static int make_magnitude_modifier(struct iforce* iforce,\r\nstruct resource* mod_chunk, int no_alloc, __s16 level)\r\n{\r\nunsigned char data[3];\r\nif (!no_alloc) {\r\nmutex_lock(&iforce->mem_mutex);\r\nif (allocate_resource(&(iforce->device_memory), mod_chunk, 2,\r\niforce->device_memory.start, iforce->device_memory.end, 2L,\r\nNULL, NULL)) {\r\nmutex_unlock(&iforce->mem_mutex);\r\nreturn -ENOSPC;\r\n}\r\nmutex_unlock(&iforce->mem_mutex);\r\n}\r\ndata[0] = LO(mod_chunk->start);\r\ndata[1] = HI(mod_chunk->start);\r\ndata[2] = HIFIX80(level);\r\niforce_send_packet(iforce, FF_CMD_MAGNITUDE, data);\r\niforce_dump_packet("magnitude: ", FF_CMD_MAGNITUDE, data);\r\nreturn 0;\r\n}\r\nstatic int make_period_modifier(struct iforce* iforce,\r\nstruct resource* mod_chunk, int no_alloc,\r\n__s16 magnitude, __s16 offset, u16 period, u16 phase)\r\n{\r\nunsigned char data[7];\r\nperiod = TIME_SCALE(period);\r\nif (!no_alloc) {\r\nmutex_lock(&iforce->mem_mutex);\r\nif (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0c,\r\niforce->device_memory.start, iforce->device_memory.end, 2L,\r\nNULL, NULL)) {\r\nmutex_unlock(&iforce->mem_mutex);\r\nreturn -ENOSPC;\r\n}\r\nmutex_unlock(&iforce->mem_mutex);\r\n}\r\ndata[0] = LO(mod_chunk->start);\r\ndata[1] = HI(mod_chunk->start);\r\ndata[2] = HIFIX80(magnitude);\r\ndata[3] = HIFIX80(offset);\r\ndata[4] = HI(phase);\r\ndata[5] = LO(period);\r\ndata[6] = HI(period);\r\niforce_send_packet(iforce, FF_CMD_PERIOD, data);\r\nreturn 0;\r\n}\r\nstatic int make_envelope_modifier(struct iforce* iforce,\r\nstruct resource* mod_chunk, int no_alloc,\r\nu16 attack_duration, __s16 initial_level,\r\nu16 fade_duration, __s16 final_level)\r\n{\r\nunsigned char data[8];\r\nattack_duration = TIME_SCALE(attack_duration);\r\nfade_duration = TIME_SCALE(fade_duration);\r\nif (!no_alloc) {\r\nmutex_lock(&iforce->mem_mutex);\r\nif (allocate_resource(&(iforce->device_memory), mod_chunk, 0x0e,\r\niforce->device_memory.start, iforce->device_memory.end, 2L,\r\nNULL, NULL)) {\r\nmutex_unlock(&iforce->mem_mutex);\r\nreturn -ENOSPC;\r\n}\r\nmutex_unlock(&iforce->mem_mutex);\r\n}\r\ndata[0] = LO(mod_chunk->start);\r\ndata[1] = HI(mod_chunk->start);\r\ndata[2] = LO(attack_duration);\r\ndata[3] = HI(attack_duration);\r\ndata[4] = HI(initial_level);\r\ndata[5] = LO(fade_duration);\r\ndata[6] = HI(fade_duration);\r\ndata[7] = HI(final_level);\r\niforce_send_packet(iforce, FF_CMD_ENVELOPE, data);\r\nreturn 0;\r\n}\r\nstatic int make_condition_modifier(struct iforce* iforce,\r\nstruct resource* mod_chunk, int no_alloc,\r\n__u16 rsat, __u16 lsat, __s16 rk, __s16 lk, u16 db, __s16 center)\r\n{\r\nunsigned char data[10];\r\nif (!no_alloc) {\r\nmutex_lock(&iforce->mem_mutex);\r\nif (allocate_resource(&(iforce->device_memory), mod_chunk, 8,\r\niforce->device_memory.start, iforce->device_memory.end, 2L,\r\nNULL, NULL)) {\r\nmutex_unlock(&iforce->mem_mutex);\r\nreturn -ENOSPC;\r\n}\r\nmutex_unlock(&iforce->mem_mutex);\r\n}\r\ndata[0] = LO(mod_chunk->start);\r\ndata[1] = HI(mod_chunk->start);\r\ndata[2] = (100 * rk) >> 15;\r\ndata[3] = (100 * lk) >> 15;\r\ncenter = (500 * center) >> 15;\r\ndata[4] = LO(center);\r\ndata[5] = HI(center);\r\ndb = (1000 * db) >> 16;\r\ndata[6] = LO(db);\r\ndata[7] = HI(db);\r\ndata[8] = (100 * rsat) >> 16;\r\ndata[9] = (100 * lsat) >> 16;\r\niforce_send_packet(iforce, FF_CMD_CONDITION, data);\r\niforce_dump_packet("condition", FF_CMD_CONDITION, data);\r\nreturn 0;\r\n}\r\nstatic unsigned char find_button(struct iforce *iforce, signed short button)\r\n{\r\nint i;\r\nfor (i = 1; iforce->type->btn[i] >= 0; i++)\r\nif (iforce->type->btn[i] == button)\r\nreturn i + 1;\r\nreturn 0;\r\n}\r\nstatic int need_condition_modifier(struct iforce *iforce,\r\nstruct ff_effect *old,\r\nstruct ff_effect *new)\r\n{\r\nint ret = 0;\r\nint i;\r\nif (new->type != FF_SPRING && new->type != FF_FRICTION) {\r\ndev_warn(&iforce->dev->dev, "bad effect type in %s\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nret |= old->u.condition[i].right_saturation != new->u.condition[i].right_saturation\r\n|| old->u.condition[i].left_saturation != new->u.condition[i].left_saturation\r\n|| old->u.condition[i].right_coeff != new->u.condition[i].right_coeff\r\n|| old->u.condition[i].left_coeff != new->u.condition[i].left_coeff\r\n|| old->u.condition[i].deadband != new->u.condition[i].deadband\r\n|| old->u.condition[i].center != new->u.condition[i].center;\r\n}\r\nreturn ret;\r\n}\r\nstatic int need_magnitude_modifier(struct iforce *iforce,\r\nstruct ff_effect *old,\r\nstruct ff_effect *effect)\r\n{\r\nif (effect->type != FF_CONSTANT) {\r\ndev_warn(&iforce->dev->dev, "bad effect type in %s\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nreturn old->u.constant.level != effect->u.constant.level;\r\n}\r\nstatic int need_envelope_modifier(struct iforce *iforce, struct ff_effect *old,\r\nstruct ff_effect *effect)\r\n{\r\nswitch (effect->type) {\r\ncase FF_CONSTANT:\r\nif (old->u.constant.envelope.attack_length != effect->u.constant.envelope.attack_length\r\n|| old->u.constant.envelope.attack_level != effect->u.constant.envelope.attack_level\r\n|| old->u.constant.envelope.fade_length != effect->u.constant.envelope.fade_length\r\n|| old->u.constant.envelope.fade_level != effect->u.constant.envelope.fade_level)\r\nreturn 1;\r\nbreak;\r\ncase FF_PERIODIC:\r\nif (old->u.periodic.envelope.attack_length != effect->u.periodic.envelope.attack_length\r\n|| old->u.periodic.envelope.attack_level != effect->u.periodic.envelope.attack_level\r\n|| old->u.periodic.envelope.fade_length != effect->u.periodic.envelope.fade_length\r\n|| old->u.periodic.envelope.fade_level != effect->u.periodic.envelope.fade_level)\r\nreturn 1;\r\nbreak;\r\ndefault:\r\ndev_warn(&iforce->dev->dev, "bad effect type in %s\n",\r\n__func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic int need_period_modifier(struct iforce *iforce, struct ff_effect *old,\r\nstruct ff_effect *new)\r\n{\r\nif (new->type != FF_PERIODIC) {\r\ndev_warn(&iforce->dev->dev, "bad effect type in %s\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nreturn (old->u.periodic.period != new->u.periodic.period\r\n|| old->u.periodic.magnitude != new->u.periodic.magnitude\r\n|| old->u.periodic.offset != new->u.periodic.offset\r\n|| old->u.periodic.phase != new->u.periodic.phase);\r\n}\r\nstatic int need_core(struct ff_effect *old, struct ff_effect *new)\r\n{\r\nif (old->direction != new->direction\r\n|| old->trigger.button != new->trigger.button\r\n|| old->trigger.interval != new->trigger.interval\r\n|| old->replay.length != new->replay.length\r\n|| old->replay.delay != new->replay.delay)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int make_core(struct iforce* iforce, u16 id, u16 mod_id1, u16 mod_id2,\r\nu8 effect_type, u8 axes, u16 duration, u16 delay, u16 button,\r\nu16 interval, u16 direction)\r\n{\r\nunsigned char data[14];\r\nduration = TIME_SCALE(duration);\r\ndelay = TIME_SCALE(delay);\r\ninterval = TIME_SCALE(interval);\r\ndata[0] = LO(id);\r\ndata[1] = effect_type;\r\ndata[2] = LO(axes) | find_button(iforce, button);\r\ndata[3] = LO(duration);\r\ndata[4] = HI(duration);\r\ndata[5] = HI(direction);\r\ndata[6] = LO(interval);\r\ndata[7] = HI(interval);\r\ndata[8] = LO(mod_id1);\r\ndata[9] = HI(mod_id1);\r\ndata[10] = LO(mod_id2);\r\ndata[11] = HI(mod_id2);\r\ndata[12] = LO(delay);\r\ndata[13] = HI(delay);\r\niforce_send_packet(iforce, FF_CMD_EFFECT, data);\r\nif (test_bit(FF_CORE_SHOULD_PLAY, iforce->core_effects[id].flags)) {\r\niforce_control_playback(iforce, id, 1);\r\n}\r\nreturn 0;\r\n}\r\nint iforce_upload_periodic(struct iforce *iforce, struct ff_effect *effect, struct ff_effect *old)\r\n{\r\nu8 wave_code;\r\nint core_id = effect->id;\r\nstruct iforce_core_effect* core_effect = iforce->core_effects + core_id;\r\nstruct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);\r\nstruct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);\r\nint param1_err = 1;\r\nint param2_err = 1;\r\nint core_err = 0;\r\nif (!old || need_period_modifier(iforce, old, effect)) {\r\nparam1_err = make_period_modifier(iforce, mod1_chunk,\r\nold != NULL,\r\neffect->u.periodic.magnitude, effect->u.periodic.offset,\r\neffect->u.periodic.period, effect->u.periodic.phase);\r\nif (param1_err)\r\nreturn param1_err;\r\nset_bit(FF_MOD1_IS_USED, core_effect->flags);\r\n}\r\nif (!old || need_envelope_modifier(iforce, old, effect)) {\r\nparam2_err = make_envelope_modifier(iforce, mod2_chunk,\r\nold !=NULL,\r\neffect->u.periodic.envelope.attack_length,\r\neffect->u.periodic.envelope.attack_level,\r\neffect->u.periodic.envelope.fade_length,\r\neffect->u.periodic.envelope.fade_level);\r\nif (param2_err)\r\nreturn param2_err;\r\nset_bit(FF_MOD2_IS_USED, core_effect->flags);\r\n}\r\nswitch (effect->u.periodic.waveform) {\r\ncase FF_SQUARE: wave_code = 0x20; break;\r\ncase FF_TRIANGLE: wave_code = 0x21; break;\r\ncase FF_SINE: wave_code = 0x22; break;\r\ncase FF_SAW_UP: wave_code = 0x23; break;\r\ncase FF_SAW_DOWN: wave_code = 0x24; break;\r\ndefault: wave_code = 0x20; break;\r\n}\r\nif (!old || need_core(old, effect)) {\r\ncore_err = make_core(iforce, effect->id,\r\nmod1_chunk->start,\r\nmod2_chunk->start,\r\nwave_code,\r\n0x20,\r\neffect->replay.length,\r\neffect->replay.delay,\r\neffect->trigger.button,\r\neffect->trigger.interval,\r\neffect->direction);\r\n}\r\nreturn core_err < 0 ? core_err : (param1_err && param2_err);\r\n}\r\nint iforce_upload_constant(struct iforce *iforce, struct ff_effect *effect, struct ff_effect *old)\r\n{\r\nint core_id = effect->id;\r\nstruct iforce_core_effect* core_effect = iforce->core_effects + core_id;\r\nstruct resource* mod1_chunk = &(iforce->core_effects[core_id].mod1_chunk);\r\nstruct resource* mod2_chunk = &(iforce->core_effects[core_id].mod2_chunk);\r\nint param1_err = 1;\r\nint param2_err = 1;\r\nint core_err = 0;\r\nif (!old || need_magnitude_modifier(iforce, old, effect)) {\r\nparam1_err = make_magnitude_modifier(iforce, mod1_chunk,\r\nold != NULL,\r\neffect->u.constant.level);\r\nif (param1_err)\r\nreturn param1_err;\r\nset_bit(FF_MOD1_IS_USED, core_effect->flags);\r\n}\r\nif (!old || need_envelope_modifier(iforce, old, effect)) {\r\nparam2_err = make_envelope_modifier(iforce, mod2_chunk,\r\nold != NULL,\r\neffect->u.constant.envelope.attack_length,\r\neffect->u.constant.envelope.attack_level,\r\neffect->u.constant.envelope.fade_length,\r\neffect->u.constant.envelope.fade_level);\r\nif (param2_err)\r\nreturn param2_err;\r\nset_bit(FF_MOD2_IS_USED, core_effect->flags);\r\n}\r\nif (!old || need_core(old, effect)) {\r\ncore_err = make_core(iforce, effect->id,\r\nmod1_chunk->start,\r\nmod2_chunk->start,\r\n0x00,\r\n0x20,\r\neffect->replay.length,\r\neffect->replay.delay,\r\neffect->trigger.button,\r\neffect->trigger.interval,\r\neffect->direction);\r\n}\r\nreturn core_err < 0 ? core_err : (param1_err && param2_err);\r\n}\r\nint iforce_upload_condition(struct iforce *iforce, struct ff_effect *effect, struct ff_effect *old)\r\n{\r\nint core_id = effect->id;\r\nstruct iforce_core_effect* core_effect = iforce->core_effects + core_id;\r\nstruct resource* mod1_chunk = &(core_effect->mod1_chunk);\r\nstruct resource* mod2_chunk = &(core_effect->mod2_chunk);\r\nu8 type;\r\nint param_err = 1;\r\nint core_err = 0;\r\nswitch (effect->type) {\r\ncase FF_SPRING: type = 0x40; break;\r\ncase FF_DAMPER: type = 0x41; break;\r\ndefault: return -1;\r\n}\r\nif (!old || need_condition_modifier(iforce, old, effect)) {\r\nparam_err = make_condition_modifier(iforce, mod1_chunk,\r\nold != NULL,\r\neffect->u.condition[0].right_saturation,\r\neffect->u.condition[0].left_saturation,\r\neffect->u.condition[0].right_coeff,\r\neffect->u.condition[0].left_coeff,\r\neffect->u.condition[0].deadband,\r\neffect->u.condition[0].center);\r\nif (param_err)\r\nreturn param_err;\r\nset_bit(FF_MOD1_IS_USED, core_effect->flags);\r\nparam_err = make_condition_modifier(iforce, mod2_chunk,\r\nold != NULL,\r\neffect->u.condition[1].right_saturation,\r\neffect->u.condition[1].left_saturation,\r\neffect->u.condition[1].right_coeff,\r\neffect->u.condition[1].left_coeff,\r\neffect->u.condition[1].deadband,\r\neffect->u.condition[1].center);\r\nif (param_err)\r\nreturn param_err;\r\nset_bit(FF_MOD2_IS_USED, core_effect->flags);\r\n}\r\nif (!old || need_core(old, effect)) {\r\ncore_err = make_core(iforce, effect->id,\r\nmod1_chunk->start, mod2_chunk->start,\r\ntype, 0xc0,\r\neffect->replay.length, effect->replay.delay,\r\neffect->trigger.button, effect->trigger.interval,\r\neffect->direction);\r\n}\r\nreturn core_err < 0 ? core_err : param_err;\r\n}
