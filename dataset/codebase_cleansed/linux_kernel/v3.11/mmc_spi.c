static inline int mmc_cs_off(struct mmc_spi_host *host)\r\n{\r\nreturn spi_setup(host->spi);\r\n}\r\nstatic int\r\nmmc_spi_readbytes(struct mmc_spi_host *host, unsigned len)\r\n{\r\nint status;\r\nif (len > sizeof(*host->data)) {\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nhost->status.len = len;\r\nif (host->dma_dev)\r\ndma_sync_single_for_device(host->dma_dev,\r\nhost->data_dma, sizeof(*host->data),\r\nDMA_FROM_DEVICE);\r\nstatus = spi_sync_locked(host->spi, &host->readback);\r\nif (host->dma_dev)\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nhost->data_dma, sizeof(*host->data),\r\nDMA_FROM_DEVICE);\r\nreturn status;\r\n}\r\nstatic int mmc_spi_skip(struct mmc_spi_host *host, unsigned long timeout,\r\nunsigned n, u8 byte)\r\n{\r\nu8 *cp = host->data->status;\r\nunsigned long start = jiffies;\r\nwhile (1) {\r\nint status;\r\nunsigned i;\r\nstatus = mmc_spi_readbytes(host, n);\r\nif (status < 0)\r\nreturn status;\r\nfor (i = 0; i < n; i++) {\r\nif (cp[i] != byte)\r\nreturn cp[i];\r\n}\r\nif (time_is_before_jiffies(start + timeout))\r\nbreak;\r\nif (time_is_before_jiffies(start+1))\r\nschedule();\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int\r\nmmc_spi_wait_unbusy(struct mmc_spi_host *host, unsigned long timeout)\r\n{\r\nreturn mmc_spi_skip(host, timeout, sizeof(host->data->status), 0);\r\n}\r\nstatic int mmc_spi_readtoken(struct mmc_spi_host *host, unsigned long timeout)\r\n{\r\nreturn mmc_spi_skip(host, timeout, 1, 0xff);\r\n}\r\nstatic char *maptype(struct mmc_command *cmd)\r\n{\r\nswitch (mmc_spi_resp_type(cmd)) {\r\ncase MMC_RSP_SPI_R1: return "R1";\r\ncase MMC_RSP_SPI_R1B: return "R1B";\r\ncase MMC_RSP_SPI_R2: return "R2/R5";\r\ncase MMC_RSP_SPI_R3: return "R3/R4/R7";\r\ndefault: return "?";\r\n}\r\n}\r\nstatic int mmc_spi_response_get(struct mmc_spi_host *host,\r\nstruct mmc_command *cmd, int cs_on)\r\n{\r\nu8 *cp = host->data->status;\r\nu8 *end = cp + host->t.len;\r\nint value = 0;\r\nint bitshift;\r\nu8 leftover = 0;\r\nunsigned short rotator;\r\nint i;\r\nchar tag[32];\r\nsnprintf(tag, sizeof(tag), " ... CMD%d response SPI_%s",\r\ncmd->opcode, maptype(cmd));\r\ncp += 8;\r\nwhile (cp < end && *cp == 0xff)\r\ncp++;\r\nif (cp == end) {\r\ncp = host->data->status;\r\nend = cp+1;\r\nfor (i = 2; i < 16; i++) {\r\nvalue = mmc_spi_readbytes(host, 1);\r\nif (value < 0)\r\ngoto done;\r\nif (*cp != 0xff)\r\ngoto checkstatus;\r\n}\r\nvalue = -ETIMEDOUT;\r\ngoto done;\r\n}\r\ncheckstatus:\r\nbitshift = 0;\r\nif (*cp & 0x80) {\r\nrotator = *cp++ << 8;\r\nif (cp == end) {\r\nvalue = mmc_spi_readbytes(host, 1);\r\nif (value < 0)\r\ngoto done;\r\ncp = host->data->status;\r\nend = cp+1;\r\n}\r\nrotator |= *cp++;\r\nwhile (rotator & 0x8000) {\r\nbitshift++;\r\nrotator <<= 1;\r\n}\r\ncmd->resp[0] = rotator >> 8;\r\nleftover = rotator;\r\n} else {\r\ncmd->resp[0] = *cp++;\r\n}\r\ncmd->error = 0;\r\nif (cmd->resp[0] != 0) {\r\nif ((R1_SPI_PARAMETER | R1_SPI_ADDRESS)\r\n& cmd->resp[0])\r\nvalue = -EFAULT;\r\nelse if (R1_SPI_ILLEGAL_COMMAND & cmd->resp[0])\r\nvalue = -ENOSYS;\r\nelse if (R1_SPI_COM_CRC & cmd->resp[0])\r\nvalue = -EILSEQ;\r\nelse if ((R1_SPI_ERASE_SEQ | R1_SPI_ERASE_RESET)\r\n& cmd->resp[0])\r\nvalue = -EIO;\r\n}\r\nswitch (mmc_spi_resp_type(cmd)) {\r\ncase MMC_RSP_SPI_R1B:\r\nwhile (cp < end && *cp == 0)\r\ncp++;\r\nif (cp == end)\r\nmmc_spi_wait_unbusy(host, r1b_timeout);\r\nbreak;\r\ncase MMC_RSP_SPI_R2:\r\nif (cp == end) {\r\nvalue = mmc_spi_readbytes(host, 1);\r\nif (value < 0)\r\ngoto done;\r\ncp = host->data->status;\r\nend = cp+1;\r\n}\r\nif (bitshift) {\r\nrotator = leftover << 8;\r\nrotator |= *cp << bitshift;\r\ncmd->resp[0] |= (rotator & 0xFF00);\r\n} else {\r\ncmd->resp[0] |= *cp << 8;\r\n}\r\nbreak;\r\ncase MMC_RSP_SPI_R3:\r\nrotator = leftover << 8;\r\ncmd->resp[1] = 0;\r\nfor (i = 0; i < 4; i++) {\r\ncmd->resp[1] <<= 8;\r\nif (cp == end) {\r\nvalue = mmc_spi_readbytes(host, 1);\r\nif (value < 0)\r\ngoto done;\r\ncp = host->data->status;\r\nend = cp+1;\r\n}\r\nif (bitshift) {\r\nrotator |= *cp++ << bitshift;\r\ncmd->resp[1] |= (rotator >> 8);\r\nrotator <<= 8;\r\n} else {\r\ncmd->resp[1] |= *cp++;\r\n}\r\n}\r\nbreak;\r\ncase MMC_RSP_SPI_R1:\r\nbreak;\r\ndefault:\r\ndev_dbg(&host->spi->dev, "bad response type %04x\n",\r\nmmc_spi_resp_type(cmd));\r\nif (value >= 0)\r\nvalue = -EINVAL;\r\ngoto done;\r\n}\r\nif (value < 0)\r\ndev_dbg(&host->spi->dev, "%s: resp %04x %08x\n",\r\ntag, cmd->resp[0], cmd->resp[1]);\r\nif (value >= 0 && cs_on)\r\nreturn value;\r\ndone:\r\nif (value < 0)\r\ncmd->error = value;\r\nmmc_cs_off(host);\r\nreturn value;\r\n}\r\nstatic int\r\nmmc_spi_command_send(struct mmc_spi_host *host,\r\nstruct mmc_request *mrq,\r\nstruct mmc_command *cmd, int cs_on)\r\n{\r\nstruct scratch *data = host->data;\r\nu8 *cp = data->status;\r\nu32 arg = cmd->arg;\r\nint status;\r\nstruct spi_transfer *t;\r\nmemset(cp++, 0xff, sizeof(data->status));\r\n*cp++ = 0x40 | cmd->opcode;\r\n*cp++ = (u8)(arg >> 24);\r\n*cp++ = (u8)(arg >> 16);\r\n*cp++ = (u8)(arg >> 8);\r\n*cp++ = (u8)arg;\r\n*cp++ = (crc7(0, &data->status[1], 5) << 1) | 0x01;\r\nif (cs_on && (mrq->data->flags & MMC_DATA_READ)) {\r\ncp += 2;\r\n} else {\r\ncp += 10;\r\nif (cmd->flags & MMC_RSP_SPI_S2)\r\ncp++;\r\nelse if (cmd->flags & MMC_RSP_SPI_B4)\r\ncp += 4;\r\nelse if (cmd->flags & MMC_RSP_BUSY)\r\ncp = data->status + sizeof(data->status);\r\n}\r\ndev_dbg(&host->spi->dev, " mmc_spi: CMD%d, resp %s\n",\r\ncmd->opcode, maptype(cmd));\r\nspi_message_init(&host->m);\r\nt = &host->t;\r\nmemset(t, 0, sizeof(*t));\r\nt->tx_buf = t->rx_buf = data->status;\r\nt->tx_dma = t->rx_dma = host->data_dma;\r\nt->len = cp - data->status;\r\nt->cs_change = 1;\r\nspi_message_add_tail(t, &host->m);\r\nif (host->dma_dev) {\r\nhost->m.is_dma_mapped = 1;\r\ndma_sync_single_for_device(host->dma_dev,\r\nhost->data_dma, sizeof(*host->data),\r\nDMA_BIDIRECTIONAL);\r\n}\r\nstatus = spi_sync_locked(host->spi, &host->m);\r\nif (host->dma_dev)\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nhost->data_dma, sizeof(*host->data),\r\nDMA_BIDIRECTIONAL);\r\nif (status < 0) {\r\ndev_dbg(&host->spi->dev, " ... write returned %d\n", status);\r\ncmd->error = status;\r\nreturn status;\r\n}\r\nreturn mmc_spi_response_get(host, cmd, cs_on);\r\n}\r\nstatic void\r\nmmc_spi_setup_data_message(\r\nstruct mmc_spi_host *host,\r\nint multiple,\r\nenum dma_data_direction direction)\r\n{\r\nstruct spi_transfer *t;\r\nstruct scratch *scratch = host->data;\r\ndma_addr_t dma = host->data_dma;\r\nspi_message_init(&host->m);\r\nif (dma)\r\nhost->m.is_dma_mapped = 1;\r\nif (direction == DMA_TO_DEVICE) {\r\nt = &host->token;\r\nmemset(t, 0, sizeof(*t));\r\nt->len = 1;\r\nif (multiple)\r\nscratch->data_token = SPI_TOKEN_MULTI_WRITE;\r\nelse\r\nscratch->data_token = SPI_TOKEN_SINGLE;\r\nt->tx_buf = &scratch->data_token;\r\nif (dma)\r\nt->tx_dma = dma + offsetof(struct scratch, data_token);\r\nspi_message_add_tail(t, &host->m);\r\n}\r\nt = &host->t;\r\nmemset(t, 0, sizeof(*t));\r\nt->tx_buf = host->ones;\r\nt->tx_dma = host->ones_dma;\r\nspi_message_add_tail(t, &host->m);\r\nt = &host->crc;\r\nmemset(t, 0, sizeof(*t));\r\nt->len = 2;\r\nif (direction == DMA_TO_DEVICE) {\r\nt->tx_buf = &scratch->crc_val;\r\nif (dma)\r\nt->tx_dma = dma + offsetof(struct scratch, crc_val);\r\n} else {\r\nt->tx_buf = host->ones;\r\nt->tx_dma = host->ones_dma;\r\nt->rx_buf = &scratch->crc_val;\r\nif (dma)\r\nt->rx_dma = dma + offsetof(struct scratch, crc_val);\r\n}\r\nspi_message_add_tail(t, &host->m);\r\nif (multiple || direction == DMA_TO_DEVICE) {\r\nt = &host->early_status;\r\nmemset(t, 0, sizeof(*t));\r\nt->len = (direction == DMA_TO_DEVICE)\r\n? sizeof(scratch->status)\r\n: 1;\r\nt->tx_buf = host->ones;\r\nt->tx_dma = host->ones_dma;\r\nt->rx_buf = scratch->status;\r\nif (dma)\r\nt->rx_dma = dma + offsetof(struct scratch, status);\r\nt->cs_change = 1;\r\nspi_message_add_tail(t, &host->m);\r\n}\r\n}\r\nstatic int\r\nmmc_spi_writeblock(struct mmc_spi_host *host, struct spi_transfer *t,\r\nunsigned long timeout)\r\n{\r\nstruct spi_device *spi = host->spi;\r\nint status, i;\r\nstruct scratch *scratch = host->data;\r\nu32 pattern;\r\nif (host->mmc->use_spi_crc)\r\nscratch->crc_val = cpu_to_be16(\r\ncrc_itu_t(0, t->tx_buf, t->len));\r\nif (host->dma_dev)\r\ndma_sync_single_for_device(host->dma_dev,\r\nhost->data_dma, sizeof(*scratch),\r\nDMA_BIDIRECTIONAL);\r\nstatus = spi_sync_locked(spi, &host->m);\r\nif (status != 0) {\r\ndev_dbg(&spi->dev, "write error (%d)\n", status);\r\nreturn status;\r\n}\r\nif (host->dma_dev)\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nhost->data_dma, sizeof(*scratch),\r\nDMA_BIDIRECTIONAL);\r\npattern = scratch->status[0] << 24;\r\npattern |= scratch->status[1] << 16;\r\npattern |= scratch->status[2] << 8;\r\npattern |= scratch->status[3];\r\npattern |= 0xE0000000;\r\nwhile (pattern & 0x80000000)\r\npattern <<= 1;\r\npattern >>= 27;\r\nswitch (pattern) {\r\ncase SPI_RESPONSE_ACCEPTED:\r\nstatus = 0;\r\nbreak;\r\ncase SPI_RESPONSE_CRC_ERR:\r\nstatus = -EILSEQ;\r\nbreak;\r\ncase SPI_RESPONSE_WRITE_ERR:\r\nstatus = -EIO;\r\nbreak;\r\ndefault:\r\nstatus = -EPROTO;\r\nbreak;\r\n}\r\nif (status != 0) {\r\ndev_dbg(&spi->dev, "write error %02x (%d)\n",\r\nscratch->status[0], status);\r\nreturn status;\r\n}\r\nt->tx_buf += t->len;\r\nif (host->dma_dev)\r\nt->tx_dma += t->len;\r\nfor (i = 4; i < sizeof(scratch->status); i++) {\r\nif (scratch->status[i] & 0x01)\r\nreturn 0;\r\n}\r\nreturn mmc_spi_wait_unbusy(host, timeout);\r\n}\r\nstatic int\r\nmmc_spi_readblock(struct mmc_spi_host *host, struct spi_transfer *t,\r\nunsigned long timeout)\r\n{\r\nstruct spi_device *spi = host->spi;\r\nint status;\r\nstruct scratch *scratch = host->data;\r\nunsigned int bitshift;\r\nu8 leftover;\r\nstatus = mmc_spi_readbytes(host, 1);\r\nif (status < 0)\r\nreturn status;\r\nstatus = scratch->status[0];\r\nif (status == 0xff || status == 0)\r\nstatus = mmc_spi_readtoken(host, timeout);\r\nif (status < 0) {\r\ndev_dbg(&spi->dev, "read error %02x (%d)\n", status, status);\r\nreturn status;\r\n}\r\nbitshift = 7;\r\nwhile (status & 0x80) {\r\nstatus <<= 1;\r\nbitshift--;\r\n}\r\nleftover = status << 1;\r\nif (host->dma_dev) {\r\ndma_sync_single_for_device(host->dma_dev,\r\nhost->data_dma, sizeof(*scratch),\r\nDMA_BIDIRECTIONAL);\r\ndma_sync_single_for_device(host->dma_dev,\r\nt->rx_dma, t->len,\r\nDMA_FROM_DEVICE);\r\n}\r\nstatus = spi_sync_locked(spi, &host->m);\r\nif (host->dma_dev) {\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nhost->data_dma, sizeof(*scratch),\r\nDMA_BIDIRECTIONAL);\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nt->rx_dma, t->len,\r\nDMA_FROM_DEVICE);\r\n}\r\nif (bitshift) {\r\nu8 *cp = t->rx_buf;\r\nunsigned int len;\r\nunsigned int bitright = 8 - bitshift;\r\nu8 temp;\r\nfor (len = t->len; len; len--) {\r\ntemp = *cp;\r\n*cp++ = leftover | (temp >> bitshift);\r\nleftover = temp << bitright;\r\n}\r\ncp = (u8 *) &scratch->crc_val;\r\ntemp = *cp;\r\n*cp++ = leftover | (temp >> bitshift);\r\nleftover = temp << bitright;\r\ntemp = *cp;\r\n*cp = leftover | (temp >> bitshift);\r\n}\r\nif (host->mmc->use_spi_crc) {\r\nu16 crc = crc_itu_t(0, t->rx_buf, t->len);\r\nbe16_to_cpus(&scratch->crc_val);\r\nif (scratch->crc_val != crc) {\r\ndev_dbg(&spi->dev, "read - crc error: crc_val=0x%04x, "\r\n"computed=0x%04x len=%d\n",\r\nscratch->crc_val, crc, t->len);\r\nreturn -EILSEQ;\r\n}\r\n}\r\nt->rx_buf += t->len;\r\nif (host->dma_dev)\r\nt->rx_dma += t->len;\r\nreturn 0;\r\n}\r\nstatic void\r\nmmc_spi_data_do(struct mmc_spi_host *host, struct mmc_command *cmd,\r\nstruct mmc_data *data, u32 blk_size)\r\n{\r\nstruct spi_device *spi = host->spi;\r\nstruct device *dma_dev = host->dma_dev;\r\nstruct spi_transfer *t;\r\nenum dma_data_direction direction;\r\nstruct scatterlist *sg;\r\nunsigned n_sg;\r\nint multiple = (data->blocks > 1);\r\nu32 clock_rate;\r\nunsigned long timeout;\r\nif (data->flags & MMC_DATA_READ)\r\ndirection = DMA_FROM_DEVICE;\r\nelse\r\ndirection = DMA_TO_DEVICE;\r\nmmc_spi_setup_data_message(host, multiple, direction);\r\nt = &host->t;\r\nif (t->speed_hz)\r\nclock_rate = t->speed_hz;\r\nelse\r\nclock_rate = spi->max_speed_hz;\r\ntimeout = data->timeout_ns +\r\ndata->timeout_clks * 1000000 / clock_rate;\r\ntimeout = usecs_to_jiffies((unsigned int)(timeout / 1000)) + 1;\r\nfor (sg = data->sg, n_sg = data->sg_len; n_sg; n_sg--, sg++) {\r\nint status = 0;\r\ndma_addr_t dma_addr = 0;\r\nvoid *kmap_addr;\r\nunsigned length = sg->length;\r\nenum dma_data_direction dir = direction;\r\nif (dma_dev) {\r\nif ((sg->offset != 0 || length != PAGE_SIZE)\r\n&& dir == DMA_FROM_DEVICE)\r\ndir = DMA_BIDIRECTIONAL;\r\ndma_addr = dma_map_page(dma_dev, sg_page(sg), 0,\r\nPAGE_SIZE, dir);\r\nif (direction == DMA_TO_DEVICE)\r\nt->tx_dma = dma_addr + sg->offset;\r\nelse\r\nt->rx_dma = dma_addr + sg->offset;\r\n}\r\nkmap_addr = kmap(sg_page(sg));\r\nif (direction == DMA_TO_DEVICE)\r\nt->tx_buf = kmap_addr + sg->offset;\r\nelse\r\nt->rx_buf = kmap_addr + sg->offset;\r\nwhile (length) {\r\nt->len = min(length, blk_size);\r\ndev_dbg(&host->spi->dev,\r\n" mmc_spi: %s block, %d bytes\n",\r\n(direction == DMA_TO_DEVICE)\r\n? "write"\r\n: "read",\r\nt->len);\r\nif (direction == DMA_TO_DEVICE)\r\nstatus = mmc_spi_writeblock(host, t, timeout);\r\nelse\r\nstatus = mmc_spi_readblock(host, t, timeout);\r\nif (status < 0)\r\nbreak;\r\ndata->bytes_xfered += t->len;\r\nlength -= t->len;\r\nif (!multiple)\r\nbreak;\r\n}\r\nif (direction == DMA_FROM_DEVICE)\r\nflush_kernel_dcache_page(sg_page(sg));\r\nkunmap(sg_page(sg));\r\nif (dma_dev)\r\ndma_unmap_page(dma_dev, dma_addr, PAGE_SIZE, dir);\r\nif (status < 0) {\r\ndata->error = status;\r\ndev_dbg(&spi->dev, "%s status %d\n",\r\n(direction == DMA_TO_DEVICE)\r\n? "write" : "read",\r\nstatus);\r\nbreak;\r\n}\r\n}\r\nif (direction == DMA_TO_DEVICE && multiple) {\r\nstruct scratch *scratch = host->data;\r\nint tmp;\r\nconst unsigned statlen = sizeof(scratch->status);\r\ndev_dbg(&spi->dev, " mmc_spi: STOP_TRAN\n");\r\nINIT_LIST_HEAD(&host->m.transfers);\r\nlist_add(&host->early_status.transfer_list,\r\n&host->m.transfers);\r\nmemset(scratch->status, 0xff, statlen);\r\nscratch->status[0] = SPI_TOKEN_STOP_TRAN;\r\nhost->early_status.tx_buf = host->early_status.rx_buf;\r\nhost->early_status.tx_dma = host->early_status.rx_dma;\r\nhost->early_status.len = statlen;\r\nif (host->dma_dev)\r\ndma_sync_single_for_device(host->dma_dev,\r\nhost->data_dma, sizeof(*scratch),\r\nDMA_BIDIRECTIONAL);\r\ntmp = spi_sync_locked(spi, &host->m);\r\nif (host->dma_dev)\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nhost->data_dma, sizeof(*scratch),\r\nDMA_BIDIRECTIONAL);\r\nif (tmp < 0) {\r\nif (!data->error)\r\ndata->error = tmp;\r\nreturn;\r\n}\r\nfor (tmp = 2; tmp < statlen; tmp++) {\r\nif (scratch->status[tmp] != 0)\r\nreturn;\r\n}\r\ntmp = mmc_spi_wait_unbusy(host, timeout);\r\nif (tmp < 0 && !data->error)\r\ndata->error = tmp;\r\n}\r\n}\r\nstatic void mmc_spi_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct mmc_spi_host *host = mmc_priv(mmc);\r\nint status = -EINVAL;\r\nint crc_retry = 5;\r\nstruct mmc_command stop;\r\n#ifdef DEBUG\r\n{\r\nstruct mmc_command *cmd;\r\nint invalid = 0;\r\ncmd = mrq->cmd;\r\nif (!mmc_spi_resp_type(cmd)) {\r\ndev_dbg(&host->spi->dev, "bogus command\n");\r\ncmd->error = -EINVAL;\r\ninvalid = 1;\r\n}\r\ncmd = mrq->stop;\r\nif (cmd && !mmc_spi_resp_type(cmd)) {\r\ndev_dbg(&host->spi->dev, "bogus STOP command\n");\r\ncmd->error = -EINVAL;\r\ninvalid = 1;\r\n}\r\nif (invalid) {\r\ndump_stack();\r\nmmc_request_done(host->mmc, mrq);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nspi_bus_lock(host->spi->master);\r\ncrc_recover:\r\nstatus = mmc_spi_command_send(host, mrq, mrq->cmd, mrq->data != NULL);\r\nif (status == 0 && mrq->data) {\r\nmmc_spi_data_do(host, mrq->cmd, mrq->data, mrq->data->blksz);\r\nif (mrq->data->error == -EILSEQ && crc_retry) {\r\nstop.opcode = MMC_STOP_TRANSMISSION;\r\nstop.arg = 0;\r\nstop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;\r\nstatus = mmc_spi_command_send(host, mrq, &stop, 0);\r\ncrc_retry--;\r\nmrq->data->error = 0;\r\ngoto crc_recover;\r\n}\r\nif (mrq->stop)\r\nstatus = mmc_spi_command_send(host, mrq, mrq->stop, 0);\r\nelse\r\nmmc_cs_off(host);\r\n}\r\nspi_bus_unlock(host->spi->master);\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void mmc_spi_initsequence(struct mmc_spi_host *host)\r\n{\r\nmmc_spi_wait_unbusy(host, r1b_timeout);\r\nmmc_spi_readbytes(host, 10);\r\nhost->spi->mode |= SPI_CS_HIGH;\r\nif (spi_setup(host->spi) != 0) {\r\ndev_warn(&host->spi->dev,\r\n"can't change chip-select polarity\n");\r\nhost->spi->mode &= ~SPI_CS_HIGH;\r\n} else {\r\nmmc_spi_readbytes(host, 18);\r\nhost->spi->mode &= ~SPI_CS_HIGH;\r\nif (spi_setup(host->spi) != 0) {\r\ndev_err(&host->spi->dev,\r\n"can't restore chip-select polarity\n");\r\n}\r\n}\r\n}\r\nstatic char *mmc_powerstring(u8 power_mode)\r\n{\r\nswitch (power_mode) {\r\ncase MMC_POWER_OFF: return "off";\r\ncase MMC_POWER_UP: return "up";\r\ncase MMC_POWER_ON: return "on";\r\n}\r\nreturn "?";\r\n}\r\nstatic void mmc_spi_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mmc_spi_host *host = mmc_priv(mmc);\r\nif (host->power_mode != ios->power_mode) {\r\nint canpower;\r\ncanpower = host->pdata && host->pdata->setpower;\r\ndev_dbg(&host->spi->dev, "mmc_spi: power %s (%d)%s\n",\r\nmmc_powerstring(ios->power_mode),\r\nios->vdd,\r\ncanpower ? ", can switch" : "");\r\nif (canpower) {\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\ncase MMC_POWER_UP:\r\nhost->pdata->setpower(&host->spi->dev,\r\nios->vdd);\r\nif (ios->power_mode == MMC_POWER_UP)\r\nmsleep(host->powerup_msecs);\r\n}\r\n}\r\nif (ios->power_mode == MMC_POWER_ON)\r\nmmc_spi_initsequence(host);\r\nif (canpower && ios->power_mode == MMC_POWER_OFF) {\r\nint mres;\r\nu8 nullbyte = 0;\r\nhost->spi->mode &= ~(SPI_CPOL|SPI_CPHA);\r\nmres = spi_setup(host->spi);\r\nif (mres < 0)\r\ndev_dbg(&host->spi->dev,\r\n"switch to SPI mode 0 failed\n");\r\nif (spi_write(host->spi, &nullbyte, 1) < 0)\r\ndev_dbg(&host->spi->dev,\r\n"put spi signals to low failed\n");\r\nmsleep(10);\r\nif (mres == 0) {\r\nhost->spi->mode |= (SPI_CPOL|SPI_CPHA);\r\nmres = spi_setup(host->spi);\r\nif (mres < 0)\r\ndev_dbg(&host->spi->dev,\r\n"switch back to SPI mode 3"\r\n" failed\n");\r\n}\r\n}\r\nhost->power_mode = ios->power_mode;\r\n}\r\nif (host->spi->max_speed_hz != ios->clock && ios->clock != 0) {\r\nint status;\r\nhost->spi->max_speed_hz = ios->clock;\r\nstatus = spi_setup(host->spi);\r\ndev_dbg(&host->spi->dev,\r\n"mmc_spi: clock to %d Hz, %d\n",\r\nhost->spi->max_speed_hz, status);\r\n}\r\n}\r\nstatic int mmc_spi_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct mmc_spi_host *host = mmc_priv(mmc);\r\nif (host->pdata && host->pdata->get_ro)\r\nreturn !!host->pdata->get_ro(mmc->parent);\r\nreturn -ENOSYS;\r\n}\r\nstatic int mmc_spi_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct mmc_spi_host *host = mmc_priv(mmc);\r\nif (host->pdata && host->pdata->get_cd)\r\nreturn !!host->pdata->get_cd(mmc->parent);\r\nreturn -ENOSYS;\r\n}\r\nstatic irqreturn_t\r\nmmc_spi_detect_irq(int irq, void *mmc)\r\n{\r\nstruct mmc_spi_host *host = mmc_priv(mmc);\r\nu16 delay_msec = max(host->pdata->detect_delay, (u16)100);\r\nmmc_detect_change(mmc, msecs_to_jiffies(delay_msec));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mmc_spi_probe(struct spi_device *spi)\r\n{\r\nvoid *ones;\r\nstruct mmc_host *mmc;\r\nstruct mmc_spi_host *host;\r\nint status;\r\nif (spi->master->flags & SPI_MASTER_HALF_DUPLEX)\r\nreturn -EINVAL;\r\nif (spi->mode != SPI_MODE_3)\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nstatus = spi_setup(spi);\r\nif (status < 0) {\r\ndev_dbg(&spi->dev, "needs SPI mode %02x, %d KHz; %d\n",\r\nspi->mode, spi->max_speed_hz / 1000,\r\nstatus);\r\nreturn status;\r\n}\r\nstatus = -ENOMEM;\r\nones = kmalloc(MMC_SPI_BLOCKSIZE, GFP_KERNEL);\r\nif (!ones)\r\ngoto nomem;\r\nmemset(ones, 0xff, MMC_SPI_BLOCKSIZE);\r\nmmc = mmc_alloc_host(sizeof(*host), &spi->dev);\r\nif (!mmc)\r\ngoto nomem;\r\nmmc->ops = &mmc_spi_ops;\r\nmmc->max_blk_size = MMC_SPI_BLOCKSIZE;\r\nmmc->max_segs = MMC_SPI_BLOCKSATONCE;\r\nmmc->max_req_size = MMC_SPI_BLOCKSATONCE * MMC_SPI_BLOCKSIZE;\r\nmmc->max_blk_count = MMC_SPI_BLOCKSATONCE;\r\nmmc->caps = MMC_CAP_SPI;\r\nmmc->f_min = 400000;\r\nmmc->f_max = spi->max_speed_hz;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->spi = spi;\r\nhost->ones = ones;\r\nhost->pdata = mmc_spi_get_pdata(spi);\r\nif (host->pdata)\r\nmmc->ocr_avail = host->pdata->ocr_mask;\r\nif (!mmc->ocr_avail) {\r\ndev_warn(&spi->dev, "ASSUMING 3.2-3.4 V slot power\n");\r\nmmc->ocr_avail = MMC_VDD_32_33|MMC_VDD_33_34;\r\n}\r\nif (host->pdata && host->pdata->setpower) {\r\nhost->powerup_msecs = host->pdata->powerup_msecs;\r\nif (!host->powerup_msecs || host->powerup_msecs > 250)\r\nhost->powerup_msecs = 250;\r\n}\r\ndev_set_drvdata(&spi->dev, mmc);\r\nhost->data = kmalloc(sizeof(*host->data), GFP_KERNEL);\r\nif (!host->data)\r\ngoto fail_nobuf1;\r\nif (spi->master->dev.parent->dma_mask) {\r\nstruct device *dev = spi->master->dev.parent;\r\nhost->dma_dev = dev;\r\nhost->ones_dma = dma_map_single(dev, ones,\r\nMMC_SPI_BLOCKSIZE, DMA_TO_DEVICE);\r\nhost->data_dma = dma_map_single(dev, host->data,\r\nsizeof(*host->data), DMA_BIDIRECTIONAL);\r\ndma_sync_single_for_cpu(host->dma_dev,\r\nhost->data_dma, sizeof(*host->data),\r\nDMA_BIDIRECTIONAL);\r\n}\r\nspi_message_init(&host->readback);\r\nhost->readback.is_dma_mapped = (host->dma_dev != NULL);\r\nspi_message_add_tail(&host->status, &host->readback);\r\nhost->status.tx_buf = host->ones;\r\nhost->status.tx_dma = host->ones_dma;\r\nhost->status.rx_buf = &host->data->status;\r\nhost->status.rx_dma = host->data_dma + offsetof(struct scratch, status);\r\nhost->status.cs_change = 1;\r\nif (host->pdata && host->pdata->init) {\r\nstatus = host->pdata->init(&spi->dev, mmc_spi_detect_irq, mmc);\r\nif (status != 0)\r\ngoto fail_glue_init;\r\n}\r\nif (host->pdata)\r\nmmc->caps |= host->pdata->caps;\r\nstatus = mmc_add_host(mmc);\r\nif (status != 0)\r\ngoto fail_add_host;\r\ndev_info(&spi->dev, "SD/MMC host %s%s%s%s%s\n",\r\ndev_name(&mmc->class_dev),\r\nhost->dma_dev ? "" : ", no DMA",\r\n(host->pdata && host->pdata->get_ro)\r\n? "" : ", no WP",\r\n(host->pdata && host->pdata->setpower)\r\n? "" : ", no poweroff",\r\n(mmc->caps & MMC_CAP_NEEDS_POLL)\r\n? ", cd polling" : "");\r\nreturn 0;\r\nfail_add_host:\r\nmmc_remove_host (mmc);\r\nfail_glue_init:\r\nif (host->dma_dev)\r\ndma_unmap_single(host->dma_dev, host->data_dma,\r\nsizeof(*host->data), DMA_BIDIRECTIONAL);\r\nkfree(host->data);\r\nfail_nobuf1:\r\nmmc_free_host(mmc);\r\nmmc_spi_put_pdata(spi);\r\ndev_set_drvdata(&spi->dev, NULL);\r\nnomem:\r\nkfree(ones);\r\nreturn status;\r\n}\r\nstatic int mmc_spi_remove(struct spi_device *spi)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(&spi->dev);\r\nstruct mmc_spi_host *host;\r\nif (mmc) {\r\nhost = mmc_priv(mmc);\r\nif (host->pdata && host->pdata->exit)\r\nhost->pdata->exit(&spi->dev, mmc);\r\nmmc_remove_host(mmc);\r\nif (host->dma_dev) {\r\ndma_unmap_single(host->dma_dev, host->ones_dma,\r\nMMC_SPI_BLOCKSIZE, DMA_TO_DEVICE);\r\ndma_unmap_single(host->dma_dev, host->data_dma,\r\nsizeof(*host->data), DMA_BIDIRECTIONAL);\r\n}\r\nkfree(host->data);\r\nkfree(host->ones);\r\nspi->max_speed_hz = mmc->f_max;\r\nmmc_free_host(mmc);\r\nmmc_spi_put_pdata(spi);\r\ndev_set_drvdata(&spi->dev, NULL);\r\n}\r\nreturn 0;\r\n}
