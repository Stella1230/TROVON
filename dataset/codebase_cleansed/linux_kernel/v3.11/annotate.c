static void ins__delete(struct ins_operands *ops)\r\n{\r\nfree(ops->source.raw);\r\nfree(ops->source.name);\r\nfree(ops->target.raw);\r\nfree(ops->target.name);\r\n}\r\nstatic int ins__raw_scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nreturn scnprintf(bf, size, "%-6.6s %s", ins->name, ops->raw);\r\n}\r\nint ins__scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nif (ins->ops->scnprintf)\r\nreturn ins->ops->scnprintf(ins, bf, size, ops);\r\nreturn ins__raw_scnprintf(ins, bf, size, ops);\r\n}\r\nstatic int call__parse(struct ins_operands *ops)\r\n{\r\nchar *endptr, *tok, *name;\r\nops->target.addr = strtoull(ops->raw, &endptr, 16);\r\nname = strchr(endptr, '<');\r\nif (name == NULL)\r\ngoto indirect_call;\r\nname++;\r\ntok = strchr(name, '>');\r\nif (tok == NULL)\r\nreturn -1;\r\n*tok = '\0';\r\nops->target.name = strdup(name);\r\n*tok = '>';\r\nreturn ops->target.name == NULL ? -1 : 0;\r\nindirect_call:\r\ntok = strchr(endptr, '(');\r\nif (tok != NULL) {\r\nops->target.addr = 0;\r\nreturn 0;\r\n}\r\ntok = strchr(endptr, '*');\r\nif (tok == NULL)\r\nreturn -1;\r\nops->target.addr = strtoull(tok + 1, NULL, 16);\r\nreturn 0;\r\n}\r\nstatic int call__scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nif (ops->target.name)\r\nreturn scnprintf(bf, size, "%-6.6s %s", ins->name, ops->target.name);\r\nif (ops->target.addr == 0)\r\nreturn ins__raw_scnprintf(ins, bf, size, ops);\r\nreturn scnprintf(bf, size, "%-6.6s *%" PRIx64, ins->name, ops->target.addr);\r\n}\r\nbool ins__is_call(const struct ins *ins)\r\n{\r\nreturn ins->ops == &call_ops;\r\n}\r\nstatic int jump__parse(struct ins_operands *ops)\r\n{\r\nconst char *s = strchr(ops->raw, '+');\r\nops->target.addr = strtoll(ops->raw, NULL, 16);\r\nif (s++ != NULL)\r\nops->target.offset = strtoll(s, NULL, 16);\r\nelse\r\nops->target.offset = UINT64_MAX;\r\nreturn 0;\r\n}\r\nstatic int jump__scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nreturn scnprintf(bf, size, "%-6.6s %" PRIx64, ins->name, ops->target.offset);\r\n}\r\nbool ins__is_jump(const struct ins *ins)\r\n{\r\nreturn ins->ops == &jump_ops;\r\n}\r\nstatic int comment__symbol(char *raw, char *comment, u64 *addrp, char **namep)\r\n{\r\nchar *endptr, *name, *t;\r\nif (strstr(raw, "(%rip)") == NULL)\r\nreturn 0;\r\n*addrp = strtoull(comment, &endptr, 16);\r\nname = strchr(endptr, '<');\r\nif (name == NULL)\r\nreturn -1;\r\nname++;\r\nt = strchr(name, '>');\r\nif (t == NULL)\r\nreturn 0;\r\n*t = '\0';\r\n*namep = strdup(name);\r\n*t = '>';\r\nreturn 0;\r\n}\r\nstatic int lock__parse(struct ins_operands *ops)\r\n{\r\nchar *name;\r\nops->locked.ops = zalloc(sizeof(*ops->locked.ops));\r\nif (ops->locked.ops == NULL)\r\nreturn 0;\r\nif (disasm_line__parse(ops->raw, &name, &ops->locked.ops->raw) < 0)\r\ngoto out_free_ops;\r\nops->locked.ins = ins__find(name);\r\nif (ops->locked.ins == NULL)\r\ngoto out_free_ops;\r\nif (!ops->locked.ins->ops)\r\nreturn 0;\r\nif (ops->locked.ins->ops->parse)\r\nops->locked.ins->ops->parse(ops->locked.ops);\r\nreturn 0;\r\nout_free_ops:\r\nfree(ops->locked.ops);\r\nops->locked.ops = NULL;\r\nreturn 0;\r\n}\r\nstatic int lock__scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nint printed;\r\nif (ops->locked.ins == NULL)\r\nreturn ins__raw_scnprintf(ins, bf, size, ops);\r\nprinted = scnprintf(bf, size, "%-6.6s ", ins->name);\r\nreturn printed + ins__scnprintf(ops->locked.ins, bf + printed,\r\nsize - printed, ops->locked.ops);\r\n}\r\nstatic void lock__delete(struct ins_operands *ops)\r\n{\r\nfree(ops->locked.ops);\r\nfree(ops->target.raw);\r\nfree(ops->target.name);\r\n}\r\nstatic int mov__parse(struct ins_operands *ops)\r\n{\r\nchar *s = strchr(ops->raw, ','), *target, *comment, prev;\r\nif (s == NULL)\r\nreturn -1;\r\n*s = '\0';\r\nops->source.raw = strdup(ops->raw);\r\n*s = ',';\r\nif (ops->source.raw == NULL)\r\nreturn -1;\r\ntarget = ++s;\r\nwhile (s[0] != '\0' && !isspace(s[0]))\r\n++s;\r\nprev = *s;\r\n*s = '\0';\r\nops->target.raw = strdup(target);\r\n*s = prev;\r\nif (ops->target.raw == NULL)\r\ngoto out_free_source;\r\ncomment = strchr(s, '#');\r\nif (comment == NULL)\r\nreturn 0;\r\nwhile (comment[0] != '\0' && isspace(comment[0]))\r\n++comment;\r\ncomment__symbol(ops->source.raw, comment, &ops->source.addr, &ops->source.name);\r\ncomment__symbol(ops->target.raw, comment, &ops->target.addr, &ops->target.name);\r\nreturn 0;\r\nout_free_source:\r\nfree(ops->source.raw);\r\nops->source.raw = NULL;\r\nreturn -1;\r\n}\r\nstatic int mov__scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nreturn scnprintf(bf, size, "%-6.6s %s,%s", ins->name,\r\nops->source.name ?: ops->source.raw,\r\nops->target.name ?: ops->target.raw);\r\n}\r\nstatic int dec__parse(struct ins_operands *ops)\r\n{\r\nchar *target, *comment, *s, prev;\r\ntarget = s = ops->raw;\r\nwhile (s[0] != '\0' && !isspace(s[0]))\r\n++s;\r\nprev = *s;\r\n*s = '\0';\r\nops->target.raw = strdup(target);\r\n*s = prev;\r\nif (ops->target.raw == NULL)\r\nreturn -1;\r\ncomment = strchr(s, '#');\r\nif (comment == NULL)\r\nreturn 0;\r\nwhile (comment[0] != '\0' && isspace(comment[0]))\r\n++comment;\r\ncomment__symbol(ops->target.raw, comment, &ops->target.addr, &ops->target.name);\r\nreturn 0;\r\n}\r\nstatic int dec__scnprintf(struct ins *ins, char *bf, size_t size,\r\nstruct ins_operands *ops)\r\n{\r\nreturn scnprintf(bf, size, "%-6.6s %s", ins->name,\r\nops->target.name ?: ops->target.raw);\r\n}\r\nstatic int nop__scnprintf(struct ins *ins __maybe_unused, char *bf, size_t size,\r\nstruct ins_operands *ops __maybe_unused)\r\n{\r\nreturn scnprintf(bf, size, "%-6.6s", "nop");\r\n}\r\nstatic int ins__cmp(const void *name, const void *insp)\r\n{\r\nconst struct ins *ins = insp;\r\nreturn strcmp(name, ins->name);\r\n}\r\nstatic struct ins *ins__find(const char *name)\r\n{\r\nconst int nmemb = ARRAY_SIZE(instructions);\r\nreturn bsearch(name, instructions, nmemb, sizeof(struct ins), ins__cmp);\r\n}\r\nint symbol__annotate_init(struct map *map __maybe_unused, struct symbol *sym)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\npthread_mutex_init(&notes->lock, NULL);\r\nreturn 0;\r\n}\r\nint symbol__alloc_hist(struct symbol *sym)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nconst size_t size = symbol__size(sym);\r\nsize_t sizeof_sym_hist;\r\nif (size > (SIZE_MAX - sizeof(struct sym_hist)) / sizeof(u64))\r\nreturn -1;\r\nsizeof_sym_hist = (sizeof(struct sym_hist) + size * sizeof(u64));\r\nif (sizeof_sym_hist > (SIZE_MAX - sizeof(*notes->src))\r\n/ symbol_conf.nr_events)\r\nreturn -1;\r\nnotes->src = zalloc(sizeof(*notes->src) + symbol_conf.nr_events * sizeof_sym_hist);\r\nif (notes->src == NULL)\r\nreturn -1;\r\nnotes->src->sizeof_sym_hist = sizeof_sym_hist;\r\nnotes->src->nr_histograms = symbol_conf.nr_events;\r\nINIT_LIST_HEAD(&notes->src->source);\r\nreturn 0;\r\n}\r\nvoid symbol__annotate_zero_histograms(struct symbol *sym)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\npthread_mutex_lock(&notes->lock);\r\nif (notes->src != NULL)\r\nmemset(notes->src->histograms, 0,\r\nnotes->src->nr_histograms * notes->src->sizeof_sym_hist);\r\npthread_mutex_unlock(&notes->lock);\r\n}\r\nint symbol__inc_addr_samples(struct symbol *sym, struct map *map,\r\nint evidx, u64 addr)\r\n{\r\nunsigned offset;\r\nstruct annotation *notes;\r\nstruct sym_hist *h;\r\nnotes = symbol__annotation(sym);\r\nif (notes->src == NULL)\r\nreturn -ENOMEM;\r\npr_debug3("%s: addr=%#" PRIx64 "\n", __func__, map->unmap_ip(map, addr));\r\nif (addr < sym->start || addr > sym->end)\r\nreturn -ERANGE;\r\noffset = addr - sym->start;\r\nh = annotation__histogram(notes, evidx);\r\nh->sum++;\r\nh->addr[offset]++;\r\npr_debug3("%#" PRIx64 " %s: period++ [addr: %#" PRIx64 ", %#" PRIx64\r\n", evidx=%d] => %" PRIu64 "\n", sym->start, sym->name,\r\naddr, addr - sym->start, evidx, h->addr[offset]);\r\nreturn 0;\r\n}\r\nstatic void disasm_line__init_ins(struct disasm_line *dl)\r\n{\r\ndl->ins = ins__find(dl->name);\r\nif (dl->ins == NULL)\r\nreturn;\r\nif (!dl->ins->ops)\r\nreturn;\r\nif (dl->ins->ops->parse)\r\ndl->ins->ops->parse(&dl->ops);\r\n}\r\nstatic int disasm_line__parse(char *line, char **namep, char **rawp)\r\n{\r\nchar *name = line, tmp;\r\nwhile (isspace(name[0]))\r\n++name;\r\nif (name[0] == '\0')\r\nreturn -1;\r\n*rawp = name + 1;\r\nwhile ((*rawp)[0] != '\0' && !isspace((*rawp)[0]))\r\n++*rawp;\r\ntmp = (*rawp)[0];\r\n(*rawp)[0] = '\0';\r\n*namep = strdup(name);\r\nif (*namep == NULL)\r\ngoto out_free_name;\r\n(*rawp)[0] = tmp;\r\nif ((*rawp)[0] != '\0') {\r\n(*rawp)++;\r\nwhile (isspace((*rawp)[0]))\r\n++(*rawp);\r\n}\r\nreturn 0;\r\nout_free_name:\r\nfree(*namep);\r\n*namep = NULL;\r\nreturn -1;\r\n}\r\nstatic struct disasm_line *disasm_line__new(s64 offset, char *line, size_t privsize)\r\n{\r\nstruct disasm_line *dl = zalloc(sizeof(*dl) + privsize);\r\nif (dl != NULL) {\r\ndl->offset = offset;\r\ndl->line = strdup(line);\r\nif (dl->line == NULL)\r\ngoto out_delete;\r\nif (offset != -1) {\r\nif (disasm_line__parse(dl->line, &dl->name, &dl->ops.raw) < 0)\r\ngoto out_free_line;\r\ndisasm_line__init_ins(dl);\r\n}\r\n}\r\nreturn dl;\r\nout_free_line:\r\nfree(dl->line);\r\nout_delete:\r\nfree(dl);\r\nreturn NULL;\r\n}\r\nvoid disasm_line__free(struct disasm_line *dl)\r\n{\r\nfree(dl->line);\r\nfree(dl->name);\r\nif (dl->ins && dl->ins->ops->free)\r\ndl->ins->ops->free(&dl->ops);\r\nelse\r\nins__delete(&dl->ops);\r\nfree(dl);\r\n}\r\nint disasm_line__scnprintf(struct disasm_line *dl, char *bf, size_t size, bool raw)\r\n{\r\nif (raw || !dl->ins)\r\nreturn scnprintf(bf, size, "%-6.6s %s", dl->name, dl->ops.raw);\r\nreturn ins__scnprintf(dl->ins, bf, size, &dl->ops);\r\n}\r\nstatic void disasm__add(struct list_head *head, struct disasm_line *line)\r\n{\r\nlist_add_tail(&line->node, head);\r\n}\r\nstruct disasm_line *disasm__get_next_ip_line(struct list_head *head, struct disasm_line *pos)\r\n{\r\nlist_for_each_entry_continue(pos, head, node)\r\nif (pos->offset >= 0)\r\nreturn pos;\r\nreturn NULL;\r\n}\r\ndouble disasm__calc_percent(struct annotation *notes, int evidx, s64 offset,\r\ns64 end, const char **path)\r\n{\r\nstruct source_line *src_line = notes->src->lines;\r\ndouble percent = 0.0;\r\nif (src_line) {\r\nsize_t sizeof_src_line = sizeof(*src_line) +\r\nsizeof(src_line->p) * (src_line->nr_pcnt - 1);\r\nwhile (offset < end) {\r\nsrc_line = (void *)notes->src->lines +\r\n(sizeof_src_line * offset);\r\nif (*path == NULL)\r\n*path = src_line->path;\r\npercent += src_line->p[evidx].percent;\r\noffset++;\r\n}\r\n} else {\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nunsigned int hits = 0;\r\nwhile (offset < end)\r\nhits += h->addr[offset++];\r\nif (h->sum)\r\npercent = 100.0 * hits / h->sum;\r\n}\r\nreturn percent;\r\n}\r\nstatic int disasm_line__print(struct disasm_line *dl, struct symbol *sym, u64 start,\r\nstruct perf_evsel *evsel, u64 len, int min_pcnt, int printed,\r\nint max_lines, struct disasm_line *queue)\r\n{\r\nstatic const char *prev_line;\r\nstatic const char *prev_color;\r\nif (dl->offset != -1) {\r\nconst char *path = NULL;\r\ndouble percent, max_percent = 0.0;\r\ndouble *ppercents = &percent;\r\nint i, nr_percent = 1;\r\nconst char *color;\r\nstruct annotation *notes = symbol__annotation(sym);\r\ns64 offset = dl->offset;\r\nconst u64 addr = start + offset;\r\nstruct disasm_line *next;\r\nnext = disasm__get_next_ip_line(&notes->src->source, dl);\r\nif (perf_evsel__is_group_event(evsel)) {\r\nnr_percent = evsel->nr_members;\r\nppercents = calloc(nr_percent, sizeof(double));\r\nif (ppercents == NULL)\r\nreturn -1;\r\n}\r\nfor (i = 0; i < nr_percent; i++) {\r\npercent = disasm__calc_percent(notes,\r\nnotes->src->lines ? i : evsel->idx + i,\r\noffset,\r\nnext ? next->offset : (s64) len,\r\n&path);\r\nppercents[i] = percent;\r\nif (percent > max_percent)\r\nmax_percent = percent;\r\n}\r\nif (max_percent < min_pcnt)\r\nreturn -1;\r\nif (max_lines && printed >= max_lines)\r\nreturn 1;\r\nif (queue != NULL) {\r\nlist_for_each_entry_from(queue, &notes->src->source, node) {\r\nif (queue == dl)\r\nbreak;\r\ndisasm_line__print(queue, sym, start, evsel, len,\r\n0, 0, 1, NULL);\r\n}\r\n}\r\ncolor = get_percent_color(max_percent);\r\nif (path) {\r\nif (!prev_line || strcmp(prev_line, path)\r\n|| color != prev_color) {\r\ncolor_fprintf(stdout, color, " %s", path);\r\nprev_line = path;\r\nprev_color = color;\r\n}\r\n}\r\nfor (i = 0; i < nr_percent; i++) {\r\npercent = ppercents[i];\r\ncolor = get_percent_color(percent);\r\ncolor_fprintf(stdout, color, " %7.2f", percent);\r\n}\r\nprintf(" : ");\r\ncolor_fprintf(stdout, PERF_COLOR_MAGENTA, " %" PRIx64 ":", addr);\r\ncolor_fprintf(stdout, PERF_COLOR_BLUE, "%s\n", dl->line);\r\nif (ppercents != &percent)\r\nfree(ppercents);\r\n} else if (max_lines && printed >= max_lines)\r\nreturn 1;\r\nelse {\r\nint width = 8;\r\nif (queue)\r\nreturn -1;\r\nif (perf_evsel__is_group_event(evsel))\r\nwidth *= evsel->nr_members;\r\nif (!*dl->line)\r\nprintf(" %*s:\n", width, " ");\r\nelse\r\nprintf(" %*s: %s\n", width, " ", dl->line);\r\n}\r\nreturn 0;\r\n}\r\nstatic int symbol__parse_objdump_line(struct symbol *sym, struct map *map,\r\nFILE *file, size_t privsize)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct disasm_line *dl;\r\nchar *line = NULL, *parsed_line, *tmp, *tmp2, *c;\r\nsize_t line_len;\r\ns64 line_ip, offset = -1;\r\nif (getline(&line, &line_len, file) < 0)\r\nreturn -1;\r\nif (!line)\r\nreturn -1;\r\nwhile (line_len != 0 && isspace(line[line_len - 1]))\r\nline[--line_len] = '\0';\r\nc = strchr(line, '\n');\r\nif (c)\r\n*c = 0;\r\nline_ip = -1;\r\nparsed_line = line;\r\ntmp = line;\r\nwhile (*tmp) {\r\nif (*tmp != ' ')\r\nbreak;\r\ntmp++;\r\n}\r\nif (*tmp) {\r\nline_ip = strtoull(tmp, &tmp2, 16);\r\nif (*tmp2 != ':' || tmp == tmp2 || tmp2[1] == '\0')\r\nline_ip = -1;\r\n}\r\nif (line_ip != -1) {\r\nu64 start = map__rip_2objdump(map, sym->start),\r\nend = map__rip_2objdump(map, sym->end);\r\noffset = line_ip - start;\r\nif (offset < 0 || (u64)line_ip > end)\r\noffset = -1;\r\nelse\r\nparsed_line = tmp2 + 1;\r\n}\r\ndl = disasm_line__new(offset, parsed_line, privsize);\r\nfree(line);\r\nif (dl == NULL)\r\nreturn -1;\r\ndisasm__add(&notes->src->source, dl);\r\nreturn 0;\r\n}\r\nint symbol__annotate(struct symbol *sym, struct map *map, size_t privsize)\r\n{\r\nstruct dso *dso = map->dso;\r\nchar *filename = dso__build_id_filename(dso, NULL, 0);\r\nbool free_filename = true;\r\nchar command[PATH_MAX * 2];\r\nFILE *file;\r\nint err = 0;\r\nchar symfs_filename[PATH_MAX];\r\nif (filename) {\r\nsnprintf(symfs_filename, sizeof(symfs_filename), "%s%s",\r\nsymbol_conf.symfs, filename);\r\n}\r\nif (filename == NULL) {\r\nif (dso->has_build_id) {\r\npr_err("Can't annotate %s: not enough memory\n",\r\nsym->name);\r\nreturn -ENOMEM;\r\n}\r\ngoto fallback;\r\n} else if (readlink(symfs_filename, command, sizeof(command)) < 0 ||\r\nstrstr(command, "[kernel.kallsyms]") ||\r\naccess(symfs_filename, R_OK)) {\r\nfree(filename);\r\nfallback:\r\nfilename = dso->long_name;\r\nsnprintf(symfs_filename, sizeof(symfs_filename), "%s%s",\r\nsymbol_conf.symfs, filename);\r\nfree_filename = false;\r\n}\r\nif (dso->symtab_type == DSO_BINARY_TYPE__KALLSYMS) {\r\nchar bf[BUILD_ID_SIZE * 2 + 16] = " with build id ";\r\nchar *build_id_msg = NULL;\r\nif (dso->annotate_warned)\r\ngoto out_free_filename;\r\nif (dso->has_build_id) {\r\nbuild_id__sprintf(dso->build_id,\r\nsizeof(dso->build_id), bf + 15);\r\nbuild_id_msg = bf;\r\n}\r\nerr = -ENOENT;\r\ndso->annotate_warned = 1;\r\npr_err("Can't annotate %s:\n\n"\r\n"No vmlinux file%s\nwas found in the path.\n\n"\r\n"Please use:\n\n"\r\n" perf buildid-cache -vu vmlinux\n\n"\r\n"or:\n\n"\r\n" --vmlinux vmlinux\n",\r\nsym->name, build_id_msg ?: "");\r\ngoto out_free_filename;\r\n}\r\npr_debug("%s: filename=%s, sym=%s, start=%#" PRIx64 ", end=%#" PRIx64 "\n", __func__,\r\nfilename, sym->name, map->unmap_ip(map, sym->start),\r\nmap->unmap_ip(map, sym->end));\r\npr_debug("annotating [%p] %30s : [%p] %30s\n",\r\ndso, dso->long_name, sym, sym->name);\r\nsnprintf(command, sizeof(command),\r\n"%s %s%s --start-address=0x%016" PRIx64\r\n" --stop-address=0x%016" PRIx64\r\n" -d %s %s -C %s|grep -v %s|expand",\r\nobjdump_path ? objdump_path : "objdump",\r\ndisassembler_style ? "-M " : "",\r\ndisassembler_style ? disassembler_style : "",\r\nmap__rip_2objdump(map, sym->start),\r\nmap__rip_2objdump(map, sym->end+1),\r\nsymbol_conf.annotate_asm_raw ? "" : "--no-show-raw",\r\nsymbol_conf.annotate_src ? "-S" : "",\r\nsymfs_filename, filename);\r\npr_debug("Executing: %s\n", command);\r\nfile = popen(command, "r");\r\nif (!file)\r\ngoto out_free_filename;\r\nwhile (!feof(file))\r\nif (symbol__parse_objdump_line(sym, map, file, privsize) < 0)\r\nbreak;\r\npclose(file);\r\nout_free_filename:\r\nif (free_filename)\r\nfree(filename);\r\nreturn err;\r\n}\r\nstatic void insert_source_line(struct rb_root *root, struct source_line *src_line)\r\n{\r\nstruct source_line *iter;\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nint i, ret;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct source_line, node);\r\nret = strcmp(iter->path, src_line->path);\r\nif (ret == 0) {\r\nfor (i = 0; i < src_line->nr_pcnt; i++)\r\niter->p[i].percent_sum += src_line->p[i].percent;\r\nreturn;\r\n}\r\nif (ret < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nfor (i = 0; i < src_line->nr_pcnt; i++)\r\nsrc_line->p[i].percent_sum = src_line->p[i].percent;\r\nrb_link_node(&src_line->node, parent, p);\r\nrb_insert_color(&src_line->node, root);\r\n}\r\nstatic int cmp_source_line(struct source_line *a, struct source_line *b)\r\n{\r\nint i;\r\nfor (i = 0; i < a->nr_pcnt; i++) {\r\nif (a->p[i].percent_sum == b->p[i].percent_sum)\r\ncontinue;\r\nreturn a->p[i].percent_sum > b->p[i].percent_sum;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __resort_source_line(struct rb_root *root, struct source_line *src_line)\r\n{\r\nstruct source_line *iter;\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct source_line, node);\r\nif (cmp_source_line(src_line, iter))\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&src_line->node, parent, p);\r\nrb_insert_color(&src_line->node, root);\r\n}\r\nstatic void resort_source_line(struct rb_root *dest_root, struct rb_root *src_root)\r\n{\r\nstruct source_line *src_line;\r\nstruct rb_node *node;\r\nnode = rb_first(src_root);\r\nwhile (node) {\r\nstruct rb_node *next;\r\nsrc_line = rb_entry(node, struct source_line, node);\r\nnext = rb_next(node);\r\nrb_erase(node, src_root);\r\n__resort_source_line(dest_root, src_line);\r\nnode = next;\r\n}\r\n}\r\nstatic void symbol__free_source_line(struct symbol *sym, int len)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct source_line *src_line = notes->src->lines;\r\nsize_t sizeof_src_line;\r\nint i;\r\nsizeof_src_line = sizeof(*src_line) +\r\n(sizeof(src_line->p) * (src_line->nr_pcnt - 1));\r\nfor (i = 0; i < len; i++) {\r\nfree(src_line->path);\r\nsrc_line = (void *)src_line + sizeof_src_line;\r\n}\r\nfree(notes->src->lines);\r\nnotes->src->lines = NULL;\r\n}\r\nstatic int symbol__get_source_line(struct symbol *sym, struct map *map,\r\nstruct perf_evsel *evsel,\r\nstruct rb_root *root, int len,\r\nconst char *filename)\r\n{\r\nu64 start;\r\nint i, k;\r\nint evidx = evsel->idx;\r\nchar cmd[PATH_MAX * 2];\r\nstruct source_line *src_line;\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nstruct rb_root tmp_root = RB_ROOT;\r\nint nr_pcnt = 1;\r\nu64 h_sum = h->sum;\r\nsize_t sizeof_src_line = sizeof(struct source_line);\r\nif (perf_evsel__is_group_event(evsel)) {\r\nfor (i = 1; i < evsel->nr_members; i++) {\r\nh = annotation__histogram(notes, evidx + i);\r\nh_sum += h->sum;\r\n}\r\nnr_pcnt = evsel->nr_members;\r\nsizeof_src_line += (nr_pcnt - 1) * sizeof(src_line->p);\r\n}\r\nif (!h_sum)\r\nreturn 0;\r\nsrc_line = notes->src->lines = calloc(len, sizeof_src_line);\r\nif (!notes->src->lines)\r\nreturn -1;\r\nstart = map__rip_2objdump(map, sym->start);\r\nfor (i = 0; i < len; i++) {\r\nchar *path = NULL;\r\nsize_t line_len;\r\nu64 offset;\r\nFILE *fp;\r\ndouble percent_max = 0.0;\r\nsrc_line->nr_pcnt = nr_pcnt;\r\nfor (k = 0; k < nr_pcnt; k++) {\r\nh = annotation__histogram(notes, evidx + k);\r\nsrc_line->p[k].percent = 100.0 * h->addr[i] / h->sum;\r\nif (src_line->p[k].percent > percent_max)\r\npercent_max = src_line->p[k].percent;\r\n}\r\nif (percent_max <= 0.5)\r\ngoto next;\r\noffset = start + i;\r\nsprintf(cmd, "addr2line -e %s %016" PRIx64, filename, offset);\r\nfp = popen(cmd, "r");\r\nif (!fp)\r\ngoto next;\r\nif (getline(&path, &line_len, fp) < 0 || !line_len)\r\ngoto next_close;\r\nsrc_line->path = malloc(sizeof(char) * line_len + 1);\r\nif (!src_line->path)\r\ngoto next_close;\r\nstrcpy(src_line->path, path);\r\ninsert_source_line(&tmp_root, src_line);\r\nnext_close:\r\npclose(fp);\r\nnext:\r\nsrc_line = (void *)src_line + sizeof_src_line;\r\n}\r\nresort_source_line(root, &tmp_root);\r\nreturn 0;\r\n}\r\nstatic void print_summary(struct rb_root *root, const char *filename)\r\n{\r\nstruct source_line *src_line;\r\nstruct rb_node *node;\r\nprintf("\nSorted summary for file %s\n", filename);\r\nprintf("----------------------------------------------\n\n");\r\nif (RB_EMPTY_ROOT(root)) {\r\nprintf(" Nothing higher than %1.1f%%\n", MIN_GREEN);\r\nreturn;\r\n}\r\nnode = rb_first(root);\r\nwhile (node) {\r\ndouble percent, percent_max = 0.0;\r\nconst char *color;\r\nchar *path;\r\nint i;\r\nsrc_line = rb_entry(node, struct source_line, node);\r\nfor (i = 0; i < src_line->nr_pcnt; i++) {\r\npercent = src_line->p[i].percent_sum;\r\ncolor = get_percent_color(percent);\r\ncolor_fprintf(stdout, color, " %7.2f", percent);\r\nif (percent > percent_max)\r\npercent_max = percent;\r\n}\r\npath = src_line->path;\r\ncolor = get_percent_color(percent_max);\r\ncolor_fprintf(stdout, color, " %s", path);\r\nnode = rb_next(node);\r\n}\r\n}\r\nstatic void symbol__annotate_hits(struct symbol *sym, struct perf_evsel *evsel)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evsel->idx);\r\nu64 len = symbol__size(sym), offset;\r\nfor (offset = 0; offset < len; ++offset)\r\nif (h->addr[offset] != 0)\r\nprintf("%*" PRIx64 ": %" PRIu64 "\n", BITS_PER_LONG / 2,\r\nsym->start + offset, h->addr[offset]);\r\nprintf("%*s: %" PRIu64 "\n", BITS_PER_LONG / 2, "h->sum", h->sum);\r\n}\r\nint symbol__annotate_printf(struct symbol *sym, struct map *map,\r\nstruct perf_evsel *evsel, bool full_paths,\r\nint min_pcnt, int max_lines, int context)\r\n{\r\nstruct dso *dso = map->dso;\r\nchar *filename;\r\nconst char *d_filename;\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct disasm_line *pos, *queue = NULL;\r\nu64 start = map__rip_2objdump(map, sym->start);\r\nint printed = 2, queue_len = 0;\r\nint more = 0;\r\nu64 len;\r\nint width = 8;\r\nint namelen;\r\nfilename = strdup(dso->long_name);\r\nif (!filename)\r\nreturn -ENOMEM;\r\nif (full_paths)\r\nd_filename = filename;\r\nelse\r\nd_filename = basename(filename);\r\nlen = symbol__size(sym);\r\nnamelen = strlen(d_filename);\r\nif (perf_evsel__is_group_event(evsel))\r\nwidth *= evsel->nr_members;\r\nprintf(" %-*.*s| Source code & Disassembly of %s\n",\r\nwidth, width, "Percent", d_filename);\r\nprintf("-%-*.*s-------------------------------------\n",\r\nwidth+namelen, width+namelen, graph_dotted_line);\r\nif (verbose)\r\nsymbol__annotate_hits(sym, evsel);\r\nlist_for_each_entry(pos, &notes->src->source, node) {\r\nif (context && queue == NULL) {\r\nqueue = pos;\r\nqueue_len = 0;\r\n}\r\nswitch (disasm_line__print(pos, sym, start, evsel, len,\r\nmin_pcnt, printed, max_lines,\r\nqueue)) {\r\ncase 0:\r\n++printed;\r\nif (context) {\r\nprinted += queue_len;\r\nqueue = NULL;\r\nqueue_len = 0;\r\n}\r\nbreak;\r\ncase 1:\r\n++more;\r\nbreak;\r\ncase -1:\r\ndefault:\r\nif (!context)\r\nbreak;\r\nif (queue_len == context)\r\nqueue = list_entry(queue->node.next, typeof(*queue), node);\r\nelse\r\n++queue_len;\r\nbreak;\r\n}\r\n}\r\nfree(filename);\r\nreturn more;\r\n}\r\nvoid symbol__annotate_zero_histogram(struct symbol *sym, int evidx)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nmemset(h, 0, notes->src->sizeof_sym_hist);\r\n}\r\nvoid symbol__annotate_decay_histogram(struct symbol *sym, int evidx)\r\n{\r\nstruct annotation *notes = symbol__annotation(sym);\r\nstruct sym_hist *h = annotation__histogram(notes, evidx);\r\nint len = symbol__size(sym), offset;\r\nh->sum = 0;\r\nfor (offset = 0; offset < len; ++offset) {\r\nh->addr[offset] = h->addr[offset] * 7 / 8;\r\nh->sum += h->addr[offset];\r\n}\r\n}\r\nvoid disasm__purge(struct list_head *head)\r\n{\r\nstruct disasm_line *pos, *n;\r\nlist_for_each_entry_safe(pos, n, head, node) {\r\nlist_del(&pos->node);\r\ndisasm_line__free(pos);\r\n}\r\n}\r\nstatic size_t disasm_line__fprintf(struct disasm_line *dl, FILE *fp)\r\n{\r\nsize_t printed;\r\nif (dl->offset == -1)\r\nreturn fprintf(fp, "%s\n", dl->line);\r\nprinted = fprintf(fp, "%#" PRIx64 " %s", dl->offset, dl->name);\r\nif (dl->ops.raw[0] != '\0') {\r\nprinted += fprintf(fp, "%.*s %s\n", 6 - (int)printed, " ",\r\ndl->ops.raw);\r\n}\r\nreturn printed + fprintf(fp, "\n");\r\n}\r\nsize_t disasm__fprintf(struct list_head *head, FILE *fp)\r\n{\r\nstruct disasm_line *pos;\r\nsize_t printed = 0;\r\nlist_for_each_entry(pos, head, node)\r\nprinted += disasm_line__fprintf(pos, fp);\r\nreturn printed;\r\n}\r\nint symbol__tty_annotate(struct symbol *sym, struct map *map,\r\nstruct perf_evsel *evsel, bool print_lines,\r\nbool full_paths, int min_pcnt, int max_lines)\r\n{\r\nstruct dso *dso = map->dso;\r\nconst char *filename = dso->long_name;\r\nstruct rb_root source_line = RB_ROOT;\r\nu64 len;\r\nif (symbol__annotate(sym, map, 0) < 0)\r\nreturn -1;\r\nlen = symbol__size(sym);\r\nif (print_lines) {\r\nsymbol__get_source_line(sym, map, evsel, &source_line,\r\nlen, filename);\r\nprint_summary(&source_line, filename);\r\n}\r\nsymbol__annotate_printf(sym, map, evsel, full_paths,\r\nmin_pcnt, max_lines, 0);\r\nif (print_lines)\r\nsymbol__free_source_line(sym, len);\r\ndisasm__purge(&symbol__annotation(sym)->src->source);\r\nreturn 0;\r\n}
