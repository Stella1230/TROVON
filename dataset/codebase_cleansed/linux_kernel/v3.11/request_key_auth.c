static int request_key_auth_instantiate(struct key *key,\r\nstruct key_preparsed_payload *prep)\r\n{\r\nkey->payload.data = (struct request_key_auth *)prep->data;\r\nreturn 0;\r\n}\r\nstatic void request_key_auth_describe(const struct key *key,\r\nstruct seq_file *m)\r\n{\r\nstruct request_key_auth *rka = key->payload.data;\r\nseq_puts(m, "key:");\r\nseq_puts(m, key->description);\r\nif (key_is_instantiated(key))\r\nseq_printf(m, " pid:%d ci:%zu", rka->pid, rka->callout_len);\r\n}\r\nstatic long request_key_auth_read(const struct key *key,\r\nchar __user *buffer, size_t buflen)\r\n{\r\nstruct request_key_auth *rka = key->payload.data;\r\nsize_t datalen;\r\nlong ret;\r\ndatalen = rka->callout_len;\r\nret = datalen;\r\nif (buffer && buflen > 0) {\r\nif (buflen > datalen)\r\nbuflen = datalen;\r\nif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nstatic void request_key_auth_revoke(struct key *key)\r\n{\r\nstruct request_key_auth *rka = key->payload.data;\r\nkenter("{%d}", key->serial);\r\nif (rka->cred) {\r\nput_cred(rka->cred);\r\nrka->cred = NULL;\r\n}\r\n}\r\nstatic void request_key_auth_destroy(struct key *key)\r\n{\r\nstruct request_key_auth *rka = key->payload.data;\r\nkenter("{%d}", key->serial);\r\nif (rka->cred) {\r\nput_cred(rka->cred);\r\nrka->cred = NULL;\r\n}\r\nkey_put(rka->target_key);\r\nkey_put(rka->dest_keyring);\r\nkfree(rka->callout_info);\r\nkfree(rka);\r\n}\r\nstruct key *request_key_auth_new(struct key *target, const void *callout_info,\r\nsize_t callout_len, struct key *dest_keyring)\r\n{\r\nstruct request_key_auth *rka, *irka;\r\nconst struct cred *cred = current->cred;\r\nstruct key *authkey = NULL;\r\nchar desc[20];\r\nint ret;\r\nkenter("%d,", target->serial);\r\nrka = kmalloc(sizeof(*rka), GFP_KERNEL);\r\nif (!rka) {\r\nkleave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nrka->callout_info = kmalloc(callout_len, GFP_KERNEL);\r\nif (!rka->callout_info) {\r\nkleave(" = -ENOMEM");\r\nkfree(rka);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (cred->request_key_auth) {\r\ndown_read(&cred->request_key_auth->sem);\r\nif (test_bit(KEY_FLAG_REVOKED, &cred->request_key_auth->flags))\r\ngoto auth_key_revoked;\r\nirka = cred->request_key_auth->payload.data;\r\nrka->cred = get_cred(irka->cred);\r\nrka->pid = irka->pid;\r\nup_read(&cred->request_key_auth->sem);\r\n}\r\nelse {\r\nrka->cred = get_cred(cred);\r\nrka->pid = current->pid;\r\n}\r\nrka->target_key = key_get(target);\r\nrka->dest_keyring = key_get(dest_keyring);\r\nmemcpy(rka->callout_info, callout_info, callout_len);\r\nrka->callout_len = callout_len;\r\nsprintf(desc, "%x", target->serial);\r\nauthkey = key_alloc(&key_type_request_key_auth, desc,\r\ncred->fsuid, cred->fsgid, cred,\r\nKEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\r\nKEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA);\r\nif (IS_ERR(authkey)) {\r\nret = PTR_ERR(authkey);\r\ngoto error_alloc;\r\n}\r\nret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\r\nif (ret < 0)\r\ngoto error_inst;\r\nkleave(" = {%d,%d}", authkey->serial, atomic_read(&authkey->usage));\r\nreturn authkey;\r\nauth_key_revoked:\r\nup_read(&cred->request_key_auth->sem);\r\nkfree(rka->callout_info);\r\nkfree(rka);\r\nkleave("= -EKEYREVOKED");\r\nreturn ERR_PTR(-EKEYREVOKED);\r\nerror_inst:\r\nkey_revoke(authkey);\r\nkey_put(authkey);\r\nerror_alloc:\r\nkey_put(rka->target_key);\r\nkey_put(rka->dest_keyring);\r\nkfree(rka->callout_info);\r\nkfree(rka);\r\nkleave("= %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int key_get_instantiation_authkey_match(const struct key *key,\r\nconst void *_id)\r\n{\r\nstruct request_key_auth *rka = key->payload.data;\r\nkey_serial_t id = (key_serial_t)(unsigned long) _id;\r\nreturn rka->target_key->serial == id;\r\n}\r\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct key *authkey;\r\nkey_ref_t authkey_ref;\r\nauthkey_ref = search_process_keyrings(\r\n&key_type_request_key_auth,\r\n(void *) (unsigned long) target_id,\r\nkey_get_instantiation_authkey_match,\r\ncred);\r\nif (IS_ERR(authkey_ref)) {\r\nauthkey = ERR_CAST(authkey_ref);\r\nif (authkey == ERR_PTR(-EAGAIN))\r\nauthkey = ERR_PTR(-ENOKEY);\r\ngoto error;\r\n}\r\nauthkey = key_ref_to_ptr(authkey_ref);\r\nif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\r\nkey_put(authkey);\r\nauthkey = ERR_PTR(-EKEYREVOKED);\r\n}\r\nerror:\r\nreturn authkey;\r\n}
