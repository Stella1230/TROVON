static struct ctl_table_set *\r\nnet_ctl_header_lookup(struct ctl_table_root *root, struct nsproxy *namespaces)\r\n{\r\nreturn &namespaces->net_ns->sysctls;\r\n}\r\nstatic int is_seen(struct ctl_table_set *set)\r\n{\r\nreturn &current->nsproxy->net_ns->sysctls == set;\r\n}\r\nstatic int net_ctl_permissions(struct ctl_table_header *head,\r\nstruct ctl_table *table)\r\n{\r\nstruct net *net = container_of(head->set, struct net, sysctls);\r\nkuid_t root_uid = make_kuid(net->user_ns, 0);\r\nkgid_t root_gid = make_kgid(net->user_ns, 0);\r\nif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\r\nuid_eq(root_uid, current_uid())) {\r\nint mode = (table->mode >> 6) & 7;\r\nreturn (mode << 6) | (mode << 3) | mode;\r\n}\r\nif (gid_eq(root_gid, current_gid())) {\r\nint mode = (table->mode >> 3) & 7;\r\nreturn (mode << 3) | mode;\r\n}\r\nreturn table->mode;\r\n}\r\nstatic int __net_init sysctl_net_init(struct net *net)\r\n{\r\nsetup_sysctl_set(&net->sysctls, &net_sysctl_root, is_seen);\r\nreturn 0;\r\n}\r\nstatic void __net_exit sysctl_net_exit(struct net *net)\r\n{\r\nretire_sysctl_set(&net->sysctls);\r\n}\r\n__init int net_sysctl_init(void)\r\n{\r\nstatic struct ctl_table empty[1];\r\nint ret = -ENOMEM;\r\nnet_header = register_sysctl("net", empty);\r\nif (!net_header)\r\ngoto out;\r\nret = register_pernet_subsys(&sysctl_pernet_ops);\r\nif (ret)\r\ngoto out;\r\nregister_sysctl_root(&net_sysctl_root);\r\nout:\r\nreturn ret;\r\n}\r\nstruct ctl_table_header *register_net_sysctl(struct net *net,\r\nconst char *path, struct ctl_table *table)\r\n{\r\nreturn __register_sysctl_table(&net->sysctls, path, table);\r\n}\r\nvoid unregister_net_sysctl_table(struct ctl_table_header *header)\r\n{\r\nunregister_sysctl_table(header);\r\n}
