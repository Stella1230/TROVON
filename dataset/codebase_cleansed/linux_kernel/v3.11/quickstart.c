static ssize_t quickstart_buttons_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct quickstart_button *b;\r\nif (list_empty(&buttons))\r\nreturn snprintf(buf, PAGE_SIZE, "none");\r\nlist_for_each_entry(b, &buttons, list) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%u\t%s\n",\r\nb->id, b->name);\r\nif (count >= PAGE_SIZE) {\r\ncount = PAGE_SIZE;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t quickstart_pressed_button_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n",\r\n(pressed ? pressed->name : "none"));\r\n}\r\nstatic ssize_t quickstart_pressed_button_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (count < 2)\r\nreturn -EINVAL;\r\nif (strncasecmp(buf, "none", 4) != 0)\r\nreturn -EINVAL;\r\npressed = NULL;\r\nreturn count;\r\n}\r\nstatic struct quickstart_button *quickstart_buttons_add(void)\r\n{\r\nstruct quickstart_button *b;\r\nb = kzalloc(sizeof(*b), GFP_KERNEL);\r\nif (!b)\r\nreturn NULL;\r\nlist_add_tail(&b->list, &buttons);\r\nreturn b;\r\n}\r\nstatic void quickstart_button_del(struct quickstart_button *data)\r\n{\r\nif (!data)\r\nreturn;\r\nlist_del(&data->list);\r\nkfree(data->name);\r\nkfree(data);\r\n}\r\nstatic void quickstart_buttons_free(void)\r\n{\r\nstruct quickstart_button *b, *n;\r\nlist_for_each_entry_safe(b, n, &buttons, list)\r\nquickstart_button_del(b);\r\n}\r\nstatic void quickstart_acpi_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct quickstart_acpi *quickstart = data;\r\nif (!quickstart)\r\nreturn;\r\nswitch (event) {\r\ncase QUICKSTART_EVENT_WAKE:\r\npressed = quickstart->button;\r\nbreak;\r\ncase QUICKSTART_EVENT_RUNTIME:\r\ninput_report_key(quickstart_input, quickstart->button->id, 1);\r\ninput_sync(quickstart_input);\r\ninput_report_key(quickstart_input, quickstart->button->id, 0);\r\ninput_sync(quickstart_input);\r\nbreak;\r\ndefault:\r\npr_err("Unexpected ACPI event notify (%u)\n", event);\r\nbreak;\r\n}\r\n}\r\nstatic int quickstart_acpi_ghid(struct quickstart_acpi *quickstart)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nint ret = 0;\r\nstatus = acpi_evaluate_object(quickstart->device->handle, "GHID", NULL,\r\n&buffer);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("%s GHID method failed\n", quickstart->button->name);\r\nreturn -EINVAL;\r\n}\r\nswitch (buffer.length) {\r\ncase 1:\r\nquickstart->button->id = *(uint8_t *)buffer.pointer;\r\nbreak;\r\ncase 2:\r\nquickstart->button->id = *(uint16_t *)buffer.pointer;\r\nbreak;\r\ncase 4:\r\nquickstart->button->id = *(uint32_t *)buffer.pointer;\r\nbreak;\r\ncase 8:\r\nquickstart->button->id = *(uint64_t *)buffer.pointer;\r\nbreak;\r\ndefault:\r\npr_err("%s GHID method returned buffer of unexpected length %lu\n",\r\nquickstart->button->name,\r\n(unsigned long)buffer.length);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nkfree(buffer.pointer);\r\nreturn ret;\r\n}\r\nstatic int quickstart_acpi_config(struct quickstart_acpi *quickstart)\r\n{\r\nchar *bid = acpi_device_bid(quickstart->device);\r\nchar *name;\r\nname = kmalloc(strlen(bid) + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nquickstart->button = quickstart_buttons_add();\r\nif (!quickstart->button) {\r\nkfree(name);\r\nreturn -ENOMEM;\r\n}\r\nquickstart->button->name = name;\r\nstrcpy(quickstart->button->name, bid);\r\nreturn 0;\r\n}\r\nstatic int quickstart_acpi_add(struct acpi_device *device)\r\n{\r\nint ret;\r\nacpi_status status;\r\nstruct quickstart_acpi *quickstart;\r\nif (!device)\r\nreturn -EINVAL;\r\nquickstart = kzalloc(sizeof(*quickstart), GFP_KERNEL);\r\nif (!quickstart)\r\nreturn -ENOMEM;\r\nquickstart->device = device;\r\nstrcpy(acpi_device_name(device), QUICKSTART_ACPI_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), QUICKSTART_ACPI_CLASS);\r\ndevice->driver_data = quickstart;\r\nret = quickstart_acpi_config(quickstart);\r\nif (ret < 0)\r\ngoto fail_config;\r\nstatus = acpi_install_notify_handler(device->handle, ACPI_ALL_NOTIFY,\r\nquickstart_acpi_notify,\r\nquickstart);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Notify handler install error\n");\r\nret = -ENODEV;\r\ngoto fail_installnotify;\r\n}\r\nret = quickstart_acpi_ghid(quickstart);\r\nif (ret < 0)\r\ngoto fail_ghid;\r\nreturn 0;\r\nfail_ghid:\r\nacpi_remove_notify_handler(device->handle, ACPI_ALL_NOTIFY,\r\nquickstart_acpi_notify);\r\nfail_installnotify:\r\nquickstart_button_del(quickstart->button);\r\nfail_config:\r\nkfree(quickstart);\r\nreturn ret;\r\n}\r\nstatic int quickstart_acpi_remove(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nstruct quickstart_acpi *quickstart;\r\nif (!device)\r\nreturn -EINVAL;\r\nquickstart = acpi_driver_data(device);\r\nif (!quickstart)\r\nreturn -EINVAL;\r\nstatus = acpi_remove_notify_handler(device->handle, ACPI_ALL_NOTIFY,\r\nquickstart_acpi_notify);\r\nif (ACPI_FAILURE(status))\r\npr_err("Error removing notify handler\n");\r\nkfree(quickstart);\r\nreturn 0;\r\n}\r\nstatic void quickstart_exit(void)\r\n{\r\ninput_unregister_device(quickstart_input);\r\ndevice_remove_file(&pf_device->dev, &dev_attr_pressed_button);\r\ndevice_remove_file(&pf_device->dev, &dev_attr_buttons);\r\nplatform_device_unregister(pf_device);\r\nplatform_driver_unregister(&pf_driver);\r\nacpi_bus_unregister_driver(&quickstart_acpi_driver);\r\nquickstart_buttons_free();\r\n}\r\nstatic int __init quickstart_init_input(void)\r\n{\r\nstruct quickstart_button *b;\r\nint ret;\r\nquickstart_input = input_allocate_device();\r\nif (!quickstart_input)\r\nreturn -ENOMEM;\r\nquickstart_input->name = "Quickstart ACPI Buttons";\r\nquickstart_input->id.bustype = BUS_HOST;\r\nlist_for_each_entry(b, &buttons, list) {\r\nset_bit(EV_KEY, quickstart_input->evbit);\r\nset_bit(b->id, quickstart_input->keybit);\r\n}\r\nret = input_register_device(quickstart_input);\r\nif (ret) {\r\ninput_free_device(quickstart_input);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init quickstart_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nret = acpi_bus_register_driver(&quickstart_acpi_driver);\r\nif (ret)\r\nreturn ret;\r\nif (list_empty(&buttons)) {\r\nret = -ENODEV;\r\ngoto fail_pfdrv_reg;\r\n}\r\nret = platform_driver_register(&pf_driver);\r\nif (ret)\r\ngoto fail_pfdrv_reg;\r\npf_device = platform_device_alloc(QUICKSTART_PF_DEVICE_NAME, -1);\r\nif (!pf_device) {\r\nret = -ENOMEM;\r\ngoto fail_pfdev_alloc;\r\n}\r\nret = platform_device_add(pf_device);\r\nif (ret)\r\ngoto fail_pfdev_add;\r\nret = device_create_file(&pf_device->dev, &dev_attr_pressed_button);\r\nif (ret)\r\ngoto fail_dev_file;\r\nret = device_create_file(&pf_device->dev, &dev_attr_buttons);\r\nif (ret)\r\ngoto fail_dev_file2;\r\nret = quickstart_init_input();\r\nif (ret)\r\ngoto fail_input;\r\npr_info("ACPI Direct App Launch ver %s\n", QUICKSTART_VERSION);\r\nreturn 0;\r\nfail_input:\r\ndevice_remove_file(&pf_device->dev, &dev_attr_buttons);\r\nfail_dev_file2:\r\ndevice_remove_file(&pf_device->dev, &dev_attr_pressed_button);\r\nfail_dev_file:\r\nplatform_device_del(pf_device);\r\nfail_pfdev_add:\r\nplatform_device_put(pf_device);\r\nfail_pfdev_alloc:\r\nplatform_driver_unregister(&pf_driver);\r\nfail_pfdrv_reg:\r\nacpi_bus_unregister_driver(&quickstart_acpi_driver);\r\nreturn ret;\r\n}
