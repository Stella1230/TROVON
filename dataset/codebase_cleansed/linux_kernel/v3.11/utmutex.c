acpi_status acpi_ut_mutex_initialize(void)\r\n{\r\nu32 i;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ut_mutex_initialize);\r\nfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\r\nstatus = acpi_ut_create_mutex(i);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nstatus = acpi_os_create_lock (&acpi_gbl_gpe_lock);\r\nif (ACPI_FAILURE (status)) {\r\nreturn_ACPI_STATUS (status);\r\n}\r\nstatus = acpi_os_create_lock (&acpi_gbl_hardware_lock);\r\nif (ACPI_FAILURE (status)) {\r\nreturn_ACPI_STATUS (status);\r\n}\r\nstatus = acpi_os_create_lock(&acpi_gbl_reference_count_lock);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_os_create_mutex(&acpi_gbl_osi_mutex);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ut_create_rw_lock(&acpi_gbl_namespace_rw_lock);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid acpi_ut_mutex_terminate(void)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ut_mutex_terminate);\r\nfor (i = 0; i < ACPI_NUM_MUTEX; i++) {\r\nacpi_ut_delete_mutex(i);\r\n}\r\nacpi_os_delete_mutex(acpi_gbl_osi_mutex);\r\nacpi_os_delete_lock(acpi_gbl_gpe_lock);\r\nacpi_os_delete_lock(acpi_gbl_hardware_lock);\r\nacpi_os_delete_lock(acpi_gbl_reference_count_lock);\r\nacpi_ut_delete_rw_lock(&acpi_gbl_namespace_rw_lock);\r\nreturn_VOID;\r\n}\r\nstatic acpi_status acpi_ut_create_mutex(acpi_mutex_handle mutex_id)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_U32(ut_create_mutex, mutex_id);\r\nif (!acpi_gbl_mutex_info[mutex_id].mutex) {\r\nstatus =\r\nacpi_os_create_mutex(&acpi_gbl_mutex_info[mutex_id].mutex);\r\nacpi_gbl_mutex_info[mutex_id].thread_id =\r\nACPI_MUTEX_NOT_ACQUIRED;\r\nacpi_gbl_mutex_info[mutex_id].use_count = 0;\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic void acpi_ut_delete_mutex(acpi_mutex_handle mutex_id)\r\n{\r\nACPI_FUNCTION_TRACE_U32(ut_delete_mutex, mutex_id);\r\nacpi_os_delete_mutex(acpi_gbl_mutex_info[mutex_id].mutex);\r\nacpi_gbl_mutex_info[mutex_id].mutex = NULL;\r\nacpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;\r\nreturn_VOID;\r\n}\r\nacpi_status acpi_ut_acquire_mutex(acpi_mutex_handle mutex_id)\r\n{\r\nacpi_status status;\r\nacpi_thread_id this_thread_id;\r\nACPI_FUNCTION_NAME(ut_acquire_mutex);\r\nif (mutex_id > ACPI_MAX_MUTEX) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nthis_thread_id = acpi_os_get_thread_id();\r\n#ifdef ACPI_MUTEX_DEBUG\r\n{\r\nu32 i;\r\nfor (i = mutex_id; i < ACPI_NUM_MUTEX; i++) {\r\nif (acpi_gbl_mutex_info[i].thread_id == this_thread_id) {\r\nif (i == mutex_id) {\r\nACPI_ERROR((AE_INFO,\r\n"Mutex [%s] already acquired by this thread [%u]",\r\nacpi_ut_get_mutex_name\r\n(mutex_id),\r\n(u32)this_thread_id));\r\nreturn (AE_ALREADY_ACQUIRED);\r\n}\r\nACPI_ERROR((AE_INFO,\r\n"Invalid acquire order: Thread %u owns [%s], wants [%s]",\r\n(u32)this_thread_id,\r\nacpi_ut_get_mutex_name(i),\r\nacpi_ut_get_mutex_name(mutex_id)));\r\nreturn (AE_ACQUIRE_DEADLOCK);\r\n}\r\n}\r\n}\r\n#endif\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX,\r\n"Thread %u attempting to acquire Mutex [%s]\n",\r\n(u32)this_thread_id,\r\nacpi_ut_get_mutex_name(mutex_id)));\r\nstatus = acpi_os_acquire_mutex(acpi_gbl_mutex_info[mutex_id].mutex,\r\nACPI_WAIT_FOREVER);\r\nif (ACPI_SUCCESS(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX,\r\n"Thread %u acquired Mutex [%s]\n",\r\n(u32)this_thread_id,\r\nacpi_ut_get_mutex_name(mutex_id)));\r\nacpi_gbl_mutex_info[mutex_id].use_count++;\r\nacpi_gbl_mutex_info[mutex_id].thread_id = this_thread_id;\r\n} else {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Thread %u could not acquire Mutex [0x%X]",\r\n(u32)this_thread_id, mutex_id));\r\n}\r\nreturn (status);\r\n}\r\nacpi_status acpi_ut_release_mutex(acpi_mutex_handle mutex_id)\r\n{\r\nACPI_FUNCTION_NAME(ut_release_mutex);\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Thread %u releasing Mutex [%s]\n",\r\n(u32)acpi_os_get_thread_id(),\r\nacpi_ut_get_mutex_name(mutex_id)));\r\nif (mutex_id > ACPI_MAX_MUTEX) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (acpi_gbl_mutex_info[mutex_id].thread_id == ACPI_MUTEX_NOT_ACQUIRED) {\r\nACPI_ERROR((AE_INFO,\r\n"Mutex [0x%X] is not acquired, cannot release",\r\nmutex_id));\r\nreturn (AE_NOT_ACQUIRED);\r\n}\r\n#ifdef ACPI_MUTEX_DEBUG\r\n{\r\nu32 i;\r\nfor (i = mutex_id; i < ACPI_NUM_MUTEX; i++) {\r\nif (acpi_gbl_mutex_info[i].thread_id ==\r\nacpi_os_get_thread_id()) {\r\nif (i == mutex_id) {\r\ncontinue;\r\n}\r\nACPI_ERROR((AE_INFO,\r\n"Invalid release order: owns [%s], releasing [%s]",\r\nacpi_ut_get_mutex_name(i),\r\nacpi_ut_get_mutex_name(mutex_id)));\r\nreturn (AE_RELEASE_DEADLOCK);\r\n}\r\n}\r\n}\r\n#endif\r\nacpi_gbl_mutex_info[mutex_id].thread_id = ACPI_MUTEX_NOT_ACQUIRED;\r\nacpi_os_release_mutex(acpi_gbl_mutex_info[mutex_id].mutex);\r\nreturn (AE_OK);\r\n}
