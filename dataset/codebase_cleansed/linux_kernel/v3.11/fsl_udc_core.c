static u32 _fsl_readl_be(const unsigned __iomem *p)\r\n{\r\nreturn in_be32(p);\r\n}\r\nstatic u32 _fsl_readl_le(const unsigned __iomem *p)\r\n{\r\nreturn in_le32(p);\r\n}\r\nstatic void _fsl_writel_be(u32 v, unsigned __iomem *p)\r\n{\r\nout_be32(p, v);\r\n}\r\nstatic void _fsl_writel_le(u32 v, unsigned __iomem *p)\r\n{\r\nout_le32(p, v);\r\n}\r\nstatic inline void fsl_set_accessors(struct fsl_usb2_platform_data *pdata)\r\n{\r\nif (pdata->big_endian_mmio) {\r\n_fsl_readl = _fsl_readl_be;\r\n_fsl_writel = _fsl_writel_be;\r\n} else {\r\n_fsl_readl = _fsl_readl_le;\r\n_fsl_writel = _fsl_writel_le;\r\n}\r\n}\r\nstatic inline u32 cpu_to_hc32(const u32 x)\r\n{\r\nreturn udc_controller->pdata->big_endian_desc\r\n? (__force u32)cpu_to_be32(x)\r\n: (__force u32)cpu_to_le32(x);\r\n}\r\nstatic inline u32 hc32_to_cpu(const u32 x)\r\n{\r\nreturn udc_controller->pdata->big_endian_desc\r\n? be32_to_cpu((__force __be32)x)\r\n: le32_to_cpu((__force __le32)x);\r\n}\r\nstatic inline void fsl_set_accessors(struct fsl_usb2_platform_data *pdata) {}\r\nstatic void done(struct fsl_ep *ep, struct fsl_req *req, int status)\r\n{\r\nstruct fsl_udc *udc = NULL;\r\nunsigned char stopped = ep->stopped;\r\nstruct ep_td_struct *curr_td, *next_td;\r\nint j;\r\nudc = (struct fsl_udc *)ep->udc;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nnext_td = req->head;\r\nfor (j = 0; j < req->dtd_count; j++) {\r\ncurr_td = next_td;\r\nif (j != req->dtd_count - 1) {\r\nnext_td = curr_td->next_td_virt;\r\n}\r\ndma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);\r\n}\r\nusb_gadget_unmap_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\r\nif (status && (status != -ESHUTDOWN))\r\nVDBG("complete %s req %p stat %d len %u/%u",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nspin_unlock(&ep->udc->lock);\r\nif (req->req.complete)\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&ep->udc->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic void nuke(struct fsl_ep *ep, int status)\r\n{\r\nep->stopped = 1;\r\nfsl_ep_fifo_flush(&ep->ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct fsl_req *req = NULL;\r\nreq = list_entry(ep->queue.next, struct fsl_req, queue);\r\ndone(ep, req, status);\r\n}\r\n}\r\nstatic int dr_controller_setup(struct fsl_udc *udc)\r\n{\r\nunsigned int tmp, portctrl, ep_num;\r\nunsigned int max_no_of_ep;\r\nunsigned int ctrl;\r\nunsigned long timeout;\r\n#define FSL_UDC_RESET_TIMEOUT 1000\r\nportctrl = fsl_readl(&dr_regs->portsc1);\r\nportctrl &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);\r\nswitch (udc->phy_mode) {\r\ncase FSL_USB2_PHY_ULPI:\r\nif (udc->pdata->have_sysif_regs) {\r\nif (udc->pdata->controller_ver) {\r\nctrl = __raw_readl(&usb_sys_regs->control);\r\nctrl &= ~USB_CTRL_UTMI_PHY_EN;\r\nctrl |= USB_CTRL_USB_EN;\r\n__raw_writel(ctrl, &usb_sys_regs->control);\r\n}\r\n}\r\nportctrl |= PORTSCX_PTS_ULPI;\r\nbreak;\r\ncase FSL_USB2_PHY_UTMI_WIDE:\r\nportctrl |= PORTSCX_PTW_16BIT;\r\ncase FSL_USB2_PHY_UTMI:\r\nif (udc->pdata->have_sysif_regs) {\r\nif (udc->pdata->controller_ver) {\r\nctrl = __raw_readl(&usb_sys_regs->control);\r\nctrl |= (USB_CTRL_UTMI_PHY_EN |\r\nUSB_CTRL_USB_EN);\r\n__raw_writel(ctrl, &usb_sys_regs->control);\r\nmdelay(FSL_UTMI_PHY_DLY);\r\n}\r\n}\r\nportctrl |= PORTSCX_PTS_UTMI;\r\nbreak;\r\ncase FSL_USB2_PHY_SERIAL:\r\nportctrl |= PORTSCX_PTS_FSLS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfsl_writel(portctrl, &dr_regs->portsc1);\r\ntmp = fsl_readl(&dr_regs->usbcmd);\r\ntmp &= ~USB_CMD_RUN_STOP;\r\nfsl_writel(tmp, &dr_regs->usbcmd);\r\ntmp = fsl_readl(&dr_regs->usbcmd);\r\ntmp |= USB_CMD_CTRL_RESET;\r\nfsl_writel(tmp, &dr_regs->usbcmd);\r\ntimeout = jiffies + FSL_UDC_RESET_TIMEOUT;\r\nwhile (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {\r\nif (time_after(jiffies, timeout)) {\r\nERR("udc reset timeout!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\ntmp = fsl_readl(&dr_regs->usbmode);\r\ntmp &= ~USB_MODE_CTRL_MODE_MASK;\r\ntmp |= USB_MODE_CTRL_MODE_DEVICE;\r\ntmp |= USB_MODE_SETUP_LOCK_OFF;\r\nif (udc->pdata->es)\r\ntmp |= USB_MODE_ES;\r\nfsl_writel(tmp, &dr_regs->usbmode);\r\nfsl_writel(0, &dr_regs->usbsts);\r\ntmp = udc->ep_qh_dma;\r\ntmp &= USB_EP_LIST_ADDRESS_MASK;\r\nfsl_writel(tmp, &dr_regs->endpointlistaddr);\r\nVDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",\r\nudc->ep_qh, (int)tmp,\r\nfsl_readl(&dr_regs->endpointlistaddr));\r\nmax_no_of_ep = (0x0000001F & fsl_readl(&dr_regs->dccparams));\r\nfor (ep_num = 1; ep_num < max_no_of_ep; ep_num++) {\r\ntmp = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\ntmp &= ~(EPCTRL_TX_TYPE | EPCTRL_RX_TYPE);\r\ntmp |= (EPCTRL_EP_TYPE_BULK << EPCTRL_TX_EP_TYPE_SHIFT)\r\n| (EPCTRL_EP_TYPE_BULK << EPCTRL_RX_EP_TYPE_SHIFT);\r\nfsl_writel(tmp, &dr_regs->endptctrl[ep_num]);\r\n}\r\n#ifndef CONFIG_ARCH_MXC\r\nif (udc->pdata->have_sysif_regs) {\r\nctrl = __raw_readl(&usb_sys_regs->control);\r\nctrl |= USB_CTRL_IOENB;\r\n__raw_writel(ctrl, &usb_sys_regs->control);\r\n}\r\n#endif\r\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\r\nif (udc->pdata->have_sysif_regs) {\r\ntmp = SNOOP_SIZE_2GB;\r\n__raw_writel(tmp, &usb_sys_regs->snoop1);\r\ntmp |= 0x80000000;\r\n__raw_writel(tmp, &usb_sys_regs->snoop2);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void dr_controller_run(struct fsl_udc *udc)\r\n{\r\nu32 temp;\r\ntemp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN\r\n| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN\r\n| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;\r\nfsl_writel(temp, &dr_regs->usbintr);\r\nudc->stopped = 0;\r\ntemp = fsl_readl(&dr_regs->usbmode);\r\ntemp |= USB_MODE_CTRL_MODE_DEVICE;\r\nfsl_writel(temp, &dr_regs->usbmode);\r\ntemp = fsl_readl(&dr_regs->usbcmd);\r\ntemp |= USB_CMD_RUN_STOP;\r\nfsl_writel(temp, &dr_regs->usbcmd);\r\n}\r\nstatic void dr_controller_stop(struct fsl_udc *udc)\r\n{\r\nunsigned int tmp;\r\npr_debug("%s\n", __func__);\r\nif (udc->gadget.is_otg) {\r\nif (!(fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID)) {\r\npr_debug("udc: Leaving early\n");\r\nreturn;\r\n}\r\n}\r\nfsl_writel(0, &dr_regs->usbintr);\r\nudc->stopped = 1;\r\ntmp = fsl_readl(&dr_regs->usbcmd);\r\ntmp &= ~USB_CMD_RUN_STOP;\r\nfsl_writel(tmp, &dr_regs->usbcmd);\r\n}\r\nstatic void dr_ep_setup(unsigned char ep_num, unsigned char dir,\r\nunsigned char ep_type)\r\n{\r\nunsigned int tmp_epctrl = 0;\r\ntmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\nif (dir) {\r\nif (ep_num)\r\ntmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;\r\ntmp_epctrl |= EPCTRL_TX_ENABLE;\r\ntmp_epctrl &= ~EPCTRL_TX_TYPE;\r\ntmp_epctrl |= ((unsigned int)(ep_type)\r\n<< EPCTRL_TX_EP_TYPE_SHIFT);\r\n} else {\r\nif (ep_num)\r\ntmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;\r\ntmp_epctrl |= EPCTRL_RX_ENABLE;\r\ntmp_epctrl &= ~EPCTRL_RX_TYPE;\r\ntmp_epctrl |= ((unsigned int)(ep_type)\r\n<< EPCTRL_RX_EP_TYPE_SHIFT);\r\n}\r\nfsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);\r\n}\r\nstatic void\r\ndr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)\r\n{\r\nu32 tmp_epctrl = 0;\r\ntmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\nif (value) {\r\nif (dir)\r\ntmp_epctrl |= EPCTRL_TX_EP_STALL;\r\nelse\r\ntmp_epctrl |= EPCTRL_RX_EP_STALL;\r\n} else {\r\nif (dir) {\r\ntmp_epctrl &= ~EPCTRL_TX_EP_STALL;\r\ntmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;\r\n} else {\r\ntmp_epctrl &= ~EPCTRL_RX_EP_STALL;\r\ntmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;\r\n}\r\n}\r\nfsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);\r\n}\r\nstatic int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)\r\n{\r\nu32 epctrl;\r\nepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\nif (dir)\r\nreturn (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;\r\nelse\r\nreturn (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;\r\n}\r\nstatic void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,\r\nunsigned char dir, unsigned char ep_type,\r\nunsigned int max_pkt_len,\r\nunsigned int zlt, unsigned char mult)\r\n{\r\nstruct ep_queue_head *p_QH = &udc->ep_qh[2 * ep_num + dir];\r\nunsigned int tmp = 0;\r\nswitch (ep_type) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ntmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\r\n| EP_QUEUE_HEAD_IOS;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ntmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\r\n| (mult << EP_QUEUE_HEAD_MULT_POS);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\ntmp = max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS;\r\nbreak;\r\ndefault:\r\nVDBG("error ep type is %d", ep_type);\r\nreturn;\r\n}\r\nif (zlt)\r\ntmp |= EP_QUEUE_HEAD_ZLT_SEL;\r\np_QH->max_pkt_length = cpu_to_hc32(tmp);\r\np_QH->next_dtd_ptr = 1;\r\np_QH->size_ioc_int_sts = 0;\r\n}\r\nstatic void ep0_setup(struct fsl_udc *udc)\r\n{\r\nstruct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,\r\nUSB_MAX_CTRL_PAYLOAD, 0, 0);\r\nstruct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,\r\nUSB_MAX_CTRL_PAYLOAD, 0, 0);\r\ndr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);\r\ndr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);\r\nreturn;\r\n}\r\nstatic int fsl_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct fsl_udc *udc = NULL;\r\nstruct fsl_ep *ep = NULL;\r\nunsigned short max = 0;\r\nunsigned char mult = 0, zlt;\r\nint retval = -EINVAL;\r\nunsigned long flags = 0;\r\nep = container_of(_ep, struct fsl_ep, ep);\r\nif (!_ep || !desc\r\n|| (desc->bDescriptorType != USB_DT_ENDPOINT))\r\nreturn -EINVAL;\r\nudc = ep->udc;\r\nif (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nmax = usb_endpoint_maxp(desc);\r\nzlt = 1;\r\nswitch (desc->bmAttributes & 0x03) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\nmult = 0;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nmult = (unsigned char)(1 + ((max >> 11) & 0x03));\r\nmax = max & 0x7ff;\r\nif (mult > 3)\r\ngoto en_done;\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->ep.maxpacket = max;\r\nep->ep.desc = desc;\r\nep->stopped = 0;\r\nstruct_ep_qh_setup(udc, (unsigned char) ep_index(ep),\r\n(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)\r\n? USB_SEND : USB_RECV),\r\n(unsigned char) (desc->bmAttributes\r\n& USB_ENDPOINT_XFERTYPE_MASK),\r\nmax, zlt, mult);\r\ndr_ep_setup((unsigned char) ep_index(ep),\r\n(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)\r\n? USB_SEND : USB_RECV),\r\n(unsigned char) (desc->bmAttributes\r\n& USB_ENDPOINT_XFERTYPE_MASK));\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nretval = 0;\r\nVDBG("enabled %s (ep%d%s) maxpacket %d",ep->ep.name,\r\nep->ep.desc->bEndpointAddress & 0x0f,\r\n(desc->bEndpointAddress & USB_DIR_IN)\r\n? "in" : "out", max);\r\nen_done:\r\nreturn retval;\r\n}\r\nstatic int fsl_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct fsl_udc *udc = NULL;\r\nstruct fsl_ep *ep = NULL;\r\nunsigned long flags = 0;\r\nu32 epctrl;\r\nint ep_num;\r\nep = container_of(_ep, struct fsl_ep, ep);\r\nif (!_ep || !ep->ep.desc) {\r\nVDBG("%s not enabled", _ep ? ep->ep.name : NULL);\r\nreturn -EINVAL;\r\n}\r\nep_num = ep_index(ep);\r\nepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\nif (ep_is_in(ep)) {\r\nepctrl &= ~(EPCTRL_TX_ENABLE | EPCTRL_TX_TYPE);\r\nepctrl |= EPCTRL_EP_TYPE_BULK << EPCTRL_TX_EP_TYPE_SHIFT;\r\n} else {\r\nepctrl &= ~(EPCTRL_RX_ENABLE | EPCTRL_TX_TYPE);\r\nepctrl |= EPCTRL_EP_TYPE_BULK << EPCTRL_RX_EP_TYPE_SHIFT;\r\n}\r\nfsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);\r\nudc = (struct fsl_udc *)ep->udc;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nnuke(ep, -ESHUTDOWN);\r\nep->ep.desc = NULL;\r\nep->stopped = 1;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nVDBG("disabled %s OK", _ep->name);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nfsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct fsl_req *req = NULL;\r\nreq = kzalloc(sizeof *req, gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nreq->req.dma = DMA_ADDR_INVALID;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void fsl_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct fsl_req *req = NULL;\r\nreq = container_of(_req, struct fsl_req, req);\r\nif (_req)\r\nkfree(req);\r\n}\r\nstatic void fsl_prime_ep(struct fsl_ep *ep, struct ep_td_struct *td)\r\n{\r\nstruct ep_queue_head *qh = get_qh_by_ep(ep);\r\nqh->next_dtd_ptr = cpu_to_hc32(td->td_dma\r\n& EP_QUEUE_HEAD_NEXT_POINTER_MASK);\r\nqh->size_ioc_int_sts &= cpu_to_hc32(~(EP_QUEUE_HEAD_STATUS_ACTIVE\r\n| EP_QUEUE_HEAD_STATUS_HALT));\r\nwmb();\r\nfsl_writel(ep_is_in(ep) ? (1 << (ep_index(ep) + 16))\r\n: (1 << (ep_index(ep))), &dr_regs->endpointprime);\r\n}\r\nstatic void fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)\r\n{\r\nu32 temp, bitmask, tmp_stat;\r\nbitmask = ep_is_in(ep)\r\n? (1 << (ep_index(ep) + 16))\r\n: (1 << (ep_index(ep)));\r\nif (!(list_empty(&ep->queue)) && !(ep_index(ep) == 0)) {\r\nstruct fsl_req *lastreq;\r\nlastreq = list_entry(ep->queue.prev, struct fsl_req, queue);\r\nlastreq->tail->next_td_ptr =\r\ncpu_to_hc32(req->head->td_dma & DTD_ADDR_MASK);\r\nwmb();\r\nif (fsl_readl(&dr_regs->endpointprime) & bitmask)\r\nreturn;\r\ndo {\r\ntemp = fsl_readl(&dr_regs->usbcmd);\r\nfsl_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);\r\ntmp_stat = fsl_readl(&dr_regs->endptstatus) & bitmask;\r\n} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));\r\ntemp = fsl_readl(&dr_regs->usbcmd);\r\nfsl_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);\r\nif (tmp_stat)\r\nreturn;\r\n}\r\nfsl_prime_ep(ep, req->head);\r\n}\r\nstatic struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,\r\ndma_addr_t *dma, int *is_last, gfp_t gfp_flags)\r\n{\r\nu32 swap_temp;\r\nstruct ep_td_struct *dtd;\r\n*length = min(req->req.length - req->req.actual,\r\n(unsigned)EP_MAX_LENGTH_TRANSFER);\r\ndtd = dma_pool_alloc(udc_controller->td_pool, gfp_flags, dma);\r\nif (dtd == NULL)\r\nreturn dtd;\r\ndtd->td_dma = *dma;\r\nswap_temp = hc32_to_cpu(dtd->size_ioc_sts);\r\nswap_temp &= ~DTD_RESERVED_FIELDS;\r\ndtd->size_ioc_sts = cpu_to_hc32(swap_temp);\r\nswap_temp = (u32) (req->req.dma + req->req.actual);\r\ndtd->buff_ptr0 = cpu_to_hc32(swap_temp);\r\ndtd->buff_ptr1 = cpu_to_hc32(swap_temp + 0x1000);\r\ndtd->buff_ptr2 = cpu_to_hc32(swap_temp + 0x2000);\r\ndtd->buff_ptr3 = cpu_to_hc32(swap_temp + 0x3000);\r\ndtd->buff_ptr4 = cpu_to_hc32(swap_temp + 0x4000);\r\nreq->req.actual += *length;\r\nif (req->req.zero) {\r\nif (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)\r\n*is_last = 1;\r\nelse\r\n*is_last = 0;\r\n} else if (req->req.length == req->req.actual)\r\n*is_last = 1;\r\nelse\r\n*is_last = 0;\r\nif ((*is_last) == 0)\r\nVDBG("multi-dtd request!");\r\nswap_temp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);\r\nif (*is_last && !req->req.no_interrupt)\r\nswap_temp |= DTD_IOC;\r\ndtd->size_ioc_sts = cpu_to_hc32(swap_temp);\r\nmb();\r\nVDBG("length = %d address= 0x%x", *length, (int)*dma);\r\nreturn dtd;\r\n}\r\nstatic int fsl_req_to_dtd(struct fsl_req *req, gfp_t gfp_flags)\r\n{\r\nunsigned count;\r\nint is_last;\r\nint is_first =1;\r\nstruct ep_td_struct *last_dtd = NULL, *dtd;\r\ndma_addr_t dma;\r\ndo {\r\ndtd = fsl_build_dtd(req, &count, &dma, &is_last, gfp_flags);\r\nif (dtd == NULL)\r\nreturn -ENOMEM;\r\nif (is_first) {\r\nis_first = 0;\r\nreq->head = dtd;\r\n} else {\r\nlast_dtd->next_td_ptr = cpu_to_hc32(dma);\r\nlast_dtd->next_td_virt = dtd;\r\n}\r\nlast_dtd = dtd;\r\nreq->dtd_count++;\r\n} while (!is_last);\r\ndtd->next_td_ptr = cpu_to_hc32(DTD_NEXT_TERMINATE);\r\nreq->tail = dtd;\r\nreturn 0;\r\n}\r\nstatic int\r\nfsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);\r\nstruct fsl_req *req = container_of(_req, struct fsl_req, req);\r\nstruct fsl_udc *udc;\r\nunsigned long flags;\r\nint ret;\r\nif (!_req || !req->req.complete || !req->req.buf\r\n|| !list_empty(&req->queue)) {\r\nVDBG("%s, bad params", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!_ep || !ep->ep.desc)) {\r\nVDBG("%s, bad ep", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (usb_endpoint_xfer_isoc(ep->ep.desc)) {\r\nif (req->req.length > ep->ep.maxpacket)\r\nreturn -EMSGSIZE;\r\n}\r\nudc = ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nreq->ep = ep;\r\nret = usb_gadget_map_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\r\nif (ret)\r\nreturn ret;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nreq->dtd_count = 0;\r\nif (!fsl_req_to_dtd(req, gfp_flags)) {\r\nspin_lock_irqsave(&udc->lock, flags);\r\nfsl_queue_td(ep, req);\r\n} else {\r\nreturn -ENOMEM;\r\n}\r\nif (req != NULL)\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fsl_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);\r\nstruct fsl_req *req;\r\nunsigned long flags;\r\nint ep_num, stopped, ret = 0;\r\nu32 epctrl;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nstopped = ep->stopped;\r\nep->stopped = 1;\r\nep_num = ep_index(ep);\r\nepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\nif (ep_is_in(ep))\r\nepctrl &= ~EPCTRL_TX_ENABLE;\r\nelse\r\nepctrl &= ~EPCTRL_RX_ENABLE;\r\nfsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ep->queue.next == &req->queue) {\r\n_req->status = -ECONNRESET;\r\nfsl_ep_fifo_flush(_ep);\r\nif (req->queue.next != &ep->queue) {\r\nstruct fsl_req *next_req;\r\nnext_req = list_entry(req->queue.next, struct fsl_req,\r\nqueue);\r\nfsl_prime_ep(ep, next_req->head);\r\n}\r\n} else {\r\nstruct fsl_req *prev_req;\r\nprev_req = list_entry(req->queue.prev, struct fsl_req, queue);\r\nprev_req->tail->next_td_ptr = req->tail->next_td_ptr;\r\n}\r\ndone(ep, req, -ECONNRESET);\r\nout: epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\r\nif (ep_is_in(ep))\r\nepctrl |= EPCTRL_TX_ENABLE;\r\nelse\r\nepctrl |= EPCTRL_RX_ENABLE;\r\nfsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);\r\nep->stopped = stopped;\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fsl_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct fsl_ep *ep = NULL;\r\nunsigned long flags = 0;\r\nint status = -EOPNOTSUPP;\r\nunsigned char ep_dir = 0, ep_num = 0;\r\nstruct fsl_udc *udc = NULL;\r\nep = container_of(_ep, struct fsl_ep, ep);\r\nudc = ep->udc;\r\nif (!_ep || !ep->ep.desc) {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nif (usb_endpoint_xfer_isoc(ep->ep.desc)) {\r\nstatus = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (value && ep_is_in(ep) && !list_empty(&ep->queue)) {\r\nstatus = -EAGAIN;\r\ngoto out;\r\n}\r\nstatus = 0;\r\nep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;\r\nep_num = (unsigned char)(ep_index(ep));\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\ndr_ep_change_stall(ep_num, ep_dir, value);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nif (ep_index(ep) == 0) {\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = 0;\r\n}\r\nout:\r\nVDBG(" %s %s halt stat %d", ep->ep.name,\r\nvalue ? "set" : "clear", status);\r\nreturn status;\r\n}\r\nstatic int fsl_ep_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct fsl_ep *ep;\r\nstruct fsl_udc *udc;\r\nint size = 0;\r\nu32 bitmask;\r\nstruct ep_queue_head *qh;\r\nep = container_of(_ep, struct fsl_ep, ep);\r\nif (!_ep || (!ep->ep.desc && ep_index(ep) != 0))\r\nreturn -ENODEV;\r\nudc = (struct fsl_udc *)ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nqh = get_qh_by_ep(ep);\r\nbitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :\r\n(1 << (ep_index(ep)));\r\nif (fsl_readl(&dr_regs->endptstatus) & bitmask)\r\nsize = (qh->size_ioc_int_sts & DTD_PACKET_SIZE)\r\n>> DTD_LENGTH_BIT_POS;\r\npr_debug("%s %u\n", __func__, size);\r\nreturn size;\r\n}\r\nstatic void fsl_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct fsl_ep *ep;\r\nint ep_num, ep_dir;\r\nu32 bits;\r\nunsigned long timeout;\r\n#define FSL_UDC_FLUSH_TIMEOUT 1000\r\nif (!_ep) {\r\nreturn;\r\n} else {\r\nep = container_of(_ep, struct fsl_ep, ep);\r\nif (!ep->ep.desc)\r\nreturn;\r\n}\r\nep_num = ep_index(ep);\r\nep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;\r\nif (ep_num == 0)\r\nbits = (1 << 16) | 1;\r\nelse if (ep_dir == USB_SEND)\r\nbits = 1 << (16 + ep_num);\r\nelse\r\nbits = 1 << ep_num;\r\ntimeout = jiffies + FSL_UDC_FLUSH_TIMEOUT;\r\ndo {\r\nfsl_writel(bits, &dr_regs->endptflush);\r\nwhile (fsl_readl(&dr_regs->endptflush)) {\r\nif (time_after(jiffies, timeout)) {\r\nERR("ep flush timeout\n");\r\nreturn;\r\n}\r\ncpu_relax();\r\n}\r\n} while (fsl_readl(&dr_regs->endptstatus) & bits);\r\n}\r\nstatic int fsl_get_frame(struct usb_gadget *gadget)\r\n{\r\nreturn (int)(fsl_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);\r\n}\r\nstatic int fsl_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct fsl_udc *udc = container_of(gadget, struct fsl_udc, gadget);\r\nu32 portsc;\r\nif (!udc->remote_wakeup)\r\nreturn -ENOTSUPP;\r\nportsc = fsl_readl(&dr_regs->portsc1);\r\nif (!(portsc & PORTSCX_PORT_SUSPEND))\r\nreturn 0;\r\nportsc |= PORTSCX_PORT_FORCE_RESUME;\r\nfsl_writel(portsc, &dr_regs->portsc1);\r\nreturn 0;\r\n}\r\nstatic int can_pullup(struct fsl_udc *udc)\r\n{\r\nreturn udc->driver && udc->softconnect && udc->vbus_active;\r\n}\r\nstatic int fsl_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct fsl_udc *udc;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct fsl_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nVDBG("VBUS %s", is_active ? "on" : "off");\r\nudc->vbus_active = (is_active != 0);\r\nif (can_pullup(udc))\r\nfsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),\r\n&dr_regs->usbcmd);\r\nelse\r\nfsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),\r\n&dr_regs->usbcmd);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fsl_vbus_draw(struct usb_gadget *gadget, unsigned mA)\r\n{\r\nstruct fsl_udc *udc;\r\nudc = container_of(gadget, struct fsl_udc, gadget);\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nreturn usb_phy_set_power(udc->transceiver, mA);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int fsl_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct fsl_udc *udc;\r\nudc = container_of(gadget, struct fsl_udc, gadget);\r\nudc->softconnect = (is_on != 0);\r\nif (can_pullup(udc))\r\nfsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),\r\n&dr_regs->usbcmd);\r\nelse\r\nfsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),\r\n&dr_regs->usbcmd);\r\nreturn 0;\r\n}\r\nstatic void ep0stall(struct fsl_udc *udc)\r\n{\r\nu32 tmp;\r\ntmp = fsl_readl(&dr_regs->endptctrl[0]);\r\ntmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;\r\nfsl_writel(tmp, &dr_regs->endptctrl[0]);\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = 0;\r\n}\r\nstatic int ep0_prime_status(struct fsl_udc *udc, int direction)\r\n{\r\nstruct fsl_req *req = udc->status_req;\r\nstruct fsl_ep *ep;\r\nint ret;\r\nif (direction == EP_DIR_IN)\r\nudc->ep0_dir = USB_DIR_IN;\r\nelse\r\nudc->ep0_dir = USB_DIR_OUT;\r\nep = &udc->eps[0];\r\nif (udc->ep0_state != DATA_STATE_XMIT)\r\nudc->ep0_state = WAIT_FOR_OUT_STATUS;\r\nreq->ep = ep;\r\nreq->req.length = 0;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nreq->req.complete = NULL;\r\nreq->dtd_count = 0;\r\nret = usb_gadget_map_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\r\nif (ret)\r\nreturn ret;\r\nif (fsl_req_to_dtd(req, GFP_ATOMIC) == 0)\r\nfsl_queue_td(ep, req);\r\nelse\r\nreturn -ENOMEM;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreturn 0;\r\n}\r\nstatic void udc_reset_ep_queue(struct fsl_udc *udc, u8 pipe)\r\n{\r\nstruct fsl_ep *ep = get_ep_by_pipe(udc, pipe);\r\nif (ep->name)\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\nstatic void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)\r\n{\r\nudc->device_address = (u8) value;\r\nudc->usb_state = USB_STATE_ADDRESS;\r\nif (ep0_prime_status(udc, EP_DIR_IN))\r\nep0stall(udc);\r\n}\r\nstatic void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,\r\nu16 index, u16 length)\r\n{\r\nu16 tmp = 0;\r\nstruct fsl_req *req;\r\nstruct fsl_ep *ep;\r\nint ret;\r\nep = &udc->eps[0];\r\nif ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\r\ntmp = 1 << USB_DEVICE_SELF_POWERED;\r\ntmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;\r\n} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {\r\ntmp = 0;\r\n} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {\r\nstruct fsl_ep *target_ep;\r\ntarget_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));\r\nif (!target_ep->ep.desc)\r\ngoto stall;\r\ntmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))\r\n<< USB_ENDPOINT_HALT;\r\n}\r\nudc->ep0_dir = USB_DIR_IN;\r\nreq = udc->status_req;\r\n*((u16 *) req->req.buf) = cpu_to_le16(tmp);\r\nreq->ep = ep;\r\nreq->req.length = 2;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nreq->req.complete = NULL;\r\nreq->dtd_count = 0;\r\nret = usb_gadget_map_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\r\nif (ret)\r\ngoto stall;\r\nif ((fsl_req_to_dtd(req, GFP_ATOMIC) == 0))\r\nfsl_queue_td(ep, req);\r\nelse\r\ngoto stall;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nudc->ep0_state = DATA_STATE_XMIT;\r\nif (ep0_prime_status(udc, EP_DIR_OUT))\r\nep0stall(udc);\r\nreturn;\r\nstall:\r\nep0stall(udc);\r\n}\r\nstatic void setup_received_irq(struct fsl_udc *udc,\r\nstruct usb_ctrlrequest *setup)\r\n{\r\nu16 wValue = le16_to_cpu(setup->wValue);\r\nu16 wIndex = le16_to_cpu(setup->wIndex);\r\nu16 wLength = le16_to_cpu(setup->wLength);\r\nudc_reset_ep_queue(udc, 0);\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nif ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))\r\n!= (USB_DIR_IN | USB_TYPE_STANDARD))\r\nbreak;\r\nch9getstatus(udc, setup->bRequestType, wValue, wIndex, wLength);\r\nreturn;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD\r\n| USB_RECIP_DEVICE))\r\nbreak;\r\nch9setaddress(udc, wValue, wIndex, wLength);\r\nreturn;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\n{\r\nint rc = -EOPNOTSUPP;\r\nu16 ptc = 0;\r\nif ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))\r\n== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {\r\nint pipe = get_pipe_by_windex(wIndex);\r\nstruct fsl_ep *ep;\r\nif (wValue != 0 || wLength != 0 || pipe >= udc->max_ep)\r\nbreak;\r\nep = get_ep_by_pipe(udc, pipe);\r\nspin_unlock(&udc->lock);\r\nrc = fsl_ep_set_halt(&ep->ep,\r\n(setup->bRequest == USB_REQ_SET_FEATURE)\r\n? 1 : 0);\r\nspin_lock(&udc->lock);\r\n} else if ((setup->bRequestType & (USB_RECIP_MASK\r\n| USB_TYPE_MASK)) == (USB_RECIP_DEVICE\r\n| USB_TYPE_STANDARD)) {\r\nif (wValue == USB_DEVICE_TEST_MODE)\r\nptc = wIndex >> 8;\r\nelse if (gadget_is_otg(&udc->gadget)) {\r\nif (setup->bRequest ==\r\nUSB_DEVICE_B_HNP_ENABLE)\r\nudc->gadget.b_hnp_enable = 1;\r\nelse if (setup->bRequest ==\r\nUSB_DEVICE_A_HNP_SUPPORT)\r\nudc->gadget.a_hnp_support = 1;\r\nelse if (setup->bRequest ==\r\nUSB_DEVICE_A_ALT_HNP_SUPPORT)\r\nudc->gadget.a_alt_hnp_support = 1;\r\n}\r\nrc = 0;\r\n} else\r\nbreak;\r\nif (rc == 0) {\r\nif (ep0_prime_status(udc, EP_DIR_IN))\r\nep0stall(udc);\r\n}\r\nif (ptc) {\r\nu32 tmp;\r\nmdelay(10);\r\ntmp = fsl_readl(&dr_regs->portsc1) | (ptc << 16);\r\nfsl_writel(tmp, &dr_regs->portsc1);\r\nprintk(KERN_INFO "udc: switch to test mode %d.\n", ptc);\r\n}\r\nreturn;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (wLength) {\r\nudc->ep0_dir = (setup->bRequestType & USB_DIR_IN)\r\n? USB_DIR_IN : USB_DIR_OUT;\r\nspin_unlock(&udc->lock);\r\nif (udc->driver->setup(&udc->gadget,\r\n&udc->local_setup_buff) < 0)\r\nep0stall(udc);\r\nspin_lock(&udc->lock);\r\nudc->ep0_state = (setup->bRequestType & USB_DIR_IN)\r\n? DATA_STATE_XMIT : DATA_STATE_RECV;\r\nif (udc->ep0_state == DATA_STATE_XMIT)\r\nif (ep0_prime_status(udc, EP_DIR_OUT))\r\nep0stall(udc);\r\n} else {\r\nudc->ep0_dir = USB_DIR_IN;\r\nspin_unlock(&udc->lock);\r\nif (udc->driver->setup(&udc->gadget,\r\n&udc->local_setup_buff) < 0)\r\nep0stall(udc);\r\nspin_lock(&udc->lock);\r\nudc->ep0_state = WAIT_FOR_OUT_STATUS;\r\n}\r\n}\r\nstatic void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,\r\nstruct fsl_req *req)\r\n{\r\nif (udc->usb_state == USB_STATE_ADDRESS) {\r\nu32 new_address = (u32) udc->device_address;\r\nfsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,\r\n&dr_regs->deviceaddr);\r\n}\r\ndone(ep0, req, 0);\r\nswitch (udc->ep0_state) {\r\ncase DATA_STATE_XMIT:\r\nudc->ep0_state = WAIT_FOR_OUT_STATUS;\r\nbreak;\r\ncase DATA_STATE_RECV:\r\nif (ep0_prime_status(udc, EP_DIR_IN))\r\nep0stall(udc);\r\nbreak;\r\ncase WAIT_FOR_OUT_STATUS:\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase WAIT_FOR_SETUP:\r\nERR("Unexpect ep0 packets\n");\r\nbreak;\r\ndefault:\r\nep0stall(udc);\r\nbreak;\r\n}\r\n}\r\nstatic void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)\r\n{\r\nu32 temp;\r\nstruct ep_queue_head *qh;\r\nstruct fsl_usb2_platform_data *pdata = udc->pdata;\r\nqh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];\r\ntemp = fsl_readl(&dr_regs->endptsetupstat);\r\nfsl_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);\r\ndo {\r\ntemp = fsl_readl(&dr_regs->usbcmd);\r\nfsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);\r\nif (pdata->le_setup_buf) {\r\nu32 *p = (u32 *)buffer_ptr;\r\nu32 *s = (u32 *)qh->setup_buffer;\r\n*p++ = le32_to_cpu(*s++);\r\n*p = le32_to_cpu(*s);\r\n} else {\r\nmemcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);\r\n}\r\n} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));\r\ntemp = fsl_readl(&dr_regs->usbcmd);\r\nfsl_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);\r\n}\r\nstatic int process_ep_req(struct fsl_udc *udc, int pipe,\r\nstruct fsl_req *curr_req)\r\n{\r\nstruct ep_td_struct *curr_td;\r\nint td_complete, actual, remaining_length, j, tmp;\r\nint status = 0;\r\nint errors = 0;\r\nstruct ep_queue_head *curr_qh = &udc->ep_qh[pipe];\r\nint direction = pipe % 2;\r\ncurr_td = curr_req->head;\r\ntd_complete = 0;\r\nactual = curr_req->req.length;\r\nfor (j = 0; j < curr_req->dtd_count; j++) {\r\nremaining_length = (hc32_to_cpu(curr_td->size_ioc_sts)\r\n& DTD_PACKET_SIZE)\r\n>> DTD_LENGTH_BIT_POS;\r\nactual -= remaining_length;\r\nerrors = hc32_to_cpu(curr_td->size_ioc_sts);\r\nif (errors & DTD_ERROR_MASK) {\r\nif (errors & DTD_STATUS_HALTED) {\r\nERR("dTD error %08x QH=%d\n", errors, pipe);\r\ntmp = hc32_to_cpu(curr_qh->size_ioc_int_sts);\r\ntmp &= ~errors;\r\ncurr_qh->size_ioc_int_sts = cpu_to_hc32(tmp);\r\nstatus = -EPIPE;\r\nbreak;\r\n}\r\nif (errors & DTD_STATUS_DATA_BUFF_ERR) {\r\nVDBG("Transfer overflow");\r\nstatus = -EPROTO;\r\nbreak;\r\n} else if (errors & DTD_STATUS_TRANSACTION_ERR) {\r\nVDBG("ISO error");\r\nstatus = -EILSEQ;\r\nbreak;\r\n} else\r\nERR("Unknown error has occurred (0x%x)!\n",\r\nerrors);\r\n} else if (hc32_to_cpu(curr_td->size_ioc_sts)\r\n& DTD_STATUS_ACTIVE) {\r\nVDBG("Request not complete");\r\nstatus = REQ_UNCOMPLETE;\r\nreturn status;\r\n} else if (remaining_length) {\r\nif (direction) {\r\nVDBG("Transmit dTD remaining length not zero");\r\nstatus = -EPROTO;\r\nbreak;\r\n} else {\r\ntd_complete++;\r\nbreak;\r\n}\r\n} else {\r\ntd_complete++;\r\nVDBG("dTD transmitted successful");\r\n}\r\nif (j != curr_req->dtd_count - 1)\r\ncurr_td = (struct ep_td_struct *)curr_td->next_td_virt;\r\n}\r\nif (status)\r\nreturn status;\r\ncurr_req->req.actual = actual;\r\nreturn 0;\r\n}\r\nstatic void dtd_complete_irq(struct fsl_udc *udc)\r\n{\r\nu32 bit_pos;\r\nint i, ep_num, direction, bit_mask, status;\r\nstruct fsl_ep *curr_ep;\r\nstruct fsl_req *curr_req, *temp_req;\r\nbit_pos = fsl_readl(&dr_regs->endptcomplete);\r\nfsl_writel(bit_pos, &dr_regs->endptcomplete);\r\nif (!bit_pos)\r\nreturn;\r\nfor (i = 0; i < udc->max_ep; i++) {\r\nep_num = i >> 1;\r\ndirection = i % 2;\r\nbit_mask = 1 << (ep_num + 16 * direction);\r\nif (!(bit_pos & bit_mask))\r\ncontinue;\r\ncurr_ep = get_ep_by_pipe(udc, i);\r\nif (curr_ep->name == NULL) {\r\nWARNING("Invalid EP?");\r\ncontinue;\r\n}\r\nlist_for_each_entry_safe(curr_req, temp_req, &curr_ep->queue,\r\nqueue) {\r\nstatus = process_ep_req(udc, i, curr_req);\r\nVDBG("status of process_ep_req= %d, ep = %d",\r\nstatus, ep_num);\r\nif (status == REQ_UNCOMPLETE)\r\nbreak;\r\ncurr_req->req.status = status;\r\nif (ep_num == 0) {\r\nep0_req_complete(udc, curr_ep, curr_req);\r\nbreak;\r\n} else\r\ndone(curr_ep, curr_req, status);\r\n}\r\n}\r\n}\r\nstatic inline enum usb_device_speed portscx_device_speed(u32 reg)\r\n{\r\nswitch (reg & PORTSCX_PORT_SPEED_MASK) {\r\ncase PORTSCX_PORT_SPEED_HIGH:\r\nreturn USB_SPEED_HIGH;\r\ncase PORTSCX_PORT_SPEED_FULL:\r\nreturn USB_SPEED_FULL;\r\ncase PORTSCX_PORT_SPEED_LOW:\r\nreturn USB_SPEED_LOW;\r\ndefault:\r\nreturn USB_SPEED_UNKNOWN;\r\n}\r\n}\r\nstatic void port_change_irq(struct fsl_udc *udc)\r\n{\r\nif (udc->bus_reset)\r\nudc->bus_reset = 0;\r\nif (!(fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET))\r\nudc->gadget.speed =\r\nportscx_device_speed(fsl_readl(&dr_regs->portsc1));\r\nif (!udc->resume_state)\r\nudc->usb_state = USB_STATE_DEFAULT;\r\n}\r\nstatic void suspend_irq(struct fsl_udc *udc)\r\n{\r\nudc->resume_state = udc->usb_state;\r\nudc->usb_state = USB_STATE_SUSPENDED;\r\nif (udc->driver->suspend)\r\nudc->driver->suspend(&udc->gadget);\r\n}\r\nstatic void bus_resume(struct fsl_udc *udc)\r\n{\r\nudc->usb_state = udc->resume_state;\r\nudc->resume_state = 0;\r\nif (udc->driver->resume)\r\nudc->driver->resume(&udc->gadget);\r\n}\r\nstatic int reset_queues(struct fsl_udc *udc)\r\n{\r\nu8 pipe;\r\nfor (pipe = 0; pipe < udc->max_pipes; pipe++)\r\nudc_reset_ep_queue(udc, pipe);\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\nreturn 0;\r\n}\r\nstatic void reset_irq(struct fsl_udc *udc)\r\n{\r\nu32 temp;\r\nunsigned long timeout;\r\ntemp = fsl_readl(&dr_regs->deviceaddr);\r\nfsl_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);\r\nudc->device_address = 0;\r\nudc->resume_state = 0;\r\nudc->ep0_dir = 0;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->remote_wakeup = 0;\r\nudc->gadget.b_hnp_enable = 0;\r\nudc->gadget.a_hnp_support = 0;\r\nudc->gadget.a_alt_hnp_support = 0;\r\ntemp = fsl_readl(&dr_regs->endptsetupstat);\r\nfsl_writel(temp, &dr_regs->endptsetupstat);\r\ntemp = fsl_readl(&dr_regs->endptcomplete);\r\nfsl_writel(temp, &dr_regs->endptcomplete);\r\ntimeout = jiffies + 100;\r\nwhile (fsl_readl(&dr_regs->endpointprime)) {\r\nif (time_after(jiffies, timeout)) {\r\nERR("Timeout for reset\n");\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nfsl_writel(0xffffffff, &dr_regs->endptflush);\r\nif (fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET) {\r\nVDBG("Bus reset");\r\nudc->bus_reset = 1;\r\nreset_queues(udc);\r\nudc->usb_state = USB_STATE_DEFAULT;\r\n} else {\r\nVDBG("Controller reset");\r\ndr_controller_setup(udc);\r\nreset_queues(udc);\r\nep0_setup(udc);\r\ndr_controller_run(udc);\r\nudc->usb_state = USB_STATE_ATTACHED;\r\n}\r\n}\r\nstatic irqreturn_t fsl_udc_irq(int irq, void *_udc)\r\n{\r\nstruct fsl_udc *udc = _udc;\r\nu32 irq_src;\r\nirqreturn_t status = IRQ_NONE;\r\nunsigned long flags;\r\nif (udc->stopped)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nirq_src = fsl_readl(&dr_regs->usbsts) & fsl_readl(&dr_regs->usbintr);\r\nfsl_writel(irq_src, &dr_regs->usbsts);\r\nif (udc->usb_state == USB_STATE_SUSPENDED)\r\nif ((fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SUSPEND) == 0)\r\nbus_resume(udc);\r\nif (irq_src & USB_STS_INT) {\r\nVDBG("Packet int");\r\nif (fsl_readl(&dr_regs->endptsetupstat) & EP_SETUP_STATUS_EP0) {\r\ntripwire_handler(udc, 0,\r\n(u8 *) (&udc->local_setup_buff));\r\nsetup_received_irq(udc, &udc->local_setup_buff);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (fsl_readl(&dr_regs->endptcomplete)) {\r\ndtd_complete_irq(udc);\r\nstatus = IRQ_HANDLED;\r\n}\r\n}\r\nif (irq_src & USB_STS_SOF) {\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_STS_PORT_CHANGE) {\r\nport_change_irq(udc);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_STS_RESET) {\r\nVDBG("reset int");\r\nreset_irq(udc);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_STS_SUSPEND) {\r\nsuspend_irq(udc);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & (USB_STS_ERR | USB_STS_SYS_ERR)) {\r\nVDBG("Error IRQ %x", irq_src);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic int fsl_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nint retval = 0;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&udc_controller->lock, flags);\r\ndriver->driver.bus = NULL;\r\nudc_controller->driver = driver;\r\nspin_unlock_irqrestore(&udc_controller->lock, flags);\r\nif (!IS_ERR_OR_NULL(udc_controller->transceiver)) {\r\nudc_controller->stopped = 1;\r\nprintk(KERN_INFO "Suspend udc for OTG auto detect\n");\r\nif (!IS_ERR_OR_NULL(udc_controller->transceiver)) {\r\nretval = otg_set_peripheral(\r\nudc_controller->transceiver->otg,\r\n&udc_controller->gadget);\r\nif (retval < 0) {\r\nERR("can't bind to transceiver\n");\r\ndriver->unbind(&udc_controller->gadget);\r\nudc_controller->driver = 0;\r\nreturn retval;\r\n}\r\n}\r\n} else {\r\ndr_controller_run(udc_controller);\r\nudc_controller->usb_state = USB_STATE_ATTACHED;\r\nudc_controller->ep0_state = WAIT_FOR_SETUP;\r\nudc_controller->ep0_dir = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic int fsl_udc_stop(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct fsl_ep *loop_ep;\r\nunsigned long flags;\r\nif (!IS_ERR_OR_NULL(udc_controller->transceiver))\r\notg_set_peripheral(udc_controller->transceiver->otg, NULL);\r\ndr_controller_stop(udc_controller);\r\nudc_controller->usb_state = USB_STATE_ATTACHED;\r\nudc_controller->ep0_state = WAIT_FOR_SETUP;\r\nudc_controller->ep0_dir = 0;\r\nspin_lock_irqsave(&udc_controller->lock, flags);\r\nudc_controller->gadget.speed = USB_SPEED_UNKNOWN;\r\nnuke(&udc_controller->eps[0], -ESHUTDOWN);\r\nlist_for_each_entry(loop_ep, &udc_controller->gadget.ep_list,\r\nep.ep_list)\r\nnuke(loop_ep, -ESHUTDOWN);\r\nspin_unlock_irqrestore(&udc_controller->lock, flags);\r\nudc_controller->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic int fsl_proc_read(struct seq_file *m, void *v)\r\n{\r\nunsigned long flags;\r\nint i;\r\nu32 tmp_reg;\r\nstruct fsl_ep *ep = NULL;\r\nstruct fsl_req *req;\r\nstruct fsl_udc *udc = udc_controller;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nseq_printf(m,\r\nDRIVER_DESC "\n"\r\n"%s version: %s\n"\r\n"Gadget driver: %s\n\n",\r\ndriver_name, DRIVER_VERSION,\r\nudc->driver ? udc->driver->driver.name : "(none)");\r\ntmp_reg = fsl_readl(&dr_regs->usbcmd);\r\nseq_printf(m,\r\n"USBCMD reg:\n"\r\n"SetupTW: %d\n"\r\n"Run/Stop: %s\n\n",\r\n(tmp_reg & USB_CMD_SUTW) ? 1 : 0,\r\n(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");\r\ntmp_reg = fsl_readl(&dr_regs->usbsts);\r\nseq_printf(m,\r\n"USB Status Reg:\n"\r\n"Dr Suspend: %d Reset Received: %d System Error: %s "\r\n"USB Error Interrupt: %s\n\n",\r\n(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,\r\n(tmp_reg & USB_STS_RESET) ? 1 : 0,\r\n(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",\r\n(tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");\r\ntmp_reg = fsl_readl(&dr_regs->usbintr);\r\nseq_printf(m,\r\n"USB Interrupt Enable Reg:\n"\r\n"Sleep Enable: %d SOF Received Enable: %d "\r\n"Reset Enable: %d\n"\r\n"System Error Enable: %d "\r\n"Port Change Dectected Enable: %d\n"\r\n"USB Error Intr Enable: %d USB Intr Enable: %d\n\n",\r\n(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,\r\n(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,\r\n(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,\r\n(tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,\r\n(tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,\r\n(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,\r\n(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);\r\ntmp_reg = fsl_readl(&dr_regs->frindex);\r\nseq_printf(m,\r\n"USB Frame Index Reg: Frame Number is 0x%x\n\n",\r\n(tmp_reg & USB_FRINDEX_MASKS));\r\ntmp_reg = fsl_readl(&dr_regs->deviceaddr);\r\nseq_printf(m,\r\n"USB Device Address Reg: Device Addr is 0x%x\n\n",\r\n(tmp_reg & USB_DEVICE_ADDRESS_MASK));\r\ntmp_reg = fsl_readl(&dr_regs->endpointlistaddr);\r\nseq_printf(m,\r\n"USB Endpoint List Address Reg: "\r\n"Device Addr is 0x%x\n\n",\r\n(tmp_reg & USB_EP_LIST_ADDRESS_MASK));\r\ntmp_reg = fsl_readl(&dr_regs->portsc1);\r\nseq_printf(m,\r\n"USB Port Status&Control Reg:\n"\r\n"Port Transceiver Type : %s Port Speed: %s\n"\r\n"PHY Low Power Suspend: %s Port Reset: %s "\r\n"Port Suspend Mode: %s\n"\r\n"Over-current Change: %s "\r\n"Port Enable/Disable Change: %s\n"\r\n"Port Enabled/Disabled: %s "\r\n"Current Connect Status: %s\n\n", ( {\r\nconst char *s;\r\nswitch (tmp_reg & PORTSCX_PTS_FSLS) {\r\ncase PORTSCX_PTS_UTMI:\r\ns = "UTMI"; break;\r\ncase PORTSCX_PTS_ULPI:\r\ns = "ULPI "; break;\r\ncase PORTSCX_PTS_FSLS:\r\ns = "FS/LS Serial"; break;\r\ndefault:\r\ns = "None"; break;\r\n}\r\ns;} ),\r\nusb_speed_string(portscx_device_speed(tmp_reg)),\r\n(tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?\r\n"Normal PHY mode" : "Low power mode",\r\n(tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :\r\n"Not in Reset",\r\n(tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",\r\n(tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :\r\n"No",\r\n(tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :\r\n"Not change",\r\n(tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :\r\n"Not correct",\r\n(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?\r\n"Attached" : "Not-Att");\r\ntmp_reg = fsl_readl(&dr_regs->usbmode);\r\nseq_printf(m,\r\n"USB Mode Reg: Controller Mode is: %s\n\n", ( {\r\nconst char *s;\r\nswitch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {\r\ncase USB_MODE_CTRL_MODE_IDLE:\r\ns = "Idle"; break;\r\ncase USB_MODE_CTRL_MODE_DEVICE:\r\ns = "Device Controller"; break;\r\ncase USB_MODE_CTRL_MODE_HOST:\r\ns = "Host Controller"; break;\r\ndefault:\r\ns = "None"; break;\r\n}\r\ns;\r\n} ));\r\ntmp_reg = fsl_readl(&dr_regs->endptsetupstat);\r\nseq_printf(m,\r\n"Endpoint Setup Status Reg: SETUP on ep 0x%x\n\n",\r\n(tmp_reg & EP_SETUP_STATUS_MASK));\r\nfor (i = 0; i < udc->max_ep / 2; i++) {\r\ntmp_reg = fsl_readl(&dr_regs->endptctrl[i]);\r\nseq_printf(m, "EP Ctrl Reg [0x%x]: = [0x%x]\n", i, tmp_reg);\r\n}\r\ntmp_reg = fsl_readl(&dr_regs->endpointprime);\r\nseq_printf(m, "EP Prime Reg = [0x%x]\n\n", tmp_reg);\r\n#ifndef CONFIG_ARCH_MXC\r\nif (udc->pdata->have_sysif_regs) {\r\ntmp_reg = usb_sys_regs->snoop1;\r\nseq_printf(m, "Snoop1 Reg : = [0x%x]\n\n", tmp_reg);\r\ntmp_reg = usb_sys_regs->control;\r\nseq_printf(m, "General Control Reg : = [0x%x]\n\n", tmp_reg);\r\n}\r\n#endif\r\nep = &udc->eps[0];\r\nseq_printf(m, "For %s Maxpkt is 0x%x index is 0x%x\n",\r\nep->ep.name, ep_maxpacket(ep), ep_index(ep));\r\nif (list_empty(&ep->queue)) {\r\nseq_puts(m, "its req queue is empty\n\n");\r\n} else {\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nseq_printf(m,\r\n"req %p actual 0x%x length 0x%x buf %p\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf);\r\n}\r\n}\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\r\nif (ep->ep.desc) {\r\nseq_printf(m,\r\n"\nFor %s Maxpkt is 0x%x "\r\n"index is 0x%x\n",\r\nep->ep.name, ep_maxpacket(ep),\r\nep_index(ep));\r\nif (list_empty(&ep->queue)) {\r\nseq_puts(m, "its req queue is empty\n\n");\r\n} else {\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nseq_printf(m,\r\n"req %p actual 0x%x length "\r\n"0x%x buf %p\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf);\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fsl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fsl_proc_read, NULL);\r\n}\r\nstatic void fsl_udc_release(struct device *dev)\r\n{\r\ncomplete(udc_controller->done);\r\ndma_free_coherent(dev->parent, udc_controller->ep_qh_size,\r\nudc_controller->ep_qh, udc_controller->ep_qh_dma);\r\nkfree(udc_controller);\r\n}\r\nstatic int __init struct_udc_setup(struct fsl_udc *udc,\r\nstruct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata;\r\nsize_t size;\r\npdata = pdev->dev.platform_data;\r\nudc->phy_mode = pdata->phy_mode;\r\nudc->eps = kzalloc(sizeof(struct fsl_ep) * udc->max_ep, GFP_KERNEL);\r\nif (!udc->eps) {\r\nERR("malloc fsl_ep failed\n");\r\nreturn -1;\r\n}\r\nsize = udc->max_ep * sizeof(struct ep_queue_head);\r\nif (size < QH_ALIGNMENT)\r\nsize = QH_ALIGNMENT;\r\nelse if ((size % QH_ALIGNMENT) != 0) {\r\nsize += QH_ALIGNMENT + 1;\r\nsize &= ~(QH_ALIGNMENT - 1);\r\n}\r\nudc->ep_qh = dma_alloc_coherent(&pdev->dev, size,\r\n&udc->ep_qh_dma, GFP_KERNEL);\r\nif (!udc->ep_qh) {\r\nERR("malloc QHs for udc failed\n");\r\nkfree(udc->eps);\r\nreturn -1;\r\n}\r\nudc->ep_qh_size = size;\r\nudc->status_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),\r\nstruct fsl_req, req);\r\nudc->status_req->req.buf = kmalloc(8, GFP_KERNEL);\r\nudc->resume_state = USB_STATE_NOTATTACHED;\r\nudc->usb_state = USB_STATE_POWERED;\r\nudc->ep0_dir = 0;\r\nudc->remote_wakeup = 0;\r\nreturn 0;\r\n}\r\nstatic int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,\r\nchar *name, int link)\r\n{\r\nstruct fsl_ep *ep = &udc->eps[index];\r\nep->udc = udc;\r\nstrcpy(ep->name, name);\r\nep->ep.name = ep->name;\r\nep->ep.ops = &fsl_ep_ops;\r\nep->stopped = 0;\r\nep->ep.maxpacket = (unsigned short) ~0;\r\nINIT_LIST_HEAD(&ep->queue);\r\nif (link)\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nep->gadget = &udc->gadget;\r\nep->qh = &udc->ep_qh[index];\r\nreturn 0;\r\n}\r\nstatic int __init fsl_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata;\r\nstruct resource *res;\r\nint ret = -ENODEV;\r\nunsigned int i;\r\nu32 dccparams;\r\nudc_controller = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);\r\nif (udc_controller == NULL) {\r\nERR("malloc udc failed\n");\r\nreturn -ENOMEM;\r\n}\r\npdata = pdev->dev.platform_data;\r\nudc_controller->pdata = pdata;\r\nspin_lock_init(&udc_controller->lock);\r\nudc_controller->stopped = 1;\r\n#ifdef CONFIG_USB_OTG\r\nif (pdata->operating_mode == FSL_USB2_DR_OTG) {\r\nudc_controller->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(udc_controller->transceiver)) {\r\nERR("Can't find OTG driver!\n");\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\n}\r\n#endif\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENXIO;\r\ngoto err_kfree;\r\n}\r\nif (pdata->operating_mode == FSL_USB2_DR_DEVICE) {\r\nif (!request_mem_region(res->start, resource_size(res),\r\ndriver_name)) {\r\nERR("request mem region for %s failed\n", pdev->name);\r\nret = -EBUSY;\r\ngoto err_kfree;\r\n}\r\n}\r\ndr_regs = ioremap(res->start, resource_size(res));\r\nif (!dr_regs) {\r\nret = -ENOMEM;\r\ngoto err_release_mem_region;\r\n}\r\npdata->regs = (void *)dr_regs;\r\nif (pdata->init && pdata->init(pdev)) {\r\nret = -ENODEV;\r\ngoto err_iounmap_noclk;\r\n}\r\nfsl_set_accessors(pdata);\r\n#ifndef CONFIG_ARCH_MXC\r\nif (pdata->have_sysif_regs)\r\nusb_sys_regs = (void *)dr_regs + USB_DR_SYS_OFFSET;\r\n#endif\r\nret = fsl_udc_clk_init(pdev);\r\nif (ret < 0)\r\ngoto err_iounmap_noclk;\r\ndccparams = fsl_readl(&dr_regs->dccparams);\r\nif (!(dccparams & DCCPARAMS_DC)) {\r\nERR("This SOC doesn't support device role\n");\r\nret = -ENODEV;\r\ngoto err_iounmap;\r\n}\r\nudc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;\r\nudc_controller->irq = platform_get_irq(pdev, 0);\r\nif (!udc_controller->irq) {\r\nret = -ENODEV;\r\ngoto err_iounmap;\r\n}\r\nret = request_irq(udc_controller->irq, fsl_udc_irq, IRQF_SHARED,\r\ndriver_name, udc_controller);\r\nif (ret != 0) {\r\nERR("cannot request irq %d err %d\n",\r\nudc_controller->irq, ret);\r\ngoto err_iounmap;\r\n}\r\nif (struct_udc_setup(udc_controller, pdev)) {\r\nERR("Can't initialize udc data structure\n");\r\nret = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\nif (IS_ERR_OR_NULL(udc_controller->transceiver)) {\r\ndr_controller_setup(udc_controller);\r\n}\r\nret = fsl_udc_clk_finalize(pdev);\r\nif (ret)\r\ngoto err_free_irq;\r\nudc_controller->gadget.ops = &fsl_gadget_ops;\r\nudc_controller->gadget.max_speed = USB_SPEED_HIGH;\r\nudc_controller->gadget.ep0 = &udc_controller->eps[0].ep;\r\nINIT_LIST_HEAD(&udc_controller->gadget.ep_list);\r\nudc_controller->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc_controller->gadget.name = driver_name;\r\ndev_set_name(&udc_controller->gadget.dev, "gadget");\r\nudc_controller->gadget.dev.of_node = pdev->dev.of_node;\r\nif (!IS_ERR_OR_NULL(udc_controller->transceiver))\r\nudc_controller->gadget.is_otg = 1;\r\nep0_setup(udc_controller);\r\nstruct_ep_setup(udc_controller, 0, "ep0", 0);\r\nudc_controller->eps[0].ep.desc = &fsl_ep0_desc;\r\nudc_controller->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;\r\nfor (i = 1; i < (int)(udc_controller->max_ep / 2); i++) {\r\nchar name[14];\r\nsprintf(name, "ep%dout", i);\r\nstruct_ep_setup(udc_controller, i * 2, name, 1);\r\nsprintf(name, "ep%din", i);\r\nstruct_ep_setup(udc_controller, i * 2 + 1, name, 1);\r\n}\r\nudc_controller->td_pool = dma_pool_create("udc_td", &pdev->dev,\r\nsizeof(struct ep_td_struct),\r\nDTD_ALIGNMENT, UDC_DMA_BOUNDARY);\r\nif (udc_controller->td_pool == NULL) {\r\nret = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\nret = usb_add_gadget_udc_release(&pdev->dev, &udc_controller->gadget,\r\nfsl_udc_release);\r\nif (ret)\r\ngoto err_del_udc;\r\ncreate_proc_file();\r\nreturn 0;\r\nerr_del_udc:\r\ndma_pool_destroy(udc_controller->td_pool);\r\nerr_free_irq:\r\nfree_irq(udc_controller->irq, udc_controller);\r\nerr_iounmap:\r\nif (pdata->exit)\r\npdata->exit(pdev);\r\nfsl_udc_clk_release();\r\nerr_iounmap_noclk:\r\niounmap(dr_regs);\r\nerr_release_mem_region:\r\nif (pdata->operating_mode == FSL_USB2_DR_DEVICE)\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_kfree:\r\nkfree(udc_controller);\r\nudc_controller = NULL;\r\nreturn ret;\r\n}\r\nstatic int __exit fsl_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;\r\nDECLARE_COMPLETION(done);\r\nif (!udc_controller)\r\nreturn -ENODEV;\r\nusb_del_gadget_udc(&udc_controller->gadget);\r\nudc_controller->done = &done;\r\nfsl_udc_clk_release();\r\nremove_proc_file();\r\nkfree(udc_controller->status_req->req.buf);\r\nkfree(udc_controller->status_req);\r\nkfree(udc_controller->eps);\r\ndma_pool_destroy(udc_controller->td_pool);\r\nfree_irq(udc_controller->irq, udc_controller);\r\niounmap(dr_regs);\r\nif (pdata->operating_mode == FSL_USB2_DR_DEVICE)\r\nrelease_mem_region(res->start, resource_size(res));\r\nwait_for_completion(&done);\r\nif (pdata->exit)\r\npdata->exit(pdev);\r\nreturn 0;\r\n}\r\nstatic int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\ndr_controller_stop(udc_controller);\r\nreturn 0;\r\n}\r\nstatic int fsl_udc_resume(struct platform_device *pdev)\r\n{\r\nif (udc_controller->stopped) {\r\ndr_controller_setup(udc_controller);\r\ndr_controller_run(udc_controller);\r\n}\r\nudc_controller->usb_state = USB_STATE_ATTACHED;\r\nudc_controller->ep0_state = WAIT_FOR_SETUP;\r\nudc_controller->ep0_dir = 0;\r\nreturn 0;\r\n}\r\nstatic int fsl_udc_otg_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct fsl_udc *udc = udc_controller;\r\nu32 mode, usbcmd;\r\nmode = fsl_readl(&dr_regs->usbmode) & USB_MODE_CTRL_MODE_MASK;\r\npr_debug("%s(): mode 0x%x stopped %d\n", __func__, mode, udc->stopped);\r\nif (udc->stopped) {\r\npr_debug("gadget already stopped, leaving early\n");\r\nudc->already_stopped = 1;\r\nreturn 0;\r\n}\r\nif (mode != USB_MODE_CTRL_MODE_DEVICE) {\r\npr_debug("gadget not in device mode, leaving early\n");\r\nreturn 0;\r\n}\r\nusbcmd = fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;\r\nfsl_writel(usbcmd, &dr_regs->usbcmd);\r\nudc->stopped = 1;\r\npr_info("USB Gadget suspended\n");\r\nreturn 0;\r\n}\r\nstatic int fsl_udc_otg_resume(struct device *dev)\r\n{\r\npr_debug("%s(): stopped %d already_stopped %d\n", __func__,\r\nudc_controller->stopped, udc_controller->already_stopped);\r\nif (udc_controller->already_stopped) {\r\nudc_controller->already_stopped = 0;\r\npr_debug("gadget was already stopped, leaving early\n");\r\nreturn 0;\r\n}\r\npr_info("USB Gadget resume\n");\r\nreturn fsl_udc_resume(NULL);\r\n}
