static void set_device_claimage(struct bbc_i2c_bus *bp, struct platform_device *op, int val)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_CHILDREN; i++) {\r\nif (bp->devs[i].device == op) {\r\nbp->devs[i].client_claimed = val;\r\nreturn;\r\n}\r\n}\r\n}\r\nstruct platform_device *bbc_i2c_getdev(struct bbc_i2c_bus *bp, int index)\r\n{\r\nstruct platform_device *op = NULL;\r\nint curidx = 0, i;\r\nfor (i = 0; i < NUM_CHILDREN; i++) {\r\nif (!(op = bp->devs[i].device))\r\nbreak;\r\nif (curidx == index)\r\ngoto out;\r\nop = NULL;\r\ncuridx++;\r\n}\r\nout:\r\nif (curidx == index)\r\nreturn op;\r\nreturn NULL;\r\n}\r\nstruct bbc_i2c_client *bbc_i2c_attach(struct bbc_i2c_bus *bp, struct platform_device *op)\r\n{\r\nstruct bbc_i2c_client *client;\r\nconst u32 *reg;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (!client)\r\nreturn NULL;\r\nclient->bp = bp;\r\nclient->op = op;\r\nreg = of_get_property(op->dev.of_node, "reg", NULL);\r\nif (!reg) {\r\nkfree(client);\r\nreturn NULL;\r\n}\r\nclient->bus = reg[0];\r\nclient->address = reg[1];\r\nclaim_device(bp, op);\r\nreturn client;\r\n}\r\nvoid bbc_i2c_detach(struct bbc_i2c_client *client)\r\n{\r\nstruct bbc_i2c_bus *bp = client->bp;\r\nstruct platform_device *op = client->op;\r\nrelease_device(bp, op);\r\nkfree(client);\r\n}\r\nstatic int wait_for_pin(struct bbc_i2c_bus *bp, u8 *status)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint limit = 32;\r\nint ret = 1;\r\nbp->waiting = 1;\r\nadd_wait_queue(&bp->wq, &wait);\r\nwhile (limit-- > 0) {\r\nlong val;\r\nval = wait_event_interruptible_timeout(\r\nbp->wq,\r\n(((*status = readb(bp->i2c_control_regs + 0))\r\n& I2C_PCF_PIN) == 0),\r\nmsecs_to_jiffies(250));\r\nif (val > 0) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&bp->wq, &wait);\r\nbp->waiting = 0;\r\nreturn ret;\r\n}\r\nint bbc_i2c_writeb(struct bbc_i2c_client *client, unsigned char val, int off)\r\n{\r\nstruct bbc_i2c_bus *bp = client->bp;\r\nint address = client->address;\r\nu8 status;\r\nint ret = -1;\r\nif (bp->i2c_bussel_reg != NULL)\r\nwriteb(client->bus, bp->i2c_bussel_reg);\r\nwriteb(address, bp->i2c_control_regs + 0x1);\r\nwriteb(I2C_PCF_START, bp->i2c_control_regs + 0x0);\r\nif (wait_for_pin(bp, &status))\r\ngoto out;\r\nwriteb(off, bp->i2c_control_regs + 0x1);\r\nif (wait_for_pin(bp, &status) ||\r\n(status & I2C_PCF_LRB) != 0)\r\ngoto out;\r\nwriteb(val, bp->i2c_control_regs + 0x1);\r\nif (wait_for_pin(bp, &status))\r\ngoto out;\r\nret = 0;\r\nout:\r\nwriteb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);\r\nreturn ret;\r\n}\r\nint bbc_i2c_readb(struct bbc_i2c_client *client, unsigned char *byte, int off)\r\n{\r\nstruct bbc_i2c_bus *bp = client->bp;\r\nunsigned char address = client->address, status;\r\nint ret = -1;\r\nif (bp->i2c_bussel_reg != NULL)\r\nwriteb(client->bus, bp->i2c_bussel_reg);\r\nwriteb(address, bp->i2c_control_regs + 0x1);\r\nwriteb(I2C_PCF_START, bp->i2c_control_regs + 0x0);\r\nif (wait_for_pin(bp, &status))\r\ngoto out;\r\nwriteb(off, bp->i2c_control_regs + 0x1);\r\nif (wait_for_pin(bp, &status) ||\r\n(status & I2C_PCF_LRB) != 0)\r\ngoto out;\r\nwriteb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);\r\naddress |= 0x1;\r\nwriteb(address, bp->i2c_control_regs + 0x1);\r\nwriteb(I2C_PCF_START, bp->i2c_control_regs + 0x0);\r\nif (wait_for_pin(bp, &status))\r\ngoto out;\r\n(void) readb(bp->i2c_control_regs + 0x1);\r\nif (wait_for_pin(bp, &status))\r\ngoto out;\r\nwriteb(I2C_PCF_ESO | I2C_PCF_ENI, bp->i2c_control_regs + 0x0);\r\n*byte = readb(bp->i2c_control_regs + 0x1);\r\nif (wait_for_pin(bp, &status))\r\ngoto out;\r\nret = 0;\r\nout:\r\nwriteb(I2C_PCF_STOP, bp->i2c_control_regs + 0x0);\r\n(void) readb(bp->i2c_control_regs + 0x1);\r\nreturn ret;\r\n}\r\nint bbc_i2c_write_buf(struct bbc_i2c_client *client,\r\nchar *buf, int len, int off)\r\n{\r\nint ret = 0;\r\nwhile (len > 0) {\r\nret = bbc_i2c_writeb(client, *buf, off);\r\nif (ret < 0)\r\nbreak;\r\nlen--;\r\nbuf++;\r\noff++;\r\n}\r\nreturn ret;\r\n}\r\nint bbc_i2c_read_buf(struct bbc_i2c_client *client,\r\nchar *buf, int len, int off)\r\n{\r\nint ret = 0;\r\nwhile (len > 0) {\r\nret = bbc_i2c_readb(client, buf, off);\r\nif (ret < 0)\r\nbreak;\r\nlen--;\r\nbuf++;\r\noff++;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t bbc_i2c_interrupt(int irq, void *dev_id)\r\n{\r\nstruct bbc_i2c_bus *bp = dev_id;\r\nif (bp->waiting &&\r\n!(readb(bp->i2c_control_regs + 0x0) & I2C_PCF_PIN))\r\nwake_up_interruptible(&bp->wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void reset_one_i2c(struct bbc_i2c_bus *bp)\r\n{\r\nwriteb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);\r\nwriteb(bp->own, bp->i2c_control_regs + 0x1);\r\nwriteb(I2C_PCF_PIN | I2C_PCF_ES1, bp->i2c_control_regs + 0x0);\r\nwriteb(bp->clock, bp->i2c_control_regs + 0x1);\r\nwriteb(I2C_PCF_IDLE, bp->i2c_control_regs + 0x0);\r\n}\r\nstatic struct bbc_i2c_bus * attach_one_i2c(struct platform_device *op, int index)\r\n{\r\nstruct bbc_i2c_bus *bp;\r\nstruct device_node *dp;\r\nint entry;\r\nbp = kzalloc(sizeof(*bp), GFP_KERNEL);\r\nif (!bp)\r\nreturn NULL;\r\nbp->i2c_control_regs = of_ioremap(&op->resource[0], 0, 0x2, "bbc_i2c_regs");\r\nif (!bp->i2c_control_regs)\r\ngoto fail;\r\nbp->i2c_bussel_reg = of_ioremap(&op->resource[1], 0, 0x1, "bbc_i2c_bussel");\r\nif (!bp->i2c_bussel_reg)\r\ngoto fail;\r\nbp->waiting = 0;\r\ninit_waitqueue_head(&bp->wq);\r\nif (request_irq(op->archdata.irqs[0], bbc_i2c_interrupt,\r\nIRQF_SHARED, "bbc_i2c", bp))\r\ngoto fail;\r\nbp->index = index;\r\nbp->op = op;\r\nspin_lock_init(&bp->lock);\r\nentry = 0;\r\nfor (dp = op->dev.of_node->child;\r\ndp && entry < 8;\r\ndp = dp->sibling, entry++) {\r\nstruct platform_device *child_op;\r\nchild_op = of_find_device_by_node(dp);\r\nbp->devs[entry].device = child_op;\r\nbp->devs[entry].client_claimed = 0;\r\n}\r\nwriteb(I2C_PCF_PIN, bp->i2c_control_regs + 0x0);\r\nbp->own = readb(bp->i2c_control_regs + 0x01);\r\nwriteb(I2C_PCF_PIN | I2C_PCF_ES1, bp->i2c_control_regs + 0x0);\r\nbp->clock = readb(bp->i2c_control_regs + 0x01);\r\nprintk(KERN_INFO "i2c-%d: Regs at %p, %d devices, own %02x, clock %02x.\n",\r\nbp->index, bp->i2c_control_regs, entry, bp->own, bp->clock);\r\nreset_one_i2c(bp);\r\nreturn bp;\r\nfail:\r\nif (bp->i2c_bussel_reg)\r\nof_iounmap(&op->resource[1], bp->i2c_bussel_reg, 1);\r\nif (bp->i2c_control_regs)\r\nof_iounmap(&op->resource[0], bp->i2c_control_regs, 2);\r\nkfree(bp);\r\nreturn NULL;\r\n}\r\nstatic int bbc_i2c_probe(struct platform_device *op)\r\n{\r\nstruct bbc_i2c_bus *bp;\r\nint err, index = 0;\r\nbp = attach_one_i2c(op, index);\r\nif (!bp)\r\nreturn -EINVAL;\r\nerr = bbc_envctrl_init(bp);\r\nif (err) {\r\nfree_irq(op->archdata.irqs[0], bp);\r\nif (bp->i2c_bussel_reg)\r\nof_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);\r\nif (bp->i2c_control_regs)\r\nof_iounmap(&op->resource[1], bp->i2c_control_regs, 2);\r\nkfree(bp);\r\n} else {\r\ndev_set_drvdata(&op->dev, bp);\r\n}\r\nreturn err;\r\n}\r\nstatic int bbc_i2c_remove(struct platform_device *op)\r\n{\r\nstruct bbc_i2c_bus *bp = dev_get_drvdata(&op->dev);\r\nbbc_envctrl_cleanup(bp);\r\nfree_irq(op->archdata.irqs[0], bp);\r\nif (bp->i2c_bussel_reg)\r\nof_iounmap(&op->resource[0], bp->i2c_bussel_reg, 1);\r\nif (bp->i2c_control_regs)\r\nof_iounmap(&op->resource[1], bp->i2c_control_regs, 2);\r\nkfree(bp);\r\nreturn 0;\r\n}
