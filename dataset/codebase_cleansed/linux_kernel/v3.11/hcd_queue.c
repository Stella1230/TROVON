static void dwc2_qh_init(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nstruct dwc2_hcd_urb *urb)\r\n{\r\nint dev_speed, hub_addr, hub_port;\r\nchar *speed, *type;\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nqh->ep_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\r\nqh->ep_is_in = dwc2_hcd_is_pipe_in(&urb->pipe_info) ? 1 : 0;\r\nqh->data_toggle = DWC2_HC_PID_DATA0;\r\nqh->maxp = dwc2_hcd_get_mps(&urb->pipe_info);\r\nINIT_LIST_HEAD(&qh->qtd_list);\r\nINIT_LIST_HEAD(&qh->qh_list_entry);\r\ndev_speed = dwc2_host_get_speed(hsotg, urb->priv);\r\ndwc2_host_hub_info(hsotg, urb->priv, &hub_addr, &hub_port);\r\nif ((dev_speed == USB_SPEED_LOW || dev_speed == USB_SPEED_FULL) &&\r\nhub_addr != 0 && hub_addr != 1) {\r\ndev_vdbg(hsotg->dev,\r\n"QH init: EP %d: TT found at hub addr %d, for port %d\n",\r\ndwc2_hcd_get_ep_num(&urb->pipe_info), hub_addr,\r\nhub_port);\r\nqh->do_split = 1;\r\n}\r\nif (qh->ep_type == USB_ENDPOINT_XFER_INT ||\r\nqh->ep_type == USB_ENDPOINT_XFER_ISOC) {\r\nu32 hprt, prtspd;\r\nint bytecount =\r\ndwc2_hb_mult(qh->maxp) * dwc2_max_packet(qh->maxp);\r\nqh->usecs = NS_TO_US(usb_calc_bus_time(qh->do_split ?\r\nUSB_SPEED_HIGH : dev_speed, qh->ep_is_in,\r\nqh->ep_type == USB_ENDPOINT_XFER_ISOC,\r\nbytecount));\r\nqh->sched_frame = dwc2_frame_num_inc(hsotg->frame_number,\r\nSCHEDULE_SLOP);\r\nqh->interval = urb->interval;\r\n#if 0\r\nif (qh->ep_type == USB_ENDPOINT_XFER_INT)\r\nqh->interval = 8;\r\n#endif\r\nhprt = readl(hsotg->regs + HPRT0);\r\nprtspd = hprt & HPRT0_SPD_MASK;\r\nif (prtspd == HPRT0_SPD_HIGH_SPEED &&\r\n(dev_speed == USB_SPEED_LOW ||\r\ndev_speed == USB_SPEED_FULL)) {\r\nqh->interval *= 8;\r\nqh->sched_frame |= 0x7;\r\nqh->start_split_frame = qh->sched_frame;\r\n}\r\ndev_dbg(hsotg->dev, "interval=%d\n", qh->interval);\r\n}\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH Initialized\n");\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - qh = %p\n", qh);\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - Device Address = %d\n",\r\ndwc2_hcd_get_dev_addr(&urb->pipe_info));\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - Endpoint %d, %s\n",\r\ndwc2_hcd_get_ep_num(&urb->pipe_info),\r\ndwc2_hcd_is_pipe_in(&urb->pipe_info) ? "IN" : "OUT");\r\nqh->dev_speed = dev_speed;\r\nswitch (dev_speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "low";\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nspeed = "full";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "high";\r\nbreak;\r\ndefault:\r\nspeed = "?";\r\nbreak;\r\n}\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - Speed = %s\n", speed);\r\nswitch (qh->ep_type) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ntype = "isochronous";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ntype = "interrupt";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ntype = "control";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ntype = "bulk";\r\nbreak;\r\ndefault:\r\ntype = "?";\r\nbreak;\r\n}\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - Type = %s\n", type);\r\nif (qh->ep_type == USB_ENDPOINT_XFER_INT) {\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - usecs = %d\n",\r\nqh->usecs);\r\ndev_vdbg(hsotg->dev, "DWC OTG HCD QH - interval = %d\n",\r\nqh->interval);\r\n}\r\n}\r\nstatic struct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hcd_urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct dwc2_qh *qh;\r\nqh = kzalloc(sizeof(*qh), mem_flags);\r\nif (!qh)\r\nreturn NULL;\r\ndwc2_qh_init(hsotg, qh, urb);\r\nif (hsotg->core_params->dma_desc_enable > 0 &&\r\ndwc2_hcd_qh_init_ddma(hsotg, qh, mem_flags) < 0) {\r\ndwc2_hcd_qh_free(hsotg, qh);\r\nreturn NULL;\r\n}\r\nreturn qh;\r\n}\r\nvoid dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nu32 buf_size;\r\nif (hsotg->core_params->dma_desc_enable > 0) {\r\ndwc2_hcd_qh_free_ddma(hsotg, qh);\r\n} else if (qh->dw_align_buf) {\r\nif (qh->ep_type == USB_ENDPOINT_XFER_ISOC)\r\nbuf_size = 4096;\r\nelse\r\nbuf_size = hsotg->core_params->max_transfer_size;\r\ndma_free_coherent(hsotg->dev, buf_size, qh->dw_align_buf,\r\nqh->dw_align_buf_dma);\r\n}\r\nkfree(qh);\r\n}\r\nstatic int dwc2_periodic_channel_available(struct dwc2_hsotg *hsotg)\r\n{\r\nint status;\r\nint num_channels;\r\nnum_channels = hsotg->core_params->host_channels;\r\nif (hsotg->periodic_channels + hsotg->non_periodic_channels <\r\nnum_channels\r\n&& hsotg->periodic_channels < num_channels - 1) {\r\nstatus = 0;\r\n} else {\r\ndev_dbg(hsotg->dev,\r\n"%s: Total channels: %d, Periodic: %d, "\r\n"Non-periodic: %d\n", __func__, num_channels,\r\nhsotg->periodic_channels, hsotg->non_periodic_channels);\r\nstatus = -ENOSPC;\r\n}\r\nreturn status;\r\n}\r\nstatic int dwc2_check_periodic_bandwidth(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nint status;\r\ns16 max_claimed_usecs;\r\nstatus = 0;\r\nif (qh->dev_speed == USB_SPEED_HIGH || qh->do_split) {\r\nmax_claimed_usecs = 100 - qh->usecs;\r\n} else {\r\nmax_claimed_usecs = 900 - qh->usecs;\r\n}\r\nif (hsotg->periodic_usecs > max_claimed_usecs) {\r\ndev_err(hsotg->dev,\r\n"%s: already claimed usecs %d, required usecs %d\n",\r\n__func__, hsotg->periodic_usecs, qh->usecs);\r\nstatus = -ENOSPC;\r\n}\r\nreturn status;\r\n}\r\nstatic int dwc2_check_max_xfer_size(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nu32 max_xfer_size;\r\nu32 max_channel_xfer_size;\r\nint status = 0;\r\nmax_xfer_size = dwc2_max_packet(qh->maxp) * dwc2_hb_mult(qh->maxp);\r\nmax_channel_xfer_size = hsotg->core_params->max_transfer_size;\r\nif (max_xfer_size > max_channel_xfer_size) {\r\ndev_err(hsotg->dev,\r\n"%s: Periodic xfer length %d > max xfer length for channel %d\n",\r\n__func__, max_xfer_size, max_channel_xfer_size);\r\nstatus = -ENOSPC;\r\n}\r\nreturn status;\r\n}\r\nstatic int dwc2_schedule_periodic(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint status;\r\nstatus = dwc2_periodic_channel_available(hsotg);\r\nif (status) {\r\ndev_dbg(hsotg->dev,\r\n"%s: No host channel available for periodic transfer\n",\r\n__func__);\r\nreturn status;\r\n}\r\nstatus = dwc2_check_periodic_bandwidth(hsotg, qh);\r\nif (status) {\r\ndev_dbg(hsotg->dev,\r\n"%s: Insufficient periodic bandwidth for periodic transfer\n",\r\n__func__);\r\nreturn status;\r\n}\r\nstatus = dwc2_check_max_xfer_size(hsotg, qh);\r\nif (status) {\r\ndev_dbg(hsotg->dev,\r\n"%s: Channel max transfer size too small for periodic transfer\n",\r\n__func__);\r\nreturn status;\r\n}\r\nif (hsotg->core_params->dma_desc_enable > 0)\r\nlist_add_tail(&qh->qh_list_entry, &hsotg->periodic_sched_ready);\r\nelse\r\nlist_add_tail(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_inactive);\r\nhsotg->periodic_channels++;\r\nhsotg->periodic_usecs += qh->usecs;\r\nreturn status;\r\n}\r\nstatic void dwc2_deschedule_periodic(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nlist_del_init(&qh->qh_list_entry);\r\nhsotg->periodic_channels--;\r\nhsotg->periodic_usecs -= qh->usecs;\r\n}\r\nint dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint status = 0;\r\nu32 intr_mask;\r\nif (dbg_qh(qh))\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (!list_empty(&qh->qh_list_entry))\r\nreturn status;\r\nif (dwc2_qh_is_non_per(qh)) {\r\nlist_add_tail(&qh->qh_list_entry,\r\n&hsotg->non_periodic_sched_inactive);\r\n} else {\r\nstatus = dwc2_schedule_periodic(hsotg, qh);\r\nif (status == 0) {\r\nif (!hsotg->periodic_qh_count) {\r\nintr_mask = readl(hsotg->regs + GINTMSK);\r\nintr_mask |= GINTSTS_SOF;\r\nwritel(intr_mask, hsotg->regs + GINTMSK);\r\n}\r\nhsotg->periodic_qh_count++;\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nu32 intr_mask;\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (list_empty(&qh->qh_list_entry))\r\nreturn;\r\nif (dwc2_qh_is_non_per(qh)) {\r\nif (hsotg->non_periodic_qh_ptr == &qh->qh_list_entry)\r\nhsotg->non_periodic_qh_ptr =\r\nhsotg->non_periodic_qh_ptr->next;\r\nlist_del_init(&qh->qh_list_entry);\r\n} else {\r\ndwc2_deschedule_periodic(hsotg, qh);\r\nhsotg->periodic_qh_count--;\r\nif (!hsotg->periodic_qh_count) {\r\nintr_mask = readl(hsotg->regs + GINTMSK);\r\nintr_mask &= ~GINTSTS_SOF;\r\nwritel(intr_mask, hsotg->regs + GINTMSK);\r\n}\r\n}\r\n}\r\nstatic void dwc2_sched_periodic_split(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh, u16 frame_number,\r\nint sched_next_periodic_split)\r\n{\r\nu16 incr;\r\nif (sched_next_periodic_split) {\r\nqh->sched_frame = frame_number;\r\nincr = dwc2_frame_num_inc(qh->start_split_frame, 1);\r\nif (dwc2_frame_num_le(frame_number, incr)) {\r\nif (qh->ep_type != USB_ENDPOINT_XFER_ISOC ||\r\nqh->ep_is_in != 0) {\r\nqh->sched_frame =\r\ndwc2_frame_num_inc(qh->sched_frame, 1);\r\n}\r\n}\r\n} else {\r\nqh->sched_frame = dwc2_frame_num_inc(qh->start_split_frame,\r\nqh->interval);\r\nif (dwc2_frame_num_le(qh->sched_frame, frame_number))\r\nqh->sched_frame = frame_number;\r\nqh->sched_frame |= 0x7;\r\nqh->start_split_frame = qh->sched_frame;\r\n}\r\n}\r\nvoid dwc2_hcd_qh_deactivate(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nint sched_next_periodic_split)\r\n{\r\nif (dbg_qh(qh))\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (dwc2_qh_is_non_per(qh)) {\r\ndwc2_hcd_qh_unlink(hsotg, qh);\r\nif (!list_empty(&qh->qtd_list))\r\ndwc2_hcd_qh_add(hsotg, qh);\r\n} else {\r\nu16 frame_number = dwc2_hcd_get_frame_number(hsotg);\r\nif (qh->do_split) {\r\ndwc2_sched_periodic_split(hsotg, qh, frame_number,\r\nsched_next_periodic_split);\r\n} else {\r\nqh->sched_frame = dwc2_frame_num_inc(qh->sched_frame,\r\nqh->interval);\r\nif (dwc2_frame_num_le(qh->sched_frame, frame_number))\r\nqh->sched_frame = frame_number;\r\n}\r\nif (list_empty(&qh->qtd_list)) {\r\ndwc2_hcd_qh_unlink(hsotg, qh);\r\n} else {\r\nif (qh->sched_frame == frame_number)\r\nlist_move(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_ready);\r\nelse\r\nlist_move(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_inactive);\r\n}\r\n}\r\n}\r\nvoid dwc2_hcd_qtd_init(struct dwc2_qtd *qtd, struct dwc2_hcd_urb *urb)\r\n{\r\nqtd->urb = urb;\r\nif (dwc2_hcd_get_pipe_type(&urb->pipe_info) ==\r\nUSB_ENDPOINT_XFER_CONTROL) {\r\nqtd->data_toggle = DWC2_HC_PID_DATA1;\r\nqtd->control_phase = DWC2_CONTROL_SETUP;\r\n}\r\nqtd->complete_split = 0;\r\nqtd->isoc_split_pos = DWC2_HCSPLT_XACTPOS_ALL;\r\nqtd->isoc_split_offset = 0;\r\nqtd->in_process = 0;\r\nurb->qtd = qtd;\r\n}\r\nint dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,\r\nstruct dwc2_qh **qh, gfp_t mem_flags)\r\n{\r\nstruct dwc2_hcd_urb *urb = qtd->urb;\r\nunsigned long flags;\r\nint allocated = 0;\r\nint retval = 0;\r\nif (*qh == NULL) {\r\n*qh = dwc2_hcd_qh_create(hsotg, urb, mem_flags);\r\nif (*qh == NULL)\r\nreturn -ENOMEM;\r\nallocated = 1;\r\n}\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nretval = dwc2_hcd_qh_add(hsotg, *qh);\r\nif (retval && allocated) {\r\nstruct dwc2_qtd *qtd2, *qtd2_tmp;\r\nstruct dwc2_qh *qh_tmp = *qh;\r\n*qh = NULL;\r\ndwc2_hcd_qh_unlink(hsotg, qh_tmp);\r\nlist_for_each_entry_safe(qtd2, qtd2_tmp, &qh_tmp->qtd_list,\r\nqtd_list_entry)\r\ndwc2_hcd_qtd_unlink_and_free(hsotg, qtd2, qh_tmp);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\ndwc2_hcd_qh_free(hsotg, qh_tmp);\r\n} else {\r\nqtd->qh = *qh;\r\nlist_add_tail(&qtd->qtd_list_entry, &(*qh)->qtd_list);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\n}\r\nreturn retval;\r\n}
