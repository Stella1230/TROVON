static inline uint32_t vmw_surface_dma_size(const struct vmw_surface *srf)\r\n{\r\nreturn srf->num_sizes * sizeof(struct vmw_surface_dma);\r\n}\r\nstatic inline uint32_t vmw_surface_define_size(const struct vmw_surface *srf)\r\n{\r\nreturn sizeof(struct vmw_surface_define) + srf->num_sizes *\r\nsizeof(SVGA3dSize);\r\n}\r\nstatic inline uint32_t vmw_surface_destroy_size(void)\r\n{\r\nreturn sizeof(struct vmw_surface_destroy);\r\n}\r\nstatic void vmw_surface_destroy_encode(uint32_t id,\r\nvoid *cmd_space)\r\n{\r\nstruct vmw_surface_destroy *cmd = (struct vmw_surface_destroy *)\r\ncmd_space;\r\ncmd->header.id = SVGA_3D_CMD_SURFACE_DESTROY;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.sid = id;\r\n}\r\nstatic void vmw_surface_define_encode(const struct vmw_surface *srf,\r\nvoid *cmd_space)\r\n{\r\nstruct vmw_surface_define *cmd = (struct vmw_surface_define *)\r\ncmd_space;\r\nstruct drm_vmw_size *src_size;\r\nSVGA3dSize *cmd_size;\r\nuint32_t cmd_len;\r\nint i;\r\ncmd_len = sizeof(cmd->body) + srf->num_sizes * sizeof(SVGA3dSize);\r\ncmd->header.id = SVGA_3D_CMD_SURFACE_DEFINE;\r\ncmd->header.size = cmd_len;\r\ncmd->body.sid = srf->res.id;\r\ncmd->body.surfaceFlags = srf->flags;\r\ncmd->body.format = cpu_to_le32(srf->format);\r\nfor (i = 0; i < DRM_VMW_MAX_SURFACE_FACES; ++i)\r\ncmd->body.face[i].numMipLevels = srf->mip_levels[i];\r\ncmd += 1;\r\ncmd_size = (SVGA3dSize *) cmd;\r\nsrc_size = srf->sizes;\r\nfor (i = 0; i < srf->num_sizes; ++i, cmd_size++, src_size++) {\r\ncmd_size->width = src_size->width;\r\ncmd_size->height = src_size->height;\r\ncmd_size->depth = src_size->depth;\r\n}\r\n}\r\nstatic void vmw_surface_dma_encode(struct vmw_surface *srf,\r\nvoid *cmd_space,\r\nconst SVGAGuestPtr *ptr,\r\nbool to_surface)\r\n{\r\nuint32_t i;\r\nstruct vmw_surface_dma *cmd = (struct vmw_surface_dma *)cmd_space;\r\nconst struct svga3d_surface_desc *desc =\r\nsvga3dsurface_get_desc(srf->format);\r\nfor (i = 0; i < srf->num_sizes; ++i) {\r\nSVGA3dCmdHeader *header = &cmd->header;\r\nSVGA3dCmdSurfaceDMA *body = &cmd->body;\r\nSVGA3dCopyBox *cb = &cmd->cb;\r\nSVGA3dCmdSurfaceDMASuffix *suffix = &cmd->suffix;\r\nconst struct vmw_surface_offset *cur_offset = &srf->offsets[i];\r\nconst struct drm_vmw_size *cur_size = &srf->sizes[i];\r\nheader->id = SVGA_3D_CMD_SURFACE_DMA;\r\nheader->size = sizeof(*body) + sizeof(*cb) + sizeof(*suffix);\r\nbody->guest.ptr = *ptr;\r\nbody->guest.ptr.offset += cur_offset->bo_offset;\r\nbody->guest.pitch = svga3dsurface_calculate_pitch(desc,\r\ncur_size);\r\nbody->host.sid = srf->res.id;\r\nbody->host.face = cur_offset->face;\r\nbody->host.mipmap = cur_offset->mip;\r\nbody->transfer = ((to_surface) ? SVGA3D_WRITE_HOST_VRAM :\r\nSVGA3D_READ_HOST_VRAM);\r\ncb->x = 0;\r\ncb->y = 0;\r\ncb->z = 0;\r\ncb->srcx = 0;\r\ncb->srcy = 0;\r\ncb->srcz = 0;\r\ncb->w = cur_size->width;\r\ncb->h = cur_size->height;\r\ncb->d = cur_size->depth;\r\nsuffix->suffixSize = sizeof(*suffix);\r\nsuffix->maximumOffset =\r\nsvga3dsurface_get_image_buffer_size(desc, cur_size,\r\nbody->guest.pitch);\r\nsuffix->flags.discard = 0;\r\nsuffix->flags.unsynchronized = 0;\r\nsuffix->flags.reserved = 0;\r\n++cmd;\r\n}\r\n}\r\nstatic void vmw_hw_surface_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_surface *srf;\r\nvoid *cmd;\r\nif (res->id != -1) {\r\ncmd = vmw_fifo_reserve(dev_priv, vmw_surface_destroy_size());\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"destruction.\n");\r\nreturn;\r\n}\r\nvmw_surface_destroy_encode(res->id, cmd);\r\nvmw_fifo_commit(dev_priv, vmw_surface_destroy_size());\r\nmutex_lock(&dev_priv->cmdbuf_mutex);\r\nsrf = vmw_res_to_srf(res);\r\ndev_priv->used_memory_size -= res->backup_size;\r\nmutex_unlock(&dev_priv->cmdbuf_mutex);\r\n}\r\nvmw_3d_resource_dec(dev_priv, false);\r\n}\r\nstatic int vmw_legacy_srf_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_surface *srf;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nint ret;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nsrf = vmw_res_to_srf(res);\r\nif (unlikely(dev_priv->used_memory_size + res->backup_size >=\r\ndev_priv->memory_size))\r\nreturn -EBUSY;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a surface id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= SVGA3D_MAX_SURFACE_IDS)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\nsubmit_size = vmw_surface_define_size(srf);\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\nvmw_surface_define_encode(srf, cmd);\r\nvmw_fifo_commit(dev_priv, submit_size);\r\ndev_priv->used_memory_size += res->backup_size;\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_legacy_srf_dma(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf,\r\nbool bind)\r\n{\r\nSVGAGuestPtr ptr;\r\nstruct vmw_fence_obj *fence;\r\nuint32_t submit_size;\r\nstruct vmw_surface *srf = vmw_res_to_srf(res);\r\nuint8_t *cmd;\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nBUG_ON(val_buf->bo == NULL);\r\nsubmit_size = vmw_surface_dma_size(srf);\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"DMA.\n");\r\nreturn -ENOMEM;\r\n}\r\nvmw_bo_get_guest_ptr(val_buf->bo, &ptr);\r\nvmw_surface_dma_encode(srf, cmd, &ptr, bind);\r\nvmw_fifo_commit(dev_priv, submit_size);\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(val_buf->bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_legacy_srf_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nif (!res->backup_dirty)\r\nreturn 0;\r\nreturn vmw_legacy_srf_dma(res, val_buf, true);\r\n}\r\nstatic int vmw_legacy_srf_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nif (unlikely(readback))\r\nreturn vmw_legacy_srf_dma(res, val_buf, false);\r\nreturn 0;\r\n}\r\nstatic int vmw_legacy_srf_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nBUG_ON(res->id == -1);\r\nsubmit_size = vmw_surface_destroy_size();\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"eviction.\n");\r\nreturn -ENOMEM;\r\n}\r\nvmw_surface_destroy_encode(res->id, cmd);\r\nvmw_fifo_commit(dev_priv, submit_size);\r\ndev_priv->used_memory_size -= res->backup_size;\r\nvmw_resource_release_id(res);\r\nreturn 0;\r\n}\r\nstatic int vmw_surface_init(struct vmw_private *dev_priv,\r\nstruct vmw_surface *srf,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nint ret;\r\nstruct vmw_resource *res = &srf->res;\r\nBUG_ON(res_free == NULL);\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nret = vmw_resource_init(dev_priv, res, true, res_free,\r\n&vmw_legacy_surface_func);\r\nif (unlikely(ret != 0)) {\r\nvmw_3d_resource_dec(dev_priv, false);\r\nres_free(res);\r\nreturn ret;\r\n}\r\nvmw_resource_activate(res, vmw_hw_surface_destroy);\r\nreturn ret;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_surface_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_surface, base)->srf.res);\r\n}\r\nstatic void vmw_user_surface_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_surface *srf = vmw_res_to_srf(res);\r\nstruct vmw_user_surface *user_srf =\r\ncontainer_of(srf, struct vmw_user_surface, srf);\r\nstruct vmw_private *dev_priv = srf->res.dev_priv;\r\nuint32_t size = user_srf->size;\r\nkfree(srf->offsets);\r\nkfree(srf->sizes);\r\nkfree(srf->snooper.image);\r\nttm_base_object_kfree(user_srf, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\n}\r\nstatic void vmw_user_surface_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_surface *user_srf =\r\ncontainer_of(base, struct vmw_user_surface, base);\r\nstruct vmw_resource *res = &user_srf->srf.res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_surface_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_surface_arg *arg = (struct drm_vmw_surface_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->sid, TTM_REF_USAGE);\r\n}\r\nint vmw_surface_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_surface *user_srf;\r\nstruct vmw_surface *srf;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nunion drm_vmw_surface_create_arg *arg =\r\n(union drm_vmw_surface_create_arg *)data;\r\nstruct drm_vmw_surface_create_req *req = &arg->req;\r\nstruct drm_vmw_surface_arg *rep = &arg->rep;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct drm_vmw_size __user *user_sizes;\r\nint ret;\r\nint i, j;\r\nuint32_t cur_bo_offset;\r\nstruct drm_vmw_size *cur_size;\r\nstruct vmw_surface_offset *cur_offset;\r\nuint32_t num_sizes;\r\nuint32_t size;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nconst struct svga3d_surface_desc *desc;\r\nif (unlikely(vmw_user_surface_size == 0))\r\nvmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +\r\n128;\r\nnum_sizes = 0;\r\nfor (i = 0; i < DRM_VMW_MAX_SURFACE_FACES; ++i)\r\nnum_sizes += req->mip_levels[i];\r\nif (num_sizes > DRM_VMW_MAX_SURFACE_FACES *\r\nDRM_VMW_MAX_MIP_LEVELS)\r\nreturn -EINVAL;\r\nsize = vmw_user_surface_size + 128 +\r\nttm_round_pot(num_sizes * sizeof(struct drm_vmw_size)) +\r\nttm_round_pot(num_sizes * sizeof(struct vmw_surface_offset));\r\ndesc = svga3dsurface_get_desc(req->format);\r\nif (unlikely(desc->block_desc == SVGA3DBLOCKDESC_NONE)) {\r\nDRM_ERROR("Invalid surface format for surface creation.\n");\r\nreturn -EINVAL;\r\n}\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nsize, false, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for surface"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nuser_srf = kzalloc(sizeof(*user_srf), GFP_KERNEL);\r\nif (unlikely(user_srf == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_user_srf;\r\n}\r\nsrf = &user_srf->srf;\r\nres = &srf->res;\r\nsrf->flags = req->flags;\r\nsrf->format = req->format;\r\nsrf->scanout = req->scanout;\r\nmemcpy(srf->mip_levels, req->mip_levels, sizeof(srf->mip_levels));\r\nsrf->num_sizes = num_sizes;\r\nuser_srf->size = size;\r\nsrf->sizes = kmalloc(srf->num_sizes * sizeof(*srf->sizes), GFP_KERNEL);\r\nif (unlikely(srf->sizes == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_sizes;\r\n}\r\nsrf->offsets = kmalloc(srf->num_sizes * sizeof(*srf->offsets),\r\nGFP_KERNEL);\r\nif (unlikely(srf->sizes == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_offsets;\r\n}\r\nuser_sizes = (struct drm_vmw_size __user *)(unsigned long)\r\nreq->size_addr;\r\nret = copy_from_user(srf->sizes, user_sizes,\r\nsrf->num_sizes * sizeof(*srf->sizes));\r\nif (unlikely(ret != 0)) {\r\nret = -EFAULT;\r\ngoto out_no_copy;\r\n}\r\nsrf->base_size = *srf->sizes;\r\nsrf->autogen_filter = SVGA3D_TEX_FILTER_NONE;\r\nsrf->multisample_count = 1;\r\ncur_bo_offset = 0;\r\ncur_offset = srf->offsets;\r\ncur_size = srf->sizes;\r\nfor (i = 0; i < DRM_VMW_MAX_SURFACE_FACES; ++i) {\r\nfor (j = 0; j < srf->mip_levels[i]; ++j) {\r\nuint32_t stride = svga3dsurface_calculate_pitch\r\n(desc, cur_size);\r\ncur_offset->face = i;\r\ncur_offset->mip = j;\r\ncur_offset->bo_offset = cur_bo_offset;\r\ncur_bo_offset += svga3dsurface_get_image_buffer_size\r\n(desc, cur_size, stride);\r\n++cur_offset;\r\n++cur_size;\r\n}\r\n}\r\nres->backup_size = cur_bo_offset;\r\nif (srf->scanout &&\r\nsrf->num_sizes == 1 &&\r\nsrf->sizes[0].width == 64 &&\r\nsrf->sizes[0].height == 64 &&\r\nsrf->format == SVGA3D_A8R8G8B8) {\r\nsrf->snooper.image = kmalloc(64 * 64 * 4, GFP_KERNEL);\r\nif (srf->snooper.image) {\r\nmemset(srf->snooper.image, 0x00, 64 * 64 * 4);\r\n} else {\r\nDRM_ERROR("Failed to allocate cursor_image\n");\r\nret = -ENOMEM;\r\ngoto out_no_copy;\r\n}\r\n} else {\r\nsrf->snooper.image = NULL;\r\n}\r\nsrf->snooper.crtc = NULL;\r\nuser_srf->base.shareable = false;\r\nuser_srf->base.tfile = NULL;\r\nret = vmw_surface_init(dev_priv, srf, vmw_user_surface_free);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(&srf->res);\r\nret = ttm_base_object_init(tfile, &user_srf->base,\r\nreq->shareable, VMW_RES_SURFACE,\r\n&vmw_user_surface_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\nvmw_resource_unreference(&res);\r\ngoto out_unlock;\r\n}\r\nrep->sid = user_srf->base.hash.key;\r\nvmw_resource_unreference(&res);\r\nttm_read_unlock(&vmaster->lock);\r\nreturn 0;\r\nout_no_copy:\r\nkfree(srf->offsets);\r\nout_no_offsets:\r\nkfree(srf->sizes);\r\nout_no_sizes:\r\nttm_base_object_kfree(user_srf, base);\r\nout_no_user_srf:\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nint vmw_surface_reference_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nunion drm_vmw_surface_reference_arg *arg =\r\n(union drm_vmw_surface_reference_arg *)data;\r\nstruct drm_vmw_surface_arg *req = &arg->req;\r\nstruct drm_vmw_surface_create_req *rep = &arg->rep;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_surface *srf;\r\nstruct vmw_user_surface *user_srf;\r\nstruct drm_vmw_size __user *user_sizes;\r\nstruct ttm_base_object *base;\r\nint ret = -EINVAL;\r\nbase = ttm_base_object_lookup(tfile, req->sid);\r\nif (unlikely(base == NULL)) {\r\nDRM_ERROR("Could not find surface to reference.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(base->object_type != VMW_RES_SURFACE))\r\ngoto out_bad_resource;\r\nuser_srf = container_of(base, struct vmw_user_surface, base);\r\nsrf = &user_srf->srf;\r\nret = ttm_ref_object_add(tfile, &user_srf->base, TTM_REF_USAGE, NULL);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Could not add a reference to a surface.\n");\r\ngoto out_no_reference;\r\n}\r\nrep->flags = srf->flags;\r\nrep->format = srf->format;\r\nmemcpy(rep->mip_levels, srf->mip_levels, sizeof(srf->mip_levels));\r\nuser_sizes = (struct drm_vmw_size __user *)(unsigned long)\r\nrep->size_addr;\r\nif (user_sizes)\r\nret = copy_to_user(user_sizes, srf->sizes,\r\nsrf->num_sizes * sizeof(*srf->sizes));\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("copy_to_user failed %p %u\n",\r\nuser_sizes, srf->num_sizes);\r\nret = -EFAULT;\r\n}\r\nout_bad_resource:\r\nout_no_reference:\r\nttm_base_object_unref(&base);\r\nreturn ret;\r\n}
