static ssize_t set_temp(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nlong temp;\r\nshort value;\r\ns32 err;\r\nint status = kstrtol(buf, 10, &temp);\r\nif (status < 0)\r\nreturn status;\r\nvalue = clamp_val(temp / 250, LM73_TEMP_MIN, LM73_TEMP_MAX) << 5;\r\nerr = i2c_smbus_write_word_swapped(client, attr->index, value);\r\nreturn (err < 0) ? err : count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint temp;\r\ns32 err = i2c_smbus_read_word_swapped(client, attr->index);\r\nif (err < 0)\r\nreturn err;\r\ntemp = (((s16) err) * 250) / 32;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", temp);\r\n}\r\nstatic ssize_t set_convrate(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm73_data *data = i2c_get_clientdata(client);\r\nunsigned long convrate;\r\ns32 err;\r\nint res = 0;\r\nerr = kstrtoul(buf, 10, &convrate);\r\nif (err < 0)\r\nreturn err;\r\nwhile (res < (ARRAY_SIZE(lm73_convrates) - 1) &&\r\nconvrate > lm73_convrates[res])\r\nres++;\r\nmutex_lock(&data->lock);\r\ndata->ctrl &= LM73_CTRL_TO_MASK;\r\ndata->ctrl |= res << LM73_CTRL_RES_SHIFT;\r\nerr = i2c_smbus_write_byte_data(client, LM73_REG_CTRL, data->ctrl);\r\nmutex_unlock(&data->lock);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t show_convrate(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm73_data *data = i2c_get_clientdata(client);\r\nint res;\r\nres = (data->ctrl & LM73_CTRL_RES_MASK) >> LM73_CTRL_RES_SHIFT;\r\nreturn scnprintf(buf, PAGE_SIZE, "%hu\n", lm73_convrates[res]);\r\n}\r\nstatic ssize_t show_maxmin_alarm(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm73_data *data = i2c_get_clientdata(client);\r\ns32 ctrl;\r\nmutex_lock(&data->lock);\r\nctrl = i2c_smbus_read_byte_data(client, LM73_REG_CTRL);\r\nif (ctrl < 0)\r\ngoto abort;\r\ndata->ctrl = ctrl;\r\nmutex_unlock(&data->lock);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (ctrl >> attr->index) & 1);\r\nabort:\r\nmutex_unlock(&data->lock);\r\nreturn ctrl;\r\n}\r\nstatic int\r\nlm73_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nint status;\r\nstruct lm73_data *data;\r\nint ctrl;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct lm73_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\nctrl = i2c_smbus_read_byte_data(client, LM73_REG_CTRL);\r\nif (ctrl < 0)\r\nreturn ctrl;\r\ndata->ctrl = ctrl;\r\nstatus = sysfs_create_group(&client->dev.kobj, &lm73_group);\r\nif (status)\r\nreturn status;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nstatus = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\ndev_info(&client->dev, "%s: sensor '%s'\n",\r\ndev_name(data->hwmon_dev), client->name);\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &lm73_group);\r\nreturn status;\r\n}\r\nstatic int lm73_remove(struct i2c_client *client)\r\n{\r\nstruct lm73_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &lm73_group);\r\nreturn 0;\r\n}\r\nstatic int lm73_detect(struct i2c_client *new_client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nint id, ctrl, conf;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\nctrl = i2c_smbus_read_byte_data(new_client, LM73_REG_CTRL);\r\nif (ctrl < 0 || (ctrl & 0x10))\r\nreturn -ENODEV;\r\nconf = i2c_smbus_read_byte_data(new_client, LM73_REG_CONF);\r\nif (conf < 0 || (conf & 0x0c))\r\nreturn -ENODEV;\r\nid = i2c_smbus_read_byte_data(new_client, LM73_REG_ID);\r\nif (id < 0 || id != (LM73_ID & 0xff))\r\nreturn -ENODEV;\r\nid = i2c_smbus_read_word_data(new_client, LM73_REG_ID);\r\nif (id < 0 || id != LM73_ID)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "lm73", I2C_NAME_SIZE);\r\nreturn 0;\r\n}
