struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)\r\n{\r\nreturn try_module_get(alg->cra_module) ? crypto_alg_get(alg) : NULL;\r\n}\r\nvoid crypto_mod_put(struct crypto_alg *alg)\r\n{\r\nstruct module *module = alg->cra_module;\r\ncrypto_alg_put(alg);\r\nmodule_put(module);\r\n}\r\nstatic inline int crypto_is_test_larval(struct crypto_larval *larval)\r\n{\r\nreturn larval->alg.cra_driver_name[0];\r\n}\r\nstatic struct crypto_alg *__crypto_alg_lookup(const char *name, u32 type,\r\nu32 mask)\r\n{\r\nstruct crypto_alg *q, *alg = NULL;\r\nint best = -2;\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nint exact, fuzzy;\r\nif (crypto_is_moribund(q))\r\ncontinue;\r\nif ((q->cra_flags ^ type) & mask)\r\ncontinue;\r\nif (crypto_is_larval(q) &&\r\n!crypto_is_test_larval((struct crypto_larval *)q) &&\r\n((struct crypto_larval *)q)->mask != mask)\r\ncontinue;\r\nexact = !strcmp(q->cra_driver_name, name);\r\nfuzzy = !strcmp(q->cra_name, name);\r\nif (!exact && !(fuzzy && q->cra_priority > best))\r\ncontinue;\r\nif (unlikely(!crypto_mod_get(q)))\r\ncontinue;\r\nbest = q->cra_priority;\r\nif (alg)\r\ncrypto_mod_put(alg);\r\nalg = q;\r\nif (exact)\r\nbreak;\r\n}\r\nreturn alg;\r\n}\r\nstatic void crypto_larval_destroy(struct crypto_alg *alg)\r\n{\r\nstruct crypto_larval *larval = (void *)alg;\r\nBUG_ON(!crypto_is_larval(alg));\r\nif (larval->adult)\r\ncrypto_mod_put(larval->adult);\r\nkfree(larval);\r\n}\r\nstruct crypto_larval *crypto_larval_alloc(const char *name, u32 type, u32 mask)\r\n{\r\nstruct crypto_larval *larval;\r\nlarval = kzalloc(sizeof(*larval), GFP_KERNEL);\r\nif (!larval)\r\nreturn ERR_PTR(-ENOMEM);\r\nlarval->mask = mask;\r\nlarval->alg.cra_flags = CRYPTO_ALG_LARVAL | type;\r\nlarval->alg.cra_priority = -1;\r\nlarval->alg.cra_destroy = crypto_larval_destroy;\r\nstrlcpy(larval->alg.cra_name, name, CRYPTO_MAX_ALG_NAME);\r\ninit_completion(&larval->completion);\r\nreturn larval;\r\n}\r\nstatic struct crypto_alg *crypto_larval_add(const char *name, u32 type,\r\nu32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_larval *larval;\r\nlarval = crypto_larval_alloc(name, type, mask);\r\nif (IS_ERR(larval))\r\nreturn ERR_CAST(larval);\r\natomic_set(&larval->alg.cra_refcnt, 2);\r\ndown_write(&crypto_alg_sem);\r\nalg = __crypto_alg_lookup(name, type, mask);\r\nif (!alg) {\r\nalg = &larval->alg;\r\nlist_add(&alg->cra_list, &crypto_alg_list);\r\n}\r\nup_write(&crypto_alg_sem);\r\nif (alg != &larval->alg)\r\nkfree(larval);\r\nreturn alg;\r\n}\r\nvoid crypto_larval_kill(struct crypto_alg *alg)\r\n{\r\nstruct crypto_larval *larval = (void *)alg;\r\ndown_write(&crypto_alg_sem);\r\nlist_del(&alg->cra_list);\r\nup_write(&crypto_alg_sem);\r\ncomplete_all(&larval->completion);\r\ncrypto_alg_put(alg);\r\n}\r\nstatic struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)\r\n{\r\nstruct crypto_larval *larval = (void *)alg;\r\nlong timeout;\r\ntimeout = wait_for_completion_interruptible_timeout(\r\n&larval->completion, 60 * HZ);\r\nalg = larval->adult;\r\nif (timeout < 0)\r\nalg = ERR_PTR(-EINTR);\r\nelse if (!timeout)\r\nalg = ERR_PTR(-ETIMEDOUT);\r\nelse if (!alg)\r\nalg = ERR_PTR(-ENOENT);\r\nelse if (crypto_is_test_larval(larval) &&\r\n!(alg->cra_flags & CRYPTO_ALG_TESTED))\r\nalg = ERR_PTR(-EAGAIN);\r\nelse if (!crypto_mod_get(alg))\r\nalg = ERR_PTR(-EAGAIN);\r\ncrypto_mod_put(&larval->alg);\r\nreturn alg;\r\n}\r\nstruct crypto_alg *crypto_alg_lookup(const char *name, u32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\ndown_read(&crypto_alg_sem);\r\nalg = __crypto_alg_lookup(name, type, mask);\r\nup_read(&crypto_alg_sem);\r\nreturn alg;\r\n}\r\nstruct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nif (!name)\r\nreturn ERR_PTR(-ENOENT);\r\nmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\r\ntype &= mask;\r\nalg = crypto_alg_lookup(name, type, mask);\r\nif (!alg) {\r\nrequest_module("%s", name);\r\nif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\r\nCRYPTO_ALG_NEED_FALLBACK))\r\nrequest_module("%s-all", name);\r\nalg = crypto_alg_lookup(name, type, mask);\r\n}\r\nif (alg)\r\nreturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\r\nreturn crypto_larval_add(name, type, mask);\r\n}\r\nint crypto_probing_notify(unsigned long val, void *v)\r\n{\r\nint ok;\r\nok = blocking_notifier_call_chain(&crypto_chain, val, v);\r\nif (ok == NOTIFY_DONE) {\r\nrequest_module("cryptomgr");\r\nok = blocking_notifier_call_chain(&crypto_chain, val, v);\r\n}\r\nreturn ok;\r\n}\r\nstruct crypto_alg *crypto_alg_mod_lookup(const char *name, u32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_alg *larval;\r\nint ok;\r\nif (!((type | mask) & CRYPTO_ALG_TESTED)) {\r\ntype |= CRYPTO_ALG_TESTED;\r\nmask |= CRYPTO_ALG_TESTED;\r\n}\r\nlarval = crypto_larval_lookup(name, type, mask);\r\nif (IS_ERR(larval) || !crypto_is_larval(larval))\r\nreturn larval;\r\nok = crypto_probing_notify(CRYPTO_MSG_ALG_REQUEST, larval);\r\nif (ok == NOTIFY_STOP)\r\nalg = crypto_larval_wait(larval);\r\nelse {\r\ncrypto_mod_put(larval);\r\nalg = ERR_PTR(-ENOENT);\r\n}\r\ncrypto_larval_kill(larval);\r\nreturn alg;\r\n}\r\nstatic int crypto_init_ops(struct crypto_tfm *tfm, u32 type, u32 mask)\r\n{\r\nconst struct crypto_type *type_obj = tfm->__crt_alg->cra_type;\r\nif (type_obj)\r\nreturn type_obj->init(tfm, type, mask);\r\nswitch (crypto_tfm_alg_type(tfm)) {\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\nreturn crypto_init_cipher_ops(tfm);\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\nreturn crypto_init_compress_ops(tfm);\r\ndefault:\r\nbreak;\r\n}\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nstatic void crypto_exit_ops(struct crypto_tfm *tfm)\r\n{\r\nconst struct crypto_type *type = tfm->__crt_alg->cra_type;\r\nif (type) {\r\nif (tfm->exit)\r\ntfm->exit(tfm);\r\nreturn;\r\n}\r\nswitch (crypto_tfm_alg_type(tfm)) {\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\ncrypto_exit_cipher_ops(tfm);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\ncrypto_exit_compress_ops(tfm);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic unsigned int crypto_ctxsize(struct crypto_alg *alg, u32 type, u32 mask)\r\n{\r\nconst struct crypto_type *type_obj = alg->cra_type;\r\nunsigned int len;\r\nlen = alg->cra_alignmask & ~(crypto_tfm_ctx_alignment() - 1);\r\nif (type_obj)\r\nreturn len + type_obj->ctxsize(alg, type, mask);\r\nswitch (alg->cra_flags & CRYPTO_ALG_TYPE_MASK) {\r\ndefault:\r\nBUG();\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\nlen += crypto_cipher_ctxsize(alg);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\nlen += crypto_compress_ctxsize(alg);\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nvoid crypto_shoot_alg(struct crypto_alg *alg)\r\n{\r\ndown_write(&crypto_alg_sem);\r\nalg->cra_flags |= CRYPTO_ALG_DYING;\r\nup_write(&crypto_alg_sem);\r\n}\r\nstruct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 type,\r\nu32 mask)\r\n{\r\nstruct crypto_tfm *tfm = NULL;\r\nunsigned int tfm_size;\r\nint err = -ENOMEM;\r\ntfm_size = sizeof(*tfm) + crypto_ctxsize(alg, type, mask);\r\ntfm = kzalloc(tfm_size, GFP_KERNEL);\r\nif (tfm == NULL)\r\ngoto out_err;\r\ntfm->__crt_alg = alg;\r\nerr = crypto_init_ops(tfm, type, mask);\r\nif (err)\r\ngoto out_free_tfm;\r\nif (!tfm->exit && alg->cra_init && (err = alg->cra_init(tfm)))\r\ngoto cra_init_failed;\r\ngoto out;\r\ncra_init_failed:\r\ncrypto_exit_ops(tfm);\r\nout_free_tfm:\r\nif (err == -EAGAIN)\r\ncrypto_shoot_alg(alg);\r\nkfree(tfm);\r\nout_err:\r\ntfm = ERR_PTR(err);\r\nout:\r\nreturn tfm;\r\n}\r\nstruct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)\r\n{\r\nstruct crypto_tfm *tfm;\r\nint err;\r\nfor (;;) {\r\nstruct crypto_alg *alg;\r\nalg = crypto_alg_mod_lookup(alg_name, type, mask);\r\nif (IS_ERR(alg)) {\r\nerr = PTR_ERR(alg);\r\ngoto err;\r\n}\r\ntfm = __crypto_alloc_tfm(alg, type, mask);\r\nif (!IS_ERR(tfm))\r\nreturn tfm;\r\ncrypto_mod_put(alg);\r\nerr = PTR_ERR(tfm);\r\nerr:\r\nif (err != -EAGAIN)\r\nbreak;\r\nif (signal_pending(current)) {\r\nerr = -EINTR;\r\nbreak;\r\n}\r\n}\r\nreturn ERR_PTR(err);\r\n}\r\nvoid *crypto_create_tfm(struct crypto_alg *alg,\r\nconst struct crypto_type *frontend)\r\n{\r\nchar *mem;\r\nstruct crypto_tfm *tfm = NULL;\r\nunsigned int tfmsize;\r\nunsigned int total;\r\nint err = -ENOMEM;\r\ntfmsize = frontend->tfmsize;\r\ntotal = tfmsize + sizeof(*tfm) + frontend->extsize(alg);\r\nmem = kzalloc(total, GFP_KERNEL);\r\nif (mem == NULL)\r\ngoto out_err;\r\ntfm = (struct crypto_tfm *)(mem + tfmsize);\r\ntfm->__crt_alg = alg;\r\nerr = frontend->init_tfm(tfm);\r\nif (err)\r\ngoto out_free_tfm;\r\nif (!tfm->exit && alg->cra_init && (err = alg->cra_init(tfm)))\r\ngoto cra_init_failed;\r\ngoto out;\r\ncra_init_failed:\r\ncrypto_exit_ops(tfm);\r\nout_free_tfm:\r\nif (err == -EAGAIN)\r\ncrypto_shoot_alg(alg);\r\nkfree(mem);\r\nout_err:\r\nmem = ERR_PTR(err);\r\nout:\r\nreturn mem;\r\n}\r\nstruct crypto_alg *crypto_find_alg(const char *alg_name,\r\nconst struct crypto_type *frontend,\r\nu32 type, u32 mask)\r\n{\r\nstruct crypto_alg *(*lookup)(const char *name, u32 type, u32 mask) =\r\ncrypto_alg_mod_lookup;\r\nif (frontend) {\r\ntype &= frontend->maskclear;\r\nmask &= frontend->maskclear;\r\ntype |= frontend->type;\r\nmask |= frontend->maskset;\r\nif (frontend->lookup)\r\nlookup = frontend->lookup;\r\n}\r\nreturn lookup(alg_name, type, mask);\r\n}\r\nvoid *crypto_alloc_tfm(const char *alg_name,\r\nconst struct crypto_type *frontend, u32 type, u32 mask)\r\n{\r\nvoid *tfm;\r\nint err;\r\nfor (;;) {\r\nstruct crypto_alg *alg;\r\nalg = crypto_find_alg(alg_name, frontend, type, mask);\r\nif (IS_ERR(alg)) {\r\nerr = PTR_ERR(alg);\r\ngoto err;\r\n}\r\ntfm = crypto_create_tfm(alg, frontend);\r\nif (!IS_ERR(tfm))\r\nreturn tfm;\r\ncrypto_mod_put(alg);\r\nerr = PTR_ERR(tfm);\r\nerr:\r\nif (err != -EAGAIN)\r\nbreak;\r\nif (signal_pending(current)) {\r\nerr = -EINTR;\r\nbreak;\r\n}\r\n}\r\nreturn ERR_PTR(err);\r\n}\r\nvoid crypto_destroy_tfm(void *mem, struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_alg *alg;\r\nif (unlikely(!mem))\r\nreturn;\r\nalg = tfm->__crt_alg;\r\nif (!tfm->exit && alg->cra_exit)\r\nalg->cra_exit(tfm);\r\ncrypto_exit_ops(tfm);\r\ncrypto_mod_put(alg);\r\nkzfree(mem);\r\n}\r\nint crypto_has_alg(const char *name, u32 type, u32 mask)\r\n{\r\nint ret = 0;\r\nstruct crypto_alg *alg = crypto_alg_mod_lookup(name, type, mask);\r\nif (!IS_ERR(alg)) {\r\ncrypto_mod_put(alg);\r\nret = 1;\r\n}\r\nreturn ret;\r\n}
