static int gcm_aes_nx_set_key(struct crypto_aead *tfm,\r\nconst u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_csbcpb *csbcpb_aead = nx_ctx->csbcpb_aead;\r\nnx_ctx_init(nx_ctx, HCOP_FC_AES);\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\nNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);\r\nNX_CPB_SET_KEY_SIZE(csbcpb_aead, NX_KS_AES_128);\r\nnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_128];\r\nbreak;\r\ncase AES_KEYSIZE_192:\r\nNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_192);\r\nNX_CPB_SET_KEY_SIZE(csbcpb_aead, NX_KS_AES_192);\r\nnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_192];\r\nbreak;\r\ncase AES_KEYSIZE_256:\r\nNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_256);\r\nNX_CPB_SET_KEY_SIZE(csbcpb_aead, NX_KS_AES_256);\r\nnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_256];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncsbcpb->cpb.hdr.mode = NX_MODE_AES_GCM;\r\nmemcpy(csbcpb->cpb.aes_gcm.key, in_key, key_len);\r\ncsbcpb_aead->cpb.hdr.mode = NX_MODE_AES_GCA;\r\nmemcpy(csbcpb_aead->cpb.aes_gca.key, in_key, key_len);\r\nreturn 0;\r\n}\r\nstatic int gcm4106_aes_nx_set_key(struct crypto_aead *tfm,\r\nconst u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&tfm->base);\r\nchar *nonce = nx_ctx->priv.gcm.nonce;\r\nint rc;\r\nif (key_len < 4)\r\nreturn -EINVAL;\r\nkey_len -= 4;\r\nrc = gcm_aes_nx_set_key(tfm, in_key, key_len);\r\nif (rc)\r\ngoto out;\r\nmemcpy(nonce, in_key + key_len, 4);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int gcm_aes_nx_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nif (authsize > crypto_aead_alg(tfm)->maxauthsize)\r\nreturn -EINVAL;\r\ncrypto_aead_crt(tfm)->authsize = authsize;\r\nreturn 0;\r\n}\r\nstatic int gcm4106_aes_nx_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 8:\r\ncase 12:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncrypto_aead_crt(tfm)->authsize = authsize;\r\nreturn 0;\r\n}\r\nstatic int nx_gca(struct nx_crypto_ctx *nx_ctx,\r\nstruct aead_request *req,\r\nu8 *out)\r\n{\r\nstruct nx_csbcpb *csbcpb_aead = nx_ctx->csbcpb_aead;\r\nint rc = -EINVAL;\r\nstruct scatter_walk walk;\r\nstruct nx_sg *nx_sg = nx_ctx->in_sg;\r\nif (req->assoclen > nx_ctx->ap->databytelen)\r\ngoto out;\r\nif (req->assoclen <= AES_BLOCK_SIZE) {\r\nscatterwalk_start(&walk, req->assoc);\r\nscatterwalk_copychunks(out, &walk, req->assoclen,\r\nSCATTERWALK_FROM_SG);\r\nscatterwalk_done(&walk, SCATTERWALK_FROM_SG, 0);\r\nrc = 0;\r\ngoto out;\r\n}\r\nnx_sg = nx_walk_and_build(nx_sg, nx_ctx->ap->sglen, req->assoc, 0,\r\nreq->assoclen);\r\nnx_ctx->op_aead.inlen = (nx_ctx->in_sg - nx_sg) * sizeof(struct nx_sg);\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op_aead,\r\nreq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\natomic64_add(req->assoclen, &(nx_ctx->stats->aes_bytes));\r\nmemcpy(out, csbcpb_aead->cpb.aes_gca.out_pat, AES_BLOCK_SIZE);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int gcm_aes_nx_crypt(struct aead_request *req, int enc)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct blkcipher_desc desc;\r\nunsigned int nbytes = req->cryptlen;\r\nint rc = -EINVAL;\r\nif (nbytes > nx_ctx->ap->databytelen)\r\ngoto out;\r\ndesc.info = nx_ctx->priv.gcm.iv;\r\n*(u32 *)(desc.info + NX_GCM_CTR_OFFSET) = 1;\r\nif (nbytes == 0) {\r\nchar src[AES_BLOCK_SIZE] = {};\r\nstruct scatterlist sg;\r\ndesc.tfm = crypto_alloc_blkcipher("ctr(aes)", 0, 0);\r\nif (IS_ERR(desc.tfm)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ncrypto_blkcipher_setkey(desc.tfm, csbcpb->cpb.aes_gcm.key,\r\nNX_CPB_KEY_SIZE(csbcpb) == NX_KS_AES_128 ? 16 :\r\nNX_CPB_KEY_SIZE(csbcpb) == NX_KS_AES_192 ? 24 : 32);\r\nsg_init_one(&sg, src, AES_BLOCK_SIZE);\r\nif (enc)\r\ncrypto_blkcipher_encrypt_iv(&desc, req->dst, &sg,\r\nAES_BLOCK_SIZE);\r\nelse\r\ncrypto_blkcipher_decrypt_iv(&desc, req->dst, &sg,\r\nAES_BLOCK_SIZE);\r\ncrypto_free_blkcipher(desc.tfm);\r\nrc = 0;\r\ngoto out;\r\n}\r\ndesc.tfm = (struct crypto_blkcipher *)req->base.tfm;\r\ncsbcpb->cpb.aes_gcm.bit_length_aad = req->assoclen * 8;\r\nif (req->assoclen) {\r\nrc = nx_gca(nx_ctx, req, csbcpb->cpb.aes_gcm.in_pat_or_aad);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (enc)\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_ENDE_ENCRYPT;\r\nelse\r\nnbytes -= crypto_aead_authsize(crypto_aead_reqtfm(req));\r\ncsbcpb->cpb.aes_gcm.bit_length_data = nbytes * 8;\r\nrc = nx_build_sg_lists(nx_ctx, &desc, req->dst, req->src, nbytes,\r\ncsbcpb->cpb.aes_gcm.iv_or_cnt);\r\nif (rc)\r\ngoto out;\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\nreq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\natomic64_add(csbcpb->csb.processed_byte_count,\r\n&(nx_ctx->stats->aes_bytes));\r\nif (enc) {\r\nscatterwalk_map_and_copy(csbcpb->cpb.aes_gcm.out_pat_or_mac,\r\nreq->dst, nbytes,\r\ncrypto_aead_authsize(crypto_aead_reqtfm(req)),\r\nSCATTERWALK_TO_SG);\r\n} else if (req->assoclen) {\r\nu8 *itag = nx_ctx->priv.gcm.iauth_tag;\r\nu8 *otag = csbcpb->cpb.aes_gcm.out_pat_or_mac;\r\nscatterwalk_map_and_copy(itag, req->dst, nbytes,\r\ncrypto_aead_authsize(crypto_aead_reqtfm(req)),\r\nSCATTERWALK_FROM_SG);\r\nrc = memcmp(itag, otag,\r\ncrypto_aead_authsize(crypto_aead_reqtfm(req))) ?\r\n-EBADMSG : 0;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int gcm_aes_nx_encrypt(struct aead_request *req)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req->base.tfm);\r\nchar *iv = nx_ctx->priv.gcm.iv;\r\nmemcpy(iv, req->iv, 12);\r\nreturn gcm_aes_nx_crypt(req, 1);\r\n}\r\nstatic int gcm_aes_nx_decrypt(struct aead_request *req)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req->base.tfm);\r\nchar *iv = nx_ctx->priv.gcm.iv;\r\nmemcpy(iv, req->iv, 12);\r\nreturn gcm_aes_nx_crypt(req, 0);\r\n}\r\nstatic int gcm4106_aes_nx_encrypt(struct aead_request *req)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req->base.tfm);\r\nchar *iv = nx_ctx->priv.gcm.iv;\r\nchar *nonce = nx_ctx->priv.gcm.nonce;\r\nmemcpy(iv, nonce, NX_GCM4106_NONCE_LEN);\r\nmemcpy(iv + NX_GCM4106_NONCE_LEN, req->iv, 8);\r\nreturn gcm_aes_nx_crypt(req, 1);\r\n}\r\nstatic int gcm4106_aes_nx_decrypt(struct aead_request *req)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(req->base.tfm);\r\nchar *iv = nx_ctx->priv.gcm.iv;\r\nchar *nonce = nx_ctx->priv.gcm.nonce;\r\nmemcpy(iv, nonce, NX_GCM4106_NONCE_LEN);\r\nmemcpy(iv + NX_GCM4106_NONCE_LEN, req->iv, 8);\r\nreturn gcm_aes_nx_crypt(req, 0);\r\n}
