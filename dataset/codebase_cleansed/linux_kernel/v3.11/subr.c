static int t1_wait_op_done(adapter_t *adapter, int reg, u32 mask, int polarity,\r\nint attempts, int delay)\r\n{\r\nwhile (1) {\r\nu32 val = readl(adapter->regs + reg) & mask;\r\nif (!!val == polarity)\r\nreturn 0;\r\nif (--attempts == 0)\r\nreturn 1;\r\nif (delay)\r\nudelay(delay);\r\n}\r\n}\r\nint __t1_tpi_write(adapter_t *adapter, u32 addr, u32 value)\r\n{\r\nint tpi_busy;\r\nwritel(addr, adapter->regs + A_TPI_ADDR);\r\nwritel(value, adapter->regs + A_TPI_WR_DATA);\r\nwritel(F_TPIWR, adapter->regs + A_TPI_CSR);\r\ntpi_busy = t1_wait_op_done(adapter, A_TPI_CSR, F_TPIRDY, 1,\r\nTPI_ATTEMPTS, 3);\r\nif (tpi_busy)\r\npr_alert("%s: TPI write to 0x%x failed\n",\r\nadapter->name, addr);\r\nreturn tpi_busy;\r\n}\r\nint t1_tpi_write(adapter_t *adapter, u32 addr, u32 value)\r\n{\r\nint ret;\r\nspin_lock(&adapter->tpi_lock);\r\nret = __t1_tpi_write(adapter, addr, value);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn ret;\r\n}\r\nint __t1_tpi_read(adapter_t *adapter, u32 addr, u32 *valp)\r\n{\r\nint tpi_busy;\r\nwritel(addr, adapter->regs + A_TPI_ADDR);\r\nwritel(0, adapter->regs + A_TPI_CSR);\r\ntpi_busy = t1_wait_op_done(adapter, A_TPI_CSR, F_TPIRDY, 1,\r\nTPI_ATTEMPTS, 3);\r\nif (tpi_busy)\r\npr_alert("%s: TPI read from 0x%x failed\n",\r\nadapter->name, addr);\r\nelse\r\n*valp = readl(adapter->regs + A_TPI_RD_DATA);\r\nreturn tpi_busy;\r\n}\r\nint t1_tpi_read(adapter_t *adapter, u32 addr, u32 *valp)\r\n{\r\nint ret;\r\nspin_lock(&adapter->tpi_lock);\r\nret = __t1_tpi_read(adapter, addr, valp);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn ret;\r\n}\r\nstatic void t1_tpi_par(adapter_t *adapter, u32 value)\r\n{\r\nwritel(V_TPIPAR(value), adapter->regs + A_TPI_PAR);\r\n}\r\nvoid t1_link_changed(adapter_t *adapter, int port_id)\r\n{\r\nint link_ok, speed, duplex, fc;\r\nstruct cphy *phy = adapter->port[port_id].phy;\r\nstruct link_config *lc = &adapter->port[port_id].link_config;\r\nphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\r\nlc->speed = speed < 0 ? SPEED_INVALID : speed;\r\nlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\r\nif (!(lc->requested_fc & PAUSE_AUTONEG))\r\nfc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\nif (link_ok && speed >= 0 && lc->autoneg == AUTONEG_ENABLE) {\r\nstruct cmac *mac = adapter->port[port_id].mac;\r\nmac->ops->set_speed_duplex_fc(mac, speed, duplex, fc);\r\nlc->fc = (unsigned char)fc;\r\n}\r\nt1_link_negotiated(adapter, port_id, link_ok, speed, duplex, fc);\r\n}\r\nstatic int t1_pci_intr_handler(adapter_t *adapter)\r\n{\r\nu32 pcix_cause;\r\npci_read_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE, &pcix_cause);\r\nif (pcix_cause) {\r\npci_write_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE,\r\npcix_cause);\r\nt1_fatal_err(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpga_phy_intr_handler(adapter_t *adapter)\r\n{\r\nint p;\r\nu32 cause = readl(adapter->regs + FPGA_GMAC_ADDR_INTERRUPT_CAUSE);\r\nfor_each_port(adapter, p)\r\nif (cause & (1 << p)) {\r\nstruct cphy *phy = adapter->port[p].phy;\r\nint phy_cause = phy->ops->interrupt_handler(phy);\r\nif (phy_cause & cphy_cause_link_change)\r\nt1_link_changed(adapter, p);\r\n}\r\nwritel(cause, adapter->regs + FPGA_GMAC_ADDR_INTERRUPT_CAUSE);\r\nreturn 0;\r\n}\r\nstatic int fpga_slow_intr(adapter_t *adapter)\r\n{\r\nu32 cause = readl(adapter->regs + A_PL_CAUSE);\r\ncause &= ~F_PL_INTR_SGE_DATA;\r\nif (cause & F_PL_INTR_SGE_ERR)\r\nt1_sge_intr_error_handler(adapter->sge);\r\nif (cause & FPGA_PCIX_INTERRUPT_GMAC)\r\nfpga_phy_intr_handler(adapter);\r\nif (cause & FPGA_PCIX_INTERRUPT_TP) {\r\nu32 tp_cause = readl(adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);\r\nwritel(tp_cause, adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);\r\n}\r\nif (cause & FPGA_PCIX_INTERRUPT_PCIX)\r\nt1_pci_intr_handler(adapter);\r\nif (cause)\r\nwritel(cause, adapter->regs + A_PL_CAUSE);\r\nreturn cause != 0;\r\n}\r\nstatic int mi1_wait_until_ready(adapter_t *adapter, int mi1_reg)\r\n{\r\nint attempts = 100, busy;\r\ndo {\r\nu32 val;\r\n__t1_tpi_read(adapter, mi1_reg, &val);\r\nbusy = val & F_MI1_OP_BUSY;\r\nif (busy)\r\nudelay(10);\r\n} while (busy && --attempts);\r\nif (busy)\r\npr_alert("%s: MDIO operation timed out\n", adapter->name);\r\nreturn busy;\r\n}\r\nstatic void mi1_mdio_init(adapter_t *adapter, const struct board_info *bi)\r\n{\r\nu32 clkdiv = bi->clock_elmer0 / (2 * bi->mdio_mdc) - 1;\r\nu32 val = F_MI1_PREAMBLE_ENABLE | V_MI1_MDI_INVERT(bi->mdio_mdiinv) |\r\nV_MI1_MDI_ENABLE(bi->mdio_mdien) | V_MI1_CLK_DIV(clkdiv);\r\nif (!(bi->caps & SUPPORTED_10000baseT_Full))\r\nval |= V_MI1_SOF(1);\r\nt1_tpi_write(adapter, A_ELMER0_PORT0_MI1_CFG, val);\r\n}\r\nstatic int mi1_mdio_read(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nu32 addr = V_MI1_REG_ADDR(reg_addr) | V_MI1_PHY_ADDR(phy_addr);\r\nunsigned int val;\r\nspin_lock(&adapter->tpi_lock);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\r\n__t1_tpi_write(adapter,\r\nA_ELMER0_PORT0_MI1_OP, MI1_OP_DIRECT_READ);\r\nmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\r\n__t1_tpi_read(adapter, A_ELMER0_PORT0_MI1_DATA, &val);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn val;\r\n}\r\nstatic int mi1_mdio_write(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr, u16 val)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nu32 addr = V_MI1_REG_ADDR(reg_addr) | V_MI1_PHY_ADDR(phy_addr);\r\nspin_lock(&adapter->tpi_lock);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, val);\r\n__t1_tpi_write(adapter,\r\nA_ELMER0_PORT0_MI1_OP, MI1_OP_DIRECT_WRITE);\r\nmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn 0;\r\n}\r\nstatic int mi1_mdio_ext_read(struct net_device *dev, int phy_addr, int mmd_addr,\r\nu16 reg_addr)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nu32 addr = V_MI1_REG_ADDR(mmd_addr) | V_MI1_PHY_ADDR(phy_addr);\r\nunsigned int val;\r\nspin_lock(&adapter->tpi_lock);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, reg_addr);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_OP,\r\nMI1_OP_INDIRECT_ADDRESS);\r\nmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\r\n__t1_tpi_write(adapter,\r\nA_ELMER0_PORT0_MI1_OP, MI1_OP_INDIRECT_READ);\r\nmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\r\n__t1_tpi_read(adapter, A_ELMER0_PORT0_MI1_DATA, &val);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn val;\r\n}\r\nstatic int mi1_mdio_ext_write(struct net_device *dev, int phy_addr,\r\nint mmd_addr, u16 reg_addr, u16 val)\r\n{\r\nstruct adapter *adapter = dev->ml_priv;\r\nu32 addr = V_MI1_REG_ADDR(mmd_addr) | V_MI1_PHY_ADDR(phy_addr);\r\nspin_lock(&adapter->tpi_lock);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, reg_addr);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_OP,\r\nMI1_OP_INDIRECT_ADDRESS);\r\nmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, val);\r\n__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_OP, MI1_OP_INDIRECT_WRITE);\r\nmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\r\nspin_unlock(&adapter->tpi_lock);\r\nreturn 0;\r\n}\r\nconst struct board_info *t1_get_board_info(unsigned int board_id)\r\n{\r\nreturn board_id < ARRAY_SIZE(t1_board) ? &t1_board[board_id] : NULL;\r\n}\r\nint t1_seeprom_read(adapter_t *adapter, u32 addr, __le32 *data)\r\n{\r\nint i = EEPROM_MAX_POLL;\r\nu16 val;\r\nu32 v;\r\nif (addr >= EEPROMSIZE || (addr & 3))\r\nreturn -EINVAL;\r\npci_write_config_word(adapter->pdev, A_PCICFG_VPD_ADDR, (u16)addr);\r\ndo {\r\nudelay(50);\r\npci_read_config_word(adapter->pdev, A_PCICFG_VPD_ADDR, &val);\r\n} while (!(val & F_VPD_OP_FLAG) && --i);\r\nif (!(val & F_VPD_OP_FLAG)) {\r\npr_err("%s: reading EEPROM address 0x%x failed\n",\r\nadapter->name, addr);\r\nreturn -EIO;\r\n}\r\npci_read_config_dword(adapter->pdev, A_PCICFG_VPD_DATA, &v);\r\n*data = cpu_to_le32(v);\r\nreturn 0;\r\n}\r\nstatic int t1_eeprom_vpd_get(adapter_t *adapter, struct chelsio_vpd_t *vpd)\r\n{\r\nint addr, ret = 0;\r\nfor (addr = 0; !ret && addr < sizeof(*vpd); addr += sizeof(u32))\r\nret = t1_seeprom_read(adapter, addr,\r\n(__le32 *)((u8 *)vpd + addr));\r\nreturn ret;\r\n}\r\nstatic int vpd_macaddress_get(adapter_t *adapter, int index, u8 mac_addr[])\r\n{\r\nstruct chelsio_vpd_t vpd;\r\nif (t1_eeprom_vpd_get(adapter, &vpd))\r\nreturn 1;\r\nmemcpy(mac_addr, vpd.mac_base_address, 5);\r\nmac_addr[5] = vpd.mac_base_address[5] + index;\r\nreturn 0;\r\n}\r\nint t1_link_start(struct cphy *phy, struct cmac *mac, struct link_config *lc)\r\n{\r\nunsigned int fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\r\nif (lc->supported & SUPPORTED_Autoneg) {\r\nlc->advertising &= ~(ADVERTISED_ASYM_PAUSE | ADVERTISED_PAUSE);\r\nif (fc) {\r\nif (fc == ((PAUSE_RX | PAUSE_TX) &\r\n(mac->adapter->params.nports < 2)))\r\nlc->advertising |= ADVERTISED_PAUSE;\r\nelse {\r\nlc->advertising |= ADVERTISED_ASYM_PAUSE;\r\nif (fc == PAUSE_RX)\r\nlc->advertising |= ADVERTISED_PAUSE;\r\n}\r\n}\r\nphy->ops->advertise(phy, lc->advertising);\r\nif (lc->autoneg == AUTONEG_DISABLE) {\r\nlc->speed = lc->requested_speed;\r\nlc->duplex = lc->requested_duplex;\r\nlc->fc = (unsigned char)fc;\r\nmac->ops->set_speed_duplex_fc(mac, lc->speed,\r\nlc->duplex, fc);\r\nphy->state = PHY_AUTONEG_RDY;\r\nphy->ops->set_speed_duplex(phy, lc->speed, lc->duplex);\r\nphy->ops->reset(phy, 0);\r\n} else {\r\nphy->state = PHY_AUTONEG_EN;\r\nphy->ops->autoneg_enable(phy);\r\n}\r\n} else {\r\nphy->state = PHY_AUTONEG_RDY;\r\nmac->ops->set_speed_duplex_fc(mac, -1, -1, fc);\r\nlc->fc = (unsigned char)fc;\r\nphy->ops->reset(phy, 0);\r\n}\r\nreturn 0;\r\n}\r\nint t1_elmer0_ext_intr_handler(adapter_t *adapter)\r\n{\r\nstruct cphy *phy;\r\nint phy_cause;\r\nu32 cause;\r\nt1_tpi_read(adapter, A_ELMER0_INT_CAUSE, &cause);\r\nswitch (board_info(adapter)->board) {\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\ncase CHBT_BOARD_CHT204:\r\ncase CHBT_BOARD_CHT204E:\r\ncase CHBT_BOARD_CHN204:\r\ncase CHBT_BOARD_CHT204V: {\r\nint i, port_bit;\r\nfor_each_port(adapter, i) {\r\nport_bit = i + 1;\r\nif (!(cause & (1 << port_bit)))\r\ncontinue;\r\nphy = adapter->port[i].phy;\r\nphy_cause = phy->ops->interrupt_handler(phy);\r\nif (phy_cause & cphy_cause_link_change)\r\nt1_link_changed(adapter, i);\r\n}\r\nbreak;\r\n}\r\ncase CHBT_BOARD_CHT101:\r\nif (cause & ELMER0_GP_BIT1) {\r\nphy = adapter->port[0].phy;\r\nphy_cause = phy->ops->interrupt_handler(phy);\r\nif (phy_cause & cphy_cause_link_change)\r\nt1_link_changed(adapter, 0);\r\n}\r\nbreak;\r\ncase CHBT_BOARD_7500: {\r\nint p;\r\nfor_each_port(adapter, p) {\r\nphy = adapter->port[p].phy;\r\nphy_cause = phy->ops->interrupt_handler(phy);\r\nif (phy_cause & cphy_cause_link_change)\r\nt1_link_changed(adapter, p);\r\n}\r\nbreak;\r\n}\r\n#endif\r\ncase CHBT_BOARD_CHT210:\r\ncase CHBT_BOARD_N210:\r\ncase CHBT_BOARD_N110:\r\nif (cause & ELMER0_GP_BIT6) {\r\nphy = adapter->port[0].phy;\r\nphy_cause = phy->ops->interrupt_handler(phy);\r\nif (phy_cause & cphy_cause_link_change)\r\nt1_link_changed(adapter, 0);\r\n}\r\nbreak;\r\ncase CHBT_BOARD_8000:\r\ncase CHBT_BOARD_CHT110:\r\nif (netif_msg_intr(adapter))\r\ndev_dbg(&adapter->pdev->dev,\r\n"External interrupt cause 0x%x\n", cause);\r\nif (cause & ELMER0_GP_BIT1) {\r\nstruct cmac *mac = adapter->port[0].mac;\r\nmac->ops->interrupt_handler(mac);\r\n}\r\nif (cause & ELMER0_GP_BIT5) {\r\nu32 mod_detect;\r\nt1_tpi_read(adapter,\r\nA_ELMER0_GPI_STAT, &mod_detect);\r\nif (netif_msg_link(adapter))\r\ndev_info(&adapter->pdev->dev, "XPAK %s\n",\r\nmod_detect ? "removed" : "inserted");\r\n}\r\nbreak;\r\n}\r\nt1_tpi_write(adapter, A_ELMER0_INT_CAUSE, cause);\r\nreturn 0;\r\n}\r\nvoid t1_interrupts_enable(adapter_t *adapter)\r\n{\r\nunsigned int i;\r\nadapter->slow_intr_mask = F_PL_INTR_SGE_ERR | F_PL_INTR_TP;\r\nt1_sge_intr_enable(adapter->sge);\r\nt1_tp_intr_enable(adapter->tp);\r\nif (adapter->espi) {\r\nadapter->slow_intr_mask |= F_PL_INTR_ESPI;\r\nt1_espi_intr_enable(adapter->espi);\r\n}\r\nfor_each_port(adapter, i) {\r\nadapter->port[i].mac->ops->interrupt_enable(adapter->port[i].mac);\r\nadapter->port[i].phy->ops->interrupt_enable(adapter->port[i].phy);\r\n}\r\nif (t1_is_asic(adapter)) {\r\nu32 pl_intr = readl(adapter->regs + A_PL_ENABLE);\r\npci_write_config_dword(adapter->pdev, A_PCICFG_INTR_ENABLE,\r\n0xffffffff);\r\nadapter->slow_intr_mask |= F_PL_INTR_EXT | F_PL_INTR_PCIX;\r\npl_intr |= F_PL_INTR_EXT | F_PL_INTR_PCIX;\r\nwritel(pl_intr, adapter->regs + A_PL_ENABLE);\r\n}\r\n}\r\nvoid t1_interrupts_disable(adapter_t* adapter)\r\n{\r\nunsigned int i;\r\nt1_sge_intr_disable(adapter->sge);\r\nt1_tp_intr_disable(adapter->tp);\r\nif (adapter->espi)\r\nt1_espi_intr_disable(adapter->espi);\r\nfor_each_port(adapter, i) {\r\nadapter->port[i].mac->ops->interrupt_disable(adapter->port[i].mac);\r\nadapter->port[i].phy->ops->interrupt_disable(adapter->port[i].phy);\r\n}\r\nif (t1_is_asic(adapter))\r\nwritel(0, adapter->regs + A_PL_ENABLE);\r\npci_write_config_dword(adapter->pdev, A_PCICFG_INTR_ENABLE, 0);\r\nadapter->slow_intr_mask = 0;\r\n}\r\nvoid t1_interrupts_clear(adapter_t* adapter)\r\n{\r\nunsigned int i;\r\nt1_sge_intr_clear(adapter->sge);\r\nt1_tp_intr_clear(adapter->tp);\r\nif (adapter->espi)\r\nt1_espi_intr_clear(adapter->espi);\r\nfor_each_port(adapter, i) {\r\nadapter->port[i].mac->ops->interrupt_clear(adapter->port[i].mac);\r\nadapter->port[i].phy->ops->interrupt_clear(adapter->port[i].phy);\r\n}\r\nif (t1_is_asic(adapter)) {\r\nu32 pl_intr = readl(adapter->regs + A_PL_CAUSE);\r\nwritel(pl_intr | F_PL_INTR_EXT | F_PL_INTR_PCIX,\r\nadapter->regs + A_PL_CAUSE);\r\n}\r\npci_write_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE, 0xffffffff);\r\n}\r\nstatic int asic_slow_intr(adapter_t *adapter)\r\n{\r\nu32 cause = readl(adapter->regs + A_PL_CAUSE);\r\ncause &= adapter->slow_intr_mask;\r\nif (!cause)\r\nreturn 0;\r\nif (cause & F_PL_INTR_SGE_ERR)\r\nt1_sge_intr_error_handler(adapter->sge);\r\nif (cause & F_PL_INTR_TP)\r\nt1_tp_intr_handler(adapter->tp);\r\nif (cause & F_PL_INTR_ESPI)\r\nt1_espi_intr_handler(adapter->espi);\r\nif (cause & F_PL_INTR_PCIX)\r\nt1_pci_intr_handler(adapter);\r\nif (cause & F_PL_INTR_EXT)\r\nt1_elmer0_ext_intr(adapter);\r\nwritel(cause, adapter->regs + A_PL_CAUSE);\r\nreadl(adapter->regs + A_PL_CAUSE);\r\nreturn 1;\r\n}\r\nint t1_slow_intr_handler(adapter_t *adapter)\r\n{\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\nif (!t1_is_asic(adapter))\r\nreturn fpga_slow_intr(adapter);\r\n#endif\r\nreturn asic_slow_intr(adapter);\r\n}\r\nstatic void power_sequence_xpak(adapter_t* adapter)\r\n{\r\nu32 mod_detect;\r\nu32 gpo;\r\nt1_tpi_read(adapter, A_ELMER0_GPI_STAT, &mod_detect);\r\nif (!(ELMER0_GP_BIT5 & mod_detect)) {\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &gpo);\r\ngpo |= ELMER0_GP_BIT18;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, gpo);\r\n}\r\n}\r\nint t1_get_board_rev(adapter_t *adapter, const struct board_info *bi,\r\nstruct adapter_params *p)\r\n{\r\np->chip_version = bi->chip_term;\r\np->is_asic = (p->chip_version != CHBT_TERM_FPGA);\r\nif (p->chip_version == CHBT_TERM_T1 ||\r\np->chip_version == CHBT_TERM_T2 ||\r\np->chip_version == CHBT_TERM_FPGA) {\r\nu32 val = readl(adapter->regs + A_TP_PC_CONFIG);\r\nval = G_TP_PC_REV(val);\r\nif (val == 2)\r\np->chip_revision = TERM_T1B;\r\nelse if (val == 3)\r\np->chip_revision = TERM_T2;\r\nelse\r\nreturn -1;\r\n} else\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int board_init(adapter_t *adapter, const struct board_info *bi)\r\n{\r\nswitch (bi->board) {\r\ncase CHBT_BOARD_8000:\r\ncase CHBT_BOARD_N110:\r\ncase CHBT_BOARD_N210:\r\ncase CHBT_BOARD_CHT210:\r\nt1_tpi_par(adapter, 0xf);\r\nt1_tpi_write(adapter, A_ELMER0_GPO, 0x800);\r\nbreak;\r\ncase CHBT_BOARD_CHT110:\r\nt1_tpi_par(adapter, 0xf);\r\nt1_tpi_write(adapter, A_ELMER0_GPO, 0x1800);\r\npower_sequence_xpak(adapter);\r\nbreak;\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\ncase CHBT_BOARD_CHT204E:\r\ncase CHBT_BOARD_CHT204:\r\ncase CHBT_BOARD_CHT204V:\r\ncase CHBT_BOARD_CHN204:\r\nt1_tpi_par(adapter, 0xf);\r\nt1_tpi_write(adapter, A_ELMER0_GPO, 0x804);\r\nbreak;\r\ncase CHBT_BOARD_CHT101:\r\ncase CHBT_BOARD_7500:\r\nt1_tpi_par(adapter, 0xf);\r\nt1_tpi_write(adapter, A_ELMER0_GPO, 0x1804);\r\nbreak;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint t1_init_hw_modules(adapter_t *adapter)\r\n{\r\nint err = -EIO;\r\nconst struct board_info *bi = board_info(adapter);\r\nif (!bi->clock_mc4) {\r\nu32 val = readl(adapter->regs + A_MC4_CFG);\r\nwritel(val | F_READY | F_MC4_SLOW, adapter->regs + A_MC4_CFG);\r\nwritel(F_M_BUS_ENABLE | F_TCAM_RESET,\r\nadapter->regs + A_MC5_CONFIG);\r\n}\r\nif (adapter->espi && t1_espi_init(adapter->espi, bi->chip_mac,\r\nbi->espi_nports))\r\ngoto out_err;\r\nif (t1_tp_reset(adapter->tp, &adapter->params.tp, bi->clock_core))\r\ngoto out_err;\r\nerr = t1_sge_configure(adapter->sge, &adapter->params.sge);\r\nif (err)\r\ngoto out_err;\r\nerr = 0;\r\nout_err:\r\nreturn err;\r\n}\r\nstatic void get_pci_mode(adapter_t *adapter, struct chelsio_pci_params *p)\r\n{\r\nstatic const unsigned short speed_map[] = { 33, 66, 100, 133 };\r\nu32 pci_mode;\r\npci_read_config_dword(adapter->pdev, A_PCICFG_MODE, &pci_mode);\r\np->speed = speed_map[G_PCI_MODE_CLK(pci_mode)];\r\np->width = (pci_mode & F_PCI_MODE_64BIT) ? 64 : 32;\r\np->is_pcix = (pci_mode & F_PCI_MODE_PCIX) != 0;\r\n}\r\nvoid t1_free_sw_modules(adapter_t *adapter)\r\n{\r\nunsigned int i;\r\nfor_each_port(adapter, i) {\r\nstruct cmac *mac = adapter->port[i].mac;\r\nstruct cphy *phy = adapter->port[i].phy;\r\nif (mac)\r\nmac->ops->destroy(mac);\r\nif (phy)\r\nphy->ops->destroy(phy);\r\n}\r\nif (adapter->sge)\r\nt1_sge_destroy(adapter->sge);\r\nif (adapter->tp)\r\nt1_tp_destroy(adapter->tp);\r\nif (adapter->espi)\r\nt1_espi_destroy(adapter->espi);\r\n}\r\nstatic void init_link_config(struct link_config *lc,\r\nconst struct board_info *bi)\r\n{\r\nlc->supported = bi->caps;\r\nlc->requested_speed = lc->speed = SPEED_INVALID;\r\nlc->requested_duplex = lc->duplex = DUPLEX_INVALID;\r\nlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\r\nif (lc->supported & SUPPORTED_Autoneg) {\r\nlc->advertising = lc->supported;\r\nlc->autoneg = AUTONEG_ENABLE;\r\nlc->requested_fc |= PAUSE_AUTONEG;\r\n} else {\r\nlc->advertising = 0;\r\nlc->autoneg = AUTONEG_DISABLE;\r\n}\r\n}\r\nint t1_init_sw_modules(adapter_t *adapter, const struct board_info *bi)\r\n{\r\nunsigned int i;\r\nadapter->params.brd_info = bi;\r\nadapter->params.nports = bi->port_number;\r\nadapter->params.stats_update_period = bi->gmac->stats_update_period;\r\nadapter->sge = t1_sge_create(adapter, &adapter->params.sge);\r\nif (!adapter->sge) {\r\npr_err("%s: SGE initialization failed\n",\r\nadapter->name);\r\ngoto error;\r\n}\r\nif (bi->espi_nports && !(adapter->espi = t1_espi_create(adapter))) {\r\npr_err("%s: ESPI initialization failed\n",\r\nadapter->name);\r\ngoto error;\r\n}\r\nadapter->tp = t1_tp_create(adapter, &adapter->params.tp);\r\nif (!adapter->tp) {\r\npr_err("%s: TP initialization failed\n",\r\nadapter->name);\r\ngoto error;\r\n}\r\nboard_init(adapter, bi);\r\nbi->mdio_ops->init(adapter, bi);\r\nif (bi->gphy->reset)\r\nbi->gphy->reset(adapter);\r\nif (bi->gmac->reset)\r\nbi->gmac->reset(adapter);\r\nfor_each_port(adapter, i) {\r\nu8 hw_addr[6];\r\nstruct cmac *mac;\r\nint phy_addr = bi->mdio_phybaseaddr + i;\r\nadapter->port[i].phy = bi->gphy->create(adapter->port[i].dev,\r\nphy_addr, bi->mdio_ops);\r\nif (!adapter->port[i].phy) {\r\npr_err("%s: PHY %d initialization failed\n",\r\nadapter->name, i);\r\ngoto error;\r\n}\r\nadapter->port[i].mac = mac = bi->gmac->create(adapter, i);\r\nif (!mac) {\r\npr_err("%s: MAC %d initialization failed\n",\r\nadapter->name, i);\r\ngoto error;\r\n}\r\nif (!t1_is_asic(adapter) || bi->chip_mac == CHBT_MAC_DUMMY)\r\nmac->ops->macaddress_get(mac, hw_addr);\r\nelse if (vpd_macaddress_get(adapter, i, hw_addr)) {\r\npr_err("%s: could not read MAC address from VPD ROM\n",\r\nadapter->port[i].dev->name);\r\ngoto error;\r\n}\r\nmemcpy(adapter->port[i].dev->dev_addr, hw_addr, ETH_ALEN);\r\ninit_link_config(&adapter->port[i].link_config, bi);\r\n}\r\nget_pci_mode(adapter, &adapter->params.pci);\r\nt1_interrupts_clear(adapter);\r\nreturn 0;\r\nerror:\r\nt1_free_sw_modules(adapter);\r\nreturn -1;\r\n}
