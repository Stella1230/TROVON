int r2net_remote_target_node_set(int node_num)\r\n{\r\nint ret = -1;\r\nr2net_target_node = r2nm_get_node_by_num(node_num);\r\nif (r2net_target_node != NULL) {\r\nr2net_target_nodenum = node_num;\r\nr2nm_node_put(r2net_target_node);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ramster_remote_async_get_request_handler(struct r2net_msg *msg,\r\nu32 len, void *data, void **ret_data)\r\n{\r\nchar *pdata;\r\nstruct tmem_xhandle xh;\r\nint found;\r\nsize_t size = RMSTR_R2NET_MAX_LEN;\r\nu16 msgtype = be16_to_cpu(msg->msg_type);\r\nbool get_and_free = (msgtype == RMSTR_TMEM_ASYNC_GET_AND_FREE_REQUEST);\r\nunsigned long flags;\r\nxh = *(struct tmem_xhandle *)msg->buf;\r\nif (xh.xh_data_size > RMSTR_R2NET_MAX_LEN)\r\nBUG();\r\npdata = ramster_async_get_buf;\r\n*(struct tmem_xhandle *)pdata = xh;\r\npdata += sizeof(struct tmem_xhandle);\r\nlocal_irq_save(flags);\r\nfound = zcache_get_page(xh.client_id, xh.pool_id, &xh.oid, xh.index,\r\npdata, &size, true, get_and_free ? 1 : -1);\r\nlocal_irq_restore(flags);\r\nif (found < 0) {\r\nsize = 0;\r\n}\r\nif (size > RMSTR_R2NET_MAX_LEN)\r\nBUG();\r\n*ret_data = pdata - sizeof(struct tmem_xhandle);\r\nr2net_force_data_magic(msg, RMSTR_TMEM_ASYNC_GET_REPLY, RMSTR_KEY);\r\nreturn size + sizeof(struct tmem_xhandle);\r\n}\r\nstatic int ramster_remote_async_get_reply_handler(struct r2net_msg *msg,\r\nu32 len, void *data, void **ret_data)\r\n{\r\nchar *in = (char *)msg->buf;\r\nint datalen = len - sizeof(struct r2net_msg);\r\nint ret = -1;\r\nstruct tmem_xhandle *xh = (struct tmem_xhandle *)in;\r\nin += sizeof(struct tmem_xhandle);\r\ndatalen -= sizeof(struct tmem_xhandle);\r\nBUG_ON(datalen < 0 || datalen > PAGE_SIZE);\r\nret = ramster_localify(xh->pool_id, &xh->oid, xh->index,\r\nin, datalen, xh->extra);\r\n#ifdef RAMSTER_TESTING\r\nif (ret == -EEXIST)\r\npr_err("TESTING ArrgREP, aborted overwrite on racy put\n");\r\n#endif\r\nreturn ret;\r\n}\r\nint ramster_remote_put_handler(struct r2net_msg *msg,\r\nu32 len, void *data, void **ret_data)\r\n{\r\nstruct tmem_xhandle *xh;\r\nchar *p = (char *)msg->buf;\r\nint datalen = len - sizeof(struct r2net_msg) -\r\nsizeof(struct tmem_xhandle);\r\nu16 msgtype = be16_to_cpu(msg->msg_type);\r\nbool ephemeral = (msgtype == RMSTR_TMEM_PUT_EPH);\r\nunsigned long flags;\r\nint ret;\r\nxh = (struct tmem_xhandle *)p;\r\np += sizeof(struct tmem_xhandle);\r\nzcache_autocreate_pool(xh->client_id, xh->pool_id, ephemeral);\r\nlocal_irq_save(flags);\r\nret = zcache_put_page(xh->client_id, xh->pool_id, &xh->oid, xh->index,\r\np, datalen, true, ephemeral);\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nint ramster_remote_flush_handler(struct r2net_msg *msg,\r\nu32 len, void *data, void **ret_data)\r\n{\r\nstruct tmem_xhandle *xh;\r\nchar *p = (char *)msg->buf;\r\nxh = (struct tmem_xhandle *)p;\r\np += sizeof(struct tmem_xhandle);\r\n(void)zcache_flush_page(xh->client_id, xh->pool_id,\r\n&xh->oid, xh->index);\r\nreturn 0;\r\n}\r\nint ramster_remote_flobj_handler(struct r2net_msg *msg,\r\nu32 len, void *data, void **ret_data)\r\n{\r\nstruct tmem_xhandle *xh;\r\nchar *p = (char *)msg->buf;\r\nxh = (struct tmem_xhandle *)p;\r\np += sizeof(struct tmem_xhandle);\r\n(void)zcache_flush_object(xh->client_id, xh->pool_id, &xh->oid);\r\nreturn 0;\r\n}\r\nint r2net_remote_async_get(struct tmem_xhandle *xh, bool free, int remotenode,\r\nsize_t expect_size, uint8_t expect_cksum,\r\nvoid *extra)\r\n{\r\nint nodenum, ret = -1, status;\r\nstruct r2nm_node *node = NULL;\r\nstruct kvec vec[1];\r\nsize_t veclen = 1;\r\nu32 msg_type;\r\nstruct r2net_node *nn;\r\nnode = r2nm_get_node_by_num(remotenode);\r\nif (node == NULL)\r\ngoto out;\r\nxh->client_id = r2nm_this_node();\r\nxh->xh_data_cksum = expect_cksum;\r\nxh->xh_data_size = expect_size;\r\nxh->extra = extra;\r\nvec[0].iov_len = sizeof(*xh);\r\nvec[0].iov_base = xh;\r\nnode = r2net_target_node;\r\nif (!node)\r\ngoto out;\r\nnodenum = r2net_target_nodenum;\r\nr2nm_node_get(node);\r\nnn = r2net_nn_from_num(nodenum);\r\nif (nn->nn_persistent_error || !nn->nn_sc_valid) {\r\nret = -ENOTCONN;\r\nr2nm_node_put(node);\r\ngoto out;\r\n}\r\nif (free)\r\nmsg_type = RMSTR_TMEM_ASYNC_GET_AND_FREE_REQUEST;\r\nelse\r\nmsg_type = RMSTR_TMEM_ASYNC_GET_REQUEST;\r\nret = r2net_send_message_vec(msg_type, RMSTR_KEY,\r\nvec, veclen, remotenode, &status);\r\nr2nm_node_put(node);\r\nif (ret < 0) {\r\nif (ret == -ENOTCONN || ret == -EHOSTDOWN)\r\ngoto out;\r\nif (ret == -EAGAIN)\r\ngoto out;\r\npr_err("UNTESTED ret<0 in ramster_remote_async_get: ret=%d\n",\r\nret);\r\n}\r\nret = status;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ramster_check_irq_counts(void)\r\n{\r\nstatic int last_hardirq_cnt, last_softirq_cnt, last_preempt_cnt;\r\nint cur_hardirq_cnt, cur_softirq_cnt, cur_preempt_cnt;\r\ncur_hardirq_cnt = hardirq_count() >> HARDIRQ_SHIFT;\r\nif (cur_hardirq_cnt > last_hardirq_cnt) {\r\nlast_hardirq_cnt = cur_hardirq_cnt;\r\nif (!(last_hardirq_cnt&(last_hardirq_cnt-1)))\r\npr_err("RAMSTER TESTING RRP hardirq_count=%d\n",\r\nlast_hardirq_cnt);\r\n}\r\ncur_softirq_cnt = softirq_count() >> SOFTIRQ_SHIFT;\r\nif (cur_softirq_cnt > last_softirq_cnt) {\r\nlast_softirq_cnt = cur_softirq_cnt;\r\nif (!(last_softirq_cnt&(last_softirq_cnt-1)))\r\npr_err("RAMSTER TESTING RRP softirq_count=%d\n",\r\nlast_softirq_cnt);\r\n}\r\ncur_preempt_cnt = preempt_count() & PREEMPT_MASK;\r\nif (cur_preempt_cnt > last_preempt_cnt) {\r\nlast_preempt_cnt = cur_preempt_cnt;\r\nif (!(last_preempt_cnt&(last_preempt_cnt-1)))\r\npr_err("RAMSTER TESTING RRP preempt_count=%d\n",\r\nlast_preempt_cnt);\r\n}\r\n}\r\nint r2net_remote_put(struct tmem_xhandle *xh, char *data, size_t size,\r\nbool ephemeral, int *remotenode)\r\n{\r\nint nodenum, ret = -1, status;\r\nstruct r2nm_node *node = NULL;\r\nstruct kvec vec[2];\r\nsize_t veclen = 2;\r\nu32 msg_type;\r\nstruct r2net_node *nn;\r\nBUG_ON(size > RMSTR_R2NET_MAX_LEN);\r\nxh->client_id = r2nm_this_node();\r\nvec[0].iov_len = sizeof(*xh);\r\nvec[0].iov_base = xh;\r\nvec[1].iov_len = size;\r\nvec[1].iov_base = data;\r\nnode = r2net_target_node;\r\nif (!node)\r\ngoto out;\r\nnodenum = r2net_target_nodenum;\r\nr2nm_node_get(node);\r\nnn = r2net_nn_from_num(nodenum);\r\nif (nn->nn_persistent_error || !nn->nn_sc_valid) {\r\nret = -ENOTCONN;\r\nr2nm_node_put(node);\r\ngoto out;\r\n}\r\nif (ephemeral)\r\nmsg_type = RMSTR_TMEM_PUT_EPH;\r\nelse\r\nmsg_type = RMSTR_TMEM_PUT_PERS;\r\n#ifdef RAMSTER_TESTING\r\nramster_check_irq_counts();\r\n#endif\r\nret = r2net_send_message_vec(msg_type, RMSTR_KEY, vec, veclen,\r\nnodenum, &status);\r\nif (ret < 0)\r\nret = -1;\r\nelse {\r\nret = status;\r\n*remotenode = nodenum;\r\n}\r\nr2nm_node_put(node);\r\nout:\r\nreturn ret;\r\n}\r\nint r2net_remote_flush(struct tmem_xhandle *xh, int remotenode)\r\n{\r\nint ret = -1, status;\r\nstruct r2nm_node *node = NULL;\r\nstruct kvec vec[1];\r\nsize_t veclen = 1;\r\nnode = r2nm_get_node_by_num(remotenode);\r\nBUG_ON(node == NULL);\r\nxh->client_id = r2nm_this_node();\r\nvec[0].iov_len = sizeof(*xh);\r\nvec[0].iov_base = xh;\r\nBUG_ON(irqs_disabled());\r\nBUG_ON(in_softirq());\r\nret = r2net_send_message_vec(RMSTR_TMEM_FLUSH, RMSTR_KEY,\r\nvec, veclen, remotenode, &status);\r\nr2nm_node_put(node);\r\nreturn ret;\r\n}\r\nint r2net_remote_flush_object(struct tmem_xhandle *xh, int remotenode)\r\n{\r\nint ret = -1, status;\r\nstruct r2nm_node *node = NULL;\r\nstruct kvec vec[1];\r\nsize_t veclen = 1;\r\nnode = r2nm_get_node_by_num(remotenode);\r\nBUG_ON(node == NULL);\r\nxh->client_id = r2nm_this_node();\r\nvec[0].iov_len = sizeof(*xh);\r\nvec[0].iov_base = xh;\r\nret = r2net_send_message_vec(RMSTR_TMEM_FLOBJ, RMSTR_KEY,\r\nvec, veclen, remotenode, &status);\r\nr2nm_node_put(node);\r\nreturn ret;\r\n}\r\nstatic void r2net_unregister_handlers(void)\r\n{\r\nr2net_unregister_handler_list(&r2net_unreg_list);\r\n}\r\nint r2net_register_handlers(void)\r\n{\r\nint status;\r\nstatus = r2net_register_handler(RMSTR_TMEM_PUT_EPH, RMSTR_KEY,\r\nRMSTR_R2NET_MAX_LEN,\r\nramster_remote_put_handler,\r\nNULL, NULL, &r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\nstatus = r2net_register_handler(RMSTR_TMEM_PUT_PERS, RMSTR_KEY,\r\nRMSTR_R2NET_MAX_LEN,\r\nramster_remote_put_handler,\r\nNULL, NULL, &r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\nstatus = r2net_register_handler(RMSTR_TMEM_ASYNC_GET_REQUEST, RMSTR_KEY,\r\nRMSTR_R2NET_MAX_LEN,\r\nramster_remote_async_get_request_handler,\r\nNULL, NULL,\r\n&r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\nstatus = r2net_register_handler(RMSTR_TMEM_ASYNC_GET_AND_FREE_REQUEST,\r\nRMSTR_KEY, RMSTR_R2NET_MAX_LEN,\r\nramster_remote_async_get_request_handler,\r\nNULL, NULL,\r\n&r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\nstatus = r2net_register_handler(RMSTR_TMEM_ASYNC_GET_REPLY, RMSTR_KEY,\r\nRMSTR_R2NET_MAX_LEN,\r\nramster_remote_async_get_reply_handler,\r\nNULL, NULL,\r\n&r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\nstatus = r2net_register_handler(RMSTR_TMEM_FLUSH, RMSTR_KEY,\r\nRMSTR_R2NET_MAX_LEN,\r\nramster_remote_flush_handler,\r\nNULL, NULL,\r\n&r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\nstatus = r2net_register_handler(RMSTR_TMEM_FLOBJ, RMSTR_KEY,\r\nRMSTR_R2NET_MAX_LEN,\r\nramster_remote_flobj_handler,\r\nNULL, NULL,\r\n&r2net_unreg_list);\r\nif (status)\r\ngoto bail;\r\npr_info("ramster: r2net handlers registered\n");\r\nbail:\r\nif (status) {\r\nr2net_unregister_handlers();\r\npr_err("ramster: couldn't register r2net handlers\n");\r\n}\r\nreturn status;\r\n}
