static int mixart_wait_nice_for_register_value(struct mixart_mgr *mgr,\r\nu32 offset, int is_egal,\r\nu32 value, unsigned long timeout)\r\n{\r\nunsigned long end_time = jiffies + (timeout * HZ / 100);\r\nu32 read;\r\ndo {\r\ncond_resched();\r\nread = readl_be( MIXART_MEM( mgr, offset ));\r\nif(is_egal) {\r\nif(read == value) return 0;\r\n}\r\nelse {\r\nif(read != value) return 0;\r\n}\r\n} while ( time_after_eq(end_time, jiffies) );\r\nreturn -EBUSY;\r\n}\r\nstatic int mixart_load_elf(struct mixart_mgr *mgr, const struct firmware *dsp )\r\n{\r\nchar elf32_magic_number[4] = {0x7f,'E','L','F'};\r\nstruct snd_mixart_elf32_ehdr *elf_header;\r\nint i;\r\nelf_header = (struct snd_mixart_elf32_ehdr *)dsp->data;\r\nfor( i=0; i<4; i++ )\r\nif ( elf32_magic_number[i] != elf_header->e_ident[i] )\r\nreturn -EINVAL;\r\nif( elf_header->e_phoff != 0 ) {\r\nstruct snd_mixart_elf32_phdr elf_programheader;\r\nfor( i=0; i < be16_to_cpu(elf_header->e_phnum); i++ ) {\r\nu32 pos = be32_to_cpu(elf_header->e_phoff) + (u32)(i * be16_to_cpu(elf_header->e_phentsize));\r\nmemcpy( &elf_programheader, dsp->data + pos, sizeof(elf_programheader) );\r\nif(elf_programheader.p_type != 0) {\r\nif( elf_programheader.p_filesz != 0 ) {\r\nmemcpy_toio( MIXART_MEM( mgr, be32_to_cpu(elf_programheader.p_vaddr)),\r\ndsp->data + be32_to_cpu( elf_programheader.p_offset ),\r\nbe32_to_cpu( elf_programheader.p_filesz ));\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_enum_connectors(struct mixart_mgr *mgr)\r\n{\r\nu32 k;\r\nint err;\r\nstruct mixart_msg request;\r\nstruct mixart_enum_connector_resp *connector;\r\nstruct mixart_audio_info_req *audio_info_req;\r\nstruct mixart_audio_info_resp *audio_info;\r\nconnector = kmalloc(sizeof(*connector), GFP_KERNEL);\r\naudio_info_req = kmalloc(sizeof(*audio_info_req), GFP_KERNEL);\r\naudio_info = kmalloc(sizeof(*audio_info), GFP_KERNEL);\r\nif (! connector || ! audio_info_req || ! audio_info) {\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\naudio_info_req->line_max_level = MIXART_FLOAT_P_22_0_TO_HEX;\r\naudio_info_req->micro_max_level = MIXART_FLOAT_M_20_0_TO_HEX;\r\naudio_info_req->cd_max_level = MIXART_FLOAT____0_0_TO_HEX;\r\nrequest.message_id = MSG_SYSTEM_ENUM_PLAY_CONNECTOR;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = NULL;\r\nrequest.size = 0;\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(*connector), connector);\r\nif((err < 0) || (connector->error_code) || (connector->uid_count > MIXART_MAX_PHYS_CONNECTORS)) {\r\nsnd_printk(KERN_ERR "error MSG_SYSTEM_ENUM_PLAY_CONNECTOR\n");\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nfor(k=0; k < connector->uid_count; k++) {\r\nstruct mixart_pipe *pipe;\r\nif(k < MIXART_FIRST_DIG_AUDIO_ID) {\r\npipe = &mgr->chip[k/2]->pipe_out_ana;\r\n} else {\r\npipe = &mgr->chip[(k-MIXART_FIRST_DIG_AUDIO_ID)/2]->pipe_out_dig;\r\n}\r\nif(k & 1) {\r\npipe->uid_right_connector = connector->uid[k];\r\n} else {\r\npipe->uid_left_connector = connector->uid[k];\r\n}\r\nrequest.message_id = MSG_CONNECTOR_GET_AUDIO_INFO;\r\nrequest.uid = connector->uid[k];\r\nrequest.data = audio_info_req;\r\nrequest.size = sizeof(*audio_info_req);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(*audio_info), audio_info);\r\nif( err < 0 ) {\r\nsnd_printk(KERN_ERR "error MSG_CONNECTOR_GET_AUDIO_INFO\n");\r\ngoto __error;\r\n}\r\n}\r\nrequest.message_id = MSG_SYSTEM_ENUM_RECORD_CONNECTOR;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = NULL;\r\nrequest.size = 0;\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(*connector), connector);\r\nif((err < 0) || (connector->error_code) || (connector->uid_count > MIXART_MAX_PHYS_CONNECTORS)) {\r\nsnd_printk(KERN_ERR "error MSG_SYSTEM_ENUM_RECORD_CONNECTOR\n");\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nfor(k=0; k < connector->uid_count; k++) {\r\nstruct mixart_pipe *pipe;\r\nif(k < MIXART_FIRST_DIG_AUDIO_ID) {\r\npipe = &mgr->chip[k/2]->pipe_in_ana;\r\n} else {\r\npipe = &mgr->chip[(k-MIXART_FIRST_DIG_AUDIO_ID)/2]->pipe_in_dig;\r\n}\r\nif(k & 1) {\r\npipe->uid_right_connector = connector->uid[k];\r\n} else {\r\npipe->uid_left_connector = connector->uid[k];\r\n}\r\nrequest.message_id = MSG_CONNECTOR_GET_AUDIO_INFO;\r\nrequest.uid = connector->uid[k];\r\nrequest.data = audio_info_req;\r\nrequest.size = sizeof(*audio_info_req);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(*audio_info), audio_info);\r\nif( err < 0 ) {\r\nsnd_printk(KERN_ERR "error MSG_CONNECTOR_GET_AUDIO_INFO\n");\r\ngoto __error;\r\n}\r\n}\r\nerr = 0;\r\n__error:\r\nkfree(connector);\r\nkfree(audio_info_req);\r\nkfree(audio_info);\r\nreturn err;\r\n}\r\nstatic int mixart_enum_physio(struct mixart_mgr *mgr)\r\n{\r\nu32 k;\r\nint err;\r\nstruct mixart_msg request;\r\nstruct mixart_uid get_console_mgr;\r\nstruct mixart_return_uid console_mgr;\r\nstruct mixart_uid_enumeration phys_io;\r\nget_console_mgr.object_id = 0;\r\nget_console_mgr.desc = MSG_CONSOLE_MANAGER | 0;\r\nrequest.message_id = MSG_CONSOLE_GET_CLOCK_UID;\r\nrequest.uid = get_console_mgr;\r\nrequest.data = &get_console_mgr;\r\nrequest.size = sizeof(get_console_mgr);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(console_mgr), &console_mgr);\r\nif( (err < 0) || (console_mgr.error_code != 0) ) {\r\nsnd_printk(KERN_DEBUG "error MSG_CONSOLE_GET_CLOCK_UID : err=%x\n", console_mgr.error_code);\r\nreturn -EINVAL;\r\n}\r\nmgr->uid_console_manager = console_mgr.uid;\r\nrequest.message_id = MSG_SYSTEM_ENUM_PHYSICAL_IO;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = &console_mgr.uid;\r\nrequest.size = sizeof(console_mgr.uid);\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(phys_io), &phys_io);\r\nif( (err < 0) || ( phys_io.error_code != 0 ) ) {\r\nsnd_printk(KERN_ERR "error MSG_SYSTEM_ENUM_PHYSICAL_IO err(%x) error_code(%x)\n", err, phys_io.error_code );\r\nreturn -EINVAL;\r\n}\r\nif (phys_io.nb_uid < MIXART_MAX_CARDS * 2)\r\nreturn -EINVAL;\r\nfor(k=0; k<mgr->num_cards; k++) {\r\nmgr->chip[k]->uid_in_analog_physio = phys_io.uid[k];\r\nmgr->chip[k]->uid_out_analog_physio = phys_io.uid[phys_io.nb_uid/2 + k];\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_first_init(struct mixart_mgr *mgr)\r\n{\r\nu32 k;\r\nint err;\r\nstruct mixart_msg request;\r\nif((err = mixart_enum_connectors(mgr)) < 0) return err;\r\nif((err = mixart_enum_physio(mgr)) < 0) return err;\r\nrequest.message_id = MSG_SYSTEM_SEND_SYNCHRO_CMD;\r\nrequest.uid = (struct mixart_uid){0,0};\r\nrequest.data = NULL;\r\nrequest.size = 0;\r\nerr = snd_mixart_send_msg(mgr, &request, sizeof(k), &k);\r\nif( (err < 0) || (k != 0) ) {\r\nsnd_printk(KERN_ERR "error MSG_SYSTEM_SEND_SYNCHRO_CMD\n");\r\nreturn err == 0 ? -EINVAL : err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixart_dsp_load(struct mixart_mgr* mgr, int index, const struct firmware *dsp)\r\n{\r\nint err, card_index;\r\nu32 status_xilinx, status_elf, status_daught;\r\nu32 val;\r\nstatus_xilinx = readl_be( MIXART_MEM( mgr,MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));\r\nstatus_elf = readl_be( MIXART_MEM( mgr,MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));\r\nstatus_daught = readl_be( MIXART_MEM( mgr,MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));\r\nif (status_xilinx == 5) {\r\nsnd_printk(KERN_ERR "miXart is resetting !\n");\r\nreturn -EAGAIN;\r\n}\r\nswitch (index) {\r\ncase MIXART_MOTHERBOARD_XLX_INDEX:\r\nif (status_xilinx == 4) {\r\nsnd_printk(KERN_DEBUG "xilinx is already loaded !\n");\r\nreturn 0;\r\n}\r\nif (status_xilinx != 0) {\r\nsnd_printk(KERN_ERR "xilinx load error ! status = %d\n",\r\nstatus_xilinx);\r\nreturn -EIO;\r\n}\r\nif (((u32*)(dsp->data))[0] == 0xffffffff)\r\nreturn -EINVAL;\r\nif (dsp->size % 4)\r\nreturn -EINVAL;\r\nwritel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));\r\nwritel_be( MIXART_MOTHERBOARD_XLX_BASE_ADDRESS, MIXART_MEM( mgr,MIXART_PSEUDOREG_MXLX_BASE_ADDR_OFFSET ));\r\nwritel_be( dsp->size, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_SIZE_OFFSET ));\r\nmemcpy_toio( MIXART_MEM( mgr, MIXART_MOTHERBOARD_XLX_BASE_ADDRESS), dsp->data, dsp->size);\r\nwritel_be( 2, MIXART_MEM( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET ));\r\nreturn 0;\r\ncase MIXART_MOTHERBOARD_ELF_INDEX:\r\nif (status_elf == 4) {\r\nsnd_printk(KERN_DEBUG "elf file already loaded !\n");\r\nreturn 0;\r\n}\r\nif (status_elf != 0) {\r\nsnd_printk(KERN_ERR "elf load error ! status = %d\n",\r\nstatus_elf);\r\nreturn -EIO;\r\n}\r\nerr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_MXLX_STATUS_OFFSET, 1, 4, 500);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "xilinx was not loaded or "\r\n"could not be started\n");\r\nreturn err;\r\n}\r\nwritel_be( 0, MIXART_MEM( mgr, MIXART_PSEUDOREG_BOARDNUMBER ) );\r\nwritel_be( 0, MIXART_MEM( mgr, MIXART_FLOWTABLE_PTR ) );\r\nwritel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));\r\nerr = mixart_load_elf( mgr, dsp );\r\nif (err < 0) return err;\r\nwritel_be( 2, MIXART_MEM( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET ));\r\nerr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_ELF_STATUS_OFFSET, 1, 4, 300);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "elf could not be started\n");\r\nreturn err;\r\n}\r\nwritel_be( (u32)mgr->flowinfo.addr, MIXART_MEM( mgr, MIXART_FLOWTABLE_PTR ) );\r\nreturn 0;\r\ncase MIXART_AESEBUBOARD_XLX_INDEX:\r\ndefault:\r\nif (status_elf != 4 || status_xilinx != 4) {\r\nprintk(KERN_ERR "xilinx or elf not "\r\n"successfully loaded\n");\r\nreturn -EIO;\r\n}\r\nerr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_DBRD_PRESENCE_OFFSET, 0, 0, 30);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "error starting elf file\n");\r\nreturn err;\r\n}\r\nmgr->board_type = (DAUGHTER_TYPE_MASK & readl_be( MIXART_MEM( mgr, MIXART_PSEUDOREG_DBRD_TYPE_OFFSET)));\r\nif (mgr->board_type == MIXART_DAUGHTER_TYPE_NONE)\r\nbreak;\r\nif (mgr->board_type != MIXART_DAUGHTER_TYPE_AES )\r\nreturn -EINVAL;\r\nif (status_daught != 0) {\r\nprintk(KERN_ERR "daughter load error ! status = %d\n",\r\nstatus_daught);\r\nreturn -EIO;\r\n}\r\nif (((u32*)(dsp->data))[0] == 0xffffffff)\r\nreturn -EINVAL;\r\nif (dsp->size % 4)\r\nreturn -EINVAL;\r\nwritel_be( dsp->size, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_SIZE_OFFSET ));\r\nwritel_be( 1, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));\r\nerr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET, 1, 2, 30);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "daughter board load error\n");\r\nreturn err;\r\n}\r\nval = readl_be( MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_BASE_ADDR_OFFSET ));\r\nif (!val)\r\nreturn -EINVAL;\r\nmemcpy_toio( MIXART_MEM( mgr, val), dsp->data, dsp->size);\r\nwritel_be( 4, MIXART_MEM( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET ));\r\nbreak;\r\n}\r\nerr = mixart_wait_nice_for_register_value( mgr, MIXART_PSEUDOREG_DXLX_STATUS_OFFSET, 1, 3, 300);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR\r\n"daughter board could not be initialised\n");\r\nreturn err;\r\n}\r\nsnd_mixart_init_mailbox(mgr);\r\nerr = mixart_first_init(mgr);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "miXart could not be set up\n");\r\nreturn err;\r\n}\r\nfor (card_index = 0; card_index < mgr->num_cards; card_index++) {\r\nstruct snd_mixart *chip = mgr->chip[card_index];\r\nif ((err = snd_mixart_create_pcm(chip)) < 0)\r\nreturn err;\r\nif (card_index == 0) {\r\nif ((err = snd_mixart_create_mixer(chip->mgr)) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_card_register(chip->card)) < 0)\r\nreturn err;\r\n}\r\nsnd_printdd("miXart firmware downloaded and successfully set up\n");\r\nreturn 0;\r\n}\r\nint snd_mixart_setup_firmware(struct mixart_mgr *mgr)\r\n{\r\nstatic char *fw_files[3] = {\r\n"miXart8.xlx", "miXart8.elf", "miXart8AES.xlx"\r\n};\r\nchar path[32];\r\nconst struct firmware *fw_entry;\r\nint i, err;\r\nfor (i = 0; i < 3; i++) {\r\nsprintf(path, "mixart/%s", fw_files[i]);\r\nif (request_firmware(&fw_entry, path, &mgr->pci->dev)) {\r\nsnd_printk(KERN_ERR "miXart: can't load firmware %s\n", path);\r\nreturn -ENOENT;\r\n}\r\nerr = mixart_dsp_load(mgr, i, fw_entry);\r\nrelease_firmware(fw_entry);\r\nif (err < 0)\r\nreturn err;\r\nmgr->dsp_loaded |= 1 << i;\r\n}\r\nreturn 0;\r\n}
