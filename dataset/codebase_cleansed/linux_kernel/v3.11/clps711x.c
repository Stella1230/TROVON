static void uart_clps711x_stop_tx(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nif (s->tx_enabled[port->line]) {\r\ndisable_irq(TX_IRQ(port));\r\ns->tx_enabled[port->line] = 0;\r\n}\r\n}\r\nstatic void uart_clps711x_start_tx(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nif (!s->tx_enabled[port->line]) {\r\nenable_irq(TX_IRQ(port));\r\ns->tx_enabled[port->line] = 1;\r\n}\r\n}\r\nstatic void uart_clps711x_stop_rx(struct uart_port *port)\r\n{\r\ndisable_irq(RX_IRQ(port));\r\n}\r\nstatic void uart_clps711x_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic irqreturn_t uart_clps711x_int_rx(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned int status, ch, flg;\r\nfor (;;) {\r\nstatus = clps_readl(SYSFLG(port));\r\nif (status & SYSFLG_URXFE)\r\nbreak;\r\nch = clps_readw(UARTDR(port));\r\nstatus = ch & (UARTDR_FRMERR | UARTDR_PARERR | UARTDR_OVERR);\r\nch &= 0xff;\r\nport->icount.rx++;\r\nflg = TTY_NORMAL;\r\nif (unlikely(status)) {\r\nif (status & UARTDR_PARERR)\r\nport->icount.parity++;\r\nelse if (status & UARTDR_FRMERR)\r\nport->icount.frame++;\r\nelse if (status & UARTDR_OVERR)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & UARTDR_PARERR)\r\nflg = TTY_PARITY;\r\nelse if (status & UARTDR_FRMERR)\r\nflg = TTY_FRAME;\r\nelse if (status & UARTDR_OVERR)\r\nflg = TTY_OVERRUN;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nif (status & port->ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(port, status, UARTDR_OVERR, ch, flg);\r\n}\r\ntty_flip_buffer_push(&port->state->port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t uart_clps711x_int_tx(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nclps_writew(port->x_char, UARTDR(port));\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\ndisable_irq_nosync(TX_IRQ(port));\r\ns->tx_enabled[port->line] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nwhile (!uart_circ_empty(xmit)) {\r\nclps_writew(xmit->buf[xmit->tail], UARTDR(port));\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (clps_readl(SYSFLG(port) & SYSFLG_UTXFF))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int uart_clps711x_tx_empty(struct uart_port *port)\r\n{\r\nreturn (clps_readl(SYSFLG(port) & SYSFLG_UBUSY)) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int uart_clps711x_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int status, result = 0;\r\nif (port->line == 0) {\r\nstatus = clps_readl(SYSFLG1);\r\nif (status & SYSFLG1_DCD)\r\nresult |= TIOCM_CAR;\r\nif (status & SYSFLG1_DSR)\r\nresult |= TIOCM_DSR;\r\nif (status & SYSFLG1_CTS)\r\nresult |= TIOCM_CTS;\r\n} else\r\nresult = TIOCM_DSR | TIOCM_CTS | TIOCM_CAR;\r\nreturn result;\r\n}\r\nstatic void uart_clps711x_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void uart_clps711x_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long flags;\r\nunsigned int ubrlcr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nubrlcr = clps_readl(UBRLCR(port));\r\nif (break_state)\r\nubrlcr |= UBRLCR_BREAK;\r\nelse\r\nubrlcr &= ~UBRLCR_BREAK;\r\nclps_writel(ubrlcr, UBRLCR(port));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int uart_clps711x_startup(struct uart_port *port)\r\n{\r\nstruct clps711x_port *s = dev_get_drvdata(port->dev);\r\nint ret;\r\ns->tx_enabled[port->line] = 1;\r\nret = devm_request_irq(port->dev, TX_IRQ(port), uart_clps711x_int_tx,\r\n0, UART_CLPS711X_NAME " TX", port);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_irq(port->dev, RX_IRQ(port), uart_clps711x_int_rx,\r\n0, UART_CLPS711X_NAME " RX", port);\r\nif (ret) {\r\ndevm_free_irq(port->dev, TX_IRQ(port), port);\r\nreturn ret;\r\n}\r\nclps_writel(clps_readl(UBRLCR(port)) & ~UBRLCR_BREAK, UBRLCR(port));\r\nclps_writel(clps_readl(SYSCON(port)) | SYSCON_UARTEN, SYSCON(port));\r\nreturn 0;\r\n}\r\nstatic void uart_clps711x_shutdown(struct uart_port *port)\r\n{\r\ndevm_free_irq(port->dev, TX_IRQ(port), port);\r\ndevm_free_irq(port->dev, RX_IRQ(port), port);\r\nclps_writel(clps_readl(SYSCON(port)) & ~SYSCON_UARTEN, SYSCON(port));\r\n}\r\nstatic void uart_clps711x_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int ubrlcr, baud, quot;\r\nunsigned long flags;\r\ntermios->c_cflag &= ~CMSPAR;\r\ntermios->c_iflag &= ~(BRKINT | IGNBRK);\r\nbaud = uart_get_baud_rate(port, termios, old, port->uartclk / 4096,\r\nport->uartclk / 16);\r\nquot = uart_get_divisor(port, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nubrlcr = UBRLCR_WRDLEN5;\r\nbreak;\r\ncase CS6:\r\nubrlcr = UBRLCR_WRDLEN6;\r\nbreak;\r\ncase CS7:\r\nubrlcr = UBRLCR_WRDLEN7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nubrlcr = UBRLCR_WRDLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nubrlcr |= UBRLCR_XSTOP;\r\nif (termios->c_cflag & PARENB) {\r\nubrlcr |= UBRLCR_PRTEN;\r\nif (!(termios->c_cflag & PARODD))\r\nubrlcr |= UBRLCR_EVENPRT;\r\n}\r\nubrlcr |= UBRLCR_FIFOEN;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = UARTDR_OVERR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UARTDR_PARERR | UARTDR_FRMERR;\r\nport->ignore_status_mask = 0;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= UARTDR_OVERR | UARTDR_PARERR |\r\nUARTDR_FRMERR;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nclps_writel(ubrlcr | (quot - 1), UBRLCR(port));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *uart_clps711x_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_CLPS711X) ? "CLPS711X" : NULL;\r\n}\r\nstatic void uart_clps711x_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_CLPS711X;\r\n}\r\nstatic void uart_clps711x_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int uart_clps711x_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void uart_clps711x_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (clps_readl(SYSFLG(port)) & SYSFLG_UTXFF)\r\nbarrier();\r\nclps_writew(ch, UARTDR(port));\r\n}\r\nstatic void uart_clps711x_console_write(struct console *co, const char *c,\r\nunsigned n)\r\n{\r\nstruct clps711x_port *s = (struct clps711x_port *)co->data;\r\nstruct uart_port *port = &s->port[co->index];\r\nu32 syscon;\r\nsyscon = clps_readl(SYSCON(port));\r\nclps_writel(syscon | SYSCON_UARTEN, SYSCON(port));\r\nuart_console_write(port, c, n, uart_clps711x_console_putchar);\r\nwhile (clps_readl(SYSFLG(port)) & SYSFLG_UBUSY)\r\nbarrier();\r\nclps_writel(syscon, SYSCON(port));\r\n}\r\nstatic void uart_clps711x_console_get_options(struct uart_port *port,\r\nint *baud, int *parity,\r\nint *bits)\r\n{\r\nif (clps_readl(SYSCON(port)) & SYSCON_UARTEN) {\r\nunsigned int ubrlcr, quot;\r\nubrlcr = clps_readl(UBRLCR(port));\r\n*parity = 'n';\r\nif (ubrlcr & UBRLCR_PRTEN) {\r\nif (ubrlcr & UBRLCR_EVENPRT)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif ((ubrlcr & UBRLCR_WRDLEN_MASK) == UBRLCR_WRDLEN7)\r\n*bits = 7;\r\nelse\r\n*bits = 8;\r\nquot = ubrlcr & UBRLCR_BAUD_MASK;\r\n*baud = port->uartclk / (16 * (quot + 1));\r\n}\r\n}\r\nstatic int uart_clps711x_console_setup(struct console *co, char *options)\r\n{\r\nint baud = 38400, bits = 8, parity = 'n', flow = 'n';\r\nstruct clps711x_port *s = (struct clps711x_port *)co->data;\r\nstruct uart_port *port = &s->port[(co->index > 0) ? co->index : 0];\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nuart_clps711x_console_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int uart_clps711x_probe(struct platform_device *pdev)\r\n{\r\nstruct clps711x_port *s;\r\nint ret, i;\r\ns = devm_kzalloc(&pdev->dev, sizeof(struct clps711x_port), GFP_KERNEL);\r\nif (!s) {\r\ndev_err(&pdev->dev, "Error allocating port structure\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, s);\r\ns->uart_clk = devm_clk_get(&pdev->dev, "uart");\r\nif (IS_ERR(s->uart_clk)) {\r\ndev_err(&pdev->dev, "Can't get UART clocks\n");\r\nret = PTR_ERR(s->uart_clk);\r\ngoto err_out;\r\n}\r\ns->uart.owner = THIS_MODULE;\r\ns->uart.dev_name = "ttyCL";\r\ns->uart.major = UART_CLPS711X_MAJOR;\r\ns->uart.minor = UART_CLPS711X_MINOR;\r\ns->uart.nr = UART_CLPS711X_NR;\r\n#ifdef CONFIG_SERIAL_CLPS711X_CONSOLE\r\ns->uart.cons = &s->console;\r\ns->uart.cons->device = uart_console_device;\r\ns->uart.cons->write = uart_clps711x_console_write;\r\ns->uart.cons->setup = uart_clps711x_console_setup;\r\ns->uart.cons->flags = CON_PRINTBUFFER;\r\ns->uart.cons->index = -1;\r\ns->uart.cons->data = s;\r\nstrcpy(s->uart.cons->name, "ttyCL");\r\n#endif\r\nret = uart_register_driver(&s->uart);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Registering UART driver failed\n");\r\ndevm_clk_put(&pdev->dev, s->uart_clk);\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < UART_CLPS711X_NR; i++) {\r\ns->port[i].line = i;\r\ns->port[i].dev = &pdev->dev;\r\ns->port[i].irq = TX_IRQ(&s->port[i]);\r\ns->port[i].iobase = SYSCON(&s->port[i]);\r\ns->port[i].type = PORT_CLPS711X;\r\ns->port[i].fifosize = 16;\r\ns->port[i].flags = UPF_SKIP_TEST | UPF_FIXED_TYPE;\r\ns->port[i].uartclk = clk_get_rate(s->uart_clk);\r\ns->port[i].ops = &uart_clps711x_ops;\r\nWARN_ON(uart_add_one_port(&s->uart, &s->port[i]));\r\n}\r\nreturn 0;\r\nerr_out:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int uart_clps711x_remove(struct platform_device *pdev)\r\n{\r\nstruct clps711x_port *s = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < UART_CLPS711X_NR; i++)\r\nuart_remove_one_port(&s->uart, &s->port[i]);\r\ndevm_clk_put(&pdev->dev, s->uart_clk);\r\nuart_unregister_driver(&s->uart);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init uart_clps711x_init(void)\r\n{\r\nreturn platform_device_register(&clps711x_uart_device);\r\n}\r\nstatic void __exit uart_clps711x_exit(void)\r\n{\r\nplatform_device_unregister(&clps711x_uart_device);\r\n}
