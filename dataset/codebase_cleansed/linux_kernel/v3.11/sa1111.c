static void\r\nsa1111_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned int stat0, stat1, i;\r\nstruct sa1111 *sachip = irq_get_handler_data(irq);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nstat0 = sa1111_readl(mapbase + SA1111_INTSTATCLR0);\r\nstat1 = sa1111_readl(mapbase + SA1111_INTSTATCLR1);\r\nsa1111_writel(stat0, mapbase + SA1111_INTSTATCLR0);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nsa1111_writel(stat1, mapbase + SA1111_INTSTATCLR1);\r\nif (stat0 == 0 && stat1 == 0) {\r\ndo_bad_IRQ(irq, desc);\r\nreturn;\r\n}\r\nfor (i = 0; stat0; i++, stat0 >>= 1)\r\nif (stat0 & 1)\r\ngeneric_handle_irq(i + sachip->irq_base);\r\nfor (i = 32; stat1; i++, stat1 >>= 1)\r\nif (stat1 & 1)\r\ngeneric_handle_irq(i + sachip->irq_base);\r\ndesc->irq_data.chip->irq_unmask(&desc->irq_data);\r\n}\r\nstatic void sa1111_ack_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void sa1111_mask_lowirq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned long ie0;\r\nie0 = sa1111_readl(mapbase + SA1111_INTEN0);\r\nie0 &= ~SA1111_IRQMASK_LO(d->irq);\r\nwritel(ie0, mapbase + SA1111_INTEN0);\r\n}\r\nstatic void sa1111_unmask_lowirq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned long ie0;\r\nie0 = sa1111_readl(mapbase + SA1111_INTEN0);\r\nie0 |= SA1111_IRQMASK_LO(d->irq);\r\nsa1111_writel(ie0, mapbase + SA1111_INTEN0);\r\n}\r\nstatic int sa1111_retrigger_lowirq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned int mask = SA1111_IRQMASK_LO(d->irq);\r\nunsigned long ip0;\r\nint i;\r\nip0 = sa1111_readl(mapbase + SA1111_INTPOL0);\r\nfor (i = 0; i < 8; i++) {\r\nsa1111_writel(ip0 ^ mask, mapbase + SA1111_INTPOL0);\r\nsa1111_writel(ip0, mapbase + SA1111_INTPOL0);\r\nif (sa1111_readl(mapbase + SA1111_INTSTATCLR0) & mask)\r\nbreak;\r\n}\r\nif (i == 8)\r\nprintk(KERN_ERR "Danger Will Robinson: failed to "\r\n"re-trigger IRQ%d\n", d->irq);\r\nreturn i == 8 ? -1 : 0;\r\n}\r\nstatic int sa1111_type_lowirq(struct irq_data *d, unsigned int flags)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned int mask = SA1111_IRQMASK_LO(d->irq);\r\nunsigned long ip0;\r\nif (flags == IRQ_TYPE_PROBE)\r\nreturn 0;\r\nif ((!(flags & IRQ_TYPE_EDGE_RISING) ^ !(flags & IRQ_TYPE_EDGE_FALLING)) == 0)\r\nreturn -EINVAL;\r\nip0 = sa1111_readl(mapbase + SA1111_INTPOL0);\r\nif (flags & IRQ_TYPE_EDGE_RISING)\r\nip0 &= ~mask;\r\nelse\r\nip0 |= mask;\r\nsa1111_writel(ip0, mapbase + SA1111_INTPOL0);\r\nsa1111_writel(ip0, mapbase + SA1111_WAKEPOL0);\r\nreturn 0;\r\n}\r\nstatic int sa1111_wake_lowirq(struct irq_data *d, unsigned int on)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned int mask = SA1111_IRQMASK_LO(d->irq);\r\nunsigned long we0;\r\nwe0 = sa1111_readl(mapbase + SA1111_WAKEEN0);\r\nif (on)\r\nwe0 |= mask;\r\nelse\r\nwe0 &= ~mask;\r\nsa1111_writel(we0, mapbase + SA1111_WAKEEN0);\r\nreturn 0;\r\n}\r\nstatic void sa1111_mask_highirq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned long ie1;\r\nie1 = sa1111_readl(mapbase + SA1111_INTEN1);\r\nie1 &= ~SA1111_IRQMASK_HI(d->irq);\r\nsa1111_writel(ie1, mapbase + SA1111_INTEN1);\r\n}\r\nstatic void sa1111_unmask_highirq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned long ie1;\r\nie1 = sa1111_readl(mapbase + SA1111_INTEN1);\r\nie1 |= SA1111_IRQMASK_HI(d->irq);\r\nsa1111_writel(ie1, mapbase + SA1111_INTEN1);\r\n}\r\nstatic int sa1111_retrigger_highirq(struct irq_data *d)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned int mask = SA1111_IRQMASK_HI(d->irq);\r\nunsigned long ip1;\r\nint i;\r\nip1 = sa1111_readl(mapbase + SA1111_INTPOL1);\r\nfor (i = 0; i < 8; i++) {\r\nsa1111_writel(ip1 ^ mask, mapbase + SA1111_INTPOL1);\r\nsa1111_writel(ip1, mapbase + SA1111_INTPOL1);\r\nif (sa1111_readl(mapbase + SA1111_INTSTATCLR1) & mask)\r\nbreak;\r\n}\r\nif (i == 8)\r\nprintk(KERN_ERR "Danger Will Robinson: failed to "\r\n"re-trigger IRQ%d\n", d->irq);\r\nreturn i == 8 ? -1 : 0;\r\n}\r\nstatic int sa1111_type_highirq(struct irq_data *d, unsigned int flags)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned int mask = SA1111_IRQMASK_HI(d->irq);\r\nunsigned long ip1;\r\nif (flags == IRQ_TYPE_PROBE)\r\nreturn 0;\r\nif ((!(flags & IRQ_TYPE_EDGE_RISING) ^ !(flags & IRQ_TYPE_EDGE_FALLING)) == 0)\r\nreturn -EINVAL;\r\nip1 = sa1111_readl(mapbase + SA1111_INTPOL1);\r\nif (flags & IRQ_TYPE_EDGE_RISING)\r\nip1 &= ~mask;\r\nelse\r\nip1 |= mask;\r\nsa1111_writel(ip1, mapbase + SA1111_INTPOL1);\r\nsa1111_writel(ip1, mapbase + SA1111_WAKEPOL1);\r\nreturn 0;\r\n}\r\nstatic int sa1111_wake_highirq(struct irq_data *d, unsigned int on)\r\n{\r\nstruct sa1111 *sachip = irq_data_get_irq_chip_data(d);\r\nvoid __iomem *mapbase = sachip->base + SA1111_INTC;\r\nunsigned int mask = SA1111_IRQMASK_HI(d->irq);\r\nunsigned long we1;\r\nwe1 = sa1111_readl(mapbase + SA1111_WAKEEN1);\r\nif (on)\r\nwe1 |= mask;\r\nelse\r\nwe1 &= ~mask;\r\nsa1111_writel(we1, mapbase + SA1111_WAKEEN1);\r\nreturn 0;\r\n}\r\nstatic int sa1111_setup_irq(struct sa1111 *sachip, unsigned irq_base)\r\n{\r\nvoid __iomem *irqbase = sachip->base + SA1111_INTC;\r\nunsigned i, irq;\r\nint ret;\r\nrequest_mem_region(sachip->phys + SA1111_INTC, 512, "irq");\r\nret = irq_alloc_descs(-1, irq_base, SA1111_IRQ_NR, -1);\r\nif (ret <= 0) {\r\ndev_err(sachip->dev, "unable to allocate %u irqs: %d\n",\r\nSA1111_IRQ_NR, ret);\r\nif (ret == 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nsachip->irq_base = ret;\r\nsa1111_writel(0, irqbase + SA1111_INTEN0);\r\nsa1111_writel(0, irqbase + SA1111_INTEN1);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN0);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN1);\r\nsa1111_writel(0, irqbase + SA1111_INTPOL0);\r\nsa1111_writel(SA1111_IRQMASK_HI(IRQ_S0_READY_NINT) |\r\nSA1111_IRQMASK_HI(IRQ_S1_READY_NINT),\r\nirqbase + SA1111_INTPOL1);\r\nsa1111_writel(~0, irqbase + SA1111_INTSTATCLR0);\r\nsa1111_writel(~0, irqbase + SA1111_INTSTATCLR1);\r\nfor (i = IRQ_GPAIN0; i <= SSPROR; i++) {\r\nirq = sachip->irq_base + i;\r\nirq_set_chip_and_handler(irq, &sa1111_low_chip,\r\nhandle_edge_irq);\r\nirq_set_chip_data(irq, sachip);\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\n}\r\nfor (i = AUDXMTDMADONEA; i <= IRQ_S1_BVD1_STSCHG; i++) {\r\nirq = sachip->irq_base + i;\r\nirq_set_chip_and_handler(irq, &sa1111_high_chip,\r\nhandle_edge_irq);\r\nirq_set_chip_data(irq, sachip);\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\n}\r\nirq_set_irq_type(sachip->irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_handler_data(sachip->irq, sachip);\r\nirq_set_chained_handler(sachip->irq, sa1111_irq_handler);\r\ndev_info(sachip->dev, "Providing IRQ%u-%u\n",\r\nsachip->irq_base, sachip->irq_base + SA1111_IRQ_NR - 1);\r\nreturn 0;\r\n}\r\nstatic void sa1111_wake(struct sa1111 *sachip)\r\n{\r\nunsigned long flags, r;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nclk_enable(sachip->clk);\r\nr = sa1111_readl(sachip->base + SA1111_SKCR);\r\nr &= ~SKCR_VCO_OFF;\r\nsa1111_writel(r, sachip->base + SA1111_SKCR);\r\nr |= SKCR_PLL_BYPASS | SKCR_OE_EN;\r\nsa1111_writel(r, sachip->base + SA1111_SKCR);\r\nudelay(100);\r\nr |= SKCR_RCLKEN | SKCR_RDYEN;\r\nsa1111_writel(r, sachip->base + SA1111_SKCR);\r\nudelay(1);\r\nsa1111_writel(0, sachip->base + SA1111_SKPCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nvoid\r\nsa1111_configure_smc(struct sa1111 *sachip, int sdram, unsigned int drac,\r\nunsigned int cas_latency)\r\n{\r\nunsigned int smcr = SMCR_DTIM | SMCR_MBGE | FInsrt(drac, SMCR_DRAC);\r\nif (cas_latency == 3)\r\nsmcr |= SMCR_CLAT;\r\nsa1111_writel(smcr, sachip->base + SA1111_SMCR);\r\nif (sachip->dev->dma_mask)\r\n*sachip->dev->dma_mask &= sa1111_dma_mask[drac >> 2];\r\nsachip->dev->coherent_dma_mask &= sa1111_dma_mask[drac >> 2];\r\n}\r\nstatic void sa1111_dev_release(struct device *_dev)\r\n{\r\nstruct sa1111_dev *dev = SA1111_DEV(_dev);\r\nkfree(dev);\r\n}\r\nstatic int\r\nsa1111_init_one_child(struct sa1111 *sachip, struct resource *parent,\r\nstruct sa1111_dev_info *info)\r\n{\r\nstruct sa1111_dev *dev;\r\nunsigned i;\r\nint ret;\r\ndev = kzalloc(sizeof(struct sa1111_dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\ndevice_initialize(&dev->dev);\r\ndev_set_name(&dev->dev, "%4.4lx", info->offset);\r\ndev->devid = info->devid;\r\ndev->dev.parent = sachip->dev;\r\ndev->dev.bus = &sa1111_bus_type;\r\ndev->dev.release = sa1111_dev_release;\r\ndev->res.start = sachip->phys + info->offset;\r\ndev->res.end = dev->res.start + 511;\r\ndev->res.name = dev_name(&dev->dev);\r\ndev->res.flags = IORESOURCE_MEM;\r\ndev->mapbase = sachip->base + info->offset;\r\ndev->skpcr_mask = info->skpcr_mask;\r\nfor (i = 0; i < ARRAY_SIZE(info->irq); i++)\r\ndev->irq[i] = sachip->irq_base + info->irq[i];\r\nif (info->dma && sachip->dev->dma_mask) {\r\ndev->dma_mask = *sachip->dev->dma_mask;\r\ndev->dev.dma_mask = &dev->dma_mask;\r\ndev->dev.coherent_dma_mask = sachip->dev->coherent_dma_mask;\r\n}\r\nret = request_resource(parent, &dev->res);\r\nif (ret) {\r\ndev_err(sachip->dev, "failed to allocate resource for %s\n",\r\ndev->res.name);\r\ngoto err_resource;\r\n}\r\nret = device_add(&dev->dev);\r\nif (ret)\r\ngoto err_add;\r\nreturn 0;\r\nerr_add:\r\nrelease_resource(&dev->res);\r\nerr_resource:\r\nput_device(&dev->dev);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic int __sa1111_probe(struct device *me, struct resource *mem, int irq)\r\n{\r\nstruct sa1111_platform_data *pd = me->platform_data;\r\nstruct sa1111 *sachip;\r\nunsigned long id;\r\nunsigned int has_devs;\r\nint i, ret = -ENODEV;\r\nif (!pd)\r\nreturn -EINVAL;\r\nsachip = kzalloc(sizeof(struct sa1111), GFP_KERNEL);\r\nif (!sachip)\r\nreturn -ENOMEM;\r\nsachip->clk = clk_get(me, "SA1111_CLK");\r\nif (IS_ERR(sachip->clk)) {\r\nret = PTR_ERR(sachip->clk);\r\ngoto err_free;\r\n}\r\nret = clk_prepare(sachip->clk);\r\nif (ret)\r\ngoto err_clkput;\r\nspin_lock_init(&sachip->lock);\r\nsachip->dev = me;\r\ndev_set_drvdata(sachip->dev, sachip);\r\nsachip->pdata = pd;\r\nsachip->phys = mem->start;\r\nsachip->irq = irq;\r\nsachip->base = ioremap(mem->start, PAGE_SIZE * 2);\r\nif (!sachip->base) {\r\nret = -ENOMEM;\r\ngoto err_clk_unprep;\r\n}\r\nid = sa1111_readl(sachip->base + SA1111_SKID);\r\nif ((id & SKID_ID_MASK) != SKID_SA1111_ID) {\r\nprintk(KERN_DEBUG "SA1111 not detected: ID = %08lx\n", id);\r\nret = -ENODEV;\r\ngoto err_unmap;\r\n}\r\nprintk(KERN_INFO "SA1111 Microprocessor Companion Chip: "\r\n"silicon revision %lx, metal revision %lx\n",\r\n(id & SKID_SIREV_MASK)>>4, (id & SKID_MTREV_MASK));\r\nsa1111_wake(sachip);\r\nif (sachip->irq != NO_IRQ) {\r\nret = sa1111_setup_irq(sachip, pd->irq_base);\r\nif (ret)\r\ngoto err_unmap;\r\n}\r\n#ifdef CONFIG_ARCH_SA1100\r\n{\r\nunsigned int val;\r\nsa1111_configure_smc(sachip, 1,\r\nFExtr(MDCNFG, MDCNFG_SA1110_DRAC0),\r\nFExtr(MDCNFG, MDCNFG_SA1110_TDL0));\r\nval = sa1111_readl(sachip->base + SA1111_SKPCR);\r\nsa1111_writel(val | SKPCR_DCLKEN, sachip->base + SA1111_SKPCR);\r\nsa1110_mb_enable();\r\n}\r\n#endif\r\ng_sa1111 = sachip;\r\nhas_devs = ~0;\r\nif (pd)\r\nhas_devs &= ~pd->disable_devs;\r\nfor (i = 0; i < ARRAY_SIZE(sa1111_devices); i++)\r\nif (sa1111_devices[i].devid & has_devs)\r\nsa1111_init_one_child(sachip, mem, &sa1111_devices[i]);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(sachip->base);\r\nerr_clk_unprep:\r\nclk_unprepare(sachip->clk);\r\nerr_clkput:\r\nclk_put(sachip->clk);\r\nerr_free:\r\nkfree(sachip);\r\nreturn ret;\r\n}\r\nstatic int sa1111_remove_one(struct device *dev, void *data)\r\n{\r\nstruct sa1111_dev *sadev = SA1111_DEV(dev);\r\ndevice_del(&sadev->dev);\r\nrelease_resource(&sadev->res);\r\nput_device(&sadev->dev);\r\nreturn 0;\r\n}\r\nstatic void __sa1111_remove(struct sa1111 *sachip)\r\n{\r\nvoid __iomem *irqbase = sachip->base + SA1111_INTC;\r\ndevice_for_each_child(sachip->dev, NULL, sa1111_remove_one);\r\nsa1111_writel(0, irqbase + SA1111_INTEN0);\r\nsa1111_writel(0, irqbase + SA1111_INTEN1);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN0);\r\nsa1111_writel(0, irqbase + SA1111_WAKEEN1);\r\nclk_disable(sachip->clk);\r\nclk_unprepare(sachip->clk);\r\nif (sachip->irq != NO_IRQ) {\r\nirq_set_chained_handler(sachip->irq, NULL);\r\nirq_set_handler_data(sachip->irq, NULL);\r\nirq_free_descs(sachip->irq_base, SA1111_IRQ_NR);\r\nrelease_mem_region(sachip->phys + SA1111_INTC, 512);\r\n}\r\niounmap(sachip->base);\r\nclk_put(sachip->clk);\r\nkfree(sachip);\r\n}\r\nstatic int sa1111_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct sa1111 *sachip = platform_get_drvdata(dev);\r\nstruct sa1111_save_data *save;\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *base;\r\nsave = kmalloc(sizeof(struct sa1111_save_data), GFP_KERNEL);\r\nif (!save)\r\nreturn -ENOMEM;\r\nsachip->saved_state = save;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nbase = sachip->base;\r\nsave->skcr = sa1111_readl(base + SA1111_SKCR);\r\nsave->skpcr = sa1111_readl(base + SA1111_SKPCR);\r\nsave->skcdr = sa1111_readl(base + SA1111_SKCDR);\r\nsave->skaud = sa1111_readl(base + SA1111_SKAUD);\r\nsave->skpwm0 = sa1111_readl(base + SA1111_SKPWM0);\r\nsave->skpwm1 = sa1111_readl(base + SA1111_SKPWM1);\r\nsa1111_writel(0, sachip->base + SA1111_SKPWM0);\r\nsa1111_writel(0, sachip->base + SA1111_SKPWM1);\r\nbase = sachip->base + SA1111_INTC;\r\nsave->intpol0 = sa1111_readl(base + SA1111_INTPOL0);\r\nsave->intpol1 = sa1111_readl(base + SA1111_INTPOL1);\r\nsave->inten0 = sa1111_readl(base + SA1111_INTEN0);\r\nsave->inten1 = sa1111_readl(base + SA1111_INTEN1);\r\nsave->wakepol0 = sa1111_readl(base + SA1111_WAKEPOL0);\r\nsave->wakepol1 = sa1111_readl(base + SA1111_WAKEPOL1);\r\nsave->wakeen0 = sa1111_readl(base + SA1111_WAKEEN0);\r\nsave->wakeen1 = sa1111_readl(base + SA1111_WAKEEN1);\r\nval = sa1111_readl(sachip->base + SA1111_SKCR);\r\nsa1111_writel(val | SKCR_SLEEP, sachip->base + SA1111_SKCR);\r\nclk_disable(sachip->clk);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n#ifdef CONFIG_ARCH_SA1100\r\nsa1110_mb_disable();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sa1111_resume(struct platform_device *dev)\r\n{\r\nstruct sa1111 *sachip = platform_get_drvdata(dev);\r\nstruct sa1111_save_data *save;\r\nunsigned long flags, id;\r\nvoid __iomem *base;\r\nsave = sachip->saved_state;\r\nif (!save)\r\nreturn 0;\r\nid = sa1111_readl(sachip->base + SA1111_SKID);\r\nif ((id & SKID_ID_MASK) != SKID_SA1111_ID) {\r\n__sa1111_remove(sachip);\r\nplatform_set_drvdata(dev, NULL);\r\nkfree(save);\r\nreturn 0;\r\n}\r\nsa1111_wake(sachip);\r\n#ifdef CONFIG_ARCH_SA1100\r\nsa1110_mb_enable();\r\n#endif\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nsa1111_writel(0, sachip->base + SA1111_INTC + SA1111_INTEN0);\r\nsa1111_writel(0, sachip->base + SA1111_INTC + SA1111_INTEN1);\r\nbase = sachip->base;\r\nsa1111_writel(save->skcr, base + SA1111_SKCR);\r\nsa1111_writel(save->skpcr, base + SA1111_SKPCR);\r\nsa1111_writel(save->skcdr, base + SA1111_SKCDR);\r\nsa1111_writel(save->skaud, base + SA1111_SKAUD);\r\nsa1111_writel(save->skpwm0, base + SA1111_SKPWM0);\r\nsa1111_writel(save->skpwm1, base + SA1111_SKPWM1);\r\nbase = sachip->base + SA1111_INTC;\r\nsa1111_writel(save->intpol0, base + SA1111_INTPOL0);\r\nsa1111_writel(save->intpol1, base + SA1111_INTPOL1);\r\nsa1111_writel(save->inten0, base + SA1111_INTEN0);\r\nsa1111_writel(save->inten1, base + SA1111_INTEN1);\r\nsa1111_writel(save->wakepol0, base + SA1111_WAKEPOL0);\r\nsa1111_writel(save->wakepol1, base + SA1111_WAKEPOL1);\r\nsa1111_writel(save->wakeen0, base + SA1111_WAKEEN0);\r\nsa1111_writel(save->wakeen1, base + SA1111_WAKEEN1);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\nsachip->saved_state = NULL;\r\nkfree(save);\r\nreturn 0;\r\n}\r\nstatic int sa1111_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint irq;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -ENXIO;\r\nreturn __sa1111_probe(&pdev->dev, mem, irq);\r\n}\r\nstatic int sa1111_remove(struct platform_device *pdev)\r\n{\r\nstruct sa1111 *sachip = platform_get_drvdata(pdev);\r\nif (sachip) {\r\n#ifdef CONFIG_PM\r\nkfree(sachip->saved_state);\r\nsachip->saved_state = NULL;\r\n#endif\r\n__sa1111_remove(sachip);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct sa1111 *sa1111_chip_driver(struct sa1111_dev *sadev)\r\n{\r\nreturn (struct sa1111 *)dev_get_drvdata(sadev->dev.parent);\r\n}\r\nstatic unsigned int __sa1111_pll_clock(struct sa1111 *sachip)\r\n{\r\nunsigned int skcdr, fbdiv, ipdiv, opdiv;\r\nskcdr = sa1111_readl(sachip->base + SA1111_SKCDR);\r\nfbdiv = (skcdr & 0x007f) + 2;\r\nipdiv = ((skcdr & 0x0f80) >> 7) + 2;\r\nopdiv = opdiv_table[(skcdr & 0x3000) >> 12];\r\nreturn 3686400 * fbdiv / (ipdiv * opdiv);\r\n}\r\nunsigned int sa1111_pll_clock(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nreturn __sa1111_pll_clock(sachip);\r\n}\r\nvoid sa1111_select_audio_mode(struct sa1111_dev *sadev, int mode)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nval = sa1111_readl(sachip->base + SA1111_SKCR);\r\nif (mode == SA1111_AUDIO_I2S) {\r\nval &= ~SKCR_SELAC;\r\n} else {\r\nval |= SKCR_SELAC;\r\n}\r\nsa1111_writel(val, sachip->base + SA1111_SKCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nint sa1111_set_audio_rate(struct sa1111_dev *sadev, int rate)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned int div;\r\nif (sadev->devid != SA1111_DEVID_SAC)\r\nreturn -EINVAL;\r\ndiv = (__sa1111_pll_clock(sachip) / 256 + rate / 2) / rate;\r\nif (div == 0)\r\ndiv = 1;\r\nif (div > 128)\r\ndiv = 128;\r\nsa1111_writel(div - 1, sachip->base + SA1111_SKAUD);\r\nreturn 0;\r\n}\r\nint sa1111_get_audio_rate(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long div;\r\nif (sadev->devid != SA1111_DEVID_SAC)\r\nreturn -EINVAL;\r\ndiv = sa1111_readl(sachip->base + SA1111_SKAUD) + 1;\r\nreturn __sa1111_pll_clock(sachip) / (256 * div);\r\n}\r\nvoid sa1111_set_io_dir(struct sa1111_dev *sadev,\r\nunsigned int bits, unsigned int dir,\r\nunsigned int sleep_dir)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *gpio = sachip->base + SA1111_GPIO;\r\n#define MODIFY_BITS(port, mask, dir) \\r\nif (mask) { \\r\nval = sa1111_readl(port); \\r\nval &= ~(mask); \\r\nval |= (dir) & (mask); \\r\nsa1111_writel(val, port); \\r\n}\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PADDR, bits & 15, dir);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBDDR, (bits >> 8) & 255, dir >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCDDR, (bits >> 16) & 255, dir >> 16);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PASDR, bits & 15, sleep_dir);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBSDR, (bits >> 8) & 255, sleep_dir >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCSDR, (bits >> 16) & 255, sleep_dir >> 16);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nvoid sa1111_set_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *gpio = sachip->base + SA1111_GPIO;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PADWR, bits & 15, v);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBDWR, (bits >> 8) & 255, v >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCDWR, (bits >> 16) & 255, v >> 16);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nvoid sa1111_set_sleep_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nvoid __iomem *gpio = sachip->base + SA1111_GPIO;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PASSR, bits & 15, v);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PBSSR, (bits >> 8) & 255, v >> 8);\r\nMODIFY_BITS(gpio + SA1111_GPIO_PCSSR, (bits >> 16) & 255, v >> 16);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nint sa1111_enable_device(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nint ret = 0;\r\nif (sachip->pdata && sachip->pdata->enable)\r\nret = sachip->pdata->enable(sachip->pdata->data, sadev->devid);\r\nif (ret == 0) {\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nval = sa1111_readl(sachip->base + SA1111_SKPCR);\r\nsa1111_writel(val | sadev->skpcr_mask, sachip->base + SA1111_SKPCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nvoid sa1111_disable_device(struct sa1111_dev *sadev)\r\n{\r\nstruct sa1111 *sachip = sa1111_chip_driver(sadev);\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&sachip->lock, flags);\r\nval = sa1111_readl(sachip->base + SA1111_SKPCR);\r\nsa1111_writel(val & ~sadev->skpcr_mask, sachip->base + SA1111_SKPCR);\r\nspin_unlock_irqrestore(&sachip->lock, flags);\r\nif (sachip->pdata && sachip->pdata->disable)\r\nsachip->pdata->disable(sachip->pdata->data, sadev->devid);\r\n}\r\nstatic int sa1111_match(struct device *_dev, struct device_driver *_drv)\r\n{\r\nstruct sa1111_dev *dev = SA1111_DEV(_dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(_drv);\r\nreturn dev->devid & drv->devid;\r\n}\r\nstatic int sa1111_bus_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct sa1111_dev *sadev = SA1111_DEV(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv && drv->suspend)\r\nret = drv->suspend(sadev, state);\r\nreturn ret;\r\n}\r\nstatic int sa1111_bus_resume(struct device *dev)\r\n{\r\nstruct sa1111_dev *sadev = SA1111_DEV(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv && drv->resume)\r\nret = drv->resume(sadev);\r\nreturn ret;\r\n}\r\nstatic void sa1111_bus_shutdown(struct device *dev)\r\n{\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nif (drv && drv->shutdown)\r\ndrv->shutdown(SA1111_DEV(dev));\r\n}\r\nstatic int sa1111_bus_probe(struct device *dev)\r\n{\r\nstruct sa1111_dev *sadev = SA1111_DEV(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = -ENODEV;\r\nif (drv->probe)\r\nret = drv->probe(sadev);\r\nreturn ret;\r\n}\r\nstatic int sa1111_bus_remove(struct device *dev)\r\n{\r\nstruct sa1111_dev *sadev = SA1111_DEV(dev);\r\nstruct sa1111_driver *drv = SA1111_DRV(dev->driver);\r\nint ret = 0;\r\nif (drv->remove)\r\nret = drv->remove(sadev);\r\nreturn ret;\r\n}\r\nint sa1111_driver_register(struct sa1111_driver *driver)\r\n{\r\ndriver->drv.bus = &sa1111_bus_type;\r\nreturn driver_register(&driver->drv);\r\n}\r\nvoid sa1111_driver_unregister(struct sa1111_driver *driver)\r\n{\r\ndriver_unregister(&driver->drv);\r\n}\r\nstatic int sa1111_needs_bounce(struct device *dev, dma_addr_t addr, size_t size)\r\n{\r\nreturn (machine_is_assabet() || machine_is_pfs168()) &&\r\n(addr >= 0xc8000000 || (addr + size) >= 0xc8000000);\r\n}\r\nstatic int sa1111_notifier_call(struct notifier_block *n, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct sa1111_dev *dev = SA1111_DEV(data);\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (dev->dev.dma_mask && dev->dma_mask < 0xffffffffUL) {\r\nint ret = dmabounce_register_dev(&dev->dev, 1024, 4096,\r\nsa1111_needs_bounce);\r\nif (ret)\r\ndev_err(&dev->dev, "failed to register with dmabounce: %d\n", ret);\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (dev->dev.dma_mask && dev->dma_mask < 0xffffffffUL)\r\ndmabounce_unregister_dev(&dev->dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init sa1111_init(void)\r\n{\r\nint ret = bus_register(&sa1111_bus_type);\r\n#ifdef CONFIG_DMABOUNCE\r\nif (ret == 0)\r\nbus_register_notifier(&sa1111_bus_type, &sa1111_bus_notifier);\r\n#endif\r\nif (ret == 0)\r\nplatform_driver_register(&sa1111_device_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit sa1111_exit(void)\r\n{\r\nplatform_driver_unregister(&sa1111_device_driver);\r\n#ifdef CONFIG_DMABOUNCE\r\nbus_unregister_notifier(&sa1111_bus_type, &sa1111_bus_notifier);\r\n#endif\r\nbus_unregister(&sa1111_bus_type);\r\n}
