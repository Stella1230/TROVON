static inline unsigned int u32_hash_fold(__be32 key,\r\nconst struct tc_u32_sel *sel,\r\nu8 fshift)\r\n{\r\nunsigned int h = ntohl(key & sel->hmask) >> fshift;\r\nreturn h;\r\n}\r\nstatic int u32_classify(struct sk_buff *skb, const struct tcf_proto *tp, struct tcf_result *res)\r\n{\r\nstruct {\r\nstruct tc_u_knode *knode;\r\nunsigned int off;\r\n} stack[TC_U32_MAXDEPTH];\r\nstruct tc_u_hnode *ht = (struct tc_u_hnode *)tp->root;\r\nunsigned int off = skb_network_offset(skb);\r\nstruct tc_u_knode *n;\r\nint sdepth = 0;\r\nint off2 = 0;\r\nint sel = 0;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nint j;\r\n#endif\r\nint i, r;\r\nnext_ht:\r\nn = ht->ht[sel];\r\nnext_knode:\r\nif (n) {\r\nstruct tc_u32_key *key = n->sel.keys;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nn->pf->rcnt += 1;\r\nj = 0;\r\n#endif\r\n#ifdef CONFIG_CLS_U32_MARK\r\nif ((skb->mark & n->mark.mask) != n->mark.val) {\r\nn = n->next;\r\ngoto next_knode;\r\n} else {\r\nn->mark.success++;\r\n}\r\n#endif\r\nfor (i = n->sel.nkeys; i > 0; i--, key++) {\r\nint toff = off + key->off + (off2 & key->offmask);\r\n__be32 *data, hdata;\r\nif (skb_headroom(skb) + toff > INT_MAX)\r\ngoto out;\r\ndata = skb_header_pointer(skb, toff, 4, &hdata);\r\nif (!data)\r\ngoto out;\r\nif ((*data ^ key->val) & key->mask) {\r\nn = n->next;\r\ngoto next_knode;\r\n}\r\n#ifdef CONFIG_CLS_U32_PERF\r\nn->pf->kcnts[j] += 1;\r\nj++;\r\n#endif\r\n}\r\nif (n->ht_down == NULL) {\r\ncheck_terminal:\r\nif (n->sel.flags & TC_U32_TERMINAL) {\r\n*res = n->res;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (!tcf_match_indev(skb, n->indev)) {\r\nn = n->next;\r\ngoto next_knode;\r\n}\r\n#endif\r\n#ifdef CONFIG_CLS_U32_PERF\r\nn->pf->rhit += 1;\r\n#endif\r\nr = tcf_exts_exec(skb, &n->exts, res);\r\nif (r < 0) {\r\nn = n->next;\r\ngoto next_knode;\r\n}\r\nreturn r;\r\n}\r\nn = n->next;\r\ngoto next_knode;\r\n}\r\nif (sdepth >= TC_U32_MAXDEPTH)\r\ngoto deadloop;\r\nstack[sdepth].knode = n;\r\nstack[sdepth].off = off;\r\nsdepth++;\r\nht = n->ht_down;\r\nsel = 0;\r\nif (ht->divisor) {\r\n__be32 *data, hdata;\r\ndata = skb_header_pointer(skb, off + n->sel.hoff, 4,\r\n&hdata);\r\nif (!data)\r\ngoto out;\r\nsel = ht->divisor & u32_hash_fold(*data, &n->sel,\r\nn->fshift);\r\n}\r\nif (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))\r\ngoto next_ht;\r\nif (n->sel.flags & (TC_U32_OFFSET | TC_U32_VAROFFSET)) {\r\noff2 = n->sel.off + 3;\r\nif (n->sel.flags & TC_U32_VAROFFSET) {\r\n__be16 *data, hdata;\r\ndata = skb_header_pointer(skb,\r\noff + n->sel.offoff,\r\n2, &hdata);\r\nif (!data)\r\ngoto out;\r\noff2 += ntohs(n->sel.offmask & *data) >>\r\nn->sel.offshift;\r\n}\r\noff2 &= ~3;\r\n}\r\nif (n->sel.flags & TC_U32_EAT) {\r\noff += off2;\r\noff2 = 0;\r\n}\r\nif (off < skb->len)\r\ngoto next_ht;\r\n}\r\nif (sdepth--) {\r\nn = stack[sdepth].knode;\r\nht = n->ht_up;\r\noff = stack[sdepth].off;\r\ngoto check_terminal;\r\n}\r\nout:\r\nreturn -1;\r\ndeadloop:\r\nnet_warn_ratelimited("cls_u32: dead loop\n");\r\nreturn -1;\r\n}\r\nstatic struct tc_u_hnode *\r\nu32_lookup_ht(struct tc_u_common *tp_c, u32 handle)\r\n{\r\nstruct tc_u_hnode *ht;\r\nfor (ht = tp_c->hlist; ht; ht = ht->next)\r\nif (ht->handle == handle)\r\nbreak;\r\nreturn ht;\r\n}\r\nstatic struct tc_u_knode *\r\nu32_lookup_key(struct tc_u_hnode *ht, u32 handle)\r\n{\r\nunsigned int sel;\r\nstruct tc_u_knode *n = NULL;\r\nsel = TC_U32_HASH(handle);\r\nif (sel > ht->divisor)\r\ngoto out;\r\nfor (n = ht->ht[sel]; n; n = n->next)\r\nif (n->handle == handle)\r\nbreak;\r\nout:\r\nreturn n;\r\n}\r\nstatic unsigned long u32_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct tc_u_hnode *ht;\r\nstruct tc_u_common *tp_c = tp->data;\r\nif (TC_U32_HTID(handle) == TC_U32_ROOT)\r\nht = tp->root;\r\nelse\r\nht = u32_lookup_ht(tp_c, TC_U32_HTID(handle));\r\nif (!ht)\r\nreturn 0;\r\nif (TC_U32_KEY(handle) == 0)\r\nreturn (unsigned long)ht;\r\nreturn (unsigned long)u32_lookup_key(ht, handle);\r\n}\r\nstatic void u32_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\n}\r\nstatic u32 gen_new_htid(struct tc_u_common *tp_c)\r\n{\r\nint i = 0x800;\r\ndo {\r\nif (++tp_c->hgenerator == 0x7FF)\r\ntp_c->hgenerator = 1;\r\n} while (--i > 0 && u32_lookup_ht(tp_c, (tp_c->hgenerator|0x800)<<20));\r\nreturn i > 0 ? (tp_c->hgenerator|0x800)<<20 : 0;\r\n}\r\nstatic int u32_init(struct tcf_proto *tp)\r\n{\r\nstruct tc_u_hnode *root_ht;\r\nstruct tc_u_common *tp_c;\r\ntp_c = tp->q->u32_node;\r\nroot_ht = kzalloc(sizeof(*root_ht), GFP_KERNEL);\r\nif (root_ht == NULL)\r\nreturn -ENOBUFS;\r\nroot_ht->divisor = 0;\r\nroot_ht->refcnt++;\r\nroot_ht->handle = tp_c ? gen_new_htid(tp_c) : 0x80000000;\r\nroot_ht->prio = tp->prio;\r\nif (tp_c == NULL) {\r\ntp_c = kzalloc(sizeof(*tp_c), GFP_KERNEL);\r\nif (tp_c == NULL) {\r\nkfree(root_ht);\r\nreturn -ENOBUFS;\r\n}\r\ntp_c->q = tp->q;\r\ntp->q->u32_node = tp_c;\r\n}\r\ntp_c->refcnt++;\r\nroot_ht->next = tp_c->hlist;\r\ntp_c->hlist = root_ht;\r\nroot_ht->tp_c = tp_c;\r\ntp->root = root_ht;\r\ntp->data = tp_c;\r\nreturn 0;\r\n}\r\nstatic int u32_destroy_key(struct tcf_proto *tp, struct tc_u_knode *n)\r\n{\r\ntcf_unbind_filter(tp, &n->res);\r\ntcf_exts_destroy(tp, &n->exts);\r\nif (n->ht_down)\r\nn->ht_down->refcnt--;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nkfree(n->pf);\r\n#endif\r\nkfree(n);\r\nreturn 0;\r\n}\r\nstatic int u32_delete_key(struct tcf_proto *tp, struct tc_u_knode* key)\r\n{\r\nstruct tc_u_knode **kp;\r\nstruct tc_u_hnode *ht = key->ht_up;\r\nif (ht) {\r\nfor (kp = &ht->ht[TC_U32_HASH(key->handle)]; *kp; kp = &(*kp)->next) {\r\nif (*kp == key) {\r\ntcf_tree_lock(tp);\r\n*kp = key->next;\r\ntcf_tree_unlock(tp);\r\nu32_destroy_key(tp, key);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nstatic void u32_clear_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht)\r\n{\r\nstruct tc_u_knode *n;\r\nunsigned int h;\r\nfor (h = 0; h <= ht->divisor; h++) {\r\nwhile ((n = ht->ht[h]) != NULL) {\r\nht->ht[h] = n->next;\r\nu32_destroy_key(tp, n);\r\n}\r\n}\r\n}\r\nstatic int u32_destroy_hnode(struct tcf_proto *tp, struct tc_u_hnode *ht)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode **hn;\r\nWARN_ON(ht->refcnt);\r\nu32_clear_hnode(tp, ht);\r\nfor (hn = &tp_c->hlist; *hn; hn = &(*hn)->next) {\r\nif (*hn == ht) {\r\n*hn = ht->next;\r\nkfree(ht);\r\nreturn 0;\r\n}\r\n}\r\nWARN_ON(1);\r\nreturn -ENOENT;\r\n}\r\nstatic void u32_destroy(struct tcf_proto *tp)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode *root_ht = tp->root;\r\nWARN_ON(root_ht == NULL);\r\nif (root_ht && --root_ht->refcnt == 0)\r\nu32_destroy_hnode(tp, root_ht);\r\nif (--tp_c->refcnt == 0) {\r\nstruct tc_u_hnode *ht;\r\ntp->q->u32_node = NULL;\r\nfor (ht = tp_c->hlist; ht; ht = ht->next) {\r\nht->refcnt--;\r\nu32_clear_hnode(tp, ht);\r\n}\r\nwhile ((ht = tp_c->hlist) != NULL) {\r\ntp_c->hlist = ht->next;\r\nWARN_ON(ht->refcnt != 0);\r\nkfree(ht);\r\n}\r\nkfree(tp_c);\r\n}\r\ntp->data = NULL;\r\n}\r\nstatic int u32_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct tc_u_hnode *ht = (struct tc_u_hnode *)arg;\r\nif (ht == NULL)\r\nreturn 0;\r\nif (TC_U32_KEY(ht->handle))\r\nreturn u32_delete_key(tp, (struct tc_u_knode *)ht);\r\nif (tp->root == ht)\r\nreturn -EINVAL;\r\nif (ht->refcnt == 1) {\r\nht->refcnt--;\r\nu32_destroy_hnode(tp, ht);\r\n} else {\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 gen_new_kid(struct tc_u_hnode *ht, u32 handle)\r\n{\r\nstruct tc_u_knode *n;\r\nunsigned int i = 0x7FF;\r\nfor (n = ht->ht[TC_U32_HASH(handle)]; n; n = n->next)\r\nif (i < TC_U32_NODE(n->handle))\r\ni = TC_U32_NODE(n->handle);\r\ni++;\r\nreturn handle | (i > 0xFFF ? 0xFFF : i);\r\n}\r\nstatic int u32_set_parms(struct net *net, struct tcf_proto *tp,\r\nunsigned long base, struct tc_u_hnode *ht,\r\nstruct tc_u_knode *n, struct nlattr **tb,\r\nstruct nlattr *est)\r\n{\r\nint err;\r\nstruct tcf_exts e;\r\nerr = tcf_exts_validate(net, tp, tb, est, &e, &u32_ext_map);\r\nif (err < 0)\r\nreturn err;\r\nerr = -EINVAL;\r\nif (tb[TCA_U32_LINK]) {\r\nu32 handle = nla_get_u32(tb[TCA_U32_LINK]);\r\nstruct tc_u_hnode *ht_down = NULL, *ht_old;\r\nif (TC_U32_KEY(handle))\r\ngoto errout;\r\nif (handle) {\r\nht_down = u32_lookup_ht(ht->tp_c, handle);\r\nif (ht_down == NULL)\r\ngoto errout;\r\nht_down->refcnt++;\r\n}\r\ntcf_tree_lock(tp);\r\nht_old = n->ht_down;\r\nn->ht_down = ht_down;\r\ntcf_tree_unlock(tp);\r\nif (ht_old)\r\nht_old->refcnt--;\r\n}\r\nif (tb[TCA_U32_CLASSID]) {\r\nn->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);\r\ntcf_bind_filter(tp, &n->res, base);\r\n}\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (tb[TCA_U32_INDEV]) {\r\nerr = tcf_change_indev(tp, n->indev, tb[TCA_U32_INDEV]);\r\nif (err < 0)\r\ngoto errout;\r\n}\r\n#endif\r\ntcf_exts_change(tp, &n->exts, &e);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(tp, &e);\r\nreturn err;\r\n}\r\nstatic int u32_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct nlattr **tca,\r\nunsigned long *arg)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode *ht;\r\nstruct tc_u_knode *n;\r\nstruct tc_u32_sel *s;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_U32_MAX + 1];\r\nu32 htid;\r\nint err;\r\nif (opt == NULL)\r\nreturn handle ? -EINVAL : 0;\r\nerr = nla_parse_nested(tb, TCA_U32_MAX, opt, u32_policy);\r\nif (err < 0)\r\nreturn err;\r\nn = (struct tc_u_knode *)*arg;\r\nif (n) {\r\nif (TC_U32_KEY(n->handle) == 0)\r\nreturn -EINVAL;\r\nreturn u32_set_parms(net, tp, base, n->ht_up, n, tb,\r\ntca[TCA_RATE]);\r\n}\r\nif (tb[TCA_U32_DIVISOR]) {\r\nunsigned int divisor = nla_get_u32(tb[TCA_U32_DIVISOR]);\r\nif (--divisor > 0x100)\r\nreturn -EINVAL;\r\nif (TC_U32_KEY(handle))\r\nreturn -EINVAL;\r\nif (handle == 0) {\r\nhandle = gen_new_htid(tp->data);\r\nif (handle == 0)\r\nreturn -ENOMEM;\r\n}\r\nht = kzalloc(sizeof(*ht) + divisor*sizeof(void *), GFP_KERNEL);\r\nif (ht == NULL)\r\nreturn -ENOBUFS;\r\nht->tp_c = tp_c;\r\nht->refcnt = 1;\r\nht->divisor = divisor;\r\nht->handle = handle;\r\nht->prio = tp->prio;\r\nht->next = tp_c->hlist;\r\ntp_c->hlist = ht;\r\n*arg = (unsigned long)ht;\r\nreturn 0;\r\n}\r\nif (tb[TCA_U32_HASH]) {\r\nhtid = nla_get_u32(tb[TCA_U32_HASH]);\r\nif (TC_U32_HTID(htid) == TC_U32_ROOT) {\r\nht = tp->root;\r\nhtid = ht->handle;\r\n} else {\r\nht = u32_lookup_ht(tp->data, TC_U32_HTID(htid));\r\nif (ht == NULL)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nht = tp->root;\r\nhtid = ht->handle;\r\n}\r\nif (ht->divisor < TC_U32_HASH(htid))\r\nreturn -EINVAL;\r\nif (handle) {\r\nif (TC_U32_HTID(handle) && TC_U32_HTID(handle^htid))\r\nreturn -EINVAL;\r\nhandle = htid | TC_U32_NODE(handle);\r\n} else\r\nhandle = gen_new_kid(ht, htid);\r\nif (tb[TCA_U32_SEL] == NULL)\r\nreturn -EINVAL;\r\ns = nla_data(tb[TCA_U32_SEL]);\r\nn = kzalloc(sizeof(*n) + s->nkeys*sizeof(struct tc_u32_key), GFP_KERNEL);\r\nif (n == NULL)\r\nreturn -ENOBUFS;\r\n#ifdef CONFIG_CLS_U32_PERF\r\nn->pf = kzalloc(sizeof(struct tc_u32_pcnt) + s->nkeys*sizeof(u64), GFP_KERNEL);\r\nif (n->pf == NULL) {\r\nkfree(n);\r\nreturn -ENOBUFS;\r\n}\r\n#endif\r\nmemcpy(&n->sel, s, sizeof(*s) + s->nkeys*sizeof(struct tc_u32_key));\r\nn->ht_up = ht;\r\nn->handle = handle;\r\nn->fshift = s->hmask ? ffs(ntohl(s->hmask)) - 1 : 0;\r\n#ifdef CONFIG_CLS_U32_MARK\r\nif (tb[TCA_U32_MARK]) {\r\nstruct tc_u32_mark *mark;\r\nmark = nla_data(tb[TCA_U32_MARK]);\r\nmemcpy(&n->mark, mark, sizeof(struct tc_u32_mark));\r\nn->mark.success = 0;\r\n}\r\n#endif\r\nerr = u32_set_parms(net, tp, base, ht, n, tb, tca[TCA_RATE]);\r\nif (err == 0) {\r\nstruct tc_u_knode **ins;\r\nfor (ins = &ht->ht[TC_U32_HASH(handle)]; *ins; ins = &(*ins)->next)\r\nif (TC_U32_NODE(handle) < TC_U32_NODE((*ins)->handle))\r\nbreak;\r\nn->next = *ins;\r\ntcf_tree_lock(tp);\r\n*ins = n;\r\ntcf_tree_unlock(tp);\r\n*arg = (unsigned long)n;\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_CLS_U32_PERF\r\nkfree(n->pf);\r\n#endif\r\nkfree(n);\r\nreturn err;\r\n}\r\nstatic void u32_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct tc_u_common *tp_c = tp->data;\r\nstruct tc_u_hnode *ht;\r\nstruct tc_u_knode *n;\r\nunsigned int h;\r\nif (arg->stop)\r\nreturn;\r\nfor (ht = tp_c->hlist; ht; ht = ht->next) {\r\nif (ht->prio != tp->prio)\r\ncontinue;\r\nif (arg->count >= arg->skip) {\r\nif (arg->fn(tp, (unsigned long)ht, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\n}\r\narg->count++;\r\nfor (h = 0; h <= ht->divisor; h++) {\r\nfor (n = ht->ht[h]; n; n = n->next) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(tp, (unsigned long)n, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\n}\r\nstatic int u32_dump(struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct tc_u_knode *n = (struct tc_u_knode *)fh;\r\nstruct nlattr *nest;\r\nif (n == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = n->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (TC_U32_KEY(n->handle) == 0) {\r\nstruct tc_u_hnode *ht = (struct tc_u_hnode *)fh;\r\nu32 divisor = ht->divisor + 1;\r\nif (nla_put_u32(skb, TCA_U32_DIVISOR, divisor))\r\ngoto nla_put_failure;\r\n} else {\r\nif (nla_put(skb, TCA_U32_SEL,\r\nsizeof(n->sel) + n->sel.nkeys*sizeof(struct tc_u32_key),\r\n&n->sel))\r\ngoto nla_put_failure;\r\nif (n->ht_up) {\r\nu32 htid = n->handle & 0xFFFFF000;\r\nif (nla_put_u32(skb, TCA_U32_HASH, htid))\r\ngoto nla_put_failure;\r\n}\r\nif (n->res.classid &&\r\nnla_put_u32(skb, TCA_U32_CLASSID, n->res.classid))\r\ngoto nla_put_failure;\r\nif (n->ht_down &&\r\nnla_put_u32(skb, TCA_U32_LINK, n->ht_down->handle))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_CLS_U32_MARK\r\nif ((n->mark.val || n->mark.mask) &&\r\nnla_put(skb, TCA_U32_MARK, sizeof(n->mark), &n->mark))\r\ngoto nla_put_failure;\r\n#endif\r\nif (tcf_exts_dump(skb, &n->exts, &u32_ext_map) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (strlen(n->indev) &&\r\nnla_put_string(skb, TCA_U32_INDEV, n->indev))\r\ngoto nla_put_failure;\r\n#endif\r\n#ifdef CONFIG_CLS_U32_PERF\r\nif (nla_put(skb, TCA_U32_PCNT,\r\nsizeof(struct tc_u32_pcnt) + n->sel.nkeys*sizeof(u64),\r\nn->pf))\r\ngoto nla_put_failure;\r\n#endif\r\n}\r\nnla_nest_end(skb, nest);\r\nif (TC_U32_KEY(n->handle))\r\nif (tcf_exts_dump_stats(skb, &n->exts, &u32_ext_map) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_u32(void)\r\n{\r\npr_info("u32 classifier\n");\r\n#ifdef CONFIG_CLS_U32_PERF\r\npr_info(" Performance counters on\n");\r\n#endif\r\n#ifdef CONFIG_NET_CLS_IND\r\npr_info(" input device check on\n");\r\n#endif\r\n#ifdef CONFIG_NET_CLS_ACT\r\npr_info(" Actions configured\n");\r\n#endif\r\nreturn register_tcf_proto_ops(&cls_u32_ops);\r\n}\r\nstatic void __exit exit_u32(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_u32_ops);\r\n}
