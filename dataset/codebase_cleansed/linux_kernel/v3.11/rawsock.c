static void rawsock_write_queue_purge(struct sock *sk)\r\n{\r\npr_debug("sk=%p\n", sk);\r\nspin_lock_bh(&sk->sk_write_queue.lock);\r\n__skb_queue_purge(&sk->sk_write_queue);\r\nnfc_rawsock(sk)->tx_work_scheduled = false;\r\nspin_unlock_bh(&sk->sk_write_queue.lock);\r\n}\r\nstatic void rawsock_report_error(struct sock *sk, int err)\r\n{\r\npr_debug("sk=%p err=%d\n", sk, err);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nsk->sk_err = -err;\r\nsk->sk_error_report(sk);\r\nrawsock_write_queue_purge(sk);\r\n}\r\nstatic int rawsock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\npr_debug("sock=%p sk=%p\n", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsock_orphan(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int rawsock_connect(struct socket *sock, struct sockaddr *_addr,\r\nint len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_nfc *addr = (struct sockaddr_nfc *)_addr;\r\nstruct nfc_dev *dev;\r\nint rc = 0;\r\npr_debug("sock=%p sk=%p flags=%d\n", sock, sk, flags);\r\nif (!addr || len < sizeof(struct sockaddr_nfc) ||\r\naddr->sa_family != AF_NFC)\r\nreturn -EINVAL;\r\npr_debug("addr dev_idx=%u target_idx=%u protocol=%u\n",\r\naddr->dev_idx, addr->target_idx, addr->nfc_protocol);\r\nlock_sock(sk);\r\nif (sock->state == SS_CONNECTED) {\r\nrc = -EISCONN;\r\ngoto error;\r\n}\r\ndev = nfc_get_device(addr->dev_idx);\r\nif (!dev) {\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\nif (addr->target_idx > dev->target_next_idx - 1 ||\r\naddr->target_idx < dev->target_next_idx - dev->n_targets) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nrc = nfc_activate_target(dev, addr->target_idx, addr->nfc_protocol);\r\nif (rc)\r\ngoto put_dev;\r\nnfc_rawsock(sk)->dev = dev;\r\nnfc_rawsock(sk)->target_idx = addr->target_idx;\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsk->sk_state_change(sk);\r\nrelease_sock(sk);\r\nreturn 0;\r\nput_dev:\r\nnfc_put_device(dev);\r\nerror:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int rawsock_add_header(struct sk_buff *skb)\r\n{\r\n*skb_push(skb, NFC_HEADER_SIZE) = 0;\r\nreturn 0;\r\n}\r\nstatic void rawsock_data_exchange_complete(void *context, struct sk_buff *skb,\r\nint err)\r\n{\r\nstruct sock *sk = (struct sock *) context;\r\nBUG_ON(in_irq());\r\npr_debug("sk=%p err=%d\n", sk, err);\r\nif (err)\r\ngoto error;\r\nerr = rawsock_add_header(skb);\r\nif (err)\r\ngoto error;\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err)\r\ngoto error;\r\nspin_lock_bh(&sk->sk_write_queue.lock);\r\nif (!skb_queue_empty(&sk->sk_write_queue))\r\nschedule_work(&nfc_rawsock(sk)->tx_work);\r\nelse\r\nnfc_rawsock(sk)->tx_work_scheduled = false;\r\nspin_unlock_bh(&sk->sk_write_queue.lock);\r\nsock_put(sk);\r\nreturn;\r\nerror:\r\nrawsock_report_error(sk, err);\r\nsock_put(sk);\r\n}\r\nstatic void rawsock_tx_work(struct work_struct *work)\r\n{\r\nstruct sock *sk = to_rawsock_sk(work);\r\nstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\r\nu32 target_idx = nfc_rawsock(sk)->target_idx;\r\nstruct sk_buff *skb;\r\nint rc;\r\npr_debug("sk=%p target_idx=%u\n", sk, target_idx);\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nrawsock_write_queue_purge(sk);\r\nreturn;\r\n}\r\nskb = skb_dequeue(&sk->sk_write_queue);\r\nsock_hold(sk);\r\nrc = nfc_data_exchange(dev, target_idx, skb,\r\nrawsock_data_exchange_complete, sk);\r\nif (rc) {\r\nrawsock_report_error(sk, rc);\r\nsock_put(sk);\r\n}\r\n}\r\nstatic int rawsock_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\r\nstruct sk_buff *skb;\r\nint rc;\r\npr_debug("sock=%p sk=%p len=%zu\n", sock, sk, len);\r\nif (msg->msg_namelen)\r\nreturn -EOPNOTSUPP;\r\nif (sock->state != SS_CONNECTED)\r\nreturn -ENOTCONN;\r\nskb = nfc_alloc_send_skb(dev, sk, msg->msg_flags, len, &rc);\r\nif (skb == NULL)\r\nreturn rc;\r\nrc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\r\nif (rc < 0) {\r\nkfree_skb(skb);\r\nreturn rc;\r\n}\r\nspin_lock_bh(&sk->sk_write_queue.lock);\r\n__skb_queue_tail(&sk->sk_write_queue, skb);\r\nif (!nfc_rawsock(sk)->tx_work_scheduled) {\r\nschedule_work(&nfc_rawsock(sk)->tx_work);\r\nnfc_rawsock(sk)->tx_work_scheduled = true;\r\n}\r\nspin_unlock_bh(&sk->sk_write_queue.lock);\r\nreturn len;\r\n}\r\nstatic int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nint noblock = flags & MSG_DONTWAIT;\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nint copied;\r\nint rc;\r\npr_debug("sock=%p sk=%p len=%zu flags=%d\n", sock, sk, len, flags);\r\nskb = skb_recv_datagram(sk, flags, noblock, &rc);\r\nif (!skb)\r\nreturn rc;\r\nmsg->msg_namelen = 0;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nrc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nskb_free_datagram(sk, skb);\r\nreturn rc ? : copied;\r\n}\r\nstatic void rawsock_destruct(struct sock *sk)\r\n{\r\npr_debug("sk=%p\n", sk);\r\nif (sk->sk_state == TCP_ESTABLISHED) {\r\nnfc_deactivate_target(nfc_rawsock(sk)->dev,\r\nnfc_rawsock(sk)->target_idx);\r\nnfc_put_device(nfc_rawsock(sk)->dev);\r\n}\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\npr_err("Freeing alive NFC raw socket %p\n", sk);\r\nreturn;\r\n}\r\n}\r\nstatic int rawsock_create(struct net *net, struct socket *sock,\r\nconst struct nfc_protocol *nfc_proto)\r\n{\r\nstruct sock *sk;\r\npr_debug("sock=%p\n", sock);\r\nif (sock->type != SOCK_SEQPACKET)\r\nreturn -ESOCKTNOSUPPORT;\r\nsock->ops = &rawsock_ops;\r\nsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_init_data(sock, sk);\r\nsk->sk_protocol = nfc_proto->id;\r\nsk->sk_destruct = rawsock_destruct;\r\nsock->state = SS_UNCONNECTED;\r\nINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\r\nnfc_rawsock(sk)->tx_work_scheduled = false;\r\nreturn 0;\r\n}\r\nint __init rawsock_init(void)\r\n{\r\nint rc;\r\nrc = nfc_proto_register(&rawsock_nfc_proto);\r\nreturn rc;\r\n}\r\nvoid rawsock_exit(void)\r\n{\r\nnfc_proto_unregister(&rawsock_nfc_proto);\r\n}
