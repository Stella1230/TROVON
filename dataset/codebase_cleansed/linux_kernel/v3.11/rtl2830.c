static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[1+len];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = 1+len,\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl2830_rd(struct rtl2830_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl2830_wr_regs(struct rtl2830_priv *priv, u16 reg, const u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 reg2 = (reg >> 0) & 0xff;\r\nu8 page = (reg >> 8) & 0xff;\r\nif (page != priv->page) {\r\nret = rtl2830_wr(priv, 0x00, &page, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->page = page;\r\n}\r\nreturn rtl2830_wr(priv, reg2, val, len);\r\n}\r\nstatic int rtl2830_rd_regs(struct rtl2830_priv *priv, u16 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 reg2 = (reg >> 0) & 0xff;\r\nu8 page = (reg >> 8) & 0xff;\r\nif (page != priv->page) {\r\nret = rtl2830_wr(priv, 0x00, &page, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->page = page;\r\n}\r\nreturn rtl2830_rd(priv, reg2, val, len);\r\n}\r\nstatic int rtl2830_rd_reg(struct rtl2830_priv *priv, u16 reg, u8 *val)\r\n{\r\nreturn rtl2830_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int rtl2830_wr_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = rtl2830_rd_regs(priv, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn rtl2830_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int rtl2830_rd_reg_mask(struct rtl2830_priv *priv, u16 reg, u8 *val, u8 mask)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nret = rtl2830_rd_regs(priv, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\ntmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = tmp >> i;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_init(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nint ret, i;\r\nstruct rtl2830_reg_val_mask tab[] = {\r\n{ 0x00d, 0x01, 0x03 },\r\n{ 0x00d, 0x10, 0x10 },\r\n{ 0x104, 0x00, 0x1e },\r\n{ 0x105, 0x80, 0x80 },\r\n{ 0x110, 0x02, 0x03 },\r\n{ 0x110, 0x08, 0x0c },\r\n{ 0x17b, 0x00, 0x40 },\r\n{ 0x17d, 0x05, 0x0f },\r\n{ 0x17d, 0x50, 0xf0 },\r\n{ 0x18c, 0x08, 0x0f },\r\n{ 0x18d, 0x00, 0xc0 },\r\n{ 0x188, 0x05, 0x0f },\r\n{ 0x189, 0x00, 0xfc },\r\n{ 0x2d5, 0x02, 0x02 },\r\n{ 0x2f1, 0x02, 0x06 },\r\n{ 0x2f1, 0x20, 0xf8 },\r\n{ 0x16d, 0x00, 0x01 },\r\n{ 0x1a6, 0x00, 0x80 },\r\n{ 0x106, priv->cfg.vtop, 0x3f },\r\n{ 0x107, priv->cfg.krf, 0x3f },\r\n{ 0x112, 0x28, 0xff },\r\n{ 0x103, priv->cfg.agc_targ_val, 0xff },\r\n{ 0x00a, 0x02, 0x07 },\r\n{ 0x140, 0x0c, 0x3c },\r\n{ 0x140, 0x40, 0xc0 },\r\n{ 0x15b, 0x05, 0x07 },\r\n{ 0x15b, 0x28, 0x38 },\r\n{ 0x15c, 0x05, 0x07 },\r\n{ 0x15c, 0x28, 0x38 },\r\n{ 0x115, priv->cfg.spec_inv, 0x01 },\r\n{ 0x16f, 0x01, 0x07 },\r\n{ 0x170, 0x18, 0x38 },\r\n{ 0x172, 0x0f, 0x0f },\r\n{ 0x173, 0x08, 0x38 },\r\n{ 0x175, 0x01, 0x07 },\r\n{ 0x176, 0x00, 0xc0 },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = rtl2830_wr_reg_mask(priv, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = rtl2830_wr_regs(priv, 0x18f, "\x28\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_wr_regs(priv, 0x195,\r\n"\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_wr_reg_mask(priv, 0x101, 0x04, 0x04);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_wr_reg_mask(priv, 0x101, 0x00, 0x04);\r\nif (ret)\r\ngoto err;\r\npriv->sleeping = false;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\npriv->sleeping = true;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 500;\r\ns->step_size = fe->ops.info.frequency_stepsize * 2;\r\ns->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu64 num;\r\nu8 buf[3], tmp;\r\nu32 if_ctl, if_frequency;\r\nstatic const u8 bw_params1[3][34] = {\r\n{\r\n0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xfa, 0x00, 0x17, 0x00, 0x41,\r\n0x00, 0x64, 0x00, 0x67, 0x00, 0x38, 0x1f, 0xde, 0x1f, 0x7a,\r\n0x1f, 0x47, 0x1f, 0x7c, 0x00, 0x30, 0x01, 0x4b, 0x02, 0x82,\r\n0x03, 0x73, 0x03, 0xcf,\r\n}, {\r\n0x1f, 0xfa, 0x1f, 0xda, 0x1f, 0xc1, 0x1f, 0xb3, 0x1f, 0xca,\r\n0x00, 0x07, 0x00, 0x4d, 0x00, 0x6d, 0x00, 0x40, 0x1f, 0xca,\r\n0x1f, 0x4d, 0x1f, 0x2a, 0x1f, 0xb2, 0x00, 0xec, 0x02, 0x7e,\r\n0x03, 0xd0, 0x04, 0x53,\r\n}, {\r\n0x00, 0x10, 0x00, 0x0e, 0x1f, 0xf7, 0x1f, 0xc9, 0x1f, 0xa0,\r\n0x1f, 0xa6, 0x1f, 0xec, 0x00, 0x4e, 0x00, 0x7d, 0x00, 0x3a,\r\n0x1f, 0x98, 0x1f, 0x10, 0x1f, 0x40, 0x00, 0x75, 0x02, 0x5f,\r\n0x04, 0x24, 0x04, 0xdb,\r\n},\r\n};\r\nstatic const u8 bw_params2[3][6] = {\r\n{0xc3, 0x0c, 0x44, 0x33, 0x33, 0x30},\r\n{0xb8, 0xe3, 0x93, 0x99, 0x99, 0x98},\r\n{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64},\r\n};\r\ndev_dbg(&priv->i2c->dev,\r\n"%s: frequency=%d bandwidth_hz=%d inversion=%d\n",\r\n__func__, c->frequency, c->bandwidth_hz, c->inversion);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\ni = 0;\r\nbreak;\r\ncase 7000000:\r\ni = 1;\r\nbreak;\r\ncase 8000000:\r\ni = 2;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid bandwidth\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = rtl2830_wr_reg_mask(priv, 0x008, i << 1, 0x06);\r\nif (ret)\r\ngoto err;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nelse\r\nret = -EINVAL;\r\nif (ret < 0)\r\ngoto err;\r\nnum = if_frequency % priv->cfg.xtal;\r\nnum *= 0x400000;\r\nnum = div_u64(num, priv->cfg.xtal);\r\nnum = -num;\r\nif_ctl = num & 0x3fffff;\r\ndev_dbg(&priv->i2c->dev, "%s: if_frequency=%d if_ctl=%08x\n",\r\n__func__, if_frequency, if_ctl);\r\nret = rtl2830_rd_reg_mask(priv, 0x119, &tmp, 0xc0);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = tmp << 6;\r\nbuf[0] |= (if_ctl >> 16) & 0x3f;\r\nbuf[1] = (if_ctl >> 8) & 0xff;\r\nbuf[2] = (if_ctl >> 0) & 0xff;\r\nret = rtl2830_wr_regs(priv, 0x119, buf, 3);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_wr_regs(priv, 0x11c, &bw_params1[i][0], 17);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_wr_regs(priv, 0x12d, &bw_params1[i][17], 17);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_wr_regs(priv, 0x19d, bw_params2[i], 6);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu8 buf[3];\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2830_rd_regs(priv, 0x33c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_rd_reg(priv, 0x351, &buf[2]);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: TPS=%*ph\n", __func__, 3, buf);\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 2) & 1) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[2] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 3) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 tmp;\r\n*status = 0;\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2830_rd_reg_mask(priv, 0x351, &tmp, 0x78);\r\nif (ret)\r\ngoto err;\r\nif (tmp == 11) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n} else if (tmp == 10) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nint ret, hierarchy, constellation;\r\nu8 buf[2], tmp;\r\nu16 tmp16;\r\n#define CONSTELLATION_NUM 3\r\n#define HIERARCHY_NUM 4\r\nstatic const u32 snr_constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {\r\n{ 70705899, 70705899, 70705899, 70705899 },\r\n{ 82433173, 82433173, 87483115, 94445660 },\r\n{ 92888734, 92888734, 95487525, 99770748 },\r\n};\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2830_rd_reg(priv, 0x33c, &tmp);\r\nif (ret)\r\ngoto err;\r\nconstellation = (tmp >> 2) & 0x03;\r\nif (constellation > CONSTELLATION_NUM - 1)\r\ngoto err;\r\nhierarchy = (tmp >> 4) & 0x07;\r\nif (hierarchy > HIERARCHY_NUM - 1)\r\ngoto err;\r\nret = rtl2830_rd_regs(priv, 0x40c, buf, 2);\r\nif (ret)\r\ngoto err;\r\ntmp16 = buf[0] << 8 | buf[1];\r\nif (tmp16)\r\n*snr = (snr_constant[constellation][hierarchy] -\r\nintlog10(tmp16)) / ((1 << 24) / 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2830_rd_regs(priv, 0x34e, buf, 2);\r\nif (ret)\r\ngoto err;\r\n*ber = buf[0] << 8 | buf[1];\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nu16 if_agc_raw, if_agc;\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2830_rd_regs(priv, 0x359, buf, 2);\r\nif (ret)\r\ngoto err;\r\nif_agc_raw = (buf[0] << 8 | buf[1]) & 0x3fff;\r\nif (if_agc_raw & (1 << 9))\r\nif_agc = -(~(if_agc_raw - 1) & 0x1ff);\r\nelse\r\nif_agc = if_agc_raw;\r\n*strength = (u8) (55 - if_agc / 182);\r\n*strength |= *strength << 8;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic u32 rtl2830_tuner_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int rtl2830_tuner_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct rtl2830_priv *priv = i2c_get_adapdata(i2c_adap);\r\nint ret;\r\nret = rtl2830_wr_reg_mask(priv, 0x101, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = i2c_transfer(priv->i2c, msg, num);\r\nif (ret < 0)\r\ndev_warn(&priv->i2c->dev, "%s: tuner i2c failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstruct i2c_adapter *rtl2830_get_tuner_i2c_adapter(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\nreturn &priv->tuner_i2c_adapter;\r\n}\r\nstatic void rtl2830_release(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2830_priv *priv = fe->demodulator_priv;\r\ni2c_del_adapter(&priv->tuner_i2c_adapter);\r\nkfree(priv);\r\n}\r\nstruct dvb_frontend *rtl2830_attach(const struct rtl2830_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct rtl2830_priv *priv = NULL;\r\nint ret = 0;\r\nu8 tmp;\r\npriv = kzalloc(sizeof(struct rtl2830_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\ngoto err;\r\npriv->i2c = i2c;\r\nmemcpy(&priv->cfg, cfg, sizeof(struct rtl2830_config));\r\nret = rtl2830_rd_reg(priv, 0x000, &tmp);\r\nif (ret)\r\ngoto err;\r\nmemcpy(&priv->fe.ops, &rtl2830_ops, sizeof(struct dvb_frontend_ops));\r\npriv->fe.demodulator_priv = priv;\r\nstrlcpy(priv->tuner_i2c_adapter.name, "RTL2830 tuner I2C adapter",\r\nsizeof(priv->tuner_i2c_adapter.name));\r\npriv->tuner_i2c_adapter.algo = &rtl2830_tuner_i2c_algo;\r\npriv->tuner_i2c_adapter.algo_data = NULL;\r\ni2c_set_adapdata(&priv->tuner_i2c_adapter, priv);\r\nif (i2c_add_adapter(&priv->tuner_i2c_adapter) < 0) {\r\ndev_err(&i2c->dev,\r\n"%s: tuner i2c bus could not be initialized\n",\r\nKBUILD_MODNAME);\r\ngoto err;\r\n}\r\npriv->sleeping = true;\r\nreturn &priv->fe;\r\nerr:\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
