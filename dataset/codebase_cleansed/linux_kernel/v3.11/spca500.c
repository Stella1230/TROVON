static void reg_r(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\n__u16 length)\r\n{\r\nusb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex, gspca_dev->usb_buf, length, 500);\r\n}\r\nstatic int reg_w(struct gspca_dev *gspca_dev,\r\n__u16 req, __u16 index, __u16 value)\r\n{\r\nint ret;\r\nPDEBUG(D_USBO, "reg write: [0x%02x] = 0x%02x", index, value);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0, 500);\r\nif (ret < 0)\r\npr_err("reg write: error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int reg_r_12(struct gspca_dev *gspca_dev,\r\n__u16 req,\r\n__u16 index,\r\n__u16 length)\r\n{\r\nint ret;\r\ngspca_dev->usb_buf[1] = 0;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\nreq,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex,\r\ngspca_dev->usb_buf, length,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_r_12 err %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn (gspca_dev->usb_buf[1] << 8) + gspca_dev->usb_buf[0];\r\n}\r\nstatic int reg_r_wait(struct gspca_dev *gspca_dev,\r\n__u16 reg, __u16 index, __u16 value)\r\n{\r\nint ret, cnt = 20;\r\nwhile (--cnt > 0) {\r\nret = reg_r_12(gspca_dev, reg, index, 1);\r\nif (ret == value)\r\nreturn 0;\r\nmsleep(50);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int write_vector(struct gspca_dev *gspca_dev,\r\nconst __u16 data[][3])\r\n{\r\nint ret, i = 0;\r\nwhile (data[i][0] != 0 || data[i][1] != 0 || data[i][2] != 0) {\r\nret = reg_w(gspca_dev, data[i][0], data[i][2], data[i][1]);\r\nif (ret < 0)\r\nreturn ret;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spca50x_setup_qtable(struct gspca_dev *gspca_dev,\r\nunsigned int request,\r\nunsigned int ybase,\r\nunsigned int cbase,\r\nconst __u8 qtable[2][64])\r\n{\r\nint i, err;\r\nfor (i = 0; i < 64; i++) {\r\nerr = reg_w(gspca_dev, request, ybase + i, qtable[0][i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < 64; i++) {\r\nerr = reg_w(gspca_dev, request, cbase + i, qtable[1][i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void spca500_ping310(struct gspca_dev *gspca_dev)\r\n{\r\nreg_r(gspca_dev, 0x0d04, 2);\r\nPDEBUG(D_STREAM, "ClickSmart310 ping 0x0d04 0x%02x 0x%02x",\r\ngspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\r\n}\r\nstatic void spca500_clksmart310_init(struct gspca_dev *gspca_dev)\r\n{\r\nreg_r(gspca_dev, 0x0d05, 2);\r\nPDEBUG(D_STREAM, "ClickSmart310 init 0x0d05 0x%02x 0x%02x",\r\ngspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\r\nreg_w(gspca_dev, 0x00, 0x8167, 0x5a);\r\nspca500_ping310(gspca_dev);\r\nreg_w(gspca_dev, 0x00, 0x8168, 0x22);\r\nreg_w(gspca_dev, 0x00, 0x816a, 0xc0);\r\nreg_w(gspca_dev, 0x00, 0x816b, 0x0b);\r\nreg_w(gspca_dev, 0x00, 0x8169, 0x25);\r\nreg_w(gspca_dev, 0x00, 0x8157, 0x5b);\r\nreg_w(gspca_dev, 0x00, 0x8158, 0x5b);\r\nreg_w(gspca_dev, 0x00, 0x813f, 0x03);\r\nreg_w(gspca_dev, 0x00, 0x8151, 0x4a);\r\nreg_w(gspca_dev, 0x00, 0x8153, 0x78);\r\nreg_w(gspca_dev, 0x00, 0x0d01, 0x04);\r\nreg_w(gspca_dev, 0x00, 0x0d02, 0x01);\r\nreg_w(gspca_dev, 0x00, 0x8169, 0x25);\r\nreg_w(gspca_dev, 0x00, 0x0d01, 0x02);\r\n}\r\nstatic void spca500_setmode(struct gspca_dev *gspca_dev,\r\n__u8 xmult, __u8 ymult)\r\n{\r\nint mode;\r\nreg_w(gspca_dev, 0, 0x8001, xmult);\r\nreg_w(gspca_dev, 0, 0x8002, ymult);\r\nmode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\r\nreg_w(gspca_dev, 0, 0x8003, mode << 4);\r\n}\r\nstatic int spca500_full_reset(struct gspca_dev *gspca_dev)\r\n{\r\nint err;\r\nerr = reg_w(gspca_dev, 0xe0, 0x0001, 0x0000);\r\nif (err < 0)\r\nreturn err;\r\nerr = reg_r_wait(gspca_dev, 0x06, 0x0000, 0x0000);\r\nif (err < 0)\r\nreturn err;\r\nerr = reg_w(gspca_dev, 0xe0, 0x0000, 0x0000);\r\nif (err < 0)\r\nreturn err;\r\nerr = reg_r_wait(gspca_dev, 0x06, 0, 0);\r\nif (err < 0) {\r\nPERR("reg_r_wait() failed");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spca500_synch310(struct gspca_dev *gspca_dev)\r\n{\r\nif (usb_set_interface(gspca_dev->dev, gspca_dev->iface, 0) < 0) {\r\nPERR("Set packet size: set interface error");\r\ngoto error;\r\n}\r\nspca500_ping310(gspca_dev);\r\nreg_r(gspca_dev, 0x0d00, 1);\r\nPDEBUG(D_PACK, "ClickSmart310 sync alt: %d", gspca_dev->alt);\r\nif (usb_set_interface(gspca_dev->dev,\r\ngspca_dev->iface,\r\ngspca_dev->alt) < 0) {\r\nPERR("Set packet size: set interface error");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nreturn -EBUSY;\r\n}\r\nstatic void spca500_reinit(struct gspca_dev *gspca_dev)\r\n{\r\nint err;\r\n__u8 Data;\r\nreg_w(gspca_dev, 0x00, 0x0d01, 0x01);\r\nreg_w(gspca_dev, 0x00, 0x0d03, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x0d02, 0x01);\r\nreg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nerr = spca50x_setup_qtable(gspca_dev, 0x00, 0x8800, 0x8840,\r\nqtable_pocketdv);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed on init");\r\nreg_w(gspca_dev, 0x00, 0x8880, 2);\r\nreg_w(gspca_dev, 0x00, 0x800a, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x820f, 0x01);\r\nreg_w(gspca_dev, 0x00, 0x870a, 0x04);\r\nreg_w(gspca_dev, 0, 0x8003, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nmsleep(2000);\r\nif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0) {\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\nsd->subtype = id->driver_info;\r\nif (sd->subtype != LogitechClickSmart310) {\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\n} else {\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_STREAM, "SPCA500 init");\r\nif (sd->subtype == LogitechClickSmart310)\r\nspca500_clksmart310_init(gspca_dev);\r\nPDEBUG(D_STREAM, "SPCA500 init done");\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err;\r\n__u8 Data;\r\n__u8 xmult, ymult;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x22);\r\njpeg_set_qual(sd->jpeg_hdr, QUALITY);\r\nif (sd->subtype == LogitechClickSmart310) {\r\nxmult = 0x16;\r\nymult = 0x12;\r\n} else {\r\nxmult = 0x28;\r\nymult = 0x1e;\r\n}\r\nreg_r(gspca_dev, 0x8a04, 1);\r\nPDEBUG(D_STREAM, "Spca500 Sensor Address 0x%02x",\r\ngspca_dev->usb_buf[0]);\r\nPDEBUG(D_STREAM, "Spca500 curr_mode: %d Xmult: 0x%02x, Ymult: 0x%02x",\r\ngspca_dev->curr_mode, xmult, ymult);\r\nswitch (sd->subtype) {\r\ncase LogitechClickSmart310:\r\nspca500_setmode(gspca_dev, xmult, ymult);\r\nreg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nreg_w(gspca_dev, 0x00, 0x8880, 3);\r\nerr = spca50x_setup_qtable(gspca_dev,\r\n0x00, 0x8800, 0x8840,\r\nqtable_creative_pccam);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed");\r\nreg_w(gspca_dev, 0x00, 0x870a, 0x04);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nmsleep(500);\r\nif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\r\nPERR("reg_r_wait() failed");\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\nspca500_synch310(gspca_dev);\r\nwrite_vector(gspca_dev, spca500_visual_defaults);\r\nspca500_setmode(gspca_dev, xmult, ymult);\r\nerr = reg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nif (err < 0)\r\nPERR("failed to enable drop packet");\r\nreg_w(gspca_dev, 0x00, 0x8880, 3);\r\nerr = spca50x_setup_qtable(gspca_dev,\r\n0x00, 0x8800, 0x8840,\r\nqtable_creative_pccam);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed");\r\nreg_w(gspca_dev, 0x00, 0x870a, 0x04);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\r\nPERR("reg_r_wait() failed");\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\nbreak;\r\ncase CreativePCCam300:\r\ncase IntelPocketPCCamera:\r\nerr = spca500_full_reset(gspca_dev);\r\nif (err < 0)\r\nPERR("spca500_full_reset failed");\r\nerr = reg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nif (err < 0)\r\nPERR("failed to enable drop packet");\r\nreg_w(gspca_dev, 0x00, 0x8880, 3);\r\nerr = spca50x_setup_qtable(gspca_dev,\r\n0x00, 0x8800, 0x8840,\r\nqtable_creative_pccam);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed");\r\nspca500_setmode(gspca_dev, xmult, ymult);\r\nreg_w(gspca_dev, 0x20, 0x0001, 0x0004);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\r\nPERR("reg_r_wait() failed");\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\nbreak;\r\ncase KodakEZ200:\r\nerr = spca500_full_reset(gspca_dev);\r\nif (err < 0)\r\nPERR("spca500_full_reset failed");\r\nreg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nreg_w(gspca_dev, 0x00, 0x8880, 0);\r\nerr = spca50x_setup_qtable(gspca_dev,\r\n0x00, 0x8800, 0x8840,\r\nqtable_kodak_ez200);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed");\r\nspca500_setmode(gspca_dev, xmult, ymult);\r\nreg_w(gspca_dev, 0x20, 0x0001, 0x0004);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nif (reg_r_wait(gspca_dev, 0, 0x8000, 0x44) != 0)\r\nPERR("reg_r_wait() failed");\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\nbreak;\r\ncase BenqDC1016:\r\ncase DLinkDSC350:\r\ncase AiptekPocketDV:\r\ncase Gsmartmini:\r\ncase MustekGsmart300:\r\ncase PalmPixDC85:\r\ncase Optimedia:\r\ncase ToptroIndus:\r\ncase AgfaCl20:\r\nspca500_reinit(gspca_dev);\r\nreg_w(gspca_dev, 0x00, 0x0d01, 0x01);\r\nreg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nerr = spca50x_setup_qtable(gspca_dev,\r\n0x00, 0x8800, 0x8840, qtable_pocketdv);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed");\r\nreg_w(gspca_dev, 0x00, 0x8880, 2);\r\nreg_w(gspca_dev, 0x00, 0x800a, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x820f, 0x01);\r\nreg_w(gspca_dev, 0x00, 0x870a, 0x04);\r\nspca500_setmode(gspca_dev, xmult, ymult);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nreg_r_wait(gspca_dev, 0, 0x8000, 0x44);\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\nbreak;\r\ncase LogitechTraveler:\r\ncase LogitechClickSmart510:\r\nreg_w(gspca_dev, 0x02, 0x00, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x850a, 0x0001);\r\nerr = spca50x_setup_qtable(gspca_dev,\r\n0x00, 0x8800,\r\n0x8840, qtable_creative_pccam);\r\nif (err < 0)\r\nPERR("spca50x_setup_qtable failed");\r\nreg_w(gspca_dev, 0x00, 0x8880, 3);\r\nreg_w(gspca_dev, 0x00, 0x800a, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x870a, 0x04);\r\nspca500_setmode(gspca_dev, xmult, ymult);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nreg_r_wait(gspca_dev, 0, 0x8000, 0x44);\r\nreg_r(gspca_dev, 0x816b, 1);\r\nData = gspca_dev->usb_buf[0];\r\nreg_w(gspca_dev, 0x00, 0x816b, Data);\r\nwrite_vector(gspca_dev, Clicksmart510_defaults);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 0, 0x8003, 0x00);\r\nreg_w(gspca_dev, 0x00, 0x8000, 0x0004);\r\nreg_r(gspca_dev, 0x8000, 1);\r\nPDEBUG(D_STREAM, "stop SPCA500 done reg8000: 0x%2x",\r\ngspca_dev->usb_buf[0]);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nstatic __u8 ffd9[] = {0xff, 0xd9};\r\nif (data[0] == 0xff) {\r\nif (data[1] != 0x01) {\r\nreturn;\r\n}\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nffd9, 2);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ndata += SPCA500_OFFSET_DATA;\r\nlen -= SPCA500_OFFSET_DATA;\r\n} else {\r\ndata += 1;\r\nlen -= 1;\r\n}\r\ni = 0;\r\ndo {\r\nif (data[i] == 0xff) {\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, i + 1);\r\nlen -= i;\r\ndata += i;\r\n*data = 0x00;\r\ni = 0;\r\n}\r\ni++;\r\n} while (i < len);\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_w(gspca_dev, 0x00, 0x8167,\r\n(__u8) (val - 128));\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_w(gspca_dev, 0x00, 0x8168, val);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_w(gspca_dev, 0x00, 0x8169, val);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 3);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 63, 1, 31);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 63, 1, 31);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
