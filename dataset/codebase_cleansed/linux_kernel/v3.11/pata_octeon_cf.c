static unsigned int ns_to_tim_reg(unsigned int tim_mult, unsigned int nsecs)\r\n{\r\nunsigned int val;\r\nval = DIV_ROUND_UP(nsecs * (octeon_get_io_clock_rate() / 1000000),\r\n1000 * tim_mult);\r\nreturn val;\r\n}\r\nstatic void octeon_cf_set_boot_reg_cfg(int cs, unsigned int multiplier)\r\n{\r\nunion cvmx_mio_boot_reg_cfgx reg_cfg;\r\nunsigned int tim_mult;\r\nswitch (multiplier) {\r\ncase 8:\r\ntim_mult = 3;\r\nbreak;\r\ncase 4:\r\ntim_mult = 0;\r\nbreak;\r\ncase 2:\r\ntim_mult = 2;\r\nbreak;\r\ndefault:\r\ntim_mult = 1;\r\nbreak;\r\n}\r\nreg_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(cs));\r\nreg_cfg.s.dmack = 0;\r\nreg_cfg.s.tim_mult = tim_mult;\r\nreg_cfg.s.rd_dly = 0;\r\nreg_cfg.s.sam = 0;\r\nreg_cfg.s.we_ext = 0;\r\nreg_cfg.s.oe_ext = 0;\r\nreg_cfg.s.en = 1;\r\nreg_cfg.s.orbit = 0;\r\nreg_cfg.s.ale = 0;\r\ncvmx_write_csr(CVMX_MIO_BOOT_REG_CFGX(cs), reg_cfg.u64);\r\n}\r\nstatic void octeon_cf_set_piomode(struct ata_port *ap, struct ata_device *dev)\r\n{\r\nstruct octeon_cf_port *cf_port = ap->private_data;\r\nunion cvmx_mio_boot_reg_timx reg_tim;\r\nint T;\r\nstruct ata_timing timing;\r\nunsigned int div;\r\nint use_iordy;\r\nint trh;\r\nint pause;\r\nint t1;\r\nint t2;\r\nint t2i;\r\nif (octeon_get_io_clock_rate() <= 800000000)\r\ndiv = 4;\r\nelse\r\ndiv = 8;\r\nT = (int)((1000000000000LL * div) / octeon_get_io_clock_rate());\r\nif (ata_timing_compute(dev, dev->pio_mode, &timing, T, T))\r\nBUG();\r\nt1 = timing.setup;\r\nif (t1)\r\nt1--;\r\nt2 = timing.active;\r\nif (t2)\r\nt2--;\r\nt2i = timing.act8b;\r\nif (t2i)\r\nt2i--;\r\ntrh = ns_to_tim_reg(div, 20);\r\nif (trh)\r\ntrh--;\r\npause = (int)timing.cycle - (int)timing.active -\r\n(int)timing.setup - trh;\r\nif (pause < 0)\r\npause = 0;\r\nif (pause)\r\npause--;\r\nocteon_cf_set_boot_reg_cfg(cf_port->cs0, div);\r\nif (cf_port->is_true_ide)\r\nocteon_cf_set_boot_reg_cfg(cf_port->cs1, div);\r\nuse_iordy = ata_pio_need_iordy(dev);\r\nreg_tim.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs0));\r\nreg_tim.s.pagem = 0;\r\nreg_tim.s.waitm = use_iordy;\r\nreg_tim.s.pages = 0;\r\nreg_tim.s.ale = 0;\r\nreg_tim.s.page = 0;\r\nreg_tim.s.wait = 0;\r\nreg_tim.s.pause = pause;\r\nreg_tim.s.wr_hld = trh;\r\nreg_tim.s.rd_hld = trh;\r\nreg_tim.s.we = t2;\r\nreg_tim.s.oe = t2;\r\nreg_tim.s.ce = ns_to_tim_reg(div, 5);\r\nreg_tim.s.adr = 0;\r\ncvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs0), reg_tim.u64);\r\nif (cf_port->is_true_ide)\r\ncvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs1),\r\nreg_tim.u64);\r\n}\r\nstatic void octeon_cf_set_dmamode(struct ata_port *ap, struct ata_device *dev)\r\n{\r\nstruct octeon_cf_port *cf_port = ap->private_data;\r\nunion cvmx_mio_boot_pin_defs pin_defs;\r\nunion cvmx_mio_boot_dma_timx dma_tim;\r\nunsigned int oe_a;\r\nunsigned int oe_n;\r\nunsigned int dma_ackh;\r\nunsigned int dma_arq;\r\nunsigned int pause;\r\nunsigned int T0, Tkr, Td;\r\nunsigned int tim_mult;\r\nint c;\r\nconst struct ata_timing *timing;\r\ntiming = ata_timing_find_mode(dev->dma_mode);\r\nT0 = timing->cycle;\r\nTd = timing->active;\r\nTkr = timing->recover;\r\ndma_ackh = timing->dmack_hold;\r\ndma_tim.u64 = 0;\r\ntim_mult = 4;\r\ndma_arq = 8;\r\npause = 25 - dma_arq * 1000 /\r\n(octeon_get_io_clock_rate() / 1000000);\r\noe_a = Td;\r\noe_n = max(T0 - oe_a, Tkr);\r\npin_defs.u64 = cvmx_read_csr(CVMX_MIO_BOOT_PIN_DEFS);\r\nc = (cf_port->dma_base & 8) >> 3;\r\ndma_tim.s.dmack_pi = (pin_defs.u64 & (1ull << (11 + c))) ? 0 : 1;\r\ndma_tim.s.oe_n = ns_to_tim_reg(tim_mult, oe_n);\r\ndma_tim.s.oe_a = ns_to_tim_reg(tim_mult, oe_a);\r\ndma_tim.s.dmack_s = ns_to_tim_reg(tim_mult, 20);\r\ndma_tim.s.dmack_h = ns_to_tim_reg(tim_mult, dma_ackh);\r\ndma_tim.s.dmarq = dma_arq;\r\ndma_tim.s.pause = ns_to_tim_reg(tim_mult, pause);\r\ndma_tim.s.rd_dly = 0;\r\ndma_tim.s.we_n = ns_to_tim_reg(tim_mult, oe_n);\r\ndma_tim.s.we_a = ns_to_tim_reg(tim_mult, oe_a);\r\npr_debug("ns to ticks (mult %d) of %d is: %d\n", tim_mult, 60,\r\nns_to_tim_reg(tim_mult, 60));\r\npr_debug("oe_n: %d, oe_a: %d, dmack_s: %d, dmack_h: %d, dmarq: %d, pause: %d\n",\r\ndma_tim.s.oe_n, dma_tim.s.oe_a, dma_tim.s.dmack_s,\r\ndma_tim.s.dmack_h, dma_tim.s.dmarq, dma_tim.s.pause);\r\ncvmx_write_csr(cf_port->dma_base + DMA_TIM, dma_tim.u64);\r\n}\r\nstatic unsigned int octeon_cf_data_xfer8(struct ata_device *dev,\r\nunsigned char *buffer,\r\nunsigned int buflen,\r\nint rw)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nvoid __iomem *data_addr = ap->ioaddr.data_addr;\r\nunsigned long words;\r\nint count;\r\nwords = buflen;\r\nif (rw) {\r\ncount = 16;\r\nwhile (words--) {\r\niowrite8(*buffer, data_addr);\r\nbuffer++;\r\nif (--count == 0) {\r\nioread8(ap->ioaddr.altstatus_addr);\r\ncount = 16;\r\n}\r\n}\r\n} else {\r\nioread8_rep(data_addr, buffer, words);\r\n}\r\nreturn buflen;\r\n}\r\nstatic unsigned int octeon_cf_data_xfer16(struct ata_device *dev,\r\nunsigned char *buffer,\r\nunsigned int buflen,\r\nint rw)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nvoid __iomem *data_addr = ap->ioaddr.data_addr;\r\nunsigned long words;\r\nint count;\r\nwords = buflen / 2;\r\nif (rw) {\r\ncount = 16;\r\nwhile (words--) {\r\niowrite16(*(uint16_t *)buffer, data_addr);\r\nbuffer += sizeof(uint16_t);\r\nif (--count == 0) {\r\nioread8(ap->ioaddr.altstatus_addr);\r\ncount = 16;\r\n}\r\n}\r\n} else {\r\nwhile (words--) {\r\n*(uint16_t *)buffer = ioread16(data_addr);\r\nbuffer += sizeof(uint16_t);\r\n}\r\n}\r\nif (unlikely(buflen & 0x01)) {\r\n__le16 align_buf[1] = { 0 };\r\nif (rw == READ) {\r\nalign_buf[0] = cpu_to_le16(ioread16(data_addr));\r\nmemcpy(buffer, align_buf, 1);\r\n} else {\r\nmemcpy(align_buf, buffer, 1);\r\niowrite16(le16_to_cpu(align_buf[0]), data_addr);\r\n}\r\nwords++;\r\n}\r\nreturn buflen;\r\n}\r\nstatic void octeon_cf_tf_read16(struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\nu16 blob;\r\nvoid __iomem *base = ap->ioaddr.data_addr;\r\nblob = __raw_readw(base + 0xc);\r\ntf->feature = blob >> 8;\r\nblob = __raw_readw(base + 2);\r\ntf->nsect = blob & 0xff;\r\ntf->lbal = blob >> 8;\r\nblob = __raw_readw(base + 4);\r\ntf->lbam = blob & 0xff;\r\ntf->lbah = blob >> 8;\r\nblob = __raw_readw(base + 6);\r\ntf->device = blob & 0xff;\r\ntf->command = blob >> 8;\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\nif (likely(ap->ioaddr.ctl_addr)) {\r\niowrite8(tf->ctl | ATA_HOB, ap->ioaddr.ctl_addr);\r\nblob = __raw_readw(base + 0xc);\r\ntf->hob_feature = blob >> 8;\r\nblob = __raw_readw(base + 2);\r\ntf->hob_nsect = blob & 0xff;\r\ntf->hob_lbal = blob >> 8;\r\nblob = __raw_readw(base + 4);\r\ntf->hob_lbam = blob & 0xff;\r\ntf->hob_lbah = blob >> 8;\r\niowrite8(tf->ctl, ap->ioaddr.ctl_addr);\r\nap->last_ctl = tf->ctl;\r\n} else {\r\nWARN_ON(1);\r\n}\r\n}\r\n}\r\nstatic u8 octeon_cf_check_status16(struct ata_port *ap)\r\n{\r\nu16 blob;\r\nvoid __iomem *base = ap->ioaddr.data_addr;\r\nblob = __raw_readw(base + 6);\r\nreturn blob >> 8;\r\n}\r\nstatic int octeon_cf_softreset16(struct ata_link *link, unsigned int *classes,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nvoid __iomem *base = ap->ioaddr.data_addr;\r\nint rc;\r\nu8 err;\r\nDPRINTK("about to softreset\n");\r\n__raw_writew(ap->ctl, base + 0xe);\r\nudelay(20);\r\n__raw_writew(ap->ctl | ATA_SRST, base + 0xe);\r\nudelay(20);\r\n__raw_writew(ap->ctl, base + 0xe);\r\nrc = ata_sff_wait_after_reset(link, 1, deadline);\r\nif (rc) {\r\nata_link_err(link, "SRST failed (errno=%d)\n", rc);\r\nreturn rc;\r\n}\r\nclasses[0] = ata_sff_dev_classify(&link->device[0], 1, &err);\r\nDPRINTK("EXIT, classes[0]=%u [1]=%u\n", classes[0], classes[1]);\r\nreturn 0;\r\n}\r\nstatic void octeon_cf_tf_load16(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nvoid __iomem *base = ap->ioaddr.data_addr;\r\nif (tf->ctl != ap->last_ctl) {\r\niowrite8(tf->ctl, ap->ioaddr.ctl_addr);\r\nap->last_ctl = tf->ctl;\r\nata_wait_idle(ap);\r\n}\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\n__raw_writew(tf->hob_feature << 8, base + 0xc);\r\n__raw_writew(tf->hob_nsect | tf->hob_lbal << 8, base + 2);\r\n__raw_writew(tf->hob_lbam | tf->hob_lbah << 8, base + 4);\r\nVPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",\r\ntf->hob_feature,\r\ntf->hob_nsect,\r\ntf->hob_lbal,\r\ntf->hob_lbam,\r\ntf->hob_lbah);\r\n}\r\nif (is_addr) {\r\n__raw_writew(tf->feature << 8, base + 0xc);\r\n__raw_writew(tf->nsect | tf->lbal << 8, base + 2);\r\n__raw_writew(tf->lbam | tf->lbah << 8, base + 4);\r\nVPRINTK("feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",\r\ntf->feature,\r\ntf->nsect,\r\ntf->lbal,\r\ntf->lbam,\r\ntf->lbah);\r\n}\r\nata_wait_idle(ap);\r\n}\r\nstatic void octeon_cf_dev_select(struct ata_port *ap, unsigned int device)\r\n{\r\nreturn;\r\n}\r\nstatic void octeon_cf_exec_command16(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nvoid __iomem *base = ap->ioaddr.data_addr;\r\nu16 blob;\r\nif (tf->flags & ATA_TFLAG_DEVICE) {\r\nVPRINTK("device 0x%X\n", tf->device);\r\nblob = tf->device;\r\n} else {\r\nblob = 0;\r\n}\r\nDPRINTK("ata%u: cmd 0x%X\n", ap->print_id, tf->command);\r\nblob |= (tf->command << 8);\r\n__raw_writew(blob, base + 6);\r\nata_wait_idle(ap);\r\n}\r\nstatic void octeon_cf_ata_port_noaction(struct ata_port *ap)\r\n{\r\n}\r\nstatic void octeon_cf_dma_setup(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct octeon_cf_port *cf_port;\r\ncf_port = ap->private_data;\r\nDPRINTK("ENTER\n");\r\nqc->cursg = qc->sg;\r\ncf_port->dma_finished = 0;\r\nap->ops->sff_exec_command(ap, &qc->tf);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic void octeon_cf_dma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct octeon_cf_port *cf_port = qc->ap->private_data;\r\nunion cvmx_mio_boot_dma_cfgx mio_boot_dma_cfg;\r\nunion cvmx_mio_boot_dma_intx mio_boot_dma_int;\r\nstruct scatterlist *sg;\r\nVPRINTK("%d scatterlists\n", qc->n_elem);\r\nsg = qc->cursg;\r\nBUG_ON(!sg);\r\nmio_boot_dma_int.u64 = 0;\r\nmio_boot_dma_int.s.done = 1;\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT, mio_boot_dma_int.u64);\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT_EN, mio_boot_dma_int.u64);\r\nmio_boot_dma_cfg.u64 = 0;\r\n#ifdef __LITTLE_ENDIAN\r\nmio_boot_dma_cfg.s.endian = 1;\r\n#endif\r\nmio_boot_dma_cfg.s.en = 1;\r\nmio_boot_dma_cfg.s.rw = ((qc->tf.flags & ATA_TFLAG_WRITE) != 0);\r\nmio_boot_dma_cfg.s.clr = 0;\r\nmio_boot_dma_cfg.s.size = sg_dma_len(sg) / 2 - 1;\r\nmio_boot_dma_cfg.s.swap8 = 1;\r\nmio_boot_dma_cfg.s.adr = sg_dma_address(sg);\r\nVPRINTK("%s %d bytes address=%p\n",\r\n(mio_boot_dma_cfg.s.rw) ? "write" : "read", sg->length,\r\n(void *)(unsigned long)mio_boot_dma_cfg.s.adr);\r\ncvmx_write_csr(cf_port->dma_base + DMA_CFG, mio_boot_dma_cfg.u64);\r\n}\r\nstatic unsigned int octeon_cf_dma_finished(struct ata_port *ap,\r\nstruct ata_queued_cmd *qc)\r\n{\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nstruct octeon_cf_port *cf_port = ap->private_data;\r\nunion cvmx_mio_boot_dma_cfgx dma_cfg;\r\nunion cvmx_mio_boot_dma_intx dma_int;\r\nu8 status;\r\nVPRINTK("ata%u: protocol %d task_state %d\n",\r\nap->print_id, qc->tf.protocol, ap->hsm_task_state);\r\nif (ap->hsm_task_state != HSM_ST_LAST)\r\nreturn 0;\r\ndma_cfg.u64 = cvmx_read_csr(cf_port->dma_base + DMA_CFG);\r\nif (dma_cfg.s.size != 0xfffff) {\r\nqc->err_mask |= AC_ERR_HOST_BUS;\r\nap->hsm_task_state = HSM_ST_ERR;\r\n}\r\ndma_cfg.u64 = 0;\r\ndma_cfg.s.size = -1;\r\ncvmx_write_csr(cf_port->dma_base + DMA_CFG, dma_cfg.u64);\r\ndma_int.u64 = 0;\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT_EN, dma_int.u64);\r\ndma_int.s.done = 1;\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);\r\nstatus = ap->ops->sff_check_status(ap);\r\nata_sff_hsm_move(ap, qc, status, 0);\r\nif (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA))\r\nata_ehi_push_desc(ehi, "DMA stat 0x%x", status);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t octeon_cf_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct octeon_cf_port *cf_port;\r\nint i;\r\nunsigned int handled = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nDPRINTK("ENTER\n");\r\nfor (i = 0; i < host->n_ports; i++) {\r\nu8 status;\r\nstruct ata_port *ap;\r\nstruct ata_queued_cmd *qc;\r\nunion cvmx_mio_boot_dma_intx dma_int;\r\nunion cvmx_mio_boot_dma_cfgx dma_cfg;\r\nap = host->ports[i];\r\ncf_port = ap->private_data;\r\ndma_int.u64 = cvmx_read_csr(cf_port->dma_base + DMA_INT);\r\ndma_cfg.u64 = cvmx_read_csr(cf_port->dma_base + DMA_CFG);\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (!qc || (qc->tf.flags & ATA_TFLAG_POLLING))\r\ncontinue;\r\nif (dma_int.s.done && !dma_cfg.s.en) {\r\nif (!sg_is_last(qc->cursg)) {\r\nqc->cursg = sg_next(qc->cursg);\r\nhandled = 1;\r\nocteon_cf_dma_start(qc);\r\ncontinue;\r\n} else {\r\ncf_port->dma_finished = 1;\r\n}\r\n}\r\nif (!cf_port->dma_finished)\r\ncontinue;\r\nstatus = ioread8(ap->ioaddr.altstatus_addr);\r\nif (status & (ATA_BUSY | ATA_DRQ)) {\r\ndma_int.u64 = 0;\r\ndma_int.s.done = 1;\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT,\r\ndma_int.u64);\r\nhrtimer_start_range_ns(&cf_port->delayed_finish,\r\nns_to_ktime(OCTEON_CF_BUSY_POLL_INTERVAL),\r\nOCTEON_CF_BUSY_POLL_INTERVAL / 5,\r\nHRTIMER_MODE_REL);\r\nhandled = 1;\r\n} else {\r\nhandled |= octeon_cf_dma_finished(ap, qc);\r\n}\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nDPRINTK("EXIT\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic enum hrtimer_restart octeon_cf_delayed_finish(struct hrtimer *hrt)\r\n{\r\nstruct octeon_cf_port *cf_port = container_of(hrt,\r\nstruct octeon_cf_port,\r\ndelayed_finish);\r\nstruct ata_port *ap = cf_port->ap;\r\nstruct ata_host *host = ap->host;\r\nstruct ata_queued_cmd *qc;\r\nunsigned long flags;\r\nu8 status;\r\nenum hrtimer_restart rv = HRTIMER_NORESTART;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (ap->hsm_task_state != HSM_ST_LAST || !cf_port->dma_finished)\r\ngoto out;\r\nstatus = ioread8(ap->ioaddr.altstatus_addr);\r\nif (status & (ATA_BUSY | ATA_DRQ)) {\r\nhrtimer_forward_now(hrt,\r\nns_to_ktime(OCTEON_CF_BUSY_POLL_INTERVAL));\r\nrv = HRTIMER_RESTART;\r\ngoto out;\r\n}\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)))\r\nocteon_cf_dma_finished(ap, qc);\r\nout:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn rv;\r\n}\r\nstatic void octeon_cf_dev_config(struct ata_device *dev)\r\n{\r\ndev->max_sectors = min(dev->max_sectors, 4095U);\r\n}\r\nstatic int octeon_cf_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int octeon_cf_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_DMA:\r\nWARN_ON(qc->tf.flags & ATA_TFLAG_POLLING);\r\nap->ops->sff_tf_load(ap, &qc->tf);\r\nocteon_cf_dma_setup(qc);\r\nocteon_cf_dma_start(qc);\r\nap->hsm_task_state = HSM_ST_LAST;\r\nbreak;\r\ncase ATAPI_PROT_DMA:\r\ndev_err(ap->dev, "Error, ATAPI not supported\n");\r\nBUG();\r\ndefault:\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_cf_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_cs0, *res_cs1;\r\nbool is_16bit;\r\nconst __be32 *cs_num;\r\nstruct property *reg_prop;\r\nint n_addr, n_size, reg_len;\r\nstruct device_node *node;\r\nconst void *prop;\r\nvoid __iomem *cs0;\r\nvoid __iomem *cs1 = NULL;\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nint irq = 0;\r\nirq_handler_t irq_handler = NULL;\r\nvoid __iomem *base;\r\nstruct octeon_cf_port *cf_port;\r\nint rv = -ENOMEM;\r\nnode = pdev->dev.of_node;\r\nif (node == NULL)\r\nreturn -EINVAL;\r\ncf_port = kzalloc(sizeof(*cf_port), GFP_KERNEL);\r\nif (!cf_port)\r\nreturn -ENOMEM;\r\ncf_port->is_true_ide = (of_find_property(node, "cavium,true-ide", NULL) != NULL);\r\nprop = of_get_property(node, "cavium,bus-width", NULL);\r\nif (prop)\r\nis_16bit = (be32_to_cpup(prop) == 16);\r\nelse\r\nis_16bit = false;\r\nn_addr = of_n_addr_cells(node);\r\nn_size = of_n_size_cells(node);\r\nreg_prop = of_find_property(node, "reg", &reg_len);\r\nif (!reg_prop || reg_len < sizeof(__be32)) {\r\nrv = -EINVAL;\r\ngoto free_cf_port;\r\n}\r\ncs_num = reg_prop->value;\r\ncf_port->cs0 = be32_to_cpup(cs_num);\r\nif (cf_port->is_true_ide) {\r\nstruct device_node *dma_node;\r\ndma_node = of_parse_phandle(node,\r\n"cavium,dma-engine-handle", 0);\r\nif (dma_node) {\r\nstruct platform_device *dma_dev;\r\ndma_dev = of_find_device_by_node(dma_node);\r\nif (dma_dev) {\r\nstruct resource *res_dma;\r\nint i;\r\nres_dma = platform_get_resource(dma_dev, IORESOURCE_MEM, 0);\r\nif (!res_dma) {\r\nof_node_put(dma_node);\r\nrv = -EINVAL;\r\ngoto free_cf_port;\r\n}\r\ncf_port->dma_base = (u64)devm_ioremap_nocache(&pdev->dev, res_dma->start,\r\nresource_size(res_dma));\r\nif (!cf_port->dma_base) {\r\nof_node_put(dma_node);\r\nrv = -EINVAL;\r\ngoto free_cf_port;\r\n}\r\nirq_handler = octeon_cf_interrupt;\r\ni = platform_get_irq(dma_dev, 0);\r\nif (i > 0)\r\nirq = i;\r\n}\r\nof_node_put(dma_node);\r\n}\r\nres_cs1 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res_cs1) {\r\nrv = -EINVAL;\r\ngoto free_cf_port;\r\n}\r\ncs1 = devm_ioremap_nocache(&pdev->dev, res_cs1->start,\r\nresource_size(res_cs1));\r\nif (!cs1)\r\ngoto free_cf_port;\r\nif (reg_len < (n_addr + n_size + 1) * sizeof(__be32)) {\r\nrv = -EINVAL;\r\ngoto free_cf_port;\r\n}\r\ncs_num += n_addr + n_size;\r\ncf_port->cs1 = be32_to_cpup(cs_num);\r\n}\r\nres_cs0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_cs0) {\r\nrv = -EINVAL;\r\ngoto free_cf_port;\r\n}\r\ncs0 = devm_ioremap_nocache(&pdev->dev, res_cs0->start,\r\nresource_size(res_cs0));\r\nif (!cs0)\r\ngoto free_cf_port;\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host)\r\ngoto free_cf_port;\r\nap = host->ports[0];\r\nap->private_data = cf_port;\r\npdev->dev.platform_data = cf_port;\r\ncf_port->ap = ap;\r\nap->ops = &octeon_cf_ops;\r\nap->pio_mask = ATA_PIO6;\r\nap->flags |= ATA_FLAG_NO_ATAPI | ATA_FLAG_PIO_POLLING;\r\nif (!is_16bit) {\r\nbase = cs0 + 0x800;\r\nap->ioaddr.cmd_addr = base;\r\nata_sff_std_ports(&ap->ioaddr);\r\nap->ioaddr.altstatus_addr = base + 0xe;\r\nap->ioaddr.ctl_addr = base + 0xe;\r\nocteon_cf_ops.sff_data_xfer = octeon_cf_data_xfer8;\r\n} else if (cf_port->is_true_ide) {\r\nbase = cs0;\r\nap->ioaddr.cmd_addr = base + (ATA_REG_CMD << 1) + 1;\r\nap->ioaddr.data_addr = base + (ATA_REG_DATA << 1);\r\nap->ioaddr.error_addr = base + (ATA_REG_ERR << 1) + 1;\r\nap->ioaddr.feature_addr = base + (ATA_REG_FEATURE << 1) + 1;\r\nap->ioaddr.nsect_addr = base + (ATA_REG_NSECT << 1) + 1;\r\nap->ioaddr.lbal_addr = base + (ATA_REG_LBAL << 1) + 1;\r\nap->ioaddr.lbam_addr = base + (ATA_REG_LBAM << 1) + 1;\r\nap->ioaddr.lbah_addr = base + (ATA_REG_LBAH << 1) + 1;\r\nap->ioaddr.device_addr = base + (ATA_REG_DEVICE << 1) + 1;\r\nap->ioaddr.status_addr = base + (ATA_REG_STATUS << 1) + 1;\r\nap->ioaddr.command_addr = base + (ATA_REG_CMD << 1) + 1;\r\nap->ioaddr.altstatus_addr = cs1 + (6 << 1) + 1;\r\nap->ioaddr.ctl_addr = cs1 + (6 << 1) + 1;\r\nocteon_cf_ops.sff_data_xfer = octeon_cf_data_xfer16;\r\nap->mwdma_mask = enable_dma ? ATA_MWDMA4 : 0;\r\nhrtimer_init(&cf_port->delayed_finish, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\ncf_port->delayed_finish.function = octeon_cf_delayed_finish;\r\n} else {\r\nbase = cs0 + 0x800;\r\nocteon_cf_ops.sff_data_xfer = octeon_cf_data_xfer16;\r\nocteon_cf_ops.softreset = octeon_cf_softreset16;\r\nocteon_cf_ops.sff_check_status = octeon_cf_check_status16;\r\nocteon_cf_ops.sff_tf_read = octeon_cf_tf_read16;\r\nocteon_cf_ops.sff_tf_load = octeon_cf_tf_load16;\r\nocteon_cf_ops.sff_exec_command = octeon_cf_exec_command16;\r\nap->ioaddr.data_addr = base + ATA_REG_DATA;\r\nap->ioaddr.nsect_addr = base + ATA_REG_NSECT;\r\nap->ioaddr.lbal_addr = base + ATA_REG_LBAL;\r\nap->ioaddr.ctl_addr = base + 0xe;\r\nap->ioaddr.altstatus_addr = base + 0xe;\r\n}\r\ncf_port->c0 = ap->ioaddr.ctl_addr;\r\npdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);\r\npdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\r\nata_port_desc(ap, "cmd %p ctl %p", base, ap->ioaddr.ctl_addr);\r\ndev_info(&pdev->dev, "version " DRV_VERSION" %d bit%s.\n",\r\nis_16bit ? 16 : 8,\r\ncf_port->is_true_ide ? ", True IDE" : "");\r\nreturn ata_host_activate(host, irq, irq_handler,\r\nIRQF_SHARED, &octeon_cf_sht);\r\nfree_cf_port:\r\nkfree(cf_port);\r\nreturn rv;\r\n}\r\nstatic void octeon_cf_shutdown(struct device *dev)\r\n{\r\nunion cvmx_mio_boot_dma_cfgx dma_cfg;\r\nunion cvmx_mio_boot_dma_intx dma_int;\r\nstruct octeon_cf_port *cf_port = dev->platform_data;\r\nif (cf_port->dma_base) {\r\ndma_cfg.u64 = 0;\r\ndma_cfg.s.size = -1;\r\ncvmx_write_csr(cf_port->dma_base + DMA_CFG, dma_cfg.u64);\r\ndma_int.u64 = 0;\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT_EN, dma_int.u64);\r\ndma_int.s.done = 1;\r\ncvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);\r\n__raw_writeb(0, cf_port->c0);\r\nudelay(20);\r\n__raw_writeb(ATA_SRST, cf_port->c0);\r\nudelay(20);\r\n__raw_writeb(0, cf_port->c0);\r\nmdelay(100);\r\n}\r\n}\r\nstatic int __init octeon_cf_init(void)\r\n{\r\nreturn platform_driver_register(&octeon_cf_driver);\r\n}
