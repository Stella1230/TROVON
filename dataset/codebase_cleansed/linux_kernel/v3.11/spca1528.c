static void reg_r(struct gspca_dev *gspca_dev,\r\nu8 req,\r\nu16 index,\r\nint len)\r\n{\r\n#if USB_BUF_SZ < 64\r\n#error "USB buffer too small"\r\n#endif\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nreq,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000,\r\nindex,\r\ngspca_dev->usb_buf, len,\r\n500);\r\nPDEBUG(D_USBI, "GET %02x 0000 %04x %02x", req, index,\r\ngspca_dev->usb_buf[0]);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu8 req,\r\nu16 value,\r\nu16 index)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "SET %02x %04x %04x", req, value, index);\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index,\r\nNULL, 0, 500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_wb(struct gspca_dev *gspca_dev,\r\nu8 req,\r\nu16 value,\r\nu16 index,\r\nu8 byte)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "SET %02x %04x %04x %02x", req, value, index, byte);\r\ngspca_dev->usb_buf[0] = byte;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index,\r\ngspca_dev->usb_buf, 1, 500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void wait_status_0(struct gspca_dev *gspca_dev)\r\n{\r\nint i, w;\r\ni = 16;\r\nw = 0;\r\ndo {\r\nreg_r(gspca_dev, 0x21, 0x0000, 1);\r\nif (gspca_dev->usb_buf[0] == 0)\r\nreturn;\r\nw += 15;\r\nmsleep(w);\r\n} while (--i > 0);\r\nPERR("wait_status_0 timeout");\r\ngspca_dev->usb_err = -ETIME;\r\n}\r\nstatic void wait_status_1(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\ni = 10;\r\ndo {\r\nreg_r(gspca_dev, 0x21, 0x0001, 1);\r\nmsleep(10);\r\nif (gspca_dev->usb_buf[0] == 1) {\r\nreg_wb(gspca_dev, 0x21, 0x0000, 0x0001, 0x00);\r\nreg_r(gspca_dev, 0x21, 0x0001, 1);\r\nreturn;\r\n}\r\n} while (--i > 0);\r\nPERR("wait_status_1 timeout");\r\ngspca_dev->usb_err = -ETIME;\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_wb(gspca_dev, 0xc0, 0x0000, 0x00c0, val);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_wb(gspca_dev, 0xc1, 0x0000, 0x00c1, val);\r\n}\r\nstatic void sethue(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_wb(gspca_dev, 0xc2, 0x0000, 0x0000, val);\r\n}\r\nstatic void setcolor(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_wb(gspca_dev, 0xc3, 0x0000, 0x00c3, val);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nreg_wb(gspca_dev, 0xc4, 0x0000, 0x00c4, val);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\ngspca_dev->cam.cam_mode = vga_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\r\ngspca_dev->cam.npkt = 128;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 0x00, 0x0001, 0x2067);\r\nreg_w(gspca_dev, 0x00, 0x00d0, 0x206b);\r\nreg_w(gspca_dev, 0x00, 0x0000, 0x206c);\r\nreg_w(gspca_dev, 0x00, 0x0001, 0x2069);\r\nmsleep(8);\r\nreg_w(gspca_dev, 0x00, 0x00c0, 0x206b);\r\nreg_w(gspca_dev, 0x00, 0x0000, 0x206c);\r\nreg_w(gspca_dev, 0x00, 0x0001, 0x2069);\r\nreg_r(gspca_dev, 0x20, 0x0000, 1);\r\nreg_r(gspca_dev, 0x20, 0x0000, 5);\r\nreg_r(gspca_dev, 0x23, 0x0000, 64);\r\nPDEBUG(D_PROBE, "%s%s", &gspca_dev->usb_buf[0x1c],\r\n&gspca_dev->usb_buf[0x30]);\r\nreg_r(gspca_dev, 0x23, 0x0001, 64);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\nu8 mode;\r\nreg_r(gspca_dev, 0x00, 0x2520, 1);\r\nwait_status_0(gspca_dev);\r\nreg_w(gspca_dev, 0xc5, 0x0003, 0x0000);\r\nwait_status_1(gspca_dev);\r\nwait_status_0(gspca_dev);\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nreg_wb(gspca_dev, 0x25, 0x0000, 0x0004, mode);\r\nreg_r(gspca_dev, 0x25, 0x0004, 1);\r\nreg_wb(gspca_dev, 0x27, 0x0000, 0x0000, 0x06);\r\nreg_r(gspca_dev, 0x27, 0x0000, 1);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x22);\r\njpeg_set_qual(sd->jpeg_hdr, 85);\r\nreg_r(gspca_dev, 0x00, 0x2520, 1);\r\nmsleep(8);\r\nwait_status_0(gspca_dev);\r\nreg_w(gspca_dev, 0x31, 0x0000, 0x0004);\r\nwait_status_1(gspca_dev);\r\nwait_status_0(gspca_dev);\r\nmsleep(200);\r\nsd->pkt_seq = 0;\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nwait_status_0(gspca_dev);\r\nreg_w(gspca_dev, 0x31, 0x0000, 0x0000);\r\nwait_status_1(gspca_dev);\r\nwait_status_0(gspca_dev);\r\n}\r\nstatic void add_packet(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint i;\r\ni = 0;\r\ndo {\r\nif (data[i] == 0xff) {\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, i + 1);\r\nlen -= i;\r\ndata += i;\r\n*data = 0x00;\r\ni = 0;\r\n}\r\n} while (++i < len);\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstatic const u8 ffd9[] = {0xff, 0xd9};\r\nif (len < 3)\r\nreturn;\r\nif (*data == 0x02) {\r\nif (data[1] & 0x02) {\r\nsd->pkt_seq = !(data[1] & 1);\r\nadd_packet(gspca_dev, data + 2, len - 2);\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nffd9, 2);\r\nreturn;\r\n}\r\nif ((data[1] & 1) != sd->pkt_seq)\r\ngoto err;\r\nif (gspca_dev->last_packet_type == LAST_PACKET)\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\nadd_packet(gspca_dev, data + 2, len - 2);\r\nreturn;\r\n}\r\nerr:\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nsethue(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolor(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 5);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 8, 1, 1);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HUE, 0, 255, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 8, 1, 1);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 255, 1, 0);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 1)\r\nreturn -ENODEV;\r\nreturn gspca_dev_probe2(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
