static int pm8xxx_read_root_irq(const struct pm_irq_chip *chip, u8 *rp)\r\n{\r\nreturn pm8xxx_readb(chip->dev, SSBI_REG_ADDR_IRQ_ROOT, rp);\r\n}\r\nstatic int pm8xxx_read_master_irq(const struct pm_irq_chip *chip, u8 m, u8 *bp)\r\n{\r\nreturn pm8xxx_readb(chip->dev,\r\nSSBI_REG_ADDR_IRQ_M_STATUS1 + m, bp);\r\n}\r\nstatic int pm8xxx_read_block_irq(struct pm_irq_chip *chip, u8 bp, u8 *ip)\r\n{\r\nint rc;\r\nspin_lock(&chip->pm_irq_lock);\r\nrc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);\r\nif (rc) {\r\npr_err("Failed Selecting Block %d rc=%d\n", bp, rc);\r\ngoto bail;\r\n}\r\nrc = pm8xxx_readb(chip->dev, SSBI_REG_ADDR_IRQ_IT_STATUS, ip);\r\nif (rc)\r\npr_err("Failed Reading Status rc=%d\n", rc);\r\nbail:\r\nspin_unlock(&chip->pm_irq_lock);\r\nreturn rc;\r\n}\r\nstatic int pm8xxx_config_irq(struct pm_irq_chip *chip, u8 bp, u8 cp)\r\n{\r\nint rc;\r\nspin_lock(&chip->pm_irq_lock);\r\nrc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);\r\nif (rc) {\r\npr_err("Failed Selecting Block %d rc=%d\n", bp, rc);\r\ngoto bail;\r\n}\r\ncp |= PM_IRQF_WRITE;\r\nrc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_CONFIG, cp);\r\nif (rc)\r\npr_err("Failed Configuring IRQ rc=%d\n", rc);\r\nbail:\r\nspin_unlock(&chip->pm_irq_lock);\r\nreturn rc;\r\n}\r\nstatic int pm8xxx_irq_block_handler(struct pm_irq_chip *chip, int block)\r\n{\r\nint pmirq, irq, i, ret = 0;\r\nu8 bits;\r\nret = pm8xxx_read_block_irq(chip, block, &bits);\r\nif (ret) {\r\npr_err("Failed reading %d block ret=%d", block, ret);\r\nreturn ret;\r\n}\r\nif (!bits) {\r\npr_err("block bit set in master but no irqs: %d", block);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (bits & (1 << i)) {\r\npmirq = block * 8 + i;\r\nirq = pmirq + chip->irq_base;\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_irq_master_handler(struct pm_irq_chip *chip, int master)\r\n{\r\nu8 blockbits;\r\nint block_number, i, ret = 0;\r\nret = pm8xxx_read_master_irq(chip, master, &blockbits);\r\nif (ret) {\r\npr_err("Failed to read master %d ret=%d\n", master, ret);\r\nreturn ret;\r\n}\r\nif (!blockbits) {\r\npr_err("master bit set in root but no blocks: %d", master);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 8; i++)\r\nif (blockbits & (1 << i)) {\r\nblock_number = master * 8 + i;\r\nret |= pm8xxx_irq_block_handler(chip, block_number);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pm8xxx_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pm_irq_chip *chip = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *irq_chip = irq_desc_get_chip(desc);\r\nu8 root;\r\nint i, ret, masters = 0;\r\nret = pm8xxx_read_root_irq(chip, &root);\r\nif (ret) {\r\npr_err("Can't read root status ret=%d\n", ret);\r\nreturn;\r\n}\r\nmasters = root >> 1;\r\nfor (i = 0; i < chip->num_masters; i++)\r\nif (masters & (1 << i))\r\npm8xxx_irq_master_handler(chip, i);\r\nirq_chip->irq_ack(&desc->irq_data);\r\n}\r\nstatic void pm8xxx_irq_mask_ack(struct irq_data *d)\r\n{\r\nstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\r\nunsigned int pmirq = d->irq - chip->irq_base;\r\nint master, irq_bit;\r\nu8 block, config;\r\nblock = pmirq / 8;\r\nmaster = block / 8;\r\nirq_bit = pmirq % 8;\r\nconfig = chip->config[pmirq] | PM_IRQF_MASK_ALL | PM_IRQF_CLR;\r\npm8xxx_config_irq(chip, block, config);\r\n}\r\nstatic void pm8xxx_irq_unmask(struct irq_data *d)\r\n{\r\nstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\r\nunsigned int pmirq = d->irq - chip->irq_base;\r\nint master, irq_bit;\r\nu8 block, config;\r\nblock = pmirq / 8;\r\nmaster = block / 8;\r\nirq_bit = pmirq % 8;\r\nconfig = chip->config[pmirq];\r\npm8xxx_config_irq(chip, block, config);\r\n}\r\nstatic int pm8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\r\nunsigned int pmirq = d->irq - chip->irq_base;\r\nint master, irq_bit;\r\nu8 block, config;\r\nblock = pmirq / 8;\r\nmaster = block / 8;\r\nirq_bit = pmirq % 8;\r\nchip->config[pmirq] = (irq_bit << PM_IRQF_BITS_SHIFT)\r\n| PM_IRQF_MASK_ALL;\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\r\nif (flow_type & IRQF_TRIGGER_RISING)\r\nchip->config[pmirq] &= ~PM_IRQF_MASK_RE;\r\nif (flow_type & IRQF_TRIGGER_FALLING)\r\nchip->config[pmirq] &= ~PM_IRQF_MASK_FE;\r\n} else {\r\nchip->config[pmirq] |= PM_IRQF_LVL_SEL;\r\nif (flow_type & IRQF_TRIGGER_HIGH)\r\nchip->config[pmirq] &= ~PM_IRQF_MASK_RE;\r\nelse\r\nchip->config[pmirq] &= ~PM_IRQF_MASK_FE;\r\n}\r\nconfig = chip->config[pmirq] | PM_IRQF_CLR;\r\nreturn pm8xxx_config_irq(chip, block, config);\r\n}\r\nstatic int pm8xxx_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nreturn 0;\r\n}\r\nint pm8xxx_get_irq_stat(struct pm_irq_chip *chip, int irq)\r\n{\r\nint pmirq, rc;\r\nu8 block, bits, bit;\r\nunsigned long flags;\r\nif (chip == NULL || irq < chip->irq_base ||\r\nirq >= chip->irq_base + chip->num_irqs)\r\nreturn -EINVAL;\r\npmirq = irq - chip->irq_base;\r\nblock = pmirq / 8;\r\nbit = pmirq % 8;\r\nspin_lock_irqsave(&chip->pm_irq_lock, flags);\r\nrc = pm8xxx_writeb(chip->dev, SSBI_REG_ADDR_IRQ_BLK_SEL, block);\r\nif (rc) {\r\npr_err("Failed Selecting block irq=%d pmirq=%d blk=%d rc=%d\n",\r\nirq, pmirq, block, rc);\r\ngoto bail_out;\r\n}\r\nrc = pm8xxx_readb(chip->dev, SSBI_REG_ADDR_IRQ_RT_STATUS, &bits);\r\nif (rc) {\r\npr_err("Failed Configuring irq=%d pmirq=%d blk=%d rc=%d\n",\r\nirq, pmirq, block, rc);\r\ngoto bail_out;\r\n}\r\nrc = (bits & (1 << bit)) ? 1 : 0;\r\nbail_out:\r\nspin_unlock_irqrestore(&chip->pm_irq_lock, flags);\r\nreturn rc;\r\n}\r\nstruct pm_irq_chip * pm8xxx_irq_init(struct device *dev,\r\nconst struct pm8xxx_irq_platform_data *pdata)\r\n{\r\nstruct pm_irq_chip *chip;\r\nint devirq, rc;\r\nunsigned int pmirq;\r\nif (!pdata) {\r\npr_err("No platform data\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndevirq = pdata->devirq;\r\nif (devirq < 0) {\r\npr_err("missing devirq\n");\r\nrc = devirq;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nchip = kzalloc(sizeof(struct pm_irq_chip)\r\n+ sizeof(u8) * pdata->irq_cdata.nirqs, GFP_KERNEL);\r\nif (!chip) {\r\npr_err("Cannot alloc pm_irq_chip struct\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nchip->dev = dev;\r\nchip->devirq = devirq;\r\nchip->irq_base = pdata->irq_base;\r\nchip->num_irqs = pdata->irq_cdata.nirqs;\r\nchip->num_blocks = DIV_ROUND_UP(chip->num_irqs, 8);\r\nchip->num_masters = DIV_ROUND_UP(chip->num_blocks, 8);\r\nspin_lock_init(&chip->pm_irq_lock);\r\nfor (pmirq = 0; pmirq < chip->num_irqs; pmirq++) {\r\nirq_set_chip_and_handler(chip->irq_base + pmirq,\r\n&pm8xxx_irq_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(chip->irq_base + pmirq, chip);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(chip->irq_base + pmirq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(chip->irq_base + pmirq);\r\n#endif\r\n}\r\nirq_set_irq_type(devirq, pdata->irq_trigger_flag);\r\nirq_set_handler_data(devirq, chip);\r\nirq_set_chained_handler(devirq, pm8xxx_irq_handler);\r\nset_irq_wake(devirq, 1);\r\nreturn chip;\r\n}\r\nint pm8xxx_irq_exit(struct pm_irq_chip *chip)\r\n{\r\nirq_set_chained_handler(chip->devirq, NULL);\r\nkfree(chip);\r\nreturn 0;\r\n}
