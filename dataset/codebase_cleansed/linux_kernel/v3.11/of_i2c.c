void of_i2c_register_devices(struct i2c_adapter *adap)\r\n{\r\nvoid *result;\r\nstruct device_node *node;\r\nif (!adap->dev.of_node)\r\nreturn;\r\ndev_dbg(&adap->dev, "of_i2c: walking child nodes\n");\r\nfor_each_available_child_of_node(adap->dev.of_node, node) {\r\nstruct i2c_board_info info = {};\r\nstruct dev_archdata dev_ad = {};\r\nconst __be32 *addr;\r\nint len;\r\ndev_dbg(&adap->dev, "of_i2c: register %s\n", node->full_name);\r\nif (of_modalias_node(node, info.type, sizeof(info.type)) < 0) {\r\ndev_err(&adap->dev, "of_i2c: modalias failure on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\naddr = of_get_property(node, "reg", &len);\r\nif (!addr || (len < sizeof(int))) {\r\ndev_err(&adap->dev, "of_i2c: invalid reg on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\ninfo.addr = be32_to_cpup(addr);\r\nif (info.addr > (1 << 10) - 1) {\r\ndev_err(&adap->dev, "of_i2c: invalid addr=%x on %s\n",\r\ninfo.addr, node->full_name);\r\ncontinue;\r\n}\r\ninfo.irq = irq_of_parse_and_map(node, 0);\r\ninfo.of_node = of_node_get(node);\r\ninfo.archdata = &dev_ad;\r\nif (of_get_property(node, "wakeup-source", NULL))\r\ninfo.flags |= I2C_CLIENT_WAKE;\r\nrequest_module("%s%s", I2C_MODULE_PREFIX, info.type);\r\nresult = i2c_new_device(adap, &info);\r\nif (result == NULL) {\r\ndev_err(&adap->dev, "of_i2c: Failure registering %s\n",\r\nnode->full_name);\r\nof_node_put(node);\r\nirq_dispose_mapping(info.irq);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic int of_dev_node_match(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstruct i2c_client *of_find_i2c_device_by_node(struct device_node *node)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&i2c_bus_type, NULL, node,\r\nof_dev_node_match);\r\nif (!dev)\r\nreturn NULL;\r\nreturn i2c_verify_client(dev);\r\n}\r\nstruct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&i2c_bus_type, NULL, node,\r\nof_dev_node_match);\r\nif (!dev)\r\nreturn NULL;\r\nreturn i2c_verify_adapter(dev);\r\n}
