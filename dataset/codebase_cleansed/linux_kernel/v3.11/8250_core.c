static int serial_index(struct uart_port *port)\r\n{\r\nreturn (serial8250_reg.minor - 64) + port->line;\r\n}\r\nstatic int default_serial_dl_read(struct uart_8250_port *up)\r\n{\r\nreturn serial_in(up, UART_DLL) | serial_in(up, UART_DLM) << 8;\r\n}\r\nstatic void default_serial_dl_write(struct uart_8250_port *up, int value)\r\n{\r\nserial_out(up, UART_DLL, value & 0xff);\r\nserial_out(up, UART_DLM, value >> 8 & 0xff);\r\n}\r\nstatic unsigned int au_serial_in(struct uart_port *p, int offset)\r\n{\r\noffset = au_io_in_map[offset] << p->regshift;\r\nreturn __raw_readl(p->membase + offset);\r\n}\r\nstatic void au_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\noffset = au_io_out_map[offset] << p->regshift;\r\n__raw_writel(value, p->membase + offset);\r\n}\r\nstatic int au_serial_dl_read(struct uart_8250_port *up)\r\n{\r\nreturn __raw_readl(up->port.membase + 0x28);\r\n}\r\nstatic void au_serial_dl_write(struct uart_8250_port *up, int value)\r\n{\r\n__raw_writel(value, up->port.membase + 0x28);\r\n}\r\nstatic unsigned int hub6_serial_in(struct uart_port *p, int offset)\r\n{\r\noffset = offset << p->regshift;\r\noutb(p->hub6 - 1 + offset, p->iobase);\r\nreturn inb(p->iobase + 1);\r\n}\r\nstatic void hub6_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\noffset = offset << p->regshift;\r\noutb(p->hub6 - 1 + offset, p->iobase);\r\noutb(value, p->iobase + 1);\r\n}\r\nstatic unsigned int mem_serial_in(struct uart_port *p, int offset)\r\n{\r\noffset = offset << p->regshift;\r\nreturn readb(p->membase + offset);\r\n}\r\nstatic void mem_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\noffset = offset << p->regshift;\r\nwriteb(value, p->membase + offset);\r\n}\r\nstatic void mem32_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\noffset = offset << p->regshift;\r\nwritel(value, p->membase + offset);\r\n}\r\nstatic unsigned int mem32_serial_in(struct uart_port *p, int offset)\r\n{\r\noffset = offset << p->regshift;\r\nreturn readl(p->membase + offset);\r\n}\r\nstatic unsigned int io_serial_in(struct uart_port *p, int offset)\r\n{\r\noffset = offset << p->regshift;\r\nreturn inb(p->iobase + offset);\r\n}\r\nstatic void io_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\noffset = offset << p->regshift;\r\noutb(value, p->iobase + offset);\r\n}\r\nstatic void set_io_from_upio(struct uart_port *p)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(p, struct uart_8250_port, port);\r\nup->dl_read = default_serial_dl_read;\r\nup->dl_write = default_serial_dl_write;\r\nswitch (p->iotype) {\r\ncase UPIO_HUB6:\r\np->serial_in = hub6_serial_in;\r\np->serial_out = hub6_serial_out;\r\nbreak;\r\ncase UPIO_MEM:\r\np->serial_in = mem_serial_in;\r\np->serial_out = mem_serial_out;\r\nbreak;\r\ncase UPIO_MEM32:\r\np->serial_in = mem32_serial_in;\r\np->serial_out = mem32_serial_out;\r\nbreak;\r\n#if defined(CONFIG_MIPS_ALCHEMY) || defined(CONFIG_SERIAL_8250_RT288X)\r\ncase UPIO_AU:\r\np->serial_in = au_serial_in;\r\np->serial_out = au_serial_out;\r\nup->dl_read = au_serial_dl_read;\r\nup->dl_write = au_serial_dl_write;\r\nbreak;\r\n#endif\r\ndefault:\r\np->serial_in = io_serial_in;\r\np->serial_out = io_serial_out;\r\nbreak;\r\n}\r\nup->cur_iotype = p->iotype;\r\np->handle_irq = serial8250_default_handle_irq;\r\n}\r\nstatic void\r\nserial_port_out_sync(struct uart_port *p, int offset, int value)\r\n{\r\nswitch (p->iotype) {\r\ncase UPIO_MEM:\r\ncase UPIO_MEM32:\r\ncase UPIO_AU:\r\np->serial_out(p, offset, value);\r\np->serial_in(p, UART_LCR);\r\nbreak;\r\ndefault:\r\np->serial_out(p, offset, value);\r\n}\r\n}\r\nstatic void serial_icr_write(struct uart_8250_port *up, int offset, int value)\r\n{\r\nserial_out(up, UART_SCR, offset);\r\nserial_out(up, UART_ICR, value);\r\n}\r\nstatic unsigned int serial_icr_read(struct uart_8250_port *up, int offset)\r\n{\r\nunsigned int value;\r\nserial_icr_write(up, UART_ACR, up->acr | UART_ACR_ICRRD);\r\nserial_out(up, UART_SCR, offset);\r\nvalue = serial_in(up, UART_ICR);\r\nserial_icr_write(up, UART_ACR, up->acr);\r\nreturn value;\r\n}\r\nstatic void serial8250_clear_fifos(struct uart_8250_port *p)\r\n{\r\nif (p->capabilities & UART_CAP_FIFO) {\r\nserial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(p, UART_FCR, 0);\r\n}\r\n}\r\nvoid serial8250_clear_and_reinit_fifos(struct uart_8250_port *p)\r\n{\r\nunsigned char fcr;\r\nserial8250_clear_fifos(p);\r\nfcr = uart_config[p->port.type].fcr;\r\nserial_out(p, UART_FCR, fcr);\r\n}\r\nstatic void serial8250_set_sleep(struct uart_8250_port *p, int sleep)\r\n{\r\nif ((p->port.type == PORT_XR17V35X) ||\r\n(p->port.type == PORT_XR17D15X)) {\r\nserial_out(p, UART_EXAR_SLEEP, 0xff);\r\nreturn;\r\n}\r\nif (p->capabilities & UART_CAP_SLEEP) {\r\nif (p->capabilities & UART_CAP_EFR) {\r\nserial_out(p, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(p, UART_EFR, UART_EFR_ECB);\r\nserial_out(p, UART_LCR, 0);\r\n}\r\nserial_out(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);\r\nif (p->capabilities & UART_CAP_EFR) {\r\nserial_out(p, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(p, UART_EFR, 0);\r\nserial_out(p, UART_LCR, 0);\r\n}\r\n}\r\n}\r\nstatic int __enable_rsa(struct uart_8250_port *up)\r\n{\r\nunsigned char mode;\r\nint result;\r\nmode = serial_in(up, UART_RSA_MSR);\r\nresult = mode & UART_RSA_MSR_FIFO;\r\nif (!result) {\r\nserial_out(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);\r\nmode = serial_in(up, UART_RSA_MSR);\r\nresult = mode & UART_RSA_MSR_FIFO;\r\n}\r\nif (result)\r\nup->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;\r\nreturn result;\r\n}\r\nstatic void enable_rsa(struct uart_8250_port *up)\r\n{\r\nif (up->port.type == PORT_RSA) {\r\nif (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {\r\nspin_lock_irq(&up->port.lock);\r\n__enable_rsa(up);\r\nspin_unlock_irq(&up->port.lock);\r\n}\r\nif (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)\r\nserial_out(up, UART_RSA_FRR, 0);\r\n}\r\n}\r\nstatic void disable_rsa(struct uart_8250_port *up)\r\n{\r\nunsigned char mode;\r\nint result;\r\nif (up->port.type == PORT_RSA &&\r\nup->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {\r\nspin_lock_irq(&up->port.lock);\r\nmode = serial_in(up, UART_RSA_MSR);\r\nresult = !(mode & UART_RSA_MSR_FIFO);\r\nif (!result) {\r\nserial_out(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);\r\nmode = serial_in(up, UART_RSA_MSR);\r\nresult = !(mode & UART_RSA_MSR_FIFO);\r\n}\r\nif (result)\r\nup->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;\r\nspin_unlock_irq(&up->port.lock);\r\n}\r\n}\r\nstatic int size_fifo(struct uart_8250_port *up)\r\n{\r\nunsigned char old_fcr, old_mcr, old_lcr;\r\nunsigned short old_dl;\r\nint count;\r\nold_lcr = serial_in(up, UART_LCR);\r\nserial_out(up, UART_LCR, 0);\r\nold_fcr = serial_in(up, UART_FCR);\r\nold_mcr = serial_in(up, UART_MCR);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_MCR, UART_MCR_LOOP);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nold_dl = serial_dl_read(up);\r\nserial_dl_write(up, 0x0001);\r\nserial_out(up, UART_LCR, 0x03);\r\nfor (count = 0; count < 256; count++)\r\nserial_out(up, UART_TX, count);\r\nmdelay(20);\r\nfor (count = 0; (serial_in(up, UART_LSR) & UART_LSR_DR) &&\r\n(count < 256); count++)\r\nserial_in(up, UART_RX);\r\nserial_out(up, UART_FCR, old_fcr);\r\nserial_out(up, UART_MCR, old_mcr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_dl_write(up, old_dl);\r\nserial_out(up, UART_LCR, old_lcr);\r\nreturn count;\r\n}\r\nstatic unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)\r\n{\r\nunsigned char old_dll, old_dlm, old_lcr;\r\nunsigned int id;\r\nold_lcr = serial_in(p, UART_LCR);\r\nserial_out(p, UART_LCR, UART_LCR_CONF_MODE_A);\r\nold_dll = serial_in(p, UART_DLL);\r\nold_dlm = serial_in(p, UART_DLM);\r\nserial_out(p, UART_DLL, 0);\r\nserial_out(p, UART_DLM, 0);\r\nid = serial_in(p, UART_DLL) | serial_in(p, UART_DLM) << 8;\r\nserial_out(p, UART_DLL, old_dll);\r\nserial_out(p, UART_DLM, old_dlm);\r\nserial_out(p, UART_LCR, old_lcr);\r\nreturn id;\r\n}\r\nstatic void autoconfig_has_efr(struct uart_8250_port *up)\r\n{\r\nunsigned int id1, id2, id3, rev;\r\nup->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;\r\nup->acr = 0;\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0x00);\r\nid1 = serial_icr_read(up, UART_ID1);\r\nid2 = serial_icr_read(up, UART_ID2);\r\nid3 = serial_icr_read(up, UART_ID3);\r\nrev = serial_icr_read(up, UART_REV);\r\nDEBUG_AUTOCONF("950id=%02x:%02x:%02x:%02x ", id1, id2, id3, rev);\r\nif (id1 == 0x16 && id2 == 0xC9 &&\r\n(id3 == 0x50 || id3 == 0x52 || id3 == 0x54)) {\r\nup->port.type = PORT_16C950;\r\nif (id3 == 0x52 && rev == 0x01)\r\nup->bugs |= UART_BUG_QUOT;\r\nreturn;\r\n}\r\nid1 = autoconfig_read_divisor_id(up);\r\nDEBUG_AUTOCONF("850id=%04x ", id1);\r\nid2 = id1 >> 8;\r\nif (id2 == 0x10 || id2 == 0x12 || id2 == 0x14) {\r\nup->port.type = PORT_16850;\r\nreturn;\r\n}\r\nif (size_fifo(up) == 64)\r\nup->port.type = PORT_16654;\r\nelse\r\nup->port.type = PORT_16650V2;\r\n}\r\nstatic void autoconfig_8250(struct uart_8250_port *up)\r\n{\r\nunsigned char scratch, status1, status2;\r\nup->port.type = PORT_8250;\r\nscratch = serial_in(up, UART_SCR);\r\nserial_out(up, UART_SCR, 0xa5);\r\nstatus1 = serial_in(up, UART_SCR);\r\nserial_out(up, UART_SCR, 0x5a);\r\nstatus2 = serial_in(up, UART_SCR);\r\nserial_out(up, UART_SCR, scratch);\r\nif (status1 == 0xa5 && status2 == 0x5a)\r\nup->port.type = PORT_16450;\r\n}\r\nstatic int broken_efr(struct uart_8250_port *up)\r\n{\r\nif (autoconfig_read_divisor_id(up) == 0x0201 && size_fifo(up) == 16)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int ns16550a_goto_highspeed(struct uart_8250_port *up)\r\n{\r\nunsigned char status;\r\nstatus = serial_in(up, 0x04);\r\n#define PRESL(x) ((x) & 0x30)\r\nif (PRESL(status) == 0x10) {\r\nreturn 0;\r\n} else {\r\nstatus &= ~0xB0;\r\nstatus |= 0x10;\r\nserial_out(up, 0x04, status);\r\n}\r\nreturn 1;\r\n}\r\nstatic void autoconfig_16550a(struct uart_8250_port *up)\r\n{\r\nunsigned char status1, status2;\r\nunsigned int iersave;\r\nup->port.type = PORT_16550A;\r\nup->capabilities |= UART_CAP_FIFO;\r\nif (up->port.flags & UPF_EXAR_EFR) {\r\nstatus1 = serial_in(up, UART_EXAR_DVID);\r\nif (status1 == 0x82 || status1 == 0x84 || status1 == 0x88) {\r\nDEBUG_AUTOCONF("Exar XR17V35x ");\r\nup->port.type = PORT_XR17V35X;\r\nup->capabilities |= UART_CAP_AFE | UART_CAP_EFR |\r\nUART_CAP_SLEEP;\r\nreturn;\r\n}\r\n}\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nif (serial_in(up, UART_EFR) == 0) {\r\nserial_out(up, UART_EFR, 0xA8);\r\nif (serial_in(up, UART_EFR) != 0) {\r\nDEBUG_AUTOCONF("EFRv1 ");\r\nup->port.type = PORT_16650;\r\nup->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;\r\n} else {\r\nDEBUG_AUTOCONF("Motorola 8xxx DUART ");\r\n}\r\nserial_out(up, UART_EFR, 0);\r\nreturn;\r\n}\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nif (serial_in(up, UART_EFR) == 0 && !broken_efr(up)) {\r\nDEBUG_AUTOCONF("EFRv2 ");\r\nautoconfig_has_efr(up);\r\nreturn;\r\n}\r\nserial_out(up, UART_LCR, 0);\r\nstatus1 = serial_in(up, UART_MCR);\r\nserial_out(up, UART_LCR, 0xE0);\r\nstatus2 = serial_in(up, 0x02);\r\nif (!((status2 ^ status1) & UART_MCR_LOOP)) {\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_MCR, status1 ^ UART_MCR_LOOP);\r\nserial_out(up, UART_LCR, 0xE0);\r\nstatus2 = serial_in(up, 0x02);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_MCR, status1);\r\nif ((status2 ^ status1) & UART_MCR_LOOP) {\r\nunsigned short quot;\r\nserial_out(up, UART_LCR, 0xE0);\r\nquot = serial_dl_read(up);\r\nquot <<= 3;\r\nif (ns16550a_goto_highspeed(up))\r\nserial_dl_write(up, quot);\r\nserial_out(up, UART_LCR, 0);\r\nup->port.uartclk = 921600*16;\r\nup->port.type = PORT_NS16550A;\r\nup->capabilities |= UART_NATSEMI;\r\nreturn;\r\n}\r\n}\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\r\nstatus1 = serial_in(up, UART_IIR) >> 5;\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\r\nstatus2 = serial_in(up, UART_IIR) >> 5;\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(up, UART_LCR, 0);\r\nDEBUG_AUTOCONF("iir1=%d iir2=%d ", status1, status2);\r\nif (status1 == 6 && status2 == 7) {\r\nup->port.type = PORT_16750;\r\nup->capabilities |= UART_CAP_AFE | UART_CAP_SLEEP;\r\nreturn;\r\n}\r\niersave = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, iersave & ~UART_IER_UUE);\r\nif (!(serial_in(up, UART_IER) & UART_IER_UUE)) {\r\nserial_out(up, UART_IER, iersave | UART_IER_UUE);\r\nif (serial_in(up, UART_IER) & UART_IER_UUE) {\r\nDEBUG_AUTOCONF("Xscale ");\r\nup->port.type = PORT_XSCALE;\r\nup->capabilities |= UART_CAP_UUE | UART_CAP_RTOIE;\r\nreturn;\r\n}\r\n} else {\r\nDEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");\r\n}\r\nserial_out(up, UART_IER, iersave);\r\nif (up->port.flags & UPF_EXAR_EFR) {\r\nDEBUG_AUTOCONF("Exar XR17D15x ");\r\nup->port.type = PORT_XR17D15X;\r\nup->capabilities |= UART_CAP_AFE | UART_CAP_EFR |\r\nUART_CAP_SLEEP;\r\nreturn;\r\n}\r\nif (up->port.type == PORT_16550A && size_fifo(up) == 64) {\r\nup->port.type = PORT_U6_16550A;\r\nup->capabilities |= UART_CAP_AFE;\r\n}\r\n}\r\nstatic void autoconfig(struct uart_8250_port *up, unsigned int probeflags)\r\n{\r\nunsigned char status1, scratch, scratch2, scratch3;\r\nunsigned char save_lcr, save_mcr;\r\nstruct uart_port *port = &up->port;\r\nunsigned long flags;\r\nunsigned int old_capabilities;\r\nif (!port->iobase && !port->mapbase && !port->membase)\r\nreturn;\r\nDEBUG_AUTOCONF("ttyS%d: autoconf (0x%04lx, 0x%p): ",\r\nserial_index(port), port->iobase, port->membase);\r\nspin_lock_irqsave(&port->lock, flags);\r\nup->capabilities = 0;\r\nup->bugs = 0;\r\nif (!(port->flags & UPF_BUGGY_UART)) {\r\nscratch = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\n#ifdef __i386__\r\noutb(0xff, 0x080);\r\n#endif\r\nscratch2 = serial_in(up, UART_IER) & 0x0f;\r\nserial_out(up, UART_IER, 0x0F);\r\n#ifdef __i386__\r\noutb(0, 0x080);\r\n#endif\r\nscratch3 = serial_in(up, UART_IER) & 0x0f;\r\nserial_out(up, UART_IER, scratch);\r\nif (scratch2 != 0 || scratch3 != 0x0F) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nDEBUG_AUTOCONF("IER test failed (%02x, %02x) ",\r\nscratch2, scratch3);\r\ngoto out;\r\n}\r\n}\r\nsave_mcr = serial_in(up, UART_MCR);\r\nsave_lcr = serial_in(up, UART_LCR);\r\nif (!(port->flags & UPF_SKIP_TEST)) {\r\nserial_out(up, UART_MCR, UART_MCR_LOOP | 0x0A);\r\nstatus1 = serial_in(up, UART_MSR) & 0xF0;\r\nserial_out(up, UART_MCR, save_mcr);\r\nif (status1 != 0x90) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nDEBUG_AUTOCONF("LOOP test failed (%02x) ",\r\nstatus1);\r\ngoto out;\r\n}\r\n}\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, 0);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nscratch = serial_in(up, UART_IIR) >> 6;\r\nswitch (scratch) {\r\ncase 0:\r\nautoconfig_8250(up);\r\nbreak;\r\ncase 1:\r\nport->type = PORT_UNKNOWN;\r\nbreak;\r\ncase 2:\r\nport->type = PORT_16550;\r\nbreak;\r\ncase 3:\r\nautoconfig_16550a(up);\r\nbreak;\r\n}\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\nif (port->type == PORT_16550A && probeflags & PROBE_RSA) {\r\nint i;\r\nfor (i = 0 ; i < probe_rsa_count; ++i) {\r\nif (probe_rsa[i] == port->iobase && __enable_rsa(up)) {\r\nport->type = PORT_RSA;\r\nbreak;\r\n}\r\n}\r\n}\r\n#endif\r\nserial_out(up, UART_LCR, save_lcr);\r\nport->fifosize = uart_config[up->port.type].fifo_size;\r\nold_capabilities = up->capabilities;\r\nup->capabilities = uart_config[port->type].flags;\r\nup->tx_loadsz = uart_config[port->type].tx_loadsz;\r\nif (port->type == PORT_UNKNOWN)\r\ngoto out_lock;\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\nif (port->type == PORT_RSA)\r\nserial_out(up, UART_RSA_FRR, 0);\r\n#endif\r\nserial_out(up, UART_MCR, save_mcr);\r\nserial8250_clear_fifos(up);\r\nserial_in(up, UART_RX);\r\nif (up->capabilities & UART_CAP_UUE)\r\nserial_out(up, UART_IER, UART_IER_UUE);\r\nelse\r\nserial_out(up, UART_IER, 0);\r\nout_lock:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (up->capabilities != old_capabilities) {\r\nprintk(KERN_WARNING\r\n"ttyS%d: detected caps %08x should be %08x\n",\r\nserial_index(port), old_capabilities,\r\nup->capabilities);\r\n}\r\nout:\r\nDEBUG_AUTOCONF("iir=%d ", scratch);\r\nDEBUG_AUTOCONF("type=%s\n", uart_config[port->type].name);\r\n}\r\nstatic void autoconfig_irq(struct uart_8250_port *up)\r\n{\r\nstruct uart_port *port = &up->port;\r\nunsigned char save_mcr, save_ier;\r\nunsigned char save_ICP = 0;\r\nunsigned int ICP = 0;\r\nunsigned long irqs;\r\nint irq;\r\nif (port->flags & UPF_FOURPORT) {\r\nICP = (port->iobase & 0xfe0) | 0x1f;\r\nsave_ICP = inb_p(ICP);\r\noutb_p(0x80, ICP);\r\ninb_p(ICP);\r\n}\r\nprobe_irq_off(probe_irq_on());\r\nsave_mcr = serial_in(up, UART_MCR);\r\nsave_ier = serial_in(up, UART_IER);\r\nserial_out(up, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);\r\nirqs = probe_irq_on();\r\nserial_out(up, UART_MCR, 0);\r\nudelay(10);\r\nif (port->flags & UPF_FOURPORT) {\r\nserial_out(up, UART_MCR,\r\nUART_MCR_DTR | UART_MCR_RTS);\r\n} else {\r\nserial_out(up, UART_MCR,\r\nUART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);\r\n}\r\nserial_out(up, UART_IER, 0x0f);\r\nserial_in(up, UART_LSR);\r\nserial_in(up, UART_RX);\r\nserial_in(up, UART_IIR);\r\nserial_in(up, UART_MSR);\r\nserial_out(up, UART_TX, 0xFF);\r\nudelay(20);\r\nirq = probe_irq_off(irqs);\r\nserial_out(up, UART_MCR, save_mcr);\r\nserial_out(up, UART_IER, save_ier);\r\nif (port->flags & UPF_FOURPORT)\r\noutb_p(save_ICP, ICP);\r\nport->irq = (irq > 0) ? irq : 0;\r\n}\r\nstatic inline void __stop_tx(struct uart_8250_port *p)\r\n{\r\nif (p->ier & UART_IER_THRI) {\r\np->ier &= ~UART_IER_THRI;\r\nserial_out(p, UART_IER, p->ier);\r\n}\r\n}\r\nstatic void serial8250_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\n__stop_tx(up);\r\nif (port->type == PORT_16C950) {\r\nup->acr |= UART_ACR_TXDIS;\r\nserial_icr_write(up, UART_ACR, up->acr);\r\n}\r\n}\r\nstatic void serial8250_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nif (up->dma && !serial8250_tx_dma(up)) {\r\nreturn;\r\n} else if (!(up->ier & UART_IER_THRI)) {\r\nup->ier |= UART_IER_THRI;\r\nserial_port_out(port, UART_IER, up->ier);\r\nif (up->bugs & UART_BUG_TXEN) {\r\nunsigned char lsr;\r\nlsr = serial_in(up, UART_LSR);\r\nup->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;\r\nif (lsr & UART_LSR_TEMT)\r\nserial8250_tx_chars(up);\r\n}\r\n}\r\nif (port->type == PORT_16C950 && up->acr & UART_ACR_TXDIS) {\r\nup->acr &= ~UART_ACR_TXDIS;\r\nserial_icr_write(up, UART_ACR, up->acr);\r\n}\r\n}\r\nstatic void serial8250_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nup->ier &= ~UART_IER_RLSI;\r\nup->port.read_status_mask &= ~UART_LSR_DR;\r\nserial_port_out(port, UART_IER, up->ier);\r\n}\r\nstatic void serial8250_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nif (up->bugs & UART_BUG_NOMSR)\r\nreturn;\r\nup->ier |= UART_IER_MSI;\r\nserial_port_out(port, UART_IER, up->ier);\r\n}\r\nunsigned char\r\nserial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr)\r\n{\r\nstruct uart_port *port = &up->port;\r\nunsigned char ch;\r\nint max_count = 256;\r\nchar flag;\r\ndo {\r\nif (likely(lsr & UART_LSR_DR))\r\nch = serial_in(up, UART_RX);\r\nelse\r\nch = 0;\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nlsr |= up->lsr_saved_flags;\r\nup->lsr_saved_flags = 0;\r\nif (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {\r\nif (lsr & UART_LSR_BI) {\r\nlsr &= ~(UART_LSR_FE | UART_LSR_PE);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ngoto ignore_char;\r\n} else if (lsr & UART_LSR_PE)\r\nport->icount.parity++;\r\nelse if (lsr & UART_LSR_FE)\r\nport->icount.frame++;\r\nif (lsr & UART_LSR_OE)\r\nport->icount.overrun++;\r\nlsr &= port->read_status_mask;\r\nif (lsr & UART_LSR_BI) {\r\nDEBUG_INTR("handling break....");\r\nflag = TTY_BREAK;\r\n} else if (lsr & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (lsr & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(port, lsr, UART_LSR_OE, ch, flag);\r\nignore_char:\r\nlsr = serial_in(up, UART_LSR);\r\n} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(&port->state->port);\r\nspin_lock(&port->lock);\r\nreturn lsr;\r\n}\r\nvoid serial8250_tx_chars(struct uart_8250_port *up)\r\n{\r\nstruct uart_port *port = &up->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint count;\r\nif (port->x_char) {\r\nserial_out(up, UART_TX, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_tx_stopped(port)) {\r\nserial8250_stop_tx(port);\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit)) {\r\n__stop_tx(up);\r\nreturn;\r\n}\r\ncount = up->tx_loadsz;\r\ndo {\r\nserial_out(up, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nif (up->capabilities & UART_CAP_HFIFO) {\r\nif ((serial_port_in(port, UART_LSR) & BOTH_EMPTY) !=\r\nBOTH_EMPTY)\r\nbreak;\r\n}\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nDEBUG_INTR("THRE...");\r\nif (uart_circ_empty(xmit))\r\n__stop_tx(up);\r\n}\r\nunsigned int serial8250_modem_status(struct uart_8250_port *up)\r\n{\r\nstruct uart_port *port = &up->port;\r\nunsigned int status = serial_in(up, UART_MSR);\r\nstatus |= up->msr_saved_flags;\r\nup->msr_saved_flags = 0;\r\nif (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&\r\nport->state != NULL) {\r\nif (status & UART_MSR_TERI)\r\nport->icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nuart_handle_dcd_change(port, status & UART_MSR_DCD);\r\nif (status & UART_MSR_DCTS)\r\nuart_handle_cts_change(port, status & UART_MSR_CTS);\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\nreturn status;\r\n}\r\nint serial8250_handle_irq(struct uart_port *port, unsigned int iir)\r\n{\r\nunsigned char status;\r\nunsigned long flags;\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nint dma_err = 0;\r\nif (iir & UART_IIR_NO_INT)\r\nreturn 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = serial_port_in(port, UART_LSR);\r\nDEBUG_INTR("status = %x...", status);\r\nif (status & (UART_LSR_DR | UART_LSR_BI)) {\r\nif (up->dma)\r\ndma_err = serial8250_rx_dma(up, iir);\r\nif (!up->dma || dma_err)\r\nstatus = serial8250_rx_chars(up, status);\r\n}\r\nserial8250_modem_status(up);\r\nif (status & UART_LSR_THRE)\r\nserial8250_tx_chars(up);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 1;\r\n}\r\nstatic int serial8250_default_handle_irq(struct uart_port *port)\r\n{\r\nunsigned int iir = serial_port_in(port, UART_IIR);\r\nreturn serial8250_handle_irq(port, iir);\r\n}\r\nstatic int exar_handle_irq(struct uart_port *port)\r\n{\r\nunsigned char int0, int1, int2, int3;\r\nunsigned int iir = serial_port_in(port, UART_IIR);\r\nint ret;\r\nret = serial8250_handle_irq(port, iir);\r\nif ((port->type == PORT_XR17V35X) ||\r\n(port->type == PORT_XR17D15X)) {\r\nint0 = serial_port_in(port, 0x80);\r\nint1 = serial_port_in(port, 0x81);\r\nint2 = serial_port_in(port, 0x82);\r\nint3 = serial_port_in(port, 0x83);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t serial8250_interrupt(int irq, void *dev_id)\r\n{\r\nstruct irq_info *i = dev_id;\r\nstruct list_head *l, *end = NULL;\r\nint pass_counter = 0, handled = 0;\r\nDEBUG_INTR("serial8250_interrupt(%d)...", irq);\r\nspin_lock(&i->lock);\r\nl = i->head;\r\ndo {\r\nstruct uart_8250_port *up;\r\nstruct uart_port *port;\r\nup = list_entry(l, struct uart_8250_port, list);\r\nport = &up->port;\r\nif (port->handle_irq(port)) {\r\nhandled = 1;\r\nend = NULL;\r\n} else if (end == NULL)\r\nend = l;\r\nl = l->next;\r\nif (l == i->head && pass_counter++ > PASS_LIMIT) {\r\nprintk_ratelimited(KERN_ERR\r\n"serial8250: too much work for irq%d\n", irq);\r\nbreak;\r\n}\r\n} while (l != end);\r\nspin_unlock(&i->lock);\r\nDEBUG_INTR("end.\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)\r\n{\r\nspin_lock_irq(&i->lock);\r\nif (!list_empty(i->head)) {\r\nif (i->head == &up->list)\r\ni->head = i->head->next;\r\nlist_del(&up->list);\r\n} else {\r\nBUG_ON(i->head != &up->list);\r\ni->head = NULL;\r\n}\r\nspin_unlock_irq(&i->lock);\r\nif (i->head == NULL) {\r\nhlist_del(&i->node);\r\nkfree(i);\r\n}\r\n}\r\nstatic int serial_link_irq_chain(struct uart_8250_port *up)\r\n{\r\nstruct hlist_head *h;\r\nstruct hlist_node *n;\r\nstruct irq_info *i;\r\nint ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;\r\nmutex_lock(&hash_mutex);\r\nh = &irq_lists[up->port.irq % NR_IRQ_HASH];\r\nhlist_for_each(n, h) {\r\ni = hlist_entry(n, struct irq_info, node);\r\nif (i->irq == up->port.irq)\r\nbreak;\r\n}\r\nif (n == NULL) {\r\ni = kzalloc(sizeof(struct irq_info), GFP_KERNEL);\r\nif (i == NULL) {\r\nmutex_unlock(&hash_mutex);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&i->lock);\r\ni->irq = up->port.irq;\r\nhlist_add_head(&i->node, h);\r\n}\r\nmutex_unlock(&hash_mutex);\r\nspin_lock_irq(&i->lock);\r\nif (i->head) {\r\nlist_add(&up->list, i->head);\r\nspin_unlock_irq(&i->lock);\r\nret = 0;\r\n} else {\r\nINIT_LIST_HEAD(&up->list);\r\ni->head = &up->list;\r\nspin_unlock_irq(&i->lock);\r\nirq_flags |= up->port.irqflags;\r\nret = request_irq(up->port.irq, serial8250_interrupt,\r\nirq_flags, "serial", i);\r\nif (ret < 0)\r\nserial_do_unlink(i, up);\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial_unlink_irq_chain(struct uart_8250_port *up)\r\n{\r\nstruct irq_info *i;\r\nstruct hlist_node *n;\r\nstruct hlist_head *h;\r\nmutex_lock(&hash_mutex);\r\nh = &irq_lists[up->port.irq % NR_IRQ_HASH];\r\nhlist_for_each(n, h) {\r\ni = hlist_entry(n, struct irq_info, node);\r\nif (i->irq == up->port.irq)\r\nbreak;\r\n}\r\nBUG_ON(n == NULL);\r\nBUG_ON(i->head == NULL);\r\nif (list_empty(i->head))\r\nfree_irq(up->port.irq, i);\r\nserial_do_unlink(i, up);\r\nmutex_unlock(&hash_mutex);\r\n}\r\nstatic void serial8250_timeout(unsigned long data)\r\n{\r\nstruct uart_8250_port *up = (struct uart_8250_port *)data;\r\nup->port.handle_irq(&up->port);\r\nmod_timer(&up->timer, jiffies + uart_poll_timeout(&up->port));\r\n}\r\nstatic void serial8250_backup_timeout(unsigned long data)\r\n{\r\nstruct uart_8250_port *up = (struct uart_8250_port *)data;\r\nunsigned int iir, ier = 0, lsr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (up->port.irq) {\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\n}\r\niir = serial_in(up, UART_IIR);\r\nlsr = serial_in(up, UART_LSR);\r\nup->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;\r\nif ((iir & UART_IIR_NO_INT) && (up->ier & UART_IER_THRI) &&\r\n(!uart_circ_empty(&up->port.state->xmit) || up->port.x_char) &&\r\n(lsr & UART_LSR_THRE)) {\r\niir &= ~(UART_IIR_ID | UART_IIR_NO_INT);\r\niir |= UART_IIR_THRI;\r\n}\r\nif (!(iir & UART_IIR_NO_INT))\r\nserial8250_tx_chars(up);\r\nif (up->port.irq)\r\nserial_out(up, UART_IER, ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nmod_timer(&up->timer,\r\njiffies + uart_poll_timeout(&up->port) + HZ / 5);\r\n}\r\nstatic unsigned int serial8250_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned long flags;\r\nunsigned int lsr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nlsr = serial_port_in(port, UART_LSR);\r\nup->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn (lsr & BOTH_EMPTY) == BOTH_EMPTY ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int serial8250_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned int status;\r\nunsigned int ret;\r\nstatus = serial8250_modem_status(up);\r\nret = 0;\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned char mcr = 0;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nmcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;\r\nserial_port_out(port, UART_MCR, mcr);\r\n}\r\nstatic void serial8250_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (break_state == -1)\r\nup->lcr |= UART_LCR_SBC;\r\nelse\r\nup->lcr &= ~UART_LCR_SBC;\r\nserial_port_out(port, UART_LCR, up->lcr);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void wait_for_xmitr(struct uart_8250_port *up, int bits)\r\n{\r\nunsigned int status, tmout = 10000;\r\nfor (;;) {\r\nstatus = serial_in(up, UART_LSR);\r\nup->lsr_saved_flags |= status & LSR_SAVE_FLAGS;\r\nif ((status & bits) == bits)\r\nbreak;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\nunsigned int tmout;\r\nfor (tmout = 1000000; tmout; tmout--) {\r\nunsigned int msr = serial_in(up, UART_MSR);\r\nup->msr_saved_flags |= msr & MSR_SAVE_FLAGS;\r\nif (msr & UART_MSR_CTS)\r\nbreak;\r\nudelay(1);\r\ntouch_nmi_watchdog();\r\n}\r\n}\r\n}\r\nstatic int serial8250_get_poll_char(struct uart_port *port)\r\n{\r\nunsigned char lsr = serial_port_in(port, UART_LSR);\r\nif (!(lsr & UART_LSR_DR))\r\nreturn NO_POLL_CHAR;\r\nreturn serial_port_in(port, UART_RX);\r\n}\r\nstatic void serial8250_put_poll_char(struct uart_port *port,\r\nunsigned char c)\r\n{\r\nunsigned int ier;\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nier = serial_port_in(port, UART_IER);\r\nif (up->capabilities & UART_CAP_UUE)\r\nserial_port_out(port, UART_IER, UART_IER_UUE);\r\nelse\r\nserial_port_out(port, UART_IER, 0);\r\nwait_for_xmitr(up, BOTH_EMPTY);\r\nserial_port_out(port, UART_TX, c);\r\nif (c == 10) {\r\nwait_for_xmitr(up, BOTH_EMPTY);\r\nserial_port_out(port, UART_TX, 13);\r\n}\r\nwait_for_xmitr(up, BOTH_EMPTY);\r\nserial_port_out(port, UART_IER, ier);\r\n}\r\nstatic int serial8250_startup(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned long flags;\r\nunsigned char lsr, iir;\r\nint retval;\r\nif (port->type == PORT_8250_CIR)\r\nreturn -ENODEV;\r\nif (!port->fifosize)\r\nport->fifosize = uart_config[port->type].fifo_size;\r\nif (!up->tx_loadsz)\r\nup->tx_loadsz = uart_config[port->type].tx_loadsz;\r\nif (!up->capabilities)\r\nup->capabilities = uart_config[port->type].flags;\r\nup->mcr = 0;\r\nif (port->iotype != up->cur_iotype)\r\nset_io_from_upio(port);\r\nif (port->type == PORT_16C950) {\r\nup->acr = 0;\r\nserial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_port_out(port, UART_EFR, UART_EFR_ECB);\r\nserial_port_out(port, UART_IER, 0);\r\nserial_port_out(port, UART_LCR, 0);\r\nserial_icr_write(up, UART_CSR, 0);\r\nserial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_port_out(port, UART_EFR, UART_EFR_ECB);\r\nserial_port_out(port, UART_LCR, 0);\r\n}\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\nenable_rsa(up);\r\n#endif\r\nserial8250_clear_fifos(up);\r\nserial_port_in(port, UART_LSR);\r\nserial_port_in(port, UART_RX);\r\nserial_port_in(port, UART_IIR);\r\nserial_port_in(port, UART_MSR);\r\nif (!(port->flags & UPF_BUGGY_UART) &&\r\n(serial_port_in(port, UART_LSR) == 0xff)) {\r\nprintk_ratelimited(KERN_INFO "ttyS%d: LSR safety check engaged!\n",\r\nserial_index(port));\r\nreturn -ENODEV;\r\n}\r\nif (port->type == PORT_16850) {\r\nunsigned char fctr;\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nfctr = serial_in(up, UART_FCTR) & ~(UART_FCTR_RX|UART_FCTR_TX);\r\nserial_port_out(port, UART_FCTR,\r\nfctr | UART_FCTR_TRGD | UART_FCTR_RX);\r\nserial_port_out(port, UART_TRG, UART_TRG_96);\r\nserial_port_out(port, UART_FCTR,\r\nfctr | UART_FCTR_TRGD | UART_FCTR_TX);\r\nserial_port_out(port, UART_TRG, UART_TRG_96);\r\nserial_port_out(port, UART_LCR, 0);\r\n}\r\nif (port->irq) {\r\nunsigned char iir1;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (up->port.irqflags & IRQF_SHARED)\r\ndisable_irq_nosync(port->irq);\r\nwait_for_xmitr(up, UART_LSR_THRE);\r\nserial_port_out_sync(port, UART_IER, UART_IER_THRI);\r\nudelay(1);\r\niir1 = serial_port_in(port, UART_IIR);\r\nserial_port_out(port, UART_IER, 0);\r\nserial_port_out_sync(port, UART_IER, UART_IER_THRI);\r\nudelay(1);\r\niir = serial_port_in(port, UART_IIR);\r\nserial_port_out(port, UART_IER, 0);\r\nif (port->irqflags & IRQF_SHARED)\r\nenable_irq(port->irq);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif ((!(iir1 & UART_IIR_NO_INT) && (iir & UART_IIR_NO_INT)) ||\r\nup->port.flags & UPF_BUG_THRE) {\r\nup->bugs |= UART_BUG_THRE;\r\npr_debug("ttyS%d - using backup timer\n",\r\nserial_index(port));\r\n}\r\n}\r\nif (up->bugs & UART_BUG_THRE) {\r\nup->timer.function = serial8250_backup_timeout;\r\nup->timer.data = (unsigned long)up;\r\nmod_timer(&up->timer, jiffies +\r\nuart_poll_timeout(port) + HZ / 5);\r\n}\r\nif (!port->irq) {\r\nup->timer.data = (unsigned long)up;\r\nmod_timer(&up->timer, jiffies + uart_poll_timeout(port));\r\n} else {\r\nretval = serial_link_irq_chain(up);\r\nif (retval)\r\nreturn retval;\r\n}\r\nserial_port_out(port, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (up->port.flags & UPF_FOURPORT) {\r\nif (!up->port.irq)\r\nup->port.mctrl |= TIOCM_OUT1;\r\n} else\r\nif (port->irq)\r\nup->port.mctrl |= TIOCM_OUT2;\r\nserial8250_set_mctrl(port, port->mctrl);\r\nif (skip_txen_test || up->port.flags & UPF_NO_TXEN_TEST)\r\ngoto dont_test_tx_en;\r\nserial_port_out(port, UART_IER, UART_IER_THRI);\r\nlsr = serial_port_in(port, UART_LSR);\r\niir = serial_port_in(port, UART_IIR);\r\nserial_port_out(port, UART_IER, 0);\r\nif (lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT) {\r\nif (!(up->bugs & UART_BUG_TXEN)) {\r\nup->bugs |= UART_BUG_TXEN;\r\npr_debug("ttyS%d - enabling bad tx status workarounds\n",\r\nserial_index(port));\r\n}\r\n} else {\r\nup->bugs &= ~UART_BUG_TXEN;\r\n}\r\ndont_test_tx_en:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nserial_port_in(port, UART_LSR);\r\nserial_port_in(port, UART_RX);\r\nserial_port_in(port, UART_IIR);\r\nserial_port_in(port, UART_MSR);\r\nup->lsr_saved_flags = 0;\r\nup->msr_saved_flags = 0;\r\nif (up->dma) {\r\nretval = serial8250_request_dma(up);\r\nif (retval) {\r\npr_warn_ratelimited("ttyS%d - failed to request DMA\n",\r\nserial_index(port));\r\nup->dma = NULL;\r\n}\r\n}\r\nup->ier = UART_IER_RLSI | UART_IER_RDI;\r\nserial_port_out(port, UART_IER, up->ier);\r\nif (port->flags & UPF_FOURPORT) {\r\nunsigned int icp;\r\nicp = (port->iobase & 0xfe0) | 0x01f;\r\noutb_p(0x80, icp);\r\ninb_p(icp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void serial8250_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned long flags;\r\nup->ier = 0;\r\nserial_port_out(port, UART_IER, 0);\r\nif (up->dma)\r\nserial8250_release_dma(up);\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (port->flags & UPF_FOURPORT) {\r\ninb((port->iobase & 0xfe0) | 0x1f);\r\nport->mctrl |= TIOCM_OUT1;\r\n} else\r\nport->mctrl &= ~TIOCM_OUT2;\r\nserial8250_set_mctrl(port, port->mctrl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nserial_port_out(port, UART_LCR,\r\nserial_port_in(port, UART_LCR) & ~UART_LCR_SBC);\r\nserial8250_clear_fifos(up);\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\ndisable_rsa(up);\r\n#endif\r\nserial_port_in(port, UART_RX);\r\ndel_timer_sync(&up->timer);\r\nup->timer.function = serial8250_timeout;\r\nif (port->irq)\r\nserial_unlink_irq_chain(up);\r\n}\r\nstatic unsigned int serial8250_get_divisor(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int quot;\r\nif ((port->flags & UPF_MAGIC_MULTIPLIER) &&\r\nbaud == (port->uartclk/4))\r\nquot = 0x8001;\r\nelse if ((port->flags & UPF_MAGIC_MULTIPLIER) &&\r\nbaud == (port->uartclk/8))\r\nquot = 0x8002;\r\nelse\r\nquot = uart_get_divisor(port, baud);\r\nreturn quot;\r\n}\r\nvoid\r\nserial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nunsigned char cval, fcr = 0;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nint fifo_bug = 0;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB) {\r\ncval |= UART_LCR_PARITY;\r\nif (up->bugs & UART_BUG_PARITY)\r\nfifo_bug = 1;\r\n}\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\n#ifdef CMSPAR\r\nif (termios->c_cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\n#endif\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nport->uartclk / 16 / 0xffff,\r\nport->uartclk / 16);\r\nquot = serial8250_get_divisor(port, baud);\r\nif (up->bugs & UART_BUG_QUOT && (quot & 0xff) == 0)\r\nquot++;\r\nif (up->capabilities & UART_CAP_FIFO && port->fifosize > 1) {\r\nfcr = uart_config[port->type].fcr;\r\nif (baud < 2400 || fifo_bug) {\r\nfcr &= ~UART_FCR_TRIGGER_MASK;\r\nfcr |= UART_FCR_TRIGGER_1;\r\n}\r\n}\r\nif (up->capabilities & UART_CAP_AFE && port->fifosize >= 32) {\r\nup->mcr &= ~UART_MCR_AFE;\r\nif (termios->c_cflag & CRTSCTS)\r\nup->mcr |= UART_MCR_AFE;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= UART_LSR_BI;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (!(up->bugs & UART_BUG_NOMSR) &&\r\nUART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->ier |= UART_IER_MSI;\r\nif (up->capabilities & UART_CAP_UUE)\r\nup->ier |= UART_IER_UUE;\r\nif (up->capabilities & UART_CAP_RTOIE)\r\nup->ier |= UART_IER_RTOIE;\r\nserial_port_out(port, UART_IER, up->ier);\r\nif (up->capabilities & UART_CAP_EFR) {\r\nunsigned char efr = 0;\r\nif (termios->c_cflag & CRTSCTS)\r\nefr |= UART_EFR_CTS;\r\nserial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);\r\nif (port->flags & UPF_EXAR_EFR)\r\nserial_port_out(port, UART_XR_EFR, efr);\r\nelse\r\nserial_port_out(port, UART_EFR, efr);\r\n}\r\nif (is_omap1510_8250(up)) {\r\nif (baud == 115200) {\r\nquot = 1;\r\nserial_port_out(port, UART_OMAP_OSC_12M_SEL, 1);\r\n} else\r\nserial_port_out(port, UART_OMAP_OSC_12M_SEL, 0);\r\n}\r\nif (up->capabilities & UART_NATSEMI)\r\nserial_port_out(port, UART_LCR, 0xe0);\r\nelse\r\nserial_port_out(port, UART_LCR, cval | UART_LCR_DLAB);\r\nserial_dl_write(up, quot);\r\nif (port->type == PORT_16750)\r\nserial_port_out(port, UART_FCR, fcr);\r\nserial_port_out(port, UART_LCR, cval);\r\nup->lcr = cval;\r\nif (port->type != PORT_16750) {\r\nif (fcr & UART_FCR_ENABLE_FIFO)\r\nserial_port_out(port, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_port_out(port, UART_FCR, fcr);\r\n}\r\nserial8250_set_mctrl(port, port->mctrl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nstatic void\r\nserial8250_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nif (port->set_termios)\r\nport->set_termios(port, termios, old);\r\nelse\r\nserial8250_do_set_termios(port, termios, old);\r\n}\r\nstatic void\r\nserial8250_set_ldisc(struct uart_port *port, int new)\r\n{\r\nif (new == N_PPS) {\r\nport->flags |= UPF_HARDPPS_CD;\r\nserial8250_enable_ms(port);\r\n} else\r\nport->flags &= ~UPF_HARDPPS_CD;\r\n}\r\nvoid serial8250_do_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct uart_8250_port *p =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nserial8250_set_sleep(p, state != 0);\r\n}\r\nstatic void\r\nserial8250_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nif (port->pm)\r\nport->pm(port, state, oldstate);\r\nelse\r\nserial8250_do_pm(port, state, oldstate);\r\n}\r\nstatic unsigned int serial8250_port_size(struct uart_8250_port *pt)\r\n{\r\nif (pt->port.iotype == UPIO_AU)\r\nreturn 0x1000;\r\nif (is_omap1_8250(pt))\r\nreturn 0x16 << pt->port.regshift;\r\nreturn 8 << pt->port.regshift;\r\n}\r\nstatic int serial8250_request_std_resource(struct uart_8250_port *up)\r\n{\r\nunsigned int size = serial8250_port_size(up);\r\nstruct uart_port *port = &up->port;\r\nint ret = 0;\r\nswitch (port->iotype) {\r\ncase UPIO_AU:\r\ncase UPIO_TSI:\r\ncase UPIO_MEM32:\r\ncase UPIO_MEM:\r\nif (!port->mapbase)\r\nbreak;\r\nif (!request_mem_region(port->mapbase, size, "serial")) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap_nocache(port->mapbase, size);\r\nif (!port->membase) {\r\nrelease_mem_region(port->mapbase, size);\r\nret = -ENOMEM;\r\n}\r\n}\r\nbreak;\r\ncase UPIO_HUB6:\r\ncase UPIO_PORT:\r\nif (!request_region(port->iobase, size, "serial"))\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial8250_release_std_resource(struct uart_8250_port *up)\r\n{\r\nunsigned int size = serial8250_port_size(up);\r\nstruct uart_port *port = &up->port;\r\nswitch (port->iotype) {\r\ncase UPIO_AU:\r\ncase UPIO_TSI:\r\ncase UPIO_MEM32:\r\ncase UPIO_MEM:\r\nif (!port->mapbase)\r\nbreak;\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nrelease_mem_region(port->mapbase, size);\r\nbreak;\r\ncase UPIO_HUB6:\r\ncase UPIO_PORT:\r\nrelease_region(port->iobase, size);\r\nbreak;\r\n}\r\n}\r\nstatic int serial8250_request_rsa_resource(struct uart_8250_port *up)\r\n{\r\nunsigned long start = UART_RSA_BASE << up->port.regshift;\r\nunsigned int size = 8 << up->port.regshift;\r\nstruct uart_port *port = &up->port;\r\nint ret = -EINVAL;\r\nswitch (port->iotype) {\r\ncase UPIO_HUB6:\r\ncase UPIO_PORT:\r\nstart += port->iobase;\r\nif (request_region(start, size, "serial-rsa"))\r\nret = 0;\r\nelse\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial8250_release_rsa_resource(struct uart_8250_port *up)\r\n{\r\nunsigned long offset = UART_RSA_BASE << up->port.regshift;\r\nunsigned int size = 8 << up->port.regshift;\r\nstruct uart_port *port = &up->port;\r\nswitch (port->iotype) {\r\ncase UPIO_HUB6:\r\ncase UPIO_PORT:\r\nrelease_region(port->iobase + offset, size);\r\nbreak;\r\n}\r\n}\r\nstatic void serial8250_release_port(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nserial8250_release_std_resource(up);\r\nif (port->type == PORT_RSA)\r\nserial8250_release_rsa_resource(up);\r\n}\r\nstatic int serial8250_request_port(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nint ret;\r\nif (port->type == PORT_8250_CIR)\r\nreturn -ENODEV;\r\nret = serial8250_request_std_resource(up);\r\nif (ret == 0 && port->type == PORT_RSA) {\r\nret = serial8250_request_rsa_resource(up);\r\nif (ret < 0)\r\nserial8250_release_std_resource(up);\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial8250_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nint probeflags = PROBE_ANY;\r\nint ret;\r\nif (port->type == PORT_8250_CIR)\r\nreturn;\r\nret = serial8250_request_std_resource(up);\r\nif (ret < 0)\r\nreturn;\r\nret = serial8250_request_rsa_resource(up);\r\nif (ret < 0)\r\nprobeflags &= ~PROBE_RSA;\r\nif (port->iotype != up->cur_iotype)\r\nset_io_from_upio(port);\r\nif (flags & UART_CONFIG_TYPE)\r\nautoconfig(up, probeflags);\r\nif (port->type == PORT_16550A && port->iotype == UPIO_AU)\r\nup->bugs |= UART_BUG_NOMSR;\r\nif (port->type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)\r\nautoconfig_irq(up);\r\nif (port->type != PORT_RSA && probeflags & PROBE_RSA)\r\nserial8250_release_rsa_resource(up);\r\nif (port->type == PORT_UNKNOWN)\r\nserial8250_release_std_resource(up);\r\nif ((port->type == PORT_XR17V35X) ||\r\n(port->type == PORT_XR17D15X))\r\nport->handle_irq = exar_handle_irq;\r\n}\r\nstatic int\r\nserial8250_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (ser->irq >= nr_irqs || ser->irq < 0 ||\r\nser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||\r\nser->type >= ARRAY_SIZE(uart_config) || ser->type == PORT_CIRRUS ||\r\nser->type == PORT_STARTECH)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic const char *\r\nserial8250_type(struct uart_port *port)\r\n{\r\nint type = port->type;\r\nif (type >= ARRAY_SIZE(uart_config))\r\ntype = 0;\r\nreturn uart_config[type].name;\r\n}\r\nvoid serial8250_set_isa_configurator(\r\nvoid (*v)(int port, struct uart_port *up, unsigned short *capabilities))\r\n{\r\nserial8250_isa_config = v;\r\n}\r\nstatic void __init serial8250_isa_init_ports(void)\r\n{\r\nstruct uart_8250_port *up;\r\nstatic int first = 1;\r\nint i, irqflag = 0;\r\nif (!first)\r\nreturn;\r\nfirst = 0;\r\nif (nr_uarts > UART_NR)\r\nnr_uarts = UART_NR;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nstruct uart_port *port = &up->port;\r\nport->line = i;\r\nspin_lock_init(&port->lock);\r\ninit_timer(&up->timer);\r\nup->timer.function = serial8250_timeout;\r\nup->cur_iotype = 0xFF;\r\nup->mcr_mask = ~ALPHA_KLUDGE_MCR;\r\nup->mcr_force = ALPHA_KLUDGE_MCR;\r\nport->ops = &serial8250_pops;\r\n}\r\nif (share_irqs)\r\nirqflag = IRQF_SHARED;\r\nfor (i = 0, up = serial8250_ports;\r\ni < ARRAY_SIZE(old_serial_port) && i < nr_uarts;\r\ni++, up++) {\r\nstruct uart_port *port = &up->port;\r\nport->iobase = old_serial_port[i].port;\r\nport->irq = irq_canonicalize(old_serial_port[i].irq);\r\nport->irqflags = old_serial_port[i].irqflags;\r\nport->uartclk = old_serial_port[i].baud_base * 16;\r\nport->flags = old_serial_port[i].flags;\r\nport->hub6 = old_serial_port[i].hub6;\r\nport->membase = old_serial_port[i].iomem_base;\r\nport->iotype = old_serial_port[i].io_type;\r\nport->regshift = old_serial_port[i].iomem_reg_shift;\r\nset_io_from_upio(port);\r\nport->irqflags |= irqflag;\r\nif (serial8250_isa_config != NULL)\r\nserial8250_isa_config(i, &up->port, &up->capabilities);\r\n}\r\n}\r\nstatic void\r\nserial8250_init_fixed_type_port(struct uart_8250_port *up, unsigned int type)\r\n{\r\nup->port.type = type;\r\nif (!up->port.fifosize)\r\nup->port.fifosize = uart_config[type].fifo_size;\r\nif (!up->tx_loadsz)\r\nup->tx_loadsz = uart_config[type].tx_loadsz;\r\nif (!up->capabilities)\r\nup->capabilities = uart_config[type].flags;\r\n}\r\nstatic void __init\r\nserial8250_register_ports(struct uart_driver *drv, struct device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.dev)\r\ncontinue;\r\nup->port.dev = dev;\r\nif (up->port.flags & UPF_FIXED_TYPE)\r\nserial8250_init_fixed_type_port(up, up->port.type);\r\nuart_add_one_port(drv, &up->port);\r\n}\r\n}\r\nstatic void serial8250_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(port, struct uart_8250_port, port);\r\nwait_for_xmitr(up, UART_LSR_THRE);\r\nserial_port_out(port, UART_TX, ch);\r\n}\r\nstatic void\r\nserial8250_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_8250_port *up = &serial8250_ports[co->index];\r\nstruct uart_port *port = &up->port;\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\ntouch_nmi_watchdog();\r\nlocal_irq_save(flags);\r\nif (port->sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&port->lock);\r\n} else\r\nspin_lock(&port->lock);\r\nier = serial_port_in(port, UART_IER);\r\nif (up->capabilities & UART_CAP_UUE)\r\nserial_port_out(port, UART_IER, UART_IER_UUE);\r\nelse\r\nserial_port_out(port, UART_IER, 0);\r\nuart_console_write(port, s, count, serial8250_console_putchar);\r\nwait_for_xmitr(up, BOTH_EMPTY);\r\nserial_port_out(port, UART_IER, ier);\r\nif (up->msr_saved_flags)\r\nserial8250_modem_status(up);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init serial8250_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= nr_uarts)\r\nco->index = 0;\r\nport = &serial8250_ports[co->index].port;\r\nif (!port->iobase && !port->membase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int serial8250_console_early_setup(void)\r\n{\r\nreturn serial8250_find_port_for_earlycon();\r\n}\r\nstatic int __init serial8250_console_init(void)\r\n{\r\nserial8250_isa_init_ports();\r\nregister_console(&serial8250_console);\r\nreturn 0;\r\n}\r\nint serial8250_find_port(struct uart_port *p)\r\n{\r\nint line;\r\nstruct uart_port *port;\r\nfor (line = 0; line < nr_uarts; line++) {\r\nport = &serial8250_ports[line].port;\r\nif (uart_match_port(p, port))\r\nreturn line;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint __init early_serial_setup(struct uart_port *port)\r\n{\r\nstruct uart_port *p;\r\nif (port->line >= ARRAY_SIZE(serial8250_ports))\r\nreturn -ENODEV;\r\nserial8250_isa_init_ports();\r\np = &serial8250_ports[port->line].port;\r\np->iobase = port->iobase;\r\np->membase = port->membase;\r\np->irq = port->irq;\r\np->irqflags = port->irqflags;\r\np->uartclk = port->uartclk;\r\np->fifosize = port->fifosize;\r\np->regshift = port->regshift;\r\np->iotype = port->iotype;\r\np->flags = port->flags;\r\np->mapbase = port->mapbase;\r\np->private_data = port->private_data;\r\np->type = port->type;\r\np->line = port->line;\r\nset_io_from_upio(p);\r\nif (port->serial_in)\r\np->serial_in = port->serial_in;\r\nif (port->serial_out)\r\np->serial_out = port->serial_out;\r\nif (port->handle_irq)\r\np->handle_irq = port->handle_irq;\r\nelse\r\np->handle_irq = serial8250_default_handle_irq;\r\nreturn 0;\r\n}\r\nvoid serial8250_suspend_port(int line)\r\n{\r\nuart_suspend_port(&serial8250_reg, &serial8250_ports[line].port);\r\n}\r\nvoid serial8250_resume_port(int line)\r\n{\r\nstruct uart_8250_port *up = &serial8250_ports[line];\r\nstruct uart_port *port = &up->port;\r\nif (up->capabilities & UART_NATSEMI) {\r\nserial_port_out(port, UART_LCR, 0xE0);\r\nns16550a_goto_highspeed(up);\r\nserial_port_out(port, UART_LCR, 0);\r\nport->uartclk = 921600*16;\r\n}\r\nuart_resume_port(&serial8250_reg, port);\r\n}\r\nstatic int serial8250_probe(struct platform_device *dev)\r\n{\r\nstruct plat_serial8250_port *p = dev->dev.platform_data;\r\nstruct uart_8250_port uart;\r\nint ret, i, irqflag = 0;\r\nmemset(&uart, 0, sizeof(uart));\r\nif (share_irqs)\r\nirqflag = IRQF_SHARED;\r\nfor (i = 0; p && p->flags != 0; p++, i++) {\r\nuart.port.iobase = p->iobase;\r\nuart.port.membase = p->membase;\r\nuart.port.irq = p->irq;\r\nuart.port.irqflags = p->irqflags;\r\nuart.port.uartclk = p->uartclk;\r\nuart.port.regshift = p->regshift;\r\nuart.port.iotype = p->iotype;\r\nuart.port.flags = p->flags;\r\nuart.port.mapbase = p->mapbase;\r\nuart.port.hub6 = p->hub6;\r\nuart.port.private_data = p->private_data;\r\nuart.port.type = p->type;\r\nuart.port.serial_in = p->serial_in;\r\nuart.port.serial_out = p->serial_out;\r\nuart.port.handle_irq = p->handle_irq;\r\nuart.port.handle_break = p->handle_break;\r\nuart.port.set_termios = p->set_termios;\r\nuart.port.pm = p->pm;\r\nuart.port.dev = &dev->dev;\r\nuart.port.irqflags |= irqflag;\r\nret = serial8250_register_8250_port(&uart);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "unable to register port at index %d "\r\n"(IO%lx MEM%llx IRQ%d): %d\n", i,\r\np->iobase, (unsigned long long)p->mapbase,\r\np->irq, ret);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial8250_remove(struct platform_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.dev == &dev->dev)\r\nserial8250_unregister_port(i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial8250_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\r\nuart_suspend_port(&serial8250_reg, &up->port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial8250_resume(struct platform_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\r\nserial8250_resume_port(i);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct uart_8250_port *serial8250_find_match_or_unused(struct uart_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_uarts; i++)\r\nif (uart_match_port(&serial8250_ports[i].port, port))\r\nreturn &serial8250_ports[i];\r\nfor (i = 0; i < nr_uarts; i++)\r\nif (serial8250_ports[i].port.type == PORT_UNKNOWN &&\r\nserial8250_ports[i].port.iobase == 0)\r\nreturn &serial8250_ports[i];\r\nfor (i = 0; i < nr_uarts; i++)\r\nif (serial8250_ports[i].port.type == PORT_UNKNOWN)\r\nreturn &serial8250_ports[i];\r\nreturn NULL;\r\n}\r\nint serial8250_register_8250_port(struct uart_8250_port *up)\r\n{\r\nstruct uart_8250_port *uart;\r\nint ret = -ENOSPC;\r\nif (up->port.uartclk == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&serial_mutex);\r\nuart = serial8250_find_match_or_unused(&up->port);\r\nif (uart && uart->port.type != PORT_8250_CIR) {\r\nif (uart->port.dev)\r\nuart_remove_one_port(&serial8250_reg, &uart->port);\r\nuart->port.iobase = up->port.iobase;\r\nuart->port.membase = up->port.membase;\r\nuart->port.irq = up->port.irq;\r\nuart->port.irqflags = up->port.irqflags;\r\nuart->port.uartclk = up->port.uartclk;\r\nuart->port.fifosize = up->port.fifosize;\r\nuart->port.regshift = up->port.regshift;\r\nuart->port.iotype = up->port.iotype;\r\nuart->port.flags = up->port.flags | UPF_BOOT_AUTOCONF;\r\nuart->bugs = up->bugs;\r\nuart->port.mapbase = up->port.mapbase;\r\nuart->port.private_data = up->port.private_data;\r\nuart->port.fifosize = up->port.fifosize;\r\nuart->tx_loadsz = up->tx_loadsz;\r\nuart->capabilities = up->capabilities;\r\nif (uart->port.fifosize && !uart->tx_loadsz)\r\nuart->tx_loadsz = uart->port.fifosize;\r\nif (up->port.dev)\r\nuart->port.dev = up->port.dev;\r\nif (up->port.flags & UPF_FIXED_TYPE)\r\nserial8250_init_fixed_type_port(uart, up->port.type);\r\nset_io_from_upio(&uart->port);\r\nif (up->port.serial_in)\r\nuart->port.serial_in = up->port.serial_in;\r\nif (up->port.serial_out)\r\nuart->port.serial_out = up->port.serial_out;\r\nif (up->port.handle_irq)\r\nuart->port.handle_irq = up->port.handle_irq;\r\nif (up->port.set_termios)\r\nuart->port.set_termios = up->port.set_termios;\r\nif (up->port.pm)\r\nuart->port.pm = up->port.pm;\r\nif (up->port.handle_break)\r\nuart->port.handle_break = up->port.handle_break;\r\nif (up->dl_read)\r\nuart->dl_read = up->dl_read;\r\nif (up->dl_write)\r\nuart->dl_write = up->dl_write;\r\nif (up->dma)\r\nuart->dma = up->dma;\r\nif (serial8250_isa_config != NULL)\r\nserial8250_isa_config(0, &uart->port,\r\n&uart->capabilities);\r\nret = uart_add_one_port(&serial8250_reg, &uart->port);\r\nif (ret == 0)\r\nret = uart->port.line;\r\n}\r\nmutex_unlock(&serial_mutex);\r\nreturn ret;\r\n}\r\nvoid serial8250_unregister_port(int line)\r\n{\r\nstruct uart_8250_port *uart = &serial8250_ports[line];\r\nmutex_lock(&serial_mutex);\r\nuart_remove_one_port(&serial8250_reg, &uart->port);\r\nif (serial8250_isa_devs) {\r\nuart->port.flags &= ~UPF_BOOT_AUTOCONF;\r\nuart->port.type = PORT_UNKNOWN;\r\nuart->port.dev = &serial8250_isa_devs->dev;\r\nuart->capabilities = uart_config[uart->port.type].flags;\r\nuart_add_one_port(&serial8250_reg, &uart->port);\r\n} else {\r\nuart->port.dev = NULL;\r\n}\r\nmutex_unlock(&serial_mutex);\r\n}\r\nstatic int __init serial8250_init(void)\r\n{\r\nint ret;\r\nserial8250_isa_init_ports();\r\nprintk(KERN_INFO "Serial: 8250/16550 driver, "\r\n"%d ports, IRQ sharing %sabled\n", nr_uarts,\r\nshare_irqs ? "en" : "dis");\r\n#ifdef CONFIG_SPARC\r\nret = sunserial_register_minors(&serial8250_reg, UART_NR);\r\n#else\r\nserial8250_reg.nr = UART_NR;\r\nret = uart_register_driver(&serial8250_reg);\r\n#endif\r\nif (ret)\r\ngoto out;\r\nret = serial8250_pnp_init();\r\nif (ret)\r\ngoto unreg_uart_drv;\r\nserial8250_isa_devs = platform_device_alloc("serial8250",\r\nPLAT8250_DEV_LEGACY);\r\nif (!serial8250_isa_devs) {\r\nret = -ENOMEM;\r\ngoto unreg_pnp;\r\n}\r\nret = platform_device_add(serial8250_isa_devs);\r\nif (ret)\r\ngoto put_dev;\r\nserial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);\r\nret = platform_driver_register(&serial8250_isa_driver);\r\nif (ret == 0)\r\ngoto out;\r\nplatform_device_del(serial8250_isa_devs);\r\nput_dev:\r\nplatform_device_put(serial8250_isa_devs);\r\nunreg_pnp:\r\nserial8250_pnp_exit();\r\nunreg_uart_drv:\r\n#ifdef CONFIG_SPARC\r\nsunserial_unregister_minors(&serial8250_reg, UART_NR);\r\n#else\r\nuart_unregister_driver(&serial8250_reg);\r\n#endif\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit serial8250_exit(void)\r\n{\r\nstruct platform_device *isa_dev = serial8250_isa_devs;\r\nserial8250_isa_devs = NULL;\r\nplatform_driver_unregister(&serial8250_isa_driver);\r\nplatform_device_unregister(isa_dev);\r\nserial8250_pnp_exit();\r\n#ifdef CONFIG_SPARC\r\nsunserial_unregister_minors(&serial8250_reg, UART_NR);\r\n#else\r\nuart_unregister_driver(&serial8250_reg);\r\n#endif\r\n}\r\nstatic void __used s8250_options(void)\r\n{\r\n#undef MODULE_PARAM_PREFIX\r\n#define MODULE_PARAM_PREFIX "8250_core."\r\nmodule_param_cb(share_irqs, &param_ops_uint, &share_irqs, 0644);\r\nmodule_param_cb(nr_uarts, &param_ops_uint, &nr_uarts, 0644);\r\nmodule_param_cb(skip_txen_test, &param_ops_uint, &skip_txen_test, 0644);\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\n__module_param_call(MODULE_PARAM_PREFIX, probe_rsa,\r\n&param_array_ops, .arr = &__param_arr_probe_rsa,\r\n0444, -1);\r\n#endif\r\n}
