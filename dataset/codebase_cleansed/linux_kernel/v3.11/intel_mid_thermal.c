static int to_msic_die_temp(uint16_t adc_val)\r\n{\r\nreturn (368 * (adc_val) / 1000) - 220;\r\n}\r\nstatic int is_valid_adc(uint16_t adc_val, uint16_t min, uint16_t max)\r\n{\r\nreturn (adc_val >= min) && (adc_val <= max);\r\n}\r\nstatic int adc_to_temp(int direct, uint16_t adc_val, unsigned long *tp)\r\n{\r\nint temp;\r\nif (direct) {\r\nif (is_valid_adc(adc_val, MSIC_DIE_ADC_MIN, MSIC_DIE_ADC_MAX)) {\r\n*tp = to_msic_die_temp(adc_val) * 1000;\r\nreturn 0;\r\n}\r\nreturn -ERANGE;\r\n}\r\nif (!is_valid_adc(adc_val, ADC_MIN, ADC_MAX))\r\nreturn -ERANGE;\r\nif (adc_val > ADC_VAL0C)\r\ntemp = 177 - (adc_val/5);\r\nelse if ((adc_val <= ADC_VAL0C) && (adc_val > ADC_VAL20C))\r\ntemp = 111 - (adc_val/8);\r\nelse if ((adc_val <= ADC_VAL20C) && (adc_val > ADC_VAL40C))\r\ntemp = 92 - (adc_val/10);\r\nelse if ((adc_val <= ADC_VAL40C) && (adc_val > ADC_VAL60C))\r\ntemp = 91 - (adc_val/10);\r\nelse\r\ntemp = 112 - (adc_val/6);\r\n*tp = temp * 1000;\r\nreturn 0;\r\n}\r\nstatic int mid_read_temp(struct thermal_zone_device *tzd, unsigned long *temp)\r\n{\r\nstruct thermal_device_info *td_info = tzd->devdata;\r\nuint16_t adc_val, addr;\r\nuint8_t data = 0;\r\nint ret;\r\nunsigned long curr_temp;\r\naddr = td_info->chnl_addr;\r\nret = intel_msic_reg_write(INTEL_MSIC_ADC1CNTL3, MSIC_ADCRRDATA_ENBL);\r\nif (ret)\r\nreturn ret;\r\nret = intel_msic_reg_write(INTEL_MSIC_ADC1CNTL3, MSIC_ADCTHERM_ENBL);\r\nif (ret)\r\nreturn ret;\r\nret = intel_msic_reg_read(addr, &data);\r\nif (ret)\r\nreturn ret;\r\nadc_val = (data << 2);\r\naddr++;\r\nret = intel_msic_reg_read(addr, &data);\r\nif (ret)\r\nreturn ret;\r\ndata &= 03;\r\nadc_val += data;\r\nret = adc_to_temp(td_info->direct, adc_val, &curr_temp);\r\nif (ret == 0)\r\n*temp = td_info->curr_temp = curr_temp;\r\nreturn ret;\r\n}\r\nstatic int configure_adc(int val)\r\n{\r\nint ret;\r\nuint8_t data;\r\nret = intel_msic_reg_read(INTEL_MSIC_ADC1CNTL1, &data);\r\nif (ret)\r\nreturn ret;\r\nif (val) {\r\ndata |= (MSIC_ADC_ENBL | MSIC_ADC_START);\r\n} else {\r\ndata &= (~MSIC_ADC_START);\r\n}\r\nreturn intel_msic_reg_write(INTEL_MSIC_ADC1CNTL1, data);\r\n}\r\nstatic int set_up_therm_channel(u16 base_addr)\r\n{\r\nint ret;\r\nret = intel_msic_reg_write(base_addr, SKIN_SENSOR0_CODE);\r\nif (ret)\r\nreturn ret;\r\nret = intel_msic_reg_write(base_addr + 1, SKIN_SENSOR1_CODE);\r\nif (ret)\r\nreturn ret;\r\nret = intel_msic_reg_write(base_addr + 2, SYS_SENSOR_CODE);\r\nif (ret)\r\nreturn ret;\r\nret = intel_msic_reg_write(base_addr + 3,\r\n(MSIC_DIE_SENSOR_CODE | 0x10));\r\nif (ret)\r\nreturn ret;\r\nreturn configure_adc(1);\r\n}\r\nstatic int reset_stopbit(uint16_t addr)\r\n{\r\nint ret;\r\nuint8_t data;\r\nret = intel_msic_reg_read(addr, &data);\r\nif (ret)\r\nreturn ret;\r\nreturn intel_msic_reg_write(addr, (data & 0xEF));\r\n}\r\nstatic int find_free_channel(void)\r\n{\r\nint ret;\r\nint i;\r\nuint8_t data;\r\nret = intel_msic_reg_read(INTEL_MSIC_ADC1CNTL1, &data);\r\nif (ret)\r\nreturn ret;\r\nif ((data & MSIC_ADC_ENBL) == 0)\r\nreturn 0;\r\nfor (i = 0; i < ADC_CHANLS_MAX; i++) {\r\nret = intel_msic_reg_read(ADC_CHNL_START_ADDR + i, &data);\r\nif (ret)\r\nreturn ret;\r\nif (data & MSIC_STOPBIT_MASK) {\r\nret = i;\r\nbreak;\r\n}\r\n}\r\nreturn (ret > ADC_LOOP_MAX) ? (-EINVAL) : ret;\r\n}\r\nstatic int mid_initialize_adc(struct device *dev)\r\n{\r\nu8 data;\r\nu16 base_addr;\r\nint ret;\r\nret = intel_msic_reg_read(INTEL_MSIC_ADC1CNTL3, &data);\r\nif (ret)\r\nreturn ret;\r\ndata &= ~MSIC_ADCTHERM_MASK;\r\nret = intel_msic_reg_write(INTEL_MSIC_ADC1CNTL3, data);\r\nif (ret)\r\nreturn ret;\r\nchannel_index = find_free_channel();\r\nif (channel_index < 0) {\r\ndev_err(dev, "No free ADC channels");\r\nreturn channel_index;\r\n}\r\nbase_addr = ADC_CHNL_START_ADDR + channel_index;\r\nif (!(channel_index == 0 || channel_index == ADC_LOOP_MAX)) {\r\nret = reset_stopbit(base_addr);\r\nif (ret)\r\nreturn ret;\r\nbase_addr++;\r\nchannel_index++;\r\n}\r\nret = set_up_therm_channel(base_addr);\r\nif (ret) {\r\ndev_err(dev, "unable to enable ADC");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "ADC initialization successful");\r\nreturn ret;\r\n}\r\nstatic struct thermal_device_info *initialize_sensor(int index)\r\n{\r\nstruct thermal_device_info *td_info =\r\nkzalloc(sizeof(struct thermal_device_info), GFP_KERNEL);\r\nif (!td_info)\r\nreturn NULL;\r\ntd_info->chnl_addr = ADC_DATA_START_ADDR + 2 * (channel_index + index);\r\nif (index == 3)\r\ntd_info->direct = 1;\r\nreturn td_info;\r\n}\r\nstatic int mid_thermal_resume(struct device *dev)\r\n{\r\nreturn mid_initialize_adc(dev);\r\n}\r\nstatic int mid_thermal_suspend(struct device *dev)\r\n{\r\nreturn configure_adc(0);\r\n}\r\nstatic int read_curr_temp(struct thermal_zone_device *tzd, unsigned long *temp)\r\n{\r\nWARN_ON(tzd == NULL);\r\nreturn mid_read_temp(tzd, temp);\r\n}\r\nstatic int mid_thermal_probe(struct platform_device *pdev)\r\n{\r\nstatic char *name[MSIC_THERMAL_SENSORS] = {\r\n"skin0", "skin1", "sys", "msicdie"\r\n};\r\nint ret;\r\nint i;\r\nstruct platform_info *pinfo;\r\npinfo = kzalloc(sizeof(struct platform_info), GFP_KERNEL);\r\nif (!pinfo)\r\nreturn -ENOMEM;\r\nret = mid_initialize_adc(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "ADC init failed");\r\nkfree(pinfo);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < MSIC_THERMAL_SENSORS; i++) {\r\nstruct thermal_device_info *td_info = initialize_sensor(i);\r\nif (!td_info) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npinfo->tzd[i] = thermal_zone_device_register(name[i],\r\n0, 0, td_info, &tzd_ops, NULL, 0, 0);\r\nif (IS_ERR(pinfo->tzd[i])) {\r\nkfree(td_info);\r\nret = PTR_ERR(pinfo->tzd[i]);\r\ngoto err;\r\n}\r\n}\r\npinfo->pdev = pdev;\r\nplatform_set_drvdata(pdev, pinfo);\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0) {\r\nkfree(pinfo->tzd[i]->devdata);\r\nthermal_zone_device_unregister(pinfo->tzd[i]);\r\n}\r\nconfigure_adc(0);\r\nkfree(pinfo);\r\nreturn ret;\r\n}\r\nstatic int mid_thermal_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct platform_info *pinfo = platform_get_drvdata(pdev);\r\nfor (i = 0; i < MSIC_THERMAL_SENSORS; i++) {\r\nkfree(pinfo->tzd[i]->devdata);\r\nthermal_zone_device_unregister(pinfo->tzd[i]);\r\n}\r\nkfree(pinfo);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn configure_adc(0);\r\n}
