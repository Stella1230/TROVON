static int pcl812_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nint n;\r\nint timeout, hi;\r\noutb(devpriv->mode_reg_int | 1, dev->iobase + PCL812_MODE);\r\nsetup_range_channel(dev, s, insn->chanspec, 1);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(255, dev->iobase + PCL812_SOFTTRIG);\r\nudelay(5);\r\ntimeout = 50;\r\nwhile (timeout--) {\r\nhi = inb(dev->iobase + PCL812_AD_HI);\r\nif (!(hi & PCL812_DRDY))\r\ngoto conv_finish;\r\nudelay(1);\r\n}\r\nprintk\r\n("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",\r\ndev->minor, dev->board_name, dev->iobase);\r\noutb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);\r\nreturn -ETIME;\r\nconv_finish:\r\ndata[n] = ((hi & 0xf) << 8) | inb(dev->iobase + PCL812_AD_LO);\r\n}\r\noutb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);\r\nreturn n;\r\n}\r\nstatic int acl8216_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint timeout;\r\noutb(1, dev->iobase + PCL812_MODE);\r\nsetup_range_channel(dev, s, insn->chanspec, 1);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(255, dev->iobase + PCL812_SOFTTRIG);\r\nudelay(5);\r\ntimeout = 50;\r\nwhile (timeout--) {\r\nif (!(inb(dev->iobase + ACL8216_STATUS) & ACL8216_DRDY))\r\ngoto conv_finish;\r\nudelay(1);\r\n}\r\nprintk\r\n("comedi%d: pcl812: (%s at 0x%lx) A/D insn read timeout\n",\r\ndev->minor, dev->board_name, dev->iobase);\r\noutb(0, dev->iobase + PCL812_MODE);\r\nreturn -ETIME;\r\nconv_finish:\r\ndata[n] =\r\n(inb(dev->iobase +\r\nPCL812_AD_HI) << 8) | inb(dev->iobase + PCL812_AD_LO);\r\n}\r\noutb(0, dev->iobase + PCL812_MODE);\r\nreturn n;\r\n}\r\nstatic int pcl812_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nint chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\noutb((data[i] & 0xff),\r\ndev->iobase + (chan ? PCL812_DA2_LO : PCL812_DA1_LO));\r\noutb((data[i] >> 8) & 0x0f,\r\ndev->iobase + (chan ? PCL812_DA2_HI : PCL812_DA1_HI));\r\ndevpriv->ao_readback[chan] = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int pcl812_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nint chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic int pcl812_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + PCL812_DI_LO);\r\ndata[1] |= inb(dev->iobase + PCL812_DI_HI) << 8;\r\nreturn insn->n;\r\n}\r\nstatic int pcl812_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= data[0] & data[1];\r\noutb(s->state & 0xff, dev->iobase + PCL812_DO_LO);\r\noutb((s->state >> 8), dev->iobase + PCL812_DO_HI);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int pcl812_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct pcl812_board *board = comedi_board(dev);\r\nstruct pcl812_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int flags;\r\nint tmp, divisor1, divisor2;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nif (devpriv->use_ext_trg)\r\nflags = TRIG_EXT;\r\nelse\r\nflags = TRIG_TIMER;\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, flags);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_ns_min);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= cfc_check_trigger_arg_max(&cmd->chanlist_len, MAX_CHANLIST_LEN);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer(board->i8254_osc_base, &divisor1,\r\n&divisor2, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->convert_arg < board->ai_ns_min)\r\ncmd->convert_arg = board->ai_ns_min;\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int pcl812_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct pcl812_board *board = comedi_board(dev);\r\nstruct pcl812_private *devpriv = dev->private;\r\nunsigned int divisor1 = 0, divisor2 = 0, i, dma_flags, bytes;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (cmd->start_src != TRIG_NOW)\r\nreturn -EINVAL;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW)\r\nreturn -EINVAL;\r\nif (devpriv->use_ext_trg) {\r\nif (cmd->convert_src != TRIG_EXT)\r\nreturn -EINVAL;\r\n} else {\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn -EINVAL;\r\n}\r\nif (cmd->scan_end_src != TRIG_COUNT)\r\nreturn -EINVAL;\r\nif (cmd->scan_end_arg != cmd->chanlist_len)\r\nreturn -EINVAL;\r\nif (cmd->chanlist_len > MAX_CHANLIST_LEN)\r\nreturn -EINVAL;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < board->ai_ns_min)\r\ncmd->convert_arg = board->ai_ns_min;\r\ni8253_cascade_ns_to_timer(board->i8254_osc_base,\r\n&divisor1, &divisor2,\r\n&cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\n}\r\nstart_pacer(dev, -1, 0, 0);\r\ndevpriv->ai_n_chan = cmd->chanlist_len;\r\nmemcpy(devpriv->ai_chanlist, cmd->chanlist,\r\nsizeof(unsigned int) * cmd->scan_end_arg);\r\nsetup_range_channel(dev, s, devpriv->ai_chanlist[0], 1);\r\nif (devpriv->dma) {\r\ndevpriv->ai_dma = 1;\r\nfor (i = 1; i < devpriv->ai_n_chan; i++)\r\nif (devpriv->ai_chanlist[0] != devpriv->ai_chanlist[i]) {\r\ndevpriv->ai_dma = 0;\r\nbreak;\r\n}\r\n} else\r\ndevpriv->ai_dma = 0;\r\ndevpriv->ai_flags = cmd->flags;\r\ndevpriv->ai_data_len = s->async->prealloc_bufsz;\r\ndevpriv->ai_data = s->async->prealloc_buf;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\ndevpriv->ai_scans = cmd->stop_arg;\r\ndevpriv->ai_neverending = 0;\r\n} else {\r\ndevpriv->ai_scans = 0;\r\ndevpriv->ai_neverending = 1;\r\n}\r\ndevpriv->ai_act_scan = 0;\r\ndevpriv->ai_poll_ptr = 0;\r\ns->async->cur_chan = 0;\r\nif ((devpriv->ai_flags & TRIG_WAKE_EOS)) {\r\ndevpriv->ai_eos = 1;\r\nif (devpriv->ai_n_chan == 1)\r\ndevpriv->ai_dma = 0;\r\n}\r\nif (devpriv->ai_dma) {\r\nif (devpriv->ai_eos) {\r\ndevpriv->dmabytestomove[0] =\r\ndevpriv->ai_n_chan * sizeof(short);\r\ndevpriv->dmabytestomove[1] =\r\ndevpriv->ai_n_chan * sizeof(short);\r\ndevpriv->dma_runs_to_end = 1;\r\n} else {\r\ndevpriv->dmabytestomove[0] = devpriv->hwdmasize[0];\r\ndevpriv->dmabytestomove[1] = devpriv->hwdmasize[1];\r\nif (devpriv->ai_data_len < devpriv->hwdmasize[0])\r\ndevpriv->dmabytestomove[0] =\r\ndevpriv->ai_data_len;\r\nif (devpriv->ai_data_len < devpriv->hwdmasize[1])\r\ndevpriv->dmabytestomove[1] =\r\ndevpriv->ai_data_len;\r\nif (devpriv->ai_neverending) {\r\ndevpriv->dma_runs_to_end = 1;\r\n} else {\r\nbytes = devpriv->ai_n_chan *\r\ndevpriv->ai_scans * sizeof(short);\r\ndevpriv->dma_runs_to_end =\r\nbytes / devpriv->dmabytestomove[0];\r\ndevpriv->last_dma_run =\r\nbytes % devpriv->dmabytestomove[0];\r\nif (devpriv->dma_runs_to_end == 0)\r\ndevpriv->dmabytestomove[0] =\r\ndevpriv->last_dma_run;\r\ndevpriv->dma_runs_to_end--;\r\n}\r\n}\r\nif (devpriv->dmabytestomove[0] > devpriv->hwdmasize[0]) {\r\ndevpriv->dmabytestomove[0] = devpriv->hwdmasize[0];\r\ndevpriv->ai_eos = 0;\r\n}\r\nif (devpriv->dmabytestomove[1] > devpriv->hwdmasize[1]) {\r\ndevpriv->dmabytestomove[1] = devpriv->hwdmasize[1];\r\ndevpriv->ai_eos = 0;\r\n}\r\ndevpriv->next_dma_buf = 0;\r\nset_dma_mode(devpriv->dma, DMA_MODE_READ);\r\ndma_flags = claim_dma_lock();\r\nclear_dma_ff(devpriv->dma);\r\nset_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);\r\nset_dma_count(devpriv->dma, devpriv->dmabytestomove[0]);\r\nrelease_dma_lock(dma_flags);\r\nenable_dma(devpriv->dma);\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\nstart_pacer(dev, 1, divisor1, divisor2);\r\nbreak;\r\n}\r\nif (devpriv->ai_dma)\r\noutb(devpriv->mode_reg_int | 2, dev->iobase + PCL812_MODE);\r\nelse\r\noutb(devpriv->mode_reg_int | 6, dev->iobase + PCL812_MODE);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t interrupt_pcl812_ai_int(int irq, void *d)\r\n{\r\nchar err = 1;\r\nunsigned int mask, timeout;\r\nstruct comedi_device *dev = d;\r\nstruct pcl812_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nunsigned int next_chan;\r\ns->async->events = 0;\r\ntimeout = 50;\r\nif (devpriv->ai_is16b) {\r\nmask = 0xffff;\r\nwhile (timeout--) {\r\nif (!(inb(dev->iobase + ACL8216_STATUS) & ACL8216_DRDY)) {\r\nerr = 0;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n} else {\r\nmask = 0x0fff;\r\nwhile (timeout--) {\r\nif (!(inb(dev->iobase + PCL812_AD_HI) & PCL812_DRDY)) {\r\nerr = 0;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nif (err) {\r\nprintk\r\n("comedi%d: pcl812: (%s at 0x%lx) "\r\n"A/D cmd IRQ without DRDY!\n",\r\ndev->minor, dev->board_name, dev->iobase);\r\npcl812_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\ncomedi_buf_put(s->async,\r\n((inb(dev->iobase + PCL812_AD_HI) << 8) |\r\ninb(dev->iobase + PCL812_AD_LO)) & mask);\r\nnext_chan = s->async->cur_chan + 1;\r\nif (next_chan >= devpriv->ai_n_chan)\r\nnext_chan = 0;\r\nif (devpriv->ai_chanlist[s->async->cur_chan] !=\r\ndevpriv->ai_chanlist[next_chan])\r\nsetup_range_channel(dev, s, devpriv->ai_chanlist[next_chan], 0);\r\noutb(0, dev->iobase + PCL812_CLRINT);\r\ns->async->cur_chan = next_chan;\r\nif (next_chan == 0) {\r\ndevpriv->ai_act_scan++;\r\nif (!(devpriv->ai_neverending))\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npcl812_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void transfer_from_dma_buf(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, short *ptr,\r\nunsigned int bufptr, unsigned int len)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nunsigned int i;\r\ns->async->events = 0;\r\nfor (i = len; i; i--) {\r\ncomedi_buf_put(s->async, ptr[bufptr++]);\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan) {\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_act_scan++;\r\nif (!devpriv->ai_neverending)\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npcl812_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\nbreak;\r\n}\r\n}\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic irqreturn_t interrupt_pcl812_ai_dma(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl812_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nunsigned long dma_flags;\r\nint len, bufptr;\r\nshort *ptr;\r\nptr = (short *)devpriv->dmabuf[devpriv->next_dma_buf];\r\nlen = (devpriv->dmabytestomove[devpriv->next_dma_buf] >> 1) -\r\ndevpriv->ai_poll_ptr;\r\ndevpriv->next_dma_buf = 1 - devpriv->next_dma_buf;\r\ndisable_dma(devpriv->dma);\r\nset_dma_mode(devpriv->dma, DMA_MODE_READ);\r\ndma_flags = claim_dma_lock();\r\nset_dma_addr(devpriv->dma, devpriv->hwdmaptr[devpriv->next_dma_buf]);\r\nif (devpriv->ai_eos) {\r\nset_dma_count(devpriv->dma,\r\ndevpriv->dmabytestomove[devpriv->next_dma_buf]);\r\n} else {\r\nif (devpriv->dma_runs_to_end) {\r\nset_dma_count(devpriv->dma,\r\ndevpriv->dmabytestomove[devpriv->\r\nnext_dma_buf]);\r\n} else {\r\nset_dma_count(devpriv->dma, devpriv->last_dma_run);\r\n}\r\ndevpriv->dma_runs_to_end--;\r\n}\r\nrelease_dma_lock(dma_flags);\r\nenable_dma(devpriv->dma);\r\noutb(0, dev->iobase + PCL812_CLRINT);\r\nbufptr = devpriv->ai_poll_ptr;\r\ndevpriv->ai_poll_ptr = 0;\r\ntransfer_from_dma_buf(dev, s, ptr, bufptr, len);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t interrupt_pcl812(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (!dev->attached) {\r\ncomedi_error(dev, "spurious interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->ai_dma)\r\nreturn interrupt_pcl812_ai_dma(irq, d);\r\nelse\r\nreturn interrupt_pcl812_ai_int(irq, d);\r\n}\r\nstatic int pcl812_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nunsigned long flags;\r\nunsigned int top1, top2, i;\r\nif (!devpriv->ai_dma)\r\nreturn 0;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < 10; i++) {\r\ntop1 = get_dma_residue(devpriv->ai_dma);\r\ntop2 = get_dma_residue(devpriv->ai_dma);\r\nif (top1 == top2)\r\nbreak;\r\n}\r\nif (top1 != top2) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\ntop1 = devpriv->dmabytestomove[1 - devpriv->next_dma_buf] - top1;\r\ntop1 >>= 1;\r\ntop2 = top1 - devpriv->ai_poll_ptr;\r\nif (top2 < 1) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\ntransfer_from_dma_buf(dev, s,\r\n(void *)devpriv->dmabuf[1 -\r\ndevpriv->next_dma_buf],\r\ndevpriv->ai_poll_ptr, top2);\r\ndevpriv->ai_poll_ptr = top1;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn s->async->buf_write_count - s->async->buf_read_count;\r\n}\r\nstatic void setup_range_channel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int rangechan, char wait)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nunsigned char chan_reg = CR_CHAN(rangechan);\r\nunsigned char gain_reg = CR_RANGE(rangechan) +\r\ndevpriv->range_correction;\r\nif ((chan_reg == devpriv->old_chan_reg)\r\n&& (gain_reg == devpriv->old_gain_reg))\r\nreturn;\r\ndevpriv->old_chan_reg = chan_reg;\r\ndevpriv->old_gain_reg = gain_reg;\r\nif (devpriv->use_MPC) {\r\nif (devpriv->use_diff) {\r\nchan_reg = chan_reg | 0x30;\r\n} else {\r\nif (chan_reg & 0x80)\r\nchan_reg = chan_reg | 0x20;\r\nelse\r\nchan_reg = chan_reg | 0x10;\r\n}\r\n}\r\noutb(chan_reg, dev->iobase + PCL812_MUX);\r\noutb(gain_reg, dev->iobase + PCL812_GAIN);\r\nif (wait)\r\nudelay(devpriv->max_812_ai_mode0_rangewait);\r\n}\r\nstatic void start_pacer(struct comedi_device *dev, int mode,\r\nunsigned int divisor1, unsigned int divisor2)\r\n{\r\noutb(0xb4, dev->iobase + PCL812_CTRCTL);\r\noutb(0x74, dev->iobase + PCL812_CTRCTL);\r\nudelay(1);\r\nif (mode == 1) {\r\noutb(divisor2 & 0xff, dev->iobase + PCL812_CTR2);\r\noutb((divisor2 >> 8) & 0xff, dev->iobase + PCL812_CTR2);\r\noutb(divisor1 & 0xff, dev->iobase + PCL812_CTR1);\r\noutb((divisor1 >> 8) & 0xff, dev->iobase + PCL812_CTR1);\r\n}\r\n}\r\nstatic int pcl812_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (devpriv->ai_dma)\r\ndisable_dma(devpriv->dma);\r\noutb(0, dev->iobase + PCL812_CLRINT);\r\noutb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);\r\nstart_pacer(dev, -1, 0, 0);\r\noutb(0, dev->iobase + PCL812_CLRINT);\r\nreturn 0;\r\n}\r\nstatic void pcl812_reset(struct comedi_device *dev)\r\n{\r\nconst struct pcl812_board *board = comedi_board(dev);\r\nstruct pcl812_private *devpriv = dev->private;\r\noutb(0, dev->iobase + PCL812_MUX);\r\noutb(0 + devpriv->range_correction, dev->iobase + PCL812_GAIN);\r\ndevpriv->old_chan_reg = -1;\r\ndevpriv->old_gain_reg = -1;\r\nswitch (board->board_type) {\r\ncase boardPCL812PG:\r\ncase boardPCL812:\r\ncase boardACL8112:\r\ncase boardACL8216:\r\noutb(0, dev->iobase + PCL812_DA2_LO);\r\noutb(0, dev->iobase + PCL812_DA2_HI);\r\ncase boardA821:\r\noutb(0, dev->iobase + PCL812_DA1_LO);\r\noutb(0, dev->iobase + PCL812_DA1_HI);\r\nstart_pacer(dev, -1, 0, 0);\r\noutb(0, dev->iobase + PCL812_DO_HI);\r\noutb(0, dev->iobase + PCL812_DO_LO);\r\noutb(devpriv->mode_reg_int | 0, dev->iobase + PCL812_MODE);\r\noutb(0, dev->iobase + PCL812_CLRINT);\r\nbreak;\r\ncase boardPCL813B:\r\ncase boardPCL813:\r\ncase boardISO813:\r\ncase boardACL8113:\r\nudelay(5);\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nstatic int pcl812_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcl812_board *board = comedi_board(dev);\r\nstruct pcl812_private *devpriv;\r\nint ret, subdev;\r\nunsigned int irq;\r\nunsigned int dma;\r\nunsigned long pages;\r\nstruct comedi_subdevice *s;\r\nint n_subdevices;\r\nret = comedi_request_region(dev, it->options[0], board->io_range);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\nirq = 0;\r\nif (board->IRQbits != 0) {\r\nirq = it->options[1];\r\nif (irq) {\r\nif (((1 << irq) & board->IRQbits) == 0) {\r\nprintk\r\n(", IRQ %u is out of allowed range, "\r\n"DISABLING IT", irq);\r\nirq = 0;\r\n} else {\r\nif (request_irq(irq, interrupt_pcl812, 0,\r\ndev->board_name, dev)) {\r\nprintk\r\n(", unable to allocate IRQ %u, "\r\n"DISABLING IT", irq);\r\nirq = 0;\r\n} else {\r\nprintk(KERN_INFO ", irq=%u", irq);\r\n}\r\n}\r\n}\r\n}\r\ndev->irq = irq;\r\ndma = 0;\r\ndevpriv->dma = dma;\r\nif (!dev->irq)\r\ngoto no_dma;\r\nif (board->DMAbits != 0) {\r\ndma = it->options[2];\r\nif (((1 << dma) & board->DMAbits) == 0) {\r\nprintk(", DMA is out of allowed range, FAIL!\n");\r\nreturn -EINVAL;\r\n}\r\nret = request_dma(dma, dev->board_name);\r\nif (ret) {\r\nprintk(KERN_ERR ", unable to allocate DMA %u, FAIL!\n",\r\ndma);\r\nreturn -EBUSY;\r\n}\r\ndevpriv->dma = dma;\r\nprintk(KERN_INFO ", dma=%u", dma);\r\npages = 1;\r\ndevpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);\r\nif (!devpriv->dmabuf[0]) {\r\nprintk(", unable to allocate DMA buffer, FAIL!\n");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->dmapages[0] = pages;\r\ndevpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);\r\ndevpriv->hwdmasize[0] = PAGE_SIZE * (1 << pages);\r\ndevpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);\r\nif (!devpriv->dmabuf[1]) {\r\nprintk(KERN_ERR ", unable to allocate DMA buffer, FAIL!\n");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->dmapages[1] = pages;\r\ndevpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);\r\ndevpriv->hwdmasize[1] = PAGE_SIZE * (1 << pages);\r\n}\r\nno_dma:\r\nn_subdevices = 0;\r\nif (board->n_aichan > 0)\r\nn_subdevices++;\r\nif (board->n_aochan > 0)\r\nn_subdevices++;\r\nif (board->n_dichan > 0)\r\nn_subdevices++;\r\nif (board->n_dochan > 0)\r\nn_subdevices++;\r\nret = comedi_alloc_subdevices(dev, n_subdevices);\r\nif (ret)\r\nreturn ret;\r\nsubdev = 0;\r\nif (board->n_aichan > 0) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE;\r\nswitch (board->board_type) {\r\ncase boardA821:\r\nif (it->options[2] == 1) {\r\ns->n_chan = board->n_aichan_diff;\r\ns->subdev_flags |= SDF_DIFF;\r\ndevpriv->use_diff = 1;\r\n} else {\r\ns->n_chan = board->n_aichan;\r\ns->subdev_flags |= SDF_GROUND;\r\n}\r\nbreak;\r\ncase boardACL8112:\r\ncase boardACL8216:\r\nif (it->options[4] == 1) {\r\ns->n_chan = board->n_aichan_diff;\r\ns->subdev_flags |= SDF_DIFF;\r\ndevpriv->use_diff = 1;\r\n} else {\r\ns->n_chan = board->n_aichan;\r\ns->subdev_flags |= SDF_GROUND;\r\n}\r\nbreak;\r\ndefault:\r\ns->n_chan = board->n_aichan;\r\ns->subdev_flags |= SDF_GROUND;\r\nbreak;\r\n}\r\ns->maxdata = board->ai_maxdata;\r\ns->len_chanlist = MAX_CHANLIST_LEN;\r\ns->range_table = board->rangelist_ai;\r\nif (board->board_type == boardACL8216)\r\ns->insn_read = acl8216_ai_insn_read;\r\nelse\r\ns->insn_read = pcl812_ai_insn_read;\r\ndevpriv->use_MPC = board->haveMPC508;\r\ns->cancel = pcl812_ai_cancel;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmdtest = pcl812_ai_cmdtest;\r\ns->do_cmd = pcl812_ai_cmd;\r\ns->poll = pcl812_ai_poll;\r\n}\r\nswitch (board->board_type) {\r\ncase boardPCL812PG:\r\nif (it->options[4] == 1)\r\ns->range_table = &range_pcl812pg2_ai;\r\nbreak;\r\ncase boardPCL812:\r\nswitch (it->options[4]) {\r\ncase 0:\r\ns->range_table = &range_bipolar10;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_bipolar5;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_bipolar2_5;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range812_bipolar1_25;\r\nbreak;\r\ncase 4:\r\ns->range_table = &range812_bipolar0_625;\r\nbreak;\r\ncase 5:\r\ns->range_table = &range812_bipolar0_3125;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_bipolar10;\r\nbreak;\r\nprintk\r\n(", incorrect range number %d, changing "\r\n"to 0 (+/-10V)", it->options[4]);\r\nbreak;\r\n}\r\nbreak;\r\nbreak;\r\ncase boardPCL813B:\r\nif (it->options[1] == 1)\r\ns->range_table = &range_pcl813b2_ai;\r\nbreak;\r\ncase boardISO813:\r\nswitch (it->options[1]) {\r\ncase 0:\r\ns->range_table = &range_iso813_1_ai;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_iso813_1_2_ai;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_iso813_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range_iso813_2_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_iso813_1_ai;\r\nbreak;\r\nprintk\r\n(", incorrect range number %d, "\r\n"changing to 0 ", it->options[1]);\r\nbreak;\r\n}\r\nbreak;\r\ncase boardACL8113:\r\nswitch (it->options[1]) {\r\ncase 0:\r\ns->range_table = &range_acl8113_1_ai;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_acl8113_1_2_ai;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_acl8113_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range_acl8113_2_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_acl8113_1_ai;\r\nbreak;\r\nprintk\r\n(", incorrect range number %d, "\r\n"changing to 0 ", it->options[1]);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nsubdev++;\r\n}\r\nif (board->n_aochan > 0) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = 0xfff;\r\ns->len_chanlist = 1;\r\ns->range_table = board->rangelist_ao;\r\ns->insn_read = pcl812_ao_insn_read;\r\ns->insn_write = pcl812_ao_insn_write;\r\nswitch (board->board_type) {\r\ncase boardA821:\r\nif (it->options[3] == 1)\r\ns->range_table = &range_unipolar10;\r\nbreak;\r\ncase boardPCL812:\r\ncase boardACL8112:\r\ncase boardPCL812PG:\r\ncase boardACL8216:\r\nif (it->options[5] == 1)\r\ns->range_table = &range_unipolar10;\r\nif (it->options[5] == 2)\r\ns->range_table = &range_unknown;\r\nbreak;\r\n}\r\nsubdev++;\r\n}\r\nif (board->n_dichan > 0) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = board->n_dichan;\r\ns->maxdata = 1;\r\ns->len_chanlist = board->n_dichan;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl812_di_insn_bits;\r\nsubdev++;\r\n}\r\nif (board->n_dochan > 0) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->n_dochan;\r\ns->maxdata = 1;\r\ns->len_chanlist = board->n_dochan;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl812_do_insn_bits;\r\nsubdev++;\r\n}\r\nswitch (board->board_type) {\r\ncase boardACL8216:\r\ndevpriv->ai_is16b = 1;\r\ncase boardPCL812PG:\r\ncase boardPCL812:\r\ncase boardACL8112:\r\ndevpriv->max_812_ai_mode0_rangewait = 1;\r\nif (it->options[3] > 0)\r\ndevpriv->use_ext_trg = 1;\r\ncase boardA821:\r\ndevpriv->max_812_ai_mode0_rangewait = 1;\r\ndevpriv->mode_reg_int = (irq << 4) & 0xf0;\r\nbreak;\r\ncase boardPCL813B:\r\ncase boardPCL813:\r\ncase boardISO813:\r\ncase boardACL8113:\r\ndevpriv->max_812_ai_mode0_rangewait = 5;\r\nbreak;\r\n}\r\nprintk(KERN_INFO "\n");\r\ndevpriv->valid = 1;\r\npcl812_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void pcl812_detach(struct comedi_device *dev)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (devpriv) {\r\nif (devpriv->dmabuf[0])\r\nfree_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);\r\nif (devpriv->dmabuf[1])\r\nfree_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);\r\nif (devpriv->dma)\r\nfree_dma(devpriv->dma);\r\n}\r\ncomedi_legacy_detach(dev);\r\n}
