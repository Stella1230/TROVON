bool CheckHighPower(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nif(!priv->bRegHighPowerMechanism)\r\nreturn false;\r\nif(ieee->state == IEEE80211_LINKED_SCANNING)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid DoTxHighPower(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu16 HiPwrUpperTh = 0;\r\nu16 HiPwrLowerTh = 0;\r\nu8 RSSIHiPwrUpperTh;\r\nu8 RSSIHiPwrLowerTh;\r\nu8 u1bTmp;\r\nchar OfdmTxPwrIdx, CckTxPwrIdx;\r\nHiPwrUpperTh = priv->RegHiPwrUpperTh;\r\nHiPwrLowerTh = priv->RegHiPwrLowerTh;\r\nHiPwrUpperTh = HiPwrUpperTh * 10;\r\nHiPwrLowerTh = HiPwrLowerTh * 10;\r\nRSSIHiPwrUpperTh = priv->RegRSSIHiPwrUpperTh;\r\nRSSIHiPwrLowerTh = priv->RegRSSIHiPwrLowerTh;\r\nOfdmTxPwrIdx = priv->chtxpwr_ofdm[priv->ieee80211->current_network.channel];\r\nCckTxPwrIdx = priv->chtxpwr[priv->ieee80211->current_network.channel];\r\nif ((priv->UndecoratedSmoothedSS > HiPwrUpperTh) ||\r\n(priv->bCurCCKPkt && (priv->CurCCKRSSI > RSSIHiPwrUpperTh))) {\r\npriv->bToUpdateTxPwr = true;\r\nu1bTmp= read_nic_byte(dev, CCK_TXAGC);\r\nif (CckTxPwrIdx == u1bTmp) {\r\nu1bTmp = (u1bTmp > 16) ? (u1bTmp -16): 0;\r\nwrite_nic_byte(dev, CCK_TXAGC, u1bTmp);\r\nu1bTmp= read_nic_byte(dev, OFDM_TXAGC);\r\nu1bTmp = (u1bTmp > 16) ? (u1bTmp -16): 0;\r\nwrite_nic_byte(dev, OFDM_TXAGC, u1bTmp);\r\n}\r\n} else if ((priv->UndecoratedSmoothedSS < HiPwrLowerTh) &&\r\n(!priv->bCurCCKPkt || priv->CurCCKRSSI < RSSIHiPwrLowerTh)) {\r\nif (priv->bToUpdateTxPwr) {\r\npriv->bToUpdateTxPwr = false;\r\nu1bTmp= read_nic_byte(dev, CCK_TXAGC);\r\nif (u1bTmp < CckTxPwrIdx) {\r\nwrite_nic_byte(dev, CCK_TXAGC, CckTxPwrIdx);\r\n}\r\nu1bTmp= read_nic_byte(dev, OFDM_TXAGC);\r\nif (u1bTmp < OfdmTxPwrIdx) {\r\nwrite_nic_byte(dev, OFDM_TXAGC, OfdmTxPwrIdx);\r\n}\r\n}\r\n}\r\n}\r\nvoid rtl8180_tx_pw_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,tx_pw_wq);\r\nstruct net_device *dev = ieee->dev;\r\nDoTxHighPower(dev);\r\n}\r\nbool CheckDig(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nif (!priv->bDigMechanism)\r\nreturn false;\r\nif (ieee->state != IEEE80211_LINKED)\r\nreturn false;\r\nif ((priv->ieee80211->rate / 5) < 36)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid DIG_Zebra(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu16 CCKFalseAlarm, OFDMFalseAlarm;\r\nu16 OfdmFA1, OfdmFA2;\r\nint InitialGainStep = 7;\r\nint LowestGainStage = 4;\r\nu32 AwakePeriodIn2Sec = 0;\r\nCCKFalseAlarm = (u16)(priv->FalseAlarmRegValue & 0x0000ffff);\r\nOFDMFalseAlarm = (u16)((priv->FalseAlarmRegValue >> 16) & 0x0000ffff);\r\nOfdmFA1 = 0x15;\r\nOfdmFA2 = ((u16)(priv->RegDigOfdmFaUpTh)) << 8;\r\nif (priv->InitialGain == 0) {\r\npriv->InitialGain = 4;\r\n}\r\nOfdmFA1 = 0x20;\r\n#if 1\r\nAwakePeriodIn2Sec = (2000 - priv->DozePeriodInPast2Sec);\r\npriv ->DozePeriodInPast2Sec = 0;\r\nif (AwakePeriodIn2Sec) {\r\nOfdmFA1 = (u16)((OfdmFA1 * AwakePeriodIn2Sec) / 2000) ;\r\nOfdmFA2 = (u16)((OfdmFA2 * AwakePeriodIn2Sec) / 2000) ;\r\n} else {\r\n;\r\n}\r\n#endif\r\nInitialGainStep = 8;\r\nLowestGainStage = priv->RegBModeGainStage;\r\nif (OFDMFalseAlarm > OfdmFA1) {\r\nif (OFDMFalseAlarm > OfdmFA2) {\r\npriv->DIG_NumberFallbackVote++;\r\nif (priv->DIG_NumberFallbackVote > 1) {\r\nif (priv->InitialGain < InitialGainStep) {\r\npriv->InitialGainBackUp = priv->InitialGain;\r\npriv->InitialGain = (priv->InitialGain + 1);\r\nUpdateInitialGain(dev);\r\n}\r\npriv->DIG_NumberFallbackVote = 0;\r\npriv->DIG_NumberUpgradeVote = 0;\r\n}\r\n} else {\r\nif (priv->DIG_NumberFallbackVote)\r\npriv->DIG_NumberFallbackVote--;\r\n}\r\npriv->DIG_NumberUpgradeVote = 0;\r\n} else {\r\nif (priv->DIG_NumberFallbackVote)\r\npriv->DIG_NumberFallbackVote--;\r\npriv->DIG_NumberUpgradeVote++;\r\nif (priv->DIG_NumberUpgradeVote > 9) {\r\nif (priv->InitialGain > LowestGainStage) {\r\npriv->InitialGainBackUp = priv->InitialGain;\r\npriv->InitialGain = (priv->InitialGain - 1);\r\nUpdateInitialGain(dev);\r\n}\r\npriv->DIG_NumberFallbackVote = 0;\r\npriv->DIG_NumberUpgradeVote = 0;\r\n}\r\n}\r\n}\r\nvoid DynamicInitGain(struct net_device *dev)\r\n{\r\nDIG_Zebra(dev);\r\n}\r\nvoid rtl8180_hw_dig_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_dig_wq);\r\nstruct net_device *dev = ieee->dev;\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\npriv->FalseAlarmRegValue = read_nic_dword(dev, CCK_FALSE_ALARM);\r\nDynamicInitGain(dev);\r\n}\r\nint IncludedInSupportedRates(struct r8180_priv *priv, u8 TxRate)\r\n{\r\nu8 rate_len;\r\nu8 rate_ex_len;\r\nu8 RateMask = 0x7F;\r\nu8 idx;\r\nunsigned short Found = 0;\r\nu8 NaiveTxRate = TxRate&RateMask;\r\nrate_len = priv->ieee80211->current_network.rates_len;\r\nrate_ex_len = priv->ieee80211->current_network.rates_ex_len;\r\nfor (idx=0; idx < rate_len; idx++) {\r\nif ((priv->ieee80211->current_network.rates[idx] & RateMask) == NaiveTxRate) {\r\nFound = 1;\r\ngoto found_rate;\r\n}\r\n}\r\nfor (idx = 0; idx < rate_ex_len; idx++) {\r\nif ((priv->ieee80211->current_network.rates_ex[idx] & RateMask) == NaiveTxRate) {\r\nFound = 1;\r\ngoto found_rate;\r\n}\r\n}\r\nreturn Found;\r\nfound_rate:\r\nreturn Found;\r\n}\r\nu8 GetUpgradeTxRate(struct net_device *dev, u8 rate)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu8 UpRate;\r\nswitch (rate) {\r\ncase 108:\r\nUpRate = 108;\r\nbreak;\r\ncase 96:\r\nUpRate = 108;\r\nbreak;\r\ncase 72:\r\nUpRate = 96;\r\nbreak;\r\ncase 48:\r\nUpRate = 72;\r\nbreak;\r\ncase 36:\r\nUpRate = 48;\r\nbreak;\r\ncase 22:\r\nUpRate = 36;\r\nbreak;\r\ncase 11:\r\nUpRate = 22;\r\nbreak;\r\ncase 4:\r\nUpRate = 11;\r\nbreak;\r\ncase 2:\r\nUpRate = 4;\r\nbreak;\r\ndefault:\r\nprintk("GetUpgradeTxRate(): Input Tx Rate(%d) is undefined!\n", rate);\r\nreturn rate;\r\n}\r\nif (IncludedInSupportedRates(priv, UpRate)) {\r\nreturn UpRate;\r\n} else {\r\nreturn rate;\r\n}\r\nreturn rate;\r\n}\r\nu8 GetDegradeTxRate(struct net_device *dev, u8 rate)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu8 DownRate;\r\nswitch (rate) {\r\ncase 108:\r\nDownRate = 96;\r\nbreak;\r\ncase 96:\r\nDownRate = 72;\r\nbreak;\r\ncase 72:\r\nDownRate = 48;\r\nbreak;\r\ncase 48:\r\nDownRate = 36;\r\nbreak;\r\ncase 36:\r\nDownRate = 22;\r\nbreak;\r\ncase 22:\r\nDownRate = 11;\r\nbreak;\r\ncase 11:\r\nDownRate = 4;\r\nbreak;\r\ncase 4:\r\nDownRate = 2;\r\nbreak;\r\ncase 2:\r\nDownRate = 2;\r\nbreak;\r\ndefault:\r\nprintk("GetDegradeTxRate(): Input Tx Rate(%d) is undefined!\n", rate);\r\nreturn rate;\r\n}\r\nif (IncludedInSupportedRates(priv, DownRate)) {\r\nreturn DownRate;\r\n} else {\r\nreturn rate;\r\n}\r\nreturn rate;\r\n}\r\nbool MgntIsCckRate(u16 rate)\r\n{\r\nbool bReturn = false;\r\nif ((rate <= 22) && (rate != 12) && (rate != 18)) {\r\nbReturn = true;\r\n}\r\nreturn bReturn;\r\n}\r\nvoid TxPwrTracking87SE(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu8 tmpu1Byte, CurrentThermal, Idx;\r\nchar CckTxPwrIdx, OfdmTxPwrIdx;\r\ntmpu1Byte = read_nic_byte(dev, EN_LPF_CAL);\r\nCurrentThermal = (tmpu1Byte & 0xf0) >> 4;\r\nCurrentThermal = (CurrentThermal > 0x0c) ? 0x0c:CurrentThermal;\r\nif (CurrentThermal != priv->ThermalMeter) {\r\nfor (Idx = 1; Idx < 15; Idx++) {\r\nCckTxPwrIdx = priv->chtxpwr[Idx];\r\nOfdmTxPwrIdx = priv->chtxpwr_ofdm[Idx];\r\nif (CurrentThermal > priv->ThermalMeter) {\r\nCckTxPwrIdx += (CurrentThermal - priv->ThermalMeter) * 2;\r\nOfdmTxPwrIdx += (CurrentThermal - priv->ThermalMeter) * 2;\r\nif (CckTxPwrIdx > 35)\r\nCckTxPwrIdx = 35;\r\nif (OfdmTxPwrIdx > 35)\r\nOfdmTxPwrIdx = 35;\r\n} else {\r\nCckTxPwrIdx -= (priv->ThermalMeter - CurrentThermal) * 2;\r\nOfdmTxPwrIdx -= (priv->ThermalMeter - CurrentThermal) * 2;\r\nif (CckTxPwrIdx < 0)\r\nCckTxPwrIdx = 0;\r\nif (OfdmTxPwrIdx < 0)\r\nOfdmTxPwrIdx = 0;\r\n}\r\npriv->chtxpwr[Idx] = CckTxPwrIdx;\r\npriv->chtxpwr_ofdm[Idx] = OfdmTxPwrIdx;\r\n}\r\nrtl8225z2_SetTXPowerLevel(dev, priv->ieee80211->current_network.channel);\r\n}\r\npriv->ThermalMeter = CurrentThermal;\r\n}\r\nvoid StaRateAdaptive87SE(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nunsigned long CurrTxokCnt;\r\nu16 CurrRetryCnt;\r\nu16 CurrRetryRate;\r\nunsigned long CurrRxokCnt;\r\nbool bTryUp = false;\r\nbool bTryDown = false;\r\nu8 TryUpTh = 1;\r\nu8 TryDownTh = 2;\r\nu32 TxThroughput;\r\nlong CurrSignalStrength;\r\nbool bUpdateInitialGain = false;\r\nu8 u1bOfdm = 0, u1bCck = 0;\r\nchar OfdmTxPwrIdx, CckTxPwrIdx;\r\npriv->RateAdaptivePeriod = RATE_ADAPTIVE_TIMER_PERIOD;\r\nCurrRetryCnt = priv->CurrRetryCnt;\r\nCurrTxokCnt = priv->NumTxOkTotal - priv->LastTxokCnt;\r\nCurrRxokCnt = priv->ieee80211->NumRxOkTotal - priv->LastRxokCnt;\r\nCurrSignalStrength = priv->Stats_RecvSignalPower;\r\nTxThroughput = (u32)(priv->NumTxOkBytesTotal - priv->LastTxOKBytes);\r\npriv->LastTxOKBytes = priv->NumTxOkBytesTotal;\r\npriv->CurrentOperaRate = priv->ieee80211->rate / 5;\r\nif (CurrTxokCnt > 0) {\r\nCurrRetryRate = (u16)(CurrRetryCnt * 100 / CurrTxokCnt);\r\n} else {\r\nCurrRetryRate = (u16)(CurrRetryCnt * 100 / 1);\r\n}\r\npriv->LastRetryCnt = priv->CurrRetryCnt;\r\npriv->LastTxokCnt = priv->NumTxOkTotal;\r\npriv->LastRxokCnt = priv->ieee80211->NumRxOkTotal;\r\npriv->CurrRetryCnt = 0;\r\nif (CurrRetryRate == 0 && CurrTxokCnt == 0) {\r\npriv->TryupingCountNoData++;\r\nif (priv->TryupingCountNoData > 30) {\r\npriv->TryupingCountNoData = 0;\r\npriv->CurrentOperaRate = GetUpgradeTxRate(dev, priv->CurrentOperaRate);\r\npriv->LastFailTxRate = 0;\r\npriv->LastFailTxRateSS = -200;\r\npriv->FailTxRateCount = 0;\r\n}\r\ngoto SetInitialGain;\r\n} else {\r\npriv->TryupingCountNoData = 0;\r\n}\r\nif (priv->CurrentOperaRate == 22 || priv->CurrentOperaRate == 72)\r\nTryUpTh += 9;\r\nif (MgntIsCckRate(priv->CurrentOperaRate) || priv->CurrentOperaRate == 36)\r\nTryDownTh += 1;\r\nif (priv->bTryuping == true) {\r\nif ((CurrRetryRate > 25) && TxThroughput < priv->LastTxThroughput) {\r\nbTryDown = true;\r\n} else {\r\npriv->bTryuping = false;\r\n}\r\n} else if (CurrSignalStrength > -47 && (CurrRetryRate < 50)) {\r\nif (priv->CurrentOperaRate != priv->ieee80211->current_network.HighestOperaRate) {\r\nbTryUp = true;\r\npriv->TryupingCount += TryUpTh;\r\n}\r\n} else if (CurrTxokCnt > 9 && CurrTxokCnt < 100 && CurrRetryRate >= 600) {\r\nbTryDown = true;\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if (priv->CurrentOperaRate == 108) {\r\nif ((CurrRetryRate > 26) && (priv->LastRetryRate > 25)) {\r\nbTryDown = true;\r\n}\r\nelse if ((CurrRetryRate > 17) && (priv->LastRetryRate > 16) && (CurrSignalStrength > -72)) {\r\nbTryDown = true;\r\n}\r\nif (bTryDown && (CurrSignalStrength < -75))\r\npriv->TryDownCountLowData += TryDownTh;\r\n}\r\nelse if (priv->CurrentOperaRate == 96) {\r\nif (((CurrRetryRate > 48) && (priv->LastRetryRate > 47))) {\r\nbTryDown = true;\r\n} else if (((CurrRetryRate > 21) && (priv->LastRetryRate > 20)) && (CurrSignalStrength > -74)) {\r\nbTryDown = true;\r\n} else if ((CurrRetryRate > (priv->LastRetryRate + 50)) && (priv->FailTxRateCount > 2)) {\r\nbTryDown = true;\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if ((CurrRetryRate < 8) && (priv->LastRetryRate < 8)) {\r\nbTryUp = true;\r\n}\r\nif (bTryDown && (CurrSignalStrength < -75)){\r\npriv->TryDownCountLowData += TryDownTh;\r\n}\r\n} else if (priv->CurrentOperaRate == 72) {\r\nif ((CurrRetryRate > 43) && (priv->LastRetryRate > 41)) {\r\nbTryDown = true;\r\n} else if ((CurrRetryRate > (priv->LastRetryRate + 50)) && (priv->FailTxRateCount > 2)) {\r\nbTryDown = true;\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if ((CurrRetryRate < 15) && (priv->LastRetryRate < 16)) {\r\nbTryUp = true;\r\n}\r\nif (bTryDown && (CurrSignalStrength < -80))\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if (priv->CurrentOperaRate == 48) {\r\nif (((CurrRetryRate > 63) && (priv->LastRetryRate > 62))) {\r\nbTryDown = true;\r\n} else if (((CurrRetryRate > 33) && (priv->LastRetryRate > 32)) && (CurrSignalStrength > -82)) {\r\nbTryDown = true;\r\n} else if ((CurrRetryRate > (priv->LastRetryRate + 50)) && (priv->FailTxRateCount > 2 )) {\r\nbTryDown = true;\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if ((CurrRetryRate < 20) && (priv->LastRetryRate < 21)) {\r\nbTryUp = true;\r\n}\r\nif (bTryDown && (CurrSignalStrength < -82))\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if (priv->CurrentOperaRate == 36) {\r\nif (((CurrRetryRate > 85) && (priv->LastRetryRate > 86))) {\r\nbTryDown = true;\r\n} else if ((CurrRetryRate > (priv->LastRetryRate + 50)) && (priv->FailTxRateCount > 2)) {\r\nbTryDown = true;\r\npriv->TryDownCountLowData += TryDownTh;\r\n} else if ((CurrRetryRate < 22) && (priv->LastRetryRate < 23)) {\r\nbTryUp = true;\r\n}\r\n} else if (priv->CurrentOperaRate == 22) {\r\nif (CurrRetryRate > 95) {\r\nbTryDown = true;\r\n}\r\nelse if ((CurrRetryRate < 29) && (priv->LastRetryRate < 30)) {\r\nbTryUp = true;\r\n}\r\n} else if (priv->CurrentOperaRate == 11) {\r\nif (CurrRetryRate > 149) {\r\nbTryDown = true;\r\n} else if ((CurrRetryRate < 60) && (priv->LastRetryRate < 65)) {\r\nbTryUp = true;\r\n}\r\n} else if (priv->CurrentOperaRate == 4) {\r\nif ((CurrRetryRate > 99) && (priv->LastRetryRate > 99)) {\r\nbTryDown = true;\r\n} else if ((CurrRetryRate < 65) && (priv->LastRetryRate < 70)) {\r\nbTryUp = true;\r\n}\r\n} else if (priv->CurrentOperaRate == 2) {\r\nif ((CurrRetryRate < 70) && (priv->LastRetryRate < 75)) {\r\nbTryUp = true;\r\n}\r\n}\r\nif (bTryUp && bTryDown)\r\nprintk("StaRateAdaptive87B(): Tx Rate tried upping and downing simultaneously!\n");\r\nif (!bTryUp && !bTryDown && (priv->TryupingCount == 0) && (priv->TryDownCountLowData == 0)\r\n&& priv->CurrentOperaRate != priv->ieee80211->current_network.HighestOperaRate && priv->FailTxRateCount < 2) {\r\nif (jiffies % (CurrRetryRate + 101) == 0) {\r\nbTryUp = true;\r\npriv->bTryuping = true;\r\n}\r\n}\r\nif (bTryUp) {\r\npriv->TryupingCount++;\r\npriv->TryDownCountLowData = 0;\r\nif ((priv->TryupingCount > (TryUpTh + priv->FailTxRateCount * priv->FailTxRateCount)) ||\r\n(CurrSignalStrength > priv->LastFailTxRateSS) || priv->bTryuping) {\r\npriv->TryupingCount = 0;\r\nif (priv->CurrentOperaRate == 22)\r\nbUpdateInitialGain = true;\r\nif (((priv->CurrentOperaRate == 72) || (priv->CurrentOperaRate == 48) || (priv->CurrentOperaRate == 36)) &&\r\n(priv->FailTxRateCount > 2))\r\npriv->RateAdaptivePeriod = (RATE_ADAPTIVE_TIMER_PERIOD / 2);\r\npriv->CurrentOperaRate = GetUpgradeTxRate(dev, priv->CurrentOperaRate);\r\nif (priv->CurrentOperaRate == 36) {\r\npriv->bUpdateARFR = true;\r\nwrite_nic_word(dev, ARFR, 0x0F8F);\r\n} else if(priv->bUpdateARFR) {\r\npriv->bUpdateARFR = false;\r\nwrite_nic_word(dev, ARFR, 0x0FFF);\r\n}\r\nif (priv->LastFailTxRate != priv->CurrentOperaRate) {\r\npriv->LastFailTxRate = priv->CurrentOperaRate;\r\npriv->FailTxRateCount = 0;\r\npriv->LastFailTxRateSS = -200;\r\n}\r\n}\r\n} else {\r\nif (priv->TryupingCount > 0)\r\npriv->TryupingCount --;\r\n}\r\nif (bTryDown) {\r\npriv->TryDownCountLowData++;\r\npriv->TryupingCount = 0;\r\nif (priv->TryDownCountLowData > TryDownTh || priv->bTryuping) {\r\npriv->TryDownCountLowData = 0;\r\npriv->bTryuping = false;\r\nif (priv->LastFailTxRate == priv->CurrentOperaRate) {\r\npriv->FailTxRateCount++;\r\nif (CurrSignalStrength > priv->LastFailTxRateSS)\r\npriv->LastFailTxRateSS = CurrSignalStrength;\r\n} else {\r\npriv->LastFailTxRate = priv->CurrentOperaRate;\r\npriv->FailTxRateCount = 1;\r\npriv->LastFailTxRateSS = CurrSignalStrength;\r\n}\r\npriv->CurrentOperaRate = GetDegradeTxRate(dev, priv->CurrentOperaRate);\r\nif ((CurrSignalStrength < -80) && (priv->CurrentOperaRate > 72 )) {\r\npriv->CurrentOperaRate = 72;\r\n}\r\nif (priv->CurrentOperaRate == 36) {\r\npriv->bUpdateARFR = true;\r\nwrite_nic_word(dev, ARFR, 0x0F8F);\r\n} else if (priv->bUpdateARFR) {\r\npriv->bUpdateARFR = false;\r\nwrite_nic_word(dev, ARFR, 0x0FFF);\r\n}\r\nif (MgntIsCckRate(priv->CurrentOperaRate)) {\r\nbUpdateInitialGain = true;\r\n}\r\n}\r\n} else {\r\nif (priv->TryDownCountLowData > 0)\r\npriv->TryDownCountLowData--;\r\n}\r\nif (priv->FailTxRateCount >= 0x15 ||\r\n(!bTryUp && !bTryDown && priv->TryDownCountLowData == 0 && priv->TryupingCount && priv->FailTxRateCount > 0x6)) {\r\npriv->FailTxRateCount--;\r\n}\r\nOfdmTxPwrIdx = priv->chtxpwr_ofdm[priv->ieee80211->current_network.channel];\r\nCckTxPwrIdx = priv->chtxpwr[priv->ieee80211->current_network.channel];\r\nif ((priv->CurrentOperaRate < 96) && (priv->CurrentOperaRate > 22)) {\r\nu1bCck = read_nic_byte(dev, CCK_TXAGC);\r\nu1bOfdm = read_nic_byte(dev, OFDM_TXAGC);\r\nif (u1bCck == CckTxPwrIdx) {\r\nif (u1bOfdm != (OfdmTxPwrIdx + 2)) {\r\npriv->bEnhanceTxPwr = true;\r\nu1bOfdm = ((u1bOfdm + 2) > 35) ? 35: (u1bOfdm + 2);\r\nwrite_nic_byte(dev, OFDM_TXAGC, u1bOfdm);\r\n}\r\n} else if (u1bCck < CckTxPwrIdx) {\r\nif (!priv->bEnhanceTxPwr) {\r\npriv->bEnhanceTxPwr = true;\r\nu1bOfdm = ((u1bOfdm + 2) > 35) ? 35: (u1bOfdm + 2);\r\nwrite_nic_byte(dev, OFDM_TXAGC, u1bOfdm);\r\n}\r\n}\r\n} else if (priv->bEnhanceTxPwr) {\r\nu1bCck = read_nic_byte(dev, CCK_TXAGC);\r\nu1bOfdm = read_nic_byte(dev, OFDM_TXAGC);\r\nif (u1bCck == CckTxPwrIdx) {\r\npriv->bEnhanceTxPwr = false;\r\nwrite_nic_byte(dev, OFDM_TXAGC, OfdmTxPwrIdx);\r\n}\r\nelse if (u1bCck < CckTxPwrIdx) {\r\npriv->bEnhanceTxPwr = false;\r\nu1bOfdm = ((u1bOfdm - 2) > 0) ? (u1bOfdm - 2): 0;\r\nwrite_nic_byte(dev, OFDM_TXAGC, u1bOfdm);\r\n}\r\n}\r\nSetInitialGain:\r\nif (bUpdateInitialGain) {\r\nif (MgntIsCckRate(priv->CurrentOperaRate)) {\r\nif (priv->InitialGain > priv->RegBModeGainStage) {\r\npriv->InitialGainBackUp = priv->InitialGain;\r\nif (CurrSignalStrength < -85)\r\npriv->InitialGain = priv->RegBModeGainStage;\r\nelse if (priv->InitialGain > priv->RegBModeGainStage + 1)\r\npriv->InitialGain -= 2;\r\nelse\r\npriv->InitialGain--;\r\nprintk("StaRateAdaptive87SE(): update init_gain to index %d for date rate %d\n",priv->InitialGain, priv->CurrentOperaRate);\r\nUpdateInitialGain(dev);\r\n}\r\n} else {\r\nif (priv->InitialGain < 4) {\r\npriv->InitialGainBackUp = priv->InitialGain;\r\npriv->InitialGain++;\r\nprintk("StaRateAdaptive87SE(): update init_gain to index %d for date rate %d\n",priv->InitialGain, priv->CurrentOperaRate);\r\nUpdateInitialGain(dev);\r\n}\r\n}\r\n}\r\npriv->LastRetryRate = CurrRetryRate;\r\npriv->LastTxThroughput = TxThroughput;\r\npriv->ieee80211->rate = priv->CurrentOperaRate * 5;\r\n}\r\nvoid rtl8180_rate_adapter(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, rate_adapter_wq);\r\nstruct net_device *dev = ieee->dev;\r\nStaRateAdaptive87SE(dev);\r\n}\r\nvoid timer_rate_adaptive(unsigned long data)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv((struct net_device *)data);\r\nif (!priv->up) {\r\nreturn;\r\n}\r\nif ((priv->ieee80211->iw_mode != IW_MODE_MASTER)\r\n&& (priv->ieee80211->state == IEEE80211_LINKED) &&\r\n(priv->ForcedDataRate == 0)) {\r\nqueue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->rate_adapter_wq);\r\n}\r\npriv->rateadapter_timer.expires = jiffies + MSECS(priv->RateAdaptivePeriod);\r\nadd_timer(&priv->rateadapter_timer);\r\n}\r\nvoid SwAntennaDiversityRxOk8185(struct net_device *dev, u8 SignalStrength)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\npriv->AdRxOkCnt++;\r\nif (priv->AdRxSignalStrength != -1) {\r\npriv->AdRxSignalStrength = ((priv->AdRxSignalStrength * 7) + (SignalStrength * 3)) / 10;\r\n} else {\r\npriv->AdRxSignalStrength = SignalStrength;\r\n}\r\nif (priv->LastRxPktAntenna)\r\npriv->AdMainAntennaRxOkCnt++;\r\nelse\r\npriv->AdAuxAntennaRxOkCnt++;\r\n}\r\nbool SetAntenna8185(struct net_device *dev, u8 u1bAntennaIndex)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nbool bAntennaSwitched = false;\r\nswitch (u1bAntennaIndex) {\r\ncase 0:\r\nwrite_nic_byte(dev, ANTSEL, 0x03);\r\nwrite_phy_cck(dev, 0x11, 0x9b);\r\nwrite_phy_ofdm(dev, 0x0d, 0x5c);\r\nbAntennaSwitched = true;\r\nbreak;\r\ncase 1:\r\nwrite_nic_byte(dev, ANTSEL, 0x00);\r\nwrite_phy_cck(dev, 0x11, 0xbb);\r\nwrite_phy_ofdm(dev, 0x0d, 0x54);\r\nbAntennaSwitched = true;\r\nbreak;\r\ndefault:\r\nprintk("SetAntenna8185: unknown u1bAntennaIndex(%d)\n", u1bAntennaIndex);\r\nbreak;\r\n}\r\nif(bAntennaSwitched)\r\npriv->CurrAntennaIndex = u1bAntennaIndex;\r\nreturn bAntennaSwitched;\r\n}\r\nbool SwitchAntenna(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nbool bResult;\r\nif (priv->CurrAntennaIndex == 0) {\r\nbResult = SetAntenna8185(dev, 1);\r\n} else {\r\nbResult = SetAntenna8185(dev, 0);\r\n}\r\nreturn bResult;\r\n}\r\nvoid SwAntennaDiversity(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nbool bSwCheckSS = false;\r\nif (bSwCheckSS) {\r\npriv->AdTickCount++;\r\nprintk("(1) AdTickCount: %d, AdCheckPeriod: %d\n",\r\npriv->AdTickCount, priv->AdCheckPeriod);\r\nprintk("(2) AdRxSignalStrength: %ld, AdRxSsThreshold: %ld\n",\r\npriv->AdRxSignalStrength, priv->AdRxSsThreshold);\r\n}\r\nif (priv->ieee80211->state != IEEE80211_LINKED) {\r\npriv->bAdSwitchedChecking = false;\r\nSwitchAntenna(dev);\r\n} else if (priv->AdRxOkCnt == 0) {\r\npriv->bAdSwitchedChecking = false;\r\nSwitchAntenna(dev);\r\n} else if (priv->bAdSwitchedChecking == true) {\r\npriv->bAdSwitchedChecking = false;\r\npriv->AdRxSsThreshold = (priv->AdRxSignalStrength + priv->AdRxSsBeforeSwitched) / 2;\r\npriv->AdRxSsThreshold = (priv->AdRxSsThreshold > priv->AdMaxRxSsThreshold) ?\r\npriv->AdMaxRxSsThreshold: priv->AdRxSsThreshold;\r\nif(priv->AdRxSignalStrength < priv->AdRxSsBeforeSwitched) {\r\npriv->AdCheckPeriod *= 2;\r\nif (priv->AdCheckPeriod > priv->AdMaxCheckPeriod)\r\npriv->AdCheckPeriod = priv->AdMaxCheckPeriod;\r\nSwitchAntenna(dev);\r\n} else {\r\npriv->AdCheckPeriod = priv->AdMinCheckPeriod;\r\n}\r\n}\r\nelse {\r\npriv->AdTickCount = 0;\r\nif ((priv->AdMainAntennaRxOkCnt < priv->AdAuxAntennaRxOkCnt)\r\n&& (priv->CurrAntennaIndex == 0)) {\r\nSwitchAntenna(dev);\r\npriv->bHWAdSwitched = true;\r\n} else if ((priv->AdAuxAntennaRxOkCnt < priv->AdMainAntennaRxOkCnt)\r\n&& (priv->CurrAntennaIndex == 1)) {\r\nSwitchAntenna(dev);\r\npriv->bHWAdSwitched = true;\r\n} else {\r\npriv->bHWAdSwitched = false;\r\n}\r\nif ((!priv->bHWAdSwitched) && (bSwCheckSS)) {\r\nif (priv->AdRxSignalStrength < priv->AdRxSsThreshold) {\r\npriv->AdRxSsBeforeSwitched = priv->AdRxSignalStrength;\r\npriv->bAdSwitchedChecking = true;\r\nSwitchAntenna(dev);\r\n} else {\r\npriv->bAdSwitchedChecking = false;\r\nif ((priv->AdRxSignalStrength > (priv->AdRxSsThreshold + 10)) &&\r\npriv->AdRxSsThreshold <= priv->AdMaxRxSsThreshold) {\r\npriv->AdRxSsThreshold = (priv->AdRxSsThreshold + priv->AdRxSignalStrength) / 2;\r\npriv->AdRxSsThreshold = (priv->AdRxSsThreshold > priv->AdMaxRxSsThreshold) ?\r\npriv->AdMaxRxSsThreshold: priv->AdRxSsThreshold;\r\n}\r\nif (priv->AdCheckPeriod > priv->AdMinCheckPeriod)\r\npriv->AdCheckPeriod /= 2;\r\n}\r\n}\r\n}\r\npriv->AdRxOkCnt = 0;\r\npriv->AdMainAntennaRxOkCnt = 0;\r\npriv->AdAuxAntennaRxOkCnt = 0;\r\n}\r\nbool CheckTxPwrTracking(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nif (!priv->bTxPowerTrack)\r\nreturn false;\r\nif (priv->bToUpdateTxPwr)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid SwAntennaDiversityTimerCallback(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nRT_RF_POWER_STATE rtState;\r\nrtState = priv->eRFPowerState;\r\ndo {\r\nif (rtState == eRfOff) {\r\nbreak;\r\n} else if (rtState == eRfSleep) {\r\nbreak;\r\n}\r\nSwAntennaDiversity(dev);\r\n} while (false);\r\nif (priv->up) {\r\npriv->SwAntennaDiversityTimer.expires = jiffies + MSECS(ANTENNA_DIVERSITY_TIMER_PERIOD);\r\nadd_timer(&priv->SwAntennaDiversityTimer);\r\n}\r\n}
