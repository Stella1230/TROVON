static int is_wakeup(enum android_alarm_type type)\r\n{\r\nreturn (type == ANDROID_ALARM_RTC_WAKEUP ||\r\ntype == ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);\r\n}\r\nstatic void devalarm_start(struct devalarm *alrm, ktime_t exp)\r\n{\r\nif (is_wakeup(alrm->type))\r\nalarm_start(&alrm->u.alrm, exp);\r\nelse\r\nhrtimer_start(&alrm->u.hrt, exp, HRTIMER_MODE_ABS);\r\n}\r\nstatic int devalarm_try_to_cancel(struct devalarm *alrm)\r\n{\r\nif (is_wakeup(alrm->type))\r\nreturn alarm_try_to_cancel(&alrm->u.alrm);\r\nreturn hrtimer_try_to_cancel(&alrm->u.hrt);\r\n}\r\nstatic void devalarm_cancel(struct devalarm *alrm)\r\n{\r\nif (is_wakeup(alrm->type))\r\nalarm_cancel(&alrm->u.alrm);\r\nelse\r\nhrtimer_cancel(&alrm->u.hrt);\r\n}\r\nstatic void alarm_clear(enum android_alarm_type alarm_type)\r\n{\r\nuint32_t alarm_type_mask = 1U << alarm_type;\r\nunsigned long flags;\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nalarm_dbg(IO, "alarm %d clear\n", alarm_type);\r\ndevalarm_try_to_cancel(&alarms[alarm_type]);\r\nif (alarm_pending) {\r\nalarm_pending &= ~alarm_type_mask;\r\nif (!alarm_pending && !wait_pending)\r\n__pm_relax(&alarm_wake_lock);\r\n}\r\nalarm_enabled &= ~alarm_type_mask;\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\n}\r\nstatic void alarm_set(enum android_alarm_type alarm_type,\r\nstruct timespec *ts)\r\n{\r\nuint32_t alarm_type_mask = 1U << alarm_type;\r\nunsigned long flags;\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nalarm_dbg(IO, "alarm %d set %ld.%09ld\n",\r\nalarm_type, ts->tv_sec, ts->tv_nsec);\r\nalarm_enabled |= alarm_type_mask;\r\ndevalarm_start(&alarms[alarm_type], timespec_to_ktime(*ts));\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\n}\r\nstatic int alarm_wait(void)\r\n{\r\nunsigned long flags;\r\nint rv = 0;\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nalarm_dbg(IO, "alarm wait\n");\r\nif (!alarm_pending && wait_pending) {\r\n__pm_relax(&alarm_wake_lock);\r\nwait_pending = 0;\r\n}\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\nrv = wait_event_interruptible(alarm_wait_queue, alarm_pending);\r\nif (rv)\r\nreturn rv;\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nrv = alarm_pending;\r\nwait_pending = 1;\r\nalarm_pending = 0;\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\nreturn rv;\r\n}\r\nstatic int alarm_set_rtc(struct timespec *ts)\r\n{\r\nstruct rtc_time new_rtc_tm;\r\nstruct rtc_device *rtc_dev;\r\nunsigned long flags;\r\nint rv = 0;\r\nrtc_time_to_tm(ts->tv_sec, &new_rtc_tm);\r\nrtc_dev = alarmtimer_get_rtcdev();\r\nrv = do_settimeofday(ts);\r\nif (rv < 0)\r\nreturn rv;\r\nif (rtc_dev)\r\nrv = rtc_set_time(rtc_dev, &new_rtc_tm);\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nalarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;\r\nwake_up(&alarm_wait_queue);\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\nreturn rv;\r\n}\r\nstatic int alarm_get_time(enum android_alarm_type alarm_type,\r\nstruct timespec *ts)\r\n{\r\nint rv = 0;\r\nswitch (alarm_type) {\r\ncase ANDROID_ALARM_RTC_WAKEUP:\r\ncase ANDROID_ALARM_RTC:\r\ngetnstimeofday(ts);\r\nbreak;\r\ncase ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP:\r\ncase ANDROID_ALARM_ELAPSED_REALTIME:\r\nget_monotonic_boottime(ts);\r\nbreak;\r\ncase ANDROID_ALARM_SYSTEMTIME:\r\nktime_get_ts(ts);\r\nbreak;\r\ndefault:\r\nrv = -EINVAL;\r\n}\r\nreturn rv;\r\n}\r\nstatic long alarm_do_ioctl(struct file *file, unsigned int cmd,\r\nstruct timespec *ts)\r\n{\r\nint rv = 0;\r\nunsigned long flags;\r\nenum android_alarm_type alarm_type = ANDROID_ALARM_IOCTL_TO_TYPE(cmd);\r\nif (alarm_type >= ANDROID_ALARM_TYPE_COUNT)\r\nreturn -EINVAL;\r\nif (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_GET_TIME(0)) {\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY)\r\nreturn -EPERM;\r\nif (file->private_data == NULL &&\r\ncmd != ANDROID_ALARM_SET_RTC) {\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nif (alarm_opened) {\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\nreturn -EBUSY;\r\n}\r\nalarm_opened = 1;\r\nfile->private_data = (void *)1;\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\n}\r\n}\r\nswitch (ANDROID_ALARM_BASE_CMD(cmd)) {\r\ncase ANDROID_ALARM_CLEAR(0):\r\nalarm_clear(alarm_type);\r\nbreak;\r\ncase ANDROID_ALARM_SET(0):\r\nalarm_set(alarm_type, ts);\r\nbreak;\r\ncase ANDROID_ALARM_SET_AND_WAIT(0):\r\nalarm_set(alarm_type, ts);\r\ncase ANDROID_ALARM_WAIT:\r\nrv = alarm_wait();\r\nbreak;\r\ncase ANDROID_ALARM_SET_RTC:\r\nrv = alarm_set_rtc(ts);\r\nbreak;\r\ncase ANDROID_ALARM_GET_TIME(0):\r\nrv = alarm_get_time(alarm_type, ts);\r\nbreak;\r\ndefault:\r\nrv = -EINVAL;\r\n}\r\nreturn rv;\r\n}\r\nstatic long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct timespec ts;\r\nint rv;\r\nswitch (ANDROID_ALARM_BASE_CMD(cmd)) {\r\ncase ANDROID_ALARM_SET_AND_WAIT(0):\r\ncase ANDROID_ALARM_SET(0):\r\ncase ANDROID_ALARM_SET_RTC:\r\nif (copy_from_user(&ts, (void __user *)arg, sizeof(ts)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\nrv = alarm_do_ioctl(file, cmd, &ts);\r\nif (rv)\r\nreturn rv;\r\nswitch (ANDROID_ALARM_BASE_CMD(cmd)) {\r\ncase ANDROID_ALARM_GET_TIME(0):\r\nif (copy_to_user((void __user *)arg, &ts, sizeof(ts)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long alarm_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct timespec ts;\r\nint rv;\r\nswitch (ANDROID_ALARM_BASE_CMD(cmd)) {\r\ncase ANDROID_ALARM_SET_AND_WAIT_COMPAT(0):\r\ncase ANDROID_ALARM_SET_COMPAT(0):\r\ncase ANDROID_ALARM_SET_RTC_COMPAT:\r\nif (compat_get_timespec(&ts, (void __user *)arg))\r\nreturn -EFAULT;\r\ncase ANDROID_ALARM_GET_TIME_COMPAT(0):\r\ncmd = ANDROID_ALARM_COMPAT_TO_NORM(cmd);\r\nbreak;\r\n}\r\nrv = alarm_do_ioctl(file, cmd, &ts);\r\nif (rv)\r\nreturn rv;\r\nswitch (ANDROID_ALARM_BASE_CMD(cmd)) {\r\ncase ANDROID_ALARM_GET_TIME(0):\r\nif (compat_put_timespec(&ts, (void __user *)arg))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alarm_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int alarm_release(struct inode *inode, struct file *file)\r\n{\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nif (file->private_data) {\r\nfor (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {\r\nuint32_t alarm_type_mask = 1U << i;\r\nif (alarm_enabled & alarm_type_mask) {\r\nalarm_dbg(INFO,\r\n"%s: clear alarm, pending %d\n",\r\n__func__,\r\n!!(alarm_pending & alarm_type_mask));\r\nalarm_enabled &= ~alarm_type_mask;\r\n}\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\ndevalarm_cancel(&alarms[i]);\r\nspin_lock_irqsave(&alarm_slock, flags);\r\n}\r\nif (alarm_pending | wait_pending) {\r\nif (alarm_pending)\r\nalarm_dbg(INFO, "%s: clear pending alarms %x\n",\r\n__func__, alarm_pending);\r\n__pm_relax(&alarm_wake_lock);\r\nwait_pending = 0;\r\nalarm_pending = 0;\r\n}\r\nalarm_opened = 0;\r\n}\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\nreturn 0;\r\n}\r\nstatic void devalarm_triggered(struct devalarm *alarm)\r\n{\r\nunsigned long flags;\r\nuint32_t alarm_type_mask = 1U << alarm->type;\r\nalarm_dbg(INT, "%s: type %d\n", __func__, alarm->type);\r\nspin_lock_irqsave(&alarm_slock, flags);\r\nif (alarm_enabled & alarm_type_mask) {\r\n__pm_wakeup_event(&alarm_wake_lock, 5000);\r\nalarm_enabled &= ~alarm_type_mask;\r\nalarm_pending |= alarm_type_mask;\r\nwake_up(&alarm_wait_queue);\r\n}\r\nspin_unlock_irqrestore(&alarm_slock, flags);\r\n}\r\nstatic enum hrtimer_restart devalarm_hrthandler(struct hrtimer *hrt)\r\n{\r\nstruct devalarm *devalrm = container_of(hrt, struct devalarm, u.hrt);\r\ndevalarm_triggered(devalrm);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic enum alarmtimer_restart devalarm_alarmhandler(struct alarm *alrm,\r\nktime_t now)\r\n{\r\nstruct devalarm *devalrm = container_of(alrm, struct devalarm, u.alrm);\r\ndevalarm_triggered(devalrm);\r\nreturn ALARMTIMER_NORESTART;\r\n}\r\nstatic int __init alarm_dev_init(void)\r\n{\r\nint err;\r\nint i;\r\nerr = misc_register(&alarm_device);\r\nif (err)\r\nreturn err;\r\nalarm_init(&alarms[ANDROID_ALARM_RTC_WAKEUP].u.alrm,\r\nALARM_REALTIME, devalarm_alarmhandler);\r\nhrtimer_init(&alarms[ANDROID_ALARM_RTC].u.hrt,\r\nCLOCK_REALTIME, HRTIMER_MODE_ABS);\r\nalarm_init(&alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP].u.alrm,\r\nALARM_BOOTTIME, devalarm_alarmhandler);\r\nhrtimer_init(&alarms[ANDROID_ALARM_ELAPSED_REALTIME].u.hrt,\r\nCLOCK_BOOTTIME, HRTIMER_MODE_ABS);\r\nhrtimer_init(&alarms[ANDROID_ALARM_SYSTEMTIME].u.hrt,\r\nCLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nfor (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {\r\nalarms[i].type = i;\r\nif (!is_wakeup(i))\r\nalarms[i].u.hrt.function = devalarm_hrthandler;\r\n}\r\nwakeup_source_init(&alarm_wake_lock, "alarm");\r\nreturn 0;\r\n}\r\nstatic void __exit alarm_dev_exit(void)\r\n{\r\nmisc_deregister(&alarm_device);\r\nwakeup_source_trash(&alarm_wake_lock);\r\n}
