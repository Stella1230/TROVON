static void lcdtg_ssp_i2c_send(struct corgi_lcd *lcd, uint8_t data)\r\n{\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS, data);\r\nudelay(10);\r\n}\r\nstatic void lcdtg_i2c_send_bit(struct corgi_lcd *lcd, uint8_t data)\r\n{\r\nlcdtg_ssp_i2c_send(lcd, data);\r\nlcdtg_ssp_i2c_send(lcd, data | POWER0_COM_DCLK);\r\nlcdtg_ssp_i2c_send(lcd, data);\r\n}\r\nstatic void lcdtg_i2c_send_start(struct corgi_lcd *lcd, uint8_t base)\r\n{\r\nlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK | POWER0_COM_DOUT);\r\nlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK);\r\nlcdtg_ssp_i2c_send(lcd, base);\r\n}\r\nstatic void lcdtg_i2c_send_stop(struct corgi_lcd *lcd, uint8_t base)\r\n{\r\nlcdtg_ssp_i2c_send(lcd, base);\r\nlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK);\r\nlcdtg_ssp_i2c_send(lcd, base | POWER0_COM_DCLK | POWER0_COM_DOUT);\r\n}\r\nstatic void lcdtg_i2c_send_byte(struct corgi_lcd *lcd,\r\nuint8_t base, uint8_t data)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (data & 0x80)\r\nlcdtg_i2c_send_bit(lcd, base | POWER0_COM_DOUT);\r\nelse\r\nlcdtg_i2c_send_bit(lcd, base);\r\ndata <<= 1;\r\n}\r\n}\r\nstatic void lcdtg_i2c_wait_ack(struct corgi_lcd *lcd, uint8_t base)\r\n{\r\nlcdtg_i2c_send_bit(lcd, base);\r\n}\r\nstatic void lcdtg_set_common_voltage(struct corgi_lcd *lcd,\r\nuint8_t base_data, uint8_t data)\r\n{\r\nlcdtg_i2c_send_start(lcd, base_data);\r\nlcdtg_i2c_send_byte(lcd, base_data, 0x9c);\r\nlcdtg_i2c_wait_ack(lcd, base_data);\r\nlcdtg_i2c_send_byte(lcd, base_data, 0x00);\r\nlcdtg_i2c_wait_ack(lcd, base_data);\r\nlcdtg_i2c_send_byte(lcd, base_data, data);\r\nlcdtg_i2c_wait_ack(lcd, base_data);\r\nlcdtg_i2c_send_stop(lcd, base_data);\r\n}\r\nstatic int corgi_ssp_lcdtg_send(struct corgi_lcd *lcd, int adrs, uint8_t data)\r\n{\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 1,\r\n.cs_change = 1,\r\n.tx_buf = lcd->buf,\r\n};\r\nlcd->buf[0] = ((adrs & 0x07) << 5) | (data & 0x1f);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nreturn spi_sync(lcd->spi_dev, &msg);\r\n}\r\nstatic void lcdtg_set_phadadj(struct corgi_lcd *lcd, int mode)\r\n{\r\nint adj;\r\nswitch (mode) {\r\ncase CORGI_LCD_MODE_VGA:\r\nadj = sharpsl_param.phadadj;\r\nadj = (adj < 0) ? PHACTRL_PHASE_MANUAL :\r\nPHACTRL_PHASE_MANUAL | ((adj & 0xf) << 1);\r\nbreak;\r\ncase CORGI_LCD_MODE_QVGA:\r\ndefault:\r\nadj = (DEFAULT_PHAD_QVGA << 1) | PHACTRL_PHASE_MANUAL;\r\nbreak;\r\n}\r\ncorgi_ssp_lcdtg_send(lcd, PHACTRL_ADRS, adj);\r\n}\r\nstatic void corgi_lcd_power_on(struct corgi_lcd *lcd)\r\n{\r\nint comadj;\r\ncorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS,\r\nPICTRL_POWER_DOWN | PICTRL_INIOFF |\r\nPICTRL_INIT_STATE | PICTRL_COM_SIGNAL_OFF |\r\nPICTRL_DAC_SIGNAL_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_OFF |\r\nPOWER0_COM_OFF | POWER0_VCC5_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_ON);\r\nmdelay(3);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_ON |\r\nPOWER0_COM_OFF | POWER0_VCC5_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS,\r\nPICTRL_INIT_STATE | PICTRL_COM_SIGNAL_OFF);\r\ncomadj = sharpsl_param.comadj;\r\nif (comadj < 0)\r\ncomadj = DEFAULT_COMADJ;\r\nlcdtg_set_common_voltage(lcd, POWER0_DAC_ON | POWER0_COM_OFF |\r\nPOWER0_VCC5_OFF, comadj);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_ON |\r\nPOWER0_COM_OFF | POWER0_VCC5_ON);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_OFF | POWER1_GVSS_ON | POWER1_VDD_ON);\r\nmdelay(2);\r\ncorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS, PICTRL_INIT_STATE);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_COM_DCLK | POWER0_COM_DOUT | POWER0_DAC_ON |\r\nPOWER0_COM_ON | POWER0_VCC5_ON);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_ON | POWER1_GVSS_ON | POWER1_VDD_ON);\r\ncorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS, 0);\r\nlcdtg_set_phadadj(lcd, lcd->mode);\r\ncorgi_ssp_lcdtg_send(lcd, POLCTRL_ADRS,\r\nPOLCTRL_SYNC_POL_RISE | POLCTRL_EN_POL_RISE |\r\nPOLCTRL_DATA_POL_RISE | POLCTRL_SYNC_ACT_L |\r\nPOLCTRL_EN_ACT_H);\r\nudelay(1000);\r\nswitch (lcd->mode) {\r\ncase CORGI_LCD_MODE_VGA:\r\ncorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_VGA);\r\nbreak;\r\ncase CORGI_LCD_MODE_QVGA:\r\ndefault:\r\ncorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_QVGA);\r\nbreak;\r\n}\r\n}\r\nstatic void corgi_lcd_power_off(struct corgi_lcd *lcd)\r\n{\r\nmsleep(34);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_OFF | POWER1_GVSS_ON | POWER1_VDD_ON);\r\ncorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS, PICTRL_COM_SIGNAL_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_DAC_ON | POWER0_COM_OFF | POWER0_VCC5_ON);\r\nlcdtg_set_common_voltage(lcd, POWER0_DAC_ON | POWER0_COM_OFF |\r\nPOWER0_VCC5_ON, 0);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_ON);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_DAC_ON | POWER0_COM_OFF | POWER0_VCC5_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, PICTRL_ADRS,\r\nPICTRL_INIOFF | PICTRL_DAC_SIGNAL_OFF |\r\nPICTRL_POWER_DOWN | PICTRL_COM_SIGNAL_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG0_ADRS,\r\nPOWER0_DAC_OFF | POWER0_COM_OFF | POWER0_VCC5_OFF);\r\ncorgi_ssp_lcdtg_send(lcd, POWERREG1_ADRS,\r\nPOWER1_VW_OFF | POWER1_GVSS_OFF | POWER1_VDD_OFF);\r\n}\r\nstatic int corgi_lcd_set_mode(struct lcd_device *ld, struct fb_videomode *m)\r\n{\r\nstruct corgi_lcd *lcd = lcd_get_data(ld);\r\nint mode = CORGI_LCD_MODE_QVGA;\r\nif (m->xres == 640 || m->xres == 480)\r\nmode = CORGI_LCD_MODE_VGA;\r\nif (lcd->mode == mode)\r\nreturn 0;\r\nlcdtg_set_phadadj(lcd, mode);\r\nswitch (mode) {\r\ncase CORGI_LCD_MODE_VGA:\r\ncorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_VGA);\r\nbreak;\r\ncase CORGI_LCD_MODE_QVGA:\r\ndefault:\r\ncorgi_ssp_lcdtg_send(lcd, RESCTL_ADRS, RESCTL_QVGA);\r\nbreak;\r\n}\r\nlcd->mode = mode;\r\nreturn 0;\r\n}\r\nstatic int corgi_lcd_set_power(struct lcd_device *ld, int power)\r\n{\r\nstruct corgi_lcd *lcd = lcd_get_data(ld);\r\nif (POWER_IS_ON(power) && !POWER_IS_ON(lcd->power))\r\ncorgi_lcd_power_on(lcd);\r\nif (!POWER_IS_ON(power) && POWER_IS_ON(lcd->power))\r\ncorgi_lcd_power_off(lcd);\r\nlcd->power = power;\r\nreturn 0;\r\n}\r\nstatic int corgi_lcd_get_power(struct lcd_device *ld)\r\n{\r\nstruct corgi_lcd *lcd = lcd_get_data(ld);\r\nreturn lcd->power;\r\n}\r\nstatic int corgi_bl_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct corgi_lcd *lcd = bl_get_data(bd);\r\nreturn lcd->intensity;\r\n}\r\nstatic int corgi_bl_set_intensity(struct corgi_lcd *lcd, int intensity)\r\n{\r\nint cont;\r\nif (intensity > 0x10)\r\nintensity += 0x10;\r\ncorgi_ssp_lcdtg_send(lcd, DUTYCTRL_ADRS, intensity);\r\ncont = !!(intensity & 0x20) ^ lcd->gpio_backlight_cont_inverted;\r\nif (gpio_is_valid(lcd->gpio_backlight_cont))\r\ngpio_set_value_cansleep(lcd->gpio_backlight_cont, cont);\r\nif (gpio_is_valid(lcd->gpio_backlight_on))\r\ngpio_set_value_cansleep(lcd->gpio_backlight_on, intensity);\r\nif (lcd->kick_battery)\r\nlcd->kick_battery();\r\nlcd->intensity = intensity;\r\nreturn 0;\r\n}\r\nstatic int corgi_bl_update_status(struct backlight_device *bd)\r\n{\r\nstruct corgi_lcd *lcd = bl_get_data(bd);\r\nint intensity = bd->props.brightness;\r\nif (bd->props.power != FB_BLANK_UNBLANK)\r\nintensity = 0;\r\nif (bd->props.fb_blank != FB_BLANK_UNBLANK)\r\nintensity = 0;\r\nif (corgibl_flags & CORGIBL_SUSPENDED)\r\nintensity = 0;\r\nif ((corgibl_flags & CORGIBL_BATTLOW) && intensity > lcd->limit_mask)\r\nintensity = lcd->limit_mask;\r\nreturn corgi_bl_set_intensity(lcd, intensity);\r\n}\r\nvoid corgi_lcd_limit_intensity(int limit)\r\n{\r\nif (limit)\r\ncorgibl_flags |= CORGIBL_BATTLOW;\r\nelse\r\ncorgibl_flags &= ~CORGIBL_BATTLOW;\r\nbacklight_update_status(the_corgi_lcd->bl_dev);\r\n}\r\nstatic int corgi_lcd_suspend(struct device *dev)\r\n{\r\nstruct corgi_lcd *lcd = dev_get_drvdata(dev);\r\ncorgibl_flags |= CORGIBL_SUSPENDED;\r\ncorgi_bl_set_intensity(lcd, 0);\r\ncorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_POWERDOWN);\r\nreturn 0;\r\n}\r\nstatic int corgi_lcd_resume(struct device *dev)\r\n{\r\nstruct corgi_lcd *lcd = dev_get_drvdata(dev);\r\ncorgibl_flags &= ~CORGIBL_SUSPENDED;\r\ncorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_UNBLANK);\r\nbacklight_update_status(lcd->bl_dev);\r\nreturn 0;\r\n}\r\nstatic int setup_gpio_backlight(struct corgi_lcd *lcd,\r\nstruct corgi_lcd_platform_data *pdata)\r\n{\r\nstruct spi_device *spi = lcd->spi_dev;\r\nint err;\r\nlcd->gpio_backlight_on = -1;\r\nlcd->gpio_backlight_cont = -1;\r\nif (gpio_is_valid(pdata->gpio_backlight_on)) {\r\nerr = devm_gpio_request(&spi->dev, pdata->gpio_backlight_on,\r\n"BL_ON");\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"failed to request GPIO%d for backlight_on\n",\r\npdata->gpio_backlight_on);\r\nreturn err;\r\n}\r\nlcd->gpio_backlight_on = pdata->gpio_backlight_on;\r\ngpio_direction_output(lcd->gpio_backlight_on, 0);\r\n}\r\nif (gpio_is_valid(pdata->gpio_backlight_cont)) {\r\nerr = devm_gpio_request(&spi->dev, pdata->gpio_backlight_cont,\r\n"BL_CONT");\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"failed to request GPIO%d for backlight_cont\n",\r\npdata->gpio_backlight_cont);\r\nreturn err;\r\n}\r\nlcd->gpio_backlight_cont = pdata->gpio_backlight_cont;\r\nif (gpio_is_valid(lcd->gpio_backlight_on)) {\r\nlcd->gpio_backlight_cont_inverted = 1;\r\ngpio_direction_output(lcd->gpio_backlight_cont, 1);\r\n} else {\r\nlcd->gpio_backlight_cont_inverted = 0;\r\ngpio_direction_output(lcd->gpio_backlight_cont, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int corgi_lcd_probe(struct spi_device *spi)\r\n{\r\nstruct backlight_properties props;\r\nstruct corgi_lcd_platform_data *pdata = spi->dev.platform_data;\r\nstruct corgi_lcd *lcd;\r\nint ret = 0;\r\nif (pdata == NULL) {\r\ndev_err(&spi->dev, "platform data not available\n");\r\nreturn -EINVAL;\r\n}\r\nlcd = devm_kzalloc(&spi->dev, sizeof(struct corgi_lcd), GFP_KERNEL);\r\nif (!lcd) {\r\ndev_err(&spi->dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nlcd->spi_dev = spi;\r\nlcd->lcd_dev = lcd_device_register("corgi_lcd", &spi->dev,\r\nlcd, &corgi_lcd_ops);\r\nif (IS_ERR(lcd->lcd_dev))\r\nreturn PTR_ERR(lcd->lcd_dev);\r\nlcd->power = FB_BLANK_POWERDOWN;\r\nlcd->mode = (pdata) ? pdata->init_mode : CORGI_LCD_MODE_VGA;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = pdata->max_intensity;\r\nlcd->bl_dev = backlight_device_register("corgi_bl", &spi->dev, lcd,\r\n&corgi_bl_ops, &props);\r\nif (IS_ERR(lcd->bl_dev)) {\r\nret = PTR_ERR(lcd->bl_dev);\r\ngoto err_unregister_lcd;\r\n}\r\nlcd->bl_dev->props.brightness = pdata->default_intensity;\r\nlcd->bl_dev->props.power = FB_BLANK_UNBLANK;\r\nret = setup_gpio_backlight(lcd, pdata);\r\nif (ret)\r\ngoto err_unregister_bl;\r\nlcd->kick_battery = pdata->kick_battery;\r\nspi_set_drvdata(spi, lcd);\r\ncorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_UNBLANK);\r\nbacklight_update_status(lcd->bl_dev);\r\nlcd->limit_mask = pdata->limit_mask;\r\nthe_corgi_lcd = lcd;\r\nreturn 0;\r\nerr_unregister_bl:\r\nbacklight_device_unregister(lcd->bl_dev);\r\nerr_unregister_lcd:\r\nlcd_device_unregister(lcd->lcd_dev);\r\nreturn ret;\r\n}\r\nstatic int corgi_lcd_remove(struct spi_device *spi)\r\n{\r\nstruct corgi_lcd *lcd = spi_get_drvdata(spi);\r\nlcd->bl_dev->props.power = FB_BLANK_UNBLANK;\r\nlcd->bl_dev->props.brightness = 0;\r\nbacklight_update_status(lcd->bl_dev);\r\nbacklight_device_unregister(lcd->bl_dev);\r\ncorgi_lcd_set_power(lcd->lcd_dev, FB_BLANK_POWERDOWN);\r\nlcd_device_unregister(lcd->lcd_dev);\r\nreturn 0;\r\n}
