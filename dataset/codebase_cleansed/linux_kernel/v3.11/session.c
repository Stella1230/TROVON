static int perf_session__open(struct perf_session *self, bool force)\r\n{\r\nstruct stat input_stat;\r\nif (!strcmp(self->filename, "-")) {\r\nself->fd_pipe = true;\r\nself->fd = STDIN_FILENO;\r\nif (perf_session__read_header(self, self->fd) < 0)\r\npr_err("incompatible file format (rerun with -v to learn more)");\r\nreturn 0;\r\n}\r\nself->fd = open(self->filename, O_RDONLY);\r\nif (self->fd < 0) {\r\nint err = errno;\r\npr_err("failed to open %s: %s", self->filename, strerror(err));\r\nif (err == ENOENT && !strcmp(self->filename, "perf.data"))\r\npr_err(" (try 'perf record' first)");\r\npr_err("\n");\r\nreturn -errno;\r\n}\r\nif (fstat(self->fd, &input_stat) < 0)\r\ngoto out_close;\r\nif (!force && input_stat.st_uid && (input_stat.st_uid != geteuid())) {\r\npr_err("file %s not owned by current user or root\n",\r\nself->filename);\r\ngoto out_close;\r\n}\r\nif (!input_stat.st_size) {\r\npr_info("zero-sized file (%s), nothing to do!\n",\r\nself->filename);\r\ngoto out_close;\r\n}\r\nif (perf_session__read_header(self, self->fd) < 0) {\r\npr_err("incompatible file format (rerun with -v to learn more)");\r\ngoto out_close;\r\n}\r\nif (!perf_evlist__valid_sample_type(self->evlist)) {\r\npr_err("non matching sample_type");\r\ngoto out_close;\r\n}\r\nif (!perf_evlist__valid_sample_id_all(self->evlist)) {\r\npr_err("non matching sample_id_all");\r\ngoto out_close;\r\n}\r\nself->size = input_stat.st_size;\r\nreturn 0;\r\nout_close:\r\nclose(self->fd);\r\nself->fd = -1;\r\nreturn -1;\r\n}\r\nvoid perf_session__set_id_hdr_size(struct perf_session *session)\r\n{\r\nu16 id_hdr_size = perf_evlist__id_hdr_size(session->evlist);\r\nmachines__set_id_hdr_size(&session->machines, id_hdr_size);\r\n}\r\nint perf_session__create_kernel_maps(struct perf_session *self)\r\n{\r\nint ret = machine__create_kernel_maps(&self->machines.host);\r\nif (ret >= 0)\r\nret = machines__create_guest_kernel_maps(&self->machines);\r\nreturn ret;\r\n}\r\nstatic void perf_session__destroy_kernel_maps(struct perf_session *self)\r\n{\r\nmachines__destroy_kernel_maps(&self->machines);\r\n}\r\nstruct perf_session *perf_session__new(const char *filename, int mode,\r\nbool force, bool repipe,\r\nstruct perf_tool *tool)\r\n{\r\nstruct perf_session *self;\r\nstruct stat st;\r\nsize_t len;\r\nif (!filename || !strlen(filename)) {\r\nif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\r\nfilename = "-";\r\nelse\r\nfilename = "perf.data";\r\n}\r\nlen = strlen(filename);\r\nself = zalloc(sizeof(*self) + len);\r\nif (self == NULL)\r\ngoto out;\r\nmemcpy(self->filename, filename, len);\r\nself->repipe = repipe;\r\nINIT_LIST_HEAD(&self->ordered_samples.samples);\r\nINIT_LIST_HEAD(&self->ordered_samples.sample_cache);\r\nINIT_LIST_HEAD(&self->ordered_samples.to_free);\r\nmachines__init(&self->machines);\r\nif (mode == O_RDONLY) {\r\nif (perf_session__open(self, force) < 0)\r\ngoto out_delete;\r\nperf_session__set_id_hdr_size(self);\r\n} else if (mode == O_WRONLY) {\r\nif (perf_session__create_kernel_maps(self) < 0)\r\ngoto out_delete;\r\n}\r\nif (tool && tool->ordering_requires_timestamps &&\r\ntool->ordered_samples && !perf_evlist__sample_id_all(self->evlist)) {\r\ndump_printf("WARNING: No sample_id_all support, falling back to unordered processing\n");\r\ntool->ordered_samples = false;\r\n}\r\nout:\r\nreturn self;\r\nout_delete:\r\nperf_session__delete(self);\r\nreturn NULL;\r\n}\r\nstatic void perf_session__delete_dead_threads(struct perf_session *session)\r\n{\r\nmachine__delete_dead_threads(&session->machines.host);\r\n}\r\nstatic void perf_session__delete_threads(struct perf_session *session)\r\n{\r\nmachine__delete_threads(&session->machines.host);\r\n}\r\nstatic void perf_session_env__delete(struct perf_session_env *env)\r\n{\r\nfree(env->hostname);\r\nfree(env->os_release);\r\nfree(env->version);\r\nfree(env->arch);\r\nfree(env->cpu_desc);\r\nfree(env->cpuid);\r\nfree(env->cmdline);\r\nfree(env->sibling_cores);\r\nfree(env->sibling_threads);\r\nfree(env->numa_nodes);\r\nfree(env->pmu_mappings);\r\n}\r\nvoid perf_session__delete(struct perf_session *self)\r\n{\r\nperf_session__destroy_kernel_maps(self);\r\nperf_session__delete_dead_threads(self);\r\nperf_session__delete_threads(self);\r\nperf_session_env__delete(&self->header.env);\r\nmachines__exit(&self->machines);\r\nclose(self->fd);\r\nfree(self);\r\nvdso__exit();\r\n}\r\nstatic int process_event_synth_tracing_data_stub(union perf_event *event\r\n__maybe_unused,\r\nstruct perf_session *session\r\n__maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_synth_attr_stub(union perf_event *event __maybe_unused,\r\nstruct perf_evlist **pevlist\r\n__maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_sample_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_finished_round_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *perf_session\r\n__maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_type_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic void perf_tool__fill_defaults(struct perf_tool *tool)\r\n{\r\nif (tool->sample == NULL)\r\ntool->sample = process_event_sample_stub;\r\nif (tool->mmap == NULL)\r\ntool->mmap = process_event_stub;\r\nif (tool->comm == NULL)\r\ntool->comm = process_event_stub;\r\nif (tool->fork == NULL)\r\ntool->fork = process_event_stub;\r\nif (tool->exit == NULL)\r\ntool->exit = process_event_stub;\r\nif (tool->lost == NULL)\r\ntool->lost = perf_event__process_lost;\r\nif (tool->read == NULL)\r\ntool->read = process_event_sample_stub;\r\nif (tool->throttle == NULL)\r\ntool->throttle = process_event_stub;\r\nif (tool->unthrottle == NULL)\r\ntool->unthrottle = process_event_stub;\r\nif (tool->attr == NULL)\r\ntool->attr = process_event_synth_attr_stub;\r\nif (tool->event_type == NULL)\r\ntool->event_type = process_event_type_stub;\r\nif (tool->tracing_data == NULL)\r\ntool->tracing_data = process_event_synth_tracing_data_stub;\r\nif (tool->build_id == NULL)\r\ntool->build_id = process_finished_round_stub;\r\nif (tool->finished_round == NULL) {\r\nif (tool->ordered_samples)\r\ntool->finished_round = process_finished_round;\r\nelse\r\ntool->finished_round = process_finished_round_stub;\r\n}\r\n}\r\nvoid mem_bswap_32(void *src, int byte_size)\r\n{\r\nu32 *m = src;\r\nwhile (byte_size > 0) {\r\n*m = bswap_32(*m);\r\nbyte_size -= sizeof(u32);\r\n++m;\r\n}\r\n}\r\nvoid mem_bswap_64(void *src, int byte_size)\r\n{\r\nu64 *m = src;\r\nwhile (byte_size > 0) {\r\n*m = bswap_64(*m);\r\nbyte_size -= sizeof(u64);\r\n++m;\r\n}\r\n}\r\nstatic void swap_sample_id_all(union perf_event *event, void *data)\r\n{\r\nvoid *end = (void *) event + event->header.size;\r\nint size = end - data;\r\nBUG_ON(size % sizeof(u64));\r\nmem_bswap_64(data, size);\r\n}\r\nstatic void perf_event__all64_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nstruct perf_event_header *hdr = &event->header;\r\nmem_bswap_64(hdr + 1, event->header.size - sizeof(*hdr));\r\n}\r\nstatic void perf_event__comm_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->comm.pid = bswap_32(event->comm.pid);\r\nevent->comm.tid = bswap_32(event->comm.tid);\r\nif (sample_id_all) {\r\nvoid *data = &event->comm.comm;\r\ndata += PERF_ALIGN(strlen(data) + 1, sizeof(u64));\r\nswap_sample_id_all(event, data);\r\n}\r\n}\r\nstatic void perf_event__mmap_swap(union perf_event *event,\r\nbool sample_id_all)\r\n{\r\nevent->mmap.pid = bswap_32(event->mmap.pid);\r\nevent->mmap.tid = bswap_32(event->mmap.tid);\r\nevent->mmap.start = bswap_64(event->mmap.start);\r\nevent->mmap.len = bswap_64(event->mmap.len);\r\nevent->mmap.pgoff = bswap_64(event->mmap.pgoff);\r\nif (sample_id_all) {\r\nvoid *data = &event->mmap.filename;\r\ndata += PERF_ALIGN(strlen(data) + 1, sizeof(u64));\r\nswap_sample_id_all(event, data);\r\n}\r\n}\r\nstatic void perf_event__task_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->fork.pid = bswap_32(event->fork.pid);\r\nevent->fork.tid = bswap_32(event->fork.tid);\r\nevent->fork.ppid = bswap_32(event->fork.ppid);\r\nevent->fork.ptid = bswap_32(event->fork.ptid);\r\nevent->fork.time = bswap_64(event->fork.time);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->fork + 1);\r\n}\r\nstatic void perf_event__read_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->read.pid = bswap_32(event->read.pid);\r\nevent->read.tid = bswap_32(event->read.tid);\r\nevent->read.value = bswap_64(event->read.value);\r\nevent->read.time_enabled = bswap_64(event->read.time_enabled);\r\nevent->read.time_running = bswap_64(event->read.time_running);\r\nevent->read.id = bswap_64(event->read.id);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->read + 1);\r\n}\r\nstatic u8 revbyte(u8 b)\r\n{\r\nint rev = (b >> 4) | ((b & 0xf) << 4);\r\nrev = ((rev & 0xcc) >> 2) | ((rev & 0x33) << 2);\r\nrev = ((rev & 0xaa) >> 1) | ((rev & 0x55) << 1);\r\nreturn (u8) rev;\r\n}\r\nstatic void swap_bitfield(u8 *p, unsigned len)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < len; i++) {\r\n*p = revbyte(*p);\r\np++;\r\n}\r\n}\r\nvoid perf_event__attr_swap(struct perf_event_attr *attr)\r\n{\r\nattr->type = bswap_32(attr->type);\r\nattr->size = bswap_32(attr->size);\r\nattr->config = bswap_64(attr->config);\r\nattr->sample_period = bswap_64(attr->sample_period);\r\nattr->sample_type = bswap_64(attr->sample_type);\r\nattr->read_format = bswap_64(attr->read_format);\r\nattr->wakeup_events = bswap_32(attr->wakeup_events);\r\nattr->bp_type = bswap_32(attr->bp_type);\r\nattr->bp_addr = bswap_64(attr->bp_addr);\r\nattr->bp_len = bswap_64(attr->bp_len);\r\nswap_bitfield((u8 *) (&attr->read_format + 1), sizeof(u64));\r\n}\r\nstatic void perf_event__hdr_attr_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nsize_t size;\r\nperf_event__attr_swap(&event->attr.attr);\r\nsize = event->header.size;\r\nsize -= (void *)&event->attr.id - (void *)event;\r\nmem_bswap_64(event->attr.id, size);\r\n}\r\nstatic void perf_event__event_type_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->event_type.event_type.event_id =\r\nbswap_64(event->event_type.event_type.event_id);\r\n}\r\nstatic void perf_event__tracing_data_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->tracing_data.size = bswap_32(event->tracing_data.size);\r\n}\r\nstatic void perf_session_free_sample_buffers(struct perf_session *session)\r\n{\r\nstruct ordered_samples *os = &session->ordered_samples;\r\nwhile (!list_empty(&os->to_free)) {\r\nstruct sample_queue *sq;\r\nsq = list_entry(os->to_free.next, struct sample_queue, list);\r\nlist_del(&sq->list);\r\nfree(sq);\r\n}\r\n}\r\nstatic int flush_sample_queue(struct perf_session *s,\r\nstruct perf_tool *tool)\r\n{\r\nstruct ordered_samples *os = &s->ordered_samples;\r\nstruct list_head *head = &os->samples;\r\nstruct sample_queue *tmp, *iter;\r\nstruct perf_sample sample;\r\nu64 limit = os->next_flush;\r\nu64 last_ts = os->last_sample ? os->last_sample->timestamp : 0ULL;\r\nunsigned idx = 0, progress_next = os->nr_samples / 16;\r\nint ret;\r\nif (!tool->ordered_samples || !limit)\r\nreturn 0;\r\nlist_for_each_entry_safe(iter, tmp, head, list) {\r\nif (iter->timestamp > limit)\r\nbreak;\r\nret = perf_evlist__parse_sample(s->evlist, iter->event, &sample);\r\nif (ret)\r\npr_err("Can't parse sample, err = %d\n", ret);\r\nelse {\r\nret = perf_session_deliver_event(s, iter->event, &sample, tool,\r\niter->file_offset);\r\nif (ret)\r\nreturn ret;\r\n}\r\nos->last_flush = iter->timestamp;\r\nlist_del(&iter->list);\r\nlist_add(&iter->list, &os->sample_cache);\r\nif (++idx >= progress_next) {\r\nprogress_next += os->nr_samples / 16;\r\nui_progress__update(idx, os->nr_samples,\r\n"Processing time ordered events...");\r\n}\r\n}\r\nif (list_empty(head)) {\r\nos->last_sample = NULL;\r\n} else if (last_ts <= limit) {\r\nos->last_sample =\r\nlist_entry(head->prev, struct sample_queue, list);\r\n}\r\nos->nr_samples = 0;\r\nreturn 0;\r\n}\r\nstatic int process_finished_round(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *session)\r\n{\r\nint ret = flush_sample_queue(session, tool);\r\nif (!ret)\r\nsession->ordered_samples.next_flush = session->ordered_samples.max_timestamp;\r\nreturn ret;\r\n}\r\nstatic void __queue_event(struct sample_queue *new, struct perf_session *s)\r\n{\r\nstruct ordered_samples *os = &s->ordered_samples;\r\nstruct sample_queue *sample = os->last_sample;\r\nu64 timestamp = new->timestamp;\r\nstruct list_head *p;\r\n++os->nr_samples;\r\nos->last_sample = new;\r\nif (!sample) {\r\nlist_add(&new->list, &os->samples);\r\nos->max_timestamp = timestamp;\r\nreturn;\r\n}\r\nif (sample->timestamp <= timestamp) {\r\nwhile (sample->timestamp <= timestamp) {\r\np = sample->list.next;\r\nif (p == &os->samples) {\r\nlist_add_tail(&new->list, &os->samples);\r\nos->max_timestamp = timestamp;\r\nreturn;\r\n}\r\nsample = list_entry(p, struct sample_queue, list);\r\n}\r\nlist_add_tail(&new->list, &sample->list);\r\n} else {\r\nwhile (sample->timestamp > timestamp) {\r\np = sample->list.prev;\r\nif (p == &os->samples) {\r\nlist_add(&new->list, &os->samples);\r\nreturn;\r\n}\r\nsample = list_entry(p, struct sample_queue, list);\r\n}\r\nlist_add(&new->list, &sample->list);\r\n}\r\n}\r\nstatic int perf_session_queue_event(struct perf_session *s, union perf_event *event,\r\nstruct perf_sample *sample, u64 file_offset)\r\n{\r\nstruct ordered_samples *os = &s->ordered_samples;\r\nstruct list_head *sc = &os->sample_cache;\r\nu64 timestamp = sample->time;\r\nstruct sample_queue *new;\r\nif (!timestamp || timestamp == ~0ULL)\r\nreturn -ETIME;\r\nif (timestamp < s->ordered_samples.last_flush) {\r\nprintf("Warning: Timestamp below last timeslice flush\n");\r\nreturn -EINVAL;\r\n}\r\nif (!list_empty(sc)) {\r\nnew = list_entry(sc->next, struct sample_queue, list);\r\nlist_del(&new->list);\r\n} else if (os->sample_buffer) {\r\nnew = os->sample_buffer + os->sample_buffer_idx;\r\nif (++os->sample_buffer_idx == MAX_SAMPLE_BUFFER)\r\nos->sample_buffer = NULL;\r\n} else {\r\nos->sample_buffer = malloc(MAX_SAMPLE_BUFFER * sizeof(*new));\r\nif (!os->sample_buffer)\r\nreturn -ENOMEM;\r\nlist_add(&os->sample_buffer->list, &os->to_free);\r\nos->sample_buffer_idx = 2;\r\nnew = os->sample_buffer + 1;\r\n}\r\nnew->timestamp = timestamp;\r\nnew->file_offset = file_offset;\r\nnew->event = event;\r\n__queue_event(new, s);\r\nreturn 0;\r\n}\r\nstatic void callchain__printf(struct perf_sample *sample)\r\n{\r\nunsigned int i;\r\nprintf("... chain: nr:%" PRIu64 "\n", sample->callchain->nr);\r\nfor (i = 0; i < sample->callchain->nr; i++)\r\nprintf("..... %2d: %016" PRIx64 "\n",\r\ni, sample->callchain->ips[i]);\r\n}\r\nstatic void branch_stack__printf(struct perf_sample *sample)\r\n{\r\nuint64_t i;\r\nprintf("... branch stack: nr:%" PRIu64 "\n", sample->branch_stack->nr);\r\nfor (i = 0; i < sample->branch_stack->nr; i++)\r\nprintf("..... %2"PRIu64": %016" PRIx64 " -> %016" PRIx64 "\n",\r\ni, sample->branch_stack->entries[i].from,\r\nsample->branch_stack->entries[i].to);\r\n}\r\nstatic void regs_dump__printf(u64 mask, u64 *regs)\r\n{\r\nunsigned rid, i = 0;\r\nfor_each_set_bit(rid, (unsigned long *) &mask, sizeof(mask) * 8) {\r\nu64 val = regs[i++];\r\nprintf(".... %-5s 0x%" PRIx64 "\n",\r\nperf_reg_name(rid), val);\r\n}\r\n}\r\nstatic void regs_user__printf(struct perf_sample *sample, u64 mask)\r\n{\r\nstruct regs_dump *user_regs = &sample->user_regs;\r\nif (user_regs->regs) {\r\nprintf("... user regs: mask 0x%" PRIx64 "\n", mask);\r\nregs_dump__printf(mask, user_regs->regs);\r\n}\r\n}\r\nstatic void stack_user__printf(struct stack_dump *dump)\r\n{\r\nprintf("... ustack: size %" PRIu64 ", offset 0x%x\n",\r\ndump->size, dump->offset);\r\n}\r\nstatic void perf_session__print_tstamp(struct perf_session *session,\r\nunion perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nu64 sample_type = perf_evlist__sample_type(session->evlist);\r\nif (event->header.type != PERF_RECORD_SAMPLE &&\r\n!perf_evlist__sample_id_all(session->evlist)) {\r\nfputs("-1 -1 ", stdout);\r\nreturn;\r\n}\r\nif ((sample_type & PERF_SAMPLE_CPU))\r\nprintf("%u ", sample->cpu);\r\nif (sample_type & PERF_SAMPLE_TIME)\r\nprintf("%" PRIu64 " ", sample->time);\r\n}\r\nstatic void dump_event(struct perf_session *session, union perf_event *event,\r\nu64 file_offset, struct perf_sample *sample)\r\n{\r\nif (!dump_trace)\r\nreturn;\r\nprintf("\n%#" PRIx64 " [%#x]: event: %d\n",\r\nfile_offset, event->header.size, event->header.type);\r\ntrace_event(event);\r\nif (sample)\r\nperf_session__print_tstamp(session, event, sample);\r\nprintf("%#" PRIx64 " [%#x]: PERF_RECORD_%s", file_offset,\r\nevent->header.size, perf_event__name(event->header.type));\r\n}\r\nstatic void dump_sample(struct perf_evsel *evsel, union perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nu64 sample_type;\r\nif (!dump_trace)\r\nreturn;\r\nprintf("(IP, %d): %d/%d: %#" PRIx64 " period: %" PRIu64 " addr: %#" PRIx64 "\n",\r\nevent->header.misc, sample->pid, sample->tid, sample->ip,\r\nsample->period, sample->addr);\r\nsample_type = evsel->attr.sample_type;\r\nif (sample_type & PERF_SAMPLE_CALLCHAIN)\r\ncallchain__printf(sample);\r\nif (sample_type & PERF_SAMPLE_BRANCH_STACK)\r\nbranch_stack__printf(sample);\r\nif (sample_type & PERF_SAMPLE_REGS_USER)\r\nregs_user__printf(sample, evsel->attr.sample_regs_user);\r\nif (sample_type & PERF_SAMPLE_STACK_USER)\r\nstack_user__printf(&sample->user_stack);\r\nif (sample_type & PERF_SAMPLE_WEIGHT)\r\nprintf("... weight: %" PRIu64 "\n", sample->weight);\r\nif (sample_type & PERF_SAMPLE_DATA_SRC)\r\nprintf(" . data_src: 0x%"PRIx64"\n", sample->data_src);\r\n}\r\nstatic struct machine *\r\nperf_session__find_machine_for_cpumode(struct perf_session *session,\r\nunion perf_event *event)\r\n{\r\nconst u8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nif (perf_guest &&\r\n((cpumode == PERF_RECORD_MISC_GUEST_KERNEL) ||\r\n(cpumode == PERF_RECORD_MISC_GUEST_USER))) {\r\nu32 pid;\r\nif (event->header.type == PERF_RECORD_MMAP)\r\npid = event->mmap.pid;\r\nelse\r\npid = event->ip.pid;\r\nreturn perf_session__findnew_machine(session, pid);\r\n}\r\nreturn &session->machines.host;\r\n}\r\nstatic int perf_session_deliver_event(struct perf_session *session,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_tool *tool,\r\nu64 file_offset)\r\n{\r\nstruct perf_evsel *evsel;\r\nstruct machine *machine;\r\ndump_event(session, event, file_offset, sample);\r\nevsel = perf_evlist__id2evsel(session->evlist, sample->id);\r\nif (evsel != NULL && event->header.type != PERF_RECORD_SAMPLE) {\r\nhists__inc_nr_events(&evsel->hists, event->header.type);\r\n}\r\nmachine = perf_session__find_machine_for_cpumode(session, event);\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_SAMPLE:\r\ndump_sample(evsel, event, sample);\r\nif (evsel == NULL) {\r\n++session->stats.nr_unknown_id;\r\nreturn 0;\r\n}\r\nif (machine == NULL) {\r\n++session->stats.nr_unprocessable_samples;\r\nreturn 0;\r\n}\r\nreturn tool->sample(tool, event, sample, evsel, machine);\r\ncase PERF_RECORD_MMAP:\r\nreturn tool->mmap(tool, event, sample, machine);\r\ncase PERF_RECORD_COMM:\r\nreturn tool->comm(tool, event, sample, machine);\r\ncase PERF_RECORD_FORK:\r\nreturn tool->fork(tool, event, sample, machine);\r\ncase PERF_RECORD_EXIT:\r\nreturn tool->exit(tool, event, sample, machine);\r\ncase PERF_RECORD_LOST:\r\nif (tool->lost == perf_event__process_lost)\r\nsession->stats.total_lost += event->lost.lost;\r\nreturn tool->lost(tool, event, sample, machine);\r\ncase PERF_RECORD_READ:\r\nreturn tool->read(tool, event, sample, evsel, machine);\r\ncase PERF_RECORD_THROTTLE:\r\nreturn tool->throttle(tool, event, sample, machine);\r\ncase PERF_RECORD_UNTHROTTLE:\r\nreturn tool->unthrottle(tool, event, sample, machine);\r\ndefault:\r\n++session->stats.nr_unknown_events;\r\nreturn -1;\r\n}\r\n}\r\nstatic int perf_session__preprocess_sample(struct perf_session *session,\r\nunion perf_event *event, struct perf_sample *sample)\r\n{\r\nif (event->header.type != PERF_RECORD_SAMPLE ||\r\n!(perf_evlist__sample_type(session->evlist) & PERF_SAMPLE_CALLCHAIN))\r\nreturn 0;\r\nif (!ip_callchain__valid(sample->callchain, event)) {\r\npr_debug("call-chain problem with event, skipping it.\n");\r\n++session->stats.nr_invalid_chains;\r\nsession->stats.total_invalid_chains += sample->period;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_session__process_user_event(struct perf_session *session, union perf_event *event,\r\nstruct perf_tool *tool, u64 file_offset)\r\n{\r\nint err;\r\ndump_event(session, event, file_offset, NULL);\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_HEADER_ATTR:\r\nerr = tool->attr(event, &session->evlist);\r\nif (err == 0)\r\nperf_session__set_id_hdr_size(session);\r\nreturn err;\r\ncase PERF_RECORD_HEADER_EVENT_TYPE:\r\nreturn tool->event_type(tool, event);\r\ncase PERF_RECORD_HEADER_TRACING_DATA:\r\nlseek(session->fd, file_offset, SEEK_SET);\r\nreturn tool->tracing_data(event, session);\r\ncase PERF_RECORD_HEADER_BUILD_ID:\r\nreturn tool->build_id(tool, event, session);\r\ncase PERF_RECORD_FINISHED_ROUND:\r\nreturn tool->finished_round(tool, event, session);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void event_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nperf_event__swap_op swap;\r\nswap = perf_event__swap_ops[event->header.type];\r\nif (swap)\r\nswap(event, sample_id_all);\r\n}\r\nstatic int perf_session__process_event(struct perf_session *session,\r\nunion perf_event *event,\r\nstruct perf_tool *tool,\r\nu64 file_offset)\r\n{\r\nstruct perf_sample sample;\r\nint ret;\r\nif (session->header.needs_swap)\r\nevent_swap(event, perf_evlist__sample_id_all(session->evlist));\r\nif (event->header.type >= PERF_RECORD_HEADER_MAX)\r\nreturn -EINVAL;\r\nevents_stats__inc(&session->stats, event->header.type);\r\nif (event->header.type >= PERF_RECORD_USER_TYPE_START)\r\nreturn perf_session__process_user_event(session, event, tool, file_offset);\r\nret = perf_evlist__parse_sample(session->evlist, event, &sample);\r\nif (ret)\r\nreturn ret;\r\nif (perf_session__preprocess_sample(session, event, &sample))\r\nreturn 0;\r\nif (tool->ordered_samples) {\r\nret = perf_session_queue_event(session, event, &sample,\r\nfile_offset);\r\nif (ret != -ETIME)\r\nreturn ret;\r\n}\r\nreturn perf_session_deliver_event(session, event, &sample, tool,\r\nfile_offset);\r\n}\r\nvoid perf_event_header__bswap(struct perf_event_header *self)\r\n{\r\nself->type = bswap_32(self->type);\r\nself->misc = bswap_16(self->misc);\r\nself->size = bswap_16(self->size);\r\n}\r\nstruct thread *perf_session__findnew(struct perf_session *session, pid_t pid)\r\n{\r\nreturn machine__findnew_thread(&session->machines.host, pid);\r\n}\r\nstatic struct thread *perf_session__register_idle_thread(struct perf_session *self)\r\n{\r\nstruct thread *thread = perf_session__findnew(self, 0);\r\nif (thread == NULL || thread__set_comm(thread, "swapper")) {\r\npr_err("problem inserting idle task.\n");\r\nthread = NULL;\r\n}\r\nreturn thread;\r\n}\r\nstatic void perf_session__warn_about_errors(const struct perf_session *session,\r\nconst struct perf_tool *tool)\r\n{\r\nif (tool->lost == perf_event__process_lost &&\r\nsession->stats.nr_events[PERF_RECORD_LOST] != 0) {\r\nui__warning("Processed %d events and lost %d chunks!\n\n"\r\n"Check IO/CPU overload!\n\n",\r\nsession->stats.nr_events[0],\r\nsession->stats.nr_events[PERF_RECORD_LOST]);\r\n}\r\nif (session->stats.nr_unknown_events != 0) {\r\nui__warning("Found %u unknown events!\n\n"\r\n"Is this an older tool processing a perf.data "\r\n"file generated by a more recent tool?\n\n"\r\n"If that is not the case, consider "\r\n"reporting to linux-kernel@vger.kernel.org.\n\n",\r\nsession->stats.nr_unknown_events);\r\n}\r\nif (session->stats.nr_unknown_id != 0) {\r\nui__warning("%u samples with id not present in the header\n",\r\nsession->stats.nr_unknown_id);\r\n}\r\nif (session->stats.nr_invalid_chains != 0) {\r\nui__warning("Found invalid callchains!\n\n"\r\n"%u out of %u events were discarded for this reason.\n\n"\r\n"Consider reporting to linux-kernel@vger.kernel.org.\n\n",\r\nsession->stats.nr_invalid_chains,\r\nsession->stats.nr_events[PERF_RECORD_SAMPLE]);\r\n}\r\nif (session->stats.nr_unprocessable_samples != 0) {\r\nui__warning("%u unprocessable samples recorded.\n"\r\n"Do you have a KVM guest running and not using 'perf kvm'?\n",\r\nsession->stats.nr_unprocessable_samples);\r\n}\r\n}\r\nstatic int __perf_session__process_pipe_events(struct perf_session *self,\r\nstruct perf_tool *tool)\r\n{\r\nunion perf_event *event;\r\nuint32_t size, cur_size = 0;\r\nvoid *buf = NULL;\r\nint skip = 0;\r\nu64 head;\r\nint err;\r\nvoid *p;\r\nperf_tool__fill_defaults(tool);\r\nhead = 0;\r\ncur_size = sizeof(union perf_event);\r\nbuf = malloc(cur_size);\r\nif (!buf)\r\nreturn -errno;\r\nmore:\r\nevent = buf;\r\nerr = readn(self->fd, event, sizeof(struct perf_event_header));\r\nif (err <= 0) {\r\nif (err == 0)\r\ngoto done;\r\npr_err("failed to read event header\n");\r\ngoto out_err;\r\n}\r\nif (self->header.needs_swap)\r\nperf_event_header__bswap(&event->header);\r\nsize = event->header.size;\r\nif (size == 0)\r\nsize = 8;\r\nif (size > cur_size) {\r\nvoid *new = realloc(buf, size);\r\nif (!new) {\r\npr_err("failed to allocate memory to read event\n");\r\ngoto out_err;\r\n}\r\nbuf = new;\r\ncur_size = size;\r\nevent = buf;\r\n}\r\np = event;\r\np += sizeof(struct perf_event_header);\r\nif (size - sizeof(struct perf_event_header)) {\r\nerr = readn(self->fd, p, size - sizeof(struct perf_event_header));\r\nif (err <= 0) {\r\nif (err == 0) {\r\npr_err("unexpected end of event stream\n");\r\ngoto done;\r\n}\r\npr_err("failed to read event data\n");\r\ngoto out_err;\r\n}\r\n}\r\nif ((skip = perf_session__process_event(self, event, tool, head)) < 0) {\r\npr_err("%#" PRIx64 " [%#x]: failed to process type: %d\n",\r\nhead, event->header.size, event->header.type);\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nhead += size;\r\nif (skip > 0)\r\nhead += skip;\r\nif (!session_done())\r\ngoto more;\r\ndone:\r\nerr = 0;\r\nout_err:\r\nfree(buf);\r\nperf_session__warn_about_errors(self, tool);\r\nperf_session_free_sample_buffers(self);\r\nreturn err;\r\n}\r\nstatic union perf_event *\r\nfetch_mmaped_event(struct perf_session *session,\r\nu64 head, size_t mmap_size, char *buf)\r\n{\r\nunion perf_event *event;\r\nif (head + sizeof(event->header) > mmap_size)\r\nreturn NULL;\r\nevent = (union perf_event *)(buf + head);\r\nif (session->header.needs_swap)\r\nperf_event_header__bswap(&event->header);\r\nif (head + event->header.size > mmap_size)\r\nreturn NULL;\r\nreturn event;\r\n}\r\nint __perf_session__process_events(struct perf_session *session,\r\nu64 data_offset, u64 data_size,\r\nu64 file_size, struct perf_tool *tool)\r\n{\r\nu64 head, page_offset, file_offset, file_pos, progress_next;\r\nint err, mmap_prot, mmap_flags, map_idx = 0;\r\nsize_t mmap_size;\r\nchar *buf, *mmaps[NUM_MMAPS];\r\nunion perf_event *event;\r\nuint32_t size;\r\nperf_tool__fill_defaults(tool);\r\npage_offset = page_size * (data_offset / page_size);\r\nfile_offset = page_offset;\r\nhead = data_offset - page_offset;\r\nif (data_offset + data_size < file_size)\r\nfile_size = data_offset + data_size;\r\nprogress_next = file_size / 16;\r\nmmap_size = MMAP_SIZE;\r\nif (mmap_size > file_size)\r\nmmap_size = file_size;\r\nmemset(mmaps, 0, sizeof(mmaps));\r\nmmap_prot = PROT_READ;\r\nmmap_flags = MAP_SHARED;\r\nif (session->header.needs_swap) {\r\nmmap_prot |= PROT_WRITE;\r\nmmap_flags = MAP_PRIVATE;\r\n}\r\nremap:\r\nbuf = mmap(NULL, mmap_size, mmap_prot, mmap_flags, session->fd,\r\nfile_offset);\r\nif (buf == MAP_FAILED) {\r\npr_err("failed to mmap file\n");\r\nerr = -errno;\r\ngoto out_err;\r\n}\r\nmmaps[map_idx] = buf;\r\nmap_idx = (map_idx + 1) & (ARRAY_SIZE(mmaps) - 1);\r\nfile_pos = file_offset + head;\r\nmore:\r\nevent = fetch_mmaped_event(session, head, mmap_size, buf);\r\nif (!event) {\r\nif (mmaps[map_idx]) {\r\nmunmap(mmaps[map_idx], mmap_size);\r\nmmaps[map_idx] = NULL;\r\n}\r\npage_offset = page_size * (head / page_size);\r\nfile_offset += page_offset;\r\nhead -= page_offset;\r\ngoto remap;\r\n}\r\nsize = event->header.size;\r\nif (size == 0 ||\r\nperf_session__process_event(session, event, tool, file_pos) < 0) {\r\npr_err("%#" PRIx64 " [%#x]: failed to process type: %d\n",\r\nfile_offset + head, event->header.size,\r\nevent->header.type);\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nhead += size;\r\nfile_pos += size;\r\nif (file_pos >= progress_next) {\r\nprogress_next += file_size / 16;\r\nui_progress__update(file_pos, file_size,\r\n"Processing events...");\r\n}\r\nif (file_pos < file_size)\r\ngoto more;\r\nerr = 0;\r\nsession->ordered_samples.next_flush = ULLONG_MAX;\r\nerr = flush_sample_queue(session, tool);\r\nout_err:\r\nui_progress__finish();\r\nperf_session__warn_about_errors(session, tool);\r\nperf_session_free_sample_buffers(session);\r\nreturn err;\r\n}\r\nint perf_session__process_events(struct perf_session *self,\r\nstruct perf_tool *tool)\r\n{\r\nint err;\r\nif (perf_session__register_idle_thread(self) == NULL)\r\nreturn -ENOMEM;\r\nif (!self->fd_pipe)\r\nerr = __perf_session__process_events(self,\r\nself->header.data_offset,\r\nself->header.data_size,\r\nself->size, tool);\r\nelse\r\nerr = __perf_session__process_pipe_events(self, tool);\r\nreturn err;\r\n}\r\nbool perf_session__has_traces(struct perf_session *session, const char *msg)\r\n{\r\nif (!(perf_evlist__sample_type(session->evlist) & PERF_SAMPLE_RAW)) {\r\npr_err("No trace sample to read. Did you call 'perf %s'?\n", msg);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint maps__set_kallsyms_ref_reloc_sym(struct map **maps,\r\nconst char *symbol_name, u64 addr)\r\n{\r\nchar *bracket;\r\nenum map_type i;\r\nstruct ref_reloc_sym *ref;\r\nref = zalloc(sizeof(struct ref_reloc_sym));\r\nif (ref == NULL)\r\nreturn -ENOMEM;\r\nref->name = strdup(symbol_name);\r\nif (ref->name == NULL) {\r\nfree(ref);\r\nreturn -ENOMEM;\r\n}\r\nbracket = strchr(ref->name, ']');\r\nif (bracket)\r\n*bracket = '\0';\r\nref->addr = addr;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nstruct kmap *kmap = map__kmap(maps[i]);\r\nkmap->ref_reloc_sym = ref;\r\n}\r\nreturn 0;\r\n}\r\nsize_t perf_session__fprintf_dsos(struct perf_session *self, FILE *fp)\r\n{\r\nreturn machines__fprintf_dsos(&self->machines, fp);\r\n}\r\nsize_t perf_session__fprintf_dsos_buildid(struct perf_session *self, FILE *fp,\r\nbool (skip)(struct dso *dso, int parm), int parm)\r\n{\r\nreturn machines__fprintf_dsos_buildid(&self->machines, fp, skip, parm);\r\n}\r\nsize_t perf_session__fprintf_nr_events(struct perf_session *session, FILE *fp)\r\n{\r\nstruct perf_evsel *pos;\r\nsize_t ret = fprintf(fp, "Aggregated stats:\n");\r\nret += events_stats__fprintf(&session->stats, fp);\r\nlist_for_each_entry(pos, &session->evlist->entries, node) {\r\nret += fprintf(fp, "%s stats:\n", perf_evsel__name(pos));\r\nret += events_stats__fprintf(&pos->hists.stats, fp);\r\n}\r\nreturn ret;\r\n}\r\nsize_t perf_session__fprintf(struct perf_session *session, FILE *fp)\r\n{\r\nreturn machine__fprintf(&session->machines.host, fp);\r\n}\r\nstruct perf_evsel *perf_session__find_first_evtype(struct perf_session *session,\r\nunsigned int type)\r\n{\r\nstruct perf_evsel *pos;\r\nlist_for_each_entry(pos, &session->evlist->entries, node) {\r\nif (pos->attr.type == type)\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}\r\nvoid perf_evsel__print_ip(struct perf_evsel *evsel, union perf_event *event,\r\nstruct perf_sample *sample, struct machine *machine,\r\nint print_sym, int print_dso, int print_symoffset)\r\n{\r\nstruct addr_location al;\r\nstruct callchain_cursor_node *node;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample,\r\nNULL) < 0) {\r\nerror("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn;\r\n}\r\nif (symbol_conf.use_callchain && sample->callchain) {\r\nif (machine__resolve_callchain(machine, evsel, al.thread,\r\nsample, NULL) != 0) {\r\nif (verbose)\r\nerror("Failed to resolve callchain. Skipping\n");\r\nreturn;\r\n}\r\ncallchain_cursor_commit(&callchain_cursor);\r\nwhile (1) {\r\nnode = callchain_cursor_current(&callchain_cursor);\r\nif (!node)\r\nbreak;\r\nprintf("\t%16" PRIx64, node->ip);\r\nif (print_sym) {\r\nprintf(" ");\r\nsymbol__fprintf_symname(node->sym, stdout);\r\n}\r\nif (print_dso) {\r\nprintf(" (");\r\nmap__fprintf_dsoname(node->map, stdout);\r\nprintf(")");\r\n}\r\nprintf("\n");\r\ncallchain_cursor_advance(&callchain_cursor);\r\n}\r\n} else {\r\nprintf("%16" PRIx64, sample->ip);\r\nif (print_sym) {\r\nprintf(" ");\r\nif (print_symoffset)\r\nsymbol__fprintf_symname_offs(al.sym, &al,\r\nstdout);\r\nelse\r\nsymbol__fprintf_symname(al.sym, stdout);\r\n}\r\nif (print_dso) {\r\nprintf(" (");\r\nmap__fprintf_dsoname(al.map, stdout);\r\nprintf(")");\r\n}\r\n}\r\n}\r\nint perf_session__cpu_bitmap(struct perf_session *session,\r\nconst char *cpu_list, unsigned long *cpu_bitmap)\r\n{\r\nint i;\r\nstruct cpu_map *map;\r\nfor (i = 0; i < PERF_TYPE_MAX; ++i) {\r\nstruct perf_evsel *evsel;\r\nevsel = perf_session__find_first_evtype(session, i);\r\nif (!evsel)\r\ncontinue;\r\nif (!(evsel->attr.sample_type & PERF_SAMPLE_CPU)) {\r\npr_err("File does not contain CPU events. "\r\n"Remove -c option to proceed.\n");\r\nreturn -1;\r\n}\r\n}\r\nmap = cpu_map__new(cpu_list);\r\nif (map == NULL) {\r\npr_err("Invalid cpu_list\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < map->nr; i++) {\r\nint cpu = map->map[i];\r\nif (cpu >= MAX_NR_CPUS) {\r\npr_err("Requested CPU %d too large. "\r\n"Consider raising MAX_NR_CPUS\n", cpu);\r\nreturn -1;\r\n}\r\nset_bit(cpu, cpu_bitmap);\r\n}\r\nreturn 0;\r\n}\r\nvoid perf_session__fprintf_info(struct perf_session *session, FILE *fp,\r\nbool full)\r\n{\r\nstruct stat st;\r\nint ret;\r\nif (session == NULL || fp == NULL)\r\nreturn;\r\nret = fstat(session->fd, &st);\r\nif (ret == -1)\r\nreturn;\r\nfprintf(fp, "# ========\n");\r\nfprintf(fp, "# captured on: %s", ctime(&st.st_ctime));\r\nperf_header__fprintf_info(session, fp, full);\r\nfprintf(fp, "# ========\n#\n");\r\n}\r\nint __perf_session__set_tracepoints_handlers(struct perf_session *session,\r\nconst struct perf_evsel_str_handler *assocs,\r\nsize_t nr_assocs)\r\n{\r\nstruct perf_evlist *evlist = session->evlist;\r\nstruct event_format *format;\r\nstruct perf_evsel *evsel;\r\nchar *tracepoint, *name;\r\nsize_t i;\r\nint err;\r\nfor (i = 0; i < nr_assocs; i++) {\r\nerr = -ENOMEM;\r\ntracepoint = strdup(assocs[i].name);\r\nif (tracepoint == NULL)\r\ngoto out;\r\nerr = -ENOENT;\r\nname = strchr(tracepoint, ':');\r\nif (name == NULL)\r\ngoto out_free;\r\n*name++ = '\0';\r\nformat = pevent_find_event_by_name(session->pevent,\r\ntracepoint, name);\r\nif (format == NULL) {\r\ngoto next;\r\n}\r\nevsel = perf_evlist__find_tracepoint_by_id(evlist, format->id);\r\nif (evsel == NULL)\r\ngoto next;\r\nerr = -EEXIST;\r\nif (evsel->handler.func != NULL)\r\ngoto out_free;\r\nevsel->handler.func = assocs[i].handler;\r\nnext:\r\nfree(tracepoint);\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_free:\r\nfree(tracepoint);\r\ngoto out;\r\n}
