static void lt3593_led_work(struct work_struct *work)\r\n{\r\nint pulses;\r\nstruct lt3593_led_data *led_dat =\r\ncontainer_of(work, struct lt3593_led_data, work);\r\nif (led_dat->new_level == 0) {\r\ngpio_set_value_cansleep(led_dat->gpio, 0);\r\nreturn;\r\n}\r\npulses = 32 - (led_dat->new_level * 32) / 255;\r\nif (pulses == 0) {\r\ngpio_set_value_cansleep(led_dat->gpio, 0);\r\nmdelay(1);\r\ngpio_set_value_cansleep(led_dat->gpio, 1);\r\nreturn;\r\n}\r\ngpio_set_value_cansleep(led_dat->gpio, 1);\r\nwhile (pulses--) {\r\ngpio_set_value_cansleep(led_dat->gpio, 0);\r\nudelay(1);\r\ngpio_set_value_cansleep(led_dat->gpio, 1);\r\nudelay(1);\r\n}\r\n}\r\nstatic void lt3593_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct lt3593_led_data *led_dat =\r\ncontainer_of(led_cdev, struct lt3593_led_data, cdev);\r\nled_dat->new_level = value;\r\nschedule_work(&led_dat->work);\r\n}\r\nstatic int create_lt3593_led(const struct gpio_led *template,\r\nstruct lt3593_led_data *led_dat, struct device *parent)\r\n{\r\nint ret, state;\r\nif (!gpio_is_valid(template->gpio)) {\r\ndev_info(parent, "%s: skipping unavailable LT3593 LED at gpio %d (%s)\n",\r\nKBUILD_MODNAME, template->gpio, template->name);\r\nreturn 0;\r\n}\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->gpio = template->gpio;\r\nled_dat->cdev.brightness_set = lt3593_led_set;\r\nstate = (template->default_state == LEDS_GPIO_DEFSTATE_ON);\r\nled_dat->cdev.brightness = state ? LED_FULL : LED_OFF;\r\nif (!template->retain_state_suspended)\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nret = devm_gpio_request_one(parent, template->gpio, state ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\ntemplate->name);\r\nif (ret < 0)\r\nreturn ret;\r\nINIT_WORK(&led_dat->work, lt3593_led_work);\r\nret = led_classdev_register(parent, &led_dat->cdev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(parent, "%s: registered LT3593 LED '%s' at GPIO %d\n",\r\nKBUILD_MODNAME, template->name, template->gpio);\r\nreturn 0;\r\n}\r\nstatic void delete_lt3593_led(struct lt3593_led_data *led)\r\n{\r\nif (!gpio_is_valid(led->gpio))\r\nreturn;\r\nled_classdev_unregister(&led->cdev);\r\ncancel_work_sync(&led->work);\r\n}\r\nstatic int lt3593_led_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct lt3593_led_data *leds_data;\r\nint i, ret = 0;\r\nif (!pdata)\r\nreturn -EBUSY;\r\nleds_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct lt3593_led_data) * pdata->num_leds,\r\nGFP_KERNEL);\r\nif (!leds_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nret = create_lt3593_led(&pdata->leds[i], &leds_data[i],\r\n&pdev->dev);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, leds_data);\r\nreturn 0;\r\nerr:\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_lt3593_led(&leds_data[i]);\r\nreturn ret;\r\n}\r\nstatic int lt3593_led_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct gpio_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct lt3593_led_data *leds_data;\r\nleds_data = platform_get_drvdata(pdev);\r\nfor (i = 0; i < pdata->num_leds; i++)\r\ndelete_lt3593_led(&leds_data[i]);\r\nreturn 0;\r\n}
