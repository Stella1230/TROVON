static struct tpci200_board *check_slot(struct ipack_device *dev)\r\n{\r\nstruct tpci200_board *tpci200;\r\nif (dev == NULL)\r\nreturn NULL;\r\ntpci200 = dev_get_drvdata(dev->bus->parent);\r\nif (tpci200 == NULL) {\r\ndev_info(&dev->dev, "carrier board not found\n");\r\nreturn NULL;\r\n}\r\nif (dev->slot >= TPCI200_NB_SLOT) {\r\ndev_info(&dev->dev,\r\n"Slot [%d:%d] doesn't exist! Last tpci200 slot is %d.\n",\r\ndev->bus->bus_nr, dev->slot, TPCI200_NB_SLOT-1);\r\nreturn NULL;\r\n}\r\nreturn tpci200;\r\n}\r\nstatic void tpci200_clear_mask(struct tpci200_board *tpci200,\r\n__le16 __iomem *addr, u16 mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tpci200->regs_lock, flags);\r\niowrite16(ioread16(addr) & (~mask), addr);\r\nspin_unlock_irqrestore(&tpci200->regs_lock, flags);\r\n}\r\nstatic void tpci200_set_mask(struct tpci200_board *tpci200,\r\n__le16 __iomem *addr, u16 mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tpci200->regs_lock, flags);\r\niowrite16(ioread16(addr) | mask, addr);\r\nspin_unlock_irqrestore(&tpci200->regs_lock, flags);\r\n}\r\nstatic void tpci200_unregister(struct tpci200_board *tpci200)\r\n{\r\nfree_irq(tpci200->info->pdev->irq, (void *) tpci200);\r\npci_iounmap(tpci200->info->pdev, tpci200->info->interface_regs);\r\npci_iounmap(tpci200->info->pdev, tpci200->info->cfg_regs);\r\npci_release_region(tpci200->info->pdev, TPCI200_IP_INTERFACE_BAR);\r\npci_release_region(tpci200->info->pdev, TPCI200_IO_ID_INT_SPACES_BAR);\r\npci_release_region(tpci200->info->pdev, TPCI200_MEM16_SPACE_BAR);\r\npci_release_region(tpci200->info->pdev, TPCI200_MEM8_SPACE_BAR);\r\npci_release_region(tpci200->info->pdev, TPCI200_CFG_MEM_BAR);\r\npci_disable_device(tpci200->info->pdev);\r\npci_dev_put(tpci200->info->pdev);\r\n}\r\nstatic void tpci200_enable_irq(struct tpci200_board *tpci200,\r\nint islot)\r\n{\r\ntpci200_set_mask(tpci200,\r\n&tpci200->info->interface_regs->control[islot],\r\nTPCI200_INT0_EN | TPCI200_INT1_EN);\r\n}\r\nstatic void tpci200_disable_irq(struct tpci200_board *tpci200,\r\nint islot)\r\n{\r\ntpci200_clear_mask(tpci200,\r\n&tpci200->info->interface_regs->control[islot],\r\nTPCI200_INT0_EN | TPCI200_INT1_EN);\r\n}\r\nstatic irqreturn_t tpci200_slot_irq(struct slot_irq *slot_irq)\r\n{\r\nirqreturn_t ret;\r\nif (!slot_irq)\r\nreturn -ENODEV;\r\nret = slot_irq->handler(slot_irq->arg);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t tpci200_interrupt(int irq, void *dev_id)\r\n{\r\nstruct tpci200_board *tpci200 = (struct tpci200_board *) dev_id;\r\nstruct slot_irq *slot_irq;\r\nirqreturn_t ret;\r\nu16 status_reg;\r\nint i;\r\nstatus_reg = ioread16(&tpci200->info->interface_regs->status);\r\nif (!(status_reg & TPCI200_SLOT_INT_MASK))\r\nreturn IRQ_NONE;\r\nrcu_read_lock();\r\nfor (i = 0; i < TPCI200_NB_SLOT; i++) {\r\nif (!(status_reg & ((TPCI200_A_INT0 | TPCI200_A_INT1) << (2 * i))))\r\ncontinue;\r\nslot_irq = rcu_dereference(tpci200->slots[i].irq);\r\nret = tpci200_slot_irq(slot_irq);\r\nif (ret == -ENODEV) {\r\ndev_info(&tpci200->info->pdev->dev,\r\n"No registered ISR for slot [%d:%d]!. IRQ will be disabled.\n",\r\ntpci200->number, i);\r\ntpci200_disable_irq(tpci200, i);\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tpci200_free_irq(struct ipack_device *dev)\r\n{\r\nstruct slot_irq *slot_irq;\r\nstruct tpci200_board *tpci200;\r\ntpci200 = check_slot(dev);\r\nif (tpci200 == NULL)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&tpci200->mutex))\r\nreturn -ERESTARTSYS;\r\nif (tpci200->slots[dev->slot].irq == NULL) {\r\nmutex_unlock(&tpci200->mutex);\r\nreturn -EINVAL;\r\n}\r\ntpci200_disable_irq(tpci200, dev->slot);\r\nslot_irq = tpci200->slots[dev->slot].irq;\r\nRCU_INIT_POINTER(tpci200->slots[dev->slot].irq, NULL);\r\nsynchronize_rcu();\r\nkfree(slot_irq);\r\nmutex_unlock(&tpci200->mutex);\r\nreturn 0;\r\n}\r\nstatic int tpci200_request_irq(struct ipack_device *dev,\r\nirqreturn_t (*handler)(void *), void *arg)\r\n{\r\nint res = 0;\r\nstruct slot_irq *slot_irq;\r\nstruct tpci200_board *tpci200;\r\ntpci200 = check_slot(dev);\r\nif (tpci200 == NULL)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&tpci200->mutex))\r\nreturn -ERESTARTSYS;\r\nif (tpci200->slots[dev->slot].irq != NULL) {\r\ndev_err(&dev->dev,\r\n"Slot [%d:%d] IRQ already registered !\n",\r\ndev->bus->bus_nr,\r\ndev->slot);\r\nres = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nslot_irq = kzalloc(sizeof(struct slot_irq), GFP_KERNEL);\r\nif (slot_irq == NULL) {\r\ndev_err(&dev->dev,\r\n"Slot [%d:%d] unable to allocate memory for IRQ !\n",\r\ndev->bus->bus_nr, dev->slot);\r\nres = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nslot_irq->handler = handler;\r\nslot_irq->arg = arg;\r\nslot_irq->holder = dev;\r\nrcu_assign_pointer(tpci200->slots[dev->slot].irq, slot_irq);\r\ntpci200_enable_irq(tpci200, dev->slot);\r\nout_unlock:\r\nmutex_unlock(&tpci200->mutex);\r\nreturn res;\r\n}\r\nstatic int tpci200_register(struct tpci200_board *tpci200)\r\n{\r\nint i;\r\nint res;\r\nphys_addr_t ioidint_base;\r\nunsigned short slot_ctrl;\r\nif (pci_enable_device(tpci200->info->pdev) < 0)\r\nreturn -ENODEV;\r\nres = pci_request_region(tpci200->info->pdev, TPCI200_IP_INTERFACE_BAR,\r\n"Carrier IP interface registers");\r\nif (res) {\r\ndev_err(&tpci200->info->pdev->dev,\r\n"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 2 !",\r\ntpci200->info->pdev->bus->number,\r\ntpci200->info->pdev->devfn);\r\ngoto out_disable_pci;\r\n}\r\nres = pci_request_region(tpci200->info->pdev,\r\nTPCI200_IO_ID_INT_SPACES_BAR,\r\n"Carrier IO ID INT space");\r\nif (res) {\r\ndev_err(&tpci200->info->pdev->dev,\r\n"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 3 !",\r\ntpci200->info->pdev->bus->number,\r\ntpci200->info->pdev->devfn);\r\ngoto out_release_ip_space;\r\n}\r\nres = pci_request_region(tpci200->info->pdev, TPCI200_MEM8_SPACE_BAR,\r\n"Carrier MEM8 space");\r\nif (res) {\r\ndev_err(&tpci200->info->pdev->dev,\r\n"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 5!",\r\ntpci200->info->pdev->bus->number,\r\ntpci200->info->pdev->devfn);\r\ngoto out_release_ioid_int_space;\r\n}\r\nres = pci_request_region(tpci200->info->pdev, TPCI200_MEM16_SPACE_BAR,\r\n"Carrier MEM16 space");\r\nif (res) {\r\ndev_err(&tpci200->info->pdev->dev,\r\n"(bn 0x%X, sn 0x%X) failed to allocate PCI resource for BAR 4!",\r\ntpci200->info->pdev->bus->number,\r\ntpci200->info->pdev->devfn);\r\ngoto out_release_mem8_space;\r\n}\r\ntpci200->info->interface_regs =\r\nioremap_nocache(pci_resource_start(tpci200->info->pdev,\r\nTPCI200_IP_INTERFACE_BAR),\r\nTPCI200_IFACE_SIZE);\r\nspin_lock_init(&tpci200->regs_lock);\r\nioidint_base = pci_resource_start(tpci200->info->pdev,\r\nTPCI200_IO_ID_INT_SPACES_BAR);\r\ntpci200->mod_mem[IPACK_IO_SPACE] = ioidint_base + TPCI200_IO_SPACE_OFF;\r\ntpci200->mod_mem[IPACK_ID_SPACE] = ioidint_base + TPCI200_ID_SPACE_OFF;\r\ntpci200->mod_mem[IPACK_INT_SPACE] =\r\nioidint_base + TPCI200_INT_SPACE_OFF;\r\ntpci200->mod_mem[IPACK_MEM8_SPACE] =\r\npci_resource_start(tpci200->info->pdev,\r\nTPCI200_MEM8_SPACE_BAR);\r\ntpci200->mod_mem[IPACK_MEM16_SPACE] =\r\npci_resource_start(tpci200->info->pdev,\r\nTPCI200_MEM16_SPACE_BAR);\r\nslot_ctrl = 0;\r\nfor (i = 0; i < TPCI200_NB_SLOT; i++)\r\nwritew(slot_ctrl, &tpci200->info->interface_regs->control[i]);\r\nres = request_irq(tpci200->info->pdev->irq,\r\ntpci200_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, (void *) tpci200);\r\nif (res) {\r\ndev_err(&tpci200->info->pdev->dev,\r\n"(bn 0x%X, sn 0x%X) unable to register IRQ !",\r\ntpci200->info->pdev->bus->number,\r\ntpci200->info->pdev->devfn);\r\ngoto out_release_ioid_int_space;\r\n}\r\nreturn 0;\r\nout_release_mem8_space:\r\npci_release_region(tpci200->info->pdev, TPCI200_MEM8_SPACE_BAR);\r\nout_release_ioid_int_space:\r\npci_release_region(tpci200->info->pdev, TPCI200_IO_ID_INT_SPACES_BAR);\r\nout_release_ip_space:\r\npci_release_region(tpci200->info->pdev, TPCI200_IP_INTERFACE_BAR);\r\nout_disable_pci:\r\npci_disable_device(tpci200->info->pdev);\r\nreturn res;\r\n}\r\nstatic int tpci200_get_clockrate(struct ipack_device *dev)\r\n{\r\nstruct tpci200_board *tpci200 = check_slot(dev);\r\n__le16 __iomem *addr;\r\nif (!tpci200)\r\nreturn -ENODEV;\r\naddr = &tpci200->info->interface_regs->control[dev->slot];\r\nreturn (ioread16(addr) & TPCI200_CLK32) ? 32 : 8;\r\n}\r\nstatic int tpci200_set_clockrate(struct ipack_device *dev, int mherz)\r\n{\r\nstruct tpci200_board *tpci200 = check_slot(dev);\r\n__le16 __iomem *addr;\r\nif (!tpci200)\r\nreturn -ENODEV;\r\naddr = &tpci200->info->interface_regs->control[dev->slot];\r\nswitch (mherz) {\r\ncase 8:\r\ntpci200_clear_mask(tpci200, addr, TPCI200_CLK32);\r\nbreak;\r\ncase 32:\r\ntpci200_set_mask(tpci200, addr, TPCI200_CLK32);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpci200_get_error(struct ipack_device *dev)\r\n{\r\nstruct tpci200_board *tpci200 = check_slot(dev);\r\n__le16 __iomem *addr;\r\nu16 mask;\r\nif (!tpci200)\r\nreturn -ENODEV;\r\naddr = &tpci200->info->interface_regs->status;\r\nmask = tpci200_status_error[dev->slot];\r\nreturn (ioread16(addr) & mask) ? 1 : 0;\r\n}\r\nstatic int tpci200_get_timeout(struct ipack_device *dev)\r\n{\r\nstruct tpci200_board *tpci200 = check_slot(dev);\r\n__le16 __iomem *addr;\r\nu16 mask;\r\nif (!tpci200)\r\nreturn -ENODEV;\r\naddr = &tpci200->info->interface_regs->status;\r\nmask = tpci200_status_timeout[dev->slot];\r\nreturn (ioread16(addr) & mask) ? 1 : 0;\r\n}\r\nstatic int tpci200_reset_timeout(struct ipack_device *dev)\r\n{\r\nstruct tpci200_board *tpci200 = check_slot(dev);\r\n__le16 __iomem *addr;\r\nu16 mask;\r\nif (!tpci200)\r\nreturn -ENODEV;\r\naddr = &tpci200->info->interface_regs->status;\r\nmask = tpci200_status_timeout[dev->slot];\r\niowrite16(mask, addr);\r\nreturn 0;\r\n}\r\nstatic void tpci200_uninstall(struct tpci200_board *tpci200)\r\n{\r\ntpci200_unregister(tpci200);\r\nkfree(tpci200->slots);\r\n}\r\nstatic int tpci200_install(struct tpci200_board *tpci200)\r\n{\r\nint res;\r\ntpci200->slots = kzalloc(\r\nTPCI200_NB_SLOT * sizeof(struct tpci200_slot), GFP_KERNEL);\r\nif (tpci200->slots == NULL)\r\nreturn -ENOMEM;\r\nres = tpci200_register(tpci200);\r\nif (res) {\r\nkfree(tpci200->slots);\r\ntpci200->slots = NULL;\r\nreturn res;\r\n}\r\nmutex_init(&tpci200->mutex);\r\nreturn 0;\r\n}\r\nstatic void tpci200_release_device(struct ipack_device *dev)\r\n{\r\nkfree(dev);\r\n}\r\nstatic int tpci200_create_device(struct tpci200_board *tpci200, int i)\r\n{\r\nint ret;\r\nenum ipack_space space;\r\nstruct ipack_device *dev =\r\nkzalloc(sizeof(struct ipack_device), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->slot = i;\r\ndev->bus = tpci200->info->ipack_bus;\r\ndev->release = tpci200_release_device;\r\nfor (space = 0; space < IPACK_SPACE_COUNT; space++) {\r\ndev->region[space].start =\r\ntpci200->mod_mem[space]\r\n+ tpci200_space_interval[space] * i;\r\ndev->region[space].size = tpci200_space_size[space];\r\n}\r\nret = ipack_device_init(dev);\r\nif (ret < 0) {\r\nipack_put_device(dev);\r\nreturn ret;\r\n}\r\nret = ipack_device_add(dev);\r\nif (ret < 0)\r\nipack_put_device(dev);\r\nreturn ret;\r\n}\r\nstatic int tpci200_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint ret, i;\r\nstruct tpci200_board *tpci200;\r\nu32 reg32;\r\ntpci200 = kzalloc(sizeof(struct tpci200_board), GFP_KERNEL);\r\nif (!tpci200)\r\nreturn -ENOMEM;\r\ntpci200->info = kzalloc(sizeof(struct tpci200_infos), GFP_KERNEL);\r\nif (!tpci200->info) {\r\nret = -ENOMEM;\r\ngoto out_err_info;\r\n}\r\npci_dev_get(pdev);\r\nret = pci_request_region(pdev, TPCI200_CFG_MEM_BAR,\r\nKBUILD_MODNAME " Configuration Memory");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to allocate PCI Configuration Memory");\r\nret = -EBUSY;\r\ngoto out_err_pci_request;\r\n}\r\ntpci200->info->cfg_regs = ioremap_nocache(\r\npci_resource_start(pdev, TPCI200_CFG_MEM_BAR),\r\npci_resource_len(pdev, TPCI200_CFG_MEM_BAR));\r\nif (!tpci200->info->cfg_regs) {\r\ndev_err(&pdev->dev, "Failed to map PCI Configuration Memory");\r\nret = -EFAULT;\r\ngoto out_err_ioremap;\r\n}\r\nreg32 = ioread32(tpci200->info->cfg_regs + LAS1_DESC);\r\nreg32 |= 1 << LAS_BIT_BIGENDIAN;\r\niowrite32(reg32, tpci200->info->cfg_regs + LAS1_DESC);\r\nreg32 = ioread32(tpci200->info->cfg_regs + LAS2_DESC);\r\nreg32 |= 1 << LAS_BIT_BIGENDIAN;\r\niowrite32(reg32, tpci200->info->cfg_regs + LAS2_DESC);\r\ntpci200->info->pdev = pdev;\r\ntpci200->info->id_table = (struct pci_device_id *)id;\r\nret = tpci200_install(tpci200);\r\nif (ret) {\r\ndev_err(&pdev->dev, "error during tpci200 install\n");\r\nret = -ENODEV;\r\ngoto out_err_install;\r\n}\r\ntpci200->info->ipack_bus = ipack_bus_register(&pdev->dev,\r\nTPCI200_NB_SLOT,\r\n&tpci200_bus_ops);\r\nif (!tpci200->info->ipack_bus) {\r\ndev_err(&pdev->dev,\r\n"error registering the carrier on ipack driver\n");\r\nret = -EFAULT;\r\ngoto out_err_bus_register;\r\n}\r\ntpci200->number = tpci200->info->ipack_bus->bus_nr;\r\ndev_set_drvdata(&pdev->dev, tpci200);\r\nfor (i = 0; i < TPCI200_NB_SLOT; i++)\r\ntpci200_create_device(tpci200, i);\r\nreturn 0;\r\nout_err_bus_register:\r\ntpci200_uninstall(tpci200);\r\nout_err_install:\r\niounmap(tpci200->info->cfg_regs);\r\nout_err_ioremap:\r\npci_release_region(pdev, TPCI200_CFG_MEM_BAR);\r\nout_err_pci_request:\r\npci_dev_put(pdev);\r\nkfree(tpci200->info);\r\nout_err_info:\r\nkfree(tpci200);\r\nreturn ret;\r\n}\r\nstatic void __tpci200_pci_remove(struct tpci200_board *tpci200)\r\n{\r\nipack_bus_unregister(tpci200->info->ipack_bus);\r\ntpci200_uninstall(tpci200);\r\nkfree(tpci200->info);\r\nkfree(tpci200);\r\n}\r\nstatic void tpci200_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct tpci200_board *tpci200 = pci_get_drvdata(dev);\r\n__tpci200_pci_remove(tpci200);\r\n}
