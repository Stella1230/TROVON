static void asix_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nstruct ax88172_int_data *event;\r\nint link;\r\nif (urb->actual_length < 8)\r\nreturn;\r\nevent = urb->transfer_buffer;\r\nlink = event->link & 0x01;\r\nif (netif_carrier_ok(dev->net) != link) {\r\nusbnet_link_change(dev, link, 1);\r\nnetdev_dbg(dev->net, "Link Status is: %d\n", link);\r\n}\r\n}\r\nstatic void asix_set_netdev_dev_addr(struct usbnet *dev, u8 *addr)\r\n{\r\nif (is_valid_ether_addr(addr)) {\r\nmemcpy(dev->net->dev_addr, addr, ETH_ALEN);\r\n} else {\r\nnetdev_info(dev->net, "invalid hw address, using random\n");\r\neth_hw_addr_random(dev->net);\r\n}\r\n}\r\nstatic u32 asix_get_phyid(struct usbnet *dev)\r\n{\r\nint phy_reg;\r\nu32 phy_id;\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nphy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID1);\r\nif (phy_reg != 0 && phy_reg != 0xFFFF)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (phy_reg <= 0 || phy_reg == 0xFFFF)\r\nreturn 0;\r\nphy_id = (phy_reg & 0xffff) << 16;\r\nphy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID2);\r\nif (phy_reg < 0)\r\nreturn 0;\r\nphy_id |= (phy_reg & 0xffff);\r\nreturn phy_id;\r\n}\r\nstatic u32 asix_get_link(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn mii_link_ok(&dev->mii);\r\n}\r\nstatic int asix_ioctl (struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nreturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\r\n}\r\nstatic void ax88172_set_multicast(struct net_device *net)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nu8 rx_ctl = 0x8c;\r\nif (net->flags & IFF_PROMISC) {\r\nrx_ctl |= 0x01;\r\n} else if (net->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(net) > AX_MAX_MCAST) {\r\nrx_ctl |= 0x02;\r\n} else if (netdev_mc_empty(net)) {\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nu32 crc_bits;\r\nmemset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);\r\nnetdev_for_each_mc_addr(ha, net) {\r\ncrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\ndata->multi_filter[crc_bits >> 3] |=\r\n1 << (crc_bits & 7);\r\n}\r\nasix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,\r\nAX_MCAST_FILTER_SIZE, data->multi_filter);\r\nrx_ctl |= 0x10;\r\n}\r\nasix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);\r\n}\r\nstatic int ax88172_link_reset(struct usbnet *dev)\r\n{\r\nu8 mode;\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nmode = AX88172_MEDIUM_DEFAULT;\r\nif (ecmd.duplex != DUPLEX_FULL)\r\nmode |= ~AX88172_MEDIUM_FD;\r\nnetdev_dbg(dev->net, "ax88172_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",\r\nethtool_cmd_speed(&ecmd), ecmd.duplex, mode);\r\nasix_write_medium_mode(dev, mode);\r\nreturn 0;\r\n}\r\nstatic int ax88172_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret = 0;\r\nu8 buf[ETH_ALEN];\r\nint i;\r\nunsigned long gpio_bits = dev->driver_info->data;\r\nusbnet_get_endpoints(dev,intf);\r\nfor (i = 2; i >= 0; i--) {\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS,\r\n(gpio_bits >> (i * 8)) & 0xff, 0, 0, NULL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(5);\r\n}\r\nret = asix_write_rx_ctl(dev, 0x80);\r\nif (ret < 0)\r\ngoto out;\r\nret = asix_read_cmd(dev, AX88172_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "read AX_CMD_READ_NODE_ID failed: %d\n",\r\nret);\r\ngoto out;\r\n}\r\nasix_set_netdev_dev_addr(dev, buf);\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = asix_mdio_read;\r\ndev->mii.mdio_write = asix_mdio_write;\r\ndev->mii.phy_id_mask = 0x3f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.phy_id = asix_get_phy_addr(dev);\r\ndev->net->netdev_ops = &ax88172_netdev_ops;\r\ndev->net->ethtool_ops = &ax88172_ethtool_ops;\r\ndev->net->needed_headroom = 4;\r\ndev->net->needed_tailroom = 4;\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\r\nmii_nway_restart(&dev->mii);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ax88772_link_reset(struct usbnet *dev)\r\n{\r\nu16 mode;\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nmode = AX88772_MEDIUM_DEFAULT;\r\nif (ethtool_cmd_speed(&ecmd) != SPEED_100)\r\nmode &= ~AX_MEDIUM_PS;\r\nif (ecmd.duplex != DUPLEX_FULL)\r\nmode &= ~AX_MEDIUM_FD;\r\nnetdev_dbg(dev->net, "ax88772_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",\r\nethtool_cmd_speed(&ecmd), ecmd.duplex, mode);\r\nasix_write_medium_mode(dev, mode);\r\nreturn 0;\r\n}\r\nstatic int ax88772_reset(struct usbnet *dev)\r\n{\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nint ret, embd_phy;\r\nu16 rx_ctl;\r\nret = asix_write_gpio(dev,\r\nAX_GPIO_RSE | AX_GPIO_GPO_2 | AX_GPIO_GPO2EN, 5);\r\nif (ret < 0)\r\ngoto out;\r\nembd_phy = ((asix_get_phy_addr(dev) & 0x1f) == 0x10 ? 1 : 0);\r\nret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, embd_phy, 0, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Select PHY #1 failed: %d\n", ret);\r\ngoto out;\r\n}\r\nret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nret = asix_sw_reset(dev, AX_SWRESET_CLEAR);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nif (embd_phy) {\r\nret = asix_sw_reset(dev, AX_SWRESET_IPRL);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nret = asix_sw_reset(dev, AX_SWRESET_PRTE);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nmsleep(150);\r\nrx_ctl = asix_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after software reset\n", rx_ctl);\r\nret = asix_write_rx_ctl(dev, 0x0000);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = asix_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x setting to 0x0000\n", rx_ctl);\r\nret = asix_sw_reset(dev, AX_SWRESET_PRL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nret = asix_sw_reset(dev, AX_SWRESET_IPRL | AX_SWRESET_PRL);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(150);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA);\r\nmii_nway_restart(&dev->mii);\r\nret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT);\r\nif (ret < 0)\r\ngoto out;\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,\r\nAX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,\r\nAX88772_IPG2_DEFAULT, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Write IPG,IPG1,IPG2 failed: %d\n", ret);\r\ngoto out;\r\n}\r\nmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\r\ndata->mac_addr);\r\nif (ret < 0)\r\ngoto out;\r\nret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = asix_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after all initializations\n",\r\nrx_ctl);\r\nrx_ctl = asix_read_medium_status(dev);\r\nnetdev_dbg(dev->net,\r\n"Medium Status is 0x%04x after all initializations\n",\r\nrx_ctl);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret, embd_phy, i;\r\nu8 buf[ETH_ALEN];\r\nu32 phyid;\r\nusbnet_get_endpoints(dev,intf);\r\nif (dev->driver_info->data & FLAG_EEPROM_MAC) {\r\nfor (i = 0; i < (ETH_ALEN >> 1); i++) {\r\nret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, 0x04 + i,\r\n0, 2, buf + i * 2);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n} else {\r\nret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,\r\n0, 0, ETH_ALEN, buf);\r\n}\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Failed to read MAC address: %d\n", ret);\r\nreturn ret;\r\n}\r\nasix_set_netdev_dev_addr(dev, buf);\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = asix_mdio_read;\r\ndev->mii.mdio_write = asix_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0x1f;\r\ndev->mii.phy_id = asix_get_phy_addr(dev);\r\ndev->net->netdev_ops = &ax88772_netdev_ops;\r\ndev->net->ethtool_ops = &ax88772_ethtool_ops;\r\ndev->net->needed_headroom = 4;\r\ndev->net->needed_tailroom = 4;\r\nembd_phy = ((dev->mii.phy_id & 0x1f) == 0x10 ? 1 : 0);\r\nret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, embd_phy, 0, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Select PHY #1 failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(150);\r\nret = asix_sw_reset(dev, AX_SWRESET_CLEAR);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(150);\r\nret = asix_sw_reset(dev, embd_phy ? AX_SWRESET_IPRL : AX_SWRESET_PRTE);\r\nphyid = asix_get_phyid(dev);\r\nnetdev_dbg(dev->net, "PHYID=0x%08x\n", phyid);\r\nif (dev->driver_info->flags & FLAG_FRAMING_AX) {\r\ndev->rx_urb_size = 2048;\r\n}\r\ndev->driver_priv = kzalloc(sizeof(struct asix_common_private), GFP_KERNEL);\r\nif (!dev->driver_priv)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nif (dev->driver_priv)\r\nkfree(dev->driver_priv);\r\n}\r\nstatic int marvell_phy_init(struct usbnet *dev)\r\n{\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nu16 reg;\r\nnetdev_dbg(dev->net, "marvell_phy_init()\n");\r\nreg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_MARVELL_STATUS);\r\nnetdev_dbg(dev->net, "MII_MARVELL_STATUS = 0x%04x\n", reg);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_MARVELL_CTRL,\r\nMARVELL_CTRL_RXDELAY | MARVELL_CTRL_TXDELAY);\r\nif (data->ledmode) {\r\nreg = asix_mdio_read(dev->net, dev->mii.phy_id,\r\nMII_MARVELL_LED_CTRL);\r\nnetdev_dbg(dev->net, "MII_MARVELL_LED_CTRL (1) = 0x%04x\n", reg);\r\nreg &= 0xf8ff;\r\nreg |= (1 + 0x0100);\r\nasix_mdio_write(dev->net, dev->mii.phy_id,\r\nMII_MARVELL_LED_CTRL, reg);\r\nreg = asix_mdio_read(dev->net, dev->mii.phy_id,\r\nMII_MARVELL_LED_CTRL);\r\nnetdev_dbg(dev->net, "MII_MARVELL_LED_CTRL (2) = 0x%04x\n", reg);\r\nreg &= 0xfc0f;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8211cl_phy_init(struct usbnet *dev)\r\n{\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nnetdev_dbg(dev->net, "rtl8211cl_phy_init()\n");\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0x0005);\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x0c, 0);\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x01,\r\nasix_mdio_read (dev->net, dev->mii.phy_id, 0x01) | 0x0080);\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0);\r\nif (data->ledmode == 12) {\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0x0002);\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x1a, 0x00cb);\r\nasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int marvell_led_status(struct usbnet *dev, u16 speed)\r\n{\r\nu16 reg = asix_mdio_read(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL);\r\nnetdev_dbg(dev->net, "marvell_led_status() read 0x%04x\n", reg);\r\nreg &= 0xfc0f;\r\nswitch (speed) {\r\ncase SPEED_1000:\r\nreg |= 0x03e0;\r\nbreak;\r\ncase SPEED_100:\r\nreg |= 0x03b0;\r\nbreak;\r\ndefault:\r\nreg |= 0x02f0;\r\n}\r\nnetdev_dbg(dev->net, "marvell_led_status() writing 0x%04x\n", reg);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL, reg);\r\nreturn 0;\r\n}\r\nstatic int ax88178_reset(struct usbnet *dev)\r\n{\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nint ret;\r\n__le16 eeprom;\r\nu8 status;\r\nint gpio0 = 0;\r\nu32 phyid;\r\nasix_read_cmd(dev, AX_CMD_READ_GPIOS, 0, 0, 1, &status);\r\nnetdev_dbg(dev->net, "GPIO Status: 0x%04x\n", status);\r\nasix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0, 0, 0, NULL);\r\nasix_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2, &eeprom);\r\nasix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0, 0, 0, NULL);\r\nnetdev_dbg(dev->net, "EEPROM index 0x17 is 0x%04x\n", eeprom);\r\nif (eeprom == cpu_to_le16(0xffff)) {\r\ndata->phymode = PHY_MODE_MARVELL;\r\ndata->ledmode = 0;\r\ngpio0 = 1;\r\n} else {\r\ndata->phymode = le16_to_cpu(eeprom) & 0x7F;\r\ndata->ledmode = le16_to_cpu(eeprom) >> 8;\r\ngpio0 = (le16_to_cpu(eeprom) & 0x80) ? 0 : 1;\r\n}\r\nnetdev_dbg(dev->net, "GPIO0: %d, PhyMode: %d\n", gpio0, data->phymode);\r\nasix_write_gpio(dev, AX_GPIO_RSE | AX_GPIO_GPO_1 | AX_GPIO_GPO1EN, 40);\r\nif ((le16_to_cpu(eeprom) >> 8) != 1) {\r\nasix_write_gpio(dev, 0x003c, 30);\r\nasix_write_gpio(dev, 0x001c, 300);\r\nasix_write_gpio(dev, 0x003c, 30);\r\n} else {\r\nnetdev_dbg(dev->net, "gpio phymode == 1 path\n");\r\nasix_write_gpio(dev, AX_GPIO_GPO1EN, 30);\r\nasix_write_gpio(dev, AX_GPIO_GPO1EN | AX_GPIO_GPO_1, 30);\r\n}\r\nphyid = asix_get_phyid(dev);\r\nnetdev_dbg(dev->net, "PHYID=0x%08x\n", phyid);\r\nasix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0, 0, 0, NULL);\r\nasix_sw_reset(dev, 0);\r\nmsleep(150);\r\nasix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD);\r\nmsleep(150);\r\nasix_write_rx_ctl(dev, 0);\r\nif (data->phymode == PHY_MODE_MARVELL) {\r\nmarvell_phy_init(dev);\r\nmsleep(60);\r\n} else if (data->phymode == PHY_MODE_RTL8211CL)\r\nrtl8211cl_phy_init(dev);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR,\r\nBMCR_RESET | BMCR_ANENABLE);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\r\nADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\r\nasix_mdio_write(dev->net, dev->mii.phy_id, MII_CTRL1000,\r\nADVERTISE_1000FULL);\r\nmii_nway_restart(&dev->mii);\r\nret = asix_write_medium_mode(dev, AX88178_MEDIUM_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\nmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\r\ndata->mac_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ax88178_link_reset(struct usbnet *dev)\r\n{\r\nu16 mode;\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nu32 speed;\r\nnetdev_dbg(dev->net, "ax88178_link_reset()\n");\r\nmii_check_media(&dev->mii, 1, 1);\r\nmii_ethtool_gset(&dev->mii, &ecmd);\r\nmode = AX88178_MEDIUM_DEFAULT;\r\nspeed = ethtool_cmd_speed(&ecmd);\r\nif (speed == SPEED_1000)\r\nmode |= AX_MEDIUM_GM;\r\nelse if (speed == SPEED_100)\r\nmode |= AX_MEDIUM_PS;\r\nelse\r\nmode &= ~(AX_MEDIUM_PS | AX_MEDIUM_GM);\r\nmode |= AX_MEDIUM_ENCK;\r\nif (ecmd.duplex == DUPLEX_FULL)\r\nmode |= AX_MEDIUM_FD;\r\nelse\r\nmode &= ~AX_MEDIUM_FD;\r\nnetdev_dbg(dev->net, "ax88178_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",\r\nspeed, ecmd.duplex, mode);\r\nasix_write_medium_mode(dev, mode);\r\nif (data->phymode == PHY_MODE_MARVELL && data->ledmode)\r\nmarvell_led_status(dev, speed);\r\nreturn 0;\r\n}\r\nstatic void ax88178_set_mfb(struct usbnet *dev)\r\n{\r\nu16 mfb = AX_RX_CTL_MFB_16384;\r\nu16 rxctl;\r\nu16 medium;\r\nint old_rx_urb_size = dev->rx_urb_size;\r\nif (dev->hard_mtu < 2048) {\r\ndev->rx_urb_size = 2048;\r\nmfb = AX_RX_CTL_MFB_2048;\r\n} else if (dev->hard_mtu < 4096) {\r\ndev->rx_urb_size = 4096;\r\nmfb = AX_RX_CTL_MFB_4096;\r\n} else if (dev->hard_mtu < 8192) {\r\ndev->rx_urb_size = 8192;\r\nmfb = AX_RX_CTL_MFB_8192;\r\n} else if (dev->hard_mtu < 16384) {\r\ndev->rx_urb_size = 16384;\r\nmfb = AX_RX_CTL_MFB_16384;\r\n}\r\nrxctl = asix_read_rx_ctl(dev);\r\nasix_write_rx_ctl(dev, (rxctl & ~AX_RX_CTL_MFB_16384) | mfb);\r\nmedium = asix_read_medium_status(dev);\r\nif (dev->net->mtu > 1500)\r\nmedium |= AX_MEDIUM_JFE;\r\nelse\r\nmedium &= ~AX_MEDIUM_JFE;\r\nasix_write_medium_mode(dev, medium);\r\nif (dev->rx_urb_size > old_rx_urb_size)\r\nusbnet_unlink_rx_urbs(dev);\r\n}\r\nstatic int ax88178_change_mtu(struct net_device *net, int new_mtu)\r\n{\r\nstruct usbnet *dev = netdev_priv(net);\r\nint ll_mtu = new_mtu + net->hard_header_len + 4;\r\nnetdev_dbg(dev->net, "ax88178_change_mtu() new_mtu=%d\n", new_mtu);\r\nif (new_mtu <= 0 || ll_mtu > 16384)\r\nreturn -EINVAL;\r\nif ((ll_mtu % dev->maxpacket) == 0)\r\nreturn -EDOM;\r\nnet->mtu = new_mtu;\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\nax88178_set_mfb(dev);\r\nreturn 0;\r\n}\r\nstatic int ax88178_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nu8 buf[ETH_ALEN];\r\nusbnet_get_endpoints(dev,intf);\r\nret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf);\r\nif (ret < 0) {\r\nnetdev_dbg(dev->net, "Failed to read MAC address: %d\n", ret);\r\nreturn ret;\r\n}\r\nasix_set_netdev_dev_addr(dev, buf);\r\ndev->mii.dev = dev->net;\r\ndev->mii.mdio_read = asix_mdio_read;\r\ndev->mii.mdio_write = asix_mdio_write;\r\ndev->mii.phy_id_mask = 0x1f;\r\ndev->mii.reg_num_mask = 0xff;\r\ndev->mii.supports_gmii = 1;\r\ndev->mii.phy_id = asix_get_phy_addr(dev);\r\ndev->net->netdev_ops = &ax88178_netdev_ops;\r\ndev->net->ethtool_ops = &ax88178_ethtool_ops;\r\nasix_sw_reset(dev, 0);\r\nmsleep(150);\r\nasix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD);\r\nmsleep(150);\r\nif (dev->driver_info->flags & FLAG_FRAMING_AX) {\r\ndev->rx_urb_size = 2048;\r\n}\r\ndev->driver_priv = kzalloc(sizeof(struct asix_common_private), GFP_KERNEL);\r\nif (!dev->driver_priv)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
