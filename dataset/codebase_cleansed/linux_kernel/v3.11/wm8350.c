static inline int wm8350_out1_ramp_step(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350_output *out1 = &wm8350_data->out1;\r\nstruct wm8350 *wm8350 = wm8350_data->wm8350;\r\nint left_complete = 0, right_complete = 0;\r\nu16 reg, val;\r\nreg = wm8350_reg_read(wm8350, WM8350_LOUT1_VOLUME);\r\nval = (reg & WM8350_OUT1L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\r\nif (out1->ramp == WM8350_RAMP_UP) {\r\nif (val < out1->left_vol) {\r\nval++;\r\nreg &= ~WM8350_OUT1L_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_LOUT1_VOLUME,\r\nreg | (val << WM8350_OUT1L_VOL_SHIFT));\r\n} else\r\nleft_complete = 1;\r\n} else if (out1->ramp == WM8350_RAMP_DOWN) {\r\nif (val > 0) {\r\nval--;\r\nreg &= ~WM8350_OUT1L_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_LOUT1_VOLUME,\r\nreg | (val << WM8350_OUT1L_VOL_SHIFT));\r\n} else\r\nleft_complete = 1;\r\n} else\r\nreturn 1;\r\nreg = wm8350_reg_read(wm8350, WM8350_ROUT1_VOLUME);\r\nval = (reg & WM8350_OUT1R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\r\nif (out1->ramp == WM8350_RAMP_UP) {\r\nif (val < out1->right_vol) {\r\nval++;\r\nreg &= ~WM8350_OUT1R_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_ROUT1_VOLUME,\r\nreg | (val << WM8350_OUT1R_VOL_SHIFT));\r\n} else\r\nright_complete = 1;\r\n} else if (out1->ramp == WM8350_RAMP_DOWN) {\r\nif (val > 0) {\r\nval--;\r\nreg &= ~WM8350_OUT1R_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_ROUT1_VOLUME,\r\nreg | (val << WM8350_OUT1R_VOL_SHIFT));\r\n} else\r\nright_complete = 1;\r\n}\r\nif (!left_complete || !right_complete)\r\nwm8350_set_bits(wm8350, WM8350_LOUT1_VOLUME, WM8350_OUT1_VU);\r\nreturn left_complete & right_complete;\r\n}\r\nstatic inline int wm8350_out2_ramp_step(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350_output *out2 = &wm8350_data->out2;\r\nstruct wm8350 *wm8350 = wm8350_data->wm8350;\r\nint left_complete = 0, right_complete = 0;\r\nu16 reg, val;\r\nreg = wm8350_reg_read(wm8350, WM8350_LOUT2_VOLUME);\r\nval = (reg & WM8350_OUT2L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\r\nif (out2->ramp == WM8350_RAMP_UP) {\r\nif (val < out2->left_vol) {\r\nval++;\r\nreg &= ~WM8350_OUT2L_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_LOUT2_VOLUME,\r\nreg | (val << WM8350_OUT1L_VOL_SHIFT));\r\n} else\r\nleft_complete = 1;\r\n} else if (out2->ramp == WM8350_RAMP_DOWN) {\r\nif (val > 0) {\r\nval--;\r\nreg &= ~WM8350_OUT2L_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_LOUT2_VOLUME,\r\nreg | (val << WM8350_OUT1L_VOL_SHIFT));\r\n} else\r\nleft_complete = 1;\r\n} else\r\nreturn 1;\r\nreg = wm8350_reg_read(wm8350, WM8350_ROUT2_VOLUME);\r\nval = (reg & WM8350_OUT2R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\r\nif (out2->ramp == WM8350_RAMP_UP) {\r\nif (val < out2->right_vol) {\r\nval++;\r\nreg &= ~WM8350_OUT2R_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_ROUT2_VOLUME,\r\nreg | (val << WM8350_OUT1R_VOL_SHIFT));\r\n} else\r\nright_complete = 1;\r\n} else if (out2->ramp == WM8350_RAMP_DOWN) {\r\nif (val > 0) {\r\nval--;\r\nreg &= ~WM8350_OUT2R_VOL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_ROUT2_VOLUME,\r\nreg | (val << WM8350_OUT1R_VOL_SHIFT));\r\n} else\r\nright_complete = 1;\r\n}\r\nif (!left_complete || !right_complete)\r\nwm8350_set_bits(wm8350, WM8350_LOUT2_VOLUME, WM8350_OUT2_VU);\r\nreturn left_complete & right_complete;\r\n}\r\nstatic void wm8350_pga_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_dapm_context *dapm =\r\ncontainer_of(work, struct snd_soc_dapm_context, delayed_work.work);\r\nstruct snd_soc_codec *codec = dapm->codec;\r\nstruct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350_output *out1 = &wm8350_data->out1,\r\n*out2 = &wm8350_data->out2;\r\nint i, out1_complete, out2_complete;\r\nif (out1->ramp == WM8350_RAMP_NONE && out2->ramp == WM8350_RAMP_NONE)\r\nreturn;\r\nfor (i = 0; i <= 63; i++) {\r\nout1_complete = 1, out2_complete = 1;\r\nif (out1->ramp != WM8350_RAMP_NONE)\r\nout1_complete = wm8350_out1_ramp_step(codec);\r\nif (out2->ramp != WM8350_RAMP_NONE)\r\nout2_complete = wm8350_out2_ramp_step(codec);\r\nif (out1_complete && out2_complete)\r\nbreak;\r\nif (out1->ramp == WM8350_RAMP_UP ||\r\nout2->ramp == WM8350_RAMP_UP) {\r\nif (i >= WM8350_OUTn_0dB)\r\nschedule_timeout_interruptible(msecs_to_jiffies\r\n(2));\r\nelse\r\nschedule_timeout_interruptible(msecs_to_jiffies\r\n(1));\r\n} else\r\nudelay(50);\r\n}\r\nout1->ramp = WM8350_RAMP_NONE;\r\nout2->ramp = WM8350_RAMP_NONE;\r\n}\r\nstatic int pga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350_output *out;\r\nswitch (w->shift) {\r\ncase 0:\r\ncase 1:\r\nout = &wm8350_data->out1;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nout = &wm8350_data->out2;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -1;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nout->ramp = WM8350_RAMP_UP;\r\nout->active = 1;\r\nschedule_delayed_work(&codec->dapm.delayed_work,\r\nmsecs_to_jiffies(1));\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nout->ramp = WM8350_RAMP_DOWN;\r\nout->active = 0;\r\nschedule_delayed_work(&codec->dapm.delayed_work,\r\nmsecs_to_jiffies(1));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_put_volsw_2r_vu(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8350_data *wm8350_priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350_output *out = NULL;\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint ret;\r\nunsigned int reg = mc->reg;\r\nu16 val;\r\nswitch (reg) {\r\ncase WM8350_LOUT1_VOLUME:\r\nout = &wm8350_priv->out1;\r\nbreak;\r\ncase WM8350_LOUT2_VOLUME:\r\nout = &wm8350_priv->out2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (out) {\r\nout->left_vol = ucontrol->value.integer.value[0];\r\nout->right_vol = ucontrol->value.integer.value[1];\r\nif (!out->active)\r\nreturn 1;\r\n}\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret < 0)\r\nreturn ret;\r\nval = snd_soc_read(codec, reg);\r\nsnd_soc_write(codec, reg, val | WM8350_OUT1_VU);\r\nreturn 1;\r\n}\r\nstatic int wm8350_get_volsw_2r(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8350_data *wm8350_priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350_output *out1 = &wm8350_priv->out1;\r\nstruct wm8350_output *out2 = &wm8350_priv->out2;\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nswitch (reg) {\r\ncase WM8350_LOUT1_VOLUME:\r\nucontrol->value.integer.value[0] = out1->left_vol;\r\nucontrol->value.integer.value[1] = out1->right_vol;\r\nreturn 0;\r\ncase WM8350_LOUT2_VOLUME:\r\nucontrol->value.integer.value[0] = out2->left_vol;\r\nucontrol->value.integer.value[1] = out2->right_vol;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn snd_soc_get_volsw(kcontrol, ucontrol);\r\n}\r\nstatic int wm8350_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = wm8350_data->wm8350;\r\nu16 fll_4;\r\nswitch (clk_id) {\r\ncase WM8350_MCLK_SEL_MCLK:\r\nwm8350_clear_bits(wm8350, WM8350_CLOCK_CONTROL_1,\r\nWM8350_MCLK_SEL);\r\nbreak;\r\ncase WM8350_MCLK_SEL_PLL_MCLK:\r\ncase WM8350_MCLK_SEL_PLL_DAC:\r\ncase WM8350_MCLK_SEL_PLL_ADC:\r\ncase WM8350_MCLK_SEL_PLL_32K:\r\nwm8350_set_bits(wm8350, WM8350_CLOCK_CONTROL_1,\r\nWM8350_MCLK_SEL);\r\nfll_4 = snd_soc_read(codec, WM8350_FLL_CONTROL_4) &\r\n~WM8350_FLL_CLK_SRC_MASK;\r\nsnd_soc_write(codec, WM8350_FLL_CONTROL_4, fll_4 | clk_id);\r\nbreak;\r\n}\r\nif (dir == SND_SOC_CLOCK_OUT)\r\nwm8350_set_bits(wm8350, WM8350_CLOCK_CONTROL_2,\r\nWM8350_MCLK_DIR);\r\nelse\r\nwm8350_clear_bits(wm8350, WM8350_CLOCK_CONTROL_2,\r\nWM8350_MCLK_DIR);\r\nreturn 0;\r\n}\r\nstatic int wm8350_set_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 val;\r\nswitch (div_id) {\r\ncase WM8350_ADC_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_ADC_DIVIDER) &\r\n~WM8350_ADC_CLKDIV_MASK;\r\nsnd_soc_write(codec, WM8350_ADC_DIVIDER, val | div);\r\nbreak;\r\ncase WM8350_DAC_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_DAC_CLOCK_CONTROL) &\r\n~WM8350_DAC_CLKDIV_MASK;\r\nsnd_soc_write(codec, WM8350_DAC_CLOCK_CONTROL, val | div);\r\nbreak;\r\ncase WM8350_BCLK_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_CLOCK_CONTROL_1) &\r\n~WM8350_BCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8350_CLOCK_CONTROL_1, val | div);\r\nbreak;\r\ncase WM8350_OPCLK_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_CLOCK_CONTROL_1) &\r\n~WM8350_OPCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8350_CLOCK_CONTROL_1, val | div);\r\nbreak;\r\ncase WM8350_SYS_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_CLOCK_CONTROL_1) &\r\n~WM8350_MCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8350_CLOCK_CONTROL_1, val | div);\r\nbreak;\r\ncase WM8350_DACLR_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_DAC_LR_RATE) &\r\n~WM8350_DACLRC_RATE_MASK;\r\nsnd_soc_write(codec, WM8350_DAC_LR_RATE, val | div);\r\nbreak;\r\ncase WM8350_ADCLR_CLKDIV:\r\nval = snd_soc_read(codec, WM8350_ADC_LR_RATE) &\r\n~WM8350_ADCLRC_RATE_MASK;\r\nsnd_soc_write(codec, WM8350_ADC_LR_RATE, val | div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = snd_soc_read(codec, WM8350_AI_FORMATING) &\r\n~(WM8350_AIF_BCLK_INV | WM8350_AIF_LRCLK_INV | WM8350_AIF_FMT_MASK);\r\nu16 master = snd_soc_read(codec, WM8350_AI_DAC_CONTROL) &\r\n~WM8350_BCLK_MSTR;\r\nu16 dac_lrc = snd_soc_read(codec, WM8350_DAC_LR_RATE) &\r\n~WM8350_DACLRC_ENA;\r\nu16 adc_lrc = snd_soc_read(codec, WM8350_ADC_LR_RATE) &\r\n~WM8350_ADCLRC_ENA;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster |= WM8350_BCLK_MSTR;\r\ndac_lrc |= WM8350_DACLRC_ENA;\r\nadc_lrc |= WM8350_ADCLRC_ENA;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x2 << 8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x1 << 8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= 0x3 << 8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= 0x3 << 8 | WM8350_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= WM8350_AIF_LRCLK_INV | WM8350_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= WM8350_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= WM8350_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8350_AI_FORMATING, iface);\r\nsnd_soc_write(codec, WM8350_AI_DAC_CONTROL, master);\r\nsnd_soc_write(codec, WM8350_DAC_LR_RATE, dac_lrc);\r\nsnd_soc_write(codec, WM8350_ADC_LR_RATE, adc_lrc);\r\nreturn 0;\r\n}\r\nstatic int wm8350_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *codec_dai)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8350_data *wm8350_data = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = wm8350_data->wm8350;\r\nu16 iface = snd_soc_read(codec, WM8350_AI_FORMATING) &\r\n~WM8350_AIF_WL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface |= 0x1 << 10;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface |= 0x2 << 10;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\niface |= 0x3 << 10;\r\nbreak;\r\n}\r\nsnd_soc_write(codec, WM8350_AI_FORMATING, iface);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (params_rate(params) < 24000)\r\nwm8350_set_bits(wm8350, WM8350_DAC_MUTE_VOLUME,\r\nWM8350_DAC_SB_FILT);\r\nelse\r\nwm8350_clear_bits(wm8350, WM8350_DAC_MUTE_VOLUME,\r\nWM8350_DAC_SB_FILT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val;\r\nif (mute)\r\nval = WM8350_DAC_MUTE_ENA;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, WM8350_DAC_MUTE, WM8350_DAC_MUTE_ENA, val);\r\nreturn 0;\r\n}\r\nstatic inline int fll_factors(struct _fll_div *fll_div, unsigned int input,\r\nunsigned int output)\r\n{\r\nu64 Kpart;\r\nunsigned int t1, t2, K, Nmod;\r\nif (output >= 2815250 && output <= 3125000)\r\nfll_div->div = 0x4;\r\nelse if (output >= 5625000 && output <= 6250000)\r\nfll_div->div = 0x3;\r\nelse if (output >= 11250000 && output <= 12500000)\r\nfll_div->div = 0x2;\r\nelse if (output >= 22500000 && output <= 25000000)\r\nfll_div->div = 0x1;\r\nelse {\r\nprintk(KERN_ERR "wm8350: fll freq %d out of range\n", output);\r\nreturn -EINVAL;\r\n}\r\nif (input > 48000)\r\nfll_div->ratio = 1;\r\nelse\r\nfll_div->ratio = 8;\r\nt1 = output * (1 << (fll_div->div + 1));\r\nt2 = input * fll_div->ratio;\r\nfll_div->n = t1 / t2;\r\nNmod = t1 % t2;\r\nif (Nmod) {\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, t2);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\nfll_div->k = K;\r\n} else\r\nfll_div->k = 0;\r\nreturn 0;\r\n}\r\nstatic int wm8350_set_fll(struct snd_soc_dai *codec_dai,\r\nint pll_id, int source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8350_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\nstruct _fll_div fll_div;\r\nint ret = 0;\r\nu16 fll_1, fll_4;\r\nif (freq_in == priv->fll_freq_in && freq_out == priv->fll_freq_out)\r\nreturn 0;\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_4,\r\nWM8350_FLL_ENA | WM8350_FLL_OSC_ENA);\r\nif (freq_out == 0 || freq_in == 0)\r\nreturn ret;\r\nret = fll_factors(&fll_div, freq_in, freq_out);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(wm8350->dev,\r\n"FLL in %u FLL out %u N 0x%x K 0x%x div %d ratio %d",\r\nfreq_in, freq_out, fll_div.n, fll_div.k, fll_div.div,\r\nfll_div.ratio);\r\nfll_1 = snd_soc_read(codec, WM8350_FLL_CONTROL_1) &\r\n~(WM8350_FLL_OUTDIV_MASK | WM8350_FLL_RSP_RATE_MASK | 0xc000);\r\nsnd_soc_write(codec, WM8350_FLL_CONTROL_1,\r\nfll_1 | (fll_div.div << 8) | 0x50);\r\nsnd_soc_write(codec, WM8350_FLL_CONTROL_2,\r\n(fll_div.ratio << 11) | (fll_div.\r\nn & WM8350_FLL_N_MASK));\r\nsnd_soc_write(codec, WM8350_FLL_CONTROL_3, fll_div.k);\r\nfll_4 = snd_soc_read(codec, WM8350_FLL_CONTROL_4) &\r\n~(WM8350_FLL_FRAC | WM8350_FLL_SLOW_LOCK_REF);\r\nsnd_soc_write(codec, WM8350_FLL_CONTROL_4,\r\nfll_4 | (fll_div.k ? WM8350_FLL_FRAC : 0) |\r\n(fll_div.ratio == 8 ? WM8350_FLL_SLOW_LOCK_REF : 0));\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_FLL_OSC_ENA);\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_FLL_ENA);\r\npriv->fll_freq_out = freq_out;\r\npriv->fll_freq_in = freq_in;\r\nreturn 0;\r\n}\r\nstatic int wm8350_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8350_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\nstruct wm8350_audio_platform_data *platform =\r\nwm8350->codec.platform_data;\r\nu16 pm1;\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\npm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\r\n~(WM8350_VMID_MASK | WM8350_CODEC_ISEL_MASK);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\r\npm1 | WM8350_VMID_50K |\r\nplatform->codec_current_on << 14);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\npm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1);\r\npm1 &= ~WM8350_VMID_MASK;\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\r\npm1 | WM8350_VMID_50K);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies),\r\npriv->supplies);\r\nif (ret != 0)\r\nreturn ret;\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_4,\r\nWM8350_SYSCLK_ENA);\r\nwm8350_set_bits(wm8350, WM8350_DAC_MUTE,\r\nWM8350_DAC_MUTE_ENA);\r\nwm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\r\nplatform->dis_out1 |\r\n(platform->dis_out2 << 2) |\r\n(platform->dis_out3 << 4) |\r\n(platform->dis_out4 << 6));\r\nschedule_timeout_interruptible(msecs_to_jiffies\r\n(platform->\r\ncap_discharge_msecs));\r\nwm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\r\n(platform->vmid_s_curve << 8));\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\r\n(platform->\r\ncodec_current_charge << 14) |\r\nWM8350_VMID_5K | WM8350_VMIDEN |\r\nWM8350_VBUFEN);\r\nschedule_timeout_interruptible(msecs_to_jiffies\r\n(platform->\r\nvmid_charge_msecs));\r\npm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\r\n~(WM8350_VMID_MASK | WM8350_CODEC_ISEL_MASK);\r\npm1 |= WM8350_VMID_300K |\r\n(platform->codec_current_standby << 14);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\r\npm1);\r\npm1 |= WM8350_BIASEN;\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);\r\nwm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL, 0);\r\n} else {\r\npm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\r\n~(WM8350_VMID_MASK | WM8350_CODEC_ISEL_MASK);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\r\npm1 | WM8350_VMID_300K |\r\n(platform->\r\ncodec_current_standby << 14));\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nwm8350_set_bits(wm8350, WM8350_DAC_MUTE, WM8350_DAC_MUTE_ENA);\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_3,\r\nWM8350_OUT1L_ENA | WM8350_OUT1R_ENA |\r\nWM8350_OUT2L_ENA | WM8350_OUT2R_ENA);\r\nwm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\r\n(platform->vmid_s_curve << 8));\r\npm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\r\n~WM8350_VMIDEN;\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);\r\nschedule_timeout_interruptible(msecs_to_jiffies\r\n(platform->\r\nvmid_discharge_msecs));\r\nwm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\r\n(platform->vmid_s_curve << 8) |\r\nplatform->dis_out1 |\r\n(platform->dis_out2 << 2) |\r\n(platform->dis_out3 << 4) |\r\n(platform->dis_out4 << 6));\r\npm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\r\n~(WM8350_VBUFEN | WM8350_VMID_MASK);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\r\npm1 | WM8350_OUTPUT_DRAIN_EN);\r\nschedule_timeout_interruptible(msecs_to_jiffies\r\n(platform->drain_msecs));\r\npm1 &= ~WM8350_BIASEN;\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);\r\nwm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL, 0);\r\nwm8350_clear_bits(wm8350, WM8350_LOUT1_VOLUME,\r\nWM8350_OUT1L_ENA);\r\nwm8350_clear_bits(wm8350, WM8350_ROUT1_VOLUME,\r\nWM8350_OUT1R_ENA);\r\nwm8350_clear_bits(wm8350, WM8350_LOUT2_VOLUME,\r\nWM8350_OUT2L_ENA);\r\nwm8350_clear_bits(wm8350, WM8350_ROUT2_VOLUME,\r\nWM8350_OUT2R_ENA);\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_4,\r\nWM8350_SYSCLK_ENA);\r\nregulator_bulk_disable(ARRAY_SIZE(priv->supplies),\r\npriv->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8350_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8350_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8350_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8350_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic void wm8350_hp_work(struct wm8350_data *priv,\r\nstruct wm8350_jack_data *jack,\r\nu16 mask)\r\n{\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\nu16 reg;\r\nint report;\r\nreg = wm8350_reg_read(wm8350, WM8350_JACK_PIN_STATUS);\r\nif (reg & mask)\r\nreport = jack->report;\r\nelse\r\nreport = 0;\r\nsnd_soc_jack_report(jack->jack, report, jack->report);\r\n}\r\nstatic void wm8350_hpl_work(struct work_struct *work)\r\n{\r\nstruct wm8350_data *priv =\r\ncontainer_of(work, struct wm8350_data, hpl.work.work);\r\nwm8350_hp_work(priv, &priv->hpl, WM8350_JACK_L_LVL);\r\n}\r\nstatic void wm8350_hpr_work(struct work_struct *work)\r\n{\r\nstruct wm8350_data *priv =\r\ncontainer_of(work, struct wm8350_data, hpr.work.work);\r\nwm8350_hp_work(priv, &priv->hpr, WM8350_JACK_R_LVL);\r\n}\r\nstatic irqreturn_t wm8350_hpl_jack_handler(int irq, void *data)\r\n{\r\nstruct wm8350_data *priv = data;\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\r\ntrace_snd_soc_jack_irq("WM8350 HPL");\r\n#endif\r\nif (device_may_wakeup(wm8350->dev))\r\npm_wakeup_event(wm8350->dev, 250);\r\nschedule_delayed_work(&priv->hpl.work, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm8350_hpr_jack_handler(int irq, void *data)\r\n{\r\nstruct wm8350_data *priv = data;\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\r\ntrace_snd_soc_jack_irq("WM8350 HPR");\r\n#endif\r\nif (device_may_wakeup(wm8350->dev))\r\npm_wakeup_event(wm8350->dev, 250);\r\nschedule_delayed_work(&priv->hpr.work, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nint wm8350_hp_jack_detect(struct snd_soc_codec *codec, enum wm8350_jack which,\r\nstruct snd_soc_jack *jack, int report)\r\n{\r\nstruct wm8350_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\nint irq;\r\nint ena;\r\nswitch (which) {\r\ncase WM8350_JDL:\r\npriv->hpl.jack = jack;\r\npriv->hpl.report = report;\r\nirq = WM8350_IRQ_CODEC_JCK_DET_L;\r\nena = WM8350_JDL_ENA;\r\nbreak;\r\ncase WM8350_JDR:\r\npriv->hpr.jack = jack;\r\npriv->hpr.report = report;\r\nirq = WM8350_IRQ_CODEC_JCK_DET_R;\r\nena = WM8350_JDR_ENA;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (report) {\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_TOCLK_ENA);\r\nwm8350_set_bits(wm8350, WM8350_JACK_DETECT, ena);\r\n} else {\r\nwm8350_clear_bits(wm8350, WM8350_JACK_DETECT, ena);\r\n}\r\nswitch (which) {\r\ncase WM8350_JDL:\r\nwm8350_hpl_jack_handler(0, priv);\r\nbreak;\r\ncase WM8350_JDR:\r\nwm8350_hpr_jack_handler(0, priv);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm8350_mic_handler(int irq, void *data)\r\n{\r\nstruct wm8350_data *priv = data;\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\nu16 reg;\r\nint report = 0;\r\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\r\ntrace_snd_soc_jack_irq("WM8350 mic");\r\n#endif\r\nreg = wm8350_reg_read(wm8350, WM8350_JACK_PIN_STATUS);\r\nif (reg & WM8350_JACK_MICSCD_LVL)\r\nreport |= priv->mic.short_report;\r\nif (reg & WM8350_JACK_MICSD_LVL)\r\nreport |= priv->mic.report;\r\nsnd_soc_jack_report(priv->mic.jack, report,\r\npriv->mic.report | priv->mic.short_report);\r\nreturn IRQ_HANDLED;\r\n}\r\nint wm8350_mic_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack,\r\nint detect_report, int short_report)\r\n{\r\nstruct wm8350_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = priv->wm8350;\r\npriv->mic.jack = jack;\r\npriv->mic.report = detect_report;\r\npriv->mic.short_report = short_report;\r\nif (detect_report || short_report) {\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_TOCLK_ENA);\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_1,\r\nWM8350_MIC_DET_ENA);\r\n} else {\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_1,\r\nWM8350_MIC_DET_ENA);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_platdata(codec->dev);\r\nstruct wm8350_data *priv;\r\nstruct wm8350_output *out1;\r\nstruct wm8350_output *out2;\r\nint ret, i;\r\nif (wm8350->codec.platform_data == NULL) {\r\ndev_err(codec->dev, "No audio platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(codec->dev, sizeof(struct wm8350_data),\r\nGFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\nsnd_soc_codec_set_drvdata(codec, priv);\r\npriv->wm8350 = wm8350;\r\nfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\r\npriv->supplies[i].supply = supply_names[i];\r\nret = devm_regulator_bulk_get(wm8350->dev, ARRAY_SIZE(priv->supplies),\r\npriv->supplies);\r\nif (ret != 0)\r\nreturn ret;\r\ncodec->control_data = wm8350->regmap;\r\nsnd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);\r\nINIT_DELAYED_WORK(&codec->dapm.delayed_work, wm8350_pga_work);\r\nINIT_DELAYED_WORK(&priv->hpl.work, wm8350_hpl_work);\r\nINIT_DELAYED_WORK(&priv->hpr.work, wm8350_hpr_work);\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);\r\nsnd_soc_write(codec, WM8350_SECURITY, 0xa7);\r\nsnd_soc_write(codec, 0xde, 0x13);\r\nsnd_soc_write(codec, WM8350_SECURITY, 0);\r\nout1 = &priv->out1;\r\nout2 = &priv->out2;\r\nout1->left_vol = (wm8350_reg_read(wm8350, WM8350_LOUT1_VOLUME) &\r\nWM8350_OUT1L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\r\nout1->right_vol = (wm8350_reg_read(wm8350, WM8350_ROUT1_VOLUME) &\r\nWM8350_OUT1R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\r\nout2->left_vol = (wm8350_reg_read(wm8350, WM8350_LOUT2_VOLUME) &\r\nWM8350_OUT2L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\r\nout2->right_vol = (wm8350_reg_read(wm8350, WM8350_ROUT2_VOLUME) &\r\nWM8350_OUT2R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\r\nwm8350_reg_write(wm8350, WM8350_LOUT1_VOLUME, 0);\r\nwm8350_reg_write(wm8350, WM8350_ROUT1_VOLUME, 0);\r\nwm8350_reg_write(wm8350, WM8350_LOUT2_VOLUME, 0);\r\nwm8350_reg_write(wm8350, WM8350_ROUT2_VOLUME, 0);\r\nwm8350_set_bits(wm8350, WM8350_LOUT1_VOLUME,\r\nWM8350_OUT1_VU | WM8350_OUT1L_MUTE);\r\nwm8350_set_bits(wm8350, WM8350_LOUT2_VOLUME,\r\nWM8350_OUT2_VU | WM8350_OUT2L_MUTE);\r\nwm8350_set_bits(wm8350, WM8350_ROUT1_VOLUME,\r\nWM8350_OUT1_VU | WM8350_OUT1R_MUTE);\r\nwm8350_set_bits(wm8350, WM8350_ROUT2_VOLUME,\r\nWM8350_OUT2_VU | WM8350_OUT2R_MUTE);\r\nwm8350_clear_bits(wm8350, WM8350_AI_FORMATING, WM8350_AIF_TRI);\r\nwm8350_clear_bits(wm8350, WM8350_ADC_DAC_COMP,\r\nWM8350_DAC_COMP | WM8350_LOOPBACK);\r\nwm8350_clear_bits(wm8350, WM8350_JACK_DETECT,\r\nWM8350_JDL_ENA | WM8350_JDR_ENA);\r\nwm8350_register_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_L,\r\nwm8350_hpl_jack_handler, 0, "Left jack detect",\r\npriv);\r\nwm8350_register_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_R,\r\nwm8350_hpr_jack_handler, 0, "Right jack detect",\r\npriv);\r\nwm8350_register_irq(wm8350, WM8350_IRQ_CODEC_MICSCD,\r\nwm8350_mic_handler, 0, "Microphone short", priv);\r\nwm8350_register_irq(wm8350, WM8350_IRQ_CODEC_MICD,\r\nwm8350_mic_handler, 0, "Microphone detect", priv);\r\nwm8350_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8350_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8350_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8350 *wm8350 = dev_get_platdata(codec->dev);\r\nwm8350_clear_bits(wm8350, WM8350_JACK_DETECT,\r\nWM8350_JDL_ENA | WM8350_JDR_ENA);\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_TOCLK_ENA);\r\nwm8350_free_irq(wm8350, WM8350_IRQ_CODEC_MICD, priv);\r\nwm8350_free_irq(wm8350, WM8350_IRQ_CODEC_MICSCD, priv);\r\nwm8350_free_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_L, priv);\r\nwm8350_free_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_R, priv);\r\npriv->hpl.jack = NULL;\r\npriv->hpr.jack = NULL;\r\npriv->mic.jack = NULL;\r\ncancel_delayed_work_sync(&priv->hpl.work);\r\ncancel_delayed_work_sync(&priv->hpr.work);\r\nflush_delayed_work(&codec->dapm.delayed_work);\r\nwm8350_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);\r\nreturn 0;\r\n}\r\nstatic int wm8350_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm8350,\r\n&wm8350_dai, 1);\r\n}\r\nstatic int wm8350_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
