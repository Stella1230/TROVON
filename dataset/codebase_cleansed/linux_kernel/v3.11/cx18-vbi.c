static void copy_vbi_data(struct cx18 *cx, int lines, u32 pts_stamp)\r\n{\r\nint line = 0;\r\nint i;\r\nu32 linemask[2] = { 0, 0 };\r\nunsigned short size;\r\nstatic const u8 mpeg_hdr_data[] = {\r\n0x00, 0x00, 0x01, 0xba,\r\n0x44, 0x00, 0x0c, 0x66, 0x24, 0x01,\r\n0x01, 0xd1, 0xd3,\r\n0xfa, 0xff, 0xff,\r\n0x00, 0x00, 0x01, 0xbd,\r\n0x00, 0x1a,\r\n0x84, 0x80, 0x07,\r\n0x21, 0x00, 0x5d, 0x63, 0xa7,\r\n0xff, 0xff\r\n};\r\nconst int sd = sizeof(mpeg_hdr_data);\r\nint idx = cx->vbi.frame % CX18_VBI_FRAMES;\r\nu8 *dst = &cx->vbi.sliced_mpeg_data[idx][0];\r\nfor (i = 0; i < lines; i++) {\r\nstruct v4l2_sliced_vbi_data *sdata = cx->vbi.sliced_data + i;\r\nint f, l;\r\nif (sdata->id == 0)\r\ncontinue;\r\nl = sdata->line - 6;\r\nf = sdata->field;\r\nif (f)\r\nl += 18;\r\nif (l < 32)\r\nlinemask[0] |= (1 << l);\r\nelse\r\nlinemask[1] |= (1 << (l - 32));\r\ndst[sd + 12 + line * 43] = cx18_service2vbi(sdata->id);\r\nmemcpy(dst + sd + 12 + line * 43 + 1, sdata->data, 42);\r\nline++;\r\n}\r\nmemcpy(dst, mpeg_hdr_data, sizeof(mpeg_hdr_data));\r\nif (line == 36) {\r\nmemcpy(dst + sd, "ITV0", 4);\r\nmemmove(dst + sd + 4, dst + sd + 12, line * 43);\r\nsize = 4 + ((43 * line + 3) & ~3);\r\n} else {\r\nmemcpy(dst + sd, "itv0", 4);\r\ncpu_to_le32s(&linemask[0]);\r\ncpu_to_le32s(&linemask[1]);\r\nmemcpy(dst + sd + 4, &linemask[0], 8);\r\nsize = 12 + ((43 * line + 3) & ~3);\r\n}\r\ndst[4+16] = (size + 10) >> 8;\r\ndst[5+16] = (size + 10) & 0xff;\r\ndst[9+16] = 0x21 | ((pts_stamp >> 29) & 0x6);\r\ndst[10+16] = (pts_stamp >> 22) & 0xff;\r\ndst[11+16] = 1 | ((pts_stamp >> 14) & 0xff);\r\ndst[12+16] = (pts_stamp >> 7) & 0xff;\r\ndst[13+16] = 1 | ((pts_stamp & 0x7f) << 1);\r\ncx->vbi.sliced_mpeg_size[idx] = sd + size;\r\n}\r\nstatic u32 compress_raw_buf(struct cx18 *cx, u8 *buf, u32 size, u32 hdr_size)\r\n{\r\nu32 line_size = vbi_active_samples;\r\nu32 lines = cx->vbi.count * 2;\r\nu8 *q = buf;\r\nu8 *p;\r\nint i;\r\nbuf += hdr_size;\r\nfor (i = 0; i < lines; i++) {\r\np = buf + i * line_size;\r\nif (p[0] != 0xff || p[1] || p[2] ||\r\n(p[3] != raw_vbi_sav_rp[0] &&\r\np[3] != raw_vbi_sav_rp[1]))\r\nbreak;\r\nif (i == lines - 1) {\r\nmemcpy(q, p + 4, line_size - 4 - hdr_size);\r\nq += line_size - 4 - hdr_size;\r\np += line_size - hdr_size - 1;\r\nmemset(q, (int) *p, hdr_size);\r\n} else {\r\nmemcpy(q, p + 4, line_size - 4);\r\nq += line_size - 4;\r\n}\r\n}\r\nreturn lines * (line_size - 4);\r\n}\r\nstatic u32 compress_sliced_buf(struct cx18 *cx, u8 *buf, u32 size,\r\nconst u32 hdr_size)\r\n{\r\nstruct v4l2_decode_vbi_line vbi;\r\nint i;\r\nu32 line = 0;\r\nu32 line_size = cx->is_60hz ? vbi_hblank_samples_60Hz\r\n: vbi_hblank_samples_50Hz;\r\nfor (i = hdr_size, buf += hdr_size; i < size; i++, buf++) {\r\nif (buf[0] == 0xff && !buf[1] && !buf[2] &&\r\n(buf[3] == sliced_vbi_eav_rp[0] ||\r\nbuf[3] == sliced_vbi_eav_rp[1]))\r\nbreak;\r\n}\r\nsize -= (i - hdr_size);\r\nif (size < line_size)\r\nreturn line;\r\nfor (i = 0; i < size / line_size; i++) {\r\nu8 *p = buf + i * line_size;\r\nif (p[0] != 0xff || p[1] || p[2] ||\r\n(p[3] != sliced_vbi_eav_rp[0] &&\r\np[3] != sliced_vbi_eav_rp[1]))\r\ncontinue;\r\nvbi.p = p + 4;\r\nv4l2_subdev_call(cx->sd_av, vbi, decode_vbi_line, &vbi);\r\nif (vbi.type) {\r\ncx->vbi.sliced_data[line].id = vbi.type;\r\ncx->vbi.sliced_data[line].field = vbi.is_second_field;\r\ncx->vbi.sliced_data[line].line = vbi.line;\r\nmemcpy(cx->vbi.sliced_data[line].data, vbi.p, 42);\r\nline++;\r\n}\r\n}\r\nreturn line;\r\n}\r\nstatic void _cx18_process_vbi_data(struct cx18 *cx, struct cx18_buffer *buf)\r\n{\r\nstruct vbi_data_hdr {\r\n__be32 magic;\r\n__be32 unknown;\r\n__be32 pts;\r\n} *hdr = (struct vbi_data_hdr *) buf->buf;\r\nu8 *p = (u8 *) buf->buf;\r\nu32 size = buf->bytesused;\r\nu32 pts;\r\nint lines;\r\ncx18_buf_swap(buf);\r\nif (cx18_raw_vbi(cx)) {\r\nsize = buf->bytesused =\r\ncompress_raw_buf(cx, p, size, sizeof(struct vbi_data_hdr));\r\np += size - 4;\r\nmemcpy(p, &cx->vbi.frame, 4);\r\ncx->vbi.frame++;\r\nreturn;\r\n}\r\npts = (be32_to_cpu(hdr->magic) == 0x3fffffff) ? be32_to_cpu(hdr->pts)\r\n: 0;\r\nlines = compress_sliced_buf(cx, p, size, sizeof(struct vbi_data_hdr));\r\nif (lines == 0) {\r\ncx->vbi.sliced_data[0].id = 0;\r\ncx->vbi.sliced_data[0].line = 0;\r\ncx->vbi.sliced_data[0].field = 0;\r\nlines = 1;\r\n}\r\nbuf->bytesused = size = lines * sizeof(cx->vbi.sliced_data[0]);\r\nmemcpy(p, &cx->vbi.sliced_data[0], size);\r\nif (cx->vbi.insert_mpeg)\r\ncopy_vbi_data(cx, lines, pts);\r\ncx->vbi.frame++;\r\n}\r\nvoid cx18_process_vbi_data(struct cx18 *cx, struct cx18_mdl *mdl,\r\nint streamtype)\r\n{\r\nstruct cx18_buffer *buf;\r\nu32 orig_used;\r\nif (streamtype != CX18_ENC_STREAM_TYPE_VBI)\r\nreturn;\r\nlist_for_each_entry(buf, &mdl->buf_list, list) {\r\norig_used = buf->bytesused;\r\nif (orig_used == 0)\r\nbreak;\r\n_cx18_process_vbi_data(cx, buf);\r\nmdl->bytesused -= (orig_used - buf->bytesused);\r\n}\r\n}
