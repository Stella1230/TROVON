static long\r\nsal_ioif_init(u64 *result)\r\n{\r\nstruct ia64_sal_retval isrv = {0,0,0,0};\r\nSAL_CALL_NOLOCK(isrv,\r\nSN_SAL_IOIF_INIT, 0, 0, 0, 0, 0, 0, 0);\r\n*result = isrv.v0;\r\nreturn isrv.status;\r\n}\r\nstatic acpi_status __init\r\nsn_acpi_hubdev_init(acpi_handle handle, u32 depth, void *context, void **ret)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nu64 addr;\r\nstruct hubdev_info *hubdev;\r\nstruct hubdev_info *hubdev_ptr;\r\nint i;\r\nu64 nasid;\r\nstruct acpi_resource *resource;\r\nacpi_status status;\r\nstruct acpi_resource_vendor_typed *vendor;\r\nextern void sn_common_hubdev_init(struct hubdev_info *);\r\nstatus = acpi_get_vendor_resource(handle, METHOD_NAME__CRS,\r\n&sn_uuid, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR\r\n"sn_acpi_hubdev_init: acpi_get_vendor_resource() "\r\n"(0x%x) failed for: %s\n", status,\r\n(char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn AE_OK;\r\n}\r\nresource = buffer.pointer;\r\nvendor = &resource->data.vendor_typed;\r\nif ((vendor->byte_length - sizeof(struct acpi_vendor_uuid)) !=\r\nsizeof(struct hubdev_info *)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR\r\n"sn_acpi_hubdev_init: Invalid vendor data length: "\r\n"%d for: %s\n",\r\nvendor->byte_length, (char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\ngoto exit;\r\n}\r\nmemcpy(&addr, vendor->byte_data, sizeof(struct hubdev_info *));\r\nhubdev_ptr = __va((struct hubdev_info *) addr);\r\nnasid = hubdev_ptr->hdi_nasid;\r\ni = nasid_to_cnodeid(nasid);\r\nhubdev = (struct hubdev_info *)(NODEPDA(i)->pdinfo);\r\n*hubdev = *hubdev_ptr;\r\nsn_common_hubdev_init(hubdev);\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn AE_OK;\r\n}\r\nstatic struct pcibus_bussoft *\r\nsn_get_bussoft_ptr(struct pci_bus *bus)\r\n{\r\nu64 addr;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_handle handle;\r\nstruct pcibus_bussoft *prom_bussoft_ptr;\r\nstruct acpi_resource *resource;\r\nacpi_status status;\r\nstruct acpi_resource_vendor_typed *vendor;\r\nhandle = PCI_CONTROLLER(bus)->acpi_handle;\r\nstatus = acpi_get_vendor_resource(handle, METHOD_NAME__CRS,\r\n&sn_uuid, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR "%s: "\r\n"acpi_get_vendor_resource() failed (0x%x) for: %s\n",\r\n__func__, status, (char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn NULL;\r\n}\r\nresource = buffer.pointer;\r\nvendor = &resource->data.vendor_typed;\r\nif ((vendor->byte_length - sizeof(struct acpi_vendor_uuid)) !=\r\nsizeof(struct pcibus_bussoft *)) {\r\nprintk(KERN_ERR\r\n"%s: Invalid vendor data length %d\n",\r\n__func__, vendor->byte_length);\r\nkfree(buffer.pointer);\r\nreturn NULL;\r\n}\r\nmemcpy(&addr, vendor->byte_data, sizeof(struct pcibus_bussoft *));\r\nprom_bussoft_ptr = __va((struct pcibus_bussoft *) addr);\r\nkfree(buffer.pointer);\r\nreturn prom_bussoft_ptr;\r\n}\r\nstatic int\r\nsn_extract_device_info(acpi_handle handle, struct pcidev_info **pcidev_info,\r\nstruct sn_irq_info **sn_irq_info)\r\n{\r\nu64 addr;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct sn_irq_info *irq_info, *irq_info_prom;\r\nstruct pcidev_info *pcidev_ptr, *pcidev_prom_ptr;\r\nstruct acpi_resource *resource;\r\nint ret = 0;\r\nacpi_status status;\r\nstruct acpi_resource_vendor_typed *vendor;\r\nstatus = acpi_get_vendor_resource(handle, METHOD_NAME__CRS,\r\n&sn_uuid, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR\r\n"%s: acpi_get_vendor_resource() failed (0x%x) for: %s\n",\r\n__func__, status, (char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn 1;\r\n}\r\nresource = buffer.pointer;\r\nvendor = &resource->data.vendor_typed;\r\nif ((vendor->byte_length - sizeof(struct acpi_vendor_uuid)) !=\r\nsizeof(struct pci_devdev_info *)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR\r\n"%s: Invalid vendor data length: %d for: %s\n",\r\n__func__, vendor->byte_length,\r\n(char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nret = 1;\r\ngoto exit;\r\n}\r\npcidev_ptr = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);\r\nif (!pcidev_ptr)\r\npanic("%s: Unable to alloc memory for pcidev_info", __func__);\r\nmemcpy(&addr, vendor->byte_data, sizeof(struct pcidev_info *));\r\npcidev_prom_ptr = __va(addr);\r\nmemcpy(pcidev_ptr, pcidev_prom_ptr, sizeof(struct pcidev_info));\r\nirq_info = kzalloc(sizeof(struct sn_irq_info), GFP_KERNEL);\r\nif (!irq_info)\r\npanic("%s: Unable to alloc memory for sn_irq_info", __func__);\r\nif (pcidev_ptr->pdi_sn_irq_info) {\r\nirq_info_prom = __va(pcidev_ptr->pdi_sn_irq_info);\r\nmemcpy(irq_info, irq_info_prom, sizeof(struct sn_irq_info));\r\n}\r\n*pcidev_info = pcidev_ptr;\r\n*sn_irq_info = irq_info;\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nget_host_devfn(acpi_handle device_handle, acpi_handle rootbus_handle)\r\n{\r\nunsigned long long adr;\r\nacpi_handle child;\r\nunsigned int devfn;\r\nint function;\r\nacpi_handle parent;\r\nint slot;\r\nacpi_status status;\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(device_handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nchild = device_handle;\r\nwhile (child) {\r\nstatus = acpi_get_parent(child, &parent);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR "%s: acpi_get_parent() failed "\r\n"(0x%x) for: %s\n", __func__, status,\r\n(char *)name_buffer.pointer);\r\npanic("%s: Unable to find host devfn\n", __func__);\r\n}\r\nif (parent == rootbus_handle)\r\nbreak;\r\nchild = parent;\r\n}\r\nif (!child) {\r\nprintk(KERN_ERR "%s: Unable to find root bus for: %s\n",\r\n__func__, (char *)name_buffer.pointer);\r\nBUG();\r\n}\r\nstatus = acpi_evaluate_integer(child, METHOD_NAME__ADR, NULL, &adr);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR "%s: Unable to get _ADR (0x%x) for: %s\n",\r\n__func__, status, (char *)name_buffer.pointer);\r\npanic("%s: Unable to find host devfn\n", __func__);\r\n}\r\nkfree(name_buffer.pointer);\r\nslot = (adr >> 16) & 0xffff;\r\nfunction = adr & 0xffff;\r\ndevfn = PCI_DEVFN(slot, function);\r\nreturn devfn;\r\n}\r\nstatic acpi_status\r\nfind_matching_device(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nunsigned long long bbn = -1;\r\nunsigned long long adr;\r\nacpi_handle parent = NULL;\r\nacpi_status status;\r\nunsigned int devfn;\r\nint function;\r\nint slot;\r\nstruct sn_pcidev_match *info = context;\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__ADR, NULL,\r\n&adr);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_get_parent(handle, &parent);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR\r\n"%s: acpi_get_parent() failed (0x%x) for: %s\n",\r\n__func__, status, (char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn AE_OK;\r\n}\r\nstatus = acpi_evaluate_integer(parent, METHOD_NAME__BBN,\r\nNULL, &bbn);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR\r\n"%s: Failed to find _BBN in parent of: %s\n",\r\n__func__, (char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn AE_OK;\r\n}\r\nslot = (adr >> 16) & 0xffff;\r\nfunction = adr & 0xffff;\r\ndevfn = PCI_DEVFN(slot, function);\r\nif ((info->devfn == devfn) && (info->bus == bbn)) {\r\ninfo->handle = handle;\r\nreturn 1;\r\n}\r\n}\r\nreturn AE_OK;\r\n}\r\nint\r\nsn_acpi_get_pcidev_info(struct pci_dev *dev, struct pcidev_info **pcidev_info,\r\nstruct sn_irq_info **sn_irq_info)\r\n{\r\nunsigned int host_devfn;\r\nstruct sn_pcidev_match pcidev_match;\r\nacpi_handle rootbus_handle;\r\nunsigned long long segment;\r\nacpi_status status;\r\nstruct acpi_buffer name_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nrootbus_handle = PCI_CONTROLLER(dev)->acpi_handle;\r\nstatus = acpi_evaluate_integer(rootbus_handle, METHOD_NAME__SEG, NULL,\r\n&segment);\r\nif (ACPI_SUCCESS(status)) {\r\nif (segment != pci_domain_nr(dev)) {\r\nacpi_get_name(rootbus_handle, ACPI_FULL_PATHNAME,\r\n&name_buffer);\r\nprintk(KERN_ERR\r\n"%s: Segment number mismatch, 0x%llx vs 0x%x for: %s\n",\r\n__func__, segment, pci_domain_nr(dev),\r\n(char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn 1;\r\n}\r\n} else {\r\nacpi_get_name(rootbus_handle, ACPI_FULL_PATHNAME, &name_buffer);\r\nprintk(KERN_ERR "%s: Unable to get __SEG from: %s\n",\r\n__func__, (char *)name_buffer.pointer);\r\nkfree(name_buffer.pointer);\r\nreturn 1;\r\n}\r\npcidev_match.bus = dev->bus->number;\r\npcidev_match.devfn = dev->devfn;\r\npcidev_match.handle = NULL;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, rootbus_handle, ACPI_UINT32_MAX,\r\nfind_matching_device, NULL, &pcidev_match, NULL);\r\nif (!pcidev_match.handle) {\r\nprintk(KERN_ERR\r\n"%s: Could not find matching ACPI device for %s.\n",\r\n__func__, pci_name(dev));\r\nreturn 1;\r\n}\r\nif (sn_extract_device_info(pcidev_match.handle, pcidev_info, sn_irq_info))\r\nreturn 1;\r\nhost_devfn = get_host_devfn(pcidev_match.handle, rootbus_handle);\r\n(*pcidev_info)->pdi_slot_host_handle =\r\n((unsigned long) pci_domain_nr(dev) << 40) |\r\nhost_devfn;\r\nreturn 0;\r\n}\r\nvoid\r\nsn_acpi_slot_fixup(struct pci_dev *dev)\r\n{\r\nvoid __iomem *addr;\r\nstruct pcidev_info *pcidev_info = NULL;\r\nstruct sn_irq_info *sn_irq_info = NULL;\r\nsize_t image_size, size;\r\nif (sn_acpi_get_pcidev_info(dev, &pcidev_info, &sn_irq_info)) {\r\npanic("%s: Failure obtaining pcidev_info for %s\n",\r\n__func__, pci_name(dev));\r\n}\r\nif (pcidev_info->pdi_pio_mapped_addr[PCI_ROM_RESOURCE]) {\r\nsize = pci_resource_len(dev, PCI_ROM_RESOURCE);\r\naddr = ioremap(pcidev_info->pdi_pio_mapped_addr[PCI_ROM_RESOURCE],\r\nsize);\r\nimage_size = pci_get_rom_size(dev, addr, size);\r\ndev->resource[PCI_ROM_RESOURCE].start = (unsigned long) addr;\r\ndev->resource[PCI_ROM_RESOURCE].end =\r\n(unsigned long) addr + image_size - 1;\r\ndev->resource[PCI_ROM_RESOURCE].flags |= IORESOURCE_ROM_BIOS_COPY;\r\n}\r\nsn_pci_fixup_slot(dev, pcidev_info, sn_irq_info);\r\n}\r\nvoid\r\nsn_acpi_bus_fixup(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *pci_dev = NULL;\r\nstruct pcibus_bussoft *prom_bussoft_ptr;\r\nif (!bus->parent) {\r\nprom_bussoft_ptr = sn_get_bussoft_ptr(bus);\r\nif (prom_bussoft_ptr == NULL) {\r\nprintk(KERN_ERR\r\n"%s: 0x%04x:0x%02x Unable to "\r\n"obtain prom_bussoft_ptr\n",\r\n__func__, pci_domain_nr(bus), bus->number);\r\nreturn;\r\n}\r\nsn_common_bus_fixup(bus, prom_bussoft_ptr);\r\n}\r\nlist_for_each_entry(pci_dev, &bus->devices, bus_list) {\r\nsn_acpi_slot_fixup(pci_dev);\r\n}\r\n}\r\nvoid __init\r\nsn_io_acpi_init(void)\r\n{\r\nu64 result;\r\nlong status;\r\nacpi_irq_model = ACPI_IRQ_MODEL_PLATFORM;\r\nacpi_get_devices("SGIHUB", sn_acpi_hubdev_init, NULL, NULL);\r\nacpi_get_devices("SGITIO", sn_acpi_hubdev_init, NULL, NULL);\r\nstatus = sal_ioif_init(&result);\r\nif (status || result)\r\npanic("sal_ioif_init failed: [%lx] %s\n",\r\nstatus, ia64_sal_strerror(status));\r\n}
