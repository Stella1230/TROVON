static void wm8995_update_class_w(struct snd_soc_codec *codec)\r\n{\r\nint enable = 1;\r\nint source = 0;\r\nint reg, reg_r;\r\nreg = snd_soc_read(codec, WM8995_DAC1_LEFT_MIXER_ROUTING);\r\nswitch (reg) {\r\ncase WM8995_AIF2DACL_TO_DAC1L:\r\ndev_dbg(codec->dev, "Class W source AIF2DAC\n");\r\nsource = 2 << WM8995_CP_DYN_SRC_SEL_SHIFT;\r\nbreak;\r\ncase WM8995_AIF1DAC2L_TO_DAC1L:\r\ndev_dbg(codec->dev, "Class W source AIF1DAC2\n");\r\nsource = 1 << WM8995_CP_DYN_SRC_SEL_SHIFT;\r\nbreak;\r\ncase WM8995_AIF1DAC1L_TO_DAC1L:\r\ndev_dbg(codec->dev, "Class W source AIF1DAC1\n");\r\nsource = 0 << WM8995_CP_DYN_SRC_SEL_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_dbg(codec->dev, "DAC mixer setting: %x\n", reg);\r\nenable = 0;\r\nbreak;\r\n}\r\nreg_r = snd_soc_read(codec, WM8995_DAC1_RIGHT_MIXER_ROUTING);\r\nif (reg_r != reg) {\r\ndev_dbg(codec->dev, "Left and right DAC mixers different\n");\r\nenable = 0;\r\n}\r\nif (enable) {\r\ndev_dbg(codec->dev, "Class W enabled\n");\r\nsnd_soc_update_bits(codec, WM8995_CLASS_W_1,\r\nWM8995_CP_DYN_PWR_MASK |\r\nWM8995_CP_DYN_SRC_SEL_MASK,\r\nsource | WM8995_CP_DYN_PWR);\r\n} else {\r\ndev_dbg(codec->dev, "Class W disabled\n");\r\nsnd_soc_update_bits(codec, WM8995_CLASS_W_1,\r\nWM8995_CP_DYN_PWR_MASK, 0);\r\n}\r\n}\r\nstatic int check_clk_sys(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nconst char *clk;\r\nreg = snd_soc_read(source->codec, WM8995_CLOCKING_1);\r\nif (reg & WM8995_SYSCLK_SRC)\r\nclk = "AIF2CLK";\r\nelse\r\nclk = "AIF1CLK";\r\nreturn !strcmp(source->name, clk);\r\n}\r\nstatic int wm8995_put_class_w(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *w = wlist->widgets[0];\r\nstruct snd_soc_codec *codec;\r\nint ret;\r\ncodec = w->codec;\r\nret = snd_soc_dapm_put_volsw(kcontrol, ucontrol);\r\nwm8995_update_class_w(codec);\r\nreturn ret;\r\n}\r\nstatic int hp_supply_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8995_priv *wm8995;\r\ncodec = w->codec;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, WM8995_POWER_MANAGEMENT_1,\r\nWM8995_HPOUT1L_ENA_MASK |\r\nWM8995_HPOUT1R_ENA_MASK,\r\nWM8995_HPOUT1L_ENA |\r\nWM8995_HPOUT1R_ENA);\r\nsnd_soc_update_bits(codec, WM8995_ANALOGUE_HP_1,\r\nWM8995_HPOUT1L_DLY_MASK |\r\nWM8995_HPOUT1R_DLY_MASK,\r\nWM8995_HPOUT1L_DLY |\r\nWM8995_HPOUT1R_DLY);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, WM8995_CHARGE_PUMP_1,\r\nWM8995_CP_ENA_MASK, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dc_servo_cmd(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int val, unsigned int mask)\r\n{\r\nint timeout = 10;\r\ndev_dbg(codec->dev, "%s: reg = %#x, val = %#x, mask = %#x\n",\r\n__func__, reg, val, mask);\r\nsnd_soc_write(codec, reg, val);\r\nwhile (timeout--) {\r\nmsleep(10);\r\nval = snd_soc_read(codec, WM8995_DC_SERVO_READBACK_0);\r\nif ((val & mask) == mask)\r\nreturn;\r\n}\r\ndev_err(codec->dev, "Timed out waiting for DC Servo\n");\r\n}\r\nstatic int hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec;\r\nunsigned int reg;\r\ncodec = w->codec;\r\nreg = snd_soc_read(codec, WM8995_ANALOGUE_HP_1);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, WM8995_CHARGE_PUMP_1,\r\nWM8995_CP_ENA_MASK, WM8995_CP_ENA);\r\nmsleep(5);\r\nsnd_soc_update_bits(codec, WM8995_POWER_MANAGEMENT_1,\r\nWM8995_HPOUT1L_ENA_MASK |\r\nWM8995_HPOUT1R_ENA_MASK,\r\nWM8995_HPOUT1L_ENA | WM8995_HPOUT1R_ENA);\r\nudelay(20);\r\nreg |= WM8995_HPOUT1L_DLY | WM8995_HPOUT1R_DLY;\r\nsnd_soc_write(codec, WM8995_ANALOGUE_HP_1, reg);\r\nsnd_soc_write(codec, WM8995_DC_SERVO_1, WM8995_DCS_ENA_CHAN_0 |\r\nWM8995_DCS_ENA_CHAN_1);\r\ndc_servo_cmd(codec, WM8995_DC_SERVO_2,\r\nWM8995_DCS_TRIG_STARTUP_0 |\r\nWM8995_DCS_TRIG_STARTUP_1,\r\nWM8995_DCS_TRIG_DAC_WR_0 |\r\nWM8995_DCS_TRIG_DAC_WR_1);\r\nreg |= WM8995_HPOUT1R_OUTP | WM8995_HPOUT1R_RMV_SHORT |\r\nWM8995_HPOUT1L_OUTP | WM8995_HPOUT1L_RMV_SHORT;\r\nsnd_soc_write(codec, WM8995_ANALOGUE_HP_1, reg);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, WM8995_ANALOGUE_HP_1,\r\nWM8995_HPOUT1L_OUTP_MASK |\r\nWM8995_HPOUT1R_OUTP_MASK |\r\nWM8995_HPOUT1L_RMV_SHORT_MASK |\r\nWM8995_HPOUT1R_RMV_SHORT_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8995_ANALOGUE_HP_1,\r\nWM8995_HPOUT1L_DLY_MASK |\r\nWM8995_HPOUT1R_DLY_MASK, 0);\r\nsnd_soc_write(codec, WM8995_DC_SERVO_1, 0);\r\nsnd_soc_update_bits(codec, WM8995_POWER_MANAGEMENT_1,\r\nWM8995_HPOUT1L_ENA_MASK |\r\nWM8995_HPOUT1R_ENA_MASK,\r\n0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int configure_aif_clock(struct snd_soc_codec *codec, int aif)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint rate;\r\nint reg1 = 0;\r\nint offset;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nif (aif)\r\noffset = 4;\r\nelse\r\noffset = 0;\r\nswitch (wm8995->sysclk[aif]) {\r\ncase WM8995_SYSCLK_MCLK1:\r\nrate = wm8995->mclk[0];\r\nbreak;\r\ncase WM8995_SYSCLK_MCLK2:\r\nreg1 |= 0x8;\r\nrate = wm8995->mclk[1];\r\nbreak;\r\ncase WM8995_SYSCLK_FLL1:\r\nreg1 |= 0x10;\r\nrate = wm8995->fll[0].out;\r\nbreak;\r\ncase WM8995_SYSCLK_FLL2:\r\nreg1 |= 0x18;\r\nrate = wm8995->fll[1].out;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rate >= 13500000) {\r\nrate /= 2;\r\nreg1 |= WM8995_AIF1CLK_DIV;\r\ndev_dbg(codec->dev, "Dividing AIF%d clock to %dHz\n",\r\naif + 1, rate);\r\n}\r\nwm8995->aifclk[aif] = rate;\r\nsnd_soc_update_bits(codec, WM8995_AIF1_CLOCKING_1 + offset,\r\nWM8995_AIF1CLK_SRC_MASK | WM8995_AIF1CLK_DIV_MASK,\r\nreg1);\r\nreturn 0;\r\n}\r\nstatic int configure_clock(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint change, new;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nconfigure_aif_clock(codec, 0);\r\nconfigure_aif_clock(codec, 1);\r\nif (wm8995->aifclk[0] == wm8995->aifclk[1])\r\nreturn 0;\r\nif (wm8995->aifclk[0] < wm8995->aifclk[1])\r\nnew = WM8995_SYSCLK_SRC;\r\nelse\r\nnew = 0;\r\nchange = snd_soc_update_bits(codec, WM8995_CLOCKING_1,\r\nWM8995_SYSCLK_SRC_MASK, new);\r\nif (!change)\r\nreturn 0;\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nreturn 0;\r\n}\r\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec;\r\ncodec = w->codec;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nreturn configure_clock(codec);\r\ncase SND_SOC_DAPM_POST_PMD:\r\nconfigure_clock(codec);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool wm8995_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8995_SOFTWARE_RESET:\r\ncase WM8995_POWER_MANAGEMENT_1:\r\ncase WM8995_POWER_MANAGEMENT_2:\r\ncase WM8995_POWER_MANAGEMENT_3:\r\ncase WM8995_POWER_MANAGEMENT_4:\r\ncase WM8995_POWER_MANAGEMENT_5:\r\ncase WM8995_LEFT_LINE_INPUT_1_VOLUME:\r\ncase WM8995_RIGHT_LINE_INPUT_1_VOLUME:\r\ncase WM8995_LEFT_LINE_INPUT_CONTROL:\r\ncase WM8995_DAC1_LEFT_VOLUME:\r\ncase WM8995_DAC1_RIGHT_VOLUME:\r\ncase WM8995_DAC2_LEFT_VOLUME:\r\ncase WM8995_DAC2_RIGHT_VOLUME:\r\ncase WM8995_OUTPUT_VOLUME_ZC_1:\r\ncase WM8995_MICBIAS_1:\r\ncase WM8995_MICBIAS_2:\r\ncase WM8995_LDO_1:\r\ncase WM8995_LDO_2:\r\ncase WM8995_ACCESSORY_DETECT_MODE1:\r\ncase WM8995_ACCESSORY_DETECT_MODE2:\r\ncase WM8995_HEADPHONE_DETECT1:\r\ncase WM8995_HEADPHONE_DETECT2:\r\ncase WM8995_MIC_DETECT_1:\r\ncase WM8995_MIC_DETECT_2:\r\ncase WM8995_CHARGE_PUMP_1:\r\ncase WM8995_CLASS_W_1:\r\ncase WM8995_DC_SERVO_1:\r\ncase WM8995_DC_SERVO_2:\r\ncase WM8995_DC_SERVO_3:\r\ncase WM8995_DC_SERVO_5:\r\ncase WM8995_DC_SERVO_6:\r\ncase WM8995_DC_SERVO_7:\r\ncase WM8995_DC_SERVO_READBACK_0:\r\ncase WM8995_ANALOGUE_HP_1:\r\ncase WM8995_ANALOGUE_HP_2:\r\ncase WM8995_CHIP_REVISION:\r\ncase WM8995_CONTROL_INTERFACE_1:\r\ncase WM8995_CONTROL_INTERFACE_2:\r\ncase WM8995_WRITE_SEQUENCER_CTRL_1:\r\ncase WM8995_WRITE_SEQUENCER_CTRL_2:\r\ncase WM8995_AIF1_CLOCKING_1:\r\ncase WM8995_AIF1_CLOCKING_2:\r\ncase WM8995_AIF2_CLOCKING_1:\r\ncase WM8995_AIF2_CLOCKING_2:\r\ncase WM8995_CLOCKING_1:\r\ncase WM8995_CLOCKING_2:\r\ncase WM8995_AIF1_RATE:\r\ncase WM8995_AIF2_RATE:\r\ncase WM8995_RATE_STATUS:\r\ncase WM8995_FLL1_CONTROL_1:\r\ncase WM8995_FLL1_CONTROL_2:\r\ncase WM8995_FLL1_CONTROL_3:\r\ncase WM8995_FLL1_CONTROL_4:\r\ncase WM8995_FLL1_CONTROL_5:\r\ncase WM8995_FLL2_CONTROL_1:\r\ncase WM8995_FLL2_CONTROL_2:\r\ncase WM8995_FLL2_CONTROL_3:\r\ncase WM8995_FLL2_CONTROL_4:\r\ncase WM8995_FLL2_CONTROL_5:\r\ncase WM8995_AIF1_CONTROL_1:\r\ncase WM8995_AIF1_CONTROL_2:\r\ncase WM8995_AIF1_MASTER_SLAVE:\r\ncase WM8995_AIF1_BCLK:\r\ncase WM8995_AIF1ADC_LRCLK:\r\ncase WM8995_AIF1DAC_LRCLK:\r\ncase WM8995_AIF1DAC_DATA:\r\ncase WM8995_AIF1ADC_DATA:\r\ncase WM8995_AIF2_CONTROL_1:\r\ncase WM8995_AIF2_CONTROL_2:\r\ncase WM8995_AIF2_MASTER_SLAVE:\r\ncase WM8995_AIF2_BCLK:\r\ncase WM8995_AIF2ADC_LRCLK:\r\ncase WM8995_AIF2DAC_LRCLK:\r\ncase WM8995_AIF2DAC_DATA:\r\ncase WM8995_AIF2ADC_DATA:\r\ncase WM8995_AIF1_ADC1_LEFT_VOLUME:\r\ncase WM8995_AIF1_ADC1_RIGHT_VOLUME:\r\ncase WM8995_AIF1_DAC1_LEFT_VOLUME:\r\ncase WM8995_AIF1_DAC1_RIGHT_VOLUME:\r\ncase WM8995_AIF1_ADC2_LEFT_VOLUME:\r\ncase WM8995_AIF1_ADC2_RIGHT_VOLUME:\r\ncase WM8995_AIF1_DAC2_LEFT_VOLUME:\r\ncase WM8995_AIF1_DAC2_RIGHT_VOLUME:\r\ncase WM8995_AIF1_ADC1_FILTERS:\r\ncase WM8995_AIF1_ADC2_FILTERS:\r\ncase WM8995_AIF1_DAC1_FILTERS_1:\r\ncase WM8995_AIF1_DAC1_FILTERS_2:\r\ncase WM8995_AIF1_DAC2_FILTERS_1:\r\ncase WM8995_AIF1_DAC2_FILTERS_2:\r\ncase WM8995_AIF1_DRC1_1:\r\ncase WM8995_AIF1_DRC1_2:\r\ncase WM8995_AIF1_DRC1_3:\r\ncase WM8995_AIF1_DRC1_4:\r\ncase WM8995_AIF1_DRC1_5:\r\ncase WM8995_AIF1_DRC2_1:\r\ncase WM8995_AIF1_DRC2_2:\r\ncase WM8995_AIF1_DRC2_3:\r\ncase WM8995_AIF1_DRC2_4:\r\ncase WM8995_AIF1_DRC2_5:\r\ncase WM8995_AIF1_DAC1_EQ_GAINS_1:\r\ncase WM8995_AIF1_DAC1_EQ_GAINS_2:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_1_A:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_1_B:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_1_PG:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_2_A:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_2_B:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_2_C:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_2_PG:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_3_A:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_3_B:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_3_C:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_3_PG:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_4_A:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_4_B:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_4_C:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_4_PG:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_5_A:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_5_B:\r\ncase WM8995_AIF1_DAC1_EQ_BAND_5_PG:\r\ncase WM8995_AIF1_DAC2_EQ_GAINS_1:\r\ncase WM8995_AIF1_DAC2_EQ_GAINS_2:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_1_A:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_1_B:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_1_PG:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_2_A:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_2_B:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_2_C:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_2_PG:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_3_A:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_3_B:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_3_C:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_3_PG:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_4_A:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_4_B:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_4_C:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_4_PG:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_5_A:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_5_B:\r\ncase WM8995_AIF1_DAC2_EQ_BAND_5_PG:\r\ncase WM8995_AIF2_ADC_LEFT_VOLUME:\r\ncase WM8995_AIF2_ADC_RIGHT_VOLUME:\r\ncase WM8995_AIF2_DAC_LEFT_VOLUME:\r\ncase WM8995_AIF2_DAC_RIGHT_VOLUME:\r\ncase WM8995_AIF2_ADC_FILTERS:\r\ncase WM8995_AIF2_DAC_FILTERS_1:\r\ncase WM8995_AIF2_DAC_FILTERS_2:\r\ncase WM8995_AIF2_DRC_1:\r\ncase WM8995_AIF2_DRC_2:\r\ncase WM8995_AIF2_DRC_3:\r\ncase WM8995_AIF2_DRC_4:\r\ncase WM8995_AIF2_DRC_5:\r\ncase WM8995_AIF2_EQ_GAINS_1:\r\ncase WM8995_AIF2_EQ_GAINS_2:\r\ncase WM8995_AIF2_EQ_BAND_1_A:\r\ncase WM8995_AIF2_EQ_BAND_1_B:\r\ncase WM8995_AIF2_EQ_BAND_1_PG:\r\ncase WM8995_AIF2_EQ_BAND_2_A:\r\ncase WM8995_AIF2_EQ_BAND_2_B:\r\ncase WM8995_AIF2_EQ_BAND_2_C:\r\ncase WM8995_AIF2_EQ_BAND_2_PG:\r\ncase WM8995_AIF2_EQ_BAND_3_A:\r\ncase WM8995_AIF2_EQ_BAND_3_B:\r\ncase WM8995_AIF2_EQ_BAND_3_C:\r\ncase WM8995_AIF2_EQ_BAND_3_PG:\r\ncase WM8995_AIF2_EQ_BAND_4_A:\r\ncase WM8995_AIF2_EQ_BAND_4_B:\r\ncase WM8995_AIF2_EQ_BAND_4_C:\r\ncase WM8995_AIF2_EQ_BAND_4_PG:\r\ncase WM8995_AIF2_EQ_BAND_5_A:\r\ncase WM8995_AIF2_EQ_BAND_5_B:\r\ncase WM8995_AIF2_EQ_BAND_5_PG:\r\ncase WM8995_DAC1_MIXER_VOLUMES:\r\ncase WM8995_DAC1_LEFT_MIXER_ROUTING:\r\ncase WM8995_DAC1_RIGHT_MIXER_ROUTING:\r\ncase WM8995_DAC2_MIXER_VOLUMES:\r\ncase WM8995_DAC2_LEFT_MIXER_ROUTING:\r\ncase WM8995_DAC2_RIGHT_MIXER_ROUTING:\r\ncase WM8995_AIF1_ADC1_LEFT_MIXER_ROUTING:\r\ncase WM8995_AIF1_ADC1_RIGHT_MIXER_ROUTING:\r\ncase WM8995_AIF1_ADC2_LEFT_MIXER_ROUTING:\r\ncase WM8995_AIF1_ADC2_RIGHT_MIXER_ROUTING:\r\ncase WM8995_DAC_SOFTMUTE:\r\ncase WM8995_OVERSAMPLING:\r\ncase WM8995_SIDETONE:\r\ncase WM8995_GPIO_1:\r\ncase WM8995_GPIO_2:\r\ncase WM8995_GPIO_3:\r\ncase WM8995_GPIO_4:\r\ncase WM8995_GPIO_5:\r\ncase WM8995_GPIO_6:\r\ncase WM8995_GPIO_7:\r\ncase WM8995_GPIO_8:\r\ncase WM8995_GPIO_9:\r\ncase WM8995_GPIO_10:\r\ncase WM8995_GPIO_11:\r\ncase WM8995_GPIO_12:\r\ncase WM8995_GPIO_13:\r\ncase WM8995_GPIO_14:\r\ncase WM8995_PULL_CONTROL_1:\r\ncase WM8995_PULL_CONTROL_2:\r\ncase WM8995_INTERRUPT_STATUS_1:\r\ncase WM8995_INTERRUPT_STATUS_2:\r\ncase WM8995_INTERRUPT_RAW_STATUS_2:\r\ncase WM8995_INTERRUPT_STATUS_1_MASK:\r\ncase WM8995_INTERRUPT_STATUS_2_MASK:\r\ncase WM8995_INTERRUPT_CONTROL:\r\ncase WM8995_LEFT_PDM_SPEAKER_1:\r\ncase WM8995_RIGHT_PDM_SPEAKER_1:\r\ncase WM8995_PDM_SPEAKER_1_MUTE_SEQUENCE:\r\ncase WM8995_LEFT_PDM_SPEAKER_2:\r\ncase WM8995_RIGHT_PDM_SPEAKER_2:\r\ncase WM8995_PDM_SPEAKER_2_MUTE_SEQUENCE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm8995_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8995_SOFTWARE_RESET:\r\ncase WM8995_DC_SERVO_READBACK_0:\r\ncase WM8995_INTERRUPT_STATUS_1:\r\ncase WM8995_INTERRUPT_STATUS_2:\r\ncase WM8995_INTERRUPT_CONTROL:\r\ncase WM8995_ACCESSORY_DETECT_MODE1:\r\ncase WM8995_ACCESSORY_DETECT_MODE2:\r\ncase WM8995_HEADPHONE_DETECT1:\r\ncase WM8995_HEADPHONE_DETECT2:\r\ncase WM8995_RATE_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm8995_aif_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint mute_reg;\r\nswitch (dai->id) {\r\ncase 0:\r\nmute_reg = WM8995_AIF1_DAC1_FILTERS_1;\r\nbreak;\r\ncase 1:\r\nmute_reg = WM8995_AIF2_DAC_FILTERS_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, mute_reg, WM8995_AIF1DAC1_MUTE_MASK,\r\n!!mute << WM8995_AIF1DAC1_MUTE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int wm8995_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec;\r\nint master;\r\nint aif;\r\ncodec = dai->codec;\r\nmaster = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = WM8995_AIF1_MSTR;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\naif = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif |= WM8995_AIF1_LRCLK_INV;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif |= (0x3 << WM8995_AIF1_FMT_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif |= (0x2 << WM8995_AIF1_FMT_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif |= (0x1 << WM8995_AIF1_FMT_SHIFT);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif |= WM8995_AIF1_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif |= WM8995_AIF1_BCLK_INV | WM8995_AIF1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif |= WM8995_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif |= WM8995_AIF1_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8995_AIF1_CONTROL_1,\r\nWM8995_AIF1_BCLK_INV_MASK |\r\nWM8995_AIF1_LRCLK_INV_MASK |\r\nWM8995_AIF1_FMT_MASK, aif);\r\nsnd_soc_update_bits(codec, WM8995_AIF1_MASTER_SLAVE,\r\nWM8995_AIF1_MSTR_MASK, master);\r\nreturn 0;\r\n}\r\nstatic int wm8995_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8995_priv *wm8995;\r\nint aif1_reg;\r\nint bclk_reg;\r\nint lrclk_reg;\r\nint rate_reg;\r\nint bclk_rate;\r\nint aif1;\r\nint lrclk, bclk;\r\nint i, rate_val, best, best_val, cur_val;\r\ncodec = dai->codec;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nswitch (dai->id) {\r\ncase 0:\r\naif1_reg = WM8995_AIF1_CONTROL_1;\r\nbclk_reg = WM8995_AIF1_BCLK;\r\nrate_reg = WM8995_AIF1_RATE;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) {\r\nlrclk_reg = WM8995_AIF1DAC_LRCLK;\r\n} else {\r\nlrclk_reg = WM8995_AIF1ADC_LRCLK;\r\ndev_dbg(codec->dev, "AIF1 using split LRCLK\n");\r\n}\r\nbreak;\r\ncase 1:\r\naif1_reg = WM8995_AIF2_CONTROL_1;\r\nbclk_reg = WM8995_AIF2_BCLK;\r\nrate_reg = WM8995_AIF2_RATE;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ) {\r\nlrclk_reg = WM8995_AIF2DAC_LRCLK;\r\n} else {\r\nlrclk_reg = WM8995_AIF2ADC_LRCLK;\r\ndev_dbg(codec->dev, "AIF2 using split LRCLK\n");\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbclk_rate = snd_soc_params_to_bclk(params);\r\nif (bclk_rate < 0)\r\nreturn bclk_rate;\r\naif1 = 0;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\naif1 |= (0x1 << WM8995_AIF1_WL_SHIFT);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\naif1 |= (0x2 << WM8995_AIF1_WL_SHIFT);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naif1 |= (0x3 << WM8995_AIF1_WL_SHIFT);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unsupported word length %u\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(srs); ++i)\r\nif (srs[i] == params_rate(params))\r\nbreak;\r\nif (i == ARRAY_SIZE(srs)) {\r\ndev_err(dai->dev, "Sample rate %d is not supported\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nrate_val = i << WM8995_AIF1_SR_SHIFT;\r\ndev_dbg(dai->dev, "Sample rate is %dHz\n", srs[i]);\r\ndev_dbg(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",\r\ndai->id + 1, wm8995->aifclk[dai->id], bclk_rate);\r\nbest = 1;\r\nbest_val = abs((fs_ratios[1] * params_rate(params))\r\n- wm8995->aifclk[dai->id]);\r\nfor (i = 2; i < ARRAY_SIZE(fs_ratios); i++) {\r\ncur_val = abs((fs_ratios[i] * params_rate(params))\r\n- wm8995->aifclk[dai->id]);\r\nif (cur_val >= best_val)\r\ncontinue;\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\nrate_val |= best;\r\ndev_dbg(dai->dev, "Selected AIF%dCLK/fs = %d\n",\r\ndai->id + 1, fs_ratios[best]);\r\nbest = 0;\r\nbclk = 0;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\ncur_val = (wm8995->aifclk[dai->id] * 10 / bclk_divs[i]) - bclk_rate;\r\nif (cur_val < 0)\r\nbreak;\r\nbest = i;\r\n}\r\nbclk |= best << WM8995_AIF1_BCLK_DIV_SHIFT;\r\nbclk_rate = wm8995->aifclk[dai->id] * 10 / bclk_divs[best];\r\ndev_dbg(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",\r\nbclk_divs[best], bclk_rate);\r\nlrclk = bclk_rate / params_rate(params);\r\ndev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",\r\nlrclk, bclk_rate / lrclk);\r\nsnd_soc_update_bits(codec, aif1_reg,\r\nWM8995_AIF1_WL_MASK, aif1);\r\nsnd_soc_update_bits(codec, bclk_reg,\r\nWM8995_AIF1_BCLK_DIV_MASK, bclk);\r\nsnd_soc_update_bits(codec, lrclk_reg,\r\nWM8995_AIF1DAC_RATE_MASK, lrclk);\r\nsnd_soc_update_bits(codec, rate_reg,\r\nWM8995_AIF1_SR_MASK |\r\nWM8995_AIF1CLK_RATE_MASK, rate_val);\r\nreturn 0;\r\n}\r\nstatic int wm8995_set_tristate(struct snd_soc_dai *codec_dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint reg, val, mask;\r\nswitch (codec_dai->id) {\r\ncase 0:\r\nreg = WM8995_AIF1_MASTER_SLAVE;\r\nmask = WM8995_AIF1_TRI;\r\nbreak;\r\ncase 1:\r\nreg = WM8995_AIF2_MASTER_SLAVE;\r\nmask = WM8995_AIF2_TRI;\r\nbreak;\r\ncase 2:\r\nreg = WM8995_POWER_MANAGEMENT_5;\r\nmask = WM8995_AIF3_TRI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (tristate)\r\nval = mask;\r\nelse\r\nval = 0;\r\nreturn snd_soc_update_bits(codec, reg, mask, val);\r\n}\r\nstatic int wm8995_get_fll_config(struct fll_div *fll,\r\nint freq_in, int freq_out)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\npr_debug("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);\r\nfll->clk_ref_div = 0;\r\nwhile (freq_in > 13500000) {\r\nfll->clk_ref_div++;\r\nfreq_in /= 2;\r\nif (fll->clk_ref_div > 3)\r\nreturn -EINVAL;\r\n}\r\npr_debug("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);\r\nfll->outdiv = 3;\r\nwhile (freq_out * (fll->outdiv + 1) < 90000000) {\r\nfll->outdiv++;\r\nif (fll->outdiv > 63)\r\nreturn -EINVAL;\r\n}\r\nfreq_out *= fll->outdiv + 1;\r\npr_debug("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);\r\nif (freq_in > 1000000) {\r\nfll->fll_fratio = 0;\r\n} else if (freq_in > 256000) {\r\nfll->fll_fratio = 1;\r\nfreq_in *= 2;\r\n} else if (freq_in > 128000) {\r\nfll->fll_fratio = 2;\r\nfreq_in *= 4;\r\n} else if (freq_in > 64000) {\r\nfll->fll_fratio = 3;\r\nfreq_in *= 8;\r\n} else {\r\nfll->fll_fratio = 4;\r\nfreq_in *= 16;\r\n}\r\npr_debug("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);\r\nNdiv = freq_out / freq_in;\r\nfll->n = Ndiv;\r\nNmod = freq_out % freq_in;\r\npr_debug("Nmod=%d\n", Nmod);\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, freq_in);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfll->k = K / 10;\r\npr_debug("N=%x K=%x\n", fll->n, fll->k);\r\nreturn 0;\r\n}\r\nstatic int wm8995_set_fll(struct snd_soc_dai *dai, int id,\r\nint src, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8995_priv *wm8995;\r\nint reg_offset, ret;\r\nstruct fll_div fll;\r\nu16 reg, aif1, aif2;\r\ncodec = dai->codec;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\naif1 = snd_soc_read(codec, WM8995_AIF1_CLOCKING_1)\r\n& WM8995_AIF1CLK_ENA;\r\naif2 = snd_soc_read(codec, WM8995_AIF2_CLOCKING_1)\r\n& WM8995_AIF2CLK_ENA;\r\nswitch (id) {\r\ncase WM8995_FLL1:\r\nreg_offset = 0;\r\nid = 0;\r\nbreak;\r\ncase WM8995_FLL2:\r\nreg_offset = 0x20;\r\nid = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (src) {\r\ncase 0:\r\nif (freq_out)\r\nreturn -EINVAL;\r\nbreak;\r\ncase WM8995_FLL_SRC_MCLK1:\r\ncase WM8995_FLL_SRC_MCLK2:\r\ncase WM8995_FLL_SRC_LRCLK:\r\ncase WM8995_FLL_SRC_BCLK:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (wm8995->fll[id].src == src &&\r\nwm8995->fll[id].in == freq_in && wm8995->fll[id].out == freq_out)\r\nreturn 0;\r\nif (freq_out)\r\nret = wm8995_get_fll_config(&fll, freq_in, freq_out);\r\nelse\r\nret = wm8995_get_fll_config(&fll, wm8995->fll[id].in,\r\nwm8995->fll[id].out);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, WM8995_AIF1_CLOCKING_1,\r\nWM8995_AIF1CLK_ENA_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8995_AIF2_CLOCKING_1,\r\nWM8995_AIF2CLK_ENA_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8995_FLL1_CONTROL_1 + reg_offset,\r\nWM8995_FLL1_ENA_MASK, 0);\r\nreg = (fll.outdiv << WM8995_FLL1_OUTDIV_SHIFT) |\r\n(fll.fll_fratio << WM8995_FLL1_FRATIO_SHIFT);\r\nsnd_soc_update_bits(codec, WM8995_FLL1_CONTROL_2 + reg_offset,\r\nWM8995_FLL1_OUTDIV_MASK |\r\nWM8995_FLL1_FRATIO_MASK, reg);\r\nsnd_soc_write(codec, WM8995_FLL1_CONTROL_3 + reg_offset, fll.k);\r\nsnd_soc_update_bits(codec, WM8995_FLL1_CONTROL_4 + reg_offset,\r\nWM8995_FLL1_N_MASK,\r\nfll.n << WM8995_FLL1_N_SHIFT);\r\nsnd_soc_update_bits(codec, WM8995_FLL1_CONTROL_5 + reg_offset,\r\nWM8995_FLL1_REFCLK_DIV_MASK |\r\nWM8995_FLL1_REFCLK_SRC_MASK,\r\n(fll.clk_ref_div << WM8995_FLL1_REFCLK_DIV_SHIFT) |\r\n(src - 1));\r\nif (freq_out)\r\nsnd_soc_update_bits(codec, WM8995_FLL1_CONTROL_1 + reg_offset,\r\nWM8995_FLL1_ENA_MASK, WM8995_FLL1_ENA);\r\nwm8995->fll[id].in = freq_in;\r\nwm8995->fll[id].out = freq_out;\r\nwm8995->fll[id].src = src;\r\nsnd_soc_update_bits(codec, WM8995_AIF1_CLOCKING_1,\r\nWM8995_AIF1CLK_ENA_MASK, aif1);\r\nsnd_soc_update_bits(codec, WM8995_AIF2_CLOCKING_1,\r\nWM8995_AIF2CLK_ENA_MASK, aif2);\r\nconfigure_clock(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8995_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8995_priv *wm8995;\r\ncodec = dai->codec;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nswitch (dai->id) {\r\ncase 0:\r\ncase 1:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (clk_id) {\r\ncase WM8995_SYSCLK_MCLK1:\r\nwm8995->sysclk[dai->id] = WM8995_SYSCLK_MCLK1;\r\nwm8995->mclk[0] = freq;\r\ndev_dbg(dai->dev, "AIF%d using MCLK1 at %uHz\n",\r\ndai->id + 1, freq);\r\nbreak;\r\ncase WM8995_SYSCLK_MCLK2:\r\nwm8995->sysclk[dai->id] = WM8995_SYSCLK_MCLK1;\r\nwm8995->mclk[1] = freq;\r\ndev_dbg(dai->dev, "AIF%d using MCLK2 at %uHz\n",\r\ndai->id + 1, freq);\r\nbreak;\r\ncase WM8995_SYSCLK_FLL1:\r\nwm8995->sysclk[dai->id] = WM8995_SYSCLK_FLL1;\r\ndev_dbg(dai->dev, "AIF%d using FLL1\n", dai->id + 1);\r\nbreak;\r\ncase WM8995_SYSCLK_FLL2:\r\nwm8995->sysclk[dai->id] = WM8995_SYSCLK_FLL2;\r\ndev_dbg(dai->dev, "AIF%d using FLL2\n", dai->id + 1);\r\nbreak;\r\ncase WM8995_SYSCLK_OPCLK:\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nconfigure_clock(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8995_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint ret;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8995->supplies),\r\nwm8995->supplies);\r\nif (ret)\r\nreturn ret;\r\nret = regcache_sync(wm8995->regmap);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, WM8995_POWER_MANAGEMENT_1,\r\nWM8995_BG_ENA_MASK, WM8995_BG_ENA);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8995_POWER_MANAGEMENT_1,\r\nWM8995_BG_ENA_MASK, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8995->supplies),\r\nwm8995->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8995_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8995_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8995_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8995_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8995_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint i;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nwm8995_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nfor (i = 0; i < ARRAY_SIZE(wm8995->supplies); ++i)\r\nregulator_unregister_notifier(wm8995->supplies[i].consumer,\r\n&wm8995->disable_nb[i]);\r\nregulator_bulk_free(ARRAY_SIZE(wm8995->supplies), wm8995->supplies);\r\nreturn 0;\r\n}\r\nstatic int wm8995_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint i;\r\nint ret;\r\nwm8995 = snd_soc_codec_get_drvdata(codec);\r\nwm8995->codec = codec;\r\ncodec->control_data = wm8995->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache i/o: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8995->supplies); i++)\r\nwm8995->supplies[i].supply = wm8995_supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(wm8995->supplies),\r\nwm8995->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8995->disable_nb[0].notifier_call = wm8995_regulator_event_0;\r\nwm8995->disable_nb[1].notifier_call = wm8995_regulator_event_1;\r\nwm8995->disable_nb[2].notifier_call = wm8995_regulator_event_2;\r\nwm8995->disable_nb[3].notifier_call = wm8995_regulator_event_3;\r\nwm8995->disable_nb[4].notifier_call = wm8995_regulator_event_4;\r\nwm8995->disable_nb[5].notifier_call = wm8995_regulator_event_5;\r\nwm8995->disable_nb[6].notifier_call = wm8995_regulator_event_6;\r\nwm8995->disable_nb[7].notifier_call = wm8995_regulator_event_7;\r\nfor (i = 0; i < ARRAY_SIZE(wm8995->supplies); i++) {\r\nret = regulator_register_notifier(wm8995->supplies[i].consumer,\r\n&wm8995->disable_nb[i]);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8995->supplies),\r\nwm8995->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_reg_get;\r\n}\r\nret = snd_soc_read(codec, WM8995_SOFTWARE_RESET);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read device ID: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nif (ret != 0x8995) {\r\ndev_err(codec->dev, "Invalid device ID: %#x\n", ret);\r\nret = -EINVAL;\r\ngoto err_reg_enable;\r\n}\r\nret = snd_soc_write(codec, WM8995_SOFTWARE_RESET, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nwm8995_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_update_bits(codec, WM8995_AIF1_DAC1_RIGHT_VOLUME,\r\nWM8995_AIF1DAC1_VU_MASK, WM8995_AIF1DAC1_VU);\r\nsnd_soc_update_bits(codec, WM8995_AIF1_DAC2_RIGHT_VOLUME,\r\nWM8995_AIF1DAC2_VU_MASK, WM8995_AIF1DAC2_VU);\r\nsnd_soc_update_bits(codec, WM8995_AIF2_DAC_RIGHT_VOLUME,\r\nWM8995_AIF2DAC_VU_MASK, WM8995_AIF2DAC_VU);\r\nsnd_soc_update_bits(codec, WM8995_AIF1_ADC1_RIGHT_VOLUME,\r\nWM8995_AIF1ADC1_VU_MASK, WM8995_AIF1ADC1_VU);\r\nsnd_soc_update_bits(codec, WM8995_AIF1_ADC2_RIGHT_VOLUME,\r\nWM8995_AIF1ADC2_VU_MASK, WM8995_AIF1ADC2_VU);\r\nsnd_soc_update_bits(codec, WM8995_AIF2_ADC_RIGHT_VOLUME,\r\nWM8995_AIF2ADC_VU_MASK, WM8995_AIF1ADC2_VU);\r\nsnd_soc_update_bits(codec, WM8995_DAC1_RIGHT_VOLUME,\r\nWM8995_DAC1_VU_MASK, WM8995_DAC1_VU);\r\nsnd_soc_update_bits(codec, WM8995_DAC2_RIGHT_VOLUME,\r\nWM8995_DAC2_VU_MASK, WM8995_DAC2_VU);\r\nsnd_soc_update_bits(codec, WM8995_RIGHT_LINE_INPUT_1_VOLUME,\r\nWM8995_IN1_VU_MASK, WM8995_IN1_VU);\r\nwm8995_update_class_w(codec);\r\nsnd_soc_add_codec_controls(codec, wm8995_snd_controls,\r\nARRAY_SIZE(wm8995_snd_controls));\r\nsnd_soc_dapm_new_controls(&codec->dapm, wm8995_dapm_widgets,\r\nARRAY_SIZE(wm8995_dapm_widgets));\r\nsnd_soc_dapm_add_routes(&codec->dapm, wm8995_intercon,\r\nARRAY_SIZE(wm8995_intercon));\r\nreturn 0;\r\nerr_reg_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8995->supplies), wm8995->supplies);\r\nerr_reg_get:\r\nregulator_bulk_free(ARRAY_SIZE(wm8995->supplies), wm8995->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8995_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint ret;\r\nwm8995 = devm_kzalloc(&spi->dev, sizeof(*wm8995), GFP_KERNEL);\r\nif (!wm8995)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, wm8995);\r\nwm8995->regmap = devm_regmap_init_spi(spi, &wm8995_regmap);\r\nif (IS_ERR(wm8995->regmap)) {\r\nret = PTR_ERR(wm8995->regmap);\r\ndev_err(&spi->dev, "Failed to register regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm8995, wm8995_dai,\r\nARRAY_SIZE(wm8995_dai));\r\nreturn ret;\r\n}\r\nstatic int wm8995_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int wm8995_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8995_priv *wm8995;\r\nint ret;\r\nwm8995 = devm_kzalloc(&i2c->dev, sizeof(*wm8995), GFP_KERNEL);\r\nif (!wm8995)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8995);\r\nwm8995->regmap = devm_regmap_init_i2c(i2c, &wm8995_regmap);\r\nif (IS_ERR(wm8995->regmap)) {\r\nret = PTR_ERR(wm8995->regmap);\r\ndev_err(&i2c->dev, "Failed to register regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8995, wm8995_dai,\r\nARRAY_SIZE(wm8995_dai));\r\nif (ret < 0)\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int wm8995_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init wm8995_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&wm8995_i2c_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to register wm8995 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&wm8995_spi_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to register wm8995 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8995_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&wm8995_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&wm8995_spi_driver);\r\n#endif\r\n}
