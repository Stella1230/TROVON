static int pl061_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\nreturn pinctrl_request_gpio(gpio);\r\n}\r\nstatic void pl061_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int pl061_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\ngpiodir = readb(chip->base + GPIODIR);\r\ngpiodir &= ~(1 << offset);\r\nwriteb(gpiodir, chip->base + GPIODIR);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nwriteb(!!value << offset, chip->base + (1 << (offset + 2)));\r\ngpiodir = readb(chip->base + GPIODIR);\r\ngpiodir |= 1 << offset;\r\nwriteb(gpiodir, chip->base + GPIODIR);\r\nwriteb(!!value << offset, chip->base + (1 << (offset + 2)));\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nreturn !!readb(chip->base + (1 << (offset + 2)));\r\n}\r\nstatic void pl061_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nwriteb(!!value << offset, chip->base + (1 << (offset + 2)));\r\n}\r\nstatic int pl061_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nreturn irq_create_mapping(chip->domain, offset);\r\n}\r\nstatic int pl061_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct pl061_gpio *chip = irq_data_get_irq_chip_data(d);\r\nint offset = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu8 gpiois, gpioibe, gpioiev;\r\nif (offset < 0 || offset >= PL061_GPIO_NR)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\ngpioiev = readb(chip->base + GPIOIEV);\r\ngpiois = readb(chip->base + GPIOIS);\r\nif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\ngpiois |= 1 << offset;\r\nif (trigger & IRQ_TYPE_LEVEL_HIGH)\r\ngpioiev |= 1 << offset;\r\nelse\r\ngpioiev &= ~(1 << offset);\r\n} else\r\ngpiois &= ~(1 << offset);\r\nwriteb(gpiois, chip->base + GPIOIS);\r\ngpioibe = readb(chip->base + GPIOIBE);\r\nif ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\ngpioibe |= 1 << offset;\r\nelse {\r\ngpioibe &= ~(1 << offset);\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\ngpioiev |= 1 << offset;\r\nelse if (trigger & IRQ_TYPE_EDGE_FALLING)\r\ngpioiev &= ~(1 << offset);\r\n}\r\nwriteb(gpioibe, chip->base + GPIOIBE);\r\nwriteb(gpioiev, chip->base + GPIOIEV);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pl061_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nunsigned long pending;\r\nint offset;\r\nstruct pl061_gpio *chip = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nchained_irq_enter(irqchip, desc);\r\npending = readb(chip->base + GPIOMIS);\r\nwriteb(pending, chip->base + GPIOIC);\r\nif (pending) {\r\nfor_each_set_bit(offset, &pending, PL061_GPIO_NR)\r\ngeneric_handle_irq(pl061_to_irq(&chip->gc, offset));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic void pl061_irq_mask(struct irq_data *d)\r\n{\r\nstruct pl061_gpio *chip = irq_data_get_irq_chip_data(d);\r\nu8 mask = 1 << (irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nu8 gpioie;\r\nspin_lock(&chip->lock);\r\ngpioie = readb(chip->base + GPIOIE) & ~mask;\r\nwriteb(gpioie, chip->base + GPIOIE);\r\nspin_unlock(&chip->lock);\r\n}\r\nstatic void pl061_irq_unmask(struct irq_data *d)\r\n{\r\nstruct pl061_gpio *chip = irq_data_get_irq_chip_data(d);\r\nu8 mask = 1 << (irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nu8 gpioie;\r\nspin_lock(&chip->lock);\r\ngpioie = readb(chip->base + GPIOIE) | mask;\r\nwriteb(gpioie, chip->base + GPIOIE);\r\nspin_unlock(&chip->lock);\r\n}\r\nstatic int pl061_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct pl061_gpio *chip = d->host_data;\r\nirq_set_chip_and_handler_name(virq, &pl061_irqchip, handle_simple_irq,\r\n"pl061");\r\nirq_set_chip_data(virq, chip);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int pl061_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nstruct device *dev = &adev->dev;\r\nstruct pl061_platform_data *pdata = dev->platform_data;\r\nstruct pl061_gpio *chip;\r\nint ret, irq, i, irq_base;\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nif (pdata) {\r\nchip->gc.base = pdata->gpio_base;\r\nirq_base = pdata->irq_base;\r\nif (irq_base <= 0)\r\nreturn -ENODEV;\r\n} else {\r\nchip->gc.base = -1;\r\nirq_base = 0;\r\n}\r\nif (!devm_request_mem_region(dev, adev->res.start,\r\nresource_size(&adev->res), "pl061"))\r\nreturn -EBUSY;\r\nchip->base = devm_ioremap(dev, adev->res.start,\r\nresource_size(&adev->res));\r\nif (!chip->base)\r\nreturn -ENOMEM;\r\nchip->domain = irq_domain_add_simple(adev->dev.of_node, PL061_GPIO_NR,\r\nirq_base, &pl061_domain_ops, chip);\r\nif (!chip->domain)\r\nreturn -ENODEV;\r\nspin_lock_init(&chip->lock);\r\nchip->gc.request = pl061_gpio_request;\r\nchip->gc.free = pl061_gpio_free;\r\nchip->gc.direction_input = pl061_direction_input;\r\nchip->gc.direction_output = pl061_direction_output;\r\nchip->gc.get = pl061_get_value;\r\nchip->gc.set = pl061_set_value;\r\nchip->gc.to_irq = pl061_to_irq;\r\nchip->gc.ngpio = PL061_GPIO_NR;\r\nchip->gc.label = dev_name(dev);\r\nchip->gc.dev = dev;\r\nchip->gc.owner = THIS_MODULE;\r\nret = gpiochip_add(&chip->gc);\r\nif (ret)\r\nreturn ret;\r\nwriteb(0, chip->base + GPIOIE);\r\nirq = adev->irq[0];\r\nif (irq < 0)\r\nreturn -ENODEV;\r\nirq_set_chained_handler(irq, pl061_irq_handler);\r\nirq_set_handler_data(irq, chip);\r\nfor (i = 0; i < PL061_GPIO_NR; i++) {\r\nif (pdata) {\r\nif (pdata->directions & (1 << i))\r\npl061_direction_output(&chip->gc, i,\r\npdata->values & (1 << i));\r\nelse\r\npl061_direction_input(&chip->gc, i);\r\n}\r\n}\r\namba_set_drvdata(adev, chip);\r\nreturn 0;\r\n}\r\nstatic int pl061_suspend(struct device *dev)\r\n{\r\nstruct pl061_gpio *chip = dev_get_drvdata(dev);\r\nint offset;\r\nchip->csave_regs.gpio_data = 0;\r\nchip->csave_regs.gpio_dir = readb(chip->base + GPIODIR);\r\nchip->csave_regs.gpio_is = readb(chip->base + GPIOIS);\r\nchip->csave_regs.gpio_ibe = readb(chip->base + GPIOIBE);\r\nchip->csave_regs.gpio_iev = readb(chip->base + GPIOIEV);\r\nchip->csave_regs.gpio_ie = readb(chip->base + GPIOIE);\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (chip->csave_regs.gpio_dir & (1 << offset))\r\nchip->csave_regs.gpio_data |=\r\npl061_get_value(&chip->gc, offset) << offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl061_resume(struct device *dev)\r\n{\r\nstruct pl061_gpio *chip = dev_get_drvdata(dev);\r\nint offset;\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (chip->csave_regs.gpio_dir & (1 << offset))\r\npl061_direction_output(&chip->gc, offset,\r\nchip->csave_regs.gpio_data &\r\n(1 << offset));\r\nelse\r\npl061_direction_input(&chip->gc, offset);\r\n}\r\nwriteb(chip->csave_regs.gpio_is, chip->base + GPIOIS);\r\nwriteb(chip->csave_regs.gpio_ibe, chip->base + GPIOIBE);\r\nwriteb(chip->csave_regs.gpio_iev, chip->base + GPIOIEV);\r\nwriteb(chip->csave_regs.gpio_ie, chip->base + GPIOIE);\r\nreturn 0;\r\n}\r\nstatic int __init pl061_gpio_init(void)\r\n{\r\nreturn amba_driver_register(&pl061_gpio_driver);\r\n}
