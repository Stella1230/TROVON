static int arizona_micsupp_list_voltage(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nif (selector > ARIZONA_MICSUPP_MAX_SELECTOR)\r\nreturn -EINVAL;\r\nif (selector == ARIZONA_MICSUPP_MAX_SELECTOR)\r\nreturn 3300000;\r\nelse\r\nreturn (selector * 50000) + 1700000;\r\n}\r\nstatic int arizona_micsupp_map_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nunsigned int voltage;\r\nint selector;\r\nif (min_uV < 1700000)\r\nmin_uV = 1700000;\r\nif (min_uV > 3200000)\r\nselector = ARIZONA_MICSUPP_MAX_SELECTOR;\r\nelse\r\nselector = DIV_ROUND_UP(min_uV - 1700000, 50000);\r\nif (selector < 0)\r\nreturn -EINVAL;\r\nvoltage = arizona_micsupp_list_voltage(rdev, selector);\r\nif (voltage < min_uV || voltage > max_uV)\r\nreturn -EINVAL;\r\nreturn selector;\r\n}\r\nstatic void arizona_micsupp_check_cp(struct work_struct *work)\r\n{\r\nstruct arizona_micsupp *micsupp =\r\ncontainer_of(work, struct arizona_micsupp, check_cp_work);\r\nstruct snd_soc_dapm_context *dapm = micsupp->arizona->dapm;\r\nstruct arizona *arizona = micsupp->arizona;\r\nstruct regmap *regmap = arizona->regmap;\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(regmap, ARIZONA_MIC_CHARGE_PUMP_1, &reg);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read CP state: %d\n", ret);\r\nreturn;\r\n}\r\nif (dapm) {\r\nif ((reg & (ARIZONA_CPMIC_ENA | ARIZONA_CPMIC_BYPASS)) ==\r\nARIZONA_CPMIC_ENA)\r\nsnd_soc_dapm_force_enable_pin(dapm, "MICSUPP");\r\nelse\r\nsnd_soc_dapm_disable_pin(dapm, "MICSUPP");\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\n}\r\nstatic int arizona_micsupp_enable(struct regulator_dev *rdev)\r\n{\r\nstruct arizona_micsupp *micsupp = rdev_get_drvdata(rdev);\r\nint ret;\r\nret = regulator_enable_regmap(rdev);\r\nif (ret == 0)\r\nschedule_work(&micsupp->check_cp_work);\r\nreturn ret;\r\n}\r\nstatic int arizona_micsupp_disable(struct regulator_dev *rdev)\r\n{\r\nstruct arizona_micsupp *micsupp = rdev_get_drvdata(rdev);\r\nint ret;\r\nret = regulator_disable_regmap(rdev);\r\nif (ret == 0)\r\nschedule_work(&micsupp->check_cp_work);\r\nreturn ret;\r\n}\r\nstatic int arizona_micsupp_set_bypass(struct regulator_dev *rdev, bool ena)\r\n{\r\nstruct arizona_micsupp *micsupp = rdev_get_drvdata(rdev);\r\nint ret;\r\nret = regulator_set_bypass_regmap(rdev, ena);\r\nif (ret == 0)\r\nschedule_work(&micsupp->check_cp_work);\r\nreturn ret;\r\n}\r\nstatic int arizona_micsupp_probe(struct platform_device *pdev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(pdev->dev.parent);\r\nstruct regulator_config config = { };\r\nstruct arizona_micsupp *micsupp;\r\nint ret;\r\nmicsupp = devm_kzalloc(&pdev->dev, sizeof(*micsupp), GFP_KERNEL);\r\nif (micsupp == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nmicsupp->arizona = arizona;\r\nINIT_WORK(&micsupp->check_cp_work, arizona_micsupp_check_cp);\r\nmicsupp->init_data = arizona_micsupp_default;\r\nmicsupp->init_data.consumer_supplies = &micsupp->supply;\r\nmicsupp->supply.supply = "MICVDD";\r\nmicsupp->supply.dev_name = dev_name(arizona->dev);\r\nconfig.dev = arizona->dev;\r\nconfig.driver_data = micsupp;\r\nconfig.regmap = arizona->regmap;\r\nif (arizona->pdata.micvdd)\r\nconfig.init_data = arizona->pdata.micvdd;\r\nelse\r\nconfig.init_data = &micsupp->init_data;\r\nregmap_update_bits(arizona->regmap, ARIZONA_MIC_CHARGE_PUMP_1,\r\nARIZONA_CPMIC_BYPASS, 0);\r\nmicsupp->regulator = regulator_register(&arizona_micsupp, &config);\r\nif (IS_ERR(micsupp->regulator)) {\r\nret = PTR_ERR(micsupp->regulator);\r\ndev_err(arizona->dev, "Failed to register mic supply: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, micsupp);\r\nreturn 0;\r\n}\r\nstatic int arizona_micsupp_remove(struct platform_device *pdev)\r\n{\r\nstruct arizona_micsupp *micsupp = platform_get_drvdata(pdev);\r\nregulator_unregister(micsupp->regulator);\r\nreturn 0;\r\n}
