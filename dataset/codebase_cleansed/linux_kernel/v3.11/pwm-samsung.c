static inline int pwm_is_tdiv(struct s3c_chip *chip)\r\n{\r\nreturn clk_get_parent(chip->clk) == chip->clk_div;\r\n}\r\nstatic int s3c_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct s3c_chip *s3c = to_s3c_chip(chip);\r\nunsigned long flags;\r\nunsigned long tcon;\r\nlocal_irq_save(flags);\r\ntcon = __raw_readl(S3C2410_TCON);\r\ntcon |= pwm_tcon_start(s3c);\r\n__raw_writel(tcon, S3C2410_TCON);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void s3c_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct s3c_chip *s3c = to_s3c_chip(chip);\r\nunsigned long flags;\r\nunsigned long tcon;\r\nlocal_irq_save(flags);\r\ntcon = __raw_readl(S3C2410_TCON);\r\ntcon &= ~pwm_tcon_start(s3c);\r\n__raw_writel(tcon, S3C2410_TCON);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic unsigned long pwm_calc_tin(struct s3c_chip *s3c, unsigned long freq)\r\n{\r\nunsigned long tin_parent_rate;\r\nunsigned int div;\r\ntin_parent_rate = clk_get_rate(clk_get_parent(s3c->clk_div));\r\npwm_dbg(s3c, "tin parent at %lu\n", tin_parent_rate);\r\nfor (div = 2; div <= 16; div *= 2) {\r\nif ((tin_parent_rate / (div << 16)) < freq)\r\nreturn tin_parent_rate / div;\r\n}\r\nreturn tin_parent_rate / 16;\r\n}\r\nstatic int s3c_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct s3c_chip *s3c = to_s3c_chip(chip);\r\nunsigned long tin_rate;\r\nunsigned long tin_ns;\r\nunsigned long period;\r\nunsigned long flags;\r\nunsigned long tcon;\r\nunsigned long tcnt;\r\nlong tcmp;\r\nif (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)\r\nreturn -ERANGE;\r\nif (period_ns == s3c->period_ns &&\r\nduty_ns == s3c->duty_ns)\r\nreturn 0;\r\ntcmp = __raw_readl(S3C2410_TCMPB(s3c->pwm_id));\r\ntcnt = __raw_readl(S3C2410_TCNTB(s3c->pwm_id));\r\nperiod = NS_IN_HZ / period_ns;\r\npwm_dbg(s3c, "duty_ns=%d, period_ns=%d (%lu)\n",\r\nduty_ns, period_ns, period);\r\nif (s3c->period_ns != period_ns) {\r\nif (pwm_is_tdiv(s3c)) {\r\ntin_rate = pwm_calc_tin(s3c, period);\r\nclk_set_rate(s3c->clk_div, tin_rate);\r\n} else\r\ntin_rate = clk_get_rate(s3c->clk);\r\ns3c->period_ns = period_ns;\r\npwm_dbg(s3c, "tin_rate=%lu\n", tin_rate);\r\ntin_ns = NS_IN_HZ / tin_rate;\r\ntcnt = period_ns / tin_ns;\r\n} else\r\ntin_ns = NS_IN_HZ / clk_get_rate(s3c->clk);\r\ntcmp = duty_ns / tin_ns;\r\ntcmp = tcnt - tcmp;\r\nif (tcmp == tcnt)\r\ntcmp--;\r\npwm_dbg(s3c, "tin_ns=%lu, tcmp=%ld/%lu\n", tin_ns, tcmp, tcnt);\r\nif (tcmp < 0)\r\ntcmp = 0;\r\nlocal_irq_save(flags);\r\n__raw_writel(tcmp, S3C2410_TCMPB(s3c->pwm_id));\r\n__raw_writel(tcnt, S3C2410_TCNTB(s3c->pwm_id));\r\ntcon = __raw_readl(S3C2410_TCON);\r\ntcon |= pwm_tcon_manulupdate(s3c);\r\ntcon |= pwm_tcon_autoreload(s3c);\r\n__raw_writel(tcon, S3C2410_TCON);\r\ntcon &= ~pwm_tcon_manulupdate(s3c);\r\n__raw_writel(tcon, S3C2410_TCON);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct s3c_chip *s3c;\r\nunsigned long flags;\r\nunsigned long tcon;\r\nunsigned int id = pdev->id;\r\nint ret;\r\nif (id == 4) {\r\ndev_err(dev, "TIMER4 is currently not supported\n");\r\nreturn -ENXIO;\r\n}\r\ns3c = devm_kzalloc(&pdev->dev, sizeof(*s3c), GFP_KERNEL);\r\nif (s3c == NULL) {\r\ndev_err(dev, "failed to allocate pwm_device\n");\r\nreturn -ENOMEM;\r\n}\r\ns3c->tcon_base = id == 0 ? 0 : (id * 4) + 4;\r\ns3c->pwm_id = id;\r\ns3c->chip.dev = &pdev->dev;\r\ns3c->chip.ops = &s3c_pwm_ops;\r\ns3c->chip.base = -1;\r\ns3c->chip.npwm = 1;\r\ns3c->clk = devm_clk_get(dev, "pwm-tin");\r\nif (IS_ERR(s3c->clk)) {\r\ndev_err(dev, "failed to get pwm tin clk\n");\r\nreturn PTR_ERR(s3c->clk);\r\n}\r\ns3c->clk_div = devm_clk_get(dev, "pwm-tdiv");\r\nif (IS_ERR(s3c->clk_div)) {\r\ndev_err(dev, "failed to get pwm tdiv clk\n");\r\nreturn PTR_ERR(s3c->clk_div);\r\n}\r\nclk_enable(s3c->clk);\r\nclk_enable(s3c->clk_div);\r\nlocal_irq_save(flags);\r\ntcon = __raw_readl(S3C2410_TCON);\r\ntcon |= pwm_tcon_invert(s3c);\r\n__raw_writel(tcon, S3C2410_TCON);\r\nlocal_irq_restore(flags);\r\nret = pwmchip_add(&s3c->chip);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register pwm\n");\r\ngoto err_clk_tdiv;\r\n}\r\npwm_dbg(s3c, "config bits %02x\n",\r\n(__raw_readl(S3C2410_TCON) >> s3c->tcon_base) & 0x0f);\r\ndev_info(dev, "tin at %lu, tdiv at %lu, tin=%sclk, base %d\n",\r\nclk_get_rate(s3c->clk),\r\nclk_get_rate(s3c->clk_div),\r\npwm_is_tdiv(s3c) ? "div" : "ext", s3c->tcon_base);\r\nplatform_set_drvdata(pdev, s3c);\r\nreturn 0;\r\nerr_clk_tdiv:\r\nclk_disable(s3c->clk_div);\r\nclk_disable(s3c->clk);\r\nreturn ret;\r\n}\r\nstatic int s3c_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_chip *s3c = platform_get_drvdata(pdev);\r\nint err;\r\nerr = pwmchip_remove(&s3c->chip);\r\nif (err < 0)\r\nreturn err;\r\nclk_disable(s3c->clk_div);\r\nclk_disable(s3c->clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_pwm_suspend(struct device *dev)\r\n{\r\nstruct s3c_chip *s3c = dev_get_drvdata(dev);\r\ns3c->period_ns = 0;\r\ns3c->duty_ns = 0;\r\nreturn 0;\r\n}\r\nstatic int s3c_pwm_resume(struct device *dev)\r\n{\r\nstruct s3c_chip *s3c = dev_get_drvdata(dev);\r\nunsigned long tcon;\r\ntcon = __raw_readl(S3C2410_TCON);\r\ntcon |= pwm_tcon_invert(s3c);\r\n__raw_writel(tcon, S3C2410_TCON);\r\nreturn 0;\r\n}\r\nstatic int __init pwm_init(void)\r\n{\r\nint ret;\r\nclk_scaler[0] = clk_get(NULL, "pwm-scaler0");\r\nclk_scaler[1] = clk_get(NULL, "pwm-scaler1");\r\nif (IS_ERR(clk_scaler[0]) || IS_ERR(clk_scaler[1])) {\r\npr_err("failed to get scaler clocks\n");\r\nreturn -EINVAL;\r\n}\r\nret = platform_driver_register(&s3c_pwm_driver);\r\nif (ret)\r\npr_err("failed to add pwm driver\n");\r\nreturn ret;\r\n}
