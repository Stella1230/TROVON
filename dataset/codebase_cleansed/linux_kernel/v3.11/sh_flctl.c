static void empty_fifo(struct sh_flctl *flctl)\r\n{\r\nwritel(flctl->flintdmacr_base | AC1CLR | AC0CLR, FLINTDMACR(flctl));\r\nwritel(flctl->flintdmacr_base, FLINTDMACR(flctl));\r\n}\r\nstatic void start_translation(struct sh_flctl *flctl)\r\n{\r\nwriteb(TRSTRT, FLTRCR(flctl));\r\n}\r\nstatic void timeout_error(struct sh_flctl *flctl, const char *str)\r\n{\r\ndev_err(&flctl->pdev->dev, "Timeout occurred in %s\n", str);\r\n}\r\nstatic void wait_completion(struct sh_flctl *flctl)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nwhile (timeout--) {\r\nif (readb(FLTRCR(flctl)) & TREND) {\r\nwriteb(0x0, FLTRCR(flctl));\r\nreturn;\r\n}\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\nwriteb(0x0, FLTRCR(flctl));\r\n}\r\nstatic void flctl_dma_complete(void *param)\r\n{\r\nstruct sh_flctl *flctl = param;\r\ncomplete(&flctl->dma_complete);\r\n}\r\nstatic void flctl_release_dma(struct sh_flctl *flctl)\r\n{\r\nif (flctl->chan_fifo0_rx) {\r\ndma_release_channel(flctl->chan_fifo0_rx);\r\nflctl->chan_fifo0_rx = NULL;\r\n}\r\nif (flctl->chan_fifo0_tx) {\r\ndma_release_channel(flctl->chan_fifo0_tx);\r\nflctl->chan_fifo0_tx = NULL;\r\n}\r\n}\r\nstatic void flctl_setup_dma(struct sh_flctl *flctl)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_slave_config cfg;\r\nstruct platform_device *pdev = flctl->pdev;\r\nstruct sh_flctl_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nif (!pdata)\r\nreturn;\r\nif (pdata->slave_id_fifo0_tx <= 0 || pdata->slave_id_fifo0_rx <= 0)\r\nreturn;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nflctl->chan_fifo0_tx = dma_request_channel(mask, shdma_chan_filter,\r\n(void *)pdata->slave_id_fifo0_tx);\r\ndev_dbg(&pdev->dev, "%s: TX: got channel %p\n", __func__,\r\nflctl->chan_fifo0_tx);\r\nif (!flctl->chan_fifo0_tx)\r\nreturn;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.slave_id = pdata->slave_id_fifo0_tx;\r\ncfg.direction = DMA_MEM_TO_DEV;\r\ncfg.dst_addr = (dma_addr_t)FLDTFIFO(flctl);\r\ncfg.src_addr = 0;\r\nret = dmaengine_slave_config(flctl->chan_fifo0_tx, &cfg);\r\nif (ret < 0)\r\ngoto err;\r\nflctl->chan_fifo0_rx = dma_request_channel(mask, shdma_chan_filter,\r\n(void *)pdata->slave_id_fifo0_rx);\r\ndev_dbg(&pdev->dev, "%s: RX: got channel %p\n", __func__,\r\nflctl->chan_fifo0_rx);\r\nif (!flctl->chan_fifo0_rx)\r\ngoto err;\r\ncfg.slave_id = pdata->slave_id_fifo0_rx;\r\ncfg.direction = DMA_DEV_TO_MEM;\r\ncfg.dst_addr = 0;\r\ncfg.src_addr = (dma_addr_t)FLDTFIFO(flctl);\r\nret = dmaengine_slave_config(flctl->chan_fifo0_rx, &cfg);\r\nif (ret < 0)\r\ngoto err;\r\ninit_completion(&flctl->dma_complete);\r\nreturn;\r\nerr:\r\nflctl_release_dma(flctl);\r\n}\r\nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint32_t addr = 0;\r\nif (column == -1) {\r\naddr = page_addr;\r\n} else if (page_addr != -1) {\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nif (flctl->page_size) {\r\naddr = column & 0x0FFF;\r\naddr |= (page_addr & 0xff) << 16;\r\naddr |= ((page_addr >> 8) & 0xff) << 24;\r\nif (flctl->rw_ADRCNT == ADRCNT2_E) {\r\nuint32_t addr2;\r\naddr2 = (page_addr >> 16) & 0xff;\r\nwritel(addr2, FLADR2(flctl));\r\n}\r\n} else {\r\naddr = column;\r\naddr |= (page_addr & 0xff) << 8;\r\naddr |= ((page_addr >> 8) & 0xff) << 16;\r\naddr |= ((page_addr >> 16) & 0xff) << 24;\r\n}\r\n}\r\nwritel(addr, FLADR(flctl));\r\n}\r\nstatic void wait_rfifo_ready(struct sh_flctl *flctl)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nwhile (timeout--) {\r\nuint32_t val;\r\nval = readl(FLDTCNTR(flctl)) >> 16;\r\nif (val & 0xFF)\r\nreturn;\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\n}\r\nstatic void wait_wfifo_ready(struct sh_flctl *flctl)\r\n{\r\nuint32_t len, timeout = LOOP_TIMEOUT_MAX;\r\nwhile (timeout--) {\r\nlen = (readl(FLDTCNTR(flctl)) >> 16) & 0xFF;\r\nif (len >= 4)\r\nreturn;\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\n}\r\nstatic enum flctl_ecc_res_t wait_recfifo_ready\r\n(struct sh_flctl *flctl, int sector_number)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nvoid __iomem *ecc_reg[4];\r\nint i;\r\nint state = FL_SUCCESS;\r\nuint32_t data, size;\r\nwhile (timeout--) {\r\nsize = readl(FLDTCNTR(flctl)) >> 24;\r\nif ((size & 0xFF) == 4)\r\nreturn state;\r\nif (!(readl(FL4ECCCR(flctl)) & _4ECCEND)) {\r\nudelay(1);\r\ncontinue;\r\n}\r\nif (readl(FL4ECCCR(flctl)) & _4ECCFA) {\r\nfor (i = 0; i < 512; i++) {\r\nif (flctl->done_buff[i] != 0xff) {\r\nstate = FL_ERROR;\r\nbreak;\r\n}\r\n}\r\nif (state == FL_SUCCESS)\r\ndev_dbg(&flctl->pdev->dev,\r\n"reading empty sector %d, ecc error ignored\n",\r\nsector_number);\r\nwritel(0, FL4ECCCR(flctl));\r\ncontinue;\r\n}\r\necc_reg[0] = FL4ECCRESULT0(flctl);\r\necc_reg[1] = FL4ECCRESULT1(flctl);\r\necc_reg[2] = FL4ECCRESULT2(flctl);\r\necc_reg[3] = FL4ECCRESULT3(flctl);\r\nfor (i = 0; i < 3; i++) {\r\nuint8_t org;\r\nunsigned int index;\r\ndata = readl(ecc_reg[i]);\r\nif (flctl->page_size)\r\nindex = (512 * sector_number) +\r\n(data >> 16);\r\nelse\r\nindex = data >> 16;\r\norg = flctl->done_buff[index];\r\nflctl->done_buff[index] = org ^ (data & 0xFF);\r\n}\r\nstate = FL_REPAIRABLE;\r\nwritel(0, FL4ECCCR(flctl));\r\n}\r\ntimeout_error(flctl, __func__);\r\nreturn FL_TIMEOUT;\r\n}\r\nstatic void wait_wecfifo_ready(struct sh_flctl *flctl)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nuint32_t len;\r\nwhile (timeout--) {\r\nlen = (readl(FLDTCNTR(flctl)) >> 24) & 0xFF;\r\nif (len >= 4)\r\nreturn;\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\n}\r\nstatic int flctl_dma_fifo0_transfer(struct sh_flctl *flctl, unsigned long *buf,\r\nint len, enum dma_data_direction dir)\r\n{\r\nstruct dma_async_tx_descriptor *desc = NULL;\r\nstruct dma_chan *chan;\r\nenum dma_transfer_direction tr_dir;\r\ndma_addr_t dma_addr;\r\ndma_cookie_t cookie = -EINVAL;\r\nuint32_t reg;\r\nint ret;\r\nif (dir == DMA_FROM_DEVICE) {\r\nchan = flctl->chan_fifo0_rx;\r\ntr_dir = DMA_DEV_TO_MEM;\r\n} else {\r\nchan = flctl->chan_fifo0_tx;\r\ntr_dir = DMA_MEM_TO_DEV;\r\n}\r\ndma_addr = dma_map_single(chan->device->dev, buf, len, dir);\r\nif (dma_addr)\r\ndesc = dmaengine_prep_slave_single(chan, dma_addr, len,\r\ntr_dir, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (desc) {\r\nreg = readl(FLINTDMACR(flctl));\r\nreg |= DREQ0EN;\r\nwritel(reg, FLINTDMACR(flctl));\r\ndesc->callback = flctl_dma_complete;\r\ndesc->callback_param = flctl;\r\ncookie = dmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\n} else {\r\nflctl_release_dma(flctl);\r\ndev_warn(&flctl->pdev->dev,\r\n"DMA failed, falling back to PIO\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret =\r\nwait_for_completion_timeout(&flctl->dma_complete,\r\nmsecs_to_jiffies(3000));\r\nif (ret <= 0) {\r\nchan->device->device_control(chan, DMA_TERMINATE_ALL, 0);\r\ndev_err(&flctl->pdev->dev, "wait_for_completion_timeout\n");\r\n}\r\nout:\r\nreg = readl(FLINTDMACR(flctl));\r\nreg &= ~DREQ0EN;\r\nwritel(reg, FLINTDMACR(flctl));\r\ndma_unmap_single(chan->device->dev, dma_addr, len, dir);\r\nreturn ret;\r\n}\r\nstatic void read_datareg(struct sh_flctl *flctl, int offset)\r\n{\r\nunsigned long data;\r\nunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\r\nwait_completion(flctl);\r\ndata = readl(FLDATAR(flctl));\r\n*buf = le32_to_cpu(data);\r\n}\r\nstatic void read_fiforeg(struct sh_flctl *flctl, int rlen, int offset)\r\n{\r\nint i, len_4align;\r\nunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\r\nlen_4align = (rlen + 3) / 4;\r\nif (flctl->chan_fifo0_rx && rlen >= 32 &&\r\nflctl_dma_fifo0_transfer(flctl, buf, rlen, DMA_DEV_TO_MEM) > 0)\r\ngoto convert;\r\nfor (i = 0; i < len_4align; i++) {\r\nwait_rfifo_ready(flctl);\r\nbuf[i] = readl(FLDTFIFO(flctl));\r\n}\r\nconvert:\r\nfor (i = 0; i < len_4align; i++)\r\nbuf[i] = be32_to_cpu(buf[i]);\r\n}\r\nstatic enum flctl_ecc_res_t read_ecfiforeg\r\n(struct sh_flctl *flctl, uint8_t *buff, int sector)\r\n{\r\nint i;\r\nenum flctl_ecc_res_t res;\r\nunsigned long *ecc_buf = (unsigned long *)buff;\r\nres = wait_recfifo_ready(flctl , sector);\r\nif (res != FL_ERROR) {\r\nfor (i = 0; i < 4; i++) {\r\necc_buf[i] = readl(FLECFIFO(flctl));\r\necc_buf[i] = be32_to_cpu(ecc_buf[i]);\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic void write_fiforeg(struct sh_flctl *flctl, int rlen,\r\nunsigned int offset)\r\n{\r\nint i, len_4align;\r\nunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\r\nlen_4align = (rlen + 3) / 4;\r\nfor (i = 0; i < len_4align; i++) {\r\nwait_wfifo_ready(flctl);\r\nwritel(cpu_to_be32(buf[i]), FLDTFIFO(flctl));\r\n}\r\n}\r\nstatic void write_ec_fiforeg(struct sh_flctl *flctl, int rlen,\r\nunsigned int offset)\r\n{\r\nint i, len_4align;\r\nunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\r\nlen_4align = (rlen + 3) / 4;\r\nfor (i = 0; i < len_4align; i++)\r\nbuf[i] = cpu_to_be32(buf[i]);\r\nif (flctl->chan_fifo0_tx && rlen >= 32 &&\r\nflctl_dma_fifo0_transfer(flctl, buf, rlen, DMA_MEM_TO_DEV) > 0)\r\nreturn;\r\nfor (i = 0; i < len_4align; i++) {\r\nwait_wecfifo_ready(flctl);\r\nwritel(buf[i], FLECFIFO(flctl));\r\n}\r\n}\r\nstatic void set_cmd_regs(struct mtd_info *mtd, uint32_t cmd, uint32_t flcmcdr_val)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint32_t flcmncr_val = flctl->flcmncr_base & ~SEL_16BIT;\r\nuint32_t flcmdcr_val, addr_len_bytes = 0;\r\nif (flctl->page_size)\r\nflcmncr_val |= SNAND_E;\r\nelse\r\nflcmncr_val &= ~SNAND_E;\r\nflcmdcr_val = DOCMD1_E | DOADR_E;\r\nswitch (cmd) {\r\ncase NAND_CMD_ERASE1:\r\naddr_len_bytes = flctl->erase_ADRCNT;\r\nflcmdcr_val |= DOCMD2_E;\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_RNDOUT:\r\naddr_len_bytes = flctl->rw_ADRCNT;\r\nflcmdcr_val |= CDSRC_E;\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\nflcmncr_val |= SEL_16BIT;\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nflcmdcr_val &= ~DOADR_E;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\naddr_len_bytes = flctl->rw_ADRCNT;\r\nflcmdcr_val |= DOCMD2_E | CDSRC_E | SELRW;\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\nflcmncr_val |= SEL_16BIT;\r\nbreak;\r\ncase NAND_CMD_READID:\r\nflcmncr_val &= ~SNAND_E;\r\nflcmdcr_val |= CDSRC_E;\r\naddr_len_bytes = ADRCNT_1;\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_RESET:\r\nflcmncr_val &= ~SNAND_E;\r\nflcmdcr_val &= ~(DOADR_E | DOSR_E);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nflcmdcr_val |= addr_len_bytes;\r\nwritel(flcmncr_val, FLCMNCR(flctl));\r\nwritel(flcmdcr_val, FLCMDCR(flctl));\r\nwritel(flcmcdr_val, FLCMCDR(flctl));\r\n}\r\nstatic int flctl_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int flctl_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic void execmd_read_page_sector(struct mtd_info *mtd, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint sector, page_sectors;\r\nenum flctl_ecc_res_t ecc_result;\r\npage_sectors = flctl->page_size ? 4 : 1;\r\nset_cmd_regs(mtd, NAND_CMD_READ0,\r\n(NAND_CMD_READSTART << 8) | NAND_CMD_READ0);\r\nwritel(readl(FLCMNCR(flctl)) | ACM_SACCES_MODE | _4ECCCORRECT,\r\nFLCMNCR(flctl));\r\nwritel(readl(FLCMDCR(flctl)) | page_sectors, FLCMDCR(flctl));\r\nwritel(page_addr << 2, FLADR(flctl));\r\nempty_fifo(flctl);\r\nstart_translation(flctl);\r\nfor (sector = 0; sector < page_sectors; sector++) {\r\nread_fiforeg(flctl, 512, 512 * sector);\r\necc_result = read_ecfiforeg(flctl,\r\n&flctl->done_buff[mtd->writesize + 16 * sector],\r\nsector);\r\nswitch (ecc_result) {\r\ncase FL_REPAIRABLE:\r\ndev_info(&flctl->pdev->dev,\r\n"applied ecc on page 0x%x", page_addr);\r\nflctl->mtd.ecc_stats.corrected++;\r\nbreak;\r\ncase FL_ERROR:\r\ndev_warn(&flctl->pdev->dev,\r\n"page 0x%x contains corrupted data\n",\r\npage_addr);\r\nflctl->mtd.ecc_stats.failed++;\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n}\r\nwait_completion(flctl);\r\nwritel(readl(FLCMNCR(flctl)) & ~(ACM_SACCES_MODE | _4ECCCORRECT),\r\nFLCMNCR(flctl));\r\n}\r\nstatic void execmd_read_oob(struct mtd_info *mtd, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint page_sectors = flctl->page_size ? 4 : 1;\r\nint i;\r\nset_cmd_regs(mtd, NAND_CMD_READ0,\r\n(NAND_CMD_READSTART << 8) | NAND_CMD_READ0);\r\nempty_fifo(flctl);\r\nfor (i = 0; i < page_sectors; i++) {\r\nset_addr(mtd, (512 + 16) * i + 512 , page_addr);\r\nwritel(16, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, 16, 16 * i);\r\nwait_completion(flctl);\r\n}\r\n}\r\nstatic void execmd_write_page_sector(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint page_addr = flctl->seqin_page_addr;\r\nint sector, page_sectors;\r\npage_sectors = flctl->page_size ? 4 : 1;\r\nset_cmd_regs(mtd, NAND_CMD_PAGEPROG,\r\n(NAND_CMD_PAGEPROG << 8) | NAND_CMD_SEQIN);\r\nempty_fifo(flctl);\r\nwritel(readl(FLCMNCR(flctl)) | ACM_SACCES_MODE, FLCMNCR(flctl));\r\nwritel(readl(FLCMDCR(flctl)) | page_sectors, FLCMDCR(flctl));\r\nwritel(page_addr << 2, FLADR(flctl));\r\nstart_translation(flctl);\r\nfor (sector = 0; sector < page_sectors; sector++) {\r\nwrite_fiforeg(flctl, 512, 512 * sector);\r\nwrite_ec_fiforeg(flctl, 16, mtd->writesize + 16 * sector);\r\n}\r\nwait_completion(flctl);\r\nwritel(readl(FLCMNCR(flctl)) & ~ACM_SACCES_MODE, FLCMNCR(flctl));\r\n}\r\nstatic void execmd_write_oob(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint page_addr = flctl->seqin_page_addr;\r\nint sector, page_sectors;\r\npage_sectors = flctl->page_size ? 4 : 1;\r\nset_cmd_regs(mtd, NAND_CMD_PAGEPROG,\r\n(NAND_CMD_PAGEPROG << 8) | NAND_CMD_SEQIN);\r\nfor (sector = 0; sector < page_sectors; sector++) {\r\nempty_fifo(flctl);\r\nset_addr(mtd, sector * 528 + 512, page_addr);\r\nwritel(16, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwrite_fiforeg(flctl, 16, 16 * sector);\r\nwait_completion(flctl);\r\n}\r\n}\r\nstatic void flctl_cmdfunc(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint32_t read_cmd = 0;\r\npm_runtime_get_sync(&flctl->pdev->dev);\r\nflctl->read_bytes = 0;\r\nif (command != NAND_CMD_PAGEPROG)\r\nflctl->index = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ1:\r\ncase NAND_CMD_READ0:\r\nif (flctl->hwecc) {\r\nexecmd_read_page_sector(mtd, page_addr);\r\nbreak;\r\n}\r\nif (flctl->page_size)\r\nset_cmd_regs(mtd, command, (NAND_CMD_READSTART << 8)\r\n| command);\r\nelse\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, 0, page_addr);\r\nflctl->read_bytes = mtd->writesize + mtd->oobsize;\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nflctl->index += column;\r\ngoto read_normal_exit;\r\ncase NAND_CMD_READOOB:\r\nif (flctl->hwecc) {\r\nexecmd_read_oob(mtd, page_addr);\r\nbreak;\r\n}\r\nif (flctl->page_size) {\r\nset_cmd_regs(mtd, command, (NAND_CMD_READSTART << 8)\r\n| NAND_CMD_READ0);\r\nset_addr(mtd, mtd->writesize, page_addr);\r\n} else {\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, 0, page_addr);\r\n}\r\nflctl->read_bytes = mtd->oobsize;\r\ngoto read_normal_exit;\r\ncase NAND_CMD_RNDOUT:\r\nif (flctl->hwecc)\r\nbreak;\r\nif (flctl->page_size)\r\nset_cmd_regs(mtd, command, (NAND_CMD_RNDOUTSTART << 8)\r\n| command);\r\nelse\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, column, 0);\r\nflctl->read_bytes = mtd->writesize + mtd->oobsize - column;\r\ngoto read_normal_exit;\r\ncase NAND_CMD_READID:\r\nset_cmd_regs(mtd, command, command);\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\ncolumn <<= 1;\r\nset_addr(mtd, column, 0);\r\nflctl->read_bytes = 8;\r\nwritel(flctl->read_bytes, FLDTCNTR(flctl));\r\nempty_fifo(flctl);\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, flctl->read_bytes, 0);\r\nwait_completion(flctl);\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nflctl->erase1_page_addr = page_addr;\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nset_cmd_regs(mtd, NAND_CMD_ERASE1,\r\n(command << 8) | NAND_CMD_ERASE1);\r\nset_addr(mtd, -1, flctl->erase1_page_addr);\r\nstart_translation(flctl);\r\nwait_completion(flctl);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nif (!flctl->page_size) {\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nread_cmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nread_cmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nread_cmd = NAND_CMD_READ1;\r\n}\r\n}\r\nflctl->seqin_column = column;\r\nflctl->seqin_page_addr = page_addr;\r\nflctl->seqin_read_cmd = read_cmd;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nempty_fifo(flctl);\r\nif (!flctl->page_size) {\r\nset_cmd_regs(mtd, NAND_CMD_SEQIN,\r\nflctl->seqin_read_cmd);\r\nset_addr(mtd, -1, -1);\r\nwritel(0, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwait_completion(flctl);\r\n}\r\nif (flctl->hwecc) {\r\nif (flctl->seqin_column == mtd->writesize)\r\nexecmd_write_oob(mtd);\r\nelse if (!flctl->seqin_column)\r\nexecmd_write_page_sector(mtd);\r\nelse\r\nprintk(KERN_ERR "Invalid address !?\n");\r\nbreak;\r\n}\r\nset_cmd_regs(mtd, command, (command << 8) | NAND_CMD_SEQIN);\r\nset_addr(mtd, flctl->seqin_column, flctl->seqin_page_addr);\r\nwritel(flctl->index, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwrite_fiforeg(flctl, flctl->index, 0);\r\nwait_completion(flctl);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, -1, -1);\r\nflctl->read_bytes = 1;\r\nwritel(flctl->read_bytes, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nread_datareg(flctl, 0);\r\nbreak;\r\ncase NAND_CMD_RESET:\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, -1, -1);\r\nwritel(0, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwait_completion(flctl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ngoto runtime_exit;\r\nread_normal_exit:\r\nwritel(flctl->read_bytes, FLDTCNTR(flctl));\r\nempty_fifo(flctl);\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, flctl->read_bytes, 0);\r\nwait_completion(flctl);\r\nruntime_exit:\r\npm_runtime_put_sync(&flctl->pdev->dev);\r\nreturn;\r\n}\r\nstatic void flctl_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint ret;\r\nswitch (chipnr) {\r\ncase -1:\r\nflctl->flcmncr_base &= ~CE0_ENABLE;\r\npm_runtime_get_sync(&flctl->pdev->dev);\r\nwritel(flctl->flcmncr_base, FLCMNCR(flctl));\r\nif (flctl->qos_request) {\r\ndev_pm_qos_remove_request(&flctl->pm_qos);\r\nflctl->qos_request = 0;\r\n}\r\npm_runtime_put_sync(&flctl->pdev->dev);\r\nbreak;\r\ncase 0:\r\nflctl->flcmncr_base |= CE0_ENABLE;\r\nif (!flctl->qos_request) {\r\nret = dev_pm_qos_add_request(&flctl->pdev->dev,\r\n&flctl->pm_qos,\r\nDEV_PM_QOS_LATENCY,\r\n100);\r\nif (ret < 0)\r\ndev_err(&flctl->pdev->dev,\r\n"PM QoS request failed: %d\n", ret);\r\nflctl->qos_request = 1;\r\n}\r\nif (flctl->holden) {\r\npm_runtime_get_sync(&flctl->pdev->dev);\r\nwritel(HOLDEN, FLHOLDCR(flctl));\r\npm_runtime_put_sync(&flctl->pdev->dev);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void flctl_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nmemcpy(&flctl->done_buff[flctl->index], buf, len);\r\nflctl->index += len;\r\n}\r\nstatic uint8_t flctl_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint8_t data;\r\ndata = flctl->done_buff[flctl->index];\r\nflctl->index++;\r\nreturn data;\r\n}\r\nstatic uint16_t flctl_read_word(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint16_t *buf = (uint16_t *)&flctl->done_buff[flctl->index];\r\nflctl->index += 2;\r\nreturn *buf;\r\n}\r\nstatic void flctl_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nmemcpy(buf, &flctl->done_buff[flctl->index], len);\r\nflctl->index += len;\r\n}\r\nstatic int flctl_chip_init_tail(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nstruct nand_chip *chip = &flctl->chip;\r\nif (mtd->writesize == 512) {\r\nflctl->page_size = 0;\r\nif (chip->chipsize > (32 << 20)) {\r\nflctl->rw_ADRCNT = ADRCNT_4;\r\nflctl->erase_ADRCNT = ADRCNT_3;\r\n} else if (chip->chipsize > (2 << 16)) {\r\nflctl->rw_ADRCNT = ADRCNT_3;\r\nflctl->erase_ADRCNT = ADRCNT_2;\r\n} else {\r\nflctl->rw_ADRCNT = ADRCNT_2;\r\nflctl->erase_ADRCNT = ADRCNT_1;\r\n}\r\n} else {\r\nflctl->page_size = 1;\r\nif (chip->chipsize > (128 << 20)) {\r\nflctl->rw_ADRCNT = ADRCNT2_E;\r\nflctl->erase_ADRCNT = ADRCNT_3;\r\n} else if (chip->chipsize > (8 << 16)) {\r\nflctl->rw_ADRCNT = ADRCNT_4;\r\nflctl->erase_ADRCNT = ADRCNT_2;\r\n} else {\r\nflctl->rw_ADRCNT = ADRCNT_3;\r\nflctl->erase_ADRCNT = ADRCNT_1;\r\n}\r\n}\r\nif (flctl->hwecc) {\r\nif (mtd->writesize == 512) {\r\nchip->ecc.layout = &flctl_4secc_oob_16;\r\nchip->badblock_pattern = &flctl_4secc_smallpage;\r\n} else {\r\nchip->ecc.layout = &flctl_4secc_oob_64;\r\nchip->badblock_pattern = &flctl_4secc_largepage;\r\n}\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 10;\r\nchip->ecc.strength = 4;\r\nchip->ecc.read_page = flctl_read_page_hwecc;\r\nchip->ecc.write_page = flctl_write_page_hwecc;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nflctl->flcmncr_base |= _4ECCEN;\r\n} else {\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t flctl_handle_flste(int irq, void *dev_id)\r\n{\r\nstruct sh_flctl *flctl = dev_id;\r\ndev_err(&flctl->pdev->dev, "flste irq: %x\n", readl(FLINTDMACR(flctl)));\r\nwritel(flctl->flintdmacr_base, FLINTDMACR(flctl));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct sh_flctl_platform_data *flctl_parse_dt(struct device *dev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct flctl_soc_config *config;\r\nstruct sh_flctl_platform_data *pdata;\r\nstruct device_node *dn = dev->of_node;\r\nint ret;\r\nmatch = of_match_device(of_flctl_match, dev);\r\nif (match)\r\nconfig = (struct flctl_soc_config *)match->data;\r\nelse {\r\ndev_err(dev, "%s: no OF configuration attached\n", __func__);\r\nreturn NULL;\r\n}\r\npdata = devm_kzalloc(dev, sizeof(struct sh_flctl_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "%s: failed to allocate config data\n", __func__);\r\nreturn NULL;\r\n}\r\npdata->flcmncr_val = config->flcmncr_val;\r\npdata->has_hwecc = config->has_hwecc;\r\npdata->use_holden = config->use_holden;\r\nret = of_get_nand_bus_width(dn);\r\nif (ret == 16)\r\npdata->flcmncr_val |= SEL_16BIT;\r\nelse if (ret != 8) {\r\ndev_err(dev, "%s: invalid bus width\n", __func__);\r\nreturn NULL;\r\n}\r\nreturn pdata;\r\n}\r\nstatic struct sh_flctl_platform_data *flctl_parse_dt(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int flctl_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct sh_flctl *flctl;\r\nstruct mtd_info *flctl_mtd;\r\nstruct nand_chip *nand;\r\nstruct sh_flctl_platform_data *pdata;\r\nint ret = -ENXIO;\r\nint irq;\r\nstruct mtd_part_parser_data ppdata = {};\r\nflctl = kzalloc(sizeof(struct sh_flctl), GFP_KERNEL);\r\nif (!flctl) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\ngoto err_iomap;\r\n}\r\nflctl->reg = ioremap(res->start, resource_size(res));\r\nif (flctl->reg == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\ngoto err_iomap;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get flste irq data\n");\r\ngoto err_flste;\r\n}\r\nret = request_irq(irq, flctl_handle_flste, IRQF_SHARED, "flste", flctl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request interrupt failed.\n");\r\ngoto err_flste;\r\n}\r\nif (pdev->dev.of_node)\r\npdata = flctl_parse_dt(&pdev->dev);\r\nelse\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no setup data defined\n");\r\nret = -EINVAL;\r\ngoto err_pdata;\r\n}\r\nplatform_set_drvdata(pdev, flctl);\r\nflctl_mtd = &flctl->mtd;\r\nnand = &flctl->chip;\r\nflctl_mtd->priv = nand;\r\nflctl->pdev = pdev;\r\nflctl->hwecc = pdata->has_hwecc;\r\nflctl->holden = pdata->use_holden;\r\nflctl->flcmncr_base = pdata->flcmncr_val;\r\nflctl->flintdmacr_base = flctl->hwecc ? (STERINTE | ECERB) : STERINTE;\r\nnand->chip_delay = 20;\r\nnand->read_byte = flctl_read_byte;\r\nnand->write_buf = flctl_write_buf;\r\nnand->read_buf = flctl_read_buf;\r\nnand->select_chip = flctl_select_chip;\r\nnand->cmdfunc = flctl_cmdfunc;\r\nif (pdata->flcmncr_val & SEL_16BIT) {\r\nnand->options |= NAND_BUSWIDTH_16;\r\nnand->read_word = flctl_read_word;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\nflctl_setup_dma(flctl);\r\nret = nand_scan_ident(flctl_mtd, 1, NULL);\r\nif (ret)\r\ngoto err_chip;\r\nret = flctl_chip_init_tail(flctl_mtd);\r\nif (ret)\r\ngoto err_chip;\r\nret = nand_scan_tail(flctl_mtd);\r\nif (ret)\r\ngoto err_chip;\r\nppdata.of_node = pdev->dev.of_node;\r\nret = mtd_device_parse_register(flctl_mtd, NULL, &ppdata, pdata->parts,\r\npdata->nr_parts);\r\nreturn 0;\r\nerr_chip:\r\nflctl_release_dma(flctl);\r\npm_runtime_disable(&pdev->dev);\r\nerr_pdata:\r\nfree_irq(irq, flctl);\r\nerr_flste:\r\niounmap(flctl->reg);\r\nerr_iomap:\r\nkfree(flctl);\r\nreturn ret;\r\n}\r\nstatic int flctl_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_flctl *flctl = platform_get_drvdata(pdev);\r\nflctl_release_dma(flctl);\r\nnand_release(&flctl->mtd);\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(platform_get_irq(pdev, 0), flctl);\r\niounmap(flctl->reg);\r\nkfree(flctl);\r\nreturn 0;\r\n}
