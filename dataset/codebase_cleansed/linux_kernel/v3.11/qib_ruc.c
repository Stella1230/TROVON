static int qib_init_sge(struct qib_qp *qp, struct qib_rwqe *wqe)\r\n{\r\nint i, j, ret;\r\nstruct ib_wc wc;\r\nstruct qib_lkey_table *rkt;\r\nstruct qib_pd *pd;\r\nstruct qib_sge_state *ss;\r\nrkt = &to_idev(qp->ibqp.device)->lk_table;\r\npd = to_ipd(qp->ibqp.srq ? qp->ibqp.srq->pd : qp->ibqp.pd);\r\nss = &qp->r_sge;\r\nss->sg_list = qp->r_sg_list;\r\nqp->r_len = 0;\r\nfor (i = j = 0; i < wqe->num_sge; i++) {\r\nif (wqe->sg_list[i].length == 0)\r\ncontinue;\r\nif (!qib_lkey_ok(rkt, pd, j ? &ss->sg_list[j - 1] : &ss->sge,\r\n&wqe->sg_list[i], IB_ACCESS_LOCAL_WRITE))\r\ngoto bad_lkey;\r\nqp->r_len += wqe->sg_list[i].length;\r\nj++;\r\n}\r\nss->num_sge = j;\r\nss->total_len = qp->r_len;\r\nret = 1;\r\ngoto bail;\r\nbad_lkey:\r\nwhile (j) {\r\nstruct qib_sge *sge = --j ? &ss->sg_list[j - 1] : &ss->sge;\r\nqib_put_mr(sge->mr);\r\n}\r\nss->num_sge = 0;\r\nmemset(&wc, 0, sizeof(wc));\r\nwc.wr_id = wqe->wr_id;\r\nwc.status = IB_WC_LOC_PROT_ERR;\r\nwc.opcode = IB_WC_RECV;\r\nwc.qp = &qp->ibqp;\r\nqib_cq_enter(to_icq(qp->ibqp.recv_cq), &wc, 1);\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nint qib_get_rwqe(struct qib_qp *qp, int wr_id_only)\r\n{\r\nunsigned long flags;\r\nstruct qib_rq *rq;\r\nstruct qib_rwq *wq;\r\nstruct qib_srq *srq;\r\nstruct qib_rwqe *wqe;\r\nvoid (*handler)(struct ib_event *, void *);\r\nu32 tail;\r\nint ret;\r\nif (qp->ibqp.srq) {\r\nsrq = to_isrq(qp->ibqp.srq);\r\nhandler = srq->ibsrq.event_handler;\r\nrq = &srq->rq;\r\n} else {\r\nsrq = NULL;\r\nhandler = NULL;\r\nrq = &qp->r_rq;\r\n}\r\nspin_lock_irqsave(&rq->lock, flags);\r\nif (!(ib_qib_state_ops[qp->state] & QIB_PROCESS_RECV_OK)) {\r\nret = 0;\r\ngoto unlock;\r\n}\r\nwq = rq->wq;\r\ntail = wq->tail;\r\nif (tail >= rq->size)\r\ntail = 0;\r\nif (unlikely(tail == wq->head)) {\r\nret = 0;\r\ngoto unlock;\r\n}\r\nsmp_rmb();\r\nwqe = get_rwqe_ptr(rq, tail);\r\nif (++tail >= rq->size)\r\ntail = 0;\r\nwq->tail = tail;\r\nif (!wr_id_only && !qib_init_sge(qp, wqe)) {\r\nret = -1;\r\ngoto unlock;\r\n}\r\nqp->r_wr_id = wqe->wr_id;\r\nret = 1;\r\nset_bit(QIB_R_WRID_VALID, &qp->r_aflags);\r\nif (handler) {\r\nu32 n;\r\nn = wq->head;\r\nif (n >= rq->size)\r\nn = 0;\r\nif (n < tail)\r\nn += rq->size - tail;\r\nelse\r\nn -= tail;\r\nif (n < srq->limit) {\r\nstruct ib_event ev;\r\nsrq->limit = 0;\r\nspin_unlock_irqrestore(&rq->lock, flags);\r\nev.device = qp->ibqp.device;\r\nev.element.srq = qp->ibqp.srq;\r\nev.event = IB_EVENT_SRQ_LIMIT_REACHED;\r\nhandler(&ev, srq->ibsrq.srq_context);\r\ngoto bail;\r\n}\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&rq->lock, flags);\r\nbail:\r\nreturn ret;\r\n}\r\nvoid qib_migrate_qp(struct qib_qp *qp)\r\n{\r\nstruct ib_event ev;\r\nqp->s_mig_state = IB_MIG_MIGRATED;\r\nqp->remote_ah_attr = qp->alt_ah_attr;\r\nqp->port_num = qp->alt_ah_attr.port_num;\r\nqp->s_pkey_index = qp->s_alt_pkey_index;\r\nev.device = qp->ibqp.device;\r\nev.element.qp = &qp->ibqp;\r\nev.event = IB_EVENT_PATH_MIG;\r\nqp->ibqp.event_handler(&ev, qp->ibqp.qp_context);\r\n}\r\nstatic __be64 get_sguid(struct qib_ibport *ibp, unsigned index)\r\n{\r\nif (!index) {\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nreturn ppd->guid;\r\n} else\r\nreturn ibp->guids[index - 1];\r\n}\r\nstatic int gid_ok(union ib_gid *gid, __be64 gid_prefix, __be64 id)\r\n{\r\nreturn (gid->global.interface_id == id &&\r\n(gid->global.subnet_prefix == gid_prefix ||\r\ngid->global.subnet_prefix == IB_DEFAULT_GID_PREFIX));\r\n}\r\nint qib_ruc_check_hdr(struct qib_ibport *ibp, struct qib_ib_header *hdr,\r\nint has_grh, struct qib_qp *qp, u32 bth0)\r\n{\r\n__be64 guid;\r\nunsigned long flags;\r\nif (qp->s_mig_state == IB_MIG_ARMED && (bth0 & IB_BTH_MIG_REQ)) {\r\nif (!has_grh) {\r\nif (qp->alt_ah_attr.ah_flags & IB_AH_GRH)\r\ngoto err;\r\n} else {\r\nif (!(qp->alt_ah_attr.ah_flags & IB_AH_GRH))\r\ngoto err;\r\nguid = get_sguid(ibp, qp->alt_ah_attr.grh.sgid_index);\r\nif (!gid_ok(&hdr->u.l.grh.dgid, ibp->gid_prefix, guid))\r\ngoto err;\r\nif (!gid_ok(&hdr->u.l.grh.sgid,\r\nqp->alt_ah_attr.grh.dgid.global.subnet_prefix,\r\nqp->alt_ah_attr.grh.dgid.global.interface_id))\r\ngoto err;\r\n}\r\nif (!qib_pkey_ok((u16)bth0,\r\nqib_get_pkey(ibp, qp->s_alt_pkey_index))) {\r\nqib_bad_pqkey(ibp, IB_NOTICE_TRAP_BAD_PKEY,\r\n(u16)bth0,\r\n(be16_to_cpu(hdr->lrh[0]) >> 4) & 0xF,\r\n0, qp->ibqp.qp_num,\r\nhdr->lrh[3], hdr->lrh[1]);\r\ngoto err;\r\n}\r\nif (be16_to_cpu(hdr->lrh[3]) != qp->alt_ah_attr.dlid ||\r\nppd_from_ibp(ibp)->port != qp->alt_ah_attr.port_num)\r\ngoto err;\r\nspin_lock_irqsave(&qp->s_lock, flags);\r\nqib_migrate_qp(qp);\r\nspin_unlock_irqrestore(&qp->s_lock, flags);\r\n} else {\r\nif (!has_grh) {\r\nif (qp->remote_ah_attr.ah_flags & IB_AH_GRH)\r\ngoto err;\r\n} else {\r\nif (!(qp->remote_ah_attr.ah_flags & IB_AH_GRH))\r\ngoto err;\r\nguid = get_sguid(ibp,\r\nqp->remote_ah_attr.grh.sgid_index);\r\nif (!gid_ok(&hdr->u.l.grh.dgid, ibp->gid_prefix, guid))\r\ngoto err;\r\nif (!gid_ok(&hdr->u.l.grh.sgid,\r\nqp->remote_ah_attr.grh.dgid.global.subnet_prefix,\r\nqp->remote_ah_attr.grh.dgid.global.interface_id))\r\ngoto err;\r\n}\r\nif (!qib_pkey_ok((u16)bth0,\r\nqib_get_pkey(ibp, qp->s_pkey_index))) {\r\nqib_bad_pqkey(ibp, IB_NOTICE_TRAP_BAD_PKEY,\r\n(u16)bth0,\r\n(be16_to_cpu(hdr->lrh[0]) >> 4) & 0xF,\r\n0, qp->ibqp.qp_num,\r\nhdr->lrh[3], hdr->lrh[1]);\r\ngoto err;\r\n}\r\nif (be16_to_cpu(hdr->lrh[3]) != qp->remote_ah_attr.dlid ||\r\nppd_from_ibp(ibp)->port != qp->port_num)\r\ngoto err;\r\nif (qp->s_mig_state == IB_MIG_REARM &&\r\n!(bth0 & IB_BTH_MIG_REQ))\r\nqp->s_mig_state = IB_MIG_ARMED;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn 1;\r\n}\r\nstatic void qib_ruc_loopback(struct qib_qp *sqp)\r\n{\r\nstruct qib_ibport *ibp = to_iport(sqp->ibqp.device, sqp->port_num);\r\nstruct qib_qp *qp;\r\nstruct qib_swqe *wqe;\r\nstruct qib_sge *sge;\r\nunsigned long flags;\r\nstruct ib_wc wc;\r\nu64 sdata;\r\natomic64_t *maddr;\r\nenum ib_wc_status send_status;\r\nint release;\r\nint ret;\r\nqp = qib_lookup_qpn(ibp, sqp->remote_qpn);\r\nspin_lock_irqsave(&sqp->s_lock, flags);\r\nif ((sqp->s_flags & (QIB_S_BUSY | QIB_S_ANY_WAIT)) ||\r\n!(ib_qib_state_ops[sqp->state] & QIB_PROCESS_OR_FLUSH_SEND))\r\ngoto unlock;\r\nsqp->s_flags |= QIB_S_BUSY;\r\nagain:\r\nif (sqp->s_last == sqp->s_head)\r\ngoto clr_busy;\r\nwqe = get_swqe_ptr(sqp, sqp->s_last);\r\nif (!(ib_qib_state_ops[sqp->state] & QIB_PROCESS_NEXT_SEND_OK)) {\r\nif (!(ib_qib_state_ops[sqp->state] & QIB_FLUSH_SEND))\r\ngoto clr_busy;\r\nsend_status = IB_WC_WR_FLUSH_ERR;\r\ngoto flush_send;\r\n}\r\nif (sqp->s_last == sqp->s_cur) {\r\nif (++sqp->s_cur >= sqp->s_size)\r\nsqp->s_cur = 0;\r\n}\r\nspin_unlock_irqrestore(&sqp->s_lock, flags);\r\nif (!qp || !(ib_qib_state_ops[qp->state] & QIB_PROCESS_RECV_OK) ||\r\nqp->ibqp.qp_type != sqp->ibqp.qp_type) {\r\nibp->n_pkt_drops++;\r\nif (sqp->ibqp.qp_type == IB_QPT_RC)\r\nsend_status = IB_WC_RETRY_EXC_ERR;\r\nelse\r\nsend_status = IB_WC_SUCCESS;\r\ngoto serr;\r\n}\r\nmemset(&wc, 0, sizeof wc);\r\nsend_status = IB_WC_SUCCESS;\r\nrelease = 1;\r\nsqp->s_sge.sge = wqe->sg_list[0];\r\nsqp->s_sge.sg_list = wqe->sg_list + 1;\r\nsqp->s_sge.num_sge = wqe->wr.num_sge;\r\nsqp->s_len = wqe->length;\r\nswitch (wqe->wr.opcode) {\r\ncase IB_WR_SEND_WITH_IMM:\r\nwc.wc_flags = IB_WC_WITH_IMM;\r\nwc.ex.imm_data = wqe->wr.ex.imm_data;\r\ncase IB_WR_SEND:\r\nret = qib_get_rwqe(qp, 0);\r\nif (ret < 0)\r\ngoto op_err;\r\nif (!ret)\r\ngoto rnr_nak;\r\nbreak;\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_WRITE)))\r\ngoto inv_err;\r\nwc.wc_flags = IB_WC_WITH_IMM;\r\nwc.ex.imm_data = wqe->wr.ex.imm_data;\r\nret = qib_get_rwqe(qp, 1);\r\nif (ret < 0)\r\ngoto op_err;\r\nif (!ret)\r\ngoto rnr_nak;\r\ncase IB_WR_RDMA_WRITE:\r\nif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_WRITE)))\r\ngoto inv_err;\r\nif (wqe->length == 0)\r\nbreak;\r\nif (unlikely(!qib_rkey_ok(qp, &qp->r_sge.sge, wqe->length,\r\nwqe->wr.wr.rdma.remote_addr,\r\nwqe->wr.wr.rdma.rkey,\r\nIB_ACCESS_REMOTE_WRITE)))\r\ngoto acc_err;\r\nqp->r_sge.sg_list = NULL;\r\nqp->r_sge.num_sge = 1;\r\nqp->r_sge.total_len = wqe->length;\r\nbreak;\r\ncase IB_WR_RDMA_READ:\r\nif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_READ)))\r\ngoto inv_err;\r\nif (unlikely(!qib_rkey_ok(qp, &sqp->s_sge.sge, wqe->length,\r\nwqe->wr.wr.rdma.remote_addr,\r\nwqe->wr.wr.rdma.rkey,\r\nIB_ACCESS_REMOTE_READ)))\r\ngoto acc_err;\r\nrelease = 0;\r\nsqp->s_sge.sg_list = NULL;\r\nsqp->s_sge.num_sge = 1;\r\nqp->r_sge.sge = wqe->sg_list[0];\r\nqp->r_sge.sg_list = wqe->sg_list + 1;\r\nqp->r_sge.num_sge = wqe->wr.num_sge;\r\nqp->r_sge.total_len = wqe->length;\r\nbreak;\r\ncase IB_WR_ATOMIC_CMP_AND_SWP:\r\ncase IB_WR_ATOMIC_FETCH_AND_ADD:\r\nif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_ATOMIC)))\r\ngoto inv_err;\r\nif (unlikely(!qib_rkey_ok(qp, &qp->r_sge.sge, sizeof(u64),\r\nwqe->wr.wr.atomic.remote_addr,\r\nwqe->wr.wr.atomic.rkey,\r\nIB_ACCESS_REMOTE_ATOMIC)))\r\ngoto acc_err;\r\nmaddr = (atomic64_t *) qp->r_sge.sge.vaddr;\r\nsdata = wqe->wr.wr.atomic.compare_add;\r\n*(u64 *) sqp->s_sge.sge.vaddr =\r\n(wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD) ?\r\n(u64) atomic64_add_return(sdata, maddr) - sdata :\r\n(u64) cmpxchg((u64 *) qp->r_sge.sge.vaddr,\r\nsdata, wqe->wr.wr.atomic.swap);\r\nqib_put_mr(qp->r_sge.sge.mr);\r\nqp->r_sge.num_sge = 0;\r\ngoto send_comp;\r\ndefault:\r\nsend_status = IB_WC_LOC_QP_OP_ERR;\r\ngoto serr;\r\n}\r\nsge = &sqp->s_sge.sge;\r\nwhile (sqp->s_len) {\r\nu32 len = sqp->s_len;\r\nif (len > sge->length)\r\nlen = sge->length;\r\nif (len > sge->sge_length)\r\nlen = sge->sge_length;\r\nBUG_ON(len == 0);\r\nqib_copy_sge(&qp->r_sge, sge->vaddr, len, release);\r\nsge->vaddr += len;\r\nsge->length -= len;\r\nsge->sge_length -= len;\r\nif (sge->sge_length == 0) {\r\nif (!release)\r\nqib_put_mr(sge->mr);\r\nif (--sqp->s_sge.num_sge)\r\n*sge = *sqp->s_sge.sg_list++;\r\n} else if (sge->length == 0 && sge->mr->lkey) {\r\nif (++sge->n >= QIB_SEGSZ) {\r\nif (++sge->m >= sge->mr->mapsz)\r\nbreak;\r\nsge->n = 0;\r\n}\r\nsge->vaddr =\r\nsge->mr->map[sge->m]->segs[sge->n].vaddr;\r\nsge->length =\r\nsge->mr->map[sge->m]->segs[sge->n].length;\r\n}\r\nsqp->s_len -= len;\r\n}\r\nif (release)\r\nqib_put_ss(&qp->r_sge);\r\nif (!test_and_clear_bit(QIB_R_WRID_VALID, &qp->r_aflags))\r\ngoto send_comp;\r\nif (wqe->wr.opcode == IB_WR_RDMA_WRITE_WITH_IMM)\r\nwc.opcode = IB_WC_RECV_RDMA_WITH_IMM;\r\nelse\r\nwc.opcode = IB_WC_RECV;\r\nwc.wr_id = qp->r_wr_id;\r\nwc.status = IB_WC_SUCCESS;\r\nwc.byte_len = wqe->length;\r\nwc.qp = &qp->ibqp;\r\nwc.src_qp = qp->remote_qpn;\r\nwc.slid = qp->remote_ah_attr.dlid;\r\nwc.sl = qp->remote_ah_attr.sl;\r\nwc.port_num = 1;\r\nqib_cq_enter(to_icq(qp->ibqp.recv_cq), &wc,\r\nwqe->wr.send_flags & IB_SEND_SOLICITED);\r\nsend_comp:\r\nspin_lock_irqsave(&sqp->s_lock, flags);\r\nibp->n_loop_pkts++;\r\nflush_send:\r\nsqp->s_rnr_retry = sqp->s_rnr_retry_cnt;\r\nqib_send_complete(sqp, wqe, send_status);\r\ngoto again;\r\nrnr_nak:\r\nif (qp->ibqp.qp_type == IB_QPT_UC)\r\ngoto send_comp;\r\nibp->n_rnr_naks++;\r\nif (sqp->s_rnr_retry == 0) {\r\nsend_status = IB_WC_RNR_RETRY_EXC_ERR;\r\ngoto serr;\r\n}\r\nif (sqp->s_rnr_retry_cnt < 7)\r\nsqp->s_rnr_retry--;\r\nspin_lock_irqsave(&sqp->s_lock, flags);\r\nif (!(ib_qib_state_ops[sqp->state] & QIB_PROCESS_RECV_OK))\r\ngoto clr_busy;\r\nsqp->s_flags |= QIB_S_WAIT_RNR;\r\nsqp->s_timer.function = qib_rc_rnr_retry;\r\nsqp->s_timer.expires = jiffies +\r\nusecs_to_jiffies(ib_qib_rnr_table[qp->r_min_rnr_timer]);\r\nadd_timer(&sqp->s_timer);\r\ngoto clr_busy;\r\nop_err:\r\nsend_status = IB_WC_REM_OP_ERR;\r\nwc.status = IB_WC_LOC_QP_OP_ERR;\r\ngoto err;\r\ninv_err:\r\nsend_status = IB_WC_REM_INV_REQ_ERR;\r\nwc.status = IB_WC_LOC_QP_OP_ERR;\r\ngoto err;\r\nacc_err:\r\nsend_status = IB_WC_REM_ACCESS_ERR;\r\nwc.status = IB_WC_LOC_PROT_ERR;\r\nerr:\r\nqib_rc_error(qp, wc.status);\r\nserr:\r\nspin_lock_irqsave(&sqp->s_lock, flags);\r\nqib_send_complete(sqp, wqe, send_status);\r\nif (sqp->ibqp.qp_type == IB_QPT_RC) {\r\nint lastwqe = qib_error_qp(sqp, IB_WC_WR_FLUSH_ERR);\r\nsqp->s_flags &= ~QIB_S_BUSY;\r\nspin_unlock_irqrestore(&sqp->s_lock, flags);\r\nif (lastwqe) {\r\nstruct ib_event ev;\r\nev.device = sqp->ibqp.device;\r\nev.element.qp = &sqp->ibqp;\r\nev.event = IB_EVENT_QP_LAST_WQE_REACHED;\r\nsqp->ibqp.event_handler(&ev, sqp->ibqp.qp_context);\r\n}\r\ngoto done;\r\n}\r\nclr_busy:\r\nsqp->s_flags &= ~QIB_S_BUSY;\r\nunlock:\r\nspin_unlock_irqrestore(&sqp->s_lock, flags);\r\ndone:\r\nif (qp && atomic_dec_and_test(&qp->refcount))\r\nwake_up(&qp->wait);\r\n}\r\nu32 qib_make_grh(struct qib_ibport *ibp, struct ib_grh *hdr,\r\nstruct ib_global_route *grh, u32 hwords, u32 nwords)\r\n{\r\nhdr->version_tclass_flow =\r\ncpu_to_be32((IB_GRH_VERSION << IB_GRH_VERSION_SHIFT) |\r\n(grh->traffic_class << IB_GRH_TCLASS_SHIFT) |\r\n(grh->flow_label << IB_GRH_FLOW_SHIFT));\r\nhdr->paylen = cpu_to_be16((hwords - 2 + nwords + SIZE_OF_CRC) << 2);\r\nhdr->next_hdr = IB_GRH_NEXT_HDR;\r\nhdr->hop_limit = grh->hop_limit;\r\nhdr->sgid.global.subnet_prefix = ibp->gid_prefix;\r\nhdr->sgid.global.interface_id = grh->sgid_index ?\r\nibp->guids[grh->sgid_index - 1] : ppd_from_ibp(ibp)->guid;\r\nhdr->dgid = grh->dgid;\r\nreturn sizeof(struct ib_grh) / sizeof(u32);\r\n}\r\nvoid qib_make_ruc_header(struct qib_qp *qp, struct qib_other_headers *ohdr,\r\nu32 bth0, u32 bth2)\r\n{\r\nstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\r\nu16 lrh0;\r\nu32 nwords;\r\nu32 extra_bytes;\r\nextra_bytes = -qp->s_cur_size & 3;\r\nnwords = (qp->s_cur_size + extra_bytes) >> 2;\r\nlrh0 = QIB_LRH_BTH;\r\nif (unlikely(qp->remote_ah_attr.ah_flags & IB_AH_GRH)) {\r\nqp->s_hdrwords += qib_make_grh(ibp, &qp->s_hdr->u.l.grh,\r\n&qp->remote_ah_attr.grh,\r\nqp->s_hdrwords, nwords);\r\nlrh0 = QIB_LRH_GRH;\r\n}\r\nlrh0 |= ibp->sl_to_vl[qp->remote_ah_attr.sl] << 12 |\r\nqp->remote_ah_attr.sl << 4;\r\nqp->s_hdr->lrh[0] = cpu_to_be16(lrh0);\r\nqp->s_hdr->lrh[1] = cpu_to_be16(qp->remote_ah_attr.dlid);\r\nqp->s_hdr->lrh[2] = cpu_to_be16(qp->s_hdrwords + nwords + SIZE_OF_CRC);\r\nqp->s_hdr->lrh[3] = cpu_to_be16(ppd_from_ibp(ibp)->lid |\r\nqp->remote_ah_attr.src_path_bits);\r\nbth0 |= qib_get_pkey(ibp, qp->s_pkey_index);\r\nbth0 |= extra_bytes << 20;\r\nif (qp->s_mig_state == IB_MIG_MIGRATED)\r\nbth0 |= IB_BTH_MIG_REQ;\r\nohdr->bth[0] = cpu_to_be32(bth0);\r\nohdr->bth[1] = cpu_to_be32(qp->remote_qpn);\r\nohdr->bth[2] = cpu_to_be32(bth2);\r\n}\r\nvoid qib_do_send(struct work_struct *work)\r\n{\r\nstruct qib_qp *qp = container_of(work, struct qib_qp, s_work);\r\nstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\r\nstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\r\nint (*make_req)(struct qib_qp *qp);\r\nunsigned long flags;\r\nif ((qp->ibqp.qp_type == IB_QPT_RC ||\r\nqp->ibqp.qp_type == IB_QPT_UC) &&\r\n(qp->remote_ah_attr.dlid & ~((1 << ppd->lmc) - 1)) == ppd->lid) {\r\nqib_ruc_loopback(qp);\r\nreturn;\r\n}\r\nif (qp->ibqp.qp_type == IB_QPT_RC)\r\nmake_req = qib_make_rc_req;\r\nelse if (qp->ibqp.qp_type == IB_QPT_UC)\r\nmake_req = qib_make_uc_req;\r\nelse\r\nmake_req = qib_make_ud_req;\r\nspin_lock_irqsave(&qp->s_lock, flags);\r\nif (!qib_send_ok(qp)) {\r\nspin_unlock_irqrestore(&qp->s_lock, flags);\r\nreturn;\r\n}\r\nqp->s_flags |= QIB_S_BUSY;\r\nspin_unlock_irqrestore(&qp->s_lock, flags);\r\ndo {\r\nif (qp->s_hdrwords != 0) {\r\nif (qib_verbs_send(qp, qp->s_hdr, qp->s_hdrwords,\r\nqp->s_cur_sge, qp->s_cur_size))\r\nbreak;\r\nqp->s_hdrwords = 0;\r\n}\r\n} while (make_req(qp));\r\n}\r\nvoid qib_send_complete(struct qib_qp *qp, struct qib_swqe *wqe,\r\nenum ib_wc_status status)\r\n{\r\nu32 old_last, last;\r\nunsigned i;\r\nif (!(ib_qib_state_ops[qp->state] & QIB_PROCESS_OR_FLUSH_SEND))\r\nreturn;\r\nfor (i = 0; i < wqe->wr.num_sge; i++) {\r\nstruct qib_sge *sge = &wqe->sg_list[i];\r\nqib_put_mr(sge->mr);\r\n}\r\nif (qp->ibqp.qp_type == IB_QPT_UD ||\r\nqp->ibqp.qp_type == IB_QPT_SMI ||\r\nqp->ibqp.qp_type == IB_QPT_GSI)\r\natomic_dec(&to_iah(wqe->wr.wr.ud.ah)->refcount);\r\nif (!(qp->s_flags & QIB_S_SIGNAL_REQ_WR) ||\r\n(wqe->wr.send_flags & IB_SEND_SIGNALED) ||\r\nstatus != IB_WC_SUCCESS) {\r\nstruct ib_wc wc;\r\nmemset(&wc, 0, sizeof wc);\r\nwc.wr_id = wqe->wr.wr_id;\r\nwc.status = status;\r\nwc.opcode = ib_qib_wc_opcode[wqe->wr.opcode];\r\nwc.qp = &qp->ibqp;\r\nif (status == IB_WC_SUCCESS)\r\nwc.byte_len = wqe->length;\r\nqib_cq_enter(to_icq(qp->ibqp.send_cq), &wc,\r\nstatus != IB_WC_SUCCESS);\r\n}\r\nlast = qp->s_last;\r\nold_last = last;\r\nif (++last >= qp->s_size)\r\nlast = 0;\r\nqp->s_last = last;\r\nif (qp->s_acked == old_last)\r\nqp->s_acked = last;\r\nif (qp->s_cur == old_last)\r\nqp->s_cur = last;\r\nif (qp->s_tail == old_last)\r\nqp->s_tail = last;\r\nif (qp->state == IB_QPS_SQD && last == qp->s_cur)\r\nqp->s_draining = 0;\r\n}
