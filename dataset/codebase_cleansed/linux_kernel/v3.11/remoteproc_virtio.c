static void rproc_virtio_notify(struct virtqueue *vq)\r\n{\r\nstruct rproc_vring *rvring = vq->priv;\r\nstruct rproc *rproc = rvring->rvdev->rproc;\r\nint notifyid = rvring->notifyid;\r\ndev_dbg(&rproc->dev, "kicking vq index: %d\n", notifyid);\r\nrproc->ops->kick(rproc, notifyid);\r\n}\r\nirqreturn_t rproc_vq_interrupt(struct rproc *rproc, int notifyid)\r\n{\r\nstruct rproc_vring *rvring;\r\ndev_dbg(&rproc->dev, "vq index %d is interrupted\n", notifyid);\r\nrvring = idr_find(&rproc->notifyids, notifyid);\r\nif (!rvring || !rvring->vq)\r\nreturn IRQ_NONE;\r\nreturn vring_interrupt(0, rvring->vq);\r\n}\r\nstatic struct virtqueue *rp_find_vq(struct virtio_device *vdev,\r\nunsigned id,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct rproc *rproc = vdev_to_rproc(vdev);\r\nstruct device *dev = &rproc->dev;\r\nstruct rproc_vring *rvring;\r\nstruct virtqueue *vq;\r\nvoid *addr;\r\nint len, size, ret;\r\nif (id >= ARRAY_SIZE(rvdev->vring))\r\nreturn ERR_PTR(-EINVAL);\r\nif (!name)\r\nreturn NULL;\r\nret = rproc_alloc_vring(rvdev, id);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nrvring = &rvdev->vring[id];\r\naddr = rvring->va;\r\nlen = rvring->len;\r\nsize = vring_size(len, rvring->align);\r\nmemset(addr, 0, size);\r\ndev_dbg(dev, "vring%d: va %p qsz %d notifyid %d\n",\r\nid, addr, len, rvring->notifyid);\r\nvq = vring_new_virtqueue(id, len, rvring->align, vdev, false, addr,\r\nrproc_virtio_notify, callback, name);\r\nif (!vq) {\r\ndev_err(dev, "vring_new_virtqueue %s failed\n", name);\r\nrproc_free_vring(rvring);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nrvring->vq = vq;\r\nvq->priv = rvring;\r\nreturn vq;\r\n}\r\nstatic void __rproc_virtio_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct virtqueue *vq, *n;\r\nstruct rproc_vring *rvring;\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list) {\r\nrvring = vq->priv;\r\nrvring->vq = NULL;\r\nvring_del_virtqueue(vq);\r\nrproc_free_vring(rvring);\r\n}\r\n}\r\nstatic void rproc_virtio_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct rproc *rproc = vdev_to_rproc(vdev);\r\nrproc_shutdown(rproc);\r\n__rproc_virtio_del_vqs(vdev);\r\n}\r\nstatic int rproc_virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char *names[])\r\n{\r\nstruct rproc *rproc = vdev_to_rproc(vdev);\r\nint i, ret;\r\nfor (i = 0; i < nvqs; ++i) {\r\nvqs[i] = rp_find_vq(vdev, i, callbacks[i], names[i]);\r\nif (IS_ERR(vqs[i])) {\r\nret = PTR_ERR(vqs[i]);\r\ngoto error;\r\n}\r\n}\r\nret = rproc_boot(rproc);\r\nif (ret) {\r\ndev_err(&rproc->dev, "rproc_boot() failed %d\n", ret);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\n__rproc_virtio_del_vqs(vdev);\r\nreturn ret;\r\n}\r\nstatic u8 rproc_virtio_get_status(struct virtio_device *vdev)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\nreturn rsc->status;\r\n}\r\nstatic void rproc_virtio_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\nrsc->status = status;\r\ndev_dbg(&vdev->dev, "status: %d\n", status);\r\n}\r\nstatic void rproc_virtio_reset(struct virtio_device *vdev)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\nrsc->status = 0;\r\ndev_dbg(&vdev->dev, "reset !\n");\r\n}\r\nstatic u32 rproc_virtio_get_features(struct virtio_device *vdev)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\nreturn rsc->dfeatures;\r\n}\r\nstatic void rproc_virtio_finalize_features(struct virtio_device *vdev)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\nvring_transport_features(vdev);\r\nrsc->gfeatures = vdev->features[0];\r\n}\r\nstatic void rproc_virtio_get(struct virtio_device *vdev, unsigned offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nvoid *cfg;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\ncfg = &rsc->vring[rsc->num_of_vrings];\r\nif (offset + len > rsc->config_len || offset + len < len) {\r\ndev_err(&vdev->dev, "rproc_virtio_get: access out of bounds\n");\r\nreturn;\r\n}\r\nmemcpy(buf, cfg + offset, len);\r\n}\r\nstatic void rproc_virtio_set(struct virtio_device *vdev, unsigned offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct fw_rsc_vdev *rsc;\r\nvoid *cfg;\r\nrsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\r\ncfg = &rsc->vring[rsc->num_of_vrings];\r\nif (offset + len > rsc->config_len || offset + len < len) {\r\ndev_err(&vdev->dev, "rproc_virtio_set: access out of bounds\n");\r\nreturn;\r\n}\r\nmemcpy(cfg + offset, buf, len);\r\n}\r\nstatic void rproc_vdev_release(struct device *dev)\r\n{\r\nstruct virtio_device *vdev = dev_to_virtio(dev);\r\nstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\r\nstruct rproc *rproc = vdev_to_rproc(vdev);\r\nlist_del(&rvdev->node);\r\nkfree(rvdev);\r\nput_device(&rproc->dev);\r\n}\r\nint rproc_add_virtio_dev(struct rproc_vdev *rvdev, int id)\r\n{\r\nstruct rproc *rproc = rvdev->rproc;\r\nstruct device *dev = &rproc->dev;\r\nstruct virtio_device *vdev = &rvdev->vdev;\r\nint ret;\r\nvdev->id.device = id,\r\nvdev->config = &rproc_virtio_config_ops,\r\nvdev->dev.parent = dev;\r\nvdev->dev.release = rproc_vdev_release;\r\nget_device(&rproc->dev);\r\nret = register_virtio_device(vdev);\r\nif (ret) {\r\nput_device(&rproc->dev);\r\ndev_err(dev, "failed to register vdev: %d\n", ret);\r\ngoto out;\r\n}\r\ndev_info(dev, "registered %s (type %d)\n", dev_name(&vdev->dev), id);\r\nout:\r\nreturn ret;\r\n}\r\nvoid rproc_remove_virtio_dev(struct rproc_vdev *rvdev)\r\n{\r\nunregister_virtio_device(&rvdev->vdev);\r\n}
