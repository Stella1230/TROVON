static ssize_t ima_show_htable_value(char __user *buf, size_t count,\r\nloff_t *ppos, atomic_long_t *val)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t len;\r\nlen = scnprintf(tmpbuf, TMPBUFLEN, "%li\n", atomic_long_read(val));\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\r\n}\r\nstatic ssize_t ima_show_htable_violations(struct file *filp,\r\nchar __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn ima_show_htable_value(buf, count, ppos, &ima_htable.violations);\r\n}\r\nstatic ssize_t ima_show_measurements_count(struct file *filp,\r\nchar __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn ima_show_htable_value(buf, count, ppos, &ima_htable.len);\r\n}\r\nstatic void *ima_measurements_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t l = *pos;\r\nstruct ima_queue_entry *qe;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(qe, &ima_measurements, later) {\r\nif (!l--) {\r\nrcu_read_unlock();\r\nreturn qe;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void *ima_measurements_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nrcu_read_lock();\r\nqe = list_entry_rcu(qe->later.next,\r\nstruct ima_queue_entry, later);\r\nrcu_read_unlock();\r\n(*pos)++;\r\nreturn (&qe->later == &ima_measurements) ? NULL : qe;\r\n}\r\nstatic void ima_measurements_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic void ima_putc(struct seq_file *m, void *data, int datalen)\r\n{\r\nwhile (datalen--)\r\nseq_putc(m, *(char *)data++);\r\n}\r\nstatic int ima_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nstruct ima_template_entry *e;\r\nint namelen;\r\nu32 pcr = CONFIG_IMA_MEASURE_PCR_IDX;\r\ne = qe->entry;\r\nif (e == NULL)\r\nreturn -1;\r\nima_putc(m, &pcr, sizeof pcr);\r\nima_putc(m, e->digest, IMA_DIGEST_SIZE);\r\nnamelen = strlen(e->template_name);\r\nima_putc(m, &namelen, sizeof namelen);\r\nima_putc(m, (void *)e->template_name, namelen);\r\nima_template_show(m, (struct ima_template_data *)&e->template,\r\nIMA_SHOW_BINARY);\r\nreturn 0;\r\n}\r\nstatic int ima_measurements_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ima_measurments_seqops);\r\n}\r\nstatic void ima_print_digest(struct seq_file *m, u8 *digest)\r\n{\r\nint i;\r\nfor (i = 0; i < IMA_DIGEST_SIZE; i++)\r\nseq_printf(m, "%02x", *(digest + i));\r\n}\r\nvoid ima_template_show(struct seq_file *m, void *e, enum ima_show_type show)\r\n{\r\nstruct ima_template_data *entry = e;\r\nint namelen;\r\nswitch (show) {\r\ncase IMA_SHOW_ASCII:\r\nima_print_digest(m, entry->digest);\r\nseq_printf(m, " %s\n", entry->file_name);\r\nbreak;\r\ncase IMA_SHOW_BINARY:\r\nima_putc(m, entry->digest, IMA_DIGEST_SIZE);\r\nnamelen = strlen(entry->file_name);\r\nima_putc(m, &namelen, sizeof namelen);\r\nima_putc(m, entry->file_name, namelen);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int ima_ascii_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nstruct ima_template_entry *e;\r\ne = qe->entry;\r\nif (e == NULL)\r\nreturn -1;\r\nseq_printf(m, "%2d ", CONFIG_IMA_MEASURE_PCR_IDX);\r\nima_print_digest(m, e->digest);\r\nseq_printf(m, " %s ", e->template_name);\r\nima_template_show(m, (struct ima_template_data *)&e->template,\r\nIMA_SHOW_ASCII);\r\nreturn 0;\r\n}\r\nstatic int ima_ascii_measurements_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ima_ascii_measurements_seqops);\r\n}\r\nstatic ssize_t ima_write_policy(struct file *file, const char __user *buf,\r\nsize_t datalen, loff_t *ppos)\r\n{\r\nchar *data = NULL;\r\nssize_t result;\r\nif (datalen >= PAGE_SIZE)\r\ndatalen = PAGE_SIZE - 1;\r\nresult = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nresult = -ENOMEM;\r\ndata = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!data)\r\ngoto out;\r\n*(data + datalen) = '\0';\r\nresult = -EFAULT;\r\nif (copy_from_user(data, buf, datalen))\r\ngoto out;\r\nresult = ima_parse_add_rule(data);\r\nout:\r\nif (result < 0)\r\nvalid_policy = 0;\r\nkfree(data);\r\nreturn result;\r\n}\r\nstatic int ima_open_policy(struct inode * inode, struct file * filp)\r\n{\r\nif (!(filp->f_flags & O_WRONLY))\r\nreturn -EACCES;\r\nif (atomic_dec_and_test(&policy_opencount))\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int ima_release_policy(struct inode *inode, struct file *file)\r\n{\r\nif (!valid_policy) {\r\nima_delete_rules();\r\nvalid_policy = 1;\r\natomic_set(&policy_opencount, 1);\r\nreturn 0;\r\n}\r\nima_update_policy();\r\nsecurityfs_remove(ima_policy);\r\nima_policy = NULL;\r\nreturn 0;\r\n}\r\nint __init ima_fs_init(void)\r\n{\r\nima_dir = securityfs_create_dir("ima", NULL);\r\nif (IS_ERR(ima_dir))\r\nreturn -1;\r\nbinary_runtime_measurements =\r\nsecurityfs_create_file("binary_runtime_measurements",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_measurements_ops);\r\nif (IS_ERR(binary_runtime_measurements))\r\ngoto out;\r\nascii_runtime_measurements =\r\nsecurityfs_create_file("ascii_runtime_measurements",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_ascii_measurements_ops);\r\nif (IS_ERR(ascii_runtime_measurements))\r\ngoto out;\r\nruntime_measurements_count =\r\nsecurityfs_create_file("runtime_measurements_count",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_measurements_count_ops);\r\nif (IS_ERR(runtime_measurements_count))\r\ngoto out;\r\nviolations =\r\nsecurityfs_create_file("violations", S_IRUSR | S_IRGRP,\r\nima_dir, NULL, &ima_htable_violations_ops);\r\nif (IS_ERR(violations))\r\ngoto out;\r\nima_policy = securityfs_create_file("policy",\r\nS_IWUSR,\r\nima_dir, NULL,\r\n&ima_measure_policy_ops);\r\nif (IS_ERR(ima_policy))\r\ngoto out;\r\nreturn 0;\r\nout:\r\nsecurityfs_remove(violations);\r\nsecurityfs_remove(runtime_measurements_count);\r\nsecurityfs_remove(ascii_runtime_measurements);\r\nsecurityfs_remove(binary_runtime_measurements);\r\nsecurityfs_remove(ima_dir);\r\nsecurityfs_remove(ima_policy);\r\nreturn -1;\r\n}
