static int copyin(struct openpromio __user *info, struct openpromio **opp_p)\r\n{\r\nunsigned int bufsize;\r\nif (!info || !opp_p)\r\nreturn -EFAULT;\r\nif (get_user(bufsize, &info->oprom_size))\r\nreturn -EFAULT;\r\nif (bufsize == 0)\r\nreturn -EINVAL;\r\nif (bufsize > OPROMMAXPARAM)\r\nbufsize = OPROMMAXPARAM;\r\nif (!(*opp_p = kzalloc(sizeof(int) + bufsize + 1, GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nif (copy_from_user(&(*opp_p)->oprom_array,\r\n&info->oprom_array, bufsize)) {\r\nkfree(*opp_p);\r\nreturn -EFAULT;\r\n}\r\nreturn bufsize;\r\n}\r\nstatic int getstrings(struct openpromio __user *info, struct openpromio **opp_p)\r\n{\r\nint n, bufsize;\r\nchar c;\r\nif (!info || !opp_p)\r\nreturn -EFAULT;\r\nif (!(*opp_p = kzalloc(sizeof(int) + OPROMMAXPARAM + 1, GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n(*opp_p)->oprom_size = 0;\r\nn = bufsize = 0;\r\nwhile ((n < 2) && (bufsize < OPROMMAXPARAM)) {\r\nif (get_user(c, &info->oprom_array[bufsize])) {\r\nkfree(*opp_p);\r\nreturn -EFAULT;\r\n}\r\nif (c == '\0')\r\nn++;\r\n(*opp_p)->oprom_array[bufsize++] = c;\r\n}\r\nif (!n) {\r\nkfree(*opp_p);\r\nreturn -EINVAL;\r\n}\r\nreturn bufsize;\r\n}\r\nstatic int copyout(void __user *info, struct openpromio *opp, int len)\r\n{\r\nif (copy_to_user(info, opp, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int opromgetprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)\r\n{\r\nconst void *pval;\r\nint len;\r\nif (!dp ||\r\n!(pval = of_get_property(dp, op->oprom_array, &len)) ||\r\nlen <= 0 || len > bufsize)\r\nreturn copyout(argp, op, sizeof(int));\r\nmemcpy(op->oprom_array, pval, len);\r\nop->oprom_array[len] = '\0';\r\nop->oprom_size = len;\r\nreturn copyout(argp, op, sizeof(int) + bufsize);\r\n}\r\nstatic int opromnxtprop(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize)\r\n{\r\nstruct property *prop;\r\nint len;\r\nif (!dp)\r\nreturn copyout(argp, op, sizeof(int));\r\nif (op->oprom_array[0] == '\0') {\r\nprop = dp->properties;\r\nif (!prop)\r\nreturn copyout(argp, op, sizeof(int));\r\nlen = strlen(prop->name);\r\n} else {\r\nprop = of_find_property(dp, op->oprom_array, NULL);\r\nif (!prop ||\r\n!prop->next ||\r\n(len = strlen(prop->next->name)) + 1 > bufsize)\r\nreturn copyout(argp, op, sizeof(int));\r\nprop = prop->next;\r\n}\r\nmemcpy(op->oprom_array, prop->name, len);\r\nop->oprom_array[len] = '\0';\r\nop->oprom_size = ++len;\r\nreturn copyout(argp, op, sizeof(int) + bufsize);\r\n}\r\nstatic int opromsetopt(struct device_node *dp, struct openpromio *op, int bufsize)\r\n{\r\nchar *buf = op->oprom_array + strlen(op->oprom_array) + 1;\r\nint len = op->oprom_array + bufsize - buf;\r\nreturn of_set_property(options_node, op->oprom_array, buf, len);\r\n}\r\nstatic int opromnext(void __user *argp, unsigned int cmd, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)\r\n{\r\nphandle ph;\r\nBUILD_BUG_ON(sizeof(phandle) != sizeof(int));\r\nif (bufsize < sizeof(phandle))\r\nreturn -EINVAL;\r\nph = *((int *) op->oprom_array);\r\nif (ph) {\r\ndp = of_find_node_by_phandle(ph);\r\nif (!dp)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase OPROMNEXT:\r\ndp = dp->sibling;\r\nbreak;\r\ncase OPROMCHILD:\r\ndp = dp->child;\r\nbreak;\r\ncase OPROMSETCUR:\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nif (cmd != OPROMNEXT)\r\nreturn -EINVAL;\r\ndp = of_find_node_by_path("/");\r\n}\r\nph = 0;\r\nif (dp)\r\nph = dp->phandle;\r\ndata->current_node = dp;\r\n*((int *) op->oprom_array) = ph;\r\nop->oprom_size = sizeof(phandle);\r\nreturn copyout(argp, op, bufsize + sizeof(int));\r\n}\r\nstatic int oprompci2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)\r\n{\r\nint err = -EINVAL;\r\nif (bufsize >= 2*sizeof(int)) {\r\n#ifdef CONFIG_PCI\r\nstruct pci_dev *pdev;\r\nstruct device_node *dp;\r\npdev = pci_get_bus_and_slot (((int *) op->oprom_array)[0],\r\n((int *) op->oprom_array)[1]);\r\ndp = pci_device_to_OF_node(pdev);\r\ndata->current_node = dp;\r\n*((int *)op->oprom_array) = dp->phandle;\r\nop->oprom_size = sizeof(int);\r\nerr = copyout(argp, op, bufsize + sizeof(int));\r\npci_dev_put(pdev);\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int oprompath2node(void __user *argp, struct device_node *dp, struct openpromio *op, int bufsize, DATA *data)\r\n{\r\nphandle ph = 0;\r\ndp = of_find_node_by_path(op->oprom_array);\r\nif (dp)\r\nph = dp->phandle;\r\ndata->current_node = dp;\r\n*((int *)op->oprom_array) = ph;\r\nop->oprom_size = sizeof(int);\r\nreturn copyout(argp, op, bufsize + sizeof(int));\r\n}\r\nstatic int opromgetbootargs(void __user *argp, struct openpromio *op, int bufsize)\r\n{\r\nchar *buf = saved_command_line;\r\nint len = strlen(buf);\r\nif (len > bufsize)\r\nreturn -EINVAL;\r\nstrcpy(op->oprom_array, buf);\r\nop->oprom_size = len;\r\nreturn copyout(argp, op, bufsize + sizeof(int));\r\n}\r\nstatic long openprom_sunos_ioctl(struct file * file,\r\nunsigned int cmd, unsigned long arg,\r\nstruct device_node *dp)\r\n{\r\nDATA *data = file->private_data;\r\nstruct openpromio *opp = NULL;\r\nint bufsize, error = 0;\r\nstatic int cnt;\r\nvoid __user *argp = (void __user *)arg;\r\nif (cmd == OPROMSETOPT)\r\nbufsize = getstrings(argp, &opp);\r\nelse\r\nbufsize = copyin(argp, &opp);\r\nif (bufsize < 0)\r\nreturn bufsize;\r\nmutex_lock(&openprom_mutex);\r\nswitch (cmd) {\r\ncase OPROMGETOPT:\r\ncase OPROMGETPROP:\r\nerror = opromgetprop(argp, dp, opp, bufsize);\r\nbreak;\r\ncase OPROMNXTOPT:\r\ncase OPROMNXTPROP:\r\nerror = opromnxtprop(argp, dp, opp, bufsize);\r\nbreak;\r\ncase OPROMSETOPT:\r\ncase OPROMSETOPT2:\r\nerror = opromsetopt(dp, opp, bufsize);\r\nbreak;\r\ncase OPROMNEXT:\r\ncase OPROMCHILD:\r\ncase OPROMSETCUR:\r\nerror = opromnext(argp, cmd, dp, opp, bufsize, data);\r\nbreak;\r\ncase OPROMPCI2NODE:\r\nerror = oprompci2node(argp, dp, opp, bufsize, data);\r\nbreak;\r\ncase OPROMPATH2NODE:\r\nerror = oprompath2node(argp, dp, opp, bufsize, data);\r\nbreak;\r\ncase OPROMGETBOOTARGS:\r\nerror = opromgetbootargs(argp, opp, bufsize);\r\nbreak;\r\ncase OPROMU2P:\r\ncase OPROMGETCONS:\r\ncase OPROMGETFBNAME:\r\nif (cnt++ < 10)\r\nprintk(KERN_INFO "openprom_sunos_ioctl: unimplemented ioctl\n");\r\nerror = -EINVAL;\r\nbreak;\r\ndefault:\r\nif (cnt++ < 10)\r\nprintk(KERN_INFO "openprom_sunos_ioctl: cmd 0x%X, arg 0x%lX\n", cmd, arg);\r\nerror = -EINVAL;\r\nbreak;\r\n}\r\nkfree(opp);\r\nmutex_unlock(&openprom_mutex);\r\nreturn error;\r\n}\r\nstatic struct device_node *get_node(phandle n, DATA *data)\r\n{\r\nstruct device_node *dp = of_find_node_by_phandle(n);\r\nif (dp)\r\ndata->lastnode = dp;\r\nreturn dp;\r\n}\r\nstatic int copyin_string(char __user *user, size_t len, char **ptr)\r\n{\r\nchar *tmp;\r\nif ((ssize_t)len < 0 || (ssize_t)(len + 1) < 0)\r\nreturn -EINVAL;\r\ntmp = kmalloc(len + 1, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nif (copy_from_user(tmp, user, len)) {\r\nkfree(tmp);\r\nreturn -EFAULT;\r\n}\r\ntmp[len] = '\0';\r\n*ptr = tmp;\r\nreturn 0;\r\n}\r\nstatic int opiocget(void __user *argp, DATA *data)\r\n{\r\nstruct opiocdesc op;\r\nstruct device_node *dp;\r\nchar *str;\r\nconst void *pval;\r\nint err, len;\r\nif (copy_from_user(&op, argp, sizeof(op)))\r\nreturn -EFAULT;\r\ndp = get_node(op.op_nodeid, data);\r\nerr = copyin_string(op.op_name, op.op_namelen, &str);\r\nif (err)\r\nreturn err;\r\npval = of_get_property(dp, str, &len);\r\nerr = 0;\r\nif (!pval || len > op.op_buflen) {\r\nerr = -EINVAL;\r\n} else {\r\nop.op_buflen = len;\r\nif (copy_to_user(argp, &op, sizeof(op)) ||\r\ncopy_to_user(op.op_buf, pval, len))\r\nerr = -EFAULT;\r\n}\r\nkfree(str);\r\nreturn err;\r\n}\r\nstatic int opiocnextprop(void __user *argp, DATA *data)\r\n{\r\nstruct opiocdesc op;\r\nstruct device_node *dp;\r\nstruct property *prop;\r\nchar *str;\r\nint err, len;\r\nif (copy_from_user(&op, argp, sizeof(op)))\r\nreturn -EFAULT;\r\ndp = get_node(op.op_nodeid, data);\r\nif (!dp)\r\nreturn -EINVAL;\r\nerr = copyin_string(op.op_name, op.op_namelen, &str);\r\nif (err)\r\nreturn err;\r\nif (str[0] == '\0') {\r\nprop = dp->properties;\r\n} else {\r\nprop = of_find_property(dp, str, NULL);\r\nif (prop)\r\nprop = prop->next;\r\n}\r\nkfree(str);\r\nif (!prop)\r\nlen = 0;\r\nelse\r\nlen = prop->length;\r\nif (len > op.op_buflen)\r\nlen = op.op_buflen;\r\nif (copy_to_user(argp, &op, sizeof(op)))\r\nreturn -EFAULT;\r\nif (len &&\r\ncopy_to_user(op.op_buf, prop->value, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int opiocset(void __user *argp, DATA *data)\r\n{\r\nstruct opiocdesc op;\r\nstruct device_node *dp;\r\nchar *str, *tmp;\r\nint err;\r\nif (copy_from_user(&op, argp, sizeof(op)))\r\nreturn -EFAULT;\r\ndp = get_node(op.op_nodeid, data);\r\nif (!dp)\r\nreturn -EINVAL;\r\nerr = copyin_string(op.op_name, op.op_namelen, &str);\r\nif (err)\r\nreturn err;\r\nerr = copyin_string(op.op_buf, op.op_buflen, &tmp);\r\nif (err) {\r\nkfree(str);\r\nreturn err;\r\n}\r\nerr = of_set_property(dp, str, tmp, op.op_buflen);\r\nkfree(str);\r\nkfree(tmp);\r\nreturn err;\r\n}\r\nstatic int opiocgetnext(unsigned int cmd, void __user *argp)\r\n{\r\nstruct device_node *dp;\r\nphandle nd;\r\nBUILD_BUG_ON(sizeof(phandle) != sizeof(int));\r\nif (copy_from_user(&nd, argp, sizeof(phandle)))\r\nreturn -EFAULT;\r\nif (nd == 0) {\r\nif (cmd != OPIOCGETNEXT)\r\nreturn -EINVAL;\r\ndp = of_find_node_by_path("/");\r\n} else {\r\ndp = of_find_node_by_phandle(nd);\r\nnd = 0;\r\nif (dp) {\r\nif (cmd == OPIOCGETNEXT)\r\ndp = dp->sibling;\r\nelse\r\ndp = dp->child;\r\n}\r\n}\r\nif (dp)\r\nnd = dp->phandle;\r\nif (copy_to_user(argp, &nd, sizeof(phandle)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int openprom_bsd_ioctl(struct file * file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nDATA *data = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint err;\r\nmutex_lock(&openprom_mutex);\r\nswitch (cmd) {\r\ncase OPIOCGET:\r\nerr = opiocget(argp, data);\r\nbreak;\r\ncase OPIOCNEXTPROP:\r\nerr = opiocnextprop(argp, data);\r\nbreak;\r\ncase OPIOCSET:\r\nerr = opiocset(argp, data);\r\nbreak;\r\ncase OPIOCGETOPTNODE:\r\nBUILD_BUG_ON(sizeof(phandle) != sizeof(int));\r\nerr = 0;\r\nif (copy_to_user(argp, &options_node->phandle, sizeof(phandle)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase OPIOCGETNEXT:\r\ncase OPIOCGETCHILD:\r\nerr = opiocgetnext(cmd, argp);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&openprom_mutex);\r\nreturn err;\r\n}\r\nstatic long openprom_ioctl(struct file * file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nDATA *data = file->private_data;\r\nswitch (cmd) {\r\ncase OPROMGETOPT:\r\ncase OPROMNXTOPT:\r\nif ((file->f_mode & FMODE_READ) == 0)\r\nreturn -EPERM;\r\nreturn openprom_sunos_ioctl(file, cmd, arg,\r\noptions_node);\r\ncase OPROMSETOPT:\r\ncase OPROMSETOPT2:\r\nif ((file->f_mode & FMODE_WRITE) == 0)\r\nreturn -EPERM;\r\nreturn openprom_sunos_ioctl(file, cmd, arg,\r\noptions_node);\r\ncase OPROMNEXT:\r\ncase OPROMCHILD:\r\ncase OPROMGETPROP:\r\ncase OPROMNXTPROP:\r\nif ((file->f_mode & FMODE_READ) == 0)\r\nreturn -EPERM;\r\nreturn openprom_sunos_ioctl(file, cmd, arg,\r\ndata->current_node);\r\ncase OPROMU2P:\r\ncase OPROMGETCONS:\r\ncase OPROMGETFBNAME:\r\ncase OPROMGETBOOTARGS:\r\ncase OPROMSETCUR:\r\ncase OPROMPCI2NODE:\r\ncase OPROMPATH2NODE:\r\nif ((file->f_mode & FMODE_READ) == 0)\r\nreturn -EPERM;\r\nreturn openprom_sunos_ioctl(file, cmd, arg, NULL);\r\ncase OPIOCGET:\r\ncase OPIOCNEXTPROP:\r\ncase OPIOCGETOPTNODE:\r\ncase OPIOCGETNEXT:\r\ncase OPIOCGETCHILD:\r\nif ((file->f_mode & FMODE_READ) == 0)\r\nreturn -EBADF;\r\nreturn openprom_bsd_ioctl(file,cmd,arg);\r\ncase OPIOCSET:\r\nif ((file->f_mode & FMODE_WRITE) == 0)\r\nreturn -EBADF;\r\nreturn openprom_bsd_ioctl(file,cmd,arg);\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic long openprom_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nlong rval = -ENOTTY;\r\nswitch (cmd) {\r\ncase OPROMGETOPT:\r\ncase OPROMSETOPT:\r\ncase OPROMNXTOPT:\r\ncase OPROMSETOPT2:\r\ncase OPROMNEXT:\r\ncase OPROMCHILD:\r\ncase OPROMGETPROP:\r\ncase OPROMNXTPROP:\r\ncase OPROMU2P:\r\ncase OPROMGETCONS:\r\ncase OPROMGETFBNAME:\r\ncase OPROMGETBOOTARGS:\r\ncase OPROMSETCUR:\r\ncase OPROMPCI2NODE:\r\ncase OPROMPATH2NODE:\r\nrval = openprom_ioctl(file, cmd, arg);\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic int openprom_open(struct inode * inode, struct file * file)\r\n{\r\nDATA *data;\r\ndata = kmalloc(sizeof(DATA), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_lock(&openprom_mutex);\r\ndata->current_node = of_find_node_by_path("/");\r\ndata->lastnode = data->current_node;\r\nfile->private_data = (void *) data;\r\nmutex_unlock(&openprom_mutex);\r\nreturn 0;\r\n}\r\nstatic int openprom_release(struct inode * inode, struct file * file)\r\n{\r\nkfree(file->private_data);\r\nreturn 0;\r\n}\r\nstatic int __init openprom_init(void)\r\n{\r\nstruct device_node *dp;\r\nint err;\r\nerr = misc_register(&openprom_dev);\r\nif (err)\r\nreturn err;\r\ndp = of_find_node_by_path("/");\r\ndp = dp->child;\r\nwhile (dp) {\r\nif (!strcmp(dp->name, "options"))\r\nbreak;\r\ndp = dp->sibling;\r\n}\r\noptions_node = dp;\r\nif (!options_node) {\r\nmisc_deregister(&openprom_dev);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit openprom_cleanup(void)\r\n{\r\nmisc_deregister(&openprom_dev);\r\n}
