static struct rc_map_list *seek_rc_map(const char *name)\r\n{\r\nstruct rc_map_list *map = NULL;\r\nspin_lock(&rc_map_lock);\r\nlist_for_each_entry(map, &rc_map_list, list) {\r\nif (!strcmp(name, map->map.name)) {\r\nspin_unlock(&rc_map_lock);\r\nreturn map;\r\n}\r\n}\r\nspin_unlock(&rc_map_lock);\r\nreturn NULL;\r\n}\r\nstruct rc_map *rc_map_get(const char *name)\r\n{\r\nstruct rc_map_list *map;\r\nmap = seek_rc_map(name);\r\n#ifdef MODULE\r\nif (!map) {\r\nint rc = request_module(name);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "Couldn't load IR keymap %s\n", name);\r\nreturn NULL;\r\n}\r\nmsleep(20);\r\nmap = seek_rc_map(name);\r\n}\r\n#endif\r\nif (!map) {\r\nprintk(KERN_ERR "IR keymap %s not found\n", name);\r\nreturn NULL;\r\n}\r\nprintk(KERN_INFO "Registered IR keymap %s\n", map->map.name);\r\nreturn &map->map;\r\n}\r\nint rc_map_register(struct rc_map_list *map)\r\n{\r\nspin_lock(&rc_map_lock);\r\nlist_add_tail(&map->list, &rc_map_list);\r\nspin_unlock(&rc_map_lock);\r\nreturn 0;\r\n}\r\nvoid rc_map_unregister(struct rc_map_list *map)\r\n{\r\nspin_lock(&rc_map_lock);\r\nlist_del(&map->list);\r\nspin_unlock(&rc_map_lock);\r\n}\r\nstatic int ir_create_table(struct rc_map *rc_map,\r\nconst char *name, u64 rc_type, size_t size)\r\n{\r\nrc_map->name = name;\r\nrc_map->rc_type = rc_type;\r\nrc_map->alloc = roundup_pow_of_two(size * sizeof(struct rc_map_table));\r\nrc_map->size = rc_map->alloc / sizeof(struct rc_map_table);\r\nrc_map->scan = kmalloc(rc_map->alloc, GFP_KERNEL);\r\nif (!rc_map->scan)\r\nreturn -ENOMEM;\r\nIR_dprintk(1, "Allocated space for %u keycode entries (%u bytes)\n",\r\nrc_map->size, rc_map->alloc);\r\nreturn 0;\r\n}\r\nstatic void ir_free_table(struct rc_map *rc_map)\r\n{\r\nrc_map->size = 0;\r\nkfree(rc_map->scan);\r\nrc_map->scan = NULL;\r\n}\r\nstatic int ir_resize_table(struct rc_map *rc_map, gfp_t gfp_flags)\r\n{\r\nunsigned int oldalloc = rc_map->alloc;\r\nunsigned int newalloc = oldalloc;\r\nstruct rc_map_table *oldscan = rc_map->scan;\r\nstruct rc_map_table *newscan;\r\nif (rc_map->size == rc_map->len) {\r\nif (rc_map->alloc >= IR_TAB_MAX_SIZE)\r\nreturn -ENOMEM;\r\nnewalloc *= 2;\r\nIR_dprintk(1, "Growing table to %u bytes\n", newalloc);\r\n}\r\nif ((rc_map->len * 3 < rc_map->size) && (oldalloc > IR_TAB_MIN_SIZE)) {\r\nnewalloc /= 2;\r\nIR_dprintk(1, "Shrinking table to %u bytes\n", newalloc);\r\n}\r\nif (newalloc == oldalloc)\r\nreturn 0;\r\nnewscan = kmalloc(newalloc, gfp_flags);\r\nif (!newscan) {\r\nIR_dprintk(1, "Failed to kmalloc %u bytes\n", newalloc);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(newscan, rc_map->scan, rc_map->len * sizeof(struct rc_map_table));\r\nrc_map->scan = newscan;\r\nrc_map->alloc = newalloc;\r\nrc_map->size = rc_map->alloc / sizeof(struct rc_map_table);\r\nkfree(oldscan);\r\nreturn 0;\r\n}\r\nstatic unsigned int ir_update_mapping(struct rc_dev *dev,\r\nstruct rc_map *rc_map,\r\nunsigned int index,\r\nunsigned int new_keycode)\r\n{\r\nint old_keycode = rc_map->scan[index].keycode;\r\nint i;\r\nif (new_keycode == KEY_RESERVED || new_keycode == KEY_UNKNOWN) {\r\nIR_dprintk(1, "#%d: Deleting scan 0x%04x\n",\r\nindex, rc_map->scan[index].scancode);\r\nrc_map->len--;\r\nmemmove(&rc_map->scan[index], &rc_map->scan[index+ 1],\r\n(rc_map->len - index) * sizeof(struct rc_map_table));\r\n} else {\r\nIR_dprintk(1, "#%d: %s scan 0x%04x with key 0x%04x\n",\r\nindex,\r\nold_keycode == KEY_RESERVED ? "New" : "Replacing",\r\nrc_map->scan[index].scancode, new_keycode);\r\nrc_map->scan[index].keycode = new_keycode;\r\n__set_bit(new_keycode, dev->input_dev->keybit);\r\n}\r\nif (old_keycode != KEY_RESERVED) {\r\n__clear_bit(old_keycode, dev->input_dev->keybit);\r\nfor (i = 0; i < rc_map->len; i++) {\r\nif (rc_map->scan[i].keycode == old_keycode) {\r\n__set_bit(old_keycode, dev->input_dev->keybit);\r\nbreak;\r\n}\r\n}\r\nir_resize_table(rc_map, GFP_ATOMIC);\r\n}\r\nreturn old_keycode;\r\n}\r\nstatic unsigned int ir_establish_scancode(struct rc_dev *dev,\r\nstruct rc_map *rc_map,\r\nunsigned int scancode,\r\nbool resize)\r\n{\r\nunsigned int i;\r\nif (dev->scanmask)\r\nscancode &= dev->scanmask;\r\nfor (i = 0; i < rc_map->len; i++) {\r\nif (rc_map->scan[i].scancode == scancode)\r\nreturn i;\r\nif (rc_map->scan[i].scancode >= scancode)\r\nbreak;\r\n}\r\nif (rc_map->size == rc_map->len) {\r\nif (!resize || ir_resize_table(rc_map, GFP_ATOMIC))\r\nreturn -1U;\r\n}\r\nif (i < rc_map->len)\r\nmemmove(&rc_map->scan[i + 1], &rc_map->scan[i],\r\n(rc_map->len - i) * sizeof(struct rc_map_table));\r\nrc_map->scan[i].scancode = scancode;\r\nrc_map->scan[i].keycode = KEY_RESERVED;\r\nrc_map->len++;\r\nreturn i;\r\n}\r\nstatic int ir_setkeycode(struct input_dev *idev,\r\nconst struct input_keymap_entry *ke,\r\nunsigned int *old_keycode)\r\n{\r\nstruct rc_dev *rdev = input_get_drvdata(idev);\r\nstruct rc_map *rc_map = &rdev->rc_map;\r\nunsigned int index;\r\nunsigned int scancode;\r\nint retval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc_map->lock, flags);\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\r\nindex = ke->index;\r\nif (index >= rc_map->len) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nretval = input_scancode_to_scalar(ke, &scancode);\r\nif (retval)\r\ngoto out;\r\nindex = ir_establish_scancode(rdev, rc_map, scancode, true);\r\nif (index >= rc_map->len) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\n*old_keycode = ir_update_mapping(rdev, rc_map, index, ke->keycode);\r\nout:\r\nspin_unlock_irqrestore(&rc_map->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ir_setkeytable(struct rc_dev *dev,\r\nconst struct rc_map *from)\r\n{\r\nstruct rc_map *rc_map = &dev->rc_map;\r\nunsigned int i, index;\r\nint rc;\r\nrc = ir_create_table(rc_map, from->name,\r\nfrom->rc_type, from->size);\r\nif (rc)\r\nreturn rc;\r\nIR_dprintk(1, "Allocated space for %u keycode entries (%u bytes)\n",\r\nrc_map->size, rc_map->alloc);\r\nfor (i = 0; i < from->size; i++) {\r\nindex = ir_establish_scancode(dev, rc_map,\r\nfrom->scan[i].scancode, false);\r\nif (index >= rc_map->len) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nir_update_mapping(dev, rc_map, index,\r\nfrom->scan[i].keycode);\r\n}\r\nif (rc)\r\nir_free_table(rc_map);\r\nreturn rc;\r\n}\r\nstatic unsigned int ir_lookup_by_scancode(const struct rc_map *rc_map,\r\nunsigned int scancode)\r\n{\r\nint start = 0;\r\nint end = rc_map->len - 1;\r\nint mid;\r\nwhile (start <= end) {\r\nmid = (start + end) / 2;\r\nif (rc_map->scan[mid].scancode < scancode)\r\nstart = mid + 1;\r\nelse if (rc_map->scan[mid].scancode > scancode)\r\nend = mid - 1;\r\nelse\r\nreturn mid;\r\n}\r\nreturn -1U;\r\n}\r\nstatic int ir_getkeycode(struct input_dev *idev,\r\nstruct input_keymap_entry *ke)\r\n{\r\nstruct rc_dev *rdev = input_get_drvdata(idev);\r\nstruct rc_map *rc_map = &rdev->rc_map;\r\nstruct rc_map_table *entry;\r\nunsigned long flags;\r\nunsigned int index;\r\nunsigned int scancode;\r\nint retval;\r\nspin_lock_irqsave(&rc_map->lock, flags);\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\r\nindex = ke->index;\r\n} else {\r\nretval = input_scancode_to_scalar(ke, &scancode);\r\nif (retval)\r\ngoto out;\r\nindex = ir_lookup_by_scancode(rc_map, scancode);\r\n}\r\nif (index < rc_map->len) {\r\nentry = &rc_map->scan[index];\r\nke->index = index;\r\nke->keycode = entry->keycode;\r\nke->len = sizeof(entry->scancode);\r\nmemcpy(ke->scancode, &entry->scancode, sizeof(entry->scancode));\r\n} else if (!(ke->flags & INPUT_KEYMAP_BY_INDEX)) {\r\nke->index = index;\r\nke->keycode = KEY_RESERVED;\r\n} else {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nretval = 0;\r\nout:\r\nspin_unlock_irqrestore(&rc_map->lock, flags);\r\nreturn retval;\r\n}\r\nu32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode)\r\n{\r\nstruct rc_map *rc_map = &dev->rc_map;\r\nunsigned int keycode;\r\nunsigned int index;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc_map->lock, flags);\r\nindex = ir_lookup_by_scancode(rc_map, scancode);\r\nkeycode = index < rc_map->len ?\r\nrc_map->scan[index].keycode : KEY_RESERVED;\r\nspin_unlock_irqrestore(&rc_map->lock, flags);\r\nif (keycode != KEY_RESERVED)\r\nIR_dprintk(1, "%s: scancode 0x%04x keycode 0x%02x\n",\r\ndev->input_name, scancode, keycode);\r\nreturn keycode;\r\n}\r\nstatic void ir_do_keyup(struct rc_dev *dev, bool sync)\r\n{\r\nif (!dev->keypressed)\r\nreturn;\r\nIR_dprintk(1, "keyup key 0x%04x\n", dev->last_keycode);\r\ninput_report_key(dev->input_dev, dev->last_keycode, 0);\r\nif (sync)\r\ninput_sync(dev->input_dev);\r\ndev->keypressed = false;\r\n}\r\nvoid rc_keyup(struct rc_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->keylock, flags);\r\nir_do_keyup(dev, true);\r\nspin_unlock_irqrestore(&dev->keylock, flags);\r\n}\r\nstatic void ir_timer_keyup(unsigned long cookie)\r\n{\r\nstruct rc_dev *dev = (struct rc_dev *)cookie;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->keylock, flags);\r\nif (time_is_before_eq_jiffies(dev->keyup_jiffies))\r\nir_do_keyup(dev, true);\r\nspin_unlock_irqrestore(&dev->keylock, flags);\r\n}\r\nvoid rc_repeat(struct rc_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->keylock, flags);\r\ninput_event(dev->input_dev, EV_MSC, MSC_SCAN, dev->last_scancode);\r\ninput_sync(dev->input_dev);\r\nif (!dev->keypressed)\r\ngoto out;\r\ndev->keyup_jiffies = jiffies + msecs_to_jiffies(IR_KEYPRESS_TIMEOUT);\r\nmod_timer(&dev->timer_keyup, dev->keyup_jiffies);\r\nout:\r\nspin_unlock_irqrestore(&dev->keylock, flags);\r\n}\r\nstatic void ir_do_keydown(struct rc_dev *dev, int scancode,\r\nu32 keycode, u8 toggle)\r\n{\r\nbool new_event = !dev->keypressed ||\r\ndev->last_scancode != scancode ||\r\ndev->last_toggle != toggle;\r\nif (new_event && dev->keypressed)\r\nir_do_keyup(dev, false);\r\ninput_event(dev->input_dev, EV_MSC, MSC_SCAN, scancode);\r\nif (new_event && keycode != KEY_RESERVED) {\r\ndev->keypressed = true;\r\ndev->last_scancode = scancode;\r\ndev->last_toggle = toggle;\r\ndev->last_keycode = keycode;\r\nIR_dprintk(1, "%s: key down event, "\r\n"key 0x%04x, scancode 0x%04x\n",\r\ndev->input_name, keycode, scancode);\r\ninput_report_key(dev->input_dev, keycode, 1);\r\n}\r\ninput_sync(dev->input_dev);\r\n}\r\nvoid rc_keydown(struct rc_dev *dev, int scancode, u8 toggle)\r\n{\r\nunsigned long flags;\r\nu32 keycode = rc_g_keycode_from_table(dev, scancode);\r\nspin_lock_irqsave(&dev->keylock, flags);\r\nir_do_keydown(dev, scancode, keycode, toggle);\r\nif (dev->keypressed) {\r\ndev->keyup_jiffies = jiffies + msecs_to_jiffies(IR_KEYPRESS_TIMEOUT);\r\nmod_timer(&dev->timer_keyup, dev->keyup_jiffies);\r\n}\r\nspin_unlock_irqrestore(&dev->keylock, flags);\r\n}\r\nvoid rc_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle)\r\n{\r\nunsigned long flags;\r\nu32 keycode = rc_g_keycode_from_table(dev, scancode);\r\nspin_lock_irqsave(&dev->keylock, flags);\r\nir_do_keydown(dev, scancode, keycode, toggle);\r\nspin_unlock_irqrestore(&dev->keylock, flags);\r\n}\r\nstatic int ir_open(struct input_dev *idev)\r\n{\r\nstruct rc_dev *rdev = input_get_drvdata(idev);\r\nreturn rdev->open(rdev);\r\n}\r\nstatic void ir_close(struct input_dev *idev)\r\n{\r\nstruct rc_dev *rdev = input_get_drvdata(idev);\r\nif (rdev)\r\nrdev->close(rdev);\r\n}\r\nstatic char *rc_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "rc/%s", dev_name(dev));\r\n}\r\nstatic ssize_t show_protocols(struct device *device,\r\nstruct device_attribute *mattr, char *buf)\r\n{\r\nstruct rc_dev *dev = to_rc_dev(device);\r\nu64 allowed, enabled;\r\nchar *tmp = buf;\r\nint i;\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\nenabled = dev->enabled_protocols;\r\nif (dev->driver_type == RC_DRIVER_SCANCODE)\r\nallowed = dev->allowed_protos;\r\nelse if (dev->raw)\r\nallowed = ir_raw_get_allowed_protocols();\r\nelse {\r\nmutex_unlock(&dev->lock);\r\nreturn -ENODEV;\r\n}\r\nIR_dprintk(1, "allowed - 0x%llx, enabled - 0x%llx\n",\r\n(long long)allowed,\r\n(long long)enabled);\r\nfor (i = 0; i < ARRAY_SIZE(proto_names); i++) {\r\nif (allowed & enabled & proto_names[i].type)\r\ntmp += sprintf(tmp, "[%s] ", proto_names[i].name);\r\nelse if (allowed & proto_names[i].type)\r\ntmp += sprintf(tmp, "%s ", proto_names[i].name);\r\nif (allowed & proto_names[i].type)\r\nallowed &= ~proto_names[i].type;\r\n}\r\nif (tmp != buf)\r\ntmp--;\r\n*tmp = '\n';\r\nmutex_unlock(&dev->lock);\r\nreturn tmp + 1 - buf;\r\n}\r\nstatic ssize_t store_protocols(struct device *device,\r\nstruct device_attribute *mattr,\r\nconst char *data,\r\nsize_t len)\r\n{\r\nstruct rc_dev *dev = to_rc_dev(device);\r\nbool enable, disable;\r\nconst char *tmp;\r\nu64 type;\r\nu64 mask;\r\nint rc, i, count = 0;\r\nssize_t ret;\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\nif (dev->driver_type != RC_DRIVER_SCANCODE && !dev->raw) {\r\nIR_dprintk(1, "Protocol switching not supported\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntype = dev->enabled_protocols;\r\nwhile ((tmp = strsep((char **) &data, " \n")) != NULL) {\r\nif (!*tmp)\r\nbreak;\r\nif (*tmp == '+') {\r\nenable = true;\r\ndisable = false;\r\ntmp++;\r\n} else if (*tmp == '-') {\r\nenable = false;\r\ndisable = true;\r\ntmp++;\r\n} else {\r\nenable = false;\r\ndisable = false;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(proto_names); i++) {\r\nif (!strcasecmp(tmp, proto_names[i].name)) {\r\nmask = proto_names[i].type;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(proto_names)) {\r\nIR_dprintk(1, "Unknown protocol: '%s'\n", tmp);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncount++;\r\nif (enable)\r\ntype |= mask;\r\nelse if (disable)\r\ntype &= ~mask;\r\nelse\r\ntype = mask;\r\n}\r\nif (!count) {\r\nIR_dprintk(1, "Protocol not specified\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (dev->change_protocol) {\r\nrc = dev->change_protocol(dev, &type);\r\nif (rc < 0) {\r\nIR_dprintk(1, "Error setting protocols to 0x%llx\n",\r\n(long long)type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\ndev->enabled_protocols = type;\r\nIR_dprintk(1, "Current protocol(s): 0x%llx\n",\r\n(long long)type);\r\nret = len;\r\nout:\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic void rc_dev_release(struct device *device)\r\n{\r\n}\r\nstatic int rc_dev_uevent(struct device *device, struct kobj_uevent_env *env)\r\n{\r\nstruct rc_dev *dev = to_rc_dev(device);\r\nif (!dev || !dev->input_dev)\r\nreturn -ENODEV;\r\nif (dev->rc_map.name)\r\nADD_HOTPLUG_VAR("NAME=%s", dev->rc_map.name);\r\nif (dev->driver_name)\r\nADD_HOTPLUG_VAR("DRV_NAME=%s", dev->driver_name);\r\nreturn 0;\r\n}\r\nstruct rc_dev *rc_allocate_device(void)\r\n{\r\nstruct rc_dev *dev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\ndev->input_dev = input_allocate_device();\r\nif (!dev->input_dev) {\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\ndev->input_dev->getkeycode = ir_getkeycode;\r\ndev->input_dev->setkeycode = ir_setkeycode;\r\ninput_set_drvdata(dev->input_dev, dev);\r\nspin_lock_init(&dev->rc_map.lock);\r\nspin_lock_init(&dev->keylock);\r\nmutex_init(&dev->lock);\r\nsetup_timer(&dev->timer_keyup, ir_timer_keyup, (unsigned long)dev);\r\ndev->dev.type = &rc_dev_type;\r\ndev->dev.class = &rc_class;\r\ndevice_initialize(&dev->dev);\r\n__module_get(THIS_MODULE);\r\nreturn dev;\r\n}\r\nvoid rc_free_device(struct rc_dev *dev)\r\n{\r\nif (!dev)\r\nreturn;\r\nif (dev->input_dev)\r\ninput_free_device(dev->input_dev);\r\nput_device(&dev->dev);\r\nkfree(dev);\r\nmodule_put(THIS_MODULE);\r\n}\r\nint rc_register_device(struct rc_dev *dev)\r\n{\r\nstatic bool raw_init = false;\r\nstatic atomic_t devno = ATOMIC_INIT(0);\r\nstruct rc_map *rc_map;\r\nconst char *path;\r\nint rc;\r\nif (!dev || !dev->map_name)\r\nreturn -EINVAL;\r\nrc_map = rc_map_get(dev->map_name);\r\nif (!rc_map)\r\nrc_map = rc_map_get(RC_MAP_EMPTY);\r\nif (!rc_map || !rc_map->scan || rc_map->size == 0)\r\nreturn -EINVAL;\r\nset_bit(EV_KEY, dev->input_dev->evbit);\r\nset_bit(EV_REP, dev->input_dev->evbit);\r\nset_bit(EV_MSC, dev->input_dev->evbit);\r\nset_bit(MSC_SCAN, dev->input_dev->mscbit);\r\nif (dev->open)\r\ndev->input_dev->open = ir_open;\r\nif (dev->close)\r\ndev->input_dev->close = ir_close;\r\nmutex_lock(&dev->lock);\r\ndev->devno = (unsigned long)(atomic_inc_return(&devno) - 1);\r\ndev_set_name(&dev->dev, "rc%ld", dev->devno);\r\ndev_set_drvdata(&dev->dev, dev);\r\nrc = device_add(&dev->dev);\r\nif (rc)\r\ngoto out_unlock;\r\nrc = ir_setkeytable(dev, rc_map);\r\nif (rc)\r\ngoto out_dev;\r\ndev->input_dev->dev.parent = &dev->dev;\r\nmemcpy(&dev->input_dev->id, &dev->input_id, sizeof(dev->input_id));\r\ndev->input_dev->phys = dev->input_phys;\r\ndev->input_dev->name = dev->input_name;\r\nrc = input_register_device(dev->input_dev);\r\nif (rc)\r\ngoto out_table;\r\ndev->input_dev->rep[REP_DELAY] = 500;\r\ndev->input_dev->rep[REP_PERIOD] = 125;\r\npath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\r\nprintk(KERN_INFO "%s: %s as %s\n",\r\ndev_name(&dev->dev),\r\ndev->input_name ? dev->input_name : "Unspecified device",\r\npath ? path : "N/A");\r\nkfree(path);\r\nif (dev->driver_type == RC_DRIVER_IR_RAW) {\r\nif (!raw_init) {\r\nIR_dprintk(1, "Loading raw decoders\n");\r\nir_raw_init();\r\nraw_init = true;\r\n}\r\nrc = ir_raw_event_register(dev);\r\nif (rc < 0)\r\ngoto out_input;\r\n}\r\nif (dev->change_protocol) {\r\nu64 rc_type = (1 << rc_map->rc_type);\r\nrc = dev->change_protocol(dev, &rc_type);\r\nif (rc < 0)\r\ngoto out_raw;\r\ndev->enabled_protocols = rc_type;\r\n}\r\nmutex_unlock(&dev->lock);\r\nIR_dprintk(1, "Registered rc%ld (driver: %s, remote: %s, mode %s)\n",\r\ndev->devno,\r\ndev->driver_name ? dev->driver_name : "unknown",\r\nrc_map->name ? rc_map->name : "unknown",\r\ndev->driver_type == RC_DRIVER_IR_RAW ? "raw" : "cooked");\r\nreturn 0;\r\nout_raw:\r\nif (dev->driver_type == RC_DRIVER_IR_RAW)\r\nir_raw_event_unregister(dev);\r\nout_input:\r\ninput_unregister_device(dev->input_dev);\r\ndev->input_dev = NULL;\r\nout_table:\r\nir_free_table(&dev->rc_map);\r\nout_dev:\r\ndevice_del(&dev->dev);\r\nout_unlock:\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nvoid rc_unregister_device(struct rc_dev *dev)\r\n{\r\nif (!dev)\r\nreturn;\r\ndel_timer_sync(&dev->timer_keyup);\r\nif (dev->driver_type == RC_DRIVER_IR_RAW)\r\nir_raw_event_unregister(dev);\r\nir_free_table(&dev->rc_map);\r\nIR_dprintk(1, "Freed keycode table\n");\r\ninput_unregister_device(dev->input_dev);\r\ndev->input_dev = NULL;\r\ndevice_del(&dev->dev);\r\nrc_free_device(dev);\r\n}\r\nstatic int __init rc_core_init(void)\r\n{\r\nint rc = class_register(&rc_class);\r\nif (rc) {\r\nprintk(KERN_ERR "rc_core: unable to register rc class\n");\r\nreturn rc;\r\n}\r\nrc_map_register(&empty_map);\r\nreturn 0;\r\n}\r\nstatic void __exit rc_core_exit(void)\r\n{\r\nclass_unregister(&rc_class);\r\nrc_map_unregister(&empty_map);\r\n}
