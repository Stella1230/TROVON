static int acpi_i2c_add_resource(struct acpi_resource *ares, void *data)\r\n{\r\nstruct i2c_board_info *info = data;\r\nif (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {\r\nstruct acpi_resource_i2c_serialbus *sb;\r\nsb = &ares->data.i2c_serial_bus;\r\nif (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {\r\ninfo->addr = sb->slave_address;\r\nif (sb->access_mode == ACPI_I2C_10BIT_MODE)\r\ninfo->flags |= I2C_CLIENT_TEN;\r\n}\r\n} else if (info->irq < 0) {\r\nstruct resource r;\r\nif (acpi_dev_resource_interrupt(ares, 0, &r))\r\ninfo->irq = r.start;\r\n}\r\nreturn 1;\r\n}\r\nstatic acpi_status acpi_i2c_add_device(acpi_handle handle, u32 level,\r\nvoid *data, void **return_value)\r\n{\r\nstruct i2c_adapter *adapter = data;\r\nstruct list_head resource_list;\r\nstruct i2c_board_info info;\r\nstruct acpi_device *adev;\r\nint ret;\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\nif (acpi_bus_get_status(adev) || !adev->status.present)\r\nreturn AE_OK;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.acpi_node.handle = handle;\r\ninfo.irq = -1;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list,\r\nacpi_i2c_add_resource, &info);\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (ret < 0 || !info.addr)\r\nreturn AE_OK;\r\nstrlcpy(info.type, dev_name(&adev->dev), sizeof(info.type));\r\nif (!i2c_new_device(adapter, &info)) {\r\ndev_err(&adapter->dev,\r\n"failed to add I2C device %s from ACPI\n",\r\ndev_name(&adev->dev));\r\n}\r\nreturn AE_OK;\r\n}\r\nvoid acpi_i2c_register_devices(struct i2c_adapter *adapter)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nhandle = ACPI_HANDLE(adapter->dev.parent);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\r\nacpi_i2c_add_device, NULL,\r\nadapter, NULL);\r\nif (ACPI_FAILURE(status))\r\ndev_warn(&adapter->dev, "failed to enumerate I2C slaves\n");\r\n}
