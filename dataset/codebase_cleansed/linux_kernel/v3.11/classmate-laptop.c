static int cmpc_add_acpi_notify_device(struct acpi_device *acpi, char *name,\r\ninput_device_init idev_init)\r\n{\r\nstruct input_dev *inputdev;\r\nint error;\r\ninputdev = input_allocate_device();\r\nif (!inputdev)\r\nreturn -ENOMEM;\r\ninputdev->name = name;\r\ninputdev->dev.parent = &acpi->dev;\r\nidev_init(inputdev);\r\nerror = input_register_device(inputdev);\r\nif (error) {\r\ninput_free_device(inputdev);\r\nreturn error;\r\n}\r\ndev_set_drvdata(&acpi->dev, inputdev);\r\nreturn 0;\r\n}\r\nstatic int cmpc_remove_acpi_notify_device(struct acpi_device *acpi)\r\n{\r\nstruct input_dev *inputdev = dev_get_drvdata(&acpi->dev);\r\ninput_unregister_device(inputdev);\r\nreturn 0;\r\n}\r\nstatic acpi_status cmpc_start_accel_v4(acpi_handle handle)\r\n{\r\nunion acpi_object param[4];\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x3;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = 0;\r\nparam[2].type = ACPI_TYPE_INTEGER;\r\nparam[2].integer.value = 0;\r\nparam[3].type = ACPI_TYPE_INTEGER;\r\nparam[3].integer.value = 0;\r\ninput.count = 4;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\nreturn status;\r\n}\r\nstatic acpi_status cmpc_stop_accel_v4(acpi_handle handle)\r\n{\r\nunion acpi_object param[4];\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x4;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = 0;\r\nparam[2].type = ACPI_TYPE_INTEGER;\r\nparam[2].integer.value = 0;\r\nparam[3].type = ACPI_TYPE_INTEGER;\r\nparam[3].integer.value = 0;\r\ninput.count = 4;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\nreturn status;\r\n}\r\nstatic acpi_status cmpc_accel_set_sensitivity_v4(acpi_handle handle, int val)\r\n{\r\nunion acpi_object param[4];\r\nstruct acpi_object_list input;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x02;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = val;\r\nparam[2].type = ACPI_TYPE_INTEGER;\r\nparam[2].integer.value = 0;\r\nparam[3].type = ACPI_TYPE_INTEGER;\r\nparam[3].integer.value = 0;\r\ninput.count = 4;\r\ninput.pointer = param;\r\nreturn acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\n}\r\nstatic acpi_status cmpc_accel_set_g_select_v4(acpi_handle handle, int val)\r\n{\r\nunion acpi_object param[4];\r\nstruct acpi_object_list input;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x05;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = val;\r\nparam[2].type = ACPI_TYPE_INTEGER;\r\nparam[2].integer.value = 0;\r\nparam[3].type = ACPI_TYPE_INTEGER;\r\nparam[3].integer.value = 0;\r\ninput.count = 4;\r\ninput.pointer = param;\r\nreturn acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\n}\r\nstatic acpi_status cmpc_get_accel_v4(acpi_handle handle,\r\nint16_t *x,\r\nint16_t *y,\r\nint16_t *z)\r\n{\r\nunion acpi_object param[4];\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nint16_t *locs;\r\nacpi_status status;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x01;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = 0;\r\nparam[2].type = ACPI_TYPE_INTEGER;\r\nparam[2].integer.value = 0;\r\nparam[3].type = ACPI_TYPE_INTEGER;\r\nparam[3].integer.value = 0;\r\ninput.count = 4;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_object(handle, "ACMD", &input, &output);\r\nif (ACPI_SUCCESS(status)) {\r\nunion acpi_object *obj;\r\nobj = output.pointer;\r\nlocs = (int16_t *) obj->buffer.pointer;\r\n*x = locs[0];\r\n*y = locs[1];\r\n*z = locs[2];\r\nkfree(output.pointer);\r\n}\r\nreturn status;\r\n}\r\nstatic void cmpc_accel_handler_v4(struct acpi_device *dev, u32 event)\r\n{\r\nif (event == 0x81) {\r\nint16_t x, y, z;\r\nacpi_status status;\r\nstatus = cmpc_get_accel_v4(dev->handle, &x, &y, &z);\r\nif (ACPI_SUCCESS(status)) {\r\nstruct input_dev *inputdev = dev_get_drvdata(&dev->dev);\r\ninput_report_abs(inputdev, ABS_X, x);\r\ninput_report_abs(inputdev, ABS_Y, y);\r\ninput_report_abs(inputdev, ABS_Z, z);\r\ninput_sync(inputdev);\r\n}\r\n}\r\n}\r\nstatic ssize_t cmpc_accel_sensitivity_show_v4(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\nacpi = to_acpi_device(dev);\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nreturn sprintf(buf, "%d\n", accel->sensitivity);\r\n}\r\nstatic ssize_t cmpc_accel_sensitivity_store_v4(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\nunsigned long sensitivity;\r\nint r;\r\nacpi = to_acpi_device(dev);\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nr = kstrtoul(buf, 0, &sensitivity);\r\nif (r)\r\nreturn r;\r\nif (sensitivity < 1 || sensitivity > 127)\r\nreturn -EINVAL;\r\naccel->sensitivity = sensitivity;\r\ncmpc_accel_set_sensitivity_v4(acpi->handle, sensitivity);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t cmpc_accel_g_select_show_v4(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\nacpi = to_acpi_device(dev);\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nreturn sprintf(buf, "%d\n", accel->g_select);\r\n}\r\nstatic ssize_t cmpc_accel_g_select_store_v4(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\nunsigned long g_select;\r\nint r;\r\nacpi = to_acpi_device(dev);\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nr = kstrtoul(buf, 0, &g_select);\r\nif (r)\r\nreturn r;\r\nif (g_select != 0 && g_select != 1)\r\nreturn -EINVAL;\r\naccel->g_select = g_select;\r\ncmpc_accel_set_g_select_v4(acpi->handle, g_select);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic int cmpc_accel_open_v4(struct input_dev *input)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct cmpc_accel *accel;\r\nacpi = to_acpi_device(input->dev.parent);\r\naccel = dev_get_drvdata(&input->dev);\r\ncmpc_accel_set_sensitivity_v4(acpi->handle, accel->sensitivity);\r\ncmpc_accel_set_g_select_v4(acpi->handle, accel->g_select);\r\nif (ACPI_SUCCESS(cmpc_start_accel_v4(acpi->handle))) {\r\naccel->inputdev_state = CMPC_ACCEL_DEV_STATE_OPEN;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void cmpc_accel_close_v4(struct input_dev *input)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct cmpc_accel *accel;\r\nacpi = to_acpi_device(input->dev.parent);\r\naccel = dev_get_drvdata(&input->dev);\r\ncmpc_stop_accel_v4(acpi->handle);\r\naccel->inputdev_state = CMPC_ACCEL_DEV_STATE_CLOSED;\r\n}\r\nstatic void cmpc_accel_idev_init_v4(struct input_dev *inputdev)\r\n{\r\nset_bit(EV_ABS, inputdev->evbit);\r\ninput_set_abs_params(inputdev, ABS_X, -255, 255, 16, 0);\r\ninput_set_abs_params(inputdev, ABS_Y, -255, 255, 16, 0);\r\ninput_set_abs_params(inputdev, ABS_Z, -255, 255, 16, 0);\r\ninputdev->open = cmpc_accel_open_v4;\r\ninputdev->close = cmpc_accel_close_v4;\r\n}\r\nstatic int cmpc_accel_suspend_v4(struct device *dev)\r\n{\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\ninputdev = dev_get_drvdata(dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nif (accel->inputdev_state == CMPC_ACCEL_DEV_STATE_OPEN)\r\nreturn cmpc_stop_accel_v4(to_acpi_device(dev)->handle);\r\nreturn 0;\r\n}\r\nstatic int cmpc_accel_resume_v4(struct device *dev)\r\n{\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\ninputdev = dev_get_drvdata(dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nif (accel->inputdev_state == CMPC_ACCEL_DEV_STATE_OPEN) {\r\ncmpc_accel_set_sensitivity_v4(to_acpi_device(dev)->handle,\r\naccel->sensitivity);\r\ncmpc_accel_set_g_select_v4(to_acpi_device(dev)->handle,\r\naccel->g_select);\r\nif (ACPI_FAILURE(cmpc_start_accel_v4(to_acpi_device(dev)->handle)))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmpc_accel_add_v4(struct acpi_device *acpi)\r\n{\r\nint error;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\naccel = kmalloc(sizeof(*accel), GFP_KERNEL);\r\nif (!accel)\r\nreturn -ENOMEM;\r\naccel->inputdev_state = CMPC_ACCEL_DEV_STATE_CLOSED;\r\naccel->sensitivity = CMPC_ACCEL_SENSITIVITY_DEFAULT;\r\ncmpc_accel_set_sensitivity_v4(acpi->handle, accel->sensitivity);\r\nerror = device_create_file(&acpi->dev, &cmpc_accel_sensitivity_attr_v4);\r\nif (error)\r\ngoto failed_sensitivity;\r\naccel->g_select = CMPC_ACCEL_G_SELECT_DEFAULT;\r\ncmpc_accel_set_g_select_v4(acpi->handle, accel->g_select);\r\nerror = device_create_file(&acpi->dev, &cmpc_accel_g_select_attr_v4);\r\nif (error)\r\ngoto failed_g_select;\r\nerror = cmpc_add_acpi_notify_device(acpi, "cmpc_accel_v4",\r\ncmpc_accel_idev_init_v4);\r\nif (error)\r\ngoto failed_input;\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\ndev_set_drvdata(&inputdev->dev, accel);\r\nreturn 0;\r\nfailed_input:\r\ndevice_remove_file(&acpi->dev, &cmpc_accel_g_select_attr_v4);\r\nfailed_g_select:\r\ndevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr_v4);\r\nfailed_sensitivity:\r\nkfree(accel);\r\nreturn error;\r\n}\r\nstatic int cmpc_accel_remove_v4(struct acpi_device *acpi)\r\n{\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\ndevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr_v4);\r\ndevice_remove_file(&acpi->dev, &cmpc_accel_g_select_attr_v4);\r\nreturn cmpc_remove_acpi_notify_device(acpi);\r\n}\r\nstatic acpi_status cmpc_start_accel(acpi_handle handle)\r\n{\r\nunion acpi_object param[2];\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x3;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\ninput.count = 2;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\nreturn status;\r\n}\r\nstatic acpi_status cmpc_stop_accel(acpi_handle handle)\r\n{\r\nunion acpi_object param[2];\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x4;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\ninput.count = 2;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\nreturn status;\r\n}\r\nstatic acpi_status cmpc_accel_set_sensitivity(acpi_handle handle, int val)\r\n{\r\nunion acpi_object param[2];\r\nstruct acpi_object_list input;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x02;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = val;\r\ninput.count = 2;\r\ninput.pointer = param;\r\nreturn acpi_evaluate_object(handle, "ACMD", &input, NULL);\r\n}\r\nstatic acpi_status cmpc_get_accel(acpi_handle handle,\r\nunsigned char *x,\r\nunsigned char *y,\r\nunsigned char *z)\r\n{\r\nunion acpi_object param[2];\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, 0 };\r\nunsigned char *locs;\r\nacpi_status status;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0x01;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\ninput.count = 2;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_object(handle, "ACMD", &input, &output);\r\nif (ACPI_SUCCESS(status)) {\r\nunion acpi_object *obj;\r\nobj = output.pointer;\r\nlocs = obj->buffer.pointer;\r\n*x = locs[0];\r\n*y = locs[1];\r\n*z = locs[2];\r\nkfree(output.pointer);\r\n}\r\nreturn status;\r\n}\r\nstatic void cmpc_accel_handler(struct acpi_device *dev, u32 event)\r\n{\r\nif (event == 0x81) {\r\nunsigned char x, y, z;\r\nacpi_status status;\r\nstatus = cmpc_get_accel(dev->handle, &x, &y, &z);\r\nif (ACPI_SUCCESS(status)) {\r\nstruct input_dev *inputdev = dev_get_drvdata(&dev->dev);\r\ninput_report_abs(inputdev, ABS_X, x);\r\ninput_report_abs(inputdev, ABS_Y, y);\r\ninput_report_abs(inputdev, ABS_Z, z);\r\ninput_sync(inputdev);\r\n}\r\n}\r\n}\r\nstatic ssize_t cmpc_accel_sensitivity_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\nacpi = to_acpi_device(dev);\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nreturn sprintf(buf, "%d\n", accel->sensitivity);\r\n}\r\nstatic ssize_t cmpc_accel_sensitivity_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acpi_device *acpi;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\nunsigned long sensitivity;\r\nint r;\r\nacpi = to_acpi_device(dev);\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\nr = strict_strtoul(buf, 0, &sensitivity);\r\nif (r)\r\nreturn r;\r\naccel->sensitivity = sensitivity;\r\ncmpc_accel_set_sensitivity(acpi->handle, sensitivity);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic int cmpc_accel_open(struct input_dev *input)\r\n{\r\nstruct acpi_device *acpi;\r\nacpi = to_acpi_device(input->dev.parent);\r\nif (ACPI_SUCCESS(cmpc_start_accel(acpi->handle)))\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic void cmpc_accel_close(struct input_dev *input)\r\n{\r\nstruct acpi_device *acpi;\r\nacpi = to_acpi_device(input->dev.parent);\r\ncmpc_stop_accel(acpi->handle);\r\n}\r\nstatic void cmpc_accel_idev_init(struct input_dev *inputdev)\r\n{\r\nset_bit(EV_ABS, inputdev->evbit);\r\ninput_set_abs_params(inputdev, ABS_X, 0, 255, 8, 0);\r\ninput_set_abs_params(inputdev, ABS_Y, 0, 255, 8, 0);\r\ninput_set_abs_params(inputdev, ABS_Z, 0, 255, 8, 0);\r\ninputdev->open = cmpc_accel_open;\r\ninputdev->close = cmpc_accel_close;\r\n}\r\nstatic int cmpc_accel_add(struct acpi_device *acpi)\r\n{\r\nint error;\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\naccel = kmalloc(sizeof(*accel), GFP_KERNEL);\r\nif (!accel)\r\nreturn -ENOMEM;\r\naccel->sensitivity = CMPC_ACCEL_SENSITIVITY_DEFAULT;\r\ncmpc_accel_set_sensitivity(acpi->handle, accel->sensitivity);\r\nerror = device_create_file(&acpi->dev, &cmpc_accel_sensitivity_attr);\r\nif (error)\r\ngoto failed_file;\r\nerror = cmpc_add_acpi_notify_device(acpi, "cmpc_accel",\r\ncmpc_accel_idev_init);\r\nif (error)\r\ngoto failed_input;\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\ndev_set_drvdata(&inputdev->dev, accel);\r\nreturn 0;\r\nfailed_input:\r\ndevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr);\r\nfailed_file:\r\nkfree(accel);\r\nreturn error;\r\n}\r\nstatic int cmpc_accel_remove(struct acpi_device *acpi)\r\n{\r\nstruct input_dev *inputdev;\r\nstruct cmpc_accel *accel;\r\ninputdev = dev_get_drvdata(&acpi->dev);\r\naccel = dev_get_drvdata(&inputdev->dev);\r\ndevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr);\r\nreturn cmpc_remove_acpi_notify_device(acpi);\r\n}\r\nstatic acpi_status cmpc_get_tablet(acpi_handle handle,\r\nunsigned long long *value)\r\n{\r\nunion acpi_object param;\r\nstruct acpi_object_list input;\r\nunsigned long long output;\r\nacpi_status status;\r\nparam.type = ACPI_TYPE_INTEGER;\r\nparam.integer.value = 0x01;\r\ninput.count = 1;\r\ninput.pointer = &param;\r\nstatus = acpi_evaluate_integer(handle, "TCMD", &input, &output);\r\nif (ACPI_SUCCESS(status))\r\n*value = output;\r\nreturn status;\r\n}\r\nstatic void cmpc_tablet_handler(struct acpi_device *dev, u32 event)\r\n{\r\nunsigned long long val = 0;\r\nstruct input_dev *inputdev = dev_get_drvdata(&dev->dev);\r\nif (event == 0x81) {\r\nif (ACPI_SUCCESS(cmpc_get_tablet(dev->handle, &val))) {\r\ninput_report_switch(inputdev, SW_TABLET_MODE, !val);\r\ninput_sync(inputdev);\r\n}\r\n}\r\n}\r\nstatic void cmpc_tablet_idev_init(struct input_dev *inputdev)\r\n{\r\nunsigned long long val = 0;\r\nstruct acpi_device *acpi;\r\nset_bit(EV_SW, inputdev->evbit);\r\nset_bit(SW_TABLET_MODE, inputdev->swbit);\r\nacpi = to_acpi_device(inputdev->dev.parent);\r\nif (ACPI_SUCCESS(cmpc_get_tablet(acpi->handle, &val))) {\r\ninput_report_switch(inputdev, SW_TABLET_MODE, !val);\r\ninput_sync(inputdev);\r\n}\r\n}\r\nstatic int cmpc_tablet_add(struct acpi_device *acpi)\r\n{\r\nreturn cmpc_add_acpi_notify_device(acpi, "cmpc_tablet",\r\ncmpc_tablet_idev_init);\r\n}\r\nstatic int cmpc_tablet_remove(struct acpi_device *acpi)\r\n{\r\nreturn cmpc_remove_acpi_notify_device(acpi);\r\n}\r\nstatic int cmpc_tablet_resume(struct device *dev)\r\n{\r\nstruct input_dev *inputdev = dev_get_drvdata(dev);\r\nunsigned long long val = 0;\r\nif (ACPI_SUCCESS(cmpc_get_tablet(to_acpi_device(dev)->handle, &val))) {\r\ninput_report_switch(inputdev, SW_TABLET_MODE, !val);\r\ninput_sync(inputdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic acpi_status cmpc_get_brightness(acpi_handle handle,\r\nunsigned long long *value)\r\n{\r\nunion acpi_object param;\r\nstruct acpi_object_list input;\r\nunsigned long long output;\r\nacpi_status status;\r\nparam.type = ACPI_TYPE_INTEGER;\r\nparam.integer.value = 0xC0;\r\ninput.count = 1;\r\ninput.pointer = &param;\r\nstatus = acpi_evaluate_integer(handle, "GRDI", &input, &output);\r\nif (ACPI_SUCCESS(status))\r\n*value = output;\r\nreturn status;\r\n}\r\nstatic acpi_status cmpc_set_brightness(acpi_handle handle,\r\nunsigned long long value)\r\n{\r\nunion acpi_object param[2];\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nunsigned long long output;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0xC0;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = value;\r\ninput.count = 2;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_integer(handle, "GWRI", &input, &output);\r\nreturn status;\r\n}\r\nstatic int cmpc_bl_get_brightness(struct backlight_device *bd)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nunsigned long long brightness;\r\nhandle = bl_get_data(bd);\r\nstatus = cmpc_get_brightness(handle, &brightness);\r\nif (ACPI_SUCCESS(status))\r\nreturn brightness;\r\nelse\r\nreturn -1;\r\n}\r\nstatic int cmpc_bl_update_status(struct backlight_device *bd)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nhandle = bl_get_data(bd);\r\nstatus = cmpc_set_brightness(handle, bd->props.brightness);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic acpi_status cmpc_get_rfkill_wlan(acpi_handle handle,\r\nunsigned long long *value)\r\n{\r\nunion acpi_object param;\r\nstruct acpi_object_list input;\r\nunsigned long long output;\r\nacpi_status status;\r\nparam.type = ACPI_TYPE_INTEGER;\r\nparam.integer.value = 0xC1;\r\ninput.count = 1;\r\ninput.pointer = &param;\r\nstatus = acpi_evaluate_integer(handle, "GRDI", &input, &output);\r\nif (ACPI_SUCCESS(status))\r\n*value = output;\r\nreturn status;\r\n}\r\nstatic acpi_status cmpc_set_rfkill_wlan(acpi_handle handle,\r\nunsigned long long value)\r\n{\r\nunion acpi_object param[2];\r\nstruct acpi_object_list input;\r\nacpi_status status;\r\nunsigned long long output;\r\nparam[0].type = ACPI_TYPE_INTEGER;\r\nparam[0].integer.value = 0xC1;\r\nparam[1].type = ACPI_TYPE_INTEGER;\r\nparam[1].integer.value = value;\r\ninput.count = 2;\r\ninput.pointer = param;\r\nstatus = acpi_evaluate_integer(handle, "GWRI", &input, &output);\r\nreturn status;\r\n}\r\nstatic void cmpc_rfkill_query(struct rfkill *rfkill, void *data)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nunsigned long long state;\r\nbool blocked;\r\nhandle = data;\r\nstatus = cmpc_get_rfkill_wlan(handle, &state);\r\nif (ACPI_SUCCESS(status)) {\r\nblocked = state & 1 ? false : true;\r\nrfkill_set_sw_state(rfkill, blocked);\r\n}\r\n}\r\nstatic int cmpc_rfkill_block(void *data, bool blocked)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nunsigned long long state;\r\nbool is_blocked;\r\nhandle = data;\r\nstatus = cmpc_get_rfkill_wlan(handle, &state);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nis_blocked = state & 1 ? false : true;\r\nif (is_blocked != blocked) {\r\nstate = blocked ? 0 : 1;\r\nstatus = cmpc_set_rfkill_wlan(handle, state);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmpc_ipml_add(struct acpi_device *acpi)\r\n{\r\nint retval;\r\nstruct ipml200_dev *ipml;\r\nstruct backlight_properties props;\r\nipml = kmalloc(sizeof(*ipml), GFP_KERNEL);\r\nif (ipml == NULL)\r\nreturn -ENOMEM;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = 7;\r\nipml->bd = backlight_device_register("cmpc_bl", &acpi->dev,\r\nacpi->handle, &cmpc_bl_ops,\r\n&props);\r\nif (IS_ERR(ipml->bd)) {\r\nretval = PTR_ERR(ipml->bd);\r\ngoto out_bd;\r\n}\r\nipml->rf = rfkill_alloc("cmpc_rfkill", &acpi->dev, RFKILL_TYPE_WLAN,\r\n&cmpc_rfkill_ops, acpi->handle);\r\nif (ipml->rf) {\r\nretval = rfkill_register(ipml->rf);\r\nif (retval) {\r\nrfkill_destroy(ipml->rf);\r\nipml->rf = NULL;\r\n}\r\n}\r\ndev_set_drvdata(&acpi->dev, ipml);\r\nreturn 0;\r\nout_bd:\r\nkfree(ipml);\r\nreturn retval;\r\n}\r\nstatic int cmpc_ipml_remove(struct acpi_device *acpi)\r\n{\r\nstruct ipml200_dev *ipml;\r\nipml = dev_get_drvdata(&acpi->dev);\r\nbacklight_device_unregister(ipml->bd);\r\nif (ipml->rf) {\r\nrfkill_unregister(ipml->rf);\r\nrfkill_destroy(ipml->rf);\r\n}\r\nkfree(ipml);\r\nreturn 0;\r\n}\r\nstatic void cmpc_keys_handler(struct acpi_device *dev, u32 event)\r\n{\r\nstruct input_dev *inputdev;\r\nint code = KEY_MAX;\r\nif ((event & 0x0F) < ARRAY_SIZE(cmpc_keys_codes))\r\ncode = cmpc_keys_codes[event & 0x0F];\r\ninputdev = dev_get_drvdata(&dev->dev);\r\ninput_report_key(inputdev, code, !(event & 0x10));\r\ninput_sync(inputdev);\r\n}\r\nstatic void cmpc_keys_idev_init(struct input_dev *inputdev)\r\n{\r\nint i;\r\nset_bit(EV_KEY, inputdev->evbit);\r\nfor (i = 0; cmpc_keys_codes[i] != KEY_MAX; i++)\r\nset_bit(cmpc_keys_codes[i], inputdev->keybit);\r\n}\r\nstatic int cmpc_keys_add(struct acpi_device *acpi)\r\n{\r\nreturn cmpc_add_acpi_notify_device(acpi, "cmpc_keys",\r\ncmpc_keys_idev_init);\r\n}\r\nstatic int cmpc_keys_remove(struct acpi_device *acpi)\r\n{\r\nreturn cmpc_remove_acpi_notify_device(acpi);\r\n}\r\nstatic int cmpc_init(void)\r\n{\r\nint r;\r\nr = acpi_bus_register_driver(&cmpc_keys_acpi_driver);\r\nif (r)\r\ngoto failed_keys;\r\nr = acpi_bus_register_driver(&cmpc_ipml_acpi_driver);\r\nif (r)\r\ngoto failed_bl;\r\nr = acpi_bus_register_driver(&cmpc_tablet_acpi_driver);\r\nif (r)\r\ngoto failed_tablet;\r\nr = acpi_bus_register_driver(&cmpc_accel_acpi_driver);\r\nif (r)\r\ngoto failed_accel;\r\nr = acpi_bus_register_driver(&cmpc_accel_acpi_driver_v4);\r\nif (r)\r\ngoto failed_accel_v4;\r\nreturn r;\r\nfailed_accel_v4:\r\nacpi_bus_unregister_driver(&cmpc_accel_acpi_driver);\r\nfailed_accel:\r\nacpi_bus_unregister_driver(&cmpc_tablet_acpi_driver);\r\nfailed_tablet:\r\nacpi_bus_unregister_driver(&cmpc_ipml_acpi_driver);\r\nfailed_bl:\r\nacpi_bus_unregister_driver(&cmpc_keys_acpi_driver);\r\nfailed_keys:\r\nreturn r;\r\n}\r\nstatic void cmpc_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&cmpc_accel_acpi_driver_v4);\r\nacpi_bus_unregister_driver(&cmpc_accel_acpi_driver);\r\nacpi_bus_unregister_driver(&cmpc_tablet_acpi_driver);\r\nacpi_bus_unregister_driver(&cmpc_ipml_acpi_driver);\r\nacpi_bus_unregister_driver(&cmpc_keys_acpi_driver);\r\n}
