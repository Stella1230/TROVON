static void\r\npci_disable_io_access(struct pci_dev *pdev)\r\n{\r\nu16 command_reg;\r\npci_read_config_word(pdev, PCI_COMMAND, &command_reg);\r\ncommand_reg &= ~1;\r\npci_write_config_word(pdev, PCI_COMMAND, command_reg);\r\n}\r\nstatic void\r\npci_enable_io_access(struct pci_dev *pdev)\r\n{\r\nu16 command_reg;\r\npci_read_config_word(pdev, PCI_COMMAND, &command_reg);\r\ncommand_reg |= 1;\r\npci_write_config_word(pdev, PCI_COMMAND, command_reg);\r\n}\r\nstatic int mpt_set_debug_level(const char *val, struct kernel_param *kp)\r\n{\r\nint ret = param_set_int(val, kp);\r\nMPT_ADAPTER *ioc;\r\nif (ret)\r\nreturn ret;\r\nlist_for_each_entry(ioc, &ioc_list, list)\r\nioc->debug_level = mpt_debug_level;\r\nreturn 0;\r\n}\r\nstatic u8\r\nmpt_get_cb_idx(MPT_DRIVER_CLASS dclass)\r\n{\r\nu8 cb_idx;\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--)\r\nif (MptDriverClass[cb_idx] == dclass)\r\nreturn cb_idx;\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_is_discovery_complete(MPT_ADAPTER *ioc)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasIOUnitPage0_t *buffer;\r\ndma_addr_t dma_handle;\r\nint rc = 0;\r\nmemset(&hdr, 0, sizeof(ConfigExtendedPageHeader_t));\r\nmemset(&cfg, 0, sizeof(CONFIGPARMS));\r\nhdr.PageVersion = MPI_SASIOUNITPAGE0_PAGEVERSION;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\nif ((mpt_config(ioc, &cfg)))\r\ngoto out;\r\nif (!hdr.ExtPageLength)\r\ngoto out;\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer)\r\ngoto out;\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((mpt_config(ioc, &cfg)))\r\ngoto out_free_consistent;\r\nif (!(buffer->PhyData[0].PortFlags &\r\nMPI_SAS_IOUNIT0_PORT_FLAGS_DISCOVERY_IN_PROGRESS))\r\nrc = 1;\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int mpt_remove_dead_ioc_func(void *arg)\r\n{\r\nMPT_ADAPTER *ioc = (MPT_ADAPTER *)arg;\r\nstruct pci_dev *pdev;\r\nif ((ioc == NULL))\r\nreturn -1;\r\npdev = ioc->pcidev;\r\nif ((pdev == NULL))\r\nreturn -1;\r\npci_stop_and_remove_bus_device(pdev);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpt_fault_reset_work(struct work_struct *work)\r\n{\r\nMPT_ADAPTER *ioc =\r\ncontainer_of(work, MPT_ADAPTER, fault_reset_work.work);\r\nu32 ioc_raw_state;\r\nint rc;\r\nunsigned long flags;\r\nMPT_SCSI_HOST *hd;\r\nstruct task_struct *p;\r\nif (ioc->ioc_reset_in_progress || !ioc->active)\r\ngoto out;\r\nioc_raw_state = mpt_GetIocState(ioc, 0);\r\nif ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_MASK) {\r\nprintk(MYIOC_s_INFO_FMT "%s: IOC is non-operational !!!!\n",\r\nioc->name, __func__);\r\nhd = shost_priv(ioc->sh);\r\nioc->schedule_dead_ioc_flush_running_cmds(hd);\r\np = kthread_run(mpt_remove_dead_ioc_func, ioc,\r\n"mpt_dead_ioc_%d", ioc->id);\r\nif (IS_ERR(p)) {\r\nprintk(MYIOC_s_ERR_FMT\r\n"%s: Running mpt_dead_ioc thread failed !\n",\r\nioc->name, __func__);\r\n} else {\r\nprintk(MYIOC_s_WARN_FMT\r\n"%s: Running mpt_dead_ioc thread success !\n",\r\nioc->name, __func__);\r\n}\r\nreturn;\r\n}\r\nif ((ioc_raw_state & MPI_IOC_STATE_MASK)\r\n== MPI_IOC_STATE_FAULT) {\r\nprintk(MYIOC_s_WARN_FMT "IOC is in FAULT state (%04xh)!!!\n",\r\nioc->name, ioc_raw_state & MPI_DOORBELL_DATA_MASK);\r\nprintk(MYIOC_s_WARN_FMT "Issuing HardReset from %s!!\n",\r\nioc->name, __func__);\r\nrc = mpt_HardResetHandler(ioc, CAN_SLEEP);\r\nprintk(MYIOC_s_WARN_FMT "%s: HardReset: %s\n", ioc->name,\r\n__func__, (rc == 0) ? "success" : "failed");\r\nioc_raw_state = mpt_GetIocState(ioc, 0);\r\nif ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT)\r\nprintk(MYIOC_s_WARN_FMT "IOC is in FAULT state after "\r\n"reset (%04xh)\n", ioc->name, ioc_raw_state &\r\nMPI_DOORBELL_DATA_MASK);\r\n} else if (ioc->bus_type == SAS && ioc->sas_discovery_quiesce_io) {\r\nif ((mpt_is_discovery_complete(ioc))) {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "clearing "\r\n"discovery_quiesce_io flag\n", ioc->name));\r\nioc->sas_discovery_quiesce_io = 0;\r\n}\r\n}\r\nout:\r\nif (ioc->alt_ioc)\r\nioc = ioc->alt_ioc;\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->reset_work_q)\r\nqueue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,\r\nmsecs_to_jiffies(MPT_POLLING_INTERVAL));\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\n}\r\nstatic void\r\nmpt_turbo_reply(MPT_ADAPTER *ioc, u32 pa)\r\n{\r\nMPT_FRAME_HDR *mf = NULL;\r\nMPT_FRAME_HDR *mr = NULL;\r\nu16 req_idx = 0;\r\nu8 cb_idx;\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Got TURBO reply req_idx=%08x\n",\r\nioc->name, pa));\r\nswitch (pa >> MPI_CONTEXT_REPLY_TYPE_SHIFT) {\r\ncase MPI_CONTEXT_REPLY_TYPE_SCSI_INIT:\r\nreq_idx = pa & 0x0000FFFF;\r\ncb_idx = (pa & 0x00FF0000) >> 16;\r\nmf = MPT_INDEX_2_MFPTR(ioc, req_idx);\r\nbreak;\r\ncase MPI_CONTEXT_REPLY_TYPE_LAN:\r\ncb_idx = mpt_get_cb_idx(MPTLAN_DRIVER);\r\nif ((pa & 0x58000000) == 0x58000000) {\r\nreq_idx = pa & 0x0000FFFF;\r\nmf = MPT_INDEX_2_MFPTR(ioc, req_idx);\r\nmpt_free_msg_frame(ioc, mf);\r\nmb();\r\nreturn;\r\nbreak;\r\n}\r\nmr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);\r\nbreak;\r\ncase MPI_CONTEXT_REPLY_TYPE_SCSI_TARGET:\r\ncb_idx = mpt_get_cb_idx(MPTSTM_DRIVER);\r\nmr = (MPT_FRAME_HDR *) CAST_U32_TO_PTR(pa);\r\nbreak;\r\ndefault:\r\ncb_idx = 0;\r\nBUG();\r\n}\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS ||\r\nMptCallbacks[cb_idx] == NULL) {\r\nprintk(MYIOC_s_WARN_FMT "%s: Invalid cb_idx (%d)!\n",\r\n__func__, ioc->name, cb_idx);\r\ngoto out;\r\n}\r\nif (MptCallbacks[cb_idx](ioc, mf, mr))\r\nmpt_free_msg_frame(ioc, mf);\r\nout:\r\nmb();\r\n}\r\nstatic void\r\nmpt_reply(MPT_ADAPTER *ioc, u32 pa)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nMPT_FRAME_HDR *mr;\r\nu16 req_idx;\r\nu8 cb_idx;\r\nint freeme;\r\nu32 reply_dma_low;\r\nu16 ioc_stat;\r\nreply_dma_low = (pa <<= 1);\r\nmr = (MPT_FRAME_HDR *)((u8 *)ioc->reply_frames +\r\n(reply_dma_low - ioc->reply_frames_low_dma));\r\nreq_idx = le16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx);\r\ncb_idx = mr->u.frame.hwhdr.msgctxu.fld.cb_idx;\r\nmf = MPT_INDEX_2_MFPTR(ioc, req_idx);\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Got non-TURBO reply=%p req_idx=%x cb_idx=%x Function=%x\n",\r\nioc->name, mr, req_idx, cb_idx, mr->u.hdr.Function));\r\nDBG_DUMP_REPLY_FRAME(ioc, (u32 *)mr);\r\nioc_stat = le16_to_cpu(mr->u.reply.IOCStatus);\r\nif (ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {\r\nu32 log_info = le32_to_cpu(mr->u.reply.IOCLogInfo);\r\nif (ioc->bus_type == FC)\r\nmpt_fc_log_info(ioc, log_info);\r\nelse if (ioc->bus_type == SPI)\r\nmpt_spi_log_info(ioc, log_info);\r\nelse if (ioc->bus_type == SAS)\r\nmpt_sas_log_info(ioc, log_info, cb_idx);\r\n}\r\nif (ioc_stat & MPI_IOCSTATUS_MASK)\r\nmpt_iocstatus_info(ioc, (u32)ioc_stat, mf);\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS ||\r\nMptCallbacks[cb_idx] == NULL) {\r\nprintk(MYIOC_s_WARN_FMT "%s: Invalid cb_idx (%d)!\n",\r\n__func__, ioc->name, cb_idx);\r\nfreeme = 0;\r\ngoto out;\r\n}\r\nfreeme = MptCallbacks[cb_idx](ioc, mf, mr);\r\nout:\r\nCHIPREG_WRITE32(&ioc->chip->ReplyFifo, pa);\r\nif (freeme)\r\nmpt_free_msg_frame(ioc, mf);\r\nmb();\r\n}\r\nstatic irqreturn_t\r\nmpt_interrupt(int irq, void *bus_id)\r\n{\r\nMPT_ADAPTER *ioc = bus_id;\r\nu32 pa = CHIPREG_READ32_dmasync(&ioc->chip->ReplyFifo);\r\nif (pa == 0xFFFFFFFF)\r\nreturn IRQ_NONE;\r\ndo {\r\nif (pa & MPI_ADDRESS_REPLY_A_BIT)\r\nmpt_reply(ioc, pa);\r\nelse\r\nmpt_turbo_reply(ioc, pa);\r\npa = CHIPREG_READ32_dmasync(&ioc->chip->ReplyFifo);\r\n} while (pa != 0xFFFFFFFF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nmptbase_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req, MPT_FRAME_HDR *reply)\r\n{\r\nEventNotificationReply_t *pEventReply;\r\nu8 event;\r\nint evHandlers;\r\nint freereq = 1;\r\nswitch (reply->u.hdr.Function) {\r\ncase MPI_FUNCTION_EVENT_NOTIFICATION:\r\npEventReply = (EventNotificationReply_t *)reply;\r\nevHandlers = 0;\r\nProcessEventNotification(ioc, pEventReply, &evHandlers);\r\nevent = le32_to_cpu(pEventReply->Event) & 0xFF;\r\nif (pEventReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY)\r\nfreereq = 0;\r\nif (event != MPI_EVENT_EVENT_CHANGE)\r\nbreak;\r\ncase MPI_FUNCTION_CONFIG:\r\ncase MPI_FUNCTION_SAS_IO_UNIT_CONTROL:\r\nioc->mptbase_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nif (reply) {\r\nioc->mptbase_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\r\nmemcpy(ioc->mptbase_cmds.reply, reply,\r\nmin(MPT_DEFAULT_FRAME_SIZE,\r\n4 * reply->u.reply.MsgLength));\r\n}\r\nif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->mptbase_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->mptbase_cmds.done);\r\n} else\r\nfreereq = 0;\r\nif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_FREE_MF)\r\nfreereq = 1;\r\nbreak;\r\ncase MPI_FUNCTION_EVENT_ACK:\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"EventAck reply received\n", ioc->name));\r\nbreak;\r\ndefault:\r\nprintk(MYIOC_s_ERR_FMT\r\n"Unexpected msg function (=%02Xh) reply received!\n",\r\nioc->name, reply->u.hdr.Function);\r\nbreak;\r\n}\r\nreturn freereq;\r\n}\r\nu8\r\nmpt_register(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass, char *func_name)\r\n{\r\nu8 cb_idx;\r\nlast_drv_idx = MPT_MAX_PROTOCOL_DRIVERS;\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptCallbacks[cb_idx] == NULL) {\r\nMptCallbacks[cb_idx] = cbfunc;\r\nMptDriverClass[cb_idx] = dclass;\r\nMptEvHandlers[cb_idx] = NULL;\r\nlast_drv_idx = cb_idx;\r\nstrlcpy(MptCallbacksName[cb_idx], func_name,\r\nMPT_MAX_CALLBACKNAME_LEN+1);\r\nbreak;\r\n}\r\n}\r\nreturn last_drv_idx;\r\n}\r\nvoid\r\nmpt_deregister(u8 cb_idx)\r\n{\r\nif (cb_idx && (cb_idx < MPT_MAX_PROTOCOL_DRIVERS)) {\r\nMptCallbacks[cb_idx] = NULL;\r\nMptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;\r\nMptEvHandlers[cb_idx] = NULL;\r\nlast_drv_idx++;\r\n}\r\n}\r\nint\r\nmpt_event_register(u8 cb_idx, MPT_EVHANDLER ev_cbfunc)\r\n{\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\r\nreturn -1;\r\nMptEvHandlers[cb_idx] = ev_cbfunc;\r\nreturn 0;\r\n}\r\nvoid\r\nmpt_event_deregister(u8 cb_idx)\r\n{\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\r\nreturn;\r\nMptEvHandlers[cb_idx] = NULL;\r\n}\r\nint\r\nmpt_reset_register(u8 cb_idx, MPT_RESETHANDLER reset_func)\r\n{\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\r\nreturn -1;\r\nMptResetHandlers[cb_idx] = reset_func;\r\nreturn 0;\r\n}\r\nvoid\r\nmpt_reset_deregister(u8 cb_idx)\r\n{\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\r\nreturn;\r\nMptResetHandlers[cb_idx] = NULL;\r\n}\r\nint\r\nmpt_device_driver_register(struct mpt_pci_driver * dd_cbfunc, u8 cb_idx)\r\n{\r\nMPT_ADAPTER *ioc;\r\nconst struct pci_device_id *id;\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\r\nreturn -EINVAL;\r\nMptDeviceDriverHandlers[cb_idx] = dd_cbfunc;\r\nlist_for_each_entry(ioc, &ioc_list, list) {\r\nid = ioc->pcidev->driver ?\r\nioc->pcidev->driver->id_table : NULL;\r\nif (dd_cbfunc->probe)\r\ndd_cbfunc->probe(ioc->pcidev, id);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nmpt_device_driver_deregister(u8 cb_idx)\r\n{\r\nstruct mpt_pci_driver *dd_cbfunc;\r\nMPT_ADAPTER *ioc;\r\nif (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS)\r\nreturn;\r\ndd_cbfunc = MptDeviceDriverHandlers[cb_idx];\r\nlist_for_each_entry(ioc, &ioc_list, list) {\r\nif (dd_cbfunc->remove)\r\ndd_cbfunc->remove(ioc->pcidev);\r\n}\r\nMptDeviceDriverHandlers[cb_idx] = NULL;\r\n}\r\nMPT_FRAME_HDR*\r\nmpt_get_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nunsigned long flags;\r\nu16 req_idx;\r\n#ifdef MFCNT\r\nif (!ioc->active)\r\nprintk(MYIOC_s_WARN_FMT "IOC Not Active! mpt_get_msg_frame "\r\n"returning NULL!\n", ioc->name);\r\n#endif\r\nif (!ioc->active)\r\nreturn NULL;\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nif (!list_empty(&ioc->FreeQ)) {\r\nint req_offset;\r\nmf = list_entry(ioc->FreeQ.next, MPT_FRAME_HDR,\r\nu.frame.linkage.list);\r\nlist_del(&mf->u.frame.linkage.list);\r\nmf->u.frame.linkage.arg1 = 0;\r\nmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\r\nreq_offset = (u8 *)mf - (u8 *)ioc->req_frames;\r\nreq_idx = req_offset / ioc->req_sz;\r\nmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);\r\nmf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;\r\nioc->RequestNB[req_idx] = ioc->NB_for_64_byte_frame;\r\n#ifdef MFCNT\r\nioc->mfcnt++;\r\n#endif\r\n}\r\nelse\r\nmf = NULL;\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\n#ifdef MFCNT\r\nif (mf == NULL)\r\nprintk(MYIOC_s_WARN_FMT "IOC Active. No free Msg Frames! "\r\n"Count 0x%x Max 0x%x\n", ioc->name, ioc->mfcnt,\r\nioc->req_depth);\r\nmfcounter++;\r\nif (mfcounter == PRINT_MF_COUNT)\r\nprintk(MYIOC_s_INFO_FMT "MF Count 0x%x Max 0x%x \n", ioc->name,\r\nioc->mfcnt, ioc->req_depth);\r\n#endif\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mpt_get_msg_frame(%d,%d), got mf=%p\n",\r\nioc->name, cb_idx, ioc->id, mf));\r\nreturn mf;\r\n}\r\nvoid\r\nmpt_put_msg_frame(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\r\n{\r\nu32 mf_dma_addr;\r\nint req_offset;\r\nu16 req_idx;\r\nmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\r\nreq_offset = (u8 *)mf - (u8 *)ioc->req_frames;\r\nreq_idx = req_offset / ioc->req_sz;\r\nmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);\r\nmf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;\r\nDBG_DUMP_PUT_MSG_FRAME(ioc, (u32 *)mf);\r\nmf_dma_addr = (ioc->req_frames_low_dma + req_offset) | ioc->RequestNB[req_idx];\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mf_dma_addr=%x req_idx=%d "\r\n"RequestNB=%x\n", ioc->name, mf_dma_addr, req_idx,\r\nioc->RequestNB[req_idx]));\r\nCHIPREG_WRITE32(&ioc->chip->RequestFifo, mf_dma_addr);\r\n}\r\nvoid\r\nmpt_put_msg_frame_hi_pri(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\r\n{\r\nu32 mf_dma_addr;\r\nint req_offset;\r\nu16 req_idx;\r\nmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\r\nreq_offset = (u8 *)mf - (u8 *)ioc->req_frames;\r\nreq_idx = req_offset / ioc->req_sz;\r\nmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(req_idx);\r\nmf->u.frame.hwhdr.msgctxu.fld.rsvd = 0;\r\nDBG_DUMP_PUT_MSG_FRAME(ioc, (u32 *)mf);\r\nmf_dma_addr = (ioc->req_frames_low_dma + req_offset);\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mf_dma_addr=%x req_idx=%d\n",\r\nioc->name, mf_dma_addr, req_idx));\r\nCHIPREG_WRITE32(&ioc->chip->RequestHiPriFifo, mf_dma_addr);\r\n}\r\nvoid\r\nmpt_free_msg_frame(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nif (cpu_to_le32(mf->u.frame.linkage.arg1) == 0xdeadbeaf)\r\ngoto out;\r\nmf->u.frame.linkage.arg1 = cpu_to_le32(0xdeadbeaf);\r\nlist_add_tail(&mf->u.frame.linkage.list, &ioc->FreeQ);\r\n#ifdef MFCNT\r\nioc->mfcnt--;\r\n#endif\r\nout:\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\n}\r\nstatic void\r\nmpt_add_sge(void *pAddr, u32 flagslength, dma_addr_t dma_addr)\r\n{\r\nSGESimple32_t *pSge = (SGESimple32_t *) pAddr;\r\npSge->FlagsLength = cpu_to_le32(flagslength);\r\npSge->Address = cpu_to_le32(dma_addr);\r\n}\r\nstatic void\r\nmpt_add_sge_64bit(void *pAddr, u32 flagslength, dma_addr_t dma_addr)\r\n{\r\nSGESimple64_t *pSge = (SGESimple64_t *) pAddr;\r\npSge->Address.Low = cpu_to_le32\r\n(lower_32_bits(dma_addr));\r\npSge->Address.High = cpu_to_le32\r\n(upper_32_bits(dma_addr));\r\npSge->FlagsLength = cpu_to_le32\r\n((flagslength | MPT_SGE_FLAGS_64_BIT_ADDRESSING));\r\n}\r\nstatic void\r\nmpt_add_sge_64bit_1078(void *pAddr, u32 flagslength, dma_addr_t dma_addr)\r\n{\r\nSGESimple64_t *pSge = (SGESimple64_t *) pAddr;\r\nu32 tmp;\r\npSge->Address.Low = cpu_to_le32\r\n(lower_32_bits(dma_addr));\r\ntmp = (u32)(upper_32_bits(dma_addr));\r\nif ((((u64)dma_addr + MPI_SGE_LENGTH(flagslength)) >> 32) == 9) {\r\nflagslength |=\r\nMPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LOCAL_ADDRESS);\r\ntmp |= (1<<31);\r\nif (mpt_debug_level & MPT_DEBUG_36GB_MEM)\r\nprintk(KERN_DEBUG "1078 P0M2 addressing for "\r\n"addr = 0x%llx len = %d\n",\r\n(unsigned long long)dma_addr,\r\nMPI_SGE_LENGTH(flagslength));\r\n}\r\npSge->Address.High = cpu_to_le32(tmp);\r\npSge->FlagsLength = cpu_to_le32(\r\n(flagslength | MPT_SGE_FLAGS_64_BIT_ADDRESSING));\r\n}\r\nstatic void\r\nmpt_add_chain(void *pAddr, u8 next, u16 length, dma_addr_t dma_addr)\r\n{\r\nSGEChain32_t *pChain = (SGEChain32_t *) pAddr;\r\npChain->Length = cpu_to_le16(length);\r\npChain->Flags = MPI_SGE_FLAGS_CHAIN_ELEMENT;\r\npChain->NextChainOffset = next;\r\npChain->Address = cpu_to_le32(dma_addr);\r\n}\r\nstatic void\r\nmpt_add_chain_64bit(void *pAddr, u8 next, u16 length, dma_addr_t dma_addr)\r\n{\r\nSGEChain64_t *pChain = (SGEChain64_t *) pAddr;\r\nu32 tmp = dma_addr & 0xFFFFFFFF;\r\npChain->Length = cpu_to_le16(length);\r\npChain->Flags = (MPI_SGE_FLAGS_CHAIN_ELEMENT |\r\nMPI_SGE_FLAGS_64_BIT_ADDRESSING);\r\npChain->NextChainOffset = next;\r\npChain->Address.Low = cpu_to_le32(tmp);\r\ntmp = (u32)(upper_32_bits(dma_addr));\r\npChain->Address.High = cpu_to_le32(tmp);\r\n}\r\nint\r\nmpt_send_handshake_request(u8 cb_idx, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag)\r\n{\r\nint r = 0;\r\nu8 *req_as_bytes;\r\nint ii;\r\nii = MFPTR_2_MPT_INDEX(ioc,(MPT_FRAME_HDR*)req);\r\nif (reqBytes >= 12 && ii >= 0 && ii < ioc->req_depth) {\r\nMPT_FRAME_HDR *mf = (MPT_FRAME_HDR*)req;\r\nmf->u.frame.hwhdr.msgctxu.fld.req_idx = cpu_to_le16(ii);\r\nmf->u.frame.hwhdr.msgctxu.fld.cb_idx = cb_idx;\r\n}\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell,\r\n((MPI_FUNCTION_HANDSHAKE<<MPI_DOORBELL_FUNCTION_SHIFT) |\r\n((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));\r\nif ((ii = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0) {\r\nreturn ii;\r\n}\r\nif (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))\r\nreturn -5;\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mpt_send_handshake_request start, WaitCnt=%d\n",\r\nioc->name, ii));\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {\r\nreturn -2;\r\n}\r\nreq_as_bytes = (u8 *) req;\r\nfor (ii = 0; ii < reqBytes/4; ii++) {\r\nu32 word;\r\nword = ((req_as_bytes[(ii*4) + 0] << 0) |\r\n(req_as_bytes[(ii*4) + 1] << 8) |\r\n(req_as_bytes[(ii*4) + 2] << 16) |\r\n(req_as_bytes[(ii*4) + 3] << 24));\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell, word);\r\nif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {\r\nr = -3;\r\nbreak;\r\n}\r\n}\r\nif (r >= 0 && WaitForDoorbellInt(ioc, 10, sleepFlag) >= 0)\r\nr = 0;\r\nelse\r\nr = -4;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nreturn r;\r\n}\r\nstatic int\r\nmpt_host_page_access_control(MPT_ADAPTER *ioc, u8 access_control_value, int sleepFlag)\r\n{\r\nint r = 0;\r\nif (CHIPREG_READ32(&ioc->chip->Doorbell)\r\n& MPI_DOORBELL_ACTIVE)\r\nreturn -1;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell,\r\n((MPI_FUNCTION_HOST_PAGEBUF_ACCESS_CONTROL\r\n<<MPI_DOORBELL_FUNCTION_SHIFT) |\r\n(access_control_value<<12)));\r\nif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0) {\r\nreturn -2;\r\n}else\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_host_page_alloc(MPT_ADAPTER *ioc, pIOCInit_t ioc_init)\r\n{\r\nchar *psge;\r\nint flags_length;\r\nu32 host_page_buffer_sz=0;\r\nif(!ioc->HostPageBuffer) {\r\nhost_page_buffer_sz =\r\nle32_to_cpu(ioc->facts.HostPageBufferSGE.FlagsLength) & 0xFFFFFF;\r\nif(!host_page_buffer_sz)\r\nreturn 0;\r\nwhile(host_page_buffer_sz > 0) {\r\nif((ioc->HostPageBuffer = pci_alloc_consistent(\r\nioc->pcidev,\r\nhost_page_buffer_sz,\r\n&ioc->HostPageBuffer_dma)) != NULL) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"host_page_buffer @ %p, dma @ %x, sz=%d bytes\n",\r\nioc->name, ioc->HostPageBuffer,\r\n(u32)ioc->HostPageBuffer_dma,\r\nhost_page_buffer_sz));\r\nioc->alloc_total += host_page_buffer_sz;\r\nioc->HostPageBuffer_sz = host_page_buffer_sz;\r\nbreak;\r\n}\r\nhost_page_buffer_sz -= (4*1024);\r\n}\r\n}\r\nif(!ioc->HostPageBuffer) {\r\nprintk(MYIOC_s_ERR_FMT\r\n"Failed to alloc memory for host_page_buffer!\n",\r\nioc->name);\r\nreturn -999;\r\n}\r\npsge = (char *)&ioc_init->HostPageBufferSGE;\r\nflags_length = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_SYSTEM_ADDRESS |\r\nMPI_SGE_FLAGS_HOST_TO_IOC |\r\nMPI_SGE_FLAGS_END_OF_BUFFER;\r\nflags_length = flags_length << MPI_SGE_FLAGS_SHIFT;\r\nflags_length |= ioc->HostPageBuffer_sz;\r\nioc->add_sge(psge, flags_length, ioc->HostPageBuffer_dma);\r\nioc->facts.HostPageBufferSGE = ioc_init->HostPageBufferSGE;\r\nreturn 0;\r\n}\r\nint\r\nmpt_verify_adapter(int iocid, MPT_ADAPTER **iocpp)\r\n{\r\nMPT_ADAPTER *ioc;\r\nlist_for_each_entry(ioc,&ioc_list,list) {\r\nif (ioc->id == iocid) {\r\n*iocpp =ioc;\r\nreturn iocid;\r\n}\r\n}\r\n*iocpp = NULL;\r\nreturn -1;\r\n}\r\nstatic void\r\nmpt_get_product_name(u16 vendor, u16 device, u8 revision, char *prod_name)\r\n{\r\nchar *product_str = NULL;\r\nif (vendor == PCI_VENDOR_ID_BROCADE) {\r\nswitch (device)\r\n{\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC949E:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "BRE040 A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "BRE040 A1";\r\nbreak;\r\ndefault:\r\nproduct_str = "BRE040";\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nswitch (device)\r\n{\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC909:\r\nproduct_str = "LSIFC909 B1";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC919:\r\nproduct_str = "LSIFC919 B0";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC929:\r\nproduct_str = "LSIFC929 B0";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC919X:\r\nif (revision < 0x80)\r\nproduct_str = "LSIFC919X A0";\r\nelse\r\nproduct_str = "LSIFC919XL A1";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC929X:\r\nif (revision < 0x80)\r\nproduct_str = "LSIFC929X A0";\r\nelse\r\nproduct_str = "LSIFC929XL A1";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC939X:\r\nproduct_str = "LSIFC939X A1";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC949X:\r\nproduct_str = "LSIFC949X A1";\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC949E:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSIFC949E A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSIFC949E A1";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSIFC949E";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_53C1030:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSI53C1030 A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSI53C1030 B0";\r\nbreak;\r\ncase 0x03:\r\nproduct_str = "LSI53C1030 B1";\r\nbreak;\r\ncase 0x07:\r\nproduct_str = "LSI53C1030 B2";\r\nbreak;\r\ncase 0x08:\r\nproduct_str = "LSI53C1030 C0";\r\nbreak;\r\ncase 0x80:\r\nproduct_str = "LSI53C1030T A0";\r\nbreak;\r\ncase 0x83:\r\nproduct_str = "LSI53C1030T A2";\r\nbreak;\r\ncase 0x87:\r\nproduct_str = "LSI53C1030T A3";\r\nbreak;\r\ncase 0xc1:\r\nproduct_str = "LSI53C1020A A1";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSI53C1030";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_1030_53C1035:\r\nswitch (revision)\r\n{\r\ncase 0x03:\r\nproduct_str = "LSI53C1035 A2";\r\nbreak;\r\ncase 0x04:\r\nproduct_str = "LSI53C1035 B0";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSI53C1035";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1064:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSISAS1064 A1";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSISAS1064 A2";\r\nbreak;\r\ncase 0x02:\r\nproduct_str = "LSISAS1064 A3";\r\nbreak;\r\ncase 0x03:\r\nproduct_str = "LSISAS1064 A4";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSISAS1064";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1064E:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSISAS1064E A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSISAS1064E B0";\r\nbreak;\r\ncase 0x02:\r\nproduct_str = "LSISAS1064E B1";\r\nbreak;\r\ncase 0x04:\r\nproduct_str = "LSISAS1064E B2";\r\nbreak;\r\ncase 0x08:\r\nproduct_str = "LSISAS1064E B3";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSISAS1064E";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1068:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSISAS1068 A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSISAS1068 B0";\r\nbreak;\r\ncase 0x02:\r\nproduct_str = "LSISAS1068 B1";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSISAS1068";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1068E:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSISAS1068E A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSISAS1068E B0";\r\nbreak;\r\ncase 0x02:\r\nproduct_str = "LSISAS1068E B1";\r\nbreak;\r\ncase 0x04:\r\nproduct_str = "LSISAS1068E B2";\r\nbreak;\r\ncase 0x08:\r\nproduct_str = "LSISAS1068E B3";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSISAS1068E";\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1078:\r\nswitch (revision)\r\n{\r\ncase 0x00:\r\nproduct_str = "LSISAS1078 A0";\r\nbreak;\r\ncase 0x01:\r\nproduct_str = "LSISAS1078 B0";\r\nbreak;\r\ncase 0x02:\r\nproduct_str = "LSISAS1078 C0";\r\nbreak;\r\ncase 0x03:\r\nproduct_str = "LSISAS1078 C1";\r\nbreak;\r\ncase 0x04:\r\nproduct_str = "LSISAS1078 C2";\r\nbreak;\r\ndefault:\r\nproduct_str = "LSISAS1078";\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nout:\r\nif (product_str)\r\nsprintf(prod_name, "%s", product_str);\r\n}\r\nstatic int\r\nmpt_mapresources(MPT_ADAPTER *ioc)\r\n{\r\nu8 __iomem *mem;\r\nint ii;\r\nresource_size_t mem_phys;\r\nunsigned long port;\r\nu32 msize;\r\nu32 psize;\r\nint r = -ENODEV;\r\nstruct pci_dev *pdev;\r\npdev = ioc->pcidev;\r\nioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);\r\nif (pci_enable_device_mem(pdev)) {\r\nprintk(MYIOC_s_ERR_FMT "pci_enable_device_mem() "\r\n"failed\n", ioc->name);\r\nreturn r;\r\n}\r\nif (pci_request_selected_regions(pdev, ioc->bars, "mpt")) {\r\nprintk(MYIOC_s_ERR_FMT "pci_request_selected_regions() with "\r\n"MEM failed\n", ioc->name);\r\ngoto out_pci_disable_device;\r\n}\r\nif (sizeof(dma_addr_t) > 4) {\r\nconst uint64_t required_mask = dma_get_required_mask\r\n(&pdev->dev);\r\nif (required_mask > DMA_BIT_MASK(32)\r\n&& !pci_set_dma_mask(pdev, DMA_BIT_MASK(64))\r\n&& !pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(64))) {\r\nioc->dma_mask = DMA_BIT_MASK(64);\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n": 64 BIT PCI BUS DMA ADDRESSING SUPPORTED\n",\r\nioc->name));\r\n} else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(32))) {\r\nioc->dma_mask = DMA_BIT_MASK(32);\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n": 32 BIT PCI BUS DMA ADDRESSING SUPPORTED\n",\r\nioc->name));\r\n} else {\r\nprintk(MYIOC_s_WARN_FMT "no suitable DMA mask for %s\n",\r\nioc->name, pci_name(pdev));\r\ngoto out_pci_release_region;\r\n}\r\n} else {\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(32))) {\r\nioc->dma_mask = DMA_BIT_MASK(32);\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n": 32 BIT PCI BUS DMA ADDRESSING SUPPORTED\n",\r\nioc->name));\r\n} else {\r\nprintk(MYIOC_s_WARN_FMT "no suitable DMA mask for %s\n",\r\nioc->name, pci_name(pdev));\r\ngoto out_pci_release_region;\r\n}\r\n}\r\nmem_phys = msize = 0;\r\nport = psize = 0;\r\nfor (ii = 0; ii < DEVICE_COUNT_RESOURCE; ii++) {\r\nif (pci_resource_flags(pdev, ii) & PCI_BASE_ADDRESS_SPACE_IO) {\r\nif (psize)\r\ncontinue;\r\nport = pci_resource_start(pdev, ii);\r\npsize = pci_resource_len(pdev, ii);\r\n} else {\r\nif (msize)\r\ncontinue;\r\nmem_phys = pci_resource_start(pdev, ii);\r\nmsize = pci_resource_len(pdev, ii);\r\n}\r\n}\r\nioc->mem_size = msize;\r\nmem = NULL;\r\nmem = ioremap(mem_phys, msize);\r\nif (mem == NULL) {\r\nprintk(MYIOC_s_ERR_FMT ": ERROR - Unable to map adapter"\r\n" memory!\n", ioc->name);\r\nr = -EINVAL;\r\ngoto out_pci_release_region;\r\n}\r\nioc->memmap = mem;\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT "mem = %p, mem_phys = %llx\n",\r\nioc->name, mem, (unsigned long long)mem_phys));\r\nioc->mem_phys = mem_phys;\r\nioc->chip = (SYSIF_REGS __iomem *)mem;\r\nioc->pio_mem_phys = port;\r\nioc->pio_chip = (SYSIF_REGS __iomem *)port;\r\nreturn 0;\r\nout_pci_release_region:\r\npci_release_selected_regions(pdev, ioc->bars);\r\nout_pci_disable_device:\r\npci_disable_device(pdev);\r\nreturn r;\r\n}\r\nint\r\nmpt_attach(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nMPT_ADAPTER *ioc;\r\nu8 cb_idx;\r\nint r = -ENODEV;\r\nu8 pcixcmd;\r\nstatic int mpt_ids = 0;\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *dent;\r\n#endif\r\nioc = kzalloc(sizeof(MPT_ADAPTER), GFP_ATOMIC);\r\nif (ioc == NULL) {\r\nprintk(KERN_ERR MYNAM ": ERROR - Insufficient memory to add adapter!\n");\r\nreturn -ENOMEM;\r\n}\r\nioc->id = mpt_ids++;\r\nsprintf(ioc->name, "ioc%d", ioc->id);\r\ndinitprintk(ioc, printk(KERN_WARNING MYNAM ": mpt_adapter_install\n"));\r\nioc->debug_level = mpt_debug_level;\r\nif (mpt_debug_level)\r\nprintk(KERN_INFO "mpt_debug_level=%xh\n", mpt_debug_level);\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT ": mpt_adapter_install\n", ioc->name));\r\nioc->pcidev = pdev;\r\nif (mpt_mapresources(ioc)) {\r\nkfree(ioc);\r\nreturn r;\r\n}\r\nif (ioc->dma_mask == DMA_BIT_MASK(64)) {\r\nif (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1078)\r\nioc->add_sge = &mpt_add_sge_64bit_1078;\r\nelse\r\nioc->add_sge = &mpt_add_sge_64bit;\r\nioc->add_chain = &mpt_add_chain_64bit;\r\nioc->sg_addr_size = 8;\r\n} else {\r\nioc->add_sge = &mpt_add_sge;\r\nioc->add_chain = &mpt_add_chain;\r\nioc->sg_addr_size = 4;\r\n}\r\nioc->SGE_size = sizeof(u32) + ioc->sg_addr_size;\r\nioc->alloc_total = sizeof(MPT_ADAPTER);\r\nioc->req_sz = MPT_DEFAULT_FRAME_SIZE;\r\nioc->reply_sz = MPT_REPLY_FRAME_SIZE;\r\nspin_lock_init(&ioc->taskmgmt_lock);\r\nmutex_init(&ioc->internal_cmds.mutex);\r\ninit_completion(&ioc->internal_cmds.done);\r\nmutex_init(&ioc->mptbase_cmds.mutex);\r\ninit_completion(&ioc->mptbase_cmds.done);\r\nmutex_init(&ioc->taskmgmt_cmds.mutex);\r\ninit_completion(&ioc->taskmgmt_cmds.done);\r\nioc->eventTypes = 0;\r\nioc->eventContext = 0;\r\nioc->eventLogSize = 0;\r\nioc->events = NULL;\r\n#ifdef MFCNT\r\nioc->mfcnt = 0;\r\n#endif\r\nioc->sh = NULL;\r\nioc->cached_fw = NULL;\r\nmemset(&ioc->spi_data, 0, sizeof(SpiCfgData));\r\nINIT_LIST_HEAD(&ioc->fc_rports);\r\nINIT_LIST_HEAD(&ioc->list);\r\nINIT_DELAYED_WORK(&ioc->fault_reset_work, mpt_fault_reset_work);\r\nsnprintf(ioc->reset_work_q_name, MPT_KOBJ_NAME_LEN,\r\n"mpt_poll_%d", ioc->id);\r\nioc->reset_work_q =\r\ncreate_singlethread_workqueue(ioc->reset_work_q_name);\r\nif (!ioc->reset_work_q) {\r\nprintk(MYIOC_s_ERR_FMT "Insufficient memory to add adapter!\n",\r\nioc->name);\r\npci_release_selected_regions(pdev, ioc->bars);\r\nkfree(ioc);\r\nreturn -ENOMEM;\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT "facts @ %p, pfacts[0] @ %p\n",\r\nioc->name, &ioc->facts, &ioc->pfacts[0]));\r\nmpt_get_product_name(pdev->vendor, pdev->device, pdev->revision,\r\nioc->prod_name);\r\nswitch (pdev->device)\r\n{\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC939X:\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC949X:\r\nioc->errata_flag_1064 = 1;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC909:\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC929:\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC919:\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC949E:\r\nioc->bus_type = FC;\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC929X:\r\nif (pdev->revision < XL_929) {\r\npci_read_config_byte(pdev, 0x6a, &pcixcmd);\r\npcixcmd &= 0x8F;\r\npci_write_config_byte(pdev, 0x6a, pcixcmd);\r\n} else {\r\npci_read_config_byte(pdev, 0x6a, &pcixcmd);\r\npcixcmd |= 0x08;\r\npci_write_config_byte(pdev, 0x6a, pcixcmd);\r\n}\r\nioc->bus_type = FC;\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVICEID_FC919X:\r\npci_read_config_byte(pdev, 0x6a, &pcixcmd);\r\npcixcmd &= 0x8F;\r\npci_write_config_byte(pdev, 0x6a, pcixcmd);\r\nioc->bus_type = FC;\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_53C1030:\r\nif (pdev->revision < C0_1030) {\r\npci_read_config_byte(pdev, 0x6a, &pcixcmd);\r\npcixcmd &= 0x8F;\r\npci_write_config_byte(pdev, 0x6a, pcixcmd);\r\n}\r\ncase MPI_MANUFACTPAGE_DEVID_1030_53C1035:\r\nioc->bus_type = SPI;\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1064:\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1068:\r\nioc->errata_flag_1064 = 1;\r\nioc->bus_type = SAS;\r\nbreak;\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1064E:\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1068E:\r\ncase MPI_MANUFACTPAGE_DEVID_SAS1078:\r\nioc->bus_type = SAS;\r\nbreak;\r\n}\r\nswitch (ioc->bus_type) {\r\ncase SAS:\r\nioc->msi_enable = mpt_msi_enable_sas;\r\nbreak;\r\ncase SPI:\r\nioc->msi_enable = mpt_msi_enable_spi;\r\nbreak;\r\ncase FC:\r\nioc->msi_enable = mpt_msi_enable_fc;\r\nbreak;\r\ndefault:\r\nioc->msi_enable = 0;\r\nbreak;\r\n}\r\nioc->fw_events_off = 1;\r\nif (ioc->errata_flag_1064)\r\npci_disable_io_access(pdev);\r\nspin_lock_init(&ioc->FreeQlock);\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\r\nioc->active = 0;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\npci_set_drvdata(ioc->pcidev, ioc);\r\nlist_add_tail(&ioc->list, &ioc_list);\r\nmpt_detect_bound_ports(ioc, pdev);\r\nINIT_LIST_HEAD(&ioc->fw_event_list);\r\nspin_lock_init(&ioc->fw_event_lock);\r\nsnprintf(ioc->fw_event_q_name, MPT_KOBJ_NAME_LEN, "mpt/%d", ioc->id);\r\nioc->fw_event_q = create_singlethread_workqueue(ioc->fw_event_q_name);\r\nif ((r = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP,\r\nCAN_SLEEP)) != 0){\r\nprintk(MYIOC_s_ERR_FMT "didn't initialize properly! (%d)\n",\r\nioc->name, r);\r\nlist_del(&ioc->list);\r\nif (ioc->alt_ioc)\r\nioc->alt_ioc->alt_ioc = NULL;\r\niounmap(ioc->memmap);\r\nif (r != -5)\r\npci_release_selected_regions(pdev, ioc->bars);\r\ndestroy_workqueue(ioc->reset_work_q);\r\nioc->reset_work_q = NULL;\r\nkfree(ioc);\r\npci_set_drvdata(pdev, NULL);\r\nreturn r;\r\n}\r\nfor(cb_idx = 0; cb_idx < MPT_MAX_PROTOCOL_DRIVERS; cb_idx++) {\r\nif(MptDeviceDriverHandlers[cb_idx] &&\r\nMptDeviceDriverHandlers[cb_idx]->probe) {\r\nMptDeviceDriverHandlers[cb_idx]->probe(pdev,id);\r\n}\r\n}\r\n#ifdef CONFIG_PROC_FS\r\ndent = proc_mkdir(ioc->name, mpt_proc_root_dir);\r\nif (dent) {\r\nproc_create_data("info", S_IRUGO, dent, &mpt_iocinfo_proc_fops, ioc);\r\nproc_create_data("summary", S_IRUGO, dent, &mpt_summary_proc_fops, ioc);\r\n}\r\n#endif\r\nif (!ioc->alt_ioc)\r\nqueue_delayed_work(ioc->reset_work_q, &ioc->fault_reset_work,\r\nmsecs_to_jiffies(MPT_POLLING_INTERVAL));\r\nreturn 0;\r\n}\r\nvoid\r\nmpt_detach(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nchar pname[32];\r\nu8 cb_idx;\r\nunsigned long flags;\r\nstruct workqueue_struct *wq;\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nwq = ioc->reset_work_q;\r\nioc->reset_work_q = NULL;\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\ncancel_delayed_work(&ioc->fault_reset_work);\r\ndestroy_workqueue(wq);\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nwq = ioc->fw_event_q;\r\nioc->fw_event_q = NULL;\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\ndestroy_workqueue(wq);\r\nsprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s/summary", ioc->name);\r\nremove_proc_entry(pname, NULL);\r\nsprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s/info", ioc->name);\r\nremove_proc_entry(pname, NULL);\r\nsprintf(pname, MPT_PROCFS_MPTBASEDIR "/%s", ioc->name);\r\nremove_proc_entry(pname, NULL);\r\nfor(cb_idx = 0; cb_idx < MPT_MAX_PROTOCOL_DRIVERS; cb_idx++) {\r\nif(MptDeviceDriverHandlers[cb_idx] &&\r\nMptDeviceDriverHandlers[cb_idx]->remove) {\r\nMptDeviceDriverHandlers[cb_idx]->remove(pdev);\r\n}\r\n}\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\r\nioc->active = 0;\r\nsynchronize_irq(pdev->irq);\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nCHIPREG_READ32(&ioc->chip->IntStatus);\r\nmpt_adapter_dispose(ioc);\r\n}\r\nint\r\nmpt_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nu32 device_state;\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\ndevice_state = pci_choose_state(pdev, state);\r\nprintk(MYIOC_s_INFO_FMT "pci-suspend: pdev=0x%p, slot=%s, Entering "\r\n"operating state [D%d]\n", ioc->name, pdev, pci_name(pdev),\r\ndevice_state);\r\nif(SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, CAN_SLEEP)) {\r\nprintk(MYIOC_s_ERR_FMT\r\n"pci-suspend: IOC msg unit reset failed!\n", ioc->name);\r\n}\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\r\nioc->active = 0;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nfree_irq(ioc->pci_irq, ioc);\r\nif (ioc->msi_enable)\r\npci_disable_msi(ioc->pcidev);\r\nioc->pci_irq = -1;\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_release_selected_regions(pdev, ioc->bars);\r\npci_set_power_state(pdev, device_state);\r\nreturn 0;\r\n}\r\nint\r\nmpt_resume(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nu32 device_state = pdev->current_state;\r\nint recovery_state;\r\nint err;\r\nprintk(MYIOC_s_INFO_FMT "pci-resume: pdev=0x%p, slot=%s, Previous "\r\n"operating state [D%d]\n", ioc->name, pdev, pci_name(pdev),\r\ndevice_state);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nioc->pcidev = pdev;\r\nerr = mpt_mapresources(ioc);\r\nif (err)\r\nreturn err;\r\nif (ioc->dma_mask == DMA_BIT_MASK(64)) {\r\nif (pdev->device == MPI_MANUFACTPAGE_DEVID_SAS1078)\r\nioc->add_sge = &mpt_add_sge_64bit_1078;\r\nelse\r\nioc->add_sge = &mpt_add_sge_64bit;\r\nioc->add_chain = &mpt_add_chain_64bit;\r\nioc->sg_addr_size = 8;\r\n} else {\r\nioc->add_sge = &mpt_add_sge;\r\nioc->add_chain = &mpt_add_chain;\r\nioc->sg_addr_size = 4;\r\n}\r\nioc->SGE_size = sizeof(u32) + ioc->sg_addr_size;\r\nprintk(MYIOC_s_INFO_FMT "pci-resume: ioc-state=0x%x,doorbell=0x%x\n",\r\nioc->name, (mpt_GetIocState(ioc, 1) >> MPI_IOC_STATE_SHIFT),\r\nCHIPREG_READ32(&ioc->chip->Doorbell));\r\nif (ioc->bus_type == SAS && (pdev->device ==\r\nMPI_MANUFACTPAGE_DEVID_SAS1068E || pdev->device ==\r\nMPI_MANUFACTPAGE_DEVID_SAS1064E)) {\r\nif (KickStart(ioc, 1, CAN_SLEEP) < 0) {\r\nprintk(MYIOC_s_WARN_FMT "pci-resume: Cannot recover\n",\r\nioc->name);\r\ngoto out;\r\n}\r\n}\r\nprintk(MYIOC_s_INFO_FMT "Sending mpt_do_ioc_recovery\n", ioc->name);\r\nrecovery_state = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_BRINGUP,\r\nCAN_SLEEP);\r\nif (recovery_state != 0)\r\nprintk(MYIOC_s_WARN_FMT "pci-resume: Cannot recover, "\r\n"error:[%x]\n", ioc->name, recovery_state);\r\nelse\r\nprintk(MYIOC_s_INFO_FMT\r\n"pci-resume: success\n", ioc->name);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\nmpt_signal_reset(u8 index, MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nif ((MptDriverClass[index] == MPTSPI_DRIVER &&\r\nioc->bus_type != SPI) ||\r\n(MptDriverClass[index] == MPTFC_DRIVER &&\r\nioc->bus_type != FC) ||\r\n(MptDriverClass[index] == MPTSAS_DRIVER &&\r\nioc->bus_type != SAS))\r\nreturn 0;\r\nreturn (MptResetHandlers[index])(ioc, reset_phase);\r\n}\r\nstatic int\r\nmpt_do_ioc_recovery(MPT_ADAPTER *ioc, u32 reason, int sleepFlag)\r\n{\r\nint hard_reset_done = 0;\r\nint alt_ioc_ready = 0;\r\nint hard;\r\nint rc=0;\r\nint ii;\r\nint ret = 0;\r\nint reset_alt_ioc_active = 0;\r\nint irq_allocated = 0;\r\nu8 *a;\r\nprintk(MYIOC_s_INFO_FMT "Initiating %s\n", ioc->name,\r\nreason == MPT_HOSTEVENT_IOC_BRINGUP ? "bringup" : "recovery");\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\r\nioc->active = 0;\r\nif (ioc->alt_ioc) {\r\nif (ioc->alt_ioc->active ||\r\nreason == MPT_HOSTEVENT_IOC_RECOVER) {\r\nreset_alt_ioc_active = 1;\r\nCHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,\r\n0xFFFFFFFF);\r\nioc->alt_ioc->active = 0;\r\n}\r\n}\r\nhard = 1;\r\nif (reason == MPT_HOSTEVENT_IOC_BRINGUP)\r\nhard = 0;\r\nif ((hard_reset_done = MakeIocReady(ioc, hard, sleepFlag)) < 0) {\r\nif (hard_reset_done == -4) {\r\nprintk(MYIOC_s_WARN_FMT "Owned by PEER..skipping!\n",\r\nioc->name);\r\nif (reset_alt_ioc_active && ioc->alt_ioc) {\r\ndprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n"alt_ioc reply irq re-enabled\n", ioc->alt_ioc->name));\r\nCHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);\r\nioc->alt_ioc->active = 1;\r\n}\r\n} else {\r\nprintk(MYIOC_s_WARN_FMT\r\n"NOT READY WARNING!\n", ioc->name);\r\n}\r\nret = -1;\r\ngoto out;\r\n}\r\nif (hard_reset_done && reset_alt_ioc_active && ioc->alt_ioc) {\r\nif ((rc = MakeIocReady(ioc->alt_ioc, 0, sleepFlag)) == 0)\r\nalt_ioc_ready = 1;\r\nelse\r\nprintk(MYIOC_s_WARN_FMT\r\n": alt-ioc Not ready WARNING!\n",\r\nioc->alt_ioc->name);\r\n}\r\nfor (ii=0; ii<5; ii++) {\r\nif ((rc = GetIocFacts(ioc, sleepFlag, reason)) == 0)\r\nbreak;\r\n}\r\nif (ii == 5) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Retry IocFacts failed rc=%x\n", ioc->name, rc));\r\nret = -2;\r\n} else if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\r\nMptDisplayIocCapabilities(ioc);\r\n}\r\nif (alt_ioc_ready) {\r\nif ((rc = GetIocFacts(ioc->alt_ioc, sleepFlag, reason)) != 0) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Initial Alt IocFacts failed rc=%x\n",\r\nioc->name, rc));\r\nrc = GetIocFacts(ioc->alt_ioc, sleepFlag, reason);\r\n}\r\nif (rc) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Retry Alt IocFacts failed rc=%x\n", ioc->name, rc));\r\nalt_ioc_ready = 0;\r\nreset_alt_ioc_active = 0;\r\n} else if (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\r\nMptDisplayIocCapabilities(ioc->alt_ioc);\r\n}\r\n}\r\nif ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP) &&\r\n(ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)) {\r\npci_release_selected_regions(ioc->pcidev, ioc->bars);\r\nioc->bars = pci_select_bars(ioc->pcidev, IORESOURCE_MEM |\r\nIORESOURCE_IO);\r\nif (pci_enable_device(ioc->pcidev))\r\nreturn -5;\r\nif (pci_request_selected_regions(ioc->pcidev, ioc->bars,\r\n"mpt"))\r\nreturn -5;\r\n}\r\nif ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP)) {\r\nioc->pci_irq = -1;\r\nif (ioc->pcidev->irq) {\r\nif (ioc->msi_enable && !pci_enable_msi(ioc->pcidev))\r\nprintk(MYIOC_s_INFO_FMT "PCI-MSI enabled\n",\r\nioc->name);\r\nelse\r\nioc->msi_enable = 0;\r\nrc = request_irq(ioc->pcidev->irq, mpt_interrupt,\r\nIRQF_SHARED, ioc->name, ioc);\r\nif (rc < 0) {\r\nprintk(MYIOC_s_ERR_FMT "Unable to allocate "\r\n"interrupt %d!\n",\r\nioc->name, ioc->pcidev->irq);\r\nif (ioc->msi_enable)\r\npci_disable_msi(ioc->pcidev);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nirq_allocated = 1;\r\nioc->pci_irq = ioc->pcidev->irq;\r\npci_set_master(ioc->pcidev);\r\npci_set_drvdata(ioc->pcidev, ioc);\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n"installed at interrupt %d\n", ioc->name,\r\nioc->pcidev->irq));\r\n}\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT "PrimeIocFifos\n",\r\nioc->name));\r\nif ((ret == 0) && ((rc = PrimeIocFifos(ioc)) != 0))\r\nret = -3;\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT "SendIocInit\n",\r\nioc->name));\r\nif ((ret == 0) && ((rc = SendIocInit(ioc, sleepFlag)) != 0))\r\nret = -4;\r\nif (alt_ioc_ready && ((rc = PrimeIocFifos(ioc->alt_ioc)) != 0)) {\r\nprintk(MYIOC_s_WARN_FMT\r\n": alt-ioc (%d) FIFO mgmt alloc WARNING!\n",\r\nioc->alt_ioc->name, rc);\r\nalt_ioc_ready = 0;\r\nreset_alt_ioc_active = 0;\r\n}\r\nif (alt_ioc_ready) {\r\nif ((rc = SendIocInit(ioc->alt_ioc, sleepFlag)) != 0) {\r\nalt_ioc_ready = 0;\r\nreset_alt_ioc_active = 0;\r\nprintk(MYIOC_s_WARN_FMT\r\n": alt-ioc: (%d) init failure WARNING!\n",\r\nioc->alt_ioc->name, rc);\r\n}\r\n}\r\nif (reason == MPT_HOSTEVENT_IOC_BRINGUP){\r\nif (ioc->upload_fw) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"firmware upload required!\n", ioc->name));\r\nif (ret == 0) {\r\nrc = mpt_do_upload(ioc, sleepFlag);\r\nif (rc == 0) {\r\nif (ioc->alt_ioc && ioc->alt_ioc->cached_fw) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"mpt_upload: alt_%s has cached_fw=%p \n",\r\nioc->name, ioc->alt_ioc->name, ioc->alt_ioc->cached_fw));\r\nioc->cached_fw = NULL;\r\n}\r\n} else {\r\nprintk(MYIOC_s_WARN_FMT\r\n"firmware upload failure!\n", ioc->name);\r\nret = -6;\r\n}\r\n}\r\n}\r\n}\r\nif ((ret == 0) && (!ioc->facts.EventState)) {\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n"SendEventNotification\n",\r\nioc->name));\r\nret = SendEventNotification(ioc, 1, sleepFlag);\r\n}\r\nif (ioc->alt_ioc && alt_ioc_ready && !ioc->alt_ioc->facts.EventState)\r\nrc = SendEventNotification(ioc->alt_ioc, 1, sleepFlag);\r\nif (ret == 0) {\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);\r\nioc->active = 1;\r\n}\r\nif (rc == 0) {\r\nif (reset_alt_ioc_active && ioc->alt_ioc) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "alt-ioc"\r\n"reply irq re-enabled\n",\r\nioc->alt_ioc->name));\r\nCHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,\r\nMPI_HIM_DIM);\r\nioc->alt_ioc->active = 1;\r\n}\r\n}\r\nif ((ret == 0) && (reason == MPT_HOSTEVENT_IOC_BRINGUP)) {\r\nmutex_init(&ioc->raid_data.inactive_list_mutex);\r\nINIT_LIST_HEAD(&ioc->raid_data.inactive_list);\r\nswitch (ioc->bus_type) {\r\ncase SAS:\r\nif(ioc->facts.IOCExceptions &\r\nMPI_IOCFACTS_EXCEPT_PERSISTENT_TABLE_FULL) {\r\nret = mptbase_sas_persist_operation(ioc,\r\nMPI_SAS_OP_CLEAR_NOT_PRESENT);\r\nif(ret != 0)\r\ngoto out;\r\n}\r\nmpt_findImVolumes(ioc);\r\nmpt_read_ioc_pg_1(ioc);\r\nbreak;\r\ncase FC:\r\nif ((ioc->pfacts[0].ProtocolFlags &\r\nMPI_PORTFACTS_PROTOCOL_LAN) &&\r\n(ioc->lan_cnfg_page0.Header.PageLength == 0)) {\r\n(void) GetLanConfigPages(ioc);\r\na = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"LanAddr = %02X:%02X:%02X"\r\n":%02X:%02X:%02X\n",\r\nioc->name, a[5], a[4],\r\na[3], a[2], a[1], a[0]));\r\n}\r\nbreak;\r\ncase SPI:\r\nmpt_GetScsiPortSettings(ioc, 0);\r\nmpt_readScsiDevicePageHeaders(ioc, 0);\r\nif (ioc->facts.MsgVersion >= MPI_VERSION_01_02)\r\nmpt_findImVolumes(ioc);\r\nmpt_read_ioc_pg_1(ioc);\r\nmpt_read_ioc_pg_4(ioc);\r\nbreak;\r\n}\r\nGetIoUnitPage2(ioc);\r\nmpt_get_manufacturing_pg_0(ioc);\r\n}\r\nout:\r\nif ((ret != 0) && irq_allocated) {\r\nfree_irq(ioc->pci_irq, ioc);\r\nif (ioc->msi_enable)\r\npci_disable_msi(ioc->pcidev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nmpt_detect_bound_ports(MPT_ADAPTER *ioc, struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *peer=NULL;\r\nunsigned int slot = PCI_SLOT(pdev->devfn);\r\nunsigned int func = PCI_FUNC(pdev->devfn);\r\nMPT_ADAPTER *ioc_srch;\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "PCI device %s devfn=%x/%x,"\r\n" searching for devfn match on %x or %x\n",\r\nioc->name, pci_name(pdev), pdev->bus->number,\r\npdev->devfn, func-1, func+1));\r\npeer = pci_get_slot(pdev->bus, PCI_DEVFN(slot,func-1));\r\nif (!peer) {\r\npeer = pci_get_slot(pdev->bus, PCI_DEVFN(slot,func+1));\r\nif (!peer)\r\nreturn;\r\n}\r\nlist_for_each_entry(ioc_srch, &ioc_list, list) {\r\nstruct pci_dev *_pcidev = ioc_srch->pcidev;\r\nif (_pcidev == peer) {\r\nif (ioc->alt_ioc != NULL) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Oops, already bound (%s <==> %s)!\n",\r\nioc->name, ioc->name, ioc->alt_ioc->name);\r\nbreak;\r\n} else if (ioc_srch->alt_ioc != NULL) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Oops, already bound (%s <==> %s)!\n",\r\nioc_srch->name, ioc_srch->name,\r\nioc_srch->alt_ioc->name);\r\nbreak;\r\n}\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"FOUND! binding %s <==> %s\n",\r\nioc->name, ioc->name, ioc_srch->name));\r\nioc_srch->alt_ioc = ioc;\r\nioc->alt_ioc = ioc_srch;\r\n}\r\n}\r\npci_dev_put(peer);\r\n}\r\nstatic void\r\nmpt_adapter_disable(MPT_ADAPTER *ioc)\r\n{\r\nint sz;\r\nint ret;\r\nif (ioc->cached_fw != NULL) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: Pushing FW onto adapter\n", __func__, ioc->name));\r\nif ((ret = mpt_downloadboot(ioc, (MpiFwHeader_t *)\r\nioc->cached_fw, CAN_SLEEP)) < 0) {\r\nprintk(MYIOC_s_WARN_FMT\r\n": firmware downloadboot failure (%d)!\n",\r\nioc->name, ret);\r\n}\r\n}\r\nif (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_READY) {\r\nif (!SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET,\r\nCAN_SLEEP)) {\r\nif (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_READY)\r\nprintk(MYIOC_s_ERR_FMT "%s: IOC msg unit "\r\n"reset failed to put ioc in ready state!\n",\r\nioc->name, __func__);\r\n} else\r\nprintk(MYIOC_s_ERR_FMT "%s: IOC msg unit reset "\r\n"failed!\n", ioc->name, __func__);\r\n}\r\nsynchronize_irq(ioc->pcidev->irq);\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\r\nioc->active = 0;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nCHIPREG_READ32(&ioc->chip->IntStatus);\r\nif (ioc->alloc != NULL) {\r\nsz = ioc->alloc_sz;\r\ndexitprintk(ioc, printk(MYIOC_s_INFO_FMT "free @ %p, sz=%d bytes\n",\r\nioc->name, ioc->alloc, ioc->alloc_sz));\r\npci_free_consistent(ioc->pcidev, sz,\r\nioc->alloc, ioc->alloc_dma);\r\nioc->reply_frames = NULL;\r\nioc->req_frames = NULL;\r\nioc->alloc = NULL;\r\nioc->alloc_total -= sz;\r\n}\r\nif (ioc->sense_buf_pool != NULL) {\r\nsz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);\r\npci_free_consistent(ioc->pcidev, sz,\r\nioc->sense_buf_pool, ioc->sense_buf_pool_dma);\r\nioc->sense_buf_pool = NULL;\r\nioc->alloc_total -= sz;\r\n}\r\nif (ioc->events != NULL){\r\nsz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\r\nkfree(ioc->events);\r\nioc->events = NULL;\r\nioc->alloc_total -= sz;\r\n}\r\nmpt_free_fw_memory(ioc);\r\nkfree(ioc->spi_data.nvram);\r\nmpt_inactive_raid_list_free(ioc);\r\nkfree(ioc->raid_data.pIocPg2);\r\nkfree(ioc->raid_data.pIocPg3);\r\nioc->spi_data.nvram = NULL;\r\nioc->raid_data.pIocPg3 = NULL;\r\nif (ioc->spi_data.pIocPg4 != NULL) {\r\nsz = ioc->spi_data.IocPg4Sz;\r\npci_free_consistent(ioc->pcidev, sz,\r\nioc->spi_data.pIocPg4,\r\nioc->spi_data.IocPg4_dma);\r\nioc->spi_data.pIocPg4 = NULL;\r\nioc->alloc_total -= sz;\r\n}\r\nif (ioc->ReqToChain != NULL) {\r\nkfree(ioc->ReqToChain);\r\nkfree(ioc->RequestNB);\r\nioc->ReqToChain = NULL;\r\n}\r\nkfree(ioc->ChainToChain);\r\nioc->ChainToChain = NULL;\r\nif (ioc->HostPageBuffer != NULL) {\r\nif((ret = mpt_host_page_access_control(ioc,\r\nMPI_DB_HPBAC_FREE_BUFFER, NO_SLEEP)) != 0) {\r\nprintk(MYIOC_s_ERR_FMT\r\n": %s: host page buffers free failed (%d)!\n",\r\nioc->name, __func__, ret);\r\n}\r\ndexitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"HostPageBuffer free @ %p, sz=%d bytes\n",\r\nioc->name, ioc->HostPageBuffer,\r\nioc->HostPageBuffer_sz));\r\npci_free_consistent(ioc->pcidev, ioc->HostPageBuffer_sz,\r\nioc->HostPageBuffer, ioc->HostPageBuffer_dma);\r\nioc->HostPageBuffer = NULL;\r\nioc->HostPageBuffer_sz = 0;\r\nioc->alloc_total -= ioc->HostPageBuffer_sz;\r\n}\r\npci_set_drvdata(ioc->pcidev, NULL);\r\n}\r\nstatic void\r\nmpt_adapter_dispose(MPT_ADAPTER *ioc)\r\n{\r\nint sz_first, sz_last;\r\nif (ioc == NULL)\r\nreturn;\r\nsz_first = ioc->alloc_total;\r\nmpt_adapter_disable(ioc);\r\nif (ioc->pci_irq != -1) {\r\nfree_irq(ioc->pci_irq, ioc);\r\nif (ioc->msi_enable)\r\npci_disable_msi(ioc->pcidev);\r\nioc->pci_irq = -1;\r\n}\r\nif (ioc->memmap != NULL) {\r\niounmap(ioc->memmap);\r\nioc->memmap = NULL;\r\n}\r\npci_disable_device(ioc->pcidev);\r\npci_release_selected_regions(ioc->pcidev, ioc->bars);\r\n#if defined(CONFIG_MTRR) && 0\r\nif (ioc->mtrr_reg > 0) {\r\nmtrr_del(ioc->mtrr_reg, 0, 0);\r\ndprintk(ioc, printk(MYIOC_s_INFO_FMT "MTRR region de-registered\n", ioc->name));\r\n}\r\n#endif\r\nlist_del(&ioc->list);\r\nsz_last = ioc->alloc_total;\r\ndprintk(ioc, printk(MYIOC_s_INFO_FMT "free'd %d of %d bytes\n",\r\nioc->name, sz_first-sz_last+(int)sizeof(*ioc), sz_first));\r\nif (ioc->alt_ioc)\r\nioc->alt_ioc->alt_ioc = NULL;\r\nkfree(ioc);\r\n}\r\nstatic void\r\nMptDisplayIocCapabilities(MPT_ADAPTER *ioc)\r\n{\r\nint i = 0;\r\nprintk(KERN_INFO "%s: ", ioc->name);\r\nif (ioc->prod_name)\r\nprintk("%s: ", ioc->prod_name);\r\nprintk("Capabilities={");\r\nif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_INITIATOR) {\r\nprintk("Initiator");\r\ni++;\r\n}\r\nif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET) {\r\nprintk("%sTarget", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {\r\nprintk("%sLAN", i ? "," : "");\r\ni++;\r\n}\r\n#if 0\r\nif (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET) {\r\nprintk("%sLogBusAddr", i ? "," : "");\r\ni++;\r\n}\r\n#endif\r\nprintk("}\n");\r\n}\r\nstatic int\r\nMakeIocReady(MPT_ADAPTER *ioc, int force, int sleepFlag)\r\n{\r\nu32 ioc_state;\r\nint statefault = 0;\r\nint cntdn;\r\nint hard_reset_done = 0;\r\nint r;\r\nint ii;\r\nint whoinit;\r\nioc_state = mpt_GetIocState(ioc, 0);\r\ndhsprintk(ioc, printk(MYIOC_s_INFO_FMT "MakeIocReady [raw] state=%08x\n", ioc->name, ioc_state));\r\nif (ioc_state & MPI_DOORBELL_ACTIVE) {\r\nstatefault = 1;\r\nprintk(MYIOC_s_WARN_FMT "Unexpected doorbell active!\n",\r\nioc->name);\r\n}\r\nif (!statefault &&\r\n((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_READY)) {\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n"IOC is in READY state\n", ioc->name));\r\nreturn 0;\r\n}\r\nif ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {\r\nstatefault = 2;\r\nprintk(MYIOC_s_WARN_FMT "IOC is in FAULT state!!!\n",\r\nioc->name);\r\nprintk(MYIOC_s_WARN_FMT " FAULT code = %04xh\n",\r\nioc->name, ioc_state & MPI_DOORBELL_DATA_MASK);\r\n}\r\nif ((ioc_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_OPERATIONAL) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "IOC operational unexpected\n",\r\nioc->name));\r\nwhoinit = (ioc_state & MPI_DOORBELL_WHO_INIT_MASK) >> MPI_DOORBELL_WHO_INIT_SHIFT;\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT\r\n"whoinit 0x%x statefault %d force %d\n",\r\nioc->name, whoinit, statefault, force));\r\nif (whoinit == MPI_WHOINIT_PCI_PEER)\r\nreturn -4;\r\nelse {\r\nif ((statefault == 0 ) && (force == 0)) {\r\nif ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) == 0)\r\nreturn 0;\r\n}\r\nstatefault = 3;\r\n}\r\n}\r\nhard_reset_done = KickStart(ioc, statefault||force, sleepFlag);\r\nif (hard_reset_done < 0)\r\nreturn -1;\r\nii = 0;\r\ncntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 5;\r\nwhile ((ioc_state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {\r\nif (ioc_state == MPI_IOC_STATE_OPERATIONAL) {\r\nif ((r = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag)) != 0) {\r\nprintk(MYIOC_s_ERR_FMT "IOC msg unit reset failed!\n", ioc->name);\r\nreturn -2;\r\n}\r\n} else if (ioc_state == MPI_IOC_STATE_RESET) {\r\nif ((r = SendIocReset(ioc, MPI_FUNCTION_IO_UNIT_RESET, sleepFlag)) != 0) {\r\nprintk(MYIOC_s_ERR_FMT "IO unit reset failed!\n", ioc->name);\r\nreturn -3;\r\n}\r\n}\r\nii++; cntdn--;\r\nif (!cntdn) {\r\nprintk(MYIOC_s_ERR_FMT\r\n"Wait IOC_READY state (0x%x) timeout(%d)!\n",\r\nioc->name, ioc_state, (int)((ii+5)/HZ));\r\nreturn -ETIME;\r\n}\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep(1);\r\n} else {\r\nmdelay (1);\r\n}\r\n}\r\nif (statefault < 3) {\r\nprintk(MYIOC_s_INFO_FMT "Recovered from %s\n", ioc->name,\r\nstatefault == 1 ? "stuck handshake" : "IOC FAULT");\r\n}\r\nreturn hard_reset_done;\r\n}\r\nu32\r\nmpt_GetIocState(MPT_ADAPTER *ioc, int cooked)\r\n{\r\nu32 s, sc;\r\ns = CHIPREG_READ32(&ioc->chip->Doorbell);\r\nsc = s & MPI_IOC_STATE_MASK;\r\nioc->last_state = sc;\r\nreturn cooked ? sc : s;\r\n}\r\nstatic int\r\nGetIocFacts(MPT_ADAPTER *ioc, int sleepFlag, int reason)\r\n{\r\nIOCFacts_t get_facts;\r\nIOCFactsReply_t *facts;\r\nint r;\r\nint req_sz;\r\nint reply_sz;\r\nint sz;\r\nu32 status, vv;\r\nu8 shiftFactor=1;\r\nif (ioc->last_state == MPI_IOC_STATE_RESET) {\r\nprintk(KERN_ERR MYNAM\r\n": ERROR - Can't get IOCFacts, %s NOT READY! (%08x)\n",\r\nioc->name, ioc->last_state);\r\nreturn -44;\r\n}\r\nfacts = &ioc->facts;\r\nreply_sz = sizeof(*facts);\r\nmemset(facts, 0, reply_sz);\r\nreq_sz = sizeof(get_facts);\r\nmemset(&get_facts, 0, req_sz);\r\nget_facts.Function = MPI_FUNCTION_IOC_FACTS;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Sending get IocFacts request req_sz=%d reply_sz=%d\n",\r\nioc->name, req_sz, reply_sz));\r\nr = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_facts,\r\nreply_sz, (u16*)facts, 5 , sleepFlag);\r\nif (r != 0)\r\nreturn r;\r\nif (facts->MsgLength > offsetof(IOCFactsReply_t, RequestFrameSize)/sizeof(u32)) {\r\nif (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\r\nif (ioc->FirstWhoInit == WHOINIT_UNKNOWN)\r\nioc->FirstWhoInit = facts->WhoInit;\r\n}\r\nfacts->MsgVersion = le16_to_cpu(facts->MsgVersion);\r\nfacts->MsgContext = le32_to_cpu(facts->MsgContext);\r\nfacts->IOCExceptions = le16_to_cpu(facts->IOCExceptions);\r\nfacts->IOCStatus = le16_to_cpu(facts->IOCStatus);\r\nfacts->IOCLogInfo = le32_to_cpu(facts->IOCLogInfo);\r\nstatus = le16_to_cpu(facts->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nfacts->ReplyQueueDepth = le16_to_cpu(facts->ReplyQueueDepth);\r\nfacts->RequestFrameSize = le16_to_cpu(facts->RequestFrameSize);\r\nif (facts->MsgVersion < MPI_VERSION_01_02) {\r\nu16 oldv = le16_to_cpu(facts->Reserved_0101_FWVersion);\r\nfacts->FWVersion.Word =\r\n((oldv<<12) & 0xFF000000) |\r\n((oldv<<8) & 0x000FFF00);\r\n} else\r\nfacts->FWVersion.Word = le32_to_cpu(facts->FWVersion.Word);\r\nfacts->ProductID = le16_to_cpu(facts->ProductID);\r\nif ((ioc->facts.ProductID & MPI_FW_HEADER_PID_PROD_MASK)\r\n> MPI_FW_HEADER_PID_PROD_TARGET_SCSI)\r\nioc->ir_firmware = 1;\r\nfacts->CurrentHostMfaHighAddr =\r\nle32_to_cpu(facts->CurrentHostMfaHighAddr);\r\nfacts->GlobalCredits = le16_to_cpu(facts->GlobalCredits);\r\nfacts->CurrentSenseBufferHighAddr =\r\nle32_to_cpu(facts->CurrentSenseBufferHighAddr);\r\nfacts->CurReplyFrameSize =\r\nle16_to_cpu(facts->CurReplyFrameSize);\r\nfacts->IOCCapabilities = le32_to_cpu(facts->IOCCapabilities);\r\nif (facts->MsgLength >= (offsetof(IOCFactsReply_t,FWImageSize) + 7)/4 &&\r\nfacts->MsgVersion > MPI_VERSION_01_00) {\r\nfacts->FWImageSize = le32_to_cpu(facts->FWImageSize);\r\n}\r\nsz = facts->FWImageSize;\r\nif ( sz & 0x01 )\r\nsz += 1;\r\nif ( sz & 0x02 )\r\nsz += 2;\r\nfacts->FWImageSize = sz;\r\nif (!facts->RequestFrameSize) {\r\nprintk(MYIOC_s_ERR_FMT "IOC reported invalid 0 request size!\n",\r\nioc->name);\r\nreturn -55;\r\n}\r\nr = sz = facts->BlockSize;\r\nvv = ((63 / (sz * 4)) + 1) & 0x03;\r\nioc->NB_for_64_byte_frame = vv;\r\nwhile ( sz )\r\n{\r\nshiftFactor++;\r\nsz = sz >> 1;\r\n}\r\nioc->NBShiftFactor = shiftFactor;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"NB_for_64_byte_frame=%x NBShiftFactor=%x BlockSize=%x\n",\r\nioc->name, vv, shiftFactor, r));\r\nif (reason == MPT_HOSTEVENT_IOC_BRINGUP) {\r\nioc->req_sz = min(MPT_DEFAULT_FRAME_SIZE, facts->RequestFrameSize * 4);\r\nioc->req_depth = min_t(int, MPT_MAX_REQ_DEPTH, facts->GlobalCredits);\r\nioc->reply_sz = MPT_REPLY_FRAME_SIZE;\r\nioc->reply_depth = min_t(int, MPT_DEFAULT_REPLY_DEPTH, facts->ReplyQueueDepth);\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "reply_sz=%3d, reply_depth=%4d\n",\r\nioc->name, ioc->reply_sz, ioc->reply_depth));\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "req_sz =%3d, req_depth =%4d\n",\r\nioc->name, ioc->req_sz, ioc->req_depth));\r\nif ( (r = GetPortFacts(ioc, 0, sleepFlag)) != 0 )\r\nreturn r;\r\n}\r\n} else {\r\nprintk(MYIOC_s_ERR_FMT\r\n"Invalid IOC facts reply, msgLength=%d offsetof=%zd!\n",\r\nioc->name, facts->MsgLength, (offsetof(IOCFactsReply_t,\r\nRequestFrameSize)/sizeof(u32)));\r\nreturn -66;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nGetPortFacts(MPT_ADAPTER *ioc, int portnum, int sleepFlag)\r\n{\r\nPortFacts_t get_pfacts;\r\nPortFactsReply_t *pfacts;\r\nint ii;\r\nint req_sz;\r\nint reply_sz;\r\nint max_id;\r\nif (ioc->last_state == MPI_IOC_STATE_RESET) {\r\nprintk(MYIOC_s_ERR_FMT "Can't get PortFacts NOT READY! (%08x)\n",\r\nioc->name, ioc->last_state );\r\nreturn -4;\r\n}\r\npfacts = &ioc->pfacts[portnum];\r\nreply_sz = sizeof(*pfacts);\r\nmemset(pfacts, 0, reply_sz);\r\nreq_sz = sizeof(get_pfacts);\r\nmemset(&get_pfacts, 0, req_sz);\r\nget_pfacts.Function = MPI_FUNCTION_PORT_FACTS;\r\nget_pfacts.PortNumber = portnum;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending get PortFacts(%d) request\n",\r\nioc->name, portnum));\r\nii = mpt_handshake_req_reply_wait(ioc, req_sz, (u32*)&get_pfacts,\r\nreply_sz, (u16*)pfacts, 5 , sleepFlag);\r\nif (ii != 0)\r\nreturn ii;\r\npfacts->MsgContext = le32_to_cpu(pfacts->MsgContext);\r\npfacts->IOCStatus = le16_to_cpu(pfacts->IOCStatus);\r\npfacts->IOCLogInfo = le32_to_cpu(pfacts->IOCLogInfo);\r\npfacts->MaxDevices = le16_to_cpu(pfacts->MaxDevices);\r\npfacts->PortSCSIID = le16_to_cpu(pfacts->PortSCSIID);\r\npfacts->ProtocolFlags = le16_to_cpu(pfacts->ProtocolFlags);\r\npfacts->MaxPostedCmdBuffers = le16_to_cpu(pfacts->MaxPostedCmdBuffers);\r\npfacts->MaxPersistentIDs = le16_to_cpu(pfacts->MaxPersistentIDs);\r\npfacts->MaxLanBuckets = le16_to_cpu(pfacts->MaxLanBuckets);\r\nmax_id = (ioc->bus_type == SAS) ? pfacts->PortSCSIID :\r\npfacts->MaxDevices;\r\nioc->devices_per_bus = (max_id > 255) ? 256 : max_id;\r\nioc->number_of_buses = (ioc->devices_per_bus < 256) ? 1 : max_id/256;\r\nif (mpt_channel_mapping) {\r\nioc->devices_per_bus = 1;\r\nioc->number_of_buses = (max_id > 255) ? 255 : max_id;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nSendIocInit(MPT_ADAPTER *ioc, int sleepFlag)\r\n{\r\nIOCInit_t ioc_init;\r\nMPIDefaultReply_t init_reply;\r\nu32 state;\r\nint r;\r\nint count;\r\nint cntdn;\r\nmemset(&ioc_init, 0, sizeof(ioc_init));\r\nmemset(&init_reply, 0, sizeof(init_reply));\r\nioc_init.WhoInit = MPI_WHOINIT_HOST_DRIVER;\r\nioc_init.Function = MPI_FUNCTION_IOC_INIT;\r\nif (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)\r\nioc->upload_fw = 1;\r\nelse\r\nioc->upload_fw = 0;\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "upload_fw %d facts.Flags=%x\n",\r\nioc->name, ioc->upload_fw, ioc->facts.Flags));\r\nioc_init.MaxDevices = (U8)ioc->devices_per_bus;\r\nioc_init.MaxBuses = (U8)ioc->number_of_buses;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "facts.MsgVersion=%x\n",\r\nioc->name, ioc->facts.MsgVersion));\r\nif (ioc->facts.MsgVersion >= MPI_VERSION_01_05) {\r\nioc_init.MsgVersion = cpu_to_le16(MPI_VERSION);\r\nioc_init.HeaderVersion = cpu_to_le16(MPI_HEADER_VERSION);\r\nif (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_HOST_PAGE_BUFFER_PERSISTENT) {\r\nioc_init.HostPageBufferSGE = ioc->facts.HostPageBufferSGE;\r\n} else if(mpt_host_page_alloc(ioc, &ioc_init))\r\nreturn -99;\r\n}\r\nioc_init.ReplyFrameSize = cpu_to_le16(ioc->reply_sz);\r\nif (ioc->sg_addr_size == sizeof(u64)) {\r\nioc_init.HostMfaHighAddr = cpu_to_le32((u32)((u64)ioc->alloc_dma >> 32));\r\nioc_init.SenseBufferHighAddr = cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));\r\n} else {\r\nioc_init.HostMfaHighAddr = cpu_to_le32(0);\r\nioc_init.SenseBufferHighAddr = cpu_to_le32(0);\r\n}\r\nioc->facts.CurrentHostMfaHighAddr = ioc_init.HostMfaHighAddr;\r\nioc->facts.CurrentSenseBufferHighAddr = ioc_init.SenseBufferHighAddr;\r\nioc->facts.MaxDevices = ioc_init.MaxDevices;\r\nioc->facts.MaxBuses = ioc_init.MaxBuses;\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending IOCInit (req @ %p)\n",\r\nioc->name, &ioc_init));\r\nr = mpt_handshake_req_reply_wait(ioc, sizeof(IOCInit_t), (u32*)&ioc_init,\r\nsizeof(MPIDefaultReply_t), (u16*)&init_reply, 10 , sleepFlag);\r\nif (r != 0) {\r\nprintk(MYIOC_s_ERR_FMT "Sending IOCInit failed(%d)!\n",ioc->name, r);\r\nreturn r;\r\n}\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending PortEnable (req @ %p)\n",\r\nioc->name, &ioc_init));\r\nif ((r = SendPortEnable(ioc, 0, sleepFlag)) != 0) {\r\nprintk(MYIOC_s_ERR_FMT "Sending PortEnable failed(%d)!\n",ioc->name, r);\r\nreturn r;\r\n}\r\ncount = 0;\r\ncntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 60;\r\nstate = mpt_GetIocState(ioc, 1);\r\nwhile (state != MPI_IOC_STATE_OPERATIONAL && --cntdn) {\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep(1);\r\n} else {\r\nmdelay(1);\r\n}\r\nif (!cntdn) {\r\nprintk(MYIOC_s_ERR_FMT "Wait IOC_OP state timeout(%d)!\n",\r\nioc->name, (int)((count+5)/HZ));\r\nreturn -9;\r\n}\r\nstate = mpt_GetIocState(ioc, 1);\r\ncount++;\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Wait IOC_OPERATIONAL state (cnt=%d)\n",\r\nioc->name, count));\r\nioc->aen_event_read_flag=0;\r\nreturn r;\r\n}\r\nstatic int\r\nSendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag)\r\n{\r\nPortEnable_t port_enable;\r\nMPIDefaultReply_t reply_buf;\r\nint rc;\r\nint req_sz;\r\nint reply_sz;\r\nreply_sz = sizeof(MPIDefaultReply_t);\r\nmemset(&reply_buf, 0, reply_sz);\r\nreq_sz = sizeof(PortEnable_t);\r\nmemset(&port_enable, 0, req_sz);\r\nport_enable.Function = MPI_FUNCTION_PORT_ENABLE;\r\nport_enable.PortNumber = portnum;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending Port(%d)Enable (req @ %p)\n",\r\nioc->name, portnum, &port_enable));\r\nif (ioc->ir_firmware || ioc->bus_type == SAS) {\r\nrc = mpt_handshake_req_reply_wait(ioc, req_sz,\r\n(u32*)&port_enable, reply_sz, (u16*)&reply_buf,\r\n300 , sleepFlag);\r\n} else {\r\nrc = mpt_handshake_req_reply_wait(ioc, req_sz,\r\n(u32*)&port_enable, reply_sz, (u16*)&reply_buf,\r\n30 , sleepFlag);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nmpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size)\r\n{\r\nint rc;\r\nif (ioc->cached_fw) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nelse if (ioc->alt_ioc && ioc->alt_ioc->cached_fw) {\r\nioc->cached_fw = ioc->alt_ioc->cached_fw;\r\nioc->cached_fw_dma = ioc->alt_ioc->cached_fw_dma;\r\nrc = 0;\r\ngoto out;\r\n}\r\nioc->cached_fw = pci_alloc_consistent(ioc->pcidev, size, &ioc->cached_fw_dma);\r\nif (!ioc->cached_fw) {\r\nprintk(MYIOC_s_ERR_FMT "Unable to allocate memory for the cached firmware image!\n",\r\nioc->name);\r\nrc = -1;\r\n} else {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "FW Image @ %p[%p], sz=%d[%x] bytes\n",\r\nioc->name, ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, size, size));\r\nioc->alloc_total += size;\r\nrc = 0;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nvoid\r\nmpt_free_fw_memory(MPT_ADAPTER *ioc)\r\n{\r\nint sz;\r\nif (!ioc->cached_fw)\r\nreturn;\r\nsz = ioc->facts.FWImageSize;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "free_fw_memory: FW Image @ %p[%p], sz=%d[%x] bytes\n",\r\nioc->name, ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, sz, sz));\r\npci_free_consistent(ioc->pcidev, sz, ioc->cached_fw, ioc->cached_fw_dma);\r\nioc->alloc_total -= sz;\r\nioc->cached_fw = NULL;\r\n}\r\nstatic int\r\nmpt_do_upload(MPT_ADAPTER *ioc, int sleepFlag)\r\n{\r\nu8 reply[sizeof(FWUploadReply_t)];\r\nFWUpload_t *prequest;\r\nFWUploadReply_t *preply;\r\nFWUploadTCSGE_t *ptcsge;\r\nu32 flagsLength;\r\nint ii, sz, reply_sz;\r\nint cmdStatus;\r\nint request_size;\r\nif ((sz = ioc->facts.FWImageSize) == 0)\r\nreturn 0;\r\nif (mpt_alloc_fw_memory(ioc, ioc->facts.FWImageSize) != 0)\r\nreturn -ENOMEM;\r\ndinitprintk(ioc, printk(MYIOC_s_INFO_FMT ": FW Image @ %p[%p], sz=%d[%x] bytes\n",\r\nioc->name, ioc->cached_fw, (void *)(ulong)ioc->cached_fw_dma, sz, sz));\r\nprequest = (sleepFlag == NO_SLEEP) ? kzalloc(ioc->req_sz, GFP_ATOMIC) :\r\nkzalloc(ioc->req_sz, GFP_KERNEL);\r\nif (!prequest) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "fw upload failed "\r\n"while allocating memory \n", ioc->name));\r\nmpt_free_fw_memory(ioc);\r\nreturn -ENOMEM;\r\n}\r\npreply = (FWUploadReply_t *)&reply;\r\nreply_sz = sizeof(reply);\r\nmemset(preply, 0, reply_sz);\r\nprequest->ImageType = MPI_FW_UPLOAD_ITYPE_FW_IOC_MEM;\r\nprequest->Function = MPI_FUNCTION_FW_UPLOAD;\r\nptcsge = (FWUploadTCSGE_t *) &prequest->SGL;\r\nptcsge->DetailsLength = 12;\r\nptcsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;\r\nptcsge->ImageSize = cpu_to_le32(sz);\r\nptcsge++;\r\nflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ | sz;\r\nioc->add_sge((char *)ptcsge, flagsLength, ioc->cached_fw_dma);\r\nrequest_size = offsetof(FWUpload_t, SGL) + sizeof(FWUploadTCSGE_t) +\r\nioc->SGE_size;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending FW Upload "\r\n" (req @ %p) fw_size=%d mf_request_size=%d\n", ioc->name, prequest,\r\nioc->facts.FWImageSize, request_size));\r\nDBG_DUMP_FW_REQUEST_FRAME(ioc, (u32 *)prequest);\r\nii = mpt_handshake_req_reply_wait(ioc, request_size, (u32 *)prequest,\r\nreply_sz, (u16 *)preply, 65 , sleepFlag);\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "FW Upload completed "\r\n"rc=%x \n", ioc->name, ii));\r\ncmdStatus = -EFAULT;\r\nif (ii == 0) {\r\nint status;\r\nstatus = le16_to_cpu(preply->IOCStatus) &\r\nMPI_IOCSTATUS_MASK;\r\nif (status == MPI_IOCSTATUS_SUCCESS &&\r\nioc->facts.FWImageSize ==\r\nle32_to_cpu(preply->ActualImageSize))\r\ncmdStatus = 0;\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": do_upload cmdStatus=%d \n",\r\nioc->name, cmdStatus));\r\nif (cmdStatus) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "fw upload failed, "\r\n"freeing image \n", ioc->name));\r\nmpt_free_fw_memory(ioc);\r\n}\r\nkfree(prequest);\r\nreturn cmdStatus;\r\n}\r\nstatic int\r\nmpt_downloadboot(MPT_ADAPTER *ioc, MpiFwHeader_t *pFwHeader, int sleepFlag)\r\n{\r\nMpiExtImageHeader_t *pExtImage;\r\nu32 fwSize;\r\nu32 diag0val;\r\nint count;\r\nu32 *ptrFw;\r\nu32 diagRwData;\r\nu32 nextImage;\r\nu32 load_addr;\r\nu32 ioc_state=0;\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "downloadboot: fw size 0x%x (%d), FW Ptr %p\n",\r\nioc->name, pFwHeader->ImageSize, pFwHeader->ImageSize, pFwHeader));\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM));\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep(1);\r\n} else {\r\nmdelay (1);\r\n}\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);\r\nfor (count = 0; count < 30; count ++) {\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nif (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RESET_ADAPTER cleared, count=%d\n",\r\nioc->name, count));\r\nbreak;\r\n}\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (100);\r\n} else {\r\nmdelay (100);\r\n}\r\n}\r\nif ( count == 30 ) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "downloadboot failed! "\r\n"Unable to get MPI_DIAG_DRWE mode, diag0val=%x\n",\r\nioc->name, diag0val));\r\nreturn -3;\r\n}\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM));\r\nfwSize = (pFwHeader->ImageSize + 3)/4;\r\nptrFw = (u32 *) pFwHeader;\r\nif (ioc->errata_flag_1064)\r\npci_enable_io_access(ioc->pcidev);\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->LoadStartAddress);\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "LoadStart addr written 0x%x \n",\r\nioc->name, pFwHeader->LoadStartAddress));\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Write FW Image: 0x%x bytes @ %p\n",\r\nioc->name, fwSize*4, ptrFw));\r\nwhile (fwSize--) {\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);\r\n}\r\nnextImage = pFwHeader->NextImageHeaderOffset;\r\nwhile (nextImage) {\r\npExtImage = (MpiExtImageHeader_t *) ((char *)pFwHeader + nextImage);\r\nload_addr = pExtImage->LoadStartAddress;\r\nfwSize = (pExtImage->ImageSize + 3) >> 2;\r\nptrFw = (u32 *)pExtImage;\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Write Ext Image: 0x%x (%d) bytes @ %p load_addr=%x\n",\r\nioc->name, fwSize*4, fwSize*4, ptrFw, load_addr));\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);\r\nwhile (fwSize--) {\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);\r\n}\r\nnextImage = pExtImage->NextImageHeaderOffset;\r\n}\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Write IopResetVector Addr=%x! \n", ioc->name, pFwHeader->IopResetRegAddr));\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->IopResetRegAddr);\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Write IopResetVector Value=%x! \n", ioc->name, pFwHeader->IopResetVectorValue));\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, pFwHeader->IopResetVectorValue);\r\nif (ioc->bus_type == SPI) {\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);\r\ndiagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);\r\ndiagRwData |= 0x40000000;\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);\r\nCHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);\r\n} else {\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val |\r\nMPI_DIAG_CLEAR_FLASH_BAD_SIG);\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (1);\r\n} else {\r\nmdelay (1);\r\n}\r\n}\r\nif (ioc->errata_flag_1064)\r\npci_disable_io_access(ioc->pcidev);\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "downloadboot diag0val=%x, "\r\n"turning off PREVENT_IOC_BOOT, DISABLE_ARM, RW_ENABLE\n",\r\nioc->name, diag0val));\r\ndiag0val &= ~(MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM | MPI_DIAG_RW_ENABLE);\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "downloadboot now diag0val=%x\n",\r\nioc->name, diag0val));\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\r\nif (ioc->bus_type == SAS) {\r\nioc_state = mpt_GetIocState(ioc, 0);\r\nif ( (GetIocFacts(ioc, sleepFlag,\r\nMPT_HOSTEVENT_IOC_BRINGUP)) != 0 ) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "GetIocFacts failed: IocState=%x\n",\r\nioc->name, ioc_state));\r\nreturn -EFAULT;\r\n}\r\n}\r\nfor (count=0; count<HZ*20; count++) {\r\nif ((ioc_state = mpt_GetIocState(ioc, 0)) & MPI_IOC_STATE_READY) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"downloadboot successful! (count=%d) IocState=%x\n",\r\nioc->name, count, ioc_state));\r\nif (ioc->bus_type == SAS) {\r\nreturn 0;\r\n}\r\nif ((SendIocInit(ioc, sleepFlag)) != 0) {\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"downloadboot: SendIocInit failed\n",\r\nioc->name));\r\nreturn -EFAULT;\r\n}\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"downloadboot: SendIocInit successful\n",\r\nioc->name));\r\nreturn 0;\r\n}\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (10);\r\n} else {\r\nmdelay (10);\r\n}\r\n}\r\nddlprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"downloadboot failed! IocState=%x\n",ioc->name, ioc_state));\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\nKickStart(MPT_ADAPTER *ioc, int force, int sleepFlag)\r\n{\r\nint hard_reset_done = 0;\r\nu32 ioc_state=0;\r\nint cnt,cntdn;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "KickStarting!\n", ioc->name));\r\nif (ioc->bus_type == SPI) {\r\nSendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag);\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (1000);\r\n} else {\r\nmdelay (1000);\r\n}\r\n}\r\nhard_reset_done = mpt_diag_reset(ioc, force, sleepFlag);\r\nif (hard_reset_done < 0)\r\nreturn hard_reset_done;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Diagnostic reset successful!\n",\r\nioc->name));\r\ncntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 2;\r\nfor (cnt=0; cnt<cntdn; cnt++) {\r\nioc_state = mpt_GetIocState(ioc, 1);\r\nif ((ioc_state == MPI_IOC_STATE_READY) || (ioc_state == MPI_IOC_STATE_OPERATIONAL)) {\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "KickStart successful! (cnt=%d)\n",\r\nioc->name, cnt));\r\nreturn hard_reset_done;\r\n}\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (10);\r\n} else {\r\nmdelay (10);\r\n}\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_ERR_FMT "Failed to come READY after reset! IocState=%x\n",\r\nioc->name, mpt_GetIocState(ioc, 0)));\r\nreturn -1;\r\n}\r\nstatic int\r\nmpt_diag_reset(MPT_ADAPTER *ioc, int ignore, int sleepFlag)\r\n{\r\nu32 diag0val;\r\nu32 doorbell;\r\nint hard_reset_done = 0;\r\nint count = 0;\r\nu32 diag1val = 0;\r\nMpiFwHeader_t *cached_fw;\r\nu8 cb_idx;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nif (ioc->pcidev->device == MPI_MANUFACTPAGE_DEVID_SAS1078) {\r\nif (!ignore)\r\nreturn 0;\r\ndrsprintk(ioc, printk(MYIOC_s_WARN_FMT "%s: Doorbell=%p; 1078 reset "\r\n"address=%p\n", ioc->name, __func__,\r\n&ioc->chip->Doorbell, &ioc->chip->Reset_1078));\r\nCHIPREG_WRITE32(&ioc->chip->Reset_1078, 0x07);\r\nif (sleepFlag == CAN_SLEEP)\r\nmsleep(1);\r\nelse\r\nmdelay(1);\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx])\r\n(*(MptResetHandlers[cb_idx]))(ioc,\r\nMPT_IOC_PRE_RESET);\r\n}\r\nfor (count = 0; count < 60; count ++) {\r\ndoorbell = CHIPREG_READ32(&ioc->chip->Doorbell);\r\ndoorbell &= MPI_IOC_STATE_MASK;\r\ndrsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"looking for READY STATE: doorbell=%x"\r\n" count=%d\n",\r\nioc->name, doorbell, count));\r\nif (doorbell == MPI_IOC_STATE_READY) {\r\nreturn 1;\r\n}\r\nif (sleepFlag == CAN_SLEEP)\r\nmsleep(1000);\r\nelse\r\nmdelay(1000);\r\n}\r\nreturn -1;\r\n}\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nif (ioc->debug_level & MPT_DEBUG) {\r\nif (ioc->alt_ioc)\r\ndiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG1: diag0=%08x, diag1=%08x\n",\r\nioc->name, diag0val, diag1val));\r\n}\r\nif (ignore || !(diag0val & MPI_DIAG_RESET_HISTORY)) {\r\nwhile ((diag0val & MPI_DIAG_DRWE) == 0) {\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (100);\r\n} else {\r\nmdelay (100);\r\n}\r\ncount++;\r\nif (count > 20) {\r\nprintk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",\r\nioc->name, diag0val);\r\nreturn -2;\r\n}\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Wrote magic DiagWriteEn sequence (%x)\n",\r\nioc->name, diag0val));\r\n}\r\nif (ioc->debug_level & MPT_DEBUG) {\r\nif (ioc->alt_ioc)\r\ndiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG2: diag0=%08x, diag1=%08x\n",\r\nioc->name, diag0val, diag1val));\r\n}\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);\r\nmdelay(1);\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);\r\nhard_reset_done = 1;\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Diagnostic reset performed\n",\r\nioc->name));\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx]) {\r\nmpt_signal_reset(cb_idx,\r\nioc, MPT_IOC_PRE_RESET);\r\nif (ioc->alt_ioc) {\r\nmpt_signal_reset(cb_idx,\r\nioc->alt_ioc, MPT_IOC_PRE_RESET);\r\n}\r\n}\r\n}\r\nif (ioc->cached_fw)\r\ncached_fw = (MpiFwHeader_t *)ioc->cached_fw;\r\nelse if (ioc->alt_ioc && ioc->alt_ioc->cached_fw)\r\ncached_fw = (MpiFwHeader_t *)ioc->alt_ioc->cached_fw;\r\nelse\r\ncached_fw = NULL;\r\nif (cached_fw) {\r\nfor (count = 0; count < 30; count ++) {\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nif (!(diag0val & MPI_DIAG_RESET_ADAPTER)) {\r\nbreak;\r\n}\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "cached_fw: diag0val=%x count=%d\n",\r\nioc->name, diag0val, count));\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (1000);\r\n} else {\r\nmdelay (1000);\r\n}\r\n}\r\nif ((count = mpt_downloadboot(ioc, cached_fw, sleepFlag)) < 0) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"firmware downloadboot failure (%d)!\n", ioc->name, count);\r\n}\r\n} else {\r\nfor (count = 0; count < 60; count ++) {\r\ndoorbell = CHIPREG_READ32(&ioc->chip->Doorbell);\r\ndoorbell &= MPI_IOC_STATE_MASK;\r\ndrsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"looking for READY STATE: doorbell=%x"\r\n" count=%d\n", ioc->name, doorbell, count));\r\nif (doorbell == MPI_IOC_STATE_READY) {\r\nbreak;\r\n}\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (1000);\r\n} else {\r\nmdelay (1000);\r\n}\r\n}\r\nif (doorbell != MPI_IOC_STATE_READY)\r\nprintk(MYIOC_s_ERR_FMT "Failed to come READY "\r\n"after reset! IocState=%x", ioc->name,\r\ndoorbell);\r\n}\r\n}\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nif (ioc->debug_level & MPT_DEBUG) {\r\nif (ioc->alt_ioc)\r\ndiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG3: diag0=%08x, diag1=%08x\n",\r\nioc->name, diag0val, diag1val));\r\n}\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\ncount = 0;\r\nwhile ((diag0val & MPI_DIAG_DRWE) == 0) {\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep (100);\r\n} else {\r\nmdelay (100);\r\n}\r\ncount++;\r\nif (count > 20) {\r\nprintk(MYIOC_s_ERR_FMT "Enable Diagnostic mode FAILED! (%02xh)\n",\r\nioc->name, diag0val);\r\nbreak;\r\n}\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\n}\r\ndiag0val &= ~MPI_DIAG_RESET_HISTORY;\r\nCHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nif (diag0val & MPI_DIAG_RESET_HISTORY) {\r\nprintk(MYIOC_s_WARN_FMT "ResetHistory bit failed to clear!\n",\r\nioc->name);\r\n}\r\nCHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFFFFFFFF);\r\ndiag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);\r\nif (diag0val & (MPI_DIAG_FLASH_BAD_SIG | MPI_DIAG_RESET_ADAPTER | MPI_DIAG_DISABLE_ARM)) {\r\nprintk(MYIOC_s_ERR_FMT "Diagnostic reset FAILED! (%02xh)\n",\r\nioc->name, diag0val);\r\nreturn -3;\r\n}\r\nif (ioc->debug_level & MPT_DEBUG) {\r\nif (ioc->alt_ioc)\r\ndiag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DbG4: diag0=%08x, diag1=%08x\n",\r\nioc->name, diag0val, diag1val));\r\n}\r\nioc->facts.EventState = 0;\r\nif (ioc->alt_ioc)\r\nioc->alt_ioc->facts.EventState = 0;\r\nreturn hard_reset_done;\r\n}\r\nstatic int\r\nSendIocReset(MPT_ADAPTER *ioc, u8 reset_type, int sleepFlag)\r\n{\r\nint r;\r\nu32 state;\r\nint cntdn, count;\r\ndrsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending IOC reset(0x%02x)!\n",\r\nioc->name, reset_type));\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);\r\nif ((r = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)\r\nreturn r;\r\ncount = 0;\r\ncntdn = ((sleepFlag == CAN_SLEEP) ? HZ : 1000) * 15;\r\nwhile ((state = mpt_GetIocState(ioc, 1)) != MPI_IOC_STATE_READY) {\r\ncntdn--;\r\ncount++;\r\nif (!cntdn) {\r\nif (sleepFlag != CAN_SLEEP)\r\ncount *= 10;\r\nprintk(MYIOC_s_ERR_FMT\r\n"Wait IOC_READY state (0x%x) timeout(%d)!\n",\r\nioc->name, state, (int)((count+5)/HZ));\r\nreturn -ETIME;\r\n}\r\nif (sleepFlag == CAN_SLEEP) {\r\nmsleep(1);\r\n} else {\r\nmdelay (1);\r\n}\r\n}\r\nif (ioc->facts.Function)\r\nioc->facts.EventState = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ninitChainBuffers(MPT_ADAPTER *ioc)\r\n{\r\nu8 *mem;\r\nint sz, ii, num_chain;\r\nint scale, num_sge, numSGE;\r\nif (ioc->ReqToChain == NULL) {\r\nsz = ioc->req_depth * sizeof(int);\r\nmem = kmalloc(sz, GFP_ATOMIC);\r\nif (mem == NULL)\r\nreturn -1;\r\nioc->ReqToChain = (int *) mem;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReqToChain alloc @ %p, sz=%d bytes\n",\r\nioc->name, mem, sz));\r\nmem = kmalloc(sz, GFP_ATOMIC);\r\nif (mem == NULL)\r\nreturn -1;\r\nioc->RequestNB = (int *) mem;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RequestNB alloc @ %p, sz=%d bytes\n",\r\nioc->name, mem, sz));\r\n}\r\nfor (ii = 0; ii < ioc->req_depth; ii++) {\r\nioc->ReqToChain[ii] = MPT_HOST_NO_CHAIN;\r\n}\r\nscale = ioc->req_sz / ioc->SGE_size;\r\nif (ioc->sg_addr_size == sizeof(u64))\r\nnum_sge = scale + (ioc->req_sz - 60) / ioc->SGE_size;\r\nelse\r\nnum_sge = 1 + scale + (ioc->req_sz - 64) / ioc->SGE_size;\r\nif (ioc->sg_addr_size == sizeof(u64)) {\r\nnumSGE = (scale - 1) * (ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 60) / ioc->SGE_size;\r\n} else {\r\nnumSGE = 1 + (scale - 1) * (ioc->facts.MaxChainDepth-1) +\r\nscale + (ioc->req_sz - 64) / ioc->SGE_size;\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "num_sge=%d numSGE=%d\n",\r\nioc->name, num_sge, numSGE));\r\nif (ioc->bus_type == FC) {\r\nif (numSGE > MPT_SCSI_FC_SG_DEPTH)\r\nnumSGE = MPT_SCSI_FC_SG_DEPTH;\r\n} else {\r\nif (numSGE > MPT_SCSI_SG_DEPTH)\r\nnumSGE = MPT_SCSI_SG_DEPTH;\r\n}\r\nnum_chain = 1;\r\nwhile (numSGE - num_sge > 0) {\r\nnum_chain++;\r\nnum_sge += (scale - 1);\r\n}\r\nnum_chain++;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Now numSGE=%d num_sge=%d num_chain=%d\n",\r\nioc->name, numSGE, num_sge, num_chain));\r\nif (ioc->bus_type == SPI)\r\nnum_chain *= MPT_SCSI_CAN_QUEUE;\r\nelse if (ioc->bus_type == SAS)\r\nnum_chain *= MPT_SAS_CAN_QUEUE;\r\nelse\r\nnum_chain *= MPT_FC_CAN_QUEUE;\r\nioc->num_chain = num_chain;\r\nsz = num_chain * sizeof(int);\r\nif (ioc->ChainToChain == NULL) {\r\nmem = kmalloc(sz, GFP_ATOMIC);\r\nif (mem == NULL)\r\nreturn -1;\r\nioc->ChainToChain = (int *) mem;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ChainToChain alloc @ %p, sz=%d bytes\n",\r\nioc->name, mem, sz));\r\n} else {\r\nmem = (u8 *) ioc->ChainToChain;\r\n}\r\nmemset(mem, 0xFF, sz);\r\nreturn num_chain;\r\n}\r\nstatic int\r\nPrimeIocFifos(MPT_ADAPTER *ioc)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nunsigned long flags;\r\ndma_addr_t alloc_dma;\r\nu8 *mem;\r\nint i, reply_sz, sz, total_size, num_chain;\r\nu64 dma_mask;\r\ndma_mask = 0;\r\nif (ioc->reply_frames == NULL) {\r\nif ( (num_chain = initChainBuffers(ioc)) < 0)\r\nreturn -1;\r\nif (ioc->pcidev->device == MPI_MANUFACTPAGE_DEVID_SAS1078 &&\r\nioc->dma_mask > DMA_BIT_MASK(35)) {\r\nif (!pci_set_dma_mask(ioc->pcidev, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(ioc->pcidev,\r\nDMA_BIT_MASK(32))) {\r\ndma_mask = DMA_BIT_MASK(35);\r\nd36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"setting 35 bit addressing for "\r\n"Request/Reply/Chain and Sense Buffers\n",\r\nioc->name));\r\n} else {\r\npci_set_dma_mask(ioc->pcidev,\r\nDMA_BIT_MASK(64));\r\npci_set_consistent_dma_mask(ioc->pcidev,\r\nDMA_BIT_MASK(64));\r\nprintk(MYIOC_s_ERR_FMT\r\n"failed setting 35 bit addressing for "\r\n"Request/Reply/Chain and Sense Buffers\n",\r\nioc->name);\r\nreturn -1;\r\n}\r\n}\r\ntotal_size = reply_sz = (ioc->reply_sz * ioc->reply_depth);\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReplyBuffer sz=%d bytes, ReplyDepth=%d\n",\r\nioc->name, ioc->reply_sz, ioc->reply_depth));\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReplyBuffer sz=%d[%x] bytes\n",\r\nioc->name, reply_sz, reply_sz));\r\nsz = (ioc->req_sz * ioc->req_depth);\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RequestBuffer sz=%d bytes, RequestDepth=%d\n",\r\nioc->name, ioc->req_sz, ioc->req_depth));\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RequestBuffer sz=%d[%x] bytes\n",\r\nioc->name, sz, sz));\r\ntotal_size += sz;\r\nsz = num_chain * ioc->req_sz;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ChainBuffer sz=%d bytes, ChainDepth=%d\n",\r\nioc->name, ioc->req_sz, num_chain));\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ChainBuffer sz=%d[%x] bytes num_chain=%d\n",\r\nioc->name, sz, sz, num_chain));\r\ntotal_size += sz;\r\nmem = pci_alloc_consistent(ioc->pcidev, total_size, &alloc_dma);\r\nif (mem == NULL) {\r\nprintk(MYIOC_s_ERR_FMT "Unable to allocate Reply, Request, Chain Buffers!\n",\r\nioc->name);\r\ngoto out_fail;\r\n}\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Total alloc @ %p[%p], sz=%d[%x] bytes\n",\r\nioc->name, mem, (void *)(ulong)alloc_dma, total_size, total_size));\r\nmemset(mem, 0, total_size);\r\nioc->alloc_total += total_size;\r\nioc->alloc = mem;\r\nioc->alloc_dma = alloc_dma;\r\nioc->alloc_sz = total_size;\r\nioc->reply_frames = (MPT_FRAME_HDR *) mem;\r\nioc->reply_frames_low_dma = (u32) (alloc_dma & 0xFFFFFFFF);\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReplyBuffers @ %p[%p]\n",\r\nioc->name, ioc->reply_frames, (void *)(ulong)alloc_dma));\r\nalloc_dma += reply_sz;\r\nmem += reply_sz;\r\nioc->req_frames = (MPT_FRAME_HDR *) mem;\r\nioc->req_frames_dma = alloc_dma;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "RequestBuffers @ %p[%p]\n",\r\nioc->name, mem, (void *)(ulong)alloc_dma));\r\nioc->req_frames_low_dma = (u32) (alloc_dma & 0xFFFFFFFF);\r\n#if defined(CONFIG_MTRR) && 0\r\nioc->mtrr_reg = mtrr_add(ioc->req_frames_dma,\r\nsz,\r\nMTRR_TYPE_WRCOMB, 1);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "MTRR region registered (base:size=%08x:%x)\n",\r\nioc->name, ioc->req_frames_dma, sz));\r\n#endif\r\nfor (i = 0; i < ioc->req_depth; i++) {\r\nalloc_dma += ioc->req_sz;\r\nmem += ioc->req_sz;\r\n}\r\nioc->ChainBuffer = mem;\r\nioc->ChainBufferDMA = alloc_dma;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ChainBuffers @ %p(%p)\n",\r\nioc->name, ioc->ChainBuffer, (void *)(ulong)ioc->ChainBufferDMA));\r\nINIT_LIST_HEAD(&ioc->FreeChainQ);\r\nmem = (u8 *)ioc->ChainBuffer;\r\nfor (i=0; i < num_chain; i++) {\r\nmf = (MPT_FRAME_HDR *) mem;\r\nlist_add_tail(&mf->u.frame.linkage.list, &ioc->FreeChainQ);\r\nmem += ioc->req_sz;\r\n}\r\nalloc_dma = ioc->req_frames_dma;\r\nmem = (u8 *) ioc->req_frames;\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nINIT_LIST_HEAD(&ioc->FreeQ);\r\nfor (i = 0; i < ioc->req_depth; i++) {\r\nmf = (MPT_FRAME_HDR *) mem;\r\nlist_add_tail(&mf->u.frame.linkage.list, &ioc->FreeQ);\r\nmem += ioc->req_sz;\r\n}\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\nsz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);\r\nioc->sense_buf_pool =\r\npci_alloc_consistent(ioc->pcidev, sz, &ioc->sense_buf_pool_dma);\r\nif (ioc->sense_buf_pool == NULL) {\r\nprintk(MYIOC_s_ERR_FMT "Unable to allocate Sense Buffers!\n",\r\nioc->name);\r\ngoto out_fail;\r\n}\r\nioc->sense_buf_low_dma = (u32) (ioc->sense_buf_pool_dma & 0xFFFFFFFF);\r\nioc->alloc_total += sz;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SenseBuffers @ %p[%p]\n",\r\nioc->name, ioc->sense_buf_pool, (void *)(ulong)ioc->sense_buf_pool_dma));\r\n}\r\nalloc_dma = ioc->alloc_dma;\r\ndinitprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ReplyBuffers @ %p[%p]\n",\r\nioc->name, ioc->reply_frames, (void *)(ulong)alloc_dma));\r\nfor (i = 0; i < ioc->reply_depth; i++) {\r\nCHIPREG_WRITE32(&ioc->chip->ReplyFifo, alloc_dma);\r\nalloc_dma += ioc->reply_sz;\r\n}\r\nif (dma_mask == DMA_BIT_MASK(35) && !pci_set_dma_mask(ioc->pcidev,\r\nioc->dma_mask) && !pci_set_consistent_dma_mask(ioc->pcidev,\r\nioc->dma_mask))\r\nd36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"restoring 64 bit addressing\n", ioc->name));\r\nreturn 0;\r\nout_fail:\r\nif (ioc->alloc != NULL) {\r\nsz = ioc->alloc_sz;\r\npci_free_consistent(ioc->pcidev,\r\nsz,\r\nioc->alloc, ioc->alloc_dma);\r\nioc->reply_frames = NULL;\r\nioc->req_frames = NULL;\r\nioc->alloc_total -= sz;\r\n}\r\nif (ioc->sense_buf_pool != NULL) {\r\nsz = (ioc->req_depth * MPT_SENSE_BUFFER_ALLOC);\r\npci_free_consistent(ioc->pcidev,\r\nsz,\r\nioc->sense_buf_pool, ioc->sense_buf_pool_dma);\r\nioc->sense_buf_pool = NULL;\r\n}\r\nif (dma_mask == DMA_BIT_MASK(35) && !pci_set_dma_mask(ioc->pcidev,\r\nDMA_BIT_MASK(64)) && !pci_set_consistent_dma_mask(ioc->pcidev,\r\nDMA_BIT_MASK(64)))\r\nd36memprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"restoring 64 bit addressing\n", ioc->name));\r\nreturn -1;\r\n}\r\nstatic int\r\nmpt_handshake_req_reply_wait(MPT_ADAPTER *ioc, int reqBytes, u32 *req,\r\nint replyBytes, u16 *u16reply, int maxwait, int sleepFlag)\r\n{\r\nMPIDefaultReply_t *mptReply;\r\nint failcnt = 0;\r\nint t;\r\nioc->hs_reply_idx = 0;\r\nmptReply = (MPIDefaultReply_t *) ioc->hs_reply;\r\nmptReply->MsgLength = 0;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell,\r\n((MPI_FUNCTION_HANDSHAKE<<MPI_DOORBELL_FUNCTION_SHIFT) |\r\n((reqBytes/4)<<MPI_DOORBELL_ADD_DWORDS_SHIFT)));\r\nif ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\r\nfailcnt++;\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HandShake request start reqBytes=%d, WaitCnt=%d%s\n",\r\nioc->name, reqBytes, t, failcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));\r\nif (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))\r\nreturn -1;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nif (!failcnt && (t = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)\r\nfailcnt++;\r\nif (!failcnt) {\r\nint ii;\r\nu8 *req_as_bytes = (u8 *) req;\r\nfor (ii = 0; !failcnt && ii < reqBytes/4; ii++) {\r\nu32 word = ((req_as_bytes[(ii*4) + 0] << 0) |\r\n(req_as_bytes[(ii*4) + 1] << 8) |\r\n(req_as_bytes[(ii*4) + 2] << 16) |\r\n(req_as_bytes[(ii*4) + 3] << 24));\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell, word);\r\nif ((t = WaitForDoorbellAck(ioc, 5, sleepFlag)) < 0)\r\nfailcnt++;\r\n}\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Handshake request frame (@%p) header\n", ioc->name, req));\r\nDBG_DUMP_REQUEST_FRAME_HDR(ioc, (u32 *)req);\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HandShake request post done, WaitCnt=%d%s\n",\r\nioc->name, t, failcnt ? " - MISSING DOORBELL ACK!" : ""));\r\nif (!failcnt && (t = WaitForDoorbellReply(ioc, maxwait, sleepFlag)) < 0)\r\nfailcnt++;\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HandShake reply count=%d%s\n",\r\nioc->name, t, failcnt ? " - MISSING DOORBELL REPLY!" : ""));\r\nfor (ii=0; ii < min(replyBytes/2,mptReply->MsgLength*2); ii++)\r\nu16reply[ii] = ioc->hs_reply[ii];\r\n} else {\r\nreturn -99;\r\n}\r\nreturn -failcnt;\r\n}\r\nstatic int\r\nWaitForDoorbellAck(MPT_ADAPTER *ioc, int howlong, int sleepFlag)\r\n{\r\nint cntdn;\r\nint count = 0;\r\nu32 intstat=0;\r\ncntdn = 1000 * howlong;\r\nif (sleepFlag == CAN_SLEEP) {\r\nwhile (--cntdn) {\r\nmsleep (1);\r\nintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\r\nif (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))\r\nbreak;\r\ncount++;\r\n}\r\n} else {\r\nwhile (--cntdn) {\r\nudelay (1000);\r\nintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\r\nif (! (intstat & MPI_HIS_IOP_DOORBELL_STATUS))\r\nbreak;\r\ncount++;\r\n}\r\n}\r\nif (cntdn) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "WaitForDoorbell ACK (count=%d)\n",\r\nioc->name, count));\r\nreturn count;\r\n}\r\nprintk(MYIOC_s_ERR_FMT "Doorbell ACK timeout (count=%d), IntStatus=%x!\n",\r\nioc->name, count, intstat);\r\nreturn -1;\r\n}\r\nstatic int\r\nWaitForDoorbellInt(MPT_ADAPTER *ioc, int howlong, int sleepFlag)\r\n{\r\nint cntdn;\r\nint count = 0;\r\nu32 intstat=0;\r\ncntdn = 1000 * howlong;\r\nif (sleepFlag == CAN_SLEEP) {\r\nwhile (--cntdn) {\r\nintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\r\nif (intstat & MPI_HIS_DOORBELL_INTERRUPT)\r\nbreak;\r\nmsleep(1);\r\ncount++;\r\n}\r\n} else {\r\nwhile (--cntdn) {\r\nintstat = CHIPREG_READ32(&ioc->chip->IntStatus);\r\nif (intstat & MPI_HIS_DOORBELL_INTERRUPT)\r\nbreak;\r\nudelay (1000);\r\ncount++;\r\n}\r\n}\r\nif (cntdn) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "WaitForDoorbell INT (cnt=%d) howlong=%d\n",\r\nioc->name, count, howlong));\r\nreturn count;\r\n}\r\nprintk(MYIOC_s_ERR_FMT "Doorbell INT timeout (count=%d), IntStatus=%x!\n",\r\nioc->name, count, intstat);\r\nreturn -1;\r\n}\r\nstatic int\r\nWaitForDoorbellReply(MPT_ADAPTER *ioc, int howlong, int sleepFlag)\r\n{\r\nint u16cnt = 0;\r\nint failcnt = 0;\r\nint t;\r\nu16 *hs_reply = ioc->hs_reply;\r\nvolatile MPIDefaultReply_t *mptReply = (MPIDefaultReply_t *) ioc->hs_reply;\r\nu16 hword;\r\nhs_reply[0] = hs_reply[1] = hs_reply[7] = 0;\r\nu16cnt=0;\r\nif ((t = WaitForDoorbellInt(ioc, howlong, sleepFlag)) < 0) {\r\nfailcnt++;\r\n} else {\r\nhs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nif ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\r\nfailcnt++;\r\nelse {\r\nhs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\n}\r\n}\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "WaitCnt=%d First handshake reply word=%08x%s\n",\r\nioc->name, t, le32_to_cpu(*(u32 *)hs_reply),\r\nfailcnt ? " - MISSING DOORBELL HANDSHAKE!" : ""));\r\nfor (u16cnt=2; !failcnt && u16cnt < (2 * mptReply->MsgLength); u16cnt++) {\r\nif ((t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\r\nfailcnt++;\r\nhword = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);\r\nif (u16cnt < ARRAY_SIZE(ioc->hs_reply))\r\nhs_reply[u16cnt] = hword;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\n}\r\nif (!failcnt && (t = WaitForDoorbellInt(ioc, 5, sleepFlag)) < 0)\r\nfailcnt++;\r\nCHIPREG_WRITE32(&ioc->chip->IntStatus, 0);\r\nif (failcnt) {\r\nprintk(MYIOC_s_ERR_FMT "Handshake reply failure!\n",\r\nioc->name);\r\nreturn -failcnt;\r\n}\r\n#if 0\r\nelse if (u16cnt != (2 * mptReply->MsgLength)) {\r\nreturn -101;\r\n}\r\nelse if ((mptReply->IOCStatus & MPI_IOCSTATUS_MASK) != MPI_IOCSTATUS_SUCCESS) {\r\nreturn -102;\r\n}\r\n#endif\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Got Handshake reply:\n", ioc->name));\r\nDBG_DUMP_REPLY_FRAME(ioc, (u32 *)mptReply);\r\ndhsprintk(ioc, printk(MYIOC_s_DEBUG_FMT "WaitForDoorbell REPLY WaitCnt=%d (sz=%d)\n",\r\nioc->name, t, u16cnt/2));\r\nreturn u16cnt/2;\r\n}\r\nstatic int\r\nGetLanConfigPages(MPT_ADAPTER *ioc)\r\n{\r\nConfigPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nLANPage0_t *ppage0_alloc;\r\ndma_addr_t page0_dma;\r\nLANPage1_t *ppage1_alloc;\r\ndma_addr_t page1_dma;\r\nint rc = 0;\r\nint data_sz;\r\nint copy_sz;\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_LAN;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = 0;\r\ncfg.timeout = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nreturn rc;\r\nif (hdr.PageLength > 0) {\r\ndata_sz = hdr.PageLength * 4;\r\nppage0_alloc = (LANPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);\r\nrc = -ENOMEM;\r\nif (ppage0_alloc) {\r\nmemset((u8 *)ppage0_alloc, 0, data_sz);\r\ncfg.physAddr = page0_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\ncopy_sz = min_t(int, sizeof(LANPage0_t), data_sz);\r\nmemcpy(&ioc->lan_cnfg_page0, ppage0_alloc, copy_sz);\r\n}\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);\r\n}\r\nif (rc)\r\nreturn rc;\r\n}\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 1;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_LAN;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nreturn rc;\r\nif (hdr.PageLength == 0)\r\nreturn 0;\r\ndata_sz = hdr.PageLength * 4;\r\nrc = -ENOMEM;\r\nppage1_alloc = (LANPage1_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page1_dma);\r\nif (ppage1_alloc) {\r\nmemset((u8 *)ppage1_alloc, 0, data_sz);\r\ncfg.physAddr = page1_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\ncopy_sz = min_t(int, sizeof(LANPage1_t), data_sz);\r\nmemcpy(&ioc->lan_cnfg_page1, ppage1_alloc, copy_sz);\r\n}\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage1_alloc, page1_dma);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nmptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode)\r\n{\r\nSasIoUnitControlRequest_t *sasIoUnitCntrReq;\r\nSasIoUnitControlReply_t *sasIoUnitCntrReply;\r\nMPT_FRAME_HDR *mf = NULL;\r\nMPIHeader_t *mpi_hdr;\r\nint ret = 0;\r\nunsigned long timeleft;\r\nmutex_lock(&ioc->mptbase_cmds.mutex);\r\nmemset(ioc->mptbase_cmds.reply, 0 , MPT_DEFAULT_FRAME_SIZE);\r\nINITIALIZE_MGMT_STATUS(ioc->mptbase_cmds.status)\r\nswitch(persist_opcode) {\r\ncase MPI_SAS_OP_CLEAR_NOT_PRESENT:\r\ncase MPI_SAS_OP_CLEAR_ALL_PERSISTENT:\r\nbreak;\r\ndefault:\r\nret = -1;\r\ngoto out;\r\n}\r\nprintk(KERN_DEBUG "%s: persist_opcode=%x\n",\r\n__func__, persist_opcode);\r\nif ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {\r\nprintk(KERN_DEBUG "%s: no msg frames!\n", __func__);\r\nret = -1;\r\ngoto out;\r\n}\r\nmpi_hdr = (MPIHeader_t *) mf;\r\nsasIoUnitCntrReq = (SasIoUnitControlRequest_t *)mf;\r\nmemset(sasIoUnitCntrReq,0,sizeof(SasIoUnitControlRequest_t));\r\nsasIoUnitCntrReq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;\r\nsasIoUnitCntrReq->MsgContext = mpi_hdr->MsgContext;\r\nsasIoUnitCntrReq->Operation = persist_opcode;\r\nmpt_put_msg_frame(mpt_base_index, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done, 10*HZ);\r\nif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = -ETIME;\r\nprintk(KERN_DEBUG "%s: failed\n", __func__);\r\nif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out;\r\nif (!timeleft) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Issuing Reset from %s!!, doorbell=0x%08x\n",\r\nioc->name, __func__, mpt_GetIocState(ioc, 0));\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\nmpt_free_msg_frame(ioc, mf);\r\n}\r\ngoto out;\r\n}\r\nif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\r\nret = -1;\r\ngoto out;\r\n}\r\nsasIoUnitCntrReply =\r\n(SasIoUnitControlReply_t *)ioc->mptbase_cmds.reply;\r\nif (le16_to_cpu(sasIoUnitCntrReply->IOCStatus) != MPI_IOCSTATUS_SUCCESS) {\r\nprintk(KERN_DEBUG "%s: IOCStatus=0x%X IOCLogInfo=0x%X\n",\r\n__func__, sasIoUnitCntrReply->IOCStatus,\r\nsasIoUnitCntrReply->IOCLogInfo);\r\nprintk(KERN_DEBUG "%s: failed\n", __func__);\r\nret = -1;\r\n} else\r\nprintk(KERN_DEBUG "%s: success\n", __func__);\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->mptbase_cmds.status)\r\nmutex_unlock(&ioc->mptbase_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nmptbase_raid_process_event_data(MPT_ADAPTER *ioc,\r\nMpiEventDataRaid_t * pRaidEventData)\r\n{\r\nint volume;\r\nint reason;\r\nint disk;\r\nint status;\r\nint flags;\r\nint state;\r\nvolume = pRaidEventData->VolumeID;\r\nreason = pRaidEventData->ReasonCode;\r\ndisk = pRaidEventData->PhysDiskNum;\r\nstatus = le32_to_cpu(pRaidEventData->SettingsStatus);\r\nflags = (status >> 0) & 0xff;\r\nstate = (status >> 8) & 0xff;\r\nif (reason == MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED) {\r\nreturn;\r\n}\r\nif ((reason >= MPI_EVENT_RAID_RC_PHYSDISK_CREATED &&\r\nreason <= MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED) ||\r\n(reason == MPI_EVENT_RAID_RC_SMART_DATA)) {\r\nprintk(MYIOC_s_INFO_FMT "RAID STATUS CHANGE for PhysDisk %d id=%d\n",\r\nioc->name, disk, volume);\r\n} else {\r\nprintk(MYIOC_s_INFO_FMT "RAID STATUS CHANGE for VolumeID %d\n",\r\nioc->name, volume);\r\n}\r\nswitch(reason) {\r\ncase MPI_EVENT_RAID_RC_VOLUME_CREATED:\r\nprintk(MYIOC_s_INFO_FMT " volume has been created\n",\r\nioc->name);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_DELETED:\r\nprintk(MYIOC_s_INFO_FMT " volume has been deleted\n",\r\nioc->name);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED:\r\nprintk(MYIOC_s_INFO_FMT " volume settings have been changed\n",\r\nioc->name);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED:\r\nprintk(MYIOC_s_INFO_FMT " volume is now %s%s%s%s\n",\r\nioc->name,\r\nstate == MPI_RAIDVOL0_STATUS_STATE_OPTIMAL\r\n? "optimal"\r\n: state == MPI_RAIDVOL0_STATUS_STATE_DEGRADED\r\n? "degraded"\r\n: state == MPI_RAIDVOL0_STATUS_STATE_FAILED\r\n? "failed"\r\n: "state unknown",\r\nflags & MPI_RAIDVOL0_STATUS_FLAG_ENABLED\r\n? ", enabled" : "",\r\nflags & MPI_RAIDVOL0_STATUS_FLAG_QUIESCED\r\n? ", quiesced" : "",\r\nflags & MPI_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS\r\n? ", resync in progress" : "" );\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED:\r\nprintk(MYIOC_s_INFO_FMT " volume membership of PhysDisk %d has changed\n",\r\nioc->name, disk);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_CREATED:\r\nprintk(MYIOC_s_INFO_FMT " PhysDisk has been created\n",\r\nioc->name);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_DELETED:\r\nprintk(MYIOC_s_INFO_FMT " PhysDisk has been deleted\n",\r\nioc->name);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED:\r\nprintk(MYIOC_s_INFO_FMT " PhysDisk settings have been changed\n",\r\nioc->name);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED:\r\nprintk(MYIOC_s_INFO_FMT " PhysDisk is now %s%s%s\n",\r\nioc->name,\r\nstate == MPI_PHYSDISK0_STATUS_ONLINE\r\n? "online"\r\n: state == MPI_PHYSDISK0_STATUS_MISSING\r\n? "missing"\r\n: state == MPI_PHYSDISK0_STATUS_NOT_COMPATIBLE\r\n? "not compatible"\r\n: state == MPI_PHYSDISK0_STATUS_FAILED\r\n? "failed"\r\n: state == MPI_PHYSDISK0_STATUS_INITIALIZING\r\n? "initializing"\r\n: state == MPI_PHYSDISK0_STATUS_OFFLINE_REQUESTED\r\n? "offline requested"\r\n: state == MPI_PHYSDISK0_STATUS_FAILED_REQUESTED\r\n? "failed requested"\r\n: state == MPI_PHYSDISK0_STATUS_OTHER_OFFLINE\r\n? "offline"\r\n: "state unknown",\r\nflags & MPI_PHYSDISK0_STATUS_FLAG_OUT_OF_SYNC\r\n? ", out of sync" : "",\r\nflags & MPI_PHYSDISK0_STATUS_FLAG_QUIESCED\r\n? ", quiesced" : "" );\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED:\r\nprintk(MYIOC_s_INFO_FMT " Domain Validation needed for PhysDisk %d\n",\r\nioc->name, disk);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_SMART_DATA:\r\nprintk(MYIOC_s_INFO_FMT " SMART data received, ASC/ASCQ = %02xh/%02xh\n",\r\nioc->name, pRaidEventData->ASC, pRaidEventData->ASCQ);\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED:\r\nprintk(MYIOC_s_INFO_FMT " replacement of PhysDisk %d has started\n",\r\nioc->name, disk);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nGetIoUnitPage2(MPT_ADAPTER *ioc)\r\n{\r\nConfigPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nIOUnitPage2_t *ppage_alloc;\r\ndma_addr_t page_dma;\r\nint data_sz;\r\nint rc;\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 2;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_IO_UNIT;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = 0;\r\ncfg.timeout = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nreturn rc;\r\nif (hdr.PageLength == 0)\r\nreturn 0;\r\ndata_sz = hdr.PageLength * 4;\r\nrc = -ENOMEM;\r\nppage_alloc = (IOUnitPage2_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);\r\nif (ppage_alloc) {\r\nmemset((u8 *)ppage_alloc, 0, data_sz);\r\ncfg.physAddr = page_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0)\r\nioc->biosVersion = le32_to_cpu(ppage_alloc->BiosVersion);\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage_alloc, page_dma);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmpt_GetScsiPortSettings(MPT_ADAPTER *ioc, int portnum)\r\n{\r\nu8 *pbuf;\r\ndma_addr_t buf_dma;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t header;\r\nint ii;\r\nint data, rc = 0;\r\nif (!ioc->spi_data.nvram) {\r\nint sz;\r\nu8 *mem;\r\nsz = MPT_MAX_SCSI_DEVICES * sizeof(int);\r\nmem = kmalloc(sz, GFP_ATOMIC);\r\nif (mem == NULL)\r\nreturn -EFAULT;\r\nioc->spi_data.nvram = (int *) mem;\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SCSI device NVRAM settings @ %p, sz=%d\n",\r\nioc->name, ioc->spi_data.nvram, sz));\r\n}\r\nfor (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {\r\nioc->spi_data.nvram[ii] = MPT_HOST_NVRAM_INVALID;\r\n}\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 0;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = portnum;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn -EFAULT;\r\nif (header.PageLength > 0) {\r\npbuf = pci_alloc_consistent(ioc->pcidev, header.PageLength * 4, &buf_dma);\r\nif (pbuf) {\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.physAddr = buf_dma;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nioc->spi_data.maxBusWidth = MPT_NARROW;\r\nioc->spi_data.maxSyncOffset = 0;\r\nioc->spi_data.minSyncFactor = MPT_ASYNC;\r\nioc->spi_data.busType = MPT_HOST_BUS_UNKNOWN;\r\nrc = 1;\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Unable to read PortPage0 minSyncFactor=%x\n",\r\nioc->name, ioc->spi_data.minSyncFactor));\r\n} else {\r\nSCSIPortPage0_t *pPP0 = (SCSIPortPage0_t *) pbuf;\r\npPP0->Capabilities = le32_to_cpu(pPP0->Capabilities);\r\npPP0->PhysicalInterface = le32_to_cpu(pPP0->PhysicalInterface);\r\nif ( (pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_QAS) == 0 ) {\r\nioc->spi_data.noQas |= MPT_TARGET_NO_NEGO_QAS;\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"noQas due to Capabilities=%x\n",\r\nioc->name, pPP0->Capabilities));\r\n}\r\nioc->spi_data.maxBusWidth = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_WIDE ? 1 : 0;\r\ndata = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MAX_SYNC_OFFSET_MASK;\r\nif (data) {\r\nioc->spi_data.maxSyncOffset = (u8) (data >> 16);\r\ndata = pPP0->Capabilities & MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;\r\nioc->spi_data.minSyncFactor = (u8) (data >> 8);\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"PortPage0 minSyncFactor=%x\n",\r\nioc->name, ioc->spi_data.minSyncFactor));\r\n} else {\r\nioc->spi_data.maxSyncOffset = 0;\r\nioc->spi_data.minSyncFactor = MPT_ASYNC;\r\n}\r\nioc->spi_data.busType = pPP0->PhysicalInterface & MPI_SCSIPORTPAGE0_PHY_SIGNAL_TYPE_MASK;\r\nif ((ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_HVD) ||\r\n(ioc->spi_data.busType == MPI_SCSIPORTPAGE0_PHY_SIGNAL_SE)) {\r\nif (ioc->spi_data.minSyncFactor < MPT_ULTRA) {\r\nioc->spi_data.minSyncFactor = MPT_ULTRA;\r\nddvprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"HVD or SE detected, minSyncFactor=%x\n",\r\nioc->name, ioc->spi_data.minSyncFactor));\r\n}\r\n}\r\n}\r\nif (pbuf) {\r\npci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);\r\n}\r\n}\r\n}\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 2;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_SCSI_PORT;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = portnum;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn -EFAULT;\r\nif (header.PageLength > 0) {\r\npbuf = pci_alloc_consistent(ioc->pcidev, header.PageLength * 4, &buf_dma);\r\nif (pbuf) {\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_NVRAM;\r\ncfg.physAddr = buf_dma;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = 1;\r\n} else if (ioc->pcidev->vendor == PCI_VENDOR_ID_ATTO) {\r\nATTO_SCSIPortPage2_t *pPP2 = (ATTO_SCSIPortPage2_t *) pbuf;\r\nATTODeviceInfo_t *pdevice = NULL;\r\nu16 ATTOFlags;\r\nfor (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {\r\npdevice = &pPP2->DeviceSettings[ii];\r\nATTOFlags = le16_to_cpu(pdevice->ATTOFlags);\r\ndata = 0;\r\nif (ATTOFlags & ATTOFLAG_DISC)\r\ndata |= (MPI_SCSIPORTPAGE2_DEVICE_DISCONNECT_ENABLE);\r\nif (ATTOFlags & ATTOFLAG_ID_ENB)\r\ndata |= (MPI_SCSIPORTPAGE2_DEVICE_ID_SCAN_ENABLE);\r\nif (ATTOFlags & ATTOFLAG_LUN_ENB)\r\ndata |= (MPI_SCSIPORTPAGE2_DEVICE_LUN_SCAN_ENABLE);\r\nif (ATTOFlags & ATTOFLAG_TAGGED)\r\ndata |= (MPI_SCSIPORTPAGE2_DEVICE_TAG_QUEUE_ENABLE);\r\nif (!(ATTOFlags & ATTOFLAG_WIDE_ENB))\r\ndata |= (MPI_SCSIPORTPAGE2_DEVICE_WIDE_DISABLE);\r\ndata = (data << 16) | (pdevice->Period << 8) | 10;\r\nioc->spi_data.nvram[ii] = data;\r\n}\r\n} else {\r\nSCSIPortPage2_t *pPP2 = (SCSIPortPage2_t *) pbuf;\r\nMpiDeviceInfo_t *pdevice = NULL;\r\nioc->spi_data.bus_reset =\r\n(le32_to_cpu(pPP2->PortFlags) &\r\nMPI_SCSIPORTPAGE2_PORT_FLAGS_AVOID_SCSI_RESET) ?\r\n0 : 1 ;\r\ndata = le32_to_cpu(pPP2->PortFlags) & MPI_SCSIPORTPAGE2_PORT_FLAGS_DV_MASK;\r\nioc->spi_data.PortFlags = data;\r\nfor (ii=0; ii < MPT_MAX_SCSI_DEVICES; ii++) {\r\npdevice = &pPP2->DeviceSettings[ii];\r\ndata = (le16_to_cpu(pdevice->DeviceFlags) << 16) |\r\n(pdevice->SyncFactor << 8) | pdevice->Timeout;\r\nioc->spi_data.nvram[ii] = data;\r\n}\r\n}\r\npci_free_consistent(ioc->pcidev, header.PageLength * 4, pbuf, buf_dma);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmpt_readScsiDevicePageHeaders(MPT_ADAPTER *ioc, int portnum)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t header;\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 1;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = portnum;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn -EFAULT;\r\nioc->spi_data.sdp1version = cfg.cfghdr.hdr->PageVersion;\r\nioc->spi_data.sdp1length = cfg.cfghdr.hdr->PageLength;\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 0;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn -EFAULT;\r\nioc->spi_data.sdp0version = cfg.cfghdr.hdr->PageVersion;\r\nioc->spi_data.sdp0length = cfg.cfghdr.hdr->PageLength;\r\ndcprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Headers: 0: version %d length %d\n",\r\nioc->name, ioc->spi_data.sdp0version, ioc->spi_data.sdp0length));\r\ndcprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Headers: 1: version %d length %d\n",\r\nioc->name, ioc->spi_data.sdp1version, ioc->spi_data.sdp1length));\r\nreturn 0;\r\n}\r\nstatic void\r\nmpt_inactive_raid_list_free(MPT_ADAPTER *ioc)\r\n{\r\nstruct inactive_raid_component_info *component_info, *pNext;\r\nif (list_empty(&ioc->raid_data.inactive_list))\r\nreturn;\r\nmutex_lock(&ioc->raid_data.inactive_list_mutex);\r\nlist_for_each_entry_safe(component_info, pNext,\r\n&ioc->raid_data.inactive_list, list) {\r\nlist_del(&component_info->list);\r\nkfree(component_info);\r\n}\r\nmutex_unlock(&ioc->raid_data.inactive_list_mutex);\r\n}\r\nstatic void\r\nmpt_inactive_raid_volumes(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t dma_handle;\r\npRaidVolumePage0_t buffer = NULL;\r\nint i;\r\nRaidPhysDiskPage0_t phys_disk;\r\nstruct inactive_raid_component_info *component_info;\r\nint handle_inactive_volumes;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;\r\ncfg.pageAddr = (channel << 8) + id;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!hdr.PageLength)\r\ngoto out;\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4,\r\n&dma_handle);\r\nif (!buffer)\r\ngoto out;\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!buffer->NumPhysDisks)\r\ngoto out;\r\nhandle_inactive_volumes =\r\n(buffer->VolumeStatus.Flags & MPI_RAIDVOL0_STATUS_FLAG_VOLUME_INACTIVE ||\r\n(buffer->VolumeStatus.Flags & MPI_RAIDVOL0_STATUS_FLAG_ENABLED) == 0 ||\r\nbuffer->VolumeStatus.State == MPI_RAIDVOL0_STATUS_STATE_FAILED ||\r\nbuffer->VolumeStatus.State == MPI_RAIDVOL0_STATUS_STATE_MISSING) ? 1 : 0;\r\nif (!handle_inactive_volumes)\r\ngoto out;\r\nmutex_lock(&ioc->raid_data.inactive_list_mutex);\r\nfor (i = 0; i < buffer->NumPhysDisks; i++) {\r\nif(mpt_raid_phys_disk_pg0(ioc,\r\nbuffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)\r\ncontinue;\r\nif ((component_info = kmalloc(sizeof (*component_info),\r\nGFP_KERNEL)) == NULL)\r\ncontinue;\r\ncomponent_info->volumeID = id;\r\ncomponent_info->volumeBus = channel;\r\ncomponent_info->d.PhysDiskNum = phys_disk.PhysDiskNum;\r\ncomponent_info->d.PhysDiskBus = phys_disk.PhysDiskBus;\r\ncomponent_info->d.PhysDiskID = phys_disk.PhysDiskID;\r\ncomponent_info->d.PhysDiskIOC = phys_disk.PhysDiskIOC;\r\nlist_add_tail(&component_info->list,\r\n&ioc->raid_data.inactive_list);\r\n}\r\nmutex_unlock(&ioc->raid_data.inactive_list_mutex);\r\nout:\r\nif (buffer)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, buffer,\r\ndma_handle);\r\n}\r\nint\r\nmpt_raid_phys_disk_pg0(MPT_ADAPTER *ioc, u8 phys_disk_num,\r\nRaidPhysDiskPage0_t *phys_disk)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t dma_handle;\r\npRaidPhysDiskPage0_t buffer = NULL;\r\nint rc;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nmemset(phys_disk, 0, sizeof(RaidPhysDiskPage0_t));\r\nhdr.PageVersion = MPI_RAIDPHYSDISKPAGE0_PAGEVERSION;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nif (!hdr.PageLength) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.pageAddr = phys_disk_num;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nrc = 0;\r\nmemcpy(phys_disk, buffer, sizeof(*buffer));\r\nphys_disk->MaxLBA = le32_to_cpu(buffer->MaxLBA);\r\nout:\r\nif (buffer)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, buffer,\r\ndma_handle);\r\nreturn rc;\r\n}\r\nint\r\nmpt_raid_phys_disk_get_num_paths(MPT_ADAPTER *ioc, u8 phys_disk_num)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t dma_handle;\r\npRaidPhysDiskPage1_t buffer = NULL;\r\nint rc;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nhdr.PageVersion = MPI_RAIDPHYSDISKPAGE1_PAGEVERSION;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;\r\nhdr.PageNumber = 1;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (!hdr.PageLength) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nrc = 0;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.pageAddr = phys_disk_num;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = buffer->NumPhysDiskPaths;\r\nout:\r\nif (buffer)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, buffer,\r\ndma_handle);\r\nreturn rc;\r\n}\r\nint\r\nmpt_raid_phys_disk_pg1(MPT_ADAPTER *ioc, u8 phys_disk_num,\r\nRaidPhysDiskPage1_t *phys_disk)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t dma_handle;\r\npRaidPhysDiskPage1_t buffer = NULL;\r\nint rc;\r\nint i;\r\n__le64 sas_address;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nrc = 0;\r\nhdr.PageVersion = MPI_RAIDPHYSDISKPAGE1_PAGEVERSION;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_RAID_PHYSDISK;\r\nhdr.PageNumber = 1;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nif (!hdr.PageLength) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.pageAddr = phys_disk_num;\r\nif (mpt_config(ioc, &cfg) != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nphys_disk->NumPhysDiskPaths = buffer->NumPhysDiskPaths;\r\nphys_disk->PhysDiskNum = phys_disk_num;\r\nfor (i = 0; i < phys_disk->NumPhysDiskPaths; i++) {\r\nphys_disk->Path[i].PhysDiskID = buffer->Path[i].PhysDiskID;\r\nphys_disk->Path[i].PhysDiskBus = buffer->Path[i].PhysDiskBus;\r\nphys_disk->Path[i].OwnerIdentifier =\r\nbuffer->Path[i].OwnerIdentifier;\r\nphys_disk->Path[i].Flags = le16_to_cpu(buffer->Path[i].Flags);\r\nmemcpy(&sas_address, &buffer->Path[i].WWID, sizeof(__le64));\r\nsas_address = le64_to_cpu(sas_address);\r\nmemcpy(&phys_disk->Path[i].WWID, &sas_address, sizeof(__le64));\r\nmemcpy(&sas_address,\r\n&buffer->Path[i].OwnerWWID, sizeof(__le64));\r\nsas_address = le64_to_cpu(sas_address);\r\nmemcpy(&phys_disk->Path[i].OwnerWWID,\r\n&sas_address, sizeof(__le64));\r\n}\r\nout:\r\nif (buffer)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, buffer,\r\ndma_handle);\r\nreturn rc;\r\n}\r\nint\r\nmpt_findImVolumes(MPT_ADAPTER *ioc)\r\n{\r\nIOCPage2_t *pIoc2;\r\nu8 *mem;\r\ndma_addr_t ioc2_dma;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t header;\r\nint rc = 0;\r\nint iocpage2sz;\r\nint i;\r\nif (!ioc->ir_firmware)\r\nreturn 0;\r\nkfree(ioc->raid_data.pIocPg2);\r\nioc->raid_data.pIocPg2 = NULL;\r\nmpt_inactive_raid_list_free(ioc);\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 2;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_IOC;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = 0;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn -EFAULT;\r\nif (header.PageLength == 0)\r\nreturn -EFAULT;\r\niocpage2sz = header.PageLength * 4;\r\npIoc2 = pci_alloc_consistent(ioc->pcidev, iocpage2sz, &ioc2_dma);\r\nif (!pIoc2)\r\nreturn -ENOMEM;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\ncfg.physAddr = ioc2_dma;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nmem = kmalloc(iocpage2sz, GFP_KERNEL);\r\nif (!mem) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(mem, (u8 *)pIoc2, iocpage2sz);\r\nioc->raid_data.pIocPg2 = (IOCPage2_t *) mem;\r\nmpt_read_ioc_pg_3(ioc);\r\nfor (i = 0; i < pIoc2->NumActiveVolumes ; i++)\r\nmpt_inactive_raid_volumes(ioc,\r\npIoc2->RaidVolume[i].VolumeBus,\r\npIoc2->RaidVolume[i].VolumeID);\r\nout:\r\npci_free_consistent(ioc->pcidev, iocpage2sz, pIoc2, ioc2_dma);\r\nreturn rc;\r\n}\r\nstatic int\r\nmpt_read_ioc_pg_3(MPT_ADAPTER *ioc)\r\n{\r\nIOCPage3_t *pIoc3;\r\nu8 *mem;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t header;\r\ndma_addr_t ioc3_dma;\r\nint iocpage3sz = 0;\r\nkfree(ioc->raid_data.pIocPg3);\r\nioc->raid_data.pIocPg3 = NULL;\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 3;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_IOC;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = 0;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn 0;\r\nif (header.PageLength == 0)\r\nreturn 0;\r\niocpage3sz = header.PageLength * 4;\r\npIoc3 = pci_alloc_consistent(ioc->pcidev, iocpage3sz, &ioc3_dma);\r\nif (!pIoc3)\r\nreturn 0;\r\ncfg.physAddr = ioc3_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif (mpt_config(ioc, &cfg) == 0) {\r\nmem = kmalloc(iocpage3sz, GFP_KERNEL);\r\nif (mem) {\r\nmemcpy(mem, (u8 *)pIoc3, iocpage3sz);\r\nioc->raid_data.pIocPg3 = (IOCPage3_t *) mem;\r\n}\r\n}\r\npci_free_consistent(ioc->pcidev, iocpage3sz, pIoc3, ioc3_dma);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpt_read_ioc_pg_4(MPT_ADAPTER *ioc)\r\n{\r\nIOCPage4_t *pIoc4;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t header;\r\ndma_addr_t ioc4_dma;\r\nint iocpage4sz;\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 4;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_IOC;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = 0;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn;\r\nif (header.PageLength == 0)\r\nreturn;\r\nif ( (pIoc4 = ioc->spi_data.pIocPg4) == NULL ) {\r\niocpage4sz = (header.PageLength + 4) * 4;\r\npIoc4 = pci_alloc_consistent(ioc->pcidev, iocpage4sz, &ioc4_dma);\r\nif (!pIoc4)\r\nreturn;\r\nioc->alloc_total += iocpage4sz;\r\n} else {\r\nioc4_dma = ioc->spi_data.IocPg4_dma;\r\niocpage4sz = ioc->spi_data.IocPg4Sz;\r\n}\r\ncfg.physAddr = ioc4_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif (mpt_config(ioc, &cfg) == 0) {\r\nioc->spi_data.pIocPg4 = (IOCPage4_t *) pIoc4;\r\nioc->spi_data.IocPg4_dma = ioc4_dma;\r\nioc->spi_data.IocPg4Sz = iocpage4sz;\r\n} else {\r\npci_free_consistent(ioc->pcidev, iocpage4sz, pIoc4, ioc4_dma);\r\nioc->spi_data.pIocPg4 = NULL;\r\nioc->alloc_total -= iocpage4sz;\r\n}\r\n}\r\nstatic void\r\nmpt_read_ioc_pg_1(MPT_ADAPTER *ioc)\r\n{\r\nIOCPage1_t *pIoc1;\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t header;\r\ndma_addr_t ioc1_dma;\r\nint iocpage1sz = 0;\r\nu32 tmp;\r\nheader.PageVersion = 0;\r\nheader.PageLength = 0;\r\nheader.PageNumber = 1;\r\nheader.PageType = MPI_CONFIG_PAGETYPE_IOC;\r\ncfg.cfghdr.hdr = &header;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = 0;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = 0;\r\nif (mpt_config(ioc, &cfg) != 0)\r\nreturn;\r\nif (header.PageLength == 0)\r\nreturn;\r\niocpage1sz = header.PageLength * 4;\r\npIoc1 = pci_alloc_consistent(ioc->pcidev, iocpage1sz, &ioc1_dma);\r\nif (!pIoc1)\r\nreturn;\r\ncfg.physAddr = ioc1_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif (mpt_config(ioc, &cfg) == 0) {\r\ntmp = le32_to_cpu(pIoc1->Flags) & MPI_IOCPAGE1_REPLY_COALESCING;\r\nif (tmp == MPI_IOCPAGE1_REPLY_COALESCING) {\r\ntmp = le32_to_cpu(pIoc1->CoalescingTimeout);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Coalescing Enabled Timeout = %d\n",\r\nioc->name, tmp));\r\nif (tmp > MPT_COALESCING_TIMEOUT) {\r\npIoc1->CoalescingTimeout = cpu_to_le32(MPT_COALESCING_TIMEOUT);\r\ncfg.dir = 1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\r\nif (mpt_config(ioc, &cfg) == 0) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Reset Current Coalescing Timeout to = %d\n",\r\nioc->name, MPT_COALESCING_TIMEOUT));\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM;\r\nif (mpt_config(ioc, &cfg) == 0) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Reset NVRAM Coalescing Timeout to = %d\n",\r\nioc->name, MPT_COALESCING_TIMEOUT));\r\n} else {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Reset NVRAM Coalescing Timeout Failed\n",\r\nioc->name));\r\n}\r\n} else {\r\ndprintk(ioc, printk(MYIOC_s_WARN_FMT\r\n"Reset of Current Coalescing Timeout Failed!\n",\r\nioc->name));\r\n}\r\n}\r\n} else {\r\ndprintk(ioc, printk(MYIOC_s_WARN_FMT "Coalescing Disabled\n", ioc->name));\r\n}\r\n}\r\npci_free_consistent(ioc->pcidev, iocpage1sz, pIoc1, ioc1_dma);\r\nreturn;\r\n}\r\nstatic void\r\nmpt_get_manufacturing_pg_0(MPT_ADAPTER *ioc)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t buf_dma;\r\nManufacturingPage0_t *pbuf = NULL;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.timeout = 10;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!cfg.cfghdr.hdr->PageLength)\r\ngoto out;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\npbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);\r\nif (!pbuf)\r\ngoto out;\r\ncfg.physAddr = buf_dma;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nmemcpy(ioc->board_name, pbuf->BoardName, sizeof(ioc->board_name));\r\nmemcpy(ioc->board_assembly, pbuf->BoardAssembly, sizeof(ioc->board_assembly));\r\nmemcpy(ioc->board_tracer, pbuf->BoardTracerNumber, sizeof(ioc->board_tracer));\r\nout:\r\nif (pbuf)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);\r\n}\r\nstatic int\r\nSendEventNotification(MPT_ADAPTER *ioc, u8 EvSwitch, int sleepFlag)\r\n{\r\nEventNotification_t evn;\r\nMPIDefaultReply_t reply_buf;\r\nmemset(&evn, 0, sizeof(EventNotification_t));\r\nmemset(&reply_buf, 0, sizeof(MPIDefaultReply_t));\r\nevn.Function = MPI_FUNCTION_EVENT_NOTIFICATION;\r\nevn.Switch = EvSwitch;\r\nevn.MsgContext = cpu_to_le32(mpt_base_index << 16);\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Sending EventNotification (%d) request %p\n",\r\nioc->name, EvSwitch, &evn));\r\nreturn mpt_handshake_req_reply_wait(ioc, sizeof(EventNotification_t),\r\n(u32 *)&evn, sizeof(MPIDefaultReply_t), (u16 *)&reply_buf, 30,\r\nsleepFlag);\r\n}\r\nstatic int\r\nSendEventAck(MPT_ADAPTER *ioc, EventNotificationReply_t *evnp)\r\n{\r\nEventAck_t *pAck;\r\nif ((pAck = (EventAck_t *) mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, no msg frames!!\n",\r\nioc->name, __func__));\r\nreturn -1;\r\n}\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Sending EventAck\n", ioc->name));\r\npAck->Function = MPI_FUNCTION_EVENT_ACK;\r\npAck->ChainOffset = 0;\r\npAck->Reserved[0] = pAck->Reserved[1] = 0;\r\npAck->MsgFlags = 0;\r\npAck->Reserved1[0] = pAck->Reserved1[1] = pAck->Reserved1[2] = 0;\r\npAck->Event = evnp->Event;\r\npAck->EventContext = evnp->EventContext;\r\nmpt_put_msg_frame(mpt_base_index, ioc, (MPT_FRAME_HDR *)pAck);\r\nreturn 0;\r\n}\r\nint\r\nmpt_config(MPT_ADAPTER *ioc, CONFIGPARMS *pCfg)\r\n{\r\nConfig_t *pReq;\r\nConfigReply_t *pReply;\r\nConfigExtendedPageHeader_t *pExtHdr = NULL;\r\nMPT_FRAME_HDR *mf;\r\nint ii;\r\nint flagsLength;\r\nlong timeout;\r\nint ret;\r\nu8 page_type = 0, extend_page;\r\nunsigned long timeleft;\r\nunsigned long flags;\r\nint in_isr;\r\nu8 issue_hard_reset = 0;\r\nu8 retry_count = 0;\r\nin_isr = in_interrupt();\r\nif (in_isr) {\r\ndcprintk(ioc, printk(MYIOC_s_WARN_FMT "Config request not allowed in ISR context!\n",\r\nioc->name));\r\nreturn -EPERM;\r\n}\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: busy with host reset\n", ioc->name, __func__));\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nif (!ioc->active ||\r\nmpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: ioc not operational, %d, %xh\n",\r\nioc->name, __func__, ioc->active,\r\nmpt_GetIocState(ioc, 0)));\r\nreturn -EFAULT;\r\n}\r\nretry_config:\r\nmutex_lock(&ioc->mptbase_cmds.mutex);\r\nmemset(ioc->mptbase_cmds.reply, 0 , MPT_DEFAULT_FRAME_SIZE);\r\nINITIALIZE_MGMT_STATUS(ioc->mptbase_cmds.status)\r\nif ((mf = mpt_get_msg_frame(mpt_base_index, ioc)) == NULL) {\r\ndcprintk(ioc, printk(MYIOC_s_WARN_FMT\r\n"mpt_config: no msg frames!\n", ioc->name));\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\npReq = (Config_t *)mf;\r\npReq->Action = pCfg->action;\r\npReq->Reserved = 0;\r\npReq->ChainOffset = 0;\r\npReq->Function = MPI_FUNCTION_CONFIG;\r\npReq->ExtPageLength = 0;\r\npReq->ExtPageType = 0;\r\npReq->MsgFlags = 0;\r\nfor (ii=0; ii < 8; ii++)\r\npReq->Reserved2[ii] = 0;\r\npReq->Header.PageVersion = pCfg->cfghdr.hdr->PageVersion;\r\npReq->Header.PageLength = pCfg->cfghdr.hdr->PageLength;\r\npReq->Header.PageNumber = pCfg->cfghdr.hdr->PageNumber;\r\npReq->Header.PageType = (pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK);\r\nif ((pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK) == MPI_CONFIG_PAGETYPE_EXTENDED) {\r\npExtHdr = (ConfigExtendedPageHeader_t *)pCfg->cfghdr.ehdr;\r\npReq->ExtPageLength = cpu_to_le16(pExtHdr->ExtPageLength);\r\npReq->ExtPageType = pExtHdr->ExtPageType;\r\npReq->Header.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\npReq->Header.PageLength = 0;\r\n}\r\npReq->PageAddress = cpu_to_le32(pCfg->pageAddr);\r\nif (pCfg->dir)\r\nflagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;\r\nelse\r\nflagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;\r\nif ((pCfg->cfghdr.hdr->PageType & MPI_CONFIG_PAGETYPE_MASK) ==\r\nMPI_CONFIG_PAGETYPE_EXTENDED) {\r\nflagsLength |= pExtHdr->ExtPageLength * 4;\r\npage_type = pReq->ExtPageType;\r\nextend_page = 1;\r\n} else {\r\nflagsLength |= pCfg->cfghdr.hdr->PageLength * 4;\r\npage_type = pReq->Header.PageType;\r\nextend_page = 0;\r\n}\r\ndcprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Sending Config request type 0x%x, page 0x%x and action %d\n",\r\nioc->name, page_type, pReq->Header.PageNumber, pReq->Action));\r\nioc->add_sge((char *)&pReq->PageBufferSGE, flagsLength, pCfg->physAddr);\r\ntimeout = (pCfg->timeout < 15) ? HZ*15 : HZ*pCfg->timeout;\r\nmpt_put_msg_frame(mpt_base_index, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->mptbase_cmds.done,\r\ntimeout);\r\nif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = -ETIME;\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Failed Sending Config request type 0x%x, page 0x%x,"\r\n" action %d, status %xh, time left %ld\n\n",\r\nioc->name, page_type, pReq->Header.PageNumber,\r\npReq->Action, ioc->mptbase_cmds.status, timeleft));\r\nif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out;\r\nif (!timeleft) {\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock,\r\nflags);\r\nprintk(MYIOC_s_INFO_FMT "%s: host reset in"\r\n" progress mpt_config timed out.!!\n",\r\n__func__, ioc->name);\r\nmutex_unlock(&ioc->mptbase_cmds.mutex);\r\nreturn -EFAULT;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nissue_hard_reset = 1;\r\n}\r\ngoto out;\r\n}\r\nif (!(ioc->mptbase_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\r\nret = -1;\r\ngoto out;\r\n}\r\npReply = (ConfigReply_t *)ioc->mptbase_cmds.reply;\r\nret = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nif (ret == MPI_IOCSTATUS_SUCCESS) {\r\nif (extend_page) {\r\npCfg->cfghdr.ehdr->ExtPageLength =\r\nle16_to_cpu(pReply->ExtPageLength);\r\npCfg->cfghdr.ehdr->ExtPageType =\r\npReply->ExtPageType;\r\n}\r\npCfg->cfghdr.hdr->PageVersion = pReply->Header.PageVersion;\r\npCfg->cfghdr.hdr->PageLength = pReply->Header.PageLength;\r\npCfg->cfghdr.hdr->PageNumber = pReply->Header.PageNumber;\r\npCfg->cfghdr.hdr->PageType = pReply->Header.PageType;\r\n}\r\nif (retry_count)\r\nprintk(MYIOC_s_INFO_FMT "Retry completed "\r\n"ret=0x%x timeleft=%ld\n",\r\nioc->name, ret, timeleft);\r\ndcprintk(ioc, printk(KERN_DEBUG "IOCStatus=%04xh, IOCLogInfo=%08xh\n",\r\nret, le32_to_cpu(pReply->IOCLogInfo)));\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->mptbase_cmds.status)\r\nmutex_unlock(&ioc->mptbase_cmds.mutex);\r\nif (issue_hard_reset) {\r\nissue_hard_reset = 0;\r\nprintk(MYIOC_s_WARN_FMT\r\n"Issuing Reset from %s!!, doorbell=0x%08x\n",\r\nioc->name, __func__, mpt_GetIocState(ioc, 0));\r\nif (retry_count == 0) {\r\nif (mpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP) != 0)\r\nretry_count++;\r\n} else\r\nmpt_HardResetHandler(ioc, CAN_SLEEP);\r\nmpt_free_msg_frame(ioc, mf);\r\nif (retry_count < 2) {\r\nprintk(MYIOC_s_INFO_FMT\r\n"Attempting Retry Config request"\r\n" type 0x%x, page 0x%x,"\r\n" action %d\n", ioc->name, page_type,\r\npCfg->cfghdr.hdr->PageNumber, pCfg->action);\r\nretry_count++;\r\ngoto retry_config;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nmpt_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nswitch (reset_phase) {\r\ncase MPT_IOC_SETUP_RESET:\r\nioc->taskmgmt_quiesce_io = 1;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT_IOC_PRE_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT_IOC_POST_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));\r\nif (ioc->mptbase_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->mptbase_cmds.status |=\r\nMPT_MGMT_STATUS_DID_IOCRESET;\r\ncomplete(&ioc->mptbase_cmds.done);\r\n}\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->taskmgmt_cmds.status |=\r\nMPT_MGMT_STATUS_DID_IOCRESET;\r\ncomplete(&ioc->taskmgmt_cmds.done);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nprocmpt_create(void)\r\n{\r\nmpt_proc_root_dir = proc_mkdir(MPT_PROCFS_MPTBASEDIR, NULL);\r\nif (mpt_proc_root_dir == NULL)\r\nreturn -ENOTDIR;\r\nproc_create("summary", S_IRUGO, mpt_proc_root_dir, &mpt_summary_proc_fops);\r\nproc_create("version", S_IRUGO, mpt_proc_root_dir, &mpt_version_proc_fops);\r\nreturn 0;\r\n}\r\nstatic void\r\nprocmpt_destroy(void)\r\n{\r\nremove_proc_entry("version", mpt_proc_root_dir);\r\nremove_proc_entry("summary", mpt_proc_root_dir);\r\nremove_proc_entry(MPT_PROCFS_MPTBASEDIR, NULL);\r\n}\r\nstatic int mpt_summary_proc_show(struct seq_file *m, void *v)\r\n{\r\nMPT_ADAPTER *ioc = m->private;\r\nif (ioc) {\r\nseq_mpt_print_ioc_summary(ioc, m, 1);\r\n} else {\r\nlist_for_each_entry(ioc, &ioc_list, list) {\r\nseq_mpt_print_ioc_summary(ioc, m, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpt_summary_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mpt_summary_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int mpt_version_proc_show(struct seq_file *m, void *v)\r\n{\r\nu8 cb_idx;\r\nint scsi, fc, sas, lan, ctl, targ, dmp;\r\nchar *drvname;\r\nseq_printf(m, "%s-%s\n", "mptlinux", MPT_LINUX_VERSION_COMMON);\r\nseq_printf(m, " Fusion MPT base driver\n");\r\nscsi = fc = sas = lan = ctl = targ = dmp = 0;\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\ndrvname = NULL;\r\nif (MptCallbacks[cb_idx]) {\r\nswitch (MptDriverClass[cb_idx]) {\r\ncase MPTSPI_DRIVER:\r\nif (!scsi++) drvname = "SPI host";\r\nbreak;\r\ncase MPTFC_DRIVER:\r\nif (!fc++) drvname = "FC host";\r\nbreak;\r\ncase MPTSAS_DRIVER:\r\nif (!sas++) drvname = "SAS host";\r\nbreak;\r\ncase MPTLAN_DRIVER:\r\nif (!lan++) drvname = "LAN";\r\nbreak;\r\ncase MPTSTM_DRIVER:\r\nif (!targ++) drvname = "SCSI target";\r\nbreak;\r\ncase MPTCTL_DRIVER:\r\nif (!ctl++) drvname = "ioctl";\r\nbreak;\r\n}\r\nif (drvname)\r\nseq_printf(m, " Fusion MPT %s driver\n", drvname);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpt_version_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mpt_version_proc_show, NULL);\r\n}\r\nstatic int mpt_iocinfo_proc_show(struct seq_file *m, void *v)\r\n{\r\nMPT_ADAPTER *ioc = m->private;\r\nchar expVer[32];\r\nint sz;\r\nint p;\r\nmpt_get_fw_exp_ver(expVer, ioc);\r\nseq_printf(m, "%s:", ioc->name);\r\nif (ioc->facts.Flags & MPI_IOCFACTS_FLAGS_FW_DOWNLOAD_BOOT)\r\nseq_printf(m, " (f/w download boot flag set)");\r\nseq_printf(m, "\n ProductID = 0x%04x (%s)\n",\r\nioc->facts.ProductID,\r\nioc->prod_name);\r\nseq_printf(m, " FWVersion = 0x%08x%s", ioc->facts.FWVersion.Word, expVer);\r\nif (ioc->facts.FWImageSize)\r\nseq_printf(m, " (fw_size=%d)", ioc->facts.FWImageSize);\r\nseq_printf(m, "\n MsgVersion = 0x%04x\n", ioc->facts.MsgVersion);\r\nseq_printf(m, " FirstWhoInit = 0x%02x\n", ioc->FirstWhoInit);\r\nseq_printf(m, " EventState = 0x%02x\n", ioc->facts.EventState);\r\nseq_printf(m, " CurrentHostMfaHighAddr = 0x%08x\n",\r\nioc->facts.CurrentHostMfaHighAddr);\r\nseq_printf(m, " CurrentSenseBufferHighAddr = 0x%08x\n",\r\nioc->facts.CurrentSenseBufferHighAddr);\r\nseq_printf(m, " MaxChainDepth = 0x%02x frames\n", ioc->facts.MaxChainDepth);\r\nseq_printf(m, " MinBlockSize = 0x%02x bytes\n", 4*ioc->facts.BlockSize);\r\nseq_printf(m, " RequestFrames @ 0x%p (Dma @ 0x%p)\n",\r\n(void *)ioc->req_frames, (void *)(ulong)ioc->req_frames_dma);\r\nsz = (ioc->req_sz * ioc->req_depth) + 128;\r\nsz = ((sz + 0x1000UL - 1UL) / 0x1000) * 0x1000;\r\nseq_printf(m, " {CurReqSz=%d} x {CurReqDepth=%d} = %d bytes ^= 0x%x\n",\r\nioc->req_sz, ioc->req_depth, ioc->req_sz*ioc->req_depth, sz);\r\nseq_printf(m, " {MaxReqSz=%d} {MaxReqDepth=%d}\n",\r\n4*ioc->facts.RequestFrameSize,\r\nioc->facts.GlobalCredits);\r\nseq_printf(m, " Frames @ 0x%p (Dma @ 0x%p)\n",\r\n(void *)ioc->alloc, (void *)(ulong)ioc->alloc_dma);\r\nsz = (ioc->reply_sz * ioc->reply_depth) + 128;\r\nseq_printf(m, " {CurRepSz=%d} x {CurRepDepth=%d} = %d bytes ^= 0x%x\n",\r\nioc->reply_sz, ioc->reply_depth, ioc->reply_sz*ioc->reply_depth, sz);\r\nseq_printf(m, " {MaxRepSz=%d} {MaxRepDepth=%d}\n",\r\nioc->facts.CurReplyFrameSize,\r\nioc->facts.ReplyQueueDepth);\r\nseq_printf(m, " MaxDevices = %d\n",\r\n(ioc->facts.MaxDevices==0) ? 255 : ioc->facts.MaxDevices);\r\nseq_printf(m, " MaxBuses = %d\n", ioc->facts.MaxBuses);\r\nfor (p=0; p < ioc->facts.NumberOfPorts; p++) {\r\nseq_printf(m, " PortNumber = %d (of %d)\n",\r\np+1,\r\nioc->facts.NumberOfPorts);\r\nif (ioc->bus_type == FC) {\r\nif (ioc->pfacts[p].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN) {\r\nu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\r\nseq_printf(m, " LanAddr = %02X:%02X:%02X:%02X:%02X:%02X\n",\r\na[5], a[4], a[3], a[2], a[1], a[0]);\r\n}\r\nseq_printf(m, " WWN = %08X%08X:%08X%08X\n",\r\nioc->fc_port_page0[p].WWNN.High,\r\nioc->fc_port_page0[p].WWNN.Low,\r\nioc->fc_port_page0[p].WWPN.High,\r\nioc->fc_port_page0[p].WWPN.Low);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpt_iocinfo_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mpt_iocinfo_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void\r\nmpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc)\r\n{\r\nbuf[0] ='\0';\r\nif ((ioc->facts.FWVersion.Word >> 24) == 0x0E) {\r\nsprintf(buf, " (Exp %02d%02d)",\r\n(ioc->facts.FWVersion.Word >> 16) & 0x00FF,\r\n(ioc->facts.FWVersion.Word >> 8) & 0x1F);\r\nif ((ioc->facts.FWVersion.Word >> 8) & 0x80)\r\nstrcat(buf, " [MDBG]");\r\n}\r\n}\r\nvoid\r\nmpt_print_ioc_summary(MPT_ADAPTER *ioc, char *buffer, int *size, int len, int showlan)\r\n{\r\nchar expVer[32];\r\nint y;\r\nmpt_get_fw_exp_ver(expVer, ioc);\r\ny = sprintf(buffer+len, "%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d",\r\nioc->name,\r\nioc->prod_name,\r\nMPT_FW_REV_MAGIC_ID_STRING,\r\nioc->facts.FWVersion.Word,\r\nexpVer,\r\nioc->facts.NumberOfPorts,\r\nioc->req_depth);\r\nif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\r\nu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\r\ny += sprintf(buffer+len+y, ", LanAddr=%02X:%02X:%02X:%02X:%02X:%02X",\r\na[5], a[4], a[3], a[2], a[1], a[0]);\r\n}\r\ny += sprintf(buffer+len+y, ", IRQ=%d", ioc->pci_irq);\r\nif (!ioc->active)\r\ny += sprintf(buffer+len+y, " (disabled)");\r\ny += sprintf(buffer+len+y, "\n");\r\n*size = y;\r\n}\r\nstatic void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\r\n{\r\nchar expVer[32];\r\nmpt_get_fw_exp_ver(expVer, ioc);\r\nseq_printf(m, "%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d",\r\nioc->name,\r\nioc->prod_name,\r\nMPT_FW_REV_MAGIC_ID_STRING,\r\nioc->facts.FWVersion.Word,\r\nexpVer,\r\nioc->facts.NumberOfPorts,\r\nioc->req_depth);\r\nif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\r\nu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\r\nseq_printf(m, ", LanAddr=%02X:%02X:%02X:%02X:%02X:%02X",\r\na[5], a[4], a[3], a[2], a[1], a[0]);\r\n}\r\nseq_printf(m, ", IRQ=%d", ioc->pci_irq);\r\nif (!ioc->active)\r\nseq_printf(m, " (disabled)");\r\nseq_putc(m, '\n');\r\n}\r\nint\r\nmpt_set_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc)\r\n{\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress || ioc->taskmgmt_in_progress ||\r\n(ioc->alt_ioc && ioc->alt_ioc->taskmgmt_in_progress)) {\r\nretval = -1;\r\ngoto out;\r\n}\r\nretval = 0;\r\nioc->taskmgmt_in_progress = 1;\r\nioc->taskmgmt_quiesce_io = 1;\r\nif (ioc->alt_ioc) {\r\nioc->alt_ioc->taskmgmt_in_progress = 1;\r\nioc->alt_ioc->taskmgmt_quiesce_io = 1;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nreturn retval;\r\n}\r\nvoid\r\nmpt_clear_taskmgmt_in_progress_flag(MPT_ADAPTER *ioc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nioc->taskmgmt_in_progress = 0;\r\nioc->taskmgmt_quiesce_io = 0;\r\nif (ioc->alt_ioc) {\r\nioc->alt_ioc->taskmgmt_in_progress = 0;\r\nioc->alt_ioc->taskmgmt_quiesce_io = 0;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\n}\r\nvoid\r\nmpt_halt_firmware(MPT_ADAPTER *ioc)\r\n{\r\nu32 ioc_raw_state;\r\nioc_raw_state = mpt_GetIocState(ioc, 0);\r\nif ((ioc_raw_state & MPI_IOC_STATE_MASK) == MPI_IOC_STATE_FAULT) {\r\nprintk(MYIOC_s_ERR_FMT "IOC is in FAULT state (%04xh)!!!\n",\r\nioc->name, ioc_raw_state & MPI_DOORBELL_DATA_MASK);\r\npanic("%s: IOC Fault (%04xh)!!!\n", ioc->name,\r\nioc_raw_state & MPI_DOORBELL_DATA_MASK);\r\n} else {\r\nCHIPREG_WRITE32(&ioc->chip->Doorbell, 0xC0FFEE00);\r\npanic("%s: Firmware is halted due to command timeout\n",\r\nioc->name);\r\n}\r\n}\r\nint\r\nmpt_SoftResetHandler(MPT_ADAPTER *ioc, int sleepFlag)\r\n{\r\nint rc;\r\nint ii;\r\nu8 cb_idx;\r\nunsigned long flags;\r\nu32 ioc_state;\r\nunsigned long time_count;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SoftResetHandler Entered!\n",\r\nioc->name));\r\nioc_state = mpt_GetIocState(ioc, 0) & MPI_IOC_STATE_MASK;\r\nif (mpt_fwfault_debug)\r\nmpt_halt_firmware(ioc);\r\nif (ioc_state == MPI_IOC_STATE_FAULT ||\r\nioc_state == MPI_IOC_STATE_RESET) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"skipping, either in FAULT or RESET state!\n", ioc->name));\r\nreturn -1;\r\n}\r\nif (ioc->bus_type == FC) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"skipping, because the bus type is FC!\n", ioc->name));\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nreturn -1;\r\n}\r\nioc->ioc_reset_in_progress = 1;\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nrc = -1;\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx])\r\nmpt_signal_reset(cb_idx, ioc, MPT_IOC_SETUP_RESET);\r\n}\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->taskmgmt_in_progress) {\r\nioc->ioc_reset_in_progress = 0;\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nreturn -1;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);\r\nioc->active = 0;\r\ntime_count = jiffies;\r\nrc = SendIocReset(ioc, MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET, sleepFlag);\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx])\r\nmpt_signal_reset(cb_idx, ioc, MPT_IOC_PRE_RESET);\r\n}\r\nif (rc)\r\ngoto out;\r\nioc_state = mpt_GetIocState(ioc, 0) & MPI_IOC_STATE_MASK;\r\nif (ioc_state != MPI_IOC_STATE_READY)\r\ngoto out;\r\nfor (ii = 0; ii < 5; ii++) {\r\nrc = GetIocFacts(ioc, sleepFlag,\r\nMPT_HOSTEVENT_IOC_RECOVER);\r\nif (rc == 0)\r\nbreak;\r\nif (sleepFlag == CAN_SLEEP)\r\nmsleep(100);\r\nelse\r\nmdelay(100);\r\n}\r\nif (ii == 5)\r\ngoto out;\r\nrc = PrimeIocFifos(ioc);\r\nif (rc != 0)\r\ngoto out;\r\nrc = SendIocInit(ioc, sleepFlag);\r\nif (rc != 0)\r\ngoto out;\r\nrc = SendEventNotification(ioc, 1, sleepFlag);\r\nif (rc != 0)\r\ngoto out;\r\nif (ioc->hard_resets < -1)\r\nioc->hard_resets++;\r\nioc->active = 1;\r\nCHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);\r\nout:\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nioc->ioc_reset_in_progress = 0;\r\nioc->taskmgmt_quiesce_io = 0;\r\nioc->taskmgmt_in_progress = 0;\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nif (ioc->active) {\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx])\r\nmpt_signal_reset(cb_idx, ioc,\r\nMPT_IOC_POST_RESET);\r\n}\r\n}\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"SoftResetHandler: completed (%d seconds): %s\n",\r\nioc->name, jiffies_to_msecs(jiffies - time_count)/1000,\r\n((rc == 0) ? "SUCCESS" : "FAILED")));\r\nreturn rc;\r\n}\r\nint\r\nmpt_Soft_Hard_ResetHandler(MPT_ADAPTER *ioc, int sleepFlag) {\r\nint ret = -1;\r\nret = mpt_SoftResetHandler(ioc, sleepFlag);\r\nif (ret == 0)\r\nreturn ret;\r\nret = mpt_HardResetHandler(ioc, sleepFlag);\r\nreturn ret;\r\n}\r\nint\r\nmpt_HardResetHandler(MPT_ADAPTER *ioc, int sleepFlag)\r\n{\r\nint rc;\r\nu8 cb_idx;\r\nunsigned long flags;\r\nunsigned long time_count;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "HardResetHandler Entered!\n", ioc->name));\r\n#ifdef MFCNT\r\nprintk(MYIOC_s_INFO_FMT "HardResetHandler Entered!\n", ioc->name);\r\nprintk("MF count 0x%x !\n", ioc->mfcnt);\r\n#endif\r\nif (mpt_fwfault_debug)\r\nmpt_halt_firmware(ioc);\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nioc->wait_on_reset_completion = 1;\r\ndo {\r\nssleep(1);\r\n} while (ioc->ioc_reset_in_progress == 1);\r\nioc->wait_on_reset_completion = 0;\r\nreturn ioc->reset_status;\r\n}\r\nif (ioc->wait_on_reset_completion) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nrc = 0;\r\ntime_count = jiffies;\r\ngoto exit;\r\n}\r\nioc->ioc_reset_in_progress = 1;\r\nif (ioc->alt_ioc)\r\nioc->alt_ioc->ioc_reset_in_progress = 1;\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx]) {\r\nmpt_signal_reset(cb_idx, ioc, MPT_IOC_SETUP_RESET);\r\nif (ioc->alt_ioc)\r\nmpt_signal_reset(cb_idx, ioc->alt_ioc,\r\nMPT_IOC_SETUP_RESET);\r\n}\r\n}\r\ntime_count = jiffies;\r\nrc = mpt_do_ioc_recovery(ioc, MPT_HOSTEVENT_IOC_RECOVER, sleepFlag);\r\nif (rc != 0) {\r\nprintk(KERN_WARNING MYNAM\r\n": WARNING - (%d) Cannot recover %s, doorbell=0x%08x\n",\r\nrc, ioc->name, mpt_GetIocState(ioc, 0));\r\n} else {\r\nif (ioc->hard_resets < -1)\r\nioc->hard_resets++;\r\n}\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nioc->ioc_reset_in_progress = 0;\r\nioc->taskmgmt_quiesce_io = 0;\r\nioc->taskmgmt_in_progress = 0;\r\nioc->reset_status = rc;\r\nif (ioc->alt_ioc) {\r\nioc->alt_ioc->ioc_reset_in_progress = 0;\r\nioc->alt_ioc->taskmgmt_quiesce_io = 0;\r\nioc->alt_ioc->taskmgmt_in_progress = 0;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptResetHandlers[cb_idx]) {\r\nmpt_signal_reset(cb_idx, ioc, MPT_IOC_POST_RESET);\r\nif (ioc->alt_ioc)\r\nmpt_signal_reset(cb_idx,\r\nioc->alt_ioc, MPT_IOC_POST_RESET);\r\n}\r\n}\r\nexit:\r\ndtmprintk(ioc,\r\nprintk(MYIOC_s_DEBUG_FMT\r\n"HardResetHandler: completed (%d seconds): %s\n", ioc->name,\r\njiffies_to_msecs(jiffies - time_count)/1000, ((rc == 0) ?\r\n"SUCCESS" : "FAILED")));\r\nreturn rc;\r\n}\r\nstatic void\r\nmpt_display_event_info(MPT_ADAPTER *ioc, EventNotificationReply_t *pEventReply)\r\n{\r\nchar *ds = NULL;\r\nu32 evData0;\r\nint ii;\r\nu8 event;\r\nchar *evStr = ioc->evStr;\r\nevent = le32_to_cpu(pEventReply->Event) & 0xFF;\r\nevData0 = le32_to_cpu(pEventReply->Data[0]);\r\nswitch(event) {\r\ncase MPI_EVENT_NONE:\r\nds = "None";\r\nbreak;\r\ncase MPI_EVENT_LOG_DATA:\r\nds = "Log Data";\r\nbreak;\r\ncase MPI_EVENT_STATE_CHANGE:\r\nds = "State Change";\r\nbreak;\r\ncase MPI_EVENT_UNIT_ATTENTION:\r\nds = "Unit Attention";\r\nbreak;\r\ncase MPI_EVENT_IOC_BUS_RESET:\r\nds = "IOC Bus Reset";\r\nbreak;\r\ncase MPI_EVENT_EXT_BUS_RESET:\r\nds = "External Bus Reset";\r\nbreak;\r\ncase MPI_EVENT_RESCAN:\r\nds = "Bus Rescan Event";\r\nbreak;\r\ncase MPI_EVENT_LINK_STATUS_CHANGE:\r\nif (evData0 == MPI_EVENT_LINK_STATUS_FAILURE)\r\nds = "Link Status(FAILURE) Change";\r\nelse\r\nds = "Link Status(ACTIVE) Change";\r\nbreak;\r\ncase MPI_EVENT_LOOP_STATE_CHANGE:\r\nif (evData0 == MPI_EVENT_LOOP_STATE_CHANGE_LIP)\r\nds = "Loop State(LIP) Change";\r\nelse if (evData0 == MPI_EVENT_LOOP_STATE_CHANGE_LPE)\r\nds = "Loop State(LPE) Change";\r\nelse\r\nds = "Loop State(LPB) Change";\r\nbreak;\r\ncase MPI_EVENT_LOGOUT:\r\nds = "Logout";\r\nbreak;\r\ncase MPI_EVENT_EVENT_CHANGE:\r\nif (evData0)\r\nds = "Events ON";\r\nelse\r\nds = "Events OFF";\r\nbreak;\r\ncase MPI_EVENT_INTEGRATED_RAID:\r\n{\r\nu8 ReasonCode = (u8)(evData0 >> 16);\r\nswitch (ReasonCode) {\r\ncase MPI_EVENT_RAID_RC_VOLUME_CREATED :\r\nds = "Integrated Raid: Volume Created";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_DELETED :\r\nds = "Integrated Raid: Volume Deleted";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_SETTINGS_CHANGED :\r\nds = "Integrated Raid: Volume Settings Changed";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED :\r\nds = "Integrated Raid: Volume Status Changed";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_PHYSDISK_CHANGED :\r\nds = "Integrated Raid: Volume Physdisk Changed";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_CREATED :\r\nds = "Integrated Raid: Physdisk Created";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_DELETED :\r\nds = "Integrated Raid: Physdisk Deleted";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_SETTINGS_CHANGED :\r\nds = "Integrated Raid: Physdisk Settings Changed";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED :\r\nds = "Integrated Raid: Physdisk Status Changed";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_DOMAIN_VAL_NEEDED :\r\nds = "Integrated Raid: Domain Validation Needed";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_SMART_DATA :\r\nds = "Integrated Raid; Smart Data";\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_REPLACE_ACTION_STARTED :\r\nds = "Integrated Raid: Replace Action Started";\r\nbreak;\r\ndefault:\r\nds = "Integrated Raid";\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE:\r\nds = "SCSI Device Status Change";\r\nbreak;\r\ncase MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:\r\n{\r\nu8 id = (u8)(evData0);\r\nu8 channel = (u8)(evData0 >> 8);\r\nu8 ReasonCode = (u8)(evData0 >> 16);\r\nswitch (ReasonCode) {\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_ADDED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Added: "\r\n"id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Deleted: "\r\n"id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: SMART Data: "\r\n"id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: No Persistancy: "\r\n"id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Unsupported Device "\r\n"Discovered : id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Internal Device "\r\n"Reset : id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_TASK_ABORT_INTERNAL:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Internal Task "\r\n"Abort : id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Internal Abort "\r\n"Task Set : id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Internal Clear "\r\n"Task Set : id=%d channel=%d", id, channel);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_QUERY_TASK_INTERNAL:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Internal Query "\r\n"Task : id=%d channel=%d", id, channel);\r\nbreak;\r\ndefault:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Device Status Change: Unknown: "\r\n"id=%d channel=%d", id, channel);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase MPI_EVENT_ON_BUS_TIMER_EXPIRED:\r\nds = "Bus Timer Expired";\r\nbreak;\r\ncase MPI_EVENT_QUEUE_FULL:\r\n{\r\nu16 curr_depth = (u16)(evData0 >> 16);\r\nu8 channel = (u8)(evData0 >> 8);\r\nu8 id = (u8)(evData0);\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"Queue Full: channel=%d id=%d depth=%d",\r\nchannel, id, curr_depth);\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_SES:\r\nds = "SAS SES Event";\r\nbreak;\r\ncase MPI_EVENT_PERSISTENT_TABLE_FULL:\r\nds = "Persistent Table Full";\r\nbreak;\r\ncase MPI_EVENT_SAS_PHY_LINK_STATUS:\r\n{\r\nu8 LinkRates = (u8)(evData0 >> 8);\r\nu8 PhyNumber = (u8)(evData0);\r\nLinkRates = (LinkRates & MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>\r\nMPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;\r\nswitch (LinkRates) {\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_UNKNOWN:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Rate Unknown",PhyNumber);\r\nbreak;\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_PHY_DISABLED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Phy Disabled",PhyNumber);\r\nbreak;\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_FAILED_SPEED_NEGOTIATION:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Failed Speed Nego",PhyNumber);\r\nbreak;\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_SATA_OOB_COMPLETE:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Sata OOB Completed",PhyNumber);\r\nbreak;\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_1_5:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Rate 1.5 Gbps",PhyNumber);\r\nbreak;\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_3_0:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Rate 3.0 Gbps", PhyNumber);\r\nbreak;\r\ncase MPI_EVENT_SAS_PLS_LR_RATE_6_0:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d:"\r\n" Rate 6.0 Gbps", PhyNumber);\r\nbreak;\r\ndefault:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS PHY Link Status: Phy=%d", PhyNumber);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_DISCOVERY_ERROR:\r\nds = "SAS Discovery Error";\r\nbreak;\r\ncase MPI_EVENT_IR_RESYNC_UPDATE:\r\n{\r\nu8 resync_complete = (u8)(evData0 >> 16);\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR Resync Update: Complete = %d:",resync_complete);\r\nbreak;\r\n}\r\ncase MPI_EVENT_IR2:\r\n{\r\nu8 id = (u8)(evData0);\r\nu8 channel = (u8)(evData0 >> 8);\r\nu8 phys_num = (u8)(evData0 >> 24);\r\nu8 ReasonCode = (u8)(evData0 >> 16);\r\nswitch (ReasonCode) {\r\ncase MPI_EVENT_IR2_RC_LD_STATE_CHANGED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: LD State Changed: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_PD_STATE_CHANGED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: PD State Changed "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_BAD_BLOCK_TABLE_FULL:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: Bad Block Table Full: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_PD_INSERTED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: PD Inserted: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_PD_REMOVED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: PD Removed: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_FOREIGN_CFG_DETECTED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: Foreign CFG Detected: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_REBUILD_MEDIUM_ERROR:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: Rebuild Medium Error: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_DUAL_PORT_ADDED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: Dual Port Added: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_DUAL_PORT_REMOVED:\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"IR2: Dual Port Removed: "\r\n"id=%d channel=%d phys_num=%d",\r\nid, channel, phys_num);\r\nbreak;\r\ndefault:\r\nds = "IR2";\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_DISCOVERY:\r\n{\r\nif (evData0)\r\nds = "SAS Discovery: Start";\r\nelse\r\nds = "SAS Discovery: Stop";\r\nbreak;\r\n}\r\ncase MPI_EVENT_LOG_ENTRY_ADDED:\r\nds = "SAS Log Entry Added";\r\nbreak;\r\ncase MPI_EVENT_SAS_BROADCAST_PRIMITIVE:\r\n{\r\nu8 phy_num = (u8)(evData0);\r\nu8 port_num = (u8)(evData0 >> 8);\r\nu8 port_width = (u8)(evData0 >> 16);\r\nu8 primative = (u8)(evData0 >> 24);\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Broadcase Primative: phy=%d port=%d "\r\n"width=%d primative=0x%02x",\r\nphy_num, port_num, port_width, primative);\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:\r\n{\r\nu8 reason = (u8)(evData0);\r\nswitch (reason) {\r\ncase MPI_EVENT_SAS_INIT_RC_ADDED:\r\nds = "SAS Initiator Status Change: Added";\r\nbreak;\r\ncase MPI_EVENT_SAS_INIT_RC_REMOVED:\r\nds = "SAS Initiator Status Change: Deleted";\r\nbreak;\r\ndefault:\r\nds = "SAS Initiator Status Change";\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_INIT_TABLE_OVERFLOW:\r\n{\r\nu8 max_init = (u8)(evData0);\r\nu8 current_init = (u8)(evData0 >> 8);\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS Initiator Device Table Overflow: max initiators=%02d "\r\n"current initators=%02d",\r\nmax_init, current_init);\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_SMP_ERROR:\r\n{\r\nu8 status = (u8)(evData0);\r\nu8 port_num = (u8)(evData0 >> 8);\r\nu8 result = (u8)(evData0 >> 16);\r\nif (status == MPI_EVENT_SAS_SMP_FUNCTION_RESULT_VALID)\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS SMP Error: port=%d result=0x%02x",\r\nport_num, result);\r\nelse if (status == MPI_EVENT_SAS_SMP_CRC_ERROR)\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS SMP Error: port=%d : CRC Error",\r\nport_num);\r\nelse if (status == MPI_EVENT_SAS_SMP_TIMEOUT)\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS SMP Error: port=%d : Timeout",\r\nport_num);\r\nelse if (status == MPI_EVENT_SAS_SMP_NO_DESTINATION)\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS SMP Error: port=%d : No Destination",\r\nport_num);\r\nelse if (status == MPI_EVENT_SAS_SMP_BAD_DESTINATION)\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS SMP Error: port=%d : Bad Destination",\r\nport_num);\r\nelse\r\nsnprintf(evStr, EVENT_DESCR_STR_SZ,\r\n"SAS SMP Error: port=%d : status=0x%02x",\r\nport_num, status);\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE:\r\n{\r\nu8 reason = (u8)(evData0);\r\nswitch (reason) {\r\ncase MPI_EVENT_SAS_EXP_RC_ADDED:\r\nds = "Expander Status Change: Added";\r\nbreak;\r\ncase MPI_EVENT_SAS_EXP_RC_NOT_RESPONDING:\r\nds = "Expander Status Change: Deleted";\r\nbreak;\r\ndefault:\r\nds = "Expander Status Change";\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nds = "Unknown";\r\nbreak;\r\n}\r\nif (ds)\r\nstrncpy(evStr, ds, EVENT_DESCR_STR_SZ);\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"MPT event:(%02Xh) : %s\n",\r\nioc->name, event, evStr));\r\ndevtverboseprintk(ioc, printk(KERN_DEBUG MYNAM\r\n": Event data:\n"));\r\nfor (ii = 0; ii < le16_to_cpu(pEventReply->EventDataLength); ii++)\r\ndevtverboseprintk(ioc, printk(" %08x",\r\nle32_to_cpu(pEventReply->Data[ii])));\r\ndevtverboseprintk(ioc, printk(KERN_DEBUG "\n"));\r\n}\r\nstatic int\r\nProcessEventNotification(MPT_ADAPTER *ioc, EventNotificationReply_t *pEventReply, int *evHandlers)\r\n{\r\nu16 evDataLen;\r\nu32 evData0 = 0;\r\nint ii;\r\nu8 cb_idx;\r\nint r = 0;\r\nint handlers = 0;\r\nu8 event;\r\nevent = le32_to_cpu(pEventReply->Event) & 0xFF;\r\nevDataLen = le16_to_cpu(pEventReply->EventDataLength);\r\nif (evDataLen) {\r\nevData0 = le32_to_cpu(pEventReply->Data[0]);\r\n}\r\n#ifdef CONFIG_FUSION_LOGGING\r\nif (evDataLen)\r\nmpt_display_event_info(ioc, pEventReply);\r\n#endif\r\nswitch(event) {\r\ncase MPI_EVENT_EVENT_CHANGE:\r\nif (evDataLen) {\r\nu8 evState = evData0 & 0xFF;\r\nif (ioc->facts.Function) {\r\nioc->facts.EventState = evState;\r\n}\r\n}\r\nbreak;\r\ncase MPI_EVENT_INTEGRATED_RAID:\r\nmptbase_raid_process_event_data(ioc,\r\n(MpiEventDataRaid_t *)pEventReply->Data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ioc->events && (ioc->eventTypes & ( 1 << event))) {\r\nint idx;\r\nidx = ioc->eventContext % MPTCTL_EVENT_LOG_SIZE;\r\nioc->events[idx].event = event;\r\nioc->events[idx].eventContext = ioc->eventContext;\r\nfor (ii = 0; ii < 2; ii++) {\r\nif (ii < evDataLen)\r\nioc->events[idx].data[ii] = le32_to_cpu(pEventReply->Data[ii]);\r\nelse\r\nioc->events[idx].data[ii] = 0;\r\n}\r\nioc->eventContext++;\r\n}\r\nfor (cb_idx = MPT_MAX_PROTOCOL_DRIVERS-1; cb_idx; cb_idx--) {\r\nif (MptEvHandlers[cb_idx]) {\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Routing Event to event handler #%d\n",\r\nioc->name, cb_idx));\r\nr += (*(MptEvHandlers[cb_idx]))(ioc, pEventReply);\r\nhandlers++;\r\n}\r\n}\r\nif (pEventReply->AckRequired == MPI_EVENT_NOTIFICATION_ACK_REQUIRED) {\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"EventAck required\n",ioc->name));\r\nif ((ii = SendEventAck(ioc, pEventReply)) != 0) {\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SendEventAck returned %d\n",\r\nioc->name, ii));\r\n}\r\n}\r\n*evHandlers = handlers;\r\nreturn r;\r\n}\r\nstatic void\r\nmpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info)\r\n{\r\nchar *desc = "unknown";\r\nswitch (log_info & 0xFF000000) {\r\ncase MPI_IOCLOGINFO_FC_INIT_BASE:\r\ndesc = "FCP Initiator";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_TARGET_BASE:\r\ndesc = "FCP Target";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_LAN_BASE:\r\ndesc = "LAN";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_MSG_BASE:\r\ndesc = "MPI Message Layer";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_LINK_BASE:\r\ndesc = "FC Link";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_CTX_BASE:\r\ndesc = "Context Manager";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET:\r\ndesc = "Invalid Field Offset";\r\nbreak;\r\ncase MPI_IOCLOGINFO_FC_STATE_CHANGE:\r\ndesc = "State Change Info";\r\nbreak;\r\n}\r\nprintk(MYIOC_s_INFO_FMT "LogInfo(0x%08x): SubClass={%s}, Value=(0x%06x)\n",\r\nioc->name, log_info, desc, (log_info & 0xFFFFFF));\r\n}\r\nstatic void\r\nmpt_spi_log_info(MPT_ADAPTER *ioc, u32 log_info)\r\n{\r\nu32 info = log_info & 0x00FF0000;\r\nchar *desc = "unknown";\r\nswitch (info) {\r\ncase 0x00010000:\r\ndesc = "bug! MID not found";\r\nbreak;\r\ncase 0x00020000:\r\ndesc = "Parity Error";\r\nbreak;\r\ncase 0x00030000:\r\ndesc = "ASYNC Outbound Overrun";\r\nbreak;\r\ncase 0x00040000:\r\ndesc = "SYNC Offset Error";\r\nbreak;\r\ncase 0x00050000:\r\ndesc = "BM Change";\r\nbreak;\r\ncase 0x00060000:\r\ndesc = "Msg In Overflow";\r\nbreak;\r\ncase 0x00070000:\r\ndesc = "DMA Error";\r\nbreak;\r\ncase 0x00080000:\r\ndesc = "Outbound DMA Overrun";\r\nbreak;\r\ncase 0x00090000:\r\ndesc = "Task Management";\r\nbreak;\r\ncase 0x000A0000:\r\ndesc = "Device Problem";\r\nbreak;\r\ncase 0x000B0000:\r\ndesc = "Invalid Phase Change";\r\nbreak;\r\ncase 0x000C0000:\r\ndesc = "Untagged Table Size";\r\nbreak;\r\n}\r\nprintk(MYIOC_s_INFO_FMT "LogInfo(0x%08x): F/W: %s\n", ioc->name, log_info, desc);\r\n}\r\nstatic void\r\nmpt_sas_log_info(MPT_ADAPTER *ioc, u32 log_info, u8 cb_idx)\r\n{\r\nunion loginfo_type {\r\nu32 loginfo;\r\nstruct {\r\nu32 subcode:16;\r\nu32 code:8;\r\nu32 originator:4;\r\nu32 bus_type:4;\r\n}dw;\r\n};\r\nunion loginfo_type sas_loginfo;\r\nchar *originator_desc = NULL;\r\nchar *code_desc = NULL;\r\nchar *sub_code_desc = NULL;\r\nsas_loginfo.loginfo = log_info;\r\nif ((sas_loginfo.dw.bus_type != 3 ) &&\r\n(sas_loginfo.dw.originator < ARRAY_SIZE(originator_str)))\r\nreturn;\r\noriginator_desc = originator_str[sas_loginfo.dw.originator];\r\nswitch (sas_loginfo.dw.originator) {\r\ncase 0:\r\nif (sas_loginfo.dw.code <\r\nARRAY_SIZE(iop_code_str))\r\ncode_desc = iop_code_str[sas_loginfo.dw.code];\r\nbreak;\r\ncase 1:\r\nif (sas_loginfo.dw.code <\r\nARRAY_SIZE(pl_code_str))\r\ncode_desc = pl_code_str[sas_loginfo.dw.code];\r\nbreak;\r\ncase 2:\r\nif (sas_loginfo.dw.code >=\r\nARRAY_SIZE(ir_code_str))\r\nbreak;\r\ncode_desc = ir_code_str[sas_loginfo.dw.code];\r\nif (sas_loginfo.dw.subcode >=\r\nARRAY_SIZE(raid_sub_code_str))\r\nbreak;\r\nif (sas_loginfo.dw.code == 0)\r\nsub_code_desc =\r\nraid_sub_code_str[sas_loginfo.dw.subcode];\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (sub_code_desc != NULL)\r\nprintk(MYIOC_s_INFO_FMT\r\n"LogInfo(0x%08x): Originator={%s}, Code={%s},"\r\n" SubCode={%s} cb_idx %s\n",\r\nioc->name, log_info, originator_desc, code_desc,\r\nsub_code_desc, MptCallbacksName[cb_idx]);\r\nelse if (code_desc != NULL)\r\nprintk(MYIOC_s_INFO_FMT\r\n"LogInfo(0x%08x): Originator={%s}, Code={%s},"\r\n" SubCode(0x%04x) cb_idx %s\n",\r\nioc->name, log_info, originator_desc, code_desc,\r\nsas_loginfo.dw.subcode, MptCallbacksName[cb_idx]);\r\nelse\r\nprintk(MYIOC_s_INFO_FMT\r\n"LogInfo(0x%08x): Originator={%s}, Code=(0x%02x),"\r\n" SubCode(0x%04x) cb_idx %s\n",\r\nioc->name, log_info, originator_desc,\r\nsas_loginfo.dw.code, sas_loginfo.dw.subcode,\r\nMptCallbacksName[cb_idx]);\r\n}\r\nstatic void\r\nmpt_iocstatus_info_config(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf)\r\n{\r\nConfig_t *pReq = (Config_t *)mf;\r\nchar extend_desc[EVENT_DESCR_STR_SZ];\r\nchar *desc = NULL;\r\nu32 form;\r\nu8 page_type;\r\nif (pReq->Header.PageType == MPI_CONFIG_PAGETYPE_EXTENDED)\r\npage_type = pReq->ExtPageType;\r\nelse\r\npage_type = pReq->Header.PageType;\r\nform = le32_to_cpu(pReq->PageAddress);\r\nif (ioc_status == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\r\nif (page_type == MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE ||\r\npage_type == MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER ||\r\npage_type == MPI_CONFIG_EXTPAGETYPE_ENCLOSURE) {\r\nif ((form >> MPI_SAS_DEVICE_PGAD_FORM_SHIFT) ==\r\nMPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE)\r\nreturn;\r\n}\r\nif (page_type == MPI_CONFIG_PAGETYPE_FC_DEVICE)\r\nif ((form & MPI_FC_DEVICE_PGAD_FORM_MASK) ==\r\nMPI_FC_DEVICE_PGAD_FORM_NEXT_DID)\r\nreturn;\r\n}\r\nsnprintf(extend_desc, EVENT_DESCR_STR_SZ,\r\n"type=%02Xh, page=%02Xh, action=%02Xh, form=%08Xh",\r\npage_type, pReq->Header.PageNumber, pReq->Action, form);\r\nswitch (ioc_status) {\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_ACTION:\r\ndesc = "Config Page Invalid Action";\r\nbreak;\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_TYPE:\r\ndesc = "Config Page Invalid Type";\r\nbreak;\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_PAGE:\r\ndesc = "Config Page Invalid Page";\r\nbreak;\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_DATA:\r\ndesc = "Config Page Invalid Data";\r\nbreak;\r\ncase MPI_IOCSTATUS_CONFIG_NO_DEFAULTS:\r\ndesc = "Config Page No Defaults";\r\nbreak;\r\ncase MPI_IOCSTATUS_CONFIG_CANT_COMMIT:\r\ndesc = "Config Page Can't Commit";\r\nbreak;\r\n}\r\nif (!desc)\r\nreturn;\r\ndreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT "IOCStatus(0x%04X): %s: %s\n",\r\nioc->name, ioc_status, desc, extend_desc));\r\n}\r\nstatic void\r\nmpt_iocstatus_info(MPT_ADAPTER *ioc, u32 ioc_status, MPT_FRAME_HDR *mf)\r\n{\r\nu32 status = ioc_status & MPI_IOCSTATUS_MASK;\r\nchar *desc = NULL;\r\nswitch (status) {\r\ncase MPI_IOCSTATUS_INVALID_FUNCTION:\r\ndesc = "Invalid Function";\r\nbreak;\r\ncase MPI_IOCSTATUS_BUSY:\r\ndesc = "Busy";\r\nbreak;\r\ncase MPI_IOCSTATUS_INVALID_SGL:\r\ndesc = "Invalid SGL";\r\nbreak;\r\ncase MPI_IOCSTATUS_INTERNAL_ERROR:\r\ndesc = "Internal Error";\r\nbreak;\r\ncase MPI_IOCSTATUS_RESERVED:\r\ndesc = "Reserved";\r\nbreak;\r\ncase MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:\r\ndesc = "Insufficient Resources";\r\nbreak;\r\ncase MPI_IOCSTATUS_INVALID_FIELD:\r\ndesc = "Invalid Field";\r\nbreak;\r\ncase MPI_IOCSTATUS_INVALID_STATE:\r\ndesc = "Invalid State";\r\nbreak;\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_ACTION:\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_TYPE:\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_PAGE:\r\ncase MPI_IOCSTATUS_CONFIG_INVALID_DATA:\r\ncase MPI_IOCSTATUS_CONFIG_NO_DEFAULTS:\r\ncase MPI_IOCSTATUS_CONFIG_CANT_COMMIT:\r\nmpt_iocstatus_info_config(ioc, status, mf);\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:\r\ncase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\ncase MPI_IOCSTATUS_SCSI_INVALID_BUS:\r\ncase MPI_IOCSTATUS_SCSI_INVALID_TARGETID:\r\ncase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\ncase MPI_IOCSTATUS_SCSI_DATA_OVERRUN:\r\ncase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ncase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\ncase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\r\ncase MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\r\ncase MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\r\ncase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\r\ncase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_PRIORITY_IO:\r\ndesc = "Target: Priority IO";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_INVALID_PORT:\r\ndesc = "Target: Invalid Port";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_INVALID_IO_INDEX:\r\ndesc = "Target Invalid IO Index:";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_ABORTED:\r\ndesc = "Target: Aborted";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_NO_CONN_RETRYABLE:\r\ndesc = "Target: No Conn Retryable";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_NO_CONNECTION:\r\ndesc = "Target: No Connection";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:\r\ndesc = "Target: Transfer Count Mismatch";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT:\r\ndesc = "Target: STS Data not Sent";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:\r\ndesc = "Target: Data Offset Error";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:\r\ndesc = "Target: Too Much Write Data";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_IU_TOO_SHORT:\r\ndesc = "Target: IU Too Short";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT:\r\ndesc = "Target: ACK NAK Timeout";\r\nbreak;\r\ncase MPI_IOCSTATUS_TARGET_NAK_RECEIVED:\r\ndesc = "Target: Nak Received";\r\nbreak;\r\ncase MPI_IOCSTATUS_FC_ABORTED:\r\ndesc = "FC: Aborted";\r\nbreak;\r\ncase MPI_IOCSTATUS_FC_RX_ID_INVALID:\r\ndesc = "FC: RX ID Invalid";\r\nbreak;\r\ncase MPI_IOCSTATUS_FC_DID_INVALID:\r\ndesc = "FC: DID Invalid";\r\nbreak;\r\ncase MPI_IOCSTATUS_FC_NODE_LOGGED_OUT:\r\ndesc = "FC: Node Logged Out";\r\nbreak;\r\ncase MPI_IOCSTATUS_FC_EXCHANGE_CANCELED:\r\ndesc = "FC: Exchange Canceled";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_DEVICE_NOT_FOUND:\r\ndesc = "LAN: Device not Found";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_DEVICE_FAILURE:\r\ndesc = "LAN: Device Failure";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_TRANSMIT_ERROR:\r\ndesc = "LAN: Transmit Error";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_TRANSMIT_ABORTED:\r\ndesc = "LAN: Transmit Aborted";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_RECEIVE_ERROR:\r\ndesc = "LAN: Receive Error";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_RECEIVE_ABORTED:\r\ndesc = "LAN: Receive Aborted";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_PARTIAL_PACKET:\r\ndesc = "LAN: Partial Packet";\r\nbreak;\r\ncase MPI_IOCSTATUS_LAN_CANCELED:\r\ndesc = "LAN: Canceled";\r\nbreak;\r\ncase MPI_IOCSTATUS_SAS_SMP_REQUEST_FAILED:\r\ndesc = "SAS: SMP Request Failed";\r\nbreak;\r\ncase MPI_IOCSTATUS_SAS_SMP_DATA_OVERRUN:\r\ndesc = "SAS: SMP Data Overrun";\r\nbreak;\r\ndefault:\r\ndesc = "Others";\r\nbreak;\r\n}\r\nif (!desc)\r\nreturn;\r\ndreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT "IOCStatus(0x%04X): %s\n",\r\nioc->name, status, desc));\r\n}\r\nstatic int __init\r\nfusion_init(void)\r\n{\r\nu8 cb_idx;\r\nshow_mptmod_ver(my_NAME, my_VERSION);\r\nprintk(KERN_INFO COPYRIGHT "\n");\r\nfor (cb_idx = 0; cb_idx < MPT_MAX_PROTOCOL_DRIVERS; cb_idx++) {\r\nMptCallbacks[cb_idx] = NULL;\r\nMptDriverClass[cb_idx] = MPTUNKNOWN_DRIVER;\r\nMptEvHandlers[cb_idx] = NULL;\r\nMptResetHandlers[cb_idx] = NULL;\r\n}\r\nmpt_base_index = mpt_register(mptbase_reply, MPTBASE_DRIVER,\r\n"mptbase_reply");\r\nmpt_reset_register(mpt_base_index, mpt_ioc_reset);\r\n#ifdef CONFIG_PROC_FS\r\n(void) procmpt_create();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nfusion_exit(void)\r\n{\r\nmpt_reset_deregister(mpt_base_index);\r\n#ifdef CONFIG_PROC_FS\r\nprocmpt_destroy();\r\n#endif\r\n}
