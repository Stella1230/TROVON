static int __init checkreqprot_setup(char *str)\r\n{\r\nunsigned long checkreqprot;\r\nif (!strict_strtoul(str, 0, &checkreqprot))\r\nselinux_checkreqprot = checkreqprot ? 1 : 0;\r\nreturn 1;\r\n}\r\nstatic int task_has_security(struct task_struct *tsk,\r\nu32 perms)\r\n{\r\nconst struct task_security_struct *tsec;\r\nu32 sid = 0;\r\nrcu_read_lock();\r\ntsec = __task_cred(tsk)->security;\r\nif (tsec)\r\nsid = tsec->sid;\r\nrcu_read_unlock();\r\nif (!tsec)\r\nreturn -EACCES;\r\nreturn avc_has_perm(sid, SECINITSID_SECURITY,\r\nSECCLASS_SECURITY, perms, NULL);\r\n}\r\nstatic ssize_t sel_read_enforce(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%d", selinux_enforcing);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic ssize_t sel_write_enforce(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t length;\r\nint new_value;\r\nlength = -ENOMEM;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nlength = EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nlength = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nlength = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(page, "%d", &new_value) != 1)\r\ngoto out;\r\nif (new_value != selinux_enforcing) {\r\nlength = task_has_security(current, SECURITY__SETENFORCE);\r\nif (length)\r\ngoto out;\r\naudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,\r\n"enforcing=%d old_enforcing=%d auid=%u ses=%u",\r\nnew_value, selinux_enforcing,\r\nfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\r\naudit_get_sessionid(current));\r\nselinux_enforcing = new_value;\r\nif (selinux_enforcing)\r\navc_ss_reset(0);\r\nselnl_notify_setenforce(selinux_enforcing);\r\nselinux_status_update_setenforce(selinux_enforcing);\r\n}\r\nlength = count;\r\nout:\r\nfree_page((unsigned long) page);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_read_handle_unknown(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nino_t ino = file_inode(filp)->i_ino;\r\nint handle_unknown = (ino == SEL_REJECT_UNKNOWN) ?\r\nsecurity_get_reject_unknown() : !security_get_allow_unknown();\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%d", handle_unknown);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic int sel_open_handle_status(struct inode *inode, struct file *filp)\r\n{\r\nstruct page *status = selinux_kernel_status_page();\r\nif (!status)\r\nreturn -ENOMEM;\r\nfilp->private_data = status;\r\nreturn 0;\r\n}\r\nstatic ssize_t sel_read_handle_status(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct page *status = filp->private_data;\r\nBUG_ON(!status);\r\nreturn simple_read_from_buffer(buf, count, ppos,\r\npage_address(status),\r\nsizeof(struct selinux_kernel_status));\r\n}\r\nstatic int sel_mmap_handle_status(struct file *filp,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct page *status = filp->private_data;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nBUG_ON(!status);\r\nif (vma->vm_pgoff > 0 || size != PAGE_SIZE)\r\nreturn -EIO;\r\nif (vma->vm_flags & VM_WRITE)\r\nreturn -EPERM;\r\nvma->vm_flags &= ~VM_MAYWRITE;\r\nreturn remap_pfn_range(vma, vma->vm_start,\r\npage_to_pfn(status),\r\nsize, vma->vm_page_prot);\r\n}\r\nstatic ssize_t sel_write_disable(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t length;\r\nint new_value;\r\nlength = -ENOMEM;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nlength = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nlength = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(page, "%d", &new_value) != 1)\r\ngoto out;\r\nif (new_value) {\r\nlength = selinux_disable();\r\nif (length)\r\ngoto out;\r\naudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,\r\n"selinux=0 auid=%u ses=%u",\r\nfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\r\naudit_get_sessionid(current));\r\n}\r\nlength = count;\r\nout:\r\nfree_page((unsigned long) page);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_read_policyvers(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%u", POLICYDB_VERSION_MAX);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic ssize_t sel_read_mls(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%d",\r\nsecurity_mls_enabled());\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic int sel_open_policy(struct inode *inode, struct file *filp)\r\n{\r\nstruct policy_load_memory *plm = NULL;\r\nint rc;\r\nBUG_ON(filp->private_data);\r\nmutex_lock(&sel_mutex);\r\nrc = task_has_security(current, SECURITY__READ_POLICY);\r\nif (rc)\r\ngoto err;\r\nrc = -EBUSY;\r\nif (policy_opened)\r\ngoto err;\r\nrc = -ENOMEM;\r\nplm = kzalloc(sizeof(*plm), GFP_KERNEL);\r\nif (!plm)\r\ngoto err;\r\nif (i_size_read(inode) != security_policydb_len()) {\r\nmutex_lock(&inode->i_mutex);\r\ni_size_write(inode, security_policydb_len());\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nrc = security_read_policy(&plm->data, &plm->len);\r\nif (rc)\r\ngoto err;\r\npolicy_opened = 1;\r\nfilp->private_data = plm;\r\nmutex_unlock(&sel_mutex);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&sel_mutex);\r\nif (plm)\r\nvfree(plm->data);\r\nkfree(plm);\r\nreturn rc;\r\n}\r\nstatic int sel_release_policy(struct inode *inode, struct file *filp)\r\n{\r\nstruct policy_load_memory *plm = filp->private_data;\r\nBUG_ON(!plm);\r\npolicy_opened = 0;\r\nvfree(plm->data);\r\nkfree(plm);\r\nreturn 0;\r\n}\r\nstatic ssize_t sel_read_policy(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct policy_load_memory *plm = filp->private_data;\r\nint ret;\r\nmutex_lock(&sel_mutex);\r\nret = task_has_security(current, SECURITY__READ_POLICY);\r\nif (ret)\r\ngoto out;\r\nret = simple_read_from_buffer(buf, count, ppos, plm->data, plm->len);\r\nout:\r\nmutex_unlock(&sel_mutex);\r\nreturn ret;\r\n}\r\nstatic int sel_mmap_policy_fault(struct vm_area_struct *vma,\r\nstruct vm_fault *vmf)\r\n{\r\nstruct policy_load_memory *plm = vma->vm_file->private_data;\r\nunsigned long offset;\r\nstruct page *page;\r\nif (vmf->flags & (FAULT_FLAG_MKWRITE | FAULT_FLAG_WRITE))\r\nreturn VM_FAULT_SIGBUS;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nif (offset >= roundup(plm->len, PAGE_SIZE))\r\nreturn VM_FAULT_SIGBUS;\r\npage = vmalloc_to_page(plm->data + offset);\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic int sel_mmap_policy(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nif (vma->vm_flags & VM_SHARED) {\r\nvma->vm_flags &= ~VM_MAYWRITE;\r\nif (vma->vm_flags & VM_WRITE)\r\nreturn -EACCES;\r\n}\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_ops = &sel_mmap_policy_ops;\r\nreturn 0;\r\n}\r\nstatic ssize_t sel_write_load(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t length;\r\nvoid *data = NULL;\r\nmutex_lock(&sel_mutex);\r\nlength = task_has_security(current, SECURITY__LOAD_POLICY);\r\nif (length)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nlength = -EFBIG;\r\nif (count > 64 * 1024 * 1024)\r\ngoto out;\r\nlength = -ENOMEM;\r\ndata = vmalloc(count);\r\nif (!data)\r\ngoto out;\r\nlength = -EFAULT;\r\nif (copy_from_user(data, buf, count) != 0)\r\ngoto out;\r\nlength = security_load_policy(data, count);\r\nif (length)\r\ngoto out;\r\nlength = sel_make_bools();\r\nif (length)\r\ngoto out1;\r\nlength = sel_make_classes();\r\nif (length)\r\ngoto out1;\r\nlength = sel_make_policycap();\r\nif (length)\r\ngoto out1;\r\nlength = count;\r\nout1:\r\naudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_POLICY_LOAD,\r\n"policy loaded auid=%u ses=%u",\r\nfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\r\naudit_get_sessionid(current));\r\nout:\r\nmutex_unlock(&sel_mutex);\r\nvfree(data);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_write_context(struct file *file, char *buf, size_t size)\r\n{\r\nchar *canon = NULL;\r\nu32 sid, len;\r\nssize_t length;\r\nlength = task_has_security(current, SECURITY__CHECK_CONTEXT);\r\nif (length)\r\ngoto out;\r\nlength = security_context_to_sid(buf, size, &sid);\r\nif (length)\r\ngoto out;\r\nlength = security_sid_to_context(sid, &canon, &len);\r\nif (length)\r\ngoto out;\r\nlength = -ERANGE;\r\nif (len > SIMPLE_TRANSACTION_LIMIT) {\r\nprintk(KERN_ERR "SELinux: %s: context size (%u) exceeds "\r\n"payload max\n", __func__, len);\r\ngoto out;\r\n}\r\nmemcpy(buf, canon, len);\r\nlength = len;\r\nout:\r\nkfree(canon);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_read_checkreqprot(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%u", selinux_checkreqprot);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic ssize_t sel_write_checkreqprot(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t length;\r\nunsigned int new_value;\r\nlength = task_has_security(current, SECURITY__SETCHECKREQPROT);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nlength = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nlength = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(page, "%u", &new_value) != 1)\r\ngoto out;\r\nselinux_checkreqprot = new_value ? 1 : 0;\r\nlength = count;\r\nout:\r\nfree_page((unsigned long) page);\r\nreturn length;\r\n}\r\nstatic ssize_t selinux_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\r\n{\r\nino_t ino = file_inode(file)->i_ino;\r\nchar *data;\r\nssize_t rv;\r\nif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\r\nreturn -EINVAL;\r\ndata = simple_transaction_get(file, buf, size);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nrv = write_op[ino](file, data, size);\r\nif (rv > 0) {\r\nsimple_transaction_set(file, rv);\r\nrv = size;\r\n}\r\nreturn rv;\r\n}\r\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size)\r\n{\r\nchar *scon = NULL, *tcon = NULL;\r\nu32 ssid, tsid;\r\nu16 tclass;\r\nstruct av_decision avd;\r\nssize_t length;\r\nlength = task_has_security(current, SECURITY__COMPUTE_AV);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\nscon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!scon)\r\ngoto out;\r\nlength = -ENOMEM;\r\ntcon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!tcon)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(buf, "%s %s %hu", scon, tcon, &tclass) != 3)\r\ngoto out;\r\nlength = security_context_to_sid(scon, strlen(scon) + 1, &ssid);\r\nif (length)\r\ngoto out;\r\nlength = security_context_to_sid(tcon, strlen(tcon) + 1, &tsid);\r\nif (length)\r\ngoto out;\r\nsecurity_compute_av_user(ssid, tsid, tclass, &avd);\r\nlength = scnprintf(buf, SIMPLE_TRANSACTION_LIMIT,\r\n"%x %x %x %x %u %x",\r\navd.allowed, 0xffffffff,\r\navd.auditallow, avd.auditdeny,\r\navd.seqno, avd.flags);\r\nout:\r\nkfree(tcon);\r\nkfree(scon);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size)\r\n{\r\nchar *scon = NULL, *tcon = NULL;\r\nchar *namebuf = NULL, *objname = NULL;\r\nu32 ssid, tsid, newsid;\r\nu16 tclass;\r\nssize_t length;\r\nchar *newcon = NULL;\r\nu32 len;\r\nint nargs;\r\nlength = task_has_security(current, SECURITY__COMPUTE_CREATE);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\nscon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!scon)\r\ngoto out;\r\nlength = -ENOMEM;\r\ntcon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!tcon)\r\ngoto out;\r\nlength = -ENOMEM;\r\nnamebuf = kzalloc(size + 1, GFP_KERNEL);\r\nif (!namebuf)\r\ngoto out;\r\nlength = -EINVAL;\r\nnargs = sscanf(buf, "%s %s %hu %s", scon, tcon, &tclass, namebuf);\r\nif (nargs < 3 || nargs > 4)\r\ngoto out;\r\nif (nargs == 4) {\r\nchar *r, *w;\r\nint c1, c2;\r\nr = w = namebuf;\r\ndo {\r\nc1 = *r++;\r\nif (c1 == '+')\r\nc1 = ' ';\r\nelse if (c1 == '%') {\r\nc1 = hex_to_bin(*r++);\r\nif (c1 < 0)\r\ngoto out;\r\nc2 = hex_to_bin(*r++);\r\nif (c2 < 0)\r\ngoto out;\r\nc1 = (c1 << 4) | c2;\r\n}\r\n*w++ = c1;\r\n} while (c1 != '\0');\r\nobjname = namebuf;\r\n}\r\nlength = security_context_to_sid(scon, strlen(scon) + 1, &ssid);\r\nif (length)\r\ngoto out;\r\nlength = security_context_to_sid(tcon, strlen(tcon) + 1, &tsid);\r\nif (length)\r\ngoto out;\r\nlength = security_transition_sid_user(ssid, tsid, tclass,\r\nobjname, &newsid);\r\nif (length)\r\ngoto out;\r\nlength = security_sid_to_context(newsid, &newcon, &len);\r\nif (length)\r\ngoto out;\r\nlength = -ERANGE;\r\nif (len > SIMPLE_TRANSACTION_LIMIT) {\r\nprintk(KERN_ERR "SELinux: %s: context size (%u) exceeds "\r\n"payload max\n", __func__, len);\r\ngoto out;\r\n}\r\nmemcpy(buf, newcon, len);\r\nlength = len;\r\nout:\r\nkfree(newcon);\r\nkfree(namebuf);\r\nkfree(tcon);\r\nkfree(scon);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size)\r\n{\r\nchar *scon = NULL, *tcon = NULL;\r\nu32 ssid, tsid, newsid;\r\nu16 tclass;\r\nssize_t length;\r\nchar *newcon = NULL;\r\nu32 len;\r\nlength = task_has_security(current, SECURITY__COMPUTE_RELABEL);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\nscon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!scon)\r\ngoto out;\r\nlength = -ENOMEM;\r\ntcon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!tcon)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(buf, "%s %s %hu", scon, tcon, &tclass) != 3)\r\ngoto out;\r\nlength = security_context_to_sid(scon, strlen(scon) + 1, &ssid);\r\nif (length)\r\ngoto out;\r\nlength = security_context_to_sid(tcon, strlen(tcon) + 1, &tsid);\r\nif (length)\r\ngoto out;\r\nlength = security_change_sid(ssid, tsid, tclass, &newsid);\r\nif (length)\r\ngoto out;\r\nlength = security_sid_to_context(newsid, &newcon, &len);\r\nif (length)\r\ngoto out;\r\nlength = -ERANGE;\r\nif (len > SIMPLE_TRANSACTION_LIMIT)\r\ngoto out;\r\nmemcpy(buf, newcon, len);\r\nlength = len;\r\nout:\r\nkfree(newcon);\r\nkfree(tcon);\r\nkfree(scon);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size)\r\n{\r\nchar *con = NULL, *user = NULL, *ptr;\r\nu32 sid, *sids = NULL;\r\nssize_t length;\r\nchar *newcon;\r\nint i, rc;\r\nu32 len, nsids;\r\nlength = task_has_security(current, SECURITY__COMPUTE_USER);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\ncon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!con)\r\ngoto out;\r\nlength = -ENOMEM;\r\nuser = kzalloc(size + 1, GFP_KERNEL);\r\nif (!user)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(buf, "%s %s", con, user) != 2)\r\ngoto out;\r\nlength = security_context_to_sid(con, strlen(con) + 1, &sid);\r\nif (length)\r\ngoto out;\r\nlength = security_get_user_sids(sid, user, &sids, &nsids);\r\nif (length)\r\ngoto out;\r\nlength = sprintf(buf, "%u", nsids) + 1;\r\nptr = buf + length;\r\nfor (i = 0; i < nsids; i++) {\r\nrc = security_sid_to_context(sids[i], &newcon, &len);\r\nif (rc) {\r\nlength = rc;\r\ngoto out;\r\n}\r\nif ((length + len) >= SIMPLE_TRANSACTION_LIMIT) {\r\nkfree(newcon);\r\nlength = -ERANGE;\r\ngoto out;\r\n}\r\nmemcpy(ptr, newcon, len);\r\nkfree(newcon);\r\nptr += len;\r\nlength += len;\r\n}\r\nout:\r\nkfree(sids);\r\nkfree(user);\r\nkfree(con);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size)\r\n{\r\nchar *scon = NULL, *tcon = NULL;\r\nu32 ssid, tsid, newsid;\r\nu16 tclass;\r\nssize_t length;\r\nchar *newcon = NULL;\r\nu32 len;\r\nlength = task_has_security(current, SECURITY__COMPUTE_MEMBER);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\nscon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!scon)\r\ngoto out;\r\nlength = -ENOMEM;\r\ntcon = kzalloc(size + 1, GFP_KERNEL);\r\nif (!tcon)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(buf, "%s %s %hu", scon, tcon, &tclass) != 3)\r\ngoto out;\r\nlength = security_context_to_sid(scon, strlen(scon) + 1, &ssid);\r\nif (length)\r\ngoto out;\r\nlength = security_context_to_sid(tcon, strlen(tcon) + 1, &tsid);\r\nif (length)\r\ngoto out;\r\nlength = security_member_sid(ssid, tsid, tclass, &newsid);\r\nif (length)\r\ngoto out;\r\nlength = security_sid_to_context(newsid, &newcon, &len);\r\nif (length)\r\ngoto out;\r\nlength = -ERANGE;\r\nif (len > SIMPLE_TRANSACTION_LIMIT) {\r\nprintk(KERN_ERR "SELinux: %s: context size (%u) exceeds "\r\n"payload max\n", __func__, len);\r\ngoto out;\r\n}\r\nmemcpy(buf, newcon, len);\r\nlength = len;\r\nout:\r\nkfree(newcon);\r\nkfree(tcon);\r\nkfree(scon);\r\nreturn length;\r\n}\r\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\r\n{\r\nstruct inode *ret = new_inode(sb);\r\nif (ret) {\r\nret->i_mode = mode;\r\nret->i_atime = ret->i_mtime = ret->i_ctime = CURRENT_TIME;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t sel_read_bool(struct file *filep, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t length;\r\nssize_t ret;\r\nint cur_enforcing;\r\nunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\r\nconst char *name = filep->f_path.dentry->d_name.name;\r\nmutex_lock(&sel_mutex);\r\nret = -EINVAL;\r\nif (index >= bool_num || strcmp(name, bool_pending_names[index]))\r\ngoto out;\r\nret = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\ncur_enforcing = security_get_bool_value(index);\r\nif (cur_enforcing < 0) {\r\nret = cur_enforcing;\r\ngoto out;\r\n}\r\nlength = scnprintf(page, PAGE_SIZE, "%d %d", cur_enforcing,\r\nbool_pending_values[index]);\r\nret = simple_read_from_buffer(buf, count, ppos, page, length);\r\nout:\r\nmutex_unlock(&sel_mutex);\r\nfree_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic ssize_t sel_write_bool(struct file *filep, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t length;\r\nint new_value;\r\nunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\r\nconst char *name = filep->f_path.dentry->d_name.name;\r\nmutex_lock(&sel_mutex);\r\nlength = task_has_security(current, SECURITY__SETBOOL);\r\nif (length)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (index >= bool_num || strcmp(name, bool_pending_names[index]))\r\ngoto out;\r\nlength = -ENOMEM;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nlength = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nlength = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(page, "%d", &new_value) != 1)\r\ngoto out;\r\nif (new_value)\r\nnew_value = 1;\r\nbool_pending_values[index] = new_value;\r\nlength = count;\r\nout:\r\nmutex_unlock(&sel_mutex);\r\nfree_page((unsigned long) page);\r\nreturn length;\r\n}\r\nstatic ssize_t sel_commit_bools_write(struct file *filep,\r\nconst char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t length;\r\nint new_value;\r\nmutex_lock(&sel_mutex);\r\nlength = task_has_security(current, SECURITY__SETBOOL);\r\nif (length)\r\ngoto out;\r\nlength = -ENOMEM;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nlength = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nlength = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nlength = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nlength = -EINVAL;\r\nif (sscanf(page, "%d", &new_value) != 1)\r\ngoto out;\r\nlength = 0;\r\nif (new_value && bool_pending_values)\r\nlength = security_set_bools(bool_num, bool_pending_values);\r\nif (!length)\r\nlength = count;\r\nout:\r\nmutex_unlock(&sel_mutex);\r\nfree_page((unsigned long) page);\r\nreturn length;\r\n}\r\nstatic void sel_remove_entries(struct dentry *de)\r\n{\r\nstruct list_head *node;\r\nspin_lock(&de->d_lock);\r\nnode = de->d_subdirs.next;\r\nwhile (node != &de->d_subdirs) {\r\nstruct dentry *d = list_entry(node, struct dentry, d_u.d_child);\r\nspin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);\r\nlist_del_init(node);\r\nif (d->d_inode) {\r\ndget_dlock(d);\r\nspin_unlock(&de->d_lock);\r\nspin_unlock(&d->d_lock);\r\nd_delete(d);\r\nsimple_unlink(de->d_inode, d);\r\ndput(d);\r\nspin_lock(&de->d_lock);\r\n} else\r\nspin_unlock(&d->d_lock);\r\nnode = de->d_subdirs.next;\r\n}\r\nspin_unlock(&de->d_lock);\r\n}\r\nstatic int sel_make_bools(void)\r\n{\r\nint i, ret;\r\nssize_t len;\r\nstruct dentry *dentry = NULL;\r\nstruct dentry *dir = bool_dir;\r\nstruct inode *inode = NULL;\r\nstruct inode_security_struct *isec;\r\nchar **names = NULL, *page;\r\nint num;\r\nint *values = NULL;\r\nu32 sid;\r\nfor (i = 0; i < bool_num; i++)\r\nkfree(bool_pending_names[i]);\r\nkfree(bool_pending_names);\r\nkfree(bool_pending_values);\r\nbool_num = 0;\r\nbool_pending_names = NULL;\r\nbool_pending_values = NULL;\r\nsel_remove_entries(dir);\r\nret = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nret = security_get_bools(&num, &names, &values);\r\nif (ret)\r\ngoto out;\r\nfor (i = 0; i < num; i++) {\r\nret = -ENOMEM;\r\ndentry = d_alloc_name(dir, names[i]);\r\nif (!dentry)\r\ngoto out;\r\nret = -ENOMEM;\r\ninode = sel_make_inode(dir->d_sb, S_IFREG | S_IRUGO | S_IWUSR);\r\nif (!inode)\r\ngoto out;\r\nret = -ENAMETOOLONG;\r\nlen = snprintf(page, PAGE_SIZE, "/%s/%s", BOOL_DIR_NAME, names[i]);\r\nif (len >= PAGE_SIZE)\r\ngoto out;\r\nisec = (struct inode_security_struct *)inode->i_security;\r\nret = security_genfs_sid("selinuxfs", page, SECCLASS_FILE, &sid);\r\nif (ret)\r\ngoto out;\r\nisec->sid = sid;\r\nisec->initialized = 1;\r\ninode->i_fop = &sel_bool_ops;\r\ninode->i_ino = i|SEL_BOOL_INO_OFFSET;\r\nd_add(dentry, inode);\r\n}\r\nbool_num = num;\r\nbool_pending_names = names;\r\nbool_pending_values = values;\r\nfree_page((unsigned long)page);\r\nreturn 0;\r\nout:\r\nfree_page((unsigned long)page);\r\nif (names) {\r\nfor (i = 0; i < num; i++)\r\nkfree(names[i]);\r\nkfree(names);\r\n}\r\nkfree(values);\r\nsel_remove_entries(dir);\r\nreturn ret;\r\n}\r\nstatic ssize_t sel_read_avc_cache_threshold(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%u", avc_cache_threshold);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic ssize_t sel_write_avc_cache_threshold(struct file *file,\r\nconst char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page = NULL;\r\nssize_t ret;\r\nint new_value;\r\nret = task_has_security(current, SECURITY__SETSECPARAM);\r\nif (ret)\r\ngoto out;\r\nret = -ENOMEM;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nret = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nret = -ENOMEM;\r\npage = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nret = -EINVAL;\r\nif (sscanf(page, "%u", &new_value) != 1)\r\ngoto out;\r\navc_cache_threshold = new_value;\r\nret = count;\r\nout:\r\nfree_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic ssize_t sel_read_avc_hash_stats(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *page;\r\nssize_t length;\r\npage = (char *)__get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlength = avc_get_hash_stats(page);\r\nif (length >= 0)\r\nlength = simple_read_from_buffer(buf, count, ppos, page, length);\r\nfree_page((unsigned long)page);\r\nreturn length;\r\n}\r\nstatic struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\r\n{\r\nint cpu;\r\nfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*idx = cpu + 1;\r\nreturn &per_cpu(avc_cache_stats, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *sel_avc_stats_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nloff_t n = *pos - 1;\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nreturn sel_avc_get_stat_idx(&n);\r\n}\r\nstatic void *sel_avc_stats_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn sel_avc_get_stat_idx(pos);\r\n}\r\nstatic int sel_avc_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct avc_cache_stats *st = v;\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "lookups hits misses allocations reclaims "\r\n"frees\n");\r\nelse {\r\nunsigned int lookups = st->lookups;\r\nunsigned int misses = st->misses;\r\nunsigned int hits = lookups - misses;\r\nseq_printf(seq, "%u %u %u %u %u %u\n", lookups,\r\nhits, misses, st->allocations,\r\nst->reclaims, st->frees);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sel_avc_stats_seq_stop(struct seq_file *seq, void *v)\r\n{ }\r\nstatic int sel_open_avc_cache_stats(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &sel_avc_cache_stats_seq_ops);\r\n}\r\nstatic int sel_make_avc_files(struct dentry *dir)\r\n{\r\nint i;\r\nstatic struct tree_descr files[] = {\r\n{ "cache_threshold",\r\n&sel_avc_cache_threshold_ops, S_IRUGO|S_IWUSR },\r\n{ "hash_stats", &sel_avc_hash_stats_ops, S_IRUGO },\r\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\r\n{ "cache_stats", &sel_avc_cache_stats_ops, S_IRUGO },\r\n#endif\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(files); i++) {\r\nstruct inode *inode;\r\nstruct dentry *dentry;\r\ndentry = d_alloc_name(dir, files[i].name);\r\nif (!dentry)\r\nreturn -ENOMEM;\r\ninode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\r\nif (!inode)\r\nreturn -ENOMEM;\r\ninode->i_fop = files[i].ops;\r\ninode->i_ino = ++sel_last_ino;\r\nd_add(dentry, inode);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t sel_read_initcon(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *con;\r\nu32 sid, len;\r\nssize_t ret;\r\nsid = file_inode(file)->i_ino&SEL_INO_MASK;\r\nret = security_sid_to_context(sid, &con, &len);\r\nif (ret)\r\nreturn ret;\r\nret = simple_read_from_buffer(buf, count, ppos, con, len);\r\nkfree(con);\r\nreturn ret;\r\n}\r\nstatic int sel_make_initcon_files(struct dentry *dir)\r\n{\r\nint i;\r\nfor (i = 1; i <= SECINITSID_NUM; i++) {\r\nstruct inode *inode;\r\nstruct dentry *dentry;\r\ndentry = d_alloc_name(dir, security_get_initial_sid_context(i));\r\nif (!dentry)\r\nreturn -ENOMEM;\r\ninode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\r\nif (!inode)\r\nreturn -ENOMEM;\r\ninode->i_fop = &sel_initcon_ops;\r\ninode->i_ino = i|SEL_INITCON_INO_OFFSET;\r\nd_add(dentry, inode);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned long sel_class_to_ino(u16 class)\r\n{\r\nreturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\r\n}\r\nstatic inline u16 sel_ino_to_class(unsigned long ino)\r\n{\r\nreturn (ino & SEL_INO_MASK) / (SEL_VEC_MAX + 1);\r\n}\r\nstatic inline unsigned long sel_perm_to_ino(u16 class, u32 perm)\r\n{\r\nreturn (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;\r\n}\r\nstatic inline u32 sel_ino_to_perm(unsigned long ino)\r\n{\r\nreturn (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);\r\n}\r\nstatic ssize_t sel_read_class(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long ino = file_inode(file)->i_ino;\r\nchar res[TMPBUFLEN];\r\nssize_t len = snprintf(res, sizeof(res), "%d", sel_ino_to_class(ino));\r\nreturn simple_read_from_buffer(buf, count, ppos, res, len);\r\n}\r\nstatic ssize_t sel_read_perm(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long ino = file_inode(file)->i_ino;\r\nchar res[TMPBUFLEN];\r\nssize_t len = snprintf(res, sizeof(res), "%d", sel_ino_to_perm(ino));\r\nreturn simple_read_from_buffer(buf, count, ppos, res, len);\r\n}\r\nstatic ssize_t sel_read_policycap(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint value;\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t length;\r\nunsigned long i_ino = file_inode(file)->i_ino;\r\nvalue = security_policycap_supported(i_ino & SEL_INO_MASK);\r\nlength = scnprintf(tmpbuf, TMPBUFLEN, "%d", value);\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\r\n}\r\nstatic int sel_make_perm_files(char *objclass, int classvalue,\r\nstruct dentry *dir)\r\n{\r\nint i, rc, nperms;\r\nchar **perms;\r\nrc = security_get_permissions(objclass, &perms, &nperms);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < nperms; i++) {\r\nstruct inode *inode;\r\nstruct dentry *dentry;\r\nrc = -ENOMEM;\r\ndentry = d_alloc_name(dir, perms[i]);\r\nif (!dentry)\r\ngoto out;\r\nrc = -ENOMEM;\r\ninode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\r\nif (!inode)\r\ngoto out;\r\ninode->i_fop = &sel_perm_ops;\r\ninode->i_ino = sel_perm_to_ino(classvalue, i + 1);\r\nd_add(dentry, inode);\r\n}\r\nrc = 0;\r\nout:\r\nfor (i = 0; i < nperms; i++)\r\nkfree(perms[i]);\r\nkfree(perms);\r\nreturn rc;\r\n}\r\nstatic int sel_make_class_dir_entries(char *classname, int index,\r\nstruct dentry *dir)\r\n{\r\nstruct dentry *dentry = NULL;\r\nstruct inode *inode = NULL;\r\nint rc;\r\ndentry = d_alloc_name(dir, "index");\r\nif (!dentry)\r\nreturn -ENOMEM;\r\ninode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\r\nif (!inode)\r\nreturn -ENOMEM;\r\ninode->i_fop = &sel_class_ops;\r\ninode->i_ino = sel_class_to_ino(index);\r\nd_add(dentry, inode);\r\ndentry = sel_make_dir(dir, "perms", &last_class_ino);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nrc = sel_make_perm_files(classname, index, dentry);\r\nreturn rc;\r\n}\r\nstatic void sel_remove_classes(void)\r\n{\r\nstruct list_head *class_node;\r\nlist_for_each(class_node, &class_dir->d_subdirs) {\r\nstruct dentry *class_subdir = list_entry(class_node,\r\nstruct dentry, d_u.d_child);\r\nstruct list_head *class_subdir_node;\r\nlist_for_each(class_subdir_node, &class_subdir->d_subdirs) {\r\nstruct dentry *d = list_entry(class_subdir_node,\r\nstruct dentry, d_u.d_child);\r\nif (d->d_inode)\r\nif (d->d_inode->i_mode & S_IFDIR)\r\nsel_remove_entries(d);\r\n}\r\nsel_remove_entries(class_subdir);\r\n}\r\nsel_remove_entries(class_dir);\r\n}\r\nstatic int sel_make_classes(void)\r\n{\r\nint rc, nclasses, i;\r\nchar **classes;\r\nsel_remove_classes();\r\nrc = security_get_classes(&classes, &nclasses);\r\nif (rc)\r\nreturn rc;\r\nlast_class_ino = sel_class_to_ino(nclasses + 2);\r\nfor (i = 0; i < nclasses; i++) {\r\nstruct dentry *class_name_dir;\r\nclass_name_dir = sel_make_dir(class_dir, classes[i],\r\n&last_class_ino);\r\nif (IS_ERR(class_name_dir)) {\r\nrc = PTR_ERR(class_name_dir);\r\ngoto out;\r\n}\r\nrc = sel_make_class_dir_entries(classes[i], i + 1,\r\nclass_name_dir);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nfor (i = 0; i < nclasses; i++)\r\nkfree(classes[i]);\r\nkfree(classes);\r\nreturn rc;\r\n}\r\nstatic int sel_make_policycap(void)\r\n{\r\nunsigned int iter;\r\nstruct dentry *dentry = NULL;\r\nstruct inode *inode = NULL;\r\nsel_remove_entries(policycap_dir);\r\nfor (iter = 0; iter <= POLICYDB_CAPABILITY_MAX; iter++) {\r\nif (iter < ARRAY_SIZE(policycap_names))\r\ndentry = d_alloc_name(policycap_dir,\r\npolicycap_names[iter]);\r\nelse\r\ndentry = d_alloc_name(policycap_dir, "unknown");\r\nif (dentry == NULL)\r\nreturn -ENOMEM;\r\ninode = sel_make_inode(policycap_dir->d_sb, S_IFREG | S_IRUGO);\r\nif (inode == NULL)\r\nreturn -ENOMEM;\r\ninode->i_fop = &sel_policycap_ops;\r\ninode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;\r\nd_add(dentry, inode);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\r\nunsigned long *ino)\r\n{\r\nstruct dentry *dentry = d_alloc_name(dir, name);\r\nstruct inode *inode;\r\nif (!dentry)\r\nreturn ERR_PTR(-ENOMEM);\r\ninode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\r\nif (!inode) {\r\ndput(dentry);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninode->i_op = &simple_dir_inode_operations;\r\ninode->i_fop = &simple_dir_operations;\r\ninode->i_ino = ++(*ino);\r\ninc_nlink(inode);\r\nd_add(dentry, inode);\r\ninc_nlink(dir->d_inode);\r\nreturn dentry;\r\n}\r\nstatic int sel_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nint ret;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nstruct inode_security_struct *isec;\r\nstatic struct tree_descr selinux_files[] = {\r\n[SEL_LOAD] = {"load", &sel_load_ops, S_IRUSR|S_IWUSR},\r\n[SEL_ENFORCE] = {"enforce", &sel_enforce_ops, S_IRUGO|S_IWUSR},\r\n[SEL_CONTEXT] = {"context", &transaction_ops, S_IRUGO|S_IWUGO},\r\n[SEL_ACCESS] = {"access", &transaction_ops, S_IRUGO|S_IWUGO},\r\n[SEL_CREATE] = {"create", &transaction_ops, S_IRUGO|S_IWUGO},\r\n[SEL_RELABEL] = {"relabel", &transaction_ops, S_IRUGO|S_IWUGO},\r\n[SEL_USER] = {"user", &transaction_ops, S_IRUGO|S_IWUGO},\r\n[SEL_POLICYVERS] = {"policyvers", &sel_policyvers_ops, S_IRUGO},\r\n[SEL_COMMIT_BOOLS] = {"commit_pending_bools", &sel_commit_bools_ops, S_IWUSR},\r\n[SEL_MLS] = {"mls", &sel_mls_ops, S_IRUGO},\r\n[SEL_DISABLE] = {"disable", &sel_disable_ops, S_IWUSR},\r\n[SEL_MEMBER] = {"member", &transaction_ops, S_IRUGO|S_IWUGO},\r\n[SEL_CHECKREQPROT] = {"checkreqprot", &sel_checkreqprot_ops, S_IRUGO|S_IWUSR},\r\n[SEL_REJECT_UNKNOWN] = {"reject_unknown", &sel_handle_unknown_ops, S_IRUGO},\r\n[SEL_DENY_UNKNOWN] = {"deny_unknown", &sel_handle_unknown_ops, S_IRUGO},\r\n[SEL_STATUS] = {"status", &sel_handle_status_ops, S_IRUGO},\r\n[SEL_POLICY] = {"policy", &sel_policy_ops, S_IRUGO},\r\n{""}\r\n};\r\nret = simple_fill_super(sb, SELINUX_MAGIC, selinux_files);\r\nif (ret)\r\ngoto err;\r\nbool_dir = sel_make_dir(sb->s_root, BOOL_DIR_NAME, &sel_last_ino);\r\nif (IS_ERR(bool_dir)) {\r\nret = PTR_ERR(bool_dir);\r\nbool_dir = NULL;\r\ngoto err;\r\n}\r\nret = -ENOMEM;\r\ndentry = d_alloc_name(sb->s_root, NULL_FILE_NAME);\r\nif (!dentry)\r\ngoto err;\r\nret = -ENOMEM;\r\ninode = sel_make_inode(sb, S_IFCHR | S_IRUGO | S_IWUGO);\r\nif (!inode)\r\ngoto err;\r\ninode->i_ino = ++sel_last_ino;\r\nisec = (struct inode_security_struct *)inode->i_security;\r\nisec->sid = SECINITSID_DEVNULL;\r\nisec->sclass = SECCLASS_CHR_FILE;\r\nisec->initialized = 1;\r\ninit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO, MKDEV(MEM_MAJOR, 3));\r\nd_add(dentry, inode);\r\nselinux_null.dentry = dentry;\r\ndentry = sel_make_dir(sb->s_root, "avc", &sel_last_ino);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto err;\r\n}\r\nret = sel_make_avc_files(dentry);\r\nif (ret)\r\ngoto err;\r\ndentry = sel_make_dir(sb->s_root, "initial_contexts", &sel_last_ino);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto err;\r\n}\r\nret = sel_make_initcon_files(dentry);\r\nif (ret)\r\ngoto err;\r\nclass_dir = sel_make_dir(sb->s_root, "class", &sel_last_ino);\r\nif (IS_ERR(class_dir)) {\r\nret = PTR_ERR(class_dir);\r\nclass_dir = NULL;\r\ngoto err;\r\n}\r\npolicycap_dir = sel_make_dir(sb->s_root, "policy_capabilities", &sel_last_ino);\r\nif (IS_ERR(policycap_dir)) {\r\nret = PTR_ERR(policycap_dir);\r\npolicycap_dir = NULL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nprintk(KERN_ERR "SELinux: %s: failed while creating inodes\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic struct dentry *sel_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_single(fs_type, flags, data, sel_fill_super);\r\n}\r\nstatic int __init init_sel_fs(void)\r\n{\r\nint err;\r\nif (!selinux_enabled)\r\nreturn 0;\r\nselinuxfs_kobj = kobject_create_and_add("selinux", fs_kobj);\r\nif (!selinuxfs_kobj)\r\nreturn -ENOMEM;\r\nerr = register_filesystem(&sel_fs_type);\r\nif (err) {\r\nkobject_put(selinuxfs_kobj);\r\nreturn err;\r\n}\r\nselinux_null.mnt = selinuxfs_mount = kern_mount(&sel_fs_type);\r\nif (IS_ERR(selinuxfs_mount)) {\r\nprintk(KERN_ERR "selinuxfs: could not mount!\n");\r\nerr = PTR_ERR(selinuxfs_mount);\r\nselinuxfs_mount = NULL;\r\n}\r\nreturn err;\r\n}\r\nvoid exit_sel_fs(void)\r\n{\r\nkobject_put(selinuxfs_kobj);\r\nkern_unmount(selinuxfs_mount);\r\nunregister_filesystem(&sel_fs_type);\r\n}
