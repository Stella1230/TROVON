static int write_acpi_int(acpi_handle handle, const char *method, int val)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nacpi_status status;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = val;\r\nstatus = acpi_evaluate_object(handle, (char *)method, &params, NULL);\r\nreturn (status == AE_OK ? 0 : -1);\r\n}\r\nstatic int read_acpi_int(acpi_handle handle, const char *method, int *val)\r\n{\r\nacpi_status status;\r\nunsigned long long result;\r\nstatus = acpi_evaluate_integer(handle, (char *)method, NULL, &result);\r\nif (ACPI_FAILURE(status)) {\r\n*val = -1;\r\nreturn -1;\r\n} else {\r\n*val = result;\r\nreturn 0;\r\n}\r\n}\r\nstatic int set_acpi(struct eeepc_laptop *eeepc, int cm, int value)\r\n{\r\nconst char *method = cm_setv[cm];\r\nif (method == NULL)\r\nreturn -ENODEV;\r\nif ((eeepc->cm_supported & (0x1 << cm)) == 0)\r\nreturn -ENODEV;\r\nif (write_acpi_int(eeepc->handle, method, value))\r\npr_warn("Error writing %s\n", method);\r\nreturn 0;\r\n}\r\nstatic int get_acpi(struct eeepc_laptop *eeepc, int cm)\r\n{\r\nconst char *method = cm_getv[cm];\r\nint value;\r\nif (method == NULL)\r\nreturn -ENODEV;\r\nif ((eeepc->cm_supported & (0x1 << cm)) == 0)\r\nreturn -ENODEV;\r\nif (read_acpi_int(eeepc->handle, method, &value))\r\npr_warn("Error reading %s\n", method);\r\nreturn value;\r\n}\r\nstatic int acpi_setter_handle(struct eeepc_laptop *eeepc, int cm,\r\nacpi_handle *handle)\r\n{\r\nconst char *method = cm_setv[cm];\r\nacpi_status status;\r\nif (method == NULL)\r\nreturn -ENODEV;\r\nif ((eeepc->cm_supported & (0x1 << cm)) == 0)\r\nreturn -ENODEV;\r\nstatus = acpi_get_handle(eeepc->handle, (char *)method,\r\nhandle);\r\nif (status != AE_OK) {\r\npr_warn("Error finding %s\n", method);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_arg(const char *buf, unsigned long count, int *val)\r\n{\r\nif (!count)\r\nreturn 0;\r\nif (sscanf(buf, "%i", val) != 1)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t store_sys_acpi(struct device *dev, int cm,\r\nconst char *buf, size_t count)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nint rv, value;\r\nrv = parse_arg(buf, count, &value);\r\nif (rv > 0)\r\nvalue = set_acpi(eeepc, cm, value);\r\nif (value < 0)\r\nreturn -EIO;\r\nreturn rv;\r\n}\r\nstatic ssize_t show_sys_acpi(struct device *dev, int cm, char *buf)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nint value = get_acpi(eeepc, cm);\r\nif (value < 0)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic int get_cpufv(struct eeepc_laptop *eeepc, struct eeepc_cpufv *c)\r\n{\r\nc->cur = get_acpi(eeepc, CM_ASL_CPUFV);\r\nc->num = (c->cur >> 8) & 0xff;\r\nc->cur &= 0xff;\r\nif (c->cur < 0 || c->num <= 0 || c->num > 12)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_available_cpufv(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nstruct eeepc_cpufv c;\r\nint i;\r\nssize_t len = 0;\r\nif (get_cpufv(eeepc, &c))\r\nreturn -ENODEV;\r\nfor (i = 0; i < c.num; i++)\r\nlen += sprintf(buf + len, "%d ", i);\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t show_cpufv(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nstruct eeepc_cpufv c;\r\nif (get_cpufv(eeepc, &c))\r\nreturn -ENODEV;\r\nreturn sprintf(buf, "%#x\n", (c.num << 8) | c.cur);\r\n}\r\nstatic ssize_t store_cpufv(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nstruct eeepc_cpufv c;\r\nint rv, value;\r\nif (eeepc->cpufv_disabled)\r\nreturn -EPERM;\r\nif (get_cpufv(eeepc, &c))\r\nreturn -ENODEV;\r\nrv = parse_arg(buf, count, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nif (!rv || value < 0 || value >= c.num)\r\nreturn -EINVAL;\r\nset_acpi(eeepc, CM_ASL_CPUFV, value);\r\nreturn rv;\r\n}\r\nstatic ssize_t show_cpufv_disabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", eeepc->cpufv_disabled);\r\n}\r\nstatic ssize_t store_cpufv_disabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\r\nint rv, value;\r\nrv = parse_arg(buf, count, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nswitch (value) {\r\ncase 0:\r\nif (eeepc->cpufv_disabled)\r\npr_warn("cpufv enabled (not officially supported "\r\n"on this model)\n");\r\neeepc->cpufv_disabled = false;\r\nreturn rv;\r\ncase 1:\r\nreturn -EPERM;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int eeepc_platform_init(struct eeepc_laptop *eeepc)\r\n{\r\nint result;\r\neeepc->platform_device = platform_device_alloc(EEEPC_LAPTOP_FILE, -1);\r\nif (!eeepc->platform_device)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(eeepc->platform_device, eeepc);\r\nresult = platform_device_add(eeepc->platform_device);\r\nif (result)\r\ngoto fail_platform_device;\r\nresult = sysfs_create_group(&eeepc->platform_device->dev.kobj,\r\n&platform_attribute_group);\r\nif (result)\r\ngoto fail_sysfs;\r\nreturn 0;\r\nfail_sysfs:\r\nplatform_device_del(eeepc->platform_device);\r\nfail_platform_device:\r\nplatform_device_put(eeepc->platform_device);\r\nreturn result;\r\n}\r\nstatic void eeepc_platform_exit(struct eeepc_laptop *eeepc)\r\n{\r\nsysfs_remove_group(&eeepc->platform_device->dev.kobj,\r\n&platform_attribute_group);\r\nplatform_device_unregister(eeepc->platform_device);\r\n}\r\nstatic void tpd_led_update(struct work_struct *work)\r\n{\r\nstruct eeepc_laptop *eeepc;\r\neeepc = container_of(work, struct eeepc_laptop, tpd_led_work);\r\nset_acpi(eeepc, CM_ASL_TPD, eeepc->tpd_led_wk);\r\n}\r\nstatic void tpd_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct eeepc_laptop *eeepc;\r\neeepc = container_of(led_cdev, struct eeepc_laptop, tpd_led);\r\neeepc->tpd_led_wk = (value > 0) ? 1 : 0;\r\nqueue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);\r\n}\r\nstatic enum led_brightness tpd_led_get(struct led_classdev *led_cdev)\r\n{\r\nstruct eeepc_laptop *eeepc;\r\neeepc = container_of(led_cdev, struct eeepc_laptop, tpd_led);\r\nreturn get_acpi(eeepc, CM_ASL_TPD);\r\n}\r\nstatic int eeepc_led_init(struct eeepc_laptop *eeepc)\r\n{\r\nint rv;\r\nif (get_acpi(eeepc, CM_ASL_TPD) == -ENODEV)\r\nreturn 0;\r\neeepc->led_workqueue = create_singlethread_workqueue("led_workqueue");\r\nif (!eeepc->led_workqueue)\r\nreturn -ENOMEM;\r\nINIT_WORK(&eeepc->tpd_led_work, tpd_led_update);\r\neeepc->tpd_led.name = "eeepc::touchpad";\r\neeepc->tpd_led.brightness_set = tpd_led_set;\r\nif (get_acpi(eeepc, CM_ASL_TPD) >= 0)\r\neeepc->tpd_led.brightness_get = tpd_led_get;\r\neeepc->tpd_led.max_brightness = 1;\r\nrv = led_classdev_register(&eeepc->platform_device->dev,\r\n&eeepc->tpd_led);\r\nif (rv) {\r\ndestroy_workqueue(eeepc->led_workqueue);\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic void eeepc_led_exit(struct eeepc_laptop *eeepc)\r\n{\r\nif (!IS_ERR_OR_NULL(eeepc->tpd_led.dev))\r\nled_classdev_unregister(&eeepc->tpd_led);\r\nif (eeepc->led_workqueue)\r\ndestroy_workqueue(eeepc->led_workqueue);\r\n}\r\nstatic bool eeepc_wlan_rfkill_blocked(struct eeepc_laptop *eeepc)\r\n{\r\nif (get_acpi(eeepc, CM_ASL_WLAN) == 1)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void eeepc_rfkill_hotplug(struct eeepc_laptop *eeepc, acpi_handle handle)\r\n{\r\nstruct pci_dev *port;\r\nstruct pci_dev *dev;\r\nstruct pci_bus *bus;\r\nbool blocked = eeepc_wlan_rfkill_blocked(eeepc);\r\nbool absent;\r\nu32 l;\r\nif (eeepc->wlan_rfkill)\r\nrfkill_set_sw_state(eeepc->wlan_rfkill, blocked);\r\nmutex_lock(&eeepc->hotplug_lock);\r\nif (eeepc->hotplug_slot) {\r\nport = acpi_get_pci_dev(handle);\r\nif (!port) {\r\npr_warning("Unable to find port\n");\r\ngoto out_unlock;\r\n}\r\nbus = port->subordinate;\r\nif (!bus) {\r\npr_warn("Unable to find PCI bus 1?\n");\r\ngoto out_put_dev;\r\n}\r\nif (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {\r\npr_err("Unable to read PCI config space?\n");\r\ngoto out_put_dev;\r\n}\r\nabsent = (l == 0xffffffff);\r\nif (blocked != absent) {\r\npr_warn("BIOS says wireless lan is %s, "\r\n"but the pci device is %s\n",\r\nblocked ? "blocked" : "unblocked",\r\nabsent ? "absent" : "present");\r\npr_warn("skipped wireless hotplug as probably "\r\n"inappropriate for this model\n");\r\ngoto out_put_dev;\r\n}\r\nif (!blocked) {\r\ndev = pci_get_slot(bus, 0);\r\nif (dev) {\r\npci_dev_put(dev);\r\ngoto out_put_dev;\r\n}\r\ndev = pci_scan_single_device(bus, 0);\r\nif (dev) {\r\npci_bus_assign_resources(bus);\r\nif (pci_bus_add_device(dev))\r\npr_err("Unable to hotplug wifi\n");\r\n}\r\n} else {\r\ndev = pci_get_slot(bus, 0);\r\nif (dev) {\r\npci_stop_and_remove_bus_device(dev);\r\npci_dev_put(dev);\r\n}\r\n}\r\nout_put_dev:\r\npci_dev_put(port);\r\n}\r\nout_unlock:\r\nmutex_unlock(&eeepc->hotplug_lock);\r\n}\r\nstatic void eeepc_rfkill_hotplug_update(struct eeepc_laptop *eeepc, char *node)\r\n{\r\nacpi_status status = AE_OK;\r\nacpi_handle handle;\r\nstatus = acpi_get_handle(NULL, node, &handle);\r\nif (ACPI_SUCCESS(status))\r\neeepc_rfkill_hotplug(eeepc, handle);\r\n}\r\nstatic void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct eeepc_laptop *eeepc = data;\r\nif (event != ACPI_NOTIFY_BUS_CHECK)\r\nreturn;\r\neeepc_rfkill_hotplug(eeepc, handle);\r\n}\r\nstatic int eeepc_register_rfkill_notifier(struct eeepc_laptop *eeepc,\r\nchar *node)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nstatus = acpi_get_handle(NULL, node, &handle);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_install_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\neeepc_rfkill_notify,\r\neeepc);\r\nif (ACPI_FAILURE(status))\r\npr_warn("Failed to register notify on %s\n", node);\r\neeepc_rfkill_hotplug(eeepc, handle);\r\n} else\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void eeepc_unregister_rfkill_notifier(struct eeepc_laptop *eeepc,\r\nchar *node)\r\n{\r\nacpi_status status = AE_OK;\r\nacpi_handle handle;\r\nstatus = acpi_get_handle(NULL, node, &handle);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_remove_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\neeepc_rfkill_notify);\r\nif (ACPI_FAILURE(status))\r\npr_err("Error removing rfkill notify handler %s\n",\r\nnode);\r\neeepc_rfkill_hotplug(eeepc, handle);\r\n}\r\n}\r\nstatic int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,\r\nu8 *value)\r\n{\r\nstruct eeepc_laptop *eeepc = hotplug_slot->private;\r\nint val = get_acpi(eeepc, CM_ASL_WLAN);\r\nif (val == 1 || val == 0)\r\n*value = val;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void eeepc_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)\r\n{\r\nkfree(hotplug_slot->info);\r\nkfree(hotplug_slot);\r\n}\r\nstatic int eeepc_setup_pci_hotplug(struct eeepc_laptop *eeepc)\r\n{\r\nint ret = -ENOMEM;\r\nstruct pci_bus *bus = pci_find_bus(0, 1);\r\nif (!bus) {\r\npr_err("Unable to find wifi PCI bus\n");\r\nreturn -ENODEV;\r\n}\r\neeepc->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);\r\nif (!eeepc->hotplug_slot)\r\ngoto error_slot;\r\neeepc->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),\r\nGFP_KERNEL);\r\nif (!eeepc->hotplug_slot->info)\r\ngoto error_info;\r\neeepc->hotplug_slot->private = eeepc;\r\neeepc->hotplug_slot->release = &eeepc_cleanup_pci_hotplug;\r\neeepc->hotplug_slot->ops = &eeepc_hotplug_slot_ops;\r\neeepc_get_adapter_status(eeepc->hotplug_slot,\r\n&eeepc->hotplug_slot->info->adapter_status);\r\nret = pci_hp_register(eeepc->hotplug_slot, bus, 0, "eeepc-wifi");\r\nif (ret) {\r\npr_err("Unable to register hotplug slot - %d\n", ret);\r\ngoto error_register;\r\n}\r\nreturn 0;\r\nerror_register:\r\nkfree(eeepc->hotplug_slot->info);\r\nerror_info:\r\nkfree(eeepc->hotplug_slot);\r\neeepc->hotplug_slot = NULL;\r\nerror_slot:\r\nreturn ret;\r\n}\r\nstatic int eeepc_rfkill_set(void *data, bool blocked)\r\n{\r\nacpi_handle handle = data;\r\nreturn write_acpi_int(handle, NULL, !blocked);\r\n}\r\nstatic int eeepc_new_rfkill(struct eeepc_laptop *eeepc,\r\nstruct rfkill **rfkill,\r\nconst char *name,\r\nenum rfkill_type type, int cm)\r\n{\r\nacpi_handle handle;\r\nint result;\r\nresult = acpi_setter_handle(eeepc, cm, &handle);\r\nif (result < 0)\r\nreturn result;\r\n*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,\r\n&eeepc_rfkill_ops, handle);\r\nif (!*rfkill)\r\nreturn -EINVAL;\r\nrfkill_init_sw_state(*rfkill, get_acpi(eeepc, cm) != 1);\r\nresult = rfkill_register(*rfkill);\r\nif (result) {\r\nrfkill_destroy(*rfkill);\r\n*rfkill = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void eeepc_rfkill_exit(struct eeepc_laptop *eeepc)\r\n{\r\neeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");\r\neeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");\r\neeepc_unregister_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");\r\nif (eeepc->wlan_rfkill) {\r\nrfkill_unregister(eeepc->wlan_rfkill);\r\nrfkill_destroy(eeepc->wlan_rfkill);\r\neeepc->wlan_rfkill = NULL;\r\n}\r\nif (eeepc->hotplug_slot)\r\npci_hp_deregister(eeepc->hotplug_slot);\r\nif (eeepc->bluetooth_rfkill) {\r\nrfkill_unregister(eeepc->bluetooth_rfkill);\r\nrfkill_destroy(eeepc->bluetooth_rfkill);\r\neeepc->bluetooth_rfkill = NULL;\r\n}\r\nif (eeepc->wwan3g_rfkill) {\r\nrfkill_unregister(eeepc->wwan3g_rfkill);\r\nrfkill_destroy(eeepc->wwan3g_rfkill);\r\neeepc->wwan3g_rfkill = NULL;\r\n}\r\nif (eeepc->wimax_rfkill) {\r\nrfkill_unregister(eeepc->wimax_rfkill);\r\nrfkill_destroy(eeepc->wimax_rfkill);\r\neeepc->wimax_rfkill = NULL;\r\n}\r\n}\r\nstatic int eeepc_rfkill_init(struct eeepc_laptop *eeepc)\r\n{\r\nint result = 0;\r\nmutex_init(&eeepc->hotplug_lock);\r\nresult = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,\r\n"eeepc-wlan", RFKILL_TYPE_WLAN,\r\nCM_ASL_WLAN);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = eeepc_new_rfkill(eeepc, &eeepc->bluetooth_rfkill,\r\n"eeepc-bluetooth", RFKILL_TYPE_BLUETOOTH,\r\nCM_ASL_BLUETOOTH);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,\r\n"eeepc-wwan3g", RFKILL_TYPE_WWAN,\r\nCM_ASL_3G);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = eeepc_new_rfkill(eeepc, &eeepc->wimax_rfkill,\r\n"eeepc-wimax", RFKILL_TYPE_WIMAX,\r\nCM_ASL_WIMAX);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nif (eeepc->hotplug_disabled)\r\nreturn 0;\r\nresult = eeepc_setup_pci_hotplug(eeepc);\r\nif (result == -EBUSY)\r\nresult = 0;\r\neeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P5");\r\neeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P6");\r\neeepc_register_rfkill_notifier(eeepc, "\\_SB.PCI0.P0P7");\r\nexit:\r\nif (result && result != -ENODEV)\r\neeepc_rfkill_exit(eeepc);\r\nreturn result;\r\n}\r\nstatic int eeepc_hotk_thaw(struct device *device)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(device);\r\nif (eeepc->wlan_rfkill) {\r\nbool wlan;\r\nwlan = get_acpi(eeepc, CM_ASL_WLAN);\r\nset_acpi(eeepc, CM_ASL_WLAN, wlan);\r\n}\r\nreturn 0;\r\n}\r\nstatic int eeepc_hotk_restore(struct device *device)\r\n{\r\nstruct eeepc_laptop *eeepc = dev_get_drvdata(device);\r\nif (eeepc->wlan_rfkill) {\r\neeepc_rfkill_hotplug_update(eeepc, "\\_SB.PCI0.P0P5");\r\neeepc_rfkill_hotplug_update(eeepc, "\\_SB.PCI0.P0P6");\r\neeepc_rfkill_hotplug_update(eeepc, "\\_SB.PCI0.P0P7");\r\n}\r\nif (eeepc->bluetooth_rfkill)\r\nrfkill_set_sw_state(eeepc->bluetooth_rfkill,\r\nget_acpi(eeepc, CM_ASL_BLUETOOTH) != 1);\r\nif (eeepc->wwan3g_rfkill)\r\nrfkill_set_sw_state(eeepc->wwan3g_rfkill,\r\nget_acpi(eeepc, CM_ASL_3G) != 1);\r\nif (eeepc->wimax_rfkill)\r\nrfkill_set_sw_state(eeepc->wimax_rfkill,\r\nget_acpi(eeepc, CM_ASL_WIMAX) != 1);\r\nreturn 0;\r\n}\r\nstatic int eeepc_get_fan_pwm(void)\r\n{\r\nu8 value = 0;\r\nec_read(EEEPC_EC_FAN_PWM, &value);\r\nreturn value * 255 / 100;\r\n}\r\nstatic void eeepc_set_fan_pwm(int value)\r\n{\r\nvalue = clamp_val(value, 0, 255);\r\nvalue = value * 100 / 255;\r\nec_write(EEEPC_EC_FAN_PWM, value);\r\n}\r\nstatic int eeepc_get_fan_rpm(void)\r\n{\r\nu8 high = 0;\r\nu8 low = 0;\r\nec_read(EEEPC_EC_FAN_HRPM, &high);\r\nec_read(EEEPC_EC_FAN_LRPM, &low);\r\nreturn high << 8 | low;\r\n}\r\nstatic int eeepc_get_fan_ctrl(void)\r\n{\r\nu8 value = 0;\r\nec_read(EEEPC_EC_FAN_CTRL, &value);\r\nif (value & 0x02)\r\nreturn 1;\r\nelse\r\nreturn 2;\r\n}\r\nstatic void eeepc_set_fan_ctrl(int manual)\r\n{\r\nu8 value = 0;\r\nec_read(EEEPC_EC_FAN_CTRL, &value);\r\nif (manual == 1)\r\nvalue |= 0x02;\r\nelse\r\nvalue &= ~0x02;\r\nec_write(EEEPC_EC_FAN_CTRL, value);\r\n}\r\nstatic ssize_t store_sys_hwmon(void (*set)(int), const char *buf, size_t count)\r\n{\r\nint rv, value;\r\nrv = parse_arg(buf, count, &value);\r\nif (rv > 0)\r\nset(value);\r\nreturn rv;\r\n}\r\nstatic ssize_t show_sys_hwmon(int (*get)(void), char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", get());\r\n}\r\nstatic ssize_t\r\nshow_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "eeepc\n");\r\n}\r\nstatic void eeepc_hwmon_exit(struct eeepc_laptop *eeepc)\r\n{\r\nstruct device *hwmon;\r\nhwmon = eeepc->hwmon_device;\r\nif (!hwmon)\r\nreturn;\r\nsysfs_remove_group(&hwmon->kobj,\r\n&hwmon_attribute_group);\r\nhwmon_device_unregister(hwmon);\r\neeepc->hwmon_device = NULL;\r\n}\r\nstatic int eeepc_hwmon_init(struct eeepc_laptop *eeepc)\r\n{\r\nstruct device *hwmon;\r\nint result;\r\nhwmon = hwmon_device_register(&eeepc->platform_device->dev);\r\nif (IS_ERR(hwmon)) {\r\npr_err("Could not register eeepc hwmon device\n");\r\neeepc->hwmon_device = NULL;\r\nreturn PTR_ERR(hwmon);\r\n}\r\neeepc->hwmon_device = hwmon;\r\nresult = sysfs_create_group(&hwmon->kobj,\r\n&hwmon_attribute_group);\r\nif (result)\r\neeepc_hwmon_exit(eeepc);\r\nreturn result;\r\n}\r\nstatic int read_brightness(struct backlight_device *bd)\r\n{\r\nstruct eeepc_laptop *eeepc = bl_get_data(bd);\r\nreturn get_acpi(eeepc, CM_ASL_PANELBRIGHT);\r\n}\r\nstatic int set_brightness(struct backlight_device *bd, int value)\r\n{\r\nstruct eeepc_laptop *eeepc = bl_get_data(bd);\r\nreturn set_acpi(eeepc, CM_ASL_PANELBRIGHT, value);\r\n}\r\nstatic int update_bl_status(struct backlight_device *bd)\r\n{\r\nreturn set_brightness(bd, bd->props.brightness);\r\n}\r\nstatic int eeepc_backlight_notify(struct eeepc_laptop *eeepc)\r\n{\r\nstruct backlight_device *bd = eeepc->backlight_device;\r\nint old = bd->props.brightness;\r\nbacklight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);\r\nreturn old;\r\n}\r\nstatic int eeepc_backlight_init(struct eeepc_laptop *eeepc)\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = 15;\r\nbd = backlight_device_register(EEEPC_LAPTOP_FILE,\r\n&eeepc->platform_device->dev, eeepc,\r\n&eeepcbl_ops, &props);\r\nif (IS_ERR(bd)) {\r\npr_err("Could not register eeepc backlight device\n");\r\neeepc->backlight_device = NULL;\r\nreturn PTR_ERR(bd);\r\n}\r\neeepc->backlight_device = bd;\r\nbd->props.brightness = read_brightness(bd);\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic void eeepc_backlight_exit(struct eeepc_laptop *eeepc)\r\n{\r\nif (eeepc->backlight_device)\r\nbacklight_device_unregister(eeepc->backlight_device);\r\neeepc->backlight_device = NULL;\r\n}\r\nstatic int eeepc_input_init(struct eeepc_laptop *eeepc)\r\n{\r\nstruct input_dev *input;\r\nint error;\r\ninput = input_allocate_device();\r\nif (!input) {\r\npr_info("Unable to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = "Asus EeePC extra buttons";\r\ninput->phys = EEEPC_LAPTOP_FILE "/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &eeepc->platform_device->dev;\r\nerror = sparse_keymap_setup(input, eeepc_keymap, NULL);\r\nif (error) {\r\npr_err("Unable to setup input device keymap\n");\r\ngoto err_free_dev;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\npr_err("Unable to register input device\n");\r\ngoto err_free_keymap;\r\n}\r\neeepc->inputdev = input;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(input);\r\nerr_free_dev:\r\ninput_free_device(input);\r\nreturn error;\r\n}\r\nstatic void eeepc_input_exit(struct eeepc_laptop *eeepc)\r\n{\r\nif (eeepc->inputdev) {\r\nsparse_keymap_free(eeepc->inputdev);\r\ninput_unregister_device(eeepc->inputdev);\r\n}\r\neeepc->inputdev = NULL;\r\n}\r\nstatic void eeepc_input_notify(struct eeepc_laptop *eeepc, int event)\r\n{\r\nif (!eeepc->inputdev)\r\nreturn ;\r\nif (!sparse_keymap_report_event(eeepc->inputdev, event, 1, true))\r\npr_info("Unknown key %x pressed\n", event);\r\n}\r\nstatic void eeepc_acpi_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct eeepc_laptop *eeepc = acpi_driver_data(device);\r\nu16 count;\r\nif (event > ACPI_MAX_SYS_NOTIFY)\r\nreturn;\r\ncount = eeepc->event_count[event % 128]++;\r\nacpi_bus_generate_proc_event(device, event, count);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event,\r\ncount);\r\nif (event >= NOTIFY_BRN_MIN && event <= NOTIFY_BRN_MAX) {\r\nif (eeepc->backlight_device != NULL) {\r\nint old_brightness, new_brightness;\r\nold_brightness = eeepc_backlight_notify(eeepc);\r\nnew_brightness = event - NOTIFY_BRN_MIN;\r\nif (new_brightness < old_brightness) {\r\nevent = NOTIFY_BRN_MIN;\r\n} else if (new_brightness > old_brightness) {\r\nevent = NOTIFY_BRN_MAX;\r\n} else {\r\n}\r\neeepc_input_notify(eeepc, event);\r\n}\r\n} else {\r\neeepc_input_notify(eeepc, event);\r\n}\r\n}\r\nstatic void eeepc_dmi_check(struct eeepc_laptop *eeepc)\r\n{\r\nconst char *model;\r\nmodel = dmi_get_system_info(DMI_PRODUCT_NAME);\r\nif (!model)\r\nreturn;\r\nif (strcmp(model, "701") == 0 || strcmp(model, "702") == 0) {\r\neeepc->cpufv_disabled = true;\r\npr_info("model %s does not officially support setting cpu "\r\n"speed\n", model);\r\npr_info("cpufv disabled to avoid instability\n");\r\n}\r\nif (strcmp(model, "1005HA") == 0 || strcmp(model, "1201N") == 0 ||\r\nstrcmp(model, "1005PE") == 0) {\r\neeepc->hotplug_disabled = true;\r\npr_info("wlan hotplug disabled\n");\r\n}\r\n}\r\nstatic void cmsg_quirk(struct eeepc_laptop *eeepc, int cm, const char *name)\r\n{\r\nint dummy;\r\nif (!(eeepc->cm_supported & (1 << cm))\r\n&& !read_acpi_int(eeepc->handle, cm_getv[cm], &dummy)) {\r\npr_info("%s (%x) not reported by BIOS,"\r\n" enabling anyway\n", name, 1 << cm);\r\neeepc->cm_supported |= 1 << cm;\r\n}\r\n}\r\nstatic void cmsg_quirks(struct eeepc_laptop *eeepc)\r\n{\r\ncmsg_quirk(eeepc, CM_ASL_LID, "LID");\r\ncmsg_quirk(eeepc, CM_ASL_TYPE, "TYPE");\r\ncmsg_quirk(eeepc, CM_ASL_PANELPOWER, "PANELPOWER");\r\ncmsg_quirk(eeepc, CM_ASL_TPD, "TPD");\r\n}\r\nstatic int eeepc_acpi_init(struct eeepc_laptop *eeepc)\r\n{\r\nunsigned int init_flags;\r\nint result;\r\nresult = acpi_bus_get_status(eeepc->device);\r\nif (result)\r\nreturn result;\r\nif (!eeepc->device->status.present) {\r\npr_err("Hotkey device not present, aborting\n");\r\nreturn -ENODEV;\r\n}\r\ninit_flags = DISABLE_ASL_WLAN | DISABLE_ASL_DISPLAYSWITCH;\r\npr_notice("Hotkey init flags 0x%x\n", init_flags);\r\nif (write_acpi_int(eeepc->handle, "INIT", init_flags)) {\r\npr_err("Hotkey initialization failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (read_acpi_int(eeepc->handle, "CMSG", &eeepc->cm_supported)) {\r\npr_err("Get control methods supported failed\n");\r\nreturn -ENODEV;\r\n}\r\ncmsg_quirks(eeepc);\r\npr_info("Get control methods supported: 0x%x\n", eeepc->cm_supported);\r\nreturn 0;\r\n}\r\nstatic void eeepc_enable_camera(struct eeepc_laptop *eeepc)\r\n{\r\nif (get_acpi(eeepc, CM_ASL_CAMERA) == 0)\r\nset_acpi(eeepc, CM_ASL_CAMERA, 1);\r\n}\r\nstatic int eeepc_acpi_add(struct acpi_device *device)\r\n{\r\nstruct eeepc_laptop *eeepc;\r\nint result;\r\npr_notice(EEEPC_LAPTOP_NAME "\n");\r\neeepc = kzalloc(sizeof(struct eeepc_laptop), GFP_KERNEL);\r\nif (!eeepc)\r\nreturn -ENOMEM;\r\neeepc->handle = device->handle;\r\nstrcpy(acpi_device_name(device), EEEPC_ACPI_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), EEEPC_ACPI_CLASS);\r\ndevice->driver_data = eeepc;\r\neeepc->device = device;\r\neeepc->hotplug_disabled = hotplug_disabled;\r\neeepc_dmi_check(eeepc);\r\nresult = eeepc_acpi_init(eeepc);\r\nif (result)\r\ngoto fail_platform;\r\neeepc_enable_camera(eeepc);\r\nresult = eeepc_platform_init(eeepc);\r\nif (result)\r\ngoto fail_platform;\r\nif (!acpi_video_backlight_support()) {\r\nresult = eeepc_backlight_init(eeepc);\r\nif (result)\r\ngoto fail_backlight;\r\n} else\r\npr_info("Backlight controlled by ACPI video driver\n");\r\nresult = eeepc_input_init(eeepc);\r\nif (result)\r\ngoto fail_input;\r\nresult = eeepc_hwmon_init(eeepc);\r\nif (result)\r\ngoto fail_hwmon;\r\nresult = eeepc_led_init(eeepc);\r\nif (result)\r\ngoto fail_led;\r\nresult = eeepc_rfkill_init(eeepc);\r\nif (result)\r\ngoto fail_rfkill;\r\neeepc_device_present = true;\r\nreturn 0;\r\nfail_rfkill:\r\neeepc_led_exit(eeepc);\r\nfail_led:\r\neeepc_hwmon_exit(eeepc);\r\nfail_hwmon:\r\neeepc_input_exit(eeepc);\r\nfail_input:\r\neeepc_backlight_exit(eeepc);\r\nfail_backlight:\r\neeepc_platform_exit(eeepc);\r\nfail_platform:\r\nkfree(eeepc);\r\nreturn result;\r\n}\r\nstatic int eeepc_acpi_remove(struct acpi_device *device)\r\n{\r\nstruct eeepc_laptop *eeepc = acpi_driver_data(device);\r\neeepc_backlight_exit(eeepc);\r\neeepc_rfkill_exit(eeepc);\r\neeepc_input_exit(eeepc);\r\neeepc_hwmon_exit(eeepc);\r\neeepc_led_exit(eeepc);\r\neeepc_platform_exit(eeepc);\r\nkfree(eeepc);\r\nreturn 0;\r\n}\r\nstatic int __init eeepc_laptop_init(void)\r\n{\r\nint result;\r\nresult = platform_driver_register(&platform_driver);\r\nif (result < 0)\r\nreturn result;\r\nresult = acpi_bus_register_driver(&eeepc_acpi_driver);\r\nif (result < 0)\r\ngoto fail_acpi_driver;\r\nif (!eeepc_device_present) {\r\nresult = -ENODEV;\r\ngoto fail_no_device;\r\n}\r\nreturn 0;\r\nfail_no_device:\r\nacpi_bus_unregister_driver(&eeepc_acpi_driver);\r\nfail_acpi_driver:\r\nplatform_driver_unregister(&platform_driver);\r\nreturn result;\r\n}\r\nstatic void __exit eeepc_laptop_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&eeepc_acpi_driver);\r\nplatform_driver_unregister(&platform_driver);\r\n}
