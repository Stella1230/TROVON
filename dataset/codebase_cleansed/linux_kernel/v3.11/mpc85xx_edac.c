static ssize_t mpc85xx_mc_inject_data_hi_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->mc_vbase +\r\nMPC85XX_MC_DATA_ERR_INJECT_HI));\r\n}\r\nstatic ssize_t mpc85xx_mc_inject_data_lo_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->mc_vbase +\r\nMPC85XX_MC_DATA_ERR_INJECT_LO));\r\n}\r\nstatic ssize_t mpc85xx_mc_inject_ctrl_show(struct device *dev,\r\nstruct device_attribute *mattr,\r\nchar *data)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->mc_vbase + MPC85XX_MC_ECC_ERR_INJECT));\r\n}\r\nstatic ssize_t mpc85xx_mc_inject_data_hi_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_DATA_ERR_INJECT_HI,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_mc_inject_data_lo_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_DATA_ERR_INJECT_LO,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_mc_inject_ctrl_store(struct device *dev,\r\nstruct device_attribute *mattr,\r\nconst char *data, size_t count)\r\n{\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ECC_ERR_INJECT,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc85xx_create_sysfs_attributes(struct mem_ctl_info *mci)\r\n{\r\nint rc;\r\nrc = device_create_file(&mci->dev, &dev_attr_inject_data_hi);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = device_create_file(&mci->dev, &dev_attr_inject_data_lo);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = device_create_file(&mci->dev, &dev_attr_inject_ctrl);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic void mpc85xx_remove_sysfs_attributes(struct mem_ctl_info *mci)\r\n{\r\ndevice_remove_file(&mci->dev, &dev_attr_inject_data_hi);\r\ndevice_remove_file(&mci->dev, &dev_attr_inject_data_lo);\r\ndevice_remove_file(&mci->dev, &dev_attr_inject_ctrl);\r\n}\r\nstatic void mpc85xx_pci_check(struct edac_pci_ctl_info *pci)\r\n{\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\r\nif (!(err_detect & ~(PCI_EDE_MULTI_ERR | PCI_EDE_MST_ABRT))) {\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\r\nreturn;\r\n}\r\nprintk(KERN_ERR "PCI error(s) detected\n");\r\nprintk(KERN_ERR "PCI/X ERR_DR register: %#08x\n", err_detect);\r\nprintk(KERN_ERR "PCI/X ERR_ATTRIB register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ATTRIB));\r\nprintk(KERN_ERR "PCI/X ERR_ADDR register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR));\r\nprintk(KERN_ERR "PCI/X ERR_EXT_ADDR register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EXT_ADDR));\r\nprintk(KERN_ERR "PCI/X ERR_DL register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DL));\r\nprintk(KERN_ERR "PCI/X ERR_DH register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DH));\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\r\nif (err_detect & PCI_EDE_PERR_MASK)\r\nedac_pci_handle_pe(pci, pci->ctl_name);\r\nif ((err_detect & ~PCI_EDE_MULTI_ERR) & ~PCI_EDE_PERR_MASK)\r\nedac_pci_handle_npe(pci, pci->ctl_name);\r\n}\r\nstatic irqreturn_t mpc85xx_pci_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_pci_ctl_info *pci = dev_id;\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\r\nif (!err_detect)\r\nreturn IRQ_NONE;\r\nmpc85xx_pci_check(pci);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mpc85xx_pci_err_probe(struct platform_device *op)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nstruct mpc85xx_pci_pdata *pdata;\r\nstruct resource r;\r\nint res = 0;\r\nif (!devres_open_group(&op->dev, mpc85xx_pci_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\npci = edac_pci_alloc_ctl_info(sizeof(*pdata), "mpc85xx_pci_err");\r\nif (!pci)\r\nreturn -ENOMEM;\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\npdata = pci->pvt_info;\r\npdata->name = "mpc85xx_pci_err";\r\npdata->irq = NO_IRQ;\r\ndev_set_drvdata(&op->dev, pci);\r\npci->dev = &op->dev;\r\npci->mod_name = EDAC_MOD_STR;\r\npci->ctl_name = pdata->name;\r\npci->dev_name = dev_name(&op->dev);\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\npci->edac_check = mpc85xx_pci_check;\r\npdata->edac_idx = edac_pci_idx++;\r\nres = of_address_to_resource(op->dev.of_node, 0, &r);\r\nif (res) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"PCI err regs\n", __func__);\r\ngoto err;\r\n}\r\nr.start += 0xe00;\r\nif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->pci_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\r\nif (!pdata->pci_vbase) {\r\nprintk(KERN_ERR "%s: Unable to setup PCI err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\norig_pci_err_cap_dr =\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR, 0x40);\r\norig_pci_err_en = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, ~0x40);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, ~0);\r\nif (edac_pci_add_device(pci, pdata->edac_idx) > 0) {\r\nedac_dbg(3, "failed edac_pci_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nres = devm_request_irq(&op->dev, pdata->irq,\r\nmpc85xx_pci_isr, IRQF_DISABLED,\r\n"[EDAC] PCI err", pci);\r\nif (res < 0) {\r\nprintk(KERN_ERR\r\n"%s: Unable to request irq %d for "\r\n"MPC85xx PCI err\n", __func__, pdata->irq);\r\nirq_dispose_mapping(pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR " acquired irq %d for PCI Err\n",\r\npdata->irq);\r\n}\r\ndevres_remove_group(&op->dev, mpc85xx_pci_err_probe);\r\nedac_dbg(3, "success\n");\r\nprintk(KERN_INFO EDAC_MOD_STR " PCI err registered\n");\r\nreturn 0;\r\nerr2:\r\nedac_pci_del_device(&op->dev);\r\nerr:\r\nedac_pci_free_ctl_info(pci);\r\ndevres_release_group(&op->dev, mpc85xx_pci_err_probe);\r\nreturn res;\r\n}\r\nstatic int mpc85xx_pci_err_remove(struct platform_device *op)\r\n{\r\nstruct edac_pci_ctl_info *pci = dev_get_drvdata(&op->dev);\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nedac_dbg(0, "\n");\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR,\r\norig_pci_err_cap_dr);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, orig_pci_err_en);\r\nedac_pci_del_device(pci->dev);\r\nif (edac_op_state == EDAC_OPSTATE_INT)\r\nirq_dispose_mapping(pdata->irq);\r\nedac_pci_free_ctl_info(pci);\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_hi_show(struct edac_device_ctl_info\r\n*edac_dev, char *data)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJHI));\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_lo_show(struct edac_device_ctl_info\r\n*edac_dev, char *data)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJLO));\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_ctrl_show(struct edac_device_ctl_info\r\n*edac_dev, char *data)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJCTL));\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_hi_store(struct edac_device_ctl_info\r\n*edac_dev, const char *data,\r\nsize_t count)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJHI,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_lo_store(struct edac_device_ctl_info\r\n*edac_dev, const char *data,\r\nsize_t count)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJLO,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_ctrl_store(struct edac_device_ctl_info\r\n*edac_dev, const char *data,\r\nsize_t count)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJCTL,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpc85xx_set_l2_sysfs_attributes(struct edac_device_ctl_info\r\n*edac_dev)\r\n{\r\nedac_dev->sysfs_attributes = mpc85xx_l2_sysfs_attributes;\r\n}\r\nstatic void mpc85xx_l2_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET);\r\nif (!(err_detect & L2_EDE_MASK))\r\nreturn;\r\nprintk(KERN_ERR "ECC Error in CPU L2 cache\n");\r\nprintk(KERN_ERR "L2 Error Detect Register: 0x%08x\n", err_detect);\r\nprintk(KERN_ERR "L2 Error Capture Data High Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_CAPTDATAHI));\r\nprintk(KERN_ERR "L2 Error Capture Data Lo Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_CAPTDATALO));\r\nprintk(KERN_ERR "L2 Error Syndrome Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_CAPTECC));\r\nprintk(KERN_ERR "L2 Error Attributes Capture Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRATTR));\r\nprintk(KERN_ERR "L2 Error Address Capture Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRADDR));\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET, err_detect);\r\nif (err_detect & L2_EDE_CE_MASK)\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nif (err_detect & L2_EDE_UE_MASK)\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic irqreturn_t mpc85xx_l2_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = dev_id;\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET);\r\nif (!(err_detect & L2_EDE_MASK))\r\nreturn IRQ_NONE;\r\nmpc85xx_l2_check(edac_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpc85xx_l2_err_probe(struct platform_device *op)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct mpc85xx_l2_pdata *pdata;\r\nstruct resource r;\r\nint res;\r\nif (!devres_open_group(&op->dev, mpc85xx_l2_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),\r\n"cpu", 1, "L", 1, 2, NULL, 0,\r\nedac_dev_idx);\r\nif (!edac_dev) {\r\ndevres_release_group(&op->dev, mpc85xx_l2_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = edac_dev->pvt_info;\r\npdata->name = "mpc85xx_l2_err";\r\npdata->irq = NO_IRQ;\r\nedac_dev->dev = &op->dev;\r\ndev_set_drvdata(edac_dev->dev, edac_dev);\r\nedac_dev->ctl_name = pdata->name;\r\nedac_dev->dev_name = pdata->name;\r\nres = of_address_to_resource(op->dev.of_node, 0, &r);\r\nif (res) {\r\nprintk(KERN_ERR "%s: Unable to get resource for "\r\n"L2 err regs\n", __func__);\r\ngoto err;\r\n}\r\nr.start += 0xe00;\r\nif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->l2_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\r\nif (!pdata->l2_vbase) {\r\nprintk(KERN_ERR "%s: Unable to setup L2 err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET, ~0);\r\norig_l2_err_disable = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS);\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS, 0);\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = mpc85xx_l2_check;\r\nmpc85xx_set_l2_sysfs_attributes(edac_dev);\r\npdata->edac_idx = edac_dev_idx++;\r\nif (edac_device_add_device(edac_dev) > 0) {\r\nedac_dbg(3, "failed edac_device_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nres = devm_request_irq(&op->dev, pdata->irq,\r\nmpc85xx_l2_isr, IRQF_DISABLED,\r\n"[EDAC] L2 err", edac_dev);\r\nif (res < 0) {\r\nprintk(KERN_ERR\r\n"%s: Unable to request irq %d for "\r\n"MPC85xx L2 err\n", __func__, pdata->irq);\r\nirq_dispose_mapping(pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR " acquired irq %d for L2 Err\n",\r\npdata->irq);\r\nedac_dev->op_state = OP_RUNNING_INTERRUPT;\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINTEN, L2_EIE_MASK);\r\n}\r\ndevres_remove_group(&op->dev, mpc85xx_l2_err_probe);\r\nedac_dbg(3, "success\n");\r\nprintk(KERN_INFO EDAC_MOD_STR " L2 err registered\n");\r\nreturn 0;\r\nerr2:\r\nedac_device_del_device(&op->dev);\r\nerr:\r\ndevres_release_group(&op->dev, mpc85xx_l2_err_probe);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn res;\r\n}\r\nstatic int mpc85xx_l2_err_remove(struct platform_device *op)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = dev_get_drvdata(&op->dev);\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nedac_dbg(0, "\n");\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINTEN, 0);\r\nirq_dispose_mapping(pdata->irq);\r\n}\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS, orig_l2_err_disable);\r\nedac_device_del_device(&op->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic u8 calculate_ecc(u32 high, u32 low)\r\n{\r\nu32 mask_low;\r\nu32 mask_high;\r\nint bit_cnt;\r\nu8 ecc = 0;\r\nint i;\r\nint j;\r\nfor (i = 0; i < 8; i++) {\r\nmask_high = ecc_table[i * 2];\r\nmask_low = ecc_table[i * 2 + 1];\r\nbit_cnt = 0;\r\nfor (j = 0; j < 32; j++) {\r\nif ((mask_high >> j) & 1)\r\nbit_cnt ^= (high >> j) & 1;\r\nif ((mask_low >> j) & 1)\r\nbit_cnt ^= (low >> j) & 1;\r\n}\r\necc |= bit_cnt << i;\r\n}\r\nreturn ecc;\r\n}\r\nstatic u8 syndrome_from_bit(unsigned int bit) {\r\nint i;\r\nu8 syndrome = 0;\r\nfor (i = bit < 32; i < 16; i += 2)\r\nsyndrome |= ((ecc_table[i] >> (bit % 32)) & 1) << (i / 2);\r\nreturn syndrome;\r\n}\r\nstatic void sbe_ecc_decode(u32 cap_high, u32 cap_low, u32 cap_ecc,\r\nint *bad_data_bit, int *bad_ecc_bit)\r\n{\r\nint i;\r\nu8 syndrome;\r\n*bad_data_bit = -1;\r\n*bad_ecc_bit = -1;\r\nsyndrome = calculate_ecc(cap_high, cap_low) ^ cap_ecc;\r\nfor (i = 0; i < 64; i++) {\r\nif (syndrome == syndrome_from_bit(i)) {\r\n*bad_data_bit = i;\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif ((syndrome >> i) & 0x1) {\r\n*bad_ecc_bit = i;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void mpc85xx_mc_check(struct mem_ctl_info *mci)\r\n{\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nstruct csrow_info *csrow;\r\nu32 bus_width;\r\nu32 err_detect;\r\nu32 syndrome;\r\nu32 err_addr;\r\nu32 pfn;\r\nint row_index;\r\nu32 cap_high;\r\nu32 cap_low;\r\nint bad_data_bit;\r\nint bad_ecc_bit;\r\nerr_detect = in_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DETECT);\r\nif (!err_detect)\r\nreturn;\r\nmpc85xx_mc_printk(mci, KERN_ERR, "Err Detect Register: %#8.8x\n",\r\nerr_detect);\r\nif (!(err_detect & (DDR_EDE_SBE | DDR_EDE_MBE))) {\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DETECT, err_detect);\r\nreturn;\r\n}\r\nsyndrome = in_be32(pdata->mc_vbase + MPC85XX_MC_CAPTURE_ECC);\r\nbus_width = (in_be32(pdata->mc_vbase + MPC85XX_MC_DDR_SDRAM_CFG) &\r\nDSC_DBW_MASK) ? 32 : 64;\r\nif (bus_width == 64)\r\nsyndrome &= 0xff;\r\nelse\r\nsyndrome &= 0xffff;\r\nerr_addr = in_be32(pdata->mc_vbase + MPC85XX_MC_CAPTURE_ADDRESS);\r\npfn = err_addr >> PAGE_SHIFT;\r\nfor (row_index = 0; row_index < mci->nr_csrows; row_index++) {\r\ncsrow = mci->csrows[row_index];\r\nif ((pfn >= csrow->first_page) && (pfn <= csrow->last_page))\r\nbreak;\r\n}\r\ncap_high = in_be32(pdata->mc_vbase + MPC85XX_MC_CAPTURE_DATA_HI);\r\ncap_low = in_be32(pdata->mc_vbase + MPC85XX_MC_CAPTURE_DATA_LO);\r\nif ((err_detect & DDR_EDE_SBE) && (bus_width == 64)) {\r\nsbe_ecc_decode(cap_high, cap_low, syndrome,\r\n&bad_data_bit, &bad_ecc_bit);\r\nif (bad_data_bit != -1)\r\nmpc85xx_mc_printk(mci, KERN_ERR,\r\n"Faulty Data bit: %d\n", bad_data_bit);\r\nif (bad_ecc_bit != -1)\r\nmpc85xx_mc_printk(mci, KERN_ERR,\r\n"Faulty ECC bit: %d\n", bad_ecc_bit);\r\nmpc85xx_mc_printk(mci, KERN_ERR,\r\n"Expected Data / ECC:\t%#8.8x_%08x / %#2.2x\n",\r\ncap_high ^ (1 << (bad_data_bit - 32)),\r\ncap_low ^ (1 << bad_data_bit),\r\nsyndrome ^ (1 << bad_ecc_bit));\r\n}\r\nmpc85xx_mc_printk(mci, KERN_ERR,\r\n"Captured Data / ECC:\t%#8.8x_%08x / %#2.2x\n",\r\ncap_high, cap_low, syndrome);\r\nmpc85xx_mc_printk(mci, KERN_ERR, "Err addr: %#8.8x\n", err_addr);\r\nmpc85xx_mc_printk(mci, KERN_ERR, "PFN: %#8.8x\n", pfn);\r\nif (row_index == mci->nr_csrows)\r\nmpc85xx_mc_printk(mci, KERN_ERR, "PFN out of range!\n");\r\nif (err_detect & DDR_EDE_SBE)\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npfn, err_addr & ~PAGE_MASK, syndrome,\r\nrow_index, 0, -1,\r\nmci->ctl_name, "");\r\nif (err_detect & DDR_EDE_MBE)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npfn, err_addr & ~PAGE_MASK, syndrome,\r\nrow_index, 0, -1,\r\nmci->ctl_name, "");\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DETECT, err_detect);\r\n}\r\nstatic irqreturn_t mpc85xx_mc_isr(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DETECT);\r\nif (!err_detect)\r\nreturn IRQ_NONE;\r\nmpc85xx_mc_check(mci);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mpc85xx_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nu32 sdram_ctl;\r\nu32 sdtype;\r\nenum mem_type mtype;\r\nu32 cs_bnds;\r\nint index;\r\nsdram_ctl = in_be32(pdata->mc_vbase + MPC85XX_MC_DDR_SDRAM_CFG);\r\nsdtype = sdram_ctl & DSC_SDTYPE_MASK;\r\nif (sdram_ctl & DSC_RD_EN) {\r\nswitch (sdtype) {\r\ncase DSC_SDTYPE_DDR:\r\nmtype = MEM_RDDR;\r\nbreak;\r\ncase DSC_SDTYPE_DDR2:\r\nmtype = MEM_RDDR2;\r\nbreak;\r\ncase DSC_SDTYPE_DDR3:\r\nmtype = MEM_RDDR3;\r\nbreak;\r\ndefault:\r\nmtype = MEM_UNKNOWN;\r\nbreak;\r\n}\r\n} else {\r\nswitch (sdtype) {\r\ncase DSC_SDTYPE_DDR:\r\nmtype = MEM_DDR;\r\nbreak;\r\ncase DSC_SDTYPE_DDR2:\r\nmtype = MEM_DDR2;\r\nbreak;\r\ncase DSC_SDTYPE_DDR3:\r\nmtype = MEM_DDR3;\r\nbreak;\r\ndefault:\r\nmtype = MEM_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\nu32 start;\r\nu32 end;\r\ncsrow = mci->csrows[index];\r\ndimm = csrow->channels[0]->dimm;\r\ncs_bnds = in_be32(pdata->mc_vbase + MPC85XX_MC_CS_BNDS_0 +\r\n(index * MPC85XX_MC_CS_BNDS_OFS));\r\nstart = (cs_bnds & 0xffff0000) >> 16;\r\nend = (cs_bnds & 0x0000ffff);\r\nif (start == end)\r\ncontinue;\r\nstart <<= (24 - PAGE_SHIFT);\r\nend <<= (24 - PAGE_SHIFT);\r\nend |= (1 << (24 - PAGE_SHIFT)) - 1;\r\ncsrow->first_page = start;\r\ncsrow->last_page = end;\r\ndimm->nr_pages = end + 1 - start;\r\ndimm->grain = 8;\r\ndimm->mtype = mtype;\r\ndimm->dtype = DEV_UNKNOWN;\r\nif (sdram_ctl & DSC_X32_EN)\r\ndimm->dtype = DEV_X32;\r\ndimm->edac_mode = EDAC_SECDED;\r\n}\r\n}\r\nstatic int mpc85xx_mc_err_probe(struct platform_device *op)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct mpc85xx_mc_pdata *pdata;\r\nstruct resource r;\r\nu32 sdram_ctl;\r\nint res;\r\nif (!devres_open_group(&op->dev, mpc85xx_mc_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 4;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(edac_mc_idx, ARRAY_SIZE(layers), layers,\r\nsizeof(*pdata));\r\nif (!mci) {\r\ndevres_release_group(&op->dev, mpc85xx_mc_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = mci->pvt_info;\r\npdata->name = "mpc85xx_mc_err";\r\npdata->irq = NO_IRQ;\r\nmci->pdev = &op->dev;\r\npdata->edac_idx = edac_mc_idx++;\r\ndev_set_drvdata(mci->pdev, mci);\r\nmci->ctl_name = pdata->name;\r\nmci->dev_name = pdata->name;\r\nres = of_address_to_resource(op->dev.of_node, 0, &r);\r\nif (res) {\r\nprintk(KERN_ERR "%s: Unable to get resource for MC err regs\n",\r\n__func__);\r\ngoto err;\r\n}\r\nif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\r\npdata->name)) {\r\nprintk(KERN_ERR "%s: Error while requesting mem region\n",\r\n__func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->mc_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\r\nif (!pdata->mc_vbase) {\r\nprintk(KERN_ERR "%s: Unable to setup MC err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nsdram_ctl = in_be32(pdata->mc_vbase + MPC85XX_MC_DDR_SDRAM_CFG);\r\nif (!(sdram_ctl & DSC_ECC_EN)) {\r\nprintk(KERN_WARNING "%s: No ECC DIMMs discovered\n", __func__);\r\nres = -ENODEV;\r\ngoto err;\r\n}\r\nedac_dbg(3, "init mci\n");\r\nmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_RDDR2 |\r\nMEM_FLAG_DDR | MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = MPC85XX_REVISION;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nmci->edac_check = mpc85xx_mc_check;\r\nmci->ctl_page_to_phys = NULL;\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nmpc85xx_init_csrows(mci);\r\norig_ddr_err_disable =\r\nin_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DISABLE);\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DISABLE, 0);\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DETECT, ~0);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto err;\r\n}\r\nif (mpc85xx_create_sysfs_attributes(mci)) {\r\nedac_mc_del_mc(mci->pdev);\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_INT_EN,\r\nDDR_EIE_MBEE | DDR_EIE_SBEE);\r\norig_ddr_err_sbe = in_be32(pdata->mc_vbase +\r\nMPC85XX_MC_ERR_SBE) & 0xff0000;\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_SBE, 0x10000);\r\npdata->irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nres = devm_request_irq(&op->dev, pdata->irq,\r\nmpc85xx_mc_isr,\r\nIRQF_DISABLED | IRQF_SHARED,\r\n"[EDAC] MC err", mci);\r\nif (res < 0) {\r\nprintk(KERN_ERR "%s: Unable to request irq %d for "\r\n"MPC85xx DRAM ERR\n", __func__, pdata->irq);\r\nirq_dispose_mapping(pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO EDAC_MOD_STR " acquired irq %d for MC\n",\r\npdata->irq);\r\n}\r\ndevres_remove_group(&op->dev, mpc85xx_mc_err_probe);\r\nedac_dbg(3, "success\n");\r\nprintk(KERN_INFO EDAC_MOD_STR " MC err registered\n");\r\nreturn 0;\r\nerr2:\r\nedac_mc_del_mc(&op->dev);\r\nerr:\r\ndevres_release_group(&op->dev, mpc85xx_mc_err_probe);\r\nedac_mc_free(mci);\r\nreturn res;\r\n}\r\nstatic int mpc85xx_mc_err_remove(struct platform_device *op)\r\n{\r\nstruct mem_ctl_info *mci = dev_get_drvdata(&op->dev);\r\nstruct mpc85xx_mc_pdata *pdata = mci->pvt_info;\r\nedac_dbg(0, "\n");\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_INT_EN, 0);\r\nirq_dispose_mapping(pdata->irq);\r\n}\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_DISABLE,\r\norig_ddr_err_disable);\r\nout_be32(pdata->mc_vbase + MPC85XX_MC_ERR_SBE, orig_ddr_err_sbe);\r\nmpc85xx_remove_sysfs_attributes(mci);\r\nedac_mc_del_mc(&op->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}\r\nstatic void __init mpc85xx_mc_clear_rfxe(void *data)\r\n{\r\norig_hid1[smp_processor_id()] = mfspr(SPRN_HID1);\r\nmtspr(SPRN_HID1, (orig_hid1[smp_processor_id()] & ~HID1_RFXE));\r\n}\r\nstatic int __init mpc85xx_mc_init(void)\r\n{\r\nint res = 0;\r\nu32 pvr = 0;\r\nprintk(KERN_INFO "Freescale(R) MPC85xx EDAC driver, "\r\n"(C) 2006 Montavista Software\n");\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\nres = platform_driver_register(&mpc85xx_mc_err_driver);\r\nif (res)\r\nprintk(KERN_WARNING EDAC_MOD_STR "MC fails to register\n");\r\nres = platform_driver_register(&mpc85xx_l2_err_driver);\r\nif (res)\r\nprintk(KERN_WARNING EDAC_MOD_STR "L2 fails to register\n");\r\n#ifdef CONFIG_FSL_SOC_BOOKE\r\npvr = mfspr(SPRN_PVR);\r\nif ((PVR_VER(pvr) == PVR_VER_E500V1) ||\r\n(PVR_VER(pvr) == PVR_VER_E500V2)) {\r\nif (edac_op_state == EDAC_OPSTATE_INT)\r\non_each_cpu(mpc85xx_mc_clear_rfxe, NULL, 0);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit mpc85xx_mc_restore_hid1(void *data)\r\n{\r\nmtspr(SPRN_HID1, orig_hid1[smp_processor_id()]);\r\n}\r\nstatic void __exit mpc85xx_mc_exit(void)\r\n{\r\n#ifdef CONFIG_FSL_SOC_BOOKE\r\nu32 pvr = mfspr(SPRN_PVR);\r\nif ((PVR_VER(pvr) == PVR_VER_E500V1) ||\r\n(PVR_VER(pvr) == PVR_VER_E500V2)) {\r\non_each_cpu(mpc85xx_mc_restore_hid1, NULL, 0);\r\n}\r\n#endif\r\nplatform_driver_unregister(&mpc85xx_l2_err_driver);\r\nplatform_driver_unregister(&mpc85xx_mc_err_driver);\r\n}
