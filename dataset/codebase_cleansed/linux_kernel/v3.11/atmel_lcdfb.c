static struct atmel_lcdfb_config *\r\natmel_lcdfb_get_config(struct platform_device *pdev)\r\n{\r\nunsigned long data;\r\ndata = platform_get_device_id(pdev)->driver_data;\r\nreturn (struct atmel_lcdfb_config *)data;\r\n}\r\nstatic inline void atmel_lcdfb_update_dma2d(struct atmel_lcdfb_info *sinfo,\r\nstruct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\n}\r\nstatic void atmel_lcdfb_update_dma2d(struct atmel_lcdfb_info *sinfo,\r\nstruct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nu32 dma2dcfg;\r\nu32 pixeloff;\r\npixeloff = (var->xoffset * info->var.bits_per_pixel) & 0x1f;\r\ndma2dcfg = (info->var.xres_virtual - info->var.xres)\r\n* info->var.bits_per_pixel / 8;\r\ndma2dcfg |= pixeloff << ATMEL_LCDC_PIXELOFF_OFFSET;\r\nlcdc_writel(sinfo, ATMEL_LCDC_DMA2DCFG, dma2dcfg);\r\nlcdc_writel(sinfo, ATMEL_LCDC_DMACON,\r\nlcdc_readl(sinfo, ATMEL_LCDC_DMACON)\r\n| ATMEL_LCDC_DMAUPDT);\r\n}\r\nstatic int atmel_bl_update_status(struct backlight_device *bl)\r\n{\r\nstruct atmel_lcdfb_info *sinfo = bl_get_data(bl);\r\nint power = sinfo->bl_power;\r\nint brightness = bl->props.brightness;\r\nif (bl->props.fb_blank != sinfo->bl_power)\r\npower = bl->props.fb_blank;\r\nelse if (bl->props.power != sinfo->bl_power)\r\npower = bl->props.power;\r\nif (brightness < 0 && power == FB_BLANK_UNBLANK)\r\nbrightness = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);\r\nelse if (power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, brightness);\r\nif (contrast_ctr & ATMEL_LCDC_POL_POSITIVE)\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR,\r\nbrightness ? contrast_ctr : 0);\r\nelse\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);\r\nbl->props.fb_blank = bl->props.power = sinfo->bl_power = power;\r\nreturn 0;\r\n}\r\nstatic int atmel_bl_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct atmel_lcdfb_info *sinfo = bl_get_data(bl);\r\nreturn lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);\r\n}\r\nstatic void init_backlight(struct atmel_lcdfb_info *sinfo)\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nsinfo->bl_power = FB_BLANK_UNBLANK;\r\nif (sinfo->backlight)\r\nreturn;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 0xff;\r\nbl = backlight_device_register("backlight", &sinfo->pdev->dev, sinfo,\r\n&atmel_lcdc_bl_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&sinfo->pdev->dev, "error %ld on backlight register\n",\r\nPTR_ERR(bl));\r\nreturn;\r\n}\r\nsinfo->backlight = bl;\r\nbl->props.power = FB_BLANK_UNBLANK;\r\nbl->props.fb_blank = FB_BLANK_UNBLANK;\r\nbl->props.brightness = atmel_bl_get_brightness(bl);\r\n}\r\nstatic void exit_backlight(struct atmel_lcdfb_info *sinfo)\r\n{\r\nif (!sinfo->backlight)\r\nreturn;\r\nif (sinfo->backlight->ops) {\r\nsinfo->backlight->props.power = FB_BLANK_POWERDOWN;\r\nsinfo->backlight->ops->update_status(sinfo->backlight);\r\n}\r\nbacklight_device_unregister(sinfo->backlight);\r\n}\r\nstatic void init_backlight(struct atmel_lcdfb_info *sinfo)\r\n{\r\ndev_warn(&sinfo->pdev->dev, "backlight control is not available\n");\r\n}\r\nstatic void exit_backlight(struct atmel_lcdfb_info *sinfo)\r\n{\r\n}\r\nstatic void init_contrast(struct atmel_lcdfb_info *sinfo)\r\n{\r\nif (sinfo->lcdcon_pol_negative)\r\ncontrast_ctr &= ~(ATMEL_LCDC_POL_POSITIVE);\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);\r\nif (sinfo->lcdcon_is_backlight)\r\ninit_backlight(sinfo);\r\n}\r\nstatic unsigned long compute_hozval(struct atmel_lcdfb_info *sinfo,\r\nunsigned long xres)\r\n{\r\nunsigned long lcdcon2;\r\nunsigned long value;\r\nif (!sinfo->config->have_hozval)\r\nreturn xres;\r\nlcdcon2 = lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2);\r\nvalue = xres;\r\nif ((lcdcon2 & ATMEL_LCDC_DISTYPE) != ATMEL_LCDC_DISTYPE_TFT) {\r\nif ((lcdcon2 & ATMEL_LCDC_DISTYPE) == ATMEL_LCDC_DISTYPE_STNCOLOR) {\r\nvalue *= 3;\r\n}\r\nif ( (lcdcon2 & ATMEL_LCDC_IFWIDTH) == ATMEL_LCDC_IFWIDTH_4\r\n|| ( (lcdcon2 & ATMEL_LCDC_IFWIDTH) == ATMEL_LCDC_IFWIDTH_8\r\n&& (lcdcon2 & ATMEL_LCDC_SCANMOD) == ATMEL_LCDC_SCANMOD_DUAL ))\r\nvalue = DIV_ROUND_UP(value, 4);\r\nelse\r\nvalue = DIV_ROUND_UP(value, 8);\r\n}\r\nreturn value;\r\n}\r\nstatic void atmel_lcdfb_stop_nowait(struct atmel_lcdfb_info *sinfo)\r\n{\r\nlcdc_writel(sinfo, ATMEL_LCDC_PWRCON,\r\nsinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET);\r\nwhile (lcdc_readl(sinfo, ATMEL_LCDC_PWRCON) & ATMEL_LCDC_BUSY)\r\nmsleep(10);\r\nlcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);\r\n}\r\nstatic void atmel_lcdfb_stop(struct atmel_lcdfb_info *sinfo)\r\n{\r\natmel_lcdfb_stop_nowait(sinfo);\r\nwhile (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)\r\nmsleep(10);\r\n}\r\nstatic void atmel_lcdfb_start(struct atmel_lcdfb_info *sinfo)\r\n{\r\nlcdc_writel(sinfo, ATMEL_LCDC_DMACON, sinfo->default_dmacon);\r\nlcdc_writel(sinfo, ATMEL_LCDC_PWRCON,\r\n(sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET)\r\n| ATMEL_LCDC_PWR);\r\n}\r\nstatic void atmel_lcdfb_update_dma(struct fb_info *info,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nunsigned long dma_addr;\r\ndma_addr = (fix->smem_start + var->yoffset * fix->line_length\r\n+ var->xoffset * info->var.bits_per_pixel / 8);\r\ndma_addr &= ~3UL;\r\nlcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);\r\natmel_lcdfb_update_dma2d(sinfo, var, info);\r\n}\r\nstatic inline void atmel_lcdfb_free_video_memory(struct atmel_lcdfb_info *sinfo)\r\n{\r\nstruct fb_info *info = sinfo->info;\r\ndma_free_writecombine(info->device, info->fix.smem_len,\r\ninfo->screen_base, info->fix.smem_start);\r\n}\r\nstatic int atmel_lcdfb_alloc_video_memory(struct atmel_lcdfb_info *sinfo)\r\n{\r\nstruct fb_info *info = sinfo->info;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nunsigned int smem_len;\r\nsmem_len = (var->xres_virtual * var->yres_virtual\r\n* ((var->bits_per_pixel + 7) / 8));\r\ninfo->fix.smem_len = max(smem_len, sinfo->smem_len);\r\ninfo->screen_base = dma_alloc_writecombine(info->device, info->fix.smem_len,\r\n(dma_addr_t *)&info->fix.smem_start, GFP_KERNEL);\r\nif (!info->screen_base) {\r\nreturn -ENOMEM;\r\n}\r\nmemset(info->screen_base, 0, info->fix.smem_len);\r\nreturn 0;\r\n}\r\nstatic const struct fb_videomode *atmel_lcdfb_choose_mode(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct fb_videomode varfbmode;\r\nconst struct fb_videomode *fbmode = NULL;\r\nfb_var_to_videomode(&varfbmode, var);\r\nfbmode = fb_find_nearest_mode(&varfbmode, &info->modelist);\r\nif (fbmode)\r\nfb_videomode_to_var(var, fbmode);\r\nreturn fbmode;\r\n}\r\nstatic int atmel_lcdfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct device *dev = info->device;\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nunsigned long clk_value_khz;\r\nclk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;\r\ndev_dbg(dev, "%s:\n", __func__);\r\nif (!(var->pixclock && var->bits_per_pixel)) {\r\nif (!atmel_lcdfb_choose_mode(var, info)) {\r\ndev_err(dev, "needed value not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_dbg(dev, " resolution: %ux%u\n", var->xres, var->yres);\r\ndev_dbg(dev, " pixclk: %lu KHz\n", PICOS2KHZ(var->pixclock));\r\ndev_dbg(dev, " bpp: %u\n", var->bits_per_pixel);\r\ndev_dbg(dev, " clk: %lu KHz\n", clk_value_khz);\r\nif (PICOS2KHZ(var->pixclock) > clk_value_khz) {\r\ndev_err(dev, "%lu KHz pixel clock is too fast\n", PICOS2KHZ(var->pixclock));\r\nreturn -EINVAL;\r\n}\r\nif (var->xres > var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nvar->xres = (var->xres + 3) & ~3UL;\r\nvar->xres_virtual = (var->xres_virtual + 3) & ~3UL;\r\nvar->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nvar->transp.offset = var->transp.length = 0;\r\nvar->xoffset = var->yoffset = 0;\r\nif (info->fix.smem_len) {\r\nunsigned int smem_len = (var->xres_virtual * var->yres_virtual\r\n* ((var->bits_per_pixel + 7) / 8));\r\nif (smem_len > info->fix.smem_len) {\r\ndev_err(dev, "Frame buffer is too small (%u) for screen size (need at least %u)\n",\r\ninfo->fix.smem_len, smem_len);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvar->vsync_len = min_t(u32, var->vsync_len,\r\n(ATMEL_LCDC_VPW >> ATMEL_LCDC_VPW_OFFSET) + 1);\r\nvar->upper_margin = min_t(u32, var->upper_margin,\r\nATMEL_LCDC_VBP >> ATMEL_LCDC_VBP_OFFSET);\r\nvar->lower_margin = min_t(u32, var->lower_margin,\r\nATMEL_LCDC_VFP);\r\nvar->right_margin = min_t(u32, var->right_margin,\r\n(ATMEL_LCDC_HFP >> ATMEL_LCDC_HFP_OFFSET) + 1);\r\nvar->hsync_len = min_t(u32, var->hsync_len,\r\n(ATMEL_LCDC_HPW >> ATMEL_LCDC_HPW_OFFSET) + 1);\r\nvar->left_margin = min_t(u32, var->left_margin,\r\nATMEL_LCDC_HBP + 1);\r\nvar->vsync_len = max_t(u32, var->vsync_len, 1);\r\nvar->right_margin = max_t(u32, var->right_margin, 1);\r\nvar->hsync_len = max_t(u32, var->hsync_len, 1);\r\nvar->left_margin = max_t(u32, var->left_margin, 1);\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length\r\n= var->bits_per_pixel;\r\nbreak;\r\ncase 16:\r\nif (sinfo->config->have_intensity_bit)\r\nvar->green.length = 5;\r\nelse\r\nvar->green.length = 6;\r\nif (sinfo->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {\r\nvar->red.offset = var->green.length + 5;\r\nvar->blue.offset = 0;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->blue.offset = var->green.length + 5;\r\n}\r\nvar->green.offset = 5;\r\nvar->red.length = var->blue.length = 5;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\ncase 24:\r\nif (sinfo->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {\r\nvar->red.offset = 16;\r\nvar->blue.offset = 0;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->blue.offset = 16;\r\n}\r\nvar->green.offset = 8;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "color depth %d not supported\n",\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_lcdfb_reset(struct atmel_lcdfb_info *sinfo)\r\n{\r\nmight_sleep();\r\natmel_lcdfb_stop(sinfo);\r\natmel_lcdfb_start(sinfo);\r\n}\r\nstatic int atmel_lcdfb_set_par(struct fb_info *info)\r\n{\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nunsigned long hozval_linesz;\r\nunsigned long value;\r\nunsigned long clk_value_khz;\r\nunsigned long bits_per_line;\r\nunsigned long pix_factor = 2;\r\nmight_sleep();\r\ndev_dbg(info->device, "%s:\n", __func__);\r\ndev_dbg(info->device, " * resolution: %ux%u (%ux%u virtual)\n",\r\ninfo->var.xres, info->var.yres,\r\ninfo->var.xres_virtual, info->var.yres_virtual);\r\natmel_lcdfb_stop_nowait(sinfo);\r\nif (info->var.bits_per_pixel == 1)\r\ninfo->fix.visual = FB_VISUAL_MONO01;\r\nelse if (info->var.bits_per_pixel <= 8)\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbits_per_line = info->var.xres_virtual * info->var.bits_per_pixel;\r\ninfo->fix.line_length = DIV_ROUND_UP(bits_per_line, 8);\r\ndev_dbg(info->device, " * update DMA engine\n");\r\natmel_lcdfb_update_dma(info, &info->var);\r\nvalue = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;\r\nvalue |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);\r\nlcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);\r\nif (sinfo->config->have_alt_pixclock)\r\npix_factor = 1;\r\nclk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;\r\nvalue = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));\r\nif (value < pix_factor) {\r\ndev_notice(info->device, "Bypassing pixel clock divider\n");\r\nlcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);\r\n} else {\r\nvalue = (value / pix_factor) - 1;\r\ndev_dbg(info->device, " * programming CLKVAL = 0x%08lx\n",\r\nvalue);\r\nlcdc_writel(sinfo, ATMEL_LCDC_LCDCON1,\r\nvalue << ATMEL_LCDC_CLKVAL_OFFSET);\r\ninfo->var.pixclock =\r\nKHZ2PICOS(clk_value_khz / (pix_factor * (value + 1)));\r\ndev_dbg(info->device, " updated pixclk: %lu KHz\n",\r\nPICOS2KHZ(info->var.pixclock));\r\n}\r\nvalue = sinfo->default_lcdcon2;\r\nif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\r\nvalue |= ATMEL_LCDC_INVLINE_INVERTED;\r\nif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\r\nvalue |= ATMEL_LCDC_INVFRAME_INVERTED;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 1: value |= ATMEL_LCDC_PIXELSIZE_1; break;\r\ncase 2: value |= ATMEL_LCDC_PIXELSIZE_2; break;\r\ncase 4: value |= ATMEL_LCDC_PIXELSIZE_4; break;\r\ncase 8: value |= ATMEL_LCDC_PIXELSIZE_8; break;\r\ncase 15:\r\ncase 16: value |= ATMEL_LCDC_PIXELSIZE_16; break;\r\ncase 24: value |= ATMEL_LCDC_PIXELSIZE_24; break;\r\ncase 32: value |= ATMEL_LCDC_PIXELSIZE_32; break;\r\ndefault: BUG(); break;\r\n}\r\ndev_dbg(info->device, " * LCDCON2 = %08lx\n", value);\r\nlcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);\r\nvalue = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;\r\nvalue |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;\r\nvalue |= info->var.lower_margin;\r\ndev_dbg(info->device, " * LCDTIM1 = %08lx\n", value);\r\nlcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);\r\nvalue = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;\r\nvalue |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;\r\nvalue |= (info->var.left_margin - 1);\r\ndev_dbg(info->device, " * LCDTIM2 = %08lx\n", value);\r\nlcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);\r\nhozval_linesz = compute_hozval(sinfo, info->var.xres);\r\nvalue = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;\r\nvalue |= info->var.yres - 1;\r\ndev_dbg(info->device, " * LCDFRMCFG = %08lx\n", value);\r\nlcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);\r\nvalue = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);\r\nlcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);\r\nlcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);\r\nlcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);\r\nlcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI | ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);\r\nwhile (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)\r\nmsleep(10);\r\natmel_lcdfb_start(sinfo);\r\ndev_dbg(info->device, " * DONE\n");\r\nreturn 0;\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan, const struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int atmel_lcdfb_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nunsigned int val;\r\nu32 *pal;\r\nint ret = 1;\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green\r\n+ 7471 * blue) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\npal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno < 256) {\r\nif (sinfo->config->have_intensity_bit) {\r\nval = ((red >> 11) & 0x001f);\r\nval |= ((green >> 6) & 0x03e0);\r\nval |= ((blue >> 1) & 0x7c00);\r\n} else {\r\nif (sinfo->lcd_wiring_mode ==\r\nATMEL_LCDC_WIRING_RGB) {\r\nval = ((blue >> 11) & 0x001f);\r\nval |= ((red >> 0) & 0xf800);\r\n} else {\r\nval = ((red >> 11) & 0x001f);\r\nval |= ((blue >> 0) & 0xf800);\r\n}\r\nval |= ((green >> 5) & 0x07e0);\r\n}\r\nlcdc_writel(sinfo, ATMEL_LCDC_LUT(regno), val);\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_MONO01:\r\nif (regno < 2) {\r\nval = (regno == 0) ? 0x00 : 0x1F;\r\nlcdc_writel(sinfo, ATMEL_LCDC_LUT(regno), val);\r\nret = 0;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_lcdfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\ndev_dbg(info->device, "%s\n", __func__);\r\natmel_lcdfb_update_dma(info, var);\r\nreturn 0;\r\n}\r\nstatic int atmel_lcdfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\natmel_lcdfb_start(sinfo);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\natmel_lcdfb_stop(sinfo);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ((blank_mode == FB_BLANK_NORMAL) ? 1 : 0);\r\n}\r\nstatic irqreturn_t atmel_lcdfb_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fb_info *info = dev_id;\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nu32 status;\r\nstatus = lcdc_readl(sinfo, ATMEL_LCDC_ISR);\r\nif (status & ATMEL_LCDC_UFLWI) {\r\ndev_warn(info->device, "FIFO underflow %#x\n", status);\r\nschedule_work(&sinfo->task);\r\n}\r\nlcdc_writel(sinfo, ATMEL_LCDC_ICR, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void atmel_lcdfb_task(struct work_struct *work)\r\n{\r\nstruct atmel_lcdfb_info *sinfo =\r\ncontainer_of(work, struct atmel_lcdfb_info, task);\r\natmel_lcdfb_reset(sinfo);\r\n}\r\nstatic int __init atmel_lcdfb_init_fbinfo(struct atmel_lcdfb_info *sinfo)\r\n{\r\nstruct fb_info *info = sinfo->info;\r\nint ret = 0;\r\ninfo->var.activate |= FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;\r\ndev_info(info->device,\r\n"%luKiB frame buffer at %08lx (mapped at %p)\n",\r\n(unsigned long)info->fix.smem_len / 1024,\r\n(unsigned long)info->fix.smem_start,\r\ninfo->screen_base);\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret < 0)\r\ndev_err(info->device, "Alloc color map failed\n");\r\nreturn ret;\r\n}\r\nstatic void atmel_lcdfb_start_clock(struct atmel_lcdfb_info *sinfo)\r\n{\r\nclk_enable(sinfo->bus_clk);\r\nclk_enable(sinfo->lcdc_clk);\r\n}\r\nstatic void atmel_lcdfb_stop_clock(struct atmel_lcdfb_info *sinfo)\r\n{\r\nclk_disable(sinfo->bus_clk);\r\nclk_disable(sinfo->lcdc_clk);\r\n}\r\nstatic int __init atmel_lcdfb_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fb_info *info;\r\nstruct atmel_lcdfb_info *sinfo;\r\nstruct atmel_lcdfb_info *pdata_sinfo;\r\nstruct fb_videomode fbmode;\r\nstruct resource *regs = NULL;\r\nstruct resource *map = NULL;\r\nint ret;\r\ndev_dbg(dev, "%s BEGIN\n", __func__);\r\nret = -ENOMEM;\r\ninfo = framebuffer_alloc(sizeof(struct atmel_lcdfb_info), dev);\r\nif (!info) {\r\ndev_err(dev, "cannot allocate memory\n");\r\ngoto out;\r\n}\r\nsinfo = info->par;\r\nif (dev->platform_data) {\r\npdata_sinfo = (struct atmel_lcdfb_info *)dev->platform_data;\r\nsinfo->default_bpp = pdata_sinfo->default_bpp;\r\nsinfo->default_dmacon = pdata_sinfo->default_dmacon;\r\nsinfo->default_lcdcon2 = pdata_sinfo->default_lcdcon2;\r\nsinfo->default_monspecs = pdata_sinfo->default_monspecs;\r\nsinfo->atmel_lcdfb_power_control = pdata_sinfo->atmel_lcdfb_power_control;\r\nsinfo->guard_time = pdata_sinfo->guard_time;\r\nsinfo->smem_len = pdata_sinfo->smem_len;\r\nsinfo->lcdcon_is_backlight = pdata_sinfo->lcdcon_is_backlight;\r\nsinfo->lcdcon_pol_negative = pdata_sinfo->lcdcon_pol_negative;\r\nsinfo->lcd_wiring_mode = pdata_sinfo->lcd_wiring_mode;\r\n} else {\r\ndev_err(dev, "cannot get default configuration\n");\r\ngoto free_info;\r\n}\r\nsinfo->info = info;\r\nsinfo->pdev = pdev;\r\nsinfo->config = atmel_lcdfb_get_config(pdev);\r\nif (!sinfo->config)\r\ngoto free_info;\r\nstrcpy(info->fix.id, sinfo->pdev->name);\r\ninfo->flags = ATMEL_LCDFB_FBINFO_DEFAULT;\r\ninfo->pseudo_palette = sinfo->pseudo_palette;\r\ninfo->fbops = &atmel_lcdfb_ops;\r\nmemcpy(&info->monspecs, sinfo->default_monspecs, sizeof(info->monspecs));\r\ninfo->fix = atmel_lcdfb_fix;\r\nsinfo->bus_clk = clk_get(dev, "hclk");\r\nif (IS_ERR(sinfo->bus_clk)) {\r\nret = PTR_ERR(sinfo->bus_clk);\r\ngoto free_info;\r\n}\r\nsinfo->lcdc_clk = clk_get(dev, "lcdc_clk");\r\nif (IS_ERR(sinfo->lcdc_clk)) {\r\nret = PTR_ERR(sinfo->lcdc_clk);\r\ngoto put_bus_clk;\r\n}\r\natmel_lcdfb_start_clock(sinfo);\r\nret = fb_find_mode(&info->var, info, NULL, info->monspecs.modedb,\r\ninfo->monspecs.modedb_len, info->monspecs.modedb,\r\nsinfo->default_bpp);\r\nif (!ret) {\r\ndev_err(dev, "no suitable video mode found\n");\r\ngoto stop_clk;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_err(dev, "resources unusable\n");\r\nret = -ENXIO;\r\ngoto stop_clk;\r\n}\r\nsinfo->irq_base = platform_get_irq(pdev, 0);\r\nif (sinfo->irq_base < 0) {\r\ndev_err(dev, "unable to get irq\n");\r\nret = sinfo->irq_base;\r\ngoto stop_clk;\r\n}\r\nmap = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (map) {\r\ninfo->fix.smem_start = map->start;\r\ninfo->fix.smem_len = resource_size(map);\r\nif (!request_mem_region(info->fix.smem_start,\r\ninfo->fix.smem_len, pdev->name)) {\r\nret = -EBUSY;\r\ngoto stop_clk;\r\n}\r\ninfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\r\nif (!info->screen_base) {\r\nret = -ENOMEM;\r\ngoto release_intmem;\r\n}\r\n} else {\r\nret = atmel_lcdfb_alloc_video_memory(sinfo);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot allocate framebuffer: %d\n", ret);\r\ngoto stop_clk;\r\n}\r\n}\r\ninfo->fix.mmio_start = regs->start;\r\ninfo->fix.mmio_len = resource_size(regs);\r\nif (!request_mem_region(info->fix.mmio_start,\r\ninfo->fix.mmio_len, pdev->name)) {\r\nret = -EBUSY;\r\ngoto free_fb;\r\n}\r\nsinfo->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);\r\nif (!sinfo->mmio) {\r\ndev_err(dev, "cannot map LCDC registers\n");\r\nret = -ENOMEM;\r\ngoto release_mem;\r\n}\r\ninit_contrast(sinfo);\r\nret = request_irq(sinfo->irq_base, atmel_lcdfb_interrupt, 0, pdev->name, info);\r\nif (ret) {\r\ndev_err(dev, "request_irq failed: %d\n", ret);\r\ngoto unmap_mmio;\r\n}\r\nINIT_WORK(&sinfo->task, atmel_lcdfb_task);\r\nret = atmel_lcdfb_init_fbinfo(sinfo);\r\nif (ret < 0) {\r\ndev_err(dev, "init fbinfo failed: %d\n", ret);\r\ngoto unregister_irqs;\r\n}\r\natmel_lcdfb_check_var(&info->var, info);\r\nret = fb_set_var(info, &info->var);\r\nif (ret) {\r\ndev_warn(dev, "unable to set display parameters\n");\r\ngoto free_cmap;\r\n}\r\ndev_set_drvdata(dev, info);\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register framebuffer device: %d\n", ret);\r\ngoto reset_drvdata;\r\n}\r\nfb_var_to_videomode(&fbmode, &info->var);\r\nfb_add_videomode(&fbmode, &info->modelist);\r\nif (sinfo->atmel_lcdfb_power_control)\r\nsinfo->atmel_lcdfb_power_control(1);\r\ndev_info(dev, "fb%d: Atmel LCDC at 0x%08lx (mapped at %p), irq %d\n",\r\ninfo->node, info->fix.mmio_start, sinfo->mmio, sinfo->irq_base);\r\nreturn 0;\r\nreset_drvdata:\r\ndev_set_drvdata(dev, NULL);\r\nfree_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nunregister_irqs:\r\ncancel_work_sync(&sinfo->task);\r\nfree_irq(sinfo->irq_base, info);\r\nunmap_mmio:\r\nexit_backlight(sinfo);\r\niounmap(sinfo->mmio);\r\nrelease_mem:\r\nrelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\r\nfree_fb:\r\nif (map)\r\niounmap(info->screen_base);\r\nelse\r\natmel_lcdfb_free_video_memory(sinfo);\r\nrelease_intmem:\r\nif (map)\r\nrelease_mem_region(info->fix.smem_start, info->fix.smem_len);\r\nstop_clk:\r\natmel_lcdfb_stop_clock(sinfo);\r\nclk_put(sinfo->lcdc_clk);\r\nput_bus_clk:\r\nclk_put(sinfo->bus_clk);\r\nfree_info:\r\nframebuffer_release(info);\r\nout:\r\ndev_dbg(dev, "%s FAILED\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int __exit atmel_lcdfb_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct atmel_lcdfb_info *sinfo;\r\nif (!info || !info->par)\r\nreturn 0;\r\nsinfo = info->par;\r\ncancel_work_sync(&sinfo->task);\r\nexit_backlight(sinfo);\r\nif (sinfo->atmel_lcdfb_power_control)\r\nsinfo->atmel_lcdfb_power_control(0);\r\nunregister_framebuffer(info);\r\natmel_lcdfb_stop_clock(sinfo);\r\nclk_put(sinfo->lcdc_clk);\r\nclk_put(sinfo->bus_clk);\r\nfb_dealloc_cmap(&info->cmap);\r\nfree_irq(sinfo->irq_base, info);\r\niounmap(sinfo->mmio);\r\nrelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\r\nif (platform_get_resource(pdev, IORESOURCE_MEM, 1)) {\r\niounmap(info->screen_base);\r\nrelease_mem_region(info->fix.smem_start, info->fix.smem_len);\r\n} else {\r\natmel_lcdfb_free_video_memory(sinfo);\r\n}\r\ndev_set_drvdata(dev, NULL);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int atmel_lcdfb_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\nlcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);\r\nsinfo->saved_lcdcon = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_CTR);\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, 0);\r\nif (sinfo->atmel_lcdfb_power_control)\r\nsinfo->atmel_lcdfb_power_control(0);\r\natmel_lcdfb_stop(sinfo);\r\natmel_lcdfb_stop_clock(sinfo);\r\nreturn 0;\r\n}\r\nstatic int atmel_lcdfb_resume(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct atmel_lcdfb_info *sinfo = info->par;\r\natmel_lcdfb_start_clock(sinfo);\r\natmel_lcdfb_start(sinfo);\r\nif (sinfo->atmel_lcdfb_power_control)\r\nsinfo->atmel_lcdfb_power_control(1);\r\nlcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, sinfo->saved_lcdcon);\r\nlcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI\r\n| ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);\r\nreturn 0;\r\n}
