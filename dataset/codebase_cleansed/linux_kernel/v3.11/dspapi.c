static inline void _cp_fm_usr(void *to, const void __user * from,\r\nint *err, unsigned long bytes)\r\n{\r\nif (*err)\r\nreturn;\r\nif (unlikely(!from)) {\r\n*err = -EFAULT;\r\nreturn;\r\n}\r\nif (unlikely(copy_from_user(to, from, bytes)))\r\n*err = -EFAULT;\r\n}\r\nstatic inline void _cp_to_usr(void __user *to, const void *from,\r\nint *err, unsigned long bytes)\r\n{\r\nif (*err)\r\nreturn;\r\nif (unlikely(!to)) {\r\n*err = -EFAULT;\r\nreturn;\r\n}\r\nif (unlikely(copy_to_user(to, from, bytes)))\r\n*err = -EFAULT;\r\n}\r\ninline int api_call_dev_ioctl(u32 cmd, union trapped_args *args,\r\nu32 *result, void *pr_ctxt)\r\n{\r\nu32(*ioctl_cmd) (union trapped_args *args, void *pr_ctxt) = NULL;\r\nint i;\r\nif (_IOC_TYPE(cmd) != DB) {\r\npr_err("%s: Incompatible dspbridge ioctl number\n", __func__);\r\ngoto err;\r\n}\r\nif (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd)) {\r\npr_err("%s: undefined ioctl module\n", __func__);\r\ngoto err;\r\n}\r\ni = DB_GET_IOC(cmd);\r\nif (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {\r\npr_err("%s: requested ioctl %d out of bounds for table %d\n",\r\n__func__, i, DB_GET_IOC_TABLE(cmd));\r\ngoto err;\r\n}\r\nswitch (DB_GET_MODULE(cmd)) {\r\ncase DB_MGR:\r\nioctl_cmd = mgr_cmd[i].fxn;\r\nbreak;\r\ncase DB_PROC:\r\nioctl_cmd = proc_cmd[i].fxn;\r\nbreak;\r\ncase DB_NODE:\r\nioctl_cmd = node_cmd[i].fxn;\r\nbreak;\r\ncase DB_STRM:\r\nioctl_cmd = strm_cmd[i].fxn;\r\nbreak;\r\ncase DB_CMM:\r\nioctl_cmd = cmm_cmd[i].fxn;\r\nbreak;\r\n}\r\nif (!ioctl_cmd) {\r\npr_err("%s: requested ioctl not defined\n", __func__);\r\ngoto err;\r\n} else {\r\n*result = (*ioctl_cmd) (args, pr_ctxt);\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nvoid api_exit(void)\r\n{\r\napi_c_refs--;\r\nif (api_c_refs == 0)\r\nmgr_exit();\r\n}\r\nbool api_init(void)\r\n{\r\nbool ret = true;\r\nif (api_c_refs == 0)\r\nret = mgr_init();\r\nif (ret)\r\napi_c_refs++;\r\nreturn ret;\r\n}\r\nint api_init_complete2(void)\r\n{\r\nint status = 0;\r\nstruct cfg_devnode *dev_node;\r\nstruct dev_object *hdev_obj;\r\nstruct drv_data *drv_datap;\r\nu8 dev_type;\r\nfor (hdev_obj = dev_get_first(); hdev_obj != NULL;\r\nhdev_obj = dev_get_next(hdev_obj)) {\r\nif (dev_get_dev_node(hdev_obj, &dev_node))\r\ncontinue;\r\nif (dev_get_dev_type(hdev_obj, &dev_type))\r\ncontinue;\r\nif ((dev_type == DSP_UNIT) || (dev_type == IVA_UNIT)) {\r\ndrv_datap = dev_get_drvdata(bridge);\r\nif (drv_datap && drv_datap->base_img)\r\nproc_auto_start(dev_node, hdev_obj);\r\n}\r\n}\r\nreturn status;\r\n}\r\nu32 mgrwrap_enum_node_info(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu8 *pndb_props;\r\nu32 num_nodes;\r\nint status = 0;\r\nu32 size = args->args_mgr_enumnode_info.ndb_props_size;\r\nif (size < sizeof(struct dsp_ndbprops))\r\nreturn -EINVAL;\r\npndb_props = kmalloc(size, GFP_KERNEL);\r\nif (pndb_props == NULL)\r\nstatus = -ENOMEM;\r\nif (!status) {\r\nstatus =\r\nmgr_enum_node_info(args->args_mgr_enumnode_info.node_id,\r\n(struct dsp_ndbprops *)pndb_props, size,\r\n&num_nodes);\r\n}\r\nCP_TO_USR(args->args_mgr_enumnode_info.ndb_props, pndb_props, status,\r\nsize);\r\nCP_TO_USR(args->args_mgr_enumnode_info.num_nodes, &num_nodes, status,\r\n1);\r\nkfree(pndb_props);\r\nreturn status;\r\n}\r\nu32 mgrwrap_enum_proc_info(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu8 *processor_info;\r\nu8 num_procs;\r\nint status = 0;\r\nu32 size = args->args_mgr_enumproc_info.processor_info_size;\r\nif (size < sizeof(struct dsp_processorinfo))\r\nreturn -EINVAL;\r\nprocessor_info = kmalloc(size, GFP_KERNEL);\r\nif (processor_info == NULL)\r\nstatus = -ENOMEM;\r\nif (!status) {\r\nstatus =\r\nmgr_enum_processor_info(args->args_mgr_enumproc_info.\r\nprocessor_id,\r\n(struct dsp_processorinfo *)\r\nprocessor_info, size, &num_procs);\r\n}\r\nCP_TO_USR(args->args_mgr_enumproc_info.processor_info, processor_info,\r\nstatus, size);\r\nCP_TO_USR(args->args_mgr_enumproc_info.num_procs, &num_procs,\r\nstatus, 1);\r\nkfree(processor_info);\r\nreturn status;\r\n}\r\nu32 mgrwrap_register_object(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct dsp_uuid uuid_obj;\r\nu32 path_size = 0;\r\nchar *psz_path_name = NULL;\r\nint status = 0;\r\nCP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);\r\nif (status)\r\ngoto func_end;\r\npath_size = strlen_user((char *)\r\nargs->args_mgr_registerobject.sz_path_name);\r\nif (!path_size) {\r\nstatus = -EINVAL;\r\ngoto func_end;\r\n}\r\npsz_path_name = kmalloc(path_size, GFP_KERNEL);\r\nif (!psz_path_name) {\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\nret = strncpy_from_user(psz_path_name,\r\n(char *)args->args_mgr_registerobject.\r\nsz_path_name, path_size);\r\nif (!ret) {\r\nstatus = -EFAULT;\r\ngoto func_end;\r\n}\r\nif (args->args_mgr_registerobject.obj_type >= DSP_DCDMAXOBJTYPE) {\r\nstatus = -EINVAL;\r\ngoto func_end;\r\n}\r\nstatus = dcd_register_object(&uuid_obj,\r\nargs->args_mgr_registerobject.obj_type,\r\n(char *)psz_path_name);\r\nfunc_end:\r\nkfree(psz_path_name);\r\nreturn status;\r\n}\r\nu32 mgrwrap_unregister_object(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_uuid uuid_obj;\r\nCP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);\r\nif (status)\r\ngoto func_end;\r\nstatus = dcd_unregister_object(&uuid_obj,\r\nargs->args_mgr_unregisterobject.\r\nobj_type);\r\nfunc_end:\r\nreturn status;\r\n}\r\nu32 mgrwrap_wait_for_bridge_events(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_notification *anotifications[MAX_EVENTS];\r\nstruct dsp_notification notifications[MAX_EVENTS];\r\nu32 index, i;\r\nu32 count = args->args_mgr_wait.count;\r\nif (count > MAX_EVENTS)\r\nstatus = -EINVAL;\r\nCP_FM_USR(anotifications, args->args_mgr_wait.anotifications,\r\nstatus, count);\r\nfor (i = 0; i < count; i++) {\r\nCP_FM_USR(&notifications[i], anotifications[i], status, 1);\r\nif (status || !notifications[i].handle) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nanotifications[i] = &notifications[i];\r\n}\r\nif (!status) {\r\nstatus = mgr_wait_for_bridge_events(anotifications, count,\r\n&index,\r\nargs->args_mgr_wait.\r\ntimeout);\r\n}\r\nCP_TO_USR(args->args_mgr_wait.index, &index, status, 1);\r\nreturn status;\r\n}\r\nu32 __deprecated mgrwrap_get_process_resources_info(union trapped_args * args,\r\nvoid *pr_ctxt)\r\n{\r\npr_err("%s: deprecated dspbridge ioctl\n", __func__);\r\nreturn 0;\r\n}\r\nu32 procwrap_attach(union trapped_args *args, void *pr_ctxt)\r\n{\r\nvoid *processor;\r\nint status = 0;\r\nstruct dsp_processorattrin proc_attr_in, *attr_in = NULL;\r\nif (args->args_proc_attach.attr_in) {\r\nCP_FM_USR(&proc_attr_in, args->args_proc_attach.attr_in, status,\r\n1);\r\nif (!status)\r\nattr_in = &proc_attr_in;\r\nelse\r\ngoto func_end;\r\n}\r\nstatus = proc_attach(args->args_proc_attach.processor_id, attr_in,\r\n&processor, pr_ctxt);\r\nCP_TO_USR(args->args_proc_attach.ph_processor, &processor, status, 1);\r\nfunc_end:\r\nreturn status;\r\n}\r\nu32 procwrap_ctrl(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 cb_data_size, __user * psize = (u32 __user *)\r\nargs->args_proc_ctrl.args;\r\nu8 *pargs = NULL;\r\nint status = 0;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (psize) {\r\nif (get_user(cb_data_size, psize)) {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\ncb_data_size += sizeof(u32);\r\npargs = kmalloc(cb_data_size, GFP_KERNEL);\r\nif (pargs == NULL) {\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\nCP_FM_USR(pargs, args->args_proc_ctrl.args, status,\r\ncb_data_size);\r\n}\r\nif (!status) {\r\nstatus = proc_ctrl(hprocessor,\r\nargs->args_proc_ctrl.cmd,\r\n(struct dsp_cbdata *)pargs);\r\n}\r\nkfree(pargs);\r\nfunc_end:\r\nreturn status;\r\n}\r\nu32 __deprecated procwrap_detach(union trapped_args * args, void *pr_ctxt)\r\n{\r\npr_err("%s: deprecated dspbridge ioctl\n", __func__);\r\nreturn 0;\r\n}\r\nu32 procwrap_enum_node_info(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nvoid *node_tab[MAX_NODES];\r\nu32 num_nodes;\r\nu32 alloc_cnt;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (!args->args_proc_enumnode_info.node_tab_size)\r\nreturn -EINVAL;\r\nstatus = proc_enum_nodes(hprocessor,\r\nnode_tab,\r\nargs->args_proc_enumnode_info.node_tab_size,\r\n&num_nodes, &alloc_cnt);\r\nCP_TO_USR(args->args_proc_enumnode_info.node_tab, node_tab, status,\r\nnum_nodes);\r\nCP_TO_USR(args->args_proc_enumnode_info.num_nodes, &num_nodes,\r\nstatus, 1);\r\nCP_TO_USR(args->args_proc_enumnode_info.allocated, &alloc_cnt,\r\nstatus, 1);\r\nreturn status;\r\n}\r\nu32 procwrap_end_dma(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nif (args->args_proc_dma.dir >= DMA_NONE)\r\nreturn -EINVAL;\r\nstatus = proc_end_dma(pr_ctxt,\r\nargs->args_proc_dma.mpu_addr,\r\nargs->args_proc_dma.size,\r\nargs->args_proc_dma.dir);\r\nreturn status;\r\n}\r\nu32 procwrap_begin_dma(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nif (args->args_proc_dma.dir >= DMA_NONE)\r\nreturn -EINVAL;\r\nstatus = proc_begin_dma(pr_ctxt,\r\nargs->args_proc_dma.mpu_addr,\r\nargs->args_proc_dma.size,\r\nargs->args_proc_dma.dir);\r\nreturn status;\r\n}\r\nu32 procwrap_flush_memory(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nif (args->args_proc_flushmemory.flags >\r\nPROC_WRITEBACK_INVALIDATE_MEM)\r\nreturn -EINVAL;\r\nstatus = proc_flush_memory(pr_ctxt,\r\nargs->args_proc_flushmemory.mpu_addr,\r\nargs->args_proc_flushmemory.size,\r\nargs->args_proc_flushmemory.flags);\r\nreturn status;\r\n}\r\nu32 procwrap_invalidate_memory(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nstatus =\r\nproc_invalidate_memory(pr_ctxt,\r\nargs->args_proc_invalidatememory.mpu_addr,\r\nargs->args_proc_invalidatememory.size);\r\nreturn status;\r\n}\r\nu32 procwrap_enum_resources(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_resourceinfo resource_info;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (args->args_proc_enumresources.resource_info_size <\r\nsizeof(struct dsp_resourceinfo))\r\nreturn -EINVAL;\r\nstatus =\r\nproc_get_resource_info(hprocessor,\r\nargs->args_proc_enumresources.resource_type,\r\n&resource_info,\r\nargs->args_proc_enumresources.\r\nresource_info_size);\r\nCP_TO_USR(args->args_proc_enumresources.resource_info, &resource_info,\r\nstatus, 1);\r\nreturn status;\r\n}\r\nu32 procwrap_get_state(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nstruct dsp_processorstate proc_state;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (args->args_proc_getstate.state_info_size <\r\nsizeof(struct dsp_processorstate))\r\nreturn -EINVAL;\r\nstatus = proc_get_state(hprocessor, &proc_state,\r\nargs->args_proc_getstate.state_info_size);\r\nCP_TO_USR(args->args_proc_getstate.proc_state_obj, &proc_state, status,\r\n1);\r\nreturn status;\r\n}\r\nu32 procwrap_get_trace(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nu8 *pbuf;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)\r\nreturn -EINVAL;\r\npbuf = kzalloc(args->args_proc_gettrace.max_size, GFP_KERNEL);\r\nif (pbuf != NULL) {\r\nstatus = proc_get_trace(hprocessor, pbuf,\r\nargs->args_proc_gettrace.max_size);\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nCP_TO_USR(args->args_proc_gettrace.buf, pbuf, status,\r\nargs->args_proc_gettrace.max_size);\r\nkfree(pbuf);\r\nreturn status;\r\n}\r\nu32 procwrap_load(union trapped_args *args, void *pr_ctxt)\r\n{\r\ns32 i, len;\r\nint status = 0;\r\nchar *temp;\r\ns32 count = args->args_proc_load.argc_index;\r\nu8 **argv = NULL, **envp = NULL;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (count <= 0 || count > MAX_LOADARGS) {\r\nstatus = -EINVAL;\r\ngoto func_cont;\r\n}\r\nargv = kmalloc(count * sizeof(u8 *), GFP_KERNEL);\r\nif (!argv) {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\nCP_FM_USR(argv, args->args_proc_load.user_args, status, count);\r\nif (status) {\r\nkfree(argv);\r\nargv = NULL;\r\ngoto func_cont;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (argv[i]) {\r\ntemp = (char *)argv[i];\r\nlen = strlen_user((char *)temp) + 1;\r\nargv[i] = kmalloc(len, GFP_KERNEL);\r\nif (argv[i]) {\r\nCP_FM_USR(argv[i], temp, status, len);\r\nif (status) {\r\nkfree(argv[i]);\r\nargv[i] = NULL;\r\ngoto func_cont;\r\n}\r\n} else {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\n}\r\n}\r\nif (args->args_proc_load.user_envp) {\r\ncount = 0;\r\ndo {\r\nif (get_user(temp,\r\nargs->args_proc_load.user_envp + count)) {\r\nstatus = -EFAULT;\r\ngoto func_cont;\r\n}\r\ncount++;\r\n} while (temp);\r\nenvp = kmalloc(count * sizeof(u8 *), GFP_KERNEL);\r\nif (!envp) {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\nCP_FM_USR(envp, args->args_proc_load.user_envp, status, count);\r\nif (status) {\r\nkfree(envp);\r\nenvp = NULL;\r\ngoto func_cont;\r\n}\r\nfor (i = 0; envp[i]; i++) {\r\ntemp = (char *)envp[i];\r\nlen = strlen_user((char *)temp) + 1;\r\nenvp[i] = kmalloc(len, GFP_KERNEL);\r\nif (envp[i]) {\r\nCP_FM_USR(envp[i], temp, status, len);\r\nif (status) {\r\nkfree(envp[i]);\r\nenvp[i] = NULL;\r\ngoto func_cont;\r\n}\r\n} else {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\n}\r\n}\r\nif (!status) {\r\nstatus = proc_load(hprocessor,\r\nargs->args_proc_load.argc_index,\r\n(const char **)argv, (const char **)envp);\r\n}\r\nfunc_cont:\r\nif (envp) {\r\ni = 0;\r\nwhile (envp[i])\r\nkfree(envp[i++]);\r\nkfree(envp);\r\n}\r\nif (argv) {\r\ncount = args->args_proc_load.argc_index;\r\nfor (i = 0; (i < count) && argv[i]; i++)\r\nkfree(argv[i]);\r\nkfree(argv);\r\n}\r\nreturn status;\r\n}\r\nu32 procwrap_map(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nvoid *map_addr;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (!args->args_proc_mapmem.size)\r\nreturn -EINVAL;\r\nstatus = proc_map(args->args_proc_mapmem.processor,\r\nargs->args_proc_mapmem.mpu_addr,\r\nargs->args_proc_mapmem.size,\r\nargs->args_proc_mapmem.req_addr, &map_addr,\r\nargs->args_proc_mapmem.map_attr, pr_ctxt);\r\nif (!status) {\r\nif (put_user(map_addr, args->args_proc_mapmem.map_addr)) {\r\nstatus = -EINVAL;\r\nproc_un_map(hprocessor, map_addr, pr_ctxt);\r\n}\r\n}\r\nreturn status;\r\n}\r\nu32 procwrap_register_notify(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nstruct dsp_notification notification;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nnotification.name = NULL;\r\nnotification.handle = NULL;\r\nstatus = proc_register_notify(hprocessor,\r\nargs->args_proc_register_notify.event_mask,\r\nargs->args_proc_register_notify.notify_type,\r\n&notification);\r\nCP_TO_USR(args->args_proc_register_notify.notification, &notification,\r\nstatus, 1);\r\nreturn status;\r\n}\r\nu32 procwrap_reserve_memory(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nvoid *prsv_addr;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif ((args->args_proc_rsvmem.size <= 0) ||\r\n(args->args_proc_rsvmem.size & (PG_SIZE4K - 1)) != 0)\r\nreturn -EINVAL;\r\nstatus = proc_reserve_memory(hprocessor,\r\nargs->args_proc_rsvmem.size, &prsv_addr,\r\npr_ctxt);\r\nif (!status) {\r\nif (put_user(prsv_addr, args->args_proc_rsvmem.rsv_addr)) {\r\nstatus = -EINVAL;\r\nproc_un_reserve_memory(args->args_proc_rsvmem.\r\nprocessor, prsv_addr, pr_ctxt);\r\n}\r\n}\r\nreturn status;\r\n}\r\nu32 procwrap_start(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nret = proc_start(((struct process_context *)pr_ctxt)->processor);\r\nreturn ret;\r\n}\r\nu32 procwrap_un_map(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nstatus = proc_un_map(((struct process_context *)pr_ctxt)->processor,\r\nargs->args_proc_unmapmem.map_addr, pr_ctxt);\r\nreturn status;\r\n}\r\nu32 procwrap_un_reserve_memory(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nstatus = proc_un_reserve_memory(hprocessor,\r\nargs->args_proc_unrsvmem.rsv_addr,\r\npr_ctxt);\r\nreturn status;\r\n}\r\nu32 procwrap_stop(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nret = proc_stop(((struct process_context *)pr_ctxt)->processor);\r\nreturn ret;\r\n}\r\ninline void find_node_handle(struct node_res_object **noderes,\r\nvoid *pr_ctxt, void *hnode)\r\n{\r\nrcu_read_lock();\r\n*noderes = idr_find(((struct process_context *)pr_ctxt)->node_id,\r\n(int)hnode - 1);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nu32 nodewrap_allocate(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_uuid node_uuid;\r\nu32 cb_data_size = 0;\r\nu32 __user *psize = (u32 __user *) args->args_node_allocate.args;\r\nu8 *pargs = NULL;\r\nstruct dsp_nodeattrin proc_attr_in, *attr_in = NULL;\r\nstruct node_res_object *node_res;\r\nint nodeid;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nif (psize) {\r\nif (get_user(cb_data_size, psize))\r\nstatus = -EPERM;\r\ncb_data_size += sizeof(u32);\r\nif (!status) {\r\npargs = kmalloc(cb_data_size, GFP_KERNEL);\r\nif (pargs == NULL)\r\nstatus = -ENOMEM;\r\n}\r\nCP_FM_USR(pargs, args->args_node_allocate.args, status,\r\ncb_data_size);\r\n}\r\nCP_FM_USR(&node_uuid, args->args_node_allocate.node_id_ptr, status, 1);\r\nif (status)\r\ngoto func_cont;\r\nif (args->args_node_allocate.attr_in) {\r\nCP_FM_USR(&proc_attr_in, args->args_node_allocate.attr_in,\r\nstatus, 1);\r\nif (!status)\r\nattr_in = &proc_attr_in;\r\nelse\r\nstatus = -ENOMEM;\r\n}\r\nif (!status) {\r\nstatus = node_allocate(hprocessor,\r\n&node_uuid, (struct dsp_cbdata *)pargs,\r\nattr_in, &node_res, pr_ctxt);\r\n}\r\nif (!status) {\r\nnodeid = node_res->id + 1;\r\nCP_TO_USR(args->args_node_allocate.node, &nodeid,\r\nstatus, 1);\r\nif (status) {\r\nstatus = -EFAULT;\r\nnode_delete(node_res, pr_ctxt);\r\n}\r\n}\r\nfunc_cont:\r\nkfree(pargs);\r\nreturn status;\r\n}\r\nu32 nodewrap_alloc_msg_buf(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_bufferattr *pattr = NULL;\r\nstruct dsp_bufferattr attr;\r\nu8 *pbuffer = NULL;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt,\r\nargs->args_node_allocmsgbuf.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nif (!args->args_node_allocmsgbuf.size)\r\nreturn -EINVAL;\r\nif (args->args_node_allocmsgbuf.attr) {\r\nCP_FM_USR(&attr, args->args_node_allocmsgbuf.attr, status, 1);\r\nif (!status)\r\npattr = &attr;\r\n}\r\nCP_FM_USR(&pbuffer, args->args_node_allocmsgbuf.buffer, status, 1);\r\nif (!status) {\r\nstatus = node_alloc_msg_buf(node_res->node,\r\nargs->args_node_allocmsgbuf.size,\r\npattr, &pbuffer);\r\n}\r\nCP_TO_USR(args->args_node_allocmsgbuf.buffer, &pbuffer, status, 1);\r\nreturn status;\r\n}\r\nu32 nodewrap_change_priority(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt,\r\nargs->args_node_changepriority.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nret = node_change_priority(node_res->node,\r\nargs->args_node_changepriority.prio);\r\nreturn ret;\r\n}\r\nu32 nodewrap_connect(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_strmattr attrs;\r\nstruct dsp_strmattr *pattrs = NULL;\r\nu32 cb_data_size;\r\nu32 __user *psize = (u32 __user *) args->args_node_connect.conn_param;\r\nu8 *pargs = NULL;\r\nstruct node_res_object *node_res1, *node_res2;\r\nstruct node_object *node1 = NULL, *node2 = NULL;\r\nif ((int)args->args_node_connect.node != DSP_HGPPNODE) {\r\nfind_node_handle(&node_res1, pr_ctxt,\r\nargs->args_node_connect.node);\r\nif (node_res1)\r\nnode1 = node_res1->node;\r\n} else {\r\nnode1 = args->args_node_connect.node;\r\n}\r\nif ((int)args->args_node_connect.other_node != DSP_HGPPNODE) {\r\nfind_node_handle(&node_res2, pr_ctxt,\r\nargs->args_node_connect.other_node);\r\nif (node_res2)\r\nnode2 = node_res2->node;\r\n} else {\r\nnode2 = args->args_node_connect.other_node;\r\n}\r\nif (!node1 || !node2)\r\nreturn -EFAULT;\r\nif (psize) {\r\nif (get_user(cb_data_size, psize))\r\nstatus = -EPERM;\r\ncb_data_size += sizeof(u32);\r\nif (!status) {\r\npargs = kmalloc(cb_data_size, GFP_KERNEL);\r\nif (pargs == NULL) {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\n}\r\nCP_FM_USR(pargs, args->args_node_connect.conn_param, status,\r\ncb_data_size);\r\nif (status)\r\ngoto func_cont;\r\n}\r\nif (args->args_node_connect.attrs) {\r\nCP_FM_USR(&attrs, args->args_node_connect.attrs, status, 1);\r\nif (!status)\r\npattrs = &attrs;\r\n}\r\nif (!status) {\r\nstatus = node_connect(node1,\r\nargs->args_node_connect.stream_id,\r\nnode2,\r\nargs->args_node_connect.other_stream,\r\npattrs, (struct dsp_cbdata *)pargs);\r\n}\r\nfunc_cont:\r\nkfree(pargs);\r\nreturn status;\r\n}\r\nu32 nodewrap_create(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_create.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nret = node_create(node_res->node);\r\nreturn ret;\r\n}\r\nu32 nodewrap_delete(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_delete.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nret = node_delete(node_res, pr_ctxt);\r\nreturn ret;\r\n}\r\nu32 nodewrap_free_msg_buf(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_bufferattr *pattr = NULL;\r\nstruct dsp_bufferattr attr;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_freemsgbuf.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nif (args->args_node_freemsgbuf.attr) {\r\nCP_FM_USR(&attr, args->args_node_freemsgbuf.attr, status, 1);\r\nif (!status)\r\npattr = &attr;\r\n}\r\nif (!args->args_node_freemsgbuf.buffer)\r\nreturn -EFAULT;\r\nif (!status) {\r\nstatus = node_free_msg_buf(node_res->node,\r\nargs->args_node_freemsgbuf.buffer,\r\npattr);\r\n}\r\nreturn status;\r\n}\r\nu32 nodewrap_get_attr(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_nodeattr attr;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_getattr.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nstatus = node_get_attr(node_res->node, &attr,\r\nargs->args_node_getattr.attr_size);\r\nCP_TO_USR(args->args_node_getattr.attr, &attr, status, 1);\r\nreturn status;\r\n}\r\nu32 nodewrap_get_message(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nstruct dsp_msg msg;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_getmessage.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nstatus = node_get_message(node_res->node, &msg,\r\nargs->args_node_getmessage.timeout);\r\nCP_TO_USR(args->args_node_getmessage.message, &msg, status, 1);\r\nreturn status;\r\n}\r\nu32 nodewrap_pause(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_pause.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nret = node_pause(node_res->node);\r\nreturn ret;\r\n}\r\nu32 nodewrap_put_message(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_msg msg;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_putmessage.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nCP_FM_USR(&msg, args->args_node_putmessage.message, status, 1);\r\nif (!status) {\r\nstatus =\r\nnode_put_message(node_res->node, &msg,\r\nargs->args_node_putmessage.timeout);\r\n}\r\nreturn status;\r\n}\r\nu32 nodewrap_register_notify(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_notification notification;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt,\r\nargs->args_node_registernotify.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nnotification.name = NULL;\r\nnotification.handle = NULL;\r\nif (!args->args_proc_register_notify.event_mask)\r\nCP_FM_USR(&notification,\r\nargs->args_proc_register_notify.notification,\r\nstatus, 1);\r\nstatus = node_register_notify(node_res->node,\r\nargs->args_node_registernotify.event_mask,\r\nargs->args_node_registernotify.\r\nnotify_type, &notification);\r\nCP_TO_USR(args->args_node_registernotify.notification, &notification,\r\nstatus, 1);\r\nreturn status;\r\n}\r\nu32 nodewrap_run(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_run.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nret = node_run(node_res->node);\r\nreturn ret;\r\n}\r\nu32 nodewrap_terminate(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nint tempstatus;\r\nstruct node_res_object *node_res;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_node_terminate.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nstatus = node_terminate(node_res->node, &tempstatus);\r\nCP_TO_USR(args->args_node_terminate.status, &tempstatus, status, 1);\r\nreturn status;\r\n}\r\nu32 nodewrap_get_uuid_props(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_uuid node_uuid;\r\nstruct dsp_ndbprops *pnode_props = NULL;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nCP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,\r\n1);\r\nif (status)\r\ngoto func_cont;\r\npnode_props = kmalloc(sizeof(struct dsp_ndbprops), GFP_KERNEL);\r\nif (pnode_props != NULL) {\r\nstatus =\r\nnode_get_uuid_props(hprocessor, &node_uuid, pnode_props);\r\nCP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,\r\nstatus, 1);\r\n} else\r\nstatus = -ENOMEM;\r\nfunc_cont:\r\nkfree(pnode_props);\r\nreturn status;\r\n}\r\ninline void find_strm_handle(struct strm_res_object **strmres,\r\nvoid *pr_ctxt, void *hstream)\r\n{\r\nrcu_read_lock();\r\n*strmres = idr_find(((struct process_context *)pr_ctxt)->stream_id,\r\n(int)hstream - 1);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nu32 strmwrap_allocate_buffer(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status;\r\nu8 **ap_buffer = NULL;\r\nu32 num_bufs = args->args_strm_allocatebuffer.num_bufs;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt,\r\nargs->args_strm_allocatebuffer.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nif (num_bufs > MAX_BUFS)\r\nreturn -EINVAL;\r\nap_buffer = kmalloc((num_bufs * sizeof(u8 *)), GFP_KERNEL);\r\nif (ap_buffer == NULL)\r\nreturn -ENOMEM;\r\nstatus = strm_allocate_buffer(strm_res,\r\nargs->args_strm_allocatebuffer.size,\r\nap_buffer, num_bufs, pr_ctxt);\r\nif (!status) {\r\nCP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,\r\nstatus, num_bufs);\r\nif (status) {\r\nstatus = -EFAULT;\r\nstrm_free_buffer(strm_res,\r\nap_buffer, num_bufs, pr_ctxt);\r\n}\r\n}\r\nkfree(ap_buffer);\r\nreturn status;\r\n}\r\nu32 strmwrap_close(union trapped_args *args, void *pr_ctxt)\r\n{\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt, args->args_strm_close.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nreturn strm_close(strm_res, pr_ctxt);\r\n}\r\nu32 strmwrap_free_buffer(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nu8 **ap_buffer = NULL;\r\nu32 num_bufs = args->args_strm_freebuffer.num_bufs;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt,\r\nargs->args_strm_freebuffer.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nif (num_bufs > MAX_BUFS)\r\nreturn -EINVAL;\r\nap_buffer = kmalloc_array(num_bufs, sizeof(u8 *), GFP_KERNEL);\r\nif (ap_buffer == NULL)\r\nreturn -ENOMEM;\r\nCP_FM_USR(ap_buffer, args->args_strm_freebuffer.ap_buffer, status,\r\nnum_bufs);\r\nif (!status)\r\nstatus = strm_free_buffer(strm_res,\r\nap_buffer, num_bufs, pr_ctxt);\r\nCP_TO_USR(args->args_strm_freebuffer.ap_buffer, ap_buffer, status,\r\nnum_bufs);\r\nkfree(ap_buffer);\r\nreturn status;\r\n}\r\nu32 __deprecated strmwrap_get_event_handle(union trapped_args * args,\r\nvoid *pr_ctxt)\r\n{\r\npr_err("%s: deprecated dspbridge ioctl\n", __func__);\r\nreturn -ENOSYS;\r\n}\r\nu32 strmwrap_get_info(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct stream_info strm_info;\r\nstruct dsp_streaminfo user;\r\nstruct dsp_streaminfo *temp;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt,\r\nargs->args_strm_getinfo.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nCP_FM_USR(&strm_info, args->args_strm_getinfo.stream_info, status, 1);\r\ntemp = strm_info.user_strm;\r\nstrm_info.user_strm = &user;\r\nif (!status) {\r\nstatus = strm_get_info(strm_res->stream,\r\n&strm_info,\r\nargs->args_strm_getinfo.\r\nstream_info_size);\r\n}\r\nCP_TO_USR(temp, strm_info.user_strm, status, 1);\r\nstrm_info.user_strm = temp;\r\nCP_TO_USR(args->args_strm_getinfo.stream_info, &strm_info, status, 1);\r\nreturn status;\r\n}\r\nu32 strmwrap_idle(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 ret;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt, args->args_strm_idle.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nret = strm_idle(strm_res->stream, args->args_strm_idle.flush_flag);\r\nreturn ret;\r\n}\r\nu32 strmwrap_issue(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt, args->args_strm_issue.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nif (!args->args_strm_issue.buffer)\r\nreturn -EFAULT;\r\nstatus = strm_issue(strm_res->stream,\r\nargs->args_strm_issue.buffer,\r\nargs->args_strm_issue.bytes,\r\nargs->args_strm_issue.buf_size,\r\nargs->args_strm_issue.arg);\r\nreturn status;\r\n}\r\nu32 strmwrap_open(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct strm_attr attr;\r\nstruct strm_res_object *strm_res_obj;\r\nstruct dsp_streamattrin strm_attr_in;\r\nstruct node_res_object *node_res;\r\nint strmid;\r\nfind_node_handle(&node_res, pr_ctxt, args->args_strm_open.node);\r\nif (!node_res)\r\nreturn -EFAULT;\r\nCP_FM_USR(&attr, args->args_strm_open.attr_in, status, 1);\r\nif (attr.stream_attr_in != NULL) {\r\nCP_FM_USR(&strm_attr_in, attr.stream_attr_in, status, 1);\r\nif (!status) {\r\nattr.stream_attr_in = &strm_attr_in;\r\nif (attr.stream_attr_in->strm_mode == STRMMODE_LDMA)\r\nreturn -ENOSYS;\r\n}\r\n}\r\nstatus = strm_open(node_res->node,\r\nargs->args_strm_open.direction,\r\nargs->args_strm_open.index, &attr, &strm_res_obj,\r\npr_ctxt);\r\nif (!status) {\r\nstrmid = strm_res_obj->id + 1;\r\nCP_TO_USR(args->args_strm_open.stream, &strmid, status, 1);\r\n}\r\nreturn status;\r\n}\r\nu32 strmwrap_reclaim(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nu8 *buf_ptr;\r\nu32 ul_bytes;\r\nu32 dw_arg;\r\nu32 ul_buf_size;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt, args->args_strm_reclaim.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nstatus = strm_reclaim(strm_res->stream, &buf_ptr,\r\n&ul_bytes, &ul_buf_size, &dw_arg);\r\nCP_TO_USR(args->args_strm_reclaim.buf_ptr, &buf_ptr, status, 1);\r\nCP_TO_USR(args->args_strm_reclaim.bytes, &ul_bytes, status, 1);\r\nCP_TO_USR(args->args_strm_reclaim.arg, &dw_arg, status, 1);\r\nif (args->args_strm_reclaim.buf_size_ptr != NULL) {\r\nCP_TO_USR(args->args_strm_reclaim.buf_size_ptr, &ul_buf_size,\r\nstatus, 1);\r\n}\r\nreturn status;\r\n}\r\nu32 strmwrap_register_notify(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct dsp_notification notification;\r\nstruct strm_res_object *strm_res;\r\nfind_strm_handle(&strm_res, pr_ctxt,\r\nargs->args_strm_registernotify.stream);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nnotification.name = NULL;\r\nnotification.handle = NULL;\r\nstatus = strm_register_notify(strm_res->stream,\r\nargs->args_strm_registernotify.event_mask,\r\nargs->args_strm_registernotify.\r\nnotify_type, &notification);\r\nCP_TO_USR(args->args_strm_registernotify.notification, &notification,\r\nstatus, 1);\r\nreturn status;\r\n}\r\nu32 strmwrap_select(union trapped_args *args, void *pr_ctxt)\r\n{\r\nu32 mask;\r\nstruct strm_object *strm_tab[MAX_STREAMS];\r\nint status = 0;\r\nstruct strm_res_object *strm_res;\r\nint *ids[MAX_STREAMS];\r\nint i;\r\nif (args->args_strm_select.strm_num > MAX_STREAMS)\r\nreturn -EINVAL;\r\nCP_FM_USR(ids, args->args_strm_select.stream_tab, status,\r\nargs->args_strm_select.strm_num);\r\nif (status)\r\nreturn status;\r\nfor (i = 0; i < args->args_strm_select.strm_num; i++) {\r\nfind_strm_handle(&strm_res, pr_ctxt, ids[i]);\r\nif (!strm_res)\r\nreturn -EFAULT;\r\nstrm_tab[i] = strm_res->stream;\r\n}\r\nif (!status) {\r\nstatus = strm_select(strm_tab, args->args_strm_select.strm_num,\r\n&mask, args->args_strm_select.timeout);\r\n}\r\nCP_TO_USR(args->args_strm_select.mask, &mask, status, 1);\r\nreturn status;\r\n}\r\nu32 __deprecated cmmwrap_calloc_buf(union trapped_args * args, void *pr_ctxt)\r\n{\r\npr_err("%s: deprecated dspbridge ioctl\n", __func__);\r\nreturn -ENOSYS;\r\n}\r\nu32 __deprecated cmmwrap_free_buf(union trapped_args * args, void *pr_ctxt)\r\n{\r\npr_err("%s: deprecated dspbridge ioctl\n", __func__);\r\nreturn -ENOSYS;\r\n}\r\nu32 cmmwrap_get_handle(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct cmm_object *hcmm_mgr;\r\nvoid *hprocessor = ((struct process_context *)pr_ctxt)->processor;\r\nstatus = cmm_get_handle(hprocessor, &hcmm_mgr);\r\nCP_TO_USR(args->args_cmm_gethandle.cmm_mgr, &hcmm_mgr, status, 1);\r\nreturn status;\r\n}\r\nu32 cmmwrap_get_info(union trapped_args *args, void *pr_ctxt)\r\n{\r\nint status = 0;\r\nstruct cmm_info cmm_info_obj;\r\nstatus = cmm_get_info(args->args_cmm_getinfo.cmm_mgr, &cmm_info_obj);\r\nCP_TO_USR(args->args_cmm_getinfo.cmm_info_obj, &cmm_info_obj, status,\r\n1);\r\nreturn status;\r\n}
