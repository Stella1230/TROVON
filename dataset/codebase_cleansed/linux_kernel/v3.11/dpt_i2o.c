static inline int dpt_dma64(adpt_hba *pHba)\r\n{\r\nreturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\r\n}\r\nstatic inline u32 dma_high(dma_addr_t addr)\r\n{\r\nreturn upper_32_bits(addr);\r\n}\r\nstatic inline u32 dma_low(dma_addr_t addr)\r\n{\r\nreturn (u32)addr;\r\n}\r\nstatic u8 adpt_read_blink_led(adpt_hba* host)\r\n{\r\nif (host->FwDebugBLEDflag_P) {\r\nif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\r\nreturn readb(host->FwDebugBLEDvalue_P);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adpt_detect(struct scsi_host_template* sht)\r\n{\r\nstruct pci_dev *pDev = NULL;\r\nadpt_hba *pHba;\r\nadpt_hba *next;\r\nPINFO("Detecting Adaptec I2O RAID controllers...\n");\r\nwhile ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {\r\nif(pDev->device == PCI_DPT_DEVICE_ID ||\r\npDev->device == PCI_DPT_RAPTOR_DEVICE_ID){\r\nif(adpt_install_hba(sht, pDev) ){\r\nPERROR("Could not Init an I2O RAID device\n");\r\nPERROR("Will not try to detect others.\n");\r\nreturn hba_count-1;\r\n}\r\npci_dev_get(pDev);\r\n}\r\n}\r\nfor (pHba = hba_chain; pHba; pHba = next) {\r\nnext = pHba->next;\r\nif (adpt_i2o_activate_hba(pHba) < 0) {\r\nadpt_i2o_delete_hba(pHba);\r\n}\r\n}\r\nrebuild_sys_tab:\r\nif (hba_chain == NULL)\r\nreturn 0;\r\nif (adpt_i2o_build_sys_table() < 0) {\r\nadpt_i2o_sys_shutdown();\r\nreturn 0;\r\n}\r\nPDEBUG("HBA's in HOLD state\n");\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next) {\r\nif (adpt_i2o_online_hba(pHba) < 0) {\r\nadpt_i2o_delete_hba(pHba);\r\ngoto rebuild_sys_tab;\r\n}\r\n}\r\nPDEBUG("HBA's in OPERATIONAL state\n");\r\nprintk("dpti: If you have a lot of devices this could take a few minutes.\n");\r\nfor (pHba = hba_chain; pHba; pHba = next) {\r\nnext = pHba->next;\r\nprintk(KERN_INFO"%s: Reading the hardware resource table.\n", pHba->name);\r\nif (adpt_i2o_lct_get(pHba) < 0){\r\nadpt_i2o_delete_hba(pHba);\r\ncontinue;\r\n}\r\nif (adpt_i2o_parse_lct(pHba) < 0){\r\nadpt_i2o_delete_hba(pHba);\r\ncontinue;\r\n}\r\nadpt_inquiry(pHba);\r\n}\r\nadpt_sysfs_class = class_create(THIS_MODULE, "dpt_i2o");\r\nif (IS_ERR(adpt_sysfs_class)) {\r\nprintk(KERN_WARNING"dpti: unable to create dpt_i2o class\n");\r\nadpt_sysfs_class = NULL;\r\n}\r\nfor (pHba = hba_chain; pHba; pHba = next) {\r\nnext = pHba->next;\r\nif (adpt_scsi_host_alloc(pHba, sht) < 0){\r\nadpt_i2o_delete_hba(pHba);\r\ncontinue;\r\n}\r\npHba->initialized = TRUE;\r\npHba->state &= ~DPTI_STATE_RESET;\r\nif (adpt_sysfs_class) {\r\nstruct device *dev = device_create(adpt_sysfs_class,\r\nNULL, MKDEV(DPTI_I2O_MAJOR, pHba->unit), NULL,\r\n"dpti%d", pHba->unit);\r\nif (IS_ERR(dev)) {\r\nprintk(KERN_WARNING"dpti%d: unable to "\r\n"create device in dpt_i2o class\n",\r\npHba->unit);\r\n}\r\n}\r\n}\r\nif (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {\r\nadpt_i2o_sys_shutdown();\r\nreturn 0;\r\n}\r\nreturn hba_count;\r\n}\r\nstatic int adpt_release(struct Scsi_Host *host)\r\n{\r\nadpt_hba* pHba = (adpt_hba*) host->hostdata[0];\r\nadpt_i2o_delete_hba(pHba);\r\nscsi_unregister(host);\r\nreturn 0;\r\n}\r\nstatic void adpt_inquiry(adpt_hba* pHba)\r\n{\r\nu32 msg[17];\r\nu32 *mptr;\r\nu32 *lenptr;\r\nint direction;\r\nint scsidir;\r\nu32 len;\r\nu32 reqlen;\r\nu8* buf;\r\ndma_addr_t addr;\r\nu8 scb[16];\r\ns32 rcode;\r\nmemset(msg, 0, sizeof(msg));\r\nbuf = dma_alloc_coherent(&pHba->pDev->dev, 80, &addr, GFP_KERNEL);\r\nif(!buf){\r\nprintk(KERN_ERR"%s: Could not allocate buffer\n",pHba->name);\r\nreturn;\r\n}\r\nmemset((void*)buf, 0, 36);\r\nlen = 36;\r\ndirection = 0x00000000;\r\nscsidir =0x40000000;\r\nif (dpt_dma64(pHba))\r\nreqlen = 17;\r\nelse\r\nreqlen = 14;\r\nmsg[0] = reqlen<<16 | SGL_OFFSET_12;\r\nmsg[1] = (0xff<<24|HOST_TID<<12|ADAPTER_TID);\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nmsg[4] = I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16;\r\nmsg[5] = ADAPTER_TID | 1<<16 ;\r\nmsg[6] = scsidir|0x20a00000| 6 ;\r\nmptr=msg+7;\r\nmemset(scb, 0, sizeof(scb));\r\nscb[0] = INQUIRY;\r\nscb[1] = 0;\r\nscb[2] = 0;\r\nscb[3] = 0;\r\nscb[4] = 36;\r\nscb[5] = 0;\r\nmemcpy(mptr, scb, sizeof(scb));\r\nmptr+=4;\r\nlenptr=mptr++;\r\n*lenptr = len;\r\nif (dpt_dma64(pHba)) {\r\n*mptr++ = (0x7C<<24)+(2<<16)+0x02;\r\n*mptr++ = 1 << PAGE_SHIFT;\r\n*mptr++ = 0xD0000000|direction|len;\r\n*mptr++ = dma_low(addr);\r\n*mptr++ = dma_high(addr);\r\n} else {\r\n*mptr++ = 0xD0000000|direction|len;\r\n*mptr++ = addr;\r\n}\r\nrcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);\r\nif (rcode != 0) {\r\nsprintf(pHba->detail, "Adaptec I2O RAID");\r\nprintk(KERN_INFO "%s: Inquiry Error (%d)\n",pHba->name,rcode);\r\nif (rcode != -ETIME && rcode != -EINTR)\r\ndma_free_coherent(&pHba->pDev->dev, 80, buf, addr);\r\n} else {\r\nmemset(pHba->detail, 0, sizeof(pHba->detail));\r\nmemcpy(&(pHba->detail), "Vendor: Adaptec ", 16);\r\nmemcpy(&(pHba->detail[16]), " Model: ", 8);\r\nmemcpy(&(pHba->detail[24]), (u8*) &buf[16], 16);\r\nmemcpy(&(pHba->detail[40]), " FW: ", 4);\r\nmemcpy(&(pHba->detail[44]), (u8*) &buf[32], 4);\r\npHba->detail[48] = '\0';\r\ndma_free_coherent(&pHba->pDev->dev, 80, buf, addr);\r\n}\r\nadpt_i2o_status_get(pHba);\r\nreturn ;\r\n}\r\nstatic int adpt_slave_configure(struct scsi_device * device)\r\n{\r\nstruct Scsi_Host *host = device->host;\r\nadpt_hba* pHba;\r\npHba = (adpt_hba *) host->hostdata[0];\r\nif (host->can_queue && device->tagged_supported) {\r\nscsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,\r\nhost->can_queue - 1);\r\n} else {\r\nscsi_adjust_queue_depth(device, 0, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adpt_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))\r\n{\r\nadpt_hba* pHba = NULL;\r\nstruct adpt_device* pDev = NULL;\r\ncmd->scsi_done = done;\r\nif ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {\r\ncmd->result = (DID_OK << 16);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\npHba = (adpt_hba*)cmd->device->host->hostdata[0];\r\nif (!pHba) {\r\nreturn FAILED;\r\n}\r\nrmb();\r\nif(((pHba->state) & DPTI_STATE_IOCTL) || ((pHba->state) & DPTI_STATE_RESET)) {\r\npHba->host->last_reset = jiffies;\r\npHba->host->resetting = 1;\r\nreturn 1;\r\n}\r\nif((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {\r\nif ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun)) == NULL) {\r\ncmd->result = (DID_NO_CONNECT << 16);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\ncmd->device->hostdata = pDev;\r\n}\r\npDev->pScsi_dev = cmd->device;\r\nif (pDev->state & DPTI_DEV_RESET ) {\r\nreturn FAILED;\r\n}\r\nreturn adpt_scsi_to_i2o(pHba, cmd, pDev);\r\n}\r\nconst char *adpt_info(struct Scsi_Host *host)\r\n{\r\nadpt_hba* pHba;\r\npHba = (adpt_hba *) host->hostdata[0];\r\nreturn (char *) (pHba->detail);\r\n}\r\nstatic int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nstruct adpt_device* d;\r\nint id;\r\nint chan;\r\nadpt_hba* pHba;\r\nint unit;\r\nmutex_lock(&adpt_configuration_lock);\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next) {\r\nif (pHba->host == host) {\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&adpt_configuration_lock);\r\nif (pHba == NULL) {\r\nreturn 0;\r\n}\r\nhost = pHba->host;\r\nseq_printf(m, "Adaptec I2O RAID Driver Version: %s\n\n", DPT_I2O_VERSION);\r\nseq_printf(m, "%s\n", pHba->detail);\r\nseq_printf(m, "SCSI Host=scsi%d Control Node=/dev/%s irq=%d\n",\r\npHba->host->host_no, pHba->name, host->irq);\r\nseq_printf(m, "\tpost fifo size = %d\n\treply fifo size = %d\n\tsg table size = %d\n\n",\r\nhost->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);\r\nseq_printf(m, "Devices:\n");\r\nfor(chan = 0; chan < MAX_CHANNEL; chan++) {\r\nfor(id = 0; id < MAX_ID; id++) {\r\nd = pHba->channel[chan].device[id];\r\nwhile(d) {\r\nseq_printf(m,"\t%-24.24s", d->pScsi_dev->vendor);\r\nseq_printf(m," Rev: %-8.8s\n", d->pScsi_dev->rev);\r\nunit = d->pI2o_dev->lct_data.tid;\r\nseq_printf(m, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d) (%s)\n\n",\r\nunit, (int)d->scsi_channel, (int)d->scsi_id, (int)d->scsi_lun,\r\nscsi_device_online(d->pScsi_dev)? "online":"offline");\r\nd = d->next_lun;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 adpt_cmd_to_context(struct scsi_cmnd *cmd)\r\n{\r\nreturn (u32)cmd->serial_number;\r\n}\r\nstatic struct scsi_cmnd *\r\nadpt_cmd_from_context(adpt_hba * pHba, u32 context)\r\n{\r\nstruct scsi_cmnd * cmd;\r\nstruct scsi_device * d;\r\nif (context == 0)\r\nreturn NULL;\r\nspin_unlock(pHba->host->host_lock);\r\nshost_for_each_device(d, pHba->host) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&d->list_lock, flags);\r\nlist_for_each_entry(cmd, &d->cmd_list, list) {\r\nif (((u32)cmd->serial_number == context)) {\r\nspin_unlock_irqrestore(&d->list_lock, flags);\r\nscsi_device_put(d);\r\nspin_lock(pHba->host->host_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_irqrestore(&d->list_lock, flags);\r\n}\r\nspin_lock(pHba->host->host_lock);\r\nreturn NULL;\r\n}\r\nstatic u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\r\n{\r\n#if BITS_PER_LONG == 32\r\nreturn (u32)(unsigned long)reply;\r\n#else\r\nulong flags = 0;\r\nu32 nr, i;\r\nspin_lock_irqsave(pHba->host->host_lock, flags);\r\nnr = ARRAY_SIZE(pHba->ioctl_reply_context);\r\nfor (i = 0; i < nr; i++) {\r\nif (pHba->ioctl_reply_context[i] == NULL) {\r\npHba->ioctl_reply_context[i] = reply;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(pHba->host->host_lock, flags);\r\nif (i >= nr) {\r\nkfree (reply);\r\nprintk(KERN_WARNING"%s: Too many outstanding "\r\n"ioctl commands\n", pHba->name);\r\nreturn (u32)-1;\r\n}\r\nreturn i;\r\n#endif\r\n}\r\nstatic void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\r\n{\r\n#if BITS_PER_LONG == 32\r\nreturn (void *)(unsigned long)context;\r\n#else\r\nvoid *p = pHba->ioctl_reply_context[context];\r\npHba->ioctl_reply_context[context] = NULL;\r\nreturn p;\r\n#endif\r\n}\r\nstatic int adpt_abort(struct scsi_cmnd * cmd)\r\n{\r\nadpt_hba* pHba = NULL;\r\nstruct adpt_device* dptdevice;\r\nu32 msg[5];\r\nint rcode;\r\nif(cmd->serial_number == 0){\r\nreturn FAILED;\r\n}\r\npHba = (adpt_hba*) cmd->device->host->hostdata[0];\r\nprintk(KERN_INFO"%s: Trying to Abort\n",pHba->name);\r\nif ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {\r\nprintk(KERN_ERR "%s: Unable to abort: No device in cmnd\n",pHba->name);\r\nreturn FAILED;\r\n}\r\nmemset(msg, 0, sizeof(msg));\r\nmsg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;\r\nmsg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;\r\nmsg[2] = 0;\r\nmsg[3]= 0;\r\nmsg[4] = adpt_cmd_to_context(cmd);\r\nif (pHba->host)\r\nspin_lock_irq(pHba->host->host_lock);\r\nrcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);\r\nif (pHba->host)\r\nspin_unlock_irq(pHba->host->host_lock);\r\nif (rcode != 0) {\r\nif(rcode == -EOPNOTSUPP ){\r\nprintk(KERN_INFO"%s: Abort cmd not supported\n",pHba->name);\r\nreturn FAILED;\r\n}\r\nprintk(KERN_INFO"%s: Abort failed.\n",pHba->name);\r\nreturn FAILED;\r\n}\r\nprintk(KERN_INFO"%s: Abort complete.\n",pHba->name);\r\nreturn SUCCESS;\r\n}\r\nstatic int adpt_device_reset(struct scsi_cmnd* cmd)\r\n{\r\nadpt_hba* pHba;\r\nu32 msg[4];\r\nu32 rcode;\r\nint old_state;\r\nstruct adpt_device* d = cmd->device->hostdata;\r\npHba = (void*) cmd->device->host->hostdata[0];\r\nprintk(KERN_INFO"%s: Trying to reset device\n",pHba->name);\r\nif (!d) {\r\nprintk(KERN_INFO"%s: Reset Device: Device Not found\n",pHba->name);\r\nreturn FAILED;\r\n}\r\nmemset(msg, 0, sizeof(msg));\r\nmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\r\nmsg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nif (pHba->host)\r\nspin_lock_irq(pHba->host->host_lock);\r\nold_state = d->state;\r\nd->state |= DPTI_DEV_RESET;\r\nrcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\r\nd->state = old_state;\r\nif (pHba->host)\r\nspin_unlock_irq(pHba->host->host_lock);\r\nif (rcode != 0) {\r\nif(rcode == -EOPNOTSUPP ){\r\nprintk(KERN_INFO"%s: Device reset not supported\n",pHba->name);\r\nreturn FAILED;\r\n}\r\nprintk(KERN_INFO"%s: Device reset failed\n",pHba->name);\r\nreturn FAILED;\r\n} else {\r\nprintk(KERN_INFO"%s: Device reset successful\n",pHba->name);\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic int adpt_bus_reset(struct scsi_cmnd* cmd)\r\n{\r\nadpt_hba* pHba;\r\nu32 msg[4];\r\nu32 rcode;\r\npHba = (adpt_hba*)cmd->device->host->hostdata[0];\r\nmemset(msg, 0, sizeof(msg));\r\nprintk(KERN_WARNING"%s: Bus reset: SCSI Bus %d: tid: %d\n",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );\r\nmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\r\nmsg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nif (pHba->host)\r\nspin_lock_irq(pHba->host->host_lock);\r\nrcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\r\nif (pHba->host)\r\nspin_unlock_irq(pHba->host->host_lock);\r\nif (rcode != 0) {\r\nprintk(KERN_WARNING"%s: Bus reset failed.\n",pHba->name);\r\nreturn FAILED;\r\n} else {\r\nprintk(KERN_WARNING"%s: Bus reset success.\n",pHba->name);\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic int __adpt_reset(struct scsi_cmnd* cmd)\r\n{\r\nadpt_hba* pHba;\r\nint rcode;\r\npHba = (adpt_hba*)cmd->device->host->hostdata[0];\r\nprintk(KERN_WARNING"%s: Hba Reset: scsi id %d: tid: %d\n",pHba->name,cmd->device->channel,pHba->channel[cmd->device->channel].tid );\r\nrcode = adpt_hba_reset(pHba);\r\nif(rcode == 0){\r\nprintk(KERN_WARNING"%s: HBA reset complete\n",pHba->name);\r\nreturn SUCCESS;\r\n} else {\r\nprintk(KERN_WARNING"%s: HBA reset failed (%x)\n",pHba->name, rcode);\r\nreturn FAILED;\r\n}\r\n}\r\nstatic int adpt_reset(struct scsi_cmnd* cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = __adpt_reset(cmd);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int adpt_hba_reset(adpt_hba* pHba)\r\n{\r\nint rcode;\r\npHba->state |= DPTI_STATE_RESET;\r\nif ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {\r\nprintk(KERN_ERR "%s: Could not activate\n", pHba->name);\r\nadpt_i2o_delete_hba(pHba);\r\nreturn rcode;\r\n}\r\nif ((rcode=adpt_i2o_build_sys_table()) < 0) {\r\nadpt_i2o_delete_hba(pHba);\r\nreturn rcode;\r\n}\r\nPDEBUG("%s: in HOLD state\n",pHba->name);\r\nif ((rcode=adpt_i2o_online_hba(pHba)) < 0) {\r\nadpt_i2o_delete_hba(pHba);\r\nreturn rcode;\r\n}\r\nPDEBUG("%s: in OPERATIONAL state\n",pHba->name);\r\nif ((rcode=adpt_i2o_lct_get(pHba)) < 0){\r\nadpt_i2o_delete_hba(pHba);\r\nreturn rcode;\r\n}\r\nif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){\r\nadpt_i2o_delete_hba(pHba);\r\nreturn rcode;\r\n}\r\npHba->state &= ~DPTI_STATE_RESET;\r\nadpt_fail_posted_scbs(pHba);\r\nreturn 0;\r\n}\r\nstatic void adpt_i2o_sys_shutdown(void)\r\n{\r\nadpt_hba *pHba, *pNext;\r\nstruct adpt_i2o_post_wait_data *p1, *old;\r\nprintk(KERN_INFO"Shutting down Adaptec I2O controllers.\n");\r\nprintk(KERN_INFO" This could take a few minutes if there are many devices attached\n");\r\nfor (pHba = hba_chain; pHba; pHba = pNext) {\r\npNext = pHba->next;\r\nadpt_i2o_delete_hba(pHba);\r\n}\r\nfor(p1 = adpt_post_wait_queue; p1;) {\r\nold = p1;\r\np1 = p1->next;\r\nkfree(old);\r\n}\r\nadpt_post_wait_queue = NULL;\r\nprintk(KERN_INFO "Adaptec I2O controllers down.\n");\r\n}\r\nstatic int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev)\r\n{\r\nadpt_hba* pHba = NULL;\r\nadpt_hba* p = NULL;\r\nulong base_addr0_phys = 0;\r\nulong base_addr1_phys = 0;\r\nu32 hba_map0_area_size = 0;\r\nu32 hba_map1_area_size = 0;\r\nvoid __iomem *base_addr_virt = NULL;\r\nvoid __iomem *msg_addr_virt = NULL;\r\nint dma64 = 0;\r\nint raptorFlag = FALSE;\r\nif(pci_enable_device(pDev)) {\r\nreturn -EINVAL;\r\n}\r\nif (pci_request_regions(pDev, "dpt_i2o")) {\r\nPERROR("dpti: adpt_config_hba: pci request region failed\n");\r\nreturn -EINVAL;\r\n}\r\npci_set_master(pDev);\r\nif (sizeof(dma_addr_t) > 4 &&\r\npci_set_dma_mask(pDev, DMA_BIT_MASK(64)) == 0) {\r\nif (dma_get_required_mask(&pDev->dev) > DMA_BIT_MASK(32))\r\ndma64 = 1;\r\n}\r\nif (!dma64 && pci_set_dma_mask(pDev, DMA_BIT_MASK(32)) != 0)\r\nreturn -EINVAL;\r\npci_set_consistent_dma_mask(pDev, DMA_BIT_MASK(32));\r\nbase_addr0_phys = pci_resource_start(pDev,0);\r\nhba_map0_area_size = pci_resource_len(pDev,0);\r\nif(pDev->device == PCI_DPT_DEVICE_ID){\r\nif(pDev->subsystem_device >=0xc032 && pDev->subsystem_device <= 0xc03b){\r\nhba_map0_area_size = 0x400000;\r\n} else {\r\nif(hba_map0_area_size > 0x100000 ){\r\nhba_map0_area_size = 0x100000;\r\n}\r\n}\r\n} else {\r\nbase_addr1_phys = pci_resource_start(pDev,1);\r\nhba_map1_area_size = pci_resource_len(pDev,1);\r\nraptorFlag = TRUE;\r\n}\r\n#if BITS_PER_LONG == 64\r\nif (raptorFlag == TRUE) {\r\nif (hba_map0_area_size > 128)\r\nhba_map0_area_size = 128;\r\nif (hba_map1_area_size > 524288)\r\nhba_map1_area_size = 524288;\r\n} else {\r\nif (hba_map0_area_size > 524288)\r\nhba_map0_area_size = 524288;\r\n}\r\n#endif\r\nbase_addr_virt = ioremap(base_addr0_phys,hba_map0_area_size);\r\nif (!base_addr_virt) {\r\npci_release_regions(pDev);\r\nPERROR("dpti: adpt_config_hba: io remap failed\n");\r\nreturn -EINVAL;\r\n}\r\nif(raptorFlag == TRUE) {\r\nmsg_addr_virt = ioremap(base_addr1_phys, hba_map1_area_size );\r\nif (!msg_addr_virt) {\r\nPERROR("dpti: adpt_config_hba: io remap failed on BAR1\n");\r\niounmap(base_addr_virt);\r\npci_release_regions(pDev);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nmsg_addr_virt = base_addr_virt;\r\n}\r\npHba = kzalloc(sizeof(adpt_hba), GFP_KERNEL);\r\nif (!pHba) {\r\nif (msg_addr_virt != base_addr_virt)\r\niounmap(msg_addr_virt);\r\niounmap(base_addr_virt);\r\npci_release_regions(pDev);\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&adpt_configuration_lock);\r\nif(hba_chain != NULL){\r\nfor(p = hba_chain; p->next; p = p->next);\r\np->next = pHba;\r\n} else {\r\nhba_chain = pHba;\r\n}\r\npHba->next = NULL;\r\npHba->unit = hba_count;\r\nsprintf(pHba->name, "dpti%d", hba_count);\r\nhba_count++;\r\nmutex_unlock(&adpt_configuration_lock);\r\npHba->pDev = pDev;\r\npHba->base_addr_phys = base_addr0_phys;\r\npHba->base_addr_virt = base_addr_virt;\r\npHba->msg_addr_virt = msg_addr_virt;\r\npHba->irq_mask = base_addr_virt+0x30;\r\npHba->post_port = base_addr_virt+0x40;\r\npHba->reply_port = base_addr_virt+0x44;\r\npHba->hrt = NULL;\r\npHba->lct = NULL;\r\npHba->lct_size = 0;\r\npHba->status_block = NULL;\r\npHba->post_count = 0;\r\npHba->state = DPTI_STATE_RESET;\r\npHba->pDev = pDev;\r\npHba->devices = NULL;\r\npHba->dma64 = dma64;\r\nspin_lock_init(&pHba->state_lock);\r\nspin_lock_init(&adpt_post_wait_lock);\r\nif(raptorFlag == 0){\r\nprintk(KERN_INFO "Adaptec I2O RAID controller"\r\n" %d at %p size=%x irq=%d%s\n",\r\nhba_count-1, base_addr_virt,\r\nhba_map0_area_size, pDev->irq,\r\ndma64 ? " (64-bit DMA)" : "");\r\n} else {\r\nprintk(KERN_INFO"Adaptec I2O RAID controller %d irq=%d%s\n",\r\nhba_count-1, pDev->irq,\r\ndma64 ? " (64-bit DMA)" : "");\r\nprintk(KERN_INFO" BAR0 %p - size= %x\n",base_addr_virt,hba_map0_area_size);\r\nprintk(KERN_INFO" BAR1 %p - size= %x\n",msg_addr_virt,hba_map1_area_size);\r\n}\r\nif (request_irq (pDev->irq, adpt_isr, IRQF_SHARED, pHba->name, pHba)) {\r\nprintk(KERN_ERR"%s: Couldn't register IRQ %d\n", pHba->name, pDev->irq);\r\nadpt_i2o_delete_hba(pHba);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adpt_i2o_delete_hba(adpt_hba* pHba)\r\n{\r\nadpt_hba* p1;\r\nadpt_hba* p2;\r\nstruct i2o_device* d;\r\nstruct i2o_device* next;\r\nint i;\r\nint j;\r\nstruct adpt_device* pDev;\r\nstruct adpt_device* pNext;\r\nmutex_lock(&adpt_configuration_lock);\r\nif(pHba->host){\r\nfree_irq(pHba->host->irq, pHba);\r\n}\r\np2 = NULL;\r\nfor( p1 = hba_chain; p1; p2 = p1,p1=p1->next){\r\nif(p1 == pHba) {\r\nif(p2) {\r\np2->next = p1->next;\r\n} else {\r\nhba_chain = p1->next;\r\n}\r\nbreak;\r\n}\r\n}\r\nhba_count--;\r\nmutex_unlock(&adpt_configuration_lock);\r\niounmap(pHba->base_addr_virt);\r\npci_release_regions(pHba->pDev);\r\nif(pHba->msg_addr_virt != pHba->base_addr_virt){\r\niounmap(pHba->msg_addr_virt);\r\n}\r\nif(pHba->FwDebugBuffer_P)\r\niounmap(pHba->FwDebugBuffer_P);\r\nif(pHba->hrt) {\r\ndma_free_coherent(&pHba->pDev->dev,\r\npHba->hrt->num_entries * pHba->hrt->entry_len << 2,\r\npHba->hrt, pHba->hrt_pa);\r\n}\r\nif(pHba->lct) {\r\ndma_free_coherent(&pHba->pDev->dev, pHba->lct_size,\r\npHba->lct, pHba->lct_pa);\r\n}\r\nif(pHba->status_block) {\r\ndma_free_coherent(&pHba->pDev->dev, sizeof(i2o_status_block),\r\npHba->status_block, pHba->status_block_pa);\r\n}\r\nif(pHba->reply_pool) {\r\ndma_free_coherent(&pHba->pDev->dev,\r\npHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,\r\npHba->reply_pool, pHba->reply_pool_pa);\r\n}\r\nfor(d = pHba->devices; d ; d = next){\r\nnext = d->next;\r\nkfree(d);\r\n}\r\nfor(i = 0 ; i < pHba->top_scsi_channel ; i++){\r\nfor(j = 0; j < MAX_ID; j++){\r\nif(pHba->channel[i].device[j] != NULL){\r\nfor(pDev = pHba->channel[i].device[j]; pDev; pDev = pNext){\r\npNext = pDev->next_lun;\r\nkfree(pDev);\r\n}\r\n}\r\n}\r\n}\r\npci_dev_put(pHba->pDev);\r\nif (adpt_sysfs_class)\r\ndevice_destroy(adpt_sysfs_class,\r\nMKDEV(DPTI_I2O_MAJOR, pHba->unit));\r\nkfree(pHba);\r\nif(hba_count <= 0){\r\nunregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);\r\nif (adpt_sysfs_class) {\r\nclass_destroy(adpt_sysfs_class);\r\nadpt_sysfs_class = NULL;\r\n}\r\n}\r\n}\r\nstatic struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)\r\n{\r\nstruct adpt_device* d;\r\nif(chan < 0 || chan >= MAX_CHANNEL)\r\nreturn NULL;\r\nif( pHba->channel[chan].device == NULL){\r\nprintk(KERN_DEBUG"Adaptec I2O RAID: Trying to find device before they are allocated\n");\r\nreturn NULL;\r\n}\r\nd = pHba->channel[chan].device[id];\r\nif(!d || d->tid == 0) {\r\nreturn NULL;\r\n}\r\nif(d->scsi_lun == lun){\r\nreturn d;\r\n}\r\nfor(d=d->next_lun ; d ; d = d->next_lun){\r\nif(d->scsi_lun == lun){\r\nreturn d;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)\r\n{\r\nADPT_DECLARE_WAIT_QUEUE_HEAD(adpt_wq_i2o_post);\r\nint status = 0;\r\nulong flags = 0;\r\nstruct adpt_i2o_post_wait_data *p1, *p2;\r\nstruct adpt_i2o_post_wait_data *wait_data =\r\nkmalloc(sizeof(struct adpt_i2o_post_wait_data), GFP_ATOMIC);\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (!wait_data)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&adpt_post_wait_lock, flags);\r\nwait_data->next = adpt_post_wait_queue;\r\nadpt_post_wait_queue = wait_data;\r\nadpt_post_wait_id++;\r\nadpt_post_wait_id &= 0x7fff;\r\nwait_data->id = adpt_post_wait_id;\r\nspin_unlock_irqrestore(&adpt_post_wait_lock, flags);\r\nwait_data->wq = &adpt_wq_i2o_post;\r\nwait_data->status = -ETIMEDOUT;\r\nadd_wait_queue(&adpt_wq_i2o_post, &wait);\r\nmsg[2] |= 0x80000000 | ((u32)wait_data->id);\r\ntimeout *= HZ;\r\nif((status = adpt_i2o_post_this(pHba, msg, len)) == 0){\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif(pHba->host)\r\nspin_unlock_irq(pHba->host->host_lock);\r\nif (!timeout)\r\nschedule();\r\nelse{\r\ntimeout = schedule_timeout(timeout);\r\nif (timeout == 0) {\r\nstatus = -ETIME;\r\n}\r\n}\r\nif(pHba->host)\r\nspin_lock_irq(pHba->host->host_lock);\r\n}\r\nremove_wait_queue(&adpt_wq_i2o_post, &wait);\r\nif(status == -ETIMEDOUT){\r\nprintk(KERN_INFO"dpti%d: POST WAIT TIMEOUT\n",pHba->unit);\r\nreturn status;\r\n}\r\np2 = NULL;\r\nspin_lock_irqsave(&adpt_post_wait_lock, flags);\r\nfor(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p1->next) {\r\nif(p1 == wait_data) {\r\nif(p1->status == I2O_DETAIL_STATUS_UNSUPPORTED_FUNCTION ) {\r\nstatus = -EOPNOTSUPP;\r\n}\r\nif(p2) {\r\np2->next = p1->next;\r\n} else {\r\nadpt_post_wait_queue = p1->next;\r\n}\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&adpt_post_wait_lock, flags);\r\nkfree(wait_data);\r\nreturn status;\r\n}\r\nstatic s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\r\n{\r\nu32 m = EMPTY_QUEUE;\r\nu32 __iomem *msg;\r\nulong timeout = jiffies + 30*HZ;\r\ndo {\r\nrmb();\r\nm = readl(pHba->post_port);\r\nif (m != EMPTY_QUEUE) {\r\nbreak;\r\n}\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_WARNING"dpti%d: Timeout waiting for message frame!\n", pHba->unit);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while(m == EMPTY_QUEUE);\r\nmsg = pHba->msg_addr_virt + m;\r\nmemcpy_toio(msg, data, len);\r\nwmb();\r\nwritel(m, pHba->post_port);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic void adpt_i2o_post_wait_complete(u32 context, int status)\r\n{\r\nstruct adpt_i2o_post_wait_data *p1 = NULL;\r\ncontext &= 0x7fff;\r\nspin_lock(&adpt_post_wait_lock);\r\nfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\r\nif(p1->id == context) {\r\np1->status = status;\r\nspin_unlock(&adpt_post_wait_lock);\r\nwake_up_interruptible(p1->wq);\r\nreturn;\r\n}\r\n}\r\nspin_unlock(&adpt_post_wait_lock);\r\nprintk(KERN_DEBUG"dpti: Could Not find task %d in wait queue\n",context);\r\nprintk(KERN_DEBUG" Tasks in wait queue:\n");\r\nfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\r\nprintk(KERN_DEBUG" %d\n",p1->id);\r\n}\r\nreturn;\r\n}\r\nstatic s32 adpt_i2o_reset_hba(adpt_hba* pHba)\r\n{\r\nu32 msg[8];\r\nu8* status;\r\ndma_addr_t addr;\r\nu32 m = EMPTY_QUEUE ;\r\nulong timeout = jiffies + (TMOUT_IOPRESET*HZ);\r\nif(pHba->initialized == FALSE) {\r\ntimeout = jiffies + (25*HZ);\r\n} else {\r\nadpt_i2o_quiesce_hba(pHba);\r\n}\r\ndo {\r\nrmb();\r\nm = readl(pHba->post_port);\r\nif (m != EMPTY_QUEUE) {\r\nbreak;\r\n}\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_WARNING"Timeout waiting for message!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (m == EMPTY_QUEUE);\r\nstatus = dma_alloc_coherent(&pHba->pDev->dev, 4, &addr, GFP_KERNEL);\r\nif(status == NULL) {\r\nadpt_send_nop(pHba, m);\r\nprintk(KERN_ERR"IOP reset failed - no free memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(status,0,4);\r\nmsg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;\r\nmsg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;\r\nmsg[2]=0;\r\nmsg[3]=0;\r\nmsg[4]=0;\r\nmsg[5]=0;\r\nmsg[6]=dma_low(addr);\r\nmsg[7]=dma_high(addr);\r\nmemcpy_toio(pHba->msg_addr_virt+m, msg, sizeof(msg));\r\nwmb();\r\nwritel(m, pHba->post_port);\r\nwmb();\r\nwhile(*status == 0){\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_WARNING"%s: IOP Reset Timeout\n",pHba->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nrmb();\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nif(*status == 0x01 ) {\r\nPDEBUG("%s: Reset in progress...\n", pHba->name);\r\ndo {\r\nrmb();\r\nm = readl(pHba->post_port);\r\nif (m != EMPTY_QUEUE) {\r\nbreak;\r\n}\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_ERR "%s:Timeout waiting for IOP Reset.\n",pHba->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (m == EMPTY_QUEUE);\r\nadpt_send_nop(pHba, m);\r\n}\r\nadpt_i2o_status_get(pHba);\r\nif(*status == 0x02 ||\r\npHba->status_block->iop_state != ADAPTER_STATE_RESET) {\r\nprintk(KERN_WARNING"%s: Reset reject, trying to clear\n",\r\npHba->name);\r\n} else {\r\nPDEBUG("%s: Reset completed.\n", pHba->name);\r\n}\r\ndma_free_coherent(&pHba->pDev->dev, 4, status, addr);\r\n#ifdef UARTDELAY\r\nadpt_delay(20000);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_parse_lct(adpt_hba* pHba)\r\n{\r\nint i;\r\nint max;\r\nint tid;\r\nstruct i2o_device *d;\r\ni2o_lct *lct = pHba->lct;\r\nu8 bus_no = 0;\r\ns16 scsi_id;\r\ns16 scsi_lun;\r\nu32 buf[10];\r\nstruct adpt_device* pDev;\r\nif (lct == NULL) {\r\nprintk(KERN_ERR "%s: LCT is empty???\n",pHba->name);\r\nreturn -1;\r\n}\r\nmax = lct->table_size;\r\nmax -= 3;\r\nmax /= 9;\r\nfor(i=0;i<max;i++) {\r\nif( lct->lct_entry[i].user_tid != 0xfff){\r\nif( lct->lct_entry[i].class_id != I2O_CLASS_RANDOM_BLOCK_STORAGE &&\r\nlct->lct_entry[i].class_id != I2O_CLASS_SCSI_PERIPHERAL &&\r\nlct->lct_entry[i].class_id != I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){\r\ncontinue;\r\n}\r\ntid = lct->lct_entry[i].tid;\r\nif(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {\r\ncontinue;\r\n}\r\nbus_no = buf[0]>>16;\r\nscsi_id = buf[1];\r\nscsi_lun = (buf[2]>>8 )&0xff;\r\nif(bus_no >= MAX_CHANNEL) {\r\nprintk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);\r\ncontinue;\r\n}\r\nif (scsi_id >= MAX_ID){\r\nprintk(KERN_WARNING"%s: SCSI ID %d out of range \n", pHba->name, bus_no);\r\ncontinue;\r\n}\r\nif(bus_no > pHba->top_scsi_channel){\r\npHba->top_scsi_channel = bus_no;\r\n}\r\nif(scsi_id > pHba->top_scsi_id){\r\npHba->top_scsi_id = scsi_id;\r\n}\r\nif(scsi_lun > pHba->top_scsi_lun){\r\npHba->top_scsi_lun = scsi_lun;\r\n}\r\ncontinue;\r\n}\r\nd = kmalloc(sizeof(struct i2o_device), GFP_KERNEL);\r\nif(d==NULL)\r\n{\r\nprintk(KERN_CRIT"%s: Out of memory for I2O device data.\n",pHba->name);\r\nreturn -ENOMEM;\r\n}\r\nd->controller = pHba;\r\nd->next = NULL;\r\nmemcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));\r\nd->flags = 0;\r\ntid = d->lct_data.tid;\r\nadpt_i2o_report_hba_unit(pHba, d);\r\nadpt_i2o_install_device(pHba, d);\r\n}\r\nbus_no = 0;\r\nfor(d = pHba->devices; d ; d = d->next) {\r\nif(d->lct_data.class_id == I2O_CLASS_BUS_ADAPTER_PORT ||\r\nd->lct_data.class_id == I2O_CLASS_FIBRE_CHANNEL_PORT){\r\ntid = d->lct_data.tid;\r\nif(bus_no > pHba->top_scsi_channel){\r\npHba->top_scsi_channel = bus_no;\r\n}\r\npHba->channel[bus_no].type = d->lct_data.class_id;\r\npHba->channel[bus_no].tid = tid;\r\nif(adpt_i2o_query_scalar(pHba, tid, 0x0200, -1, buf, 28)>=0)\r\n{\r\npHba->channel[bus_no].scsi_id = buf[1];\r\nPDEBUG("Bus %d - SCSI ID %d.\n", bus_no, buf[1]);\r\n}\r\nbus_no++;\r\nif(bus_no >= MAX_CHANNEL) {\r\nprintk(KERN_WARNING"%s: Channel number %d out of range - LCT\n", pHba->name, bus_no);\r\nbreak;\r\n}\r\n}\r\n}\r\nfor(d = pHba->devices; d ; d = d->next) {\r\nif(d->lct_data.class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||\r\nd->lct_data.class_id == I2O_CLASS_SCSI_PERIPHERAL ||\r\nd->lct_data.class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){\r\ntid = d->lct_data.tid;\r\nscsi_id = -1;\r\nif(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {\r\nbus_no = buf[0]>>16;\r\nscsi_id = buf[1];\r\nscsi_lun = (buf[2]>>8 )&0xff;\r\nif(bus_no >= MAX_CHANNEL) {\r\ncontinue;\r\n}\r\nif (scsi_id >= MAX_ID) {\r\ncontinue;\r\n}\r\nif( pHba->channel[bus_no].device[scsi_id] == NULL){\r\npDev = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);\r\nif(pDev == NULL) {\r\nreturn -ENOMEM;\r\n}\r\npHba->channel[bus_no].device[scsi_id] = pDev;\r\n} else {\r\nfor( pDev = pHba->channel[bus_no].device[scsi_id];\r\npDev->next_lun; pDev = pDev->next_lun){\r\n}\r\npDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);\r\nif(pDev->next_lun == NULL) {\r\nreturn -ENOMEM;\r\n}\r\npDev = pDev->next_lun;\r\n}\r\npDev->tid = tid;\r\npDev->scsi_channel = bus_no;\r\npDev->scsi_id = scsi_id;\r\npDev->scsi_lun = scsi_lun;\r\npDev->pI2o_dev = d;\r\nd->owner = pDev;\r\npDev->type = (buf[0])&0xff;\r\npDev->flags = (buf[0]>>8)&0xff;\r\nif(scsi_id > pHba->top_scsi_id){\r\npHba->top_scsi_id = scsi_id;\r\n}\r\nif(scsi_lun > pHba->top_scsi_lun){\r\npHba->top_scsi_lun = scsi_lun;\r\n}\r\n}\r\nif(scsi_id == -1){\r\nprintk(KERN_WARNING"Could not find SCSI ID for %s\n",\r\nd->lct_data.identity_tag);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\r\n{\r\nmutex_lock(&adpt_configuration_lock);\r\nd->controller=pHba;\r\nd->owner=NULL;\r\nd->next=pHba->devices;\r\nd->prev=NULL;\r\nif (pHba->devices != NULL){\r\npHba->devices->prev=d;\r\n}\r\npHba->devices=d;\r\n*d->dev_name = 0;\r\nmutex_unlock(&adpt_configuration_lock);\r\nreturn 0;\r\n}\r\nstatic int adpt_open(struct inode *inode, struct file *file)\r\n{\r\nint minor;\r\nadpt_hba* pHba;\r\nmutex_lock(&adpt_mutex);\r\nminor = iminor(inode);\r\nif (minor >= hba_count) {\r\nmutex_unlock(&adpt_mutex);\r\nreturn -ENXIO;\r\n}\r\nmutex_lock(&adpt_configuration_lock);\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next) {\r\nif (pHba->unit == minor) {\r\nbreak;\r\n}\r\n}\r\nif (pHba == NULL) {\r\nmutex_unlock(&adpt_configuration_lock);\r\nmutex_unlock(&adpt_mutex);\r\nreturn -ENXIO;\r\n}\r\npHba->in_use = 1;\r\nmutex_unlock(&adpt_configuration_lock);\r\nmutex_unlock(&adpt_mutex);\r\nreturn 0;\r\n}\r\nstatic int adpt_close(struct inode *inode, struct file *file)\r\n{\r\nint minor;\r\nadpt_hba* pHba;\r\nminor = iminor(inode);\r\nif (minor >= hba_count) {\r\nreturn -ENXIO;\r\n}\r\nmutex_lock(&adpt_configuration_lock);\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next) {\r\nif (pHba->unit == minor) {\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&adpt_configuration_lock);\r\nif (pHba == NULL) {\r\nreturn -ENXIO;\r\n}\r\npHba->in_use = 0;\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)\r\n{\r\nu32 msg[MAX_MESSAGE_SIZE];\r\nu32* reply = NULL;\r\nu32 size = 0;\r\nu32 reply_size = 0;\r\nu32 __user *user_msg = arg;\r\nu32 __user * user_reply = NULL;\r\nvoid *sg_list[pHba->sg_tablesize];\r\nu32 sg_offset = 0;\r\nu32 sg_count = 0;\r\nint sg_index = 0;\r\nu32 i = 0;\r\nu32 rcode = 0;\r\nvoid *p = NULL;\r\ndma_addr_t addr;\r\nulong flags = 0;\r\nmemset(&msg, 0, MAX_MESSAGE_SIZE*4);\r\nif(get_user(size, &user_msg[0])){\r\nreturn -EFAULT;\r\n}\r\nsize = size>>16;\r\nuser_reply = &user_msg[size];\r\nif(size > MAX_MESSAGE_SIZE){\r\nreturn -EFAULT;\r\n}\r\nsize *= 4;\r\nif(copy_from_user(msg, user_msg, size)) {\r\nreturn -EFAULT;\r\n}\r\nget_user(reply_size, &user_reply[0]);\r\nreply_size = reply_size>>16;\r\nif(reply_size > REPLY_FRAME_SIZE){\r\nreply_size = REPLY_FRAME_SIZE;\r\n}\r\nreply_size *= 4;\r\nreply = kzalloc(REPLY_FRAME_SIZE*4, GFP_KERNEL);\r\nif(reply == NULL) {\r\nprintk(KERN_WARNING"%s: Could not allocate reply buffer\n",pHba->name);\r\nreturn -ENOMEM;\r\n}\r\nsg_offset = (msg[0]>>4)&0xf;\r\nmsg[2] = 0x40000000;\r\nmsg[3] = adpt_ioctl_to_context(pHba, reply);\r\nif (msg[3] == (u32)-1)\r\nreturn -EBUSY;\r\nmemset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);\r\nif(sg_offset) {\r\nstruct sg_simple_element *sg = (struct sg_simple_element*) (msg+sg_offset);\r\nsg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);\r\nif (sg_count > pHba->sg_tablesize){\r\nprintk(KERN_DEBUG"%s:IOCTL SG List too large (%u)\n", pHba->name,sg_count);\r\nkfree (reply);\r\nreturn -EINVAL;\r\n}\r\nfor(i = 0; i < sg_count; i++) {\r\nint sg_size;\r\nif (!(sg[i].flag_count & 0x10000000 )) {\r\nprintk(KERN_DEBUG"%s:Bad SG element %d - not simple (%x)\n",pHba->name,i, sg[i].flag_count);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nsg_size = sg[i].flag_count & 0xffffff;\r\np = dma_alloc_coherent(&pHba->pDev->dev, sg_size, &addr, GFP_KERNEL);\r\nif(!p) {\r\nprintk(KERN_DEBUG"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\npHba->name,sg_size,i,sg_count);\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nsg_list[sg_index++] = p;\r\nif(sg[i].flag_count & 0x04000000 ) {\r\nif (copy_from_user(p,(void __user *)(ulong)sg[i].addr_bus, sg_size)) {\r\nprintk(KERN_DEBUG"%s: Could not copy SG buf %d FROM user\n",pHba->name,i);\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\nsg[i].addr_bus = addr;\r\n}\r\n}\r\ndo {\r\nif(pHba->host)\r\nspin_lock_irqsave(pHba->host->host_lock, flags);\r\nrcode = adpt_i2o_post_wait(pHba, msg, size, FOREVER);\r\nif (rcode != 0)\r\nprintk("adpt_i2o_passthru: post wait failed %d %p\n",\r\nrcode, reply);\r\nif(pHba->host)\r\nspin_unlock_irqrestore(pHba->host->host_lock, flags);\r\n} while(rcode == -ETIMEDOUT);\r\nif(rcode){\r\ngoto cleanup;\r\n}\r\nif(sg_offset) {\r\nu32 j;\r\nstruct sg_simple_element* sg;\r\nint sg_size;\r\nmemset(&msg, 0, MAX_MESSAGE_SIZE*4);\r\nif(get_user(size, &user_msg[0])){\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nsize = size>>16;\r\nsize *= 4;\r\nif (size > MAX_MESSAGE_SIZE) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (copy_from_user (msg, user_msg, size)) {\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nsg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);\r\nsg = (struct sg_simple_element*)(msg + sg_offset);\r\nfor (j = 0; j < sg_count; j++) {\r\nif(! (sg[j].flag_count & 0x4000000 )) {\r\nsg_size = sg[j].flag_count & 0xffffff;\r\nif (copy_to_user((void __user *)(ulong)sg[j].addr_bus,sg_list[j], sg_size)) {\r\nprintk(KERN_WARNING"%s: Could not copy %p TO user %x\n",pHba->name, sg_list[j], sg[j].addr_bus);\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\n}\r\n}\r\nif (reply_size) {\r\nif(copy_from_user(reply+2, user_msg+2, sizeof(u32)*2)) {\r\nprintk(KERN_WARNING"%s: Could not copy message context FROM user\n",pHba->name);\r\nrcode = -EFAULT;\r\n}\r\nif(copy_to_user(user_reply, reply, reply_size)) {\r\nprintk(KERN_WARNING"%s: Could not copy reply TO user\n",pHba->name);\r\nrcode = -EFAULT;\r\n}\r\n}\r\ncleanup:\r\nif (rcode != -ETIME && rcode != -EINTR) {\r\nstruct sg_simple_element *sg =\r\n(struct sg_simple_element*) (msg +sg_offset);\r\nkfree (reply);\r\nwhile(sg_index) {\r\nif(sg_list[--sg_index]) {\r\ndma_free_coherent(&pHba->pDev->dev,\r\nsg[sg_index].flag_count & 0xffffff,\r\nsg_list[sg_index],\r\nsg[sg_index].addr_bus);\r\n}\r\n}\r\n}\r\nreturn rcode;\r\n}\r\nstatic void adpt_ia64_info(sysInfo_S* si)\r\n{\r\nsi->processorType = PROC_IA64;\r\n}\r\nstatic void adpt_sparc_info(sysInfo_S* si)\r\n{\r\nsi->processorType = PROC_ULTRASPARC;\r\n}\r\nstatic void adpt_alpha_info(sysInfo_S* si)\r\n{\r\nsi->processorType = PROC_ALPHA;\r\n}\r\nstatic void adpt_i386_info(sysInfo_S* si)\r\n{\r\nswitch (boot_cpu_data.x86) {\r\ncase CPU_386:\r\nsi->processorType = PROC_386;\r\nbreak;\r\ncase CPU_486:\r\nsi->processorType = PROC_486;\r\nbreak;\r\ncase CPU_586:\r\nsi->processorType = PROC_PENTIUM;\r\nbreak;\r\ndefault:\r\nsi->processorType = PROC_PENTIUM;\r\nbreak;\r\n}\r\n}\r\nstatic int adpt_system_info(void __user *buffer)\r\n{\r\nsysInfo_S si;\r\nmemset(&si, 0, sizeof(si));\r\nsi.osType = OS_LINUX;\r\nsi.osMajorVersion = 0;\r\nsi.osMinorVersion = 0;\r\nsi.osRevision = 0;\r\nsi.busType = SI_PCI_BUS;\r\nsi.processorFamily = DPTI_sig.dsProcessorFamily;\r\n#if defined __i386__\r\nadpt_i386_info(&si);\r\n#elif defined (__ia64__)\r\nadpt_ia64_info(&si);\r\n#elif defined(__sparc__)\r\nadpt_sparc_info(&si);\r\n#elif defined (__alpha__)\r\nadpt_alpha_info(&si);\r\n#else\r\nsi.processorType = 0xff ;\r\n#endif\r\nif (copy_to_user(buffer, &si, sizeof(si))){\r\nprintk(KERN_WARNING"dpti: Could not copy buffer TO user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adpt_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)\r\n{\r\nint minor;\r\nint error = 0;\r\nadpt_hba* pHba;\r\nulong flags = 0;\r\nvoid __user *argp = (void __user *)arg;\r\nminor = iminor(inode);\r\nif (minor >= DPTI_MAX_HBA){\r\nreturn -ENXIO;\r\n}\r\nmutex_lock(&adpt_configuration_lock);\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next) {\r\nif (pHba->unit == minor) {\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&adpt_configuration_lock);\r\nif(pHba == NULL){\r\nreturn -ENXIO;\r\n}\r\nwhile((volatile u32) pHba->state & DPTI_STATE_RESET )\r\nschedule_timeout_uninterruptible(2);\r\nswitch (cmd) {\r\ncase DPT_SIGNATURE:\r\nif (copy_to_user(argp, &DPTI_sig, sizeof(DPTI_sig))) {\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase I2OUSRCMD:\r\nreturn adpt_i2o_passthru(pHba, argp);\r\ncase DPT_CTRLINFO:{\r\ndrvrHBAinfo_S HbaInfo;\r\n#define FLG_OSD_PCI_VALID 0x0001\r\n#define FLG_OSD_DMA 0x0002\r\n#define FLG_OSD_I2O 0x0004\r\nmemset(&HbaInfo, 0, sizeof(HbaInfo));\r\nHbaInfo.drvrHBAnum = pHba->unit;\r\nHbaInfo.baseAddr = (ulong) pHba->base_addr_phys;\r\nHbaInfo.blinkState = adpt_read_blink_led(pHba);\r\nHbaInfo.pciBusNum = pHba->pDev->bus->number;\r\nHbaInfo.pciDeviceNum=PCI_SLOT(pHba->pDev->devfn);\r\nHbaInfo.Interrupt = pHba->pDev->irq;\r\nHbaInfo.hbaFlags = FLG_OSD_PCI_VALID | FLG_OSD_DMA | FLG_OSD_I2O;\r\nif(copy_to_user(argp, &HbaInfo, sizeof(HbaInfo))){\r\nprintk(KERN_WARNING"%s: Could not copy HbaInfo TO user\n",pHba->name);\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase DPT_SYSINFO:\r\nreturn adpt_system_info(argp);\r\ncase DPT_BLINKLED:{\r\nu32 value;\r\nvalue = (u32)adpt_read_blink_led(pHba);\r\nif (copy_to_user(argp, &value, sizeof(value))) {\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase I2ORESETCMD:\r\nif(pHba->host)\r\nspin_lock_irqsave(pHba->host->host_lock, flags);\r\nadpt_hba_reset(pHba);\r\nif(pHba->host)\r\nspin_unlock_irqrestore(pHba->host->host_lock, flags);\r\nbreak;\r\ncase I2ORESCANCMD:\r\nadpt_rescan(pHba);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn error;\r\n}\r\nstatic long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)\r\n{\r\nstruct inode *inode;\r\nlong ret;\r\ninode = file_inode(file);\r\nmutex_lock(&adpt_mutex);\r\nret = adpt_ioctl(inode, file, cmd, arg);\r\nmutex_unlock(&adpt_mutex);\r\nreturn ret;\r\n}\r\nstatic long compat_adpt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct inode *inode;\r\nlong ret;\r\ninode = file_inode(file);\r\nmutex_lock(&adpt_mutex);\r\nswitch(cmd) {\r\ncase DPT_SIGNATURE:\r\ncase I2OUSRCMD:\r\ncase DPT_CTRLINFO:\r\ncase DPT_SYSINFO:\r\ncase DPT_BLINKLED:\r\ncase I2ORESETCMD:\r\ncase I2ORESCANCMD:\r\ncase (DPT_TARGET_BUSY & 0xFFFF):\r\ncase DPT_TARGET_BUSY:\r\nret = adpt_ioctl(inode, file, cmd, arg);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nmutex_unlock(&adpt_mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t adpt_isr(int irq, void *dev_id)\r\n{\r\nstruct scsi_cmnd* cmd;\r\nadpt_hba* pHba = dev_id;\r\nu32 m;\r\nvoid __iomem *reply;\r\nu32 status=0;\r\nu32 context;\r\nulong flags = 0;\r\nint handled = 0;\r\nif (pHba == NULL){\r\nprintk(KERN_WARNING"adpt_isr: NULL dev_id\n");\r\nreturn IRQ_NONE;\r\n}\r\nif(pHba->host)\r\nspin_lock_irqsave(pHba->host->host_lock, flags);\r\nwhile( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {\r\nm = readl(pHba->reply_port);\r\nif(m == EMPTY_QUEUE){\r\nrmb();\r\nm = readl(pHba->reply_port);\r\nif(m == EMPTY_QUEUE){\r\nprintk(KERN_ERR"dpti: Could not get reply frame\n");\r\ngoto out;\r\n}\r\n}\r\nif (pHba->reply_pool_pa <= m &&\r\nm < pHba->reply_pool_pa +\r\n(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4)) {\r\nreply = (u8 *)pHba->reply_pool +\r\n(m - pHba->reply_pool_pa);\r\n} else {\r\nprintk(KERN_ERR "dpti: reply frame not from pool\n");\r\nreply = (u8 *)bus_to_virt(m);\r\n}\r\nif (readl(reply) & MSG_FAIL) {\r\nu32 old_m = readl(reply+28);\r\nvoid __iomem *msg;\r\nu32 old_context;\r\nPDEBUG("%s: Failed message\n",pHba->name);\r\nif(old_m >= 0x100000){\r\nprintk(KERN_ERR"%s: Bad preserved MFA (%x)- dropping frame\n",pHba->name,old_m);\r\nwritel(m,pHba->reply_port);\r\ncontinue;\r\n}\r\nmsg = pHba->msg_addr_virt + old_m;\r\nold_context = readl(msg+12);\r\nwritel(old_context, reply+12);\r\nadpt_send_nop(pHba, old_m);\r\n}\r\ncontext = readl(reply+8);\r\nif(context & 0x40000000){\r\nvoid *p = adpt_ioctl_from_context(pHba, readl(reply+12));\r\nif( p != NULL) {\r\nmemcpy_fromio(p, reply, REPLY_FRAME_SIZE * 4);\r\n}\r\n}\r\nif(context & 0x80000000){\r\nstatus = readl(reply+16);\r\nif(status >> 24){\r\nstatus &= 0xffff;\r\n} else {\r\nstatus = I2O_POST_WAIT_OK;\r\n}\r\nif(!(context & 0x40000000)) {\r\ncmd = adpt_cmd_from_context(pHba,\r\nreadl(reply+12));\r\nif(cmd != NULL) {\r\nprintk(KERN_WARNING"%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n", pHba->name, cmd, context);\r\n}\r\n}\r\nadpt_i2o_post_wait_complete(context, status);\r\n} else {\r\ncmd = adpt_cmd_from_context (pHba, readl(reply+12));\r\nif(cmd != NULL){\r\nscsi_dma_unmap(cmd);\r\nif(cmd->serial_number != 0) {\r\nadpt_i2o_to_scsi(reply, cmd);\r\n}\r\n}\r\n}\r\nwritel(m, pHba->reply_port);\r\nwmb();\r\nrmb();\r\n}\r\nhandled = 1;\r\nout: if(pHba->host)\r\nspin_unlock_irqrestore(pHba->host->host_lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_device* d)\r\n{\r\nint i;\r\nu32 msg[MAX_MESSAGE_SIZE];\r\nu32* mptr;\r\nu32* lptr;\r\nu32 *lenptr;\r\nint direction;\r\nint scsidir;\r\nint nseg;\r\nu32 len;\r\nu32 reqlen;\r\ns32 rcode;\r\ndma_addr_t addr;\r\nmemset(msg, 0 , sizeof(msg));\r\nlen = scsi_bufflen(cmd);\r\ndirection = 0x00000000;\r\nscsidir = 0x00000000;\r\nif(len) {\r\nswitch(cmd->sc_data_direction){\r\ncase DMA_FROM_DEVICE:\r\nscsidir =0x40000000;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\ndirection=0x04000000;\r\nscsidir =0x80000000;\r\nbreak;\r\ncase DMA_NONE:\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\nscsidir =0x40000000;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING"%s: scsi opcode 0x%x not supported.\n",\r\npHba->name, cmd->cmnd[0]);\r\ncmd->result = (DID_OK <<16) | (INITIATOR_ERROR << 8);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\n}\r\nmsg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);\r\nmsg[2] = 0;\r\nmsg[3] = adpt_cmd_to_context(cmd);\r\nmsg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);\r\nmsg[5] = d->tid;\r\nmsg[6] = scsidir|0x20a00000|cmd->cmd_len;\r\nmptr=msg+7;\r\nmemset(mptr, 0, 16);\r\nmemcpy(mptr, cmd->cmnd, cmd->cmd_len);\r\nmptr+=4;\r\nlenptr=mptr++;\r\nif (dpt_dma64(pHba)) {\r\nreqlen = 16;\r\n*mptr++ = (0x7C<<24)+(2<<16)+0x02;\r\n*mptr++ = 1 << PAGE_SHIFT;\r\n} else {\r\nreqlen = 14;\r\n}\r\nnseg = scsi_dma_map(cmd);\r\nBUG_ON(nseg < 0);\r\nif (nseg) {\r\nstruct scatterlist *sg;\r\nlen = 0;\r\nscsi_for_each_sg(cmd, sg, nseg, i) {\r\nlptr = mptr;\r\n*mptr++ = direction|0x10000000|sg_dma_len(sg);\r\nlen+=sg_dma_len(sg);\r\naddr = sg_dma_address(sg);\r\n*mptr++ = dma_low(addr);\r\nif (dpt_dma64(pHba))\r\n*mptr++ = dma_high(addr);\r\nif (i == nseg - 1)\r\n*lptr = direction|0xD0000000|sg_dma_len(sg);\r\n}\r\nreqlen = mptr - msg;\r\n*lenptr = len;\r\nif(cmd->underflow && len != cmd->underflow){\r\nprintk(KERN_WARNING"Cmd len %08X Cmd underflow %08X\n",\r\nlen, cmd->underflow);\r\n}\r\n} else {\r\n*lenptr = len = 0;\r\nreqlen = 12;\r\n}\r\nmsg[0] = reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0);\r\nrcode = adpt_i2o_post_this(pHba, msg, reqlen<<2);\r\nif (rcode == 0) {\r\nreturn 0;\r\n}\r\nreturn rcode;\r\n}\r\nstatic s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)\r\n{\r\nstruct Scsi_Host *host;\r\nhost = scsi_host_alloc(sht, sizeof(adpt_hba*));\r\nif (host == NULL) {\r\nprintk("%s: scsi_host_alloc returned NULL\n", pHba->name);\r\nreturn -1;\r\n}\r\nhost->hostdata[0] = (unsigned long)pHba;\r\npHba->host = host;\r\nhost->irq = pHba->pDev->irq;\r\nhost->io_port = 0;\r\nhost->n_io_port = 0;\r\nhost->max_id = 16;\r\nhost->max_lun = 256;\r\nhost->max_channel = pHba->top_scsi_channel + 1;\r\nhost->cmd_per_lun = 1;\r\nhost->unique_id = (u32)sys_tbl_pa + pHba->unit;\r\nhost->sg_tablesize = pHba->sg_tablesize;\r\nhost->can_queue = pHba->post_fifo_size;\r\nreturn 0;\r\n}\r\nstatic s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)\r\n{\r\nadpt_hba* pHba;\r\nu32 hba_status;\r\nu32 dev_status;\r\nu32 reply_flags = readl(reply) & 0xff00;\r\nu16 detailed_status = readl(reply+16) &0xffff;\r\ndev_status = (detailed_status & 0xff);\r\nhba_status = detailed_status >> 8;\r\nscsi_set_resid(cmd, scsi_bufflen(cmd) - readl(reply+20));\r\npHba = (adpt_hba*) cmd->device->host->hostdata[0];\r\ncmd->sense_buffer[0] = '\0';\r\nif(!(reply_flags & MSG_FAIL)) {\r\nswitch(detailed_status & I2O_SCSI_DSC_MASK) {\r\ncase I2O_SCSI_DSC_SUCCESS:\r\ncmd->result = (DID_OK << 16);\r\nif (readl(reply+20) < cmd->underflow) {\r\ncmd->result = (DID_ERROR <<16);\r\nprintk(KERN_WARNING"%s: SCSI CMD underflow\n",pHba->name);\r\n}\r\nbreak;\r\ncase I2O_SCSI_DSC_REQUEST_ABORTED:\r\ncmd->result = (DID_ABORT << 16);\r\nbreak;\r\ncase I2O_SCSI_DSC_PATH_INVALID:\r\ncase I2O_SCSI_DSC_DEVICE_NOT_PRESENT:\r\ncase I2O_SCSI_DSC_SELECTION_TIMEOUT:\r\ncase I2O_SCSI_DSC_COMMAND_TIMEOUT:\r\ncase I2O_SCSI_DSC_NO_ADAPTER:\r\ncase I2O_SCSI_DSC_RESOURCE_UNAVAILABLE:\r\nprintk(KERN_WARNING"%s: SCSI Timeout-Device (%d,%d,%d) hba status=0x%x, dev status=0x%x, cmd=0x%x\n",\r\npHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, hba_status, dev_status, cmd->cmnd[0]);\r\ncmd->result = (DID_TIME_OUT << 16);\r\nbreak;\r\ncase I2O_SCSI_DSC_ADAPTER_BUSY:\r\ncase I2O_SCSI_DSC_BUS_BUSY:\r\ncmd->result = (DID_BUS_BUSY << 16);\r\nbreak;\r\ncase I2O_SCSI_DSC_SCSI_BUS_RESET:\r\ncase I2O_SCSI_DSC_BDR_MESSAGE_SENT:\r\ncmd->result = (DID_RESET << 16);\r\nbreak;\r\ncase I2O_SCSI_DSC_PARITY_ERROR_FAILURE:\r\nprintk(KERN_WARNING"%s: SCSI CMD parity error\n",pHba->name);\r\ncmd->result = (DID_PARITY << 16);\r\nbreak;\r\ncase I2O_SCSI_DSC_UNABLE_TO_ABORT:\r\ncase I2O_SCSI_DSC_COMPLETE_WITH_ERROR:\r\ncase I2O_SCSI_DSC_UNABLE_TO_TERMINATE:\r\ncase I2O_SCSI_DSC_MR_MESSAGE_RECEIVED:\r\ncase I2O_SCSI_DSC_AUTOSENSE_FAILED:\r\ncase I2O_SCSI_DSC_DATA_OVERRUN:\r\ncase I2O_SCSI_DSC_UNEXPECTED_BUS_FREE:\r\ncase I2O_SCSI_DSC_SEQUENCE_FAILURE:\r\ncase I2O_SCSI_DSC_REQUEST_LENGTH_ERROR:\r\ncase I2O_SCSI_DSC_PROVIDE_FAILURE:\r\ncase I2O_SCSI_DSC_REQUEST_TERMINATED:\r\ncase I2O_SCSI_DSC_IDE_MESSAGE_SENT:\r\ncase I2O_SCSI_DSC_UNACKNOWLEDGED_EVENT:\r\ncase I2O_SCSI_DSC_MESSAGE_RECEIVED:\r\ncase I2O_SCSI_DSC_INVALID_CDB:\r\ncase I2O_SCSI_DSC_LUN_INVALID:\r\ncase I2O_SCSI_DSC_SCSI_TID_INVALID:\r\ncase I2O_SCSI_DSC_FUNCTION_UNAVAILABLE:\r\ncase I2O_SCSI_DSC_NO_NEXUS:\r\ncase I2O_SCSI_DSC_CDB_RECEIVED:\r\ncase I2O_SCSI_DSC_LUN_ALREADY_ENABLED:\r\ncase I2O_SCSI_DSC_QUEUE_FROZEN:\r\ncase I2O_SCSI_DSC_REQUEST_INVALID:\r\ndefault:\r\nprintk(KERN_WARNING"%s: SCSI error %0x-Device(%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",\r\npHba->name, detailed_status & I2O_SCSI_DSC_MASK, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,\r\nhba_status, dev_status, cmd->cmnd[0]);\r\ncmd->result = (DID_ERROR << 16);\r\nbreak;\r\n}\r\nif (dev_status == SAM_STAT_CHECK_CONDITION) {\r\nu32 len = min(SCSI_SENSE_BUFFERSIZE, 40);\r\nmemcpy_fromio(cmd->sense_buffer, (reply+28) , len);\r\nif(cmd->sense_buffer[0] == 0x70 &&\r\ncmd->sense_buffer[2] == DATA_PROTECT ){\r\ncmd->result = (DID_TIME_OUT << 16);\r\nprintk(KERN_WARNING"%s: SCSI Data Protect-Device (%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",\r\npHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,\r\nhba_status, dev_status, cmd->cmnd[0]);\r\n}\r\n}\r\n} else {\r\ncmd->result = (DID_TIME_OUT << 16);\r\nprintk(KERN_WARNING"%s: I2O MSG_FAIL - Device (%d,%d,%d) tid=%d, cmd=0x%x\n",\r\npHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,\r\n((struct adpt_device*)(cmd->device->hostdata))->tid, cmd->cmnd[0]);\r\n}\r\ncmd->result |= (dev_status);\r\nif(cmd->scsi_done != NULL){\r\ncmd->scsi_done(cmd);\r\n}\r\nreturn cmd->result;\r\n}\r\nstatic s32 adpt_rescan(adpt_hba* pHba)\r\n{\r\ns32 rcode;\r\nulong flags = 0;\r\nif(pHba->host)\r\nspin_lock_irqsave(pHba->host->host_lock, flags);\r\nif ((rcode=adpt_i2o_lct_get(pHba)) < 0)\r\ngoto out;\r\nif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)\r\ngoto out;\r\nrcode = 0;\r\nout: if(pHba->host)\r\nspin_unlock_irqrestore(pHba->host->host_lock, flags);\r\nreturn rcode;\r\n}\r\nstatic s32 adpt_i2o_reparse_lct(adpt_hba* pHba)\r\n{\r\nint i;\r\nint max;\r\nint tid;\r\nstruct i2o_device *d;\r\ni2o_lct *lct = pHba->lct;\r\nu8 bus_no = 0;\r\ns16 scsi_id;\r\ns16 scsi_lun;\r\nu32 buf[10];\r\nstruct adpt_device* pDev = NULL;\r\nstruct i2o_device* pI2o_dev = NULL;\r\nif (lct == NULL) {\r\nprintk(KERN_ERR "%s: LCT is empty???\n",pHba->name);\r\nreturn -1;\r\n}\r\nmax = lct->table_size;\r\nmax -= 3;\r\nmax /= 9;\r\nfor (d = pHba->devices; d; d = d->next) {\r\npDev =(struct adpt_device*) d->owner;\r\nif(!pDev){\r\ncontinue;\r\n}\r\npDev->state |= DPTI_DEV_UNSCANNED;\r\n}\r\nprintk(KERN_INFO "%s: LCT has %d entries.\n", pHba->name,max);\r\nfor(i=0;i<max;i++) {\r\nif( lct->lct_entry[i].user_tid != 0xfff){\r\ncontinue;\r\n}\r\nif( lct->lct_entry[i].class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||\r\nlct->lct_entry[i].class_id == I2O_CLASS_SCSI_PERIPHERAL ||\r\nlct->lct_entry[i].class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){\r\ntid = lct->lct_entry[i].tid;\r\nif(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {\r\nprintk(KERN_ERR"%s: Could not query device\n",pHba->name);\r\ncontinue;\r\n}\r\nbus_no = buf[0]>>16;\r\nif (bus_no >= MAX_CHANNEL) {\r\nprintk(KERN_WARNING\r\n"%s: Channel number %d out of range\n",\r\npHba->name, bus_no);\r\ncontinue;\r\n}\r\nscsi_id = buf[1];\r\nscsi_lun = (buf[2]>>8 )&0xff;\r\npDev = pHba->channel[bus_no].device[scsi_id];\r\nwhile(pDev) {\r\nif(pDev->scsi_lun == scsi_lun) {\r\nbreak;\r\n}\r\npDev = pDev->next_lun;\r\n}\r\nif(!pDev ) {\r\nd = kmalloc(sizeof(struct i2o_device),\r\nGFP_ATOMIC);\r\nif(d==NULL)\r\n{\r\nprintk(KERN_CRIT "Out of memory for I2O device data.\n");\r\nreturn -ENOMEM;\r\n}\r\nd->controller = pHba;\r\nd->next = NULL;\r\nmemcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));\r\nd->flags = 0;\r\nadpt_i2o_report_hba_unit(pHba, d);\r\nadpt_i2o_install_device(pHba, d);\r\npDev = pHba->channel[bus_no].device[scsi_id];\r\nif( pDev == NULL){\r\npDev =\r\nkzalloc(sizeof(struct adpt_device),\r\nGFP_ATOMIC);\r\nif(pDev == NULL) {\r\nreturn -ENOMEM;\r\n}\r\npHba->channel[bus_no].device[scsi_id] = pDev;\r\n} else {\r\nwhile (pDev->next_lun) {\r\npDev = pDev->next_lun;\r\n}\r\npDev = pDev->next_lun =\r\nkzalloc(sizeof(struct adpt_device),\r\nGFP_ATOMIC);\r\nif(pDev == NULL) {\r\nreturn -ENOMEM;\r\n}\r\n}\r\npDev->tid = d->lct_data.tid;\r\npDev->scsi_channel = bus_no;\r\npDev->scsi_id = scsi_id;\r\npDev->scsi_lun = scsi_lun;\r\npDev->pI2o_dev = d;\r\nd->owner = pDev;\r\npDev->type = (buf[0])&0xff;\r\npDev->flags = (buf[0]>>8)&0xff;\r\nif(scsi_id > pHba->top_scsi_id){\r\npHba->top_scsi_id = scsi_id;\r\n}\r\nif(scsi_lun > pHba->top_scsi_lun){\r\npHba->top_scsi_lun = scsi_lun;\r\n}\r\ncontinue;\r\n}\r\nwhile(pDev) {\r\nif(pDev->scsi_lun == scsi_lun) {\r\nif(!scsi_device_online(pDev->pScsi_dev)) {\r\nprintk(KERN_WARNING"%s: Setting device (%d,%d,%d) back online\n",\r\npHba->name,bus_no,scsi_id,scsi_lun);\r\nif (pDev->pScsi_dev) {\r\nscsi_device_set_state(pDev->pScsi_dev, SDEV_RUNNING);\r\n}\r\n}\r\nd = pDev->pI2o_dev;\r\nif(d->lct_data.tid != tid) {\r\npDev->tid = tid;\r\nmemcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));\r\nif (pDev->pScsi_dev) {\r\npDev->pScsi_dev->changed = TRUE;\r\npDev->pScsi_dev->removable = TRUE;\r\n}\r\n}\r\npDev->state = DPTI_DEV_ONLINE;\r\nbreak;\r\n}\r\npDev = pDev->next_lun;\r\n}\r\n}\r\n}\r\nfor (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {\r\npDev =(struct adpt_device*) pI2o_dev->owner;\r\nif(!pDev){\r\ncontinue;\r\n}\r\nif (pDev->state & DPTI_DEV_UNSCANNED){\r\npDev->state = DPTI_DEV_OFFLINE;\r\nprintk(KERN_WARNING"%s: Device (%d,%d,%d) offline\n",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);\r\nif (pDev->pScsi_dev) {\r\nscsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void adpt_fail_posted_scbs(adpt_hba* pHba)\r\n{\r\nstruct scsi_cmnd* cmd = NULL;\r\nstruct scsi_device* d = NULL;\r\nshost_for_each_device(d, pHba->host) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&d->list_lock, flags);\r\nlist_for_each_entry(cmd, &d->cmd_list, list) {\r\nif(cmd->serial_number == 0){\r\ncontinue;\r\n}\r\ncmd->result = (DID_OK << 16) | (QUEUE_FULL <<1);\r\ncmd->scsi_done(cmd);\r\n}\r\nspin_unlock_irqrestore(&d->list_lock, flags);\r\n}\r\n}\r\nstatic int adpt_i2o_activate_hba(adpt_hba* pHba)\r\n{\r\nint rcode;\r\nif(pHba->initialized ) {\r\nif (adpt_i2o_status_get(pHba) < 0) {\r\nif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\r\nprintk(KERN_WARNING"%s: Could NOT reset.\n", pHba->name);\r\nreturn rcode;\r\n}\r\nif (adpt_i2o_status_get(pHba) < 0) {\r\nprintk(KERN_INFO "HBA not responding.\n");\r\nreturn -1;\r\n}\r\n}\r\nif(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {\r\nprintk(KERN_CRIT "%s: hardware fault\n", pHba->name);\r\nreturn -1;\r\n}\r\nif (pHba->status_block->iop_state == ADAPTER_STATE_READY ||\r\npHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||\r\npHba->status_block->iop_state == ADAPTER_STATE_HOLD ||\r\npHba->status_block->iop_state == ADAPTER_STATE_FAILED) {\r\nadpt_i2o_reset_hba(pHba);\r\nif (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {\r\nprintk(KERN_ERR "%s: Failed to initialize.\n", pHba->name);\r\nreturn -1;\r\n}\r\n}\r\n} else {\r\nif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\r\nprintk(KERN_WARNING"%s: Could NOT reset.\n", pHba->name);\r\nreturn rcode;\r\n}\r\n}\r\nif (adpt_i2o_init_outbound_q(pHba) < 0) {\r\nreturn -1;\r\n}\r\nif (adpt_i2o_hrt_get(pHba) < 0) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_online_hba(adpt_hba* pHba)\r\n{\r\nif (adpt_i2o_systab_send(pHba) < 0) {\r\nadpt_i2o_delete_hba(pHba);\r\nreturn -1;\r\n}\r\nif (adpt_i2o_enable_hba(pHba) < 0) {\r\nadpt_i2o_delete_hba(pHba);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 adpt_send_nop(adpt_hba*pHba,u32 m)\r\n{\r\nu32 __iomem *msg;\r\nulong timeout = jiffies + 5*HZ;\r\nwhile(m == EMPTY_QUEUE){\r\nrmb();\r\nm = readl(pHba->post_port);\r\nif(m != EMPTY_QUEUE){\r\nbreak;\r\n}\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_ERR "%s: Timeout waiting for message frame!\n",pHba->name);\r\nreturn 2;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\r\nwritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\r\nwritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\r\nwritel( 0,&msg[2]);\r\nwmb();\r\nwritel(m, pHba->post_port);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)\r\n{\r\nu8 *status;\r\ndma_addr_t addr;\r\nu32 __iomem *msg = NULL;\r\nint i;\r\nulong timeout = jiffies + TMOUT_INITOUTBOUND*HZ;\r\nu32 m;\r\ndo {\r\nrmb();\r\nm = readl(pHba->post_port);\r\nif (m != EMPTY_QUEUE) {\r\nbreak;\r\n}\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_WARNING"%s: Timeout waiting for message frame\n",pHba->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while(m == EMPTY_QUEUE);\r\nmsg=(u32 __iomem *)(pHba->msg_addr_virt+m);\r\nstatus = dma_alloc_coherent(&pHba->pDev->dev, 4, &addr, GFP_KERNEL);\r\nif (!status) {\r\nadpt_send_nop(pHba, m);\r\nprintk(KERN_WARNING"%s: IOP reset failed - no free memory.\n",\r\npHba->name);\r\nreturn -ENOMEM;\r\n}\r\nmemset(status, 0, 4);\r\nwritel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);\r\nwritel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);\r\nwritel(0, &msg[2]);\r\nwritel(0x0106, &msg[3]);\r\nwritel(4096, &msg[4]);\r\nwritel((REPLY_FRAME_SIZE)<<16|0x80, &msg[5]);\r\nwritel(0xD0000004, &msg[6]);\r\nwritel((u32)addr, &msg[7]);\r\nwritel(m, pHba->post_port);\r\nwmb();\r\ndo {\r\nif (*status) {\r\nif (*status != 0x01 ) {\r\nbreak;\r\n}\r\n}\r\nrmb();\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_WARNING"%s: Timeout Initializing\n",pHba->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (1);\r\nif(*status != 0x04 ) {\r\ndma_free_coherent(&pHba->pDev->dev, 4, status, addr);\r\nreturn -2;\r\n}\r\ndma_free_coherent(&pHba->pDev->dev, 4, status, addr);\r\nif(pHba->reply_pool != NULL) {\r\ndma_free_coherent(&pHba->pDev->dev,\r\npHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,\r\npHba->reply_pool, pHba->reply_pool_pa);\r\n}\r\npHba->reply_pool = dma_alloc_coherent(&pHba->pDev->dev,\r\npHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,\r\n&pHba->reply_pool_pa, GFP_KERNEL);\r\nif (!pHba->reply_pool) {\r\nprintk(KERN_ERR "%s: Could not allocate reply pool\n", pHba->name);\r\nreturn -ENOMEM;\r\n}\r\nmemset(pHba->reply_pool, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);\r\nfor(i = 0; i < pHba->reply_fifo_size; i++) {\r\nwritel(pHba->reply_pool_pa + (i * REPLY_FRAME_SIZE * 4),\r\npHba->reply_port);\r\nwmb();\r\n}\r\nadpt_i2o_status_get(pHba);\r\nreturn 0;\r\n}\r\nstatic s32 adpt_i2o_status_get(adpt_hba* pHba)\r\n{\r\nulong timeout;\r\nu32 m;\r\nu32 __iomem *msg;\r\nu8 *status_block=NULL;\r\nif(pHba->status_block == NULL) {\r\npHba->status_block = dma_alloc_coherent(&pHba->pDev->dev,\r\nsizeof(i2o_status_block),\r\n&pHba->status_block_pa, GFP_KERNEL);\r\nif(pHba->status_block == NULL) {\r\nprintk(KERN_ERR\r\n"dpti%d: Get Status Block failed; Out of memory. \n",\r\npHba->unit);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(pHba->status_block, 0, sizeof(i2o_status_block));\r\nstatus_block = (u8*)(pHba->status_block);\r\ntimeout = jiffies+TMOUT_GETSTATUS*HZ;\r\ndo {\r\nrmb();\r\nm = readl(pHba->post_port);\r\nif (m != EMPTY_QUEUE) {\r\nbreak;\r\n}\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_ERR "%s: Timeout waiting for message !\n",\r\npHba->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while(m==EMPTY_QUEUE);\r\nmsg=(u32 __iomem *)(pHba->msg_addr_virt+m);\r\nwritel(NINE_WORD_MSG_SIZE|SGL_OFFSET_0, &msg[0]);\r\nwritel(I2O_CMD_STATUS_GET<<24|HOST_TID<<12|ADAPTER_TID, &msg[1]);\r\nwritel(1, &msg[2]);\r\nwritel(0, &msg[3]);\r\nwritel(0, &msg[4]);\r\nwritel(0, &msg[5]);\r\nwritel( dma_low(pHba->status_block_pa), &msg[6]);\r\nwritel( dma_high(pHba->status_block_pa), &msg[7]);\r\nwritel(sizeof(i2o_status_block), &msg[8]);\r\nwritel(m, pHba->post_port);\r\nwmb();\r\nwhile(status_block[87]!=0xff){\r\nif(time_after(jiffies,timeout)){\r\nprintk(KERN_ERR"dpti%d: Get status timeout.\n",\r\npHba->unit);\r\nreturn -ETIMEDOUT;\r\n}\r\nrmb();\r\nschedule_timeout_uninterruptible(1);\r\n}\r\npHba->post_fifo_size = pHba->status_block->max_inbound_frames;\r\nif (pHba->post_fifo_size > MAX_TO_IOP_MESSAGES) {\r\npHba->post_fifo_size = MAX_TO_IOP_MESSAGES;\r\n}\r\npHba->reply_fifo_size = pHba->status_block->max_outbound_frames;\r\nif (pHba->reply_fifo_size > MAX_FROM_IOP_MESSAGES) {\r\npHba->reply_fifo_size = MAX_FROM_IOP_MESSAGES;\r\n}\r\nif (dpt_dma64(pHba)) {\r\npHba->sg_tablesize\r\n= ((pHba->status_block->inbound_frame_size * 4\r\n- 14 * sizeof(u32))\r\n/ (sizeof(struct sg_simple_element) + sizeof(u32)));\r\n} else {\r\npHba->sg_tablesize\r\n= ((pHba->status_block->inbound_frame_size * 4\r\n- 12 * sizeof(u32))\r\n/ sizeof(struct sg_simple_element));\r\n}\r\nif (pHba->sg_tablesize > SG_LIST_ELEMENTS) {\r\npHba->sg_tablesize = SG_LIST_ELEMENTS;\r\n}\r\n#ifdef DEBUG\r\nprintk("dpti%d: State = ",pHba->unit);\r\nswitch(pHba->status_block->iop_state) {\r\ncase 0x01:\r\nprintk("INIT\n");\r\nbreak;\r\ncase 0x02:\r\nprintk("RESET\n");\r\nbreak;\r\ncase 0x04:\r\nprintk("HOLD\n");\r\nbreak;\r\ncase 0x05:\r\nprintk("READY\n");\r\nbreak;\r\ncase 0x08:\r\nprintk("OPERATIONAL\n");\r\nbreak;\r\ncase 0x10:\r\nprintk("FAILED\n");\r\nbreak;\r\ncase 0x11:\r\nprintk("FAULTED\n");\r\nbreak;\r\ndefault:\r\nprintk("%x (unknown!!)\n",pHba->status_block->iop_state);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_lct_get(adpt_hba* pHba)\r\n{\r\nu32 msg[8];\r\nint ret;\r\nu32 buf[16];\r\nif ((pHba->lct_size == 0) || (pHba->lct == NULL)){\r\npHba->lct_size = pHba->status_block->expected_lct_size;\r\n}\r\ndo {\r\nif (pHba->lct == NULL) {\r\npHba->lct = dma_alloc_coherent(&pHba->pDev->dev,\r\npHba->lct_size, &pHba->lct_pa,\r\nGFP_ATOMIC);\r\nif(pHba->lct == NULL) {\r\nprintk(KERN_CRIT "%s: Lct Get failed. Out of memory.\n",\r\npHba->name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(pHba->lct, 0, pHba->lct_size);\r\nmsg[0] = EIGHT_WORD_MSG_SIZE|SGL_OFFSET_6;\r\nmsg[1] = I2O_CMD_LCT_NOTIFY<<24 | HOST_TID<<12 | ADAPTER_TID;\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nmsg[4] = 0xFFFFFFFF;\r\nmsg[5] = 0x00000000;\r\nmsg[6] = 0xD0000000|pHba->lct_size;\r\nmsg[7] = (u32)pHba->lct_pa;\r\nif ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 360))) {\r\nprintk(KERN_ERR "%s: LCT Get failed (status=%#10x.\n",\r\npHba->name, ret);\r\nprintk(KERN_ERR"Adaptec: Error Reading Hardware.\n");\r\nreturn ret;\r\n}\r\nif ((pHba->lct->table_size << 2) > pHba->lct_size) {\r\npHba->lct_size = pHba->lct->table_size << 2;\r\ndma_free_coherent(&pHba->pDev->dev, pHba->lct_size,\r\npHba->lct, pHba->lct_pa);\r\npHba->lct = NULL;\r\n}\r\n} while (pHba->lct == NULL);\r\nPDEBUG("%s: Hardware resource table read.\n", pHba->name);\r\nif(adpt_i2o_query_scalar(pHba, 0 , 0x8000, -1, buf, sizeof(buf))>=0) {\r\npHba->FwDebugBufferSize = buf[1];\r\npHba->FwDebugBuffer_P = ioremap(pHba->base_addr_phys + buf[0],\r\npHba->FwDebugBufferSize);\r\nif (pHba->FwDebugBuffer_P) {\r\npHba->FwDebugFlags_P = pHba->FwDebugBuffer_P +\r\nFW_DEBUG_FLAGS_OFFSET;\r\npHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P +\r\nFW_DEBUG_BLED_OFFSET;\r\npHba->FwDebugBLEDflag_P = pHba->FwDebugBLEDvalue_P + 1;\r\npHba->FwDebugStrLength_P = pHba->FwDebugBuffer_P +\r\nFW_DEBUG_STR_LENGTH_OFFSET;\r\npHba->FwDebugBuffer_P += buf[2];\r\npHba->FwDebugFlags = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_build_sys_table(void)\r\n{\r\nadpt_hba* pHba = hba_chain;\r\nint count = 0;\r\nif (sys_tbl)\r\ndma_free_coherent(&pHba->pDev->dev, sys_tbl_len,\r\nsys_tbl, sys_tbl_pa);\r\nsys_tbl_len = sizeof(struct i2o_sys_tbl) +\r\n(hba_count) * sizeof(struct i2o_sys_tbl_entry);\r\nsys_tbl = dma_alloc_coherent(&pHba->pDev->dev,\r\nsys_tbl_len, &sys_tbl_pa, GFP_KERNEL);\r\nif (!sys_tbl) {\r\nprintk(KERN_WARNING "SysTab Set failed. Out of memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(sys_tbl, 0, sys_tbl_len);\r\nsys_tbl->num_entries = hba_count;\r\nsys_tbl->version = I2OVERSION;\r\nsys_tbl->change_ind = sys_tbl_ind++;\r\nfor(pHba = hba_chain; pHba; pHba = pHba->next) {\r\nu64 addr;\r\nif (adpt_i2o_status_get(pHba)) {\r\nsys_tbl->num_entries--;\r\ncontinue;\r\n}\r\nsys_tbl->iops[count].org_id = pHba->status_block->org_id;\r\nsys_tbl->iops[count].iop_id = pHba->unit + 2;\r\nsys_tbl->iops[count].seg_num = 0;\r\nsys_tbl->iops[count].i2o_version = pHba->status_block->i2o_version;\r\nsys_tbl->iops[count].iop_state = pHba->status_block->iop_state;\r\nsys_tbl->iops[count].msg_type = pHba->status_block->msg_type;\r\nsys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;\r\nsys_tbl->iops[count].last_changed = sys_tbl_ind - 1;\r\nsys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;\r\naddr = pHba->base_addr_phys + 0x40;\r\nsys_tbl->iops[count].inbound_low = dma_low(addr);\r\nsys_tbl->iops[count].inbound_high = dma_high(addr);\r\ncount++;\r\n}\r\n#ifdef DEBUG\r\n{\r\nu32 *table = (u32*)sys_tbl;\r\nprintk(KERN_DEBUG"sys_tbl_len=%d in 32bit words\n",(sys_tbl_len >>2));\r\nfor(count = 0; count < (sys_tbl_len >>2); count++) {\r\nprintk(KERN_INFO "sys_tbl[%d] = %0#10x\n",\r\ncount, table[count]);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)\r\n{\r\nchar buf[64];\r\nint unit = d->lct_data.tid;\r\nprintk(KERN_INFO "TID %3.3d ", unit);\r\nif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)\r\n{\r\nbuf[16]=0;\r\nprintk(" Vendor: %-12.12s", buf);\r\n}\r\nif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)\r\n{\r\nbuf[16]=0;\r\nprintk(" Device: %-12.12s", buf);\r\n}\r\nif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)\r\n{\r\nbuf[8]=0;\r\nprintk(" Rev: %-12.12s\n", buf);\r\n}\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "\tClass: %.21s\n", adpt_i2o_get_class_name(d->lct_data.class_id));\r\nprintk(KERN_INFO "\tSubclass: 0x%04X\n", d->lct_data.sub_class);\r\nprintk(KERN_INFO "\tFlags: ");\r\nif(d->lct_data.device_flags&(1<<0))\r\nprintk("C");\r\nif(d->lct_data.device_flags&(1<<1))\r\nprintk("U");\r\nif(!(d->lct_data.device_flags&(1<<4)))\r\nprintk("P");\r\nif(!(d->lct_data.device_flags&(1<<5)))\r\nprintk("M");\r\nprintk("\n");\r\n#endif\r\n}\r\nstatic const char *adpt_i2o_get_class_name(int class)\r\n{\r\nint idx = 16;\r\nstatic char *i2o_class_name[] = {\r\n"Executive",\r\n"Device Driver Module",\r\n"Block Device",\r\n"Tape Device",\r\n"LAN Interface",\r\n"WAN Interface",\r\n"Fibre Channel Port",\r\n"Fibre Channel Device",\r\n"SCSI Device",\r\n"ATE Port",\r\n"ATE Device",\r\n"Floppy Controller",\r\n"Floppy Device",\r\n"Secondary Bus Port",\r\n"Peer Transport Agent",\r\n"Peer Transport",\r\n"Unknown"\r\n};\r\nswitch(class&0xFFF) {\r\ncase I2O_CLASS_EXECUTIVE:\r\nidx = 0; break;\r\ncase I2O_CLASS_DDM:\r\nidx = 1; break;\r\ncase I2O_CLASS_RANDOM_BLOCK_STORAGE:\r\nidx = 2; break;\r\ncase I2O_CLASS_SEQUENTIAL_STORAGE:\r\nidx = 3; break;\r\ncase I2O_CLASS_LAN:\r\nidx = 4; break;\r\ncase I2O_CLASS_WAN:\r\nidx = 5; break;\r\ncase I2O_CLASS_FIBRE_CHANNEL_PORT:\r\nidx = 6; break;\r\ncase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\r\nidx = 7; break;\r\ncase I2O_CLASS_SCSI_PERIPHERAL:\r\nidx = 8; break;\r\ncase I2O_CLASS_ATE_PORT:\r\nidx = 9; break;\r\ncase I2O_CLASS_ATE_PERIPHERAL:\r\nidx = 10; break;\r\ncase I2O_CLASS_FLOPPY_CONTROLLER:\r\nidx = 11; break;\r\ncase I2O_CLASS_FLOPPY_DEVICE:\r\nidx = 12; break;\r\ncase I2O_CLASS_BUS_ADAPTER_PORT:\r\nidx = 13; break;\r\ncase I2O_CLASS_PEER_TRANSPORT_AGENT:\r\nidx = 14; break;\r\ncase I2O_CLASS_PEER_TRANSPORT:\r\nidx = 15; break;\r\n}\r\nreturn i2o_class_name[idx];\r\n}\r\nstatic s32 adpt_i2o_hrt_get(adpt_hba* pHba)\r\n{\r\nu32 msg[6];\r\nint ret, size = sizeof(i2o_hrt);\r\ndo {\r\nif (pHba->hrt == NULL) {\r\npHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,\r\nsize, &pHba->hrt_pa, GFP_KERNEL);\r\nif (pHba->hrt == NULL) {\r\nprintk(KERN_CRIT "%s: Hrt Get failed; Out of memory.\n", pHba->name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmsg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;\r\nmsg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;\r\nmsg[2]= 0;\r\nmsg[3]= 0;\r\nmsg[4]= (0xD0000000 | size);\r\nmsg[5]= (u32)pHba->hrt_pa;\r\nif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {\r\nprintk(KERN_ERR "%s: Unable to get HRT (status=%#10x)\n", pHba->name, ret);\r\nreturn ret;\r\n}\r\nif (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {\r\nint newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;\r\ndma_free_coherent(&pHba->pDev->dev, size,\r\npHba->hrt, pHba->hrt_pa);\r\nsize = newsize;\r\npHba->hrt = NULL;\r\n}\r\n} while(pHba->hrt == NULL);\r\nreturn 0;\r\n}\r\nstatic int adpt_i2o_query_scalar(adpt_hba* pHba, int tid,\r\nint group, int field, void *buf, int buflen)\r\n{\r\nu16 opblk[] = { 1, 0, I2O_PARAMS_FIELD_GET, group, 1, field };\r\nu8 *opblk_va;\r\ndma_addr_t opblk_pa;\r\nu8 *resblk_va;\r\ndma_addr_t resblk_pa;\r\nint size;\r\nresblk_va = dma_alloc_coherent(&pHba->pDev->dev,\r\nsizeof(u8) * (8 + buflen), &resblk_pa, GFP_KERNEL);\r\nif (resblk_va == NULL) {\r\nprintk(KERN_CRIT "%s: query scalar failed; Out of memory.\n", pHba->name);\r\nreturn -ENOMEM;\r\n}\r\nopblk_va = dma_alloc_coherent(&pHba->pDev->dev,\r\nsizeof(opblk), &opblk_pa, GFP_KERNEL);\r\nif (opblk_va == NULL) {\r\ndma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),\r\nresblk_va, resblk_pa);\r\nprintk(KERN_CRIT "%s: query operatio failed; Out of memory.\n",\r\npHba->name);\r\nreturn -ENOMEM;\r\n}\r\nif (field == -1)\r\nopblk[4] = -1;\r\nmemcpy(opblk_va, opblk, sizeof(opblk));\r\nsize = adpt_i2o_issue_params(I2O_CMD_UTIL_PARAMS_GET, pHba, tid,\r\nopblk_va, opblk_pa, sizeof(opblk),\r\nresblk_va, resblk_pa, sizeof(u8)*(8+buflen));\r\ndma_free_coherent(&pHba->pDev->dev, sizeof(opblk), opblk_va, opblk_pa);\r\nif (size == -ETIME) {\r\ndma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),\r\nresblk_va, resblk_pa);\r\nprintk(KERN_WARNING "%s: issue params failed; Timed out.\n", pHba->name);\r\nreturn -ETIME;\r\n} else if (size == -EINTR) {\r\ndma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),\r\nresblk_va, resblk_pa);\r\nprintk(KERN_WARNING "%s: issue params failed; Interrupted.\n", pHba->name);\r\nreturn -EINTR;\r\n}\r\nmemcpy(buf, resblk_va+8, buflen);\r\ndma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),\r\nresblk_va, resblk_pa);\r\nif (size < 0)\r\nreturn size;\r\nreturn buflen;\r\n}\r\nstatic int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid,\r\nvoid *opblk_va, dma_addr_t opblk_pa, int oplen,\r\nvoid *resblk_va, dma_addr_t resblk_pa, int reslen)\r\n{\r\nu32 msg[9];\r\nu32 *res = (u32 *)resblk_va;\r\nint wait_status;\r\nmsg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;\r\nmsg[1] = cmd << 24 | HOST_TID << 12 | tid;\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nmsg[4] = 0;\r\nmsg[5] = 0x54000000 | oplen;\r\nmsg[6] = (u32)opblk_pa;\r\nmsg[7] = 0xD0000000 | reslen;\r\nmsg[8] = (u32)resblk_pa;\r\nif ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {\r\nprintk("adpt_i2o_issue_params: post_wait failed (%p)\n", resblk_va);\r\nreturn wait_status;\r\n}\r\nif (res[1]&0x00FF0000) {\r\nprintk(KERN_WARNING "%s: %s - Error:\n ErrorInfoSize = 0x%02x, "\r\n"BlockStatus = 0x%02x, BlockSize = 0x%04x\n",\r\npHba->name,\r\n(cmd == I2O_CMD_UTIL_PARAMS_SET) ? "PARAMS_SET"\r\n: "PARAMS_GET",\r\nres[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);\r\nreturn -((res[1] >> 16) & 0xFF);\r\n}\r\nreturn 4 + ((res[1] & 0x0000FFFF) << 2);\r\n}\r\nstatic s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)\r\n{\r\nu32 msg[4];\r\nint ret;\r\nadpt_i2o_status_get(pHba);\r\nif((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&\r\n(pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){\r\nreturn 0;\r\n}\r\nmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\r\nmsg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nif((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\r\nprintk(KERN_INFO"dpti%d: Unable to quiesce (status=%#x).\n",\r\npHba->unit, -ret);\r\n} else {\r\nprintk(KERN_INFO"dpti%d: Quiesced.\n",pHba->unit);\r\n}\r\nadpt_i2o_status_get(pHba);\r\nreturn ret;\r\n}\r\nstatic int adpt_i2o_enable_hba(adpt_hba* pHba)\r\n{\r\nu32 msg[4];\r\nint ret;\r\nadpt_i2o_status_get(pHba);\r\nif(!pHba->status_block){\r\nreturn -ENOMEM;\r\n}\r\nif(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)\r\nreturn 0;\r\nif(pHba->status_block->iop_state != ADAPTER_STATE_READY)\r\nreturn -EINVAL;\r\nmsg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\r\nmsg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;\r\nmsg[2]= 0;\r\nmsg[3]= 0;\r\nif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\r\nprintk(KERN_WARNING"%s: Could not enable (status=%#10x).\n",\r\npHba->name, ret);\r\n} else {\r\nPDEBUG("%s: Enabled.\n", pHba->name);\r\n}\r\nadpt_i2o_status_get(pHba);\r\nreturn ret;\r\n}\r\nstatic int adpt_i2o_systab_send(adpt_hba* pHba)\r\n{\r\nu32 msg[12];\r\nint ret;\r\nmsg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;\r\nmsg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;\r\nmsg[2] = 0;\r\nmsg[3] = 0;\r\nmsg[4] = (0<<16) | ((pHba->unit+2) << 12);\r\nmsg[5] = 0;\r\nmsg[6] = 0x54000000 | sys_tbl_len;\r\nmsg[7] = (u32)sys_tbl_pa;\r\nmsg[8] = 0x54000000 | 0;\r\nmsg[9] = 0;\r\nmsg[10] = 0xD4000000 | 0;\r\nmsg[11] = 0;\r\nif ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {\r\nprintk(KERN_INFO "%s: Unable to set SysTab (status=%#10x).\n",\r\npHba->name, ret);\r\n}\r\n#ifdef DEBUG\r\nelse {\r\nPINFO("%s: SysTab set.\n", pHba->name);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic static void adpt_delay(int millisec)\r\n{\r\nint i;\r\nfor (i = 0; i < millisec; i++) {\r\nudelay(1000);\r\n}\r\n}\r\nstatic int __init adpt_init(void)\r\n{\r\nint error;\r\nadpt_hba *pHba, *next;\r\nprintk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");\r\nerror = adpt_detect(&driver_template);\r\nif (error < 0)\r\nreturn error;\r\nif (hba_chain == NULL)\r\nreturn -ENODEV;\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next) {\r\nerror = scsi_add_host(pHba->host, &pHba->pDev->dev);\r\nif (error)\r\ngoto fail;\r\nscsi_scan_host(pHba->host);\r\n}\r\nreturn 0;\r\nfail:\r\nfor (pHba = hba_chain; pHba; pHba = next) {\r\nnext = pHba->next;\r\nscsi_remove_host(pHba->host);\r\n}\r\nreturn error;\r\n}\r\nstatic void __exit adpt_exit(void)\r\n{\r\nadpt_hba *pHba, *next;\r\nfor (pHba = hba_chain; pHba; pHba = pHba->next)\r\nscsi_remove_host(pHba->host);\r\nfor (pHba = hba_chain; pHba; pHba = next) {\r\nnext = pHba->next;\r\nadpt_release(pHba->host);\r\n}\r\n}
