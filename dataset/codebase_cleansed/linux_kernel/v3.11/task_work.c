int\r\ntask_work_add(struct task_struct *task, struct callback_head *work, bool notify)\r\n{\r\nstruct callback_head *head;\r\ndo {\r\nhead = ACCESS_ONCE(task->task_works);\r\nif (unlikely(head == &work_exited))\r\nreturn -ESRCH;\r\nwork->next = head;\r\n} while (cmpxchg(&task->task_works, head, work) != head);\r\nif (notify)\r\nset_notify_resume(task);\r\nreturn 0;\r\n}\r\nstruct callback_head *\r\ntask_work_cancel(struct task_struct *task, task_work_func_t func)\r\n{\r\nstruct callback_head **pprev = &task->task_works;\r\nstruct callback_head *work = NULL;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&task->pi_lock, flags);\r\nwhile ((work = ACCESS_ONCE(*pprev))) {\r\nread_barrier_depends();\r\nif (work->func != func)\r\npprev = &work->next;\r\nelse if (cmpxchg(pprev, work, work->next) == work)\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&task->pi_lock, flags);\r\nreturn work;\r\n}\r\nvoid task_work_run(void)\r\n{\r\nstruct task_struct *task = current;\r\nstruct callback_head *work, *head, *next;\r\nfor (;;) {\r\ndo {\r\nwork = ACCESS_ONCE(task->task_works);\r\nhead = !work && (task->flags & PF_EXITING) ?\r\n&work_exited : NULL;\r\n} while (cmpxchg(&task->task_works, work, head) != work);\r\nif (!work)\r\nbreak;\r\nraw_spin_unlock_wait(&task->pi_lock);\r\nsmp_mb();\r\nhead = NULL;\r\ndo {\r\nnext = work->next;\r\nwork->next = head;\r\nhead = work;\r\nwork = next;\r\n} while (work);\r\nwork = head;\r\ndo {\r\nnext = work->next;\r\nwork->func(work);\r\nwork = next;\r\ncond_resched();\r\n} while (work);\r\n}\r\n}
