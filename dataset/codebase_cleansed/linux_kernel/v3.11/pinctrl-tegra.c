static inline u32 pmx_readl(struct tegra_pmx *pmx, u32 bank, u32 reg)\r\n{\r\nreturn readl(pmx->regs[bank] + reg);\r\n}\r\nstatic inline void pmx_writel(struct tegra_pmx *pmx, u32 val, u32 bank, u32 reg)\r\n{\r\nwritel(val, pmx->regs[bank] + reg);\r\n}\r\nstatic int tegra_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->ngroups;\r\n}\r\nstatic const char *tegra_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->groups[group].name;\r\n}\r\nstatic int tegra_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pmx->soc->groups[group].pins;\r\n*num_pins = pmx->soc->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void tegra_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctldev->dev));\r\n}\r\nstatic int reserve_map(struct device *dev, struct pinctrl_map **map,\r\nunsigned *reserved_maps, unsigned *num_maps,\r\nunsigned reserve)\r\n{\r\nunsigned old_num = *reserved_maps;\r\nunsigned new_num = *num_maps + reserve;\r\nstruct pinctrl_map *new_map;\r\nif (old_num >= new_num)\r\nreturn 0;\r\nnew_map = krealloc(*map, sizeof(*new_map) * new_num, GFP_KERNEL);\r\nif (!new_map) {\r\ndev_err(dev, "krealloc(map) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));\r\n*map = new_map;\r\n*reserved_maps = new_num;\r\nreturn 0;\r\n}\r\nstatic int add_map_mux(struct pinctrl_map **map, unsigned *reserved_maps,\r\nunsigned *num_maps, const char *group,\r\nconst char *function)\r\n{\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = group;\r\n(*map)[*num_maps].data.mux.function = function;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int add_map_configs(struct device *dev, struct pinctrl_map **map,\r\nunsigned *reserved_maps, unsigned *num_maps,\r\nconst char *group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nunsigned long *dup_configs;\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\ndup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\r\nGFP_KERNEL);\r\nif (!dup_configs) {\r\ndev_err(dev, "kmemdup(configs) failed\n");\r\nreturn -ENOMEM;\r\n}\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n(*map)[*num_maps].data.configs.group_or_pin = group;\r\n(*map)[*num_maps].data.configs.configs = dup_configs;\r\n(*map)[*num_maps].data.configs.num_configs = num_configs;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int add_config(struct device *dev, unsigned long **configs,\r\nunsigned *num_configs, unsigned long config)\r\n{\r\nunsigned old_num = *num_configs;\r\nunsigned new_num = old_num + 1;\r\nunsigned long *new_configs;\r\nnew_configs = krealloc(*configs, sizeof(*new_configs) * new_num,\r\nGFP_KERNEL);\r\nif (!new_configs) {\r\ndev_err(dev, "krealloc(configs) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nnew_configs[old_num] = config;\r\n*configs = new_configs;\r\n*num_configs = new_num;\r\nreturn 0;\r\n}\r\nstatic void tegra_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++)\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\nkfree(map);\r\n}\r\nstatic int tegra_pinctrl_dt_subnode_to_map(struct device *dev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nint ret, i;\r\nconst char *function;\r\nu32 val;\r\nunsigned long config;\r\nunsigned long *configs = NULL;\r\nunsigned num_configs = 0;\r\nunsigned reserve;\r\nstruct property *prop;\r\nconst char *group;\r\nret = of_property_read_string(np, "nvidia,function", &function);\r\nif (ret < 0) {\r\nif (ret != -EINVAL)\r\ndev_err(dev,\r\n"could not parse property nvidia,function\n");\r\nfunction = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nret = of_property_read_u32(np, cfg_params[i].property, &val);\r\nif (!ret) {\r\nconfig = TEGRA_PINCONF_PACK(cfg_params[i].param, val);\r\nret = add_config(dev, &configs, &num_configs, config);\r\nif (ret < 0)\r\ngoto exit;\r\n} else if (ret != -EINVAL) {\r\ndev_err(dev, "could not parse property %s\n",\r\ncfg_params[i].property);\r\n}\r\n}\r\nreserve = 0;\r\nif (function != NULL)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nret = of_property_count_strings(np, "nvidia,pins");\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse property nvidia,pins\n");\r\ngoto exit;\r\n}\r\nreserve *= ret;\r\nret = reserve_map(dev, map, reserved_maps, num_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "nvidia,pins", prop, group) {\r\nif (function) {\r\nret = add_map_mux(map, reserved_maps, num_maps,\r\ngroup, function);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = add_map_configs(dev, map, reserved_maps,\r\nnum_maps, group, configs,\r\nnum_configs);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic int tegra_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = tegra_pinctrl_dt_subnode_to_map(pctldev->dev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0) {\r\ntegra_pinctrl_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->nfunctions;\r\n}\r\nstatic const char *tegra_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->soc->functions[function].name;\r\n}\r\nstatic int tegra_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pmx->soc->functions[function].groups;\r\n*num_groups = pmx->soc->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int tegra_pinctrl_enable(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tegra_pingroup *g;\r\nint i;\r\nu32 val;\r\ng = &pmx->soc->groups[group];\r\nif (WARN_ON(g->mux_reg < 0))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(g->funcs); i++) {\r\nif (g->funcs[i] == function)\r\nbreak;\r\n}\r\nif (WARN_ON(i == ARRAY_SIZE(g->funcs)))\r\nreturn -EINVAL;\r\nval = pmx_readl(pmx, g->mux_bank, g->mux_reg);\r\nval &= ~(0x3 << g->mux_bit);\r\nval |= i << g->mux_bit;\r\npmx_writel(pmx, val, g->mux_bank, g->mux_reg);\r\nreturn 0;\r\n}\r\nstatic void tegra_pinctrl_disable(struct pinctrl_dev *pctldev,\r\nunsigned function, unsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tegra_pingroup *g;\r\nu32 val;\r\ng = &pmx->soc->groups[group];\r\nif (WARN_ON(g->mux_reg < 0))\r\nreturn;\r\nval = pmx_readl(pmx, g->mux_bank, g->mux_reg);\r\nval &= ~(0x3 << g->mux_bit);\r\nval |= g->func_safe << g->mux_bit;\r\npmx_writel(pmx, val, g->mux_bank, g->mux_reg);\r\n}\r\nstatic int tegra_pinconf_reg(struct tegra_pmx *pmx,\r\nconst struct tegra_pingroup *g,\r\nenum tegra_pinconf_param param,\r\nbool report_err,\r\ns8 *bank, s16 *reg, s8 *bit, s8 *width)\r\n{\r\nswitch (param) {\r\ncase TEGRA_PINCONF_PARAM_PULL:\r\n*bank = g->pupd_bank;\r\n*reg = g->pupd_reg;\r\n*bit = g->pupd_bit;\r\n*width = 2;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_TRISTATE:\r\n*bank = g->tri_bank;\r\n*reg = g->tri_reg;\r\n*bit = g->tri_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_ENABLE_INPUT:\r\n*bank = g->einput_bank;\r\n*reg = g->einput_reg;\r\n*bit = g->einput_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_OPEN_DRAIN:\r\n*bank = g->odrain_bank;\r\n*reg = g->odrain_reg;\r\n*bit = g->odrain_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_LOCK:\r\n*bank = g->lock_bank;\r\n*reg = g->lock_reg;\r\n*bit = g->lock_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_IORESET:\r\n*bank = g->ioreset_bank;\r\n*reg = g->ioreset_reg;\r\n*bit = g->ioreset_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_RCV_SEL:\r\n*bank = g->rcv_sel_bank;\r\n*reg = g->rcv_sel_reg;\r\n*bit = g->rcv_sel_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_HIGH_SPEED_MODE:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->hsm_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_SCHMITT:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->schmitt_bit;\r\n*width = 1;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_LOW_POWER_MODE:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->lpmd_bit;\r\n*width = 2;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_DRIVE_DOWN_STRENGTH:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->drvdn_bit;\r\n*width = g->drvdn_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_DRIVE_UP_STRENGTH:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->drvup_bit;\r\n*width = g->drvup_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_SLEW_RATE_FALLING:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->slwf_bit;\r\n*width = g->slwf_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_SLEW_RATE_RISING:\r\n*bank = g->drv_bank;\r\n*reg = g->drv_reg;\r\n*bit = g->slwr_bit;\r\n*width = g->slwr_width;\r\nbreak;\r\ncase TEGRA_PINCONF_PARAM_DRIVE_TYPE:\r\n*bank = g->drvtype_bank;\r\n*reg = g->drvtype_reg;\r\n*bit = g->drvtype_bit;\r\n*width = 2;\r\nbreak;\r\ndefault:\r\ndev_err(pmx->dev, "Invalid config param %04x\n", param);\r\nreturn -ENOTSUPP;\r\n}\r\nif (*reg < 0) {\r\nif (report_err)\r\ndev_err(pmx->dev,\r\n"Config param %04x not supported on group %s\n",\r\nparam, g->name);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\ndev_err(pctldev->dev, "pin_config_get op not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int tegra_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long config)\r\n{\r\ndev_err(pctldev->dev, "pin_config_set op not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int tegra_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(*config);\r\nu16 arg;\r\nconst struct tegra_pingroup *g;\r\nint ret;\r\ns8 bank, bit, width;\r\ns16 reg;\r\nu32 val, mask;\r\ng = &pmx->soc->groups[group];\r\nret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,\r\n&width);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pmx_readl(pmx, bank, reg);\r\nmask = (1 << width) - 1;\r\narg = (val >> bit) & mask;\r\n*config = TEGRA_PINCONF_PACK(param, arg);\r\nreturn 0;\r\n}\r\nstatic int tegra_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long config)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(config);\r\nu16 arg = TEGRA_PINCONF_UNPACK_ARG(config);\r\nconst struct tegra_pingroup *g;\r\nint ret;\r\ns8 bank, bit, width;\r\ns16 reg;\r\nu32 val, mask;\r\ng = &pmx->soc->groups[group];\r\nret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,\r\n&width);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pmx_readl(pmx, bank, reg);\r\nif (param == TEGRA_PINCONF_PARAM_LOCK) {\r\nif ((val & BIT(bit)) && !arg) {\r\ndev_err(pctldev->dev, "LOCK bit cannot be cleared\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (width == 1)\r\narg = !!arg;\r\nmask = (1 << width) - 1;\r\nif (arg & ~mask) {\r\ndev_err(pctldev->dev,\r\n"config %lx: %x too big for %d bit register\n",\r\nconfig, arg, width);\r\nreturn -EINVAL;\r\n}\r\nval &= ~(mask << bit);\r\nval |= arg << bit;\r\npmx_writel(pmx, val, bank, reg);\r\nreturn 0;\r\n}\r\nstatic void tegra_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\n}\r\nstatic const char *strip_prefix(const char *s)\r\n{\r\nconst char *comma = strchr(s, ',');\r\nif (!comma)\r\nreturn s;\r\nreturn comma + 1;\r\n}\r\nstatic void tegra_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\nstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct tegra_pingroup *g;\r\nint i, ret;\r\ns8 bank, bit, width;\r\ns16 reg;\r\nu32 val;\r\ng = &pmx->soc->groups[group];\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nret = tegra_pinconf_reg(pmx, g, cfg_params[i].param, false,\r\n&bank, &reg, &bit, &width);\r\nif (ret < 0)\r\ncontinue;\r\nval = pmx_readl(pmx, bank, reg);\r\nval >>= bit;\r\nval &= (1 << width) - 1;\r\nseq_printf(s, "\n\t%s=%u",\r\nstrip_prefix(cfg_params[i].property), val);\r\n}\r\n}\r\nstatic void tegra_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned long config)\r\n{\r\nenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(config);\r\nu16 arg = TEGRA_PINCONF_UNPACK_ARG(config);\r\nconst char *pname = "unknown";\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nif (cfg_params[i].param == param) {\r\npname = cfg_params[i].property;\r\nbreak;\r\n}\r\n}\r\nseq_printf(s, "%s=%d", strip_prefix(pname), arg);\r\n}\r\nint tegra_pinctrl_probe(struct platform_device *pdev,\r\nconst struct tegra_pinctrl_soc_data *soc_data)\r\n{\r\nstruct tegra_pmx *pmx;\r\nstruct resource *res;\r\nint i;\r\npmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (!pmx) {\r\ndev_err(&pdev->dev, "Can't alloc tegra_pmx\n");\r\nreturn -ENOMEM;\r\n}\r\npmx->dev = &pdev->dev;\r\npmx->soc = soc_data;\r\ntegra_pinctrl_gpio_range.npins = pmx->soc->ngpios;\r\ntegra_pinctrl_desc.name = dev_name(&pdev->dev);\r\ntegra_pinctrl_desc.pins = pmx->soc->pins;\r\ntegra_pinctrl_desc.npins = pmx->soc->npins;\r\nfor (i = 0; ; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nbreak;\r\n}\r\npmx->nbanks = i;\r\npmx->regs = devm_kzalloc(&pdev->dev, pmx->nbanks * sizeof(*pmx->regs),\r\nGFP_KERNEL);\r\nif (!pmx->regs) {\r\ndev_err(&pdev->dev, "Can't alloc regs pointer\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < pmx->nbanks; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Missing MEM resource\n");\r\nreturn -ENODEV;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res),\r\ndev_name(&pdev->dev))) {\r\ndev_err(&pdev->dev,\r\n"Couldn't request MEM resource %d\n", i);\r\nreturn -ENODEV;\r\n}\r\npmx->regs[i] = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!pmx->regs[i]) {\r\ndev_err(&pdev->dev, "Couldn't ioremap regs %d\n", i);\r\nreturn -ENODEV;\r\n}\r\n}\r\npmx->pctl = pinctrl_register(&tegra_pinctrl_desc, &pdev->dev, pmx);\r\nif (!pmx->pctl) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn -ENODEV;\r\n}\r\npinctrl_add_gpio_range(pmx->pctl, &tegra_pinctrl_gpio_range);\r\nplatform_set_drvdata(pdev, pmx);\r\ndev_dbg(&pdev->dev, "Probed Tegra pinctrl driver\n");\r\nreturn 0;\r\n}\r\nint tegra_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_pmx *pmx = platform_get_drvdata(pdev);\r\npinctrl_unregister(pmx->pctl);\r\nreturn 0;\r\n}
