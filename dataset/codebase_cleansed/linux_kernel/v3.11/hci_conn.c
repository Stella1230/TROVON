static void hci_le_create_connection(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_le_create_conn cp;\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->link_mode |= HCI_LM_MASTER;\r\nconn->sec_level = BT_SECURITY_LOW;\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.scan_interval = __constant_cpu_to_le16(0x0060);\r\ncp.scan_window = __constant_cpu_to_le16(0x0030);\r\nbacpy(&cp.peer_addr, &conn->dst);\r\ncp.peer_addr_type = conn->dst_type;\r\ncp.conn_interval_min = __constant_cpu_to_le16(0x0028);\r\ncp.conn_interval_max = __constant_cpu_to_le16(0x0038);\r\ncp.supervision_timeout = __constant_cpu_to_le16(0x002a);\r\ncp.min_ce_len = __constant_cpu_to_le16(0x0000);\r\ncp.max_ce_len = __constant_cpu_to_le16(0x0000);\r\nhci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);\r\n}\r\nstatic void hci_le_create_connection_cancel(struct hci_conn *conn)\r\n{\r\nhci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);\r\n}\r\nstatic void hci_acl_create_connection(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct inquiry_entry *ie;\r\nstruct hci_cp_create_conn cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->link_mode = HCI_LM_MASTER;\r\nconn->attempt++;\r\nconn->link_policy = hdev->link_policy;\r\nmemset(&cp, 0, sizeof(cp));\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.pscan_rep_mode = 0x02;\r\nie = hci_inquiry_cache_lookup(hdev, &conn->dst);\r\nif (ie) {\r\nif (inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {\r\ncp.pscan_rep_mode = ie->data.pscan_rep_mode;\r\ncp.pscan_mode = ie->data.pscan_mode;\r\ncp.clock_offset = ie->data.clock_offset |\r\n__constant_cpu_to_le16(0x8000);\r\n}\r\nmemcpy(conn->dev_class, ie->data.dev_class, 3);\r\nif (ie->data.ssp_mode > 0)\r\nset_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\r\n}\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\nif (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))\r\ncp.role_switch = 0x01;\r\nelse\r\ncp.role_switch = 0x00;\r\nhci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);\r\n}\r\nstatic void hci_acl_create_connection_cancel(struct hci_conn *conn)\r\n{\r\nstruct hci_cp_create_conn_cancel cp;\r\nBT_DBG("hcon %p", conn);\r\nif (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)\r\nreturn;\r\nbacpy(&cp.bdaddr, &conn->dst);\r\nhci_send_cmd(conn->hdev, HCI_OP_CREATE_CONN_CANCEL, sizeof(cp), &cp);\r\n}\r\nstatic void hci_reject_sco(struct hci_conn *conn)\r\n{\r\nstruct hci_cp_reject_sync_conn_req cp;\r\ncp.reason = HCI_ERROR_REMOTE_USER_TERM;\r\nbacpy(&cp.bdaddr, &conn->dst);\r\nhci_send_cmd(conn->hdev, HCI_OP_REJECT_SYNC_CONN_REQ, sizeof(cp), &cp);\r\n}\r\nvoid hci_disconnect(struct hci_conn *conn, __u8 reason)\r\n{\r\nstruct hci_cp_disconnect cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_DISCONN;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.reason = reason;\r\nhci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);\r\n}\r\nstatic void hci_amp_disconn(struct hci_conn *conn, __u8 reason)\r\n{\r\nstruct hci_cp_disconn_phy_link cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_DISCONN;\r\ncp.phy_handle = HCI_PHY_HANDLE(conn->handle);\r\ncp.reason = reason;\r\nhci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHY_LINK,\r\nsizeof(cp), &cp);\r\n}\r\nstatic void hci_add_sco(struct hci_conn *conn, __u16 handle)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_add_sco cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->attempt++;\r\ncp.handle = cpu_to_le16(handle);\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\nhci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);\r\n}\r\nvoid hci_setup_sync(struct hci_conn *conn, __u16 handle)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_setup_sync_conn cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->attempt++;\r\ncp.handle = cpu_to_le16(handle);\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\ncp.tx_bandwidth = __constant_cpu_to_le32(0x00001f40);\r\ncp.rx_bandwidth = __constant_cpu_to_le32(0x00001f40);\r\ncp.max_latency = __constant_cpu_to_le16(0xffff);\r\ncp.voice_setting = cpu_to_le16(hdev->voice_setting);\r\ncp.retrans_effort = 0xff;\r\nhci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);\r\n}\r\nvoid hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,\r\nu16 latency, u16 to_multiplier)\r\n{\r\nstruct hci_cp_le_conn_update cp;\r\nstruct hci_dev *hdev = conn->hdev;\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.conn_interval_min = cpu_to_le16(min);\r\ncp.conn_interval_max = cpu_to_le16(max);\r\ncp.conn_latency = cpu_to_le16(latency);\r\ncp.supervision_timeout = cpu_to_le16(to_multiplier);\r\ncp.min_ce_len = __constant_cpu_to_le16(0x0001);\r\ncp.max_ce_len = __constant_cpu_to_le16(0x0001);\r\nhci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);\r\n}\r\nvoid hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],\r\n__u8 ltk[16])\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_le_start_enc cp;\r\nBT_DBG("hcon %p", conn);\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.handle = cpu_to_le16(conn->handle);\r\nmemcpy(cp.ltk, ltk, sizeof(cp.ltk));\r\ncp.ediv = ediv;\r\nmemcpy(cp.rand, rand, sizeof(cp.rand));\r\nhci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);\r\n}\r\nvoid hci_sco_setup(struct hci_conn *conn, __u8 status)\r\n{\r\nstruct hci_conn *sco = conn->link;\r\nif (!sco)\r\nreturn;\r\nBT_DBG("hcon %p", conn);\r\nif (!status) {\r\nif (lmp_esco_capable(conn->hdev))\r\nhci_setup_sync(sco, conn->handle);\r\nelse\r\nhci_add_sco(sco, conn->handle);\r\n} else {\r\nhci_proto_connect_cfm(sco, status);\r\nhci_conn_del(sco);\r\n}\r\n}\r\nstatic void hci_conn_disconnect(struct hci_conn *conn)\r\n{\r\n__u8 reason = hci_proto_disconn_ind(conn);\r\nswitch (conn->type) {\r\ncase AMP_LINK:\r\nhci_amp_disconn(conn, reason);\r\nbreak;\r\ndefault:\r\nhci_disconnect(conn, reason);\r\nbreak;\r\n}\r\n}\r\nstatic void hci_conn_timeout(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn,\r\ndisc_work.work);\r\nBT_DBG("hcon %p state %s", conn, state_to_string(conn->state));\r\nif (atomic_read(&conn->refcnt))\r\nreturn;\r\nswitch (conn->state) {\r\ncase BT_CONNECT:\r\ncase BT_CONNECT2:\r\nif (conn->out) {\r\nif (conn->type == ACL_LINK)\r\nhci_acl_create_connection_cancel(conn);\r\nelse if (conn->type == LE_LINK)\r\nhci_le_create_connection_cancel(conn);\r\n} else if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {\r\nhci_reject_sco(conn);\r\n}\r\nbreak;\r\ncase BT_CONFIG:\r\ncase BT_CONNECTED:\r\nhci_conn_disconnect(conn);\r\nbreak;\r\ndefault:\r\nconn->state = BT_CLOSED;\r\nbreak;\r\n}\r\n}\r\nstatic void hci_conn_enter_sniff_mode(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("hcon %p mode %d", conn, conn->mode);\r\nif (test_bit(HCI_RAW, &hdev->flags))\r\nreturn;\r\nif (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))\r\nreturn;\r\nif (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))\r\nreturn;\r\nif (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {\r\nstruct hci_cp_sniff_subrate cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.max_latency = __constant_cpu_to_le16(0);\r\ncp.min_remote_timeout = __constant_cpu_to_le16(0);\r\ncp.min_local_timeout = __constant_cpu_to_le16(0);\r\nhci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);\r\n}\r\nif (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {\r\nstruct hci_cp_sniff_mode cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.max_interval = cpu_to_le16(hdev->sniff_max_interval);\r\ncp.min_interval = cpu_to_le16(hdev->sniff_min_interval);\r\ncp.attempt = __constant_cpu_to_le16(4);\r\ncp.timeout = __constant_cpu_to_le16(1);\r\nhci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);\r\n}\r\n}\r\nstatic void hci_conn_idle(unsigned long arg)\r\n{\r\nstruct hci_conn *conn = (void *) arg;\r\nBT_DBG("hcon %p mode %d", conn, conn->mode);\r\nhci_conn_enter_sniff_mode(conn);\r\n}\r\nstatic void hci_conn_auto_accept(unsigned long arg)\r\n{\r\nstruct hci_conn *conn = (void *) arg;\r\nstruct hci_dev *hdev = conn->hdev;\r\nhci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),\r\n&conn->dst);\r\n}\r\nstruct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)\r\n{\r\nstruct hci_conn *conn;\r\nBT_DBG("%s dst %pMR", hdev->name, dst);\r\nconn = kzalloc(sizeof(struct hci_conn), GFP_KERNEL);\r\nif (!conn)\r\nreturn NULL;\r\nbacpy(&conn->dst, dst);\r\nconn->hdev = hdev;\r\nconn->type = type;\r\nconn->mode = HCI_CM_ACTIVE;\r\nconn->state = BT_OPEN;\r\nconn->auth_type = HCI_AT_GENERAL_BONDING;\r\nconn->io_capability = hdev->io_capability;\r\nconn->remote_auth = 0xff;\r\nconn->key_type = 0xff;\r\nset_bit(HCI_CONN_POWER_SAVE, &conn->flags);\r\nconn->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nswitch (type) {\r\ncase ACL_LINK:\r\nconn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;\r\nbreak;\r\ncase SCO_LINK:\r\nif (lmp_esco_capable(hdev))\r\nconn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |\r\n(hdev->esco_type & EDR_ESCO_MASK);\r\nelse\r\nconn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;\r\nbreak;\r\ncase ESCO_LINK:\r\nconn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;\r\nbreak;\r\n}\r\nskb_queue_head_init(&conn->data_q);\r\nINIT_LIST_HEAD(&conn->chan_list);\r\nINIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);\r\nsetup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);\r\nsetup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,\r\n(unsigned long) conn);\r\natomic_set(&conn->refcnt, 0);\r\nhci_dev_hold(hdev);\r\nhci_conn_hash_add(hdev, conn);\r\nif (hdev->notify)\r\nhdev->notify(hdev, HCI_NOTIFY_CONN_ADD);\r\nhci_conn_init_sysfs(conn);\r\nreturn conn;\r\n}\r\nint hci_conn_del(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("%s hcon %p handle %d", hdev->name, conn, conn->handle);\r\ndel_timer(&conn->idle_timer);\r\ncancel_delayed_work_sync(&conn->disc_work);\r\ndel_timer(&conn->auto_accept_timer);\r\nif (conn->type == ACL_LINK) {\r\nstruct hci_conn *sco = conn->link;\r\nif (sco)\r\nsco->link = NULL;\r\nhdev->acl_cnt += conn->sent;\r\n} else if (conn->type == LE_LINK) {\r\nif (hdev->le_pkts)\r\nhdev->le_cnt += conn->sent;\r\nelse\r\nhdev->acl_cnt += conn->sent;\r\n} else {\r\nstruct hci_conn *acl = conn->link;\r\nif (acl) {\r\nacl->link = NULL;\r\nhci_conn_drop(acl);\r\n}\r\n}\r\nhci_chan_list_flush(conn);\r\nif (conn->amp_mgr)\r\namp_mgr_put(conn->amp_mgr);\r\nhci_conn_hash_del(hdev, conn);\r\nif (hdev->notify)\r\nhdev->notify(hdev, HCI_NOTIFY_CONN_DEL);\r\nskb_queue_purge(&conn->data_q);\r\nhci_conn_del_sysfs(conn);\r\nhci_dev_put(hdev);\r\nhci_conn_put(conn);\r\nreturn 0;\r\n}\r\nstruct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)\r\n{\r\nint use_src = bacmp(src, BDADDR_ANY);\r\nstruct hci_dev *hdev = NULL, *d;\r\nBT_DBG("%pMR -> %pMR", src, dst);\r\nread_lock(&hci_dev_list_lock);\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (!test_bit(HCI_UP, &d->flags) ||\r\ntest_bit(HCI_RAW, &d->flags) ||\r\nd->dev_type != HCI_BREDR)\r\ncontinue;\r\nif (use_src) {\r\nif (!bacmp(&d->bdaddr, src)) {\r\nhdev = d; break;\r\n}\r\n} else {\r\nif (bacmp(&d->bdaddr, dst)) {\r\nhdev = d; break;\r\n}\r\n}\r\n}\r\nif (hdev)\r\nhdev = hci_dev_hold(hdev);\r\nread_unlock(&hci_dev_list_lock);\r\nreturn hdev;\r\n}\r\nstatic struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,\r\nu8 dst_type, u8 sec_level, u8 auth_type)\r\n{\r\nstruct hci_conn *le;\r\nif (test_bit(HCI_LE_PERIPHERAL, &hdev->flags))\r\nreturn ERR_PTR(-ENOTSUPP);\r\nle = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);\r\nif (!le) {\r\nle = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);\r\nif (le)\r\nreturn ERR_PTR(-EBUSY);\r\nle = hci_conn_add(hdev, LE_LINK, dst);\r\nif (!le)\r\nreturn ERR_PTR(-ENOMEM);\r\nle->dst_type = bdaddr_to_le(dst_type);\r\nhci_le_create_connection(le);\r\n}\r\nle->pending_sec_level = sec_level;\r\nle->auth_type = auth_type;\r\nhci_conn_hold(le);\r\nreturn le;\r\n}\r\nstatic struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,\r\nu8 sec_level, u8 auth_type)\r\n{\r\nstruct hci_conn *acl;\r\nacl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);\r\nif (!acl) {\r\nacl = hci_conn_add(hdev, ACL_LINK, dst);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nhci_conn_hold(acl);\r\nif (acl->state == BT_OPEN || acl->state == BT_CLOSED) {\r\nacl->sec_level = BT_SECURITY_LOW;\r\nacl->pending_sec_level = sec_level;\r\nacl->auth_type = auth_type;\r\nhci_acl_create_connection(acl);\r\n}\r\nreturn acl;\r\n}\r\nstatic struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,\r\nbdaddr_t *dst, u8 sec_level, u8 auth_type)\r\n{\r\nstruct hci_conn *acl;\r\nstruct hci_conn *sco;\r\nacl = hci_connect_acl(hdev, dst, sec_level, auth_type);\r\nif (IS_ERR(acl))\r\nreturn acl;\r\nsco = hci_conn_hash_lookup_ba(hdev, type, dst);\r\nif (!sco) {\r\nsco = hci_conn_add(hdev, type, dst);\r\nif (!sco) {\r\nhci_conn_drop(acl);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nacl->link = sco;\r\nsco->link = acl;\r\nhci_conn_hold(sco);\r\nif (acl->state == BT_CONNECTED &&\r\n(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {\r\nset_bit(HCI_CONN_POWER_SAVE, &acl->flags);\r\nhci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);\r\nif (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {\r\nset_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);\r\nreturn sco;\r\n}\r\nhci_sco_setup(acl, 0x00);\r\n}\r\nreturn sco;\r\n}\r\nstruct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,\r\n__u8 dst_type, __u8 sec_level, __u8 auth_type)\r\n{\r\nBT_DBG("%s dst %pMR type 0x%x", hdev->name, dst, type);\r\nswitch (type) {\r\ncase LE_LINK:\r\nreturn hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);\r\ncase ACL_LINK:\r\nreturn hci_connect_acl(hdev, dst, sec_level, auth_type);\r\ncase SCO_LINK:\r\ncase ESCO_LINK:\r\nreturn hci_connect_sco(hdev, type, dst, sec_level, auth_type);\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nint hci_conn_check_link_mode(struct hci_conn *conn)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (conn->pending_sec_level > sec_level)\r\nsec_level = conn->pending_sec_level;\r\nif (sec_level > conn->sec_level)\r\nconn->pending_sec_level = sec_level;\r\nelse if (conn->link_mode & HCI_LM_AUTH)\r\nreturn 1;\r\nauth_type |= (conn->auth_type & 0x01);\r\nconn->auth_type = auth_type;\r\nif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\r\nstruct hci_cp_auth_requested cp;\r\nset_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\r\ncp.handle = cpu_to_le16(conn->handle);\r\nhci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,\r\nsizeof(cp), &cp);\r\nif (conn->key_type != 0xff)\r\nset_bit(HCI_CONN_REAUTH_PEND, &conn->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hci_conn_encrypt(struct hci_conn *conn)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {\r\nstruct hci_cp_set_conn_encrypt cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.encrypt = 0x01;\r\nhci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\r\n&cp);\r\n}\r\n}\r\nint hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (conn->type == LE_LINK)\r\nreturn smp_conn_security(conn, sec_level);\r\nif (sec_level == BT_SECURITY_SDP)\r\nreturn 1;\r\nif (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))\r\nreturn 1;\r\nif (!(conn->link_mode & HCI_LM_AUTH))\r\ngoto auth;\r\nif (conn->key_type == HCI_LK_AUTH_COMBINATION)\r\ngoto encrypt;\r\nif (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&\r\n(sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW))\r\ngoto encrypt;\r\nif (conn->key_type == HCI_LK_COMBINATION &&\r\n(sec_level != BT_SECURITY_HIGH || conn->pin_length == 16))\r\ngoto encrypt;\r\nauth:\r\nif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))\r\nreturn 0;\r\nif (!hci_conn_auth(conn, sec_level, auth_type))\r\nreturn 0;\r\nencrypt:\r\nif (conn->link_mode & HCI_LM_ENCRYPT)\r\nreturn 1;\r\nhci_conn_encrypt(conn);\r\nreturn 0;\r\n}\r\nint hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (sec_level != BT_SECURITY_HIGH)\r\nreturn 1;\r\nif (conn->sec_level == BT_SECURITY_HIGH)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint hci_conn_change_link_key(struct hci_conn *conn)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\r\nstruct hci_cp_change_conn_link_key cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\nhci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,\r\nsizeof(cp), &cp);\r\n}\r\nreturn 0;\r\n}\r\nint hci_conn_switch_role(struct hci_conn *conn, __u8 role)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (!role && conn->link_mode & HCI_LM_MASTER)\r\nreturn 1;\r\nif (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {\r\nstruct hci_cp_switch_role cp;\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.role = role;\r\nhci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);\r\n}\r\nreturn 0;\r\n}\r\nvoid hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("hcon %p mode %d", conn, conn->mode);\r\nif (test_bit(HCI_RAW, &hdev->flags))\r\nreturn;\r\nif (conn->mode != HCI_CM_SNIFF)\r\ngoto timer;\r\nif (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)\r\ngoto timer;\r\nif (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {\r\nstruct hci_cp_exit_sniff_mode cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\nhci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);\r\n}\r\ntimer:\r\nif (hdev->idle_timeout > 0)\r\nmod_timer(&conn->idle_timer,\r\njiffies + msecs_to_jiffies(hdev->idle_timeout));\r\n}\r\nvoid hci_conn_hash_flush(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *c, *n;\r\nBT_DBG("hdev %s", hdev->name);\r\nlist_for_each_entry_safe(c, n, &h->list, list) {\r\nc->state = BT_CLOSED;\r\nhci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);\r\nhci_conn_del(c);\r\n}\r\n}\r\nvoid hci_conn_check_pending(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn *conn;\r\nBT_DBG("hdev %s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECT2);\r\nif (conn)\r\nhci_acl_create_connection(conn);\r\nhci_dev_unlock(hdev);\r\n}\r\nint hci_get_conn_list(void __user *arg)\r\n{\r\nstruct hci_conn *c;\r\nstruct hci_conn_list_req req, *cl;\r\nstruct hci_conn_info *ci;\r\nstruct hci_dev *hdev;\r\nint n = 0, size, err;\r\nif (copy_from_user(&req, arg, sizeof(req)))\r\nreturn -EFAULT;\r\nif (!req.conn_num || req.conn_num > (PAGE_SIZE * 2) / sizeof(*ci))\r\nreturn -EINVAL;\r\nsize = sizeof(req) + req.conn_num * sizeof(*ci);\r\ncl = kmalloc(size, GFP_KERNEL);\r\nif (!cl)\r\nreturn -ENOMEM;\r\nhdev = hci_dev_get(req.dev_id);\r\nif (!hdev) {\r\nkfree(cl);\r\nreturn -ENODEV;\r\n}\r\nci = cl->conn_info;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(c, &hdev->conn_hash.list, list) {\r\nbacpy(&(ci + n)->bdaddr, &c->dst);\r\n(ci + n)->handle = c->handle;\r\n(ci + n)->type = c->type;\r\n(ci + n)->out = c->out;\r\n(ci + n)->state = c->state;\r\n(ci + n)->link_mode = c->link_mode;\r\nif (++n >= req.conn_num)\r\nbreak;\r\n}\r\nhci_dev_unlock(hdev);\r\ncl->dev_id = hdev->id;\r\ncl->conn_num = n;\r\nsize = sizeof(req) + n * sizeof(*ci);\r\nhci_dev_put(hdev);\r\nerr = copy_to_user(arg, cl, size);\r\nkfree(cl);\r\nreturn err ? -EFAULT : 0;\r\n}\r\nint hci_get_conn_info(struct hci_dev *hdev, void __user *arg)\r\n{\r\nstruct hci_conn_info_req req;\r\nstruct hci_conn_info ci;\r\nstruct hci_conn *conn;\r\nchar __user *ptr = arg + sizeof(req);\r\nif (copy_from_user(&req, arg, sizeof(req)))\r\nreturn -EFAULT;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);\r\nif (conn) {\r\nbacpy(&ci.bdaddr, &conn->dst);\r\nci.handle = conn->handle;\r\nci.type = conn->type;\r\nci.out = conn->out;\r\nci.state = conn->state;\r\nci.link_mode = conn->link_mode;\r\n}\r\nhci_dev_unlock(hdev);\r\nif (!conn)\r\nreturn -ENOENT;\r\nreturn copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;\r\n}\r\nint hci_get_auth_info(struct hci_dev *hdev, void __user *arg)\r\n{\r\nstruct hci_auth_info_req req;\r\nstruct hci_conn *conn;\r\nif (copy_from_user(&req, arg, sizeof(req)))\r\nreturn -EFAULT;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);\r\nif (conn)\r\nreq.type = conn->auth_type;\r\nhci_dev_unlock(hdev);\r\nif (!conn)\r\nreturn -ENOENT;\r\nreturn copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;\r\n}\r\nstruct hci_chan *hci_chan_create(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_chan *chan;\r\nBT_DBG("%s hcon %p", hdev->name, conn);\r\nchan = kzalloc(sizeof(struct hci_chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn NULL;\r\nchan->conn = conn;\r\nskb_queue_head_init(&chan->data_q);\r\nchan->state = BT_CONNECTED;\r\nlist_add_rcu(&chan->list, &conn->chan_list);\r\nreturn chan;\r\n}\r\nvoid hci_chan_del(struct hci_chan *chan)\r\n{\r\nstruct hci_conn *conn = chan->conn;\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("%s hcon %p chan %p", hdev->name, conn, chan);\r\nlist_del_rcu(&chan->list);\r\nsynchronize_rcu();\r\nhci_conn_drop(conn);\r\nskb_queue_purge(&chan->data_q);\r\nkfree(chan);\r\n}\r\nvoid hci_chan_list_flush(struct hci_conn *conn)\r\n{\r\nstruct hci_chan *chan, *n;\r\nBT_DBG("hcon %p", conn);\r\nlist_for_each_entry_safe(chan, n, &conn->chan_list, list)\r\nhci_chan_del(chan);\r\n}\r\nstatic struct hci_chan *__hci_chan_lookup_handle(struct hci_conn *hcon,\r\n__u16 handle)\r\n{\r\nstruct hci_chan *hchan;\r\nlist_for_each_entry(hchan, &hcon->chan_list, list) {\r\nif (hchan->handle == handle)\r\nreturn hchan;\r\n}\r\nreturn NULL;\r\n}\r\nstruct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *hcon;\r\nstruct hci_chan *hchan = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hcon, &h->list, list) {\r\nhchan = __hci_chan_lookup_handle(hcon, handle);\r\nif (hchan)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn hchan;\r\n}
