static void taos_defaults(struct tsl2583_chip *chip)\r\n{\r\nchip->taos_settings.als_time = 100;\r\nchip->taos_settings.als_gain = 0;\r\nchip->taos_settings.als_gain_trim = 1000;\r\nchip->taos_settings.als_cal_target = 130;\r\n}\r\nstatic int\r\ntaos_i2c_read(struct i2c_client *client, u8 reg, u8 *val, unsigned int len)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < len; i++) {\r\nret = i2c_smbus_write_byte(client, (TSL258X_CMD_REG | reg));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "taos_i2c_read failed to write"\r\n" register %x\n", reg);\r\nreturn ret;\r\n}\r\n*val = i2c_smbus_read_byte(client);\r\nval++;\r\nreg++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int taos_get_lux(struct iio_dev *indio_dev)\r\n{\r\nu16 ch0, ch1;\r\nu32 lux;\r\nu64 lux64;\r\nu32 ratio;\r\nu8 buf[5];\r\nstruct taos_lux *p;\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint i, ret;\r\nu32 ch0lux = 0;\r\nu32 ch1lux = 0;\r\nif (mutex_trylock(&chip->als_mutex) == 0) {\r\ndev_info(&chip->client->dev, "taos_get_lux device is busy\n");\r\nreturn chip->als_cur_info.lux;\r\n}\r\nif (chip->taos_chip_status != TSL258X_CHIP_WORKING) {\r\ndev_err(&chip->client->dev, "taos_get_lux device is not enabled\n");\r\nret = -EBUSY ;\r\ngoto out_unlock;\r\n}\r\nret = taos_i2c_read(chip->client, (TSL258X_CMD_REG), &buf[0], 1);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "taos_get_lux failed to read CMD_REG\n");\r\ngoto out_unlock;\r\n}\r\nif (!(buf[0] & TSL258X_STA_ADC_INTR)) {\r\ndev_err(&chip->client->dev, "taos_get_lux data not valid\n");\r\nret = chip->als_cur_info.lux;\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nint reg = TSL258X_CMD_REG | (TSL258X_ALS_CHAN0LO + i);\r\nret = taos_i2c_read(chip->client, reg, &buf[i], 1);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "taos_get_lux failed to read"\r\n" register %x\n", reg);\r\ngoto out_unlock;\r\n}\r\n}\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL258X_CMD_REG | TSL258X_CMD_SPL_FN |\r\nTSL258X_CMD_ALS_INT_CLR));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"taos_i2c_write_command failed in taos_get_lux, err = %d\n",\r\nret);\r\ngoto out_unlock;\r\n}\r\nch0 = le16_to_cpup((const __le16 *)&buf[0]);\r\nch1 = le16_to_cpup((const __le16 *)&buf[2]);\r\nchip->als_cur_info.als_ch0 = ch0;\r\nchip->als_cur_info.als_ch1 = ch1;\r\nif ((ch0 >= chip->als_saturation) || (ch1 >= chip->als_saturation))\r\ngoto return_max;\r\nif (ch0 == 0) {\r\nret = chip->als_cur_info.lux = 0;\r\ngoto out_unlock;\r\n}\r\nratio = (ch1 << 15) / ch0;\r\nfor (p = (struct taos_lux *) taos_device_lux;\r\np->ratio != 0 && p->ratio < ratio; p++)\r\n;\r\nif (p->ratio == 0) {\r\nlux = 0;\r\n} else {\r\nch0lux = ((ch0 * p->ch0) +\r\n(gainadj[chip->taos_settings.als_gain].ch0 >> 1))\r\n/ gainadj[chip->taos_settings.als_gain].ch0;\r\nch1lux = ((ch1 * p->ch1) +\r\n(gainadj[chip->taos_settings.als_gain].ch1 >> 1))\r\n/ gainadj[chip->taos_settings.als_gain].ch1;\r\nlux = ch0lux - ch1lux;\r\n}\r\nif (ch1lux > ch0lux) {\r\ndev_dbg(&chip->client->dev, "No Data - Return last value\n");\r\nret = chip->als_cur_info.lux = 0;\r\ngoto out_unlock;\r\n}\r\nif (chip->als_time_scale == 0)\r\nlux = 0;\r\nelse\r\nlux = (lux + (chip->als_time_scale >> 1)) /\r\nchip->als_time_scale;\r\nlux64 = lux;\r\nlux64 = lux64 * chip->taos_settings.als_gain_trim;\r\nlux64 >>= 13;\r\nlux = lux64;\r\nlux = (lux + 500) / 1000;\r\nif (lux > TSL258X_LUX_CALC_OVER_FLOW) {\r\nreturn_max:\r\nlux = TSL258X_LUX_CALC_OVER_FLOW;\r\n}\r\nchip->als_cur_info.lux = lux;\r\nret = lux;\r\nout_unlock:\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int taos_als_calibrate(struct iio_dev *indio_dev)\r\n{\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nu8 reg_val;\r\nunsigned int gain_trim_val;\r\nint ret;\r\nint lux_val;\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL258X_CMD_REG | TSL258X_CNTRL));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"taos_als_calibrate failed to reach the CNTRL register, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreg_val = i2c_smbus_read_byte(chip->client);\r\nif ((reg_val & (TSL258X_CNTL_ADC_ENBL | TSL258X_CNTL_PWR_ON))\r\n!= (TSL258X_CNTL_ADC_ENBL | TSL258X_CNTL_PWR_ON)) {\r\ndev_err(&chip->client->dev,\r\n"taos_als_calibrate failed: device not powered on with ADC enabled\n");\r\nreturn -1;\r\n}\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL258X_CMD_REG | TSL258X_CNTRL));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"taos_als_calibrate failed to reach the STATUS register, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreg_val = i2c_smbus_read_byte(chip->client);\r\nif ((reg_val & TSL258X_STA_ADC_VALID) != TSL258X_STA_ADC_VALID) {\r\ndev_err(&chip->client->dev,\r\n"taos_als_calibrate failed: STATUS - ADC not valid.\n");\r\nreturn -ENODATA;\r\n}\r\nlux_val = taos_get_lux(indio_dev);\r\nif (lux_val < 0) {\r\ndev_err(&chip->client->dev, "taos_als_calibrate failed to get lux\n");\r\nreturn lux_val;\r\n}\r\ngain_trim_val = (unsigned int) (((chip->taos_settings.als_cal_target)\r\n* chip->taos_settings.als_gain_trim) / lux_val);\r\nif ((gain_trim_val < 250) || (gain_trim_val > 4000)) {\r\ndev_err(&chip->client->dev,\r\n"taos_als_calibrate failed: trim_val of %d is out of range\n",\r\ngain_trim_val);\r\nreturn -ENODATA;\r\n}\r\nchip->taos_settings.als_gain_trim = (int) gain_trim_val;\r\nreturn (int) gain_trim_val;\r\n}\r\nstatic int taos_chip_on(struct iio_dev *indio_dev)\r\n{\r\nint i;\r\nint ret;\r\nu8 *uP;\r\nu8 utmp;\r\nint als_count;\r\nint als_time;\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nif (chip->taos_chip_status == TSL258X_CHIP_WORKING) {\r\ndev_info(&chip->client->dev, "device is already enabled\n");\r\nreturn -EINVAL;\r\n}\r\nals_count = (chip->taos_settings.als_time * 100 + 135) / 270;\r\nif (als_count == 0)\r\nals_count = 1;\r\nals_time = (als_count * 27 + 5) / 10;\r\nchip->taos_config[TSL258X_ALS_TIME] = 256 - als_count;\r\nchip->taos_config[TSL258X_GAIN] = chip->taos_settings.als_gain;\r\nchip->als_saturation = als_count * 922;\r\nchip->als_time_scale = (als_time + 25) / 50;\r\nutmp = TSL258X_CNTL_PWR_ON;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL258X_CMD_REG | TSL258X_CNTRL, utmp);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "taos_chip_on failed on CNTRL reg.\n");\r\nreturn -1;\r\n}\r\nfor (i = 0, uP = chip->taos_config; i < TSL258X_REG_MAX; i++) {\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL258X_CMD_REG + i,\r\n*uP++);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"taos_chip_on failed on reg %d.\n", i);\r\nreturn -1;\r\n}\r\n}\r\nmsleep(3);\r\nutmp = TSL258X_CNTL_PWR_ON | TSL258X_CNTL_ADC_ENBL;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL258X_CMD_REG | TSL258X_CNTRL,\r\nutmp);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "taos_chip_on failed on 2nd CTRL reg.\n");\r\nreturn -1;\r\n}\r\nchip->taos_chip_status = TSL258X_CHIP_WORKING;\r\nreturn ret;\r\n}\r\nstatic int taos_chip_off(struct iio_dev *indio_dev)\r\n{\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nchip->taos_chip_status = TSL258X_CHIP_SUSPENDED;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL258X_CMD_REG | TSL258X_CNTRL,\r\n0x00);\r\nreturn ret;\r\n}\r\nstatic ssize_t taos_power_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->taos_chip_status);\r\n}\r\nstatic ssize_t taos_power_state_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (value == 0)\r\ntaos_chip_off(indio_dev);\r\nelse\r\ntaos_chip_on(indio_dev);\r\nreturn len;\r\n}\r\nstatic ssize_t taos_gain_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nchar gain[4] = {0};\r\nswitch (chip->taos_settings.als_gain) {\r\ncase 0:\r\nstrcpy(gain, "001");\r\nbreak;\r\ncase 1:\r\nstrcpy(gain, "008");\r\nbreak;\r\ncase 2:\r\nstrcpy(gain, "016");\r\nbreak;\r\ncase 3:\r\nstrcpy(gain, "111");\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s\n", gain);\r\n}\r\nstatic ssize_t taos_gain_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nswitch (value) {\r\ncase 1:\r\nchip->taos_settings.als_gain = 0;\r\nbreak;\r\ncase 8:\r\nchip->taos_settings.als_gain = 1;\r\nbreak;\r\ncase 16:\r\nchip->taos_settings.als_gain = 2;\r\nbreak;\r\ncase 111:\r\nchip->taos_settings.als_gain = 3;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid Gain Index (must be 1,8,16,111)\n");\r\nreturn -1;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t taos_gain_available_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", "1 8 16 111");\r\n}\r\nstatic ssize_t taos_als_time_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->taos_settings.als_time);\r\n}\r\nstatic ssize_t taos_als_time_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif ((value < 50) || (value > 650))\r\nreturn -EINVAL;\r\nif (value % 50)\r\nreturn -EINVAL;\r\nchip->taos_settings.als_time = value;\r\nreturn len;\r\n}\r\nstatic ssize_t taos_als_time_available_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n",\r\n"50 100 150 200 250 300 350 400 450 500 550 600 650");\r\n}\r\nstatic ssize_t taos_als_trim_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->taos_settings.als_gain_trim);\r\n}\r\nstatic ssize_t taos_als_trim_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (value)\r\nchip->taos_settings.als_gain_trim = value;\r\nreturn len;\r\n}\r\nstatic ssize_t taos_als_cal_target_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->taos_settings.als_cal_target);\r\n}\r\nstatic ssize_t taos_als_cal_target_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (value)\r\nchip->taos_settings.als_cal_target = value;\r\nreturn len;\r\n}\r\nstatic ssize_t taos_lux_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nret = taos_get_lux(dev_to_iio_dev(dev));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t taos_do_calibrate(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (value == 1)\r\ntaos_als_calibrate(indio_dev);\r\nreturn len;\r\n}\r\nstatic ssize_t taos_luxtable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nint offset = 0;\r\nfor (i = 0; i < ARRAY_SIZE(taos_device_lux); i++) {\r\noffset += sprintf(buf + offset, "%d,%d,%d,",\r\ntaos_device_lux[i].ratio,\r\ntaos_device_lux[i].ch0,\r\ntaos_device_lux[i].ch1);\r\nif (taos_device_lux[i].ratio == 0) {\r\noffset--;\r\nbreak;\r\n}\r\n}\r\noffset += sprintf(buf + offset, "\n");\r\nreturn offset;\r\n}\r\nstatic ssize_t taos_luxtable_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint value[ARRAY_SIZE(taos_device_lux)*3 + 1];\r\nint n;\r\nget_options(buf, ARRAY_SIZE(value), value);\r\nn = value[0];\r\nif ((n % 3) || n < 6 || n > ((ARRAY_SIZE(taos_device_lux) - 1) * 3)) {\r\ndev_info(dev, "LUX TABLE INPUT ERROR 1 Value[0]=%d\n", n);\r\nreturn -EINVAL;\r\n}\r\nif ((value[(n - 2)] | value[(n - 1)] | value[n]) != 0) {\r\ndev_info(dev, "LUX TABLE INPUT ERROR 2 Value[0]=%d\n", n);\r\nreturn -EINVAL;\r\n}\r\nif (chip->taos_chip_status == TSL258X_CHIP_WORKING)\r\ntaos_chip_off(indio_dev);\r\nmemset(taos_device_lux, 0, sizeof(taos_device_lux));\r\nmemcpy(taos_device_lux, &value[1], (value[0] * 4));\r\ntaos_chip_on(indio_dev);\r\nreturn len;\r\n}\r\nstatic int taos_tsl258x_device(unsigned char *bufp)\r\n{\r\nreturn ((bufp[TSL258X_CHIPID] & 0xf0) == 0x90);\r\n}\r\nstatic int taos_probe(struct i2c_client *clientp,\r\nconst struct i2c_device_id *idp)\r\n{\r\nint i, ret;\r\nunsigned char buf[TSL258X_MAX_DEVICE_REGS];\r\nstruct tsl2583_chip *chip;\r\nstruct iio_dev *indio_dev;\r\nif (!i2c_check_functionality(clientp->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&clientp->dev,\r\n"taos_probe() - i2c smbus byte data "\r\n"functions unsupported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nindio_dev = iio_device_alloc(sizeof(*chip));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ndev_err(&clientp->dev, "iio allocation failed\n");\r\ngoto fail1;\r\n}\r\nchip = iio_priv(indio_dev);\r\nchip->client = clientp;\r\ni2c_set_clientdata(clientp, indio_dev);\r\nmutex_init(&chip->als_mutex);\r\nchip->taos_chip_status = TSL258X_CHIP_UNKNOWN;\r\nmemcpy(chip->taos_config, taos_config, sizeof(chip->taos_config));\r\nfor (i = 0; i < TSL258X_MAX_DEVICE_REGS; i++) {\r\nret = i2c_smbus_write_byte(clientp,\r\n(TSL258X_CMD_REG | (TSL258X_CNTRL + i)));\r\nif (ret < 0) {\r\ndev_err(&clientp->dev, "i2c_smbus_write_bytes() to cmd "\r\n"reg failed in taos_probe(), err = %d\n", ret);\r\ngoto fail2;\r\n}\r\nret = i2c_smbus_read_byte(clientp);\r\nif (ret < 0) {\r\ndev_err(&clientp->dev, "i2c_smbus_read_byte from "\r\n"reg failed in taos_probe(), err = %d\n", ret);\r\ngoto fail2;\r\n}\r\nbuf[i] = ret;\r\n}\r\nif (!taos_tsl258x_device(buf)) {\r\ndev_info(&clientp->dev, "i2c device found but does not match "\r\n"expected id in taos_probe()\n");\r\ngoto fail2;\r\n}\r\nret = i2c_smbus_write_byte(clientp, (TSL258X_CMD_REG | TSL258X_CNTRL));\r\nif (ret < 0) {\r\ndev_err(&clientp->dev, "i2c_smbus_write_byte() to cmd reg "\r\n"failed in taos_probe(), err = %d\n", ret);\r\ngoto fail2;\r\n}\r\nindio_dev->info = &tsl2583_info;\r\nindio_dev->dev.parent = &clientp->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = chip->client->name;\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&clientp->dev, "iio registration failed\n");\r\ngoto fail2;\r\n}\r\ntaos_defaults(chip);\r\ntaos_chip_on(indio_dev);\r\ndev_info(&clientp->dev, "Light sensor found.\n");\r\nreturn 0;\r\nfail1:\r\niio_device_free(indio_dev);\r\nfail2:\r\nreturn ret;\r\n}\r\nstatic int taos_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret = 0;\r\nmutex_lock(&chip->als_mutex);\r\nif (chip->taos_chip_status == TSL258X_CHIP_WORKING) {\r\nret = taos_chip_off(indio_dev);\r\nchip->taos_chip_status = TSL258X_CHIP_SUSPENDED;\r\n}\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int taos_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret = 0;\r\nmutex_lock(&chip->als_mutex);\r\nif (chip->taos_chip_status == TSL258X_CHIP_SUSPENDED)\r\nret = taos_chip_on(indio_dev);\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int taos_remove(struct i2c_client *client)\r\n{\r\niio_device_unregister(i2c_get_clientdata(client));\r\niio_device_free(i2c_get_clientdata(client));\r\nreturn 0;\r\n}
