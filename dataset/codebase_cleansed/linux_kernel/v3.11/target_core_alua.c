sense_reason_t\r\ntarget_emulate_report_target_port_groups(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_port *port;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\nunsigned char *buf;\r\nu32 rd_len = 0, off;\r\nint ext_hdr = (cmd->t_task_cdb[1] & 0x20);\r\nif (ext_hdr != 0)\r\noff = 8;\r\nelse\r\noff = 4;\r\nif (cmd->data_length < off) {\r\npr_warn("REPORT TARGET PORT GROUPS allocation length %u too"\r\n" small for %s header\n", cmd->data_length,\r\n(ext_hdr) ? "extended" : "normal");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\nlist_for_each_entry(tg_pt_gp, &dev->t10_alua.tg_pt_gps_list,\r\ntg_pt_gp_list) {\r\nif ((off + 8 + (tg_pt_gp->tg_pt_gp_members * 4)) >\r\ncmd->data_length) {\r\nrd_len += 8 + (tg_pt_gp->tg_pt_gp_members * 4);\r\ncontinue;\r\n}\r\nif (tg_pt_gp->tg_pt_gp_pref)\r\nbuf[off] = 0x80;\r\nbuf[off++] |= (atomic_read(\r\n&tg_pt_gp->tg_pt_gp_alua_access_state) & 0xff);\r\nbuf[off] = 0x80;\r\nbuf[off] |= 0x40;\r\nbuf[off] |= 0x8;\r\nbuf[off] |= 0x4;\r\nbuf[off] |= 0x2;\r\nbuf[off++] |= 0x1;\r\nbuf[off++] = ((tg_pt_gp->tg_pt_gp_id >> 8) & 0xff);\r\nbuf[off++] = (tg_pt_gp->tg_pt_gp_id & 0xff);\r\noff++;\r\nbuf[off++] = (tg_pt_gp->tg_pt_gp_alua_access_status & 0xff);\r\nbuf[off++] = 0x00;\r\nbuf[off++] = (tg_pt_gp->tg_pt_gp_members & 0xff);\r\nrd_len += 8;\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\nlist_for_each_entry(tg_pt_gp_mem, &tg_pt_gp->tg_pt_gp_mem_list,\r\ntg_pt_gp_mem_list) {\r\nport = tg_pt_gp_mem->tg_pt;\r\noff += 2;\r\nbuf[off++] = ((port->sep_rtpi >> 8) & 0xff);\r\nbuf[off++] = (port->sep_rtpi & 0xff);\r\nrd_len += 4;\r\n}\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\n}\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nput_unaligned_be32(rd_len, &buf[0]);\r\nif (ext_hdr != 0) {\r\nbuf[4] = 0x10;\r\nport = cmd->se_lun->lun_sep;\r\ntg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;\r\nif (tg_pt_gp_mem) {\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\ntg_pt_gp = tg_pt_gp_mem->tg_pt_gp;\r\nif (tg_pt_gp)\r\nbuf[5] = tg_pt_gp->tg_pt_gp_implict_trans_secs;\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\n}\r\n}\r\ntransport_kunmap_data_sg(cmd);\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_emulate_set_target_port_groups(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_port *port, *l_port = cmd->se_lun->lun_sep;\r\nstruct se_node_acl *nacl = cmd->se_sess->se_node_acl;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = NULL, *l_tg_pt_gp;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem, *l_tg_pt_gp_mem;\r\nunsigned char *buf;\r\nunsigned char *ptr;\r\nsense_reason_t rc = TCM_NO_SENSE;\r\nu32 len = 4;\r\nint alua_access_state, primary = 0;\r\nu16 tg_pt_id, rtpi;\r\nif (!l_port)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (cmd->data_length < 4) {\r\npr_warn("SET TARGET PORT GROUPS parameter list length %u too"\r\n" small\n", cmd->data_length);\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nl_tg_pt_gp_mem = l_port->sep_alua_tg_pt_gp_mem;\r\nif (!l_tg_pt_gp_mem) {\r\npr_err("Unable to access l_port->sep_alua_tg_pt_gp_mem\n");\r\nrc = TCM_UNSUPPORTED_SCSI_OPCODE;\r\ngoto out;\r\n}\r\nspin_lock(&l_tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nl_tg_pt_gp = l_tg_pt_gp_mem->tg_pt_gp;\r\nif (!l_tg_pt_gp) {\r\nspin_unlock(&l_tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\npr_err("Unable to access *l_tg_pt_gp_mem->tg_pt_gp\n");\r\nrc = TCM_UNSUPPORTED_SCSI_OPCODE;\r\ngoto out;\r\n}\r\nspin_unlock(&l_tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nif (!(l_tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICT_ALUA)) {\r\npr_debug("Unable to process SET_TARGET_PORT_GROUPS"\r\n" while TPGS_EXPLICT_ALUA is disabled\n");\r\nrc = TCM_UNSUPPORTED_SCSI_OPCODE;\r\ngoto out;\r\n}\r\nptr = &buf[4];\r\nwhile (len < cmd->data_length) {\r\nbool found = false;\r\nalua_access_state = (ptr[0] & 0x0f);\r\nrc = core_alua_check_transition(alua_access_state, &primary);\r\nif (rc) {\r\ngoto out;\r\n}\r\nif (primary) {\r\ntg_pt_id = get_unaligned_be16(ptr + 2);\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\nlist_for_each_entry(tg_pt_gp,\r\n&dev->t10_alua.tg_pt_gps_list,\r\ntg_pt_gp_list) {\r\nif (!tg_pt_gp->tg_pt_gp_valid_id)\r\ncontinue;\r\nif (tg_pt_id != tg_pt_gp->tg_pt_gp_id)\r\ncontinue;\r\natomic_inc(&tg_pt_gp->tg_pt_gp_ref_cnt);\r\nsmp_mb__after_atomic_inc();\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nif (!core_alua_do_port_transition(tg_pt_gp,\r\ndev, l_port, nacl,\r\nalua_access_state, 1))\r\nfound = true;\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\natomic_dec(&tg_pt_gp->tg_pt_gp_ref_cnt);\r\nsmp_mb__after_atomic_dec();\r\nbreak;\r\n}\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\n} else {\r\nrtpi = get_unaligned_be16(ptr + 2);\r\nspin_lock(&dev->se_port_lock);\r\nlist_for_each_entry(port, &dev->dev_sep_list,\r\nsep_list) {\r\nif (port->sep_rtpi != rtpi)\r\ncontinue;\r\ntg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;\r\nspin_unlock(&dev->se_port_lock);\r\nif (!core_alua_set_tg_pt_secondary_state(\r\ntg_pt_gp_mem, port, 1, 1))\r\nfound = true;\r\nspin_lock(&dev->se_port_lock);\r\nbreak;\r\n}\r\nspin_unlock(&dev->se_port_lock);\r\n}\r\nif (!found) {\r\nrc = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nptr += 4;\r\nlen += 4;\r\n}\r\nout:\r\ntransport_kunmap_data_sg(cmd);\r\nif (!rc)\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn rc;\r\n}\r\nstatic inline int core_alua_state_nonoptimized(\r\nstruct se_cmd *cmd,\r\nunsigned char *cdb,\r\nint nonop_delay_msecs,\r\nu8 *alua_ascq)\r\n{\r\ncmd->se_cmd_flags |= SCF_ALUA_NON_OPTIMIZED;\r\ncmd->alua_nonop_delay = nonop_delay_msecs;\r\nreturn 0;\r\n}\r\nstatic inline int core_alua_state_standby(\r\nstruct se_cmd *cmd,\r\nunsigned char *cdb,\r\nu8 *alua_ascq)\r\n{\r\nswitch (cdb[0]) {\r\ncase INQUIRY:\r\ncase LOG_SELECT:\r\ncase LOG_SENSE:\r\ncase MODE_SELECT:\r\ncase MODE_SENSE:\r\ncase REPORT_LUNS:\r\ncase RECEIVE_DIAGNOSTIC:\r\ncase SEND_DIAGNOSTIC:\r\nreturn 0;\r\ncase MAINTENANCE_IN:\r\nswitch (cdb[1] & 0x1f) {\r\ncase MI_REPORT_TARGET_PGS:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_TG_PT_STANDBY;\r\nreturn 1;\r\n}\r\ncase MAINTENANCE_OUT:\r\nswitch (cdb[1]) {\r\ncase MO_SET_TARGET_PGS:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_TG_PT_STANDBY;\r\nreturn 1;\r\n}\r\ncase REQUEST_SENSE:\r\ncase PERSISTENT_RESERVE_IN:\r\ncase PERSISTENT_RESERVE_OUT:\r\ncase READ_BUFFER:\r\ncase WRITE_BUFFER:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_TG_PT_STANDBY;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int core_alua_state_unavailable(\r\nstruct se_cmd *cmd,\r\nunsigned char *cdb,\r\nu8 *alua_ascq)\r\n{\r\nswitch (cdb[0]) {\r\ncase INQUIRY:\r\ncase REPORT_LUNS:\r\nreturn 0;\r\ncase MAINTENANCE_IN:\r\nswitch (cdb[1] & 0x1f) {\r\ncase MI_REPORT_TARGET_PGS:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_TG_PT_UNAVAILABLE;\r\nreturn 1;\r\n}\r\ncase MAINTENANCE_OUT:\r\nswitch (cdb[1]) {\r\ncase MO_SET_TARGET_PGS:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_TG_PT_UNAVAILABLE;\r\nreturn 1;\r\n}\r\ncase REQUEST_SENSE:\r\ncase READ_BUFFER:\r\ncase WRITE_BUFFER:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_TG_PT_UNAVAILABLE;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int core_alua_state_transition(\r\nstruct se_cmd *cmd,\r\nunsigned char *cdb,\r\nu8 *alua_ascq)\r\n{\r\nswitch (cdb[0]) {\r\ncase INQUIRY:\r\ncase REPORT_LUNS:\r\nreturn 0;\r\ncase MAINTENANCE_IN:\r\nswitch (cdb[1] & 0x1f) {\r\ncase MI_REPORT_TARGET_PGS:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_STATE_TRANSITION;\r\nreturn 1;\r\n}\r\ncase REQUEST_SENSE:\r\ncase READ_BUFFER:\r\ncase WRITE_BUFFER:\r\nreturn 0;\r\ndefault:\r\n*alua_ascq = ASCQ_04H_ALUA_STATE_TRANSITION;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_alua_state_check(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nstruct se_lun *lun = cmd->se_lun;\r\nstruct se_port *port = lun->lun_sep;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\nint out_alua_state, nonop_delay_msecs;\r\nu8 alua_ascq;\r\nint ret;\r\nif (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)\r\nreturn 0;\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV)\r\nreturn 0;\r\nif (!port)\r\nreturn 0;\r\nif (atomic_read(&port->sep_tg_pt_secondary_offline)) {\r\npr_debug("ALUA: Got secondary offline status for local"\r\n" target port\n");\r\nalua_ascq = ASCQ_04H_ALUA_OFFLINE;\r\nret = 1;\r\ngoto out;\r\n}\r\ntg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\ntg_pt_gp = tg_pt_gp_mem->tg_pt_gp;\r\nout_alua_state = atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state);\r\nnonop_delay_msecs = tg_pt_gp->tg_pt_gp_nonop_delay_msecs;\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nif (out_alua_state == ALUA_ACCESS_STATE_ACTIVE_OPTMIZED)\r\nreturn 0;\r\nswitch (out_alua_state) {\r\ncase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\r\nret = core_alua_state_nonoptimized(cmd, cdb,\r\nnonop_delay_msecs, &alua_ascq);\r\nbreak;\r\ncase ALUA_ACCESS_STATE_STANDBY:\r\nret = core_alua_state_standby(cmd, cdb, &alua_ascq);\r\nbreak;\r\ncase ALUA_ACCESS_STATE_UNAVAILABLE:\r\nret = core_alua_state_unavailable(cmd, cdb, &alua_ascq);\r\nbreak;\r\ncase ALUA_ACCESS_STATE_TRANSITION:\r\nret = core_alua_state_transition(cmd, cdb, &alua_ascq);\r\nbreak;\r\ncase ALUA_ACCESS_STATE_OFFLINE:\r\ndefault:\r\npr_err("Unknown ALUA access state: 0x%02x\n",\r\nout_alua_state);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nout:\r\nif (ret > 0) {\r\npr_debug("[%s]: ALUA TG Port not available, "\r\n"SenseKey: NOT_READY, ASC/ASCQ: "\r\n"0x04/0x%02x\n",\r\ncmd->se_tfo->get_fabric_name(), alua_ascq);\r\ncmd->scsi_asc = 0x04;\r\ncmd->scsi_ascq = alua_ascq;\r\nreturn TCM_CHECK_CONDITION_NOT_READY;\r\n}\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\ncore_alua_check_transition(int state, int *primary)\r\n{\r\nswitch (state) {\r\ncase ALUA_ACCESS_STATE_ACTIVE_OPTMIZED:\r\ncase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\r\ncase ALUA_ACCESS_STATE_STANDBY:\r\ncase ALUA_ACCESS_STATE_UNAVAILABLE:\r\n*primary = 1;\r\nbreak;\r\ncase ALUA_ACCESS_STATE_OFFLINE:\r\n*primary = 0;\r\nbreak;\r\ndefault:\r\npr_err("Unknown ALUA access state: 0x%02x\n", state);\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *core_alua_dump_state(int state)\r\n{\r\nswitch (state) {\r\ncase ALUA_ACCESS_STATE_ACTIVE_OPTMIZED:\r\nreturn "Active/Optimized";\r\ncase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\r\nreturn "Active/NonOptimized";\r\ncase ALUA_ACCESS_STATE_STANDBY:\r\nreturn "Standby";\r\ncase ALUA_ACCESS_STATE_UNAVAILABLE:\r\nreturn "Unavailable";\r\ncase ALUA_ACCESS_STATE_OFFLINE:\r\nreturn "Offline";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\nreturn NULL;\r\n}\r\nchar *core_alua_dump_status(int status)\r\n{\r\nswitch (status) {\r\ncase ALUA_STATUS_NONE:\r\nreturn "None";\r\ncase ALUA_STATUS_ALTERED_BY_EXPLICT_STPG:\r\nreturn "Altered by Explict STPG";\r\ncase ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA:\r\nreturn "Altered by Implict ALUA";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\nreturn NULL;\r\n}\r\nint core_alua_check_nonop_delay(\r\nstruct se_cmd *cmd)\r\n{\r\nif (!(cmd->se_cmd_flags & SCF_ALUA_NON_OPTIMIZED))\r\nreturn 0;\r\nif (in_interrupt())\r\nreturn 0;\r\nif (!cmd->alua_nonop_delay)\r\nreturn 0;\r\nmsleep_interruptible(cmd->alua_nonop_delay);\r\nreturn 0;\r\n}\r\nstatic int core_alua_write_tpg_metadata(\r\nconst char *path,\r\nunsigned char *md_buf,\r\nu32 md_buf_len)\r\n{\r\nstruct file *file = filp_open(path, O_RDWR | O_CREAT | O_TRUNC, 0600);\r\nint ret;\r\nif (IS_ERR(file)) {\r\npr_err("filp_open(%s) for ALUA metadata failed\n", path);\r\nreturn -ENODEV;\r\n}\r\nret = kernel_write(file, md_buf, md_buf_len, 0);\r\nif (ret < 0)\r\npr_err("Error writing ALUA metadata file: %s\n", path);\r\nfput(file);\r\nreturn ret ? -EIO : 0;\r\n}\r\nstatic int core_alua_update_tpg_primary_metadata(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nint primary_state,\r\nunsigned char *md_buf)\r\n{\r\nstruct t10_wwn *wwn = &tg_pt_gp->tg_pt_gp_dev->t10_wwn;\r\nchar path[ALUA_METADATA_PATH_LEN];\r\nint len;\r\nmemset(path, 0, ALUA_METADATA_PATH_LEN);\r\nlen = snprintf(md_buf, tg_pt_gp->tg_pt_gp_md_buf_len,\r\n"tg_pt_gp_id=%hu\n"\r\n"alua_access_state=0x%02x\n"\r\n"alua_access_status=0x%02x\n",\r\ntg_pt_gp->tg_pt_gp_id, primary_state,\r\ntg_pt_gp->tg_pt_gp_alua_access_status);\r\nsnprintf(path, ALUA_METADATA_PATH_LEN,\r\n"/var/target/alua/tpgs_%s/%s", &wwn->unit_serial[0],\r\nconfig_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item));\r\nreturn core_alua_write_tpg_metadata(path, md_buf, len);\r\n}\r\nstatic int core_alua_do_transition_tg_pt(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nstruct se_port *l_port,\r\nstruct se_node_acl *nacl,\r\nunsigned char *md_buf,\r\nint new_state,\r\nint explict)\r\n{\r\nstruct se_dev_entry *se_deve;\r\nstruct se_lun_acl *lacl;\r\nstruct se_port *port;\r\nstruct t10_alua_tg_pt_gp_member *mem;\r\nint old_state = 0;\r\nold_state = atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state);\r\natomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state,\r\nALUA_ACCESS_STATE_TRANSITION);\r\ntg_pt_gp->tg_pt_gp_alua_access_status = (explict) ?\r\nALUA_STATUS_ALTERED_BY_EXPLICT_STPG :\r\nALUA_STATUS_ALTERED_BY_IMPLICT_ALUA;\r\nif (tg_pt_gp->tg_pt_gp_trans_delay_msecs != 0)\r\nmsleep_interruptible(tg_pt_gp->tg_pt_gp_trans_delay_msecs);\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\nlist_for_each_entry(mem, &tg_pt_gp->tg_pt_gp_mem_list,\r\ntg_pt_gp_mem_list) {\r\nport = mem->tg_pt;\r\natomic_inc(&mem->tg_pt_gp_mem_ref_cnt);\r\nsmp_mb__after_atomic_inc();\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\nspin_lock_bh(&port->sep_alua_lock);\r\nlist_for_each_entry(se_deve, &port->sep_alua_list,\r\nalua_port_list) {\r\nlacl = se_deve->se_lun_acl;\r\nif (!lacl)\r\ncontinue;\r\nif (explict &&\r\n(nacl != NULL) && (nacl == lacl->se_lun_nacl) &&\r\n(l_port != NULL) && (l_port == port))\r\ncontinue;\r\ncore_scsi3_ua_allocate(lacl->se_lun_nacl,\r\nse_deve->mapped_lun, 0x2A,\r\nASCQ_2AH_ASYMMETRIC_ACCESS_STATE_CHANGED);\r\n}\r\nspin_unlock_bh(&port->sep_alua_lock);\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\natomic_dec(&mem->tg_pt_gp_mem_ref_cnt);\r\nsmp_mb__after_atomic_dec();\r\n}\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\nif (tg_pt_gp->tg_pt_gp_write_metadata) {\r\nmutex_lock(&tg_pt_gp->tg_pt_gp_md_mutex);\r\ncore_alua_update_tpg_primary_metadata(tg_pt_gp,\r\nnew_state, md_buf);\r\nmutex_unlock(&tg_pt_gp->tg_pt_gp_md_mutex);\r\n}\r\natomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state, new_state);\r\npr_debug("Successful %s ALUA transition TG PT Group: %s ID: %hu"\r\n" from primary access state %s to %s\n", (explict) ? "explict" :\r\n"implict", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),\r\ntg_pt_gp->tg_pt_gp_id, core_alua_dump_state(old_state),\r\ncore_alua_dump_state(new_state));\r\nreturn 0;\r\n}\r\nint core_alua_do_port_transition(\r\nstruct t10_alua_tg_pt_gp *l_tg_pt_gp,\r\nstruct se_device *l_dev,\r\nstruct se_port *l_port,\r\nstruct se_node_acl *l_nacl,\r\nint new_state,\r\nint explict)\r\n{\r\nstruct se_device *dev;\r\nstruct se_port *port;\r\nstruct se_node_acl *nacl;\r\nstruct t10_alua_lu_gp *lu_gp;\r\nstruct t10_alua_lu_gp_member *lu_gp_mem, *local_lu_gp_mem;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nunsigned char *md_buf;\r\nint primary;\r\nif (core_alua_check_transition(new_state, &primary) != 0)\r\nreturn -EINVAL;\r\nmd_buf = kzalloc(l_tg_pt_gp->tg_pt_gp_md_buf_len, GFP_KERNEL);\r\nif (!md_buf) {\r\npr_err("Unable to allocate buf for ALUA metadata\n");\r\nreturn -ENOMEM;\r\n}\r\nlocal_lu_gp_mem = l_dev->dev_alua_lu_gp_mem;\r\nspin_lock(&local_lu_gp_mem->lu_gp_mem_lock);\r\nlu_gp = local_lu_gp_mem->lu_gp;\r\natomic_inc(&lu_gp->lu_gp_ref_cnt);\r\nsmp_mb__after_atomic_inc();\r\nspin_unlock(&local_lu_gp_mem->lu_gp_mem_lock);\r\nif (!lu_gp->lu_gp_id) {\r\ncore_alua_do_transition_tg_pt(l_tg_pt_gp, l_port, l_nacl,\r\nmd_buf, new_state, explict);\r\natomic_dec(&lu_gp->lu_gp_ref_cnt);\r\nsmp_mb__after_atomic_dec();\r\nkfree(md_buf);\r\nreturn 0;\r\n}\r\nspin_lock(&lu_gp->lu_gp_lock);\r\nlist_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list,\r\nlu_gp_mem_list) {\r\ndev = lu_gp_mem->lu_gp_mem_dev;\r\natomic_inc(&lu_gp_mem->lu_gp_mem_ref_cnt);\r\nsmp_mb__after_atomic_inc();\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\nlist_for_each_entry(tg_pt_gp,\r\n&dev->t10_alua.tg_pt_gps_list,\r\ntg_pt_gp_list) {\r\nif (!tg_pt_gp->tg_pt_gp_valid_id)\r\ncontinue;\r\nif (l_tg_pt_gp->tg_pt_gp_id != tg_pt_gp->tg_pt_gp_id)\r\ncontinue;\r\nif (l_tg_pt_gp == tg_pt_gp) {\r\nport = l_port;\r\nnacl = l_nacl;\r\n} else {\r\nport = NULL;\r\nnacl = NULL;\r\n}\r\natomic_inc(&tg_pt_gp->tg_pt_gp_ref_cnt);\r\nsmp_mb__after_atomic_inc();\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\ncore_alua_do_transition_tg_pt(tg_pt_gp, port,\r\nnacl, md_buf, new_state, explict);\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\natomic_dec(&tg_pt_gp->tg_pt_gp_ref_cnt);\r\nsmp_mb__after_atomic_dec();\r\n}\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nspin_lock(&lu_gp->lu_gp_lock);\r\natomic_dec(&lu_gp_mem->lu_gp_mem_ref_cnt);\r\nsmp_mb__after_atomic_dec();\r\n}\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\npr_debug("Successfully processed LU Group: %s all ALUA TG PT"\r\n" Group IDs: %hu %s transition to primary state: %s\n",\r\nconfig_item_name(&lu_gp->lu_gp_group.cg_item),\r\nl_tg_pt_gp->tg_pt_gp_id, (explict) ? "explict" : "implict",\r\ncore_alua_dump_state(new_state));\r\natomic_dec(&lu_gp->lu_gp_ref_cnt);\r\nsmp_mb__after_atomic_dec();\r\nkfree(md_buf);\r\nreturn 0;\r\n}\r\nstatic int core_alua_update_tpg_secondary_metadata(\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,\r\nstruct se_port *port,\r\nunsigned char *md_buf,\r\nu32 md_buf_len)\r\n{\r\nstruct se_portal_group *se_tpg = port->sep_tpg;\r\nchar path[ALUA_METADATA_PATH_LEN], wwn[ALUA_SECONDARY_METADATA_WWN_LEN];\r\nint len;\r\nmemset(path, 0, ALUA_METADATA_PATH_LEN);\r\nmemset(wwn, 0, ALUA_SECONDARY_METADATA_WWN_LEN);\r\nlen = snprintf(wwn, ALUA_SECONDARY_METADATA_WWN_LEN, "%s",\r\nse_tpg->se_tpg_tfo->tpg_get_wwn(se_tpg));\r\nif (se_tpg->se_tpg_tfo->tpg_get_tag != NULL)\r\nsnprintf(wwn+len, ALUA_SECONDARY_METADATA_WWN_LEN-len, "+%hu",\r\nse_tpg->se_tpg_tfo->tpg_get_tag(se_tpg));\r\nlen = snprintf(md_buf, md_buf_len, "alua_tg_pt_offline=%d\n"\r\n"alua_tg_pt_status=0x%02x\n",\r\natomic_read(&port->sep_tg_pt_secondary_offline),\r\nport->sep_tg_pt_secondary_stat);\r\nsnprintf(path, ALUA_METADATA_PATH_LEN, "/var/target/alua/%s/%s/lun_%u",\r\nse_tpg->se_tpg_tfo->get_fabric_name(), wwn,\r\nport->sep_lun->unpacked_lun);\r\nreturn core_alua_write_tpg_metadata(path, md_buf, len);\r\n}\r\nstatic int core_alua_set_tg_pt_secondary_state(\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,\r\nstruct se_port *port,\r\nint explict,\r\nint offline)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nunsigned char *md_buf;\r\nu32 md_buf_len;\r\nint trans_delay_msecs;\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\ntg_pt_gp = tg_pt_gp_mem->tg_pt_gp;\r\nif (!tg_pt_gp) {\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\npr_err("Unable to complete secondary state"\r\n" transition\n");\r\nreturn -EINVAL;\r\n}\r\ntrans_delay_msecs = tg_pt_gp->tg_pt_gp_trans_delay_msecs;\r\nif (offline)\r\natomic_set(&port->sep_tg_pt_secondary_offline, 1);\r\nelse\r\natomic_set(&port->sep_tg_pt_secondary_offline, 0);\r\nmd_buf_len = tg_pt_gp->tg_pt_gp_md_buf_len;\r\nport->sep_tg_pt_secondary_stat = (explict) ?\r\nALUA_STATUS_ALTERED_BY_EXPLICT_STPG :\r\nALUA_STATUS_ALTERED_BY_IMPLICT_ALUA;\r\npr_debug("Successful %s ALUA transition TG PT Group: %s ID: %hu"\r\n" to secondary access state: %s\n", (explict) ? "explict" :\r\n"implict", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),\r\ntg_pt_gp->tg_pt_gp_id, (offline) ? "OFFLINE" : "ONLINE");\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nif (trans_delay_msecs != 0)\r\nmsleep_interruptible(trans_delay_msecs);\r\nif (port->sep_tg_pt_secondary_write_md) {\r\nmd_buf = kzalloc(md_buf_len, GFP_KERNEL);\r\nif (!md_buf) {\r\npr_err("Unable to allocate md_buf for"\r\n" secondary ALUA access metadata\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&port->sep_tg_pt_md_mutex);\r\ncore_alua_update_tpg_secondary_metadata(tg_pt_gp_mem, port,\r\nmd_buf, md_buf_len);\r\nmutex_unlock(&port->sep_tg_pt_md_mutex);\r\nkfree(md_buf);\r\n}\r\nreturn 0;\r\n}\r\nstruct t10_alua_lu_gp *\r\ncore_alua_allocate_lu_gp(const char *name, int def_group)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp;\r\nlu_gp = kmem_cache_zalloc(t10_alua_lu_gp_cache, GFP_KERNEL);\r\nif (!lu_gp) {\r\npr_err("Unable to allocate struct t10_alua_lu_gp\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&lu_gp->lu_gp_node);\r\nINIT_LIST_HEAD(&lu_gp->lu_gp_mem_list);\r\nspin_lock_init(&lu_gp->lu_gp_lock);\r\natomic_set(&lu_gp->lu_gp_ref_cnt, 0);\r\nif (def_group) {\r\nlu_gp->lu_gp_id = alua_lu_gps_counter++;\r\nlu_gp->lu_gp_valid_id = 1;\r\nalua_lu_gps_count++;\r\n}\r\nreturn lu_gp;\r\n}\r\nint core_alua_set_lu_gp_id(struct t10_alua_lu_gp *lu_gp, u16 lu_gp_id)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp_tmp;\r\nu16 lu_gp_id_tmp;\r\nif (lu_gp->lu_gp_valid_id) {\r\npr_warn("ALUA LU Group already has a valid ID,"\r\n" ignoring request\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&lu_gps_lock);\r\nif (alua_lu_gps_count == 0x0000ffff) {\r\npr_err("Maximum ALUA alua_lu_gps_count:"\r\n" 0x0000ffff reached\n");\r\nspin_unlock(&lu_gps_lock);\r\nkmem_cache_free(t10_alua_lu_gp_cache, lu_gp);\r\nreturn -ENOSPC;\r\n}\r\nagain:\r\nlu_gp_id_tmp = (lu_gp_id != 0) ? lu_gp_id :\r\nalua_lu_gps_counter++;\r\nlist_for_each_entry(lu_gp_tmp, &lu_gps_list, lu_gp_node) {\r\nif (lu_gp_tmp->lu_gp_id == lu_gp_id_tmp) {\r\nif (!lu_gp_id)\r\ngoto again;\r\npr_warn("ALUA Logical Unit Group ID: %hu"\r\n" already exists, ignoring request\n",\r\nlu_gp_id);\r\nspin_unlock(&lu_gps_lock);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlu_gp->lu_gp_id = lu_gp_id_tmp;\r\nlu_gp->lu_gp_valid_id = 1;\r\nlist_add_tail(&lu_gp->lu_gp_node, &lu_gps_list);\r\nalua_lu_gps_count++;\r\nspin_unlock(&lu_gps_lock);\r\nreturn 0;\r\n}\r\nstatic struct t10_alua_lu_gp_member *\r\ncore_alua_allocate_lu_gp_mem(struct se_device *dev)\r\n{\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nlu_gp_mem = kmem_cache_zalloc(t10_alua_lu_gp_mem_cache, GFP_KERNEL);\r\nif (!lu_gp_mem) {\r\npr_err("Unable to allocate struct t10_alua_lu_gp_member\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&lu_gp_mem->lu_gp_mem_list);\r\nspin_lock_init(&lu_gp_mem->lu_gp_mem_lock);\r\natomic_set(&lu_gp_mem->lu_gp_mem_ref_cnt, 0);\r\nlu_gp_mem->lu_gp_mem_dev = dev;\r\ndev->dev_alua_lu_gp_mem = lu_gp_mem;\r\nreturn lu_gp_mem;\r\n}\r\nvoid core_alua_free_lu_gp(struct t10_alua_lu_gp *lu_gp)\r\n{\r\nstruct t10_alua_lu_gp_member *lu_gp_mem, *lu_gp_mem_tmp;\r\nspin_lock(&lu_gps_lock);\r\nlist_del(&lu_gp->lu_gp_node);\r\nalua_lu_gps_count--;\r\nspin_unlock(&lu_gps_lock);\r\nwhile (atomic_read(&lu_gp->lu_gp_ref_cnt))\r\ncpu_relax();\r\nspin_lock(&lu_gp->lu_gp_lock);\r\nlist_for_each_entry_safe(lu_gp_mem, lu_gp_mem_tmp,\r\n&lu_gp->lu_gp_mem_list, lu_gp_mem_list) {\r\nif (lu_gp_mem->lu_gp_assoc) {\r\nlist_del(&lu_gp_mem->lu_gp_mem_list);\r\nlu_gp->lu_gp_members--;\r\nlu_gp_mem->lu_gp_assoc = 0;\r\n}\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\nspin_lock(&lu_gp_mem->lu_gp_mem_lock);\r\nif (lu_gp != default_lu_gp)\r\n__core_alua_attach_lu_gp_mem(lu_gp_mem,\r\ndefault_lu_gp);\r\nelse\r\nlu_gp_mem->lu_gp = NULL;\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\nspin_lock(&lu_gp->lu_gp_lock);\r\n}\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\nkmem_cache_free(t10_alua_lu_gp_cache, lu_gp);\r\n}\r\nvoid core_alua_free_lu_gp_mem(struct se_device *dev)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp;\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nlu_gp_mem = dev->dev_alua_lu_gp_mem;\r\nif (!lu_gp_mem)\r\nreturn;\r\nwhile (atomic_read(&lu_gp_mem->lu_gp_mem_ref_cnt))\r\ncpu_relax();\r\nspin_lock(&lu_gp_mem->lu_gp_mem_lock);\r\nlu_gp = lu_gp_mem->lu_gp;\r\nif (lu_gp) {\r\nspin_lock(&lu_gp->lu_gp_lock);\r\nif (lu_gp_mem->lu_gp_assoc) {\r\nlist_del(&lu_gp_mem->lu_gp_mem_list);\r\nlu_gp->lu_gp_members--;\r\nlu_gp_mem->lu_gp_assoc = 0;\r\n}\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\nlu_gp_mem->lu_gp = NULL;\r\n}\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\nkmem_cache_free(t10_alua_lu_gp_mem_cache, lu_gp_mem);\r\n}\r\nstruct t10_alua_lu_gp *core_alua_get_lu_gp_by_name(const char *name)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp;\r\nstruct config_item *ci;\r\nspin_lock(&lu_gps_lock);\r\nlist_for_each_entry(lu_gp, &lu_gps_list, lu_gp_node) {\r\nif (!lu_gp->lu_gp_valid_id)\r\ncontinue;\r\nci = &lu_gp->lu_gp_group.cg_item;\r\nif (!strcmp(config_item_name(ci), name)) {\r\natomic_inc(&lu_gp->lu_gp_ref_cnt);\r\nspin_unlock(&lu_gps_lock);\r\nreturn lu_gp;\r\n}\r\n}\r\nspin_unlock(&lu_gps_lock);\r\nreturn NULL;\r\n}\r\nvoid core_alua_put_lu_gp_from_name(struct t10_alua_lu_gp *lu_gp)\r\n{\r\nspin_lock(&lu_gps_lock);\r\natomic_dec(&lu_gp->lu_gp_ref_cnt);\r\nspin_unlock(&lu_gps_lock);\r\n}\r\nvoid __core_alua_attach_lu_gp_mem(\r\nstruct t10_alua_lu_gp_member *lu_gp_mem,\r\nstruct t10_alua_lu_gp *lu_gp)\r\n{\r\nspin_lock(&lu_gp->lu_gp_lock);\r\nlu_gp_mem->lu_gp = lu_gp;\r\nlu_gp_mem->lu_gp_assoc = 1;\r\nlist_add_tail(&lu_gp_mem->lu_gp_mem_list, &lu_gp->lu_gp_mem_list);\r\nlu_gp->lu_gp_members++;\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\n}\r\nvoid __core_alua_drop_lu_gp_mem(\r\nstruct t10_alua_lu_gp_member *lu_gp_mem,\r\nstruct t10_alua_lu_gp *lu_gp)\r\n{\r\nspin_lock(&lu_gp->lu_gp_lock);\r\nlist_del(&lu_gp_mem->lu_gp_mem_list);\r\nlu_gp_mem->lu_gp = NULL;\r\nlu_gp_mem->lu_gp_assoc = 0;\r\nlu_gp->lu_gp_members--;\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\n}\r\nstruct t10_alua_tg_pt_gp *core_alua_allocate_tg_pt_gp(struct se_device *dev,\r\nconst char *name, int def_group)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\ntg_pt_gp = kmem_cache_zalloc(t10_alua_tg_pt_gp_cache, GFP_KERNEL);\r\nif (!tg_pt_gp) {\r\npr_err("Unable to allocate struct t10_alua_tg_pt_gp\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&tg_pt_gp->tg_pt_gp_list);\r\nINIT_LIST_HEAD(&tg_pt_gp->tg_pt_gp_mem_list);\r\nmutex_init(&tg_pt_gp->tg_pt_gp_md_mutex);\r\nspin_lock_init(&tg_pt_gp->tg_pt_gp_lock);\r\natomic_set(&tg_pt_gp->tg_pt_gp_ref_cnt, 0);\r\ntg_pt_gp->tg_pt_gp_dev = dev;\r\ntg_pt_gp->tg_pt_gp_md_buf_len = ALUA_MD_BUF_LEN;\r\natomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state,\r\nALUA_ACCESS_STATE_ACTIVE_OPTMIZED);\r\ntg_pt_gp->tg_pt_gp_alua_access_type =\r\nTPGS_EXPLICT_ALUA | TPGS_IMPLICT_ALUA;\r\ntg_pt_gp->tg_pt_gp_nonop_delay_msecs = ALUA_DEFAULT_NONOP_DELAY_MSECS;\r\ntg_pt_gp->tg_pt_gp_trans_delay_msecs = ALUA_DEFAULT_TRANS_DELAY_MSECS;\r\ntg_pt_gp->tg_pt_gp_implict_trans_secs = ALUA_DEFAULT_IMPLICT_TRANS_SECS;\r\nif (def_group) {\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\ntg_pt_gp->tg_pt_gp_id =\r\ndev->t10_alua.alua_tg_pt_gps_counter++;\r\ntg_pt_gp->tg_pt_gp_valid_id = 1;\r\ndev->t10_alua.alua_tg_pt_gps_count++;\r\nlist_add_tail(&tg_pt_gp->tg_pt_gp_list,\r\n&dev->t10_alua.tg_pt_gps_list);\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\n}\r\nreturn tg_pt_gp;\r\n}\r\nint core_alua_set_tg_pt_gp_id(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nu16 tg_pt_gp_id)\r\n{\r\nstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp_tmp;\r\nu16 tg_pt_gp_id_tmp;\r\nif (tg_pt_gp->tg_pt_gp_valid_id) {\r\npr_warn("ALUA TG PT Group already has a valid ID,"\r\n" ignoring request\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\nif (dev->t10_alua.alua_tg_pt_gps_count == 0x0000ffff) {\r\npr_err("Maximum ALUA alua_tg_pt_gps_count:"\r\n" 0x0000ffff reached\n");\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nkmem_cache_free(t10_alua_tg_pt_gp_cache, tg_pt_gp);\r\nreturn -ENOSPC;\r\n}\r\nagain:\r\ntg_pt_gp_id_tmp = (tg_pt_gp_id != 0) ? tg_pt_gp_id :\r\ndev->t10_alua.alua_tg_pt_gps_counter++;\r\nlist_for_each_entry(tg_pt_gp_tmp, &dev->t10_alua.tg_pt_gps_list,\r\ntg_pt_gp_list) {\r\nif (tg_pt_gp_tmp->tg_pt_gp_id == tg_pt_gp_id_tmp) {\r\nif (!tg_pt_gp_id)\r\ngoto again;\r\npr_err("ALUA Target Port Group ID: %hu already"\r\n" exists, ignoring request\n", tg_pt_gp_id);\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntg_pt_gp->tg_pt_gp_id = tg_pt_gp_id_tmp;\r\ntg_pt_gp->tg_pt_gp_valid_id = 1;\r\nlist_add_tail(&tg_pt_gp->tg_pt_gp_list,\r\n&dev->t10_alua.tg_pt_gps_list);\r\ndev->t10_alua.alua_tg_pt_gps_count++;\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nreturn 0;\r\n}\r\nstruct t10_alua_tg_pt_gp_member *core_alua_allocate_tg_pt_gp_mem(\r\nstruct se_port *port)\r\n{\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\ntg_pt_gp_mem = kmem_cache_zalloc(t10_alua_tg_pt_gp_mem_cache,\r\nGFP_KERNEL);\r\nif (!tg_pt_gp_mem) {\r\npr_err("Unable to allocate struct t10_alua_tg_pt_gp_member\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&tg_pt_gp_mem->tg_pt_gp_mem_list);\r\nspin_lock_init(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\natomic_set(&tg_pt_gp_mem->tg_pt_gp_mem_ref_cnt, 0);\r\ntg_pt_gp_mem->tg_pt = port;\r\nport->sep_alua_tg_pt_gp_mem = tg_pt_gp_mem;\r\nreturn tg_pt_gp_mem;\r\n}\r\nvoid core_alua_free_tg_pt_gp(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp)\r\n{\r\nstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem, *tg_pt_gp_mem_tmp;\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\nlist_del(&tg_pt_gp->tg_pt_gp_list);\r\ndev->t10_alua.alua_tg_pt_gps_counter--;\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nwhile (atomic_read(&tg_pt_gp->tg_pt_gp_ref_cnt))\r\ncpu_relax();\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\nlist_for_each_entry_safe(tg_pt_gp_mem, tg_pt_gp_mem_tmp,\r\n&tg_pt_gp->tg_pt_gp_mem_list, tg_pt_gp_mem_list) {\r\nif (tg_pt_gp_mem->tg_pt_gp_assoc) {\r\nlist_del(&tg_pt_gp_mem->tg_pt_gp_mem_list);\r\ntg_pt_gp->tg_pt_gp_members--;\r\ntg_pt_gp_mem->tg_pt_gp_assoc = 0;\r\n}\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nif (tg_pt_gp != dev->t10_alua.default_tg_pt_gp) {\r\n__core_alua_attach_tg_pt_gp_mem(tg_pt_gp_mem,\r\ndev->t10_alua.default_tg_pt_gp);\r\n} else\r\ntg_pt_gp_mem->tg_pt_gp = NULL;\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\n}\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\nkmem_cache_free(t10_alua_tg_pt_gp_cache, tg_pt_gp);\r\n}\r\nvoid core_alua_free_tg_pt_gp_mem(struct se_port *port)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\ntg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;\r\nif (!tg_pt_gp_mem)\r\nreturn;\r\nwhile (atomic_read(&tg_pt_gp_mem->tg_pt_gp_mem_ref_cnt))\r\ncpu_relax();\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\ntg_pt_gp = tg_pt_gp_mem->tg_pt_gp;\r\nif (tg_pt_gp) {\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\nif (tg_pt_gp_mem->tg_pt_gp_assoc) {\r\nlist_del(&tg_pt_gp_mem->tg_pt_gp_mem_list);\r\ntg_pt_gp->tg_pt_gp_members--;\r\ntg_pt_gp_mem->tg_pt_gp_assoc = 0;\r\n}\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\ntg_pt_gp_mem->tg_pt_gp = NULL;\r\n}\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nkmem_cache_free(t10_alua_tg_pt_gp_mem_cache, tg_pt_gp_mem);\r\n}\r\nstatic struct t10_alua_tg_pt_gp *core_alua_get_tg_pt_gp_by_name(\r\nstruct se_device *dev, const char *name)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct config_item *ci;\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\nlist_for_each_entry(tg_pt_gp, &dev->t10_alua.tg_pt_gps_list,\r\ntg_pt_gp_list) {\r\nif (!tg_pt_gp->tg_pt_gp_valid_id)\r\ncontinue;\r\nci = &tg_pt_gp->tg_pt_gp_group.cg_item;\r\nif (!strcmp(config_item_name(ci), name)) {\r\natomic_inc(&tg_pt_gp->tg_pt_gp_ref_cnt);\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nreturn tg_pt_gp;\r\n}\r\n}\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\nreturn NULL;\r\n}\r\nstatic void core_alua_put_tg_pt_gp_from_name(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp)\r\n{\r\nstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\r\nspin_lock(&dev->t10_alua.tg_pt_gps_lock);\r\natomic_dec(&tg_pt_gp->tg_pt_gp_ref_cnt);\r\nspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\r\n}\r\nvoid __core_alua_attach_tg_pt_gp_mem(\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp)\r\n{\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\ntg_pt_gp_mem->tg_pt_gp = tg_pt_gp;\r\ntg_pt_gp_mem->tg_pt_gp_assoc = 1;\r\nlist_add_tail(&tg_pt_gp_mem->tg_pt_gp_mem_list,\r\n&tg_pt_gp->tg_pt_gp_mem_list);\r\ntg_pt_gp->tg_pt_gp_members++;\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\n}\r\nstatic void __core_alua_drop_tg_pt_gp_mem(\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp)\r\n{\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\nlist_del(&tg_pt_gp_mem->tg_pt_gp_mem_list);\r\ntg_pt_gp_mem->tg_pt_gp = NULL;\r\ntg_pt_gp_mem->tg_pt_gp_assoc = 0;\r\ntg_pt_gp->tg_pt_gp_members--;\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\n}\r\nssize_t core_alua_show_tg_pt_gp_info(struct se_port *port, char *page)\r\n{\r\nstruct config_item *tg_pt_ci;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\nssize_t len = 0;\r\ntg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;\r\nif (!tg_pt_gp_mem)\r\nreturn len;\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\ntg_pt_gp = tg_pt_gp_mem->tg_pt_gp;\r\nif (tg_pt_gp) {\r\ntg_pt_ci = &tg_pt_gp->tg_pt_gp_group.cg_item;\r\nlen += sprintf(page, "TG Port Alias: %s\nTG Port Group ID:"\r\n" %hu\nTG Port Primary Access State: %s\nTG Port "\r\n"Primary Access Status: %s\nTG Port Secondary Access"\r\n" State: %s\nTG Port Secondary Access Status: %s\n",\r\nconfig_item_name(tg_pt_ci), tg_pt_gp->tg_pt_gp_id,\r\ncore_alua_dump_state(atomic_read(\r\n&tg_pt_gp->tg_pt_gp_alua_access_state)),\r\ncore_alua_dump_status(\r\ntg_pt_gp->tg_pt_gp_alua_access_status),\r\n(atomic_read(&port->sep_tg_pt_secondary_offline)) ?\r\n"Offline" : "None",\r\ncore_alua_dump_status(port->sep_tg_pt_secondary_stat));\r\n}\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nreturn len;\r\n}\r\nssize_t core_alua_store_tg_pt_gp_info(\r\nstruct se_port *port,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct se_portal_group *tpg;\r\nstruct se_lun *lun;\r\nstruct se_device *dev = port->sep_lun->lun_se_dev;\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = NULL, *tg_pt_gp_new = NULL;\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\nunsigned char buf[TG_PT_GROUP_NAME_BUF];\r\nint move = 0;\r\ntpg = port->sep_tpg;\r\nlun = port->sep_lun;\r\ntg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;\r\nif (!tg_pt_gp_mem)\r\nreturn 0;\r\nif (count > TG_PT_GROUP_NAME_BUF) {\r\npr_err("ALUA Target Port Group alias too large!\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, TG_PT_GROUP_NAME_BUF);\r\nmemcpy(buf, page, count);\r\nif (strcmp(strstrip(buf), "NULL")) {\r\ntg_pt_gp_new = core_alua_get_tg_pt_gp_by_name(dev,\r\nstrstrip(buf));\r\nif (!tg_pt_gp_new)\r\nreturn -ENODEV;\r\n}\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\ntg_pt_gp = tg_pt_gp_mem->tg_pt_gp;\r\nif (tg_pt_gp) {\r\nif (!tg_pt_gp_new) {\r\npr_debug("Target_Core_ConfigFS: Moving"\r\n" %s/tpgt_%hu/%s from ALUA Target Port Group:"\r\n" alua/%s, ID: %hu back to"\r\n" default_tg_pt_gp\n",\r\ntpg->se_tpg_tfo->tpg_get_wwn(tpg),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg),\r\nconfig_item_name(&lun->lun_group.cg_item),\r\nconfig_item_name(\r\n&tg_pt_gp->tg_pt_gp_group.cg_item),\r\ntg_pt_gp->tg_pt_gp_id);\r\n__core_alua_drop_tg_pt_gp_mem(tg_pt_gp_mem, tg_pt_gp);\r\n__core_alua_attach_tg_pt_gp_mem(tg_pt_gp_mem,\r\ndev->t10_alua.default_tg_pt_gp);\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\nreturn count;\r\n}\r\n__core_alua_drop_tg_pt_gp_mem(tg_pt_gp_mem, tg_pt_gp);\r\nmove = 1;\r\n}\r\n__core_alua_attach_tg_pt_gp_mem(tg_pt_gp_mem, tg_pt_gp_new);\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\npr_debug("Target_Core_ConfigFS: %s %s/tpgt_%hu/%s to ALUA"\r\n" Target Port Group: alua/%s, ID: %hu\n", (move) ?\r\n"Moving" : "Adding", tpg->se_tpg_tfo->tpg_get_wwn(tpg),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg),\r\nconfig_item_name(&lun->lun_group.cg_item),\r\nconfig_item_name(&tg_pt_gp_new->tg_pt_gp_group.cg_item),\r\ntg_pt_gp_new->tg_pt_gp_id);\r\ncore_alua_put_tg_pt_gp_from_name(tg_pt_gp_new);\r\nreturn count;\r\n}\r\nssize_t core_alua_show_access_type(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nchar *page)\r\n{\r\nif ((tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICT_ALUA) &&\r\n(tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICT_ALUA))\r\nreturn sprintf(page, "Implict and Explict\n");\r\nelse if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICT_ALUA)\r\nreturn sprintf(page, "Implict\n");\r\nelse if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICT_ALUA)\r\nreturn sprintf(page, "Explict\n");\r\nelse\r\nreturn sprintf(page, "None\n");\r\n}\r\nssize_t core_alua_store_access_type(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract alua_access_type\n");\r\nreturn -EINVAL;\r\n}\r\nif ((tmp != 0) && (tmp != 1) && (tmp != 2) && (tmp != 3)) {\r\npr_err("Illegal value for alua_access_type:"\r\n" %lu\n", tmp);\r\nreturn -EINVAL;\r\n}\r\nif (tmp == 3)\r\ntg_pt_gp->tg_pt_gp_alua_access_type =\r\nTPGS_IMPLICT_ALUA | TPGS_EXPLICT_ALUA;\r\nelse if (tmp == 2)\r\ntg_pt_gp->tg_pt_gp_alua_access_type = TPGS_EXPLICT_ALUA;\r\nelse if (tmp == 1)\r\ntg_pt_gp->tg_pt_gp_alua_access_type = TPGS_IMPLICT_ALUA;\r\nelse\r\ntg_pt_gp->tg_pt_gp_alua_access_type = 0;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_nonop_delay_msecs(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_nonop_delay_msecs);\r\n}\r\nssize_t core_alua_store_nonop_delay_msecs(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract nonop_delay_msecs\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp > ALUA_MAX_NONOP_DELAY_MSECS) {\r\npr_err("Passed nonop_delay_msecs: %lu, exceeds"\r\n" ALUA_MAX_NONOP_DELAY_MSECS: %d\n", tmp,\r\nALUA_MAX_NONOP_DELAY_MSECS);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp->tg_pt_gp_nonop_delay_msecs = (int)tmp;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_trans_delay_msecs(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_trans_delay_msecs);\r\n}\r\nssize_t core_alua_store_trans_delay_msecs(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract trans_delay_msecs\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp > ALUA_MAX_TRANS_DELAY_MSECS) {\r\npr_err("Passed trans_delay_msecs: %lu, exceeds"\r\n" ALUA_MAX_TRANS_DELAY_MSECS: %d\n", tmp,\r\nALUA_MAX_TRANS_DELAY_MSECS);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp->tg_pt_gp_trans_delay_msecs = (int)tmp;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_implict_trans_secs(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_implict_trans_secs);\r\n}\r\nssize_t core_alua_store_implict_trans_secs(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract implict_trans_secs\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp > ALUA_MAX_IMPLICT_TRANS_SECS) {\r\npr_err("Passed implict_trans_secs: %lu, exceeds"\r\n" ALUA_MAX_IMPLICT_TRANS_SECS: %d\n", tmp,\r\nALUA_MAX_IMPLICT_TRANS_SECS);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp->tg_pt_gp_implict_trans_secs = (int)tmp;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_preferred_bit(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_pref);\r\n}\r\nssize_t core_alua_store_preferred_bit(\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract preferred ALUA value\n");\r\nreturn -EINVAL;\r\n}\r\nif ((tmp != 0) && (tmp != 1)) {\r\npr_err("Illegal value for preferred ALUA: %lu\n", tmp);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp->tg_pt_gp_pref = (int)tmp;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_offline_bit(struct se_lun *lun, char *page)\r\n{\r\nif (!lun->lun_sep)\r\nreturn -ENODEV;\r\nreturn sprintf(page, "%d\n",\r\natomic_read(&lun->lun_sep->sep_tg_pt_secondary_offline));\r\n}\r\nssize_t core_alua_store_offline_bit(\r\nstruct se_lun *lun,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem;\r\nunsigned long tmp;\r\nint ret;\r\nif (!lun->lun_sep)\r\nreturn -ENODEV;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract alua_tg_pt_offline value\n");\r\nreturn -EINVAL;\r\n}\r\nif ((tmp != 0) && (tmp != 1)) {\r\npr_err("Illegal value for alua_tg_pt_offline: %lu\n",\r\ntmp);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp_mem = lun->lun_sep->sep_alua_tg_pt_gp_mem;\r\nif (!tg_pt_gp_mem) {\r\npr_err("Unable to locate *tg_pt_gp_mem\n");\r\nreturn -EINVAL;\r\n}\r\nret = core_alua_set_tg_pt_secondary_state(tg_pt_gp_mem,\r\nlun->lun_sep, 0, (int)tmp);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_secondary_status(\r\nstruct se_lun *lun,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n", lun->lun_sep->sep_tg_pt_secondary_stat);\r\n}\r\nssize_t core_alua_store_secondary_status(\r\nstruct se_lun *lun,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract alua_tg_pt_status\n");\r\nreturn -EINVAL;\r\n}\r\nif ((tmp != ALUA_STATUS_NONE) &&\r\n(tmp != ALUA_STATUS_ALTERED_BY_EXPLICT_STPG) &&\r\n(tmp != ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA)) {\r\npr_err("Illegal value for alua_tg_pt_status: %lu\n",\r\ntmp);\r\nreturn -EINVAL;\r\n}\r\nlun->lun_sep->sep_tg_pt_secondary_stat = (int)tmp;\r\nreturn count;\r\n}\r\nssize_t core_alua_show_secondary_write_metadata(\r\nstruct se_lun *lun,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n",\r\nlun->lun_sep->sep_tg_pt_secondary_write_md);\r\n}\r\nssize_t core_alua_store_secondary_write_metadata(\r\nstruct se_lun *lun,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nint ret;\r\nret = strict_strtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract alua_tg_pt_write_md\n");\r\nreturn -EINVAL;\r\n}\r\nif ((tmp != 0) && (tmp != 1)) {\r\npr_err("Illegal value for alua_tg_pt_write_md:"\r\n" %lu\n", tmp);\r\nreturn -EINVAL;\r\n}\r\nlun->lun_sep->sep_tg_pt_secondary_write_md = (int)tmp;\r\nreturn count;\r\n}\r\nint core_setup_alua(struct se_device *dev)\r\n{\r\nif (dev->transport->transport_type != TRANSPORT_PLUGIN_PHBA_PDEV &&\r\n!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)) {\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nlu_gp_mem = core_alua_allocate_lu_gp_mem(dev);\r\nif (IS_ERR(lu_gp_mem))\r\nreturn PTR_ERR(lu_gp_mem);\r\nspin_lock(&lu_gp_mem->lu_gp_mem_lock);\r\n__core_alua_attach_lu_gp_mem(lu_gp_mem,\r\ndefault_lu_gp);\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\npr_debug("%s: Adding to default ALUA LU Group:"\r\n" core/alua/lu_gps/default_lu_gp\n",\r\ndev->transport->name);\r\n}\r\nreturn 0;\r\n}
