static inline int cpsw_ale_get_field(u32 *ale_entry, u32 start, u32 bits)\r\n{\r\nint idx;\r\nidx = start / 32;\r\nstart -= idx * 32;\r\nidx = 2 - idx;\r\nreturn (ale_entry[idx] >> start) & BITMASK(bits);\r\n}\r\nstatic inline void cpsw_ale_set_field(u32 *ale_entry, u32 start, u32 bits,\r\nu32 value)\r\n{\r\nint idx;\r\nvalue &= BITMASK(bits);\r\nidx = start / 32;\r\nstart -= idx * 32;\r\nidx = 2 - idx;\r\nale_entry[idx] &= ~(BITMASK(bits) << start);\r\nale_entry[idx] |= (value << start);\r\n}\r\nstatic inline void cpsw_ale_get_addr(u32 *ale_entry, u8 *addr)\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\naddr[i] = cpsw_ale_get_field(ale_entry, 40 - 8*i, 8);\r\n}\r\nstatic inline void cpsw_ale_set_addr(u32 *ale_entry, u8 *addr)\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\ncpsw_ale_set_field(ale_entry, 40 - 8*i, 8, addr[i]);\r\n}\r\nstatic int cpsw_ale_read(struct cpsw_ale *ale, int idx, u32 *ale_entry)\r\n{\r\nint i;\r\nWARN_ON(idx > ale->params.ale_entries);\r\n__raw_writel(idx, ale->params.ale_regs + ALE_TABLE_CONTROL);\r\nfor (i = 0; i < ALE_ENTRY_WORDS; i++)\r\nale_entry[i] = __raw_readl(ale->params.ale_regs +\r\nALE_TABLE + 4 * i);\r\nreturn idx;\r\n}\r\nstatic int cpsw_ale_write(struct cpsw_ale *ale, int idx, u32 *ale_entry)\r\n{\r\nint i;\r\nWARN_ON(idx > ale->params.ale_entries);\r\nfor (i = 0; i < ALE_ENTRY_WORDS; i++)\r\n__raw_writel(ale_entry[i], ale->params.ale_regs +\r\nALE_TABLE + 4 * i);\r\n__raw_writel(idx | ALE_TABLE_WRITE, ale->params.ale_regs +\r\nALE_TABLE_CONTROL);\r\nreturn idx;\r\n}\r\nint cpsw_ale_match_addr(struct cpsw_ale *ale, u8 *addr, u16 vid)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS];\r\nint type, idx;\r\nfor (idx = 0; idx < ale->params.ale_entries; idx++) {\r\nu8 entry_addr[6];\r\ncpsw_ale_read(ale, idx, ale_entry);\r\ntype = cpsw_ale_get_entry_type(ale_entry);\r\nif (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)\r\ncontinue;\r\nif (cpsw_ale_get_vlan_id(ale_entry) != vid)\r\ncontinue;\r\ncpsw_ale_get_addr(ale_entry, entry_addr);\r\nif (memcmp(entry_addr, addr, 6) == 0)\r\nreturn idx;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS];\r\nint type, idx;\r\nfor (idx = 0; idx < ale->params.ale_entries; idx++) {\r\ncpsw_ale_read(ale, idx, ale_entry);\r\ntype = cpsw_ale_get_entry_type(ale_entry);\r\nif (type != ALE_TYPE_VLAN)\r\ncontinue;\r\nif (cpsw_ale_get_vlan_id(ale_entry) == vid)\r\nreturn idx;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int cpsw_ale_match_free(struct cpsw_ale *ale)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS];\r\nint type, idx;\r\nfor (idx = 0; idx < ale->params.ale_entries; idx++) {\r\ncpsw_ale_read(ale, idx, ale_entry);\r\ntype = cpsw_ale_get_entry_type(ale_entry);\r\nif (type == ALE_TYPE_FREE)\r\nreturn idx;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int cpsw_ale_find_ageable(struct cpsw_ale *ale)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS];\r\nint type, idx;\r\nfor (idx = 0; idx < ale->params.ale_entries; idx++) {\r\ncpsw_ale_read(ale, idx, ale_entry);\r\ntype = cpsw_ale_get_entry_type(ale_entry);\r\nif (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)\r\ncontinue;\r\nif (cpsw_ale_get_mcast(ale_entry))\r\ncontinue;\r\ntype = cpsw_ale_get_ucast_type(ale_entry);\r\nif (type != ALE_UCAST_PERSISTANT &&\r\ntype != ALE_UCAST_OUI)\r\nreturn idx;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void cpsw_ale_flush_mcast(struct cpsw_ale *ale, u32 *ale_entry,\r\nint port_mask)\r\n{\r\nint mask;\r\nmask = cpsw_ale_get_port_mask(ale_entry);\r\nif ((mask & port_mask) == 0)\r\nreturn;\r\nmask &= ~port_mask;\r\nif (mask)\r\ncpsw_ale_set_port_mask(ale_entry, mask);\r\nelse\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\r\n}\r\nint cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS];\r\nint ret, idx;\r\nfor (idx = 0; idx < ale->params.ale_entries; idx++) {\r\ncpsw_ale_read(ale, idx, ale_entry);\r\nret = cpsw_ale_get_entry_type(ale_entry);\r\nif (ret != ALE_TYPE_ADDR && ret != ALE_TYPE_VLAN_ADDR)\r\ncontinue;\r\nif (cpsw_ale_get_mcast(ale_entry)) {\r\nu8 addr[6];\r\ncpsw_ale_get_addr(ale_entry, addr);\r\nif (!is_broadcast_ether_addr(addr))\r\ncpsw_ale_flush_mcast(ale, ale_entry, port_mask);\r\n}\r\ncpsw_ale_write(ale, idx, ale_entry);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cpsw_ale_flush_ucast(struct cpsw_ale *ale, u32 *ale_entry,\r\nint port_mask)\r\n{\r\nint port;\r\nport = cpsw_ale_get_port_num(ale_entry);\r\nif ((BIT(port) & port_mask) == 0)\r\nreturn;\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\r\n}\r\nint cpsw_ale_flush(struct cpsw_ale *ale, int port_mask)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS];\r\nint ret, idx;\r\nfor (idx = 0; idx < ale->params.ale_entries; idx++) {\r\ncpsw_ale_read(ale, idx, ale_entry);\r\nret = cpsw_ale_get_entry_type(ale_entry);\r\nif (ret != ALE_TYPE_ADDR && ret != ALE_TYPE_VLAN_ADDR)\r\ncontinue;\r\nif (cpsw_ale_get_mcast(ale_entry))\r\ncpsw_ale_flush_mcast(ale, ale_entry, port_mask);\r\nelse\r\ncpsw_ale_flush_ucast(ale, ale_entry, port_mask);\r\ncpsw_ale_write(ale, idx, ale_entry);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void cpsw_ale_set_vlan_entry_type(u32 *ale_entry,\r\nint flags, u16 vid)\r\n{\r\nif (flags & ALE_VLAN) {\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN_ADDR);\r\ncpsw_ale_set_vlan_id(ale_entry, vid);\r\n} else {\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);\r\n}\r\n}\r\nint cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port,\r\nint flags, u16 vid)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\r\nint idx;\r\ncpsw_ale_set_vlan_entry_type(ale_entry, flags, vid);\r\ncpsw_ale_set_addr(ale_entry, addr);\r\ncpsw_ale_set_ucast_type(ale_entry, ALE_UCAST_PERSISTANT);\r\ncpsw_ale_set_secure(ale_entry, (flags & ALE_SECURE) ? 1 : 0);\r\ncpsw_ale_set_blocked(ale_entry, (flags & ALE_BLOCKED) ? 1 : 0);\r\ncpsw_ale_set_port_num(ale_entry, port);\r\nidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\r\nif (idx < 0)\r\nidx = cpsw_ale_match_free(ale);\r\nif (idx < 0)\r\nidx = cpsw_ale_find_ageable(ale);\r\nif (idx < 0)\r\nreturn -ENOMEM;\r\ncpsw_ale_write(ale, idx, ale_entry);\r\nreturn 0;\r\n}\r\nint cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port,\r\nint flags, u16 vid)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\r\nint idx;\r\nidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\r\nif (idx < 0)\r\nreturn -ENOENT;\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\r\ncpsw_ale_write(ale, idx, ale_entry);\r\nreturn 0;\r\n}\r\nint cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,\r\nint flags, u16 vid, int mcast_state)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\r\nint idx, mask;\r\nidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\r\nif (idx >= 0)\r\ncpsw_ale_read(ale, idx, ale_entry);\r\ncpsw_ale_set_vlan_entry_type(ale_entry, flags, vid);\r\ncpsw_ale_set_addr(ale_entry, addr);\r\ncpsw_ale_set_super(ale_entry, (flags & ALE_BLOCKED) ? 1 : 0);\r\ncpsw_ale_set_mcast_state(ale_entry, mcast_state);\r\nmask = cpsw_ale_get_port_mask(ale_entry);\r\nport_mask |= mask;\r\ncpsw_ale_set_port_mask(ale_entry, port_mask);\r\nif (idx < 0)\r\nidx = cpsw_ale_match_free(ale);\r\nif (idx < 0)\r\nidx = cpsw_ale_find_ageable(ale);\r\nif (idx < 0)\r\nreturn -ENOMEM;\r\ncpsw_ale_write(ale, idx, ale_entry);\r\nreturn 0;\r\n}\r\nint cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,\r\nint flags, u16 vid)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\r\nint idx;\r\nidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\r\nif (idx < 0)\r\nreturn -EINVAL;\r\ncpsw_ale_read(ale, idx, ale_entry);\r\nif (port_mask)\r\ncpsw_ale_set_port_mask(ale_entry, port_mask);\r\nelse\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\r\ncpsw_ale_write(ale, idx, ale_entry);\r\nreturn 0;\r\n}\r\nint cpsw_ale_add_vlan(struct cpsw_ale *ale, u16 vid, int port, int untag,\r\nint reg_mcast, int unreg_mcast)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\r\nint idx;\r\nidx = cpsw_ale_match_vlan(ale, vid);\r\nif (idx >= 0)\r\ncpsw_ale_read(ale, idx, ale_entry);\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN);\r\ncpsw_ale_set_vlan_id(ale_entry, vid);\r\ncpsw_ale_set_vlan_untag_force(ale_entry, untag);\r\ncpsw_ale_set_vlan_reg_mcast(ale_entry, reg_mcast);\r\ncpsw_ale_set_vlan_unreg_mcast(ale_entry, unreg_mcast);\r\ncpsw_ale_set_vlan_member_list(ale_entry, port);\r\nif (idx < 0)\r\nidx = cpsw_ale_match_free(ale);\r\nif (idx < 0)\r\nidx = cpsw_ale_find_ageable(ale);\r\nif (idx < 0)\r\nreturn -ENOMEM;\r\ncpsw_ale_write(ale, idx, ale_entry);\r\nreturn 0;\r\n}\r\nint cpsw_ale_del_vlan(struct cpsw_ale *ale, u16 vid, int port_mask)\r\n{\r\nu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\r\nint idx;\r\nidx = cpsw_ale_match_vlan(ale, vid);\r\nif (idx < 0)\r\nreturn -ENOENT;\r\ncpsw_ale_read(ale, idx, ale_entry);\r\nif (port_mask)\r\ncpsw_ale_set_vlan_member_list(ale_entry, port_mask);\r\nelse\r\ncpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\r\ncpsw_ale_write(ale, idx, ale_entry);\r\nreturn 0;\r\n}\r\nint cpsw_ale_control_set(struct cpsw_ale *ale, int port, int control,\r\nint value)\r\n{\r\nconst struct ale_control_info *info;\r\nint offset, shift;\r\nu32 tmp, mask;\r\nif (control < 0 || control >= ARRAY_SIZE(ale_controls))\r\nreturn -EINVAL;\r\ninfo = &ale_controls[control];\r\nif (info->port_offset == 0 && info->port_shift == 0)\r\nport = 0;\r\nif (port < 0 || port > ale->params.ale_ports)\r\nreturn -EINVAL;\r\nmask = BITMASK(info->bits);\r\nif (value & ~mask)\r\nreturn -EINVAL;\r\noffset = info->offset + (port * info->port_offset);\r\nshift = info->shift + (port * info->port_shift);\r\ntmp = __raw_readl(ale->params.ale_regs + offset);\r\ntmp = (tmp & ~(mask << shift)) | (value << shift);\r\n__raw_writel(tmp, ale->params.ale_regs + offset);\r\nreturn 0;\r\n}\r\nint cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control)\r\n{\r\nconst struct ale_control_info *info;\r\nint offset, shift;\r\nu32 tmp;\r\nif (control < 0 || control >= ARRAY_SIZE(ale_controls))\r\nreturn -EINVAL;\r\ninfo = &ale_controls[control];\r\nif (info->port_offset == 0 && info->port_shift == 0)\r\nport = 0;\r\nif (port < 0 || port > ale->params.ale_ports)\r\nreturn -EINVAL;\r\noffset = info->offset + (port * info->port_offset);\r\nshift = info->shift + (port * info->port_shift);\r\ntmp = __raw_readl(ale->params.ale_regs + offset) >> shift;\r\nreturn tmp & BITMASK(info->bits);\r\n}\r\nstatic void cpsw_ale_timer(unsigned long arg)\r\n{\r\nstruct cpsw_ale *ale = (struct cpsw_ale *)arg;\r\ncpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);\r\nif (ale->ageout) {\r\nale->timer.expires = jiffies + ale->ageout;\r\nadd_timer(&ale->timer);\r\n}\r\n}\r\nint cpsw_ale_set_ageout(struct cpsw_ale *ale, int ageout)\r\n{\r\ndel_timer_sync(&ale->timer);\r\nale->ageout = ageout * HZ;\r\nif (ale->ageout) {\r\nale->timer.expires = jiffies + ale->ageout;\r\nadd_timer(&ale->timer);\r\n}\r\nreturn 0;\r\n}\r\nvoid cpsw_ale_start(struct cpsw_ale *ale)\r\n{\r\nu32 rev;\r\nrev = __raw_readl(ale->params.ale_regs + ALE_IDVER);\r\ndev_dbg(ale->params.dev, "initialized cpsw ale revision %d.%d\n",\r\nALE_VERSION_MAJOR(rev), ALE_VERSION_MINOR(rev));\r\ncpsw_ale_control_set(ale, 0, ALE_ENABLE, 1);\r\ncpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);\r\ninit_timer(&ale->timer);\r\nale->timer.data = (unsigned long)ale;\r\nale->timer.function = cpsw_ale_timer;\r\nif (ale->ageout) {\r\nale->timer.expires = jiffies + ale->ageout;\r\nadd_timer(&ale->timer);\r\n}\r\n}\r\nvoid cpsw_ale_stop(struct cpsw_ale *ale)\r\n{\r\ndel_timer_sync(&ale->timer);\r\n}\r\nstruct cpsw_ale *cpsw_ale_create(struct cpsw_ale_params *params)\r\n{\r\nstruct cpsw_ale *ale;\r\nale = kzalloc(sizeof(*ale), GFP_KERNEL);\r\nif (!ale)\r\nreturn NULL;\r\nale->params = *params;\r\nale->ageout = ale->params.ale_ageout * HZ;\r\nreturn ale;\r\n}\r\nint cpsw_ale_destroy(struct cpsw_ale *ale)\r\n{\r\nif (!ale)\r\nreturn -EINVAL;\r\ncpsw_ale_stop(ale);\r\ncpsw_ale_control_set(ale, 0, ALE_ENABLE, 0);\r\nkfree(ale);\r\nreturn 0;\r\n}
