static void\r\nl3_1TR6_message(struct l3_process *pc, u_char mt, u_char pd)\r\n{\r\nstruct sk_buff *skb;\r\nu_char *p;\r\nif (!(skb = l3_alloc_skb(4)))\r\nreturn;\r\np = skb_put(skb, 4);\r\nMsgHead(p, pc->callref, mt, pd);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3_1tr6_release_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nStopAllL3Timer(pc);\r\nnewl3state(pc, 19);\r\nl3_1TR6_message(pc, MT_N1_REL, PROTO_DIS_N1);\r\nL3AddTimer(&pc->timer, T308, CC_T308_1);\r\n}\r\nstatic void\r\nl3_1tr6_invalid(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\ndev_kfree_skb(skb);\r\nl3_1tr6_release_req(pc, 0, NULL);\r\n}\r\nstatic void\r\nl3_1tr6_error(struct l3_process *pc, u_char *msg, struct sk_buff *skb)\r\n{\r\ndev_kfree_skb(skb);\r\nif (pc->st->l3.debug & L3_DEB_WARN)\r\nl3_debug(pc->st, msg);\r\nl3_1tr6_release_req(pc, 0, NULL);\r\n}\r\nstatic void\r\nl3_1tr6_setup_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[128];\r\nu_char *p = tmp;\r\nu_char *teln;\r\nu_char *eaz;\r\nu_char channel = 0;\r\nint l;\r\nMsgHead(p, pc->callref, MT_N1_SETUP, PROTO_DIS_N1);\r\nteln = pc->para.setup.phone;\r\npc->para.spv = 0;\r\nif (!isdigit(*teln)) {\r\nswitch (0x5f & *teln) {\r\ncase 'S':\r\npc->para.spv = 1;\r\nbreak;\r\ncase 'C':\r\nchannel = 0x08;\r\ncase 'P':\r\nchannel |= 0x80;\r\nteln++;\r\nif (*teln == '1')\r\nchannel |= 0x01;\r\nelse\r\nchannel |= 0x02;\r\nbreak;\r\ndefault:\r\nif (pc->st->l3.debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "Wrong MSN Code");\r\nbreak;\r\n}\r\nteln++;\r\n}\r\nif (channel) {\r\n*p++ = 0x18;\r\n*p++ = 1;\r\n*p++ = channel;\r\n}\r\nif (pc->para.spv) {\r\n*p++ = WE0_netSpecFac;\r\n*p++ = 4;\r\n*p++ = 0;\r\n*p++ = FAC_SPV;\r\n*p++ = pc->para.setup.si1;\r\n*p++ = pc->para.setup.si2;\r\n*p++ = WE0_netSpecFac;\r\n*p++ = 4;\r\n*p++ = 0;\r\n*p++ = FAC_Activate;\r\n*p++ = pc->para.setup.si1;\r\n*p++ = pc->para.setup.si2;\r\n}\r\neaz = pc->para.setup.eazmsn;\r\nif (*eaz) {\r\n*p++ = WE0_origAddr;\r\n*p++ = strlen(eaz) + 1;\r\n*p++ = 0x81;\r\nwhile (*eaz)\r\n*p++ = *eaz++ & 0x7f;\r\n}\r\n*p++ = WE0_destAddr;\r\n*p++ = strlen(teln) + 1;\r\n*p++ = 0x81;\r\nwhile (*teln)\r\n*p++ = *teln++ & 0x7f;\r\n*p++ = WE_Shift_F6;\r\n*p++ = WE6_serviceInd;\r\n*p++ = 2;\r\n*p++ = pc->para.setup.si1;\r\n*p++ = pc->para.setup.si2;\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, T303, CC_T303);\r\nnewl3state(pc, 1);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\nl3_1tr6_setup(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nint bcfound = 0;\r\nchar tmp[80];\r\nstruct sk_buff *skb = arg;\r\np = findie(skb->data, skb->len, WE0_chanID, 0);\r\nif (p) {\r\nif (p[1] != 1) {\r\nl3_1tr6_error(pc, "setup wrong chanID len", skb);\r\nreturn;\r\n}\r\nif ((p[2] & 0xf4) != 0x80) {\r\nl3_1tr6_error(pc, "setup wrong WE0_chanID", skb);\r\nreturn;\r\n}\r\nif ((pc->para.bchannel = p[2] & 0x3))\r\nbcfound++;\r\n} else {\r\nl3_1tr6_error(pc, "missing setup chanID", skb);\r\nreturn;\r\n}\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE6_serviceInd, 6))) {\r\npc->para.setup.si1 = p[2];\r\npc->para.setup.si2 = p[3];\r\n} else {\r\nl3_1tr6_error(pc, "missing setup SI", skb);\r\nreturn;\r\n}\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE0_destAddr, 0)))\r\niecpy(pc->para.setup.eazmsn, p, 1);\r\nelse\r\npc->para.setup.eazmsn[0] = 0;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE0_origAddr, 0))) {\r\niecpy(pc->para.setup.phone, p, 1);\r\n} else\r\npc->para.setup.phone[0] = 0;\r\np = skb->data;\r\npc->para.spv = 0;\r\nif ((p = findie(p, skb->len, WE0_netSpecFac, 0))) {\r\nif ((FAC_SPV == p[3]) || (FAC_Activate == p[3]))\r\npc->para.spv = 1;\r\n}\r\ndev_kfree_skb(skb);\r\nif (bcfound) {\r\nif ((pc->para.setup.si1 != 7) && (pc->st->l3.debug & L3_DEB_WARN)) {\r\nsprintf(tmp, "non-digital call: %s -> %s",\r\npc->para.setup.phone,\r\npc->para.setup.eazmsn);\r\nl3_debug(pc->st, tmp);\r\n}\r\nnewl3state(pc, 6);\r\npc->st->l3.l3l4(pc->st, CC_SETUP | INDICATION, pc);\r\n} else\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nl3_1tr6_setup_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nstruct sk_buff *skb = arg;\r\nL3DelTimer(&pc->timer);\r\np = skb->data;\r\nnewl3state(pc, 2);\r\nif ((p = findie(p, skb->len, WE0_chanID, 0))) {\r\nif (p[1] != 1) {\r\nl3_1tr6_error(pc, "setup_ack wrong chanID len", skb);\r\nreturn;\r\n}\r\nif ((p[2] & 0xf4) != 0x80) {\r\nl3_1tr6_error(pc, "setup_ack wrong WE0_chanID", skb);\r\nreturn;\r\n}\r\npc->para.bchannel = p[2] & 0x3;\r\n} else {\r\nl3_1tr6_error(pc, "missing setup_ack WE0_chanID", skb);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nL3AddTimer(&pc->timer, T304, CC_T304);\r\npc->st->l3.l3l4(pc->st, CC_MORE_INFO | INDICATION, pc);\r\n}\r\nstatic void\r\nl3_1tr6_call_sent(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nstruct sk_buff *skb = arg;\r\nL3DelTimer(&pc->timer);\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE0_chanID, 0))) {\r\nif (p[1] != 1) {\r\nl3_1tr6_error(pc, "call sent wrong chanID len", skb);\r\nreturn;\r\n}\r\nif ((p[2] & 0xf4) != 0x80) {\r\nl3_1tr6_error(pc, "call sent wrong WE0_chanID", skb);\r\nreturn;\r\n}\r\nif ((pc->state == 2) && (pc->para.bchannel != (p[2] & 0x3))) {\r\nl3_1tr6_error(pc, "call sent wrong chanID value", skb);\r\nreturn;\r\n}\r\npc->para.bchannel = p[2] & 0x3;\r\n} else {\r\nl3_1tr6_error(pc, "missing call sent WE0_chanID", skb);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nL3AddTimer(&pc->timer, T310, CC_T310);\r\nnewl3state(pc, 3);\r\npc->st->l3.l3l4(pc->st, CC_PROCEEDING | INDICATION, pc);\r\n}\r\nstatic void\r\nl3_1tr6_alert(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\ndev_kfree_skb(skb);\r\nL3DelTimer(&pc->timer);\r\nnewl3state(pc, 4);\r\npc->st->l3.l3l4(pc->st, CC_ALERTING | INDICATION, pc);\r\n}\r\nstatic void\r\nl3_1tr6_info(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nu_char *p;\r\nint i, tmpcharge = 0;\r\nchar a_charge[8], tmp[32];\r\nstruct sk_buff *skb = arg;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE6_chargingInfo, 6))) {\r\niecpy(a_charge, p, 1);\r\nfor (i = 0; i < strlen(a_charge); i++) {\r\ntmpcharge *= 10;\r\ntmpcharge += a_charge[i] & 0xf;\r\n}\r\nif (tmpcharge > pc->para.chargeinfo) {\r\npc->para.chargeinfo = tmpcharge;\r\npc->st->l3.l3l4(pc->st, CC_CHARGE | INDICATION, pc);\r\n}\r\nif (pc->st->l3.debug & L3_DEB_CHARGE) {\r\nsprintf(tmp, "charging info %d", pc->para.chargeinfo);\r\nl3_debug(pc->st, tmp);\r\n}\r\n} else if (pc->st->l3.debug & L3_DEB_CHARGE)\r\nl3_debug(pc->st, "charging info not found");\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl3_1tr6_info_s2(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl3_1tr6_connect(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nL3DelTimer(&pc->timer);\r\nif (!findie(skb->data, skb->len, WE6_date, 6)) {\r\nl3_1tr6_error(pc, "missing connect date", skb);\r\nreturn;\r\n}\r\nnewl3state(pc, 10);\r\ndev_kfree_skb(skb);\r\npc->para.chargeinfo = 0;\r\npc->st->l3.l3l4(pc->st, CC_SETUP | CONFIRM, pc);\r\n}\r\nstatic void\r\nl3_1tr6_rel(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nu_char *p;\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE0_cause, 0))) {\r\nif (p[1] > 0) {\r\npc->para.cause = p[2];\r\nif (p[1] > 1)\r\npc->para.loc = p[3];\r\nelse\r\npc->para.loc = 0;\r\n} else {\r\npc->para.cause = 0;\r\npc->para.loc = 0;\r\n}\r\n} else {\r\npc->para.cause = NO_CAUSE;\r\nl3_1tr6_error(pc, "missing REL cause", skb);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nStopAllL3Timer(pc);\r\nnewl3state(pc, 0);\r\nl3_1TR6_message(pc, MT_N1_REL_ACK, PROTO_DIS_N1);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nl3_1tr6_rel_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\ndev_kfree_skb(skb);\r\nStopAllL3Timer(pc);\r\nnewl3state(pc, 0);\r\npc->para.cause = NO_CAUSE;\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | CONFIRM, pc);\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nl3_1tr6_disc(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nu_char *p;\r\nint i, tmpcharge = 0;\r\nchar a_charge[8], tmp[32];\r\nStopAllL3Timer(pc);\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE6_chargingInfo, 6))) {\r\niecpy(a_charge, p, 1);\r\nfor (i = 0; i < strlen(a_charge); i++) {\r\ntmpcharge *= 10;\r\ntmpcharge += a_charge[i] & 0xf;\r\n}\r\nif (tmpcharge > pc->para.chargeinfo) {\r\npc->para.chargeinfo = tmpcharge;\r\npc->st->l3.l3l4(pc->st, CC_CHARGE | INDICATION, pc);\r\n}\r\nif (pc->st->l3.debug & L3_DEB_CHARGE) {\r\nsprintf(tmp, "charging info %d", pc->para.chargeinfo);\r\nl3_debug(pc->st, tmp);\r\n}\r\n} else if (pc->st->l3.debug & L3_DEB_CHARGE)\r\nl3_debug(pc->st, "charging info not found");\r\np = skb->data;\r\nif ((p = findie(p, skb->len, WE0_cause, 0))) {\r\nif (p[1] > 0) {\r\npc->para.cause = p[2];\r\nif (p[1] > 1)\r\npc->para.loc = p[3];\r\nelse\r\npc->para.loc = 0;\r\n} else {\r\npc->para.cause = 0;\r\npc->para.loc = 0;\r\n}\r\n} else {\r\nif (pc->st->l3.debug & L3_DEB_WARN)\r\nl3_debug(pc->st, "cause not found");\r\npc->para.cause = NO_CAUSE;\r\n}\r\nif (!findie(skb->data, skb->len, WE6_date, 6)) {\r\nl3_1tr6_error(pc, "missing connack date", skb);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nnewl3state(pc, 12);\r\npc->st->l3.l3l4(pc->st, CC_DISCONNECT | INDICATION, pc);\r\n}\r\nstatic void\r\nl3_1tr6_connect_ack(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nif (!findie(skb->data, skb->len, WE6_date, 6)) {\r\nl3_1tr6_error(pc, "missing connack date", skb);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nnewl3state(pc, 10);\r\npc->para.chargeinfo = 0;\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_COMPL | INDICATION, pc);\r\n}\r\nstatic void\r\nl3_1tr6_alert_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nnewl3state(pc, 7);\r\nl3_1TR6_message(pc, MT_N1_ALERT, PROTO_DIS_N1);\r\n}\r\nstatic void\r\nl3_1tr6_setup_rsp(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[24];\r\nu_char *p = tmp;\r\nint l;\r\nMsgHead(p, pc->callref, MT_N1_CONN, PROTO_DIS_N1);\r\nif (pc->para.spv) {\r\n*p++ = WE0_netSpecFac;\r\n*p++ = 4;\r\n*p++ = 0;\r\n*p++ = FAC_SPV;\r\n*p++ = pc->para.setup.si1;\r\n*p++ = pc->para.setup.si2;\r\n*p++ = WE0_netSpecFac;\r\n*p++ = 4;\r\n*p++ = 0;\r\n*p++ = FAC_Activate;\r\n*p++ = pc->para.setup.si1;\r\n*p++ = pc->para.setup.si2;\r\n}\r\nnewl3state(pc, 8);\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nL3DelTimer(&pc->timer);\r\nL3AddTimer(&pc->timer, T313, CC_T313);\r\n}\r\nstatic void\r\nl3_1tr6_reset(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nl3_1tr6_disconnect_req(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nu_char cause = 0x10;\r\nu_char clen = 1;\r\nif (pc->para.cause > 0)\r\ncause = pc->para.cause;\r\nswitch (cause & 0x7f) {\r\ncase 0x10:\r\nclen = 0;\r\nbreak;\r\ncase 0x11:\r\ncause = CAUSE_UserBusy;\r\nbreak;\r\ncase 0x15:\r\ncause = CAUSE_CallRejected;\r\nbreak;\r\n}\r\nStopAllL3Timer(pc);\r\nMsgHead(p, pc->callref, MT_N1_DISC, PROTO_DIS_N1);\r\n*p++ = WE0_cause;\r\n*p++ = clen;\r\nif (clen)\r\n*p++ = cause | 0x80;\r\nnewl3state(pc, 11);\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nL3AddTimer(&pc->timer, T305, CC_T305);\r\n}\r\nstatic void\r\nl3_1tr6_t303(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nif (pc->N303 > 0) {\r\npc->N303--;\r\nL3DelTimer(&pc->timer);\r\nl3_1tr6_setup_req(pc, pr, arg);\r\n} else {\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 0;\r\nl3_1tr6_disconnect_req(pc, 0, NULL);\r\n}\r\n}\r\nstatic void\r\nl3_1tr6_t304(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 0xE6;\r\nl3_1tr6_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3_1tr6_t305(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[16];\r\nu_char *p = tmp;\r\nint l;\r\nu_char cause = 0x90;\r\nu_char clen = 1;\r\nL3DelTimer(&pc->timer);\r\nif (pc->para.cause != NO_CAUSE)\r\ncause = pc->para.cause;\r\nswitch (cause & 0x7f) {\r\ncase 0x10:\r\nclen = 0;\r\nbreak;\r\ncase 0x15:\r\ncause = CAUSE_CallRejected;\r\nbreak;\r\n}\r\nMsgHead(p, pc->callref, MT_N1_REL, PROTO_DIS_N1);\r\n*p++ = WE0_cause;\r\n*p++ = clen;\r\nif (clen)\r\n*p++ = cause;\r\nnewl3state(pc, 19);\r\nl = p - tmp;\r\nif (!(skb = l3_alloc_skb(l)))\r\nreturn;\r\nmemcpy(skb_put(skb, l), tmp, l);\r\nl3_msg(pc->st, DL_DATA | REQUEST, skb);\r\nL3AddTimer(&pc->timer, T308, CC_T308_1);\r\n}\r\nstatic void\r\nl3_1tr6_t310(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 0xE6;\r\nl3_1tr6_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3_1tr6_t313(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->para.cause = 0xE6;\r\nl3_1tr6_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_CONNECT_ERR, pc);\r\n}\r\nstatic void\r\nl3_1tr6_t308_1(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\nl3_1TR6_message(pc, MT_N1_REL, PROTO_DIS_N1);\r\nL3AddTimer(&pc->timer, T308, CC_T308_2);\r\nnewl3state(pc, 19);\r\n}\r\nstatic void\r\nl3_1tr6_t308_2(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nL3DelTimer(&pc->timer);\r\npc->st->l3.l3l4(pc->st, CC_RELEASE_ERR, pc);\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nl3_1tr6_dl_reset(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\npc->para.cause = CAUSE_LocalProcErr;\r\nl3_1tr6_disconnect_req(pc, pr, NULL);\r\npc->st->l3.l3l4(pc->st, CC_SETUP_ERR, pc);\r\n}\r\nstatic void\r\nl3_1tr6_dl_release(struct l3_process *pc, u_char pr, void *arg)\r\n{\r\nnewl3state(pc, 0);\r\npc->para.cause = 0x1b;\r\npc->para.loc = 0;\r\npc->st->l3.l3l4(pc->st, CC_RELEASE | INDICATION, pc);\r\nrelease_l3_process(pc);\r\n}\r\nstatic void\r\nup1tr6(struct PStack *st, int pr, void *arg)\r\n{\r\nint i, mt, cr;\r\nstruct l3_process *proc;\r\nstruct sk_buff *skb = arg;\r\nchar tmp[80];\r\nswitch (pr) {\r\ncase (DL_DATA | INDICATION):\r\ncase (DL_UNIT_DATA | INDICATION):\r\nbreak;\r\ncase (DL_ESTABLISH | CONFIRM):\r\ncase (DL_ESTABLISH | INDICATION):\r\ncase (DL_RELEASE | INDICATION):\r\ncase (DL_RELEASE | CONFIRM):\r\nl3_msg(st, pr, arg);\r\nreturn;\r\nbreak;\r\n}\r\nif (skb->len < 4) {\r\nif (st->l3.debug & L3_DEB_PROTERR) {\r\nsprintf(tmp, "up1tr6 len only %d", skb->len);\r\nl3_debug(st, tmp);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif ((skb->data[0] & 0xfe) != PROTO_DIS_N0) {\r\nif (st->l3.debug & L3_DEB_PROTERR) {\r\nsprintf(tmp, "up1tr6%sunexpected discriminator %x message len %d",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ",\r\nskb->data[0], skb->len);\r\nl3_debug(st, tmp);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb->data[1] != 1) {\r\nif (st->l3.debug & L3_DEB_PROTERR) {\r\nsprintf(tmp, "up1tr6 CR len not 1");\r\nl3_debug(st, tmp);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ncr = skb->data[2];\r\nmt = skb->data[3];\r\nif (skb->data[0] == PROTO_DIS_N0) {\r\ndev_kfree_skb(skb);\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nsprintf(tmp, "up1tr6%s N0 mt %x unhandled",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ", mt);\r\nl3_debug(st, tmp);\r\n}\r\n} else if (skb->data[0] == PROTO_DIS_N1) {\r\nif (!(proc = getl3proc(st, cr))) {\r\nif (mt == MT_N1_SETUP) {\r\nif (cr < 128) {\r\nif (!(proc = new_l3_process(st, cr))) {\r\nif (st->l3.debug & L3_DEB_PROTERR) {\r\nsprintf(tmp, "up1tr6 no roc mem");\r\nl3_debug(st, tmp);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n} else {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\n} else if ((mt == MT_N1_REL) || (mt == MT_N1_REL_ACK) ||\r\n(mt == MT_N1_CANC_ACK) || (mt == MT_N1_CANC_REJ) ||\r\n(mt == MT_N1_REG_ACK) || (mt == MT_N1_REG_REJ) ||\r\n(mt == MT_N1_SUSP_ACK) || (mt == MT_N1_RES_REJ) ||\r\n(mt == MT_N1_INFO)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n} else {\r\nif (!(proc = new_l3_process(st, cr))) {\r\nif (st->l3.debug & L3_DEB_PROTERR) {\r\nsprintf(tmp, "up1tr6 no roc mem");\r\nl3_debug(st, tmp);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nmt = MT_N1_INVALID;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(datastln1); i++)\r\nif ((mt == datastln1[i].primitive) &&\r\n((1 << proc->state) & datastln1[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(datastln1)) {\r\ndev_kfree_skb(skb);\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nsprintf(tmp, "up1tr6%sstate %d mt %x unhandled",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ",\r\nproc->state, mt);\r\nl3_debug(st, tmp);\r\n}\r\nreturn;\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nsprintf(tmp, "up1tr6%sstate %d mt %x",\r\n(pr == (DL_DATA | INDICATION)) ? " " : "(broadcast) ",\r\nproc->state, mt);\r\nl3_debug(st, tmp);\r\n}\r\ndatastln1[i].rout(proc, pr, skb);\r\n}\r\n}\r\n}\r\nstatic void\r\ndown1tr6(struct PStack *st, int pr, void *arg)\r\n{\r\nint i, cr;\r\nstruct l3_process *proc;\r\nstruct Channel *chan;\r\nchar tmp[80];\r\nif ((DL_ESTABLISH | REQUEST) == pr) {\r\nl3_msg(st, pr, NULL);\r\nreturn;\r\n} else if ((CC_SETUP | REQUEST) == pr) {\r\nchan = arg;\r\ncr = newcallref();\r\ncr |= 0x80;\r\nif (!(proc = new_l3_process(st, cr))) {\r\nreturn;\r\n} else {\r\nproc->chan = chan;\r\nchan->proc = proc;\r\nmemcpy(&proc->para.setup, &chan->setup, sizeof(setup_parm));\r\nproc->callref = cr;\r\n}\r\n} else {\r\nproc = arg;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(downstl); i++)\r\nif ((pr == downstl[i].primitive) &&\r\n((1 << proc->state) & downstl[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(downstl)) {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nsprintf(tmp, "down1tr6 state %d prim %d unhandled",\r\nproc->state, pr);\r\nl3_debug(st, tmp);\r\n}\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nsprintf(tmp, "down1tr6 state %d prim %d",\r\nproc->state, pr);\r\nl3_debug(st, tmp);\r\n}\r\ndownstl[i].rout(proc, pr, arg);\r\n}\r\n}\r\nstatic void\r\nman1tr6(struct PStack *st, int pr, void *arg)\r\n{\r\nint i;\r\nstruct l3_process *proc = arg;\r\nif (!proc) {\r\nprintk(KERN_ERR "HiSax man1tr6 without proc pr=%04x\n", pr);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(manstatelist); i++)\r\nif ((pr == manstatelist[i].primitive) &&\r\n((1 << proc->state) & manstatelist[i].state))\r\nbreak;\r\nif (i == ARRAY_SIZE(manstatelist)) {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "cr %d man1tr6 state %d prim %d unhandled",\r\nproc->callref & 0x7f, proc->state, pr);\r\n}\r\n} else {\r\nif (st->l3.debug & L3_DEB_STATE) {\r\nl3_debug(st, "cr %d man1tr6 state %d prim %d",\r\nproc->callref & 0x7f, proc->state, pr);\r\n}\r\nmanstatelist[i].rout(proc, pr, arg);\r\n}\r\n}\r\nvoid\r\nsetstack_1tr6(struct PStack *st)\r\n{\r\nchar tmp[64];\r\nst->lli.l4l3 = down1tr6;\r\nst->l2.l2l3 = up1tr6;\r\nst->l3.l3ml3 = man1tr6;\r\nst->l3.N303 = 0;\r\nstrcpy(tmp, l3_1tr6_revision);\r\nprintk(KERN_INFO "HiSax: 1TR6 Rev. %s\n", HiSax_getrev(tmp));\r\n}
