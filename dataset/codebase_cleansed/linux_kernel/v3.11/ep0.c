static const char *dwc3_ep0_state_string(enum dwc3_ep0_state state)\r\n{\r\nswitch (state) {\r\ncase EP0_UNCONNECTED:\r\nreturn "Unconnected";\r\ncase EP0_SETUP_PHASE:\r\nreturn "Setup Phase";\r\ncase EP0_DATA_PHASE:\r\nreturn "Data Phase";\r\ncase EP0_STATUS_PHASE:\r\nreturn "Status Phase";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum, dma_addr_t buf_dma,\r\nu32 len, u32 type)\r\n{\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nstruct dwc3_trb *trb;\r\nstruct dwc3_ep *dep;\r\nint ret;\r\ndep = dwc->eps[epnum];\r\nif (dep->flags & DWC3_EP_BUSY) {\r\ndev_vdbg(dwc->dev, "%s: still busy\n", dep->name);\r\nreturn 0;\r\n}\r\ntrb = dwc->ep0_trb;\r\ntrb->bpl = lower_32_bits(buf_dma);\r\ntrb->bph = upper_32_bits(buf_dma);\r\ntrb->size = len;\r\ntrb->ctrl = type;\r\ntrb->ctrl |= (DWC3_TRB_CTRL_HWO\r\n| DWC3_TRB_CTRL_LST\r\n| DWC3_TRB_CTRL_IOC\r\n| DWC3_TRB_CTRL_ISP_IMI);\r\nmemset(&params, 0, sizeof(params));\r\nparams.param0 = upper_32_bits(dwc->ep0_trb_addr);\r\nparams.param1 = lower_32_bits(dwc->ep0_trb_addr);\r\nret = dwc3_send_gadget_ep_cmd(dwc, dep->number,\r\nDWC3_DEPCMD_STARTTRANSFER, &params);\r\nif (ret < 0) {\r\ndev_dbg(dwc->dev, "failed to send STARTTRANSFER command\n");\r\nreturn ret;\r\n}\r\ndep->flags |= DWC3_EP_BUSY;\r\ndep->resource_index = dwc3_gadget_ep_get_transfer_index(dwc,\r\ndep->number);\r\ndwc->ep0_next_event = DWC3_EP0_COMPLETE;\r\nreturn 0;\r\n}\r\nstatic int __dwc3_gadget_ep0_queue(struct dwc3_ep *dep,\r\nstruct dwc3_request *req)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nreq->request.actual = 0;\r\nreq->request.status = -EINPROGRESS;\r\nreq->epnum = dep->number;\r\nlist_add_tail(&req->list, &dep->request_list);\r\nif (dep->flags & DWC3_EP_PENDING_REQUEST) {\r\nunsigned direction;\r\ndirection = !!(dep->flags & DWC3_EP0_DIR_IN);\r\nif (dwc->ep0state != EP0_DATA_PHASE) {\r\ndev_WARN(dwc->dev, "Unexpected pending request\n");\r\nreturn 0;\r\n}\r\n__dwc3_ep0_do_control_data(dwc, dwc->eps[direction], req);\r\ndep->flags &= ~(DWC3_EP_PENDING_REQUEST |\r\nDWC3_EP0_DIR_IN);\r\nreturn 0;\r\n}\r\nif (dwc->delayed_status) {\r\nunsigned direction;\r\ndirection = !dwc->ep0_expect_in;\r\ndwc->delayed_status = false;\r\nif (dwc->ep0state == EP0_STATUS_PHASE)\r\n__dwc3_ep0_do_control_status(dwc, dwc->eps[direction]);\r\nelse\r\ndev_dbg(dwc->dev, "too early for delayed status\n");\r\nreturn 0;\r\n}\r\nif (dwc->three_stage_setup) {\r\nunsigned direction;\r\ndirection = dwc->ep0_expect_in;\r\ndwc->ep0state = EP0_DATA_PHASE;\r\n__dwc3_ep0_do_control_data(dwc, dwc->eps[direction], req);\r\ndep->flags &= ~DWC3_EP0_DIR_IN;\r\n}\r\nreturn 0;\r\n}\r\nint dwc3_gadget_ep0_queue(struct usb_ep *ep, struct usb_request *request,\r\ngfp_t gfp_flags)\r\n{\r\nstruct dwc3_request *req = to_dwc3_request(request);\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dwc->lock, flags);\r\nif (!dep->endpoint.desc) {\r\ndev_dbg(dwc->dev, "trying to queue request %p to disabled %s\n",\r\nrequest, dep->name);\r\nret = -ESHUTDOWN;\r\ngoto out;\r\n}\r\nif (!list_empty(&dep->request_list)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ndev_vdbg(dwc->dev, "queueing request %p to %s length %d, state '%s'\n",\r\nrequest, dep->name, request->length,\r\ndwc3_ep0_state_string(dwc->ep0state));\r\nret = __dwc3_gadget_ep0_queue(dep, req);\r\nout:\r\nspin_unlock_irqrestore(&dwc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void dwc3_ep0_stall_and_restart(struct dwc3 *dwc)\r\n{\r\nstruct dwc3_ep *dep;\r\ndep = dwc->eps[1];\r\ndep->flags = DWC3_EP_ENABLED;\r\ndep = dwc->eps[0];\r\n__dwc3_gadget_ep_set_halt(dep, 1);\r\ndep->flags = DWC3_EP_ENABLED;\r\ndwc->delayed_status = false;\r\nif (!list_empty(&dep->request_list)) {\r\nstruct dwc3_request *req;\r\nreq = next_request(&dep->request_list);\r\ndwc3_gadget_giveback(dep, req, -ECONNRESET);\r\n}\r\ndwc->ep0state = EP0_SETUP_PHASE;\r\ndwc3_ep0_out_start(dwc);\r\n}\r\nint dwc3_gadget_ep0_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\ndwc3_ep0_stall_and_restart(dwc);\r\nreturn 0;\r\n}\r\nvoid dwc3_ep0_out_start(struct dwc3 *dwc)\r\n{\r\nint ret;\r\nret = dwc3_ep0_start_trans(dwc, 0, dwc->ctrl_req_addr, 8,\r\nDWC3_TRBCTL_CONTROL_SETUP);\r\nWARN_ON(ret < 0);\r\n}\r\nstatic struct dwc3_ep *dwc3_wIndex_to_dep(struct dwc3 *dwc, __le16 wIndex_le)\r\n{\r\nstruct dwc3_ep *dep;\r\nu32 windex = le16_to_cpu(wIndex_le);\r\nu32 epnum;\r\nepnum = (windex & USB_ENDPOINT_NUMBER_MASK) << 1;\r\nif ((windex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\r\nepnum |= 1;\r\ndep = dwc->eps[epnum];\r\nif (dep->flags & DWC3_EP_ENABLED)\r\nreturn dep;\r\nreturn NULL;\r\n}\r\nstatic void dwc3_ep0_status_cmpl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\n}\r\nstatic int dwc3_ep0_handle_status(struct dwc3 *dwc,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct dwc3_ep *dep;\r\nu32 recip;\r\nu32 reg;\r\nu16 usb_status = 0;\r\n__le16 *response_pkt;\r\nrecip = ctrl->bRequestType & USB_RECIP_MASK;\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nusb_status |= dwc->is_selfpowered << USB_DEVICE_SELF_POWERED;\r\nif (dwc->speed == DWC3_DSTS_SUPERSPEED) {\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nif (reg & DWC3_DCTL_INITU1ENA)\r\nusb_status |= 1 << USB_DEV_STAT_U1_ENABLED;\r\nif (reg & DWC3_DCTL_INITU2ENA)\r\nusb_status |= 1 << USB_DEV_STAT_U2_ENABLED;\r\n}\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\ndep = dwc3_wIndex_to_dep(dwc, ctrl->wIndex);\r\nif (!dep)\r\nreturn -EINVAL;\r\nif (dep->flags & DWC3_EP_STALL)\r\nusb_status = 1 << USB_ENDPOINT_HALT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nresponse_pkt = (__le16 *) dwc->setup_buf;\r\n*response_pkt = cpu_to_le16(usb_status);\r\ndep = dwc->eps[0];\r\ndwc->ep0_usb_req.dep = dep;\r\ndwc->ep0_usb_req.request.length = sizeof(*response_pkt);\r\ndwc->ep0_usb_req.request.buf = dwc->setup_buf;\r\ndwc->ep0_usb_req.request.complete = dwc3_ep0_status_cmpl;\r\nreturn __dwc3_gadget_ep0_queue(dep, &dwc->ep0_usb_req);\r\n}\r\nstatic int dwc3_ep0_handle_feature(struct dwc3 *dwc,\r\nstruct usb_ctrlrequest *ctrl, int set)\r\n{\r\nstruct dwc3_ep *dep;\r\nu32 recip;\r\nu32 wValue;\r\nu32 wIndex;\r\nu32 reg;\r\nint ret;\r\nenum usb_device_state state;\r\nwValue = le16_to_cpu(ctrl->wValue);\r\nwIndex = le16_to_cpu(ctrl->wIndex);\r\nrecip = ctrl->bRequestType & USB_RECIP_MASK;\r\nstate = dwc->gadget.state;\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nswitch (wValue) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\nif (state != USB_STATE_CONFIGURED)\r\nreturn -EINVAL;\r\nif (dwc->speed != DWC3_DSTS_SUPERSPEED)\r\nreturn -EINVAL;\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nif (set)\r\nreg |= DWC3_DCTL_INITU1ENA;\r\nelse\r\nreg &= ~DWC3_DCTL_INITU1ENA;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\nbreak;\r\ncase USB_DEVICE_U2_ENABLE:\r\nif (state != USB_STATE_CONFIGURED)\r\nreturn -EINVAL;\r\nif (dwc->speed != DWC3_DSTS_SUPERSPEED)\r\nreturn -EINVAL;\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nif (set)\r\nreg |= DWC3_DCTL_INITU2ENA;\r\nelse\r\nreg &= ~DWC3_DCTL_INITU2ENA;\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\nbreak;\r\ncase USB_DEVICE_LTM_ENABLE:\r\nreturn -EINVAL;\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\nif ((wIndex & 0xff) != 0)\r\nreturn -EINVAL;\r\nif (!set)\r\nreturn -EINVAL;\r\ndwc->test_mode_nr = wIndex >> 8;\r\ndwc->test_mode = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nswitch (wValue) {\r\ncase USB_INTRF_FUNC_SUSPEND:\r\nif (wIndex & USB_INTRF_FUNC_SUSPEND_LP)\r\n;\r\nif (wIndex & USB_INTRF_FUNC_SUSPEND_RW)\r\n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nswitch (wValue) {\r\ncase USB_ENDPOINT_HALT:\r\ndep = dwc3_wIndex_to_dep(dwc, wIndex);\r\nif (!dep)\r\nreturn -EINVAL;\r\nret = __dwc3_gadget_ep_set_halt(dep, set);\r\nif (ret)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nstatic int dwc3_ep0_set_address(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\r\n{\r\nenum usb_device_state state = dwc->gadget.state;\r\nu32 addr;\r\nu32 reg;\r\naddr = le16_to_cpu(ctrl->wValue);\r\nif (addr > 127) {\r\ndev_dbg(dwc->dev, "invalid device address %d\n", addr);\r\nreturn -EINVAL;\r\n}\r\nif (state == USB_STATE_CONFIGURED) {\r\ndev_dbg(dwc->dev, "trying to set address when configured\n");\r\nreturn -EINVAL;\r\n}\r\nreg = dwc3_readl(dwc->regs, DWC3_DCFG);\r\nreg &= ~(DWC3_DCFG_DEVADDR_MASK);\r\nreg |= DWC3_DCFG_DEVADDR(addr);\r\ndwc3_writel(dwc->regs, DWC3_DCFG, reg);\r\nif (addr)\r\nusb_gadget_set_state(&dwc->gadget, USB_STATE_ADDRESS);\r\nelse\r\nusb_gadget_set_state(&dwc->gadget, USB_STATE_DEFAULT);\r\nreturn 0;\r\n}\r\nstatic int dwc3_ep0_delegate_req(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\r\n{\r\nint ret;\r\nspin_unlock(&dwc->lock);\r\nret = dwc->gadget_driver->setup(&dwc->gadget, ctrl);\r\nspin_lock(&dwc->lock);\r\nreturn ret;\r\n}\r\nstatic int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\r\n{\r\nenum usb_device_state state = dwc->gadget.state;\r\nu32 cfg;\r\nint ret;\r\nu32 reg;\r\ndwc->start_config_issued = false;\r\ncfg = le16_to_cpu(ctrl->wValue);\r\nswitch (state) {\r\ncase USB_STATE_DEFAULT:\r\nreturn -EINVAL;\r\nbreak;\r\ncase USB_STATE_ADDRESS:\r\nret = dwc3_ep0_delegate_req(dwc, ctrl);\r\nif (cfg && (!ret || (ret == USB_GADGET_DELAYED_STATUS))) {\r\nusb_gadget_set_state(&dwc->gadget,\r\nUSB_STATE_CONFIGURED);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nreg |= (DWC3_DCTL_ACCEPTU1ENA | DWC3_DCTL_ACCEPTU2ENA);\r\ndwc3_writel(dwc->regs, DWC3_DCTL, reg);\r\ndwc->resize_fifos = true;\r\ndev_dbg(dwc->dev, "resize fifos flag SET\n");\r\n}\r\nbreak;\r\ncase USB_STATE_CONFIGURED:\r\nret = dwc3_ep0_delegate_req(dwc, ctrl);\r\nif (!cfg)\r\nusb_gadget_set_state(&dwc->gadget,\r\nUSB_STATE_ADDRESS);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dwc3_ep0_set_sel_cmpl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct dwc3_ep *dep = to_dwc3_ep(ep);\r\nstruct dwc3 *dwc = dep->dwc;\r\nu32 param = 0;\r\nu32 reg;\r\nstruct timing {\r\nu8 u1sel;\r\nu8 u1pel;\r\nu16 u2sel;\r\nu16 u2pel;\r\n} __packed timing;\r\nint ret;\r\nmemcpy(&timing, req->buf, sizeof(timing));\r\ndwc->u1sel = timing.u1sel;\r\ndwc->u1pel = timing.u1pel;\r\ndwc->u2sel = le16_to_cpu(timing.u2sel);\r\ndwc->u2pel = le16_to_cpu(timing.u2pel);\r\nreg = dwc3_readl(dwc->regs, DWC3_DCTL);\r\nif (reg & DWC3_DCTL_INITU2ENA)\r\nparam = dwc->u2pel;\r\nif (reg & DWC3_DCTL_INITU1ENA)\r\nparam = dwc->u1pel;\r\nif (param > 125)\r\nparam = 0;\r\nret = dwc3_send_gadget_generic_command(dwc,\r\nDWC3_DGCMD_SET_PERIODIC_PAR, param);\r\nWARN_ON(ret < 0);\r\n}\r\nstatic int dwc3_ep0_set_sel(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct dwc3_ep *dep;\r\nenum usb_device_state state = dwc->gadget.state;\r\nu16 wLength;\r\nu16 wValue;\r\nif (state == USB_STATE_DEFAULT)\r\nreturn -EINVAL;\r\nwValue = le16_to_cpu(ctrl->wValue);\r\nwLength = le16_to_cpu(ctrl->wLength);\r\nif (wLength != 6) {\r\ndev_err(dwc->dev, "Set SEL should be 6 bytes, got %d\n",\r\nwLength);\r\nreturn -EINVAL;\r\n}\r\ndep = dwc->eps[0];\r\ndwc->ep0_usb_req.dep = dep;\r\ndwc->ep0_usb_req.request.length = dep->endpoint.maxpacket;\r\ndwc->ep0_usb_req.request.buf = dwc->setup_buf;\r\ndwc->ep0_usb_req.request.complete = dwc3_ep0_set_sel_cmpl;\r\nreturn __dwc3_gadget_ep0_queue(dep, &dwc->ep0_usb_req);\r\n}\r\nstatic int dwc3_ep0_set_isoch_delay(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\r\n{\r\nu16 wLength;\r\nu16 wValue;\r\nu16 wIndex;\r\nwValue = le16_to_cpu(ctrl->wValue);\r\nwLength = le16_to_cpu(ctrl->wLength);\r\nwIndex = le16_to_cpu(ctrl->wIndex);\r\nif (wIndex || wLength)\r\nreturn -EINVAL;\r\ndwc->isoch_delay = wValue;\r\nreturn 0;\r\n}\r\nstatic int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\r\n{\r\nint ret;\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\ndev_vdbg(dwc->dev, "USB_REQ_GET_STATUS\n");\r\nret = dwc3_ep0_handle_status(dwc, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ndev_vdbg(dwc->dev, "USB_REQ_CLEAR_FEATURE\n");\r\nret = dwc3_ep0_handle_feature(dwc, ctrl, 0);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\ndev_vdbg(dwc->dev, "USB_REQ_SET_FEATURE\n");\r\nret = dwc3_ep0_handle_feature(dwc, ctrl, 1);\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\ndev_vdbg(dwc->dev, "USB_REQ_SET_ADDRESS\n");\r\nret = dwc3_ep0_set_address(dwc, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\ndev_vdbg(dwc->dev, "USB_REQ_SET_CONFIGURATION\n");\r\nret = dwc3_ep0_set_config(dwc, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_SEL:\r\ndev_vdbg(dwc->dev, "USB_REQ_SET_SEL\n");\r\nret = dwc3_ep0_set_sel(dwc, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_ISOCH_DELAY:\r\ndev_vdbg(dwc->dev, "USB_REQ_SET_ISOCH_DELAY\n");\r\nret = dwc3_ep0_set_isoch_delay(dwc, ctrl);\r\nbreak;\r\ndefault:\r\ndev_vdbg(dwc->dev, "Forwarding to gadget driver\n");\r\nret = dwc3_ep0_delegate_req(dwc, ctrl);\r\nbreak;\r\n};\r\nreturn ret;\r\n}\r\nstatic void dwc3_ep0_inspect_setup(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nstruct usb_ctrlrequest *ctrl = dwc->ctrl_req;\r\nint ret = -EINVAL;\r\nu32 len;\r\nif (!dwc->gadget_driver)\r\ngoto out;\r\nlen = le16_to_cpu(ctrl->wLength);\r\nif (!len) {\r\ndwc->three_stage_setup = false;\r\ndwc->ep0_expect_in = false;\r\ndwc->ep0_next_event = DWC3_EP0_NRDY_STATUS;\r\n} else {\r\ndwc->three_stage_setup = true;\r\ndwc->ep0_expect_in = !!(ctrl->bRequestType & USB_DIR_IN);\r\ndwc->ep0_next_event = DWC3_EP0_NRDY_DATA;\r\n}\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\r\nret = dwc3_ep0_std_request(dwc, ctrl);\r\nelse\r\nret = dwc3_ep0_delegate_req(dwc, ctrl);\r\nif (ret == USB_GADGET_DELAYED_STATUS)\r\ndwc->delayed_status = true;\r\nout:\r\nif (ret < 0)\r\ndwc3_ep0_stall_and_restart(dwc);\r\n}\r\nstatic void dwc3_ep0_complete_data(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nstruct dwc3_request *r = NULL;\r\nstruct usb_request *ur;\r\nstruct dwc3_trb *trb;\r\nstruct dwc3_ep *ep0;\r\nu32 transferred;\r\nu32 status;\r\nu32 length;\r\nu8 epnum;\r\nepnum = event->endpoint_number;\r\nep0 = dwc->eps[0];\r\ndwc->ep0_next_event = DWC3_EP0_NRDY_STATUS;\r\nr = next_request(&ep0->request_list);\r\nur = &r->request;\r\ntrb = dwc->ep0_trb;\r\nstatus = DWC3_TRB_SIZE_TRBSTS(trb->size);\r\nif (status == DWC3_TRBSTS_SETUP_PENDING) {\r\ndev_dbg(dwc->dev, "Setup Pending received\n");\r\nif (r)\r\ndwc3_gadget_giveback(ep0, r, -ECONNRESET);\r\nreturn;\r\n}\r\nlength = trb->size & DWC3_TRB_SIZE_MASK;\r\nif (dwc->ep0_bounced) {\r\nunsigned transfer_size = ur->length;\r\nunsigned maxp = ep0->endpoint.maxpacket;\r\ntransfer_size += (maxp - (transfer_size % maxp));\r\ntransferred = min_t(u32, ur->length,\r\ntransfer_size - length);\r\nmemcpy(ur->buf, dwc->ep0_bounce, transferred);\r\n} else {\r\ntransferred = ur->length - length;\r\n}\r\nur->actual += transferred;\r\nif ((epnum & 1) && ur->actual < ur->length) {\r\ndwc3_ep0_stall_and_restart(dwc);\r\n} else {\r\nif (r)\r\ndwc3_gadget_giveback(ep0, r, 0);\r\n}\r\n}\r\nstatic void dwc3_ep0_complete_status(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nstruct dwc3_request *r;\r\nstruct dwc3_ep *dep;\r\nstruct dwc3_trb *trb;\r\nu32 status;\r\ndep = dwc->eps[0];\r\ntrb = dwc->ep0_trb;\r\nif (!list_empty(&dep->request_list)) {\r\nr = next_request(&dep->request_list);\r\ndwc3_gadget_giveback(dep, r, 0);\r\n}\r\nif (dwc->test_mode) {\r\nint ret;\r\nret = dwc3_gadget_set_test_mode(dwc, dwc->test_mode_nr);\r\nif (ret < 0) {\r\ndev_dbg(dwc->dev, "Invalid Test #%d\n",\r\ndwc->test_mode_nr);\r\ndwc3_ep0_stall_and_restart(dwc);\r\nreturn;\r\n}\r\n}\r\nstatus = DWC3_TRB_SIZE_TRBSTS(trb->size);\r\nif (status == DWC3_TRBSTS_SETUP_PENDING)\r\ndev_dbg(dwc->dev, "Setup Pending received\n");\r\ndwc->ep0state = EP0_SETUP_PHASE;\r\ndwc3_ep0_out_start(dwc);\r\n}\r\nstatic void dwc3_ep0_xfer_complete(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nstruct dwc3_ep *dep = dwc->eps[event->endpoint_number];\r\ndep->flags &= ~DWC3_EP_BUSY;\r\ndep->resource_index = 0;\r\ndwc->setup_packet_pending = false;\r\nswitch (dwc->ep0state) {\r\ncase EP0_SETUP_PHASE:\r\ndev_vdbg(dwc->dev, "Inspecting Setup Bytes\n");\r\ndwc3_ep0_inspect_setup(dwc, event);\r\nbreak;\r\ncase EP0_DATA_PHASE:\r\ndev_vdbg(dwc->dev, "Data Phase\n");\r\ndwc3_ep0_complete_data(dwc, event);\r\nbreak;\r\ncase EP0_STATUS_PHASE:\r\ndev_vdbg(dwc->dev, "Status Phase\n");\r\ndwc3_ep0_complete_status(dwc, event);\r\nbreak;\r\ndefault:\r\nWARN(true, "UNKNOWN ep0state %d\n", dwc->ep0state);\r\n}\r\n}\r\nstatic void __dwc3_ep0_do_control_data(struct dwc3 *dwc,\r\nstruct dwc3_ep *dep, struct dwc3_request *req)\r\n{\r\nint ret;\r\nreq->direction = !!dep->number;\r\nif (req->request.length == 0) {\r\nret = dwc3_ep0_start_trans(dwc, dep->number,\r\ndwc->ctrl_req_addr, 0,\r\nDWC3_TRBCTL_CONTROL_DATA);\r\n} else if (!IS_ALIGNED(req->request.length, dep->endpoint.maxpacket)\r\n&& (dep->number == 0)) {\r\nu32 transfer_size;\r\nu32 maxpacket;\r\nret = usb_gadget_map_request(&dwc->gadget, &req->request,\r\ndep->number);\r\nif (ret) {\r\ndev_dbg(dwc->dev, "failed to map request\n");\r\nreturn;\r\n}\r\nWARN_ON(req->request.length > DWC3_EP0_BOUNCE_SIZE);\r\nmaxpacket = dep->endpoint.maxpacket;\r\ntransfer_size = roundup(req->request.length, maxpacket);\r\ndwc->ep0_bounced = true;\r\nret = dwc3_ep0_start_trans(dwc, dep->number,\r\ndwc->ep0_bounce_addr, transfer_size,\r\nDWC3_TRBCTL_CONTROL_DATA);\r\n} else {\r\nret = usb_gadget_map_request(&dwc->gadget, &req->request,\r\ndep->number);\r\nif (ret) {\r\ndev_dbg(dwc->dev, "failed to map request\n");\r\nreturn;\r\n}\r\nret = dwc3_ep0_start_trans(dwc, dep->number, req->request.dma,\r\nreq->request.length, DWC3_TRBCTL_CONTROL_DATA);\r\n}\r\nWARN_ON(ret < 0);\r\n}\r\nstatic int dwc3_ep0_start_control_status(struct dwc3_ep *dep)\r\n{\r\nstruct dwc3 *dwc = dep->dwc;\r\nu32 type;\r\ntype = dwc->three_stage_setup ? DWC3_TRBCTL_CONTROL_STATUS3\r\n: DWC3_TRBCTL_CONTROL_STATUS2;\r\nreturn dwc3_ep0_start_trans(dwc, dep->number,\r\ndwc->ctrl_req_addr, 0, type);\r\n}\r\nstatic void __dwc3_ep0_do_control_status(struct dwc3 *dwc, struct dwc3_ep *dep)\r\n{\r\nif (dwc->resize_fifos) {\r\ndev_dbg(dwc->dev, "starting to resize fifos\n");\r\ndwc3_gadget_resize_tx_fifos(dwc);\r\ndwc->resize_fifos = 0;\r\n}\r\nWARN_ON(dwc3_ep0_start_control_status(dep));\r\n}\r\nstatic void dwc3_ep0_do_control_status(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nstruct dwc3_ep *dep = dwc->eps[event->endpoint_number];\r\n__dwc3_ep0_do_control_status(dwc, dep);\r\n}\r\nstatic void dwc3_ep0_end_control_data(struct dwc3 *dwc, struct dwc3_ep *dep)\r\n{\r\nstruct dwc3_gadget_ep_cmd_params params;\r\nu32 cmd;\r\nint ret;\r\nif (!dep->resource_index)\r\nreturn;\r\ncmd = DWC3_DEPCMD_ENDTRANSFER;\r\ncmd |= DWC3_DEPCMD_CMDIOC;\r\ncmd |= DWC3_DEPCMD_PARAM(dep->resource_index);\r\nmemset(&params, 0, sizeof(params));\r\nret = dwc3_send_gadget_ep_cmd(dwc, dep->number, cmd, &params);\r\nWARN_ON_ONCE(ret);\r\ndep->resource_index = 0;\r\n}\r\nstatic void dwc3_ep0_xfernotready(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\ndwc->setup_packet_pending = true;\r\nswitch (event->status) {\r\ncase DEPEVT_STATUS_CONTROL_DATA:\r\ndev_vdbg(dwc->dev, "Control Data\n");\r\nif (dwc->ep0_expect_in != event->endpoint_number) {\r\nstruct dwc3_ep *dep = dwc->eps[dwc->ep0_expect_in];\r\ndev_vdbg(dwc->dev, "Wrong direction for Data phase\n");\r\ndwc3_ep0_end_control_data(dwc, dep);\r\ndwc3_ep0_stall_and_restart(dwc);\r\nreturn;\r\n}\r\nbreak;\r\ncase DEPEVT_STATUS_CONTROL_STATUS:\r\nif (dwc->ep0_next_event != DWC3_EP0_NRDY_STATUS)\r\nreturn;\r\ndev_vdbg(dwc->dev, "Control Status\n");\r\ndwc->ep0state = EP0_STATUS_PHASE;\r\nif (dwc->delayed_status) {\r\nWARN_ON_ONCE(event->endpoint_number != 1);\r\ndev_vdbg(dwc->dev, "Mass Storage delayed status\n");\r\nreturn;\r\n}\r\ndwc3_ep0_do_control_status(dwc, event);\r\n}\r\n}\r\nvoid dwc3_ep0_interrupt(struct dwc3 *dwc,\r\nconst struct dwc3_event_depevt *event)\r\n{\r\nu8 epnum = event->endpoint_number;\r\ndev_dbg(dwc->dev, "%s while ep%d%s in state '%s'\n",\r\ndwc3_ep_event_string(event->endpoint_event),\r\nepnum >> 1, (epnum & 1) ? "in" : "out",\r\ndwc3_ep0_state_string(dwc->ep0state));\r\nswitch (event->endpoint_event) {\r\ncase DWC3_DEPEVT_XFERCOMPLETE:\r\ndwc3_ep0_xfer_complete(dwc, event);\r\nbreak;\r\ncase DWC3_DEPEVT_XFERNOTREADY:\r\ndwc3_ep0_xfernotready(dwc, event);\r\nbreak;\r\ncase DWC3_DEPEVT_XFERINPROGRESS:\r\ncase DWC3_DEPEVT_RXTXFIFOEVT:\r\ncase DWC3_DEPEVT_STREAMEVT:\r\ncase DWC3_DEPEVT_EPCMDCMPLT:\r\nbreak;\r\n}\r\n}
