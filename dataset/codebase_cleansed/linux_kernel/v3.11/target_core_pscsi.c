static inline struct pscsi_dev_virt *PSCSI_DEV(struct se_device *dev)\r\n{\r\nreturn container_of(dev, struct pscsi_dev_virt, dev);\r\n}\r\nstatic int pscsi_attach_hba(struct se_hba *hba, u32 host_id)\r\n{\r\nstruct pscsi_hba_virt *phv;\r\nphv = kzalloc(sizeof(struct pscsi_hba_virt), GFP_KERNEL);\r\nif (!phv) {\r\npr_err("Unable to allocate struct pscsi_hba_virt\n");\r\nreturn -ENOMEM;\r\n}\r\nphv->phv_host_id = host_id;\r\nphv->phv_mode = PHV_VIRTUAL_HOST_ID;\r\nhba->hba_ptr = phv;\r\npr_debug("CORE_HBA[%d] - TCM SCSI HBA Driver %s on"\r\n" Generic Target Core Stack %s\n", hba->hba_id,\r\nPSCSI_VERSION, TARGET_CORE_MOD_VERSION);\r\npr_debug("CORE_HBA[%d] - Attached SCSI HBA to Generic\n",\r\nhba->hba_id);\r\nreturn 0;\r\n}\r\nstatic void pscsi_detach_hba(struct se_hba *hba)\r\n{\r\nstruct pscsi_hba_virt *phv = hba->hba_ptr;\r\nstruct Scsi_Host *scsi_host = phv->phv_lld_host;\r\nif (scsi_host) {\r\nscsi_host_put(scsi_host);\r\npr_debug("CORE_HBA[%d] - Detached SCSI HBA: %s from"\r\n" Generic Target Core\n", hba->hba_id,\r\n(scsi_host->hostt->name) ? (scsi_host->hostt->name) :\r\n"Unknown");\r\n} else\r\npr_debug("CORE_HBA[%d] - Detached Virtual SCSI HBA"\r\n" from Generic Target Core\n", hba->hba_id);\r\nkfree(phv);\r\nhba->hba_ptr = NULL;\r\n}\r\nstatic int pscsi_pmode_enable_hba(struct se_hba *hba, unsigned long mode_flag)\r\n{\r\nstruct pscsi_hba_virt *phv = hba->hba_ptr;\r\nstruct Scsi_Host *sh = phv->phv_lld_host;\r\nif (!mode_flag) {\r\nif (!sh)\r\nreturn 0;\r\nphv->phv_lld_host = NULL;\r\nphv->phv_mode = PHV_VIRTUAL_HOST_ID;\r\npr_debug("CORE_HBA[%d] - Disabled pSCSI HBA Passthrough"\r\n" %s\n", hba->hba_id, (sh->hostt->name) ?\r\n(sh->hostt->name) : "Unknown");\r\nscsi_host_put(sh);\r\nreturn 0;\r\n}\r\nsh = scsi_host_lookup(phv->phv_host_id);\r\nif (IS_ERR(sh)) {\r\npr_err("pSCSI: Unable to locate SCSI Host for"\r\n" phv_host_id: %d\n", phv->phv_host_id);\r\nreturn PTR_ERR(sh);\r\n}\r\nphv->phv_lld_host = sh;\r\nphv->phv_mode = PHV_LLD_SCSI_HOST_NO;\r\npr_debug("CORE_HBA[%d] - Enabled pSCSI HBA Passthrough %s\n",\r\nhba->hba_id, (sh->hostt->name) ? (sh->hostt->name) : "Unknown");\r\nreturn 1;\r\n}\r\nstatic void pscsi_tape_read_blocksize(struct se_device *dev,\r\nstruct scsi_device *sdev)\r\n{\r\nunsigned char cdb[MAX_COMMAND_SIZE], *buf;\r\nint ret;\r\nbuf = kzalloc(12, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nmemset(cdb, 0, MAX_COMMAND_SIZE);\r\ncdb[0] = MODE_SENSE;\r\ncdb[4] = 0x0c;\r\nret = scsi_execute_req(sdev, cdb, DMA_FROM_DEVICE, buf, 12, NULL,\r\nHZ, 1, NULL);\r\nif (ret)\r\ngoto out_free;\r\nsdev->sector_size = (buf[9] << 16) | (buf[10] << 8) | (buf[11]);\r\nif (!sdev->sector_size)\r\nsdev->sector_size = 1024;\r\nout_free:\r\nkfree(buf);\r\n}\r\nstatic void\r\npscsi_set_inquiry_info(struct scsi_device *sdev, struct t10_wwn *wwn)\r\n{\r\nunsigned char *buf;\r\nif (sdev->inquiry_len < INQUIRY_LEN)\r\nreturn;\r\nbuf = sdev->inquiry;\r\nif (!buf)\r\nreturn;\r\nmemcpy(&wwn->vendor[0], &buf[8], sizeof(wwn->vendor));\r\nmemcpy(&wwn->model[0], &buf[16], sizeof(wwn->model));\r\nmemcpy(&wwn->revision[0], &buf[32], sizeof(wwn->revision));\r\n}\r\nstatic int\r\npscsi_get_inquiry_vpd_serial(struct scsi_device *sdev, struct t10_wwn *wwn)\r\n{\r\nunsigned char cdb[MAX_COMMAND_SIZE], *buf;\r\nint ret;\r\nbuf = kzalloc(INQUIRY_VPD_SERIAL_LEN, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmemset(cdb, 0, MAX_COMMAND_SIZE);\r\ncdb[0] = INQUIRY;\r\ncdb[1] = 0x01;\r\ncdb[2] = 0x80;\r\ncdb[3] = (INQUIRY_VPD_SERIAL_LEN >> 8) & 0xff;\r\ncdb[4] = (INQUIRY_VPD_SERIAL_LEN & 0xff);\r\nret = scsi_execute_req(sdev, cdb, DMA_FROM_DEVICE, buf,\r\nINQUIRY_VPD_SERIAL_LEN, NULL, HZ, 1, NULL);\r\nif (ret)\r\ngoto out_free;\r\nsnprintf(&wwn->unit_serial[0], INQUIRY_VPD_SERIAL_LEN, "%s", &buf[4]);\r\nwwn->t10_dev->dev_flags |= DF_FIRMWARE_VPD_UNIT_SERIAL;\r\nkfree(buf);\r\nreturn 0;\r\nout_free:\r\nkfree(buf);\r\nreturn -EPERM;\r\n}\r\nstatic void\r\npscsi_get_inquiry_vpd_device_ident(struct scsi_device *sdev,\r\nstruct t10_wwn *wwn)\r\n{\r\nunsigned char cdb[MAX_COMMAND_SIZE], *buf, *page_83;\r\nint ident_len, page_len, off = 4, ret;\r\nstruct t10_vpd *vpd;\r\nbuf = kzalloc(INQUIRY_VPD_SERIAL_LEN, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nmemset(cdb, 0, MAX_COMMAND_SIZE);\r\ncdb[0] = INQUIRY;\r\ncdb[1] = 0x01;\r\ncdb[2] = 0x83;\r\ncdb[3] = (INQUIRY_VPD_DEVICE_IDENTIFIER_LEN >> 8) & 0xff;\r\ncdb[4] = (INQUIRY_VPD_DEVICE_IDENTIFIER_LEN & 0xff);\r\nret = scsi_execute_req(sdev, cdb, DMA_FROM_DEVICE, buf,\r\nINQUIRY_VPD_DEVICE_IDENTIFIER_LEN,\r\nNULL, HZ, 1, NULL);\r\nif (ret)\r\ngoto out;\r\npage_len = (buf[2] << 8) | buf[3];\r\nwhile (page_len > 0) {\r\npage_83 = &buf[off];\r\nident_len = page_83[3];\r\nif (!ident_len) {\r\npr_err("page_83[3]: identifier"\r\n" length zero!\n");\r\nbreak;\r\n}\r\npr_debug("T10 VPD Identifier Length: %d\n", ident_len);\r\nvpd = kzalloc(sizeof(struct t10_vpd), GFP_KERNEL);\r\nif (!vpd) {\r\npr_err("Unable to allocate memory for"\r\n" struct t10_vpd\n");\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&vpd->vpd_list);\r\ntransport_set_vpd_proto_id(vpd, page_83);\r\ntransport_set_vpd_assoc(vpd, page_83);\r\nif (transport_set_vpd_ident_type(vpd, page_83) < 0) {\r\noff += (ident_len + 4);\r\npage_len -= (ident_len + 4);\r\nkfree(vpd);\r\ncontinue;\r\n}\r\nif (transport_set_vpd_ident(vpd, page_83) < 0) {\r\noff += (ident_len + 4);\r\npage_len -= (ident_len + 4);\r\nkfree(vpd);\r\ncontinue;\r\n}\r\nlist_add_tail(&vpd->vpd_list, &wwn->t10_vpd_list);\r\noff += (ident_len + 4);\r\npage_len -= (ident_len + 4);\r\n}\r\nout:\r\nkfree(buf);\r\n}\r\nstatic int pscsi_add_device_to_list(struct se_device *dev,\r\nstruct scsi_device *sd)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct request_queue *q = sd->request_queue;\r\npdv->pdv_sd = sd;\r\nif (!sd->queue_depth) {\r\nsd->queue_depth = PSCSI_DEFAULT_QUEUEDEPTH;\r\npr_err("Set broken SCSI Device %d:%d:%d"\r\n" queue_depth to %d\n", sd->channel, sd->id,\r\nsd->lun, sd->queue_depth);\r\n}\r\ndev->dev_attrib.hw_block_size = sd->sector_size;\r\ndev->dev_attrib.hw_max_sectors =\r\nmin_t(int, sd->host->max_sectors, queue_max_hw_sectors(q));\r\ndev->dev_attrib.hw_queue_depth = sd->queue_depth;\r\npscsi_set_inquiry_info(sd, &dev->t10_wwn);\r\nif (!pscsi_get_inquiry_vpd_serial(sd, &dev->t10_wwn)) {\r\npscsi_get_inquiry_vpd_device_ident(sd, &dev->t10_wwn);\r\n}\r\nif (sd->type == TYPE_TAPE)\r\npscsi_tape_read_blocksize(dev, sd);\r\nreturn 0;\r\n}\r\nstatic struct se_device *pscsi_alloc_device(struct se_hba *hba,\r\nconst char *name)\r\n{\r\nstruct pscsi_dev_virt *pdv;\r\npdv = kzalloc(sizeof(struct pscsi_dev_virt), GFP_KERNEL);\r\nif (!pdv) {\r\npr_err("Unable to allocate memory for struct pscsi_dev_virt\n");\r\nreturn NULL;\r\n}\r\npr_debug("PSCSI: Allocated pdv: %p for %s\n", pdv, name);\r\nreturn &pdv->dev;\r\n}\r\nstatic int pscsi_create_type_disk(struct se_device *dev, struct scsi_device *sd)\r\n__releases(sh->host_lock)\r\n{\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct Scsi_Host *sh = sd->host;\r\nstruct block_device *bd;\r\nint ret;\r\nif (scsi_device_get(sd)) {\r\npr_err("scsi_device_get() failed for %d:%d:%d:%d\n",\r\nsh->host_no, sd->channel, sd->id, sd->lun);\r\nspin_unlock_irq(sh->host_lock);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irq(sh->host_lock);\r\nbd = blkdev_get_by_path(dev->udev_path,\r\nFMODE_WRITE|FMODE_READ|FMODE_EXCL, pdv);\r\nif (IS_ERR(bd)) {\r\npr_err("pSCSI: blkdev_get_by_path() failed\n");\r\nscsi_device_put(sd);\r\nreturn PTR_ERR(bd);\r\n}\r\npdv->pdv_bd = bd;\r\nret = pscsi_add_device_to_list(dev, sd);\r\nif (ret) {\r\nblkdev_put(pdv->pdv_bd, FMODE_WRITE|FMODE_READ|FMODE_EXCL);\r\nscsi_device_put(sd);\r\nreturn ret;\r\n}\r\npr_debug("CORE_PSCSI[%d] - Added TYPE_DISK for %d:%d:%d:%d\n",\r\nphv->phv_host_id, sh->host_no, sd->channel, sd->id, sd->lun);\r\nreturn 0;\r\n}\r\nstatic int pscsi_create_type_rom(struct se_device *dev, struct scsi_device *sd)\r\n__releases(sh->host_lock)\r\n{\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nstruct Scsi_Host *sh = sd->host;\r\nint ret;\r\nif (scsi_device_get(sd)) {\r\npr_err("scsi_device_get() failed for %d:%d:%d:%d\n",\r\nsh->host_no, sd->channel, sd->id, sd->lun);\r\nspin_unlock_irq(sh->host_lock);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irq(sh->host_lock);\r\nret = pscsi_add_device_to_list(dev, sd);\r\nif (ret) {\r\nscsi_device_put(sd);\r\nreturn ret;\r\n}\r\npr_debug("CORE_PSCSI[%d] - Added Type: %s for %d:%d:%d:%d\n",\r\nphv->phv_host_id, scsi_device_type(sd->type), sh->host_no,\r\nsd->channel, sd->id, sd->lun);\r\nreturn 0;\r\n}\r\nstatic int pscsi_create_type_other(struct se_device *dev,\r\nstruct scsi_device *sd)\r\n__releases(sh->host_lock)\r\n{\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nstruct Scsi_Host *sh = sd->host;\r\nint ret;\r\nspin_unlock_irq(sh->host_lock);\r\nret = pscsi_add_device_to_list(dev, sd);\r\nif (ret)\r\nreturn ret;\r\npr_debug("CORE_PSCSI[%d] - Added Type: %s for %d:%d:%d:%d\n",\r\nphv->phv_host_id, scsi_device_type(sd->type), sh->host_no,\r\nsd->channel, sd->id, sd->lun);\r\nreturn 0;\r\n}\r\nstatic int pscsi_configure_device(struct se_device *dev)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct scsi_device *sd;\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nstruct Scsi_Host *sh = phv->phv_lld_host;\r\nint legacy_mode_enable = 0;\r\nint ret;\r\nif (!(pdv->pdv_flags & PDF_HAS_CHANNEL_ID) ||\r\n!(pdv->pdv_flags & PDF_HAS_TARGET_ID) ||\r\n!(pdv->pdv_flags & PDF_HAS_LUN_ID)) {\r\npr_err("Missing scsi_channel_id=, scsi_target_id= and"\r\n" scsi_lun_id= parameters\n");\r\nreturn -EINVAL;\r\n}\r\nif (!sh) {\r\nif (phv->phv_mode == PHV_LLD_SCSI_HOST_NO) {\r\npr_err("pSCSI: Unable to locate struct"\r\n" Scsi_Host for PHV_LLD_SCSI_HOST_NO\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(dev->dev_flags & DF_USING_UDEV_PATH)) {\r\npr_err("pSCSI: udev_path attribute has not"\r\n" been set before ENABLE=1\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(pdv->pdv_flags & PDF_HAS_VIRT_HOST_ID)) {\r\nif (hba->dev_count) {\r\npr_err("pSCSI: Unable to set hba_mode"\r\n" with active devices\n");\r\nreturn -EEXIST;\r\n}\r\nif (pscsi_pmode_enable_hba(hba, 1) != 1)\r\nreturn -ENODEV;\r\nlegacy_mode_enable = 1;\r\nhba->hba_flags |= HBA_FLAGS_PSCSI_MODE;\r\nsh = phv->phv_lld_host;\r\n} else {\r\nsh = scsi_host_lookup(pdv->pdv_host_id);\r\nif (IS_ERR(sh)) {\r\npr_err("pSCSI: Unable to locate"\r\n" pdv_host_id: %d\n", pdv->pdv_host_id);\r\nreturn PTR_ERR(sh);\r\n}\r\n}\r\n} else {\r\nif (phv->phv_mode == PHV_VIRTUAL_HOST_ID) {\r\npr_err("pSCSI: PHV_VIRTUAL_HOST_ID set while"\r\n" struct Scsi_Host exists\n");\r\nreturn -EEXIST;\r\n}\r\n}\r\nspin_lock_irq(sh->host_lock);\r\nlist_for_each_entry(sd, &sh->__devices, siblings) {\r\nif ((pdv->pdv_channel_id != sd->channel) ||\r\n(pdv->pdv_target_id != sd->id) ||\r\n(pdv->pdv_lun_id != sd->lun))\r\ncontinue;\r\nswitch (sd->type) {\r\ncase TYPE_DISK:\r\nret = pscsi_create_type_disk(dev, sd);\r\nbreak;\r\ncase TYPE_ROM:\r\nret = pscsi_create_type_rom(dev, sd);\r\nbreak;\r\ndefault:\r\nret = pscsi_create_type_other(dev, sd);\r\nbreak;\r\n}\r\nif (ret) {\r\nif (phv->phv_mode == PHV_VIRTUAL_HOST_ID)\r\nscsi_host_put(sh);\r\nelse if (legacy_mode_enable) {\r\npscsi_pmode_enable_hba(hba, 0);\r\nhba->hba_flags &= ~HBA_FLAGS_PSCSI_MODE;\r\n}\r\npdv->pdv_sd = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nspin_unlock_irq(sh->host_lock);\r\npr_err("pSCSI: Unable to locate %d:%d:%d:%d\n", sh->host_no,\r\npdv->pdv_channel_id, pdv->pdv_target_id, pdv->pdv_lun_id);\r\nif (phv->phv_mode == PHV_VIRTUAL_HOST_ID)\r\nscsi_host_put(sh);\r\nelse if (legacy_mode_enable) {\r\npscsi_pmode_enable_hba(hba, 0);\r\nhba->hba_flags &= ~HBA_FLAGS_PSCSI_MODE;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void pscsi_free_device(struct se_device *dev)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nstruct scsi_device *sd = pdv->pdv_sd;\r\nif (sd) {\r\nif ((sd->type == TYPE_DISK) && pdv->pdv_bd) {\r\nblkdev_put(pdv->pdv_bd,\r\nFMODE_WRITE|FMODE_READ|FMODE_EXCL);\r\npdv->pdv_bd = NULL;\r\n}\r\nif ((phv->phv_mode == PHV_LLD_SCSI_HOST_NO) &&\r\n(phv->phv_lld_host != NULL))\r\nscsi_host_put(phv->phv_lld_host);\r\nif ((sd->type == TYPE_DISK) || (sd->type == TYPE_ROM))\r\nscsi_device_put(sd);\r\npdv->pdv_sd = NULL;\r\n}\r\nkfree(pdv);\r\n}\r\nstatic void pscsi_transport_complete(struct se_cmd *cmd, struct scatterlist *sg,\r\nunsigned char *sense_buffer)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(cmd->se_dev);\r\nstruct scsi_device *sd = pdv->pdv_sd;\r\nint result;\r\nstruct pscsi_plugin_task *pt = cmd->priv;\r\nunsigned char *cdb;\r\nif (!pt)\r\nreturn;\r\ncdb = &pt->pscsi_cdb[0];\r\nresult = pt->pscsi_result;\r\nif (!cmd->se_deve || !cmd->data_length)\r\ngoto after_mode_sense;\r\nif (((cdb[0] == MODE_SENSE) || (cdb[0] == MODE_SENSE_10)) &&\r\n(status_byte(result) << 1) == SAM_STAT_GOOD) {\r\nif (cmd->se_deve->lun_flags & TRANSPORT_LUNFLAGS_READ_ONLY) {\r\nunsigned char *buf;\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\n;\r\nif (cdb[0] == MODE_SENSE_10) {\r\nif (!(buf[3] & 0x80))\r\nbuf[3] |= 0x80;\r\n} else {\r\nif (!(buf[2] & 0x80))\r\nbuf[2] |= 0x80;\r\n}\r\ntransport_kunmap_data_sg(cmd);\r\n}\r\n}\r\nafter_mode_sense:\r\nif (sd->type != TYPE_TAPE || !cmd->data_length)\r\ngoto after_mode_select;\r\nif (((cdb[0] == MODE_SELECT) || (cdb[0] == MODE_SELECT_10)) &&\r\n(status_byte(result) << 1) == SAM_STAT_GOOD) {\r\nunsigned char *buf;\r\nu16 bdl;\r\nu32 blocksize;\r\nbuf = sg_virt(&sg[0]);\r\nif (!buf) {\r\npr_err("Unable to get buf for scatterlist\n");\r\ngoto after_mode_select;\r\n}\r\nif (cdb[0] == MODE_SELECT)\r\nbdl = (buf[3]);\r\nelse\r\nbdl = (buf[6] << 8) | (buf[7]);\r\nif (!bdl)\r\ngoto after_mode_select;\r\nif (cdb[0] == MODE_SELECT)\r\nblocksize = (buf[9] << 16) | (buf[10] << 8) |\r\n(buf[11]);\r\nelse\r\nblocksize = (buf[13] << 16) | (buf[14] << 8) |\r\n(buf[15]);\r\nsd->sector_size = blocksize;\r\n}\r\nafter_mode_select:\r\nif (sense_buffer && (status_byte(result) & CHECK_CONDITION)) {\r\nmemcpy(sense_buffer, pt->pscsi_sense, TRANSPORT_SENSE_BUFFER);\r\ncmd->se_cmd_flags |= SCF_TRANSPORT_TASK_SENSE;\r\n}\r\n}\r\nstatic ssize_t pscsi_set_configfs_dev_params(struct se_device *dev,\r\nconst char *page, ssize_t count)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nchar *orig, *ptr, *opts;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint ret = 0, arg, token;\r\nopts = kstrdup(page, GFP_KERNEL);\r\nif (!opts)\r\nreturn -ENOMEM;\r\norig = opts;\r\nwhile ((ptr = strsep(&opts, ",\n")) != NULL) {\r\nif (!*ptr)\r\ncontinue;\r\ntoken = match_token(ptr, tokens, args);\r\nswitch (token) {\r\ncase Opt_scsi_host_id:\r\nif (phv->phv_mode == PHV_LLD_SCSI_HOST_NO) {\r\npr_err("PSCSI[%d]: Unable to accept"\r\n" scsi_host_id while phv_mode =="\r\n" PHV_LLD_SCSI_HOST_NO\n",\r\nphv->phv_host_id);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmatch_int(args, &arg);\r\npdv->pdv_host_id = arg;\r\npr_debug("PSCSI[%d]: Referencing SCSI Host ID:"\r\n" %d\n", phv->phv_host_id, pdv->pdv_host_id);\r\npdv->pdv_flags |= PDF_HAS_VIRT_HOST_ID;\r\nbreak;\r\ncase Opt_scsi_channel_id:\r\nmatch_int(args, &arg);\r\npdv->pdv_channel_id = arg;\r\npr_debug("PSCSI[%d]: Referencing SCSI Channel"\r\n" ID: %d\n", phv->phv_host_id,\r\npdv->pdv_channel_id);\r\npdv->pdv_flags |= PDF_HAS_CHANNEL_ID;\r\nbreak;\r\ncase Opt_scsi_target_id:\r\nmatch_int(args, &arg);\r\npdv->pdv_target_id = arg;\r\npr_debug("PSCSI[%d]: Referencing SCSI Target"\r\n" ID: %d\n", phv->phv_host_id,\r\npdv->pdv_target_id);\r\npdv->pdv_flags |= PDF_HAS_TARGET_ID;\r\nbreak;\r\ncase Opt_scsi_lun_id:\r\nmatch_int(args, &arg);\r\npdv->pdv_lun_id = arg;\r\npr_debug("PSCSI[%d]: Referencing SCSI LUN ID:"\r\n" %d\n", phv->phv_host_id, pdv->pdv_lun_id);\r\npdv->pdv_flags |= PDF_HAS_LUN_ID;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nout:\r\nkfree(orig);\r\nreturn (!ret) ? count : ret;\r\n}\r\nstatic ssize_t pscsi_show_configfs_dev_params(struct se_device *dev, char *b)\r\n{\r\nstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct scsi_device *sd = pdv->pdv_sd;\r\nunsigned char host_id[16];\r\nssize_t bl;\r\nint i;\r\nif (phv->phv_mode == PHV_VIRTUAL_HOST_ID)\r\nsnprintf(host_id, 16, "%d", pdv->pdv_host_id);\r\nelse\r\nsnprintf(host_id, 16, "PHBA Mode");\r\nbl = sprintf(b, "SCSI Device Bus Location:"\r\n" Channel ID: %d Target ID: %d LUN: %d Host ID: %s\n",\r\npdv->pdv_channel_id, pdv->pdv_target_id, pdv->pdv_lun_id,\r\nhost_id);\r\nif (sd) {\r\nbl += sprintf(b + bl, " ");\r\nbl += sprintf(b + bl, "Vendor: ");\r\nfor (i = 0; i < 8; i++) {\r\nif (ISPRINT(sd->vendor[i]))\r\nbl += sprintf(b + bl, "%c", sd->vendor[i]);\r\nelse\r\nbl += sprintf(b + bl, " ");\r\n}\r\nbl += sprintf(b + bl, " Model: ");\r\nfor (i = 0; i < 16; i++) {\r\nif (ISPRINT(sd->model[i]))\r\nbl += sprintf(b + bl, "%c", sd->model[i]);\r\nelse\r\nbl += sprintf(b + bl, " ");\r\n}\r\nbl += sprintf(b + bl, " Rev: ");\r\nfor (i = 0; i < 4; i++) {\r\nif (ISPRINT(sd->rev[i]))\r\nbl += sprintf(b + bl, "%c", sd->rev[i]);\r\nelse\r\nbl += sprintf(b + bl, " ");\r\n}\r\nbl += sprintf(b + bl, "\n");\r\n}\r\nreturn bl;\r\n}\r\nstatic void pscsi_bi_endio(struct bio *bio, int error)\r\n{\r\nbio_put(bio);\r\n}\r\nstatic inline struct bio *pscsi_get_bio(int nr_vecs)\r\n{\r\nstruct bio *bio;\r\nbio = bio_kmalloc(GFP_KERNEL, nr_vecs);\r\nif (!bio) {\r\npr_err("PSCSI: bio_kmalloc() failed\n");\r\nreturn NULL;\r\n}\r\nbio->bi_end_io = pscsi_bi_endio;\r\nreturn bio;\r\n}\r\nstatic sense_reason_t\r\npscsi_map_sg(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\r\nenum dma_data_direction data_direction, struct bio **hbio)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(cmd->se_dev);\r\nstruct bio *bio = NULL, *tbio = NULL;\r\nstruct page *page;\r\nstruct scatterlist *sg;\r\nu32 data_len = cmd->data_length, i, len, bytes, off;\r\nint nr_pages = (cmd->data_length + sgl[0].offset +\r\nPAGE_SIZE - 1) >> PAGE_SHIFT;\r\nint nr_vecs = 0, rc;\r\nint rw = (data_direction == DMA_TO_DEVICE);\r\n*hbio = NULL;\r\npr_debug("PSCSI: nr_pages: %d\n", nr_pages);\r\nfor_each_sg(sgl, sg, sgl_nents, i) {\r\npage = sg_page(sg);\r\noff = sg->offset;\r\nlen = sg->length;\r\npr_debug("PSCSI: i: %d page: %p len: %d off: %d\n", i,\r\npage, len, off);\r\nif (off + len > PAGE_SIZE)\r\ngoto fail;\r\nif (len > 0 && data_len > 0) {\r\nbytes = min_t(unsigned int, len, PAGE_SIZE - off);\r\nbytes = min(bytes, data_len);\r\nif (!bio) {\r\nnr_vecs = min_t(int, BIO_MAX_PAGES, nr_pages);\r\nnr_pages -= nr_vecs;\r\nbio = pscsi_get_bio(nr_vecs);\r\nif (!bio)\r\ngoto fail;\r\nif (rw)\r\nbio->bi_rw |= REQ_WRITE;\r\npr_debug("PSCSI: Allocated bio: %p,"\r\n" dir: %s nr_vecs: %d\n", bio,\r\n(rw) ? "rw" : "r", nr_vecs);\r\nif (!*hbio)\r\n*hbio = tbio = bio;\r\nelse\r\ntbio = tbio->bi_next = bio;\r\n}\r\npr_debug("PSCSI: Calling bio_add_pc_page() i: %d"\r\n" bio: %p page: %p len: %d off: %d\n", i, bio,\r\npage, len, off);\r\nrc = bio_add_pc_page(pdv->pdv_sd->request_queue,\r\nbio, page, bytes, off);\r\nif (rc != bytes)\r\ngoto fail;\r\npr_debug("PSCSI: bio->bi_vcnt: %d nr_vecs: %d\n",\r\nbio->bi_vcnt, nr_vecs);\r\nif (bio->bi_vcnt > nr_vecs) {\r\npr_debug("PSCSI: Reached bio->bi_vcnt max:"\r\n" %d i: %d bio: %p, allocating another"\r\n" bio\n", bio->bi_vcnt, i, bio);\r\nbio = NULL;\r\n}\r\ndata_len -= bytes;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nwhile (*hbio) {\r\nbio = *hbio;\r\n*hbio = (*hbio)->bi_next;\r\nbio_endio(bio, 0);\r\n}\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nstatic inline void pscsi_clear_cdb_lun(unsigned char *cdb)\r\n{\r\nswitch (cdb[0]) {\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\ncase SEND_DIAGNOSTIC:\r\ncase VERIFY:\r\ncase VERIFY_16:\r\ncase WRITE_VERIFY:\r\ncase WRITE_VERIFY_12:\r\ncase MAINTENANCE_IN:\r\nbreak;\r\ndefault:\r\ncdb[1] &= 0x1f;\r\nbreak;\r\n}\r\n}\r\nstatic sense_reason_t\r\npscsi_parse_cdb(struct se_cmd *cmd)\r\n{\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nif (cmd->se_cmd_flags & SCF_BIDI)\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\npscsi_clear_cdb_lun(cdb);\r\nswitch (cdb[0]) {\r\ncase REPORT_LUNS:\r\ncmd->execute_cmd = spc_emulate_report_luns;\r\nreturn 0;\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_16:\r\ncase WRITE_VERIFY:\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ndefault:\r\ncmd->execute_cmd = pscsi_execute_cmd;\r\nreturn 0;\r\n}\r\n}\r\nstatic sense_reason_t\r\npscsi_execute_cmd(struct se_cmd *cmd)\r\n{\r\nstruct scatterlist *sgl = cmd->t_data_sg;\r\nu32 sgl_nents = cmd->t_data_nents;\r\nenum dma_data_direction data_direction = cmd->data_direction;\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(cmd->se_dev);\r\nstruct pscsi_plugin_task *pt;\r\nstruct request *req;\r\nstruct bio *hbio;\r\nsense_reason_t ret;\r\npt = kzalloc(sizeof(*pt) + scsi_command_size(cmd->t_task_cdb), GFP_KERNEL);\r\nif (!pt) {\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ncmd->priv = pt;\r\nmemcpy(pt->pscsi_cdb, cmd->t_task_cdb,\r\nscsi_command_size(cmd->t_task_cdb));\r\nif (!sgl) {\r\nreq = blk_get_request(pdv->pdv_sd->request_queue,\r\n(data_direction == DMA_TO_DEVICE),\r\nGFP_KERNEL);\r\nif (!req || IS_ERR(req)) {\r\npr_err("PSCSI: blk_get_request() failed: %ld\n",\r\nreq ? IS_ERR(req) : -ENOMEM);\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto fail;\r\n}\r\n} else {\r\nBUG_ON(!cmd->data_length);\r\nret = pscsi_map_sg(cmd, sgl, sgl_nents, data_direction, &hbio);\r\nif (ret)\r\ngoto fail;\r\nreq = blk_make_request(pdv->pdv_sd->request_queue, hbio,\r\nGFP_KERNEL);\r\nif (IS_ERR(req)) {\r\npr_err("pSCSI: blk_make_request() failed\n");\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto fail_free_bio;\r\n}\r\n}\r\nreq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nreq->end_io = pscsi_req_done;\r\nreq->end_io_data = cmd;\r\nreq->cmd_len = scsi_command_size(pt->pscsi_cdb);\r\nreq->cmd = &pt->pscsi_cdb[0];\r\nreq->sense = &pt->pscsi_sense[0];\r\nreq->sense_len = 0;\r\nif (pdv->pdv_sd->type == TYPE_DISK)\r\nreq->timeout = PS_TIMEOUT_DISK;\r\nelse\r\nreq->timeout = PS_TIMEOUT_OTHER;\r\nreq->retries = PS_RETRY;\r\nblk_execute_rq_nowait(pdv->pdv_sd->request_queue, NULL, req,\r\n(cmd->sam_task_attr == MSG_HEAD_TAG),\r\npscsi_req_done);\r\nreturn 0;\r\nfail_free_bio:\r\nwhile (hbio) {\r\nstruct bio *bio = hbio;\r\nhbio = hbio->bi_next;\r\nbio_endio(bio, 0);\r\n}\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nfail:\r\nkfree(pt);\r\nreturn ret;\r\n}\r\nstatic u32 pscsi_get_device_type(struct se_device *dev)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nstruct scsi_device *sd = pdv->pdv_sd;\r\nreturn sd->type;\r\n}\r\nstatic sector_t pscsi_get_blocks(struct se_device *dev)\r\n{\r\nstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\r\nif (pdv->pdv_bd && pdv->pdv_bd->bd_part)\r\nreturn pdv->pdv_bd->bd_part->nr_sects;\r\ndump_stack();\r\nreturn 0;\r\n}\r\nstatic void pscsi_req_done(struct request *req, int uptodate)\r\n{\r\nstruct se_cmd *cmd = req->end_io_data;\r\nstruct pscsi_plugin_task *pt = cmd->priv;\r\npt->pscsi_result = req->errors;\r\npt->pscsi_resid = req->resid_len;\r\ncmd->scsi_status = status_byte(pt->pscsi_result) << 1;\r\nif (cmd->scsi_status) {\r\npr_debug("PSCSI Status Byte exception at cmd: %p CDB:"\r\n" 0x%02x Result: 0x%08x\n", cmd, pt->pscsi_cdb[0],\r\npt->pscsi_result);\r\n}\r\nswitch (host_byte(pt->pscsi_result)) {\r\ncase DID_OK:\r\ntarget_complete_cmd(cmd, cmd->scsi_status);\r\nbreak;\r\ndefault:\r\npr_debug("PSCSI Host Byte exception at cmd: %p CDB:"\r\n" 0x%02x Result: 0x%08x\n", cmd, pt->pscsi_cdb[0],\r\npt->pscsi_result);\r\ntarget_complete_cmd(cmd, SAM_STAT_CHECK_CONDITION);\r\nbreak;\r\n}\r\n__blk_put_request(req->q, req);\r\nkfree(pt);\r\n}\r\nstatic int __init pscsi_module_init(void)\r\n{\r\nreturn transport_subsystem_register(&pscsi_template);\r\n}\r\nstatic void __exit pscsi_module_exit(void)\r\n{\r\ntransport_subsystem_release(&pscsi_template);\r\n}
