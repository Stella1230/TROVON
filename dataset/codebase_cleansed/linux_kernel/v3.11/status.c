void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nint tmp;\r\nskb->pkt_type = IEEE80211_TX_STATUS_MSG;\r\nskb_queue_tail(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS ?\r\n&local->skb_queue : &local->skb_queue_unreliable, skb);\r\ntmp = skb_queue_len(&local->skb_queue) +\r\nskb_queue_len(&local->skb_queue_unreliable);\r\nwhile (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&\r\n(skb = skb_dequeue(&local->skb_queue_unreliable))) {\r\nieee80211_free_txskb(hw, skb);\r\ntmp--;\r\nI802_DEBUG_INC(local->tx_status_drop);\r\n}\r\ntasklet_schedule(&local->tasklet);\r\n}\r\nstatic void ieee80211_handle_filtered_frame(struct ieee80211_local *local,\r\nstruct sta_info *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nint ac;\r\nmemset(&info->control, 0, sizeof(info->control));\r\ninfo->control.jiffies = jiffies;\r\ninfo->control.vif = &sta->sdata->vif;\r\ninfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING |\r\nIEEE80211_TX_INTFL_RETRANSMISSION;\r\ninfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\r\nsta->tx_filtered_count++;\r\nif (hdr->frame_control & cpu_to_le16(IEEE80211_FCTL_MOREDATA))\r\nhdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nif (ieee80211_is_data_qos(hdr->frame_control)) {\r\nu8 *p = ieee80211_get_qos_ctl(hdr);\r\nint tid = *p & IEEE80211_QOS_CTL_TID_MASK;\r\nif (*p & IEEE80211_QOS_CTL_EOSP)\r\n*p &= ~IEEE80211_QOS_CTL_EOSP;\r\nac = ieee802_1d_to_ac[tid & 7];\r\n} else {\r\nac = IEEE80211_AC_BE;\r\n}\r\nset_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT);\r\nif (test_sta_flag(sta, WLAN_STA_PS_STA) &&\r\nskb_queue_len(&sta->tx_filtered[ac]) < STA_MAX_TX_BUFFER) {\r\nskb_queue_tail(&sta->tx_filtered[ac], skb);\r\nsta_info_recalc_tim(sta);\r\nif (!timer_pending(&local->sta_cleanup))\r\nmod_timer(&local->sta_cleanup,\r\nround_jiffies(jiffies +\r\nSTA_INFO_CLEANUP_INTERVAL));\r\nreturn;\r\n}\r\nif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\r\n!(info->flags & IEEE80211_TX_INTFL_RETRIED)) {\r\ninfo->flags |= IEEE80211_TX_INTFL_RETRIED;\r\nieee80211_add_pending_skb(local, skb);\r\nreturn;\r\n}\r\nps_dbg_ratelimited(sta->sdata,\r\n"dropped TX filtered frame, queue_len=%d PS=%d @%lu\n",\r\nskb_queue_len(&sta->tx_filtered[ac]),\r\n!!test_sta_flag(sta, WLAN_STA_PS_STA), jiffies);\r\nieee80211_free_txskb(&local->hw, skb);\r\n}\r\nstatic void ieee80211_check_pending_bar(struct sta_info *sta, u8 *addr, u8 tid)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\r\nif (!tid_tx || !tid_tx->bar_pending)\r\nreturn;\r\ntid_tx->bar_pending = false;\r\nieee80211_send_bar(&sta->sdata->vif, addr, tid, tid_tx->failed_bar_ssn);\r\n}\r\nstatic void ieee80211_frame_acked(struct sta_info *sta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (void *) skb->data;\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (ieee80211_is_data_qos(mgmt->frame_control)) {\r\nstruct ieee80211_hdr *hdr = (void *) skb->data;\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\nu16 tid = qc[0] & 0xf;\r\nieee80211_check_pending_bar(sta, hdr->addr1, tid);\r\n}\r\nif (ieee80211_is_action(mgmt->frame_control) &&\r\nmgmt->u.action.category == WLAN_CATEGORY_HT &&\r\nmgmt->u.action.u.ht_smps.action == WLAN_HT_ACTION_SMPS &&\r\nsdata->vif.type == NL80211_IFTYPE_STATION &&\r\nieee80211_sdata_running(sdata)) {\r\nswitch (mgmt->u.action.u.ht_smps.smps_control) {\r\ncase WLAN_HT_SMPS_CONTROL_DYNAMIC:\r\nsdata->smps_mode = IEEE80211_SMPS_DYNAMIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_STATIC:\r\nsdata->smps_mode = IEEE80211_SMPS_STATIC;\r\nbreak;\r\ncase WLAN_HT_SMPS_CONTROL_DISABLED:\r\ndefault:\r\nsdata->smps_mode = IEEE80211_SMPS_OFF;\r\nbreak;\r\n}\r\nieee80211_queue_work(&local->hw, &sdata->recalc_smps);\r\n}\r\n}\r\nstatic void ieee80211_set_bar_pending(struct sta_info *sta, u8 tid, u16 ssn)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\r\nif (!tid_tx)\r\nreturn;\r\ntid_tx->failed_bar_ssn = ssn;\r\ntid_tx->bar_pending = true;\r\n}\r\nstatic int ieee80211_tx_radiotap_len(struct ieee80211_tx_info *info)\r\n{\r\nint len = sizeof(struct ieee80211_radiotap_header);\r\nif (info->status.rates[0].idx >= 0 &&\r\n!(info->status.rates[0].flags & IEEE80211_TX_RC_MCS))\r\nlen += 2;\r\nlen += 2;\r\nlen += 1;\r\nif (info->status.rates[0].idx >= 0 &&\r\ninfo->status.rates[0].flags & IEEE80211_TX_RC_MCS)\r\nlen += 3;\r\nreturn len;\r\n}\r\nstatic void ieee80211_add_tx_radiotap_header(struct ieee80211_supported_band\r\n*sband, struct sk_buff *skb,\r\nint retry_count, int rtap_len)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_radiotap_header *rthdr;\r\nunsigned char *pos;\r\nu16 txflags;\r\nrthdr = (struct ieee80211_radiotap_header *) skb_push(skb, rtap_len);\r\nmemset(rthdr, 0, rtap_len);\r\nrthdr->it_len = cpu_to_le16(rtap_len);\r\nrthdr->it_present =\r\ncpu_to_le32((1 << IEEE80211_RADIOTAP_TX_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_DATA_RETRIES));\r\npos = (unsigned char *)(rthdr + 1);\r\nif (info->status.rates[0].idx >= 0 &&\r\n!(info->status.rates[0].flags & IEEE80211_TX_RC_MCS)) {\r\nrthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);\r\n*pos = sband->bitrates[info->status.rates[0].idx].bitrate / 5;\r\npos += 2;\r\n}\r\ntxflags = 0;\r\nif (!(info->flags & IEEE80211_TX_STAT_ACK) &&\r\n!is_multicast_ether_addr(hdr->addr1))\r\ntxflags |= IEEE80211_RADIOTAP_F_TX_FAIL;\r\nif ((info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||\r\n(info->status.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT))\r\ntxflags |= IEEE80211_RADIOTAP_F_TX_CTS;\r\nelse if (info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\r\ntxflags |= IEEE80211_RADIOTAP_F_TX_RTS;\r\nput_unaligned_le16(txflags, pos);\r\npos += 2;\r\n*pos = retry_count;\r\npos++;\r\nif (info->status.rates[0].idx >= 0 &&\r\ninfo->status.rates[0].flags & IEEE80211_TX_RC_MCS) {\r\nrthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);\r\npos[0] = IEEE80211_RADIOTAP_MCS_HAVE_MCS |\r\nIEEE80211_RADIOTAP_MCS_HAVE_GI |\r\nIEEE80211_RADIOTAP_MCS_HAVE_BW;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\r\npos[1] |= IEEE80211_RADIOTAP_MCS_SGI;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\npos[1] |= IEEE80211_RADIOTAP_MCS_BW_40;\r\nif (info->status.rates[0].flags & IEEE80211_TX_RC_GREEN_FIELD)\r\npos[1] |= IEEE80211_RADIOTAP_MCS_FMT_GF;\r\npos[2] = info->status.rates[0].idx;\r\npos += 3;\r\n}\r\n}\r\nstatic void ieee80211_report_used_skb(struct ieee80211_local *local,\r\nstruct sk_buff *skb, bool dropped)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nbool acked = info->flags & IEEE80211_TX_STAT_ACK;\r\nif (dropped)\r\nacked = false;\r\nif (info->flags & (IEEE80211_TX_INTFL_NL80211_FRAME_TX |\r\nIEEE80211_TX_INTFL_MLME_CONN_TX)) {\r\nstruct ieee80211_sub_if_data *sdata = NULL;\r\nstruct ieee80211_sub_if_data *iter_sdata;\r\nu64 cookie = (unsigned long)skb;\r\nrcu_read_lock();\r\nif (skb->dev) {\r\nlist_for_each_entry_rcu(iter_sdata, &local->interfaces,\r\nlist) {\r\nif (!iter_sdata->dev)\r\ncontinue;\r\nif (skb->dev == iter_sdata->dev) {\r\nsdata = iter_sdata;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nsdata = rcu_dereference(local->p2p_sdata);\r\n}\r\nif (!sdata) {\r\nskb->dev = NULL;\r\n} else if (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX) {\r\nieee80211_mgd_conn_tx_status(sdata, hdr->frame_control,\r\nacked);\r\n} else if (ieee80211_is_nullfunc(hdr->frame_control) ||\r\nieee80211_is_qos_nullfunc(hdr->frame_control)) {\r\ncfg80211_probe_status(sdata->dev, hdr->addr1,\r\ncookie, acked, GFP_ATOMIC);\r\n} else {\r\ncfg80211_mgmt_tx_status(&sdata->wdev, cookie, skb->data,\r\nskb->len, acked, GFP_ATOMIC);\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (unlikely(info->ack_frame_id)) {\r\nstruct sk_buff *ack_skb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&local->ack_status_lock, flags);\r\nack_skb = idr_find(&local->ack_status_frames,\r\ninfo->ack_frame_id);\r\nif (ack_skb)\r\nidr_remove(&local->ack_status_frames,\r\ninfo->ack_frame_id);\r\nspin_unlock_irqrestore(&local->ack_status_lock, flags);\r\nif (ack_skb) {\r\nif (!dropped) {\r\nskb_complete_wifi_ack(ack_skb, acked);\r\n} else {\r\ndev_kfree_skb_any(ack_skb);\r\n}\r\n}\r\n}\r\n}\r\nvoid ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\n__le16 fc;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_sub_if_data *sdata;\r\nstruct net_device *prev_dev = NULL;\r\nstruct sta_info *sta, *tmp;\r\nint retry_count = -1, i;\r\nint rates_idx = -1;\r\nbool send_to_cooked;\r\nbool acked;\r\nstruct ieee80211_bar *bar;\r\nint rtap_len;\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU)) {\r\ninfo->status.rates[i].idx = -1;\r\ninfo->status.rates[i].count = 0;\r\nbreak;\r\n} else if (info->status.rates[i].idx < 0) {\r\nbreak;\r\n} else if (i >= hw->max_report_rates) {\r\ninfo->status.rates[i].idx = -1;\r\ninfo->status.rates[i].count = 0;\r\nbreak;\r\n}\r\nretry_count += info->status.rates[i].count;\r\n}\r\nrates_idx = i - 1;\r\nif (retry_count < 0)\r\nretry_count = 0;\r\nrcu_read_lock();\r\nsband = local->hw.wiphy->bands[info->band];\r\nfc = hdr->frame_control;\r\nfor_each_sta_info(local, hdr->addr1, sta, tmp) {\r\nif (!ether_addr_equal(hdr->addr2, sta->sdata->vif.addr))\r\ncontinue;\r\nif (info->flags & IEEE80211_TX_STATUS_EOSP)\r\nclear_sta_flag(sta, WLAN_STA_SP);\r\nacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nif (!acked && test_sta_flag(sta, WLAN_STA_PS_STA)) {\r\nieee80211_handle_filtered_frame(local, sta, skb);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (ieee80211_vif_is_mesh(&sta->sdata->vif) &&\r\nieee80211_is_data_qos(fc))\r\nieee80211_mpsp_trigger_process(\r\nieee80211_get_qos_ctl(hdr),\r\nsta, true, acked);\r\nif ((local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL) &&\r\n(rates_idx != -1))\r\nsta->last_tx_rate = info->status.rates[rates_idx];\r\nif ((info->flags & IEEE80211_TX_STAT_AMPDU_NO_BACK) &&\r\n(ieee80211_is_data_qos(fc))) {\r\nu16 tid, ssn;\r\nu8 *qc;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\nssn = ((le16_to_cpu(hdr->seq_ctrl) + 0x10)\r\n& IEEE80211_SCTL_SEQ);\r\nieee80211_send_bar(&sta->sdata->vif, hdr->addr1,\r\ntid, ssn);\r\n}\r\nif (!acked && ieee80211_is_back_req(fc)) {\r\nu16 tid, control;\r\nbar = (struct ieee80211_bar *) skb->data;\r\ncontrol = le16_to_cpu(bar->control);\r\nif (!(control & IEEE80211_BAR_CTRL_MULTI_TID)) {\r\nu16 ssn = le16_to_cpu(bar->start_seq_num);\r\ntid = (control &\r\nIEEE80211_BAR_CTRL_TID_INFO_MASK) >>\r\nIEEE80211_BAR_CTRL_TID_INFO_SHIFT;\r\nieee80211_set_bar_pending(sta, tid, ssn);\r\n}\r\n}\r\nif (info->flags & IEEE80211_TX_STAT_TX_FILTERED) {\r\nieee80211_handle_filtered_frame(local, sta, skb);\r\nrcu_read_unlock();\r\nreturn;\r\n} else {\r\nif (!acked)\r\nsta->tx_retry_failed++;\r\nsta->tx_retry_count += retry_count;\r\n}\r\nrate_control_tx_status(local, sband, sta, skb);\r\nif (ieee80211_vif_is_mesh(&sta->sdata->vif))\r\nieee80211s_update_metric(local, sta, skb);\r\nif (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)\r\nieee80211_frame_acked(sta, skb);\r\nif ((sta->sdata->vif.type == NL80211_IFTYPE_STATION) &&\r\n(local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS))\r\nieee80211_sta_tx_notify(sta->sdata, (void *) skb->data, acked);\r\nif (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) {\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nif (sta->lost_packets)\r\nsta->lost_packets = 0;\r\n} else if (++sta->lost_packets >= STA_LOST_PKT_THRESHOLD) {\r\ncfg80211_cqm_pktloss_notify(sta->sdata->dev,\r\nsta->sta.addr,\r\nsta->lost_packets,\r\nGFP_ATOMIC);\r\nsta->lost_packets = 0;\r\n}\r\n}\r\nif (acked)\r\nsta->last_ack_signal = info->status.ack_signal;\r\n}\r\nrcu_read_unlock();\r\nieee80211_led_tx(local, 0);\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nif (ieee80211_is_first_frag(hdr->seq_ctrl)) {\r\nlocal->dot11TransmittedFrameCount++;\r\nif (is_multicast_ether_addr(hdr->addr1))\r\nlocal->dot11MulticastTransmittedFrameCount++;\r\nif (retry_count > 0)\r\nlocal->dot11RetryCount++;\r\nif (retry_count > 1)\r\nlocal->dot11MultipleRetryCount++;\r\n}\r\nif (!is_multicast_ether_addr(hdr->addr1) ||\r\nieee80211_is_data(fc) ||\r\nieee80211_is_mgmt(fc))\r\nlocal->dot11TransmittedFragmentCount++;\r\n} else {\r\nif (ieee80211_is_first_frag(hdr->seq_ctrl))\r\nlocal->dot11FailedCount++;\r\n}\r\nif (ieee80211_is_nullfunc(fc) && ieee80211_has_pm(fc) &&\r\n(local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS) &&\r\n!(info->flags & IEEE80211_TX_CTL_INJECTED) &&\r\nlocal->ps_sdata && !(local->scanning)) {\r\nif (info->flags & IEEE80211_TX_STAT_ACK) {\r\nlocal->ps_sdata->u.mgd.flags |=\r\nIEEE80211_STA_NULLFUNC_ACKED;\r\n} else\r\nmod_timer(&local->dynamic_ps_timer, jiffies +\r\nmsecs_to_jiffies(10));\r\n}\r\nieee80211_report_used_skb(local, skb, false);\r\nskb_orphan(skb);\r\nsend_to_cooked = !!(info->flags & IEEE80211_TX_CTL_INJECTED) ||\r\n!(ieee80211_is_data(fc));\r\nif (!local->monitors && (!send_to_cooked || !local->cooked_mntrs)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nrtap_len = ieee80211_tx_radiotap_len(info);\r\nif (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {\r\npr_err("ieee80211_tx_status: headroom too small\n");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nieee80211_add_tx_radiotap_header(sband, skb, retry_count, rtap_len);\r\nskb_set_mac_header(skb, 0);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\r\nif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif ((sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) &&\r\n!send_to_cooked)\r\ncontinue;\r\nif (prev_dev) {\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2) {\r\nskb2->dev = prev_dev;\r\nnetif_rx(skb2);\r\n}\r\n}\r\nprev_dev = sdata->dev;\r\n}\r\n}\r\nif (prev_dev) {\r\nskb->dev = prev_dev;\r\nnetif_rx(skb);\r\nskb = NULL;\r\n}\r\nrcu_read_unlock();\r\ndev_kfree_skb(skb);\r\n}\r\nvoid ieee80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\ncfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,\r\nnum_packets, GFP_ATOMIC);\r\n}\r\nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nieee80211_report_used_skb(local, skb, true);\r\ndev_kfree_skb_any(skb);\r\n}\r\nvoid ieee80211_purge_tx_queue(struct ieee80211_hw *hw,\r\nstruct sk_buff_head *skbs)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = __skb_dequeue(skbs)))\r\nieee80211_free_txskb(hw, skb);\r\n}
