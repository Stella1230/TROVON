static void gx_write_byte(int reg, int value)\r\n{\r\npci_write_config_byte(gx_params->cs55x0, reg, value);\r\n}\r\nunsigned int gx_get_cpuspeed(unsigned int cpu)\r\n{\r\nif ((gx_params->pci_suscfg & SUSMOD) == 0)\r\nreturn stock_freq;\r\nreturn (stock_freq * gx_params->off_duration)\r\n/ (gx_params->on_duration + gx_params->off_duration);\r\n}\r\nstatic unsigned int gx_validate_speed(unsigned int khz, u8 *on_duration,\r\nu8 *off_duration)\r\n{\r\nunsigned int i;\r\nu8 tmp_on, tmp_off;\r\nint old_tmp_freq = stock_freq;\r\nint tmp_freq;\r\n*off_duration = 1;\r\n*on_duration = 0;\r\nfor (i = max_duration; i > 0; i--) {\r\ntmp_off = ((khz * i) / stock_freq) & 0xff;\r\ntmp_on = i - tmp_off;\r\ntmp_freq = (stock_freq * tmp_off) / i;\r\nif (abs(tmp_freq - khz) <= abs(old_tmp_freq - khz)) {\r\n*on_duration = tmp_on;\r\n*off_duration = tmp_off;\r\nold_tmp_freq = tmp_freq;\r\n}\r\n}\r\nreturn old_tmp_freq;\r\n}\r\nstatic void gx_set_cpuspeed(struct cpufreq_policy *policy, unsigned int khz)\r\n{\r\nu8 suscfg, pmer1;\r\nunsigned int new_khz;\r\nunsigned long flags;\r\nstruct cpufreq_freqs freqs;\r\nfreqs.old = gx_get_cpuspeed(0);\r\nnew_khz = gx_validate_speed(khz, &gx_params->on_duration,\r\n&gx_params->off_duration);\r\nfreqs.new = new_khz;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nlocal_irq_save(flags);\r\nif (new_khz != stock_freq) {\r\nswitch (gx_params->cs55x0->device) {\r\ncase PCI_DEVICE_ID_CYRIX_5530_LEGACY:\r\npmer1 = gx_params->pci_pmer1 | IRQ_SPDUP | VID_SPDUP;\r\ngx_write_byte(PCI_IRQTC, 4);\r\ngx_write_byte(PCI_VIDTC, 100);\r\ngx_write_byte(PCI_PMER1, pmer1);\r\nif (gx_params->cs55x0->revision < 0x10) {\r\nsuscfg = gx_params->pci_suscfg|SUSMOD;\r\n} else {\r\nsuscfg = gx_params->pci_suscfg|SUSMOD|PWRSVE;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_CYRIX_5520:\r\ncase PCI_DEVICE_ID_CYRIX_5510:\r\nsuscfg = gx_params->pci_suscfg | SUSMOD;\r\nbreak;\r\ndefault:\r\nlocal_irq_restore(flags);\r\npr_debug("fatal: try to set unknown chipset.\n");\r\nreturn;\r\n}\r\n} else {\r\nsuscfg = gx_params->pci_suscfg & ~(SUSMOD);\r\ngx_params->off_duration = 0;\r\ngx_params->on_duration = 0;\r\npr_debug("suspend modulation disabled: cpu runs 100%% speed.\n");\r\n}\r\ngx_write_byte(PCI_MODOFF, gx_params->off_duration);\r\ngx_write_byte(PCI_MODON, gx_params->on_duration);\r\ngx_write_byte(PCI_SUSCFG, suscfg);\r\npci_read_config_byte(gx_params->cs55x0, PCI_SUSCFG, &suscfg);\r\nlocal_irq_restore(flags);\r\ngx_params->pci_suscfg = suscfg;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\npr_debug("suspend modulation w/ duration of ON:%d us, OFF:%d us\n",\r\ngx_params->on_duration * 32, gx_params->off_duration * 32);\r\npr_debug("suspend modulation w/ clock speed: %d kHz.\n", freqs.new);\r\n}\r\nstatic int cpufreq_gx_verify(struct cpufreq_policy *policy)\r\n{\r\nunsigned int tmp_freq = 0;\r\nu8 tmp1, tmp2;\r\nif (!stock_freq || !policy)\r\nreturn -EINVAL;\r\npolicy->cpu = 0;\r\ncpufreq_verify_within_limits(policy, (stock_freq / max_duration),\r\nstock_freq);\r\ntmp_freq = gx_validate_speed(policy->min, &tmp1, &tmp2);\r\nif (tmp_freq < policy->min)\r\ntmp_freq += stock_freq / max_duration;\r\npolicy->min = tmp_freq;\r\nif (policy->min > policy->max)\r\npolicy->max = tmp_freq;\r\ntmp_freq = gx_validate_speed(policy->max, &tmp1, &tmp2);\r\nif (tmp_freq > policy->max)\r\ntmp_freq -= stock_freq / max_duration;\r\npolicy->max = tmp_freq;\r\nif (policy->max < policy->min)\r\npolicy->max = policy->min;\r\ncpufreq_verify_within_limits(policy, (stock_freq / max_duration),\r\nstock_freq);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_gx_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nu8 tmp1, tmp2;\r\nunsigned int tmp_freq;\r\nif (!stock_freq || !policy)\r\nreturn -EINVAL;\r\npolicy->cpu = 0;\r\ntmp_freq = gx_validate_speed(target_freq, &tmp1, &tmp2);\r\nwhile (tmp_freq < policy->min) {\r\ntmp_freq += stock_freq / max_duration;\r\ntmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);\r\n}\r\nwhile (tmp_freq > policy->max) {\r\ntmp_freq -= stock_freq / max_duration;\r\ntmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);\r\n}\r\ngx_set_cpuspeed(policy, tmp_freq);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_gx_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int maxfreq, curfreq;\r\nif (!policy || policy->cpu != 0)\r\nreturn -ENODEV;\r\nif (pci_busclk)\r\nmaxfreq = pci_busclk * gx_freq_mult[getCx86(CX86_DIR1) & 0x0f];\r\nelse if (cpu_khz)\r\nmaxfreq = cpu_khz;\r\nelse\r\nmaxfreq = 30000 * gx_freq_mult[getCx86(CX86_DIR1) & 0x0f];\r\nstock_freq = maxfreq;\r\ncurfreq = gx_get_cpuspeed(0);\r\npr_debug("cpu max frequency is %d.\n", maxfreq);\r\npr_debug("cpu current frequency is %dkHz.\n", curfreq);\r\npolicy->cpu = 0;\r\nif (max_duration < POLICY_MIN_DIV)\r\npolicy->min = maxfreq / max_duration;\r\nelse\r\npolicy->min = maxfreq / POLICY_MIN_DIV;\r\npolicy->max = maxfreq;\r\npolicy->cur = curfreq;\r\npolicy->cpuinfo.min_freq = maxfreq / max_duration;\r\npolicy->cpuinfo.max_freq = maxfreq;\r\npolicy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;\r\nreturn 0;\r\n}\r\nstatic int __init cpufreq_gx_init(void)\r\n{\r\nint ret;\r\nstruct gxfreq_params *params;\r\nstruct pci_dev *gx_pci;\r\ngx_pci = gx_detect_chipset();\r\nif (gx_pci == NULL)\r\nreturn -ENODEV;\r\nif (max_duration > 0xff)\r\nmax_duration = 0xff;\r\npr_debug("geode suspend modulation available.\n");\r\nparams = kzalloc(sizeof(struct gxfreq_params), GFP_KERNEL);\r\nif (params == NULL)\r\nreturn -ENOMEM;\r\nparams->cs55x0 = gx_pci;\r\ngx_params = params;\r\npci_read_config_byte(params->cs55x0, PCI_SUSCFG, &(params->pci_suscfg));\r\npci_read_config_byte(params->cs55x0, PCI_PMER1, &(params->pci_pmer1));\r\npci_read_config_byte(params->cs55x0, PCI_PMER2, &(params->pci_pmer2));\r\npci_read_config_byte(params->cs55x0, PCI_MODON, &(params->on_duration));\r\npci_read_config_byte(params->cs55x0, PCI_MODOFF,\r\n&(params->off_duration));\r\nret = cpufreq_register_driver(&gx_suspmod_driver);\r\nif (ret) {\r\nkfree(params);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cpufreq_gx_exit(void)\r\n{\r\ncpufreq_unregister_driver(&gx_suspmod_driver);\r\npci_dev_put(gx_params->cs55x0);\r\nkfree(gx_params);\r\n}
