static void amd64_tlbflush(struct agp_memory *temp)\r\n{\r\namd_flush_garts();\r\n}\r\nstatic int amd64_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nint i, j, num_entries;\r\nlong long tmp;\r\nint mask_type;\r\nstruct agp_bridge_data *bridge = mem->bridge;\r\nu32 pte;\r\nnum_entries = agp_num_entries();\r\nif (type != mem->type)\r\nreturn -EINVAL;\r\nmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\r\nif (mask_type != 0)\r\nreturn -EINVAL;\r\nif (((unsigned long)pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nj = pg_start;\r\nwhile (j < (pg_start + mem->page_count)) {\r\nif (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+j)))\r\nreturn -EBUSY;\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\r\ntmp = agp_bridge->driver->mask_memory(agp_bridge,\r\npage_to_phys(mem->pages[i]),\r\nmask_type);\r\nBUG_ON(tmp & 0xffffff0000000ffcULL);\r\npte = (tmp & 0x000000ff00000000ULL) >> 28;\r\npte |=(tmp & 0x00000000fffff000ULL);\r\npte |= GPTE_VALID | GPTE_COHERENT;\r\nwritel(pte, agp_bridge->gatt_table+j);\r\nreadl(agp_bridge->gatt_table+j);\r\n}\r\namd64_tlbflush(mem);\r\nreturn 0;\r\n}\r\nstatic int amd64_fetch_size(void)\r\n{\r\nstruct pci_dev *dev;\r\nint i;\r\nu32 temp;\r\nstruct aper_size_info_32 *values;\r\ndev = node_to_amd_nb(0)->misc;\r\nif (dev==NULL)\r\nreturn 0;\r\npci_read_config_dword(dev, AMD64_GARTAPERTURECTL, &temp);\r\ntemp = (temp & 0xe);\r\nvalues = A_SIZE_32(amd64_aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 amd64_configure(struct pci_dev *hammer, u64 gatt_table)\r\n{\r\nu64 aperturebase;\r\nu32 tmp;\r\nu64 aper_base;\r\npci_read_config_dword(hammer, AMD64_GARTAPERTUREBASE, &tmp);\r\naperturebase = tmp << 25;\r\naper_base = (aperturebase & PCI_BASE_ADDRESS_MEM_MASK);\r\nenable_gart_translation(hammer, gatt_table);\r\nreturn aper_base;\r\n}\r\nstatic int amd_8151_configure(void)\r\n{\r\nunsigned long gatt_bus = virt_to_phys(agp_bridge->gatt_table_real);\r\nint i;\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn 0;\r\nfor (i = 0; i < amd_nb_num(); i++) {\r\nagp_bridge->gart_bus_addr =\r\namd64_configure(node_to_amd_nb(i)->misc, gatt_bus);\r\n}\r\namd_flush_garts();\r\nreturn 0;\r\n}\r\nstatic void amd64_cleanup(void)\r\n{\r\nu32 tmp;\r\nint i;\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn;\r\nfor (i = 0; i < amd_nb_num(); i++) {\r\nstruct pci_dev *dev = node_to_amd_nb(i)->misc;\r\npci_read_config_dword(dev, AMD64_GARTAPERTURECTL, &tmp);\r\ntmp &= ~GARTEN;\r\npci_write_config_dword(dev, AMD64_GARTAPERTURECTL, tmp);\r\n}\r\n}\r\nstatic int agp_aperture_valid(u64 aper, u32 size)\r\n{\r\nif (!aperture_valid(aper, size, 32*1024*1024))\r\nreturn 0;\r\nif (!aperture_resource &&\r\n!(aperture_resource = request_mem_region(aper, size, "aperture"))) {\r\nprintk(KERN_ERR PFX "Aperture conflicts with PCI mapping.\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int fix_northbridge(struct pci_dev *nb, struct pci_dev *agp, u16 cap)\r\n{\r\nu32 aper_low, aper_hi;\r\nu64 aper, nb_aper;\r\nint order = 0;\r\nu32 nb_order, nb_base;\r\nu16 apsize;\r\npci_read_config_dword(nb, AMD64_GARTAPERTURECTL, &nb_order);\r\nnb_order = (nb_order >> 1) & 7;\r\npci_read_config_dword(nb, AMD64_GARTAPERTUREBASE, &nb_base);\r\nnb_aper = nb_base << 25;\r\npci_read_config_word(agp, cap+0x14, &apsize);\r\nif (apsize == 0xffff) {\r\nif (agp_aperture_valid(nb_aper, (32*1024*1024)<<nb_order))\r\nreturn 0;\r\nreturn -1;\r\n}\r\napsize &= 0xfff;\r\nif (apsize & 0xff)\r\napsize |= 0xf00;\r\norder = 7 - hweight16(apsize);\r\npci_read_config_dword(agp, 0x10, &aper_low);\r\npci_read_config_dword(agp, 0x14, &aper_hi);\r\naper = (aper_low & ~((1<<22)-1)) | ((u64)aper_hi << 32);\r\nif (order >=0 && aper + (32ULL<<(20 + order)) > 0x100000000ULL) {\r\ndev_info(&agp->dev, "aperture size %u MB is not right, using settings from NB\n",\r\n32 << order);\r\norder = nb_order;\r\n}\r\nif (nb_order >= order) {\r\nif (agp_aperture_valid(nb_aper, (32*1024*1024)<<nb_order))\r\nreturn 0;\r\n}\r\ndev_info(&agp->dev, "aperture from AGP @ %Lx size %u MB\n",\r\naper, 32 << order);\r\nif (order < 0 || !agp_aperture_valid(aper, (32*1024*1024)<<order))\r\nreturn -1;\r\ngart_set_size_and_enable(nb, order);\r\npci_write_config_dword(nb, AMD64_GARTAPERTUREBASE, aper >> 25);\r\nreturn 0;\r\n}\r\nstatic int cache_nbs(struct pci_dev *pdev, u32 cap_ptr)\r\n{\r\nint i;\r\nif (amd_cache_northbridges() < 0)\r\nreturn -ENODEV;\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn -ENODEV;\r\ni = 0;\r\nfor (i = 0; i < amd_nb_num(); i++) {\r\nstruct pci_dev *dev = node_to_amd_nb(i)->misc;\r\nif (fix_northbridge(dev, pdev, cap_ptr) < 0) {\r\ndev_err(&dev->dev, "no usable aperture found\n");\r\n#ifdef __x86_64__\r\ndev_err(&dev->dev, "consider rebooting with iommu=memaper=2 to get a good aperture\n");\r\n#endif\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)\r\n{\r\nchar *revstring;\r\nswitch (pdev->revision) {\r\ncase 0x01: revstring="A0"; break;\r\ncase 0x02: revstring="A1"; break;\r\ncase 0x11: revstring="B0"; break;\r\ncase 0x12: revstring="B1"; break;\r\ncase 0x13: revstring="B2"; break;\r\ncase 0x14: revstring="B3"; break;\r\ndefault: revstring="??"; break;\r\n}\r\ndev_info(&pdev->dev, "AMD 8151 AGP Bridge rev %s\n", revstring);\r\nif (pdev->revision < 0x13) {\r\ndev_info(&pdev->dev, "correcting AGP revision (reports 3.5, is really 3.0)\n");\r\nbridge->major_version = 3;\r\nbridge->minor_version = 0;\r\n}\r\n}\r\nstatic int uli_agp_init(struct pci_dev *pdev)\r\n{\r\nu32 httfea,baseaddr,enuscr;\r\nstruct pci_dev *dev1;\r\nint i, ret;\r\nunsigned size = amd64_fetch_size();\r\ndev_info(&pdev->dev, "setting up ULi AGP\n");\r\ndev1 = pci_get_slot (pdev->bus,PCI_DEVFN(0,0));\r\nif (dev1 == NULL) {\r\ndev_info(&pdev->dev, "can't find ULi secondary device\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(uli_sizes); i++)\r\nif (uli_sizes[i].size == size)\r\nbreak;\r\nif (i == ARRAY_SIZE(uli_sizes)) {\r\ndev_info(&pdev->dev, "no ULi size found for %d\n", size);\r\nret = -ENODEV;\r\ngoto put;\r\n}\r\npci_read_config_dword (node_to_amd_nb(0)->misc, AMD64_GARTAPERTUREBASE,\r\n&httfea);\r\nif ((httfea & 0x7fff) >> (32 - 25)) {\r\nret = -ENODEV;\r\ngoto put;\r\n}\r\nhttfea = (httfea& 0x7fff) << 25;\r\npci_read_config_dword(pdev, ULI_X86_64_BASE_ADDR, &baseaddr);\r\nbaseaddr&= ~PCI_BASE_ADDRESS_MEM_MASK;\r\nbaseaddr|= httfea;\r\npci_write_config_dword(pdev, ULI_X86_64_BASE_ADDR, baseaddr);\r\nenuscr= httfea+ (size * 1024 * 1024) - 1;\r\npci_write_config_dword(dev1, ULI_X86_64_HTT_FEA_REG, httfea);\r\npci_write_config_dword(dev1, ULI_X86_64_ENU_SCR_REG, enuscr);\r\nret = 0;\r\nput:\r\npci_dev_put(dev1);\r\nreturn ret;\r\n}\r\nstatic int nforce3_agp_init(struct pci_dev *pdev)\r\n{\r\nu32 tmp, apbase, apbar, aplimit;\r\nstruct pci_dev *dev1;\r\nint i, ret;\r\nunsigned size = amd64_fetch_size();\r\ndev_info(&pdev->dev, "setting up Nforce3 AGP\n");\r\ndev1 = pci_get_slot(pdev->bus, PCI_DEVFN(11, 0));\r\nif (dev1 == NULL) {\r\ndev_info(&pdev->dev, "can't find Nforce3 secondary device\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++)\r\nif (nforce3_sizes[i].size == size)\r\nbreak;\r\nif (i == ARRAY_SIZE(nforce3_sizes)) {\r\ndev_info(&pdev->dev, "no NForce3 size found for %d\n", size);\r\nret = -ENODEV;\r\ngoto put;\r\n}\r\npci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);\r\ntmp &= ~(0xf);\r\ntmp |= nforce3_sizes[i].size_value;\r\npci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);\r\npci_read_config_dword (node_to_amd_nb(0)->misc, AMD64_GARTAPERTUREBASE,\r\n&apbase);\r\nif ( (apbase & 0x7fff) >> (32 - 25) ) {\r\ndev_info(&pdev->dev, "aperture base > 4G\n");\r\nret = -ENODEV;\r\ngoto put;\r\n}\r\napbase = (apbase & 0x7fff) << 25;\r\npci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);\r\napbar &= ~PCI_BASE_ADDRESS_MEM_MASK;\r\napbar |= apbase;\r\npci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);\r\naplimit = apbase + (size * 1024 * 1024) - 1;\r\npci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);\r\npci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);\r\npci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);\r\npci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);\r\nret = 0;\r\nput:\r\npci_dev_put(dev1);\r\nreturn ret;\r\n}\r\nstatic int agp_amd64_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\nint err;\r\nif (agp_bridges_found)\r\nreturn -ENODEV;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD &&\r\npdev->device == PCI_DEVICE_ID_AMD_8151_0) {\r\namd8151_init(pdev, bridge);\r\n} else {\r\ndev_info(&pdev->dev, "AGP bridge [%04x/%04x]\n",\r\npdev->vendor, pdev->device);\r\n}\r\nbridge->driver = &amd_8151_driver;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\npci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);\r\nif (cache_nbs(pdev, cap_ptr) == -1) {\r\nagp_put_bridge(bridge);\r\nreturn -ENODEV;\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_NVIDIA) {\r\nint ret = nforce3_agp_init(pdev);\r\nif (ret) {\r\nagp_put_bridge(bridge);\r\nreturn ret;\r\n}\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_AL) {\r\nint ret = uli_agp_init(pdev);\r\nif (ret) {\r\nagp_put_bridge(bridge);\r\nreturn ret;\r\n}\r\n}\r\npci_set_drvdata(pdev, bridge);\r\nerr = agp_add_bridge(bridge);\r\nif (err < 0)\r\nreturn err;\r\nagp_bridges_found++;\r\nreturn 0;\r\n}\r\nstatic void agp_amd64_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nrelease_mem_region(virt_to_phys(bridge->gatt_table_real),\r\namd64_aperture_sizes[bridge->aperture_size_idx].size);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\nagp_bridges_found--;\r\n}\r\nstatic int agp_amd64_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int agp_amd64_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (pdev->vendor == PCI_VENDOR_ID_NVIDIA)\r\nnforce3_agp_init(pdev);\r\nreturn amd_8151_configure();\r\n}\r\nint __init agp_amd64_init(void)\r\n{\r\nint err = 0;\r\nif (agp_off)\r\nreturn -EINVAL;\r\nerr = pci_register_driver(&agp_amd64_pci_driver);\r\nif (err < 0)\r\nreturn err;\r\nif (agp_bridges_found == 0) {\r\nif (!agp_try_unsupported && !agp_try_unsupported_boot) {\r\nprintk(KERN_INFO PFX "No supported AGP bridge found.\n");\r\n#ifdef MODULE\r\nprintk(KERN_INFO PFX "You can try agp_try_unsupported=1\n");\r\n#else\r\nprintk(KERN_INFO PFX "You can boot with agp=try_unsupported\n");\r\n#endif\r\npci_unregister_driver(&agp_amd64_pci_driver);\r\nreturn -ENODEV;\r\n}\r\nif (!pci_dev_present(amd_nb_misc_ids)) {\r\npci_unregister_driver(&agp_amd64_pci_driver);\r\nreturn -ENODEV;\r\n}\r\nagp_amd64_pci_driver.id_table = agp_amd64_pci_promisc_table;\r\nerr = driver_attach(&agp_amd64_pci_driver.driver);\r\nif (err == 0 && agp_bridges_found == 0) {\r\npci_unregister_driver(&agp_amd64_pci_driver);\r\nerr = -ENODEV;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int __init agp_amd64_mod_init(void)\r\n{\r\n#ifndef MODULE\r\nif (gart_iommu_aperture)\r\nreturn agp_bridges_found ? 0 : -ENODEV;\r\n#endif\r\nreturn agp_amd64_init();\r\n}\r\nstatic void __exit agp_amd64_cleanup(void)\r\n{\r\n#ifndef MODULE\r\nif (gart_iommu_aperture)\r\nreturn;\r\n#endif\r\nif (aperture_resource)\r\nrelease_resource(aperture_resource);\r\npci_unregister_driver(&agp_amd64_pci_driver);\r\n}
