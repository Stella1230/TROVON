asmlinkage long sys32_chown16(const char __user * filename, u16 user, u16 group)\r\n{\r\nreturn sys_chown(filename, low2highuid(user), low2highgid(group));\r\n}\r\nasmlinkage long sys32_lchown16(const char __user * filename, u16 user, u16 group)\r\n{\r\nreturn sys_lchown(filename, low2highuid(user), low2highgid(group));\r\n}\r\nasmlinkage long sys32_fchown16(unsigned int fd, u16 user, u16 group)\r\n{\r\nreturn sys_fchown(fd, low2highuid(user), low2highgid(group));\r\n}\r\nasmlinkage long sys32_setregid16(u16 rgid, u16 egid)\r\n{\r\nreturn sys_setregid(low2highgid(rgid), low2highgid(egid));\r\n}\r\nasmlinkage long sys32_setgid16(u16 gid)\r\n{\r\nreturn sys_setgid((gid_t)gid);\r\n}\r\nasmlinkage long sys32_setreuid16(u16 ruid, u16 euid)\r\n{\r\nreturn sys_setreuid(low2highuid(ruid), low2highuid(euid));\r\n}\r\nasmlinkage long sys32_setuid16(u16 uid)\r\n{\r\nreturn sys_setuid((uid_t)uid);\r\n}\r\nasmlinkage long sys32_setresuid16(u16 ruid, u16 euid, u16 suid)\r\n{\r\nreturn sys_setresuid(low2highuid(ruid), low2highuid(euid),\r\nlow2highuid(suid));\r\n}\r\nasmlinkage long sys32_getresuid16(u16 __user *ruidp, u16 __user *euidp, u16 __user *suidp)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint retval;\r\nu16 ruid, euid, suid;\r\nruid = high2lowuid(from_kuid_munged(cred->user_ns, cred->uid));\r\neuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->euid));\r\nsuid = high2lowuid(from_kuid_munged(cred->user_ns, cred->suid));\r\nif (!(retval = put_user(ruid, ruidp)) &&\r\n!(retval = put_user(euid, euidp)))\r\nretval = put_user(suid, suidp);\r\nreturn retval;\r\n}\r\nasmlinkage long sys32_setresgid16(u16 rgid, u16 egid, u16 sgid)\r\n{\r\nreturn sys_setresgid(low2highgid(rgid), low2highgid(egid),\r\nlow2highgid(sgid));\r\n}\r\nasmlinkage long sys32_getresgid16(u16 __user *rgidp, u16 __user *egidp, u16 __user *sgidp)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint retval;\r\nu16 rgid, egid, sgid;\r\nrgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->gid));\r\negid = high2lowgid(from_kgid_munged(cred->user_ns, cred->egid));\r\nsgid = high2lowgid(from_kgid_munged(cred->user_ns, cred->sgid));\r\nif (!(retval = put_user(rgid, rgidp)) &&\r\n!(retval = put_user(egid, egidp)))\r\nretval = put_user(sgid, sgidp);\r\nreturn retval;\r\n}\r\nasmlinkage long sys32_setfsuid16(u16 uid)\r\n{\r\nreturn sys_setfsuid((uid_t)uid);\r\n}\r\nasmlinkage long sys32_setfsgid16(u16 gid)\r\n{\r\nreturn sys_setfsgid((gid_t)gid);\r\n}\r\nstatic int groups16_to_user(u16 __user *grouplist, struct group_info *group_info)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint i;\r\nu16 group;\r\nkgid_t kgid;\r\nfor (i = 0; i < group_info->ngroups; i++) {\r\nkgid = GROUP_AT(group_info, i);\r\ngroup = (u16)from_kgid_munged(user_ns, kgid);\r\nif (put_user(group, grouplist+i))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int groups16_from_user(struct group_info *group_info, u16 __user *grouplist)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint i;\r\nu16 group;\r\nkgid_t kgid;\r\nfor (i = 0; i < group_info->ngroups; i++) {\r\nif (get_user(group, grouplist+i))\r\nreturn -EFAULT;\r\nkgid = make_kgid(user_ns, (gid_t)group);\r\nif (!gid_valid(kgid))\r\nreturn -EINVAL;\r\nGROUP_AT(group_info, i) = kgid;\r\n}\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_getgroups16(int gidsetsize, u16 __user *grouplist)\r\n{\r\nint i;\r\nif (gidsetsize < 0)\r\nreturn -EINVAL;\r\nget_group_info(current->cred->group_info);\r\ni = current->cred->group_info->ngroups;\r\nif (gidsetsize) {\r\nif (i > gidsetsize) {\r\ni = -EINVAL;\r\ngoto out;\r\n}\r\nif (groups16_to_user(grouplist, current->cred->group_info)) {\r\ni = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nput_group_info(current->cred->group_info);\r\nreturn i;\r\n}\r\nasmlinkage long sys32_setgroups16(int gidsetsize, u16 __user *grouplist)\r\n{\r\nstruct group_info *group_info;\r\nint retval;\r\nif (!capable(CAP_SETGID))\r\nreturn -EPERM;\r\nif ((unsigned)gidsetsize > NGROUPS_MAX)\r\nreturn -EINVAL;\r\ngroup_info = groups_alloc(gidsetsize);\r\nif (!group_info)\r\nreturn -ENOMEM;\r\nretval = groups16_from_user(group_info, grouplist);\r\nif (retval) {\r\nput_group_info(group_info);\r\nreturn retval;\r\n}\r\nretval = set_current_groups(group_info);\r\nput_group_info(group_info);\r\nreturn retval;\r\n}\r\nasmlinkage long sys32_getuid16(void)\r\n{\r\nreturn high2lowuid(from_kuid_munged(current_user_ns(), current_uid()));\r\n}\r\nasmlinkage long sys32_geteuid16(void)\r\n{\r\nreturn high2lowuid(from_kuid_munged(current_user_ns(), current_euid()));\r\n}\r\nasmlinkage long sys32_getgid16(void)\r\n{\r\nreturn high2lowgid(from_kgid_munged(current_user_ns(), current_gid()));\r\n}\r\nasmlinkage long sys32_getegid16(void)\r\n{\r\nreturn high2lowgid(from_kgid_munged(current_user_ns(), current_egid()));\r\n}\r\nasmlinkage long sys32_truncate64(const char __user * path, unsigned long high, unsigned long low)\r\n{\r\nif ((int)high < 0)\r\nreturn -EINVAL;\r\nelse\r\nreturn sys_truncate(path, (high << 32) | low);\r\n}\r\nasmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long high, unsigned long low)\r\n{\r\nif ((int)high < 0)\r\nreturn -EINVAL;\r\nelse\r\nreturn sys_ftruncate(fd, (high << 32) | low);\r\n}\r\nasmlinkage long sys32_pread64(unsigned int fd, char __user *ubuf,\r\nsize_t count, u32 poshi, u32 poslo)\r\n{\r\nif ((compat_ssize_t) count < 0)\r\nreturn -EINVAL;\r\nreturn sys_pread64(fd, ubuf, count, ((loff_t)AA(poshi) << 32) | AA(poslo));\r\n}\r\nasmlinkage long sys32_pwrite64(unsigned int fd, const char __user *ubuf,\r\nsize_t count, u32 poshi, u32 poslo)\r\n{\r\nif ((compat_ssize_t) count < 0)\r\nreturn -EINVAL;\r\nreturn sys_pwrite64(fd, ubuf, count, ((loff_t)AA(poshi) << 32) | AA(poslo));\r\n}\r\nasmlinkage compat_ssize_t sys32_readahead(int fd, u32 offhi, u32 offlo, s32 count)\r\n{\r\nreturn sys_readahead(fd, ((loff_t)AA(offhi) << 32) | AA(offlo), count);\r\n}\r\nstatic int cp_stat64(struct stat64_emu31 __user *ubuf, struct kstat *stat)\r\n{\r\nstruct stat64_emu31 tmp;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.st_dev = huge_encode_dev(stat->dev);\r\ntmp.st_ino = stat->ino;\r\ntmp.__st_ino = (u32)stat->ino;\r\ntmp.st_mode = stat->mode;\r\ntmp.st_nlink = (unsigned int)stat->nlink;\r\ntmp.st_uid = from_kuid_munged(current_user_ns(), stat->uid);\r\ntmp.st_gid = from_kgid_munged(current_user_ns(), stat->gid);\r\ntmp.st_rdev = huge_encode_dev(stat->rdev);\r\ntmp.st_size = stat->size;\r\ntmp.st_blksize = (u32)stat->blksize;\r\ntmp.st_blocks = (u32)stat->blocks;\r\ntmp.st_atime = (u32)stat->atime.tv_sec;\r\ntmp.st_mtime = (u32)stat->mtime.tv_sec;\r\ntmp.st_ctime = (u32)stat->ctime.tv_sec;\r\nreturn copy_to_user(ubuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\r\n}\r\nasmlinkage long sys32_stat64(const char __user * filename, struct stat64_emu31 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint ret = vfs_stat(filename, &stat);\r\nif (!ret)\r\nret = cp_stat64(statbuf, &stat);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_lstat64(const char __user * filename, struct stat64_emu31 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint ret = vfs_lstat(filename, &stat);\r\nif (!ret)\r\nret = cp_stat64(statbuf, &stat);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_fstat64(unsigned long fd, struct stat64_emu31 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint ret = vfs_fstat(fd, &stat);\r\nif (!ret)\r\nret = cp_stat64(statbuf, &stat);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_fstatat64(unsigned int dfd, const char __user *filename,\r\nstruct stat64_emu31 __user* statbuf, int flag)\r\n{\r\nstruct kstat stat;\r\nint error;\r\nerror = vfs_fstatat(dfd, filename, &stat, flag);\r\nif (error)\r\nreturn error;\r\nreturn cp_stat64(statbuf, &stat);\r\n}\r\nasmlinkage unsigned long old32_mmap(struct mmap_arg_struct_emu31 __user *arg)\r\n{\r\nstruct mmap_arg_struct_emu31 a;\r\nif (copy_from_user(&a, arg, sizeof(a)))\r\nreturn -EFAULT;\r\nif (a.offset & ~PAGE_MASK)\r\nreturn -EINVAL;\r\nreturn sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\r\na.offset >> PAGE_SHIFT);\r\n}\r\nasmlinkage long sys32_mmap2(struct mmap_arg_struct_emu31 __user *arg)\r\n{\r\nstruct mmap_arg_struct_emu31 a;\r\nif (copy_from_user(&a, arg, sizeof(a)))\r\nreturn -EFAULT;\r\nreturn sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);\r\n}\r\nasmlinkage long sys32_read(unsigned int fd, char __user * buf, size_t count)\r\n{\r\nif ((compat_ssize_t) count < 0)\r\nreturn -EINVAL;\r\nreturn sys_read(fd, buf, count);\r\n}\r\nasmlinkage long sys32_write(unsigned int fd, const char __user * buf, size_t count)\r\n{\r\nif ((compat_ssize_t) count < 0)\r\nreturn -EINVAL;\r\nreturn sys_write(fd, buf, count);\r\n}\r\nasmlinkage long\r\nsys32_fadvise64(int fd, loff_t offset, size_t len, int advise)\r\n{\r\nif (advise == 4)\r\nadvise = POSIX_FADV_DONTNEED;\r\nelse if (advise == 5)\r\nadvise = POSIX_FADV_NOREUSE;\r\nreturn sys_fadvise64(fd, offset, len, advise);\r\n}\r\nasmlinkage long\r\nsys32_fadvise64_64(struct fadvise64_64_args __user *args)\r\n{\r\nstruct fadvise64_64_args a;\r\nif ( copy_from_user(&a, args, sizeof(a)) )\r\nreturn -EFAULT;\r\nif (a.advice == 4)\r\na.advice = POSIX_FADV_DONTNEED;\r\nelse if (a.advice == 5)\r\na.advice = POSIX_FADV_NOREUSE;\r\nreturn sys_fadvise64_64(a.fd, a.offset, a.len, a.advice);\r\n}
