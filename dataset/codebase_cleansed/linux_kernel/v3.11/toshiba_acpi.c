static __inline__ void _set_bit(u32 * word, u32 mask, int value)\r\n{\r\n*word = (*word & ~mask) | (mask * value);\r\n}\r\nstatic int write_acpi_int(const char *methodName, int val)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_objs[1];\r\nacpi_status status;\r\nparams.count = ARRAY_SIZE(in_objs);\r\nparams.pointer = in_objs;\r\nin_objs[0].type = ACPI_TYPE_INTEGER;\r\nin_objs[0].integer.value = val;\r\nstatus = acpi_evaluate_object(NULL, (char *)methodName, &params, NULL);\r\nreturn (status == AE_OK) ? 0 : -EIO;\r\n}\r\nstatic acpi_status hci_raw(struct toshiba_acpi_dev *dev,\r\nconst u32 in[HCI_WORDS], u32 out[HCI_WORDS])\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_objs[HCI_WORDS];\r\nstruct acpi_buffer results;\r\nunion acpi_object out_objs[HCI_WORDS + 1];\r\nacpi_status status;\r\nint i;\r\nparams.count = HCI_WORDS;\r\nparams.pointer = in_objs;\r\nfor (i = 0; i < HCI_WORDS; ++i) {\r\nin_objs[i].type = ACPI_TYPE_INTEGER;\r\nin_objs[i].integer.value = in[i];\r\n}\r\nresults.length = sizeof(out_objs);\r\nresults.pointer = out_objs;\r\nstatus = acpi_evaluate_object(dev->acpi_dev->handle,\r\n(char *)dev->method_hci, &params,\r\n&results);\r\nif ((status == AE_OK) && (out_objs->package.count <= HCI_WORDS)) {\r\nfor (i = 0; i < out_objs->package.count; ++i) {\r\nout[i] = out_objs->package.elements[i].integer.value;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status hci_write1(struct toshiba_acpi_dev *dev, u32 reg,\r\nu32 in1, u32 *result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_SET, reg, in1, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(dev, in, out);\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic acpi_status hci_read1(struct toshiba_acpi_dev *dev, u32 reg,\r\nu32 *out1, u32 *result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_GET, reg, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(dev, in, out);\r\n*out1 = out[2];\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic acpi_status hci_write2(struct toshiba_acpi_dev *dev, u32 reg,\r\nu32 in1, u32 in2, u32 *result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_SET, reg, in1, in2, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(dev, in, out);\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic acpi_status hci_read2(struct toshiba_acpi_dev *dev, u32 reg,\r\nu32 *out1, u32 *out2, u32 *result)\r\n{\r\nu32 in[HCI_WORDS] = { HCI_GET, reg, *out1, *out2, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status = hci_raw(dev, in, out);\r\n*out1 = out[2];\r\n*out2 = out[3];\r\n*result = (status == AE_OK) ? out[0] : HCI_FAILURE;\r\nreturn status;\r\n}\r\nstatic int toshiba_illumination_available(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 in[HCI_WORDS] = { 0, 0, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status;\r\nin[0] = 0xf100;\r\nstatus = hci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Illumination device not available\n");\r\nreturn 0;\r\n}\r\nin[0] = 0xf400;\r\nstatus = hci_raw(dev, in, out);\r\nreturn 1;\r\n}\r\nstatic void toshiba_illumination_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, led_dev);\r\nu32 in[HCI_WORDS] = { 0, 0, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status;\r\nin[0] = 0xf100;\r\nstatus = hci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Illumination device not available\n");\r\nreturn;\r\n}\r\nif (brightness) {\r\nin[0] = 0xf400;\r\nin[1] = 0x14e;\r\nin[2] = 1;\r\nstatus = hci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("ACPI call for illumination failed\n");\r\nreturn;\r\n}\r\n} else {\r\nin[0] = 0xf400;\r\nin[1] = 0x14e;\r\nin[2] = 0;\r\nstatus = hci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("ACPI call for illumination failed.\n");\r\nreturn;\r\n}\r\n}\r\nin[0] = 0xf200;\r\nin[1] = 0;\r\nin[2] = 0;\r\nhci_raw(dev, in, out);\r\n}\r\nstatic enum led_brightness toshiba_illumination_get(struct led_classdev *cdev)\r\n{\r\nstruct toshiba_acpi_dev *dev = container_of(cdev,\r\nstruct toshiba_acpi_dev, led_dev);\r\nu32 in[HCI_WORDS] = { 0, 0, 0, 0, 0, 0 };\r\nu32 out[HCI_WORDS];\r\nacpi_status status;\r\nenum led_brightness result;\r\nin[0] = 0xf100;\r\nstatus = hci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Illumination device not available\n");\r\nreturn LED_OFF;\r\n}\r\nin[0] = 0xf300;\r\nin[1] = 0x14e;\r\nstatus = hci_raw(dev, in, out);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("ACPI call for illumination failed.\n");\r\nreturn LED_OFF;\r\n}\r\nresult = out[2] ? LED_FULL : LED_OFF;\r\nin[0] = 0xf200;\r\nin[1] = 0;\r\nin[2] = 0;\r\nhci_raw(dev, in, out);\r\nreturn result;\r\n}\r\nstatic u32 hci_get_bt_present(struct toshiba_acpi_dev *dev, bool *present)\r\n{\r\nu32 hci_result;\r\nu32 value, value2;\r\nvalue = 0;\r\nvalue2 = 0;\r\nhci_read2(dev, HCI_WIRELESS, &value, &value2, &hci_result);\r\nif (hci_result == HCI_SUCCESS)\r\n*present = (value & HCI_WIRELESS_BT_PRESENT) ? true : false;\r\nreturn hci_result;\r\n}\r\nstatic u32 hci_get_radio_state(struct toshiba_acpi_dev *dev, bool *radio_state)\r\n{\r\nu32 hci_result;\r\nu32 value, value2;\r\nvalue = 0;\r\nvalue2 = 0x0001;\r\nhci_read2(dev, HCI_WIRELESS, &value, &value2, &hci_result);\r\n*radio_state = value & HCI_WIRELESS_KILL_SWITCH;\r\nreturn hci_result;\r\n}\r\nstatic int bt_rfkill_set_block(void *data, bool blocked)\r\n{\r\nstruct toshiba_acpi_dev *dev = data;\r\nu32 result1, result2;\r\nu32 value;\r\nint err;\r\nbool radio_state;\r\nvalue = (blocked == false);\r\nmutex_lock(&dev->mutex);\r\nif (hci_get_radio_state(dev, &radio_state) != HCI_SUCCESS) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (!radio_state) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nhci_write2(dev, HCI_WIRELESS, value, HCI_WIRELESS_BT_POWER, &result1);\r\nhci_write2(dev, HCI_WIRELESS, value, HCI_WIRELESS_BT_ATTACH, &result2);\r\nif (result1 != HCI_SUCCESS || result2 != HCI_SUCCESS)\r\nerr = -EIO;\r\nelse\r\nerr = 0;\r\nout:\r\nmutex_unlock(&dev->mutex);\r\nreturn err;\r\n}\r\nstatic void bt_rfkill_poll(struct rfkill *rfkill, void *data)\r\n{\r\nbool new_rfk_state;\r\nbool value;\r\nu32 hci_result;\r\nstruct toshiba_acpi_dev *dev = data;\r\nmutex_lock(&dev->mutex);\r\nhci_result = hci_get_radio_state(dev, &value);\r\nif (hci_result != HCI_SUCCESS) {\r\nmutex_unlock(&dev->mutex);\r\nreturn;\r\n}\r\nnew_rfk_state = value;\r\nmutex_unlock(&dev->mutex);\r\nif (rfkill_set_hw_state(rfkill, !new_rfk_state))\r\nbt_rfkill_set_block(data, true);\r\n}\r\nstatic int get_tr_backlight_status(struct toshiba_acpi_dev *dev, bool *enabled)\r\n{\r\nu32 hci_result;\r\nu32 status;\r\nhci_read1(dev, HCI_TR_BACKLIGHT, &status, &hci_result);\r\n*enabled = !status;\r\nreturn hci_result == HCI_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int set_tr_backlight_status(struct toshiba_acpi_dev *dev, bool enable)\r\n{\r\nu32 hci_result;\r\nu32 value = !enable;\r\nhci_write1(dev, HCI_TR_BACKLIGHT, value, &hci_result);\r\nreturn hci_result == HCI_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int __get_lcd_brightness(struct toshiba_acpi_dev *dev)\r\n{\r\nu32 hci_result;\r\nu32 value;\r\nint brightness = 0;\r\nif (dev->tr_backlight_supported) {\r\nbool enabled;\r\nint ret = get_tr_backlight_status(dev, &enabled);\r\nif (ret)\r\nreturn ret;\r\nif (enabled)\r\nreturn 0;\r\nbrightness++;\r\n}\r\nhci_read1(dev, HCI_LCD_BRIGHTNESS, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS)\r\nreturn brightness + (value >> HCI_LCD_BRIGHTNESS_SHIFT);\r\nreturn -EIO;\r\n}\r\nstatic int get_lcd_brightness(struct backlight_device *bd)\r\n{\r\nstruct toshiba_acpi_dev *dev = bl_get_data(bd);\r\nreturn __get_lcd_brightness(dev);\r\n}\r\nstatic int lcd_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nint value;\r\nint levels;\r\nif (!dev->backlight_dev)\r\nreturn -ENODEV;\r\nlevels = dev->backlight_dev->props.max_brightness + 1;\r\nvalue = get_lcd_brightness(dev->backlight_dev);\r\nif (value >= 0) {\r\nseq_printf(m, "brightness: %d\n", value);\r\nseq_printf(m, "brightness_levels: %d\n", levels);\r\nreturn 0;\r\n}\r\npr_err("Error reading LCD brightness\n");\r\nreturn -EIO;\r\n}\r\nstatic int lcd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, lcd_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int set_lcd_brightness(struct toshiba_acpi_dev *dev, int value)\r\n{\r\nu32 hci_result;\r\nif (dev->tr_backlight_supported) {\r\nbool enable = !value;\r\nint ret = set_tr_backlight_status(dev, enable);\r\nif (ret)\r\nreturn ret;\r\nif (value)\r\nvalue--;\r\n}\r\nvalue = value << HCI_LCD_BRIGHTNESS_SHIFT;\r\nhci_write1(dev, HCI_LCD_BRIGHTNESS, value, &hci_result);\r\nreturn hci_result == HCI_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int set_lcd_status(struct backlight_device *bd)\r\n{\r\nstruct toshiba_acpi_dev *dev = bl_get_data(bd);\r\nreturn set_lcd_brightness(dev, bd->props.brightness);\r\n}\r\nstatic ssize_t lcd_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nint ret;\r\nint levels = dev->backlight_dev->props.max_brightness + 1;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " brightness : %i", &value) == 1 &&\r\nvalue >= 0 && value < levels) {\r\nret = set_lcd_brightness(dev, value);\r\nif (ret == 0)\r\nret = count;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int get_video_status(struct toshiba_acpi_dev *dev, u32 *status)\r\n{\r\nu32 hci_result;\r\nhci_read1(dev, HCI_VIDEO_OUT, status, &hci_result);\r\nreturn hci_result == HCI_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int video_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nu32 value;\r\nint ret;\r\nret = get_video_status(dev, &value);\r\nif (!ret) {\r\nint is_lcd = (value & HCI_VIDEO_OUT_LCD) ? 1 : 0;\r\nint is_crt = (value & HCI_VIDEO_OUT_CRT) ? 1 : 0;\r\nint is_tv = (value & HCI_VIDEO_OUT_TV) ? 1 : 0;\r\nseq_printf(m, "lcd_out: %d\n", is_lcd);\r\nseq_printf(m, "crt_out: %d\n", is_crt);\r\nseq_printf(m, "tv_out: %d\n", is_tv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int video_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, video_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t video_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar *cmd, *buffer;\r\nint ret;\r\nint value;\r\nint remain = count;\r\nint lcd_out = -1;\r\nint crt_out = -1;\r\nint tv_out = -1;\r\nu32 video_out;\r\ncmd = kmalloc(count + 1, GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nif (copy_from_user(cmd, buf, count)) {\r\nkfree(cmd);\r\nreturn -EFAULT;\r\n}\r\ncmd[count] = '\0';\r\nbuffer = cmd;\r\nwhile (remain) {\r\nif (sscanf(buffer, " lcd_out : %i", &value) == 1)\r\nlcd_out = value & 1;\r\nelse if (sscanf(buffer, " crt_out : %i", &value) == 1)\r\ncrt_out = value & 1;\r\nelse if (sscanf(buffer, " tv_out : %i", &value) == 1)\r\ntv_out = value & 1;\r\ndo {\r\n++buffer;\r\n--remain;\r\n}\r\nwhile (remain && *(buffer - 1) != ';');\r\n}\r\nkfree(cmd);\r\nret = get_video_status(dev, &video_out);\r\nif (!ret) {\r\nunsigned int new_video_out = video_out;\r\nif (lcd_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_LCD, lcd_out);\r\nif (crt_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_CRT, crt_out);\r\nif (tv_out != -1)\r\n_set_bit(&new_video_out, HCI_VIDEO_OUT_TV, tv_out);\r\nif (new_video_out != video_out)\r\nret = write_acpi_int(METHOD_VIDEO_OUT, new_video_out);\r\n}\r\nreturn ret ? ret : count;\r\n}\r\nstatic int get_fan_status(struct toshiba_acpi_dev *dev, u32 *status)\r\n{\r\nu32 hci_result;\r\nhci_read1(dev, HCI_FAN, status, &hci_result);\r\nreturn hci_result == HCI_SUCCESS ? 0 : -EIO;\r\n}\r\nstatic int fan_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nint ret;\r\nu32 value;\r\nret = get_fan_status(dev, &value);\r\nif (!ret) {\r\nseq_printf(m, "running: %d\n", (value > 0));\r\nseq_printf(m, "force_on: %d\n", dev->force_fan);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fan_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fan_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t fan_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nu32 hci_result;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " force_on : %i", &value) == 1 &&\r\nvalue >= 0 && value <= 1) {\r\nhci_write1(dev, HCI_FAN, value, &hci_result);\r\nif (hci_result != HCI_SUCCESS)\r\nreturn -EIO;\r\nelse\r\ndev->force_fan = value;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int keys_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct toshiba_acpi_dev *dev = m->private;\r\nu32 hci_result;\r\nu32 value;\r\nif (!dev->key_event_valid && dev->system_event_supported) {\r\nhci_read1(dev, HCI_SYSTEM_EVENT, &value, &hci_result);\r\nif (hci_result == HCI_SUCCESS) {\r\ndev->key_event_valid = 1;\r\ndev->last_key_event = value;\r\n} else if (hci_result == HCI_EMPTY) {\r\n} else if (hci_result == HCI_NOT_SUPPORTED) {\r\nhci_write1(dev, HCI_SYSTEM_EVENT, 1, &hci_result);\r\npr_notice("Re-enabled hotkeys\n");\r\n} else {\r\npr_err("Error reading hotkey status\n");\r\nreturn -EIO;\r\n}\r\n}\r\nseq_printf(m, "hotkey_ready: %d\n", dev->key_event_valid);\r\nseq_printf(m, "hotkey: 0x%04x\n", dev->last_key_event);\r\nreturn 0;\r\n}\r\nstatic int keys_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, keys_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t keys_proc_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));\r\nchar cmd[42];\r\nsize_t len;\r\nint value;\r\nlen = min(count, sizeof(cmd) - 1);\r\nif (copy_from_user(cmd, buf, len))\r\nreturn -EFAULT;\r\ncmd[len] = '\0';\r\nif (sscanf(cmd, " hotkey_ready : %i", &value) == 1 && value == 0) {\r\ndev->key_event_valid = 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int version_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "driver: %s\n", TOSHIBA_ACPI_VERSION);\r\nseq_printf(m, "proc_interface: %d\n", PROC_INTERFACE_VERSION);\r\nreturn 0;\r\n}\r\nstatic int version_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, version_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void create_toshiba_proc_entries(struct toshiba_acpi_dev *dev)\r\n{\r\nif (dev->backlight_dev)\r\nproc_create_data("lcd", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&lcd_proc_fops, dev);\r\nif (dev->video_supported)\r\nproc_create_data("video", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&video_proc_fops, dev);\r\nif (dev->fan_supported)\r\nproc_create_data("fan", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&fan_proc_fops, dev);\r\nif (dev->hotkey_dev)\r\nproc_create_data("keys", S_IRUGO | S_IWUSR, toshiba_proc_dir,\r\n&keys_proc_fops, dev);\r\nproc_create_data("version", S_IRUGO, toshiba_proc_dir,\r\n&version_proc_fops, dev);\r\n}\r\nstatic void remove_toshiba_proc_entries(struct toshiba_acpi_dev *dev)\r\n{\r\nif (dev->backlight_dev)\r\nremove_proc_entry("lcd", toshiba_proc_dir);\r\nif (dev->video_supported)\r\nremove_proc_entry("video", toshiba_proc_dir);\r\nif (dev->fan_supported)\r\nremove_proc_entry("fan", toshiba_proc_dir);\r\nif (dev->hotkey_dev)\r\nremove_proc_entry("keys", toshiba_proc_dir);\r\nremove_proc_entry("version", toshiba_proc_dir);\r\n}\r\nstatic bool toshiba_acpi_i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *port)\r\n{\r\nif (str & 0x20)\r\nreturn false;\r\nif (unlikely(data == 0xe0))\r\nreturn false;\r\nif ((data & 0x7f) == TOS1900_FN_SCAN) {\r\nschedule_work(&toshiba_acpi->hotkey_work);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void toshiba_acpi_hotkey_work(struct work_struct *work)\r\n{\r\nacpi_handle ec_handle = ec_get_handle();\r\nacpi_status status;\r\nif (!ec_handle)\r\nreturn;\r\nstatus = acpi_evaluate_object(ec_handle, "NTFY", NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_err("ACPI NTFY method execution failed\n");\r\n}\r\nstatic int toshiba_acpi_query_hotkey(struct toshiba_acpi_dev *dev)\r\n{\r\nstruct acpi_buffer buf;\r\nunion acpi_object out_obj;\r\nacpi_status status;\r\nbuf.pointer = &out_obj;\r\nbuf.length = sizeof(out_obj);\r\nstatus = acpi_evaluate_object(dev->acpi_dev->handle, "INFO",\r\nNULL, &buf);\r\nif (ACPI_FAILURE(status) || out_obj.type != ACPI_TYPE_INTEGER) {\r\npr_err("ACPI INFO method execution failed\n");\r\nreturn -EIO;\r\n}\r\nreturn out_obj.integer.value;\r\n}\r\nstatic void toshiba_acpi_report_hotkey(struct toshiba_acpi_dev *dev,\r\nint scancode)\r\n{\r\nif (scancode == 0x100)\r\nreturn;\r\nif (scancode & 0x80)\r\nreturn;\r\nif (!sparse_keymap_report_event(dev->hotkey_dev, scancode, 1, true))\r\npr_info("Unknown key %x\n", scancode);\r\n}\r\nstatic int toshiba_acpi_setup_keyboard(struct toshiba_acpi_dev *dev)\r\n{\r\nacpi_status status;\r\nacpi_handle ec_handle, handle;\r\nint error;\r\nu32 hci_result;\r\ndev->hotkey_dev = input_allocate_device();\r\nif (!dev->hotkey_dev) {\r\npr_info("Unable to register input device\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->hotkey_dev->name = "Toshiba input device";\r\ndev->hotkey_dev->phys = "toshiba_acpi/input0";\r\ndev->hotkey_dev->id.bustype = BUS_HOST;\r\nerror = sparse_keymap_setup(dev->hotkey_dev, toshiba_acpi_keymap, NULL);\r\nif (error)\r\ngoto err_free_dev;\r\nstatus = AE_ERROR;\r\nec_handle = ec_get_handle();\r\nif (ec_handle)\r\nstatus = acpi_get_handle(ec_handle, "NTFY", &handle);\r\nif (ACPI_SUCCESS(status)) {\r\nINIT_WORK(&dev->hotkey_work, toshiba_acpi_hotkey_work);\r\nerror = i8042_install_filter(toshiba_acpi_i8042_filter);\r\nif (error) {\r\npr_err("Error installing key filter\n");\r\ngoto err_free_keymap;\r\n}\r\ndev->ntfy_supported = 1;\r\n}\r\nstatus = acpi_get_handle(dev->acpi_dev->handle, "INFO", &handle);\r\nif (ACPI_SUCCESS(status)) {\r\ndev->info_supported = 1;\r\n} else {\r\nhci_write1(dev, HCI_SYSTEM_EVENT, 1, &hci_result);\r\nif (hci_result == HCI_SUCCESS)\r\ndev->system_event_supported = 1;\r\n}\r\nif (!dev->info_supported && !dev->system_event_supported) {\r\npr_warn("No hotkey query interface found\n");\r\ngoto err_remove_filter;\r\n}\r\nstatus = acpi_evaluate_object(dev->acpi_dev->handle, "ENAB", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_info("Unable to enable hotkeys\n");\r\nerror = -ENODEV;\r\ngoto err_remove_filter;\r\n}\r\nerror = input_register_device(dev->hotkey_dev);\r\nif (error) {\r\npr_info("Unable to register input device\n");\r\ngoto err_remove_filter;\r\n}\r\nhci_write1(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_ENABLE, &hci_result);\r\nreturn 0;\r\nerr_remove_filter:\r\nif (dev->ntfy_supported)\r\ni8042_remove_filter(toshiba_acpi_i8042_filter);\r\nerr_free_keymap:\r\nsparse_keymap_free(dev->hotkey_dev);\r\nerr_free_dev:\r\ninput_free_device(dev->hotkey_dev);\r\ndev->hotkey_dev = NULL;\r\nreturn error;\r\n}\r\nstatic int toshiba_acpi_setup_backlight(struct toshiba_acpi_dev *dev)\r\n{\r\nstruct backlight_properties props;\r\nint brightness;\r\nint ret;\r\nbool enabled;\r\nbrightness = __get_lcd_brightness(dev);\r\nif (brightness < 0)\r\nreturn 0;\r\nret = set_lcd_brightness(dev, brightness);\r\nif (ret) {\r\npr_debug("Backlight method is read-only, disabling backlight support\n");\r\nreturn 0;\r\n}\r\nret = get_tr_backlight_status(dev, &enabled);\r\ndev->tr_backlight_supported = !ret;\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = HCI_LCD_BRIGHTNESS_LEVELS - 1;\r\nif (dev->tr_backlight_supported)\r\nprops.max_brightness++;\r\ndev->backlight_dev = backlight_device_register("toshiba",\r\n&dev->acpi_dev->dev,\r\ndev,\r\n&toshiba_backlight_data,\r\n&props);\r\nif (IS_ERR(dev->backlight_dev)) {\r\nret = PTR_ERR(dev->backlight_dev);\r\npr_err("Could not register toshiba backlight device\n");\r\ndev->backlight_dev = NULL;\r\nreturn ret;\r\n}\r\ndev->backlight_dev->props.brightness = brightness;\r\nreturn 0;\r\n}\r\nstatic int toshiba_acpi_remove(struct acpi_device *acpi_dev)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(acpi_dev);\r\nremove_toshiba_proc_entries(dev);\r\nif (dev->ntfy_supported) {\r\ni8042_remove_filter(toshiba_acpi_i8042_filter);\r\ncancel_work_sync(&dev->hotkey_work);\r\n}\r\nif (dev->hotkey_dev) {\r\ninput_unregister_device(dev->hotkey_dev);\r\nsparse_keymap_free(dev->hotkey_dev);\r\n}\r\nif (dev->bt_rfk) {\r\nrfkill_unregister(dev->bt_rfk);\r\nrfkill_destroy(dev->bt_rfk);\r\n}\r\nif (dev->backlight_dev)\r\nbacklight_device_unregister(dev->backlight_dev);\r\nif (dev->illumination_supported)\r\nled_classdev_unregister(&dev->led_dev);\r\nif (toshiba_acpi)\r\ntoshiba_acpi = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic const char *find_hci_method(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nacpi_handle hci_handle;\r\nstatus = acpi_get_handle(handle, "GHCI", &hci_handle);\r\nif (ACPI_SUCCESS(status))\r\nreturn "GHCI";\r\nstatus = acpi_get_handle(handle, "SPFC", &hci_handle);\r\nif (ACPI_SUCCESS(status))\r\nreturn "SPFC";\r\nreturn NULL;\r\n}\r\nstatic int toshiba_acpi_add(struct acpi_device *acpi_dev)\r\n{\r\nstruct toshiba_acpi_dev *dev;\r\nconst char *hci_method;\r\nu32 dummy;\r\nbool bt_present;\r\nint ret = 0;\r\nif (toshiba_acpi)\r\nreturn -EBUSY;\r\npr_info("Toshiba Laptop ACPI Extras version %s\n",\r\nTOSHIBA_ACPI_VERSION);\r\nhci_method = find_hci_method(acpi_dev->handle);\r\nif (!hci_method) {\r\npr_err("HCI interface not found\n");\r\nreturn -ENODEV;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->acpi_dev = acpi_dev;\r\ndev->method_hci = hci_method;\r\nacpi_dev->driver_data = dev;\r\nif (toshiba_acpi_setup_keyboard(dev))\r\npr_info("Unable to activate hotkeys\n");\r\nmutex_init(&dev->mutex);\r\nret = toshiba_acpi_setup_backlight(dev);\r\nif (ret)\r\ngoto error;\r\nif (hci_get_bt_present(dev, &bt_present) == HCI_SUCCESS && bt_present) {\r\ndev->bt_rfk = rfkill_alloc("Toshiba Bluetooth",\r\n&acpi_dev->dev,\r\nRFKILL_TYPE_BLUETOOTH,\r\n&toshiba_rfk_ops,\r\ndev);\r\nif (!dev->bt_rfk) {\r\npr_err("unable to allocate rfkill device\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = rfkill_register(dev->bt_rfk);\r\nif (ret) {\r\npr_err("unable to register rfkill device\n");\r\nrfkill_destroy(dev->bt_rfk);\r\ngoto error;\r\n}\r\n}\r\nif (toshiba_illumination_available(dev)) {\r\ndev->led_dev.name = "toshiba::illumination";\r\ndev->led_dev.max_brightness = 1;\r\ndev->led_dev.brightness_set = toshiba_illumination_set;\r\ndev->led_dev.brightness_get = toshiba_illumination_get;\r\nif (!led_classdev_register(&acpi_dev->dev, &dev->led_dev))\r\ndev->illumination_supported = 1;\r\n}\r\nret = get_video_status(dev, &dummy);\r\ndev->video_supported = !ret;\r\nret = get_fan_status(dev, &dummy);\r\ndev->fan_supported = !ret;\r\ncreate_toshiba_proc_entries(dev);\r\ntoshiba_acpi = dev;\r\nreturn 0;\r\nerror:\r\ntoshiba_acpi_remove(acpi_dev);\r\nreturn ret;\r\n}\r\nstatic void toshiba_acpi_notify(struct acpi_device *acpi_dev, u32 event)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(acpi_dev);\r\nu32 hci_result, value;\r\nint retries = 3;\r\nint scancode;\r\nif (event != 0x80)\r\nreturn;\r\nif (dev->info_supported) {\r\nscancode = toshiba_acpi_query_hotkey(dev);\r\nif (scancode < 0)\r\npr_err("Failed to query hotkey event\n");\r\nelse if (scancode != 0)\r\ntoshiba_acpi_report_hotkey(dev, scancode);\r\n} else if (dev->system_event_supported) {\r\ndo {\r\nhci_read1(dev, HCI_SYSTEM_EVENT, &value, &hci_result);\r\nswitch (hci_result) {\r\ncase HCI_SUCCESS:\r\ntoshiba_acpi_report_hotkey(dev, (int)value);\r\nbreak;\r\ncase HCI_NOT_SUPPORTED:\r\nhci_write1(dev, HCI_SYSTEM_EVENT, 1,\r\n&hci_result);\r\npr_notice("Re-enabled hotkeys\n");\r\ndefault:\r\nretries--;\r\nbreak;\r\n}\r\n} while (retries && hci_result != HCI_EMPTY);\r\n}\r\n}\r\nstatic int toshiba_acpi_suspend(struct device *device)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(to_acpi_device(device));\r\nu32 result;\r\nif (dev->hotkey_dev)\r\nhci_write1(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_DISABLE, &result);\r\nreturn 0;\r\n}\r\nstatic int toshiba_acpi_resume(struct device *device)\r\n{\r\nstruct toshiba_acpi_dev *dev = acpi_driver_data(to_acpi_device(device));\r\nu32 result;\r\nif (dev->hotkey_dev)\r\nhci_write1(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_ENABLE, &result);\r\nreturn 0;\r\n}\r\nstatic int __init toshiba_acpi_init(void)\r\n{\r\nint ret;\r\nif (wmi_has_guid(TOSHIBA_WMI_EVENT_GUID))\r\nreturn -ENODEV;\r\ntoshiba_proc_dir = proc_mkdir(PROC_TOSHIBA, acpi_root_dir);\r\nif (!toshiba_proc_dir) {\r\npr_err("Unable to create proc dir " PROC_TOSHIBA "\n");\r\nreturn -ENODEV;\r\n}\r\nret = acpi_bus_register_driver(&toshiba_acpi_driver);\r\nif (ret) {\r\npr_err("Failed to register ACPI driver: %d\n", ret);\r\nremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit toshiba_acpi_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&toshiba_acpi_driver);\r\nif (toshiba_proc_dir)\r\nremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\r\n}
