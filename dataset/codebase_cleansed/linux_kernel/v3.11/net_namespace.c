static struct net_generic *net_alloc_generic(void)\r\n{\r\nstruct net_generic *ng;\r\nsize_t generic_size = offsetof(struct net_generic, ptr[max_gen_ptrs]);\r\nng = kzalloc(generic_size, GFP_KERNEL);\r\nif (ng)\r\nng->len = max_gen_ptrs;\r\nreturn ng;\r\n}\r\nstatic int net_assign_generic(struct net *net, int id, void *data)\r\n{\r\nstruct net_generic *ng, *old_ng;\r\nBUG_ON(!mutex_is_locked(&net_mutex));\r\nBUG_ON(id == 0);\r\nold_ng = rcu_dereference_protected(net->gen,\r\nlockdep_is_held(&net_mutex));\r\nng = old_ng;\r\nif (old_ng->len >= id)\r\ngoto assign;\r\nng = net_alloc_generic();\r\nif (ng == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(&ng->ptr, &old_ng->ptr, old_ng->len * sizeof(void*));\r\nrcu_assign_pointer(net->gen, ng);\r\nkfree_rcu(old_ng, rcu);\r\nassign:\r\nng->ptr[id - 1] = data;\r\nreturn 0;\r\n}\r\nstatic int ops_init(const struct pernet_operations *ops, struct net *net)\r\n{\r\nint err = -ENOMEM;\r\nvoid *data = NULL;\r\nif (ops->id && ops->size) {\r\ndata = kzalloc(ops->size, GFP_KERNEL);\r\nif (!data)\r\ngoto out;\r\nerr = net_assign_generic(net, *ops->id, data);\r\nif (err)\r\ngoto cleanup;\r\n}\r\nerr = 0;\r\nif (ops->init)\r\nerr = ops->init(net);\r\nif (!err)\r\nreturn 0;\r\ncleanup:\r\nkfree(data);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ops_free(const struct pernet_operations *ops, struct net *net)\r\n{\r\nif (ops->id && ops->size) {\r\nint id = *ops->id;\r\nkfree(net_generic(net, id));\r\n}\r\n}\r\nstatic void ops_exit_list(const struct pernet_operations *ops,\r\nstruct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nif (ops->exit) {\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nops->exit(net);\r\n}\r\nif (ops->exit_batch)\r\nops->exit_batch(net_exit_list);\r\n}\r\nstatic void ops_free_list(const struct pernet_operations *ops,\r\nstruct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nif (ops->size && ops->id) {\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nops_free(ops, net);\r\n}\r\n}\r\nstatic __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\r\n{\r\nconst struct pernet_operations *ops, *saved_ops;\r\nint error = 0;\r\nLIST_HEAD(net_exit_list);\r\natomic_set(&net->count, 1);\r\natomic_set(&net->passive, 1);\r\nnet->dev_base_seq = 1;\r\nnet->user_ns = user_ns;\r\n#ifdef NETNS_REFCNT_DEBUG\r\natomic_set(&net->use_count, 0);\r\n#endif\r\nlist_for_each_entry(ops, &pernet_list, list) {\r\nerror = ops_init(ops, net);\r\nif (error < 0)\r\ngoto out_undo;\r\n}\r\nout:\r\nreturn error;\r\nout_undo:\r\nlist_add(&net->exit_list, &net_exit_list);\r\nsaved_ops = ops;\r\nlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\r\nops_exit_list(ops, &net_exit_list);\r\nops = saved_ops;\r\nlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\r\nops_free_list(ops, &net_exit_list);\r\nrcu_barrier();\r\ngoto out;\r\n}\r\nstatic struct net *net_alloc(void)\r\n{\r\nstruct net *net = NULL;\r\nstruct net_generic *ng;\r\nng = net_alloc_generic();\r\nif (!ng)\r\ngoto out;\r\nnet = kmem_cache_zalloc(net_cachep, GFP_KERNEL);\r\nif (!net)\r\ngoto out_free;\r\nrcu_assign_pointer(net->gen, ng);\r\nout:\r\nreturn net;\r\nout_free:\r\nkfree(ng);\r\ngoto out;\r\n}\r\nstatic void net_free(struct net *net)\r\n{\r\n#ifdef NETNS_REFCNT_DEBUG\r\nif (unlikely(atomic_read(&net->use_count) != 0)) {\r\npr_emerg("network namespace not free! Usage: %d\n",\r\natomic_read(&net->use_count));\r\nreturn;\r\n}\r\n#endif\r\nkfree(net->gen);\r\nkmem_cache_free(net_cachep, net);\r\n}\r\nvoid net_drop_ns(void *p)\r\n{\r\nstruct net *ns = p;\r\nif (ns && atomic_dec_and_test(&ns->passive))\r\nnet_free(ns);\r\n}\r\nstruct net *copy_net_ns(unsigned long flags,\r\nstruct user_namespace *user_ns, struct net *old_net)\r\n{\r\nstruct net *net;\r\nint rv;\r\nif (!(flags & CLONE_NEWNET))\r\nreturn get_net(old_net);\r\nnet = net_alloc();\r\nif (!net)\r\nreturn ERR_PTR(-ENOMEM);\r\nget_user_ns(user_ns);\r\nmutex_lock(&net_mutex);\r\nrv = setup_net(net, user_ns);\r\nif (rv == 0) {\r\nrtnl_lock();\r\nlist_add_tail_rcu(&net->list, &net_namespace_list);\r\nrtnl_unlock();\r\n}\r\nmutex_unlock(&net_mutex);\r\nif (rv < 0) {\r\nput_user_ns(user_ns);\r\nnet_drop_ns(net);\r\nreturn ERR_PTR(rv);\r\n}\r\nreturn net;\r\n}\r\nstatic void cleanup_net(struct work_struct *work)\r\n{\r\nconst struct pernet_operations *ops;\r\nstruct net *net, *tmp;\r\nLIST_HEAD(net_kill_list);\r\nLIST_HEAD(net_exit_list);\r\nspin_lock_irq(&cleanup_list_lock);\r\nlist_replace_init(&cleanup_list, &net_kill_list);\r\nspin_unlock_irq(&cleanup_list_lock);\r\nmutex_lock(&net_mutex);\r\nrtnl_lock();\r\nlist_for_each_entry(net, &net_kill_list, cleanup_list) {\r\nlist_del_rcu(&net->list);\r\nlist_add_tail(&net->exit_list, &net_exit_list);\r\n}\r\nrtnl_unlock();\r\nsynchronize_rcu();\r\nlist_for_each_entry_reverse(ops, &pernet_list, list)\r\nops_exit_list(ops, &net_exit_list);\r\nlist_for_each_entry_reverse(ops, &pernet_list, list)\r\nops_free_list(ops, &net_exit_list);\r\nmutex_unlock(&net_mutex);\r\nrcu_barrier();\r\nlist_for_each_entry_safe(net, tmp, &net_exit_list, exit_list) {\r\nlist_del_init(&net->exit_list);\r\nput_user_ns(net->user_ns);\r\nnet_drop_ns(net);\r\n}\r\n}\r\nvoid __put_net(struct net *net)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cleanup_list_lock, flags);\r\nlist_add(&net->cleanup_list, &cleanup_list);\r\nspin_unlock_irqrestore(&cleanup_list_lock, flags);\r\nqueue_work(netns_wq, &net_cleanup_work);\r\n}\r\nstruct net *get_net_ns_by_fd(int fd)\r\n{\r\nstruct proc_ns *ei;\r\nstruct file *file;\r\nstruct net *net;\r\nfile = proc_ns_fget(fd);\r\nif (IS_ERR(file))\r\nreturn ERR_CAST(file);\r\nei = get_proc_ns(file_inode(file));\r\nif (ei->ns_ops == &netns_operations)\r\nnet = get_net(ei->ns);\r\nelse\r\nnet = ERR_PTR(-EINVAL);\r\nfput(file);\r\nreturn net;\r\n}\r\nstruct net *get_net_ns_by_fd(int fd)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstruct net *get_net_ns_by_pid(pid_t pid)\r\n{\r\nstruct task_struct *tsk;\r\nstruct net *net;\r\nnet = ERR_PTR(-ESRCH);\r\nrcu_read_lock();\r\ntsk = find_task_by_vpid(pid);\r\nif (tsk) {\r\nstruct nsproxy *nsproxy;\r\nnsproxy = task_nsproxy(tsk);\r\nif (nsproxy)\r\nnet = get_net(nsproxy->net_ns);\r\n}\r\nrcu_read_unlock();\r\nreturn net;\r\n}\r\nstatic __net_init int net_ns_net_init(struct net *net)\r\n{\r\nreturn proc_alloc_inum(&net->proc_inum);\r\n}\r\nstatic __net_exit void net_ns_net_exit(struct net *net)\r\n{\r\nproc_free_inum(net->proc_inum);\r\n}\r\nstatic int __init net_ns_init(void)\r\n{\r\nstruct net_generic *ng;\r\n#ifdef CONFIG_NET_NS\r\nnet_cachep = kmem_cache_create("net_namespace", sizeof(struct net),\r\nSMP_CACHE_BYTES,\r\nSLAB_PANIC, NULL);\r\nnetns_wq = create_singlethread_workqueue("netns");\r\nif (!netns_wq)\r\npanic("Could not create netns workq");\r\n#endif\r\nng = net_alloc_generic();\r\nif (!ng)\r\npanic("Could not allocate generic netns");\r\nrcu_assign_pointer(init_net.gen, ng);\r\nmutex_lock(&net_mutex);\r\nif (setup_net(&init_net, &init_user_ns))\r\npanic("Could not setup the initial network namespace");\r\nrtnl_lock();\r\nlist_add_tail_rcu(&init_net.list, &net_namespace_list);\r\nrtnl_unlock();\r\nmutex_unlock(&net_mutex);\r\nregister_pernet_subsys(&net_ns_ops);\r\nreturn 0;\r\n}\r\nstatic int __register_pernet_operations(struct list_head *list,\r\nstruct pernet_operations *ops)\r\n{\r\nstruct net *net;\r\nint error;\r\nLIST_HEAD(net_exit_list);\r\nlist_add_tail(&ops->list, list);\r\nif (ops->init || (ops->id && ops->size)) {\r\nfor_each_net(net) {\r\nerror = ops_init(ops, net);\r\nif (error)\r\ngoto out_undo;\r\nlist_add_tail(&net->exit_list, &net_exit_list);\r\n}\r\n}\r\nreturn 0;\r\nout_undo:\r\nlist_del(&ops->list);\r\nops_exit_list(ops, &net_exit_list);\r\nops_free_list(ops, &net_exit_list);\r\nreturn error;\r\n}\r\nstatic void __unregister_pernet_operations(struct pernet_operations *ops)\r\n{\r\nstruct net *net;\r\nLIST_HEAD(net_exit_list);\r\nlist_del(&ops->list);\r\nfor_each_net(net)\r\nlist_add_tail(&net->exit_list, &net_exit_list);\r\nops_exit_list(ops, &net_exit_list);\r\nops_free_list(ops, &net_exit_list);\r\n}\r\nstatic int __register_pernet_operations(struct list_head *list,\r\nstruct pernet_operations *ops)\r\n{\r\nreturn ops_init(ops, &init_net);\r\n}\r\nstatic void __unregister_pernet_operations(struct pernet_operations *ops)\r\n{\r\nLIST_HEAD(net_exit_list);\r\nlist_add(&init_net.exit_list, &net_exit_list);\r\nops_exit_list(ops, &net_exit_list);\r\nops_free_list(ops, &net_exit_list);\r\n}\r\nstatic int register_pernet_operations(struct list_head *list,\r\nstruct pernet_operations *ops)\r\n{\r\nint error;\r\nif (ops->id) {\r\nagain:\r\nerror = ida_get_new_above(&net_generic_ids, 1, ops->id);\r\nif (error < 0) {\r\nif (error == -EAGAIN) {\r\nida_pre_get(&net_generic_ids, GFP_KERNEL);\r\ngoto again;\r\n}\r\nreturn error;\r\n}\r\nmax_gen_ptrs = max_t(unsigned int, max_gen_ptrs, *ops->id);\r\n}\r\nerror = __register_pernet_operations(list, ops);\r\nif (error) {\r\nrcu_barrier();\r\nif (ops->id)\r\nida_remove(&net_generic_ids, *ops->id);\r\n}\r\nreturn error;\r\n}\r\nstatic void unregister_pernet_operations(struct pernet_operations *ops)\r\n{\r\n__unregister_pernet_operations(ops);\r\nrcu_barrier();\r\nif (ops->id)\r\nida_remove(&net_generic_ids, *ops->id);\r\n}\r\nint register_pernet_subsys(struct pernet_operations *ops)\r\n{\r\nint error;\r\nmutex_lock(&net_mutex);\r\nerror = register_pernet_operations(first_device, ops);\r\nmutex_unlock(&net_mutex);\r\nreturn error;\r\n}\r\nvoid unregister_pernet_subsys(struct pernet_operations *ops)\r\n{\r\nmutex_lock(&net_mutex);\r\nunregister_pernet_operations(ops);\r\nmutex_unlock(&net_mutex);\r\n}\r\nint register_pernet_device(struct pernet_operations *ops)\r\n{\r\nint error;\r\nmutex_lock(&net_mutex);\r\nerror = register_pernet_operations(&pernet_list, ops);\r\nif (!error && (first_device == &pernet_list))\r\nfirst_device = &ops->list;\r\nmutex_unlock(&net_mutex);\r\nreturn error;\r\n}\r\nvoid unregister_pernet_device(struct pernet_operations *ops)\r\n{\r\nmutex_lock(&net_mutex);\r\nif (&ops->list == first_device)\r\nfirst_device = first_device->next;\r\nunregister_pernet_operations(ops);\r\nmutex_unlock(&net_mutex);\r\n}\r\nstatic void *netns_get(struct task_struct *task)\r\n{\r\nstruct net *net = NULL;\r\nstruct nsproxy *nsproxy;\r\nrcu_read_lock();\r\nnsproxy = task_nsproxy(task);\r\nif (nsproxy)\r\nnet = get_net(nsproxy->net_ns);\r\nrcu_read_unlock();\r\nreturn net;\r\n}\r\nstatic void netns_put(void *ns)\r\n{\r\nput_net(ns);\r\n}\r\nstatic int netns_install(struct nsproxy *nsproxy, void *ns)\r\n{\r\nstruct net *net = ns;\r\nif (!ns_capable(net->user_ns, CAP_SYS_ADMIN) ||\r\n!nsown_capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nput_net(nsproxy->net_ns);\r\nnsproxy->net_ns = get_net(net);\r\nreturn 0;\r\n}\r\nstatic unsigned int netns_inum(void *ns)\r\n{\r\nstruct net *net = ns;\r\nreturn net->proc_inum;\r\n}
