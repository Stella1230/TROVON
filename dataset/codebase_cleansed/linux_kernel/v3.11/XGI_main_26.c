static void dumpVGAReg(void)\r\n{\r\nu8 i, reg;\r\nxgifb_reg_set(XGISR, 0x05, 0x86);\r\nfor (i = 0; i < 0x4f; i++) {\r\nreg = xgifb_reg_get(XGISR, i);\r\npr_debug("o 3c4 %x\n", i);\r\npr_debug("i 3c5 => %x\n", reg);\r\n}\r\nfor (i = 0; i < 0xF0; i++) {\r\nreg = xgifb_reg_get(XGICR, i);\r\npr_debug("o 3d4 %x\n", i);\r\npr_debug("i 3d5 => %x\n", reg);\r\n}\r\n}\r\nstatic inline void dumpVGAReg(void)\r\n{\r\n}\r\nstatic int XGIfb_mode_rate_to_dclock(struct vb_device_info *XGI_Pr,\r\nstruct xgi_hw_device_info *HwDeviceExtension,\r\nunsigned char modeno, unsigned char rateindex)\r\n{\r\nunsigned short ModeNo = modeno;\r\nunsigned short ModeIdIndex = 0, ClockIndex = 0;\r\nunsigned short RefreshRateTableIndex = 0;\r\nint Clock;\r\nInitTo330Pointer(HwDeviceExtension->jChipType, XGI_Pr);\r\nXGI_SearchModeID(ModeNo, &ModeIdIndex, XGI_Pr);\r\nRefreshRateTableIndex = XGI_GetRatePtrCRT2(HwDeviceExtension, ModeNo,\r\nModeIdIndex, XGI_Pr);\r\nClockIndex = XGI330_RefIndex[RefreshRateTableIndex].Ext_CRTVCLK;\r\nClock = XGI_VCLKData[ClockIndex].CLOCK * 1000;\r\nreturn Clock;\r\n}\r\nstatic int XGIfb_mode_rate_to_ddata(struct vb_device_info *XGI_Pr,\r\nstruct xgi_hw_device_info *HwDeviceExtension,\r\nunsigned char modeno, unsigned char rateindex,\r\nu32 *left_margin, u32 *right_margin, u32 *upper_margin,\r\nu32 *lower_margin, u32 *hsync_len, u32 *vsync_len, u32 *sync,\r\nu32 *vmode)\r\n{\r\nunsigned short ModeNo = modeno;\r\nunsigned short ModeIdIndex, index = 0;\r\nunsigned short RefreshRateTableIndex = 0;\r\nunsigned short VRE, VBE, VRS, VDE;\r\nunsigned short HRE, HBE, HRS, HDE;\r\nunsigned char sr_data, cr_data, cr_data2;\r\nint B, C, D, F, temp, j;\r\nInitTo330Pointer(HwDeviceExtension->jChipType, XGI_Pr);\r\nif (!XGI_SearchModeID(ModeNo, &ModeIdIndex, XGI_Pr))\r\nreturn 0;\r\nRefreshRateTableIndex = XGI_GetRatePtrCRT2(HwDeviceExtension, ModeNo,\r\nModeIdIndex, XGI_Pr);\r\nindex = XGI330_RefIndex[RefreshRateTableIndex].Ext_CRT1CRTC;\r\nsr_data = XGI_CRT1Table[index].CR[5];\r\nHDE = (XGI330_RefIndex[RefreshRateTableIndex].XRes >> 3);\r\ncr_data = XGI_CRT1Table[index].CR[3];\r\nHRS = (cr_data & 0xff) | ((unsigned short) (sr_data & 0xC0) << 2);\r\nF = HRS - HDE - 3;\r\nsr_data = XGI_CRT1Table[index].CR[6];\r\ncr_data = XGI_CRT1Table[index].CR[2];\r\ncr_data2 = XGI_CRT1Table[index].CR[4];\r\nHBE = (cr_data & 0x1f) | ((unsigned short) (cr_data2 & 0x80) >> 2)\r\n| ((unsigned short) (sr_data & 0x03) << 6);\r\nHRE = (cr_data2 & 0x1f) | ((sr_data & 0x04) << 3);\r\ntemp = HBE - ((HDE - 1) & 255);\r\nB = (temp > 0) ? temp : (temp + 256);\r\ntemp = HRE - ((HDE + F + 3) & 63);\r\nC = (temp > 0) ? temp : (temp + 64);\r\nD = B - F - C;\r\n*left_margin = D * 8;\r\n*right_margin = F * 8;\r\n*hsync_len = C * 8;\r\nsr_data = XGI_CRT1Table[index].CR[14];\r\ncr_data2 = XGI_CRT1Table[index].CR[9];\r\nVDE = XGI330_RefIndex[RefreshRateTableIndex].YRes;\r\ncr_data = XGI_CRT1Table[index].CR[10];\r\nVRS = (cr_data & 0xff) | ((unsigned short) (cr_data2 & 0x04) << 6)\r\n| ((unsigned short) (cr_data2 & 0x80) << 2)\r\n| ((unsigned short) (sr_data & 0x08) << 7);\r\nF = VRS + 1 - VDE;\r\ncr_data = XGI_CRT1Table[index].CR[13];\r\nVBE = (cr_data & 0xff) | ((unsigned short) (sr_data & 0x10) << 4);\r\ntemp = VBE - ((VDE - 1) & 511);\r\nB = (temp > 0) ? temp : (temp + 512);\r\ncr_data = XGI_CRT1Table[index].CR[11];\r\nVRE = (cr_data & 0x0f) | ((sr_data & 0x20) >> 1);\r\ntemp = VRE - ((VDE + F - 1) & 31);\r\nC = (temp > 0) ? temp : (temp + 32);\r\nD = B - F - C;\r\n*upper_margin = D;\r\n*lower_margin = F;\r\n*vsync_len = C;\r\nif (XGI330_RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x8000)\r\n*sync &= ~FB_SYNC_VERT_HIGH_ACT;\r\nelse\r\n*sync |= FB_SYNC_VERT_HIGH_ACT;\r\nif (XGI330_RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x4000)\r\n*sync &= ~FB_SYNC_HOR_HIGH_ACT;\r\nelse\r\n*sync |= FB_SYNC_HOR_HIGH_ACT;\r\n*vmode = FB_VMODE_NONINTERLACED;\r\nif (XGI330_RefIndex[RefreshRateTableIndex].Ext_InfoFlag & 0x0080)\r\n*vmode = FB_VMODE_INTERLACED;\r\nelse {\r\nj = 0;\r\nwhile (XGI330_EModeIDTable[j].Ext_ModeID != 0xff) {\r\nif (XGI330_EModeIDTable[j].Ext_ModeID ==\r\nXGI330_RefIndex[RefreshRateTableIndex].ModeID) {\r\nif (XGI330_EModeIDTable[j].Ext_ModeFlag &\r\nDoubleScanMode) {\r\n*vmode = FB_VMODE_DOUBLE;\r\n}\r\nbreak;\r\n}\r\nj++;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid XGIRegInit(struct vb_device_info *XGI_Pr, unsigned long BaseAddr)\r\n{\r\nXGI_Pr->P3c4 = BaseAddr + 0x14;\r\nXGI_Pr->P3d4 = BaseAddr + 0x24;\r\nXGI_Pr->P3c0 = BaseAddr + 0x10;\r\nXGI_Pr->P3ce = BaseAddr + 0x1e;\r\nXGI_Pr->P3c2 = BaseAddr + 0x12;\r\nXGI_Pr->P3cc = BaseAddr + 0x1c;\r\nXGI_Pr->P3ca = BaseAddr + 0x1a;\r\nXGI_Pr->P3c6 = BaseAddr + 0x16;\r\nXGI_Pr->P3c7 = BaseAddr + 0x17;\r\nXGI_Pr->P3c8 = BaseAddr + 0x18;\r\nXGI_Pr->P3c9 = BaseAddr + 0x19;\r\nXGI_Pr->P3da = BaseAddr + 0x2A;\r\nXGI_Pr->Part1Port = BaseAddr + SIS_CRT2_PORT_04;\r\nXGI_Pr->Part2Port = BaseAddr + SIS_CRT2_PORT_10;\r\nXGI_Pr->Part3Port = BaseAddr + SIS_CRT2_PORT_12;\r\nXGI_Pr->Part4Port = BaseAddr + SIS_CRT2_PORT_14;\r\nXGI_Pr->Part5Port = BaseAddr + SIS_CRT2_PORT_14 + 2;\r\n}\r\nstatic int XGIfb_GetXG21DefaultLVDSModeIdx(struct xgifb_video_info *xgifb_info)\r\n{\r\nint i = 0;\r\nwhile ((XGIbios_mode[i].mode_no != 0)\r\n&& (XGIbios_mode[i].xres <= xgifb_info->lvds_data.LVDSHDE)) {\r\nif ((XGIbios_mode[i].xres == xgifb_info->lvds_data.LVDSHDE)\r\n&& (XGIbios_mode[i].yres == xgifb_info->lvds_data.LVDSVDE)\r\n&& (XGIbios_mode[i].bpp == 8)) {\r\nreturn i;\r\n}\r\ni++;\r\n}\r\nreturn -1;\r\n}\r\nstatic void XGIfb_search_mode(struct xgifb_video_info *xgifb_info,\r\nconst char *name)\r\n{\r\nunsigned int xres;\r\nunsigned int yres;\r\nunsigned int bpp;\r\nint i;\r\nif (sscanf(name, "%ux%ux%u", &xres, &yres, &bpp) != 3)\r\ngoto invalid_mode;\r\nif (bpp == 24)\r\nbpp = 32;\r\nfor (i = 0; XGIbios_mode[i].mode_no != 0; i++)\r\nif (XGIbios_mode[i].xres == xres &&\r\nXGIbios_mode[i].yres == yres &&\r\nXGIbios_mode[i].bpp == bpp) {\r\nxgifb_info->mode_idx = i;\r\nreturn;\r\n}\r\ninvalid_mode:\r\npr_info("Invalid mode '%s'\n", name);\r\n}\r\nstatic void XGIfb_search_vesamode(struct xgifb_video_info *xgifb_info,\r\nunsigned int vesamode)\r\n{\r\nint i = 0;\r\nif (vesamode == 0)\r\ngoto invalid;\r\nvesamode &= 0x1dff;\r\nwhile (XGIbios_mode[i].mode_no != 0) {\r\nif ((XGIbios_mode[i].vesa_mode_no_1 == vesamode) ||\r\n(XGIbios_mode[i].vesa_mode_no_2 == vesamode)) {\r\nxgifb_info->mode_idx = i;\r\nreturn;\r\n}\r\ni++;\r\n}\r\ninvalid:\r\npr_info("Invalid VESA mode 0x%x'\n", vesamode);\r\n}\r\nstatic int XGIfb_validate_mode(struct xgifb_video_info *xgifb_info, int myindex)\r\n{\r\nu16 xres, yres;\r\nstruct xgi_hw_device_info *hw_info = &xgifb_info->hw_info;\r\nunsigned long required_mem;\r\nif (xgifb_info->chip == XG21) {\r\nif (xgifb_info->display2 == XGIFB_DISP_LCD) {\r\nxres = xgifb_info->lvds_data.LVDSHDE;\r\nyres = xgifb_info->lvds_data.LVDSVDE;\r\nif (XGIbios_mode[myindex].xres > xres)\r\nreturn -1;\r\nif (XGIbios_mode[myindex].yres > yres)\r\nreturn -1;\r\nif ((XGIbios_mode[myindex].xres < xres) &&\r\n(XGIbios_mode[myindex].yres < yres)) {\r\nif (XGIbios_mode[myindex].bpp > 8)\r\nreturn -1;\r\n}\r\n}\r\ngoto check_memory;\r\n}\r\nif (xgifb_info->chip == XG27)\r\ngoto check_memory;\r\nif (!(XGIbios_mode[myindex].chipset & MD_XGI315))\r\nreturn -1;\r\nswitch (xgifb_info->display2) {\r\ncase XGIFB_DISP_LCD:\r\nswitch (hw_info->ulCRT2LCDType) {\r\ncase LCD_640x480:\r\nxres = 640;\r\nyres = 480;\r\nbreak;\r\ncase LCD_800x600:\r\nxres = 800;\r\nyres = 600;\r\nbreak;\r\ncase LCD_1024x600:\r\nxres = 1024;\r\nyres = 600;\r\nbreak;\r\ncase LCD_1024x768:\r\nxres = 1024;\r\nyres = 768;\r\nbreak;\r\ncase LCD_1152x768:\r\nxres = 1152;\r\nyres = 768;\r\nbreak;\r\ncase LCD_1280x960:\r\nxres = 1280;\r\nyres = 960;\r\nbreak;\r\ncase LCD_1280x768:\r\nxres = 1280;\r\nyres = 768;\r\nbreak;\r\ncase LCD_1280x1024:\r\nxres = 1280;\r\nyres = 1024;\r\nbreak;\r\ncase LCD_1400x1050:\r\nxres = 1400;\r\nyres = 1050;\r\nbreak;\r\ncase LCD_1600x1200:\r\nxres = 1600;\r\nyres = 1200;\r\nbreak;\r\ndefault:\r\nxres = 0;\r\nyres = 0;\r\nbreak;\r\n}\r\nif (XGIbios_mode[myindex].xres > xres)\r\nreturn -1;\r\nif (XGIbios_mode[myindex].yres > yres)\r\nreturn -1;\r\nif ((hw_info->ulExternalChip == 0x01) ||\r\n(hw_info->ulExternalChip == 0x05)) {\r\nswitch (XGIbios_mode[myindex].xres) {\r\ncase 512:\r\nif (XGIbios_mode[myindex].yres != 512)\r\nreturn -1;\r\nif (hw_info->ulCRT2LCDType == LCD_1024x600)\r\nreturn -1;\r\nbreak;\r\ncase 640:\r\nif ((XGIbios_mode[myindex].yres != 400)\r\n&& (XGIbios_mode[myindex].yres\r\n!= 480))\r\nreturn -1;\r\nbreak;\r\ncase 800:\r\nif (XGIbios_mode[myindex].yres != 600)\r\nreturn -1;\r\nbreak;\r\ncase 1024:\r\nif ((XGIbios_mode[myindex].yres != 600) &&\r\n(XGIbios_mode[myindex].yres != 768))\r\nreturn -1;\r\nif ((XGIbios_mode[myindex].yres == 600) &&\r\n(hw_info->ulCRT2LCDType != LCD_1024x600))\r\nreturn -1;\r\nbreak;\r\ncase 1152:\r\nif ((XGIbios_mode[myindex].yres) != 768)\r\nreturn -1;\r\nif (hw_info->ulCRT2LCDType != LCD_1152x768)\r\nreturn -1;\r\nbreak;\r\ncase 1280:\r\nif ((XGIbios_mode[myindex].yres != 768) &&\r\n(XGIbios_mode[myindex].yres != 1024))\r\nreturn -1;\r\nif ((XGIbios_mode[myindex].yres == 768) &&\r\n(hw_info->ulCRT2LCDType != LCD_1280x768))\r\nreturn -1;\r\nbreak;\r\ncase 1400:\r\nif (XGIbios_mode[myindex].yres != 1050)\r\nreturn -1;\r\nbreak;\r\ncase 1600:\r\nif (XGIbios_mode[myindex].yres != 1200)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n} else {\r\nswitch (XGIbios_mode[myindex].xres) {\r\ncase 512:\r\nif (XGIbios_mode[myindex].yres != 512)\r\nreturn -1;\r\nbreak;\r\ncase 640:\r\nif ((XGIbios_mode[myindex].yres != 400) &&\r\n(XGIbios_mode[myindex].yres != 480))\r\nreturn -1;\r\nbreak;\r\ncase 800:\r\nif (XGIbios_mode[myindex].yres != 600)\r\nreturn -1;\r\nbreak;\r\ncase 1024:\r\nif (XGIbios_mode[myindex].yres != 768)\r\nreturn -1;\r\nbreak;\r\ncase 1280:\r\nif ((XGIbios_mode[myindex].yres != 960) &&\r\n(XGIbios_mode[myindex].yres != 1024))\r\nreturn -1;\r\nif (XGIbios_mode[myindex].yres == 960) {\r\nif (hw_info->ulCRT2LCDType ==\r\nLCD_1400x1050)\r\nreturn -1;\r\n}\r\nbreak;\r\ncase 1400:\r\nif (XGIbios_mode[myindex].yres != 1050)\r\nreturn -1;\r\nbreak;\r\ncase 1600:\r\nif (XGIbios_mode[myindex].yres != 1200)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nbreak;\r\ncase XGIFB_DISP_TV:\r\nswitch (XGIbios_mode[myindex].xres) {\r\ncase 512:\r\ncase 640:\r\ncase 800:\r\nbreak;\r\ncase 720:\r\nif (xgifb_info->TV_type == TVMODE_NTSC) {\r\nif (XGIbios_mode[myindex].yres != 480)\r\nreturn -1;\r\n} else if (xgifb_info->TV_type == TVMODE_PAL) {\r\nif (XGIbios_mode[myindex].yres != 576)\r\nreturn -1;\r\n}\r\nif (xgifb_info->hasVB == HASVB_LVDS_CHRONTEL ||\r\nxgifb_info->hasVB == HASVB_CHRONTEL) {\r\nreturn -1;\r\n}\r\nbreak;\r\ncase 1024:\r\nif (xgifb_info->TV_type == TVMODE_NTSC) {\r\nif (XGIbios_mode[myindex].bpp == 32)\r\nreturn -1;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nbreak;\r\ncase XGIFB_DISP_CRT:\r\nif (XGIbios_mode[myindex].xres > 1280)\r\nreturn -1;\r\nbreak;\r\ncase XGIFB_DISP_NONE:\r\nbreak;\r\n}\r\ncheck_memory:\r\nrequired_mem = XGIbios_mode[myindex].xres * XGIbios_mode[myindex].yres *\r\nXGIbios_mode[myindex].bpp / 8;\r\nif (required_mem > xgifb_info->video_size)\r\nreturn -1;\r\nreturn myindex;\r\n}\r\nstatic void XGIfb_search_crt2type(const char *name)\r\n{\r\nint i = 0;\r\nif (name == NULL)\r\nreturn;\r\nwhile (XGI_crt2type[i].type_no != -1) {\r\nif (!strcmp(name, XGI_crt2type[i].name)) {\r\nXGIfb_crt2type = XGI_crt2type[i].type_no;\r\nXGIfb_tvplug = XGI_crt2type[i].tvplug_no;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (XGIfb_crt2type < 0)\r\npr_info("Invalid CRT2 type: %s\n", name);\r\n}\r\nstatic u8 XGIfb_search_refresh_rate(struct xgifb_video_info *xgifb_info,\r\nunsigned int rate)\r\n{\r\nu16 xres, yres;\r\nint i = 0;\r\nxres = XGIbios_mode[xgifb_info->mode_idx].xres;\r\nyres = XGIbios_mode[xgifb_info->mode_idx].yres;\r\nxgifb_info->rate_idx = 0;\r\nwhile ((XGIfb_vrate[i].idx != 0) && (XGIfb_vrate[i].xres <= xres)) {\r\nif ((XGIfb_vrate[i].xres == xres) &&\r\n(XGIfb_vrate[i].yres == yres)) {\r\nif (XGIfb_vrate[i].refresh == rate) {\r\nxgifb_info->rate_idx = XGIfb_vrate[i].idx;\r\nbreak;\r\n} else if (XGIfb_vrate[i].refresh > rate) {\r\nif ((XGIfb_vrate[i].refresh - rate) <= 3) {\r\npr_debug("Adjusting rate from %d up to %d\n",\r\nrate, XGIfb_vrate[i].refresh);\r\nxgifb_info->rate_idx =\r\nXGIfb_vrate[i].idx;\r\nxgifb_info->refresh_rate =\r\nXGIfb_vrate[i].refresh;\r\n} else if (((rate - XGIfb_vrate[i - 1].refresh)\r\n<= 2) && (XGIfb_vrate[i].idx\r\n!= 1)) {\r\npr_debug("Adjusting rate from %d down to %d\n",\r\nrate,\r\nXGIfb_vrate[i-1].refresh);\r\nxgifb_info->rate_idx =\r\nXGIfb_vrate[i - 1].idx;\r\nxgifb_info->refresh_rate =\r\nXGIfb_vrate[i - 1].refresh;\r\n}\r\nbreak;\r\n} else if ((rate - XGIfb_vrate[i].refresh) <= 2) {\r\npr_debug("Adjusting rate from %d down to %d\n",\r\nrate, XGIfb_vrate[i].refresh);\r\nxgifb_info->rate_idx = XGIfb_vrate[i].idx;\r\nbreak;\r\n}\r\n}\r\ni++;\r\n}\r\nif (xgifb_info->rate_idx > 0) {\r\nreturn xgifb_info->rate_idx;\r\n} else {\r\npr_info("Unsupported rate %d for %dx%d\n",\r\nrate, xres, yres);\r\nreturn 0;\r\n}\r\n}\r\nstatic void XGIfb_search_tvstd(const char *name)\r\n{\r\nint i = 0;\r\nif (name == NULL)\r\nreturn;\r\nwhile (XGI_tvtype[i].type_no != -1) {\r\nif (!strcmp(name, XGI_tvtype[i].name)) {\r\nXGIfb_tvmode = XGI_tvtype[i].type_no;\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nstatic void XGIfb_bpp_to_var(struct xgifb_video_info *xgifb_info,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 6;\r\nxgifb_info->video_cmap_len = 256;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nxgifb_info->video_cmap_len = 16;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nxgifb_info->video_cmap_len = 16;\r\nbreak;\r\n}\r\n}\r\nstatic void XGIfb_pre_setmode(struct xgifb_video_info *xgifb_info)\r\n{\r\nu8 cr30 = 0, cr31 = 0;\r\ncr31 = xgifb_reg_get(XGICR, 0x31);\r\ncr31 &= ~0x60;\r\nswitch (xgifb_info->display2) {\r\ncase XGIFB_DISP_CRT:\r\ncr30 = (SIS_VB_OUTPUT_CRT2 | SIS_SIMULTANEOUS_VIEW_ENABLE);\r\ncr31 |= SIS_DRIVER_MODE;\r\nbreak;\r\ncase XGIFB_DISP_LCD:\r\ncr30 = (SIS_VB_OUTPUT_LCD | SIS_SIMULTANEOUS_VIEW_ENABLE);\r\ncr31 |= SIS_DRIVER_MODE;\r\nbreak;\r\ncase XGIFB_DISP_TV:\r\nif (xgifb_info->TV_type == TVMODE_HIVISION)\r\ncr30 = (SIS_VB_OUTPUT_HIVISION\r\n| SIS_SIMULTANEOUS_VIEW_ENABLE);\r\nelse if (xgifb_info->TV_plug == TVPLUG_SVIDEO)\r\ncr30 = (SIS_VB_OUTPUT_SVIDEO\r\n| SIS_SIMULTANEOUS_VIEW_ENABLE);\r\nelse if (xgifb_info->TV_plug == TVPLUG_COMPOSITE)\r\ncr30 = (SIS_VB_OUTPUT_COMPOSITE\r\n| SIS_SIMULTANEOUS_VIEW_ENABLE);\r\nelse if (xgifb_info->TV_plug == TVPLUG_SCART)\r\ncr30 = (SIS_VB_OUTPUT_SCART\r\n| SIS_SIMULTANEOUS_VIEW_ENABLE);\r\ncr31 |= SIS_DRIVER_MODE;\r\nif (XGIfb_tvmode == 1 || xgifb_info->TV_type == TVMODE_PAL)\r\ncr31 |= 0x01;\r\nelse\r\ncr31 &= ~0x01;\r\nbreak;\r\ndefault:\r\ncr30 = 0x00;\r\ncr31 |= (SIS_DRIVER_MODE | SIS_VB_OUTPUT_DISABLE);\r\n}\r\nxgifb_reg_set(XGICR, IND_XGI_SCRATCH_REG_CR30, cr30);\r\nxgifb_reg_set(XGICR, IND_XGI_SCRATCH_REG_CR31, cr31);\r\nxgifb_reg_set(XGICR, IND_XGI_SCRATCH_REG_CR33,\r\n(xgifb_info->rate_idx & 0x0F));\r\n}\r\nstatic void XGIfb_post_setmode(struct xgifb_video_info *xgifb_info)\r\n{\r\nu8 reg;\r\nunsigned char doit = 1;\r\nif (xgifb_info->video_bpp == 8) {\r\nif ((xgifb_info->hasVB == HASVB_LVDS) ||\r\n(xgifb_info->hasVB == HASVB_LVDS_CHRONTEL)) {\r\ndoit = 0;\r\n}\r\nif (xgifb_info->display2 == XGIFB_DISP_LCD)\r\ndoit = 0;\r\n}\r\nif (xgifb_info->hasVB != HASVB_NONE) {\r\nreg = xgifb_reg_get(XGIPART1, 0x00);\r\nif ((reg & 0x50) == 0x10)\r\ndoit = 0;\r\n} else {\r\nXGIfb_crt1off = 0;\r\n}\r\nreg = xgifb_reg_get(XGICR, 0x17);\r\nif ((XGIfb_crt1off) && (doit))\r\nreg &= ~0x80;\r\nelse\r\nreg |= 0x80;\r\nxgifb_reg_set(XGICR, 0x17, reg);\r\nxgifb_reg_and(XGISR, IND_SIS_RAMDAC_CONTROL, ~0x04);\r\nif (xgifb_info->display2 == XGIFB_DISP_TV &&\r\nxgifb_info->hasVB == HASVB_301) {\r\nreg = xgifb_reg_get(XGIPART4, 0x01);\r\nif (reg < 0xB0) {\r\nint filter_tb;\r\nswitch (xgifb_info->video_width) {\r\ncase 320:\r\nfilter_tb = (xgifb_info->TV_type ==\r\nTVMODE_NTSC) ? 4 : 12;\r\nbreak;\r\ncase 640:\r\nfilter_tb = (xgifb_info->TV_type ==\r\nTVMODE_NTSC) ? 5 : 13;\r\nbreak;\r\ncase 720:\r\nfilter_tb = (xgifb_info->TV_type ==\r\nTVMODE_NTSC) ? 6 : 14;\r\nbreak;\r\ncase 800:\r\nfilter_tb = (xgifb_info->TV_type ==\r\nTVMODE_NTSC) ? 7 : 15;\r\nbreak;\r\ndefault:\r\nfilter_tb = 0;\r\nfilter = -1;\r\nbreak;\r\n}\r\nxgifb_reg_or(XGIPART1,\r\nSIS_CRT2_WENABLE_315,\r\n0x01);\r\nif (xgifb_info->TV_type == TVMODE_NTSC) {\r\nxgifb_reg_and(XGIPART2, 0x3a, 0x1f);\r\nif (xgifb_info->TV_plug == TVPLUG_SVIDEO) {\r\nxgifb_reg_and(XGIPART2, 0x30, 0xdf);\r\n} else if (xgifb_info->TV_plug\r\n== TVPLUG_COMPOSITE) {\r\nxgifb_reg_or(XGIPART2, 0x30, 0x20);\r\nswitch (xgifb_info->video_width) {\r\ncase 640:\r\nxgifb_reg_set(XGIPART2,\r\n0x35,\r\n0xEB);\r\nxgifb_reg_set(XGIPART2,\r\n0x36,\r\n0x04);\r\nxgifb_reg_set(XGIPART2,\r\n0x37,\r\n0x25);\r\nxgifb_reg_set(XGIPART2,\r\n0x38,\r\n0x18);\r\nbreak;\r\ncase 720:\r\nxgifb_reg_set(XGIPART2,\r\n0x35,\r\n0xEE);\r\nxgifb_reg_set(XGIPART2,\r\n0x36,\r\n0x0C);\r\nxgifb_reg_set(XGIPART2,\r\n0x37,\r\n0x22);\r\nxgifb_reg_set(XGIPART2,\r\n0x38,\r\n0x08);\r\nbreak;\r\ncase 800:\r\nxgifb_reg_set(XGIPART2,\r\n0x35,\r\n0xEB);\r\nxgifb_reg_set(XGIPART2,\r\n0x36,\r\n0x15);\r\nxgifb_reg_set(XGIPART2,\r\n0x37,\r\n0x25);\r\nxgifb_reg_set(XGIPART2,\r\n0x38,\r\n0xF6);\r\nbreak;\r\n}\r\n}\r\n} else if (xgifb_info->TV_type == TVMODE_PAL) {\r\nxgifb_reg_and(XGIPART2, 0x3A, 0x1F);\r\nif (xgifb_info->TV_plug == TVPLUG_SVIDEO) {\r\nxgifb_reg_and(XGIPART2, 0x30, 0xDF);\r\n} else if (xgifb_info->TV_plug\r\n== TVPLUG_COMPOSITE) {\r\nxgifb_reg_or(XGIPART2, 0x30, 0x20);\r\nswitch (xgifb_info->video_width) {\r\ncase 640:\r\nxgifb_reg_set(XGIPART2,\r\n0x35,\r\n0xF1);\r\nxgifb_reg_set(XGIPART2,\r\n0x36,\r\n0xF7);\r\nxgifb_reg_set(XGIPART2,\r\n0x37,\r\n0x1F);\r\nxgifb_reg_set(XGIPART2,\r\n0x38,\r\n0x32);\r\nbreak;\r\ncase 720:\r\nxgifb_reg_set(XGIPART2,\r\n0x35,\r\n0xF3);\r\nxgifb_reg_set(XGIPART2,\r\n0x36,\r\n0x00);\r\nxgifb_reg_set(XGIPART2,\r\n0x37,\r\n0x1D);\r\nxgifb_reg_set(XGIPART2,\r\n0x38,\r\n0x20);\r\nbreak;\r\ncase 800:\r\nxgifb_reg_set(XGIPART2,\r\n0x35,\r\n0xFC);\r\nxgifb_reg_set(XGIPART2,\r\n0x36,\r\n0xFB);\r\nxgifb_reg_set(XGIPART2,\r\n0x37,\r\n0x14);\r\nxgifb_reg_set(XGIPART2,\r\n0x38,\r\n0x2A);\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((filter >= 0) && (filter <= 7)) {\r\npr_debug("FilterTable[%d]-%d: %*ph\n",\r\nfilter_tb, filter,\r\n4, XGI_TV_filter[filter_tb].\r\nfilter[filter]);\r\nxgifb_reg_set(\r\nXGIPART2,\r\n0x35,\r\n(XGI_TV_filter[filter_tb].\r\nfilter[filter][0]));\r\nxgifb_reg_set(\r\nXGIPART2,\r\n0x36,\r\n(XGI_TV_filter[filter_tb].\r\nfilter[filter][1]));\r\nxgifb_reg_set(\r\nXGIPART2,\r\n0x37,\r\n(XGI_TV_filter[filter_tb].\r\nfilter[filter][2]));\r\nxgifb_reg_set(\r\nXGIPART2,\r\n0x38,\r\n(XGI_TV_filter[filter_tb].\r\nfilter[filter][3]));\r\n}\r\n}\r\n}\r\n}\r\nstatic int XGIfb_do_set_var(struct fb_var_screeninfo *var, int isactive,\r\nstruct fb_info *info)\r\n{\r\nstruct xgifb_video_info *xgifb_info = info->par;\r\nstruct xgi_hw_device_info *hw_info = &xgifb_info->hw_info;\r\nunsigned int htotal = var->left_margin + var->xres + var->right_margin\r\n+ var->hsync_len;\r\nunsigned int vtotal = var->upper_margin + var->yres + var->lower_margin\r\n+ var->vsync_len;\r\n#if defined(__powerpc__)\r\nu8 cr_data;\r\n#endif\r\nunsigned int drate = 0, hrate = 0;\r\nint found_mode = 0;\r\nint old_mode;\r\ninfo->var.xres_virtual = var->xres_virtual;\r\ninfo->var.yres_virtual = var->yres_virtual;\r\ninfo->var.bits_per_pixel = var->bits_per_pixel;\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED)\r\nvtotal <<= 1;\r\nelse if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)\r\nvtotal <<= 2;\r\nif (!htotal || !vtotal) {\r\npr_debug("Invalid 'var' information\n");\r\nreturn -EINVAL;\r\n} pr_debug("var->pixclock=%d, htotal=%d, vtotal=%d\n",\r\nvar->pixclock, htotal, vtotal);\r\nif (var->pixclock && htotal && vtotal) {\r\ndrate = 1000000000 / var->pixclock;\r\nhrate = (drate * 1000) / htotal;\r\nxgifb_info->refresh_rate = (unsigned int) (hrate * 2\r\n/ vtotal);\r\n} else {\r\nxgifb_info->refresh_rate = 60;\r\n}\r\npr_debug("Change mode to %dx%dx%d-%dHz\n",\r\nvar->xres,\r\nvar->yres,\r\nvar->bits_per_pixel,\r\nxgifb_info->refresh_rate);\r\nold_mode = xgifb_info->mode_idx;\r\nxgifb_info->mode_idx = 0;\r\nwhile ((XGIbios_mode[xgifb_info->mode_idx].mode_no != 0) &&\r\n(XGIbios_mode[xgifb_info->mode_idx].xres <= var->xres)) {\r\nif ((XGIbios_mode[xgifb_info->mode_idx].xres == var->xres) &&\r\n(XGIbios_mode[xgifb_info->mode_idx].yres == var->yres) &&\r\n(XGIbios_mode[xgifb_info->mode_idx].bpp\r\n== var->bits_per_pixel)) {\r\nfound_mode = 1;\r\nbreak;\r\n}\r\nxgifb_info->mode_idx++;\r\n}\r\nif (found_mode)\r\nxgifb_info->mode_idx = XGIfb_validate_mode(xgifb_info,\r\nxgifb_info->mode_idx);\r\nelse\r\nxgifb_info->mode_idx = -1;\r\nif (xgifb_info->mode_idx < 0) {\r\npr_err("Mode %dx%dx%d not supported\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nxgifb_info->mode_idx = old_mode;\r\nreturn -EINVAL;\r\n}\r\nif (XGIfb_search_refresh_rate(xgifb_info,\r\nxgifb_info->refresh_rate) == 0) {\r\nxgifb_info->rate_idx = 1;\r\nxgifb_info->refresh_rate = 60;\r\n}\r\nif (isactive) {\r\nXGIfb_pre_setmode(xgifb_info);\r\nif (XGISetModeNew(xgifb_info, hw_info,\r\nXGIbios_mode[xgifb_info->mode_idx].mode_no)\r\n== 0) {\r\npr_err("Setting mode[0x%x] failed\n",\r\nXGIbios_mode[xgifb_info->mode_idx].mode_no);\r\nreturn -EINVAL;\r\n}\r\ninfo->fix.line_length = ((info->var.xres_virtual\r\n* info->var.bits_per_pixel) >> 6);\r\nxgifb_reg_set(XGISR, IND_SIS_PASSWORD, SIS_PASSWORD);\r\nxgifb_reg_set(XGICR, 0x13, (info->fix.line_length & 0x00ff));\r\nxgifb_reg_set(XGISR,\r\n0x0E,\r\n(info->fix.line_length & 0xff00) >> 8);\r\nXGIfb_post_setmode(xgifb_info);\r\npr_debug("Set new mode: %dx%dx%d-%d\n",\r\nXGIbios_mode[xgifb_info->mode_idx].xres,\r\nXGIbios_mode[xgifb_info->mode_idx].yres,\r\nXGIbios_mode[xgifb_info->mode_idx].bpp,\r\nxgifb_info->refresh_rate);\r\nxgifb_info->video_bpp = XGIbios_mode[xgifb_info->mode_idx].bpp;\r\nxgifb_info->video_vwidth = info->var.xres_virtual;\r\nxgifb_info->video_width =\r\nXGIbios_mode[xgifb_info->mode_idx].xres;\r\nxgifb_info->video_vheight = info->var.yres_virtual;\r\nxgifb_info->video_height =\r\nXGIbios_mode[xgifb_info->mode_idx].yres;\r\nxgifb_info->org_x = xgifb_info->org_y = 0;\r\nxgifb_info->video_linelength = info->var.xres_virtual\r\n* (xgifb_info->video_bpp >> 3);\r\nswitch (xgifb_info->video_bpp) {\r\ncase 8:\r\nxgifb_info->DstColor = 0x0000;\r\nxgifb_info->XGI310_AccelDepth = 0x00000000;\r\nxgifb_info->video_cmap_len = 256;\r\n#if defined(__powerpc__)\r\ncr_data = xgifb_reg_get(XGICR, 0x4D);\r\nxgifb_reg_set(XGICR, 0x4D, (cr_data & 0xE0));\r\n#endif\r\nbreak;\r\ncase 16:\r\nxgifb_info->DstColor = 0x8000;\r\nxgifb_info->XGI310_AccelDepth = 0x00010000;\r\n#if defined(__powerpc__)\r\ncr_data = xgifb_reg_get(XGICR, 0x4D);\r\nxgifb_reg_set(XGICR, 0x4D, ((cr_data & 0xE0) | 0x0B));\r\n#endif\r\nxgifb_info->video_cmap_len = 16;\r\nbreak;\r\ncase 32:\r\nxgifb_info->DstColor = 0xC000;\r\nxgifb_info->XGI310_AccelDepth = 0x00020000;\r\nxgifb_info->video_cmap_len = 16;\r\n#if defined(__powerpc__)\r\ncr_data = xgifb_reg_get(XGICR, 0x4D);\r\nxgifb_reg_set(XGICR, 0x4D, ((cr_data & 0xE0) | 0x15));\r\n#endif\r\nbreak;\r\ndefault:\r\nxgifb_info->video_cmap_len = 16;\r\npr_err("Unsupported depth %d\n",\r\nxgifb_info->video_bpp);\r\nbreak;\r\n}\r\n}\r\nXGIfb_bpp_to_var(xgifb_info, var);\r\ndumpVGAReg();\r\nreturn 0;\r\n}\r\nstatic int XGIfb_pan_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct xgifb_video_info *xgifb_info = info->par;\r\nunsigned int base;\r\nbase = var->yoffset * info->var.xres_virtual + var->xoffset;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nbase >>= 1;\r\nbreak;\r\ncase 32:\r\nbreak;\r\ncase 8:\r\ndefault:\r\nbase >>= 2;\r\nbreak;\r\n}\r\nxgifb_reg_set(XGISR, IND_SIS_PASSWORD, SIS_PASSWORD);\r\nxgifb_reg_set(XGICR, 0x0D, base & 0xFF);\r\nxgifb_reg_set(XGICR, 0x0C, (base >> 8) & 0xFF);\r\nxgifb_reg_set(XGISR, 0x0D, (base >> 16) & 0xFF);\r\nxgifb_reg_set(XGISR, 0x37, (base >> 24) & 0x03);\r\nxgifb_reg_and_or(XGISR, 0x37, 0xDF, (base >> 21) & 0x04);\r\nif (xgifb_info->display2 != XGIFB_DISP_NONE) {\r\nxgifb_reg_or(XGIPART1, SIS_CRT2_WENABLE_315, 0x01);\r\nxgifb_reg_set(XGIPART1, 0x06, (base & 0xFF));\r\nxgifb_reg_set(XGIPART1, 0x05, ((base >> 8) & 0xFF));\r\nxgifb_reg_set(XGIPART1, 0x04, ((base >> 16) & 0xFF));\r\nxgifb_reg_and_or(XGIPART1,\r\n0x02,\r\n0x7F,\r\n((base >> 24) & 0x01) << 7);\r\n}\r\nreturn 0;\r\n}\r\nstatic int XGIfb_open(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int XGIfb_release(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int XGIfb_get_cmap_len(const struct fb_var_screeninfo *var)\r\n{\r\nreturn (var->bits_per_pixel == 8) ? 256 : 16;\r\n}\r\nstatic int XGIfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nstruct xgifb_video_info *xgifb_info = info->par;\r\nif (regno >= XGIfb_get_cmap_len(&info->var))\r\nreturn 1;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\noutb(regno, XGIDACA);\r\noutb((red >> 10), XGIDACD);\r\noutb((green >> 10), XGIDACD);\r\noutb((blue >> 10), XGIDACD);\r\nif (xgifb_info->display2 != XGIFB_DISP_NONE) {\r\noutb(regno, XGIDAC2A);\r\noutb((red >> 8), XGIDAC2D);\r\noutb((green >> 8), XGIDAC2D);\r\noutb((blue >> 8), XGIDAC2D);\r\n}\r\nbreak;\r\ncase 16:\r\n((u32 *) (info->pseudo_palette))[regno] = ((red & 0xf800))\r\n| ((green & 0xfc00) >> 5) | ((blue & 0xf800)\r\n>> 11);\r\nbreak;\r\ncase 32:\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\n((u32 *) (info->pseudo_palette))[regno] = (red << 16) | (green\r\n<< 8) | (blue);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int XGIfb_get_fix(struct fb_fix_screeninfo *fix, int con,\r\nstruct fb_info *info)\r\n{\r\nstruct xgifb_video_info *xgifb_info = info->par;\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrncpy(fix->id, "XGI", sizeof(fix->id) - 1);\r\nif (atomic_read(&info->count))\r\nmutex_lock(&info->mm_lock);\r\nfix->smem_start = xgifb_info->video_base;\r\nfix->smem_len = xgifb_info->video_size;\r\nif (atomic_read(&info->count))\r\nmutex_unlock(&info->mm_lock);\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nif (xgifb_info->video_bpp == 8)\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\nfix->visual = FB_VISUAL_DIRECTCOLOR;\r\nfix->xpanstep = 0;\r\nif (XGIfb_ypan)\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->line_length = xgifb_info->video_linelength;\r\nfix->mmio_start = xgifb_info->mmio_base;\r\nfix->mmio_len = xgifb_info->mmio_size;\r\nfix->accel = FB_ACCEL_SIS_XABRE;\r\nreturn 0;\r\n}\r\nstatic int XGIfb_set_par(struct fb_info *info)\r\n{\r\nint err;\r\nerr = XGIfb_do_set_var(&info->var, 1, info);\r\nif (err)\r\nreturn err;\r\nXGIfb_get_fix(&info->fix, -1, info);\r\nreturn 0;\r\n}\r\nstatic int XGIfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct xgifb_video_info *xgifb_info = info->par;\r\nunsigned int htotal = var->left_margin + var->xres + var->right_margin\r\n+ var->hsync_len;\r\nunsigned int vtotal = 0;\r\nunsigned int drate = 0, hrate = 0;\r\nint found_mode = 0;\r\nint refresh_rate, search_idx;\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_NONINTERLACED) {\r\nvtotal = var->upper_margin + var->yres + var->lower_margin\r\n+ var->vsync_len;\r\nvtotal <<= 1;\r\n} else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {\r\nvtotal = var->upper_margin + var->yres + var->lower_margin\r\n+ var->vsync_len;\r\nvtotal <<= 2;\r\n} else if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\r\nvtotal = var->upper_margin + (var->yres / 2)\r\n+ var->lower_margin + var->vsync_len;\r\n} else\r\nvtotal = var->upper_margin + var->yres + var->lower_margin\r\n+ var->vsync_len;\r\nif (!(htotal) || !(vtotal)) {\r\npr_debug("No valid timing data\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->pixclock && htotal && vtotal) {\r\ndrate = 1000000000 / var->pixclock;\r\nhrate = (drate * 1000) / htotal;\r\nxgifb_info->refresh_rate =\r\n(unsigned int) (hrate * 2 / vtotal);\r\npr_debug(\r\n"%s: pixclock = %d ,htotal=%d, vtotal=%d\n"\r\n"%s: drate=%d, hrate=%d, refresh_rate=%d\n",\r\n__func__, var->pixclock, htotal, vtotal,\r\n__func__, drate, hrate, xgifb_info->refresh_rate);\r\n} else {\r\nxgifb_info->refresh_rate = 60;\r\n}\r\nif ((var->xres == 1024) && (var->yres == 600))\r\nrefresh_rate = 60;\r\nsearch_idx = 0;\r\nwhile ((XGIbios_mode[search_idx].mode_no != 0) &&\r\n(XGIbios_mode[search_idx].xres <= var->xres)) {\r\nif ((XGIbios_mode[search_idx].xres == var->xres) &&\r\n(XGIbios_mode[search_idx].yres == var->yres) &&\r\n(XGIbios_mode[search_idx].bpp == var->bits_per_pixel)) {\r\nif (XGIfb_validate_mode(xgifb_info, search_idx) > 0) {\r\nfound_mode = 1;\r\nbreak;\r\n}\r\n}\r\nsearch_idx++;\r\n}\r\nif (!found_mode) {\r\npr_err("%dx%dx%d is no valid mode\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nsearch_idx = 0;\r\nwhile (XGIbios_mode[search_idx].mode_no != 0) {\r\nif ((var->xres <= XGIbios_mode[search_idx].xres) &&\r\n(var->yres <= XGIbios_mode[search_idx].yres) &&\r\n(var->bits_per_pixel ==\r\nXGIbios_mode[search_idx].bpp)) {\r\nif (XGIfb_validate_mode(xgifb_info,\r\nsearch_idx) > 0) {\r\nfound_mode = 1;\r\nbreak;\r\n}\r\n}\r\nsearch_idx++;\r\n}\r\nif (found_mode) {\r\nvar->xres = XGIbios_mode[search_idx].xres;\r\nvar->yres = XGIbios_mode[search_idx].yres;\r\npr_debug("Adapted to mode %dx%dx%d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\n} else {\r\npr_err("Failed to find similar mode to %dx%dx%d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\n}\r\nXGIfb_bpp_to_var(xgifb_info, var);\r\nif (!XGIfb_ypan) {\r\nif (var->xres != var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres != var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\n}\r\nif (var->xoffset > var->xres_virtual - var->xres)\r\nvar->xoffset = var->xres_virtual - var->xres - 1;\r\nif (var->yoffset > var->yres_virtual - var->yres)\r\nvar->yoffset = var->yres_virtual - var->yres - 1;\r\nvar->red.msb_right =\r\nvar->green.msb_right =\r\nvar->blue.msb_right =\r\nvar->transp.offset = var->transp.length = var->transp.msb_right = 0;\r\nreturn 0;\r\n}\r\nstatic int XGIfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint err;\r\nif (var->xoffset > (info->var.xres_virtual - info->var.xres))\r\nreturn -EINVAL;\r\nif (var->yoffset > (info->var.yres_virtual - info->var.yres))\r\nreturn -EINVAL;\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->yoffset >= info->var.yres_virtual || var->xoffset)\r\nreturn -EINVAL;\r\n} else if (var->xoffset + info->var.xres > info->var.xres_virtual\r\n|| var->yoffset + info->var.yres\r\n> info->var.yres_virtual) {\r\nreturn -EINVAL;\r\n}\r\nerr = XGIfb_pan_var(var, info);\r\nif (err < 0)\r\nreturn err;\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nreturn 0;\r\n}\r\nstatic int XGIfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct xgifb_video_info *xgifb_info = info->par;\r\nu8 reg;\r\nreg = xgifb_reg_get(XGICR, 0x17);\r\nif (blank > 0)\r\nreg &= 0x7f;\r\nelse\r\nreg |= 0x80;\r\nxgifb_reg_set(XGICR, 0x17, reg);\r\nxgifb_reg_set(XGISR, 0x00, 0x01);\r\nxgifb_reg_set(XGISR, 0x00, 0x03);\r\nreturn 0;\r\n}\r\nstatic int XGIfb_get_dram_size(struct xgifb_video_info *xgifb_info)\r\n{\r\nu8 ChannelNum, tmp;\r\nu8 reg = 0;\r\nif (xgifb_info->chip == XG27)\r\nxgifb_reg_set(XGISR, IND_SIS_DRAM_SIZE, 0x51);\r\nreg = xgifb_reg_get(XGISR, IND_SIS_DRAM_SIZE);\r\nif (!reg)\r\nreturn -1;\r\nswitch ((reg & XGI_DRAM_SIZE_MASK) >> 4) {\r\ncase XGI_DRAM_SIZE_1MB:\r\nxgifb_info->video_size = 0x100000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_2MB:\r\nxgifb_info->video_size = 0x200000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_4MB:\r\nxgifb_info->video_size = 0x400000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_8MB:\r\nxgifb_info->video_size = 0x800000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_16MB:\r\nxgifb_info->video_size = 0x1000000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_32MB:\r\nxgifb_info->video_size = 0x2000000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_64MB:\r\nxgifb_info->video_size = 0x4000000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_128MB:\r\nxgifb_info->video_size = 0x8000000;\r\nbreak;\r\ncase XGI_DRAM_SIZE_256MB:\r\nxgifb_info->video_size = 0x10000000;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ntmp = (reg & 0x0c) >> 2;\r\nswitch (xgifb_info->chip) {\r\ncase XG20:\r\ncase XG21:\r\ncase XG27:\r\nChannelNum = 1;\r\nbreak;\r\ncase XG42:\r\nif (reg & 0x04)\r\nChannelNum = 2;\r\nelse\r\nChannelNum = 1;\r\nbreak;\r\ncase XG40:\r\ndefault:\r\nif (tmp == 2)\r\nChannelNum = 2;\r\nelse if (tmp == 3)\r\nChannelNum = 3;\r\nelse\r\nChannelNum = 1;\r\nbreak;\r\n}\r\nxgifb_info->video_size = xgifb_info->video_size * ChannelNum;\r\npr_info("SR14=%x DramSzie %x ChannelNum %x\n",\r\nreg,\r\nxgifb_info->video_size, ChannelNum);\r\nreturn 0;\r\n}\r\nstatic void XGIfb_detect_VB(struct xgifb_video_info *xgifb_info)\r\n{\r\nu8 cr32, temp = 0;\r\nxgifb_info->TV_plug = xgifb_info->TV_type = 0;\r\ncr32 = xgifb_reg_get(XGICR, IND_XGI_SCRATCH_REG_CR32);\r\nif ((cr32 & SIS_CRT1) && !XGIfb_crt1off)\r\nXGIfb_crt1off = 0;\r\nelse {\r\nif (cr32 & 0x5F)\r\nXGIfb_crt1off = 1;\r\nelse\r\nXGIfb_crt1off = 0;\r\n}\r\nif (!xgifb_info->display2_force) {\r\nif (cr32 & SIS_VB_TV)\r\nxgifb_info->display2 = XGIFB_DISP_TV;\r\nelse if (cr32 & SIS_VB_LCD)\r\nxgifb_info->display2 = XGIFB_DISP_LCD;\r\nelse if (cr32 & SIS_VB_CRT2)\r\nxgifb_info->display2 = XGIFB_DISP_CRT;\r\nelse\r\nxgifb_info->display2 = XGIFB_DISP_NONE;\r\n}\r\nif (XGIfb_tvplug != -1)\r\nxgifb_info->TV_plug = XGIfb_tvplug;\r\nelse if (cr32 & SIS_VB_HIVISION) {\r\nxgifb_info->TV_type = TVMODE_HIVISION;\r\nxgifb_info->TV_plug = TVPLUG_SVIDEO;\r\n} else if (cr32 & SIS_VB_SVIDEO)\r\nxgifb_info->TV_plug = TVPLUG_SVIDEO;\r\nelse if (cr32 & SIS_VB_COMPOSITE)\r\nxgifb_info->TV_plug = TVPLUG_COMPOSITE;\r\nelse if (cr32 & SIS_VB_SCART)\r\nxgifb_info->TV_plug = TVPLUG_SCART;\r\nif (xgifb_info->TV_type == 0) {\r\ntemp = xgifb_reg_get(XGICR, 0x38);\r\nif (temp & 0x10)\r\nxgifb_info->TV_type = TVMODE_PAL;\r\nelse\r\nxgifb_info->TV_type = TVMODE_NTSC;\r\n}\r\nif (XGIfb_forcecrt1 != -1) {\r\nif (XGIfb_forcecrt1)\r\nXGIfb_crt1off = 0;\r\nelse\r\nXGIfb_crt1off = 1;\r\n}\r\n}\r\nstatic int XGIfb_has_VB(struct xgifb_video_info *xgifb_info)\r\n{\r\nu8 vb_chipid;\r\nvb_chipid = xgifb_reg_get(XGIPART4, 0x00);\r\nswitch (vb_chipid) {\r\ncase 0x01:\r\nxgifb_info->hasVB = HASVB_301;\r\nbreak;\r\ncase 0x02:\r\nxgifb_info->hasVB = HASVB_302;\r\nbreak;\r\ndefault:\r\nxgifb_info->hasVB = HASVB_NONE;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void XGIfb_get_VB_type(struct xgifb_video_info *xgifb_info)\r\n{\r\nu8 reg;\r\nif (!XGIfb_has_VB(xgifb_info)) {\r\nreg = xgifb_reg_get(XGICR, IND_XGI_SCRATCH_REG_CR37);\r\nswitch ((reg & SIS_EXTERNAL_CHIP_MASK) >> 1) {\r\ncase SIS_EXTERNAL_CHIP_LVDS:\r\nxgifb_info->hasVB = HASVB_LVDS;\r\nbreak;\r\ncase SIS_EXTERNAL_CHIP_LVDS_CHRONTEL:\r\nxgifb_info->hasVB = HASVB_LVDS_CHRONTEL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int __init xgifb_optval(char *fullopt, int validx)\r\n{\r\nunsigned long lres;\r\nif (kstrtoul(fullopt + validx, 0, &lres) < 0 || lres > INT_MAX) {\r\npr_err("Invalid value for option: %s\n", fullopt);\r\nreturn 0;\r\n}\r\nreturn lres;\r\n}\r\nstatic int __init XGIfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\npr_info("Options: %s\n", options);\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strncmp(this_opt, "mode:", 5)) {\r\nmode = this_opt + 5;\r\n} else if (!strncmp(this_opt, "vesa:", 5)) {\r\nvesa = xgifb_optval(this_opt, 5);\r\n} else if (!strncmp(this_opt, "vrate:", 6)) {\r\nrefresh_rate = xgifb_optval(this_opt, 6);\r\n} else if (!strncmp(this_opt, "rate:", 5)) {\r\nrefresh_rate = xgifb_optval(this_opt, 5);\r\n} else if (!strncmp(this_opt, "crt1off", 7)) {\r\nXGIfb_crt1off = 1;\r\n} else if (!strncmp(this_opt, "filter:", 7)) {\r\nfilter = xgifb_optval(this_opt, 7);\r\n} else if (!strncmp(this_opt, "forcecrt2type:", 14)) {\r\nXGIfb_search_crt2type(this_opt + 14);\r\n} else if (!strncmp(this_opt, "forcecrt1:", 10)) {\r\nXGIfb_forcecrt1 = xgifb_optval(this_opt, 10);\r\n} else if (!strncmp(this_opt, "tvmode:", 7)) {\r\nXGIfb_search_tvstd(this_opt + 7);\r\n} else if (!strncmp(this_opt, "tvstandard:", 11)) {\r\nXGIfb_search_tvstd(this_opt + 7);\r\n} else if (!strncmp(this_opt, "dstn", 4)) {\r\nenable_dstn = 1;\r\nXGIfb_crt2type = XGIFB_DISP_LCD;\r\n} else if (!strncmp(this_opt, "noypan", 6)) {\r\nXGIfb_ypan = 0;\r\n} else {\r\nmode = this_opt;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgifb_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nu8 reg, reg1;\r\nu8 CR48, CR38;\r\nint ret;\r\nstruct fb_info *fb_info;\r\nstruct xgifb_video_info *xgifb_info;\r\nstruct xgi_hw_device_info *hw_info;\r\nunsigned long video_size_max;\r\nfb_info = framebuffer_alloc(sizeof(*xgifb_info), &pdev->dev);\r\nif (!fb_info)\r\nreturn -ENOMEM;\r\nxgifb_info = fb_info->par;\r\nhw_info = &xgifb_info->hw_info;\r\nxgifb_info->fb_info = fb_info;\r\nxgifb_info->chip_id = pdev->device;\r\npci_read_config_byte(pdev,\r\nPCI_REVISION_ID,\r\n&xgifb_info->revision_id);\r\nhw_info->jChipRevision = xgifb_info->revision_id;\r\nxgifb_info->pcibus = pdev->bus->number;\r\nxgifb_info->pcislot = PCI_SLOT(pdev->devfn);\r\nxgifb_info->pcifunc = PCI_FUNC(pdev->devfn);\r\nxgifb_info->subsysvendor = pdev->subsystem_vendor;\r\nxgifb_info->subsysdevice = pdev->subsystem_device;\r\nvideo_size_max = pci_resource_len(pdev, 0);\r\nxgifb_info->video_base = pci_resource_start(pdev, 0);\r\nxgifb_info->mmio_base = pci_resource_start(pdev, 1);\r\nxgifb_info->mmio_size = pci_resource_len(pdev, 1);\r\nxgifb_info->vga_base = pci_resource_start(pdev, 2) + 0x30;\r\ndev_info(&pdev->dev, "Relocate IO address: %Lx [%08lx]\n",\r\n(u64) pci_resource_start(pdev, 2),\r\nxgifb_info->vga_base);\r\nif (pci_enable_device(pdev)) {\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif (XGIfb_crt2type != -1) {\r\nxgifb_info->display2 = XGIfb_crt2type;\r\nxgifb_info->display2_force = true;\r\n}\r\nXGIRegInit(&xgifb_info->dev_info, xgifb_info->vga_base);\r\nxgifb_reg_set(XGISR, IND_SIS_PASSWORD, SIS_PASSWORD);\r\nreg1 = xgifb_reg_get(XGISR, IND_SIS_PASSWORD);\r\nif (reg1 != 0xa1) {\r\ndev_err(&pdev->dev, "I/O error\n");\r\nret = -EIO;\r\ngoto error_disable;\r\n}\r\nswitch (xgifb_info->chip_id) {\r\ncase PCI_DEVICE_ID_XGI_20:\r\nxgifb_reg_or(XGICR, Index_CR_GPIO_Reg3, GPIOG_EN);\r\nCR48 = xgifb_reg_get(XGICR, Index_CR_GPIO_Reg1);\r\nif (CR48&GPIOG_READ)\r\nxgifb_info->chip = XG21;\r\nelse\r\nxgifb_info->chip = XG20;\r\nbreak;\r\ncase PCI_DEVICE_ID_XGI_40:\r\nxgifb_info->chip = XG40;\r\nbreak;\r\ncase PCI_DEVICE_ID_XGI_42:\r\nxgifb_info->chip = XG42;\r\nbreak;\r\ncase PCI_DEVICE_ID_XGI_27:\r\nxgifb_info->chip = XG27;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto error_disable;\r\n}\r\ndev_info(&pdev->dev, "chipid = %x\n", xgifb_info->chip);\r\nhw_info->jChipType = xgifb_info->chip;\r\nif (XGIfb_get_dram_size(xgifb_info)) {\r\nxgifb_info->video_size = min_t(unsigned long, video_size_max,\r\nSZ_16M);\r\n} else if (xgifb_info->video_size > video_size_max) {\r\nxgifb_info->video_size = video_size_max;\r\n}\r\nxgifb_reg_or(XGISR,\r\nIND_SIS_PCI_ADDRESS_SET,\r\n(SIS_PCI_ADDR_ENABLE | SIS_MEM_MAP_IO_ENABLE));\r\nxgifb_reg_or(XGISR, IND_SIS_MODULE_ENABLE, SIS_ENABLE_2D);\r\nhw_info->ulVideoMemorySize = xgifb_info->video_size;\r\nif (!request_mem_region(xgifb_info->video_base,\r\nxgifb_info->video_size,\r\n"XGIfb FB")) {\r\ndev_err(&pdev->dev, "Unable request memory size %x\n",\r\nxgifb_info->video_size);\r\ndev_err(&pdev->dev,\r\n"Fatal error: Unable to reserve frame buffer memory. "\r\n"Is there another framebuffer driver active?\n");\r\nret = -ENODEV;\r\ngoto error_disable;\r\n}\r\nif (!request_mem_region(xgifb_info->mmio_base,\r\nxgifb_info->mmio_size,\r\n"XGIfb MMIO")) {\r\ndev_err(&pdev->dev,\r\n"Fatal error: Unable to reserve MMIO region\n");\r\nret = -ENODEV;\r\ngoto error_0;\r\n}\r\nxgifb_info->video_vbase = hw_info->pjVideoMemoryAddress =\r\nioremap(xgifb_info->video_base, xgifb_info->video_size);\r\nxgifb_info->mmio_vbase = ioremap(xgifb_info->mmio_base,\r\nxgifb_info->mmio_size);\r\ndev_info(&pdev->dev,\r\n"Framebuffer at 0x%Lx, mapped to 0x%p, size %dk\n",\r\n(u64) xgifb_info->video_base,\r\nxgifb_info->video_vbase,\r\nxgifb_info->video_size / 1024);\r\ndev_info(&pdev->dev,\r\n"MMIO at 0x%Lx, mapped to 0x%p, size %ldk\n",\r\n(u64) xgifb_info->mmio_base, xgifb_info->mmio_vbase,\r\nxgifb_info->mmio_size / 1024);\r\npci_set_drvdata(pdev, xgifb_info);\r\nif (!XGIInitNew(pdev))\r\ndev_err(&pdev->dev, "XGIInitNew() failed!\n");\r\nxgifb_info->mtrr = -1;\r\nxgifb_info->hasVB = HASVB_NONE;\r\nif ((xgifb_info->chip == XG20) ||\r\n(xgifb_info->chip == XG27)) {\r\nxgifb_info->hasVB = HASVB_NONE;\r\n} else if (xgifb_info->chip == XG21) {\r\nCR38 = xgifb_reg_get(XGICR, 0x38);\r\nif ((CR38&0xE0) == 0xC0)\r\nxgifb_info->display2 = XGIFB_DISP_LCD;\r\nelse if ((CR38&0xE0) == 0x60)\r\nxgifb_info->hasVB = HASVB_CHRONTEL;\r\nelse\r\nxgifb_info->hasVB = HASVB_NONE;\r\n} else {\r\nXGIfb_get_VB_type(xgifb_info);\r\n}\r\nhw_info->ujVBChipID = VB_CHIP_UNKNOWN;\r\nhw_info->ulExternalChip = 0;\r\nswitch (xgifb_info->hasVB) {\r\ncase HASVB_301:\r\nreg = xgifb_reg_get(XGIPART4, 0x01);\r\nif (reg >= 0xE0) {\r\nhw_info->ujVBChipID = VB_CHIP_302LV;\r\ndev_info(&pdev->dev,\r\n"XGI302LV bridge detected (revision 0x%02x)\n",\r\nreg);\r\n} else if (reg >= 0xD0) {\r\nhw_info->ujVBChipID = VB_CHIP_301LV;\r\ndev_info(&pdev->dev,\r\n"XGI301LV bridge detected (revision 0x%02x)\n",\r\nreg);\r\n} else {\r\nhw_info->ujVBChipID = VB_CHIP_301;\r\ndev_info(&pdev->dev, "XGI301 bridge detected\n");\r\n}\r\nbreak;\r\ncase HASVB_302:\r\nreg = xgifb_reg_get(XGIPART4, 0x01);\r\nif (reg >= 0xE0) {\r\nhw_info->ujVBChipID = VB_CHIP_302LV;\r\ndev_info(&pdev->dev,\r\n"XGI302LV bridge detected (revision 0x%02x)\n",\r\nreg);\r\n} else if (reg >= 0xD0) {\r\nhw_info->ujVBChipID = VB_CHIP_301LV;\r\ndev_info(&pdev->dev,\r\n"XGI302LV bridge detected (revision 0x%02x)\n",\r\nreg);\r\n} else if (reg >= 0xB0) {\r\nreg1 = xgifb_reg_get(XGIPART4, 0x23);\r\nhw_info->ujVBChipID = VB_CHIP_302B;\r\n} else {\r\nhw_info->ujVBChipID = VB_CHIP_302;\r\ndev_info(&pdev->dev, "XGI302 bridge detected\n");\r\n}\r\nbreak;\r\ncase HASVB_LVDS:\r\nhw_info->ulExternalChip = 0x1;\r\ndev_info(&pdev->dev, "LVDS transmitter detected\n");\r\nbreak;\r\ncase HASVB_TRUMPION:\r\nhw_info->ulExternalChip = 0x2;\r\ndev_info(&pdev->dev, "Trumpion Zurac LVDS scaler detected\n");\r\nbreak;\r\ncase HASVB_CHRONTEL:\r\nhw_info->ulExternalChip = 0x4;\r\ndev_info(&pdev->dev, "Chrontel TV encoder detected\n");\r\nbreak;\r\ncase HASVB_LVDS_CHRONTEL:\r\nhw_info->ulExternalChip = 0x5;\r\ndev_info(&pdev->dev,\r\n"LVDS transmitter and Chrontel TV encoder detected\n");\r\nbreak;\r\ndefault:\r\ndev_info(&pdev->dev, "No or unknown bridge type detected\n");\r\nbreak;\r\n}\r\nif (xgifb_info->hasVB != HASVB_NONE)\r\nXGIfb_detect_VB(xgifb_info);\r\nelse if (xgifb_info->chip != XG21)\r\nxgifb_info->display2 = XGIFB_DISP_NONE;\r\nif (xgifb_info->display2 == XGIFB_DISP_LCD) {\r\nif (!enable_dstn) {\r\nreg = xgifb_reg_get(XGICR, IND_XGI_LCD_PANEL);\r\nreg &= 0x0f;\r\nhw_info->ulCRT2LCDType = XGI310paneltype[reg];\r\n}\r\n}\r\nxgifb_info->mode_idx = -1;\r\nif (mode)\r\nXGIfb_search_mode(xgifb_info, mode);\r\nelse if (vesa != -1)\r\nXGIfb_search_vesamode(xgifb_info, vesa);\r\nif (xgifb_info->mode_idx >= 0)\r\nxgifb_info->mode_idx =\r\nXGIfb_validate_mode(xgifb_info, xgifb_info->mode_idx);\r\nif (xgifb_info->mode_idx < 0) {\r\nif (xgifb_info->display2 == XGIFB_DISP_LCD &&\r\nxgifb_info->chip == XG21)\r\nxgifb_info->mode_idx =\r\nXGIfb_GetXG21DefaultLVDSModeIdx(xgifb_info);\r\nelse\r\nxgifb_info->mode_idx = DEFAULT_MODE;\r\n}\r\nif (xgifb_info->mode_idx < 0) {\r\ndev_err(&pdev->dev, "No supported video mode found\n");\r\nret = -EINVAL;\r\ngoto error_1;\r\n}\r\nxgifb_info->refresh_rate = refresh_rate;\r\nif (xgifb_info->refresh_rate == 0)\r\nxgifb_info->refresh_rate = 60;\r\nif (XGIfb_search_refresh_rate(xgifb_info,\r\nxgifb_info->refresh_rate) == 0) {\r\nxgifb_info->rate_idx = 1;\r\nxgifb_info->refresh_rate = 60;\r\n}\r\nxgifb_info->video_bpp = XGIbios_mode[xgifb_info->mode_idx].bpp;\r\nxgifb_info->video_vwidth =\r\nxgifb_info->video_width =\r\nXGIbios_mode[xgifb_info->mode_idx].xres;\r\nxgifb_info->video_vheight =\r\nxgifb_info->video_height =\r\nXGIbios_mode[xgifb_info->mode_idx].yres;\r\nxgifb_info->org_x = xgifb_info->org_y = 0;\r\nxgifb_info->video_linelength =\r\nxgifb_info->video_width *\r\n(xgifb_info->video_bpp >> 3);\r\nswitch (xgifb_info->video_bpp) {\r\ncase 8:\r\nxgifb_info->DstColor = 0x0000;\r\nxgifb_info->XGI310_AccelDepth = 0x00000000;\r\nxgifb_info->video_cmap_len = 256;\r\nbreak;\r\ncase 16:\r\nxgifb_info->DstColor = 0x8000;\r\nxgifb_info->XGI310_AccelDepth = 0x00010000;\r\nxgifb_info->video_cmap_len = 16;\r\nbreak;\r\ncase 32:\r\nxgifb_info->DstColor = 0xC000;\r\nxgifb_info->XGI310_AccelDepth = 0x00020000;\r\nxgifb_info->video_cmap_len = 16;\r\nbreak;\r\ndefault:\r\nxgifb_info->video_cmap_len = 16;\r\npr_info("Unsupported depth %d\n",\r\nxgifb_info->video_bpp);\r\nbreak;\r\n}\r\npr_info("Default mode is %dx%dx%d (%dHz)\n",\r\nxgifb_info->video_width,\r\nxgifb_info->video_height,\r\nxgifb_info->video_bpp,\r\nxgifb_info->refresh_rate);\r\nfb_info->var.red.length = 8;\r\nfb_info->var.green.length = 8;\r\nfb_info->var.blue.length = 8;\r\nfb_info->var.activate = FB_ACTIVATE_NOW;\r\nfb_info->var.height = -1;\r\nfb_info->var.width = -1;\r\nfb_info->var.vmode = FB_VMODE_NONINTERLACED;\r\nfb_info->var.xres = xgifb_info->video_width;\r\nfb_info->var.xres_virtual = xgifb_info->video_width;\r\nfb_info->var.yres = xgifb_info->video_height;\r\nfb_info->var.yres_virtual = xgifb_info->video_height;\r\nfb_info->var.bits_per_pixel = xgifb_info->video_bpp;\r\nXGIfb_bpp_to_var(xgifb_info, &fb_info->var);\r\nfb_info->var.pixclock = (u32) (1000000000 /\r\nXGIfb_mode_rate_to_dclock(&xgifb_info->dev_info,\r\nhw_info,\r\nXGIbios_mode[xgifb_info->mode_idx].mode_no,\r\nxgifb_info->rate_idx));\r\nif (XGIfb_mode_rate_to_ddata(&xgifb_info->dev_info, hw_info,\r\nXGIbios_mode[xgifb_info->mode_idx].mode_no,\r\nxgifb_info->rate_idx,\r\n&fb_info->var.left_margin,\r\n&fb_info->var.right_margin,\r\n&fb_info->var.upper_margin,\r\n&fb_info->var.lower_margin,\r\n&fb_info->var.hsync_len,\r\n&fb_info->var.vsync_len,\r\n&fb_info->var.sync,\r\n&fb_info->var.vmode)) {\r\nif ((fb_info->var.vmode & FB_VMODE_MASK) ==\r\nFB_VMODE_INTERLACED) {\r\nfb_info->var.yres <<= 1;\r\nfb_info->var.yres_virtual <<= 1;\r\n} else if ((fb_info->var.vmode & FB_VMODE_MASK) ==\r\nFB_VMODE_DOUBLE) {\r\nfb_info->var.pixclock >>= 1;\r\nfb_info->var.yres >>= 1;\r\nfb_info->var.yres_virtual >>= 1;\r\n}\r\n}\r\nfb_info->flags = FBINFO_FLAG_DEFAULT;\r\nfb_info->screen_base = xgifb_info->video_vbase;\r\nfb_info->fbops = &XGIfb_ops;\r\nXGIfb_get_fix(&fb_info->fix, -1, fb_info);\r\nfb_info->pseudo_palette = xgifb_info->pseudo_palette;\r\nfb_alloc_cmap(&fb_info->cmap, 256 , 0);\r\n#ifdef CONFIG_MTRR\r\nxgifb_info->mtrr = mtrr_add(xgifb_info->video_base,\r\nxgifb_info->video_size, MTRR_TYPE_WRCOMB, 1);\r\nif (xgifb_info->mtrr >= 0)\r\ndev_info(&pdev->dev, "Added MTRR\n");\r\n#endif\r\nif (register_framebuffer(fb_info) < 0) {\r\nret = -EINVAL;\r\ngoto error_mtrr;\r\n}\r\ndumpVGAReg();\r\nreturn 0;\r\nerror_mtrr:\r\n#ifdef CONFIG_MTRR\r\nif (xgifb_info->mtrr >= 0)\r\nmtrr_del(xgifb_info->mtrr, xgifb_info->video_base,\r\nxgifb_info->video_size);\r\n#endif\r\nerror_1:\r\niounmap(xgifb_info->mmio_vbase);\r\niounmap(xgifb_info->video_vbase);\r\nrelease_mem_region(xgifb_info->mmio_base, xgifb_info->mmio_size);\r\nerror_0:\r\nrelease_mem_region(xgifb_info->video_base, xgifb_info->video_size);\r\nerror_disable:\r\npci_disable_device(pdev);\r\nerror:\r\nframebuffer_release(fb_info);\r\nreturn ret;\r\n}\r\nstatic void xgifb_remove(struct pci_dev *pdev)\r\n{\r\nstruct xgifb_video_info *xgifb_info = pci_get_drvdata(pdev);\r\nstruct fb_info *fb_info = xgifb_info->fb_info;\r\nunregister_framebuffer(fb_info);\r\n#ifdef CONFIG_MTRR\r\nif (xgifb_info->mtrr >= 0)\r\nmtrr_del(xgifb_info->mtrr, xgifb_info->video_base,\r\nxgifb_info->video_size);\r\n#endif\r\niounmap(xgifb_info->mmio_vbase);\r\niounmap(xgifb_info->video_vbase);\r\nrelease_mem_region(xgifb_info->mmio_base, xgifb_info->mmio_size);\r\nrelease_mem_region(xgifb_info->video_base, xgifb_info->video_size);\r\npci_disable_device(pdev);\r\nframebuffer_release(fb_info);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init xgifb_init(void)\r\n{\r\nchar *option = NULL;\r\nif (forcecrt2type != NULL)\r\nXGIfb_search_crt2type(forcecrt2type);\r\nif (fb_get_options("xgifb", &option))\r\nreturn -ENODEV;\r\nXGIfb_setup(option);\r\nreturn pci_register_driver(&xgifb_driver);\r\n}\r\nstatic void __exit xgifb_remove_module(void)\r\n{\r\npci_unregister_driver(&xgifb_driver);\r\npr_debug("Module unloaded\n");\r\n}
