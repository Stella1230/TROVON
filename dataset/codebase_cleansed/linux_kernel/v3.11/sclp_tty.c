static int\r\nsclp_tty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\ntty_port_tty_set(&sclp_port, tty);\r\ntty->driver_data = NULL;\r\nsclp_port.low_latency = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nsclp_tty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nif (tty->count > 1)\r\nreturn;\r\ntty_port_tty_set(&sclp_port, NULL);\r\n}\r\nstatic int\r\nsclp_tty_write_room (struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct list_head *l;\r\nint count;\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\ncount = 0;\r\nif (sclp_ttybuf != NULL)\r\ncount = sclp_buffer_space(sclp_ttybuf) / sizeof(struct mto);\r\nlist_for_each(l, &sclp_tty_pages)\r\ncount += NR_EMPTY_MTO_PER_SCCB;\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\nreturn count;\r\n}\r\nstatic void\r\nsclp_ttybuf_callback(struct sclp_buffer *buffer, int rc)\r\n{\r\nunsigned long flags;\r\nvoid *page;\r\ndo {\r\npage = sclp_unmake_buffer(buffer);\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\nlist_del(&buffer->list);\r\nsclp_tty_buffer_count--;\r\nlist_add_tail((struct list_head *) page, &sclp_tty_pages);\r\nbuffer = NULL;\r\nif (!list_empty(&sclp_tty_outqueue))\r\nbuffer = list_entry(sclp_tty_outqueue.next,\r\nstruct sclp_buffer, list);\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\n} while (buffer && sclp_emit_buffer(buffer, sclp_ttybuf_callback));\r\ntty_port_tty_wakeup(&sclp_port);\r\n}\r\nstatic inline void\r\n__sclp_ttybuf_emit(struct sclp_buffer *buffer)\r\n{\r\nunsigned long flags;\r\nint count;\r\nint rc;\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\nlist_add_tail(&buffer->list, &sclp_tty_outqueue);\r\ncount = sclp_tty_buffer_count++;\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\nif (count)\r\nreturn;\r\nrc = sclp_emit_buffer(buffer, sclp_ttybuf_callback);\r\nif (rc)\r\nsclp_ttybuf_callback(buffer, rc);\r\n}\r\nstatic void\r\nsclp_tty_timeout(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct sclp_buffer *buf;\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\nbuf = sclp_ttybuf;\r\nsclp_ttybuf = NULL;\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\nif (buf != NULL) {\r\n__sclp_ttybuf_emit(buf);\r\n}\r\n}\r\nstatic int sclp_tty_write_string(const unsigned char *str, int count, int may_fail)\r\n{\r\nunsigned long flags;\r\nvoid *page;\r\nint written;\r\nint overall_written;\r\nstruct sclp_buffer *buf;\r\nif (count <= 0)\r\nreturn 0;\r\noverall_written = 0;\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\ndo {\r\nif (sclp_ttybuf == NULL) {\r\nwhile (list_empty(&sclp_tty_pages)) {\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\nif (may_fail)\r\ngoto out;\r\nelse\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\n}\r\npage = sclp_tty_pages.next;\r\nlist_del((struct list_head *) page);\r\nsclp_ttybuf = sclp_make_buffer(page, sclp_tty_columns,\r\nSPACES_PER_TAB);\r\n}\r\nwritten = sclp_write(sclp_ttybuf, str, count);\r\noverall_written += written;\r\nif (written == count)\r\nbreak;\r\nbuf = sclp_ttybuf;\r\nsclp_ttybuf = NULL;\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\n__sclp_ttybuf_emit(buf);\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\nstr += written;\r\ncount -= written;\r\n} while (count > 0);\r\nif (sclp_ttybuf && sclp_chars_in_buffer(sclp_ttybuf) &&\r\n!timer_pending(&sclp_tty_timer)) {\r\ninit_timer(&sclp_tty_timer);\r\nsclp_tty_timer.function = sclp_tty_timeout;\r\nsclp_tty_timer.data = 0UL;\r\nsclp_tty_timer.expires = jiffies + HZ/10;\r\nadd_timer(&sclp_tty_timer);\r\n}\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\nout:\r\nreturn overall_written;\r\n}\r\nstatic int\r\nsclp_tty_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nif (sclp_tty_chars_count > 0) {\r\nsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\r\nsclp_tty_chars_count = 0;\r\n}\r\nreturn sclp_tty_write_string(buf, count, 1);\r\n}\r\nstatic int\r\nsclp_tty_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nsclp_tty_chars[sclp_tty_chars_count++] = ch;\r\nif (ch == '\n' || sclp_tty_chars_count >= SCLP_TTY_BUF_SIZE) {\r\nsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\r\nsclp_tty_chars_count = 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nsclp_tty_flush_chars(struct tty_struct *tty)\r\n{\r\nif (sclp_tty_chars_count > 0) {\r\nsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\r\nsclp_tty_chars_count = 0;\r\n}\r\n}\r\nstatic int\r\nsclp_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct list_head *l;\r\nstruct sclp_buffer *t;\r\nint count;\r\nspin_lock_irqsave(&sclp_tty_lock, flags);\r\ncount = 0;\r\nif (sclp_ttybuf != NULL)\r\ncount = sclp_chars_in_buffer(sclp_ttybuf);\r\nlist_for_each(l, &sclp_tty_outqueue) {\r\nt = list_entry(l, struct sclp_buffer, list);\r\ncount += sclp_chars_in_buffer(t);\r\n}\r\nspin_unlock_irqrestore(&sclp_tty_lock, flags);\r\nreturn count;\r\n}\r\nstatic void\r\nsclp_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nif (sclp_tty_chars_count > 0) {\r\nsclp_tty_write_string(sclp_tty_chars, sclp_tty_chars_count, 0);\r\nsclp_tty_chars_count = 0;\r\n}\r\n}\r\nstatic void\r\nsclp_tty_input(unsigned char* buf, unsigned int count)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&sclp_port);\r\nunsigned int cchar;\r\nif (tty == NULL)\r\nreturn;\r\ncchar = ctrlchar_handle(buf, count, tty);\r\nswitch (cchar & CTRLCHAR_MASK) {\r\ncase CTRLCHAR_SYSRQ:\r\nbreak;\r\ncase CTRLCHAR_CTRL:\r\ntty_insert_flip_char(&sclp_port, cchar, TTY_NORMAL);\r\ntty_flip_buffer_push(&sclp_port);\r\nbreak;\r\ncase CTRLCHAR_NONE:\r\nif (count < 2 ||\r\n(strncmp((const char *) buf + count - 2, "^n", 2) &&\r\nstrncmp((const char *) buf + count - 2, "\252n", 2))) {\r\ntty_insert_flip_string(&sclp_port, buf, count);\r\ntty_insert_flip_char(&sclp_port, '\n', TTY_NORMAL);\r\n} else\r\ntty_insert_flip_string(&sclp_port, buf, count - 2);\r\ntty_flip_buffer_push(&sclp_port);\r\nbreak;\r\n}\r\ntty_kref_put(tty);\r\n}\r\nstatic int sclp_switch_cases(unsigned char *buf, int count)\r\n{\r\nunsigned char *ip, *op;\r\nint toggle;\r\ntoggle = 0;\r\nip = op = buf;\r\nwhile (count-- > 0) {\r\nif (*ip == CASE_DELIMITER) {\r\nif (count && ip[1] == CASE_DELIMITER) {\r\n*op++ = *ip++;\r\ncount--;\r\n} else\r\ntoggle = ~toggle;\r\nip++;\r\n} else\r\nif (toggle)\r\nif (sclp_tty_tolower)\r\n*op++ = _ebc_toupper[(int) *ip++];\r\nelse\r\n*op++ = _ebc_tolower[(int) *ip++];\r\nelse\r\n*op++ = *ip++;\r\n}\r\nreturn op - buf;\r\n}\r\nstatic void sclp_get_input(struct gds_subvector *sv)\r\n{\r\nunsigned char *str;\r\nint count;\r\nstr = (unsigned char *) (sv + 1);\r\ncount = sv->length - sizeof(*sv);\r\nif (sclp_tty_tolower)\r\nEBC_TOLOWER(str, count);\r\ncount = sclp_switch_cases(str, count);\r\nsclp_ebcasc_str(str, count);\r\nsclp_tty_input(str, count);\r\n}\r\nstatic inline void sclp_eval_selfdeftextmsg(struct gds_subvector *sv)\r\n{\r\nvoid *end;\r\nend = (void *) sv + sv->length;\r\nfor (sv = sv + 1; (void *) sv < end; sv = (void *) sv + sv->length)\r\nif (sv->key == 0x30)\r\nsclp_get_input(sv);\r\n}\r\nstatic inline void sclp_eval_textcmd(struct gds_vector *v)\r\n{\r\nstruct gds_subvector *sv;\r\nvoid *end;\r\nend = (void *) v + v->length;\r\nfor (sv = (struct gds_subvector *) (v + 1);\r\n(void *) sv < end; sv = (void *) sv + sv->length)\r\nif (sv->key == GDS_KEY_SELFDEFTEXTMSG)\r\nsclp_eval_selfdeftextmsg(sv);\r\n}\r\nstatic inline void sclp_eval_cpmsu(struct gds_vector *v)\r\n{\r\nvoid *end;\r\nend = (void *) v + v->length;\r\nfor (v = v + 1; (void *) v < end; v = (void *) v + v->length)\r\nif (v->gds_id == GDS_ID_TEXTCMD)\r\nsclp_eval_textcmd(v);\r\n}\r\nstatic inline void sclp_eval_mdsmu(struct gds_vector *v)\r\n{\r\nv = sclp_find_gds_vector(v + 1, (void *) v + v->length, GDS_ID_CPMSU);\r\nif (v)\r\nsclp_eval_cpmsu(v);\r\n}\r\nstatic void sclp_tty_receiver(struct evbuf_header *evbuf)\r\n{\r\nstruct gds_vector *v;\r\nv = sclp_find_gds_vector(evbuf + 1, (void *) evbuf + evbuf->length,\r\nGDS_ID_MDSMU);\r\nif (v)\r\nsclp_eval_mdsmu(v);\r\n}\r\nstatic void\r\nsclp_tty_state_change(struct sclp_register *reg)\r\n{\r\n}\r\nstatic int __init\r\nsclp_tty_init(void)\r\n{\r\nstruct tty_driver *driver;\r\nvoid *page;\r\nint i;\r\nint rc;\r\nif (!CONSOLE_IS_SCLP)\r\nreturn 0;\r\ndriver = alloc_tty_driver(1);\r\nif (!driver)\r\nreturn -ENOMEM;\r\nrc = sclp_rw_init();\r\nif (rc) {\r\nput_tty_driver(driver);\r\nreturn rc;\r\n}\r\nINIT_LIST_HEAD(&sclp_tty_pages);\r\nfor (i = 0; i < MAX_KMEM_PAGES; i++) {\r\npage = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (page == NULL) {\r\nput_tty_driver(driver);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail((struct list_head *) page, &sclp_tty_pages);\r\n}\r\nINIT_LIST_HEAD(&sclp_tty_outqueue);\r\nspin_lock_init(&sclp_tty_lock);\r\ninit_timer(&sclp_tty_timer);\r\nsclp_ttybuf = NULL;\r\nsclp_tty_buffer_count = 0;\r\nif (MACHINE_IS_VM) {\r\nsclp_tty_columns = 76;\r\nsclp_tty_tolower = 1;\r\n}\r\nsclp_tty_chars_count = 0;\r\nrc = sclp_register(&sclp_input_event);\r\nif (rc) {\r\nput_tty_driver(driver);\r\nreturn rc;\r\n}\r\ntty_port_init(&sclp_port);\r\ndriver->driver_name = "sclp_line";\r\ndriver->name = "sclp_line";\r\ndriver->major = TTY_MAJOR;\r\ndriver->minor_start = 64;\r\ndriver->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndriver->subtype = SYSTEM_TYPE_TTY;\r\ndriver->init_termios = tty_std_termios;\r\ndriver->init_termios.c_iflag = IGNBRK | IGNPAR;\r\ndriver->init_termios.c_oflag = ONLCR | XTABS;\r\ndriver->init_termios.c_lflag = ISIG | ECHO;\r\ndriver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(driver, &sclp_ops);\r\ntty_port_link_device(&sclp_port, driver, 0);\r\nrc = tty_register_driver(driver);\r\nif (rc) {\r\nput_tty_driver(driver);\r\ntty_port_destroy(&sclp_port);\r\nreturn rc;\r\n}\r\nsclp_tty_driver = driver;\r\nreturn 0;\r\n}
