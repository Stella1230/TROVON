static int\r\nwavefront_fx_idle (snd_wavefront_t *dev)\r\n{\r\nint i;\r\nunsigned int x = 0x80;\r\nfor (i = 0; i < 1000; i++) {\r\nx = inb (dev->fx_status);\r\nif ((x & 0x80) == 0) {\r\nbreak;\r\n}\r\n}\r\nif (x & 0x80) {\r\nsnd_printk ("FX device never idle.\n");\r\nreturn 0;\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nwavefront_fx_mute (snd_wavefront_t *dev, int onoff)\r\n{\r\nif (!wavefront_fx_idle(dev)) {\r\nreturn;\r\n}\r\noutb (onoff ? 0x02 : 0x00, dev->fx_op);\r\n}\r\nstatic int\r\nwavefront_fx_memset (snd_wavefront_t *dev,\r\nint page,\r\nint addr,\r\nint cnt,\r\nunsigned short *data)\r\n{\r\nif (page < 0 || page > 7) {\r\nsnd_printk ("FX memset: "\r\n"page must be >= 0 and <= 7\n");\r\nreturn -(EINVAL);\r\n}\r\nif (addr < 0 || addr > 0x7f) {\r\nsnd_printk ("FX memset: "\r\n"addr must be >= 0 and <= 7f\n");\r\nreturn -(EINVAL);\r\n}\r\nif (cnt == 1) {\r\noutb (FX_LSB_TRANSFER, dev->fx_lcr);\r\noutb (page, dev->fx_dsp_page);\r\noutb (addr, dev->fx_dsp_addr);\r\noutb ((data[0] >> 8), dev->fx_dsp_msb);\r\noutb ((data[0] & 0xff), dev->fx_dsp_lsb);\r\nsnd_printk ("FX: addr %d:%x set to 0x%x\n",\r\npage, addr, data[0]);\r\n} else {\r\nint i;\r\noutb (FX_AUTO_INCR|FX_LSB_TRANSFER, dev->fx_lcr);\r\noutb (page, dev->fx_dsp_page);\r\noutb (addr, dev->fx_dsp_addr);\r\nfor (i = 0; i < cnt; i++) {\r\noutb ((data[i] >> 8), dev->fx_dsp_msb);\r\noutb ((data[i] & 0xff), dev->fx_dsp_lsb);\r\nif (!wavefront_fx_idle (dev)) {\r\nbreak;\r\n}\r\n}\r\nif (i != cnt) {\r\nsnd_printk ("FX memset "\r\n"(0x%x, 0x%x, 0x%lx, %d) incomplete\n",\r\npage, addr, (unsigned long) data, cnt);\r\nreturn -(EIO);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_fx_detect (snd_wavefront_t *dev)\r\n{\r\nif (inb (dev->fx_status) & 0x80) {\r\nsnd_printk ("Hmm, probably a Maui or Tropez.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_fx_open (struct snd_hwdep *hw, struct file *file)\r\n{\r\nif (!try_module_get(hw->card->module))\r\nreturn -EFAULT;\r\nfile->private_data = hw;\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_fx_release (struct snd_hwdep *hw, struct file *file)\r\n{\r\nmodule_put(hw->card->module);\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_fx_ioctl (struct snd_hwdep *sdev, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_card *card;\r\nsnd_wavefront_card_t *acard;\r\nsnd_wavefront_t *dev;\r\nwavefront_fx_info r;\r\nunsigned short *page_data = NULL;\r\nunsigned short *pd;\r\nint err = 0;\r\ncard = sdev->card;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENODEV;\r\nif (snd_BUG_ON(!card->private_data))\r\nreturn -ENODEV;\r\nacard = card->private_data;\r\ndev = &acard->wavefront;\r\nif (copy_from_user (&r, (void __user *)arg, sizeof (wavefront_fx_info)))\r\nreturn -EFAULT;\r\nswitch (r.request) {\r\ncase WFFX_MUTE:\r\nwavefront_fx_mute (dev, r.data[0]);\r\nreturn -EIO;\r\ncase WFFX_MEMSET:\r\nif (r.data[2] <= 0) {\r\nsnd_printk ("cannot write "\r\n"<= 0 bytes to FX\n");\r\nreturn -EIO;\r\n} else if (r.data[2] == 1) {\r\npd = (unsigned short *) &r.data[3];\r\n} else {\r\nif (r.data[2] > 256) {\r\nsnd_printk ("cannot write "\r\n"> 512 bytes to FX\n");\r\nreturn -EIO;\r\n}\r\npage_data = memdup_user((unsigned char __user *)\r\nr.data[3],\r\nr.data[2] * sizeof(short));\r\nif (IS_ERR(page_data))\r\nreturn PTR_ERR(page_data);\r\npd = page_data;\r\n}\r\nerr = wavefront_fx_memset (dev,\r\nr.data[0],\r\nr.data[1],\r\nr.data[2],\r\npd);\r\nkfree(page_data);\r\nbreak;\r\ndefault:\r\nsnd_printk ("FX: ioctl %d not yet supported\n",\r\nr.request);\r\nreturn -ENOTTY;\r\n}\r\nreturn err;\r\n}\r\nint\r\nsnd_wavefront_fx_start (snd_wavefront_t *dev)\r\n{\r\nunsigned int i;\r\nint err;\r\nconst struct firmware *firmware = NULL;\r\nif (dev->fx_initialized)\r\nreturn 0;\r\nerr = request_firmware(&firmware, "yamaha/yss225_registers.bin",\r\ndev->card->dev);\r\nif (err < 0) {\r\nerr = -1;\r\ngoto out;\r\n}\r\nfor (i = 0; i + 1 < firmware->size; i += 2) {\r\nif (firmware->data[i] >= 8 && firmware->data[i] < 16) {\r\noutb(firmware->data[i + 1],\r\ndev->base + firmware->data[i]);\r\n} else if (firmware->data[i] == WAIT_IDLE) {\r\nif (!wavefront_fx_idle(dev)) {\r\nerr = -1;\r\ngoto out;\r\n}\r\n} else {\r\nsnd_printk(KERN_ERR "invalid address"\r\n" in register data\n");\r\nerr = -1;\r\ngoto out;\r\n}\r\n}\r\ndev->fx_initialized = 1;\r\nerr = 0;\r\nout:\r\nrelease_firmware(firmware);\r\nreturn err;\r\n}
