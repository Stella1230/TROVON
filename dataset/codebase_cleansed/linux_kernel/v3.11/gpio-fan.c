static void fan_alarm_notify(struct work_struct *ws)\r\n{\r\nstruct gpio_fan_data *fan_data =\r\ncontainer_of(ws, struct gpio_fan_data, alarm_work);\r\nsysfs_notify(&fan_data->pdev->dev.kobj, NULL, "fan1_alarm");\r\nkobject_uevent(&fan_data->pdev->dev.kobj, KOBJ_CHANGE);\r\n}\r\nstatic irqreturn_t fan_alarm_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_id;\r\nschedule_work(&fan_data->alarm_work);\r\nreturn IRQ_NONE;\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nstruct gpio_fan_alarm *alarm = fan_data->alarm;\r\nint value = gpio_get_value(alarm->gpio);\r\nif (alarm->active_low)\r\nvalue = !value;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic int fan_alarm_init(struct gpio_fan_data *fan_data,\r\nstruct gpio_fan_alarm *alarm)\r\n{\r\nint err;\r\nint alarm_irq;\r\nstruct platform_device *pdev = fan_data->pdev;\r\nfan_data->alarm = alarm;\r\nerr = devm_gpio_request(&pdev->dev, alarm->gpio, "GPIO fan alarm");\r\nif (err)\r\nreturn err;\r\nerr = gpio_direction_input(alarm->gpio);\r\nif (err)\r\nreturn err;\r\nalarm_irq = gpio_to_irq(alarm->gpio);\r\nif (alarm_irq < 0)\r\nreturn 0;\r\nINIT_WORK(&fan_data->alarm_work, fan_alarm_notify);\r\nirq_set_irq_type(alarm_irq, IRQ_TYPE_EDGE_BOTH);\r\nerr = devm_request_irq(&pdev->dev, alarm_irq, fan_alarm_irq_handler,\r\nIRQF_SHARED, "GPIO fan alarm", fan_data);\r\nreturn err;\r\n}\r\nstatic void __set_fan_ctrl(struct gpio_fan_data *fan_data, int ctrl_val)\r\n{\r\nint i;\r\nfor (i = 0; i < fan_data->num_ctrl; i++)\r\ngpio_set_value(fan_data->ctrl[i], (ctrl_val >> i) & 1);\r\n}\r\nstatic int __get_fan_ctrl(struct gpio_fan_data *fan_data)\r\n{\r\nint i;\r\nint ctrl_val = 0;\r\nfor (i = 0; i < fan_data->num_ctrl; i++) {\r\nint value;\r\nvalue = gpio_get_value(fan_data->ctrl[i]);\r\nctrl_val |= (value << i);\r\n}\r\nreturn ctrl_val;\r\n}\r\nstatic void set_fan_speed(struct gpio_fan_data *fan_data, int speed_index)\r\n{\r\nif (fan_data->speed_index == speed_index)\r\nreturn;\r\n__set_fan_ctrl(fan_data, fan_data->speed[speed_index].ctrl_val);\r\nfan_data->speed_index = speed_index;\r\n}\r\nstatic int get_fan_speed_index(struct gpio_fan_data *fan_data)\r\n{\r\nint ctrl_val = __get_fan_ctrl(fan_data);\r\nint i;\r\nfor (i = 0; i < fan_data->num_speed; i++)\r\nif (fan_data->speed[i].ctrl_val == ctrl_val)\r\nreturn i;\r\ndev_warn(&fan_data->pdev->dev,\r\n"missing speed array entry for GPIO value 0x%x\n", ctrl_val);\r\nreturn -EINVAL;\r\n}\r\nstatic int rpm_to_speed_index(struct gpio_fan_data *fan_data, int rpm)\r\n{\r\nstruct gpio_fan_speed *speed = fan_data->speed;\r\nint i;\r\nfor (i = 0; i < fan_data->num_speed; i++)\r\nif (speed[i].rpm >= rpm)\r\nreturn i;\r\nreturn fan_data->num_speed - 1;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nu8 pwm = fan_data->speed_index * 255 / (fan_data->num_speed - 1);\r\nreturn sprintf(buf, "%d\n", pwm);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nunsigned long pwm;\r\nint speed_index;\r\nint ret = count;\r\nif (kstrtoul(buf, 10, &pwm) || pwm > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&fan_data->lock);\r\nif (!fan_data->pwm_enable) {\r\nret = -EPERM;\r\ngoto exit_unlock;\r\n}\r\nspeed_index = DIV_ROUND_UP(pwm * (fan_data->num_speed - 1), 255);\r\nset_fan_speed(fan_data, speed_index);\r\nexit_unlock:\r\nmutex_unlock(&fan_data->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", fan_data->pwm_enable);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val) || val > 1)\r\nreturn -EINVAL;\r\nif (fan_data->pwm_enable == val)\r\nreturn count;\r\nmutex_lock(&fan_data->lock);\r\nfan_data->pwm_enable = val;\r\nif (val == 0)\r\nset_fan_speed(fan_data, fan_data->num_speed - 1);\r\nmutex_unlock(&fan_data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_rpm_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", fan_data->speed[0].rpm);\r\n}\r\nstatic ssize_t show_rpm_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n",\r\nfan_data->speed[fan_data->num_speed - 1].rpm);\r\n}\r\nstatic ssize_t show_rpm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", fan_data->speed[fan_data->speed_index].rpm);\r\n}\r\nstatic ssize_t set_rpm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nunsigned long rpm;\r\nint ret = count;\r\nif (kstrtoul(buf, 10, &rpm))\r\nreturn -EINVAL;\r\nmutex_lock(&fan_data->lock);\r\nif (!fan_data->pwm_enable) {\r\nret = -EPERM;\r\ngoto exit_unlock;\r\n}\r\nset_fan_speed(fan_data, rpm_to_speed_index(fan_data, rpm));\r\nexit_unlock:\r\nmutex_unlock(&fan_data->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "gpio-fan\n");\r\n}\r\nstatic umode_t gpio_fan_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct gpio_fan_data *data = dev_get_drvdata(dev);\r\nif (index == 1 && !data->alarm)\r\nreturn 0;\r\nif (index > 1 && !data->ctrl)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic int fan_ctrl_init(struct gpio_fan_data *fan_data,\r\nstruct gpio_fan_platform_data *pdata)\r\n{\r\nstruct platform_device *pdev = fan_data->pdev;\r\nint num_ctrl = pdata->num_ctrl;\r\nunsigned *ctrl = pdata->ctrl;\r\nint i, err;\r\nfor (i = 0; i < num_ctrl; i++) {\r\nerr = devm_gpio_request(&pdev->dev, ctrl[i],\r\n"GPIO fan control");\r\nif (err)\r\nreturn err;\r\nerr = gpio_direction_output(ctrl[i], gpio_get_value(ctrl[i]));\r\nif (err)\r\nreturn err;\r\n}\r\nfan_data->num_ctrl = num_ctrl;\r\nfan_data->ctrl = ctrl;\r\nfan_data->num_speed = pdata->num_speed;\r\nfan_data->speed = pdata->speed;\r\nfan_data->pwm_enable = true;\r\nfan_data->speed_index = get_fan_speed_index(fan_data);\r\nif (fan_data->speed_index < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int gpio_fan_get_of_pdata(struct device *dev,\r\nstruct gpio_fan_platform_data *pdata)\r\n{\r\nstruct device_node *node;\r\nstruct gpio_fan_speed *speed;\r\nunsigned *ctrl;\r\nunsigned i;\r\nu32 u;\r\nstruct property *prop;\r\nconst __be32 *p;\r\nnode = dev->of_node;\r\npdata->num_ctrl = of_gpio_count(node);\r\nif (pdata->num_ctrl <= 0) {\r\ndev_err(dev, "gpios DT property empty / missing");\r\nreturn -ENODEV;\r\n}\r\nctrl = devm_kzalloc(dev, pdata->num_ctrl * sizeof(unsigned),\r\nGFP_KERNEL);\r\nif (!ctrl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pdata->num_ctrl; i++) {\r\nint val;\r\nval = of_get_gpio(node, i);\r\nif (val < 0)\r\nreturn val;\r\nctrl[i] = val;\r\n}\r\npdata->ctrl = ctrl;\r\nprop = of_find_property(node, "gpio-fan,speed-map", &i);\r\nif (!prop) {\r\ndev_err(dev, "gpio-fan,speed-map DT property missing");\r\nreturn -ENODEV;\r\n}\r\ni = i / sizeof(u32);\r\nif (i == 0 || i & 1) {\r\ndev_err(dev, "gpio-fan,speed-map contains zero/odd number of entries");\r\nreturn -ENODEV;\r\n}\r\npdata->num_speed = i / 2;\r\nspeed = devm_kzalloc(dev,\r\npdata->num_speed * sizeof(struct gpio_fan_speed),\r\nGFP_KERNEL);\r\nif (!speed)\r\nreturn -ENOMEM;\r\np = NULL;\r\nfor (i = 0; i < pdata->num_speed; i++) {\r\np = of_prop_next_u32(prop, p, &u);\r\nif (!p)\r\nreturn -ENODEV;\r\nspeed[i].rpm = u;\r\np = of_prop_next_u32(prop, p, &u);\r\nif (!p)\r\nreturn -ENODEV;\r\nspeed[i].ctrl_val = u;\r\n}\r\npdata->speed = speed;\r\nif (of_gpio_named_count(node, "alarm-gpios") > 0) {\r\nstruct gpio_fan_alarm *alarm;\r\nint val;\r\nenum of_gpio_flags flags;\r\nalarm = devm_kzalloc(dev, sizeof(struct gpio_fan_alarm),\r\nGFP_KERNEL);\r\nif (!alarm)\r\nreturn -ENOMEM;\r\nval = of_get_named_gpio_flags(node, "alarm-gpios", 0, &flags);\r\nif (val < 0)\r\nreturn val;\r\nalarm->gpio = val;\r\nalarm->active_low = flags & OF_GPIO_ACTIVE_LOW;\r\npdata->alarm = alarm;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_fan_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct gpio_fan_data *fan_data;\r\nstruct gpio_fan_platform_data *pdata = pdev->dev.platform_data;\r\n#ifdef CONFIG_OF_GPIO\r\nif (!pdata) {\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct gpio_fan_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nerr = gpio_fan_get_of_pdata(&pdev->dev, pdata);\r\nif (err)\r\nreturn err;\r\n}\r\n#else\r\nif (!pdata)\r\nreturn -EINVAL;\r\n#endif\r\nfan_data = devm_kzalloc(&pdev->dev, sizeof(struct gpio_fan_data),\r\nGFP_KERNEL);\r\nif (!fan_data)\r\nreturn -ENOMEM;\r\nfan_data->pdev = pdev;\r\nplatform_set_drvdata(pdev, fan_data);\r\nmutex_init(&fan_data->lock);\r\nif (pdata->alarm) {\r\nerr = fan_alarm_init(fan_data, pdata->alarm);\r\nif (err)\r\nreturn err;\r\n}\r\nif (pdata->ctrl && pdata->num_ctrl > 0) {\r\nif (!pdata->speed || pdata->num_speed <= 1)\r\nreturn -EINVAL;\r\nerr = fan_ctrl_init(fan_data, pdata);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = sysfs_create_group(&pdev->dev.kobj, &gpio_fan_group);\r\nif (err)\r\nreturn err;\r\nfan_data->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(fan_data->hwmon_dev)) {\r\nerr = PTR_ERR(fan_data->hwmon_dev);\r\ngoto err_remove;\r\n}\r\ndev_info(&pdev->dev, "GPIO fan initialized\n");\r\nreturn 0;\r\nerr_remove:\r\nsysfs_remove_group(&pdev->dev.kobj, &gpio_fan_group);\r\nreturn err;\r\n}\r\nstatic int gpio_fan_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_fan_data *fan_data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(fan_data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &gpio_fan_group);\r\nreturn 0;\r\n}\r\nstatic int gpio_fan_suspend(struct device *dev)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nif (fan_data->ctrl) {\r\nfan_data->resume_speed = fan_data->speed_index;\r\nset_fan_speed(fan_data, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_fan_resume(struct device *dev)\r\n{\r\nstruct gpio_fan_data *fan_data = dev_get_drvdata(dev);\r\nif (fan_data->ctrl)\r\nset_fan_speed(fan_data, fan_data->resume_speed);\r\nreturn 0;\r\n}
