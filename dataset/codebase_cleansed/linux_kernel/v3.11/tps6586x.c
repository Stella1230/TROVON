static inline struct tps6586x *dev_to_tps6586x(struct device *dev)\r\n{\r\nreturn i2c_get_clientdata(to_i2c_client(dev));\r\n}\r\nint tps6586x_write(struct device *dev, int reg, uint8_t val)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn regmap_write(tps6586x->regmap, reg, val);\r\n}\r\nint tps6586x_writes(struct device *dev, int reg, int len, uint8_t *val)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn regmap_bulk_write(tps6586x->regmap, reg, val, len);\r\n}\r\nint tps6586x_read(struct device *dev, int reg, uint8_t *val)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nunsigned int rval;\r\nint ret;\r\nret = regmap_read(tps6586x->regmap, reg, &rval);\r\nif (!ret)\r\n*val = rval;\r\nreturn ret;\r\n}\r\nint tps6586x_reads(struct device *dev, int reg, int len, uint8_t *val)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn regmap_bulk_read(tps6586x->regmap, reg, val, len);\r\n}\r\nint tps6586x_set_bits(struct device *dev, int reg, uint8_t bit_mask)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn regmap_update_bits(tps6586x->regmap, reg, bit_mask, bit_mask);\r\n}\r\nint tps6586x_clr_bits(struct device *dev, int reg, uint8_t bit_mask)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn regmap_update_bits(tps6586x->regmap, reg, bit_mask, 0);\r\n}\r\nint tps6586x_update(struct device *dev, int reg, uint8_t val, uint8_t mask)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn regmap_update_bits(tps6586x->regmap, reg, mask, val);\r\n}\r\nint tps6586x_irq_get_virq(struct device *dev, int irq)\r\n{\r\nstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\r\nreturn irq_create_mapping(tps6586x->irq_domain, irq);\r\n}\r\nstatic int __remove_subdev(struct device *dev, void *unused)\r\n{\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic int tps6586x_remove_subdevs(struct tps6586x *tps6586x)\r\n{\r\nreturn device_for_each_child(tps6586x->dev, NULL, __remove_subdev);\r\n}\r\nstatic void tps6586x_irq_lock(struct irq_data *data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&tps6586x->irq_lock);\r\n}\r\nstatic void tps6586x_irq_enable(struct irq_data *irq_data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\r\nunsigned int __irq = irq_data->hwirq;\r\nconst struct tps6586x_irq_data *data = &tps6586x_irqs[__irq];\r\ntps6586x->mask_reg[data->mask_reg] &= ~data->mask_mask;\r\ntps6586x->irq_en |= (1 << __irq);\r\n}\r\nstatic void tps6586x_irq_disable(struct irq_data *irq_data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\r\nunsigned int __irq = irq_data->hwirq;\r\nconst struct tps6586x_irq_data *data = &tps6586x_irqs[__irq];\r\ntps6586x->mask_reg[data->mask_reg] |= data->mask_mask;\r\ntps6586x->irq_en &= ~(1 << __irq);\r\n}\r\nstatic void tps6586x_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(data);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tps6586x->mask_reg); i++) {\r\nint ret;\r\nret = tps6586x_write(tps6586x->dev,\r\nTPS6586X_INT_MASK1 + i,\r\ntps6586x->mask_reg[i]);\r\nWARN_ON(ret);\r\n}\r\nmutex_unlock(&tps6586x->irq_lock);\r\n}\r\nstatic int tps6586x_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct tps6586x *tps6586x = h->host_data;\r\nirq_set_chip_data(virq, tps6586x);\r\nirq_set_chip_and_handler(virq, &tps6586x_irq_chip, handle_simple_irq);\r\nirq_set_nested_thread(virq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(virq);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tps6586x_irq(int irq, void *data)\r\n{\r\nstruct tps6586x *tps6586x = data;\r\nu32 acks;\r\nint ret = 0;\r\nret = tps6586x_reads(tps6586x->dev, TPS6586X_INT_ACK1,\r\nsizeof(acks), (uint8_t *)&acks);\r\nif (ret < 0) {\r\ndev_err(tps6586x->dev, "failed to read interrupt status\n");\r\nreturn IRQ_NONE;\r\n}\r\nacks = le32_to_cpu(acks);\r\nwhile (acks) {\r\nint i = __ffs(acks);\r\nif (tps6586x->irq_en & (1 << i))\r\nhandle_nested_irq(\r\nirq_find_mapping(tps6586x->irq_domain, i));\r\nacks &= ~(1 << i);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tps6586x_irq_init(struct tps6586x *tps6586x, int irq,\r\nint irq_base)\r\n{\r\nint i, ret;\r\nu8 tmp[4];\r\nint new_irq_base;\r\nint irq_num = ARRAY_SIZE(tps6586x_irqs);\r\nmutex_init(&tps6586x->irq_lock);\r\nfor (i = 0; i < 5; i++) {\r\ntps6586x->mask_reg[i] = 0xff;\r\ntps6586x_write(tps6586x->dev, TPS6586X_INT_MASK1 + i, 0xff);\r\n}\r\ntps6586x_reads(tps6586x->dev, TPS6586X_INT_ACK1, sizeof(tmp), tmp);\r\nif (irq_base > 0) {\r\nnew_irq_base = irq_alloc_descs(irq_base, 0, irq_num, -1);\r\nif (new_irq_base < 0) {\r\ndev_err(tps6586x->dev,\r\n"Failed to alloc IRQs: %d\n", new_irq_base);\r\nreturn new_irq_base;\r\n}\r\n} else {\r\nnew_irq_base = 0;\r\n}\r\ntps6586x->irq_domain = irq_domain_add_simple(tps6586x->dev->of_node,\r\nirq_num, new_irq_base, &tps6586x_domain_ops,\r\ntps6586x);\r\nif (!tps6586x->irq_domain) {\r\ndev_err(tps6586x->dev, "Failed to create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nret = request_threaded_irq(irq, NULL, tps6586x_irq, IRQF_ONESHOT,\r\n"tps6586x", tps6586x);\r\nif (!ret) {\r\ndevice_init_wakeup(tps6586x->dev, 1);\r\nenable_irq_wake(irq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tps6586x_add_subdevs(struct tps6586x *tps6586x,\r\nstruct tps6586x_platform_data *pdata)\r\n{\r\nstruct tps6586x_subdev_info *subdev;\r\nstruct platform_device *pdev;\r\nint i, ret = 0;\r\nfor (i = 0; i < pdata->num_subdevs; i++) {\r\nsubdev = &pdata->subdevs[i];\r\npdev = platform_device_alloc(subdev->name, subdev->id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\npdev->dev.parent = tps6586x->dev;\r\npdev->dev.platform_data = subdev->platform_data;\r\npdev->dev.of_node = subdev->of_node;\r\nret = platform_device_add(pdev);\r\nif (ret) {\r\nplatform_device_put(pdev);\r\ngoto failed;\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\ntps6586x_remove_subdevs(tps6586x);\r\nreturn ret;\r\n}\r\nstatic struct tps6586x_platform_data *tps6586x_parse_dt(struct i2c_client *client)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nstruct tps6586x_platform_data *pdata;\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&client->dev, "Memory allocation failed\n");\r\nreturn NULL;\r\n}\r\npdata->num_subdevs = 0;\r\npdata->subdevs = NULL;\r\npdata->gpio_base = -1;\r\npdata->irq_base = -1;\r\npdata->pm_off = of_property_read_bool(np, "ti,system-power-controller");\r\nreturn pdata;\r\n}\r\nstatic struct tps6586x_platform_data *tps6586x_parse_dt(struct i2c_client *client)\r\n{\r\nreturn NULL;\r\n}\r\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nif ((reg >= TPS6586X_INT_MASK1) && (reg <= TPS6586X_INT_MASK5))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void tps6586x_power_off(void)\r\n{\r\nif (tps6586x_clr_bits(tps6586x_dev, TPS6586X_SUPPLYENE, EXITSLREQ_BIT))\r\nreturn;\r\ntps6586x_set_bits(tps6586x_dev, TPS6586X_SUPPLYENE, SLEEP_MODE_BIT);\r\n}\r\nstatic int tps6586x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tps6586x_platform_data *pdata = client->dev.platform_data;\r\nstruct tps6586x *tps6586x;\r\nint ret;\r\nif (!pdata && client->dev.of_node)\r\npdata = tps6586x_parse_dt(client);\r\nif (!pdata) {\r\ndev_err(&client->dev, "tps6586x requires platform data\n");\r\nreturn -ENOTSUPP;\r\n}\r\nret = i2c_smbus_read_byte_data(client, TPS6586X_VERSIONCRC);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Chip ID read failed: %d\n", ret);\r\nreturn -EIO;\r\n}\r\ndev_info(&client->dev, "VERSIONCRC is %02x\n", ret);\r\ntps6586x = devm_kzalloc(&client->dev, sizeof(*tps6586x), GFP_KERNEL);\r\nif (tps6586x == NULL) {\r\ndev_err(&client->dev, "memory for tps6586x alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\ntps6586x->client = client;\r\ntps6586x->dev = &client->dev;\r\ni2c_set_clientdata(client, tps6586x);\r\ntps6586x->regmap = devm_regmap_init_i2c(client,\r\n&tps6586x_regmap_config);\r\nif (IS_ERR(tps6586x->regmap)) {\r\nret = PTR_ERR(tps6586x->regmap);\r\ndev_err(&client->dev, "regmap init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (client->irq) {\r\nret = tps6586x_irq_init(tps6586x, client->irq,\r\npdata->irq_base);\r\nif (ret) {\r\ndev_err(&client->dev, "IRQ init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = mfd_add_devices(tps6586x->dev, -1,\r\ntps6586x_cell, ARRAY_SIZE(tps6586x_cell),\r\nNULL, 0, tps6586x->irq_domain);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "mfd_add_devices failed: %d\n", ret);\r\ngoto err_mfd_add;\r\n}\r\nret = tps6586x_add_subdevs(tps6586x, pdata);\r\nif (ret) {\r\ndev_err(&client->dev, "add devices failed: %d\n", ret);\r\ngoto err_add_devs;\r\n}\r\nif (pdata->pm_off && !pm_power_off) {\r\ntps6586x_dev = &client->dev;\r\npm_power_off = tps6586x_power_off;\r\n}\r\nreturn 0;\r\nerr_add_devs:\r\nmfd_remove_devices(tps6586x->dev);\r\nerr_mfd_add:\r\nif (client->irq)\r\nfree_irq(client->irq, tps6586x);\r\nreturn ret;\r\n}\r\nstatic int tps6586x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tps6586x *tps6586x = i2c_get_clientdata(client);\r\ntps6586x_remove_subdevs(tps6586x);\r\nmfd_remove_devices(tps6586x->dev);\r\nif (client->irq)\r\nfree_irq(client->irq, tps6586x);\r\nreturn 0;\r\n}\r\nstatic int __init tps6586x_init(void)\r\n{\r\nreturn i2c_add_driver(&tps6586x_driver);\r\n}\r\nstatic void __exit tps6586x_exit(void)\r\n{\r\ni2c_del_driver(&tps6586x_driver);\r\n}
