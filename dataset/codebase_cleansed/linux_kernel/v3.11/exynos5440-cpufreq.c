static int init_div_table(void)\r\n{\r\nstruct cpufreq_frequency_table *freq_tbl = dvfs_info->freq_table;\r\nunsigned int tmp, clk_div, ema_div, freq, volt_id;\r\nint i = 0;\r\nstruct opp *opp;\r\nrcu_read_lock();\r\nfor (i = 0; freq_tbl[i].frequency != CPUFREQ_TABLE_END; i++) {\r\nopp = opp_find_freq_exact(dvfs_info->dev,\r\nfreq_tbl[i].frequency * 1000, true);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(dvfs_info->dev,\r\n"failed to find valid OPP for %u KHZ\n",\r\nfreq_tbl[i].frequency);\r\nreturn PTR_ERR(opp);\r\n}\r\nfreq = freq_tbl[i].frequency / 1000;\r\nclk_div = ((freq / CPU_DIV_FREQ_MAX) & P0_7_CPUCLKDEV_MASK)\r\n<< P0_7_CPUCLKDEV_SHIFT;\r\nclk_div |= ((freq / CPU_ATB_FREQ_MAX) & P0_7_ATBCLKDEV_MASK)\r\n<< P0_7_ATBCLKDEV_SHIFT;\r\nclk_div |= ((freq / CPU_DBG_FREQ_MAX) & P0_7_CSCLKDEV_MASK)\r\n<< P0_7_CSCLKDEV_SHIFT;\r\nvolt_id = opp_get_voltage(opp);\r\nvolt_id = (MAX_VOLTAGE - volt_id) / VOLTAGE_STEP;\r\nif (volt_id < PMIC_HIGH_VOLT) {\r\nema_div = (CPUEMA_HIGH << P0_7_CPUEMA_SHIFT) |\r\n(L2EMA_HIGH << P0_7_L2EMA_SHIFT);\r\n} else if (volt_id > PMIC_LOW_VOLT) {\r\nema_div = (CPUEMA_LOW << P0_7_CPUEMA_SHIFT) |\r\n(L2EMA_LOW << P0_7_L2EMA_SHIFT);\r\n} else {\r\nema_div = (CPUEMA_MID << P0_7_CPUEMA_SHIFT) |\r\n(L2EMA_MID << P0_7_L2EMA_SHIFT);\r\n}\r\ntmp = (clk_div | ema_div | (volt_id << P0_7_VDD_SHIFT)\r\n| ((freq / FREQ_UNIT) << P0_7_FREQ_SHIFT));\r\n__raw_writel(tmp, dvfs_info->base + XMU_PMU_P0_7 + 4 * i);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic void exynos_enable_dvfs(void)\r\n{\r\nunsigned int tmp, i, cpu;\r\nstruct cpufreq_frequency_table *freq_table = dvfs_info->freq_table;\r\n__raw_writel(0, dvfs_info->base + XMU_DVFS_CTRL);\r\ntmp = __raw_readl(dvfs_info->base + XMU_PMUEVTEN);\r\ntmp |= (1 << PSTATE_CHANGED_EVTEN_SHIFT);\r\n__raw_writel(tmp, dvfs_info->base + XMU_PMUEVTEN);\r\ntmp = __raw_readl(dvfs_info->base + XMU_PMUIRQEN);\r\ntmp |= (1 << PSTATE_CHANGED_IRQEN_SHIFT);\r\n__raw_writel(tmp, dvfs_info->base + XMU_PMUIRQEN);\r\nfor (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++)\r\nif (freq_table[i].frequency == dvfs_info->cur_frequency)\r\nbreak;\r\nif (freq_table[i].frequency == CPUFREQ_TABLE_END) {\r\ndev_crit(dvfs_info->dev, "Boot up frequency not supported\n");\r\ni = 0;\r\ndvfs_info->cur_frequency = freq_table[i].frequency;\r\n}\r\ndev_info(dvfs_info->dev, "Setting dvfs initial frequency = %uKHZ",\r\ndvfs_info->cur_frequency);\r\nfor (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {\r\ntmp = __raw_readl(dvfs_info->base + XMU_C0_3_PSTATE + cpu * 4);\r\ntmp &= ~(P_VALUE_MASK << C0_3_PSTATE_NEW_SHIFT);\r\ntmp |= (i << C0_3_PSTATE_NEW_SHIFT);\r\n__raw_writel(tmp, dvfs_info->base + XMU_C0_3_PSTATE + cpu * 4);\r\n}\r\n__raw_writel(1 << XMU_DVFS_CTRL_EN_SHIFT,\r\ndvfs_info->base + XMU_DVFS_CTRL);\r\n}\r\nstatic int exynos_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy,\r\ndvfs_info->freq_table);\r\n}\r\nstatic unsigned int exynos_getspeed(unsigned int cpu)\r\n{\r\nreturn dvfs_info->cur_frequency;\r\n}\r\nstatic int exynos_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int index, tmp;\r\nint ret = 0, i;\r\nstruct cpufreq_frequency_table *freq_table = dvfs_info->freq_table;\r\nmutex_lock(&cpufreq_lock);\r\nret = cpufreq_frequency_table_target(policy, freq_table,\r\ntarget_freq, relation, &index);\r\nif (ret)\r\ngoto out;\r\nfreqs.old = dvfs_info->cur_frequency;\r\nfreqs.new = freq_table[index].frequency;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nfor_each_cpu(i, policy->cpus) {\r\ntmp = __raw_readl(dvfs_info->base + XMU_C0_3_PSTATE + i * 4);\r\ntmp &= ~(P_VALUE_MASK << C0_3_PSTATE_NEW_SHIFT);\r\ntmp |= (index << C0_3_PSTATE_NEW_SHIFT);\r\n__raw_writel(tmp, dvfs_info->base + XMU_C0_3_PSTATE + i * 4);\r\n}\r\nout:\r\nmutex_unlock(&cpufreq_lock);\r\nreturn ret;\r\n}\r\nstatic void exynos_cpufreq_work(struct work_struct *work)\r\n{\r\nunsigned int cur_pstate, index;\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(0);\r\nstruct cpufreq_frequency_table *freq_table = dvfs_info->freq_table;\r\nif (unlikely(dvfs_info->dvfs_enabled == false))\r\ngoto skip_work;\r\nmutex_lock(&cpufreq_lock);\r\nfreqs.old = dvfs_info->cur_frequency;\r\ncur_pstate = __raw_readl(dvfs_info->base + XMU_P_STATUS);\r\nif (cur_pstate >> C0_3_PSTATE_VALID_SHIFT & 0x1)\r\nindex = (cur_pstate >> C0_3_PSTATE_CURR_SHIFT) & P_VALUE_MASK;\r\nelse\r\nindex = (cur_pstate >> C0_3_PSTATE_NEW_SHIFT) & P_VALUE_MASK;\r\nif (likely(index < dvfs_info->freq_count)) {\r\nfreqs.new = freq_table[index].frequency;\r\ndvfs_info->cur_frequency = freqs.new;\r\n} else {\r\ndev_crit(dvfs_info->dev, "New frequency out of range\n");\r\nfreqs.new = dvfs_info->cur_frequency;\r\n}\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\ncpufreq_cpu_put(policy);\r\nmutex_unlock(&cpufreq_lock);\r\nskip_work:\r\nenable_irq(dvfs_info->irq);\r\n}\r\nstatic irqreturn_t exynos_cpufreq_irq(int irq, void *id)\r\n{\r\nunsigned int tmp;\r\ntmp = __raw_readl(dvfs_info->base + XMU_PMUIRQ);\r\nif (tmp >> PSTATE_CHANGED_SHIFT & 0x1) {\r\n__raw_writel(tmp, dvfs_info->base + XMU_PMUIRQ);\r\ndisable_irq_nosync(irq);\r\nschedule_work(&dvfs_info->irq_work);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos_sort_descend_freq_table(void)\r\n{\r\nstruct cpufreq_frequency_table *freq_tbl = dvfs_info->freq_table;\r\nint i = 0, index;\r\nunsigned int tmp_freq;\r\nfor (i = 0; i < dvfs_info->freq_count / 2; i++) {\r\nindex = dvfs_info->freq_count - i - 1;\r\ntmp_freq = freq_tbl[i].frequency;\r\nfreq_tbl[i].frequency = freq_tbl[index].frequency;\r\nfreq_tbl[index].frequency = tmp_freq;\r\n}\r\n}\r\nstatic int exynos_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint ret;\r\nret = cpufreq_frequency_table_cpuinfo(policy, dvfs_info->freq_table);\r\nif (ret) {\r\ndev_err(dvfs_info->dev, "Invalid frequency table: %d\n", ret);\r\nreturn ret;\r\n}\r\npolicy->cur = dvfs_info->cur_frequency;\r\npolicy->cpuinfo.transition_latency = dvfs_info->latency;\r\ncpumask_setall(policy->cpus);\r\ncpufreq_frequency_table_get_attr(dvfs_info->freq_table, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int exynos_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nint ret = -EINVAL;\r\nstruct device_node *np;\r\nstruct resource res;\r\nnp = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\ndvfs_info = devm_kzalloc(&pdev->dev, sizeof(*dvfs_info), GFP_KERNEL);\r\nif (!dvfs_info) {\r\nret = -ENOMEM;\r\ngoto err_put_node;\r\n}\r\ndvfs_info->dev = &pdev->dev;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret)\r\ngoto err_put_node;\r\ndvfs_info->base = devm_ioremap_resource(dvfs_info->dev, &res);\r\nif (IS_ERR(dvfs_info->base)) {\r\nret = PTR_ERR(dvfs_info->base);\r\ngoto err_put_node;\r\n}\r\ndvfs_info->irq = irq_of_parse_and_map(np, 0);\r\nif (!dvfs_info->irq) {\r\ndev_err(dvfs_info->dev, "No cpufreq irq found\n");\r\nret = -ENODEV;\r\ngoto err_put_node;\r\n}\r\nret = of_init_opp_table(dvfs_info->dev);\r\nif (ret) {\r\ndev_err(dvfs_info->dev, "failed to init OPP table: %d\n", ret);\r\ngoto err_put_node;\r\n}\r\nret = opp_init_cpufreq_table(dvfs_info->dev, &dvfs_info->freq_table);\r\nif (ret) {\r\ndev_err(dvfs_info->dev,\r\n"failed to init cpufreq table: %d\n", ret);\r\ngoto err_put_node;\r\n}\r\ndvfs_info->freq_count = opp_get_opp_count(dvfs_info->dev);\r\nexynos_sort_descend_freq_table();\r\nif (of_property_read_u32(np, "clock-latency", &dvfs_info->latency))\r\ndvfs_info->latency = DEF_TRANS_LATENCY;\r\ndvfs_info->cpu_clk = devm_clk_get(dvfs_info->dev, "armclk");\r\nif (IS_ERR(dvfs_info->cpu_clk)) {\r\ndev_err(dvfs_info->dev, "Failed to get cpu clock\n");\r\nret = PTR_ERR(dvfs_info->cpu_clk);\r\ngoto err_free_table;\r\n}\r\ndvfs_info->cur_frequency = clk_get_rate(dvfs_info->cpu_clk);\r\nif (!dvfs_info->cur_frequency) {\r\ndev_err(dvfs_info->dev, "Failed to get clock rate\n");\r\nret = -EINVAL;\r\ngoto err_free_table;\r\n}\r\ndvfs_info->cur_frequency /= 1000;\r\nINIT_WORK(&dvfs_info->irq_work, exynos_cpufreq_work);\r\nret = devm_request_irq(dvfs_info->dev, dvfs_info->irq,\r\nexynos_cpufreq_irq, IRQF_TRIGGER_NONE,\r\nCPUFREQ_NAME, dvfs_info);\r\nif (ret) {\r\ndev_err(dvfs_info->dev, "Failed to register IRQ\n");\r\ngoto err_free_table;\r\n}\r\nret = init_div_table();\r\nif (ret) {\r\ndev_err(dvfs_info->dev, "Failed to initialise div table\n");\r\ngoto err_free_table;\r\n}\r\nexynos_enable_dvfs();\r\nret = cpufreq_register_driver(&exynos_driver);\r\nif (ret) {\r\ndev_err(dvfs_info->dev,\r\n"%s: failed to register cpufreq driver\n", __func__);\r\ngoto err_free_table;\r\n}\r\nof_node_put(np);\r\ndvfs_info->dvfs_enabled = true;\r\nreturn 0;\r\nerr_free_table:\r\nopp_free_cpufreq_table(dvfs_info->dev, &dvfs_info->freq_table);\r\nerr_put_node:\r\nof_node_put(np);\r\ndev_err(dvfs_info->dev, "%s: failed initialization\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int exynos_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_driver(&exynos_driver);\r\nopp_free_cpufreq_table(dvfs_info->dev, &dvfs_info->freq_table);\r\nreturn 0;\r\n}
