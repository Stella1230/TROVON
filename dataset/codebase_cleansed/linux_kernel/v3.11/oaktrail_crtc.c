static const struct oaktrail_limit_t *oaktrail_limit(struct drm_crtc *crtc)\r\n{\r\nconst struct oaktrail_limit_t *limit = NULL;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (psb_intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)\r\n|| psb_intel_pipe_has_type(crtc, INTEL_OUTPUT_MIPI)) {\r\nswitch (dev_priv->core_freq) {\r\ncase 100:\r\nlimit = &oaktrail_limits[MRST_LIMIT_LVDS_100L];\r\nbreak;\r\ncase 166:\r\nlimit = &oaktrail_limits[MRST_LIMIT_LVDS_83];\r\nbreak;\r\ncase 200:\r\nlimit = &oaktrail_limits[MRST_LIMIT_LVDS_100];\r\nbreak;\r\n}\r\n} else {\r\nlimit = NULL;\r\ndev_err(dev->dev, "oaktrail_limit Wrong display type.\n");\r\n}\r\nreturn limit;\r\n}\r\nstatic void oaktrail_clock(int refclk, struct oaktrail_clock_t *clock)\r\n{\r\nclock->dot = (refclk * clock->m) / (14 * clock->p1);\r\n}\r\nstatic void mrstPrintPll(char *prefix, struct oaktrail_clock_t *clock)\r\n{\r\npr_debug("%s: dotclock = %d, m = %d, p1 = %d.\n",\r\nprefix, clock->dot, clock->m, clock->p1);\r\n}\r\nstatic bool\r\nmrstFindBestPLL(struct drm_crtc *crtc, int target, int refclk,\r\nstruct oaktrail_clock_t *best_clock)\r\n{\r\nstruct oaktrail_clock_t clock;\r\nconst struct oaktrail_limit_t *limit = oaktrail_limit(crtc);\r\nint err = target;\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nfor (clock.m = limit->m.min; clock.m <= limit->m.max; clock.m++) {\r\nfor (clock.p1 = limit->p1.min; clock.p1 <= limit->p1.max;\r\nclock.p1++) {\r\nint this_err;\r\noaktrail_clock(refclk, &clock);\r\nthis_err = abs(clock.dot - target);\r\nif (this_err < err) {\r\n*best_clock = clock;\r\nerr = this_err;\r\n}\r\n}\r\n}\r\ndev_dbg(crtc->dev->dev, "mrstFindBestPLL err = %d.\n", err);\r\nreturn err != target;\r\n}\r\nstatic void oaktrail_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 temp;\r\nif (pipe == 1) {\r\noaktrail_crtc_hdmi_dpms(crtc, mode);\r\nreturn;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) == 0) {\r\nREG_WRITE(map->dpll, temp);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) == 0)\r\nREG_WRITE(map->conf, temp | PIPEACONF_ENABLE);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE(map->cntr,\r\ntemp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\n}\r\npsb_intel_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_READ(map->base);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE(map->conf, temp & ~PIPEACONF_ENABLE);\r\nREG_READ(map->conf);\r\n}\r\npsb_intel_wait_for_vblank(dev);\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) != 0) {\r\nREG_WRITE(map->dpll, temp & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\n}\r\nudelay(150);\r\nbreak;\r\n}\r\nREG_WRITE(DSPARB, 0x3FFF);\r\nREG_WRITE(DSPFW1, 0x3F88080A);\r\nREG_WRITE(DSPFW2, 0x0b060808);\r\nREG_WRITE(DSPFW3, 0x0);\r\nREG_WRITE(DSPFW4, 0x08030404);\r\nREG_WRITE(DSPFW5, 0x04040404);\r\nREG_WRITE(DSPFW6, 0x78);\r\nREG_WRITE(0x70400, REG_READ(0x70400) | 0x4000);\r\ngma_power_end(dev);\r\n}\r\nstatic int oaktrail_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn (pfit_control >> 29) & 3;\r\n}\r\nstatic int oaktrail_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint refclk = 0;\r\nstruct oaktrail_clock_t clock;\r\nu32 dpll = 0, fp = 0, dspcntr, pipeconf;\r\nbool ok, is_sdvo = false;\r\nbool is_lvds = false;\r\nbool is_mipi = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct psb_intel_encoder *psb_intel_encoder = NULL;\r\nuint64_t scalingType = DRM_MODE_SCALE_FULLSCREEN;\r\nstruct drm_connector *connector;\r\nif (pipe == 1)\r\nreturn oaktrail_crtc_hdmi_mode_set(crtc, mode, adjusted_mode, x, y, old_fb);\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nmemcpy(&psb_intel_crtc->saved_mode,\r\nmode,\r\nsizeof(struct drm_display_mode));\r\nmemcpy(&psb_intel_crtc->saved_adjusted_mode,\r\nadjusted_mode,\r\nsizeof(struct drm_display_mode));\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nif (!connector->encoder || connector->encoder->crtc != crtc)\r\ncontinue;\r\npsb_intel_encoder = psb_intel_attached_encoder(connector);\r\nswitch (psb_intel_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\nis_lvds = true;\r\nbreak;\r\ncase INTEL_OUTPUT_SDVO:\r\nis_sdvo = true;\r\nbreak;\r\ncase INTEL_OUTPUT_MIPI:\r\nis_mipi = true;\r\nbreak;\r\n}\r\n}\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\nif (oaktrail_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\nREG_WRITE(map->src,\r\n((mode->crtc_hdisplay - 1) << 16) |\r\n(mode->crtc_vdisplay - 1));\r\nif (psb_intel_encoder)\r\ndrm_object_property_get_value(&connector->base,\r\ndev->mode_config.scaling_mode_property, &scalingType);\r\nif (scalingType == DRM_MODE_SCALE_NO_SCALE) {\r\nint offsetX = 0, offsetY = 0;\r\noffsetX = (adjusted_mode->crtc_hdisplay -\r\nmode->crtc_hdisplay) / 2;\r\noffsetY = (adjusted_mode->crtc_vdisplay -\r\nmode->crtc_vdisplay) / 2;\r\nREG_WRITE(map->htotal, (mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->vtotal, (mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->hblank,\r\n(adjusted_mode->crtc_hblank_start - offsetX - 1) |\r\n((adjusted_mode->crtc_hblank_end - offsetX - 1) << 16));\r\nREG_WRITE(map->hsync,\r\n(adjusted_mode->crtc_hsync_start - offsetX - 1) |\r\n((adjusted_mode->crtc_hsync_end - offsetX - 1) << 16));\r\nREG_WRITE(map->vblank,\r\n(adjusted_mode->crtc_vblank_start - offsetY - 1) |\r\n((adjusted_mode->crtc_vblank_end - offsetY - 1) << 16));\r\nREG_WRITE(map->vsync,\r\n(adjusted_mode->crtc_vsync_start - offsetY - 1) |\r\n((adjusted_mode->crtc_vsync_end - offsetY - 1) << 16));\r\n} else {\r\nREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16));\r\n}\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs =\r\ncrtc->helper_private;\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\n}\r\npipeconf = REG_READ(map->conf);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr |= DISPPLANE_GAMMA_ENABLE;\r\nif (pipe == 0)\r\ndspcntr |= DISPPLANE_SEL_PIPE_A;\r\nelse\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\nif (is_mipi)\r\ngoto oaktrail_crtc_mode_set_exit;\r\nrefclk = dev_priv->core_freq * 1000;\r\ndpll = 0;\r\nok = mrstFindBestPLL(crtc, adjusted_mode->clock, refclk, &clock);\r\nif (!ok) {\r\ndev_dbg(dev->dev, "mrstFindBestPLL fail in oaktrail_crtc_mode_set.\n");\r\n} else {\r\ndev_dbg(dev->dev, "oaktrail_crtc_mode_set pixel clock = %d,"\r\n"m = %x, p1 = %x.\n", clock.dot, clock.m,\r\nclock.p1);\r\n}\r\nfp = oaktrail_m_converts[(clock.m - MRST_M_MIN)] << 8;\r\ndpll |= DPLL_VGA_MODE_DIS;\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (is_lvds)\r\ndpll |= DPLLA_MODE_LVDS;\r\nelse\r\ndpll |= DPLLB_MODE_DAC_SERIAL;\r\nif (is_sdvo) {\r\nint sdvo_pixel_multiply =\r\nadjusted_mode->clock / mode->clock;\r\ndpll |= DPLL_DVO_HIGH_SPEED;\r\ndpll |=\r\n(sdvo_pixel_multiply -\r\n1) << SDVO_MULTIPLIER_SHIFT_HIRES;\r\n}\r\ndpll |= (1 << (clock.p1 - 2)) << 17;\r\ndpll |= DPLL_VCO_ENABLE;\r\nmrstPrintPll("chosen", &clock);\r\nif (dpll & DPLL_VCO_ENABLE) {\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->conf, pipeconf);\r\nREG_READ(map->conf);\r\npsb_intel_wait_for_vblank(dev);\r\nREG_WRITE(map->cntr, dspcntr);\r\npsb_intel_wait_for_vblank(dev);\r\noaktrail_crtc_mode_set_exit:\r\ngma_power_end(dev);\r\nreturn 0;\r\n}\r\nstatic bool oaktrail_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int oaktrail_pipe_set_base(struct drm_crtc *crtc,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_framebuffer *psbfb = to_psb_fb(crtc->fb);\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nunsigned long start, offset;\r\nu32 dspcntr;\r\nint ret = 0;\r\nif (!crtc->fb) {\r\ndev_dbg(dev->dev, "No FB bound\n");\r\nreturn 0;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nstart = psbfb->gtt->offset;\r\noffset = y * crtc->fb->pitches[0] + x * (crtc->fb->bits_per_pixel / 8);\r\nREG_WRITE(map->stride, crtc->fb->pitches[0]);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (crtc->fb->bits_per_pixel) {\r\ncase 8:\r\ndspcntr |= DISPPLANE_8BPP;\r\nbreak;\r\ncase 16:\r\nif (crtc->fb->depth == 15)\r\ndspcntr |= DISPPLANE_15_16BPP;\r\nelse\r\ndspcntr |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown color depth\n");\r\nret = -EINVAL;\r\ngoto pipe_set_base_exit;\r\n}\r\nREG_WRITE(map->cntr, dspcntr);\r\nREG_WRITE(map->base, offset);\r\nREG_READ(map->base);\r\nREG_WRITE(map->surf, start);\r\nREG_READ(map->surf);\r\npipe_set_base_exit:\r\ngma_power_end(dev);\r\nreturn ret;\r\n}\r\nstatic void oaktrail_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void oaktrail_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);\r\n}
