static inline unsigned int adfs_readval(unsigned char *p, int len)\r\n{\r\nunsigned int val = 0;\r\nswitch (len) {\r\ncase 4: val |= p[3] << 24;\r\ncase 3: val |= p[2] << 16;\r\ncase 2: val |= p[1] << 8;\r\ndefault: val |= p[0];\r\n}\r\nreturn val;\r\n}\r\nstatic inline void adfs_writeval(unsigned char *p, int len, unsigned int val)\r\n{\r\nswitch (len) {\r\ncase 4: p[3] = val >> 24;\r\ncase 3: p[2] = val >> 16;\r\ncase 2: p[1] = val >> 8;\r\ndefault: p[0] = val;\r\n}\r\n}\r\nstatic inline int adfs_readname(char *buf, char *ptr, int maxlen)\r\n{\r\nchar *old_buf = buf;\r\nwhile ((unsigned char)*ptr >= ' ' && maxlen--) {\r\nif (*ptr == '/')\r\n*buf++ = '.';\r\nelse\r\n*buf++ = *ptr;\r\nptr++;\r\n}\r\nreturn buf - old_buf;\r\n}\r\nstatic u8\r\nadfs_dir_checkbyte(const struct adfs_dir *dir)\r\n{\r\nstruct buffer_head * const *bh = dir->bh;\r\nconst int blocksize_bits = dir->sb->s_blocksize_bits;\r\nunion { __le32 *ptr32; u8 *ptr8; } ptr, end;\r\nu32 dircheck = 0;\r\nint last = 5 - 26;\r\nint i = 0;\r\ndo {\r\nlast += 26;\r\ndo {\r\ndircheck = le32_to_cpu(dir_u32(i)) ^ ror13(dircheck);\r\ni += sizeof(u32);\r\n} while (i < (last & ~3));\r\n} while (dir_u8(last) != 0);\r\nif (i != last) {\r\nptr.ptr8 = bufoff(bh, i);\r\nend.ptr8 = ptr.ptr8 + last - i;\r\ndo {\r\ndircheck = *ptr.ptr8++ ^ ror13(dircheck);\r\n} while (ptr.ptr8 < end.ptr8);\r\n}\r\nptr.ptr8 = bufoff(bh, 2008);\r\nend.ptr8 = ptr.ptr8 + 36;\r\ndo {\r\n__le32 v = *ptr.ptr32++;\r\ndircheck = le32_to_cpu(v) ^ ror13(dircheck);\r\n} while (ptr.ptr32 < end.ptr32);\r\nreturn (dircheck ^ (dircheck >> 8) ^ (dircheck >> 16) ^ (dircheck >> 24)) & 0xff;\r\n}\r\nstatic int\r\nadfs_dir_read(struct super_block *sb, unsigned long object_id,\r\nunsigned int size, struct adfs_dir *dir)\r\n{\r\nconst unsigned int blocksize_bits = sb->s_blocksize_bits;\r\nint blk = 0;\r\nif (size & 2047)\r\ngoto bad_dir;\r\nsize >>= blocksize_bits;\r\ndir->nr_buffers = 0;\r\ndir->sb = sb;\r\nfor (blk = 0; blk < size; blk++) {\r\nint phys;\r\nphys = __adfs_block_map(sb, object_id, blk);\r\nif (!phys) {\r\nadfs_error(sb, "dir object %lX has a hole at offset %d",\r\nobject_id, blk);\r\ngoto release_buffers;\r\n}\r\ndir->bh[blk] = sb_bread(sb, phys);\r\nif (!dir->bh[blk])\r\ngoto release_buffers;\r\n}\r\nmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\r\nmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\r\nif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\r\nmemcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\r\ngoto bad_dir;\r\nif (memcmp(&dir->dirhead.startname, "Nick", 4) &&\r\nmemcmp(&dir->dirhead.startname, "Hugo", 4))\r\ngoto bad_dir;\r\nif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\r\ngoto bad_dir;\r\ndir->nr_buffers = blk;\r\nreturn 0;\r\nbad_dir:\r\nadfs_error(sb, "corrupted directory fragment %lX",\r\nobject_id);\r\nrelease_buffers:\r\nfor (blk -= 1; blk >= 0; blk -= 1)\r\nbrelse(dir->bh[blk]);\r\ndir->sb = NULL;\r\nreturn -EIO;\r\n}\r\nstatic inline void\r\nadfs_dir2obj(struct adfs_dir *dir, struct object_info *obj,\r\nstruct adfs_direntry *de)\r\n{\r\nobj->name_len = adfs_readname(obj->name, de->dirobname, ADFS_F_NAME_LEN);\r\nobj->file_id = adfs_readval(de->dirinddiscadd, 3);\r\nobj->loadaddr = adfs_readval(de->dirload, 4);\r\nobj->execaddr = adfs_readval(de->direxec, 4);\r\nobj->size = adfs_readval(de->dirlen, 4);\r\nobj->attr = de->newdiratts;\r\nobj->filetype = -1;\r\nif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\r\n(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\r\nobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\r\nif (ADFS_SB(dir->sb)->s_ftsuffix)\r\nobj->name_len +=\r\nappend_filetype_suffix(\r\n&obj->name[obj->name_len],\r\nobj->filetype);\r\n}\r\n}\r\nstatic inline void\r\nadfs_obj2dir(struct adfs_direntry *de, struct object_info *obj)\r\n{\r\nadfs_writeval(de->dirinddiscadd, 3, obj->file_id);\r\nadfs_writeval(de->dirload, 4, obj->loadaddr);\r\nadfs_writeval(de->direxec, 4, obj->execaddr);\r\nadfs_writeval(de->dirlen, 4, obj->size);\r\nde->newdiratts = obj->attr;\r\n}\r\nstatic int\r\n__adfs_dir_get(struct adfs_dir *dir, int pos, struct object_info *obj)\r\n{\r\nstruct super_block *sb = dir->sb;\r\nstruct adfs_direntry de;\r\nint thissize, buffer, offset;\r\nbuffer = pos >> sb->s_blocksize_bits;\r\nif (buffer > dir->nr_buffers)\r\nreturn -EINVAL;\r\noffset = pos & (sb->s_blocksize - 1);\r\nthissize = sb->s_blocksize - offset;\r\nif (thissize > 26)\r\nthissize = 26;\r\nmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\r\nif (thissize != 26)\r\nmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\r\n26 - thissize);\r\nif (!de.dirobname[0])\r\nreturn -ENOENT;\r\nadfs_dir2obj(dir, obj, &de);\r\nreturn 0;\r\n}\r\nstatic int\r\n__adfs_dir_put(struct adfs_dir *dir, int pos, struct object_info *obj)\r\n{\r\nstruct super_block *sb = dir->sb;\r\nstruct adfs_direntry de;\r\nint thissize, buffer, offset;\r\nbuffer = pos >> sb->s_blocksize_bits;\r\nif (buffer > dir->nr_buffers)\r\nreturn -EINVAL;\r\noffset = pos & (sb->s_blocksize - 1);\r\nthissize = sb->s_blocksize - offset;\r\nif (thissize > 26)\r\nthissize = 26;\r\nmemcpy(&de, dir->bh[buffer]->b_data + offset, thissize);\r\nif (thissize != 26)\r\nmemcpy(((char *)&de) + thissize, dir->bh[buffer + 1]->b_data,\r\n26 - thissize);\r\nadfs_obj2dir(&de, obj);\r\nmemcpy(dir->bh[buffer]->b_data + offset, &de, thissize);\r\nif (thissize != 26)\r\nmemcpy(dir->bh[buffer + 1]->b_data, ((char *)&de) + thissize,\r\n26 - thissize);\r\nreturn 0;\r\n}\r\nstatic int\r\nadfs_dir_find_entry(struct adfs_dir *dir, unsigned long object_id)\r\n{\r\nint pos, ret;\r\nret = -ENOENT;\r\nfor (pos = 5; pos < ADFS_NUM_DIR_ENTRIES * 26 + 5; pos += 26) {\r\nstruct object_info obj;\r\nif (!__adfs_dir_get(dir, pos, &obj))\r\nbreak;\r\nif (obj.file_id == object_id) {\r\nret = pos;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_f_read(struct super_block *sb, unsigned int id, unsigned int sz, struct adfs_dir *dir)\r\n{\r\nint ret;\r\nif (sz != ADFS_NEWDIR_SIZE)\r\nreturn -EIO;\r\nret = adfs_dir_read(sb, id, sz, dir);\r\nif (ret)\r\nadfs_error(sb, "unable to read directory");\r\nelse\r\ndir->parent_id = adfs_readval(dir->dirtail.new.dirparent, 3);\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_f_setpos(struct adfs_dir *dir, unsigned int fpos)\r\n{\r\nif (fpos >= ADFS_NUM_DIR_ENTRIES)\r\nreturn -ENOENT;\r\ndir->pos = 5 + fpos * 26;\r\nreturn 0;\r\n}\r\nstatic int\r\nadfs_f_getnext(struct adfs_dir *dir, struct object_info *obj)\r\n{\r\nunsigned int ret;\r\nret = __adfs_dir_get(dir, dir->pos, obj);\r\nif (ret == 0)\r\ndir->pos += 26;\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_f_update(struct adfs_dir *dir, struct object_info *obj)\r\n{\r\nstruct super_block *sb = dir->sb;\r\nint ret, i;\r\nret = adfs_dir_find_entry(dir, obj->file_id);\r\nif (ret < 0) {\r\nadfs_error(dir->sb, "unable to locate entry to update");\r\ngoto out;\r\n}\r\n__adfs_dir_put(dir, ret, obj);\r\ndir->bh[0]->b_data[0] += 1;\r\ndir->bh[dir->nr_buffers - 1]->b_data[sb->s_blocksize - 6] += 1;\r\nret = adfs_dir_checkbyte(dir);\r\ndir->bh[dir->nr_buffers - 1]->b_data[sb->s_blocksize - 1] = ret;\r\n#if 1\r\n{\r\nconst unsigned int blocksize_bits = sb->s_blocksize_bits;\r\nmemcpy(&dir->dirhead, bufoff(dir->bh, 0), sizeof(dir->dirhead));\r\nmemcpy(&dir->dirtail, bufoff(dir->bh, 2007), sizeof(dir->dirtail));\r\nif (dir->dirhead.startmasseq != dir->dirtail.new.endmasseq ||\r\nmemcmp(&dir->dirhead.startname, &dir->dirtail.new.endname, 4))\r\ngoto bad_dir;\r\nif (memcmp(&dir->dirhead.startname, "Nick", 4) &&\r\nmemcmp(&dir->dirhead.startname, "Hugo", 4))\r\ngoto bad_dir;\r\nif (adfs_dir_checkbyte(dir) != dir->dirtail.new.dircheckbyte)\r\ngoto bad_dir;\r\n}\r\n#endif\r\nfor (i = dir->nr_buffers - 1; i >= 0; i--)\r\nmark_buffer_dirty(dir->bh[i]);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n#if 1\r\nbad_dir:\r\nadfs_error(dir->sb, "whoops! I broke a directory!");\r\nreturn -EIO;\r\n#endif\r\n}\r\nstatic int\r\nadfs_f_sync(struct adfs_dir *dir)\r\n{\r\nint err = 0;\r\nint i;\r\nfor (i = dir->nr_buffers - 1; i >= 0; i--) {\r\nstruct buffer_head *bh = dir->bh[i];\r\nsync_dirty_buffer(bh);\r\nif (buffer_req(bh) && !buffer_uptodate(bh))\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nadfs_f_free(struct adfs_dir *dir)\r\n{\r\nint i;\r\nfor (i = dir->nr_buffers - 1; i >= 0; i--) {\r\nbrelse(dir->bh[i]);\r\ndir->bh[i] = NULL;\r\n}\r\ndir->nr_buffers = 0;\r\ndir->sb = NULL;\r\n}
