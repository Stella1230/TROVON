static int menelaus_write_reg(int reg, u8 value)\r\n{\r\nint val = i2c_smbus_write_byte_data(the_menelaus->client, reg, value);\r\nif (val < 0) {\r\npr_err(DRIVER_NAME ": write error");\r\nreturn val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int menelaus_read_reg(int reg)\r\n{\r\nint val = i2c_smbus_read_byte_data(the_menelaus->client, reg);\r\nif (val < 0)\r\npr_err(DRIVER_NAME ": read error");\r\nreturn val;\r\n}\r\nstatic int menelaus_enable_irq(int irq)\r\n{\r\nif (irq > 7) {\r\nirq -= 8;\r\nthe_menelaus->mask2 &= ~(1 << irq);\r\nreturn menelaus_write_reg(MENELAUS_INT_MASK2,\r\nthe_menelaus->mask2);\r\n} else {\r\nthe_menelaus->mask1 &= ~(1 << irq);\r\nreturn menelaus_write_reg(MENELAUS_INT_MASK1,\r\nthe_menelaus->mask1);\r\n}\r\n}\r\nstatic int menelaus_disable_irq(int irq)\r\n{\r\nif (irq > 7) {\r\nirq -= 8;\r\nthe_menelaus->mask2 |= (1 << irq);\r\nreturn menelaus_write_reg(MENELAUS_INT_MASK2,\r\nthe_menelaus->mask2);\r\n} else {\r\nthe_menelaus->mask1 |= (1 << irq);\r\nreturn menelaus_write_reg(MENELAUS_INT_MASK1,\r\nthe_menelaus->mask1);\r\n}\r\n}\r\nstatic int menelaus_ack_irq(int irq)\r\n{\r\nif (irq > 7)\r\nreturn menelaus_write_reg(MENELAUS_INT_ACK2, 1 << (irq - 8));\r\nelse\r\nreturn menelaus_write_reg(MENELAUS_INT_ACK1, 1 << irq);\r\n}\r\nstatic int menelaus_add_irq_work(int irq,\r\nvoid (*handler)(struct menelaus_chip *))\r\n{\r\nint ret = 0;\r\nmutex_lock(&the_menelaus->lock);\r\nthe_menelaus->handlers[irq] = handler;\r\nret = menelaus_enable_irq(irq);\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nstatic int menelaus_remove_irq_work(int irq)\r\n{\r\nint ret = 0;\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_disable_irq(irq);\r\nthe_menelaus->handlers[irq] = NULL;\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nstatic void menelaus_mmc_cd_work(struct menelaus_chip *menelaus_hw)\r\n{\r\nint reg;\r\nunsigned char card_mask = 0;\r\nreg = menelaus_read_reg(MENELAUS_MCT_PIN_ST);\r\nif (reg < 0)\r\nreturn;\r\nif (!(reg & 0x1))\r\ncard_mask |= MCT_PIN_ST_S1_CD_ST;\r\nif (!(reg & 0x2))\r\ncard_mask |= MCT_PIN_ST_S2_CD_ST;\r\nif (menelaus_hw->mmc_callback)\r\nmenelaus_hw->mmc_callback(menelaus_hw->mmc_callback_data,\r\ncard_mask);\r\n}\r\nint menelaus_set_mmc_opendrain(int slot, int enable)\r\n{\r\nint ret, val;\r\nif (slot != 1 && slot != 2)\r\nreturn -EINVAL;\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_read_reg(MENELAUS_MCT_CTRL1);\r\nif (ret < 0) {\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nval = ret;\r\nif (slot == 1) {\r\nif (enable)\r\nval |= MCT_CTRL1_S1_CMD_OD;\r\nelse\r\nval &= ~MCT_CTRL1_S1_CMD_OD;\r\n} else {\r\nif (enable)\r\nval |= MCT_CTRL1_S2_CMD_OD;\r\nelse\r\nval &= ~MCT_CTRL1_S2_CMD_OD;\r\n}\r\nret = menelaus_write_reg(MENELAUS_MCT_CTRL1, val);\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nint menelaus_set_slot_sel(int enable)\r\n{\r\nint ret;\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_read_reg(MENELAUS_GPIO_CTRL);\r\nif (ret < 0)\r\ngoto out;\r\nret |= GPIO2_DIR_INPUT;\r\nif (enable)\r\nret |= GPIO_CTRL_SLOTSELEN;\r\nelse\r\nret &= ~GPIO_CTRL_SLOTSELEN;\r\nret = menelaus_write_reg(MENELAUS_GPIO_CTRL, ret);\r\nout:\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nint menelaus_set_mmc_slot(int slot, int enable, int power, int cd_en)\r\n{\r\nint ret, val;\r\nif (slot != 1 && slot != 2)\r\nreturn -EINVAL;\r\nif (power >= 3)\r\nreturn -EINVAL;\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_read_reg(MENELAUS_MCT_CTRL2);\r\nif (ret < 0)\r\ngoto out;\r\nval = ret;\r\nif (slot == 1) {\r\nif (cd_en)\r\nval |= MCT_CTRL2_S1CD_BUFEN | MCT_CTRL2_S1CD_DBEN;\r\nelse\r\nval &= ~(MCT_CTRL2_S1CD_BUFEN | MCT_CTRL2_S1CD_DBEN);\r\n} else {\r\nif (cd_en)\r\nval |= MCT_CTRL2_S2CD_BUFEN | MCT_CTRL2_S2CD_BEN;\r\nelse\r\nval &= ~(MCT_CTRL2_S2CD_BUFEN | MCT_CTRL2_S2CD_BEN);\r\n}\r\nret = menelaus_write_reg(MENELAUS_MCT_CTRL2, val);\r\nif (ret < 0)\r\ngoto out;\r\nret = menelaus_read_reg(MENELAUS_MCT_CTRL3);\r\nif (ret < 0)\r\ngoto out;\r\nval = ret;\r\nif (slot == 1) {\r\nif (enable)\r\nval |= MCT_CTRL3_SLOT1_EN;\r\nelse\r\nval &= ~MCT_CTRL3_SLOT1_EN;\r\n} else {\r\nint b;\r\nif (enable)\r\nval |= MCT_CTRL3_SLOT2_EN;\r\nelse\r\nval &= ~MCT_CTRL3_SLOT2_EN;\r\nb = menelaus_read_reg(MENELAUS_MCT_CTRL2);\r\nb &= ~(MCT_CTRL2_VS2_SEL_D0 | MCT_CTRL2_VS2_SEL_D1);\r\nb |= power;\r\nret = menelaus_write_reg(MENELAUS_MCT_CTRL2, b);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nval &= ~(MCT_CTRL3_S1_AUTO_EN | MCT_CTRL3_S2_AUTO_EN);\r\nret = menelaus_write_reg(MENELAUS_MCT_CTRL3, val);\r\nout:\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nint menelaus_register_mmc_callback(void (*callback)(void *data, u8 card_mask),\r\nvoid *data)\r\n{\r\nint ret = 0;\r\nthe_menelaus->mmc_callback_data = data;\r\nthe_menelaus->mmc_callback = callback;\r\nret = menelaus_add_irq_work(MENELAUS_MMC_S1CD_IRQ,\r\nmenelaus_mmc_cd_work);\r\nif (ret < 0)\r\nreturn ret;\r\nret = menelaus_add_irq_work(MENELAUS_MMC_S2CD_IRQ,\r\nmenelaus_mmc_cd_work);\r\nif (ret < 0)\r\nreturn ret;\r\nret = menelaus_add_irq_work(MENELAUS_MMC_S1D1_IRQ,\r\nmenelaus_mmc_cd_work);\r\nif (ret < 0)\r\nreturn ret;\r\nret = menelaus_add_irq_work(MENELAUS_MMC_S2D1_IRQ,\r\nmenelaus_mmc_cd_work);\r\nreturn ret;\r\n}\r\nvoid menelaus_unregister_mmc_callback(void)\r\n{\r\nmenelaus_remove_irq_work(MENELAUS_MMC_S1CD_IRQ);\r\nmenelaus_remove_irq_work(MENELAUS_MMC_S2CD_IRQ);\r\nmenelaus_remove_irq_work(MENELAUS_MMC_S1D1_IRQ);\r\nmenelaus_remove_irq_work(MENELAUS_MMC_S2D1_IRQ);\r\nthe_menelaus->mmc_callback = NULL;\r\nthe_menelaus->mmc_callback_data = 0;\r\n}\r\nstatic int menelaus_set_voltage(const struct menelaus_vtg *vtg, int mV,\r\nint vtg_val, int mode)\r\n{\r\nint val, ret;\r\nstruct i2c_client *c = the_menelaus->client;\r\nmutex_lock(&the_menelaus->lock);\r\nif (vtg == 0)\r\ngoto set_voltage;\r\nret = menelaus_read_reg(vtg->vtg_reg);\r\nif (ret < 0)\r\ngoto out;\r\nval = ret & ~(((1 << vtg->vtg_bits) - 1) << vtg->vtg_shift);\r\nval |= vtg_val << vtg->vtg_shift;\r\ndev_dbg(&c->dev, "Setting voltage '%s'"\r\n"to %d mV (reg 0x%02x, val 0x%02x)\n",\r\nvtg->name, mV, vtg->vtg_reg, val);\r\nret = menelaus_write_reg(vtg->vtg_reg, val);\r\nif (ret < 0)\r\ngoto out;\r\nset_voltage:\r\nret = menelaus_write_reg(vtg->mode_reg, mode);\r\nout:\r\nmutex_unlock(&the_menelaus->lock);\r\nif (ret == 0) {\r\nmsleep(1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int menelaus_get_vtg_value(int vtg, const struct menelaus_vtg_value *tbl,\r\nint n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++, tbl++)\r\nif (tbl->vtg == vtg)\r\nreturn tbl->val;\r\nreturn -EINVAL;\r\n}\r\nint menelaus_set_vcore_sw(unsigned int mV)\r\n{\r\nint val, ret;\r\nstruct i2c_client *c = the_menelaus->client;\r\nval = menelaus_get_vtg_value(mV, vcore_values,\r\nARRAY_SIZE(vcore_values));\r\nif (val < 0)\r\nreturn -EINVAL;\r\ndev_dbg(&c->dev, "Setting VCORE to %d mV (val 0x%02x)\n", mV, val);\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_write_reg(MENELAUS_VCORE_CTRL1, val);\r\nif (ret == 0)\r\nthe_menelaus->vcore_hw_mode = 0;\r\nmutex_unlock(&the_menelaus->lock);\r\nmsleep(1);\r\nreturn ret;\r\n}\r\nint menelaus_set_vcore_hw(unsigned int roof_mV, unsigned int floor_mV)\r\n{\r\nint fval, rval, val, ret;\r\nstruct i2c_client *c = the_menelaus->client;\r\nrval = menelaus_get_vtg_value(roof_mV, vcore_values,\r\nARRAY_SIZE(vcore_values));\r\nif (rval < 0)\r\nreturn -EINVAL;\r\nfval = menelaus_get_vtg_value(floor_mV, vcore_values,\r\nARRAY_SIZE(vcore_values));\r\nif (fval < 0)\r\nreturn -EINVAL;\r\ndev_dbg(&c->dev, "Setting VCORE FLOOR to %d mV and ROOF to %d mV\n",\r\nfloor_mV, roof_mV);\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_write_reg(MENELAUS_VCORE_CTRL3, fval);\r\nif (ret < 0)\r\ngoto out;\r\nret = menelaus_write_reg(MENELAUS_VCORE_CTRL4, rval);\r\nif (ret < 0)\r\ngoto out;\r\nif (!the_menelaus->vcore_hw_mode) {\r\nval = menelaus_read_reg(MENELAUS_VCORE_CTRL1);\r\nval |= (VCORE_CTRL1_HW_NSW | VCORE_CTRL1_BYP_COMP);\r\nret = menelaus_write_reg(MENELAUS_VCORE_CTRL1, val);\r\nthe_menelaus->vcore_hw_mode = 1;\r\n}\r\nmsleep(1);\r\nout:\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nint menelaus_set_vmem(unsigned int mV)\r\n{\r\nint val;\r\nif (mV == 0)\r\nreturn menelaus_set_voltage(&vmem_vtg, 0, 0, 0);\r\nval = menelaus_get_vtg_value(mV, vmem_values, ARRAY_SIZE(vmem_values));\r\nif (val < 0)\r\nreturn -EINVAL;\r\nreturn menelaus_set_voltage(&vmem_vtg, mV, val, 0x02);\r\n}\r\nint menelaus_set_vio(unsigned int mV)\r\n{\r\nint val;\r\nif (mV == 0)\r\nreturn menelaus_set_voltage(&vio_vtg, 0, 0, 0);\r\nval = menelaus_get_vtg_value(mV, vio_values, ARRAY_SIZE(vio_values));\r\nif (val < 0)\r\nreturn -EINVAL;\r\nreturn menelaus_set_voltage(&vio_vtg, mV, val, 0x02);\r\n}\r\nint menelaus_set_vdcdc(int dcdc, unsigned int mV)\r\n{\r\nconst struct menelaus_vtg *vtg;\r\nint val;\r\nif (dcdc != 2 && dcdc != 3)\r\nreturn -EINVAL;\r\nif (dcdc == 2)\r\nvtg = &vdcdc2_vtg;\r\nelse\r\nvtg = &vdcdc3_vtg;\r\nif (mV == 0)\r\nreturn menelaus_set_voltage(vtg, 0, 0, 0);\r\nval = menelaus_get_vtg_value(mV, vdcdc_values,\r\nARRAY_SIZE(vdcdc_values));\r\nif (val < 0)\r\nreturn -EINVAL;\r\nreturn menelaus_set_voltage(vtg, mV, val, 0x03);\r\n}\r\nint menelaus_set_vmmc(unsigned int mV)\r\n{\r\nint val;\r\nif (mV == 0)\r\nreturn menelaus_set_voltage(&vmmc_vtg, 0, 0, 0);\r\nval = menelaus_get_vtg_value(mV, vmmc_values, ARRAY_SIZE(vmmc_values));\r\nif (val < 0)\r\nreturn -EINVAL;\r\nreturn menelaus_set_voltage(&vmmc_vtg, mV, val, 0x02);\r\n}\r\nint menelaus_set_vaux(unsigned int mV)\r\n{\r\nint val;\r\nif (mV == 0)\r\nreturn menelaus_set_voltage(&vaux_vtg, 0, 0, 0);\r\nval = menelaus_get_vtg_value(mV, vaux_values, ARRAY_SIZE(vaux_values));\r\nif (val < 0)\r\nreturn -EINVAL;\r\nreturn menelaus_set_voltage(&vaux_vtg, mV, val, 0x02);\r\n}\r\nint menelaus_get_slot_pin_states(void)\r\n{\r\nreturn menelaus_read_reg(MENELAUS_MCT_PIN_ST);\r\n}\r\nint menelaus_set_regulator_sleep(int enable, u32 val)\r\n{\r\nint t, ret;\r\nstruct i2c_client *c = the_menelaus->client;\r\nmutex_lock(&the_menelaus->lock);\r\nret = menelaus_write_reg(MENELAUS_SLEEP_CTRL2, val);\r\nif (ret < 0)\r\ngoto out;\r\ndev_dbg(&c->dev, "regulator sleep configuration: %02x\n", val);\r\nret = menelaus_read_reg(MENELAUS_GPIO_CTRL);\r\nif (ret < 0)\r\ngoto out;\r\nt = (GPIO_CTRL_SLPCTLEN | GPIO3_DIR_INPUT);\r\nif (enable)\r\nret |= t;\r\nelse\r\nret &= ~t;\r\nret = menelaus_write_reg(MENELAUS_GPIO_CTRL, ret);\r\nout:\r\nmutex_unlock(&the_menelaus->lock);\r\nreturn ret;\r\n}\r\nstatic void menelaus_work(struct work_struct *_menelaus)\r\n{\r\nstruct menelaus_chip *menelaus =\r\ncontainer_of(_menelaus, struct menelaus_chip, work);\r\nvoid (*handler)(struct menelaus_chip *menelaus);\r\nwhile (1) {\r\nunsigned isr;\r\nisr = (menelaus_read_reg(MENELAUS_INT_STATUS2)\r\n& ~menelaus->mask2) << 8;\r\nisr |= menelaus_read_reg(MENELAUS_INT_STATUS1)\r\n& ~menelaus->mask1;\r\nif (!isr)\r\nbreak;\r\nwhile (isr) {\r\nint irq = fls(isr) - 1;\r\nisr &= ~(1 << irq);\r\nmutex_lock(&menelaus->lock);\r\nmenelaus_disable_irq(irq);\r\nmenelaus_ack_irq(irq);\r\nhandler = menelaus->handlers[irq];\r\nif (handler)\r\nhandler(menelaus);\r\nmenelaus_enable_irq(irq);\r\nmutex_unlock(&menelaus->lock);\r\n}\r\n}\r\nenable_irq(menelaus->client->irq);\r\n}\r\nstatic irqreturn_t menelaus_irq(int irq, void *_menelaus)\r\n{\r\nstruct menelaus_chip *menelaus = _menelaus;\r\ndisable_irq_nosync(irq);\r\n(void)schedule_work(&menelaus->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void menelaus_to_time(char *regs, struct rtc_time *t)\r\n{\r\nt->tm_sec = bcd2bin(regs[0]);\r\nt->tm_min = bcd2bin(regs[1]);\r\nif (the_menelaus->rtc_control & RTC_CTRL_MODE12) {\r\nt->tm_hour = bcd2bin(regs[2] & 0x1f) - 1;\r\nif (regs[2] & RTC_HR_PM)\r\nt->tm_hour += 12;\r\n} else\r\nt->tm_hour = bcd2bin(regs[2] & 0x3f);\r\nt->tm_mday = bcd2bin(regs[3]);\r\nt->tm_mon = bcd2bin(regs[4]) - 1;\r\nt->tm_year = bcd2bin(regs[5]) + 100;\r\n}\r\nstatic int time_to_menelaus(struct rtc_time *t, int regnum)\r\n{\r\nint hour, status;\r\nstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_sec));\r\nif (status < 0)\r\ngoto fail;\r\nstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_min));\r\nif (status < 0)\r\ngoto fail;\r\nif (the_menelaus->rtc_control & RTC_CTRL_MODE12) {\r\nhour = t->tm_hour + 1;\r\nif (hour > 12)\r\nhour = RTC_HR_PM | bin2bcd(hour - 12);\r\nelse\r\nhour = bin2bcd(hour);\r\n} else\r\nhour = bin2bcd(t->tm_hour);\r\nstatus = menelaus_write_reg(regnum++, hour);\r\nif (status < 0)\r\ngoto fail;\r\nstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_mday));\r\nif (status < 0)\r\ngoto fail;\r\nstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_mon + 1));\r\nif (status < 0)\r\ngoto fail;\r\nstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_year - 100));\r\nif (status < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ndev_err(&the_menelaus->client->dev, "rtc write reg %02x, err %d\n",\r\n--regnum, status);\r\nreturn status;\r\n}\r\nstatic int menelaus_read_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct i2c_msg msg[2];\r\nchar regs[7];\r\nint status;\r\nregs[0] = MENELAUS_RTC_SEC;\r\nmsg[0].addr = MENELAUS_I2C_ADDRESS;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 1;\r\nmsg[0].buf = regs;\r\nmsg[1].addr = MENELAUS_I2C_ADDRESS;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = sizeof(regs);\r\nmsg[1].buf = regs;\r\nstatus = i2c_transfer(the_menelaus->client->adapter, msg, 2);\r\nif (status != 2) {\r\ndev_err(dev, "%s error %d\n", "read", status);\r\nreturn -EIO;\r\n}\r\nmenelaus_to_time(regs, t);\r\nt->tm_wday = bcd2bin(regs[6]);\r\nreturn 0;\r\n}\r\nstatic int menelaus_set_time(struct device *dev, struct rtc_time *t)\r\n{\r\nint status;\r\nstatus = time_to_menelaus(t, MENELAUS_RTC_SEC);\r\nif (status < 0)\r\nreturn status;\r\nstatus = menelaus_write_reg(MENELAUS_RTC_WKDAY, bin2bcd(t->tm_wday));\r\nif (status < 0) {\r\ndev_err(&the_menelaus->client->dev, "rtc write reg %02x "\r\n"err %d\n", MENELAUS_RTC_WKDAY, status);\r\nreturn status;\r\n}\r\nstatus = menelaus_write_reg(MENELAUS_RTC_UPDATE, RTC_UPDATE_EVERY);\r\nif (status < 0)\r\ndev_err(&the_menelaus->client->dev, "rtc commit time, err %d\n",\r\nstatus);\r\nreturn 0;\r\n}\r\nstatic int menelaus_read_alarm(struct device *dev, struct rtc_wkalrm *w)\r\n{\r\nstruct i2c_msg msg[2];\r\nchar regs[6];\r\nint status;\r\nregs[0] = MENELAUS_RTC_AL_SEC;\r\nmsg[0].addr = MENELAUS_I2C_ADDRESS;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 1;\r\nmsg[0].buf = regs;\r\nmsg[1].addr = MENELAUS_I2C_ADDRESS;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = sizeof(regs);\r\nmsg[1].buf = regs;\r\nstatus = i2c_transfer(the_menelaus->client->adapter, msg, 2);\r\nif (status != 2) {\r\ndev_err(dev, "%s error %d\n", "alarm read", status);\r\nreturn -EIO;\r\n}\r\nmenelaus_to_time(regs, &w->time);\r\nw->enabled = !!(the_menelaus->rtc_control & RTC_CTRL_AL_EN);\r\nw->pending = 0;\r\nreturn 0;\r\n}\r\nstatic int menelaus_set_alarm(struct device *dev, struct rtc_wkalrm *w)\r\n{\r\nint status;\r\nif (the_menelaus->client->irq <= 0 && w->enabled)\r\nreturn -ENODEV;\r\nif (the_menelaus->rtc_control & RTC_CTRL_AL_EN) {\r\nthe_menelaus->rtc_control &= ~RTC_CTRL_AL_EN;\r\nstatus = menelaus_write_reg(MENELAUS_RTC_CTRL,\r\nthe_menelaus->rtc_control);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nstatus = time_to_menelaus(&w->time, MENELAUS_RTC_AL_SEC);\r\nif (status < 0)\r\nreturn status;\r\nif (w->enabled) {\r\nthe_menelaus->rtc_control |= RTC_CTRL_AL_EN;\r\nstatus = menelaus_write_reg(MENELAUS_RTC_CTRL,\r\nthe_menelaus->rtc_control);\r\n}\r\nreturn status;\r\n}\r\nstatic void menelaus_rtc_update_work(struct menelaus_chip *m)\r\n{\r\nlocal_irq_disable();\r\nrtc_update_irq(m->rtc, 1, RTC_IRQF | RTC_UF);\r\nlocal_irq_enable();\r\n}\r\nstatic int menelaus_ioctl(struct device *dev, unsigned cmd, unsigned long arg)\r\n{\r\nint status;\r\nif (the_menelaus->client->irq <= 0)\r\nreturn -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase RTC_AIE_ON:\r\nif (the_menelaus->rtc_control & RTC_CTRL_AL_EN)\r\nreturn 0;\r\nthe_menelaus->rtc_control |= RTC_CTRL_AL_EN;\r\nbreak;\r\ncase RTC_AIE_OFF:\r\nif (!(the_menelaus->rtc_control & RTC_CTRL_AL_EN))\r\nreturn 0;\r\nthe_menelaus->rtc_control &= ~RTC_CTRL_AL_EN;\r\nbreak;\r\ncase RTC_UIE_ON:\r\nif (the_menelaus->uie)\r\nreturn 0;\r\nstatus = menelaus_remove_irq_work(MENELAUS_RTCTMR_IRQ);\r\nstatus = menelaus_add_irq_work(MENELAUS_RTCTMR_IRQ,\r\nmenelaus_rtc_update_work);\r\nif (status == 0)\r\nthe_menelaus->uie = 1;\r\nreturn status;\r\ncase RTC_UIE_OFF:\r\nif (!the_menelaus->uie)\r\nreturn 0;\r\nstatus = menelaus_remove_irq_work(MENELAUS_RTCTMR_IRQ);\r\nif (status == 0)\r\nthe_menelaus->uie = 0;\r\nreturn status;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn menelaus_write_reg(MENELAUS_RTC_CTRL, the_menelaus->rtc_control);\r\n}\r\nstatic void menelaus_rtc_alarm_work(struct menelaus_chip *m)\r\n{\r\nlocal_irq_disable();\r\nrtc_update_irq(m->rtc, 1, RTC_IRQF | RTC_AF);\r\nlocal_irq_enable();\r\nthe_menelaus->rtc_control &= ~RTC_CTRL_AL_EN;\r\nmenelaus_write_reg(MENELAUS_RTC_CTRL, the_menelaus->rtc_control);\r\n}\r\nstatic inline void menelaus_rtc_init(struct menelaus_chip *m)\r\n{\r\nint alarm = (m->client->irq > 0);\r\nif (!(menelaus_read_reg(MENELAUS_OSC_CTRL) & 0x80)) {\r\ndev_dbg(&m->client->dev, "no 32k oscillator\n");\r\nreturn;\r\n}\r\nif (alarm) {\r\nif (menelaus_add_irq_work(MENELAUS_RTCALM_IRQ,\r\nmenelaus_rtc_alarm_work) < 0) {\r\ndev_err(&m->client->dev, "can't handle RTC alarm\n");\r\nreturn;\r\n}\r\ndevice_init_wakeup(&m->client->dev, 1);\r\n}\r\nm->rtc_control = menelaus_read_reg(MENELAUS_RTC_CTRL);\r\nif (!(m->rtc_control & RTC_CTRL_RTC_EN)\r\n|| (m->rtc_control & RTC_CTRL_AL_EN)\r\n|| (m->rtc_control & RTC_CTRL_EVERY_MASK)) {\r\nif (!(m->rtc_control & RTC_CTRL_RTC_EN)) {\r\ndev_warn(&m->client->dev, "rtc clock needs setting\n");\r\nm->rtc_control |= RTC_CTRL_RTC_EN;\r\n}\r\nm->rtc_control &= ~RTC_CTRL_EVERY_MASK;\r\nm->rtc_control &= ~RTC_CTRL_AL_EN;\r\nmenelaus_write_reg(MENELAUS_RTC_CTRL, m->rtc_control);\r\n}\r\nm->rtc = rtc_device_register(DRIVER_NAME,\r\n&m->client->dev,\r\n&menelaus_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(m->rtc)) {\r\nif (alarm) {\r\nmenelaus_remove_irq_work(MENELAUS_RTCALM_IRQ);\r\ndevice_init_wakeup(&m->client->dev, 0);\r\n}\r\ndev_err(&m->client->dev, "can't register RTC: %d\n",\r\n(int) PTR_ERR(m->rtc));\r\nthe_menelaus->rtc = NULL;\r\n}\r\n}\r\nstatic inline void menelaus_rtc_init(struct menelaus_chip *m)\r\n{\r\n}\r\nstatic int menelaus_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct menelaus_chip *menelaus;\r\nint rev = 0, val;\r\nint err = 0;\r\nstruct menelaus_platform_data *menelaus_pdata =\r\nclient->dev.platform_data;\r\nif (the_menelaus) {\r\ndev_dbg(&client->dev, "only one %s for now\n",\r\nDRIVER_NAME);\r\nreturn -ENODEV;\r\n}\r\nmenelaus = kzalloc(sizeof *menelaus, GFP_KERNEL);\r\nif (!menelaus)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, menelaus);\r\nthe_menelaus = menelaus;\r\nmenelaus->client = client;\r\nrev = menelaus_read_reg(MENELAUS_REV);\r\nif (rev < 0) {\r\npr_err(DRIVER_NAME ": device not found");\r\nerr = -ENODEV;\r\ngoto fail1;\r\n}\r\nmenelaus_write_reg(MENELAUS_INT_ACK1, 0xff);\r\nmenelaus_write_reg(MENELAUS_INT_ACK2, 0xff);\r\nmenelaus_write_reg(MENELAUS_INT_MASK1, 0xff);\r\nmenelaus_write_reg(MENELAUS_INT_MASK2, 0xff);\r\nmenelaus->mask1 = 0xff;\r\nmenelaus->mask2 = 0xff;\r\nmenelaus_write_reg(MENELAUS_MCT_CTRL1, 0x73);\r\nif (client->irq > 0) {\r\nerr = request_irq(client->irq, menelaus_irq, 0,\r\nDRIVER_NAME, menelaus);\r\nif (err) {\r\ndev_dbg(&client->dev, "can't get IRQ %d, err %d\n",\r\nclient->irq, err);\r\ngoto fail1;\r\n}\r\n}\r\nmutex_init(&menelaus->lock);\r\nINIT_WORK(&menelaus->work, menelaus_work);\r\npr_info("Menelaus rev %d.%d\n", rev >> 4, rev & 0x0f);\r\nval = menelaus_read_reg(MENELAUS_VCORE_CTRL1);\r\nif (val < 0)\r\ngoto fail2;\r\nif (val & (1 << 7))\r\nmenelaus->vcore_hw_mode = 1;\r\nelse\r\nmenelaus->vcore_hw_mode = 0;\r\nif (menelaus_pdata != NULL && menelaus_pdata->late_init != NULL) {\r\nerr = menelaus_pdata->late_init(&client->dev);\r\nif (err < 0)\r\ngoto fail2;\r\n}\r\nmenelaus_rtc_init(menelaus);\r\nreturn 0;\r\nfail2:\r\nfree_irq(client->irq, menelaus);\r\nflush_work(&menelaus->work);\r\nfail1:\r\nkfree(menelaus);\r\nreturn err;\r\n}\r\nstatic int __exit menelaus_remove(struct i2c_client *client)\r\n{\r\nstruct menelaus_chip *menelaus = i2c_get_clientdata(client);\r\nfree_irq(client->irq, menelaus);\r\nflush_work(&menelaus->work);\r\nkfree(menelaus);\r\nthe_menelaus = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init menelaus_init(void)\r\n{\r\nint res;\r\nres = i2c_add_driver(&menelaus_i2c_driver);\r\nif (res < 0) {\r\npr_err(DRIVER_NAME ": driver registration failed\n");\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit menelaus_exit(void)\r\n{\r\ni2c_del_driver(&menelaus_i2c_driver);\r\n}
