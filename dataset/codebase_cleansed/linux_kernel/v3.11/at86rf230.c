static int\r\n__at86rf230_write(struct at86rf230_local *lp, u8 addr, u8 data)\r\n{\r\nu8 *buf = lp->buf;\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nbuf[0] = (addr & CMD_REG_MASK) | CMD_REG | CMD_WRITE;\r\nbuf[1] = data;\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\ndev_vdbg(&lp->spi->dev, "buf[1] = %02x\n", buf[1]);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nstatus = spi_sync(lp->spi, &msg);\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\ndev_vdbg(&lp->spi->dev, "buf[1] = %02x\n", buf[1]);\r\nreturn status;\r\n}\r\nstatic int\r\n__at86rf230_read_subreg(struct at86rf230_local *lp,\r\nu8 addr, u8 mask, int shift, u8 *data)\r\n{\r\nu8 *buf = lp->buf;\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n.rx_buf = buf,\r\n};\r\nbuf[0] = (addr & CMD_REG_MASK) | CMD_REG;\r\nbuf[1] = 0xff;\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nstatus = spi_sync(lp->spi, &msg);\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\ndev_vdbg(&lp->spi->dev, "buf[1] = %02x\n", buf[1]);\r\nif (status == 0)\r\n*data = buf[1];\r\nreturn status;\r\n}\r\nstatic int\r\nat86rf230_read_subreg(struct at86rf230_local *lp,\r\nu8 addr, u8 mask, int shift, u8 *data)\r\n{\r\nint status;\r\nmutex_lock(&lp->bmux);\r\nstatus = __at86rf230_read_subreg(lp, addr, mask, shift, data);\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int\r\nat86rf230_write_subreg(struct at86rf230_local *lp,\r\nu8 addr, u8 mask, int shift, u8 data)\r\n{\r\nint status;\r\nu8 val;\r\nmutex_lock(&lp->bmux);\r\nstatus = __at86rf230_read_subreg(lp, addr, 0xff, 0, &val);\r\nif (status)\r\ngoto out;\r\nval &= ~mask;\r\nval |= (data << shift) & mask;\r\nstatus = __at86rf230_write(lp, addr, val);\r\nout:\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int\r\nat86rf230_write_fbuf(struct at86rf230_local *lp, u8 *data, u8 len)\r\n{\r\nu8 *buf = lp->buf;\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = len,\r\n.tx_buf = data,\r\n};\r\nmutex_lock(&lp->bmux);\r\nbuf[0] = CMD_WRITE | CMD_FB;\r\nbuf[1] = len + 2;\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\ndev_vdbg(&lp->spi->dev, "buf[1] = %02x\n", buf[1]);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nstatus = spi_sync(lp->spi, &msg);\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\nif (msg.status)\r\nstatus = msg.status;\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\ndev_vdbg(&lp->spi->dev, "buf[1] = %02x\n", buf[1]);\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int\r\nat86rf230_read_fbuf(struct at86rf230_local *lp, u8 *data, u8 *len, u8 *lqi)\r\n{\r\nu8 *buf = lp->buf;\r\nint status;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer_head = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n.rx_buf = buf,\r\n};\r\nstruct spi_transfer xfer_head1 = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n.rx_buf = buf,\r\n};\r\nstruct spi_transfer xfer_buf = {\r\n.len = 0,\r\n.rx_buf = data,\r\n};\r\nmutex_lock(&lp->bmux);\r\nbuf[0] = CMD_FB;\r\nbuf[1] = 0x00;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head, &msg);\r\nstatus = spi_sync(lp->spi, &msg);\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\nxfer_buf.len = *(buf + 1) + 1;\r\n*len = buf[1];\r\nbuf[0] = CMD_FB;\r\nbuf[1] = 0x00;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer_head1, &msg);\r\nspi_message_add_tail(&xfer_buf, &msg);\r\nstatus = spi_sync(lp->spi, &msg);\r\nif (msg.status)\r\nstatus = msg.status;\r\ndev_vdbg(&lp->spi->dev, "status = %d\n", status);\r\ndev_vdbg(&lp->spi->dev, "buf[0] = %02x\n", buf[0]);\r\ndev_vdbg(&lp->spi->dev, "buf[1] = %02x\n", buf[1]);\r\nif (status) {\r\nif (lqi && (*len > lp->buf[1]))\r\n*lqi = data[lp->buf[1]];\r\n}\r\nmutex_unlock(&lp->bmux);\r\nreturn status;\r\n}\r\nstatic int\r\nat86rf230_ed(struct ieee802154_dev *dev, u8 *level)\r\n{\r\nmight_sleep();\r\nBUG_ON(!level);\r\n*level = 0xbe;\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_state(struct ieee802154_dev *dev, int state)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nint rc;\r\nu8 val;\r\nu8 desired_status;\r\nmight_sleep();\r\nif (state == STATE_FORCE_TX_ON)\r\ndesired_status = STATE_TX_ON;\r\nelse if (state == STATE_FORCE_TRX_OFF)\r\ndesired_status = STATE_TRX_OFF;\r\nelse\r\ndesired_status = state;\r\ndo {\r\nrc = at86rf230_read_subreg(lp, SR_TRX_STATUS, &val);\r\nif (rc)\r\ngoto err;\r\n} while (val == STATE_TRANSITION_IN_PROGRESS);\r\nif (val == desired_status)\r\nreturn 0;\r\nrc = at86rf230_write_subreg(lp, SR_TRX_CMD, state);\r\nif (rc)\r\ngoto err;\r\ndo {\r\nrc = at86rf230_read_subreg(lp, SR_TRX_STATUS, &val);\r\nif (rc)\r\ngoto err;\r\n} while (val == STATE_TRANSITION_IN_PROGRESS);\r\nif (val == desired_status)\r\nreturn 0;\r\npr_err("unexpected state change: %d, asked for %d\n", val, state);\r\nreturn -EBUSY;\r\nerr:\r\npr_err("error: %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int\r\nat86rf230_start(struct ieee802154_dev *dev)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nu8 rc;\r\nrc = at86rf230_write_subreg(lp, SR_RX_SAFE_MODE, 1);\r\nif (rc)\r\nreturn rc;\r\nreturn at86rf230_state(dev, STATE_RX_ON);\r\n}\r\nstatic void\r\nat86rf230_stop(struct ieee802154_dev *dev)\r\n{\r\nat86rf230_state(dev, STATE_FORCE_TRX_OFF);\r\n}\r\nstatic int\r\nat86rf230_channel(struct ieee802154_dev *dev, int page, int channel)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nint rc;\r\nmight_sleep();\r\nif (page != 0 || channel < 11 || channel > 26) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nrc = at86rf230_write_subreg(lp, SR_CHANNEL, channel);\r\nmsleep(1);\r\ndev->phy->current_channel = channel;\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_xmit(struct ieee802154_dev *dev, struct sk_buff *skb)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nint rc;\r\nunsigned long flags;\r\nspin_lock(&lp->lock);\r\nif (lp->irq_busy) {\r\nspin_unlock(&lp->lock);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock(&lp->lock);\r\nmight_sleep();\r\nrc = at86rf230_state(dev, STATE_FORCE_TX_ON);\r\nif (rc)\r\ngoto err;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->is_tx = 1;\r\nINIT_COMPLETION(lp->tx_complete);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nrc = at86rf230_write_fbuf(lp, skb->data, skb->len);\r\nif (rc)\r\ngoto err_rx;\r\nrc = at86rf230_write_subreg(lp, SR_TRX_CMD, STATE_BUSY_TX);\r\nif (rc)\r\ngoto err_rx;\r\nrc = wait_for_completion_interruptible(&lp->tx_complete);\r\nif (rc < 0)\r\ngoto err_rx;\r\nrc = at86rf230_start(dev);\r\nreturn rc;\r\nerr_rx:\r\nat86rf230_start(dev);\r\nerr:\r\npr_err("error: %d\n", rc);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->is_tx = 0;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int at86rf230_rx(struct at86rf230_local *lp)\r\n{\r\nu8 len = 128, lqi = 0;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (at86rf230_read_fbuf(lp, skb_put(skb, len), &len, &lqi))\r\ngoto err;\r\nif (len < 2)\r\ngoto err;\r\nskb_trim(skb, len - 2);\r\nieee802154_rx_irqsafe(lp->dev, skb, lqi);\r\ndev_dbg(&lp->spi->dev, "READ_FBUF: %d %x\n", len, lqi);\r\nreturn 0;\r\nerr:\r\npr_debug("received frame is too small\n");\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nat86rf230_set_hw_addr_filt(struct ieee802154_dev *dev,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nif (changed & IEEE802515_AFILT_SADDR_CHANGED) {\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for saddr\n");\r\n__at86rf230_write(lp, RG_SHORT_ADDR_0, filt->short_addr);\r\n__at86rf230_write(lp, RG_SHORT_ADDR_1, filt->short_addr >> 8);\r\n}\r\nif (changed & IEEE802515_AFILT_PANID_CHANGED) {\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for pan id\n");\r\n__at86rf230_write(lp, RG_PAN_ID_0, filt->pan_id);\r\n__at86rf230_write(lp, RG_PAN_ID_1, filt->pan_id >> 8);\r\n}\r\nif (changed & IEEE802515_AFILT_IEEEADDR_CHANGED) {\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for IEEE addr\n");\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_0, filt->ieee_addr[7]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_1, filt->ieee_addr[6]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_2, filt->ieee_addr[5]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_3, filt->ieee_addr[4]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_4, filt->ieee_addr[3]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_5, filt->ieee_addr[2]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_6, filt->ieee_addr[1]);\r\nat86rf230_write_subreg(lp, SR_IEEE_ADDR_7, filt->ieee_addr[0]);\r\n}\r\nif (changed & IEEE802515_AFILT_PANC_CHANGED) {\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for panc change\n");\r\nif (filt->pan_coord)\r\nat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 1);\r\nelse\r\nat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void at86rf230_irqwork(struct work_struct *work)\r\n{\r\nstruct at86rf230_local *lp =\r\ncontainer_of(work, struct at86rf230_local, irqwork);\r\nu8 status = 0, val;\r\nint rc;\r\nunsigned long flags;\r\nrc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &val);\r\nstatus |= val;\r\nstatus &= ~IRQ_PLL_LOCK;\r\nstatus &= ~IRQ_RX_START;\r\nstatus &= ~IRQ_AMI;\r\nstatus &= ~IRQ_TRX_UR;\r\nif (status & IRQ_TRX_END) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nstatus &= ~IRQ_TRX_END;\r\nif (lp->is_tx) {\r\nlp->is_tx = 0;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ncomplete(&lp->tx_complete);\r\n} else {\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nat86rf230_rx(lp);\r\n}\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->irq_busy = 0;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void at86rf230_irqwork_level(struct work_struct *work)\r\n{\r\nstruct at86rf230_local *lp =\r\ncontainer_of(work, struct at86rf230_local, irqwork);\r\nat86rf230_irqwork(work);\r\nenable_irq(lp->spi->irq);\r\n}\r\nstatic irqreturn_t at86rf230_isr(int irq, void *data)\r\n{\r\nstruct at86rf230_local *lp = data;\r\nspin_lock(&lp->lock);\r\nlp->irq_busy = 1;\r\nspin_unlock(&lp->lock);\r\nschedule_work(&lp->irqwork);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t at86rf230_isr_level(int irq, void *data)\r\n{\r\ndisable_irq_nosync(irq);\r\nreturn at86rf230_isr(irq, data);\r\n}\r\nstatic int at86rf230_irq_polarity(struct at86rf230_local *lp, int pol)\r\n{\r\nreturn at86rf230_write_subreg(lp, SR_IRQ_POLARITY, pol);\r\n}\r\nstatic int at86rf230_hw_init(struct at86rf230_local *lp)\r\n{\r\nstruct at86rf230_platform_data *pdata = lp->spi->dev.platform_data;\r\nint rc, irq_pol;\r\nu8 status;\r\nrc = at86rf230_read_subreg(lp, SR_TRX_STATUS, &status);\r\nif (rc)\r\nreturn rc;\r\ndev_info(&lp->spi->dev, "Status: %02x\n", status);\r\nif (status == STATE_P_ON) {\r\nrc = at86rf230_write_subreg(lp, SR_TRX_CMD, STATE_TRX_OFF);\r\nif (rc)\r\nreturn rc;\r\nmsleep(1);\r\nrc = at86rf230_read_subreg(lp, SR_TRX_STATUS, &status);\r\nif (rc)\r\nreturn rc;\r\ndev_info(&lp->spi->dev, "Status: %02x\n", status);\r\n}\r\nif (pdata->irq_type & (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW))\r\nirq_pol = IRQ_ACTIVE_LOW;\r\nelse\r\nirq_pol = IRQ_ACTIVE_HIGH;\r\nrc = at86rf230_irq_polarity(lp, irq_pol);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_IRQ_MASK, IRQ_TRX_END);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CLKM_SHA_SEL, 0x00);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CLKM_CTRL, 0x00);\r\nif (rc)\r\nreturn rc;\r\nmsleep(100);\r\nrc = at86rf230_write_subreg(lp, SR_TRX_CMD, STATE_TX_ON);\r\nif (rc)\r\nreturn rc;\r\nmsleep(1);\r\nrc = at86rf230_read_subreg(lp, SR_TRX_STATUS, &status);\r\nif (rc)\r\nreturn rc;\r\ndev_info(&lp->spi->dev, "Status: %02x\n", status);\r\nrc = at86rf230_read_subreg(lp, SR_DVDD_OK, &status);\r\nif (rc)\r\nreturn rc;\r\nif (!status) {\r\ndev_err(&lp->spi->dev, "DVDD error\n");\r\nreturn -EINVAL;\r\n}\r\nrc = at86rf230_read_subreg(lp, SR_AVDD_OK, &status);\r\nif (rc)\r\nreturn rc;\r\nif (!status) {\r\ndev_err(&lp->spi->dev, "AVDD error\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void at86rf230_fill_data(struct spi_device *spi)\r\n{\r\nstruct at86rf230_local *lp = spi_get_drvdata(spi);\r\nstruct at86rf230_platform_data *pdata = spi->dev.platform_data;\r\nlp->rstn = pdata->rstn;\r\nlp->slp_tr = pdata->slp_tr;\r\nlp->dig2 = pdata->dig2;\r\n}\r\nstatic int at86rf230_probe(struct spi_device *spi)\r\n{\r\nstruct at86rf230_platform_data *pdata;\r\nstruct ieee802154_dev *dev;\r\nstruct at86rf230_local *lp;\r\nu8 man_id_0, man_id_1, status;\r\nirq_handler_t irq_handler;\r\nwork_func_t irq_worker;\r\nint rc, supported = 0;\r\nconst char *chip;\r\nif (!spi->irq) {\r\ndev_err(&spi->dev, "no IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\npdata = spi->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&spi->dev, "no platform_data\n");\r\nreturn -EINVAL;\r\n}\r\ndev = ieee802154_alloc_device(sizeof(*lp), &at86rf230_ops);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = dev->priv;\r\nlp->dev = dev;\r\nlp->spi = spi;\r\ndev->parent = &spi->dev;\r\ndev->extra_tx_headroom = 0;\r\ndev->phy->channels_supported[0] = 0x7FFF800;\r\ndev->flags = IEEE802154_HW_OMIT_CKSUM;\r\nif (pdata->irq_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\r\nirq_worker = at86rf230_irqwork;\r\nirq_handler = at86rf230_isr;\r\n} else {\r\nirq_worker = at86rf230_irqwork_level;\r\nirq_handler = at86rf230_isr_level;\r\n}\r\nmutex_init(&lp->bmux);\r\nINIT_WORK(&lp->irqwork, irq_worker);\r\nspin_lock_init(&lp->lock);\r\ninit_completion(&lp->tx_complete);\r\nspi_set_drvdata(spi, lp);\r\nat86rf230_fill_data(spi);\r\nrc = gpio_request(lp->rstn, "rstn");\r\nif (rc)\r\ngoto err_rstn;\r\nif (gpio_is_valid(lp->slp_tr)) {\r\nrc = gpio_request(lp->slp_tr, "slp_tr");\r\nif (rc)\r\ngoto err_slp_tr;\r\n}\r\nrc = gpio_direction_output(lp->rstn, 1);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nif (gpio_is_valid(lp->slp_tr)) {\r\nrc = gpio_direction_output(lp->slp_tr, 0);\r\nif (rc)\r\ngoto err_gpio_dir;\r\n}\r\nmsleep(1);\r\ngpio_set_value(lp->rstn, 0);\r\nmsleep(1);\r\ngpio_set_value(lp->rstn, 1);\r\nmsleep(1);\r\nrc = at86rf230_read_subreg(lp, SR_MAN_ID_0, &man_id_0);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nrc = at86rf230_read_subreg(lp, SR_MAN_ID_1, &man_id_1);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nif (man_id_1 != 0x00 || man_id_0 != 0x1f) {\r\ndev_err(&spi->dev, "Non-Atmel dev found (MAN_ID %02x %02x)\n",\r\nman_id_1, man_id_0);\r\nrc = -EINVAL;\r\ngoto err_gpio_dir;\r\n}\r\nrc = at86rf230_read_subreg(lp, SR_PART_NUM, &lp->part);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nrc = at86rf230_read_subreg(lp, SR_VERSION_NUM, &lp->vers);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nswitch (lp->part) {\r\ncase 2:\r\nchip = "at86rf230";\r\nbreak;\r\ncase 3:\r\nchip = "at86rf231";\r\nsupported = 1;\r\nbreak;\r\ndefault:\r\nchip = "UNKNOWN";\r\nbreak;\r\n}\r\ndev_info(&spi->dev, "Detected %s chip version %d\n", chip, lp->vers);\r\nif (!supported) {\r\nrc = -ENOTSUPP;\r\ngoto err_gpio_dir;\r\n}\r\nrc = at86rf230_hw_init(lp);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nrc = request_irq(spi->irq, irq_handler,\r\nIRQF_SHARED | pdata->irq_type,\r\ndev_name(&spi->dev), lp);\r\nif (rc)\r\ngoto err_gpio_dir;\r\nrc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &status);\r\nif (rc)\r\ngoto err_irq;\r\nrc = ieee802154_register_device(lp->dev);\r\nif (rc)\r\ngoto err_irq;\r\nreturn rc;\r\nerr_irq:\r\nfree_irq(spi->irq, lp);\r\nflush_work(&lp->irqwork);\r\nerr_gpio_dir:\r\nif (gpio_is_valid(lp->slp_tr))\r\ngpio_free(lp->slp_tr);\r\nerr_slp_tr:\r\ngpio_free(lp->rstn);\r\nerr_rstn:\r\nspi_set_drvdata(spi, NULL);\r\nmutex_destroy(&lp->bmux);\r\nieee802154_free_device(lp->dev);\r\nreturn rc;\r\n}\r\nstatic int at86rf230_remove(struct spi_device *spi)\r\n{\r\nstruct at86rf230_local *lp = spi_get_drvdata(spi);\r\nieee802154_unregister_device(lp->dev);\r\nfree_irq(spi->irq, lp);\r\nflush_work(&lp->irqwork);\r\nif (gpio_is_valid(lp->slp_tr))\r\ngpio_free(lp->slp_tr);\r\ngpio_free(lp->rstn);\r\nspi_set_drvdata(spi, NULL);\r\nmutex_destroy(&lp->bmux);\r\nieee802154_free_device(lp->dev);\r\ndev_dbg(&spi->dev, "unregistered at86rf230\n");\r\nreturn 0;\r\n}
