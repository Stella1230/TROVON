static void cciss_procinit(ctlr_info_t *h)\r\n{\r\n}\r\nstatic void set_performant_mode(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nif (likely(h->transMethod & CFGTBL_Trans_Performant))\r\nc->busaddr |= 1 | (h->blockFetchTable[c->Header.SGList] << 1);\r\n}\r\nstatic inline void addQ(struct list_head *list, CommandList_struct *c)\r\n{\r\nlist_add_tail(&c->list, list);\r\n}\r\nstatic inline void removeQ(CommandList_struct *c)\r\n{\r\nif (WARN_ON(list_empty(&c->list))) {\r\nc->cmd_type = CMD_MSG_STALE;\r\nreturn;\r\n}\r\nlist_del_init(&c->list);\r\n}\r\nstatic void enqueue_cmd_and_start_io(ctlr_info_t *h,\r\nCommandList_struct *c)\r\n{\r\nunsigned long flags;\r\nset_performant_mode(h, c);\r\nspin_lock_irqsave(&h->lock, flags);\r\naddQ(&h->reqQ, c);\r\nh->Qdepth++;\r\nif (h->Qdepth > h->maxQsinceinit)\r\nh->maxQsinceinit = h->Qdepth;\r\nstart_io(h);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\n}\r\nstatic void cciss_free_sg_chain_blocks(SGDescriptor_struct **cmd_sg_list,\r\nint nr_cmds)\r\n{\r\nint i;\r\nif (!cmd_sg_list)\r\nreturn;\r\nfor (i = 0; i < nr_cmds; i++) {\r\nkfree(cmd_sg_list[i]);\r\ncmd_sg_list[i] = NULL;\r\n}\r\nkfree(cmd_sg_list);\r\n}\r\nstatic SGDescriptor_struct **cciss_allocate_sg_chain_blocks(\r\nctlr_info_t *h, int chainsize, int nr_cmds)\r\n{\r\nint j;\r\nSGDescriptor_struct **cmd_sg_list;\r\nif (chainsize <= 0)\r\nreturn NULL;\r\ncmd_sg_list = kmalloc(sizeof(*cmd_sg_list) * nr_cmds, GFP_KERNEL);\r\nif (!cmd_sg_list)\r\nreturn NULL;\r\nfor (j = 0; j < nr_cmds; j++) {\r\ncmd_sg_list[j] = kmalloc((chainsize *\r\nsizeof(*cmd_sg_list[j])), GFP_KERNEL);\r\nif (!cmd_sg_list[j]) {\r\ndev_err(&h->pdev->dev, "Cannot get memory "\r\n"for s/g chains.\n");\r\ngoto clean;\r\n}\r\n}\r\nreturn cmd_sg_list;\r\nclean:\r\ncciss_free_sg_chain_blocks(cmd_sg_list, nr_cmds);\r\nreturn NULL;\r\n}\r\nstatic void cciss_unmap_sg_chain_block(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nSGDescriptor_struct *chain_sg;\r\nu64bit temp64;\r\nif (c->Header.SGTotal <= h->max_cmd_sgentries)\r\nreturn;\r\nchain_sg = &c->SG[h->max_cmd_sgentries - 1];\r\ntemp64.val32.lower = chain_sg->Addr.lower;\r\ntemp64.val32.upper = chain_sg->Addr.upper;\r\npci_unmap_single(h->pdev, temp64.val, chain_sg->Len, PCI_DMA_TODEVICE);\r\n}\r\nstatic void cciss_map_sg_chain_block(ctlr_info_t *h, CommandList_struct *c,\r\nSGDescriptor_struct *chain_block, int len)\r\n{\r\nSGDescriptor_struct *chain_sg;\r\nu64bit temp64;\r\nchain_sg = &c->SG[h->max_cmd_sgentries - 1];\r\nchain_sg->Ext = CCISS_SG_CHAIN;\r\nchain_sg->Len = len;\r\ntemp64.val = pci_map_single(h->pdev, chain_block, len,\r\nPCI_DMA_TODEVICE);\r\nchain_sg->Addr.lower = temp64.val32.lower;\r\nchain_sg->Addr.upper = temp64.val32.upper;\r\n}\r\nstatic void cciss_seq_show_header(struct seq_file *seq)\r\n{\r\nctlr_info_t *h = seq->private;\r\nseq_printf(seq, "%s: HP %s Controller\n"\r\n"Board ID: 0x%08lx\n"\r\n"Firmware Version: %c%c%c%c\n"\r\n"IRQ: %d\n"\r\n"Logical drives: %d\n"\r\n"Current Q depth: %d\n"\r\n"Current # commands on controller: %d\n"\r\n"Max Q depth since init: %d\n"\r\n"Max # commands on controller since init: %d\n"\r\n"Max SG entries since init: %d\n",\r\nh->devname,\r\nh->product_name,\r\n(unsigned long)h->board_id,\r\nh->firm_ver[0], h->firm_ver[1], h->firm_ver[2],\r\nh->firm_ver[3], (unsigned int)h->intr[h->intr_mode],\r\nh->num_luns,\r\nh->Qdepth, h->commands_outstanding,\r\nh->maxQsinceinit, h->max_outstanding, h->maxSG);\r\n#ifdef CONFIG_CISS_SCSI_TAPE\r\ncciss_seq_tape_report(seq, h);\r\n#endif\r\n}\r\nstatic void *cciss_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nctlr_info_t *h = seq->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring) {\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nh->busy_configuring = 1;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (*pos == 0)\r\ncciss_seq_show_header(seq);\r\nreturn pos;\r\n}\r\nstatic int cciss_seq_show(struct seq_file *seq, void *v)\r\n{\r\nsector_t vol_sz, vol_sz_frac;\r\nctlr_info_t *h = seq->private;\r\nunsigned ctlr = h->ctlr;\r\nloff_t *pos = v;\r\ndrive_info_struct *drv = h->drv[*pos];\r\nif (*pos > h->highest_lun)\r\nreturn 0;\r\nif (drv == NULL)\r\nreturn 0;\r\nif (drv->heads == 0)\r\nreturn 0;\r\nvol_sz = drv->nr_blocks;\r\nvol_sz_frac = sector_div(vol_sz, ENG_GIG_FACTOR);\r\nvol_sz_frac *= 100;\r\nsector_div(vol_sz_frac, ENG_GIG_FACTOR);\r\nif (drv->raid_level < 0 || drv->raid_level > RAID_UNKNOWN)\r\ndrv->raid_level = RAID_UNKNOWN;\r\nseq_printf(seq, "cciss/c%dd%d:"\r\n"\t%4u.%02uGB\tRAID %s\n",\r\nctlr, (int) *pos, (int)vol_sz, (int)vol_sz_frac,\r\nraid_label[drv->raid_level]);\r\nreturn 0;\r\n}\r\nstatic void *cciss_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nctlr_info_t *h = seq->private;\r\nif (*pos > h->highest_lun)\r\nreturn NULL;\r\n*pos += 1;\r\nreturn pos;\r\n}\r\nstatic void cciss_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nctlr_info_t *h = seq->private;\r\nif (v == ERR_PTR(-EBUSY))\r\nreturn;\r\nh->busy_configuring = 0;\r\n}\r\nstatic int cciss_seq_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &cciss_seq_ops);\r\nstruct seq_file *seq = file->private_data;\r\nif (!ret)\r\nseq->private = PDE_DATA(inode);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\ncciss_proc_write(struct file *file, const char __user *buf,\r\nsize_t length, loff_t *ppos)\r\n{\r\nint err;\r\nchar *buffer;\r\n#ifndef CONFIG_CISS_SCSI_TAPE\r\nreturn -EINVAL;\r\n#endif\r\nif (!buf || length > PAGE_SIZE - 1)\r\nreturn -EINVAL;\r\nbuffer = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\nif (copy_from_user(buffer, buf, length))\r\ngoto out;\r\nbuffer[length] = '\0';\r\n#ifdef CONFIG_CISS_SCSI_TAPE\r\nif (strncmp(ENGAGE_SCSI, buffer, sizeof ENGAGE_SCSI - 1) == 0) {\r\nstruct seq_file *seq = file->private_data;\r\nctlr_info_t *h = seq->private;\r\nerr = cciss_engage_scsi(h);\r\nif (err == 0)\r\nerr = length;\r\n} else\r\n#endif\r\nerr = -EINVAL;\r\nout:\r\nfree_page((unsigned long)buffer);\r\nreturn err;\r\n}\r\nstatic void cciss_procinit(ctlr_info_t *h)\r\n{\r\nstruct proc_dir_entry *pde;\r\nif (proc_cciss == NULL)\r\nproc_cciss = proc_mkdir("driver/cciss", NULL);\r\nif (!proc_cciss)\r\nreturn;\r\npde = proc_create_data(h->devname, S_IWUSR | S_IRUSR | S_IRGRP |\r\nS_IROTH, proc_cciss,\r\n&cciss_proc_fops, h);\r\n}\r\nstatic int ctlr_is_hard_resettable(u32 board_id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(unresettable_controller); i++)\r\nif (unresettable_controller[i] == board_id)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ctlr_is_soft_resettable(u32 board_id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(soft_unresettable_controller); i++)\r\nif (soft_unresettable_controller[i] == board_id)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ctlr_is_resettable(u32 board_id)\r\n{\r\nreturn ctlr_is_hard_resettable(board_id) ||\r\nctlr_is_soft_resettable(board_id);\r\n}\r\nstatic ssize_t host_show_resettable(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ctlr_info *h = to_hba(dev);\r\nreturn snprintf(buf, 20, "%d\n", ctlr_is_resettable(h->board_id));\r\n}\r\nstatic ssize_t host_store_rescan(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ctlr_info *h = to_hba(dev);\r\nadd_to_scan_list(h);\r\nwake_up_process(cciss_scan_thread);\r\nwait_for_completion_interruptible(&h->scan_wait);\r\nreturn count;\r\n}\r\nstatic ssize_t host_show_transport_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ctlr_info *h = to_hba(dev);\r\nreturn snprintf(buf, 20, "%s\n",\r\nh->transMethod & CFGTBL_Trans_Performant ?\r\n"performant" : "simple");\r\n}\r\nstatic ssize_t dev_show_unique_id(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\n__u8 sn[16];\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring)\r\nret = -EBUSY;\r\nelse\r\nmemcpy(sn, drv->serial_no, sizeof(sn));\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(buf, 16 * 2 + 2,\r\n"%02X%02X%02X%02X%02X%02X%02X%02X"\r\n"%02X%02X%02X%02X%02X%02X%02X%02X\n",\r\nsn[0], sn[1], sn[2], sn[3],\r\nsn[4], sn[5], sn[6], sn[7],\r\nsn[8], sn[9], sn[10], sn[11],\r\nsn[12], sn[13], sn[14], sn[15]);\r\n}\r\nstatic ssize_t dev_show_vendor(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\nchar vendor[VENDOR_LEN + 1];\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring)\r\nret = -EBUSY;\r\nelse\r\nmemcpy(vendor, drv->vendor, VENDOR_LEN + 1);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(buf, sizeof(vendor) + 1, "%s\n", drv->vendor);\r\n}\r\nstatic ssize_t dev_show_model(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\nchar model[MODEL_LEN + 1];\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring)\r\nret = -EBUSY;\r\nelse\r\nmemcpy(model, drv->model, MODEL_LEN + 1);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(buf, sizeof(model) + 1, "%s\n", drv->model);\r\n}\r\nstatic ssize_t dev_show_rev(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\nchar rev[REV_LEN + 1];\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring)\r\nret = -EBUSY;\r\nelse\r\nmemcpy(rev, drv->rev, REV_LEN + 1);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(buf, sizeof(rev) + 1, "%s\n", drv->rev);\r\n}\r\nstatic ssize_t cciss_show_lunid(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\nunsigned long flags;\r\nunsigned char lunid[8];\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring) {\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nif (!drv->heads) {\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn -ENOTTY;\r\n}\r\nmemcpy(lunid, drv->LunID, sizeof(lunid));\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn snprintf(buf, 20, "0x%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\nlunid[0], lunid[1], lunid[2], lunid[3],\r\nlunid[4], lunid[5], lunid[6], lunid[7]);\r\n}\r\nstatic ssize_t cciss_show_raid_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\nint raid;\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring) {\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nraid = drv->raid_level;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (raid < 0 || raid > RAID_UNKNOWN)\r\nraid = RAID_UNKNOWN;\r\nreturn snprintf(buf, strlen(raid_label[raid]) + 7, "RAID %s\n",\r\nraid_label[raid]);\r\n}\r\nstatic ssize_t cciss_show_usage_count(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nstruct ctlr_info *h = to_hba(drv->dev.parent);\r\nunsigned long flags;\r\nint count;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring) {\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ncount = drv->usage_count;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn snprintf(buf, 20, "%d\n", count);\r\n}\r\nstatic void cciss_hba_release(struct device *dev)\r\n{\r\n}\r\nstatic int cciss_create_hba_sysfs_entry(struct ctlr_info *h)\r\n{\r\ndevice_initialize(&h->dev);\r\nh->dev.type = &cciss_host_type;\r\nh->dev.bus = &cciss_bus_type;\r\ndev_set_name(&h->dev, "%s", h->devname);\r\nh->dev.parent = &h->pdev->dev;\r\nreturn device_add(&h->dev);\r\n}\r\nstatic void cciss_destroy_hba_sysfs_entry(struct ctlr_info *h)\r\n{\r\ndevice_del(&h->dev);\r\nput_device(&h->dev);\r\n}\r\nstatic void cciss_device_release(struct device *dev)\r\n{\r\ndrive_info_struct *drv = to_drv(dev);\r\nkfree(drv);\r\n}\r\nstatic long cciss_create_ld_sysfs_entry(struct ctlr_info *h,\r\nint drv_index)\r\n{\r\nstruct device *dev;\r\nif (h->drv[drv_index]->device_initialized)\r\nreturn 0;\r\ndev = &h->drv[drv_index]->dev;\r\ndevice_initialize(dev);\r\ndev->type = &cciss_dev_type;\r\ndev->bus = &cciss_bus_type;\r\ndev_set_name(dev, "c%dd%d", h->ctlr, drv_index);\r\ndev->parent = &h->dev;\r\nh->drv[drv_index]->device_initialized = 1;\r\nreturn device_add(dev);\r\n}\r\nstatic void cciss_destroy_ld_sysfs_entry(struct ctlr_info *h, int drv_index,\r\nint ctlr_exiting)\r\n{\r\nstruct device *dev = &h->drv[drv_index]->dev;\r\nif (drv_index == 0 && !ctlr_exiting)\r\nreturn;\r\ndevice_del(dev);\r\nput_device(dev);\r\nh->drv[drv_index] = NULL;\r\n}\r\nstatic CommandList_struct *cmd_alloc(ctlr_info_t *h)\r\n{\r\nCommandList_struct *c;\r\nint i;\r\nu64bit temp64;\r\ndma_addr_t cmd_dma_handle, err_dma_handle;\r\ndo {\r\ni = find_first_zero_bit(h->cmd_pool_bits, h->nr_cmds);\r\nif (i == h->nr_cmds)\r\nreturn NULL;\r\n} while (test_and_set_bit(i, h->cmd_pool_bits) != 0);\r\nc = h->cmd_pool + i;\r\nmemset(c, 0, sizeof(CommandList_struct));\r\ncmd_dma_handle = h->cmd_pool_dhandle + i * sizeof(CommandList_struct);\r\nc->err_info = h->errinfo_pool + i;\r\nmemset(c->err_info, 0, sizeof(ErrorInfo_struct));\r\nerr_dma_handle = h->errinfo_pool_dhandle\r\n+ i * sizeof(ErrorInfo_struct);\r\nh->nr_allocs++;\r\nc->cmdindex = i;\r\nINIT_LIST_HEAD(&c->list);\r\nc->busaddr = (__u32) cmd_dma_handle;\r\ntemp64.val = (__u64) err_dma_handle;\r\nc->ErrDesc.Addr.lower = temp64.val32.lower;\r\nc->ErrDesc.Addr.upper = temp64.val32.upper;\r\nc->ErrDesc.Len = sizeof(ErrorInfo_struct);\r\nc->ctlr = h->ctlr;\r\nreturn c;\r\n}\r\nstatic CommandList_struct *cmd_special_alloc(ctlr_info_t *h)\r\n{\r\nCommandList_struct *c;\r\nu64bit temp64;\r\ndma_addr_t cmd_dma_handle, err_dma_handle;\r\nc = (CommandList_struct *) pci_alloc_consistent(h->pdev,\r\nsizeof(CommandList_struct), &cmd_dma_handle);\r\nif (c == NULL)\r\nreturn NULL;\r\nmemset(c, 0, sizeof(CommandList_struct));\r\nc->cmdindex = -1;\r\nc->err_info = (ErrorInfo_struct *)\r\npci_alloc_consistent(h->pdev, sizeof(ErrorInfo_struct),\r\n&err_dma_handle);\r\nif (c->err_info == NULL) {\r\npci_free_consistent(h->pdev,\r\nsizeof(CommandList_struct), c, cmd_dma_handle);\r\nreturn NULL;\r\n}\r\nmemset(c->err_info, 0, sizeof(ErrorInfo_struct));\r\nINIT_LIST_HEAD(&c->list);\r\nc->busaddr = (__u32) cmd_dma_handle;\r\ntemp64.val = (__u64) err_dma_handle;\r\nc->ErrDesc.Addr.lower = temp64.val32.lower;\r\nc->ErrDesc.Addr.upper = temp64.val32.upper;\r\nc->ErrDesc.Len = sizeof(ErrorInfo_struct);\r\nc->ctlr = h->ctlr;\r\nreturn c;\r\n}\r\nstatic void cmd_free(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nint i;\r\ni = c - h->cmd_pool;\r\nclear_bit(i, h->cmd_pool_bits);\r\nh->nr_frees++;\r\n}\r\nstatic void cmd_special_free(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nu64bit temp64;\r\ntemp64.val32.lower = c->ErrDesc.Addr.lower;\r\ntemp64.val32.upper = c->ErrDesc.Addr.upper;\r\npci_free_consistent(h->pdev, sizeof(ErrorInfo_struct),\r\nc->err_info, (dma_addr_t) temp64.val);\r\npci_free_consistent(h->pdev, sizeof(CommandList_struct), c,\r\n(dma_addr_t) cciss_tag_discard_error_bits(h, (u32) c->busaddr));\r\n}\r\nstatic inline ctlr_info_t *get_host(struct gendisk *disk)\r\n{\r\nreturn disk->queue->queuedata;\r\n}\r\nstatic inline drive_info_struct *get_drv(struct gendisk *disk)\r\n{\r\nreturn disk->private_data;\r\n}\r\nstatic int cciss_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nctlr_info_t *h = get_host(bdev->bd_disk);\r\ndrive_info_struct *drv = get_drv(bdev->bd_disk);\r\ndev_dbg(&h->pdev->dev, "cciss_open %s\n", bdev->bd_disk->disk_name);\r\nif (drv->busy_configuring)\r\nreturn -EBUSY;\r\nif (drv->heads == 0) {\r\nif (MINOR(bdev->bd_dev) != 0) {\r\nif (MINOR(bdev->bd_dev) & 0x0f) {\r\nreturn -ENXIO;\r\n} else if (memcmp(drv->LunID, CTLR_LUNID,\r\nsizeof(drv->LunID))) {\r\nreturn -ENXIO;\r\n}\r\n}\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n}\r\ndrv->usage_count++;\r\nh->usage_count++;\r\nreturn 0;\r\n}\r\nstatic int cciss_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&cciss_mutex);\r\nret = cciss_open(bdev, mode);\r\nmutex_unlock(&cciss_mutex);\r\nreturn ret;\r\n}\r\nstatic void cciss_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nctlr_info_t *h;\r\ndrive_info_struct *drv;\r\nmutex_lock(&cciss_mutex);\r\nh = get_host(disk);\r\ndrv = get_drv(disk);\r\ndev_dbg(&h->pdev->dev, "cciss_release %s\n", disk->disk_name);\r\ndrv->usage_count--;\r\nh->usage_count--;\r\nmutex_unlock(&cciss_mutex);\r\n}\r\nstatic int cciss_compat_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase CCISS_GETPCIINFO:\r\ncase CCISS_GETINTINFO:\r\ncase CCISS_SETINTINFO:\r\ncase CCISS_GETNODENAME:\r\ncase CCISS_SETNODENAME:\r\ncase CCISS_GETHEARTBEAT:\r\ncase CCISS_GETBUSTYPES:\r\ncase CCISS_GETFIRMVER:\r\ncase CCISS_GETDRIVVER:\r\ncase CCISS_REVALIDVOLS:\r\ncase CCISS_DEREGDISK:\r\ncase CCISS_REGNEWDISK:\r\ncase CCISS_REGNEWD:\r\ncase CCISS_RESCANDISK:\r\ncase CCISS_GETLUNINFO:\r\nreturn cciss_ioctl(bdev, mode, cmd, arg);\r\ncase CCISS_PASSTHRU32:\r\nreturn cciss_ioctl32_passthru(bdev, mode, cmd, arg);\r\ncase CCISS_BIG_PASSTHRU32:\r\nreturn cciss_ioctl32_big_passthru(bdev, mode, cmd, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int cciss_ioctl32_passthru(struct block_device *bdev, fmode_t mode,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nIOCTL32_Command_struct __user *arg32 =\r\n(IOCTL32_Command_struct __user *) arg;\r\nIOCTL_Command_struct arg64;\r\nIOCTL_Command_struct __user *p = compat_alloc_user_space(sizeof(arg64));\r\nint err;\r\nu32 cp;\r\nerr = 0;\r\nerr |=\r\ncopy_from_user(&arg64.LUN_info, &arg32->LUN_info,\r\nsizeof(arg64.LUN_info));\r\nerr |=\r\ncopy_from_user(&arg64.Request, &arg32->Request,\r\nsizeof(arg64.Request));\r\nerr |=\r\ncopy_from_user(&arg64.error_info, &arg32->error_info,\r\nsizeof(arg64.error_info));\r\nerr |= get_user(arg64.buf_size, &arg32->buf_size);\r\nerr |= get_user(cp, &arg32->buf);\r\narg64.buf = compat_ptr(cp);\r\nerr |= copy_to_user(p, &arg64, sizeof(arg64));\r\nif (err)\r\nreturn -EFAULT;\r\nerr = cciss_ioctl(bdev, mode, CCISS_PASSTHRU, (unsigned long)p);\r\nif (err)\r\nreturn err;\r\nerr |=\r\ncopy_in_user(&arg32->error_info, &p->error_info,\r\nsizeof(arg32->error_info));\r\nif (err)\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int cciss_ioctl32_big_passthru(struct block_device *bdev, fmode_t mode,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nBIG_IOCTL32_Command_struct __user *arg32 =\r\n(BIG_IOCTL32_Command_struct __user *) arg;\r\nBIG_IOCTL_Command_struct arg64;\r\nBIG_IOCTL_Command_struct __user *p =\r\ncompat_alloc_user_space(sizeof(arg64));\r\nint err;\r\nu32 cp;\r\nmemset(&arg64, 0, sizeof(arg64));\r\nerr = 0;\r\nerr |=\r\ncopy_from_user(&arg64.LUN_info, &arg32->LUN_info,\r\nsizeof(arg64.LUN_info));\r\nerr |=\r\ncopy_from_user(&arg64.Request, &arg32->Request,\r\nsizeof(arg64.Request));\r\nerr |=\r\ncopy_from_user(&arg64.error_info, &arg32->error_info,\r\nsizeof(arg64.error_info));\r\nerr |= get_user(arg64.buf_size, &arg32->buf_size);\r\nerr |= get_user(arg64.malloc_size, &arg32->malloc_size);\r\nerr |= get_user(cp, &arg32->buf);\r\narg64.buf = compat_ptr(cp);\r\nerr |= copy_to_user(p, &arg64, sizeof(arg64));\r\nif (err)\r\nreturn -EFAULT;\r\nerr = cciss_ioctl(bdev, mode, CCISS_BIG_PASSTHRU, (unsigned long)p);\r\nif (err)\r\nreturn err;\r\nerr |=\r\ncopy_in_user(&arg32->error_info, &p->error_info,\r\nsizeof(arg32->error_info));\r\nif (err)\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int cciss_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\ndrive_info_struct *drv = get_drv(bdev->bd_disk);\r\nif (!drv->cylinders)\r\nreturn -ENXIO;\r\ngeo->heads = drv->heads;\r\ngeo->sectors = drv->sectors;\r\ngeo->cylinders = drv->cylinders;\r\nreturn 0;\r\n}\r\nstatic void check_ioctl_unit_attention(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nif (c->err_info->CommandStatus == CMD_TARGET_STATUS &&\r\nc->err_info->ScsiStatus != SAM_STAT_CHECK_CONDITION)\r\n(void)check_for_unit_attention(h, c);\r\n}\r\nstatic int cciss_getpciinfo(ctlr_info_t *h, void __user *argp)\r\n{\r\ncciss_pci_info_struct pciinfo;\r\nif (!argp)\r\nreturn -EINVAL;\r\npciinfo.domain = pci_domain_nr(h->pdev->bus);\r\npciinfo.bus = h->pdev->bus->number;\r\npciinfo.dev_fn = h->pdev->devfn;\r\npciinfo.board_id = h->board_id;\r\nif (copy_to_user(argp, &pciinfo, sizeof(cciss_pci_info_struct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_getintinfo(ctlr_info_t *h, void __user *argp)\r\n{\r\ncciss_coalint_struct intinfo;\r\nunsigned long flags;\r\nif (!argp)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&h->lock, flags);\r\nintinfo.delay = readl(&h->cfgtable->HostWrite.CoalIntDelay);\r\nintinfo.count = readl(&h->cfgtable->HostWrite.CoalIntCount);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (copy_to_user\r\n(argp, &intinfo, sizeof(cciss_coalint_struct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_setintinfo(ctlr_info_t *h, void __user *argp)\r\n{\r\ncciss_coalint_struct intinfo;\r\nunsigned long flags;\r\nint i;\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&intinfo, argp, sizeof(intinfo)))\r\nreturn -EFAULT;\r\nif ((intinfo.delay == 0) && (intinfo.count == 0))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&h->lock, flags);\r\nwritel(intinfo.delay, &(h->cfgtable->HostWrite.CoalIntDelay));\r\nwritel(intinfo.count, &(h->cfgtable->HostWrite.CoalIntCount));\r\nwritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\r\nfor (i = 0; i < MAX_IOCTL_CONFIG_WAIT; i++) {\r\nif (!(readl(h->vaddr + SA5_DOORBELL) & CFGTBL_ChangeReq))\r\nbreak;\r\nudelay(1000);\r\n}\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (i >= MAX_IOCTL_CONFIG_WAIT)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cciss_getnodename(ctlr_info_t *h, void __user *argp)\r\n{\r\nNodeName_type NodeName;\r\nunsigned long flags;\r\nint i;\r\nif (!argp)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&h->lock, flags);\r\nfor (i = 0; i < 16; i++)\r\nNodeName[i] = readb(&h->cfgtable->ServerName[i]);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (copy_to_user(argp, NodeName, sizeof(NodeName_type)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_setnodename(ctlr_info_t *h, void __user *argp)\r\n{\r\nNodeName_type NodeName;\r\nunsigned long flags;\r\nint i;\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(NodeName, argp, sizeof(NodeName_type)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&h->lock, flags);\r\nfor (i = 0; i < 16; i++)\r\nwriteb(NodeName[i], &h->cfgtable->ServerName[i]);\r\nwritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\r\nfor (i = 0; i < MAX_IOCTL_CONFIG_WAIT; i++) {\r\nif (!(readl(h->vaddr + SA5_DOORBELL) & CFGTBL_ChangeReq))\r\nbreak;\r\nudelay(1000);\r\n}\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (i >= MAX_IOCTL_CONFIG_WAIT)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cciss_getheartbeat(ctlr_info_t *h, void __user *argp)\r\n{\r\nHeartbeat_type heartbeat;\r\nunsigned long flags;\r\nif (!argp)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&h->lock, flags);\r\nheartbeat = readl(&h->cfgtable->HeartBeat);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (copy_to_user(argp, &heartbeat, sizeof(Heartbeat_type)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_getbustypes(ctlr_info_t *h, void __user *argp)\r\n{\r\nBusTypes_type BusTypes;\r\nunsigned long flags;\r\nif (!argp)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&h->lock, flags);\r\nBusTypes = readl(&h->cfgtable->BusTypes);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (copy_to_user(argp, &BusTypes, sizeof(BusTypes_type)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_getfirmver(ctlr_info_t *h, void __user *argp)\r\n{\r\nFirmwareVer_type firmware;\r\nif (!argp)\r\nreturn -EINVAL;\r\nmemcpy(firmware, h->firm_ver, 4);\r\nif (copy_to_user\r\n(argp, firmware, sizeof(FirmwareVer_type)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_getdrivver(ctlr_info_t *h, void __user *argp)\r\n{\r\nDriverVer_type DriverVer = DRIVER_VERSION;\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (copy_to_user(argp, &DriverVer, sizeof(DriverVer_type)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_getluninfo(ctlr_info_t *h,\r\nstruct gendisk *disk, void __user *argp)\r\n{\r\nLogvolInfo_struct luninfo;\r\ndrive_info_struct *drv = get_drv(disk);\r\nif (!argp)\r\nreturn -EINVAL;\r\nmemcpy(&luninfo.LunID, drv->LunID, sizeof(luninfo.LunID));\r\nluninfo.num_opens = drv->usage_count;\r\nluninfo.num_parts = 0;\r\nif (copy_to_user(argp, &luninfo, sizeof(LogvolInfo_struct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cciss_passthru(ctlr_info_t *h, void __user *argp)\r\n{\r\nIOCTL_Command_struct iocommand;\r\nCommandList_struct *c;\r\nchar *buff = NULL;\r\nu64bit temp64;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (copy_from_user\r\n(&iocommand, argp, sizeof(IOCTL_Command_struct)))\r\nreturn -EFAULT;\r\nif ((iocommand.buf_size < 1) &&\r\n(iocommand.Request.Type.Direction != XFER_NONE)) {\r\nreturn -EINVAL;\r\n}\r\nif (iocommand.buf_size > 0) {\r\nbuff = kmalloc(iocommand.buf_size, GFP_KERNEL);\r\nif (buff == NULL)\r\nreturn -EFAULT;\r\n}\r\nif (iocommand.Request.Type.Direction == XFER_WRITE) {\r\nif (copy_from_user(buff, iocommand.buf, iocommand.buf_size)) {\r\nkfree(buff);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nmemset(buff, 0, iocommand.buf_size);\r\n}\r\nc = cmd_special_alloc(h);\r\nif (!c) {\r\nkfree(buff);\r\nreturn -ENOMEM;\r\n}\r\nc->cmd_type = CMD_IOCTL_PEND;\r\nc->Header.ReplyQueue = 0;\r\nif (iocommand.buf_size > 0) {\r\nc->Header.SGList = 1;\r\nc->Header.SGTotal = 1;\r\n} else {\r\nc->Header.SGList = 0;\r\nc->Header.SGTotal = 0;\r\n}\r\nc->Header.LUN = iocommand.LUN_info;\r\nc->Header.Tag.lower = c->busaddr;\r\nc->Request = iocommand.Request;\r\nif (iocommand.buf_size > 0) {\r\ntemp64.val = pci_map_single(h->pdev, buff,\r\niocommand.buf_size, PCI_DMA_BIDIRECTIONAL);\r\nc->SG[0].Addr.lower = temp64.val32.lower;\r\nc->SG[0].Addr.upper = temp64.val32.upper;\r\nc->SG[0].Len = iocommand.buf_size;\r\nc->SG[0].Ext = 0;\r\n}\r\nc->waiting = &wait;\r\nenqueue_cmd_and_start_io(h, c);\r\nwait_for_completion(&wait);\r\ntemp64.val32.lower = c->SG[0].Addr.lower;\r\ntemp64.val32.upper = c->SG[0].Addr.upper;\r\npci_unmap_single(h->pdev, (dma_addr_t) temp64.val, iocommand.buf_size,\r\nPCI_DMA_BIDIRECTIONAL);\r\ncheck_ioctl_unit_attention(h, c);\r\niocommand.error_info = *(c->err_info);\r\nif (copy_to_user(argp, &iocommand, sizeof(IOCTL_Command_struct))) {\r\nkfree(buff);\r\ncmd_special_free(h, c);\r\nreturn -EFAULT;\r\n}\r\nif (iocommand.Request.Type.Direction == XFER_READ) {\r\nif (copy_to_user(iocommand.buf, buff, iocommand.buf_size)) {\r\nkfree(buff);\r\ncmd_special_free(h, c);\r\nreturn -EFAULT;\r\n}\r\n}\r\nkfree(buff);\r\ncmd_special_free(h, c);\r\nreturn 0;\r\n}\r\nstatic int cciss_bigpassthru(ctlr_info_t *h, void __user *argp)\r\n{\r\nBIG_IOCTL_Command_struct *ioc;\r\nCommandList_struct *c;\r\nunsigned char **buff = NULL;\r\nint *buff_size = NULL;\r\nu64bit temp64;\r\nBYTE sg_used = 0;\r\nint status = 0;\r\nint i;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\n__u32 left;\r\n__u32 sz;\r\nBYTE __user *data_ptr;\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nioc = kmalloc(sizeof(*ioc), GFP_KERNEL);\r\nif (!ioc) {\r\nstatus = -ENOMEM;\r\ngoto cleanup1;\r\n}\r\nif (copy_from_user(ioc, argp, sizeof(*ioc))) {\r\nstatus = -EFAULT;\r\ngoto cleanup1;\r\n}\r\nif ((ioc->buf_size < 1) &&\r\n(ioc->Request.Type.Direction != XFER_NONE)) {\r\nstatus = -EINVAL;\r\ngoto cleanup1;\r\n}\r\nif (ioc->malloc_size > MAX_KMALLOC_SIZE) {\r\nstatus = -EINVAL;\r\ngoto cleanup1;\r\n}\r\nif (ioc->buf_size > ioc->malloc_size * MAXSGENTRIES) {\r\nstatus = -EINVAL;\r\ngoto cleanup1;\r\n}\r\nbuff = kzalloc(MAXSGENTRIES * sizeof(char *), GFP_KERNEL);\r\nif (!buff) {\r\nstatus = -ENOMEM;\r\ngoto cleanup1;\r\n}\r\nbuff_size = kmalloc(MAXSGENTRIES * sizeof(int), GFP_KERNEL);\r\nif (!buff_size) {\r\nstatus = -ENOMEM;\r\ngoto cleanup1;\r\n}\r\nleft = ioc->buf_size;\r\ndata_ptr = ioc->buf;\r\nwhile (left) {\r\nsz = (left > ioc->malloc_size) ? ioc->malloc_size : left;\r\nbuff_size[sg_used] = sz;\r\nbuff[sg_used] = kmalloc(sz, GFP_KERNEL);\r\nif (buff[sg_used] == NULL) {\r\nstatus = -ENOMEM;\r\ngoto cleanup1;\r\n}\r\nif (ioc->Request.Type.Direction == XFER_WRITE) {\r\nif (copy_from_user(buff[sg_used], data_ptr, sz)) {\r\nstatus = -EFAULT;\r\ngoto cleanup1;\r\n}\r\n} else {\r\nmemset(buff[sg_used], 0, sz);\r\n}\r\nleft -= sz;\r\ndata_ptr += sz;\r\nsg_used++;\r\n}\r\nc = cmd_special_alloc(h);\r\nif (!c) {\r\nstatus = -ENOMEM;\r\ngoto cleanup1;\r\n}\r\nc->cmd_type = CMD_IOCTL_PEND;\r\nc->Header.ReplyQueue = 0;\r\nc->Header.SGList = sg_used;\r\nc->Header.SGTotal = sg_used;\r\nc->Header.LUN = ioc->LUN_info;\r\nc->Header.Tag.lower = c->busaddr;\r\nc->Request = ioc->Request;\r\nfor (i = 0; i < sg_used; i++) {\r\ntemp64.val = pci_map_single(h->pdev, buff[i], buff_size[i],\r\nPCI_DMA_BIDIRECTIONAL);\r\nc->SG[i].Addr.lower = temp64.val32.lower;\r\nc->SG[i].Addr.upper = temp64.val32.upper;\r\nc->SG[i].Len = buff_size[i];\r\nc->SG[i].Ext = 0;\r\n}\r\nc->waiting = &wait;\r\nenqueue_cmd_and_start_io(h, c);\r\nwait_for_completion(&wait);\r\nfor (i = 0; i < sg_used; i++) {\r\ntemp64.val32.lower = c->SG[i].Addr.lower;\r\ntemp64.val32.upper = c->SG[i].Addr.upper;\r\npci_unmap_single(h->pdev,\r\n(dma_addr_t) temp64.val, buff_size[i],\r\nPCI_DMA_BIDIRECTIONAL);\r\n}\r\ncheck_ioctl_unit_attention(h, c);\r\nioc->error_info = *(c->err_info);\r\nif (copy_to_user(argp, ioc, sizeof(*ioc))) {\r\ncmd_special_free(h, c);\r\nstatus = -EFAULT;\r\ngoto cleanup1;\r\n}\r\nif (ioc->Request.Type.Direction == XFER_READ) {\r\nBYTE __user *ptr = ioc->buf;\r\nfor (i = 0; i < sg_used; i++) {\r\nif (copy_to_user(ptr, buff[i], buff_size[i])) {\r\ncmd_special_free(h, c);\r\nstatus = -EFAULT;\r\ngoto cleanup1;\r\n}\r\nptr += buff_size[i];\r\n}\r\n}\r\ncmd_special_free(h, c);\r\nstatus = 0;\r\ncleanup1:\r\nif (buff) {\r\nfor (i = 0; i < sg_used; i++)\r\nkfree(buff[i]);\r\nkfree(buff);\r\n}\r\nkfree(buff_size);\r\nkfree(ioc);\r\nreturn status;\r\n}\r\nstatic int cciss_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nctlr_info_t *h = get_host(disk);\r\nvoid __user *argp = (void __user *)arg;\r\ndev_dbg(&h->pdev->dev, "cciss_ioctl: Called with cmd=%x %lx\n",\r\ncmd, arg);\r\nswitch (cmd) {\r\ncase CCISS_GETPCIINFO:\r\nreturn cciss_getpciinfo(h, argp);\r\ncase CCISS_GETINTINFO:\r\nreturn cciss_getintinfo(h, argp);\r\ncase CCISS_SETINTINFO:\r\nreturn cciss_setintinfo(h, argp);\r\ncase CCISS_GETNODENAME:\r\nreturn cciss_getnodename(h, argp);\r\ncase CCISS_SETNODENAME:\r\nreturn cciss_setnodename(h, argp);\r\ncase CCISS_GETHEARTBEAT:\r\nreturn cciss_getheartbeat(h, argp);\r\ncase CCISS_GETBUSTYPES:\r\nreturn cciss_getbustypes(h, argp);\r\ncase CCISS_GETFIRMVER:\r\nreturn cciss_getfirmver(h, argp);\r\ncase CCISS_GETDRIVVER:\r\nreturn cciss_getdrivver(h, argp);\r\ncase CCISS_DEREGDISK:\r\ncase CCISS_REGNEWD:\r\ncase CCISS_REVALIDVOLS:\r\nreturn rebuild_lun_table(h, 0, 1);\r\ncase CCISS_GETLUNINFO:\r\nreturn cciss_getluninfo(h, disk, argp);\r\ncase CCISS_PASSTHRU:\r\nreturn cciss_passthru(h, argp);\r\ncase CCISS_BIG_PASSTHRU:\r\nreturn cciss_bigpassthru(h, argp);\r\ncase SG_GET_VERSION_NUM:\r\ncase SG_SET_TIMEOUT:\r\ncase SG_GET_TIMEOUT:\r\ncase SG_GET_RESERVED_SIZE:\r\ncase SG_SET_RESERVED_SIZE:\r\ncase SG_EMULATED_HOST:\r\ncase SG_IO:\r\ncase SCSI_IOCTL_SEND_COMMAND:\r\nreturn scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);\r\ncase CDROM_SEND_PACKET:\r\ncase CDROMCLOSETRAY:\r\ncase CDROMEJECT:\r\ncase SCSI_IOCTL_GET_IDLUN:\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic void cciss_check_queues(ctlr_info_t *h)\r\n{\r\nint start_queue = h->next_to_run;\r\nint i;\r\nif ((find_first_zero_bit(h->cmd_pool_bits, h->nr_cmds)) == h->nr_cmds)\r\nreturn;\r\nfor (i = 0; i < h->highest_lun + 1; i++) {\r\nint curr_queue = (start_queue + i) % (h->highest_lun + 1);\r\nif (!h->drv[curr_queue])\r\ncontinue;\r\nif (!(h->drv[curr_queue]->queue) ||\r\n!(h->drv[curr_queue]->heads))\r\ncontinue;\r\nblk_start_queue(h->gendisk[curr_queue]->queue);\r\nif ((find_first_zero_bit(h->cmd_pool_bits, h->nr_cmds)) == h->nr_cmds) {\r\nif (curr_queue == start_queue) {\r\nh->next_to_run =\r\n(start_queue + 1) % (h->highest_lun + 1);\r\nbreak;\r\n} else {\r\nh->next_to_run = curr_queue;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void cciss_softirq_done(struct request *rq)\r\n{\r\nCommandList_struct *c = rq->completion_data;\r\nctlr_info_t *h = hba[c->ctlr];\r\nSGDescriptor_struct *curr_sg = c->SG;\r\nu64bit temp64;\r\nunsigned long flags;\r\nint i, ddir;\r\nint sg_index = 0;\r\nif (c->Request.Type.Direction == XFER_READ)\r\nddir = PCI_DMA_FROMDEVICE;\r\nelse\r\nddir = PCI_DMA_TODEVICE;\r\nfor (i = 0; i < c->Header.SGList; i++) {\r\nif (curr_sg[sg_index].Ext == CCISS_SG_CHAIN) {\r\ncciss_unmap_sg_chain_block(h, c);\r\ncurr_sg = h->cmd_sg_list[c->cmdindex];\r\nsg_index = 0;\r\n}\r\ntemp64.val32.lower = curr_sg[sg_index].Addr.lower;\r\ntemp64.val32.upper = curr_sg[sg_index].Addr.upper;\r\npci_unmap_page(h->pdev, temp64.val, curr_sg[sg_index].Len,\r\nddir);\r\n++sg_index;\r\n}\r\ndev_dbg(&h->pdev->dev, "Done with %p\n", rq);\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC)\r\nrq->resid_len = c->err_info->ResidualCnt;\r\nblk_end_request_all(rq, (rq->errors == 0) ? 0 : -EIO);\r\nspin_lock_irqsave(&h->lock, flags);\r\ncmd_free(h, c);\r\ncciss_check_queues(h);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\n}\r\nstatic inline void log_unit_to_scsi3addr(ctlr_info_t *h,\r\nunsigned char scsi3addr[], uint32_t log_unit)\r\n{\r\nmemcpy(scsi3addr, h->drv[log_unit]->LunID,\r\nsizeof(h->drv[log_unit]->LunID));\r\n}\r\nstatic void cciss_get_device_descr(ctlr_info_t *h, int logvol,\r\nchar *vendor, char *model, char *rev)\r\n{\r\nint rc;\r\nInquiryData_struct *inq_buf;\r\nunsigned char scsi3addr[8];\r\n*vendor = '\0';\r\n*model = '\0';\r\n*rev = '\0';\r\ninq_buf = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);\r\nif (!inq_buf)\r\nreturn;\r\nlog_unit_to_scsi3addr(h, scsi3addr, logvol);\r\nrc = sendcmd_withirq(h, CISS_INQUIRY, inq_buf, sizeof(*inq_buf), 0,\r\nscsi3addr, TYPE_CMD);\r\nif (rc == IO_OK) {\r\nmemcpy(vendor, &inq_buf->data_byte[8], VENDOR_LEN);\r\nvendor[VENDOR_LEN] = '\0';\r\nmemcpy(model, &inq_buf->data_byte[16], MODEL_LEN);\r\nmodel[MODEL_LEN] = '\0';\r\nmemcpy(rev, &inq_buf->data_byte[32], REV_LEN);\r\nrev[REV_LEN] = '\0';\r\n}\r\nkfree(inq_buf);\r\nreturn;\r\n}\r\nstatic void cciss_get_serial_no(ctlr_info_t *h, int logvol,\r\nunsigned char *serial_no, int buflen)\r\n{\r\n#define PAGE_83_INQ_BYTES 64\r\nint rc;\r\nunsigned char *buf;\r\nunsigned char scsi3addr[8];\r\nif (buflen > 16)\r\nbuflen = 16;\r\nmemset(serial_no, 0xff, buflen);\r\nbuf = kzalloc(PAGE_83_INQ_BYTES, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nmemset(serial_no, 0, buflen);\r\nlog_unit_to_scsi3addr(h, scsi3addr, logvol);\r\nrc = sendcmd_withirq(h, CISS_INQUIRY, buf,\r\nPAGE_83_INQ_BYTES, 0x83, scsi3addr, TYPE_CMD);\r\nif (rc == IO_OK)\r\nmemcpy(serial_no, &buf[8], buflen);\r\nkfree(buf);\r\nreturn;\r\n}\r\nstatic int cciss_add_disk(ctlr_info_t *h, struct gendisk *disk,\r\nint drv_index)\r\n{\r\ndisk->queue = blk_init_queue(do_cciss_request, &h->lock);\r\nif (!disk->queue)\r\ngoto init_queue_failure;\r\nsprintf(disk->disk_name, "cciss/c%dd%d", h->ctlr, drv_index);\r\ndisk->major = h->major;\r\ndisk->first_minor = drv_index << NWD_SHIFT;\r\ndisk->fops = &cciss_fops;\r\nif (cciss_create_ld_sysfs_entry(h, drv_index))\r\ngoto cleanup_queue;\r\ndisk->private_data = h->drv[drv_index];\r\ndisk->driverfs_dev = &h->drv[drv_index]->dev;\r\nblk_queue_bounce_limit(disk->queue, h->pdev->dma_mask);\r\nblk_queue_max_segments(disk->queue, h->maxsgentries);\r\nblk_queue_max_hw_sectors(disk->queue, h->cciss_max_sectors);\r\nblk_queue_softirq_done(disk->queue, cciss_softirq_done);\r\ndisk->queue->queuedata = h;\r\nblk_queue_logical_block_size(disk->queue,\r\nh->drv[drv_index]->block_size);\r\nwmb();\r\nh->drv[drv_index]->queue = disk->queue;\r\nadd_disk(disk);\r\nreturn 0;\r\ncleanup_queue:\r\nblk_cleanup_queue(disk->queue);\r\ndisk->queue = NULL;\r\ninit_queue_failure:\r\nreturn -1;\r\n}\r\nstatic void cciss_update_drive_info(ctlr_info_t *h, int drv_index,\r\nint first_time, int via_ioctl)\r\n{\r\nstruct gendisk *disk;\r\nInquiryData_struct *inq_buff = NULL;\r\nunsigned int block_size;\r\nsector_t total_size;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\ndrive_info_struct *drvinfo;\r\ninq_buff = kmalloc(sizeof(InquiryData_struct), GFP_KERNEL);\r\ndrvinfo = kzalloc(sizeof(*drvinfo), GFP_KERNEL);\r\nif (inq_buff == NULL || drvinfo == NULL)\r\ngoto mem_msg;\r\nif (h->cciss_read == CCISS_READ_16) {\r\ncciss_read_capacity_16(h, drv_index,\r\n&total_size, &block_size);\r\n} else {\r\ncciss_read_capacity(h, drv_index, &total_size, &block_size);\r\nif (total_size == 0xFFFFFFFFULL) {\r\ncciss_read_capacity_16(h, drv_index,\r\n&total_size, &block_size);\r\nh->cciss_read = CCISS_READ_16;\r\nh->cciss_write = CCISS_WRITE_16;\r\n} else {\r\nh->cciss_read = CCISS_READ_10;\r\nh->cciss_write = CCISS_WRITE_10;\r\n}\r\n}\r\ncciss_geometry_inquiry(h, drv_index, total_size, block_size,\r\ninq_buff, drvinfo);\r\ndrvinfo->block_size = block_size;\r\ndrvinfo->nr_blocks = total_size + 1;\r\ncciss_get_device_descr(h, drv_index, drvinfo->vendor,\r\ndrvinfo->model, drvinfo->rev);\r\ncciss_get_serial_no(h, drv_index, drvinfo->serial_no,\r\nsizeof(drvinfo->serial_no));\r\nmemcpy(drvinfo->LunID, h->drv[drv_index]->LunID,\r\nsizeof(drvinfo->LunID));\r\nif (h->drv[drv_index]->raid_level != -1 &&\r\n((memcmp(drvinfo->serial_no,\r\nh->drv[drv_index]->serial_no, 16) == 0) &&\r\ndrvinfo->block_size == h->drv[drv_index]->block_size &&\r\ndrvinfo->nr_blocks == h->drv[drv_index]->nr_blocks &&\r\ndrvinfo->heads == h->drv[drv_index]->heads &&\r\ndrvinfo->sectors == h->drv[drv_index]->sectors &&\r\ndrvinfo->cylinders == h->drv[drv_index]->cylinders))\r\ngoto freeret;\r\nif (h->drv[drv_index]->raid_level != -1 && drv_index != 0) {\r\ndev_warn(&h->pdev->dev, "disk %d has changed.\n", drv_index);\r\nspin_lock_irqsave(&h->lock, flags);\r\nh->drv[drv_index]->busy_configuring = 1;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nret = deregister_disk(h, drv_index, 0, via_ioctl);\r\n}\r\nif (ret)\r\ngoto freeret;\r\nif (h->drv[drv_index] == NULL) {\r\ndrvinfo->device_initialized = 0;\r\nh->drv[drv_index] = drvinfo;\r\ndrvinfo = NULL;\r\n} else {\r\nh->drv[drv_index]->block_size = drvinfo->block_size;\r\nh->drv[drv_index]->nr_blocks = drvinfo->nr_blocks;\r\nh->drv[drv_index]->heads = drvinfo->heads;\r\nh->drv[drv_index]->sectors = drvinfo->sectors;\r\nh->drv[drv_index]->cylinders = drvinfo->cylinders;\r\nh->drv[drv_index]->raid_level = drvinfo->raid_level;\r\nmemcpy(h->drv[drv_index]->serial_no, drvinfo->serial_no, 16);\r\nmemcpy(h->drv[drv_index]->vendor, drvinfo->vendor,\r\nVENDOR_LEN + 1);\r\nmemcpy(h->drv[drv_index]->model, drvinfo->model, MODEL_LEN + 1);\r\nmemcpy(h->drv[drv_index]->rev, drvinfo->rev, REV_LEN + 1);\r\n}\r\n++h->num_luns;\r\ndisk = h->gendisk[drv_index];\r\nset_capacity(disk, h->drv[drv_index]->nr_blocks);\r\nif (drv_index || first_time) {\r\nif (cciss_add_disk(h, disk, drv_index) != 0) {\r\ncciss_free_gendisk(h, drv_index);\r\ncciss_free_drive_info(h, drv_index);\r\ndev_warn(&h->pdev->dev, "could not update disk %d\n",\r\ndrv_index);\r\n--h->num_luns;\r\n}\r\n}\r\nfreeret:\r\nkfree(inq_buff);\r\nkfree(drvinfo);\r\nreturn;\r\nmem_msg:\r\ndev_err(&h->pdev->dev, "out of memory\n");\r\ngoto freeret;\r\n}\r\nstatic int cciss_alloc_drive_info(ctlr_info_t *h, int controller_node)\r\n{\r\nint i;\r\ndrive_info_struct *drv;\r\nfor (i = 0; i < CISS_MAX_LUN; i++) {\r\nif (h->drv[i] && i != 0)\r\ncontinue;\r\nif (i == 0 && h->drv[i] && h->drv[i]->raid_level != -1)\r\ncontinue;\r\nif (i > h->highest_lun && !controller_node)\r\nh->highest_lun = i;\r\nif (i == 0 && h->drv[i] != NULL)\r\nreturn i;\r\ndrv = kzalloc(sizeof(*drv), GFP_KERNEL);\r\nif (!drv)\r\nreturn -1;\r\ndrv->raid_level = -1;\r\nh->drv[i] = drv;\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic void cciss_free_drive_info(ctlr_info_t *h, int drv_index)\r\n{\r\nkfree(h->drv[drv_index]);\r\nh->drv[drv_index] = NULL;\r\n}\r\nstatic void cciss_free_gendisk(ctlr_info_t *h, int drv_index)\r\n{\r\nput_disk(h->gendisk[drv_index]);\r\nh->gendisk[drv_index] = NULL;\r\n}\r\nstatic int cciss_add_gendisk(ctlr_info_t *h, unsigned char lunid[],\r\nint controller_node)\r\n{\r\nint drv_index;\r\ndrv_index = cciss_alloc_drive_info(h, controller_node);\r\nif (drv_index == -1)\r\nreturn -1;\r\nif (!h->gendisk[drv_index]) {\r\nh->gendisk[drv_index] =\r\nalloc_disk(1 << NWD_SHIFT);\r\nif (!h->gendisk[drv_index]) {\r\ndev_err(&h->pdev->dev,\r\n"could not allocate a new disk %d\n",\r\ndrv_index);\r\ngoto err_free_drive_info;\r\n}\r\n}\r\nmemcpy(h->drv[drv_index]->LunID, lunid,\r\nsizeof(h->drv[drv_index]->LunID));\r\nif (cciss_create_ld_sysfs_entry(h, drv_index))\r\ngoto err_free_disk;\r\nh->drv[drv_index]->busy_configuring = 0;\r\nwmb();\r\nreturn drv_index;\r\nerr_free_disk:\r\ncciss_free_gendisk(h, drv_index);\r\nerr_free_drive_info:\r\ncciss_free_drive_info(h, drv_index);\r\nreturn -1;\r\n}\r\nstatic void cciss_add_controller_node(ctlr_info_t *h)\r\n{\r\nstruct gendisk *disk;\r\nint drv_index;\r\nif (h->gendisk[0] != NULL)\r\nreturn;\r\ndrv_index = cciss_add_gendisk(h, CTLR_LUNID, 1);\r\nif (drv_index == -1)\r\ngoto error;\r\nh->drv[drv_index]->block_size = 512;\r\nh->drv[drv_index]->nr_blocks = 0;\r\nh->drv[drv_index]->heads = 0;\r\nh->drv[drv_index]->sectors = 0;\r\nh->drv[drv_index]->cylinders = 0;\r\nh->drv[drv_index]->raid_level = -1;\r\nmemset(h->drv[drv_index]->serial_no, 0, 16);\r\ndisk = h->gendisk[drv_index];\r\nif (cciss_add_disk(h, disk, drv_index) == 0)\r\nreturn;\r\ncciss_free_gendisk(h, drv_index);\r\ncciss_free_drive_info(h, drv_index);\r\nerror:\r\ndev_warn(&h->pdev->dev, "could not add disk 0.\n");\r\nreturn;\r\n}\r\nstatic int rebuild_lun_table(ctlr_info_t *h, int first_time,\r\nint via_ioctl)\r\n{\r\nint num_luns;\r\nReportLunData_struct *ld_buff = NULL;\r\nint return_code;\r\nint listlength = 0;\r\nint i;\r\nint drv_found;\r\nint drv_index = 0;\r\nunsigned char lunid[8] = CTLR_LUNID;\r\nunsigned long flags;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nspin_lock_irqsave(&h->lock, flags);\r\nif (h->busy_configuring) {\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nh->busy_configuring = 1;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nld_buff = kzalloc(sizeof(ReportLunData_struct), GFP_KERNEL);\r\nif (ld_buff == NULL)\r\ngoto mem_msg;\r\nreturn_code = sendcmd_withirq(h, CISS_REPORT_LOG, ld_buff,\r\nsizeof(ReportLunData_struct),\r\n0, CTLR_LUNID, TYPE_CMD);\r\nif (return_code == IO_OK)\r\nlistlength = be32_to_cpu(*(__be32 *) ld_buff->LUNListLength);\r\nelse {\r\ndev_warn(&h->pdev->dev,\r\n"report logical volume command failed\n");\r\nlistlength = 0;\r\ngoto freeret;\r\n}\r\nnum_luns = listlength / 8;\r\nif (num_luns > CISS_MAX_LUN) {\r\nnum_luns = CISS_MAX_LUN;\r\ndev_warn(&h->pdev->dev, "more luns configured"\r\n" on controller than can be handled by"\r\n" this driver.\n");\r\n}\r\nif (num_luns == 0)\r\ncciss_add_controller_node(h);\r\nfor (i = 0; i <= h->highest_lun; i++) {\r\nint j;\r\ndrv_found = 0;\r\nif (h->drv[i] == NULL)\r\ncontinue;\r\nfor (j = 0; j < num_luns; j++) {\r\nmemcpy(lunid, &ld_buff->LUN[j][0], sizeof(lunid));\r\nif (memcmp(h->drv[i]->LunID, lunid,\r\nsizeof(lunid)) == 0) {\r\ndrv_found = 1;\r\nbreak;\r\n}\r\n}\r\nif (!drv_found) {\r\nspin_lock_irqsave(&h->lock, flags);\r\nh->drv[i]->busy_configuring = 1;\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn_code = deregister_disk(h, i, 1, via_ioctl);\r\nif (h->drv[i] != NULL)\r\nh->drv[i]->busy_configuring = 0;\r\n}\r\n}\r\nfor (i = 0; i < num_luns; i++) {\r\nint j;\r\ndrv_found = 0;\r\nmemcpy(lunid, &ld_buff->LUN[i][0], sizeof(lunid));\r\nfor (j = 0; j <= h->highest_lun; j++) {\r\nif (h->drv[j] != NULL &&\r\nmemcmp(h->drv[j]->LunID, lunid,\r\nsizeof(h->drv[j]->LunID)) == 0) {\r\ndrv_index = j;\r\ndrv_found = 1;\r\nbreak;\r\n}\r\n}\r\nif (!drv_found) {\r\ndrv_index = cciss_add_gendisk(h, lunid, 0);\r\nif (drv_index == -1)\r\ngoto freeret;\r\n}\r\ncciss_update_drive_info(h, drv_index, first_time, via_ioctl);\r\n}\r\nfreeret:\r\nkfree(ld_buff);\r\nh->busy_configuring = 0;\r\nreturn -1;\r\nmem_msg:\r\ndev_err(&h->pdev->dev, "out of memory\n");\r\nh->busy_configuring = 0;\r\ngoto freeret;\r\n}\r\nstatic void cciss_clear_drive_info(drive_info_struct *drive_info)\r\n{\r\ndrive_info->nr_blocks = 0;\r\ndrive_info->block_size = 0;\r\ndrive_info->heads = 0;\r\ndrive_info->sectors = 0;\r\ndrive_info->cylinders = 0;\r\ndrive_info->raid_level = -1;\r\nmemset(drive_info->serial_no, 0, sizeof(drive_info->serial_no));\r\nmemset(drive_info->model, 0, sizeof(drive_info->model));\r\nmemset(drive_info->rev, 0, sizeof(drive_info->rev));\r\nmemset(drive_info->vendor, 0, sizeof(drive_info->vendor));\r\n}\r\nstatic int deregister_disk(ctlr_info_t *h, int drv_index,\r\nint clear_all, int via_ioctl)\r\n{\r\nint i;\r\nstruct gendisk *disk;\r\ndrive_info_struct *drv;\r\nint recalculate_highest_lun;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\ndrv = h->drv[drv_index];\r\ndisk = h->gendisk[drv_index];\r\nif (clear_all || (h->gendisk[0] == disk)) {\r\nif (drv->usage_count > via_ioctl)\r\nreturn -EBUSY;\r\n} else if (drv->usage_count > 0)\r\nreturn -EBUSY;\r\nrecalculate_highest_lun = (drv == h->drv[h->highest_lun]);\r\nif (h->gendisk[0] != disk) {\r\nstruct request_queue *q = disk->queue;\r\nif (disk->flags & GENHD_FL_UP) {\r\ncciss_destroy_ld_sysfs_entry(h, drv_index, 0);\r\ndel_gendisk(disk);\r\n}\r\nif (q)\r\nblk_cleanup_queue(q);\r\nif (clear_all){\r\nfor (i=0; i < CISS_MAX_LUN; i++){\r\nif (h->gendisk[i] == disk) {\r\nh->gendisk[i] = NULL;\r\nbreak;\r\n}\r\n}\r\nput_disk(disk);\r\n}\r\n} else {\r\nset_capacity(disk, 0);\r\ncciss_clear_drive_info(drv);\r\n}\r\n--h->num_luns;\r\nif (clear_all && recalculate_highest_lun) {\r\nint newhighest = -1;\r\nfor (i = 0; i <= h->highest_lun; i++) {\r\nif (h->drv[i] && h->drv[i]->heads)\r\nnewhighest = i;\r\n}\r\nh->highest_lun = newhighest;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fill_cmd(ctlr_info_t *h, CommandList_struct *c, __u8 cmd, void *buff,\r\nsize_t size, __u8 page_code, unsigned char *scsi3addr,\r\nint cmd_type)\r\n{\r\nu64bit buff_dma_handle;\r\nint status = IO_OK;\r\nc->cmd_type = CMD_IOCTL_PEND;\r\nc->Header.ReplyQueue = 0;\r\nif (buff != NULL) {\r\nc->Header.SGList = 1;\r\nc->Header.SGTotal = 1;\r\n} else {\r\nc->Header.SGList = 0;\r\nc->Header.SGTotal = 0;\r\n}\r\nc->Header.Tag.lower = c->busaddr;\r\nmemcpy(c->Header.LUN.LunAddrBytes, scsi3addr, 8);\r\nc->Request.Type.Type = cmd_type;\r\nif (cmd_type == TYPE_CMD) {\r\nswitch (cmd) {\r\ncase CISS_INQUIRY:\r\nif (page_code != 0) {\r\nc->Request.CDB[1] = 0x01;\r\nc->Request.CDB[2] = page_code;\r\n}\r\nc->Request.CDBLen = 6;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_READ;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = CISS_INQUIRY;\r\nc->Request.CDB[4] = size & 0xFF;\r\nbreak;\r\ncase CISS_REPORT_LOG:\r\ncase CISS_REPORT_PHYS:\r\nc->Request.CDBLen = 12;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_READ;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = cmd;\r\nc->Request.CDB[6] = (size >> 24) & 0xFF;\r\nc->Request.CDB[7] = (size >> 16) & 0xFF;\r\nc->Request.CDB[8] = (size >> 8) & 0xFF;\r\nc->Request.CDB[9] = size & 0xFF;\r\nbreak;\r\ncase CCISS_READ_CAPACITY:\r\nc->Request.CDBLen = 10;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_READ;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = cmd;\r\nbreak;\r\ncase CCISS_READ_CAPACITY_16:\r\nc->Request.CDBLen = 16;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_READ;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = cmd;\r\nc->Request.CDB[1] = 0x10;\r\nc->Request.CDB[10] = (size >> 24) & 0xFF;\r\nc->Request.CDB[11] = (size >> 16) & 0xFF;\r\nc->Request.CDB[12] = (size >> 8) & 0xFF;\r\nc->Request.CDB[13] = size & 0xFF;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = cmd;\r\nbreak;\r\ncase CCISS_CACHE_FLUSH:\r\nc->Request.CDBLen = 12;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_WRITE;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = BMIC_WRITE;\r\nc->Request.CDB[6] = BMIC_CACHE_FLUSH;\r\nc->Request.CDB[7] = (size >> 8) & 0xFF;\r\nc->Request.CDB[8] = size & 0xFF;\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nc->Request.CDBLen = 6;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_NONE;\r\nc->Request.Timeout = 0;\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev, "Unknown Command 0x%c\n", cmd);\r\nreturn IO_ERROR;\r\n}\r\n} else if (cmd_type == TYPE_MSG) {\r\nswitch (cmd) {\r\ncase CCISS_ABORT_MSG:\r\nc->Request.CDBLen = 12;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_WRITE;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = cmd;\r\nc->Request.CDB[1] = 0;\r\nmemcpy(&c->Request.CDB[4], buff, 8);\r\nbreak;\r\ncase CCISS_RESET_MSG:\r\nc->Request.CDBLen = 16;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_NONE;\r\nc->Request.Timeout = 0;\r\nmemset(&c->Request.CDB[0], 0, sizeof(c->Request.CDB));\r\nc->Request.CDB[0] = cmd;\r\nc->Request.CDB[1] = CCISS_RESET_TYPE_TARGET;\r\nbreak;\r\ncase CCISS_NOOP_MSG:\r\nc->Request.CDBLen = 1;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction = XFER_WRITE;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] = cmd;\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev,\r\n"unknown message type %d\n", cmd);\r\nreturn IO_ERROR;\r\n}\r\n} else {\r\ndev_warn(&h->pdev->dev, "unknown command type %d\n", cmd_type);\r\nreturn IO_ERROR;\r\n}\r\nif (size > 0) {\r\nbuff_dma_handle.val = (__u64) pci_map_single(h->pdev,\r\nbuff, size,\r\nPCI_DMA_BIDIRECTIONAL);\r\nc->SG[0].Addr.lower = buff_dma_handle.val32.lower;\r\nc->SG[0].Addr.upper = buff_dma_handle.val32.upper;\r\nc->SG[0].Len = size;\r\nc->SG[0].Ext = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic int cciss_send_reset(ctlr_info_t *h, unsigned char *scsi3addr,\r\nu8 reset_type)\r\n{\r\nCommandList_struct *c;\r\nint return_status;\r\nc = cmd_alloc(h);\r\nif (!c)\r\nreturn -ENOMEM;\r\nreturn_status = fill_cmd(h, c, CCISS_RESET_MSG, NULL, 0, 0,\r\nCTLR_LUNID, TYPE_MSG);\r\nc->Request.CDB[1] = reset_type;\r\nif (return_status != IO_OK) {\r\ncmd_special_free(h, c);\r\nreturn return_status;\r\n}\r\nc->waiting = NULL;\r\nenqueue_cmd_and_start_io(h, c);\r\nreturn 0;\r\n}\r\nstatic int check_target_status(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nswitch (c->err_info->ScsiStatus) {\r\ncase SAM_STAT_GOOD:\r\nreturn IO_OK;\r\ncase SAM_STAT_CHECK_CONDITION:\r\nswitch (0xf & c->err_info->SenseInfo[2]) {\r\ncase 0: return IO_OK;\r\ncase 1: return IO_OK;\r\ndefault:\r\nif (check_for_unit_attention(h, c))\r\nreturn IO_NEEDS_RETRY;\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x "\r\n"check condition, sense key = 0x%02x\n",\r\nc->Request.CDB[0], c->err_info->SenseInfo[2]);\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x"\r\n"scsi status = 0x%02x\n",\r\nc->Request.CDB[0], c->err_info->ScsiStatus);\r\nbreak;\r\n}\r\nreturn IO_ERROR;\r\n}\r\nstatic int process_sendcmd_error(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nint return_status = IO_OK;\r\nif (c->err_info->CommandStatus == CMD_SUCCESS)\r\nreturn IO_OK;\r\nswitch (c->err_info->CommandStatus) {\r\ncase CMD_TARGET_STATUS:\r\nreturn_status = check_target_status(h, c);\r\nbreak;\r\ncase CMD_DATA_UNDERRUN:\r\ncase CMD_DATA_OVERRUN:\r\nbreak;\r\ncase CMD_INVALID:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x is "\r\n"reported invalid\n", c->Request.CDB[0]);\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ncase CMD_PROTOCOL_ERR:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x has "\r\n"protocol error\n", c->Request.CDB[0]);\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ncase CMD_HARDWARE_ERR:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x had "\r\n" hardware error\n", c->Request.CDB[0]);\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ncase CMD_CONNECTION_LOST:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x had "\r\n"connection lost\n", c->Request.CDB[0]);\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ncase CMD_ABORTED:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x was "\r\n"aborted\n", c->Request.CDB[0]);\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ncase CMD_ABORT_FAILED:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x reports "\r\n"abort failed\n", c->Request.CDB[0]);\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ncase CMD_UNSOLICITED_ABORT:\r\ndev_warn(&h->pdev->dev, "unsolicited abort 0x%02x\n",\r\nc->Request.CDB[0]);\r\nreturn_status = IO_NEEDS_RETRY;\r\nbreak;\r\ncase CMD_UNABORTABLE:\r\ndev_warn(&h->pdev->dev, "cmd unabortable\n");\r\nreturn_status = IO_ERROR;\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev, "cmd 0x%02x returned "\r\n"unknown status %x\n", c->Request.CDB[0],\r\nc->err_info->CommandStatus);\r\nreturn_status = IO_ERROR;\r\n}\r\nreturn return_status;\r\n}\r\nstatic int sendcmd_withirq_core(ctlr_info_t *h, CommandList_struct *c,\r\nint attempt_retry)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nu64bit buff_dma_handle;\r\nint return_status = IO_OK;\r\nresend_cmd2:\r\nc->waiting = &wait;\r\nenqueue_cmd_and_start_io(h, c);\r\nwait_for_completion(&wait);\r\nif (c->err_info->CommandStatus == 0 || !attempt_retry)\r\ngoto command_done;\r\nreturn_status = process_sendcmd_error(h, c);\r\nif (return_status == IO_NEEDS_RETRY &&\r\nc->retry_count < MAX_CMD_RETRIES) {\r\ndev_warn(&h->pdev->dev, "retrying 0x%02x\n",\r\nc->Request.CDB[0]);\r\nc->retry_count++;\r\nmemset(c->err_info, 0, sizeof(ErrorInfo_struct));\r\nreturn_status = IO_OK;\r\nINIT_COMPLETION(wait);\r\ngoto resend_cmd2;\r\n}\r\ncommand_done:\r\nbuff_dma_handle.val32.lower = c->SG[0].Addr.lower;\r\nbuff_dma_handle.val32.upper = c->SG[0].Addr.upper;\r\npci_unmap_single(h->pdev, (dma_addr_t) buff_dma_handle.val,\r\nc->SG[0].Len, PCI_DMA_BIDIRECTIONAL);\r\nreturn return_status;\r\n}\r\nstatic int sendcmd_withirq(ctlr_info_t *h, __u8 cmd, void *buff, size_t size,\r\n__u8 page_code, unsigned char scsi3addr[],\r\nint cmd_type)\r\n{\r\nCommandList_struct *c;\r\nint return_status;\r\nc = cmd_special_alloc(h);\r\nif (!c)\r\nreturn -ENOMEM;\r\nreturn_status = fill_cmd(h, c, cmd, buff, size, page_code,\r\nscsi3addr, cmd_type);\r\nif (return_status == IO_OK)\r\nreturn_status = sendcmd_withirq_core(h, c, 1);\r\ncmd_special_free(h, c);\r\nreturn return_status;\r\n}\r\nstatic void cciss_geometry_inquiry(ctlr_info_t *h, int logvol,\r\nsector_t total_size,\r\nunsigned int block_size,\r\nInquiryData_struct *inq_buff,\r\ndrive_info_struct *drv)\r\n{\r\nint return_code;\r\nunsigned long t;\r\nunsigned char scsi3addr[8];\r\nmemset(inq_buff, 0, sizeof(InquiryData_struct));\r\nlog_unit_to_scsi3addr(h, scsi3addr, logvol);\r\nreturn_code = sendcmd_withirq(h, CISS_INQUIRY, inq_buff,\r\nsizeof(*inq_buff), 0xC1, scsi3addr, TYPE_CMD);\r\nif (return_code == IO_OK) {\r\nif (inq_buff->data_byte[8] == 0xFF) {\r\ndev_warn(&h->pdev->dev,\r\n"reading geometry failed, volume "\r\n"does not support reading geometry\n");\r\ndrv->heads = 255;\r\ndrv->sectors = 32;\r\ndrv->cylinders = total_size + 1;\r\ndrv->raid_level = RAID_UNKNOWN;\r\n} else {\r\ndrv->heads = inq_buff->data_byte[6];\r\ndrv->sectors = inq_buff->data_byte[7];\r\ndrv->cylinders = (inq_buff->data_byte[4] & 0xff) << 8;\r\ndrv->cylinders += inq_buff->data_byte[5];\r\ndrv->raid_level = inq_buff->data_byte[8];\r\n}\r\ndrv->block_size = block_size;\r\ndrv->nr_blocks = total_size + 1;\r\nt = drv->heads * drv->sectors;\r\nif (t > 1) {\r\nsector_t real_size = total_size + 1;\r\nunsigned long rem = sector_div(real_size, t);\r\nif (rem)\r\nreal_size++;\r\ndrv->cylinders = real_size;\r\n}\r\n} else {\r\ndev_warn(&h->pdev->dev, "reading geometry failed\n");\r\n}\r\n}\r\nstatic void\r\ncciss_read_capacity(ctlr_info_t *h, int logvol, sector_t *total_size,\r\nunsigned int *block_size)\r\n{\r\nReadCapdata_struct *buf;\r\nint return_code;\r\nunsigned char scsi3addr[8];\r\nbuf = kzalloc(sizeof(ReadCapdata_struct), GFP_KERNEL);\r\nif (!buf) {\r\ndev_warn(&h->pdev->dev, "out of memory\n");\r\nreturn;\r\n}\r\nlog_unit_to_scsi3addr(h, scsi3addr, logvol);\r\nreturn_code = sendcmd_withirq(h, CCISS_READ_CAPACITY, buf,\r\nsizeof(ReadCapdata_struct), 0, scsi3addr, TYPE_CMD);\r\nif (return_code == IO_OK) {\r\n*total_size = be32_to_cpu(*(__be32 *) buf->total_size);\r\n*block_size = be32_to_cpu(*(__be32 *) buf->block_size);\r\n} else {\r\ndev_warn(&h->pdev->dev, "read capacity failed\n");\r\n*total_size = 0;\r\n*block_size = BLOCK_SIZE;\r\n}\r\nkfree(buf);\r\n}\r\nstatic void cciss_read_capacity_16(ctlr_info_t *h, int logvol,\r\nsector_t *total_size, unsigned int *block_size)\r\n{\r\nReadCapdata_struct_16 *buf;\r\nint return_code;\r\nunsigned char scsi3addr[8];\r\nbuf = kzalloc(sizeof(ReadCapdata_struct_16), GFP_KERNEL);\r\nif (!buf) {\r\ndev_warn(&h->pdev->dev, "out of memory\n");\r\nreturn;\r\n}\r\nlog_unit_to_scsi3addr(h, scsi3addr, logvol);\r\nreturn_code = sendcmd_withirq(h, CCISS_READ_CAPACITY_16,\r\nbuf, sizeof(ReadCapdata_struct_16),\r\n0, scsi3addr, TYPE_CMD);\r\nif (return_code == IO_OK) {\r\n*total_size = be64_to_cpu(*(__be64 *) buf->total_size);\r\n*block_size = be32_to_cpu(*(__be32 *) buf->block_size);\r\n} else {\r\ndev_warn(&h->pdev->dev, "read capacity failed\n");\r\n*total_size = 0;\r\n*block_size = BLOCK_SIZE;\r\n}\r\ndev_info(&h->pdev->dev, " blocks= %llu block_size= %d\n",\r\n(unsigned long long)*total_size+1, *block_size);\r\nkfree(buf);\r\n}\r\nstatic int cciss_revalidate(struct gendisk *disk)\r\n{\r\nctlr_info_t *h = get_host(disk);\r\ndrive_info_struct *drv = get_drv(disk);\r\nint logvol;\r\nint FOUND = 0;\r\nunsigned int block_size;\r\nsector_t total_size;\r\nInquiryData_struct *inq_buff = NULL;\r\nfor (logvol = 0; logvol <= h->highest_lun; logvol++) {\r\nif (!h->drv[logvol])\r\ncontinue;\r\nif (memcmp(h->drv[logvol]->LunID, drv->LunID,\r\nsizeof(drv->LunID)) == 0) {\r\nFOUND = 1;\r\nbreak;\r\n}\r\n}\r\nif (!FOUND)\r\nreturn 1;\r\ninq_buff = kmalloc(sizeof(InquiryData_struct), GFP_KERNEL);\r\nif (inq_buff == NULL) {\r\ndev_warn(&h->pdev->dev, "out of memory\n");\r\nreturn 1;\r\n}\r\nif (h->cciss_read == CCISS_READ_10) {\r\ncciss_read_capacity(h, logvol,\r\n&total_size, &block_size);\r\n} else {\r\ncciss_read_capacity_16(h, logvol,\r\n&total_size, &block_size);\r\n}\r\ncciss_geometry_inquiry(h, logvol, total_size, block_size,\r\ninq_buff, drv);\r\nblk_queue_logical_block_size(drv->queue, drv->block_size);\r\nset_capacity(disk, drv->nr_blocks);\r\nkfree(inq_buff);\r\nreturn 0;\r\n}\r\nstatic void __iomem *remap_pci_mem(ulong base, ulong size)\r\n{\r\nulong page_base = ((ulong) base) & PAGE_MASK;\r\nulong page_offs = ((ulong) base) - page_base;\r\nvoid __iomem *page_remapped = ioremap(page_base, page_offs + size);\r\nreturn page_remapped ? (page_remapped + page_offs) : NULL;\r\n}\r\nstatic void start_io(ctlr_info_t *h)\r\n{\r\nCommandList_struct *c;\r\nwhile (!list_empty(&h->reqQ)) {\r\nc = list_entry(h->reqQ.next, CommandList_struct, list);\r\nif ((h->access.fifo_full(h))) {\r\ndev_warn(&h->pdev->dev, "fifo full\n");\r\nbreak;\r\n}\r\nremoveQ(c);\r\nh->Qdepth--;\r\nh->access.submit_command(h, c);\r\naddQ(&h->cmpQ, c);\r\n}\r\n}\r\nstatic inline void resend_cciss_cmd(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nmemset(c->err_info, 0, sizeof(ErrorInfo_struct));\r\naddQ(&h->reqQ, c);\r\nh->Qdepth++;\r\nif (h->Qdepth > h->maxQsinceinit)\r\nh->maxQsinceinit = h->Qdepth;\r\nstart_io(h);\r\n}\r\nstatic inline unsigned int make_status_bytes(unsigned int scsi_status_byte,\r\nunsigned int msg_byte, unsigned int host_byte,\r\nunsigned int driver_byte)\r\n{\r\nreturn (scsi_status_byte & 0xff) |\r\n((msg_byte & 0xff) << 8) |\r\n((host_byte & 0xff) << 16) |\r\n((driver_byte & 0xff) << 24);\r\n}\r\nstatic inline int evaluate_target_status(ctlr_info_t *h,\r\nCommandList_struct *cmd, int *retry_cmd)\r\n{\r\nunsigned char sense_key;\r\nunsigned char status_byte, msg_byte, host_byte, driver_byte;\r\nint error_value;\r\n*retry_cmd = 0;\r\nstatus_byte = cmd->err_info->ScsiStatus;\r\ndriver_byte = DRIVER_OK;\r\nmsg_byte = cmd->err_info->CommandStatus;\r\nif (cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC)\r\nhost_byte = DID_PASSTHROUGH;\r\nelse\r\nhost_byte = DID_OK;\r\nerror_value = make_status_bytes(status_byte, msg_byte,\r\nhost_byte, driver_byte);\r\nif (cmd->err_info->ScsiStatus != SAM_STAT_CHECK_CONDITION) {\r\nif (cmd->rq->cmd_type != REQ_TYPE_BLOCK_PC)\r\ndev_warn(&h->pdev->dev, "cmd %p "\r\n"has SCSI Status 0x%x\n",\r\ncmd, cmd->err_info->ScsiStatus);\r\nreturn error_value;\r\n}\r\nsense_key = 0xf & cmd->err_info->SenseInfo[2];\r\nif (((sense_key == 0x0) || (sense_key == 0x1)) &&\r\n(cmd->rq->cmd_type != REQ_TYPE_BLOCK_PC))\r\nerror_value = 0;\r\nif (check_for_unit_attention(h, cmd)) {\r\n*retry_cmd = !(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC);\r\nreturn 0;\r\n}\r\nif (cmd->rq->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nif (error_value != 0)\r\ndev_warn(&h->pdev->dev, "cmd %p has CHECK CONDITION"\r\n" sense key = 0x%x\n", cmd, sense_key);\r\nreturn error_value;\r\n}\r\nif (cmd->rq->sense) {\r\nif (cmd->rq->sense_len > cmd->err_info->SenseLen)\r\ncmd->rq->sense_len = cmd->err_info->SenseLen;\r\nmemcpy(cmd->rq->sense, cmd->err_info->SenseInfo,\r\ncmd->rq->sense_len);\r\n} else\r\ncmd->rq->sense_len = 0;\r\nreturn error_value;\r\n}\r\nstatic inline void complete_command(ctlr_info_t *h, CommandList_struct *cmd,\r\nint timeout)\r\n{\r\nint retry_cmd = 0;\r\nstruct request *rq = cmd->rq;\r\nrq->errors = 0;\r\nif (timeout)\r\nrq->errors = make_status_bytes(0, 0, 0, DRIVER_TIMEOUT);\r\nif (cmd->err_info->CommandStatus == 0)\r\ngoto after_error_processing;\r\nswitch (cmd->err_info->CommandStatus) {\r\ncase CMD_TARGET_STATUS:\r\nrq->errors = evaluate_target_status(h, cmd, &retry_cmd);\r\nbreak;\r\ncase CMD_DATA_UNDERRUN:\r\nif (cmd->rq->cmd_type == REQ_TYPE_FS) {\r\ndev_warn(&h->pdev->dev, "cmd %p has"\r\n" completed with data underrun "\r\n"reported\n", cmd);\r\ncmd->rq->resid_len = cmd->err_info->ResidualCnt;\r\n}\r\nbreak;\r\ncase CMD_DATA_OVERRUN:\r\nif (cmd->rq->cmd_type == REQ_TYPE_FS)\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p has"\r\n" completed with data overrun "\r\n"reported\n", cmd);\r\nbreak;\r\ncase CMD_INVALID:\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p is "\r\n"reported invalid\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ncase CMD_PROTOCOL_ERR:\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p has "\r\n"protocol error\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ncase CMD_HARDWARE_ERR:\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p had "\r\n" hardware error\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ncase CMD_CONNECTION_LOST:\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p had "\r\n"connection lost\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ncase CMD_ABORTED:\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p was "\r\n"aborted\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ABORT);\r\nbreak;\r\ncase CMD_ABORT_FAILED:\r\ndev_warn(&h->pdev->dev, "cciss: cmd %p reports "\r\n"abort failed\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ncase CMD_UNSOLICITED_ABORT:\r\ndev_warn(&h->pdev->dev, "cciss%d: unsolicited "\r\n"abort %p\n", h->ctlr, cmd);\r\nif (cmd->retry_count < MAX_CMD_RETRIES) {\r\nretry_cmd = 1;\r\ndev_warn(&h->pdev->dev, "retrying %p\n", cmd);\r\ncmd->retry_count++;\r\n} else\r\ndev_warn(&h->pdev->dev,\r\n"%p retried too many times\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ABORT);\r\nbreak;\r\ncase CMD_TIMEOUT:\r\ndev_warn(&h->pdev->dev, "cmd %p timedout\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ncase CMD_UNABORTABLE:\r\ndev_warn(&h->pdev->dev, "cmd %p unabortable\n", cmd);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\ncmd->rq->cmd_type == REQ_TYPE_BLOCK_PC ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev, "cmd %p returned "\r\n"unknown status %x\n", cmd,\r\ncmd->err_info->CommandStatus);\r\nrq->errors = make_status_bytes(SAM_STAT_GOOD,\r\ncmd->err_info->CommandStatus, DRIVER_OK,\r\n(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?\r\nDID_PASSTHROUGH : DID_ERROR);\r\n}\r\nafter_error_processing:\r\nif (retry_cmd) {\r\nresend_cciss_cmd(h, cmd);\r\nreturn;\r\n}\r\ncmd->rq->completion_data = cmd;\r\nblk_complete_request(cmd->rq);\r\n}\r\nstatic inline u32 cciss_tag_contains_index(u32 tag)\r\n{\r\n#define DIRECT_LOOKUP_BIT 0x10\r\nreturn tag & DIRECT_LOOKUP_BIT;\r\n}\r\nstatic inline u32 cciss_tag_to_index(u32 tag)\r\n{\r\n#define DIRECT_LOOKUP_SHIFT 5\r\nreturn tag >> DIRECT_LOOKUP_SHIFT;\r\n}\r\nstatic inline u32 cciss_tag_discard_error_bits(ctlr_info_t *h, u32 tag)\r\n{\r\n#define CCISS_PERF_ERROR_BITS ((1 << DIRECT_LOOKUP_SHIFT) - 1)\r\n#define CCISS_SIMPLE_ERROR_BITS 0x03\r\nif (likely(h->transMethod & CFGTBL_Trans_Performant))\r\nreturn tag & ~CCISS_PERF_ERROR_BITS;\r\nreturn tag & ~CCISS_SIMPLE_ERROR_BITS;\r\n}\r\nstatic inline void cciss_mark_tag_indexed(u32 *tag)\r\n{\r\n*tag |= DIRECT_LOOKUP_BIT;\r\n}\r\nstatic inline void cciss_set_tag_index(u32 *tag, u32 index)\r\n{\r\n*tag |= (index << DIRECT_LOOKUP_SHIFT);\r\n}\r\nstatic void do_cciss_request(struct request_queue *q)\r\n{\r\nctlr_info_t *h = q->queuedata;\r\nCommandList_struct *c;\r\nsector_t start_blk;\r\nint seg;\r\nstruct request *creq;\r\nu64bit temp64;\r\nstruct scatterlist *tmp_sg;\r\nSGDescriptor_struct *curr_sg;\r\ndrive_info_struct *drv;\r\nint i, dir;\r\nint sg_index = 0;\r\nint chained = 0;\r\nqueue:\r\ncreq = blk_peek_request(q);\r\nif (!creq)\r\ngoto startio;\r\nBUG_ON(creq->nr_phys_segments > h->maxsgentries);\r\nc = cmd_alloc(h);\r\nif (!c)\r\ngoto full;\r\nblk_start_request(creq);\r\ntmp_sg = h->scatter_list[c->cmdindex];\r\nspin_unlock_irq(q->queue_lock);\r\nc->cmd_type = CMD_RWREQ;\r\nc->rq = creq;\r\ndrv = creq->rq_disk->private_data;\r\nc->Header.ReplyQueue = 0;\r\ncciss_set_tag_index(&c->Header.Tag.lower, c->cmdindex);\r\ncciss_mark_tag_indexed(&c->Header.Tag.lower);\r\nmemcpy(&c->Header.LUN, drv->LunID, sizeof(drv->LunID));\r\nc->Request.CDBLen = 10;\r\nc->Request.Type.Type = TYPE_CMD;\r\nc->Request.Type.Attribute = ATTR_SIMPLE;\r\nc->Request.Type.Direction =\r\n(rq_data_dir(creq) == READ) ? XFER_READ : XFER_WRITE;\r\nc->Request.Timeout = 0;\r\nc->Request.CDB[0] =\r\n(rq_data_dir(creq) == READ) ? h->cciss_read : h->cciss_write;\r\nstart_blk = blk_rq_pos(creq);\r\ndev_dbg(&h->pdev->dev, "sector =%d nr_sectors=%d\n",\r\n(int)blk_rq_pos(creq), (int)blk_rq_sectors(creq));\r\nsg_init_table(tmp_sg, h->maxsgentries);\r\nseg = blk_rq_map_sg(q, creq, tmp_sg);\r\nif (c->Request.Type.Direction == XFER_READ)\r\ndir = PCI_DMA_FROMDEVICE;\r\nelse\r\ndir = PCI_DMA_TODEVICE;\r\ncurr_sg = c->SG;\r\nsg_index = 0;\r\nchained = 0;\r\nfor (i = 0; i < seg; i++) {\r\nif (((sg_index+1) == (h->max_cmd_sgentries)) &&\r\n!chained && ((seg - i) > 1)) {\r\ncurr_sg = h->cmd_sg_list[c->cmdindex];\r\nsg_index = 0;\r\nchained = 1;\r\n}\r\ncurr_sg[sg_index].Len = tmp_sg[i].length;\r\ntemp64.val = (__u64) pci_map_page(h->pdev, sg_page(&tmp_sg[i]),\r\ntmp_sg[i].offset,\r\ntmp_sg[i].length, dir);\r\ncurr_sg[sg_index].Addr.lower = temp64.val32.lower;\r\ncurr_sg[sg_index].Addr.upper = temp64.val32.upper;\r\ncurr_sg[sg_index].Ext = 0;\r\n++sg_index;\r\n}\r\nif (chained)\r\ncciss_map_sg_chain_block(h, c, h->cmd_sg_list[c->cmdindex],\r\n(seg - (h->max_cmd_sgentries - 1)) *\r\nsizeof(SGDescriptor_struct));\r\nif (seg > h->maxSG)\r\nh->maxSG = seg;\r\ndev_dbg(&h->pdev->dev, "Submitting %u sectors in %d segments "\r\n"chained[%d]\n",\r\nblk_rq_sectors(creq), seg, chained);\r\nc->Header.SGTotal = seg + chained;\r\nif (seg <= h->max_cmd_sgentries)\r\nc->Header.SGList = c->Header.SGTotal;\r\nelse\r\nc->Header.SGList = h->max_cmd_sgentries;\r\nset_performant_mode(h, c);\r\nif (likely(creq->cmd_type == REQ_TYPE_FS)) {\r\nif(h->cciss_read == CCISS_READ_10) {\r\nc->Request.CDB[1] = 0;\r\nc->Request.CDB[2] = (start_blk >> 24) & 0xff;\r\nc->Request.CDB[3] = (start_blk >> 16) & 0xff;\r\nc->Request.CDB[4] = (start_blk >> 8) & 0xff;\r\nc->Request.CDB[5] = start_blk & 0xff;\r\nc->Request.CDB[6] = 0;\r\nc->Request.CDB[7] = (blk_rq_sectors(creq) >> 8) & 0xff;\r\nc->Request.CDB[8] = blk_rq_sectors(creq) & 0xff;\r\nc->Request.CDB[9] = c->Request.CDB[11] = c->Request.CDB[12] = 0;\r\n} else {\r\nu32 upper32 = upper_32_bits(start_blk);\r\nc->Request.CDBLen = 16;\r\nc->Request.CDB[1]= 0;\r\nc->Request.CDB[2]= (upper32 >> 24) & 0xff;\r\nc->Request.CDB[3]= (upper32 >> 16) & 0xff;\r\nc->Request.CDB[4]= (upper32 >> 8) & 0xff;\r\nc->Request.CDB[5]= upper32 & 0xff;\r\nc->Request.CDB[6]= (start_blk >> 24) & 0xff;\r\nc->Request.CDB[7]= (start_blk >> 16) & 0xff;\r\nc->Request.CDB[8]= (start_blk >> 8) & 0xff;\r\nc->Request.CDB[9]= start_blk & 0xff;\r\nc->Request.CDB[10]= (blk_rq_sectors(creq) >> 24) & 0xff;\r\nc->Request.CDB[11]= (blk_rq_sectors(creq) >> 16) & 0xff;\r\nc->Request.CDB[12]= (blk_rq_sectors(creq) >> 8) & 0xff;\r\nc->Request.CDB[13]= blk_rq_sectors(creq) & 0xff;\r\nc->Request.CDB[14] = c->Request.CDB[15] = 0;\r\n}\r\n} else if (creq->cmd_type == REQ_TYPE_BLOCK_PC) {\r\nc->Request.CDBLen = creq->cmd_len;\r\nmemcpy(c->Request.CDB, creq->cmd, BLK_MAX_CDB);\r\n} else {\r\ndev_warn(&h->pdev->dev, "bad request type %d\n",\r\ncreq->cmd_type);\r\nBUG();\r\n}\r\nspin_lock_irq(q->queue_lock);\r\naddQ(&h->reqQ, c);\r\nh->Qdepth++;\r\nif (h->Qdepth > h->maxQsinceinit)\r\nh->maxQsinceinit = h->Qdepth;\r\ngoto queue;\r\nfull:\r\nblk_stop_queue(q);\r\nstartio:\r\nstart_io(h);\r\n}\r\nstatic inline unsigned long get_next_completion(ctlr_info_t *h)\r\n{\r\nreturn h->access.command_completed(h);\r\n}\r\nstatic inline int interrupt_pending(ctlr_info_t *h)\r\n{\r\nreturn h->access.intr_pending(h);\r\n}\r\nstatic inline long interrupt_not_for_us(ctlr_info_t *h)\r\n{\r\nreturn ((h->access.intr_pending(h) == 0) ||\r\n(h->interrupts_enabled == 0));\r\n}\r\nstatic inline int bad_tag(ctlr_info_t *h, u32 tag_index,\r\nu32 raw_tag)\r\n{\r\nif (unlikely(tag_index >= h->nr_cmds)) {\r\ndev_warn(&h->pdev->dev, "bad tag 0x%08x ignored.\n", raw_tag);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void finish_cmd(ctlr_info_t *h, CommandList_struct *c,\r\nu32 raw_tag)\r\n{\r\nremoveQ(c);\r\nif (likely(c->cmd_type == CMD_RWREQ))\r\ncomplete_command(h, c, 0);\r\nelse if (c->cmd_type == CMD_IOCTL_PEND)\r\ncomplete(c->waiting);\r\n#ifdef CONFIG_CISS_SCSI_TAPE\r\nelse if (c->cmd_type == CMD_SCSI)\r\ncomplete_scsi_command(c, 0, raw_tag);\r\n#endif\r\n}\r\nstatic inline u32 next_command(ctlr_info_t *h)\r\n{\r\nu32 a;\r\nif (unlikely(!(h->transMethod & CFGTBL_Trans_Performant)))\r\nreturn h->access.command_completed(h);\r\nif ((*(h->reply_pool_head) & 1) == (h->reply_pool_wraparound)) {\r\na = *(h->reply_pool_head);\r\n(h->reply_pool_head)++;\r\nh->commands_outstanding--;\r\n} else {\r\na = FIFO_EMPTY;\r\n}\r\nif (h->reply_pool_head == (h->reply_pool + h->max_commands)) {\r\nh->reply_pool_head = h->reply_pool;\r\nh->reply_pool_wraparound ^= 1;\r\n}\r\nreturn a;\r\n}\r\nstatic inline u32 process_indexed_cmd(ctlr_info_t *h, u32 raw_tag)\r\n{\r\nu32 tag_index;\r\nCommandList_struct *c;\r\ntag_index = cciss_tag_to_index(raw_tag);\r\nif (bad_tag(h, tag_index, raw_tag))\r\nreturn next_command(h);\r\nc = h->cmd_pool + tag_index;\r\nfinish_cmd(h, c, raw_tag);\r\nreturn next_command(h);\r\n}\r\nstatic inline u32 process_nonindexed_cmd(ctlr_info_t *h, u32 raw_tag)\r\n{\r\nCommandList_struct *c = NULL;\r\n__u32 busaddr_masked, tag_masked;\r\ntag_masked = cciss_tag_discard_error_bits(h, raw_tag);\r\nlist_for_each_entry(c, &h->cmpQ, list) {\r\nbusaddr_masked = cciss_tag_discard_error_bits(h, c->busaddr);\r\nif (busaddr_masked == tag_masked) {\r\nfinish_cmd(h, c, raw_tag);\r\nreturn next_command(h);\r\n}\r\n}\r\nbad_tag(h, h->nr_cmds + 1, raw_tag);\r\nreturn next_command(h);\r\n}\r\nstatic int ignore_bogus_interrupt(ctlr_info_t *h)\r\n{\r\nif (likely(!reset_devices))\r\nreturn 0;\r\nif (likely(h->interrupts_enabled))\r\nreturn 0;\r\ndev_info(&h->pdev->dev, "Received interrupt while interrupts disabled "\r\n"(known firmware bug.) Ignoring.\n");\r\nreturn 1;\r\n}\r\nstatic irqreturn_t cciss_intx_discard_completions(int irq, void *dev_id)\r\n{\r\nctlr_info_t *h = dev_id;\r\nunsigned long flags;\r\nu32 raw_tag;\r\nif (ignore_bogus_interrupt(h))\r\nreturn IRQ_NONE;\r\nif (interrupt_not_for_us(h))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&h->lock, flags);\r\nwhile (interrupt_pending(h)) {\r\nraw_tag = get_next_completion(h);\r\nwhile (raw_tag != FIFO_EMPTY)\r\nraw_tag = next_command(h);\r\n}\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t cciss_msix_discard_completions(int irq, void *dev_id)\r\n{\r\nctlr_info_t *h = dev_id;\r\nunsigned long flags;\r\nu32 raw_tag;\r\nif (ignore_bogus_interrupt(h))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&h->lock, flags);\r\nraw_tag = get_next_completion(h);\r\nwhile (raw_tag != FIFO_EMPTY)\r\nraw_tag = next_command(h);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t do_cciss_intx(int irq, void *dev_id)\r\n{\r\nctlr_info_t *h = dev_id;\r\nunsigned long flags;\r\nu32 raw_tag;\r\nif (interrupt_not_for_us(h))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&h->lock, flags);\r\nwhile (interrupt_pending(h)) {\r\nraw_tag = get_next_completion(h);\r\nwhile (raw_tag != FIFO_EMPTY) {\r\nif (cciss_tag_contains_index(raw_tag))\r\nraw_tag = process_indexed_cmd(h, raw_tag);\r\nelse\r\nraw_tag = process_nonindexed_cmd(h, raw_tag);\r\n}\r\n}\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t do_cciss_msix_intr(int irq, void *dev_id)\r\n{\r\nctlr_info_t *h = dev_id;\r\nunsigned long flags;\r\nu32 raw_tag;\r\nspin_lock_irqsave(&h->lock, flags);\r\nraw_tag = get_next_completion(h);\r\nwhile (raw_tag != FIFO_EMPTY) {\r\nif (cciss_tag_contains_index(raw_tag))\r\nraw_tag = process_indexed_cmd(h, raw_tag);\r\nelse\r\nraw_tag = process_nonindexed_cmd(h, raw_tag);\r\n}\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int add_to_scan_list(struct ctlr_info *h)\r\n{\r\nstruct ctlr_info *test_h;\r\nint found = 0;\r\nint ret = 0;\r\nif (h->busy_initializing)\r\nreturn 0;\r\nif (!mutex_trylock(&h->busy_shutting_down))\r\nreturn 0;\r\nmutex_lock(&scan_mutex);\r\nlist_for_each_entry(test_h, &scan_q, scan_list) {\r\nif (test_h == h) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found && !h->busy_scanning) {\r\nINIT_COMPLETION(h->scan_wait);\r\nlist_add_tail(&h->scan_list, &scan_q);\r\nret = 1;\r\n}\r\nmutex_unlock(&scan_mutex);\r\nmutex_unlock(&h->busy_shutting_down);\r\nreturn ret;\r\n}\r\nstatic void remove_from_scan_list(struct ctlr_info *h)\r\n{\r\nstruct ctlr_info *test_h, *tmp_h;\r\nmutex_lock(&scan_mutex);\r\nlist_for_each_entry_safe(test_h, tmp_h, &scan_q, scan_list) {\r\nif (test_h == h) {\r\nlist_del(&h->scan_list);\r\ncomplete_all(&h->scan_wait);\r\nmutex_unlock(&scan_mutex);\r\nreturn;\r\n}\r\n}\r\nif (h->busy_scanning) {\r\nmutex_unlock(&scan_mutex);\r\nwait_for_completion(&h->scan_wait);\r\n} else {\r\nmutex_unlock(&scan_mutex);\r\n}\r\n}\r\nstatic int scan_thread(void *data)\r\n{\r\nstruct ctlr_info *h;\r\nwhile (1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\nif (kthread_should_stop())\r\nbreak;\r\nwhile (1) {\r\nmutex_lock(&scan_mutex);\r\nif (list_empty(&scan_q)) {\r\nmutex_unlock(&scan_mutex);\r\nbreak;\r\n}\r\nh = list_entry(scan_q.next,\r\nstruct ctlr_info,\r\nscan_list);\r\nlist_del(&h->scan_list);\r\nh->busy_scanning = 1;\r\nmutex_unlock(&scan_mutex);\r\nrebuild_lun_table(h, 0, 0);\r\ncomplete_all(&h->scan_wait);\r\nmutex_lock(&scan_mutex);\r\nh->busy_scanning = 0;\r\nmutex_unlock(&scan_mutex);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c)\r\n{\r\nif (c->err_info->SenseInfo[2] != UNIT_ATTENTION)\r\nreturn 0;\r\nswitch (c->err_info->SenseInfo[12]) {\r\ncase STATE_CHANGED:\r\ndev_warn(&h->pdev->dev, "a state change "\r\n"detected, command retried\n");\r\nreturn 1;\r\nbreak;\r\ncase LUN_FAILED:\r\ndev_warn(&h->pdev->dev, "LUN failure "\r\n"detected, action required\n");\r\nreturn 1;\r\nbreak;\r\ncase REPORT_LUNS_CHANGED:\r\ndev_warn(&h->pdev->dev, "report LUN data changed\n");\r\nreturn 1;\r\nbreak;\r\ncase POWER_OR_RESET:\r\ndev_warn(&h->pdev->dev,\r\n"a power on or device reset detected\n");\r\nreturn 1;\r\nbreak;\r\ncase UNIT_ATTENTION_CLEARED:\r\ndev_warn(&h->pdev->dev,\r\n"unit attention cleared by another initiator\n");\r\nreturn 1;\r\nbreak;\r\ndefault:\r\ndev_warn(&h->pdev->dev, "unknown unit attention detected\n");\r\nreturn 1;\r\n}\r\n}\r\nstatic void print_cfg_table(ctlr_info_t *h)\r\n{\r\nint i;\r\nchar temp_name[17];\r\nCfgTable_struct *tb = h->cfgtable;\r\ndev_dbg(&h->pdev->dev, "Controller Configuration information\n");\r\ndev_dbg(&h->pdev->dev, "------------------------------------\n");\r\nfor (i = 0; i < 4; i++)\r\ntemp_name[i] = readb(&(tb->Signature[i]));\r\ntemp_name[4] = '\0';\r\ndev_dbg(&h->pdev->dev, " Signature = %s\n", temp_name);\r\ndev_dbg(&h->pdev->dev, " Spec Number = %d\n",\r\nreadl(&(tb->SpecValence)));\r\ndev_dbg(&h->pdev->dev, " Transport methods supported = 0x%x\n",\r\nreadl(&(tb->TransportSupport)));\r\ndev_dbg(&h->pdev->dev, " Transport methods active = 0x%x\n",\r\nreadl(&(tb->TransportActive)));\r\ndev_dbg(&h->pdev->dev, " Requested transport Method = 0x%x\n",\r\nreadl(&(tb->HostWrite.TransportRequest)));\r\ndev_dbg(&h->pdev->dev, " Coalesce Interrupt Delay = 0x%x\n",\r\nreadl(&(tb->HostWrite.CoalIntDelay)));\r\ndev_dbg(&h->pdev->dev, " Coalesce Interrupt Count = 0x%x\n",\r\nreadl(&(tb->HostWrite.CoalIntCount)));\r\ndev_dbg(&h->pdev->dev, " Max outstanding commands = 0x%d\n",\r\nreadl(&(tb->CmdsOutMax)));\r\ndev_dbg(&h->pdev->dev, " Bus Types = 0x%x\n",\r\nreadl(&(tb->BusTypes)));\r\nfor (i = 0; i < 16; i++)\r\ntemp_name[i] = readb(&(tb->ServerName[i]));\r\ntemp_name[16] = '\0';\r\ndev_dbg(&h->pdev->dev, " Server Name = %s\n", temp_name);\r\ndev_dbg(&h->pdev->dev, " Heartbeat Counter = 0x%x\n\n\n",\r\nreadl(&(tb->HeartBeat)));\r\n}\r\nstatic int find_PCI_BAR_index(struct pci_dev *pdev, unsigned long pci_bar_addr)\r\n{\r\nint i, offset, mem_type, bar_type;\r\nif (pci_bar_addr == PCI_BASE_ADDRESS_0)\r\nreturn 0;\r\noffset = 0;\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nbar_type = pci_resource_flags(pdev, i) & PCI_BASE_ADDRESS_SPACE;\r\nif (bar_type == PCI_BASE_ADDRESS_SPACE_IO)\r\noffset += 4;\r\nelse {\r\nmem_type = pci_resource_flags(pdev, i) &\r\nPCI_BASE_ADDRESS_MEM_TYPE_MASK;\r\nswitch (mem_type) {\r\ncase PCI_BASE_ADDRESS_MEM_TYPE_32:\r\ncase PCI_BASE_ADDRESS_MEM_TYPE_1M:\r\noffset += 4;\r\nbreak;\r\ncase PCI_BASE_ADDRESS_MEM_TYPE_64:\r\noffset += 8;\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev,\r\n"Base address is invalid\n");\r\nreturn -1;\r\nbreak;\r\n}\r\n}\r\nif (offset == pci_bar_addr - PCI_BASE_ADDRESS_0)\r\nreturn i + 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic void calc_bucket_map(int bucket[], int num_buckets,\r\nint nsgs, int *bucket_map)\r\n{\r\nint i, j, b, size;\r\n#define MINIMUM_TRANSFER_BLOCKS 4\r\n#define NUM_BUCKETS 8\r\nfor (i = 0; i <= nsgs; i++) {\r\nsize = i + MINIMUM_TRANSFER_BLOCKS;\r\nb = num_buckets;\r\nfor (j = 0; j < 8; j++) {\r\nif (bucket[j] >= size) {\r\nb = j;\r\nbreak;\r\n}\r\n}\r\nbucket_map[i] = b;\r\n}\r\n}\r\nstatic void cciss_wait_for_mode_change_ack(ctlr_info_t *h)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CONFIG_WAIT; i++) {\r\nif (!(readl(h->vaddr + SA5_DOORBELL) & CFGTBL_ChangeReq))\r\nbreak;\r\nusleep_range(10000, 20000);\r\n}\r\n}\r\nstatic void cciss_enter_performant_mode(ctlr_info_t *h, u32 use_short_tags)\r\n{\r\n__u32 trans_offset;\r\nint bft[8] = { 5, 6, 8, 10, 12, 20, 28, MAXSGENTRIES + 4};\r\nunsigned long register_value;\r\nBUILD_BUG_ON(28 > MAXSGENTRIES + 4);\r\nh->reply_pool_wraparound = 1;\r\nmemset(h->reply_pool, 0, h->max_commands * sizeof(__u64));\r\nh->reply_pool_head = h->reply_pool;\r\ntrans_offset = readl(&(h->cfgtable->TransMethodOffset));\r\ncalc_bucket_map(bft, ARRAY_SIZE(bft), h->maxsgentries,\r\nh->blockFetchTable);\r\nwritel(bft[0], &h->transtable->BlockFetch0);\r\nwritel(bft[1], &h->transtable->BlockFetch1);\r\nwritel(bft[2], &h->transtable->BlockFetch2);\r\nwritel(bft[3], &h->transtable->BlockFetch3);\r\nwritel(bft[4], &h->transtable->BlockFetch4);\r\nwritel(bft[5], &h->transtable->BlockFetch5);\r\nwritel(bft[6], &h->transtable->BlockFetch6);\r\nwritel(bft[7], &h->transtable->BlockFetch7);\r\nwritel(h->max_commands, &h->transtable->RepQSize);\r\nwritel(1, &h->transtable->RepQCount);\r\nwritel(0, &h->transtable->RepQCtrAddrLow32);\r\nwritel(0, &h->transtable->RepQCtrAddrHigh32);\r\nwritel(h->reply_pool_dhandle, &h->transtable->RepQAddr0Low32);\r\nwritel(0, &h->transtable->RepQAddr0High32);\r\nwritel(CFGTBL_Trans_Performant | use_short_tags,\r\n&(h->cfgtable->HostWrite.TransportRequest));\r\nwritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\r\ncciss_wait_for_mode_change_ack(h);\r\nregister_value = readl(&(h->cfgtable->TransportActive));\r\nif (!(register_value & CFGTBL_Trans_Performant))\r\ndev_warn(&h->pdev->dev, "cciss: unable to get board into"\r\n" performant mode\n");\r\n}\r\nstatic void cciss_put_controller_into_performant_mode(ctlr_info_t *h)\r\n{\r\n__u32 trans_support;\r\nif (cciss_simple_mode)\r\nreturn;\r\ndev_dbg(&h->pdev->dev, "Trying to put board into Performant mode\n");\r\ntrans_support = readl(&(h->cfgtable->TransportSupport));\r\nif (!(trans_support & PERFORMANT_MODE))\r\nreturn;\r\ndev_dbg(&h->pdev->dev, "Placing controller into performant mode\n");\r\nif ((sizeof(CommandList_struct) % 32) != 0) {\r\ndev_warn(&h->pdev->dev, "%s %d %s\n",\r\n"cciss info: command size[",\r\n(int)sizeof(CommandList_struct),\r\n"] not divisible by 32, no performant mode..\n");\r\nreturn;\r\n}\r\nh->reply_pool = (__u64 *)pci_alloc_consistent(\r\nh->pdev, h->max_commands * sizeof(__u64),\r\n&(h->reply_pool_dhandle));\r\nh->blockFetchTable = kmalloc(((h->maxsgentries+1) *\r\nsizeof(__u32)), GFP_KERNEL);\r\nif ((h->reply_pool == NULL) || (h->blockFetchTable == NULL))\r\ngoto clean_up;\r\ncciss_enter_performant_mode(h,\r\ntrans_support & CFGTBL_Trans_use_short_tags);\r\nh->access = SA5_performant_access;\r\nh->transMethod = CFGTBL_Trans_Performant;\r\nreturn;\r\nclean_up:\r\nkfree(h->blockFetchTable);\r\nif (h->reply_pool)\r\npci_free_consistent(h->pdev,\r\nh->max_commands * sizeof(__u64),\r\nh->reply_pool,\r\nh->reply_pool_dhandle);\r\nreturn;\r\n}\r\nstatic void cciss_interrupt_mode(ctlr_info_t *h)\r\n{\r\n#ifdef CONFIG_PCI_MSI\r\nint err;\r\nstruct msix_entry cciss_msix_entries[4] = { {0, 0}, {0, 1},\r\n{0, 2}, {0, 3}\r\n};\r\nif ((h->board_id == 0x40700E11) || (h->board_id == 0x40800E11) ||\r\n(h->board_id == 0x40820E11) || (h->board_id == 0x40830E11))\r\ngoto default_int_mode;\r\nif (pci_find_capability(h->pdev, PCI_CAP_ID_MSIX)) {\r\nerr = pci_enable_msix(h->pdev, cciss_msix_entries, 4);\r\nif (!err) {\r\nh->intr[0] = cciss_msix_entries[0].vector;\r\nh->intr[1] = cciss_msix_entries[1].vector;\r\nh->intr[2] = cciss_msix_entries[2].vector;\r\nh->intr[3] = cciss_msix_entries[3].vector;\r\nh->msix_vector = 1;\r\nreturn;\r\n}\r\nif (err > 0) {\r\ndev_warn(&h->pdev->dev,\r\n"only %d MSI-X vectors available\n", err);\r\ngoto default_int_mode;\r\n} else {\r\ndev_warn(&h->pdev->dev,\r\n"MSI-X init failed %d\n", err);\r\ngoto default_int_mode;\r\n}\r\n}\r\nif (pci_find_capability(h->pdev, PCI_CAP_ID_MSI)) {\r\nif (!pci_enable_msi(h->pdev))\r\nh->msi_vector = 1;\r\nelse\r\ndev_warn(&h->pdev->dev, "MSI init failed\n");\r\n}\r\ndefault_int_mode:\r\n#endif\r\nh->intr[h->intr_mode] = h->pdev->irq;\r\nreturn;\r\n}\r\nstatic int cciss_lookup_board_id(struct pci_dev *pdev, u32 *board_id)\r\n{\r\nint i;\r\nu32 subsystem_vendor_id, subsystem_device_id;\r\nsubsystem_vendor_id = pdev->subsystem_vendor;\r\nsubsystem_device_id = pdev->subsystem_device;\r\n*board_id = ((subsystem_device_id << 16) & 0xffff0000) |\r\nsubsystem_vendor_id;\r\nfor (i = 0; i < ARRAY_SIZE(products); i++) {\r\nif (cciss_allow_hpsa)\r\nreturn -ENODEV;\r\nif (*board_id == products[i].board_id)\r\nreturn i;\r\n}\r\ndev_warn(&pdev->dev, "unrecognized board ID: 0x%08x, ignoring.\n",\r\n*board_id);\r\nreturn -ENODEV;\r\n}\r\nstatic inline bool cciss_board_disabled(ctlr_info_t *h)\r\n{\r\nu16 command;\r\n(void) pci_read_config_word(h->pdev, PCI_COMMAND, &command);\r\nreturn ((command & PCI_COMMAND_MEMORY) == 0);\r\n}\r\nstatic int cciss_pci_find_memory_BAR(struct pci_dev *pdev,\r\nunsigned long *memory_bar)\r\n{\r\nint i;\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++)\r\nif (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\r\n*memory_bar = pci_resource_start(pdev, i);\r\ndev_dbg(&pdev->dev, "memory BAR = %lx\n",\r\n*memory_bar);\r\nreturn 0;\r\n}\r\ndev_warn(&pdev->dev, "no memory BAR found\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int cciss_wait_for_board_state(struct pci_dev *pdev,\r\nvoid __iomem *vaddr, int wait_for_ready)\r\n#define BOARD_READY 1\r\n#define BOARD_NOT_READY 0\r\n{\r\nint i, iterations;\r\nu32 scratchpad;\r\nif (wait_for_ready)\r\niterations = CCISS_BOARD_READY_ITERATIONS;\r\nelse\r\niterations = CCISS_BOARD_NOT_READY_ITERATIONS;\r\nfor (i = 0; i < iterations; i++) {\r\nscratchpad = readl(vaddr + SA5_SCRATCHPAD_OFFSET);\r\nif (wait_for_ready) {\r\nif (scratchpad == CCISS_FIRMWARE_READY)\r\nreturn 0;\r\n} else {\r\nif (scratchpad != CCISS_FIRMWARE_READY)\r\nreturn 0;\r\n}\r\nmsleep(CCISS_BOARD_READY_POLL_INTERVAL_MSECS);\r\n}\r\ndev_warn(&pdev->dev, "board not ready, timed out.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int cciss_find_cfg_addrs(struct pci_dev *pdev, void __iomem *vaddr,\r\nu32 *cfg_base_addr, u64 *cfg_base_addr_index,\r\nu64 *cfg_offset)\r\n{\r\n*cfg_base_addr = readl(vaddr + SA5_CTCFG_OFFSET);\r\n*cfg_offset = readl(vaddr + SA5_CTMEM_OFFSET);\r\n*cfg_base_addr &= (u32) 0x0000ffff;\r\n*cfg_base_addr_index = find_PCI_BAR_index(pdev, *cfg_base_addr);\r\nif (*cfg_base_addr_index == -1) {\r\ndev_warn(&pdev->dev, "cannot find cfg_base_addr_index, "\r\n"*cfg_base_addr = 0x%08x\n", *cfg_base_addr);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cciss_find_cfgtables(ctlr_info_t *h)\r\n{\r\nu64 cfg_offset;\r\nu32 cfg_base_addr;\r\nu64 cfg_base_addr_index;\r\nu32 trans_offset;\r\nint rc;\r\nrc = cciss_find_cfg_addrs(h->pdev, h->vaddr, &cfg_base_addr,\r\n&cfg_base_addr_index, &cfg_offset);\r\nif (rc)\r\nreturn rc;\r\nh->cfgtable = remap_pci_mem(pci_resource_start(h->pdev,\r\ncfg_base_addr_index) + cfg_offset, sizeof(*h->cfgtable));\r\nif (!h->cfgtable)\r\nreturn -ENOMEM;\r\nrc = write_driver_ver_to_cfgtable(h->cfgtable);\r\nif (rc)\r\nreturn rc;\r\ntrans_offset = readl(&h->cfgtable->TransMethodOffset);\r\nh->transtable = remap_pci_mem(pci_resource_start(h->pdev,\r\ncfg_base_addr_index)+cfg_offset+trans_offset,\r\nsizeof(*h->transtable));\r\nif (!h->transtable)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void cciss_get_max_perf_mode_cmds(struct ctlr_info *h)\r\n{\r\nh->max_commands = readl(&(h->cfgtable->MaxPerformantModeCommands));\r\nif (reset_devices && h->max_commands > 32)\r\nh->max_commands = 32;\r\nif (h->max_commands < 16) {\r\ndev_warn(&h->pdev->dev, "Controller reports "\r\n"max supported commands of %d, an obvious lie. "\r\n"Using 16. Ensure that firmware is up to date.\n",\r\nh->max_commands);\r\nh->max_commands = 16;\r\n}\r\n}\r\nstatic void cciss_find_board_params(ctlr_info_t *h)\r\n{\r\ncciss_get_max_perf_mode_cmds(h);\r\nh->nr_cmds = h->max_commands - 4 - cciss_tape_cmds;\r\nh->maxsgentries = readl(&(h->cfgtable->MaxSGElements));\r\nh->max_cmd_sgentries = 31;\r\nif (h->maxsgentries > 512) {\r\nh->max_cmd_sgentries = 32;\r\nh->chainsize = h->maxsgentries - h->max_cmd_sgentries + 1;\r\nh->maxsgentries--;\r\n} else {\r\nh->maxsgentries = 31;\r\nh->chainsize = 0;\r\n}\r\n}\r\nstatic inline bool CISS_signature_present(ctlr_info_t *h)\r\n{\r\nif (!check_signature(h->cfgtable->Signature, "CISS", 4)) {\r\ndev_warn(&h->pdev->dev, "not a valid CISS config table\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic inline void cciss_enable_scsi_prefetch(ctlr_info_t *h)\r\n{\r\n#ifdef CONFIG_X86\r\nu32 prefetch;\r\nprefetch = readl(&(h->cfgtable->SCSI_Prefetch));\r\nprefetch |= 0x100;\r\nwritel(prefetch, &(h->cfgtable->SCSI_Prefetch));\r\n#endif\r\n}\r\nstatic inline void cciss_p600_dma_prefetch_quirk(ctlr_info_t *h)\r\n{\r\nu32 dma_prefetch;\r\n__u32 dma_refetch;\r\nif (h->board_id != 0x3225103C)\r\nreturn;\r\ndma_prefetch = readl(h->vaddr + I2O_DMA1_CFG);\r\ndma_prefetch |= 0x8000;\r\nwritel(dma_prefetch, h->vaddr + I2O_DMA1_CFG);\r\npci_read_config_dword(h->pdev, PCI_COMMAND_PARITY, &dma_refetch);\r\ndma_refetch |= 0x1;\r\npci_write_config_dword(h->pdev, PCI_COMMAND_PARITY, dma_refetch);\r\n}\r\nstatic int cciss_pci_init(ctlr_info_t *h)\r\n{\r\nint prod_index, err;\r\nprod_index = cciss_lookup_board_id(h->pdev, &h->board_id);\r\nif (prod_index < 0)\r\nreturn -ENODEV;\r\nh->product_name = products[prod_index].product_name;\r\nh->access = *(products[prod_index].access);\r\nif (cciss_board_disabled(h)) {\r\ndev_warn(&h->pdev->dev, "controller appears to be disabled\n");\r\nreturn -ENODEV;\r\n}\r\npci_disable_link_state(h->pdev, PCIE_LINK_STATE_L0S |\r\nPCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM);\r\nerr = pci_enable_device(h->pdev);\r\nif (err) {\r\ndev_warn(&h->pdev->dev, "Unable to Enable PCI device\n");\r\nreturn err;\r\n}\r\nerr = pci_request_regions(h->pdev, "cciss");\r\nif (err) {\r\ndev_warn(&h->pdev->dev,\r\n"Cannot obtain PCI resources, aborting\n");\r\nreturn err;\r\n}\r\ndev_dbg(&h->pdev->dev, "irq = %x\n", h->pdev->irq);\r\ndev_dbg(&h->pdev->dev, "board_id = %x\n", h->board_id);\r\ncciss_interrupt_mode(h);\r\nerr = cciss_pci_find_memory_BAR(h->pdev, &h->paddr);\r\nif (err)\r\ngoto err_out_free_res;\r\nh->vaddr = remap_pci_mem(h->paddr, 0x250);\r\nif (!h->vaddr) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_res;\r\n}\r\nerr = cciss_wait_for_board_state(h->pdev, h->vaddr, BOARD_READY);\r\nif (err)\r\ngoto err_out_free_res;\r\nerr = cciss_find_cfgtables(h);\r\nif (err)\r\ngoto err_out_free_res;\r\nprint_cfg_table(h);\r\ncciss_find_board_params(h);\r\nif (!CISS_signature_present(h)) {\r\nerr = -ENODEV;\r\ngoto err_out_free_res;\r\n}\r\ncciss_enable_scsi_prefetch(h);\r\ncciss_p600_dma_prefetch_quirk(h);\r\nerr = cciss_enter_simple_mode(h);\r\nif (err)\r\ngoto err_out_free_res;\r\ncciss_put_controller_into_performant_mode(h);\r\nreturn 0;\r\nerr_out_free_res:\r\nif (h->transtable)\r\niounmap(h->transtable);\r\nif (h->cfgtable)\r\niounmap(h->cfgtable);\r\nif (h->vaddr)\r\niounmap(h->vaddr);\r\npci_release_regions(h->pdev);\r\nreturn err;\r\n}\r\nstatic int alloc_cciss_hba(struct pci_dev *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CTLR; i++) {\r\nif (!hba[i]) {\r\nctlr_info_t *h;\r\nh = kzalloc(sizeof(ctlr_info_t), GFP_KERNEL);\r\nif (!h)\r\ngoto Enomem;\r\nhba[i] = h;\r\nreturn i;\r\n}\r\n}\r\ndev_warn(&pdev->dev, "This driver supports a maximum"\r\n" of %d controllers.\n", MAX_CTLR);\r\nreturn -1;\r\nEnomem:\r\ndev_warn(&pdev->dev, "out of memory.\n");\r\nreturn -1;\r\n}\r\nstatic void free_hba(ctlr_info_t *h)\r\n{\r\nint i;\r\nhba[h->ctlr] = NULL;\r\nfor (i = 0; i < h->highest_lun + 1; i++)\r\nif (h->gendisk[i] != NULL)\r\nput_disk(h->gendisk[i]);\r\nkfree(h);\r\n}\r\nstatic int cciss_message(struct pci_dev *pdev, unsigned char opcode,\r\nunsigned char type)\r\n{\r\ntypedef struct {\r\nCommandListHeader_struct CommandHeader;\r\nRequestBlock_struct Request;\r\nErrDescriptor_struct ErrorDescriptor;\r\n} Command;\r\nstatic const size_t cmd_sz = sizeof(Command) + sizeof(ErrorInfo_struct);\r\nCommand *cmd;\r\ndma_addr_t paddr64;\r\nuint32_t paddr32, tag;\r\nvoid __iomem *vaddr;\r\nint i, err;\r\nvaddr = ioremap_nocache(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\nif (vaddr == NULL)\r\nreturn -ENOMEM;\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\niounmap(vaddr);\r\nreturn -ENOMEM;\r\n}\r\ncmd = pci_alloc_consistent(pdev, cmd_sz, &paddr64);\r\nif (cmd == NULL) {\r\niounmap(vaddr);\r\nreturn -ENOMEM;\r\n}\r\npaddr32 = paddr64;\r\ncmd->CommandHeader.ReplyQueue = 0;\r\ncmd->CommandHeader.SGList = 0;\r\ncmd->CommandHeader.SGTotal = 0;\r\ncmd->CommandHeader.Tag.lower = paddr32;\r\ncmd->CommandHeader.Tag.upper = 0;\r\nmemset(&cmd->CommandHeader.LUN.LunAddrBytes, 0, 8);\r\ncmd->Request.CDBLen = 16;\r\ncmd->Request.Type.Type = TYPE_MSG;\r\ncmd->Request.Type.Attribute = ATTR_HEADOFQUEUE;\r\ncmd->Request.Type.Direction = XFER_NONE;\r\ncmd->Request.Timeout = 0;\r\ncmd->Request.CDB[0] = opcode;\r\ncmd->Request.CDB[1] = type;\r\nmemset(&cmd->Request.CDB[2], 0, 14);\r\ncmd->ErrorDescriptor.Addr.lower = paddr32 + sizeof(Command);\r\ncmd->ErrorDescriptor.Addr.upper = 0;\r\ncmd->ErrorDescriptor.Len = sizeof(ErrorInfo_struct);\r\nwritel(paddr32, vaddr + SA5_REQUEST_PORT_OFFSET);\r\nfor (i = 0; i < 10; i++) {\r\ntag = readl(vaddr + SA5_REPLY_PORT_OFFSET);\r\nif ((tag & ~3) == paddr32)\r\nbreak;\r\nmsleep(CCISS_POST_RESET_NOOP_TIMEOUT_MSECS);\r\n}\r\niounmap(vaddr);\r\nif (i == 10) {\r\ndev_err(&pdev->dev,\r\n"controller message %02x:%02x timed out\n",\r\nopcode, type);\r\nreturn -ETIMEDOUT;\r\n}\r\npci_free_consistent(pdev, cmd_sz, cmd, paddr64);\r\nif (tag & 2) {\r\ndev_err(&pdev->dev, "controller message %02x:%02x failed\n",\r\nopcode, type);\r\nreturn -EIO;\r\n}\r\ndev_info(&pdev->dev, "controller message %02x:%02x succeeded\n",\r\nopcode, type);\r\nreturn 0;\r\n}\r\nstatic int cciss_controller_hard_reset(struct pci_dev *pdev,\r\nvoid * __iomem vaddr, u32 use_doorbell)\r\n{\r\nu16 pmcsr;\r\nint pos;\r\nif (use_doorbell) {\r\ndev_info(&pdev->dev, "using doorbell to reset controller\n");\r\nwritel(use_doorbell, vaddr + SA5_DOORBELL);\r\n} else {\r\npos = pci_find_capability(pdev, PCI_CAP_ID_PM);\r\nif (pos == 0) {\r\ndev_err(&pdev->dev,\r\n"cciss_controller_hard_reset: "\r\n"PCI PM not supported\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(&pdev->dev, "using PCI PM to reset controller\n");\r\npci_read_config_word(pdev, pos + PCI_PM_CTRL, &pmcsr);\r\npmcsr &= ~PCI_PM_CTRL_STATE_MASK;\r\npmcsr |= PCI_D3hot;\r\npci_write_config_word(pdev, pos + PCI_PM_CTRL, pmcsr);\r\nmsleep(500);\r\npmcsr &= ~PCI_PM_CTRL_STATE_MASK;\r\npmcsr |= PCI_D0;\r\npci_write_config_word(pdev, pos + PCI_PM_CTRL, pmcsr);\r\nmsleep(500);\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_driver_version(char *driver_version, int len)\r\n{\r\nmemset(driver_version, 0, len);\r\nstrncpy(driver_version, "cciss " DRIVER_NAME, len - 1);\r\n}\r\nstatic int write_driver_ver_to_cfgtable(CfgTable_struct __iomem *cfgtable)\r\n{\r\nchar *driver_version;\r\nint i, size = sizeof(cfgtable->driver_version);\r\ndriver_version = kmalloc(size, GFP_KERNEL);\r\nif (!driver_version)\r\nreturn -ENOMEM;\r\ninit_driver_version(driver_version, size);\r\nfor (i = 0; i < size; i++)\r\nwriteb(driver_version[i], &cfgtable->driver_version[i]);\r\nkfree(driver_version);\r\nreturn 0;\r\n}\r\nstatic void read_driver_ver_from_cfgtable(CfgTable_struct __iomem *cfgtable,\r\nunsigned char *driver_ver)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(cfgtable->driver_version); i++)\r\ndriver_ver[i] = readb(&cfgtable->driver_version[i]);\r\n}\r\nstatic int controller_reset_failed(CfgTable_struct __iomem *cfgtable)\r\n{\r\nchar *driver_ver, *old_driver_ver;\r\nint rc, size = sizeof(cfgtable->driver_version);\r\nold_driver_ver = kmalloc(2 * size, GFP_KERNEL);\r\nif (!old_driver_ver)\r\nreturn -ENOMEM;\r\ndriver_ver = old_driver_ver + size;\r\ninit_driver_version(old_driver_ver, size);\r\nread_driver_ver_from_cfgtable(cfgtable, driver_ver);\r\nrc = !memcmp(driver_ver, old_driver_ver, size);\r\nkfree(old_driver_ver);\r\nreturn rc;\r\n}\r\nstatic int cciss_kdump_hard_reset_controller(struct pci_dev *pdev)\r\n{\r\nu64 cfg_offset;\r\nu32 cfg_base_addr;\r\nu64 cfg_base_addr_index;\r\nvoid __iomem *vaddr;\r\nunsigned long paddr;\r\nu32 misc_fw_support;\r\nint rc;\r\nCfgTable_struct __iomem *cfgtable;\r\nu32 use_doorbell;\r\nu32 board_id;\r\nu16 command_register;\r\ncciss_lookup_board_id(pdev, &board_id);\r\nif (!ctlr_is_resettable(board_id)) {\r\ndev_warn(&pdev->dev, "Cannot reset Smart Array 640x "\r\n"due to shared cache module.");\r\nreturn -ENODEV;\r\n}\r\nif (!ctlr_is_hard_resettable(board_id))\r\nreturn -ENOTSUPP;\r\npci_read_config_word(pdev, 4, &command_register);\r\npci_disable_device(pdev);\r\npci_save_state(pdev);\r\nrc = cciss_pci_find_memory_BAR(pdev, &paddr);\r\nif (rc)\r\nreturn rc;\r\nvaddr = remap_pci_mem(paddr, 0x250);\r\nif (!vaddr)\r\nreturn -ENOMEM;\r\nrc = cciss_find_cfg_addrs(pdev, vaddr, &cfg_base_addr,\r\n&cfg_base_addr_index, &cfg_offset);\r\nif (rc)\r\ngoto unmap_vaddr;\r\ncfgtable = remap_pci_mem(pci_resource_start(pdev,\r\ncfg_base_addr_index) + cfg_offset, sizeof(*cfgtable));\r\nif (!cfgtable) {\r\nrc = -ENOMEM;\r\ngoto unmap_vaddr;\r\n}\r\nrc = write_driver_ver_to_cfgtable(cfgtable);\r\nif (rc)\r\ngoto unmap_vaddr;\r\nmisc_fw_support = readl(&cfgtable->misc_fw_support);\r\nuse_doorbell = misc_fw_support & MISC_FW_DOORBELL_RESET2;\r\nif (use_doorbell) {\r\nuse_doorbell = DOORBELL_CTLR_RESET2;\r\n} else {\r\nuse_doorbell = misc_fw_support & MISC_FW_DOORBELL_RESET;\r\nif (use_doorbell) {\r\ndev_warn(&pdev->dev, "Controller claims that "\r\n"'Bit 2 doorbell reset' is "\r\n"supported, but not 'bit 5 doorbell reset'. "\r\n"Firmware update is recommended.\n");\r\nrc = -ENOTSUPP;\r\ngoto unmap_cfgtable;\r\n}\r\n}\r\nrc = cciss_controller_hard_reset(pdev, vaddr, use_doorbell);\r\nif (rc)\r\ngoto unmap_cfgtable;\r\npci_restore_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_warn(&pdev->dev, "failed to enable device.\n");\r\ngoto unmap_cfgtable;\r\n}\r\npci_write_config_word(pdev, 4, command_register);\r\nmsleep(CCISS_POST_RESET_PAUSE_MSECS);\r\ndev_info(&pdev->dev, "Waiting for board to reset.\n");\r\nrc = cciss_wait_for_board_state(pdev, vaddr, BOARD_NOT_READY);\r\nif (rc) {\r\ndev_warn(&pdev->dev, "Failed waiting for board to hard reset."\r\n" Will try soft reset.\n");\r\nrc = -ENOTSUPP;\r\ngoto unmap_cfgtable;\r\n}\r\nrc = cciss_wait_for_board_state(pdev, vaddr, BOARD_READY);\r\nif (rc) {\r\ndev_warn(&pdev->dev,\r\n"failed waiting for board to become ready "\r\n"after hard reset\n");\r\ngoto unmap_cfgtable;\r\n}\r\nrc = controller_reset_failed(vaddr);\r\nif (rc < 0)\r\ngoto unmap_cfgtable;\r\nif (rc) {\r\ndev_warn(&pdev->dev, "Unable to successfully hard reset "\r\n"controller. Will try soft reset.\n");\r\nrc = -ENOTSUPP;\r\n} else {\r\ndev_info(&pdev->dev, "Board ready after hard reset.\n");\r\n}\r\nunmap_cfgtable:\r\niounmap(cfgtable);\r\nunmap_vaddr:\r\niounmap(vaddr);\r\nreturn rc;\r\n}\r\nstatic int cciss_init_reset_devices(struct pci_dev *pdev)\r\n{\r\nint rc, i;\r\nif (!reset_devices)\r\nreturn 0;\r\nrc = cciss_kdump_hard_reset_controller(pdev);\r\nif (rc == -ENOTSUPP)\r\nreturn rc;\r\nif (rc)\r\nreturn -ENODEV;\r\ndev_warn(&pdev->dev, "Waiting for controller to respond to no-op\n");\r\nfor (i = 0; i < CCISS_POST_RESET_NOOP_RETRIES; i++) {\r\nif (cciss_noop(pdev) == 0)\r\nbreak;\r\nelse\r\ndev_warn(&pdev->dev, "no-op failed%s\n",\r\n(i < CCISS_POST_RESET_NOOP_RETRIES - 1 ?\r\n"; re-trying" : ""));\r\nmsleep(CCISS_POST_RESET_NOOP_INTERVAL_MSECS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cciss_allocate_cmd_pool(ctlr_info_t *h)\r\n{\r\nh->cmd_pool_bits = kmalloc(BITS_TO_LONGS(h->nr_cmds) *\r\nsizeof(unsigned long), GFP_KERNEL);\r\nh->cmd_pool = pci_alloc_consistent(h->pdev,\r\nh->nr_cmds * sizeof(CommandList_struct),\r\n&(h->cmd_pool_dhandle));\r\nh->errinfo_pool = pci_alloc_consistent(h->pdev,\r\nh->nr_cmds * sizeof(ErrorInfo_struct),\r\n&(h->errinfo_pool_dhandle));\r\nif ((h->cmd_pool_bits == NULL)\r\n|| (h->cmd_pool == NULL)\r\n|| (h->errinfo_pool == NULL)) {\r\ndev_err(&h->pdev->dev, "out of memory");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cciss_allocate_scatterlists(ctlr_info_t *h)\r\n{\r\nint i;\r\nh->scatter_list = kzalloc(h->max_commands *\r\nsizeof(struct scatterlist *), GFP_KERNEL);\r\nif (!h->scatter_list)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < h->nr_cmds; i++) {\r\nh->scatter_list[i] = kmalloc(sizeof(struct scatterlist) *\r\nh->maxsgentries, GFP_KERNEL);\r\nif (h->scatter_list[i] == NULL) {\r\ndev_err(&h->pdev->dev, "could not allocate "\r\n"s/g lists\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cciss_free_scatterlists(ctlr_info_t *h)\r\n{\r\nint i;\r\nif (h->scatter_list) {\r\nfor (i = 0; i < h->nr_cmds; i++)\r\nkfree(h->scatter_list[i]);\r\nkfree(h->scatter_list);\r\n}\r\n}\r\nstatic void cciss_free_cmd_pool(ctlr_info_t *h)\r\n{\r\nkfree(h->cmd_pool_bits);\r\nif (h->cmd_pool)\r\npci_free_consistent(h->pdev,\r\nh->nr_cmds * sizeof(CommandList_struct),\r\nh->cmd_pool, h->cmd_pool_dhandle);\r\nif (h->errinfo_pool)\r\npci_free_consistent(h->pdev,\r\nh->nr_cmds * sizeof(ErrorInfo_struct),\r\nh->errinfo_pool, h->errinfo_pool_dhandle);\r\n}\r\nstatic int cciss_request_irq(ctlr_info_t *h,\r\nirqreturn_t (*msixhandler)(int, void *),\r\nirqreturn_t (*intxhandler)(int, void *))\r\n{\r\nif (h->msix_vector || h->msi_vector) {\r\nif (!request_irq(h->intr[h->intr_mode], msixhandler,\r\n0, h->devname, h))\r\nreturn 0;\r\ndev_err(&h->pdev->dev, "Unable to get msi irq %d"\r\n" for %s\n", h->intr[h->intr_mode],\r\nh->devname);\r\nreturn -1;\r\n}\r\nif (!request_irq(h->intr[h->intr_mode], intxhandler,\r\nIRQF_SHARED, h->devname, h))\r\nreturn 0;\r\ndev_err(&h->pdev->dev, "Unable to get irq %d for %s\n",\r\nh->intr[h->intr_mode], h->devname);\r\nreturn -1;\r\n}\r\nstatic int cciss_kdump_soft_reset(ctlr_info_t *h)\r\n{\r\nif (cciss_send_reset(h, CTLR_LUNID, CCISS_RESET_TYPE_CONTROLLER)) {\r\ndev_warn(&h->pdev->dev, "Resetting array controller failed.\n");\r\nreturn -EIO;\r\n}\r\ndev_info(&h->pdev->dev, "Waiting for board to soft reset.\n");\r\nif (cciss_wait_for_board_state(h->pdev, h->vaddr, BOARD_NOT_READY)) {\r\ndev_warn(&h->pdev->dev, "Soft reset had no effect.\n");\r\nreturn -1;\r\n}\r\ndev_info(&h->pdev->dev, "Board reset, awaiting READY status.\n");\r\nif (cciss_wait_for_board_state(h->pdev, h->vaddr, BOARD_READY)) {\r\ndev_warn(&h->pdev->dev, "Board failed to become ready "\r\n"after soft reset.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cciss_undo_allocations_after_kdump_soft_reset(ctlr_info_t *h)\r\n{\r\nint ctlr = h->ctlr;\r\nfree_irq(h->intr[h->intr_mode], h);\r\n#ifdef CONFIG_PCI_MSI\r\nif (h->msix_vector)\r\npci_disable_msix(h->pdev);\r\nelse if (h->msi_vector)\r\npci_disable_msi(h->pdev);\r\n#endif\r\ncciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);\r\ncciss_free_scatterlists(h);\r\ncciss_free_cmd_pool(h);\r\nkfree(h->blockFetchTable);\r\nif (h->reply_pool)\r\npci_free_consistent(h->pdev, h->max_commands * sizeof(__u64),\r\nh->reply_pool, h->reply_pool_dhandle);\r\nif (h->transtable)\r\niounmap(h->transtable);\r\nif (h->cfgtable)\r\niounmap(h->cfgtable);\r\nif (h->vaddr)\r\niounmap(h->vaddr);\r\nunregister_blkdev(h->major, h->devname);\r\ncciss_destroy_hba_sysfs_entry(h);\r\npci_release_regions(h->pdev);\r\nkfree(h);\r\nhba[ctlr] = NULL;\r\n}\r\nstatic int cciss_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint i;\r\nint j = 0;\r\nint rc;\r\nint try_soft_reset = 0;\r\nint dac, return_code;\r\nInquiryData_struct *inq_buff;\r\nctlr_info_t *h;\r\nunsigned long flags;\r\nif ((reset_devices) && (cciss_allow_hpsa == 1))\r\nreturn -ENODEV;\r\nrc = cciss_init_reset_devices(pdev);\r\nif (rc) {\r\nif (rc != -ENOTSUPP)\r\nreturn rc;\r\ntry_soft_reset = 1;\r\nrc = 0;\r\n}\r\nreinit_after_soft_reset:\r\ni = alloc_cciss_hba(pdev);\r\nif (i < 0)\r\nreturn -1;\r\nh = hba[i];\r\nh->pdev = pdev;\r\nh->busy_initializing = 1;\r\nh->intr_mode = cciss_simple_mode ? SIMPLE_MODE_INT : PERF_MODE_INT;\r\nINIT_LIST_HEAD(&h->cmpQ);\r\nINIT_LIST_HEAD(&h->reqQ);\r\nmutex_init(&h->busy_shutting_down);\r\nif (cciss_pci_init(h) != 0)\r\ngoto clean_no_release_regions;\r\nsprintf(h->devname, "cciss%d", i);\r\nh->ctlr = i;\r\nif (cciss_tape_cmds < 2)\r\ncciss_tape_cmds = 2;\r\nif (cciss_tape_cmds > 16)\r\ncciss_tape_cmds = 16;\r\ninit_completion(&h->scan_wait);\r\nif (cciss_create_hba_sysfs_entry(h))\r\ngoto clean0;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\r\ndac = 1;\r\nelse if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))\r\ndac = 0;\r\nelse {\r\ndev_err(&h->pdev->dev, "no suitable DMA available\n");\r\ngoto clean1;\r\n}\r\nif (i < MAX_CTLR_ORIG)\r\nh->major = COMPAQ_CISS_MAJOR + i;\r\nrc = register_blkdev(h->major, h->devname);\r\nif (rc == -EBUSY || rc == -EINVAL) {\r\ndev_err(&h->pdev->dev,\r\n"Unable to get major number %d for %s "\r\n"on hba %d\n", h->major, h->devname, i);\r\ngoto clean1;\r\n} else {\r\nif (i >= MAX_CTLR_ORIG)\r\nh->major = rc;\r\n}\r\nh->access.set_intr_mask(h, CCISS_INTR_OFF);\r\nrc = cciss_request_irq(h, do_cciss_msix_intr, do_cciss_intx);\r\nif (rc)\r\ngoto clean2;\r\ndev_info(&h->pdev->dev, "%s: <0x%x> at PCI %s IRQ %d%s using DAC\n",\r\nh->devname, pdev->device, pci_name(pdev),\r\nh->intr[h->intr_mode], dac ? "" : " not");\r\nif (cciss_allocate_cmd_pool(h))\r\ngoto clean4;\r\nif (cciss_allocate_scatterlists(h))\r\ngoto clean4;\r\nh->cmd_sg_list = cciss_allocate_sg_chain_blocks(h,\r\nh->chainsize, h->nr_cmds);\r\nif (!h->cmd_sg_list && h->chainsize > 0)\r\ngoto clean4;\r\nspin_lock_init(&h->lock);\r\npci_set_drvdata(pdev, h);\r\nbitmap_zero(h->cmd_pool_bits, h->nr_cmds);\r\nh->num_luns = 0;\r\nh->highest_lun = -1;\r\nfor (j = 0; j < CISS_MAX_LUN; j++) {\r\nh->drv[j] = NULL;\r\nh->gendisk[j] = NULL;\r\n}\r\nif (try_soft_reset) {\r\nspin_lock_irqsave(&h->lock, flags);\r\nh->access.set_intr_mask(h, CCISS_INTR_OFF);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nfree_irq(h->intr[h->intr_mode], h);\r\nrc = cciss_request_irq(h, cciss_msix_discard_completions,\r\ncciss_intx_discard_completions);\r\nif (rc) {\r\ndev_warn(&h->pdev->dev, "Failed to request_irq after "\r\n"soft reset.\n");\r\ngoto clean4;\r\n}\r\nrc = cciss_kdump_soft_reset(h);\r\nif (rc) {\r\ndev_warn(&h->pdev->dev, "Soft reset failed.\n");\r\ngoto clean4;\r\n}\r\ndev_info(&h->pdev->dev, "Board READY.\n");\r\ndev_info(&h->pdev->dev,\r\n"Waiting for stale completions to drain.\n");\r\nh->access.set_intr_mask(h, CCISS_INTR_ON);\r\nmsleep(10000);\r\nh->access.set_intr_mask(h, CCISS_INTR_OFF);\r\nrc = controller_reset_failed(h->cfgtable);\r\nif (rc)\r\ndev_info(&h->pdev->dev,\r\n"Soft reset appears to have failed.\n");\r\ncciss_undo_allocations_after_kdump_soft_reset(h);\r\ntry_soft_reset = 0;\r\nif (rc)\r\nreturn -ENODEV;\r\ngoto reinit_after_soft_reset;\r\n}\r\ncciss_scsi_setup(h);\r\nh->access.set_intr_mask(h, CCISS_INTR_ON);\r\ninq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);\r\nif (inq_buff == NULL) {\r\ndev_err(&h->pdev->dev, "out of memory\n");\r\ngoto clean4;\r\n}\r\nreturn_code = sendcmd_withirq(h, CISS_INQUIRY, inq_buff,\r\nsizeof(InquiryData_struct), 0, CTLR_LUNID, TYPE_CMD);\r\nif (return_code == IO_OK) {\r\nh->firm_ver[0] = inq_buff->data_byte[32];\r\nh->firm_ver[1] = inq_buff->data_byte[33];\r\nh->firm_ver[2] = inq_buff->data_byte[34];\r\nh->firm_ver[3] = inq_buff->data_byte[35];\r\n} else {\r\ndev_warn(&h->pdev->dev, "unable to determine firmware"\r\n" version of controller\n");\r\n}\r\nkfree(inq_buff);\r\ncciss_procinit(h);\r\nh->cciss_max_sectors = 8192;\r\nrebuild_lun_table(h, 1, 0);\r\ncciss_engage_scsi(h);\r\nh->busy_initializing = 0;\r\nreturn 1;\r\nclean4:\r\ncciss_free_cmd_pool(h);\r\ncciss_free_scatterlists(h);\r\ncciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);\r\nfree_irq(h->intr[h->intr_mode], h);\r\nclean2:\r\nunregister_blkdev(h->major, h->devname);\r\nclean1:\r\ncciss_destroy_hba_sysfs_entry(h);\r\nclean0:\r\npci_release_regions(pdev);\r\nclean_no_release_regions:\r\nh->busy_initializing = 0;\r\npci_set_drvdata(pdev, NULL);\r\nfree_hba(h);\r\nreturn -1;\r\n}\r\nstatic void cciss_shutdown(struct pci_dev *pdev)\r\n{\r\nctlr_info_t *h;\r\nchar *flush_buf;\r\nint return_code;\r\nh = pci_get_drvdata(pdev);\r\nflush_buf = kzalloc(4, GFP_KERNEL);\r\nif (!flush_buf) {\r\ndev_warn(&h->pdev->dev, "cache not flushed, out of memory.\n");\r\nreturn;\r\n}\r\nreturn_code = sendcmd_withirq(h, CCISS_CACHE_FLUSH, flush_buf,\r\n4, 0, CTLR_LUNID, TYPE_CMD);\r\nkfree(flush_buf);\r\nif (return_code != IO_OK)\r\ndev_warn(&h->pdev->dev, "Error flushing cache\n");\r\nh->access.set_intr_mask(h, CCISS_INTR_OFF);\r\nfree_irq(h->intr[h->intr_mode], h);\r\n}\r\nstatic int cciss_enter_simple_mode(struct ctlr_info *h)\r\n{\r\nu32 trans_support;\r\ntrans_support = readl(&(h->cfgtable->TransportSupport));\r\nif (!(trans_support & SIMPLE_MODE))\r\nreturn -ENOTSUPP;\r\nh->max_commands = readl(&(h->cfgtable->CmdsOutMax));\r\nwritel(CFGTBL_Trans_Simple, &(h->cfgtable->HostWrite.TransportRequest));\r\nwritel(CFGTBL_ChangeReq, h->vaddr + SA5_DOORBELL);\r\ncciss_wait_for_mode_change_ack(h);\r\nprint_cfg_table(h);\r\nif (!(readl(&(h->cfgtable->TransportActive)) & CFGTBL_Trans_Simple)) {\r\ndev_warn(&h->pdev->dev, "unable to get board into simple mode\n");\r\nreturn -ENODEV;\r\n}\r\nh->transMethod = CFGTBL_Trans_Simple;\r\nreturn 0;\r\n}\r\nstatic void cciss_remove_one(struct pci_dev *pdev)\r\n{\r\nctlr_info_t *h;\r\nint i, j;\r\nif (pci_get_drvdata(pdev) == NULL) {\r\ndev_err(&pdev->dev, "Unable to remove device\n");\r\nreturn;\r\n}\r\nh = pci_get_drvdata(pdev);\r\ni = h->ctlr;\r\nif (hba[i] == NULL) {\r\ndev_err(&pdev->dev, "device appears to already be removed\n");\r\nreturn;\r\n}\r\nmutex_lock(&h->busy_shutting_down);\r\nremove_from_scan_list(h);\r\nremove_proc_entry(h->devname, proc_cciss);\r\nunregister_blkdev(h->major, h->devname);\r\nfor (j = 0; j < CISS_MAX_LUN; j++) {\r\nstruct gendisk *disk = h->gendisk[j];\r\nif (disk) {\r\nstruct request_queue *q = disk->queue;\r\nif (disk->flags & GENHD_FL_UP) {\r\ncciss_destroy_ld_sysfs_entry(h, j, 1);\r\ndel_gendisk(disk);\r\n}\r\nif (q)\r\nblk_cleanup_queue(q);\r\n}\r\n}\r\n#ifdef CONFIG_CISS_SCSI_TAPE\r\ncciss_unregister_scsi(h);\r\n#endif\r\ncciss_shutdown(pdev);\r\n#ifdef CONFIG_PCI_MSI\r\nif (h->msix_vector)\r\npci_disable_msix(h->pdev);\r\nelse if (h->msi_vector)\r\npci_disable_msi(h->pdev);\r\n#endif\r\niounmap(h->transtable);\r\niounmap(h->cfgtable);\r\niounmap(h->vaddr);\r\ncciss_free_cmd_pool(h);\r\nfor (j = 0; j < h->nr_cmds; j++)\r\nkfree(h->scatter_list[j]);\r\nkfree(h->scatter_list);\r\ncciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);\r\nkfree(h->blockFetchTable);\r\nif (h->reply_pool)\r\npci_free_consistent(h->pdev, h->max_commands * sizeof(__u64),\r\nh->reply_pool, h->reply_pool_dhandle);\r\npci_release_regions(pdev);\r\npci_set_drvdata(pdev, NULL);\r\ncciss_destroy_hba_sysfs_entry(h);\r\nmutex_unlock(&h->busy_shutting_down);\r\nfree_hba(h);\r\n}\r\nstatic int __init cciss_init(void)\r\n{\r\nint err;\r\nBUILD_BUG_ON(sizeof(CommandList_struct) % COMMANDLIST_ALIGNMENT);\r\nprintk(KERN_INFO DRIVER_NAME "\n");\r\nerr = bus_register(&cciss_bus_type);\r\nif (err)\r\nreturn err;\r\ncciss_scan_thread = kthread_run(scan_thread, NULL, "cciss_scan");\r\nif (IS_ERR(cciss_scan_thread)) {\r\nerr = PTR_ERR(cciss_scan_thread);\r\ngoto err_bus_unregister;\r\n}\r\nerr = pci_register_driver(&cciss_pci_driver);\r\nif (err)\r\ngoto err_thread_stop;\r\nreturn err;\r\nerr_thread_stop:\r\nkthread_stop(cciss_scan_thread);\r\nerr_bus_unregister:\r\nbus_unregister(&cciss_bus_type);\r\nreturn err;\r\n}\r\nstatic void __exit cciss_cleanup(void)\r\n{\r\nint i;\r\npci_unregister_driver(&cciss_pci_driver);\r\nfor (i = 0; i < MAX_CTLR; i++) {\r\nif (hba[i] != NULL) {\r\ndev_warn(&hba[i]->pdev->dev,\r\n"had to remove controller\n");\r\ncciss_remove_one(hba[i]->pdev);\r\n}\r\n}\r\nkthread_stop(cciss_scan_thread);\r\nif (proc_cciss)\r\nremove_proc_entry("driver/cciss", NULL);\r\nbus_unregister(&cciss_bus_type);\r\n}
