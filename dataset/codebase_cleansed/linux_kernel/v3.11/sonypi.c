static int sonypi_ec_write(u8 addr, u8 value)\r\n{\r\n#ifdef CONFIG_ACPI\r\nif (SONYPI_ACPI_ACTIVE)\r\nreturn ec_write(addr, value);\r\n#endif\r\nwait_on_command(1, inb_p(SONYPI_CST_IOPORT) & 3, ITERATIONS_LONG);\r\noutb_p(0x81, SONYPI_CST_IOPORT);\r\nwait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\r\noutb_p(addr, SONYPI_DATA_IOPORT);\r\nwait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\r\noutb_p(value, SONYPI_DATA_IOPORT);\r\nwait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\r\nreturn 0;\r\n}\r\nstatic int sonypi_ec_read(u8 addr, u8 *value)\r\n{\r\n#ifdef CONFIG_ACPI\r\nif (SONYPI_ACPI_ACTIVE)\r\nreturn ec_read(addr, value);\r\n#endif\r\nwait_on_command(1, inb_p(SONYPI_CST_IOPORT) & 3, ITERATIONS_LONG);\r\noutb_p(0x80, SONYPI_CST_IOPORT);\r\nwait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\r\noutb_p(addr, SONYPI_DATA_IOPORT);\r\nwait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\r\n*value = inb_p(SONYPI_DATA_IOPORT);\r\nreturn 0;\r\n}\r\nstatic int ec_read16(u8 addr, u16 *value)\r\n{\r\nu8 val_lb, val_hb;\r\nif (sonypi_ec_read(addr, &val_lb))\r\nreturn -1;\r\nif (sonypi_ec_read(addr + 1, &val_hb))\r\nreturn -1;\r\n*value = val_lb | (val_hb << 8);\r\nreturn 0;\r\n}\r\nstatic void sonypi_type1_srs(void)\r\n{\r\nu32 v;\r\npci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\r\nv = (v & 0xFFFF0000) | ((u32) sonypi_device.ioport1);\r\npci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\r\npci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\r\nv = (v & 0xFFF0FFFF) |\r\n(((u32) sonypi_device.ioport1 ^ sonypi_device.ioport2) << 16);\r\npci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\r\nv = inl(SONYPI_IRQ_PORT);\r\nv &= ~(((u32) 0x3) << SONYPI_IRQ_SHIFT);\r\nv |= (((u32) sonypi_device.bits) << SONYPI_IRQ_SHIFT);\r\noutl(v, SONYPI_IRQ_PORT);\r\npci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\r\nv = (v & 0xFF1FFFFF) | 0x00C00000;\r\npci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\r\n}\r\nstatic void sonypi_type2_srs(void)\r\n{\r\nif (sonypi_ec_write(SONYPI_SHIB, (sonypi_device.ioport1 & 0xFF00) >> 8))\r\nprintk(KERN_WARNING "ec_write failed\n");\r\nif (sonypi_ec_write(SONYPI_SLOB, sonypi_device.ioport1 & 0x00FF))\r\nprintk(KERN_WARNING "ec_write failed\n");\r\nif (sonypi_ec_write(SONYPI_SIRQ, sonypi_device.bits))\r\nprintk(KERN_WARNING "ec_write failed\n");\r\nudelay(10);\r\n}\r\nstatic void sonypi_type3_srs(void)\r\n{\r\nu16 v16;\r\nu8 v8;\r\nsonypi_type2_srs();\r\nv16 = (sonypi_device.ioport1 & 0xFFF0) | 0x01;\r\npci_write_config_word(sonypi_device.dev, SONYPI_TYPE3_GID2, v16);\r\npci_read_config_byte(sonypi_device.dev, SONYPI_TYPE3_MISC, &v8);\r\nv8 = (v8 & 0xCF) | 0x10;\r\npci_write_config_byte(sonypi_device.dev, SONYPI_TYPE3_MISC, v8);\r\n}\r\nstatic void sonypi_type1_dis(void)\r\n{\r\nu32 v;\r\npci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\r\nv = v & 0xFF3FFFFF;\r\npci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\r\nv = inl(SONYPI_IRQ_PORT);\r\nv |= (0x3 << SONYPI_IRQ_SHIFT);\r\noutl(v, SONYPI_IRQ_PORT);\r\n}\r\nstatic void sonypi_type2_dis(void)\r\n{\r\nif (sonypi_ec_write(SONYPI_SHIB, 0))\r\nprintk(KERN_WARNING "ec_write failed\n");\r\nif (sonypi_ec_write(SONYPI_SLOB, 0))\r\nprintk(KERN_WARNING "ec_write failed\n");\r\nif (sonypi_ec_write(SONYPI_SIRQ, 0))\r\nprintk(KERN_WARNING "ec_write failed\n");\r\n}\r\nstatic void sonypi_type3_dis(void)\r\n{\r\nsonypi_type2_dis();\r\nudelay(10);\r\npci_write_config_word(sonypi_device.dev, SONYPI_TYPE3_GID2, 0);\r\n}\r\nstatic u8 sonypi_call1(u8 dev)\r\n{\r\nu8 v1, v2;\r\nwait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\r\noutb(dev, sonypi_device.ioport2);\r\nv1 = inb_p(sonypi_device.ioport2);\r\nv2 = inb_p(sonypi_device.ioport1);\r\nreturn v2;\r\n}\r\nstatic u8 sonypi_call2(u8 dev, u8 fn)\r\n{\r\nu8 v1;\r\nwait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\r\noutb(dev, sonypi_device.ioport2);\r\nwait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\r\noutb(fn, sonypi_device.ioport1);\r\nv1 = inb_p(sonypi_device.ioport1);\r\nreturn v1;\r\n}\r\nstatic u8 sonypi_call3(u8 dev, u8 fn, u8 v)\r\n{\r\nu8 v1;\r\nwait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\r\noutb(dev, sonypi_device.ioport2);\r\nwait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\r\noutb(fn, sonypi_device.ioport1);\r\nwait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\r\noutb(v, sonypi_device.ioport1);\r\nv1 = inb_p(sonypi_device.ioport1);\r\nreturn v1;\r\n}\r\nstatic void sonypi_set(u8 fn, u8 v)\r\n{\r\nwait_on_command(0, sonypi_call3(0x90, fn, v), ITERATIONS_SHORT);\r\n}\r\nstatic int sonypi_camera_ready(void)\r\n{\r\nu8 v;\r\nv = sonypi_call2(0x8f, SONYPI_CAMERA_STATUS);\r\nreturn (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));\r\n}\r\nstatic void sonypi_camera_off(void)\r\n{\r\nsonypi_set(SONYPI_CAMERA_PICTURE, SONYPI_CAMERA_MUTE_MASK);\r\nif (!sonypi_device.camera_power)\r\nreturn;\r\nsonypi_call2(0x91, 0);\r\nsonypi_device.camera_power = 0;\r\n}\r\nstatic void sonypi_camera_on(void)\r\n{\r\nint i, j;\r\nif (sonypi_device.camera_power)\r\nreturn;\r\nfor (j = 5; j > 0; j--) {\r\nwhile (sonypi_call2(0x91, 0x1))\r\nmsleep(10);\r\nsonypi_call1(0x93);\r\nfor (i = 400; i > 0; i--) {\r\nif (sonypi_camera_ready())\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (i)\r\nbreak;\r\n}\r\nif (j == 0) {\r\nprintk(KERN_WARNING "sonypi: failed to power on camera\n");\r\nreturn;\r\n}\r\nsonypi_set(0x10, 0x5a);\r\nsonypi_device.camera_power = 1;\r\n}\r\nstatic void sonypi_setbluetoothpower(u8 state)\r\n{\r\nstate = !!state;\r\nif (sonypi_device.bluetooth_power == state)\r\nreturn;\r\nsonypi_call2(0x96, state);\r\nsonypi_call1(0x82);\r\nsonypi_device.bluetooth_power = state;\r\n}\r\nstatic void input_keyrelease(struct work_struct *work)\r\n{\r\nstruct sonypi_keypress kp;\r\nwhile (kfifo_out_locked(&sonypi_device.input_fifo, (unsigned char *)&kp,\r\nsizeof(kp), &sonypi_device.input_fifo_lock)\r\n== sizeof(kp)) {\r\nmsleep(10);\r\ninput_report_key(kp.dev, kp.key, 0);\r\ninput_sync(kp.dev);\r\n}\r\n}\r\nstatic void sonypi_report_input_event(u8 event)\r\n{\r\nstruct input_dev *jog_dev = sonypi_device.input_jog_dev;\r\nstruct input_dev *key_dev = sonypi_device.input_key_dev;\r\nstruct sonypi_keypress kp = { NULL };\r\nint i;\r\nswitch (event) {\r\ncase SONYPI_EVENT_JOGDIAL_UP:\r\ncase SONYPI_EVENT_JOGDIAL_UP_PRESSED:\r\ninput_report_rel(jog_dev, REL_WHEEL, 1);\r\ninput_sync(jog_dev);\r\nbreak;\r\ncase SONYPI_EVENT_JOGDIAL_DOWN:\r\ncase SONYPI_EVENT_JOGDIAL_DOWN_PRESSED:\r\ninput_report_rel(jog_dev, REL_WHEEL, -1);\r\ninput_sync(jog_dev);\r\nbreak;\r\ncase SONYPI_EVENT_JOGDIAL_PRESSED:\r\nkp.key = BTN_MIDDLE;\r\nkp.dev = jog_dev;\r\nbreak;\r\ncase SONYPI_EVENT_FNKEY_RELEASED:\r\nbreak;\r\ndefault:\r\nfor (i = 0; sonypi_inputkeys[i].sonypiev; i++)\r\nif (event == sonypi_inputkeys[i].sonypiev) {\r\nkp.dev = key_dev;\r\nkp.key = sonypi_inputkeys[i].inputev;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (kp.dev) {\r\ninput_report_key(kp.dev, kp.key, 1);\r\ninput_sync(kp.dev);\r\nkfifo_in_locked(&sonypi_device.input_fifo,\r\n(unsigned char *)&kp, sizeof(kp),\r\n&sonypi_device.input_fifo_lock);\r\nschedule_work(&sonypi_device.input_work);\r\n}\r\n}\r\nstatic irqreturn_t sonypi_irq(int irq, void *dev_id)\r\n{\r\nu8 v1, v2, event = 0;\r\nint i, j;\r\nv1 = inb_p(sonypi_device.ioport1);\r\nv2 = inb_p(sonypi_device.ioport1 + sonypi_device.evtype_offset);\r\nfor (i = 0; sonypi_eventtypes[i].model; i++) {\r\nif (sonypi_device.model != sonypi_eventtypes[i].model)\r\ncontinue;\r\nif ((v2 & sonypi_eventtypes[i].data) !=\r\nsonypi_eventtypes[i].data)\r\ncontinue;\r\nif (!(mask & sonypi_eventtypes[i].mask))\r\ncontinue;\r\nfor (j = 0; sonypi_eventtypes[i].events[j].event; j++) {\r\nif (v1 == sonypi_eventtypes[i].events[j].data) {\r\nevent = sonypi_eventtypes[i].events[j].event;\r\ngoto found;\r\n}\r\n}\r\n}\r\nif (verbose)\r\nprintk(KERN_WARNING\r\n"sonypi: unknown event port1=0x%02x,port2=0x%02x\n",\r\nv1, v2);\r\nreturn IRQ_HANDLED;\r\nfound:\r\nif (verbose > 1)\r\nprintk(KERN_INFO\r\n"sonypi: event port1=0x%02x,port2=0x%02x\n", v1, v2);\r\nif (useinput)\r\nsonypi_report_input_event(event);\r\n#ifdef CONFIG_ACPI\r\nif (sonypi_acpi_device)\r\nacpi_bus_generate_proc_event(sonypi_acpi_device, 1, event);\r\n#endif\r\nkfifo_in_locked(&sonypi_device.fifo, (unsigned char *)&event,\r\nsizeof(event), &sonypi_device.fifo_lock);\r\nkill_fasync(&sonypi_device.fifo_async, SIGIO, POLL_IN);\r\nwake_up_interruptible(&sonypi_device.fifo_proc_list);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sonypi_misc_fasync(int fd, struct file *filp, int on)\r\n{\r\nreturn fasync_helper(fd, filp, on, &sonypi_device.fifo_async);\r\n}\r\nstatic int sonypi_misc_release(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&sonypi_device.lock);\r\nsonypi_device.open_count--;\r\nmutex_unlock(&sonypi_device.lock);\r\nreturn 0;\r\n}\r\nstatic int sonypi_misc_open(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&sonypi_device.lock);\r\nif (!sonypi_device.open_count)\r\nkfifo_reset(&sonypi_device.fifo);\r\nsonypi_device.open_count++;\r\nmutex_unlock(&sonypi_device.lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t sonypi_misc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nunsigned char c;\r\nif ((kfifo_len(&sonypi_device.fifo) == 0) &&\r\n(file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(sonypi_device.fifo_proc_list,\r\nkfifo_len(&sonypi_device.fifo) != 0);\r\nif (ret)\r\nreturn ret;\r\nwhile (ret < count &&\r\n(kfifo_out_locked(&sonypi_device.fifo, &c, sizeof(c),\r\n&sonypi_device.fifo_lock) == sizeof(c))) {\r\nif (put_user(c, buf++))\r\nreturn -EFAULT;\r\nret++;\r\n}\r\nif (ret > 0) {\r\nstruct inode *inode = file_inode(file);\r\ninode->i_atime = current_fs_time(inode->i_sb);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int sonypi_misc_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &sonypi_device.fifo_proc_list, wait);\r\nif (kfifo_len(&sonypi_device.fifo))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic long sonypi_misc_ioctl(struct file *fp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nlong ret = 0;\r\nvoid __user *argp = (void __user *)arg;\r\nu8 val8;\r\nu16 val16;\r\nmutex_lock(&sonypi_device.lock);\r\nswitch (cmd) {\r\ncase SONYPI_IOCGBRT:\r\nif (sonypi_ec_read(SONYPI_LCD_LIGHT, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSBRT:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (sonypi_ec_write(SONYPI_LCD_LIGHT, val8))\r\nret = -EIO;\r\nbreak;\r\ncase SONYPI_IOCGBAT1CAP:\r\nif (ec_read16(SONYPI_BAT1_FULL, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT1REM:\r\nif (ec_read16(SONYPI_BAT1_LEFT, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT2CAP:\r\nif (ec_read16(SONYPI_BAT2_FULL, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT2REM:\r\nif (ec_read16(SONYPI_BAT2_LEFT, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBATFLAGS:\r\nif (sonypi_ec_read(SONYPI_BAT_FLAGS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nval8 &= 0x07;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBLUE:\r\nval8 = sonypi_device.bluetooth_power;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSBLUE:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nsonypi_setbluetoothpower(val8);\r\nbreak;\r\ncase SONYPI_IOCGFAN:\r\nif (sonypi_ec_read(SONYPI_FAN0_STATUS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSFAN:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (sonypi_ec_write(SONYPI_FAN0_STATUS, val8))\r\nret = -EIO;\r\nbreak;\r\ncase SONYPI_IOCGTEMP:\r\nif (sonypi_ec_read(SONYPI_TEMP_STATUS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&sonypi_device.lock);\r\nreturn ret;\r\n}\r\nstatic void sonypi_enable(unsigned int camera_on)\r\n{\r\nswitch (sonypi_device.model) {\r\ncase SONYPI_DEVICE_MODEL_TYPE1:\r\nsonypi_type1_srs();\r\nbreak;\r\ncase SONYPI_DEVICE_MODEL_TYPE2:\r\nsonypi_type2_srs();\r\nbreak;\r\ncase SONYPI_DEVICE_MODEL_TYPE3:\r\nsonypi_type3_srs();\r\nbreak;\r\n}\r\nsonypi_call1(0x82);\r\nsonypi_call2(0x81, 0xff);\r\nsonypi_call1(compat ? 0x92 : 0x82);\r\nif (!SONYPI_ACPI_ACTIVE && fnkeyinit)\r\noutb(0xf0, 0xb2);\r\nif (camera && camera_on)\r\nsonypi_camera_on();\r\n}\r\nstatic int sonypi_disable(void)\r\n{\r\nsonypi_call2(0x81, 0);\r\nif (camera)\r\nsonypi_camera_off();\r\nif (!SONYPI_ACPI_ACTIVE && fnkeyinit)\r\noutb(0xf1, 0xb2);\r\nswitch (sonypi_device.model) {\r\ncase SONYPI_DEVICE_MODEL_TYPE1:\r\nsonypi_type1_dis();\r\nbreak;\r\ncase SONYPI_DEVICE_MODEL_TYPE2:\r\nsonypi_type2_dis();\r\nbreak;\r\ncase SONYPI_DEVICE_MODEL_TYPE3:\r\nsonypi_type3_dis();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sonypi_acpi_add(struct acpi_device *device)\r\n{\r\nsonypi_acpi_device = device;\r\nstrcpy(acpi_device_name(device), "Sony laptop hotkeys");\r\nstrcpy(acpi_device_class(device), "sony/hotkey");\r\nreturn 0;\r\n}\r\nstatic int sonypi_acpi_remove(struct acpi_device *device)\r\n{\r\nsonypi_acpi_device = NULL;\r\nreturn 0;\r\n}\r\nstatic int sonypi_create_input_devices(struct platform_device *pdev)\r\n{\r\nstruct input_dev *jog_dev;\r\nstruct input_dev *key_dev;\r\nint i;\r\nint error;\r\nsonypi_device.input_jog_dev = jog_dev = input_allocate_device();\r\nif (!jog_dev)\r\nreturn -ENOMEM;\r\njog_dev->name = "Sony Vaio Jogdial";\r\njog_dev->id.bustype = BUS_ISA;\r\njog_dev->id.vendor = PCI_VENDOR_ID_SONY;\r\njog_dev->dev.parent = &pdev->dev;\r\njog_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\njog_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_MIDDLE);\r\njog_dev->relbit[0] = BIT_MASK(REL_WHEEL);\r\nsonypi_device.input_key_dev = key_dev = input_allocate_device();\r\nif (!key_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_jogdev;\r\n}\r\nkey_dev->name = "Sony Vaio Keys";\r\nkey_dev->id.bustype = BUS_ISA;\r\nkey_dev->id.vendor = PCI_VENDOR_ID_SONY;\r\nkey_dev->dev.parent = &pdev->dev;\r\nkey_dev->evbit[0] = BIT_MASK(EV_KEY);\r\nfor (i = 0; sonypi_inputkeys[i].sonypiev; i++)\r\nif (sonypi_inputkeys[i].inputev)\r\nset_bit(sonypi_inputkeys[i].inputev, key_dev->keybit);\r\nerror = input_register_device(jog_dev);\r\nif (error)\r\ngoto err_free_keydev;\r\nerror = input_register_device(key_dev);\r\nif (error)\r\ngoto err_unregister_jogdev;\r\nreturn 0;\r\nerr_unregister_jogdev:\r\ninput_unregister_device(jog_dev);\r\njog_dev = NULL;\r\nerr_free_keydev:\r\ninput_free_device(key_dev);\r\nsonypi_device.input_key_dev = NULL;\r\nerr_free_jogdev:\r\ninput_free_device(jog_dev);\r\nsonypi_device.input_jog_dev = NULL;\r\nreturn error;\r\n}\r\nstatic int sonypi_setup_ioports(struct sonypi_device *dev,\r\nconst struct sonypi_ioport_list *ioport_list)\r\n{\r\nconst struct sonypi_ioport_list *check = ioport_list;\r\nwhile (check_ioport && check->port1) {\r\nif (!request_region(check->port1,\r\nsonypi_device.region_size,\r\n"Sony Programmable I/O Device Check")) {\r\nprintk(KERN_ERR "sonypi: ioport 0x%.4x busy, using sony-laptop? "\r\n"if not use check_ioport=0\n",\r\ncheck->port1);\r\nreturn -EBUSY;\r\n}\r\nrelease_region(check->port1, sonypi_device.region_size);\r\ncheck++;\r\n}\r\nwhile (ioport_list->port1) {\r\nif (request_region(ioport_list->port1,\r\nsonypi_device.region_size,\r\n"Sony Programmable I/O Device")) {\r\ndev->ioport1 = ioport_list->port1;\r\ndev->ioport2 = ioport_list->port2;\r\nreturn 0;\r\n}\r\nioport_list++;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int sonypi_setup_irq(struct sonypi_device *dev,\r\nconst struct sonypi_irq_list *irq_list)\r\n{\r\nwhile (irq_list->irq) {\r\nif (!request_irq(irq_list->irq, sonypi_irq,\r\nIRQF_SHARED, "sonypi", sonypi_irq)) {\r\ndev->irq = irq_list->irq;\r\ndev->bits = irq_list->bits;\r\nreturn 0;\r\n}\r\nirq_list++;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic void sonypi_display_info(void)\r\n{\r\nprintk(KERN_INFO "sonypi: detected type%d model, "\r\n"verbose = %d, fnkeyinit = %s, camera = %s, "\r\n"compat = %s, mask = 0x%08lx, useinput = %s, acpi = %s\n",\r\nsonypi_device.model,\r\nverbose,\r\nfnkeyinit ? "on" : "off",\r\ncamera ? "on" : "off",\r\ncompat ? "on" : "off",\r\nmask,\r\nuseinput ? "on" : "off",\r\nSONYPI_ACPI_ACTIVE ? "on" : "off");\r\nprintk(KERN_INFO "sonypi: enabled at irq=%d, port1=0x%x, port2=0x%x\n",\r\nsonypi_device.irq,\r\nsonypi_device.ioport1, sonypi_device.ioport2);\r\nif (minor == -1)\r\nprintk(KERN_INFO "sonypi: device allocated minor is %d\n",\r\nsonypi_misc_device.minor);\r\n}\r\nstatic int sonypi_probe(struct platform_device *dev)\r\n{\r\nconst struct sonypi_ioport_list *ioport_list;\r\nconst struct sonypi_irq_list *irq_list;\r\nstruct pci_dev *pcidev;\r\nint error;\r\nprintk(KERN_WARNING "sonypi: please try the sony-laptop module instead "\r\n"and report failures, see also "\r\n"http://www.linux.it/~malattia/wiki/index.php/Sony_drivers\n");\r\nspin_lock_init(&sonypi_device.fifo_lock);\r\nerror = kfifo_alloc(&sonypi_device.fifo, SONYPI_BUF_SIZE, GFP_KERNEL);\r\nif (error) {\r\nprintk(KERN_ERR "sonypi: kfifo_alloc failed\n");\r\nreturn error;\r\n}\r\ninit_waitqueue_head(&sonypi_device.fifo_proc_list);\r\nmutex_init(&sonypi_device.lock);\r\nsonypi_device.bluetooth_power = -1;\r\nif ((pcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_3, NULL)))\r\nsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE1;\r\nelse if ((pcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH6_1, NULL)))\r\nsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE3;\r\nelse if ((pcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH7_1, NULL)))\r\nsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE3;\r\nelse\r\nsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE2;\r\nif (pcidev && pci_enable_device(pcidev)) {\r\nprintk(KERN_ERR "sonypi: pci_enable_device failed\n");\r\nerror = -EIO;\r\ngoto err_put_pcidev;\r\n}\r\nsonypi_device.dev = pcidev;\r\nif (sonypi_device.model == SONYPI_DEVICE_MODEL_TYPE1) {\r\nioport_list = sonypi_type1_ioport_list;\r\nsonypi_device.region_size = SONYPI_TYPE1_REGION_SIZE;\r\nsonypi_device.evtype_offset = SONYPI_TYPE1_EVTYPE_OFFSET;\r\nirq_list = sonypi_type1_irq_list;\r\n} else if (sonypi_device.model == SONYPI_DEVICE_MODEL_TYPE2) {\r\nioport_list = sonypi_type2_ioport_list;\r\nsonypi_device.region_size = SONYPI_TYPE2_REGION_SIZE;\r\nsonypi_device.evtype_offset = SONYPI_TYPE2_EVTYPE_OFFSET;\r\nirq_list = sonypi_type2_irq_list;\r\n} else {\r\nioport_list = sonypi_type3_ioport_list;\r\nsonypi_device.region_size = SONYPI_TYPE3_REGION_SIZE;\r\nsonypi_device.evtype_offset = SONYPI_TYPE3_EVTYPE_OFFSET;\r\nirq_list = sonypi_type3_irq_list;\r\n}\r\nerror = sonypi_setup_ioports(&sonypi_device, ioport_list);\r\nif (error) {\r\nprintk(KERN_ERR "sonypi: failed to request ioports\n");\r\ngoto err_disable_pcidev;\r\n}\r\nerror = sonypi_setup_irq(&sonypi_device, irq_list);\r\nif (error) {\r\nprintk(KERN_ERR "sonypi: request_irq failed\n");\r\ngoto err_free_ioports;\r\n}\r\nif (minor != -1)\r\nsonypi_misc_device.minor = minor;\r\nerror = misc_register(&sonypi_misc_device);\r\nif (error) {\r\nprintk(KERN_ERR "sonypi: misc_register failed\n");\r\ngoto err_free_irq;\r\n}\r\nsonypi_display_info();\r\nif (useinput) {\r\nerror = sonypi_create_input_devices(dev);\r\nif (error) {\r\nprintk(KERN_ERR\r\n"sonypi: failed to create input devices\n");\r\ngoto err_miscdev_unregister;\r\n}\r\nspin_lock_init(&sonypi_device.input_fifo_lock);\r\nerror = kfifo_alloc(&sonypi_device.input_fifo, SONYPI_BUF_SIZE,\r\nGFP_KERNEL);\r\nif (error) {\r\nprintk(KERN_ERR "sonypi: kfifo_alloc failed\n");\r\ngoto err_inpdev_unregister;\r\n}\r\nINIT_WORK(&sonypi_device.input_work, input_keyrelease);\r\n}\r\nsonypi_enable(0);\r\nreturn 0;\r\nerr_inpdev_unregister:\r\ninput_unregister_device(sonypi_device.input_key_dev);\r\ninput_unregister_device(sonypi_device.input_jog_dev);\r\nerr_miscdev_unregister:\r\nmisc_deregister(&sonypi_misc_device);\r\nerr_free_irq:\r\nfree_irq(sonypi_device.irq, sonypi_irq);\r\nerr_free_ioports:\r\nrelease_region(sonypi_device.ioport1, sonypi_device.region_size);\r\nerr_disable_pcidev:\r\nif (pcidev)\r\npci_disable_device(pcidev);\r\nerr_put_pcidev:\r\npci_dev_put(pcidev);\r\nkfifo_free(&sonypi_device.fifo);\r\nreturn error;\r\n}\r\nstatic int sonypi_remove(struct platform_device *dev)\r\n{\r\nsonypi_disable();\r\nsynchronize_irq(sonypi_device.irq);\r\nflush_work(&sonypi_device.input_work);\r\nif (useinput) {\r\ninput_unregister_device(sonypi_device.input_key_dev);\r\ninput_unregister_device(sonypi_device.input_jog_dev);\r\nkfifo_free(&sonypi_device.input_fifo);\r\n}\r\nmisc_deregister(&sonypi_misc_device);\r\nfree_irq(sonypi_device.irq, sonypi_irq);\r\nrelease_region(sonypi_device.ioport1, sonypi_device.region_size);\r\nif (sonypi_device.dev) {\r\npci_disable_device(sonypi_device.dev);\r\npci_dev_put(sonypi_device.dev);\r\n}\r\nkfifo_free(&sonypi_device.fifo);\r\nreturn 0;\r\n}\r\nstatic int sonypi_suspend(struct device *dev)\r\n{\r\nold_camera_power = sonypi_device.camera_power;\r\nsonypi_disable();\r\nreturn 0;\r\n}\r\nstatic int sonypi_resume(struct device *dev)\r\n{\r\nsonypi_enable(old_camera_power);\r\nreturn 0;\r\n}\r\nstatic void sonypi_shutdown(struct platform_device *dev)\r\n{\r\nsonypi_disable();\r\n}\r\nstatic int __init sonypi_init(void)\r\n{\r\nint error;\r\nprintk(KERN_INFO\r\n"sonypi: Sony Programmable I/O Controller Driver v%s.\n",\r\nSONYPI_DRIVER_VERSION);\r\nif (!dmi_check_system(sonypi_dmi_table))\r\nreturn -ENODEV;\r\nerror = platform_driver_register(&sonypi_driver);\r\nif (error)\r\nreturn error;\r\nsonypi_platform_device = platform_device_alloc("sonypi", -1);\r\nif (!sonypi_platform_device) {\r\nerror = -ENOMEM;\r\ngoto err_driver_unregister;\r\n}\r\nerror = platform_device_add(sonypi_platform_device);\r\nif (error)\r\ngoto err_free_device;\r\n#ifdef CONFIG_ACPI\r\nif (acpi_bus_register_driver(&sonypi_acpi_driver) >= 0)\r\nacpi_driver_registered = 1;\r\n#endif\r\nreturn 0;\r\nerr_free_device:\r\nplatform_device_put(sonypi_platform_device);\r\nerr_driver_unregister:\r\nplatform_driver_unregister(&sonypi_driver);\r\nreturn error;\r\n}\r\nstatic void __exit sonypi_exit(void)\r\n{\r\n#ifdef CONFIG_ACPI\r\nif (acpi_driver_registered)\r\nacpi_bus_unregister_driver(&sonypi_acpi_driver);\r\n#endif\r\nplatform_device_unregister(sonypi_platform_device);\r\nplatform_driver_unregister(&sonypi_driver);\r\nprintk(KERN_INFO "sonypi: removed.\n");\r\n}
