static inline u32 bl_regr(u32 offset)\r\n{\r\nreturn __raw_readl(oper_cfg.vpss_regs_base0 + offset);\r\n}\r\nstatic inline void bl_regw(u32 val, u32 offset)\r\n{\r\n__raw_writel(val, oper_cfg.vpss_regs_base0 + offset);\r\n}\r\nstatic inline u32 vpss_regr(u32 offset)\r\n{\r\nreturn __raw_readl(oper_cfg.vpss_regs_base1 + offset);\r\n}\r\nstatic inline void vpss_regw(u32 val, u32 offset)\r\n{\r\n__raw_writel(val, oper_cfg.vpss_regs_base1 + offset);\r\n}\r\nstatic inline u32 isp5_read(u32 offset)\r\n{\r\nreturn __raw_readl(oper_cfg.vpss_regs_base0 + offset);\r\n}\r\nstatic inline void isp5_write(u32 val, u32 offset)\r\n{\r\n__raw_writel(val, oper_cfg.vpss_regs_base0 + offset);\r\n}\r\nstatic void dm365_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)\r\n{\r\nu32 temp = isp5_read(DM365_ISP5_CCDCMUX) & ~CCD_SRC_SEL_MASK;\r\nif (src_sel == VPSS_PGLPBK || src_sel == VPSS_CCDCPG)\r\ntemp |= 0x08;\r\ntemp |= (src_sel << CCD_SRC_SEL_SHIFT);\r\nisp5_write(temp, DM365_ISP5_CCDCMUX);\r\n}\r\nstatic void dm355_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)\r\n{\r\nbl_regw(src_sel << VPSS_HSSISEL_SHIFT, DM355_VPSSBL_CCDCMUX);\r\n}\r\nint vpss_dma_complete_interrupt(void)\r\n{\r\nif (!oper_cfg.hw_ops.dma_complete_interrupt)\r\nreturn 2;\r\nreturn oper_cfg.hw_ops.dma_complete_interrupt();\r\n}\r\nint vpss_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)\r\n{\r\nif (!oper_cfg.hw_ops.select_ccdc_source)\r\nreturn -EINVAL;\r\noper_cfg.hw_ops.select_ccdc_source(src_sel);\r\nreturn 0;\r\n}\r\nstatic int dm644x_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel)\r\n{\r\nu32 mask = 1, val;\r\nif (wbl_sel < VPSS_PCR_AEW_WBL_0 ||\r\nwbl_sel > VPSS_PCR_CCDC_WBL_O)\r\nreturn -EINVAL;\r\nmask = ~(mask << wbl_sel);\r\nval = bl_regr(DM644X_SBL_PCR_VPSS) & mask;\r\nbl_regw(val, DM644X_SBL_PCR_VPSS);\r\nreturn 0;\r\n}\r\nvoid vpss_set_sync_pol(struct vpss_sync_pol sync)\r\n{\r\nif (!oper_cfg.hw_ops.set_sync_pol)\r\nreturn;\r\noper_cfg.hw_ops.set_sync_pol(sync);\r\n}\r\nint vpss_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel)\r\n{\r\nif (!oper_cfg.hw_ops.clear_wbl_overflow)\r\nreturn -EINVAL;\r\nreturn oper_cfg.hw_ops.clear_wbl_overflow(wbl_sel);\r\n}\r\nstatic int dm355_enable_clock(enum vpss_clock_sel clock_sel, int en)\r\n{\r\nunsigned long flags;\r\nu32 utemp, mask = 0x1, shift = 0;\r\nswitch (clock_sel) {\r\ncase VPSS_VPBE_CLOCK:\r\nbreak;\r\ncase VPSS_VENC_CLOCK_SEL:\r\nshift = 2;\r\nbreak;\r\ncase VPSS_CFALD_CLOCK:\r\nshift = 3;\r\nbreak;\r\ncase VPSS_H3A_CLOCK:\r\nshift = 4;\r\nbreak;\r\ncase VPSS_IPIPE_CLOCK:\r\nshift = 5;\r\nbreak;\r\ncase VPSS_CCDC_CLOCK:\r\nshift = 6;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "dm355_enable_clock:"\r\n" Invalid selector: %d\n", clock_sel);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&oper_cfg.vpss_lock, flags);\r\nutemp = vpss_regr(DM355_VPSSCLK_CLKCTRL);\r\nif (!en)\r\nutemp &= ~(mask << shift);\r\nelse\r\nutemp |= (mask << shift);\r\nvpss_regw(utemp, DM355_VPSSCLK_CLKCTRL);\r\nspin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dm365_enable_clock(enum vpss_clock_sel clock_sel, int en)\r\n{\r\nunsigned long flags;\r\nu32 utemp, mask = 0x1, shift = 0, offset = DM365_ISP5_PCCR;\r\nu32 (*read)(u32 offset) = isp5_read;\r\nvoid(*write)(u32 val, u32 offset) = isp5_write;\r\nswitch (clock_sel) {\r\ncase VPSS_BL_CLOCK:\r\nbreak;\r\ncase VPSS_CCDC_CLOCK:\r\nshift = 1;\r\nbreak;\r\ncase VPSS_H3A_CLOCK:\r\nshift = 2;\r\nbreak;\r\ncase VPSS_RSZ_CLOCK:\r\nshift = 3;\r\nbreak;\r\ncase VPSS_IPIPE_CLOCK:\r\nshift = 4;\r\nbreak;\r\ncase VPSS_IPIPEIF_CLOCK:\r\nshift = 5;\r\nbreak;\r\ncase VPSS_PCLK_INTERNAL:\r\nshift = 6;\r\nbreak;\r\ncase VPSS_PSYNC_CLOCK_SEL:\r\nshift = 7;\r\nbreak;\r\ncase VPSS_VPBE_CLOCK:\r\nread = vpss_regr;\r\nwrite = vpss_regw;\r\noffset = DM365_VPBE_CLK_CTRL;\r\nbreak;\r\ncase VPSS_VENC_CLOCK_SEL:\r\nshift = 2;\r\nread = vpss_regr;\r\nwrite = vpss_regw;\r\noffset = DM365_VPBE_CLK_CTRL;\r\nbreak;\r\ncase VPSS_LDC_CLOCK:\r\nshift = 3;\r\nread = vpss_regr;\r\nwrite = vpss_regw;\r\noffset = DM365_VPBE_CLK_CTRL;\r\nbreak;\r\ncase VPSS_FDIF_CLOCK:\r\nshift = 4;\r\nread = vpss_regr;\r\nwrite = vpss_regw;\r\noffset = DM365_VPBE_CLK_CTRL;\r\nbreak;\r\ncase VPSS_OSD_CLOCK_SEL:\r\nshift = 6;\r\nread = vpss_regr;\r\nwrite = vpss_regw;\r\noffset = DM365_VPBE_CLK_CTRL;\r\nbreak;\r\ncase VPSS_LDC_CLOCK_SEL:\r\nshift = 7;\r\nread = vpss_regr;\r\nwrite = vpss_regw;\r\noffset = DM365_VPBE_CLK_CTRL;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "dm365_enable_clock: Invalid selector: %d\n",\r\nclock_sel);\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&oper_cfg.vpss_lock, flags);\r\nutemp = read(offset);\r\nif (!en) {\r\nmask = ~mask;\r\nutemp &= (mask << shift);\r\n} else\r\nutemp |= (mask << shift);\r\nwrite(utemp, offset);\r\nspin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);\r\nreturn 0;\r\n}\r\nint vpss_enable_clock(enum vpss_clock_sel clock_sel, int en)\r\n{\r\nif (!oper_cfg.hw_ops.enable_clock)\r\nreturn -EINVAL;\r\nreturn oper_cfg.hw_ops.enable_clock(clock_sel, en);\r\n}\r\nvoid dm365_vpss_set_sync_pol(struct vpss_sync_pol sync)\r\n{\r\nint val = 0;\r\nval = isp5_read(DM365_ISP5_CCDCMUX);\r\nval |= (sync.ccdpg_hdpol << DM365_CCDC_PG_HD_POL_SHIFT);\r\nval |= (sync.ccdpg_vdpol << DM365_CCDC_PG_VD_POL_SHIFT);\r\nisp5_write(val, DM365_ISP5_CCDCMUX);\r\n}\r\nvoid vpss_set_pg_frame_size(struct vpss_pg_frame_size frame_size)\r\n{\r\nif (!oper_cfg.hw_ops.set_pg_frame_size)\r\nreturn;\r\noper_cfg.hw_ops.set_pg_frame_size(frame_size);\r\n}\r\nvoid dm365_vpss_set_pg_frame_size(struct vpss_pg_frame_size frame_size)\r\n{\r\nint current_reg = ((frame_size.hlpfr >> 1) - 1) << 16;\r\ncurrent_reg |= (frame_size.pplen - 1);\r\nisp5_write(current_reg, DM365_ISP5_PG_FRAME_SIZE);\r\n}\r\nstatic int vpss_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r1, *r2;\r\nchar *platform_name;\r\nint status;\r\nif (!pdev->dev.platform_data) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -ENOENT;\r\n}\r\nplatform_name = pdev->dev.platform_data;\r\nif (!strcmp(platform_name, "dm355_vpss"))\r\noper_cfg.platform = DM355;\r\nelse if (!strcmp(platform_name, "dm365_vpss"))\r\noper_cfg.platform = DM365;\r\nelse if (!strcmp(platform_name, "dm644x_vpss"))\r\noper_cfg.platform = DM644X;\r\nelse {\r\ndev_err(&pdev->dev, "vpss driver not supported on"\r\n" this platform\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(&pdev->dev, "%s vpss probed\n", platform_name);\r\nr1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r1)\r\nreturn -ENOENT;\r\nr1 = request_mem_region(r1->start, resource_size(r1), r1->name);\r\nif (!r1)\r\nreturn -EBUSY;\r\noper_cfg.vpss_regs_base0 = ioremap(r1->start, resource_size(r1));\r\nif (!oper_cfg.vpss_regs_base0) {\r\nstatus = -EBUSY;\r\ngoto fail1;\r\n}\r\nif (oper_cfg.platform == DM355 || oper_cfg.platform == DM365) {\r\nr2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r2) {\r\nstatus = -ENOENT;\r\ngoto fail2;\r\n}\r\nr2 = request_mem_region(r2->start, resource_size(r2), r2->name);\r\nif (!r2) {\r\nstatus = -EBUSY;\r\ngoto fail2;\r\n}\r\noper_cfg.vpss_regs_base1 = ioremap(r2->start,\r\nresource_size(r2));\r\nif (!oper_cfg.vpss_regs_base1) {\r\nstatus = -EBUSY;\r\ngoto fail3;\r\n}\r\n}\r\nif (oper_cfg.platform == DM355) {\r\noper_cfg.hw_ops.enable_clock = dm355_enable_clock;\r\noper_cfg.hw_ops.select_ccdc_source = dm355_select_ccdc_source;\r\nbl_regw(DM355_VPSSBL_INTSEL_DEFAULT, DM355_VPSSBL_INTSEL);\r\nbl_regw(DM355_VPSSBL_EVTSEL_DEFAULT, DM355_VPSSBL_EVTSEL);\r\n} else if (oper_cfg.platform == DM365) {\r\noper_cfg.hw_ops.enable_clock = dm365_enable_clock;\r\noper_cfg.hw_ops.select_ccdc_source = dm365_select_ccdc_source;\r\nisp5_write((isp5_read(DM365_ISP5_PCCR) |\r\nDM365_ISP5_PCCR_BL_CLK_ENABLE |\r\nDM365_ISP5_PCCR_ISIF_CLK_ENABLE |\r\nDM365_ISP5_PCCR_H3A_CLK_ENABLE |\r\nDM365_ISP5_PCCR_RSZ_CLK_ENABLE |\r\nDM365_ISP5_PCCR_IPIPE_CLK_ENABLE |\r\nDM365_ISP5_PCCR_IPIPEIF_CLK_ENABLE |\r\nDM365_ISP5_PCCR_RSV), DM365_ISP5_PCCR);\r\nisp5_write((isp5_read(DM365_ISP5_BCR) |\r\nDM365_ISP5_BCR_ISIF_OUT_ENABLE), DM365_ISP5_BCR);\r\nisp5_write(DM365_ISP5_INTSEL1_DEFAULT, DM365_ISP5_INTSEL1);\r\nisp5_write(DM365_ISP5_INTSEL2_DEFAULT, DM365_ISP5_INTSEL2);\r\nisp5_write(DM365_ISP5_INTSEL3_DEFAULT, DM365_ISP5_INTSEL3);\r\n} else\r\noper_cfg.hw_ops.clear_wbl_overflow = dm644x_clear_wbl_overflow;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get(&pdev->dev);\r\nspin_lock_init(&oper_cfg.vpss_lock);\r\ndev_info(&pdev->dev, "%s vpss probe success\n", platform_name);\r\nreturn 0;\r\nfail3:\r\nrelease_mem_region(r2->start, resource_size(r2));\r\nfail2:\r\niounmap(oper_cfg.vpss_regs_base0);\r\nfail1:\r\nrelease_mem_region(r1->start, resource_size(r1));\r\nreturn status;\r\n}\r\nstatic int vpss_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\npm_runtime_disable(&pdev->dev);\r\niounmap(oper_cfg.vpss_regs_base0);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nif (oper_cfg.platform == DM355 || oper_cfg.platform == DM365) {\r\niounmap(oper_cfg.vpss_regs_base1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrelease_mem_region(res->start, resource_size(res));\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpss_suspend(struct device *dev)\r\n{\r\npm_runtime_put(dev);\r\nreturn 0;\r\n}\r\nstatic int vpss_resume(struct device *dev)\r\n{\r\npm_runtime_get(dev);\r\nreturn 0;\r\n}\r\nstatic void vpss_exit(void)\r\n{\r\niounmap(oper_cfg.vpss_regs_base2);\r\nrelease_mem_region(VPSS_CLK_CTRL, 4);\r\nplatform_driver_unregister(&vpss_driver);\r\n}\r\nstatic int __init vpss_init(void)\r\n{\r\nif (!request_mem_region(VPSS_CLK_CTRL, 4, "vpss_clock_control"))\r\nreturn -EBUSY;\r\noper_cfg.vpss_regs_base2 = ioremap(VPSS_CLK_CTRL, 4);\r\nwritel(VPSS_CLK_CTRL_VENCCLKEN |\r\nVPSS_CLK_CTRL_DACCLKEN, oper_cfg.vpss_regs_base2);\r\nreturn platform_driver_register(&vpss_driver);\r\n}
