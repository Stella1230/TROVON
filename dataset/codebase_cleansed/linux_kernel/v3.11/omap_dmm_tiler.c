static void *alloc_dma(struct dmm_txn *txn, size_t sz, dma_addr_t *pa)\r\n{\r\nvoid *ptr;\r\nstruct refill_engine *engine = txn->engine_handle;\r\ntxn->current_pa = round_up(txn->current_pa, 16);\r\ntxn->current_va = (void *)round_up((long)txn->current_va, 16);\r\nptr = txn->current_va;\r\n*pa = txn->current_pa;\r\ntxn->current_pa += sz;\r\ntxn->current_va += sz;\r\nBUG_ON((txn->current_va - engine->refill_va) > REFILL_BUFFER_SIZE);\r\nreturn ptr;\r\n}\r\nstatic int wait_status(struct refill_engine *engine, uint32_t wait_mask)\r\n{\r\nstruct dmm *dmm = engine->dmm;\r\nuint32_t r = 0, err, i;\r\ni = DMM_FIXED_RETRY_COUNT;\r\nwhile (true) {\r\nr = readl(dmm->base + reg[PAT_STATUS][engine->id]);\r\nerr = r & DMM_PATSTATUS_ERR;\r\nif (err)\r\nreturn -EFAULT;\r\nif ((r & wait_mask) == wait_mask)\r\nbreak;\r\nif (--i == 0)\r\nreturn -ETIMEDOUT;\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_engine(struct refill_engine *engine)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_add(&engine->idle_node, &omap_dmm->idle_head);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\natomic_inc(&omap_dmm->engine_counter);\r\nwake_up_interruptible(&omap_dmm->engine_queue);\r\n}\r\nstatic irqreturn_t omap_dmm_irq_handler(int irq, void *arg)\r\n{\r\nstruct dmm *dmm = arg;\r\nuint32_t status = readl(dmm->base + DMM_PAT_IRQSTATUS);\r\nint i;\r\nwritel(status, dmm->base + DMM_PAT_IRQSTATUS);\r\nfor (i = 0; i < dmm->num_engines; i++) {\r\nif (status & DMM_IRQSTAT_LST) {\r\nwake_up_interruptible(&dmm->engines[i].wait_for_refill);\r\nif (dmm->engines[i].async)\r\nrelease_engine(&dmm->engines[i]);\r\n}\r\nstatus >>= 8;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct dmm_txn *dmm_txn_init(struct dmm *dmm, struct tcm *tcm)\r\n{\r\nstruct dmm_txn *txn = NULL;\r\nstruct refill_engine *engine = NULL;\r\nint ret;\r\nunsigned long flags;\r\nret = wait_event_interruptible(omap_dmm->engine_queue,\r\natomic_add_unless(&omap_dmm->engine_counter, -1, 0));\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nspin_lock_irqsave(&list_lock, flags);\r\nif (!list_empty(&dmm->idle_head)) {\r\nengine = list_entry(dmm->idle_head.next, struct refill_engine,\r\nidle_node);\r\nlist_del(&engine->idle_node);\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nBUG_ON(!engine);\r\ntxn = &engine->txn;\r\nengine->tcm = tcm;\r\ntxn->engine_handle = engine;\r\ntxn->last_pat = NULL;\r\ntxn->current_va = engine->refill_va;\r\ntxn->current_pa = engine->refill_pa;\r\nreturn txn;\r\n}\r\nstatic void dmm_txn_append(struct dmm_txn *txn, struct pat_area *area,\r\nstruct page **pages, uint32_t npages, uint32_t roll)\r\n{\r\ndma_addr_t pat_pa = 0;\r\nuint32_t *data;\r\nstruct pat *pat;\r\nstruct refill_engine *engine = txn->engine_handle;\r\nint columns = (1 + area->x1 - area->x0);\r\nint rows = (1 + area->y1 - area->y0);\r\nint i = columns*rows;\r\npat = alloc_dma(txn, sizeof(struct pat), &pat_pa);\r\nif (txn->last_pat)\r\ntxn->last_pat->next_pa = (uint32_t)pat_pa;\r\npat->area = *area;\r\npat->area.y0 += engine->tcm->y_offset;\r\npat->area.y1 += engine->tcm->y_offset;\r\npat->ctrl = (struct pat_ctrl){\r\n.start = 1,\r\n.lut_id = engine->tcm->lut_id,\r\n};\r\ndata = alloc_dma(txn, 4*i, &pat->data_pa);\r\nwhile (i--) {\r\nint n = i + roll;\r\nif (n >= npages)\r\nn -= npages;\r\ndata[i] = (pages && pages[n]) ?\r\npage_to_phys(pages[n]) : engine->dmm->dummy_pa;\r\n}\r\ntxn->last_pat = pat;\r\nreturn;\r\n}\r\nstatic int dmm_txn_commit(struct dmm_txn *txn, bool wait)\r\n{\r\nint ret = 0;\r\nstruct refill_engine *engine = txn->engine_handle;\r\nstruct dmm *dmm = engine->dmm;\r\nif (!txn->last_pat) {\r\ndev_err(engine->dmm->dev, "need at least one txn\n");\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\ntxn->last_pat->next_pa = 0;\r\nwritel(0x0, dmm->base + reg[PAT_DESCR][engine->id]);\r\nret = wait_status(engine, DMM_PATSTATUS_READY);\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto cleanup;\r\n}\r\nengine->async = wait ? false : true;\r\nwritel(engine->refill_pa,\r\ndmm->base + reg[PAT_DESCR][engine->id]);\r\nif (wait) {\r\nif (wait_event_interruptible_timeout(engine->wait_for_refill,\r\nwait_status(engine, DMM_PATSTATUS_READY) == 0,\r\nmsecs_to_jiffies(1)) <= 0) {\r\ndev_err(dmm->dev, "timed out waiting for done\n");\r\nret = -ETIMEDOUT;\r\n}\r\n}\r\ncleanup:\r\nif (ret || wait)\r\nrelease_engine(engine);\r\nreturn ret;\r\n}\r\nstatic int fill(struct tcm_area *area, struct page **pages,\r\nuint32_t npages, uint32_t roll, bool wait)\r\n{\r\nint ret = 0;\r\nstruct tcm_area slice, area_s;\r\nstruct dmm_txn *txn;\r\ntxn = dmm_txn_init(omap_dmm, area->tcm);\r\nif (IS_ERR_OR_NULL(txn))\r\nreturn -ENOMEM;\r\ntcm_for_each_slice(slice, *area, area_s) {\r\nstruct pat_area p_area = {\r\n.x0 = slice.p0.x, .y0 = slice.p0.y,\r\n.x1 = slice.p1.x, .y1 = slice.p1.y,\r\n};\r\ndmm_txn_append(txn, &p_area, pages, npages, roll);\r\nroll += tcm_sizeof(slice);\r\n}\r\nret = dmm_txn_commit(txn, wait);\r\nreturn ret;\r\n}\r\nint tiler_pin(struct tiler_block *block, struct page **pages,\r\nuint32_t npages, uint32_t roll, bool wait)\r\n{\r\nint ret;\r\nret = fill(&block->area, pages, npages, roll, wait);\r\nif (ret)\r\ntiler_unpin(block);\r\nreturn ret;\r\n}\r\nint tiler_unpin(struct tiler_block *block)\r\n{\r\nreturn fill(&block->area, NULL, 0, 0, false);\r\n}\r\nstruct tiler_block *tiler_reserve_2d(enum tiler_fmt fmt, uint16_t w,\r\nuint16_t h, uint16_t align)\r\n{\r\nstruct tiler_block *block = kzalloc(sizeof(*block), GFP_KERNEL);\r\nu32 min_align = 128;\r\nint ret;\r\nunsigned long flags;\r\nBUG_ON(!validfmt(fmt));\r\nw = DIV_ROUND_UP(w, geom[fmt].slot_w);\r\nh = DIV_ROUND_UP(h, geom[fmt].slot_h);\r\nmin_align = max(min_align, (geom[fmt].slot_w * geom[fmt].cpp));\r\nalign = ALIGN(align, min_align);\r\nalign /= geom[fmt].slot_w * geom[fmt].cpp;\r\nblock->fmt = fmt;\r\nret = tcm_reserve_2d(containers[fmt], w, h, align, &block->area);\r\nif (ret) {\r\nkfree(block);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_add(&block->alloc_node, &omap_dmm->alloc_head);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn block;\r\n}\r\nstruct tiler_block *tiler_reserve_1d(size_t size)\r\n{\r\nstruct tiler_block *block = kzalloc(sizeof(*block), GFP_KERNEL);\r\nint num_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long flags;\r\nif (!block)\r\nreturn ERR_PTR(-ENOMEM);\r\nblock->fmt = TILFMT_PAGE;\r\nif (tcm_reserve_1d(containers[TILFMT_PAGE], num_pages,\r\n&block->area)) {\r\nkfree(block);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_add(&block->alloc_node, &omap_dmm->alloc_head);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn block;\r\n}\r\nint tiler_release(struct tiler_block *block)\r\n{\r\nint ret = tcm_free(&block->area);\r\nunsigned long flags;\r\nif (block->area.tcm)\r\ndev_err(omap_dmm->dev, "failed to release block\n");\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_del(&block->alloc_node);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nkfree(block);\r\nreturn ret;\r\n}\r\nstatic u32 tiler_get_address(enum tiler_fmt fmt, u32 orient, u32 x, u32 y)\r\n{\r\nu32 x_bits, y_bits, tmp, x_mask, y_mask, alignment;\r\nx_bits = CONT_WIDTH_BITS - geom[fmt].x_shft;\r\ny_bits = CONT_HEIGHT_BITS - geom[fmt].y_shft;\r\nalignment = geom[fmt].x_shft + geom[fmt].y_shft;\r\nx_mask = MASK(x_bits);\r\ny_mask = MASK(y_bits);\r\nif (x < 0 || x > x_mask || y < 0 || y > y_mask) {\r\nDBG("invalid coords: %u < 0 || %u > %u || %u < 0 || %u > %u",\r\nx, x, x_mask, y, y, y_mask);\r\nreturn 0;\r\n}\r\nif (orient & MASK_X_INVERT)\r\nx ^= x_mask;\r\nif (orient & MASK_Y_INVERT)\r\ny ^= y_mask;\r\nif (orient & MASK_XY_FLIP)\r\ntmp = ((x << y_bits) + y);\r\nelse\r\ntmp = ((y << x_bits) + x);\r\nreturn TIL_ADDR((tmp << alignment), orient, fmt);\r\n}\r\ndma_addr_t tiler_ssptr(struct tiler_block *block)\r\n{\r\nBUG_ON(!validfmt(block->fmt));\r\nreturn TILVIEW_8BIT + tiler_get_address(block->fmt, 0,\r\nblock->area.p0.x * geom[block->fmt].slot_w,\r\nblock->area.p0.y * geom[block->fmt].slot_h);\r\n}\r\ndma_addr_t tiler_tsptr(struct tiler_block *block, uint32_t orient,\r\nuint32_t x, uint32_t y)\r\n{\r\nstruct tcm_pt *p = &block->area.p0;\r\nBUG_ON(!validfmt(block->fmt));\r\nreturn tiler_get_address(block->fmt, orient,\r\n(p->x * geom[block->fmt].slot_w) + x,\r\n(p->y * geom[block->fmt].slot_h) + y);\r\n}\r\nvoid tiler_align(enum tiler_fmt fmt, uint16_t *w, uint16_t *h)\r\n{\r\nBUG_ON(!validfmt(fmt));\r\n*w = round_up(*w, geom[fmt].slot_w);\r\n*h = round_up(*h, geom[fmt].slot_h);\r\n}\r\nuint32_t tiler_stride(enum tiler_fmt fmt, uint32_t orient)\r\n{\r\nBUG_ON(!validfmt(fmt));\r\nif (orient & MASK_XY_FLIP)\r\nreturn 1 << (CONT_HEIGHT_BITS + geom[fmt].x_shft);\r\nelse\r\nreturn 1 << (CONT_WIDTH_BITS + geom[fmt].y_shft);\r\n}\r\nsize_t tiler_size(enum tiler_fmt fmt, uint16_t w, uint16_t h)\r\n{\r\ntiler_align(fmt, &w, &h);\r\nreturn geom[fmt].cpp * w * h;\r\n}\r\nsize_t tiler_vsize(enum tiler_fmt fmt, uint16_t w, uint16_t h)\r\n{\r\nBUG_ON(!validfmt(fmt));\r\nreturn round_up(geom[fmt].cpp * w, PAGE_SIZE) * h;\r\n}\r\nbool dmm_is_available(void)\r\n{\r\nreturn omap_dmm ? true : false;\r\n}\r\nstatic int omap_dmm_remove(struct platform_device *dev)\r\n{\r\nstruct tiler_block *block, *_block;\r\nint i;\r\nunsigned long flags;\r\nif (omap_dmm) {\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_for_each_entry_safe(block, _block, &omap_dmm->alloc_head,\r\nalloc_node) {\r\nlist_del(&block->alloc_node);\r\nkfree(block);\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nfor (i = 0; i < omap_dmm->num_lut; i++)\r\nif (omap_dmm->tcm && omap_dmm->tcm[i])\r\nomap_dmm->tcm[i]->deinit(omap_dmm->tcm[i]);\r\nkfree(omap_dmm->tcm);\r\nkfree(omap_dmm->engines);\r\nif (omap_dmm->refill_va)\r\ndma_free_writecombine(omap_dmm->dev,\r\nREFILL_BUFFER_SIZE * omap_dmm->num_engines,\r\nomap_dmm->refill_va,\r\nomap_dmm->refill_pa);\r\nif (omap_dmm->dummy_page)\r\n__free_page(omap_dmm->dummy_page);\r\nif (omap_dmm->irq > 0)\r\nfree_irq(omap_dmm->irq, omap_dmm);\r\niounmap(omap_dmm->base);\r\nkfree(omap_dmm);\r\nomap_dmm = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_dmm_probe(struct platform_device *dev)\r\n{\r\nint ret = -EFAULT, i;\r\nstruct tcm_area area = {0};\r\nu32 hwinfo, pat_geom;\r\nstruct resource *mem;\r\nomap_dmm = kzalloc(sizeof(*omap_dmm), GFP_KERNEL);\r\nif (!omap_dmm)\r\ngoto fail;\r\nINIT_LIST_HEAD(&omap_dmm->alloc_head);\r\nINIT_LIST_HEAD(&omap_dmm->idle_head);\r\ninit_waitqueue_head(&omap_dmm->engine_queue);\r\nmem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&dev->dev, "failed to get base address resource\n");\r\ngoto fail;\r\n}\r\nomap_dmm->base = ioremap(mem->start, SZ_2K);\r\nif (!omap_dmm->base) {\r\ndev_err(&dev->dev, "failed to get dmm base address\n");\r\ngoto fail;\r\n}\r\nomap_dmm->irq = platform_get_irq(dev, 0);\r\nif (omap_dmm->irq < 0) {\r\ndev_err(&dev->dev, "failed to get IRQ resource\n");\r\ngoto fail;\r\n}\r\nomap_dmm->dev = &dev->dev;\r\nhwinfo = readl(omap_dmm->base + DMM_PAT_HWINFO);\r\nomap_dmm->num_engines = (hwinfo >> 24) & 0x1F;\r\nomap_dmm->num_lut = (hwinfo >> 16) & 0x1F;\r\nomap_dmm->container_width = 256;\r\nomap_dmm->container_height = 128;\r\natomic_set(&omap_dmm->engine_counter, omap_dmm->num_engines);\r\npat_geom = readl(omap_dmm->base + DMM_PAT_GEOMETRY);\r\nomap_dmm->lut_width = ((pat_geom >> 16) & 0xF) << 5;\r\nomap_dmm->lut_height = ((pat_geom >> 24) & 0xF) << 5;\r\nif (omap_dmm->lut_height != omap_dmm->container_height)\r\nomap_dmm->num_lut++;\r\nwritel(0x88888888, omap_dmm->base + DMM_PAT_VIEW__0);\r\nwritel(0x88888888, omap_dmm->base + DMM_PAT_VIEW__1);\r\nwritel(0x80808080, omap_dmm->base + DMM_PAT_VIEW_MAP__0);\r\nwritel(0x80000000, omap_dmm->base + DMM_PAT_VIEW_MAP_BASE);\r\nwritel(0x88888888, omap_dmm->base + DMM_TILER_OR__0);\r\nwritel(0x88888888, omap_dmm->base + DMM_TILER_OR__1);\r\nret = request_irq(omap_dmm->irq, omap_dmm_irq_handler, IRQF_SHARED,\r\n"omap_dmm_irq_handler", omap_dmm);\r\nif (ret) {\r\ndev_err(&dev->dev, "couldn't register IRQ %d, error %d\n",\r\nomap_dmm->irq, ret);\r\nomap_dmm->irq = -1;\r\ngoto fail;\r\n}\r\nwritel(0x7e7e7e7e, omap_dmm->base + DMM_PAT_IRQENABLE_SET);\r\nomap_dmm->dummy_page = alloc_page(GFP_KERNEL | __GFP_DMA32);\r\nif (!omap_dmm->dummy_page) {\r\ndev_err(&dev->dev, "could not allocate dummy page\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ndev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\nomap_dmm->dummy_pa = page_to_phys(omap_dmm->dummy_page);\r\nomap_dmm->refill_va = dma_alloc_writecombine(&dev->dev,\r\nREFILL_BUFFER_SIZE * omap_dmm->num_engines,\r\n&omap_dmm->refill_pa, GFP_KERNEL);\r\nif (!omap_dmm->refill_va) {\r\ndev_err(&dev->dev, "could not allocate refill memory\n");\r\ngoto fail;\r\n}\r\nomap_dmm->engines = kcalloc(omap_dmm->num_engines,\r\nsizeof(struct refill_engine), GFP_KERNEL);\r\nif (!omap_dmm->engines) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfor (i = 0; i < omap_dmm->num_engines; i++) {\r\nomap_dmm->engines[i].id = i;\r\nomap_dmm->engines[i].dmm = omap_dmm;\r\nomap_dmm->engines[i].refill_va = omap_dmm->refill_va +\r\n(REFILL_BUFFER_SIZE * i);\r\nomap_dmm->engines[i].refill_pa = omap_dmm->refill_pa +\r\n(REFILL_BUFFER_SIZE * i);\r\ninit_waitqueue_head(&omap_dmm->engines[i].wait_for_refill);\r\nlist_add(&omap_dmm->engines[i].idle_node, &omap_dmm->idle_head);\r\n}\r\nomap_dmm->tcm = kcalloc(omap_dmm->num_lut, sizeof(*omap_dmm->tcm),\r\nGFP_KERNEL);\r\nif (!omap_dmm->tcm) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfor (i = 0; i < omap_dmm->num_lut; i++) {\r\nomap_dmm->tcm[i] = sita_init(omap_dmm->container_width,\r\nomap_dmm->container_height,\r\nNULL);\r\nif (!omap_dmm->tcm[i]) {\r\ndev_err(&dev->dev, "failed to allocate container\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nomap_dmm->tcm[i]->lut_id = i;\r\n}\r\ncontainers[TILFMT_8BIT] = omap_dmm->tcm[0];\r\ncontainers[TILFMT_16BIT] = omap_dmm->tcm[0];\r\ncontainers[TILFMT_32BIT] = omap_dmm->tcm[0];\r\nif (omap_dmm->container_height != omap_dmm->lut_height) {\r\ncontainers[TILFMT_PAGE] = omap_dmm->tcm[1];\r\nomap_dmm->tcm[1]->y_offset = OMAP5_LUT_OFFSET;\r\nomap_dmm->tcm[1]->lut_id = 0;\r\n} else {\r\ncontainers[TILFMT_PAGE] = omap_dmm->tcm[0];\r\n}\r\narea = (struct tcm_area) {\r\n.tcm = NULL,\r\n.p1.x = omap_dmm->container_width - 1,\r\n.p1.y = omap_dmm->container_height - 1,\r\n};\r\nfor (i = 0; i < omap_dmm->num_lut; i++) {\r\narea.tcm = omap_dmm->tcm[i];\r\nif (fill(&area, NULL, 0, 0, true))\r\ndev_err(omap_dmm->dev, "refill failed");\r\n}\r\ndev_info(omap_dmm->dev, "initialized all PAT entries\n");\r\nreturn 0;\r\nfail:\r\nif (omap_dmm_remove(dev))\r\ndev_err(&dev->dev, "cleanup failed\n");\r\nreturn ret;\r\n}\r\nstatic void fill_map(char **map, int xdiv, int ydiv, struct tcm_area *a,\r\nchar c, bool ovw)\r\n{\r\nint x, y;\r\nfor (y = a->p0.y / ydiv; y <= a->p1.y / ydiv; y++)\r\nfor (x = a->p0.x / xdiv; x <= a->p1.x / xdiv; x++)\r\nif (map[y][x] == ' ' || ovw)\r\nmap[y][x] = c;\r\n}\r\nstatic void fill_map_pt(char **map, int xdiv, int ydiv, struct tcm_pt *p,\r\nchar c)\r\n{\r\nmap[p->y / ydiv][p->x / xdiv] = c;\r\n}\r\nstatic char read_map_pt(char **map, int xdiv, int ydiv, struct tcm_pt *p)\r\n{\r\nreturn map[p->y / ydiv][p->x / xdiv];\r\n}\r\nstatic int map_width(int xdiv, int x0, int x1)\r\n{\r\nreturn (x1 / xdiv) - (x0 / xdiv) + 1;\r\n}\r\nstatic void text_map(char **map, int xdiv, char *nice, int yd, int x0, int x1)\r\n{\r\nchar *p = map[yd] + (x0 / xdiv);\r\nint w = (map_width(xdiv, x0, x1) - strlen(nice)) / 2;\r\nif (w >= 0) {\r\np += w;\r\nwhile (*nice)\r\n*p++ = *nice++;\r\n}\r\n}\r\nstatic void map_1d_info(char **map, int xdiv, int ydiv, char *nice,\r\nstruct tcm_area *a)\r\n{\r\nsprintf(nice, "%dK", tcm_sizeof(*a) * 4);\r\nif (a->p0.y + 1 < a->p1.y) {\r\ntext_map(map, xdiv, nice, (a->p0.y + a->p1.y) / 2 / ydiv, 0,\r\n256 - 1);\r\n} else if (a->p0.y < a->p1.y) {\r\nif (strlen(nice) < map_width(xdiv, a->p0.x, 256 - 1))\r\ntext_map(map, xdiv, nice, a->p0.y / ydiv,\r\na->p0.x + xdiv, 256 - 1);\r\nelse if (strlen(nice) < map_width(xdiv, 0, a->p1.x))\r\ntext_map(map, xdiv, nice, a->p1.y / ydiv,\r\n0, a->p1.y - xdiv);\r\n} else if (strlen(nice) + 1 < map_width(xdiv, a->p0.x, a->p1.x)) {\r\ntext_map(map, xdiv, nice, a->p0.y / ydiv, a->p0.x, a->p1.x);\r\n}\r\n}\r\nstatic void map_2d_info(char **map, int xdiv, int ydiv, char *nice,\r\nstruct tcm_area *a)\r\n{\r\nsprintf(nice, "(%d*%d)", tcm_awidth(*a), tcm_aheight(*a));\r\nif (strlen(nice) + 1 < map_width(xdiv, a->p0.x, a->p1.x))\r\ntext_map(map, xdiv, nice, (a->p0.y + a->p1.y) / 2 / ydiv,\r\na->p0.x, a->p1.x);\r\n}\r\nint tiler_map_show(struct seq_file *s, void *arg)\r\n{\r\nint xdiv = 2, ydiv = 1;\r\nchar **map = NULL, *global_map;\r\nstruct tiler_block *block;\r\nstruct tcm_area a, p;\r\nint i;\r\nconst char *m2d = alphabet;\r\nconst char *a2d = special;\r\nconst char *m2dp = m2d, *a2dp = a2d;\r\nchar nice[128];\r\nint h_adj;\r\nint w_adj;\r\nunsigned long flags;\r\nint lut_idx;\r\nif (!omap_dmm) {\r\nreturn 0;\r\n}\r\nh_adj = omap_dmm->container_height / ydiv;\r\nw_adj = omap_dmm->container_width / xdiv;\r\nmap = kmalloc(h_adj * sizeof(*map), GFP_KERNEL);\r\nglobal_map = kmalloc((w_adj + 1) * h_adj, GFP_KERNEL);\r\nif (!map || !global_map)\r\ngoto error;\r\nfor (lut_idx = 0; lut_idx < omap_dmm->num_lut; lut_idx++) {\r\nmemset(map, 0, sizeof(h_adj * sizeof(*map)));\r\nmemset(global_map, ' ', (w_adj + 1) * h_adj);\r\nfor (i = 0; i < omap_dmm->container_height; i++) {\r\nmap[i] = global_map + i * (w_adj + 1);\r\nmap[i][w_adj] = 0;\r\n}\r\nspin_lock_irqsave(&list_lock, flags);\r\nlist_for_each_entry(block, &omap_dmm->alloc_head, alloc_node) {\r\nif (block->area.tcm == omap_dmm->tcm[lut_idx]) {\r\nif (block->fmt != TILFMT_PAGE) {\r\nfill_map(map, xdiv, ydiv, &block->area,\r\n*m2dp, true);\r\nif (!*++a2dp)\r\na2dp = a2d;\r\nif (!*++m2dp)\r\nm2dp = m2d;\r\nmap_2d_info(map, xdiv, ydiv, nice,\r\n&block->area);\r\n} else {\r\nbool start = read_map_pt(map, xdiv,\r\nydiv, &block->area.p0) == ' ';\r\nbool end = read_map_pt(map, xdiv, ydiv,\r\n&block->area.p1) == ' ';\r\ntcm_for_each_slice(a, block->area, p)\r\nfill_map(map, xdiv, ydiv, &a,\r\n'=', true);\r\nfill_map_pt(map, xdiv, ydiv,\r\n&block->area.p0,\r\nstart ? '<' : 'X');\r\nfill_map_pt(map, xdiv, ydiv,\r\n&block->area.p1,\r\nend ? '>' : 'X');\r\nmap_1d_info(map, xdiv, ydiv, nice,\r\n&block->area);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nif (s) {\r\nseq_printf(s, "CONTAINER %d DUMP BEGIN\n", lut_idx);\r\nfor (i = 0; i < 128; i++)\r\nseq_printf(s, "%03d:%s\n", i, map[i]);\r\nseq_printf(s, "CONTAINER %d DUMP END\n", lut_idx);\r\n} else {\r\ndev_dbg(omap_dmm->dev, "CONTAINER %d DUMP BEGIN\n",\r\nlut_idx);\r\nfor (i = 0; i < 128; i++)\r\ndev_dbg(omap_dmm->dev, "%03d:%s\n", i, map[i]);\r\ndev_dbg(omap_dmm->dev, "CONTAINER %d DUMP END\n",\r\nlut_idx);\r\n}\r\n}\r\nerror:\r\nkfree(map);\r\nkfree(global_map);\r\nreturn 0;\r\n}\r\nstatic int omap_dmm_resume(struct device *dev)\r\n{\r\nstruct tcm_area area;\r\nint i;\r\nif (!omap_dmm)\r\nreturn -ENODEV;\r\narea = (struct tcm_area) {\r\n.tcm = NULL,\r\n.p1.x = omap_dmm->container_width - 1,\r\n.p1.y = omap_dmm->container_height - 1,\r\n};\r\nfor (i = 0; i < omap_dmm->num_lut; i++) {\r\narea.tcm = omap_dmm->tcm[i];\r\nif (fill(&area, NULL, 0, 0, true))\r\ndev_err(dev, "refill failed");\r\n}\r\nreturn 0;\r\n}
