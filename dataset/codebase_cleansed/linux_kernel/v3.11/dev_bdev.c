static void request_complete(struct bio *bio, int err)\r\n{\r\ncomplete((struct completion *)bio->bi_private);\r\n}\r\nstatic int sync_request(struct page *page, struct block_device *bdev, int rw)\r\n{\r\nstruct bio bio;\r\nstruct bio_vec bio_vec;\r\nstruct completion complete;\r\nbio_init(&bio);\r\nbio.bi_max_vecs = 1;\r\nbio.bi_io_vec = &bio_vec;\r\nbio_vec.bv_page = page;\r\nbio_vec.bv_len = PAGE_SIZE;\r\nbio_vec.bv_offset = 0;\r\nbio.bi_vcnt = 1;\r\nbio.bi_size = PAGE_SIZE;\r\nbio.bi_bdev = bdev;\r\nbio.bi_sector = page->index * (PAGE_SIZE >> 9);\r\ninit_completion(&complete);\r\nbio.bi_private = &complete;\r\nbio.bi_end_io = request_complete;\r\nsubmit_bio(rw, &bio);\r\nwait_for_completion(&complete);\r\nreturn test_bit(BIO_UPTODATE, &bio.bi_flags) ? 0 : -EIO;\r\n}\r\nstatic int bdev_readpage(void *_sb, struct page *page)\r\n{\r\nstruct super_block *sb = _sb;\r\nstruct block_device *bdev = logfs_super(sb)->s_bdev;\r\nint err;\r\nerr = sync_request(page, bdev, READ);\r\nif (err) {\r\nClearPageUptodate(page);\r\nSetPageError(page);\r\n} else {\r\nSetPageUptodate(page);\r\nClearPageError(page);\r\n}\r\nunlock_page(page);\r\nreturn err;\r\n}\r\nstatic void writeseg_end_io(struct bio *bio, int err)\r\n{\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\r\nstruct super_block *sb = bio->bi_private;\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct page *page;\r\nBUG_ON(!uptodate);\r\nBUG_ON(err);\r\nBUG_ON(bio->bi_vcnt == 0);\r\ndo {\r\npage = bvec->bv_page;\r\nif (--bvec >= bio->bi_io_vec)\r\nprefetchw(&bvec->bv_page->flags);\r\nend_page_writeback(page);\r\npage_cache_release(page);\r\n} while (bvec >= bio->bi_io_vec);\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&super->s_pending_writes))\r\nwake_up(&wq);\r\n}\r\nstatic int __bdev_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\r\nsize_t nr_pages)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nstruct bio *bio;\r\nstruct page *page;\r\nunsigned int max_pages;\r\nint i;\r\nmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\r\nbio = bio_alloc(GFP_NOFS, max_pages);\r\nBUG_ON(!bio);\r\nfor (i = 0; i < nr_pages; i++) {\r\nif (i >= max_pages) {\r\nbio->bi_vcnt = i;\r\nbio->bi_size = i * PAGE_SIZE;\r\nbio->bi_bdev = super->s_bdev;\r\nbio->bi_sector = ofs >> 9;\r\nbio->bi_private = sb;\r\nbio->bi_end_io = writeseg_end_io;\r\natomic_inc(&super->s_pending_writes);\r\nsubmit_bio(WRITE, bio);\r\nofs += i * PAGE_SIZE;\r\nindex += i;\r\nnr_pages -= i;\r\ni = 0;\r\nbio = bio_alloc(GFP_NOFS, max_pages);\r\nBUG_ON(!bio);\r\n}\r\npage = find_lock_page(mapping, index + i);\r\nBUG_ON(!page);\r\nbio->bi_io_vec[i].bv_page = page;\r\nbio->bi_io_vec[i].bv_len = PAGE_SIZE;\r\nbio->bi_io_vec[i].bv_offset = 0;\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nunlock_page(page);\r\n}\r\nbio->bi_vcnt = nr_pages;\r\nbio->bi_size = nr_pages * PAGE_SIZE;\r\nbio->bi_bdev = super->s_bdev;\r\nbio->bi_sector = ofs >> 9;\r\nbio->bi_private = sb;\r\nbio->bi_end_io = writeseg_end_io;\r\natomic_inc(&super->s_pending_writes);\r\nsubmit_bio(WRITE, bio);\r\nreturn 0;\r\n}\r\nstatic void bdev_writeseg(struct super_block *sb, u64 ofs, size_t len)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nint head;\r\nBUG_ON(super->s_flags & LOGFS_SB_FLAG_RO);\r\nif (len == 0) {\r\nreturn;\r\n}\r\nhead = ofs & (PAGE_SIZE - 1);\r\nif (head) {\r\nofs -= head;\r\nlen += head;\r\n}\r\nlen = PAGE_ALIGN(len);\r\n__bdev_writeseg(sb, ofs, ofs >> PAGE_SHIFT, len >> PAGE_SHIFT);\r\n}\r\nstatic void erase_end_io(struct bio *bio, int err)\r\n{\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct super_block *sb = bio->bi_private;\r\nstruct logfs_super *super = logfs_super(sb);\r\nBUG_ON(!uptodate);\r\nBUG_ON(err);\r\nBUG_ON(bio->bi_vcnt == 0);\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&super->s_pending_writes))\r\nwake_up(&wq);\r\n}\r\nstatic int do_erase(struct super_block *sb, u64 ofs, pgoff_t index,\r\nsize_t nr_pages)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct bio *bio;\r\nunsigned int max_pages;\r\nint i;\r\nmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\r\nbio = bio_alloc(GFP_NOFS, max_pages);\r\nBUG_ON(!bio);\r\nfor (i = 0; i < nr_pages; i++) {\r\nif (i >= max_pages) {\r\nbio->bi_vcnt = i;\r\nbio->bi_size = i * PAGE_SIZE;\r\nbio->bi_bdev = super->s_bdev;\r\nbio->bi_sector = ofs >> 9;\r\nbio->bi_private = sb;\r\nbio->bi_end_io = erase_end_io;\r\natomic_inc(&super->s_pending_writes);\r\nsubmit_bio(WRITE, bio);\r\nofs += i * PAGE_SIZE;\r\nindex += i;\r\nnr_pages -= i;\r\ni = 0;\r\nbio = bio_alloc(GFP_NOFS, max_pages);\r\nBUG_ON(!bio);\r\n}\r\nbio->bi_io_vec[i].bv_page = super->s_erase_page;\r\nbio->bi_io_vec[i].bv_len = PAGE_SIZE;\r\nbio->bi_io_vec[i].bv_offset = 0;\r\n}\r\nbio->bi_vcnt = nr_pages;\r\nbio->bi_size = nr_pages * PAGE_SIZE;\r\nbio->bi_bdev = super->s_bdev;\r\nbio->bi_sector = ofs >> 9;\r\nbio->bi_private = sb;\r\nbio->bi_end_io = erase_end_io;\r\natomic_inc(&super->s_pending_writes);\r\nsubmit_bio(WRITE, bio);\r\nreturn 0;\r\n}\r\nstatic int bdev_erase(struct super_block *sb, loff_t to, size_t len,\r\nint ensure_write)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nBUG_ON(to & (PAGE_SIZE - 1));\r\nBUG_ON(len & (PAGE_SIZE - 1));\r\nif (super->s_flags & LOGFS_SB_FLAG_RO)\r\nreturn -EROFS;\r\nif (ensure_write) {\r\ndo_erase(sb, to, to >> PAGE_SHIFT, len >> PAGE_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bdev_sync(struct super_block *sb)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nwait_event(wq, atomic_read(&super->s_pending_writes) == 0);\r\n}\r\nstatic struct page *bdev_find_first_sb(struct super_block *sb, u64 *ofs)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nfiller_t *filler = bdev_readpage;\r\n*ofs = 0;\r\nreturn read_cache_page(mapping, 0, filler, sb);\r\n}\r\nstatic struct page *bdev_find_last_sb(struct super_block *sb, u64 *ofs)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct address_space *mapping = super->s_mapping_inode->i_mapping;\r\nfiller_t *filler = bdev_readpage;\r\nu64 pos = (super->s_bdev->bd_inode->i_size & ~0xfffULL) - 0x1000;\r\npgoff_t index = pos >> PAGE_SHIFT;\r\n*ofs = pos;\r\nreturn read_cache_page(mapping, index, filler, sb);\r\n}\r\nstatic int bdev_write_sb(struct super_block *sb, struct page *page)\r\n{\r\nstruct block_device *bdev = logfs_super(sb)->s_bdev;\r\nreturn sync_request(page, bdev, WRITE);\r\n}\r\nstatic void bdev_put_device(struct logfs_super *s)\r\n{\r\nblkdev_put(s->s_bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\r\n}\r\nstatic int bdev_can_write_buf(struct super_block *sb, u64 ofs)\r\n{\r\nreturn 0;\r\n}\r\nint logfs_get_sb_bdev(struct logfs_super *p, struct file_system_type *type,\r\nconst char *devname)\r\n{\r\nstruct block_device *bdev;\r\nbdev = blkdev_get_by_path(devname, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\r\ntype);\r\nif (IS_ERR(bdev))\r\nreturn PTR_ERR(bdev);\r\nif (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {\r\nint mtdnr = MINOR(bdev->bd_dev);\r\nblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\r\nreturn logfs_get_sb_mtd(p, mtdnr);\r\n}\r\np->s_bdev = bdev;\r\np->s_mtd = NULL;\r\np->s_devops = &bd_devops;\r\nreturn 0;\r\n}
