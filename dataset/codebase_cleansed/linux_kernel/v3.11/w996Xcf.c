static void w9968cf_write_fsb(struct sd *sd, u16* data)\r\n{\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\nu16 value;\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn;\r\nvalue = *data++;\r\nmemcpy(sd->gspca_dev.usb_buf, data, 6);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\nvalue, 0x06, sd->gspca_dev.usb_buf, 6, 500);\r\nif (ret < 0) {\r\npr_err("Write FSB registers failed (%d)\n", ret);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\n}\r\nstatic void w9968cf_write_sb(struct sd *sd, u16 value)\r\n{\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_sndctrlpipe(sd->gspca_dev.dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, 0x01, NULL, 0, 500);\r\nudelay(W9968CF_I2C_BUS_DELAY);\r\nif (ret < 0) {\r\npr_err("Write SB reg [01] %04x failed\n", value);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\n}\r\nstatic int w9968cf_read_sb(struct sd *sd)\r\n{\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn -1;\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\r\n1,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0x01, sd->gspca_dev.usb_buf, 2, 500);\r\nif (ret >= 0) {\r\nret = sd->gspca_dev.usb_buf[0] |\r\n(sd->gspca_dev.usb_buf[1] << 8);\r\n} else {\r\npr_err("Read SB reg [01] failed\n");\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\nudelay(W9968CF_I2C_BUS_DELAY);\r\nreturn ret;\r\n}\r\nstatic void w9968cf_upload_quantizationtables(struct sd *sd)\r\n{\r\nu16 a, b;\r\nint i, j;\r\nreg_w(sd, 0x39, 0x0010);\r\nfor (i = 0, j = 0; i < 32; i++, j += 2) {\r\na = Y_QUANTABLE[j] | ((unsigned)(Y_QUANTABLE[j + 1]) << 8);\r\nb = UV_QUANTABLE[j] | ((unsigned)(UV_QUANTABLE[j + 1]) << 8);\r\nreg_w(sd, 0x40 + i, a);\r\nreg_w(sd, 0x60 + i, b);\r\n}\r\nreg_w(sd, 0x39, 0x0012);\r\n}\r\nstatic void w9968cf_smbus_start(struct sd *sd)\r\n{\r\nw9968cf_write_sb(sd, 0x0011);\r\nw9968cf_write_sb(sd, 0x0010);\r\n}\r\nstatic void w9968cf_smbus_stop(struct sd *sd)\r\n{\r\nw9968cf_write_sb(sd, 0x0010);\r\nw9968cf_write_sb(sd, 0x0011);\r\nw9968cf_write_sb(sd, 0x0013);\r\n}\r\nstatic void w9968cf_smbus_write_byte(struct sd *sd, u8 v)\r\n{\r\nu8 bit;\r\nint sda;\r\nfor (bit = 0 ; bit < 8 ; bit++) {\r\nsda = (v & 0x80) ? 2 : 0;\r\nv <<= 1;\r\nw9968cf_write_sb(sd, 0x10 | sda);\r\nw9968cf_write_sb(sd, 0x11 | sda);\r\nw9968cf_write_sb(sd, 0x10 | sda);\r\n}\r\n}\r\nstatic void w9968cf_smbus_read_byte(struct sd *sd, u8 *v)\r\n{\r\nu8 bit;\r\n*v = 0;\r\nfor (bit = 0 ; bit < 8 ; bit++) {\r\n*v <<= 1;\r\nw9968cf_write_sb(sd, 0x0013);\r\n*v |= (w9968cf_read_sb(sd) & 0x0008) ? 1 : 0;\r\nw9968cf_write_sb(sd, 0x0012);\r\n}\r\n}\r\nstatic void w9968cf_smbus_write_nack(struct sd *sd)\r\n{\r\nw9968cf_write_sb(sd, 0x0013);\r\nw9968cf_write_sb(sd, 0x0012);\r\n}\r\nstatic void w9968cf_smbus_read_ack(struct sd *sd)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nint sda;\r\nw9968cf_write_sb(sd, 0x0012);\r\nw9968cf_write_sb(sd, 0x0013);\r\nsda = w9968cf_read_sb(sd);\r\nw9968cf_write_sb(sd, 0x0012);\r\nif (sda >= 0 && (sda & 0x08)) {\r\nPDEBUG(D_USBI, "Did not receive i2c ACK");\r\nsd->gspca_dev.usb_err = -EIO;\r\n}\r\n}\r\nstatic void w9968cf_i2c_w(struct sd *sd, u8 reg, u8 value)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nu16* data = (u16 *)sd->gspca_dev.usb_buf;\r\ndata[0] = 0x082f | ((sd->sensor_addr & 0x80) ? 0x1500 : 0x0);\r\ndata[0] |= (sd->sensor_addr & 0x40) ? 0x4000 : 0x0;\r\ndata[1] = 0x2082 | ((sd->sensor_addr & 0x40) ? 0x0005 : 0x0);\r\ndata[1] |= (sd->sensor_addr & 0x20) ? 0x0150 : 0x0;\r\ndata[1] |= (sd->sensor_addr & 0x10) ? 0x5400 : 0x0;\r\ndata[2] = 0x8208 | ((sd->sensor_addr & 0x08) ? 0x0015 : 0x0);\r\ndata[2] |= (sd->sensor_addr & 0x04) ? 0x0540 : 0x0;\r\ndata[2] |= (sd->sensor_addr & 0x02) ? 0x5000 : 0x0;\r\ndata[3] = 0x1d20 | ((sd->sensor_addr & 0x02) ? 0x0001 : 0x0);\r\ndata[3] |= (sd->sensor_addr & 0x01) ? 0x0054 : 0x0;\r\nw9968cf_write_fsb(sd, data);\r\ndata[0] = 0x8208 | ((reg & 0x80) ? 0x0015 : 0x0);\r\ndata[0] |= (reg & 0x40) ? 0x0540 : 0x0;\r\ndata[0] |= (reg & 0x20) ? 0x5000 : 0x0;\r\ndata[1] = 0x0820 | ((reg & 0x20) ? 0x0001 : 0x0);\r\ndata[1] |= (reg & 0x10) ? 0x0054 : 0x0;\r\ndata[1] |= (reg & 0x08) ? 0x1500 : 0x0;\r\ndata[1] |= (reg & 0x04) ? 0x4000 : 0x0;\r\ndata[2] = 0x2082 | ((reg & 0x04) ? 0x0005 : 0x0);\r\ndata[2] |= (reg & 0x02) ? 0x0150 : 0x0;\r\ndata[2] |= (reg & 0x01) ? 0x5400 : 0x0;\r\ndata[3] = 0x001d;\r\nw9968cf_write_fsb(sd, data);\r\ndata[0] = 0x8208 | ((value & 0x80) ? 0x0015 : 0x0);\r\ndata[0] |= (value & 0x40) ? 0x0540 : 0x0;\r\ndata[0] |= (value & 0x20) ? 0x5000 : 0x0;\r\ndata[1] = 0x0820 | ((value & 0x20) ? 0x0001 : 0x0);\r\ndata[1] |= (value & 0x10) ? 0x0054 : 0x0;\r\ndata[1] |= (value & 0x08) ? 0x1500 : 0x0;\r\ndata[1] |= (value & 0x04) ? 0x4000 : 0x0;\r\ndata[2] = 0x2082 | ((value & 0x04) ? 0x0005 : 0x0);\r\ndata[2] |= (value & 0x02) ? 0x0150 : 0x0;\r\ndata[2] |= (value & 0x01) ? 0x5400 : 0x0;\r\ndata[3] = 0xfe1d;\r\nw9968cf_write_fsb(sd, data);\r\nPDEBUG(D_USBO, "i2c 0x%02x -> [0x%02x]", value, reg);\r\n}\r\nstatic int w9968cf_i2c_r(struct sd *sd, u8 reg)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nint ret = 0;\r\nu8 value;\r\nw9968cf_write_sb(sd, 0x0013);\r\nw9968cf_smbus_start(sd);\r\nw9968cf_smbus_write_byte(sd, sd->sensor_addr);\r\nw9968cf_smbus_read_ack(sd);\r\nw9968cf_smbus_write_byte(sd, reg);\r\nw9968cf_smbus_read_ack(sd);\r\nw9968cf_smbus_stop(sd);\r\nw9968cf_smbus_start(sd);\r\nw9968cf_smbus_write_byte(sd, sd->sensor_addr + 1);\r\nw9968cf_smbus_read_ack(sd);\r\nw9968cf_smbus_read_byte(sd, &value);\r\nw9968cf_smbus_write_nack(sd);\r\nw9968cf_smbus_stop(sd);\r\nw9968cf_write_sb(sd, 0x0030);\r\nif (sd->gspca_dev.usb_err >= 0) {\r\nret = value;\r\nPDEBUG(D_USBI, "i2c [0x%02X] -> 0x%02X", reg, value);\r\n} else\r\nPERR("i2c read [0x%02x] failed", reg);\r\nreturn ret;\r\n}\r\nstatic void w9968cf_configure(struct sd *sd)\r\n{\r\nreg_w(sd, 0x00, 0xff00);\r\nreg_w(sd, 0x00, 0xbf17);\r\nreg_w(sd, 0x00, 0xbf10);\r\nreg_w(sd, 0x01, 0x0010);\r\nreg_w(sd, 0x01, 0x0000);\r\nreg_w(sd, 0x01, 0x0010);\r\nreg_w(sd, 0x01, 0x0030);\r\nsd->stopped = 1;\r\n}\r\nstatic void w9968cf_init(struct sd *sd)\r\n{\r\nunsigned long hw_bufsize = sd->sif ? (352 * 288 * 2) : (640 * 480 * 2),\r\ny0 = 0x0000,\r\nu0 = y0 + hw_bufsize / 2,\r\nv0 = u0 + hw_bufsize / 4,\r\ny1 = v0 + hw_bufsize / 4,\r\nu1 = y1 + hw_bufsize / 2,\r\nv1 = u1 + hw_bufsize / 4;\r\nreg_w(sd, 0x00, 0xff00);\r\nreg_w(sd, 0x00, 0xbf10);\r\nreg_w(sd, 0x03, 0x405d);\r\nreg_w(sd, 0x04, 0x0030);\r\nreg_w(sd, 0x20, y0 & 0xffff);\r\nreg_w(sd, 0x21, y0 >> 16);\r\nreg_w(sd, 0x24, u0 & 0xffff);\r\nreg_w(sd, 0x25, u0 >> 16);\r\nreg_w(sd, 0x28, v0 & 0xffff);\r\nreg_w(sd, 0x29, v0 >> 16);\r\nreg_w(sd, 0x22, y1 & 0xffff);\r\nreg_w(sd, 0x23, y1 >> 16);\r\nreg_w(sd, 0x26, u1 & 0xffff);\r\nreg_w(sd, 0x27, u1 >> 16);\r\nreg_w(sd, 0x2a, v1 & 0xffff);\r\nreg_w(sd, 0x2b, v1 >> 16);\r\nreg_w(sd, 0x32, y1 & 0xffff);\r\nreg_w(sd, 0x33, y1 >> 16);\r\nreg_w(sd, 0x34, y1 & 0xffff);\r\nreg_w(sd, 0x35, y1 >> 16);\r\nreg_w(sd, 0x36, 0x0000);\r\nreg_w(sd, 0x37, 0x0804);\r\nreg_w(sd, 0x38, 0x0000);\r\nreg_w(sd, 0x3f, 0x0000);\r\n}\r\nstatic void w9968cf_set_crop_window(struct sd *sd)\r\n{\r\nint start_cropx, start_cropy, x, y, fw, fh, cw, ch,\r\nmax_width, max_height;\r\nif (sd->sif) {\r\nmax_width = 352;\r\nmax_height = 288;\r\n} else {\r\nmax_width = 640;\r\nmax_height = 480;\r\n}\r\nif (sd->sensor == SEN_OV7620) {\r\nif (sd->freq->val == 1) {\r\nstart_cropx = 277;\r\nstart_cropy = 37;\r\n} else {\r\nstart_cropx = 105;\r\nstart_cropy = 37;\r\n}\r\n} else {\r\nstart_cropx = 320;\r\nstart_cropy = 35;\r\n}\r\n#define SC(x) ((x) << 10)\r\nfw = SC(sd->gspca_dev.width) / max_width;\r\nfh = SC(sd->gspca_dev.height) / max_height;\r\ncw = (fw >= fh) ? max_width : SC(sd->gspca_dev.width) / fh;\r\nch = (fw >= fh) ? SC(sd->gspca_dev.height) / fw : max_height;\r\nsd->sensor_width = max_width;\r\nsd->sensor_height = max_height;\r\nx = (max_width - cw) / 2;\r\ny = (max_height - ch) / 2;\r\nreg_w(sd, 0x10, start_cropx + x);\r\nreg_w(sd, 0x11, start_cropy + y);\r\nreg_w(sd, 0x12, start_cropx + x + cw);\r\nreg_w(sd, 0x13, start_cropy + y + ch);\r\n}\r\nstatic void w9968cf_mode_init_regs(struct sd *sd)\r\n{\r\nint val, vs_polarity, hs_polarity;\r\nw9968cf_set_crop_window(sd);\r\nreg_w(sd, 0x14, sd->gspca_dev.width);\r\nreg_w(sd, 0x15, sd->gspca_dev.height);\r\nreg_w(sd, 0x30, sd->gspca_dev.width);\r\nreg_w(sd, 0x31, sd->gspca_dev.height);\r\nif (w9968cf_vga_mode[sd->gspca_dev.curr_mode].pixelformat ==\r\nV4L2_PIX_FMT_JPEG) {\r\nreg_w(sd, 0x2c, sd->gspca_dev.width / 2);\r\nreg_w(sd, 0x2d, sd->gspca_dev.width / 4);\r\n} else\r\nreg_w(sd, 0x2c, sd->gspca_dev.width);\r\nreg_w(sd, 0x00, 0xbf17);\r\nreg_w(sd, 0x00, 0xbf10);\r\nval = sd->gspca_dev.width * sd->gspca_dev.height;\r\nreg_w(sd, 0x3d, val & 0xffff);\r\nreg_w(sd, 0x3e, val >> 16);\r\nif (w9968cf_vga_mode[sd->gspca_dev.curr_mode].pixelformat ==\r\nV4L2_PIX_FMT_JPEG) {\r\njpeg_define(sd->jpeg_hdr, sd->gspca_dev.height,\r\nsd->gspca_dev.width, 0x22);\r\njpeg_set_qual(sd->jpeg_hdr, v4l2_ctrl_g_ctrl(sd->jpegqual));\r\nw9968cf_upload_quantizationtables(sd);\r\nv4l2_ctrl_grab(sd->jpegqual, true);\r\n}\r\nif (sd->sensor == SEN_OV7620) {\r\nvs_polarity = 1;\r\nhs_polarity = 1;\r\n} else {\r\nvs_polarity = 1;\r\nhs_polarity = 0;\r\n}\r\nval = (vs_polarity << 12) | (hs_polarity << 11);\r\nif (w9968cf_vga_mode[sd->gspca_dev.curr_mode].pixelformat ==\r\nV4L2_PIX_FMT_JPEG) {\r\nval |= 0x0003;\r\n} else\r\nval |= 0x0080;\r\nval |= 0x8000;\r\nreg_w(sd, 0x16, val);\r\nsd->gspca_dev.empty_packet = 0;\r\n}\r\nstatic void w9968cf_stop0(struct sd *sd)\r\n{\r\nv4l2_ctrl_grab(sd->jpegqual, false);\r\nreg_w(sd, 0x39, 0x0000);\r\nreg_w(sd, 0x16, 0x0000);\r\n}\r\nstatic void w9968cf_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (w9968cf_vga_mode[gspca_dev->curr_mode].pixelformat ==\r\nV4L2_PIX_FMT_JPEG) {\r\nif (len >= 2 &&\r\ndata[0] == 0xff &&\r\ndata[1] == 0xd8) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\nlen -= 2;\r\ndata += 2;\r\n}\r\n} else {\r\nif (gspca_dev->empty_packet) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nNULL, 0);\r\ngspca_dev->empty_packet = 0;\r\n}\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}
