static inline uint64_t\r\nahc_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)\r\n{\r\nuint64_t id;\r\nid = subvendor\r\n| (subdevice << 16)\r\n| ((uint64_t)vendor << 32)\r\n| ((uint64_t)device << 48);\r\nreturn (id);\r\n}\r\nstatic int\r\nahc_9005_subdevinfo_valid(uint16_t device, uint16_t vendor,\r\nuint16_t subdevice, uint16_t subvendor)\r\n{\r\nint result;\r\nresult = 0;\r\nif (vendor == 0x9005\r\n&& subvendor == 0x9005\r\n&& subdevice != device\r\n&& SUBID_9005_TYPE_KNOWN(subdevice) != 0) {\r\nswitch (SUBID_9005_TYPE(subdevice)) {\r\ncase SUBID_9005_TYPE_MB:\r\nbreak;\r\ncase SUBID_9005_TYPE_CARD:\r\ncase SUBID_9005_TYPE_LCCARD:\r\nif (DEVID_9005_TYPE(device) == DEVID_9005_TYPE_HBA)\r\nresult = 1;\r\nbreak;\r\ncase SUBID_9005_TYPE_RAID:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn (result);\r\n}\r\nconst struct ahc_pci_identity *\r\nahc_find_pci_device(ahc_dev_softc_t pci)\r\n{\r\nuint64_t full_id;\r\nuint16_t device;\r\nuint16_t vendor;\r\nuint16_t subdevice;\r\nuint16_t subvendor;\r\nconst struct ahc_pci_identity *entry;\r\nu_int i;\r\nvendor = ahc_pci_read_config(pci, PCIR_DEVVENDOR, 2);\r\ndevice = ahc_pci_read_config(pci, PCIR_DEVICE, 2);\r\nsubvendor = ahc_pci_read_config(pci, PCIR_SUBVEND_0, 2);\r\nsubdevice = ahc_pci_read_config(pci, PCIR_SUBDEV_0, 2);\r\nfull_id = ahc_compose_id(device, vendor, subdevice, subvendor);\r\nif (ahc_get_pci_function(pci) > 0\r\n&& ahc_9005_subdevinfo_valid(vendor, device, subvendor, subdevice)\r\n&& SUBID_9005_MFUNCENB(subdevice) == 0)\r\nreturn (NULL);\r\nfor (i = 0; i < ahc_num_pci_devs; i++) {\r\nentry = &ahc_pci_ident_table[i];\r\nif (entry->full_id == (full_id & entry->id_mask)) {\r\nif (entry->name == NULL)\r\nreturn (NULL);\r\nreturn (entry);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nint\r\nahc_pci_config(struct ahc_softc *ahc, const struct ahc_pci_identity *entry)\r\n{\r\nu_int command;\r\nu_int our_id;\r\nu_int sxfrctl1;\r\nu_int scsiseq;\r\nu_int dscommand0;\r\nuint32_t devconfig;\r\nint error;\r\nuint8_t sblkctl;\r\nour_id = 0;\r\nerror = entry->setup(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nahc->chip |= AHC_PCI;\r\nahc->description = entry->name;\r\npci_set_power_state(ahc->dev_softc, AHC_POWER_STATE_D0);\r\nerror = ahc_pci_map_registers(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nahc_intr_enable(ahc, FALSE);\r\ndevconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);\r\nif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\r\nif (bootverbose)\r\nprintk("%s: Enabling 39Bit Addressing\n",\r\nahc_name(ahc));\r\ndevconfig |= DACEN;\r\n}\r\ndevconfig |= PCIERRGENDIS;\r\nahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);\r\ncommand = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 2);\r\ncommand |= PCIM_CMD_BUSMASTEREN;\r\nahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, 2);\r\nahc->flags |= AHC_PAGESCBS;\r\nerror = ahc_softc_init(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nif ((ahc->flags & AHC_DISABLE_PCI_PERR) != 0)\r\nahc->seqctl |= FAILDIS;\r\nahc->bus_intr = ahc_pci_intr;\r\nahc->bus_chip_init = ahc_pci_chip_init;\r\nif ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {\r\nahc_pause(ahc);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\r\nelse\r\nour_id = ahc_inb(ahc, SCSIID) & OID;\r\nsxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;\r\nscsiseq = ahc_inb(ahc, SCSISEQ);\r\n} else {\r\nsxfrctl1 = STPWEN;\r\nour_id = 7;\r\nscsiseq = 0;\r\n}\r\nerror = ahc_reset(ahc, FALSE);\r\nif (error != 0)\r\nreturn (ENXIO);\r\nif ((ahc->features & AHC_DT) != 0) {\r\nu_int sfunct;\r\nsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\r\nahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\r\nahc_outb(ahc, OPTIONMODE,\r\nOPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);\r\nahc_outb(ahc, SFUNCT, sfunct);\r\nahc_outb(ahc, CRCCONTROL1, CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN\r\n|TARGCRCENDEN);\r\n}\r\ndscommand0 = ahc_inb(ahc, DSCOMMAND0);\r\ndscommand0 |= MPARCKEN|CACHETHEN;\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\ndscommand0 &= ~DPARCKEN;\r\n}\r\nif ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)\r\ndscommand0 |= CACHETHEN;\r\nif ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)\r\ndscommand0 &= ~CACHETHEN;\r\nahc_outb(ahc, DSCOMMAND0, dscommand0);\r\nahc->pci_cachesize =\r\nahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME,\r\n1) & CACHESIZE;\r\nahc->pci_cachesize *= 4;\r\nif ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0\r\n&& ahc->pci_cachesize == 4) {\r\nahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME,\r\n0, 1);\r\nahc->pci_cachesize = 0;\r\n}\r\nif ((ahc->features & AHC_ULTRA) != 0) {\r\nuint32_t devconfig;\r\ndevconfig = ahc_pci_read_config(ahc->dev_softc,\r\nDEVCONFIG, 4);\r\nif ((devconfig & REXTVALID) == 0)\r\nahc->features &= ~AHC_ULTRA;\r\n}\r\ncheck_extport(ahc, &sxfrctl1);\r\nsblkctl = ahc_inb(ahc, SBLKCTL);\r\nahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);\r\n} else {\r\nahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);\r\n}\r\nif (ahc->flags & AHC_USEDEFAULTS) {\r\nif ((ahc->flags & AHC_NO_BIOS_INIT) == 0\r\n&& scsiseq != 0) {\r\nprintk("%s: Using left over BIOS settings\n",\r\nahc_name(ahc));\r\nahc->flags &= ~AHC_USEDEFAULTS;\r\nahc->flags |= AHC_BIOS_ENABLED;\r\n} else {\r\nour_id = 0x07;\r\nsxfrctl1 = STPWEN;\r\n}\r\nahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);\r\nahc->our_id = our_id;\r\n}\r\nahc_probe_ext_scbram(ahc);\r\nif ((sxfrctl1 & STPWEN) != 0)\r\nahc->flags |= AHC_TERM_ENB_A;\r\nahc->bus_softc.pci_softc.devconfig =\r\nahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);\r\nahc->bus_softc.pci_softc.command =\r\nahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 1);\r\nahc->bus_softc.pci_softc.csize_lattime =\r\nahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME, 1);\r\nahc->bus_softc.pci_softc.dscommand0 = ahc_inb(ahc, DSCOMMAND0);\r\nahc->bus_softc.pci_softc.dspcistatus = ahc_inb(ahc, DSPCISTATUS);\r\nif ((ahc->features & AHC_DT) != 0) {\r\nu_int sfunct;\r\nsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\r\nahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\r\nahc->bus_softc.pci_softc.optionmode = ahc_inb(ahc, OPTIONMODE);\r\nahc->bus_softc.pci_softc.targcrccnt = ahc_inw(ahc, TARGCRCCNT);\r\nahc_outb(ahc, SFUNCT, sfunct);\r\nahc->bus_softc.pci_softc.crccontrol1 =\r\nahc_inb(ahc, CRCCONTROL1);\r\n}\r\nif ((ahc->features & AHC_MULTI_FUNC) != 0)\r\nahc->bus_softc.pci_softc.scbbaddr = ahc_inb(ahc, SCBBADDR);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc->bus_softc.pci_softc.dff_thrsh = ahc_inb(ahc, DFF_THRSH);\r\nerror = ahc_init(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nahc->init_level++;\r\nreturn ahc_pci_map_int(ahc);\r\n}\r\nstatic int\r\nahc_ext_scbram_present(struct ahc_softc *ahc)\r\n{\r\nu_int chip;\r\nint ramps;\r\nint single_user;\r\nuint32_t devconfig;\r\nchip = ahc->chip & AHC_CHIPID_MASK;\r\ndevconfig = ahc_pci_read_config(ahc->dev_softc,\r\nDEVCONFIG, 4);\r\nsingle_user = (devconfig & MPORTMODE) != 0;\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;\r\nelse if (chip == AHC_AIC7895 || chip == AHC_AIC7895C)\r\nramps = 0;\r\nelse if (chip >= AHC_AIC7870)\r\nramps = (devconfig & RAMPSM) != 0;\r\nelse\r\nramps = 0;\r\nif (ramps && single_user)\r\nreturn (1);\r\nreturn (0);\r\n}\r\nstatic void\r\nahc_scbram_config(struct ahc_softc *ahc, int enable, int pcheck,\r\nint fast, int large)\r\n{\r\nuint32_t devconfig;\r\nif (ahc->features & AHC_MULTI_FUNC) {\r\nahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));\r\n}\r\nahc->flags &= ~AHC_LSCBS_ENABLED;\r\nif (large)\r\nahc->flags |= AHC_LSCBS_ENABLED;\r\ndevconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nu_int dscommand0;\r\ndscommand0 = ahc_inb(ahc, DSCOMMAND0);\r\nif (enable)\r\ndscommand0 &= ~INTSCBRAMSEL;\r\nelse\r\ndscommand0 |= INTSCBRAMSEL;\r\nif (large)\r\ndscommand0 &= ~USCBSIZE32;\r\nelse\r\ndscommand0 |= USCBSIZE32;\r\nahc_outb(ahc, DSCOMMAND0, dscommand0);\r\n} else {\r\nif (fast)\r\ndevconfig &= ~EXTSCBTIME;\r\nelse\r\ndevconfig |= EXTSCBTIME;\r\nif (enable)\r\ndevconfig &= ~SCBRAMSEL;\r\nelse\r\ndevconfig |= SCBRAMSEL;\r\nif (large)\r\ndevconfig &= ~SCBSIZE32;\r\nelse\r\ndevconfig |= SCBSIZE32;\r\n}\r\nif (pcheck)\r\ndevconfig |= EXTSCBPEN;\r\nelse\r\ndevconfig &= ~EXTSCBPEN;\r\nahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);\r\n}\r\nstatic void\r\nahc_probe_ext_scbram(struct ahc_softc *ahc)\r\n{\r\nint num_scbs;\r\nint test_num_scbs;\r\nint enable;\r\nint pcheck;\r\nint fast;\r\nint large;\r\nenable = FALSE;\r\npcheck = FALSE;\r\nfast = FALSE;\r\nlarge = FALSE;\r\nnum_scbs = 0;\r\nif (ahc_ext_scbram_present(ahc) == 0)\r\ngoto done;\r\nahc_scbram_config(ahc, TRUE, pcheck, fast, large);\r\nnum_scbs = ahc_probe_scbs(ahc);\r\nif (num_scbs == 0) {\r\ngoto done;\r\n}\r\nenable = TRUE;\r\nahc_outb(ahc, SEQCTL, 0);\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, CLRINT, CLRBRKADRINT);\r\nahc_scbram_config(ahc, enable, TRUE, fast, large);\r\nnum_scbs = ahc_probe_scbs(ahc);\r\nif ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\r\n|| (ahc_inb(ahc, ERROR) & MPARERR) == 0)\r\npcheck = TRUE;\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, CLRINT, CLRBRKADRINT);\r\nahc_scbram_config(ahc, enable, pcheck, TRUE, large);\r\ntest_num_scbs = ahc_probe_scbs(ahc);\r\nif (test_num_scbs == num_scbs\r\n&& ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0\r\n|| (ahc_inb(ahc, ERROR) & MPARERR) == 0))\r\nfast = TRUE;\r\nif ((ahc->features & AHC_LARGE_SCBS) != 0) {\r\nahc_scbram_config(ahc, enable, pcheck, fast, TRUE);\r\ntest_num_scbs = ahc_probe_scbs(ahc);\r\nif (test_num_scbs >= num_scbs) {\r\nlarge = TRUE;\r\nnum_scbs = test_num_scbs;\r\nif (num_scbs >= 64) {\r\nahc->flags |= AHC_SCB_BTT;\r\n}\r\n}\r\n}\r\ndone:\r\nahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, CLRINT, CLRBRKADRINT);\r\nif (bootverbose && enable) {\r\nprintk("%s: External SRAM, %s access%s, %dbytes/SCB\n",\r\nahc_name(ahc), fast ? "fast" : "slow",\r\npcheck ? ", parity checking enabled" : "",\r\nlarge ? 64 : 32);\r\n}\r\nahc_scbram_config(ahc, enable, pcheck, fast, large);\r\n}\r\nint\r\nahc_pci_test_register_access(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nu_int status1;\r\nuint32_t cmd;\r\nuint8_t hcntrl;\r\nerror = EIO;\r\ncmd = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 2);\r\nahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,\r\ncmd & ~PCIM_CMD_SERRESPEN, 2);\r\nhcntrl = ahc_inb(ahc, HCNTRL);\r\nif (hcntrl == 0xFF)\r\ngoto fail;\r\nif ((hcntrl & CHIPRST) != 0) {\r\nahc->flags |= AHC_NO_BIOS_INIT;\r\n}\r\nhcntrl &= ~CHIPRST;\r\nahc_outb(ahc, HCNTRL, hcntrl|PAUSE);\r\nwhile (ahc_is_paused(ahc) == 0)\r\n;\r\nstatus1 = ahc_pci_read_config(ahc->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,\r\nstatus1, 1);\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, SEQCTL, PERRORDIS);\r\nahc_outb(ahc, SCBPTR, 0);\r\nahc_outl(ahc, SCB_BASE, 0x5aa555aa);\r\nif (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)\r\ngoto fail;\r\nstatus1 = ahc_pci_read_config(ahc->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nif ((status1 & STA) != 0)\r\ngoto fail;\r\nerror = 0;\r\nfail:\r\nstatus1 = ahc_pci_read_config(ahc->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,\r\nstatus1, 1);\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);\r\nahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, 2);\r\nreturn (error);\r\n}\r\nstatic void\r\ncheck_extport(struct ahc_softc *ahc, u_int *sxfrctl1)\r\n{\r\nstruct seeprom_descriptor sd;\r\nstruct seeprom_config *sc;\r\nint have_seeprom;\r\nint have_autoterm;\r\nsd.sd_ahc = ahc;\r\nsd.sd_control_offset = SEECTL;\r\nsd.sd_status_offset = SEECTL;\r\nsd.sd_dataout_offset = SEECTL;\r\nsc = ahc->seep_config;\r\nif (ahc->flags & AHC_LARGE_SEEPROM)\r\nsd.sd_chip = C56_66;\r\nelse\r\nsd.sd_chip = C46;\r\nsd.sd_MS = SEEMS;\r\nsd.sd_RDY = SEERDY;\r\nsd.sd_CS = SEECS;\r\nsd.sd_CK = SEECK;\r\nsd.sd_DO = SEEDO;\r\nsd.sd_DI = SEEDI;\r\nhave_seeprom = ahc_acquire_seeprom(ahc, &sd);\r\nif (have_seeprom) {\r\nif (bootverbose)\r\nprintk("%s: Reading SEEPROM...", ahc_name(ahc));\r\nfor (;;) {\r\nu_int start_addr;\r\nstart_addr = 32 * (ahc->channel - 'A');\r\nhave_seeprom = ahc_read_seeprom(&sd, (uint16_t *)sc,\r\nstart_addr,\r\nsizeof(*sc)/2);\r\nif (have_seeprom)\r\nhave_seeprom = ahc_verify_cksum(sc);\r\nif (have_seeprom != 0 || sd.sd_chip == C56_66) {\r\nif (bootverbose) {\r\nif (have_seeprom == 0)\r\nprintk ("checksum error\n");\r\nelse\r\nprintk ("done.\n");\r\n}\r\nbreak;\r\n}\r\nsd.sd_chip = C56_66;\r\n}\r\nahc_release_seeprom(&sd);\r\nif (sd.sd_chip == C56_66)\r\nahc->flags |= AHC_LARGE_SEEPROM;\r\n}\r\nif (!have_seeprom) {\r\nahc_outb(ahc, SCBPTR, 2);\r\nif (ahc_inb(ahc, SCB_BASE) == 'A'\r\n&& ahc_inb(ahc, SCB_BASE + 1) == 'D'\r\n&& ahc_inb(ahc, SCB_BASE + 2) == 'P'\r\n&& ahc_inb(ahc, SCB_BASE + 3) == 'T') {\r\nuint16_t *sc_data;\r\nint i;\r\nsc_data = (uint16_t *)sc;\r\nfor (i = 0; i < 32; i++, sc_data++) {\r\nint j;\r\nj = i * 2;\r\n*sc_data = ahc_inb(ahc, SRAM_BASE + j)\r\n| ahc_inb(ahc, SRAM_BASE + j + 1) << 8;\r\n}\r\nhave_seeprom = ahc_verify_cksum(sc);\r\nif (have_seeprom)\r\nahc->flags |= AHC_SCB_CONFIG_USED;\r\n}\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, CLRINT, CLRBRKADRINT);\r\n}\r\nif (!have_seeprom) {\r\nif (bootverbose)\r\nprintk("%s: No SEEPROM available.\n", ahc_name(ahc));\r\nahc->flags |= AHC_USEDEFAULTS;\r\nkfree(ahc->seep_config);\r\nahc->seep_config = NULL;\r\nsc = NULL;\r\n} else {\r\nahc_parse_pci_eeprom(ahc, sc);\r\n}\r\nhave_autoterm = have_seeprom;\r\nif ((ahc->features & AHC_SPIOCAP) != 0) {\r\nif ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) == 0)\r\nhave_autoterm = FALSE;\r\n}\r\nif (have_autoterm) {\r\nahc->flags |= AHC_HAS_TERM_LOGIC;\r\nahc_acquire_seeprom(ahc, &sd);\r\nconfigure_termination(ahc, &sd, sc->adapter_control, sxfrctl1);\r\nahc_release_seeprom(&sd);\r\n} else if (have_seeprom) {\r\n*sxfrctl1 &= ~STPWEN;\r\nif ((sc->adapter_control & CFSTERM) != 0)\r\n*sxfrctl1 |= STPWEN;\r\nif (bootverbose)\r\nprintk("%s: Low byte termination %sabled\n",\r\nahc_name(ahc),\r\n(*sxfrctl1 & STPWEN) ? "en" : "dis");\r\n}\r\n}\r\nstatic void\r\nahc_parse_pci_eeprom(struct ahc_softc *ahc, struct seeprom_config *sc)\r\n{\r\nint i;\r\nint max_targ = sc->max_targets & CFMAXTARG;\r\nu_int scsi_conf;\r\nuint16_t discenable;\r\nuint16_t ultraenb;\r\ndiscenable = 0;\r\nultraenb = 0;\r\nif ((sc->adapter_control & CFULTRAEN) != 0) {\r\nfor (i = 0; i < max_targ; i++) {\r\nif ((sc->device_flags[i] & CFSYNCHISULTRA) != 0) {\r\nahc->flags |= AHC_NEWEEPROM_FMT;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < max_targ; i++) {\r\nu_int scsirate;\r\nuint16_t target_mask;\r\ntarget_mask = 0x01 << i;\r\nif (sc->device_flags[i] & CFDISC)\r\ndiscenable |= target_mask;\r\nif ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {\r\nif ((sc->device_flags[i] & CFSYNCHISULTRA) != 0)\r\nultraenb |= target_mask;\r\n} else if ((sc->adapter_control & CFULTRAEN) != 0) {\r\nultraenb |= target_mask;\r\n}\r\nif ((sc->device_flags[i] & CFXFER) == 0x04\r\n&& (ultraenb & target_mask) != 0) {\r\nsc->device_flags[i] &= ~CFXFER;\r\nultraenb &= ~target_mask;\r\n}\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nu_int offset;\r\nif (sc->device_flags[i] & CFSYNCH)\r\noffset = MAX_OFFSET_ULTRA2;\r\nelse\r\noffset = 0;\r\nahc_outb(ahc, TARG_OFFSET + i, offset);\r\nscsirate = (sc->device_flags[i] & CFXFER)\r\n| ((ultraenb & target_mask) ? 0x8 : 0x0);\r\nif (sc->device_flags[i] & CFWIDEB)\r\nscsirate |= WIDEXFER;\r\n} else {\r\nscsirate = (sc->device_flags[i] & CFXFER) << 4;\r\nif (sc->device_flags[i] & CFSYNCH)\r\nscsirate |= SOFS;\r\nif (sc->device_flags[i] & CFWIDEB)\r\nscsirate |= WIDEXFER;\r\n}\r\nahc_outb(ahc, TARG_SCSIRATE + i, scsirate);\r\n}\r\nahc->our_id = sc->brtime_id & CFSCSIID;\r\nscsi_conf = (ahc->our_id & 0x7);\r\nif (sc->adapter_control & CFSPARITY)\r\nscsi_conf |= ENSPCHK;\r\nif (sc->adapter_control & CFRESETB)\r\nscsi_conf |= RESET_SCSI;\r\nahc->flags |= (sc->adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;\r\nif (sc->bios_control & CFEXTEND)\r\nahc->flags |= AHC_EXTENDED_TRANS_A;\r\nif (sc->bios_control & CFBIOSEN)\r\nahc->flags |= AHC_BIOS_ENABLED;\r\nif (ahc->features & AHC_ULTRA\r\n&& (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {\r\nif (!(sc->adapter_control & CFULTRAEN))\r\nultraenb = 0;\r\n}\r\nif (sc->signature == CFSIGNATURE\r\n|| sc->signature == CFSIGNATURE2) {\r\nuint32_t devconfig;\r\ndevconfig = ahc_pci_read_config(ahc->dev_softc,\r\nDEVCONFIG, 4);\r\ndevconfig &= ~STPWLEVEL;\r\nif ((sc->bios_control & CFSTPWLEVEL) != 0)\r\ndevconfig |= STPWLEVEL;\r\nahc_pci_write_config(ahc->dev_softc, DEVCONFIG,\r\ndevconfig, 4);\r\n}\r\nahc_outb(ahc, SCSICONF, scsi_conf);\r\nahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\r\nahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\r\nahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);\r\nahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);\r\n}\r\nstatic void\r\nconfigure_termination(struct ahc_softc *ahc,\r\nstruct seeprom_descriptor *sd,\r\nu_int adapter_control,\r\nu_int *sxfrctl1)\r\n{\r\nuint8_t brddat;\r\nbrddat = 0;\r\n*sxfrctl1 = 0;\r\nSEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);\r\nif ((adapter_control & CFAUTOTERM) != 0\r\n|| (ahc->features & AHC_NEW_TERMCTL) != 0) {\r\nint internal50_present;\r\nint internal68_present;\r\nint externalcable_present;\r\nint eeprom_present;\r\nint enableSEC_low;\r\nint enableSEC_high;\r\nint enablePRI_low;\r\nint enablePRI_high;\r\nint sum;\r\nenableSEC_low = 0;\r\nenableSEC_high = 0;\r\nenablePRI_low = 0;\r\nenablePRI_high = 0;\r\nif ((ahc->features & AHC_NEW_TERMCTL) != 0) {\r\nahc_new_term_detect(ahc, &enableSEC_low,\r\n&enableSEC_high,\r\n&enablePRI_low,\r\n&enablePRI_high,\r\n&eeprom_present);\r\nif ((adapter_control & CFSEAUTOTERM) == 0) {\r\nif (bootverbose)\r\nprintk("%s: Manual SE Termination\n",\r\nahc_name(ahc));\r\nenableSEC_low = (adapter_control & CFSELOWTERM);\r\nenableSEC_high =\r\n(adapter_control & CFSEHIGHTERM);\r\n}\r\nif ((adapter_control & CFAUTOTERM) == 0) {\r\nif (bootverbose)\r\nprintk("%s: Manual LVD Termination\n",\r\nahc_name(ahc));\r\nenablePRI_low = (adapter_control & CFSTERM);\r\nenablePRI_high = (adapter_control & CFWSTERM);\r\n}\r\ninternal50_present = 0;\r\ninternal68_present = 1;\r\nexternalcable_present = 1;\r\n} else if ((ahc->features & AHC_SPIOCAP) != 0) {\r\naic785X_cable_detect(ahc, &internal50_present,\r\n&externalcable_present,\r\n&eeprom_present);\r\ninternal68_present = 0;\r\n} else {\r\naic787X_cable_detect(ahc, &internal50_present,\r\n&internal68_present,\r\n&externalcable_present,\r\n&eeprom_present);\r\n}\r\nif ((ahc->features & AHC_WIDE) == 0)\r\ninternal68_present = 0;\r\nif (bootverbose\r\n&& (ahc->features & AHC_ULTRA2) == 0) {\r\nprintk("%s: internal 50 cable %s present",\r\nahc_name(ahc),\r\ninternal50_present ? "is":"not");\r\nif ((ahc->features & AHC_WIDE) != 0)\r\nprintk(", internal 68 cable %s present",\r\ninternal68_present ? "is":"not");\r\nprintk("\n%s: external cable %s present\n",\r\nahc_name(ahc),\r\nexternalcable_present ? "is":"not");\r\n}\r\nif (bootverbose)\r\nprintk("%s: BIOS eeprom %s present\n",\r\nahc_name(ahc), eeprom_present ? "is" : "not");\r\nif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {\r\ninternal50_present = 0;\r\n}\r\nif ((ahc->features & AHC_ULTRA2) == 0\r\n&& (internal50_present != 0)\r\n&& (internal68_present != 0)\r\n&& (externalcable_present != 0)) {\r\nprintk("%s: Illegal cable configuration!!. "\r\n"Only two connectors on the "\r\n"adapter may be used at a "\r\n"time!\n", ahc_name(ahc));\r\ninternal50_present = 0;\r\ninternal68_present = 0;\r\nexternalcable_present = 0;\r\n}\r\nif ((ahc->features & AHC_WIDE) != 0\r\n&& ((externalcable_present == 0)\r\n|| (internal68_present == 0)\r\n|| (enableSEC_high != 0))) {\r\nbrddat |= BRDDAT6;\r\nif (bootverbose) {\r\nif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\r\nprintk("%s: 68 pin termination "\r\n"Enabled\n", ahc_name(ahc));\r\nelse\r\nprintk("%s: %sHigh byte termination "\r\n"Enabled\n", ahc_name(ahc),\r\nenableSEC_high ? "Secondary "\r\n: "");\r\n}\r\n}\r\nsum = internal50_present + internal68_present\r\n+ externalcable_present;\r\nif (sum < 2 || (enableSEC_low != 0)) {\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nbrddat |= BRDDAT5;\r\nelse\r\n*sxfrctl1 |= STPWEN;\r\nif (bootverbose) {\r\nif ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)\r\nprintk("%s: 50 pin termination "\r\n"Enabled\n", ahc_name(ahc));\r\nelse\r\nprintk("%s: %sLow byte termination "\r\n"Enabled\n", ahc_name(ahc),\r\nenableSEC_low ? "Secondary "\r\n: "");\r\n}\r\n}\r\nif (enablePRI_low != 0) {\r\n*sxfrctl1 |= STPWEN;\r\nif (bootverbose)\r\nprintk("%s: Primary Low Byte termination "\r\n"Enabled\n", ahc_name(ahc));\r\n}\r\nahc_outb(ahc, SXFRCTL1, *sxfrctl1);\r\nif (enablePRI_high != 0) {\r\nbrddat |= BRDDAT4;\r\nif (bootverbose)\r\nprintk("%s: Primary High Byte "\r\n"termination Enabled\n",\r\nahc_name(ahc));\r\n}\r\nwrite_brdctl(ahc, brddat);\r\n} else {\r\nif ((adapter_control & CFSTERM) != 0) {\r\n*sxfrctl1 |= STPWEN;\r\nif (bootverbose)\r\nprintk("%s: %sLow byte termination Enabled\n",\r\nahc_name(ahc),\r\n(ahc->features & AHC_ULTRA2) ? "Primary "\r\n: "");\r\n}\r\nif ((adapter_control & CFWSTERM) != 0\r\n&& (ahc->features & AHC_WIDE) != 0) {\r\nbrddat |= BRDDAT6;\r\nif (bootverbose)\r\nprintk("%s: %sHigh byte termination Enabled\n",\r\nahc_name(ahc),\r\n(ahc->features & AHC_ULTRA2)\r\n? "Secondary " : "");\r\n}\r\nahc_outb(ahc, SXFRCTL1, *sxfrctl1);\r\nif ((ahc->features & AHC_WIDE) != 0)\r\nwrite_brdctl(ahc, brddat);\r\n}\r\nSEEPROM_OUTB(sd, sd->sd_MS);\r\n}\r\nstatic void\r\nahc_new_term_detect(struct ahc_softc *ahc, int *enableSEC_low,\r\nint *enableSEC_high, int *enablePRI_low,\r\nint *enablePRI_high, int *eeprom_present)\r\n{\r\nuint8_t brdctl;\r\nbrdctl = read_brdctl(ahc);\r\n*eeprom_present = brdctl & BRDDAT7;\r\n*enableSEC_high = (brdctl & BRDDAT6);\r\n*enableSEC_low = (brdctl & BRDDAT5);\r\n*enablePRI_high = (brdctl & BRDDAT4);\r\n*enablePRI_low = (brdctl & BRDDAT3);\r\n}\r\nstatic void\r\naic787X_cable_detect(struct ahc_softc *ahc, int *internal50_present,\r\nint *internal68_present, int *externalcable_present,\r\nint *eeprom_present)\r\n{\r\nuint8_t brdctl;\r\nwrite_brdctl(ahc, 0);\r\nbrdctl = read_brdctl(ahc);\r\n*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;\r\n*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;\r\nwrite_brdctl(ahc, BRDDAT5);\r\nbrdctl = read_brdctl(ahc);\r\n*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;\r\n*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;\r\n}\r\nstatic void\r\naic785X_cable_detect(struct ahc_softc *ahc, int *internal50_present,\r\nint *externalcable_present, int *eeprom_present)\r\n{\r\nuint8_t brdctl;\r\nuint8_t spiocap;\r\nspiocap = ahc_inb(ahc, SPIOCAP);\r\nspiocap &= ~SOFTCMDEN;\r\nspiocap |= EXT_BRDCTL;\r\nahc_outb(ahc, SPIOCAP, spiocap);\r\nahc_outb(ahc, BRDCTL, BRDRW|BRDCS);\r\nahc_flush_device_writes(ahc);\r\nahc_delay(500);\r\nahc_outb(ahc, BRDCTL, 0);\r\nahc_flush_device_writes(ahc);\r\nahc_delay(500);\r\nbrdctl = ahc_inb(ahc, BRDCTL);\r\n*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;\r\n*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;\r\n*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;\r\n}\r\nint\r\nahc_acquire_seeprom(struct ahc_softc *ahc, struct seeprom_descriptor *sd)\r\n{\r\nint wait;\r\nif ((ahc->features & AHC_SPIOCAP) != 0\r\n&& (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)\r\nreturn (0);\r\nSEEPROM_OUTB(sd, sd->sd_MS);\r\nwait = 1000;\r\nwhile (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {\r\nahc_delay(1000);\r\n}\r\nif ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {\r\nSEEPROM_OUTB(sd, 0);\r\nreturn (0);\r\n}\r\nreturn(1);\r\n}\r\nvoid\r\nahc_release_seeprom(struct seeprom_descriptor *sd)\r\n{\r\nSEEPROM_OUTB(sd, 0);\r\n}\r\nstatic void\r\nwrite_brdctl(struct ahc_softc *ahc, uint8_t value)\r\n{\r\nuint8_t brdctl;\r\nif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\r\nbrdctl = BRDSTB;\r\nif (ahc->channel == 'B')\r\nbrdctl |= BRDCS;\r\n} else if ((ahc->features & AHC_ULTRA2) != 0) {\r\nbrdctl = 0;\r\n} else {\r\nbrdctl = BRDSTB|BRDCS;\r\n}\r\nahc_outb(ahc, BRDCTL, brdctl);\r\nahc_flush_device_writes(ahc);\r\nbrdctl |= value;\r\nahc_outb(ahc, BRDCTL, brdctl);\r\nahc_flush_device_writes(ahc);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nbrdctl |= BRDSTB_ULTRA2;\r\nelse\r\nbrdctl &= ~BRDSTB;\r\nahc_outb(ahc, BRDCTL, brdctl);\r\nahc_flush_device_writes(ahc);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nbrdctl = 0;\r\nelse\r\nbrdctl &= ~BRDCS;\r\nahc_outb(ahc, BRDCTL, brdctl);\r\n}\r\nstatic uint8_t\r\nread_brdctl(struct ahc_softc *ahc)\r\n{\r\nuint8_t brdctl;\r\nuint8_t value;\r\nif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {\r\nbrdctl = BRDRW;\r\nif (ahc->channel == 'B')\r\nbrdctl |= BRDCS;\r\n} else if ((ahc->features & AHC_ULTRA2) != 0) {\r\nbrdctl = BRDRW_ULTRA2;\r\n} else {\r\nbrdctl = BRDRW|BRDCS;\r\n}\r\nahc_outb(ahc, BRDCTL, brdctl);\r\nahc_flush_device_writes(ahc);\r\nvalue = ahc_inb(ahc, BRDCTL);\r\nahc_outb(ahc, BRDCTL, 0);\r\nreturn (value);\r\n}\r\nstatic void\r\nahc_pci_intr(struct ahc_softc *ahc)\r\n{\r\nu_int error;\r\nu_int status1;\r\nerror = ahc_inb(ahc, ERROR);\r\nif ((error & PCIERRSTAT) == 0)\r\nreturn;\r\nstatus1 = ahc_pci_read_config(ahc->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nprintk("%s: PCI error Interrupt at seqaddr = 0x%x\n",\r\nahc_name(ahc),\r\nahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\r\nif (status1 & DPE) {\r\nahc->pci_target_perr_count++;\r\nprintk("%s: Data Parity Error Detected during address "\r\n"or write data phase\n", ahc_name(ahc));\r\n}\r\nif (status1 & SSE) {\r\nprintk("%s: Signal System Error Detected\n", ahc_name(ahc));\r\n}\r\nif (status1 & RMA) {\r\nprintk("%s: Received a Master Abort\n", ahc_name(ahc));\r\n}\r\nif (status1 & RTA) {\r\nprintk("%s: Received a Target Abort\n", ahc_name(ahc));\r\n}\r\nif (status1 & STA) {\r\nprintk("%s: Signaled a Target Abort\n", ahc_name(ahc));\r\n}\r\nif (status1 & DPR) {\r\nprintk("%s: Data Parity Error has been reported via PERR#\n",\r\nahc_name(ahc));\r\n}\r\nahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,\r\nstatus1, 1);\r\nif ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {\r\nprintk("%s: Latched PCIERR interrupt with "\r\n"no status bits set\n", ahc_name(ahc));\r\n} else {\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\n}\r\nif (ahc->pci_target_perr_count > AHC_PCI_TARGET_PERR_THRESH) {\r\nprintk(\r\n"%s: WARNING WARNING WARNING WARNING\n"\r\n"%s: Too many PCI parity errors observed as a target.\n"\r\n"%s: Some device on this bus is generating bad parity.\n"\r\n"%s: This is an error *observed by*, not *generated by*, this controller.\n"\r\n"%s: PCI parity error checking has been disabled.\n"\r\n"%s: WARNING WARNING WARNING WARNING\n",\r\nahc_name(ahc), ahc_name(ahc), ahc_name(ahc),\r\nahc_name(ahc), ahc_name(ahc), ahc_name(ahc));\r\nahc->seqctl |= FAILDIS;\r\nahc_outb(ahc, SEQCTL, ahc->seqctl);\r\n}\r\nahc_unpause(ahc);\r\n}\r\nstatic int\r\nahc_pci_chip_init(struct ahc_softc *ahc)\r\n{\r\nahc_outb(ahc, DSCOMMAND0, ahc->bus_softc.pci_softc.dscommand0);\r\nahc_outb(ahc, DSPCISTATUS, ahc->bus_softc.pci_softc.dspcistatus);\r\nif ((ahc->features & AHC_DT) != 0) {\r\nu_int sfunct;\r\nsfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;\r\nahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);\r\nahc_outb(ahc, OPTIONMODE, ahc->bus_softc.pci_softc.optionmode);\r\nahc_outw(ahc, TARGCRCCNT, ahc->bus_softc.pci_softc.targcrccnt);\r\nahc_outb(ahc, SFUNCT, sfunct);\r\nahc_outb(ahc, CRCCONTROL1,\r\nahc->bus_softc.pci_softc.crccontrol1);\r\n}\r\nif ((ahc->features & AHC_MULTI_FUNC) != 0)\r\nahc_outb(ahc, SCBBADDR, ahc->bus_softc.pci_softc.scbbaddr);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc_outb(ahc, DFF_THRSH, ahc->bus_softc.pci_softc.dff_thrsh);\r\nreturn (ahc_chip_init(ahc));\r\n}\r\nvoid\r\nahc_pci_resume(struct ahc_softc *ahc)\r\n{\r\nahc_pci_write_config(ahc->dev_softc, DEVCONFIG,\r\nahc->bus_softc.pci_softc.devconfig, 4);\r\nahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,\r\nahc->bus_softc.pci_softc.command, 1);\r\nahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME,\r\nahc->bus_softc.pci_softc.csize_lattime, 1);\r\nif ((ahc->flags & AHC_HAS_TERM_LOGIC) != 0) {\r\nstruct seeprom_descriptor sd;\r\nu_int sxfrctl1;\r\nsd.sd_ahc = ahc;\r\nsd.sd_control_offset = SEECTL;\r\nsd.sd_status_offset = SEECTL;\r\nsd.sd_dataout_offset = SEECTL;\r\nahc_acquire_seeprom(ahc, &sd);\r\nconfigure_termination(ahc, &sd,\r\nahc->seep_config->adapter_control,\r\n&sxfrctl1);\r\nahc_release_seeprom(&sd);\r\n}\r\n}\r\nstatic int\r\nahc_aic785X_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\nuint8_t rev;\r\npci = ahc->dev_softc;\r\nahc->channel = 'A';\r\nahc->chip = AHC_AIC7850;\r\nahc->features = AHC_AIC7850_FE;\r\nahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\r\nrev = ahc_pci_read_config(pci, PCIR_REVID, 1);\r\nif (rev >= 1)\r\nahc->bugs |= AHC_PCI_2_1_RETRY_BUG;\r\nahc->instruction_ram_size = 512;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7860_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\nuint8_t rev;\r\npci = ahc->dev_softc;\r\nahc->channel = 'A';\r\nahc->chip = AHC_AIC7860;\r\nahc->features = AHC_AIC7860_FE;\r\nahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\r\nrev = ahc_pci_read_config(pci, PCIR_REVID, 1);\r\nif (rev >= 1)\r\nahc->bugs |= AHC_PCI_2_1_RETRY_BUG;\r\nahc->instruction_ram_size = 512;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_apa1480_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7860_setup(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nahc->features |= AHC_REMOVABLE;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7870_setup(struct ahc_softc *ahc)\r\n{\r\nahc->channel = 'A';\r\nahc->chip = AHC_AIC7870;\r\nahc->features = AHC_AIC7870_FE;\r\nahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\r\nahc->instruction_ram_size = 512;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7870h_setup(struct ahc_softc *ahc)\r\n{\r\nint error = ahc_aic7870_setup(ahc);\r\nahc->features |= AHC_HVD;\r\nreturn error;\r\n}\r\nstatic int\r\nahc_aha394X_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7870_setup(ahc);\r\nif (error == 0)\r\nerror = ahc_aha394XX_setup(ahc);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aha394Xh_setup(struct ahc_softc *ahc)\r\n{\r\nint error = ahc_aha394X_setup(ahc);\r\nahc->features |= AHC_HVD;\r\nreturn error;\r\n}\r\nstatic int\r\nahc_aha398X_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7870_setup(ahc);\r\nif (error == 0)\r\nerror = ahc_aha398XX_setup(ahc);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aha494X_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7870_setup(ahc);\r\nif (error == 0)\r\nerror = ahc_aha494XX_setup(ahc);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aha494Xh_setup(struct ahc_softc *ahc)\r\n{\r\nint error = ahc_aha494X_setup(ahc);\r\nahc->features |= AHC_HVD;\r\nreturn error;\r\n}\r\nstatic int\r\nahc_aic7880_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\nuint8_t rev;\r\npci = ahc->dev_softc;\r\nahc->channel = 'A';\r\nahc->chip = AHC_AIC7880;\r\nahc->features = AHC_AIC7880_FE;\r\nahc->bugs |= AHC_TMODE_WIDEODD_BUG;\r\nrev = ahc_pci_read_config(pci, PCIR_REVID, 1);\r\nif (rev >= 1) {\r\nahc->bugs |= AHC_PCI_2_1_RETRY_BUG;\r\n} else {\r\nahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;\r\n}\r\nahc->instruction_ram_size = 512;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7880h_setup(struct ahc_softc *ahc)\r\n{\r\nint error = ahc_aic7880_setup(ahc);\r\nahc->features |= AHC_HVD;\r\nreturn error;\r\n}\r\nstatic int\r\nahc_aha2940Pro_setup(struct ahc_softc *ahc)\r\n{\r\nahc->flags |= AHC_INT50_SPEEDFLEX;\r\nreturn (ahc_aic7880_setup(ahc));\r\n}\r\nstatic int\r\nahc_aha394XU_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7880_setup(ahc);\r\nif (error == 0)\r\nerror = ahc_aha394XX_setup(ahc);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aha394XUh_setup(struct ahc_softc *ahc)\r\n{\r\nint error = ahc_aha394XU_setup(ahc);\r\nahc->features |= AHC_HVD;\r\nreturn error;\r\n}\r\nstatic int\r\nahc_aha398XU_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7880_setup(ahc);\r\nif (error == 0)\r\nerror = ahc_aha398XX_setup(ahc);\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aic7890_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\nuint8_t rev;\r\npci = ahc->dev_softc;\r\nahc->channel = 'A';\r\nahc->chip = AHC_AIC7890;\r\nahc->features = AHC_AIC7890_FE;\r\nahc->flags |= AHC_NEWEEPROM_FMT;\r\nrev = ahc_pci_read_config(pci, PCIR_REVID, 1);\r\nif (rev == 0)\r\nahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;\r\nahc->instruction_ram_size = 768;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7892_setup(struct ahc_softc *ahc)\r\n{\r\nahc->channel = 'A';\r\nahc->chip = AHC_AIC7892;\r\nahc->features = AHC_AIC7892_FE;\r\nahc->flags |= AHC_NEWEEPROM_FMT;\r\nahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;\r\nahc->instruction_ram_size = 1024;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7895_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\nuint8_t rev;\r\npci = ahc->dev_softc;\r\nahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';\r\nrev = ahc_pci_read_config(pci, PCIR_REVID, 1);\r\nif (rev >= 4) {\r\nahc->chip = AHC_AIC7895C;\r\nahc->features = AHC_AIC7895C_FE;\r\n} else {\r\nu_int command;\r\nahc->chip = AHC_AIC7895;\r\nahc->features = AHC_AIC7895_FE;\r\ncommand = ahc_pci_read_config(pci, PCIR_COMMAND, 1);\r\ncommand |= PCIM_CMD_MWRICEN;\r\nahc_pci_write_config(pci, PCIR_COMMAND, command, 1);\r\nahc->bugs |= AHC_PCI_MWI_BUG;\r\n}\r\nahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG\r\n| AHC_CACHETHEN_BUG;\r\n#if 0\r\nuint32_t devconfig;\r\nahc_pci_write_config(pci, CSIZE_LATTIME, 0, 1);\r\ndevconfig = ahc_pci_read_config(pci, DEVCONFIG, 1);\r\ndevconfig |= MRDCEN;\r\nahc_pci_write_config(pci, DEVCONFIG, devconfig, 1);\r\n#endif\r\nahc->flags |= AHC_NEWEEPROM_FMT;\r\nahc->instruction_ram_size = 512;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7895h_setup(struct ahc_softc *ahc)\r\n{\r\nint error = ahc_aic7895_setup(ahc);\r\nahc->features |= AHC_HVD;\r\nreturn error;\r\n}\r\nstatic int\r\nahc_aic7896_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\npci = ahc->dev_softc;\r\nahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';\r\nahc->chip = AHC_AIC7896;\r\nahc->features = AHC_AIC7896_FE;\r\nahc->flags |= AHC_NEWEEPROM_FMT;\r\nahc->bugs |= AHC_CACHETHEN_DIS_BUG;\r\nahc->instruction_ram_size = 768;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aic7899_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\npci = ahc->dev_softc;\r\nahc->channel = ahc_get_pci_function(pci) == 1 ? 'B' : 'A';\r\nahc->chip = AHC_AIC7899;\r\nahc->features = AHC_AIC7899_FE;\r\nahc->flags |= AHC_NEWEEPROM_FMT;\r\nahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;\r\nahc->instruction_ram_size = 1024;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aha29160C_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7899_setup(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nahc->features |= AHC_REMOVABLE;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_raid_setup(struct ahc_softc *ahc)\r\n{\r\nprintk("RAID functionality unsupported\n");\r\nreturn (ENXIO);\r\n}\r\nstatic int\r\nahc_aha394XX_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\npci = ahc->dev_softc;\r\nswitch (ahc_get_pci_slot(pci)) {\r\ncase AHC_394X_SLOT_CHANNEL_A:\r\nahc->channel = 'A';\r\nbreak;\r\ncase AHC_394X_SLOT_CHANNEL_B:\r\nahc->channel = 'B';\r\nbreak;\r\ndefault:\r\nprintk("adapter at unexpected slot %d\n"\r\n"unable to map to a channel\n",\r\nahc_get_pci_slot(pci));\r\nahc->channel = 'A';\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aha398XX_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\npci = ahc->dev_softc;\r\nswitch (ahc_get_pci_slot(pci)) {\r\ncase AHC_398X_SLOT_CHANNEL_A:\r\nahc->channel = 'A';\r\nbreak;\r\ncase AHC_398X_SLOT_CHANNEL_B:\r\nahc->channel = 'B';\r\nbreak;\r\ncase AHC_398X_SLOT_CHANNEL_C:\r\nahc->channel = 'C';\r\nbreak;\r\ndefault:\r\nprintk("adapter at unexpected slot %d\n"\r\n"unable to map to a channel\n",\r\nahc_get_pci_slot(pci));\r\nahc->channel = 'A';\r\nbreak;\r\n}\r\nahc->flags |= AHC_LARGE_SEEPROM;\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_aha494XX_setup(struct ahc_softc *ahc)\r\n{\r\nahc_dev_softc_t pci;\r\npci = ahc->dev_softc;\r\nswitch (ahc_get_pci_slot(pci)) {\r\ncase AHC_494X_SLOT_CHANNEL_A:\r\nahc->channel = 'A';\r\nbreak;\r\ncase AHC_494X_SLOT_CHANNEL_B:\r\nahc->channel = 'B';\r\nbreak;\r\ncase AHC_494X_SLOT_CHANNEL_C:\r\nahc->channel = 'C';\r\nbreak;\r\ncase AHC_494X_SLOT_CHANNEL_D:\r\nahc->channel = 'D';\r\nbreak;\r\ndefault:\r\nprintk("adapter at unexpected slot %d\n"\r\n"unable to map to a channel\n",\r\nahc_get_pci_slot(pci));\r\nahc->channel = 'A';\r\n}\r\nahc->flags |= AHC_LARGE_SEEPROM;\r\nreturn (0);\r\n}
