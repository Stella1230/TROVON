static void pss_write(pss_confdata *devc, int data)\r\n{\r\nunsigned long i, limit;\r\nlimit = jiffies + HZ/10;\r\nfor (i = 0; i < 5000000 && time_before(jiffies, limit); i++)\r\n{\r\nif (inw(REG(PSS_STATUS)) & PSS_WRITE_EMPTY)\r\n{\r\noutw(data, REG(PSS_DATA));\r\nreturn;\r\n}\r\n}\r\nprintk(KERN_WARNING "PSS: DSP Command (%04x) Timeout.\n", data);\r\n}\r\nstatic int __init probe_pss(struct address_info *hw_config)\r\n{\r\nunsigned short id;\r\nint irq, dma;\r\ndevc->base = hw_config->io_base;\r\nirq = devc->irq = hw_config->irq;\r\ndma = devc->dma = hw_config->dma;\r\ndevc->osp = hw_config->osp;\r\nif (devc->base != 0x220 && devc->base != 0x240)\r\nif (devc->base != 0x230 && devc->base != 0x250)\r\nreturn 0;\r\nif (!request_region(devc->base, 0x10, "PSS mixer, SB emulation")) {\r\nprintk(KERN_ERR "PSS: I/O port conflict\n");\r\nreturn 0;\r\n}\r\nid = inw(REG(PSS_ID));\r\nif ((id >> 8) != 'E') {\r\nprintk(KERN_ERR "No PSS signature detected at 0x%x (0x%x)\n", devc->base, id);\r\nrelease_region(devc->base, 0x10);\r\nreturn 0;\r\n}\r\nif (!request_region(devc->base + 0x10, 0x9, "PSS config")) {\r\nprintk(KERN_ERR "PSS: I/O port conflict\n");\r\nrelease_region(devc->base, 0x10);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int set_irq(pss_confdata * devc, int dev, int irq)\r\n{\r\nstatic unsigned short irq_bits[16] =\r\n{\r\n0x0000, 0x0000, 0x0000, 0x0008,\r\n0x0000, 0x0010, 0x0000, 0x0018,\r\n0x0000, 0x0020, 0x0028, 0x0030,\r\n0x0038, 0x0000, 0x0000, 0x0000\r\n};\r\nunsigned short tmp, bits;\r\nif (irq < 0 || irq > 15)\r\nreturn 0;\r\ntmp = inw(REG(dev)) & ~0x38;\r\nif ((bits = irq_bits[irq]) == 0 && irq != 0)\r\n{\r\nprintk(KERN_ERR "PSS: Invalid IRQ %d\n", irq);\r\nreturn 0;\r\n}\r\noutw(tmp | bits, REG(dev));\r\nreturn 1;\r\n}\r\nstatic void set_io_base(pss_confdata * devc, int dev, int base)\r\n{\r\nunsigned short tmp = inw(REG(dev)) & 0x003f;\r\nunsigned short bits = (base & 0x0ffc) << 4;\r\noutw(bits | tmp, REG(dev));\r\n}\r\nstatic int set_dma(pss_confdata * devc, int dev, int dma)\r\n{\r\nstatic unsigned short dma_bits[8] =\r\n{\r\n0x0001, 0x0002, 0x0000, 0x0003,\r\n0x0000, 0x0005, 0x0006, 0x0007\r\n};\r\nunsigned short tmp, bits;\r\nif (dma < 0 || dma > 7)\r\nreturn 0;\r\ntmp = inw(REG(dev)) & ~0x07;\r\nif ((bits = dma_bits[dma]) == 0 && dma != 4)\r\n{\r\nprintk(KERN_ERR "PSS: Invalid DMA %d\n", dma);\r\nreturn 0;\r\n}\r\noutw(tmp | bits, REG(dev));\r\nreturn 1;\r\n}\r\nstatic int pss_reset_dsp(pss_confdata * devc)\r\n{\r\nunsigned long i, limit = jiffies + HZ/10;\r\noutw(0x2000, REG(PSS_CONTROL));\r\nfor (i = 0; i < 32768 && time_after_eq(limit, jiffies); i++)\r\ninw(REG(PSS_CONTROL));\r\noutw(0x0000, REG(PSS_CONTROL));\r\nreturn 1;\r\n}\r\nstatic int pss_put_dspword(pss_confdata * devc, unsigned short word)\r\n{\r\nint i, val;\r\nfor (i = 0; i < 327680; i++)\r\n{\r\nval = inw(REG(PSS_STATUS));\r\nif (val & PSS_WRITE_EMPTY)\r\n{\r\noutw(word, REG(PSS_DATA));\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pss_get_dspword(pss_confdata * devc, unsigned short *word)\r\n{\r\nint i, val;\r\nfor (i = 0; i < 327680; i++)\r\n{\r\nval = inw(REG(PSS_STATUS));\r\nif (val & PSS_READ_FULL)\r\n{\r\n*word = inw(REG(PSS_DATA));\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pss_download_boot(pss_confdata * devc, unsigned char *block, int size, int flags)\r\n{\r\nint i, val, count;\r\nunsigned long limit;\r\nif (flags & CPF_FIRST)\r\n{\r\noutw(0x00fe, REG(PSS_DATA));\r\nlimit = jiffies + HZ/10;\r\nfor (i = 0; i < 32768 && time_before(jiffies, limit); i++)\r\nif (inw(REG(PSS_DATA)) == 0x5500)\r\nbreak;\r\noutw(*block++, REG(PSS_DATA));\r\npss_reset_dsp(devc);\r\n}\r\ncount = 1;\r\nwhile ((flags&CPF_LAST) || count<size )\r\n{\r\nint j;\r\nfor (j = 0; j < 327670; j++)\r\n{\r\nif (inw(REG(PSS_STATUS)) & PSS_FLAG3)\r\nbreak;\r\n}\r\nif (j == 327670)\r\n{\r\nif (count >= size && flags & CPF_LAST)\r\nbreak;\r\nelse\r\n{\r\nprintk("\n");\r\nprintk(KERN_ERR "PSS: Download timeout problems, byte %d=%d\n", count, size);\r\nreturn 0;\r\n}\r\n}\r\nif (count >= size)\r\n{\r\noutw (0xffff, REG (PSS_DATA));\r\n}\r\nelse\r\n{\r\noutw (*block++, REG (PSS_DATA));\r\n}\r\ncount++;\r\n}\r\nif (flags & CPF_LAST)\r\n{\r\noutw(0, REG(PSS_DATA));\r\nlimit = jiffies + HZ/10;\r\nfor (i = 0; i < 32768 && time_after_eq(limit, jiffies); i++)\r\nval = inw(REG(PSS_STATUS));\r\nlimit = jiffies + HZ/10;\r\nfor (i = 0; i < 32768 && time_after_eq(limit, jiffies); i++)\r\n{\r\nval = inw(REG(PSS_STATUS));\r\nif (val & 0x4000)\r\nbreak;\r\n}\r\nfor (i = 0; i < 32000; i++)\r\n{\r\nval = inw(REG(PSS_STATUS));\r\nif (val & PSS_READ_FULL)\r\nbreak;\r\n}\r\nif (i == 32000)\r\nreturn 0;\r\nval = inw(REG(PSS_DATA));\r\n}\r\nreturn 1;\r\n}\r\nstatic void set_master_volume(pss_confdata *devc, int left, int right)\r\n{\r\nstatic unsigned char log_scale[101] = {\r\n0xdb, 0xe0, 0xe3, 0xe5, 0xe7, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xed, 0xee,\r\n0xef, 0xef, 0xf0, 0xf0, 0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf3, 0xf3, 0xf3,\r\n0xf4, 0xf4, 0xf4, 0xf5, 0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf6, 0xf7,\r\n0xf7, 0xf7, 0xf7, 0xf7, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9,\r\n0xf9, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb,\r\n0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,\r\n0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd,\r\n0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,\r\n0xfe, 0xfe, 0xff, 0xff, 0xff\r\n};\r\npss_write(devc, 0x0010);\r\npss_write(devc, log_scale[left] | 0x0000);\r\npss_write(devc, 0x0010);\r\npss_write(devc, log_scale[right] | 0x0100);\r\n}\r\nstatic void set_synth_volume(pss_confdata *devc, int volume)\r\n{\r\nint vol = ((0x8000*volume)/100L);\r\npss_write(devc, 0x0080);\r\npss_write(devc, vol);\r\npss_write(devc, 0x0081);\r\npss_write(devc, vol);\r\n}\r\nstatic void set_bass(pss_confdata *devc, int level)\r\n{\r\nint vol = (int)(((0xfd - 0xf0) * level)/100L) + 0xf0;\r\npss_write(devc, 0x0010);\r\npss_write(devc, vol | 0x0200);\r\n}\r\nstatic void set_treble(pss_confdata *devc, int level)\r\n{\r\nint vol = (((0xfd - 0xf0) * level)/100L) + 0xf0;\r\npss_write(devc, 0x0010);\r\npss_write(devc, vol | 0x0300);\r\n}\r\nstatic void pss_mixer_reset(pss_confdata *devc)\r\n{\r\nset_master_volume(devc, 33, 33);\r\nset_bass(devc, 50);\r\nset_treble(devc, 50);\r\nset_synth_volume(devc, 30);\r\npss_write (devc, 0x0010);\r\npss_write (devc, 0x0800 | 0xce);\r\nif(pss_mixer)\r\n{\r\ndevc->mixer.volume_l = devc->mixer.volume_r = 33;\r\ndevc->mixer.bass = 50;\r\ndevc->mixer.treble = 50;\r\ndevc->mixer.synth = 30;\r\n}\r\n}\r\nstatic int set_volume_mono(unsigned __user *p, unsigned int *aleft)\r\n{\r\nunsigned int left, volume;\r\nif (get_user(volume, p))\r\nreturn -EFAULT;\r\nleft = volume & 0xff;\r\nif (left > 100)\r\nleft = 100;\r\n*aleft = left;\r\nreturn 0;\r\n}\r\nstatic int set_volume_stereo(unsigned __user *p,\r\nunsigned int *aleft,\r\nunsigned int *aright)\r\n{\r\nunsigned int left, right, volume;\r\nif (get_user(volume, p))\r\nreturn -EFAULT;\r\nleft = volume & 0xff;\r\nif (left > 100)\r\nleft = 100;\r\nright = (volume >> 8) & 0xff;\r\nif (right > 100)\r\nright = 100;\r\n*aleft = left;\r\n*aright = right;\r\nreturn 0;\r\n}\r\nstatic int ret_vol_mono(int left)\r\n{\r\nreturn ((left << 8) | left);\r\n}\r\nstatic int ret_vol_stereo(int left, int right)\r\n{\r\nreturn ((right << 8) | left);\r\n}\r\nstatic int call_ad_mixer(pss_confdata *devc,unsigned int cmd, void __user *arg)\r\n{\r\nif (devc->ad_mixer_dev != NO_WSS_MIXER)\r\nreturn mixer_devs[devc->ad_mixer_dev]->ioctl(devc->ad_mixer_dev, cmd, arg);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int pss_mixer_ioctl (int dev, unsigned int cmd, void __user *arg)\r\n{\r\npss_confdata *devc = mixer_devs[dev]->devc;\r\nint cmdf = cmd & 0xff;\r\nif ((cmdf != SOUND_MIXER_VOLUME) && (cmdf != SOUND_MIXER_BASS) &&\r\n(cmdf != SOUND_MIXER_TREBLE) && (cmdf != SOUND_MIXER_SYNTH) &&\r\n(cmdf != SOUND_MIXER_DEVMASK) && (cmdf != SOUND_MIXER_STEREODEVS) &&\r\n(cmdf != SOUND_MIXER_RECMASK) && (cmdf != SOUND_MIXER_CAPS) &&\r\n(cmdf != SOUND_MIXER_RECSRC))\r\n{\r\nreturn call_ad_mixer(devc, cmd, arg);\r\n}\r\nif (((cmd >> 8) & 0xff) != 'M')\r\nreturn -EINVAL;\r\nif (_SIOC_DIR (cmd) & _SIOC_WRITE)\r\n{\r\nswitch (cmdf)\r\n{\r\ncase SOUND_MIXER_RECSRC:\r\nif (devc->ad_mixer_dev != NO_WSS_MIXER)\r\nreturn call_ad_mixer(devc, cmd, arg);\r\nelse\r\n{\r\nint v;\r\nif (get_user(v, (int __user *)arg))\r\nreturn -EFAULT;\r\nif (v != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\ncase SOUND_MIXER_VOLUME:\r\nif (set_volume_stereo(arg,\r\n&devc->mixer.volume_l,\r\n&devc->mixer.volume_r))\r\nreturn -EFAULT;\r\nset_master_volume(devc, devc->mixer.volume_l,\r\ndevc->mixer.volume_r);\r\nreturn ret_vol_stereo(devc->mixer.volume_l,\r\ndevc->mixer.volume_r);\r\ncase SOUND_MIXER_BASS:\r\nif (set_volume_mono(arg, &devc->mixer.bass))\r\nreturn -EFAULT;\r\nset_bass(devc, devc->mixer.bass);\r\nreturn ret_vol_mono(devc->mixer.bass);\r\ncase SOUND_MIXER_TREBLE:\r\nif (set_volume_mono(arg, &devc->mixer.treble))\r\nreturn -EFAULT;\r\nset_treble(devc, devc->mixer.treble);\r\nreturn ret_vol_mono(devc->mixer.treble);\r\ncase SOUND_MIXER_SYNTH:\r\nif (set_volume_mono(arg, &devc->mixer.synth))\r\nreturn -EFAULT;\r\nset_synth_volume(devc, devc->mixer.synth);\r\nreturn ret_vol_mono(devc->mixer.synth);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse\r\n{\r\nint val, and_mask = 0, or_mask = 0;\r\nswitch (cmdf)\r\n{\r\ncase SOUND_MIXER_DEVMASK:\r\nif (call_ad_mixer(devc, cmd, arg) == -EINVAL)\r\nbreak;\r\nand_mask = ~0;\r\nor_mask = SOUND_MASK_VOLUME | SOUND_MASK_BASS | SOUND_MASK_TREBLE | SOUND_MASK_SYNTH;\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nif (call_ad_mixer(devc, cmd, arg) == -EINVAL)\r\nbreak;\r\nand_mask = ~0;\r\nor_mask = SOUND_MASK_VOLUME;\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nif (devc->ad_mixer_dev != NO_WSS_MIXER)\r\nreturn call_ad_mixer(devc, cmd, arg);\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nif (devc->ad_mixer_dev != NO_WSS_MIXER)\r\nreturn call_ad_mixer(devc, cmd, arg);\r\nor_mask = SOUND_CAP_EXCL_INPUT;\r\nbreak;\r\ncase SOUND_MIXER_RECSRC:\r\nif (devc->ad_mixer_dev != NO_WSS_MIXER)\r\nreturn call_ad_mixer(devc, cmd, arg);\r\nbreak;\r\ncase SOUND_MIXER_VOLUME:\r\nor_mask = ret_vol_stereo(devc->mixer.volume_l, devc->mixer.volume_r);\r\nbreak;\r\ncase SOUND_MIXER_BASS:\r\nor_mask = ret_vol_mono(devc->mixer.bass);\r\nbreak;\r\ncase SOUND_MIXER_TREBLE:\r\nor_mask = ret_vol_mono(devc->mixer.treble);\r\nbreak;\r\ncase SOUND_MIXER_SYNTH:\r\nor_mask = ret_vol_mono(devc->mixer.synth);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nval &= and_mask;\r\nval |= or_mask;\r\nif (put_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nreturn val;\r\n}\r\n}\r\nstatic void disable_all_emulations(void)\r\n{\r\noutw(0x0000, REG(CONF_PSS));\r\noutw(0x0000, REG(CONF_WSS));\r\noutw(0x0000, REG(CONF_SB));\r\noutw(0x0000, REG(CONF_MIDI));\r\noutw(0x0000, REG(CONF_CDROM));\r\n}\r\nstatic void configure_nonsound_components(void)\r\n{\r\nif(pss_enable_joystick)\r\n{\r\noutw(0x0400, REG(CONF_PSS));\r\nprintk(KERN_INFO "PSS: joystick enabled.\n");\r\n}\r\nelse\r\n{\r\nprintk(KERN_INFO "PSS: joystick port not enabled.\n");\r\n}\r\nif (pss_cdrom_port == -1) {\r\nprintk(KERN_INFO "PSS: CDROM port not enabled.\n");\r\n} else if (!request_region(pss_cdrom_port, 2, "PSS CDROM")) {\r\npss_cdrom_port = -1;\r\nprintk(KERN_ERR "PSS: CDROM I/O port conflict.\n");\r\n} else {\r\nset_io_base(devc, CONF_CDROM, pss_cdrom_port);\r\nprintk(KERN_INFO "PSS: CDROM I/O port set to 0x%x.\n", pss_cdrom_port);\r\n}\r\n}\r\nstatic int __init attach_pss(struct address_info *hw_config)\r\n{\r\nunsigned short id;\r\nchar tmp[100];\r\ndevc->base = hw_config->io_base;\r\ndevc->irq = hw_config->irq;\r\ndevc->dma = hw_config->dma;\r\ndevc->osp = hw_config->osp;\r\ndevc->ad_mixer_dev = NO_WSS_MIXER;\r\nif (!probe_pss(hw_config))\r\nreturn 0;\r\nid = inw(REG(PSS_ID)) & 0x00ff;\r\ndisable_all_emulations();\r\n#ifdef YOU_REALLY_WANT_TO_ALLOCATE_THESE_RESOURCES\r\nif (sound_alloc_dma(hw_config->dma, "PSS"))\r\n{\r\nprintk("pss.c: Can't allocate DMA channel.\n");\r\nrelease_region(hw_config->io_base, 0x10);\r\nrelease_region(hw_config->io_base+0x10, 0x9);\r\nreturn 0;\r\n}\r\nif (!set_irq(devc, CONF_PSS, devc->irq))\r\n{\r\nprintk("PSS: IRQ allocation error.\n");\r\nrelease_region(hw_config->io_base, 0x10);\r\nrelease_region(hw_config->io_base+0x10, 0x9);\r\nreturn 0;\r\n}\r\nif (!set_dma(devc, CONF_PSS, devc->dma))\r\n{\r\nprintk(KERN_ERR "PSS: DMA allocation error\n");\r\nrelease_region(hw_config->io_base, 0x10);\r\nrelease_region(hw_config->io_base+0x10, 0x9);\r\nreturn 0;\r\n}\r\n#endif\r\nconfigure_nonsound_components();\r\npss_initialized = 1;\r\nsprintf(tmp, "ECHO-PSS Rev. %d", id);\r\nconf_printf(tmp, hw_config);\r\nreturn 1;\r\n}\r\nstatic int __init probe_pss_mpu(struct address_info *hw_config)\r\n{\r\nstruct resource *ports;\r\nint timeout;\r\nif (!pss_initialized)\r\nreturn 0;\r\nports = request_region(hw_config->io_base, 2, "mpu401");\r\nif (!ports) {\r\nprintk(KERN_ERR "PSS: MPU I/O port conflict\n");\r\nreturn 0;\r\n}\r\nset_io_base(devc, CONF_MIDI, hw_config->io_base);\r\nif (!set_irq(devc, CONF_MIDI, hw_config->irq)) {\r\nprintk(KERN_ERR "PSS: MIDI IRQ allocation error.\n");\r\ngoto fail;\r\n}\r\nif (!pss_synthLen) {\r\nprintk(KERN_ERR "PSS: Can't enable MPU. MIDI synth microcode not available.\n");\r\ngoto fail;\r\n}\r\nif (!pss_download_boot(devc, pss_synth, pss_synthLen, CPF_FIRST | CPF_LAST)) {\r\nprintk(KERN_ERR "PSS: Unable to load MIDI synth microcode to DSP.\n");\r\ngoto fail;\r\n}\r\nfor (timeout = 900000; timeout > 0; timeout--)\r\n{\r\nif ((inb(hw_config->io_base + 1) & 0x80) == 0)\r\ninb(hw_config->io_base);\r\nelse\r\nbreak;\r\n}\r\nif (!probe_mpu401(hw_config, ports))\r\ngoto fail;\r\nattach_mpu401(hw_config, THIS_MODULE);\r\nif (hw_config->slots[1] != -1)\r\nmidi_devs[hw_config->slots[1]]->coproc = &pss_coproc_operations;\r\nreturn 1;\r\nfail:\r\nrelease_region(hw_config->io_base, 2);\r\nreturn 0;\r\n}\r\nstatic int pss_coproc_open(void *dev_info, int sub_device)\r\n{\r\nswitch (sub_device)\r\n{\r\ncase COPR_MIDI:\r\nif (pss_synthLen == 0)\r\n{\r\nprintk(KERN_ERR "PSS: MIDI synth microcode not available.\n");\r\nreturn -EIO;\r\n}\r\nif (nonstandard_microcode)\r\nif (!pss_download_boot(devc, pss_synth, pss_synthLen, CPF_FIRST | CPF_LAST))\r\n{\r\nprintk(KERN_ERR "PSS: Unable to load MIDI synth microcode to DSP.\n");\r\nreturn -EIO;\r\n}\r\nnonstandard_microcode = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pss_coproc_close(void *dev_info, int sub_device)\r\n{\r\nreturn;\r\n}\r\nstatic void pss_coproc_reset(void *dev_info)\r\n{\r\nif (pss_synthLen)\r\nif (!pss_download_boot(devc, pss_synth, pss_synthLen, CPF_FIRST | CPF_LAST))\r\n{\r\nprintk(KERN_ERR "PSS: Unable to load MIDI synth microcode to DSP.\n");\r\n}\r\nnonstandard_microcode = 0;\r\n}\r\nstatic int download_boot_block(void *dev_info, copr_buffer * buf)\r\n{\r\nif (buf->len <= 0 || buf->len > sizeof(buf->data))\r\nreturn -EINVAL;\r\nif (!pss_download_boot(devc, buf->data, buf->len, buf->flags))\r\n{\r\nprintk(KERN_ERR "PSS: Unable to load microcode block to DSP.\n");\r\nreturn -EIO;\r\n}\r\nnonstandard_microcode = 1;\r\nreturn 0;\r\n}\r\nstatic int pss_coproc_ioctl(void *dev_info, unsigned int cmd, void __user *arg, int local)\r\n{\r\ncopr_buffer *buf;\r\ncopr_msg *mbuf;\r\ncopr_debug_buf dbuf;\r\nunsigned short tmp;\r\nunsigned long flags;\r\nunsigned short *data;\r\nint i, err;\r\nswitch (cmd)\r\n{\r\ncase SNDCTL_COPR_RESET:\r\npss_coproc_reset(dev_info);\r\nreturn 0;\r\ncase SNDCTL_COPR_LOAD:\r\nbuf = vmalloc(sizeof(copr_buffer));\r\nif (buf == NULL)\r\nreturn -ENOSPC;\r\nif (copy_from_user(buf, arg, sizeof(copr_buffer))) {\r\nvfree(buf);\r\nreturn -EFAULT;\r\n}\r\nerr = download_boot_block(dev_info, buf);\r\nvfree(buf);\r\nreturn err;\r\ncase SNDCTL_COPR_SENDMSG:\r\nmbuf = vmalloc(sizeof(copr_msg));\r\nif (mbuf == NULL)\r\nreturn -ENOSPC;\r\nif (copy_from_user(mbuf, arg, sizeof(copr_msg))) {\r\nvfree(mbuf);\r\nreturn -EFAULT;\r\n}\r\ndata = (unsigned short *)(mbuf->data);\r\nspin_lock_irqsave(&lock, flags);\r\nfor (i = 0; i < mbuf->len; i++) {\r\nif (!pss_put_dspword(devc, *data++)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nmbuf->len = i;\r\nerr = copy_to_user(arg, mbuf, sizeof(copr_msg));\r\nvfree(mbuf);\r\nreturn err ? -EFAULT : -EIO;\r\n}\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\nvfree(mbuf);\r\nreturn 0;\r\ncase SNDCTL_COPR_RCVMSG:\r\nerr = 0;\r\nmbuf = vmalloc(sizeof(copr_msg));\r\nif (mbuf == NULL)\r\nreturn -ENOSPC;\r\ndata = (unsigned short *)mbuf->data;\r\nspin_lock_irqsave(&lock, flags);\r\nfor (i = 0; i < sizeof(mbuf->data)/sizeof(unsigned short); i++) {\r\nmbuf->len = i;\r\nif (!pss_get_dspword(devc, data++)) {\r\nif (i == 0)\r\nerr = -EIO;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\nif (copy_to_user(arg, mbuf, sizeof(copr_msg)))\r\nerr = -EFAULT;\r\nvfree(mbuf);\r\nreturn err;\r\ncase SNDCTL_COPR_RDATA:\r\nif (copy_from_user(&dbuf, arg, sizeof(dbuf)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&lock, flags);\r\nif (!pss_put_dspword(devc, 0x00d0)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nif (!pss_put_dspword(devc, (unsigned short)(dbuf.parm1 & 0xffff))) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nif (!pss_get_dspword(devc, &tmp)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\ndbuf.parm1 = tmp;\r\nspin_unlock_irqrestore(&lock,flags);\r\nif (copy_to_user(arg, &dbuf, sizeof(dbuf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_COPR_WDATA:\r\nif (copy_from_user(&dbuf, arg, sizeof(dbuf)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&lock, flags);\r\nif (!pss_put_dspword(devc, 0x00d1)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nif (!pss_put_dspword(devc, (unsigned short) (dbuf.parm1 & 0xffff))) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\ntmp = (unsigned int)dbuf.parm2 & 0xffff;\r\nif (!pss_put_dspword(devc, tmp)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn 0;\r\ncase SNDCTL_COPR_WCODE:\r\nif (copy_from_user(&dbuf, arg, sizeof(dbuf)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&lock, flags);\r\nif (!pss_put_dspword(devc, 0x00d3)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nif (!pss_put_dspword(devc, (unsigned short)(dbuf.parm1 & 0xffff))) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\ntmp = (unsigned int)dbuf.parm2 & 0x00ff;\r\nif (!pss_put_dspword(devc, tmp)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\ntmp = ((unsigned int)dbuf.parm2 >> 8) & 0xffff;\r\nif (!pss_put_dspword(devc, tmp)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn 0;\r\ncase SNDCTL_COPR_RCODE:\r\nif (copy_from_user(&dbuf, arg, sizeof(dbuf)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&lock, flags);\r\nif (!pss_put_dspword(devc, 0x00d2)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nif (!pss_put_dspword(devc, (unsigned short)(dbuf.parm1 & 0xffff))) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\nif (!pss_get_dspword(devc, &tmp)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\ndbuf.parm1 = tmp << 8;\r\nif (!pss_get_dspword(devc, &tmp)) {\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn -EIO;\r\n}\r\ndbuf.parm1 |= tmp & 0x00ff;\r\nspin_unlock_irqrestore(&lock,flags);\r\nif (copy_to_user(arg, &dbuf, sizeof(dbuf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init probe_pss_mss(struct address_info *hw_config)\r\n{\r\nvolatile int timeout;\r\nstruct resource *ports;\r\nint my_mix = -999;\r\nif (!pss_initialized)\r\nreturn 0;\r\nif (!request_region(hw_config->io_base, 4, "WSS config")) {\r\nprintk(KERN_ERR "PSS: WSS I/O port conflicts.\n");\r\nreturn 0;\r\n}\r\nports = request_region(hw_config->io_base + 4, 4, "ad1848");\r\nif (!ports) {\r\nprintk(KERN_ERR "PSS: WSS I/O port conflicts.\n");\r\nrelease_region(hw_config->io_base, 4);\r\nreturn 0;\r\n}\r\nset_io_base(devc, CONF_WSS, hw_config->io_base);\r\nif (!set_irq(devc, CONF_WSS, hw_config->irq)) {\r\nprintk("PSS: WSS IRQ allocation error.\n");\r\ngoto fail;\r\n}\r\nif (!set_dma(devc, CONF_WSS, hw_config->dma)) {\r\nprintk(KERN_ERR "PSS: WSS DMA allocation error\n");\r\ngoto fail;\r\n}\r\nfor (timeout = 0; timeout < 100000 && (inb(hw_config->io_base + WSS_INDEX) &\r\nWSS_INITIALIZING); timeout++)\r\n;\r\noutb((0x0b), hw_config->io_base + WSS_INDEX);\r\nfor (timeout = 0; (inb(hw_config->io_base + WSS_DATA) & WSS_AUTOCALIBRATION) &&\r\n(timeout < 100000); timeout++)\r\n;\r\nif (!probe_ms_sound(hw_config, ports))\r\ngoto fail;\r\ndevc->ad_mixer_dev = NO_WSS_MIXER;\r\nif (pss_mixer)\r\n{\r\nif ((my_mix = sound_install_mixer (MIXER_DRIVER_VERSION,\r\n"PSS-SPEAKERS and AD1848 (through MSS audio codec)",\r\n&pss_mixer_operations,\r\nsizeof (struct mixer_operations),\r\ndevc)) < 0)\r\n{\r\nprintk(KERN_ERR "Could not install PSS mixer\n");\r\ngoto fail;\r\n}\r\n}\r\npss_mixer_reset(devc);\r\nattach_ms_sound(hw_config, ports, THIS_MODULE);\r\nif (hw_config->slots[0] != -1)\r\n{\r\naudio_devs[hw_config->slots[0]]->coproc = &pss_coproc_operations;\r\nif (pss_mixer && (num_mixers == (my_mix + 2)))\r\n{\r\ndevc->ad_mixer_dev = audio_devs[hw_config->slots[0]]->mixer_dev;\r\n}\r\n}\r\nreturn 1;\r\nfail:\r\nrelease_region(hw_config->io_base + 4, 4);\r\nrelease_region(hw_config->io_base, 4);\r\nreturn 0;\r\n}\r\nstatic inline void __exit unload_pss(struct address_info *hw_config)\r\n{\r\nrelease_region(hw_config->io_base, 0x10);\r\nrelease_region(hw_config->io_base+0x10, 0x9);\r\n}\r\nstatic inline void __exit unload_pss_mpu(struct address_info *hw_config)\r\n{\r\nunload_mpu401(hw_config);\r\n}\r\nstatic inline void __exit unload_pss_mss(struct address_info *hw_config)\r\n{\r\nunload_ms_sound(hw_config);\r\n}\r\nstatic int __init init_pss(void)\r\n{\r\nif(pss_no_sound)\r\n{\r\ncfg.io_base = pss_io;\r\nif(!probe_pss(&cfg))\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "ECHO-PSS Rev. %d\n", inw(REG(PSS_ID)) & 0x00ff);\r\nprintk(KERN_INFO "PSS: loading in no sound mode.\n");\r\ndisable_all_emulations();\r\nconfigure_nonsound_components();\r\nrelease_region(pss_io, 0x10);\r\nrelease_region(pss_io + 0x10, 0x9);\r\nreturn 0;\r\n}\r\ncfg.io_base = pss_io;\r\ncfg2.io_base = mss_io;\r\ncfg2.irq = mss_irq;\r\ncfg2.dma = mss_dma;\r\ncfg_mpu.io_base = mpu_io;\r\ncfg_mpu.irq = mpu_irq;\r\nif (cfg.io_base == -1 || cfg2.io_base == -1 || cfg2.irq == -1 || cfg.dma == -1) {\r\nprintk(KERN_INFO "pss: mss_io, mss_dma, mss_irq and pss_io must be set.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pss_synth) {\r\nfw_load = 1;\r\npss_synthLen = mod_firmware_load(pss_firmware, (void *) &pss_synth);\r\n}\r\nif (!attach_pss(&cfg))\r\nreturn -ENODEV;\r\nif (probe_pss_mpu(&cfg_mpu))\r\npssmpu = 1;\r\nif (probe_pss_mss(&cfg2))\r\npssmss = 1;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_pss(void)\r\n{\r\nif(!pss_no_sound)\r\n{\r\nif(fw_load && pss_synth)\r\nvfree(pss_synth);\r\nif(pssmss)\r\nunload_pss_mss(&cfg2);\r\nif(pssmpu)\r\nunload_pss_mpu(&cfg_mpu);\r\nunload_pss(&cfg);\r\n} else if (pss_cdrom_port != -1)\r\nrelease_region(pss_cdrom_port, 2);\r\nif(!pss_keep_settings)\r\n{\r\ndisable_all_emulations();\r\nprintk(KERN_INFO "Resetting PSS sound card configurations.\n");\r\n}\r\n}\r\nstatic int __init setup_pss(char *str)\r\n{\r\nint ints[7];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\npss_io = ints[1];\r\nmss_io = ints[2];\r\nmss_irq = ints[3];\r\nmss_dma = ints[4];\r\nmpu_io = ints[5];\r\nmpu_irq = ints[6];\r\nreturn 1;\r\n}
