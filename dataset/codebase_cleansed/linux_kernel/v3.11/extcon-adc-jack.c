static void adc_jack_handler(struct work_struct *work)\r\n{\r\nstruct adc_jack_data *data = container_of(to_delayed_work(work),\r\nstruct adc_jack_data,\r\nhandler);\r\nu32 state = 0;\r\nint ret, adc_val;\r\nint i;\r\nret = iio_read_channel_raw(data->chan, &adc_val);\r\nif (ret < 0) {\r\ndev_err(data->edev.dev, "read channel() error: %d\n", ret);\r\nreturn;\r\n}\r\nfor (i = 0; i < data->num_conditions; i++) {\r\nstruct adc_jack_cond *def = &data->adc_conditions[i];\r\nif (!def->state)\r\nbreak;\r\nif (def->min_adc <= adc_val && def->max_adc >= adc_val) {\r\nstate = def->state;\r\nbreak;\r\n}\r\n}\r\nextcon_set_state(&data->edev, state);\r\n}\r\nstatic irqreturn_t adc_jack_irq_thread(int irq, void *_data)\r\n{\r\nstruct adc_jack_data *data = _data;\r\nschedule_delayed_work(&data->handler, data->handling_delay);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adc_jack_probe(struct platform_device *pdev)\r\n{\r\nstruct adc_jack_data *data;\r\nstruct adc_jack_pdata *pdata = pdev->dev.platform_data;\r\nint i, err = 0;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->edev.name = pdata->name;\r\nif (!pdata->cable_names) {\r\nerr = -EINVAL;\r\ndev_err(&pdev->dev, "error: cable_names not defined.\n");\r\ngoto out;\r\n}\r\ndata->edev.supported_cable = pdata->cable_names;\r\nfor (i = 0; data->edev.supported_cable[i]; i++)\r\n;\r\nif (i == 0 || i > SUPPORTED_CABLE_MAX) {\r\nerr = -EINVAL;\r\ndev_err(&pdev->dev, "error: pdata->cable_names size = %d\n",\r\ni - 1);\r\ngoto out;\r\n}\r\ndata->num_cables = i;\r\nif (!pdata->adc_conditions ||\r\n!pdata->adc_conditions[0].state) {\r\nerr = -EINVAL;\r\ndev_err(&pdev->dev, "error: adc_conditions not defined.\n");\r\ngoto out;\r\n}\r\ndata->adc_conditions = pdata->adc_conditions;\r\nfor (i = 0; data->adc_conditions[i].state; i++)\r\n;\r\ndata->num_conditions = i;\r\ndata->chan = iio_channel_get(&pdev->dev, pdata->consumer_channel);\r\nif (IS_ERR(data->chan)) {\r\nerr = PTR_ERR(data->chan);\r\ngoto out;\r\n}\r\ndata->handling_delay = msecs_to_jiffies(pdata->handling_delay_ms);\r\nINIT_DEFERRABLE_WORK(&data->handler, adc_jack_handler);\r\nplatform_set_drvdata(pdev, data);\r\nerr = extcon_dev_register(&data->edev, &pdev->dev);\r\nif (err)\r\ngoto out;\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (!data->irq) {\r\ndev_err(&pdev->dev, "platform_get_irq failed\n");\r\nerr = -ENODEV;\r\ngoto err_irq;\r\n}\r\nerr = request_any_context_irq(data->irq, adc_jack_irq_thread,\r\npdata->irq_flags, pdata->name, data);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "error: irq %d\n", data->irq);\r\ngoto err_irq;\r\n}\r\nreturn 0;\r\nerr_irq:\r\nextcon_dev_unregister(&data->edev);\r\nout:\r\nreturn err;\r\n}\r\nstatic int adc_jack_remove(struct platform_device *pdev)\r\n{\r\nstruct adc_jack_data *data = platform_get_drvdata(pdev);\r\nfree_irq(data->irq, data);\r\ncancel_work_sync(&data->handler.work);\r\nextcon_dev_unregister(&data->edev);\r\nreturn 0;\r\n}
