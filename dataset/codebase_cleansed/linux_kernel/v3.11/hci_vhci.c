static int vhci_open_dev(struct hci_dev *hdev)\r\n{\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nreturn 0;\r\n}\r\nstatic int vhci_close_dev(struct hci_dev *hdev)\r\n{\r\nstruct vhci_data *data = hci_get_drvdata(hdev);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nskb_queue_purge(&data->readq);\r\nreturn 0;\r\n}\r\nstatic int vhci_flush(struct hci_dev *hdev)\r\n{\r\nstruct vhci_data *data = hci_get_drvdata(hdev);\r\nskb_queue_purge(&data->readq);\r\nreturn 0;\r\n}\r\nstatic int vhci_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev* hdev = (struct hci_dev *) skb->dev;\r\nstruct vhci_data *data;\r\nif (!hdev) {\r\nBT_ERR("Frame for unknown HCI device (hdev=NULL)");\r\nreturn -ENODEV;\r\n}\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\ndata = hci_get_drvdata(hdev);\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&data->readq, skb);\r\nwake_up_interruptible(&data->read_wait);\r\nreturn 0;\r\n}\r\nstatic inline ssize_t vhci_get_user(struct vhci_data *data,\r\nconst char __user *buf, size_t count)\r\n{\r\nstruct sk_buff *skb;\r\nif (count > HCI_MAX_FRAME_SIZE)\r\nreturn -EINVAL;\r\nskb = bt_skb_alloc(count, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (copy_from_user(skb_put(skb, count), buf, count)) {\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nskb->dev = (void *) data->hdev;\r\nbt_cb(skb)->pkt_type = *((__u8 *) skb->data);\r\nskb_pull(skb, 1);\r\nhci_recv_frame(skb);\r\nreturn count;\r\n}\r\nstatic inline ssize_t vhci_put_user(struct vhci_data *data,\r\nstruct sk_buff *skb, char __user *buf, int count)\r\n{\r\nchar __user *ptr = buf;\r\nint len, total = 0;\r\nlen = min_t(unsigned int, skb->len, count);\r\nif (copy_to_user(ptr, skb->data, len))\r\nreturn -EFAULT;\r\ntotal += len;\r\ndata->hdev->stat.byte_tx += len;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\ndata->hdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\ndata->hdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\ndata->hdev->stat.sco_tx++;\r\nbreak;\r\n}\r\nreturn total;\r\n}\r\nstatic ssize_t vhci_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *pos)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\nstruct sk_buff *skb;\r\nssize_t ret = 0;\r\nwhile (count) {\r\nskb = skb_dequeue(&data->readq);\r\nif (skb) {\r\nret = vhci_put_user(data, skb, buf, count);\r\nif (ret < 0)\r\nskb_queue_head(&data->readq, skb);\r\nelse\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nret = wait_event_interruptible(data->read_wait,\r\n!skb_queue_empty(&data->readq));\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t vhci_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *pos)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\nreturn vhci_get_user(data, buf, count);\r\n}\r\nstatic unsigned int vhci_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\npoll_wait(file, &data->read_wait, wait);\r\nif (!skb_queue_empty(&data->readq))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn POLLOUT | POLLWRNORM;\r\n}\r\nstatic int vhci_open(struct inode *inode, struct file *file)\r\n{\r\nstruct vhci_data *data;\r\nstruct hci_dev *hdev;\r\ndata = kzalloc(sizeof(struct vhci_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&data->readq);\r\ninit_waitqueue_head(&data->read_wait);\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\ndata->hdev = hdev;\r\nhdev->bus = HCI_VIRTUAL;\r\nhci_set_drvdata(hdev, data);\r\nif (amp)\r\nhdev->dev_type = HCI_AMP;\r\nhdev->open = vhci_open_dev;\r\nhdev->close = vhci_close_dev;\r\nhdev->flush = vhci_flush;\r\nhdev->send = vhci_send_frame;\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\nkfree(data);\r\nhci_free_dev(hdev);\r\nreturn -EBUSY;\r\n}\r\nfile->private_data = data;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\n}\r\nstatic int vhci_release(struct inode *inode, struct file *file)\r\n{\r\nstruct vhci_data *data = file->private_data;\r\nstruct hci_dev *hdev = data->hdev;\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nfile->private_data = NULL;\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init vhci_init(void)\r\n{\r\nBT_INFO("Virtual HCI driver ver %s", VERSION);\r\nreturn misc_register(&vhci_miscdev);\r\n}\r\nstatic void __exit vhci_exit(void)\r\n{\r\nmisc_deregister(&vhci_miscdev);\r\n}
