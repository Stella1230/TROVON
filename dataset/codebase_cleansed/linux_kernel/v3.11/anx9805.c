static int\r\nanx9805_train(struct nouveau_i2c_port *port, int link_nr, int link_bw, bool enh)\r\n{\r\nstruct anx9805_i2c_port *chan = (void *)port;\r\nstruct nouveau_i2c_port *mast = (void *)nv_object(chan)->parent;\r\nu8 tmp, i;\r\nnv_wri2cr(mast, chan->addr, 0xa0, link_bw);\r\nnv_wri2cr(mast, chan->addr, 0xa1, link_nr | (enh ? 0x80 : 0x00));\r\nnv_wri2cr(mast, chan->addr, 0xa2, 0x01);\r\nnv_wri2cr(mast, chan->addr, 0xa8, 0x01);\r\ni = 0;\r\nwhile ((tmp = nv_rdi2cr(mast, chan->addr, 0xa8)) & 0x01) {\r\nmdelay(5);\r\nif (i++ == 100) {\r\nnv_error(port, "link training timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nif (tmp & 0x70) {\r\nnv_error(port, "link training failed: 0x%02x\n", tmp);\r\nreturn -EIO;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nanx9805_aux(struct nouveau_i2c_port *port, u8 type, u32 addr, u8 *data, u8 size)\r\n{\r\nstruct anx9805_i2c_port *chan = (void *)port;\r\nstruct nouveau_i2c_port *mast = (void *)nv_object(chan)->parent;\r\nint i, ret = -ETIMEDOUT;\r\nu8 tmp;\r\ntmp = nv_rdi2cr(mast, chan->ctrl, 0x07) & ~0x04;\r\nnv_wri2cr(mast, chan->ctrl, 0x07, tmp | 0x04);\r\nnv_wri2cr(mast, chan->ctrl, 0x07, tmp);\r\nnv_wri2cr(mast, chan->ctrl, 0xf7, 0x01);\r\nnv_wri2cr(mast, chan->addr, 0xe4, 0x80);\r\nfor (i = 0; !(type & 1) && i < size; i++)\r\nnv_wri2cr(mast, chan->addr, 0xf0 + i, data[i]);\r\nnv_wri2cr(mast, chan->addr, 0xe5, ((size - 1) << 4) | type);\r\nnv_wri2cr(mast, chan->addr, 0xe6, (addr & 0x000ff) >> 0);\r\nnv_wri2cr(mast, chan->addr, 0xe7, (addr & 0x0ff00) >> 8);\r\nnv_wri2cr(mast, chan->addr, 0xe8, (addr & 0xf0000) >> 16);\r\nnv_wri2cr(mast, chan->addr, 0xe9, 0x01);\r\ni = 0;\r\nwhile ((tmp = nv_rdi2cr(mast, chan->addr, 0xe9)) & 0x01) {\r\nmdelay(5);\r\nif (i++ == 32)\r\ngoto done;\r\n}\r\nif ((tmp = nv_rdi2cr(mast, chan->ctrl, 0xf7)) & 0x01) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\nfor (i = 0; (type & 1) && i < size; i++)\r\ndata[i] = nv_rdi2cr(mast, chan->addr, 0xf0 + i);\r\nret = 0;\r\ndone:\r\nnv_wri2cr(mast, chan->ctrl, 0xf7, 0x01);\r\nreturn ret;\r\n}\r\nstatic int\r\nanx9805_aux_chan_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 index,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_i2c_port *mast = (void *)parent;\r\nstruct anx9805_i2c_port *chan;\r\nint ret;\r\nret = nouveau_i2c_port_create(parent, engine, oclass, index,\r\n&nouveau_i2c_aux_algo, &chan);\r\n*pobject = nv_object(chan);\r\nif (ret)\r\nreturn ret;\r\nswitch ((oclass->handle & 0xff00) >> 8) {\r\ncase 0x0d:\r\nchan->addr = 0x38;\r\nchan->ctrl = 0x39;\r\nbreak;\r\ncase 0x0e:\r\nchan->addr = 0x3c;\r\nchan->ctrl = 0x3b;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif (mast->adapter.algo == &i2c_bit_algo) {\r\nstruct i2c_algo_bit_data *algo = mast->adapter.algo_data;\r\nalgo->udelay = max(algo->udelay, 40);\r\n}\r\nchan->base.func = &anx9805_aux_func;\r\nreturn 0;\r\n}\r\nstatic int\r\nanx9805_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct anx9805_i2c_port *port = adap->algo_data;\r\nstruct nouveau_i2c_port *mast = (void *)nv_object(port)->parent;\r\nstruct i2c_msg *msg = msgs;\r\nint ret = -ETIMEDOUT;\r\nint i, j, cnt = num;\r\nu8 seg = 0x00, off = 0x00, tmp;\r\ntmp = nv_rdi2cr(mast, port->ctrl, 0x07) & ~0x10;\r\nnv_wri2cr(mast, port->ctrl, 0x07, tmp | 0x10);\r\nnv_wri2cr(mast, port->ctrl, 0x07, tmp);\r\nnv_wri2cr(mast, port->addr, 0x43, 0x05);\r\nmdelay(5);\r\nwhile (cnt--) {\r\nif ( (msg->flags & I2C_M_RD) && msg->addr == 0x50) {\r\nnv_wri2cr(mast, port->addr, 0x40, msg->addr << 1);\r\nnv_wri2cr(mast, port->addr, 0x41, seg);\r\nnv_wri2cr(mast, port->addr, 0x42, off);\r\nnv_wri2cr(mast, port->addr, 0x44, msg->len);\r\nnv_wri2cr(mast, port->addr, 0x45, 0x00);\r\nnv_wri2cr(mast, port->addr, 0x43, 0x01);\r\nfor (i = 0; i < msg->len; i++) {\r\nj = 0;\r\nwhile (nv_rdi2cr(mast, port->addr, 0x46) & 0x10) {\r\nmdelay(5);\r\nif (j++ == 32)\r\ngoto done;\r\n}\r\nmsg->buf[i] = nv_rdi2cr(mast, port->addr, 0x47);\r\n}\r\n} else\r\nif (!(msg->flags & I2C_M_RD)) {\r\nif (msg->addr == 0x50 && msg->len == 0x01) {\r\noff = msg->buf[0];\r\n} else\r\nif (msg->addr == 0x30 && msg->len == 0x01) {\r\nseg = msg->buf[0];\r\n} else\r\ngoto done;\r\n} else {\r\ngoto done;\r\n}\r\nmsg++;\r\n}\r\nret = num;\r\ndone:\r\nnv_wri2cr(mast, port->addr, 0x43, 0x00);\r\nreturn ret;\r\n}\r\nstatic u32\r\nanx9805_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int\r\nanx9805_ddc_port_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 index,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_i2c_port *mast = (void *)parent;\r\nstruct anx9805_i2c_port *port;\r\nint ret;\r\nret = nouveau_i2c_port_create(parent, engine, oclass, index,\r\n&anx9805_i2c_algo, &port);\r\n*pobject = nv_object(port);\r\nif (ret)\r\nreturn ret;\r\nswitch ((oclass->handle & 0xff00) >> 8) {\r\ncase 0x0d:\r\nport->addr = 0x3d;\r\nport->ctrl = 0x39;\r\nbreak;\r\ncase 0x0e:\r\nport->addr = 0x3f;\r\nport->ctrl = 0x3b;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif (mast->adapter.algo == &i2c_bit_algo) {\r\nstruct i2c_algo_bit_data *algo = mast->adapter.algo_data;\r\nalgo->udelay = max(algo->udelay, 40);\r\n}\r\nport->base.func = &anx9805_i2c_func;\r\nreturn 0;\r\n}
