static int tpkbd_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nstruct usbhid_device *uhdev;\r\nuhdev = (struct usbhid_device *) hdev->driver_data;\r\nif (uhdev->ifnum == 1 && usage->hid == (HID_UP_BUTTON | 0x0010)) {\r\nmap_key_clear(KEY_MICMUTE);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpkbd_features_set(struct hid_device *hdev)\r\n{\r\nstruct hid_report *report;\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreport = hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[4];\r\nreport->field[0]->value[0] = data_pointer->press_to_select ? 0x01 : 0x02;\r\nreport->field[0]->value[0] |= data_pointer->dragging ? 0x04 : 0x08;\r\nreport->field[0]->value[0] |= data_pointer->release_to_select ? 0x10 : 0x20;\r\nreport->field[0]->value[0] |= data_pointer->select_right ? 0x80 : 0x40;\r\nreport->field[1]->value[0] = 0x03;\r\nreport->field[2]->value[0] = data_pointer->sensitivity;\r\nreport->field[3]->value[0] = data_pointer->press_speed;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\nreturn 0;\r\n}\r\nstatic ssize_t pointer_press_to_select_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->press_to_select);\r\n}\r\nstatic ssize_t pointer_press_to_select_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->press_to_select = value;\r\ntpkbd_features_set(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t pointer_dragging_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->dragging);\r\n}\r\nstatic ssize_t pointer_dragging_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->dragging = value;\r\ntpkbd_features_set(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t pointer_release_to_select_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->release_to_select);\r\n}\r\nstatic ssize_t pointer_release_to_select_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->release_to_select = value;\r\ntpkbd_features_set(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t pointer_select_right_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->select_right);\r\n}\r\nstatic ssize_t pointer_select_right_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->select_right = value;\r\ntpkbd_features_set(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t pointer_sensitivity_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\ndata_pointer->sensitivity);\r\n}\r\nstatic ssize_t pointer_sensitivity_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\r\nreturn -EINVAL;\r\ndata_pointer->sensitivity = value;\r\ntpkbd_features_set(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t pointer_press_speed_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\ndata_pointer->press_speed);\r\n}\r\nstatic ssize_t pointer_press_speed_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\r\nreturn -EINVAL;\r\ndata_pointer->press_speed = value;\r\ntpkbd_features_set(hdev);\r\nreturn count;\r\n}\r\nstatic enum led_brightness tpkbd_led_brightness_get(\r\nstruct led_classdev *led_cdev)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nint led_nr = 0;\r\nif (led_cdev == &data_pointer->led_micmute)\r\nled_nr = 1;\r\nreturn data_pointer->led_state & (1 << led_nr)\r\n? LED_FULL\r\n: LED_OFF;\r\n}\r\nstatic void tpkbd_led_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nstruct hid_report *report;\r\nint led_nr = 0;\r\nif (led_cdev == &data_pointer->led_micmute)\r\nled_nr = 1;\r\nif (value == LED_OFF)\r\ndata_pointer->led_state &= ~(1 << led_nr);\r\nelse\r\ndata_pointer->led_state |= 1 << led_nr;\r\nreport = hdev->report_enum[HID_OUTPUT_REPORT].report_id_hash[3];\r\nreport->field[0]->value[0] = (data_pointer->led_state >> 0) & 1;\r\nreport->field[0]->value[1] = (data_pointer->led_state >> 1) & 1;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic int tpkbd_probe_tp(struct hid_device *hdev)\r\n{\r\nstruct device *dev = &hdev->dev;\r\nstruct tpkbd_data_pointer *data_pointer;\r\nsize_t name_sz = strlen(dev_name(dev)) + 16;\r\nchar *name_mute, *name_micmute;\r\nint ret;\r\nif (sysfs_create_group(&hdev->dev.kobj,\r\n&tpkbd_attr_group_pointer)) {\r\nhid_warn(hdev, "Could not create sysfs group\n");\r\n}\r\ndata_pointer = kzalloc(sizeof(struct tpkbd_data_pointer), GFP_KERNEL);\r\nif (data_pointer == NULL) {\r\nhid_err(hdev, "Could not allocate memory for driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata_pointer->sensitivity = 0xa0;\r\ndata_pointer->press_speed = 0x38;\r\nname_mute = kzalloc(name_sz, GFP_KERNEL);\r\nif (name_mute == NULL) {\r\nhid_err(hdev, "Could not allocate memory for led data\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsnprintf(name_mute, name_sz, "%s:amber:mute", dev_name(dev));\r\nname_micmute = kzalloc(name_sz, GFP_KERNEL);\r\nif (name_micmute == NULL) {\r\nhid_err(hdev, "Could not allocate memory for led data\n");\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nsnprintf(name_micmute, name_sz, "%s:amber:micmute", dev_name(dev));\r\nhid_set_drvdata(hdev, data_pointer);\r\ndata_pointer->led_mute.name = name_mute;\r\ndata_pointer->led_mute.brightness_get = tpkbd_led_brightness_get;\r\ndata_pointer->led_mute.brightness_set = tpkbd_led_brightness_set;\r\ndata_pointer->led_mute.dev = dev;\r\nled_classdev_register(dev, &data_pointer->led_mute);\r\ndata_pointer->led_micmute.name = name_micmute;\r\ndata_pointer->led_micmute.brightness_get = tpkbd_led_brightness_get;\r\ndata_pointer->led_micmute.brightness_set = tpkbd_led_brightness_set;\r\ndata_pointer->led_micmute.dev = dev;\r\nled_classdev_register(dev, &data_pointer->led_micmute);\r\ntpkbd_features_set(hdev);\r\nreturn 0;\r\nerr2:\r\nkfree(name_mute);\r\nerr:\r\nkfree(data_pointer);\r\nreturn ret;\r\n}\r\nstatic int tpkbd_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct usbhid_device *uhdev;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "hid_parse failed\n");\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hid_hw_start failed\n");\r\ngoto err_free;\r\n}\r\nuhdev = (struct usbhid_device *) hdev->driver_data;\r\nif (uhdev->ifnum == 1)\r\nreturn tpkbd_probe_tp(hdev);\r\nreturn 0;\r\nerr_free:\r\nreturn ret;\r\n}\r\nstatic void tpkbd_remove_tp(struct hid_device *hdev)\r\n{\r\nstruct tpkbd_data_pointer *data_pointer = hid_get_drvdata(hdev);\r\nsysfs_remove_group(&hdev->dev.kobj,\r\n&tpkbd_attr_group_pointer);\r\nled_classdev_unregister(&data_pointer->led_micmute);\r\nled_classdev_unregister(&data_pointer->led_mute);\r\nhid_set_drvdata(hdev, NULL);\r\nkfree(data_pointer->led_micmute.name);\r\nkfree(data_pointer->led_mute.name);\r\nkfree(data_pointer);\r\n}\r\nstatic void tpkbd_remove(struct hid_device *hdev)\r\n{\r\nstruct usbhid_device *uhdev;\r\nuhdev = (struct usbhid_device *) hdev->driver_data;\r\nif (uhdev->ifnum == 1)\r\ntpkbd_remove_tp(hdev);\r\nhid_hw_stop(hdev);\r\n}
