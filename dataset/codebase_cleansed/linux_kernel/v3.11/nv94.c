static void\r\nauxch_fini(struct nouveau_i2c *aux, int ch)\r\n{\r\nnv_mask(aux, 0x00e4e4 + (ch * 0x50), 0x00310000, 0x00000000);\r\n}\r\nstatic int\r\nauxch_init(struct nouveau_i2c *aux, int ch)\r\n{\r\nconst u32 unksel = 1;\r\nconst u32 ureq = unksel ? 0x00100000 : 0x00200000;\r\nconst u32 urep = unksel ? 0x01000000 : 0x02000000;\r\nu32 ctrl, timeout;\r\ntimeout = 1000;\r\ndo {\r\nctrl = nv_rd32(aux, 0x00e4e4 + (ch * 0x50));\r\nudelay(1);\r\nif (!timeout--) {\r\nAUX_ERR("begin idle timeout 0x%08x\n", ctrl);\r\nreturn -EBUSY;\r\n}\r\n} while (ctrl & 0x03010000);\r\nnv_mask(aux, 0x00e4e4 + (ch * 0x50), 0x00300000, ureq);\r\ntimeout = 1000;\r\ndo {\r\nctrl = nv_rd32(aux, 0x00e4e4 + (ch * 0x50));\r\nudelay(1);\r\nif (!timeout--) {\r\nAUX_ERR("magic wait 0x%08x\n", ctrl);\r\nauxch_fini(aux, ch);\r\nreturn -EBUSY;\r\n}\r\n} while ((ctrl & 0x03000000) != urep);\r\nreturn 0;\r\n}\r\nint\r\nnv94_aux(struct nouveau_i2c_port *base, u8 type, u32 addr, u8 *data, u8 size)\r\n{\r\nstruct nouveau_i2c *aux = nouveau_i2c(base);\r\nstruct nv50_i2c_port *port = (void *)base;\r\nu32 ctrl, stat, timeout, retries;\r\nu32 xbuf[4] = {};\r\nint ch = port->addr;\r\nint ret, i;\r\nAUX_DBG("%d: 0x%08x %d\n", type, addr, size);\r\nret = auxch_init(aux, ch);\r\nif (ret)\r\ngoto out;\r\nstat = nv_rd32(aux, 0x00e4e8 + (ch * 0x50));\r\nif (!(stat & 0x10000000)) {\r\nAUX_DBG("sink not detected\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (!(type & 1)) {\r\nmemcpy(xbuf, data, size);\r\nfor (i = 0; i < 16; i += 4) {\r\nAUX_DBG("wr 0x%08x\n", xbuf[i / 4]);\r\nnv_wr32(aux, 0x00e4c0 + (ch * 0x50) + i, xbuf[i / 4]);\r\n}\r\n}\r\nctrl = nv_rd32(aux, 0x00e4e4 + (ch * 0x50));\r\nctrl &= ~0x0001f0ff;\r\nctrl |= type << 12;\r\nctrl |= size - 1;\r\nnv_wr32(aux, 0x00e4e0 + (ch * 0x50), addr);\r\nret = -EREMOTEIO;\r\nfor (retries = 0; retries < 32; retries++) {\r\nnv_wr32(aux, 0x00e4e4 + (ch * 0x50), 0x80000000 | ctrl);\r\nnv_wr32(aux, 0x00e4e4 + (ch * 0x50), 0x00000000 | ctrl);\r\nif (retries)\r\nudelay(400);\r\nnv_wr32(aux, 0x00e4e4 + (ch * 0x50), 0x00010000 | ctrl);\r\ntimeout = 1000;\r\ndo {\r\nctrl = nv_rd32(aux, 0x00e4e4 + (ch * 0x50));\r\nudelay(1);\r\nif (!timeout--) {\r\nAUX_ERR("tx req timeout 0x%08x\n", ctrl);\r\ngoto out;\r\n}\r\n} while (ctrl & 0x00010000);\r\nstat = nv_mask(aux, 0x00e4e8 + (ch * 0x50), 0, 0);\r\nif (!(stat & 0x000f0f00)) {\r\nret = 0;\r\nbreak;\r\n}\r\nAUX_DBG("%02d 0x%08x 0x%08x\n", retries, ctrl, stat);\r\n}\r\nif (type & 1) {\r\nfor (i = 0; i < 16; i += 4) {\r\nxbuf[i / 4] = nv_rd32(aux, 0x00e4d0 + (ch * 0x50) + i);\r\nAUX_DBG("rd 0x%08x\n", xbuf[i / 4]);\r\n}\r\nmemcpy(data, xbuf, size);\r\n}\r\nout:\r\nauxch_fini(aux, ch);\r\nreturn ret;\r\n}\r\nvoid\r\nnv94_i2c_acquire(struct nouveau_i2c_port *base)\r\n{\r\nstruct nv50_i2c_priv *priv = (void *)nv_object(base)->engine;\r\nstruct nv50_i2c_port *port = (void *)base;\r\nif (port->ctrl) {\r\nnv_mask(priv, port->ctrl + 0x0c, 0x00000001, 0x00000000);\r\nnv_mask(priv, port->ctrl + 0x00, 0x0000f003, port->data);\r\n}\r\n}\r\nvoid\r\nnv94_i2c_release(struct nouveau_i2c_port *base)\r\n{\r\n}\r\nstatic int\r\nnv94_i2c_port_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 index,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct dcb_i2c_entry *info = data;\r\nstruct nv50_i2c_port *port;\r\nint ret;\r\nret = nouveau_i2c_port_create(parent, engine, oclass, index,\r\n&nouveau_i2c_bit_algo, &port);\r\n*pobject = nv_object(port);\r\nif (ret)\r\nreturn ret;\r\nif (info->drive >= nv50_i2c_addr_nr)\r\nreturn -EINVAL;\r\nport->base.func = &nv94_i2c_func;\r\nport->state = 7;\r\nport->addr = nv50_i2c_addr[info->drive];\r\nif (info->share != DCB_I2C_UNUSED) {\r\nport->ctrl = 0x00e500 + (info->share * 0x50);\r\nport->data = 0x0000e001;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv94_aux_port_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 index,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct dcb_i2c_entry *info = data;\r\nstruct nv50_i2c_port *port;\r\nint ret;\r\nret = nouveau_i2c_port_create(parent, engine, oclass, index,\r\n&nouveau_i2c_aux_algo, &port);\r\n*pobject = nv_object(port);\r\nif (ret)\r\nreturn ret;\r\nport->base.func = &nv94_aux_func;\r\nport->addr = info->drive;\r\nif (info->share != DCB_I2C_UNUSED) {\r\nport->ctrl = 0x00e500 + (info->drive * 0x50);\r\nport->data = 0x00002002;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv94_i2c_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nv50_i2c_priv *priv;\r\nint ret;\r\nret = nouveau_i2c_create(parent, engine, oclass, nv94_i2c_sclass, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
