static int is_shadow(struct dm_transaction_manager *tm, dm_block_t b)\r\n{\r\nint r = 0;\r\nunsigned bucket = dm_hash_block(b, DM_HASH_MASK);\r\nstruct shadow_info *si;\r\nspin_lock(&tm->lock);\r\nhlist_for_each_entry(si, tm->buckets + bucket, hlist)\r\nif (si->where == b) {\r\nr = 1;\r\nbreak;\r\n}\r\nspin_unlock(&tm->lock);\r\nreturn r;\r\n}\r\nstatic void insert_shadow(struct dm_transaction_manager *tm, dm_block_t b)\r\n{\r\nunsigned bucket;\r\nstruct shadow_info *si;\r\nsi = kmalloc(sizeof(*si), GFP_NOIO);\r\nif (si) {\r\nsi->where = b;\r\nbucket = dm_hash_block(b, DM_HASH_MASK);\r\nspin_lock(&tm->lock);\r\nhlist_add_head(&si->hlist, tm->buckets + bucket);\r\nspin_unlock(&tm->lock);\r\n}\r\n}\r\nstatic void wipe_shadow_table(struct dm_transaction_manager *tm)\r\n{\r\nstruct shadow_info *si;\r\nstruct hlist_node *tmp;\r\nstruct hlist_head *bucket;\r\nint i;\r\nspin_lock(&tm->lock);\r\nfor (i = 0; i < DM_HASH_SIZE; i++) {\r\nbucket = tm->buckets + i;\r\nhlist_for_each_entry_safe(si, tmp, bucket, hlist)\r\nkfree(si);\r\nINIT_HLIST_HEAD(bucket);\r\n}\r\nspin_unlock(&tm->lock);\r\n}\r\nstatic struct dm_transaction_manager *dm_tm_create(struct dm_block_manager *bm,\r\nstruct dm_space_map *sm)\r\n{\r\nint i;\r\nstruct dm_transaction_manager *tm;\r\ntm = kmalloc(sizeof(*tm), GFP_KERNEL);\r\nif (!tm)\r\nreturn ERR_PTR(-ENOMEM);\r\ntm->is_clone = 0;\r\ntm->real = NULL;\r\ntm->bm = bm;\r\ntm->sm = sm;\r\nspin_lock_init(&tm->lock);\r\nfor (i = 0; i < DM_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(tm->buckets + i);\r\nreturn tm;\r\n}\r\nstruct dm_transaction_manager *dm_tm_create_non_blocking_clone(struct dm_transaction_manager *real)\r\n{\r\nstruct dm_transaction_manager *tm;\r\ntm = kmalloc(sizeof(*tm), GFP_KERNEL);\r\nif (tm) {\r\ntm->is_clone = 1;\r\ntm->real = real;\r\n}\r\nreturn tm;\r\n}\r\nvoid dm_tm_destroy(struct dm_transaction_manager *tm)\r\n{\r\nif (!tm->is_clone)\r\nwipe_shadow_table(tm);\r\nkfree(tm);\r\n}\r\nint dm_tm_pre_commit(struct dm_transaction_manager *tm)\r\n{\r\nint r;\r\nif (tm->is_clone)\r\nreturn -EWOULDBLOCK;\r\nr = dm_sm_commit(tm->sm);\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint dm_tm_commit(struct dm_transaction_manager *tm, struct dm_block *root)\r\n{\r\nif (tm->is_clone)\r\nreturn -EWOULDBLOCK;\r\nwipe_shadow_table(tm);\r\nreturn dm_bm_flush_and_unlock(tm->bm, root);\r\n}\r\nint dm_tm_new_block(struct dm_transaction_manager *tm,\r\nstruct dm_block_validator *v,\r\nstruct dm_block **result)\r\n{\r\nint r;\r\ndm_block_t new_block;\r\nif (tm->is_clone)\r\nreturn -EWOULDBLOCK;\r\nr = dm_sm_new_block(tm->sm, &new_block);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_bm_write_lock_zero(tm->bm, new_block, v, result);\r\nif (r < 0) {\r\ndm_sm_dec_block(tm->sm, new_block);\r\nreturn r;\r\n}\r\ninsert_shadow(tm, new_block);\r\nreturn 0;\r\n}\r\nstatic int __shadow_block(struct dm_transaction_manager *tm, dm_block_t orig,\r\nstruct dm_block_validator *v,\r\nstruct dm_block **result)\r\n{\r\nint r;\r\ndm_block_t new;\r\nstruct dm_block *orig_block;\r\nr = dm_sm_new_block(tm->sm, &new);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_sm_dec_block(tm->sm, orig);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_bm_read_lock(tm->bm, orig, v, &orig_block);\r\nif (r < 0)\r\nreturn r;\r\nr = dm_bm_write_lock_zero(tm->bm, new, v, result);\r\nif (r) {\r\ndm_bm_unlock(orig_block);\r\nreturn r;\r\n}\r\nmemcpy(dm_block_data(*result), dm_block_data(orig_block),\r\ndm_bm_block_size(tm->bm));\r\ndm_bm_unlock(orig_block);\r\nreturn r;\r\n}\r\nint dm_tm_shadow_block(struct dm_transaction_manager *tm, dm_block_t orig,\r\nstruct dm_block_validator *v, struct dm_block **result,\r\nint *inc_children)\r\n{\r\nint r;\r\nif (tm->is_clone)\r\nreturn -EWOULDBLOCK;\r\nr = dm_sm_count_is_more_than_one(tm->sm, orig, inc_children);\r\nif (r < 0)\r\nreturn r;\r\nif (is_shadow(tm, orig) && !*inc_children)\r\nreturn dm_bm_write_lock(tm->bm, orig, v, result);\r\nr = __shadow_block(tm, orig, v, result);\r\nif (r < 0)\r\nreturn r;\r\ninsert_shadow(tm, dm_block_location(*result));\r\nreturn r;\r\n}\r\nint dm_tm_read_lock(struct dm_transaction_manager *tm, dm_block_t b,\r\nstruct dm_block_validator *v,\r\nstruct dm_block **blk)\r\n{\r\nif (tm->is_clone)\r\nreturn dm_bm_read_try_lock(tm->real->bm, b, v, blk);\r\nreturn dm_bm_read_lock(tm->bm, b, v, blk);\r\n}\r\nint dm_tm_unlock(struct dm_transaction_manager *tm, struct dm_block *b)\r\n{\r\nreturn dm_bm_unlock(b);\r\n}\r\nvoid dm_tm_inc(struct dm_transaction_manager *tm, dm_block_t b)\r\n{\r\nBUG_ON(tm->is_clone);\r\ndm_sm_inc_block(tm->sm, b);\r\n}\r\nvoid dm_tm_dec(struct dm_transaction_manager *tm, dm_block_t b)\r\n{\r\nBUG_ON(tm->is_clone);\r\ndm_sm_dec_block(tm->sm, b);\r\n}\r\nint dm_tm_ref(struct dm_transaction_manager *tm, dm_block_t b,\r\nuint32_t *result)\r\n{\r\nif (tm->is_clone)\r\nreturn -EWOULDBLOCK;\r\nreturn dm_sm_get_count(tm->sm, b, result);\r\n}\r\nstruct dm_block_manager *dm_tm_get_bm(struct dm_transaction_manager *tm)\r\n{\r\nreturn tm->bm;\r\n}\r\nstatic int dm_tm_create_internal(struct dm_block_manager *bm,\r\ndm_block_t sb_location,\r\nstruct dm_transaction_manager **tm,\r\nstruct dm_space_map **sm,\r\nint create,\r\nvoid *sm_root, size_t sm_len)\r\n{\r\nint r;\r\n*sm = dm_sm_metadata_init();\r\nif (IS_ERR(*sm))\r\nreturn PTR_ERR(*sm);\r\n*tm = dm_tm_create(bm, *sm);\r\nif (IS_ERR(*tm)) {\r\ndm_sm_destroy(*sm);\r\nreturn PTR_ERR(*tm);\r\n}\r\nif (create) {\r\nr = dm_sm_metadata_create(*sm, *tm, dm_bm_nr_blocks(bm),\r\nsb_location);\r\nif (r) {\r\nDMERR("couldn't create metadata space map");\r\ngoto bad;\r\n}\r\n} else {\r\nr = dm_sm_metadata_open(*sm, *tm, sm_root, sm_len);\r\nif (r) {\r\nDMERR("couldn't open metadata space map");\r\ngoto bad;\r\n}\r\n}\r\nreturn 0;\r\nbad:\r\ndm_tm_destroy(*tm);\r\ndm_sm_destroy(*sm);\r\nreturn r;\r\n}\r\nint dm_tm_create_with_sm(struct dm_block_manager *bm, dm_block_t sb_location,\r\nstruct dm_transaction_manager **tm,\r\nstruct dm_space_map **sm)\r\n{\r\nreturn dm_tm_create_internal(bm, sb_location, tm, sm, 1, NULL, 0);\r\n}\r\nint dm_tm_open_with_sm(struct dm_block_manager *bm, dm_block_t sb_location,\r\nvoid *sm_root, size_t root_len,\r\nstruct dm_transaction_manager **tm,\r\nstruct dm_space_map **sm)\r\n{\r\nreturn dm_tm_create_internal(bm, sb_location, tm, sm, 0, sm_root, root_len);\r\n}
