static bool\r\nconntrack_addrcmp(const union nf_inet_addr *kaddr,\r\nconst union nf_inet_addr *uaddr,\r\nconst union nf_inet_addr *umask, unsigned int l3proto)\r\n{\r\nif (l3proto == NFPROTO_IPV4)\r\nreturn ((kaddr->ip ^ uaddr->ip) & umask->ip) == 0;\r\nelse if (l3proto == NFPROTO_IPV6)\r\nreturn ipv6_masked_addr_cmp(&kaddr->in6, &umask->in6,\r\n&uaddr->in6) == 0;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline bool\r\nconntrack_mt_origsrc(const struct nf_conn *ct,\r\nconst struct xt_conntrack_mtinfo2 *info,\r\nu_int8_t family)\r\n{\r\nreturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3,\r\n&info->origsrc_addr, &info->origsrc_mask, family);\r\n}\r\nstatic inline bool\r\nconntrack_mt_origdst(const struct nf_conn *ct,\r\nconst struct xt_conntrack_mtinfo2 *info,\r\nu_int8_t family)\r\n{\r\nreturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3,\r\n&info->origdst_addr, &info->origdst_mask, family);\r\n}\r\nstatic inline bool\r\nconntrack_mt_replsrc(const struct nf_conn *ct,\r\nconst struct xt_conntrack_mtinfo2 *info,\r\nu_int8_t family)\r\n{\r\nreturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3,\r\n&info->replsrc_addr, &info->replsrc_mask, family);\r\n}\r\nstatic inline bool\r\nconntrack_mt_repldst(const struct nf_conn *ct,\r\nconst struct xt_conntrack_mtinfo2 *info,\r\nu_int8_t family)\r\n{\r\nreturn conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3,\r\n&info->repldst_addr, &info->repldst_mask, family);\r\n}\r\nstatic inline bool\r\nct_proto_port_check(const struct xt_conntrack_mtinfo2 *info,\r\nconst struct nf_conn *ct)\r\n{\r\nconst struct nf_conntrack_tuple *tuple;\r\ntuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nif ((info->match_flags & XT_CONNTRACK_PROTO) &&\r\n(nf_ct_protonum(ct) == info->l4proto) ^\r\n!(info->invert_flags & XT_CONNTRACK_PROTO))\r\nreturn false;\r\nif ((info->match_flags & XT_CONNTRACK_ORIGSRC_PORT) &&\r\n(tuple->src.u.all == info->origsrc_port) ^\r\n!(info->invert_flags & XT_CONNTRACK_ORIGSRC_PORT))\r\nreturn false;\r\nif ((info->match_flags & XT_CONNTRACK_ORIGDST_PORT) &&\r\n(tuple->dst.u.all == info->origdst_port) ^\r\n!(info->invert_flags & XT_CONNTRACK_ORIGDST_PORT))\r\nreturn false;\r\ntuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\r\nif ((info->match_flags & XT_CONNTRACK_REPLSRC_PORT) &&\r\n(tuple->src.u.all == info->replsrc_port) ^\r\n!(info->invert_flags & XT_CONNTRACK_REPLSRC_PORT))\r\nreturn false;\r\nif ((info->match_flags & XT_CONNTRACK_REPLDST_PORT) &&\r\n(tuple->dst.u.all == info->repldst_port) ^\r\n!(info->invert_flags & XT_CONNTRACK_REPLDST_PORT))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline bool\r\nport_match(u16 min, u16 max, u16 port, bool invert)\r\n{\r\nreturn (port >= min && port <= max) ^ invert;\r\n}\r\nstatic inline bool\r\nct_proto_port_check_v3(const struct xt_conntrack_mtinfo3 *info,\r\nconst struct nf_conn *ct)\r\n{\r\nconst struct nf_conntrack_tuple *tuple;\r\ntuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nif ((info->match_flags & XT_CONNTRACK_PROTO) &&\r\n(nf_ct_protonum(ct) == info->l4proto) ^\r\n!(info->invert_flags & XT_CONNTRACK_PROTO))\r\nreturn false;\r\nif ((info->match_flags & XT_CONNTRACK_ORIGSRC_PORT) &&\r\n!port_match(info->origsrc_port, info->origsrc_port_high,\r\nntohs(tuple->src.u.all),\r\ninfo->invert_flags & XT_CONNTRACK_ORIGSRC_PORT))\r\nreturn false;\r\nif ((info->match_flags & XT_CONNTRACK_ORIGDST_PORT) &&\r\n!port_match(info->origdst_port, info->origdst_port_high,\r\nntohs(tuple->dst.u.all),\r\ninfo->invert_flags & XT_CONNTRACK_ORIGDST_PORT))\r\nreturn false;\r\ntuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\r\nif ((info->match_flags & XT_CONNTRACK_REPLSRC_PORT) &&\r\n!port_match(info->replsrc_port, info->replsrc_port_high,\r\nntohs(tuple->src.u.all),\r\ninfo->invert_flags & XT_CONNTRACK_REPLSRC_PORT))\r\nreturn false;\r\nif ((info->match_flags & XT_CONNTRACK_REPLDST_PORT) &&\r\n!port_match(info->repldst_port, info->repldst_port_high,\r\nntohs(tuple->dst.u.all),\r\ninfo->invert_flags & XT_CONNTRACK_REPLDST_PORT))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nconntrack_mt(const struct sk_buff *skb, struct xt_action_param *par,\r\nu16 state_mask, u16 status_mask)\r\n{\r\nconst struct xt_conntrack_mtinfo2 *info = par->matchinfo;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct;\r\nunsigned int statebit;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct) {\r\nif (nf_ct_is_untracked(ct))\r\nstatebit = XT_CONNTRACK_STATE_UNTRACKED;\r\nelse\r\nstatebit = XT_CONNTRACK_STATE_BIT(ctinfo);\r\n} else\r\nstatebit = XT_CONNTRACK_STATE_INVALID;\r\nif (info->match_flags & XT_CONNTRACK_STATE) {\r\nif (ct != NULL) {\r\nif (test_bit(IPS_SRC_NAT_BIT, &ct->status))\r\nstatebit |= XT_CONNTRACK_STATE_SNAT;\r\nif (test_bit(IPS_DST_NAT_BIT, &ct->status))\r\nstatebit |= XT_CONNTRACK_STATE_DNAT;\r\n}\r\nif (!!(state_mask & statebit) ^\r\n!(info->invert_flags & XT_CONNTRACK_STATE))\r\nreturn false;\r\n}\r\nif (ct == NULL)\r\nreturn info->match_flags & XT_CONNTRACK_STATE;\r\nif ((info->match_flags & XT_CONNTRACK_DIRECTION) &&\r\n(CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) ^\r\n!(info->invert_flags & XT_CONNTRACK_DIRECTION))\r\nreturn false;\r\nif (info->match_flags & XT_CONNTRACK_ORIGSRC)\r\nif (conntrack_mt_origsrc(ct, info, par->family) ^\r\n!(info->invert_flags & XT_CONNTRACK_ORIGSRC))\r\nreturn false;\r\nif (info->match_flags & XT_CONNTRACK_ORIGDST)\r\nif (conntrack_mt_origdst(ct, info, par->family) ^\r\n!(info->invert_flags & XT_CONNTRACK_ORIGDST))\r\nreturn false;\r\nif (info->match_flags & XT_CONNTRACK_REPLSRC)\r\nif (conntrack_mt_replsrc(ct, info, par->family) ^\r\n!(info->invert_flags & XT_CONNTRACK_REPLSRC))\r\nreturn false;\r\nif (info->match_flags & XT_CONNTRACK_REPLDST)\r\nif (conntrack_mt_repldst(ct, info, par->family) ^\r\n!(info->invert_flags & XT_CONNTRACK_REPLDST))\r\nreturn false;\r\nif (par->match->revision != 3) {\r\nif (!ct_proto_port_check(info, ct))\r\nreturn false;\r\n} else {\r\nif (!ct_proto_port_check_v3(par->matchinfo, ct))\r\nreturn false;\r\n}\r\nif ((info->match_flags & XT_CONNTRACK_STATUS) &&\r\n(!!(status_mask & ct->status) ^\r\n!(info->invert_flags & XT_CONNTRACK_STATUS)))\r\nreturn false;\r\nif (info->match_flags & XT_CONNTRACK_EXPIRES) {\r\nunsigned long expires = 0;\r\nif (timer_pending(&ct->timeout))\r\nexpires = (ct->timeout.expires - jiffies) / HZ;\r\nif ((expires >= info->expires_min &&\r\nexpires <= info->expires_max) ^\r\n!(info->invert_flags & XT_CONNTRACK_EXPIRES))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nconntrack_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_conntrack_mtinfo1 *info = par->matchinfo;\r\nreturn conntrack_mt(skb, par, info->state_mask, info->status_mask);\r\n}\r\nstatic bool\r\nconntrack_mt_v2(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_conntrack_mtinfo2 *info = par->matchinfo;\r\nreturn conntrack_mt(skb, par, info->state_mask, info->status_mask);\r\n}\r\nstatic bool\r\nconntrack_mt_v3(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_conntrack_mtinfo3 *info = par->matchinfo;\r\nreturn conntrack_mt(skb, par, info->state_mask, info->status_mask);\r\n}\r\nstatic int conntrack_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nint ret;\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0)\r\npr_info("cannot load conntrack support for proto=%u\n",\r\npar->family);\r\nreturn ret;\r\n}\r\nstatic void conntrack_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nstatic int __init conntrack_mt_init(void)\r\n{\r\nreturn xt_register_matches(conntrack_mt_reg,\r\nARRAY_SIZE(conntrack_mt_reg));\r\n}\r\nstatic void __exit conntrack_mt_exit(void)\r\n{\r\nxt_unregister_matches(conntrack_mt_reg, ARRAY_SIZE(conntrack_mt_reg));\r\n}
