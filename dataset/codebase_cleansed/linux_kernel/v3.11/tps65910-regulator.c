static int tps65910_get_ctrl_register(int id)\r\n{\r\nswitch (id) {\r\ncase TPS65910_REG_VRTC:\r\nreturn TPS65910_VRTC;\r\ncase TPS65910_REG_VIO:\r\nreturn TPS65910_VIO;\r\ncase TPS65910_REG_VDD1:\r\nreturn TPS65910_VDD1;\r\ncase TPS65910_REG_VDD2:\r\nreturn TPS65910_VDD2;\r\ncase TPS65910_REG_VDD3:\r\nreturn TPS65910_VDD3;\r\ncase TPS65910_REG_VDIG1:\r\nreturn TPS65910_VDIG1;\r\ncase TPS65910_REG_VDIG2:\r\nreturn TPS65910_VDIG2;\r\ncase TPS65910_REG_VPLL:\r\nreturn TPS65910_VPLL;\r\ncase TPS65910_REG_VDAC:\r\nreturn TPS65910_VDAC;\r\ncase TPS65910_REG_VAUX1:\r\nreturn TPS65910_VAUX1;\r\ncase TPS65910_REG_VAUX2:\r\nreturn TPS65910_VAUX2;\r\ncase TPS65910_REG_VAUX33:\r\nreturn TPS65910_VAUX33;\r\ncase TPS65910_REG_VMMC:\r\nreturn TPS65910_VMMC;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int tps65911_get_ctrl_register(int id)\r\n{\r\nswitch (id) {\r\ncase TPS65910_REG_VRTC:\r\nreturn TPS65910_VRTC;\r\ncase TPS65910_REG_VIO:\r\nreturn TPS65910_VIO;\r\ncase TPS65910_REG_VDD1:\r\nreturn TPS65910_VDD1;\r\ncase TPS65910_REG_VDD2:\r\nreturn TPS65910_VDD2;\r\ncase TPS65911_REG_VDDCTRL:\r\nreturn TPS65911_VDDCTRL;\r\ncase TPS65911_REG_LDO1:\r\nreturn TPS65911_LDO1;\r\ncase TPS65911_REG_LDO2:\r\nreturn TPS65911_LDO2;\r\ncase TPS65911_REG_LDO3:\r\nreturn TPS65911_LDO3;\r\ncase TPS65911_REG_LDO4:\r\nreturn TPS65911_LDO4;\r\ncase TPS65911_REG_LDO5:\r\nreturn TPS65911_LDO5;\r\ncase TPS65911_REG_LDO6:\r\nreturn TPS65911_LDO6;\r\ncase TPS65911_REG_LDO7:\r\nreturn TPS65911_LDO7;\r\ncase TPS65911_REG_LDO8:\r\nreturn TPS65911_LDO8;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int tps65910_set_mode(struct regulator_dev *dev, unsigned int mode)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nstruct tps65910 *mfd = pmic->mfd;\r\nint reg, value, id = rdev_get_id(dev);\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nreturn tps65910_reg_update_bits(pmic->mfd, reg,\r\nLDO_ST_MODE_BIT | LDO_ST_ON_BIT,\r\nLDO_ST_ON_BIT);\r\ncase REGULATOR_MODE_IDLE:\r\nvalue = LDO_ST_ON_BIT | LDO_ST_MODE_BIT;\r\nreturn tps65910_reg_set_bits(mfd, reg, value);\r\ncase REGULATOR_MODE_STANDBY:\r\nreturn tps65910_reg_clear_bits(mfd, reg, LDO_ST_ON_BIT);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int tps65910_get_mode(struct regulator_dev *dev)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint ret, reg, value, id = rdev_get_id(dev);\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nret = tps65910_reg_read(pmic->mfd, reg, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(value & LDO_ST_ON_BIT))\r\nreturn REGULATOR_MODE_STANDBY;\r\nelse if (value & LDO_ST_MODE_BIT)\r\nreturn REGULATOR_MODE_IDLE;\r\nelse\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int tps65910_get_voltage_dcdc_sel(struct regulator_dev *dev)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint ret, id = rdev_get_id(dev);\r\nint opvsel = 0, srvsel = 0, vselmax = 0, mult = 0, sr = 0;\r\nswitch (id) {\r\ncase TPS65910_REG_VDD1:\r\nret = tps65910_reg_read(pmic->mfd, TPS65910_VDD1_OP, &opvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tps65910_reg_read(pmic->mfd, TPS65910_VDD1, &mult);\r\nif (ret < 0)\r\nreturn ret;\r\nmult = (mult & VDD1_VGAIN_SEL_MASK) >> VDD1_VGAIN_SEL_SHIFT;\r\nret = tps65910_reg_read(pmic->mfd, TPS65910_VDD1_SR, &srvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nsr = opvsel & VDD1_OP_CMD_MASK;\r\nopvsel &= VDD1_OP_SEL_MASK;\r\nsrvsel &= VDD1_SR_SEL_MASK;\r\nvselmax = 75;\r\nbreak;\r\ncase TPS65910_REG_VDD2:\r\nret = tps65910_reg_read(pmic->mfd, TPS65910_VDD2_OP, &opvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tps65910_reg_read(pmic->mfd, TPS65910_VDD2, &mult);\r\nif (ret < 0)\r\nreturn ret;\r\nmult = (mult & VDD2_VGAIN_SEL_MASK) >> VDD2_VGAIN_SEL_SHIFT;\r\nret = tps65910_reg_read(pmic->mfd, TPS65910_VDD2_SR, &srvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nsr = opvsel & VDD2_OP_CMD_MASK;\r\nopvsel &= VDD2_OP_SEL_MASK;\r\nsrvsel &= VDD2_SR_SEL_MASK;\r\nvselmax = 75;\r\nbreak;\r\ncase TPS65911_REG_VDDCTRL:\r\nret = tps65910_reg_read(pmic->mfd, TPS65911_VDDCTRL_OP,\r\n&opvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tps65910_reg_read(pmic->mfd, TPS65911_VDDCTRL_SR,\r\n&srvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nsr = opvsel & VDDCTRL_OP_CMD_MASK;\r\nopvsel &= VDDCTRL_OP_SEL_MASK;\r\nsrvsel &= VDDCTRL_SR_SEL_MASK;\r\nvselmax = 64;\r\nbreak;\r\n}\r\nif (!mult)\r\nmult=1;\r\nif (sr) {\r\nif (srvsel < 3)\r\nsrvsel = 3;\r\nif (srvsel > vselmax)\r\nsrvsel = vselmax;\r\nreturn srvsel - 3;\r\n} else {\r\nif (opvsel < 3)\r\nopvsel = 3;\r\nif (opvsel > vselmax)\r\nopvsel = vselmax;\r\nreturn opvsel - 3;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tps65910_get_voltage_sel(struct regulator_dev *dev)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint ret, reg, value, id = rdev_get_id(dev);\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nret = tps65910_reg_read(pmic->mfd, reg, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (id) {\r\ncase TPS65910_REG_VIO:\r\ncase TPS65910_REG_VDIG1:\r\ncase TPS65910_REG_VDIG2:\r\ncase TPS65910_REG_VPLL:\r\ncase TPS65910_REG_VDAC:\r\ncase TPS65910_REG_VAUX1:\r\ncase TPS65910_REG_VAUX2:\r\ncase TPS65910_REG_VAUX33:\r\ncase TPS65910_REG_VMMC:\r\nvalue &= LDO_SEL_MASK;\r\nvalue >>= LDO_SEL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn value;\r\n}\r\nstatic int tps65910_get_voltage_vdd3(struct regulator_dev *dev)\r\n{\r\nreturn dev->desc->volt_table[0];\r\n}\r\nstatic int tps65911_get_voltage_sel(struct regulator_dev *dev)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint ret, id = rdev_get_id(dev);\r\nunsigned int value, reg;\r\nreg = pmic->get_ctrl_reg(id);\r\nret = tps65910_reg_read(pmic->mfd, reg, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (id) {\r\ncase TPS65911_REG_LDO1:\r\ncase TPS65911_REG_LDO2:\r\ncase TPS65911_REG_LDO4:\r\nvalue &= LDO1_SEL_MASK;\r\nvalue >>= LDO_SEL_SHIFT;\r\nbreak;\r\ncase TPS65911_REG_LDO3:\r\ncase TPS65911_REG_LDO5:\r\ncase TPS65911_REG_LDO6:\r\ncase TPS65911_REG_LDO7:\r\ncase TPS65911_REG_LDO8:\r\nvalue &= LDO3_SEL_MASK;\r\nvalue >>= LDO_SEL_SHIFT;\r\nbreak;\r\ncase TPS65910_REG_VIO:\r\nvalue &= LDO_SEL_MASK;\r\nvalue >>= LDO_SEL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn value;\r\n}\r\nstatic int tps65910_set_voltage_dcdc_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint id = rdev_get_id(dev), vsel;\r\nint dcdc_mult = 0;\r\nswitch (id) {\r\ncase TPS65910_REG_VDD1:\r\ndcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;\r\nif (dcdc_mult == 1)\r\ndcdc_mult--;\r\nvsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;\r\ntps65910_reg_update_bits(pmic->mfd, TPS65910_VDD1,\r\nVDD1_VGAIN_SEL_MASK,\r\ndcdc_mult << VDD1_VGAIN_SEL_SHIFT);\r\ntps65910_reg_write(pmic->mfd, TPS65910_VDD1_OP, vsel);\r\nbreak;\r\ncase TPS65910_REG_VDD2:\r\ndcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;\r\nif (dcdc_mult == 1)\r\ndcdc_mult--;\r\nvsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;\r\ntps65910_reg_update_bits(pmic->mfd, TPS65910_VDD2,\r\nVDD1_VGAIN_SEL_MASK,\r\ndcdc_mult << VDD2_VGAIN_SEL_SHIFT);\r\ntps65910_reg_write(pmic->mfd, TPS65910_VDD2_OP, vsel);\r\nbreak;\r\ncase TPS65911_REG_VDDCTRL:\r\nvsel = selector + 3;\r\ntps65910_reg_write(pmic->mfd, TPS65911_VDDCTRL_OP, vsel);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65910_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint reg, id = rdev_get_id(dev);\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nswitch (id) {\r\ncase TPS65910_REG_VIO:\r\ncase TPS65910_REG_VDIG1:\r\ncase TPS65910_REG_VDIG2:\r\ncase TPS65910_REG_VPLL:\r\ncase TPS65910_REG_VDAC:\r\ncase TPS65910_REG_VAUX1:\r\ncase TPS65910_REG_VAUX2:\r\ncase TPS65910_REG_VAUX33:\r\ncase TPS65910_REG_VMMC:\r\nreturn tps65910_reg_update_bits(pmic->mfd, reg, LDO_SEL_MASK,\r\nselector << LDO_SEL_SHIFT);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tps65911_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint reg, id = rdev_get_id(dev);\r\nreg = pmic->get_ctrl_reg(id);\r\nif (reg < 0)\r\nreturn reg;\r\nswitch (id) {\r\ncase TPS65911_REG_LDO1:\r\ncase TPS65911_REG_LDO2:\r\ncase TPS65911_REG_LDO4:\r\nreturn tps65910_reg_update_bits(pmic->mfd, reg, LDO1_SEL_MASK,\r\nselector << LDO_SEL_SHIFT);\r\ncase TPS65911_REG_LDO3:\r\ncase TPS65911_REG_LDO5:\r\ncase TPS65911_REG_LDO6:\r\ncase TPS65911_REG_LDO7:\r\ncase TPS65911_REG_LDO8:\r\nreturn tps65910_reg_update_bits(pmic->mfd, reg, LDO3_SEL_MASK,\r\nselector << LDO_SEL_SHIFT);\r\ncase TPS65910_REG_VIO:\r\nreturn tps65910_reg_update_bits(pmic->mfd, reg, LDO_SEL_MASK,\r\nselector << LDO_SEL_SHIFT);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tps65910_list_voltage_dcdc(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nint volt, mult = 1, id = rdev_get_id(dev);\r\nswitch (id) {\r\ncase TPS65910_REG_VDD1:\r\ncase TPS65910_REG_VDD2:\r\nmult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;\r\nvolt = VDD1_2_MIN_VOLT +\r\n(selector % VDD1_2_NUM_VOLT_FINE) * VDD1_2_OFFSET;\r\nbreak;\r\ncase TPS65911_REG_VDDCTRL:\r\nvolt = VDDCTRL_MIN_VOLT + (selector * VDDCTRL_OFFSET);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn volt * 100 * mult;\r\n}\r\nstatic int tps65911_list_voltage(struct regulator_dev *dev, unsigned selector)\r\n{\r\nstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\r\nint step_mv = 0, id = rdev_get_id(dev);\r\nswitch(id) {\r\ncase TPS65911_REG_LDO1:\r\ncase TPS65911_REG_LDO2:\r\ncase TPS65911_REG_LDO4:\r\nif (selector < 5)\r\nselector = 0;\r\nelse\r\nselector -= 4;\r\nstep_mv = 50;\r\nbreak;\r\ncase TPS65911_REG_LDO3:\r\ncase TPS65911_REG_LDO5:\r\ncase TPS65911_REG_LDO6:\r\ncase TPS65911_REG_LDO7:\r\ncase TPS65911_REG_LDO8:\r\nif (selector < 3)\r\nselector = 0;\r\nelse\r\nselector -= 2;\r\nstep_mv = 100;\r\nbreak;\r\ncase TPS65910_REG_VIO:\r\nreturn pmic->info[id]->voltage_table[selector];\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn (LDO_MIN_VOLT + selector * step_mv) * 1000;\r\n}\r\nstatic int tps65910_set_ext_sleep_config(struct tps65910_reg *pmic,\r\nint id, int ext_sleep_config)\r\n{\r\nstruct tps65910 *mfd = pmic->mfd;\r\nu8 regoffs = (pmic->ext_sleep_control[id] >> 8) & 0xFF;\r\nu8 bit_pos = (1 << pmic->ext_sleep_control[id] & 0xFF);\r\nint ret;\r\nif (ext_sleep_config & EXT_SLEEP_CONTROL) {\r\nint en_count;\r\nen_count = ((ext_sleep_config &\r\nTPS65910_SLEEP_CONTROL_EXT_INPUT_EN1) != 0);\r\nen_count += ((ext_sleep_config &\r\nTPS65910_SLEEP_CONTROL_EXT_INPUT_EN2) != 0);\r\nen_count += ((ext_sleep_config &\r\nTPS65910_SLEEP_CONTROL_EXT_INPUT_EN3) != 0);\r\nen_count += ((ext_sleep_config &\r\nTPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP) != 0);\r\nif (en_count > 1) {\r\ndev_err(mfd->dev,\r\n"External sleep control flag is not proper\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\npmic->board_ext_control[id] = ext_sleep_config;\r\nif (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1)\r\nret = tps65910_reg_set_bits(mfd,\r\nTPS65910_EN1_LDO_ASS + regoffs, bit_pos);\r\nelse\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_EN1_LDO_ASS + regoffs, bit_pos);\r\nif (ret < 0) {\r\ndev_err(mfd->dev,\r\n"Error in configuring external control EN1\n");\r\nreturn ret;\r\n}\r\nif (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2)\r\nret = tps65910_reg_set_bits(mfd,\r\nTPS65910_EN2_LDO_ASS + regoffs, bit_pos);\r\nelse\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_EN2_LDO_ASS + regoffs, bit_pos);\r\nif (ret < 0) {\r\ndev_err(mfd->dev,\r\n"Error in configuring external control EN2\n");\r\nreturn ret;\r\n}\r\nif ((tps65910_chip_id(mfd) == TPS65910) &&\r\n(id >= TPS65910_REG_VDIG1)) {\r\nif (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3)\r\nret = tps65910_reg_set_bits(mfd,\r\nTPS65910_EN3_LDO_ASS + regoffs, bit_pos);\r\nelse\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_EN3_LDO_ASS + regoffs, bit_pos);\r\nif (ret < 0) {\r\ndev_err(mfd->dev,\r\n"Error in configuring external control EN3\n");\r\nreturn ret;\r\n}\r\n}\r\nif (!(ext_sleep_config & EXT_SLEEP_CONTROL)) {\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);\r\nif (!ret)\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);\r\nif (ret < 0)\r\ndev_err(mfd->dev,\r\n"Error in configuring SLEEP register\n");\r\nreturn ret;\r\n}\r\nif ((id == TPS65910_REG_VDD1) ||\r\n(id == TPS65910_REG_VDD2) ||\r\n((id == TPS65911_REG_VDDCTRL) &&\r\n(tps65910_chip_id(mfd) == TPS65911))) {\r\nint op_reg_add = pmic->get_ctrl_reg(id) + 1;\r\nint sr_reg_add = pmic->get_ctrl_reg(id) + 2;\r\nint opvsel, srvsel;\r\nret = tps65910_reg_read(pmic->mfd, op_reg_add, &opvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tps65910_reg_read(pmic->mfd, sr_reg_add, &srvsel);\r\nif (ret < 0)\r\nreturn ret;\r\nif (opvsel & VDD1_OP_CMD_MASK) {\r\nu8 reg_val = srvsel & VDD1_OP_SEL_MASK;\r\nret = tps65910_reg_write(pmic->mfd, op_reg_add,\r\nreg_val);\r\nif (ret < 0) {\r\ndev_err(mfd->dev,\r\n"Error in configuring op register\n");\r\nreturn ret;\r\n}\r\n}\r\nret = tps65910_reg_write(pmic->mfd, sr_reg_add, 0);\r\nif (ret < 0) {\r\ndev_err(mfd->dev, "Error in settting sr register\n");\r\nreturn ret;\r\n}\r\n}\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);\r\nif (!ret) {\r\nif (ext_sleep_config & TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)\r\nret = tps65910_reg_set_bits(mfd,\r\nTPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);\r\nelse\r\nret = tps65910_reg_clear_bits(mfd,\r\nTPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);\r\n}\r\nif (ret < 0)\r\ndev_err(mfd->dev,\r\n"Error in configuring SLEEP register\n");\r\nreturn ret;\r\n}\r\nstatic struct tps65910_board *tps65910_parse_dt_reg_data(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **tps65910_reg_matches)\r\n{\r\nstruct tps65910_board *pmic_plat_data;\r\nstruct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *np, *regulators;\r\nstruct of_regulator_match *matches;\r\nunsigned int prop;\r\nint idx = 0, ret, count;\r\npmic_plat_data = devm_kzalloc(&pdev->dev, sizeof(*pmic_plat_data),\r\nGFP_KERNEL);\r\nif (!pmic_plat_data) {\r\ndev_err(&pdev->dev, "Failure to alloc pdata for regulators.\n");\r\nreturn NULL;\r\n}\r\nnp = of_node_get(pdev->dev.parent->of_node);\r\nregulators = of_find_node_by_name(np, "regulators");\r\nif (!regulators) {\r\ndev_err(&pdev->dev, "regulator node not found\n");\r\nreturn NULL;\r\n}\r\nswitch (tps65910_chip_id(tps65910)) {\r\ncase TPS65910:\r\ncount = ARRAY_SIZE(tps65910_matches);\r\nmatches = tps65910_matches;\r\nbreak;\r\ncase TPS65911:\r\ncount = ARRAY_SIZE(tps65911_matches);\r\nmatches = tps65911_matches;\r\nbreak;\r\ndefault:\r\nof_node_put(regulators);\r\ndev_err(&pdev->dev, "Invalid tps chip version\n");\r\nreturn NULL;\r\n}\r\nret = of_regulator_match(&pdev->dev, regulators, matches, count);\r\nof_node_put(regulators);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error parsing regulator init data: %d\n",\r\nret);\r\nreturn NULL;\r\n}\r\n*tps65910_reg_matches = matches;\r\nfor (idx = 0; idx < count; idx++) {\r\nif (!matches[idx].init_data || !matches[idx].of_node)\r\ncontinue;\r\npmic_plat_data->tps65910_pmic_init_data[idx] =\r\nmatches[idx].init_data;\r\nret = of_property_read_u32(matches[idx].of_node,\r\n"ti,regulator-ext-sleep-control", &prop);\r\nif (!ret)\r\npmic_plat_data->regulator_ext_sleep_control[idx] = prop;\r\n}\r\nreturn pmic_plat_data;\r\n}\r\nstatic inline struct tps65910_board *tps65910_parse_dt_reg_data(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **tps65910_reg_matches)\r\n{\r\n*tps65910_reg_matches = NULL;\r\nreturn NULL;\r\n}\r\nstatic int tps65910_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);\r\nstruct regulator_config config = { };\r\nstruct tps_info *info;\r\nstruct regulator_init_data *reg_data;\r\nstruct regulator_dev *rdev;\r\nstruct tps65910_reg *pmic;\r\nstruct tps65910_board *pmic_plat_data;\r\nstruct of_regulator_match *tps65910_reg_matches = NULL;\r\nint i, err;\r\npmic_plat_data = dev_get_platdata(tps65910->dev);\r\nif (!pmic_plat_data && tps65910->dev->of_node)\r\npmic_plat_data = tps65910_parse_dt_reg_data(pdev,\r\n&tps65910_reg_matches);\r\nif (!pmic_plat_data) {\r\ndev_err(&pdev->dev, "Platform data not found\n");\r\nreturn -EINVAL;\r\n}\r\npmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\r\nif (!pmic) {\r\ndev_err(&pdev->dev, "Memory allocation failed for pmic\n");\r\nreturn -ENOMEM;\r\n}\r\npmic->mfd = tps65910;\r\nplatform_set_drvdata(pdev, pmic);\r\ntps65910_reg_set_bits(pmic->mfd, TPS65910_DEVCTRL,\r\nDEVCTRL_SR_CTL_I2C_SEL_MASK);\r\nswitch(tps65910_chip_id(tps65910)) {\r\ncase TPS65910:\r\npmic->get_ctrl_reg = &tps65910_get_ctrl_register;\r\npmic->num_regulators = ARRAY_SIZE(tps65910_regs);\r\npmic->ext_sleep_control = tps65910_ext_sleep_control;\r\ninfo = tps65910_regs;\r\nbreak;\r\ncase TPS65911:\r\npmic->get_ctrl_reg = &tps65911_get_ctrl_register;\r\npmic->num_regulators = ARRAY_SIZE(tps65911_regs);\r\npmic->ext_sleep_control = tps65911_ext_sleep_control;\r\ninfo = tps65911_regs;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Invalid tps chip version\n");\r\nreturn -ENODEV;\r\n}\r\npmic->desc = devm_kzalloc(&pdev->dev, pmic->num_regulators *\r\nsizeof(struct regulator_desc), GFP_KERNEL);\r\nif (!pmic->desc) {\r\ndev_err(&pdev->dev, "Memory alloc fails for desc\n");\r\nreturn -ENOMEM;\r\n}\r\npmic->info = devm_kzalloc(&pdev->dev, pmic->num_regulators *\r\nsizeof(struct tps_info *), GFP_KERNEL);\r\nif (!pmic->info) {\r\ndev_err(&pdev->dev, "Memory alloc fails for info\n");\r\nreturn -ENOMEM;\r\n}\r\npmic->rdev = devm_kzalloc(&pdev->dev, pmic->num_regulators *\r\nsizeof(struct regulator_dev *), GFP_KERNEL);\r\nif (!pmic->rdev) {\r\ndev_err(&pdev->dev, "Memory alloc fails for rdev\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < pmic->num_regulators && i < TPS65910_NUM_REGS;\r\ni++, info++) {\r\nreg_data = pmic_plat_data->tps65910_pmic_init_data[i];\r\nif (!reg_data)\r\ncontinue;\r\npmic->info[i] = info;\r\npmic->desc[i].name = info->name;\r\npmic->desc[i].supply_name = info->vin_name;\r\npmic->desc[i].id = i;\r\npmic->desc[i].n_voltages = info->n_voltages;\r\npmic->desc[i].enable_time = info->enable_time_us;\r\nif (i == TPS65910_REG_VDD1 || i == TPS65910_REG_VDD2) {\r\npmic->desc[i].ops = &tps65910_ops_dcdc;\r\npmic->desc[i].n_voltages = VDD1_2_NUM_VOLT_FINE *\r\nVDD1_2_NUM_VOLT_COARSE;\r\npmic->desc[i].ramp_delay = 12500;\r\n} else if (i == TPS65910_REG_VDD3) {\r\nif (tps65910_chip_id(tps65910) == TPS65910) {\r\npmic->desc[i].ops = &tps65910_ops_vdd3;\r\npmic->desc[i].volt_table = info->voltage_table;\r\n} else {\r\npmic->desc[i].ops = &tps65910_ops_dcdc;\r\npmic->desc[i].ramp_delay = 5000;\r\n}\r\n} else {\r\nif (tps65910_chip_id(tps65910) == TPS65910) {\r\npmic->desc[i].ops = &tps65910_ops;\r\npmic->desc[i].volt_table = info->voltage_table;\r\n} else {\r\npmic->desc[i].ops = &tps65911_ops;\r\n}\r\n}\r\nerr = tps65910_set_ext_sleep_config(pmic, i,\r\npmic_plat_data->regulator_ext_sleep_control[i]);\r\nif (err < 0)\r\ndev_warn(tps65910->dev,\r\n"Failed to initialise ext control config\n");\r\npmic->desc[i].type = REGULATOR_VOLTAGE;\r\npmic->desc[i].owner = THIS_MODULE;\r\npmic->desc[i].enable_reg = pmic->get_ctrl_reg(i);\r\npmic->desc[i].enable_mask = TPS65910_SUPPLY_STATE_ENABLED;\r\nconfig.dev = tps65910->dev;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = pmic;\r\nconfig.regmap = tps65910->regmap;\r\nif (tps65910_reg_matches)\r\nconfig.of_node = tps65910_reg_matches[i].of_node;\r\nrdev = regulator_register(&pmic->desc[i], &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(tps65910->dev,\r\n"failed to register %s regulator\n",\r\npdev->name);\r\nerr = PTR_ERR(rdev);\r\ngoto err_unregister_regulator;\r\n}\r\npmic->rdev[i] = rdev;\r\n}\r\nreturn 0;\r\nerr_unregister_regulator:\r\nwhile (--i >= 0)\r\nregulator_unregister(pmic->rdev[i]);\r\nreturn err;\r\n}\r\nstatic int tps65910_remove(struct platform_device *pdev)\r\n{\r\nstruct tps65910_reg *pmic = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < pmic->num_regulators; i++)\r\nregulator_unregister(pmic->rdev[i]);\r\nreturn 0;\r\n}\r\nstatic void tps65910_shutdown(struct platform_device *pdev)\r\n{\r\nstruct tps65910_reg *pmic = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < pmic->num_regulators; i++) {\r\nint err;\r\nif (!pmic->rdev[i])\r\ncontinue;\r\nerr = tps65910_set_ext_sleep_config(pmic, i, 0);\r\nif (err < 0)\r\ndev_err(&pdev->dev,\r\n"Error in clearing external control\n");\r\n}\r\n}\r\nstatic int __init tps65910_init(void)\r\n{\r\nreturn platform_driver_register(&tps65910_driver);\r\n}\r\nstatic void __exit tps65910_cleanup(void)\r\n{\r\nplatform_driver_unregister(&tps65910_driver);\r\n}
