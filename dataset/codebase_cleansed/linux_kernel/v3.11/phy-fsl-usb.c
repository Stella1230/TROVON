static u32 _fsl_readl_be(const unsigned __iomem *p)\r\n{\r\nreturn in_be32(p);\r\n}\r\nstatic u32 _fsl_readl_le(const unsigned __iomem *p)\r\n{\r\nreturn in_le32(p);\r\n}\r\nstatic void _fsl_writel_be(u32 v, unsigned __iomem *p)\r\n{\r\nout_be32(p, v);\r\n}\r\nstatic void _fsl_writel_le(u32 v, unsigned __iomem *p)\r\n{\r\nout_le32(p, v);\r\n}\r\nu8 view_ulpi(u8 addr)\r\n{\r\nu32 temp;\r\ntemp = 0x40000000 | (addr << 16);\r\nfsl_writel(temp, &usb_dr_regs->ulpiview);\r\nudelay(1000);\r\nwhile (temp & 0x40)\r\ntemp = fsl_readl(&usb_dr_regs->ulpiview);\r\nreturn (le32_to_cpu(temp) & 0x0000ff00) >> 8;\r\n}\r\nint write_ulpi(u8 addr, u8 data)\r\n{\r\nu32 temp;\r\ntemp = 0x60000000 | (addr << 16) | data;\r\nfsl_writel(temp, &usb_dr_regs->ulpiview);\r\nreturn 0;\r\n}\r\nvoid fsl_otg_chrg_vbus(int on)\r\n{\r\nu32 tmp;\r\ntmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\r\nif (on)\r\ntmp = (tmp & ~OTGSC_CTRL_VBUS_DISCHARGE) |\r\nOTGSC_CTRL_VBUS_CHARGE;\r\nelse\r\ntmp &= ~OTGSC_CTRL_VBUS_CHARGE;\r\nfsl_writel(tmp, &usb_dr_regs->otgsc);\r\n}\r\nvoid fsl_otg_dischrg_vbus(int on)\r\n{\r\nu32 tmp;\r\ntmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\r\nif (on)\r\ntmp = (tmp & ~OTGSC_CTRL_VBUS_CHARGE) |\r\nOTGSC_CTRL_VBUS_DISCHARGE;\r\nelse\r\ntmp &= ~OTGSC_CTRL_VBUS_DISCHARGE;\r\nfsl_writel(tmp, &usb_dr_regs->otgsc);\r\n}\r\nvoid fsl_otg_drv_vbus(int on)\r\n{\r\nu32 tmp;\r\nif (on) {\r\ntmp = fsl_readl(&usb_dr_regs->portsc) & ~PORTSC_W1C_BITS;\r\nfsl_writel(tmp | PORTSC_PORT_POWER, &usb_dr_regs->portsc);\r\n} else {\r\ntmp = fsl_readl(&usb_dr_regs->portsc) &\r\n~PORTSC_W1C_BITS & ~PORTSC_PORT_POWER;\r\nfsl_writel(tmp, &usb_dr_regs->portsc);\r\n}\r\n}\r\nvoid fsl_otg_loc_conn(int on)\r\n{\r\nu32 tmp;\r\ntmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\r\nif (on)\r\ntmp |= OTGSC_CTRL_DATA_PULSING;\r\nelse\r\ntmp &= ~OTGSC_CTRL_DATA_PULSING;\r\nfsl_writel(tmp, &usb_dr_regs->otgsc);\r\n}\r\nvoid fsl_otg_loc_sof(int on)\r\n{\r\nu32 tmp;\r\ntmp = fsl_readl(&fsl_otg_dev->dr_mem_map->portsc) & ~PORTSC_W1C_BITS;\r\nif (on)\r\ntmp |= PORTSC_PORT_FORCE_RESUME;\r\nelse\r\ntmp |= PORTSC_PORT_SUSPEND;\r\nfsl_writel(tmp, &fsl_otg_dev->dr_mem_map->portsc);\r\n}\r\nvoid fsl_otg_start_pulse(void)\r\n{\r\nu32 tmp;\r\nsrp_wait_done = 0;\r\n#ifdef HA_DATA_PULSE\r\ntmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\r\ntmp |= OTGSC_HA_DATA_PULSE;\r\nfsl_writel(tmp, &usb_dr_regs->otgsc);\r\n#else\r\nfsl_otg_loc_conn(1);\r\n#endif\r\nfsl_otg_add_timer(b_data_pulse_tmr);\r\n}\r\nvoid b_data_pulse_end(unsigned long foo)\r\n{\r\n#ifdef HA_DATA_PULSE\r\n#else\r\nfsl_otg_loc_conn(0);\r\n#endif\r\nfsl_otg_pulse_vbus();\r\n}\r\nvoid fsl_otg_pulse_vbus(void)\r\n{\r\nsrp_wait_done = 0;\r\nfsl_otg_chrg_vbus(1);\r\nfsl_otg_add_timer(b_vbus_pulse_tmr);\r\n}\r\nvoid b_vbus_pulse_end(unsigned long foo)\r\n{\r\nfsl_otg_chrg_vbus(0);\r\nfsl_otg_dischrg_vbus(1);\r\nfsl_otg_add_timer(b_srp_wait_tmr);\r\n}\r\nvoid b_srp_end(unsigned long foo)\r\n{\r\nfsl_otg_dischrg_vbus(0);\r\nsrp_wait_done = 1;\r\nif ((fsl_otg_dev->phy.state == OTG_STATE_B_SRP_INIT) &&\r\nfsl_otg_dev->fsm.b_sess_vld)\r\nfsl_otg_dev->fsm.b_srp_done = 1;\r\n}\r\nvoid a_wait_enum(unsigned long foo)\r\n{\r\nVDBG("a_wait_enum timeout\n");\r\nif (!fsl_otg_dev->phy.otg->host->b_hnp_enable)\r\nfsl_otg_add_timer(a_wait_enum_tmr);\r\nelse\r\notg_statemachine(&fsl_otg_dev->fsm);\r\n}\r\nvoid set_tmout(unsigned long indicator)\r\n{\r\n*(int *)indicator = 1;\r\n}\r\nint fsl_otg_init_timers(struct otg_fsm *fsm)\r\n{\r\na_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,\r\n(unsigned long)&fsm->a_wait_vrise_tmout);\r\nif (!a_wait_vrise_tmr)\r\nreturn -ENOMEM;\r\na_wait_bcon_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_BCON,\r\n(unsigned long)&fsm->a_wait_bcon_tmout);\r\nif (!a_wait_bcon_tmr)\r\nreturn -ENOMEM;\r\na_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,\r\n(unsigned long)&fsm->a_aidl_bdis_tmout);\r\nif (!a_aidl_bdis_tmr)\r\nreturn -ENOMEM;\r\nb_ase0_brst_tmr = otg_timer_initializer(&set_tmout, TB_ASE0_BRST,\r\n(unsigned long)&fsm->b_ase0_brst_tmout);\r\nif (!b_ase0_brst_tmr)\r\nreturn -ENOMEM;\r\nb_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,\r\n(unsigned long)&fsm->b_se0_srp);\r\nif (!b_se0_srp_tmr)\r\nreturn -ENOMEM;\r\nb_srp_fail_tmr = otg_timer_initializer(&set_tmout, TB_SRP_FAIL,\r\n(unsigned long)&fsm->b_srp_done);\r\nif (!b_srp_fail_tmr)\r\nreturn -ENOMEM;\r\na_wait_enum_tmr = otg_timer_initializer(&a_wait_enum, 10,\r\n(unsigned long)&fsm);\r\nif (!a_wait_enum_tmr)\r\nreturn -ENOMEM;\r\nb_srp_wait_tmr = otg_timer_initializer(&b_srp_end, TB_SRP_WAIT, 0);\r\nif (!b_srp_wait_tmr)\r\nreturn -ENOMEM;\r\nb_data_pulse_tmr = otg_timer_initializer(&b_data_pulse_end,\r\nTB_DATA_PLS, 0);\r\nif (!b_data_pulse_tmr)\r\nreturn -ENOMEM;\r\nb_vbus_pulse_tmr = otg_timer_initializer(&b_vbus_pulse_end,\r\nTB_VBUS_PLS, 0);\r\nif (!b_vbus_pulse_tmr)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid fsl_otg_uninit_timers(void)\r\n{\r\nkfree(a_wait_vrise_tmr);\r\nkfree(a_wait_bcon_tmr);\r\nkfree(a_aidl_bdis_tmr);\r\nkfree(b_ase0_brst_tmr);\r\nkfree(b_se0_srp_tmr);\r\nkfree(b_srp_fail_tmr);\r\nkfree(a_wait_enum_tmr);\r\nkfree(b_srp_wait_tmr);\r\nkfree(b_data_pulse_tmr);\r\nkfree(b_vbus_pulse_tmr);\r\n}\r\nvoid fsl_otg_add_timer(void *gtimer)\r\n{\r\nstruct fsl_otg_timer *timer = gtimer;\r\nstruct fsl_otg_timer *tmp_timer;\r\nlist_for_each_entry(tmp_timer, &active_timers, list)\r\nif (tmp_timer == timer) {\r\ntimer->count = timer->expires;\r\nreturn;\r\n}\r\ntimer->count = timer->expires;\r\nlist_add_tail(&timer->list, &active_timers);\r\n}\r\nvoid fsl_otg_del_timer(void *gtimer)\r\n{\r\nstruct fsl_otg_timer *timer = gtimer;\r\nstruct fsl_otg_timer *tmp_timer, *del_tmp;\r\nlist_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)\r\nif (tmp_timer == timer)\r\nlist_del(&timer->list);\r\n}\r\nint fsl_otg_tick_timer(void)\r\n{\r\nstruct fsl_otg_timer *tmp_timer, *del_tmp;\r\nint expired = 0;\r\nlist_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {\r\ntmp_timer->count--;\r\nif (!tmp_timer->count) {\r\nlist_del(&tmp_timer->list);\r\ntmp_timer->function(tmp_timer->data);\r\nexpired = 1;\r\n}\r\n}\r\nreturn expired;\r\n}\r\nvoid otg_reset_controller(void)\r\n{\r\nu32 command;\r\ncommand = fsl_readl(&usb_dr_regs->usbcmd);\r\ncommand |= (1 << 1);\r\nfsl_writel(command, &usb_dr_regs->usbcmd);\r\nwhile (fsl_readl(&usb_dr_regs->usbcmd) & (1 << 1))\r\n;\r\n}\r\nint fsl_otg_start_host(struct otg_fsm *fsm, int on)\r\n{\r\nstruct usb_otg *otg = fsm->otg;\r\nstruct device *dev;\r\nstruct fsl_otg *otg_dev = container_of(otg->phy, struct fsl_otg, phy);\r\nu32 retval = 0;\r\nif (!otg->host)\r\nreturn -ENODEV;\r\ndev = otg->host->controller;\r\nfsm->a_vbus_vld =\r\n!!(fsl_readl(&usb_dr_regs->otgsc) & OTGSC_STS_A_VBUS_VALID);\r\nif (on) {\r\nif (otg_dev->host_working)\r\ngoto end;\r\nelse {\r\notg_reset_controller();\r\nVDBG("host on......\n");\r\nif (dev->driver->pm && dev->driver->pm->resume) {\r\nretval = dev->driver->pm->resume(dev);\r\nif (fsm->id) {\r\nfsl_otg_drv_vbus(1);\r\nwrite_ulpi(0x0c, 0x20);\r\n}\r\n}\r\notg_dev->host_working = 1;\r\n}\r\n} else {\r\nif (!otg_dev->host_working)\r\ngoto end;\r\nelse {\r\nVDBG("host off......\n");\r\nif (dev && dev->driver) {\r\nif (dev->driver->pm && dev->driver->pm->suspend)\r\nretval = dev->driver->pm->suspend(dev);\r\nif (fsm->id)\r\nfsl_otg_drv_vbus(0);\r\n}\r\notg_dev->host_working = 0;\r\n}\r\n}\r\nend:\r\nreturn retval;\r\n}\r\nint fsl_otg_start_gadget(struct otg_fsm *fsm, int on)\r\n{\r\nstruct usb_otg *otg = fsm->otg;\r\nstruct device *dev;\r\nif (!otg->gadget || !otg->gadget->dev.parent)\r\nreturn -ENODEV;\r\nVDBG("gadget %s\n", on ? "on" : "off");\r\ndev = otg->gadget->dev.parent;\r\nif (on) {\r\nif (dev->driver->resume)\r\ndev->driver->resume(dev);\r\n} else {\r\nif (dev->driver->suspend)\r\ndev->driver->suspend(dev, otg_suspend_state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nstruct fsl_otg *otg_dev;\r\nif (!otg)\r\nreturn -ENODEV;\r\notg_dev = container_of(otg->phy, struct fsl_otg, phy);\r\nif (otg_dev != fsl_otg_dev)\r\nreturn -ENODEV;\r\notg->host = host;\r\notg_dev->fsm.a_bus_drop = 0;\r\notg_dev->fsm.a_bus_req = 1;\r\nif (host) {\r\nVDBG("host off......\n");\r\notg->host->otg_port = fsl_otg_initdata.otg_port;\r\notg->host->is_b_host = otg_dev->fsm.id;\r\notg_dev->host_working = 1;\r\nschedule_delayed_work(&otg_dev->otg_event, 100);\r\nreturn 0;\r\n} else {\r\nif (!(fsl_readl(&otg_dev->dr_mem_map->otgsc) &\r\nOTGSC_STS_USB_ID)) {\r\nstruct otg_fsm *fsm = &otg_dev->fsm;\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nfsm->protocol = PROTO_UNDEF;\r\n}\r\n}\r\notg_dev->host_working = 0;\r\notg_statemachine(&otg_dev->fsm);\r\nreturn 0;\r\n}\r\nstatic int fsl_otg_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct fsl_otg *otg_dev;\r\nif (!otg)\r\nreturn -ENODEV;\r\notg_dev = container_of(otg->phy, struct fsl_otg, phy);\r\nVDBG("otg_dev 0x%x\n", (int)otg_dev);\r\nVDBG("fsl_otg_dev 0x%x\n", (int)fsl_otg_dev);\r\nif (otg_dev != fsl_otg_dev)\r\nreturn -ENODEV;\r\nif (!gadget) {\r\nif (!otg->default_a)\r\notg->gadget->ops->vbus_draw(otg->gadget, 0);\r\nusb_gadget_vbus_disconnect(otg->gadget);\r\notg->gadget = 0;\r\notg_dev->fsm.b_bus_req = 0;\r\notg_statemachine(&otg_dev->fsm);\r\nreturn 0;\r\n}\r\notg->gadget = gadget;\r\notg->gadget->is_a_peripheral = !otg_dev->fsm.id;\r\notg_dev->fsm.b_bus_req = 1;\r\nDBG("ID pin=%d\n", otg_dev->fsm.id);\r\nif (otg_dev->fsm.id == 1) {\r\nfsl_otg_start_host(&otg_dev->fsm, 0);\r\notg_drv_vbus(&otg_dev->fsm, 0);\r\nfsl_otg_start_gadget(&otg_dev->fsm, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_otg_set_power(struct usb_phy *phy, unsigned mA)\r\n{\r\nif (!fsl_otg_dev)\r\nreturn -ENODEV;\r\nif (phy->state == OTG_STATE_B_PERIPHERAL)\r\npr_info("FSL OTG: Draw %d mA\n", mA);\r\nreturn 0;\r\n}\r\nstatic void fsl_otg_event(struct work_struct *work)\r\n{\r\nstruct fsl_otg *og = container_of(work, struct fsl_otg, otg_event.work);\r\nstruct otg_fsm *fsm = &og->fsm;\r\nif (fsm->id) {\r\nfsl_otg_start_host(fsm, 0);\r\notg_drv_vbus(fsm, 0);\r\nfsl_otg_start_gadget(fsm, 1);\r\n}\r\n}\r\nstatic int fsl_otg_start_srp(struct usb_otg *otg)\r\n{\r\nstruct fsl_otg *otg_dev;\r\nif (!otg || otg->phy->state != OTG_STATE_B_IDLE)\r\nreturn -ENODEV;\r\notg_dev = container_of(otg->phy, struct fsl_otg, phy);\r\nif (otg_dev != fsl_otg_dev)\r\nreturn -ENODEV;\r\notg_dev->fsm.b_bus_req = 1;\r\notg_statemachine(&otg_dev->fsm);\r\nreturn 0;\r\n}\r\nstatic int fsl_otg_start_hnp(struct usb_otg *otg)\r\n{\r\nstruct fsl_otg *otg_dev;\r\nif (!otg)\r\nreturn -ENODEV;\r\notg_dev = container_of(otg->phy, struct fsl_otg, phy);\r\nif (otg_dev != fsl_otg_dev)\r\nreturn -ENODEV;\r\nDBG("start_hnp...n");\r\notg_dev->fsm.a_bus_req = 0;\r\notg_statemachine(&otg_dev->fsm);\r\nreturn 0;\r\n}\r\nirqreturn_t fsl_otg_isr(int irq, void *dev_id)\r\n{\r\nstruct otg_fsm *fsm = &((struct fsl_otg *)dev_id)->fsm;\r\nstruct usb_otg *otg = ((struct fsl_otg *)dev_id)->phy.otg;\r\nu32 otg_int_src, otg_sc;\r\notg_sc = fsl_readl(&usb_dr_regs->otgsc);\r\notg_int_src = otg_sc & OTGSC_INTSTS_MASK & (otg_sc >> 8);\r\nfsl_writel(otg_sc, &usb_dr_regs->otgsc);\r\nfsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;\r\notg->default_a = (fsm->id == 0);\r\nif (otg_int_src) {\r\nif (otg_int_src & OTGSC_INTSTS_USB_ID) {\r\nfsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;\r\notg->default_a = (fsm->id == 0);\r\nif (fsm->id)\r\nfsm->b_conn = 0;\r\nelse\r\nfsm->a_conn = 0;\r\nif (otg->host)\r\notg->host->is_b_host = fsm->id;\r\nif (otg->gadget)\r\notg->gadget->is_a_peripheral = !fsm->id;\r\nVDBG("ID int (ID is %d)\n", fsm->id);\r\nif (fsm->id) {\r\nschedule_delayed_work(\r\n&((struct fsl_otg *)dev_id)->otg_event,\r\n100);\r\n} else {\r\ncancel_delayed_work(&\r\n((struct fsl_otg *)dev_id)->\r\notg_event);\r\nfsl_otg_start_gadget(fsm, 0);\r\notg_drv_vbus(fsm, 1);\r\nfsl_otg_start_host(fsm, 1);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int fsl_otg_conf(struct platform_device *pdev)\r\n{\r\nstruct fsl_otg *fsl_otg_tc;\r\nint status;\r\nif (fsl_otg_dev)\r\nreturn 0;\r\nfsl_otg_tc = kzalloc(sizeof(struct fsl_otg), GFP_KERNEL);\r\nif (!fsl_otg_tc)\r\nreturn -ENOMEM;\r\nfsl_otg_tc->phy.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);\r\nif (!fsl_otg_tc->phy.otg) {\r\nkfree(fsl_otg_tc);\r\nreturn -ENOMEM;\r\n}\r\nINIT_DELAYED_WORK(&fsl_otg_tc->otg_event, fsl_otg_event);\r\nINIT_LIST_HEAD(&active_timers);\r\nstatus = fsl_otg_init_timers(&fsl_otg_tc->fsm);\r\nif (status) {\r\npr_info("Couldn't init OTG timers\n");\r\ngoto err;\r\n}\r\nspin_lock_init(&fsl_otg_tc->fsm.lock);\r\nfsl_otg_tc->fsm.ops = &fsl_otg_ops;\r\nfsl_otg_tc->phy.label = DRIVER_DESC;\r\nfsl_otg_tc->phy.dev = &pdev->dev;\r\nfsl_otg_tc->phy.set_power = fsl_otg_set_power;\r\nfsl_otg_tc->phy.otg->phy = &fsl_otg_tc->phy;\r\nfsl_otg_tc->phy.otg->set_host = fsl_otg_set_host;\r\nfsl_otg_tc->phy.otg->set_peripheral = fsl_otg_set_peripheral;\r\nfsl_otg_tc->phy.otg->start_hnp = fsl_otg_start_hnp;\r\nfsl_otg_tc->phy.otg->start_srp = fsl_otg_start_srp;\r\nfsl_otg_dev = fsl_otg_tc;\r\nstatus = usb_add_phy(&fsl_otg_tc->phy, USB_PHY_TYPE_USB2);\r\nif (status) {\r\npr_warn(FSL_OTG_NAME ": unable to register OTG transceiver.\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfsl_otg_uninit_timers();\r\nkfree(fsl_otg_tc->phy.otg);\r\nkfree(fsl_otg_tc);\r\nreturn status;\r\n}\r\nint usb_otg_start(struct platform_device *pdev)\r\n{\r\nstruct fsl_otg *p_otg;\r\nstruct usb_phy *otg_trans = usb_get_phy(USB_PHY_TYPE_USB2);\r\nstruct otg_fsm *fsm;\r\nint status;\r\nstruct resource *res;\r\nu32 temp;\r\nstruct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;\r\np_otg = container_of(otg_trans, struct fsl_otg, phy);\r\nfsm = &p_otg->fsm;\r\nSET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);\r\nfsm->otg = p_otg->phy.otg;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nusb_dr_regs = ioremap(res->start, sizeof(struct usb_dr_mmap));\r\np_otg->dr_mem_map = (struct usb_dr_mmap *)usb_dr_regs;\r\npdata->regs = (void *)usb_dr_regs;\r\nif (pdata->init && pdata->init(pdev) != 0)\r\nreturn -EINVAL;\r\nif (pdata->big_endian_mmio) {\r\n_fsl_readl = _fsl_readl_be;\r\n_fsl_writel = _fsl_writel_be;\r\n} else {\r\n_fsl_readl = _fsl_readl_le;\r\n_fsl_writel = _fsl_writel_le;\r\n}\r\np_otg->irq = platform_get_irq(pdev, 0);\r\nstatus = request_irq(p_otg->irq, fsl_otg_isr,\r\nIRQF_SHARED, driver_name, p_otg);\r\nif (status) {\r\ndev_dbg(p_otg->phy.dev, "can't get IRQ %d, error %d\n",\r\np_otg->irq, status);\r\niounmap(p_otg->dr_mem_map);\r\nkfree(p_otg->phy.otg);\r\nkfree(p_otg);\r\nreturn status;\r\n}\r\ntemp = fsl_readl(&p_otg->dr_mem_map->usbcmd);\r\ntemp &= ~USB_CMD_RUN_STOP;\r\nfsl_writel(temp, &p_otg->dr_mem_map->usbcmd);\r\ntemp = fsl_readl(&p_otg->dr_mem_map->usbcmd);\r\ntemp |= USB_CMD_CTRL_RESET;\r\nfsl_writel(temp, &p_otg->dr_mem_map->usbcmd);\r\nwhile (fsl_readl(&p_otg->dr_mem_map->usbcmd) & USB_CMD_CTRL_RESET)\r\n;\r\ntemp = USB_MODE_STREAM_DISABLE | (pdata->es ? USB_MODE_ES : 0);\r\nfsl_writel(temp, &p_otg->dr_mem_map->usbmode);\r\ntemp = fsl_readl(&p_otg->dr_mem_map->portsc);\r\ntemp &= ~(PORTSC_PHY_TYPE_SEL | PORTSC_PTW);\r\nswitch (pdata->phy_mode) {\r\ncase FSL_USB2_PHY_ULPI:\r\ntemp |= PORTSC_PTS_ULPI;\r\nbreak;\r\ncase FSL_USB2_PHY_UTMI_WIDE:\r\ntemp |= PORTSC_PTW_16BIT;\r\ncase FSL_USB2_PHY_UTMI:\r\ntemp |= PORTSC_PTS_UTMI;\r\ndefault:\r\nbreak;\r\n}\r\nfsl_writel(temp, &p_otg->dr_mem_map->portsc);\r\nif (pdata->have_sysif_regs) {\r\ntemp = __raw_readl(&p_otg->dr_mem_map->control);\r\ntemp |= USB_CTRL_IOENB;\r\n__raw_writel(temp, &p_otg->dr_mem_map->control);\r\n}\r\ntemp = fsl_readl(&p_otg->dr_mem_map->otgsc);\r\ntemp &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;\r\ntemp |= OTGSC_INTERRUPT_STATUS_BITS_MASK | OTGSC_CTRL_VBUS_DISCHARGE;\r\nfsl_writel(temp, &p_otg->dr_mem_map->otgsc);\r\nif (fsl_readl(&p_otg->dr_mem_map->otgsc) & OTGSC_STS_USB_ID) {\r\np_otg->phy.state = OTG_STATE_UNDEFINED;\r\np_otg->fsm.id = 1;\r\n} else {\r\np_otg->phy.state = OTG_STATE_A_IDLE;\r\np_otg->fsm.id = 0;\r\n}\r\nDBG("initial ID pin=%d\n", p_otg->fsm.id);\r\ntemp = fsl_readl(&p_otg->dr_mem_map->otgsc);\r\ntemp |= OTGSC_INTR_USB_ID_EN;\r\ntemp &= ~(OTGSC_CTRL_VBUS_DISCHARGE | OTGSC_INTR_1MS_TIMER_EN);\r\nfsl_writel(temp, &p_otg->dr_mem_map->otgsc);\r\nreturn 0;\r\n}\r\nstatic int show_fsl_usb2_otg_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct otg_fsm *fsm = &fsl_otg_dev->fsm;\r\nchar *next = buf;\r\nunsigned size = PAGE_SIZE;\r\nunsigned long flags;\r\nint t;\r\nspin_lock_irqsave(&fsm->lock, flags);\r\nt = scnprintf(next, size,\r\nDRIVER_DESC "\n" "fsl_usb2_otg version: %s\n\n",\r\nDRIVER_VERSION);\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf(next, size,\r\n"OTGSC: 0x%08x\n"\r\n"PORTSC: 0x%08x\n"\r\n"USBMODE: 0x%08x\n"\r\n"USBCMD: 0x%08x\n"\r\n"USBSTS: 0x%08x\n"\r\n"USBINTR: 0x%08x\n",\r\nfsl_readl(&usb_dr_regs->otgsc),\r\nfsl_readl(&usb_dr_regs->portsc),\r\nfsl_readl(&usb_dr_regs->usbmode),\r\nfsl_readl(&usb_dr_regs->usbcmd),\r\nfsl_readl(&usb_dr_regs->usbsts),\r\nfsl_readl(&usb_dr_regs->usbintr));\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf(next, size,\r\n"OTG state: %s\n\n",\r\nusb_otg_state_string(fsl_otg_dev->phy.state));\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf(next, size,\r\n"a_bus_req: %d\n"\r\n"b_bus_req: %d\n"\r\n"a_bus_resume: %d\n"\r\n"a_bus_suspend: %d\n"\r\n"a_conn: %d\n"\r\n"a_sess_vld: %d\n"\r\n"a_srp_det: %d\n"\r\n"a_vbus_vld: %d\n"\r\n"b_bus_resume: %d\n"\r\n"b_bus_suspend: %d\n"\r\n"b_conn: %d\n"\r\n"b_se0_srp: %d\n"\r\n"b_sess_end: %d\n"\r\n"b_sess_vld: %d\n"\r\n"id: %d\n",\r\nfsm->a_bus_req,\r\nfsm->b_bus_req,\r\nfsm->a_bus_resume,\r\nfsm->a_bus_suspend,\r\nfsm->a_conn,\r\nfsm->a_sess_vld,\r\nfsm->a_srp_det,\r\nfsm->a_vbus_vld,\r\nfsm->b_bus_resume,\r\nfsm->b_bus_suspend,\r\nfsm->b_conn,\r\nfsm->b_se0_srp,\r\nfsm->b_sess_end,\r\nfsm->b_sess_vld,\r\nfsm->id);\r\nsize -= t;\r\nnext += t;\r\nspin_unlock_irqrestore(&fsm->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic long fsl_otg_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nu32 retval = 0;\r\nswitch (cmd) {\r\ncase GET_OTG_STATUS:\r\nretval = fsl_otg_dev->host_working;\r\nbreak;\r\ncase SET_A_SUSPEND_REQ:\r\nfsl_otg_dev->fsm.a_suspend_req = arg;\r\nbreak;\r\ncase SET_A_BUS_DROP:\r\nfsl_otg_dev->fsm.a_bus_drop = arg;\r\nbreak;\r\ncase SET_A_BUS_REQ:\r\nfsl_otg_dev->fsm.a_bus_req = arg;\r\nbreak;\r\ncase SET_B_BUS_REQ:\r\nfsl_otg_dev->fsm.b_bus_req = arg;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\notg_statemachine(&fsl_otg_dev->fsm);\r\nreturn retval;\r\n}\r\nstatic int fsl_otg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fsl_otg_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fsl_otg_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nif (!pdev->dev.platform_data)\r\nreturn -ENODEV;\r\nret = fsl_otg_conf(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't configure OTG module\n");\r\nreturn ret;\r\n}\r\nret = usb_otg_start(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't init FSL OTG device\n");\r\nreturn ret;\r\n}\r\nret = register_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME, &otg_fops);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to register FSL OTG device\n");\r\nreturn ret;\r\n}\r\nret = device_create_file(&pdev->dev, &dev_attr_fsl_usb2_otg_state);\r\nif (ret)\r\ndev_warn(&pdev->dev, "Can't register sysfs attribute\n");\r\nreturn ret;\r\n}\r\nstatic int fsl_otg_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;\r\nusb_remove_phy(&fsl_otg_dev->phy);\r\nfree_irq(fsl_otg_dev->irq, fsl_otg_dev);\r\niounmap((void *)usb_dr_regs);\r\nfsl_otg_uninit_timers();\r\nkfree(fsl_otg_dev->phy.otg);\r\nkfree(fsl_otg_dev);\r\ndevice_remove_file(&pdev->dev, &dev_attr_fsl_usb2_otg_state);\r\nunregister_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME);\r\nif (pdata->exit)\r\npdata->exit(pdev);\r\nreturn 0;\r\n}
