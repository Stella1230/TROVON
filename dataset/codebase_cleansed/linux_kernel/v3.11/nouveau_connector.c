struct nouveau_encoder *\r\nfind_encoder(struct drm_connector *connector, int type)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_mode_object *obj;\r\nint i, id;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nid = connector->encoder_ids[i];\r\nif (!id)\r\nbreak;\r\nobj = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_ENCODER);\r\nif (!obj)\r\ncontinue;\r\nnv_encoder = nouveau_encoder(obj_to_encoder(obj));\r\nif (type == DCB_OUTPUT_ANY || nv_encoder->dcb->type == type)\r\nreturn nv_encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstruct nouveau_connector *\r\nnouveau_encoder_connector_get(struct nouveau_encoder *encoder)\r\n{\r\nstruct drm_device *dev = to_drm_encoder(encoder)->dev;\r\nstruct drm_connector *drm_connector;\r\nlist_for_each_entry(drm_connector, &dev->mode_config.connector_list, head) {\r\nif (drm_connector->encoder == to_drm_encoder(encoder))\r\nreturn nouveau_connector(drm_connector);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nnouveau_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nkfree(nv_connector->edid);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic struct nouveau_i2c_port *\r\nnouveau_connector_ddc_detect(struct drm_connector *connector,\r\nstruct nouveau_encoder **pnv_encoder)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_gpio *gpio = nouveau_gpio(drm->device);\r\nstruct nouveau_i2c_port *port = NULL;\r\nint i, panel = -ENODEV;\r\nif (nv_connector->type == DCB_CONNECTOR_eDP) {\r\npanel = gpio->get(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff);\r\nif (panel == 0) {\r\ngpio->set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 1);\r\nmsleep(300);\r\n}\r\n}\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_mode_object *obj;\r\nint id;\r\nid = connector->encoder_ids[i];\r\nif (!id)\r\nbreak;\r\nobj = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_ENCODER);\r\nif (!obj)\r\ncontinue;\r\nnv_encoder = nouveau_encoder(obj_to_encoder(obj));\r\nport = nv_encoder->i2c;\r\nif (port && nv_probe_i2c(port, 0x50)) {\r\n*pnv_encoder = nv_encoder;\r\nbreak;\r\n}\r\nport = NULL;\r\n}\r\nif (!port && panel == 0)\r\ngpio->set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, panel);\r\nreturn port;\r\n}\r\nstatic struct nouveau_encoder *\r\nnouveau_connector_of_detect(struct drm_connector *connector)\r\n{\r\n#ifdef __powerpc__\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct device_node *cn, *dn = pci_device_to_OF_node(dev->pdev);\r\nif (!dn ||\r\n!((nv_encoder = find_encoder(connector, DCB_OUTPUT_TMDS)) ||\r\n(nv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG))))\r\nreturn NULL;\r\nfor_each_child_of_node(dn, cn) {\r\nconst char *name = of_get_property(cn, "name", NULL);\r\nconst void *edid = of_get_property(cn, "EDID", NULL);\r\nint idx = name ? name[strlen(name) - 1] - 'A' : 0;\r\nif (nv_encoder->dcb->i2c_index == idx && edid) {\r\nnv_connector->edid =\r\nkmemdup(edid, EDID_LENGTH, GFP_KERNEL);\r\nof_node_put(cn);\r\nreturn nv_encoder;\r\n}\r\n}\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic void\r\nnouveau_connector_set_encoder(struct drm_connector *connector,\r\nstruct nouveau_encoder *nv_encoder)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct drm_device *dev = connector->dev;\r\nif (nv_connector->detected_encoder == nv_encoder)\r\nreturn;\r\nnv_connector->detected_encoder = nv_encoder;\r\nif (nv_device(drm->device)->card_type >= NV_50) {\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\n} else\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||\r\nnv_encoder->dcb->type == DCB_OUTPUT_TMDS) {\r\nconnector->doublescan_allowed = false;\r\nconnector->interlace_allowed = false;\r\n} else {\r\nconnector->doublescan_allowed = true;\r\nif (nv_device(drm->device)->card_type == NV_20 ||\r\n(nv_device(drm->device)->card_type == NV_10 &&\r\n(dev->pci_device & 0x0ff0) != 0x0100 &&\r\n(dev->pci_device & 0x0ff0) != 0x0150))\r\nconnector->interlace_allowed = false;\r\nelse\r\nconnector->interlace_allowed = true;\r\n}\r\nif (nv_connector->type == DCB_CONNECTOR_DVI_I) {\r\ndrm_object_property_set_value(&connector->base,\r\ndev->mode_config.dvi_i_subconnector_property,\r\nnv_encoder->dcb->type == DCB_OUTPUT_TMDS ?\r\nDRM_MODE_SUBCONNECTOR_DVID :\r\nDRM_MODE_SUBCONNECTOR_DVIA);\r\n}\r\n}\r\nstatic enum drm_connector_status\r\nnouveau_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nstruct nouveau_encoder *nv_partner;\r\nstruct nouveau_i2c_port *i2c;\r\nint type;\r\nif (nv_connector->edid) {\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nkfree(nv_connector->edid);\r\nnv_connector->edid = NULL;\r\n}\r\ni2c = nouveau_connector_ddc_detect(connector, &nv_encoder);\r\nif (i2c) {\r\nnv_connector->edid = drm_get_edid(connector, &i2c->adapter);\r\ndrm_mode_connector_update_edid_property(connector,\r\nnv_connector->edid);\r\nif (!nv_connector->edid) {\r\nNV_ERROR(drm, "DDC responded, but no EDID for %s\n",\r\ndrm_get_connector_name(connector));\r\ngoto detect_analog;\r\n}\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_DP &&\r\n!nouveau_dp_detect(to_drm_encoder(nv_encoder))) {\r\nNV_ERROR(drm, "Detected %s, but failed init\n",\r\ndrm_get_connector_name(connector));\r\nreturn connector_status_disconnected;\r\n}\r\nnv_partner = NULL;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)\r\nnv_partner = find_encoder(connector, DCB_OUTPUT_ANALOG);\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_ANALOG)\r\nnv_partner = find_encoder(connector, DCB_OUTPUT_TMDS);\r\nif (nv_partner && ((nv_encoder->dcb->type == DCB_OUTPUT_ANALOG &&\r\nnv_partner->dcb->type == DCB_OUTPUT_TMDS) ||\r\n(nv_encoder->dcb->type == DCB_OUTPUT_TMDS &&\r\nnv_partner->dcb->type == DCB_OUTPUT_ANALOG))) {\r\nif (nv_connector->edid->input & DRM_EDID_INPUT_DIGITAL)\r\ntype = DCB_OUTPUT_TMDS;\r\nelse\r\ntype = DCB_OUTPUT_ANALOG;\r\nnv_encoder = find_encoder(connector, type);\r\n}\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nreturn connector_status_connected;\r\n}\r\nnv_encoder = nouveau_connector_of_detect(connector);\r\nif (nv_encoder) {\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nreturn connector_status_connected;\r\n}\r\ndetect_analog:\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG);\r\nif (!nv_encoder && !nouveau_tv_disable)\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_TV);\r\nif (nv_encoder && force) {\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nstruct drm_encoder_helper_funcs *helper =\r\nencoder->helper_private;\r\nif (helper->detect(encoder, connector) ==\r\nconnector_status_connected) {\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nreturn connector_status_connected;\r\n}\r\n}\r\nreturn connector_status_disconnected;\r\n}\r\nstatic enum drm_connector_status\r\nnouveau_connector_detect_lvds(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nenum drm_connector_status status = connector_status_disconnected;\r\nif (nv_connector->edid) {\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nkfree(nv_connector->edid);\r\nnv_connector->edid = NULL;\r\n}\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);\r\nif (!nv_encoder)\r\nreturn connector_status_disconnected;\r\nif (!drm->vbios.fp_no_ddc) {\r\nstatus = nouveau_connector_detect(connector, force);\r\nif (status == connector_status_connected)\r\ngoto out;\r\n}\r\nif (nv_encoder->dcb->lvdsconf.use_acpi_for_edid) {\r\nif ((nv_connector->edid = nouveau_acpi_edid(dev, connector))) {\r\nstatus = connector_status_connected;\r\ngoto out;\r\n}\r\n}\r\nif (nouveau_bios_fp_mode(dev, NULL) && (drm->vbios.fp_no_ddc ||\r\nnv_encoder->dcb->lvdsconf.use_straps_for_mode)) {\r\nstatus = connector_status_connected;\r\ngoto out;\r\n}\r\nif (!drm->vbios.fp_no_ddc) {\r\nstruct edid *edid =\r\n(struct edid *)nouveau_bios_embedded_edid(dev);\r\nif (edid) {\r\nnv_connector->edid =\r\nkmemdup(edid, EDID_LENGTH, GFP_KERNEL);\r\nif (nv_connector->edid)\r\nstatus = connector_status_connected;\r\n}\r\n}\r\nout:\r\n#if defined(CONFIG_ACPI_BUTTON) || \\r\n(defined(CONFIG_ACPI_BUTTON_MODULE) && defined(MODULE))\r\nif (status == connector_status_connected &&\r\n!nouveau_ignorelid && !acpi_lid_open())\r\nstatus = connector_status_unknown;\r\n#endif\r\ndrm_mode_connector_update_edid_property(connector, nv_connector->edid);\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\nreturn status;\r\n}\r\nstatic void\r\nnouveau_connector_force(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder;\r\nint type;\r\nif (nv_connector->type == DCB_CONNECTOR_DVI_I) {\r\nif (connector->force == DRM_FORCE_ON_DIGITAL)\r\ntype = DCB_OUTPUT_TMDS;\r\nelse\r\ntype = DCB_OUTPUT_ANALOG;\r\n} else\r\ntype = DCB_OUTPUT_ANY;\r\nnv_encoder = find_encoder(connector, type);\r\nif (!nv_encoder) {\r\nNV_ERROR(drm, "can't find encoder to force %s on!\n",\r\ndrm_get_connector_name(connector));\r\nconnector->status = connector_status_disconnected;\r\nreturn;\r\n}\r\nnouveau_connector_set_encoder(connector, nv_encoder);\r\n}\r\nstatic int\r\nnouveau_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property, uint64_t value)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_crtc *nv_crtc;\r\nint ret;\r\nnv_crtc = NULL;\r\nif (connector->encoder && connector->encoder->crtc)\r\nnv_crtc = nouveau_crtc(connector->encoder->crtc);\r\nif (property == dev->mode_config.scaling_mode_property) {\r\nbool modeset = false;\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_NONE:\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\ncase DRM_MODE_SCALE_CENTER:\r\ncase DRM_MODE_SCALE_ASPECT:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS &&\r\nvalue == DRM_MODE_SCALE_NONE)\r\nreturn -EINVAL;\r\nif ((nv_connector->scaling_mode == DRM_MODE_SCALE_NONE) ||\r\n(value == DRM_MODE_SCALE_NONE))\r\nmodeset = true;\r\nnv_connector->scaling_mode = value;\r\nif (!nv_crtc)\r\nreturn 0;\r\nif (modeset || !nv_crtc->set_scale) {\r\nret = drm_crtc_helper_set_mode(&nv_crtc->base,\r\n&nv_crtc->base.mode,\r\nnv_crtc->base.x,\r\nnv_crtc->base.y, NULL);\r\nif (!ret)\r\nreturn -EINVAL;\r\n} else {\r\nret = nv_crtc->set_scale(nv_crtc, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->underscan_property) {\r\nif (nv_connector->underscan != value) {\r\nnv_connector->underscan = value;\r\nif (!nv_crtc || !nv_crtc->set_scale)\r\nreturn 0;\r\nreturn nv_crtc->set_scale(nv_crtc, true);\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->underscan_hborder_property) {\r\nif (nv_connector->underscan_hborder != value) {\r\nnv_connector->underscan_hborder = value;\r\nif (!nv_crtc || !nv_crtc->set_scale)\r\nreturn 0;\r\nreturn nv_crtc->set_scale(nv_crtc, true);\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->underscan_vborder_property) {\r\nif (nv_connector->underscan_vborder != value) {\r\nnv_connector->underscan_vborder = value;\r\nif (!nv_crtc || !nv_crtc->set_scale)\r\nreturn 0;\r\nreturn nv_crtc->set_scale(nv_crtc, true);\r\n}\r\nreturn 0;\r\n}\r\nif (property == disp->dithering_mode) {\r\nnv_connector->dithering_mode = value;\r\nif (!nv_crtc || !nv_crtc->set_dither)\r\nreturn 0;\r\nreturn nv_crtc->set_dither(nv_crtc, true);\r\n}\r\nif (property == disp->dithering_depth) {\r\nnv_connector->dithering_depth = value;\r\nif (!nv_crtc || !nv_crtc->set_dither)\r\nreturn 0;\r\nreturn nv_crtc->set_dither(nv_crtc, true);\r\n}\r\nif (nv_crtc && nv_crtc->set_color_vibrance) {\r\nif (property == disp->vibrant_hue_property) {\r\nnv_crtc->vibrant_hue = value - 90;\r\nreturn nv_crtc->set_color_vibrance(nv_crtc, true);\r\n}\r\nif (property == disp->color_vibrance_property) {\r\nnv_crtc->color_vibrance = value - 100;\r\nreturn nv_crtc->set_color_vibrance(nv_crtc, true);\r\n}\r\n}\r\nif (nv_encoder && nv_encoder->dcb->type == DCB_OUTPUT_TV)\r\nreturn get_slave_funcs(encoder)->set_property(\r\nencoder, connector, property, value);\r\nreturn -EINVAL;\r\n}\r\nstatic struct drm_display_mode *\r\nnouveau_connector_native_mode(struct drm_connector *connector)\r\n{\r\nstruct drm_connector_helper_funcs *helper = connector->helper_private;\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode, *largest = NULL;\r\nint high_w = 0, high_h = 0, high_v = 0;\r\nlist_for_each_entry(mode, &nv_connector->base.probed_modes, head) {\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\nif (helper->mode_valid(connector, mode) != MODE_OK ||\r\n(mode->flags & DRM_MODE_FLAG_INTERLACE))\r\ncontinue;\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED) {\r\nNV_DEBUG(drm, "native mode from preferred\n");\r\nreturn drm_mode_duplicate(dev, mode);\r\n}\r\nif (mode->hdisplay < high_w)\r\ncontinue;\r\nif (mode->hdisplay == high_w && mode->vdisplay < high_h)\r\ncontinue;\r\nif (mode->hdisplay == high_w && mode->vdisplay == high_h &&\r\nmode->vrefresh < high_v)\r\ncontinue;\r\nhigh_w = mode->hdisplay;\r\nhigh_h = mode->vdisplay;\r\nhigh_v = mode->vrefresh;\r\nlargest = mode;\r\n}\r\nNV_DEBUG(drm, "native mode from largest: %dx%d@%d\n",\r\nhigh_w, high_h, high_v);\r\nreturn largest ? drm_mode_duplicate(dev, largest) : NULL;\r\n}\r\nstatic int\r\nnouveau_connector_scaler_modes_add(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct drm_display_mode *native = nv_connector->native_mode, *m;\r\nstruct drm_device *dev = connector->dev;\r\nstruct moderec *mode = &scaler_modes[0];\r\nint modes = 0;\r\nif (!native)\r\nreturn 0;\r\nwhile (mode->hdisplay) {\r\nif (mode->hdisplay <= native->hdisplay &&\r\nmode->vdisplay <= native->vdisplay) {\r\nm = drm_cvt_mode(dev, mode->hdisplay, mode->vdisplay,\r\ndrm_mode_vrefresh(native), false,\r\nfalse, false);\r\nif (!m)\r\ncontinue;\r\nm->type |= DRM_MODE_TYPE_DRIVER;\r\ndrm_mode_probed_add(connector, m);\r\nmodes++;\r\n}\r\nmode++;\r\n}\r\nreturn modes;\r\n}\r\nstatic void\r\nnouveau_connector_detect_depth(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct nvbios *bios = &drm->vbios;\r\nstruct drm_display_mode *mode = nv_connector->native_mode;\r\nbool duallink;\r\nif (nv_connector->edid && connector->display_info.bpc)\r\nreturn;\r\nif (nv_connector->type == DCB_CONNECTOR_eDP) {\r\nconnector->display_info.bpc = 6;\r\nreturn;\r\n}\r\nif (nv_encoder->dcb->type != DCB_OUTPUT_LVDS) {\r\nconnector->display_info.bpc = 8;\r\nreturn;\r\n}\r\nconnector->display_info.bpc = 6;\r\nif (bios->fp_no_ddc) {\r\nif (bios->fp.if_is_24bit)\r\nconnector->display_info.bpc = 8;\r\nreturn;\r\n}\r\nif (nv_connector->edid &&\r\nnv_connector->type == DCB_CONNECTOR_LVDS_SPWG)\r\nduallink = ((u8 *)nv_connector->edid)[121] == 2;\r\nelse\r\nduallink = mode->clock >= bios->fp.duallink_transition_clk;\r\nif ((!duallink && (bios->fp.strapless_is_24bit & 1)) ||\r\n( duallink && (bios->fp.strapless_is_24bit & 2)))\r\nconnector->display_info.bpc = 8;\r\n}\r\nstatic int\r\nnouveau_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nint ret = 0;\r\nif (nv_connector->native_mode) {\r\ndrm_mode_destroy(dev, nv_connector->native_mode);\r\nnv_connector->native_mode = NULL;\r\n}\r\nif (nv_connector->edid)\r\nret = drm_add_edid_modes(connector, nv_connector->edid);\r\nelse\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS &&\r\n(nv_encoder->dcb->lvdsconf.use_straps_for_mode ||\r\ndrm->vbios.fp_no_ddc) && nouveau_bios_fp_mode(dev, NULL)) {\r\nstruct drm_display_mode mode;\r\nnouveau_bios_fp_mode(dev, &mode);\r\nnv_connector->native_mode = drm_mode_duplicate(dev, &mode);\r\n}\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS)\r\nnouveau_connector_detect_depth(connector);\r\nif (!nv_connector->native_mode)\r\nnv_connector->native_mode =\r\nnouveau_connector_native_mode(connector);\r\nif (ret == 0 && nv_connector->native_mode) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(dev, nv_connector->native_mode);\r\ndrm_mode_probed_add(connector, mode);\r\nret = 1;\r\n}\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)\r\nnouveau_connector_detect_depth(connector);\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_TV)\r\nret = get_slave_funcs(encoder)->get_modes(encoder, connector);\r\nif (nv_connector->type == DCB_CONNECTOR_LVDS ||\r\nnv_connector->type == DCB_CONNECTOR_LVDS_SPWG ||\r\nnv_connector->type == DCB_CONNECTOR_eDP)\r\nret += nouveau_connector_scaler_modes_add(connector);\r\nreturn ret;\r\n}\r\nstatic unsigned\r\nget_tmds_link_bandwidth(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct dcb_output *dcb = nv_connector->detected_encoder->dcb;\r\nif (dcb->location != DCB_LOC_ON_CHIP ||\r\nnv_device(drm->device)->chipset >= 0x46)\r\nreturn 165000;\r\nelse if (nv_device(drm->device)->chipset >= 0x40)\r\nreturn 155000;\r\nelse if (nv_device(drm->device)->chipset >= 0x18)\r\nreturn 135000;\r\nelse\r\nreturn 112000;\r\n}\r\nstatic int\r\nnouveau_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\r\nstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\r\nunsigned min_clock = 25000, max_clock = min_clock;\r\nunsigned clock = mode->clock;\r\nswitch (nv_encoder->dcb->type) {\r\ncase DCB_OUTPUT_LVDS:\r\nif (nv_connector->native_mode &&\r\n(mode->hdisplay > nv_connector->native_mode->hdisplay ||\r\nmode->vdisplay > nv_connector->native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\nmin_clock = 0;\r\nmax_clock = 400000;\r\nbreak;\r\ncase DCB_OUTPUT_TMDS:\r\nmax_clock = get_tmds_link_bandwidth(connector);\r\nif (nouveau_duallink && nv_encoder->dcb->duallink_possible)\r\nmax_clock *= 2;\r\nbreak;\r\ncase DCB_OUTPUT_ANALOG:\r\nmax_clock = nv_encoder->dcb->crtconf.maxfreq;\r\nif (!max_clock)\r\nmax_clock = 350000;\r\nbreak;\r\ncase DCB_OUTPUT_TV:\r\nreturn get_slave_funcs(encoder)->mode_valid(encoder, mode);\r\ncase DCB_OUTPUT_DP:\r\nmax_clock = nv_encoder->dp.link_nr;\r\nmax_clock *= nv_encoder->dp.link_bw;\r\nclock = clock * (connector->display_info.bpc * 3) / 10;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nreturn MODE_BAD;\r\n}\r\nif (clock < min_clock)\r\nreturn MODE_CLOCK_LOW;\r\nif (clock > max_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *\r\nnouveau_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct nouveau_connector *nv_connector = nouveau_connector(connector);\r\nif (nv_connector->detected_encoder)\r\nreturn to_drm_encoder(nv_connector->detected_encoder);\r\nreturn NULL;\r\n}\r\nstatic void\r\nnouveau_connector_hotplug_work(struct work_struct *work)\r\n{\r\nstruct nouveau_connector *nv_connector =\r\ncontainer_of(work, struct nouveau_connector, hpd_work);\r\nstruct drm_connector *connector = &nv_connector->base;\r\nstruct drm_device *dev = connector->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_gpio *gpio = nouveau_gpio(drm->device);\r\nbool plugged = gpio->get(gpio, 0, nv_connector->hpd.func, 0xff);\r\nNV_DEBUG(drm, "%splugged %s\n", plugged ? "" : "un",\r\ndrm_get_connector_name(connector));\r\nif (plugged)\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\r\nelse\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\ndrm_helper_hpd_irq_event(dev);\r\n}\r\nstatic int\r\nnouveau_connector_hotplug(struct nouveau_eventh *event, int index)\r\n{\r\nstruct nouveau_connector *nv_connector =\r\ncontainer_of(event, struct nouveau_connector, hpd_func);\r\nschedule_work(&nv_connector->hpd_work);\r\nreturn NVKM_EVENT_KEEP;\r\n}\r\nstatic int\r\ndrm_conntype_from_dcb(enum dcb_connector_type dcb)\r\n{\r\nswitch (dcb) {\r\ncase DCB_CONNECTOR_VGA : return DRM_MODE_CONNECTOR_VGA;\r\ncase DCB_CONNECTOR_TV_0 :\r\ncase DCB_CONNECTOR_TV_1 :\r\ncase DCB_CONNECTOR_TV_3 : return DRM_MODE_CONNECTOR_TV;\r\ncase DCB_CONNECTOR_DMS59_0 :\r\ncase DCB_CONNECTOR_DMS59_1 :\r\ncase DCB_CONNECTOR_DVI_I : return DRM_MODE_CONNECTOR_DVII;\r\ncase DCB_CONNECTOR_DVI_D : return DRM_MODE_CONNECTOR_DVID;\r\ncase DCB_CONNECTOR_LVDS :\r\ncase DCB_CONNECTOR_LVDS_SPWG: return DRM_MODE_CONNECTOR_LVDS;\r\ncase DCB_CONNECTOR_DMS59_DP0:\r\ncase DCB_CONNECTOR_DMS59_DP1:\r\ncase DCB_CONNECTOR_DP : return DRM_MODE_CONNECTOR_DisplayPort;\r\ncase DCB_CONNECTOR_eDP : return DRM_MODE_CONNECTOR_eDP;\r\ncase DCB_CONNECTOR_HDMI_0 :\r\ncase DCB_CONNECTOR_HDMI_1 : return DRM_MODE_CONNECTOR_HDMIA;\r\ndefault:\r\nbreak;\r\n}\r\nreturn DRM_MODE_CONNECTOR_Unknown;\r\n}\r\nstruct drm_connector *\r\nnouveau_connector_create(struct drm_device *dev, int index)\r\n{\r\nconst struct drm_connector_funcs *funcs = &nouveau_connector_funcs;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_gpio *gpio = nouveau_gpio(drm->device);\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nstruct nouveau_connector *nv_connector = NULL;\r\nstruct drm_connector *connector;\r\nint type, ret = 0;\r\nbool dummy;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nnv_connector = nouveau_connector(connector);\r\nif (nv_connector->index == index)\r\nreturn connector;\r\n}\r\nnv_connector = kzalloc(sizeof(*nv_connector), GFP_KERNEL);\r\nif (!nv_connector)\r\nreturn ERR_PTR(-ENOMEM);\r\nconnector = &nv_connector->base;\r\nINIT_WORK(&nv_connector->hpd_work, nouveau_connector_hotplug_work);\r\nnv_connector->index = index;\r\nnv_connector->dcb = olddcb_conn(dev, index);\r\nif (nv_connector->dcb) {\r\nstatic const u8 hpd[16] = {\r\n0xff, 0x07, 0x08, 0xff, 0xff, 0x51, 0x52, 0xff,\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0x5e, 0x5f, 0x60,\r\n};\r\nu32 entry = ROM16(nv_connector->dcb[0]);\r\nif (olddcb_conntab(dev)[3] >= 4)\r\nentry |= (u32)ROM16(nv_connector->dcb[2]) << 16;\r\nret = gpio->find(gpio, 0, hpd[ffs((entry & 0x07033000) >> 12)],\r\nDCB_GPIO_UNUSED, &nv_connector->hpd);\r\nnv_connector->hpd_func.func = nouveau_connector_hotplug;\r\nif (ret)\r\nnv_connector->hpd.func = DCB_GPIO_UNUSED;\r\nnv_connector->type = nv_connector->dcb[0];\r\nif (drm_conntype_from_dcb(nv_connector->type) ==\r\nDRM_MODE_CONNECTOR_Unknown) {\r\nNV_WARN(drm, "unknown connector type %02x\n",\r\nnv_connector->type);\r\nnv_connector->type = DCB_CONNECTOR_NONE;\r\n}\r\nif (nv_match_device(dev, 0x0421, 0x1458, 0x344c)) {\r\nif (nv_connector->type == DCB_CONNECTOR_HDMI_1)\r\nnv_connector->type = DCB_CONNECTOR_DVI_I;\r\n}\r\nif (nv_match_device(dev, 0x0402, 0x1458, 0x3455)) {\r\nif (nv_connector->type == DCB_CONNECTOR_HDMI_1)\r\nnv_connector->type = DCB_CONNECTOR_DVI_I;\r\n}\r\n} else {\r\nnv_connector->type = DCB_CONNECTOR_NONE;\r\nnv_connector->hpd.func = DCB_GPIO_UNUSED;\r\n}\r\nif (nv_connector->type == DCB_CONNECTOR_NONE) {\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct dcb_table *dcbt = &drm->vbios.dcb;\r\nu32 encoders = 0;\r\nint i;\r\nfor (i = 0; i < dcbt->entries; i++) {\r\nif (dcbt->entry[i].connector == nv_connector->index)\r\nencoders |= (1 << dcbt->entry[i].type);\r\n}\r\nif (encoders & (1 << DCB_OUTPUT_DP)) {\r\nif (encoders & (1 << DCB_OUTPUT_TMDS))\r\nnv_connector->type = DCB_CONNECTOR_DP;\r\nelse\r\nnv_connector->type = DCB_CONNECTOR_eDP;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_TMDS)) {\r\nif (encoders & (1 << DCB_OUTPUT_ANALOG))\r\nnv_connector->type = DCB_CONNECTOR_DVI_I;\r\nelse\r\nnv_connector->type = DCB_CONNECTOR_DVI_D;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_ANALOG)) {\r\nnv_connector->type = DCB_CONNECTOR_VGA;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_LVDS)) {\r\nnv_connector->type = DCB_CONNECTOR_LVDS;\r\n} else\r\nif (encoders & (1 << DCB_OUTPUT_TV)) {\r\nnv_connector->type = DCB_CONNECTOR_TV_0;\r\n}\r\n}\r\ntype = drm_conntype_from_dcb(nv_connector->type);\r\nif (type == DRM_MODE_CONNECTOR_LVDS) {\r\nret = nouveau_bios_parse_lvds_table(dev, 0, &dummy, &dummy);\r\nif (ret) {\r\nNV_ERROR(drm, "Error parsing LVDS table, disabling\n");\r\nkfree(nv_connector);\r\nreturn ERR_PTR(ret);\r\n}\r\nfuncs = &nouveau_connector_funcs_lvds;\r\n} else {\r\nfuncs = &nouveau_connector_funcs;\r\n}\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_connector_init(dev, connector, funcs, type);\r\ndrm_connector_helper_add(connector, &nouveau_connector_helper_funcs);\r\nif (nv_connector->type == DCB_CONNECTOR_DVI_I)\r\ndrm_object_attach_property(&connector->base, dev->mode_config.dvi_i_subconnector_property, 0);\r\nif (disp->underscan_property &&\r\n(type == DRM_MODE_CONNECTOR_DVID ||\r\ntype == DRM_MODE_CONNECTOR_DVII ||\r\ntype == DRM_MODE_CONNECTOR_HDMIA ||\r\ntype == DRM_MODE_CONNECTOR_DisplayPort)) {\r\ndrm_object_attach_property(&connector->base,\r\ndisp->underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&connector->base,\r\ndisp->underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&connector->base,\r\ndisp->underscan_vborder_property,\r\n0);\r\n}\r\nif (disp->vibrant_hue_property)\r\ndrm_object_attach_property(&connector->base,\r\ndisp->vibrant_hue_property,\r\n90);\r\nif (disp->color_vibrance_property)\r\ndrm_object_attach_property(&connector->base,\r\ndisp->color_vibrance_property,\r\n150);\r\nswitch (nv_connector->type) {\r\ncase DCB_CONNECTOR_VGA:\r\nif (nv_device(drm->device)->card_type >= NV_50) {\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\nnv_connector->scaling_mode);\r\n}\r\ncase DCB_CONNECTOR_TV_0:\r\ncase DCB_CONNECTOR_TV_1:\r\ncase DCB_CONNECTOR_TV_3:\r\nnv_connector->scaling_mode = DRM_MODE_SCALE_NONE;\r\nbreak;\r\ndefault:\r\nnv_connector->scaling_mode = DRM_MODE_SCALE_FULLSCREEN;\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\nnv_connector->scaling_mode);\r\nif (disp->dithering_mode) {\r\nnv_connector->dithering_mode = DITHERING_MODE_AUTO;\r\ndrm_object_attach_property(&connector->base,\r\ndisp->dithering_mode,\r\nnv_connector->dithering_mode);\r\n}\r\nif (disp->dithering_depth) {\r\nnv_connector->dithering_depth = DITHERING_DEPTH_AUTO;\r\ndrm_object_attach_property(&connector->base,\r\ndisp->dithering_depth,\r\nnv_connector->dithering_depth);\r\n}\r\nbreak;\r\n}\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nif (nv_connector->hpd.func != DCB_GPIO_UNUSED)\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_sysfs_connector_add(connector);\r\nreturn connector;\r\n}
