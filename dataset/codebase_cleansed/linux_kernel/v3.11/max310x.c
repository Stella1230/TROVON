static bool max3107_8_reg_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX310X_IRQSTS_REG:\r\ncase MAX310X_LSR_IRQSTS_REG:\r\ncase MAX310X_SPCHR_IRQSTS_REG:\r\ncase MAX310X_STS_IRQSTS_REG:\r\ncase MAX310X_TXFIFOLVL_REG:\r\ncase MAX310X_RXFIFOLVL_REG:\r\ncase MAX3107_REVID_REG:\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic bool max310x_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX310X_RHR_REG:\r\ncase MAX310X_IRQSTS_REG:\r\ncase MAX310X_LSR_IRQSTS_REG:\r\ncase MAX310X_SPCHR_IRQSTS_REG:\r\ncase MAX310X_STS_IRQSTS_REG:\r\ncase MAX310X_TXFIFOLVL_REG:\r\ncase MAX310X_RXFIFOLVL_REG:\r\ncase MAX310X_GPIODATA_REG:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic bool max310x_reg_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX310X_RHR_REG:\r\ncase MAX310X_IRQSTS_REG:\r\ncase MAX310X_SPCHR_IRQSTS_REG:\r\ncase MAX310X_STS_IRQSTS_REG:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic void max310x_set_baud(struct max310x_port *s, int baud)\r\n{\r\nunsigned int mode = 0, div = s->uartclk / baud;\r\nif (!(div / 16)) {\r\nmode = MAX310X_BRGCFG_2XMODE_BIT;\r\ndiv = (s->uartclk * 2) / baud;\r\n}\r\nif (!(div / 16)) {\r\nmode = MAX310X_BRGCFG_4XMODE_BIT;\r\ndiv = (s->uartclk * 4) / baud;\r\n}\r\nregmap_write(s->regmap, MAX310X_BRGDIVMSB_REG,\r\n((div / 16) >> 8) & 0xff);\r\nregmap_write(s->regmap, MAX310X_BRGDIVLSB_REG, (div / 16) & 0xff);\r\nregmap_write(s->regmap, MAX310X_BRGCFG_REG, (div % 16) | mode);\r\n}\r\nstatic void max310x_wait_pll(struct max310x_port *s)\r\n{\r\nint tryes = 1000;\r\nif (!(s->pdata->driver_flags & MAX310X_EXT_CLK)) {\r\nunsigned int sts = 0;\r\nwhile (tryes--) {\r\nregmap_read(s->regmap, MAX310X_STS_IRQSTS_REG, &sts);\r\nif (sts & MAX310X_STS_CLKREADY_BIT)\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int max310x_update_best_err(unsigned long f, long *besterr)\r\n{\r\nlong err = f % (115200 * 16);\r\nif ((*besterr < 0) || (*besterr > err)) {\r\n*besterr = err;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int max310x_set_ref_clk(struct max310x_port *s)\r\n{\r\nunsigned int div, clksrc, pllcfg = 0;\r\nlong besterr = -1;\r\nunsigned long fdiv, fmul, bestfreq = s->pdata->frequency;\r\nmax310x_update_best_err(s->pdata->frequency, &besterr);\r\nfor (div = 1; (div <= 63) && besterr; div++) {\r\nfdiv = DIV_ROUND_CLOSEST(s->pdata->frequency, div);\r\nfmul = fdiv * 6;\r\nif ((fdiv >= 500000) && (fdiv <= 800000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (0 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\nfmul = fdiv * 48;\r\nif ((fdiv >= 850000) && (fdiv <= 1200000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (1 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\nfmul = fdiv * 96;\r\nif ((fdiv >= 425000) && (fdiv <= 1000000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (2 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\nfmul = fdiv * 144;\r\nif ((fdiv >= 390000) && (fdiv <= 667000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (3 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\n}\r\nif (s->pdata->driver_flags & MAX310X_EXT_CLK)\r\nclksrc = MAX310X_CLKSRC_EXTCLK_BIT;\r\nelse\r\nclksrc = MAX310X_CLKSRC_CRYST_BIT;\r\nif (pllcfg) {\r\nclksrc |= MAX310X_CLKSRC_PLL_BIT;\r\nregmap_write(s->regmap, MAX310X_PLLCFG_REG, pllcfg);\r\n} else\r\nclksrc |= MAX310X_CLKSRC_PLLBYP_BIT;\r\nregmap_write(s->regmap, MAX310X_CLKSRC_REG, clksrc);\r\nif (pllcfg)\r\nmax310x_wait_pll(s);\r\ndev_dbg(s->port.dev, "Reference clock set to %lu Hz\n", bestfreq);\r\nreturn (int)bestfreq;\r\n}\r\nstatic void max310x_handle_rx(struct max310x_port *s, unsigned int rxlen)\r\n{\r\nunsigned int sts = 0, ch = 0, flag;\r\nif (unlikely(rxlen >= MAX310X_FIFO_SIZE)) {\r\ndev_warn(s->port.dev, "Possible RX FIFO overrun %d\n", rxlen);\r\nrxlen = MAX310X_FIFO_SIZE;\r\n}\r\ndev_dbg(s->port.dev, "RX Len = %u\n", rxlen);\r\nwhile (rxlen--) {\r\nregmap_read(s->regmap, MAX310X_RHR_REG, &ch);\r\nregmap_read(s->regmap, MAX310X_LSR_IRQSTS_REG, &sts);\r\nsts &= MAX310X_LSR_RXPAR_BIT | MAX310X_LSR_FRERR_BIT |\r\nMAX310X_LSR_RXOVR_BIT | MAX310X_LSR_RXBRK_BIT;\r\ns->port.icount.rx++;\r\nflag = TTY_NORMAL;\r\nif (unlikely(sts)) {\r\nif (sts & MAX310X_LSR_RXBRK_BIT) {\r\ns->port.icount.brk++;\r\nif (uart_handle_break(&s->port))\r\ncontinue;\r\n} else if (sts & MAX310X_LSR_RXPAR_BIT)\r\ns->port.icount.parity++;\r\nelse if (sts & MAX310X_LSR_FRERR_BIT)\r\ns->port.icount.frame++;\r\nelse if (sts & MAX310X_LSR_RXOVR_BIT)\r\ns->port.icount.overrun++;\r\nsts &= s->port.read_status_mask;\r\nif (sts & MAX310X_LSR_RXBRK_BIT)\r\nflag = TTY_BREAK;\r\nelse if (sts & MAX310X_LSR_RXPAR_BIT)\r\nflag = TTY_PARITY;\r\nelse if (sts & MAX310X_LSR_FRERR_BIT)\r\nflag = TTY_FRAME;\r\nelse if (sts & MAX310X_LSR_RXOVR_BIT)\r\nflag = TTY_OVERRUN;\r\n}\r\nif (uart_handle_sysrq_char(s->port, ch))\r\ncontinue;\r\nif (sts & s->port.ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(&s->port, sts, MAX310X_LSR_RXOVR_BIT,\r\nch, flag);\r\n}\r\ntty_flip_buffer_push(&s->port.state->port);\r\n}\r\nstatic void max310x_handle_tx(struct max310x_port *s)\r\n{\r\nstruct circ_buf *xmit = &s->port.state->xmit;\r\nunsigned int txlen = 0, to_send;\r\nif (unlikely(s->port.x_char)) {\r\nregmap_write(s->regmap, MAX310X_THR_REG, s->port.x_char);\r\ns->port.icount.tx++;\r\ns->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&s->port))\r\nreturn;\r\nto_send = uart_circ_chars_pending(xmit);\r\nif (likely(to_send)) {\r\nregmap_read(s->regmap, MAX310X_TXFIFOLVL_REG, &txlen);\r\ntxlen = MAX310X_FIFO_SIZE - txlen;\r\nto_send = (to_send > txlen) ? txlen : to_send;\r\ndev_dbg(s->port.dev, "TX Len = %u\n", to_send);\r\ns->port.icount.tx += to_send;\r\nwhile (to_send--) {\r\nregmap_write(s->regmap, MAX310X_THR_REG,\r\nxmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n};\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&s->port);\r\n}\r\nstatic irqreturn_t max310x_ist(int irq, void *dev_id)\r\n{\r\nstruct max310x_port *s = (struct max310x_port *)dev_id;\r\nunsigned int ists = 0, lsr = 0, rxlen = 0;\r\nmutex_lock(&s->max310x_mutex);\r\nfor (;;) {\r\nregmap_read(s->regmap, MAX310X_IRQSTS_REG, &ists);\r\nregmap_read(s->regmap, MAX310X_LSR_IRQSTS_REG, &lsr);\r\nregmap_read(s->regmap, MAX310X_RXFIFOLVL_REG, &rxlen);\r\nif (!ists && !(lsr & MAX310X_LSR_RXTO_BIT) && !rxlen)\r\nbreak;\r\ndev_dbg(s->port.dev, "IRQ status: 0x%02x\n", ists);\r\nif (rxlen)\r\nmax310x_handle_rx(s, rxlen);\r\nif (ists & MAX310X_IRQ_TX)\r\nmax310x_handle_tx(s);\r\nif (ists & MAX310X_IRQ_CTS_BIT)\r\nuart_handle_cts_change(&s->port,\r\n!!(lsr & MAX310X_LSR_CTS_BIT));\r\n}\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void max310x_wq_proc(struct work_struct *ws)\r\n{\r\nstruct max310x_port *s = container_of(ws, struct max310x_port, tx_work);\r\nmutex_lock(&s->max310x_mutex);\r\nmax310x_handle_tx(s);\r\nmutex_unlock(&s->max310x_mutex);\r\n}\r\nstatic void max310x_start_tx(struct uart_port *port)\r\n{\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nqueue_work(s->wq, &s->tx_work);\r\n}\r\nstatic void max310x_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void max310x_stop_rx(struct uart_port *port)\r\n{\r\n}\r\nstatic unsigned int max310x_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int val = 0;\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_read(s->regmap, MAX310X_TXFIFOLVL_REG, &val);\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn val ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic void max310x_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic unsigned int max310x_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void max310x_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void max310x_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_update_bits(s->regmap, MAX310X_LCR_REG,\r\nMAX310X_LCR_TXBREAK_BIT,\r\nbreak_state ? MAX310X_LCR_TXBREAK_BIT : 0);\r\nmutex_unlock(&s->max310x_mutex);\r\n}\r\nstatic void max310x_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nunsigned int lcr, flow = 0;\r\nint baud;\r\nmutex_lock(&s->max310x_mutex);\r\ntermios->c_cflag &= ~CMSPAR;\r\ntermios->c_iflag &= ~IXANY;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr = MAX310X_LCR_WORD_LEN_5;\r\nbreak;\r\ncase CS6:\r\nlcr = MAX310X_LCR_WORD_LEN_6;\r\nbreak;\r\ncase CS7:\r\nlcr = MAX310X_LCR_WORD_LEN_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nlcr = MAX310X_LCR_WORD_LEN_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\nlcr |= MAX310X_LCR_PARITY_BIT;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr |= MAX310X_LCR_EVENPARITY_BIT;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= MAX310X_LCR_STOPLEN_BIT;\r\nregmap_write(s->regmap, MAX310X_LCR_REG, lcr);\r\nport->read_status_mask = MAX310X_LSR_RXOVR_BIT;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= MAX310X_LSR_RXPAR_BIT |\r\nMAX310X_LSR_FRERR_BIT;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= MAX310X_LSR_RXBRK_BIT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNBRK)\r\nport->ignore_status_mask |= MAX310X_LSR_RXBRK_BIT;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= MAX310X_LSR_RXPAR_BIT |\r\nMAX310X_LSR_RXOVR_BIT |\r\nMAX310X_LSR_FRERR_BIT |\r\nMAX310X_LSR_RXBRK_BIT;\r\nregmap_write(s->regmap, MAX310X_XON1_REG, termios->c_cc[VSTART]);\r\nregmap_write(s->regmap, MAX310X_XOFF1_REG, termios->c_cc[VSTOP]);\r\nif (termios->c_cflag & CRTSCTS)\r\nflow |= MAX310X_FLOWCTRL_AUTOCTS_BIT |\r\nMAX310X_FLOWCTRL_AUTORTS_BIT;\r\nif (termios->c_iflag & IXON)\r\nflow |= MAX310X_FLOWCTRL_SWFLOW3_BIT |\r\nMAX310X_FLOWCTRL_SWFLOWEN_BIT;\r\nif (termios->c_iflag & IXOFF)\r\nflow |= MAX310X_FLOWCTRL_SWFLOW1_BIT |\r\nMAX310X_FLOWCTRL_SWFLOWEN_BIT;\r\nregmap_write(s->regmap, MAX310X_FLOWCTRL_REG, flow);\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nport->uartclk / 16 / 0xffff,\r\nport->uartclk / 4);\r\nmax310x_set_baud(s, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nmutex_unlock(&s->max310x_mutex);\r\n}\r\nstatic int max310x_startup(struct uart_port *port)\r\n{\r\nunsigned int val, line = port->line;\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nif (s->pdata->suspend)\r\ns->pdata->suspend(0);\r\nmutex_lock(&s->max310x_mutex);\r\nmax310x_set_baud(s, 9600);\r\nval = MAX310X_LCR_WORD_LEN_8;\r\nregmap_write(s->regmap, MAX310X_LCR_REG, val);\r\nregmap_update_bits(s->regmap, MAX310X_MODE1_REG,\r\nMAX310X_MODE1_TRNSCVCTRL_BIT,\r\n(s->pdata->uart_flags[line] & MAX310X_AUTO_DIR_CTRL)\r\n? MAX310X_MODE1_TRNSCVCTRL_BIT : 0);\r\nval = MAX310X_MODE2_RXEMPTINV_BIT;\r\nif (s->pdata->uart_flags[line] & MAX310X_LOOPBACK)\r\nval |= MAX310X_MODE2_LOOPBACK_BIT;\r\nif (s->pdata->uart_flags[line] & MAX310X_ECHO_SUPRESS)\r\nval |= MAX310X_MODE2_ECHOSUPR_BIT;\r\nval |= MAX310X_MODE2_FIFORST_BIT;\r\nregmap_write(s->regmap, MAX310X_MODE2_REG, val);\r\nval = MAX310X_FIFOTRIGLVL_RX(16) | MAX310X_FIFOTRIGLVL_TX(64);\r\nregmap_write(s->regmap, MAX310X_FIFOTRIGLVL_REG, val);\r\nval = MAX310X_FLOWLVL_RES(48) | MAX310X_FLOWLVL_HALT(96);\r\nregmap_write(s->regmap, MAX310X_FLOWLVL_REG, val);\r\nregmap_write(s->regmap, MAX310X_RXTO_REG, 0);\r\nval = MAX310X_LSR_RXTO_BIT;\r\nregmap_write(s->regmap, MAX310X_LSR_IRQEN_REG, val);\r\nregmap_update_bits(s->regmap, MAX310X_MODE2_REG,\r\nMAX310X_MODE2_FIFORST_BIT, 0);\r\nregmap_read(s->regmap, MAX310X_IRQSTS_REG, &val);\r\nval = MAX310X_IRQ_CTS_BIT;\r\nval |= MAX310X_IRQ_RX | MAX310X_IRQ_TX;\r\nregmap_write(s->regmap, MAX310X_IRQEN_REG, val);\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn 0;\r\n}\r\nstatic void max310x_shutdown(struct uart_port *port)\r\n{\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_write(s->regmap, MAX310X_IRQEN_REG, 0);\r\nmutex_unlock(&s->max310x_mutex);\r\nif (s->pdata->suspend)\r\ns->pdata->suspend(1);\r\n}\r\nstatic const char *max310x_type(struct uart_port *port)\r\n{\r\nstruct max310x_port *s = container_of(port, struct max310x_port, port);\r\nreturn (port->type == PORT_MAX310X) ? s->name : NULL;\r\n}\r\nstatic int max310x_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void max310x_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic void max310x_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_MAX310X;\r\n}\r\nstatic int max310x_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif ((ser->type == PORT_UNKNOWN) || (ser->type == PORT_MAX310X))\r\nreturn 0;\r\nif (ser->irq == port->irq)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int max310x_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\ndev_dbg(dev, "Suspend\n");\r\nret = uart_suspend_port(&s->uart, &s->port);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_update_bits(s->regmap, MAX310X_MODE1_REG,\r\nMAX310X_MODE1_FORCESLEEP_BIT,\r\nMAX310X_MODE1_FORCESLEEP_BIT);\r\nmutex_unlock(&s->max310x_mutex);\r\nif (s->pdata->suspend)\r\ns->pdata->suspend(1);\r\nreturn ret;\r\n}\r\nstatic int max310x_resume(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\ndev_dbg(dev, "Resume\n");\r\nif (s->pdata->suspend)\r\ns->pdata->suspend(0);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_update_bits(s->regmap, MAX310X_MODE1_REG,\r\nMAX310X_MODE1_FORCESLEEP_BIT,\r\n0);\r\nmax310x_wait_pll(s);\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn uart_resume_port(&s->uart, &s->port);\r\n}\r\nstatic int max310x_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned int val = 0;\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_read(s->regmap, MAX310X_GPIODATA_REG, &val);\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn !!((val >> 4) & (1 << offset));\r\n}\r\nstatic void max310x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_update_bits(s->regmap, MAX310X_GPIODATA_REG, 1 << offset, value ?\r\n1 << offset : 0);\r\nmutex_unlock(&s->max310x_mutex);\r\n}\r\nstatic int max310x_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_update_bits(s->regmap, MAX310X_GPIOCFG_REG, 1 << offset, 0);\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn 0;\r\n}\r\nstatic int max310x_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nmutex_lock(&s->max310x_mutex);\r\nregmap_update_bits(s->regmap, MAX310X_GPIOCFG_REG, 1 << offset,\r\n1 << offset);\r\nregmap_update_bits(s->regmap, MAX310X_GPIODATA_REG, 1 << offset, value ?\r\n1 << offset : 0);\r\nmutex_unlock(&s->max310x_mutex);\r\nreturn 0;\r\n}\r\nstatic int max310x_probe(struct spi_device *spi)\r\n{\r\nstruct max310x_port *s;\r\nstruct device *dev = &spi->dev;\r\nint chiptype = spi_get_device_id(spi)->driver_data;\r\nstruct max310x_pdata *pdata = dev->platform_data;\r\nunsigned int val = 0;\r\nint ret;\r\nif (spi->irq <= 0) {\r\ndev_err(dev, "No IRQ specified\n");\r\nreturn -ENOTSUPP;\r\n}\r\ns = devm_kzalloc(dev, sizeof(struct max310x_port), GFP_KERNEL);\r\nif (!s) {\r\ndev_err(dev, "Error allocating port structure\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_set_drvdata(dev, s);\r\nif (!pdata) {\r\ndev_warn(dev, "No platform data supplied, using defaults\n");\r\npdata = &generic_plat_data;\r\n}\r\ns->pdata = pdata;\r\nswitch (chiptype) {\r\ncase MAX310X_TYPE_MAX3107:\r\ns->name = "MAX3107";\r\ns->nr_gpio = 4;\r\ns->uart.nr = 1;\r\ns->regcfg.max_register = 0x1f;\r\nbreak;\r\ncase MAX310X_TYPE_MAX3108:\r\ns->name = "MAX3108";\r\ns->nr_gpio = 4;\r\ns->uart.nr = 1;\r\ns->regcfg.max_register = 0x1e;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unsupported chip type %i\n", chiptype);\r\nreturn -ENOTSUPP;\r\n}\r\nif ((pdata->driver_flags & MAX310X_EXT_CLK) &&\r\n((pdata->frequency < 500000) || (pdata->frequency > 35000000)))\r\ngoto err_freq;\r\nif (!(pdata->driver_flags & MAX310X_EXT_CLK) &&\r\n((pdata->frequency < 1000000) || (pdata->frequency > 4000000)))\r\ngoto err_freq;\r\nmutex_init(&s->max310x_mutex);\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nspi->max_speed_hz = 26000000;\r\nspi_setup(spi);\r\ns->regcfg.reg_bits = 8;\r\ns->regcfg.val_bits = 8;\r\ns->regcfg.read_flag_mask = 0x00;\r\ns->regcfg.write_flag_mask = 0x80;\r\ns->regcfg.cache_type = REGCACHE_RBTREE;\r\ns->regcfg.writeable_reg = max3107_8_reg_writeable;\r\ns->regcfg.volatile_reg = max310x_reg_volatile;\r\ns->regcfg.precious_reg = max310x_reg_precious;\r\ns->regmap = devm_regmap_init_spi(spi, &s->regcfg);\r\nif (IS_ERR(s->regmap)) {\r\nret = PTR_ERR(s->regmap);\r\ndev_err(dev, "Failed to initialize register map\n");\r\ngoto err_out;\r\n}\r\nret = regmap_write(s->regmap, MAX310X_MODE2_REG, MAX310X_MODE2_RST_BIT);\r\nif (ret) {\r\ndev_err(dev, "SPI transfer failed\n");\r\ngoto err_out;\r\n}\r\nregmap_write(s->regmap, MAX310X_MODE2_REG, 0);\r\nswitch (chiptype) {\r\ncase MAX310X_TYPE_MAX3107:\r\nregmap_read(s->regmap, MAX3107_REVID_REG, &val);\r\nif (((val & MAX3107_REV_MASK) != MAX3107_REV_ID)) {\r\ndev_err(dev, "%s ID 0x%02x does not match\n",\r\ns->name, val);\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\nbreak;\r\ncase MAX310X_TYPE_MAX3108:\r\nregmap_read(s->regmap, MAX310X_CLKSRC_REG, &val);\r\nif (val != (MAX310X_CLKSRC_EXTCLK_BIT |\r\nMAX310X_CLKSRC_PLLBYP_BIT)) {\r\ndev_err(dev, "%s not present\n", s->name);\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\nbreak;\r\n}\r\nif (pdata->init)\r\npdata->init();\r\nif (pdata->suspend)\r\npdata->suspend(0);\r\ns->uartclk = max310x_set_ref_clk(s);\r\nregmap_write(s->regmap, MAX310X_IRQEN_REG, 0);\r\nval = MAX310X_MODE1_IRQSEL_BIT;\r\nif (pdata->driver_flags & MAX310X_AUTOSLEEP)\r\nval = MAX310X_MODE1_AUTOSLEEP_BIT;\r\nregmap_write(s->regmap, MAX310X_MODE1_REG, val);\r\nret = devm_request_threaded_irq(dev, spi->irq, NULL, max310x_ist,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(dev), s);\r\nif (ret) {\r\ndev_err(dev, "Unable to reguest IRQ %i\n", spi->irq);\r\ngoto err_out;\r\n}\r\ns->uart.owner = THIS_MODULE;\r\ns->uart.driver_name = dev_name(dev);\r\ns->uart.dev_name = "ttyMAX";\r\ns->uart.major = MAX310X_MAJOR;\r\ns->uart.minor = MAX310X_MINOR;\r\nret = uart_register_driver(&s->uart);\r\nif (ret) {\r\ndev_err(dev, "Registering UART driver failed\n");\r\ngoto err_out;\r\n}\r\ns->wq = create_freezable_workqueue(dev_name(dev));\r\nINIT_WORK(&s->tx_work, max310x_wq_proc);\r\ns->port.line = 0;\r\ns->port.dev = dev;\r\ns->port.irq = spi->irq;\r\ns->port.type = PORT_MAX310X;\r\ns->port.fifosize = MAX310X_FIFO_SIZE;\r\ns->port.flags = UPF_SKIP_TEST | UPF_FIXED_TYPE;\r\ns->port.iotype = UPIO_PORT;\r\ns->port.membase = (void __iomem *)0xffffffff;\r\ns->port.uartclk = s->uartclk;\r\ns->port.ops = &max310x_ops;\r\nuart_add_one_port(&s->uart, &s->port);\r\n#ifdef CONFIG_GPIOLIB\r\nif (pdata->gpio_base) {\r\ns->gpio.owner = THIS_MODULE;\r\ns->gpio.dev = dev;\r\ns->gpio.label = dev_name(dev);\r\ns->gpio.direction_input = max310x_gpio_direction_input;\r\ns->gpio.get = max310x_gpio_get;\r\ns->gpio.direction_output= max310x_gpio_direction_output;\r\ns->gpio.set = max310x_gpio_set;\r\ns->gpio.base = pdata->gpio_base;\r\ns->gpio.ngpio = s->nr_gpio;\r\ns->gpio.can_sleep = 1;\r\nif (gpiochip_add(&s->gpio)) {\r\ns->gpio.base = 0;\r\n}\r\n} else\r\ndev_info(dev, "GPIO support not enabled\n");\r\n#endif\r\nif (pdata->suspend)\r\npdata->suspend(1);\r\nreturn 0;\r\nerr_freq:\r\ndev_err(dev, "Frequency parameter incorrect\n");\r\nret = -EINVAL;\r\nerr_out:\r\ndev_set_drvdata(dev, NULL);\r\nreturn ret;\r\n}\r\nstatic int max310x_remove(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nint ret = 0;\r\ndev_dbg(dev, "Removing port\n");\r\ndevm_free_irq(dev, s->port.irq, s);\r\ndestroy_workqueue(s->wq);\r\nuart_remove_one_port(&s->uart, &s->port);\r\nuart_unregister_driver(&s->uart);\r\n#ifdef CONFIG_GPIOLIB\r\nif (s->pdata->gpio_base) {\r\nret = gpiochip_remove(&s->gpio);\r\nif (ret)\r\ndev_err(dev, "Failed to remove gpio chip: %d\n", ret);\r\n}\r\n#endif\r\ndev_set_drvdata(dev, NULL);\r\nif (s->pdata->suspend)\r\ns->pdata->suspend(1);\r\nif (s->pdata->exit)\r\ns->pdata->exit();\r\nreturn ret;\r\n}
