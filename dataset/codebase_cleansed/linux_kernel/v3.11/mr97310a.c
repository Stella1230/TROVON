static int mr_write(struct gspca_dev *gspca_dev, int len)\r\n{\r\nint rc;\r\nrc = usb_bulk_msg(gspca_dev->dev,\r\nusb_sndbulkpipe(gspca_dev->dev, 4),\r\ngspca_dev->usb_buf, len, NULL, 500);\r\nif (rc < 0)\r\npr_err("reg write [%02x] error %d\n",\r\ngspca_dev->usb_buf[0], rc);\r\nreturn rc;\r\n}\r\nstatic int mr_read(struct gspca_dev *gspca_dev, int len)\r\n{\r\nint rc;\r\nrc = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 3),\r\ngspca_dev->usb_buf, len, NULL, 500);\r\nif (rc < 0)\r\npr_err("reg read [%02x] error %d\n",\r\ngspca_dev->usb_buf[0], rc);\r\nreturn rc;\r\n}\r\nstatic int sensor_write_reg(struct gspca_dev *gspca_dev, u8 reg, u8 flags,\r\nconst u8 *data, int len)\r\n{\r\ngspca_dev->usb_buf[0] = 0x1f;\r\ngspca_dev->usb_buf[1] = flags;\r\ngspca_dev->usb_buf[2] = reg;\r\nmemcpy(gspca_dev->usb_buf + 3, data, len);\r\nreturn mr_write(gspca_dev, len + 3);\r\n}\r\nstatic int sensor_write_regs(struct gspca_dev *gspca_dev,\r\nconst struct sensor_w_data *data, int len)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < len; i++) {\r\nrc = sensor_write_reg(gspca_dev, data[i].reg, data[i].flags,\r\ndata[i].data, data[i].len);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sensor_write1(struct gspca_dev *gspca_dev, u8 reg, u8 data)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 buf, confirm_reg;\r\nint rc;\r\nbuf = data;\r\nif (sd->cam_type == CAM_TYPE_CIF) {\r\nrc = sensor_write_reg(gspca_dev, reg, 0x01, &buf, 1);\r\nconfirm_reg = sd->sensor_type ? 0x13 : 0x11;\r\n} else {\r\nrc = sensor_write_reg(gspca_dev, reg, 0x00, &buf, 1);\r\nconfirm_reg = 0x11;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\nbuf = 0x01;\r\nrc = sensor_write_reg(gspca_dev, confirm_reg, 0x00, &buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int cam_get_response16(struct gspca_dev *gspca_dev, u8 reg, int verbose)\r\n{\r\nint err_code;\r\ngspca_dev->usb_buf[0] = reg;\r\nerr_code = mr_write(gspca_dev, 1);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = mr_read(gspca_dev, 16);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (verbose)\r\nPDEBUG(D_PROBE, "Register: %02x reads %02x%02x%02x", reg,\r\ngspca_dev->usb_buf[0],\r\ngspca_dev->usb_buf[1],\r\ngspca_dev->usb_buf[2]);\r\nreturn 0;\r\n}\r\nstatic int zero_the_pointer(struct gspca_dev *gspca_dev)\r\n{\r\n__u8 *data = gspca_dev->usb_buf;\r\nint err_code;\r\nu8 status = 0;\r\nint tries = 0;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0x51;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0xba;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nif (err_code < 0)\r\nreturn err_code;\r\ndata[0] = 0x19;\r\ndata[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nwhile (status != 0x0a && tries < 256) {\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nstatus = data[0];\r\ntries++;\r\nif (err_code < 0)\r\nreturn err_code;\r\n}\r\nif (status != 0x0a)\r\nPERR("status is %02x", status);\r\ntries = 0;\r\nwhile (tries < 4) {\r\ndata[0] = 0x19;\r\ndata[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x21, 0);\r\nstatus = data[0];\r\ntries++;\r\nif (err_code < 0)\r\nreturn err_code;\r\n}\r\ndata[0] = 0x19;\r\nerr_code = mr_write(gspca_dev, 1);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = mr_read(gspca_dev, 16);\r\nif (err_code < 0)\r\nreturn err_code;\r\nreturn 0;\r\n}\r\nstatic int stream_start(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x01;\r\ngspca_dev->usb_buf[1] = 0x01;\r\nreturn mr_write(gspca_dev, 2);\r\n}\r\nstatic void stream_stop(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x01;\r\ngspca_dev->usb_buf[1] = 0x00;\r\nif (mr_write(gspca_dev, 2) < 0)\r\nPERR("Stream Stop failed");\r\n}\r\nstatic void lcd_stop(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x19;\r\ngspca_dev->usb_buf[1] = 0x54;\r\nif (mr_write(gspca_dev, 2) < 0)\r\nPERR("LCD Stop failed");\r\n}\r\nstatic int isoc_enable(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->usb_buf[0] = 0x00;\r\ngspca_dev->usb_buf[1] = 0x4d;\r\nreturn mr_write(gspca_dev, 2);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nint err_code;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nsd->do_lcd_stop = 0;\r\nerr_code = zero_the_pointer(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = stream_start(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = cam_get_response16(gspca_dev, 0x07, 1);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (id->idProduct == 0x0110 || id->idProduct == 0x010e) {\r\nsd->cam_type = CAM_TYPE_CIF;\r\ncam->nmodes--;\r\nswitch (gspca_dev->usb_buf[0]) {\r\ncase 2:\r\nsd->sensor_type = 0;\r\nbreak;\r\ncase 3:\r\nsd->sensor_type = 1;\r\nbreak;\r\ndefault:\r\npr_err("Unknown CIF Sensor id : %02x\n",\r\ngspca_dev->usb_buf[1]);\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "MR97310A CIF camera detected, sensor: %d",\r\nsd->sensor_type);\r\n} else {\r\nsd->cam_type = CAM_TYPE_VGA;\r\nsd->sensor_type = 1;\r\nsd->do_lcd_stop = 0;\r\nsd->adj_colors = 0;\r\nif (gspca_dev->usb_buf[0] == 0x01) {\r\nsd->sensor_type = 2;\r\n} else if ((gspca_dev->usb_buf[0] != 0x03) &&\r\n(gspca_dev->usb_buf[0] != 0x04)) {\r\npr_err("Unknown VGA Sensor id Byte 0: %02x\n",\r\ngspca_dev->usb_buf[0]);\r\npr_err("Defaults assumed, may not work\n");\r\npr_err("Please report this\n");\r\n}\r\nif ((gspca_dev->usb_buf[0] == 0x03) &&\r\n(gspca_dev->usb_buf[1] == 0x50))\r\nsd->adj_colors = 1;\r\nif (gspca_dev->usb_buf[0] == 0x04) {\r\nsd->do_lcd_stop = 1;\r\nswitch (gspca_dev->usb_buf[1]) {\r\ncase 0x50:\r\nsd->sensor_type = 0;\r\nPDEBUG(D_PROBE, "sensor_type corrected to 0");\r\nbreak;\r\ncase 0x20:\r\nbreak;\r\ndefault:\r\npr_err("Unknown VGA Sensor id Byte 1: %02x\n",\r\ngspca_dev->usb_buf[1]);\r\npr_err("Defaults assumed, may not work\n");\r\npr_err("Please report this\n");\r\n}\r\n}\r\nPDEBUG(D_PROBE, "MR97310A VGA camera detected, sensor: %d",\r\nsd->sensor_type);\r\n}\r\nsd_stopN(gspca_dev);\r\nif (force_sensor_type != -1) {\r\nsd->sensor_type = !!force_sensor_type;\r\nPDEBUG(D_PROBE, "Forcing sensor type to: %d",\r\nsd->sensor_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int start_cif_cam(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 *data = gspca_dev->usb_buf;\r\nint err_code;\r\nstatic const __u8 startup_string[] = {\r\n0x00,\r\n0x0d,\r\n0x01,\r\n0x00,\r\n0x00,\r\n0x13,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x50,\r\n0xc0\r\n};\r\nmemcpy(data, startup_string, 11);\r\nif (sd->sensor_type)\r\ndata[5] = 0xbb;\r\nswitch (gspca_dev->width) {\r\ncase 160:\r\ndata[9] |= 0x04;\r\ncase 320:\r\ndefault:\r\ndata[3] = 0x28;\r\ndata[4] = 0x3c;\r\ndata[6] = 0x14;\r\ndata[8] = 0x1a + sd->sensor_type;\r\nbreak;\r\ncase 176:\r\ndata[9] |= 0x04;\r\ncase 352:\r\ndata[3] = 0x2c;\r\ndata[4] = 0x48;\r\ndata[6] = 0x06;\r\ndata[8] = 0x06 - sd->sensor_type;\r\nbreak;\r\n}\r\nerr_code = mr_write(gspca_dev, 11);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (!sd->sensor_type) {\r\nstatic const struct sensor_w_data cif_sensor0_init_data[] = {\r\n{0x02, 0x00, {0x03, 0x5a, 0xb5, 0x01,\r\n0x0f, 0x14, 0x0f, 0x10}, 8},\r\n{0x0c, 0x00, {0x04, 0x01, 0x01, 0x00, 0x1f}, 5},\r\n{0x12, 0x00, {0x07}, 1},\r\n{0x1f, 0x00, {0x06}, 1},\r\n{0x27, 0x00, {0x04}, 1},\r\n{0x29, 0x00, {0x0c}, 1},\r\n{0x40, 0x00, {0x40, 0x00, 0x04}, 3},\r\n{0x50, 0x00, {0x60}, 1},\r\n{0x60, 0x00, {0x06}, 1},\r\n{0x6b, 0x00, {0x85, 0x85, 0xc8, 0xc8, 0xc8, 0xc8}, 6},\r\n{0x72, 0x00, {0x1e, 0x56}, 2},\r\n{0x75, 0x00, {0x58, 0x40, 0xa2, 0x02, 0x31, 0x02,\r\n0x31, 0x80, 0x00}, 9},\r\n{0x11, 0x00, {0x01}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\nerr_code = sensor_write_regs(gspca_dev, cif_sensor0_init_data,\r\nARRAY_SIZE(cif_sensor0_init_data));\r\n} else {\r\nstatic const struct sensor_w_data cif_sensor1_init_data[] = {\r\n{0x02, 0x00, {0x10}, 1},\r\n{0x05, 0x01, {0x22}, 1},\r\n{0x06, 0x01, {0x00}, 1},\r\n{0x09, 0x02, {0x0e}, 1},\r\n{0x0a, 0x02, {0x05}, 1},\r\n{0x0b, 0x02, {0x05}, 1},\r\n{0x0c, 0x02, {0x0f}, 1},\r\n{0x0d, 0x02, {0x07}, 1},\r\n{0x0e, 0x02, {0x0c}, 1},\r\n{0x0f, 0x00, {0x00}, 1},\r\n{0x10, 0x00, {0x06}, 1},\r\n{0x11, 0x00, {0x07}, 1},\r\n{0x12, 0x00, {0x00}, 1},\r\n{0x13, 0x00, {0x01}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\ngspca_dev->usb_buf[0] = 0x0a;\r\ngspca_dev->usb_buf[1] = 0x00;\r\nerr_code = mr_write(gspca_dev, 2);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = sensor_write_regs(gspca_dev, cif_sensor1_init_data,\r\nARRAY_SIZE(cif_sensor1_init_data));\r\n}\r\nreturn err_code;\r\n}\r\nstatic int start_vga_cam(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 *data = gspca_dev->usb_buf;\r\nint err_code;\r\nstatic const __u8 startup_string[] =\r\n{0x00, 0x0d, 0x01, 0x00, 0x00, 0x2b, 0x00, 0x00,\r\n0x00, 0x50, 0xc0};\r\nmemcpy(data, startup_string, 11);\r\nif (!sd->sensor_type) {\r\ndata[5] = 0x00;\r\ndata[10] = 0x91;\r\n}\r\nif (sd->sensor_type == 2) {\r\ndata[5] = 0x00;\r\ndata[10] = 0x18;\r\n}\r\nswitch (gspca_dev->width) {\r\ncase 160:\r\ndata[9] |= 0x0c;\r\ncase 320:\r\ndata[9] |= 0x04;\r\ncase 640:\r\ndefault:\r\ndata[3] = 0x50;\r\ndata[4] = 0x78;\r\ndata[6] = 0x04;\r\ndata[8] = 0x03;\r\nif (sd->sensor_type == 2) {\r\ndata[6] = 2;\r\ndata[8] = 1;\r\n}\r\nif (sd->do_lcd_stop)\r\ndata[8] = 0x04;\r\nbreak;\r\ncase 176:\r\ndata[9] |= 0x04;\r\ncase 352:\r\ndata[3] = 0x2c;\r\ndata[4] = 0x48;\r\ndata[6] = 0x94;\r\ndata[8] = 0x63;\r\nif (sd->do_lcd_stop)\r\ndata[8] = 0x64;\r\nbreak;\r\n}\r\nerr_code = mr_write(gspca_dev, 11);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (!sd->sensor_type) {\r\nstatic const struct sensor_w_data vga_sensor0_init_data[] = {\r\n{0x01, 0x00, {0x0c, 0x00, 0x04}, 3},\r\n{0x14, 0x00, {0x01, 0xe4, 0x02, 0x84}, 4},\r\n{0x20, 0x00, {0x00, 0x80, 0x00, 0x08}, 4},\r\n{0x25, 0x00, {0x03, 0xa9, 0x80}, 3},\r\n{0x30, 0x00, {0x30, 0x18, 0x10, 0x18}, 4},\r\n{0, 0, {0}, 0}\r\n};\r\nerr_code = sensor_write_regs(gspca_dev, vga_sensor0_init_data,\r\nARRAY_SIZE(vga_sensor0_init_data));\r\n} else if (sd->sensor_type == 1) {\r\nstatic const struct sensor_w_data color_adj[] = {\r\n{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,\r\n0x05, 0x01, 0x04}, 8}\r\n};\r\nstatic const struct sensor_w_data color_no_adj[] = {\r\n{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,\r\n0x07, 0x00, 0x01}, 8}\r\n};\r\nstatic const struct sensor_w_data vga_sensor1_init_data[] = {\r\n{0x11, 0x04, {0x01}, 1},\r\n{0x0a, 0x00, {0x00, 0x01, 0x00, 0x00, 0x01,\r\n0x00, 0x0a}, 7},\r\n{0x11, 0x04, {0x01}, 1},\r\n{0x12, 0x00, {0x00, 0x63, 0x00, 0x70, 0x00, 0x00}, 6},\r\n{0x11, 0x04, {0x01}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\nif (sd->adj_colors)\r\nerr_code = sensor_write_regs(gspca_dev, color_adj,\r\nARRAY_SIZE(color_adj));\r\nelse\r\nerr_code = sensor_write_regs(gspca_dev, color_no_adj,\r\nARRAY_SIZE(color_no_adj));\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = sensor_write_regs(gspca_dev, vga_sensor1_init_data,\r\nARRAY_SIZE(vga_sensor1_init_data));\r\n} else {\r\nstatic const struct sensor_w_data vga_sensor2_init_data[] = {\r\n{0x01, 0x00, {0x48}, 1},\r\n{0x02, 0x00, {0x22}, 1},\r\n{0x05, 0x00, {0x10}, 1},\r\n{0x06, 0x00, {0x00}, 1},\r\n{0x07, 0x00, {0x00}, 1},\r\n{0x08, 0x00, {0x00}, 1},\r\n{0x09, 0x00, {0x00}, 1},\r\n{0x12, 0x00, {0x00}, 1},\r\n{0x13, 0x00, {0x04}, 1},\r\n{0x14, 0x00, {0x00}, 1},\r\n{0x15, 0x00, {0x06}, 1},\r\n{0x16, 0x00, {0x01}, 1},\r\n{0x17, 0x00, {0xe2}, 1},\r\n{0x18, 0x00, {0x02}, 1},\r\n{0x19, 0x00, {0x82}, 1},\r\n{0x1a, 0x00, {0x00}, 1},\r\n{0x1b, 0x00, {0x20}, 1},\r\n{0x1d, 0x00, {0x80}, 1},\r\n{0x1e, 0x00, {0x08}, 1},\r\n{0x1f, 0x00, {0x0c}, 1},\r\n{0x20, 0x00, {0x00}, 1},\r\n{0, 0, {0}, 0}\r\n};\r\nerr_code = sensor_write_regs(gspca_dev, vga_sensor2_init_data,\r\nARRAY_SIZE(vga_sensor2_init_data));\r\n}\r\nreturn err_code;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err_code;\r\nsd->sof_read = 0;\r\nerr_code = zero_the_pointer(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nerr_code = stream_start(gspca_dev);\r\nif (err_code < 0)\r\nreturn err_code;\r\nif (sd->cam_type == CAM_TYPE_CIF) {\r\nerr_code = start_cif_cam(gspca_dev);\r\n} else {\r\nerr_code = start_vga_cam(gspca_dev);\r\n}\r\nif (err_code < 0)\r\nreturn err_code;\r\nreturn isoc_enable(gspca_dev);\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstream_stop(gspca_dev);\r\nzero_the_pointer(gspca_dev);\r\nif (sd->do_lcd_stop)\r\nlcd_stop(gspca_dev);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 sign_reg = 7;\r\nu8 value_reg = 8;\r\nstatic const u8 quick_clix_table[] =\r\n{ 0, 4, 8, 12, 1, 2, 3, 5, 6, 9, 7, 10, 13, 11, 14, 15};\r\nif (sd->cam_type == CAM_TYPE_VGA) {\r\nsign_reg += 4;\r\nvalue_reg += 4;\r\n}\r\nif (val > 0) {\r\nsensor_write1(gspca_dev, sign_reg, 0x00);\r\n} else {\r\nsensor_write1(gspca_dev, sign_reg, 0x01);\r\nval = 257 - val;\r\n}\r\nif (sd->do_lcd_stop)\r\nval = quick_clix_table[val];\r\nsensor_write1(gspca_dev, value_reg, val);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 expo, s32 min_clockdiv)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint exposure = MR97310A_EXPOSURE_DEFAULT;\r\nu8 buf[2];\r\nif (sd->cam_type == CAM_TYPE_CIF && sd->sensor_type == 1) {\r\nexposure = (expo * 9267) / 10000 + 300;\r\nsensor_write1(gspca_dev, 3, exposure >> 4);\r\nsensor_write1(gspca_dev, 4, exposure & 0x0f);\r\n} else if (sd->sensor_type == 2) {\r\nexposure = expo;\r\nexposure >>= 3;\r\nsensor_write1(gspca_dev, 3, exposure >> 8);\r\nsensor_write1(gspca_dev, 4, exposure & 0xff);\r\n} else {\r\nu8 clockdiv = (60 * expo + 7999) / 8000;\r\nif (clockdiv < min_clockdiv && gspca_dev->width >= 320)\r\nclockdiv = min_clockdiv;\r\nelse if (clockdiv < 2)\r\nclockdiv = 2;\r\nif (sd->cam_type == CAM_TYPE_VGA && clockdiv < 4)\r\nclockdiv = 4;\r\nexposure = (60 * 511 * expo) / (8000 * clockdiv);\r\nif (exposure > 511)\r\nexposure = 511;\r\nexposure = 511 - exposure;\r\nbuf[0] = exposure & 0xff;\r\nbuf[1] = exposure >> 8;\r\nsensor_write_reg(gspca_dev, 0x0e, 0, buf, 2);\r\nsensor_write1(gspca_dev, 0x02, clockdiv);\r\n}\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gainreg;\r\nif (sd->cam_type == CAM_TYPE_CIF && sd->sensor_type == 1)\r\nsensor_write1(gspca_dev, 0x0e, val);\r\nelse if (sd->cam_type == CAM_TYPE_VGA && sd->sensor_type == 2)\r\nfor (gainreg = 0x0a; gainreg < 0x11; gainreg += 2) {\r\nsensor_write1(gspca_dev, gainreg, val >> 8);\r\nsensor_write1(gspca_dev, gainreg + 1, val & 0xff);\r\n}\r\nelse\r\nsensor_write1(gspca_dev, 0x10, val);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nsensor_write1(gspca_dev, 0x1c, val);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nsetexposure(gspca_dev, sd->exposure->val,\r\nsd->min_clockdiv ? sd->min_clockdiv->val : 0);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nsetgain(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\nstatic const struct v4l2_ctrl_config clockdiv = {\r\n.ops = &sd_ctrl_ops,\r\n.id = MR97310A_CID_CLOCKDIV,\r\n.type = V4L2_CTRL_TYPE_INTEGER,\r\n.name = "Minimum Clock Divider",\r\n.min = MR97310A_MIN_CLOCKDIV_MIN,\r\n.max = MR97310A_MIN_CLOCKDIV_MAX,\r\n.step = 1,\r\n.def = MR97310A_MIN_CLOCKDIV_DEFAULT,\r\n};\r\nbool has_brightness = false;\r\nbool has_argus_brightness = false;\r\nbool has_contrast = false;\r\nbool has_gain = false;\r\nbool has_cs_gain = false;\r\nbool has_exposure = false;\r\nbool has_clockdiv = false;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nif (sd->cam_type == CAM_TYPE_CIF) {\r\nif (sd->sensor_type == 0)\r\nhas_exposure = has_gain = has_clockdiv = true;\r\nelse\r\nhas_exposure = has_gain = has_brightness = true;\r\n} else {\r\nif (sd->sensor_type == 0)\r\n;\r\nelse if (sd->sensor_type == 2)\r\nhas_exposure = has_cs_gain = has_contrast = true;\r\nelse if (sd->do_lcd_stop)\r\nhas_exposure = has_gain = has_argus_brightness =\r\nhas_clockdiv = true;\r\nelse\r\nhas_exposure = has_gain = has_brightness =\r\nhas_clockdiv = true;\r\n}\r\nif (has_brightness)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -254, 255, 1,\r\nMR97310A_BRIGHTNESS_DEFAULT);\r\nelse if (has_argus_brightness)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 15, 1,\r\nMR97310A_BRIGHTNESS_DEFAULT);\r\nif (has_contrast)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, MR97310A_CONTRAST_MIN,\r\nMR97310A_CONTRAST_MAX, 1, MR97310A_CONTRAST_DEFAULT);\r\nif (has_gain)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, MR97310A_GAIN_MIN, MR97310A_GAIN_MAX,\r\n1, MR97310A_GAIN_DEFAULT);\r\nelse if (has_cs_gain)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops, V4L2_CID_GAIN,\r\nMR97310A_CS_GAIN_MIN, MR97310A_CS_GAIN_MAX,\r\n1, MR97310A_CS_GAIN_DEFAULT);\r\nif (has_exposure)\r\nsd->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, MR97310A_EXPOSURE_MIN,\r\nMR97310A_EXPOSURE_MAX, 1, MR97310A_EXPOSURE_DEFAULT);\r\nif (has_clockdiv)\r\nsd->min_clockdiv = v4l2_ctrl_new_custom(hdl, &clockdiv, NULL);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nif (has_exposure && has_clockdiv)\r\nv4l2_ctrl_cluster(2, &sd->exposure);\r\nreturn 0;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned char *sof;\r\nsof = pac_find_sof(gspca_dev, &sd->sof_read, data, len);\r\nif (sof) {\r\nint n;\r\nn = sof - data;\r\nif (n > sizeof pac_sof_marker)\r\nn -= sizeof pac_sof_marker;\r\nelse\r\nn = 0;\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, n);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\npac_sof_marker, sizeof pac_sof_marker);\r\nlen -= sof - data;\r\ndata = sof;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
