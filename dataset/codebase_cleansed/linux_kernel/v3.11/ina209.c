static struct ina209_data *ina209_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ina209_data *data = i2c_get_clientdata(client);\r\nstruct ina209_data *ret = data;\r\ns32 val;\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (!data->valid ||\r\ntime_after(jiffies, data->last_updated + data->update_interval)) {\r\nfor (i = 0; i < ARRAY_SIZE(data->regs); i++) {\r\nval = i2c_smbus_read_word_swapped(client, i);\r\nif (val < 0) {\r\nret = ERR_PTR(val);\r\ngoto abort;\r\n}\r\ndata->regs[i] = val;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic long ina209_from_reg(const u8 reg, const u16 val)\r\n{\r\nswitch (reg) {\r\ncase INA209_SHUNT_VOLTAGE:\r\ncase INA209_SHUNT_VOLTAGE_POS_PEAK:\r\ncase INA209_SHUNT_VOLTAGE_NEG_PEAK:\r\ncase INA209_SHUNT_VOLTAGE_POS_WARN:\r\ncase INA209_SHUNT_VOLTAGE_NEG_WARN:\r\nreturn DIV_ROUND_CLOSEST(val, 100);\r\ncase INA209_BUS_VOLTAGE:\r\ncase INA209_BUS_VOLTAGE_MAX_PEAK:\r\ncase INA209_BUS_VOLTAGE_MIN_PEAK:\r\ncase INA209_BUS_VOLTAGE_OVER_WARN:\r\ncase INA209_BUS_VOLTAGE_UNDER_WARN:\r\ncase INA209_BUS_VOLTAGE_OVER_LIMIT:\r\ncase INA209_BUS_VOLTAGE_UNDER_LIMIT:\r\nreturn (val >> 3) * 4;\r\ncase INA209_CRITICAL_DAC_POS:\r\nreturn val >> 8;\r\ncase INA209_CRITICAL_DAC_NEG:\r\nreturn -1 * (val >> 8);\r\ncase INA209_POWER:\r\ncase INA209_POWER_PEAK:\r\ncase INA209_POWER_WARN:\r\ncase INA209_POWER_OVER_LIMIT:\r\nreturn val * 20 * 1000L;\r\ncase INA209_CURRENT:\r\nreturn val;\r\n}\r\nWARN_ON_ONCE(1);\r\nreturn 0;\r\n}\r\nstatic int ina209_to_reg(u8 reg, u16 old, long val)\r\n{\r\nswitch (reg) {\r\ncase INA209_SHUNT_VOLTAGE_POS_WARN:\r\ncase INA209_SHUNT_VOLTAGE_NEG_WARN:\r\nreturn clamp_val(val, -320, 320) * 100;\r\ncase INA209_BUS_VOLTAGE_OVER_WARN:\r\ncase INA209_BUS_VOLTAGE_UNDER_WARN:\r\ncase INA209_BUS_VOLTAGE_OVER_LIMIT:\r\ncase INA209_BUS_VOLTAGE_UNDER_LIMIT:\r\nreturn (DIV_ROUND_CLOSEST(clamp_val(val, 0, 32000), 4) << 3)\r\n| (old & 0x7);\r\ncase INA209_CRITICAL_DAC_NEG:\r\nreturn (clamp_val(-val, 0, 255) << 8) | (old & 0xff);\r\ncase INA209_CRITICAL_DAC_POS:\r\nreturn (clamp_val(val, 0, 255) << 8) | (old & 0xff);\r\ncase INA209_POWER_WARN:\r\ncase INA209_POWER_OVER_LIMIT:\r\nreturn DIV_ROUND_CLOSEST(val, 20 * 1000);\r\n}\r\nreturn -EACCES;\r\n}\r\nstatic int ina209_interval_from_reg(u16 reg)\r\n{\r\nreturn 68 >> (15 - ((reg >> 3) & 0x0f));\r\n}\r\nstatic u16 ina209_reg_from_interval(u16 config, long interval)\r\n{\r\nint i, adc;\r\nif (interval <= 0) {\r\nadc = 8;\r\n} else {\r\nadc = 15;\r\nfor (i = 34 + 34 / 2; i; i >>= 1) {\r\nif (i < interval)\r\nbreak;\r\nadc--;\r\n}\r\n}\r\nreturn (config & 0xf807) | (adc << 3) | (adc << 7);\r\n}\r\nstatic ssize_t ina209_set_interval(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ina209_data *data = ina209_update_device(dev);\r\nlong val;\r\nu16 regval;\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nret = kstrtol(buf, 10, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\nregval = ina209_reg_from_interval(data->regs[INA209_CONFIGURATION],\r\nval);\r\ni2c_smbus_write_word_swapped(client, INA209_CONFIGURATION, regval);\r\ndata->regs[INA209_CONFIGURATION] = regval;\r\ndata->update_interval = ina209_interval_from_reg(regval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t ina209_show_interval(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ina209_data *data = i2c_get_clientdata(client);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", data->update_interval);\r\n}\r\nstatic ssize_t ina209_reset_history(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ina209_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nu32 mask = attr->index;\r\nlong val;\r\nint i, ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\nfor (i = 0; i < ARRAY_SIZE(ina209_reset_history_regs); i++) {\r\nif (mask & (1 << i))\r\ni2c_smbus_write_word_swapped(client,\r\nina209_reset_history_regs[i], 1);\r\n}\r\ndata->valid = false;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t ina209_set_value(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ina209_data *data = ina209_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nint reg = attr->index;\r\nlong val;\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nret = kstrtol(buf, 10, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\nret = ina209_to_reg(reg, data->regs[reg], val);\r\nif (ret < 0) {\r\ncount = ret;\r\ngoto abort;\r\n}\r\ni2c_smbus_write_word_swapped(client, reg, ret);\r\ndata->regs[reg] = ret;\r\nabort:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t ina209_show_value(struct device *dev,\r\nstruct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct ina209_data *data = ina209_update_device(dev);\r\nlong val;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nval = ina209_from_reg(attr->index, data->regs[attr->index]);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", val);\r\n}\r\nstatic ssize_t ina209_show_alarm(struct device *dev,\r\nstruct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct ina209_data *data = ina209_update_device(dev);\r\nconst unsigned int mask = attr->index;\r\nu16 status;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nstatus = data->regs[INA209_STATUS];\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", !!(status & mask));\r\n}\r\nstatic void ina209_restore_conf(struct i2c_client *client,\r\nstruct ina209_data *data)\r\n{\r\ni2c_smbus_write_word_swapped(client, INA209_CONFIGURATION,\r\ndata->config_orig);\r\ni2c_smbus_write_word_swapped(client, INA209_CALIBRATION,\r\ndata->calibration_orig);\r\n}\r\nstatic int ina209_init_client(struct i2c_client *client,\r\nstruct ina209_data *data)\r\n{\r\nstruct ina2xx_platform_data *pdata = dev_get_platdata(&client->dev);\r\nu32 shunt;\r\nint reg;\r\nreg = i2c_smbus_read_word_swapped(client, INA209_CALIBRATION);\r\nif (reg < 0)\r\nreturn reg;\r\ndata->calibration_orig = reg;\r\nreg = i2c_smbus_read_word_swapped(client, INA209_CONFIGURATION);\r\nif (reg < 0)\r\nreturn reg;\r\ndata->config_orig = reg;\r\nif (pdata) {\r\nif (pdata->shunt_uohms <= 0)\r\nreturn -EINVAL;\r\nshunt = pdata->shunt_uohms;\r\n} else if (!of_property_read_u32(client->dev.of_node, "shunt-resistor",\r\n&shunt)) {\r\nif (shunt == 0)\r\nreturn -EINVAL;\r\n} else {\r\nshunt = data->calibration_orig ?\r\n40960000 / data->calibration_orig : INA209_SHUNT_DEFAULT;\r\n}\r\ni2c_smbus_write_word_swapped(client, INA209_CONFIGURATION,\r\nINA209_CONFIG_DEFAULT);\r\ndata->update_interval = ina209_interval_from_reg(INA209_CONFIG_DEFAULT);\r\ni2c_smbus_write_word_swapped(client, INA209_CALIBRATION,\r\nclamp_val(40960000 / shunt, 1, 65535));\r\ni2c_smbus_read_word_swapped(client, INA209_STATUS);\r\nreturn 0;\r\n}\r\nstatic int ina209_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct ina209_data *data;\r\nint ret;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nret = ina209_init_client(client, data);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&client->dev.kobj, &ina209_group);\r\nif (ret)\r\ngoto out_restore_conf;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto out_hwmon_device_register;\r\n}\r\nreturn 0;\r\nout_hwmon_device_register:\r\nsysfs_remove_group(&client->dev.kobj, &ina209_group);\r\nout_restore_conf:\r\nina209_restore_conf(client, data);\r\nreturn ret;\r\n}\r\nstatic int ina209_remove(struct i2c_client *client)\r\n{\r\nstruct ina209_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &ina209_group);\r\nina209_restore_conf(client, data);\r\nreturn 0;\r\n}
