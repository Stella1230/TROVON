static void cdv_hdmi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct psb_intel_encoder *psb_intel_encoder = to_psb_intel_encoder(encoder);\r\nstruct mid_intel_hdmi_priv *hdmi_priv = psb_intel_encoder->dev_priv;\r\nu32 hdmib;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct psb_intel_crtc *intel_crtc = to_psb_intel_crtc(crtc);\r\nhdmib = (2 << 10);\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nhdmib |= HDMI_VSYNC_ACTIVE_HIGH;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nhdmib |= HDMI_HSYNC_ACTIVE_HIGH;\r\nif (intel_crtc->pipe == 1)\r\nhdmib |= HDMIB_PIPE_B_SELECT;\r\nif (hdmi_priv->has_hdmi_audio) {\r\nhdmib |= HDMI_AUDIO_ENABLE;\r\nhdmib |= HDMI_NULL_PACKETS_DURING_VSYNC;\r\n}\r\nREG_WRITE(hdmi_priv->hdmi_reg, hdmib);\r\nREG_READ(hdmi_priv->hdmi_reg);\r\n}\r\nstatic bool cdv_hdmi_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void cdv_hdmi_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\nto_psb_intel_encoder(encoder);\r\nstruct mid_intel_hdmi_priv *hdmi_priv = psb_intel_encoder->dev_priv;\r\nu32 hdmib;\r\nhdmib = REG_READ(hdmi_priv->hdmi_reg);\r\nif (mode != DRM_MODE_DPMS_ON)\r\nREG_WRITE(hdmi_priv->hdmi_reg, hdmib & ~HDMIB_PORT_EN);\r\nelse\r\nREG_WRITE(hdmi_priv->hdmi_reg, hdmib | HDMIB_PORT_EN);\r\nREG_READ(hdmi_priv->hdmi_reg);\r\n}\r\nstatic void cdv_hdmi_save(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nstruct mid_intel_hdmi_priv *hdmi_priv = psb_intel_encoder->dev_priv;\r\nhdmi_priv->save_HDMIB = REG_READ(hdmi_priv->hdmi_reg);\r\n}\r\nstatic void cdv_hdmi_restore(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nstruct mid_intel_hdmi_priv *hdmi_priv = psb_intel_encoder->dev_priv;\r\nREG_WRITE(hdmi_priv->hdmi_reg, hdmi_priv->save_HDMIB);\r\nREG_READ(hdmi_priv->hdmi_reg);\r\n}\r\nstatic enum drm_connector_status cdv_hdmi_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nstruct mid_intel_hdmi_priv *hdmi_priv = psb_intel_encoder->dev_priv;\r\nstruct edid *edid = NULL;\r\nenum drm_connector_status status = connector_status_disconnected;\r\nedid = drm_get_edid(connector, &psb_intel_encoder->i2c_bus->adapter);\r\nhdmi_priv->has_hdmi_sink = false;\r\nhdmi_priv->has_hdmi_audio = false;\r\nif (edid) {\r\nif (edid->input & DRM_EDID_INPUT_DIGITAL) {\r\nstatus = connector_status_connected;\r\nhdmi_priv->has_hdmi_sink =\r\ndrm_detect_hdmi_monitor(edid);\r\nhdmi_priv->has_hdmi_audio =\r\ndrm_detect_monitor_audio(edid);\r\n}\r\nkfree(edid);\r\n}\r\nreturn status;\r\n}\r\nstatic int cdv_hdmi_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nstruct drm_encoder *encoder = connector->encoder;\r\nif (!strcmp(property->name, "scaling mode") && encoder) {\r\nstruct psb_intel_crtc *crtc = to_psb_intel_crtc(encoder->crtc);\r\nbool centre;\r\nuint64_t curValue;\r\nif (!crtc)\r\nreturn -1;\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\nbreak;\r\ncase DRM_MODE_SCALE_NO_SCALE:\r\nbreak;\r\ncase DRM_MODE_SCALE_ASPECT:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nif (drm_object_property_get_value(&connector->base,\r\nproperty, &curValue))\r\nreturn -1;\r\nif (curValue == value)\r\nreturn 0;\r\nif (drm_object_property_set_value(&connector->base,\r\nproperty, value))\r\nreturn -1;\r\ncentre = (curValue == DRM_MODE_SCALE_NO_SCALE) ||\r\n(value == DRM_MODE_SCALE_NO_SCALE);\r\nif (crtc->saved_mode.hdisplay != 0 &&\r\ncrtc->saved_mode.vdisplay != 0) {\r\nif (centre) {\r\nif (!drm_crtc_helper_set_mode(encoder->crtc, &crtc->saved_mode,\r\nencoder->crtc->x, encoder->crtc->y, encoder->crtc->fb))\r\nreturn -1;\r\n} else {\r\nstruct drm_encoder_helper_funcs *helpers\r\n= encoder->helper_private;\r\nhelpers->mode_set(encoder, &crtc->saved_mode,\r\n&crtc->saved_adjusted_mode);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdv_hdmi_get_modes(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nstruct edid *edid = NULL;\r\nint ret = 0;\r\nedid = drm_get_edid(connector, &psb_intel_encoder->i2c_bus->adapter);\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cdv_hdmi_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock > 165000)\r\nreturn MODE_CLOCK_HIGH;\r\nif (mode->clock < 20000)\r\nreturn MODE_CLOCK_HIGH;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn MODE_NO_INTERLACE;\r\nreturn MODE_OK;\r\n}\r\nstatic void cdv_hdmi_destroy(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nif (psb_intel_encoder->i2c_bus)\r\npsb_intel_i2c_destroy(psb_intel_encoder->i2c_bus);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nvoid cdv_hdmi_init(struct drm_device *dev,\r\nstruct psb_intel_mode_device *mode_dev, int reg)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder;\r\nstruct psb_intel_connector *psb_intel_connector;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct mid_intel_hdmi_priv *hdmi_priv;\r\nint ddc_bus;\r\npsb_intel_encoder = kzalloc(sizeof(struct psb_intel_encoder),\r\nGFP_KERNEL);\r\nif (!psb_intel_encoder)\r\nreturn;\r\npsb_intel_connector = kzalloc(sizeof(struct psb_intel_connector),\r\nGFP_KERNEL);\r\nif (!psb_intel_connector)\r\ngoto err_connector;\r\nhdmi_priv = kzalloc(sizeof(struct mid_intel_hdmi_priv), GFP_KERNEL);\r\nif (!hdmi_priv)\r\ngoto err_priv;\r\nconnector = &psb_intel_connector->base;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nencoder = &psb_intel_encoder->base;\r\ndrm_connector_init(dev, connector,\r\n&cdv_hdmi_connector_funcs,\r\nDRM_MODE_CONNECTOR_DVID);\r\ndrm_encoder_init(dev, encoder, &psb_intel_lvds_enc_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\npsb_intel_connector_attach_encoder(psb_intel_connector,\r\npsb_intel_encoder);\r\npsb_intel_encoder->type = INTEL_OUTPUT_HDMI;\r\nhdmi_priv->hdmi_reg = reg;\r\nhdmi_priv->has_hdmi_sink = false;\r\npsb_intel_encoder->dev_priv = hdmi_priv;\r\ndrm_encoder_helper_add(encoder, &cdv_hdmi_helper_funcs);\r\ndrm_connector_helper_add(connector,\r\n&cdv_hdmi_connector_helper_funcs);\r\nconnector->display_info.subpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nswitch (reg) {\r\ncase SDVOB:\r\nddc_bus = GPIOE;\r\npsb_intel_encoder->ddi_select = DDI0_SELECT;\r\nbreak;\r\ncase SDVOC:\r\nddc_bus = GPIOD;\r\npsb_intel_encoder->ddi_select = DDI1_SELECT;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown reg 0x%x for HDMI\n", reg);\r\ngoto failed_ddc;\r\nbreak;\r\n}\r\npsb_intel_encoder->i2c_bus = psb_intel_i2c_create(dev,\r\nddc_bus, (reg == SDVOB) ? "HDMIB" : "HDMIC");\r\nif (!psb_intel_encoder->i2c_bus) {\r\ndev_err(dev->dev, "No ddc adapter available!\n");\r\ngoto failed_ddc;\r\n}\r\nhdmi_priv->hdmi_i2c_adapter =\r\n&(psb_intel_encoder->i2c_bus->adapter);\r\nhdmi_priv->dev = dev;\r\ndrm_sysfs_connector_add(connector);\r\nreturn;\r\nfailed_ddc:\r\ndrm_encoder_cleanup(encoder);\r\ndrm_connector_cleanup(connector);\r\nerr_priv:\r\nkfree(psb_intel_connector);\r\nerr_connector:\r\nkfree(psb_intel_encoder);\r\n}
