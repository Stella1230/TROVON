static void ehci_set_command_bit(struct ehci_hcd *ehci, u32 bit)\r\n{\r\nehci->command |= bit;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci_readl(ehci, &ehci->regs->command);\r\n}\r\nstatic void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)\r\n{\r\nehci->command &= ~bit;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci_readl(ehci, &ehci->regs->command);\r\n}\r\nstatic void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,\r\nbool resched)\r\n{\r\nktime_t *timeout = &ehci->hr_timeouts[event];\r\nif (resched)\r\n*timeout = ktime_add(ktime_get(),\r\nktime_set(0, event_delays_ns[event]));\r\nehci->enabled_hrtimer_events |= (1 << event);\r\nif (event < ehci->next_hrtimer_event) {\r\nehci->next_hrtimer_event = event;\r\nhrtimer_start_range_ns(&ehci->hrtimer, *timeout,\r\nNSEC_PER_MSEC, HRTIMER_MODE_ABS);\r\n}\r\n}\r\nstatic void ehci_poll_ASS(struct ehci_hcd *ehci)\r\n{\r\nunsigned actual, want;\r\nif (ehci->rh_state != EHCI_RH_RUNNING)\r\nreturn;\r\nwant = (ehci->command & CMD_ASE) ? STS_ASS : 0;\r\nactual = ehci_readl(ehci, &ehci->regs->status) & STS_ASS;\r\nif (want != actual) {\r\nif (ehci->ASS_poll_count++ < 2) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);\r\nreturn;\r\n}\r\nehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",\r\nwant, actual);\r\n}\r\nehci->ASS_poll_count = 0;\r\nif (want == 0) {\r\nif (ehci->async_count > 0)\r\nehci_set_command_bit(ehci, CMD_ASE);\r\n} else {\r\nif (ehci->async_count == 0) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_ASYNC,\r\ntrue);\r\n}\r\n}\r\n}\r\nstatic void ehci_disable_ASE(struct ehci_hcd *ehci)\r\n{\r\nehci_clear_command_bit(ehci, CMD_ASE);\r\n}\r\nstatic void ehci_poll_PSS(struct ehci_hcd *ehci)\r\n{\r\nunsigned actual, want;\r\nif (ehci->rh_state != EHCI_RH_RUNNING)\r\nreturn;\r\nwant = (ehci->command & CMD_PSE) ? STS_PSS : 0;\r\nactual = ehci_readl(ehci, &ehci->regs->status) & STS_PSS;\r\nif (want != actual) {\r\nif (ehci->PSS_poll_count++ < 2) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);\r\nreturn;\r\n}\r\nehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",\r\nwant, actual);\r\n}\r\nehci->PSS_poll_count = 0;\r\nif (want == 0) {\r\nif (ehci->periodic_count > 0)\r\nehci_set_command_bit(ehci, CMD_PSE);\r\n} else {\r\nif (ehci->periodic_count == 0) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_PERIODIC,\r\ntrue);\r\n}\r\n}\r\n}\r\nstatic void ehci_disable_PSE(struct ehci_hcd *ehci)\r\n{\r\nehci_clear_command_bit(ehci, CMD_PSE);\r\n}\r\nstatic void ehci_handle_controller_death(struct ehci_hcd *ehci)\r\n{\r\nif (!(ehci_readl(ehci, &ehci->regs->status) & STS_HALT)) {\r\nif (ehci->died_poll_count++ < 5) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_POLL_DEAD, true);\r\nreturn;\r\n}\r\nehci_warn(ehci, "Waited too long for the controller to stop, giving up\n");\r\n}\r\nehci->rh_state = EHCI_RH_HALTED;\r\nehci_writel(ehci, 0, &ehci->regs->configured_flag);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nehci_work(ehci);\r\nend_unlink_async(ehci);\r\n}\r\nstatic void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)\r\n{\r\nbool stopped = (ehci->rh_state < EHCI_RH_RUNNING);\r\nehci->intr_unlinking = true;\r\nwhile (!list_empty(&ehci->intr_unlink)) {\r\nstruct ehci_qh *qh;\r\nqh = list_first_entry(&ehci->intr_unlink, struct ehci_qh,\r\nunlink_node);\r\nif (!stopped && qh->unlink_cycle == ehci->intr_unlink_cycle)\r\nbreak;\r\nlist_del(&qh->unlink_node);\r\nend_unlink_intr(ehci, qh);\r\n}\r\nif (!list_empty(&ehci->intr_unlink)) {\r\nehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);\r\n++ehci->intr_unlink_cycle;\r\n}\r\nehci->intr_unlinking = false;\r\n}\r\nstatic void start_free_itds(struct ehci_hcd *ehci)\r\n{\r\nif (!(ehci->enabled_hrtimer_events & BIT(EHCI_HRTIMER_FREE_ITDS))) {\r\nehci->last_itd_to_free = list_entry(\r\nehci->cached_itd_list.prev,\r\nstruct ehci_itd, itd_list);\r\nehci->last_sitd_to_free = list_entry(\r\nehci->cached_sitd_list.prev,\r\nstruct ehci_sitd, sitd_list);\r\nehci_enable_event(ehci, EHCI_HRTIMER_FREE_ITDS, true);\r\n}\r\n}\r\nstatic void end_free_itds(struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_itd *itd, *n;\r\nstruct ehci_sitd *sitd, *sn;\r\nif (ehci->rh_state < EHCI_RH_RUNNING) {\r\nehci->last_itd_to_free = NULL;\r\nehci->last_sitd_to_free = NULL;\r\n}\r\nlist_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {\r\nlist_del(&itd->itd_list);\r\ndma_pool_free(ehci->itd_pool, itd, itd->itd_dma);\r\nif (itd == ehci->last_itd_to_free)\r\nbreak;\r\n}\r\nlist_for_each_entry_safe(sitd, sn, &ehci->cached_sitd_list, sitd_list) {\r\nlist_del(&sitd->sitd_list);\r\ndma_pool_free(ehci->sitd_pool, sitd, sitd->sitd_dma);\r\nif (sitd == ehci->last_sitd_to_free)\r\nbreak;\r\n}\r\nif (!list_empty(&ehci->cached_itd_list) ||\r\n!list_empty(&ehci->cached_sitd_list))\r\nstart_free_itds(ehci);\r\n}\r\nstatic void ehci_iaa_watchdog(struct ehci_hcd *ehci)\r\n{\r\nu32 cmd, status;\r\nif (!ehci->iaa_in_progress || ehci->rh_state != EHCI_RH_RUNNING)\r\nreturn;\r\ncmd = ehci_readl(ehci, &ehci->regs->command);\r\nstatus = ehci_readl(ehci, &ehci->regs->status);\r\nif ((status & STS_IAA) || !(cmd & CMD_IAAD)) {\r\nCOUNT(ehci->stats.lost_iaa);\r\nehci_writel(ehci, STS_IAA, &ehci->regs->status);\r\n}\r\nehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);\r\nend_unlink_async(ehci);\r\n}\r\nstatic void turn_on_io_watchdog(struct ehci_hcd *ehci)\r\n{\r\nif (ehci->rh_state != EHCI_RH_RUNNING ||\r\n(ehci->enabled_hrtimer_events &\r\nBIT(EHCI_HRTIMER_IO_WATCHDOG)))\r\nreturn;\r\nif (ehci->isoc_count > 0 || (ehci->need_io_watchdog &&\r\nehci->async_count + ehci->intr_count > 0))\r\nehci_enable_event(ehci, EHCI_HRTIMER_IO_WATCHDOG, true);\r\n}\r\nstatic enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)\r\n{\r\nstruct ehci_hcd *ehci = container_of(t, struct ehci_hcd, hrtimer);\r\nktime_t now;\r\nunsigned long events;\r\nunsigned long flags;\r\nunsigned e;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nevents = ehci->enabled_hrtimer_events;\r\nehci->enabled_hrtimer_events = 0;\r\nehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;\r\nnow = ktime_get();\r\nfor_each_set_bit(e, &events, EHCI_HRTIMER_NUM_EVENTS) {\r\nif (now.tv64 >= ehci->hr_timeouts[e].tv64)\r\nevent_handlers[e](ehci);\r\nelse\r\nehci_enable_event(ehci, e, false);\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn HRTIMER_NORESTART;\r\n}
