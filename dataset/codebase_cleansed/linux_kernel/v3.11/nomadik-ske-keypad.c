static void ske_keypad_set_bits(struct ske_keypad *keypad, u16 addr,\r\nu8 mask, u8 data)\r\n{\r\nu32 ret;\r\nspin_lock(&keypad->ske_keypad_lock);\r\nret = readl(keypad->reg_base + addr);\r\nret &= ~mask;\r\nret |= data;\r\nwritel(ret, keypad->reg_base + addr);\r\nspin_unlock(&keypad->ske_keypad_lock);\r\n}\r\nstatic int __init ske_keypad_chip_init(struct ske_keypad *keypad)\r\n{\r\nu32 value;\r\nint timeout = keypad->board->debounce_ms;\r\nwhile ((readl(keypad->reg_base + SKE_RIS) != 0x00000000) && timeout--)\r\ncpu_relax();\r\nif (!timeout)\r\nreturn -EINVAL;\r\nspin_lock(&keypad->ske_keypad_lock);\r\nvalue = readl(keypad->reg_base + SKE_DBCR);\r\nvalue = value & 0xff;\r\nvalue |= ((keypad->board->debounce_ms * 32000)/32768) << 8;\r\nwritel(value, keypad->reg_base + SKE_DBCR);\r\nspin_unlock(&keypad->ske_keypad_lock);\r\nske_keypad_set_bits(keypad, SKE_CR, 0x0, SKE_KPMLT);\r\nvalue = (keypad->board->kcol - 1) << 3;\r\nske_keypad_set_bits(keypad, SKE_CR, SKE_KPCN, value);\r\nske_keypad_set_bits(keypad, SKE_ICR, 0x0, SKE_KPICA | SKE_KPICS);\r\nske_keypad_set_bits(keypad, SKE_IMSC, 0x0, SKE_KPIMA);\r\nske_keypad_set_bits(keypad, SKE_CR, 0x0, SKE_KPASEN);\r\nreturn 0;\r\n}\r\nstatic void ske_keypad_report(struct ske_keypad *keypad, u8 status, int col)\r\n{\r\nint row = 0, code, pos;\r\nstruct input_dev *input = keypad->input;\r\nu32 ske_ris;\r\nint key_pressed;\r\nint num_of_rows;\r\nnum_of_rows = hweight8(status);\r\ndo {\r\npos = __ffs(status);\r\nrow = pos;\r\nstatus &= ~(1 << pos);\r\ncode = MATRIX_SCAN_CODE(row, col, SKE_KEYPAD_ROW_SHIFT);\r\nske_ris = readl(keypad->reg_base + SKE_RIS);\r\nkey_pressed = ske_ris & SKE_KPRISA;\r\ninput_event(input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input, keypad->keymap[code], key_pressed);\r\ninput_sync(input);\r\nnum_of_rows--;\r\n} while (num_of_rows);\r\n}\r\nstatic void ske_keypad_read_data(struct ske_keypad *keypad)\r\n{\r\nu8 status;\r\nint col = 0;\r\nint ske_asr, i;\r\nfor (i = 0; i < SKE_NUM_ASRX_REGISTERS; i++) {\r\nske_asr = readl(keypad->reg_base + SKE_ASR0 + (4 * i));\r\nif (!ske_asr)\r\ncontinue;\r\nstatus = ske_asr & 0xff;\r\nif (status) {\r\ncol = i * 2;\r\nske_keypad_report(keypad, status, col);\r\n}\r\nstatus = (ske_asr & 0xff00) >> 8;\r\nif (status) {\r\ncol = (i * 2) + 1;\r\nske_keypad_report(keypad, status, col);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t ske_keypad_irq(int irq, void *dev_id)\r\n{\r\nstruct ske_keypad *keypad = dev_id;\r\nint timeout = keypad->board->debounce_ms;\r\nske_keypad_set_bits(keypad, SKE_IMSC, ~SKE_KPIMA, 0x0);\r\nske_keypad_set_bits(keypad, SKE_ICR, 0x0, SKE_KPICA);\r\nwhile ((readl(keypad->reg_base + SKE_CR) & SKE_KPASON) && --timeout)\r\ncpu_relax();\r\nske_keypad_read_data(keypad);\r\nwhile ((readl(keypad->reg_base + SKE_RIS)) && --timeout)\r\nmsleep(KEY_PRESSED_DELAY);\r\nske_keypad_set_bits(keypad, SKE_IMSC, 0x0, SKE_KPIMA);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init ske_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct ske_keypad_platform_data *plat = pdev->dev.platform_data;\r\nstruct ske_keypad *keypad;\r\nstruct input_dev *input;\r\nstruct resource *res;\r\nint irq;\r\nint error;\r\nif (!plat) {\r\ndev_err(&pdev->dev, "invalid keypad platform data\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get keypad irq\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "missing platform resources\n");\r\nreturn -EINVAL;\r\n}\r\nkeypad = kzalloc(sizeof(struct ske_keypad), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!keypad || !input) {\r\ndev_err(&pdev->dev, "failed to allocate keypad memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkeypad->irq = irq;\r\nkeypad->board = plat;\r\nkeypad->input = input;\r\nspin_lock_init(&keypad->ske_keypad_lock);\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nkeypad->reg_base = ioremap(res->start, resource_size(res));\r\nif (!keypad->reg_base) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -ENXIO;\r\ngoto err_free_mem_region;\r\n}\r\nkeypad->pclk = clk_get(&pdev->dev, "apb_pclk");\r\nif (IS_ERR(keypad->pclk)) {\r\ndev_err(&pdev->dev, "failed to get pclk\n");\r\nerror = PTR_ERR(keypad->pclk);\r\ngoto err_iounmap;\r\n}\r\nkeypad->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get clk\n");\r\nerror = PTR_ERR(keypad->clk);\r\ngoto err_pclk;\r\n}\r\ninput->id.bustype = BUS_HOST;\r\ninput->name = "ux500-ske-keypad";\r\ninput->dev.parent = &pdev->dev;\r\nerror = matrix_keypad_build_keymap(plat->keymap_data, NULL,\r\nSKE_KPD_NUM_ROWS, SKE_KPD_NUM_COLS,\r\nkeypad->keymap, input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to build keymap\n");\r\ngoto err_clk;\r\n}\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nif (!plat->no_autorepeat)\r\n__set_bit(EV_REP, input->evbit);\r\nerror = clk_prepare_enable(keypad->pclk);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to prepare/enable pclk\n");\r\ngoto err_clk;\r\n}\r\nerror = clk_prepare_enable(keypad->clk);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to prepare/enable clk\n");\r\ngoto err_pclk_disable;\r\n}\r\nif (keypad->board->init)\r\nkeypad->board->init();\r\nerror = ske_keypad_chip_init(keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to init keypad hardware\n");\r\ngoto err_clk_disable;\r\n}\r\nerror = request_threaded_irq(keypad->irq, NULL, ske_keypad_irq,\r\nIRQF_ONESHOT, "ske-keypad", keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "allocate irq %d failed\n", keypad->irq);\r\ngoto err_clk_disable;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"unable to register input device: %d\n", error);\r\ngoto err_free_irq;\r\n}\r\nif (plat->wakeup_enable)\r\ndevice_init_wakeup(&pdev->dev, true);\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(keypad->irq, keypad);\r\nerr_clk_disable:\r\nclk_disable_unprepare(keypad->clk);\r\nerr_pclk_disable:\r\nclk_disable_unprepare(keypad->pclk);\r\nerr_clk:\r\nclk_put(keypad->clk);\r\nerr_pclk:\r\nclk_put(keypad->pclk);\r\nerr_iounmap:\r\niounmap(keypad->reg_base);\r\nerr_free_mem_region:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(keypad);\r\nreturn error;\r\n}\r\nstatic int ske_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct ske_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfree_irq(keypad->irq, keypad);\r\ninput_unregister_device(keypad->input);\r\nclk_disable_unprepare(keypad->clk);\r\nclk_put(keypad->clk);\r\nif (keypad->board->exit)\r\nkeypad->board->exit();\r\niounmap(keypad->reg_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(keypad);\r\nreturn 0;\r\n}\r\nstatic int ske_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ske_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(irq);\r\nelse\r\nske_keypad_set_bits(keypad, SKE_IMSC, ~SKE_KPIMA, 0x0);\r\nreturn 0;\r\n}\r\nstatic int ske_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ske_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(irq);\r\nelse\r\nske_keypad_set_bits(keypad, SKE_IMSC, 0x0, SKE_KPIMA);\r\nreturn 0;\r\n}
