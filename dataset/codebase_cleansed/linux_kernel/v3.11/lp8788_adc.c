static int lp8788_get_adc_result(struct lp8788_adc *adc, enum lp8788_adc_id id,\r\nint *val)\r\n{\r\nunsigned int msb;\r\nunsigned int lsb;\r\nunsigned int result;\r\nu8 data;\r\nu8 rawdata[2];\r\nint size = ARRAY_SIZE(rawdata);\r\nint retry = 5;\r\nint ret;\r\ndata = (id << 1) | ADC_CONV_START;\r\nret = lp8788_write_byte(adc->lp, LP8788_ADC_CONF, data);\r\nif (ret)\r\ngoto err_io;\r\ndata = 0;\r\nwhile (retry--) {\r\nusleep_range(100, 200);\r\nret = lp8788_read_byte(adc->lp, LP8788_ADC_DONE, &data);\r\nif (ret)\r\ngoto err_io;\r\nif (data)\r\nbreak;\r\n}\r\nret = lp8788_read_multi_bytes(adc->lp, LP8788_ADC_RAW, rawdata, size);\r\nif (ret)\r\ngoto err_io;\r\nmsb = (rawdata[0] << 4) & 0x00000ff0;\r\nlsb = (rawdata[1] >> 4) & 0x0000000f;\r\nresult = msb | lsb;\r\n*val = result;\r\nreturn 0;\r\nerr_io:\r\nreturn ret;\r\n}\r\nstatic int lp8788_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct lp8788_adc *adc = iio_priv(indio_dev);\r\nenum lp8788_adc_id id = chan->channel;\r\nint ret;\r\nmutex_lock(&adc->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = lp8788_get_adc_result(adc, id, val) ? -EIO : IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = lp8788_scale[id] / 1000000;\r\n*val2 = lp8788_scale[id] % 1000000;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&adc->lock);\r\nreturn ret;\r\n}\r\nstatic int lp8788_iio_map_register(struct iio_dev *indio_dev,\r\nstruct lp8788_platform_data *pdata,\r\nstruct lp8788_adc *adc)\r\n{\r\nstruct iio_map *map;\r\nint ret;\r\nmap = (!pdata || !pdata->adc_pdata) ?\r\nlp8788_default_iio_maps : pdata->adc_pdata;\r\nret = iio_map_array_register(indio_dev, map);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "iio map err: %d\n", ret);\r\nreturn ret;\r\n}\r\nadc->map = map;\r\nreturn 0;\r\n}\r\nstatic int lp8788_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nstruct iio_dev *indio_dev;\r\nstruct lp8788_adc *adc;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*adc));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nadc = iio_priv(indio_dev);\r\nadc->lp = lp;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nret = lp8788_iio_map_register(indio_dev, lp->pdata, adc);\r\nif (ret)\r\ngoto err_iio_map;\r\nmutex_init(&adc->lock);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->name = pdev->name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &lp8788_adc_info;\r\nindio_dev->channels = lp8788_adc_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(lp8788_adc_channels);\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "iio dev register err: %d\n", ret);\r\ngoto err_iio_device;\r\n}\r\nreturn 0;\r\nerr_iio_device:\r\niio_map_array_unregister(indio_dev);\r\nerr_iio_map:\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int lp8788_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\niio_device_unregister(indio_dev);\r\niio_map_array_unregister(indio_dev);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
