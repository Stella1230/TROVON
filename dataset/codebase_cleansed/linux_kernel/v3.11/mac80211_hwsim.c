static inline void hwsim_check_magic(struct ieee80211_vif *vif)\r\n{\r\nstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\r\nWARN(vp->magic != HWSIM_VIF_MAGIC,\r\n"Invalid VIF (%p) magic %#x, %pM, %d/%d\n",\r\nvif, vp->magic, vif->addr, vif->type, vif->p2p);\r\n}\r\nstatic inline void hwsim_set_magic(struct ieee80211_vif *vif)\r\n{\r\nstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\r\nvp->magic = HWSIM_VIF_MAGIC;\r\n}\r\nstatic inline void hwsim_clear_magic(struct ieee80211_vif *vif)\r\n{\r\nstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\r\nvp->magic = 0;\r\n}\r\nstatic inline void hwsim_check_sta_magic(struct ieee80211_sta *sta)\r\n{\r\nstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\r\nWARN_ON(sp->magic != HWSIM_STA_MAGIC);\r\n}\r\nstatic inline void hwsim_set_sta_magic(struct ieee80211_sta *sta)\r\n{\r\nstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\r\nsp->magic = HWSIM_STA_MAGIC;\r\n}\r\nstatic inline void hwsim_clear_sta_magic(struct ieee80211_sta *sta)\r\n{\r\nstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\r\nsp->magic = 0;\r\n}\r\nstatic inline void hwsim_check_chanctx_magic(struct ieee80211_chanctx_conf *c)\r\n{\r\nstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\r\nWARN_ON(cp->magic != HWSIM_CHANCTX_MAGIC);\r\n}\r\nstatic inline void hwsim_set_chanctx_magic(struct ieee80211_chanctx_conf *c)\r\n{\r\nstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\r\ncp->magic = HWSIM_CHANCTX_MAGIC;\r\n}\r\nstatic inline void hwsim_clear_chanctx_magic(struct ieee80211_chanctx_conf *c)\r\n{\r\nstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\r\ncp->magic = 0;\r\n}\r\nstatic netdev_tx_t hwsim_mon_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline u64 mac80211_hwsim_get_tsf_raw(void)\r\n{\r\nreturn ktime_to_us(ktime_get_real());\r\n}\r\nstatic __le64 __mac80211_hwsim_get_tsf(struct mac80211_hwsim_data *data)\r\n{\r\nu64 now = mac80211_hwsim_get_tsf_raw();\r\nreturn cpu_to_le64(now + data->tsf_offset);\r\n}\r\nstatic u64 mac80211_hwsim_get_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nreturn le64_to_cpu(__mac80211_hwsim_get_tsf(data));\r\n}\r\nstatic void mac80211_hwsim_set_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u64 tsf)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nu64 now = mac80211_hwsim_get_tsf(hw, vif);\r\nu32 bcn_int = data->beacon_int;\r\ns64 delta = tsf - now;\r\ndata->tsf_offset += delta;\r\ndata->bcn_delta = do_div(delta, bcn_int);\r\n}\r\nstatic void mac80211_hwsim_monitor_rx(struct ieee80211_hw *hw,\r\nstruct sk_buff *tx_skb,\r\nstruct ieee80211_channel *chan)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nstruct sk_buff *skb;\r\nstruct hwsim_radiotap_hdr *hdr;\r\nu16 flags;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_skb);\r\nstruct ieee80211_rate *txrate = ieee80211_get_tx_rate(hw, info);\r\nif (!netif_running(hwsim_mon))\r\nreturn;\r\nskb = skb_copy_expand(tx_skb, sizeof(*hdr), 0, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\nhdr = (struct hwsim_radiotap_hdr *) skb_push(skb, sizeof(*hdr));\r\nhdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\r\nhdr->hdr.it_pad = 0;\r\nhdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\r\nhdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_RATE) |\r\n(1 << IEEE80211_RADIOTAP_TSFT) |\r\n(1 << IEEE80211_RADIOTAP_CHANNEL));\r\nhdr->rt_tsft = __mac80211_hwsim_get_tsf(data);\r\nhdr->rt_flags = 0;\r\nhdr->rt_rate = txrate->bitrate / 5;\r\nhdr->rt_channel = cpu_to_le16(chan->center_freq);\r\nflags = IEEE80211_CHAN_2GHZ;\r\nif (txrate->flags & IEEE80211_RATE_ERP_G)\r\nflags |= IEEE80211_CHAN_OFDM;\r\nelse\r\nflags |= IEEE80211_CHAN_CCK;\r\nhdr->rt_chbitmask = cpu_to_le16(flags);\r\nskb->dev = hwsim_mon;\r\nskb_set_mac_header(skb, 0);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic void mac80211_hwsim_monitor_ack(struct ieee80211_channel *chan,\r\nconst u8 *addr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hwsim_radiotap_hdr *hdr;\r\nu16 flags;\r\nstruct ieee80211_hdr *hdr11;\r\nif (!netif_running(hwsim_mon))\r\nreturn;\r\nskb = dev_alloc_skb(100);\r\nif (skb == NULL)\r\nreturn;\r\nhdr = (struct hwsim_radiotap_hdr *) skb_put(skb, sizeof(*hdr));\r\nhdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\r\nhdr->hdr.it_pad = 0;\r\nhdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\r\nhdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_CHANNEL));\r\nhdr->rt_flags = 0;\r\nhdr->rt_rate = 0;\r\nhdr->rt_channel = cpu_to_le16(chan->center_freq);\r\nflags = IEEE80211_CHAN_2GHZ;\r\nhdr->rt_chbitmask = cpu_to_le16(flags);\r\nhdr11 = (struct ieee80211_hdr *) skb_put(skb, 10);\r\nhdr11->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\r\nIEEE80211_STYPE_ACK);\r\nhdr11->duration_id = cpu_to_le16(0);\r\nmemcpy(hdr11->addr1, addr, ETH_ALEN);\r\nskb->dev = hwsim_mon;\r\nskb_set_mac_header(skb, 0);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic bool hwsim_ps_rx_ok(struct mac80211_hwsim_data *data,\r\nstruct sk_buff *skb)\r\n{\r\nswitch (data->ps) {\r\ncase PS_DISABLED:\r\nreturn true;\r\ncase PS_ENABLED:\r\nreturn false;\r\ncase PS_AUTO_POLL:\r\nreturn true;\r\ncase PS_MANUAL_POLL:\r\nif (data->ps_poll_pending &&\r\nmemcmp(data->hw->wiphy->perm_addr, skb->data + 4,\r\nETH_ALEN) == 0) {\r\ndata->ps_poll_pending = false;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void mac80211_hwsim_addr_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_addr_match_data *md = data;\r\nif (memcmp(mac, md->addr, ETH_ALEN) == 0)\r\nmd->ret = true;\r\n}\r\nstatic bool mac80211_hwsim_addr_match(struct mac80211_hwsim_data *data,\r\nconst u8 *addr)\r\n{\r\nstruct mac80211_hwsim_addr_match_data md;\r\nif (memcmp(addr, data->hw->wiphy->perm_addr, ETH_ALEN) == 0)\r\nreturn true;\r\nmd.ret = false;\r\nmd.addr = addr;\r\nieee80211_iterate_active_interfaces_atomic(data->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\nmac80211_hwsim_addr_iter,\r\n&md);\r\nreturn md.ret;\r\n}\r\nstatic void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw,\r\nstruct sk_buff *my_skb,\r\nint dst_portid)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) my_skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(my_skb);\r\nvoid *msg_head;\r\nunsigned int hwsim_flags = 0;\r\nint i;\r\nstruct hwsim_tx_rate tx_attempts[IEEE80211_TX_MAX_RATES];\r\nif (data->ps != PS_DISABLED)\r\nhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\r\nif (skb_queue_len(&data->pending) >= MAX_QUEUE) {\r\nwhile (skb_queue_len(&data->pending) >= WARN_QUEUE)\r\nskb_dequeue(&data->pending);\r\n}\r\nskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto nla_put_failure;\r\nmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\r\nHWSIM_CMD_FRAME);\r\nif (msg_head == NULL) {\r\nprintk(KERN_DEBUG "mac80211_hwsim: problem with msg_head\n");\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER,\r\nsizeof(struct mac_address), data->addresses[1].addr))\r\ngoto nla_put_failure;\r\nif (nla_put(skb, HWSIM_ATTR_FRAME, my_skb->len, my_skb->data))\r\ngoto nla_put_failure;\r\nif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)\r\nhwsim_flags |= HWSIM_TX_CTL_REQ_TX_STATUS;\r\nif (info->flags & IEEE80211_TX_CTL_NO_ACK)\r\nhwsim_flags |= HWSIM_TX_CTL_NO_ACK;\r\nif (nla_put_u32(skb, HWSIM_ATTR_FLAGS, hwsim_flags))\r\ngoto nla_put_failure;\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\ntx_attempts[i].idx = info->status.rates[i].idx;\r\ntx_attempts[i].count = info->status.rates[i].count;\r\n}\r\nif (nla_put(skb, HWSIM_ATTR_TX_INFO,\r\nsizeof(struct hwsim_tx_rate)*IEEE80211_TX_MAX_RATES,\r\ntx_attempts))\r\ngoto nla_put_failure;\r\nif (nla_put_u64(skb, HWSIM_ATTR_COOKIE, (unsigned long) my_skb))\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, msg_head);\r\ngenlmsg_unicast(&init_net, skb, dst_portid);\r\nskb_queue_tail(&data->pending, my_skb);\r\nreturn;\r\nnla_put_failure:\r\nprintk(KERN_DEBUG "mac80211_hwsim: error occurred in %s\n", __func__);\r\n}\r\nstatic bool hwsim_chans_compat(struct ieee80211_channel *c1,\r\nstruct ieee80211_channel *c2)\r\n{\r\nif (!c1 || !c2)\r\nreturn false;\r\nreturn c1->center_freq == c2->center_freq;\r\n}\r\nstatic void mac80211_hwsim_tx_iter(void *_data, u8 *addr,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct tx_iter_data *data = _data;\r\nif (!vif->chanctx_conf)\r\nreturn;\r\nif (!hwsim_chans_compat(data->channel,\r\nrcu_dereference(vif->chanctx_conf)->def.chan))\r\nreturn;\r\ndata->receive = true;\r\n}\r\nstatic bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_channel *chan)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv, *data2;\r\nbool ack = false;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_rx_status rx_status;\r\nu64 now;\r\nmemset(&rx_status, 0, sizeof(rx_status));\r\nrx_status.flag |= RX_FLAG_MACTIME_START;\r\nrx_status.freq = chan->center_freq;\r\nrx_status.band = chan->band;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\r\nrx_status.rate_idx =\r\nieee80211_rate_get_vht_mcs(&info->control.rates[0]);\r\nrx_status.vht_nss =\r\nieee80211_rate_get_vht_nss(&info->control.rates[0]);\r\nrx_status.flag |= RX_FLAG_VHT;\r\n} else {\r\nrx_status.rate_idx = info->control.rates[0].idx;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\r\nrx_status.flag |= RX_FLAG_HT;\r\n}\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\nrx_status.flag |= RX_FLAG_40MHZ;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\r\nrx_status.flag |= RX_FLAG_SHORT_GI;\r\nrx_status.signal = data->power_level - 50;\r\nif (data->ps != PS_DISABLED)\r\nhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\r\nskb_orphan(skb);\r\nskb_dst_drop(skb);\r\nskb->mark = 0;\r\nsecpath_reset(skb);\r\nnf_reset(skb);\r\nif (ieee80211_is_beacon(hdr->frame_control) ||\r\nieee80211_is_probe_resp(hdr->frame_control))\r\nnow = data->abs_bcn_ts;\r\nelse\r\nnow = mac80211_hwsim_get_tsf_raw();\r\nspin_lock(&hwsim_radio_lock);\r\nlist_for_each_entry(data2, &hwsim_radios, list) {\r\nstruct sk_buff *nskb;\r\nstruct tx_iter_data tx_iter_data = {\r\n.receive = false,\r\n.channel = chan,\r\n};\r\nif (data == data2)\r\ncontinue;\r\nif (!data2->started || (data2->idle && !data2->tmp_chan) ||\r\n!hwsim_ps_rx_ok(data2, skb))\r\ncontinue;\r\nif (!(data->group & data2->group))\r\ncontinue;\r\nif (!hwsim_chans_compat(chan, data2->tmp_chan) &&\r\n!hwsim_chans_compat(chan, data2->channel)) {\r\nieee80211_iterate_active_interfaces_atomic(\r\ndata2->hw, IEEE80211_IFACE_ITER_NORMAL,\r\nmac80211_hwsim_tx_iter, &tx_iter_data);\r\nif (!tx_iter_data.receive)\r\ncontinue;\r\n}\r\nif (skb->len < PAGE_SIZE && paged_rx) {\r\nstruct page *page = alloc_page(GFP_ATOMIC);\r\nif (!page)\r\ncontinue;\r\nnskb = dev_alloc_skb(128);\r\nif (!nskb) {\r\n__free_page(page);\r\ncontinue;\r\n}\r\nmemcpy(page_address(page), skb->data, skb->len);\r\nskb_add_rx_frag(nskb, 0, page, 0, skb->len, skb->len);\r\n} else {\r\nnskb = skb_copy(skb, GFP_ATOMIC);\r\nif (!nskb)\r\ncontinue;\r\n}\r\nif (mac80211_hwsim_addr_match(data2, hdr->addr1))\r\nack = true;\r\nrx_status.mactime = now + data2->tsf_offset;\r\n#if 0\r\nrx_status.vendor_radiotap_oui[0] = 0x00;\r\nrx_status.vendor_radiotap_oui[1] = 0x00;\r\nrx_status.vendor_radiotap_oui[2] = 0x00;\r\nrx_status.vendor_radiotap_subns = 127;\r\nrx_status.vendor_radiotap_bitmap = BIT(0);\r\nrx_status.vendor_radiotap_len = 8;\r\nrx_status.vendor_radiotap_align = 8;\r\nmemcpy(skb_push(nskb, 8), "ABCDEFGH", 8);\r\n#endif\r\nmemcpy(IEEE80211_SKB_RXCB(nskb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(data2->hw, nskb);\r\n}\r\nspin_unlock(&hwsim_radio_lock);\r\nreturn ack;\r\n}\r\nstatic void mac80211_hwsim_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct ieee80211_channel *channel;\r\nbool ack;\r\nu32 _portid;\r\nif (WARN_ON(skb->len < 10)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (channels == 1) {\r\nchannel = data->channel;\r\n} else if (txi->hw_queue == 4) {\r\nchannel = data->tmp_chan;\r\n} else {\r\nchanctx_conf = rcu_dereference(txi->control.vif->chanctx_conf);\r\nif (chanctx_conf)\r\nchannel = chanctx_conf->def.chan;\r\nelse\r\nchannel = NULL;\r\n}\r\nif (WARN(!channel, "TX w/o channel - queue = %d\n", txi->hw_queue)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (data->idle && !data->tmp_chan) {\r\nwiphy_debug(hw->wiphy, "Trying to TX when idle - reject\n");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (txi->control.vif)\r\nhwsim_check_magic(txi->control.vif);\r\nif (control->sta)\r\nhwsim_check_sta_magic(control->sta);\r\nif (rctbl)\r\nieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\r\ntxi->control.rates,\r\nARRAY_SIZE(txi->control.rates));\r\ntxi->rate_driver_data[0] = channel;\r\nmac80211_hwsim_monitor_rx(hw, skb, channel);\r\n_portid = ACCESS_ONCE(wmediumd_portid);\r\nif (_portid)\r\nreturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid);\r\nack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\r\nif (ack && skb->len >= 16) {\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nmac80211_hwsim_monitor_ack(channel, hdr->addr2);\r\n}\r\nieee80211_tx_info_clear_status(txi);\r\ntxi->control.rates[0].count = 1;\r\ntxi->control.rates[1].idx = -1;\r\nif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\r\ntxi->flags |= IEEE80211_TX_STAT_ACK;\r\nieee80211_tx_status_irqsafe(hw, skb);\r\n}\r\nstatic int mac80211_hwsim_start(struct ieee80211_hw *hw)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nwiphy_debug(hw->wiphy, "%s\n", __func__);\r\ndata->started = true;\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\ndata->started = false;\r\ntasklet_hrtimer_cancel(&data->beacon_timer);\r\nwiphy_debug(hw->wiphy, "%s\n", __func__);\r\n}\r\nstatic int mac80211_hwsim_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nwiphy_debug(hw->wiphy, "%s (type=%d mac_addr=%pM)\n",\r\n__func__, ieee80211_vif_type_p2p(vif),\r\nvif->addr);\r\nhwsim_set_magic(vif);\r\nvif->cab_queue = 0;\r\nvif->hw_queue[IEEE80211_AC_VO] = 0;\r\nvif->hw_queue[IEEE80211_AC_VI] = 1;\r\nvif->hw_queue[IEEE80211_AC_BE] = 2;\r\nvif->hw_queue[IEEE80211_AC_BK] = 3;\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_change_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum nl80211_iftype newtype,\r\nbool newp2p)\r\n{\r\nnewtype = ieee80211_iftype_p2p(newtype, newp2p);\r\nwiphy_debug(hw->wiphy,\r\n"%s (old type=%d, new type=%d, mac_addr=%pM)\n",\r\n__func__, ieee80211_vif_type_p2p(vif),\r\nnewtype, vif->addr);\r\nhwsim_check_magic(vif);\r\nvif->cab_queue = 0;\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_remove_interface(\r\nstruct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nwiphy_debug(hw->wiphy, "%s (type=%d mac_addr=%pM)\n",\r\n__func__, ieee80211_vif_type_p2p(vif),\r\nvif->addr);\r\nhwsim_check_magic(vif);\r\nhwsim_clear_magic(vif);\r\n}\r\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_channel *chan)\r\n{\r\nu32 _pid = ACCESS_ONCE(wmediumd_portid);\r\nif (rctbl) {\r\nstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\r\nieee80211_get_tx_rates(txi->control.vif, NULL, skb,\r\ntxi->control.rates,\r\nARRAY_SIZE(txi->control.rates));\r\n}\r\nmac80211_hwsim_monitor_rx(hw, skb, chan);\r\nif (_pid)\r\nreturn mac80211_hwsim_tx_frame_nl(hw, skb, _pid);\r\nmac80211_hwsim_tx_frame_no_nl(hw, skb, chan);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_data *data = arg;\r\nstruct ieee80211_hw *hw = data->hw;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_rate *txrate;\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct sk_buff *skb;\r\nhwsim_check_magic(vif);\r\nif (vif->type != NL80211_IFTYPE_AP &&\r\nvif->type != NL80211_IFTYPE_MESH_POINT &&\r\nvif->type != NL80211_IFTYPE_ADHOC)\r\nreturn;\r\nskb = ieee80211_beacon_get(hw, vif);\r\nif (skb == NULL)\r\nreturn;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nif (rctbl)\r\nieee80211_get_tx_rates(vif, NULL, skb,\r\ninfo->control.rates,\r\nARRAY_SIZE(info->control.rates));\r\ntxrate = ieee80211_get_tx_rate(hw, info);\r\nmgmt = (struct ieee80211_mgmt *) skb->data;\r\ndata->abs_bcn_ts = mac80211_hwsim_get_tsf_raw();\r\nmgmt->u.beacon.timestamp = cpu_to_le64(data->abs_bcn_ts +\r\ndata->tsf_offset +\r\n24 * 8 * 10 / txrate->bitrate);\r\nmac80211_hwsim_tx_frame(hw, skb,\r\nrcu_dereference(vif->chanctx_conf)->def.chan);\r\n}\r\nstatic enum hrtimer_restart\r\nmac80211_hwsim_beacon(struct hrtimer *timer)\r\n{\r\nstruct mac80211_hwsim_data *data =\r\ncontainer_of(timer, struct mac80211_hwsim_data,\r\nbeacon_timer.timer);\r\nstruct ieee80211_hw *hw = data->hw;\r\nu64 bcn_int = data->beacon_int;\r\nktime_t next_bcn;\r\nif (!data->started)\r\ngoto out;\r\nieee80211_iterate_active_interfaces_atomic(\r\nhw, IEEE80211_IFACE_ITER_NORMAL,\r\nmac80211_hwsim_beacon_tx, data);\r\nif (data->bcn_delta) {\r\nbcn_int -= data->bcn_delta;\r\ndata->bcn_delta = 0;\r\n}\r\nnext_bcn = ktime_add(hrtimer_get_expires(timer),\r\nns_to_ktime(bcn_int * 1000));\r\ntasklet_hrtimer_start(&data->beacon_timer, next_bcn, HRTIMER_MODE_ABS);\r\nout:\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int mac80211_hwsim_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstatic const char *smps_modes[IEEE80211_SMPS_NUM_MODES] = {\r\n[IEEE80211_SMPS_AUTOMATIC] = "auto",\r\n[IEEE80211_SMPS_OFF] = "off",\r\n[IEEE80211_SMPS_STATIC] = "static",\r\n[IEEE80211_SMPS_DYNAMIC] = "dynamic",\r\n};\r\nif (conf->chandef.chan)\r\nwiphy_debug(hw->wiphy,\r\n"%s (freq=%d(%d - %d)/%s idle=%d ps=%d smps=%s)\n",\r\n__func__,\r\nconf->chandef.chan->center_freq,\r\nconf->chandef.center_freq1,\r\nconf->chandef.center_freq2,\r\nhwsim_chanwidths[conf->chandef.width],\r\n!!(conf->flags & IEEE80211_CONF_IDLE),\r\n!!(conf->flags & IEEE80211_CONF_PS),\r\nsmps_modes[conf->smps_mode]);\r\nelse\r\nwiphy_debug(hw->wiphy,\r\n"%s (freq=0 idle=%d ps=%d smps=%s)\n",\r\n__func__,\r\n!!(conf->flags & IEEE80211_CONF_IDLE),\r\n!!(conf->flags & IEEE80211_CONF_PS),\r\nsmps_modes[conf->smps_mode]);\r\ndata->idle = !!(conf->flags & IEEE80211_CONF_IDLE);\r\ndata->channel = conf->chandef.chan;\r\nWARN_ON(data->channel && channels > 1);\r\ndata->power_level = conf->power_level;\r\nif (!data->started || !data->beacon_int)\r\ntasklet_hrtimer_cancel(&data->beacon_timer);\r\nelse if (!hrtimer_is_queued(&data->beacon_timer.timer)) {\r\nu64 tsf = mac80211_hwsim_get_tsf(hw, NULL);\r\nu32 bcn_int = data->beacon_int;\r\nu64 until_tbtt = bcn_int - do_div(tsf, bcn_int);\r\ntasklet_hrtimer_start(&data->beacon_timer,\r\nns_to_ktime(until_tbtt * 1000),\r\nHRTIMER_MODE_REL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,u64 multicast)\r\n{\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nwiphy_debug(hw->wiphy, "%s\n", __func__);\r\ndata->rx_filter = 0;\r\nif (*total_flags & FIF_PROMISC_IN_BSS)\r\ndata->rx_filter |= FIF_PROMISC_IN_BSS;\r\nif (*total_flags & FIF_ALLMULTI)\r\ndata->rx_filter |= FIF_ALLMULTI;\r\n*total_flags = data->rx_filter;\r\n}\r\nstatic void mac80211_hwsim_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info,\r\nu32 changed)\r\n{\r\nstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\r\nstruct mac80211_hwsim_data *data = hw->priv;\r\nhwsim_check_magic(vif);\r\nwiphy_debug(hw->wiphy, "%s(changed=0x%x)\n", __func__, changed);\r\nif (changed & BSS_CHANGED_BSSID) {\r\nwiphy_debug(hw->wiphy, "%s: BSSID changed: %pM\n",\r\n__func__, info->bssid);\r\nmemcpy(vp->bssid, info->bssid, ETH_ALEN);\r\n}\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nwiphy_debug(hw->wiphy, " ASSOC: assoc=%d aid=%d\n",\r\ninfo->assoc, info->aid);\r\nvp->assoc = info->assoc;\r\nvp->aid = info->aid;\r\n}\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\nwiphy_debug(hw->wiphy, " BCNINT: %d\n", info->beacon_int);\r\ndata->beacon_int = info->beacon_int * 1024;\r\n}\r\nif (changed & BSS_CHANGED_BEACON_ENABLED) {\r\nwiphy_debug(hw->wiphy, " BCN EN: %d\n", info->enable_beacon);\r\nif (data->started &&\r\n!hrtimer_is_queued(&data->beacon_timer.timer) &&\r\ninfo->enable_beacon) {\r\nu64 tsf, until_tbtt;\r\nu32 bcn_int;\r\nif (WARN_ON(!data->beacon_int))\r\ndata->beacon_int = 1000 * 1024;\r\ntsf = mac80211_hwsim_get_tsf(hw, vif);\r\nbcn_int = data->beacon_int;\r\nuntil_tbtt = bcn_int - do_div(tsf, bcn_int);\r\ntasklet_hrtimer_start(&data->beacon_timer,\r\nns_to_ktime(until_tbtt * 1000),\r\nHRTIMER_MODE_REL);\r\n} else if (!info->enable_beacon)\r\ntasklet_hrtimer_cancel(&data->beacon_timer);\r\n}\r\nif (changed & BSS_CHANGED_ERP_CTS_PROT) {\r\nwiphy_debug(hw->wiphy, " ERP_CTS_PROT: %d\n",\r\ninfo->use_cts_prot);\r\n}\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nwiphy_debug(hw->wiphy, " ERP_PREAMBLE: %d\n",\r\ninfo->use_short_preamble);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nwiphy_debug(hw->wiphy, " ERP_SLOT: %d\n", info->use_short_slot);\r\n}\r\nif (changed & BSS_CHANGED_HT) {\r\nwiphy_debug(hw->wiphy, " HT: op_mode=0x%x\n",\r\ninfo->ht_operation_mode);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES) {\r\nwiphy_debug(hw->wiphy, " BASIC_RATES: 0x%llx\n",\r\n(unsigned long long) info->basic_rates);\r\n}\r\nif (changed & BSS_CHANGED_TXPOWER)\r\nwiphy_debug(hw->wiphy, " TX Power: %d dBm\n", info->txpower);\r\n}\r\nstatic int mac80211_hwsim_sta_add(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nhwsim_check_magic(vif);\r\nhwsim_set_sta_magic(sta);\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_sta_remove(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nhwsim_check_magic(vif);\r\nhwsim_clear_sta_magic(sta);\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_sta_notify(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum sta_notify_cmd cmd,\r\nstruct ieee80211_sta *sta)\r\n{\r\nhwsim_check_magic(vif);\r\nswitch (cmd) {\r\ncase STA_NOTIFY_SLEEP:\r\ncase STA_NOTIFY_AWAKE:\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid sta notify: %d\n", cmd);\r\nbreak;\r\n}\r\n}\r\nstatic int mac80211_hwsim_set_tim(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta,\r\nbool set)\r\n{\r\nhwsim_check_sta_magic(sta);\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_conf_tx(\r\nstruct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nwiphy_debug(hw->wiphy,\r\n"%s (queue=%d txop=%d cw_min=%d cw_max=%d aifs=%d)\n",\r\n__func__, queue,\r\nparams->txop, params->cw_min,\r\nparams->cw_max, params->aifs);\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_get_survey(\r\nstruct ieee80211_hw *hw, int idx,\r\nstruct survey_info *survey)\r\n{\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nwiphy_debug(hw->wiphy, "%s (idx=%d)\n", __func__, idx);\r\nif (idx != 0)\r\nreturn -ENOENT;\r\nsurvey->channel = conf->chandef.chan;\r\nsurvey->filled = SURVEY_INFO_NOISE_DBM;\r\nsurvey->noise = -92;\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_testmode_cmd(struct ieee80211_hw *hw,\r\nvoid *data, int len)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\nstruct nlattr *tb[HWSIM_TM_ATTR_MAX + 1];\r\nstruct sk_buff *skb;\r\nint err, ps;\r\nerr = nla_parse(tb, HWSIM_TM_ATTR_MAX, data, len,\r\nhwsim_testmode_policy);\r\nif (err)\r\nreturn err;\r\nif (!tb[HWSIM_TM_ATTR_CMD])\r\nreturn -EINVAL;\r\nswitch (nla_get_u32(tb[HWSIM_TM_ATTR_CMD])) {\r\ncase HWSIM_TM_CMD_SET_PS:\r\nif (!tb[HWSIM_TM_ATTR_PS])\r\nreturn -EINVAL;\r\nps = nla_get_u32(tb[HWSIM_TM_ATTR_PS]);\r\nreturn hwsim_fops_ps_write(hwsim, ps);\r\ncase HWSIM_TM_CMD_GET_PS:\r\nskb = cfg80211_testmode_alloc_reply_skb(hw->wiphy,\r\nnla_total_size(sizeof(u32)));\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (nla_put_u32(skb, HWSIM_TM_ATTR_PS, hwsim->ps))\r\ngoto nla_put_failure;\r\nreturn cfg80211_testmode_reply(skb);\r\ncase HWSIM_TM_CMD_STOP_QUEUES:\r\nieee80211_stop_queues(hw);\r\nreturn 0;\r\ncase HWSIM_TM_CMD_WAKE_QUEUES:\r\nieee80211_wake_queues(hw);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nnla_put_failure:\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nstatic int mac80211_hwsim_ampdu_action(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta, u16 tid, u16 *ssn,\r\nu8 buf_size)\r\n{\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_TX_START:\r\nieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_CONT:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_OPERATIONAL:\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_START:\r\ncase IEEE80211_AMPDU_RX_STOP:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_flush(struct ieee80211_hw *hw, u32 queues, bool drop)\r\n{\r\n}\r\nstatic void hw_scan_work(struct work_struct *work)\r\n{\r\nstruct mac80211_hwsim_data *hwsim =\r\ncontainer_of(work, struct mac80211_hwsim_data, hw_scan.work);\r\nstruct cfg80211_scan_request *req = hwsim->hw_scan_request;\r\nint dwell, i;\r\nmutex_lock(&hwsim->mutex);\r\nif (hwsim->scan_chan_idx >= req->n_channels) {\r\nwiphy_debug(hwsim->hw->wiphy, "hw scan complete\n");\r\nieee80211_scan_completed(hwsim->hw, false);\r\nhwsim->hw_scan_request = NULL;\r\nhwsim->hw_scan_vif = NULL;\r\nhwsim->tmp_chan = NULL;\r\nmutex_unlock(&hwsim->mutex);\r\nreturn;\r\n}\r\nwiphy_debug(hwsim->hw->wiphy, "hw scan %d MHz\n",\r\nreq->channels[hwsim->scan_chan_idx]->center_freq);\r\nhwsim->tmp_chan = req->channels[hwsim->scan_chan_idx];\r\nif (hwsim->tmp_chan->flags & IEEE80211_CHAN_PASSIVE_SCAN ||\r\n!req->n_ssids) {\r\ndwell = 120;\r\n} else {\r\ndwell = 30;\r\nfor (i = 0; i < req->n_ssids; i++) {\r\nstruct sk_buff *probe;\r\nprobe = ieee80211_probereq_get(hwsim->hw,\r\nhwsim->hw_scan_vif,\r\nreq->ssids[i].ssid,\r\nreq->ssids[i].ssid_len,\r\nreq->ie_len);\r\nif (!probe)\r\ncontinue;\r\nif (req->ie_len)\r\nmemcpy(skb_put(probe, req->ie_len), req->ie,\r\nreq->ie_len);\r\nlocal_bh_disable();\r\nmac80211_hwsim_tx_frame(hwsim->hw, probe,\r\nhwsim->tmp_chan);\r\nlocal_bh_enable();\r\n}\r\n}\r\nieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan,\r\nmsecs_to_jiffies(dwell));\r\nhwsim->scan_chan_idx++;\r\nmutex_unlock(&hwsim->mutex);\r\n}\r\nstatic int mac80211_hwsim_hw_scan(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct cfg80211_scan_request *req)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\nmutex_lock(&hwsim->mutex);\r\nif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\r\nmutex_unlock(&hwsim->mutex);\r\nreturn -EBUSY;\r\n}\r\nhwsim->hw_scan_request = req;\r\nhwsim->hw_scan_vif = vif;\r\nhwsim->scan_chan_idx = 0;\r\nmutex_unlock(&hwsim->mutex);\r\nwiphy_debug(hw->wiphy, "hwsim hw_scan request\n");\r\nieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan, 0);\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_cancel_hw_scan(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\nwiphy_debug(hw->wiphy, "hwsim cancel_hw_scan\n");\r\ncancel_delayed_work_sync(&hwsim->hw_scan);\r\nmutex_lock(&hwsim->mutex);\r\nieee80211_scan_completed(hwsim->hw, true);\r\nhwsim->tmp_chan = NULL;\r\nhwsim->hw_scan_request = NULL;\r\nhwsim->hw_scan_vif = NULL;\r\nmutex_unlock(&hwsim->mutex);\r\n}\r\nstatic void mac80211_hwsim_sw_scan(struct ieee80211_hw *hw)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\nmutex_lock(&hwsim->mutex);\r\nif (hwsim->scanning) {\r\nprintk(KERN_DEBUG "two hwsim sw_scans detected!\n");\r\ngoto out;\r\n}\r\nprintk(KERN_DEBUG "hwsim sw_scan request, prepping stuff\n");\r\nhwsim->scanning = true;\r\nout:\r\nmutex_unlock(&hwsim->mutex);\r\n}\r\nstatic void mac80211_hwsim_sw_scan_complete(struct ieee80211_hw *hw)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\nmutex_lock(&hwsim->mutex);\r\nprintk(KERN_DEBUG "hwsim sw_scan_complete\n");\r\nhwsim->scanning = false;\r\nmutex_unlock(&hwsim->mutex);\r\n}\r\nstatic void hw_roc_done(struct work_struct *work)\r\n{\r\nstruct mac80211_hwsim_data *hwsim =\r\ncontainer_of(work, struct mac80211_hwsim_data, roc_done.work);\r\nmutex_lock(&hwsim->mutex);\r\nieee80211_remain_on_channel_expired(hwsim->hw);\r\nhwsim->tmp_chan = NULL;\r\nmutex_unlock(&hwsim->mutex);\r\nwiphy_debug(hwsim->hw->wiphy, "hwsim ROC expired\n");\r\n}\r\nstatic int mac80211_hwsim_roc(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_channel *chan,\r\nint duration,\r\nenum ieee80211_roc_type type)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\nmutex_lock(&hwsim->mutex);\r\nif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\r\nmutex_unlock(&hwsim->mutex);\r\nreturn -EBUSY;\r\n}\r\nhwsim->tmp_chan = chan;\r\nmutex_unlock(&hwsim->mutex);\r\nwiphy_debug(hw->wiphy, "hwsim ROC (%d MHz, %d ms)\n",\r\nchan->center_freq, duration);\r\nieee80211_ready_on_channel(hw);\r\nieee80211_queue_delayed_work(hw, &hwsim->roc_done,\r\nmsecs_to_jiffies(duration));\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_croc(struct ieee80211_hw *hw)\r\n{\r\nstruct mac80211_hwsim_data *hwsim = hw->priv;\r\ncancel_delayed_work_sync(&hwsim->roc_done);\r\nmutex_lock(&hwsim->mutex);\r\nhwsim->tmp_chan = NULL;\r\nmutex_unlock(&hwsim->mutex);\r\nwiphy_debug(hw->wiphy, "hwsim ROC canceled\n");\r\nreturn 0;\r\n}\r\nstatic int mac80211_hwsim_add_chanctx(struct ieee80211_hw *hw,\r\nstruct ieee80211_chanctx_conf *ctx)\r\n{\r\nhwsim_set_chanctx_magic(ctx);\r\nwiphy_debug(hw->wiphy,\r\n"add channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\n",\r\nctx->def.chan->center_freq, ctx->def.width,\r\nctx->def.center_freq1, ctx->def.center_freq2);\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_remove_chanctx(struct ieee80211_hw *hw,\r\nstruct ieee80211_chanctx_conf *ctx)\r\n{\r\nwiphy_debug(hw->wiphy,\r\n"remove channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\n",\r\nctx->def.chan->center_freq, ctx->def.width,\r\nctx->def.center_freq1, ctx->def.center_freq2);\r\nhwsim_check_chanctx_magic(ctx);\r\nhwsim_clear_chanctx_magic(ctx);\r\n}\r\nstatic void mac80211_hwsim_change_chanctx(struct ieee80211_hw *hw,\r\nstruct ieee80211_chanctx_conf *ctx,\r\nu32 changed)\r\n{\r\nhwsim_check_chanctx_magic(ctx);\r\nwiphy_debug(hw->wiphy,\r\n"change channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\n",\r\nctx->def.chan->center_freq, ctx->def.width,\r\nctx->def.center_freq1, ctx->def.center_freq2);\r\n}\r\nstatic int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_chanctx_conf *ctx)\r\n{\r\nhwsim_check_magic(vif);\r\nhwsim_check_chanctx_magic(ctx);\r\nreturn 0;\r\n}\r\nstatic void mac80211_hwsim_unassign_vif_chanctx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_chanctx_conf *ctx)\r\n{\r\nhwsim_check_magic(vif);\r\nhwsim_check_chanctx_magic(ctx);\r\n}\r\nstatic void mac80211_hwsim_free(void)\r\n{\r\nstruct list_head tmplist, *i, *tmp;\r\nstruct mac80211_hwsim_data *data, *tmpdata;\r\nINIT_LIST_HEAD(&tmplist);\r\nspin_lock_bh(&hwsim_radio_lock);\r\nlist_for_each_safe(i, tmp, &hwsim_radios)\r\nlist_move(i, &tmplist);\r\nspin_unlock_bh(&hwsim_radio_lock);\r\nlist_for_each_entry_safe(data, tmpdata, &tmplist, list) {\r\ndebugfs_remove(data->debugfs_group);\r\ndebugfs_remove(data->debugfs_ps);\r\ndebugfs_remove(data->debugfs);\r\nieee80211_unregister_hw(data->hw);\r\ndevice_release_driver(data->dev);\r\ndevice_unregister(data->dev);\r\nieee80211_free_hw(data->hw);\r\n}\r\nclass_destroy(hwsim_class);\r\n}\r\nstatic void hwsim_mon_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &hwsim_netdev_ops;\r\ndev->destructor = free_netdev;\r\nether_setup(dev);\r\ndev->tx_queue_len = 0;\r\ndev->type = ARPHRD_IEEE80211_RADIOTAP;\r\nmemset(dev->dev_addr, 0, ETH_ALEN);\r\ndev->dev_addr[0] = 0x12;\r\n}\r\nstatic void hwsim_send_ps_poll(void *dat, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\nstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_pspoll *pspoll;\r\nif (!vp->assoc)\r\nreturn;\r\nwiphy_debug(data->hw->wiphy,\r\n"%s: send PS-Poll to %pM for aid %d\n",\r\n__func__, vp->bssid, vp->aid);\r\nskb = dev_alloc_skb(sizeof(*pspoll));\r\nif (!skb)\r\nreturn;\r\npspoll = (void *) skb_put(skb, sizeof(*pspoll));\r\npspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\r\nIEEE80211_STYPE_PSPOLL |\r\nIEEE80211_FCTL_PM);\r\npspoll->aid = cpu_to_le16(0xc000 | vp->aid);\r\nmemcpy(pspoll->bssid, vp->bssid, ETH_ALEN);\r\nmemcpy(pspoll->ta, mac, ETH_ALEN);\r\nrcu_read_lock();\r\nmac80211_hwsim_tx_frame(data->hw, skb,\r\nrcu_dereference(vif->chanctx_conf)->def.chan);\r\nrcu_read_unlock();\r\n}\r\nstatic void hwsim_send_nullfunc(struct mac80211_hwsim_data *data, u8 *mac,\r\nstruct ieee80211_vif *vif, int ps)\r\n{\r\nstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nif (!vp->assoc)\r\nreturn;\r\nwiphy_debug(data->hw->wiphy,\r\n"%s: send data::nullfunc to %pM ps=%d\n",\r\n__func__, vp->bssid, ps);\r\nskb = dev_alloc_skb(sizeof(*hdr));\r\nif (!skb)\r\nreturn;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr) - ETH_ALEN);\r\nhdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_NULLFUNC |\r\n(ps ? IEEE80211_FCTL_PM : 0));\r\nhdr->duration_id = cpu_to_le16(0);\r\nmemcpy(hdr->addr1, vp->bssid, ETH_ALEN);\r\nmemcpy(hdr->addr2, mac, ETH_ALEN);\r\nmemcpy(hdr->addr3, vp->bssid, ETH_ALEN);\r\nrcu_read_lock();\r\nmac80211_hwsim_tx_frame(data->hw, skb,\r\nrcu_dereference(vif->chanctx_conf)->def.chan);\r\nrcu_read_unlock();\r\n}\r\nstatic void hwsim_send_nullfunc_ps(void *dat, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\nhwsim_send_nullfunc(data, mac, vif, 1);\r\n}\r\nstatic void hwsim_send_nullfunc_no_ps(void *dat, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\nhwsim_send_nullfunc(data, mac, vif, 0);\r\n}\r\nstatic int hwsim_fops_ps_read(void *dat, u64 *val)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\n*val = data->ps;\r\nreturn 0;\r\n}\r\nstatic int hwsim_fops_ps_write(void *dat, u64 val)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\nenum ps_mode old_ps;\r\nif (val != PS_DISABLED && val != PS_ENABLED && val != PS_AUTO_POLL &&\r\nval != PS_MANUAL_POLL)\r\nreturn -EINVAL;\r\nold_ps = data->ps;\r\ndata->ps = val;\r\nif (val == PS_MANUAL_POLL) {\r\nieee80211_iterate_active_interfaces(data->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\nhwsim_send_ps_poll, data);\r\ndata->ps_poll_pending = true;\r\n} else if (old_ps == PS_DISABLED && val != PS_DISABLED) {\r\nieee80211_iterate_active_interfaces(data->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\nhwsim_send_nullfunc_ps,\r\ndata);\r\n} else if (old_ps != PS_DISABLED && val == PS_DISABLED) {\r\nieee80211_iterate_active_interfaces(data->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\nhwsim_send_nullfunc_no_ps,\r\ndata);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hwsim_fops_group_read(void *dat, u64 *val)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\n*val = data->group;\r\nreturn 0;\r\n}\r\nstatic int hwsim_fops_group_write(void *dat, u64 val)\r\n{\r\nstruct mac80211_hwsim_data *data = dat;\r\ndata->group = val;\r\nreturn 0;\r\n}\r\nstatic struct mac80211_hwsim_data *get_hwsim_data_ref_from_addr(\r\nstruct mac_address *addr)\r\n{\r\nstruct mac80211_hwsim_data *data;\r\nbool _found = false;\r\nspin_lock_bh(&hwsim_radio_lock);\r\nlist_for_each_entry(data, &hwsim_radios, list) {\r\nif (memcmp(data->addresses[1].addr, addr,\r\nsizeof(struct mac_address)) == 0) {\r\n_found = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&hwsim_radio_lock);\r\nif (!_found)\r\nreturn NULL;\r\nreturn data;\r\n}\r\nstatic int hwsim_tx_info_frame_received_nl(struct sk_buff *skb_2,\r\nstruct genl_info *info)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nstruct mac80211_hwsim_data *data2;\r\nstruct ieee80211_tx_info *txi;\r\nstruct hwsim_tx_rate *tx_attempts;\r\nunsigned long ret_skb_ptr;\r\nstruct sk_buff *skb, *tmp;\r\nstruct mac_address *src;\r\nunsigned int hwsim_flags;\r\nint i;\r\nbool found = false;\r\nif (!info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER] ||\r\n!info->attrs[HWSIM_ATTR_FLAGS] ||\r\n!info->attrs[HWSIM_ATTR_COOKIE] ||\r\n!info->attrs[HWSIM_ATTR_TX_INFO])\r\ngoto out;\r\nsrc = (struct mac_address *)nla_data(\r\ninfo->attrs[HWSIM_ATTR_ADDR_TRANSMITTER]);\r\nhwsim_flags = nla_get_u32(info->attrs[HWSIM_ATTR_FLAGS]);\r\nret_skb_ptr = nla_get_u64(info->attrs[HWSIM_ATTR_COOKIE]);\r\ndata2 = get_hwsim_data_ref_from_addr(src);\r\nif (data2 == NULL)\r\ngoto out;\r\nskb_queue_walk_safe(&data2->pending, skb, tmp) {\r\nif ((unsigned long)skb == ret_skb_ptr) {\r\nskb_unlink(skb, &data2->pending);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\ngoto out;\r\ntx_attempts = (struct hwsim_tx_rate *)nla_data(\r\ninfo->attrs[HWSIM_ATTR_TX_INFO]);\r\ntxi = IEEE80211_SKB_CB(skb);\r\nieee80211_tx_info_clear_status(txi);\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\ntxi->status.rates[i].idx = tx_attempts[i].idx;\r\ntxi->status.rates[i].count = tx_attempts[i].count;\r\n}\r\ntxi->status.ack_signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\r\nif (!(hwsim_flags & HWSIM_TX_CTL_NO_ACK) &&\r\n(hwsim_flags & HWSIM_TX_STAT_ACK)) {\r\nif (skb->len >= 16) {\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nmac80211_hwsim_monitor_ack(txi->rate_driver_data[0],\r\nhdr->addr2);\r\n}\r\ntxi->flags |= IEEE80211_TX_STAT_ACK;\r\n}\r\nieee80211_tx_status_irqsafe(data2->hw, skb);\r\nreturn 0;\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int hwsim_cloned_frame_received_nl(struct sk_buff *skb_2,\r\nstruct genl_info *info)\r\n{\r\nstruct mac80211_hwsim_data *data2;\r\nstruct ieee80211_rx_status rx_status;\r\nstruct mac_address *dst;\r\nint frame_data_len;\r\nchar *frame_data;\r\nstruct sk_buff *skb = NULL;\r\nif (!info->attrs[HWSIM_ATTR_ADDR_RECEIVER] ||\r\n!info->attrs[HWSIM_ATTR_FRAME] ||\r\n!info->attrs[HWSIM_ATTR_RX_RATE] ||\r\n!info->attrs[HWSIM_ATTR_SIGNAL])\r\ngoto out;\r\ndst = (struct mac_address *)nla_data(\r\ninfo->attrs[HWSIM_ATTR_ADDR_RECEIVER]);\r\nframe_data_len = nla_len(info->attrs[HWSIM_ATTR_FRAME]);\r\nframe_data = (char *)nla_data(info->attrs[HWSIM_ATTR_FRAME]);\r\nskb = alloc_skb(frame_data_len, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto err;\r\nif (frame_data_len <= IEEE80211_MAX_DATA_LEN) {\r\nmemcpy(skb_put(skb, frame_data_len), frame_data,\r\nframe_data_len);\r\n} else\r\ngoto err;\r\ndata2 = get_hwsim_data_ref_from_addr(dst);\r\nif (data2 == NULL)\r\ngoto out;\r\nif (data2->idle || !data2->started)\r\ngoto out;\r\nmemset(&rx_status, 0, sizeof(rx_status));\r\nrx_status.freq = data2->channel->center_freq;\r\nrx_status.band = data2->channel->band;\r\nrx_status.rate_idx = nla_get_u32(info->attrs[HWSIM_ATTR_RX_RATE]);\r\nrx_status.signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(data2->hw, skb);\r\nreturn 0;\r\nerr:\r\nprintk(KERN_DEBUG "mac80211_hwsim: error occurred in %s\n", __func__);\r\ngoto out;\r\nout:\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int hwsim_register_received_nl(struct sk_buff *skb_2,\r\nstruct genl_info *info)\r\n{\r\nif (info == NULL)\r\ngoto out;\r\nwmediumd_portid = info->snd_portid;\r\nprintk(KERN_DEBUG "mac80211_hwsim: received a REGISTER, "\r\n"switching to wmediumd mode with pid %d\n", info->snd_portid);\r\nreturn 0;\r\nout:\r\nprintk(KERN_DEBUG "mac80211_hwsim: error occurred in %s\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int mac80211_hwsim_netlink_notify(struct notifier_block *nb,\r\nunsigned long state,\r\nvoid *_notify)\r\n{\r\nstruct netlink_notify *notify = _notify;\r\nif (state != NETLINK_URELEASE)\r\nreturn NOTIFY_DONE;\r\nif (notify->portid == wmediumd_portid) {\r\nprintk(KERN_INFO "mac80211_hwsim: wmediumd released netlink"\r\n" socket, switching to perfect channel medium\n");\r\nwmediumd_portid = 0;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int hwsim_init_netlink(void)\r\n{\r\nint rc;\r\nif (channels > 1)\r\nreturn 0;\r\nprintk(KERN_INFO "mac80211_hwsim: initializing netlink\n");\r\nrc = genl_register_family_with_ops(&hwsim_genl_family,\r\nhwsim_ops, ARRAY_SIZE(hwsim_ops));\r\nif (rc)\r\ngoto failure;\r\nrc = netlink_register_notifier(&hwsim_netlink_notifier);\r\nif (rc)\r\ngoto failure;\r\nreturn 0;\r\nfailure:\r\nprintk(KERN_DEBUG "mac80211_hwsim: error occurred in %s\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic void hwsim_exit_netlink(void)\r\n{\r\nint ret;\r\nif (channels > 1)\r\nreturn;\r\nprintk(KERN_INFO "mac80211_hwsim: closing netlink\n");\r\nnetlink_unregister_notifier(&hwsim_netlink_notifier);\r\nret = genl_unregister_family(&hwsim_genl_family);\r\nif (ret)\r\nprintk(KERN_DEBUG "mac80211_hwsim: "\r\n"unregister family %i\n", ret);\r\n}\r\nstatic int __init init_mac80211_hwsim(void)\r\n{\r\nint i, err = 0;\r\nu8 addr[ETH_ALEN];\r\nstruct mac80211_hwsim_data *data;\r\nstruct ieee80211_hw *hw;\r\nenum ieee80211_band band;\r\nif (radios < 1 || radios > 100)\r\nreturn -EINVAL;\r\nif (channels < 1)\r\nreturn -EINVAL;\r\nif (channels > 1) {\r\nhwsim_if_comb.num_different_channels = channels;\r\nmac80211_hwsim_ops.hw_scan = mac80211_hwsim_hw_scan;\r\nmac80211_hwsim_ops.cancel_hw_scan =\r\nmac80211_hwsim_cancel_hw_scan;\r\nmac80211_hwsim_ops.sw_scan_start = NULL;\r\nmac80211_hwsim_ops.sw_scan_complete = NULL;\r\nmac80211_hwsim_ops.remain_on_channel =\r\nmac80211_hwsim_roc;\r\nmac80211_hwsim_ops.cancel_remain_on_channel =\r\nmac80211_hwsim_croc;\r\nmac80211_hwsim_ops.add_chanctx =\r\nmac80211_hwsim_add_chanctx;\r\nmac80211_hwsim_ops.remove_chanctx =\r\nmac80211_hwsim_remove_chanctx;\r\nmac80211_hwsim_ops.change_chanctx =\r\nmac80211_hwsim_change_chanctx;\r\nmac80211_hwsim_ops.assign_vif_chanctx =\r\nmac80211_hwsim_assign_vif_chanctx;\r\nmac80211_hwsim_ops.unassign_vif_chanctx =\r\nmac80211_hwsim_unassign_vif_chanctx;\r\n}\r\nspin_lock_init(&hwsim_radio_lock);\r\nINIT_LIST_HEAD(&hwsim_radios);\r\nerr = platform_driver_register(&mac80211_hwsim_driver);\r\nif (err)\r\nreturn err;\r\nhwsim_class = class_create(THIS_MODULE, "mac80211_hwsim");\r\nif (IS_ERR(hwsim_class)) {\r\nerr = PTR_ERR(hwsim_class);\r\ngoto failed_unregister_driver;\r\n}\r\nmemset(addr, 0, ETH_ALEN);\r\naddr[0] = 0x02;\r\nfor (i = 0; i < radios; i++) {\r\nprintk(KERN_DEBUG "mac80211_hwsim: Initializing radio %d\n",\r\ni);\r\nhw = ieee80211_alloc_hw(sizeof(*data), &mac80211_hwsim_ops);\r\nif (!hw) {\r\nprintk(KERN_DEBUG "mac80211_hwsim: ieee80211_alloc_hw "\r\n"failed\n");\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\ndata = hw->priv;\r\ndata->hw = hw;\r\ndata->dev = device_create(hwsim_class, NULL, 0, hw,\r\n"hwsim%d", i);\r\nif (IS_ERR(data->dev)) {\r\nprintk(KERN_DEBUG\r\n"mac80211_hwsim: device_create failed (%ld)\n",\r\nPTR_ERR(data->dev));\r\nerr = -ENOMEM;\r\ngoto failed_drvdata;\r\n}\r\ndata->dev->driver = &mac80211_hwsim_driver.driver;\r\nerr = device_bind_driver(data->dev);\r\nif (err != 0) {\r\nprintk(KERN_DEBUG\r\n"mac80211_hwsim: device_bind_driver failed (%d)\n",\r\nerr);\r\ngoto failed_hw;\r\n}\r\nskb_queue_head_init(&data->pending);\r\nSET_IEEE80211_DEV(hw, data->dev);\r\naddr[3] = i >> 8;\r\naddr[4] = i;\r\nmemcpy(data->addresses[0].addr, addr, ETH_ALEN);\r\nmemcpy(data->addresses[1].addr, addr, ETH_ALEN);\r\ndata->addresses[1].addr[0] |= 0x40;\r\nhw->wiphy->n_addresses = 2;\r\nhw->wiphy->addresses = data->addresses;\r\nhw->wiphy->iface_combinations = &hwsim_if_comb;\r\nhw->wiphy->n_iface_combinations = 1;\r\nif (channels > 1) {\r\nhw->wiphy->max_scan_ssids = 255;\r\nhw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\r\nhw->wiphy->max_remain_on_channel_duration = 1000;\r\n}\r\nINIT_DELAYED_WORK(&data->roc_done, hw_roc_done);\r\nINIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);\r\nhw->channel_change_time = 1;\r\nhw->queues = 5;\r\nhw->offchannel_tx_hw_queue = 4;\r\nhw->wiphy->interface_modes =\r\nBIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_AP) |\r\nBIT(NL80211_IFTYPE_P2P_CLIENT) |\r\nBIT(NL80211_IFTYPE_P2P_GO) |\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\nBIT(NL80211_IFTYPE_MESH_POINT) |\r\nBIT(NL80211_IFTYPE_P2P_DEVICE);\r\nhw->flags = IEEE80211_HW_MFP_CAPABLE |\r\nIEEE80211_HW_SIGNAL_DBM |\r\nIEEE80211_HW_SUPPORTS_STATIC_SMPS |\r\nIEEE80211_HW_SUPPORTS_DYNAMIC_SMPS |\r\nIEEE80211_HW_AMPDU_AGGREGATION |\r\nIEEE80211_HW_WANT_MONITOR_VIF |\r\nIEEE80211_HW_QUEUE_CONTROL;\r\nif (rctbl)\r\nhw->flags |= IEEE80211_HW_SUPPORTS_RC_TABLE;\r\nhw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\r\nWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\r\nhw->vif_data_size = sizeof(struct hwsim_vif_priv);\r\nhw->sta_data_size = sizeof(struct hwsim_sta_priv);\r\nhw->chanctx_data_size = sizeof(struct hwsim_chanctx_priv);\r\nmemcpy(data->channels_2ghz, hwsim_channels_2ghz,\r\nsizeof(hwsim_channels_2ghz));\r\nmemcpy(data->channels_5ghz, hwsim_channels_5ghz,\r\nsizeof(hwsim_channels_5ghz));\r\nmemcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));\r\nfor (band = IEEE80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; band++) {\r\nstruct ieee80211_supported_band *sband = &data->bands[band];\r\nswitch (band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nsband->channels = data->channels_2ghz;\r\nsband->n_channels =\r\nARRAY_SIZE(hwsim_channels_2ghz);\r\nsband->bitrates = data->rates;\r\nsband->n_bitrates = ARRAY_SIZE(hwsim_rates);\r\nbreak;\r\ncase IEEE80211_BAND_5GHZ:\r\nsband->channels = data->channels_5ghz;\r\nsband->n_channels =\r\nARRAY_SIZE(hwsim_channels_5ghz);\r\nsband->bitrates = data->rates + 4;\r\nsband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nsband->ht_cap.ht_supported = true;\r\nsband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\r\nIEEE80211_HT_CAP_GRN_FLD |\r\nIEEE80211_HT_CAP_SGI_40 |\r\nIEEE80211_HT_CAP_DSSSCCK40;\r\nsband->ht_cap.ampdu_factor = 0x3;\r\nsband->ht_cap.ampdu_density = 0x6;\r\nmemset(&sband->ht_cap.mcs, 0,\r\nsizeof(sband->ht_cap.mcs));\r\nsband->ht_cap.mcs.rx_mask[0] = 0xff;\r\nsband->ht_cap.mcs.rx_mask[1] = 0xff;\r\nsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\nhw->wiphy->bands[band] = sband;\r\nsband->vht_cap.vht_supported = true;\r\nsband->vht_cap.cap =\r\nIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\r\nIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |\r\nIEEE80211_VHT_CAP_RXLDPC |\r\nIEEE80211_VHT_CAP_SHORT_GI_80 |\r\nIEEE80211_VHT_CAP_SHORT_GI_160 |\r\nIEEE80211_VHT_CAP_TXSTBC |\r\nIEEE80211_VHT_CAP_RXSTBC_1 |\r\nIEEE80211_VHT_CAP_RXSTBC_2 |\r\nIEEE80211_VHT_CAP_RXSTBC_3 |\r\nIEEE80211_VHT_CAP_RXSTBC_4 |\r\nIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\r\nsband->vht_cap.vht_mcs.rx_mcs_map =\r\ncpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_8 << 0 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_8 << 2 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_9 << 4 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_8 << 6 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_8 << 8 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_9 << 10 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_9 << 12 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_8 << 14);\r\nsband->vht_cap.vht_mcs.tx_mcs_map =\r\nsband->vht_cap.vht_mcs.rx_mcs_map;\r\n}\r\ndata->group = 1;\r\nmutex_init(&data->mutex);\r\nhw->max_rates = 4;\r\nhw->max_rate_tries = 11;\r\nswitch (regtest) {\r\ncase HWSIM_REGTEST_DISABLED:\r\ncase HWSIM_REGTEST_DRIVER_REG_FOLLOW:\r\ncase HWSIM_REGTEST_DRIVER_REG_ALL:\r\ncase HWSIM_REGTEST_DIFF_COUNTRY:\r\nbreak;\r\ncase HWSIM_REGTEST_WORLD_ROAM:\r\nif (i == 0) {\r\nhw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(hw->wiphy,\r\n&hwsim_world_regdom_custom_01);\r\n}\r\nbreak;\r\ncase HWSIM_REGTEST_CUSTOM_WORLD:\r\nhw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(hw->wiphy,\r\n&hwsim_world_regdom_custom_01);\r\nbreak;\r\ncase HWSIM_REGTEST_CUSTOM_WORLD_2:\r\nif (i == 0) {\r\nhw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(hw->wiphy,\r\n&hwsim_world_regdom_custom_01);\r\n} else if (i == 1) {\r\nhw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(hw->wiphy,\r\n&hwsim_world_regdom_custom_02);\r\n}\r\nbreak;\r\ncase HWSIM_REGTEST_STRICT_ALL:\r\nhw->wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;\r\nbreak;\r\ncase HWSIM_REGTEST_STRICT_FOLLOW:\r\ncase HWSIM_REGTEST_STRICT_AND_DRIVER_REG:\r\nif (i == 0)\r\nhw->wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;\r\nbreak;\r\ncase HWSIM_REGTEST_ALL:\r\nif (i == 0) {\r\nhw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(hw->wiphy,\r\n&hwsim_world_regdom_custom_01);\r\n} else if (i == 1) {\r\nhw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(hw->wiphy,\r\n&hwsim_world_regdom_custom_02);\r\n} else if (i == 4)\r\nhw->wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (regtest)\r\nschedule_timeout_interruptible(1);\r\nerr = ieee80211_register_hw(hw);\r\nif (err < 0) {\r\nprintk(KERN_DEBUG "mac80211_hwsim: "\r\n"ieee80211_register_hw failed (%d)\n", err);\r\ngoto failed_hw;\r\n}\r\nswitch (regtest) {\r\ncase HWSIM_REGTEST_WORLD_ROAM:\r\ncase HWSIM_REGTEST_DISABLED:\r\nbreak;\r\ncase HWSIM_REGTEST_DRIVER_REG_FOLLOW:\r\nif (!i)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[0]);\r\nbreak;\r\ncase HWSIM_REGTEST_DRIVER_REG_ALL:\r\ncase HWSIM_REGTEST_STRICT_ALL:\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[0]);\r\nbreak;\r\ncase HWSIM_REGTEST_DIFF_COUNTRY:\r\nif (i < ARRAY_SIZE(hwsim_alpha2s))\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[i]);\r\nbreak;\r\ncase HWSIM_REGTEST_CUSTOM_WORLD:\r\ncase HWSIM_REGTEST_CUSTOM_WORLD_2:\r\nbreak;\r\ncase HWSIM_REGTEST_STRICT_FOLLOW:\r\nif (i == 0)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[0]);\r\nbreak;\r\ncase HWSIM_REGTEST_STRICT_AND_DRIVER_REG:\r\nif (i == 0)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[0]);\r\nelse if (i == 1)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[1]);\r\nbreak;\r\ncase HWSIM_REGTEST_ALL:\r\nif (i == 2)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[0]);\r\nelse if (i == 3)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[1]);\r\nelse if (i == 4)\r\nregulatory_hint(hw->wiphy, hwsim_alpha2s[2]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwiphy_debug(hw->wiphy, "hwaddr %pm registered\n",\r\nhw->wiphy->perm_addr);\r\ndata->debugfs = debugfs_create_dir("hwsim",\r\nhw->wiphy->debugfsdir);\r\ndata->debugfs_ps = debugfs_create_file("ps", 0666,\r\ndata->debugfs, data,\r\n&hwsim_fops_ps);\r\ndata->debugfs_group = debugfs_create_file("group", 0666,\r\ndata->debugfs, data,\r\n&hwsim_fops_group);\r\ntasklet_hrtimer_init(&data->beacon_timer,\r\nmac80211_hwsim_beacon,\r\nCLOCK_REALTIME, HRTIMER_MODE_ABS);\r\nlist_add_tail(&data->list, &hwsim_radios);\r\n}\r\nhwsim_mon = alloc_netdev(0, "hwsim%d", hwsim_mon_setup);\r\nif (hwsim_mon == NULL)\r\ngoto failed;\r\nrtnl_lock();\r\nerr = dev_alloc_name(hwsim_mon, hwsim_mon->name);\r\nif (err < 0)\r\ngoto failed_mon;\r\nerr = register_netdevice(hwsim_mon);\r\nif (err < 0)\r\ngoto failed_mon;\r\nrtnl_unlock();\r\nerr = hwsim_init_netlink();\r\nif (err < 0)\r\ngoto failed_nl;\r\nreturn 0;\r\nfailed_nl:\r\nprintk(KERN_DEBUG "mac_80211_hwsim: failed initializing netlink\n");\r\nreturn err;\r\nfailed_mon:\r\nrtnl_unlock();\r\nfree_netdev(hwsim_mon);\r\nmac80211_hwsim_free();\r\nreturn err;\r\nfailed_hw:\r\ndevice_unregister(data->dev);\r\nfailed_drvdata:\r\nieee80211_free_hw(hw);\r\nfailed:\r\nmac80211_hwsim_free();\r\nfailed_unregister_driver:\r\nplatform_driver_unregister(&mac80211_hwsim_driver);\r\nreturn err;\r\n}\r\nstatic void __exit exit_mac80211_hwsim(void)\r\n{\r\nprintk(KERN_DEBUG "mac80211_hwsim: unregister radios\n");\r\nhwsim_exit_netlink();\r\nmac80211_hwsim_free();\r\nunregister_netdev(hwsim_mon);\r\nplatform_driver_unregister(&mac80211_hwsim_driver);\r\n}
