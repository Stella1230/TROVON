bool pxa2xx_spi_dma_is_possible(size_t len)\r\n{\r\nreturn len > 0 && len <= MAX_DMA_LEN;\r\n}\r\nint pxa2xx_spi_map_dma_buffers(struct driver_data *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nstruct device *dev = &msg->spi->dev;\r\nif (!drv_data->cur_chip->enable_dma)\r\nreturn 0;\r\nif (msg->is_dma_mapped)\r\nreturn drv_data->rx_dma && drv_data->tx_dma;\r\nif (!IS_DMA_ALIGNED(drv_data->rx) || !IS_DMA_ALIGNED(drv_data->tx))\r\nreturn 0;\r\nif (drv_data->rx == NULL) {\r\n*drv_data->null_dma_buf = 0;\r\ndrv_data->rx = drv_data->null_dma_buf;\r\ndrv_data->rx_map_len = 4;\r\n} else\r\ndrv_data->rx_map_len = drv_data->len;\r\nif (drv_data->tx == NULL) {\r\n*drv_data->null_dma_buf = 0;\r\ndrv_data->tx = drv_data->null_dma_buf;\r\ndrv_data->tx_map_len = 4;\r\n} else\r\ndrv_data->tx_map_len = drv_data->len;\r\ndrv_data->tx_dma = dma_map_single(dev, drv_data->tx,\r\ndrv_data->tx_map_len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, drv_data->tx_dma))\r\nreturn 0;\r\ndrv_data->rx_dma = dma_map_single(dev, drv_data->rx,\r\ndrv_data->rx_map_len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, drv_data->rx_dma)) {\r\ndma_unmap_single(dev, drv_data->tx_dma,\r\ndrv_data->tx_map_len, DMA_TO_DEVICE);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void pxa2xx_spi_unmap_dma_buffers(struct driver_data *drv_data)\r\n{\r\nstruct device *dev;\r\nif (!drv_data->dma_mapped)\r\nreturn;\r\nif (!drv_data->cur_msg->is_dma_mapped) {\r\ndev = &drv_data->cur_msg->spi->dev;\r\ndma_unmap_single(dev, drv_data->rx_dma,\r\ndrv_data->rx_map_len, DMA_FROM_DEVICE);\r\ndma_unmap_single(dev, drv_data->tx_dma,\r\ndrv_data->tx_map_len, DMA_TO_DEVICE);\r\n}\r\ndrv_data->dma_mapped = 0;\r\n}\r\nstatic int wait_ssp_rx_stall(void const __iomem *ioaddr)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nwhile ((read_SSSR(ioaddr) & SSSR_BSY) && --limit)\r\ncpu_relax();\r\nreturn limit;\r\n}\r\nstatic int wait_dma_channel_stop(int channel)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nwhile (!(DCSR(channel) & DCSR_STOPSTATE) && --limit)\r\ncpu_relax();\r\nreturn limit;\r\n}\r\nstatic void pxa2xx_spi_dma_error_stop(struct driver_data *drv_data,\r\nconst char *msg)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nDCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;\r\nDCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nwrite_SSCR1(read_SSCR1(reg) & ~drv_data->dma_cr1, reg);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\npxa2xx_spi_flush(drv_data);\r\nwrite_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);\r\npxa2xx_spi_unmap_dma_buffers(drv_data);\r\ndev_err(&drv_data->pdev->dev, "%s\n", msg);\r\ndrv_data->cur_msg->state = ERROR_STATE;\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void pxa2xx_spi_dma_transfer_complete(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nwrite_SSCR1(read_SSCR1(reg) & ~drv_data->dma_cr1, reg);\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nDCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;\r\nDCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;\r\nif (wait_dma_channel_stop(drv_data->rx_channel) == 0)\r\ndev_err(&drv_data->pdev->dev,\r\n"dma_handler: dma rx channel stop failed\n");\r\nif (wait_ssp_rx_stall(drv_data->ioaddr) == 0)\r\ndev_err(&drv_data->pdev->dev,\r\n"dma_transfer: ssp rx stall failed\n");\r\npxa2xx_spi_unmap_dma_buffers(drv_data);\r\ndrv_data->rx += drv_data->len -\r\n(DCMD(drv_data->rx_channel) & DCMD_LENGTH);\r\ndrv_data->read(drv_data);\r\nmsg->actual_length += drv_data->len -\r\n(drv_data->rx_end - drv_data->rx);\r\nmsg->state = pxa2xx_spi_next_transfer(drv_data);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nvoid pxa2xx_spi_dma_handler(int channel, void *data)\r\n{\r\nstruct driver_data *drv_data = data;\r\nu32 irq_status = DCSR(channel) & DMA_INT_MASK;\r\nif (irq_status & DCSR_BUSERR) {\r\nif (channel == drv_data->tx_channel)\r\npxa2xx_spi_dma_error_stop(drv_data,\r\n"dma_handler: bad bus address on tx channel");\r\nelse\r\npxa2xx_spi_dma_error_stop(drv_data,\r\n"dma_handler: bad bus address on rx channel");\r\nreturn;\r\n}\r\nif ((channel == drv_data->tx_channel)\r\n&& (irq_status & DCSR_ENDINTR)\r\n&& (drv_data->ssp_type == PXA25x_SSP)) {\r\nif (wait_ssp_rx_stall(drv_data->ioaddr) == 0)\r\ndev_err(&drv_data->pdev->dev,\r\n"dma_handler: ssp rx stall failed\n");\r\npxa2xx_spi_dma_transfer_complete(drv_data);\r\n}\r\n}\r\nirqreturn_t pxa2xx_spi_dma_transfer(struct driver_data *drv_data)\r\n{\r\nu32 irq_status;\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nirq_status = read_SSSR(reg) & drv_data->mask_sr;\r\nif (irq_status & SSSR_ROR) {\r\npxa2xx_spi_dma_error_stop(drv_data,\r\n"dma_transfer: fifo overrun");\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((irq_status & SSSR_TINT)\r\n&& (DCSR(drv_data->tx_channel) & DCSR_RUN)) {\r\nwrite_SSSR(SSSR_TINT, reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (irq_status & SSSR_TINT || drv_data->rx == drv_data->rx_end) {\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\npxa2xx_spi_dma_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nint pxa2xx_spi_dma_prepare(struct driver_data *drv_data, u32 dma_burst)\r\n{\r\nu32 dma_width;\r\nswitch (drv_data->n_bytes) {\r\ncase 1:\r\ndma_width = DCMD_WIDTH1;\r\nbreak;\r\ncase 2:\r\ndma_width = DCMD_WIDTH2;\r\nbreak;\r\ndefault:\r\ndma_width = DCMD_WIDTH4;\r\nbreak;\r\n}\r\nDCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;\r\nDSADR(drv_data->rx_channel) = drv_data->ssdr_physical;\r\nDTADR(drv_data->rx_channel) = drv_data->rx_dma;\r\nif (drv_data->rx == drv_data->null_dma_buf)\r\nDCMD(drv_data->rx_channel) = DCMD_FLOWSRC\r\n| dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nelse\r\nDCMD(drv_data->rx_channel) = DCMD_INCTRGADDR\r\n| DCMD_FLOWSRC\r\n| dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nDCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;\r\nDSADR(drv_data->tx_channel) = drv_data->tx_dma;\r\nDTADR(drv_data->tx_channel) = drv_data->ssdr_physical;\r\nif (drv_data->tx == drv_data->null_dma_buf)\r\nDCMD(drv_data->tx_channel) = DCMD_FLOWTRG\r\n| dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nelse\r\nDCMD(drv_data->tx_channel) = DCMD_INCSRCADDR\r\n| DCMD_FLOWTRG\r\n| dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nif (drv_data->ssp_type == PXA25x_SSP)\r\nDCMD(drv_data->tx_channel) |= DCMD_ENDIRQEN;\r\nreturn 0;\r\n}\r\nvoid pxa2xx_spi_dma_start(struct driver_data *drv_data)\r\n{\r\nDCSR(drv_data->rx_channel) |= DCSR_RUN;\r\nDCSR(drv_data->tx_channel) |= DCSR_RUN;\r\n}\r\nint pxa2xx_spi_dma_setup(struct driver_data *drv_data)\r\n{\r\nstruct device *dev = &drv_data->pdev->dev;\r\nstruct ssp_device *ssp = drv_data->ssp;\r\ndrv_data->rx_channel = pxa_request_dma("pxa2xx_spi_ssp_rx",\r\nDMA_PRIO_HIGH,\r\npxa2xx_spi_dma_handler,\r\ndrv_data);\r\nif (drv_data->rx_channel < 0) {\r\ndev_err(dev, "problem (%d) requesting rx channel\n",\r\ndrv_data->rx_channel);\r\nreturn -ENODEV;\r\n}\r\ndrv_data->tx_channel = pxa_request_dma("pxa2xx_spi_ssp_tx",\r\nDMA_PRIO_MEDIUM,\r\npxa2xx_spi_dma_handler,\r\ndrv_data);\r\nif (drv_data->tx_channel < 0) {\r\ndev_err(dev, "problem (%d) requesting tx channel\n",\r\ndrv_data->tx_channel);\r\npxa_free_dma(drv_data->rx_channel);\r\nreturn -ENODEV;\r\n}\r\nDRCMR(ssp->drcmr_rx) = DRCMR_MAPVLD | drv_data->rx_channel;\r\nDRCMR(ssp->drcmr_tx) = DRCMR_MAPVLD | drv_data->tx_channel;\r\nreturn 0;\r\n}\r\nvoid pxa2xx_spi_dma_release(struct driver_data *drv_data)\r\n{\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nDRCMR(ssp->drcmr_rx) = 0;\r\nDRCMR(ssp->drcmr_tx) = 0;\r\nif (drv_data->tx_channel != 0)\r\npxa_free_dma(drv_data->tx_channel);\r\nif (drv_data->rx_channel != 0)\r\npxa_free_dma(drv_data->rx_channel);\r\n}\r\nvoid pxa2xx_spi_dma_resume(struct driver_data *drv_data)\r\n{\r\nif (drv_data->rx_channel != -1)\r\nDRCMR(drv_data->ssp->drcmr_rx) =\r\nDRCMR_MAPVLD | drv_data->rx_channel;\r\nif (drv_data->tx_channel != -1)\r\nDRCMR(drv_data->ssp->drcmr_tx) =\r\nDRCMR_MAPVLD | drv_data->tx_channel;\r\n}\r\nint pxa2xx_spi_set_dma_burst_and_threshold(struct chip_data *chip,\r\nstruct spi_device *spi,\r\nu8 bits_per_word, u32 *burst_code,\r\nu32 *threshold)\r\n{\r\nstruct pxa2xx_spi_chip *chip_info =\r\n(struct pxa2xx_spi_chip *)spi->controller_data;\r\nint bytes_per_word;\r\nint burst_bytes;\r\nint thresh_words;\r\nint req_burst_size;\r\nint retval = 0;\r\nif (bits_per_word <= 8)\r\nbytes_per_word = 1;\r\nelse if (bits_per_word <= 16)\r\nbytes_per_word = 2;\r\nelse\r\nbytes_per_word = 4;\r\nif (chip_info)\r\nreq_burst_size = chip_info->dma_burst_size;\r\nelse {\r\nswitch (chip->dma_burst_size) {\r\ndefault:\r\nchip->dma_burst_size = DCMD_BURST8;\r\ncase DCMD_BURST8:\r\nreq_burst_size = 8;\r\nbreak;\r\ncase DCMD_BURST16:\r\nreq_burst_size = 16;\r\nbreak;\r\ncase DCMD_BURST32:\r\nreq_burst_size = 32;\r\nbreak;\r\n}\r\n}\r\nif (req_burst_size <= 8) {\r\n*burst_code = DCMD_BURST8;\r\nburst_bytes = 8;\r\n} else if (req_burst_size <= 16) {\r\nif (bytes_per_word == 1) {\r\n*burst_code = DCMD_BURST8;\r\nburst_bytes = 8;\r\nretval = 1;\r\n} else {\r\n*burst_code = DCMD_BURST16;\r\nburst_bytes = 16;\r\n}\r\n} else {\r\nif (bytes_per_word == 1) {\r\n*burst_code = DCMD_BURST8;\r\nburst_bytes = 8;\r\nretval = 1;\r\n} else if (bytes_per_word == 2) {\r\n*burst_code = DCMD_BURST16;\r\nburst_bytes = 16;\r\nretval = 1;\r\n} else {\r\n*burst_code = DCMD_BURST32;\r\nburst_bytes = 32;\r\n}\r\n}\r\nthresh_words = burst_bytes / bytes_per_word;\r\n*threshold = (SSCR1_RxTresh(thresh_words) & SSCR1_RFT)\r\n| (SSCR1_TxTresh(16-thresh_words) & SSCR1_TFT);\r\nreturn retval;\r\n}
