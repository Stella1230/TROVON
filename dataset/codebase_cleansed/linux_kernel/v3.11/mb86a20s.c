static int mb86a20s_i2c_writereg(struct mb86a20s_state *state,\r\nu8 i2c_addr, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\r\n};\r\nint rc;\r\nrc = i2c_transfer(state->i2c, &msg, 1);\r\nif (rc != 1) {\r\ndev_err(&state->i2c->dev,\r\n"%s: writereg error (rc == %i, reg == 0x%02x, data == 0x%02x)\n",\r\n__func__, rc, reg, data);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_i2c_writeregdata(struct mb86a20s_state *state,\r\nu8 i2c_addr, struct regdata *rd, int size)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < size; i++) {\r\nrc = mb86a20s_i2c_writereg(state, i2c_addr, rd[i].reg,\r\nrd[i].data);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_i2c_readreg(struct mb86a20s_state *state,\r\nu8 i2c_addr, u8 reg)\r\n{\r\nu8 val;\r\nint rc;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\r\n};\r\nrc = i2c_transfer(state->i2c, msg, 2);\r\nif (rc != 2) {\r\ndev_err(&state->i2c->dev, "%s: reg=0x%x (error=%d)\n",\r\n__func__, reg, rc);\r\nreturn (rc < 0) ? rc : -EIO;\r\n}\r\nreturn val;\r\n}\r\nstatic int mb86a20s_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint val;\r\n*status = 0;\r\nval = mb86a20s_readreg(state, 0x0a) & 0xf;\r\nif (val < 0)\r\nreturn val;\r\nif (val >= 2)\r\n*status |= FE_HAS_SIGNAL;\r\nif (val >= 4)\r\n*status |= FE_HAS_CARRIER;\r\nif (val >= 5)\r\n*status |= FE_HAS_VITERBI;\r\nif (val >= 7)\r\n*status |= FE_HAS_SYNC;\r\nif (val >= 8)\r\n*status |= FE_HAS_LOCK;\r\ndev_dbg(&state->i2c->dev, "%s: Status = 0x%02x (state = %d)\n",\r\n__func__, *status, val);\r\nreturn val;\r\n}\r\nstatic int mb86a20s_read_signal_strength(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc;\r\nunsigned rf_max, rf_min, rf;\r\nif (state->get_strength_time &&\r\n(!time_after(jiffies, state->get_strength_time)))\r\nreturn c->strength.stat[0].uvalue;\r\nc->strength.stat[0].uvalue = 0;\r\nrf_max = 0xfff;\r\nrf_min = 0;\r\ndo {\r\nrf = (rf_max + rf_min) / 2;\r\nrc = mb86a20s_writereg(state, 0x04, 0x1f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x05, rf >> 8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x04, 0x20);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x05, rf);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x02);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc & 0x08)\r\nrf_min = (rf_max + rf_min) / 2;\r\nelse\r\nrf_max = (rf_max + rf_min) / 2;\r\nif (rf_max - rf_min < 4) {\r\nrf = (rf_max + rf_min) / 2;\r\nrf = rf << (16 - 12);\r\nif (rf)\r\nrf |= (1 << 12) - 1;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: signal strength = %d (%d < RF=%d < %d)\n",\r\n__func__, rf, rf_min, rf >> 4, rf_max);\r\nc->strength.stat[0].uvalue = rf;\r\nstate->get_strength_time = jiffies +\r\nmsecs_to_jiffies(1000);\r\nreturn 0;\r\n}\r\n} while (1);\r\n}\r\nstatic int mb86a20s_get_modulation(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x86,\r\n[1] = 0x8a,\r\n[2] = 0x8e,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch ((rc >> 4) & 0x07) {\r\ncase 0:\r\nreturn DQPSK;\r\ncase 1:\r\nreturn QPSK;\r\ncase 2:\r\nreturn QAM_16;\r\ncase 3:\r\nreturn QAM_64;\r\ndefault:\r\nreturn QAM_AUTO;\r\n}\r\n}\r\nstatic int mb86a20s_get_fec(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x87,\r\n[1] = 0x8b,\r\n[2] = 0x8f,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch ((rc >> 4) & 0x07) {\r\ncase 0:\r\nreturn FEC_1_2;\r\ncase 1:\r\nreturn FEC_2_3;\r\ncase 2:\r\nreturn FEC_3_4;\r\ncase 3:\r\nreturn FEC_5_6;\r\ncase 4:\r\nreturn FEC_7_8;\r\ndefault:\r\nreturn FEC_AUTO;\r\n}\r\n}\r\nstatic int mb86a20s_get_interleaving(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x88,\r\n[1] = 0x8c,\r\n[2] = 0x90,\r\n};\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch ((rc >> 4) & 0x07) {\r\ncase 1:\r\nreturn GUARD_INTERVAL_1_4;\r\ncase 2:\r\nreturn GUARD_INTERVAL_1_8;\r\ncase 3:\r\nreturn GUARD_INTERVAL_1_16;\r\ncase 4:\r\nreturn GUARD_INTERVAL_1_32;\r\ndefault:\r\ncase 0:\r\nreturn GUARD_INTERVAL_AUTO;\r\n}\r\n}\r\nstatic int mb86a20s_get_segment_count(struct mb86a20s_state *state,\r\nunsigned layer)\r\n{\r\nint rc, count;\r\nstatic unsigned char reg[] = {\r\n[0] = 0x89,\r\n[1] = 0x8d,\r\n[2] = 0x91,\r\n};\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (layer >= ARRAY_SIZE(reg))\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x6d, reg[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\ncount = (rc >> 4) & 0x0f;\r\ndev_dbg(&state->i2c->dev, "%s: segments: %d.\n", __func__, count);\r\nreturn count;\r\n}\r\nstatic void mb86a20s_reset_frontend_cache(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nc->delivery_system = SYS_ISDBT;\r\nc->bandwidth_hz = 6000000;\r\nc->isdbt_layer_enabled = 0;\r\nc->transmission_mode = TRANSMISSION_MODE_AUTO;\r\nc->guard_interval = GUARD_INTERVAL_AUTO;\r\nc->isdbt_sb_mode = 0;\r\nc->isdbt_sb_segment_count = 0;\r\n}\r\nstatic void mb86a20s_layer_bitrate(struct dvb_frontend *fe, u32 layer,\r\nu32 modulation, u32 forward_error_correction,\r\nu32 interleaving,\r\nu32 segment)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nu32 rate;\r\nint mod, fec, guard;\r\nswitch (modulation) {\r\ncase DQPSK:\r\ncase QPSK:\r\ndefault:\r\nmod = 0;\r\nbreak;\r\ncase QAM_16:\r\nmod = 1;\r\nbreak;\r\ncase QAM_64:\r\nmod = 2;\r\nbreak;\r\n}\r\nswitch (forward_error_correction) {\r\ndefault:\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\nfec = 0;\r\nbreak;\r\ncase FEC_2_3:\r\nfec = 1;\r\nbreak;\r\ncase FEC_3_4:\r\nfec = 2;\r\nbreak;\r\ncase FEC_5_6:\r\nfec = 3;\r\nbreak;\r\ncase FEC_7_8:\r\nfec = 4;\r\nbreak;\r\n}\r\nswitch (interleaving) {\r\ndefault:\r\ncase GUARD_INTERVAL_1_4:\r\nguard = 0;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nguard = 1;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nguard = 2;\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\nguard = 3;\r\nbreak;\r\n}\r\nrate = isdbt_rate[mod][fec][guard] * segment * BER_SAMPLING_RATE;\r\nif (rate < 256)\r\nrate = 256;\r\nelse if (rate > (1 << 24) - 1)\r\nrate = (1 << 24) - 1;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: layer %c bitrate: %d kbps; counter = %d (0x%06x)\n",\r\n__func__, 'A' + layer,\r\nsegment * isdbt_rate[mod][fec][guard]/1000,\r\nrate, rate);\r\nstate->estimated_rate[layer] = rate;\r\n}\r\nstatic int mb86a20s_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint layer, rc;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nmb86a20s_reset_frontend_cache(fe);\r\nrc = mb86a20s_writereg(state, 0x6d, 0x85);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x6e);\r\nif (rc < 0)\r\nreturn rc;\r\nc->isdbt_partial_reception = (rc & 0x10) ? 1 : 0;\r\nfor (layer = 0; layer < NUM_LAYERS; layer++) {\r\ndev_dbg(&state->i2c->dev, "%s: getting data for layer %c.\n",\r\n__func__, 'A' + layer);\r\nrc = mb86a20s_get_segment_count(state, layer);\r\nif (rc < 0)\r\ngoto noperlayer_error;\r\nif (rc >= 0 && rc < 14) {\r\nc->layer[layer].segment_count = rc;\r\n} else {\r\nc->layer[layer].segment_count = 0;\r\nstate->estimated_rate[layer] = 0;\r\ncontinue;\r\n}\r\nc->isdbt_layer_enabled |= 1 << layer;\r\nrc = mb86a20s_get_modulation(state, layer);\r\nif (rc < 0)\r\ngoto noperlayer_error;\r\ndev_dbg(&state->i2c->dev, "%s: modulation %d.\n",\r\n__func__, rc);\r\nc->layer[layer].modulation = rc;\r\nrc = mb86a20s_get_fec(state, layer);\r\nif (rc < 0)\r\ngoto noperlayer_error;\r\ndev_dbg(&state->i2c->dev, "%s: FEC %d.\n",\r\n__func__, rc);\r\nc->layer[layer].fec = rc;\r\nrc = mb86a20s_get_interleaving(state, layer);\r\nif (rc < 0)\r\ngoto noperlayer_error;\r\ndev_dbg(&state->i2c->dev, "%s: interleaving %d.\n",\r\n__func__, rc);\r\nc->layer[layer].interleaving = rc;\r\nmb86a20s_layer_bitrate(fe, layer, c->layer[layer].modulation,\r\nc->layer[layer].fec,\r\nc->layer[layer].interleaving,\r\nc->layer[layer].segment_count);\r\n}\r\nrc = mb86a20s_writereg(state, 0x6d, 0x84);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((rc & 0x60) == 0x20) {\r\nc->isdbt_sb_mode = 1;\r\nif (!c->isdbt_sb_segment_count)\r\nc->isdbt_sb_segment_count = 1;\r\n}\r\nrc = mb86a20s_readreg(state, 0x07);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((rc & 0x60) == 0x20) {\r\nswitch (rc & 0x0c >> 2) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_4K;\r\nbreak;\r\ncase 2:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\n}\r\nif (!(rc & 0x10)) {\r\nswitch (rc & 0x3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nnoperlayer_error:\r\nc->isdbt_layer_enabled = 0;\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_reset_counters(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc, val;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (state->last_frequency != c->frequency) {\r\nmemset(&c->cnr, 0, sizeof(c->cnr));\r\nmemset(&c->pre_bit_error, 0, sizeof(c->pre_bit_error));\r\nmemset(&c->pre_bit_count, 0, sizeof(c->pre_bit_count));\r\nmemset(&c->post_bit_error, 0, sizeof(c->post_bit_error));\r\nmemset(&c->post_bit_count, 0, sizeof(c->post_bit_count));\r\nmemset(&c->block_error, 0, sizeof(c->block_error));\r\nmemset(&c->block_count, 0, sizeof(c->block_count));\r\nstate->last_frequency = c->frequency;\r\n}\r\nrc = mb86a20s_writeregdata(state, mb86a20s_per_ber_reset);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_readreg(state, 0x45);\r\nif (rc < 0)\r\ngoto err;\r\nval = rc;\r\nrc = mb86a20s_writereg(state, 0x45, val | 0x10);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x45, val & 0x6f);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x50, 0x50);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\ngoto err;\r\nval = rc;\r\nrc = mb86a20s_writereg(state, 0x51, val | 0x01);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x51, val & 0x06);\r\nif (rc < 0)\r\ngoto err;\r\ngoto ok;\r\nerr:\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't reset FE statistics (error %d).\n",\r\n__func__, rc);\r\nok:\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_pre_ber(struct dvb_frontend *fe,\r\nunsigned layer,\r\nu32 *error, u32 *count)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc, val;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (layer >= NUM_LAYERS)\r\nreturn -EINVAL;\r\nrc = mb86a20s_readreg(state, 0x54);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(rc & (1 << layer))) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: preBER for layer %c is not available yet.\n",\r\n__func__, 'A' + layer);\r\nreturn -EBUSY;\r\n}\r\nrc = mb86a20s_readreg(state, 0x55 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\n*error = rc << 16;\r\nrc = mb86a20s_readreg(state, 0x56 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\n*error |= rc << 8;\r\nrc = mb86a20s_readreg(state, 0x57 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\n*error |= rc;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: bit error before Viterbi for layer %c: %d.\n",\r\n__func__, 'A' + layer, *error);\r\nrc = mb86a20s_writereg(state, 0x50, 0xa7 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*count = rc << 16;\r\nrc = mb86a20s_writereg(state, 0x50, 0xa8 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*count |= rc << 8;\r\nrc = mb86a20s_writereg(state, 0x50, 0xa9 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*count |= rc;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: bit count before Viterbi for layer %c: %d.\n",\r\n__func__, 'A' + layer, *count);\r\nif (state->estimated_rate[layer]\r\n&& state->estimated_rate[layer] != *count) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: updating layer %c preBER counter to %d.\n",\r\n__func__, 'A' + layer, state->estimated_rate[layer]);\r\nrc = mb86a20s_writereg(state, 0x52, 0x00);\r\nrc = mb86a20s_writereg(state, 0x50, 0xa7 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51,\r\nstate->estimated_rate[layer] >> 16);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xa8 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51,\r\nstate->estimated_rate[layer] >> 8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xa9 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51,\r\nstate->estimated_rate[layer]);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x52, 0x01);\r\nrc = mb86a20s_writereg(state, 0x53, 0x00);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x53, 0x07);\r\n} else {\r\nrc = mb86a20s_readreg(state, 0x53);\r\nif (rc < 0)\r\nreturn rc;\r\nval = rc;\r\nrc = mb86a20s_writereg(state, 0x53, val & ~(1 << layer));\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x53, val | (1 << layer));\r\n}\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_post_ber(struct dvb_frontend *fe,\r\nunsigned layer,\r\nu32 *error, u32 *count)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nu32 counter, collect_rate;\r\nint rc, val;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (layer >= NUM_LAYERS)\r\nreturn -EINVAL;\r\nrc = mb86a20s_readreg(state, 0x60);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(rc & (1 << layer))) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: post BER for layer %c is not available yet.\n",\r\n__func__, 'A' + layer);\r\nreturn -EBUSY;\r\n}\r\nrc = mb86a20s_readreg(state, 0x64 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\n*error = rc << 16;\r\nrc = mb86a20s_readreg(state, 0x65 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\n*error |= rc << 8;\r\nrc = mb86a20s_readreg(state, 0x66 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\n*error |= rc;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: post bit error for layer %c: %d.\n",\r\n__func__, 'A' + layer, *error);\r\nrc = mb86a20s_writereg(state, 0x50, 0xdc + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\ncounter = rc << 8;\r\nrc = mb86a20s_writereg(state, 0x50, 0xdd + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\ncounter |= rc;\r\n*count = counter * 204 * 8;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: post bit count for layer %c: %d.\n",\r\n__func__, 'A' + layer, *count);\r\nif (!state->estimated_rate[layer])\r\ngoto reset_measurement;\r\ncollect_rate = state->estimated_rate[layer] / 204 / 8;\r\nif (collect_rate < 32)\r\ncollect_rate = 32;\r\nif (collect_rate > 65535)\r\ncollect_rate = 65535;\r\nif (collect_rate != counter) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: updating postBER counter on layer %c to %d.\n",\r\n__func__, 'A' + layer, collect_rate);\r\nrc = mb86a20s_writereg(state, 0x5e, 0x00);\r\nrc = mb86a20s_writereg(state, 0x50, 0xdc + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, collect_rate >> 8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xdd + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, collect_rate & 0xff);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x5e, 0x07);\r\nrc = mb86a20s_writereg(state, 0x5f, 0x00);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x5f, 0x07);\r\nreturn rc;\r\n}\r\nreset_measurement:\r\nrc = mb86a20s_readreg(state, 0x5f);\r\nif (rc < 0)\r\nreturn rc;\r\nval = rc;\r\nrc = mb86a20s_writereg(state, 0x5f, val & ~(1 << layer));\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x5f, val | (1 << layer));\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_blk_error(struct dvb_frontend *fe,\r\nunsigned layer,\r\nu32 *error, u32 *count)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc, val;\r\nu32 collect_rate;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (layer >= NUM_LAYERS)\r\nreturn -EINVAL;\r\nrc = mb86a20s_writereg(state, 0x50, 0xb8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(rc & (1 << layer))) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: block counts for layer %c aren't available yet.\n",\r\n__func__, 'A' + layer);\r\nreturn -EBUSY;\r\n}\r\nrc = mb86a20s_writereg(state, 0x50, 0xb9 + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*error = rc << 8;\r\nrc = mb86a20s_writereg(state, 0x50, 0xba + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*error |= rc;\r\ndev_dbg(&state->i2c->dev, "%s: block error for layer %c: %d.\n",\r\n__func__, 'A' + layer, *error);\r\nrc = mb86a20s_writereg(state, 0x50, 0xb2 + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*count = rc << 8;\r\nrc = mb86a20s_writereg(state, 0x50, 0xb3 + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\n*count |= rc;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: block count for layer %c: %d.\n",\r\n__func__, 'A' + layer, *count);\r\nif (!state->estimated_rate[layer])\r\ngoto reset_measurement;\r\ncollect_rate = state->estimated_rate[layer] / 204 / 8;\r\nif (collect_rate < 32)\r\ncollect_rate = 32;\r\nif (collect_rate > 65535)\r\ncollect_rate = 65535;\r\nif (collect_rate != *count) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: updating PER counter on layer %c to %d.\n",\r\n__func__, 'A' + layer, collect_rate);\r\nrc = mb86a20s_writereg(state, 0x50, 0xb0);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, 0x00);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xb2 + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, collect_rate >> 8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xb3 + layer * 2);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, collect_rate & 0xff);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xb0);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, 0x07);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x50, 0xb1);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, 0x07);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, 0x00);\r\nreturn rc;\r\n}\r\nreset_measurement:\r\nrc = mb86a20s_writereg(state, 0x50, 0xb1);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nval = rc;\r\nrc = mb86a20s_writereg(state, 0x51, val | (1 << layer));\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, val & ~(1 << layer));\r\nreturn rc;\r\n}\r\nstatic u32 interpolate_value(u32 value, struct linear_segments *segments,\r\nunsigned len)\r\n{\r\nu64 tmp64;\r\nu32 dx, dy;\r\nint i, ret;\r\nif (value >= segments[0].x)\r\nreturn segments[0].y;\r\nif (value < segments[len-1].x)\r\nreturn segments[len-1].y;\r\nfor (i = 1; i < len - 1; i++) {\r\nif (value == segments[i].x)\r\nreturn segments[i].y;\r\nif (value > segments[i].x)\r\nbreak;\r\n}\r\ndy = segments[i].y - segments[i - 1].y;\r\ndx = segments[i - 1].x - segments[i].x;\r\ntmp64 = value - segments[i].x;\r\ntmp64 *= dy;\r\ndo_div(tmp64, dx);\r\nret = segments[i].y - tmp64;\r\nreturn ret;\r\n}\r\nstatic int mb86a20s_get_main_CNR(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 cnr_linear, cnr;\r\nint rc, val;\r\nrc = mb86a20s_readreg(state, 0x45);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(rc & 0x40)) {\r\ndev_dbg(&state->i2c->dev, "%s: CNR is not available yet.\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nval = rc;\r\nrc = mb86a20s_readreg(state, 0x46);\r\nif (rc < 0)\r\nreturn rc;\r\ncnr_linear = rc << 8;\r\nrc = mb86a20s_readreg(state, 0x46);\r\nif (rc < 0)\r\nreturn rc;\r\ncnr_linear |= rc;\r\ncnr = interpolate_value(cnr_linear,\r\ncnr_to_db_table, ARRAY_SIZE(cnr_to_db_table));\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = cnr;\r\ndev_dbg(&state->i2c->dev, "%s: CNR is %d.%03d dB (%d)\n",\r\n__func__, cnr / 1000, cnr % 1000, cnr_linear);\r\nrc = mb86a20s_writereg(state, 0x45, val | 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x45, val & 0x6f);\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_get_blk_error_layer_CNR(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 mer, cnr;\r\nint rc, val, layer;\r\nstruct linear_segments *segs;\r\nunsigned segs_len;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nrc = mb86a20s_writereg(state, 0x50, 0x5b);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(rc & 0x01)) {\r\ndev_dbg(&state->i2c->dev,\r\n"%s: MER measures aren't available yet.\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nfor (layer = 0; layer < NUM_LAYERS; layer++) {\r\nif (!(c->isdbt_layer_enabled & (1 << layer))) {\r\nc->cnr.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\ncontinue;\r\n}\r\nrc = mb86a20s_writereg(state, 0x50, 0x52 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nmer = rc << 16;\r\nrc = mb86a20s_writereg(state, 0x50, 0x53 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nmer |= rc << 8;\r\nrc = mb86a20s_writereg(state, 0x50, 0x54 + layer * 3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nmer |= rc;\r\nswitch (c->layer[layer].modulation) {\r\ncase DQPSK:\r\ncase QPSK:\r\nsegs = cnr_qpsk_table;\r\nsegs_len = ARRAY_SIZE(cnr_qpsk_table);\r\nbreak;\r\ncase QAM_16:\r\nsegs = cnr_16qam_table;\r\nsegs_len = ARRAY_SIZE(cnr_16qam_table);\r\nbreak;\r\ndefault:\r\ncase QAM_64:\r\nsegs = cnr_64qam_table;\r\nsegs_len = ARRAY_SIZE(cnr_64qam_table);\r\nbreak;\r\n}\r\ncnr = interpolate_value(mer, segs, segs_len);\r\nc->cnr.stat[1 + layer].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[1 + layer].svalue = cnr;\r\ndev_dbg(&state->i2c->dev,\r\n"%s: CNR for layer %c is %d.%03d dB (MER = %d).\n",\r\n__func__, 'A' + layer, cnr / 1000, cnr % 1000, mer);\r\n}\r\nrc = mb86a20s_writereg(state, 0x50, 0x50);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_readreg(state, 0x51);\r\nif (rc < 0)\r\nreturn rc;\r\nval = rc;\r\nrc = mb86a20s_writereg(state, 0x51, val | 0x01);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = mb86a20s_writereg(state, 0x51, val & 0x06);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic void mb86a20s_stats_not_ready(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint layer;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nc->strength.len = 1;\r\nc->cnr.len = NUM_LAYERS + 1;\r\nc->pre_bit_error.len = NUM_LAYERS + 1;\r\nc->pre_bit_count.len = NUM_LAYERS + 1;\r\nc->post_bit_error.len = NUM_LAYERS + 1;\r\nc->post_bit_count.len = NUM_LAYERS + 1;\r\nc->block_error.len = NUM_LAYERS + 1;\r\nc->block_count.len = NUM_LAYERS + 1;\r\nc->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->strength.stat[0].uvalue = 0;\r\nfor (layer = 0; layer < NUM_LAYERS + 1; layer++) {\r\nc->cnr.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->pre_bit_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->pre_bit_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\n}\r\nstatic int mb86a20s_get_stats(struct dvb_frontend *fe, int status_nr)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc = 0, layer;\r\nu32 bit_error = 0, bit_count = 0;\r\nu32 t_pre_bit_error = 0, t_pre_bit_count = 0;\r\nu32 t_post_bit_error = 0, t_post_bit_count = 0;\r\nu32 block_error = 0, block_count = 0;\r\nu32 t_block_error = 0, t_block_count = 0;\r\nint active_layers = 0, pre_ber_layers = 0, post_ber_layers = 0;\r\nint per_layers = 0;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nmb86a20s_get_main_CNR(fe);\r\nmb86a20s_get_blk_error_layer_CNR(fe);\r\nif (status_nr < 9)\r\nreturn 0;\r\nfor (layer = 0; layer < NUM_LAYERS; layer++) {\r\nif (c->isdbt_layer_enabled & (1 << layer)) {\r\nactive_layers++;\r\nrc = mb86a20s_get_pre_ber(fe, layer,\r\n&bit_error, &bit_count);\r\nif (rc >= 0) {\r\nc->pre_bit_error.stat[1 + layer].scale = FE_SCALE_COUNTER;\r\nc->pre_bit_error.stat[1 + layer].uvalue += bit_error;\r\nc->pre_bit_count.stat[1 + layer].scale = FE_SCALE_COUNTER;\r\nc->pre_bit_count.stat[1 + layer].uvalue += bit_count;\r\n} else if (rc != -EBUSY) {\r\nc->pre_bit_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->pre_bit_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't get BER for layer %c (error %d).\n",\r\n__func__, 'A' + layer, rc);\r\n}\r\nif (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)\r\npre_ber_layers++;\r\nrc = mb86a20s_get_post_ber(fe, layer,\r\n&bit_error, &bit_count);\r\nif (rc >= 0) {\r\nc->post_bit_error.stat[1 + layer].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[1 + layer].uvalue += bit_error;\r\nc->post_bit_count.stat[1 + layer].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[1 + layer].uvalue += bit_count;\r\n} else if (rc != -EBUSY) {\r\nc->post_bit_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't get BER for layer %c (error %d).\n",\r\n__func__, 'A' + layer, rc);\r\n}\r\nif (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)\r\npost_ber_layers++;\r\nrc = mb86a20s_get_blk_error(fe, layer,\r\n&block_error,\r\n&block_count);\r\nif (rc >= 0) {\r\nc->block_error.stat[1 + layer].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[1 + layer].uvalue += block_error;\r\nc->block_count.stat[1 + layer].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[1 + layer].uvalue += block_count;\r\n} else if (rc != -EBUSY) {\r\nc->block_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't get PER for layer %c (error %d).\n",\r\n__func__, 'A' + layer, rc);\r\n}\r\nif (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)\r\nper_layers++;\r\nt_pre_bit_error += c->pre_bit_error.stat[1 + layer].uvalue;\r\nt_pre_bit_count += c->pre_bit_count.stat[1 + layer].uvalue;\r\nt_post_bit_error += c->post_bit_error.stat[1 + layer].uvalue;\r\nt_post_bit_count += c->post_bit_count.stat[1 + layer].uvalue;\r\nt_block_error += c->block_error.stat[1 + layer].uvalue;\r\nt_block_count += c->block_count.stat[1 + layer].uvalue;\r\n}\r\n}\r\nif (pre_ber_layers) {\r\nc->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->pre_bit_error.stat[0].uvalue = t_pre_bit_error;\r\nc->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->pre_bit_count.stat[0].uvalue = t_pre_bit_count;\r\n} else {\r\nc->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\n}\r\nif (post_ber_layers) {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = t_post_bit_error;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue = t_post_bit_count;\r\n} else {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\n}\r\nif (per_layers) {\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue = t_block_error;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].uvalue = t_block_count;\r\n} else {\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nu64 pll;\r\nu32 fclk;\r\nint rc;\r\nu8 regD5 = 1, reg71, reg09 = 0x3a;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writeregdata(state, mb86a20s_init1);\r\nif (rc < 0)\r\ngoto err;\r\nif (!state->inversion)\r\nreg09 |= 0x04;\r\nrc = mb86a20s_writereg(state, 0x09, reg09);\r\nif (rc < 0)\r\ngoto err;\r\nif (!state->bw)\r\nreg71 = 1;\r\nelse\r\nreg71 = 0;\r\nrc = mb86a20s_writereg(state, 0x39, reg71);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x71, state->bw);\r\nif (rc < 0)\r\ngoto err;\r\nif (state->subchannel) {\r\nrc = mb86a20s_writereg(state, 0x44, state->subchannel);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\nfclk = state->config->fclk;\r\nif (!fclk)\r\nfclk = 32571428;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &state->if_freq);\r\nif (!state->if_freq)\r\nstate->if_freq = 3300000;\r\npll = (((u64)1) << 34) * state->if_freq;\r\ndo_div(pll, 63 * fclk);\r\npll = (1 << 25) - pll;\r\nrc = mb86a20s_writereg(state, 0x28, 0x2a);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x29, (pll >> 16) & 0xff);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x2a, (pll >> 8) & 0xff);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x2b, pll & 0xff);\r\nif (rc < 0)\r\ngoto err;\r\ndev_dbg(&state->i2c->dev, "%s: fclk=%d, IF=%d, clock reg=0x%06llx\n",\r\n__func__, fclk, state->if_freq, (long long)pll);\r\npll = state->if_freq * 1677721600L;\r\ndo_div(pll, 1628571429L);\r\nrc = mb86a20s_writereg(state, 0x28, 0x20);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x29, (pll >> 16) & 0xff);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x2a, (pll >> 8) & 0xff);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x2b, pll & 0xff);\r\nif (rc < 0)\r\ngoto err;\r\ndev_dbg(&state->i2c->dev, "%s: IF=%d, IF reg=0x%06llx\n",\r\n__func__, state->if_freq, (long long)pll);\r\nif (!state->config->is_serial) {\r\nregD5 &= ~1;\r\nrc = mb86a20s_writereg(state, 0x50, 0xd5);\r\nif (rc < 0)\r\ngoto err;\r\nrc = mb86a20s_writereg(state, 0x51, regD5);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\nrc = mb86a20s_writeregdata(state, mb86a20s_init2);\r\nif (rc < 0)\r\ngoto err;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (rc < 0) {\r\nstate->need_init = true;\r\ndev_info(&state->i2c->dev,\r\n"mb86a20s: Init failed. Will try again later\n");\r\n} else {\r\nstate->need_init = false;\r\ndev_dbg(&state->i2c->dev, "Initialization succeeded.\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc, if_freq;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (!c->isdbt_layer_enabled)\r\nc->isdbt_layer_enabled = 7;\r\nif (c->isdbt_layer_enabled == 1)\r\nstate->bw = MB86A20S_1SEG;\r\nelse if (c->isdbt_partial_reception)\r\nstate->bw = MB86A20S_13SEG_PARTIAL;\r\nelse\r\nstate->bw = MB86A20S_13SEG;\r\nif (c->inversion == INVERSION_ON)\r\nstate->inversion = true;\r\nelse\r\nstate->inversion = false;\r\nif (!c->isdbt_sb_mode) {\r\nstate->subchannel = 0;\r\n} else {\r\nif (c->isdbt_sb_subchannel >= ARRAY_SIZE(mb86a20s_subchannel))\r\nc->isdbt_sb_subchannel = 0;\r\nstate->subchannel = mb86a20s_subchannel[c->isdbt_sb_subchannel];\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\r\nmb86a20s_initfe(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nrc = mb86a20s_writeregdata(state, mb86a20s_reset_reception);\r\nmb86a20s_reset_counters(fe);\r\nmb86a20s_stats_not_ready(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_read_status_and_stats(struct dvb_frontend *fe,\r\nfe_status_t *status)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc, status_nr;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nstatus_nr = mb86a20s_read_status(fe, status);\r\nif (status_nr < 7) {\r\nmb86a20s_stats_not_ready(fe);\r\nmb86a20s_reset_frontend_cache(fe);\r\n}\r\nif (status_nr < 0) {\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't read frontend lock status\n", __func__);\r\ngoto error;\r\n}\r\nrc = mb86a20s_read_signal_strength(fe);\r\nif (rc < 0) {\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't reset VBER registers.\n", __func__);\r\nmb86a20s_stats_not_ready(fe);\r\nmb86a20s_reset_frontend_cache(fe);\r\nrc = 0;\r\ngoto error;\r\n}\r\nif (status_nr >= 7) {\r\nrc = mb86a20s_get_frontend(fe);\r\nif (rc < 0) {\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't get FE TMCC data.\n", __func__);\r\nrc = 0;\r\ngoto error;\r\n}\r\nrc = mb86a20s_get_stats(fe, status_nr);\r\nif (rc < 0 && rc != -EBUSY) {\r\ndev_err(&state->i2c->dev,\r\n"%s: Can't get FE statistics.\n", __func__);\r\nrc = 0;\r\ngoto error;\r\n}\r\nrc = 0;\r\n}\r\ngoto ok;\r\nerror:\r\nmb86a20s_stats_not_ready(fe);\r\nok:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn rc;\r\n}\r\nstatic int mb86a20s_read_signal_strength_from_cache(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\n*strength = c->strength.stat[0].uvalue;\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_get_frontend_dummy(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mb86a20s_tune(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\nint rc = 0;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nif (re_tune)\r\nrc = mb86a20s_set_frontend(fe);\r\nif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\r\nmb86a20s_read_status_and_stats(fe, status);\r\nreturn rc;\r\n}\r\nstatic void mb86a20s_release(struct dvb_frontend *fe)\r\n{\r\nstruct mb86a20s_state *state = fe->demodulator_priv;\r\ndev_dbg(&state->i2c->dev, "%s called.\n", __func__);\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct mb86a20s_state *state;\r\nu8 rev;\r\ndev_dbg(&i2c->dev, "%s called.\n", __func__);\r\nstate = kzalloc(sizeof(struct mb86a20s_state), GFP_KERNEL);\r\nif (state == NULL) {\r\ndev_err(&i2c->dev,\r\n"%s: unable to allocate memory for state\n", __func__);\r\ngoto error;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nmemcpy(&state->frontend.ops, &mb86a20s_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nrev = mb86a20s_readreg(state, 0);\r\nif (rev == 0x13) {\r\ndev_info(&i2c->dev,\r\n"Detected a Fujitsu mb86a20s frontend\n");\r\n} else {\r\ndev_dbg(&i2c->dev,\r\n"Frontend revision %d is unknown - aborting.\n",\r\nrev);\r\ngoto error;\r\n}\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
