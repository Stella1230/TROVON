static int dt2801_readdata(struct comedi_device *dev, int *data)\r\n{\r\nint stat = 0;\r\nint timeout = DT2801_TIMEOUT;\r\ndo {\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & (DT_S_COMPOSITE_ERROR | DT_S_READY))\r\nreturn stat;\r\nif (stat & DT_S_DATA_OUT_READY) {\r\n*data = inb_p(dev->iobase + DT2801_DATA);\r\nreturn 0;\r\n}\r\n} while (--timeout > 0);\r\nreturn -ETIME;\r\n}\r\nstatic int dt2801_readdata2(struct comedi_device *dev, int *data)\r\n{\r\nint lb, hb;\r\nint ret;\r\nret = dt2801_readdata(dev, &lb);\r\nif (ret)\r\nreturn ret;\r\nret = dt2801_readdata(dev, &hb);\r\nif (ret)\r\nreturn ret;\r\n*data = (hb << 8) + lb;\r\nreturn 0;\r\n}\r\nstatic int dt2801_writedata(struct comedi_device *dev, unsigned int data)\r\n{\r\nint stat = 0;\r\nint timeout = DT2801_TIMEOUT;\r\ndo {\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & DT_S_COMPOSITE_ERROR)\r\nreturn stat;\r\nif (!(stat & DT_S_DATA_IN_FULL)) {\r\noutb_p(data & 0xff, dev->iobase + DT2801_DATA);\r\nreturn 0;\r\n}\r\n#if 0\r\nif (stat & DT_S_READY) {\r\nprintk\r\n("dt2801: ready flag set (bad!) in dt2801_writedata()\n");\r\nreturn -EIO;\r\n}\r\n#endif\r\n} while (--timeout > 0);\r\nreturn -ETIME;\r\n}\r\nstatic int dt2801_writedata2(struct comedi_device *dev, unsigned int data)\r\n{\r\nint ret;\r\nret = dt2801_writedata(dev, data & 0xff);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dt2801_writedata(dev, (data >> 8));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int dt2801_wait_for_ready(struct comedi_device *dev)\r\n{\r\nint timeout = DT2801_TIMEOUT;\r\nint stat;\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & DT_S_READY)\r\nreturn 0;\r\ndo {\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & DT_S_COMPOSITE_ERROR)\r\nreturn stat;\r\nif (stat & DT_S_READY)\r\nreturn 0;\r\n} while (--timeout > 0);\r\nreturn -ETIME;\r\n}\r\nstatic int dt2801_writecmd(struct comedi_device *dev, int command)\r\n{\r\nint stat;\r\ndt2801_wait_for_ready(dev);\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & DT_S_COMPOSITE_ERROR) {\r\nprintk\r\n("dt2801: composite-error in dt2801_writecmd(), ignoring\n");\r\n}\r\nif (!(stat & DT_S_READY))\r\nprintk("dt2801: !ready in dt2801_writecmd(), ignoring\n");\r\noutb_p(command, dev->iobase + DT2801_CMD);\r\nreturn 0;\r\n}\r\nstatic int dt2801_reset(struct comedi_device *dev)\r\n{\r\nint board_code = 0;\r\nunsigned int stat;\r\nint timeout;\r\nDPRINTK("dt2801: resetting board...\n");\r\nDPRINTK("fingerprint: 0x%02x 0x%02x\n", inb_p(dev->iobase),\r\ninb_p(dev->iobase + 1));\r\ninb_p(dev->iobase + DT2801_DATA);\r\ninb_p(dev->iobase + DT2801_DATA);\r\ninb_p(dev->iobase + DT2801_DATA);\r\ninb_p(dev->iobase + DT2801_DATA);\r\nDPRINTK("dt2801: stop\n");\r\noutb_p(DT_C_STOP, dev->iobase + DT2801_CMD);\r\nudelay(100);\r\ntimeout = 10000;\r\ndo {\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & DT_S_READY)\r\nbreak;\r\n} while (timeout--);\r\nif (!timeout)\r\nprintk("dt2801: timeout 1 status=0x%02x\n", stat);\r\nDPRINTK("dt2801: reset\n");\r\noutb_p(DT_C_RESET, dev->iobase + DT2801_CMD);\r\nudelay(100);\r\ntimeout = 10000;\r\ndo {\r\nstat = inb_p(dev->iobase + DT2801_STATUS);\r\nif (stat & DT_S_READY)\r\nbreak;\r\n} while (timeout--);\r\nif (!timeout)\r\nprintk("dt2801: timeout 2 status=0x%02x\n", stat);\r\nDPRINTK("dt2801: reading code\n");\r\ndt2801_readdata(dev, &board_code);\r\nDPRINTK("dt2801: ok. code=0x%02x\n", board_code);\r\nreturn board_code;\r\n}\r\nstatic int probe_number_of_ai_chans(struct comedi_device *dev)\r\n{\r\nint n_chans;\r\nint stat;\r\nint data;\r\nfor (n_chans = 0; n_chans < 16; n_chans++) {\r\nstat = dt2801_writecmd(dev, DT_C_READ_ADIM);\r\ndt2801_writedata(dev, 0);\r\ndt2801_writedata(dev, n_chans);\r\nstat = dt2801_readdata2(dev, &data);\r\nif (stat)\r\nbreak;\r\n}\r\ndt2801_reset(dev);\r\ndt2801_reset(dev);\r\nreturn n_chans;\r\n}\r\nstatic const struct comedi_lrange *dac_range_lkup(int opt)\r\n{\r\nif (opt < 0 || opt >= 5)\r\nreturn &range_unknown;\r\nreturn dac_range_table[opt];\r\n}\r\nstatic const struct comedi_lrange *ai_range_lkup(int type, int opt)\r\n{\r\nswitch (type) {\r\ncase 0:\r\nreturn (opt) ?\r\n&range_dt2801_ai_pgl_unipolar :\r\n&range_dt2801_ai_pgl_bipolar;\r\ncase 1:\r\nreturn (opt) ? &range_unipolar10 : &range_bipolar10;\r\ncase 2:\r\nreturn &range_unipolar5;\r\n}\r\nreturn &range_unknown;\r\n}\r\nstatic int dt2801_error(struct comedi_device *dev, int stat)\r\n{\r\nif (stat < 0) {\r\nif (stat == -ETIME)\r\nprintk("dt2801: timeout\n");\r\nelse\r\nprintk("dt2801: error %d\n", stat);\r\nreturn stat;\r\n}\r\nprintk("dt2801: error status 0x%02x, resetting...\n", stat);\r\ndt2801_reset(dev);\r\ndt2801_reset(dev);\r\nreturn -EIO;\r\n}\r\nstatic int dt2801_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint d;\r\nint stat;\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nstat = dt2801_writecmd(dev, DT_C_READ_ADIM);\r\ndt2801_writedata(dev, CR_RANGE(insn->chanspec));\r\ndt2801_writedata(dev, CR_CHAN(insn->chanspec));\r\nstat = dt2801_readdata2(dev, &d);\r\nif (stat != 0)\r\nreturn dt2801_error(dev, stat);\r\ndata[i] = d;\r\n}\r\nreturn i;\r\n}\r\nstatic int dt2801_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt2801_private *devpriv = dev->private;\r\ndata[0] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int dt2801_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt2801_private *devpriv = dev->private;\r\ndt2801_writecmd(dev, DT_C_WRITE_DAIM);\r\ndt2801_writedata(dev, CR_CHAN(insn->chanspec));\r\ndt2801_writedata2(dev, data[0]);\r\ndevpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[0];\r\nreturn 1;\r\n}\r\nstatic int dt2801_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint which = 0;\r\nif (s == &dev->subdevices[3])\r\nwhich = 1;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\ndt2801_writecmd(dev, DT_C_WRITE_DIG);\r\ndt2801_writedata(dev, which);\r\ndt2801_writedata(dev, s->state);\r\n}\r\ndt2801_writecmd(dev, DT_C_READ_DIG);\r\ndt2801_writedata(dev, which);\r\ndt2801_readdata(dev, data + 1);\r\nreturn insn->n;\r\n}\r\nstatic int dt2801_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint which = 0;\r\nif (s == &dev->subdevices[3])\r\nwhich = 1;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits = 0xff;\r\ndt2801_writecmd(dev, DT_C_SET_DIGOUT);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits = 0;\r\ndt2801_writecmd(dev, DT_C_SET_DIGIN);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] = s->io_bits ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndt2801_writedata(dev, which);\r\nreturn 1;\r\n}\r\nstatic int dt2801_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct dt2801_board *board = comedi_board(dev);\r\nstruct dt2801_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint board_code, type;\r\nint ret = 0;\r\nint n_ai_chans;\r\nret = comedi_request_region(dev, it->options[0], DT2801_IOSIZE);\r\nif (ret)\r\nreturn ret;\r\nboard_code = dt2801_reset(dev);\r\nif (!board_code)\r\nboard_code = dt2801_reset(dev);\r\nfor (type = 0; type < ARRAY_SIZE(boardtypes); type++) {\r\nif (boardtypes[type].boardcode == board_code)\r\ngoto havetype;\r\n}\r\nprintk("dt2801: unrecognized board code=0x%02x, contact author\n",\r\nboard_code);\r\ntype = 0;\r\nhavetype:\r\ndev->board_ptr = boardtypes + type;\r\nboard = comedi_board(dev);\r\nn_ai_chans = probe_number_of_ai_chans(dev);\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\ngoto out;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\ndev->board_name = board->name;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\n#if 1\r\ns->n_chan = n_ai_chans;\r\n#else\r\nif (it->options[2])\r\ns->n_chan = board->ad_chan;\r\nelse\r\ns->n_chan = board->ad_chan / 2;\r\n#endif\r\ns->maxdata = (1 << board->adbits) - 1;\r\ns->range_table = ai_range_lkup(board->adrangetype, it->options[3]);\r\ns->insn_read = dt2801_ai_insn_read;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = (1 << board->dabits) - 1;\r\ns->range_table_list = devpriv->dac_range_types;\r\ndevpriv->dac_range_types[0] = dac_range_lkup(it->options[4]);\r\ndevpriv->dac_range_types[1] = dac_range_lkup(it->options[5]);\r\ns->insn_read = dt2801_ao_insn_read;\r\ns->insn_write = dt2801_ao_insn_write;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = dt2801_dio_insn_bits;\r\ns->insn_config = dt2801_dio_insn_config;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = dt2801_dio_insn_bits;\r\ns->insn_config = dt2801_dio_insn_config;\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}
