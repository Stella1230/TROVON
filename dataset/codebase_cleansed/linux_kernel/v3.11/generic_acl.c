static size_t\r\ngeneric_acl_list(struct dentry *dentry, char *list, size_t list_size,\r\nconst char *name, size_t name_len, int type)\r\n{\r\nstruct posix_acl *acl;\r\nconst char *xname;\r\nsize_t size;\r\nacl = get_cached_acl(dentry->d_inode, type);\r\nif (!acl)\r\nreturn 0;\r\nposix_acl_release(acl);\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nxname = POSIX_ACL_XATTR_ACCESS;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nxname = POSIX_ACL_XATTR_DEFAULT;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsize = strlen(xname) + 1;\r\nif (list && size <= list_size)\r\nmemcpy(list, xname, size);\r\nreturn size;\r\n}\r\nstatic int\r\ngeneric_acl_get(struct dentry *dentry, const char *name, void *buffer,\r\nsize_t size, int type)\r\n{\r\nstruct posix_acl *acl;\r\nint error;\r\nif (strcmp(name, "") != 0)\r\nreturn -EINVAL;\r\nacl = get_cached_acl(dentry->d_inode, type);\r\nif (!acl)\r\nreturn -ENODATA;\r\nerror = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nstatic int\r\ngeneric_acl_set(struct dentry *dentry, const char *name, const void *value,\r\nsize_t size, int flags, int type)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct posix_acl *acl = NULL;\r\nint error;\r\nif (strcmp(name, "") != 0)\r\nreturn -EINVAL;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nif (!inode_owner_or_capable(inode))\r\nreturn -EPERM;\r\nif (value) {\r\nacl = posix_acl_from_xattr(&init_user_ns, value, size);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\n}\r\nif (acl) {\r\nerror = posix_acl_valid(acl);\r\nif (error)\r\ngoto failed;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nerror = posix_acl_equiv_mode(acl, &inode->i_mode);\r\nif (error < 0)\r\ngoto failed;\r\ninode->i_ctime = CURRENT_TIME;\r\nif (error == 0) {\r\nposix_acl_release(acl);\r\nacl = NULL;\r\n}\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nif (!S_ISDIR(inode->i_mode)) {\r\nerror = -EINVAL;\r\ngoto failed;\r\n}\r\nbreak;\r\n}\r\n}\r\nset_cached_acl(inode, type, acl);\r\nerror = 0;\r\nfailed:\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nint\r\ngeneric_acl_init(struct inode *inode, struct inode *dir)\r\n{\r\nstruct posix_acl *acl = NULL;\r\nint error;\r\nif (!S_ISLNK(inode->i_mode))\r\nacl = get_cached_acl(dir, ACL_TYPE_DEFAULT);\r\nif (acl) {\r\nif (S_ISDIR(inode->i_mode))\r\nset_cached_acl(inode, ACL_TYPE_DEFAULT, acl);\r\nerror = posix_acl_create(&acl, GFP_KERNEL, &inode->i_mode);\r\nif (error < 0)\r\nreturn error;\r\nif (error > 0)\r\nset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\r\n} else {\r\ninode->i_mode &= ~current_umask();\r\n}\r\nerror = 0;\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nint\r\ngeneric_acl_chmod(struct inode *inode)\r\n{\r\nstruct posix_acl *acl;\r\nint error = 0;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nacl = get_cached_acl(inode, ACL_TYPE_ACCESS);\r\nif (acl) {\r\nerror = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\r\nif (error)\r\nreturn error;\r\nset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\r\nposix_acl_release(acl);\r\n}\r\nreturn error;\r\n}
