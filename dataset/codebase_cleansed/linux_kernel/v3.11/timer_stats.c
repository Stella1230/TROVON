static void reset_entries(void)\r\n{\r\nnr_entries = 0;\r\nmemset(entries, 0, sizeof(entries));\r\nmemset(tstat_hash_table, 0, sizeof(tstat_hash_table));\r\natomic_set(&overflow_count, 0);\r\n}\r\nstatic struct entry *alloc_entry(void)\r\n{\r\nif (nr_entries >= MAX_ENTRIES)\r\nreturn NULL;\r\nreturn entries + nr_entries++;\r\n}\r\nstatic int match_entries(struct entry *entry1, struct entry *entry2)\r\n{\r\nreturn entry1->timer == entry2->timer &&\r\nentry1->start_func == entry2->start_func &&\r\nentry1->expire_func == entry2->expire_func &&\r\nentry1->pid == entry2->pid;\r\n}\r\nstatic struct entry *tstat_lookup(struct entry *entry, char *comm)\r\n{\r\nstruct entry **head, *curr, *prev;\r\nhead = tstat_hashentry(entry);\r\ncurr = *head;\r\nwhile (curr) {\r\nif (match_entries(curr, entry))\r\nreturn curr;\r\ncurr = curr->next;\r\n}\r\nprev = NULL;\r\ncurr = *head;\r\nraw_spin_lock(&table_lock);\r\nwhile (curr) {\r\nif (match_entries(curr, entry))\r\ngoto out_unlock;\r\nprev = curr;\r\ncurr = curr->next;\r\n}\r\ncurr = alloc_entry();\r\nif (curr) {\r\n*curr = *entry;\r\ncurr->count = 0;\r\ncurr->next = NULL;\r\nmemcpy(curr->comm, comm, TASK_COMM_LEN);\r\nsmp_mb();\r\nif (prev)\r\nprev->next = curr;\r\nelse\r\n*head = curr;\r\n}\r\nout_unlock:\r\nraw_spin_unlock(&table_lock);\r\nreturn curr;\r\n}\r\nvoid timer_stats_update_stats(void *timer, pid_t pid, void *startf,\r\nvoid *timerf, char *comm,\r\nunsigned int timer_flag)\r\n{\r\nraw_spinlock_t *lock;\r\nstruct entry *entry, input;\r\nunsigned long flags;\r\nif (likely(!timer_stats_active))\r\nreturn;\r\nlock = &per_cpu(tstats_lookup_lock, raw_smp_processor_id());\r\ninput.timer = timer;\r\ninput.start_func = startf;\r\ninput.expire_func = timerf;\r\ninput.pid = pid;\r\ninput.timer_flag = timer_flag;\r\nraw_spin_lock_irqsave(lock, flags);\r\nif (!timer_stats_active)\r\ngoto out_unlock;\r\nentry = tstat_lookup(&input, comm);\r\nif (likely(entry))\r\nentry->count++;\r\nelse\r\natomic_inc(&overflow_count);\r\nout_unlock:\r\nraw_spin_unlock_irqrestore(lock, flags);\r\n}\r\nstatic void print_name_offset(struct seq_file *m, unsigned long addr)\r\n{\r\nchar symname[KSYM_NAME_LEN];\r\nif (lookup_symbol_name(addr, symname) < 0)\r\nseq_printf(m, "<%p>", (void *)addr);\r\nelse\r\nseq_printf(m, "%s", symname);\r\n}\r\nstatic int tstats_show(struct seq_file *m, void *v)\r\n{\r\nstruct timespec period;\r\nstruct entry *entry;\r\nunsigned long ms;\r\nlong events = 0;\r\nktime_t time;\r\nint i;\r\nmutex_lock(&show_mutex);\r\nif (timer_stats_active)\r\ntime_stop = ktime_get();\r\ntime = ktime_sub(time_stop, time_start);\r\nperiod = ktime_to_timespec(time);\r\nms = period.tv_nsec / 1000000;\r\nseq_puts(m, "Timer Stats Version: v0.2\n");\r\nseq_printf(m, "Sample period: %ld.%03ld s\n", period.tv_sec, ms);\r\nif (atomic_read(&overflow_count))\r\nseq_printf(m, "Overflow: %d entries\n",\r\natomic_read(&overflow_count));\r\nfor (i = 0; i < nr_entries; i++) {\r\nentry = entries + i;\r\nif (entry->timer_flag & TIMER_STATS_FLAG_DEFERRABLE) {\r\nseq_printf(m, "%4luD, %5d %-16s ",\r\nentry->count, entry->pid, entry->comm);\r\n} else {\r\nseq_printf(m, " %4lu, %5d %-16s ",\r\nentry->count, entry->pid, entry->comm);\r\n}\r\nprint_name_offset(m, (unsigned long)entry->start_func);\r\nseq_puts(m, " (");\r\nprint_name_offset(m, (unsigned long)entry->expire_func);\r\nseq_puts(m, ")\n");\r\nevents += entry->count;\r\n}\r\nms += period.tv_sec * 1000;\r\nif (!ms)\r\nms = 1;\r\nif (events && period.tv_sec)\r\nseq_printf(m, "%ld total events, %ld.%03ld events/sec\n",\r\nevents, events * 1000 / ms,\r\n(events * 1000000 / ms) % 1000);\r\nelse\r\nseq_printf(m, "%ld total events\n", events);\r\nmutex_unlock(&show_mutex);\r\nreturn 0;\r\n}\r\nstatic void sync_access(void)\r\n{\r\nunsigned long flags;\r\nint cpu;\r\nfor_each_online_cpu(cpu) {\r\nraw_spinlock_t *lock = &per_cpu(tstats_lookup_lock, cpu);\r\nraw_spin_lock_irqsave(lock, flags);\r\nraw_spin_unlock_irqrestore(lock, flags);\r\n}\r\n}\r\nstatic ssize_t tstats_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offs)\r\n{\r\nchar ctl[2];\r\nif (count != 2 || *offs)\r\nreturn -EINVAL;\r\nif (copy_from_user(ctl, buf, count))\r\nreturn -EFAULT;\r\nmutex_lock(&show_mutex);\r\nswitch (ctl[0]) {\r\ncase '0':\r\nif (timer_stats_active) {\r\ntimer_stats_active = 0;\r\ntime_stop = ktime_get();\r\nsync_access();\r\n}\r\nbreak;\r\ncase '1':\r\nif (!timer_stats_active) {\r\nreset_entries();\r\ntime_start = ktime_get();\r\nsmp_mb();\r\ntimer_stats_active = 1;\r\n}\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\n}\r\nmutex_unlock(&show_mutex);\r\nreturn count;\r\n}\r\nstatic int tstats_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, tstats_show, NULL);\r\n}\r\nvoid __init init_timer_stats(void)\r\n{\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\nraw_spin_lock_init(&per_cpu(tstats_lookup_lock, cpu));\r\n}\r\nstatic int __init init_tstats_procfs(void)\r\n{\r\nstruct proc_dir_entry *pe;\r\npe = proc_create("timer_stats", 0644, NULL, &tstats_fops);\r\nif (!pe)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
