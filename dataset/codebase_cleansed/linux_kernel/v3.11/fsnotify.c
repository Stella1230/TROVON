void __fsnotify_inode_delete(struct inode *inode)\r\n{\r\nfsnotify_clear_marks_by_inode(inode);\r\n}\r\nvoid __fsnotify_vfsmount_delete(struct vfsmount *mnt)\r\n{\r\nfsnotify_clear_marks_by_mount(mnt);\r\n}\r\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\r\n{\r\nstruct dentry *alias;\r\nint watched;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn;\r\nwatched = fsnotify_inode_watches_children(inode);\r\nspin_lock(&inode->i_lock);\r\nhlist_for_each_entry(alias, &inode->i_dentry, d_alias) {\r\nstruct dentry *child;\r\nspin_lock(&alias->d_lock);\r\nlist_for_each_entry(child, &alias->d_subdirs, d_u.d_child) {\r\nif (!child->d_inode)\r\ncontinue;\r\nspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (watched)\r\nchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\r\nelse\r\nchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\r\nspin_unlock(&child->d_lock);\r\n}\r\nspin_unlock(&alias->d_lock);\r\n}\r\nspin_unlock(&inode->i_lock);\r\n}\r\nint __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)\r\n{\r\nstruct dentry *parent;\r\nstruct inode *p_inode;\r\nint ret = 0;\r\nif (!dentry)\r\ndentry = path->dentry;\r\nif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\r\nreturn 0;\r\nparent = dget_parent(dentry);\r\np_inode = parent->d_inode;\r\nif (unlikely(!fsnotify_inode_watches_children(p_inode)))\r\n__fsnotify_update_child_dentry_flags(p_inode);\r\nelse if (p_inode->i_fsnotify_mask & mask) {\r\nmask |= FS_EVENT_ON_CHILD;\r\nif (path)\r\nret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\r\ndentry->d_name.name, 0);\r\nelse\r\nret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\r\ndentry->d_name.name, 0);\r\n}\r\ndput(parent);\r\nreturn ret;\r\n}\r\nstatic int send_to_group(struct inode *to_tell,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\n__u32 mask, void *data,\r\nint data_is, u32 cookie,\r\nconst unsigned char *file_name,\r\nstruct fsnotify_event **event)\r\n{\r\nstruct fsnotify_group *group = NULL;\r\n__u32 inode_test_mask = 0;\r\n__u32 vfsmount_test_mask = 0;\r\nif (unlikely(!inode_mark && !vfsmount_mark)) {\r\nBUG();\r\nreturn 0;\r\n}\r\nif (mask & FS_MODIFY) {\r\nif (inode_mark &&\r\n!(inode_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\r\ninode_mark->ignored_mask = 0;\r\nif (vfsmount_mark &&\r\n!(vfsmount_mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY))\r\nvfsmount_mark->ignored_mask = 0;\r\n}\r\nif (inode_mark) {\r\ngroup = inode_mark->group;\r\ninode_test_mask = (mask & ~FS_EVENT_ON_CHILD);\r\ninode_test_mask &= inode_mark->mask;\r\ninode_test_mask &= ~inode_mark->ignored_mask;\r\n}\r\nif (vfsmount_mark) {\r\nvfsmount_test_mask = (mask & ~FS_EVENT_ON_CHILD);\r\ngroup = vfsmount_mark->group;\r\nvfsmount_test_mask &= vfsmount_mark->mask;\r\nvfsmount_test_mask &= ~vfsmount_mark->ignored_mask;\r\nif (inode_mark)\r\nvfsmount_test_mask &= ~inode_mark->ignored_mask;\r\n}\r\npr_debug("%s: group=%p to_tell=%p mask=%x inode_mark=%p"\r\n" inode_test_mask=%x vfsmount_mark=%p vfsmount_test_mask=%x"\r\n" data=%p data_is=%d cookie=%d event=%p\n",\r\n__func__, group, to_tell, mask, inode_mark,\r\ninode_test_mask, vfsmount_mark, vfsmount_test_mask, data,\r\ndata_is, cookie, *event);\r\nif (!inode_test_mask && !vfsmount_test_mask)\r\nreturn 0;\r\nif (group->ops->should_send_event(group, to_tell, inode_mark,\r\nvfsmount_mark, mask, data,\r\ndata_is) == false)\r\nreturn 0;\r\nif (!*event) {\r\n*event = fsnotify_create_event(to_tell, mask, data,\r\ndata_is, file_name,\r\ncookie, GFP_KERNEL);\r\nif (!*event)\r\nreturn -ENOMEM;\r\n}\r\nreturn group->ops->handle_event(group, inode_mark, vfsmount_mark, *event);\r\n}\r\nint fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\r\nconst unsigned char *file_name, u32 cookie)\r\n{\r\nstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\r\nstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\r\nstruct fsnotify_group *inode_group, *vfsmount_group;\r\nstruct fsnotify_event *event = NULL;\r\nstruct mount *mnt;\r\nint idx, ret = 0;\r\n__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\r\nif (data_is == FSNOTIFY_EVENT_PATH)\r\nmnt = real_mount(((struct path *)data)->mnt);\r\nelse\r\nmnt = NULL;\r\nif (!(mask & FS_MODIFY) &&\r\n!(test_mask & to_tell->i_fsnotify_mask) &&\r\n!(mnt && test_mask & mnt->mnt_fsnotify_mask))\r\nreturn 0;\r\nidx = srcu_read_lock(&fsnotify_mark_srcu);\r\nif ((mask & FS_MODIFY) ||\r\n(test_mask & to_tell->i_fsnotify_mask))\r\ninode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\r\n&fsnotify_mark_srcu);\r\nif (mnt && ((mask & FS_MODIFY) ||\r\n(test_mask & mnt->mnt_fsnotify_mask))) {\r\nvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\r\n&fsnotify_mark_srcu);\r\ninode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\r\n&fsnotify_mark_srcu);\r\n}\r\nwhile (inode_node || vfsmount_node) {\r\ninode_group = vfsmount_group = NULL;\r\nif (inode_node) {\r\ninode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\r\nstruct fsnotify_mark, i.i_list);\r\ninode_group = inode_mark->group;\r\n}\r\nif (vfsmount_node) {\r\nvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\r\nstruct fsnotify_mark, m.m_list);\r\nvfsmount_group = vfsmount_mark->group;\r\n}\r\nif (inode_group > vfsmount_group) {\r\nret = send_to_group(to_tell, inode_mark, NULL, mask, data,\r\ndata_is, cookie, file_name, &event);\r\nvfsmount_group = NULL;\r\n} else if (vfsmount_group > inode_group) {\r\nret = send_to_group(to_tell, NULL, vfsmount_mark, mask, data,\r\ndata_is, cookie, file_name, &event);\r\ninode_group = NULL;\r\n} else {\r\nret = send_to_group(to_tell, inode_mark, vfsmount_mark,\r\nmask, data, data_is, cookie, file_name,\r\n&event);\r\n}\r\nif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\r\ngoto out;\r\nif (inode_group)\r\ninode_node = srcu_dereference(inode_node->next,\r\n&fsnotify_mark_srcu);\r\nif (vfsmount_group)\r\nvfsmount_node = srcu_dereference(vfsmount_node->next,\r\n&fsnotify_mark_srcu);\r\n}\r\nret = 0;\r\nout:\r\nsrcu_read_unlock(&fsnotify_mark_srcu, idx);\r\nif (event)\r\nfsnotify_put_event(event);\r\nreturn ret;\r\n}\r\nstatic __init int fsnotify_init(void)\r\n{\r\nint ret;\r\nBUG_ON(hweight32(ALL_FSNOTIFY_EVENTS) != 23);\r\nret = init_srcu_struct(&fsnotify_mark_srcu);\r\nif (ret)\r\npanic("initializing fsnotify_mark_srcu");\r\nreturn 0;\r\n}
