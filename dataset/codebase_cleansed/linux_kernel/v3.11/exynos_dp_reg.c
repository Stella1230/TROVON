void exynos_dp_enable_video_mute(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu32 reg;\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\nreg |= HDCP_VIDEO_MUTE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\nreg &= ~HDCP_VIDEO_MUTE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\n}\r\n}\r\nvoid exynos_dp_stop_video(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\nreg &= ~VIDEO_EN;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\n}\r\nvoid exynos_dp_lane_swap(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu32 reg;\r\nif (enable)\r\nreg = LANE3_MAP_LOGIC_LANE_0 | LANE2_MAP_LOGIC_LANE_1 |\r\nLANE1_MAP_LOGIC_LANE_2 | LANE0_MAP_LOGIC_LANE_3;\r\nelse\r\nreg = LANE3_MAP_LOGIC_LANE_3 | LANE2_MAP_LOGIC_LANE_2 |\r\nLANE1_MAP_LOGIC_LANE_1 | LANE0_MAP_LOGIC_LANE_0;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LANE_MAP);\r\n}\r\nvoid exynos_dp_init_analog_param(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = TX_TERMINAL_CTRL_50_OHM;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_ANALOG_CTL_1);\r\nreg = SEL_24M | TX_DVDD_BIT_1_0625V;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_ANALOG_CTL_2);\r\nreg = DRIVE_DVDD_BIT_1_0625V | VCO_BIT_600_MICRO;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_ANALOG_CTL_3);\r\nreg = PD_RING_OSC | AUX_TERMINAL_CTRL_50_OHM |\r\nTX_CUR1_2X | TX_CUR_16_MA;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PLL_FILTER_CTL_1);\r\nreg = CH3_AMP_400_MV | CH2_AMP_400_MV |\r\nCH1_AMP_400_MV | CH0_AMP_400_MV;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TX_AMP_TUNING_CTL);\r\n}\r\nvoid exynos_dp_init_interrupt(struct exynos_dp_device *dp)\r\n{\r\nwritel(INT_POL1 | INT_POL0, dp->reg_base + EXYNOS_DP_INT_CTL);\r\nwritel(0xff, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_1);\r\nwritel(0x4f, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_2);\r\nwritel(0xe0, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_3);\r\nwritel(0xe7, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_4);\r\nwritel(0x63, dp->reg_base + EXYNOS_DP_INT_STA);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_1);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_2);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_3);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_4);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_INT_STA_MASK);\r\n}\r\nvoid exynos_dp_reset(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nexynos_dp_stop_video(dp);\r\nexynos_dp_enable_video_mute(dp, 0);\r\nreg = MASTER_VID_FUNC_EN_N | SLAVE_VID_FUNC_EN_N |\r\nAUD_FIFO_FUNC_EN_N | AUD_FUNC_EN_N |\r\nHDCP_FUNC_EN_N | SW_FUNC_EN_N;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_1);\r\nreg = SSC_FUNC_EN_N | AUX_FUNC_EN_N |\r\nSERDES_FIFO_FUNC_EN_N |\r\nLS_CLK_DOMAIN_FUNC_EN_N;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\nusleep_range(20, 30);\r\nexynos_dp_lane_swap(dp, 0);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_SYS_CTL_1);\r\nwritel(0x40, dp->reg_base + EXYNOS_DP_SYS_CTL_2);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_PKT_SEND_CTL);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_HDCP_CTL);\r\nwritel(0x5e, dp->reg_base + EXYNOS_DP_HPD_DEGLITCH_L);\r\nwritel(0x1a, dp->reg_base + EXYNOS_DP_HPD_DEGLITCH_H);\r\nwritel(0x10, dp->reg_base + EXYNOS_DP_LINK_DEBUG_CTL);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_PHY_TEST);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_VIDEO_FIFO_THRD);\r\nwritel(0x20, dp->reg_base + EXYNOS_DP_AUDIO_MARGIN);\r\nwritel(0x4, dp->reg_base + EXYNOS_DP_M_VID_GEN_FILTER_TH);\r\nwritel(0x2, dp->reg_base + EXYNOS_DP_M_AUD_GEN_FILTER_TH);\r\nwritel(0x00000101, dp->reg_base + EXYNOS_DP_SOC_GENERAL_CTL);\r\n}\r\nvoid exynos_dp_swreset(struct exynos_dp_device *dp)\r\n{\r\nwritel(RESET_DP_TX, dp->reg_base + EXYNOS_DP_TX_SW_RESET);\r\n}\r\nvoid exynos_dp_config_interrupt(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = COMMON_INT_MASK_1;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_1);\r\nreg = COMMON_INT_MASK_2;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_2);\r\nreg = COMMON_INT_MASK_3;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_3);\r\nreg = COMMON_INT_MASK_4;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_MASK_4);\r\nreg = INT_STA_MASK;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_INT_STA_MASK);\r\n}\r\nenum pll_status exynos_dp_get_pll_lock_status(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_DEBUG_CTL);\r\nif (reg & PLL_LOCK)\r\nreturn PLL_LOCKED;\r\nelse\r\nreturn PLL_UNLOCKED;\r\n}\r\nvoid exynos_dp_set_pll_power_down(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu32 reg;\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PLL_CTL);\r\nreg |= DP_PLL_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PLL_CTL);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PLL_CTL);\r\nreg &= ~DP_PLL_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PLL_CTL);\r\n}\r\n}\r\nvoid exynos_dp_set_analog_power_down(struct exynos_dp_device *dp,\r\nenum analog_power_block block,\r\nbool enable)\r\n{\r\nu32 reg;\r\nswitch (block) {\r\ncase AUX_BLOCK:\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg |= AUX_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg &= ~AUX_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ncase CH0_BLOCK:\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg |= CH0_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg &= ~CH0_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ncase CH1_BLOCK:\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg |= CH1_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg &= ~CH1_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ncase CH2_BLOCK:\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg |= CH2_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg &= ~CH2_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ncase CH3_BLOCK:\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg |= CH3_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg &= ~CH3_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ncase ANALOG_TOTAL:\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg |= DP_PHY_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_PD);\r\nreg &= ~DP_PHY_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ncase POWER_ALL:\r\nif (enable) {\r\nreg = DP_PHY_PD | AUX_PD | CH3_PD | CH2_PD |\r\nCH1_PD | CH0_PD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n} else {\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_PHY_PD);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid exynos_dp_init_analog_func(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nint timeout_loop = 0;\r\nexynos_dp_set_analog_power_down(dp, POWER_ALL, 0);\r\nreg = PLL_LOCK_CHG;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_1);\r\nreg = readl(dp->reg_base + EXYNOS_DP_DEBUG_CTL);\r\nreg &= ~(F_PLL_LOCK | PLL_LOCK_CTRL);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_DEBUG_CTL);\r\nif (exynos_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\r\nexynos_dp_set_pll_power_down(dp, 0);\r\nwhile (exynos_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\r\ntimeout_loop++;\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "failed to get pll lock status\n");\r\nreturn;\r\n}\r\nusleep_range(10, 20);\r\n}\r\n}\r\nreg = readl(dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\nreg &= ~(SERDES_FIFO_FUNC_EN_N | LS_CLK_DOMAIN_FUNC_EN_N\r\n| AUX_FUNC_EN_N);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\n}\r\nvoid exynos_dp_clear_hotplug_interrupts(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = HOTPLUG_CHG | HPD_LOST | PLUG;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_4);\r\nreg = INT_HPD;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_INT_STA);\r\n}\r\nvoid exynos_dp_init_hpd(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nexynos_dp_clear_hotplug_interrupts(dp);\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nreg &= ~(F_HPD | HPD_CTRL);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\n}\r\nenum dp_irq_type exynos_dp_get_irq_type(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_COMMON_INT_STA_4);\r\nif (reg & PLUG)\r\nreturn DP_IRQ_TYPE_HP_CABLE_IN;\r\nif (reg & HPD_LOST)\r\nreturn DP_IRQ_TYPE_HP_CABLE_OUT;\r\nif (reg & HOTPLUG_CHG)\r\nreturn DP_IRQ_TYPE_HP_CHANGE;\r\nreturn DP_IRQ_TYPE_UNKNOWN;\r\n}\r\nvoid exynos_dp_reset_aux(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\nreg |= AUX_FUNC_EN_N;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\n}\r\nvoid exynos_dp_init_aux(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = RPLY_RECEIV | AUX_ERR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_INT_STA);\r\nexynos_dp_reset_aux(dp);\r\nreg = AUX_BIT_PERIOD_EXPECTED_DELAY(3) | AUX_HW_RETRY_COUNT_SEL(0)|\r\nAUX_HW_RETRY_INTERVAL_600_MICROSECONDS;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_HW_RETRY_CTL) ;\r\nreg = DEFER_CTRL_EN | DEFER_COUNT(1);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_DEFER_CTL);\r\nreg = readl(dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\nreg &= ~AUX_FUNC_EN_N;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_2);\r\n}\r\nint exynos_dp_get_plug_in_status(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nif (reg & HPD_STATUS)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nvoid exynos_dp_enable_sw_function(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_FUNC_EN_1);\r\nreg &= ~SW_FUNC_EN_N;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_1);\r\n}\r\nint exynos_dp_start_aux_transaction(struct exynos_dp_device *dp)\r\n{\r\nint reg;\r\nint retval = 0;\r\nint timeout_loop = 0;\r\nreg = readl(dp->reg_base + EXYNOS_DP_AUX_CH_CTL_2);\r\nreg |= AUX_EN;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_2);\r\nreg = readl(dp->reg_base + EXYNOS_DP_INT_STA);\r\nwhile (!(reg & RPLY_RECEIV)) {\r\ntimeout_loop++;\r\nif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\r\ndev_err(dp->dev, "AUX CH command reply failed!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreg = readl(dp->reg_base + EXYNOS_DP_INT_STA);\r\nusleep_range(10, 11);\r\n}\r\nwritel(RPLY_RECEIV, dp->reg_base + EXYNOS_DP_INT_STA);\r\nreg = readl(dp->reg_base + EXYNOS_DP_INT_STA);\r\nif (reg & AUX_ERR) {\r\nwritel(AUX_ERR, dp->reg_base + EXYNOS_DP_INT_STA);\r\nreturn -EREMOTEIO;\r\n}\r\nreg = readl(dp->reg_base + EXYNOS_DP_AUX_CH_STA);\r\nif ((reg & AUX_STATUS_MASK) != 0) {\r\ndev_err(dp->dev, "AUX CH error happens: %d\n\n",\r\nreg & AUX_STATUS_MASK);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn retval;\r\n}\r\nint exynos_dp_write_byte_to_dpcd(struct exynos_dp_device *dp,\r\nunsigned int reg_addr,\r\nunsigned char data)\r\n{\r\nu32 reg;\r\nint i;\r\nint retval;\r\nfor (i = 0; i < 3; i++) {\r\nreg = BUF_CLR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUFFER_DATA_CTL);\r\nreg = AUX_ADDR_7_0(reg_addr);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_7_0);\r\nreg = AUX_ADDR_15_8(reg_addr);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_15_8);\r\nreg = AUX_ADDR_19_16(reg_addr);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_19_16);\r\nreg = (unsigned int)data;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUF_DATA_0);\r\nreg = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval == 0)\r\nbreak;\r\nelse\r\ndev_dbg(dp->dev, "%s: Aux Transaction fail!\n",\r\n__func__);\r\n}\r\nreturn retval;\r\n}\r\nint exynos_dp_read_byte_from_dpcd(struct exynos_dp_device *dp,\r\nunsigned int reg_addr,\r\nunsigned char *data)\r\n{\r\nu32 reg;\r\nint i;\r\nint retval;\r\nfor (i = 0; i < 3; i++) {\r\nreg = BUF_CLR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUFFER_DATA_CTL);\r\nreg = AUX_ADDR_7_0(reg_addr);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_7_0);\r\nreg = AUX_ADDR_15_8(reg_addr);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_15_8);\r\nreg = AUX_ADDR_19_16(reg_addr);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_19_16);\r\nreg = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval == 0)\r\nbreak;\r\nelse\r\ndev_dbg(dp->dev, "%s: Aux Transaction fail!\n",\r\n__func__);\r\n}\r\nreg = readl(dp->reg_base + EXYNOS_DP_BUF_DATA_0);\r\n*data = (unsigned char)(reg & 0xff);\r\nreturn retval;\r\n}\r\nint exynos_dp_write_bytes_to_dpcd(struct exynos_dp_device *dp,\r\nunsigned int reg_addr,\r\nunsigned int count,\r\nunsigned char data[])\r\n{\r\nu32 reg;\r\nunsigned int start_offset;\r\nunsigned int cur_data_count;\r\nunsigned int cur_data_idx;\r\nint i;\r\nint retval = 0;\r\nreg = BUF_CLR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUFFER_DATA_CTL);\r\nstart_offset = 0;\r\nwhile (start_offset < count) {\r\nif ((count - start_offset) > 16)\r\ncur_data_count = 16;\r\nelse\r\ncur_data_count = count - start_offset;\r\nfor (i = 0; i < 3; i++) {\r\nreg = AUX_ADDR_7_0(reg_addr + start_offset);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_7_0);\r\nreg = AUX_ADDR_15_8(reg_addr + start_offset);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_15_8);\r\nreg = AUX_ADDR_19_16(reg_addr + start_offset);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_19_16);\r\nfor (cur_data_idx = 0; cur_data_idx < cur_data_count;\r\ncur_data_idx++) {\r\nreg = data[start_offset + cur_data_idx];\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUF_DATA_0\r\n+ 4 * cur_data_idx);\r\n}\r\nreg = AUX_LENGTH(cur_data_count) |\r\nAUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval == 0)\r\nbreak;\r\nelse\r\ndev_dbg(dp->dev, "%s: Aux Transaction fail!\n",\r\n__func__);\r\n}\r\nstart_offset += cur_data_count;\r\n}\r\nreturn retval;\r\n}\r\nint exynos_dp_read_bytes_from_dpcd(struct exynos_dp_device *dp,\r\nunsigned int reg_addr,\r\nunsigned int count,\r\nunsigned char data[])\r\n{\r\nu32 reg;\r\nunsigned int start_offset;\r\nunsigned int cur_data_count;\r\nunsigned int cur_data_idx;\r\nint i;\r\nint retval = 0;\r\nreg = BUF_CLR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUFFER_DATA_CTL);\r\nstart_offset = 0;\r\nwhile (start_offset < count) {\r\nif ((count - start_offset) > 16)\r\ncur_data_count = 16;\r\nelse\r\ncur_data_count = count - start_offset;\r\nfor (i = 0; i < 3; i++) {\r\nreg = AUX_ADDR_7_0(reg_addr + start_offset);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_7_0);\r\nreg = AUX_ADDR_15_8(reg_addr + start_offset);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_15_8);\r\nreg = AUX_ADDR_19_16(reg_addr + start_offset);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_19_16);\r\nreg = AUX_LENGTH(cur_data_count) |\r\nAUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval == 0)\r\nbreak;\r\nelse\r\ndev_dbg(dp->dev, "%s: Aux Transaction fail!\n",\r\n__func__);\r\n}\r\nfor (cur_data_idx = 0; cur_data_idx < cur_data_count;\r\ncur_data_idx++) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_BUF_DATA_0\r\n+ 4 * cur_data_idx);\r\ndata[start_offset + cur_data_idx] =\r\n(unsigned char)reg;\r\n}\r\nstart_offset += cur_data_count;\r\n}\r\nreturn retval;\r\n}\r\nint exynos_dp_select_i2c_device(struct exynos_dp_device *dp,\r\nunsigned int device_addr,\r\nunsigned int reg_addr)\r\n{\r\nu32 reg;\r\nint retval;\r\nreg = device_addr;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_ADDR_7_0);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_AUX_ADDR_15_8);\r\nwritel(0x0, dp->reg_base + EXYNOS_DP_AUX_ADDR_19_16);\r\nwritel(reg_addr, dp->reg_base + EXYNOS_DP_BUF_DATA_0);\r\nreg = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_MOT |\r\nAUX_TX_COMM_WRITE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval != 0)\r\ndev_dbg(dp->dev, "%s: Aux Transaction fail!\n", __func__);\r\nreturn retval;\r\n}\r\nint exynos_dp_read_byte_from_i2c(struct exynos_dp_device *dp,\r\nunsigned int device_addr,\r\nunsigned int reg_addr,\r\nunsigned int *data)\r\n{\r\nu32 reg;\r\nint i;\r\nint retval;\r\nfor (i = 0; i < 3; i++) {\r\nreg = BUF_CLR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUFFER_DATA_CTL);\r\nretval = exynos_dp_select_i2c_device(dp, device_addr, reg_addr);\r\nif (retval != 0)\r\ncontinue;\r\nreg = AUX_TX_COMM_I2C_TRANSACTION |\r\nAUX_TX_COMM_READ;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval == 0)\r\nbreak;\r\nelse\r\ndev_dbg(dp->dev, "%s: Aux Transaction fail!\n",\r\n__func__);\r\n}\r\nif (retval == 0)\r\n*data = readl(dp->reg_base + EXYNOS_DP_BUF_DATA_0);\r\nreturn retval;\r\n}\r\nint exynos_dp_read_bytes_from_i2c(struct exynos_dp_device *dp,\r\nunsigned int device_addr,\r\nunsigned int reg_addr,\r\nunsigned int count,\r\nunsigned char edid[])\r\n{\r\nu32 reg;\r\nunsigned int i, j;\r\nunsigned int cur_data_idx;\r\nunsigned int defer = 0;\r\nint retval = 0;\r\nfor (i = 0; i < count; i += 16) {\r\nfor (j = 0; j < 3; j++) {\r\nreg = BUF_CLR;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_BUFFER_DATA_CTL);\r\nreg = readl(dp->reg_base + EXYNOS_DP_AUX_CH_CTL_2);\r\nreg &= ~ADDR_ONLY;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_AUX_CH_CTL_2);\r\nif (!defer)\r\nretval = exynos_dp_select_i2c_device(dp,\r\ndevice_addr, reg_addr + i);\r\nelse\r\ndefer = 0;\r\nif (retval == 0) {\r\nreg = AUX_LENGTH(16) |\r\nAUX_TX_COMM_I2C_TRANSACTION |\r\nAUX_TX_COMM_READ;\r\nwritel(reg, dp->reg_base +\r\nEXYNOS_DP_AUX_CH_CTL_1);\r\nretval = exynos_dp_start_aux_transaction(dp);\r\nif (retval == 0)\r\nbreak;\r\nelse\r\ndev_dbg(dp->dev,\r\n"%s: Aux Transaction fail!\n",\r\n__func__);\r\n}\r\nreg = readl(dp->reg_base + EXYNOS_DP_AUX_RX_COMM);\r\nif (reg == AUX_RX_COMM_AUX_DEFER ||\r\nreg == AUX_RX_COMM_I2C_DEFER) {\r\ndev_err(dp->dev, "Defer: %d\n\n", reg);\r\ndefer = 1;\r\n}\r\n}\r\nfor (cur_data_idx = 0; cur_data_idx < 16; cur_data_idx++) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_BUF_DATA_0\r\n+ 4 * cur_data_idx);\r\nedid[i + cur_data_idx] = (unsigned char)reg;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nvoid exynos_dp_set_link_bandwidth(struct exynos_dp_device *dp, u32 bwtype)\r\n{\r\nu32 reg;\r\nreg = bwtype;\r\nif ((bwtype == LINK_RATE_2_70GBPS) || (bwtype == LINK_RATE_1_62GBPS))\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LINK_BW_SET);\r\n}\r\nvoid exynos_dp_get_link_bandwidth(struct exynos_dp_device *dp, u32 *bwtype)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LINK_BW_SET);\r\n*bwtype = reg;\r\n}\r\nvoid exynos_dp_set_lane_count(struct exynos_dp_device *dp, u32 count)\r\n{\r\nu32 reg;\r\nreg = count;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LANE_COUNT_SET);\r\n}\r\nvoid exynos_dp_get_lane_count(struct exynos_dp_device *dp, u32 *count)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LANE_COUNT_SET);\r\n*count = reg;\r\n}\r\nvoid exynos_dp_enable_enhanced_mode(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu32 reg;\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nreg |= ENHANCED;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nreg &= ~ENHANCED;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\n}\r\n}\r\nvoid exynos_dp_set_training_pattern(struct exynos_dp_device *dp,\r\nenum pattern_set pattern)\r\n{\r\nu32 reg;\r\nswitch (pattern) {\r\ncase PRBS7:\r\nreg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_PRBS7;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nbreak;\r\ncase D10_2:\r\nreg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_D10_2;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nbreak;\r\ncase TRAINING_PTN1:\r\nreg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN1;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nbreak;\r\ncase TRAINING_PTN2:\r\nreg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN2;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nbreak;\r\ncase DP_NONE:\r\nreg = SCRAMBLING_ENABLE |\r\nLINK_QUAL_PATTERN_SET_DISABLE |\r\nSW_TRAINING_PATTERN_SET_NORMAL;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid exynos_dp_set_lane0_pre_emphasis(struct exynos_dp_device *dp, u32 level)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN0_LINK_TRAINING_CTL);\r\nreg &= ~PRE_EMPHASIS_SET_MASK;\r\nreg |= level << PRE_EMPHASIS_SET_SHIFT;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN0_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane1_pre_emphasis(struct exynos_dp_device *dp, u32 level)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN1_LINK_TRAINING_CTL);\r\nreg &= ~PRE_EMPHASIS_SET_MASK;\r\nreg |= level << PRE_EMPHASIS_SET_SHIFT;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN1_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane2_pre_emphasis(struct exynos_dp_device *dp, u32 level)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN2_LINK_TRAINING_CTL);\r\nreg &= ~PRE_EMPHASIS_SET_MASK;\r\nreg |= level << PRE_EMPHASIS_SET_SHIFT;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN2_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane3_pre_emphasis(struct exynos_dp_device *dp, u32 level)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN3_LINK_TRAINING_CTL);\r\nreg &= ~PRE_EMPHASIS_SET_MASK;\r\nreg |= level << PRE_EMPHASIS_SET_SHIFT;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN3_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane0_link_training(struct exynos_dp_device *dp,\r\nu32 training_lane)\r\n{\r\nu32 reg;\r\nreg = training_lane;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN0_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane1_link_training(struct exynos_dp_device *dp,\r\nu32 training_lane)\r\n{\r\nu32 reg;\r\nreg = training_lane;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN1_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane2_link_training(struct exynos_dp_device *dp,\r\nu32 training_lane)\r\n{\r\nu32 reg;\r\nreg = training_lane;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN2_LINK_TRAINING_CTL);\r\n}\r\nvoid exynos_dp_set_lane3_link_training(struct exynos_dp_device *dp,\r\nu32 training_lane)\r\n{\r\nu32 reg;\r\nreg = training_lane;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_LN3_LINK_TRAINING_CTL);\r\n}\r\nu32 exynos_dp_get_lane0_link_training(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN0_LINK_TRAINING_CTL);\r\nreturn reg;\r\n}\r\nu32 exynos_dp_get_lane1_link_training(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN1_LINK_TRAINING_CTL);\r\nreturn reg;\r\n}\r\nu32 exynos_dp_get_lane2_link_training(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN2_LINK_TRAINING_CTL);\r\nreturn reg;\r\n}\r\nu32 exynos_dp_get_lane3_link_training(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_LN3_LINK_TRAINING_CTL);\r\nreturn reg;\r\n}\r\nvoid exynos_dp_reset_macro(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_PHY_TEST);\r\nreg |= MACRO_RST;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_TEST);\r\nusleep_range(10, 20);\r\nreg &= ~MACRO_RST;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_PHY_TEST);\r\n}\r\nvoid exynos_dp_init_video(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = VSYNC_DET | VID_FORMAT_CHG | VID_CLK_CHG;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_COMMON_INT_STA_1);\r\nreg = 0x0;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_1);\r\nreg = CHA_CRI(4) | CHA_CTRL;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_2);\r\nreg = 0x0;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nreg = VID_HRES_TH(2) | VID_VRES_TH(0);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_8);\r\n}\r\nvoid exynos_dp_set_video_color_format(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = (dp->video_info->dynamic_range << IN_D_RANGE_SHIFT) |\r\n(dp->video_info->color_depth << IN_BPC_SHIFT) |\r\n(dp->video_info->color_space << IN_COLOR_F_SHIFT);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_2);\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_3);\r\nreg &= ~IN_YC_COEFFI_MASK;\r\nif (dp->video_info->ycbcr_coeff)\r\nreg |= IN_YC_COEFFI_ITU709;\r\nelse\r\nreg |= IN_YC_COEFFI_ITU601;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_3);\r\n}\r\nint exynos_dp_is_slave_video_stream_clock_on(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_1);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_1);\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_1);\r\nif (!(reg & DET_STA)) {\r\ndev_dbg(dp->dev, "Input stream clock not detected.\n");\r\nreturn -EINVAL;\r\n}\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_2);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_2);\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_2);\r\ndev_dbg(dp->dev, "wait SYS_CTL_2.\n");\r\nif (reg & CHA_STA) {\r\ndev_dbg(dp->dev, "Input stream clk is changing\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid exynos_dp_set_video_cr_mn(struct exynos_dp_device *dp,\r\nenum clock_recovery_m_value_type type,\r\nu32 m_value,\r\nu32 n_value)\r\n{\r\nu32 reg;\r\nif (type == REGISTER_M) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nreg |= FIX_M_VID;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nreg = m_value & 0xff;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_M_VID_0);\r\nreg = (m_value >> 8) & 0xff;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_M_VID_1);\r\nreg = (m_value >> 16) & 0xff;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_M_VID_2);\r\nreg = n_value & 0xff;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_N_VID_0);\r\nreg = (n_value >> 8) & 0xff;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_N_VID_1);\r\nreg = (n_value >> 16) & 0xff;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_N_VID_2);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nreg &= ~FIX_M_VID;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_4);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_N_VID_0);\r\nwritel(0x80, dp->reg_base + EXYNOS_DP_N_VID_1);\r\nwritel(0x00, dp->reg_base + EXYNOS_DP_N_VID_2);\r\n}\r\n}\r\nvoid exynos_dp_set_video_timing_mode(struct exynos_dp_device *dp, u32 type)\r\n{\r\nu32 reg;\r\nif (type == VIDEO_TIMING_FROM_CAPTURE) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg &= ~FORMAT_SEL;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg |= FORMAT_SEL;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\n}\r\n}\r\nvoid exynos_dp_enable_video_master(struct exynos_dp_device *dp, bool enable)\r\n{\r\nu32 reg;\r\nif (enable) {\r\nreg = readl(dp->reg_base + EXYNOS_DP_SOC_GENERAL_CTL);\r\nreg &= ~VIDEO_MODE_MASK;\r\nreg |= VIDEO_MASTER_MODE_EN | VIDEO_MODE_MASTER_MODE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SOC_GENERAL_CTL);\r\n} else {\r\nreg = readl(dp->reg_base + EXYNOS_DP_SOC_GENERAL_CTL);\r\nreg &= ~VIDEO_MODE_MASK;\r\nreg |= VIDEO_MODE_SLAVE_MODE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SOC_GENERAL_CTL);\r\n}\r\n}\r\nvoid exynos_dp_start_video(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\nreg |= VIDEO_EN;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_1);\r\n}\r\nint exynos_dp_is_video_stream_on(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nreg = readl(dp->reg_base + EXYNOS_DP_SYS_CTL_3);\r\nif (!(reg & STRM_VALID)) {\r\ndev_dbg(dp->dev, "Input video stream is not detected.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid exynos_dp_config_video_slave_mode(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_FUNC_EN_1);\r\nreg &= ~(MASTER_VID_FUNC_EN_N|SLAVE_VID_FUNC_EN_N);\r\nreg |= MASTER_VID_FUNC_EN_N;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_FUNC_EN_1);\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg &= ~INTERACE_SCAN_CFG;\r\nreg |= (dp->video_info->interlaced << 2);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg &= ~VSYNC_POLARITY_CFG;\r\nreg |= (dp->video_info->v_sync_polarity << 1);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg = readl(dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg &= ~HSYNC_POLARITY_CFG;\r\nreg |= (dp->video_info->h_sync_polarity << 0);\r\nwritel(reg, dp->reg_base + EXYNOS_DP_VIDEO_CTL_10);\r\nreg = AUDIO_MODE_SPDIF_MODE | VIDEO_MODE_SLAVE_MODE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_SOC_GENERAL_CTL);\r\n}\r\nvoid exynos_dp_enable_scrambling(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nreg &= ~SCRAMBLING_DISABLE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\n}\r\nvoid exynos_dp_disable_scrambling(struct exynos_dp_device *dp)\r\n{\r\nu32 reg;\r\nreg = readl(dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\nreg |= SCRAMBLING_DISABLE;\r\nwritel(reg, dp->reg_base + EXYNOS_DP_TRAINING_PTN_SET);\r\n}
