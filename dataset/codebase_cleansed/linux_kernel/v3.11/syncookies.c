static __init int init_syncookies(void)\r\n{\r\nget_random_bytes(syncookie_secret, sizeof(syncookie_secret));\r\nreturn 0;\r\n}\r\nstatic u32 cookie_hash(__be32 saddr, __be32 daddr, __be16 sport, __be16 dport,\r\nu32 count, int c)\r\n{\r\n__u32 *tmp = __get_cpu_var(ipv4_cookie_scratch);\r\nmemcpy(tmp + 4, syncookie_secret[c], sizeof(syncookie_secret[c]));\r\ntmp[0] = (__force u32)saddr;\r\ntmp[1] = (__force u32)daddr;\r\ntmp[2] = ((__force u32)sport << 16) + (__force u32)dport;\r\ntmp[3] = count;\r\nsha_transform(tmp + 16, (__u8 *)tmp, tmp + 16 + 5);\r\nreturn tmp[17];\r\n}\r\n__u32 cookie_init_timestamp(struct request_sock *req)\r\n{\r\nstruct inet_request_sock *ireq;\r\nu32 ts, ts_now = tcp_time_stamp;\r\nu32 options = 0;\r\nireq = inet_rsk(req);\r\noptions = ireq->wscale_ok ? ireq->snd_wscale : 0xf;\r\noptions |= ireq->sack_ok << 4;\r\noptions |= ireq->ecn_ok << 5;\r\nts = ts_now & ~TSMASK;\r\nts |= options;\r\nif (ts > ts_now) {\r\nts >>= TSBITS;\r\nts--;\r\nts <<= TSBITS;\r\nts |= options;\r\n}\r\nreturn ts;\r\n}\r\nstatic __u32 secure_tcp_syn_cookie(__be32 saddr, __be32 daddr, __be16 sport,\r\n__be16 dport, __u32 sseq, __u32 count,\r\n__u32 data)\r\n{\r\nreturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\r\nsseq + (count << COOKIEBITS) +\r\n((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\r\n& COOKIEMASK));\r\n}\r\nstatic __u32 check_tcp_syn_cookie(__u32 cookie, __be32 saddr, __be32 daddr,\r\n__be16 sport, __be16 dport, __u32 sseq,\r\n__u32 count, __u32 maxdiff)\r\n{\r\n__u32 diff;\r\ncookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\r\ndiff = (count - (cookie >> COOKIEBITS)) & ((__u32) - 1 >> COOKIEBITS);\r\nif (diff >= maxdiff)\r\nreturn (__u32)-1;\r\nreturn (cookie -\r\ncookie_hash(saddr, daddr, sport, dport, count - diff, 1))\r\n& COOKIEMASK;\r\n}\r\n__u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, __u16 *mssp)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\nint mssind;\r\nconst __u16 mss = *mssp;\r\ntcp_synq_overflow(sk);\r\nfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\r\nif (mss >= msstab[mssind])\r\nbreak;\r\n*mssp = msstab[mssind];\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESSENT);\r\nreturn secure_tcp_syn_cookie(iph->saddr, iph->daddr,\r\nth->source, th->dest, ntohl(th->seq),\r\njiffies / (HZ * 60), mssind);\r\n}\r\nstatic inline int cookie_check(struct sk_buff *skb, __u32 cookie)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\n__u32 seq = ntohl(th->seq) - 1;\r\n__u32 mssind = check_tcp_syn_cookie(cookie, iph->saddr, iph->daddr,\r\nth->source, th->dest, seq,\r\njiffies / (HZ * 60),\r\nCOUNTER_TRIES);\r\nreturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\r\n}\r\nstatic inline struct sock *get_cookie_sock(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *req,\r\nstruct dst_entry *dst)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct sock *child;\r\nchild = icsk->icsk_af_ops->syn_recv_sock(sk, skb, req, dst);\r\nif (child)\r\ninet_csk_reqsk_queue_add(sk, req, child);\r\nelse\r\nreqsk_free(req);\r\nreturn child;\r\n}\r\nbool cookie_check_timestamp(struct tcp_options_received *tcp_opt,\r\nstruct net *net, bool *ecn_ok)\r\n{\r\nu32 options = tcp_opt->rcv_tsecr & TSMASK;\r\nif (!tcp_opt->saw_tstamp) {\r\ntcp_clear_options(tcp_opt);\r\nreturn true;\r\n}\r\nif (!sysctl_tcp_timestamps)\r\nreturn false;\r\ntcp_opt->sack_ok = (options & (1 << 4)) ? TCP_SACK_SEEN : 0;\r\n*ecn_ok = (options >> 5) & 1;\r\nif (*ecn_ok && !net->ipv4.sysctl_tcp_ecn)\r\nreturn false;\r\nif (tcp_opt->sack_ok && !sysctl_tcp_sack)\r\nreturn false;\r\nif ((options & 0xf) == 0xf)\r\nreturn true;\r\ntcp_opt->wscale_ok = 1;\r\ntcp_opt->snd_wscale = options & 0xf;\r\nreturn sysctl_tcp_window_scaling != 0;\r\n}\r\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,\r\nstruct ip_options *opt)\r\n{\r\nstruct tcp_options_received tcp_opt;\r\nstruct inet_request_sock *ireq;\r\nstruct tcp_request_sock *treq;\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\n__u32 cookie = ntohl(th->ack_seq) - 1;\r\nstruct sock *ret = sk;\r\nstruct request_sock *req;\r\nint mss;\r\nstruct rtable *rt;\r\n__u8 rcv_wscale;\r\nbool ecn_ok = false;\r\nstruct flowi4 fl4;\r\nif (!sysctl_tcp_syncookies || !th->ack || th->rst)\r\ngoto out;\r\nif (tcp_synq_no_recent_overflow(sk) ||\r\n(mss = cookie_check(skb, cookie)) == 0) {\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\r\ngoto out;\r\n}\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\r\nmemset(&tcp_opt, 0, sizeof(tcp_opt));\r\ntcp_parse_options(skb, &tcp_opt, 0, NULL);\r\nif (!cookie_check_timestamp(&tcp_opt, sock_net(sk), &ecn_ok))\r\ngoto out;\r\nret = NULL;\r\nreq = inet_reqsk_alloc(&tcp_request_sock_ops);\r\nif (!req)\r\ngoto out;\r\nireq = inet_rsk(req);\r\ntreq = tcp_rsk(req);\r\ntreq->rcv_isn = ntohl(th->seq) - 1;\r\ntreq->snt_isn = cookie;\r\nreq->mss = mss;\r\nireq->loc_port = th->dest;\r\nireq->rmt_port = th->source;\r\nireq->loc_addr = ip_hdr(skb)->daddr;\r\nireq->rmt_addr = ip_hdr(skb)->saddr;\r\nireq->ecn_ok = ecn_ok;\r\nireq->snd_wscale = tcp_opt.snd_wscale;\r\nireq->sack_ok = tcp_opt.sack_ok;\r\nireq->wscale_ok = tcp_opt.wscale_ok;\r\nireq->tstamp_ok = tcp_opt.saw_tstamp;\r\nreq->ts_recent = tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\r\ntreq->snt_synack = tcp_opt.saw_tstamp ? tcp_opt.rcv_tsecr : 0;\r\ntreq->listener = NULL;\r\nif (opt && opt->optlen) {\r\nint opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\r\nireq->opt = kmalloc(opt_size, GFP_ATOMIC);\r\nif (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\r\nkfree(ireq->opt);\r\nireq->opt = NULL;\r\n}\r\n}\r\nif (security_inet_conn_request(sk, skb, req)) {\r\nreqsk_free(req);\r\ngoto out;\r\n}\r\nreq->expires = 0UL;\r\nreq->num_retrans = 0;\r\nflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\r\nRT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, IPPROTO_TCP,\r\ninet_sk_flowi_flags(sk),\r\n(opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\r\nireq->loc_addr, th->source, th->dest);\r\nsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\r\nrt = ip_route_output_key(sock_net(sk), &fl4);\r\nif (IS_ERR(rt)) {\r\nreqsk_free(req);\r\ngoto out;\r\n}\r\nreq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\r\ntcp_select_initial_window(tcp_full_space(sk), req->mss,\r\n&req->rcv_wnd, &req->window_clamp,\r\nireq->wscale_ok, &rcv_wscale,\r\ndst_metric(&rt->dst, RTAX_INITRWND));\r\nireq->rcv_wscale = rcv_wscale;\r\nret = get_cookie_sock(sk, skb, req, &rt->dst);\r\nif (ret)\r\ninet_sk(ret)->cork.fl.u.ip4 = fl4;\r\nout: return ret;\r\n}
