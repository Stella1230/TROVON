void ast_set_index_reg_mask(struct ast_private *ast,\r\nuint32_t base, uint8_t index,\r\nuint8_t mask, uint8_t val)\r\n{\r\nu8 tmp;\r\nast_io_write8(ast, base, index);\r\ntmp = (ast_io_read8(ast, base + 1) & mask) | val;\r\nast_set_index_reg(ast, base, index, tmp);\r\n}\r\nuint8_t ast_get_index_reg(struct ast_private *ast,\r\nuint32_t base, uint8_t index)\r\n{\r\nuint8_t ret;\r\nast_io_write8(ast, base, index);\r\nret = ast_io_read8(ast, base + 1);\r\nreturn ret;\r\n}\r\nuint8_t ast_get_index_reg_mask(struct ast_private *ast,\r\nuint32_t base, uint8_t index, uint8_t mask)\r\n{\r\nuint8_t ret;\r\nast_io_write8(ast, base, index);\r\nret = ast_io_read8(ast, base + 1) & mask;\r\nreturn ret;\r\n}\r\nstatic int ast_detect_chip(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nif (dev->pdev->device == PCI_CHIP_AST1180) {\r\nast->chip = AST1100;\r\nDRM_INFO("AST 1180 detected\n");\r\n} else {\r\nif (dev->pdev->revision >= 0x20) {\r\nast->chip = AST2300;\r\nDRM_INFO("AST 2300 detected\n");\r\n} else if (dev->pdev->revision >= 0x10) {\r\nuint32_t data;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\ndata = ast_read32(ast, 0x1207c);\r\nswitch (data & 0x0300) {\r\ncase 0x0200:\r\nast->chip = AST1100;\r\nDRM_INFO("AST 1100 detected\n");\r\nbreak;\r\ncase 0x0100:\r\nast->chip = AST2200;\r\nDRM_INFO("AST 2200 detected\n");\r\nbreak;\r\ncase 0x0000:\r\nast->chip = AST2150;\r\nDRM_INFO("AST 2150 detected\n");\r\nbreak;\r\ndefault:\r\nast->chip = AST2100;\r\nDRM_INFO("AST 2100 detected\n");\r\nbreak;\r\n}\r\nast->vga2_clone = false;\r\n} else {\r\nast->chip = 2000;\r\nDRM_INFO("AST 2000 detected\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ast_get_dram_info(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nuint32_t data, data2;\r\nuint32_t denum, num, div, ref_pll;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x10000, 0xfc600309);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x10000) != 0x01);\r\ndata = ast_read32(ast, 0x10004);\r\nif (data & 0x400)\r\nast->dram_bus_width = 16;\r\nelse\r\nast->dram_bus_width = 32;\r\nif (ast->chip == AST2300) {\r\nswitch (data & 0x03) {\r\ncase 0:\r\nast->dram_type = AST_DRAM_512Mx16;\r\nbreak;\r\ndefault:\r\ncase 1:\r\nast->dram_type = AST_DRAM_1Gx16;\r\nbreak;\r\ncase 2:\r\nast->dram_type = AST_DRAM_2Gx16;\r\nbreak;\r\ncase 3:\r\nast->dram_type = AST_DRAM_4Gx16;\r\nbreak;\r\n}\r\n} else {\r\nswitch (data & 0x0c) {\r\ncase 0:\r\ncase 4:\r\nast->dram_type = AST_DRAM_512Mx16;\r\nbreak;\r\ncase 8:\r\nif (data & 0x40)\r\nast->dram_type = AST_DRAM_1Gx16;\r\nelse\r\nast->dram_type = AST_DRAM_512Mx32;\r\nbreak;\r\ncase 0xc:\r\nast->dram_type = AST_DRAM_1Gx32;\r\nbreak;\r\n}\r\n}\r\ndata = ast_read32(ast, 0x10120);\r\ndata2 = ast_read32(ast, 0x10170);\r\nif (data2 & 0x2000)\r\nref_pll = 14318;\r\nelse\r\nref_pll = 12000;\r\ndenum = data & 0x1f;\r\nnum = (data & 0x3fe0) >> 5;\r\ndata = (data & 0xc000) >> 14;\r\nswitch (data) {\r\ncase 3:\r\ndiv = 0x4;\r\nbreak;\r\ncase 2:\r\ncase 1:\r\ndiv = 0x2;\r\nbreak;\r\ndefault:\r\ndiv = 0x1;\r\nbreak;\r\n}\r\nast->mclk = ref_pll * (num + 2) / (denum + 2) * (div * 1000);\r\nreturn 0;\r\n}\r\nuint32_t ast_get_max_dclk(struct drm_device *dev, int bpp)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nuint32_t dclk, jreg;\r\nuint32_t dram_bus_width, mclk, dram_bandwidth, actual_dram_bandwidth, dram_efficency = 500;\r\ndram_bus_width = ast->dram_bus_width;\r\nmclk = ast->mclk;\r\nif (ast->chip == AST2100 ||\r\nast->chip == AST1100 ||\r\nast->chip == AST2200 ||\r\nast->chip == AST2150 ||\r\nast->dram_bus_width == 16)\r\ndram_efficency = 600;\r\nelse if (ast->chip == AST2300)\r\ndram_efficency = 400;\r\ndram_bandwidth = mclk * dram_bus_width * 2 / 8;\r\nactual_dram_bandwidth = dram_bandwidth * dram_efficency / 1000;\r\nif (ast->chip == AST1180)\r\ndclk = actual_dram_bandwidth / ((bpp + 1) / 8);\r\nelse {\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\nif ((jreg & 0x08) && (ast->chip == AST2000))\r\ndclk = actual_dram_bandwidth / ((bpp + 1 + 16) / 8);\r\nelse if ((jreg & 0x08) && (bpp == 8))\r\ndclk = actual_dram_bandwidth / ((bpp + 1 + 24) / 8);\r\nelse\r\ndclk = actual_dram_bandwidth / ((bpp + 1) / 8);\r\n}\r\nif (ast->chip == AST2100 ||\r\nast->chip == AST2200 ||\r\nast->chip == AST2300 ||\r\nast->chip == AST1180) {\r\nif (dclk > 200)\r\ndclk = 200;\r\n} else {\r\nif (dclk > 165)\r\ndclk = 165;\r\n}\r\nreturn dclk;\r\n}\r\nstatic void ast_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct ast_framebuffer *ast_fb = to_ast_framebuffer(fb);\r\nif (ast_fb->obj)\r\ndrm_gem_object_unreference_unlocked(ast_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\nint ast_framebuffer_init(struct drm_device *dev,\r\nstruct ast_framebuffer *ast_fb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\ndrm_helper_mode_fill_fb_struct(&ast_fb->base, mode_cmd);\r\nast_fb->obj = obj;\r\nret = drm_framebuffer_init(dev, &ast_fb->base, &ast_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("framebuffer init failed %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nast_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct ast_framebuffer *ast_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, filp, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nast_fb = kzalloc(sizeof(*ast_fb), GFP_KERNEL);\r\nif (!ast_fb) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = ast_framebuffer_init(dev, ast_fb, mode_cmd, obj);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nkfree(ast_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &ast_fb->base;\r\n}\r\nstatic u32 ast_get_vram_info(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 jreg;\r\nast_open_key(ast);\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xaa, 0xff);\r\nswitch (jreg & 3) {\r\ncase 0: return AST_VIDMEM_SIZE_8M;\r\ncase 1: return AST_VIDMEM_SIZE_16M;\r\ncase 2: return AST_VIDMEM_SIZE_32M;\r\ncase 3: return AST_VIDMEM_SIZE_64M;\r\n}\r\nreturn AST_VIDMEM_DEFAULT_SIZE;\r\n}\r\nint ast_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct ast_private *ast;\r\nint ret = 0;\r\nast = kzalloc(sizeof(struct ast_private), GFP_KERNEL);\r\nif (!ast)\r\nreturn -ENOMEM;\r\ndev->dev_private = ast;\r\nast->dev = dev;\r\nast->regs = pci_iomap(dev->pdev, 1, 0);\r\nif (!ast->regs) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nast->ioregs = pci_iomap(dev->pdev, 2, 0);\r\nif (!ast->ioregs) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nast_detect_chip(dev);\r\nif (ast->chip != AST1180) {\r\nast_get_dram_info(dev);\r\nast->vram_size = ast_get_vram_info(dev);\r\nDRM_INFO("dram %d %d %d %08x\n", ast->mclk, ast->dram_type, ast->dram_bus_width, ast->vram_size);\r\n}\r\nret = ast_mm_init(ast);\r\nif (ret)\r\ngoto out_free;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = (void *)&ast_mode_funcs;\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.prefer_shadow = 1;\r\nif (ast->chip == AST2100 ||\r\nast->chip == AST2200 ||\r\nast->chip == AST2300 ||\r\nast->chip == AST1180) {\r\ndev->mode_config.max_width = 1920;\r\ndev->mode_config.max_height = 2048;\r\n} else {\r\ndev->mode_config.max_width = 1600;\r\ndev->mode_config.max_height = 1200;\r\n}\r\nret = ast_mode_init(dev);\r\nif (ret)\r\ngoto out_free;\r\nret = ast_fbdev_init(dev);\r\nif (ret)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nkfree(ast);\r\ndev->dev_private = NULL;\r\nreturn ret;\r\n}\r\nint ast_driver_unload(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nast_mode_fini(dev);\r\nast_fbdev_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\nast_mm_fini(ast);\r\npci_iounmap(dev->pdev, ast->ioregs);\r\npci_iounmap(dev->pdev, ast->regs);\r\nkfree(ast);\r\nreturn 0;\r\n}\r\nint ast_gem_create(struct drm_device *dev,\r\nu32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct ast_bo *astbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = roundup(size, PAGE_SIZE);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nret = ast_bo_create(dev, size, 0, 0, &astbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object\n");\r\nreturn ret;\r\n}\r\n*obj = &astbo->gem;\r\nreturn 0;\r\n}\r\nint ast_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nint ret;\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nret = ast_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nint ast_dumb_destroy(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle)\r\n{\r\nreturn drm_gem_handle_delete(file, handle);\r\n}\r\nint ast_gem_init_object(struct drm_gem_object *obj)\r\n{\r\nBUG();\r\nreturn 0;\r\n}\r\nvoid ast_bo_unref(struct ast_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\nif (tbo == NULL)\r\n*bo = NULL;\r\n}\r\nvoid ast_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct ast_bo *ast_bo = gem_to_ast_bo(obj);\r\nif (!ast_bo)\r\nreturn;\r\nast_bo_unref(&ast_bo);\r\n}\r\nstatic inline u64 ast_bo_mmap_offset(struct ast_bo *bo)\r\n{\r\nreturn bo->bo.addr_space_offset;\r\n}\r\nint\r\nast_dumb_mmap_offset(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nstruct ast_bo *bo;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nbo = gem_to_ast_bo(obj);\r\n*offset = ast_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference(obj);\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
