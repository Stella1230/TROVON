static inline void sound_silence(void)\r\n{\r\ndmasound.mach.silence();\r\n}\r\nstatic inline int sound_set_format(int format)\r\n{\r\nreturn dmasound.mach.setFormat(format);\r\n}\r\nstatic int sound_set_speed(int speed)\r\n{\r\nif (speed < 0)\r\nreturn dmasound.soft.speed;\r\nif (dmasound.mach.max_dsp_speed &&\r\n(speed > dmasound.mach.max_dsp_speed))\r\nspeed = dmasound.mach.max_dsp_speed ;\r\ndmasound.soft.speed = speed;\r\nif (dmasound.minDev == SND_DEV_DSP)\r\ndmasound.dsp.speed = dmasound.soft.speed;\r\nreturn dmasound.soft.speed;\r\n}\r\nstatic int sound_set_stereo(int stereo)\r\n{\r\nif (stereo < 0)\r\nreturn dmasound.soft.stereo;\r\nstereo = !!stereo;\r\ndmasound.soft.stereo = stereo;\r\nif (dmasound.minDev == SND_DEV_DSP)\r\ndmasound.dsp.stereo = stereo;\r\nreturn stereo;\r\n}\r\nstatic ssize_t sound_copy_translate(TRANS *trans, const u_char __user *userPtr,\r\nsize_t userCount, u_char frame[],\r\nssize_t *frameUsed, ssize_t frameLeft)\r\n{\r\nssize_t (*ct_func)(const u_char __user *, size_t, u_char *, ssize_t *, ssize_t);\r\nswitch (dmasound.soft.format) {\r\ncase AFMT_MU_LAW:\r\nct_func = trans->ct_ulaw;\r\nbreak;\r\ncase AFMT_A_LAW:\r\nct_func = trans->ct_alaw;\r\nbreak;\r\ncase AFMT_S8:\r\nct_func = trans->ct_s8;\r\nbreak;\r\ncase AFMT_U8:\r\nct_func = trans->ct_u8;\r\nbreak;\r\ncase AFMT_S16_BE:\r\nct_func = trans->ct_s16be;\r\nbreak;\r\ncase AFMT_U16_BE:\r\nct_func = trans->ct_u16be;\r\nbreak;\r\ncase AFMT_S16_LE:\r\nct_func = trans->ct_s16le;\r\nbreak;\r\ncase AFMT_U16_LE:\r\nct_func = trans->ct_u16le;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (ct_func)\r\nreturn ct_func(userPtr, userCount, frame, frameUsed, frameLeft);\r\nreturn 0;\r\n}\r\nstatic int mixer_open(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&dmasound_core_mutex);\r\nif (!try_module_get(dmasound.mach.owner)) {\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn -ENODEV;\r\n}\r\nmixer.busy = 1;\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixer_release(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&dmasound_core_mutex);\r\nmixer.busy = 0;\r\nmodule_put(dmasound.mach.owner);\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn 0;\r\n}\r\nstatic int mixer_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE)\r\nmixer.modify_counter++;\r\nswitch (cmd) {\r\ncase OSS_GETVERSION:\r\nreturn IOCTL_OUT(arg, SOUND_VERSION);\r\ncase SOUND_MIXER_INFO:\r\n{\r\nmixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, dmasound.mach.name2, sizeof(info.id));\r\nstrlcpy(info.name, dmasound.mach.name2, sizeof(info.name));\r\ninfo.modify_counter = mixer.modify_counter;\r\nif (copy_to_user((void __user *)arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nif (dmasound.mach.mixer_ioctl)\r\nreturn dmasound.mach.mixer_ioctl(cmd, arg);\r\nreturn -EINVAL;\r\n}\r\nstatic long mixer_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nint ret;\r\nmutex_lock(&dmasound_core_mutex);\r\nret = mixer_ioctl(file, cmd, arg);\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn ret;\r\n}\r\nstatic void mixer_init(void)\r\n{\r\n#ifndef MODULE\r\nint mixer_unit;\r\n#endif\r\nmixer_unit = register_sound_mixer(&mixer_fops, -1);\r\nif (mixer_unit < 0)\r\nreturn;\r\nmixer.busy = 0;\r\ndmasound.treble = 0;\r\ndmasound.bass = 0;\r\nif (dmasound.mach.mixer_init)\r\ndmasound.mach.mixer_init();\r\n}\r\nstatic int sq_allocate_buffers(struct sound_queue *sq, int num, int size)\r\n{\r\nint i;\r\nif (sq->buffers)\r\nreturn 0;\r\nsq->numBufs = num;\r\nsq->bufSize = size;\r\nsq->buffers = kmalloc (num * sizeof(char *), GFP_KERNEL);\r\nif (!sq->buffers)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num; i++) {\r\nsq->buffers[i] = dmasound.mach.dma_alloc(size, GFP_KERNEL);\r\nif (!sq->buffers[i]) {\r\nwhile (i--)\r\ndmasound.mach.dma_free(sq->buffers[i], size);\r\nkfree(sq->buffers);\r\nsq->buffers = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sq_release_buffers(struct sound_queue *sq)\r\n{\r\nint i;\r\nif (sq->buffers) {\r\nfor (i = 0; i < sq->numBufs; i++)\r\ndmasound.mach.dma_free(sq->buffers[i], sq->bufSize);\r\nkfree(sq->buffers);\r\nsq->buffers = NULL;\r\n}\r\n}\r\nstatic int sq_setup(struct sound_queue *sq)\r\n{\r\nint (*setup_func)(void) = NULL;\r\nint hard_frame ;\r\nif (sq->locked) {\r\n#ifdef DEBUG_DMASOUND\r\nprintk("dmasound_core: tried to sq_setup a locked queue\n") ;\r\n#endif\r\nreturn -EINVAL ;\r\n}\r\nsq->locked = 1 ;\r\ndmasound.mach.init();\r\nif (sq->user_frags <= 0) {\r\nsq->max_count = sq->numBufs ;\r\nsq->max_active = sq->numBufs ;\r\nsq->block_size = sq->bufSize;\r\nsq->user_frags = sq->numBufs ;\r\nsq->user_frag_size = sq->bufSize ;\r\nsq->user_frag_size *=\r\n(dmasound.soft.size * (dmasound.soft.stereo+1) ) ;\r\nsq->user_frag_size /=\r\n(dmasound.hard.size * (dmasound.hard.stereo+1) ) ;\r\n} else {\r\nsq->block_size = sq->user_frag_size ;\r\nsq->block_size *=\r\n(dmasound.hard.size * (dmasound.hard.stereo+1) ) ;\r\nsq->block_size /=\r\n(dmasound.soft.size * (dmasound.soft.stereo+1) ) ;\r\nsq->block_size *= dmasound.hard.speed ;\r\nsq->block_size /= dmasound.soft.speed ;\r\nhard_frame =\r\n(dmasound.hard.size * (dmasound.hard.stereo+1))/8 ;\r\nsq->block_size += (hard_frame - 1) ;\r\nsq->block_size &= ~(hard_frame - 1) ;\r\nif ( sq->block_size <= 0 || sq->block_size > sq->bufSize) {\r\n#ifdef DEBUG_DMASOUND\r\nprintk("dmasound_core: invalid frag size (user set %d)\n", sq->user_frag_size) ;\r\n#endif\r\nsq->block_size = sq->bufSize ;\r\n}\r\nif ( sq->user_frags <= sq->numBufs ) {\r\nsq->max_count = sq->user_frags ;\r\nsq->max_active = (sq->max_active <= sq->max_count) ?\r\nsq->max_active : sq->max_count ;\r\n} else {\r\n#ifdef DEBUG_DMASOUND\r\nprintk("dmasound_core: invalid frag count (user set %d)\n", sq->user_frags) ;\r\n#endif\r\nsq->max_count =\r\nsq->max_active = sq->numBufs ;\r\n}\r\n}\r\nsq->front = sq->count = sq->rear_size = 0;\r\nsq->syncing = 0;\r\nsq->active = 0;\r\nif (sq == &write_sq) {\r\nsq->rear = -1;\r\nsetup_func = dmasound.mach.write_sq_setup;\r\n}\r\nif (setup_func)\r\nreturn setup_func();\r\nreturn 0 ;\r\n}\r\nstatic inline void sq_play(void)\r\n{\r\ndmasound.mach.play();\r\n}\r\nstatic ssize_t sq_write(struct file *file, const char __user *src, size_t uLeft,\r\nloff_t *ppos)\r\n{\r\nssize_t uWritten = 0;\r\nu_char *dest;\r\nssize_t uUsed = 0, bUsed, bLeft;\r\nunsigned long flags ;\r\nif (uLeft == 0)\r\nreturn 0;\r\nif (shared_resources_initialised == 0) {\r\ndmasound.mach.init() ;\r\nshared_resources_initialised = 1 ;\r\n}\r\nif (write_sq.locked == 0) {\r\nif ((uWritten = sq_setup(&write_sq)) < 0) return uWritten ;\r\nuWritten = 0 ;\r\n}\r\nspin_lock_irqsave(&dmasound.lock, flags);\r\nwrite_sq.syncing &= ~2 ;\r\nspin_unlock_irqrestore(&dmasound.lock, flags);\r\nif (write_sq.count > 0 &&\r\n(bLeft = write_sq.block_size-write_sq.rear_size) > 0) {\r\ndest = write_sq.buffers[write_sq.rear];\r\nbUsed = write_sq.rear_size;\r\nuUsed = sound_copy_translate(dmasound.trans_write, src, uLeft,\r\ndest, &bUsed, bLeft);\r\nif (uUsed <= 0)\r\nreturn uUsed;\r\nsrc += uUsed;\r\nuWritten += uUsed;\r\nuLeft = (uUsed <= uLeft) ? (uLeft - uUsed) : 0 ;\r\nwrite_sq.rear_size = bUsed;\r\n}\r\nwhile (uLeft) {\r\nwhile (write_sq.count >= write_sq.max_active) {\r\nsq_play();\r\nif (write_sq.non_blocking)\r\nreturn uWritten > 0 ? uWritten : -EAGAIN;\r\nSLEEP(write_sq.action_queue);\r\nif (signal_pending(current))\r\nreturn uWritten > 0 ? uWritten : -EINTR;\r\n}\r\ndest = write_sq.buffers[(write_sq.rear+1) % write_sq.max_count];\r\nbUsed = 0;\r\nbLeft = write_sq.block_size;\r\nuUsed = sound_copy_translate(dmasound.trans_write, src, uLeft,\r\ndest, &bUsed, bLeft);\r\nif (uUsed <= 0)\r\nbreak;\r\nsrc += uUsed;\r\nuWritten += uUsed;\r\nuLeft = (uUsed <= uLeft) ? (uLeft - uUsed) : 0 ;\r\nif (bUsed) {\r\nwrite_sq.rear = (write_sq.rear+1) % write_sq.max_count;\r\nwrite_sq.rear_size = bUsed;\r\nwrite_sq.count++;\r\n}\r\n}\r\nsq_play();\r\nreturn uUsed < 0? uUsed: uWritten;\r\n}\r\nstatic unsigned int sq_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nunsigned int mask = 0;\r\nint retVal;\r\nif (write_sq.locked == 0) {\r\nif ((retVal = sq_setup(&write_sq)) < 0)\r\nreturn retVal;\r\nreturn 0;\r\n}\r\nif (file->f_mode & FMODE_WRITE )\r\npoll_wait(file, &write_sq.action_queue, wait);\r\nif (file->f_mode & FMODE_WRITE)\r\nif (write_sq.count < write_sq.max_active || write_sq.block_size - write_sq.rear_size > 0)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic inline void sq_init_waitqueue(struct sound_queue *sq)\r\n{\r\ninit_waitqueue_head(&sq->action_queue);\r\ninit_waitqueue_head(&sq->open_queue);\r\ninit_waitqueue_head(&sq->sync_queue);\r\nsq->busy = 0;\r\n}\r\nstatic int sq_open2(struct sound_queue *sq, struct file *file, fmode_t mode,\r\nint numbufs, int bufsize)\r\n{\r\nint rc = 0;\r\nif (file->f_mode & mode) {\r\nif (sq->busy) {\r\n#if 0\r\nrc = -EBUSY;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn rc;\r\nrc = -EINTR;\r\nwhile (sq->busy) {\r\nSLEEP(sq->open_queue);\r\nif (signal_pending(current))\r\nreturn rc;\r\n}\r\nrc = 0;\r\n#else\r\nreturn -EBUSY ;\r\n#endif\r\n}\r\nsq->busy = 1;\r\nif (( rc = sq_allocate_buffers(sq, numbufs, bufsize))) {\r\n#if 0\r\nsq_wake_up(sq, file, mode);\r\n#else\r\nsq->busy = 0 ;\r\n#endif\r\nreturn rc;\r\n}\r\nsq->non_blocking = file->f_flags & O_NONBLOCK;\r\n}\r\nreturn rc;\r\n}\r\nstatic int sq_open(struct inode *inode, struct file *file)\r\n{\r\nint rc;\r\nmutex_lock(&dmasound_core_mutex);\r\nif (!try_module_get(dmasound.mach.owner)) {\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn -ENODEV;\r\n}\r\nrc = write_sq_open(file);\r\nif (rc)\r\ngoto out;\r\nif (file->f_mode & FMODE_READ) {\r\nrc = -ENXIO ;\r\ngoto out;\r\n}\r\nif (dmasound.mach.sq_open)\r\ndmasound.mach.sq_open(file->f_mode);\r\ndmasound.minDev = iminor(inode) & 0x0f;\r\nif (shared_resource_owner == 0) {\r\ndmasound.soft = dmasound.mach.default_soft ;\r\ndmasound.dsp = dmasound.mach.default_soft ;\r\ndmasound.hard = dmasound.mach.default_hard ;\r\n}\r\n#ifndef DMASOUND_STRICT_OSS_COMPLIANCE\r\nif (dmasound.minDev == SND_DEV_AUDIO) {\r\nsound_set_speed(8000);\r\nsound_set_stereo(0);\r\nsound_set_format(AFMT_MU_LAW);\r\n}\r\n#endif\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn 0;\r\nout:\r\nmodule_put(dmasound.mach.owner);\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn rc;\r\n}\r\nstatic void sq_reset_output(void)\r\n{\r\nsound_silence();\r\nwrite_sq.active = 0;\r\nwrite_sq.count = 0;\r\nwrite_sq.rear_size = 0;\r\nwrite_sq.front = 0 ;\r\nwrite_sq.rear = -1 ;\r\nwrite_sq.locked = 0 ;\r\nwrite_sq.user_frags = 0 ;\r\nwrite_sq.user_frag_size = 0 ;\r\n}\r\nstatic void sq_reset(void)\r\n{\r\nsq_reset_output() ;\r\nshared_resources_initialised = 0 ;\r\n}\r\nstatic int sq_fsync(void)\r\n{\r\nint rc = 0;\r\nint timeout = 5;\r\nwrite_sq.syncing |= 1;\r\nsq_play();\r\nwhile (write_sq.active) {\r\nSLEEP(write_sq.sync_queue);\r\nif (signal_pending(current)) {\r\nsq_reset_output();\r\nrc = -EINTR;\r\nbreak;\r\n}\r\nif (!--timeout) {\r\nprintk(KERN_WARNING "dmasound: Timeout draining output\n");\r\nsq_reset_output();\r\nrc = -EIO;\r\nbreak;\r\n}\r\n}\r\nwrite_sq.syncing = 0 ;\r\nreturn rc;\r\n}\r\nstatic int sq_release(struct inode *inode, struct file *file)\r\n{\r\nint rc = 0;\r\nmutex_lock(&dmasound_core_mutex);\r\nif (file->f_mode & FMODE_WRITE) {\r\nif (write_sq.busy)\r\nrc = sq_fsync();\r\nsq_reset_output() ;\r\nwrite_sq_release_buffers();\r\nwrite_sq.busy = 0;\r\n}\r\nif (file->f_mode & shared_resource_owner) {\r\nshared_resource_owner = 0 ;\r\nshared_resources_initialised = 0 ;\r\ndmasound.hard = dmasound.mach.default_hard ;\r\n}\r\nmodule_put(dmasound.mach.owner);\r\n#if 0\r\nread_sq_wake_up(file);\r\nwrite_sq_wake_up(file);\r\n#endif\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn rc;\r\n}\r\nstatic int shared_resources_are_mine(fmode_t md)\r\n{\r\nif (shared_resource_owner)\r\nreturn (shared_resource_owner & md) != 0;\r\nelse {\r\nshared_resource_owner = md ;\r\nreturn 1 ;\r\n}\r\n}\r\nstatic int queues_are_quiescent(void)\r\n{\r\nif (write_sq.locked)\r\nreturn 0 ;\r\nreturn 1 ;\r\n}\r\nstatic int set_queue_frags(struct sound_queue *sq, int bufs, int size)\r\n{\r\nif (sq->locked) {\r\n#ifdef DEBUG_DMASOUND\r\nprintk("dmasound_core: tried to set_queue_frags on a locked queue\n") ;\r\n#endif\r\nreturn -EINVAL ;\r\n}\r\nif ((size < MIN_FRAG_SIZE) || (size > MAX_FRAG_SIZE))\r\nreturn -EINVAL ;\r\nsize = (1<<size) ;\r\nif (size > sq->bufSize)\r\nreturn -EINVAL ;\r\nif (bufs <= 0)\r\nreturn -EINVAL ;\r\nif (bufs > sq->numBufs)\r\nbufs = sq->numBufs ;\r\nsq->user_frags =\r\nsq->max_active = bufs ;\r\nsq->user_frag_size = size ;\r\nreturn 0 ;\r\n}\r\nstatic int sq_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nint val, result;\r\nu_long fmt;\r\nint data;\r\nint size, nbufs;\r\naudio_buf_info info;\r\nswitch (cmd) {\r\ncase SNDCTL_DSP_RESET:\r\nsq_reset();\r\nreturn 0;\r\nbreak ;\r\ncase SNDCTL_DSP_GETFMTS:\r\nfmt = dmasound.mach.hardware_afmts ;\r\nreturn IOCTL_OUT(arg, fmt);\r\nbreak ;\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\nsize = 0 ;\r\nif (file->f_mode & FMODE_WRITE) {\r\nif ( !write_sq.locked )\r\nsq_setup(&write_sq) ;\r\nsize = write_sq.user_frag_size ;\r\n}\r\nreturn IOCTL_OUT(arg, size);\r\nbreak ;\r\ncase SNDCTL_DSP_POST:\r\nwrite_sq.syncing |= 0x2 ;\r\nsq_play() ;\r\nreturn 0 ;\r\ncase SNDCTL_DSP_SYNC:\r\nresult = 0 ;\r\nif (file->f_mode & FMODE_WRITE) {\r\nresult = sq_fsync();\r\nsq_reset_output() ;\r\n}\r\nif (file->f_mode & shared_resource_owner)\r\nshared_resources_initialised = 0 ;\r\nreturn result ;\r\nbreak ;\r\ncase SOUND_PCM_READ_RATE:\r\nreturn IOCTL_OUT(arg, dmasound.soft.speed);\r\ncase SNDCTL_DSP_SPEED:\r\nif (shared_resources_are_mine(file->f_mode)) {\r\nIOCTL_IN(arg, data);\r\ndata = sound_set_speed(data) ;\r\nshared_resources_initialised = 0 ;\r\nreturn IOCTL_OUT(arg, data);\r\n} else\r\nreturn -EINVAL ;\r\nbreak ;\r\ncase SNDCTL_DSP_STEREO:\r\nif (shared_resources_are_mine(file->f_mode) &&\r\nqueues_are_quiescent()) {\r\nIOCTL_IN(arg, data);\r\nshared_resources_initialised = 0 ;\r\nreturn IOCTL_OUT(arg, sound_set_stereo(data));\r\n} else\r\nreturn -EINVAL ;\r\nbreak ;\r\ncase SOUND_PCM_WRITE_CHANNELS:\r\nif (shared_resources_are_mine(file->f_mode) &&\r\nqueues_are_quiescent()) {\r\nIOCTL_IN(arg, data);\r\nshared_resources_initialised = 0 ;\r\nreturn IOCTL_OUT(arg, sound_set_stereo(data-1)+1);\r\n} else\r\nreturn -EINVAL ;\r\nbreak ;\r\ncase SNDCTL_DSP_SETFMT:\r\nif (shared_resources_are_mine(file->f_mode) &&\r\nqueues_are_quiescent()) {\r\nint format;\r\nIOCTL_IN(arg, data);\r\nshared_resources_initialised = 0 ;\r\nformat = sound_set_format(data);\r\nresult = IOCTL_OUT(arg, format);\r\nif (result < 0)\r\nreturn result;\r\nif (format != data && data != AFMT_QUERY)\r\nreturn -EINVAL;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL ;\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\nreturn -EINVAL ;\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nIOCTL_IN(arg, data);\r\nresult = 0 ;\r\nnbufs = (data >> 16) & 0x7fff ;\r\nsize = data & 0xffff;\r\nif (file->f_mode & FMODE_WRITE) {\r\nresult = set_queue_frags(&write_sq, nbufs, size) ;\r\nif (result)\r\nreturn result ;\r\n}\r\nreturn IOCTL_OUT(arg, data);\r\nbreak ;\r\ncase SNDCTL_DSP_GETOSPACE:\r\nif (file->f_mode & FMODE_WRITE) {\r\nif ( !write_sq.locked )\r\nsq_setup(&write_sq) ;\r\ninfo.fragments = write_sq.max_active - write_sq.count;\r\ninfo.fragstotal = write_sq.max_active;\r\ninfo.fragsize = write_sq.user_frag_size;\r\ninfo.bytes = info.fragments * info.fragsize;\r\nif (copy_to_user((void __user *)arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL ;\r\nbreak ;\r\ncase SNDCTL_DSP_GETCAPS:\r\nval = dmasound.mach.capabilities & 0xffffff00;\r\nreturn IOCTL_OUT(arg,val);\r\ndefault:\r\nreturn mixer_ioctl(file, cmd, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long sq_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nint ret;\r\nmutex_lock(&dmasound_core_mutex);\r\nret = sq_ioctl(file, cmd, arg);\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn ret;\r\n}\r\nstatic int sq_init(void)\r\n{\r\nconst struct file_operations *fops = &sq_fops;\r\n#ifndef MODULE\r\nint sq_unit;\r\n#endif\r\nsq_unit = register_sound_dsp(fops, -1);\r\nif (sq_unit < 0) {\r\nprintk(KERN_ERR "dmasound_core: couldn't register fops\n") ;\r\nreturn sq_unit ;\r\n}\r\nwrite_sq_init_waitqueue();\r\nif (shared_resource_owner == 0) {\r\ndmasound.soft = dmasound.mach.default_soft ;\r\ndmasound.hard = dmasound.mach.default_hard ;\r\ndmasound.dsp = dmasound.mach.default_soft ;\r\nshared_resources_initialised = 0 ;\r\n}\r\nreturn 0 ;\r\n}\r\nstatic char *get_afmt_string(int afmt)\r\n{\r\nswitch(afmt) {\r\ncase AFMT_MU_LAW:\r\nreturn "mu-law";\r\nbreak;\r\ncase AFMT_A_LAW:\r\nreturn "A-law";\r\nbreak;\r\ncase AFMT_U8:\r\nreturn "unsigned 8 bit";\r\nbreak;\r\ncase AFMT_S8:\r\nreturn "signed 8 bit";\r\nbreak;\r\ncase AFMT_S16_BE:\r\nreturn "signed 16 bit BE";\r\nbreak;\r\ncase AFMT_U16_BE:\r\nreturn "unsigned 16 bit BE";\r\nbreak;\r\ncase AFMT_S16_LE:\r\nreturn "signed 16 bit LE";\r\nbreak;\r\ncase AFMT_U16_LE:\r\nreturn "unsigned 16 bit LE";\r\nbreak;\r\ncase 0:\r\nreturn "format not set" ;\r\nbreak ;\r\ndefault:\r\nbreak ;\r\n}\r\nreturn "ERROR: Unsupported AFMT_XXXX code" ;\r\n}\r\nstatic int state_open(struct inode *inode, struct file *file)\r\n{\r\nchar *buffer = state.buf;\r\nint len = 0;\r\nint ret;\r\nmutex_lock(&dmasound_core_mutex);\r\nret = -EBUSY;\r\nif (state.busy)\r\ngoto out;\r\nret = -ENODEV;\r\nif (!try_module_get(dmasound.mach.owner))\r\ngoto out;\r\nstate.ptr = 0;\r\nstate.busy = 1;\r\nlen += sprintf(buffer+len, "%sDMA sound driver rev %03d :\n",\r\ndmasound.mach.name, (DMASOUND_CORE_REVISION<<4) +\r\n((dmasound.mach.version>>8) & 0x0f));\r\nlen += sprintf(buffer+len,\r\n"Core driver edition %02d.%02d : %s driver edition %02d.%02d\n",\r\nDMASOUND_CORE_REVISION, DMASOUND_CORE_EDITION, dmasound.mach.name2,\r\n(dmasound.mach.version >> 8), (dmasound.mach.version & 0xff)) ;\r\nif (dmasound.mach.state_info)\r\nlen += dmasound.mach.state_info(buffer+len,\r\n(size_t) LOW_LEVEL_STAT_ALLOC) ;\r\nlen += sprintf(buffer+len,"\t\t === Formats & settings ===\n") ;\r\nlen += sprintf(buffer+len,"Parameter %20s%20s\n","soft","hard") ;\r\nlen += sprintf(buffer+len,"Format :%20s%20s\n",\r\nget_afmt_string(dmasound.soft.format),\r\nget_afmt_string(dmasound.hard.format));\r\nlen += sprintf(buffer+len,"Samp Rate:%14d s/sec%14d s/sec\n",\r\ndmasound.soft.speed, dmasound.hard.speed);\r\nlen += sprintf(buffer+len,"Channels :%20s%20s\n",\r\ndmasound.soft.stereo ? "stereo" : "mono",\r\ndmasound.hard.stereo ? "stereo" : "mono" );\r\nlen += sprintf(buffer+len,"\t\t === Sound Queue status ===\n");\r\nlen += sprintf(buffer+len,"Allocated:%8s%6s\n","Buffers","Size") ;\r\nlen += sprintf(buffer+len,"%9s:%8d%6d\n",\r\n"write", write_sq.numBufs, write_sq.bufSize) ;\r\nlen += sprintf(buffer+len,\r\n"Current : MaxFrg FragSiz MaxAct Frnt Rear "\r\n"Cnt RrSize A B S L xruns\n") ;\r\nlen += sprintf(buffer+len,"%9s:%7d%8d%7d%5d%5d%4d%7d%2d%2d%2d%2d%7d\n",\r\n"write", write_sq.max_count, write_sq.block_size,\r\nwrite_sq.max_active, write_sq.front, write_sq.rear,\r\nwrite_sq.count, write_sq.rear_size, write_sq.active,\r\nwrite_sq.busy, write_sq.syncing, write_sq.locked, write_sq.xruns) ;\r\n#ifdef DEBUG_DMASOUND\r\nprintk("dmasound: stat buffer used %d bytes\n", len) ;\r\n#endif\r\nif (len >= STAT_BUFF_LEN)\r\nprintk(KERN_ERR "dmasound_core: stat buffer overflowed!\n");\r\nstate.len = len;\r\nret = 0;\r\nout:\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn ret;\r\n}\r\nstatic int state_release(struct inode *inode, struct file *file)\r\n{\r\nmutex_lock(&dmasound_core_mutex);\r\nstate.busy = 0;\r\nmodule_put(dmasound.mach.owner);\r\nmutex_unlock(&dmasound_core_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t state_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint n = state.len - state.ptr;\r\nif (n > count)\r\nn = count;\r\nif (n <= 0)\r\nreturn 0;\r\nif (copy_to_user(buf, &state.buf[state.ptr], n))\r\nreturn -EFAULT;\r\nstate.ptr += n;\r\nreturn n;\r\n}\r\nstatic int state_init(void)\r\n{\r\n#ifndef MODULE\r\nint state_unit;\r\n#endif\r\nstate_unit = register_sound_special(&state_fops, SND_DEV_STATUS);\r\nif (state_unit < 0)\r\nreturn state_unit ;\r\nstate.busy = 0;\r\nreturn 0 ;\r\n}\r\nint dmasound_init(void)\r\n{\r\nint res ;\r\n#ifdef MODULE\r\nif (irq_installed)\r\nreturn -EBUSY;\r\n#endif\r\nif ((res = sq_init()) < 0)\r\nreturn res ;\r\nif ((res = state_init()) < 0)\r\nreturn res ;\r\nmixer_init();\r\nif (!dmasound.mach.irqinit()) {\r\nprintk(KERN_ERR "DMA sound driver: Interrupt initialization failed\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef MODULE\r\nirq_installed = 1;\r\n#endif\r\nprintk(KERN_INFO "%s DMA sound driver rev %03d installed\n",\r\ndmasound.mach.name, (DMASOUND_CORE_REVISION<<4) +\r\n((dmasound.mach.version>>8) & 0x0f));\r\nprintk(KERN_INFO\r\n"Core driver edition %02d.%02d : %s driver edition %02d.%02d\n",\r\nDMASOUND_CORE_REVISION, DMASOUND_CORE_EDITION, dmasound.mach.name2,\r\n(dmasound.mach.version >> 8), (dmasound.mach.version & 0xff)) ;\r\nprintk(KERN_INFO "Write will use %4d fragments of %7d bytes as default\n",\r\nnumWriteBufs, writeBufSize) ;\r\nreturn 0;\r\n}\r\nvoid dmasound_deinit(void)\r\n{\r\nif (irq_installed) {\r\nsound_silence();\r\ndmasound.mach.irqcleanup();\r\nirq_installed = 0;\r\n}\r\nwrite_sq_release_buffers();\r\nif (mixer_unit >= 0)\r\nunregister_sound_mixer(mixer_unit);\r\nif (state_unit >= 0)\r\nunregister_sound_special(state_unit);\r\nif (sq_unit >= 0)\r\nunregister_sound_dsp(sq_unit);\r\n}\r\nstatic int dmasound_setup(char *str)\r\n{\r\nint ints[6], size;\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nswitch (ints[0]) {\r\ncase 3:\r\nif ((ints[3] < 0) || (ints[3] > MAX_CATCH_RADIUS))\r\nprintk("dmasound_setup: invalid catch radius, using default = %d\n", catchRadius);\r\nelse\r\ncatchRadius = ints[3];\r\ncase 2:\r\nif (ints[1] < MIN_BUFFERS)\r\nprintk("dmasound_setup: invalid number of buffers, using default = %d\n", numWriteBufs);\r\nelse\r\nnumWriteBufs = ints[1];\r\ncase 1:\r\nif ((size = ints[2]) < 256)\r\nsize <<= 10 ;\r\nif (size < MIN_BUFSIZE || size > MAX_BUFSIZE)\r\nprintk("dmasound_setup: invalid write buffer size, using default = %d\n", writeBufSize);\r\nelse\r\nwriteBufSize = size;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nprintk("dmasound_setup: invalid number of arguments\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}
