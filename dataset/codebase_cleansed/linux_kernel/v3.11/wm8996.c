static void wm8996_set_retune_mobile(struct snd_soc_codec *codec, int block)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8996_pdata *pdata = &wm8996->pdata;\r\nint base, best, best_val, save, i, cfg, iface;\r\nif (!wm8996->num_retune_mobile_texts)\r\nreturn;\r\nswitch (block) {\r\ncase 0:\r\nbase = WM8996_DSP1_RX_EQ_GAINS_1;\r\nif (snd_soc_read(codec, WM8996_POWER_MANAGEMENT_8) &\r\nWM8996_DSP1RX_SRC)\r\niface = 1;\r\nelse\r\niface = 0;\r\nbreak;\r\ncase 1:\r\nbase = WM8996_DSP1_RX_EQ_GAINS_2;\r\nif (snd_soc_read(codec, WM8996_POWER_MANAGEMENT_8) &\r\nWM8996_DSP2RX_SRC)\r\niface = 1;\r\nelse\r\niface = 0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ncfg = wm8996->retune_mobile_cfg[block];\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\r\nif (strcmp(pdata->retune_mobile_cfgs[i].name,\r\nwm8996->retune_mobile_texts[cfg]) == 0 &&\r\nabs(pdata->retune_mobile_cfgs[i].rate\r\n- wm8996->rx_rate[iface]) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->retune_mobile_cfgs[i].rate\r\n- wm8996->rx_rate[iface]);\r\n}\r\n}\r\ndev_dbg(codec->dev, "ReTune Mobile %d %s/%dHz for %dHz sample rate\n",\r\nblock,\r\npdata->retune_mobile_cfgs[best].name,\r\npdata->retune_mobile_cfgs[best].rate,\r\nwm8996->rx_rate[iface]);\r\nsave = snd_soc_read(codec, base);\r\nsave &= WM8996_DSP1RX_EQ_ENA;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->retune_mobile_cfgs[best].regs); i++)\r\nsnd_soc_update_bits(codec, base + i, 0xffff,\r\npdata->retune_mobile_cfgs[best].regs[i]);\r\nsnd_soc_update_bits(codec, base, WM8996_DSP1RX_EQ_ENA, save);\r\n}\r\nstatic int wm8996_get_retune_mobile_block(const char *name)\r\n{\r\nif (strcmp(name, "DSP1 EQ Mode") == 0)\r\nreturn 0;\r\nif (strcmp(name, "DSP2 EQ Mode") == 0)\r\nreturn 1;\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8996_put_retune_mobile_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8996_pdata *pdata = &wm8996->pdata;\r\nint block = wm8996_get_retune_mobile_block(kcontrol->id.name);\r\nint value = ucontrol->value.integer.value[0];\r\nif (block < 0)\r\nreturn block;\r\nif (value >= pdata->num_retune_mobile_cfgs)\r\nreturn -EINVAL;\r\nwm8996->retune_mobile_cfg[block] = value;\r\nwm8996_set_retune_mobile(codec, block);\r\nreturn 0;\r\n}\r\nstatic int wm8996_get_retune_mobile_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint block = wm8996_get_retune_mobile_block(kcontrol->id.name);\r\nucontrol->value.enumerated.item[0] = wm8996->retune_mobile_cfg[block];\r\nreturn 0;\r\n}\r\nstatic void wm8996_bg_enable(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nwm8996->bg_ena++;\r\nif (wm8996->bg_ena == 1) {\r\nsnd_soc_update_bits(codec, WM8996_POWER_MANAGEMENT_1,\r\nWM8996_BG_ENA, WM8996_BG_ENA);\r\nmsleep(2);\r\n}\r\n}\r\nstatic void wm8996_bg_disable(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nwm8996->bg_ena--;\r\nif (!wm8996->bg_ena)\r\nsnd_soc_update_bits(codec, WM8996_POWER_MANAGEMENT_1,\r\nWM8996_BG_ENA, 0);\r\n}\r\nstatic int bg_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nint ret = 0;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nwm8996_bg_enable(codec);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nwm8996_bg_disable(codec);\r\nbreak;\r\ndefault:\r\nBUG();\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nint ret = 0;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nmsleep(5);\r\nbreak;\r\ndefault:\r\nBUG();\r\nret = -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmv_short_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(w->codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nwm8996->hpout_pending &= ~w->shift;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nwm8996->hpout_pending |= w->shift;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wait_for_dc_servo(struct snd_soc_codec *codec, u16 mask)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nunsigned long timeout = 200;\r\nsnd_soc_write(codec, WM8996_DC_SERVO_2, mask);\r\ndo {\r\nif (i2c->irq) {\r\ntimeout = wait_for_completion_timeout(&wm8996->dcs_done,\r\nmsecs_to_jiffies(200));\r\nif (timeout == 0)\r\ndev_err(codec->dev, "DC servo timed out\n");\r\n} else {\r\nmsleep(1);\r\ntimeout--;\r\n}\r\nret = snd_soc_read(codec, WM8996_DC_SERVO_2);\r\ndev_dbg(codec->dev, "DC servo state: %x\n", ret);\r\n} while (timeout && ret & mask);\r\nif (timeout == 0)\r\ndev_err(codec->dev, "DC servo timed out for %x\n", mask);\r\nelse\r\ndev_dbg(codec->dev, "DC servo complete for %x\n", mask);\r\n}\r\nstatic void wm8996_seq_notifier(struct snd_soc_dapm_context *dapm,\r\nenum snd_soc_dapm_type event, int subseq)\r\n{\r\nstruct snd_soc_codec *codec = container_of(dapm,\r\nstruct snd_soc_codec, dapm);\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nu16 val, mask;\r\nif (wm8996->dcs_pending) {\r\ndev_dbg(codec->dev, "Starting DC servo for %x\n",\r\nwm8996->dcs_pending);\r\nwait_for_dc_servo(codec, wm8996->dcs_pending\r\n<< WM8996_DCS_TRIG_STARTUP_0_SHIFT);\r\nwm8996->dcs_pending = 0;\r\n}\r\nif (wm8996->hpout_pending != wm8996->hpout_ena) {\r\ndev_dbg(codec->dev, "Applying RMV_SHORTs %x->%x\n",\r\nwm8996->hpout_ena, wm8996->hpout_pending);\r\nval = 0;\r\nmask = 0;\r\nif (wm8996->hpout_pending & HPOUT1L) {\r\nval |= WM8996_HPOUT1L_RMV_SHORT | WM8996_HPOUT1L_OUTP;\r\nmask |= WM8996_HPOUT1L_RMV_SHORT | WM8996_HPOUT1L_OUTP;\r\n} else {\r\nmask |= WM8996_HPOUT1L_RMV_SHORT |\r\nWM8996_HPOUT1L_OUTP |\r\nWM8996_HPOUT1L_DLY;\r\n}\r\nif (wm8996->hpout_pending & HPOUT1R) {\r\nval |= WM8996_HPOUT1R_RMV_SHORT | WM8996_HPOUT1R_OUTP;\r\nmask |= WM8996_HPOUT1R_RMV_SHORT | WM8996_HPOUT1R_OUTP;\r\n} else {\r\nmask |= WM8996_HPOUT1R_RMV_SHORT |\r\nWM8996_HPOUT1R_OUTP |\r\nWM8996_HPOUT1R_DLY;\r\n}\r\nsnd_soc_update_bits(codec, WM8996_ANALOGUE_HP_1, mask, val);\r\nval = 0;\r\nmask = 0;\r\nif (wm8996->hpout_pending & HPOUT2L) {\r\nval |= WM8996_HPOUT2L_RMV_SHORT | WM8996_HPOUT2L_OUTP;\r\nmask |= WM8996_HPOUT2L_RMV_SHORT | WM8996_HPOUT2L_OUTP;\r\n} else {\r\nmask |= WM8996_HPOUT2L_RMV_SHORT |\r\nWM8996_HPOUT2L_OUTP |\r\nWM8996_HPOUT2L_DLY;\r\n}\r\nif (wm8996->hpout_pending & HPOUT2R) {\r\nval |= WM8996_HPOUT2R_RMV_SHORT | WM8996_HPOUT2R_OUTP;\r\nmask |= WM8996_HPOUT2R_RMV_SHORT | WM8996_HPOUT2R_OUTP;\r\n} else {\r\nmask |= WM8996_HPOUT2R_RMV_SHORT |\r\nWM8996_HPOUT2R_OUTP |\r\nWM8996_HPOUT2R_DLY;\r\n}\r\nsnd_soc_update_bits(codec, WM8996_ANALOGUE_HP_2, mask, val);\r\nwm8996->hpout_ena = wm8996->hpout_pending;\r\n}\r\n}\r\nstatic int dcs_start(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(w->codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nwm8996->dcs_pending |= 1 << w->shift;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool wm8996_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8996_SOFTWARE_RESET:\r\ncase WM8996_POWER_MANAGEMENT_1:\r\ncase WM8996_POWER_MANAGEMENT_2:\r\ncase WM8996_POWER_MANAGEMENT_3:\r\ncase WM8996_POWER_MANAGEMENT_4:\r\ncase WM8996_POWER_MANAGEMENT_5:\r\ncase WM8996_POWER_MANAGEMENT_6:\r\ncase WM8996_POWER_MANAGEMENT_7:\r\ncase WM8996_POWER_MANAGEMENT_8:\r\ncase WM8996_LEFT_LINE_INPUT_VOLUME:\r\ncase WM8996_RIGHT_LINE_INPUT_VOLUME:\r\ncase WM8996_LINE_INPUT_CONTROL:\r\ncase WM8996_DAC1_HPOUT1_VOLUME:\r\ncase WM8996_DAC2_HPOUT2_VOLUME:\r\ncase WM8996_DAC1_LEFT_VOLUME:\r\ncase WM8996_DAC1_RIGHT_VOLUME:\r\ncase WM8996_DAC2_LEFT_VOLUME:\r\ncase WM8996_DAC2_RIGHT_VOLUME:\r\ncase WM8996_OUTPUT1_LEFT_VOLUME:\r\ncase WM8996_OUTPUT1_RIGHT_VOLUME:\r\ncase WM8996_OUTPUT2_LEFT_VOLUME:\r\ncase WM8996_OUTPUT2_RIGHT_VOLUME:\r\ncase WM8996_MICBIAS_1:\r\ncase WM8996_MICBIAS_2:\r\ncase WM8996_LDO_1:\r\ncase WM8996_LDO_2:\r\ncase WM8996_ACCESSORY_DETECT_MODE_1:\r\ncase WM8996_ACCESSORY_DETECT_MODE_2:\r\ncase WM8996_HEADPHONE_DETECT_1:\r\ncase WM8996_HEADPHONE_DETECT_2:\r\ncase WM8996_MIC_DETECT_1:\r\ncase WM8996_MIC_DETECT_2:\r\ncase WM8996_MIC_DETECT_3:\r\ncase WM8996_CHARGE_PUMP_1:\r\ncase WM8996_CHARGE_PUMP_2:\r\ncase WM8996_DC_SERVO_1:\r\ncase WM8996_DC_SERVO_2:\r\ncase WM8996_DC_SERVO_3:\r\ncase WM8996_DC_SERVO_5:\r\ncase WM8996_DC_SERVO_6:\r\ncase WM8996_DC_SERVO_7:\r\ncase WM8996_DC_SERVO_READBACK_0:\r\ncase WM8996_ANALOGUE_HP_1:\r\ncase WM8996_ANALOGUE_HP_2:\r\ncase WM8996_CHIP_REVISION:\r\ncase WM8996_CONTROL_INTERFACE_1:\r\ncase WM8996_WRITE_SEQUENCER_CTRL_1:\r\ncase WM8996_WRITE_SEQUENCER_CTRL_2:\r\ncase WM8996_AIF_CLOCKING_1:\r\ncase WM8996_AIF_CLOCKING_2:\r\ncase WM8996_CLOCKING_1:\r\ncase WM8996_CLOCKING_2:\r\ncase WM8996_AIF_RATE:\r\ncase WM8996_FLL_CONTROL_1:\r\ncase WM8996_FLL_CONTROL_2:\r\ncase WM8996_FLL_CONTROL_3:\r\ncase WM8996_FLL_CONTROL_4:\r\ncase WM8996_FLL_CONTROL_5:\r\ncase WM8996_FLL_CONTROL_6:\r\ncase WM8996_FLL_EFS_1:\r\ncase WM8996_FLL_EFS_2:\r\ncase WM8996_AIF1_CONTROL:\r\ncase WM8996_AIF1_BCLK:\r\ncase WM8996_AIF1_TX_LRCLK_1:\r\ncase WM8996_AIF1_TX_LRCLK_2:\r\ncase WM8996_AIF1_RX_LRCLK_1:\r\ncase WM8996_AIF1_RX_LRCLK_2:\r\ncase WM8996_AIF1TX_DATA_CONFIGURATION_1:\r\ncase WM8996_AIF1TX_DATA_CONFIGURATION_2:\r\ncase WM8996_AIF1RX_DATA_CONFIGURATION:\r\ncase WM8996_AIF1TX_CHANNEL_0_CONFIGURATION:\r\ncase WM8996_AIF1TX_CHANNEL_1_CONFIGURATION:\r\ncase WM8996_AIF1TX_CHANNEL_2_CONFIGURATION:\r\ncase WM8996_AIF1TX_CHANNEL_3_CONFIGURATION:\r\ncase WM8996_AIF1TX_CHANNEL_4_CONFIGURATION:\r\ncase WM8996_AIF1TX_CHANNEL_5_CONFIGURATION:\r\ncase WM8996_AIF1RX_CHANNEL_0_CONFIGURATION:\r\ncase WM8996_AIF1RX_CHANNEL_1_CONFIGURATION:\r\ncase WM8996_AIF1RX_CHANNEL_2_CONFIGURATION:\r\ncase WM8996_AIF1RX_CHANNEL_3_CONFIGURATION:\r\ncase WM8996_AIF1RX_CHANNEL_4_CONFIGURATION:\r\ncase WM8996_AIF1RX_CHANNEL_5_CONFIGURATION:\r\ncase WM8996_AIF1RX_MONO_CONFIGURATION:\r\ncase WM8996_AIF1TX_TEST:\r\ncase WM8996_AIF2_CONTROL:\r\ncase WM8996_AIF2_BCLK:\r\ncase WM8996_AIF2_TX_LRCLK_1:\r\ncase WM8996_AIF2_TX_LRCLK_2:\r\ncase WM8996_AIF2_RX_LRCLK_1:\r\ncase WM8996_AIF2_RX_LRCLK_2:\r\ncase WM8996_AIF2TX_DATA_CONFIGURATION_1:\r\ncase WM8996_AIF2TX_DATA_CONFIGURATION_2:\r\ncase WM8996_AIF2RX_DATA_CONFIGURATION:\r\ncase WM8996_AIF2TX_CHANNEL_0_CONFIGURATION:\r\ncase WM8996_AIF2TX_CHANNEL_1_CONFIGURATION:\r\ncase WM8996_AIF2RX_CHANNEL_0_CONFIGURATION:\r\ncase WM8996_AIF2RX_CHANNEL_1_CONFIGURATION:\r\ncase WM8996_AIF2RX_MONO_CONFIGURATION:\r\ncase WM8996_AIF2TX_TEST:\r\ncase WM8996_DSP1_TX_LEFT_VOLUME:\r\ncase WM8996_DSP1_TX_RIGHT_VOLUME:\r\ncase WM8996_DSP1_RX_LEFT_VOLUME:\r\ncase WM8996_DSP1_RX_RIGHT_VOLUME:\r\ncase WM8996_DSP1_TX_FILTERS:\r\ncase WM8996_DSP1_RX_FILTERS_1:\r\ncase WM8996_DSP1_RX_FILTERS_2:\r\ncase WM8996_DSP1_DRC_1:\r\ncase WM8996_DSP1_DRC_2:\r\ncase WM8996_DSP1_DRC_3:\r\ncase WM8996_DSP1_DRC_4:\r\ncase WM8996_DSP1_DRC_5:\r\ncase WM8996_DSP1_RX_EQ_GAINS_1:\r\ncase WM8996_DSP1_RX_EQ_GAINS_2:\r\ncase WM8996_DSP1_RX_EQ_BAND_1_A:\r\ncase WM8996_DSP1_RX_EQ_BAND_1_B:\r\ncase WM8996_DSP1_RX_EQ_BAND_1_PG:\r\ncase WM8996_DSP1_RX_EQ_BAND_2_A:\r\ncase WM8996_DSP1_RX_EQ_BAND_2_B:\r\ncase WM8996_DSP1_RX_EQ_BAND_2_C:\r\ncase WM8996_DSP1_RX_EQ_BAND_2_PG:\r\ncase WM8996_DSP1_RX_EQ_BAND_3_A:\r\ncase WM8996_DSP1_RX_EQ_BAND_3_B:\r\ncase WM8996_DSP1_RX_EQ_BAND_3_C:\r\ncase WM8996_DSP1_RX_EQ_BAND_3_PG:\r\ncase WM8996_DSP1_RX_EQ_BAND_4_A:\r\ncase WM8996_DSP1_RX_EQ_BAND_4_B:\r\ncase WM8996_DSP1_RX_EQ_BAND_4_C:\r\ncase WM8996_DSP1_RX_EQ_BAND_4_PG:\r\ncase WM8996_DSP1_RX_EQ_BAND_5_A:\r\ncase WM8996_DSP1_RX_EQ_BAND_5_B:\r\ncase WM8996_DSP1_RX_EQ_BAND_5_PG:\r\ncase WM8996_DSP2_TX_LEFT_VOLUME:\r\ncase WM8996_DSP2_TX_RIGHT_VOLUME:\r\ncase WM8996_DSP2_RX_LEFT_VOLUME:\r\ncase WM8996_DSP2_RX_RIGHT_VOLUME:\r\ncase WM8996_DSP2_TX_FILTERS:\r\ncase WM8996_DSP2_RX_FILTERS_1:\r\ncase WM8996_DSP2_RX_FILTERS_2:\r\ncase WM8996_DSP2_DRC_1:\r\ncase WM8996_DSP2_DRC_2:\r\ncase WM8996_DSP2_DRC_3:\r\ncase WM8996_DSP2_DRC_4:\r\ncase WM8996_DSP2_DRC_5:\r\ncase WM8996_DSP2_RX_EQ_GAINS_1:\r\ncase WM8996_DSP2_RX_EQ_GAINS_2:\r\ncase WM8996_DSP2_RX_EQ_BAND_1_A:\r\ncase WM8996_DSP2_RX_EQ_BAND_1_B:\r\ncase WM8996_DSP2_RX_EQ_BAND_1_PG:\r\ncase WM8996_DSP2_RX_EQ_BAND_2_A:\r\ncase WM8996_DSP2_RX_EQ_BAND_2_B:\r\ncase WM8996_DSP2_RX_EQ_BAND_2_C:\r\ncase WM8996_DSP2_RX_EQ_BAND_2_PG:\r\ncase WM8996_DSP2_RX_EQ_BAND_3_A:\r\ncase WM8996_DSP2_RX_EQ_BAND_3_B:\r\ncase WM8996_DSP2_RX_EQ_BAND_3_C:\r\ncase WM8996_DSP2_RX_EQ_BAND_3_PG:\r\ncase WM8996_DSP2_RX_EQ_BAND_4_A:\r\ncase WM8996_DSP2_RX_EQ_BAND_4_B:\r\ncase WM8996_DSP2_RX_EQ_BAND_4_C:\r\ncase WM8996_DSP2_RX_EQ_BAND_4_PG:\r\ncase WM8996_DSP2_RX_EQ_BAND_5_A:\r\ncase WM8996_DSP2_RX_EQ_BAND_5_B:\r\ncase WM8996_DSP2_RX_EQ_BAND_5_PG:\r\ncase WM8996_DAC1_MIXER_VOLUMES:\r\ncase WM8996_DAC1_LEFT_MIXER_ROUTING:\r\ncase WM8996_DAC1_RIGHT_MIXER_ROUTING:\r\ncase WM8996_DAC2_MIXER_VOLUMES:\r\ncase WM8996_DAC2_LEFT_MIXER_ROUTING:\r\ncase WM8996_DAC2_RIGHT_MIXER_ROUTING:\r\ncase WM8996_DSP1_TX_LEFT_MIXER_ROUTING:\r\ncase WM8996_DSP1_TX_RIGHT_MIXER_ROUTING:\r\ncase WM8996_DSP2_TX_LEFT_MIXER_ROUTING:\r\ncase WM8996_DSP2_TX_RIGHT_MIXER_ROUTING:\r\ncase WM8996_DSP_TX_MIXER_SELECT:\r\ncase WM8996_DAC_SOFTMUTE:\r\ncase WM8996_OVERSAMPLING:\r\ncase WM8996_SIDETONE:\r\ncase WM8996_GPIO_1:\r\ncase WM8996_GPIO_2:\r\ncase WM8996_GPIO_3:\r\ncase WM8996_GPIO_4:\r\ncase WM8996_GPIO_5:\r\ncase WM8996_PULL_CONTROL_1:\r\ncase WM8996_PULL_CONTROL_2:\r\ncase WM8996_INTERRUPT_STATUS_1:\r\ncase WM8996_INTERRUPT_STATUS_2:\r\ncase WM8996_INTERRUPT_RAW_STATUS_2:\r\ncase WM8996_INTERRUPT_STATUS_1_MASK:\r\ncase WM8996_INTERRUPT_STATUS_2_MASK:\r\ncase WM8996_INTERRUPT_CONTROL:\r\ncase WM8996_LEFT_PDM_SPEAKER:\r\ncase WM8996_RIGHT_PDM_SPEAKER:\r\ncase WM8996_PDM_SPEAKER_MUTE_SEQUENCE:\r\ncase WM8996_PDM_SPEAKER_VOLUME:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic bool wm8996_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8996_SOFTWARE_RESET:\r\ncase WM8996_CHIP_REVISION:\r\ncase WM8996_LDO_1:\r\ncase WM8996_LDO_2:\r\ncase WM8996_INTERRUPT_STATUS_1:\r\ncase WM8996_INTERRUPT_STATUS_2:\r\ncase WM8996_INTERRUPT_RAW_STATUS_2:\r\ncase WM8996_DC_SERVO_READBACK_0:\r\ncase WM8996_DC_SERVO_2:\r\ncase WM8996_DC_SERVO_6:\r\ncase WM8996_DC_SERVO_7:\r\ncase WM8996_FLL_CONTROL_6:\r\ncase WM8996_MIC_DETECT_3:\r\ncase WM8996_HEADPHONE_DETECT_1:\r\ncase WM8996_HEADPHONE_DETECT_2:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void wm8996_update_bclk(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint aif, best, cur_val, bclk_rate, bclk_reg, i;\r\nif (wm8996->sysclk < 64000)\r\nreturn;\r\nfor (aif = 0; aif < WM8996_AIFS; aif++) {\r\nswitch (aif) {\r\ncase 0:\r\nbclk_reg = WM8996_AIF1_BCLK;\r\nbreak;\r\ncase 1:\r\nbclk_reg = WM8996_AIF2_BCLK;\r\nbreak;\r\n}\r\nbclk_rate = wm8996->bclk_rate[aif];\r\nbest = 0;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\ncur_val = (wm8996->sysclk / bclk_divs[i]) - bclk_rate;\r\nif (cur_val < 0)\r\nbreak;\r\nbest = i;\r\n}\r\nbclk_rate = wm8996->sysclk / bclk_divs[best];\r\ndev_dbg(codec->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",\r\nbclk_divs[best], bclk_rate);\r\nsnd_soc_update_bits(codec, bclk_reg,\r\nWM8996_AIF1_BCLK_DIV_MASK, best);\r\n}\r\n}\r\nstatic int wm8996_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8996_MICBIAS_1,\r\nWM8996_MICB1_MODE, 0);\r\nsnd_soc_update_bits(codec, WM8996_MICBIAS_2,\r\nWM8996_MICB2_MODE, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8996->supplies),\r\nwm8996->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (wm8996->pdata.ldo_ena >= 0) {\r\ngpio_set_value_cansleep(wm8996->pdata.ldo_ena,\r\n1);\r\nmsleep(5);\r\n}\r\nregcache_cache_only(codec->control_data, false);\r\nregcache_sync(codec->control_data);\r\n}\r\nsnd_soc_update_bits(codec, WM8996_MICBIAS_1,\r\nWM8996_MICB1_MODE, WM8996_MICB1_MODE);\r\nsnd_soc_update_bits(codec, WM8996_MICBIAS_2,\r\nWM8996_MICB2_MODE, WM8996_MICB2_MODE);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregcache_cache_only(codec->control_data, true);\r\nif (wm8996->pdata.ldo_ena >= 0) {\r\ngpio_set_value_cansleep(wm8996->pdata.ldo_ena, 0);\r\nregcache_cache_only(codec->control_data, true);\r\n}\r\nregulator_bulk_disable(ARRAY_SIZE(wm8996->supplies),\r\nwm8996->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8996_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint aifctrl = 0;\r\nint bclk = 0;\r\nint lrclk_tx = 0;\r\nint lrclk_rx = 0;\r\nint aifctrl_reg, bclk_reg, lrclk_tx_reg, lrclk_rx_reg;\r\nswitch (dai->id) {\r\ncase 0:\r\naifctrl_reg = WM8996_AIF1_CONTROL;\r\nbclk_reg = WM8996_AIF1_BCLK;\r\nlrclk_tx_reg = WM8996_AIF1_TX_LRCLK_2;\r\nlrclk_rx_reg = WM8996_AIF1_RX_LRCLK_2;\r\nbreak;\r\ncase 1:\r\naifctrl_reg = WM8996_AIF2_CONTROL;\r\nbclk_reg = WM8996_AIF2_BCLK;\r\nlrclk_tx_reg = WM8996_AIF2_TX_LRCLK_2;\r\nlrclk_rx_reg = WM8996_AIF2_RX_LRCLK_2;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbclk |= WM8996_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrclk_tx |= WM8996_AIF1TX_LRCLK_INV;\r\nlrclk_rx |= WM8996_AIF1RX_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbclk |= WM8996_AIF1_BCLK_INV;\r\nlrclk_tx |= WM8996_AIF1TX_LRCLK_INV;\r\nlrclk_rx |= WM8996_AIF1RX_LRCLK_INV;\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nlrclk_tx |= WM8996_AIF1TX_LRCLK_MSTR;\r\nlrclk_rx |= WM8996_AIF1RX_LRCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nbclk |= WM8996_AIF1_BCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbclk |= WM8996_AIF1_BCLK_MSTR;\r\nlrclk_tx |= WM8996_AIF1TX_LRCLK_MSTR;\r\nlrclk_rx |= WM8996_AIF1RX_LRCLK_MSTR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naifctrl |= 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naifctrl |= 2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naifctrl |= 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, aifctrl_reg, WM8996_AIF1_FMT_MASK, aifctrl);\r\nsnd_soc_update_bits(codec, bclk_reg,\r\nWM8996_AIF1_BCLK_INV | WM8996_AIF1_BCLK_MSTR,\r\nbclk);\r\nsnd_soc_update_bits(codec, lrclk_tx_reg,\r\nWM8996_AIF1TX_LRCLK_INV |\r\nWM8996_AIF1TX_LRCLK_MSTR,\r\nlrclk_tx);\r\nsnd_soc_update_bits(codec, lrclk_rx_reg,\r\nWM8996_AIF1RX_LRCLK_INV |\r\nWM8996_AIF1RX_LRCLK_MSTR,\r\nlrclk_rx);\r\nreturn 0;\r\n}\r\nstatic int wm8996_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint bits, i, bclk_rate, best;\r\nint aifdata = 0;\r\nint lrclk = 0;\r\nint dsp = 0;\r\nint aifdata_reg, lrclk_reg, dsp_shift;\r\nswitch (dai->id) {\r\ncase 0:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\r\n(snd_soc_read(codec, WM8996_GPIO_1)) & WM8996_GP1_FN_MASK) {\r\naifdata_reg = WM8996_AIF1RX_DATA_CONFIGURATION;\r\nlrclk_reg = WM8996_AIF1_RX_LRCLK_1;\r\n} else {\r\naifdata_reg = WM8996_AIF1TX_DATA_CONFIGURATION_1;\r\nlrclk_reg = WM8996_AIF1_TX_LRCLK_1;\r\n}\r\ndsp_shift = 0;\r\nbreak;\r\ncase 1:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\r\n(snd_soc_read(codec, WM8996_GPIO_2)) & WM8996_GP2_FN_MASK) {\r\naifdata_reg = WM8996_AIF2RX_DATA_CONFIGURATION;\r\nlrclk_reg = WM8996_AIF2_RX_LRCLK_1;\r\n} else {\r\naifdata_reg = WM8996_AIF2TX_DATA_CONFIGURATION_1;\r\nlrclk_reg = WM8996_AIF2_TX_LRCLK_1;\r\n}\r\ndsp_shift = WM8996_DSP2_DIV_SHIFT;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nbclk_rate = snd_soc_params_to_bclk(params);\r\nif (bclk_rate < 0) {\r\ndev_err(codec->dev, "Unsupported BCLK rate: %d\n", bclk_rate);\r\nreturn bclk_rate;\r\n}\r\nwm8996->bclk_rate[dai->id] = bclk_rate;\r\nwm8996->rx_rate[dai->id] = params_rate(params);\r\nbits = snd_pcm_format_width(params_format(params));\r\nif (bits < 0)\r\nreturn bits;\r\naifdata |= (bits << WM8996_AIF1TX_WL_SHIFT) | bits;\r\nbest = 0;\r\nfor (i = 0; i < ARRAY_SIZE(dsp_divs); i++) {\r\nif (abs(dsp_divs[i] - params_rate(params)) <\r\nabs(dsp_divs[best] - params_rate(params)))\r\nbest = i;\r\n}\r\ndsp |= i << dsp_shift;\r\nwm8996_update_bclk(codec);\r\nlrclk = bclk_rate / params_rate(params);\r\ndev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",\r\nlrclk, bclk_rate / lrclk);\r\nsnd_soc_update_bits(codec, aifdata_reg,\r\nWM8996_AIF1TX_WL_MASK |\r\nWM8996_AIF1TX_SLOT_LEN_MASK,\r\naifdata);\r\nsnd_soc_update_bits(codec, lrclk_reg, WM8996_AIF1RX_RATE_MASK,\r\nlrclk);\r\nsnd_soc_update_bits(codec, WM8996_AIF_CLOCKING_2,\r\nWM8996_DSP1_DIV_MASK << dsp_shift, dsp);\r\nreturn 0;\r\n}\r\nstatic int wm8996_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint lfclk = 0;\r\nint ratediv = 0;\r\nint sync = WM8996_REG_SYNC;\r\nint src;\r\nint old;\r\nif (freq == wm8996->sysclk && clk_id == wm8996->sysclk_src)\r\nreturn 0;\r\nold = snd_soc_read(codec, WM8996_AIF_CLOCKING_1) & WM8996_SYSCLK_ENA;\r\nsnd_soc_update_bits(codec, WM8996_AIF_CLOCKING_1,\r\nWM8996_SYSCLK_ENA, 0);\r\nswitch (clk_id) {\r\ncase WM8996_SYSCLK_MCLK1:\r\nwm8996->sysclk = freq;\r\nsrc = 0;\r\nbreak;\r\ncase WM8996_SYSCLK_MCLK2:\r\nwm8996->sysclk = freq;\r\nsrc = 1;\r\nbreak;\r\ncase WM8996_SYSCLK_FLL:\r\nwm8996->sysclk = freq;\r\nsrc = 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nswitch (wm8996->sysclk) {\r\ncase 5644800:\r\ncase 6144000:\r\nsnd_soc_update_bits(codec, WM8996_AIF_RATE,\r\nWM8996_SYSCLK_RATE, 0);\r\nbreak;\r\ncase 22579200:\r\ncase 24576000:\r\nratediv = WM8996_SYSCLK_DIV;\r\nwm8996->sysclk /= 2;\r\ncase 11289600:\r\ncase 12288000:\r\nsnd_soc_update_bits(codec, WM8996_AIF_RATE,\r\nWM8996_SYSCLK_RATE, WM8996_SYSCLK_RATE);\r\nbreak;\r\ncase 32000:\r\ncase 32768:\r\nlfclk = WM8996_LFCLK_ENA;\r\nsync = 0;\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "Unsupported clock rate %dHz\n",\r\nwm8996->sysclk);\r\nreturn -EINVAL;\r\n}\r\nwm8996_update_bclk(codec);\r\nsnd_soc_update_bits(codec, WM8996_AIF_CLOCKING_1,\r\nWM8996_SYSCLK_SRC_MASK | WM8996_SYSCLK_DIV_MASK,\r\nsrc << WM8996_SYSCLK_SRC_SHIFT | ratediv);\r\nsnd_soc_update_bits(codec, WM8996_CLOCKING_1, WM8996_LFCLK_ENA, lfclk);\r\nsnd_soc_update_bits(codec, WM8996_CONTROL_INTERFACE_1,\r\nWM8996_REG_SYNC, sync);\r\nsnd_soc_update_bits(codec, WM8996_AIF_CLOCKING_1,\r\nWM8996_SYSCLK_ENA, old);\r\nwm8996->sysclk_src = clk_id;\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nunsigned int target;\r\nunsigned int div;\r\nunsigned int fratio, gcd_fll;\r\nint i;\r\ndiv = 1;\r\nfll_div->fll_refclk_div = 0;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nfll_div->fll_refclk_div++;\r\nif (div > 8) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\npr_debug("FLL Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\nif (Fref >= 3000000)\r\nfll_div->fll_loop_gain = 5;\r\nelse\r\nfll_div->fll_loop_gain = 0;\r\nif (Fref >= 48000)\r\nfll_div->fll_ref_freq = 0;\r\nelse\r\nfll_div->fll_ref_freq = 1;\r\ndiv = 2;\r\nwhile (Fout * div < 90000000) {\r\ndiv++;\r\nif (div > 64) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntarget = Fout * div;\r\nfll_div->fll_outdiv = div - 1;\r\npr_debug("FLL Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\nfratio = fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nfll_div->n = target / (fratio * Fref);\r\nif (target % Fref == 0) {\r\nfll_div->theta = 0;\r\nfll_div->lambda = 0;\r\n} else {\r\ngcd_fll = gcd(target, fratio * Fref);\r\nfll_div->theta = (target - (fll_div->n * fratio * Fref))\r\n/ gcd_fll;\r\nfll_div->lambda = (fratio * Fref) / gcd_fll;\r\n}\r\npr_debug("FLL N=%x THETA=%x LAMBDA=%x\n",\r\nfll_div->n, fll_div->theta, fll_div->lambda);\r\npr_debug("FLL_FRATIO=%x FLL_OUTDIV=%x FLL_REFCLK_DIV=%x\n",\r\nfll_div->fll_fratio, fll_div->fll_outdiv,\r\nfll_div->fll_refclk_div);\r\nreturn 0;\r\n}\r\nstatic int wm8996_set_fll(struct snd_soc_codec *codec, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nstruct _fll_div fll_div;\r\nunsigned long timeout;\r\nint ret, reg, retry;\r\nif (source == wm8996->fll_src && Fref == wm8996->fll_fref &&\r\nFout == wm8996->fll_fout)\r\nreturn 0;\r\nif (Fout == 0) {\r\ndev_dbg(codec->dev, "FLL disabled\n");\r\nwm8996->fll_fref = 0;\r\nwm8996->fll_fout = 0;\r\nsnd_soc_update_bits(codec, WM8996_FLL_CONTROL_1,\r\nWM8996_FLL_ENA, 0);\r\nwm8996_bg_disable(codec);\r\nreturn 0;\r\n}\r\nret = fll_factors(&fll_div, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\nswitch (source) {\r\ncase WM8996_FLL_MCLK1:\r\nreg = 0;\r\nbreak;\r\ncase WM8996_FLL_MCLK2:\r\nreg = 1;\r\nbreak;\r\ncase WM8996_FLL_DACLRCLK1:\r\nreg = 2;\r\nbreak;\r\ncase WM8996_FLL_BCLK1:\r\nreg = 3;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown FLL source %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nreg |= fll_div.fll_refclk_div << WM8996_FLL_REFCLK_DIV_SHIFT;\r\nreg |= fll_div.fll_ref_freq << WM8996_FLL_REF_FREQ_SHIFT;\r\nsnd_soc_update_bits(codec, WM8996_FLL_CONTROL_5,\r\nWM8996_FLL_REFCLK_DIV_MASK | WM8996_FLL_REF_FREQ |\r\nWM8996_FLL_REFCLK_SRC_MASK, reg);\r\nreg = 0;\r\nif (fll_div.theta || fll_div.lambda)\r\nreg |= WM8996_FLL_EFS_ENA | (3 << WM8996_FLL_LFSR_SEL_SHIFT);\r\nelse\r\nreg |= 1 << WM8996_FLL_LFSR_SEL_SHIFT;\r\nsnd_soc_write(codec, WM8996_FLL_EFS_2, reg);\r\nsnd_soc_update_bits(codec, WM8996_FLL_CONTROL_2,\r\nWM8996_FLL_OUTDIV_MASK |\r\nWM8996_FLL_FRATIO_MASK,\r\n(fll_div.fll_outdiv << WM8996_FLL_OUTDIV_SHIFT) |\r\n(fll_div.fll_fratio));\r\nsnd_soc_write(codec, WM8996_FLL_CONTROL_3, fll_div.theta);\r\nsnd_soc_update_bits(codec, WM8996_FLL_CONTROL_4,\r\nWM8996_FLL_N_MASK | WM8996_FLL_LOOP_GAIN_MASK,\r\n(fll_div.n << WM8996_FLL_N_SHIFT) |\r\nfll_div.fll_loop_gain);\r\nsnd_soc_write(codec, WM8996_FLL_EFS_1, fll_div.lambda);\r\nret = snd_soc_read(codec, WM8996_FLL_CONTROL_1);\r\nif (!(ret & WM8996_FLL_ENA))\r\nwm8996_bg_enable(codec);\r\ntry_wait_for_completion(&wm8996->fll_lock);\r\nsnd_soc_update_bits(codec, WM8996_FLL_CONTROL_1,\r\nWM8996_FLL_ENA, WM8996_FLL_ENA);\r\nsnd_soc_write(codec, WM8996_FLL_CONTROL_6, WM8996_FLL_SWITCH_CLK);\r\nif (Fref > 1000000)\r\ntimeout = usecs_to_jiffies(300);\r\nelse\r\ntimeout = msecs_to_jiffies(2);\r\nif (i2c->irq)\r\ntimeout *= 10;\r\nelse\r\ntimeout /= 2;\r\nfor (retry = 0; retry < 10; retry++) {\r\nret = wait_for_completion_timeout(&wm8996->fll_lock,\r\ntimeout);\r\nif (ret != 0) {\r\nWARN_ON(!i2c->irq);\r\nbreak;\r\n}\r\nret = snd_soc_read(codec, WM8996_INTERRUPT_RAW_STATUS_2);\r\nif (ret & WM8996_FLL_LOCK_STS)\r\nbreak;\r\n}\r\nif (retry == 10) {\r\ndev_err(codec->dev, "Timed out waiting for FLL\n");\r\nret = -ETIMEDOUT;\r\n}\r\ndev_dbg(codec->dev, "FLL configured for %dHz->%dHz\n", Fref, Fout);\r\nwm8996->fll_fref = Fref;\r\nwm8996->fll_fout = Fout;\r\nwm8996->fll_src = source;\r\nreturn ret;\r\n}\r\nstatic inline struct wm8996_priv *gpio_to_wm8996(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct wm8996_priv, gpio_chip);\r\n}\r\nstatic void wm8996_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct wm8996_priv *wm8996 = gpio_to_wm8996(chip);\r\nregmap_update_bits(wm8996->regmap, WM8996_GPIO_1 + offset,\r\nWM8996_GP1_LVL, !!value << WM8996_GP1_LVL_SHIFT);\r\n}\r\nstatic int wm8996_gpio_direction_out(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct wm8996_priv *wm8996 = gpio_to_wm8996(chip);\r\nint val;\r\nval = (1 << WM8996_GP1_FN_SHIFT) | (!!value << WM8996_GP1_LVL_SHIFT);\r\nreturn regmap_update_bits(wm8996->regmap, WM8996_GPIO_1 + offset,\r\nWM8996_GP1_FN_MASK | WM8996_GP1_DIR |\r\nWM8996_GP1_LVL, val);\r\n}\r\nstatic int wm8996_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8996_priv *wm8996 = gpio_to_wm8996(chip);\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(wm8996->regmap, WM8996_GPIO_1 + offset, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (reg & WM8996_GP1_LVL) != 0;\r\n}\r\nstatic int wm8996_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8996_priv *wm8996 = gpio_to_wm8996(chip);\r\nreturn regmap_update_bits(wm8996->regmap, WM8996_GPIO_1 + offset,\r\nWM8996_GP1_FN_MASK | WM8996_GP1_DIR,\r\n(1 << WM8996_GP1_FN_SHIFT) |\r\n(1 << WM8996_GP1_DIR_SHIFT));\r\n}\r\nstatic void wm8996_init_gpio(struct wm8996_priv *wm8996)\r\n{\r\nint ret;\r\nwm8996->gpio_chip = wm8996_template_chip;\r\nwm8996->gpio_chip.ngpio = 5;\r\nwm8996->gpio_chip.dev = wm8996->dev;\r\nif (wm8996->pdata.gpio_base)\r\nwm8996->gpio_chip.base = wm8996->pdata.gpio_base;\r\nelse\r\nwm8996->gpio_chip.base = -1;\r\nret = gpiochip_add(&wm8996->gpio_chip);\r\nif (ret != 0)\r\ndev_err(wm8996->dev, "Failed to add GPIOs: %d\n", ret);\r\n}\r\nstatic void wm8996_free_gpio(struct wm8996_priv *wm8996)\r\n{\r\nint ret;\r\nret = gpiochip_remove(&wm8996->gpio_chip);\r\nif (ret != 0)\r\ndev_err(wm8996->dev, "Failed to remove GPIOs: %d\n", ret);\r\n}\r\nstatic void wm8996_init_gpio(struct wm8996_priv *wm8996)\r\n{\r\n}\r\nstatic void wm8996_free_gpio(struct wm8996_priv *wm8996)\r\n{\r\n}\r\nint wm8996_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,\r\nwm8996_polarity_fn polarity_cb)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nwm8996->jack = jack;\r\nwm8996->detecting = true;\r\nwm8996->polarity_cb = polarity_cb;\r\nwm8996->jack_flips = 0;\r\nif (wm8996->polarity_cb)\r\nwm8996->polarity_cb(codec, 0);\r\nsnd_soc_update_bits(codec, WM8996_MICBIAS_1,\r\nWM8996_MICB1_DISCH, 0);\r\nsnd_soc_update_bits(codec, WM8996_MICBIAS_2,\r\nWM8996_MICB2_DISCH, 0);\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "LDO2");\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "SYSCLK");\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1,\r\nWM8996_MICD_ENA, WM8996_MICD_ENA);\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1,\r\nWM8996_MICD_RATE_MASK,\r\nWM8996_MICD_RATE_MASK);\r\nsnd_soc_update_bits(codec, WM8996_INTERRUPT_STATUS_2_MASK,\r\nWM8996_IM_MICD_EINT | WM8996_HP_DONE_EINT, 0);\r\nreturn 0;\r\n}\r\nstatic void wm8996_hpdet_irq(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint val, reg, report;\r\nreport = SND_JACK_HEADPHONE;\r\nreg = snd_soc_read(codec, WM8996_HEADPHONE_DETECT_2);\r\nif (reg < 0) {\r\ndev_err(codec->dev, "Failed to read HPDET status\n");\r\ngoto out;\r\n}\r\nif (!(reg & WM8996_HP_DONE)) {\r\ndev_err(codec->dev, "Got HPDET IRQ but HPDET is busy\n");\r\ngoto out;\r\n}\r\nval = reg & WM8996_HP_LVL_MASK;\r\ndev_dbg(codec->dev, "HPDET measured %d ohms\n", val);\r\nif (val >= 126)\r\nreport = SND_JACK_LINEOUT;\r\nelse\r\nreport = SND_JACK_HEADPHONE;\r\nout:\r\nif (wm8996->jack_mic)\r\nreport |= SND_JACK_MICROPHONE;\r\nsnd_soc_jack_report(wm8996->jack, report,\r\nSND_JACK_LINEOUT | SND_JACK_HEADSET);\r\nwm8996->detecting = false;\r\nif (!(snd_soc_read(codec, WM8996_POWER_MANAGEMENT_1) &\r\n(WM8996_HPOUT1L_ENA | WM8996_HPOUT1R_RMV_SHORT)))\r\nsnd_soc_update_bits(codec, WM8996_ANALOGUE_HP_1,\r\nWM8996_HPOUT1L_RMV_SHORT |\r\nWM8996_HPOUT1R_RMV_SHORT, 0);\r\nsnd_soc_update_bits(codec, WM8996_ACCESSORY_DETECT_MODE_1,\r\nWM8996_JD_MODE_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1, WM8996_MICD_ENA,\r\nWM8996_MICD_ENA);\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "Bandgap");\r\nsnd_soc_dapm_sync(&codec->dapm);\r\n}\r\nstatic void wm8996_hpdet_start(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_update_bits(codec, WM8996_ANALOGUE_HP_1,\r\nWM8996_HPOUT1L_RMV_SHORT |\r\nWM8996_HPOUT1R_RMV_SHORT,\r\nWM8996_HPOUT1L_RMV_SHORT |\r\nWM8996_HPOUT1R_RMV_SHORT);\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "Bandgap");\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1, WM8996_MICD_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8996_ACCESSORY_DETECT_MODE_1,\r\nWM8996_JD_MODE_MASK, 1);\r\nsnd_soc_update_bits(codec, WM8996_HEADPHONE_DETECT_1,\r\nWM8996_HP_POLL, WM8996_HP_POLL);\r\n}\r\nstatic void wm8996_report_headphone(struct snd_soc_codec *codec)\r\n{\r\ndev_dbg(codec->dev, "Headphone detected\n");\r\nwm8996_hpdet_start(codec);\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1,\r\nWM8996_MICD_RATE_MASK |\r\nWM8996_MICD_BIAS_STARTTIME_MASK,\r\n7 << WM8996_MICD_RATE_SHIFT |\r\n7 << WM8996_MICD_BIAS_STARTTIME_SHIFT);\r\n}\r\nstatic void wm8996_micd(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint val, reg;\r\nval = snd_soc_read(codec, WM8996_MIC_DETECT_3);\r\ndev_dbg(codec->dev, "Microphone event: %x\n", val);\r\nif (!(val & WM8996_MICD_VALID)) {\r\ndev_warn(codec->dev, "Microphone detection state invalid\n");\r\nreturn;\r\n}\r\nif (!(val & WM8996_MICD_STS)) {\r\ndev_dbg(codec->dev, "Jack removal detected\n");\r\nwm8996->jack_mic = false;\r\nwm8996->detecting = true;\r\nwm8996->jack_flips = 0;\r\nsnd_soc_jack_report(wm8996->jack, 0,\r\nSND_JACK_LINEOUT | SND_JACK_HEADSET |\r\nSND_JACK_BTN_0);\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1,\r\nWM8996_MICD_RATE_MASK |\r\nWM8996_MICD_BIAS_STARTTIME_MASK,\r\nWM8996_MICD_RATE_MASK |\r\n9 << WM8996_MICD_BIAS_STARTTIME_SHIFT);\r\nreturn;\r\n}\r\nif (val & 0x400) {\r\nif (wm8996->detecting) {\r\ndev_dbg(codec->dev, "Microphone detected\n");\r\nwm8996->jack_mic = true;\r\nwm8996_hpdet_start(codec);\r\nsnd_soc_update_bits(codec, WM8996_MIC_DETECT_1,\r\nWM8996_MICD_RATE_MASK |\r\nWM8996_MICD_BIAS_STARTTIME_MASK,\r\n5 << WM8996_MICD_RATE_SHIFT |\r\n7 << WM8996_MICD_BIAS_STARTTIME_SHIFT);\r\n} else {\r\ndev_dbg(codec->dev, "Mic button up\n");\r\nsnd_soc_jack_report(wm8996->jack, 0, SND_JACK_BTN_0);\r\n}\r\nreturn;\r\n}\r\nif (wm8996->detecting && (val & 0x3f0)) {\r\nwm8996->jack_flips++;\r\nif (wm8996->jack_flips > 1) {\r\nwm8996_report_headphone(codec);\r\nreturn;\r\n}\r\nreg = snd_soc_read(codec, WM8996_ACCESSORY_DETECT_MODE_2);\r\nreg ^= WM8996_HPOUT1FB_SRC | WM8996_MICD_SRC |\r\nWM8996_MICD_BIAS_SRC;\r\nsnd_soc_update_bits(codec, WM8996_ACCESSORY_DETECT_MODE_2,\r\nWM8996_HPOUT1FB_SRC | WM8996_MICD_SRC |\r\nWM8996_MICD_BIAS_SRC, reg);\r\nif (wm8996->polarity_cb)\r\nwm8996->polarity_cb(codec,\r\n(reg & WM8996_MICD_SRC) != 0);\r\ndev_dbg(codec->dev, "Set microphone polarity to %d\n",\r\n(reg & WM8996_MICD_SRC) != 0);\r\nreturn;\r\n}\r\nif (val & 0x3fc) {\r\nif (wm8996->jack_mic) {\r\ndev_dbg(codec->dev, "Mic button detected\n");\r\nsnd_soc_jack_report(wm8996->jack, SND_JACK_BTN_0,\r\nSND_JACK_BTN_0);\r\n} else if (wm8996->detecting) {\r\nwm8996_report_headphone(codec);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t wm8996_irq(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nint irq_val;\r\nirq_val = snd_soc_read(codec, WM8996_INTERRUPT_STATUS_2);\r\nif (irq_val < 0) {\r\ndev_err(codec->dev, "Failed to read IRQ status: %d\n",\r\nirq_val);\r\nreturn IRQ_NONE;\r\n}\r\nirq_val &= ~snd_soc_read(codec, WM8996_INTERRUPT_STATUS_2_MASK);\r\nif (!irq_val)\r\nreturn IRQ_NONE;\r\nsnd_soc_write(codec, WM8996_INTERRUPT_STATUS_2, irq_val);\r\nif (irq_val & (WM8996_DCS_DONE_01_EINT | WM8996_DCS_DONE_23_EINT)) {\r\ndev_dbg(codec->dev, "DC servo IRQ\n");\r\ncomplete(&wm8996->dcs_done);\r\n}\r\nif (irq_val & WM8996_FIFOS_ERR_EINT)\r\ndev_err(codec->dev, "Digital core FIFO error\n");\r\nif (irq_val & WM8996_FLL_LOCK_EINT) {\r\ndev_dbg(codec->dev, "FLL locked\n");\r\ncomplete(&wm8996->fll_lock);\r\n}\r\nif (irq_val & WM8996_MICD_EINT)\r\nwm8996_micd(codec);\r\nif (irq_val & WM8996_HP_DONE_EINT)\r\nwm8996_hpdet_irq(codec);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm8996_edge_irq(int irq, void *data)\r\n{\r\nirqreturn_t ret = IRQ_NONE;\r\nirqreturn_t val;\r\ndo {\r\nval = wm8996_irq(irq, data);\r\nif (val != IRQ_NONE)\r\nret = val;\r\n} while (val != IRQ_NONE);\r\nreturn ret;\r\n}\r\nstatic void wm8996_retune_mobile_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8996_pdata *pdata = &wm8996->pdata;\r\nstruct snd_kcontrol_new controls[] = {\r\nSOC_ENUM_EXT("DSP1 EQ Mode",\r\nwm8996->retune_mobile_enum,\r\nwm8996_get_retune_mobile_enum,\r\nwm8996_put_retune_mobile_enum),\r\nSOC_ENUM_EXT("DSP2 EQ Mode",\r\nwm8996->retune_mobile_enum,\r\nwm8996_get_retune_mobile_enum,\r\nwm8996_put_retune_mobile_enum),\r\n};\r\nint ret, i, j;\r\nconst char **t;\r\nwm8996->num_retune_mobile_texts = 0;\r\nwm8996->retune_mobile_texts = NULL;\r\nfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\r\nfor (j = 0; j < wm8996->num_retune_mobile_texts; j++) {\r\nif (strcmp(pdata->retune_mobile_cfgs[i].name,\r\nwm8996->retune_mobile_texts[j]) == 0)\r\nbreak;\r\n}\r\nif (j != wm8996->num_retune_mobile_texts)\r\ncontinue;\r\nt = krealloc(wm8996->retune_mobile_texts,\r\nsizeof(char *) *\r\n(wm8996->num_retune_mobile_texts + 1),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\ncontinue;\r\nt[wm8996->num_retune_mobile_texts] =\r\npdata->retune_mobile_cfgs[i].name;\r\nwm8996->num_retune_mobile_texts++;\r\nwm8996->retune_mobile_texts = t;\r\n}\r\ndev_dbg(codec->dev, "Allocated %d unique ReTune Mobile names\n",\r\nwm8996->num_retune_mobile_texts);\r\nwm8996->retune_mobile_enum.max = wm8996->num_retune_mobile_texts;\r\nwm8996->retune_mobile_enum.texts = wm8996->retune_mobile_texts;\r\nret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));\r\nif (ret != 0)\r\ndev_err(codec->dev,\r\n"Failed to add ReTune Mobile controls: %d\n", ret);\r\n}\r\nstatic int wm8996_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nstruct wm8996_priv *wm8996 = snd_soc_codec_get_drvdata(codec);\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nint irq_flags;\r\nwm8996->codec = codec;\r\ninit_completion(&wm8996->dcs_done);\r\ninit_completion(&wm8996->fll_lock);\r\ncodec->control_data = wm8996->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\ngoto err;\r\n}\r\nif (wm8996->pdata.num_retune_mobile_cfgs)\r\nwm8996_retune_mobile_pdata(codec);\r\nelse\r\nsnd_soc_add_codec_controls(codec, wm8996_eq_controls,\r\nARRAY_SIZE(wm8996_eq_controls));\r\nif (i2c->irq) {\r\nif (wm8996->pdata.irq_flags)\r\nirq_flags = wm8996->pdata.irq_flags;\r\nelse\r\nirq_flags = IRQF_TRIGGER_LOW;\r\nirq_flags |= IRQF_ONESHOT;\r\nif (irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))\r\nret = request_threaded_irq(i2c->irq, NULL,\r\nwm8996_edge_irq,\r\nirq_flags, "wm8996", codec);\r\nelse\r\nret = request_threaded_irq(i2c->irq, NULL, wm8996_irq,\r\nirq_flags, "wm8996", codec);\r\nif (ret == 0) {\r\nsnd_soc_update_bits(codec, WM8996_INTERRUPT_CONTROL,\r\nWM8996_IM_IRQ, 0);\r\nsnd_soc_update_bits(codec,\r\nWM8996_INTERRUPT_STATUS_2_MASK,\r\nWM8996_IM_DCS_DONE_23_EINT |\r\nWM8996_IM_DCS_DONE_01_EINT |\r\nWM8996_IM_FLL_LOCK_EINT |\r\nWM8996_IM_FIFOS_ERR_EINT,\r\n0);\r\n} else {\r\ndev_err(codec->dev, "Failed to request IRQ: %d\n",\r\nret);\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm8996_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nsnd_soc_update_bits(codec, WM8996_INTERRUPT_CONTROL,\r\nWM8996_IM_IRQ, WM8996_IM_IRQ);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, codec);\r\nreturn 0;\r\n}\r\nstatic int wm8996_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8996_priv *wm8996;\r\nint ret, i;\r\nunsigned int reg;\r\nwm8996 = devm_kzalloc(&i2c->dev, sizeof(struct wm8996_priv),\r\nGFP_KERNEL);\r\nif (wm8996 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8996);\r\nwm8996->dev = &i2c->dev;\r\nif (dev_get_platdata(&i2c->dev))\r\nmemcpy(&wm8996->pdata, dev_get_platdata(&i2c->dev),\r\nsizeof(wm8996->pdata));\r\nif (wm8996->pdata.ldo_ena > 0) {\r\nret = gpio_request_one(wm8996->pdata.ldo_ena,\r\nGPIOF_OUT_INIT_LOW, "WM8996 ENA");\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to request GPIO %d: %d\n",\r\nwm8996->pdata.ldo_ena, ret);\r\ngoto err;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8996->supplies); i++)\r\nwm8996->supplies[i].supply = wm8996_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8996->supplies),\r\nwm8996->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\ngoto err_gpio;\r\n}\r\nwm8996->disable_nb[0].notifier_call = wm8996_regulator_event_0;\r\nwm8996->disable_nb[1].notifier_call = wm8996_regulator_event_1;\r\nwm8996->disable_nb[2].notifier_call = wm8996_regulator_event_2;\r\nfor (i = 0; i < ARRAY_SIZE(wm8996->supplies); i++) {\r\nret = regulator_register_notifier(wm8996->supplies[i].consumer,\r\n&wm8996->disable_nb[i]);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8996->supplies),\r\nwm8996->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_gpio;\r\n}\r\nif (wm8996->pdata.ldo_ena > 0) {\r\ngpio_set_value_cansleep(wm8996->pdata.ldo_ena, 1);\r\nmsleep(5);\r\n}\r\nwm8996->regmap = devm_regmap_init_i2c(i2c, &wm8996_regmap);\r\nif (IS_ERR(wm8996->regmap)) {\r\nret = PTR_ERR(wm8996->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nret = regmap_read(wm8996->regmap, WM8996_SOFTWARE_RESET, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_regmap;\r\n}\r\nif (reg != 0x8915) {\r\ndev_err(&i2c->dev, "Device is not a WM8996, ID %x\n", reg);\r\nret = -EINVAL;\r\ngoto err_regmap;\r\n}\r\nret = regmap_read(wm8996->regmap, WM8996_CHIP_REVISION, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_regmap;\r\n}\r\ndev_info(&i2c->dev, "revision %c\n",\r\n(reg & WM8996_CHIP_REV_MASK) + 'A');\r\nif (wm8996->pdata.ldo_ena > 0) {\r\ngpio_set_value_cansleep(wm8996->pdata.ldo_ena, 0);\r\nregcache_cache_only(wm8996->regmap, true);\r\n} else {\r\nret = regmap_write(wm8996->regmap, WM8996_SOFTWARE_RESET,\r\n0x8915);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_regmap;\r\n}\r\n}\r\nregulator_bulk_disable(ARRAY_SIZE(wm8996->supplies), wm8996->supplies);\r\nregmap_update_bits(wm8996->regmap, WM8996_LINE_INPUT_CONTROL,\r\nWM8996_INL_MODE_MASK | WM8996_INR_MODE_MASK,\r\nwm8996->pdata.inl_mode << WM8996_INL_MODE_SHIFT |\r\nwm8996->pdata.inr_mode);\r\nfor (i = 0; i < ARRAY_SIZE(wm8996->pdata.gpio_default); i++) {\r\nif (!wm8996->pdata.gpio_default[i])\r\ncontinue;\r\nregmap_write(wm8996->regmap, WM8996_GPIO_1 + i,\r\nwm8996->pdata.gpio_default[i] & 0xffff);\r\n}\r\nif (wm8996->pdata.spkmute_seq)\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_PDM_SPEAKER_MUTE_SEQUENCE,\r\nWM8996_SPK_MUTE_ENDIAN |\r\nWM8996_SPK_MUTE_SEQ1_MASK,\r\nwm8996->pdata.spkmute_seq);\r\nregmap_update_bits(wm8996->regmap, WM8996_ACCESSORY_DETECT_MODE_2,\r\nWM8996_MICD_BIAS_SRC | WM8996_HPOUT1FB_SRC |\r\nWM8996_MICD_SRC, wm8996->pdata.micdet_def);\r\nregmap_update_bits(wm8996->regmap, WM8996_LEFT_LINE_INPUT_VOLUME,\r\nWM8996_IN1_VU, WM8996_IN1_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_RIGHT_LINE_INPUT_VOLUME,\r\nWM8996_IN1_VU, WM8996_IN1_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DAC1_LEFT_VOLUME,\r\nWM8996_DAC1_VU, WM8996_DAC1_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DAC1_RIGHT_VOLUME,\r\nWM8996_DAC1_VU, WM8996_DAC1_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DAC2_LEFT_VOLUME,\r\nWM8996_DAC2_VU, WM8996_DAC2_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DAC2_RIGHT_VOLUME,\r\nWM8996_DAC2_VU, WM8996_DAC2_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_OUTPUT1_LEFT_VOLUME,\r\nWM8996_DAC1_VU, WM8996_DAC1_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_OUTPUT1_RIGHT_VOLUME,\r\nWM8996_DAC1_VU, WM8996_DAC1_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_OUTPUT2_LEFT_VOLUME,\r\nWM8996_DAC2_VU, WM8996_DAC2_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_OUTPUT2_RIGHT_VOLUME,\r\nWM8996_DAC2_VU, WM8996_DAC2_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP1_TX_LEFT_VOLUME,\r\nWM8996_DSP1TX_VU, WM8996_DSP1TX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP1_TX_RIGHT_VOLUME,\r\nWM8996_DSP1TX_VU, WM8996_DSP1TX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP2_TX_LEFT_VOLUME,\r\nWM8996_DSP2TX_VU, WM8996_DSP2TX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP2_TX_RIGHT_VOLUME,\r\nWM8996_DSP2TX_VU, WM8996_DSP2TX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP1_RX_LEFT_VOLUME,\r\nWM8996_DSP1RX_VU, WM8996_DSP1RX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP1_RX_RIGHT_VOLUME,\r\nWM8996_DSP1RX_VU, WM8996_DSP1RX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP2_RX_LEFT_VOLUME,\r\nWM8996_DSP2RX_VU, WM8996_DSP2RX_VU);\r\nregmap_update_bits(wm8996->regmap, WM8996_DSP2_RX_RIGHT_VOLUME,\r\nWM8996_DSP2RX_VU, WM8996_DSP2RX_VU);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1RX_CHANNEL_0_CONFIGURATION,\r\nWM8996_AIF1RX_CHAN0_SLOTS_MASK |\r\nWM8996_AIF1RX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1RX_CHAN0_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1RX_CHANNEL_1_CONFIGURATION,\r\nWM8996_AIF1RX_CHAN1_SLOTS_MASK |\r\nWM8996_AIF1RX_CHAN1_START_SLOT_MASK,\r\n1 << WM8996_AIF1RX_CHAN1_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1RX_CHANNEL_2_CONFIGURATION,\r\nWM8996_AIF1RX_CHAN2_SLOTS_MASK |\r\nWM8996_AIF1RX_CHAN2_START_SLOT_MASK,\r\n1 << WM8996_AIF1RX_CHAN2_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1RX_CHANNEL_3_CONFIGURATION,\r\nWM8996_AIF1RX_CHAN3_SLOTS_MASK |\r\nWM8996_AIF1RX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1RX_CHAN3_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1RX_CHANNEL_4_CONFIGURATION,\r\nWM8996_AIF1RX_CHAN4_SLOTS_MASK |\r\nWM8996_AIF1RX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1RX_CHAN4_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1RX_CHANNEL_5_CONFIGURATION,\r\nWM8996_AIF1RX_CHAN5_SLOTS_MASK |\r\nWM8996_AIF1RX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1RX_CHAN5_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF2RX_CHANNEL_0_CONFIGURATION,\r\nWM8996_AIF2RX_CHAN0_SLOTS_MASK |\r\nWM8996_AIF2RX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF2RX_CHAN0_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF2RX_CHANNEL_1_CONFIGURATION,\r\nWM8996_AIF2RX_CHAN1_SLOTS_MASK |\r\nWM8996_AIF2RX_CHAN1_START_SLOT_MASK,\r\n1 << WM8996_AIF2RX_CHAN1_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_0_CONFIGURATION,\r\nWM8996_AIF1TX_CHAN0_SLOTS_MASK |\r\nWM8996_AIF1TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN0_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_1_CONFIGURATION,\r\nWM8996_AIF1TX_CHAN1_SLOTS_MASK |\r\nWM8996_AIF1TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN1_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_2_CONFIGURATION,\r\nWM8996_AIF1TX_CHAN2_SLOTS_MASK |\r\nWM8996_AIF1TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN2_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_3_CONFIGURATION,\r\nWM8996_AIF1TX_CHAN3_SLOTS_MASK |\r\nWM8996_AIF1TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN3_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_4_CONFIGURATION,\r\nWM8996_AIF1TX_CHAN4_SLOTS_MASK |\r\nWM8996_AIF1TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN4_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_5_CONFIGURATION,\r\nWM8996_AIF1TX_CHAN5_SLOTS_MASK |\r\nWM8996_AIF1TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN5_SLOTS_SHIFT | 1);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF2TX_CHANNEL_0_CONFIGURATION,\r\nWM8996_AIF2TX_CHAN0_SLOTS_MASK |\r\nWM8996_AIF2TX_CHAN0_START_SLOT_MASK,\r\n1 << WM8996_AIF2TX_CHAN0_SLOTS_SHIFT | 0);\r\nregmap_update_bits(wm8996->regmap,\r\nWM8996_AIF1TX_CHANNEL_1_CONFIGURATION,\r\nWM8996_AIF2TX_CHAN1_SLOTS_MASK |\r\nWM8996_AIF2TX_CHAN1_START_SLOT_MASK,\r\n1 << WM8996_AIF1TX_CHAN1_SLOTS_SHIFT | 1);\r\nret = regmap_read(wm8996->regmap, WM8996_GPIO_1, &reg);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to read GPIO1: %d\n", ret);\r\ngoto err_regmap;\r\n}\r\nif (reg & WM8996_GP1_FN_MASK)\r\nregmap_update_bits(wm8996->regmap, WM8996_AIF1_TX_LRCLK_2,\r\nWM8996_AIF1TX_LRCLK_MODE,\r\nWM8996_AIF1TX_LRCLK_MODE);\r\nret = regmap_read(wm8996->regmap, WM8996_GPIO_2, &reg);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to read GPIO2: %d\n", ret);\r\ngoto err_regmap;\r\n}\r\nif (reg & WM8996_GP2_FN_MASK)\r\nregmap_update_bits(wm8996->regmap, WM8996_AIF2_TX_LRCLK_2,\r\nWM8996_AIF2TX_LRCLK_MODE,\r\nWM8996_AIF2TX_LRCLK_MODE);\r\nwm8996_init_gpio(wm8996);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8996, wm8996_dai,\r\nARRAY_SIZE(wm8996_dai));\r\nif (ret < 0)\r\ngoto err_gpiolib;\r\nreturn ret;\r\nerr_gpiolib:\r\nwm8996_free_gpio(wm8996);\r\nerr_regmap:\r\nerr_enable:\r\nif (wm8996->pdata.ldo_ena > 0)\r\ngpio_set_value_cansleep(wm8996->pdata.ldo_ena, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8996->supplies), wm8996->supplies);\r\nerr_gpio:\r\nif (wm8996->pdata.ldo_ena > 0)\r\ngpio_free(wm8996->pdata.ldo_ena);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm8996_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct wm8996_priv *wm8996 = i2c_get_clientdata(client);\r\nint i;\r\nsnd_soc_unregister_codec(&client->dev);\r\nwm8996_free_gpio(wm8996);\r\nif (wm8996->pdata.ldo_ena > 0) {\r\ngpio_set_value_cansleep(wm8996->pdata.ldo_ena, 0);\r\ngpio_free(wm8996->pdata.ldo_ena);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8996->supplies); i++)\r\nregulator_unregister_notifier(wm8996->supplies[i].consumer,\r\n&wm8996->disable_nb[i]);\r\nreturn 0;\r\n}
