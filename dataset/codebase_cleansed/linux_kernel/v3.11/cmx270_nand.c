static u_char cmx270_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nreturn (readl(this->IO_ADDR_R) >> 16);\r\n}\r\nstatic void cmx270_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i=0; i<len; i++)\r\nwritel((*buf++ << 16), this->IO_ADDR_W);\r\n}\r\nstatic void cmx270_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i=0; i<len; i++)\r\n*buf++ = readl(this->IO_ADDR_R) >> 16;\r\n}\r\nstatic inline void nand_cs_on(void)\r\n{\r\ngpio_set_value(GPIO_NAND_CS, 0);\r\n}\r\nstatic void nand_cs_off(void)\r\n{\r\ndsb();\r\ngpio_set_value(GPIO_NAND_CS, 1);\r\n}\r\nstatic void cmx270_hwcontrol(struct mtd_info *mtd, int dat,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip* this = mtd->priv;\r\nunsigned int nandaddr = (unsigned int)this->IO_ADDR_W;\r\ndsb();\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif ( ctrl & NAND_ALE )\r\nnandaddr |= (1 << 3);\r\nelse\r\nnandaddr &= ~(1 << 3);\r\nif ( ctrl & NAND_CLE )\r\nnandaddr |= (1 << 2);\r\nelse\r\nnandaddr &= ~(1 << 2);\r\nif ( ctrl & NAND_NCE )\r\nnand_cs_on();\r\nelse\r\nnand_cs_off();\r\n}\r\ndsb();\r\nthis->IO_ADDR_W = (void __iomem*)nandaddr;\r\nif (dat != NAND_CMD_NONE)\r\nwritel((dat << 16), this->IO_ADDR_W);\r\ndsb();\r\n}\r\nstatic int cmx270_device_ready(struct mtd_info *mtd)\r\n{\r\ndsb();\r\nreturn (gpio_get_value(GPIO_NAND_RB));\r\n}\r\nstatic int __init cmx270_init(void)\r\n{\r\nstruct nand_chip *this;\r\nint ret;\r\nif (!(machine_is_armcore() && cpu_is_pxa27x()))\r\nreturn -ENODEV;\r\nret = gpio_request(GPIO_NAND_CS, "NAND CS");\r\nif (ret) {\r\npr_warning("CM-X270: failed to request NAND CS gpio\n");\r\nreturn ret;\r\n}\r\ngpio_direction_output(GPIO_NAND_CS, 1);\r\nret = gpio_request(GPIO_NAND_RB, "NAND R/B");\r\nif (ret) {\r\npr_warning("CM-X270: failed to request NAND R/B gpio\n");\r\ngoto err_gpio_request;\r\n}\r\ngpio_direction_input(GPIO_NAND_RB);\r\ncmx270_nand_mtd = kzalloc(sizeof(struct mtd_info) +\r\nsizeof(struct nand_chip),\r\nGFP_KERNEL);\r\nif (!cmx270_nand_mtd) {\r\npr_debug("Unable to allocate CM-X270 NAND MTD device structure.\n");\r\nret = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\ncmx270_nand_io = ioremap(PXA_CS1_PHYS, 12);\r\nif (!cmx270_nand_io) {\r\npr_debug("Unable to ioremap NAND device\n");\r\nret = -EINVAL;\r\ngoto err_ioremap;\r\n}\r\nthis = (struct nand_chip *)(&cmx270_nand_mtd[1]);\r\ncmx270_nand_mtd->owner = THIS_MODULE;\r\ncmx270_nand_mtd->priv = this;\r\nthis->IO_ADDR_R = cmx270_nand_io;\r\nthis->IO_ADDR_W = cmx270_nand_io;\r\nthis->cmd_ctrl = cmx270_hwcontrol;\r\nthis->dev_ready = cmx270_device_ready;\r\nthis->chip_delay = 20;\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nthis->read_byte = cmx270_read_byte;\r\nthis->read_buf = cmx270_read_buf;\r\nthis->write_buf = cmx270_write_buf;\r\nif (nand_scan (cmx270_nand_mtd, 1)) {\r\npr_notice("No NAND device\n");\r\nret = -ENXIO;\r\ngoto err_scan;\r\n}\r\nret = mtd_device_parse_register(cmx270_nand_mtd, NULL, NULL,\r\npartition_info, NUM_PARTITIONS);\r\nif (ret)\r\ngoto err_scan;\r\nreturn 0;\r\nerr_scan:\r\niounmap(cmx270_nand_io);\r\nerr_ioremap:\r\nkfree(cmx270_nand_mtd);\r\nerr_kzalloc:\r\ngpio_free(GPIO_NAND_RB);\r\nerr_gpio_request:\r\ngpio_free(GPIO_NAND_CS);\r\nreturn ret;\r\n}\r\nstatic void __exit cmx270_cleanup(void)\r\n{\r\nnand_release(cmx270_nand_mtd);\r\ngpio_free(GPIO_NAND_RB);\r\ngpio_free(GPIO_NAND_CS);\r\niounmap(cmx270_nand_io);\r\nkfree (cmx270_nand_mtd);\r\n}
