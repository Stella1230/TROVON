static int __init default_appraise_setup(char *str)\r\n{\r\nif (strncmp(str, "off", 3) == 0)\r\nima_appraise = 0;\r\nelse if (strncmp(str, "fix", 3) == 0)\r\nima_appraise = IMA_APPRAISE_FIX;\r\nreturn 1;\r\n}\r\nint ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)\r\n{\r\nif (!ima_appraise)\r\nreturn 0;\r\nreturn ima_match_policy(inode, func, mask, IMA_APPRAISE);\r\n}\r\nstatic int ima_fix_xattr(struct dentry *dentry,\r\nstruct integrity_iint_cache *iint)\r\n{\r\niint->ima_xattr.type = IMA_XATTR_DIGEST;\r\nreturn __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\r\n(u8 *)&iint->ima_xattr,\r\nsizeof(iint->ima_xattr), 0);\r\n}\r\nenum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,\r\nint func)\r\n{\r\nswitch(func) {\r\ncase MMAP_CHECK:\r\nreturn iint->ima_mmap_status;\r\ncase BPRM_CHECK:\r\nreturn iint->ima_bprm_status;\r\ncase MODULE_CHECK:\r\nreturn iint->ima_module_status;\r\ncase FILE_CHECK:\r\ndefault:\r\nreturn iint->ima_file_status;\r\n}\r\n}\r\nstatic void ima_set_cache_status(struct integrity_iint_cache *iint,\r\nint func, enum integrity_status status)\r\n{\r\nswitch(func) {\r\ncase MMAP_CHECK:\r\niint->ima_mmap_status = status;\r\nbreak;\r\ncase BPRM_CHECK:\r\niint->ima_bprm_status = status;\r\nbreak;\r\ncase MODULE_CHECK:\r\niint->ima_module_status = status;\r\nbreak;\r\ncase FILE_CHECK:\r\ndefault:\r\niint->ima_file_status = status;\r\nbreak;\r\n}\r\n}\r\nstatic void ima_cache_flags(struct integrity_iint_cache *iint, int func)\r\n{\r\nswitch(func) {\r\ncase MMAP_CHECK:\r\niint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase BPRM_CHECK:\r\niint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase MODULE_CHECK:\r\niint->flags |= (IMA_MODULE_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase FILE_CHECK:\r\ndefault:\r\niint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\n}\r\n}\r\nint ima_appraise_measurement(int func, struct integrity_iint_cache *iint,\r\nstruct file *file, const unsigned char *filename)\r\n{\r\nstruct dentry *dentry = file->f_dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nstruct evm_ima_xattr_data *xattr_value = NULL;\r\nenum integrity_status status = INTEGRITY_UNKNOWN;\r\nconst char *op = "appraise_data";\r\nchar *cause = "unknown";\r\nint rc;\r\nif (!ima_appraise)\r\nreturn 0;\r\nif (!inode->i_op->getxattr)\r\nreturn INTEGRITY_UNKNOWN;\r\nrc = vfs_getxattr_alloc(dentry, XATTR_NAME_IMA, (char **)&xattr_value,\r\n0, GFP_NOFS);\r\nif (rc <= 0) {\r\nif (rc && rc != -ENODATA)\r\ngoto out;\r\ncause = "missing-hash";\r\nstatus =\r\n(inode->i_size == 0) ? INTEGRITY_PASS : INTEGRITY_NOLABEL;\r\ngoto out;\r\n}\r\nstatus = evm_verifyxattr(dentry, XATTR_NAME_IMA, xattr_value, rc, iint);\r\nif ((status != INTEGRITY_PASS) && (status != INTEGRITY_UNKNOWN)) {\r\nif ((status == INTEGRITY_NOLABEL)\r\n|| (status == INTEGRITY_NOXATTRS))\r\ncause = "missing-HMAC";\r\nelse if (status == INTEGRITY_FAIL)\r\ncause = "invalid-HMAC";\r\ngoto out;\r\n}\r\nswitch (xattr_value->type) {\r\ncase IMA_XATTR_DIGEST:\r\nif (iint->flags & IMA_DIGSIG_REQUIRED) {\r\ncause = "IMA signature required";\r\nstatus = INTEGRITY_FAIL;\r\nbreak;\r\n}\r\nrc = memcmp(xattr_value->digest, iint->ima_xattr.digest,\r\nIMA_DIGEST_SIZE);\r\nif (rc) {\r\ncause = "invalid-hash";\r\nstatus = INTEGRITY_FAIL;\r\nbreak;\r\n}\r\nstatus = INTEGRITY_PASS;\r\nbreak;\r\ncase EVM_IMA_XATTR_DIGSIG:\r\niint->flags |= IMA_DIGSIG;\r\nrc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,\r\nxattr_value->digest, rc - 1,\r\niint->ima_xattr.digest,\r\nIMA_DIGEST_SIZE);\r\nif (rc == -EOPNOTSUPP) {\r\nstatus = INTEGRITY_UNKNOWN;\r\n} else if (rc) {\r\ncause = "invalid-signature";\r\nstatus = INTEGRITY_FAIL;\r\n} else {\r\nstatus = INTEGRITY_PASS;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = INTEGRITY_UNKNOWN;\r\ncause = "unknown-ima-data";\r\nbreak;\r\n}\r\nout:\r\nif (status != INTEGRITY_PASS) {\r\nif ((ima_appraise & IMA_APPRAISE_FIX) &&\r\n(!xattr_value ||\r\nxattr_value->type != EVM_IMA_XATTR_DIGSIG)) {\r\nif (!ima_fix_xattr(dentry, iint))\r\nstatus = INTEGRITY_PASS;\r\n}\r\nintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,\r\nop, cause, rc, 0);\r\n} else {\r\nima_cache_flags(iint, func);\r\n}\r\nima_set_cache_status(iint, func, status);\r\nkfree(xattr_value);\r\nreturn status;\r\n}\r\nvoid ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)\r\n{\r\nstruct dentry *dentry = file->f_dentry;\r\nint rc = 0;\r\nif (iint->flags & IMA_DIGSIG)\r\nreturn;\r\nrc = ima_collect_measurement(iint, file);\r\nif (rc < 0)\r\nreturn;\r\nima_fix_xattr(dentry, iint);\r\n}\r\nvoid ima_inode_post_setattr(struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct integrity_iint_cache *iint;\r\nint must_appraise, rc;\r\nif (!ima_initialized || !ima_appraise || !S_ISREG(inode->i_mode)\r\n|| !inode->i_op->removexattr)\r\nreturn;\r\nmust_appraise = ima_must_appraise(inode, MAY_ACCESS, POST_SETATTR);\r\niint = integrity_iint_find(inode);\r\nif (iint) {\r\niint->flags &= ~(IMA_APPRAISE | IMA_APPRAISED |\r\nIMA_APPRAISE_SUBMASK | IMA_APPRAISED_SUBMASK |\r\nIMA_ACTION_FLAGS);\r\nif (must_appraise)\r\niint->flags |= IMA_APPRAISE;\r\n}\r\nif (!must_appraise)\r\nrc = inode->i_op->removexattr(dentry, XATTR_NAME_IMA);\r\nreturn;\r\n}\r\nstatic int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ima_reset_appraise_flags(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nif (!ima_initialized || !ima_appraise || !S_ISREG(inode->i_mode))\r\nreturn;\r\niint = integrity_iint_find(inode);\r\nif (!iint)\r\nreturn;\r\niint->flags &= ~IMA_DONE_MASK;\r\nreturn;\r\n}\r\nint ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nint result;\r\nresult = ima_protect_xattr(dentry, xattr_name, xattr_value,\r\nxattr_value_len);\r\nif (result == 1) {\r\nima_reset_appraise_flags(dentry->d_inode);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nint ima_inode_removexattr(struct dentry *dentry, const char *xattr_name)\r\n{\r\nint result;\r\nresult = ima_protect_xattr(dentry, xattr_name, NULL, 0);\r\nif (result == 1) {\r\nima_reset_appraise_flags(dentry->d_inode);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}
