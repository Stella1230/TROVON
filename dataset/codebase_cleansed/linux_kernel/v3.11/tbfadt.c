static void\r\nacpi_tb_init_generic_address(struct acpi_generic_address *generic_address,\r\nu8 space_id,\r\nu8 byte_width, u64 address, char *register_name)\r\n{\r\nu8 bit_width;\r\nbit_width = (u8)(byte_width * 8);\r\nif (byte_width > 31) {\r\nACPI_ERROR((AE_INFO,\r\n"%s - 32-bit FADT register is too long (%u bytes, %u bits) "\r\n"to convert to GAS struct - 255 bits max, truncating",\r\nregister_name, byte_width, (byte_width * 8)));\r\nbit_width = 255;\r\n}\r\nACPI_MOVE_64_TO_64(&generic_address->address, &address);\r\ngeneric_address->space_id = space_id;\r\ngeneric_address->bit_width = bit_width;\r\ngeneric_address->bit_offset = 0;\r\ngeneric_address->access_width = 0;\r\n}\r\nvoid acpi_tb_parse_fadt(u32 table_index)\r\n{\r\nu32 length;\r\nstruct acpi_table_header *table;\r\nlength = acpi_gbl_root_table_list.tables[table_index].length;\r\ntable =\r\nacpi_os_map_memory(acpi_gbl_root_table_list.tables[table_index].\r\naddress, length);\r\nif (!table) {\r\nreturn;\r\n}\r\n(void)acpi_tb_verify_checksum(table, length);\r\nacpi_tb_create_local_fadt(table, length);\r\nacpi_os_unmap_memory(table, length);\r\nacpi_tb_install_table((acpi_physical_address) acpi_gbl_FADT.Xdsdt,\r\nACPI_SIG_DSDT, ACPI_TABLE_INDEX_DSDT);\r\nif (!acpi_gbl_reduced_hardware) {\r\nacpi_tb_install_table((acpi_physical_address) acpi_gbl_FADT.\r\nXfacs, ACPI_SIG_FACS,\r\nACPI_TABLE_INDEX_FACS);\r\n}\r\n}\r\nvoid acpi_tb_create_local_fadt(struct acpi_table_header *table, u32 length)\r\n{\r\nif (length > sizeof(struct acpi_table_fadt)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"FADT (revision %u) is longer than ACPI 5.0 version, "\r\n"truncating length %u to %u",\r\ntable->revision, length,\r\n(u32)sizeof(struct acpi_table_fadt)));\r\n}\r\nACPI_MEMSET(&acpi_gbl_FADT, 0, sizeof(struct acpi_table_fadt));\r\nACPI_MEMCPY(&acpi_gbl_FADT, table,\r\nACPI_MIN(length, sizeof(struct acpi_table_fadt)));\r\nacpi_gbl_reduced_hardware = FALSE;\r\nif (acpi_gbl_FADT.flags & ACPI_FADT_HW_REDUCED) {\r\nacpi_gbl_reduced_hardware = TRUE;\r\n}\r\nacpi_tb_convert_fadt();\r\nacpi_tb_validate_fadt();\r\nacpi_tb_setup_fadt_registers();\r\n}\r\nstatic void acpi_tb_convert_fadt(void)\r\n{\r\nstruct acpi_generic_address *address64;\r\nu32 address32;\r\nu32 i;\r\nif (!acpi_gbl_FADT.Xfacs) {\r\nacpi_gbl_FADT.Xfacs = (u64) acpi_gbl_FADT.facs;\r\n} else if (acpi_gbl_FADT.facs &&\r\n(acpi_gbl_FADT.Xfacs != (u64) acpi_gbl_FADT.facs)) {\r\nACPI_WARNING((AE_INFO,\r\n"32/64 FACS address mismatch in FADT - two FACS tables!"));\r\n}\r\nif (!acpi_gbl_FADT.Xdsdt) {\r\nacpi_gbl_FADT.Xdsdt = (u64) acpi_gbl_FADT.dsdt;\r\n} else if (acpi_gbl_FADT.dsdt &&\r\n(acpi_gbl_FADT.Xdsdt != (u64) acpi_gbl_FADT.dsdt)) {\r\nACPI_WARNING((AE_INFO,\r\n"32/64 DSDT address mismatch in FADT - two DSDT tables!"));\r\n}\r\nif (acpi_gbl_FADT.header.length <= ACPI_FADT_V2_SIZE) {\r\nacpi_gbl_FADT.preferred_profile = 0;\r\nacpi_gbl_FADT.pstate_control = 0;\r\nacpi_gbl_FADT.cst_control = 0;\r\nacpi_gbl_FADT.boot_flags = 0;\r\n}\r\nacpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);\r\nfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\r\naddress32 = *ACPI_ADD_PTR(u32,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address32);\r\naddress64 = ACPI_ADD_PTR(struct acpi_generic_address,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address64);\r\nif (address64->address && address32 &&\r\n(address64->address != (u64)address32)) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"32/64X address mismatch in FADT/%s: "\r\n"0x%8.8X/0x%8.8X%8.8X, using 32",\r\nfadt_info_table[i].name, address32,\r\nACPI_FORMAT_UINT64(address64->\r\naddress)));\r\n}\r\nif (address32) {\r\nacpi_tb_init_generic_address(address64,\r\nACPI_ADR_SPACE_SYSTEM_IO,\r\n*ACPI_ADD_PTR(u8,\r\n&acpi_gbl_FADT,\r\nfadt_info_table\r\n[i].length),\r\n(u64) address32,\r\nfadt_info_table[i].name);\r\n}\r\n}\r\n}\r\nstatic void acpi_tb_validate_fadt(void)\r\n{\r\nchar *name;\r\nstruct acpi_generic_address *address64;\r\nu8 length;\r\nu32 i;\r\nif (acpi_gbl_FADT.facs &&\r\n(acpi_gbl_FADT.Xfacs != (u64)acpi_gbl_FADT.facs)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"32/64X FACS address mismatch in FADT - "\r\n"0x%8.8X/0x%8.8X%8.8X, using 32",\r\nacpi_gbl_FADT.facs,\r\nACPI_FORMAT_UINT64(acpi_gbl_FADT.Xfacs)));\r\nacpi_gbl_FADT.Xfacs = (u64)acpi_gbl_FADT.facs;\r\n}\r\nif (acpi_gbl_FADT.dsdt &&\r\n(acpi_gbl_FADT.Xdsdt != (u64)acpi_gbl_FADT.dsdt)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"32/64X DSDT address mismatch in FADT - "\r\n"0x%8.8X/0x%8.8X%8.8X, using 32",\r\nacpi_gbl_FADT.dsdt,\r\nACPI_FORMAT_UINT64(acpi_gbl_FADT.Xdsdt)));\r\nacpi_gbl_FADT.Xdsdt = (u64)acpi_gbl_FADT.dsdt;\r\n}\r\nif (acpi_gbl_reduced_hardware) {\r\nreturn;\r\n}\r\nfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\r\naddress64 = ACPI_ADD_PTR(struct acpi_generic_address,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address64);\r\nlength =\r\n*ACPI_ADD_PTR(u8, &acpi_gbl_FADT,\r\nfadt_info_table[i].length);\r\nname = fadt_info_table[i].name;\r\nif (address64->address &&\r\n(ACPI_MUL_8(length) <= ACPI_UINT8_MAX) &&\r\n(address64->bit_width != ACPI_MUL_8(length))) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"32/64X length mismatch in FADT/%s: %u/%u",\r\nname, ACPI_MUL_8(length),\r\naddress64->bit_width));\r\n}\r\nif (fadt_info_table[i].type & ACPI_FADT_REQUIRED) {\r\nif (!address64->address || !length) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Required FADT field %s has zero address and/or length: "\r\n"0x%8.8X%8.8X/0x%X",\r\nname,\r\nACPI_FORMAT_UINT64(address64->\r\naddress),\r\nlength));\r\n}\r\n} else if (fadt_info_table[i].type & ACPI_FADT_SEPARATE_LENGTH) {\r\nif ((address64->address && !length) ||\r\n(!address64->address && length)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"Optional FADT field %s has zero address or length: "\r\n"0x%8.8X%8.8X/0x%X",\r\nname,\r\nACPI_FORMAT_UINT64\r\n(address64->address),\r\nlength));\r\n}\r\n}\r\n}\r\n}\r\nstatic void acpi_tb_setup_fadt_registers(void)\r\n{\r\nstruct acpi_generic_address *target64;\r\nstruct acpi_generic_address *source64;\r\nu8 pm1_register_byte_width;\r\nu32 i;\r\nif (acpi_gbl_use_default_register_widths) {\r\nfor (i = 0; i < ACPI_FADT_INFO_ENTRIES; i++) {\r\ntarget64 =\r\nACPI_ADD_PTR(struct acpi_generic_address,\r\n&acpi_gbl_FADT,\r\nfadt_info_table[i].address64);\r\nif ((target64->address) &&\r\n(fadt_info_table[i].default_length > 0) &&\r\n(fadt_info_table[i].default_length !=\r\ntarget64->bit_width)) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"Invalid length for FADT/%s: %u, using default %u",\r\nfadt_info_table[i].name,\r\ntarget64->bit_width,\r\nfadt_info_table[i].\r\ndefault_length));\r\ntarget64->bit_width =\r\nfadt_info_table[i].default_length;\r\n}\r\n}\r\n}\r\npm1_register_byte_width = (u8)\r\nACPI_DIV_16(acpi_gbl_FADT.xpm1a_event_block.bit_width);\r\nfor (i = 0; i < ACPI_FADT_PM_INFO_ENTRIES; i++) {\r\nsource64 =\r\nACPI_ADD_PTR(struct acpi_generic_address, &acpi_gbl_FADT,\r\nfadt_pm_info_table[i].source);\r\nif (source64->address) {\r\nacpi_tb_init_generic_address(fadt_pm_info_table[i].\r\ntarget, source64->space_id,\r\npm1_register_byte_width,\r\nsource64->address +\r\n(fadt_pm_info_table[i].\r\nregister_num *\r\npm1_register_byte_width),\r\n"PmRegisters");\r\n}\r\n}\r\n}
