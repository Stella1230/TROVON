static inline u8 checksum(u8 * buffer, u32 length)\r\n{\r\nu8 sum = 0, *i = buffer;\r\nbuffer += length;\r\nfor (; i < buffer; sum += *(i++));\r\nreturn sum;\r\n}\r\nstatic unsigned long read_efi_systab( void )\r\n{\r\nchar buffer[80];\r\nunsigned long addr;\r\nFILE *f = fopen("/sys/firmware/efi/systab", "r");\r\nif (f) {\r\nwhile (fgets(buffer, 80, f)) {\r\nif (sscanf(buffer, "ACPI20=0x%lx", &addr) == 1)\r\nreturn addr;\r\n}\r\nfclose(f);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 *acpi_map_memory(unsigned long where, unsigned length)\r\n{\r\nunsigned long offset;\r\nu8 *there;\r\nint fd = open("/dev/mem", O_RDONLY);\r\nif (fd < 0) {\r\nfprintf(stderr, "acpi_os_map_memory: cannot open /dev/mem\n");\r\nexit(1);\r\n}\r\noffset = where % psz;\r\nthere = mmap(NULL, length + offset, PROT_READ, MAP_PRIVATE,\r\nfd, where - offset);\r\nclose(fd);\r\nif (there == MAP_FAILED) return 0;\r\nreturn (there + offset);\r\n}\r\nstatic void acpi_unmap_memory(u8 * there, unsigned length)\r\n{\r\nunsigned long offset = (unsigned long)there % psz;\r\nmunmap(there - offset, length + offset);\r\n}\r\nstatic struct acpi_table_header *acpi_map_table(unsigned long where, char *sig)\r\n{\r\nunsigned size;\r\nstruct acpi_table_header *tbl = (struct acpi_table_header *)\r\nacpi_map_memory(where, sizeof(struct acpi_table_header));\r\nif (!tbl || (sig && memcmp(sig, tbl->signature, 4))) return 0;\r\nsize = tbl->length;\r\nacpi_unmap_memory((u8 *) tbl, sizeof(struct acpi_table_header));\r\nreturn (struct acpi_table_header *)acpi_map_memory(where, size);\r\n}\r\nstatic void acpi_unmap_table(struct acpi_table_header *tbl)\r\n{\r\nacpi_unmap_memory((u8 *)tbl, tbl->length);\r\n}\r\nstatic struct acpi_rsdp_descriptor *acpi_scan_for_rsdp(u8 *begin, u32 length)\r\n{\r\nstruct acpi_rsdp_descriptor *rsdp;\r\nu8 *i, *end = begin + length;\r\nfor (i = begin; i < end; i += ACPI_RSDP_SCAN_STEP) {\r\nif (memcmp((char *)i, "RSD PTR ", 8)) continue;\r\nrsdp = (struct acpi_rsdp_descriptor *)i;\r\nif (!checksum((u8 *) rsdp, (rsdp->revision < 2) ?\r\nACPI_RSDP_CHECKSUM_LENGTH :\r\nACPI_RSDP_XCHECKSUM_LENGTH))\r\nreturn rsdp;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_show_data(int fd, u8 * data, int size)\r\n{\r\nchar buffer[256];\r\nint len;\r\nint i, remain = size;\r\nwhile (remain > 0) {\r\nlen = snprintf(buffer, 256, " %04x:", size - remain);\r\nfor (i = 0; i < 16 && i < remain; i++) {\r\nlen +=\r\nsnprintf(&buffer[len], 256 - len, " %02x", data[i]);\r\n}\r\nfor (; i < 16; i++) {\r\nlen += snprintf(&buffer[len], 256 - len, " ");\r\n}\r\nlen += snprintf(&buffer[len], 256 - len, " ");\r\nfor (i = 0; i < 16 && i < remain; i++) {\r\nbuffer[len++] = (isprint(data[i])) ? data[i] : '.';\r\n}\r\nbuffer[len++] = '\n';\r\nwrite(fd, buffer, len);\r\ndata += 16;\r\nremain -= 16;\r\n}\r\n}\r\nstatic void acpi_show_table(int fd, struct acpi_table_header *table, unsigned long addr)\r\n{\r\nchar buff[80];\r\nint len = snprintf(buff, 80, "%.4s @ %p\n", table->signature, (void *)addr);\r\nwrite(fd, buff, len);\r\nacpi_show_data(fd, (u8 *) table, table->length);\r\nbuff[0] = '\n';\r\nwrite(fd, buff, 1);\r\n}\r\nstatic void write_table(int fd, struct acpi_table_header *tbl, unsigned long addr)\r\n{\r\nstatic int select_done = 0;\r\nif (!select_sig[0]) {\r\nif (print) {\r\nacpi_show_table(fd, tbl, addr);\r\n} else {\r\nwrite(fd, tbl, tbl->length);\r\n}\r\n} else if (!select_done && !memcmp(select_sig, tbl->signature, 4)) {\r\nif (skip > 0) {\r\n--skip;\r\nreturn;\r\n}\r\nif (print) {\r\nacpi_show_table(fd, tbl, addr);\r\n} else {\r\nwrite(fd, tbl, tbl->length);\r\n}\r\nselect_done = 1;\r\n}\r\n}\r\nstatic void acpi_dump_FADT(int fd, struct acpi_table_header *tbl, unsigned long xaddr) {\r\nstruct acpi_fadt_descriptor x;\r\nunsigned long addr;\r\nsize_t len = sizeof(struct acpi_fadt_descriptor);\r\nif (len > tbl->length) len = tbl->length;\r\nmemcpy(&x, tbl, len);\r\nx.header.length = len;\r\nif (checksum((u8 *)tbl, len)) {\r\nfprintf(stderr, "Wrong checksum for FADT!\n");\r\n}\r\nif (x.header.length >= 148 && x.Xdsdt) {\r\naddr = (unsigned long)x.Xdsdt;\r\nif (connect) {\r\nx.Xdsdt = lseek(fd, 0, SEEK_CUR);\r\n}\r\n} else if (x.header.length >= 44 && x.dsdt) {\r\naddr = (unsigned long)x.dsdt;\r\nif (connect) {\r\nx.dsdt = lseek(fd, 0, SEEK_CUR);\r\n}\r\n} else {\r\nfprintf(stderr, "No DSDT in FADT!\n");\r\ngoto no_dsdt;\r\n}\r\ntbl = acpi_map_table(addr, DSDT_SIG);\r\nif (!tbl) goto no_dsdt;\r\nif (checksum((u8 *)tbl, tbl->length))\r\nfprintf(stderr, "Wrong checksum for DSDT!\n");\r\nwrite_table(fd, tbl, addr);\r\nacpi_unmap_table(tbl);\r\nno_dsdt:\r\nif (x.header.length >= 140 && x.xfirmware_ctrl) {\r\naddr = (unsigned long)x.xfirmware_ctrl;\r\nif (connect) {\r\nx.xfirmware_ctrl = lseek(fd, 0, SEEK_CUR);\r\n}\r\n} else if (x.header.length >= 40 && x.firmware_ctrl) {\r\naddr = (unsigned long)x.firmware_ctrl;\r\nif (connect) {\r\nx.firmware_ctrl = lseek(fd, 0, SEEK_CUR);\r\n}\r\n} else {\r\nfprintf(stderr, "No FACS in FADT!\n");\r\ngoto no_facs;\r\n}\r\ntbl = acpi_map_table(addr, FACS_SIG);\r\nif (!tbl) goto no_facs;\r\nwrite_table(fd, tbl, addr);\r\nacpi_unmap_table(tbl);\r\nno_facs:\r\nwrite_table(fd, (struct acpi_table_header *)&x, xaddr);\r\n}\r\nstatic int acpi_dump_SDT(int fd, struct acpi_rsdp_descriptor *rsdp)\r\n{\r\nstruct acpi_table_header *sdt, *tbl = 0;\r\nint xsdt = 1, i, num;\r\nchar *offset;\r\nunsigned long addr;\r\nif (rsdp->revision > 1 && rsdp->xsdt_physical_address) {\r\ntbl = acpi_map_table(rsdp->xsdt_physical_address, "XSDT");\r\n}\r\nif (!tbl && rsdp->rsdt_physical_address) {\r\nxsdt = 0;\r\ntbl = acpi_map_table(rsdp->rsdt_physical_address, "RSDT");\r\n}\r\nif (!tbl) return 0;\r\nsdt = malloc(tbl->length);\r\nmemcpy(sdt, tbl, tbl->length);\r\nacpi_unmap_table(tbl);\r\nif (checksum((u8 *)sdt, sdt->length))\r\nfprintf(stderr, "Wrong checksum for %s!\n", (xsdt)?"XSDT":"RSDT");\r\nnum = (sdt->length - sizeof(struct acpi_table_header))/((xsdt)?sizeof(u64):sizeof(u32));\r\noffset = (char *)sdt + sizeof(struct acpi_table_header);\r\nfor (i = 0; i < num; ++i, offset += ((xsdt) ? sizeof(u64) : sizeof(u32))) {\r\naddr = (xsdt) ? (unsigned long)(*(u64 *)offset):\r\n(unsigned long)(*(u32 *)offset);\r\nif (!addr) continue;\r\ntbl = acpi_map_table(addr, 0);\r\nif (!tbl) continue;\r\nif (!memcmp(tbl->signature, FADT_SIG, 4)) {\r\nacpi_dump_FADT(fd, tbl, addr);\r\n} else {\r\nif (checksum((u8 *)tbl, tbl->length))\r\nfprintf(stderr, "Wrong checksum for generic table!\n");\r\nwrite_table(fd, tbl, addr);\r\n}\r\nacpi_unmap_table(tbl);\r\nif (connect) {\r\nif (xsdt)\r\n(*(u64*)offset) = lseek(fd, 0, SEEK_CUR);\r\nelse\r\n(*(u32*)offset) = lseek(fd, 0, SEEK_CUR);\r\n}\r\n}\r\nif (xsdt) {\r\naddr = (unsigned long)rsdp->xsdt_physical_address;\r\nif (connect) {\r\nrsdp->xsdt_physical_address = lseek(fd, 0, SEEK_CUR);\r\n}\r\n} else {\r\naddr = (unsigned long)rsdp->rsdt_physical_address;\r\nif (connect) {\r\nrsdp->rsdt_physical_address = lseek(fd, 0, SEEK_CUR);\r\n}\r\n}\r\nwrite_table(fd, sdt, addr);\r\nfree (sdt);\r\nreturn 1;\r\n}\r\nstatic void acpi_dump_dynamic_SSDT(int fd)\r\n{\r\nstruct stat file_stat;\r\nchar filename[256], *ptr;\r\nDIR *tabledir;\r\nstruct dirent *entry;\r\nFILE *fp;\r\nint count, readcount, length;\r\nstruct acpi_table_header table_header, *ptable;\r\nif (stat(DYNAMIC_SSDT, &file_stat) == -1) {\r\nreturn;\r\n}\r\ntabledir = opendir(DYNAMIC_SSDT);\r\nif(!tabledir){\r\nreturn;\r\n}\r\nwhile ((entry = readdir(tabledir)) != 0){\r\nif (entry->d_name[0] == '.')\r\ncontinue;\r\nsprintf(filename, "%s/%s", DYNAMIC_SSDT, entry->d_name);\r\nfp = fopen(filename, "r");\r\nif (fp == NULL) {\r\nfprintf(stderr, "Can't open the file of %s\n",\r\nfilename);\r\ncontinue;\r\n}\r\ncount = fread(&table_header, 1, sizeof(struct acpi_table_header), fp);\r\nif (count < sizeof(table_header)) {\r\nfclose(fp);\r\ncontinue;\r\n}\r\nlength = table_header.length;\r\nptr = malloc(table_header.length);\r\nfseek(fp, 0, SEEK_SET);\r\nreadcount = 0;\r\nwhile(!feof(fp) && readcount < length) {\r\ncount = fread(ptr + readcount, 1, 256, fp);\r\nreadcount += count;\r\n}\r\nfclose(fp);\r\nptable = (struct acpi_table_header *) ptr;\r\nif (checksum((u8 *) ptable, ptable->length))\r\nfprintf(stderr, "Wrong checksum "\r\n"for dynamic SSDT table!\n");\r\nwrite_table(fd, ptable, 0);\r\nfree(ptr);\r\n}\r\nclosedir(tabledir);\r\nreturn;\r\n}\r\nstatic void usage(const char *progname)\r\n{\r\nputs("Usage:");\r\nprintf("%s [--addr 0x1234][--table DSDT][--output filename]"\r\n"[--binary][--length 0x456][--help]\n", progname);\r\nputs("\t--addr 0x1234 or -a 0x1234 -- look for tables at this physical address");\r\nputs("\t--table DSDT or -t DSDT -- only dump table with DSDT signature");\r\nputs("\t--output filename or -o filename -- redirect output from stdin to filename");\r\nputs("\t--binary or -b -- dump data in binary form rather than in hex-dump format");\r\nputs("\t--length 0x456 or -l 0x456 -- works only with --addr, dump physical memory"\r\n"\n\t\tregion without trying to understand it's contents");\r\nputs("\t--skip 2 or -s 2 -- skip 2 tables of the given name and output only 3rd one");\r\nputs("\t--help or -h -- this help message");\r\nexit(0);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint option_index, c, fd;\r\nu8 *raw;\r\nstruct acpi_rsdp_descriptor rsdpx, *x = 0;\r\nchar *filename = 0;\r\nchar buff[80];\r\nmemset(select_sig, 0, 4);\r\nprint = 1;\r\nconnect = 0;\r\naddr = length = 0;\r\nskip = 0;\r\nwhile (1) {\r\noption_index = 0;\r\nc = getopt_long(argc, argv, "a:t:o:bl:s:h",\r\nlong_options, &option_index);\r\nif (c == -1)\r\nbreak;\r\nswitch (c) {\r\ncase 0:\r\nswitch (option_index) {\r\ncase 0:\r\naddr = strtoul(optarg, (char **)NULL, 16);\r\nbreak;\r\ncase 1:\r\nmemcpy(select_sig, optarg, 4);\r\nbreak;\r\ncase 2:\r\nfilename = optarg;\r\nbreak;\r\ncase 3:\r\nprint = 0;\r\nbreak;\r\ncase 4:\r\nlength = strtoul(optarg, (char **)NULL, 16);\r\nbreak;\r\ncase 5:\r\nskip = strtoul(optarg, (char **)NULL, 10);\r\nbreak;\r\ncase 6:\r\nusage(argv[0]);\r\nexit(0);\r\n}\r\nbreak;\r\ncase 'a':\r\naddr = strtoul(optarg, (char **)NULL, 16);\r\nbreak;\r\ncase 't':\r\nmemcpy(select_sig, optarg, 4);\r\nbreak;\r\ncase 'o':\r\nfilename = optarg;\r\nbreak;\r\ncase 'b':\r\nprint = 0;\r\nbreak;\r\ncase 'l':\r\nlength = strtoul(optarg, (char **)NULL, 16);\r\nbreak;\r\ncase 's':\r\nskip = strtoul(optarg, (char **)NULL, 10);\r\nbreak;\r\ncase 'h':\r\nusage(argv[0]);\r\nexit(0);\r\ndefault:\r\nprintf("Unknown option!\n");\r\nusage(argv[0]);\r\nexit(0);\r\n}\r\n}\r\nfd = STDOUT_FILENO;\r\nif (filename) {\r\nfd = creat(filename, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\r\nif (fd < 0)\r\nreturn fd;\r\n}\r\nif (!select_sig[0] && !print) {\r\nconnect = 1;\r\n}\r\npsz = sysconf(_SC_PAGESIZE);\r\nif (length && addr) {\r\nif (!(raw = acpi_map_memory(addr, length)))\r\ngoto not_found;\r\nwrite(fd, raw, length);\r\nacpi_unmap_memory(raw, length);\r\nclose(fd);\r\nreturn 0;\r\n}\r\nlength = sizeof(struct acpi_rsdp_descriptor);\r\nif (!addr) {\r\naddr = read_efi_systab();\r\nif (!addr) {\r\naddr = ACPI_HI_RSDP_WINDOW_BASE;\r\nlength = ACPI_HI_RSDP_WINDOW_SIZE;\r\n}\r\n}\r\nif (!(raw = acpi_map_memory(addr, length)) ||\r\n!(x = acpi_scan_for_rsdp(raw, length)))\r\ngoto not_found;\r\nmemcpy(&rsdpx, x, sizeof(struct acpi_rsdp_descriptor));\r\nacpi_unmap_memory(raw, length);\r\nif (connect) {\r\nlseek(fd, sizeof(struct acpi_rsdp_descriptor), SEEK_SET);\r\n}\r\nif (!acpi_dump_SDT(fd, &rsdpx))\r\ngoto not_found;\r\nif (connect) {\r\nlseek(fd, 0, SEEK_SET);\r\nwrite(fd, x, (rsdpx.revision < 2) ?\r\nACPI_RSDP_CHECKSUM_LENGTH : ACPI_RSDP_XCHECKSUM_LENGTH);\r\n} else if (!select_sig[0] || !memcmp("RSD PTR ", select_sig, 4)) {\r\naddr += (long)x - (long)raw;\r\nlength = snprintf(buff, 80, "RSD PTR @ %p\n", (void *)addr);\r\nwrite(fd, buff, length);\r\nacpi_show_data(fd, (u8 *) & rsdpx, (rsdpx.revision < 2) ?\r\nACPI_RSDP_CHECKSUM_LENGTH : ACPI_RSDP_XCHECKSUM_LENGTH);\r\nbuff[0] = '\n';\r\nwrite(fd, buff, 1);\r\n}\r\nacpi_dump_dynamic_SSDT(fd);\r\nclose(fd);\r\nreturn 0;\r\nnot_found:\r\nclose(fd);\r\nfprintf(stderr, "ACPI tables were not found. If you know location "\r\n"of RSD PTR table (from dmesg, etc), "\r\n"supply it with either --addr or -a option\n");\r\nreturn 1;\r\n}
