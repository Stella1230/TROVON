void generic_close(int fd, void *unused)\r\n{\r\nclose(fd);\r\n}\r\nint generic_read(int fd, char *c_out, void *unused)\r\n{\r\nint n;\r\nn = read(fd, c_out, sizeof(*c_out));\r\nif (n > 0)\r\nreturn n;\r\nelse if (errno == EAGAIN)\r\nreturn 0;\r\nelse if (n == 0)\r\nreturn -EIO;\r\nreturn -errno;\r\n}\r\nint generic_write(int fd, const char *buf, int n, void *unused)\r\n{\r\nint err;\r\nerr = write(fd, buf, n);\r\nif (err > 0)\r\nreturn err;\r\nelse if (errno == EAGAIN)\r\nreturn 0;\r\nelse if (err == 0)\r\nreturn -EIO;\r\nreturn -errno;\r\n}\r\nint generic_window_size(int fd, void *unused, unsigned short *rows_out,\r\nunsigned short *cols_out)\r\n{\r\nstruct winsize size;\r\nint ret;\r\nif (ioctl(fd, TIOCGWINSZ, &size) < 0)\r\nreturn -errno;\r\nret = ((*rows_out != size.ws_row) || (*cols_out != size.ws_col));\r\n*rows_out = size.ws_row;\r\n*cols_out = size.ws_col;\r\nreturn ret;\r\n}\r\nvoid generic_free(void *data)\r\n{\r\nkfree(data);\r\n}\r\nint generic_console_write(int fd, const char *buf, int n)\r\n{\r\nsigset_t old, no_sigio;\r\nstruct termios save, new;\r\nint err;\r\nif (isatty(fd)) {\r\nsigemptyset(&no_sigio);\r\nsigaddset(&no_sigio, SIGIO);\r\nif (sigprocmask(SIG_BLOCK, &no_sigio, &old))\r\ngoto error;\r\nCATCH_EINTR(err = tcgetattr(fd, &save));\r\nif (err)\r\ngoto error;\r\nnew = save;\r\nnew.c_oflag |= OPOST;\r\nCATCH_EINTR(err = tcsetattr(fd, TCSAFLUSH, &new));\r\nif (err)\r\ngoto error;\r\n}\r\nerr = generic_write(fd, buf, n, NULL);\r\nif (isatty(fd)) {\r\nCATCH_EINTR(tcsetattr(fd, TCSAFLUSH, &save));\r\nsigprocmask(SIG_SETMASK, &old, NULL);\r\n}\r\nreturn err;\r\nerror:\r\nreturn -errno;\r\n}\r\nstatic void winch_handler(int sig)\r\n{\r\n}\r\nstatic int winch_thread(void *arg)\r\n{\r\nstruct winch_data *data = arg;\r\nsigset_t sigs;\r\nint pty_fd, pipe_fd;\r\nint count;\r\nchar c = 1;\r\npty_fd = data->pty_fd;\r\npipe_fd = data->pipe_fd;\r\ncount = write(pipe_fd, &c, sizeof(c));\r\nif (count != sizeof(c))\r\nprintk(UM_KERN_ERR "winch_thread : failed to write "\r\n"synchronization byte, err = %d\n", -count);\r\nsignal(SIGWINCH, winch_handler);\r\nsigfillset(&sigs);\r\nif (sigprocmask(SIG_SETMASK, &sigs, NULL) < 0) {\r\nprintk(UM_KERN_ERR "winch_thread : sigprocmask failed, "\r\n"errno = %d\n", errno);\r\nexit(1);\r\n}\r\nsigdelset(&sigs, SIGWINCH);\r\nif (setsid() < 0) {\r\nprintk(UM_KERN_ERR "winch_thread : setsid failed, errno = %d\n",\r\nerrno);\r\nexit(1);\r\n}\r\nif (ioctl(pty_fd, TIOCSCTTY, 0) < 0) {\r\nprintk(UM_KERN_ERR "winch_thread : TIOCSCTTY failed on "\r\n"fd %d err = %d\n", pty_fd, errno);\r\nexit(1);\r\n}\r\nif (tcsetpgrp(pty_fd, os_getpid()) < 0) {\r\nprintk(UM_KERN_ERR "winch_thread : tcsetpgrp failed on "\r\n"fd %d err = %d\n", pty_fd, errno);\r\nexit(1);\r\n}\r\ncount = read(pipe_fd, &c, sizeof(c));\r\nif (count != sizeof(c))\r\nprintk(UM_KERN_ERR "winch_thread : failed to read "\r\n"synchronization byte, err = %d\n", errno);\r\nwhile(1) {\r\nsigsuspend(&sigs);\r\ncount = write(pipe_fd, &c, sizeof(c));\r\nif (count != sizeof(c))\r\nprintk(UM_KERN_ERR "winch_thread : write failed, "\r\n"err = %d\n", errno);\r\n}\r\n}\r\nstatic int winch_tramp(int fd, struct tty_port *port, int *fd_out,\r\nunsigned long *stack_out)\r\n{\r\nstruct winch_data data;\r\nint fds[2], n, err;\r\nchar c;\r\nerr = os_pipe(fds, 1, 1);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "winch_tramp : os_pipe failed, err = %d\n",\r\n-err);\r\ngoto out;\r\n}\r\ndata = ((struct winch_data) { .pty_fd = fd,\r\n.pipe_fd = fds[1] } );\r\nerr = run_helper_thread(winch_thread, &data, CLONE_FILES, stack_out);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "fork of winch_thread failed - errno = %d\n",\r\n-err);\r\ngoto out_close;\r\n}\r\n*fd_out = fds[0];\r\nn = read(fds[0], &c, sizeof(c));\r\nif (n != sizeof(c)) {\r\nprintk(UM_KERN_ERR "winch_tramp : failed to read "\r\n"synchronization byte\n");\r\nprintk(UM_KERN_ERR "read failed, err = %d\n", errno);\r\nprintk(UM_KERN_ERR "fd %d will not support SIGWINCH\n", fd);\r\nerr = -EINVAL;\r\ngoto out_close;\r\n}\r\nif (os_set_fd_block(*fd_out, 0)) {\r\nprintk(UM_KERN_ERR "winch_tramp: failed to set thread_fd "\r\n"non-blocking.\n");\r\ngoto out_close;\r\n}\r\nreturn err;\r\nout_close:\r\nclose(fds[1]);\r\nclose(fds[0]);\r\nout:\r\nreturn err;\r\n}\r\nvoid register_winch(int fd, struct tty_port *port)\r\n{\r\nunsigned long stack;\r\nint pid, thread, count, thread_fd = -1;\r\nchar c = 1;\r\nif (!isatty(fd))\r\nreturn;\r\npid = tcgetpgrp(fd);\r\nif (is_skas_winch(pid, fd, port)) {\r\nregister_winch_irq(-1, fd, -1, port, 0);\r\nreturn;\r\n}\r\nif (pid == -1) {\r\nthread = winch_tramp(fd, port, &thread_fd, &stack);\r\nif (thread < 0)\r\nreturn;\r\nregister_winch_irq(thread_fd, fd, thread, port, stack);\r\ncount = write(thread_fd, &c, sizeof(c));\r\nif (count != sizeof(c))\r\nprintk(UM_KERN_ERR "register_winch : failed to write "\r\n"synchronization byte, err = %d\n", errno);\r\n}\r\n}
