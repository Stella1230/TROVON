struct vexpress_config_bridge *vexpress_config_bridge_register(\r\nstruct device_node *node,\r\nstruct vexpress_config_bridge_info *info)\r\n{\r\nstruct vexpress_config_bridge *bridge;\r\nint i;\r\npr_debug("Registering bridge '%s'\n", info->name);\r\nmutex_lock(&vexpress_config_bridges_mutex);\r\ni = find_first_zero_bit(vexpress_config_bridges_map,\r\nARRAY_SIZE(vexpress_config_bridges));\r\nif (i >= ARRAY_SIZE(vexpress_config_bridges)) {\r\npr_err("Can't register more bridges!\n");\r\nmutex_unlock(&vexpress_config_bridges_mutex);\r\nreturn NULL;\r\n}\r\n__set_bit(i, vexpress_config_bridges_map);\r\nbridge = &vexpress_config_bridges[i];\r\nbridge->node = node;\r\nbridge->info = info;\r\nINIT_LIST_HEAD(&bridge->transactions);\r\nspin_lock_init(&bridge->transactions_lock);\r\nmutex_unlock(&vexpress_config_bridges_mutex);\r\nreturn bridge;\r\n}\r\nvoid vexpress_config_bridge_unregister(struct vexpress_config_bridge *bridge)\r\n{\r\nstruct vexpress_config_bridge __bridge = *bridge;\r\nint i;\r\nmutex_lock(&vexpress_config_bridges_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(vexpress_config_bridges); i++)\r\nif (&vexpress_config_bridges[i] == bridge)\r\n__clear_bit(i, vexpress_config_bridges_map);\r\nmutex_unlock(&vexpress_config_bridges_mutex);\r\nWARN_ON(!list_empty(&__bridge.transactions));\r\nwhile (!list_empty(&__bridge.transactions))\r\ncpu_relax();\r\n}\r\nstruct vexpress_config_func *__vexpress_config_func_get(struct device *dev,\r\nstruct device_node *node)\r\n{\r\nstruct device_node *bridge_node;\r\nstruct vexpress_config_func *func;\r\nint i;\r\nif (WARN_ON(dev && node && dev->of_node != node))\r\nreturn NULL;\r\nif (dev && !node)\r\nnode = dev->of_node;\r\nfunc = kzalloc(sizeof(*func), GFP_KERNEL);\r\nif (!func)\r\nreturn NULL;\r\nbridge_node = of_node_get(node);\r\nwhile (bridge_node) {\r\nconst __be32 *prop = of_get_property(bridge_node,\r\n"arm,vexpress,config-bridge", NULL);\r\nif (prop) {\r\nbridge_node = of_find_node_by_phandle(\r\nbe32_to_cpup(prop));\r\nbreak;\r\n}\r\nbridge_node = of_get_next_parent(bridge_node);\r\n}\r\nmutex_lock(&vexpress_config_bridges_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(vexpress_config_bridges); i++) {\r\nstruct vexpress_config_bridge *bridge =\r\n&vexpress_config_bridges[i];\r\nif (test_bit(i, vexpress_config_bridges_map) &&\r\nbridge->node == bridge_node) {\r\nfunc->bridge = bridge;\r\nfunc->func = bridge->info->func_get(dev, node);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vexpress_config_bridges_mutex);\r\nif (!func->func) {\r\nof_node_put(node);\r\nkfree(func);\r\nreturn NULL;\r\n}\r\nreturn func;\r\n}\r\nvoid vexpress_config_func_put(struct vexpress_config_func *func)\r\n{\r\nfunc->bridge->info->func_put(func->func);\r\nof_node_put(func->bridge->node);\r\nkfree(func);\r\n}\r\nstatic void vexpress_config_dump_trans(const char *what,\r\nstruct vexpress_config_trans *trans)\r\n{\r\npr_debug("%s %s trans %p func 0x%p offset %d data 0x%x status %d\n",\r\nwhat, trans->write ? "write" : "read", trans,\r\ntrans->func->func, trans->offset,\r\ntrans->data ? *trans->data : 0, trans->status);\r\n}\r\nstatic int vexpress_config_schedule(struct vexpress_config_trans *trans)\r\n{\r\nint status;\r\nstruct vexpress_config_bridge *bridge = trans->func->bridge;\r\nunsigned long flags;\r\ninit_completion(&trans->completion);\r\ntrans->status = -EFAULT;\r\nspin_lock_irqsave(&bridge->transactions_lock, flags);\r\nif (list_empty(&bridge->transactions)) {\r\nvexpress_config_dump_trans("Executing", trans);\r\nstatus = bridge->info->func_exec(trans->func->func,\r\ntrans->offset, trans->write, trans->data);\r\n} else {\r\nvexpress_config_dump_trans("Queuing", trans);\r\nstatus = VEXPRESS_CONFIG_STATUS_WAIT;\r\n}\r\nswitch (status) {\r\ncase VEXPRESS_CONFIG_STATUS_DONE:\r\nvexpress_config_dump_trans("Finished", trans);\r\ntrans->status = status;\r\nbreak;\r\ncase VEXPRESS_CONFIG_STATUS_WAIT:\r\nlist_add_tail(&trans->list, &bridge->transactions);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&bridge->transactions_lock, flags);\r\nreturn status;\r\n}\r\nvoid vexpress_config_complete(struct vexpress_config_bridge *bridge,\r\nint status)\r\n{\r\nstruct vexpress_config_trans *trans;\r\nunsigned long flags;\r\nconst char *message = "Completed";\r\nspin_lock_irqsave(&bridge->transactions_lock, flags);\r\ntrans = list_first_entry(&bridge->transactions,\r\nstruct vexpress_config_trans, list);\r\ntrans->status = status;\r\ndo {\r\nvexpress_config_dump_trans(message, trans);\r\nlist_del(&trans->list);\r\ncomplete(&trans->completion);\r\nif (list_empty(&bridge->transactions))\r\nbreak;\r\ntrans = list_first_entry(&bridge->transactions,\r\nstruct vexpress_config_trans, list);\r\nvexpress_config_dump_trans("Executing pending", trans);\r\ntrans->status = bridge->info->func_exec(trans->func->func,\r\ntrans->offset, trans->write, trans->data);\r\nmessage = "Finished pending";\r\n} while (trans->status == VEXPRESS_CONFIG_STATUS_DONE);\r\nspin_unlock_irqrestore(&bridge->transactions_lock, flags);\r\n}\r\nint vexpress_config_wait(struct vexpress_config_trans *trans)\r\n{\r\nwait_for_completion(&trans->completion);\r\nreturn trans->status;\r\n}\r\nint vexpress_config_read(struct vexpress_config_func *func, int offset,\r\nu32 *data)\r\n{\r\nstruct vexpress_config_trans trans = {\r\n.func = func,\r\n.offset = offset,\r\n.write = false,\r\n.data = data,\r\n.status = 0,\r\n};\r\nint status = vexpress_config_schedule(&trans);\r\nif (status == VEXPRESS_CONFIG_STATUS_WAIT)\r\nstatus = vexpress_config_wait(&trans);\r\nreturn status;\r\n}\r\nint vexpress_config_write(struct vexpress_config_func *func, int offset,\r\nu32 data)\r\n{\r\nstruct vexpress_config_trans trans = {\r\n.func = func,\r\n.offset = offset,\r\n.write = true,\r\n.data = &data,\r\n.status = 0,\r\n};\r\nint status = vexpress_config_schedule(&trans);\r\nif (status == VEXPRESS_CONFIG_STATUS_WAIT)\r\nstatus = vexpress_config_wait(&trans);\r\nreturn status;\r\n}
