static struct usbhsh_request *usbhsh_ureq_alloc(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct usbhsh_request *ureq;\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nureq = kzalloc(sizeof(struct usbhsh_request), mem_flags);\r\nif (!ureq) {\r\ndev_err(dev, "ureq alloc fail\n");\r\nreturn NULL;\r\n}\r\nusbhs_pkt_init(&ureq->pkt);\r\nureq->urb = urb;\r\nusbhsh_urb_to_ureq(urb) = ureq;\r\nreturn ureq;\r\n}\r\nstatic void usbhsh_ureq_free(struct usbhsh_hpriv *hpriv,\r\nstruct usbhsh_request *ureq)\r\n{\r\nusbhsh_urb_to_ureq(ureq->urb) = NULL;\r\nureq->urb = NULL;\r\nkfree(ureq);\r\n}\r\nstatic int usbhsh_is_running(struct usbhsh_hpriv *hpriv)\r\n{\r\nreturn (hpriv->mod.irq_attch == NULL);\r\n}\r\nstatic void usbhsh_endpoint_sequence_save(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb,\r\nstruct usbhs_pkt *pkt)\r\n{\r\nint len = urb->actual_length;\r\nint maxp = usb_endpoint_maxp(&urb->ep->desc);\r\nint t = 0;\r\nif (usb_pipecontrol(urb->pipe))\r\nreturn;\r\nt = len / maxp;\r\nif (len % maxp)\r\nt++;\r\nif (pkt->zero)\r\nt++;\r\nt %= 2;\r\nif (t)\r\nusb_dotoggle(urb->dev,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe));\r\n}\r\nstatic int usbhsh_pipe_attach(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct usbhsh_ep *uep = usbhsh_ep_to_uep(urb->ep);\r\nstruct usbhsh_device *udev = usbhsh_device_get(hpriv, urb);\r\nstruct usbhs_pipe *pipe;\r\nstruct usb_endpoint_descriptor *desc = &urb->ep->desc;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nunsigned long flags;\r\nint dir_in_req = !!usb_pipein(urb->pipe);\r\nint is_dcp = usb_endpoint_xfer_control(desc);\r\nint i, dir_in;\r\nint ret = -EBUSY;\r\nusbhs_lock(priv, flags);\r\nif (usbhsh_uep_to_pipe(uep)) {\r\nret = 0;\r\ngoto usbhsh_pipe_attach_done;\r\n}\r\nusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\r\nif (!usbhs_pipe_type_is(pipe, usb_endpoint_type(desc)))\r\ncontinue;\r\nif (!is_dcp) {\r\ndir_in = !!usbhs_pipe_is_dir_in(pipe);\r\nif (0 != (dir_in - dir_in_req))\r\ncontinue;\r\n}\r\nif (usbhsh_pipe_to_uep(pipe))\r\ncontinue;\r\nusbhsh_uep_to_pipe(uep) = pipe;\r\nusbhsh_pipe_to_uep(pipe) = uep;\r\nusbhs_pipe_config_update(pipe,\r\nusbhsh_device_number(hpriv, udev),\r\nusb_endpoint_num(desc),\r\nusb_endpoint_maxp(desc));\r\ndev_dbg(dev, "%s [%d-%d(%s:%s)]\n", __func__,\r\nusbhsh_device_number(hpriv, udev),\r\nusb_endpoint_num(desc),\r\nusbhs_pipe_name(pipe),\r\ndir_in_req ? "in" : "out");\r\nret = 0;\r\nbreak;\r\n}\r\nusbhsh_pipe_attach_done:\r\nif (0 == ret)\r\nuep->counter++;\r\nusbhs_unlock(priv, flags);\r\nreturn ret;\r\n}\r\nstatic void usbhsh_pipe_detach(struct usbhsh_hpriv *hpriv,\r\nstruct usbhsh_ep *uep)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct usbhs_pipe *pipe;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nunsigned long flags;\r\nif (unlikely(!uep)) {\r\ndev_err(dev, "no uep\n");\r\nreturn;\r\n}\r\nusbhs_lock(priv, flags);\r\npipe = usbhsh_uep_to_pipe(uep);\r\nif (unlikely(!pipe)) {\r\ndev_err(dev, "uep doens't have pipe\n");\r\n} else if (1 == uep->counter--) {\r\nstruct usb_host_endpoint *ep = usbhsh_uep_to_ep(uep);\r\nstruct usbhsh_device *udev = usbhsh_uep_to_udev(uep);\r\nusbhsh_uep_to_pipe(uep) = NULL;\r\nusbhsh_pipe_to_uep(pipe) = NULL;\r\ndev_dbg(dev, "%s [%d-%d(%s)]\n", __func__,\r\nusbhsh_device_number(hpriv, udev),\r\nusb_endpoint_num(&ep->desc),\r\nusbhs_pipe_name(pipe));\r\n}\r\nusbhs_unlock(priv, flags);\r\n}\r\nstatic int usbhsh_endpoint_attach(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct usbhsh_device *udev = usbhsh_device_get(hpriv, urb);\r\nstruct usb_host_endpoint *ep = urb->ep;\r\nstruct usbhsh_ep *uep;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct usb_endpoint_descriptor *desc = &ep->desc;\r\nunsigned long flags;\r\nuep = kzalloc(sizeof(struct usbhsh_ep), mem_flags);\r\nif (!uep) {\r\ndev_err(dev, "usbhsh_ep alloc fail\n");\r\nreturn -ENOMEM;\r\n}\r\nusbhs_lock(priv, flags);\r\nuep->counter = 0;\r\nINIT_LIST_HEAD(&uep->ep_list);\r\nlist_add_tail(&uep->ep_list, &udev->ep_list_head);\r\nusbhsh_uep_to_udev(uep) = udev;\r\nusbhsh_uep_to_ep(uep) = ep;\r\nusbhsh_ep_to_uep(ep) = uep;\r\nusbhs_unlock(priv, flags);\r\ndev_dbg(dev, "%s [%d-%d]\n", __func__,\r\nusbhsh_device_number(hpriv, udev),\r\nusb_endpoint_num(desc));\r\nreturn 0;\r\n}\r\nstatic void usbhsh_endpoint_detach(struct usbhsh_hpriv *hpriv,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct usbhsh_ep *uep = usbhsh_ep_to_uep(ep);\r\nunsigned long flags;\r\nif (!uep)\r\nreturn;\r\ndev_dbg(dev, "%s [%d-%d]\n", __func__,\r\nusbhsh_device_number(hpriv, usbhsh_uep_to_udev(uep)),\r\nusb_endpoint_num(&ep->desc));\r\nif (usbhsh_uep_to_pipe(uep))\r\nusbhsh_pipe_detach(hpriv, uep);\r\nusbhs_lock(priv, flags);\r\nlist_del_init(&uep->ep_list);\r\nusbhsh_uep_to_udev(uep) = NULL;\r\nusbhsh_uep_to_ep(uep) = NULL;\r\nusbhsh_ep_to_uep(ep) = NULL;\r\nusbhs_unlock(priv, flags);\r\nkfree(uep);\r\n}\r\nstatic void usbhsh_endpoint_detach_all(struct usbhsh_hpriv *hpriv,\r\nstruct usbhsh_device *udev)\r\n{\r\nstruct usbhsh_ep *uep, *next;\r\nlist_for_each_entry_safe(uep, next, &udev->ep_list_head, ep_list)\r\nusbhsh_endpoint_detach(hpriv, usbhsh_uep_to_ep(uep));\r\n}\r\nstatic int usbhsh_connected_to_rhdev(struct usb_hcd *hcd,\r\nstruct usbhsh_device *udev)\r\n{\r\nstruct usb_device *usbv = usbhsh_udev_to_usbv(udev);\r\nreturn hcd->self.root_hub == usbv->parent;\r\n}\r\nstatic int usbhsh_device_has_endpoint(struct usbhsh_device *udev)\r\n{\r\nreturn !list_empty(&udev->ep_list_head);\r\n}\r\nstatic struct usbhsh_device *usbhsh_device_get(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb)\r\n{\r\nstruct usb_device *usbv = usbhsh_urb_to_usbv(urb);\r\nstruct usbhsh_device *udev = usbhsh_usbv_to_udev(usbv);\r\nif (!udev)\r\nreturn NULL;\r\nif (0 == usb_pipedevice(urb->pipe))\r\nreturn usbhsh_device0(hpriv);\r\nreturn udev;\r\n}\r\nstatic struct usbhsh_device *usbhsh_device_attach(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb)\r\n{\r\nstruct usbhsh_device *udev = NULL;\r\nstruct usbhsh_device *udev0 = usbhsh_device0(hpriv);\r\nstruct usbhsh_device *pos;\r\nstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\r\nstruct device *dev = usbhsh_hcd_to_dev(hcd);\r\nstruct usb_device *usbv = usbhsh_urb_to_usbv(urb);\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nunsigned long flags;\r\nu16 upphub, hubport;\r\nint i;\r\nif (0 != usb_pipedevice(urb->pipe)) {\r\ndev_err(dev, "%s fail: urb isn't pointing device0\n", __func__);\r\nreturn NULL;\r\n}\r\nusbhs_lock(priv, flags);\r\nusbhsh_for_each_udev(pos, hpriv, i) {\r\nif (usbhsh_udev_is_used(pos))\r\ncontinue;\r\nudev = pos;\r\nbreak;\r\n}\r\nif (udev) {\r\ndev_set_drvdata(&usbv->dev, udev);\r\nudev->usbv = usbv;\r\n}\r\nusbhs_unlock(priv, flags);\r\nif (!udev) {\r\ndev_err(dev, "no free usbhsh_device\n");\r\nreturn NULL;\r\n}\r\nif (usbhsh_device_has_endpoint(udev)) {\r\ndev_warn(dev, "udev have old endpoint\n");\r\nusbhsh_endpoint_detach_all(hpriv, udev);\r\n}\r\nif (usbhsh_device_has_endpoint(udev0)) {\r\ndev_warn(dev, "udev0 have old endpoint\n");\r\nusbhsh_endpoint_detach_all(hpriv, udev0);\r\n}\r\nINIT_LIST_HEAD(&udev0->ep_list_head);\r\nINIT_LIST_HEAD(&udev->ep_list_head);\r\nusbhs_set_device_config(priv,\r\n0, 0, 0, usbv->speed);\r\nupphub = 0;\r\nhubport = 0;\r\nif (!usbhsh_connected_to_rhdev(hcd, udev)) {\r\nstruct usbhsh_device *parent = usbhsh_device_parent(udev);\r\nupphub = usbhsh_device_number(hpriv, parent);\r\nhubport = usbhsh_device_hubport(udev);\r\ndev_dbg(dev, "%s connecte to Hub [%d:%d](%p)\n", __func__,\r\nupphub, hubport, parent);\r\n}\r\nusbhs_set_device_config(priv,\r\nusbhsh_device_number(hpriv, udev),\r\nupphub, hubport, usbv->speed);\r\ndev_dbg(dev, "%s [%d](%p)\n", __func__,\r\nusbhsh_device_number(hpriv, udev), udev);\r\nreturn udev;\r\n}\r\nstatic void usbhsh_device_detach(struct usbhsh_hpriv *hpriv,\r\nstruct usbhsh_device *udev)\r\n{\r\nstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhsh_hcd_to_dev(hcd);\r\nstruct usb_device *usbv = usbhsh_udev_to_usbv(udev);\r\nunsigned long flags;\r\ndev_dbg(dev, "%s [%d](%p)\n", __func__,\r\nusbhsh_device_number(hpriv, udev), udev);\r\nif (usbhsh_device_has_endpoint(udev)) {\r\ndev_warn(dev, "udev still have endpoint\n");\r\nusbhsh_endpoint_detach_all(hpriv, udev);\r\n}\r\nif (0 == usbhsh_device_number(hpriv, udev))\r\nreturn;\r\nusbhs_lock(priv, flags);\r\ndev_set_drvdata(&usbv->dev, NULL);\r\nudev->usbv = NULL;\r\nusbhs_unlock(priv, flags);\r\n}\r\nstatic void usbhsh_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)\r\n{\r\nstruct usbhsh_request *ureq = usbhsh_pkt_to_ureq(pkt);\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\r\nstruct urb *urb = ureq->urb;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint status = 0;\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (!urb) {\r\ndev_warn(dev, "pkt doesn't have urb\n");\r\nreturn;\r\n}\r\nif (!usbhsh_is_running(hpriv))\r\nstatus = -ESHUTDOWN;\r\nurb->actual_length = pkt->actual;\r\nusbhsh_endpoint_sequence_save(hpriv, urb, pkt);\r\nusbhsh_ureq_free(hpriv, ureq);\r\nusbhsh_pipe_detach(hpriv, usbhsh_ep_to_uep(urb->ep));\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\n}\r\nstatic int usbhsh_queue_push(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\r\nstruct usbhsh_ep *uep = usbhsh_ep_to_uep(urb->ep);\r\nstruct usbhs_pipe *pipe = usbhsh_uep_to_pipe(uep);\r\nstruct device *dev = usbhsh_hcd_to_dev(hcd);\r\nstruct usbhsh_request *ureq;\r\nvoid *buf;\r\nint len, sequence;\r\nif (usb_pipeisoc(urb->pipe)) {\r\ndev_err(dev, "pipe iso is not supported now\n");\r\nreturn -EIO;\r\n}\r\nureq = usbhsh_ureq_alloc(hpriv, urb, mem_flags);\r\nif (unlikely(!ureq)) {\r\ndev_err(dev, "ureq alloc fail\n");\r\nreturn -ENOMEM;\r\n}\r\nif (usb_pipein(urb->pipe))\r\npipe->handler = &usbhs_fifo_dma_pop_handler;\r\nelse\r\npipe->handler = &usbhs_fifo_dma_push_handler;\r\nbuf = (void *)(urb->transfer_buffer + urb->actual_length);\r\nlen = urb->transfer_buffer_length - urb->actual_length;\r\nsequence = usb_gettoggle(urb->dev,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe));\r\ndev_dbg(dev, "%s\n", __func__);\r\nusbhs_pkt_push(pipe, &ureq->pkt, usbhsh_queue_done,\r\nbuf, len, (urb->transfer_flags & URB_ZERO_PACKET),\r\nsequence);\r\nusbhs_pkt_start(pipe);\r\nreturn 0;\r\n}\r\nstatic void usbhsh_queue_force_pop(struct usbhs_priv *priv,\r\nstruct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_pkt *pkt;\r\nwhile (1) {\r\npkt = usbhs_pkt_pop(pipe, NULL);\r\nif (!pkt)\r\nbreak;\r\nusbhsh_queue_done(priv, pkt);\r\n}\r\n}\r\nstatic void usbhsh_queue_force_pop_all(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_pipe *pos;\r\nint i;\r\nusbhs_for_each_pipe_with_dcp(pos, priv, i)\r\nusbhsh_queue_force_pop(priv, pos);\r\n}\r\nstatic int usbhsh_is_request_address(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nreq = (struct usb_ctrlrequest *)urb->setup_packet;\r\nif ((DeviceOutRequest == req->bRequestType << 8) &&\r\n(USB_REQ_SET_ADDRESS == req->bRequest))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void usbhsh_setup_stage_packet_push(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb,\r\nstruct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct usb_ctrlrequest req;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ninit_completion(&hpriv->setup_ack_done);\r\nmemcpy(&req, urb->setup_packet, sizeof(struct usb_ctrlrequest));\r\nif (usbhsh_is_request_address(urb)) {\r\nstruct usb_device *usbv = usbhsh_urb_to_usbv(urb);\r\nstruct usbhsh_device *udev = usbhsh_usbv_to_udev(usbv);\r\nreq.wValue = usbhsh_device_number(hpriv, udev);\r\ndev_dbg(dev, "create new address - %d\n", req.wValue);\r\n}\r\nusbhs_usbreq_set_val(priv, &req);\r\nwait_for_completion(&hpriv->setup_ack_done);\r\ndev_dbg(dev, "%s done\n", __func__);\r\n}\r\nstatic void usbhsh_data_stage_packet_done(struct usbhs_priv *priv,\r\nstruct usbhs_pkt *pkt)\r\n{\r\nstruct usbhsh_request *ureq = usbhsh_pkt_to_ureq(pkt);\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nusbhsh_ureq_free(hpriv, ureq);\r\n}\r\nstatic int usbhsh_data_stage_packet_push(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb,\r\nstruct usbhs_pipe *pipe,\r\ngfp_t mem_flags)\r\n{\r\nstruct usbhsh_request *ureq;\r\nureq = usbhsh_ureq_alloc(hpriv, urb, mem_flags);\r\nif (unlikely(!ureq))\r\nreturn -ENOMEM;\r\nif (usb_pipein(urb->pipe))\r\npipe->handler = &usbhs_dcp_data_stage_in_handler;\r\nelse\r\npipe->handler = &usbhs_dcp_data_stage_out_handler;\r\nusbhs_pkt_push(pipe, &ureq->pkt,\r\nusbhsh_data_stage_packet_done,\r\nurb->transfer_buffer,\r\nurb->transfer_buffer_length,\r\n(urb->transfer_flags & URB_ZERO_PACKET),\r\n-1);\r\nreturn 0;\r\n}\r\nstatic int usbhsh_status_stage_packet_push(struct usbhsh_hpriv *hpriv,\r\nstruct urb *urb,\r\nstruct usbhs_pipe *pipe,\r\ngfp_t mem_flags)\r\n{\r\nstruct usbhsh_request *ureq;\r\nureq = usbhsh_ureq_alloc(hpriv, urb, mem_flags);\r\nif (unlikely(!ureq))\r\nreturn -ENOMEM;\r\nif (usb_pipein(urb->pipe))\r\npipe->handler = &usbhs_dcp_status_stage_in_handler;\r\nelse\r\npipe->handler = &usbhs_dcp_status_stage_out_handler;\r\nusbhs_pkt_push(pipe, &ureq->pkt,\r\nusbhsh_queue_done,\r\nNULL,\r\nurb->transfer_buffer_length,\r\n0, -1);\r\nreturn 0;\r\n}\r\nstatic int usbhsh_dcp_queue_push(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mflags)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\r\nstruct usbhsh_ep *uep = usbhsh_ep_to_uep(urb->ep);\r\nstruct usbhs_pipe *pipe = usbhsh_uep_to_pipe(uep);\r\nstruct device *dev = usbhsh_hcd_to_dev(hcd);\r\nint ret;\r\ndev_dbg(dev, "%s\n", __func__);\r\nusbhsh_setup_stage_packet_push(hpriv, urb, pipe);\r\nif (urb->transfer_buffer_length) {\r\nret = usbhsh_data_stage_packet_push(hpriv, urb, pipe, mflags);\r\nif (ret < 0) {\r\ndev_err(dev, "data stage failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = usbhsh_status_stage_packet_push(hpriv, urb, pipe, mflags);\r\nif (ret < 0) {\r\ndev_err(dev, "status stage failed\n");\r\nreturn ret;\r\n}\r\nusbhs_pkt_start(pipe);\r\nreturn 0;\r\n}\r\nstatic int usbhsh_dma_map_ctrl(struct usbhs_pkt *pkt, int map)\r\n{\r\nif (map) {\r\nstruct usbhsh_request *ureq = usbhsh_pkt_to_ureq(pkt);\r\nstruct urb *urb = ureq->urb;\r\nif (urb->num_sgs)\r\nreturn -EINVAL;\r\npkt->dma = urb->transfer_dma;\r\nif (!pkt->dma)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbhsh_host_start(struct usb_hcd *hcd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usbhsh_host_stop(struct usb_hcd *hcd)\r\n{\r\n}\r\nstatic int usbhsh_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct usb_host_endpoint *ep = urb->ep;\r\nstruct usbhsh_device *new_udev = NULL;\r\nint is_dir_in = usb_pipein(urb->pipe);\r\nint ret;\r\ndev_dbg(dev, "%s (%s)\n", __func__, is_dir_in ? "in" : "out");\r\nif (!usbhsh_is_running(hpriv)) {\r\nret = -EIO;\r\ndev_err(dev, "host is not running\n");\r\ngoto usbhsh_urb_enqueue_error_not_linked;\r\n}\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret) {\r\ndev_err(dev, "urb link failed\n");\r\ngoto usbhsh_urb_enqueue_error_not_linked;\r\n}\r\nif (!usbhsh_device_get(hpriv, urb)) {\r\nnew_udev = usbhsh_device_attach(hpriv, urb);\r\nif (!new_udev) {\r\nret = -EIO;\r\ndev_err(dev, "device attach failed\n");\r\ngoto usbhsh_urb_enqueue_error_not_linked;\r\n}\r\n}\r\nif (!usbhsh_ep_to_uep(ep)) {\r\nret = usbhsh_endpoint_attach(hpriv, urb, mem_flags);\r\nif (ret < 0) {\r\ndev_err(dev, "endpoint attach failed\n");\r\ngoto usbhsh_urb_enqueue_error_free_device;\r\n}\r\n}\r\nret = usbhsh_pipe_attach(hpriv, urb);\r\nif (ret < 0) {\r\ndev_err(dev, "pipe attach failed\n");\r\ngoto usbhsh_urb_enqueue_error_free_endpoint;\r\n}\r\nif (usb_pipecontrol(urb->pipe))\r\nret = usbhsh_dcp_queue_push(hcd, urb, mem_flags);\r\nelse\r\nret = usbhsh_queue_push(hcd, urb, mem_flags);\r\nreturn ret;\r\nusbhsh_urb_enqueue_error_free_endpoint:\r\nusbhsh_endpoint_detach(hpriv, ep);\r\nusbhsh_urb_enqueue_error_free_device:\r\nif (new_udev)\r\nusbhsh_device_detach(hpriv, new_udev);\r\nusbhsh_urb_enqueue_error_not_linked:\r\ndev_dbg(dev, "%s error\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int usbhsh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\r\nstruct usbhsh_request *ureq = usbhsh_urb_to_ureq(urb);\r\nif (ureq) {\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct usbhs_pkt *pkt = &ureq->pkt;\r\nusbhs_pkt_pop(pkt->pipe, pkt);\r\nusbhsh_queue_done(priv, pkt);\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbhsh_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct usbhsh_ep *uep = usbhsh_ep_to_uep(ep);\r\nstruct usbhsh_device *udev;\r\nstruct usbhsh_hpriv *hpriv;\r\nif (!uep)\r\nreturn;\r\nudev = usbhsh_uep_to_udev(uep);\r\nhpriv = usbhsh_hcd_to_hpriv(hcd);\r\nusbhsh_endpoint_detach(hpriv, ep);\r\nif (!usbhsh_device_has_endpoint(udev))\r\nusbhsh_device_detach(hpriv, udev);\r\n}\r\nstatic int usbhsh_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\r\nint roothub_id = 1;\r\nif (usbhsh_port_stat_get(hpriv) & 0xFFFF0000)\r\n*buf = (1 << roothub_id);\r\nelse\r\n*buf = 0;\r\nreturn !!(*buf);\r\n}\r\nstatic int __usbhsh_hub_hub_feature(struct usbhsh_hpriv *hpriv,\r\nu16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\ndev_dbg(dev, "%s :: C_HUB_xx\n", __func__);\r\nreturn 0;\r\n}\r\nreturn -EPIPE;\r\n}\r\nstatic int __usbhsh_hub_port_feature(struct usbhsh_hpriv *hpriv,\r\nu16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint enable = (typeReq == SetPortFeature);\r\nint speed, i, timeout = 128;\r\nint roothub_id = 1;\r\nif (wIndex > roothub_id || wLength != 0)\r\nreturn -EPIPE;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_POWER:\r\nusbhs_vbus_ctrl(priv, enable);\r\ndev_dbg(dev, "%s :: USB_PORT_FEAT_POWER\n", __func__);\r\nbreak;\r\ncase USB_PORT_FEAT_ENABLE:\r\ncase USB_PORT_FEAT_SUSPEND:\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_RESET:\r\ndev_dbg(dev, "%s :: USB_PORT_FEAT_xxx\n", __func__);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (!enable)\r\nbreak;\r\nusbhsh_port_stat_clear(hpriv,\r\nUSB_PORT_STAT_HIGH_SPEED |\r\nUSB_PORT_STAT_LOW_SPEED);\r\nusbhsh_queue_force_pop_all(priv);\r\nusbhs_bus_send_reset(priv);\r\nmsleep(20);\r\nusbhs_bus_send_sof_enable(priv);\r\nfor (i = 0; i < timeout ; i++) {\r\nswitch (usbhs_bus_get_speed(priv)) {\r\ncase USB_SPEED_LOW:\r\nspeed = USB_PORT_STAT_LOW_SPEED;\r\ngoto got_usb_bus_speed;\r\ncase USB_SPEED_HIGH:\r\nspeed = USB_PORT_STAT_HIGH_SPEED;\r\ngoto got_usb_bus_speed;\r\ncase USB_SPEED_FULL:\r\nspeed = 0;\r\ngoto got_usb_bus_speed;\r\n}\r\nmsleep(20);\r\n}\r\nreturn -EPIPE;\r\ngot_usb_bus_speed:\r\nusbhsh_port_stat_set(hpriv, speed);\r\nusbhsh_port_stat_set(hpriv, USB_PORT_STAT_ENABLE);\r\ndev_dbg(dev, "%s :: USB_PORT_FEAT_RESET (speed = %d)\n",\r\n__func__, speed);\r\nreturn 0;\r\ndefault:\r\nreturn -EPIPE;\r\n}\r\nif (enable)\r\nusbhsh_port_stat_set(hpriv, (1 << wValue));\r\nelse\r\nusbhsh_port_stat_clear(hpriv, (1 << wValue));\r\nreturn 0;\r\n}\r\nstatic int __usbhsh_hub_get_status(struct usbhsh_hpriv *hpriv,\r\nu16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct usb_hub_descriptor *desc = (struct usb_hub_descriptor *)buf;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint roothub_id = 1;\r\nswitch (typeReq) {\r\ncase GetHubStatus:\r\ndev_dbg(dev, "%s :: GetHubStatus\n", __func__);\r\n*buf = 0x00;\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex != roothub_id)\r\nreturn -EPIPE;\r\ndev_dbg(dev, "%s :: GetPortStatus\n", __func__);\r\n*(__le32 *)buf = cpu_to_le32(usbhsh_port_stat_get(hpriv));\r\nbreak;\r\ncase GetHubDescriptor:\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = roothub_id;\r\ndesc->bDescLength = 9;\r\ndesc->bPwrOn2PwrGood = 0;\r\ndesc->wHubCharacteristics = cpu_to_le16(0x0011);\r\ndesc->u.hs.DeviceRemovable[0] = (roothub_id << 1);\r\ndesc->u.hs.DeviceRemovable[1] = ~0;\r\ndev_dbg(dev, "%s :: GetHubDescriptor\n", __func__);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbhsh_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\r\nstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint ret = -EPIPE;\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\ncase SetHubFeature:\r\nret = __usbhsh_hub_hub_feature(hpriv, typeReq,\r\nwValue, wIndex, buf, wLength);\r\nbreak;\r\ncase SetPortFeature:\r\ncase ClearPortFeature:\r\nret = __usbhsh_hub_port_feature(hpriv, typeReq,\r\nwValue, wIndex, buf, wLength);\r\nbreak;\r\ncase GetHubStatus:\r\ncase GetPortStatus:\r\ncase GetHubDescriptor:\r\nret = __usbhsh_hub_get_status(hpriv, typeReq,\r\nwValue, wIndex, buf, wLength);\r\nbreak;\r\n}\r\ndev_dbg(dev, "typeReq = %x, ret = %d, port_stat = %x\n",\r\ntypeReq, ret, usbhsh_port_stat_get(hpriv));\r\nreturn ret;\r\n}\r\nstatic int usbhsh_bus_nop(struct usb_hcd *hcd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usbhsh_irq_attch(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndev_dbg(dev, "device attached\n");\r\nusbhsh_port_stat_set(hpriv, USB_PORT_STAT_CONNECTION);\r\nusbhsh_port_stat_set(hpriv, USB_PORT_STAT_C_CONNECTION << 16);\r\nhpriv->mod.irq_attch = NULL;\r\nusbhs_irq_callback_update(priv, &hpriv->mod);\r\nreturn 0;\r\n}\r\nstatic int usbhsh_irq_dtch(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndev_dbg(dev, "device detached\n");\r\nusbhsh_port_stat_clear(hpriv, USB_PORT_STAT_CONNECTION);\r\nusbhsh_port_stat_set(hpriv, USB_PORT_STAT_C_CONNECTION << 16);\r\nhpriv->mod.irq_attch = usbhsh_irq_attch;\r\nusbhs_irq_callback_update(priv, &hpriv->mod);\r\nusbhsh_queue_force_pop_all(priv);\r\nreturn 0;\r\n}\r\nstatic int usbhsh_irq_setup_ack(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndev_dbg(dev, "setup packet OK\n");\r\ncomplete(&hpriv->setup_ack_done);\r\nreturn 0;\r\n}\r\nstatic int usbhsh_irq_setup_err(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndev_dbg(dev, "setup packet Err\n");\r\ncomplete(&hpriv->setup_ack_done);\r\nreturn 0;\r\n}\r\nstatic void usbhsh_pipe_init_for_host(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct usbhs_pipe *pipe;\r\nu32 *pipe_type = usbhs_get_dparam(priv, pipe_type);\r\nint pipe_size = usbhs_get_dparam(priv, pipe_size);\r\nint old_type, dir_in, i;\r\nold_type = USB_ENDPOINT_XFER_CONTROL;\r\nfor (i = 0; i < pipe_size; i++) {\r\ndir_in = (pipe_type[i] == old_type);\r\nold_type = pipe_type[i];\r\nif (USB_ENDPOINT_XFER_CONTROL == pipe_type[i]) {\r\npipe = usbhs_dcp_malloc(priv);\r\nusbhsh_hpriv_to_dcp(hpriv) = pipe;\r\n} else {\r\npipe = usbhs_pipe_malloc(priv,\r\npipe_type[i],\r\ndir_in);\r\n}\r\npipe->mod_private = NULL;\r\n}\r\n}\r\nstatic int usbhsh_start(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\r\nstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint ret;\r\nret = usb_add_hcd(hcd, 0, 0);\r\nif (ret < 0)\r\nreturn 0;\r\nusbhs_pipe_init(priv,\r\nusbhsh_dma_map_ctrl);\r\nusbhs_fifo_init(priv);\r\nusbhsh_pipe_init_for_host(priv);\r\nusbhs_sys_host_ctrl(priv, 1);\r\nmod->irq_attch = usbhsh_irq_attch;\r\nmod->irq_dtch = usbhsh_irq_dtch;\r\nmod->irq_sack = usbhsh_irq_setup_ack;\r\nmod->irq_sign = usbhsh_irq_setup_err;\r\nusbhs_irq_callback_update(priv, mod);\r\ndev_dbg(dev, "start host\n");\r\nreturn ret;\r\n}\r\nstatic int usbhsh_stop(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\r\nstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nmod->irq_attch = NULL;\r\nmod->irq_dtch = NULL;\r\nmod->irq_sack = NULL;\r\nmod->irq_sign = NULL;\r\nusbhs_irq_callback_update(priv, mod);\r\nusb_remove_hcd(hcd);\r\nusbhs_sys_host_ctrl(priv, 0);\r\ndev_dbg(dev, "quit host\n");\r\nreturn 0;\r\n}\r\nint usbhs_mod_host_probe(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsh_hpriv *hpriv;\r\nstruct usb_hcd *hcd;\r\nstruct usbhsh_device *udev;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint i;\r\nhcd = usb_create_hcd(&usbhsh_driver, dev, usbhsh_hcd_name);\r\nif (!hcd) {\r\ndev_err(dev, "Failed to create hcd\n");\r\nreturn -ENOMEM;\r\n}\r\nhcd->has_tt = 1;\r\nhpriv = usbhsh_hcd_to_hpriv(hcd);\r\nusbhs_mod_register(priv, &hpriv->mod, USBHS_HOST);\r\nhpriv->mod.name = "host";\r\nhpriv->mod.start = usbhsh_start;\r\nhpriv->mod.stop = usbhsh_stop;\r\nusbhsh_port_stat_init(hpriv);\r\nusbhsh_for_each_udev_with_dev0(udev, hpriv, i) {\r\nudev->usbv = NULL;\r\nINIT_LIST_HEAD(&udev->ep_list_head);\r\n}\r\ndev_info(dev, "host probed\n");\r\nreturn 0;\r\n}\r\nint usbhs_mod_host_remove(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\r\nstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}
