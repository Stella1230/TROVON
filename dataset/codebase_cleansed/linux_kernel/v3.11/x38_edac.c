static int how_many_channel(struct pci_dev *pdev)\r\n{\r\nunsigned char capid0_8b;\r\npci_read_config_byte(pdev, X38_CAPID0 + 8, &capid0_8b);\r\nif (capid0_8b & 0x20) {\r\nedac_dbg(0, "In single channel mode\n");\r\nx38_channel_num = 1;\r\n} else {\r\nedac_dbg(0, "In dual channel mode\n");\r\nx38_channel_num = 2;\r\n}\r\nreturn x38_channel_num;\r\n}\r\nstatic unsigned long eccerrlog_syndrome(u64 log)\r\n{\r\nreturn (log & X38_ECCERRLOG_SYNDROME_BITS) >> 16;\r\n}\r\nstatic int eccerrlog_row(int channel, u64 log)\r\n{\r\nreturn ((log & X38_ECCERRLOG_RANK_BITS) >> 27) |\r\n(channel * X38_RANKS_PER_CHANNEL);\r\n}\r\nstatic void x38_clear_error_info(struct mem_ctl_info *mci)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_write_bits16(pdev, X38_ERRSTS, X38_ERRSTS_BITS,\r\nX38_ERRSTS_BITS);\r\n}\r\nstatic u64 x38_readq(const void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((u64)readl(addr + 4)) << 32);\r\n}\r\nstatic void x38_get_and_clear_error_info(struct mem_ctl_info *mci,\r\nstruct x38_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\nvoid __iomem *window = mci->pvt_info;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_word(pdev, X38_ERRSTS, &info->errsts);\r\nif (!(info->errsts & X38_ERRSTS_BITS))\r\nreturn;\r\ninfo->eccerrlog[0] = x38_readq(window + X38_C0ECCERRLOG);\r\nif (x38_channel_num == 2)\r\ninfo->eccerrlog[1] = x38_readq(window + X38_C1ECCERRLOG);\r\npci_read_config_word(pdev, X38_ERRSTS, &info->errsts2);\r\nif ((info->errsts ^ info->errsts2) & X38_ERRSTS_BITS) {\r\ninfo->eccerrlog[0] = x38_readq(window + X38_C0ECCERRLOG);\r\nif (x38_channel_num == 2)\r\ninfo->eccerrlog[1] =\r\nx38_readq(window + X38_C1ECCERRLOG);\r\n}\r\nx38_clear_error_info(mci);\r\n}\r\nstatic void x38_process_error_info(struct mem_ctl_info *mci,\r\nstruct x38_error_info *info)\r\n{\r\nint channel;\r\nu64 log;\r\nif (!(info->errsts & X38_ERRSTS_BITS))\r\nreturn;\r\nif ((info->errsts ^ info->errsts2) & X38_ERRSTS_BITS) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1,\r\n"UE overwrote CE", "");\r\ninfo->errsts = info->errsts2;\r\n}\r\nfor (channel = 0; channel < x38_channel_num; channel++) {\r\nlog = info->eccerrlog[channel];\r\nif (log & X38_ECCERRLOG_UE) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\n0, 0, 0,\r\neccerrlog_row(channel, log),\r\n-1, -1,\r\n"x38 UE", "");\r\n} else if (log & X38_ECCERRLOG_CE) {\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\n0, 0, eccerrlog_syndrome(log),\r\neccerrlog_row(channel, log),\r\n-1, -1,\r\n"x38 CE", "");\r\n}\r\n}\r\n}\r\nstatic void x38_check(struct mem_ctl_info *mci)\r\n{\r\nstruct x38_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\nx38_get_and_clear_error_info(mci, &info);\r\nx38_process_error_info(mci, &info);\r\n}\r\nvoid __iomem *x38_map_mchbar(struct pci_dev *pdev)\r\n{\r\nunion {\r\nu64 mchbar;\r\nstruct {\r\nu32 mchbar_low;\r\nu32 mchbar_high;\r\n};\r\n} u;\r\nvoid __iomem *window;\r\npci_read_config_dword(pdev, X38_MCHBAR_LOW, &u.mchbar_low);\r\npci_write_config_dword(pdev, X38_MCHBAR_LOW, u.mchbar_low | 0x1);\r\npci_read_config_dword(pdev, X38_MCHBAR_HIGH, &u.mchbar_high);\r\nu.mchbar &= X38_MCHBAR_MASK;\r\nif (u.mchbar != (resource_size_t)u.mchbar) {\r\nprintk(KERN_ERR\r\n"x38: mmio space beyond accessible range (0x%llx)\n",\r\n(unsigned long long)u.mchbar);\r\nreturn NULL;\r\n}\r\nwindow = ioremap_nocache(u.mchbar, X38_MMR_WINDOW_SIZE);\r\nif (!window)\r\nprintk(KERN_ERR "x38: cannot map mmio space at 0x%llx\n",\r\n(unsigned long long)u.mchbar);\r\nreturn window;\r\n}\r\nstatic void x38_get_drbs(void __iomem *window,\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL])\r\n{\r\nint i;\r\nfor (i = 0; i < X38_RANKS_PER_CHANNEL; i++) {\r\ndrbs[0][i] = readw(window + X38_C0DRB + 2*i) & X38_DRB_MASK;\r\ndrbs[1][i] = readw(window + X38_C1DRB + 2*i) & X38_DRB_MASK;\r\n}\r\n}\r\nstatic bool x38_is_stacked(struct pci_dev *pdev,\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL])\r\n{\r\nu16 tom;\r\npci_read_config_word(pdev, X38_TOM, &tom);\r\ntom &= X38_TOM_MASK;\r\nreturn drbs[X38_CHANNELS - 1][X38_RANKS_PER_CHANNEL - 1] == tom;\r\n}\r\nstatic unsigned long drb_to_nr_pages(\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL],\r\nbool stacked, int channel, int rank)\r\n{\r\nint n;\r\nn = drbs[channel][rank];\r\nif (rank > 0)\r\nn -= drbs[channel][rank - 1];\r\nif (stacked && (channel == 1) && drbs[channel][rank] ==\r\ndrbs[channel][X38_RANKS_PER_CHANNEL - 1]) {\r\nn -= drbs[0][X38_RANKS_PER_CHANNEL - 1];\r\n}\r\nn <<= (X38_DRB_SHIFT - PAGE_SHIFT);\r\nreturn n;\r\n}\r\nstatic int x38_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc;\r\nint i, j;\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct edac_mc_layer layers[2];\r\nu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL];\r\nbool stacked;\r\nvoid __iomem *window;\r\nedac_dbg(0, "MC:\n");\r\nwindow = x38_map_mchbar(pdev);\r\nif (!window)\r\nreturn -ENODEV;\r\nx38_get_drbs(window, drbs);\r\nhow_many_channel(pdev);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = X38_RANKS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = x38_channel_num;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\r\nif (!mci)\r\nreturn -ENOMEM;\r\nedac_dbg(3, "MC: init mci\n");\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = X38_REVISION;\r\nmci->ctl_name = x38_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = x38_check;\r\nmci->ctl_page_to_phys = NULL;\r\nmci->pvt_info = window;\r\nstacked = x38_is_stacked(pdev, drbs);\r\nfor (i = 0; i < mci->nr_csrows; i++) {\r\nunsigned long nr_pages;\r\nstruct csrow_info *csrow = mci->csrows[i];\r\nnr_pages = drb_to_nr_pages(drbs, stacked,\r\ni / X38_RANKS_PER_CHANNEL,\r\ni % X38_RANKS_PER_CHANNEL);\r\nif (nr_pages == 0)\r\ncontinue;\r\nfor (j = 0; j < x38_channel_num; j++) {\r\nstruct dimm_info *dimm = csrow->channels[j]->dimm;\r\ndimm->nr_pages = nr_pages / x38_channel_num;\r\ndimm->grain = nr_pages << PAGE_SHIFT;\r\ndimm->mtype = MEM_DDR2;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = EDAC_UNKNOWN;\r\n}\r\n}\r\nx38_clear_error_info(mci);\r\nrc = -ENODEV;\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "MC: failed edac_mc_add_mc()\n");\r\ngoto fail;\r\n}\r\nedac_dbg(3, "MC: success\n");\r\nreturn 0;\r\nfail:\r\niounmap(window);\r\nif (mci)\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nstatic int x38_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint rc;\r\nedac_dbg(0, "MC:\n");\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = x38_probe1(pdev, ent->driver_data);\r\nif (!mci_pdev)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void x38_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nedac_dbg(0, "\n");\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\niounmap(mci->pvt_info);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init x38_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(3, "MC:\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&x38_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (!mci_pdev) {\r\nx38_registered = 0;\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_X38_HB, NULL);\r\nif (!mci_pdev) {\r\nedac_dbg(0, "x38 pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = x38_init_one(mci_pdev, x38_pci_tbl);\r\nif (pci_rc < 0) {\r\nedac_dbg(0, "x38 init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&x38_driver);\r\nfail0:\r\nif (mci_pdev)\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit x38_exit(void)\r\n{\r\nedac_dbg(3, "MC:\n");\r\npci_unregister_driver(&x38_driver);\r\nif (!x38_registered) {\r\nx38_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\n}\r\n}
