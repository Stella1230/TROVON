static const struct psb_intel_limit_t *psb_intel_limit(struct drm_crtc *crtc)\r\n{\r\nconst struct psb_intel_limit_t *limit;\r\nif (psb_intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))\r\nlimit = &psb_intel_limits[INTEL_LIMIT_I9XX_LVDS];\r\nelse\r\nlimit = &psb_intel_limits[INTEL_LIMIT_I9XX_SDVO_DAC];\r\nreturn limit;\r\n}\r\nstatic void psb_intel_clock(int refclk, struct psb_intel_clock_t *clock)\r\n{\r\nclock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);\r\nclock->p = clock->p1 * clock->p2;\r\nclock->vco = refclk * clock->m / (clock->n + 2);\r\nclock->dot = clock->vco / clock->p;\r\n}\r\nbool psb_intel_pipe_has_type(struct drm_crtc *crtc, int type)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *l_entry;\r\nlist_for_each_entry(l_entry, &mode_config->connector_list, head) {\r\nif (l_entry->encoder && l_entry->encoder->crtc == crtc) {\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(l_entry);\r\nif (psb_intel_encoder->type == type)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool psb_intel_PLL_is_valid(struct drm_crtc *crtc,\r\nstruct psb_intel_clock_t *clock)\r\n{\r\nconst struct psb_intel_limit_t *limit = psb_intel_limit(crtc);\r\nif (clock->p1 < limit->p1.min || limit->p1.max < clock->p1)\r\nINTELPllInvalid("p1 out of range\n");\r\nif (clock->p < limit->p.min || limit->p.max < clock->p)\r\nINTELPllInvalid("p out of range\n");\r\nif (clock->m2 < limit->m2.min || limit->m2.max < clock->m2)\r\nINTELPllInvalid("m2 out of range\n");\r\nif (clock->m1 < limit->m1.min || limit->m1.max < clock->m1)\r\nINTELPllInvalid("m1 out of range\n");\r\nif (clock->m1 <= clock->m2)\r\nINTELPllInvalid("m1 <= m2\n");\r\nif (clock->m < limit->m.min || limit->m.max < clock->m)\r\nINTELPllInvalid("m out of range\n");\r\nif (clock->n < limit->n.min || limit->n.max < clock->n)\r\nINTELPllInvalid("n out of range\n");\r\nif (clock->vco < limit->vco.min || limit->vco.max < clock->vco)\r\nINTELPllInvalid("vco out of range\n");\r\nif (clock->dot < limit->dot.min || limit->dot.max < clock->dot)\r\nINTELPllInvalid("dot out of range\n");\r\nreturn true;\r\n}\r\nstatic bool psb_intel_find_best_PLL(struct drm_crtc *crtc, int target,\r\nint refclk,\r\nstruct psb_intel_clock_t *best_clock)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_clock_t clock;\r\nconst struct psb_intel_limit_t *limit = psb_intel_limit(crtc);\r\nint err = target;\r\nif (psb_intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&\r\n(REG_READ(LVDS) & LVDS_PORT_EN) != 0) {\r\nif ((REG_READ(LVDS) & LVDS_CLKB_POWER_MASK) ==\r\nLVDS_CLKB_POWER_UP)\r\nclock.p2 = limit->p2.p2_fast;\r\nelse\r\nclock.p2 = limit->p2.p2_slow;\r\n} else {\r\nif (target < limit->p2.dot_limit)\r\nclock.p2 = limit->p2.p2_slow;\r\nelse\r\nclock.p2 = limit->p2.p2_fast;\r\n}\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;\r\nclock.m1++) {\r\nfor (clock.m2 = limit->m2.min;\r\nclock.m2 < clock.m1 && clock.m2 <= limit->m2.max;\r\nclock.m2++) {\r\nfor (clock.n = limit->n.min;\r\nclock.n <= limit->n.max; clock.n++) {\r\nfor (clock.p1 = limit->p1.min;\r\nclock.p1 <= limit->p1.max;\r\nclock.p1++) {\r\nint this_err;\r\npsb_intel_clock(refclk, &clock);\r\nif (!psb_intel_PLL_is_valid\r\n(crtc, &clock))\r\ncontinue;\r\nthis_err = abs(clock.dot - target);\r\nif (this_err < err) {\r\n*best_clock = clock;\r\nerr = this_err;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn err != target;\r\n}\r\nvoid psb_intel_wait_for_vblank(struct drm_device *dev)\r\n{\r\nmdelay(20);\r\n}\r\nstatic int psb_intel_pipe_set_base(struct drm_crtc *crtc,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_framebuffer *psbfb = to_psb_fb(crtc->fb);\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nunsigned long start, offset;\r\nu32 dspcntr;\r\nint ret = 0;\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nif (!crtc->fb) {\r\ndev_dbg(dev->dev, "No FB bound\n");\r\ngoto psb_intel_pipe_cleaner;\r\n}\r\nret = psb_gtt_pin(psbfb->gtt);\r\nif (ret < 0)\r\ngoto psb_intel_pipe_set_base_exit;\r\nstart = psbfb->gtt->offset;\r\noffset = y * crtc->fb->pitches[0] + x * (crtc->fb->bits_per_pixel / 8);\r\nREG_WRITE(map->stride, crtc->fb->pitches[0]);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (crtc->fb->bits_per_pixel) {\r\ncase 8:\r\ndspcntr |= DISPPLANE_8BPP;\r\nbreak;\r\ncase 16:\r\nif (crtc->fb->depth == 15)\r\ndspcntr |= DISPPLANE_15_16BPP;\r\nelse\r\ndspcntr |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown color depth\n");\r\nret = -EINVAL;\r\npsb_gtt_unpin(psbfb->gtt);\r\ngoto psb_intel_pipe_set_base_exit;\r\n}\r\nREG_WRITE(map->cntr, dspcntr);\r\nREG_WRITE(map->base, start + offset);\r\nREG_READ(map->base);\r\npsb_intel_pipe_cleaner:\r\nif (old_fb)\r\npsb_gtt_unpin(to_psb_fb(old_fb)->gtt);\r\npsb_intel_pipe_set_base_exit:\r\ngma_power_end(dev);\r\nreturn ret;\r\n}\r\nstatic void psb_intel_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 temp;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) == 0) {\r\nREG_WRITE(map->dpll, temp);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) == 0)\r\nREG_WRITE(map->conf, temp | PIPEACONF_ENABLE);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE(map->cntr,\r\ntemp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\n}\r\npsb_intel_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_READ(map->base);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE(map->conf, temp & ~PIPEACONF_ENABLE);\r\nREG_READ(map->conf);\r\n}\r\npsb_intel_wait_for_vblank(dev);\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) != 0) {\r\nREG_WRITE(map->dpll, temp & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\n}\r\nudelay(150);\r\nbreak;\r\n}\r\nREG_WRITE(DSPARB, 0x3F3E);\r\n}\r\nstatic void psb_intel_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void psb_intel_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nvoid psb_intel_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nvoid psb_intel_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nvoid psb_intel_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct psb_intel_encoder *intel_encoder = to_psb_intel_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(intel_encoder);\r\n}\r\nstatic bool psb_intel_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int psb_intel_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int psb_intel_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint refclk;\r\nstruct psb_intel_clock_t clock;\r\nu32 dpll = 0, fp = 0, dspcntr, pipeconf;\r\nbool ok, is_sdvo = false;\r\nbool is_lvds = false, is_tv = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nif (crtc->fb == NULL) {\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\nreturn 0;\r\n}\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nif (!connector->encoder\r\n|| connector->encoder->crtc != crtc)\r\ncontinue;\r\nswitch (psb_intel_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\nis_lvds = true;\r\nbreak;\r\ncase INTEL_OUTPUT_SDVO:\r\nis_sdvo = true;\r\nbreak;\r\ncase INTEL_OUTPUT_TVOUT:\r\nis_tv = true;\r\nbreak;\r\n}\r\n}\r\nrefclk = 96000;\r\nok = psb_intel_find_best_PLL(crtc, adjusted_mode->clock, refclk,\r\n&clock);\r\nif (!ok) {\r\ndev_err(dev->dev, "Couldn't find PLL settings for mode!\n");\r\nreturn 0;\r\n}\r\nfp = clock.n << 16 | clock.m1 << 8 | clock.m2;\r\ndpll = DPLL_VGA_MODE_DIS;\r\nif (is_lvds) {\r\ndpll |= DPLLB_MODE_LVDS;\r\ndpll |= DPLL_DVO_HIGH_SPEED;\r\n} else\r\ndpll |= DPLLB_MODE_DAC_SERIAL;\r\nif (is_sdvo) {\r\nint sdvo_pixel_multiply =\r\nadjusted_mode->clock / mode->clock;\r\ndpll |= DPLL_DVO_HIGH_SPEED;\r\ndpll |=\r\n(sdvo_pixel_multiply - 1) << SDVO_MULTIPLIER_SHIFT_HIRES;\r\n}\r\ndpll |= (1 << (clock.p1 - 1)) << 16;\r\nswitch (clock.p2) {\r\ncase 5:\r\ndpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\r\nbreak;\r\ncase 7:\r\ndpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\r\nbreak;\r\ncase 10:\r\ndpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\r\nbreak;\r\ncase 14:\r\ndpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\r\nbreak;\r\n}\r\nif (is_tv) {\r\ndpll |= 3;\r\n}\r\ndpll |= PLL_REF_INPUT_DREFCLK;\r\npipeconf = REG_READ(map->conf);\r\ndspcntr = DISPPLANE_GAMMA_ENABLE;\r\nif (pipe == 0)\r\ndspcntr |= DISPPLANE_SEL_PIPE_A;\r\nelse\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\ndspcntr |= DISPLAY_PLANE_ENABLE;\r\npipeconf |= PIPEACONF_ENABLE;\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (psb_intel_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\ndrm_mode_debug_printmodeline(mode);\r\nif (dpll & DPLL_VCO_ENABLE) {\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\nif (is_lvds) {\r\nu32 lvds = REG_READ(LVDS);\r\nlvds &= ~LVDS_PIPEB_SELECT;\r\nif (pipe == 1)\r\nlvds |= LVDS_PIPEB_SELECT;\r\nlvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;\r\nlvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\r\nif (clock.p2 == 7)\r\nlvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\r\nREG_WRITE(LVDS, lvds);\r\nREG_READ(LVDS);\r\n}\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16));\r\nREG_WRITE(map->size,\r\n((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(map->pos, 0);\r\nREG_WRITE(map->src,\r\n((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\r\nREG_WRITE(map->conf, pipeconf);\r\nREG_READ(map->conf);\r\npsb_intel_wait_for_vblank(dev);\r\nREG_WRITE(map->cntr, dspcntr);\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\npsb_intel_wait_for_vblank(dev);\r\nreturn 0;\r\n}\r\nvoid psb_intel_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nconst struct psb_offset *map = &dev_priv->regmap[psb_intel_crtc->pipe];\r\nint palreg = map->palette;\r\nint i;\r\nif (!crtc->enabled)\r\nreturn;\r\nswitch (psb_intel_crtc->pipe) {\r\ncase 0:\r\ncase 1:\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Illegal Pipe Number.\n");\r\nreturn;\r\n}\r\nif (gma_power_begin(dev, false)) {\r\nfor (i = 0; i < 256; i++) {\r\nREG_WRITE(palreg + 4 * i,\r\n((psb_intel_crtc->lut_r[i] +\r\npsb_intel_crtc->lut_adj[i]) << 16) |\r\n((psb_intel_crtc->lut_g[i] +\r\npsb_intel_crtc->lut_adj[i]) << 8) |\r\n(psb_intel_crtc->lut_b[i] +\r\npsb_intel_crtc->lut_adj[i]));\r\n}\r\ngma_power_end(dev);\r\n} else {\r\nfor (i = 0; i < 256; i++) {\r\ndev_priv->regs.pipe[0].palette[i] =\r\n((psb_intel_crtc->lut_r[i] +\r\npsb_intel_crtc->lut_adj[i]) << 16) |\r\n((psb_intel_crtc->lut_g[i] +\r\npsb_intel_crtc->lut_adj[i]) << 8) |\r\n(psb_intel_crtc->lut_b[i] +\r\npsb_intel_crtc->lut_adj[i]);\r\n}\r\n}\r\n}\r\nstatic void psb_intel_crtc_save(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_intel_crtc_state *crtc_state = psb_intel_crtc->crtc_state;\r\nconst struct psb_offset *map = &dev_priv->regmap[psb_intel_crtc->pipe];\r\nuint32_t paletteReg;\r\nint i;\r\nif (!crtc_state) {\r\ndev_err(dev->dev, "No CRTC state found\n");\r\nreturn;\r\n}\r\ncrtc_state->saveDSPCNTR = REG_READ(map->cntr);\r\ncrtc_state->savePIPECONF = REG_READ(map->conf);\r\ncrtc_state->savePIPESRC = REG_READ(map->src);\r\ncrtc_state->saveFP0 = REG_READ(map->fp0);\r\ncrtc_state->saveFP1 = REG_READ(map->fp1);\r\ncrtc_state->saveDPLL = REG_READ(map->dpll);\r\ncrtc_state->saveHTOTAL = REG_READ(map->htotal);\r\ncrtc_state->saveHBLANK = REG_READ(map->hblank);\r\ncrtc_state->saveHSYNC = REG_READ(map->hsync);\r\ncrtc_state->saveVTOTAL = REG_READ(map->vtotal);\r\ncrtc_state->saveVBLANK = REG_READ(map->vblank);\r\ncrtc_state->saveVSYNC = REG_READ(map->vsync);\r\ncrtc_state->saveDSPSTRIDE = REG_READ(map->stride);\r\ncrtc_state->saveDSPSIZE = REG_READ(map->size);\r\ncrtc_state->saveDSPPOS = REG_READ(map->pos);\r\ncrtc_state->saveDSPBASE = REG_READ(map->base);\r\npaletteReg = map->palette;\r\nfor (i = 0; i < 256; ++i)\r\ncrtc_state->savePalette[i] = REG_READ(paletteReg + (i << 2));\r\n}\r\nstatic void psb_intel_crtc_restore(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_intel_crtc_state *crtc_state = psb_intel_crtc->crtc_state;\r\nconst struct psb_offset *map = &dev_priv->regmap[psb_intel_crtc->pipe];\r\nuint32_t paletteReg;\r\nint i;\r\nif (!crtc_state) {\r\ndev_err(dev->dev, "No crtc state\n");\r\nreturn;\r\n}\r\nif (crtc_state->saveDPLL & DPLL_VCO_ENABLE) {\r\nREG_WRITE(map->dpll,\r\ncrtc_state->saveDPLL & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\nREG_WRITE(map->fp0, crtc_state->saveFP0);\r\nREG_READ(map->fp0);\r\nREG_WRITE(map->fp1, crtc_state->saveFP1);\r\nREG_READ(map->fp1);\r\nREG_WRITE(map->dpll, crtc_state->saveDPLL);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->htotal, crtc_state->saveHTOTAL);\r\nREG_WRITE(map->hblank, crtc_state->saveHBLANK);\r\nREG_WRITE(map->hsync, crtc_state->saveHSYNC);\r\nREG_WRITE(map->vtotal, crtc_state->saveVTOTAL);\r\nREG_WRITE(map->vblank, crtc_state->saveVBLANK);\r\nREG_WRITE(map->vsync, crtc_state->saveVSYNC);\r\nREG_WRITE(map->stride, crtc_state->saveDSPSTRIDE);\r\nREG_WRITE(map->size, crtc_state->saveDSPSIZE);\r\nREG_WRITE(map->pos, crtc_state->saveDSPPOS);\r\nREG_WRITE(map->src, crtc_state->savePIPESRC);\r\nREG_WRITE(map->base, crtc_state->saveDSPBASE);\r\nREG_WRITE(map->conf, crtc_state->savePIPECONF);\r\npsb_intel_wait_for_vblank(dev);\r\nREG_WRITE(map->cntr, crtc_state->saveDSPCNTR);\r\nREG_WRITE(map->base, crtc_state->saveDSPBASE);\r\npsb_intel_wait_for_vblank(dev);\r\npaletteReg = map->palette;\r\nfor (i = 0; i < 256; ++i)\r\nREG_WRITE(paletteReg + (i << 2), crtc_state->savePalette[i]);\r\n}\r\nstatic int psb_intel_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width, uint32_t height)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nuint32_t control = (pipe == 0) ? CURACNTR : CURBCNTR;\r\nuint32_t base = (pipe == 0) ? CURABASE : CURBBASE;\r\nuint32_t temp;\r\nsize_t addr = 0;\r\nstruct gtt_range *gt;\r\nstruct gtt_range *cursor_gt = psb_intel_crtc->cursor_gt;\r\nstruct drm_gem_object *obj;\r\nvoid *tmp_dst, *tmp_src;\r\nint ret = 0, i, cursor_pages;\r\nif (!handle) {\r\ntemp = CURSOR_MODE_DISABLE;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(control, temp);\r\nREG_WRITE(base, 0);\r\ngma_power_end(dev);\r\n}\r\nif (psb_intel_crtc->cursor_obj) {\r\ngt = container_of(psb_intel_crtc->cursor_obj,\r\nstruct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(psb_intel_crtc->cursor_obj);\r\npsb_intel_crtc->cursor_obj = NULL;\r\n}\r\nreturn 0;\r\n}\r\nif (width != 64 || height != 64) {\r\ndev_dbg(dev->dev, "we currently only support 64x64 cursors\n");\r\nreturn -EINVAL;\r\n}\r\nobj = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nif (obj->size < width * height * 4) {\r\ndev_dbg(dev->dev, "buffer is to small\n");\r\nret = -ENOMEM;\r\ngoto unref_cursor;\r\n}\r\ngt = container_of(obj, struct gtt_range, gem);\r\nret = psb_gtt_pin(gt);\r\nif (ret) {\r\ndev_err(dev->dev, "Can not pin down handle 0x%x\n", handle);\r\ngoto unref_cursor;\r\n}\r\nif (dev_priv->ops->cursor_needs_phys) {\r\nif (cursor_gt == NULL) {\r\ndev_err(dev->dev, "No hardware cursor mem available");\r\nret = -ENOMEM;\r\ngoto unref_cursor;\r\n}\r\nif (gt->npage > 4)\r\ncursor_pages = 4;\r\nelse\r\ncursor_pages = gt->npage;\r\ntmp_dst = dev_priv->vram_addr + cursor_gt->offset;\r\nfor (i = 0; i < cursor_pages; i++) {\r\ntmp_src = kmap(gt->pages[i]);\r\nmemcpy(tmp_dst, tmp_src, PAGE_SIZE);\r\nkunmap(gt->pages[i]);\r\ntmp_dst += PAGE_SIZE;\r\n}\r\naddr = psb_intel_crtc->cursor_addr;\r\n} else {\r\naddr = gt->offset;\r\npsb_intel_crtc->cursor_addr = addr;\r\n}\r\ntemp = 0;\r\ntemp |= (pipe << 28);\r\ntemp |= CURSOR_MODE_64_ARGB_AX | MCURSOR_GAMMA_ENABLE;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(control, temp);\r\nREG_WRITE(base, addr);\r\ngma_power_end(dev);\r\n}\r\nif (psb_intel_crtc->cursor_obj) {\r\ngt = container_of(psb_intel_crtc->cursor_obj,\r\nstruct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(psb_intel_crtc->cursor_obj);\r\n}\r\npsb_intel_crtc->cursor_obj = obj;\r\nreturn ret;\r\nunref_cursor:\r\ndrm_gem_object_unreference(obj);\r\nreturn ret;\r\n}\r\nstatic int psb_intel_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nuint32_t temp = 0;\r\nuint32_t addr;\r\nif (x < 0) {\r\ntemp |= (CURSOR_POS_SIGN << CURSOR_X_SHIFT);\r\nx = -x;\r\n}\r\nif (y < 0) {\r\ntemp |= (CURSOR_POS_SIGN << CURSOR_Y_SHIFT);\r\ny = -y;\r\n}\r\ntemp |= ((x & CURSOR_POS_MASK) << CURSOR_X_SHIFT);\r\ntemp |= ((y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT);\r\naddr = psb_intel_crtc->cursor_addr;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE((pipe == 0) ? CURAPOS : CURBPOS, temp);\r\nREG_WRITE((pipe == 0) ? CURABASE : CURBBASE, addr);\r\ngma_power_end(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void psb_intel_crtc_gamma_set(struct drm_crtc *crtc, u16 *red,\r\nu16 *green, u16 *blue, uint32_t type, uint32_t size)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint i;\r\nif (size != 256)\r\nreturn;\r\nfor (i = 0; i < 256; i++) {\r\npsb_intel_crtc->lut_r[i] = red[i] >> 8;\r\npsb_intel_crtc->lut_g[i] = green[i] >> 8;\r\npsb_intel_crtc->lut_b[i] = blue[i] >> 8;\r\n}\r\npsb_intel_crtc_load_lut(crtc);\r\n}\r\nstatic int psb_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nint ret;\r\nstruct drm_device *dev = set->crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (!dev_priv->rpm_enabled)\r\nreturn drm_crtc_helper_set_config(set);\r\npm_runtime_forbid(&dev->pdev->dev);\r\nret = drm_crtc_helper_set_config(set);\r\npm_runtime_allow(&dev->pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int psb_intel_crtc_clock_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = psb_intel_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 dpll;\r\nu32 fp;\r\nstruct psb_intel_clock_t clock;\r\nbool is_lvds;\r\nstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\r\nif (gma_power_begin(dev, false)) {\r\ndpll = REG_READ(map->dpll);\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = REG_READ(map->fp0);\r\nelse\r\nfp = REG_READ(map->fp1);\r\nis_lvds = (pipe == 1) && (REG_READ(LVDS) & LVDS_PORT_EN);\r\ngma_power_end(dev);\r\n} else {\r\ndpll = p->dpll;\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = p->fp0;\r\nelse\r\nfp = p->fp1;\r\nis_lvds = (pipe == 1) && (dev_priv->regs.psb.saveLVDS &\r\nLVDS_PORT_EN);\r\n}\r\nclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\r\nclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\r\nclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\r\nif (is_lvds) {\r\nclock.p1 =\r\nffs((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT);\r\nclock.p2 = 14;\r\nif ((dpll & PLL_REF_INPUT_MASK) ==\r\nPLLB_REF_INPUT_SPREADSPECTRUMIN) {\r\npsb_intel_clock(66000, &clock);\r\n} else\r\npsb_intel_clock(48000, &clock);\r\n} else {\r\nif (dpll & PLL_P1_DIVIDE_BY_TWO)\r\nclock.p1 = 2;\r\nelse {\r\nclock.p1 =\r\n((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\r\n}\r\nif (dpll & PLL_P2_DIVIDE_BY_4)\r\nclock.p2 = 4;\r\nelse\r\nclock.p2 = 2;\r\npsb_intel_clock(48000, &clock);\r\n}\r\nreturn clock.dot;\r\n}\r\nstruct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nint pipe = psb_intel_crtc->pipe;\r\nstruct drm_display_mode *mode;\r\nint htot;\r\nint hsync;\r\nint vtot;\r\nint vsync;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nif (gma_power_begin(dev, false)) {\r\nhtot = REG_READ(map->htotal);\r\nhsync = REG_READ(map->hsync);\r\nvtot = REG_READ(map->vtotal);\r\nvsync = REG_READ(map->vsync);\r\ngma_power_end(dev);\r\n} else {\r\nhtot = p->htotal;\r\nhsync = p->hsync;\r\nvtot = p->vtotal;\r\nvsync = p->vsync;\r\n}\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn NULL;\r\nmode->clock = psb_intel_crtc_clock_get(dev, crtc);\r\nmode->hdisplay = (htot & 0xffff) + 1;\r\nmode->htotal = ((htot & 0xffff0000) >> 16) + 1;\r\nmode->hsync_start = (hsync & 0xffff) + 1;\r\nmode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;\r\nmode->vdisplay = (vtot & 0xffff) + 1;\r\nmode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;\r\nmode->vsync_start = (vsync & 0xffff) + 1;\r\nmode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nreturn mode;\r\n}\r\nstatic void psb_intel_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct gtt_range *gt;\r\nif (psb_intel_crtc->cursor_obj) {\r\ngt = container_of(psb_intel_crtc->cursor_obj,\r\nstruct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(psb_intel_crtc->cursor_obj);\r\npsb_intel_crtc->cursor_obj = NULL;\r\n}\r\nif (psb_intel_crtc->cursor_gt != NULL)\r\npsb_gtt_free_range(crtc->dev, psb_intel_crtc->cursor_gt);\r\nkfree(psb_intel_crtc->crtc_state);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(psb_intel_crtc);\r\n}\r\nstatic void psb_intel_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct gtt_range *gt;\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\nif (crtc->fb) {\r\ngt = to_psb_fb(crtc->fb)->gtt;\r\npsb_gtt_unpin(gt);\r\n}\r\n}\r\nstatic void psb_intel_cursor_init(struct drm_device *dev,\r\nstruct psb_intel_crtc *psb_intel_crtc)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 control[3] = { CURACNTR, CURBCNTR, CURCCNTR };\r\nu32 base[3] = { CURABASE, CURBBASE, CURCBASE };\r\nstruct gtt_range *cursor_gt;\r\nif (dev_priv->ops->cursor_needs_phys) {\r\ncursor_gt = psb_gtt_alloc_range(dev, 4 * PAGE_SIZE, "cursor", 1);\r\nif (!cursor_gt) {\r\npsb_intel_crtc->cursor_gt = NULL;\r\ngoto out;\r\n}\r\npsb_intel_crtc->cursor_gt = cursor_gt;\r\npsb_intel_crtc->cursor_addr = dev_priv->stolen_base +\r\ncursor_gt->offset;\r\n} else {\r\npsb_intel_crtc->cursor_gt = NULL;\r\n}\r\nout:\r\nREG_WRITE(control[psb_intel_crtc->pipe], 0);\r\nREG_WRITE(base[psb_intel_crtc->pipe], 0);\r\n}\r\nvoid psb_intel_crtc_init(struct drm_device *dev, int pipe,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_crtc *psb_intel_crtc;\r\nint i;\r\nuint16_t *r_base, *g_base, *b_base;\r\npsb_intel_crtc =\r\nkzalloc(sizeof(struct psb_intel_crtc) +\r\n(INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)),\r\nGFP_KERNEL);\r\nif (psb_intel_crtc == NULL)\r\nreturn;\r\npsb_intel_crtc->crtc_state =\r\nkzalloc(sizeof(struct psb_intel_crtc_state), GFP_KERNEL);\r\nif (!psb_intel_crtc->crtc_state) {\r\ndev_err(dev->dev, "Crtc state error: No memory\n");\r\nkfree(psb_intel_crtc);\r\nreturn;\r\n}\r\ndrm_crtc_init(dev, &psb_intel_crtc->base, dev_priv->ops->crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(&psb_intel_crtc->base, 256);\r\npsb_intel_crtc->pipe = pipe;\r\npsb_intel_crtc->plane = pipe;\r\nr_base = psb_intel_crtc->base.gamma_store;\r\ng_base = r_base + 256;\r\nb_base = g_base + 256;\r\nfor (i = 0; i < 256; i++) {\r\npsb_intel_crtc->lut_r[i] = i;\r\npsb_intel_crtc->lut_g[i] = i;\r\npsb_intel_crtc->lut_b[i] = i;\r\nr_base[i] = i << 8;\r\ng_base[i] = i << 8;\r\nb_base[i] = i << 8;\r\npsb_intel_crtc->lut_adj[i] = 0;\r\n}\r\npsb_intel_crtc->mode_dev = mode_dev;\r\npsb_intel_crtc->cursor_addr = 0;\r\ndrm_crtc_helper_add(&psb_intel_crtc->base,\r\ndev_priv->ops->crtc_helper);\r\npsb_intel_crtc->mode_set.crtc = &psb_intel_crtc->base;\r\nBUG_ON(pipe >= ARRAY_SIZE(dev_priv->plane_to_crtc_mapping) ||\r\ndev_priv->plane_to_crtc_mapping[psb_intel_crtc->plane] != NULL);\r\ndev_priv->plane_to_crtc_mapping[psb_intel_crtc->plane] =\r\n&psb_intel_crtc->base;\r\ndev_priv->pipe_to_crtc_mapping[psb_intel_crtc->pipe] =\r\n&psb_intel_crtc->base;\r\npsb_intel_crtc->mode_set.connectors =\r\n(struct drm_connector **) (psb_intel_crtc + 1);\r\npsb_intel_crtc->mode_set.num_connectors = 0;\r\npsb_intel_cursor_init(dev, psb_intel_crtc);\r\npsb_intel_crtc->active = true;\r\n}\r\nint psb_intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_psb_get_pipe_from_crtc_id_arg *pipe_from_crtc_id = data;\r\nstruct drm_mode_object *drmmode_obj;\r\nstruct psb_intel_crtc *crtc;\r\nif (!dev_priv) {\r\ndev_err(dev->dev, "called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\ndrmmode_obj = drm_mode_object_find(dev, pipe_from_crtc_id->crtc_id,\r\nDRM_MODE_OBJECT_CRTC);\r\nif (!drmmode_obj) {\r\ndev_err(dev->dev, "no such CRTC id\n");\r\nreturn -EINVAL;\r\n}\r\ncrtc = to_psb_intel_crtc(obj_to_crtc(drmmode_obj));\r\npipe_from_crtc_id->pipe = crtc->pipe;\r\nreturn 0;\r\n}\r\nstruct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_crtc *crtc = NULL;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nif (psb_intel_crtc->pipe == pipe)\r\nbreak;\r\n}\r\nreturn crtc;\r\n}\r\nint psb_intel_connector_clones(struct drm_device *dev, int type_mask)\r\n{\r\nint index_mask = 0;\r\nstruct drm_connector *connector;\r\nint entry = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list,\r\nhead) {\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nif (type_mask & (1 << psb_intel_encoder->type))\r\nindex_mask |= (1 << entry);\r\nentry++;\r\n}\r\nreturn index_mask;\r\n}\r\nstruct drm_encoder *psb_intel_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nreturn &psb_intel_encoder->base;\r\n}\r\nvoid psb_intel_connector_attach_encoder(struct psb_intel_connector *connector,\r\nstruct psb_intel_encoder *encoder)\r\n{\r\nconnector->encoder = encoder;\r\ndrm_mode_connector_attach_encoder(&connector->base,\r\n&encoder->base);\r\n}
