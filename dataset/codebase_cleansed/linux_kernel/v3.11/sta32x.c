static int sta32x_coefficient_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint numcoef = kcontrol->private_value >> 16;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = 3 * numcoef;\r\nreturn 0;\r\n}\r\nstatic int sta32x_coefficient_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint numcoef = kcontrol->private_value >> 16;\r\nint index = kcontrol->private_value & 0xffff;\r\nunsigned int cfud;\r\nint i;\r\ncfud = snd_soc_read(codec, STA32X_CFUD) & 0xf0;\r\nsnd_soc_write(codec, STA32X_CFUD, cfud);\r\nsnd_soc_write(codec, STA32X_CFADDR2, index);\r\nif (numcoef == 1)\r\nsnd_soc_write(codec, STA32X_CFUD, cfud | 0x04);\r\nelse if (numcoef == 5)\r\nsnd_soc_write(codec, STA32X_CFUD, cfud | 0x08);\r\nelse\r\nreturn -EINVAL;\r\nfor (i = 0; i < 3 * numcoef; i++)\r\nucontrol->value.bytes.data[i] =\r\nsnd_soc_read(codec, STA32X_B1CF1 + i);\r\nreturn 0;\r\n}\r\nstatic int sta32x_coefficient_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nint numcoef = kcontrol->private_value >> 16;\r\nint index = kcontrol->private_value & 0xffff;\r\nunsigned int cfud;\r\nint i;\r\ncfud = snd_soc_read(codec, STA32X_CFUD) & 0xf0;\r\nsnd_soc_write(codec, STA32X_CFUD, cfud);\r\nsnd_soc_write(codec, STA32X_CFADDR2, index);\r\nfor (i = 0; i < numcoef && (index + i < STA32X_COEF_COUNT); i++)\r\nsta32x->coef_shadow[index + i] =\r\n(ucontrol->value.bytes.data[3 * i] << 16)\r\n| (ucontrol->value.bytes.data[3 * i + 1] << 8)\r\n| (ucontrol->value.bytes.data[3 * i + 2]);\r\nfor (i = 0; i < 3 * numcoef; i++)\r\nsnd_soc_write(codec, STA32X_B1CF1 + i,\r\nucontrol->value.bytes.data[i]);\r\nif (numcoef == 1)\r\nsnd_soc_write(codec, STA32X_CFUD, cfud | 0x01);\r\nelse if (numcoef == 5)\r\nsnd_soc_write(codec, STA32X_CFUD, cfud | 0x02);\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sta32x_sync_coef_shadow(struct snd_soc_codec *codec)\r\n{\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int cfud;\r\nint i;\r\ncfud = snd_soc_read(codec, STA32X_CFUD) & 0xf0;\r\nfor (i = 0; i < STA32X_COEF_COUNT; i++) {\r\nsnd_soc_write(codec, STA32X_CFADDR2, i);\r\nsnd_soc_write(codec, STA32X_B1CF1,\r\n(sta32x->coef_shadow[i] >> 16) & 0xff);\r\nsnd_soc_write(codec, STA32X_B1CF2,\r\n(sta32x->coef_shadow[i] >> 8) & 0xff);\r\nsnd_soc_write(codec, STA32X_B1CF3,\r\n(sta32x->coef_shadow[i]) & 0xff);\r\nsnd_soc_write(codec, STA32X_CFUD, cfud);\r\nsnd_soc_write(codec, STA32X_CFUD, cfud | 0x01);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sta32x_cache_sync(struct snd_soc_codec *codec)\r\n{\r\nstruct sta32x_priv *sta32x = codec->control_data;\r\nunsigned int mute;\r\nint rc;\r\nmute = snd_soc_read(codec, STA32X_MMUTE);\r\nsnd_soc_write(codec, STA32X_MMUTE, mute | STA32X_MMUTE_MMUTE);\r\nsta32x_sync_coef_shadow(codec);\r\nrc = regcache_sync(sta32x->regmap);\r\nsnd_soc_write(codec, STA32X_MMUTE, mute);\r\nreturn rc;\r\n}\r\nstatic void sta32x_watchdog(struct work_struct *work)\r\n{\r\nstruct sta32x_priv *sta32x = container_of(work, struct sta32x_priv,\r\nwatchdog_work.work);\r\nstruct snd_soc_codec *codec = sta32x->codec;\r\nunsigned int confa, confa_cached;\r\nconfa_cached = snd_soc_read(codec, STA32X_CONFA);\r\nregcache_cache_bypass(sta32x->regmap, true);\r\nconfa = snd_soc_read(codec, STA32X_CONFA);\r\nregcache_cache_bypass(sta32x->regmap, false);\r\nif (confa != confa_cached) {\r\nregcache_mark_dirty(sta32x->regmap);\r\nsta32x_cache_sync(codec);\r\n}\r\nif (!sta32x->shutdown)\r\nschedule_delayed_work(&sta32x->watchdog_work,\r\nround_jiffies_relative(HZ));\r\n}\r\nstatic void sta32x_watchdog_start(struct sta32x_priv *sta32x)\r\n{\r\nif (sta32x->pdata->needs_esd_watchdog) {\r\nsta32x->shutdown = 0;\r\nschedule_delayed_work(&sta32x->watchdog_work,\r\nround_jiffies_relative(HZ));\r\n}\r\n}\r\nstatic void sta32x_watchdog_stop(struct sta32x_priv *sta32x)\r\n{\r\nif (sta32x->pdata->needs_esd_watchdog) {\r\nsta32x->shutdown = 1;\r\ncancel_delayed_work_sync(&sta32x->watchdog_work);\r\n}\r\n}\r\nstatic int sta32x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nint i, j, ir, fs;\r\nunsigned int rates = 0;\r\nunsigned int rate_min = -1;\r\nunsigned int rate_max = 0;\r\npr_debug("mclk=%u\n", freq);\r\nsta32x->mclk = freq;\r\nif (sta32x->mclk) {\r\nfor (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {\r\nir = interpolation_ratios[i].ir;\r\nfs = interpolation_ratios[i].fs;\r\nfor (j = 0; mclk_ratios[ir][j].ratio; j++) {\r\nif (mclk_ratios[ir][j].ratio * fs == freq) {\r\nrates |= snd_pcm_rate_to_rate_bit(fs);\r\nif (fs < rate_min)\r\nrate_min = fs;\r\nif (fs > rate_max)\r\nrate_max = fs;\r\nbreak;\r\n}\r\n}\r\n}\r\nrates &= ~SNDRV_PCM_RATE_KNOT;\r\nif (!rates) {\r\ndev_err(codec->dev, "could not find a valid sample rate\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nrates = STA32X_RATES;\r\nrate_min = 32000;\r\nrate_max = 192000;\r\n}\r\ncodec_dai->driver->playback.rates = rates;\r\ncodec_dai->driver->playback.rate_min = rate_min;\r\ncodec_dai->driver->playback.rate_max = rate_max;\r\nreturn 0;\r\n}\r\nstatic int sta32x_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nu8 confb = snd_soc_read(codec, STA32X_CONFB);\r\npr_debug("\n");\r\nconfb &= ~(STA32X_CONFB_C1IM | STA32X_CONFB_C2IM);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nsta32x->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nconfb |= STA32X_CONFB_C2IM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nconfb |= STA32X_CONFB_C1IM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, STA32X_CONFB, confb);\r\nreturn 0;\r\n}\r\nstatic int sta32x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rate;\r\nint i, mcs = -1, ir = -1;\r\nu8 confa, confb;\r\nrate = params_rate(params);\r\npr_debug("rate: %u\n", rate);\r\nfor (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++)\r\nif (interpolation_ratios[i].fs == rate) {\r\nir = interpolation_ratios[i].ir;\r\nbreak;\r\n}\r\nif (ir < 0)\r\nreturn -EINVAL;\r\nfor (i = 0; mclk_ratios[ir][i].ratio; i++)\r\nif (mclk_ratios[ir][i].ratio * rate == sta32x->mclk) {\r\nmcs = mclk_ratios[ir][i].mcs;\r\nbreak;\r\n}\r\nif (mcs < 0)\r\nreturn -EINVAL;\r\nconfa = snd_soc_read(codec, STA32X_CONFA);\r\nconfa &= ~(STA32X_CONFA_MCS_MASK | STA32X_CONFA_IR_MASK);\r\nconfa |= (ir << STA32X_CONFA_IR_SHIFT) | (mcs << STA32X_CONFA_MCS_SHIFT);\r\nconfb = snd_soc_read(codec, STA32X_CONFB);\r\nconfb &= ~(STA32X_CONFB_SAI_MASK | STA32X_CONFB_SAIFB);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S24_BE:\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\ncase SNDRV_PCM_FORMAT_S24_3BE:\r\npr_debug("24bit\n");\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ncase SNDRV_PCM_FORMAT_S32_BE:\r\npr_debug("24bit or 32bit\n");\r\nswitch (sta32x->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0x2;\r\nbreak;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ncase SNDRV_PCM_FORMAT_S20_3BE:\r\npr_debug("20bit\n");\r\nswitch (sta32x->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x4;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0x5;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0x6;\r\nbreak;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\ncase SNDRV_PCM_FORMAT_S18_3BE:\r\npr_debug("18bit\n");\r\nswitch (sta32x->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0x9;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0xa;\r\nbreak;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\npr_debug("16bit\n");\r\nswitch (sta32x->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0xd;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0xe;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, STA32X_CONFA, confa);\r\nsnd_soc_write(codec, STA32X_CONFB, confb);\r\nreturn 0;\r\n}\r\nstatic int sta32x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\npr_debug("level = %d\n", level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, STA32X_CONFF,\r\nSTA32X_CONFF_PWDN | STA32X_CONFF_EAPD,\r\nSTA32X_CONFF_PWDN | STA32X_CONFF_EAPD);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(sta32x->supplies),\r\nsta32x->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nsta32x_cache_sync(codec);\r\nsta32x_watchdog_start(sta32x);\r\n}\r\nsnd_soc_update_bits(codec, STA32X_CONFF,\r\nSTA32X_CONFF_PWDN | STA32X_CONFF_EAPD,\r\nSTA32X_CONFF_PWDN | STA32X_CONFF_EAPD);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, STA32X_CONFF,\r\nSTA32X_CONFF_PWDN | STA32X_CONFF_EAPD,\r\nSTA32X_CONFF_PWDN);\r\nmsleep(300);\r\nsta32x_watchdog_stop(sta32x);\r\nregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies),\r\nsta32x->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int sta32x_suspend(struct snd_soc_codec *codec)\r\n{\r\nsta32x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int sta32x_resume(struct snd_soc_codec *codec)\r\n{\r\nsta32x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int sta32x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nint i, ret = 0, thermal = 0;\r\nsta32x->codec = codec;\r\nsta32x->pdata = dev_get_platdata(codec->dev);\r\nret = regulator_bulk_enable(ARRAY_SIZE(sta32x->supplies),\r\nsta32x->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ncodec->control_data = sta32x->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to set cache I/O (ret=%i)\n", ret);\r\ngoto err;\r\n}\r\nregcache_cache_only(sta32x->regmap, true);\r\nsnd_soc_write(codec, STA32X_CONFC, 0xc2);\r\nsnd_soc_write(codec, STA32X_CONFE, 0xc2);\r\nsnd_soc_write(codec, STA32X_CONFF, 0x5c);\r\nsnd_soc_write(codec, STA32X_MMUTE, 0x10);\r\nsnd_soc_write(codec, STA32X_AUTO1, 0x60);\r\nsnd_soc_write(codec, STA32X_AUTO3, 0x00);\r\nsnd_soc_write(codec, STA32X_C3CFG, 0x40);\r\nregcache_cache_only(sta32x->regmap, false);\r\nif (!(sta32x->pdata->thermal_conf & STA32X_THERMAL_ADJUSTMENT_ENABLE))\r\nthermal |= STA32X_CONFA_TWAB;\r\nif (!(sta32x->pdata->thermal_conf & STA32X_THERMAL_RECOVERY_ENABLE))\r\nthermal |= STA32X_CONFA_TWRB;\r\nsnd_soc_update_bits(codec, STA32X_CONFA,\r\nSTA32X_CONFA_TWAB | STA32X_CONFA_TWRB,\r\nthermal);\r\nsnd_soc_update_bits(codec, STA32X_CONFF,\r\nSTA32X_CONFF_OCFG_MASK,\r\nsta32x->pdata->output_conf\r\n<< STA32X_CONFF_OCFG_SHIFT);\r\nsnd_soc_update_bits(codec, STA32X_C1CFG,\r\nSTA32X_CxCFG_OM_MASK,\r\nsta32x->pdata->ch1_output_mapping\r\n<< STA32X_CxCFG_OM_SHIFT);\r\nsnd_soc_update_bits(codec, STA32X_C2CFG,\r\nSTA32X_CxCFG_OM_MASK,\r\nsta32x->pdata->ch2_output_mapping\r\n<< STA32X_CxCFG_OM_SHIFT);\r\nsnd_soc_update_bits(codec, STA32X_C3CFG,\r\nSTA32X_CxCFG_OM_MASK,\r\nsta32x->pdata->ch3_output_mapping\r\n<< STA32X_CxCFG_OM_SHIFT);\r\nfor (i = 4; i <= 49; i += 5)\r\nsta32x->coef_shadow[i] = 0x400000;\r\nfor (i = 50; i <= 54; i++)\r\nsta32x->coef_shadow[i] = 0x7fffff;\r\nsta32x->coef_shadow[55] = 0x5a9df7;\r\nsta32x->coef_shadow[56] = 0x7fffff;\r\nsta32x->coef_shadow[59] = 0x7fffff;\r\nsta32x->coef_shadow[60] = 0x400000;\r\nsta32x->coef_shadow[61] = 0x400000;\r\nif (sta32x->pdata->needs_esd_watchdog)\r\nINIT_DELAYED_WORK(&sta32x->watchdog_work, sta32x_watchdog);\r\nsta32x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies), sta32x->supplies);\r\nreturn 0;\r\nerr:\r\nregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies), sta32x->supplies);\r\nreturn ret;\r\n}\r\nstatic int sta32x_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct sta32x_priv *sta32x = snd_soc_codec_get_drvdata(codec);\r\nsta32x_watchdog_stop(sta32x);\r\nsta32x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies), sta32x->supplies);\r\nreturn 0;\r\n}\r\nstatic bool sta32x_reg_is_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase STA32X_CONFA ... STA32X_L2ATRT:\r\ncase STA32X_MPCC1 ... STA32X_FDRC2:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int sta32x_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sta32x_priv *sta32x;\r\nint ret, i;\r\nsta32x = devm_kzalloc(&i2c->dev, sizeof(struct sta32x_priv),\r\nGFP_KERNEL);\r\nif (!sta32x)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(sta32x->supplies); i++)\r\nsta32x->supplies[i].supply = sta32x_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(sta32x->supplies),\r\nsta32x->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nsta32x->regmap = devm_regmap_init_i2c(i2c, &sta32x_regmap);\r\nif (IS_ERR(sta32x->regmap)) {\r\nret = PTR_ERR(sta32x->regmap);\r\ndev_err(&i2c->dev, "Failed to init regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, sta32x);\r\nret = snd_soc_register_codec(&i2c->dev, &sta32x_codec, &sta32x_dai, 1);\r\nif (ret != 0)\r\ndev_err(&i2c->dev, "Failed to register codec (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int sta32x_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
