static inline int old_item_num(int new_num, int affected_item_num, int mode)\r\n{\r\nif (mode == M_PASTE || mode == M_CUT || new_num < affected_item_num)\r\nreturn new_num;\r\nif (mode == M_INSERT) {\r\nRFALSE(new_num == 0,\r\n"vs-8005: for INSERT mode and item number of inserted item");\r\nreturn new_num - 1;\r\n}\r\nRFALSE(mode != M_DELETE,\r\n"vs-8010: old_item_num: mode must be M_DELETE (mode = \'%c\'",\r\nmode);\r\nreturn new_num + 1;\r\n}\r\nstatic void create_virtual_node(struct tree_balance *tb, int h)\r\n{\r\nstruct item_head *ih;\r\nstruct virtual_node *vn = tb->tb_vn;\r\nint new_num;\r\nstruct buffer_head *Sh;\r\nSh = PATH_H_PBUFFER(tb->tb_path, h);\r\nvn->vn_size =\r\nMAX_CHILD_SIZE(Sh) - B_FREE_SPACE(Sh) + tb->insert_size[h];\r\nif (h) {\r\nvn->vn_nr_item = (vn->vn_size - DC_SIZE) / (DC_SIZE + KEY_SIZE);\r\nreturn;\r\n}\r\nvn->vn_nr_item =\r\nB_NR_ITEMS(Sh) + ((vn->vn_mode == M_INSERT) ? 1 : 0) -\r\n((vn->vn_mode == M_DELETE) ? 1 : 0);\r\nvn->vn_vi = (struct virtual_item *)(tb->tb_vn + 1);\r\nmemset(vn->vn_vi, 0, vn->vn_nr_item * sizeof(struct virtual_item));\r\nvn->vn_free_ptr += vn->vn_nr_item * sizeof(struct virtual_item);\r\nih = B_N_PITEM_HEAD(Sh, 0);\r\nif (op_is_left_mergeable(&(ih->ih_key), Sh->b_size)\r\n&& (vn->vn_mode != M_DELETE || vn->vn_affected_item_num))\r\nvn->vn_vi[0].vi_type |= VI_TYPE_LEFT_MERGEABLE;\r\nfor (new_num = 0; new_num < vn->vn_nr_item; new_num++) {\r\nint j;\r\nstruct virtual_item *vi = vn->vn_vi + new_num;\r\nint is_affected =\r\n((new_num != vn->vn_affected_item_num) ? 0 : 1);\r\nif (is_affected && vn->vn_mode == M_INSERT)\r\ncontinue;\r\nj = old_item_num(new_num, vn->vn_affected_item_num,\r\nvn->vn_mode);\r\nvi->vi_item_len += ih_item_len(ih + j) + IH_SIZE;\r\nvi->vi_ih = ih + j;\r\nvi->vi_item = B_I_PITEM(Sh, ih + j);\r\nvi->vi_uarea = vn->vn_free_ptr;\r\nvn->vn_free_ptr +=\r\nop_create_vi(vn, vi, is_affected, tb->insert_size[0]);\r\nif (tb->vn_buf + tb->vn_buf_size < vn->vn_free_ptr)\r\nreiserfs_panic(tb->tb_sb, "vs-8030",\r\n"virtual node space consumed");\r\nif (!is_affected)\r\ncontinue;\r\nif (vn->vn_mode == M_PASTE || vn->vn_mode == M_CUT) {\r\nvn->vn_vi[new_num].vi_item_len += tb->insert_size[0];\r\nvi->vi_new_data = vn->vn_data;\r\n}\r\n}\r\nif (vn->vn_mode == M_INSERT) {\r\nstruct virtual_item *vi = vn->vn_vi + vn->vn_affected_item_num;\r\nRFALSE(vn->vn_ins_ih == NULL,\r\n"vs-8040: item header of inserted item is not specified");\r\nvi->vi_item_len = tb->insert_size[0];\r\nvi->vi_ih = vn->vn_ins_ih;\r\nvi->vi_item = vn->vn_data;\r\nvi->vi_uarea = vn->vn_free_ptr;\r\nop_create_vi(vn, vi, 0 ,\r\ntb->insert_size[0]);\r\n}\r\nif (tb->CFR[0]) {\r\nstruct reiserfs_key *key;\r\nkey = B_N_PDELIM_KEY(tb->CFR[0], tb->rkey[0]);\r\nif (op_is_left_mergeable(key, Sh->b_size)\r\n&& (vn->vn_mode != M_DELETE\r\n|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1))\r\nvn->vn_vi[vn->vn_nr_item - 1].vi_type |=\r\nVI_TYPE_RIGHT_MERGEABLE;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (op_is_left_mergeable(key, Sh->b_size) &&\r\n!(vn->vn_mode != M_DELETE\r\n|| vn->vn_affected_item_num != B_NR_ITEMS(Sh) - 1)) {\r\nif (!\r\n(B_NR_ITEMS(Sh) == 1\r\n&& is_direntry_le_ih(B_N_PITEM_HEAD(Sh, 0))\r\n&& I_ENTRY_COUNT(B_N_PITEM_HEAD(Sh, 0)) == 1)) {\r\nprint_block(Sh, 0, -1, -1);\r\nreiserfs_panic(tb->tb_sb, "vs-8045",\r\n"rdkey %k, affected item==%d "\r\n"(mode==%c) Must be %c",\r\nkey, vn->vn_affected_item_num,\r\nvn->vn_mode, M_DELETE);\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nstatic void check_left(struct tree_balance *tb, int h, int cur_free)\r\n{\r\nint i;\r\nstruct virtual_node *vn = tb->tb_vn;\r\nstruct virtual_item *vi;\r\nint d_size, ih_size;\r\nRFALSE(cur_free < 0, "vs-8050: cur_free (%d) < 0", cur_free);\r\nif (h > 0) {\r\ntb->lnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\r\nreturn;\r\n}\r\nif (!cur_free || !vn->vn_nr_item) {\r\ntb->lnum[h] = 0;\r\ntb->lbytes = -1;\r\nreturn;\r\n}\r\nRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\r\n"vs-8055: parent does not exist or invalid");\r\nvi = vn->vn_vi;\r\nif ((unsigned int)cur_free >=\r\n(vn->vn_size -\r\n((vi->vi_type & VI_TYPE_LEFT_MERGEABLE) ? IH_SIZE : 0))) {\r\nRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\r\n"vs-8055: invalid mode or balance condition failed");\r\ntb->lnum[0] = vn->vn_nr_item;\r\ntb->lbytes = -1;\r\nreturn;\r\n}\r\nd_size = 0, ih_size = IH_SIZE;\r\nif (vi->vi_type & VI_TYPE_LEFT_MERGEABLE)\r\nd_size = -((int)IH_SIZE), ih_size = 0;\r\ntb->lnum[0] = 0;\r\nfor (i = 0; i < vn->vn_nr_item;\r\ni++, ih_size = IH_SIZE, d_size = 0, vi++) {\r\nd_size += vi->vi_item_len;\r\nif (cur_free >= d_size) {\r\ncur_free -= d_size;\r\ntb->lnum[0]++;\r\ncontinue;\r\n}\r\nif (cur_free <= ih_size) {\r\ntb->lbytes = -1;\r\nreturn;\r\n}\r\ncur_free -= ih_size;\r\ntb->lbytes = op_check_left(vi, cur_free, 0, 0);\r\nif (tb->lbytes != -1)\r\ntb->lnum[0]++;\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void check_right(struct tree_balance *tb, int h, int cur_free)\r\n{\r\nint i;\r\nstruct virtual_node *vn = tb->tb_vn;\r\nstruct virtual_item *vi;\r\nint d_size, ih_size;\r\nRFALSE(cur_free < 0, "vs-8070: cur_free < 0");\r\nif (h > 0) {\r\ntb->rnum[h] = cur_free / (DC_SIZE + KEY_SIZE);\r\nreturn;\r\n}\r\nif (!cur_free || !vn->vn_nr_item) {\r\ntb->rnum[h] = 0;\r\ntb->rbytes = -1;\r\nreturn;\r\n}\r\nRFALSE(!PATH_H_PPARENT(tb->tb_path, 0),\r\n"vs-8075: parent does not exist or invalid");\r\nvi = vn->vn_vi + vn->vn_nr_item - 1;\r\nif ((unsigned int)cur_free >=\r\n(vn->vn_size -\r\n((vi->vi_type & VI_TYPE_RIGHT_MERGEABLE) ? IH_SIZE : 0))) {\r\nRFALSE(vn->vn_mode == M_INSERT || vn->vn_mode == M_PASTE,\r\n"vs-8080: invalid mode or balance condition failed");\r\ntb->rnum[h] = vn->vn_nr_item;\r\ntb->rbytes = -1;\r\nreturn;\r\n}\r\nd_size = 0, ih_size = IH_SIZE;\r\nif (vi->vi_type & VI_TYPE_RIGHT_MERGEABLE)\r\nd_size = -(int)IH_SIZE, ih_size = 0;\r\ntb->rnum[0] = 0;\r\nfor (i = vn->vn_nr_item - 1; i >= 0;\r\ni--, d_size = 0, ih_size = IH_SIZE, vi--) {\r\nd_size += vi->vi_item_len;\r\nif (cur_free >= d_size) {\r\ncur_free -= d_size;\r\ntb->rnum[0]++;\r\ncontinue;\r\n}\r\nif (cur_free <= ih_size) {\r\ntb->rbytes = -1;\r\nreturn;\r\n}\r\ncur_free -= ih_size;\r\ntb->rbytes = op_check_right(vi, cur_free);\r\nif (tb->rbytes != -1)\r\ntb->rnum[0]++;\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int get_num_ver(int mode, struct tree_balance *tb, int h,\r\nint from, int from_bytes,\r\nint to, int to_bytes, short *snum012, int flow)\r\n{\r\nint i;\r\nint cur_free;\r\nint units;\r\nstruct virtual_node *vn = tb->tb_vn;\r\nint total_node_size, max_node_size, current_item_size;\r\nint needed_nodes;\r\nint start_item,\r\nend_item,\r\nstart_bytes,\r\nend_bytes;\r\nint split_item_positions[2];\r\nsplit_item_positions[0] = -1;\r\nsplit_item_positions[1] = -1;\r\nRFALSE(tb->insert_size[h] < 0 || (mode != M_INSERT && mode != M_PASTE),\r\n"vs-8100: insert_size < 0 in overflow");\r\nmax_node_size = MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, h));\r\nsnum012[3] = -1;\r\nsnum012[4] = -1;\r\nif (h > 0) {\r\ni = ((to - from) * (KEY_SIZE + DC_SIZE) + DC_SIZE);\r\nif (i == max_node_size)\r\nreturn 1;\r\nreturn (i / max_node_size + 1);\r\n}\r\nneeded_nodes = 1;\r\ntotal_node_size = 0;\r\ncur_free = max_node_size;\r\nstart_item = from;\r\nstart_bytes = ((from_bytes != -1) ? from_bytes : 0);\r\nend_item = vn->vn_nr_item - to - 1;\r\nend_bytes = (to_bytes != -1) ? to_bytes : 0;\r\nfor (i = start_item; i <= end_item; i++) {\r\nstruct virtual_item *vi = vn->vn_vi + i;\r\nint skip_from_end = ((i == end_item) ? end_bytes : 0);\r\nRFALSE(needed_nodes > 3, "vs-8105: too many nodes are needed");\r\ncurrent_item_size = vi->vi_item_len;\r\ncurrent_item_size -=\r\nop_part_size(vi, 0 , start_bytes);\r\ncurrent_item_size -=\r\nop_part_size(vi, 1 , skip_from_end);\r\nif (total_node_size + current_item_size <= max_node_size) {\r\nsnum012[needed_nodes - 1]++;\r\ntotal_node_size += current_item_size;\r\nstart_bytes = 0;\r\ncontinue;\r\n}\r\nif (current_item_size > max_node_size) {\r\nRFALSE(is_direct_le_ih(vi->vi_ih),\r\n"vs-8110: "\r\n"direct item length is %d. It can not be longer than %d",\r\ncurrent_item_size, max_node_size);\r\nflow = 1;\r\n}\r\nif (!flow) {\r\nneeded_nodes++;\r\ni--;\r\ntotal_node_size = 0;\r\ncontinue;\r\n}\r\n{\r\nint free_space;\r\nfree_space = max_node_size - total_node_size - IH_SIZE;\r\nunits =\r\nop_check_left(vi, free_space, start_bytes,\r\nskip_from_end);\r\nif (units == -1) {\r\nneeded_nodes++, i--, total_node_size = 0;\r\ncontinue;\r\n}\r\n}\r\nstart_bytes += units;\r\nsnum012[needed_nodes - 1 + 3] = units;\r\nif (needed_nodes > 2)\r\nreiserfs_warning(tb->tb_sb, "vs-8111",\r\n"split_item_position is out of range");\r\nsnum012[needed_nodes - 1]++;\r\nsplit_item_positions[needed_nodes - 1] = i;\r\nneeded_nodes++;\r\nstart_item = i;\r\ni--;\r\ntotal_node_size = 0;\r\n}\r\nif (snum012[4] > 0) {\r\nint split_item_num;\r\nint bytes_to_r, bytes_to_l;\r\nint bytes_to_S1new;\r\nsplit_item_num = split_item_positions[1];\r\nbytes_to_l =\r\n((from == split_item_num\r\n&& from_bytes != -1) ? from_bytes : 0);\r\nbytes_to_r =\r\n((end_item == split_item_num\r\n&& end_bytes != -1) ? end_bytes : 0);\r\nbytes_to_S1new =\r\n((split_item_positions[0] ==\r\nsplit_item_positions[1]) ? snum012[3] : 0);\r\nsnum012[4] =\r\nop_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -\r\nbytes_to_r - bytes_to_l - bytes_to_S1new;\r\nif (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY &&\r\nvn->vn_vi[split_item_num].vi_index != TYPE_INDIRECT)\r\nreiserfs_warning(tb->tb_sb, "vs-8115",\r\n"not directory or indirect item");\r\n}\r\nif (snum012[3] > 0) {\r\nint split_item_num;\r\nint bytes_to_r, bytes_to_l;\r\nint bytes_to_S2new;\r\nsplit_item_num = split_item_positions[0];\r\nbytes_to_l =\r\n((from == split_item_num\r\n&& from_bytes != -1) ? from_bytes : 0);\r\nbytes_to_r =\r\n((end_item == split_item_num\r\n&& end_bytes != -1) ? end_bytes : 0);\r\nbytes_to_S2new =\r\n((split_item_positions[0] == split_item_positions[1]\r\n&& snum012[4] != -1) ? snum012[4] : 0);\r\nsnum012[3] =\r\nop_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -\r\nbytes_to_r - bytes_to_l - bytes_to_S2new;\r\n}\r\nreturn needed_nodes;\r\n}\r\nstatic void set_parameters(struct tree_balance *tb, int h, int lnum,\r\nint rnum, int blk_num, short *s012, int lb, int rb)\r\n{\r\ntb->lnum[h] = lnum;\r\ntb->rnum[h] = rnum;\r\ntb->blknum[h] = blk_num;\r\nif (h == 0) {\r\nif (s012 != NULL) {\r\ntb->s0num = *s012++,\r\ntb->s1num = *s012++, tb->s2num = *s012++;\r\ntb->s1bytes = *s012++;\r\ntb->s2bytes = *s012;\r\n}\r\ntb->lbytes = lb;\r\ntb->rbytes = rb;\r\n}\r\nPROC_INFO_ADD(tb->tb_sb, lnum[h], lnum);\r\nPROC_INFO_ADD(tb->tb_sb, rnum[h], rnum);\r\nPROC_INFO_ADD(tb->tb_sb, lbytes[h], lb);\r\nPROC_INFO_ADD(tb->tb_sb, rbytes[h], rb);\r\n}\r\nstatic int is_leaf_removable(struct tree_balance *tb)\r\n{\r\nstruct virtual_node *vn = tb->tb_vn;\r\nint to_left, to_right;\r\nint size;\r\nint remain_items;\r\nto_left = tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0);\r\nto_right = tb->rnum[0] - ((tb->rbytes != -1) ? 1 : 0);\r\nremain_items = vn->vn_nr_item;\r\nremain_items -= (to_left + to_right);\r\nif (remain_items < 1) {\r\nset_parameters(tb, 0, to_left, vn->vn_nr_item - to_left, 0,\r\nNULL, -1, -1);\r\nreturn 1;\r\n}\r\nif (remain_items > 1 || tb->lbytes == -1 || tb->rbytes == -1)\r\nreturn 0;\r\nsize = op_unit_num(&(vn->vn_vi[to_left]));\r\nif (tb->lbytes + tb->rbytes >= size) {\r\nset_parameters(tb, 0, to_left + 1, to_right + 1, 0, NULL,\r\ntb->lbytes, -1);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\r\n{\r\nstruct virtual_node *vn = tb->tb_vn;\r\nint ih_size;\r\nstruct buffer_head *S0;\r\nS0 = PATH_H_PBUFFER(tb->tb_path, 0);\r\nih_size = 0;\r\nif (vn->vn_nr_item) {\r\nif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\r\nih_size += IH_SIZE;\r\nif (vn->vn_vi[vn->vn_nr_item - 1].\r\nvi_type & VI_TYPE_RIGHT_MERGEABLE)\r\nih_size += IH_SIZE;\r\n} else {\r\nstruct item_head *ih;\r\nRFALSE(B_NR_ITEMS(S0) != 1,\r\n"vs-8125: item number must be 1: it is %d",\r\nB_NR_ITEMS(S0));\r\nih = B_N_PITEM_HEAD(S0, 0);\r\nif (tb->CFR[0]\r\n&& !comp_short_le_keys(&(ih->ih_key),\r\nB_N_PDELIM_KEY(tb->CFR[0],\r\ntb->rkey[0])))\r\nif (is_direntry_le_ih(ih)) {\r\nih_size = IH_SIZE;\r\nRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\r\n"vs-8130: first directory item can not be removed until directory is not empty");\r\n}\r\n}\r\nif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\r\nset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\r\nPROC_INFO_INC(tb->tb_sb, leaves_removable);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_buffers_in_tb(struct tree_balance *tb)\r\n{\r\nint i;\r\npathrelse(tb->tb_path);\r\nfor (i = 0; i < MAX_HEIGHT; i++) {\r\nbrelse(tb->L[i]);\r\nbrelse(tb->R[i]);\r\nbrelse(tb->FL[i]);\r\nbrelse(tb->FR[i]);\r\nbrelse(tb->CFL[i]);\r\nbrelse(tb->CFR[i]);\r\ntb->L[i] = NULL;\r\ntb->R[i] = NULL;\r\ntb->FL[i] = NULL;\r\ntb->FR[i] = NULL;\r\ntb->CFL[i] = NULL;\r\ntb->CFR[i] = NULL;\r\n}\r\n}\r\nstatic int get_empty_nodes(struct tree_balance *tb, int h)\r\n{\r\nstruct buffer_head *new_bh,\r\n*Sh = PATH_H_PBUFFER(tb->tb_path, h);\r\nb_blocknr_t *blocknr, blocknrs[MAX_AMOUNT_NEEDED] = { 0, };\r\nint counter, number_of_freeblk, amount_needed,\r\nretval = CARRY_ON;\r\nstruct super_block *sb = tb->tb_sb;\r\nfor (counter = 0, number_of_freeblk = tb->cur_blknum;\r\ncounter < h; counter++)\r\nnumber_of_freeblk -=\r\n(tb->blknum[counter]) ? (tb->blknum[counter] -\r\n1) : 0;\r\namount_needed = (Sh) ? (tb->blknum[h] - 1) : 1;\r\nif (amount_needed > number_of_freeblk)\r\namount_needed -= number_of_freeblk;\r\nelse\r\nreturn CARRY_ON;\r\nif (reiserfs_new_form_blocknrs(tb, blocknrs,\r\namount_needed) == NO_DISK_SPACE)\r\nreturn NO_DISK_SPACE;\r\nfor (blocknr = blocknrs, counter = 0;\r\ncounter < amount_needed; blocknr++, counter++) {\r\nRFALSE(!*blocknr,\r\n"PAP-8135: reiserfs_new_blocknrs failed when got new blocks");\r\nnew_bh = sb_getblk(sb, *blocknr);\r\nRFALSE(buffer_dirty(new_bh) ||\r\nbuffer_journaled(new_bh) ||\r\nbuffer_journal_dirty(new_bh),\r\n"PAP-8140: journaled or dirty buffer %b for the new block",\r\nnew_bh);\r\nRFALSE(tb->FEB[tb->cur_blknum],\r\n"PAP-8141: busy slot for new buffer");\r\nset_buffer_journal_new(new_bh);\r\ntb->FEB[tb->cur_blknum++] = new_bh;\r\n}\r\nif (retval == CARRY_ON && FILESYSTEM_CHANGED_TB(tb))\r\nretval = REPEAT_SEARCH;\r\nreturn retval;\r\n}\r\nstatic int get_lfree(struct tree_balance *tb, int h)\r\n{\r\nstruct buffer_head *l, *f;\r\nint order;\r\nif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\r\n(l = tb->FL[h]) == NULL)\r\nreturn 0;\r\nif (f == l)\r\norder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) - 1;\r\nelse {\r\norder = B_NR_ITEMS(l);\r\nf = l;\r\n}\r\nreturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\r\n}\r\nstatic int get_rfree(struct tree_balance *tb, int h)\r\n{\r\nstruct buffer_head *r, *f;\r\nint order;\r\nif ((f = PATH_H_PPARENT(tb->tb_path, h)) == NULL ||\r\n(r = tb->FR[h]) == NULL)\r\nreturn 0;\r\nif (f == r)\r\norder = PATH_H_B_ITEM_ORDER(tb->tb_path, h) + 1;\r\nelse {\r\norder = 0;\r\nf = r;\r\n}\r\nreturn (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f, order)));\r\n}\r\nstatic int is_left_neighbor_in_cache(struct tree_balance *tb, int h)\r\n{\r\nstruct buffer_head *father, *left;\r\nstruct super_block *sb = tb->tb_sb;\r\nb_blocknr_t left_neighbor_blocknr;\r\nint left_neighbor_position;\r\nif (!tb->FL[h])\r\nreturn 0;\r\nfather = PATH_H_PBUFFER(tb->tb_path, h + 1);\r\nRFALSE(!father ||\r\n!B_IS_IN_TREE(father) ||\r\n!B_IS_IN_TREE(tb->FL[h]) ||\r\n!buffer_uptodate(father) ||\r\n!buffer_uptodate(tb->FL[h]),\r\n"vs-8165: F[h] (%b) or FL[h] (%b) is invalid",\r\nfather, tb->FL[h]);\r\nleft_neighbor_position = (father == tb->FL[h]) ?\r\ntb->lkey[h] : B_NR_ITEMS(tb->FL[h]);\r\nleft_neighbor_blocknr =\r\nB_N_CHILD_NUM(tb->FL[h], left_neighbor_position);\r\nif ((left = sb_find_get_block(sb, left_neighbor_blocknr))) {\r\nRFALSE(buffer_uptodate(left) && !B_IS_IN_TREE(left),\r\n"vs-8170: left neighbor (%b %z) is not in the tree",\r\nleft, left);\r\nput_bh(left);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void decrement_key(struct cpu_key *key)\r\n{\r\nitem_ops[cpu_key_k_type(key)]->decrement_key(key);\r\n}\r\nstatic int get_far_parent(struct tree_balance *tb,\r\nint h,\r\nstruct buffer_head **pfather,\r\nstruct buffer_head **pcom_father, char c_lr_par)\r\n{\r\nstruct buffer_head *parent;\r\nINITIALIZE_PATH(s_path_to_neighbor_father);\r\nstruct treepath *path = tb->tb_path;\r\nstruct cpu_key s_lr_father_key;\r\nint counter,\r\nposition = INT_MAX,\r\nfirst_last_position = 0,\r\npath_offset = PATH_H_PATH_OFFSET(path, h);\r\ncounter = path_offset;\r\nRFALSE(counter < FIRST_PATH_ELEMENT_OFFSET,\r\n"PAP-8180: invalid path length");\r\nfor (; counter > FIRST_PATH_ELEMENT_OFFSET; counter--) {\r\nif (!B_IS_IN_TREE\r\n(parent = PATH_OFFSET_PBUFFER(path, counter - 1)))\r\nreturn REPEAT_SEARCH;\r\nif ((position =\r\nPATH_OFFSET_POSITION(path,\r\ncounter - 1)) >\r\nB_NR_ITEMS(parent))\r\nreturn REPEAT_SEARCH;\r\nif (B_N_CHILD_NUM(parent, position) !=\r\nPATH_OFFSET_PBUFFER(path, counter)->b_blocknr)\r\nreturn REPEAT_SEARCH;\r\nif (c_lr_par == RIGHT_PARENTS)\r\nfirst_last_position = B_NR_ITEMS(parent);\r\nif (position != first_last_position) {\r\n*pcom_father = parent;\r\nget_bh(*pcom_father);\r\nbreak;\r\n}\r\n}\r\nif (counter == FIRST_PATH_ELEMENT_OFFSET) {\r\nif (PATH_OFFSET_PBUFFER\r\n(tb->tb_path,\r\nFIRST_PATH_ELEMENT_OFFSET)->b_blocknr ==\r\nSB_ROOT_BLOCK(tb->tb_sb)) {\r\n*pfather = *pcom_father = NULL;\r\nreturn CARRY_ON;\r\n}\r\nreturn REPEAT_SEARCH;\r\n}\r\nRFALSE(B_LEVEL(*pcom_father) <= DISK_LEAF_NODE_LEVEL,\r\n"PAP-8185: (%b %z) level too small",\r\n*pcom_father, *pcom_father);\r\nif (buffer_locked(*pcom_father)) {\r\nreiserfs_write_unlock(tb->tb_sb);\r\n__wait_on_buffer(*pcom_father);\r\nreiserfs_write_lock(tb->tb_sb);\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\nbrelse(*pcom_father);\r\nreturn REPEAT_SEARCH;\r\n}\r\n}\r\nle_key2cpu_key(&s_lr_father_key,\r\nB_N_PDELIM_KEY(*pcom_father,\r\n(c_lr_par ==\r\nLEFT_PARENTS) ? (tb->lkey[h - 1] =\r\nposition -\r\n1) : (tb->rkey[h -\r\n1] =\r\nposition)));\r\nif (c_lr_par == LEFT_PARENTS)\r\ndecrement_key(&s_lr_father_key);\r\nif (search_by_key\r\n(tb->tb_sb, &s_lr_father_key, &s_path_to_neighbor_father,\r\nh + 1) == IO_ERROR)\r\nreturn IO_ERROR;\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\npathrelse(&s_path_to_neighbor_father);\r\nbrelse(*pcom_father);\r\nreturn REPEAT_SEARCH;\r\n}\r\n*pfather = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);\r\nRFALSE(B_LEVEL(*pfather) != h + 1,\r\n"PAP-8190: (%b %z) level too small", *pfather, *pfather);\r\nRFALSE(s_path_to_neighbor_father.path_length <\r\nFIRST_PATH_ELEMENT_OFFSET, "PAP-8192: path length is too small");\r\ns_path_to_neighbor_father.path_length--;\r\npathrelse(&s_path_to_neighbor_father);\r\nreturn CARRY_ON;\r\n}\r\nstatic int get_parents(struct tree_balance *tb, int h)\r\n{\r\nstruct treepath *path = tb->tb_path;\r\nint position,\r\nret,\r\npath_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\r\nstruct buffer_head *curf, *curcf;\r\nif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\r\nbrelse(tb->FL[h]);\r\nbrelse(tb->CFL[h]);\r\nbrelse(tb->FR[h]);\r\nbrelse(tb->CFR[h]);\r\ntb->FL[h] = NULL;\r\ntb->CFL[h] = NULL;\r\ntb->FR[h] = NULL;\r\ntb->CFR[h] = NULL;\r\nreturn CARRY_ON;\r\n}\r\nposition = PATH_OFFSET_POSITION(path, path_offset - 1);\r\nif (position) {\r\ncurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\r\ncurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\r\nget_bh(curf);\r\nget_bh(curf);\r\ntb->lkey[h] = position - 1;\r\n} else {\r\nif ((ret = get_far_parent(tb, h + 1, &curf,\r\n&curcf,\r\nLEFT_PARENTS)) != CARRY_ON)\r\nreturn ret;\r\n}\r\nbrelse(tb->FL[h]);\r\ntb->FL[h] = curf;\r\nbrelse(tb->CFL[h]);\r\ntb->CFL[h] = curcf;\r\nRFALSE((curf && !B_IS_IN_TREE(curf)) ||\r\n(curcf && !B_IS_IN_TREE(curcf)),\r\n"PAP-8195: FL (%b) or CFL (%b) is invalid", curf, curcf);\r\nif (position == B_NR_ITEMS(PATH_H_PBUFFER(path, h + 1))) {\r\nif ((ret =\r\nget_far_parent(tb, h + 1, &curf, &curcf,\r\nRIGHT_PARENTS)) != CARRY_ON)\r\nreturn ret;\r\n} else {\r\ncurf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\r\ncurcf = PATH_OFFSET_PBUFFER(path, path_offset - 1);\r\nget_bh(curf);\r\nget_bh(curf);\r\ntb->rkey[h] = position;\r\n}\r\nbrelse(tb->FR[h]);\r\ntb->FR[h] = curf;\r\nbrelse(tb->CFR[h]);\r\ntb->CFR[h] = curcf;\r\nRFALSE((curf && !B_IS_IN_TREE(curf)) ||\r\n(curcf && !B_IS_IN_TREE(curcf)),\r\n"PAP-8205: FR (%b) or CFR (%b) is invalid", curf, curcf);\r\nreturn CARRY_ON;\r\n}\r\nstatic inline int can_node_be_removed(int mode, int lfree, int sfree, int rfree,\r\nstruct tree_balance *tb, int h)\r\n{\r\nstruct buffer_head *Sh = PATH_H_PBUFFER(tb->tb_path, h);\r\nint levbytes = tb->insert_size[h];\r\nstruct item_head *ih;\r\nstruct reiserfs_key *r_key = NULL;\r\nih = B_N_PITEM_HEAD(Sh, 0);\r\nif (tb->CFR[h])\r\nr_key = B_N_PDELIM_KEY(tb->CFR[h], tb->rkey[h]);\r\nif (lfree + rfree + sfree < MAX_CHILD_SIZE(Sh) + levbytes\r\n-\r\n((!h\r\n&& op_is_left_mergeable(&(ih->ih_key), Sh->b_size)) ? IH_SIZE : 0)\r\n-\r\n((!h && r_key\r\n&& op_is_left_mergeable(r_key, Sh->b_size)) ? IH_SIZE : 0)\r\n+ ((h) ? KEY_SIZE : 0)) {\r\nif (sfree >= levbytes) {\r\nif (!h)\r\ntb->s0num =\r\nB_NR_ITEMS(Sh) +\r\n((mode == M_INSERT) ? 1 : 0);\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\n}\r\n}\r\nPROC_INFO_INC(tb->tb_sb, can_node_be_removed[h]);\r\nreturn !NO_BALANCING_NEEDED;\r\n}\r\nstatic int ip_check_balance(struct tree_balance *tb, int h)\r\n{\r\nstruct virtual_node *vn = tb->tb_vn;\r\nint levbytes,\r\nret;\r\nint lfree, sfree, rfree ;\r\nint nver, lnver, rnver, lrnver;\r\nshort snum012[40] = { 0, };\r\nstruct buffer_head *Sh;\r\nSh = PATH_H_PBUFFER(tb->tb_path, h);\r\nlevbytes = tb->insert_size[h];\r\nif (!Sh) {\r\nif (!h)\r\nreiserfs_panic(tb->tb_sb, "vs-8210",\r\n"S[0] can not be 0");\r\nswitch (ret = get_empty_nodes(tb, h)) {\r\ncase CARRY_ON:\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\ncase NO_DISK_SPACE:\r\ncase REPEAT_SEARCH:\r\nreturn ret;\r\ndefault:\r\nreiserfs_panic(tb->tb_sb, "vs-8215", "incorrect "\r\n"return value of get_empty_nodes");\r\n}\r\n}\r\nif ((ret = get_parents(tb, h)) != CARRY_ON)\r\nreturn ret;\r\nsfree = B_FREE_SPACE(Sh);\r\nrfree = get_rfree(tb, h);\r\nlfree = get_lfree(tb, h);\r\nif (can_node_be_removed(vn->vn_mode, lfree, sfree, rfree, tb, h) ==\r\nNO_BALANCING_NEEDED)\r\nreturn NO_BALANCING_NEEDED;\r\ncreate_virtual_node(tb, h);\r\ncheck_left(tb, h, lfree);\r\ncheck_right(tb, h, rfree);\r\nif (h && (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1)) {\r\nint to_r;\r\nto_r =\r\n((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\r\nvn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\r\ntb->rnum[h]);\r\nset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\r\n-1, -1);\r\nreturn CARRY_ON;\r\n}\r\nRFALSE(h &&\r\n(tb->lnum[h] >= vn->vn_nr_item + 1 ||\r\ntb->rnum[h] >= vn->vn_nr_item + 1),\r\n"vs-8220: tree is not balanced on internal level");\r\nRFALSE(!h && ((tb->lnum[h] >= vn->vn_nr_item && (tb->lbytes == -1)) ||\r\n(tb->rnum[h] >= vn->vn_nr_item && (tb->rbytes == -1))),\r\n"vs-8225: tree is not balanced on leaf level");\r\nif (!h && is_leaf_removable(tb))\r\nreturn CARRY_ON;\r\nif (sfree >= levbytes) {\r\nif (!h)\r\ntb->s0num = vn->vn_nr_item;\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\n}\r\n{\r\nint lpar, rpar, nset, lset, rset, lrset;\r\n#define FLOW 1\r\n#define NO_FLOW 0\r\n#define NOTHING_SHIFT_NO_FLOW 0\r\n#define NOTHING_SHIFT_FLOW 5\r\n#define LEFT_SHIFT_NO_FLOW 10\r\n#define LEFT_SHIFT_FLOW 15\r\n#define RIGHT_SHIFT_NO_FLOW 20\r\n#define RIGHT_SHIFT_FLOW 25\r\n#define LR_SHIFT_NO_FLOW 30\r\n#define LR_SHIFT_FLOW 35\r\nlpar = tb->lnum[h];\r\nrpar = tb->rnum[h];\r\nnset = NOTHING_SHIFT_NO_FLOW;\r\nnver = get_num_ver(vn->vn_mode, tb, h,\r\n0, -1, h ? vn->vn_nr_item : 0, -1,\r\nsnum012, NO_FLOW);\r\nif (!h) {\r\nint nver1;\r\nnver1 = get_num_ver(vn->vn_mode, tb, h,\r\n0, -1, 0, -1,\r\nsnum012 + NOTHING_SHIFT_FLOW, FLOW);\r\nif (nver > nver1)\r\nnset = NOTHING_SHIFT_FLOW, nver = nver1;\r\n}\r\nlset = LEFT_SHIFT_NO_FLOW;\r\nlnver = get_num_ver(vn->vn_mode, tb, h,\r\nlpar - ((h || tb->lbytes == -1) ? 0 : 1),\r\n-1, h ? vn->vn_nr_item : 0, -1,\r\nsnum012 + LEFT_SHIFT_NO_FLOW, NO_FLOW);\r\nif (!h) {\r\nint lnver1;\r\nlnver1 = get_num_ver(vn->vn_mode, tb, h,\r\nlpar -\r\n((tb->lbytes != -1) ? 1 : 0),\r\ntb->lbytes, 0, -1,\r\nsnum012 + LEFT_SHIFT_FLOW, FLOW);\r\nif (lnver > lnver1)\r\nlset = LEFT_SHIFT_FLOW, lnver = lnver1;\r\n}\r\nrset = RIGHT_SHIFT_NO_FLOW;\r\nrnver = get_num_ver(vn->vn_mode, tb, h,\r\n0, -1,\r\nh ? (vn->vn_nr_item - rpar) : (rpar -\r\n((tb->\r\nrbytes !=\r\n-1) ? 1 :\r\n0)), -1,\r\nsnum012 + RIGHT_SHIFT_NO_FLOW, NO_FLOW);\r\nif (!h) {\r\nint rnver1;\r\nrnver1 = get_num_ver(vn->vn_mode, tb, h,\r\n0, -1,\r\n(rpar -\r\n((tb->rbytes != -1) ? 1 : 0)),\r\ntb->rbytes,\r\nsnum012 + RIGHT_SHIFT_FLOW, FLOW);\r\nif (rnver > rnver1)\r\nrset = RIGHT_SHIFT_FLOW, rnver = rnver1;\r\n}\r\nlrset = LR_SHIFT_NO_FLOW;\r\nlrnver = get_num_ver(vn->vn_mode, tb, h,\r\nlpar - ((h || tb->lbytes == -1) ? 0 : 1),\r\n-1,\r\nh ? (vn->vn_nr_item - rpar) : (rpar -\r\n((tb->\r\nrbytes !=\r\n-1) ? 1 :\r\n0)), -1,\r\nsnum012 + LR_SHIFT_NO_FLOW, NO_FLOW);\r\nif (!h) {\r\nint lrnver1;\r\nlrnver1 = get_num_ver(vn->vn_mode, tb, h,\r\nlpar -\r\n((tb->lbytes != -1) ? 1 : 0),\r\ntb->lbytes,\r\n(rpar -\r\n((tb->rbytes != -1) ? 1 : 0)),\r\ntb->rbytes,\r\nsnum012 + LR_SHIFT_FLOW, FLOW);\r\nif (lrnver > lrnver1)\r\nlrset = LR_SHIFT_FLOW, lrnver = lrnver1;\r\n}\r\nif (lrnver < lnver && lrnver < rnver) {\r\nRFALSE(h &&\r\n(tb->lnum[h] != 1 ||\r\ntb->rnum[h] != 1 ||\r\nlrnver != 1 || rnver != 2 || lnver != 2\r\n|| h != 1), "vs-8230: bad h");\r\nif (lrset == LR_SHIFT_FLOW)\r\nset_parameters(tb, h, tb->lnum[h], tb->rnum[h],\r\nlrnver, snum012 + lrset,\r\ntb->lbytes, tb->rbytes);\r\nelse\r\nset_parameters(tb, h,\r\ntb->lnum[h] -\r\n((tb->lbytes == -1) ? 0 : 1),\r\ntb->rnum[h] -\r\n((tb->rbytes == -1) ? 0 : 1),\r\nlrnver, snum012 + lrset, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nif (nver == lrnver) {\r\nset_parameters(tb, h, 0, 0, nver, snum012 + nset, -1,\r\n-1);\r\nreturn CARRY_ON;\r\n}\r\nif (lnver < rnver) {\r\nSET_PAR_SHIFT_LEFT;\r\nreturn CARRY_ON;\r\n}\r\nif (lnver > rnver) {\r\nSET_PAR_SHIFT_RIGHT;\r\nreturn CARRY_ON;\r\n}\r\nif (is_left_neighbor_in_cache(tb, h)) {\r\nSET_PAR_SHIFT_LEFT;\r\nreturn CARRY_ON;\r\n}\r\nSET_PAR_SHIFT_RIGHT;\r\nreturn CARRY_ON;\r\n}\r\n}\r\nstatic int dc_check_balance_internal(struct tree_balance *tb, int h)\r\n{\r\nstruct virtual_node *vn = tb->tb_vn;\r\nstruct buffer_head *Sh, *Fh;\r\nint maxsize, ret;\r\nint lfree, rfree ;\r\nSh = PATH_H_PBUFFER(tb->tb_path, h);\r\nFh = PATH_H_PPARENT(tb->tb_path, h);\r\nmaxsize = MAX_CHILD_SIZE(Sh);\r\ncreate_virtual_node(tb, h);\r\nif (!Fh) {\r\nif (vn->vn_nr_item > 0) {\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\n}\r\nset_parameters(tb, h, 0, 0, 0, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nif ((ret = get_parents(tb, h)) != CARRY_ON)\r\nreturn ret;\r\nrfree = get_rfree(tb, h);\r\nlfree = get_lfree(tb, h);\r\ncheck_left(tb, h, lfree);\r\ncheck_right(tb, h, rfree);\r\nif (vn->vn_nr_item >= MIN_NR_KEY(Sh)) {\r\nif (vn->vn_nr_item == MIN_NR_KEY(Sh)) {\r\nif (tb->lnum[h] >= vn->vn_nr_item + 1) {\r\nint n;\r\nint order_L;\r\norder_L =\r\n((n =\r\nPATH_H_B_ITEM_ORDER(tb->tb_path,\r\nh)) ==\r\n0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\r\nn = dc_size(B_N_CHILD(tb->FL[h], order_L)) /\r\n(DC_SIZE + KEY_SIZE);\r\nset_parameters(tb, h, -n - 1, 0, 0, NULL, -1,\r\n-1);\r\nreturn CARRY_ON;\r\n}\r\nif (tb->rnum[h] >= vn->vn_nr_item + 1) {\r\nint n;\r\nint order_R;\r\norder_R =\r\n((n =\r\nPATH_H_B_ITEM_ORDER(tb->tb_path,\r\nh)) ==\r\nB_NR_ITEMS(Fh)) ? 0 : n + 1;\r\nn = dc_size(B_N_CHILD(tb->FR[h], order_R)) /\r\n(DC_SIZE + KEY_SIZE);\r\nset_parameters(tb, h, 0, -n - 1, 0, NULL, -1,\r\n-1);\r\nreturn CARRY_ON;\r\n}\r\n}\r\nif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\r\nint to_r;\r\nto_r =\r\n((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] -\r\ntb->rnum[h] + vn->vn_nr_item + 1) / 2 -\r\n(MAX_NR_KEY(Sh) + 1 - tb->rnum[h]);\r\nset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r,\r\n0, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\n}\r\nif (tb->lnum[h] >= vn->vn_nr_item + 1)\r\nif (is_left_neighbor_in_cache(tb, h)\r\n|| tb->rnum[h] < vn->vn_nr_item + 1 || !tb->FR[h]) {\r\nint n;\r\nint order_L;\r\norder_L =\r\n((n =\r\nPATH_H_B_ITEM_ORDER(tb->tb_path,\r\nh)) ==\r\n0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;\r\nn = dc_size(B_N_CHILD(tb->FL[h], order_L)) / (DC_SIZE +\r\nKEY_SIZE);\r\nset_parameters(tb, h, -n - 1, 0, 0, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nif (tb->rnum[h] >= vn->vn_nr_item + 1) {\r\nint n;\r\nint order_R;\r\norder_R =\r\n((n =\r\nPATH_H_B_ITEM_ORDER(tb->tb_path,\r\nh)) == B_NR_ITEMS(Fh)) ? 0 : (n + 1);\r\nn = dc_size(B_N_CHILD(tb->FR[h], order_R)) / (DC_SIZE +\r\nKEY_SIZE);\r\nset_parameters(tb, h, 0, -n - 1, 0, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nif (tb->rnum[h] + tb->lnum[h] >= vn->vn_nr_item + 1) {\r\nint to_r;\r\nto_r =\r\n((MAX_NR_KEY(Sh) << 1) + 2 - tb->lnum[h] - tb->rnum[h] +\r\nvn->vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 -\r\ntb->rnum[h]);\r\nset_parameters(tb, h, vn->vn_nr_item + 1 - to_r, to_r, 0, NULL,\r\n-1, -1);\r\nreturn CARRY_ON;\r\n}\r\nRFALSE(!tb->FL[h] && !tb->FR[h], "vs-8235: trying to borrow for root");\r\nif (is_left_neighbor_in_cache(tb, h) || !tb->FR[h]) {\r\nint from_l;\r\nfrom_l =\r\n(MAX_NR_KEY(Sh) + 1 - tb->lnum[h] + vn->vn_nr_item +\r\n1) / 2 - (vn->vn_nr_item + 1);\r\nset_parameters(tb, h, -from_l, 0, 1, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nset_parameters(tb, h, 0,\r\n-((MAX_NR_KEY(Sh) + 1 - tb->rnum[h] + vn->vn_nr_item +\r\n1) / 2 - (vn->vn_nr_item + 1)), 1, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nstatic int dc_check_balance_leaf(struct tree_balance *tb, int h)\r\n{\r\nstruct virtual_node *vn = tb->tb_vn;\r\nint levbytes;\r\nint maxsize, ret;\r\nstruct buffer_head *S0, *F0;\r\nint lfree, rfree ;\r\nS0 = PATH_H_PBUFFER(tb->tb_path, 0);\r\nF0 = PATH_H_PPARENT(tb->tb_path, 0);\r\nlevbytes = tb->insert_size[h];\r\nmaxsize = MAX_CHILD_SIZE(S0);\r\nif (!F0) {\r\nRFALSE(-levbytes >= maxsize - B_FREE_SPACE(S0),\r\n"vs-8240: attempt to create empty buffer tree");\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\n}\r\nif ((ret = get_parents(tb, h)) != CARRY_ON)\r\nreturn ret;\r\nrfree = get_rfree(tb, h);\r\nlfree = get_lfree(tb, h);\r\ncreate_virtual_node(tb, h);\r\nif (are_leaves_removable(tb, lfree, rfree))\r\nreturn CARRY_ON;\r\ncheck_left(tb, h, lfree);\r\ncheck_right(tb, h, rfree);\r\nif (tb->lnum[0] >= vn->vn_nr_item && tb->lbytes == -1)\r\nif (is_left_neighbor_in_cache(tb, h) || ((tb->rnum[0] - ((tb->rbytes == -1) ? 0 : 1)) < vn->vn_nr_item) ||\r\n!tb->FR[h]) {\r\nRFALSE(!tb->FL[h],\r\n"vs-8245: dc_check_balance_leaf: FL[h] must exist");\r\nset_parameters(tb, h, -1, 0, 0, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nif (tb->rnum[0] >= vn->vn_nr_item && tb->rbytes == -1) {\r\nset_parameters(tb, h, 0, -1, 0, NULL, -1, -1);\r\nreturn CARRY_ON;\r\n}\r\nif (is_leaf_removable(tb))\r\nreturn CARRY_ON;\r\ntb->s0num = vn->vn_nr_item;\r\nset_parameters(tb, h, 0, 0, 1, NULL, -1, -1);\r\nreturn NO_BALANCING_NEEDED;\r\n}\r\nstatic int dc_check_balance(struct tree_balance *tb, int h)\r\n{\r\nRFALSE(!(PATH_H_PBUFFER(tb->tb_path, h)),\r\n"vs-8250: S is not initialized");\r\nif (h)\r\nreturn dc_check_balance_internal(tb, h);\r\nelse\r\nreturn dc_check_balance_leaf(tb, h);\r\n}\r\nstatic int check_balance(int mode,\r\nstruct tree_balance *tb,\r\nint h,\r\nint inum,\r\nint pos_in_item,\r\nstruct item_head *ins_ih, const void *data)\r\n{\r\nstruct virtual_node *vn;\r\nvn = tb->tb_vn = (struct virtual_node *)(tb->vn_buf);\r\nvn->vn_free_ptr = (char *)(tb->tb_vn + 1);\r\nvn->vn_mode = mode;\r\nvn->vn_affected_item_num = inum;\r\nvn->vn_pos_in_item = pos_in_item;\r\nvn->vn_ins_ih = ins_ih;\r\nvn->vn_data = data;\r\nRFALSE(mode == M_INSERT && !vn->vn_ins_ih,\r\n"vs-8255: ins_ih can not be 0 in insert mode");\r\nif (tb->insert_size[h] > 0)\r\nreturn ip_check_balance(tb, h);\r\nreturn dc_check_balance(tb, h);\r\n}\r\nstatic int get_direct_parent(struct tree_balance *tb, int h)\r\n{\r\nstruct buffer_head *bh;\r\nstruct treepath *path = tb->tb_path;\r\nint position,\r\npath_offset = PATH_H_PATH_OFFSET(tb->tb_path, h);\r\nif (path_offset <= FIRST_PATH_ELEMENT_OFFSET) {\r\nRFALSE(path_offset < FIRST_PATH_ELEMENT_OFFSET - 1,\r\n"PAP-8260: invalid offset in the path");\r\nif (PATH_OFFSET_PBUFFER(path, FIRST_PATH_ELEMENT_OFFSET)->\r\nb_blocknr == SB_ROOT_BLOCK(tb->tb_sb)) {\r\nPATH_OFFSET_PBUFFER(path, path_offset - 1) = NULL;\r\nPATH_OFFSET_POSITION(path, path_offset - 1) = 0;\r\nreturn CARRY_ON;\r\n}\r\nreturn REPEAT_SEARCH;\r\n}\r\nif (!B_IS_IN_TREE\r\n(bh = PATH_OFFSET_PBUFFER(path, path_offset - 1)))\r\nreturn REPEAT_SEARCH;\r\nif ((position =\r\nPATH_OFFSET_POSITION(path,\r\npath_offset - 1)) > B_NR_ITEMS(bh))\r\nreturn REPEAT_SEARCH;\r\nif (B_N_CHILD_NUM(bh, position) !=\r\nPATH_OFFSET_PBUFFER(path, path_offset)->b_blocknr)\r\nreturn REPEAT_SEARCH;\r\nif (buffer_locked(bh)) {\r\nreiserfs_write_unlock(tb->tb_sb);\r\n__wait_on_buffer(bh);\r\nreiserfs_write_lock(tb->tb_sb);\r\nif (FILESYSTEM_CHANGED_TB(tb))\r\nreturn REPEAT_SEARCH;\r\n}\r\nreturn CARRY_ON;\r\n}\r\nstatic int get_neighbors(struct tree_balance *tb, int h)\r\n{\r\nint child_position,\r\npath_offset = PATH_H_PATH_OFFSET(tb->tb_path, h + 1);\r\nunsigned long son_number;\r\nstruct super_block *sb = tb->tb_sb;\r\nstruct buffer_head *bh;\r\nPROC_INFO_INC(sb, get_neighbors[h]);\r\nif (tb->lnum[h]) {\r\nPROC_INFO_INC(sb, need_l_neighbor[h]);\r\nbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\r\nRFALSE(bh == tb->FL[h] &&\r\n!PATH_OFFSET_POSITION(tb->tb_path, path_offset),\r\n"PAP-8270: invalid position in the parent");\r\nchild_position =\r\n(bh ==\r\ntb->FL[h]) ? tb->lkey[h] : B_NR_ITEMS(tb->\r\nFL[h]);\r\nson_number = B_N_CHILD_NUM(tb->FL[h], child_position);\r\nreiserfs_write_unlock(sb);\r\nbh = sb_bread(sb, son_number);\r\nreiserfs_write_lock(sb);\r\nif (!bh)\r\nreturn IO_ERROR;\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\nbrelse(bh);\r\nPROC_INFO_INC(sb, get_neighbors_restart[h]);\r\nreturn REPEAT_SEARCH;\r\n}\r\nRFALSE(!B_IS_IN_TREE(tb->FL[h]) ||\r\nchild_position > B_NR_ITEMS(tb->FL[h]) ||\r\nB_N_CHILD_NUM(tb->FL[h], child_position) !=\r\nbh->b_blocknr, "PAP-8275: invalid parent");\r\nRFALSE(!B_IS_IN_TREE(bh), "PAP-8280: invalid child");\r\nRFALSE(!h &&\r\nB_FREE_SPACE(bh) !=\r\nMAX_CHILD_SIZE(bh) -\r\ndc_size(B_N_CHILD(tb->FL[0], child_position)),\r\n"PAP-8290: invalid child size of left neighbor");\r\nbrelse(tb->L[h]);\r\ntb->L[h] = bh;\r\n}\r\nif (tb->rnum[h]) {\r\nPROC_INFO_INC(sb, need_r_neighbor[h]);\r\nbh = PATH_OFFSET_PBUFFER(tb->tb_path, path_offset);\r\nRFALSE(bh == tb->FR[h] &&\r\nPATH_OFFSET_POSITION(tb->tb_path,\r\npath_offset) >=\r\nB_NR_ITEMS(bh),\r\n"PAP-8295: invalid position in the parent");\r\nchild_position =\r\n(bh == tb->FR[h]) ? tb->rkey[h] + 1 : 0;\r\nson_number = B_N_CHILD_NUM(tb->FR[h], child_position);\r\nreiserfs_write_unlock(sb);\r\nbh = sb_bread(sb, son_number);\r\nreiserfs_write_lock(sb);\r\nif (!bh)\r\nreturn IO_ERROR;\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\nbrelse(bh);\r\nPROC_INFO_INC(sb, get_neighbors_restart[h]);\r\nreturn REPEAT_SEARCH;\r\n}\r\nbrelse(tb->R[h]);\r\ntb->R[h] = bh;\r\nRFALSE(!h\r\n&& B_FREE_SPACE(bh) !=\r\nMAX_CHILD_SIZE(bh) -\r\ndc_size(B_N_CHILD(tb->FR[0], child_position)),\r\n"PAP-8300: invalid child size of right neighbor (%d != %d - %d)",\r\nB_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),\r\ndc_size(B_N_CHILD(tb->FR[0], child_position)));\r\n}\r\nreturn CARRY_ON;\r\n}\r\nstatic int get_virtual_node_size(struct super_block *sb, struct buffer_head *bh)\r\n{\r\nint max_num_of_items;\r\nint max_num_of_entries;\r\nunsigned long blocksize = sb->s_blocksize;\r\n#define MIN_NAME_LEN 1\r\nmax_num_of_items = (blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN);\r\nmax_num_of_entries = (blocksize - BLKH_SIZE - IH_SIZE) /\r\n(DEH_SIZE + MIN_NAME_LEN);\r\nreturn sizeof(struct virtual_node) +\r\nmax(max_num_of_items * sizeof(struct virtual_item),\r\nsizeof(struct virtual_item) + sizeof(struct direntry_uarea) +\r\n(max_num_of_entries - 1) * sizeof(__u16));\r\n}\r\nstatic int get_mem_for_virtual_node(struct tree_balance *tb)\r\n{\r\nint check_fs = 0;\r\nint size;\r\nchar *buf;\r\nsize = get_virtual_node_size(tb->tb_sb, PATH_PLAST_BUFFER(tb->tb_path));\r\nif (size > tb->vn_buf_size) {\r\nif (tb->vn_buf) {\r\nkfree(tb->vn_buf);\r\ncheck_fs = 1;\r\n}\r\ntb->vn_buf_size = size;\r\nbuf = kmalloc(size, GFP_ATOMIC | __GFP_NOWARN);\r\nif (!buf) {\r\nfree_buffers_in_tb(tb);\r\nbuf = kmalloc(size, GFP_NOFS);\r\nif (!buf) {\r\ntb->vn_buf_size = 0;\r\n}\r\ntb->vn_buf = buf;\r\nschedule();\r\nreturn REPEAT_SEARCH;\r\n}\r\ntb->vn_buf = buf;\r\n}\r\nif (check_fs && FILESYSTEM_CHANGED_TB(tb))\r\nreturn REPEAT_SEARCH;\r\nreturn CARRY_ON;\r\n}\r\nstatic void tb_buffer_sanity_check(struct super_block *sb,\r\nstruct buffer_head *bh,\r\nconst char *descr, int level)\r\n{\r\nif (bh) {\r\nif (atomic_read(&(bh->b_count)) <= 0)\r\nreiserfs_panic(sb, "jmacd-1", "negative or zero "\r\n"reference counter for buffer %s[%d] "\r\n"(%b)", descr, level, bh);\r\nif (!buffer_uptodate(bh))\r\nreiserfs_panic(sb, "jmacd-2", "buffer is not up "\r\n"to date %s[%d] (%b)",\r\ndescr, level, bh);\r\nif (!B_IS_IN_TREE(bh))\r\nreiserfs_panic(sb, "jmacd-3", "buffer is not "\r\n"in tree %s[%d] (%b)",\r\ndescr, level, bh);\r\nif (bh->b_bdev != sb->s_bdev)\r\nreiserfs_panic(sb, "jmacd-4", "buffer has wrong "\r\n"device %s[%d] (%b)",\r\ndescr, level, bh);\r\nif (bh->b_size != sb->s_blocksize)\r\nreiserfs_panic(sb, "jmacd-5", "buffer has wrong "\r\n"blocksize %s[%d] (%b)",\r\ndescr, level, bh);\r\nif (bh->b_blocknr > SB_BLOCK_COUNT(sb))\r\nreiserfs_panic(sb, "jmacd-6", "buffer block "\r\n"number too high %s[%d] (%b)",\r\ndescr, level, bh);\r\n}\r\n}\r\nstatic void tb_buffer_sanity_check(struct super_block *sb,\r\nstruct buffer_head *bh,\r\nconst char *descr, int level)\r\n{;\r\n}\r\nstatic int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)\r\n{\r\nreturn reiserfs_prepare_for_journal(s, bh, 0);\r\n}\r\nstatic int wait_tb_buffers_until_unlocked(struct tree_balance *tb)\r\n{\r\nstruct buffer_head *locked;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nint repeat_counter = 0;\r\n#endif\r\nint i;\r\ndo {\r\nlocked = NULL;\r\nfor (i = tb->tb_path->path_length;\r\n!locked && i > ILLEGAL_PATH_ELEMENT_OFFSET; i--) {\r\nif (PATH_OFFSET_PBUFFER(tb->tb_path, i)) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (PATH_PLAST_BUFFER(tb->tb_path) ==\r\nPATH_OFFSET_PBUFFER(tb->tb_path, i))\r\ntb_buffer_sanity_check(tb->tb_sb,\r\nPATH_OFFSET_PBUFFER\r\n(tb->tb_path,\r\ni), "S",\r\ntb->tb_path->\r\npath_length - i);\r\n#endif\r\nif (!clear_all_dirty_bits(tb->tb_sb,\r\nPATH_OFFSET_PBUFFER\r\n(tb->tb_path,\r\ni))) {\r\nlocked =\r\nPATH_OFFSET_PBUFFER(tb->tb_path,\r\ni);\r\n}\r\n}\r\n}\r\nfor (i = 0; !locked && i < MAX_HEIGHT && tb->insert_size[i];\r\ni++) {\r\nif (tb->lnum[i]) {\r\nif (tb->L[i]) {\r\ntb_buffer_sanity_check(tb->tb_sb,\r\ntb->L[i],\r\n"L", i);\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->L[i]))\r\nlocked = tb->L[i];\r\n}\r\nif (!locked && tb->FL[i]) {\r\ntb_buffer_sanity_check(tb->tb_sb,\r\ntb->FL[i],\r\n"FL", i);\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->FL[i]))\r\nlocked = tb->FL[i];\r\n}\r\nif (!locked && tb->CFL[i]) {\r\ntb_buffer_sanity_check(tb->tb_sb,\r\ntb->CFL[i],\r\n"CFL", i);\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->CFL[i]))\r\nlocked = tb->CFL[i];\r\n}\r\n}\r\nif (!locked && (tb->rnum[i])) {\r\nif (tb->R[i]) {\r\ntb_buffer_sanity_check(tb->tb_sb,\r\ntb->R[i],\r\n"R", i);\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->R[i]))\r\nlocked = tb->R[i];\r\n}\r\nif (!locked && tb->FR[i]) {\r\ntb_buffer_sanity_check(tb->tb_sb,\r\ntb->FR[i],\r\n"FR", i);\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->FR[i]))\r\nlocked = tb->FR[i];\r\n}\r\nif (!locked && tb->CFR[i]) {\r\ntb_buffer_sanity_check(tb->tb_sb,\r\ntb->CFR[i],\r\n"CFR", i);\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->CFR[i]))\r\nlocked = tb->CFR[i];\r\n}\r\n}\r\n}\r\nfor (i = 0; !locked && i < MAX_FEB_SIZE; i++) {\r\nif (tb->FEB[i]) {\r\nif (!clear_all_dirty_bits\r\n(tb->tb_sb, tb->FEB[i]))\r\nlocked = tb->FEB[i];\r\n}\r\n}\r\nif (locked) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nrepeat_counter++;\r\nif ((repeat_counter % 10000) == 0) {\r\nreiserfs_warning(tb->tb_sb, "reiserfs-8200",\r\n"too many iterations waiting "\r\n"for buffer to unlock "\r\n"(%b)", locked);\r\nreturn (FILESYSTEM_CHANGED_TB(tb)) ?\r\nREPEAT_SEARCH : CARRY_ON;\r\n}\r\n#endif\r\nreiserfs_write_unlock(tb->tb_sb);\r\n__wait_on_buffer(locked);\r\nreiserfs_write_lock(tb->tb_sb);\r\nif (FILESYSTEM_CHANGED_TB(tb))\r\nreturn REPEAT_SEARCH;\r\n}\r\n} while (locked);\r\nreturn CARRY_ON;\r\n}\r\nint fix_nodes(int op_mode, struct tree_balance *tb,\r\nstruct item_head *ins_ih, const void *data)\r\n{\r\nint ret, h, item_num = PATH_LAST_POSITION(tb->tb_path);\r\nint pos_in_item;\r\nint wait_tb_buffers_run = 0;\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\n++REISERFS_SB(tb->tb_sb)->s_fix_nodes;\r\npos_in_item = tb->tb_path->pos_in_item;\r\ntb->fs_gen = get_generation(tb->tb_sb);\r\nreiserfs_prepare_for_journal(tb->tb_sb,\r\nSB_BUFFER_WITH_SB(tb->tb_sb), 1);\r\njournal_mark_dirty(tb->transaction_handle, tb->tb_sb,\r\nSB_BUFFER_WITH_SB(tb->tb_sb));\r\nif (FILESYSTEM_CHANGED_TB(tb))\r\nreturn REPEAT_SEARCH;\r\nif (buffer_locked(tbS0)) {\r\nreiserfs_write_unlock(tb->tb_sb);\r\n__wait_on_buffer(tbS0);\r\nreiserfs_write_lock(tb->tb_sb);\r\nif (FILESYSTEM_CHANGED_TB(tb))\r\nreturn REPEAT_SEARCH;\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (REISERFS_SB(tb->tb_sb)->cur_tb) {\r\nprint_cur_tb("fix_nodes");\r\nreiserfs_panic(tb->tb_sb, "PAP-8305",\r\n"there is pending do_balance");\r\n}\r\nif (!buffer_uptodate(tbS0) || !B_IS_IN_TREE(tbS0))\r\nreiserfs_panic(tb->tb_sb, "PAP-8320", "S[0] (%b %z) is "\r\n"not uptodate at the beginning of fix_nodes "\r\n"or not in tree (mode %c)",\r\ntbS0, tbS0, op_mode);\r\nswitch (op_mode) {\r\ncase M_INSERT:\r\nif (item_num <= 0 || item_num > B_NR_ITEMS(tbS0))\r\nreiserfs_panic(tb->tb_sb, "PAP-8330", "Incorrect "\r\n"item number %d (in S0 - %d) in case "\r\n"of insert", item_num,\r\nB_NR_ITEMS(tbS0));\r\nbreak;\r\ncase M_PASTE:\r\ncase M_DELETE:\r\ncase M_CUT:\r\nif (item_num < 0 || item_num >= B_NR_ITEMS(tbS0)) {\r\nprint_block(tbS0, 0, -1, -1);\r\nreiserfs_panic(tb->tb_sb, "PAP-8335", "Incorrect "\r\n"item number(%d); mode = %c "\r\n"insert_size = %d",\r\nitem_num, op_mode,\r\ntb->insert_size[0]);\r\n}\r\nbreak;\r\ndefault:\r\nreiserfs_panic(tb->tb_sb, "PAP-8340", "Incorrect mode "\r\n"of operation");\r\n}\r\n#endif\r\nif (get_mem_for_virtual_node(tb) == REPEAT_SEARCH)\r\nreturn REPEAT_SEARCH;\r\nfor (h = 0; h < MAX_HEIGHT && tb->insert_size[h]; h++) {\r\nret = get_direct_parent(tb, h);\r\nif (ret != CARRY_ON)\r\ngoto repeat;\r\nret = check_balance(op_mode, tb, h, item_num,\r\npos_in_item, ins_ih, data);\r\nif (ret != CARRY_ON) {\r\nif (ret == NO_BALANCING_NEEDED) {\r\nret = get_neighbors(tb, h);\r\nif (ret != CARRY_ON)\r\ngoto repeat;\r\nif (h != MAX_HEIGHT - 1)\r\ntb->insert_size[h + 1] = 0;\r\nbreak;\r\n}\r\ngoto repeat;\r\n}\r\nret = get_neighbors(tb, h);\r\nif (ret != CARRY_ON)\r\ngoto repeat;\r\nret = get_empty_nodes(tb, h);\r\nif (ret != CARRY_ON)\r\ngoto repeat;\r\nif (!PATH_H_PBUFFER(tb->tb_path, h)) {\r\nRFALSE(tb->blknum[h] != 1,\r\n"PAP-8350: creating new empty root");\r\nif (h < MAX_HEIGHT - 1)\r\ntb->insert_size[h + 1] = 0;\r\n} else if (!PATH_H_PBUFFER(tb->tb_path, h + 1)) {\r\nif (tb->blknum[h] > 1) {\r\nRFALSE(h == MAX_HEIGHT - 1,\r\n"PAP-8355: attempt to create too high of a tree");\r\ntb->insert_size[h + 1] =\r\n(DC_SIZE +\r\nKEY_SIZE) * (tb->blknum[h] - 1) +\r\nDC_SIZE;\r\n} else if (h < MAX_HEIGHT - 1)\r\ntb->insert_size[h + 1] = 0;\r\n} else\r\ntb->insert_size[h + 1] =\r\n(DC_SIZE + KEY_SIZE) * (tb->blknum[h] - 1);\r\n}\r\nret = wait_tb_buffers_until_unlocked(tb);\r\nif (ret == CARRY_ON) {\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\nwait_tb_buffers_run = 1;\r\nret = REPEAT_SEARCH;\r\ngoto repeat;\r\n} else {\r\nreturn CARRY_ON;\r\n}\r\n} else {\r\nwait_tb_buffers_run = 1;\r\ngoto repeat;\r\n}\r\nrepeat:\r\n{\r\nint i;\r\nif (wait_tb_buffers_run) {\r\npathrelse_and_restore(tb->tb_sb, tb->tb_path);\r\n} else {\r\npathrelse(tb->tb_path);\r\n}\r\nfor (i = 0; i < MAX_HEIGHT; i++) {\r\nif (wait_tb_buffers_run) {\r\nreiserfs_restore_prepared_buffer(tb->tb_sb,\r\ntb->L[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb,\r\ntb->R[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb,\r\ntb->FL[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb,\r\ntb->FR[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb,\r\ntb->\r\nCFL[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb,\r\ntb->\r\nCFR[i]);\r\n}\r\nbrelse(tb->L[i]);\r\nbrelse(tb->R[i]);\r\nbrelse(tb->FL[i]);\r\nbrelse(tb->FR[i]);\r\nbrelse(tb->CFL[i]);\r\nbrelse(tb->CFR[i]);\r\ntb->L[i] = NULL;\r\ntb->R[i] = NULL;\r\ntb->FL[i] = NULL;\r\ntb->FR[i] = NULL;\r\ntb->CFL[i] = NULL;\r\ntb->CFR[i] = NULL;\r\n}\r\nif (wait_tb_buffers_run) {\r\nfor (i = 0; i < MAX_FEB_SIZE; i++) {\r\nif (tb->FEB[i])\r\nreiserfs_restore_prepared_buffer\r\n(tb->tb_sb, tb->FEB[i]);\r\n}\r\n}\r\nreturn ret;\r\n}\r\n}\r\nvoid unfix_nodes(struct tree_balance *tb)\r\n{\r\nint i;\r\npathrelse_and_restore(tb->tb_sb, tb->tb_path);\r\nfor (i = 0; i < MAX_HEIGHT; i++) {\r\nreiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\r\nreiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\r\nbrelse(tb->L[i]);\r\nbrelse(tb->R[i]);\r\nbrelse(tb->FL[i]);\r\nbrelse(tb->FR[i]);\r\nbrelse(tb->CFL[i]);\r\nbrelse(tb->CFR[i]);\r\n}\r\nfor (i = 0; i < MAX_FEB_SIZE; i++) {\r\nif (tb->FEB[i]) {\r\nb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\r\nbrelse(tb->FEB[i]);\r\nreiserfs_free_block(tb->transaction_handle, NULL,\r\nblocknr, 0);\r\n}\r\nif (tb->used[i]) {\r\nbrelse(tb->used[i]);\r\n}\r\n}\r\nkfree(tb->vn_buf);\r\n}
