static enum ata_completion_errors sas_to_ata_err(struct task_status_struct *ts)\r\n{\r\nif (ts->resp == SAS_TASK_UNDELIVERED)\r\nreturn AC_ERR_ATA_BUS;\r\nswitch (ts->stat) {\r\ncase SAS_DEV_NO_RESPONSE:\r\nreturn AC_ERR_TIMEOUT;\r\ncase SAS_INTERRUPTED:\r\ncase SAS_PHY_DOWN:\r\ncase SAS_NAK_R_ERR:\r\nreturn AC_ERR_ATA_BUS;\r\ncase SAS_DATA_UNDERRUN:\r\nreturn 0;\r\ncase SAS_DATA_OVERRUN:\r\ncase SAS_QUEUE_FULL:\r\ncase SAS_DEVICE_UNKNOWN:\r\ncase SAS_SG_ERR:\r\nreturn AC_ERR_INVALID;\r\ncase SAS_OPEN_TO:\r\ncase SAS_OPEN_REJECT:\r\nSAS_DPRINTK("%s: Saw error %d. What to do?\n",\r\n__func__, ts->stat);\r\nreturn AC_ERR_OTHER;\r\ncase SAM_STAT_CHECK_CONDITION:\r\ncase SAS_ABORTED_TASK:\r\nreturn AC_ERR_DEV;\r\ncase SAS_PROTO_RESPONSE:\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void sas_ata_task_done(struct sas_task *task)\r\n{\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nstruct domain_device *dev = task->dev;\r\nstruct task_status_struct *stat = &task->task_status;\r\nstruct ata_task_resp *resp = (struct ata_task_resp *)stat->buf;\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nenum ata_completion_errors ac;\r\nunsigned long flags;\r\nstruct ata_link *link;\r\nstruct ata_port *ap;\r\nspin_lock_irqsave(&dev->done_lock, flags);\r\nif (test_bit(SAS_HA_FROZEN, &sas_ha->state))\r\ntask = NULL;\r\nelse if (qc && qc->scsicmd)\r\nASSIGN_SAS_TASK(qc->scsicmd, NULL);\r\nspin_unlock_irqrestore(&dev->done_lock, flags);\r\nif (unlikely(!task))\r\nreturn;\r\nif (!qc)\r\ngoto qc_already_gone;\r\nap = qc->ap;\r\nlink = &ap->link;\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (unlikely(ap->pflags & ATA_PFLAG_FROZEN)) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (qc->scsicmd)\r\ngoto qc_already_gone;\r\nelse {\r\nreturn;\r\n}\r\n}\r\nif (stat->stat == SAS_PROTO_RESPONSE || stat->stat == SAM_STAT_GOOD ||\r\n((stat->stat == SAM_STAT_CHECK_CONDITION &&\r\ndev->sata_dev.command_set == ATAPI_COMMAND_SET))) {\r\nmemcpy(dev->sata_dev.fis, resp->ending_fis, ATA_RESP_FIS_SIZE);\r\nif (!link->sactive) {\r\nqc->err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\r\n} else {\r\nlink->eh_info.err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\r\nif (unlikely(link->eh_info.err_mask))\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\n}\r\n} else {\r\nac = sas_to_ata_err(stat);\r\nif (ac) {\r\nSAS_DPRINTK("%s: SAS error %x\n", __func__,\r\nstat->stat);\r\nif (!link->sactive) {\r\nqc->err_mask = ac;\r\n} else {\r\nlink->eh_info.err_mask |= AC_ERR_DEV;\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\n}\r\ndev->sata_dev.fis[3] = 0x04;\r\ndev->sata_dev.fis[2] = ATA_ERR;\r\n}\r\n}\r\nqc->lldd_task = NULL;\r\nata_qc_complete(qc);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nqc_already_gone:\r\nlist_del_init(&task->list);\r\nsas_free_task(task);\r\n}\r\nstatic unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nunsigned long flags;\r\nstruct sas_task *task;\r\nstruct scatterlist *sg;\r\nint ret = AC_ERR_SYSTEM;\r\nunsigned int si, xfer = 0;\r\nstruct ata_port *ap = qc->ap;\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct Scsi_Host *host = sas_ha->core.shost;\r\nstruct sas_internal *i = to_sas_internal(host->transportt);\r\nlocal_irq_save(flags);\r\nspin_unlock(ap->lock);\r\nif (test_bit(SAS_DEV_GONE, &dev->state))\r\ngoto out;\r\ntask = sas_alloc_task(GFP_ATOMIC);\r\nif (!task)\r\ngoto out;\r\ntask->dev = dev;\r\ntask->task_proto = SAS_PROTOCOL_STP;\r\ntask->task_done = sas_ata_task_done;\r\nif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\r\nqc->tf.command == ATA_CMD_FPDMA_READ) {\r\nqc->tf.nsect = 0;\r\n}\r\nata_tf_to_fis(&qc->tf, 1, 0, (u8*)&task->ata_task.fis);\r\ntask->uldd_task = qc;\r\nif (ata_is_atapi(qc->tf.protocol)) {\r\nmemcpy(task->ata_task.atapi_packet, qc->cdb, qc->dev->cdb_len);\r\ntask->total_xfer_len = qc->nbytes;\r\ntask->num_scatter = qc->n_elem;\r\n} else {\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si)\r\nxfer += sg->length;\r\ntask->total_xfer_len = xfer;\r\ntask->num_scatter = si;\r\n}\r\ntask->data_dir = qc->dma_dir;\r\ntask->scatter = qc->sg;\r\ntask->ata_task.retry_count = 1;\r\ntask->task_state_flags = SAS_TASK_STATE_PENDING;\r\nqc->lldd_task = task;\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_NCQ:\r\ntask->ata_task.use_ncq = 1;\r\ncase ATAPI_PROT_DMA:\r\ncase ATA_PROT_DMA:\r\ntask->ata_task.dma_xfer = 1;\r\nbreak;\r\n}\r\nif (qc->scsicmd)\r\nASSIGN_SAS_TASK(qc->scsicmd, task);\r\nif (sas_ha->lldd_max_execute_num < 2)\r\nret = i->dft->lldd_execute_task(task, 1, GFP_ATOMIC);\r\nelse\r\nret = sas_queue_up(task);\r\nif (ret) {\r\nSAS_DPRINTK("lldd_execute_task returned: %d\n", ret);\r\nif (qc->scsicmd)\r\nASSIGN_SAS_TASK(qc->scsicmd, NULL);\r\nsas_free_task(task);\r\nret = AC_ERR_SYSTEM;\r\n}\r\nout:\r\nspin_lock(ap->lock);\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic bool sas_ata_qc_fill_rtf(struct ata_queued_cmd *qc)\r\n{\r\nstruct domain_device *dev = qc->ap->private_data;\r\nata_tf_from_fis(dev->sata_dev.fis, &qc->result_tf);\r\nreturn true;\r\n}\r\nstatic struct sas_internal *dev_to_sas_internal(struct domain_device *dev)\r\n{\r\nreturn to_sas_internal(dev->port->ha->core.shost->transportt);\r\n}\r\nint sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)\r\n{\r\nif (phy->attached_tproto & SAS_PROTOCOL_STP)\r\ndev->tproto = phy->attached_tproto;\r\nif (phy->attached_sata_dev)\r\ndev->tproto |= SAS_SATA_DEV;\r\nif (phy->attached_dev_type == SAS_SATA_PENDING)\r\ndev->dev_type = SAS_SATA_PENDING;\r\nelse {\r\nint res;\r\ndev->dev_type = SAS_SATA_DEV;\r\nres = sas_get_report_phy_sata(dev->parent, phy->phy_id,\r\n&dev->sata_dev.rps_resp);\r\nif (res) {\r\nSAS_DPRINTK("report phy sata to %016llx:0x%x returned "\r\n"0x%x\n", SAS_ADDR(dev->parent->sas_addr),\r\nphy->phy_id, res);\r\nreturn res;\r\n}\r\nmemcpy(dev->frame_rcvd, &dev->sata_dev.rps_resp.rps.fis,\r\nsizeof(struct dev_to_host_fis));\r\nsas_get_ata_command_set(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sas_ata_clear_pending(struct domain_device *dev, struct ex_phy *phy)\r\n{\r\nint res;\r\nif (dev->dev_type != SAS_SATA_PENDING)\r\nreturn 1;\r\nres = sas_get_ata_info(dev, phy);\r\nif (res)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int smp_ata_check_ready(struct ata_link *link)\r\n{\r\nint res;\r\nstruct ata_port *ap = link->ap;\r\nstruct domain_device *dev = ap->private_data;\r\nstruct domain_device *ex_dev = dev->parent;\r\nstruct sas_phy *phy = sas_get_local_phy(dev);\r\nstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy->number];\r\nres = sas_ex_phy_discover(ex_dev, phy->number);\r\nsas_put_local_phy(phy);\r\nif (res == -ECOMM)\r\nreturn res;\r\nif (res != SMP_RESP_FUNC_ACC)\r\nreturn 0;\r\nswitch (ex_phy->attached_dev_type) {\r\ncase SAS_SATA_PENDING:\r\nreturn 0;\r\ncase SAS_END_DEVICE:\r\nif (ex_phy->attached_sata_dev)\r\nreturn sas_ata_clear_pending(dev, ex_phy);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int local_ata_check_ready(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_internal *i = dev_to_sas_internal(dev);\r\nif (i->dft->lldd_ata_check_ready)\r\nreturn i->dft->lldd_ata_check_ready(dev);\r\nelse {\r\nreturn 1;\r\n}\r\n}\r\nstatic int sas_ata_printk(const char *level, const struct domain_device *ddev,\r\nconst char *fmt, ...)\r\n{\r\nstruct ata_port *ap = ddev->sata_dev.ap;\r\nstruct device *dev = &ddev->rphy->dev;\r\nstruct va_format vaf;\r\nva_list args;\r\nint r;\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nr = printk("%ssas: ata%u: %s: %pV",\r\nlevel, ap->print_id, dev_name(dev), &vaf);\r\nva_end(args);\r\nreturn r;\r\n}\r\nstatic int sas_ata_hard_reset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nint ret = 0, res;\r\nstruct sas_phy *phy;\r\nstruct ata_port *ap = link->ap;\r\nint (*check_ready)(struct ata_link *link);\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_internal *i = dev_to_sas_internal(dev);\r\nres = i->dft->lldd_I_T_nexus_reset(dev);\r\nif (res == -ENODEV)\r\nreturn res;\r\nif (res != TMF_RESP_FUNC_COMPLETE)\r\nsas_ata_printk(KERN_DEBUG, dev, "Unable to reset ata device?\n");\r\nphy = sas_get_local_phy(dev);\r\nif (scsi_is_sas_phy_local(phy))\r\ncheck_ready = local_ata_check_ready;\r\nelse\r\ncheck_ready = smp_ata_check_ready;\r\nsas_put_local_phy(phy);\r\nret = ata_wait_after_reset(link, deadline, check_ready);\r\nif (ret && ret != -EAGAIN)\r\nsas_ata_printk(KERN_ERR, dev, "reset failed (errno=%d)\n", ret);\r\nswitch (dev->sata_dev.command_set) {\r\ncase ATA_COMMAND_SET:\r\n*class = ATA_DEV_ATA;\r\nbreak;\r\ncase ATAPI_COMMAND_SET:\r\n*class = ATA_DEV_ATAPI;\r\nbreak;\r\n}\r\nap->cbl = ATA_CBL_SATA;\r\nreturn ret;\r\n}\r\nstatic void sas_ata_internal_abort(struct sas_task *task)\r\n{\r\nstruct sas_internal *si = dev_to_sas_internal(task->dev);\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_ABORTED ||\r\ntask->task_state_flags & SAS_TASK_STATE_DONE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nSAS_DPRINTK("%s: Task %p already finished.\n", __func__,\r\ntask);\r\ngoto out;\r\n}\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nres = si->dft->lldd_abort_task(task);\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE ||\r\nres == TMF_RESP_FUNC_COMPLETE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ngoto out;\r\n}\r\nSAS_DPRINTK("%s: Task %p leaked.\n", __func__, task);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\r\ntask->task_state_flags &= ~SAS_TASK_STATE_ABORTED;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nreturn;\r\nout:\r\nlist_del_init(&task->list);\r\nsas_free_task(task);\r\n}\r\nstatic void sas_ata_post_internal(struct ata_queued_cmd *qc)\r\n{\r\nif (qc->flags & ATA_QCFLAG_FAILED)\r\nqc->err_mask |= AC_ERR_OTHER;\r\nif (qc->err_mask) {\r\nstruct sas_task *task = qc->lldd_task;\r\nqc->lldd_task = NULL;\r\nif (!task)\r\nreturn;\r\ntask->uldd_task = NULL;\r\nsas_ata_internal_abort(task);\r\n}\r\n}\r\nstatic void sas_ata_set_dmamode(struct ata_port *ap, struct ata_device *ata_dev)\r\n{\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_internal *i = dev_to_sas_internal(dev);\r\nif (i->dft->lldd_ata_set_dmamode)\r\ni->dft->lldd_ata_set_dmamode(dev);\r\n}\r\nstatic void sas_ata_sched_eh(struct ata_port *ap)\r\n{\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->lock, flags);\r\nif (!test_and_set_bit(SAS_DEV_EH_PENDING, &dev->state))\r\nha->eh_active++;\r\nata_std_sched_eh(ap);\r\nspin_unlock_irqrestore(&ha->lock, flags);\r\n}\r\nvoid sas_ata_end_eh(struct ata_port *ap)\r\n{\r\nstruct domain_device *dev = ap->private_data;\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->lock, flags);\r\nif (test_and_clear_bit(SAS_DEV_EH_PENDING, &dev->state))\r\nha->eh_active--;\r\nspin_unlock_irqrestore(&ha->lock, flags);\r\n}\r\nint sas_ata_init(struct domain_device *found_dev)\r\n{\r\nstruct sas_ha_struct *ha = found_dev->port->ha;\r\nstruct Scsi_Host *shost = ha->core.shost;\r\nstruct ata_port *ap;\r\nint rc;\r\nata_host_init(&found_dev->sata_dev.ata_host, ha->dev, &sas_sata_ops);\r\nap = ata_sas_port_alloc(&found_dev->sata_dev.ata_host,\r\n&sata_port_info,\r\nshost);\r\nif (!ap) {\r\nSAS_DPRINTK("ata_sas_port_alloc failed.\n");\r\nreturn -ENODEV;\r\n}\r\nap->private_data = found_dev;\r\nap->cbl = ATA_CBL_SATA;\r\nap->scsi_host = shost;\r\nrc = ata_sas_port_init(ap);\r\nif (rc) {\r\nata_sas_port_destroy(ap);\r\nreturn rc;\r\n}\r\nfound_dev->sata_dev.ap = ap;\r\nreturn 0;\r\n}\r\nvoid sas_ata_task_abort(struct sas_task *task)\r\n{\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nstruct completion *waiting;\r\nif (qc->scsicmd) {\r\nstruct request_queue *q = qc->scsicmd->device->request_queue;\r\nunsigned long flags;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nblk_abort_request(qc->scsicmd->request);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nreturn;\r\n}\r\nqc->flags &= ~ATA_QCFLAG_ACTIVE;\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\nqc->err_mask |= AC_ERR_TIMEOUT;\r\nwaiting = qc->private_data;\r\ncomplete(waiting);\r\n}\r\nstatic void sas_get_ata_command_set(struct domain_device *dev)\r\n{\r\nstruct dev_to_host_fis *fis =\r\n(struct dev_to_host_fis *) dev->frame_rcvd;\r\nif (dev->dev_type == SAS_SATA_PENDING)\r\nreturn;\r\nif ((fis->sector_count == 1 &&\r\nfis->lbal == 1 &&\r\nfis->lbam == 0 &&\r\nfis->lbah == 0 &&\r\nfis->device == 0)\r\n||\r\n(fis->sector_count == 0 &&\r\nfis->lbal == 0 &&\r\nfis->lbam == 0xCE &&\r\nfis->lbah == 0xAA &&\r\n(fis->device & ~0x10) == 0))\r\ndev->sata_dev.command_set = ATA_COMMAND_SET;\r\nelse if ((fis->interrupt_reason == 1 &&\r\nfis->lbal == 1 &&\r\nfis->byte_count_low == 0x14 &&\r\nfis->byte_count_high == 0xEB &&\r\n(fis->device & ~0x10) == 0))\r\ndev->sata_dev.command_set = ATAPI_COMMAND_SET;\r\nelse if ((fis->sector_count == 1 &&\r\nfis->lbal == 1 &&\r\nfis->lbam == 0x3C &&\r\nfis->lbah == 0xC3 &&\r\nfis->device == 0)\r\n||\r\n(fis->interrupt_reason == 1 &&\r\nfis->lbal == 1 &&\r\nfis->byte_count_low == 0x69 &&\r\nfis->byte_count_high == 0x96 &&\r\n(fis->device & ~0x10) == 0))\r\ndev->sata_dev.command_set = ATAPI_COMMAND_SET;\r\n}\r\nvoid sas_probe_sata(struct asd_sas_port *port)\r\n{\r\nstruct domain_device *dev, *n;\r\nmutex_lock(&port->ha->disco_mutex);\r\nlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\r\nif (!dev_is_sata(dev))\r\ncontinue;\r\nata_sas_async_probe(dev->sata_dev.ap);\r\n}\r\nmutex_unlock(&port->ha->disco_mutex);\r\nlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\r\nif (!dev_is_sata(dev))\r\ncontinue;\r\nsas_ata_wait_eh(dev);\r\nif (ata_dev_disabled(sas_to_ata_dev(dev)))\r\nsas_fail_probe(dev, __func__, -ENODEV);\r\n}\r\n}\r\nstatic bool sas_ata_flush_pm_eh(struct asd_sas_port *port, const char *func)\r\n{\r\nstruct domain_device *dev, *n;\r\nbool retry = false;\r\nlist_for_each_entry_safe(dev, n, &port->dev_list, dev_list_node) {\r\nint rc;\r\nif (!dev_is_sata(dev))\r\ncontinue;\r\nsas_ata_wait_eh(dev);\r\nrc = dev->sata_dev.pm_result;\r\nif (rc == -EAGAIN)\r\nretry = true;\r\nelse if (rc) {\r\nWARN_ONCE(1, "failed %s %s error: %d\n", func,\r\ndev_name(&dev->rphy->dev), rc);\r\n}\r\nif (ata_dev_disabled(sas_to_ata_dev(dev)))\r\nsas_fail_probe(dev, func, -ENODEV);\r\n}\r\nreturn retry;\r\n}\r\nvoid sas_suspend_sata(struct asd_sas_port *port)\r\n{\r\nstruct domain_device *dev;\r\nretry:\r\nmutex_lock(&port->ha->disco_mutex);\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nstruct sata_device *sata;\r\nif (!dev_is_sata(dev))\r\ncontinue;\r\nsata = &dev->sata_dev;\r\nif (sata->ap->pm_mesg.event == PM_EVENT_SUSPEND)\r\ncontinue;\r\nsata->pm_result = -EIO;\r\nata_sas_port_async_suspend(sata->ap, &sata->pm_result);\r\n}\r\nmutex_unlock(&port->ha->disco_mutex);\r\nif (sas_ata_flush_pm_eh(port, __func__))\r\ngoto retry;\r\n}\r\nvoid sas_resume_sata(struct asd_sas_port *port)\r\n{\r\nstruct domain_device *dev;\r\nretry:\r\nmutex_lock(&port->ha->disco_mutex);\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nstruct sata_device *sata;\r\nif (!dev_is_sata(dev))\r\ncontinue;\r\nsata = &dev->sata_dev;\r\nif (sata->ap->pm_mesg.event == PM_EVENT_ON)\r\ncontinue;\r\nsata->pm_result = -EIO;\r\nata_sas_port_async_resume(sata->ap, &sata->pm_result);\r\n}\r\nmutex_unlock(&port->ha->disco_mutex);\r\nif (sas_ata_flush_pm_eh(port, __func__))\r\ngoto retry;\r\n}\r\nint sas_discover_sata(struct domain_device *dev)\r\n{\r\nint res;\r\nif (dev->dev_type == SAS_SATA_PM)\r\nreturn -ENODEV;\r\nsas_get_ata_command_set(dev);\r\nsas_fill_in_rphy(dev, dev->rphy);\r\nres = sas_notify_lldd_dev_found(dev);\r\nif (res)\r\nreturn res;\r\nsas_discover_event(dev->port, DISCE_PROBE);\r\nreturn 0;\r\n}\r\nstatic void async_sas_ata_eh(void *data, async_cookie_t cookie)\r\n{\r\nstruct domain_device *dev = data;\r\nstruct ata_port *ap = dev->sata_dev.ap;\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nsas_ata_printk(KERN_DEBUG, dev, "dev error handler\n");\r\nata_scsi_port_error_handler(ha->core.shost, ap);\r\nsas_put_device(dev);\r\n}\r\nvoid sas_ata_strategy_handler(struct Scsi_Host *shost)\r\n{\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nASYNC_DOMAIN_EXCLUSIVE(async);\r\nint i;\r\nsas_disable_revalidation(sas_ha);\r\nspin_lock_irq(&sas_ha->phy_port_lock);\r\nfor (i = 0; i < sas_ha->num_phys; i++) {\r\nstruct asd_sas_port *port = sas_ha->sas_port[i];\r\nstruct domain_device *dev;\r\nspin_lock(&port->dev_list_lock);\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nif (!dev_is_sata(dev))\r\ncontinue;\r\nkref_get(&dev->kref);\r\nasync_schedule_domain(async_sas_ata_eh, dev, &async);\r\n}\r\nspin_unlock(&port->dev_list_lock);\r\n}\r\nspin_unlock_irq(&sas_ha->phy_port_lock);\r\nasync_synchronize_full_domain(&async);\r\nsas_enable_revalidation(sas_ha);\r\n}\r\nvoid sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *cmd, *n;\r\nstruct domain_device *eh_dev;\r\ndo {\r\nLIST_HEAD(sata_q);\r\neh_dev = NULL;\r\nlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\r\nstruct domain_device *ddev = cmd_to_domain_dev(cmd);\r\nif (!dev_is_sata(ddev) || TO_SAS_TASK(cmd))\r\ncontinue;\r\nif (eh_dev && eh_dev != ddev)\r\ncontinue;\r\neh_dev = ddev;\r\nlist_move(&cmd->eh_entry, &sata_q);\r\n}\r\nif (!list_empty(&sata_q)) {\r\nstruct ata_port *ap = eh_dev->sata_dev.ap;\r\nsas_ata_printk(KERN_DEBUG, eh_dev, "cmd error handler\n");\r\nata_scsi_cmd_error_handler(shost, ap, &sata_q);\r\nwhile (!list_empty(&sata_q))\r\nlist_del_init(sata_q.next);\r\n}\r\n} while (eh_dev);\r\n}\r\nvoid sas_ata_schedule_reset(struct domain_device *dev)\r\n{\r\nstruct ata_eh_info *ehi;\r\nstruct ata_port *ap;\r\nunsigned long flags;\r\nif (!dev_is_sata(dev))\r\nreturn;\r\nap = dev->sata_dev.ap;\r\nehi = &ap->link.eh_info;\r\nspin_lock_irqsave(ap->lock, flags);\r\nehi->err_mask |= AC_ERR_TIMEOUT;\r\nehi->action |= ATA_EH_RESET;\r\nata_port_schedule_eh(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nvoid sas_ata_wait_eh(struct domain_device *dev)\r\n{\r\nstruct ata_port *ap;\r\nif (!dev_is_sata(dev))\r\nreturn;\r\nap = dev->sata_dev.ap;\r\nata_port_wait_eh(ap);\r\n}
