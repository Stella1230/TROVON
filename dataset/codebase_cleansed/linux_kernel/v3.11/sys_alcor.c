static inline void\r\nalcor_update_irq_hw(unsigned long mask)\r\n{\r\n*(vuip)GRU_INT_MASK = mask;\r\nmb();\r\n}\r\nstatic inline void\r\nalcor_enable_irq(struct irq_data *d)\r\n{\r\nalcor_update_irq_hw(cached_irq_mask |= 1UL << (d->irq - 16));\r\n}\r\nstatic void\r\nalcor_disable_irq(struct irq_data *d)\r\n{\r\nalcor_update_irq_hw(cached_irq_mask &= ~(1UL << (d->irq - 16)));\r\n}\r\nstatic void\r\nalcor_mask_and_ack_irq(struct irq_data *d)\r\n{\r\nalcor_disable_irq(d);\r\n*(vuip)GRU_INT_CLEAR = 1 << (d->irq - 16); mb();\r\n*(vuip)GRU_INT_CLEAR = 0; mb();\r\n}\r\nstatic void\r\nalcor_isa_mask_and_ack_irq(struct irq_data *d)\r\n{\r\ni8259a_mask_and_ack_irq(d);\r\n*(vuip)GRU_INT_CLEAR = 0x80000000; mb();\r\n*(vuip)GRU_INT_CLEAR = 0; mb();\r\n}\r\nstatic void\r\nalcor_device_interrupt(unsigned long vector)\r\n{\r\nunsigned long pld;\r\nunsigned int i;\r\npld = (*(vuip)GRU_INT_REQ) & GRU_INT_REQ_BITS;\r\nwhile (pld) {\r\ni = ffz(~pld);\r\npld &= pld - 1;\r\nif (i == 31) {\r\nisa_device_interrupt(vector);\r\n} else {\r\nhandle_irq(16 + i);\r\n}\r\n}\r\n}\r\nstatic void __init\r\nalcor_init_irq(void)\r\n{\r\nlong i;\r\nif (alpha_using_srm)\r\nalpha_mv.device_interrupt = srm_device_interrupt;\r\n*(vuip)GRU_INT_MASK = 0; mb();\r\n*(vuip)GRU_INT_EDGE = 0; mb();\r\n*(vuip)GRU_INT_HILO = 0x80000000U; mb();\r\n*(vuip)GRU_INT_CLEAR = 0; mb();\r\nfor (i = 16; i < 48; ++i) {\r\nif (i >= 16+20 && i <= 16+30)\r\ncontinue;\r\nirq_set_chip_and_handler(i, &alcor_irq_type, handle_level_irq);\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\ni8259a_irq_type.irq_ack = alcor_isa_mask_and_ack_irq;\r\ninit_i8259a_irqs();\r\ncommon_init_isa_dma();\r\nsetup_irq(16+31, &isa_cascade_irqaction);\r\n}\r\nstatic int __init\r\nalcor_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[7][5] __initdata = {\r\n{16+13, 16+13, 16+13, 16+13, 16+13},\r\n{ 16+8, 16+8, 16+9, 16+10, 16+11},\r\n{16+16, 16+16, 16+17, 16+18, 16+19},\r\n{16+12, 16+12, 16+13, 16+14, 16+15},\r\n{ -1, -1, -1, -1, -1},\r\n{ 16+0, 16+0, 16+1, 16+2, 16+3},\r\n{ 16+4, 16+4, 16+5, 16+6, 16+7},\r\n};\r\nconst long min_idsel = 6, max_idsel = 12, irqs_per_slot = 5;\r\nreturn COMMON_TABLE_LOOKUP;\r\n}\r\nstatic void\r\nalcor_kill_arch(int mode)\r\n{\r\ncia_kill_arch(mode);\r\n#ifndef ALPHA_RESTORE_SRM_SETUP\r\nswitch(mode) {\r\ncase LINUX_REBOOT_CMD_RESTART:\r\nif (alpha_using_srm) {\r\n*(vuip) GRU_RESET = 0x0000dead;\r\nmb();\r\n}\r\nbreak;\r\ncase LINUX_REBOOT_CMD_HALT:\r\nbreak;\r\ncase LINUX_REBOOT_CMD_POWER_OFF:\r\nbreak;\r\n}\r\nhalt();\r\n#endif\r\n}\r\nstatic void __init\r\nalcor_init_pci(void)\r\n{\r\nstruct pci_dev *dev;\r\ncia_init_pci();\r\ndev = pci_get_device(PCI_VENDOR_ID_DEC,\r\nPCI_DEVICE_ID_DEC_TULIP,\r\nNULL);\r\nif (dev && dev->devfn == PCI_DEVFN(6,0)) {\r\nalpha_mv.sys.cia.gru_int_req_bits = XLT_GRU_INT_REQ_BITS;\r\nprintk(KERN_INFO "%s: Detected AS500 or XLT motherboard.\n",\r\n__func__);\r\n}\r\npci_dev_put(dev);\r\n}
