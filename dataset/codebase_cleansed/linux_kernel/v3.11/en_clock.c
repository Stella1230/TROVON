int mlx4_en_timestamp_config(struct net_device *dev, int tx_type, int rx_filter)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint port_up = 0;\r\nint err = 0;\r\nmutex_lock(&mdev->state_lock);\r\nif (priv->port_up) {\r\nport_up = 1;\r\nmlx4_en_stop_port(dev, 1);\r\n}\r\nmlx4_en_free_resources(priv);\r\nen_warn(priv, "Changing Time Stamp configuration\n");\r\npriv->hwtstamp_config.tx_type = tx_type;\r\npriv->hwtstamp_config.rx_filter = rx_filter;\r\nif (rx_filter != HWTSTAMP_FILTER_NONE)\r\ndev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\r\nelse\r\ndev->features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nerr = mlx4_en_alloc_resources(priv);\r\nif (err) {\r\nen_err(priv, "Failed reallocating port resources\n");\r\ngoto out;\r\n}\r\nif (port_up) {\r\nerr = mlx4_en_start_port(dev);\r\nif (err)\r\nen_err(priv, "Failed starting port\n");\r\n}\r\nout:\r\nmutex_unlock(&mdev->state_lock);\r\nnetdev_features_change(dev);\r\nreturn err;\r\n}\r\nstatic cycle_t mlx4_en_read_clock(const struct cyclecounter *tc)\r\n{\r\nstruct mlx4_en_dev *mdev =\r\ncontainer_of(tc, struct mlx4_en_dev, cycles);\r\nstruct mlx4_dev *dev = mdev->dev;\r\nreturn mlx4_read_clock(dev) & tc->mask;\r\n}\r\nu64 mlx4_en_get_cqe_ts(struct mlx4_cqe *cqe)\r\n{\r\nu64 hi, lo;\r\nstruct mlx4_ts_cqe *ts_cqe = (struct mlx4_ts_cqe *)cqe;\r\nlo = (u64)be16_to_cpu(ts_cqe->timestamp_lo);\r\nhi = ((u64)be32_to_cpu(ts_cqe->timestamp_hi) + !lo) << 16;\r\nreturn hi | lo;\r\n}\r\nvoid mlx4_en_fill_hwtstamps(struct mlx4_en_dev *mdev,\r\nstruct skb_shared_hwtstamps *hwts,\r\nu64 timestamp)\r\n{\r\nu64 nsec;\r\nnsec = timecounter_cyc2time(&mdev->clock, timestamp);\r\nmemset(hwts, 0, sizeof(struct skb_shared_hwtstamps));\r\nhwts->hwtstamp = ns_to_ktime(nsec);\r\n}\r\nvoid mlx4_en_init_timestamp(struct mlx4_en_dev *mdev)\r\n{\r\nstruct mlx4_dev *dev = mdev->dev;\r\nu64 ns;\r\nmemset(&mdev->cycles, 0, sizeof(mdev->cycles));\r\nmdev->cycles.read = mlx4_en_read_clock;\r\nmdev->cycles.mask = CLOCKSOURCE_MASK(48);\r\nmdev->cycles.shift = 14;\r\nmdev->cycles.mult =\r\nclocksource_khz2mult(1000 * dev->caps.hca_core_clock, mdev->cycles.shift);\r\ntimecounter_init(&mdev->clock, &mdev->cycles,\r\nktime_to_ns(ktime_get_real()));\r\nns = cyclecounter_cyc2ns(&mdev->cycles, mdev->cycles.mask);\r\ndo_div(ns, NSEC_PER_SEC / 2 / HZ);\r\nmdev->overflow_period = ns;\r\n}\r\nvoid mlx4_en_ptp_overflow_check(struct mlx4_en_dev *mdev)\r\n{\r\nbool timeout = time_is_before_jiffies(mdev->last_overflow_check +\r\nmdev->overflow_period);\r\nif (timeout) {\r\ntimecounter_read(&mdev->clock);\r\nmdev->last_overflow_check = jiffies;\r\n}\r\n}
