static irqreturn_t l3_interrupt_handler(int irq, void *_l3)\r\n{\r\nstruct omap4_l3 *l3 = _l3;\r\nint inttype, i, k;\r\nint err_src = 0;\r\nu32 std_err_main, err_reg, clear, masterid;\r\nvoid __iomem *base, *l3_targ_base;\r\nchar *target_name, *master_name = "UN IDENTIFIED";\r\ninttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;\r\nfor (i = 0; i < L3_MODULES; i++) {\r\nbase = l3->l3_base[i];\r\nerr_reg = __raw_readl(base + l3_flagmux[i] +\r\n+ L3_FLAGMUX_REGERR0 + (inttype << 3));\r\nif (err_reg) {\r\nerr_src = __ffs(err_reg);\r\nl3_targ_base = base + *(l3_targ[i] + err_src);\r\nstd_err_main = __raw_readl(l3_targ_base +\r\nL3_TARG_STDERRLOG_MAIN);\r\nmasterid = __raw_readl(l3_targ_base +\r\nL3_TARG_STDERRLOG_MSTADDR);\r\nswitch (std_err_main & CUSTOM_ERROR) {\r\ncase STANDARD_ERROR:\r\ntarget_name =\r\nl3_targ_inst_name[i][err_src];\r\nWARN(true, "L3 standard error: TARGET:%s at address 0x%x\n",\r\ntarget_name,\r\n__raw_readl(l3_targ_base +\r\nL3_TARG_STDERRLOG_SLVOFSLSB));\r\nclear = std_err_main | CLEAR_STDERR_LOG;\r\nwritel(clear, l3_targ_base +\r\nL3_TARG_STDERRLOG_MAIN);\r\nbreak;\r\ncase CUSTOM_ERROR:\r\ntarget_name =\r\nl3_targ_inst_name[i][err_src];\r\nfor (k = 0; k < NUM_OF_L3_MASTERS; k++) {\r\nif (masterid == l3_masters[k].id)\r\nmaster_name =\r\nl3_masters[k].name;\r\n}\r\nWARN(true, "L3 custom error: MASTER:%s TARGET:%s\n",\r\nmaster_name, target_name);\r\nclear = std_err_main | CLEAR_STDERR_LOG;\r\nwritel(clear, l3_targ_base +\r\nL3_TARG_STDERRLOG_MAIN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap4_l3_probe(struct platform_device *pdev)\r\n{\r\nstatic struct omap4_l3 *l3;\r\nstruct resource *res;\r\nint ret;\r\nl3 = kzalloc(sizeof(*l3), GFP_KERNEL);\r\nif (!l3)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, l3);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource 0\n");\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nl3->l3_base[0] = ioremap(res->start, resource_size(res));\r\nif (!l3->l3_base[0]) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource 1\n");\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\nl3->l3_base[1] = ioremap(res->start, resource_size(res));\r\nif (!l3->l3_base[1]) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (!res) {\r\ndev_err(&pdev->dev, "couldn't find resource 2\n");\r\nret = -ENODEV;\r\ngoto err2;\r\n}\r\nl3->l3_base[2] = ioremap(res->start, resource_size(res));\r\nif (!l3->l3_base[2]) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nl3->debug_irq = platform_get_irq(pdev, 0);\r\nret = request_irq(l3->debug_irq,\r\nl3_interrupt_handler,\r\nIRQF_DISABLED, "l3-dbg-irq", l3);\r\nif (ret) {\r\npr_crit("L3: request_irq failed to register for 0x%x\n",\r\nl3->debug_irq);\r\ngoto err3;\r\n}\r\nl3->app_irq = platform_get_irq(pdev, 1);\r\nret = request_irq(l3->app_irq,\r\nl3_interrupt_handler,\r\nIRQF_DISABLED, "l3-app-irq", l3);\r\nif (ret) {\r\npr_crit("L3: request_irq failed to register for 0x%x\n",\r\nl3->app_irq);\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\nfree_irq(l3->debug_irq, l3);\r\nerr3:\r\niounmap(l3->l3_base[2]);\r\nerr2:\r\niounmap(l3->l3_base[1]);\r\nerr1:\r\niounmap(l3->l3_base[0]);\r\nerr0:\r\nkfree(l3);\r\nreturn ret;\r\n}\r\nstatic int omap4_l3_remove(struct platform_device *pdev)\r\n{\r\nstruct omap4_l3 *l3 = platform_get_drvdata(pdev);\r\nfree_irq(l3->app_irq, l3);\r\nfree_irq(l3->debug_irq, l3);\r\niounmap(l3->l3_base[0]);\r\niounmap(l3->l3_base[1]);\r\niounmap(l3->l3_base[2]);\r\nkfree(l3);\r\nreturn 0;\r\n}\r\nstatic int __init omap4_l3_init(void)\r\n{\r\nreturn platform_driver_register(&omap4_l3_driver);\r\n}\r\nstatic void __exit omap4_l3_exit(void)\r\n{\r\nplatform_driver_unregister(&omap4_l3_driver);\r\n}
