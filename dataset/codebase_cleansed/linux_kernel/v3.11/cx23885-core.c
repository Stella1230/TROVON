static void cx23885_irq_add(struct cx23885_dev *dev, u32 mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\r\ndev->pci_irqmask |= mask;\r\nspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\r\n}\r\nvoid cx23885_irq_add_enable(struct cx23885_dev *dev, u32 mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\r\ndev->pci_irqmask |= mask;\r\ncx_set(PCI_INT_MSK, mask);\r\nspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\r\n}\r\nvoid cx23885_irq_enable(struct cx23885_dev *dev, u32 mask)\r\n{\r\nu32 v;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\r\nv = mask & dev->pci_irqmask;\r\nif (v)\r\ncx_set(PCI_INT_MSK, v);\r\nspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\r\n}\r\nstatic inline void cx23885_irq_enable_all(struct cx23885_dev *dev)\r\n{\r\ncx23885_irq_enable(dev, 0xffffffff);\r\n}\r\nvoid cx23885_irq_disable(struct cx23885_dev *dev, u32 mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\r\ncx_clear(PCI_INT_MSK, mask);\r\nspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\r\n}\r\nstatic inline void cx23885_irq_disable_all(struct cx23885_dev *dev)\r\n{\r\ncx23885_irq_disable(dev, 0xffffffff);\r\n}\r\nvoid cx23885_irq_remove(struct cx23885_dev *dev, u32 mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\r\ndev->pci_irqmask &= ~mask;\r\ncx_clear(PCI_INT_MSK, mask);\r\nspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\r\n}\r\nstatic u32 cx23885_irq_get_mask(struct cx23885_dev *dev)\r\n{\r\nu32 v;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->pci_irqmask_lock, flags);\r\nv = cx_read(PCI_INT_MSK);\r\nspin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);\r\nreturn v;\r\n}\r\nstatic int cx23885_risc_decode(u32 risc)\r\n{\r\nstatic char *instr[16] = {\r\n[RISC_SYNC >> 28] = "sync",\r\n[RISC_WRITE >> 28] = "write",\r\n[RISC_WRITEC >> 28] = "writec",\r\n[RISC_READ >> 28] = "read",\r\n[RISC_READC >> 28] = "readc",\r\n[RISC_JUMP >> 28] = "jump",\r\n[RISC_SKIP >> 28] = "skip",\r\n[RISC_WRITERM >> 28] = "writerm",\r\n[RISC_WRITECM >> 28] = "writecm",\r\n[RISC_WRITECR >> 28] = "writecr",\r\n};\r\nstatic int incr[16] = {\r\n[RISC_WRITE >> 28] = 3,\r\n[RISC_JUMP >> 28] = 3,\r\n[RISC_SKIP >> 28] = 1,\r\n[RISC_SYNC >> 28] = 1,\r\n[RISC_WRITERM >> 28] = 3,\r\n[RISC_WRITECM >> 28] = 3,\r\n[RISC_WRITECR >> 28] = 4,\r\n};\r\nstatic char *bits[] = {\r\n"12", "13", "14", "resync",\r\n"cnt0", "cnt1", "18", "19",\r\n"20", "21", "22", "23",\r\n"irq1", "irq2", "eol", "sol",\r\n};\r\nint i;\r\nprintk("0x%08x [ %s", risc,\r\ninstr[risc >> 28] ? instr[risc >> 28] : "INVALID");\r\nfor (i = ARRAY_SIZE(bits) - 1; i >= 0; i--)\r\nif (risc & (1 << (i + 12)))\r\nprintk(" %s", bits[i]);\r\nprintk(" count=%d ]\n", risc & 0xfff);\r\nreturn incr[risc >> 28] ? incr[risc >> 28] : 1;\r\n}\r\nvoid cx23885_wakeup(struct cx23885_tsport *port,\r\nstruct cx23885_dmaqueue *q, u32 count)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_buffer *buf;\r\nint bc;\r\nfor (bc = 0;; bc++) {\r\nif (list_empty(&q->active))\r\nbreak;\r\nbuf = list_entry(q->active.next,\r\nstruct cx23885_buffer, vb.queue);\r\nif ((s16) (count - buf->count) < 0)\r\nbreak;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\ndprintk(2, "[%p/%d] wakeup reg=%d buf=%d\n", buf, buf->vb.i,\r\ncount, buf->count);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nif (list_empty(&q->active))\r\ndel_timer(&q->timeout);\r\nelse\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\nif (bc != 1)\r\nprintk(KERN_WARNING "%s: %d buffers handled (should be 1)\n",\r\n__func__, bc);\r\n}\r\nint cx23885_sram_channel_setup(struct cx23885_dev *dev,\r\nstruct sram_channel *ch,\r\nunsigned int bpl, u32 risc)\r\n{\r\nunsigned int i, lines;\r\nu32 cdt;\r\nif (ch->cmds_start == 0) {\r\ndprintk(1, "%s() Erasing channel [%s]\n", __func__,\r\nch->name);\r\ncx_write(ch->ptr1_reg, 0);\r\ncx_write(ch->ptr2_reg, 0);\r\ncx_write(ch->cnt2_reg, 0);\r\ncx_write(ch->cnt1_reg, 0);\r\nreturn 0;\r\n} else {\r\ndprintk(1, "%s() Configuring channel [%s]\n", __func__,\r\nch->name);\r\n}\r\nbpl = (bpl + 7) & ~7;\r\ncdt = ch->cdt;\r\nlines = ch->fifo_size / bpl;\r\nif (lines > 6)\r\nlines = 6;\r\nBUG_ON(lines < 2);\r\ncx_write(8 + 0, RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\ncx_write(8 + 4, 8);\r\ncx_write(8 + 8, 0);\r\nfor (i = 0; i < lines; i++) {\r\ndprintk(2, "%s() 0x%08x <- 0x%08x\n", __func__, cdt + 16*i,\r\nch->fifo_start + bpl*i);\r\ncx_write(cdt + 16*i, ch->fifo_start + bpl*i);\r\ncx_write(cdt + 16*i + 4, 0);\r\ncx_write(cdt + 16*i + 8, 0);\r\ncx_write(cdt + 16*i + 12, 0);\r\n}\r\nif (ch->jumponly)\r\ncx_write(ch->cmds_start + 0, 8);\r\nelse\r\ncx_write(ch->cmds_start + 0, risc);\r\ncx_write(ch->cmds_start + 4, 0);\r\ncx_write(ch->cmds_start + 8, cdt);\r\ncx_write(ch->cmds_start + 12, (lines*16) >> 3);\r\ncx_write(ch->cmds_start + 16, ch->ctrl_start);\r\nif (ch->jumponly)\r\ncx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));\r\nelse\r\ncx_write(ch->cmds_start + 20, 64 >> 2);\r\nfor (i = 24; i < 80; i += 4)\r\ncx_write(ch->cmds_start + i, 0);\r\ncx_write(ch->ptr1_reg, ch->fifo_start);\r\ncx_write(ch->ptr2_reg, cdt);\r\ncx_write(ch->cnt2_reg, (lines*16) >> 3);\r\ncx_write(ch->cnt1_reg, (bpl >> 3) - 1);\r\ndprintk(2, "[bridge %d] sram setup %s: bpl=%d lines=%d\n",\r\ndev->bridge,\r\nch->name,\r\nbpl,\r\nlines);\r\nreturn 0;\r\n}\r\nvoid cx23885_sram_channel_dump(struct cx23885_dev *dev,\r\nstruct sram_channel *ch)\r\n{\r\nstatic char *name[] = {\r\n"init risc lo",\r\n"init risc hi",\r\n"cdt base",\r\n"cdt size",\r\n"iq base",\r\n"iq size",\r\n"risc pc lo",\r\n"risc pc hi",\r\n"iq wr ptr",\r\n"iq rd ptr",\r\n"cdt current",\r\n"pci target lo",\r\n"pci target hi",\r\n"line / byte",\r\n};\r\nu32 risc;\r\nunsigned int i, j, n;\r\nprintk(KERN_WARNING "%s: %s - dma channel status dump\n",\r\ndev->name, ch->name);\r\nfor (i = 0; i < ARRAY_SIZE(name); i++)\r\nprintk(KERN_WARNING "%s: cmds: %-15s: 0x%08x\n",\r\ndev->name, name[i],\r\ncx_read(ch->cmds_start + 4*i));\r\nfor (i = 0; i < 4; i++) {\r\nrisc = cx_read(ch->cmds_start + 4 * (i + 14));\r\nprintk(KERN_WARNING "%s: risc%d: ", dev->name, i);\r\ncx23885_risc_decode(risc);\r\n}\r\nfor (i = 0; i < (64 >> 2); i += n) {\r\nrisc = cx_read(ch->ctrl_start + 4 * i);\r\nprintk(KERN_WARNING "%s: (0x%08x) iq %x: ", dev->name,\r\nch->ctrl_start + 4 * i, i);\r\nn = cx23885_risc_decode(risc);\r\nfor (j = 1; j < n; j++) {\r\nrisc = cx_read(ch->ctrl_start + 4 * (i + j));\r\nprintk(KERN_WARNING "%s: iq %x: 0x%08x [ arg #%d ]\n",\r\ndev->name, i+j, risc, j);\r\n}\r\n}\r\nprintk(KERN_WARNING "%s: fifo: 0x%08x -> 0x%x\n",\r\ndev->name, ch->fifo_start, ch->fifo_start+ch->fifo_size);\r\nprintk(KERN_WARNING "%s: ctrl: 0x%08x -> 0x%x\n",\r\ndev->name, ch->ctrl_start, ch->ctrl_start + 6*16);\r\nprintk(KERN_WARNING "%s: ptr1_reg: 0x%08x\n",\r\ndev->name, cx_read(ch->ptr1_reg));\r\nprintk(KERN_WARNING "%s: ptr2_reg: 0x%08x\n",\r\ndev->name, cx_read(ch->ptr2_reg));\r\nprintk(KERN_WARNING "%s: cnt1_reg: 0x%08x\n",\r\ndev->name, cx_read(ch->cnt1_reg));\r\nprintk(KERN_WARNING "%s: cnt2_reg: 0x%08x\n",\r\ndev->name, cx_read(ch->cnt2_reg));\r\n}\r\nstatic void cx23885_risc_disasm(struct cx23885_tsport *port,\r\nstruct btcx_riscmem *risc)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nunsigned int i, j, n;\r\nprintk(KERN_INFO "%s: risc disasm: %p [dma=0x%08lx]\n",\r\ndev->name, risc->cpu, (unsigned long)risc->dma);\r\nfor (i = 0; i < (risc->size >> 2); i += n) {\r\nprintk(KERN_INFO "%s: %04d: ", dev->name, i);\r\nn = cx23885_risc_decode(le32_to_cpu(risc->cpu[i]));\r\nfor (j = 1; j < n; j++)\r\nprintk(KERN_INFO "%s: %04d: 0x%08x [ arg #%d ]\n",\r\ndev->name, i + j, risc->cpu[i + j], j);\r\nif (risc->cpu[i] == cpu_to_le32(RISC_JUMP))\r\nbreak;\r\n}\r\n}\r\nstatic void cx23885_shutdown(struct cx23885_dev *dev)\r\n{\r\ncx_write(DEV_CNTRL2, 0);\r\ncx_write(IR_CNTRL_REG, 0);\r\ncx_write(VID_A_DMA_CTL, 0);\r\ncx_write(VID_B_DMA_CTL, 0);\r\ncx_write(VID_C_DMA_CTL, 0);\r\ncx_write(AUD_INT_DMA_CTL, 0);\r\ncx_write(AUD_EXT_DMA_CTL, 0);\r\ncx_write(UART_CTL, 0);\r\ncx23885_irq_disable_all(dev);\r\ncx_write(VID_A_INT_MSK, 0);\r\ncx_write(VID_B_INT_MSK, 0);\r\ncx_write(VID_C_INT_MSK, 0);\r\ncx_write(AUDIO_INT_INT_MSK, 0);\r\ncx_write(AUDIO_EXT_INT_MSK, 0);\r\n}\r\nstatic void cx23885_reset(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx23885_shutdown(dev);\r\ncx_write(PCI_INT_STAT, 0xffffffff);\r\ncx_write(VID_A_INT_STAT, 0xffffffff);\r\ncx_write(VID_B_INT_STAT, 0xffffffff);\r\ncx_write(VID_C_INT_STAT, 0xffffffff);\r\ncx_write(AUDIO_INT_INT_STAT, 0xffffffff);\r\ncx_write(AUDIO_EXT_INT_STAT, 0xffffffff);\r\ncx_write(CLK_DELAY, cx_read(CLK_DELAY) & 0x80000000);\r\ncx_write(PAD_CTRL, 0x00500300);\r\nmdelay(100);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH01],\r\n720*4, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH02], 128, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH03],\r\n188*4, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH04], 128, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH05], 128, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH06],\r\n188*4, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH07], 128, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH08], 128, 0);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH09], 128, 0);\r\ncx23885_gpio_setup(dev);\r\n}\r\nstatic int cx23885_pci_quirks(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nif (dev->bridge == CX23885_BRIDGE_885)\r\ncx_clear(RDR_TLCTL0, 1 << 4);\r\nreturn 0;\r\n}\r\nstatic int get_resources(struct cx23885_dev *dev)\r\n{\r\nif (request_mem_region(pci_resource_start(dev->pci, 0),\r\npci_resource_len(dev->pci, 0),\r\ndev->name))\r\nreturn 0;\r\nprintk(KERN_ERR "%s: can't get MMIO memory @ 0x%llx\n",\r\ndev->name, (unsigned long long)pci_resource_start(dev->pci, 0));\r\nreturn -EBUSY;\r\n}\r\nstatic int cx23885_init_tsport(struct cx23885_dev *dev,\r\nstruct cx23885_tsport *port, int portno)\r\n{\r\ndprintk(1, "%s(portno=%d)\n", __func__, portno);\r\nport->dma_ctl_val = 0x11;\r\nport->ts_int_msk_val = 0x1111;\r\nport->vld_misc_val = 0x0;\r\nport->hw_sop_ctrl_val = (0x47 << 16 | 188 << 4);\r\nspin_lock_init(&port->slock);\r\nport->dev = dev;\r\nport->nr = portno;\r\nINIT_LIST_HEAD(&port->mpegq.active);\r\nINIT_LIST_HEAD(&port->mpegq.queued);\r\nport->mpegq.timeout.function = cx23885_timeout;\r\nport->mpegq.timeout.data = (unsigned long)port;\r\ninit_timer(&port->mpegq.timeout);\r\nmutex_init(&port->frontends.lock);\r\nINIT_LIST_HEAD(&port->frontends.felist);\r\nport->frontends.active_fe_id = 0;\r\nif (!port->num_frontends)\r\nport->num_frontends = 1;\r\nswitch (portno) {\r\ncase 1:\r\nport->reg_gpcnt = VID_B_GPCNT;\r\nport->reg_gpcnt_ctl = VID_B_GPCNT_CTL;\r\nport->reg_dma_ctl = VID_B_DMA_CTL;\r\nport->reg_lngth = VID_B_LNGTH;\r\nport->reg_hw_sop_ctrl = VID_B_HW_SOP_CTL;\r\nport->reg_gen_ctrl = VID_B_GEN_CTL;\r\nport->reg_bd_pkt_status = VID_B_BD_PKT_STATUS;\r\nport->reg_sop_status = VID_B_SOP_STATUS;\r\nport->reg_fifo_ovfl_stat = VID_B_FIFO_OVFL_STAT;\r\nport->reg_vld_misc = VID_B_VLD_MISC;\r\nport->reg_ts_clk_en = VID_B_TS_CLK_EN;\r\nport->reg_src_sel = VID_B_SRC_SEL;\r\nport->reg_ts_int_msk = VID_B_INT_MSK;\r\nport->reg_ts_int_stat = VID_B_INT_STAT;\r\nport->sram_chno = SRAM_CH03;\r\nport->pci_irqmask = 0x02;\r\nbreak;\r\ncase 2:\r\nport->reg_gpcnt = VID_C_GPCNT;\r\nport->reg_gpcnt_ctl = VID_C_GPCNT_CTL;\r\nport->reg_dma_ctl = VID_C_DMA_CTL;\r\nport->reg_lngth = VID_C_LNGTH;\r\nport->reg_hw_sop_ctrl = VID_C_HW_SOP_CTL;\r\nport->reg_gen_ctrl = VID_C_GEN_CTL;\r\nport->reg_bd_pkt_status = VID_C_BD_PKT_STATUS;\r\nport->reg_sop_status = VID_C_SOP_STATUS;\r\nport->reg_fifo_ovfl_stat = VID_C_FIFO_OVFL_STAT;\r\nport->reg_vld_misc = VID_C_VLD_MISC;\r\nport->reg_ts_clk_en = VID_C_TS_CLK_EN;\r\nport->reg_src_sel = 0;\r\nport->reg_ts_int_msk = VID_C_INT_MSK;\r\nport->reg_ts_int_stat = VID_C_INT_STAT;\r\nport->sram_chno = SRAM_CH06;\r\nport->pci_irqmask = 0x04;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ncx23885_risc_stopper(dev->pci, &port->mpegq.stopper,\r\nport->reg_dma_ctl, port->dma_ctl_val, 0x00);\r\nreturn 0;\r\n}\r\nstatic void cx23885_dev_checkrevision(struct cx23885_dev *dev)\r\n{\r\nswitch (cx_read(RDR_CFG2) & 0xff) {\r\ncase 0x00:\r\ndev->hwrevision = 0xa0;\r\nbreak;\r\ncase 0x01:\r\ndev->hwrevision = 0xa1;\r\nbreak;\r\ncase 0x02:\r\ndev->hwrevision = 0xb0;\r\nbreak;\r\ncase 0x03:\r\nif (dev->pci->device == 0x8880) {\r\ndev->hwrevision = 0xc0;\r\n} else {\r\ndev->hwrevision = 0xa4;\r\n}\r\nbreak;\r\ncase 0x04:\r\nif (dev->pci->device == 0x8880) {\r\ndev->hwrevision = 0xd0;\r\n} else {\r\ndev->hwrevision = 0xa5;\r\n}\r\nbreak;\r\ncase 0x0e:\r\ndev->hwrevision = 0xc0;\r\nbreak;\r\ncase 0x0f:\r\ndev->hwrevision = 0xb1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s() New hardware revision found 0x%x\n",\r\n__func__, dev->hwrevision);\r\n}\r\nif (dev->hwrevision)\r\nprintk(KERN_INFO "%s() Hardware revision = 0x%02x\n",\r\n__func__, dev->hwrevision);\r\nelse\r\nprintk(KERN_ERR "%s() Hardware revision unknown 0x%x\n",\r\n__func__, dev->hwrevision);\r\n}\r\nstruct v4l2_subdev *cx23885_find_hw(struct cx23885_dev *dev, u32 hw)\r\n{\r\nstruct v4l2_subdev *result = NULL;\r\nstruct v4l2_subdev *sd;\r\nspin_lock(&dev->v4l2_dev.lock);\r\nv4l2_device_for_each_subdev(sd, &dev->v4l2_dev) {\r\nif (sd->grp_id == hw) {\r\nresult = sd;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dev->v4l2_dev.lock);\r\nreturn result;\r\n}\r\nstatic int cx23885_dev_setup(struct cx23885_dev *dev)\r\n{\r\nint i;\r\nspin_lock_init(&dev->pci_irqmask_lock);\r\nmutex_init(&dev->lock);\r\nmutex_init(&dev->gpio_lock);\r\natomic_inc(&dev->refcount);\r\ndev->nr = cx23885_devcount++;\r\nsprintf(dev->name, "cx23885[%d]", dev->nr);\r\nif (dev->pci->device == 0x8880) {\r\ndev->bridge = CX23885_BRIDGE_887;\r\ndev->clk_freq = 25000000;\r\ndev->sram_channels = cx23887_sram_channels;\r\n} else\r\nif (dev->pci->device == 0x8852) {\r\ndev->bridge = CX23885_BRIDGE_885;\r\ndev->clk_freq = 28000000;\r\ndev->sram_channels = cx23885_sram_channels;\r\n} else\r\nBUG();\r\ndprintk(1, "%s() Memory configured for PCIe bridge type %d\n",\r\n__func__, dev->bridge);\r\ndev->board = UNSET;\r\nif (card[dev->nr] < cx23885_bcount)\r\ndev->board = card[dev->nr];\r\nfor (i = 0; UNSET == dev->board && i < cx23885_idcount; i++)\r\nif (dev->pci->subsystem_vendor == cx23885_subids[i].subvendor &&\r\ndev->pci->subsystem_device == cx23885_subids[i].subdevice)\r\ndev->board = cx23885_subids[i].card;\r\nif (UNSET == dev->board) {\r\ndev->board = CX23885_BOARD_UNKNOWN;\r\ncx23885_card_list(dev);\r\n}\r\nif (cx23885_boards[dev->board].clk_freq > 0)\r\ndev->clk_freq = cx23885_boards[dev->board].clk_freq;\r\ndev->pci_bus = dev->pci->bus->number;\r\ndev->pci_slot = PCI_SLOT(dev->pci->devfn);\r\ncx23885_irq_add(dev, 0x001f00);\r\ndev->i2c_bus[0].nr = 0;\r\ndev->i2c_bus[0].dev = dev;\r\ndev->i2c_bus[0].reg_stat = I2C1_STAT;\r\ndev->i2c_bus[0].reg_ctrl = I2C1_CTRL;\r\ndev->i2c_bus[0].reg_addr = I2C1_ADDR;\r\ndev->i2c_bus[0].reg_rdata = I2C1_RDATA;\r\ndev->i2c_bus[0].reg_wdata = I2C1_WDATA;\r\ndev->i2c_bus[0].i2c_period = (0x9d << 24);\r\ndev->i2c_bus[1].nr = 1;\r\ndev->i2c_bus[1].dev = dev;\r\ndev->i2c_bus[1].reg_stat = I2C2_STAT;\r\ndev->i2c_bus[1].reg_ctrl = I2C2_CTRL;\r\ndev->i2c_bus[1].reg_addr = I2C2_ADDR;\r\ndev->i2c_bus[1].reg_rdata = I2C2_RDATA;\r\ndev->i2c_bus[1].reg_wdata = I2C2_WDATA;\r\ndev->i2c_bus[1].i2c_period = (0x9d << 24);\r\ndev->i2c_bus[2].nr = 2;\r\ndev->i2c_bus[2].dev = dev;\r\ndev->i2c_bus[2].reg_stat = I2C3_STAT;\r\ndev->i2c_bus[2].reg_ctrl = I2C3_CTRL;\r\ndev->i2c_bus[2].reg_addr = I2C3_ADDR;\r\ndev->i2c_bus[2].reg_rdata = I2C3_RDATA;\r\ndev->i2c_bus[2].reg_wdata = I2C3_WDATA;\r\ndev->i2c_bus[2].i2c_period = (0x07 << 24);\r\nif ((cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) ||\r\n(cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER))\r\ncx23885_init_tsport(dev, &dev->ts1, 1);\r\nif ((cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) ||\r\n(cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER))\r\ncx23885_init_tsport(dev, &dev->ts2, 2);\r\nif (get_resources(dev) < 0) {\r\nprintk(KERN_ERR "CORE %s No more PCIe resources for "\r\n"subsystem: %04x:%04x\n",\r\ndev->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device);\r\ncx23885_devcount--;\r\nreturn -ENODEV;\r\n}\r\ndev->lmmio = ioremap(pci_resource_start(dev->pci, 0),\r\npci_resource_len(dev->pci, 0));\r\ndev->bmmio = (u8 __iomem *)dev->lmmio;\r\nprintk(KERN_INFO "CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",\r\ndev->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device, cx23885_boards[dev->board].name,\r\ndev->board, card[dev->nr] == dev->board ?\r\n"insmod option" : "autodetected");\r\ncx23885_pci_quirks(dev);\r\ndev->tuner_type = cx23885_boards[dev->board].tuner_type;\r\ndev->tuner_addr = cx23885_boards[dev->board].tuner_addr;\r\ndev->tuner_bus = cx23885_boards[dev->board].tuner_bus;\r\ndev->radio_type = cx23885_boards[dev->board].radio_type;\r\ndev->radio_addr = cx23885_boards[dev->board].radio_addr;\r\ndprintk(1, "%s() tuner_type = 0x%x tuner_addr = 0x%x tuner_bus = %d\n",\r\n__func__, dev->tuner_type, dev->tuner_addr, dev->tuner_bus);\r\ndprintk(1, "%s() radio_type = 0x%x radio_addr = 0x%x\n",\r\n__func__, dev->radio_type, dev->radio_addr);\r\nif ((cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) ||\r\n(cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER))\r\ncx23885_mc417_init(dev);\r\ncx23885_reset(dev);\r\ncx23885_i2c_register(&dev->i2c_bus[0]);\r\ncx23885_i2c_register(&dev->i2c_bus[1]);\r\ncx23885_i2c_register(&dev->i2c_bus[2]);\r\ncx23885_card_setup(dev);\r\ncall_all(dev, core, s_power, 0);\r\ncx23885_ir_init(dev);\r\nif (cx23885_boards[dev->board].porta == CX23885_ANALOG_VIDEO) {\r\nif (cx23885_video_register(dev) < 0) {\r\nprintk(KERN_ERR "%s() Failed to register analog "\r\n"video adapters on VID_A\n", __func__);\r\n}\r\n}\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) {\r\nif (cx23885_boards[dev->board].num_fds_portb)\r\ndev->ts1.num_frontends =\r\ncx23885_boards[dev->board].num_fds_portb;\r\nif (cx23885_dvb_register(&dev->ts1) < 0) {\r\nprintk(KERN_ERR "%s() Failed to register dvb adapters on VID_B\n",\r\n__func__);\r\n}\r\n} else\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {\r\nif (cx23885_417_register(dev) < 0) {\r\nprintk(KERN_ERR\r\n"%s() Failed to register 417 on VID_B\n",\r\n__func__);\r\n}\r\n}\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) {\r\nif (cx23885_boards[dev->board].num_fds_portc)\r\ndev->ts2.num_frontends =\r\ncx23885_boards[dev->board].num_fds_portc;\r\nif (cx23885_dvb_register(&dev->ts2) < 0) {\r\nprintk(KERN_ERR\r\n"%s() Failed to register dvb on VID_C\n",\r\n__func__);\r\n}\r\n} else\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER) {\r\nif (cx23885_417_register(dev) < 0) {\r\nprintk(KERN_ERR\r\n"%s() Failed to register 417 on VID_C\n",\r\n__func__);\r\n}\r\n}\r\ncx23885_dev_checkrevision(dev);\r\nif (cx23885_boards[dev->board].ci_type > 0)\r\ncx_clear(RDR_RDRCTL1, 1 << 8);\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_TEVII_S470:\r\ncase CX23885_BOARD_TEVII_S471:\r\ncx_clear(RDR_RDRCTL1, 1 << 8);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cx23885_dev_unregister(struct cx23885_dev *dev)\r\n{\r\nrelease_mem_region(pci_resource_start(dev->pci, 0),\r\npci_resource_len(dev->pci, 0));\r\nif (!atomic_dec_and_test(&dev->refcount))\r\nreturn;\r\nif (cx23885_boards[dev->board].porta == CX23885_ANALOG_VIDEO)\r\ncx23885_video_unregister(dev);\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)\r\ncx23885_dvb_unregister(&dev->ts1);\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\r\ncx23885_417_unregister(dev);\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB)\r\ncx23885_dvb_unregister(&dev->ts2);\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER)\r\ncx23885_417_unregister(dev);\r\ncx23885_i2c_unregister(&dev->i2c_bus[2]);\r\ncx23885_i2c_unregister(&dev->i2c_bus[1]);\r\ncx23885_i2c_unregister(&dev->i2c_bus[0]);\r\niounmap(dev->lmmio);\r\n}\r\nstatic __le32 *cx23885_risc_field(__le32 *rp, struct scatterlist *sglist,\r\nunsigned int offset, u32 sync_line,\r\nunsigned int bpl, unsigned int padding,\r\nunsigned int lines, unsigned int lpi)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int line, todo, sol;\r\nif (sync_line != NO_SYNC_LINE)\r\n*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\r\nsg = sglist;\r\nfor (line = 0; line < lines; line++) {\r\nwhile (offset && offset >= sg_dma_len(sg)) {\r\noffset -= sg_dma_len(sg);\r\nsg++;\r\n}\r\nif (lpi && line > 0 && !(line % lpi))\r\nsol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;\r\nelse\r\nsol = RISC_SOL;\r\nif (bpl <= sg_dma_len(sg)-offset) {\r\n*(rp++) = cpu_to_le32(RISC_WRITE|sol|RISC_EOL|bpl);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg)+offset);\r\n*(rp++) = cpu_to_le32(0);\r\noffset += bpl;\r\n} else {\r\ntodo = bpl;\r\n*(rp++) = cpu_to_le32(RISC_WRITE|sol|\r\n(sg_dma_len(sg)-offset));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg)+offset);\r\n*(rp++) = cpu_to_le32(0);\r\ntodo -= (sg_dma_len(sg)-offset);\r\noffset = 0;\r\nsg++;\r\nwhile (todo > sg_dma_len(sg)) {\r\n*(rp++) = cpu_to_le32(RISC_WRITE|\r\nsg_dma_len(sg));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\n*(rp++) = cpu_to_le32(0);\r\ntodo -= sg_dma_len(sg);\r\nsg++;\r\n}\r\n*(rp++) = cpu_to_le32(RISC_WRITE|RISC_EOL|todo);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\n*(rp++) = cpu_to_le32(0);\r\noffset += todo;\r\n}\r\noffset += padding;\r\n}\r\nreturn rp;\r\n}\r\nint cx23885_risc_buffer(struct pci_dev *pci, struct btcx_riscmem *risc,\r\nstruct scatterlist *sglist, unsigned int top_offset,\r\nunsigned int bottom_offset, unsigned int bpl,\r\nunsigned int padding, unsigned int lines)\r\n{\r\nu32 instructions, fields;\r\n__le32 *rp;\r\nint rc;\r\nfields = 0;\r\nif (UNSET != top_offset)\r\nfields++;\r\nif (UNSET != bottom_offset)\r\nfields++;\r\ninstructions = fields * (1 + ((bpl + padding) * lines)\r\n/ PAGE_SIZE + lines);\r\ninstructions += 2;\r\nrc = btcx_riscmem_alloc(pci, risc, instructions*12);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\nif (UNSET != top_offset)\r\nrp = cx23885_risc_field(rp, sglist, top_offset, 0,\r\nbpl, padding, lines, 0);\r\nif (UNSET != bottom_offset)\r\nrp = cx23885_risc_field(rp, sglist, bottom_offset, 0x200,\r\nbpl, padding, lines, 0);\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nint cx23885_risc_databuffer(struct pci_dev *pci,\r\nstruct btcx_riscmem *risc,\r\nstruct scatterlist *sglist,\r\nunsigned int bpl,\r\nunsigned int lines, unsigned int lpi)\r\n{\r\nu32 instructions;\r\n__le32 *rp;\r\nint rc;\r\ninstructions = 1 + (bpl * lines) / PAGE_SIZE + lines;\r\ninstructions += 1;\r\nrc = btcx_riscmem_alloc(pci, risc, instructions*12);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\nrp = cx23885_risc_field(rp, sglist, 0, NO_SYNC_LINE,\r\nbpl, 0, lines, lpi);\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nint cx23885_risc_vbibuffer(struct pci_dev *pci, struct btcx_riscmem *risc,\r\nstruct scatterlist *sglist, unsigned int top_offset,\r\nunsigned int bottom_offset, unsigned int bpl,\r\nunsigned int padding, unsigned int lines)\r\n{\r\nu32 instructions, fields;\r\n__le32 *rp;\r\nint rc;\r\nfields = 0;\r\nif (UNSET != top_offset)\r\nfields++;\r\nif (UNSET != bottom_offset)\r\nfields++;\r\ninstructions = fields * (1 + ((bpl + padding) * lines)\r\n/ PAGE_SIZE + lines);\r\ninstructions += 2;\r\nrc = btcx_riscmem_alloc(pci, risc, instructions*12);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\nif (UNSET != top_offset)\r\nrp = cx23885_risc_field(rp, sglist, top_offset, 6,\r\nbpl, padding, lines, 0);\r\nif (UNSET != bottom_offset)\r\nrp = cx23885_risc_field(rp, sglist, bottom_offset, 0x207,\r\nbpl, padding, lines, 0);\r\nrisc->jmp = rp;\r\nBUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nint cx23885_risc_stopper(struct pci_dev *pci, struct btcx_riscmem *risc,\r\nu32 reg, u32 mask, u32 value)\r\n{\r\n__le32 *rp;\r\nint rc;\r\nrc = btcx_riscmem_alloc(pci, risc, 4*16);\r\nif (rc < 0)\r\nreturn rc;\r\nrp = risc->cpu;\r\n*(rp++) = cpu_to_le32(RISC_WRITECR | RISC_IRQ2);\r\n*(rp++) = cpu_to_le32(reg);\r\n*(rp++) = cpu_to_le32(value);\r\n*(rp++) = cpu_to_le32(mask);\r\n*(rp++) = cpu_to_le32(RISC_JUMP);\r\n*(rp++) = cpu_to_le32(risc->dma);\r\n*(rp++) = cpu_to_le32(0);\r\nreturn 0;\r\n}\r\nvoid cx23885_free_buffer(struct videobuf_queue *q, struct cx23885_buffer *buf)\r\n{\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(q, &buf->vb, 0, 0);\r\nvideobuf_dma_unmap(q->dev, dma);\r\nvideobuf_dma_free(dma);\r\nbtcx_riscmem_free(to_pci_dev(q->dev), &buf->risc);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic void cx23885_tsport_reg_dump(struct cx23885_tsport *port)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\ndprintk(1, "%s() Register Dump\n", __func__);\r\ndprintk(1, "%s() DEV_CNTRL2 0x%08X\n", __func__,\r\ncx_read(DEV_CNTRL2));\r\ndprintk(1, "%s() PCI_INT_MSK 0x%08X\n", __func__,\r\ncx23885_irq_get_mask(dev));\r\ndprintk(1, "%s() AUD_INT_INT_MSK 0x%08X\n", __func__,\r\ncx_read(AUDIO_INT_INT_MSK));\r\ndprintk(1, "%s() AUD_INT_DMA_CTL 0x%08X\n", __func__,\r\ncx_read(AUD_INT_DMA_CTL));\r\ndprintk(1, "%s() AUD_EXT_INT_MSK 0x%08X\n", __func__,\r\ncx_read(AUDIO_EXT_INT_MSK));\r\ndprintk(1, "%s() AUD_EXT_DMA_CTL 0x%08X\n", __func__,\r\ncx_read(AUD_EXT_DMA_CTL));\r\ndprintk(1, "%s() PAD_CTRL 0x%08X\n", __func__,\r\ncx_read(PAD_CTRL));\r\ndprintk(1, "%s() ALT_PIN_OUT_SEL 0x%08X\n", __func__,\r\ncx_read(ALT_PIN_OUT_SEL));\r\ndprintk(1, "%s() GPIO2 0x%08X\n", __func__,\r\ncx_read(GPIO2));\r\ndprintk(1, "%s() gpcnt(0x%08X) 0x%08X\n", __func__,\r\nport->reg_gpcnt, cx_read(port->reg_gpcnt));\r\ndprintk(1, "%s() gpcnt_ctl(0x%08X) 0x%08x\n", __func__,\r\nport->reg_gpcnt_ctl, cx_read(port->reg_gpcnt_ctl));\r\ndprintk(1, "%s() dma_ctl(0x%08X) 0x%08x\n", __func__,\r\nport->reg_dma_ctl, cx_read(port->reg_dma_ctl));\r\nif (port->reg_src_sel)\r\ndprintk(1, "%s() src_sel(0x%08X) 0x%08x\n", __func__,\r\nport->reg_src_sel, cx_read(port->reg_src_sel));\r\ndprintk(1, "%s() lngth(0x%08X) 0x%08x\n", __func__,\r\nport->reg_lngth, cx_read(port->reg_lngth));\r\ndprintk(1, "%s() hw_sop_ctrl(0x%08X) 0x%08x\n", __func__,\r\nport->reg_hw_sop_ctrl, cx_read(port->reg_hw_sop_ctrl));\r\ndprintk(1, "%s() gen_ctrl(0x%08X) 0x%08x\n", __func__,\r\nport->reg_gen_ctrl, cx_read(port->reg_gen_ctrl));\r\ndprintk(1, "%s() bd_pkt_status(0x%08X) 0x%08x\n", __func__,\r\nport->reg_bd_pkt_status, cx_read(port->reg_bd_pkt_status));\r\ndprintk(1, "%s() sop_status(0x%08X) 0x%08x\n", __func__,\r\nport->reg_sop_status, cx_read(port->reg_sop_status));\r\ndprintk(1, "%s() fifo_ovfl_stat(0x%08X) 0x%08x\n", __func__,\r\nport->reg_fifo_ovfl_stat, cx_read(port->reg_fifo_ovfl_stat));\r\ndprintk(1, "%s() vld_misc(0x%08X) 0x%08x\n", __func__,\r\nport->reg_vld_misc, cx_read(port->reg_vld_misc));\r\ndprintk(1, "%s() ts_clk_en(0x%08X) 0x%08x\n", __func__,\r\nport->reg_ts_clk_en, cx_read(port->reg_ts_clk_en));\r\ndprintk(1, "%s() ts_int_msk(0x%08X) 0x%08x\n", __func__,\r\nport->reg_ts_int_msk, cx_read(port->reg_ts_int_msk));\r\n}\r\nstatic int cx23885_start_dma(struct cx23885_tsport *port,\r\nstruct cx23885_dmaqueue *q,\r\nstruct cx23885_buffer *buf)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nu32 reg;\r\ndprintk(1, "%s() w: %d, h: %d, f: %d\n", __func__,\r\nbuf->vb.width, buf->vb.height, buf->vb.field);\r\ncx_clear(port->reg_dma_ctl, port->dma_ctl_val);\r\ncx23885_sram_channel_setup(dev,\r\n&dev->sram_channels[port->sram_chno],\r\nport->ts_packet_size, buf->risc.dma);\r\nif (debug > 5) {\r\ncx23885_sram_channel_dump(dev,\r\n&dev->sram_channels[port->sram_chno]);\r\ncx23885_risc_disasm(port, &buf->risc);\r\n}\r\ncx_write(port->reg_lngth, buf->vb.width);\r\nif ((!(cx23885_boards[dev->board].portb & CX23885_MPEG_DVB)) &&\r\n(!(cx23885_boards[dev->board].portc & CX23885_MPEG_DVB))) {\r\nprintk("%s() Unsupported .portb/c (0x%08x)/(0x%08x)\n",\r\n__func__,\r\ncx23885_boards[dev->board].portb,\r\ncx23885_boards[dev->board].portc);\r\nreturn -EINVAL;\r\n}\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\r\ncx23885_av_clk(dev, 0);\r\nudelay(100);\r\nif (port->reg_src_sel)\r\ncx_write(port->reg_src_sel, port->src_sel_val);\r\ncx_write(port->reg_hw_sop_ctrl, port->hw_sop_ctrl_val);\r\ncx_write(port->reg_ts_clk_en, port->ts_clk_en_val);\r\ncx_write(port->reg_vld_misc, port->vld_misc_val);\r\ncx_write(port->reg_gen_ctrl, port->gen_ctrl_val);\r\nudelay(100);\r\ncx_write(port->reg_gpcnt_ctl, 3);\r\nq->count = 1;\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) {\r\nreg = cx_read(PAD_CTRL);\r\nreg &= ~0x3;\r\ncx_write(PAD_CTRL, reg);\r\n}\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) {\r\nreg = cx_read(PAD_CTRL);\r\nreg &= ~0x4;\r\ncx_write(PAD_CTRL, reg);\r\n}\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {\r\nreg = cx_read(PAD_CTRL);\r\nreg = reg & ~0x1;\r\nreg = reg | 0xa;\r\ncx_write(PAD_CTRL, reg);\r\ncx_write(CLK_DELAY, cx_read(CLK_DELAY) | 0x80000011);\r\ncx_write(ALT_PIN_OUT_SEL, 0x10100045);\r\n}\r\nswitch (dev->bridge) {\r\ncase CX23885_BRIDGE_885:\r\ncase CX23885_BRIDGE_887:\r\ncase CX23885_BRIDGE_888:\r\ndprintk(1, "%s() enabling TS int's and DMA\n", __func__);\r\ncx_set(port->reg_ts_int_msk, port->ts_int_msk_val);\r\ncx_set(port->reg_dma_ctl, port->dma_ctl_val);\r\ncx23885_irq_add(dev, port->pci_irqmask);\r\ncx23885_irq_enable_all(dev);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ncx_set(DEV_CNTRL2, (1<<5));\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\r\ncx23885_av_clk(dev, 1);\r\nif (debug > 4)\r\ncx23885_tsport_reg_dump(port);\r\nreturn 0;\r\n}\r\nstatic int cx23885_stop_dma(struct cx23885_tsport *port)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nu32 reg;\r\ndprintk(1, "%s()\n", __func__);\r\ncx_clear(port->reg_ts_int_msk, port->ts_int_msk_val);\r\ncx_clear(port->reg_dma_ctl, port->dma_ctl_val);\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {\r\nreg = cx_read(PAD_CTRL);\r\nreg = reg | 0x1;\r\nreg = reg & ~0xa;\r\ncx_write(PAD_CTRL, reg);\r\ncx_write(port->reg_src_sel, 0);\r\ncx_write(port->reg_gen_ctrl, 8);\r\n}\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\r\ncx23885_av_clk(dev, 0);\r\nreturn 0;\r\n}\r\nint cx23885_restart_queue(struct cx23885_tsport *port,\r\nstruct cx23885_dmaqueue *q)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_buffer *buf;\r\ndprintk(5, "%s()\n", __func__);\r\nif (list_empty(&q->active)) {\r\nstruct cx23885_buffer *prev;\r\nprev = NULL;\r\ndprintk(5, "%s() queue is empty\n", __func__);\r\nfor (;;) {\r\nif (list_empty(&q->queued))\r\nreturn 0;\r\nbuf = list_entry(q->queued.next, struct cx23885_buffer,\r\nvb.queue);\r\nif (NULL == prev) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\ncx23885_start_dma(port, q, buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(5, "[%p/%d] restart_queue - f/active\n",\r\nbuf, buf->vb.i);\r\n} else if (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(5, "[%p/%d] restart_queue - m/active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nreturn 0;\r\n}\r\nprev = buf;\r\n}\r\nreturn 0;\r\n}\r\nbuf = list_entry(q->active.next, struct cx23885_buffer, vb.queue);\r\ndprintk(2, "restart_queue [%p/%d]: restart dma\n",\r\nbuf, buf->vb.i);\r\ncx23885_start_dma(port, q, buf);\r\nlist_for_each_entry(buf, &q->active, vb.queue)\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nint cx23885_buf_prepare(struct videobuf_queue *q, struct cx23885_tsport *port,\r\nstruct cx23885_buffer *buf, enum v4l2_field field)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nint size = port->ts_packet_size * port->ts_packet_count;\r\nint rc;\r\ndprintk(1, "%s: %p\n", __func__, buf);\r\nif (0 != buf->vb.baddr && buf->vb.bsize < size)\r\nreturn -EINVAL;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nbuf->vb.width = port->ts_packet_size;\r\nbuf->vb.height = port->ts_packet_count;\r\nbuf->vb.size = size;\r\nbuf->vb.field = field ;\r\nrc = videobuf_iolock(q, &buf->vb, NULL);\r\nif (0 != rc)\r\ngoto fail;\r\ncx23885_risc_databuffer(dev->pci, &buf->risc,\r\nvideobuf_to_dma(&buf->vb)->sglist,\r\nbuf->vb.width, buf->vb.height, 0);\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\ncx23885_free_buffer(q, buf);\r\nreturn rc;\r\n}\r\nvoid cx23885_buf_queue(struct cx23885_tsport *port, struct cx23885_buffer *buf)\r\n{\r\nstruct cx23885_buffer *prev;\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_dmaqueue *cx88q = &port->mpegq;\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(cx88q->stopper.dma);\r\nbuf->risc.jmp[2] = cpu_to_le32(0);\r\nif (list_empty(&cx88q->active)) {\r\ndprintk(1, "queue is empty - first active\n");\r\nlist_add_tail(&buf->vb.queue, &cx88q->active);\r\ncx23885_start_dma(port, cx88q, buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = cx88q->count++;\r\nmod_timer(&cx88q->timeout, jiffies + BUFFER_TIMEOUT);\r\ndprintk(1, "[%p/%d] %s - first active\n",\r\nbuf, buf->vb.i, __func__);\r\n} else {\r\ndprintk(1, "queue is not empty - append to active\n");\r\nprev = list_entry(cx88q->active.prev, struct cx23885_buffer,\r\nvb.queue);\r\nlist_add_tail(&buf->vb.queue, &cx88q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = cx88q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(1, "[%p/%d] %s - append to active\n",\r\nbuf, buf->vb.i, __func__);\r\n}\r\n}\r\nstatic void do_cancel_buffers(struct cx23885_tsport *port, char *reason,\r\nint restart)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_dmaqueue *q = &port->mpegq;\r\nstruct cx23885_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->slock, flags);\r\nwhile (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx23885_buffer,\r\nvb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\ndprintk(1, "[%p/%d] %s - dma=0x%08lx\n",\r\nbuf, buf->vb.i, reason, (unsigned long)buf->risc.dma);\r\n}\r\nif (restart) {\r\ndprintk(1, "restarting queue\n");\r\ncx23885_restart_queue(port, q);\r\n}\r\nspin_unlock_irqrestore(&port->slock, flags);\r\n}\r\nvoid cx23885_cancel_buffers(struct cx23885_tsport *port)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nstruct cx23885_dmaqueue *q = &port->mpegq;\r\ndprintk(1, "%s()\n", __func__);\r\ndel_timer_sync(&q->timeout);\r\ncx23885_stop_dma(port);\r\ndo_cancel_buffers(port, "cancel", 0);\r\n}\r\nstatic void cx23885_timeout(unsigned long data)\r\n{\r\nstruct cx23885_tsport *port = (struct cx23885_tsport *)data;\r\nstruct cx23885_dev *dev = port->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nif (debug > 5)\r\ncx23885_sram_channel_dump(dev,\r\n&dev->sram_channels[port->sram_chno]);\r\ncx23885_stop_dma(port);\r\ndo_cancel_buffers(port, "timeout", 1);\r\n}\r\nint cx23885_irq_417(struct cx23885_dev *dev, u32 status)\r\n{\r\nstruct cx23885_tsport *port = &dev->ts1;\r\nint count = 0;\r\nint handled = 0;\r\nif (status == 0)\r\nreturn handled;\r\ncount = cx_read(port->reg_gpcnt);\r\ndprintk(7, "status: 0x%08x mask: 0x%08x count: 0x%x\n",\r\nstatus, cx_read(port->reg_ts_int_msk), count);\r\nif ((status & VID_B_MSK_BAD_PKT) ||\r\n(status & VID_B_MSK_OPC_ERR) ||\r\n(status & VID_B_MSK_VBI_OPC_ERR) ||\r\n(status & VID_B_MSK_SYNC) ||\r\n(status & VID_B_MSK_VBI_SYNC) ||\r\n(status & VID_B_MSK_OF) ||\r\n(status & VID_B_MSK_VBI_OF)) {\r\nprintk(KERN_ERR "%s: V4L mpeg risc op code error, status "\r\n"= 0x%x\n", dev->name, status);\r\nif (status & VID_B_MSK_BAD_PKT)\r\ndprintk(1, " VID_B_MSK_BAD_PKT\n");\r\nif (status & VID_B_MSK_OPC_ERR)\r\ndprintk(1, " VID_B_MSK_OPC_ERR\n");\r\nif (status & VID_B_MSK_VBI_OPC_ERR)\r\ndprintk(1, " VID_B_MSK_VBI_OPC_ERR\n");\r\nif (status & VID_B_MSK_SYNC)\r\ndprintk(1, " VID_B_MSK_SYNC\n");\r\nif (status & VID_B_MSK_VBI_SYNC)\r\ndprintk(1, " VID_B_MSK_VBI_SYNC\n");\r\nif (status & VID_B_MSK_OF)\r\ndprintk(1, " VID_B_MSK_OF\n");\r\nif (status & VID_B_MSK_VBI_OF)\r\ndprintk(1, " VID_B_MSK_VBI_OF\n");\r\ncx_clear(port->reg_dma_ctl, port->dma_ctl_val);\r\ncx23885_sram_channel_dump(dev,\r\n&dev->sram_channels[port->sram_chno]);\r\ncx23885_417_check_encoder(dev);\r\n} else if (status & VID_B_MSK_RISCI1) {\r\ndprintk(7, " VID_B_MSK_RISCI1\n");\r\nspin_lock(&port->slock);\r\ncx23885_wakeup(port, &port->mpegq, count);\r\nspin_unlock(&port->slock);\r\n} else if (status & VID_B_MSK_RISCI2) {\r\ndprintk(7, " VID_B_MSK_RISCI2\n");\r\nspin_lock(&port->slock);\r\ncx23885_restart_queue(port, &port->mpegq);\r\nspin_unlock(&port->slock);\r\n}\r\nif (status) {\r\ncx_write(port->reg_ts_int_stat, status);\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nstatic int cx23885_irq_ts(struct cx23885_tsport *port, u32 status)\r\n{\r\nstruct cx23885_dev *dev = port->dev;\r\nint handled = 0;\r\nu32 count;\r\nif ((status & VID_BC_MSK_OPC_ERR) ||\r\n(status & VID_BC_MSK_BAD_PKT) ||\r\n(status & VID_BC_MSK_SYNC) ||\r\n(status & VID_BC_MSK_OF)) {\r\nif (status & VID_BC_MSK_OPC_ERR)\r\ndprintk(7, " (VID_BC_MSK_OPC_ERR 0x%08x)\n",\r\nVID_BC_MSK_OPC_ERR);\r\nif (status & VID_BC_MSK_BAD_PKT)\r\ndprintk(7, " (VID_BC_MSK_BAD_PKT 0x%08x)\n",\r\nVID_BC_MSK_BAD_PKT);\r\nif (status & VID_BC_MSK_SYNC)\r\ndprintk(7, " (VID_BC_MSK_SYNC 0x%08x)\n",\r\nVID_BC_MSK_SYNC);\r\nif (status & VID_BC_MSK_OF)\r\ndprintk(7, " (VID_BC_MSK_OF 0x%08x)\n",\r\nVID_BC_MSK_OF);\r\nprintk(KERN_ERR "%s: mpeg risc op code error\n", dev->name);\r\ncx_clear(port->reg_dma_ctl, port->dma_ctl_val);\r\ncx23885_sram_channel_dump(dev,\r\n&dev->sram_channels[port->sram_chno]);\r\n} else if (status & VID_BC_MSK_RISCI1) {\r\ndprintk(7, " (RISCI1 0x%08x)\n", VID_BC_MSK_RISCI1);\r\nspin_lock(&port->slock);\r\ncount = cx_read(port->reg_gpcnt);\r\ncx23885_wakeup(port, &port->mpegq, count);\r\nspin_unlock(&port->slock);\r\n} else if (status & VID_BC_MSK_RISCI2) {\r\ndprintk(7, " (RISCI2 0x%08x)\n", VID_BC_MSK_RISCI2);\r\nspin_lock(&port->slock);\r\ncx23885_restart_queue(port, &port->mpegq);\r\nspin_unlock(&port->slock);\r\n}\r\nif (status) {\r\ncx_write(port->reg_ts_int_stat, status);\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t cx23885_irq(int irq, void *dev_id)\r\n{\r\nstruct cx23885_dev *dev = dev_id;\r\nstruct cx23885_tsport *ts1 = &dev->ts1;\r\nstruct cx23885_tsport *ts2 = &dev->ts2;\r\nu32 pci_status, pci_mask;\r\nu32 vida_status, vida_mask;\r\nu32 audint_status, audint_mask;\r\nu32 ts1_status, ts1_mask;\r\nu32 ts2_status, ts2_mask;\r\nint vida_count = 0, ts1_count = 0, ts2_count = 0, handled = 0;\r\nint audint_count = 0;\r\nbool subdev_handled;\r\npci_status = cx_read(PCI_INT_STAT);\r\npci_mask = cx23885_irq_get_mask(dev);\r\nvida_status = cx_read(VID_A_INT_STAT);\r\nvida_mask = cx_read(VID_A_INT_MSK);\r\naudint_status = cx_read(AUDIO_INT_INT_STAT);\r\naudint_mask = cx_read(AUDIO_INT_INT_MSK);\r\nts1_status = cx_read(VID_B_INT_STAT);\r\nts1_mask = cx_read(VID_B_INT_MSK);\r\nts2_status = cx_read(VID_C_INT_STAT);\r\nts2_mask = cx_read(VID_C_INT_MSK);\r\nif ((pci_status == 0) && (ts2_status == 0) && (ts1_status == 0))\r\ngoto out;\r\nvida_count = cx_read(VID_A_GPCNT);\r\naudint_count = cx_read(AUD_INT_A_GPCNT);\r\nts1_count = cx_read(ts1->reg_gpcnt);\r\nts2_count = cx_read(ts2->reg_gpcnt);\r\ndprintk(7, "pci_status: 0x%08x pci_mask: 0x%08x\n",\r\npci_status, pci_mask);\r\ndprintk(7, "vida_status: 0x%08x vida_mask: 0x%08x count: 0x%x\n",\r\nvida_status, vida_mask, vida_count);\r\ndprintk(7, "audint_status: 0x%08x audint_mask: 0x%08x count: 0x%x\n",\r\naudint_status, audint_mask, audint_count);\r\ndprintk(7, "ts1_status: 0x%08x ts1_mask: 0x%08x count: 0x%x\n",\r\nts1_status, ts1_mask, ts1_count);\r\ndprintk(7, "ts2_status: 0x%08x ts2_mask: 0x%08x count: 0x%x\n",\r\nts2_status, ts2_mask, ts2_count);\r\nif (pci_status & (PCI_MSK_RISC_RD | PCI_MSK_RISC_WR |\r\nPCI_MSK_AL_RD | PCI_MSK_AL_WR | PCI_MSK_APB_DMA |\r\nPCI_MSK_VID_C | PCI_MSK_VID_B | PCI_MSK_VID_A |\r\nPCI_MSK_AUD_INT | PCI_MSK_AUD_EXT |\r\nPCI_MSK_GPIO0 | PCI_MSK_GPIO1 |\r\nPCI_MSK_AV_CORE | PCI_MSK_IR)) {\r\nif (pci_status & PCI_MSK_RISC_RD)\r\ndprintk(7, " (PCI_MSK_RISC_RD 0x%08x)\n",\r\nPCI_MSK_RISC_RD);\r\nif (pci_status & PCI_MSK_RISC_WR)\r\ndprintk(7, " (PCI_MSK_RISC_WR 0x%08x)\n",\r\nPCI_MSK_RISC_WR);\r\nif (pci_status & PCI_MSK_AL_RD)\r\ndprintk(7, " (PCI_MSK_AL_RD 0x%08x)\n",\r\nPCI_MSK_AL_RD);\r\nif (pci_status & PCI_MSK_AL_WR)\r\ndprintk(7, " (PCI_MSK_AL_WR 0x%08x)\n",\r\nPCI_MSK_AL_WR);\r\nif (pci_status & PCI_MSK_APB_DMA)\r\ndprintk(7, " (PCI_MSK_APB_DMA 0x%08x)\n",\r\nPCI_MSK_APB_DMA);\r\nif (pci_status & PCI_MSK_VID_C)\r\ndprintk(7, " (PCI_MSK_VID_C 0x%08x)\n",\r\nPCI_MSK_VID_C);\r\nif (pci_status & PCI_MSK_VID_B)\r\ndprintk(7, " (PCI_MSK_VID_B 0x%08x)\n",\r\nPCI_MSK_VID_B);\r\nif (pci_status & PCI_MSK_VID_A)\r\ndprintk(7, " (PCI_MSK_VID_A 0x%08x)\n",\r\nPCI_MSK_VID_A);\r\nif (pci_status & PCI_MSK_AUD_INT)\r\ndprintk(7, " (PCI_MSK_AUD_INT 0x%08x)\n",\r\nPCI_MSK_AUD_INT);\r\nif (pci_status & PCI_MSK_AUD_EXT)\r\ndprintk(7, " (PCI_MSK_AUD_EXT 0x%08x)\n",\r\nPCI_MSK_AUD_EXT);\r\nif (pci_status & PCI_MSK_GPIO0)\r\ndprintk(7, " (PCI_MSK_GPIO0 0x%08x)\n",\r\nPCI_MSK_GPIO0);\r\nif (pci_status & PCI_MSK_GPIO1)\r\ndprintk(7, " (PCI_MSK_GPIO1 0x%08x)\n",\r\nPCI_MSK_GPIO1);\r\nif (pci_status & PCI_MSK_AV_CORE)\r\ndprintk(7, " (PCI_MSK_AV_CORE 0x%08x)\n",\r\nPCI_MSK_AV_CORE);\r\nif (pci_status & PCI_MSK_IR)\r\ndprintk(7, " (PCI_MSK_IR 0x%08x)\n",\r\nPCI_MSK_IR);\r\n}\r\nif (cx23885_boards[dev->board].ci_type == 1 &&\r\n(pci_status & (PCI_MSK_GPIO1 | PCI_MSK_GPIO0)))\r\nhandled += netup_ci_slot_status(dev, pci_status);\r\nif (cx23885_boards[dev->board].ci_type == 2 &&\r\n(pci_status & PCI_MSK_GPIO0))\r\nhandled += altera_ci_irq(dev);\r\nif (ts1_status) {\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)\r\nhandled += cx23885_irq_ts(ts1, ts1_status);\r\nelse\r\nif (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)\r\nhandled += cx23885_irq_417(dev, ts1_status);\r\n}\r\nif (ts2_status) {\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB)\r\nhandled += cx23885_irq_ts(ts2, ts2_status);\r\nelse\r\nif (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER)\r\nhandled += cx23885_irq_417(dev, ts2_status);\r\n}\r\nif (vida_status)\r\nhandled += cx23885_video_irq(dev, vida_status);\r\nif (audint_status)\r\nhandled += cx23885_audio_irq(dev, audint_status, audint_mask);\r\nif (pci_status & PCI_MSK_IR) {\r\nsubdev_handled = false;\r\nv4l2_subdev_call(dev->sd_ir, core, interrupt_service_routine,\r\npci_status, &subdev_handled);\r\nif (subdev_handled)\r\nhandled++;\r\n}\r\nif ((pci_status & pci_mask) & PCI_MSK_AV_CORE) {\r\ncx23885_irq_disable(dev, PCI_MSK_AV_CORE);\r\nif (!schedule_work(&dev->cx25840_work))\r\nprintk(KERN_ERR "%s: failed to set up deferred work for"\r\n" AV Core/IR interrupt. Interrupt is disabled"\r\n" and won't be re-enabled\n", dev->name);\r\nhandled++;\r\n}\r\nif (handled)\r\ncx_write(PCI_INT_STAT, pci_status);\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void cx23885_v4l2_dev_notify(struct v4l2_subdev *sd,\r\nunsigned int notification, void *arg)\r\n{\r\nstruct cx23885_dev *dev;\r\nif (sd == NULL)\r\nreturn;\r\ndev = to_cx23885(sd->v4l2_dev);\r\nswitch (notification) {\r\ncase V4L2_SUBDEV_IR_RX_NOTIFY:\r\nif (sd == dev->sd_ir)\r\ncx23885_ir_rx_v4l2_dev_notify(sd, *(u32 *)arg);\r\nbreak;\r\ncase V4L2_SUBDEV_IR_TX_NOTIFY:\r\nif (sd == dev->sd_ir)\r\ncx23885_ir_tx_v4l2_dev_notify(sd, *(u32 *)arg);\r\nbreak;\r\n}\r\n}\r\nstatic void cx23885_v4l2_dev_notify_init(struct cx23885_dev *dev)\r\n{\r\nINIT_WORK(&dev->cx25840_work, cx23885_av_work_handler);\r\nINIT_WORK(&dev->ir_rx_work, cx23885_ir_rx_work_handler);\r\nINIT_WORK(&dev->ir_tx_work, cx23885_ir_tx_work_handler);\r\ndev->v4l2_dev.notify = cx23885_v4l2_dev_notify;\r\n}\r\nstatic inline int encoder_on_portb(struct cx23885_dev *dev)\r\n{\r\nreturn cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER;\r\n}\r\nstatic inline int encoder_on_portc(struct cx23885_dev *dev)\r\n{\r\nreturn cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER;\r\n}\r\nvoid cx23885_gpio_set(struct cx23885_dev *dev, u32 mask)\r\n{\r\nif (mask & 0x7)\r\ncx_set(GP0_IO, mask & 0x7);\r\nif (mask & 0x0007fff8) {\r\nif (encoder_on_portb(dev) || encoder_on_portc(dev))\r\nprintk(KERN_ERR\r\n"%s: Setting GPIO on encoder ports\n",\r\ndev->name);\r\ncx_set(MC417_RWD, (mask & 0x0007fff8) >> 3);\r\n}\r\nif (mask & 0x00f80000)\r\nprintk(KERN_INFO "%s: Unsupported\n", dev->name);\r\n}\r\nvoid cx23885_gpio_clear(struct cx23885_dev *dev, u32 mask)\r\n{\r\nif (mask & 0x00000007)\r\ncx_clear(GP0_IO, mask & 0x7);\r\nif (mask & 0x0007fff8) {\r\nif (encoder_on_portb(dev) || encoder_on_portc(dev))\r\nprintk(KERN_ERR\r\n"%s: Clearing GPIO moving on encoder ports\n",\r\ndev->name);\r\ncx_clear(MC417_RWD, (mask & 0x7fff8) >> 3);\r\n}\r\nif (mask & 0x00f80000)\r\nprintk(KERN_INFO "%s: Unsupported\n", dev->name);\r\n}\r\nu32 cx23885_gpio_get(struct cx23885_dev *dev, u32 mask)\r\n{\r\nif (mask & 0x00000007)\r\nreturn (cx_read(GP0_IO) >> 8) & mask & 0x7;\r\nif (mask & 0x0007fff8) {\r\nif (encoder_on_portb(dev) || encoder_on_portc(dev))\r\nprintk(KERN_ERR\r\n"%s: Reading GPIO moving on encoder ports\n",\r\ndev->name);\r\nreturn (cx_read(MC417_RWD) & ((mask & 0x7fff8) >> 3)) << 3;\r\n}\r\nif (mask & 0x00f80000)\r\nprintk(KERN_INFO "%s: Unsupported\n", dev->name);\r\nreturn 0;\r\n}\r\nvoid cx23885_gpio_enable(struct cx23885_dev *dev, u32 mask, int asoutput)\r\n{\r\nif ((mask & 0x00000007) && asoutput)\r\ncx_set(GP0_IO, (mask & 0x7) << 16);\r\nelse if ((mask & 0x00000007) && !asoutput)\r\ncx_clear(GP0_IO, (mask & 0x7) << 16);\r\nif (mask & 0x0007fff8) {\r\nif (encoder_on_portb(dev) || encoder_on_portc(dev))\r\nprintk(KERN_ERR\r\n"%s: Enabling GPIO on encoder ports\n",\r\ndev->name);\r\n}\r\nif ((mask & 0x0007fff8) && asoutput)\r\ncx_clear(MC417_OEN, (mask & 0x7fff8) >> 3);\r\nelse if ((mask & 0x0007fff8) && !asoutput)\r\ncx_set(MC417_OEN, (mask & 0x7fff8) >> 3);\r\n}\r\nstatic int cx23885_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct cx23885_dev *dev;\r\nint err;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\nerr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\r\nif (err < 0)\r\ngoto fail_free;\r\ncx23885_v4l2_dev_notify_init(dev);\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\ngoto fail_unreg;\r\n}\r\nif (cx23885_dev_setup(dev) < 0) {\r\nerr = -EINVAL;\r\ngoto fail_unreg;\r\n}\r\ndev->pci_rev = pci_dev->revision;\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\nprintk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", dev->name,\r\npci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat,\r\n(unsigned long long)pci_resource_start(pci_dev, 0));\r\npci_set_master(pci_dev);\r\nif (!pci_dma_supported(pci_dev, 0xffffffff)) {\r\nprintk("%s/0: Oops: no 32bit PCI DMA ???\n", dev->name);\r\nerr = -EIO;\r\ngoto fail_irq;\r\n}\r\nerr = request_irq(pci_dev->irq, cx23885_irq,\r\nIRQF_SHARED | IRQF_DISABLED, dev->name, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: can't get IRQ %d\n",\r\ndev->name, pci_dev->irq);\r\ngoto fail_irq;\r\n}\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_NETUP_DUAL_DVBS2_CI:\r\ncx23885_irq_add_enable(dev, PCI_MSK_GPIO1 | PCI_MSK_GPIO0);\r\nbreak;\r\ncase CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:\r\ncx23885_irq_add_enable(dev, PCI_MSK_GPIO0);\r\nbreak;\r\n}\r\ncx23885_ir_pci_int_enable(dev);\r\ncx23885_input_init(dev);\r\nreturn 0;\r\nfail_irq:\r\ncx23885_dev_unregister(dev);\r\nfail_unreg:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nfail_free:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void cx23885_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct cx23885_dev *dev = to_cx23885(v4l2_dev);\r\ncx23885_input_fini(dev);\r\ncx23885_ir_fini(dev);\r\ncx23885_shutdown(dev);\r\npci_disable_device(pci_dev);\r\nfree_irq(pci_dev->irq, dev);\r\ncx23885_dev_unregister(dev);\r\nv4l2_device_unregister(v4l2_dev);\r\nkfree(dev);\r\n}\r\nstatic int __init cx23885_init(void)\r\n{\r\nprintk(KERN_INFO "cx23885 driver version %s loaded\n",\r\nCX23885_VERSION);\r\nreturn pci_register_driver(&cx23885_pci_driver);\r\n}\r\nstatic void __exit cx23885_fini(void)\r\n{\r\npci_unregister_driver(&cx23885_pci_driver);\r\n}
