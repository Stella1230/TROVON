static void print_prot(struct seq_file *m, unsigned int pr, int level)\r\n{\r\nstatic const char * const level_name[] =\r\n{ "ASCE", "PGD", "PUD", "PMD", "PTE" };\r\nseq_printf(m, "%s ", level_name[level]);\r\nif (pr & _PAGE_INVALID) {\r\nseq_printf(m, "I\n");\r\nreturn;\r\n}\r\nseq_printf(m, "%s", pr & _PAGE_RO ? "RO " : "RW ");\r\nseq_printf(m, "%s", pr & _PAGE_CO ? "CO " : " ");\r\nseq_putc(m, '\n');\r\n}\r\nstatic void note_page(struct seq_file *m, struct pg_state *st,\r\nunsigned int new_prot, int level)\r\n{\r\nstatic const char units[] = "KMGTPE";\r\nint width = sizeof(unsigned long) * 2;\r\nconst char *unit = units;\r\nunsigned int prot, cur;\r\nunsigned long delta;\r\nprot = new_prot;\r\ncur = st->current_prot;\r\nif (!st->level) {\r\nst->current_prot = new_prot;\r\nst->level = level;\r\nst->marker = address_markers;\r\nseq_printf(m, "---[ %s ]---\n", st->marker->name);\r\n} else if (prot != cur || level != st->level ||\r\nst->current_address >= st->marker[1].start_address) {\r\nseq_printf(m, "0x%0*lx-0x%0*lx",\r\nwidth, st->start_address,\r\nwidth, st->current_address);\r\ndelta = (st->current_address - st->start_address) >> 10;\r\nwhile (!(delta & 0x3ff) && unit[1]) {\r\ndelta >>= 10;\r\nunit++;\r\n}\r\nseq_printf(m, "%9lu%c ", delta, *unit);\r\nprint_prot(m, st->current_prot, st->level);\r\nif (st->current_address >= st->marker[1].start_address) {\r\nst->marker++;\r\nseq_printf(m, "---[ %s ]---\n", st->marker->name);\r\n}\r\nst->start_address = st->current_address;\r\nst->current_prot = new_prot;\r\nst->level = level;\r\n}\r\n}\r\nstatic void walk_pte_level(struct seq_file *m, struct pg_state *st,\r\npmd_t *pmd, unsigned long addr)\r\n{\r\nunsigned int prot;\r\npte_t *pte;\r\nint i;\r\nfor (i = 0; i < PTRS_PER_PTE && addr < max_addr; i++) {\r\nst->current_address = addr;\r\npte = pte_offset_kernel(pmd, addr);\r\nprot = pte_val(*pte) & (_PAGE_RO | _PAGE_INVALID);\r\nnote_page(m, st, prot, 4);\r\naddr += PAGE_SIZE;\r\n}\r\n}\r\nstatic void walk_pmd_level(struct seq_file *m, struct pg_state *st,\r\npud_t *pud, unsigned long addr)\r\n{\r\nunsigned int prot;\r\npmd_t *pmd;\r\nint i;\r\nfor (i = 0; i < PTRS_PER_PMD && addr < max_addr; i++) {\r\nst->current_address = addr;\r\npmd = pmd_offset(pud, addr);\r\nif (!pmd_none(*pmd)) {\r\nif (pmd_large(*pmd)) {\r\nprot = pmd_val(*pmd) & _PMD_PROT_MASK;\r\nnote_page(m, st, prot, 3);\r\n} else\r\nwalk_pte_level(m, st, pmd, addr);\r\n} else\r\nnote_page(m, st, _PAGE_INVALID, 3);\r\naddr += PMD_SIZE;\r\n}\r\n}\r\nstatic void walk_pud_level(struct seq_file *m, struct pg_state *st,\r\npgd_t *pgd, unsigned long addr)\r\n{\r\nunsigned int prot;\r\npud_t *pud;\r\nint i;\r\nfor (i = 0; i < PTRS_PER_PUD && addr < max_addr; i++) {\r\nst->current_address = addr;\r\npud = pud_offset(pgd, addr);\r\nif (!pud_none(*pud))\r\nif (pud_large(*pud)) {\r\nprot = pud_val(*pud) & _PUD_PROT_MASK;\r\nnote_page(m, st, prot, 2);\r\n} else\r\nwalk_pmd_level(m, st, pud, addr);\r\nelse\r\nnote_page(m, st, _PAGE_INVALID, 2);\r\naddr += PUD_SIZE;\r\n}\r\n}\r\nstatic void walk_pgd_level(struct seq_file *m)\r\n{\r\nunsigned long addr = 0;\r\nstruct pg_state st;\r\npgd_t *pgd;\r\nint i;\r\nmemset(&st, 0, sizeof(st));\r\nfor (i = 0; i < PTRS_PER_PGD && addr < max_addr; i++) {\r\nst.current_address = addr;\r\npgd = pgd_offset_k(addr);\r\nif (!pgd_none(*pgd))\r\nwalk_pud_level(m, &st, pgd, addr);\r\nelse\r\nnote_page(m, &st, _PAGE_INVALID, 1);\r\naddr += PGDIR_SIZE;\r\n}\r\nst.current_address = max_addr;\r\nnote_page(m, &st, 0, 0);\r\n}\r\nstatic int ptdump_show(struct seq_file *m, void *v)\r\n{\r\nwalk_pgd_level(m);\r\nreturn 0;\r\n}\r\nstatic int ptdump_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, ptdump_show, NULL);\r\n}\r\nstatic int pt_dump_init(void)\r\n{\r\n#ifdef CONFIG_32BIT\r\nmax_addr = 1UL << 31;\r\n#else\r\nmax_addr = (S390_lowcore.kernel_asce & _REGION_ENTRY_TYPE_MASK) >> 2;\r\nmax_addr = 1UL << (max_addr * 11 + 31);\r\naddress_markers[MODULES_NR].start_address = MODULES_VADDR;\r\n#endif\r\naddress_markers[VMEMMAP_NR].start_address = (unsigned long) vmemmap;\r\naddress_markers[VMALLOC_NR].start_address = VMALLOC_START;\r\ndebugfs_create_file("kernel_page_tables", 0400, NULL, NULL, &ptdump_fops);\r\nreturn 0;\r\n}
