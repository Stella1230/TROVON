int\r\naic7xxx_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)\r\n{\r\nstruct aic7xxx_host *p;\r\nstruct aic_dev_data *aic_dev;\r\nstruct scsi_device *sdptr;\r\nunsigned char i;\r\nunsigned char tindex;\r\nfor(p=first_aic7xxx; p && p->host != HBAptr; p=p->next)\r\n;\r\nif (!p)\r\n{\r\nseq_printf(m, "Can't find adapter for host number %d\n", HBAptr->host_no);\r\nreturn 0;\r\n}\r\np = (struct aic7xxx_host *) HBAptr->hostdata;\r\nseq_printf(m, "Adaptec AIC7xxx driver version: ");\r\nseq_printf(m, "%s/", AIC7XXX_C_VERSION);\r\nseq_printf(m, "%s", AIC7XXX_H_VERSION);\r\nseq_printf(m, "\n");\r\nseq_printf(m, "Adapter Configuration:\n");\r\nseq_printf(m, " SCSI Adapter: %s\n",\r\nboard_names[p->board_name_index]);\r\nif (p->flags & AHC_TWIN)\r\nseq_printf(m, " Twin Channel Controller ");\r\nelse\r\n{\r\nchar *channel = "";\r\nchar *ultra = "";\r\nchar *wide = "Narrow ";\r\nif (p->flags & AHC_MULTI_CHANNEL)\r\n{\r\nchannel = " Channel A";\r\nif (p->flags & (AHC_CHNLB|AHC_CHNLC))\r\nchannel = (p->flags & AHC_CHNLB) ? " Channel B" : " Channel C";\r\n}\r\nif (p->features & AHC_WIDE)\r\nwide = "Wide ";\r\nif (p->features & AHC_ULTRA3)\r\n{\r\nswitch(p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7892:\r\ncase AHC_AIC7899:\r\nultra = "Ultra-160/m LVD/SE ";\r\nbreak;\r\ndefault:\r\nultra = "Ultra-3 LVD/SE ";\r\nbreak;\r\n}\r\n}\r\nelse if (p->features & AHC_ULTRA2)\r\nultra = "Ultra-2 LVD/SE ";\r\nelse if (p->features & AHC_ULTRA)\r\nultra = "Ultra ";\r\nseq_printf(m, " %s%sController%s ",\r\nultra, wide, channel);\r\n}\r\nswitch(p->chip & ~AHC_CHIPID_MASK)\r\n{\r\ncase AHC_VL:\r\nseq_printf(m, "at VLB slot %d\n", p->pci_device_fn);\r\nbreak;\r\ncase AHC_EISA:\r\nseq_printf(m, "at EISA slot %d\n", p->pci_device_fn);\r\nbreak;\r\ndefault:\r\nseq_printf(m, "at PCI %d/%d/%d\n", p->pci_bus,\r\nPCI_SLOT(p->pci_device_fn), PCI_FUNC(p->pci_device_fn));\r\nbreak;\r\n}\r\nif( !(p->maddr) )\r\n{\r\nseq_printf(m, " Programmed I/O Base: %lx\n", p->base);\r\n}\r\nelse\r\n{\r\nseq_printf(m, " PCI MMAPed I/O Base: 0x%lx\n", p->mbase);\r\n}\r\nif( (p->chip & (AHC_VL | AHC_EISA)) )\r\n{\r\nseq_printf(m, " BIOS Memory Address: 0x%08x\n", p->bios_address);\r\n}\r\nseq_printf(m, " Adapter SEEPROM Config: %s\n",\r\n(p->flags & AHC_SEEPROM_FOUND) ? "SEEPROM found and used." :\r\n((p->flags & AHC_USEDEFAULTS) ? "SEEPROM not found, using defaults." :\r\n"SEEPROM not found, using leftover BIOS values.") );\r\nseq_printf(m, " Adaptec SCSI BIOS: %s\n",\r\n(p->flags & AHC_BIOS_ENABLED) ? "Enabled" : "Disabled");\r\nseq_printf(m, " IRQ: %d\n", HBAptr->irq);\r\nseq_printf(m, " SCBs: Active %d, Max Active %d,\n",\r\np->activescbs, p->max_activescbs);\r\nseq_printf(m, " Allocated %d, HW %d, "\r\n"Page %d\n", p->scb_data->numscbs, p->scb_data->maxhscbs,\r\np->scb_data->maxscbs);\r\nif (p->flags & AHC_EXTERNAL_SRAM)\r\nseq_printf(m, " Using External SCB SRAM\n");\r\nseq_printf(m, " Interrupts: %ld", p->isr_count);\r\nif (p->chip & AHC_EISA)\r\n{\r\nseq_printf(m, " %s\n",\r\n(p->pause & IRQMS) ? "(Level Sensitive)" : "(Edge Triggered)");\r\n}\r\nelse\r\n{\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, " BIOS Control Word: 0x%04x\n",\r\np->bios_control);\r\nseq_printf(m, " Adapter Control Word: 0x%04x\n",\r\np->adapter_control);\r\nseq_printf(m, " Extended Translation: %sabled\n",\r\n(p->flags & AHC_EXTEND_TRANS_A) ? "En" : "Dis");\r\nseq_printf(m, "Disconnect Enable Flags: 0x%04x\n", p->discenable);\r\nif (p->features & (AHC_ULTRA | AHC_ULTRA2))\r\n{\r\nseq_printf(m, " Ultra Enable Flags: 0x%04x\n", p->ultraenb);\r\n}\r\nseq_printf(m, "Default Tag Queue Depth: %d\n", aic7xxx_default_queue_depth);\r\nseq_printf(m, " Tagged Queue By Device array for aic7xxx host "\r\n"instance %d:\n", p->instance);\r\nseq_printf(m, " {");\r\nfor(i=0; i < (MAX_TARGETS - 1); i++)\r\nseq_printf(m, "%d,",aic7xxx_tag_info[p->instance].tag_commands[i]);\r\nseq_printf(m, "%d}\n",aic7xxx_tag_info[p->instance].tag_commands[i]);\r\nseq_printf(m, "\n");\r\nseq_printf(m, "Statistics:\n\n");\r\nlist_for_each_entry(aic_dev, &p->aic_devs, list)\r\n{\r\nsdptr = aic_dev->SDptr;\r\ntindex = sdptr->channel << 3 | sdptr->id;\r\nseq_printf(m, "(scsi%d:%d:%d:%d)\n",\r\np->host_no, sdptr->channel, sdptr->id, sdptr->lun);\r\nseq_printf(m, " Device using %s/%s",\r\n(aic_dev->cur.width == MSG_EXT_WDTR_BUS_16_BIT) ?\r\n"Wide" : "Narrow",\r\n(aic_dev->cur.offset != 0) ?\r\n"Sync transfers at " : "Async transfers.\n" );\r\nif (aic_dev->cur.offset != 0)\r\n{\r\nstruct aic7xxx_syncrate *sync_rate;\r\nunsigned char options = aic_dev->cur.options;\r\nint period = aic_dev->cur.period;\r\nint rate = (aic_dev->cur.width ==\r\nMSG_EXT_WDTR_BUS_16_BIT) ? 1 : 0;\r\nsync_rate = aic7xxx_find_syncrate(p, &period, 0, &options);\r\nif (sync_rate != NULL)\r\n{\r\nseq_printf(m, "%s MByte/sec, offset %d\n",\r\nsync_rate->rate[rate],\r\naic_dev->cur.offset );\r\n}\r\nelse\r\n{\r\nseq_printf(m, "3.3 MByte/sec, offset %d\n",\r\naic_dev->cur.offset );\r\n}\r\n}\r\nseq_printf(m, " Transinfo settings: ");\r\nseq_printf(m, "current(%d/%d/%d/%d), ",\r\naic_dev->cur.period,\r\naic_dev->cur.offset,\r\naic_dev->cur.width,\r\naic_dev->cur.options);\r\nseq_printf(m, "goal(%d/%d/%d/%d), ",\r\naic_dev->goal.period,\r\naic_dev->goal.offset,\r\naic_dev->goal.width,\r\naic_dev->goal.options);\r\nseq_printf(m, "user(%d/%d/%d/%d)\n",\r\np->user[tindex].period,\r\np->user[tindex].offset,\r\np->user[tindex].width,\r\np->user[tindex].options);\r\nif(sdptr->simple_tags)\r\n{\r\nseq_printf(m, " Tagged Command Queueing Enabled, Ordered Tags %s, Depth %d/%d\n", sdptr->ordered_tags ? "Enabled" : "Disabled", sdptr->queue_depth, aic_dev->max_q_depth);\r\n}\r\nif(aic_dev->barrier_total)\r\nseq_printf(m, " Total transfers %ld:\n (%ld/%ld/%ld/%ld reads/writes/REQ_BARRIER/Ordered Tags)\n",\r\naic_dev->r_total+aic_dev->w_total, aic_dev->r_total, aic_dev->w_total,\r\naic_dev->barrier_total, aic_dev->ordered_total);\r\nelse\r\nseq_printf(m, " Total transfers %ld:\n (%ld/%ld reads/writes)\n",\r\naic_dev->r_total+aic_dev->w_total, aic_dev->r_total, aic_dev->w_total);\r\nseq_printf(m, "%s\n", HDRB);\r\nseq_printf(m, " Reads:");\r\nfor (i = 0; i < ARRAY_SIZE(aic_dev->r_bins); i++)\r\n{\r\nseq_printf(m, " %10ld", aic_dev->r_bins[i]);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, " Writes:");\r\nfor (i = 0; i < ARRAY_SIZE(aic_dev->w_bins); i++)\r\n{\r\nseq_printf(m, " %10ld", aic_dev->w_bins[i]);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, "\n\n");\r\n}\r\nreturn 0;\r\n}
