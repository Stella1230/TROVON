void kvmppc_dump_tlbs(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nstruct kvmppc_44x_tlbe *tlbe;\r\nint i;\r\nprintk("vcpu %d TLB dump:\n", vcpu->vcpu_id);\r\nprintk("| %2s | %3s | %8s | %8s | %8s |\n",\r\n"nr", "tid", "word0", "word1", "word2");\r\nfor (i = 0; i < ARRAY_SIZE(vcpu_44x->guest_tlb); i++) {\r\ntlbe = &vcpu_44x->guest_tlb[i];\r\nif (tlbe->word0 & PPC44x_TLB_VALID)\r\nprintk(" G%2d | %02X | %08X | %08X | %08X |\n",\r\ni, tlbe->tid, tlbe->word0, tlbe->word1,\r\ntlbe->word2);\r\n}\r\n}\r\nstatic inline void kvmppc_44x_tlbie(unsigned int index)\r\n{\r\nasm volatile(\r\n"tlbwe %[index], %[index], 0\n"\r\n:\r\n: [index] "r"(index)\r\n);\r\n}\r\nstatic inline void kvmppc_44x_tlbre(unsigned int index,\r\nstruct kvmppc_44x_tlbe *tlbe)\r\n{\r\nasm volatile(\r\n"tlbre %[word0], %[index], 0\n"\r\n"mfspr %[tid], %[sprn_mmucr]\n"\r\n"andi. %[tid], %[tid], 0xff\n"\r\n"tlbre %[word1], %[index], 1\n"\r\n"tlbre %[word2], %[index], 2\n"\r\n: [word0] "=r"(tlbe->word0),\r\n[word1] "=r"(tlbe->word1),\r\n[word2] "=r"(tlbe->word2),\r\n[tid] "=r"(tlbe->tid)\r\n: [index] "r"(index),\r\n[sprn_mmucr] "i"(SPRN_MMUCR)\r\n: "cc"\r\n);\r\n}\r\nstatic inline void kvmppc_44x_tlbwe(unsigned int index,\r\nstruct kvmppc_44x_tlbe *stlbe)\r\n{\r\nunsigned long tmp;\r\nasm volatile(\r\n"mfspr %[tmp], %[sprn_mmucr]\n"\r\n"rlwimi %[tmp], %[tid], 0, 0xff\n"\r\n"mtspr %[sprn_mmucr], %[tmp]\n"\r\n"tlbwe %[word0], %[index], 0\n"\r\n"tlbwe %[word1], %[index], 1\n"\r\n"tlbwe %[word2], %[index], 2\n"\r\n: [tmp] "=&r"(tmp)\r\n: [word0] "r"(stlbe->word0),\r\n[word1] "r"(stlbe->word1),\r\n[word2] "r"(stlbe->word2),\r\n[tid] "r"(stlbe->tid),\r\n[index] "r"(index),\r\n[sprn_mmucr] "i"(SPRN_MMUCR)\r\n);\r\n}\r\nstatic u32 kvmppc_44x_tlb_shadow_attrib(u32 attrib, int usermode)\r\n{\r\nattrib &= PPC44x_TLB_PERM_MASK|PPC44x_TLB_UATTR_MASK;\r\nif (!usermode) {\r\nattrib &= ~PPC44x_TLB_USER_PERM_MASK;\r\nattrib |= (attrib & PPC44x_TLB_SUPER_PERM_MASK) << 3;\r\n}\r\nattrib |= PPC44x_TLB_SX|PPC44x_TLB_SR|PPC44x_TLB_SW;\r\nattrib |= PPC44x_TLB_M;\r\nreturn attrib;\r\n}\r\nvoid kvmppc_44x_tlb_load(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nint i;\r\nfor (i = 0; i <= tlb_44x_hwater; i++) {\r\nstruct kvmppc_44x_tlbe *stlbe = &vcpu_44x->shadow_tlb[i];\r\nif (get_tlb_v(stlbe) && get_tlb_ts(stlbe))\r\nkvmppc_44x_tlbwe(i, stlbe);\r\n}\r\n}\r\nstatic void kvmppc_44x_tlbe_set_modified(struct kvmppc_vcpu_44x *vcpu_44x,\r\nunsigned int i)\r\n{\r\nvcpu_44x->shadow_tlb_mod[i] = 1;\r\n}\r\nvoid kvmppc_44x_tlb_put(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nint i;\r\nfor (i = 0; i <= tlb_44x_hwater; i++) {\r\nstruct kvmppc_44x_tlbe *stlbe = &vcpu_44x->shadow_tlb[i];\r\nif (vcpu_44x->shadow_tlb_mod[i])\r\nkvmppc_44x_tlbre(i, stlbe);\r\nif (get_tlb_v(stlbe) && get_tlb_ts(stlbe))\r\nkvmppc_44x_tlbie(i);\r\n}\r\n}\r\nint kvmppc_44x_tlb_index(struct kvm_vcpu *vcpu, gva_t eaddr, unsigned int pid,\r\nunsigned int as)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vcpu_44x->guest_tlb); i++) {\r\nstruct kvmppc_44x_tlbe *tlbe = &vcpu_44x->guest_tlb[i];\r\nunsigned int tid;\r\nif (eaddr < get_tlb_eaddr(tlbe))\r\ncontinue;\r\nif (eaddr > get_tlb_end(tlbe))\r\ncontinue;\r\ntid = get_tlb_tid(tlbe);\r\nif (tid && (tid != pid))\r\ncontinue;\r\nif (!get_tlb_v(tlbe))\r\ncontinue;\r\nif (get_tlb_ts(tlbe) != as)\r\ncontinue;\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\ngpa_t kvmppc_mmu_xlate(struct kvm_vcpu *vcpu, unsigned int gtlb_index,\r\ngva_t eaddr)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nstruct kvmppc_44x_tlbe *gtlbe = &vcpu_44x->guest_tlb[gtlb_index];\r\nunsigned int pgmask = get_tlb_bytes(gtlbe) - 1;\r\nreturn get_tlb_raddr(gtlbe) | (eaddr & pgmask);\r\n}\r\nint kvmppc_mmu_itlb_index(struct kvm_vcpu *vcpu, gva_t eaddr)\r\n{\r\nunsigned int as = !!(vcpu->arch.shared->msr & MSR_IS);\r\nreturn kvmppc_44x_tlb_index(vcpu, eaddr, vcpu->arch.pid, as);\r\n}\r\nint kvmppc_mmu_dtlb_index(struct kvm_vcpu *vcpu, gva_t eaddr)\r\n{\r\nunsigned int as = !!(vcpu->arch.shared->msr & MSR_DS);\r\nreturn kvmppc_44x_tlb_index(vcpu, eaddr, vcpu->arch.pid, as);\r\n}\r\nvoid kvmppc_mmu_itlb_miss(struct kvm_vcpu *vcpu)\r\n{\r\n}\r\nvoid kvmppc_mmu_dtlb_miss(struct kvm_vcpu *vcpu)\r\n{\r\n}\r\nstatic void kvmppc_44x_shadow_release(struct kvmppc_vcpu_44x *vcpu_44x,\r\nunsigned int stlb_index)\r\n{\r\nstruct kvmppc_44x_shadow_ref *ref = &vcpu_44x->shadow_refs[stlb_index];\r\nif (!ref->page)\r\nreturn;\r\nkvmppc_44x_tlbie(stlb_index);\r\nif (ref->writeable)\r\nkvm_release_page_dirty(ref->page);\r\nelse\r\nkvm_release_page_clean(ref->page);\r\nref->page = NULL;\r\ntrace_kvm_stlb_inval(stlb_index);\r\n}\r\nvoid kvmppc_mmu_destroy(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nint i;\r\nfor (i = 0; i <= tlb_44x_hwater; i++)\r\nkvmppc_44x_shadow_release(vcpu_44x, i);\r\n}\r\nvoid kvmppc_mmu_map(struct kvm_vcpu *vcpu, u64 gvaddr, gpa_t gpaddr,\r\nunsigned int gtlb_index)\r\n{\r\nstruct kvmppc_44x_tlbe stlbe;\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nstruct kvmppc_44x_tlbe *gtlbe = &vcpu_44x->guest_tlb[gtlb_index];\r\nstruct kvmppc_44x_shadow_ref *ref;\r\nstruct page *new_page;\r\nhpa_t hpaddr;\r\ngfn_t gfn;\r\nu32 asid = gtlbe->tid;\r\nu32 flags = gtlbe->word2;\r\nu32 max_bytes = get_tlb_bytes(gtlbe);\r\nunsigned int victim;\r\nlocal_irq_disable();\r\nvictim = ++tlb_44x_index;\r\nif (victim > tlb_44x_hwater)\r\nvictim = 0;\r\ntlb_44x_index = victim;\r\nlocal_irq_enable();\r\ngfn = gpaddr >> PAGE_SHIFT;\r\nnew_page = gfn_to_page(vcpu->kvm, gfn);\r\nif (is_error_page(new_page)) {\r\nprintk(KERN_ERR "Couldn't get guest page for gfn %llx!\n",\r\n(unsigned long long)gfn);\r\nreturn;\r\n}\r\nhpaddr = page_to_phys(new_page);\r\nkvmppc_44x_shadow_release(vcpu_44x, victim);\r\nstlbe.word0 = PPC44x_TLB_VALID | PPC44x_TLB_TS;\r\nif (max_bytes >= PAGE_SIZE) {\r\nstlbe.word0 |= (gvaddr & PAGE_MASK) | PPC44x_TLBE_SIZE;\r\n} else {\r\nstlbe.word0 |= (gvaddr & PAGE_MASK_4K) | PPC44x_TLB_4K;\r\nhpaddr |= gpaddr & (PAGE_MASK ^ PAGE_MASK_4K);\r\n}\r\nstlbe.word1 = (hpaddr & 0xfffffc00) | ((hpaddr >> 32) & 0xf);\r\nstlbe.word2 = kvmppc_44x_tlb_shadow_attrib(flags,\r\nvcpu->arch.shared->msr & MSR_PR);\r\nstlbe.tid = !(asid & 0xff);\r\nref = &vcpu_44x->shadow_refs[victim];\r\nref->page = new_page;\r\nref->gtlb_index = gtlb_index;\r\nref->writeable = !!(stlbe.word2 & PPC44x_TLB_UW);\r\nref->tid = stlbe.tid;\r\nkvmppc_44x_tlbe_set_modified(vcpu_44x, victim);\r\nkvmppc_44x_tlbwe(victim, &stlbe);\r\ntrace_kvm_stlb_write(victim, stlbe.tid, stlbe.word0, stlbe.word1,\r\nstlbe.word2);\r\n}\r\nstatic void kvmppc_44x_invalidate(struct kvm_vcpu *vcpu,\r\nunsigned int gtlb_index)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vcpu_44x->shadow_refs); i++) {\r\nstruct kvmppc_44x_shadow_ref *ref = &vcpu_44x->shadow_refs[i];\r\nif (ref->gtlb_index == gtlb_index)\r\nkvmppc_44x_shadow_release(vcpu_44x, i);\r\n}\r\n}\r\nvoid kvmppc_mmu_msr_notify(struct kvm_vcpu *vcpu, u32 old_msr)\r\n{\r\nint usermode = vcpu->arch.shared->msr & MSR_PR;\r\nvcpu->arch.shadow_pid = !usermode;\r\n}\r\nvoid kvmppc_set_pid(struct kvm_vcpu *vcpu, u32 new_pid)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nint i;\r\nif (unlikely(vcpu->arch.pid == new_pid))\r\nreturn;\r\nvcpu->arch.pid = new_pid;\r\nfor (i = 0; i < ARRAY_SIZE(vcpu_44x->shadow_refs); i++) {\r\nstruct kvmppc_44x_shadow_ref *ref = &vcpu_44x->shadow_refs[i];\r\nif (ref->tid == 0)\r\nkvmppc_44x_shadow_release(vcpu_44x, i);\r\n}\r\n}\r\nstatic int tlbe_is_host_safe(const struct kvm_vcpu *vcpu,\r\nconst struct kvmppc_44x_tlbe *tlbe)\r\n{\r\ngpa_t gpa;\r\nif (!get_tlb_v(tlbe))\r\nreturn 0;\r\nif (get_tlb_ts(tlbe) != !!(vcpu->arch.shared->msr & MSR_IS))\r\nreturn 0;\r\ngpa = get_tlb_raddr(tlbe);\r\nif (!gfn_to_memslot(vcpu->kvm, gpa >> PAGE_SHIFT))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint kvmppc_44x_emul_tlbwe(struct kvm_vcpu *vcpu, u8 ra, u8 rs, u8 ws)\r\n{\r\nstruct kvmppc_vcpu_44x *vcpu_44x = to_44x(vcpu);\r\nstruct kvmppc_44x_tlbe *tlbe;\r\nunsigned int gtlb_index;\r\nint idx;\r\ngtlb_index = kvmppc_get_gpr(vcpu, ra);\r\nif (gtlb_index >= KVM44x_GUEST_TLB_SIZE) {\r\nprintk("%s: index %d\n", __func__, gtlb_index);\r\nkvmppc_dump_vcpu(vcpu);\r\nreturn EMULATE_FAIL;\r\n}\r\ntlbe = &vcpu_44x->guest_tlb[gtlb_index];\r\nif (tlbe->word0 & PPC44x_TLB_VALID)\r\nkvmppc_44x_invalidate(vcpu, gtlb_index);\r\nswitch (ws) {\r\ncase PPC44x_TLB_PAGEID:\r\ntlbe->tid = get_mmucr_stid(vcpu);\r\ntlbe->word0 = kvmppc_get_gpr(vcpu, rs);\r\nbreak;\r\ncase PPC44x_TLB_XLAT:\r\ntlbe->word1 = kvmppc_get_gpr(vcpu, rs);\r\nbreak;\r\ncase PPC44x_TLB_ATTRIB:\r\ntlbe->word2 = kvmppc_get_gpr(vcpu, rs);\r\nbreak;\r\ndefault:\r\nreturn EMULATE_FAIL;\r\n}\r\nidx = srcu_read_lock(&vcpu->kvm->srcu);\r\nif (tlbe_is_host_safe(vcpu, tlbe)) {\r\ngva_t eaddr;\r\ngpa_t gpaddr;\r\nu32 bytes;\r\neaddr = get_tlb_eaddr(tlbe);\r\ngpaddr = get_tlb_raddr(tlbe);\r\nbytes = get_tlb_bytes(tlbe);\r\neaddr &= ~(bytes - 1);\r\ngpaddr &= ~(bytes - 1);\r\nkvmppc_mmu_map(vcpu, eaddr, gpaddr, gtlb_index);\r\n}\r\nsrcu_read_unlock(&vcpu->kvm->srcu, idx);\r\ntrace_kvm_gtlb_write(gtlb_index, tlbe->tid, tlbe->word0, tlbe->word1,\r\ntlbe->word2);\r\nkvmppc_set_exit_type(vcpu, EMULATED_TLBWE_EXITS);\r\nreturn EMULATE_DONE;\r\n}\r\nint kvmppc_44x_emul_tlbsx(struct kvm_vcpu *vcpu, u8 rt, u8 ra, u8 rb, u8 rc)\r\n{\r\nu32 ea;\r\nint gtlb_index;\r\nunsigned int as = get_mmucr_sts(vcpu);\r\nunsigned int pid = get_mmucr_stid(vcpu);\r\nea = kvmppc_get_gpr(vcpu, rb);\r\nif (ra)\r\nea += kvmppc_get_gpr(vcpu, ra);\r\ngtlb_index = kvmppc_44x_tlb_index(vcpu, ea, pid, as);\r\nif (rc) {\r\nu32 cr = kvmppc_get_cr(vcpu);\r\nif (gtlb_index < 0)\r\nkvmppc_set_cr(vcpu, cr & ~0x20000000);\r\nelse\r\nkvmppc_set_cr(vcpu, cr | 0x20000000);\r\n}\r\nkvmppc_set_gpr(vcpu, rt, gtlb_index);\r\nkvmppc_set_exit_type(vcpu, EMULATED_TLBSX_EXITS);\r\nreturn EMULATE_DONE;\r\n}
