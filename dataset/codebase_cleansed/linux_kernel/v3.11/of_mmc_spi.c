static struct of_mmc_spi *to_of_mmc_spi(struct device *dev)\r\n{\r\nreturn container_of(dev->platform_data, struct of_mmc_spi, pdata);\r\n}\r\nstatic int of_mmc_spi_read_gpio(struct device *dev, int gpio_num)\r\n{\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nbool active_low = oms->alow_gpios[gpio_num];\r\nbool value = gpio_get_value(oms->gpios[gpio_num]);\r\nreturn active_low ^ value;\r\n}\r\nstatic int of_mmc_spi_get_cd(struct device *dev)\r\n{\r\nreturn of_mmc_spi_read_gpio(dev, CD_GPIO);\r\n}\r\nstatic int of_mmc_spi_get_ro(struct device *dev)\r\n{\r\nreturn of_mmc_spi_read_gpio(dev, WP_GPIO);\r\n}\r\nstatic int of_mmc_spi_init(struct device *dev,\r\nirqreturn_t (*irqhandler)(int, void *), void *mmc)\r\n{\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nreturn request_threaded_irq(oms->detect_irq, NULL, irqhandler, 0,\r\ndev_name(dev), mmc);\r\n}\r\nstatic void of_mmc_spi_exit(struct device *dev, void *mmc)\r\n{\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nfree_irq(oms->detect_irq, mmc);\r\n}\r\nstruct mmc_spi_platform_data *mmc_spi_get_pdata(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_mmc_spi *oms;\r\nconst u32 *voltage_ranges;\r\nint num_ranges;\r\nint i;\r\nint ret = -EINVAL;\r\nif (dev->platform_data || !np)\r\nreturn dev->platform_data;\r\noms = kzalloc(sizeof(*oms), GFP_KERNEL);\r\nif (!oms)\r\nreturn NULL;\r\nvoltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);\r\nnum_ranges = num_ranges / sizeof(*voltage_ranges) / 2;\r\nif (!voltage_ranges || !num_ranges) {\r\ndev_err(dev, "OF: voltage-ranges unspecified\n");\r\ngoto err_ocr;\r\n}\r\nfor (i = 0; i < num_ranges; i++) {\r\nconst int j = i * 2;\r\nu32 mask;\r\nmask = mmc_vddrange_to_ocrmask(be32_to_cpu(voltage_ranges[j]),\r\nbe32_to_cpu(voltage_ranges[j + 1]));\r\nif (!mask) {\r\nret = -EINVAL;\r\ndev_err(dev, "OF: voltage-range #%d is invalid\n", i);\r\ngoto err_ocr;\r\n}\r\noms->pdata.ocr_mask |= mask;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(oms->gpios); i++) {\r\nenum of_gpio_flags gpio_flags;\r\noms->gpios[i] = of_get_gpio_flags(np, i, &gpio_flags);\r\nif (!gpio_is_valid(oms->gpios[i]))\r\ncontinue;\r\nret = gpio_request(oms->gpios[i], dev_name(dev));\r\nif (ret < 0) {\r\noms->gpios[i] = -EINVAL;\r\ncontinue;\r\n}\r\nif (gpio_flags & OF_GPIO_ACTIVE_LOW)\r\noms->alow_gpios[i] = true;\r\n}\r\nif (gpio_is_valid(oms->gpios[CD_GPIO]))\r\noms->pdata.get_cd = of_mmc_spi_get_cd;\r\nif (gpio_is_valid(oms->gpios[WP_GPIO]))\r\noms->pdata.get_ro = of_mmc_spi_get_ro;\r\noms->detect_irq = irq_of_parse_and_map(np, 0);\r\nif (oms->detect_irq != 0) {\r\noms->pdata.init = of_mmc_spi_init;\r\noms->pdata.exit = of_mmc_spi_exit;\r\n} else {\r\noms->pdata.caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\ndev->platform_data = &oms->pdata;\r\nreturn dev->platform_data;\r\nerr_ocr:\r\nkfree(oms);\r\nreturn NULL;\r\n}\r\nvoid mmc_spi_put_pdata(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_mmc_spi *oms = to_of_mmc_spi(dev);\r\nint i;\r\nif (!dev->platform_data || !np)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(oms->gpios); i++) {\r\nif (gpio_is_valid(oms->gpios[i]))\r\ngpio_free(oms->gpios[i]);\r\n}\r\nkfree(oms);\r\ndev->platform_data = NULL;\r\n}
