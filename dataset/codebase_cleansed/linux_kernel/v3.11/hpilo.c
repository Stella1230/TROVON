static inline int get_entry_id(int entry)\r\n{\r\nreturn (entry & ENTRY_MASK_DESCRIPTOR) >> ENTRY_BITPOS_DESCRIPTOR;\r\n}\r\nstatic inline int get_entry_len(int entry)\r\n{\r\nreturn ((entry & ENTRY_MASK_QWORDS) >> ENTRY_BITPOS_QWORDS) << 3;\r\n}\r\nstatic inline int mk_entry(int id, int len)\r\n{\r\nint qlen = len & 7 ? (len >> 3) + 1 : len >> 3;\r\nreturn id << ENTRY_BITPOS_DESCRIPTOR | qlen << ENTRY_BITPOS_QWORDS;\r\n}\r\nstatic inline int desc_mem_sz(int nr_entry)\r\n{\r\nreturn nr_entry << L2_QENTRY_SZ;\r\n}\r\nstatic int fifo_enqueue(struct ilo_hwinfo *hw, char *fifobar, int entry)\r\n{\r\nstruct fifo *fifo_q = FIFOBARTOHANDLE(fifobar);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&hw->fifo_lock, flags);\r\nif (!(fifo_q->fifobar[(fifo_q->tail + 1) & fifo_q->imask]\r\n& ENTRY_MASK_O)) {\r\nfifo_q->fifobar[fifo_q->tail & fifo_q->imask] |=\r\n(entry & ENTRY_MASK_NOSTATE) | fifo_q->merge;\r\nfifo_q->tail += 1;\r\nret = 1;\r\n}\r\nspin_unlock_irqrestore(&hw->fifo_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fifo_dequeue(struct ilo_hwinfo *hw, char *fifobar, int *entry)\r\n{\r\nstruct fifo *fifo_q = FIFOBARTOHANDLE(fifobar);\r\nunsigned long flags;\r\nint ret = 0;\r\nu64 c;\r\nspin_lock_irqsave(&hw->fifo_lock, flags);\r\nc = fifo_q->fifobar[fifo_q->head & fifo_q->imask];\r\nif (c & ENTRY_MASK_C) {\r\nif (entry)\r\n*entry = c & ENTRY_MASK_NOSTATE;\r\nfifo_q->fifobar[fifo_q->head & fifo_q->imask] =\r\n(c | ENTRY_MASK) + 1;\r\nfifo_q->head += 1;\r\nret = 1;\r\n}\r\nspin_unlock_irqrestore(&hw->fifo_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fifo_check_recv(struct ilo_hwinfo *hw, char *fifobar)\r\n{\r\nstruct fifo *fifo_q = FIFOBARTOHANDLE(fifobar);\r\nunsigned long flags;\r\nint ret = 0;\r\nu64 c;\r\nspin_lock_irqsave(&hw->fifo_lock, flags);\r\nc = fifo_q->fifobar[fifo_q->head & fifo_q->imask];\r\nif (c & ENTRY_MASK_C)\r\nret = 1;\r\nspin_unlock_irqrestore(&hw->fifo_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ilo_pkt_enqueue(struct ilo_hwinfo *hw, struct ccb *ccb,\r\nint dir, int id, int len)\r\n{\r\nchar *fifobar;\r\nint entry;\r\nif (dir == SENDQ)\r\nfifobar = ccb->ccb_u1.send_fifobar;\r\nelse\r\nfifobar = ccb->ccb_u3.recv_fifobar;\r\nentry = mk_entry(id, len);\r\nreturn fifo_enqueue(hw, fifobar, entry);\r\n}\r\nstatic int ilo_pkt_dequeue(struct ilo_hwinfo *hw, struct ccb *ccb,\r\nint dir, int *id, int *len, void **pkt)\r\n{\r\nchar *fifobar, *desc;\r\nint entry = 0, pkt_id = 0;\r\nint ret;\r\nif (dir == SENDQ) {\r\nfifobar = ccb->ccb_u1.send_fifobar;\r\ndesc = ccb->ccb_u2.send_desc;\r\n} else {\r\nfifobar = ccb->ccb_u3.recv_fifobar;\r\ndesc = ccb->ccb_u4.recv_desc;\r\n}\r\nret = fifo_dequeue(hw, fifobar, &entry);\r\nif (ret) {\r\npkt_id = get_entry_id(entry);\r\nif (id)\r\n*id = pkt_id;\r\nif (len)\r\n*len = get_entry_len(entry);\r\nif (pkt)\r\n*pkt = (void *)(desc + desc_mem_sz(pkt_id));\r\n}\r\nreturn ret;\r\n}\r\nstatic int ilo_pkt_recv(struct ilo_hwinfo *hw, struct ccb *ccb)\r\n{\r\nchar *fifobar = ccb->ccb_u3.recv_fifobar;\r\nreturn fifo_check_recv(hw, fifobar);\r\n}\r\nstatic inline void doorbell_set(struct ccb *ccb)\r\n{\r\niowrite8(1, ccb->ccb_u5.db_base);\r\n}\r\nstatic inline void doorbell_clr(struct ccb *ccb)\r\n{\r\niowrite8(2, ccb->ccb_u5.db_base);\r\n}\r\nstatic inline int ctrl_set(int l2sz, int idxmask, int desclim)\r\n{\r\nint active = 0, go = 1;\r\nreturn l2sz << CTRL_BITPOS_L2SZ |\r\nidxmask << CTRL_BITPOS_FIFOINDEXMASK |\r\ndesclim << CTRL_BITPOS_DESCLIMIT |\r\nactive << CTRL_BITPOS_A |\r\ngo << CTRL_BITPOS_G;\r\n}\r\nstatic void ctrl_setup(struct ccb *ccb, int nr_desc, int l2desc_sz)\r\n{\r\nccb->send_ctrl = ctrl_set(l2desc_sz, nr_desc-1, nr_desc-1);\r\nccb->recv_ctrl = ctrl_set(l2desc_sz, nr_desc-1, nr_desc-1);\r\n}\r\nstatic inline int fifo_sz(int nr_entry)\r\n{\r\nreturn (nr_entry * sizeof(u64)) + FIFOHANDLESIZE;\r\n}\r\nstatic void fifo_setup(void *base_addr, int nr_entry)\r\n{\r\nstruct fifo *fifo_q = base_addr;\r\nint i;\r\nfifo_q->head = 0;\r\nfifo_q->tail = 0;\r\nfifo_q->reset = 0;\r\nfifo_q->nrents = nr_entry;\r\nfifo_q->imask = nr_entry - 1;\r\nfifo_q->merge = ENTRY_MASK_O;\r\nfor (i = 0; i < nr_entry; i++)\r\nfifo_q->fifobar[i] = 0;\r\n}\r\nstatic void ilo_ccb_close(struct pci_dev *pdev, struct ccb_data *data)\r\n{\r\nstruct ccb *driver_ccb = &data->driver_ccb;\r\nstruct ccb __iomem *device_ccb = data->mapped_ccb;\r\nint retries;\r\ndoorbell_clr(driver_ccb);\r\niowrite32(ioread32(&device_ccb->send_ctrl) & ~(1 << CTRL_BITPOS_G),\r\n&device_ccb->send_ctrl);\r\niowrite32(ioread32(&device_ccb->recv_ctrl) & ~(1 << CTRL_BITPOS_G),\r\n&device_ccb->recv_ctrl);\r\nfor (retries = MAX_WAIT; retries > 0; retries--) {\r\ndoorbell_set(driver_ccb);\r\nudelay(WAIT_TIME);\r\nif (!(ioread32(&device_ccb->send_ctrl) & (1 << CTRL_BITPOS_A))\r\n&&\r\n!(ioread32(&device_ccb->recv_ctrl) & (1 << CTRL_BITPOS_A)))\r\nbreak;\r\n}\r\nif (retries == 0)\r\ndev_err(&pdev->dev, "Closing, but controller still active\n");\r\nmemset_io(device_ccb, 0, sizeof(struct ccb));\r\npci_free_consistent(pdev, data->dma_size, data->dma_va, data->dma_pa);\r\n}\r\nstatic int ilo_ccb_setup(struct ilo_hwinfo *hw, struct ccb_data *data, int slot)\r\n{\r\nchar *dma_va;\r\ndma_addr_t dma_pa;\r\nstruct ccb *driver_ccb, *ilo_ccb;\r\ndriver_ccb = &data->driver_ccb;\r\nilo_ccb = &data->ilo_ccb;\r\ndata->dma_size = 2 * fifo_sz(NR_QENTRY) +\r\n2 * desc_mem_sz(NR_QENTRY) +\r\nILO_START_ALIGN + ILO_CACHE_SZ;\r\ndata->dma_va = pci_alloc_consistent(hw->ilo_dev, data->dma_size,\r\n&data->dma_pa);\r\nif (!data->dma_va)\r\nreturn -ENOMEM;\r\ndma_va = (char *)data->dma_va;\r\ndma_pa = data->dma_pa;\r\nmemset(dma_va, 0, data->dma_size);\r\ndma_va = (char *)roundup((unsigned long)dma_va, ILO_START_ALIGN);\r\ndma_pa = roundup(dma_pa, ILO_START_ALIGN);\r\nctrl_setup(driver_ccb, NR_QENTRY, L2_QENTRY_SZ);\r\nctrl_setup(ilo_ccb, NR_QENTRY, L2_QENTRY_SZ);\r\nfifo_setup(dma_va, NR_QENTRY);\r\ndriver_ccb->ccb_u1.send_fifobar = dma_va + FIFOHANDLESIZE;\r\nilo_ccb->ccb_u1.send_fifobar_pa = dma_pa + FIFOHANDLESIZE;\r\ndma_va += fifo_sz(NR_QENTRY);\r\ndma_pa += fifo_sz(NR_QENTRY);\r\ndma_va = (char *)roundup((unsigned long)dma_va, ILO_CACHE_SZ);\r\ndma_pa = roundup(dma_pa, ILO_CACHE_SZ);\r\nfifo_setup(dma_va, NR_QENTRY);\r\ndriver_ccb->ccb_u3.recv_fifobar = dma_va + FIFOHANDLESIZE;\r\nilo_ccb->ccb_u3.recv_fifobar_pa = dma_pa + FIFOHANDLESIZE;\r\ndma_va += fifo_sz(NR_QENTRY);\r\ndma_pa += fifo_sz(NR_QENTRY);\r\ndriver_ccb->ccb_u2.send_desc = dma_va;\r\nilo_ccb->ccb_u2.send_desc_pa = dma_pa;\r\ndma_pa += desc_mem_sz(NR_QENTRY);\r\ndma_va += desc_mem_sz(NR_QENTRY);\r\ndriver_ccb->ccb_u4.recv_desc = dma_va;\r\nilo_ccb->ccb_u4.recv_desc_pa = dma_pa;\r\ndriver_ccb->channel = slot;\r\nilo_ccb->channel = slot;\r\ndriver_ccb->ccb_u5.db_base = hw->db_vaddr + (slot << L2_DB_SIZE);\r\nilo_ccb->ccb_u5.db_base = NULL;\r\nreturn 0;\r\n}\r\nstatic void ilo_ccb_open(struct ilo_hwinfo *hw, struct ccb_data *data, int slot)\r\n{\r\nint pkt_id, pkt_sz;\r\nstruct ccb *driver_ccb = &data->driver_ccb;\r\ndata->mapped_ccb = (struct ccb __iomem *)\r\n(hw->ram_vaddr + (slot * ILOHW_CCB_SZ));\r\nmemcpy_toio(data->mapped_ccb, &data->ilo_ccb, sizeof(struct ccb));\r\npkt_sz = 0;\r\nfor (pkt_id = 0; pkt_id < NR_QENTRY; pkt_id++) {\r\nilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, pkt_sz);\r\ndoorbell_set(driver_ccb);\r\n}\r\npkt_sz = desc_mem_sz(1);\r\nfor (pkt_id = 0; pkt_id < NR_QENTRY; pkt_id++)\r\nilo_pkt_enqueue(hw, driver_ccb, RECVQ, pkt_id, pkt_sz);\r\ndoorbell_clr(driver_ccb);\r\n}\r\nstatic int ilo_ccb_verify(struct ilo_hwinfo *hw, struct ccb_data *data)\r\n{\r\nint pkt_id, i;\r\nstruct ccb *driver_ccb = &data->driver_ccb;\r\nfor (i = MAX_WAIT; i > 0; i--) {\r\nif (ilo_pkt_dequeue(hw, driver_ccb, SENDQ, &pkt_id, NULL, NULL))\r\nbreak;\r\nudelay(WAIT_TIME);\r\n}\r\nif (i == 0) {\r\ndev_err(&hw->ilo_dev->dev, "Open could not dequeue a packet\n");\r\nreturn -EBUSY;\r\n}\r\nilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, 0);\r\ndoorbell_set(driver_ccb);\r\nreturn 0;\r\n}\r\nstatic inline int is_channel_reset(struct ccb *ccb)\r\n{\r\nreturn FIFOBARTOHANDLE(ccb->ccb_u1.send_fifobar)->reset;\r\n}\r\nstatic inline void set_channel_reset(struct ccb *ccb)\r\n{\r\nFIFOBARTOHANDLE(ccb->ccb_u1.send_fifobar)->reset = 1;\r\n}\r\nstatic inline int get_device_outbound(struct ilo_hwinfo *hw)\r\n{\r\nreturn ioread32(&hw->mmio_vaddr[DB_OUT]);\r\n}\r\nstatic inline int is_db_reset(int db_out)\r\n{\r\nreturn db_out & (1 << DB_RESET);\r\n}\r\nstatic inline int is_device_reset(struct ilo_hwinfo *hw)\r\n{\r\nreturn is_db_reset(get_device_outbound(hw));\r\n}\r\nstatic inline void clear_pending_db(struct ilo_hwinfo *hw, int clr)\r\n{\r\niowrite32(clr, &hw->mmio_vaddr[DB_OUT]);\r\n}\r\nstatic inline void clear_device(struct ilo_hwinfo *hw)\r\n{\r\nclear_pending_db(hw, -1);\r\n}\r\nstatic inline void ilo_enable_interrupts(struct ilo_hwinfo *hw)\r\n{\r\niowrite8(ioread8(&hw->mmio_vaddr[DB_IRQ]) | 1, &hw->mmio_vaddr[DB_IRQ]);\r\n}\r\nstatic inline void ilo_disable_interrupts(struct ilo_hwinfo *hw)\r\n{\r\niowrite8(ioread8(&hw->mmio_vaddr[DB_IRQ]) & ~1,\r\n&hw->mmio_vaddr[DB_IRQ]);\r\n}\r\nstatic void ilo_set_reset(struct ilo_hwinfo *hw)\r\n{\r\nint slot;\r\nfor (slot = 0; slot < max_ccb; slot++) {\r\nif (!hw->ccb_alloc[slot])\r\ncontinue;\r\nset_channel_reset(&hw->ccb_alloc[slot]->driver_ccb);\r\n}\r\n}\r\nstatic ssize_t ilo_read(struct file *fp, char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nint err, found, cnt, pkt_id, pkt_len;\r\nstruct ccb_data *data = fp->private_data;\r\nstruct ccb *driver_ccb = &data->driver_ccb;\r\nstruct ilo_hwinfo *hw = data->ilo_hw;\r\nvoid *pkt;\r\nif (is_channel_reset(driver_ccb)) {\r\nreturn -ENODEV;\r\n}\r\ncnt = 20;\r\ndo {\r\nfound = ilo_pkt_dequeue(hw, driver_ccb, RECVQ, &pkt_id,\r\n&pkt_len, &pkt);\r\nif (found)\r\nbreak;\r\ncnt--;\r\nmsleep(100);\r\n} while (!found && cnt);\r\nif (!found)\r\nreturn -EAGAIN;\r\nif (pkt_len < len)\r\nlen = pkt_len;\r\nerr = copy_to_user(buf, pkt, len);\r\nilo_pkt_enqueue(hw, driver_ccb, RECVQ, pkt_id, desc_mem_sz(1));\r\nreturn err ? -EFAULT : len;\r\n}\r\nstatic ssize_t ilo_write(struct file *fp, const char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nint err, pkt_id, pkt_len;\r\nstruct ccb_data *data = fp->private_data;\r\nstruct ccb *driver_ccb = &data->driver_ccb;\r\nstruct ilo_hwinfo *hw = data->ilo_hw;\r\nvoid *pkt;\r\nif (is_channel_reset(driver_ccb))\r\nreturn -ENODEV;\r\nif (!ilo_pkt_dequeue(hw, driver_ccb, SENDQ, &pkt_id, &pkt_len, &pkt))\r\nreturn -EBUSY;\r\nif (pkt_len < len)\r\nlen = pkt_len;\r\nerr = copy_from_user(pkt, buf, len);\r\nif (err)\r\nlen = 0;\r\nilo_pkt_enqueue(hw, driver_ccb, SENDQ, pkt_id, len);\r\ndoorbell_set(driver_ccb);\r\nreturn err ? -EFAULT : len;\r\n}\r\nstatic unsigned int ilo_poll(struct file *fp, poll_table *wait)\r\n{\r\nstruct ccb_data *data = fp->private_data;\r\nstruct ccb *driver_ccb = &data->driver_ccb;\r\npoll_wait(fp, &data->ccb_waitq, wait);\r\nif (is_channel_reset(driver_ccb))\r\nreturn POLLERR;\r\nelse if (ilo_pkt_recv(data->ilo_hw, driver_ccb))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int ilo_close(struct inode *ip, struct file *fp)\r\n{\r\nint slot;\r\nstruct ccb_data *data;\r\nstruct ilo_hwinfo *hw;\r\nunsigned long flags;\r\nslot = iminor(ip) % max_ccb;\r\nhw = container_of(ip->i_cdev, struct ilo_hwinfo, cdev);\r\nspin_lock(&hw->open_lock);\r\nif (hw->ccb_alloc[slot]->ccb_cnt == 1) {\r\ndata = fp->private_data;\r\nspin_lock_irqsave(&hw->alloc_lock, flags);\r\nhw->ccb_alloc[slot] = NULL;\r\nspin_unlock_irqrestore(&hw->alloc_lock, flags);\r\nilo_ccb_close(hw->ilo_dev, data);\r\nkfree(data);\r\n} else\r\nhw->ccb_alloc[slot]->ccb_cnt--;\r\nspin_unlock(&hw->open_lock);\r\nreturn 0;\r\n}\r\nstatic int ilo_open(struct inode *ip, struct file *fp)\r\n{\r\nint slot, error;\r\nstruct ccb_data *data;\r\nstruct ilo_hwinfo *hw;\r\nunsigned long flags;\r\nslot = iminor(ip) % max_ccb;\r\nhw = container_of(ip->i_cdev, struct ilo_hwinfo, cdev);\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock(&hw->open_lock);\r\nif (hw->ccb_alloc[slot] == NULL) {\r\nerror = ilo_ccb_setup(hw, data, slot);\r\nif (error) {\r\nkfree(data);\r\ngoto out;\r\n}\r\ndata->ccb_cnt = 1;\r\ndata->ccb_excl = fp->f_flags & O_EXCL;\r\ndata->ilo_hw = hw;\r\ninit_waitqueue_head(&data->ccb_waitq);\r\nspin_lock_irqsave(&hw->alloc_lock, flags);\r\nilo_ccb_open(hw, data, slot);\r\nhw->ccb_alloc[slot] = data;\r\nspin_unlock_irqrestore(&hw->alloc_lock, flags);\r\nerror = ilo_ccb_verify(hw, data);\r\nif (error) {\r\nspin_lock_irqsave(&hw->alloc_lock, flags);\r\nhw->ccb_alloc[slot] = NULL;\r\nspin_unlock_irqrestore(&hw->alloc_lock, flags);\r\nilo_ccb_close(hw->ilo_dev, data);\r\nkfree(data);\r\ngoto out;\r\n}\r\n} else {\r\nkfree(data);\r\nif (fp->f_flags & O_EXCL || hw->ccb_alloc[slot]->ccb_excl) {\r\nerror = -EBUSY;\r\n} else {\r\nhw->ccb_alloc[slot]->ccb_cnt++;\r\nerror = 0;\r\n}\r\n}\r\nout:\r\nspin_unlock(&hw->open_lock);\r\nif (!error)\r\nfp->private_data = hw->ccb_alloc[slot];\r\nreturn error;\r\n}\r\nstatic irqreturn_t ilo_isr(int irq, void *data)\r\n{\r\nstruct ilo_hwinfo *hw = data;\r\nint pending, i;\r\nspin_lock(&hw->alloc_lock);\r\npending = get_device_outbound(hw);\r\nif (!pending) {\r\nspin_unlock(&hw->alloc_lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (is_db_reset(pending)) {\r\npending = -1;\r\nilo_set_reset(hw);\r\n}\r\nfor (i = 0; i < max_ccb; i++) {\r\nif (!hw->ccb_alloc[i])\r\ncontinue;\r\nif (pending & (1 << i))\r\nwake_up_interruptible(&hw->ccb_alloc[i]->ccb_waitq);\r\n}\r\nclear_pending_db(hw, pending);\r\nspin_unlock(&hw->alloc_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ilo_unmap_device(struct pci_dev *pdev, struct ilo_hwinfo *hw)\r\n{\r\npci_iounmap(pdev, hw->db_vaddr);\r\npci_iounmap(pdev, hw->ram_vaddr);\r\npci_iounmap(pdev, hw->mmio_vaddr);\r\n}\r\nstatic int ilo_map_device(struct pci_dev *pdev, struct ilo_hwinfo *hw)\r\n{\r\nint error = -ENOMEM;\r\nhw->mmio_vaddr = pci_iomap(pdev, 1, 0);\r\nif (hw->mmio_vaddr == NULL) {\r\ndev_err(&pdev->dev, "Error mapping mmio\n");\r\ngoto out;\r\n}\r\nhw->ram_vaddr = pci_iomap(pdev, 2, max_ccb * ILOHW_CCB_SZ);\r\nif (hw->ram_vaddr == NULL) {\r\ndev_err(&pdev->dev, "Error mapping shared mem\n");\r\ngoto mmio_free;\r\n}\r\nhw->db_vaddr = pci_iomap(pdev, 3, max_ccb * ONE_DB_SIZE);\r\nif (hw->db_vaddr == NULL) {\r\ndev_err(&pdev->dev, "Error mapping doorbell\n");\r\ngoto ram_free;\r\n}\r\nreturn 0;\r\nram_free:\r\npci_iounmap(pdev, hw->ram_vaddr);\r\nmmio_free:\r\npci_iounmap(pdev, hw->mmio_vaddr);\r\nout:\r\nreturn error;\r\n}\r\nstatic void ilo_remove(struct pci_dev *pdev)\r\n{\r\nint i, minor;\r\nstruct ilo_hwinfo *ilo_hw = pci_get_drvdata(pdev);\r\nif (!ilo_hw)\r\nreturn;\r\nclear_device(ilo_hw);\r\nminor = MINOR(ilo_hw->cdev.dev);\r\nfor (i = minor; i < minor + max_ccb; i++)\r\ndevice_destroy(ilo_class, MKDEV(ilo_major, i));\r\ncdev_del(&ilo_hw->cdev);\r\nilo_disable_interrupts(ilo_hw);\r\nfree_irq(pdev->irq, ilo_hw);\r\nilo_unmap_device(pdev, ilo_hw);\r\npci_release_regions(pdev);\r\nkfree(ilo_hw);\r\nilo_hwdev[(minor / max_ccb)] = 0;\r\n}\r\nstatic int ilo_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint devnum, minor, start, error = 0;\r\nstruct ilo_hwinfo *ilo_hw;\r\nif (pdev->subsystem_device == 0x1979)\r\ngoto out;\r\nif (max_ccb > MAX_CCB)\r\nmax_ccb = MAX_CCB;\r\nelse if (max_ccb < MIN_CCB)\r\nmax_ccb = MIN_CCB;\r\nfor (devnum = 0; devnum < MAX_ILO_DEV; devnum++) {\r\nif (ilo_hwdev[devnum] == 0) {\r\nilo_hwdev[devnum] = 1;\r\nbreak;\r\n}\r\n}\r\nif (devnum == MAX_ILO_DEV) {\r\ndev_err(&pdev->dev, "Error finding free device\n");\r\nreturn -ENODEV;\r\n}\r\nerror = -ENOMEM;\r\nilo_hw = kzalloc(sizeof(*ilo_hw), GFP_KERNEL);\r\nif (!ilo_hw)\r\ngoto out;\r\nilo_hw->ilo_dev = pdev;\r\nspin_lock_init(&ilo_hw->alloc_lock);\r\nspin_lock_init(&ilo_hw->fifo_lock);\r\nspin_lock_init(&ilo_hw->open_lock);\r\nerror = pci_enable_device(pdev);\r\nif (error)\r\ngoto free;\r\npci_set_master(pdev);\r\nerror = pci_request_regions(pdev, ILO_NAME);\r\nif (error)\r\ngoto disable;\r\nerror = ilo_map_device(pdev, ilo_hw);\r\nif (error)\r\ngoto free_regions;\r\npci_set_drvdata(pdev, ilo_hw);\r\nclear_device(ilo_hw);\r\nerror = request_irq(pdev->irq, ilo_isr, IRQF_SHARED, "hpilo", ilo_hw);\r\nif (error)\r\ngoto unmap;\r\nilo_enable_interrupts(ilo_hw);\r\ncdev_init(&ilo_hw->cdev, &ilo_fops);\r\nilo_hw->cdev.owner = THIS_MODULE;\r\nstart = devnum * max_ccb;\r\nerror = cdev_add(&ilo_hw->cdev, MKDEV(ilo_major, start), max_ccb);\r\nif (error) {\r\ndev_err(&pdev->dev, "Could not add cdev\n");\r\ngoto remove_isr;\r\n}\r\nfor (minor = 0 ; minor < max_ccb; minor++) {\r\nstruct device *dev;\r\ndev = device_create(ilo_class, &pdev->dev,\r\nMKDEV(ilo_major, minor), NULL,\r\n"hpilo!d%dccb%d", devnum, minor);\r\nif (IS_ERR(dev))\r\ndev_err(&pdev->dev, "Could not create files\n");\r\n}\r\nreturn 0;\r\nremove_isr:\r\nilo_disable_interrupts(ilo_hw);\r\nfree_irq(pdev->irq, ilo_hw);\r\nunmap:\r\nilo_unmap_device(pdev, ilo_hw);\r\nfree_regions:\r\npci_release_regions(pdev);\r\ndisable:\r\nfree:\r\nkfree(ilo_hw);\r\nout:\r\nilo_hwdev[devnum] = 0;\r\nreturn error;\r\n}\r\nstatic int __init ilo_init(void)\r\n{\r\nint error;\r\ndev_t dev;\r\nilo_class = class_create(THIS_MODULE, "iLO");\r\nif (IS_ERR(ilo_class)) {\r\nerror = PTR_ERR(ilo_class);\r\ngoto out;\r\n}\r\nerror = alloc_chrdev_region(&dev, 0, MAX_OPEN, ILO_NAME);\r\nif (error)\r\ngoto class_destroy;\r\nilo_major = MAJOR(dev);\r\nerror = pci_register_driver(&ilo_driver);\r\nif (error)\r\ngoto chr_remove;\r\nreturn 0;\r\nchr_remove:\r\nunregister_chrdev_region(dev, MAX_OPEN);\r\nclass_destroy:\r\nclass_destroy(ilo_class);\r\nout:\r\nreturn error;\r\n}\r\nstatic void __exit ilo_exit(void)\r\n{\r\npci_unregister_driver(&ilo_driver);\r\nunregister_chrdev_region(MKDEV(ilo_major, 0), MAX_OPEN);\r\nclass_destroy(ilo_class);\r\n}
