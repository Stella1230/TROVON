int\r\nnv50_dac_power(struct nv50_disp_priv *priv, int or, u32 data)\r\n{\r\nconst u32 stat = (data & NV50_DISP_DAC_PWR_HSYNC) |\r\n(data & NV50_DISP_DAC_PWR_VSYNC) |\r\n(data & NV50_DISP_DAC_PWR_DATA) |\r\n(data & NV50_DISP_DAC_PWR_STATE);\r\nconst u32 doff = (or * 0x800);\r\nnv_wait(priv, 0x61a004 + doff, 0x80000000, 0x00000000);\r\nnv_mask(priv, 0x61a004 + doff, 0xc000007f, 0x80000000 | stat);\r\nnv_wait(priv, 0x61a004 + doff, 0x80000000, 0x00000000);\r\nreturn 0;\r\n}\r\nint\r\nnv50_dac_sense(struct nv50_disp_priv *priv, int or, u32 loadval)\r\n{\r\nconst u32 doff = (or * 0x800);\r\nint load = -EINVAL;\r\nnv_mask(priv, 0x61a004 + doff, 0x807f0000, 0x80150000);\r\nnv_wait(priv, 0x61a004 + doff, 0x80000000, 0x00000000);\r\nnv_wr32(priv, 0x61a00c + doff, 0x00100000 | loadval);\r\nmdelay(9);\r\nudelay(500);\r\nnv_wr32(priv, 0x61a00c + doff, 0x80000000);\r\nload = (nv_rd32(priv, 0x61a00c + doff) & 0x38000000) >> 27;\r\nnv_wr32(priv, 0x61a00c + doff, 0x00000000);\r\nnv_mask(priv, 0x61a004 + doff, 0x807f0000, 0x80550000);\r\nnv_wait(priv, 0x61a004 + doff, 0x80000000, 0x00000000);\r\nreturn load;\r\n}\r\nint\r\nnv50_dac_mthd(struct nouveau_object *object, u32 mthd, void *args, u32 size)\r\n{\r\nstruct nv50_disp_priv *priv = (void *)object->engine;\r\nconst u8 or = (mthd & NV50_DISP_DAC_MTHD_OR);\r\nu32 *data = args;\r\nint ret;\r\nif (size < sizeof(u32))\r\nreturn -EINVAL;\r\nswitch (mthd & ~0x3f) {\r\ncase NV50_DISP_DAC_PWR:\r\nret = priv->dac.power(priv, or, data[0]);\r\nbreak;\r\ncase NV50_DISP_DAC_LOAD:\r\nret = priv->dac.sense(priv, or, data[0]);\r\nif (ret >= 0) {\r\ndata[0] = ret;\r\nret = 0;\r\n}\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nreturn ret;\r\n}
