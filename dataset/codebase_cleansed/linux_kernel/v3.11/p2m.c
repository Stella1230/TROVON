static inline unsigned p2m_top_index(unsigned long pfn)\r\n{\r\nBUG_ON(pfn >= MAX_P2M_PFN);\r\nreturn pfn / (P2M_MID_PER_PAGE * P2M_PER_PAGE);\r\n}\r\nstatic inline unsigned p2m_mid_index(unsigned long pfn)\r\n{\r\nreturn (pfn / P2M_PER_PAGE) % P2M_MID_PER_PAGE;\r\n}\r\nstatic inline unsigned p2m_index(unsigned long pfn)\r\n{\r\nreturn pfn % P2M_PER_PAGE;\r\n}\r\nstatic void p2m_top_init(unsigned long ***top)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < P2M_TOP_PER_PAGE; i++)\r\ntop[i] = p2m_mid_missing;\r\n}\r\nstatic void p2m_top_mfn_init(unsigned long *top)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < P2M_TOP_PER_PAGE; i++)\r\ntop[i] = virt_to_mfn(p2m_mid_missing_mfn);\r\n}\r\nstatic void p2m_top_mfn_p_init(unsigned long **top)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < P2M_TOP_PER_PAGE; i++)\r\ntop[i] = p2m_mid_missing_mfn;\r\n}\r\nstatic void p2m_mid_init(unsigned long **mid)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < P2M_MID_PER_PAGE; i++)\r\nmid[i] = p2m_missing;\r\n}\r\nstatic void p2m_mid_mfn_init(unsigned long *mid)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < P2M_MID_PER_PAGE; i++)\r\nmid[i] = virt_to_mfn(p2m_missing);\r\n}\r\nstatic void p2m_init(unsigned long *p2m)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < P2M_MID_PER_PAGE; i++)\r\np2m[i] = INVALID_P2M_ENTRY;\r\n}\r\nvoid __ref xen_build_mfn_list_list(void)\r\n{\r\nunsigned long pfn;\r\nif (p2m_top_mfn == NULL) {\r\np2m_mid_missing_mfn = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_mid_mfn_init(p2m_mid_missing_mfn);\r\np2m_top_mfn_p = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_top_mfn_p_init(p2m_top_mfn_p);\r\np2m_top_mfn = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_top_mfn_init(p2m_top_mfn);\r\n} else {\r\np2m_mid_mfn_init(p2m_mid_missing_mfn);\r\n}\r\nfor (pfn = 0; pfn < xen_max_p2m_pfn; pfn += P2M_PER_PAGE) {\r\nunsigned topidx = p2m_top_index(pfn);\r\nunsigned mididx = p2m_mid_index(pfn);\r\nunsigned long **mid;\r\nunsigned long *mid_mfn_p;\r\nmid = p2m_top[topidx];\r\nmid_mfn_p = p2m_top_mfn_p[topidx];\r\nif (mid == p2m_mid_missing) {\r\nBUG_ON(mididx);\r\nBUG_ON(mid_mfn_p != p2m_mid_missing_mfn);\r\np2m_top_mfn[topidx] = virt_to_mfn(p2m_mid_missing_mfn);\r\npfn += (P2M_MID_PER_PAGE - 1) * P2M_PER_PAGE;\r\ncontinue;\r\n}\r\nif (mid_mfn_p == p2m_mid_missing_mfn) {\r\nmid_mfn_p = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_mid_mfn_init(mid_mfn_p);\r\np2m_top_mfn_p[topidx] = mid_mfn_p;\r\n}\r\np2m_top_mfn[topidx] = virt_to_mfn(mid_mfn_p);\r\nmid_mfn_p[mididx] = virt_to_mfn(mid[mididx]);\r\n}\r\n}\r\nvoid xen_setup_mfn_list_list(void)\r\n{\r\nBUG_ON(HYPERVISOR_shared_info == &xen_dummy_shared_info);\r\nHYPERVISOR_shared_info->arch.pfn_to_mfn_frame_list_list =\r\nvirt_to_mfn(p2m_top_mfn);\r\nHYPERVISOR_shared_info->arch.max_pfn = xen_max_p2m_pfn;\r\n}\r\nvoid __init xen_build_dynamic_phys_to_machine(void)\r\n{\r\nunsigned long *mfn_list = (unsigned long *)xen_start_info->mfn_list;\r\nunsigned long max_pfn = min(MAX_DOMAIN_PAGES, xen_start_info->nr_pages);\r\nunsigned long pfn;\r\nxen_max_p2m_pfn = max_pfn;\r\np2m_missing = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_init(p2m_missing);\r\np2m_mid_missing = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_mid_init(p2m_mid_missing);\r\np2m_top = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_top_init(p2m_top);\r\np2m_identity = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_init(p2m_identity);\r\nfor (pfn = 0; pfn < max_pfn; pfn += P2M_PER_PAGE) {\r\nunsigned topidx = p2m_top_index(pfn);\r\nunsigned mididx = p2m_mid_index(pfn);\r\nif (p2m_top[topidx] == p2m_mid_missing) {\r\nunsigned long **mid = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_mid_init(mid);\r\np2m_top[topidx] = mid;\r\n}\r\nif (unlikely(pfn + P2M_PER_PAGE > max_pfn)) {\r\nunsigned long p2midx;\r\np2midx = max_pfn % P2M_PER_PAGE;\r\nfor ( ; p2midx < P2M_PER_PAGE; p2midx++)\r\nmfn_list[pfn + p2midx] = INVALID_P2M_ENTRY;\r\n}\r\np2m_top[topidx][mididx] = &mfn_list[pfn];\r\n}\r\nm2p_override_init();\r\n}\r\nunsigned long __init xen_revector_p2m_tree(void)\r\n{\r\nunsigned long va_start;\r\nunsigned long va_end;\r\nunsigned long pfn;\r\nunsigned long pfn_free = 0;\r\nunsigned long *mfn_list = NULL;\r\nunsigned long size;\r\nva_start = xen_start_info->mfn_list;\r\nsize = PAGE_ALIGN(xen_start_info->nr_pages * sizeof(unsigned long));\r\nva_end = va_start + size;\r\nif (va_start <= __START_KERNEL_map && va_start >= __PAGE_OFFSET)\r\nreturn 0;\r\nmfn_list = alloc_bootmem_align(size, PAGE_SIZE);\r\nif (!mfn_list) {\r\npr_warn("Could not allocate space for a new P2M tree!\n");\r\nreturn xen_start_info->mfn_list;\r\n}\r\nmemset(mfn_list, 0xFF, size);\r\nfor (pfn = 0; pfn < ALIGN(MAX_DOMAIN_PAGES, P2M_PER_PAGE); pfn += P2M_PER_PAGE) {\r\nunsigned topidx = p2m_top_index(pfn);\r\nunsigned mididx;\r\nunsigned long *mid_p;\r\nif (!p2m_top[topidx])\r\ncontinue;\r\nif (p2m_top[topidx] == p2m_mid_missing)\r\ncontinue;\r\nmididx = p2m_mid_index(pfn);\r\nmid_p = p2m_top[topidx][mididx];\r\nif (!mid_p)\r\ncontinue;\r\nif ((mid_p == p2m_missing) || (mid_p == p2m_identity))\r\ncontinue;\r\nif ((unsigned long)mid_p == INVALID_P2M_ENTRY)\r\ncontinue;\r\nif (mid_p >= (unsigned long *)va_start && mid_p <= (unsigned long *)va_end) {\r\nunsigned long *new;\r\nif (pfn_free > (size / sizeof(unsigned long))) {\r\nWARN(1, "Only allocated for %ld pages, but we want %ld!\n",\r\nsize / sizeof(unsigned long), pfn_free);\r\nreturn 0;\r\n}\r\nnew = &mfn_list[pfn_free];\r\ncopy_page(new, mid_p);\r\np2m_top[topidx][mididx] = &mfn_list[pfn_free];\r\np2m_top_mfn_p[topidx][mididx] = virt_to_mfn(&mfn_list[pfn_free]);\r\npfn_free += P2M_PER_PAGE;\r\n}\r\n}\r\nreturn (unsigned long)mfn_list;\r\n}\r\nunsigned long __init xen_revector_p2m_tree(void)\r\n{\r\nreturn 0;\r\n}\r\nunsigned long get_phys_to_machine(unsigned long pfn)\r\n{\r\nunsigned topidx, mididx, idx;\r\nif (unlikely(pfn >= MAX_P2M_PFN))\r\nreturn INVALID_P2M_ENTRY;\r\ntopidx = p2m_top_index(pfn);\r\nmididx = p2m_mid_index(pfn);\r\nidx = p2m_index(pfn);\r\nif (p2m_top[topidx][mididx] == p2m_identity)\r\nreturn IDENTITY_FRAME(pfn);\r\nreturn p2m_top[topidx][mididx][idx];\r\n}\r\nstatic void *alloc_p2m_page(void)\r\n{\r\nreturn (void *)__get_free_page(GFP_KERNEL | __GFP_REPEAT);\r\n}\r\nstatic void free_p2m_page(void *p)\r\n{\r\nfree_page((unsigned long)p);\r\n}\r\nstatic bool alloc_p2m(unsigned long pfn)\r\n{\r\nunsigned topidx, mididx;\r\nunsigned long ***top_p, **mid;\r\nunsigned long *top_mfn_p, *mid_mfn;\r\ntopidx = p2m_top_index(pfn);\r\nmididx = p2m_mid_index(pfn);\r\ntop_p = &p2m_top[topidx];\r\nmid = *top_p;\r\nif (mid == p2m_mid_missing) {\r\nmid = alloc_p2m_page();\r\nif (!mid)\r\nreturn false;\r\np2m_mid_init(mid);\r\nif (cmpxchg(top_p, p2m_mid_missing, mid) != p2m_mid_missing)\r\nfree_p2m_page(mid);\r\n}\r\ntop_mfn_p = &p2m_top_mfn[topidx];\r\nmid_mfn = p2m_top_mfn_p[topidx];\r\nBUG_ON(virt_to_mfn(mid_mfn) != *top_mfn_p);\r\nif (mid_mfn == p2m_mid_missing_mfn) {\r\nunsigned long missing_mfn;\r\nunsigned long mid_mfn_mfn;\r\nmid_mfn = alloc_p2m_page();\r\nif (!mid_mfn)\r\nreturn false;\r\np2m_mid_mfn_init(mid_mfn);\r\nmissing_mfn = virt_to_mfn(p2m_mid_missing_mfn);\r\nmid_mfn_mfn = virt_to_mfn(mid_mfn);\r\nif (cmpxchg(top_mfn_p, missing_mfn, mid_mfn_mfn) != missing_mfn)\r\nfree_p2m_page(mid_mfn);\r\nelse\r\np2m_top_mfn_p[topidx] = mid_mfn;\r\n}\r\nif (p2m_top[topidx][mididx] == p2m_identity ||\r\np2m_top[topidx][mididx] == p2m_missing) {\r\nunsigned long *p2m;\r\nunsigned long *p2m_orig = p2m_top[topidx][mididx];\r\np2m = alloc_p2m_page();\r\nif (!p2m)\r\nreturn false;\r\np2m_init(p2m);\r\nif (cmpxchg(&mid[mididx], p2m_orig, p2m) != p2m_orig)\r\nfree_p2m_page(p2m);\r\nelse\r\nmid_mfn[mididx] = virt_to_mfn(p2m);\r\n}\r\nreturn true;\r\n}\r\nstatic bool __init early_alloc_p2m_middle(unsigned long pfn, bool check_boundary)\r\n{\r\nunsigned topidx, mididx, idx;\r\nunsigned long *p2m;\r\nunsigned long *mid_mfn_p;\r\ntopidx = p2m_top_index(pfn);\r\nmididx = p2m_mid_index(pfn);\r\nidx = p2m_index(pfn);\r\nif (!idx && check_boundary)\r\nreturn false;\r\nWARN(p2m_top[topidx][mididx] == p2m_identity,\r\n"P2M[%d][%d] == IDENTITY, should be MISSING (or alloced)!\n",\r\ntopidx, mididx);\r\nif (p2m_top[topidx][mididx] != p2m_missing)\r\nreturn false;\r\np2m = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_init(p2m);\r\np2m_top[topidx][mididx] = p2m;\r\nmid_mfn_p = p2m_top_mfn_p[topidx];\r\nWARN(mid_mfn_p[mididx] != virt_to_mfn(p2m_missing),\r\n"P2M_TOP_P[%d][%d] != MFN of p2m_missing!\n",\r\ntopidx, mididx);\r\nmid_mfn_p[mididx] = virt_to_mfn(p2m);\r\nreturn true;\r\n}\r\nstatic bool __init early_alloc_p2m(unsigned long pfn)\r\n{\r\nunsigned topidx = p2m_top_index(pfn);\r\nunsigned long *mid_mfn_p;\r\nunsigned long **mid;\r\nmid = p2m_top[topidx];\r\nmid_mfn_p = p2m_top_mfn_p[topidx];\r\nif (mid == p2m_mid_missing) {\r\nmid = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_mid_init(mid);\r\np2m_top[topidx] = mid;\r\nBUG_ON(mid_mfn_p != p2m_mid_missing_mfn);\r\n}\r\nif (mid_mfn_p == p2m_mid_missing_mfn) {\r\nmid_mfn_p = extend_brk(PAGE_SIZE, PAGE_SIZE);\r\np2m_mid_mfn_init(mid_mfn_p);\r\np2m_top_mfn_p[topidx] = mid_mfn_p;\r\np2m_top_mfn[topidx] = virt_to_mfn(mid_mfn_p);\r\n}\r\nreturn true;\r\n}\r\nbool __init early_can_reuse_p2m_middle(unsigned long set_pfn, unsigned long set_mfn)\r\n{\r\nunsigned topidx;\r\nunsigned mididx;\r\nunsigned ident_pfns;\r\nunsigned inv_pfns;\r\nunsigned long *p2m;\r\nunsigned long *mid_mfn_p;\r\nunsigned idx;\r\nunsigned long pfn;\r\nif (p2m_index(set_pfn))\r\nreturn false;\r\nfor (pfn = 0; pfn < MAX_DOMAIN_PAGES; pfn += P2M_PER_PAGE) {\r\ntopidx = p2m_top_index(pfn);\r\nif (!p2m_top[topidx])\r\ncontinue;\r\nif (p2m_top[topidx] == p2m_mid_missing)\r\ncontinue;\r\nmididx = p2m_mid_index(pfn);\r\np2m = p2m_top[topidx][mididx];\r\nif (!p2m)\r\ncontinue;\r\nif ((p2m == p2m_missing) || (p2m == p2m_identity))\r\ncontinue;\r\nif ((unsigned long)p2m == INVALID_P2M_ENTRY)\r\ncontinue;\r\nident_pfns = 0;\r\ninv_pfns = 0;\r\nfor (idx = 0; idx < P2M_PER_PAGE; idx++) {\r\nif (p2m[idx] == IDENTITY_FRAME(pfn + idx))\r\nident_pfns++;\r\nelse if (p2m[idx] == INVALID_P2M_ENTRY)\r\ninv_pfns++;\r\nelse\r\nbreak;\r\n}\r\nif ((ident_pfns == P2M_PER_PAGE) || (inv_pfns == P2M_PER_PAGE))\r\ngoto found;\r\n}\r\nreturn false;\r\nfound:\r\np2m_top[topidx][mididx] = (ident_pfns ? p2m_identity : p2m_missing);\r\nmid_mfn_p = p2m_top_mfn_p[topidx];\r\nmid_mfn_p[mididx] = virt_to_mfn(p2m_missing);\r\ntopidx = p2m_top_index(set_pfn);\r\nmididx = p2m_mid_index(set_pfn);\r\nif (WARN_ON(p2m_top[topidx] == p2m_mid_missing))\r\nearly_alloc_p2m(set_pfn);\r\nif (WARN_ON(p2m_top[topidx][mididx] != p2m_missing))\r\nreturn false;\r\np2m_init(p2m);\r\np2m_top[topidx][mididx] = p2m;\r\nmid_mfn_p = p2m_top_mfn_p[topidx];\r\nmid_mfn_p[mididx] = virt_to_mfn(p2m);\r\nreturn true;\r\n}\r\nbool __init early_set_phys_to_machine(unsigned long pfn, unsigned long mfn)\r\n{\r\nif (unlikely(!__set_phys_to_machine(pfn, mfn))) {\r\nif (!early_alloc_p2m(pfn))\r\nreturn false;\r\nif (early_can_reuse_p2m_middle(pfn, mfn))\r\nreturn __set_phys_to_machine(pfn, mfn);\r\nif (!early_alloc_p2m_middle(pfn, false ))\r\nreturn false;\r\nif (!__set_phys_to_machine(pfn, mfn))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nunsigned long __init set_phys_range_identity(unsigned long pfn_s,\r\nunsigned long pfn_e)\r\n{\r\nunsigned long pfn;\r\nif (unlikely(pfn_s >= MAX_P2M_PFN || pfn_e >= MAX_P2M_PFN))\r\nreturn 0;\r\nif (unlikely(xen_feature(XENFEAT_auto_translated_physmap)))\r\nreturn pfn_e - pfn_s;\r\nif (pfn_s > pfn_e)\r\nreturn 0;\r\nfor (pfn = (pfn_s & ~(P2M_MID_PER_PAGE * P2M_PER_PAGE - 1));\r\npfn < ALIGN(pfn_e, (P2M_MID_PER_PAGE * P2M_PER_PAGE));\r\npfn += P2M_MID_PER_PAGE * P2M_PER_PAGE)\r\n{\r\nWARN_ON(!early_alloc_p2m(pfn));\r\n}\r\nearly_alloc_p2m_middle(pfn_s, true);\r\nearly_alloc_p2m_middle(pfn_e, true);\r\nfor (pfn = pfn_s; pfn < pfn_e; pfn++)\r\nif (!__set_phys_to_machine(pfn, IDENTITY_FRAME(pfn)))\r\nbreak;\r\nif (!WARN((pfn - pfn_s) != (pfn_e - pfn_s),\r\n"Identity mapping failed. We are %ld short of 1-1 mappings!\n",\r\n(pfn_e - pfn_s) - (pfn - pfn_s)))\r\nprintk(KERN_DEBUG "1-1 mapping on %lx->%lx\n", pfn_s, pfn);\r\nreturn pfn - pfn_s;\r\n}\r\nbool __set_phys_to_machine(unsigned long pfn, unsigned long mfn)\r\n{\r\nunsigned topidx, mididx, idx;\r\nif (unlikely(xen_feature(XENFEAT_auto_translated_physmap))) {\r\nBUG_ON(pfn != mfn && mfn != INVALID_P2M_ENTRY);\r\nreturn true;\r\n}\r\nif (unlikely(pfn >= MAX_P2M_PFN)) {\r\nBUG_ON(mfn != INVALID_P2M_ENTRY);\r\nreturn true;\r\n}\r\ntopidx = p2m_top_index(pfn);\r\nmididx = p2m_mid_index(pfn);\r\nidx = p2m_index(pfn);\r\nif (mfn != INVALID_P2M_ENTRY && (mfn & IDENTITY_FRAME_BIT)) {\r\nif (p2m_top[topidx][mididx] == p2m_identity)\r\nreturn true;\r\nif (p2m_top[topidx][mididx] == p2m_missing) {\r\nWARN_ON(cmpxchg(&p2m_top[topidx][mididx], p2m_missing,\r\np2m_identity) != p2m_missing);\r\nreturn true;\r\n}\r\n}\r\nif (p2m_top[topidx][mididx] == p2m_missing)\r\nreturn mfn == INVALID_P2M_ENTRY;\r\np2m_top[topidx][mididx][idx] = mfn;\r\nreturn true;\r\n}\r\nbool set_phys_to_machine(unsigned long pfn, unsigned long mfn)\r\n{\r\nif (unlikely(!__set_phys_to_machine(pfn, mfn))) {\r\nif (!alloc_p2m(pfn))\r\nreturn false;\r\nif (!__set_phys_to_machine(pfn, mfn))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void __init m2p_override_init(void)\r\n{\r\nunsigned i;\r\nm2p_overrides = extend_brk(sizeof(*m2p_overrides) * M2P_OVERRIDE_HASH,\r\nsizeof(unsigned long));\r\nfor (i = 0; i < M2P_OVERRIDE_HASH; i++)\r\nINIT_LIST_HEAD(&m2p_overrides[i]);\r\n}\r\nstatic unsigned long mfn_hash(unsigned long mfn)\r\n{\r\nreturn hash_long(mfn, M2P_OVERRIDE_HASH_SHIFT);\r\n}\r\nint m2p_add_override(unsigned long mfn, struct page *page,\r\nstruct gnttab_map_grant_ref *kmap_op)\r\n{\r\nunsigned long flags;\r\nunsigned long pfn;\r\nunsigned long uninitialized_var(address);\r\nunsigned level;\r\npte_t *ptep = NULL;\r\nint ret = 0;\r\npfn = page_to_pfn(page);\r\nif (!PageHighMem(page)) {\r\naddress = (unsigned long)__va(pfn << PAGE_SHIFT);\r\nptep = lookup_address(address, &level);\r\nif (WARN(ptep == NULL || level != PG_LEVEL_4K,\r\n"m2p_add_override: pfn %lx not mapped", pfn))\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(PagePrivate(page));\r\nSetPagePrivate(page);\r\nset_page_private(page, mfn);\r\npage->index = pfn_to_mfn(pfn);\r\nif (unlikely(!set_phys_to_machine(pfn, FOREIGN_FRAME(mfn))))\r\nreturn -ENOMEM;\r\nif (kmap_op != NULL) {\r\nif (!PageHighMem(page)) {\r\nstruct multicall_space mcs =\r\nxen_mc_entry(sizeof(*kmap_op));\r\nMULTI_grant_table_op(mcs.mc,\r\nGNTTABOP_map_grant_ref, kmap_op, 1);\r\nxen_mc_issue(PARAVIRT_LAZY_MMU);\r\n}\r\n}\r\nspin_lock_irqsave(&m2p_override_lock, flags);\r\nlist_add(&page->lru, &m2p_overrides[mfn_hash(mfn)]);\r\nspin_unlock_irqrestore(&m2p_override_lock, flags);\r\nret = __get_user(pfn, &machine_to_phys_mapping[mfn]);\r\nif (ret == 0 && get_phys_to_machine(pfn) == mfn)\r\nset_phys_to_machine(pfn, FOREIGN_FRAME(mfn));\r\nreturn 0;\r\n}\r\nint m2p_remove_override(struct page *page,\r\nstruct gnttab_map_grant_ref *kmap_op)\r\n{\r\nunsigned long flags;\r\nunsigned long mfn;\r\nunsigned long pfn;\r\nunsigned long uninitialized_var(address);\r\nunsigned level;\r\npte_t *ptep = NULL;\r\nint ret = 0;\r\npfn = page_to_pfn(page);\r\nmfn = get_phys_to_machine(pfn);\r\nif (mfn == INVALID_P2M_ENTRY || !(mfn & FOREIGN_FRAME_BIT))\r\nreturn -EINVAL;\r\nif (!PageHighMem(page)) {\r\naddress = (unsigned long)__va(pfn << PAGE_SHIFT);\r\nptep = lookup_address(address, &level);\r\nif (WARN(ptep == NULL || level != PG_LEVEL_4K,\r\n"m2p_remove_override: pfn %lx not mapped", pfn))\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&m2p_override_lock, flags);\r\nlist_del(&page->lru);\r\nspin_unlock_irqrestore(&m2p_override_lock, flags);\r\nWARN_ON(!PagePrivate(page));\r\nClearPagePrivate(page);\r\nset_phys_to_machine(pfn, page->index);\r\nif (kmap_op != NULL) {\r\nif (!PageHighMem(page)) {\r\nstruct multicall_space mcs;\r\nstruct gnttab_unmap_grant_ref *unmap_op;\r\nif (kmap_op->handle == -1)\r\nxen_mc_flush();\r\nif (kmap_op->handle == GNTST_general_error) {\r\nprintk(KERN_WARNING "m2p_remove_override: "\r\n"pfn %lx mfn %lx, failed to modify kernel mappings",\r\npfn, mfn);\r\nreturn -1;\r\n}\r\nmcs = xen_mc_entry(\r\nsizeof(struct gnttab_unmap_grant_ref));\r\nunmap_op = mcs.args;\r\nunmap_op->host_addr = kmap_op->host_addr;\r\nunmap_op->handle = kmap_op->handle;\r\nunmap_op->dev_bus_addr = 0;\r\nMULTI_grant_table_op(mcs.mc,\r\nGNTTABOP_unmap_grant_ref, unmap_op, 1);\r\nxen_mc_issue(PARAVIRT_LAZY_MMU);\r\nset_pte_at(&init_mm, address, ptep,\r\npfn_pte(pfn, PAGE_KERNEL));\r\n__flush_tlb_single(address);\r\nkmap_op->host_addr = 0;\r\n}\r\n}\r\nmfn &= ~FOREIGN_FRAME_BIT;\r\nret = __get_user(pfn, &machine_to_phys_mapping[mfn]);\r\nif (ret == 0 && get_phys_to_machine(pfn) == FOREIGN_FRAME(mfn) &&\r\nm2p_find_override(mfn) == NULL)\r\nset_phys_to_machine(pfn, mfn);\r\nreturn 0;\r\n}\r\nstruct page *m2p_find_override(unsigned long mfn)\r\n{\r\nunsigned long flags;\r\nstruct list_head *bucket = &m2p_overrides[mfn_hash(mfn)];\r\nstruct page *p, *ret;\r\nret = NULL;\r\nspin_lock_irqsave(&m2p_override_lock, flags);\r\nlist_for_each_entry(p, bucket, lru) {\r\nif (page_private(p) == mfn) {\r\nret = p;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&m2p_override_lock, flags);\r\nreturn ret;\r\n}\r\nunsigned long m2p_find_override_pfn(unsigned long mfn, unsigned long pfn)\r\n{\r\nstruct page *p = m2p_find_override(mfn);\r\nunsigned long ret = pfn;\r\nif (p)\r\nret = page_to_pfn(p);\r\nreturn ret;\r\n}\r\nstatic int p2m_dump_show(struct seq_file *m, void *v)\r\n{\r\nstatic const char * const level_name[] = { "top", "middle",\r\n"entry", "abnormal", "error"};\r\n#define TYPE_IDENTITY 0\r\n#define TYPE_MISSING 1\r\n#define TYPE_PFN 2\r\n#define TYPE_UNKNOWN 3\r\nstatic const char * const type_name[] = {\r\n[TYPE_IDENTITY] = "identity",\r\n[TYPE_MISSING] = "missing",\r\n[TYPE_PFN] = "pfn",\r\n[TYPE_UNKNOWN] = "abnormal"};\r\nunsigned long pfn, prev_pfn_type = 0, prev_pfn_level = 0;\r\nunsigned int uninitialized_var(prev_level);\r\nunsigned int uninitialized_var(prev_type);\r\nif (!p2m_top)\r\nreturn 0;\r\nfor (pfn = 0; pfn < MAX_DOMAIN_PAGES; pfn++) {\r\nunsigned topidx = p2m_top_index(pfn);\r\nunsigned mididx = p2m_mid_index(pfn);\r\nunsigned idx = p2m_index(pfn);\r\nunsigned lvl, type;\r\nlvl = 4;\r\ntype = TYPE_UNKNOWN;\r\nif (p2m_top[topidx] == p2m_mid_missing) {\r\nlvl = 0; type = TYPE_MISSING;\r\n} else if (p2m_top[topidx] == NULL) {\r\nlvl = 0; type = TYPE_UNKNOWN;\r\n} else if (p2m_top[topidx][mididx] == NULL) {\r\nlvl = 1; type = TYPE_UNKNOWN;\r\n} else if (p2m_top[topidx][mididx] == p2m_identity) {\r\nlvl = 1; type = TYPE_IDENTITY;\r\n} else if (p2m_top[topidx][mididx] == p2m_missing) {\r\nlvl = 1; type = TYPE_MISSING;\r\n} else if (p2m_top[topidx][mididx][idx] == 0) {\r\nlvl = 2; type = TYPE_UNKNOWN;\r\n} else if (p2m_top[topidx][mididx][idx] == IDENTITY_FRAME(pfn)) {\r\nlvl = 2; type = TYPE_IDENTITY;\r\n} else if (p2m_top[topidx][mididx][idx] == INVALID_P2M_ENTRY) {\r\nlvl = 2; type = TYPE_MISSING;\r\n} else if (p2m_top[topidx][mididx][idx] == pfn) {\r\nlvl = 2; type = TYPE_PFN;\r\n} else if (p2m_top[topidx][mididx][idx] != pfn) {\r\nlvl = 2; type = TYPE_PFN;\r\n}\r\nif (pfn == 0) {\r\nprev_level = lvl;\r\nprev_type = type;\r\n}\r\nif (pfn == MAX_DOMAIN_PAGES-1) {\r\nlvl = 3;\r\ntype = TYPE_UNKNOWN;\r\n}\r\nif (prev_type != type) {\r\nseq_printf(m, " [0x%lx->0x%lx] %s\n",\r\nprev_pfn_type, pfn, type_name[prev_type]);\r\nprev_pfn_type = pfn;\r\nprev_type = type;\r\n}\r\nif (prev_level != lvl) {\r\nseq_printf(m, " [0x%lx->0x%lx] level %s\n",\r\nprev_pfn_level, pfn, level_name[prev_level]);\r\nprev_pfn_level = pfn;\r\nprev_level = lvl;\r\n}\r\n}\r\nreturn 0;\r\n#undef TYPE_IDENTITY\r\n#undef TYPE_MISSING\r\n#undef TYPE_PFN\r\n#undef TYPE_UNKNOWN\r\n}\r\nstatic int p2m_dump_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, p2m_dump_show, NULL);\r\n}\r\nstatic int __init xen_p2m_debugfs(void)\r\n{\r\nstruct dentry *d_xen = xen_init_debugfs();\r\nif (d_xen == NULL)\r\nreturn -ENOMEM;\r\nd_mmu_debug = debugfs_create_dir("mmu", d_xen);\r\ndebugfs_create_file("p2m", 0600, d_mmu_debug, NULL, &p2m_dump_fops);\r\nreturn 0;\r\n}
