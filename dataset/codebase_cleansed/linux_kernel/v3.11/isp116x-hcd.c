static void write_ptddata_to_fifo(struct isp116x *isp116x, void *buf, int len)\r\n{\r\nu8 *dp = (u8 *) buf;\r\nu16 *dp2 = (u16 *) buf;\r\nu16 w;\r\nint quot = len % 4;\r\nif ((unsigned long)dp2 & 1) {\r\nfor (; len > 1; len -= 2) {\r\nw = *dp++;\r\nw |= *dp++ << 8;\r\nisp116x_raw_write_data16(isp116x, w);\r\n}\r\nif (len)\r\nisp116x_write_data16(isp116x, (u16) * dp);\r\n} else {\r\nfor (; len > 1; len -= 2) {\r\nisp116x_raw_write_data16(isp116x, cpu_to_le16(*dp2++));\r\n}\r\nif (len)\r\nisp116x_write_data16(isp116x, 0xff & *((u8 *) dp2));\r\n}\r\nif (quot == 1 || quot == 2)\r\nisp116x_raw_write_data16(isp116x, 0);\r\n}\r\nstatic void read_ptddata_from_fifo(struct isp116x *isp116x, void *buf, int len)\r\n{\r\nu8 *dp = (u8 *) buf;\r\nu16 *dp2 = (u16 *) buf;\r\nu16 w;\r\nint quot = len % 4;\r\nif ((unsigned long)dp2 & 1) {\r\nfor (; len > 1; len -= 2) {\r\nw = isp116x_raw_read_data16(isp116x);\r\n*dp++ = w & 0xff;\r\n*dp++ = (w >> 8) & 0xff;\r\n}\r\nif (len)\r\n*dp = 0xff & isp116x_read_data16(isp116x);\r\n} else {\r\nfor (; len > 1; len -= 2) {\r\n*dp2++ = le16_to_cpu(isp116x_raw_read_data16(isp116x));\r\n}\r\nif (len)\r\n*(u8 *) dp2 = 0xff & isp116x_read_data16(isp116x);\r\n}\r\nif (quot == 1 || quot == 2)\r\nisp116x_raw_read_data16(isp116x);\r\n}\r\nstatic void pack_fifo(struct isp116x *isp116x)\r\n{\r\nstruct isp116x_ep *ep;\r\nstruct ptd *ptd;\r\nint buflen = isp116x->atl_last_dir == PTD_DIR_IN\r\n? isp116x->atl_bufshrt : isp116x->atl_buflen;\r\nisp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);\r\nisp116x_write_reg16(isp116x, HCXFERCTR, buflen);\r\nisp116x_write_addr(isp116x, HCATLPORT | ISP116x_WRITE_OFFSET);\r\nfor (ep = isp116x->atl_active; ep; ep = ep->active) {\r\nptd = &ep->ptd;\r\ndump_ptd(ptd);\r\ndump_ptd_out_data(ptd, ep->data);\r\nisp116x_write_data16(isp116x, ptd->count);\r\nisp116x_write_data16(isp116x, ptd->mps);\r\nisp116x_write_data16(isp116x, ptd->len);\r\nisp116x_write_data16(isp116x, ptd->faddr);\r\nbuflen -= sizeof(struct ptd);\r\nif (ep->active || (isp116x->atl_last_dir != PTD_DIR_IN)) {\r\nwrite_ptddata_to_fifo(isp116x, ep->data, ep->length);\r\nbuflen -= ALIGN(ep->length, 4);\r\n}\r\n}\r\nBUG_ON(buflen);\r\n}\r\nstatic void unpack_fifo(struct isp116x *isp116x)\r\n{\r\nstruct isp116x_ep *ep;\r\nstruct ptd *ptd;\r\nint buflen = isp116x->atl_last_dir == PTD_DIR_IN\r\n? isp116x->atl_buflen : isp116x->atl_bufshrt;\r\nisp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);\r\nisp116x_write_reg16(isp116x, HCXFERCTR, buflen);\r\nisp116x_write_addr(isp116x, HCATLPORT);\r\nfor (ep = isp116x->atl_active; ep; ep = ep->active) {\r\nptd = &ep->ptd;\r\nptd->count = isp116x_read_data16(isp116x);\r\nptd->mps = isp116x_read_data16(isp116x);\r\nptd->len = isp116x_read_data16(isp116x);\r\nptd->faddr = isp116x_read_data16(isp116x);\r\nbuflen -= sizeof(struct ptd);\r\nif (ep->active || (isp116x->atl_last_dir == PTD_DIR_IN)) {\r\nread_ptddata_from_fifo(isp116x, ep->data, ep->length);\r\nbuflen -= ALIGN(ep->length, 4);\r\n}\r\ndump_ptd(ptd);\r\ndump_ptd_in_data(ptd, ep->data);\r\n}\r\nBUG_ON(buflen);\r\n}\r\nstatic void preproc_atl_queue(struct isp116x *isp116x)\r\n{\r\nstruct isp116x_ep *ep;\r\nstruct urb *urb;\r\nstruct ptd *ptd;\r\nu16 len;\r\nfor (ep = isp116x->atl_active; ep; ep = ep->active) {\r\nu16 toggle = 0, dir = PTD_DIR_SETUP;\r\nBUG_ON(list_empty(&ep->hep->urb_list));\r\nurb = container_of(ep->hep->urb_list.next,\r\nstruct urb, urb_list);\r\nptd = &ep->ptd;\r\nlen = ep->length;\r\nep->data = (unsigned char *)urb->transfer_buffer\r\n+ urb->actual_length;\r\nswitch (ep->nextpid) {\r\ncase USB_PID_IN:\r\ntoggle = usb_gettoggle(urb->dev, ep->epnum, 0);\r\ndir = PTD_DIR_IN;\r\nbreak;\r\ncase USB_PID_OUT:\r\ntoggle = usb_gettoggle(urb->dev, ep->epnum, 1);\r\ndir = PTD_DIR_OUT;\r\nbreak;\r\ncase USB_PID_SETUP:\r\nlen = sizeof(struct usb_ctrlrequest);\r\nep->data = urb->setup_packet;\r\nbreak;\r\ncase USB_PID_ACK:\r\ntoggle = 1;\r\nlen = 0;\r\ndir = (urb->transfer_buffer_length\r\n&& usb_pipein(urb->pipe))\r\n? PTD_DIR_OUT : PTD_DIR_IN;\r\nbreak;\r\ndefault:\r\nERR("%s %d: ep->nextpid %d\n", __func__, __LINE__,\r\nep->nextpid);\r\nBUG();\r\n}\r\nptd->count = PTD_CC_MSK | PTD_ACTIVE_MSK | PTD_TOGGLE(toggle);\r\nptd->mps = PTD_MPS(ep->maxpacket)\r\n| PTD_SPD(urb->dev->speed == USB_SPEED_LOW)\r\n| PTD_EP(ep->epnum);\r\nptd->len = PTD_LEN(len) | PTD_DIR(dir);\r\nptd->faddr = PTD_FA(usb_pipedevice(urb->pipe));\r\nif (!ep->active) {\r\nptd->mps |= PTD_LAST_MSK;\r\nisp116x->atl_last_dir = dir;\r\n}\r\nisp116x->atl_bufshrt = sizeof(struct ptd) + isp116x->atl_buflen;\r\nisp116x->atl_buflen = isp116x->atl_bufshrt + ALIGN(len, 4);\r\n}\r\n}\r\nstatic void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,\r\nstruct urb *urb, int status)\r\n__releases(isp116x->lock) __acquires(isp116x->lock)\r\n{\r\nunsigned i;\r\nep->error_count = 0;\r\nif (usb_pipecontrol(urb->pipe))\r\nep->nextpid = USB_PID_SETUP;\r\nurb_dbg(urb, "Finish");\r\nusb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);\r\nspin_unlock(&isp116x->lock);\r\nusb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb, status);\r\nspin_lock(&isp116x->lock);\r\nif (!list_empty(&ep->hep->urb_list))\r\nreturn;\r\nif (!list_empty(&ep->schedule)) {\r\nlist_del_init(&ep->schedule);\r\nreturn;\r\n}\r\nDBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);\r\nfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\r\nstruct isp116x_ep *temp;\r\nstruct isp116x_ep **prev = &isp116x->periodic[i];\r\nwhile (*prev && ((temp = *prev) != ep))\r\nprev = &temp->next;\r\nif (*prev)\r\n*prev = ep->next;\r\nisp116x->load[i] -= ep->load;\r\n}\r\nep->branch = PERIODIC_SIZE;\r\nisp116x_to_hcd(isp116x)->self.bandwidth_allocated -=\r\nep->load / ep->period;\r\nif (!--isp116x->periodic_count) {\r\nisp116x->irqenb &= ~HCuPINT_SOF;\r\nisp116x->irqenb |= HCuPINT_ATL;\r\n}\r\n}\r\nstatic void postproc_atl_queue(struct isp116x *isp116x)\r\n{\r\nstruct isp116x_ep *ep;\r\nstruct urb *urb;\r\nstruct usb_device *udev;\r\nstruct ptd *ptd;\r\nint short_not_ok;\r\nint status;\r\nu8 cc;\r\nfor (ep = isp116x->atl_active; ep; ep = ep->active) {\r\nBUG_ON(list_empty(&ep->hep->urb_list));\r\nurb =\r\ncontainer_of(ep->hep->urb_list.next, struct urb, urb_list);\r\nudev = urb->dev;\r\nptd = &ep->ptd;\r\ncc = PTD_GET_CC(ptd);\r\nshort_not_ok = 1;\r\nstatus = -EINPROGRESS;\r\nif (cc == TD_DATAUNDERRUN) {\r\nif (!(urb->transfer_flags & URB_SHORT_NOT_OK) ||\r\nusb_pipecontrol(urb->pipe)) {\r\nDBG("Allowed or control data underrun\n");\r\ncc = TD_CC_NOERROR;\r\nshort_not_ok = 0;\r\n} else {\r\nep->error_count = 1;\r\nusb_settoggle(udev, ep->epnum,\r\nep->nextpid == USB_PID_OUT,\r\nPTD_GET_TOGGLE(ptd));\r\nurb->actual_length += PTD_GET_COUNT(ptd);\r\nstatus = cc_to_error[TD_DATAUNDERRUN];\r\ngoto done;\r\n}\r\n}\r\nif (cc != TD_CC_NOERROR && cc != TD_NOTACCESSED\r\n&& (++ep->error_count >= 3 || cc == TD_CC_STALL\r\n|| cc == TD_DATAOVERRUN)) {\r\nstatus = cc_to_error[cc];\r\nif (ep->nextpid == USB_PID_ACK)\r\nep->nextpid = 0;\r\ngoto done;\r\n}\r\nif (usb_pipeint(urb->pipe) && !PTD_GET_LEN(ptd)) {\r\nstatus = 0;\r\ngoto done;\r\n}\r\nif (ep->error_count\r\n&& (cc == TD_CC_NOERROR || cc == TD_NOTACCESSED))\r\nep->error_count = 0;\r\nif (ep->nextpid == USB_PID_OUT)\r\nusb_settoggle(udev, ep->epnum, 1, PTD_GET_TOGGLE(ptd)\r\n^ (ep->error_count > 0));\r\nelse if (ep->nextpid == USB_PID_IN)\r\nusb_settoggle(udev, ep->epnum, 0, PTD_GET_TOGGLE(ptd)\r\n^ (ep->error_count > 0));\r\nswitch (ep->nextpid) {\r\ncase USB_PID_IN:\r\ncase USB_PID_OUT:\r\nurb->actual_length += PTD_GET_COUNT(ptd);\r\nif (PTD_GET_ACTIVE(ptd)\r\n|| (cc != TD_CC_NOERROR && cc < 0x0E))\r\nbreak;\r\nif (urb->transfer_buffer_length != urb->actual_length) {\r\nif (short_not_ok)\r\nbreak;\r\n} else {\r\nif (urb->transfer_flags & URB_ZERO_PACKET\r\n&& ep->nextpid == USB_PID_OUT\r\n&& !(PTD_GET_COUNT(ptd) % ep->maxpacket)) {\r\nDBG("Zero packet requested\n");\r\nbreak;\r\n}\r\n}\r\nif (usb_pipecontrol(urb->pipe))\r\nep->nextpid = USB_PID_ACK;\r\nelse\r\nstatus = 0;\r\nbreak;\r\ncase USB_PID_SETUP:\r\nif (PTD_GET_ACTIVE(ptd)\r\n|| (cc != TD_CC_NOERROR && cc < 0x0E))\r\nbreak;\r\nif (urb->transfer_buffer_length == urb->actual_length)\r\nep->nextpid = USB_PID_ACK;\r\nelse if (usb_pipeout(urb->pipe)) {\r\nusb_settoggle(udev, 0, 1, 1);\r\nep->nextpid = USB_PID_OUT;\r\n} else {\r\nusb_settoggle(udev, 0, 0, 1);\r\nep->nextpid = USB_PID_IN;\r\n}\r\nbreak;\r\ncase USB_PID_ACK:\r\nif (PTD_GET_ACTIVE(ptd)\r\n|| (cc != TD_CC_NOERROR && cc < 0x0E))\r\nbreak;\r\nstatus = 0;\r\nep->nextpid = 0;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndone:\r\nif (status != -EINPROGRESS || urb->unlinked)\r\nfinish_request(isp116x, ep, urb, status);\r\n}\r\n}\r\nstatic void start_atl_transfers(struct isp116x *isp116x)\r\n{\r\nstruct isp116x_ep *last_ep = NULL, *ep;\r\nstruct urb *urb;\r\nu16 load = 0;\r\nint len, index, speed, byte_time;\r\nif (atomic_read(&isp116x->atl_finishing))\r\nreturn;\r\nif (!HC_IS_RUNNING(isp116x_to_hcd(isp116x)->state))\r\nreturn;\r\nif (isp116x_read_reg16(isp116x, HCBUFSTAT) & HCBUFSTAT_ATL_FULL)\r\nreturn;\r\nisp116x->atl_active = NULL;\r\nisp116x->atl_buflen = isp116x->atl_bufshrt = 0;\r\nif (isp116x->periodic_count) {\r\nisp116x->fmindex = index =\r\n(isp116x->fmindex + 1) & (PERIODIC_SIZE - 1);\r\nif ((load = isp116x->load[index])) {\r\nisp116x->atl_active = last_ep =\r\nisp116x->periodic[index];\r\nwhile (last_ep->next)\r\nlast_ep = (last_ep->active = last_ep->next);\r\nlast_ep->active = NULL;\r\n}\r\n}\r\nlist_for_each_entry(ep, &isp116x->async, schedule) {\r\nurb = container_of(ep->hep->urb_list.next,\r\nstruct urb, urb_list);\r\nspeed = urb->dev->speed;\r\nbyte_time = speed == USB_SPEED_LOW\r\n? BYTE_TIME_LOWSPEED : BYTE_TIME_FULLSPEED;\r\nif (ep->nextpid == USB_PID_SETUP) {\r\nlen = sizeof(struct usb_ctrlrequest);\r\n} else if (ep->nextpid == USB_PID_ACK) {\r\nlen = 0;\r\n} else {\r\nlen = (MAX_LOAD_LIMIT - load) / byte_time;\r\nlen = min(len, speed == USB_SPEED_LOW ?\r\nMAX_TRANSFER_SIZE_LOWSPEED :\r\nMAX_TRANSFER_SIZE_FULLSPEED);\r\nif (len <\r\n(urb->transfer_buffer_length -\r\nurb->actual_length)) {\r\nlen -= len % ep->maxpacket;\r\nif (!len)\r\ncontinue;\r\n} else\r\nlen = urb->transfer_buffer_length -\r\nurb->actual_length;\r\nBUG_ON(len < 0);\r\n}\r\nload += len * byte_time;\r\nif (load > MAX_LOAD_LIMIT)\r\nbreak;\r\nep->active = NULL;\r\nep->length = len;\r\nif (last_ep)\r\nlast_ep->active = ep;\r\nelse\r\nisp116x->atl_active = ep;\r\nlast_ep = ep;\r\n}\r\nif ((&isp116x->async)->next != (&isp116x->async)->prev)\r\nlist_move(&isp116x->async, (&isp116x->async)->next);\r\nif (isp116x->atl_active) {\r\npreproc_atl_queue(isp116x);\r\npack_fifo(isp116x);\r\n}\r\n}\r\nstatic void finish_atl_transfers(struct isp116x *isp116x)\r\n{\r\nif (!isp116x->atl_active)\r\nreturn;\r\nif (!(isp116x_read_reg16(isp116x, HCBUFSTAT) & HCBUFSTAT_ATL_DONE))\r\nreturn;\r\natomic_inc(&isp116x->atl_finishing);\r\nunpack_fifo(isp116x);\r\npostproc_atl_queue(isp116x);\r\natomic_dec(&isp116x->atl_finishing);\r\n}\r\nstatic irqreturn_t isp116x_irq(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nu16 irqstat;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&isp116x->lock);\r\nisp116x_write_reg16(isp116x, HCuPINTENB, 0);\r\nirqstat = isp116x_read_reg16(isp116x, HCuPINT);\r\nisp116x_write_reg16(isp116x, HCuPINT, irqstat);\r\nif (irqstat & (HCuPINT_ATL | HCuPINT_SOF)) {\r\nret = IRQ_HANDLED;\r\nfinish_atl_transfers(isp116x);\r\n}\r\nif (irqstat & HCuPINT_OPR) {\r\nu32 intstat = isp116x_read_reg32(isp116x, HCINTSTAT);\r\nisp116x_write_reg32(isp116x, HCINTSTAT, intstat);\r\nif (intstat & HCINT_UE) {\r\nERR("Unrecoverable error, HC is dead!\n");\r\nhcd->state = HC_STATE_HALT;\r\nusb_hc_died(hcd);\r\nret = IRQ_HANDLED;\r\ngoto done;\r\n}\r\nif (intstat & HCINT_RHSC)\r\nmod_timer(&hcd->rh_timer, jiffies\r\n+ msecs_to_jiffies(20) + 1);\r\nif (intstat & HCINT_RD) {\r\nDBG("---- remote wakeup\n");\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\nirqstat &= ~HCuPINT_OPR;\r\nret = IRQ_HANDLED;\r\n}\r\nif (irqstat & (HCuPINT_ATL | HCuPINT_SOF)) {\r\nstart_atl_transfers(isp116x);\r\n}\r\nisp116x_write_reg16(isp116x, HCuPINTENB, isp116x->irqenb);\r\ndone:\r\nspin_unlock(&isp116x->lock);\r\nreturn ret;\r\n}\r\nstatic int balance(struct isp116x *isp116x, u16 period, u16 load)\r\n{\r\nint i, branch = -ENOSPC;\r\nfor (i = 0; i < period; i++) {\r\nif (branch < 0 || isp116x->load[branch] > isp116x->load[i]) {\r\nint j;\r\nfor (j = i; j < PERIODIC_SIZE; j += period) {\r\nif ((isp116x->load[j] + load)\r\n> MAX_PERIODIC_LOAD)\r\nbreak;\r\n}\r\nif (j < PERIODIC_SIZE)\r\ncontinue;\r\nbranch = i;\r\n}\r\n}\r\nreturn branch;\r\n}\r\nstatic int isp116x_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nstruct usb_device *udev = urb->dev;\r\nunsigned int pipe = urb->pipe;\r\nint is_out = !usb_pipein(pipe);\r\nint type = usb_pipetype(pipe);\r\nint epnum = usb_pipeendpoint(pipe);\r\nstruct usb_host_endpoint *hep = urb->ep;\r\nstruct isp116x_ep *ep = NULL;\r\nunsigned long flags;\r\nint i;\r\nint ret = 0;\r\nurb_dbg(urb, "Enqueue");\r\nif (type == PIPE_ISOCHRONOUS) {\r\nERR("Isochronous transfers not supported\n");\r\nurb_dbg(urb, "Refused to enqueue");\r\nreturn -ENXIO;\r\n}\r\nif (!hep->hcpriv) {\r\nep = kzalloc(sizeof *ep, mem_flags);\r\nif (!ep)\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nif (!HC_IS_RUNNING(hcd->state)) {\r\nkfree(ep);\r\nret = -ENODEV;\r\ngoto fail_not_linked;\r\n}\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret) {\r\nkfree(ep);\r\ngoto fail_not_linked;\r\n}\r\nif (hep->hcpriv)\r\nep = hep->hcpriv;\r\nelse {\r\nINIT_LIST_HEAD(&ep->schedule);\r\nep->udev = udev;\r\nep->epnum = epnum;\r\nep->maxpacket = usb_maxpacket(udev, urb->pipe, is_out);\r\nusb_settoggle(udev, epnum, is_out, 0);\r\nif (type == PIPE_CONTROL) {\r\nep->nextpid = USB_PID_SETUP;\r\n} else if (is_out) {\r\nep->nextpid = USB_PID_OUT;\r\n} else {\r\nep->nextpid = USB_PID_IN;\r\n}\r\nif (urb->interval) {\r\nif (urb->interval < 2)\r\nurb->interval = 2;\r\nif (urb->interval > 2 * PERIODIC_SIZE)\r\nurb->interval = 2 * PERIODIC_SIZE;\r\nep->period = urb->interval >> 1;\r\nep->branch = PERIODIC_SIZE;\r\nep->load = usb_calc_bus_time(udev->speed,\r\n!is_out,\r\n(type == PIPE_ISOCHRONOUS),\r\nusb_maxpacket(udev, pipe,\r\nis_out)) /\r\n1000;\r\n}\r\nhep->hcpriv = ep;\r\nep->hep = hep;\r\n}\r\nswitch (type) {\r\ncase PIPE_CONTROL:\r\ncase PIPE_BULK:\r\nif (list_empty(&ep->schedule))\r\nlist_add_tail(&ep->schedule, &isp116x->async);\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nurb->interval = ep->period;\r\nep->length = min_t(u32, ep->maxpacket,\r\nurb->transfer_buffer_length);\r\nif (ep->branch < PERIODIC_SIZE)\r\nbreak;\r\nep->branch = ret = balance(isp116x, ep->period, ep->load);\r\nif (ret < 0)\r\ngoto fail;\r\nret = 0;\r\nurb->start_frame = (isp116x->fmindex & (PERIODIC_SIZE - 1))\r\n+ ep->branch;\r\nDBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);\r\nfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\r\nstruct isp116x_ep **prev = &isp116x->periodic[i];\r\nstruct isp116x_ep *here = *prev;\r\nwhile (here && ep != here) {\r\nif (ep->period > here->period)\r\nbreak;\r\nprev = &here->next;\r\nhere = *prev;\r\n}\r\nif (ep != here) {\r\nep->next = here;\r\n*prev = ep;\r\n}\r\nisp116x->load[i] += ep->load;\r\n}\r\nhcd->self.bandwidth_allocated += ep->load / ep->period;\r\nif (!isp116x->periodic_count++) {\r\nisp116x->irqenb &= ~HCuPINT_ATL;\r\nisp116x->irqenb |= HCuPINT_SOF;\r\nisp116x_write_reg16(isp116x, HCuPINTENB,\r\nisp116x->irqenb);\r\n}\r\n}\r\nurb->hcpriv = hep;\r\nstart_atl_transfers(isp116x);\r\nfail:\r\nif (ret)\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nfail_not_linked:\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\r\nint status)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nstruct usb_host_endpoint *hep;\r\nstruct isp116x_ep *ep, *ep_act;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nhep = urb->hcpriv;\r\nep = hep->hcpriv;\r\nWARN_ON(hep != ep->hep);\r\nif (ep->hep->urb_list.next == &urb->urb_list)\r\nfor (ep_act = isp116x->atl_active; ep_act;\r\nep_act = ep_act->active)\r\nif (ep_act == ep) {\r\nVDBG("dequeue, urb %p active; wait for irq\n",\r\nurb);\r\nurb = NULL;\r\nbreak;\r\n}\r\nif (urb)\r\nfinish_request(isp116x, ep, urb, status);\r\ndone:\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void isp116x_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *hep)\r\n{\r\nint i;\r\nstruct isp116x_ep *ep = hep->hcpriv;\r\nif (!ep)\r\nreturn;\r\nfor (i = 0; i < 100 && !list_empty(&hep->urb_list); i++)\r\nmsleep(3);\r\nif (!list_empty(&hep->urb_list))\r\nWARNING("ep %p not empty?\n", ep);\r\nkfree(ep);\r\nhep->hcpriv = NULL;\r\n}\r\nstatic int isp116x_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nu32 fmnum;\r\nunsigned long flags;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nfmnum = isp116x_read_reg32(isp116x, HCFMNUM);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn (int)fmnum;\r\n}\r\nstatic int isp116x_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nint ports, i, changed = 0;\r\nunsigned long flags;\r\nif (!HC_IS_RUNNING(hcd->state))\r\nreturn -ESHUTDOWN;\r\nif (timer_pending(&hcd->rh_timer))\r\nreturn 0;\r\nports = isp116x->rhdesca & RH_A_NDP;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x->rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);\r\nif (isp116x->rhstatus & (RH_HS_LPSC | RH_HS_OCIC))\r\nbuf[0] = changed = 1;\r\nelse\r\nbuf[0] = 0;\r\nfor (i = 0; i < ports; i++) {\r\nu32 status = isp116x_read_reg32(isp116x, i ? HCRHPORT2 : HCRHPORT1);\r\nif (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC\r\n| RH_PS_OCIC | RH_PS_PRSC)) {\r\nchanged = 1;\r\nbuf[0] |= 1 << (i + 1);\r\n}\r\n}\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn changed;\r\n}\r\nstatic void isp116x_hub_descriptor(struct isp116x *isp116x,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nu32 reg = isp116x->rhdesca;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bDescLength = 9;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = (u8) (reg & 0x3);\r\ndesc->wHubCharacteristics = cpu_to_le16((u16) ((reg >> 8) & 0x1f));\r\ndesc->bPwrOn2PwrGood = (u8) ((reg >> 24) & 0xff);\r\ndesc->u.hs.DeviceRemovable[0] = 0;\r\ndesc->u.hs.DeviceRemovable[1] = ~0;\r\n}\r\nstatic inline void root_port_reset(struct isp116x *isp116x, unsigned port)\r\n{\r\nu32 tmp;\r\nunsigned long flags, t;\r\nt = jiffies + msecs_to_jiffies(100);\r\nwhile (time_before(jiffies, t)) {\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nfor (;;) {\r\ntmp = isp116x_read_reg32(isp116x, port ?\r\nHCRHPORT2 : HCRHPORT1);\r\nif (!(tmp & RH_PS_PRS))\r\nbreak;\r\nudelay(500);\r\n}\r\nif (!(tmp & RH_PS_CCS)) {\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nbreak;\r\n}\r\nisp116x_write_reg32(isp116x, port ? HCRHPORT2 :\r\nHCRHPORT1, (RH_PS_PRS));\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nmsleep(10);\r\n}\r\n}\r\nstatic int isp116x_hub_control(struct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue, u16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nint ret = 0;\r\nunsigned long flags;\r\nint ports = isp116x->rhdesca & RH_A_NDP;\r\nu32 tmp = 0;\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nDBG("ClearHubFeature: ");\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\nDBG("C_HUB_OVER_CURRENT\n");\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_OCIC);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\ncase C_HUB_LOCAL_POWER:\r\nDBG("C_HUB_LOCAL_POWER\n");\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetHubFeature:\r\nDBG("SetHubFeature: ");\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nDBG("C_HUB_OVER_CURRENT or C_HUB_LOCAL_POWER\n");\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nDBG("GetHubDescriptor\n");\r\nisp116x_hub_descriptor(isp116x,\r\n(struct usb_hub_descriptor *)buf);\r\nbreak;\r\ncase GetHubStatus:\r\nDBG("GetHubStatus\n");\r\n*(__le32 *) buf = 0;\r\nbreak;\r\ncase GetPortStatus:\r\nDBG("GetPortStatus\n");\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\ntmp = isp116x_read_reg32(isp116x, (--wIndex) ? HCRHPORT2 : HCRHPORT1);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\n*(__le32 *) buf = cpu_to_le32(tmp);\r\nDBG("GetPortStatus: port[%d] %08x\n", wIndex + 1, tmp);\r\nbreak;\r\ncase ClearPortFeature:\r\nDBG("ClearPortFeature: ");\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nDBG("USB_PORT_FEAT_ENABLE\n");\r\ntmp = RH_PS_CCS;\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nDBG("USB_PORT_FEAT_C_ENABLE\n");\r\ntmp = RH_PS_PESC;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nDBG("USB_PORT_FEAT_SUSPEND\n");\r\ntmp = RH_PS_POCI;\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nDBG("USB_PORT_FEAT_C_SUSPEND\n");\r\ntmp = RH_PS_PSSC;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nDBG("USB_PORT_FEAT_POWER\n");\r\ntmp = RH_PS_LSDA;\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nDBG("USB_PORT_FEAT_C_CONNECTION\n");\r\ntmp = RH_PS_CSC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nDBG("USB_PORT_FEAT_C_OVER_CURRENT\n");\r\ntmp = RH_PS_OCIC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nDBG("USB_PORT_FEAT_C_RESET\n");\r\ntmp = RH_PS_PRSC;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg32(isp116x, wIndex\r\n? HCRHPORT2 : HCRHPORT1, tmp);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nbreak;\r\ncase SetPortFeature:\r\nDBG("SetPortFeature: ");\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nDBG("USB_PORT_FEAT_SUSPEND\n");\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg32(isp116x, wIndex\r\n? HCRHPORT2 : HCRHPORT1, RH_PS_PSS);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nDBG("USB_PORT_FEAT_POWER\n");\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg32(isp116x, wIndex\r\n? HCRHPORT2 : HCRHPORT1, RH_PS_PPS);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nDBG("USB_PORT_FEAT_RESET\n");\r\nroot_port_reset(isp116x, wIndex);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nerror:\r\nDBG("PROTOCOL STALL\n");\r\nret = -EPIPE;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dump_irq(struct seq_file *s, char *label, u16 mask)\r\n{\r\nseq_printf(s, "%s %04x%s%s%s%s%s%s\n", label, mask,\r\nmask & HCuPINT_CLKRDY ? " clkrdy" : "",\r\nmask & HCuPINT_SUSP ? " susp" : "",\r\nmask & HCuPINT_OPR ? " opr" : "",\r\nmask & HCuPINT_AIIEOT ? " eot" : "",\r\nmask & HCuPINT_ATL ? " atl" : "",\r\nmask & HCuPINT_SOF ? " sof" : "");\r\n}\r\nstatic void dump_int(struct seq_file *s, char *label, u32 mask)\r\n{\r\nseq_printf(s, "%s %08x%s%s%s%s%s%s%s\n", label, mask,\r\nmask & HCINT_MIE ? " MIE" : "",\r\nmask & HCINT_RHSC ? " rhsc" : "",\r\nmask & HCINT_FNO ? " fno" : "",\r\nmask & HCINT_UE ? " ue" : "",\r\nmask & HCINT_RD ? " rd" : "",\r\nmask & HCINT_SF ? " sof" : "", mask & HCINT_SO ? " so" : "");\r\n}\r\nstatic int isp116x_show_dbg(struct seq_file *s, void *unused)\r\n{\r\nstruct isp116x *isp116x = s->private;\r\nseq_printf(s, "%s\n%s version %s\n",\r\nisp116x_to_hcd(isp116x)->product_desc, hcd_name,\r\nDRIVER_VERSION);\r\nif (HC_IS_SUSPENDED(isp116x_to_hcd(isp116x)->state)) {\r\nseq_printf(s, "HCD is suspended\n");\r\nreturn 0;\r\n}\r\nif (!HC_IS_RUNNING(isp116x_to_hcd(isp116x)->state)) {\r\nseq_printf(s, "HCD not running\n");\r\nreturn 0;\r\n}\r\nspin_lock_irq(&isp116x->lock);\r\ndump_irq(s, "hc_irq_enable", isp116x_read_reg16(isp116x, HCuPINTENB));\r\ndump_irq(s, "hc_irq_status", isp116x_read_reg16(isp116x, HCuPINT));\r\ndump_int(s, "hc_int_enable", isp116x_read_reg32(isp116x, HCINTENB));\r\ndump_int(s, "hc_int_status", isp116x_read_reg32(isp116x, HCINTSTAT));\r\nisp116x_show_regs_seq(isp116x, s);\r\nspin_unlock_irq(&isp116x->lock);\r\nseq_printf(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int isp116x_open_seq(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, isp116x_show_dbg, inode->i_private);\r\n}\r\nstatic int create_debug_file(struct isp116x *isp116x)\r\n{\r\nisp116x->dentry = debugfs_create_file(hcd_name,\r\nS_IRUGO, NULL, isp116x,\r\n&isp116x_debug_fops);\r\nif (!isp116x->dentry)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void remove_debug_file(struct isp116x *isp116x)\r\n{\r\ndebugfs_remove(isp116x->dentry);\r\n}\r\nstatic int isp116x_sw_reset(struct isp116x *isp116x)\r\n{\r\nint retries = 15;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg16(isp116x, HCSWRES, HCSWRES_MAGIC);\r\nisp116x_write_reg32(isp116x, HCCMDSTAT, HCCMDSTAT_HCR);\r\nwhile (--retries) {\r\nmdelay(1);\r\nif (!(isp116x_read_reg32(isp116x, HCCMDSTAT) & HCCMDSTAT_HCR))\r\nbreak;\r\n}\r\nif (!retries) {\r\nERR("Software reset timeout\n");\r\nret = -ETIME;\r\n}\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int isp116x_reset(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nunsigned long t;\r\nu16 clkrdy = 0;\r\nint ret, timeout = 15 ;\r\nret = isp116x_sw_reset(isp116x);\r\nif (ret)\r\nreturn ret;\r\nt = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before_eq(jiffies, t)) {\r\nmsleep(4);\r\nspin_lock_irq(&isp116x->lock);\r\nclkrdy = isp116x_read_reg16(isp116x, HCuPINT) & HCuPINT_CLKRDY;\r\nspin_unlock_irq(&isp116x->lock);\r\nif (clkrdy)\r\nbreak;\r\n}\r\nif (!clkrdy) {\r\nERR("Clock not ready after %dms\n", timeout);\r\nERR("Please make sure that the H_WAKEUP pin is pulled low!\n");\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic void isp116x_stop(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg16(isp116x, HCuPINTENB, 0);\r\nval = isp116x_read_reg32(isp116x, HCRHDESCA);\r\nval &= ~(RH_A_NPS | RH_A_PSM);\r\nisp116x_write_reg32(isp116x, HCRHDESCA, val);\r\nisp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_LPS);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nisp116x_sw_reset(isp116x);\r\n}\r\nstatic int isp116x_start(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nstruct isp116x_platform_data *board = isp116x->board;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg16(isp116x, HCuPINT, 0xff);\r\nisp116x_write_reg16(isp116x, HCuPINTENB, 0);\r\nval = isp116x_read_reg16(isp116x, HCCHIPID);\r\nif ((val & HCCHIPID_MASK) != HCCHIPID_MAGIC) {\r\nERR("Invalid chip ID %04x\n", val);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn -ENODEV;\r\n}\r\nhcd->uses_new_polling = 1;\r\nisp116x_write_reg16(isp116x, HCITLBUFLEN, ISP116x_ITL_BUFSIZE);\r\nisp116x_write_reg16(isp116x, HCATLBUFLEN, ISP116x_ATL_BUFSIZE);\r\nval = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);\r\nif (board->sel15Kres)\r\nval |= HCHWCFG_15KRSEL;\r\nif (board->remote_wakeup_enable)\r\nval |= HCHWCFG_CLKNOTSTOP;\r\nif (board->oc_enable)\r\nval |= HCHWCFG_ANALOG_OC;\r\nif (board->int_act_high)\r\nval |= HCHWCFG_INT_POL;\r\nif (board->int_edge_triggered)\r\nval |= HCHWCFG_INT_TRIGGER;\r\nisp116x_write_reg16(isp116x, HCHWCFG, val);\r\nval = (25 << 24) & RH_A_POTPGT;\r\nval |= RH_A_PSM;\r\nval |= RH_A_OCPM;\r\nisp116x_write_reg32(isp116x, HCRHDESCA, val);\r\nisp116x->rhdesca = isp116x_read_reg32(isp116x, HCRHDESCA);\r\nval = RH_B_PPCM;\r\nisp116x_write_reg32(isp116x, HCRHDESCB, val);\r\nisp116x->rhdescb = isp116x_read_reg32(isp116x, HCRHDESCB);\r\nval = 0;\r\nif (board->remote_wakeup_enable) {\r\nif (!device_can_wakeup(hcd->self.controller))\r\ndevice_init_wakeup(hcd->self.controller, 1);\r\nval |= RH_HS_DRWE;\r\n}\r\nisp116x_write_reg32(isp116x, HCRHSTATUS, val);\r\nisp116x->rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);\r\nisp116x_write_reg32(isp116x, HCFMINTVL, 0x27782edf);\r\nhcd->state = HC_STATE_RUNNING;\r\nisp116x->intenb = HCINT_MIE | HCINT_RHSC | HCINT_UE;\r\nif (board->remote_wakeup_enable)\r\nisp116x->intenb |= HCINT_RD;\r\nisp116x->irqenb = HCuPINT_ATL | HCuPINT_OPR;\r\nisp116x_write_reg32(isp116x, HCINTENB, isp116x->intenb);\r\nisp116x_write_reg16(isp116x, HCuPINTENB, isp116x->irqenb);\r\nval = HCCONTROL_USB_OPER;\r\nif (board->remote_wakeup_enable)\r\nval |= HCCONTROL_RWE;\r\nisp116x_write_reg32(isp116x, HCCONTROL, val);\r\nisp116x_write_reg32(isp116x, HCRHPORT1, RH_PS_CCS);\r\nisp116x_write_reg32(isp116x, HCRHPORT2, RH_PS_CCS);\r\nisp116x_show_regs_log(isp116x);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int isp116x_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nunsigned long flags;\r\nu32 val;\r\nint ret = 0;\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nval = isp116x_read_reg32(isp116x, HCCONTROL);\r\nswitch (val & HCCONTROL_HCFS) {\r\ncase HCCONTROL_USB_OPER:\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nval &= (~HCCONTROL_HCFS & ~HCCONTROL_RWE);\r\nval |= HCCONTROL_USB_SUSPEND;\r\nif (hcd->self.root_hub->do_remote_wakeup)\r\nval |= HCCONTROL_RWE;\r\nmsleep(2);\r\nspin_lock_irqsave(&isp116x->lock, flags);\r\nisp116x_write_reg32(isp116x, HCCONTROL, val);\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nmsleep(5);\r\nbreak;\r\ncase HCCONTROL_USB_RESUME:\r\nisp116x_write_reg32(isp116x, HCCONTROL,\r\n(val & ~HCCONTROL_HCFS) |\r\nHCCONTROL_USB_RESET);\r\ncase HCCONTROL_USB_RESET:\r\nret = -EBUSY;\r\ndefault:\r\nspin_unlock_irqrestore(&isp116x->lock, flags);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int isp116x_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct isp116x *isp116x = hcd_to_isp116x(hcd);\r\nu32 val;\r\nmsleep(5);\r\nspin_lock_irq(&isp116x->lock);\r\nval = isp116x_read_reg32(isp116x, HCCONTROL);\r\nswitch (val & HCCONTROL_HCFS) {\r\ncase HCCONTROL_USB_SUSPEND:\r\nval &= ~HCCONTROL_HCFS;\r\nval |= HCCONTROL_USB_RESUME;\r\nisp116x_write_reg32(isp116x, HCCONTROL, val);\r\ncase HCCONTROL_USB_RESUME:\r\nbreak;\r\ncase HCCONTROL_USB_OPER:\r\nspin_unlock_irq(&isp116x->lock);\r\nreturn 0;\r\ndefault:\r\nspin_unlock_irq(&isp116x->lock);\r\nDBG("Chip has been reset while suspended. Reinit from scratch.\n");\r\nisp116x_reset(hcd);\r\nisp116x_start(hcd);\r\nisp116x_hub_control(hcd, SetPortFeature,\r\nUSB_PORT_FEAT_POWER, 1, NULL, 0);\r\nif ((isp116x->rhdesca & RH_A_NDP) == 2)\r\nisp116x_hub_control(hcd, SetPortFeature,\r\nUSB_PORT_FEAT_POWER, 2, NULL, 0);\r\nreturn 0;\r\n}\r\nval = isp116x->rhdesca & RH_A_NDP;\r\nwhile (val--) {\r\nu32 stat =\r\nisp116x_read_reg32(isp116x, val ? HCRHPORT2 : HCRHPORT1);\r\nif (!(stat & RH_PS_PSS))\r\ncontinue;\r\nDBG("%s: Resuming port %d\n", __func__, val);\r\nisp116x_write_reg32(isp116x, RH_PS_POCI, val\r\n? HCRHPORT2 : HCRHPORT1);\r\n}\r\nspin_unlock_irq(&isp116x->lock);\r\nhcd->state = HC_STATE_RESUMING;\r\nmsleep(20);\r\nspin_lock_irq(&isp116x->lock);\r\nval = isp116x_read_reg32(isp116x, HCCONTROL);\r\nisp116x_write_reg32(isp116x, HCCONTROL,\r\n(val & ~HCCONTROL_HCFS) | HCCONTROL_USB_OPER);\r\nspin_unlock_irq(&isp116x->lock);\r\nhcd->state = HC_STATE_RUNNING;\r\nreturn 0;\r\n}\r\nstatic int isp116x_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct isp116x *isp116x;\r\nstruct resource *res;\r\nif (!hcd)\r\nreturn 0;\r\nisp116x = hcd_to_isp116x(hcd);\r\nremove_debug_file(isp116x);\r\nusb_remove_hcd(hcd);\r\niounmap(isp116x->data_reg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrelease_mem_region(res->start, 2);\r\niounmap(isp116x->addr_reg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, 2);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int isp116x_probe(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct isp116x *isp116x;\r\nstruct resource *addr, *data, *ires;\r\nvoid __iomem *addr_reg;\r\nvoid __iomem *data_reg;\r\nint irq;\r\nint ret = 0;\r\nunsigned long irqflags;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (pdev->num_resources < 3) {\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\ndata = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!addr || !data || !ires) {\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\nirq = ires->start;\r\nirqflags = ires->flags & IRQF_TRIGGER_MASK;\r\nif (pdev->dev.dma_mask) {\r\nDBG("DMA not supported\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nif (!request_mem_region(addr->start, 2, hcd_name)) {\r\nret = -EBUSY;\r\ngoto err1;\r\n}\r\naddr_reg = ioremap(addr->start, resource_size(addr));\r\nif (addr_reg == NULL) {\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nif (!request_mem_region(data->start, 2, hcd_name)) {\r\nret = -EBUSY;\r\ngoto err3;\r\n}\r\ndata_reg = ioremap(data->start, resource_size(data));\r\nif (data_reg == NULL) {\r\nret = -ENOMEM;\r\ngoto err4;\r\n}\r\nhcd = usb_create_hcd(&isp116x_hc_driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nret = -ENOMEM;\r\ngoto err5;\r\n}\r\nhcd->rsrc_start = addr->start;\r\nisp116x = hcd_to_isp116x(hcd);\r\nisp116x->data_reg = data_reg;\r\nisp116x->addr_reg = addr_reg;\r\nspin_lock_init(&isp116x->lock);\r\nINIT_LIST_HEAD(&isp116x->async);\r\nisp116x->board = pdev->dev.platform_data;\r\nif (!isp116x->board) {\r\nERR("Platform data structure not initialized\n");\r\nret = -ENODEV;\r\ngoto err6;\r\n}\r\nif (isp116x_check_platform_delay(isp116x)) {\r\nERR("USE_PLATFORM_DELAY defined, but delay function not "\r\n"implemented.\n");\r\nERR("See comments in drivers/usb/host/isp116x-hcd.c\n");\r\nret = -ENODEV;\r\ngoto err6;\r\n}\r\nret = usb_add_hcd(hcd, irq, irqflags);\r\nif (ret)\r\ngoto err6;\r\nret = create_debug_file(isp116x);\r\nif (ret) {\r\nERR("Couldn't create debugfs entry\n");\r\ngoto err7;\r\n}\r\nreturn 0;\r\nerr7:\r\nusb_remove_hcd(hcd);\r\nerr6:\r\nusb_put_hcd(hcd);\r\nerr5:\r\niounmap(data_reg);\r\nerr4:\r\nrelease_mem_region(data->start, 2);\r\nerr3:\r\niounmap(addr_reg);\r\nerr2:\r\nrelease_mem_region(addr->start, 2);\r\nerr1:\r\nERR("init error, %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int isp116x_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nVDBG("%s: state %x\n", __func__, state.event);\r\nreturn 0;\r\n}\r\nstatic int isp116x_resume(struct platform_device *dev)\r\n{\r\nVDBG("%s\n", __func__);\r\nreturn 0;\r\n}
