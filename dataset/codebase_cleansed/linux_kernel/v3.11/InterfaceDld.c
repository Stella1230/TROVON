int InterfaceFileDownload(PVOID arg, struct file *flp, unsigned int on_chip_loc)\r\n{\r\nmm_segment_t oldfs = {0};\r\nint errno = 0, len = 0;\r\nloff_t pos = 0;\r\nstruct bcm_interface_adapter *psIntfAdapter = (struct bcm_interface_adapter *)arg;\r\nchar *buff = kmalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nwhile (1) {\r\noldfs = get_fs();\r\nset_fs(get_ds());\r\nlen = vfs_read(flp, (void __force __user *)buff,\r\nMAX_TRANSFER_CTRL_BYTE_USB, &pos);\r\nset_fs(oldfs);\r\nif (len <= 0) {\r\nif (len < 0) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, MP_INIT,\r\nDBG_LVL_ALL, "len < 0");\r\nerrno = len;\r\n} else {\r\nerrno = 0;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, MP_INIT,\r\nDBG_LVL_ALL,\r\n"Got end of file!");\r\n}\r\nbreak;\r\n}\r\nerrno = InterfaceWRM(psIntfAdapter, on_chip_loc, buff, len);\r\nif (errno) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_PRINTK, 0, 0,\r\n"WRM Failed! status: %d", errno);\r\nbreak;\r\n}\r\non_chip_loc += MAX_TRANSFER_CTRL_BYTE_USB;\r\n}\r\nkfree(buff);\r\nreturn errno;\r\n}\r\nint InterfaceFileReadbackFromChip(PVOID arg, struct file *flp, unsigned int on_chip_loc)\r\n{\r\nchar *buff, *buff_readback;\r\nunsigned int reg = 0;\r\nmm_segment_t oldfs = {0};\r\nint errno = 0, len = 0, is_config_file = 0;\r\nloff_t pos = 0;\r\nstatic int fw_down;\r\nINT Status = STATUS_SUCCESS;\r\nstruct bcm_interface_adapter *psIntfAdapter = (struct bcm_interface_adapter *)arg;\r\nint bytes;\r\nbuff = kmalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_DMA);\r\nbuff_readback = kmalloc(MAX_TRANSFER_CTRL_BYTE_USB , GFP_DMA);\r\nif (!buff || !buff_readback) {\r\nkfree(buff);\r\nkfree(buff_readback);\r\nreturn -ENOMEM;\r\n}\r\nis_config_file = (on_chip_loc == CONFIG_BEGIN_ADDR) ? 1 : 0;\r\nmemset(buff_readback, 0, MAX_TRANSFER_CTRL_BYTE_USB);\r\nmemset(buff, 0, MAX_TRANSFER_CTRL_BYTE_USB);\r\nwhile (1) {\r\noldfs = get_fs();\r\nset_fs(get_ds());\r\nlen = vfs_read(flp, (void __force __user *)buff, MAX_TRANSFER_CTRL_BYTE_USB, &pos);\r\nset_fs(oldfs);\r\nfw_down++;\r\nif (len <= 0) {\r\nif (len < 0) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "len < 0");\r\nerrno = len;\r\n} else {\r\nerrno = 0;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Got end of file!");\r\n}\r\nbreak;\r\n}\r\nbytes = InterfaceRDM(psIntfAdapter, on_chip_loc, buff_readback, len);\r\nif (bytes < 0) {\r\nStatus = bytes;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "RDM of len %d Failed! %d", len, reg);\r\ngoto exit;\r\n}\r\nreg++;\r\nif ((len-sizeof(unsigned int)) < 4) {\r\nif (memcmp(buff_readback, buff, len)) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Length is: %d", len);\r\nStatus = -EIO;\r\ngoto exit;\r\n}\r\n} else {\r\nlen -= 4;\r\nwhile (len) {\r\nif (*(unsigned int *)&buff_readback[len] != *(unsigned int *)&buff[len]) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Firmware Download is not proper %d", fw_down);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Val from Binary %x, Val From Read Back %x ", *(unsigned int *)&buff[len], *(unsigned int*)&buff_readback[len]);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "len =%x!!!", len);\r\nStatus = -EIO;\r\ngoto exit;\r\n}\r\nlen -= 4;\r\n}\r\n}\r\non_chip_loc += MAX_TRANSFER_CTRL_BYTE_USB;\r\n}\r\nexit:\r\nkfree(buff);\r\nkfree(buff_readback);\r\nreturn Status;\r\n}\r\nstatic int bcm_download_config_file(struct bcm_mini_adapter *Adapter, struct bcm_firmware_info *psFwInfo)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nB_UINT32 value = 0;\r\nif (Adapter->pstargetparams == NULL) {\r\nAdapter->pstargetparams = kmalloc(sizeof(struct bcm_target_params), GFP_KERNEL);\r\nif (Adapter->pstargetparams == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (psFwInfo->u32FirmwareLength != sizeof(struct bcm_target_params))\r\nreturn -EIO;\r\nretval = copy_from_user(Adapter->pstargetparams, psFwInfo->pvMappedFirmwareAddress, psFwInfo->u32FirmwareLength);\r\nif (retval) {\r\nkfree(Adapter->pstargetparams);\r\nAdapter->pstargetparams = NULL;\r\nreturn -EFAULT;\r\n}\r\nbeceem_parse_target_struct(Adapter);\r\nBcmInitNVM(Adapter);\r\nretval = InitLedSettings(Adapter);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "INIT LED Failed\n");\r\nreturn retval;\r\n}\r\nif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\r\nAdapter->LEDInfo.bLedInitDone = FALSE;\r\nAdapter->DriverState = DRIVER_INIT;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\r\nAdapter->DriverState = FW_DOWNLOAD;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\n}\r\nretval = ddr_init(Adapter);\r\nif (retval) {\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "DDR Init Failed\n");\r\nreturn retval;\r\n}\r\nvalue = 0;\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 4, &value, sizeof(value));\r\nwrmalt(Adapter, EEPROM_CAL_DATA_INTERNAL_LOC - 8, &value, sizeof(value));\r\nif (Adapter->eNVMType == NVM_FLASH) {\r\nretval = PropagateCalParamsFromFlashToMemory(Adapter);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "propagaion of cal param failed with status :%d", retval);\r\nreturn retval;\r\n}\r\n}\r\nretval = buffDnldVerify(Adapter, (PUCHAR)Adapter->pstargetparams, sizeof(struct bcm_target_params), CONFIG_BEGIN_ADDR);\r\nif (retval)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "configuration file not downloaded properly");\r\nelse\r\nAdapter->bCfgDownloaded = TRUE;\r\nreturn retval;\r\n}\r\nint bcm_ioctl_fw_download(struct bcm_mini_adapter *Adapter, struct bcm_firmware_info *psFwInfo)\r\n{\r\nint retval = STATUS_SUCCESS;\r\nPUCHAR buff = NULL;\r\natomic_set(&Adapter->uiMBupdate, FALSE);\r\nif (!Adapter->bCfgDownloaded && psFwInfo->u32StartingAddress != CONFIG_BEGIN_ADDR) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Download the config File first\n");\r\nreturn -EINVAL;\r\n}\r\nif (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR) {\r\nretval = bcm_download_config_file(Adapter, psFwInfo);\r\n} else {\r\nbuff = kzalloc(psFwInfo->u32FirmwareLength, GFP_KERNEL);\r\nif (buff == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Failed in allocation memory");\r\nreturn -ENOMEM;\r\n}\r\nretval = copy_from_user(buff, psFwInfo->pvMappedFirmwareAddress, psFwInfo->u32FirmwareLength);\r\nif (retval != STATUS_SUCCESS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "copying buffer from user space failed");\r\nretval = -EFAULT;\r\ngoto error;\r\n}\r\nretval = buffDnldVerify(Adapter,\r\nbuff,\r\npsFwInfo->u32FirmwareLength,\r\npsFwInfo->u32StartingAddress);\r\nif (retval != STATUS_SUCCESS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "f/w download failed status :%d", retval);\r\ngoto error;\r\n}\r\n}\r\nerror:\r\nkfree(buff);\r\nreturn retval;\r\n}\r\nstatic INT buffDnld(struct bcm_mini_adapter *Adapter, PUCHAR mappedbuffer, UINT u32FirmwareLength, ULONG u32StartingAddress)\r\n{\r\nunsigned int len = 0;\r\nint retval = STATUS_SUCCESS;\r\nlen = u32FirmwareLength;\r\nwhile (u32FirmwareLength) {\r\nlen = MIN_VAL(u32FirmwareLength, MAX_TRANSFER_CTRL_BYTE_USB);\r\nretval = wrm(Adapter, u32StartingAddress, mappedbuffer, len);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "wrm failed with status :%d", retval);\r\nbreak;\r\n}\r\nu32StartingAddress += len;\r\nu32FirmwareLength -= len;\r\nmappedbuffer += len;\r\n}\r\nreturn retval;\r\n}\r\nstatic INT buffRdbkVerify(struct bcm_mini_adapter *Adapter, PUCHAR mappedbuffer, UINT u32FirmwareLength, ULONG u32StartingAddress)\r\n{\r\nUINT len = u32FirmwareLength;\r\nINT retval = STATUS_SUCCESS;\r\nPUCHAR readbackbuff = kzalloc(MAX_TRANSFER_CTRL_BYTE_USB, GFP_KERNEL);\r\nint bytes;\r\nif (NULL == readbackbuff) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "MEMORY ALLOCATION FAILED");\r\nreturn -ENOMEM;\r\n}\r\nwhile (u32FirmwareLength && !retval) {\r\nlen = MIN_VAL(u32FirmwareLength, MAX_TRANSFER_CTRL_BYTE_USB);\r\nbytes = rdm(Adapter, u32StartingAddress, readbackbuff, len);\r\nif (bytes < 0) {\r\nretval = bytes;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "rdm failed with status %d", retval);\r\nbreak;\r\n}\r\nif (memcmp(readbackbuff, mappedbuffer, len) != 0) {\r\npr_err("%s() failed. The firmware doesn't match what was written",\r\n__func__);\r\nretval = -EIO;\r\n}\r\nu32StartingAddress += len;\r\nu32FirmwareLength -= len;\r\nmappedbuffer += len;\r\n}\r\nkfree(readbackbuff);\r\nreturn retval;\r\n}\r\nINT buffDnldVerify(struct bcm_mini_adapter *Adapter, unsigned char *mappedbuffer, unsigned int u32FirmwareLength, unsigned long u32StartingAddress)\r\n{\r\nINT status = STATUS_SUCCESS;\r\nstatus = buffDnld(Adapter, mappedbuffer, u32FirmwareLength, u32StartingAddress);\r\nif (status != STATUS_SUCCESS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Buffer download failed");\r\ngoto error;\r\n}\r\nstatus = buffRdbkVerify(Adapter, mappedbuffer, u32FirmwareLength, u32StartingAddress);\r\nif (status != STATUS_SUCCESS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL, "Buffer readback verifier failed");\r\ngoto error;\r\n}\r\nerror:\r\nreturn status;\r\n}
