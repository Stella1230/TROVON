static int set_system(const struct dmi_system_id *id)\r\n{\r\nstruct efifb_dmi_info *info = id->driver_data;\r\nif (info->base == 0 && info->height == 0 && info->width == 0\r\n&& info->stride == 0)\r\nreturn 0;\r\nif (screen_info.lfb_base == 0) {\r\n#if defined(CONFIG_PCI)\r\nstruct pci_dev *dev = NULL;\r\nint found_bar = 0;\r\n#endif\r\nif (info->base) {\r\nscreen_info.lfb_base = choose_value(info->base,\r\nscreen_info.lfb_base, OVERRIDE_BASE,\r\ninfo->flags);\r\n#if defined(CONFIG_PCI)\r\nfor_each_pci_dev(dev) {\r\nint i;\r\nif ((dev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\r\ncontinue;\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nresource_size_t start, end;\r\nstart = pci_resource_start(dev, i);\r\nif (start == 0)\r\nbreak;\r\nend = pci_resource_end(dev, i);\r\nif (screen_info.lfb_base >= start &&\r\nscreen_info.lfb_base < end) {\r\nfound_bar = 1;\r\n}\r\n}\r\n}\r\nif (!found_bar)\r\nscreen_info.lfb_base = 0;\r\n#endif\r\n}\r\n}\r\nif (screen_info.lfb_base) {\r\nscreen_info.lfb_linelength = choose_value(info->stride,\r\nscreen_info.lfb_linelength, OVERRIDE_STRIDE,\r\ninfo->flags);\r\nscreen_info.lfb_width = choose_value(info->width,\r\nscreen_info.lfb_width, OVERRIDE_WIDTH,\r\ninfo->flags);\r\nscreen_info.lfb_height = choose_value(info->height,\r\nscreen_info.lfb_height, OVERRIDE_HEIGHT,\r\ninfo->flags);\r\nif (screen_info.orig_video_isVGA == 0)\r\nscreen_info.orig_video_isVGA = VIDEO_TYPE_EFI;\r\n} else {\r\nscreen_info.lfb_linelength = 0;\r\nscreen_info.lfb_width = 0;\r\nscreen_info.lfb_height = 0;\r\nscreen_info.orig_video_isVGA = 0;\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "efifb: dmi detected %s - framebuffer at 0x%08x "\r\n"(%dx%d, stride %d)\n", id->ident,\r\nscreen_info.lfb_base, screen_info.lfb_width,\r\nscreen_info.lfb_height, screen_info.lfb_linelength);\r\nreturn 1;\r\n}\r\nstatic int efifb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nif (regno < 16) {\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\n((u32 *)(info->pseudo_palette))[regno] =\r\n(red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\n}\r\nreturn 0;\r\n}\r\nstatic void efifb_destroy(struct fb_info *info)\r\n{\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nif (request_mem_succeeded)\r\nrelease_mem_region(info->apertures->ranges[0].base,\r\ninfo->apertures->ranges[0].size);\r\nframebuffer_release(info);\r\n}\r\nstruct pci_dev *vga_default_device(void)\r\n{\r\nreturn default_vga;\r\n}\r\nvoid vga_set_default_device(struct pci_dev *pdev)\r\n{\r\ndefault_vga = pdev;\r\n}\r\nstatic int __init efifb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nint i;\r\nstruct pci_dev *dev = NULL;\r\nif (options && *options) {\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt) continue;\r\nfor (i = 0; i < M_UNKNOWN; i++) {\r\nif (!strcmp(this_opt, dmi_list[i].optname) &&\r\ndmi_list[i].base != 0) {\r\nscreen_info.lfb_base = dmi_list[i].base;\r\nscreen_info.lfb_linelength = dmi_list[i].stride;\r\nscreen_info.lfb_width = dmi_list[i].width;\r\nscreen_info.lfb_height = dmi_list[i].height;\r\n}\r\n}\r\nif (!strncmp(this_opt, "base:", 5))\r\nscreen_info.lfb_base = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "stride:", 7))\r\nscreen_info.lfb_linelength = simple_strtoul(this_opt+7, NULL, 0) * 4;\r\nelse if (!strncmp(this_opt, "height:", 7))\r\nscreen_info.lfb_height = simple_strtoul(this_opt+7, NULL, 0);\r\nelse if (!strncmp(this_opt, "width:", 6))\r\nscreen_info.lfb_width = simple_strtoul(this_opt+6, NULL, 0);\r\n}\r\n}\r\nfor_each_pci_dev(dev) {\r\nint i;\r\nif ((dev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\r\ncontinue;\r\nfor (i=0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nresource_size_t start, end;\r\nif (!(pci_resource_flags(dev, i) & IORESOURCE_MEM))\r\ncontinue;\r\nstart = pci_resource_start(dev, i);\r\nend = pci_resource_end(dev, i);\r\nif (!start || !end)\r\ncontinue;\r\nif (screen_info.lfb_base >= start &&\r\n(screen_info.lfb_base + screen_info.lfb_size) < end)\r\ndefault_vga = dev;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init efifb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nint err;\r\nunsigned int size_vmode;\r\nunsigned int size_remap;\r\nunsigned int size_total;\r\nif (!screen_info.lfb_depth)\r\nscreen_info.lfb_depth = 32;\r\nif (!screen_info.pages)\r\nscreen_info.pages = 1;\r\nif (!screen_info.lfb_base) {\r\nprintk(KERN_DEBUG "efifb: invalid framebuffer address\n");\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "efifb: probing for efifb\n");\r\nif (!screen_info.blue_size) {\r\nscreen_info.blue_size = 8;\r\nscreen_info.blue_pos = 0;\r\nscreen_info.green_size = 8;\r\nscreen_info.green_pos = 8;\r\nscreen_info.red_size = 8;\r\nscreen_info.red_pos = 16;\r\nscreen_info.rsvd_size = 8;\r\nscreen_info.rsvd_pos = 24;\r\n}\r\nefifb_fix.smem_start = screen_info.lfb_base;\r\nefifb_defined.bits_per_pixel = screen_info.lfb_depth;\r\nefifb_defined.xres = screen_info.lfb_width;\r\nefifb_defined.yres = screen_info.lfb_height;\r\nefifb_fix.line_length = screen_info.lfb_linelength;\r\nsize_vmode = efifb_defined.yres * efifb_fix.line_length;\r\nsize_total = screen_info.lfb_size;\r\nif (size_total < size_vmode)\r\nsize_total = size_vmode;\r\nsize_remap = size_vmode * 2;\r\nif (size_remap > size_total)\r\nsize_remap = size_total;\r\nif (size_remap % PAGE_SIZE)\r\nsize_remap += PAGE_SIZE - (size_remap % PAGE_SIZE);\r\nefifb_fix.smem_len = size_remap;\r\nif (request_mem_region(efifb_fix.smem_start, size_remap, "efifb")) {\r\nrequest_mem_succeeded = true;\r\n} else {\r\nprintk(KERN_WARNING\r\n"efifb: cannot reserve video memory at 0x%lx\n",\r\nefifb_fix.smem_start);\r\n}\r\ninfo = framebuffer_alloc(sizeof(u32) * 16, &dev->dev);\r\nif (!info) {\r\nprintk(KERN_ERR "efifb: cannot allocate framebuffer\n");\r\nerr = -ENOMEM;\r\ngoto err_release_mem;\r\n}\r\ninfo->pseudo_palette = info->par;\r\ninfo->par = NULL;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nerr = -ENOMEM;\r\ngoto err_release_fb;\r\n}\r\ninfo->apertures->ranges[0].base = efifb_fix.smem_start;\r\ninfo->apertures->ranges[0].size = size_remap;\r\ninfo->screen_base = ioremap_wc(efifb_fix.smem_start, efifb_fix.smem_len);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "efifb: abort, cannot ioremap video memory "\r\n"0x%x @ 0x%lx\n",\r\nefifb_fix.smem_len, efifb_fix.smem_start);\r\nerr = -EIO;\r\ngoto err_release_fb;\r\n}\r\nprintk(KERN_INFO "efifb: framebuffer at 0x%lx, mapped to 0x%p, "\r\n"using %dk, total %dk\n",\r\nefifb_fix.smem_start, info->screen_base,\r\nsize_remap/1024, size_total/1024);\r\nprintk(KERN_INFO "efifb: mode is %dx%dx%d, linelength=%d, pages=%d\n",\r\nefifb_defined.xres, efifb_defined.yres,\r\nefifb_defined.bits_per_pixel, efifb_fix.line_length,\r\nscreen_info.pages);\r\nefifb_defined.xres_virtual = efifb_defined.xres;\r\nefifb_defined.yres_virtual = efifb_fix.smem_len /\r\nefifb_fix.line_length;\r\nprintk(KERN_INFO "efifb: scrolling: redraw\n");\r\nefifb_defined.yres_virtual = efifb_defined.yres;\r\nefifb_defined.pixclock = 10000000 / efifb_defined.xres *\r\n1000 / efifb_defined.yres;\r\nefifb_defined.left_margin = (efifb_defined.xres / 8) & 0xf8;\r\nefifb_defined.hsync_len = (efifb_defined.xres / 8) & 0xf8;\r\nefifb_defined.red.offset = screen_info.red_pos;\r\nefifb_defined.red.length = screen_info.red_size;\r\nefifb_defined.green.offset = screen_info.green_pos;\r\nefifb_defined.green.length = screen_info.green_size;\r\nefifb_defined.blue.offset = screen_info.blue_pos;\r\nefifb_defined.blue.length = screen_info.blue_size;\r\nefifb_defined.transp.offset = screen_info.rsvd_pos;\r\nefifb_defined.transp.length = screen_info.rsvd_size;\r\nprintk(KERN_INFO "efifb: %s: "\r\n"size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",\r\n"Truecolor",\r\nscreen_info.rsvd_size,\r\nscreen_info.red_size,\r\nscreen_info.green_size,\r\nscreen_info.blue_size,\r\nscreen_info.rsvd_pos,\r\nscreen_info.red_pos,\r\nscreen_info.green_pos,\r\nscreen_info.blue_pos);\r\nefifb_fix.ypanstep = 0;\r\nefifb_fix.ywrapstep = 0;\r\ninfo->fbops = &efifb_ops;\r\ninfo->var = efifb_defined;\r\ninfo->fix = efifb_fix;\r\ninfo->flags = FBINFO_FLAG_DEFAULT | FBINFO_MISC_FIRMWARE;\r\nif ((err = fb_alloc_cmap(&info->cmap, 256, 0)) < 0) {\r\nprintk(KERN_ERR "efifb: cannot allocate colormap\n");\r\ngoto err_unmap;\r\n}\r\nif ((err = register_framebuffer(info)) < 0) {\r\nprintk(KERN_ERR "efifb: cannot register framebuffer\n");\r\ngoto err_fb_dealoc;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nreturn 0;\r\nerr_fb_dealoc:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_unmap:\r\niounmap(info->screen_base);\r\nerr_release_fb:\r\nframebuffer_release(info);\r\nerr_release_mem:\r\nif (request_mem_succeeded)\r\nrelease_mem_region(efifb_fix.smem_start, size_total);\r\nreturn err;\r\n}\r\nstatic int __init efifb_init(void)\r\n{\r\nint ret;\r\nchar *option = NULL;\r\nif (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI ||\r\n!(screen_info.capabilities & VIDEO_CAPABILITY_SKIP_QUIRKS))\r\ndmi_check_system(dmi_system_table);\r\nif (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI)\r\nreturn -ENODEV;\r\nif (fb_get_options("efifb", &option))\r\nreturn -ENODEV;\r\nefifb_setup(option);\r\nif (!screen_info.lfb_linelength)\r\nreturn -ENODEV;\r\nret = platform_device_register(&efifb_device);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_probe(&efifb_driver, efifb_probe);\r\nif (ret) {\r\nplatform_device_unregister(&efifb_device);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}
