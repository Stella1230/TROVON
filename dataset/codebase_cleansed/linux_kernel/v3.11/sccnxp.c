static inline u8 sccnxp_raw_read(void __iomem *base, u8 reg, u8 shift)\r\n{\r\nreturn readb(base + (reg << shift));\r\n}\r\nstatic inline void sccnxp_raw_write(void __iomem *base, u8 reg, u8 shift, u8 v)\r\n{\r\nwriteb(v, base + (reg << shift));\r\n}\r\nstatic inline u8 sccnxp_read(struct uart_port *port, u8 reg)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nreturn sccnxp_raw_read(port->membase, reg & s->addr_mask,\r\nport->regshift);\r\n}\r\nstatic inline void sccnxp_write(struct uart_port *port, u8 reg, u8 v)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nsccnxp_raw_write(port->membase, reg & s->addr_mask, port->regshift, v);\r\n}\r\nstatic inline u8 sccnxp_port_read(struct uart_port *port, u8 reg)\r\n{\r\nreturn sccnxp_read(port, (port->line << 3) + reg);\r\n}\r\nstatic inline void sccnxp_port_write(struct uart_port *port, u8 reg, u8 v)\r\n{\r\nsccnxp_write(port, (port->line << 3) + reg, v);\r\n}\r\nstatic int sccnxp_update_best_err(int a, int b, int *besterr)\r\n{\r\nint err = abs(a - b);\r\nif ((*besterr < 0) || (*besterr > err)) {\r\n*besterr = err;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int sccnxp_set_baud(struct uart_port *port, int baud)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nint div_std, tmp_baud, bestbaud = baud, besterr = -1;\r\nu8 i, acr = 0, csr = 0, mr0 = 0;\r\nfor (i = 0; baud_std[i].baud && besterr; i++) {\r\nif (baud_std[i].mr0 && !(s->flags & SCCNXP_HAVE_MR0))\r\ncontinue;\r\ndiv_std = DIV_ROUND_CLOSEST(s->freq_std, baud_std[i].baud);\r\ntmp_baud = DIV_ROUND_CLOSEST(port->uartclk, div_std);\r\nif (!sccnxp_update_best_err(baud, tmp_baud, &besterr)) {\r\nacr = baud_std[i].acr;\r\ncsr = baud_std[i].csr;\r\nmr0 = baud_std[i].mr0;\r\nbestbaud = tmp_baud;\r\n}\r\n}\r\nif (s->flags & SCCNXP_HAVE_MR0) {\r\nmr0 |= MR0_FIFO | MR0_TXLVL;\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_MRPTR0);\r\nsccnxp_port_write(port, SCCNXP_MR_REG, mr0);\r\n}\r\nsccnxp_port_write(port, SCCNXP_ACR_REG, acr | ACR_TIMER_MODE);\r\nsccnxp_port_write(port, SCCNXP_CSR_REG, (csr << 4) | csr);\r\nif (baud != bestbaud)\r\ndev_dbg(port->dev, "Baudrate desired: %i, calculated: %i\n",\r\nbaud, bestbaud);\r\nreturn bestbaud;\r\n}\r\nstatic void sccnxp_enable_irq(struct uart_port *port, int mask)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\ns->imr |= mask << (port->line * 4);\r\nsccnxp_write(port, SCCNXP_IMR_REG, s->imr);\r\n}\r\nstatic void sccnxp_disable_irq(struct uart_port *port, int mask)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\ns->imr &= ~(mask << (port->line * 4));\r\nsccnxp_write(port, SCCNXP_IMR_REG, s->imr);\r\n}\r\nstatic void sccnxp_set_bit(struct uart_port *port, int sig, int state)\r\n{\r\nu8 bitmask;\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(sig)) {\r\nbitmask = 1 << MCTRL_OBIT(s->pdata.mctrl_cfg[port->line], sig);\r\nif (state)\r\nsccnxp_write(port, SCCNXP_SOP_REG, bitmask);\r\nelse\r\nsccnxp_write(port, SCCNXP_ROP_REG, bitmask);\r\n}\r\n}\r\nstatic void sccnxp_handle_rx(struct uart_port *port)\r\n{\r\nu8 sr;\r\nunsigned int ch, flag;\r\nfor (;;) {\r\nsr = sccnxp_port_read(port, SCCNXP_SR_REG);\r\nif (!(sr & SR_RXRDY))\r\nbreak;\r\nsr &= SR_PE | SR_FE | SR_OVR | SR_BRK;\r\nch = sccnxp_port_read(port, SCCNXP_RHR_REG);\r\nport->icount.rx++;\r\nflag = TTY_NORMAL;\r\nif (unlikely(sr)) {\r\nif (sr & SR_BRK) {\r\nport->icount.brk++;\r\nsccnxp_port_write(port, SCCNXP_CR_REG,\r\nCR_CMD_BREAK_RESET);\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sr & SR_PE)\r\nport->icount.parity++;\r\nelse if (sr & SR_FE)\r\nport->icount.frame++;\r\nelse if (sr & SR_OVR) {\r\nport->icount.overrun++;\r\nsccnxp_port_write(port, SCCNXP_CR_REG,\r\nCR_CMD_STATUS_RESET);\r\n}\r\nsr &= port->read_status_mask;\r\nif (sr & SR_BRK)\r\nflag = TTY_BREAK;\r\nelse if (sr & SR_PE)\r\nflag = TTY_PARITY;\r\nelse if (sr & SR_FE)\r\nflag = TTY_FRAME;\r\nelse if (sr & SR_OVR)\r\nflag = TTY_OVERRUN;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nif (sr & port->ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(port, sr, SR_OVR, ch, flag);\r\n}\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void sccnxp_handle_tx(struct uart_port *port)\r\n{\r\nu8 sr;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nif (unlikely(port->x_char)) {\r\nsccnxp_port_write(port, SCCNXP_THR_REG, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nif (sccnxp_port_read(port, SCCNXP_SR_REG) & SR_TXEMT) {\r\nsccnxp_disable_irq(port, IMR_TXRDY);\r\nif (s->flags & SCCNXP_HAVE_IO)\r\nsccnxp_set_bit(port, DIR_OP, 0);\r\n}\r\nreturn;\r\n}\r\nwhile (!uart_circ_empty(xmit)) {\r\nsr = sccnxp_port_read(port, SCCNXP_SR_REG);\r\nif (!(sr & SR_TXRDY))\r\nbreak;\r\nsccnxp_port_write(port, SCCNXP_THR_REG, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void sccnxp_handle_events(struct sccnxp_port *s)\r\n{\r\nint i;\r\nu8 isr;\r\ndo {\r\nisr = sccnxp_read(&s->port[0], SCCNXP_ISR_REG);\r\nisr &= s->imr;\r\nif (!isr)\r\nbreak;\r\nfor (i = 0; i < s->uart.nr; i++) {\r\nif (s->opened[i] && (isr & ISR_RXRDY(i)))\r\nsccnxp_handle_rx(&s->port[i]);\r\nif (s->opened[i] && (isr & ISR_TXRDY(i)))\r\nsccnxp_handle_tx(&s->port[i]);\r\n}\r\n} while (1);\r\n}\r\nstatic void sccnxp_timer(unsigned long data)\r\n{\r\nstruct sccnxp_port *s = (struct sccnxp_port *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nsccnxp_handle_events(s);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nif (!timer_pending(&s->timer))\r\nmod_timer(&s->timer, jiffies +\r\nusecs_to_jiffies(s->pdata.poll_time_us));\r\n}\r\nstatic irqreturn_t sccnxp_ist(int irq, void *dev_id)\r\n{\r\nstruct sccnxp_port *s = (struct sccnxp_port *)dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nsccnxp_handle_events(s);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sccnxp_start_tx(struct uart_port *port)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (s->flags & SCCNXP_HAVE_IO)\r\nsccnxp_set_bit(port, DIR_OP, 1);\r\nsccnxp_enable_irq(port, IMR_TXRDY);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic void sccnxp_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void sccnxp_stop_rx(struct uart_port *port)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_DISABLE);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic unsigned int sccnxp_tx_empty(struct uart_port *port)\r\n{\r\nu8 val;\r\nunsigned long flags;\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nspin_lock_irqsave(&s->lock, flags);\r\nval = sccnxp_port_read(port, SCCNXP_SR_REG);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn (val & SR_TXEMT) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void sccnxp_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void sccnxp_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nif (!(s->flags & SCCNXP_HAVE_IO))\r\nreturn;\r\nspin_lock_irqsave(&s->lock, flags);\r\nsccnxp_set_bit(port, DTR_OP, mctrl & TIOCM_DTR);\r\nsccnxp_set_bit(port, RTS_OP, mctrl & TIOCM_RTS);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic unsigned int sccnxp_get_mctrl(struct uart_port *port)\r\n{\r\nu8 bitmask, ipr;\r\nunsigned long flags;\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned int mctrl = TIOCM_DSR | TIOCM_CTS | TIOCM_CAR;\r\nif (!(s->flags & SCCNXP_HAVE_IO))\r\nreturn mctrl;\r\nspin_lock_irqsave(&s->lock, flags);\r\nipr = ~sccnxp_read(port, SCCNXP_IPCR_REG);\r\nif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(DSR_IP)) {\r\nbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\r\nDSR_IP);\r\nmctrl &= ~TIOCM_DSR;\r\nmctrl |= (ipr & bitmask) ? TIOCM_DSR : 0;\r\n}\r\nif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(CTS_IP)) {\r\nbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\r\nCTS_IP);\r\nmctrl &= ~TIOCM_CTS;\r\nmctrl |= (ipr & bitmask) ? TIOCM_CTS : 0;\r\n}\r\nif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(DCD_IP)) {\r\nbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\r\nDCD_IP);\r\nmctrl &= ~TIOCM_CAR;\r\nmctrl |= (ipr & bitmask) ? TIOCM_CAR : 0;\r\n}\r\nif (s->pdata.mctrl_cfg[port->line] & MCTRL_MASK(RNG_IP)) {\r\nbitmask = 1 << MCTRL_IBIT(s->pdata.mctrl_cfg[port->line],\r\nRNG_IP);\r\nmctrl &= ~TIOCM_RNG;\r\nmctrl |= (ipr & bitmask) ? TIOCM_RNG : 0;\r\n}\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn mctrl;\r\n}\r\nstatic void sccnxp_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, break_state ?\r\nCR_CMD_START_BREAK : CR_CMD_STOP_BREAK);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic void sccnxp_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nu8 mr1, mr2;\r\nint baud;\r\nspin_lock_irqsave(&s->lock, flags);\r\ntermios->c_cflag &= ~CMSPAR;\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_RX_RESET |\r\nCR_RX_DISABLE | CR_TX_DISABLE);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_TX_RESET);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_STATUS_RESET);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_BREAK_RESET);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nmr1 = MR1_BITS_5;\r\nbreak;\r\ncase CS6:\r\nmr1 = MR1_BITS_6;\r\nbreak;\r\ncase CS7:\r\nmr1 = MR1_BITS_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nmr1 = MR1_BITS_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & PARODD)\r\nmr1 |= MR1_PAR_ODD;\r\n} else\r\nmr1 |= MR1_PAR_NO;\r\nmr2 = (termios->c_cflag & CSTOPB) ? MR2_STOP2 : MR2_STOP1;\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_MRPTR1);\r\nsccnxp_port_write(port, SCCNXP_MR_REG, mr1);\r\nsccnxp_port_write(port, SCCNXP_MR_REG, mr2);\r\nport->read_status_mask = SR_OVR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= SR_PE | SR_FE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= SR_BRK;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNBRK)\r\nport->ignore_status_mask |= SR_BRK;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= SR_PE | SR_OVR | SR_FE | SR_BRK;\r\nbaud = uart_get_baud_rate(port, termios, old, 50,\r\n(s->flags & SCCNXP_HAVE_MR0) ?\r\n230400 : 38400);\r\nbaud = sccnxp_set_baud(port, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_ENABLE | CR_TX_ENABLE);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic int sccnxp_startup(struct uart_port *port)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (s->flags & SCCNXP_HAVE_IO) {\r\nsccnxp_write(port, SCCNXP_OPCR_REG, 0);\r\n}\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_RX_RESET);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_TX_RESET);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_STATUS_RESET);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_CMD_BREAK_RESET);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_ENABLE | CR_TX_ENABLE);\r\nsccnxp_enable_irq(port, IMR_RXRDY);\r\ns->opened[port->line] = 1;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sccnxp_shutdown(struct uart_port *port)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\ns->opened[port->line] = 0;\r\nsccnxp_disable_irq(port, IMR_TXRDY | IMR_RXRDY);\r\nsccnxp_port_write(port, SCCNXP_CR_REG, CR_RX_DISABLE | CR_TX_DISABLE);\r\nif (s->flags & SCCNXP_HAVE_IO)\r\nsccnxp_set_bit(port, DIR_OP, 0);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic const char *sccnxp_type(struct uart_port *port)\r\n{\r\nstruct sccnxp_port *s = dev_get_drvdata(port->dev);\r\nreturn (port->type == PORT_SC26XX) ? s->name : NULL;\r\n}\r\nstatic void sccnxp_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sccnxp_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sccnxp_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_SC26XX;\r\n}\r\nstatic int sccnxp_verify_port(struct uart_port *port, struct serial_struct *s)\r\n{\r\nif ((s->type == PORT_UNKNOWN) || (s->type == PORT_SC26XX))\r\nreturn 0;\r\nif (s->irq == port->irq)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void sccnxp_console_putchar(struct uart_port *port, int c)\r\n{\r\nint tryes = 100000;\r\nwhile (tryes--) {\r\nif (sccnxp_port_read(port, SCCNXP_SR_REG) & SR_TXRDY) {\r\nsccnxp_port_write(port, SCCNXP_THR_REG, c);\r\nbreak;\r\n}\r\nbarrier();\r\n}\r\n}\r\nstatic void sccnxp_console_write(struct console *co, const char *c, unsigned n)\r\n{\r\nstruct sccnxp_port *s = (struct sccnxp_port *)co->data;\r\nstruct uart_port *port = &s->port[co->index];\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nuart_console_write(port, c, n, sccnxp_console_putchar);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic int sccnxp_console_setup(struct console *co, char *options)\r\n{\r\nstruct sccnxp_port *s = (struct sccnxp_port *)co->data;\r\nstruct uart_port *port = &s->port[(co->index > 0) ? co->index : 0];\r\nint baud = 9600, bits = 8, parity = 'n', flow = 'n';\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int sccnxp_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nint chiptype = pdev->id_entry->driver_data;\r\nstruct sccnxp_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nint i, ret, fifosize, freq_min, freq_max;\r\nstruct sccnxp_port *s;\r\nvoid __iomem *membase;\r\nif (!res) {\r\ndev_err(&pdev->dev, "Missing memory resource data\n");\r\nreturn -EADDRNOTAVAIL;\r\n}\r\ns = devm_kzalloc(&pdev->dev, sizeof(struct sccnxp_port), GFP_KERNEL);\r\nif (!s) {\r\ndev_err(&pdev->dev, "Error allocating port structure\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, s);\r\nspin_lock_init(&s->lock);\r\nswitch (chiptype) {\r\ncase SCCNXP_TYPE_SC2681:\r\ns->name = "SC2681";\r\ns->uart.nr = 2;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x0f;\r\ns->flags = SCCNXP_HAVE_IO;\r\nfifosize = 3;\r\nfreq_min = 1000000;\r\nfreq_max = 4000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC2691:\r\ns->name = "SC2691";\r\ns->uart.nr = 1;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x07;\r\ns->flags = 0;\r\nfifosize = 3;\r\nfreq_min = 1000000;\r\nfreq_max = 4000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC2692:\r\ns->name = "SC2692";\r\ns->uart.nr = 2;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x0f;\r\ns->flags = SCCNXP_HAVE_IO;\r\nfifosize = 3;\r\nfreq_min = 1000000;\r\nfreq_max = 4000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC2891:\r\ns->name = "SC2891";\r\ns->uart.nr = 1;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x0f;\r\ns->flags = SCCNXP_HAVE_IO | SCCNXP_HAVE_MR0;\r\nfifosize = 16;\r\nfreq_min = 100000;\r\nfreq_max = 8000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC2892:\r\ns->name = "SC2892";\r\ns->uart.nr = 2;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x0f;\r\ns->flags = SCCNXP_HAVE_IO | SCCNXP_HAVE_MR0;\r\nfifosize = 16;\r\nfreq_min = 100000;\r\nfreq_max = 8000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC28202:\r\ns->name = "SC28202";\r\ns->uart.nr = 2;\r\ns->freq_std = 14745600;\r\ns->addr_mask = 0x7f;\r\ns->flags = SCCNXP_HAVE_IO | SCCNXP_HAVE_MR0;\r\nfifosize = 256;\r\nfreq_min = 1000000;\r\nfreq_max = 50000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC68681:\r\ns->name = "SC68681";\r\ns->uart.nr = 2;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x0f;\r\ns->flags = SCCNXP_HAVE_IO;\r\nfifosize = 3;\r\nfreq_min = 1000000;\r\nfreq_max = 4000000;\r\nbreak;\r\ncase SCCNXP_TYPE_SC68692:\r\ns->name = "SC68692";\r\ns->uart.nr = 2;\r\ns->freq_std = 3686400;\r\ns->addr_mask = 0x0f;\r\ns->flags = SCCNXP_HAVE_IO;\r\nfifosize = 3;\r\nfreq_min = 1000000;\r\nfreq_max = 4000000;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported chip type %i\n", chiptype);\r\nret = -ENOTSUPP;\r\ngoto err_out;\r\n}\r\nif (!pdata) {\r\ndev_warn(&pdev->dev,\r\n"No platform data supplied, using defaults\n");\r\ns->pdata.frequency = s->freq_std;\r\n} else\r\nmemcpy(&s->pdata, pdata, sizeof(struct sccnxp_pdata));\r\nif (s->pdata.poll_time_us) {\r\ndev_info(&pdev->dev, "Using poll mode, resolution %u usecs\n",\r\ns->pdata.poll_time_us);\r\ns->poll = 1;\r\n}\r\nif (!s->poll) {\r\ns->irq = platform_get_irq(pdev, 0);\r\nif (s->irq < 0) {\r\ndev_err(&pdev->dev, "Missing irq resource data\n");\r\nret = -ENXIO;\r\ngoto err_out;\r\n}\r\n}\r\nif ((s->pdata.frequency < freq_min) ||\r\n(s->pdata.frequency > freq_max)) {\r\ndev_err(&pdev->dev, "Frequency out of bounds\n");\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\ns->regulator = devm_regulator_get(&pdev->dev, "VCC");\r\nif (!IS_ERR(s->regulator)) {\r\nret = regulator_enable(s->regulator);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to enable regulator: %i\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nmembase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(membase)) {\r\nret = PTR_ERR(membase);\r\ngoto err_out;\r\n}\r\ns->uart.owner = THIS_MODULE;\r\ns->uart.dev_name = "ttySC";\r\ns->uart.major = SCCNXP_MAJOR;\r\ns->uart.minor = SCCNXP_MINOR;\r\n#ifdef CONFIG_SERIAL_SCCNXP_CONSOLE\r\ns->uart.cons = &s->console;\r\ns->uart.cons->device = uart_console_device;\r\ns->uart.cons->write = sccnxp_console_write;\r\ns->uart.cons->setup = sccnxp_console_setup;\r\ns->uart.cons->flags = CON_PRINTBUFFER;\r\ns->uart.cons->index = -1;\r\ns->uart.cons->data = s;\r\nstrcpy(s->uart.cons->name, "ttySC");\r\n#endif\r\nret = uart_register_driver(&s->uart);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Registering UART driver failed\n");\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < s->uart.nr; i++) {\r\ns->port[i].line = i;\r\ns->port[i].dev = &pdev->dev;\r\ns->port[i].irq = s->irq;\r\ns->port[i].type = PORT_SC26XX;\r\ns->port[i].fifosize = fifosize;\r\ns->port[i].flags = UPF_SKIP_TEST | UPF_FIXED_TYPE;\r\ns->port[i].iotype = UPIO_MEM;\r\ns->port[i].mapbase = res->start;\r\ns->port[i].membase = membase;\r\ns->port[i].regshift = s->pdata.reg_shift;\r\ns->port[i].uartclk = s->pdata.frequency;\r\ns->port[i].ops = &sccnxp_ops;\r\nuart_add_one_port(&s->uart, &s->port[i]);\r\nif (s->flags & SCCNXP_HAVE_IO)\r\nsccnxp_set_bit(&s->port[i], DIR_OP, 0);\r\n}\r\ns->imr = 0;\r\nsccnxp_write(&s->port[0], SCCNXP_IMR_REG, 0);\r\nif (!s->poll) {\r\nret = devm_request_threaded_irq(&pdev->dev, s->irq, NULL,\r\nsccnxp_ist,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\ndev_name(&pdev->dev), s);\r\nif (!ret)\r\nreturn 0;\r\ndev_err(&pdev->dev, "Unable to reguest IRQ %i\n", s->irq);\r\n} else {\r\ninit_timer(&s->timer);\r\nsetup_timer(&s->timer, sccnxp_timer, (unsigned long)s);\r\nmod_timer(&s->timer, jiffies +\r\nusecs_to_jiffies(s->pdata.poll_time_us));\r\nreturn 0;\r\n}\r\nerr_out:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int sccnxp_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct sccnxp_port *s = platform_get_drvdata(pdev);\r\nif (!s->poll)\r\ndevm_free_irq(&pdev->dev, s->irq, s);\r\nelse\r\ndel_timer_sync(&s->timer);\r\nfor (i = 0; i < s->uart.nr; i++)\r\nuart_remove_one_port(&s->uart, &s->port[i]);\r\nuart_unregister_driver(&s->uart);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (!IS_ERR(s->regulator))\r\nreturn regulator_disable(s->regulator);\r\nreturn 0;\r\n}
