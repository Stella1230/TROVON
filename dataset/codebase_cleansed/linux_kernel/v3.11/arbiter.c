static void crisv32_arbiter_config(int arbiter, int region, int unused_slots)\r\n{\r\nint slot;\r\nint client;\r\nint interval = 0;\r\ns8 val[NBR_OF_SLOTS];\r\nfor (slot = 0; slot < NBR_OF_SLOTS; slot++)\r\nval[slot] = -1;\r\nfor (client = 0; client < arbiters[arbiter].nbr_clients; client++) {\r\nint pos;\r\nif (!arbiters[arbiter].requested_slots[region][client]) {\r\nif (!arbiters[arbiter].active_clients[region][client] ||\r\nunused_slots <= 0)\r\ncontinue;\r\nunused_slots--;\r\ninterval = NBR_OF_SLOTS;\r\n} else\r\ninterval = NBR_OF_SLOTS /\r\narbiters[arbiter].requested_slots[region][client];\r\npos = 0;\r\nwhile (pos < NBR_OF_SLOTS) {\r\nif (val[pos] >= 0)\r\npos++;\r\nelse {\r\nval[pos] = client;\r\npos += interval;\r\n}\r\n}\r\n}\r\nclient = 0;\r\nfor (slot = 0; slot < NBR_OF_SLOTS; slot++) {\r\nif (val[slot] < 0) {\r\nint first = client;\r\nwhile (!arbiters[arbiter].active_clients[region][client]) {\r\nclient = (client + 1) %\r\narbiters[arbiter].nbr_clients;\r\nif (client == first)\r\nbreak;\r\n}\r\nval[slot] = client;\r\nclient = (client + 1) % arbiters[arbiter].nbr_clients;\r\n}\r\nif (arbiter == 0) {\r\nif (region == EXT_REGION)\r\nREG_WR_INT_VECT(marb_foo, regi_marb_foo,\r\nrw_l2_slots, slot, val[slot]);\r\nelse if (region == INT_REGION)\r\nREG_WR_INT_VECT(marb_foo, regi_marb_foo,\r\nrw_intm_slots, slot, val[slot]);\r\n} else {\r\nREG_WR_INT_VECT(marb_bar, regi_marb_bar,\r\nrw_ddr2_slots, slot, val[slot]);\r\n}\r\n}\r\n}\r\nstatic void crisv32_arbiter_init(void)\r\n{\r\nstatic int initialized;\r\nif (initialized)\r\nreturn;\r\ninitialized = 1;\r\narbiters[0].active_clients[EXT_REGION][11] = 1;\r\narbiters[0].active_clients[EXT_REGION][12] = 1;\r\ncrisv32_arbiter_config(0, EXT_REGION, 0);\r\ncrisv32_arbiter_config(0, INT_REGION, 0);\r\ncrisv32_arbiter_config(1, EXT_REGION, 0);\r\nif (request_irq(MEMARB_FOO_INTR_VECT, crisv32_foo_arbiter_irq,\r\nIRQF_DISABLED, "arbiter", NULL))\r\nprintk(KERN_ERR "Couldn't allocate arbiter IRQ\n");\r\nif (request_irq(MEMARB_BAR_INTR_VECT, crisv32_bar_arbiter_irq,\r\nIRQF_DISABLED, "arbiter", NULL))\r\nprintk(KERN_ERR "Couldn't allocate arbiter IRQ\n");\r\n#ifndef CONFIG_ETRAX_KGDB\r\ncrisv32_arbiter_watch(virt_to_phys(&_stext), &_etext - &_stext,\r\nMARB_CLIENTS(arbiter_all_clients, arbiter_bar_all_clients),\r\narbiter_all_write, NULL);\r\n#endif\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_h264_rd_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_h264_wr_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_ccd_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_vin_wr_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_vin_rd_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_sclr_rd_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_vout_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_sclr_fifo_burst, 3);\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_l2cache_burst, 3);\r\n}\r\nint crisv32_arbiter_allocate_bandwidth(int client, int region,\r\nunsigned long bandwidth)\r\n{\r\nint i;\r\nint total_assigned = 0;\r\nint total_clients = 0;\r\nint req;\r\nint arbiter = 0;\r\ncrisv32_arbiter_init();\r\nif (client & 0xffff0000) {\r\narbiter = 1;\r\nclient >>= 16;\r\n}\r\nfor (i = 0; i < arbiters[arbiter].nbr_clients; i++) {\r\ntotal_assigned += arbiters[arbiter].requested_slots[region][i];\r\ntotal_clients += arbiters[arbiter].active_clients[region][i];\r\n}\r\nreq = bandwidth == 0\r\n? 0 : NBR_OF_SLOTS / (max_bandwidth[region] / bandwidth);\r\nif (total_assigned + req > NBR_OF_SLOTS)\r\nreturn -ENOMEM;\r\narbiters[arbiter].active_clients[region][client] = 1;\r\narbiters[arbiter].requested_slots[region][client] = req;\r\ncrisv32_arbiter_config(arbiter, region, NBR_OF_SLOTS - total_assigned);\r\nif (arbiter == 0)\r\ncrisv32_arbiter_allocate_bandwidth(8 << 16,\r\nEXT_REGION, bandwidth);\r\nreturn 0;\r\n}\r\nvoid crisv32_arbiter_deallocate_bandwidth(int client, int region)\r\n{\r\nint i;\r\nint total_assigned = 0;\r\nint arbiter = 0;\r\nif (client & 0xffff0000)\r\narbiter = 1;\r\narbiters[arbiter].requested_slots[region][client] = 0;\r\narbiters[arbiter].active_clients[region][client] = 0;\r\nfor (i = 0; i < arbiters[arbiter].nbr_clients; i++)\r\ntotal_assigned += arbiters[arbiter].requested_slots[region][i];\r\ncrisv32_arbiter_config(arbiter, region, NBR_OF_SLOTS - total_assigned);\r\n}\r\nint crisv32_arbiter_watch(unsigned long start, unsigned long size,\r\nunsigned long clients, unsigned long accesses,\r\nwatch_callback *cb)\r\n{\r\nint i;\r\nint arbiter;\r\nint used[2];\r\nint ret = 0;\r\ncrisv32_arbiter_init();\r\nif (start > 0x80000000) {\r\nprintk(KERN_ERR "Arbiter: %lX doesn't look like a "\r\n"physical address", start);\r\nreturn -EFAULT;\r\n}\r\nspin_lock(&arbiter_lock);\r\nif (clients & 0xffff)\r\nused[0] = 1;\r\nif (clients & 0xffff0000)\r\nused[1] = 1;\r\nfor (arbiter = 0; arbiter < ARBITERS; arbiter++) {\r\nif (!used[arbiter])\r\ncontinue;\r\nfor (i = 0; i < NUMBER_OF_BP; i++) {\r\nif (!watches[arbiter][i].used) {\r\nunsigned intr_mask;\r\nif (arbiter)\r\nintr_mask = REG_RD_INT(marb_bar,\r\nregi_marb_bar, rw_intr_mask);\r\nelse\r\nintr_mask = REG_RD_INT(marb_foo,\r\nregi_marb_foo, rw_intr_mask);\r\nwatches[arbiter][i].used = 1;\r\nwatches[arbiter][i].start = start;\r\nwatches[arbiter][i].end = start + size;\r\nwatches[arbiter][i].cb = cb;\r\nret |= (i + 1) << (arbiter + 8);\r\nif (arbiter) {\r\nREG_WR_INT(marb_bar_bp,\r\nwatches[arbiter][i].instance,\r\nrw_first_addr,\r\nwatches[arbiter][i].start);\r\nREG_WR_INT(marb_bar_bp,\r\nwatches[arbiter][i].instance,\r\nrw_last_addr,\r\nwatches[arbiter][i].end);\r\nREG_WR_INT(marb_bar_bp,\r\nwatches[arbiter][i].instance,\r\nrw_op, accesses);\r\nREG_WR_INT(marb_bar_bp,\r\nwatches[arbiter][i].instance,\r\nrw_clients,\r\nclients & 0xffff);\r\n} else {\r\nREG_WR_INT(marb_foo_bp,\r\nwatches[arbiter][i].instance,\r\nrw_first_addr,\r\nwatches[arbiter][i].start);\r\nREG_WR_INT(marb_foo_bp,\r\nwatches[arbiter][i].instance,\r\nrw_last_addr,\r\nwatches[arbiter][i].end);\r\nREG_WR_INT(marb_foo_bp,\r\nwatches[arbiter][i].instance,\r\nrw_op, accesses);\r\nREG_WR_INT(marb_foo_bp,\r\nwatches[arbiter][i].instance,\r\nrw_clients, clients >> 16);\r\n}\r\nif (i == 0)\r\nintr_mask |= 1;\r\nelse if (i == 1)\r\nintr_mask |= 2;\r\nelse if (i == 2)\r\nintr_mask |= 4;\r\nelse if (i == 3)\r\nintr_mask |= 8;\r\nif (arbiter)\r\nREG_WR_INT(marb_bar, regi_marb_bar,\r\nrw_intr_mask, intr_mask);\r\nelse\r\nREG_WR_INT(marb_foo, regi_marb_foo,\r\nrw_intr_mask, intr_mask);\r\nspin_unlock(&arbiter_lock);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock(&arbiter_lock);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn -ENOMEM;\r\n}\r\nint crisv32_arbiter_unwatch(int id)\r\n{\r\nint arbiter;\r\nint intr_mask;\r\ncrisv32_arbiter_init();\r\nspin_lock(&arbiter_lock);\r\nfor (arbiter = 0; arbiter < ARBITERS; arbiter++) {\r\nint id2;\r\nif (arbiter)\r\nintr_mask = REG_RD_INT(marb_bar, regi_marb_bar,\r\nrw_intr_mask);\r\nelse\r\nintr_mask = REG_RD_INT(marb_foo, regi_marb_foo,\r\nrw_intr_mask);\r\nid2 = (id & (0xff << (arbiter + 8))) >> (arbiter + 8);\r\nif (id2 == 0)\r\ncontinue;\r\nid2--;\r\nif ((id2 >= NUMBER_OF_BP) || (!watches[arbiter][id2].used)) {\r\nspin_unlock(&arbiter_lock);\r\nreturn -EINVAL;\r\n}\r\nmemset(&watches[arbiter][id2], 0,\r\nsizeof(struct crisv32_watch_entry));\r\nif (id2 == 0)\r\nintr_mask &= ~1;\r\nelse if (id2 == 1)\r\nintr_mask &= ~2;\r\nelse if (id2 == 2)\r\nintr_mask &= ~4;\r\nelse if (id2 == 3)\r\nintr_mask &= ~8;\r\nif (arbiter)\r\nREG_WR_INT(marb_bar, regi_marb_bar, rw_intr_mask,\r\nintr_mask);\r\nelse\r\nREG_WR_INT(marb_foo, regi_marb_foo, rw_intr_mask,\r\nintr_mask);\r\n}\r\nspin_unlock(&arbiter_lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\ncrisv32_foo_arbiter_irq(int irq, void *dev_id)\r\n{\r\nreg_marb_foo_r_masked_intr masked_intr =\r\nREG_RD(marb_foo, regi_marb_foo, r_masked_intr);\r\nreg_marb_foo_bp_r_brk_clients r_clients;\r\nreg_marb_foo_bp_r_brk_addr r_addr;\r\nreg_marb_foo_bp_r_brk_op r_op;\r\nreg_marb_foo_bp_r_brk_first_client r_first;\r\nreg_marb_foo_bp_r_brk_size r_size;\r\nreg_marb_foo_bp_rw_ack ack = {0};\r\nreg_marb_foo_rw_ack_intr ack_intr = {\r\n.bp0 = 1, .bp1 = 1, .bp2 = 1, .bp3 = 1\r\n};\r\nstruct crisv32_watch_entry *watch;\r\nunsigned arbiter = (unsigned)dev_id;\r\nmasked_intr = REG_RD(marb_foo, regi_marb_foo, r_masked_intr);\r\nif (masked_intr.bp0)\r\nwatch = &watches[arbiter][0];\r\nelse if (masked_intr.bp1)\r\nwatch = &watches[arbiter][1];\r\nelse if (masked_intr.bp2)\r\nwatch = &watches[arbiter][2];\r\nelse if (masked_intr.bp3)\r\nwatch = &watches[arbiter][3];\r\nelse\r\nreturn IRQ_NONE;\r\nr_clients = REG_RD(marb_foo_bp, watch->instance, r_brk_clients);\r\nr_addr = REG_RD(marb_foo_bp, watch->instance, r_brk_addr);\r\nr_op = REG_RD(marb_foo_bp, watch->instance, r_brk_op);\r\nr_first = REG_RD(marb_foo_bp, watch->instance, r_brk_first_client);\r\nr_size = REG_RD(marb_foo_bp, watch->instance, r_brk_size);\r\nprintk(KERN_DEBUG "Arbiter IRQ\n");\r\nprintk(KERN_DEBUG "Clients %X addr %X op %X first %X size %X\n",\r\nREG_TYPE_CONV(int, reg_marb_foo_bp_r_brk_clients, r_clients),\r\nREG_TYPE_CONV(int, reg_marb_foo_bp_r_brk_addr, r_addr),\r\nREG_TYPE_CONV(int, reg_marb_foo_bp_r_brk_op, r_op),\r\nREG_TYPE_CONV(int, reg_marb_foo_bp_r_brk_first_client, r_first),\r\nREG_TYPE_CONV(int, reg_marb_foo_bp_r_brk_size, r_size));\r\nREG_WR(marb_foo_bp, watch->instance, rw_ack, ack);\r\nREG_WR(marb_foo, regi_marb_foo, rw_ack_intr, ack_intr);\r\nprintk(KERN_DEBUG "IRQ occurred at %X\n", (unsigned)get_irq_regs());\r\nif (watch->cb)\r\nwatch->cb();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ncrisv32_bar_arbiter_irq(int irq, void *dev_id)\r\n{\r\nreg_marb_bar_r_masked_intr masked_intr =\r\nREG_RD(marb_bar, regi_marb_bar, r_masked_intr);\r\nreg_marb_bar_bp_r_brk_clients r_clients;\r\nreg_marb_bar_bp_r_brk_addr r_addr;\r\nreg_marb_bar_bp_r_brk_op r_op;\r\nreg_marb_bar_bp_r_brk_first_client r_first;\r\nreg_marb_bar_bp_r_brk_size r_size;\r\nreg_marb_bar_bp_rw_ack ack = {0};\r\nreg_marb_bar_rw_ack_intr ack_intr = {\r\n.bp0 = 1, .bp1 = 1, .bp2 = 1, .bp3 = 1\r\n};\r\nstruct crisv32_watch_entry *watch;\r\nunsigned arbiter = (unsigned)dev_id;\r\nmasked_intr = REG_RD(marb_bar, regi_marb_bar, r_masked_intr);\r\nif (masked_intr.bp0)\r\nwatch = &watches[arbiter][0];\r\nelse if (masked_intr.bp1)\r\nwatch = &watches[arbiter][1];\r\nelse if (masked_intr.bp2)\r\nwatch = &watches[arbiter][2];\r\nelse if (masked_intr.bp3)\r\nwatch = &watches[arbiter][3];\r\nelse\r\nreturn IRQ_NONE;\r\nr_clients = REG_RD(marb_bar_bp, watch->instance, r_brk_clients);\r\nr_addr = REG_RD(marb_bar_bp, watch->instance, r_brk_addr);\r\nr_op = REG_RD(marb_bar_bp, watch->instance, r_brk_op);\r\nr_first = REG_RD(marb_bar_bp, watch->instance, r_brk_first_client);\r\nr_size = REG_RD(marb_bar_bp, watch->instance, r_brk_size);\r\nprintk(KERN_DEBUG "Arbiter IRQ\n");\r\nprintk(KERN_DEBUG "Clients %X addr %X op %X first %X size %X\n",\r\nREG_TYPE_CONV(int, reg_marb_bar_bp_r_brk_clients, r_clients),\r\nREG_TYPE_CONV(int, reg_marb_bar_bp_r_brk_addr, r_addr),\r\nREG_TYPE_CONV(int, reg_marb_bar_bp_r_brk_op, r_op),\r\nREG_TYPE_CONV(int, reg_marb_bar_bp_r_brk_first_client, r_first),\r\nREG_TYPE_CONV(int, reg_marb_bar_bp_r_brk_size, r_size));\r\nREG_WR(marb_bar_bp, watch->instance, rw_ack, ack);\r\nREG_WR(marb_bar, regi_marb_bar, rw_ack_intr, ack_intr);\r\nprintk(KERN_DEBUG "IRQ occurred at %X\n", (unsigned)get_irq_regs()->erp);\r\nif (watch->cb)\r\nwatch->cb();\r\nreturn IRQ_HANDLED;\r\n}
