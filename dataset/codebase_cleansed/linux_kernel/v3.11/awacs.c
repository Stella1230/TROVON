static void snd_pmac_screamer_wait(struct snd_pmac *chip)\r\n{\r\nlong timeout = 2000;\r\nwhile (!(in_le32(&chip->awacs->codec_stat) & MASK_VALID)) {\r\nmdelay(1);\r\nif (! --timeout) {\r\nsnd_printd("snd_pmac_screamer_wait timeout\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nsnd_pmac_awacs_write(struct snd_pmac *chip, int val)\r\n{\r\nlong timeout = 5000000;\r\nif (chip->model == PMAC_SCREAMER)\r\nsnd_pmac_screamer_wait(chip);\r\nout_le32(&chip->awacs->codec_ctrl, val | (chip->subframe << 22));\r\nwhile (in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) {\r\nif (! --timeout) {\r\nsnd_printd("snd_pmac_awacs_write timeout\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nsnd_pmac_awacs_write_reg(struct snd_pmac *chip, int reg, int val)\r\n{\r\nsnd_pmac_awacs_write(chip, val | (reg << 12));\r\nchip->awacs_reg[reg] = val;\r\n}\r\nstatic void\r\nsnd_pmac_awacs_write_noreg(struct snd_pmac *chip, int reg, int val)\r\n{\r\nsnd_pmac_awacs_write(chip, val | (reg << 12));\r\n}\r\nstatic void screamer_recalibrate(struct snd_pmac *chip)\r\n{\r\nif (chip->model != PMAC_SCREAMER)\r\nreturn;\r\nsnd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);\r\nif (chip->manufacturer == 0x1)\r\nmsleep(750);\r\nsnd_pmac_awacs_write_noreg(chip, 1,\r\nchip->awacs_reg[1] | MASK_RECALIBRATE |\r\nMASK_CMUTE | MASK_AMUTE);\r\nsnd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);\r\nsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\r\n}\r\nstatic void snd_pmac_awacs_set_format(struct snd_pmac *chip)\r\n{\r\nchip->awacs_reg[1] &= ~MASK_SAMPLERATE;\r\nchip->awacs_reg[1] |= chip->rate_index << 3;\r\nsnd_pmac_awacs_write_reg(chip, 1, chip->awacs_reg[1]);\r\n}\r\nstatic int snd_pmac_awacs_info_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 15;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_get_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint lshift = (kcontrol->private_value >> 8) & 0xff;\r\nint inverted = (kcontrol->private_value >> 16) & 1;\r\nunsigned long flags;\r\nint vol[2];\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nvol[0] = (chip->awacs_reg[reg] >> lshift) & 0xf;\r\nvol[1] = chip->awacs_reg[reg] & 0xf;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (inverted) {\r\nvol[0] = 0x0f - vol[0];\r\nvol[1] = 0x0f - vol[1];\r\n}\r\nucontrol->value.integer.value[0] = vol[0];\r\nucontrol->value.integer.value[1] = vol[1];\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_put_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint lshift = (kcontrol->private_value >> 8) & 0xff;\r\nint inverted = (kcontrol->private_value >> 16) & 1;\r\nint val, oldval;\r\nunsigned long flags;\r\nunsigned int vol[2];\r\nvol[0] = ucontrol->value.integer.value[0];\r\nvol[1] = ucontrol->value.integer.value[1];\r\nif (vol[0] > 0x0f || vol[1] > 0x0f)\r\nreturn -EINVAL;\r\nif (inverted) {\r\nvol[0] = 0x0f - vol[0];\r\nvol[1] = 0x0f - vol[1];\r\n}\r\nvol[0] &= 0x0f;\r\nvol[1] &= 0x0f;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noldval = chip->awacs_reg[reg];\r\nval = oldval & ~(0xf | (0xf << lshift));\r\nval |= vol[0] << lshift;\r\nval |= vol[1];\r\nif (oldval != val)\r\nsnd_pmac_awacs_write_reg(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn oldval != reg;\r\n}\r\nstatic int snd_pmac_awacs_get_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint invert = (kcontrol->private_value >> 16) & 1;\r\nint val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = (chip->awacs_reg[reg] >> shift) & 1;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert)\r\nval = 1 - val;\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_put_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint invert = (kcontrol->private_value >> 16) & 1;\r\nint mask = 1 << shift;\r\nint val, changed;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = chip->awacs_reg[reg] & ~mask;\r\nif (ucontrol->value.integer.value[0] != invert)\r\nval |= mask;\r\nchanged = chip->awacs_reg[reg] != val;\r\nif (changed)\r\nsnd_pmac_awacs_write_reg(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn changed;\r\n}\r\nstatic void awacs_set_cuda(int reg, int val)\r\n{\r\nstruct adb_request req;\r\ncuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC, 0x8a,\r\nreg, val);\r\nwhile (! req.complete)\r\ncuda_poll();\r\n}\r\nstatic void awacs_amp_set_tone(struct awacs_amp *amp, int bass, int treble)\r\n{\r\namp->amp_tone[0] = bass;\r\namp->amp_tone[1] = treble;\r\nif (bass > 7)\r\nbass = (14 - bass) + 8;\r\nif (treble > 7)\r\ntreble = (14 - treble) + 8;\r\nawacs_set_cuda(2, (bass << 4) | treble);\r\n}\r\nstatic int awacs_amp_set_vol(struct awacs_amp *amp, int index,\r\nint lvol, int rvol, int do_check)\r\n{\r\nif (do_check && amp->amp_vol[index][0] == lvol &&\r\namp->amp_vol[index][1] == rvol)\r\nreturn 0;\r\nawacs_set_cuda(3 + index, lvol);\r\nawacs_set_cuda(5 + index, rvol);\r\namp->amp_vol[index][0] = lvol;\r\namp->amp_vol[index][1] = rvol;\r\nreturn 1;\r\n}\r\nstatic void awacs_amp_set_master(struct awacs_amp *amp, int vol)\r\n{\r\namp->amp_master = vol;\r\nif (vol <= 79)\r\nvol = 32 + (79 - vol);\r\nelse\r\nvol = 32 - (vol - 79);\r\nawacs_set_cuda(1, vol);\r\n}\r\nstatic void awacs_amp_free(struct snd_pmac *chip)\r\n{\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nif (!amp)\r\nreturn;\r\nkfree(amp);\r\nchip->mixer_data = NULL;\r\nchip->mixer_free = NULL;\r\n}\r\nstatic int snd_pmac_awacs_info_volume_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 31;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_get_volume_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nucontrol->value.integer.value[0] = 31 - (amp->amp_vol[index][0] & 31);\r\nucontrol->value.integer.value[1] = 31 - (amp->amp_vol[index][1] & 31);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_put_volume_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nint vol[2];\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nvol[0] = (31 - (ucontrol->value.integer.value[0] & 31))\r\n| (amp->amp_vol[index][0] & 32);\r\nvol[1] = (31 - (ucontrol->value.integer.value[1] & 31))\r\n| (amp->amp_vol[index][1] & 32);\r\nreturn awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);\r\n}\r\nstatic int snd_pmac_awacs_get_switch_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32)\r\n? 0 : 1;\r\nucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32)\r\n? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_put_switch_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nint vol[2];\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nvol[0] = (ucontrol->value.integer.value[0] ? 0 : 32)\r\n| (amp->amp_vol[index][0] & 31);\r\nvol[1] = (ucontrol->value.integer.value[1] ? 0 : 32)\r\n| (amp->amp_vol[index][1] & 31);\r\nreturn awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);\r\n}\r\nstatic int snd_pmac_awacs_info_tone_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 14;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_get_tone_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nucontrol->value.integer.value[0] = amp->amp_tone[index];\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_put_tone_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint index = kcontrol->private_value;\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nunsigned int val;\r\nval = ucontrol->value.integer.value[0];\r\nif (val > 14)\r\nreturn -EINVAL;\r\nif (val != amp->amp_tone[index]) {\r\namp->amp_tone[index] = val;\r\nawacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_info_master_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 99;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_get_master_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nucontrol->value.integer.value[0] = amp->amp_master;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nunsigned int val;\r\nval = ucontrol->value.integer.value[0];\r\nif (val > 99)\r\nreturn -EINVAL;\r\nif (val != amp->amp_master) {\r\namp->amp_master = val;\r\nawacs_amp_set_master(amp, amp->amp_master);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_screamer_mic_boost_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 3;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_screamer_mic_boost_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint val = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->awacs_reg[6] & MASK_MIC_BOOST)\r\nval |= 2;\r\nif (chip->awacs_reg[0] & MASK_GAINLINE)\r\nval |= 1;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint val0, val6;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval0 = chip->awacs_reg[0] & ~MASK_GAINLINE;\r\nval6 = chip->awacs_reg[6] & ~MASK_MIC_BOOST;\r\nif (ucontrol->value.integer.value[0] & 1)\r\nval0 |= MASK_GAINLINE;\r\nif (ucontrol->value.integer.value[0] & 2)\r\nval6 |= MASK_MIC_BOOST;\r\nif (val0 != chip->awacs_reg[0]) {\r\nsnd_pmac_awacs_write_reg(chip, 0, val0);\r\nchanged = 1;\r\n}\r\nif (val6 != chip->awacs_reg[6]) {\r\nsnd_pmac_awacs_write_reg(chip, 6, val6);\r\nchanged = 1;\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn changed;\r\n}\r\nstatic int build_mixers(struct snd_pmac *chip, int nums,\r\nstruct snd_kcontrol_new *mixers)\r\n{\r\nint i, err;\r\nfor (i = 0; i < nums; i++) {\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&mixers[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void awacs_restore_all_regs(struct snd_pmac *chip)\r\n{\r\nsnd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);\r\nsnd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);\r\nsnd_pmac_awacs_write_noreg(chip, 2, chip->awacs_reg[2]);\r\nsnd_pmac_awacs_write_noreg(chip, 4, chip->awacs_reg[4]);\r\nif (chip->model == PMAC_SCREAMER) {\r\nsnd_pmac_awacs_write_noreg(chip, 5, chip->awacs_reg[5]);\r\nsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\r\nsnd_pmac_awacs_write_noreg(chip, 7, chip->awacs_reg[7]);\r\n}\r\n}\r\nstatic void snd_pmac_awacs_suspend(struct snd_pmac *chip)\r\n{\r\nsnd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]\r\n| MASK_AMUTE | MASK_CMUTE));\r\n}\r\nstatic void snd_pmac_awacs_resume(struct snd_pmac *chip)\r\n{\r\nif (of_machine_is_compatible("PowerBook3,1")\r\n|| of_machine_is_compatible("PowerBook3,2")) {\r\nmsleep(100);\r\nsnd_pmac_awacs_write_reg(chip, 1,\r\nchip->awacs_reg[1] & ~MASK_PAROUT);\r\nmsleep(300);\r\n}\r\nawacs_restore_all_regs(chip);\r\nif (chip->model == PMAC_SCREAMER) {\r\nmdelay(5);\r\nsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\r\n}\r\nscreamer_recalibrate(chip);\r\n#ifdef PMAC_AMP_AVAIL\r\nif (chip->mixer_data) {\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nawacs_amp_set_vol(amp, 0,\r\namp->amp_vol[0][0], amp->amp_vol[0][1], 0);\r\nawacs_amp_set_vol(amp, 1,\r\namp->amp_vol[1][0], amp->amp_vol[1][1], 0);\r\nawacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);\r\nawacs_amp_set_master(amp, amp->amp_master);\r\n}\r\n#endif\r\n}\r\nstatic int snd_pmac_awacs_detect_headphone(struct snd_pmac *chip)\r\n{\r\nreturn (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;\r\n}\r\nstatic int toggle_amp_mute(struct awacs_amp *amp, int index, int mute)\r\n{\r\nint vol[2];\r\nvol[0] = amp->amp_vol[index][0] & 31;\r\nvol[1] = amp->amp_vol[index][1] & 31;\r\nif (mute) {\r\nvol[0] |= 32;\r\nvol[1] |= 32;\r\n}\r\nreturn awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);\r\n}\r\nstatic void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)\r\n{\r\nif (chip->auto_mute) {\r\n#ifdef PMAC_AMP_AVAIL\r\nif (chip->mixer_data) {\r\nstruct awacs_amp *amp = chip->mixer_data;\r\nint changed;\r\nif (snd_pmac_awacs_detect_headphone(chip)) {\r\nchanged = toggle_amp_mute(amp, AMP_CH_HD, 0);\r\nchanged |= toggle_amp_mute(amp, AMP_CH_SPK, 1);\r\n} else {\r\nchanged = toggle_amp_mute(amp, AMP_CH_HD, 1);\r\nchanged |= toggle_amp_mute(amp, AMP_CH_SPK, 0);\r\n}\r\nif (do_notify && ! changed)\r\nreturn;\r\n} else\r\n#endif\r\n{\r\nint reg = chip->awacs_reg[1]\r\n| (MASK_HDMUTE | MASK_SPKMUTE);\r\nif (imac1) {\r\nreg &= ~MASK_SPKMUTE;\r\nreg |= MASK_PAROUT1;\r\n} else if (imac2) {\r\nreg &= ~MASK_SPKMUTE;\r\nreg &= ~MASK_PAROUT1;\r\n}\r\nif (snd_pmac_awacs_detect_headphone(chip))\r\nreg &= ~MASK_HDMUTE;\r\nelse if (imac1)\r\nreg &= ~MASK_PAROUT1;\r\nelse if (imac2)\r\nreg |= MASK_PAROUT1;\r\nelse\r\nreg &= ~MASK_SPKMUTE;\r\nif (do_notify && reg == chip->awacs_reg[1])\r\nreturn;\r\nsnd_pmac_awacs_write_reg(chip, 1, reg);\r\n}\r\nif (do_notify) {\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_sw_ctl->id);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->speaker_sw_ctl->id);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->hp_detect_ctl->id);\r\n}\r\n}\r\n}\r\nint\r\nsnd_pmac_awacs_init(struct snd_pmac *chip)\r\n{\r\nint pm7500 = IS_PM7500;\r\nint pm5500 = IS_PM5500;\r\nint beige = IS_BEIGE;\r\nint g4agp = IS_G4AGP;\r\nint lombard = IS_LOMBARD;\r\nint imac;\r\nint err, vol;\r\nstruct snd_kcontrol *vmaster_sw, *vmaster_vol;\r\nstruct snd_kcontrol *master_vol, *speaker_vol;\r\nimac1 = IS_IMAC1;\r\nimac2 = IS_IMAC2;\r\nimac = imac1 || imac2;\r\nchip->awacs_reg[0] = MASK_MUX_CD | 0xff | MASK_GAINLINE;\r\nchip->awacs_reg[1] = MASK_CMUTE | MASK_AMUTE;\r\nif (chip->has_iic || chip->device_id == 0x5 ||\r\nchip->device_id == 0xb)\r\nchip->awacs_reg[1] |= MASK_PAROUT;\r\nvol = 0x0f;\r\nvol = vol + (vol << 6);\r\nchip->awacs_reg[2] = vol;\r\nchip->awacs_reg[4] = vol;\r\nif (chip->model == PMAC_SCREAMER) {\r\nchip->awacs_reg[5] = vol;\r\nchip->awacs_reg[6] = MASK_MIC_BOOST;\r\nchip->awacs_reg[7] = 0;\r\n}\r\nawacs_restore_all_regs(chip);\r\nchip->manufacturer = (in_le32(&chip->awacs->codec_stat) >> 8) & 0xf;\r\nscreamer_recalibrate(chip);\r\nchip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;\r\n#ifdef PMAC_AMP_AVAIL\r\nif (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {\r\nstruct awacs_amp *amp = kzalloc(sizeof(*amp), GFP_KERNEL);\r\nif (! amp)\r\nreturn -ENOMEM;\r\nchip->mixer_data = amp;\r\nchip->mixer_free = awacs_amp_free;\r\nawacs_amp_set_vol(amp, 0, 63, 63, 0);\r\nawacs_amp_set_vol(amp, 1, 63, 63, 0);\r\nawacs_amp_set_tone(amp, 7, 7);\r\nawacs_amp_set_master(amp, 79);\r\n}\r\n#endif\r\nif (chip->hp_stat_mask == 0) {\r\nswitch (chip->model) {\r\ncase PMAC_AWACS:\r\nchip->hp_stat_mask = pm7500 || pm5500 ? MASK_HDPCONN\r\n: MASK_LOCONN;\r\nbreak;\r\ncase PMAC_SCREAMER:\r\nswitch (chip->device_id) {\r\ncase 0x08:\r\ncase 0x0B:\r\nchip->hp_stat_mask = imac\r\n? MASK_LOCONN_IMAC |\r\nMASK_HDPLCONN_IMAC |\r\nMASK_HDPRCONN_IMAC\r\n: MASK_HDPCONN;\r\nbreak;\r\ncase 0x00:\r\ncase 0x05:\r\nchip->hp_stat_mask = MASK_LOCONN;\r\nbreak;\r\ndefault:\r\nchip->hp_stat_mask = MASK_HDPCONN;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\n}\r\nstrcpy(chip->card->mixername, "PowerMac AWACS");\r\nerr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers),\r\nsnd_pmac_awacs_mixers);\r\nif (err < 0)\r\nreturn err;\r\nif (beige || g4agp)\r\n;\r\nelse if (chip->model == PMAC_SCREAMER || pm5500)\r\nerr = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mixers2),\r\nsnd_pmac_screamer_mixers2);\r\nelse if (!pm7500)\r\nerr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers2),\r\nsnd_pmac_awacs_mixers2);\r\nif (err < 0)\r\nreturn err;\r\nif (pm5500) {\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_awacs_mixers2_pmac5500),\r\nsnd_pmac_awacs_mixers2_pmac5500);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (pm7500)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_awacs_mixers_pmac7500),\r\nsnd_pmac_awacs_mixers_pmac7500);\r\nelse if (pm5500)\r\nerr = snd_ctl_add(chip->card,\r\n(master_vol = snd_ctl_new1(snd_pmac_awacs_mixers_pmac5500,\r\nchip)));\r\nelse if (beige)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_screamer_mixers_beige),\r\nsnd_pmac_screamer_mixers_beige);\r\nelse if (imac || lombard) {\r\nerr = snd_ctl_add(chip->card,\r\n(master_vol = snd_ctl_new1(snd_pmac_screamer_mixers_lo,\r\nchip)));\r\nif (err < 0)\r\nreturn err;\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_screamer_mixers_imac),\r\nsnd_pmac_screamer_mixers_imac);\r\n} else if (g4agp)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_screamer_mixers_g4agp),\r\nsnd_pmac_screamer_mixers_g4agp);\r\nelse\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_awacs_mixers_pmac),\r\nsnd_pmac_awacs_mixers_pmac);\r\nif (err < 0)\r\nreturn err;\r\nchip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp || lombard)\r\n? &snd_pmac_awacs_master_sw_imac\r\n: pm5500\r\n? &snd_pmac_awacs_master_sw_pmac5500\r\n: &snd_pmac_awacs_master_sw, chip);\r\nerr = snd_ctl_add(chip->card, chip->master_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef PMAC_AMP_AVAIL\r\nif (chip->mixer_data) {\r\nerr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_amp_vol),\r\nsnd_pmac_awacs_amp_vol);\r\nif (err < 0)\r\nreturn err;\r\nchip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw,\r\nchip);\r\nerr = snd_ctl_add(chip->card, chip->master_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\nchip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw,\r\nchip);\r\nerr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\n} else\r\n#endif\r\n{\r\nerr = snd_ctl_add(chip->card,\r\n(speaker_vol = snd_ctl_new1(snd_pmac_awacs_speaker_vol,\r\nchip)));\r\nif (err < 0)\r\nreturn err;\r\nchip->speaker_sw_ctl = snd_ctl_new1(imac1\r\n? &snd_pmac_awacs_speaker_sw_imac1\r\n: imac2\r\n? &snd_pmac_awacs_speaker_sw_imac2\r\n: &snd_pmac_awacs_speaker_sw, chip);\r\nerr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (pm5500 || imac || lombard) {\r\nvmaster_sw = snd_ctl_make_virtual_master(\r\n"Master Playback Switch", (unsigned int *) NULL);\r\nerr = snd_ctl_add_slave_uncached(vmaster_sw,\r\nchip->master_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add_slave_uncached(vmaster_sw,\r\nchip->speaker_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card, vmaster_sw);\r\nif (err < 0)\r\nreturn err;\r\nvmaster_vol = snd_ctl_make_virtual_master(\r\n"Master Playback Volume", (unsigned int *) NULL);\r\nerr = snd_ctl_add_slave(vmaster_vol, master_vol);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add_slave(vmaster_vol, speaker_vol);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card, vmaster_vol);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (beige || g4agp)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_screamer_mic_boost_beige),\r\nsnd_pmac_screamer_mic_boost_beige);\r\nelse if (imac)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_screamer_mic_boost_imac),\r\nsnd_pmac_screamer_mic_boost_imac);\r\nelse if (chip->model == PMAC_SCREAMER)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_screamer_mic_boost),\r\nsnd_pmac_screamer_mic_boost);\r\nelse if (pm7500)\r\nerr = build_mixers(chip,\r\nARRAY_SIZE(snd_pmac_awacs_mic_boost_pmac7500),\r\nsnd_pmac_awacs_mic_boost_pmac7500);\r\nelse\r\nerr = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mic_boost),\r\nsnd_pmac_awacs_mic_boost);\r\nif (err < 0)\r\nreturn err;\r\nchip->set_format = snd_pmac_awacs_set_format;\r\n#ifdef CONFIG_PM\r\nchip->suspend = snd_pmac_awacs_suspend;\r\nchip->resume = snd_pmac_awacs_resume;\r\n#endif\r\n#ifdef PMAC_SUPPORT_AUTOMUTE\r\nerr = snd_pmac_add_automute(chip);\r\nif (err < 0)\r\nreturn err;\r\nchip->detect_headphone = snd_pmac_awacs_detect_headphone;\r\nchip->update_automute = snd_pmac_awacs_update_automute;\r\nsnd_pmac_awacs_update_automute(chip, 0);\r\n#endif\r\nif (chip->model == PMAC_SCREAMER) {\r\nsnd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);\r\nsnd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);\r\n}\r\nreturn 0;\r\n}
