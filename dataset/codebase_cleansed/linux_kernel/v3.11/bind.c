int cachefiles_daemon_bind(struct cachefiles_cache *cache, char *args)\r\n{\r\n_enter("{%u,%u,%u,%u,%u,%u},%s",\r\ncache->frun_percent,\r\ncache->fcull_percent,\r\ncache->fstop_percent,\r\ncache->brun_percent,\r\ncache->bcull_percent,\r\ncache->bstop_percent,\r\nargs);\r\nASSERT(cache->fstop_percent >= 0 &&\r\ncache->fstop_percent < cache->fcull_percent &&\r\ncache->fcull_percent < cache->frun_percent &&\r\ncache->frun_percent < 100);\r\nASSERT(cache->bstop_percent >= 0 &&\r\ncache->bstop_percent < cache->bcull_percent &&\r\ncache->bcull_percent < cache->brun_percent &&\r\ncache->brun_percent < 100);\r\nif (*args) {\r\nkerror("'bind' command doesn't take an argument");\r\nreturn -EINVAL;\r\n}\r\nif (!cache->rootdirname) {\r\nkerror("No cache directory specified");\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(CACHEFILES_READY, &cache->flags)) {\r\nkerror("Cache already bound");\r\nreturn -EBUSY;\r\n}\r\nif (!cache->tag) {\r\ncache->tag = kstrdup("CacheFiles", GFP_KERNEL);\r\nif (!cache->tag)\r\nreturn -ENOMEM;\r\n}\r\nreturn cachefiles_daemon_add_cache(cache);\r\n}\r\nstatic int cachefiles_daemon_add_cache(struct cachefiles_cache *cache)\r\n{\r\nstruct cachefiles_object *fsdef;\r\nstruct path path;\r\nstruct kstatfs stats;\r\nstruct dentry *graveyard, *cachedir, *root;\r\nconst struct cred *saved_cred;\r\nint ret;\r\n_enter("");\r\nret = cachefiles_get_security_ID(cache);\r\nif (ret < 0)\r\nreturn ret;\r\ncachefiles_begin_secure(cache, &saved_cred);\r\nret = -ENOMEM;\r\nfsdef = kmem_cache_alloc(cachefiles_object_jar, GFP_KERNEL);\r\nif (!fsdef)\r\ngoto error_root_object;\r\nASSERTCMP(fsdef->backer, ==, NULL);\r\natomic_set(&fsdef->usage, 1);\r\nfsdef->type = FSCACHE_COOKIE_TYPE_INDEX;\r\n_debug("- fsdef %p", fsdef);\r\nret = kern_path(cache->rootdirname, LOOKUP_DIRECTORY, &path);\r\nif (ret < 0)\r\ngoto error_open_root;\r\ncache->mnt = path.mnt;\r\nroot = path.dentry;\r\nret = -EOPNOTSUPP;\r\nif (!root->d_inode ||\r\n!root->d_inode->i_op ||\r\n!root->d_inode->i_op->lookup ||\r\n!root->d_inode->i_op->mkdir ||\r\n!root->d_inode->i_op->setxattr ||\r\n!root->d_inode->i_op->getxattr ||\r\n!root->d_sb->s_op->statfs ||\r\n!root->d_sb->s_op->sync_fs)\r\ngoto error_unsupported;\r\nret = -EROFS;\r\nif (root->d_sb->s_flags & MS_RDONLY)\r\ngoto error_unsupported;\r\nret = cachefiles_determine_cache_security(cache, root, &saved_cred);\r\nif (ret < 0)\r\ngoto error_unsupported;\r\nret = vfs_statfs(&path, &stats);\r\nif (ret < 0)\r\ngoto error_unsupported;\r\nret = -ERANGE;\r\nif (stats.f_bsize <= 0)\r\ngoto error_unsupported;\r\nret = -EOPNOTSUPP;\r\nif (stats.f_bsize > PAGE_SIZE)\r\ngoto error_unsupported;\r\ncache->bsize = stats.f_bsize;\r\ncache->bshift = 0;\r\nif (stats.f_bsize < PAGE_SIZE)\r\ncache->bshift = PAGE_SHIFT - ilog2(stats.f_bsize);\r\n_debug("blksize %u (shift %u)",\r\ncache->bsize, cache->bshift);\r\n_debug("size %llu, avail %llu",\r\n(unsigned long long) stats.f_blocks,\r\n(unsigned long long) stats.f_bavail);\r\ndo_div(stats.f_files, 100);\r\ncache->fstop = stats.f_files * cache->fstop_percent;\r\ncache->fcull = stats.f_files * cache->fcull_percent;\r\ncache->frun = stats.f_files * cache->frun_percent;\r\n_debug("limits {%llu,%llu,%llu} files",\r\n(unsigned long long) cache->frun,\r\n(unsigned long long) cache->fcull,\r\n(unsigned long long) cache->fstop);\r\nstats.f_blocks >>= cache->bshift;\r\ndo_div(stats.f_blocks, 100);\r\ncache->bstop = stats.f_blocks * cache->bstop_percent;\r\ncache->bcull = stats.f_blocks * cache->bcull_percent;\r\ncache->brun = stats.f_blocks * cache->brun_percent;\r\n_debug("limits {%llu,%llu,%llu} blocks",\r\n(unsigned long long) cache->brun,\r\n(unsigned long long) cache->bcull,\r\n(unsigned long long) cache->bstop);\r\ncachedir = cachefiles_get_directory(cache, root, "cache");\r\nif (IS_ERR(cachedir)) {\r\nret = PTR_ERR(cachedir);\r\ngoto error_unsupported;\r\n}\r\nfsdef->dentry = cachedir;\r\nfsdef->fscache.cookie = NULL;\r\nret = cachefiles_check_object_type(fsdef);\r\nif (ret < 0)\r\ngoto error_unsupported;\r\ngraveyard = cachefiles_get_directory(cache, root, "graveyard");\r\nif (IS_ERR(graveyard)) {\r\nret = PTR_ERR(graveyard);\r\ngoto error_unsupported;\r\n}\r\ncache->graveyard = graveyard;\r\nfscache_init_cache(&cache->cache,\r\n&cachefiles_cache_ops,\r\n"%s",\r\nfsdef->dentry->d_sb->s_id);\r\nfscache_object_init(&fsdef->fscache, NULL, &cache->cache);\r\nret = fscache_add_cache(&cache->cache, &fsdef->fscache, cache->tag);\r\nif (ret < 0)\r\ngoto error_add_cache;\r\nset_bit(CACHEFILES_READY, &cache->flags);\r\ndput(root);\r\nprintk(KERN_INFO "CacheFiles:"\r\n" File cache on %s registered\n",\r\ncache->cache.identifier);\r\ncachefiles_has_space(cache, 0, 0);\r\ncachefiles_end_secure(cache, saved_cred);\r\nreturn 0;\r\nerror_add_cache:\r\ndput(cache->graveyard);\r\ncache->graveyard = NULL;\r\nerror_unsupported:\r\nmntput(cache->mnt);\r\ncache->mnt = NULL;\r\ndput(fsdef->dentry);\r\nfsdef->dentry = NULL;\r\ndput(root);\r\nerror_open_root:\r\nkmem_cache_free(cachefiles_object_jar, fsdef);\r\nerror_root_object:\r\ncachefiles_end_secure(cache, saved_cred);\r\nkerror("Failed to register: %d", ret);\r\nreturn ret;\r\n}\r\nvoid cachefiles_daemon_unbind(struct cachefiles_cache *cache)\r\n{\r\n_enter("");\r\nif (test_bit(CACHEFILES_READY, &cache->flags)) {\r\nprintk(KERN_INFO "CacheFiles:"\r\n" File cache on %s unregistering\n",\r\ncache->cache.identifier);\r\nfscache_withdraw_cache(&cache->cache);\r\n}\r\ndput(cache->graveyard);\r\nmntput(cache->mnt);\r\nkfree(cache->rootdirname);\r\nkfree(cache->secctx);\r\nkfree(cache->tag);\r\n_leave("");\r\n}
