void dlpar_free_cc_property(struct property *prop)\r\n{\r\nkfree(prop->name);\r\nkfree(prop->value);\r\nkfree(prop);\r\n}\r\nstatic struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\r\n{\r\nstruct property *prop;\r\nchar *name;\r\nchar *value;\r\nprop = kzalloc(sizeof(*prop), GFP_KERNEL);\r\nif (!prop)\r\nreturn NULL;\r\nname = (char *)ccwa + ccwa->name_offset;\r\nprop->name = kstrdup(name, GFP_KERNEL);\r\nprop->length = ccwa->prop_length;\r\nvalue = (char *)ccwa + ccwa->prop_offset;\r\nprop->value = kmemdup(value, prop->length, GFP_KERNEL);\r\nif (!prop->value) {\r\ndlpar_free_cc_property(prop);\r\nreturn NULL;\r\n}\r\nreturn prop;\r\n}\r\nstatic struct device_node *dlpar_parse_cc_node(struct cc_workarea *ccwa)\r\n{\r\nstruct device_node *dn;\r\nchar *name;\r\ndn = kzalloc(sizeof(*dn), GFP_KERNEL);\r\nif (!dn)\r\nreturn NULL;\r\nname = (char *)ccwa + ccwa->name_offset;\r\ndn->full_name = kasprintf(GFP_KERNEL, "/%s", name);\r\nif (!dn->full_name) {\r\nkfree(dn);\r\nreturn NULL;\r\n}\r\nreturn dn;\r\n}\r\nstatic void dlpar_free_one_cc_node(struct device_node *dn)\r\n{\r\nstruct property *prop;\r\nwhile (dn->properties) {\r\nprop = dn->properties;\r\ndn->properties = prop->next;\r\ndlpar_free_cc_property(prop);\r\n}\r\nkfree(dn->full_name);\r\nkfree(dn);\r\n}\r\nvoid dlpar_free_cc_nodes(struct device_node *dn)\r\n{\r\nif (dn->child)\r\ndlpar_free_cc_nodes(dn->child);\r\nif (dn->sibling)\r\ndlpar_free_cc_nodes(dn->sibling);\r\ndlpar_free_one_cc_node(dn);\r\n}\r\nstruct device_node *dlpar_configure_connector(u32 drc_index)\r\n{\r\nstruct device_node *dn;\r\nstruct device_node *first_dn = NULL;\r\nstruct device_node *last_dn = NULL;\r\nstruct property *property;\r\nstruct property *last_property = NULL;\r\nstruct cc_workarea *ccwa;\r\nchar *data_buf;\r\nint cc_token;\r\nint rc = -1;\r\ncc_token = rtas_token("ibm,configure-connector");\r\nif (cc_token == RTAS_UNKNOWN_SERVICE)\r\nreturn NULL;\r\ndata_buf = kzalloc(RTAS_DATA_BUF_SIZE, GFP_KERNEL);\r\nif (!data_buf)\r\nreturn NULL;\r\nccwa = (struct cc_workarea *)&data_buf[0];\r\nccwa->drc_index = drc_index;\r\nccwa->zero = 0;\r\ndo {\r\nspin_lock(&rtas_data_buf_lock);\r\nmemcpy(rtas_data_buf, data_buf, RTAS_DATA_BUF_SIZE);\r\nrc = rtas_call(cc_token, 2, 1, NULL, rtas_data_buf, NULL);\r\nmemcpy(data_buf, rtas_data_buf, RTAS_DATA_BUF_SIZE);\r\nspin_unlock(&rtas_data_buf_lock);\r\nswitch (rc) {\r\ncase COMPLETE:\r\nbreak;\r\ncase NEXT_SIBLING:\r\ndn = dlpar_parse_cc_node(ccwa);\r\nif (!dn)\r\ngoto cc_error;\r\ndn->parent = last_dn->parent;\r\nlast_dn->sibling = dn;\r\nlast_dn = dn;\r\nbreak;\r\ncase NEXT_CHILD:\r\ndn = dlpar_parse_cc_node(ccwa);\r\nif (!dn)\r\ngoto cc_error;\r\nif (!first_dn)\r\nfirst_dn = dn;\r\nelse {\r\ndn->parent = last_dn;\r\nif (last_dn)\r\nlast_dn->child = dn;\r\n}\r\nlast_dn = dn;\r\nbreak;\r\ncase NEXT_PROPERTY:\r\nproperty = dlpar_parse_cc_property(ccwa);\r\nif (!property)\r\ngoto cc_error;\r\nif (!last_dn->properties)\r\nlast_dn->properties = property;\r\nelse\r\nlast_property->next = property;\r\nlast_property = property;\r\nbreak;\r\ncase PREV_PARENT:\r\nlast_dn = last_dn->parent;\r\nbreak;\r\ncase CALL_AGAIN:\r\nbreak;\r\ncase MORE_MEMORY:\r\ncase ERR_CFG_USE:\r\ndefault:\r\nprintk(KERN_ERR "Unexpected Error (%d) "\r\n"returned from configure-connector\n", rc);\r\ngoto cc_error;\r\n}\r\n} while (rc);\r\ncc_error:\r\nkfree(data_buf);\r\nif (rc) {\r\nif (first_dn)\r\ndlpar_free_cc_nodes(first_dn);\r\nreturn NULL;\r\n}\r\nreturn first_dn;\r\n}\r\nstatic struct device_node *derive_parent(const char *path)\r\n{\r\nstruct device_node *parent;\r\nchar *last_slash;\r\nlast_slash = strrchr(path, '/');\r\nif (last_slash == path) {\r\nparent = of_find_node_by_path("/");\r\n} else {\r\nchar *parent_path;\r\nint parent_path_len = last_slash - path + 1;\r\nparent_path = kmalloc(parent_path_len, GFP_KERNEL);\r\nif (!parent_path)\r\nreturn NULL;\r\nstrlcpy(parent_path, path, parent_path_len);\r\nparent = of_find_node_by_path(parent_path);\r\nkfree(parent_path);\r\n}\r\nreturn parent;\r\n}\r\nint dlpar_attach_node(struct device_node *dn)\r\n{\r\nint rc;\r\nof_node_set_flag(dn, OF_DYNAMIC);\r\nkref_init(&dn->kref);\r\ndn->parent = derive_parent(dn->full_name);\r\nif (!dn->parent)\r\nreturn -ENOMEM;\r\nrc = of_attach_node(dn);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to add device node %s\n",\r\ndn->full_name);\r\nreturn rc;\r\n}\r\nof_node_put(dn->parent);\r\nreturn 0;\r\n}\r\nint dlpar_detach_node(struct device_node *dn)\r\n{\r\nint rc;\r\nrc = of_detach_node(dn);\r\nif (rc)\r\nreturn rc;\r\nof_node_put(dn);\r\nreturn 0;\r\n}\r\nint dlpar_acquire_drc(u32 drc_index)\r\n{\r\nint dr_status, rc;\r\nrc = rtas_call(rtas_token("get-sensor-state"), 2, 2, &dr_status,\r\nDR_ENTITY_SENSE, drc_index);\r\nif (rc || dr_status != DR_ENTITY_UNUSABLE)\r\nreturn -1;\r\nrc = rtas_set_indicator(ALLOCATION_STATE, drc_index, ALLOC_USABLE);\r\nif (rc)\r\nreturn rc;\r\nrc = rtas_set_indicator(ISOLATION_STATE, drc_index, UNISOLATE);\r\nif (rc) {\r\nrtas_set_indicator(ALLOCATION_STATE, drc_index, ALLOC_UNUSABLE);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint dlpar_release_drc(u32 drc_index)\r\n{\r\nint dr_status, rc;\r\nrc = rtas_call(rtas_token("get-sensor-state"), 2, 2, &dr_status,\r\nDR_ENTITY_SENSE, drc_index);\r\nif (rc || dr_status != DR_ENTITY_PRESENT)\r\nreturn -1;\r\nrc = rtas_set_indicator(ISOLATION_STATE, drc_index, ISOLATE);\r\nif (rc)\r\nreturn rc;\r\nrc = rtas_set_indicator(ALLOCATION_STATE, drc_index, ALLOC_UNUSABLE);\r\nif (rc) {\r\nrtas_set_indicator(ISOLATION_STATE, drc_index, UNISOLATE);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlpar_online_cpu(struct device_node *dn)\r\n{\r\nint rc = 0;\r\nunsigned int cpu;\r\nint len, nthreads, i;\r\nconst u32 *intserv;\r\nintserv = of_get_property(dn, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn -EINVAL;\r\nnthreads = len / sizeof(u32);\r\ncpu_maps_update_begin();\r\nfor (i = 0; i < nthreads; i++) {\r\nfor_each_present_cpu(cpu) {\r\nif (get_hard_smp_processor_id(cpu) != intserv[i])\r\ncontinue;\r\nBUG_ON(get_cpu_current_state(cpu)\r\n!= CPU_STATE_OFFLINE);\r\ncpu_maps_update_done();\r\nrc = cpu_up(cpu);\r\nif (rc)\r\ngoto out;\r\ncpu_maps_update_begin();\r\nbreak;\r\n}\r\nif (cpu == num_possible_cpus())\r\nprintk(KERN_WARNING "Could not find cpu to online "\r\n"with physical id 0x%x\n", intserv[i]);\r\n}\r\ncpu_maps_update_done();\r\nout:\r\nreturn rc;\r\n}\r\nstatic ssize_t dlpar_cpu_probe(const char *buf, size_t count)\r\n{\r\nstruct device_node *dn;\r\nunsigned long drc_index;\r\nchar *cpu_name;\r\nint rc;\r\ncpu_hotplug_driver_lock();\r\nrc = strict_strtoul(buf, 0, &drc_index);\r\nif (rc) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndn = dlpar_configure_connector(drc_index);\r\nif (!dn) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncpu_name = kasprintf(GFP_KERNEL, "/cpus%s", dn->full_name);\r\nif (!cpu_name) {\r\ndlpar_free_cc_nodes(dn);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nkfree(dn->full_name);\r\ndn->full_name = cpu_name;\r\nrc = dlpar_acquire_drc(drc_index);\r\nif (rc) {\r\ndlpar_free_cc_nodes(dn);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = dlpar_attach_node(dn);\r\nif (rc) {\r\ndlpar_release_drc(drc_index);\r\ndlpar_free_cc_nodes(dn);\r\ngoto out;\r\n}\r\nrc = dlpar_online_cpu(dn);\r\nout:\r\ncpu_hotplug_driver_unlock();\r\nreturn rc ? rc : count;\r\n}\r\nstatic int dlpar_offline_cpu(struct device_node *dn)\r\n{\r\nint rc = 0;\r\nunsigned int cpu;\r\nint len, nthreads, i;\r\nconst u32 *intserv;\r\nintserv = of_get_property(dn, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn -EINVAL;\r\nnthreads = len / sizeof(u32);\r\ncpu_maps_update_begin();\r\nfor (i = 0; i < nthreads; i++) {\r\nfor_each_present_cpu(cpu) {\r\nif (get_hard_smp_processor_id(cpu) != intserv[i])\r\ncontinue;\r\nif (get_cpu_current_state(cpu) == CPU_STATE_OFFLINE)\r\nbreak;\r\nif (get_cpu_current_state(cpu) == CPU_STATE_ONLINE) {\r\nset_preferred_offline_state(cpu, CPU_STATE_OFFLINE);\r\ncpu_maps_update_done();\r\nrc = cpu_down(cpu);\r\nif (rc)\r\ngoto out;\r\ncpu_maps_update_begin();\r\nbreak;\r\n}\r\nset_preferred_offline_state(cpu, CPU_STATE_OFFLINE);\r\nBUG_ON(plpar_hcall_norets(H_PROD, intserv[i])\r\n!= H_SUCCESS);\r\n__cpu_die(cpu);\r\nbreak;\r\n}\r\nif (cpu == num_possible_cpus())\r\nprintk(KERN_WARNING "Could not find cpu to offline "\r\n"with physical id 0x%x\n", intserv[i]);\r\n}\r\ncpu_maps_update_done();\r\nout:\r\nreturn rc;\r\n}\r\nstatic ssize_t dlpar_cpu_release(const char *buf, size_t count)\r\n{\r\nstruct device_node *dn;\r\nconst u32 *drc_index;\r\nint rc;\r\ndn = of_find_node_by_path(buf);\r\nif (!dn)\r\nreturn -EINVAL;\r\ndrc_index = of_get_property(dn, "ibm,my-drc-index", NULL);\r\nif (!drc_index) {\r\nof_node_put(dn);\r\nreturn -EINVAL;\r\n}\r\ncpu_hotplug_driver_lock();\r\nrc = dlpar_offline_cpu(dn);\r\nif (rc) {\r\nof_node_put(dn);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = dlpar_release_drc(*drc_index);\r\nif (rc) {\r\nof_node_put(dn);\r\ngoto out;\r\n}\r\nrc = dlpar_detach_node(dn);\r\nif (rc) {\r\ndlpar_acquire_drc(*drc_index);\r\ngoto out;\r\n}\r\nof_node_put(dn);\r\nout:\r\ncpu_hotplug_driver_unlock();\r\nreturn rc ? rc : count;\r\n}\r\nstatic int __init pseries_dlpar_init(void)\r\n{\r\nppc_md.cpu_probe = dlpar_cpu_probe;\r\nppc_md.cpu_release = dlpar_cpu_release;\r\nreturn 0;\r\n}
