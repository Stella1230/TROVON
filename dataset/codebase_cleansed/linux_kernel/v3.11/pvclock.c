void pvclock_set_flags(u8 flags)\r\n{\r\nvalid_flags = flags;\r\n}\r\nunsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src)\r\n{\r\nu64 pv_tsc_khz = 1000000ULL << 32;\r\ndo_div(pv_tsc_khz, src->tsc_to_system_mul);\r\nif (src->tsc_shift < 0)\r\npv_tsc_khz <<= -src->tsc_shift;\r\nelse\r\npv_tsc_khz >>= src->tsc_shift;\r\nreturn pv_tsc_khz;\r\n}\r\nvoid pvclock_resume(void)\r\n{\r\natomic64_set(&last_value, 0);\r\n}\r\nu8 pvclock_read_flags(struct pvclock_vcpu_time_info *src)\r\n{\r\nunsigned version;\r\ncycle_t ret;\r\nu8 flags;\r\ndo {\r\nversion = __pvclock_read_cycles(src, &ret, &flags);\r\n} while ((src->version & 1) || version != src->version);\r\nreturn flags & valid_flags;\r\n}\r\ncycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src)\r\n{\r\nunsigned version;\r\ncycle_t ret;\r\nu64 last;\r\nu8 flags;\r\ndo {\r\nversion = __pvclock_read_cycles(src, &ret, &flags);\r\n} while ((src->version & 1) || version != src->version);\r\nif ((valid_flags & PVCLOCK_TSC_STABLE_BIT) &&\r\n(flags & PVCLOCK_TSC_STABLE_BIT))\r\nreturn ret;\r\nlast = atomic64_read(&last_value);\r\ndo {\r\nif (ret < last)\r\nreturn last;\r\nlast = atomic64_cmpxchg(&last_value, last, ret);\r\n} while (unlikely(last != ret));\r\nreturn ret;\r\n}\r\nvoid pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,\r\nstruct pvclock_vcpu_time_info *vcpu_time,\r\nstruct timespec *ts)\r\n{\r\nu32 version;\r\nu64 delta;\r\nstruct timespec now;\r\ndo {\r\nversion = wall_clock->version;\r\nrmb();\r\nnow.tv_sec = wall_clock->sec;\r\nnow.tv_nsec = wall_clock->nsec;\r\nrmb();\r\n} while ((wall_clock->version & 1) || (version != wall_clock->version));\r\ndelta = pvclock_clocksource_read(vcpu_time);\r\ndelta += now.tv_sec * (u64)NSEC_PER_SEC + now.tv_nsec;\r\nnow.tv_nsec = do_div(delta, NSEC_PER_SEC);\r\nnow.tv_sec = delta;\r\nset_normalized_timespec(ts, now.tv_sec, now.tv_nsec);\r\n}\r\nstatic struct pvclock_vsyscall_time_info *\r\npvclock_get_vsyscall_user_time_info(int cpu)\r\n{\r\nif (!pvclock_vdso_info) {\r\nBUG();\r\nreturn NULL;\r\n}\r\nreturn &pvclock_vdso_info[cpu];\r\n}\r\nstruct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu)\r\n{\r\nreturn &pvclock_get_vsyscall_user_time_info(cpu)->pvti;\r\n}\r\nstatic int pvclock_task_migrate(struct notifier_block *nb, unsigned long l,\r\nvoid *v)\r\n{\r\nstruct task_migration_notifier *mn = v;\r\nstruct pvclock_vsyscall_time_info *pvti;\r\npvti = pvclock_get_vsyscall_user_time_info(mn->from_cpu);\r\nif (unlikely(pvti == NULL))\r\nreturn NOTIFY_DONE;\r\npvti->migrate_count++;\r\nreturn NOTIFY_DONE;\r\n}\r\nint __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,\r\nint size)\r\n{\r\nint idx;\r\nWARN_ON (size != PVCLOCK_VSYSCALL_NR_PAGES*PAGE_SIZE);\r\npvclock_vdso_info = i;\r\nfor (idx = 0; idx <= (PVCLOCK_FIXMAP_END-PVCLOCK_FIXMAP_BEGIN); idx++) {\r\n__set_fixmap(PVCLOCK_FIXMAP_BEGIN + idx,\r\n__pa(i) + (idx*PAGE_SIZE),\r\nPAGE_KERNEL_VVAR);\r\n}\r\nregister_task_migration_notifier(&pvclock_migrate);\r\nreturn 0;\r\n}
