int vmw_getparam_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_getparam_arg *param =\r\n(struct drm_vmw_getparam_arg *)data;\r\nswitch (param->param) {\r\ncase DRM_VMW_PARAM_NUM_STREAMS:\r\nparam->value = vmw_overlay_num_overlays(dev_priv);\r\nbreak;\r\ncase DRM_VMW_PARAM_NUM_FREE_STREAMS:\r\nparam->value = vmw_overlay_num_free_overlays(dev_priv);\r\nbreak;\r\ncase DRM_VMW_PARAM_3D:\r\nparam->value = vmw_fifo_have_3d(dev_priv) ? 1 : 0;\r\nbreak;\r\ncase DRM_VMW_PARAM_HW_CAPS:\r\nparam->value = dev_priv->capabilities;\r\nbreak;\r\ncase DRM_VMW_PARAM_FIFO_CAPS:\r\nparam->value = dev_priv->fifo.capabilities;\r\nbreak;\r\ncase DRM_VMW_PARAM_MAX_FB_SIZE:\r\nparam->value = dev_priv->vram_size;\r\nbreak;\r\ncase DRM_VMW_PARAM_FIFO_HW_VERSION:\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nconst struct vmw_fifo_state *fifo = &dev_priv->fifo;\r\nparam->value =\r\nioread32(fifo_mem +\r\n((fifo->capabilities &\r\nSVGA_FIFO_CAP_3D_HWVERSION_REVISED) ?\r\nSVGA_FIFO_3D_HWVERSION_REVISED :\r\nSVGA_FIFO_3D_HWVERSION));\r\nbreak;\r\n}\r\ndefault:\r\nDRM_ERROR("Illegal vmwgfx get param request: %d\n",\r\nparam->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vmw_get_cap_3d_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_get_3d_cap_arg *arg =\r\n(struct drm_vmw_get_3d_cap_arg *) data;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nuint32_t size;\r\n__le32 __iomem *fifo_mem;\r\nvoid __user *buffer = (void __user *)((unsigned long)(arg->buffer));\r\nvoid *bounce;\r\nint ret;\r\nif (unlikely(arg->pad64 != 0)) {\r\nDRM_ERROR("Illegal GET_3D_CAP argument.\n");\r\nreturn -EINVAL;\r\n}\r\nsize = (SVGA_FIFO_3D_CAPS_LAST - SVGA_FIFO_3D_CAPS + 1) << 2;\r\nif (arg->max_size < size)\r\nsize = arg->max_size;\r\nbounce = vmalloc(size);\r\nif (unlikely(bounce == NULL)) {\r\nDRM_ERROR("Failed to allocate bounce buffer for 3D caps.\n");\r\nreturn -ENOMEM;\r\n}\r\nfifo_mem = dev_priv->mmio_virt;\r\nmemcpy_fromio(bounce, &fifo_mem[SVGA_FIFO_3D_CAPS], size);\r\nret = copy_to_user(buffer, bounce, size);\r\nif (ret)\r\nret = -EFAULT;\r\nvfree(bounce);\r\nif (unlikely(ret != 0))\r\nDRM_ERROR("Failed to report 3D caps info.\n");\r\nreturn ret;\r\n}\r\nint vmw_present_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_present_arg *arg =\r\n(struct drm_vmw_present_arg *)data;\r\nstruct vmw_surface *surface;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nstruct drm_vmw_rect __user *clips_ptr;\r\nstruct drm_vmw_rect *clips = NULL;\r\nstruct drm_framebuffer *fb;\r\nstruct vmw_framebuffer *vfb;\r\nstruct vmw_resource *res;\r\nuint32_t num_clips;\r\nint ret;\r\nnum_clips = arg->num_clips;\r\nclips_ptr = (struct drm_vmw_rect *)(unsigned long)arg->clips_ptr;\r\nif (unlikely(num_clips == 0))\r\nreturn 0;\r\nif (clips_ptr == NULL) {\r\nDRM_ERROR("Variable clips_ptr must be specified.\n");\r\nret = -EINVAL;\r\ngoto out_clips;\r\n}\r\nclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\r\nif (clips == NULL) {\r\nDRM_ERROR("Failed to allocate clip rect list.\n");\r\nret = -ENOMEM;\r\ngoto out_clips;\r\n}\r\nret = copy_from_user(clips, clips_ptr, num_clips * sizeof(*clips));\r\nif (ret) {\r\nDRM_ERROR("Failed to copy clip rects from userspace.\n");\r\nret = -EFAULT;\r\ngoto out_no_copy;\r\n}\r\ndrm_modeset_lock_all(dev);\r\nfb = drm_framebuffer_lookup(dev, arg->fb_id);\r\nif (!fb) {\r\nDRM_ERROR("Invalid framebuffer id.\n");\r\nret = -EINVAL;\r\ngoto out_no_fb;\r\n}\r\nvfb = vmw_framebuffer_to_vfb(fb);\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\ngoto out_no_ttm_lock;\r\nret = vmw_user_resource_lookup_handle(dev_priv, tfile, arg->sid,\r\nuser_surface_converter,\r\n&res);\r\nif (ret)\r\ngoto out_no_surface;\r\nsurface = vmw_res_to_srf(res);\r\nret = vmw_kms_present(dev_priv, file_priv,\r\nvfb, surface, arg->sid,\r\narg->dest_x, arg->dest_y,\r\nclips, num_clips);\r\nvmw_surface_unreference(&surface);\r\nout_no_surface:\r\nttm_read_unlock(&vmaster->lock);\r\nout_no_ttm_lock:\r\ndrm_framebuffer_unreference(fb);\r\nout_no_fb:\r\ndrm_modeset_unlock_all(dev);\r\nout_no_copy:\r\nkfree(clips);\r\nout_clips:\r\nreturn ret;\r\n}\r\nint vmw_present_readback_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_present_readback_arg *arg =\r\n(struct drm_vmw_present_readback_arg *)data;\r\nstruct drm_vmw_fence_rep __user *user_fence_rep =\r\n(struct drm_vmw_fence_rep __user *)\r\n(unsigned long)arg->fence_rep;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nstruct drm_vmw_rect __user *clips_ptr;\r\nstruct drm_vmw_rect *clips = NULL;\r\nstruct drm_framebuffer *fb;\r\nstruct vmw_framebuffer *vfb;\r\nuint32_t num_clips;\r\nint ret;\r\nnum_clips = arg->num_clips;\r\nclips_ptr = (struct drm_vmw_rect *)(unsigned long)arg->clips_ptr;\r\nif (unlikely(num_clips == 0))\r\nreturn 0;\r\nif (clips_ptr == NULL) {\r\nDRM_ERROR("Argument clips_ptr must be specified.\n");\r\nret = -EINVAL;\r\ngoto out_clips;\r\n}\r\nclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\r\nif (clips == NULL) {\r\nDRM_ERROR("Failed to allocate clip rect list.\n");\r\nret = -ENOMEM;\r\ngoto out_clips;\r\n}\r\nret = copy_from_user(clips, clips_ptr, num_clips * sizeof(*clips));\r\nif (ret) {\r\nDRM_ERROR("Failed to copy clip rects from userspace.\n");\r\nret = -EFAULT;\r\ngoto out_no_copy;\r\n}\r\ndrm_modeset_lock_all(dev);\r\nfb = drm_framebuffer_lookup(dev, arg->fb_id);\r\nif (!fb) {\r\nDRM_ERROR("Invalid framebuffer id.\n");\r\nret = -EINVAL;\r\ngoto out_no_fb;\r\n}\r\nvfb = vmw_framebuffer_to_vfb(fb);\r\nif (!vfb->dmabuf) {\r\nDRM_ERROR("Framebuffer not dmabuf backed.\n");\r\nret = -EINVAL;\r\ngoto out_no_ttm_lock;\r\n}\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\ngoto out_no_ttm_lock;\r\nret = vmw_kms_readback(dev_priv, file_priv,\r\nvfb, user_fence_rep,\r\nclips, num_clips);\r\nttm_read_unlock(&vmaster->lock);\r\nout_no_ttm_lock:\r\ndrm_framebuffer_unreference(fb);\r\nout_no_fb:\r\ndrm_modeset_unlock_all(dev);\r\nout_no_copy:\r\nkfree(clips);\r\nout_clips:\r\nreturn ret;\r\n}\r\nunsigned int vmw_fops_poll(struct file *filp, struct poll_table_struct *wait)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct vmw_private *dev_priv =\r\nvmw_priv(file_priv->minor->dev);\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\r\nreturn drm_poll(filp, wait);\r\n}\r\nssize_t vmw_fops_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct vmw_private *dev_priv =\r\nvmw_priv(file_priv->minor->dev);\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\r\nreturn drm_read(filp, buffer, count, offset);\r\n}
