static inline const struct raid6_recov_calls *raid6_choose_recov(void)\r\n{\r\nconst struct raid6_recov_calls *const *algo;\r\nconst struct raid6_recov_calls *best;\r\nfor (best = NULL, algo = raid6_recov_algos; *algo; algo++)\r\nif (!best || (*algo)->priority > best->priority)\r\nif (!(*algo)->valid || (*algo)->valid())\r\nbest = *algo;\r\nif (best) {\r\nraid6_2data_recov = best->data2;\r\nraid6_datap_recov = best->datap;\r\nprintk("raid6: using %s recovery algorithm\n", best->name);\r\n} else\r\nprintk("raid6: Yikes! No recovery algorithm found!\n");\r\nreturn best;\r\n}\r\nint __init raid6_select_algo(void)\r\n{\r\nconst int disks = (65536/PAGE_SIZE)+2;\r\nconst struct raid6_calls *gen_best;\r\nconst struct raid6_recov_calls *rec_best;\r\nchar *syndromes;\r\nvoid *dptrs[(65536/PAGE_SIZE)+2];\r\nint i;\r\nfor (i = 0; i < disks-2; i++)\r\ndptrs[i] = ((char *)raid6_gfmul) + PAGE_SIZE*i;\r\nsyndromes = (void *) __get_free_pages(GFP_KERNEL, 1);\r\nif (!syndromes) {\r\nprintk("raid6: Yikes! No memory available.\n");\r\nreturn -ENOMEM;\r\n}\r\ndptrs[disks-2] = syndromes;\r\ndptrs[disks-1] = syndromes + PAGE_SIZE;\r\ngen_best = raid6_choose_gen(&dptrs, disks);\r\nrec_best = raid6_choose_recov();\r\nfree_pages((unsigned long)syndromes, 1);\r\nreturn gen_best && rec_best ? 0 : -EINVAL;\r\n}\r\nstatic void raid6_exit(void)\r\n{\r\ndo { } while (0);\r\n}
