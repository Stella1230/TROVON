static inline void c_can_pm_runtime_enable(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_enable(priv->device);\r\n}\r\nstatic inline void c_can_pm_runtime_disable(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_disable(priv->device);\r\n}\r\nstatic inline void c_can_pm_runtime_get_sync(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_get_sync(priv->device);\r\n}\r\nstatic inline void c_can_pm_runtime_put_sync(const struct c_can_priv *priv)\r\n{\r\nif (priv->device)\r\npm_runtime_put_sync(priv->device);\r\n}\r\nstatic inline void c_can_reset_ram(const struct c_can_priv *priv, bool enable)\r\n{\r\nif (priv->raminit)\r\npriv->raminit(priv, enable);\r\n}\r\nstatic inline int get_tx_next_msg_obj(const struct c_can_priv *priv)\r\n{\r\nreturn (priv->tx_next & C_CAN_NEXT_MSG_OBJ_MASK) +\r\nC_CAN_MSG_OBJ_TX_FIRST;\r\n}\r\nstatic inline int get_tx_echo_msg_obj(const struct c_can_priv *priv)\r\n{\r\nreturn (priv->tx_echo & C_CAN_NEXT_MSG_OBJ_MASK) +\r\nC_CAN_MSG_OBJ_TX_FIRST;\r\n}\r\nstatic u32 c_can_read_reg32(struct c_can_priv *priv, enum reg index)\r\n{\r\nu32 val = priv->read_reg(priv, index);\r\nval |= ((u32) priv->read_reg(priv, index + 1)) << 16;\r\nreturn val;\r\n}\r\nstatic void c_can_enable_all_interrupts(struct c_can_priv *priv,\r\nint enable)\r\n{\r\nunsigned int cntrl_save = priv->read_reg(priv,\r\nC_CAN_CTRL_REG);\r\nif (enable)\r\ncntrl_save |= (CONTROL_SIE | CONTROL_EIE | CONTROL_IE);\r\nelse\r\ncntrl_save &= ~(CONTROL_EIE | CONTROL_IE | CONTROL_SIE);\r\npriv->write_reg(priv, C_CAN_CTRL_REG, cntrl_save);\r\n}\r\nstatic inline int c_can_msg_obj_is_busy(struct c_can_priv *priv, int iface)\r\n{\r\nint count = MIN_TIMEOUT_VALUE;\r\nwhile (count && priv->read_reg(priv,\r\nC_CAN_IFACE(COMREQ_REG, iface)) &\r\nIF_COMR_BUSY) {\r\ncount--;\r\nudelay(1);\r\n}\r\nif (!count)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void c_can_object_get(struct net_device *dev,\r\nint iface, int objno, int mask)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(COMMSK_REG, iface),\r\nIFX_WRITE_LOW_16BIT(mask));\r\npriv->write_reg(priv, C_CAN_IFACE(COMREQ_REG, iface),\r\nIFX_WRITE_LOW_16BIT(objno));\r\nif (c_can_msg_obj_is_busy(priv, iface))\r\nnetdev_err(dev, "timed out in object get\n");\r\n}\r\nstatic inline void c_can_object_put(struct net_device *dev,\r\nint iface, int objno, int mask)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(COMMSK_REG, iface),\r\n(IF_COMM_WR | IFX_WRITE_LOW_16BIT(mask)));\r\npriv->write_reg(priv, C_CAN_IFACE(COMREQ_REG, iface),\r\nIFX_WRITE_LOW_16BIT(objno));\r\nif (c_can_msg_obj_is_busy(priv, iface))\r\nnetdev_err(dev, "timed out in object put\n");\r\n}\r\nstatic void c_can_write_msg_object(struct net_device *dev,\r\nint iface, struct can_frame *frame, int objno)\r\n{\r\nint i;\r\nu16 flags = 0;\r\nunsigned int id;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nif (!(frame->can_id & CAN_RTR_FLAG))\r\nflags |= IF_ARB_TRANSMIT;\r\nif (frame->can_id & CAN_EFF_FLAG) {\r\nid = frame->can_id & CAN_EFF_MASK;\r\nflags |= IF_ARB_MSGXTD;\r\n} else\r\nid = ((frame->can_id & CAN_SFF_MASK) << 18);\r\nflags |= IF_ARB_MSGVAL;\r\npriv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface),\r\nIFX_WRITE_LOW_16BIT(id));\r\npriv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface), flags |\r\nIFX_WRITE_HIGH_16BIT(id));\r\nfor (i = 0; i < frame->can_dlc; i += 2) {\r\npriv->write_reg(priv, C_CAN_IFACE(DATA1_REG, iface) + i / 2,\r\nframe->data[i] | (frame->data[i + 1] << 8));\r\n}\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),\r\nIF_MCONT_TXIE | IF_MCONT_TXRQST | IF_MCONT_EOB |\r\nframe->can_dlc);\r\nc_can_object_put(dev, iface, objno, IF_COMM_ALL);\r\n}\r\nstatic inline void c_can_mark_rx_msg_obj(struct net_device *dev,\r\nint iface, int ctrl_mask,\r\nint obj)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),\r\nctrl_mask & ~(IF_MCONT_MSGLST | IF_MCONT_INTPND));\r\nc_can_object_put(dev, iface, obj, IF_COMM_CONTROL);\r\n}\r\nstatic inline void c_can_activate_all_lower_rx_msg_obj(struct net_device *dev,\r\nint iface,\r\nint ctrl_mask)\r\n{\r\nint i;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nfor (i = C_CAN_MSG_OBJ_RX_FIRST; i <= C_CAN_MSG_RX_LOW_LAST; i++) {\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),\r\nctrl_mask & ~(IF_MCONT_MSGLST |\r\nIF_MCONT_INTPND | IF_MCONT_NEWDAT));\r\nc_can_object_put(dev, iface, i, IF_COMM_CONTROL);\r\n}\r\n}\r\nstatic inline void c_can_activate_rx_msg_obj(struct net_device *dev,\r\nint iface, int ctrl_mask,\r\nint obj)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),\r\nctrl_mask & ~(IF_MCONT_MSGLST |\r\nIF_MCONT_INTPND | IF_MCONT_NEWDAT));\r\nc_can_object_put(dev, iface, obj, IF_COMM_CONTROL);\r\n}\r\nstatic void c_can_handle_lost_msg_obj(struct net_device *dev,\r\nint iface, int objno)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nnetdev_err(dev, "msg lost in buffer %d\n", objno);\r\nc_can_object_get(dev, iface, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface),\r\nIF_MCONT_CLR_MSGLST);\r\nc_can_object_put(dev, 0, objno, IF_COMM_CONTROL);\r\nskb = alloc_can_err_skb(dev, &frame);\r\nif (unlikely(!skb))\r\nreturn;\r\nframe->can_id |= CAN_ERR_CRTL;\r\nframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_errors++;\r\nstats->rx_over_errors++;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int c_can_read_msg_object(struct net_device *dev, int iface, int ctrl)\r\n{\r\nu16 flags, data;\r\nint i;\r\nunsigned int val;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nskb = alloc_can_skb(dev, &frame);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\nframe->can_dlc = get_can_dlc(ctrl & 0x0F);\r\nflags = priv->read_reg(priv, C_CAN_IFACE(ARB2_REG, iface));\r\nval = priv->read_reg(priv, C_CAN_IFACE(ARB1_REG, iface)) |\r\n(flags << 16);\r\nif (flags & IF_ARB_MSGXTD)\r\nframe->can_id = (val & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\nframe->can_id = (val >> 18) & CAN_SFF_MASK;\r\nif (flags & IF_ARB_TRANSMIT)\r\nframe->can_id |= CAN_RTR_FLAG;\r\nelse {\r\nfor (i = 0; i < frame->can_dlc; i += 2) {\r\ndata = priv->read_reg(priv,\r\nC_CAN_IFACE(DATA1_REG, iface) + i / 2);\r\nframe->data[i] = data;\r\nframe->data[i + 1] = data >> 8;\r\n}\r\n}\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += frame->can_dlc;\r\ncan_led_event(dev, CAN_LED_EVENT_RX);\r\nreturn 0;\r\n}\r\nstatic void c_can_setup_receive_object(struct net_device *dev, int iface,\r\nint objno, unsigned int mask,\r\nunsigned int id, unsigned int mcont)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(MASK1_REG, iface),\r\nIFX_WRITE_LOW_16BIT(mask));\r\npriv->write_reg(priv, C_CAN_IFACE(MASK2_REG, iface),\r\nIFX_WRITE_HIGH_16BIT(mask) | BIT(13));\r\npriv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface),\r\nIFX_WRITE_LOW_16BIT(id));\r\npriv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface),\r\n(IF_ARB_MSGVAL | IFX_WRITE_HIGH_16BIT(id)));\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), mcont);\r\nc_can_object_put(dev, iface, objno, IF_COMM_ALL & ~IF_COMM_TXRQST);\r\nnetdev_dbg(dev, "obj no:%d, msgval:0x%08x\n", objno,\r\nc_can_read_reg32(priv, C_CAN_MSGVAL1_REG));\r\n}\r\nstatic void c_can_inval_msg_object(struct net_device *dev, int iface, int objno)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_IFACE(ARB1_REG, iface), 0);\r\npriv->write_reg(priv, C_CAN_IFACE(ARB2_REG, iface), 0);\r\npriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), 0);\r\nc_can_object_put(dev, iface, objno, IF_COMM_ARB | IF_COMM_CONTROL);\r\nnetdev_dbg(dev, "obj no:%d, msgval:0x%08x\n", objno,\r\nc_can_read_reg32(priv, C_CAN_MSGVAL1_REG));\r\n}\r\nstatic inline int c_can_is_next_tx_obj_busy(struct c_can_priv *priv, int objno)\r\n{\r\nint val = c_can_read_reg32(priv, C_CAN_TXRQST1_REG);\r\nif (val & (1 << (objno - 1)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t c_can_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nu32 msg_obj_no;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct can_frame *frame = (struct can_frame *)skb->data;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nmsg_obj_no = get_tx_next_msg_obj(priv);\r\nc_can_write_msg_object(dev, 0, frame, msg_obj_no);\r\ncan_put_echo_skb(skb, dev, msg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);\r\npriv->tx_next++;\r\nif (c_can_is_next_tx_obj_busy(priv, get_tx_next_msg_obj(priv)) ||\r\n(priv->tx_next & C_CAN_NEXT_MSG_OBJ_MASK) == 0)\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int c_can_set_bittiming(struct net_device *dev)\r\n{\r\nunsigned int reg_btr, reg_brpe, ctrl_save;\r\nu8 brp, brpe, sjw, tseg1, tseg2;\r\nu32 ten_bit_brp;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nten_bit_brp = bt->brp - 1;\r\nbrp = ten_bit_brp & BTR_BRP_MASK;\r\nbrpe = ten_bit_brp >> 6;\r\nsjw = bt->sjw - 1;\r\ntseg1 = bt->prop_seg + bt->phase_seg1 - 1;\r\ntseg2 = bt->phase_seg2 - 1;\r\nreg_btr = brp | (sjw << BTR_SJW_SHIFT) | (tseg1 << BTR_TSEG1_SHIFT) |\r\n(tseg2 << BTR_TSEG2_SHIFT);\r\nreg_brpe = brpe & BRP_EXT_BRPE_MASK;\r\nnetdev_info(dev,\r\n"setting BTR=%04x BRPE=%04x\n", reg_btr, reg_brpe);\r\nctrl_save = priv->read_reg(priv, C_CAN_CTRL_REG);\r\npriv->write_reg(priv, C_CAN_CTRL_REG,\r\nctrl_save | CONTROL_CCE | CONTROL_INIT);\r\npriv->write_reg(priv, C_CAN_BTR_REG, reg_btr);\r\npriv->write_reg(priv, C_CAN_BRPEXT_REG, reg_brpe);\r\npriv->write_reg(priv, C_CAN_CTRL_REG, ctrl_save);\r\nreturn 0;\r\n}\r\nstatic void c_can_configure_msg_objects(struct net_device *dev)\r\n{\r\nint i;\r\nfor (i = C_CAN_MSG_OBJ_RX_FIRST; i <= C_CAN_NO_OF_OBJECTS; i++)\r\nc_can_inval_msg_object(dev, 0, i);\r\nfor (i = C_CAN_MSG_OBJ_RX_FIRST; i < C_CAN_MSG_OBJ_RX_LAST; i++)\r\nc_can_setup_receive_object(dev, 0, i, 0, 0,\r\n(IF_MCONT_RXIE | IF_MCONT_UMASK) & ~IF_MCONT_EOB);\r\nc_can_setup_receive_object(dev, 0, C_CAN_MSG_OBJ_RX_LAST, 0, 0,\r\nIF_MCONT_EOB | IF_MCONT_RXIE | IF_MCONT_UMASK);\r\n}\r\nstatic void c_can_chip_config(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->write_reg(priv, C_CAN_CTRL_REG,\r\nCONTROL_ENABLE_AR);\r\nif ((priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) &&\r\n(priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)) {\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE |\r\nCONTROL_SIE | CONTROL_IE | CONTROL_TEST);\r\npriv->write_reg(priv, C_CAN_TEST_REG,\r\nTEST_LBACK | TEST_SILENT);\r\n} else if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE |\r\nCONTROL_SIE | CONTROL_IE | CONTROL_TEST);\r\npriv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK);\r\n} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {\r\npriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_EIE |\r\nCONTROL_SIE | CONTROL_IE | CONTROL_TEST);\r\npriv->write_reg(priv, C_CAN_TEST_REG, TEST_SILENT);\r\n} else\r\npriv->write_reg(priv, C_CAN_CTRL_REG,\r\nCONTROL_EIE | CONTROL_SIE | CONTROL_IE);\r\nc_can_configure_msg_objects(dev);\r\npriv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);\r\nc_can_set_bittiming(dev);\r\n}\r\nstatic void c_can_start(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nc_can_chip_config(dev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\npriv->tx_next = priv->tx_echo = 0;\r\nc_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);\r\n}\r\nstatic void c_can_stop(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nc_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int c_can_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nc_can_start(dev);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int c_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nunsigned int reg_err_counter;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nc_can_pm_runtime_get_sync(priv);\r\nreg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);\r\nbec->rxerr = (reg_err_counter & ERR_CNT_REC_MASK) >>\r\nERR_CNT_REC_SHIFT;\r\nbec->txerr = reg_err_counter & ERR_CNT_TEC_MASK;\r\nc_can_pm_runtime_put_sync(priv);\r\nreturn 0;\r\n}\r\nstatic void c_can_do_tx(struct net_device *dev)\r\n{\r\nu32 val;\r\nu32 msg_obj_no;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nfor (; (priv->tx_next - priv->tx_echo) > 0; priv->tx_echo++) {\r\nmsg_obj_no = get_tx_echo_msg_obj(priv);\r\nval = c_can_read_reg32(priv, C_CAN_TXRQST1_REG);\r\nif (!(val & (1 << (msg_obj_no - 1)))) {\r\ncan_get_echo_skb(dev,\r\nmsg_obj_no - C_CAN_MSG_OBJ_TX_FIRST);\r\nstats->tx_bytes += priv->read_reg(priv,\r\nC_CAN_IFACE(MSGCTRL_REG, 0))\r\n& IF_MCONT_DLC_MASK;\r\nstats->tx_packets++;\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\nc_can_inval_msg_object(dev, 0, msg_obj_no);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (((priv->tx_next & C_CAN_NEXT_MSG_OBJ_MASK) != 0) ||\r\n((priv->tx_echo & C_CAN_NEXT_MSG_OBJ_MASK) == 0))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int c_can_do_rx_poll(struct net_device *dev, int quota)\r\n{\r\nu32 num_rx_pkts = 0;\r\nunsigned int msg_obj, msg_ctrl_save;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nu32 val = c_can_read_reg32(priv, C_CAN_INTPND1_REG);\r\nfor (msg_obj = C_CAN_MSG_OBJ_RX_FIRST;\r\nmsg_obj <= C_CAN_MSG_OBJ_RX_LAST && quota > 0;\r\nval = c_can_read_reg32(priv, C_CAN_INTPND1_REG),\r\nmsg_obj++) {\r\nif (val & (1 << (msg_obj - 1))) {\r\nc_can_object_get(dev, 0, msg_obj, IF_COMM_ALL &\r\n~IF_COMM_TXRQST);\r\nmsg_ctrl_save = priv->read_reg(priv,\r\nC_CAN_IFACE(MSGCTRL_REG, 0));\r\nif (msg_ctrl_save & IF_MCONT_EOB)\r\nreturn num_rx_pkts;\r\nif (msg_ctrl_save & IF_MCONT_MSGLST) {\r\nc_can_handle_lost_msg_obj(dev, 0, msg_obj);\r\nnum_rx_pkts++;\r\nquota--;\r\ncontinue;\r\n}\r\nif (!(msg_ctrl_save & IF_MCONT_NEWDAT))\r\ncontinue;\r\nc_can_read_msg_object(dev, 0, msg_ctrl_save);\r\nif (msg_obj < C_CAN_MSG_RX_LOW_LAST)\r\nc_can_mark_rx_msg_obj(dev, 0,\r\nmsg_ctrl_save, msg_obj);\r\nelse if (msg_obj > C_CAN_MSG_RX_LOW_LAST)\r\nc_can_activate_rx_msg_obj(dev, 0,\r\nmsg_ctrl_save, msg_obj);\r\nelse if (msg_obj == C_CAN_MSG_RX_LOW_LAST)\r\nc_can_activate_all_lower_rx_msg_obj(dev,\r\n0, msg_ctrl_save);\r\nnum_rx_pkts++;\r\nquota--;\r\n}\r\n}\r\nreturn num_rx_pkts;\r\n}\r\nstatic inline int c_can_has_and_handle_berr(struct c_can_priv *priv)\r\n{\r\nreturn (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\r\n(priv->current_status & LEC_UNUSED);\r\n}\r\nstatic int c_can_handle_state_change(struct net_device *dev,\r\nenum c_can_bus_error_types error_type)\r\n{\r\nunsigned int reg_err_counter;\r\nunsigned int rx_err_passive;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct can_berr_counter bec;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nc_can_get_berr_counter(dev, &bec);\r\nreg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);\r\nrx_err_passive = (reg_err_counter & ERR_CNT_RP_MASK) >>\r\nERR_CNT_RP_SHIFT;\r\nswitch (error_type) {\r\ncase C_CAN_ERROR_WARNING:\r\npriv->can.can_stats.error_warning++;\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase C_CAN_ERROR_PASSIVE:\r\npriv->can.can_stats.error_passive++;\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (rx_err_passive)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nif (bec.txerr > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase C_CAN_BUS_OFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nc_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);\r\ncan_bus_off(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nreturn 1;\r\n}\r\nstatic int c_can_handle_bus_err(struct net_device *dev,\r\nenum c_can_lec_type lec_type)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)\r\nreturn 0;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\ncf->data[2] |= CAN_ERR_PROT_UNSPEC;\r\nswitch (lec_type) {\r\ncase LEC_STUFF_ERROR:\r\nnetdev_dbg(dev, "stuff error\n");\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ncase LEC_FORM_ERROR:\r\nnetdev_dbg(dev, "form error\n");\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase LEC_ACK_ERROR:\r\nnetdev_dbg(dev, "ack error\n");\r\ncf->data[3] |= (CAN_ERR_PROT_LOC_ACK |\r\nCAN_ERR_PROT_LOC_ACK_DEL);\r\nbreak;\r\ncase LEC_BIT1_ERROR:\r\nnetdev_dbg(dev, "bit1 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nbreak;\r\ncase LEC_BIT0_ERROR:\r\nnetdev_dbg(dev, "bit0 error\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nbreak;\r\ncase LEC_CRC_ERROR:\r\nnetdev_dbg(dev, "CRC error\n");\r\ncf->data[3] |= (CAN_ERR_PROT_LOC_CRC_SEQ |\r\nCAN_ERR_PROT_LOC_CRC_DEL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npriv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nreturn 1;\r\n}\r\nstatic int c_can_poll(struct napi_struct *napi, int quota)\r\n{\r\nu16 irqstatus;\r\nint lec_type = 0;\r\nint work_done = 0;\r\nstruct net_device *dev = napi->dev;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nirqstatus = priv->irqstatus;\r\nif (!irqstatus)\r\ngoto end;\r\nif (irqstatus == STATUS_INTERRUPT) {\r\npriv->current_status = priv->read_reg(priv,\r\nC_CAN_STS_REG);\r\nif (priv->current_status & STATUS_TXOK)\r\npriv->write_reg(priv, C_CAN_STS_REG,\r\npriv->current_status & ~STATUS_TXOK);\r\nif (priv->current_status & STATUS_RXOK)\r\npriv->write_reg(priv, C_CAN_STS_REG,\r\npriv->current_status & ~STATUS_RXOK);\r\nif ((priv->current_status & STATUS_EWARN) &&\r\n(!(priv->last_status & STATUS_EWARN))) {\r\nnetdev_dbg(dev, "entered error warning state\n");\r\nwork_done += c_can_handle_state_change(dev,\r\nC_CAN_ERROR_WARNING);\r\n}\r\nif ((priv->current_status & STATUS_EPASS) &&\r\n(!(priv->last_status & STATUS_EPASS))) {\r\nnetdev_dbg(dev, "entered error passive state\n");\r\nwork_done += c_can_handle_state_change(dev,\r\nC_CAN_ERROR_PASSIVE);\r\n}\r\nif ((priv->current_status & STATUS_BOFF) &&\r\n(!(priv->last_status & STATUS_BOFF))) {\r\nnetdev_dbg(dev, "entered bus off state\n");\r\nwork_done += c_can_handle_state_change(dev,\r\nC_CAN_BUS_OFF);\r\n}\r\nif ((!(priv->current_status & STATUS_BOFF)) &&\r\n(priv->last_status & STATUS_BOFF)) {\r\nnetdev_dbg(dev, "left bus off state\n");\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif ((!(priv->current_status & STATUS_EPASS)) &&\r\n(priv->last_status & STATUS_EPASS)) {\r\nnetdev_dbg(dev, "left error passive state\n");\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\npriv->last_status = priv->current_status;\r\nlec_type = c_can_has_and_handle_berr(priv);\r\nif (lec_type)\r\nwork_done += c_can_handle_bus_err(dev, lec_type);\r\n} else if ((irqstatus >= C_CAN_MSG_OBJ_RX_FIRST) &&\r\n(irqstatus <= C_CAN_MSG_OBJ_RX_LAST)) {\r\nwork_done += c_can_do_rx_poll(dev, (quota - work_done));\r\n} else if ((irqstatus >= C_CAN_MSG_OBJ_TX_FIRST) &&\r\n(irqstatus <= C_CAN_MSG_OBJ_TX_LAST)) {\r\nc_can_do_tx(dev);\r\n}\r\nend:\r\nif (work_done < quota) {\r\nnapi_complete(napi);\r\nc_can_enable_all_interrupts(priv, ENABLE_ALL_INTERRUPTS);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t c_can_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\npriv->irqstatus = priv->read_reg(priv, C_CAN_INT_REG);\r\nif (!priv->irqstatus)\r\nreturn IRQ_NONE;\r\nc_can_enable_all_interrupts(priv, DISABLE_ALL_INTERRUPTS);\r\nnapi_schedule(&priv->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int c_can_open(struct net_device *dev)\r\n{\r\nint err;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nc_can_pm_runtime_get_sync(priv);\r\nc_can_reset_ram(priv, true);\r\nerr = open_candev(dev);\r\nif (err) {\r\nnetdev_err(dev, "failed to open can device\n");\r\ngoto exit_open_fail;\r\n}\r\nerr = request_irq(dev->irq, &c_can_isr, IRQF_SHARED, dev->name,\r\ndev);\r\nif (err < 0) {\r\nnetdev_err(dev, "failed to request interrupt\n");\r\ngoto exit_irq_fail;\r\n}\r\nnapi_enable(&priv->napi);\r\ncan_led_event(dev, CAN_LED_EVENT_OPEN);\r\nc_can_start(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_irq_fail:\r\nclose_candev(dev);\r\nexit_open_fail:\r\nc_can_reset_ram(priv, false);\r\nc_can_pm_runtime_put_sync(priv);\r\nreturn err;\r\n}\r\nstatic int c_can_close(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nc_can_stop(dev);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\nc_can_reset_ram(priv, false);\r\nc_can_pm_runtime_put_sync(priv);\r\ncan_led_event(dev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstruct net_device *alloc_c_can_dev(void)\r\n{\r\nstruct net_device *dev;\r\nstruct c_can_priv *priv;\r\ndev = alloc_candev(sizeof(struct c_can_priv), C_CAN_MSG_OBJ_TX_NUM);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\nnetif_napi_add(dev, &priv->napi, c_can_poll, C_CAN_NAPI_WEIGHT);\r\npriv->dev = dev;\r\npriv->can.bittiming_const = &c_can_bittiming_const;\r\npriv->can.do_set_mode = c_can_set_mode;\r\npriv->can.do_get_berr_counter = c_can_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\nreturn dev;\r\n}\r\nint c_can_power_down(struct net_device *dev)\r\n{\r\nu32 val;\r\nunsigned long time_out;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nif (!(dev->flags & IFF_UP))\r\nreturn 0;\r\nWARN_ON(priv->type != BOSCH_D_CAN);\r\nval = priv->read_reg(priv, C_CAN_CTRL_EX_REG);\r\nval |= CONTROL_EX_PDR;\r\npriv->write_reg(priv, C_CAN_CTRL_EX_REG, val);\r\ntime_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);\r\nwhile (!(priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&\r\ntime_after(time_out, jiffies))\r\ncpu_relax();\r\nif (time_after(jiffies, time_out))\r\nreturn -ETIMEDOUT;\r\nc_can_stop(dev);\r\nc_can_reset_ram(priv, false);\r\nc_can_pm_runtime_put_sync(priv);\r\nreturn 0;\r\n}\r\nint c_can_power_up(struct net_device *dev)\r\n{\r\nu32 val;\r\nunsigned long time_out;\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nif (!(dev->flags & IFF_UP))\r\nreturn 0;\r\nWARN_ON(priv->type != BOSCH_D_CAN);\r\nc_can_pm_runtime_get_sync(priv);\r\nc_can_reset_ram(priv, true);\r\nval = priv->read_reg(priv, C_CAN_CTRL_EX_REG);\r\nval &= ~CONTROL_EX_PDR;\r\npriv->write_reg(priv, C_CAN_CTRL_EX_REG, val);\r\nval = priv->read_reg(priv, C_CAN_CTRL_REG);\r\nval &= ~CONTROL_INIT;\r\npriv->write_reg(priv, C_CAN_CTRL_REG, val);\r\ntime_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);\r\nwhile ((priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&\r\ntime_after(time_out, jiffies))\r\ncpu_relax();\r\nif (time_after(jiffies, time_out))\r\nreturn -ETIMEDOUT;\r\nc_can_start(dev);\r\nreturn 0;\r\n}\r\nvoid free_c_can_dev(struct net_device *dev)\r\n{\r\nfree_candev(dev);\r\n}\r\nint register_c_can_dev(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nint err;\r\nc_can_pm_runtime_enable(priv);\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &c_can_netdev_ops;\r\nerr = register_candev(dev);\r\nif (err)\r\nc_can_pm_runtime_disable(priv);\r\nelse\r\ndevm_can_led_init(dev);\r\nreturn err;\r\n}\r\nvoid unregister_c_can_dev(struct net_device *dev)\r\n{\r\nstruct c_can_priv *priv = netdev_priv(dev);\r\nunregister_candev(dev);\r\nc_can_pm_runtime_disable(priv);\r\n}
