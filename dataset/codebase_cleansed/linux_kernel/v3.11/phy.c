static const char *phy_state_name(enum sci_phy_states state)\r\n{\r\nstatic const char * const strings[] = PHY_STATES;\r\nreturn strings[state];\r\n}\r\nenum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)\r\n{\r\nreturn iphy->max_negotiated_speed;\r\n}\r\nstatic struct isci_host *phy_to_host(struct isci_phy *iphy)\r\n{\r\nstruct isci_phy *table = iphy - iphy->phy_index;\r\nstruct isci_host *ihost = container_of(table, typeof(*ihost), phys[0]);\r\nreturn ihost;\r\n}\r\nstatic struct device *sciphy_to_dev(struct isci_phy *iphy)\r\n{\r\nreturn &phy_to_host(iphy)->pdev->dev;\r\n}\r\nstatic enum sci_status\r\nsci_phy_transport_layer_initialization(struct isci_phy *iphy,\r\nstruct scu_transport_layer_registers __iomem *reg)\r\n{\r\nu32 tl_control;\r\niphy->transport_layer_registers = reg;\r\nwritel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,\r\n&iphy->transport_layer_registers->stp_rni);\r\ntl_control = readl(&iphy->transport_layer_registers->control);\r\ntl_control |= SCU_TLCR_GEN_BIT(STP_WRITE_DATA_PREFETCH);\r\nwritel(tl_control, &iphy->transport_layer_registers->control);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status\r\nsci_phy_link_layer_initialization(struct isci_phy *iphy,\r\nstruct scu_link_layer_registers __iomem *llr)\r\n{\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nstruct sci_phy_user_params *phy_user;\r\nstruct sci_phy_oem_params *phy_oem;\r\nint phy_idx = iphy->phy_index;\r\nstruct sci_phy_cap phy_cap;\r\nu32 phy_configuration;\r\nu32 parity_check = 0;\r\nu32 parity_count = 0;\r\nu32 llctl, link_rate;\r\nu32 clksm_value = 0;\r\nu32 sp_timeouts = 0;\r\nphy_user = &ihost->user_parameters.phys[phy_idx];\r\nphy_oem = &ihost->oem_parameters.phys[phy_idx];\r\niphy->link_layer_registers = llr;\r\n#define SCI_END_DEVICE 0x01\r\nwritel(SCU_SAS_TIID_GEN_BIT(SMP_INITIATOR) |\r\nSCU_SAS_TIID_GEN_BIT(SSP_INITIATOR) |\r\nSCU_SAS_TIID_GEN_BIT(STP_INITIATOR) |\r\nSCU_SAS_TIID_GEN_BIT(DA_SATA_HOST) |\r\nSCU_SAS_TIID_GEN_VAL(DEVICE_TYPE, SCI_END_DEVICE),\r\n&llr->transmit_identification);\r\nwritel(0xFEDCBA98, &llr->sas_device_name_high);\r\nwritel(phy_idx, &llr->sas_device_name_low);\r\nwritel(phy_oem->sas_address.high, &llr->source_sas_address_high);\r\nwritel(phy_oem->sas_address.low, &llr->source_sas_address_low);\r\nwritel(0, &llr->identify_frame_phy_id);\r\nwritel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx), &llr->identify_frame_phy_id);\r\nphy_configuration = readl(&llr->phy_configuration);\r\nphy_configuration |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\r\nwritel(phy_configuration, &llr->phy_configuration);\r\nphy_cap.all = 0;\r\nphy_cap.start = 1;\r\nphy_cap.gen3_no_ssc = 1;\r\nphy_cap.gen2_no_ssc = 1;\r\nphy_cap.gen1_no_ssc = 1;\r\nif (ihost->oem_parameters.controller.do_enable_ssc) {\r\nstruct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;\r\nstruct scu_afe_transceiver __iomem *xcvr = &afe->scu_afe_xcvr[phy_idx];\r\nstruct isci_pci_info *pci_info = to_pci_info(ihost->pdev);\r\nbool en_sas = false;\r\nbool en_sata = false;\r\nu32 sas_type = 0;\r\nu32 sata_spread = 0x2;\r\nu32 sas_spread = 0x2;\r\nphy_cap.gen3_ssc = 1;\r\nphy_cap.gen2_ssc = 1;\r\nphy_cap.gen1_ssc = 1;\r\nif (pci_info->orom->hdr.version < ISCI_ROM_VER_1_1)\r\nen_sas = en_sata = true;\r\nelse {\r\nsata_spread = ihost->oem_parameters.controller.ssc_sata_tx_spread_level;\r\nsas_spread = ihost->oem_parameters.controller.ssc_sas_tx_spread_level;\r\nif (sata_spread)\r\nen_sata = true;\r\nif (sas_spread) {\r\nen_sas = true;\r\nsas_type = ihost->oem_parameters.controller.ssc_sas_tx_type;\r\n}\r\n}\r\nif (en_sas) {\r\nu32 reg;\r\nreg = readl(&xcvr->afe_xcvr_control0);\r\nreg |= (0x00100000 | (sas_type << 19));\r\nwritel(reg, &xcvr->afe_xcvr_control0);\r\nreg = readl(&xcvr->afe_tx_ssc_control);\r\nreg |= sas_spread << 8;\r\nwritel(reg, &xcvr->afe_tx_ssc_control);\r\n}\r\nif (en_sata) {\r\nu32 reg;\r\nreg = readl(&xcvr->afe_tx_ssc_control);\r\nreg |= sata_spread;\r\nwritel(reg, &xcvr->afe_tx_ssc_control);\r\nreg = readl(&llr->stp_control);\r\nreg |= 1 << 12;\r\nwritel(reg, &llr->stp_control);\r\n}\r\n}\r\nparity_check = phy_cap.all;\r\nwhile (parity_check != 0) {\r\nif (parity_check & 0x1)\r\nparity_count++;\r\nparity_check >>= 1;\r\n}\r\nif ((parity_count % 2) != 0)\r\nphy_cap.parity = 1;\r\nwritel(phy_cap.all, &llr->phy_capabilities);\r\nwritel(SCU_ENSPINUP_GEN_VAL(COUNT,\r\nphy_user->notify_enable_spin_up_insertion_frequency),\r\n&llr->notify_enable_spinup_control);\r\nclksm_value = SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(CONNECTED,\r\nphy_user->in_connection_align_insertion_frequency);\r\nclksm_value |= SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(GENERAL,\r\nphy_user->align_insertion_frequency);\r\nwritel(clksm_value, &llr->clock_skew_management);\r\nif (is_c0(ihost->pdev) || is_c1(ihost->pdev)) {\r\nwritel(0x04210400, &llr->afe_lookup_table_control);\r\nwritel(0x020A7C05, &llr->sas_primitive_timeout);\r\n} else\r\nwritel(0x02108421, &llr->afe_lookup_table_control);\r\nllctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,\r\n(u8)ihost->user_parameters.no_outbound_task_timeout);\r\nswitch (phy_user->max_speed_generation) {\r\ncase SCIC_SDS_PARM_GEN3_SPEED:\r\nlink_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN3;\r\nbreak;\r\ncase SCIC_SDS_PARM_GEN2_SPEED:\r\nlink_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN2;\r\nbreak;\r\ndefault:\r\nlink_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN1;\r\nbreak;\r\n}\r\nllctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);\r\nwritel(llctl, &llr->link_layer_control);\r\nsp_timeouts = readl(&llr->sas_phy_timeouts);\r\nsp_timeouts &= ~SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0xFF);\r\nsp_timeouts |= SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0x3B);\r\nwritel(sp_timeouts, &llr->sas_phy_timeouts);\r\nif (is_a2(ihost->pdev)) {\r\nwritel(SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME,\r\n&llr->maximum_arbitration_wait_timer_timeout);\r\n}\r\nwritel(0, &llr->link_layer_hang_detection_timeout);\r\nsci_change_state(&iphy->sm, SCI_PHY_STOPPED);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic void phy_sata_timeout(unsigned long data)\r\n{\r\nstruct sci_timer *tmr = (struct sci_timer *)data;\r\nstruct isci_phy *iphy = container_of(tmr, typeof(*iphy), sata_timer);\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nif (tmr->cancel)\r\ngoto done;\r\ndev_dbg(sciphy_to_dev(iphy),\r\n"%s: SCIC SDS Phy 0x%p did not receive signature fis before "\r\n"timeout.\n",\r\n__func__,\r\niphy);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\ndone:\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}\r\nstruct isci_port *phy_get_non_dummy_port(struct isci_phy *iphy)\r\n{\r\nstruct isci_port *iport = iphy->owning_port;\r\nif (iport->physical_port_index == SCIC_SDS_DUMMY_PORT)\r\nreturn NULL;\r\nreturn iphy->owning_port;\r\n}\r\nvoid sci_phy_set_port(\r\nstruct isci_phy *iphy,\r\nstruct isci_port *iport)\r\n{\r\niphy->owning_port = iport;\r\nif (iphy->bcn_received_while_port_unassigned) {\r\niphy->bcn_received_while_port_unassigned = false;\r\nsci_port_broadcast_change_received(iphy->owning_port, iphy);\r\n}\r\n}\r\nenum sci_status sci_phy_initialize(struct isci_phy *iphy,\r\nstruct scu_transport_layer_registers __iomem *tl,\r\nstruct scu_link_layer_registers __iomem *ll)\r\n{\r\nsci_phy_transport_layer_initialization(iphy, tl);\r\nsci_phy_link_layer_initialization(iphy, ll);\r\nsci_change_state(&iphy->sm, SCI_PHY_STOPPED);\r\nreturn SCI_SUCCESS;\r\n}\r\nvoid sci_phy_setup_transport(struct isci_phy *iphy, u32 device_id)\r\n{\r\nu32 tl_control;\r\nwritel(device_id, &iphy->transport_layer_registers->stp_rni);\r\ntl_control = readl(&iphy->transport_layer_registers->control);\r\ntl_control |= SCU_TLCR_GEN_BIT(CLEAR_TCI_NCQ_MAPPING_TABLE);\r\nwritel(tl_control, &iphy->transport_layer_registers->control);\r\n}\r\nstatic void sci_phy_suspend(struct isci_phy *iphy)\r\n{\r\nu32 scu_sas_pcfg_value;\r\nscu_sas_pcfg_value =\r\nreadl(&iphy->link_layer_registers->phy_configuration);\r\nscu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);\r\nwritel(scu_sas_pcfg_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\nsci_phy_setup_transport(iphy, SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);\r\n}\r\nvoid sci_phy_resume(struct isci_phy *iphy)\r\n{\r\nu32 scu_sas_pcfg_value;\r\nscu_sas_pcfg_value =\r\nreadl(&iphy->link_layer_registers->phy_configuration);\r\nscu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);\r\nwritel(scu_sas_pcfg_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\n}\r\nvoid sci_phy_get_sas_address(struct isci_phy *iphy, struct sci_sas_address *sas)\r\n{\r\nsas->high = readl(&iphy->link_layer_registers->source_sas_address_high);\r\nsas->low = readl(&iphy->link_layer_registers->source_sas_address_low);\r\n}\r\nvoid sci_phy_get_attached_sas_address(struct isci_phy *iphy, struct sci_sas_address *sas)\r\n{\r\nstruct sas_identify_frame *iaf;\r\niaf = &iphy->frame_rcvd.iaf;\r\nmemcpy(sas, iaf->sas_addr, SAS_ADDR_SIZE);\r\n}\r\nvoid sci_phy_get_protocols(struct isci_phy *iphy, struct sci_phy_proto *proto)\r\n{\r\nproto->all = readl(&iphy->link_layer_registers->transmit_identification);\r\n}\r\nenum sci_status sci_phy_start(struct isci_phy *iphy)\r\n{\r\nenum sci_phy_states state = iphy->sm.current_state_id;\r\nif (state != SCI_PHY_STOPPED) {\r\ndev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",\r\n__func__, phy_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_phy_stop(struct isci_phy *iphy)\r\n{\r\nenum sci_phy_states state = iphy->sm.current_state_id;\r\nswitch (state) {\r\ncase SCI_PHY_SUB_INITIAL:\r\ncase SCI_PHY_SUB_AWAIT_OSSP_EN:\r\ncase SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:\r\ncase SCI_PHY_SUB_AWAIT_SAS_POWER:\r\ncase SCI_PHY_SUB_AWAIT_SATA_POWER:\r\ncase SCI_PHY_SUB_AWAIT_SATA_PHY_EN:\r\ncase SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:\r\ncase SCI_PHY_SUB_AWAIT_SIG_FIS_UF:\r\ncase SCI_PHY_SUB_FINAL:\r\ncase SCI_PHY_READY:\r\nbreak;\r\ndefault:\r\ndev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",\r\n__func__, phy_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_change_state(&iphy->sm, SCI_PHY_STOPPED);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_phy_reset(struct isci_phy *iphy)\r\n{\r\nenum sci_phy_states state = iphy->sm.current_state_id;\r\nif (state != SCI_PHY_READY) {\r\ndev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",\r\n__func__, phy_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_change_state(&iphy->sm, SCI_PHY_RESETTING);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_phy_consume_power_handler(struct isci_phy *iphy)\r\n{\r\nenum sci_phy_states state = iphy->sm.current_state_id;\r\nswitch (state) {\r\ncase SCI_PHY_SUB_AWAIT_SAS_POWER: {\r\nu32 enable_spinup;\r\nenable_spinup = readl(&iphy->link_layer_registers->notify_enable_spinup_control);\r\nenable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);\r\nwritel(enable_spinup, &iphy->link_layer_registers->notify_enable_spinup_control);\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);\r\nreturn SCI_SUCCESS;\r\n}\r\ncase SCI_PHY_SUB_AWAIT_SATA_POWER: {\r\nu32 scu_sas_pcfg_value;\r\nscu_sas_pcfg_value =\r\nreadl(&iphy->link_layer_registers->phy_configuration);\r\nscu_sas_pcfg_value &=\r\n~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));\r\nscu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\r\nwritel(scu_sas_pcfg_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\nscu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\r\nscu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);\r\nwritel(scu_sas_pcfg_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);\r\nreturn SCI_SUCCESS;\r\n}\r\ndefault:\r\ndev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",\r\n__func__, phy_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\n}\r\nstatic void sci_phy_start_sas_link_training(struct isci_phy *iphy)\r\n{\r\nu32 phy_control;\r\nphy_control = readl(&iphy->link_layer_registers->phy_configuration);\r\nphy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);\r\nwritel(phy_control,\r\n&iphy->link_layer_registers->phy_configuration);\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);\r\niphy->protocol = SAS_PROTOCOL_SSP;\r\n}\r\nstatic void sci_phy_start_sata_link_training(struct isci_phy *iphy)\r\n{\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);\r\niphy->protocol = SAS_PROTOCOL_SATA;\r\n}\r\nstatic void sci_phy_complete_link_training(struct isci_phy *iphy,\r\nenum sas_linkrate max_link_rate,\r\nu32 next_state)\r\n{\r\niphy->max_negotiated_speed = max_link_rate;\r\nsci_change_state(&iphy->sm, next_state);\r\n}\r\nstatic const char *phy_event_name(u32 event_code)\r\n{\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_PORT_SELECTOR_DETECTED:\r\nreturn "port selector";\r\ncase SCU_EVENT_SENT_PORT_SELECTION:\r\nreturn "port selection";\r\ncase SCU_EVENT_HARD_RESET_TRANSMITTED:\r\nreturn "tx hard reset";\r\ncase SCU_EVENT_HARD_RESET_RECEIVED:\r\nreturn "rx hard reset";\r\ncase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\r\nreturn "identify timeout";\r\ncase SCU_EVENT_LINK_FAILURE:\r\nreturn "link fail";\r\ncase SCU_EVENT_SATA_SPINUP_HOLD:\r\nreturn "sata spinup hold";\r\ncase SCU_EVENT_SAS_15_SSC:\r\ncase SCU_EVENT_SAS_15:\r\nreturn "sas 1.5";\r\ncase SCU_EVENT_SAS_30_SSC:\r\ncase SCU_EVENT_SAS_30:\r\nreturn "sas 3.0";\r\ncase SCU_EVENT_SAS_60_SSC:\r\ncase SCU_EVENT_SAS_60:\r\nreturn "sas 6.0";\r\ncase SCU_EVENT_SATA_15_SSC:\r\ncase SCU_EVENT_SATA_15:\r\nreturn "sata 1.5";\r\ncase SCU_EVENT_SATA_30_SSC:\r\ncase SCU_EVENT_SATA_30:\r\nreturn "sata 3.0";\r\ncase SCU_EVENT_SATA_60_SSC:\r\ncase SCU_EVENT_SATA_60:\r\nreturn "sata 6.0";\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nreturn "sas detect";\r\ncase SCU_EVENT_SATA_PHY_DETECTED:\r\nreturn "sata detect";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nvoid scu_link_layer_set_txcomsas_timeout(struct isci_phy *iphy, u32 timeout)\r\n{\r\nu32 val;\r\nval = readl(&iphy->link_layer_registers->transmit_comsas_signal);\r\nval &= ~SCU_SAS_LLTXCOMSAS_GEN_VAL(NEGTIME, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_MASK);\r\nval |= SCU_SAS_LLTXCOMSAS_GEN_VAL(NEGTIME, timeout);\r\nwritel(val, &iphy->link_layer_registers->transmit_comsas_signal);\r\n}\r\nenum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)\r\n{\r\nenum sci_phy_states state = iphy->sm.current_state_id;\r\nswitch (state) {\r\ncase SCI_PHY_SUB_AWAIT_OSSP_EN:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nsci_phy_start_sas_link_training(iphy);\r\niphy->is_in_link_training = true;\r\nbreak;\r\ncase SCU_EVENT_SATA_SPINUP_HOLD:\r\nsci_phy_start_sata_link_training(iphy);\r\niphy->is_in_link_training = true;\r\nbreak;\r\ncase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ndefault:\r\nphy_event_dbg(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nbreak;\r\ncase SCU_EVENT_SAS_15:\r\ncase SCU_EVENT_SAS_15_SSC:\r\nsci_phy_complete_link_training(iphy, SAS_LINK_RATE_1_5_GBPS,\r\nSCI_PHY_SUB_AWAIT_IAF_UF);\r\nbreak;\r\ncase SCU_EVENT_SAS_30:\r\ncase SCU_EVENT_SAS_30_SSC:\r\nsci_phy_complete_link_training(iphy, SAS_LINK_RATE_3_0_GBPS,\r\nSCI_PHY_SUB_AWAIT_IAF_UF);\r\nbreak;\r\ncase SCU_EVENT_SAS_60:\r\ncase SCU_EVENT_SAS_60_SSC:\r\nsci_phy_complete_link_training(iphy, SAS_LINK_RATE_6_0_GBPS,\r\nSCI_PHY_SUB_AWAIT_IAF_UF);\r\nbreak;\r\ncase SCU_EVENT_SATA_SPINUP_HOLD:\r\nsci_phy_start_sata_link_training(iphy);\r\nbreak;\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ncase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_IAF_UF:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nsci_phy_start_sas_link_training(iphy);\r\nbreak;\r\ncase SCU_EVENT_SATA_SPINUP_HOLD:\r\nsci_phy_start_sata_link_training(iphy);\r\nbreak;\r\ncase SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\ncase SCU_EVENT_HARD_RESET_RECEIVED:\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_SAS_POWER:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_SATA_POWER:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ncase SCU_EVENT_SATA_SPINUP_HOLD:\r\nbreak;\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nsci_phy_start_sas_link_training(iphy);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_SATA_PHY_EN:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ncase SCU_EVENT_SATA_SPINUP_HOLD:\r\nbreak;\r\ncase SCU_EVENT_SATA_PHY_DETECTED:\r\niphy->protocol = SAS_PROTOCOL_SATA;\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);\r\nbreak;\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nsci_phy_start_sas_link_training(iphy);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_SATA_PHY_DETECTED:\r\nbreak;\r\ncase SCU_EVENT_SATA_15:\r\ncase SCU_EVENT_SATA_15_SSC:\r\nsci_phy_complete_link_training(iphy, SAS_LINK_RATE_1_5_GBPS,\r\nSCI_PHY_SUB_AWAIT_SIG_FIS_UF);\r\nbreak;\r\ncase SCU_EVENT_SATA_30:\r\ncase SCU_EVENT_SATA_30_SSC:\r\nsci_phy_complete_link_training(iphy, SAS_LINK_RATE_3_0_GBPS,\r\nSCI_PHY_SUB_AWAIT_SIG_FIS_UF);\r\nbreak;\r\ncase SCU_EVENT_SATA_60:\r\ncase SCU_EVENT_SATA_60_SSC:\r\nsci_phy_complete_link_training(iphy, SAS_LINK_RATE_6_0_GBPS,\r\nSCI_PHY_SUB_AWAIT_SIG_FIS_UF);\r\nbreak;\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ncase SCU_EVENT_SAS_PHY_DETECTED:\r\nsci_phy_start_sas_link_training(iphy);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_SUB_AWAIT_SIG_FIS_UF:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_SATA_PHY_DETECTED:\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);\r\nbreak;\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_READY:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_LINK_FAILURE:\r\nscu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ncase SCU_EVENT_BROADCAST_CHANGE:\r\ncase SCU_EVENT_BROADCAST_SES:\r\ncase SCU_EVENT_BROADCAST_RESERVED0:\r\ncase SCU_EVENT_BROADCAST_RESERVED1:\r\ncase SCU_EVENT_BROADCAST_EXPANDER:\r\ncase SCU_EVENT_BROADCAST_AEN:\r\nif (phy_get_non_dummy_port(iphy) != NULL)\r\nsci_port_broadcast_change_received(iphy->owning_port, iphy);\r\nelse\r\niphy->bcn_received_while_port_unassigned = true;\r\nbreak;\r\ncase SCU_EVENT_BROADCAST_RESERVED3:\r\ncase SCU_EVENT_BROADCAST_RESERVED4:\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_PHY_RESETTING:\r\nswitch (scu_get_event_code(event_code)) {\r\ncase SCU_EVENT_HARD_RESET_TRANSMITTED:\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\nbreak;\r\ndefault:\r\nphy_event_warn(iphy, state, event_code);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\ndefault:\r\ndev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",\r\n__func__, phy_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\n}\r\nenum sci_status sci_phy_frame_handler(struct isci_phy *iphy, u32 frame_index)\r\n{\r\nenum sci_phy_states state = iphy->sm.current_state_id;\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nenum sci_status result;\r\nunsigned long flags;\r\nswitch (state) {\r\ncase SCI_PHY_SUB_AWAIT_IAF_UF: {\r\nu32 *frame_words;\r\nstruct sas_identify_frame iaf;\r\nresult = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_words);\r\nif (result != SCI_SUCCESS)\r\nreturn result;\r\nsci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));\r\nif (iaf.frame_type == 0) {\r\nu32 state;\r\nspin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);\r\nmemcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));\r\nspin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);\r\nif (iaf.smp_tport) {\r\nstate = SCI_PHY_SUB_FINAL;\r\n} else {\r\nstate = SCI_PHY_SUB_AWAIT_SAS_POWER;\r\n}\r\nsci_change_state(&iphy->sm, state);\r\nresult = SCI_SUCCESS;\r\n} else\r\ndev_warn(sciphy_to_dev(iphy),\r\n"%s: PHY starting substate machine received "\r\n"unexpected frame id %x\n",\r\n__func__, frame_index);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn result;\r\n}\r\ncase SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {\r\nstruct dev_to_host_fis *frame_header;\r\nu32 *fis_frame_data;\r\nresult = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_header);\r\nif (result != SCI_SUCCESS)\r\nreturn result;\r\nif ((frame_header->fis_type == FIS_REGD2H) &&\r\n!(frame_header->status & ATA_BUSY)) {\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&fis_frame_data);\r\nspin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);\r\nsci_controller_copy_sata_response(&iphy->frame_rcvd.fis,\r\nframe_header,\r\nfis_frame_data);\r\nspin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);\r\nresult = SCI_SUCCESS;\r\n} else\r\ndev_warn(sciphy_to_dev(iphy),\r\n"%s: PHY starting substate machine received "\r\n"unexpected frame id %x\n",\r\n__func__, frame_index);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn result;\r\n}\r\ndefault:\r\ndev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",\r\n__func__, phy_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\n}\r\nstatic void sci_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);\r\n}\r\nstatic void sci_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nsci_controller_power_control_queue_insert(ihost, iphy);\r\n}\r\nstatic void sci_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nsci_controller_power_control_queue_remove(ihost, iphy);\r\n}\r\nstatic void sci_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nsci_controller_power_control_queue_insert(ihost, iphy);\r\n}\r\nstatic void sci_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_host *ihost = iphy->owning_port->owning_controller;\r\nsci_controller_power_control_queue_remove(ihost, iphy);\r\n}\r\nstatic void sci_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);\r\n}\r\nstatic void sci_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_del_timer(&iphy->sata_timer);\r\n}\r\nstatic void sci_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);\r\n}\r\nstatic void sci_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_del_timer(&iphy->sata_timer);\r\n}\r\nstatic void sci_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nif (sci_port_link_detected(iphy->owning_port, iphy)) {\r\nsci_phy_resume(iphy);\r\nsci_mod_timer(&iphy->sata_timer,\r\nSCIC_SDS_SIGNATURE_FIS_TIMEOUT);\r\n} else\r\niphy->is_in_link_training = false;\r\n}\r\nstatic void sci_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_del_timer(&iphy->sata_timer);\r\n}\r\nstatic void sci_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_change_state(&iphy->sm, SCI_PHY_READY);\r\n}\r\nstatic void scu_link_layer_stop_protocol_engine(\r\nstruct isci_phy *iphy)\r\n{\r\nu32 scu_sas_pcfg_value;\r\nu32 enable_spinup_value;\r\nscu_sas_pcfg_value =\r\nreadl(&iphy->link_layer_registers->phy_configuration);\r\nscu_sas_pcfg_value |=\r\n(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |\r\nSCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE) |\r\nSCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD));\r\nwritel(scu_sas_pcfg_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\nenable_spinup_value = readl(&iphy->link_layer_registers->notify_enable_spinup_control);\r\nenable_spinup_value &= ~SCU_ENSPINUP_GEN_BIT(ENABLE);\r\nwritel(enable_spinup_value, &iphy->link_layer_registers->notify_enable_spinup_control);\r\n}\r\nstatic void scu_link_layer_start_oob(struct isci_phy *iphy)\r\n{\r\nstruct scu_link_layer_registers __iomem *ll = iphy->link_layer_registers;\r\nu32 val;\r\nval = readl(&ll->phy_configuration);\r\nval &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |\r\nSCU_SAS_PCFG_GEN_BIT(OOB_ENABLE) |\r\nSCU_SAS_PCFG_GEN_BIT(HARD_RESET));\r\nwritel(val, &ll->phy_configuration);\r\nreadl(&ll->phy_configuration);\r\nval = readl(&ll->phy_configuration);\r\nval |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);\r\nwritel(val, &ll->phy_configuration);\r\nreadl(&ll->phy_configuration);\r\n}\r\nstatic void scu_link_layer_tx_hard_reset(\r\nstruct isci_phy *iphy)\r\n{\r\nu32 phy_configuration_value;\r\nphy_configuration_value =\r\nreadl(&iphy->link_layer_registers->phy_configuration);\r\nphy_configuration_value &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));\r\nphy_configuration_value |=\r\n(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |\r\nSCU_SAS_PCFG_GEN_BIT(OOB_RESET));\r\nwritel(phy_configuration_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\nphy_configuration_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);\r\nphy_configuration_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);\r\nwritel(phy_configuration_value,\r\n&iphy->link_layer_registers->phy_configuration);\r\n}\r\nstatic void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_port *iport = iphy->owning_port;\r\nstruct isci_host *ihost = iport->owning_controller;\r\nsci_del_timer(&iphy->sata_timer);\r\nscu_link_layer_stop_protocol_engine(iphy);\r\nif (iphy->sm.previous_state_id != SCI_PHY_INITIAL)\r\nsci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);\r\n}\r\nstatic void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_port *iport = iphy->owning_port;\r\nstruct isci_host *ihost = iport->owning_controller;\r\nscu_link_layer_stop_protocol_engine(iphy);\r\nscu_link_layer_start_oob(iphy);\r\niphy->protocol = SAS_PROTOCOL_NONE;\r\niphy->bcn_received_while_port_unassigned = false;\r\nif (iphy->sm.previous_state_id == SCI_PHY_READY)\r\nsci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);\r\nsci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);\r\n}\r\nstatic void sci_phy_ready_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nstruct isci_port *iport = iphy->owning_port;\r\nstruct isci_host *ihost = iport->owning_controller;\r\nsci_controller_link_up(ihost, phy_get_non_dummy_port(iphy), iphy);\r\n}\r\nstatic void sci_phy_ready_state_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_phy_suspend(iphy);\r\n}\r\nstatic void sci_phy_resetting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);\r\nsci_port_deactivate_phy(iphy->owning_port, iphy, false);\r\nif (iphy->protocol == SAS_PROTOCOL_SSP) {\r\nscu_link_layer_tx_hard_reset(iphy);\r\n} else {\r\nsci_change_state(&iphy->sm, SCI_PHY_STARTING);\r\n}\r\n}\r\nvoid sci_phy_construct(struct isci_phy *iphy,\r\nstruct isci_port *iport, u8 phy_index)\r\n{\r\nsci_init_sm(&iphy->sm, sci_phy_state_table, SCI_PHY_INITIAL);\r\niphy->owning_port = iport;\r\niphy->phy_index = phy_index;\r\niphy->bcn_received_while_port_unassigned = false;\r\niphy->protocol = SAS_PROTOCOL_NONE;\r\niphy->link_layer_registers = NULL;\r\niphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;\r\nsci_init_timer(&iphy->sata_timer, phy_sata_timeout);\r\n}\r\nvoid isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)\r\n{\r\nstruct sci_oem_params *oem = &ihost->oem_parameters;\r\nu64 sci_sas_addr;\r\n__be64 sas_addr;\r\nsci_sas_addr = oem->phys[index].sas_address.high;\r\nsci_sas_addr <<= 32;\r\nsci_sas_addr |= oem->phys[index].sas_address.low;\r\nsas_addr = cpu_to_be64(sci_sas_addr);\r\nmemcpy(iphy->sas_addr, &sas_addr, sizeof(sas_addr));\r\niphy->sas_phy.enabled = 0;\r\niphy->sas_phy.id = index;\r\niphy->sas_phy.sas_addr = &iphy->sas_addr[0];\r\niphy->sas_phy.frame_rcvd = (u8 *)&iphy->frame_rcvd;\r\niphy->sas_phy.ha = &ihost->sas_ha;\r\niphy->sas_phy.lldd_phy = iphy;\r\niphy->sas_phy.enabled = 1;\r\niphy->sas_phy.class = SAS;\r\niphy->sas_phy.iproto = SAS_PROTOCOL_ALL;\r\niphy->sas_phy.tproto = 0;\r\niphy->sas_phy.type = PHY_TYPE_PHYSICAL;\r\niphy->sas_phy.role = PHY_ROLE_INITIATOR;\r\niphy->sas_phy.oob_mode = OOB_NOT_CONNECTED;\r\niphy->sas_phy.linkrate = SAS_LINK_RATE_UNKNOWN;\r\nmemset(&iphy->frame_rcvd, 0, sizeof(iphy->frame_rcvd));\r\n}\r\nint isci_phy_control(struct asd_sas_phy *sas_phy,\r\nenum phy_func func,\r\nvoid *buf)\r\n{\r\nint ret = 0;\r\nstruct isci_phy *iphy = sas_phy->lldd_phy;\r\nstruct asd_sas_port *port = sas_phy->port;\r\nstruct isci_host *ihost = sas_phy->ha->lldd_ha;\r\nunsigned long flags;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: phy %p; func %d; buf %p; isci phy %p, port %p\n",\r\n__func__, sas_phy, func, buf, iphy, port);\r\nswitch (func) {\r\ncase PHY_FUNC_DISABLE:\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nscu_link_layer_start_oob(iphy);\r\nsci_phy_stop(iphy);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nbreak;\r\ncase PHY_FUNC_LINK_RESET:\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nscu_link_layer_start_oob(iphy);\r\nsci_phy_stop(iphy);\r\nsci_phy_start(iphy);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nbreak;\r\ncase PHY_FUNC_HARD_RESET:\r\nif (!port)\r\nreturn -ENODEV;\r\nret = isci_port_perform_hard_reset(ihost, port->lldd_port, iphy);\r\nbreak;\r\ncase PHY_FUNC_GET_EVENTS: {\r\nstruct scu_link_layer_registers __iomem *r;\r\nstruct sas_phy *phy = sas_phy->phy;\r\nr = iphy->link_layer_registers;\r\nphy->running_disparity_error_count = readl(&r->running_disparity_error_count);\r\nphy->loss_of_dword_sync_count = readl(&r->loss_of_sync_error_count);\r\nphy->phy_reset_problem_count = readl(&r->phy_reset_problem_count);\r\nphy->invalid_dword_count = readl(&r->invalid_dword_counter);\r\nbreak;\r\n}\r\ndefault:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: phy %p; func %d NOT IMPLEMENTED!\n",\r\n__func__, sas_phy, func);\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nreturn ret;\r\n}
