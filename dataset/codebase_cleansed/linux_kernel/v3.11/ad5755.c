static int ad5755_write_unlocked(struct iio_dev *indio_dev,\r\nunsigned int reg, unsigned int val)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nst->data[0].d32 = cpu_to_be32((reg << 16) | val);\r\nreturn spi_write(st->spi, &st->data[0].d8[1], 3);\r\n}\r\nstatic int ad5755_write_ctrl_unlocked(struct iio_dev *indio_dev,\r\nunsigned int channel, unsigned int reg, unsigned int val)\r\n{\r\nreturn ad5755_write_unlocked(indio_dev,\r\nAD5755_WRITE_REG_CTRL(channel), (reg << 13) | val);\r\n}\r\nstatic int ad5755_write(struct iio_dev *indio_dev, unsigned int reg,\r\nunsigned int val)\r\n{\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5755_write_unlocked(indio_dev, reg, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5755_write_ctrl(struct iio_dev *indio_dev, unsigned int channel,\r\nunsigned int reg, unsigned int val)\r\n{\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5755_write_ctrl_unlocked(indio_dev, channel, reg, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5755_read(struct iio_dev *indio_dev, unsigned int addr)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[1],\r\n.len = 3,\r\n.cs_change = 1,\r\n}, {\r\n.tx_buf = &st->data[1].d8[1],\r\n.rx_buf = &st->data[1].d8[1],\r\n.len = 3,\r\n},\r\n};\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0].d32 = cpu_to_be32(AD5755_READ_FLAG | (addr << 16));\r\nst->data[1].d32 = cpu_to_be32(AD5755_NOOP);\r\nret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\r\nif (ret >= 0)\r\nret = be32_to_cpu(st->data[1].d32) & 0xffff;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5755_update_dac_ctrl(struct iio_dev *indio_dev,\r\nunsigned int channel, unsigned int set, unsigned int clr)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nint ret;\r\nst->ctrl[channel] |= set;\r\nst->ctrl[channel] &= ~clr;\r\nret = ad5755_write_ctrl_unlocked(indio_dev, channel,\r\nAD5755_CTRL_REG_DAC, st->ctrl[channel]);\r\nreturn ret;\r\n}\r\nstatic int ad5755_set_channel_pwr_down(struct iio_dev *indio_dev,\r\nunsigned int channel, bool pwr_down)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nunsigned int mask = BIT(channel);\r\nmutex_lock(&indio_dev->mlock);\r\nif ((bool)(st->pwr_down & mask) == pwr_down)\r\ngoto out_unlock;\r\nif (!pwr_down) {\r\nst->pwr_down &= ~mask;\r\nad5755_update_dac_ctrl(indio_dev, channel,\r\nAD5755_DAC_INT_EN | AD5755_DAC_DC_DC_EN, 0);\r\nudelay(200);\r\nad5755_update_dac_ctrl(indio_dev, channel,\r\nAD5755_DAC_OUT_EN, 0);\r\n} else {\r\nst->pwr_down |= mask;\r\nad5755_update_dac_ctrl(indio_dev, channel,\r\n0, AD5755_DAC_INT_EN | AD5755_DAC_OUT_EN |\r\nAD5755_DAC_DC_DC_EN);\r\n}\r\nout_unlock:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic void ad5755_get_min_max(struct ad5755_state *st,\r\nstruct iio_chan_spec const *chan, int *min, int *max)\r\n{\r\nenum ad5755_mode mode = st->ctrl[chan->channel] & 7;\r\n*min = ad5755_min_max_table[mode][0];\r\n*max = ad5755_min_max_table[mode][1];\r\n}\r\nstatic inline int ad5755_get_offset(struct ad5755_state *st,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint min, max;\r\nad5755_get_min_max(st, chan, &min, &max);\r\nreturn (min * (1 << chan->scan_type.realbits)) / (max - min);\r\n}\r\nstatic inline int ad5755_get_scale(struct ad5755_state *st,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint min, max;\r\nad5755_get_min_max(st, chan, &min, &max);\r\nreturn ((max - min) * 1000000000ULL) >> chan->scan_type.realbits;\r\n}\r\nstatic int ad5755_chan_reg_info(struct ad5755_state *st,\r\nstruct iio_chan_spec const *chan, long info, bool write,\r\nunsigned int *reg, unsigned int *shift, unsigned int *offset)\r\n{\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (write)\r\n*reg = AD5755_WRITE_REG_DATA(chan->address);\r\nelse\r\n*reg = AD5755_READ_REG_DATA(chan->address);\r\n*shift = chan->scan_type.shift;\r\n*offset = 0;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (write)\r\n*reg = AD5755_WRITE_REG_OFFSET(chan->address);\r\nelse\r\n*reg = AD5755_READ_REG_OFFSET(chan->address);\r\n*shift = st->chip_info->calib_shift;\r\n*offset = 32768;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (write)\r\n*reg = AD5755_WRITE_REG_GAIN(chan->address);\r\nelse\r\n*reg = AD5755_READ_REG_GAIN(chan->address);\r\n*shift = st->chip_info->calib_shift;\r\n*offset = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5755_read_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *val, int *val2, long info)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nunsigned int reg, shift, offset;\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = ad5755_get_scale(st, chan);\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = ad5755_get_offset(st, chan);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nret = ad5755_chan_reg_info(st, chan, info, false,\r\n&reg, &shift, &offset);\r\nif (ret)\r\nreturn ret;\r\nret = ad5755_read(indio_dev, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (ret - offset) >> shift;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5755_write_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int val, int val2, long info)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nunsigned int shift, reg, offset;\r\nint ret;\r\nret = ad5755_chan_reg_info(st, chan, info, true,\r\n&reg, &shift, &offset);\r\nif (ret)\r\nreturn ret;\r\nval <<= shift;\r\nval += offset;\r\nif (val < 0 || val > 0xffff)\r\nreturn -EINVAL;\r\nreturn ad5755_write(indio_dev, reg, val);\r\n}\r\nstatic ssize_t ad5755_read_powerdown(struct iio_dev *indio_dev, uintptr_t priv,\r\nconst struct iio_chan_spec *chan, char *buf)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n",\r\n(bool)(st->pwr_down & (1 << chan->channel)));\r\n}\r\nstatic ssize_t ad5755_write_powerdown(struct iio_dev *indio_dev, uintptr_t priv,\r\nstruct iio_chan_spec const *chan, const char *buf, size_t len)\r\n{\r\nbool pwr_down;\r\nint ret;\r\nret = strtobool(buf, &pwr_down);\r\nif (ret)\r\nreturn ret;\r\nret = ad5755_set_channel_pwr_down(indio_dev, chan->channel, pwr_down);\r\nreturn ret ? ret : len;\r\n}\r\nstatic bool ad5755_is_valid_mode(struct ad5755_state *st, enum ad5755_mode mode)\r\n{\r\nswitch (mode) {\r\ncase AD5755_MODE_VOLTAGE_0V_5V:\r\ncase AD5755_MODE_VOLTAGE_0V_10V:\r\ncase AD5755_MODE_VOLTAGE_PLUSMINUS_5V:\r\ncase AD5755_MODE_VOLTAGE_PLUSMINUS_10V:\r\nreturn st->chip_info->has_voltage_out;\r\ncase AD5755_MODE_CURRENT_4mA_20mA:\r\ncase AD5755_MODE_CURRENT_0mA_20mA:\r\ncase AD5755_MODE_CURRENT_0mA_24mA:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int ad5755_setup_pdata(struct iio_dev *indio_dev,\r\nconst struct ad5755_platform_data *pdata)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nunsigned int val;\r\nunsigned int i;\r\nint ret;\r\nif (pdata->dc_dc_phase > AD5755_DC_DC_PHASE_90_DEGREE ||\r\npdata->dc_dc_freq > AD5755_DC_DC_FREQ_650kHZ ||\r\npdata->dc_dc_maxv > AD5755_DC_DC_MAXV_29V5)\r\nreturn -EINVAL;\r\nval = pdata->dc_dc_maxv << AD5755_DC_DC_MAXV;\r\nval |= pdata->dc_dc_freq << AD5755_DC_DC_FREQ_SHIFT;\r\nval |= pdata->dc_dc_phase << AD5755_DC_DC_PHASE_SHIFT;\r\nif (pdata->ext_dc_dc_compenstation_resistor)\r\nval |= AD5755_EXT_DC_DC_COMP_RES;\r\nret = ad5755_write_ctrl(indio_dev, 0, AD5755_CTRL_REG_DC_DC, val);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->dac); ++i) {\r\nval = pdata->dac[i].slew.step_size <<\r\nAD5755_SLEW_STEP_SIZE_SHIFT;\r\nval |= pdata->dac[i].slew.rate <<\r\nAD5755_SLEW_RATE_SHIFT;\r\nif (pdata->dac[i].slew.enable)\r\nval |= AD5755_SLEW_ENABLE;\r\nret = ad5755_write_ctrl(indio_dev, i,\r\nAD5755_CTRL_REG_SLEW, val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pdata->dac); ++i) {\r\nif (!ad5755_is_valid_mode(st, pdata->dac[i].mode))\r\nreturn -EINVAL;\r\nval = 0;\r\nif (!pdata->dac[i].ext_current_sense_resistor)\r\nval |= AD5755_DAC_INT_CURRENT_SENSE_RESISTOR;\r\nif (pdata->dac[i].enable_voltage_overrange)\r\nval |= AD5755_DAC_VOLTAGE_OVERRANGE_EN;\r\nval |= pdata->dac[i].mode;\r\nret = ad5755_update_dac_ctrl(indio_dev, i, val, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ad5755_is_voltage_mode(enum ad5755_mode mode)\r\n{\r\nswitch (mode) {\r\ncase AD5755_MODE_VOLTAGE_0V_5V:\r\ncase AD5755_MODE_VOLTAGE_0V_10V:\r\ncase AD5755_MODE_VOLTAGE_PLUSMINUS_5V:\r\ncase AD5755_MODE_VOLTAGE_PLUSMINUS_10V:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int ad5755_init_channels(struct iio_dev *indio_dev,\r\nconst struct ad5755_platform_data *pdata)\r\n{\r\nstruct ad5755_state *st = iio_priv(indio_dev);\r\nstruct iio_chan_spec *channels = st->channels;\r\nunsigned int i;\r\nfor (i = 0; i < AD5755_NUM_CHANNELS; ++i) {\r\nchannels[i] = st->chip_info->channel_template;\r\nchannels[i].channel = i;\r\nchannels[i].address = i;\r\nif (pdata && ad5755_is_voltage_mode(pdata->dac[i].mode))\r\nchannels[i].type = IIO_VOLTAGE;\r\nelse\r\nchannels[i].type = IIO_CURRENT;\r\n}\r\nindio_dev->channels = channels;\r\nreturn 0;\r\n}\r\nstatic int ad5755_probe(struct spi_device *spi)\r\n{\r\nenum ad5755_type type = spi_get_device_id(spi)->driver_data;\r\nconst struct ad5755_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nstruct iio_dev *indio_dev;\r\nstruct ad5755_state *st;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL) {\r\ndev_err(&spi->dev, "Failed to allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->chip_info = &ad5755_chip_info_tbl[type];\r\nst->spi = spi;\r\nst->pwr_down = 0xf;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->info = &ad5755_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->num_channels = AD5755_NUM_CHANNELS;\r\nif (!pdata)\r\npdata = &ad5755_default_pdata;\r\nret = ad5755_init_channels(indio_dev, pdata);\r\nif (ret)\r\ngoto error_free;\r\nret = ad5755_setup_pdata(indio_dev, pdata);\r\nif (ret)\r\ngoto error_free;\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to register iio device: %d\n", ret);\r\ngoto error_free;\r\n}\r\nreturn 0;\r\nerror_free:\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int ad5755_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\niio_device_unregister(indio_dev);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
