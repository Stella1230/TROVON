static inline struct s3c_hsotg_req *our_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct s3c_hsotg_req, req);\r\n}\r\nstatic inline struct s3c_hsotg_ep *our_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct s3c_hsotg_ep, ep);\r\n}\r\nstatic inline struct s3c_hsotg *to_hsotg(struct usb_gadget *gadget)\r\n{\r\nreturn container_of(gadget, struct s3c_hsotg, gadget);\r\n}\r\nstatic inline void __orr32(void __iomem *ptr, u32 val)\r\n{\r\nwritel(readl(ptr) | val, ptr);\r\n}\r\nstatic inline void __bic32(void __iomem *ptr, u32 val)\r\n{\r\nwritel(readl(ptr) & ~val, ptr);\r\n}\r\nstatic inline bool using_dma(struct s3c_hsotg *hsotg)\r\n{\r\nreturn false;\r\n}\r\nstatic void s3c_hsotg_en_gsint(struct s3c_hsotg *hsotg, u32 ints)\r\n{\r\nu32 gsintmsk = readl(hsotg->regs + GINTMSK);\r\nu32 new_gsintmsk;\r\nnew_gsintmsk = gsintmsk | ints;\r\nif (new_gsintmsk != gsintmsk) {\r\ndev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);\r\nwritel(new_gsintmsk, hsotg->regs + GINTMSK);\r\n}\r\n}\r\nstatic void s3c_hsotg_disable_gsint(struct s3c_hsotg *hsotg, u32 ints)\r\n{\r\nu32 gsintmsk = readl(hsotg->regs + GINTMSK);\r\nu32 new_gsintmsk;\r\nnew_gsintmsk = gsintmsk & ~ints;\r\nif (new_gsintmsk != gsintmsk)\r\nwritel(new_gsintmsk, hsotg->regs + GINTMSK);\r\n}\r\nstatic void s3c_hsotg_ctrl_epint(struct s3c_hsotg *hsotg,\r\nunsigned int ep, unsigned int dir_in,\r\nunsigned int en)\r\n{\r\nunsigned long flags;\r\nu32 bit = 1 << ep;\r\nu32 daint;\r\nif (!dir_in)\r\nbit <<= 16;\r\nlocal_irq_save(flags);\r\ndaint = readl(hsotg->regs + DAINTMSK);\r\nif (en)\r\ndaint |= bit;\r\nelse\r\ndaint &= ~bit;\r\nwritel(daint, hsotg->regs + DAINTMSK);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void s3c_hsotg_init_fifo(struct s3c_hsotg *hsotg)\r\n{\r\nunsigned int ep;\r\nunsigned int addr;\r\nunsigned int size;\r\nint timeout;\r\nu32 val;\r\nwritel(2048, hsotg->regs + GRXFSIZ);\r\nwritel(GNPTXFSIZ_NPTxFStAddr(2048) |\r\nGNPTXFSIZ_NPTxFDep(1024),\r\nhsotg->regs + GNPTXFSIZ);\r\naddr = 2048 + 1024;\r\nsize = 768;\r\nfor (ep = 1; ep <= 15; ep++) {\r\nval = addr;\r\nval |= size << DPTXFSIZn_DPTxFSize_SHIFT;\r\naddr += size;\r\nwritel(val, hsotg->regs + DPTXFSIZn(ep));\r\n}\r\nwritel(GRSTCTL_TxFNum(0x10) | GRSTCTL_TxFFlsh |\r\nGRSTCTL_RxFFlsh, hsotg->regs + GRSTCTL);\r\ntimeout = 100;\r\nwhile (1) {\r\nval = readl(hsotg->regs + GRSTCTL);\r\nif ((val & (GRSTCTL_TxFFlsh | GRSTCTL_RxFFlsh)) == 0)\r\nbreak;\r\nif (--timeout == 0) {\r\ndev_err(hsotg->dev,\r\n"%s: timeout flushing fifos (GRSTCTL=%08x)\n",\r\n__func__, val);\r\n}\r\nudelay(1);\r\n}\r\ndev_dbg(hsotg->dev, "FIFOs reset, timeout at %d\n", timeout);\r\n}\r\nstatic struct usb_request *s3c_hsotg_ep_alloc_request(struct usb_ep *ep,\r\ngfp_t flags)\r\n{\r\nstruct s3c_hsotg_req *req;\r\nreq = kzalloc(sizeof(struct s3c_hsotg_req), flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic inline int is_ep_periodic(struct s3c_hsotg_ep *hs_ep)\r\n{\r\nreturn hs_ep->periodic;\r\n}\r\nstatic void s3c_hsotg_unmap_dma(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req)\r\n{\r\nstruct usb_request *req = &hs_req->req;\r\nif (hs_req->req.length == 0)\r\nreturn;\r\nusb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->dir_in);\r\n}\r\nstatic int s3c_hsotg_write_fifo(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req)\r\n{\r\nbool periodic = is_ep_periodic(hs_ep);\r\nu32 gnptxsts = readl(hsotg->regs + GNPTXSTS);\r\nint buf_pos = hs_req->req.actual;\r\nint to_write = hs_ep->size_loaded;\r\nvoid *data;\r\nint can_write;\r\nint pkt_round;\r\nto_write -= (buf_pos - hs_ep->last_load);\r\nif (to_write == 0)\r\nreturn 0;\r\nif (periodic && !hsotg->dedicated_fifos) {\r\nu32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));\r\nint size_left;\r\nint size_done;\r\nsize_left = DxEPTSIZ_XferSize_GET(epsize);\r\nif (hs_ep->fifo_load != 0) {\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_PTxFEmp);\r\nreturn -ENOSPC;\r\n}\r\ndev_dbg(hsotg->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",\r\n__func__, size_left,\r\nhs_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);\r\nsize_done = hs_ep->size_loaded - size_left;\r\ncan_write = hs_ep->fifo_load - size_done;\r\ndev_dbg(hsotg->dev, "%s: => can_write1=%d\n",\r\n__func__, can_write);\r\ncan_write = hs_ep->fifo_size - can_write;\r\ndev_dbg(hsotg->dev, "%s: => can_write2=%d\n",\r\n__func__, can_write);\r\nif (can_write <= 0) {\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_PTxFEmp);\r\nreturn -ENOSPC;\r\n}\r\n} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {\r\ncan_write = readl(hsotg->regs + DTXFSTS(hs_ep->index));\r\ncan_write &= 0xffff;\r\ncan_write *= 4;\r\n} else {\r\nif (GNPTXSTS_NPTxQSpcAvail_GET(gnptxsts) == 0) {\r\ndev_dbg(hsotg->dev,\r\n"%s: no queue slots available (0x%08x)\n",\r\n__func__, gnptxsts);\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_NPTxFEmp);\r\nreturn -ENOSPC;\r\n}\r\ncan_write = GNPTXSTS_NPTxFSpcAvail_GET(gnptxsts);\r\ncan_write *= 4;\r\n}\r\ndev_dbg(hsotg->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, mps %d\n",\r\n__func__, gnptxsts, can_write, to_write, hs_ep->ep.maxpacket);\r\nif (can_write > 512)\r\ncan_write = 512;\r\nif (to_write > hs_ep->ep.maxpacket) {\r\nto_write = hs_ep->ep.maxpacket;\r\ns3c_hsotg_en_gsint(hsotg,\r\nperiodic ? GINTSTS_PTxFEmp :\r\nGINTSTS_NPTxFEmp);\r\n}\r\nif (to_write > can_write) {\r\nto_write = can_write;\r\npkt_round = to_write % hs_ep->ep.maxpacket;\r\nif (pkt_round)\r\nto_write -= pkt_round;\r\ns3c_hsotg_en_gsint(hsotg,\r\nperiodic ? GINTSTS_PTxFEmp :\r\nGINTSTS_NPTxFEmp);\r\n}\r\ndev_dbg(hsotg->dev, "write %d/%d, can_write %d, done %d\n",\r\nto_write, hs_req->req.length, can_write, buf_pos);\r\nif (to_write <= 0)\r\nreturn -ENOSPC;\r\nhs_req->req.actual = buf_pos + to_write;\r\nhs_ep->total_data += to_write;\r\nif (periodic)\r\nhs_ep->fifo_load += to_write;\r\nto_write = DIV_ROUND_UP(to_write, 4);\r\ndata = hs_req->req.buf + buf_pos;\r\nwritesl(hsotg->regs + EPFIFO(hs_ep->index), data, to_write);\r\nreturn (to_write >= can_write) ? -ENOSPC : 0;\r\n}\r\nstatic unsigned get_ep_limit(struct s3c_hsotg_ep *hs_ep)\r\n{\r\nint index = hs_ep->index;\r\nunsigned maxsize;\r\nunsigned maxpkt;\r\nif (index != 0) {\r\nmaxsize = DxEPTSIZ_XferSize_LIMIT + 1;\r\nmaxpkt = DxEPTSIZ_PktCnt_LIMIT + 1;\r\n} else {\r\nmaxsize = 64+64;\r\nif (hs_ep->dir_in)\r\nmaxpkt = DIEPTSIZ0_PktCnt_LIMIT + 1;\r\nelse\r\nmaxpkt = 2;\r\n}\r\nmaxpkt--;\r\nmaxsize--;\r\nif ((maxpkt * hs_ep->ep.maxpacket) < maxsize)\r\nmaxsize = maxpkt * hs_ep->ep.maxpacket;\r\nreturn maxsize;\r\n}\r\nstatic void s3c_hsotg_start_req(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req,\r\nbool continuing)\r\n{\r\nstruct usb_request *ureq = &hs_req->req;\r\nint index = hs_ep->index;\r\nint dir_in = hs_ep->dir_in;\r\nu32 epctrl_reg;\r\nu32 epsize_reg;\r\nu32 epsize;\r\nu32 ctrl;\r\nunsigned length;\r\nunsigned packets;\r\nunsigned maxreq;\r\nif (index != 0) {\r\nif (hs_ep->req && !continuing) {\r\ndev_err(hsotg->dev, "%s: active request\n", __func__);\r\nWARN_ON(1);\r\nreturn;\r\n} else if (hs_ep->req != hs_req && continuing) {\r\ndev_err(hsotg->dev,\r\n"%s: continue different req\n", __func__);\r\nWARN_ON(1);\r\nreturn;\r\n}\r\n}\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nepsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",\r\n__func__, readl(hsotg->regs + epctrl_reg), index,\r\nhs_ep->dir_in ? "in" : "out");\r\nctrl = readl(hsotg->regs + epctrl_reg);\r\nif (ctrl & DxEPCTL_Stall) {\r\ndev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);\r\nreturn;\r\n}\r\nlength = ureq->length - ureq->actual;\r\ndev_dbg(hsotg->dev, "ureq->length:%d ureq->actual:%d\n",\r\nureq->length, ureq->actual);\r\nif (0)\r\ndev_dbg(hsotg->dev,\r\n"REQ buf %p len %d dma 0x%08x noi=%d zp=%d snok=%d\n",\r\nureq->buf, length, ureq->dma,\r\nureq->no_interrupt, ureq->zero, ureq->short_not_ok);\r\nmaxreq = get_ep_limit(hs_ep);\r\nif (length > maxreq) {\r\nint round = maxreq % hs_ep->ep.maxpacket;\r\ndev_dbg(hsotg->dev, "%s: length %d, max-req %d, r %d\n",\r\n__func__, length, maxreq, round);\r\nif (round)\r\nmaxreq -= round;\r\nlength = maxreq;\r\n}\r\nif (length)\r\npackets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);\r\nelse\r\npackets = 1;\r\nif (dir_in && index != 0)\r\nepsize = DxEPTSIZ_MC(1);\r\nelse\r\nepsize = 0;\r\nif (index != 0 && ureq->zero) {\r\nif (length == (packets * hs_ep->ep.maxpacket))\r\npackets++;\r\n}\r\nepsize |= DxEPTSIZ_PktCnt(packets);\r\nepsize |= DxEPTSIZ_XferSize(length);\r\ndev_dbg(hsotg->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",\r\n__func__, packets, length, ureq->length, epsize, epsize_reg);\r\nhs_ep->req = hs_req;\r\nwritel(epsize, hsotg->regs + epsize_reg);\r\nif (using_dma(hsotg) && !continuing) {\r\nunsigned int dma_reg;\r\ndma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);\r\nwritel(ureq->dma, hsotg->regs + dma_reg);\r\ndev_dbg(hsotg->dev, "%s: 0x%08x => 0x%08x\n",\r\n__func__, ureq->dma, dma_reg);\r\n}\r\nctrl |= DxEPCTL_EPEna;\r\nctrl |= DxEPCTL_USBActEp;\r\ndev_dbg(hsotg->dev, "setup req:%d\n", hsotg->setup);\r\nif (hsotg->setup && index == 0)\r\nhsotg->setup = 0;\r\nelse\r\nctrl |= DxEPCTL_CNAK;\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);\r\nwritel(ctrl, hsotg->regs + epctrl_reg);\r\nhs_ep->size_loaded = length;\r\nhs_ep->last_load = ureq->actual;\r\nif (dir_in && !using_dma(hsotg)) {\r\nhs_ep->fifo_load = 0;\r\ns3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);\r\n}\r\nif (dir_in)\r\nwritel(DIEPMSK_INTknTXFEmpMsk,\r\nhsotg->regs + DIEPINT(index));\r\nif (!(readl(hsotg->regs + epctrl_reg) & DxEPCTL_EPEna))\r\ndev_warn(hsotg->dev,\r\n"ep%d: failed to become enabled (DxEPCTL=0x%08x)?\n",\r\nindex, readl(hsotg->regs + epctrl_reg));\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n",\r\n__func__, readl(hsotg->regs + epctrl_reg));\r\n}\r\nstatic int s3c_hsotg_map_dma(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nint ret;\r\nif (hs_req->req.length == 0)\r\nreturn 0;\r\nret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);\r\nif (ret)\r\ngoto dma_error;\r\nreturn 0;\r\ndma_error:\r\ndev_err(hsotg->dev, "%s: failed to map buffer %p, %d bytes\n",\r\n__func__, req->buf, req->length);\r\nreturn -EIO;\r\n}\r\nstatic int s3c_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hs = hs_ep->parent;\r\nbool first;\r\ndev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",\r\nep->name, req, req->length, req->buf, req->no_interrupt,\r\nreq->zero, req->short_not_ok);\r\nINIT_LIST_HEAD(&hs_req->queue);\r\nreq->actual = 0;\r\nreq->status = -EINPROGRESS;\r\nif (using_dma(hs)) {\r\nint ret = s3c_hsotg_map_dma(hs, hs_ep, req);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfirst = list_empty(&hs_ep->queue);\r\nlist_add_tail(&hs_req->queue, &hs_ep->queue);\r\nif (first)\r\ns3c_hsotg_start_req(hs, hs_ep, hs_req, false);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hs = hs_ep->parent;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&hs->lock, flags);\r\nret = s3c_hsotg_ep_queue(ep, req, gfp_flags);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void s3c_hsotg_ep_free_request(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nkfree(hs_req);\r\n}\r\nstatic void s3c_hsotg_complete_oursetup(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hsotg = hs_ep->parent;\r\ndev_dbg(hsotg->dev, "%s: ep %p, req %p\n", __func__, ep, req);\r\ns3c_hsotg_ep_free_request(ep, req);\r\n}\r\nstatic struct s3c_hsotg_ep *ep_from_windex(struct s3c_hsotg *hsotg,\r\nu32 windex)\r\n{\r\nstruct s3c_hsotg_ep *ep = &hsotg->eps[windex & 0x7F];\r\nint dir = (windex & USB_DIR_IN) ? 1 : 0;\r\nint idx = windex & 0x7F;\r\nif (windex >= 0x100)\r\nreturn NULL;\r\nif (idx > hsotg->num_of_eps)\r\nreturn NULL;\r\nif (idx && ep->dir_in != dir)\r\nreturn NULL;\r\nreturn ep;\r\n}\r\nstatic int s3c_hsotg_send_reply(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *ep,\r\nvoid *buff,\r\nint length)\r\n{\r\nstruct usb_request *req;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: buff %p, len %d\n", __func__, buff, length);\r\nreq = s3c_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);\r\nhsotg->ep0_reply = req;\r\nif (!req) {\r\ndev_warn(hsotg->dev, "%s: cannot alloc req\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreq->buf = hsotg->ep0_buff;\r\nreq->length = length;\r\nreq->zero = 1;\r\nreq->complete = s3c_hsotg_complete_oursetup;\r\nif (length)\r\nmemcpy(req->buf, buff, length);\r\nelse\r\nep->sent_zlp = 1;\r\nret = s3c_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);\r\nif (ret) {\r\ndev_warn(hsotg->dev, "%s: cannot queue req\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_process_req_status(struct s3c_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = &hsotg->eps[0];\r\nstruct s3c_hsotg_ep *ep;\r\n__le16 reply;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: USB_REQ_GET_STATUS\n", __func__);\r\nif (!ep0->dir_in) {\r\ndev_warn(hsotg->dev, "%s: direction out?\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));\r\nif (!ep)\r\nreturn -ENOENT;\r\nreply = cpu_to_le16(ep->halted ? 1 : 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (le16_to_cpu(ctrl->wLength) != 2)\r\nreturn -EINVAL;\r\nret = s3c_hsotg_send_reply(hsotg, ep0, &reply, 2);\r\nif (ret) {\r\ndev_err(hsotg->dev, "%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct s3c_hsotg_req *get_ep_head(struct s3c_hsotg_ep *hs_ep)\r\n{\r\nif (list_empty(&hs_ep->queue))\r\nreturn NULL;\r\nreturn list_first_entry(&hs_ep->queue, struct s3c_hsotg_req, queue);\r\n}\r\nstatic int s3c_hsotg_process_req_feature(struct s3c_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = &hsotg->eps[0];\r\nstruct s3c_hsotg_req *hs_req;\r\nbool restart;\r\nbool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);\r\nstruct s3c_hsotg_ep *ep;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: %s_FEATURE\n",\r\n__func__, set ? "SET" : "CLEAR");\r\nif (ctrl->bRequestType == USB_RECIP_ENDPOINT) {\r\nep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));\r\nif (!ep) {\r\ndev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",\r\n__func__, le16_to_cpu(ctrl->wIndex));\r\nreturn -ENOENT;\r\n}\r\nswitch (le16_to_cpu(ctrl->wValue)) {\r\ncase USB_ENDPOINT_HALT:\r\ns3c_hsotg_ep_sethalt(&ep->ep, set);\r\nret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nif (ret) {\r\ndev_err(hsotg->dev,\r\n"%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nif (!set) {\r\nif (ep->req) {\r\nhs_req = ep->req;\r\nep->req = NULL;\r\nlist_del_init(&hs_req->queue);\r\nhs_req->req.complete(&ep->ep,\r\n&hs_req->req);\r\n}\r\nrestart = !list_empty(&ep->queue);\r\nif (restart) {\r\nhs_req = get_ep_head(ep);\r\ns3c_hsotg_start_req(hsotg, ep,\r\nhs_req, false);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\n} else\r\nreturn -ENOENT;\r\nreturn 1;\r\n}\r\nstatic void s3c_hsotg_process_control(struct s3c_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = &hsotg->eps[0];\r\nint ret = 0;\r\nu32 dcfg;\r\nep0->sent_zlp = 0;\r\ndev_dbg(hsotg->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",\r\nctrl->bRequest, ctrl->bRequestType,\r\nctrl->wValue, ctrl->wLength);\r\nep0->dir_in = (ctrl->bRequestType & USB_DIR_IN) ? 1 : 0;\r\ndev_dbg(hsotg->dev, "ctrl: dir_in=%d\n", ep0->dir_in);\r\nif (ctrl->wLength == 0)\r\nep0->dir_in = 1;\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\ndcfg = readl(hsotg->regs + DCFG);\r\ndcfg &= ~DCFG_DevAddr_MASK;\r\ndcfg |= ctrl->wValue << DCFG_DevAddr_SHIFT;\r\nwritel(dcfg, hsotg->regs + DCFG);\r\ndev_info(hsotg->dev, "new address %d\n", ctrl->wValue);\r\nret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nreturn;\r\ncase USB_REQ_GET_STATUS:\r\nret = s3c_hsotg_process_req_status(hsotg, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nret = s3c_hsotg_process_req_feature(hsotg, ctrl);\r\nbreak;\r\n}\r\n}\r\nif (ret == 0 && hsotg->driver) {\r\nret = hsotg->driver->setup(&hsotg->gadget, ctrl);\r\nif (ret < 0)\r\ndev_dbg(hsotg->dev, "driver->setup() ret %d\n", ret);\r\n}\r\nif (ret < 0) {\r\nu32 reg;\r\nu32 ctrl;\r\ndev_dbg(hsotg->dev, "ep0 stall (dir=%d)\n", ep0->dir_in);\r\nreg = (ep0->dir_in) ? DIEPCTL0 : DOEPCTL0;\r\nctrl = readl(hsotg->regs + reg);\r\nctrl |= DxEPCTL_Stall;\r\nctrl |= DxEPCTL_CNAK;\r\nwritel(ctrl, hsotg->regs + reg);\r\ndev_dbg(hsotg->dev,\r\n"written DxEPCTL=0x%08x to %08x (DxEPCTL=0x%08x)\n",\r\nctrl, reg, readl(hsotg->regs + reg));\r\n}\r\n}\r\nstatic void s3c_hsotg_complete_setup(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hsotg = hs_ep->parent;\r\nif (req->status < 0) {\r\ndev_dbg(hsotg->dev, "%s: failed %d\n", __func__, req->status);\r\nreturn;\r\n}\r\nif (req->actual == 0)\r\ns3c_hsotg_enqueue_setup(hsotg);\r\nelse\r\ns3c_hsotg_process_control(hsotg, req->buf);\r\n}\r\nstatic void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg)\r\n{\r\nstruct usb_request *req = hsotg->ctrl_req;\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: queueing setup request\n", __func__);\r\nreq->zero = 0;\r\nreq->length = 8;\r\nreq->buf = hsotg->ctrl_buff;\r\nreq->complete = s3c_hsotg_complete_setup;\r\nif (!list_empty(&hs_req->queue)) {\r\ndev_dbg(hsotg->dev, "%s already queued???\n", __func__);\r\nreturn;\r\n}\r\nhsotg->eps[0].dir_in = 0;\r\nret = s3c_hsotg_ep_queue(&hsotg->eps[0].ep, req, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);\r\n}\r\n}\r\nstatic void s3c_hsotg_complete_request(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req,\r\nint result)\r\n{\r\nbool restart;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "%s: nothing to complete?\n", __func__);\r\nreturn;\r\n}\r\ndev_dbg(hsotg->dev, "complete: ep %p %s, req %p, %d => %p\n",\r\nhs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);\r\nif (hs_req->req.status == -EINPROGRESS)\r\nhs_req->req.status = result;\r\nhs_ep->req = NULL;\r\nlist_del_init(&hs_req->queue);\r\nif (using_dma(hsotg))\r\ns3c_hsotg_unmap_dma(hsotg, hs_ep, hs_req);\r\nif (hs_req->req.complete) {\r\nspin_unlock(&hsotg->lock);\r\nhs_req->req.complete(&hs_ep->ep, &hs_req->req);\r\nspin_lock(&hsotg->lock);\r\n}\r\nif (!hs_ep->req && result >= 0) {\r\nrestart = !list_empty(&hs_ep->queue);\r\nif (restart) {\r\nhs_req = get_ep_head(hs_ep);\r\ns3c_hsotg_start_req(hsotg, hs_ep, hs_req, false);\r\n}\r\n}\r\n}\r\nstatic void s3c_hsotg_rx_data(struct s3c_hsotg *hsotg, int ep_idx, int size)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = &hsotg->eps[ep_idx];\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nvoid __iomem *fifo = hsotg->regs + EPFIFO(ep_idx);\r\nint to_read;\r\nint max_req;\r\nint read_ptr;\r\nif (!hs_req) {\r\nu32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));\r\nint ptr;\r\ndev_warn(hsotg->dev,\r\n"%s: FIFO %d bytes on ep%d but no req (DxEPCTl=0x%08x)\n",\r\n__func__, size, ep_idx, epctl);\r\nfor (ptr = 0; ptr < size; ptr += 4)\r\n(void)readl(fifo);\r\nreturn;\r\n}\r\nto_read = size;\r\nread_ptr = hs_req->req.actual;\r\nmax_req = hs_req->req.length - read_ptr;\r\ndev_dbg(hsotg->dev, "%s: read %d/%d, done %d/%d\n",\r\n__func__, to_read, max_req, read_ptr, hs_req->req.length);\r\nif (to_read > max_req) {\r\nWARN_ON_ONCE(1);\r\n}\r\nhs_ep->total_data += to_read;\r\nhs_req->req.actual += to_read;\r\nto_read = DIV_ROUND_UP(to_read, 4);\r\nreadsl(fifo, hs_req->req.buf + read_ptr, to_read);\r\n}\r\nstatic void s3c_hsotg_send_zlp(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_req *req)\r\n{\r\nu32 ctrl;\r\nif (!req) {\r\ndev_warn(hsotg->dev, "%s: no request?\n", __func__);\r\nreturn;\r\n}\r\nif (req->req.length == 0) {\r\nhsotg->eps[0].sent_zlp = 1;\r\ns3c_hsotg_enqueue_setup(hsotg);\r\nreturn;\r\n}\r\nhsotg->eps[0].dir_in = 1;\r\nhsotg->eps[0].sent_zlp = 1;\r\ndev_dbg(hsotg->dev, "sending zero-length packet\n");\r\nwritel(DxEPTSIZ_MC(1) | DxEPTSIZ_PktCnt(1) |\r\nDxEPTSIZ_XferSize(0), hsotg->regs + DIEPTSIZ(0));\r\nctrl = readl(hsotg->regs + DIEPCTL0);\r\nctrl |= DxEPCTL_CNAK;\r\nctrl |= DxEPCTL_EPEna;\r\nctrl |= DxEPCTL_USBActEp;\r\nwritel(ctrl, hsotg->regs + DIEPCTL0);\r\n}\r\nstatic void s3c_hsotg_handle_outdone(struct s3c_hsotg *hsotg,\r\nint epnum, bool was_setup)\r\n{\r\nu32 epsize = readl(hsotg->regs + DOEPTSIZ(epnum));\r\nstruct s3c_hsotg_ep *hs_ep = &hsotg->eps[epnum];\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nstruct usb_request *req = &hs_req->req;\r\nunsigned size_left = DxEPTSIZ_XferSize_GET(epsize);\r\nint result = 0;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "%s: no request active\n", __func__);\r\nreturn;\r\n}\r\nif (using_dma(hsotg)) {\r\nunsigned size_done;\r\nsize_done = hs_ep->size_loaded - size_left;\r\nsize_done += hs_ep->last_load;\r\nreq->actual = size_done;\r\n}\r\nif (req->actual < req->length && size_left == 0) {\r\ns3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);\r\nreturn;\r\n} else if (epnum == 0) {\r\nhsotg->setup = was_setup ? 0 : 1;\r\n}\r\nif (req->actual < req->length && req->short_not_ok) {\r\ndev_dbg(hsotg->dev, "%s: got %d/%d (short not ok) => error\n",\r\n__func__, req->actual, req->length);\r\n}\r\nif (epnum == 0) {\r\nif (!was_setup && req->complete != s3c_hsotg_complete_setup)\r\ns3c_hsotg_send_zlp(hsotg, hs_req);\r\n}\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);\r\n}\r\nstatic u32 s3c_hsotg_read_frameno(struct s3c_hsotg *hsotg)\r\n{\r\nu32 dsts;\r\ndsts = readl(hsotg->regs + DSTS);\r\ndsts &= DSTS_SOFFN_MASK;\r\ndsts >>= DSTS_SOFFN_SHIFT;\r\nreturn dsts;\r\n}\r\nstatic void s3c_hsotg_handle_rx(struct s3c_hsotg *hsotg)\r\n{\r\nu32 grxstsr = readl(hsotg->regs + GRXSTSP);\r\nu32 epnum, status, size;\r\nWARN_ON(using_dma(hsotg));\r\nepnum = grxstsr & GRXSTS_EPNum_MASK;\r\nstatus = grxstsr & GRXSTS_PktSts_MASK;\r\nsize = grxstsr & GRXSTS_ByteCnt_MASK;\r\nsize >>= GRXSTS_ByteCnt_SHIFT;\r\nif (1)\r\ndev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",\r\n__func__, grxstsr, size, epnum);\r\n#define __status(x) ((x) >> GRXSTS_PktSts_SHIFT)\r\nswitch (status >> GRXSTS_PktSts_SHIFT) {\r\ncase __status(GRXSTS_PktSts_GlobalOutNAK):\r\ndev_dbg(hsotg->dev, "GlobalOutNAK\n");\r\nbreak;\r\ncase __status(GRXSTS_PktSts_OutDone):\r\ndev_dbg(hsotg->dev, "OutDone (Frame=0x%08x)\n",\r\ns3c_hsotg_read_frameno(hsotg));\r\nif (!using_dma(hsotg))\r\ns3c_hsotg_handle_outdone(hsotg, epnum, false);\r\nbreak;\r\ncase __status(GRXSTS_PktSts_SetupDone):\r\ndev_dbg(hsotg->dev,\r\n"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",\r\ns3c_hsotg_read_frameno(hsotg),\r\nreadl(hsotg->regs + DOEPCTL(0)));\r\ns3c_hsotg_handle_outdone(hsotg, epnum, true);\r\nbreak;\r\ncase __status(GRXSTS_PktSts_OutRX):\r\ns3c_hsotg_rx_data(hsotg, epnum, size);\r\nbreak;\r\ncase __status(GRXSTS_PktSts_SetupRX):\r\ndev_dbg(hsotg->dev,\r\n"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",\r\ns3c_hsotg_read_frameno(hsotg),\r\nreadl(hsotg->regs + DOEPCTL(0)));\r\ns3c_hsotg_rx_data(hsotg, epnum, size);\r\nbreak;\r\ndefault:\r\ndev_warn(hsotg->dev, "%s: unknown status %08x\n",\r\n__func__, grxstsr);\r\ns3c_hsotg_dump(hsotg);\r\nbreak;\r\n}\r\n}\r\nstatic u32 s3c_hsotg_ep0_mps(unsigned int mps)\r\n{\r\nswitch (mps) {\r\ncase 64:\r\nreturn D0EPCTL_MPS_64;\r\ncase 32:\r\nreturn D0EPCTL_MPS_32;\r\ncase 16:\r\nreturn D0EPCTL_MPS_16;\r\ncase 8:\r\nreturn D0EPCTL_MPS_8;\r\n}\r\nWARN_ON(1);\r\nreturn (u32)-1;\r\n}\r\nstatic void s3c_hsotg_set_ep_maxpacket(struct s3c_hsotg *hsotg,\r\nunsigned int ep, unsigned int mps)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = &hsotg->eps[ep];\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 mpsval;\r\nu32 reg;\r\nif (ep == 0) {\r\nmpsval = s3c_hsotg_ep0_mps(mps);\r\nif (mpsval > 3)\r\ngoto bad_mps;\r\n} else {\r\nif (mps >= DxEPCTL_MPS_LIMIT+1)\r\ngoto bad_mps;\r\nmpsval = mps;\r\n}\r\nhs_ep->ep.maxpacket = mps;\r\nreg = readl(regs + DIEPCTL(ep));\r\nreg &= ~DxEPCTL_MPS_MASK;\r\nreg |= mpsval;\r\nwritel(reg, regs + DIEPCTL(ep));\r\nif (ep) {\r\nreg = readl(regs + DOEPCTL(ep));\r\nreg &= ~DxEPCTL_MPS_MASK;\r\nreg |= mpsval;\r\nwritel(reg, regs + DOEPCTL(ep));\r\n}\r\nreturn;\r\nbad_mps:\r\ndev_err(hsotg->dev, "ep%d: bad mps of %d\n", ep, mps);\r\n}\r\nstatic void s3c_hsotg_txfifo_flush(struct s3c_hsotg *hsotg, unsigned int idx)\r\n{\r\nint timeout;\r\nint val;\r\nwritel(GRSTCTL_TxFNum(idx) | GRSTCTL_TxFFlsh,\r\nhsotg->regs + GRSTCTL);\r\ntimeout = 100;\r\nwhile (1) {\r\nval = readl(hsotg->regs + GRSTCTL);\r\nif ((val & (GRSTCTL_TxFFlsh)) == 0)\r\nbreak;\r\nif (--timeout == 0) {\r\ndev_err(hsotg->dev,\r\n"%s: timeout flushing fifo (GRSTCTL=%08x)\n",\r\n__func__, val);\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic int s3c_hsotg_trytx(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep)\r\n{\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nif (!hs_ep->dir_in || !hs_req)\r\nreturn 0;\r\nif (hs_req->req.actual < hs_req->req.length) {\r\ndev_dbg(hsotg->dev, "trying to write more for ep%d\n",\r\nhs_ep->index);\r\nreturn s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c_hsotg_complete_in(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep)\r\n{\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nu32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));\r\nint size_left, size_done;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "XferCompl but no req\n");\r\nreturn;\r\n}\r\nif (hsotg->eps[0].sent_zlp) {\r\ndev_dbg(hsotg->dev, "zlp packet received\n");\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\nreturn;\r\n}\r\nsize_left = DxEPTSIZ_XferSize_GET(epsize);\r\nsize_done = hs_ep->size_loaded - size_left;\r\nsize_done += hs_ep->last_load;\r\nif (hs_req->req.actual != size_done)\r\ndev_dbg(hsotg->dev, "%s: adjusting size done %d => %d\n",\r\n__func__, hs_req->req.actual, size_done);\r\nhs_req->req.actual = size_done;\r\ndev_dbg(hsotg->dev, "req->length:%d req->actual:%d req->zero:%d\n",\r\nhs_req->req.length, hs_req->req.actual, hs_req->req.zero);\r\nif (hs_req->req.length && hs_ep->index == 0 && hs_req->req.zero &&\r\nhs_req->req.length == hs_req->req.actual &&\r\n!(hs_req->req.length % hs_ep->ep.maxpacket)) {\r\ndev_dbg(hsotg->dev, "ep0 zlp IN packet sent\n");\r\ns3c_hsotg_send_zlp(hsotg, hs_req);\r\nreturn;\r\n}\r\nif (!size_left && hs_req->req.actual < hs_req->req.length) {\r\ndev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);\r\ns3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);\r\n} else\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\n}\r\nstatic void s3c_hsotg_epint(struct s3c_hsotg *hsotg, unsigned int idx,\r\nint dir_in)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = &hsotg->eps[idx];\r\nu32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);\r\nu32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);\r\nu32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);\r\nu32 ints;\r\nints = readl(hsotg->regs + epint_reg);\r\nwritel(ints, hsotg->regs + epint_reg);\r\ndev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",\r\n__func__, idx, dir_in ? "in" : "out", ints);\r\nif (ints & DxEPINT_XferCompl) {\r\ndev_dbg(hsotg->dev,\r\n"%s: XferCompl: DxEPCTL=0x%08x, DxEPTSIZ=%08x\n",\r\n__func__, readl(hsotg->regs + epctl_reg),\r\nreadl(hsotg->regs + epsiz_reg));\r\nif (dir_in) {\r\ns3c_hsotg_complete_in(hsotg, hs_ep);\r\nif (idx == 0 && !hs_ep->req)\r\ns3c_hsotg_enqueue_setup(hsotg);\r\n} else if (using_dma(hsotg)) {\r\ns3c_hsotg_handle_outdone(hsotg, idx, false);\r\n}\r\n}\r\nif (ints & DxEPINT_EPDisbld) {\r\ndev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);\r\nif (dir_in) {\r\nint epctl = readl(hsotg->regs + epctl_reg);\r\ns3c_hsotg_txfifo_flush(hsotg, idx);\r\nif ((epctl & DxEPCTL_Stall) &&\r\n(epctl & DxEPCTL_EPType_Bulk)) {\r\nint dctl = readl(hsotg->regs + DCTL);\r\ndctl |= DCTL_CGNPInNAK;\r\nwritel(dctl, hsotg->regs + DCTL);\r\n}\r\n}\r\n}\r\nif (ints & DxEPINT_AHBErr)\r\ndev_dbg(hsotg->dev, "%s: AHBErr\n", __func__);\r\nif (ints & DxEPINT_Setup) {\r\ndev_dbg(hsotg->dev, "%s: Setup/Timeout\n", __func__);\r\nif (using_dma(hsotg) && idx == 0) {\r\nif (dir_in)\r\nWARN_ON_ONCE(1);\r\nelse\r\ns3c_hsotg_handle_outdone(hsotg, 0, true);\r\n}\r\n}\r\nif (ints & DxEPINT_Back2BackSetup)\r\ndev_dbg(hsotg->dev, "%s: B2BSetup/INEPNakEff\n", __func__);\r\nif (dir_in) {\r\nif (ints & DIEPMSK_INTknTXFEmpMsk) {\r\ndev_dbg(hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",\r\n__func__, idx);\r\n}\r\nif (ints & DIEPMSK_INTknEPMisMsk) {\r\ndev_warn(hsotg->dev, "%s: ep%d: INTknEP\n",\r\n__func__, idx);\r\n}\r\nif (hsotg->dedicated_fifos &&\r\nints & DIEPMSK_TxFIFOEmpty) {\r\ndev_dbg(hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",\r\n__func__, idx);\r\nif (!using_dma(hsotg))\r\ns3c_hsotg_trytx(hsotg, hs_ep);\r\n}\r\n}\r\n}\r\nstatic void s3c_hsotg_irq_enumdone(struct s3c_hsotg *hsotg)\r\n{\r\nu32 dsts = readl(hsotg->regs + DSTS);\r\nint ep0_mps = 0, ep_mps;\r\ndev_dbg(hsotg->dev, "EnumDone (DSTS=0x%08x)\n", dsts);\r\nswitch (dsts & DSTS_EnumSpd_MASK) {\r\ncase DSTS_EnumSpd_FS:\r\ncase DSTS_EnumSpd_FS48:\r\nhsotg->gadget.speed = USB_SPEED_FULL;\r\nep0_mps = EP0_MPS_LIMIT;\r\nep_mps = 64;\r\nbreak;\r\ncase DSTS_EnumSpd_HS:\r\nhsotg->gadget.speed = USB_SPEED_HIGH;\r\nep0_mps = EP0_MPS_LIMIT;\r\nep_mps = 512;\r\nbreak;\r\ncase DSTS_EnumSpd_LS:\r\nhsotg->gadget.speed = USB_SPEED_LOW;\r\nbreak;\r\n}\r\ndev_info(hsotg->dev, "new device is %s\n",\r\nusb_speed_string(hsotg->gadget.speed));\r\nif (ep0_mps) {\r\nint i;\r\ns3c_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps);\r\nfor (i = 1; i < hsotg->num_of_eps; i++)\r\ns3c_hsotg_set_ep_maxpacket(hsotg, i, ep_mps);\r\n}\r\ns3c_hsotg_enqueue_setup(hsotg);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\nreadl(hsotg->regs + DIEPCTL0),\r\nreadl(hsotg->regs + DOEPCTL0));\r\n}\r\nstatic void kill_all_requests(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *ep,\r\nint result, bool force)\r\n{\r\nstruct s3c_hsotg_req *req, *treq;\r\nlist_for_each_entry_safe(req, treq, &ep->queue, queue) {\r\nif (ep->req == req && ep->dir_in && !force)\r\ncontinue;\r\ns3c_hsotg_complete_request(hsotg, ep, req,\r\nresult);\r\n}\r\n}\r\nstatic void s3c_hsotg_disconnect(struct s3c_hsotg *hsotg)\r\n{\r\nunsigned ep;\r\nfor (ep = 0; ep < hsotg->num_of_eps; ep++)\r\nkill_all_requests(hsotg, &hsotg->eps[ep], -ESHUTDOWN, true);\r\ncall_gadget(hsotg, disconnect);\r\n}\r\nstatic void s3c_hsotg_irq_fifoempty(struct s3c_hsotg *hsotg, bool periodic)\r\n{\r\nstruct s3c_hsotg_ep *ep;\r\nint epno, ret;\r\nfor (epno = 0; epno < hsotg->num_of_eps; epno++) {\r\nep = &hsotg->eps[epno];\r\nif (!ep->dir_in)\r\ncontinue;\r\nif ((periodic && !ep->periodic) ||\r\n(!periodic && ep->periodic))\r\ncontinue;\r\nret = s3c_hsotg_trytx(hsotg, ep);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\nstatic int s3c_hsotg_corereset(struct s3c_hsotg *hsotg)\r\n{\r\nint timeout;\r\nu32 grstctl;\r\ndev_dbg(hsotg->dev, "resetting core\n");\r\nwritel(GRSTCTL_CSftRst, hsotg->regs + GRSTCTL);\r\ntimeout = 10000;\r\ndo {\r\ngrstctl = readl(hsotg->regs + GRSTCTL);\r\n} while ((grstctl & GRSTCTL_CSftRst) && timeout-- > 0);\r\nif (grstctl & GRSTCTL_CSftRst) {\r\ndev_err(hsotg->dev, "Failed to get CSftRst asserted\n");\r\nreturn -EINVAL;\r\n}\r\ntimeout = 10000;\r\nwhile (1) {\r\nu32 grstctl = readl(hsotg->regs + GRSTCTL);\r\nif (timeout-- < 0) {\r\ndev_info(hsotg->dev,\r\n"%s: reset failed, GRSTCTL=%08x\n",\r\n__func__, grstctl);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!(grstctl & GRSTCTL_AHBIdle))\r\ncontinue;\r\nbreak;\r\n}\r\ndev_dbg(hsotg->dev, "reset successful\n");\r\nreturn 0;\r\n}\r\nstatic void s3c_hsotg_core_init(struct s3c_hsotg *hsotg)\r\n{\r\ns3c_hsotg_corereset(hsotg);\r\nwritel(GUSBCFG_PHYIf16 | GUSBCFG_TOutCal(7) |\r\n(0x5 << 10), hsotg->regs + GUSBCFG);\r\ns3c_hsotg_init_fifo(hsotg);\r\n__orr32(hsotg->regs + DCTL, DCTL_SftDiscon);\r\nwritel(1 << 18 | DCFG_DevSpd_HS, hsotg->regs + DCFG);\r\nwritel(0xffffffff, hsotg->regs + GOTGINT);\r\nwritel(0xffffffff, hsotg->regs + GINTSTS);\r\nwritel(GINTSTS_ErlySusp | GINTSTS_SessReqInt |\r\nGINTSTS_GOUTNakEff | GINTSTS_GINNakEff |\r\nGINTSTS_ConIDStsChng | GINTSTS_USBRst |\r\nGINTSTS_EnumDone | GINTSTS_OTGInt |\r\nGINTSTS_USBSusp | GINTSTS_WkUpInt,\r\nhsotg->regs + GINTMSK);\r\nif (using_dma(hsotg))\r\nwritel(GAHBCFG_GlblIntrEn | GAHBCFG_DMAEn |\r\nGAHBCFG_HBstLen_Incr4,\r\nhsotg->regs + GAHBCFG);\r\nelse\r\nwritel(GAHBCFG_GlblIntrEn, hsotg->regs + GAHBCFG);\r\nwritel(((hsotg->dedicated_fifos) ? DIEPMSK_TxFIFOEmpty : 0) |\r\nDIEPMSK_EPDisbldMsk | DIEPMSK_XferComplMsk |\r\nDIEPMSK_TimeOUTMsk | DIEPMSK_AHBErrMsk |\r\nDIEPMSK_INTknEPMisMsk,\r\nhsotg->regs + DIEPMSK);\r\nwritel((using_dma(hsotg) ? (DIEPMSK_XferComplMsk |\r\nDIEPMSK_TimeOUTMsk) : 0) |\r\nDOEPMSK_EPDisbldMsk | DOEPMSK_AHBErrMsk |\r\nDOEPMSK_SetupMsk,\r\nhsotg->regs + DOEPMSK);\r\nwritel(0, hsotg->regs + DAINTMSK);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\nreadl(hsotg->regs + DIEPCTL0),\r\nreadl(hsotg->regs + DOEPCTL0));\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_OEPInt | GINTSTS_IEPInt);\r\nif (!using_dma(hsotg))\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_RxFLvl);\r\ns3c_hsotg_ctrl_epint(hsotg, 0, 0, 1);\r\ns3c_hsotg_ctrl_epint(hsotg, 0, 1, 1);\r\n__orr32(hsotg->regs + DCTL, DCTL_PWROnPrgDone);\r\nudelay(10);\r\n__bic32(hsotg->regs + DCTL, DCTL_PWROnPrgDone);\r\ndev_dbg(hsotg->dev, "DCTL=0x%08x\n", readl(hsotg->regs + DCTL));\r\nwritel(DxEPTSIZ_MC(1) | DxEPTSIZ_PktCnt(1) |\r\nDxEPTSIZ_XferSize(8), hsotg->regs + DOEPTSIZ0);\r\nwritel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |\r\nDxEPCTL_CNAK | DxEPCTL_EPEna |\r\nDxEPCTL_USBActEp,\r\nhsotg->regs + DOEPCTL0);\r\nwritel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |\r\nDxEPCTL_USBActEp, hsotg->regs + DIEPCTL0);\r\ns3c_hsotg_enqueue_setup(hsotg);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\nreadl(hsotg->regs + DIEPCTL0),\r\nreadl(hsotg->regs + DOEPCTL0));\r\nwritel(DCTL_CGOUTNak | DCTL_CGNPInNAK,\r\nhsotg->regs + DCTL);\r\nmdelay(3);\r\n__bic32(hsotg->regs + DCTL, DCTL_SftDiscon);\r\n}\r\nstatic irqreturn_t s3c_hsotg_irq(int irq, void *pw)\r\n{\r\nstruct s3c_hsotg *hsotg = pw;\r\nint retry_count = 8;\r\nu32 gintsts;\r\nu32 gintmsk;\r\nspin_lock(&hsotg->lock);\r\nirq_retry:\r\ngintsts = readl(hsotg->regs + GINTSTS);\r\ngintmsk = readl(hsotg->regs + GINTMSK);\r\ndev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",\r\n__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);\r\ngintsts &= gintmsk;\r\nif (gintsts & GINTSTS_OTGInt) {\r\nu32 otgint = readl(hsotg->regs + GOTGINT);\r\ndev_info(hsotg->dev, "OTGInt: %08x\n", otgint);\r\nwritel(otgint, hsotg->regs + GOTGINT);\r\n}\r\nif (gintsts & GINTSTS_SessReqInt) {\r\ndev_dbg(hsotg->dev, "%s: SessReqInt\n", __func__);\r\nwritel(GINTSTS_SessReqInt, hsotg->regs + GINTSTS);\r\n}\r\nif (gintsts & GINTSTS_EnumDone) {\r\nwritel(GINTSTS_EnumDone, hsotg->regs + GINTSTS);\r\ns3c_hsotg_irq_enumdone(hsotg);\r\n}\r\nif (gintsts & GINTSTS_ConIDStsChng) {\r\ndev_dbg(hsotg->dev, "ConIDStsChg (DSTS=0x%08x, GOTCTL=%08x)\n",\r\nreadl(hsotg->regs + DSTS),\r\nreadl(hsotg->regs + GOTGCTL));\r\nwritel(GINTSTS_ConIDStsChng, hsotg->regs + GINTSTS);\r\n}\r\nif (gintsts & (GINTSTS_OEPInt | GINTSTS_IEPInt)) {\r\nu32 daint = readl(hsotg->regs + DAINT);\r\nu32 daint_out = daint >> DAINT_OutEP_SHIFT;\r\nu32 daint_in = daint & ~(daint_out << DAINT_OutEP_SHIFT);\r\nint ep;\r\ndev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);\r\nfor (ep = 0; ep < 15 && daint_out; ep++, daint_out >>= 1) {\r\nif (daint_out & 1)\r\ns3c_hsotg_epint(hsotg, ep, 0);\r\n}\r\nfor (ep = 0; ep < 15 && daint_in; ep++, daint_in >>= 1) {\r\nif (daint_in & 1)\r\ns3c_hsotg_epint(hsotg, ep, 1);\r\n}\r\n}\r\nif (gintsts & GINTSTS_USBRst) {\r\nu32 usb_status = readl(hsotg->regs + GOTGCTL);\r\ndev_info(hsotg->dev, "%s: USBRst\n", __func__);\r\ndev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",\r\nreadl(hsotg->regs + GNPTXSTS));\r\nwritel(GINTSTS_USBRst, hsotg->regs + GINTSTS);\r\nif (usb_status & GOTGCTL_BSESVLD) {\r\nif (time_after(jiffies, hsotg->last_rst +\r\nmsecs_to_jiffies(200))) {\r\nkill_all_requests(hsotg, &hsotg->eps[0],\r\n-ECONNRESET, true);\r\ns3c_hsotg_core_init(hsotg);\r\nhsotg->last_rst = jiffies;\r\n}\r\n}\r\n}\r\nif (gintsts & GINTSTS_NPTxFEmp) {\r\ndev_dbg(hsotg->dev, "NPTxFEmp\n");\r\ns3c_hsotg_disable_gsint(hsotg, GINTSTS_NPTxFEmp);\r\ns3c_hsotg_irq_fifoempty(hsotg, false);\r\n}\r\nif (gintsts & GINTSTS_PTxFEmp) {\r\ndev_dbg(hsotg->dev, "PTxFEmp\n");\r\ns3c_hsotg_disable_gsint(hsotg, GINTSTS_PTxFEmp);\r\ns3c_hsotg_irq_fifoempty(hsotg, true);\r\n}\r\nif (gintsts & GINTSTS_RxFLvl) {\r\ns3c_hsotg_handle_rx(hsotg);\r\n}\r\nif (gintsts & GINTSTS_ModeMis) {\r\ndev_warn(hsotg->dev, "warning, mode mismatch triggered\n");\r\nwritel(GINTSTS_ModeMis, hsotg->regs + GINTSTS);\r\n}\r\nif (gintsts & GINTSTS_USBSusp) {\r\ndev_info(hsotg->dev, "GINTSTS_USBSusp\n");\r\nwritel(GINTSTS_USBSusp, hsotg->regs + GINTSTS);\r\ncall_gadget(hsotg, suspend);\r\ns3c_hsotg_disconnect(hsotg);\r\n}\r\nif (gintsts & GINTSTS_WkUpInt) {\r\ndev_info(hsotg->dev, "GINTSTS_WkUpIn\n");\r\nwritel(GINTSTS_WkUpInt, hsotg->regs + GINTSTS);\r\ncall_gadget(hsotg, resume);\r\n}\r\nif (gintsts & GINTSTS_ErlySusp) {\r\ndev_dbg(hsotg->dev, "GINTSTS_ErlySusp\n");\r\nwritel(GINTSTS_ErlySusp, hsotg->regs + GINTSTS);\r\ns3c_hsotg_disconnect(hsotg);\r\n}\r\nif (gintsts & GINTSTS_GOUTNakEff) {\r\ndev_info(hsotg->dev, "GOUTNakEff triggered\n");\r\nwritel(DCTL_CGOUTNak, hsotg->regs + DCTL);\r\ns3c_hsotg_dump(hsotg);\r\n}\r\nif (gintsts & GINTSTS_GINNakEff) {\r\ndev_info(hsotg->dev, "GINNakEff triggered\n");\r\nwritel(DCTL_CGNPInNAK, hsotg->regs + DCTL);\r\ns3c_hsotg_dump(hsotg);\r\n}\r\nif (gintsts & IRQ_RETRY_MASK && --retry_count > 0)\r\ngoto irq_retry;\r\nspin_unlock(&hsotg->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_hsotg_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hsotg = hs_ep->parent;\r\nunsigned long flags;\r\nint index = hs_ep->index;\r\nu32 epctrl_reg;\r\nu32 epctrl;\r\nu32 mps;\r\nint dir_in;\r\nint ret = 0;\r\ndev_dbg(hsotg->dev,\r\n"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",\r\n__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,\r\ndesc->wMaxPacketSize, desc->bInterval);\r\nWARN_ON(index == 0);\r\ndir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;\r\nif (dir_in != hs_ep->dir_in) {\r\ndev_err(hsotg->dev, "%s: direction mismatch!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmps = usb_endpoint_maxp(desc);\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nepctrl = readl(hsotg->regs + epctrl_reg);\r\ndev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",\r\n__func__, epctrl, epctrl_reg);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nepctrl &= ~(DxEPCTL_EPType_MASK | DxEPCTL_MPS_MASK);\r\nepctrl |= DxEPCTL_MPS(mps);\r\nepctrl |= DxEPCTL_USBActEp;\r\nepctrl |= DxEPCTL_SNAK;\r\nhs_ep->ep.maxpacket = mps;\r\nhs_ep->periodic = 0;\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ndev_err(hsotg->dev, "no current ISOC support\n");\r\nret = -EINVAL;\r\ngoto out;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nepctrl |= DxEPCTL_EPType_Bulk;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (dir_in) {\r\nhs_ep->periodic = 1;\r\nepctrl |= DxEPCTL_TxFNum(index);\r\n}\r\nepctrl |= DxEPCTL_EPType_Intterupt;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nepctrl |= DxEPCTL_EPType_Control;\r\nbreak;\r\n}\r\nif (dir_in && hsotg->dedicated_fifos)\r\nepctrl |= DxEPCTL_TxFNum(index);\r\nif (index)\r\nepctrl |= DxEPCTL_SetD0PID;\r\ndev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",\r\n__func__, epctrl);\r\nwritel(epctrl, hsotg->regs + epctrl_reg);\r\ndev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",\r\n__func__, readl(hsotg->regs + epctrl_reg));\r\ns3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);\r\nout:\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int s3c_hsotg_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hsotg = hs_ep->parent;\r\nint dir_in = hs_ep->dir_in;\r\nint index = hs_ep->index;\r\nunsigned long flags;\r\nu32 epctrl_reg;\r\nu32 ctrl;\r\ndev_info(hsotg->dev, "%s(ep %p)\n", __func__, ep);\r\nif (ep == &hsotg->eps[0].ep) {\r\ndev_err(hsotg->dev, "%s: called for ep0\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nkill_all_requests(hsotg, hs_ep, -ESHUTDOWN, false);\r\nctrl = readl(hsotg->regs + epctrl_reg);\r\nctrl &= ~DxEPCTL_EPEna;\r\nctrl &= ~DxEPCTL_USBActEp;\r\nctrl |= DxEPCTL_SNAK;\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);\r\nwritel(ctrl, hsotg->regs + epctrl_reg);\r\ns3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic bool on_list(struct s3c_hsotg_ep *ep, struct s3c_hsotg_req *test)\r\n{\r\nstruct s3c_hsotg_req *req, *treq;\r\nlist_for_each_entry_safe(req, treq, &ep->queue, queue) {\r\nif (req == test)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int s3c_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hs = hs_ep->parent;\r\nunsigned long flags;\r\ndev_info(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);\r\nspin_lock_irqsave(&hs->lock, flags);\r\nif (!on_list(hs_ep, hs_req)) {\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ns3c_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hs = hs_ep->parent;\r\nint index = hs_ep->index;\r\nu32 epreg;\r\nu32 epctl;\r\nu32 xfertype;\r\ndev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);\r\nepreg = DIEPCTL(index);\r\nepctl = readl(hs->regs + epreg);\r\nif (value) {\r\nepctl |= DxEPCTL_Stall + DxEPCTL_SNAK;\r\nif (epctl & DxEPCTL_EPEna)\r\nepctl |= DxEPCTL_EPDis;\r\n} else {\r\nepctl &= ~DxEPCTL_Stall;\r\nxfertype = epctl & DxEPCTL_EPType_MASK;\r\nif (xfertype == DxEPCTL_EPType_Bulk ||\r\nxfertype == DxEPCTL_EPType_Intterupt)\r\nepctl |= DxEPCTL_SetD0PID;\r\n}\r\nwritel(epctl, hs->regs + epreg);\r\nepreg = DOEPCTL(index);\r\nepctl = readl(hs->regs + epreg);\r\nif (value)\r\nepctl |= DxEPCTL_Stall;\r\nelse {\r\nepctl &= ~DxEPCTL_Stall;\r\nxfertype = epctl & DxEPCTL_EPType_MASK;\r\nif (xfertype == DxEPCTL_EPType_Bulk ||\r\nxfertype == DxEPCTL_EPType_Intterupt)\r\nepctl |= DxEPCTL_SetD0PID;\r\n}\r\nwritel(epctl, hs->regs + epreg);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct s3c_hsotg *hs = hs_ep->parent;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&hs->lock, flags);\r\nret = s3c_hsotg_ep_sethalt(ep, value);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void s3c_hsotg_phy_enable(struct s3c_hsotg *hsotg)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hsotg->dev);\r\ndev_dbg(hsotg->dev, "pdev 0x%p\n", pdev);\r\nif (hsotg->phy)\r\nusb_phy_init(hsotg->phy);\r\nelse if (hsotg->plat->phy_init)\r\nhsotg->plat->phy_init(pdev, hsotg->plat->phy_type);\r\n}\r\nstatic void s3c_hsotg_phy_disable(struct s3c_hsotg *hsotg)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hsotg->dev);\r\nif (hsotg->phy)\r\nusb_phy_shutdown(hsotg->phy);\r\nelse if (hsotg->plat->phy_exit)\r\nhsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);\r\n}\r\nstatic void s3c_hsotg_init(struct s3c_hsotg *hsotg)\r\n{\r\nwritel(DIEPMSK_TimeOUTMsk | DIEPMSK_AHBErrMsk |\r\nDIEPMSK_EPDisbldMsk | DIEPMSK_XferComplMsk,\r\nhsotg->regs + DIEPMSK);\r\nwritel(DOEPMSK_SetupMsk | DOEPMSK_AHBErrMsk |\r\nDOEPMSK_EPDisbldMsk | DOEPMSK_XferComplMsk,\r\nhsotg->regs + DOEPMSK);\r\nwritel(0, hsotg->regs + DAINTMSK);\r\n__orr32(hsotg->regs + DCTL, DCTL_SftDiscon);\r\nif (0) {\r\nwritel(DCTL_SGNPInNAK | DCTL_SGOUTNak,\r\nhsotg->regs + DCTL);\r\n}\r\ndev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",\r\nreadl(hsotg->regs + GRXFSIZ),\r\nreadl(hsotg->regs + GNPTXFSIZ));\r\ns3c_hsotg_init_fifo(hsotg);\r\nwritel(GUSBCFG_PHYIf16 | GUSBCFG_TOutCal(7) | (0x5 << 10),\r\nhsotg->regs + GUSBCFG);\r\nwritel(using_dma(hsotg) ? GAHBCFG_DMAEn : 0x0,\r\nhsotg->regs + GAHBCFG);\r\n}\r\nstatic int s3c_hsotg_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct s3c_hsotg *hsotg = to_hsotg(gadget);\r\nint ret;\r\nif (!hsotg) {\r\nprintk(KERN_ERR "%s: called with no device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!driver) {\r\ndev_err(hsotg->dev, "%s: no driver\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (driver->max_speed < USB_SPEED_FULL)\r\ndev_err(hsotg->dev, "%s: bad speed\n", __func__);\r\nif (!driver->setup) {\r\ndev_err(hsotg->dev, "%s: missing entry points\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(hsotg->driver);\r\ndriver->driver.bus = NULL;\r\nhsotg->driver = driver;\r\nhsotg->gadget.dev.of_node = hsotg->dev->of_node;\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);\r\ngoto err;\r\n}\r\nhsotg->last_rst = jiffies;\r\ndev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);\r\nreturn 0;\r\nerr:\r\nhsotg->driver = NULL;\r\nreturn ret;\r\n}\r\nstatic int s3c_hsotg_udc_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct s3c_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags = 0;\r\nint ep;\r\nif (!hsotg)\r\nreturn -ENODEV;\r\nif (!driver || driver != hsotg->driver || !driver->unbind)\r\nreturn -EINVAL;\r\nfor (ep = 0; ep < hsotg->num_of_eps; ep++)\r\ns3c_hsotg_ep_disable(&hsotg->eps[ep].ep);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ns3c_hsotg_phy_disable(hsotg);\r\nregulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);\r\nhsotg->driver = NULL;\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\ndev_info(hsotg->dev, "unregistered gadget driver '%s'\n",\r\ndriver->driver.name);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_gadget_getframe(struct usb_gadget *gadget)\r\n{\r\nreturn s3c_hsotg_read_frameno(to_hsotg(gadget));\r\n}\r\nstatic int s3c_hsotg_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct s3c_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags = 0;\r\ndev_dbg(hsotg->dev, "%s: is_in: %d\n", __func__, is_on);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (is_on) {\r\ns3c_hsotg_phy_enable(hsotg);\r\ns3c_hsotg_core_init(hsotg);\r\n} else {\r\ns3c_hsotg_disconnect(hsotg);\r\ns3c_hsotg_phy_disable(hsotg);\r\n}\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void s3c_hsotg_initep(struct s3c_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nint epnum)\r\n{\r\nu32 ptxfifo;\r\nchar *dir;\r\nif (epnum == 0)\r\ndir = "";\r\nelse if ((epnum % 2) == 0) {\r\ndir = "out";\r\n} else {\r\ndir = "in";\r\nhs_ep->dir_in = 1;\r\n}\r\nhs_ep->index = epnum;\r\nsnprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);\r\nINIT_LIST_HEAD(&hs_ep->queue);\r\nINIT_LIST_HEAD(&hs_ep->ep.ep_list);\r\nif (epnum)\r\nlist_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);\r\nhs_ep->parent = hsotg;\r\nhs_ep->ep.name = hs_ep->name;\r\nhs_ep->ep.maxpacket = epnum ? 512 : EP0_MPS_LIMIT;\r\nhs_ep->ep.ops = &s3c_hsotg_ep_ops;\r\nptxfifo = readl(hsotg->regs + DPTXFSIZn(epnum));\r\nhs_ep->fifo_size = DPTXFSIZn_DPTxFSize_GET(ptxfifo) * 4;\r\nif (using_dma(hsotg)) {\r\nu32 next = DxEPCTL_NextEp((epnum + 1) % 15);\r\nwritel(next, hsotg->regs + DIEPCTL(epnum));\r\nwritel(next, hsotg->regs + DOEPCTL(epnum));\r\n}\r\n}\r\nstatic void s3c_hsotg_hw_cfg(struct s3c_hsotg *hsotg)\r\n{\r\nu32 cfg2, cfg4;\r\ncfg2 = readl(hsotg->regs + 0x48);\r\nhsotg->num_of_eps = (cfg2 >> 10) & 0xF;\r\ndev_info(hsotg->dev, "EPs:%d\n", hsotg->num_of_eps);\r\ncfg4 = readl(hsotg->regs + 0x50);\r\nhsotg->dedicated_fifos = (cfg4 >> 25) & 1;\r\ndev_info(hsotg->dev, "%s fifos\n",\r\nhsotg->dedicated_fifos ? "dedicated" : "shared");\r\n}\r\nstatic void s3c_hsotg_dump(struct s3c_hsotg *hsotg)\r\n{\r\n#ifdef DEBUG\r\nstruct device *dev = hsotg->dev;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 val;\r\nint idx;\r\ndev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",\r\nreadl(regs + DCFG), readl(regs + DCTL),\r\nreadl(regs + DIEPMSK));\r\ndev_info(dev, "GAHBCFG=0x%08x, 0x44=0x%08x\n",\r\nreadl(regs + GAHBCFG), readl(regs + 0x44));\r\ndev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",\r\nreadl(regs + GRXFSIZ), readl(regs + GNPTXFSIZ));\r\nfor (idx = 1; idx <= 15; idx++) {\r\nval = readl(regs + DPTXFSIZn(idx));\r\ndev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,\r\nval >> DPTXFSIZn_DPTxFSize_SHIFT,\r\nval & DPTXFSIZn_DPTxFStAddr_MASK);\r\n}\r\nfor (idx = 0; idx < 15; idx++) {\r\ndev_info(dev,\r\n"ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,\r\nreadl(regs + DIEPCTL(idx)),\r\nreadl(regs + DIEPTSIZ(idx)),\r\nreadl(regs + DIEPDMA(idx)));\r\nval = readl(regs + DOEPCTL(idx));\r\ndev_info(dev,\r\n"ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",\r\nidx, readl(regs + DOEPCTL(idx)),\r\nreadl(regs + DOEPTSIZ(idx)),\r\nreadl(regs + DOEPDMA(idx)));\r\n}\r\ndev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",\r\nreadl(regs + DVBUSDIS), readl(regs + DVBUSPULSE));\r\n#endif\r\n}\r\nstatic int state_show(struct seq_file *seq, void *v)\r\n{\r\nstruct s3c_hsotg *hsotg = seq->private;\r\nvoid __iomem *regs = hsotg->regs;\r\nint idx;\r\nseq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",\r\nreadl(regs + DCFG),\r\nreadl(regs + DCTL),\r\nreadl(regs + DSTS));\r\nseq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",\r\nreadl(regs + DIEPMSK), readl(regs + DOEPMSK));\r\nseq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",\r\nreadl(regs + GINTMSK),\r\nreadl(regs + GINTSTS));\r\nseq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",\r\nreadl(regs + DAINTMSK),\r\nreadl(regs + DAINT));\r\nseq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",\r\nreadl(regs + GNPTXSTS),\r\nreadl(regs + GRXSTSR));\r\nseq_printf(seq, "\nEndpoint status:\n");\r\nfor (idx = 0; idx < 15; idx++) {\r\nu32 in, out;\r\nin = readl(regs + DIEPCTL(idx));\r\nout = readl(regs + DOEPCTL(idx));\r\nseq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",\r\nidx, in, out);\r\nin = readl(regs + DIEPTSIZ(idx));\r\nout = readl(regs + DOEPTSIZ(idx));\r\nseq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",\r\nin, out);\r\nseq_printf(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int state_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, state_show, inode->i_private);\r\n}\r\nstatic int fifo_show(struct seq_file *seq, void *v)\r\n{\r\nstruct s3c_hsotg *hsotg = seq->private;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 val;\r\nint idx;\r\nseq_printf(seq, "Non-periodic FIFOs:\n");\r\nseq_printf(seq, "RXFIFO: Size %d\n", readl(regs + GRXFSIZ));\r\nval = readl(regs + GNPTXFSIZ);\r\nseq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",\r\nval >> GNPTXFSIZ_NPTxFDep_SHIFT,\r\nval & GNPTXFSIZ_NPTxFStAddr_MASK);\r\nseq_printf(seq, "\nPeriodic TXFIFOs:\n");\r\nfor (idx = 1; idx <= 15; idx++) {\r\nval = readl(regs + DPTXFSIZn(idx));\r\nseq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,\r\nval >> DPTXFSIZn_DPTxFSize_SHIFT,\r\nval & DPTXFSIZn_DPTxFStAddr_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fifo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fifo_show, inode->i_private);\r\n}\r\nstatic const char *decode_direction(int is_in)\r\n{\r\nreturn is_in ? "in" : "out";\r\n}\r\nstatic int ep_show(struct seq_file *seq, void *v)\r\n{\r\nstruct s3c_hsotg_ep *ep = seq->private;\r\nstruct s3c_hsotg *hsotg = ep->parent;\r\nstruct s3c_hsotg_req *req;\r\nvoid __iomem *regs = hsotg->regs;\r\nint index = ep->index;\r\nint show_limit = 15;\r\nunsigned long flags;\r\nseq_printf(seq, "Endpoint index %d, named %s, dir %s:\n",\r\nep->index, ep->ep.name, decode_direction(ep->dir_in));\r\nseq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",\r\nreadl(regs + DIEPCTL(index)),\r\nreadl(regs + DOEPCTL(index)));\r\nseq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",\r\nreadl(regs + DIEPDMA(index)),\r\nreadl(regs + DOEPDMA(index)));\r\nseq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",\r\nreadl(regs + DIEPINT(index)),\r\nreadl(regs + DOEPINT(index)));\r\nseq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",\r\nreadl(regs + DIEPTSIZ(index)),\r\nreadl(regs + DOEPTSIZ(index)));\r\nseq_printf(seq, "\n");\r\nseq_printf(seq, "mps %d\n", ep->ep.maxpacket);\r\nseq_printf(seq, "total_data=%ld\n", ep->total_data);\r\nseq_printf(seq, "request list (%p,%p):\n",\r\nep->queue.next, ep->queue.prev);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (--show_limit < 0) {\r\nseq_printf(seq, "not showing more requests...\n");\r\nbreak;\r\n}\r\nseq_printf(seq, "%c req %p: %d bytes @%p, ",\r\nreq == ep->req ? '*' : ' ',\r\nreq, req->req.length, req->req.buf);\r\nseq_printf(seq, "%d done, res %d\n",\r\nreq->req.actual, req->req.status);\r\n}\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ep_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ep_show, inode->i_private);\r\n}\r\nstatic void s3c_hsotg_create_debug(struct s3c_hsotg *hsotg)\r\n{\r\nstruct dentry *root;\r\nunsigned epidx;\r\nroot = debugfs_create_dir(dev_name(hsotg->dev), NULL);\r\nhsotg->debug_root = root;\r\nif (IS_ERR(root)) {\r\ndev_err(hsotg->dev, "cannot create debug root\n");\r\nreturn;\r\n}\r\nhsotg->debug_file = debugfs_create_file("state", 0444, root,\r\nhsotg, &state_fops);\r\nif (IS_ERR(hsotg->debug_file))\r\ndev_err(hsotg->dev, "%s: failed to create state\n", __func__);\r\nhsotg->debug_fifo = debugfs_create_file("fifo", 0444, root,\r\nhsotg, &fifo_fops);\r\nif (IS_ERR(hsotg->debug_fifo))\r\ndev_err(hsotg->dev, "%s: failed to create fifo\n", __func__);\r\nfor (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {\r\nstruct s3c_hsotg_ep *ep = &hsotg->eps[epidx];\r\nep->debugfs = debugfs_create_file(ep->name, 0444,\r\nroot, ep, &ep_fops);\r\nif (IS_ERR(ep->debugfs))\r\ndev_err(hsotg->dev, "failed to create %s debug file\n",\r\nep->name);\r\n}\r\n}\r\nstatic void s3c_hsotg_delete_debug(struct s3c_hsotg *hsotg)\r\n{\r\nunsigned epidx;\r\nfor (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {\r\nstruct s3c_hsotg_ep *ep = &hsotg->eps[epidx];\r\ndebugfs_remove(ep->debugfs);\r\n}\r\ndebugfs_remove(hsotg->debug_file);\r\ndebugfs_remove(hsotg->debug_fifo);\r\ndebugfs_remove(hsotg->debug_root);\r\n}\r\nstatic int s3c_hsotg_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_hsotg_plat *plat = pdev->dev.platform_data;\r\nstruct usb_phy *phy;\r\nstruct device *dev = &pdev->dev;\r\nstruct s3c_hsotg_ep *eps;\r\nstruct s3c_hsotg *hsotg;\r\nstruct resource *res;\r\nint epnum;\r\nint ret;\r\nint i;\r\nhsotg = devm_kzalloc(&pdev->dev, sizeof(struct s3c_hsotg), GFP_KERNEL);\r\nif (!hsotg) {\r\ndev_err(dev, "cannot get memory\n");\r\nreturn -ENOMEM;\r\n}\r\nphy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(phy)) {\r\nplat = pdev->dev.platform_data;\r\nif (!plat) {\r\ndev_err(&pdev->dev, "no platform data or transceiver defined\n");\r\nreturn -EPROBE_DEFER;\r\n} else {\r\nhsotg->plat = plat;\r\n}\r\n} else {\r\nhsotg->phy = phy;\r\n}\r\nhsotg->dev = dev;\r\nhsotg->clk = devm_clk_get(&pdev->dev, "otg");\r\nif (IS_ERR(hsotg->clk)) {\r\ndev_err(dev, "cannot get otg clock\n");\r\nreturn PTR_ERR(hsotg->clk);\r\n}\r\nplatform_set_drvdata(pdev, hsotg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhsotg->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hsotg->regs)) {\r\nret = PTR_ERR(hsotg->regs);\r\ngoto err_clk;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot find IRQ\n");\r\ngoto err_clk;\r\n}\r\nspin_lock_init(&hsotg->lock);\r\nhsotg->irq = ret;\r\nret = devm_request_irq(&pdev->dev, hsotg->irq, s3c_hsotg_irq, 0,\r\ndev_name(dev), hsotg);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot claim IRQ\n");\r\ngoto err_clk;\r\n}\r\ndev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);\r\nhsotg->gadget.max_speed = USB_SPEED_HIGH;\r\nhsotg->gadget.ops = &s3c_hsotg_gadget_ops;\r\nhsotg->gadget.name = dev_name(dev);\r\nclk_prepare_enable(hsotg->clk);\r\nfor (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)\r\nhsotg->supplies[i].supply = s3c_hsotg_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to request supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);\r\ngoto err_supplies;\r\n}\r\ns3c_hsotg_phy_enable(hsotg);\r\ns3c_hsotg_corereset(hsotg);\r\ns3c_hsotg_init(hsotg);\r\ns3c_hsotg_hw_cfg(hsotg);\r\nif (hsotg->num_of_eps == 0) {\r\ndev_err(dev, "wrong number of EPs (zero)\n");\r\nret = -EINVAL;\r\ngoto err_supplies;\r\n}\r\neps = kcalloc(hsotg->num_of_eps + 1, sizeof(struct s3c_hsotg_ep),\r\nGFP_KERNEL);\r\nif (!eps) {\r\ndev_err(dev, "cannot get memory\n");\r\nret = -ENOMEM;\r\ngoto err_supplies;\r\n}\r\nhsotg->eps = eps;\r\nINIT_LIST_HEAD(&hsotg->gadget.ep_list);\r\nhsotg->gadget.ep0 = &hsotg->eps[0].ep;\r\nhsotg->ctrl_req = s3c_hsotg_ep_alloc_request(&hsotg->eps[0].ep,\r\nGFP_KERNEL);\r\nif (!hsotg->ctrl_req) {\r\ndev_err(dev, "failed to allocate ctrl req\n");\r\nret = -ENOMEM;\r\ngoto err_ep_mem;\r\n}\r\nfor (epnum = 0; epnum < hsotg->num_of_eps; epnum++)\r\ns3c_hsotg_initep(hsotg, &hsotg->eps[epnum], epnum);\r\nret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(hsotg->dev, "failed to disable supplies: %d\n", ret);\r\ngoto err_ep_mem;\r\n}\r\ns3c_hsotg_phy_disable(hsotg);\r\nret = usb_add_gadget_udc(&pdev->dev, &hsotg->gadget);\r\nif (ret)\r\ngoto err_ep_mem;\r\ns3c_hsotg_create_debug(hsotg);\r\ns3c_hsotg_dump(hsotg);\r\nreturn 0;\r\nerr_ep_mem:\r\nkfree(eps);\r\nerr_supplies:\r\ns3c_hsotg_phy_disable(hsotg);\r\nerr_clk:\r\nclk_disable_unprepare(hsotg->clk);\r\nreturn ret;\r\n}\r\nstatic int s3c_hsotg_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_hsotg *hsotg = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&hsotg->gadget);\r\ns3c_hsotg_delete_debug(hsotg);\r\nif (hsotg->driver) {\r\nusb_gadget_unregister_driver(hsotg->driver);\r\n}\r\ns3c_hsotg_phy_disable(hsotg);\r\nclk_disable_unprepare(hsotg->clk);\r\nreturn 0;\r\n}
