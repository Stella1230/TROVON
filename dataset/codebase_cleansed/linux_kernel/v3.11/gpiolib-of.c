static int of_gpiochip_find_and_xlate(struct gpio_chip *gc, void *data)\r\n{\r\nstruct gg_data *gg_data = data;\r\nint ret;\r\nif ((gc->of_node != gg_data->gpiospec.np) ||\r\n(gc->of_gpio_n_cells != gg_data->gpiospec.args_count) ||\r\n(!gc->of_xlate))\r\nreturn false;\r\nret = gc->of_xlate(gc, &gg_data->gpiospec, gg_data->flags);\r\nif (ret < 0)\r\nreturn false;\r\ngg_data->out_gpio = ret + gc->base;\r\nreturn true;\r\n}\r\nint of_get_named_gpio_flags(struct device_node *np, const char *propname,\r\nint index, enum of_gpio_flags *flags)\r\n{\r\nstruct gg_data gg_data = { .flags = flags, .out_gpio = -EPROBE_DEFER };\r\nint ret;\r\nif (flags)\r\n*flags = 0;\r\nret = of_parse_phandle_with_args(np, propname, "#gpio-cells", index,\r\n&gg_data.gpiospec);\r\nif (ret) {\r\npr_debug("%s: can't parse gpios property\n", __func__);\r\nreturn ret;\r\n}\r\ngpiochip_find(&gg_data, of_gpiochip_find_and_xlate);\r\nof_node_put(gg_data.gpiospec.np);\r\npr_debug("%s exited with status %d\n", __func__, gg_data.out_gpio);\r\nreturn gg_data.out_gpio;\r\n}\r\nint of_gpio_simple_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec, u32 *flags)\r\n{\r\nif (gc->of_gpio_n_cells < 2) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))\r\nreturn -EINVAL;\r\nif (gpiospec->args[0] >= gc->ngpio)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0];\r\n}\r\nint of_mm_gpiochip_add(struct device_node *np,\r\nstruct of_mm_gpio_chip *mm_gc)\r\n{\r\nint ret = -ENOMEM;\r\nstruct gpio_chip *gc = &mm_gc->gc;\r\ngc->label = kstrdup(np->full_name, GFP_KERNEL);\r\nif (!gc->label)\r\ngoto err0;\r\nmm_gc->regs = of_iomap(np, 0);\r\nif (!mm_gc->regs)\r\ngoto err1;\r\ngc->base = -1;\r\nif (mm_gc->save_regs)\r\nmm_gc->save_regs(mm_gc);\r\nmm_gc->gc.of_node = np;\r\nret = gpiochip_add(gc);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\niounmap(mm_gc->regs);\r\nerr1:\r\nkfree(gc->label);\r\nerr0:\r\npr_err("%s: GPIO chip registration failed with status %d\n",\r\nnp->full_name, ret);\r\nreturn ret;\r\n}\r\nstatic void of_gpiochip_add_pin_range(struct gpio_chip *chip)\r\n{\r\nstruct device_node *np = chip->of_node;\r\nstruct of_phandle_args pinspec;\r\nstruct pinctrl_dev *pctldev;\r\nint index = 0, ret;\r\nif (!np)\r\nreturn;\r\nfor (;; index++) {\r\nret = of_parse_phandle_with_args(np, "gpio-ranges",\r\n"#gpio-range-cells", index, &pinspec);\r\nif (ret)\r\nbreak;\r\npctldev = of_pinctrl_get(pinspec.np);\r\nif (!pctldev)\r\nbreak;\r\nret = gpiochip_add_pin_range(chip,\r\npinctrl_dev_get_devname(pctldev),\r\npinspec.args[0],\r\npinspec.args[1],\r\npinspec.args[2]);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nstatic void of_gpiochip_add_pin_range(struct gpio_chip *chip) {}\r\nvoid of_gpiochip_add(struct gpio_chip *chip)\r\n{\r\nif ((!chip->of_node) && (chip->dev))\r\nchip->of_node = chip->dev->of_node;\r\nif (!chip->of_node)\r\nreturn;\r\nif (!chip->of_xlate) {\r\nchip->of_gpio_n_cells = 2;\r\nchip->of_xlate = of_gpio_simple_xlate;\r\n}\r\nof_gpiochip_add_pin_range(chip);\r\nof_node_get(chip->of_node);\r\n}\r\nvoid of_gpiochip_remove(struct gpio_chip *chip)\r\n{\r\ngpiochip_remove_pin_ranges(chip);\r\nif (chip->of_node)\r\nof_node_put(chip->of_node);\r\n}
