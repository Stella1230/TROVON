static void exynos_ohci_phy_enable(struct exynos_ohci_hcd *exynos_ohci)\r\n{\r\nstruct platform_device *pdev = to_platform_device(exynos_ohci->dev);\r\nif (exynos_ohci->phy)\r\nusb_phy_init(exynos_ohci->phy);\r\nelse if (exynos_ohci->pdata && exynos_ohci->pdata->phy_init)\r\nexynos_ohci->pdata->phy_init(pdev, USB_PHY_TYPE_HOST);\r\n}\r\nstatic void exynos_ohci_phy_disable(struct exynos_ohci_hcd *exynos_ohci)\r\n{\r\nstruct platform_device *pdev = to_platform_device(exynos_ohci->dev);\r\nif (exynos_ohci->phy)\r\nusb_phy_shutdown(exynos_ohci->phy);\r\nelse if (exynos_ohci->pdata && exynos_ohci->pdata->phy_exit)\r\nexynos_ohci->pdata->phy_exit(pdev, USB_PHY_TYPE_HOST);\r\n}\r\nstatic int ohci_exynos_reset(struct usb_hcd *hcd)\r\n{\r\nreturn ohci_init(hcd_to_ohci(hcd));\r\n}\r\nstatic int ohci_exynos_start(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint ret;\r\nohci_dbg(ohci, "ohci_exynos_start, ohci:%p", ohci);\r\nret = ohci_run(ohci);\r\nif (ret < 0) {\r\ndev_err(hcd->self.controller, "can't start %s\n",\r\nhcd->self.bus_name);\r\nohci_stop(hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_ohci_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos4_ohci_platdata *pdata = pdev->dev.platform_data;\r\nstruct exynos_ohci_hcd *exynos_ohci;\r\nstruct usb_hcd *hcd;\r\nstruct ohci_hcd *ohci;\r\nstruct resource *res;\r\nstruct usb_phy *phy;\r\nint irq;\r\nint err;\r\nif (!pdev->dev.dma_mask)\r\npdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\r\nif (!pdev->dev.coherent_dma_mask)\r\npdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\nexynos_ohci = devm_kzalloc(&pdev->dev, sizeof(struct exynos_ohci_hcd),\r\nGFP_KERNEL);\r\nif (!exynos_ohci)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(pdev->dev.of_node,\r\n"samsung,exynos5440-ohci"))\r\ngoto skip_phy;\r\nphy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(phy)) {\r\nif (!pdata) {\r\ndev_warn(&pdev->dev, "no platform data or transceiver defined\n");\r\nreturn -EPROBE_DEFER;\r\n} else {\r\nexynos_ohci->pdata = pdata;\r\n}\r\n} else {\r\nexynos_ohci->phy = phy;\r\nexynos_ohci->otg = phy->otg;\r\n}\r\nskip_phy:\r\nexynos_ohci->dev = &pdev->dev;\r\nhcd = usb_create_hcd(&exynos_ohci_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!hcd) {\r\ndev_err(&pdev->dev, "Unable to create HCD\n");\r\nreturn -ENOMEM;\r\n}\r\nexynos_ohci->hcd = hcd;\r\nexynos_ohci->clk = devm_clk_get(&pdev->dev, "usbhost");\r\nif (IS_ERR(exynos_ohci->clk)) {\r\ndev_err(&pdev->dev, "Failed to get usbhost clock\n");\r\nerr = PTR_ERR(exynos_ohci->clk);\r\ngoto fail_clk;\r\n}\r\nerr = clk_prepare_enable(exynos_ohci->clk);\r\nif (err)\r\ngoto fail_clk;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Failed to get I/O memory\n");\r\nerr = -ENXIO;\r\ngoto fail_io;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = devm_ioremap(&pdev->dev, res->start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\ndev_err(&pdev->dev, "Failed to remap I/O memory\n");\r\nerr = -ENOMEM;\r\ngoto fail_io;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "Failed to get IRQ\n");\r\nerr = -ENODEV;\r\ngoto fail_io;\r\n}\r\nif (exynos_ohci->otg)\r\nexynos_ohci->otg->set_host(exynos_ohci->otg,\r\n&exynos_ohci->hcd->self);\r\nexynos_ohci_phy_enable(exynos_ohci);\r\nohci = hcd_to_ohci(hcd);\r\nohci_hcd_init(ohci);\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to add USB HCD\n");\r\ngoto fail_add_hcd;\r\n}\r\nplatform_set_drvdata(pdev, exynos_ohci);\r\nreturn 0;\r\nfail_add_hcd:\r\nexynos_ohci_phy_disable(exynos_ohci);\r\nfail_io:\r\nclk_disable_unprepare(exynos_ohci->clk);\r\nfail_clk:\r\nusb_put_hcd(hcd);\r\nreturn err;\r\n}\r\nstatic int exynos_ohci_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos_ohci_hcd *exynos_ohci = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = exynos_ohci->hcd;\r\nusb_remove_hcd(hcd);\r\nif (exynos_ohci->otg)\r\nexynos_ohci->otg->set_host(exynos_ohci->otg,\r\n&exynos_ohci->hcd->self);\r\nexynos_ohci_phy_disable(exynos_ohci);\r\nclk_disable_unprepare(exynos_ohci->clk);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic void exynos_ohci_shutdown(struct platform_device *pdev)\r\n{\r\nstruct exynos_ohci_hcd *exynos_ohci = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = exynos_ohci->hcd;\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}\r\nstatic int exynos_ohci_suspend(struct device *dev)\r\n{\r\nstruct exynos_ohci_hcd *exynos_ohci = dev_get_drvdata(dev);\r\nstruct usb_hcd *hcd = exynos_ohci->hcd;\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&ohci->lock, flags);\r\nif (ohci->rh_state != OHCI_RH_SUSPENDED &&\r\nohci->rh_state != OHCI_RH_HALTED) {\r\nrc = -EINVAL;\r\ngoto fail;\r\n}\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nif (exynos_ohci->otg)\r\nexynos_ohci->otg->set_host(exynos_ohci->otg,\r\n&exynos_ohci->hcd->self);\r\nexynos_ohci_phy_disable(exynos_ohci);\r\nclk_disable_unprepare(exynos_ohci->clk);\r\nfail:\r\nspin_unlock_irqrestore(&ohci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int exynos_ohci_resume(struct device *dev)\r\n{\r\nstruct exynos_ohci_hcd *exynos_ohci = dev_get_drvdata(dev);\r\nstruct usb_hcd *hcd = exynos_ohci->hcd;\r\nclk_prepare_enable(exynos_ohci->clk);\r\nif (exynos_ohci->otg)\r\nexynos_ohci->otg->set_host(exynos_ohci->otg,\r\n&exynos_ohci->hcd->self);\r\nexynos_ohci_phy_enable(exynos_ohci);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}
