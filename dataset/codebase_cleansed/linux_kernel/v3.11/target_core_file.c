static inline struct fd_dev *FD_DEV(struct se_device *dev)\r\n{\r\nreturn container_of(dev, struct fd_dev, dev);\r\n}\r\nstatic int fd_attach_hba(struct se_hba *hba, u32 host_id)\r\n{\r\nstruct fd_host *fd_host;\r\nfd_host = kzalloc(sizeof(struct fd_host), GFP_KERNEL);\r\nif (!fd_host) {\r\npr_err("Unable to allocate memory for struct fd_host\n");\r\nreturn -ENOMEM;\r\n}\r\nfd_host->fd_host_id = host_id;\r\nhba->hba_ptr = fd_host;\r\npr_debug("CORE_HBA[%d] - TCM FILEIO HBA Driver %s on Generic"\r\n" Target Core Stack %s\n", hba->hba_id, FD_VERSION,\r\nTARGET_CORE_MOD_VERSION);\r\npr_debug("CORE_HBA[%d] - Attached FILEIO HBA: %u to Generic"\r\n" MaxSectors: %u\n",\r\nhba->hba_id, fd_host->fd_host_id, FD_MAX_SECTORS);\r\nreturn 0;\r\n}\r\nstatic void fd_detach_hba(struct se_hba *hba)\r\n{\r\nstruct fd_host *fd_host = hba->hba_ptr;\r\npr_debug("CORE_HBA[%d] - Detached FILEIO HBA: %u from Generic"\r\n" Target Core\n", hba->hba_id, fd_host->fd_host_id);\r\nkfree(fd_host);\r\nhba->hba_ptr = NULL;\r\n}\r\nstatic struct se_device *fd_alloc_device(struct se_hba *hba, const char *name)\r\n{\r\nstruct fd_dev *fd_dev;\r\nstruct fd_host *fd_host = hba->hba_ptr;\r\nfd_dev = kzalloc(sizeof(struct fd_dev), GFP_KERNEL);\r\nif (!fd_dev) {\r\npr_err("Unable to allocate memory for struct fd_dev\n");\r\nreturn NULL;\r\n}\r\nfd_dev->fd_host = fd_host;\r\npr_debug("FILEIO: Allocated fd_dev for %p\n", name);\r\nreturn &fd_dev->dev;\r\n}\r\nstatic int fd_configure_device(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nstruct fd_host *fd_host = dev->se_hba->hba_ptr;\r\nstruct file *file;\r\nstruct inode *inode = NULL;\r\nint flags, ret = -EINVAL;\r\nif (!(fd_dev->fbd_flags & FBDF_HAS_PATH)) {\r\npr_err("Missing fd_dev_name=\n");\r\nreturn -EINVAL;\r\n}\r\nflags = O_RDWR | O_CREAT | O_LARGEFILE | O_DSYNC;\r\nif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) {\r\npr_debug("FILEIO: Disabling O_DSYNC, using buffered FILEIO\n");\r\nflags &= ~O_DSYNC;\r\n}\r\nfile = filp_open(fd_dev->fd_dev_name, flags, 0600);\r\nif (IS_ERR(file)) {\r\npr_err("filp_open(%s) failed\n", fd_dev->fd_dev_name);\r\nret = PTR_ERR(file);\r\ngoto fail;\r\n}\r\nfd_dev->fd_file = file;\r\ninode = file->f_mapping->host;\r\nif (S_ISBLK(inode->i_mode)) {\r\nstruct request_queue *q = bdev_get_queue(inode->i_bdev);\r\nunsigned long long dev_size;\r\nfd_dev->fd_block_size = bdev_logical_block_size(inode->i_bdev);\r\ndev_size = (i_size_read(file->f_mapping->host) -\r\nfd_dev->fd_block_size);\r\npr_debug("FILEIO: Using size: %llu bytes from struct"\r\n" block_device blocks: %llu logical_block_size: %d\n",\r\ndev_size, div_u64(dev_size, fd_dev->fd_block_size),\r\nfd_dev->fd_block_size);\r\nif (blk_queue_discard(q)) {\r\ndev->dev_attrib.max_unmap_lba_count =\r\nq->limits.max_discard_sectors;\r\ndev->dev_attrib.max_unmap_block_desc_count = 1;\r\ndev->dev_attrib.unmap_granularity =\r\nq->limits.discard_granularity >> 9;\r\ndev->dev_attrib.unmap_granularity_alignment =\r\nq->limits.discard_alignment;\r\npr_debug("IFILE: BLOCK Discard support available,"\r\n" disabled by default\n");\r\n}\r\ndev->dev_attrib.max_write_same_len = 0xFFFF;\r\nif (blk_queue_nonrot(q))\r\ndev->dev_attrib.is_nonrot = 1;\r\n} else {\r\nif (!(fd_dev->fbd_flags & FBDF_HAS_SIZE)) {\r\npr_err("FILEIO: Missing fd_dev_size="\r\n" parameter, and no backing struct"\r\n" block_device\n");\r\ngoto fail;\r\n}\r\nfd_dev->fd_block_size = FD_BLOCKSIZE;\r\ndev->dev_attrib.max_unmap_lba_count = 0x2000;\r\ndev->dev_attrib.max_unmap_block_desc_count = 1;\r\ndev->dev_attrib.unmap_granularity = 1;\r\ndev->dev_attrib.unmap_granularity_alignment = 0;\r\ndev->dev_attrib.max_write_same_len = 0x1000;\r\n}\r\ndev->dev_attrib.hw_block_size = fd_dev->fd_block_size;\r\ndev->dev_attrib.hw_max_sectors = FD_MAX_SECTORS;\r\ndev->dev_attrib.hw_queue_depth = FD_MAX_DEVICE_QUEUE_DEPTH;\r\nif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) {\r\npr_debug("FILEIO: Forcing setting of emulate_write_cache=1"\r\n" with FDBD_HAS_BUFFERED_IO_WCE\n");\r\ndev->dev_attrib.emulate_write_cache = 1;\r\n}\r\nfd_dev->fd_dev_id = fd_host->fd_host_dev_id_count++;\r\nfd_dev->fd_queue_depth = dev->queue_depth;\r\npr_debug("CORE_FILE[%u] - Added TCM FILEIO Device ID: %u at %s,"\r\n" %llu total bytes\n", fd_host->fd_host_id, fd_dev->fd_dev_id,\r\nfd_dev->fd_dev_name, fd_dev->fd_dev_size);\r\nreturn 0;\r\nfail:\r\nif (fd_dev->fd_file) {\r\nfilp_close(fd_dev->fd_file, NULL);\r\nfd_dev->fd_file = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fd_free_device(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nif (fd_dev->fd_file) {\r\nfilp_close(fd_dev->fd_file, NULL);\r\nfd_dev->fd_file = NULL;\r\n}\r\nkfree(fd_dev);\r\n}\r\nstatic int fd_do_rw(struct se_cmd *cmd, struct scatterlist *sgl,\r\nu32 sgl_nents, int is_write)\r\n{\r\nstruct se_device *se_dev = cmd->se_dev;\r\nstruct fd_dev *dev = FD_DEV(se_dev);\r\nstruct file *fd = dev->fd_file;\r\nstruct scatterlist *sg;\r\nstruct iovec *iov;\r\nmm_segment_t old_fs;\r\nloff_t pos = (cmd->t_task_lba * se_dev->dev_attrib.block_size);\r\nint ret = 0, i;\r\niov = kzalloc(sizeof(struct iovec) * sgl_nents, GFP_KERNEL);\r\nif (!iov) {\r\npr_err("Unable to allocate fd_do_readv iov[]\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_sg(sgl, sg, sgl_nents, i) {\r\niov[i].iov_len = sg->length;\r\niov[i].iov_base = kmap(sg_page(sg)) + sg->offset;\r\n}\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nif (is_write)\r\nret = vfs_writev(fd, &iov[0], sgl_nents, &pos);\r\nelse\r\nret = vfs_readv(fd, &iov[0], sgl_nents, &pos);\r\nset_fs(old_fs);\r\nfor_each_sg(sgl, sg, sgl_nents, i)\r\nkunmap(sg_page(sg));\r\nkfree(iov);\r\nif (is_write) {\r\nif (ret < 0 || ret != cmd->data_length) {\r\npr_err("%s() write returned %d\n", __func__, ret);\r\nreturn (ret < 0 ? ret : -EINVAL);\r\n}\r\n} else {\r\nif (S_ISBLK(file_inode(fd)->i_mode)) {\r\nif (ret < 0 || ret != cmd->data_length) {\r\npr_err("%s() returned %d, expecting %u for "\r\n"S_ISBLK\n", __func__, ret,\r\ncmd->data_length);\r\nreturn (ret < 0 ? ret : -EINVAL);\r\n}\r\n} else {\r\nif (ret < 0) {\r\npr_err("%s() returned %d for non S_ISBLK\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_sync_cache(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nint immed = (cmd->t_task_cdb[1] & 0x2);\r\nloff_t start, end;\r\nint ret;\r\nif (immed)\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nif (cmd->t_task_lba == 0 && cmd->data_length == 0) {\r\nstart = 0;\r\nend = LLONG_MAX;\r\n} else {\r\nstart = cmd->t_task_lba * dev->dev_attrib.block_size;\r\nif (cmd->data_length)\r\nend = start + cmd->data_length;\r\nelse\r\nend = LLONG_MAX;\r\n}\r\nret = vfs_fsync_range(fd_dev->fd_file, start, end, 1);\r\nif (ret != 0)\r\npr_err("FILEIO: vfs_fsync_range() failed: %d\n", ret);\r\nif (immed)\r\nreturn 0;\r\nif (ret)\r\ntarget_complete_cmd(cmd, SAM_STAT_CHECK_CONDITION);\r\nelse\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nstatic unsigned char *\r\nfd_setup_write_same_buf(struct se_cmd *cmd, struct scatterlist *sg,\r\nunsigned int len)\r\n{\r\nstruct se_device *se_dev = cmd->se_dev;\r\nunsigned int block_size = se_dev->dev_attrib.block_size;\r\nunsigned int i = 0, end;\r\nunsigned char *buf, *p, *kmap_buf;\r\nbuf = kzalloc(min_t(unsigned int, len, PAGE_SIZE), GFP_KERNEL);\r\nif (!buf) {\r\npr_err("Unable to allocate fd_execute_write_same buf\n");\r\nreturn NULL;\r\n}\r\nkmap_buf = kmap(sg_page(sg)) + sg->offset;\r\nif (!kmap_buf) {\r\npr_err("kmap() failed in fd_setup_write_same\n");\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\np = buf;\r\nend = min_t(unsigned int, len, PAGE_SIZE);\r\nwhile (i < end) {\r\nmemcpy(p, kmap_buf, block_size);\r\ni += block_size;\r\np += block_size;\r\n}\r\nkunmap(sg_page(sg));\r\nreturn buf;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_write_same(struct se_cmd *cmd)\r\n{\r\nstruct se_device *se_dev = cmd->se_dev;\r\nstruct fd_dev *fd_dev = FD_DEV(se_dev);\r\nstruct file *f = fd_dev->fd_file;\r\nstruct scatterlist *sg;\r\nstruct iovec *iov;\r\nmm_segment_t old_fs;\r\nsector_t nolb = sbc_get_write_same_sectors(cmd);\r\nloff_t pos = cmd->t_task_lba * se_dev->dev_attrib.block_size;\r\nunsigned int len, len_tmp, iov_num;\r\nint i, rc;\r\nunsigned char *buf;\r\nif (!nolb) {\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nsg = &cmd->t_data_sg[0];\r\nif (cmd->t_data_nents > 1 ||\r\nsg->length != cmd->se_dev->dev_attrib.block_size) {\r\npr_err("WRITE_SAME: Illegal SGL t_data_nents: %u length: %u"\r\n" block_size: %u\n", cmd->t_data_nents, sg->length,\r\ncmd->se_dev->dev_attrib.block_size);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nlen = len_tmp = nolb * se_dev->dev_attrib.block_size;\r\niov_num = DIV_ROUND_UP(len, PAGE_SIZE);\r\nbuf = fd_setup_write_same_buf(cmd, sg, len);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\niov = vzalloc(sizeof(struct iovec) * iov_num);\r\nif (!iov) {\r\npr_err("Unable to allocate fd_execute_write_same iovecs\n");\r\nkfree(buf);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nfor (i = 0; i < iov_num; i++) {\r\niov[i].iov_base = buf;\r\niov[i].iov_len = min_t(unsigned int, len_tmp, PAGE_SIZE);\r\nlen_tmp -= iov[i].iov_len;\r\n}\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nrc = vfs_writev(f, &iov[0], iov_num, &pos);\r\nset_fs(old_fs);\r\nvfree(iov);\r\nkfree(buf);\r\nif (rc < 0 || rc != len) {\r\npr_err("vfs_writev() returned %d for write same\n", rc);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nfd_do_unmap(struct se_cmd *cmd, void *priv, sector_t lba, sector_t nolb)\r\n{\r\nstruct file *file = priv;\r\nstruct inode *inode = file->f_mapping->host;\r\nint ret;\r\nif (S_ISBLK(inode->i_mode)) {\r\nstruct block_device *bdev = inode->i_bdev;\r\nret = blkdev_issue_discard(bdev, lba,\r\nnolb, GFP_KERNEL, 0);\r\nif (ret < 0) {\r\npr_warn("FILEIO: blkdev_issue_discard() failed: %d\n",\r\nret);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\n} else {\r\nstruct se_device *se_dev = cmd->se_dev;\r\nloff_t pos = lba * se_dev->dev_attrib.block_size;\r\nunsigned int len = nolb * se_dev->dev_attrib.block_size;\r\nint mode = FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE;\r\nif (!file->f_op->fallocate)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nret = file->f_op->fallocate(file, mode, pos, len);\r\nif (ret < 0) {\r\npr_warn("FILEIO: fallocate() failed: %d\n", ret);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_write_same_unmap(struct se_cmd *cmd)\r\n{\r\nstruct se_device *se_dev = cmd->se_dev;\r\nstruct fd_dev *fd_dev = FD_DEV(se_dev);\r\nstruct file *file = fd_dev->fd_file;\r\nsector_t lba = cmd->t_task_lba;\r\nsector_t nolb = sbc_get_write_same_sectors(cmd);\r\nint ret;\r\nif (!nolb) {\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nret = fd_do_unmap(cmd, file, lba, nolb);\r\nif (ret)\r\nreturn ret;\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nfd_execute_unmap(struct se_cmd *cmd)\r\n{\r\nstruct file *file = FD_DEV(cmd->se_dev)->fd_file;\r\nreturn sbc_execute_unmap(cmd, fd_do_unmap, file);\r\n}\r\nstatic sense_reason_t\r\nfd_execute_rw(struct se_cmd *cmd)\r\n{\r\nstruct scatterlist *sgl = cmd->t_data_sg;\r\nu32 sgl_nents = cmd->t_data_nents;\r\nenum dma_data_direction data_direction = cmd->data_direction;\r\nstruct se_device *dev = cmd->se_dev;\r\nint ret = 0;\r\nif (data_direction == DMA_FROM_DEVICE) {\r\nret = fd_do_rw(cmd, sgl, sgl_nents, 0);\r\n} else {\r\nret = fd_do_rw(cmd, sgl, sgl_nents, 1);\r\nif (ret > 0 &&\r\ndev->dev_attrib.emulate_fua_write > 0 &&\r\n(cmd->se_cmd_flags & SCF_FUA)) {\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nloff_t start = cmd->t_task_lba *\r\ndev->dev_attrib.block_size;\r\nloff_t end = start + cmd->data_length;\r\nvfs_fsync_range(fd_dev->fd_file, start, end, 1);\r\n}\r\n}\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (ret)\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nstatic ssize_t fd_set_configfs_dev_params(struct se_device *dev,\r\nconst char *page, ssize_t count)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nchar *orig, *ptr, *arg_p, *opts;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint ret = 0, arg, token;\r\nopts = kstrdup(page, GFP_KERNEL);\r\nif (!opts)\r\nreturn -ENOMEM;\r\norig = opts;\r\nwhile ((ptr = strsep(&opts, ",\n")) != NULL) {\r\nif (!*ptr)\r\ncontinue;\r\ntoken = match_token(ptr, tokens, args);\r\nswitch (token) {\r\ncase Opt_fd_dev_name:\r\nif (match_strlcpy(fd_dev->fd_dev_name, &args[0],\r\nFD_MAX_DEV_NAME) == 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\npr_debug("FILEIO: Referencing Path: %s\n",\r\nfd_dev->fd_dev_name);\r\nfd_dev->fbd_flags |= FBDF_HAS_PATH;\r\nbreak;\r\ncase Opt_fd_dev_size:\r\narg_p = match_strdup(&args[0]);\r\nif (!arg_p) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = strict_strtoull(arg_p, 0, &fd_dev->fd_dev_size);\r\nkfree(arg_p);\r\nif (ret < 0) {\r\npr_err("strict_strtoull() failed for"\r\n" fd_dev_size=\n");\r\ngoto out;\r\n}\r\npr_debug("FILEIO: Referencing Size: %llu"\r\n" bytes\n", fd_dev->fd_dev_size);\r\nfd_dev->fbd_flags |= FBDF_HAS_SIZE;\r\nbreak;\r\ncase Opt_fd_buffered_io:\r\nmatch_int(args, &arg);\r\nif (arg != 1) {\r\npr_err("bogus fd_buffered_io=%d value\n", arg);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_debug("FILEIO: Using buffered I/O"\r\n" operations for struct fd_dev\n");\r\nfd_dev->fbd_flags |= FDBD_HAS_BUFFERED_IO_WCE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nout:\r\nkfree(orig);\r\nreturn (!ret) ? count : ret;\r\n}\r\nstatic ssize_t fd_show_configfs_dev_params(struct se_device *dev, char *b)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nssize_t bl = 0;\r\nbl = sprintf(b + bl, "TCM FILEIO ID: %u", fd_dev->fd_dev_id);\r\nbl += sprintf(b + bl, " File: %s Size: %llu Mode: %s\n",\r\nfd_dev->fd_dev_name, fd_dev->fd_dev_size,\r\n(fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) ?\r\n"Buffered-WCE" : "O_DSYNC");\r\nreturn bl;\r\n}\r\nstatic sector_t fd_get_blocks(struct se_device *dev)\r\n{\r\nstruct fd_dev *fd_dev = FD_DEV(dev);\r\nstruct file *f = fd_dev->fd_file;\r\nstruct inode *i = f->f_mapping->host;\r\nunsigned long long dev_size;\r\nif (S_ISBLK(i->i_mode))\r\ndev_size = i_size_read(i);\r\nelse\r\ndev_size = fd_dev->fd_dev_size;\r\nreturn div_u64(dev_size - dev->dev_attrib.block_size,\r\ndev->dev_attrib.block_size);\r\n}\r\nstatic sense_reason_t\r\nfd_parse_cdb(struct se_cmd *cmd)\r\n{\r\nreturn sbc_parse_cdb(cmd, &fd_sbc_ops);\r\n}\r\nstatic int __init fileio_module_init(void)\r\n{\r\nreturn transport_subsystem_register(&fileio_template);\r\n}\r\nstatic void __exit fileio_module_exit(void)\r\n{\r\ntransport_subsystem_release(&fileio_template);\r\n}
