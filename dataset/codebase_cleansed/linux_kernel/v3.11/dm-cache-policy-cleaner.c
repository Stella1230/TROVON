static unsigned next_power(unsigned n, unsigned min)\r\n{\r\nreturn roundup_pow_of_two(max(n, min));\r\n}\r\nstatic struct policy *to_policy(struct dm_cache_policy *p)\r\n{\r\nreturn container_of(p, struct policy, policy);\r\n}\r\nstatic struct list_head *list_pop(struct list_head *q)\r\n{\r\nstruct list_head *r = q->next;\r\nlist_del(r);\r\nreturn r;\r\n}\r\nstatic int alloc_hash(struct hash *hash, unsigned elts)\r\n{\r\nhash->nr_buckets = next_power(elts >> 4, 16);\r\nhash->hash_bits = ffs(hash->nr_buckets) - 1;\r\nhash->table = vzalloc(sizeof(*hash->table) * hash->nr_buckets);\r\nreturn hash->table ? 0 : -ENOMEM;\r\n}\r\nstatic void free_hash(struct hash *hash)\r\n{\r\nvfree(hash->table);\r\n}\r\nstatic int alloc_cache_blocks_with_hash(struct policy *p, dm_cblock_t cache_size)\r\n{\r\nint r = -ENOMEM;\r\np->cblocks = vzalloc(sizeof(*p->cblocks) * from_cblock(cache_size));\r\nif (p->cblocks) {\r\nunsigned u = from_cblock(cache_size);\r\nwhile (u--)\r\nlist_add(&p->cblocks[u].list, &p->free);\r\np->nr_cblocks_allocated = 0;\r\nr = alloc_hash(&p->chash, from_cblock(cache_size));\r\nif (r)\r\nvfree(p->cblocks);\r\n}\r\nreturn r;\r\n}\r\nstatic void free_cache_blocks_and_hash(struct policy *p)\r\n{\r\nfree_hash(&p->chash);\r\nvfree(p->cblocks);\r\n}\r\nstatic struct wb_cache_entry *alloc_cache_entry(struct policy *p)\r\n{\r\nstruct wb_cache_entry *e;\r\nBUG_ON(from_cblock(p->nr_cblocks_allocated) >= from_cblock(p->cache_size));\r\ne = list_entry(list_pop(&p->free), struct wb_cache_entry, list);\r\np->nr_cblocks_allocated = to_cblock(from_cblock(p->nr_cblocks_allocated) + 1);\r\nreturn e;\r\n}\r\nstatic struct wb_cache_entry *lookup_cache_entry(struct policy *p, dm_oblock_t oblock)\r\n{\r\nstruct hash *hash = &p->chash;\r\nunsigned h = hash_64(from_oblock(oblock), hash->hash_bits);\r\nstruct wb_cache_entry *cur;\r\nstruct hlist_head *bucket = &hash->table[h];\r\nhlist_for_each_entry(cur, bucket, hlist) {\r\nif (cur->oblock == oblock) {\r\nhlist_del(&cur->hlist);\r\nhlist_add_head(&cur->hlist, bucket);\r\nreturn cur;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void insert_cache_hash_entry(struct policy *p, struct wb_cache_entry *e)\r\n{\r\nunsigned h = hash_64(from_oblock(e->oblock), p->chash.hash_bits);\r\nhlist_add_head(&e->hlist, &p->chash.table[h]);\r\n}\r\nstatic void remove_cache_hash_entry(struct wb_cache_entry *e)\r\n{\r\nhlist_del(&e->hlist);\r\n}\r\nstatic int wb_map(struct dm_cache_policy *pe, dm_oblock_t oblock,\r\nbool can_block, bool can_migrate, bool discarded_oblock,\r\nstruct bio *bio, struct policy_result *result)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e;\r\nunsigned long flags;\r\nresult->op = POLICY_MISS;\r\nif (can_block)\r\nspin_lock_irqsave(&p->lock, flags);\r\nelse if (!spin_trylock_irqsave(&p->lock, flags))\r\nreturn -EWOULDBLOCK;\r\ne = lookup_cache_entry(p, oblock);\r\nif (e) {\r\nresult->op = POLICY_HIT;\r\nresult->cblock = e->cblock;\r\n}\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wb_lookup(struct dm_cache_policy *pe, dm_oblock_t oblock, dm_cblock_t *cblock)\r\n{\r\nint r;\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e;\r\nunsigned long flags;\r\nif (!spin_trylock_irqsave(&p->lock, flags))\r\nreturn -EWOULDBLOCK;\r\ne = lookup_cache_entry(p, oblock);\r\nif (e) {\r\n*cblock = e->cblock;\r\nr = 0;\r\n} else\r\nr = -ENOENT;\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nreturn r;\r\n}\r\nstatic void __set_clear_dirty(struct dm_cache_policy *pe, dm_oblock_t oblock, bool set)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e;\r\ne = lookup_cache_entry(p, oblock);\r\nBUG_ON(!e);\r\nif (set) {\r\nif (!e->dirty) {\r\ne->dirty = true;\r\nlist_move(&e->list, &p->dirty);\r\n}\r\n} else {\r\nif (e->dirty) {\r\ne->pending = false;\r\ne->dirty = false;\r\nlist_move(&e->list, &p->clean);\r\n}\r\n}\r\n}\r\nstatic void wb_set_dirty(struct dm_cache_policy *pe, dm_oblock_t oblock)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\n__set_clear_dirty(pe, oblock, true);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic void wb_clear_dirty(struct dm_cache_policy *pe, dm_oblock_t oblock)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\n__set_clear_dirty(pe, oblock, false);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic void add_cache_entry(struct policy *p, struct wb_cache_entry *e)\r\n{\r\ninsert_cache_hash_entry(p, e);\r\nif (e->dirty)\r\nlist_add(&e->list, &p->dirty);\r\nelse\r\nlist_add(&e->list, &p->clean);\r\n}\r\nstatic int wb_load_mapping(struct dm_cache_policy *pe,\r\ndm_oblock_t oblock, dm_cblock_t cblock,\r\nuint32_t hint, bool hint_valid)\r\n{\r\nint r;\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e = alloc_cache_entry(p);\r\nif (e) {\r\ne->cblock = cblock;\r\ne->oblock = oblock;\r\ne->dirty = false;\r\nadd_cache_entry(p, e);\r\nr = 0;\r\n} else\r\nr = -ENOMEM;\r\nreturn r;\r\n}\r\nstatic void wb_destroy(struct dm_cache_policy *pe)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nfree_cache_blocks_and_hash(p);\r\nkfree(p);\r\n}\r\nstatic struct wb_cache_entry *__wb_force_remove_mapping(struct policy *p, dm_oblock_t oblock)\r\n{\r\nstruct wb_cache_entry *r = lookup_cache_entry(p, oblock);\r\nBUG_ON(!r);\r\nremove_cache_hash_entry(r);\r\nlist_del(&r->list);\r\nreturn r;\r\n}\r\nstatic void wb_remove_mapping(struct dm_cache_policy *pe, dm_oblock_t oblock)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e;\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ne = __wb_force_remove_mapping(p, oblock);\r\nlist_add_tail(&e->list, &p->free);\r\nBUG_ON(!from_cblock(p->nr_cblocks_allocated));\r\np->nr_cblocks_allocated = to_cblock(from_cblock(p->nr_cblocks_allocated) - 1);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic void wb_force_mapping(struct dm_cache_policy *pe,\r\ndm_oblock_t current_oblock, dm_oblock_t oblock)\r\n{\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e;\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ne = __wb_force_remove_mapping(p, current_oblock);\r\ne->oblock = oblock;\r\nadd_cache_entry(p, e);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic struct wb_cache_entry *get_next_dirty_entry(struct policy *p)\r\n{\r\nstruct list_head *l;\r\nstruct wb_cache_entry *r;\r\nif (list_empty(&p->dirty))\r\nreturn NULL;\r\nl = list_pop(&p->dirty);\r\nr = container_of(l, struct wb_cache_entry, list);\r\nlist_add(l, &p->clean_pending);\r\nreturn r;\r\n}\r\nstatic int wb_writeback_work(struct dm_cache_policy *pe,\r\ndm_oblock_t *oblock,\r\ndm_cblock_t *cblock)\r\n{\r\nint r = -ENOENT;\r\nstruct policy *p = to_policy(pe);\r\nstruct wb_cache_entry *e;\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ne = get_next_dirty_entry(p);\r\nif (e) {\r\n*oblock = e->oblock;\r\n*cblock = e->cblock;\r\nr = 0;\r\n}\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nreturn r;\r\n}\r\nstatic dm_cblock_t wb_residency(struct dm_cache_policy *pe)\r\n{\r\nreturn to_policy(pe)->nr_cblocks_allocated;\r\n}\r\nstatic void init_policy_functions(struct policy *p)\r\n{\r\np->policy.destroy = wb_destroy;\r\np->policy.map = wb_map;\r\np->policy.lookup = wb_lookup;\r\np->policy.set_dirty = wb_set_dirty;\r\np->policy.clear_dirty = wb_clear_dirty;\r\np->policy.load_mapping = wb_load_mapping;\r\np->policy.walk_mappings = NULL;\r\np->policy.remove_mapping = wb_remove_mapping;\r\np->policy.writeback_work = wb_writeback_work;\r\np->policy.force_mapping = wb_force_mapping;\r\np->policy.residency = wb_residency;\r\np->policy.tick = NULL;\r\n}\r\nstatic struct dm_cache_policy *wb_create(dm_cblock_t cache_size,\r\nsector_t origin_size,\r\nsector_t cache_block_size)\r\n{\r\nint r;\r\nstruct policy *p = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\ninit_policy_functions(p);\r\nINIT_LIST_HEAD(&p->free);\r\nINIT_LIST_HEAD(&p->clean);\r\nINIT_LIST_HEAD(&p->clean_pending);\r\nINIT_LIST_HEAD(&p->dirty);\r\np->cache_size = cache_size;\r\nspin_lock_init(&p->lock);\r\nr = alloc_cache_blocks_with_hash(p, cache_size);\r\nif (!r)\r\nreturn &p->policy;\r\nkfree(p);\r\nreturn NULL;\r\n}\r\nstatic int __init wb_init(void)\r\n{\r\nint r = dm_cache_policy_register(&wb_policy_type);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nelse\r\nDMINFO("version %u.%u.%u loaded",\r\nwb_policy_type.version[0],\r\nwb_policy_type.version[1],\r\nwb_policy_type.version[2]);\r\nreturn r;\r\n}\r\nstatic void __exit wb_exit(void)\r\n{\r\ndm_cache_policy_unregister(&wb_policy_type);\r\n}
