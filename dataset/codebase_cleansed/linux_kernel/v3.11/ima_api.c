int ima_store_template(struct ima_template_entry *entry,\r\nint violation, struct inode *inode)\r\n{\r\nconst char *op = "add_template_measure";\r\nconst char *audit_cause = "hashing_error";\r\nint result;\r\nmemset(entry->digest, 0, sizeof(entry->digest));\r\nentry->template_name = IMA_TEMPLATE_NAME;\r\nentry->template_len = sizeof(entry->template);\r\nif (!violation) {\r\nresult = ima_calc_buffer_hash(&entry->template,\r\nentry->template_len,\r\nentry->digest);\r\nif (result < 0) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\r\nentry->template_name, op,\r\naudit_cause, result, 0);\r\nreturn result;\r\n}\r\n}\r\nresult = ima_add_template_entry(entry, violation, op, inode);\r\nreturn result;\r\n}\r\nvoid ima_add_violation(struct inode *inode, const unsigned char *filename,\r\nconst char *op, const char *cause)\r\n{\r\nstruct ima_template_entry *entry;\r\nint violation = 1;\r\nint result;\r\natomic_long_inc(&ima_htable.violations);\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nresult = -ENOMEM;\r\ngoto err_out;\r\n}\r\nmemset(&entry->template, 0, sizeof(entry->template));\r\nstrncpy(entry->template.file_name, filename, IMA_EVENT_NAME_LEN_MAX);\r\nresult = ima_store_template(entry, violation, inode);\r\nif (result < 0)\r\nkfree(entry);\r\nerr_out:\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, cause, result, 0);\r\n}\r\nint ima_get_action(struct inode *inode, int mask, int function)\r\n{\r\nint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;\r\nif (!ima_appraise)\r\nflags &= ~IMA_APPRAISE;\r\nreturn ima_match_policy(inode, function, mask, flags);\r\n}\r\nint ima_must_measure(struct inode *inode, int mask, int function)\r\n{\r\nreturn ima_match_policy(inode, function, mask, IMA_MEASURE);\r\n}\r\nint ima_collect_measurement(struct integrity_iint_cache *iint,\r\nstruct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nconst char *filename = file->f_dentry->d_name.name;\r\nint result = 0;\r\nif (!(iint->flags & IMA_COLLECTED)) {\r\nu64 i_version = file_inode(file)->i_version;\r\niint->ima_xattr.type = IMA_XATTR_DIGEST;\r\nresult = ima_calc_file_hash(file, iint->ima_xattr.digest);\r\nif (!result) {\r\niint->version = i_version;\r\niint->flags |= IMA_COLLECTED;\r\n}\r\n}\r\nif (result)\r\nintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\r\nfilename, "collect_data", "failed",\r\nresult, 0);\r\nreturn result;\r\n}\r\nvoid ima_store_measurement(struct integrity_iint_cache *iint,\r\nstruct file *file, const unsigned char *filename)\r\n{\r\nconst char *op = "add_template_measure";\r\nconst char *audit_cause = "ENOMEM";\r\nint result = -ENOMEM;\r\nstruct inode *inode = file_inode(file);\r\nstruct ima_template_entry *entry;\r\nint violation = 0;\r\nif (iint->flags & IMA_MEASURED)\r\nreturn;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, audit_cause, result, 0);\r\nreturn;\r\n}\r\nmemset(&entry->template, 0, sizeof(entry->template));\r\nmemcpy(entry->template.digest, iint->ima_xattr.digest, IMA_DIGEST_SIZE);\r\nstrcpy(entry->template.file_name,\r\n(strlen(filename) > IMA_EVENT_NAME_LEN_MAX) ?\r\nfile->f_dentry->d_name.name : filename);\r\nresult = ima_store_template(entry, violation, inode);\r\nif (!result || result == -EEXIST)\r\niint->flags |= IMA_MEASURED;\r\nif (result < 0)\r\nkfree(entry);\r\n}\r\nvoid ima_audit_measurement(struct integrity_iint_cache *iint,\r\nconst unsigned char *filename)\r\n{\r\nstruct audit_buffer *ab;\r\nchar hash[(IMA_DIGEST_SIZE * 2) + 1];\r\nint i;\r\nif (iint->flags & IMA_AUDITED)\r\nreturn;\r\nfor (i = 0; i < IMA_DIGEST_SIZE; i++)\r\nhex_byte_pack(hash + (i * 2), iint->ima_xattr.digest[i]);\r\nhash[i * 2] = '\0';\r\nab = audit_log_start(current->audit_context, GFP_KERNEL,\r\nAUDIT_INTEGRITY_RULE);\r\nif (!ab)\r\nreturn;\r\naudit_log_format(ab, "file=");\r\naudit_log_untrustedstring(ab, filename);\r\naudit_log_format(ab, " hash=");\r\naudit_log_untrustedstring(ab, hash);\r\naudit_log_task_info(ab, current);\r\naudit_log_end(ab);\r\niint->flags |= IMA_AUDITED;\r\n}\r\nconst char *ima_d_path(struct path *path, char **pathbuf)\r\n{\r\nchar *pathname = NULL;\r\n*pathbuf = kmalloc(PATH_MAX + 11, GFP_KERNEL);\r\nif (*pathbuf) {\r\npathname = d_path(path, *pathbuf, PATH_MAX + 11);\r\nif (IS_ERR(pathname)) {\r\nkfree(*pathbuf);\r\n*pathbuf = NULL;\r\npathname = NULL;\r\n}\r\n}\r\nreturn pathname;\r\n}
