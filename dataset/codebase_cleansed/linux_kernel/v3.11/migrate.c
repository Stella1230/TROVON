static int finish_range(handle_t *handle, struct inode *inode,\r\nstruct migrate_struct *lb)\r\n{\r\nint retval = 0, needed;\r\nstruct ext4_extent newext;\r\nstruct ext4_ext_path *path;\r\nif (lb->first_pblock == 0)\r\nreturn 0;\r\nnewext.ee_block = cpu_to_le32(lb->first_block);\r\nnewext.ee_len = cpu_to_le16(lb->last_block - lb->first_block + 1);\r\next4_ext_store_pblock(&newext, lb->first_pblock);\r\npath = ext4_ext_find_extent(inode, lb->first_block, NULL);\r\nif (IS_ERR(path)) {\r\nretval = PTR_ERR(path);\r\npath = NULL;\r\ngoto err_out;\r\n}\r\nneeded = ext4_ext_calc_credits_for_single_extent(inode,\r\nlb->last_block - lb->first_block + 1, path);\r\nif (needed && ext4_handle_has_enough_credits(handle,\r\nEXT4_RESERVE_TRANS_BLOCKS)) {\r\nretval = ext4_journal_restart(handle, needed);\r\nif (retval)\r\ngoto err_out;\r\n} else if (needed) {\r\nretval = ext4_journal_extend(handle, needed);\r\nif (retval) {\r\nretval = ext4_journal_restart(handle, needed);\r\nif (retval)\r\ngoto err_out;\r\n}\r\n}\r\nretval = ext4_ext_insert_extent(handle, inode, path, &newext, 0);\r\nerr_out:\r\nif (path) {\r\next4_ext_drop_refs(path);\r\nkfree(path);\r\n}\r\nlb->first_pblock = 0;\r\nreturn retval;\r\n}\r\nstatic int update_extent_range(handle_t *handle, struct inode *inode,\r\next4_fsblk_t pblock, struct migrate_struct *lb)\r\n{\r\nint retval;\r\nif (lb->first_pblock &&\r\n(lb->last_pblock+1 == pblock) &&\r\n(lb->last_block+1 == lb->curr_block)) {\r\nlb->last_pblock = pblock;\r\nlb->last_block = lb->curr_block;\r\nlb->curr_block++;\r\nreturn 0;\r\n}\r\nretval = finish_range(handle, inode, lb);\r\nlb->first_pblock = lb->last_pblock = pblock;\r\nlb->first_block = lb->last_block = lb->curr_block;\r\nlb->curr_block++;\r\nreturn retval;\r\n}\r\nstatic int update_ind_extent_range(handle_t *handle, struct inode *inode,\r\next4_fsblk_t pblock,\r\nstruct migrate_struct *lb)\r\n{\r\nstruct buffer_head *bh;\r\n__le32 *i_data;\r\nint i, retval = 0;\r\nunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\r\nbh = sb_bread(inode->i_sb, pblock);\r\nif (!bh)\r\nreturn -EIO;\r\ni_data = (__le32 *)bh->b_data;\r\nfor (i = 0; i < max_entries; i++) {\r\nif (i_data[i]) {\r\nretval = update_extent_range(handle, inode,\r\nle32_to_cpu(i_data[i]), lb);\r\nif (retval)\r\nbreak;\r\n} else {\r\nlb->curr_block++;\r\n}\r\n}\r\nput_bh(bh);\r\nreturn retval;\r\n}\r\nstatic int update_dind_extent_range(handle_t *handle, struct inode *inode,\r\next4_fsblk_t pblock,\r\nstruct migrate_struct *lb)\r\n{\r\nstruct buffer_head *bh;\r\n__le32 *i_data;\r\nint i, retval = 0;\r\nunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\r\nbh = sb_bread(inode->i_sb, pblock);\r\nif (!bh)\r\nreturn -EIO;\r\ni_data = (__le32 *)bh->b_data;\r\nfor (i = 0; i < max_entries; i++) {\r\nif (i_data[i]) {\r\nretval = update_ind_extent_range(handle, inode,\r\nle32_to_cpu(i_data[i]), lb);\r\nif (retval)\r\nbreak;\r\n} else {\r\nlb->curr_block += max_entries;\r\n}\r\n}\r\nput_bh(bh);\r\nreturn retval;\r\n}\r\nstatic int update_tind_extent_range(handle_t *handle, struct inode *inode,\r\next4_fsblk_t pblock,\r\nstruct migrate_struct *lb)\r\n{\r\nstruct buffer_head *bh;\r\n__le32 *i_data;\r\nint i, retval = 0;\r\nunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\r\nbh = sb_bread(inode->i_sb, pblock);\r\nif (!bh)\r\nreturn -EIO;\r\ni_data = (__le32 *)bh->b_data;\r\nfor (i = 0; i < max_entries; i++) {\r\nif (i_data[i]) {\r\nretval = update_dind_extent_range(handle, inode,\r\nle32_to_cpu(i_data[i]), lb);\r\nif (retval)\r\nbreak;\r\n} else {\r\nlb->curr_block += max_entries * max_entries;\r\n}\r\n}\r\nput_bh(bh);\r\nreturn retval;\r\n}\r\nstatic int extend_credit_for_blkdel(handle_t *handle, struct inode *inode)\r\n{\r\nint retval = 0, needed;\r\nif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\r\nreturn 0;\r\nneeded = 3 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\r\nif (ext4_journal_extend(handle, needed) != 0)\r\nretval = ext4_journal_restart(handle, needed);\r\nreturn retval;\r\n}\r\nstatic int free_dind_blocks(handle_t *handle,\r\nstruct inode *inode, __le32 i_data)\r\n{\r\nint i;\r\n__le32 *tmp_idata;\r\nstruct buffer_head *bh;\r\nunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\r\nbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\r\nif (!bh)\r\nreturn -EIO;\r\ntmp_idata = (__le32 *)bh->b_data;\r\nfor (i = 0; i < max_entries; i++) {\r\nif (tmp_idata[i]) {\r\nextend_credit_for_blkdel(handle, inode);\r\next4_free_blocks(handle, inode, NULL,\r\nle32_to_cpu(tmp_idata[i]), 1,\r\nEXT4_FREE_BLOCKS_METADATA |\r\nEXT4_FREE_BLOCKS_FORGET);\r\n}\r\n}\r\nput_bh(bh);\r\nextend_credit_for_blkdel(handle, inode);\r\next4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\r\nEXT4_FREE_BLOCKS_METADATA |\r\nEXT4_FREE_BLOCKS_FORGET);\r\nreturn 0;\r\n}\r\nstatic int free_tind_blocks(handle_t *handle,\r\nstruct inode *inode, __le32 i_data)\r\n{\r\nint i, retval = 0;\r\n__le32 *tmp_idata;\r\nstruct buffer_head *bh;\r\nunsigned long max_entries = inode->i_sb->s_blocksize >> 2;\r\nbh = sb_bread(inode->i_sb, le32_to_cpu(i_data));\r\nif (!bh)\r\nreturn -EIO;\r\ntmp_idata = (__le32 *)bh->b_data;\r\nfor (i = 0; i < max_entries; i++) {\r\nif (tmp_idata[i]) {\r\nretval = free_dind_blocks(handle,\r\ninode, tmp_idata[i]);\r\nif (retval) {\r\nput_bh(bh);\r\nreturn retval;\r\n}\r\n}\r\n}\r\nput_bh(bh);\r\nextend_credit_for_blkdel(handle, inode);\r\next4_free_blocks(handle, inode, NULL, le32_to_cpu(i_data), 1,\r\nEXT4_FREE_BLOCKS_METADATA |\r\nEXT4_FREE_BLOCKS_FORGET);\r\nreturn 0;\r\n}\r\nstatic int free_ind_block(handle_t *handle, struct inode *inode, __le32 *i_data)\r\n{\r\nint retval;\r\nif (i_data[0]) {\r\nextend_credit_for_blkdel(handle, inode);\r\next4_free_blocks(handle, inode, NULL,\r\nle32_to_cpu(i_data[0]), 1,\r\nEXT4_FREE_BLOCKS_METADATA |\r\nEXT4_FREE_BLOCKS_FORGET);\r\n}\r\nif (i_data[1]) {\r\nretval = free_dind_blocks(handle, inode, i_data[1]);\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (i_data[2]) {\r\nretval = free_tind_blocks(handle, inode, i_data[2]);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ext4_ext_swap_inode_data(handle_t *handle, struct inode *inode,\r\nstruct inode *tmp_inode)\r\n{\r\nint retval;\r\n__le32 i_data[3];\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_inode_info *tmp_ei = EXT4_I(tmp_inode);\r\nretval = ext4_journal_extend(handle, 1);\r\nif (retval) {\r\nretval = ext4_journal_restart(handle, 1);\r\nif (retval)\r\ngoto err_out;\r\n}\r\ni_data[0] = ei->i_data[EXT4_IND_BLOCK];\r\ni_data[1] = ei->i_data[EXT4_DIND_BLOCK];\r\ni_data[2] = ei->i_data[EXT4_TIND_BLOCK];\r\ndown_write(&EXT4_I(inode)->i_data_sem);\r\nif (!ext4_test_inode_state(inode, EXT4_STATE_EXT_MIGRATE)) {\r\nretval = -EAGAIN;\r\nup_write(&EXT4_I(inode)->i_data_sem);\r\ngoto err_out;\r\n} else\r\next4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\r\next4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\r\nmemcpy(ei->i_data, tmp_ei->i_data, sizeof(ei->i_data));\r\nspin_lock(&inode->i_lock);\r\ninode->i_blocks += tmp_inode->i_blocks;\r\nspin_unlock(&inode->i_lock);\r\nup_write(&EXT4_I(inode)->i_data_sem);\r\nretval = free_ind_block(handle, inode, i_data);\r\next4_mark_inode_dirty(handle, inode);\r\nerr_out:\r\nreturn retval;\r\n}\r\nstatic int free_ext_idx(handle_t *handle, struct inode *inode,\r\nstruct ext4_extent_idx *ix)\r\n{\r\nint i, retval = 0;\r\next4_fsblk_t block;\r\nstruct buffer_head *bh;\r\nstruct ext4_extent_header *eh;\r\nblock = ext4_idx_pblock(ix);\r\nbh = sb_bread(inode->i_sb, block);\r\nif (!bh)\r\nreturn -EIO;\r\neh = (struct ext4_extent_header *)bh->b_data;\r\nif (eh->eh_depth != 0) {\r\nix = EXT_FIRST_INDEX(eh);\r\nfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\r\nretval = free_ext_idx(handle, inode, ix);\r\nif (retval)\r\nbreak;\r\n}\r\n}\r\nput_bh(bh);\r\nextend_credit_for_blkdel(handle, inode);\r\next4_free_blocks(handle, inode, NULL, block, 1,\r\nEXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET);\r\nreturn retval;\r\n}\r\nstatic int free_ext_block(handle_t *handle, struct inode *inode)\r\n{\r\nint i, retval = 0;\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_extent_header *eh = (struct ext4_extent_header *)ei->i_data;\r\nstruct ext4_extent_idx *ix;\r\nif (eh->eh_depth == 0)\r\nreturn 0;\r\nix = EXT_FIRST_INDEX(eh);\r\nfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ix++) {\r\nretval = free_ext_idx(handle, inode, ix);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn retval;\r\n}\r\nint ext4_ext_migrate(struct inode *inode)\r\n{\r\nhandle_t *handle;\r\nint retval = 0, i;\r\n__le32 *i_data;\r\nstruct ext4_inode_info *ei;\r\nstruct inode *tmp_inode = NULL;\r\nstruct migrate_struct lb;\r\nunsigned long max_entries;\r\n__u32 goal;\r\nuid_t owner[2];\r\nif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\r\nEXT4_FEATURE_INCOMPAT_EXTENTS) ||\r\n(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\r\nreturn -EINVAL;\r\nif (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)\r\nreturn retval;\r\nhandle = ext4_journal_start(inode, EXT4_HT_MIGRATE,\r\n4 + EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb));\r\nif (IS_ERR(handle)) {\r\nretval = PTR_ERR(handle);\r\nreturn retval;\r\n}\r\ngoal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *\r\nEXT4_INODES_PER_GROUP(inode->i_sb)) + 1;\r\nowner[0] = i_uid_read(inode);\r\nowner[1] = i_gid_read(inode);\r\ntmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,\r\nS_IFREG, NULL, goal, owner);\r\nif (IS_ERR(tmp_inode)) {\r\nretval = PTR_ERR(tmp_inode);\r\next4_journal_stop(handle);\r\nreturn retval;\r\n}\r\ni_size_write(tmp_inode, i_size_read(inode));\r\nclear_nlink(tmp_inode);\r\next4_ext_tree_init(handle, tmp_inode);\r\next4_orphan_add(handle, tmp_inode);\r\next4_journal_stop(handle);\r\ndown_read((&EXT4_I(inode)->i_data_sem));\r\next4_set_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\r\nup_read((&EXT4_I(inode)->i_data_sem));\r\nhandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\r\nif (IS_ERR(handle)) {\r\next4_orphan_del(NULL, tmp_inode);\r\nretval = PTR_ERR(handle);\r\ngoto out;\r\n}\r\nei = EXT4_I(inode);\r\ni_data = ei->i_data;\r\nmemset(&lb, 0, sizeof(lb));\r\nmax_entries = inode->i_sb->s_blocksize >> 2;\r\nfor (i = 0; i < EXT4_NDIR_BLOCKS; i++) {\r\nif (i_data[i]) {\r\nretval = update_extent_range(handle, tmp_inode,\r\nle32_to_cpu(i_data[i]), &lb);\r\nif (retval)\r\ngoto err_out;\r\n} else\r\nlb.curr_block++;\r\n}\r\nif (i_data[EXT4_IND_BLOCK]) {\r\nretval = update_ind_extent_range(handle, tmp_inode,\r\nle32_to_cpu(i_data[EXT4_IND_BLOCK]), &lb);\r\nif (retval)\r\ngoto err_out;\r\n} else\r\nlb.curr_block += max_entries;\r\nif (i_data[EXT4_DIND_BLOCK]) {\r\nretval = update_dind_extent_range(handle, tmp_inode,\r\nle32_to_cpu(i_data[EXT4_DIND_BLOCK]), &lb);\r\nif (retval)\r\ngoto err_out;\r\n} else\r\nlb.curr_block += max_entries * max_entries;\r\nif (i_data[EXT4_TIND_BLOCK]) {\r\nretval = update_tind_extent_range(handle, tmp_inode,\r\nle32_to_cpu(i_data[EXT4_TIND_BLOCK]), &lb);\r\nif (retval)\r\ngoto err_out;\r\n}\r\nretval = finish_range(handle, tmp_inode, &lb);\r\nerr_out:\r\nif (retval)\r\nfree_ext_block(handle, tmp_inode);\r\nelse {\r\nretval = ext4_ext_swap_inode_data(handle, inode, tmp_inode);\r\nif (retval)\r\nfree_ext_block(handle, tmp_inode);\r\n}\r\nif (ext4_journal_extend(handle, 1) != 0)\r\next4_journal_restart(handle, 1);\r\ni_size_write(tmp_inode, 0);\r\ntmp_inode->i_blocks = 0;\r\next4_ext_tree_init(handle, tmp_inode);\r\next4_journal_stop(handle);\r\nout:\r\nunlock_new_inode(tmp_inode);\r\niput(tmp_inode);\r\nreturn retval;\r\n}\r\nint ext4_ind_migrate(struct inode *inode)\r\n{\r\nstruct ext4_extent_header *eh;\r\nstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_extent *ex;\r\nunsigned int i, len;\r\next4_fsblk_t blk;\r\nhandle_t *handle;\r\nint ret;\r\nif (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,\r\nEXT4_FEATURE_INCOMPAT_EXTENTS) ||\r\n(!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\r\nreturn -EINVAL;\r\nif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\r\nEXT4_FEATURE_RO_COMPAT_BIGALLOC))\r\nreturn -EOPNOTSUPP;\r\nhandle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\ndown_write(&EXT4_I(inode)->i_data_sem);\r\nret = ext4_ext_check_inode(inode);\r\nif (ret)\r\ngoto errout;\r\neh = ext_inode_hdr(inode);\r\nex = EXT_FIRST_EXTENT(eh);\r\nif (ext4_blocks_count(es) > EXT4_MAX_BLOCK_FILE_PHYS ||\r\neh->eh_depth != 0 || le16_to_cpu(eh->eh_entries) > 1) {\r\nret = -EOPNOTSUPP;\r\ngoto errout;\r\n}\r\nif (eh->eh_entries == 0)\r\nblk = len = 0;\r\nelse {\r\nlen = le16_to_cpu(ex->ee_len);\r\nblk = ext4_ext_pblock(ex);\r\nif (len > EXT4_NDIR_BLOCKS) {\r\nret = -EOPNOTSUPP;\r\ngoto errout;\r\n}\r\n}\r\next4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\r\nmemset(ei->i_data, 0, sizeof(ei->i_data));\r\nfor (i=0; i < len; i++)\r\nei->i_data[i] = cpu_to_le32(blk++);\r\next4_mark_inode_dirty(handle, inode);\r\nerrout:\r\next4_journal_stop(handle);\r\nup_write(&EXT4_I(inode)->i_data_sem);\r\nreturn ret;\r\n}
