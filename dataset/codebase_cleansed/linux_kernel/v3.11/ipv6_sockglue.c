int ip6_ra_control(struct sock *sk, int sel)\r\n{\r\nstruct ip6_ra_chain *ra, *new_ra, **rap;\r\nif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num != IPPROTO_RAW)\r\nreturn -ENOPROTOOPT;\r\nnew_ra = (sel>=0) ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\r\nwrite_lock_bh(&ip6_ra_lock);\r\nfor (rap = &ip6_ra_chain; (ra=*rap) != NULL; rap = &ra->next) {\r\nif (ra->sk == sk) {\r\nif (sel>=0) {\r\nwrite_unlock_bh(&ip6_ra_lock);\r\nkfree(new_ra);\r\nreturn -EADDRINUSE;\r\n}\r\n*rap = ra->next;\r\nwrite_unlock_bh(&ip6_ra_lock);\r\nsock_put(sk);\r\nkfree(ra);\r\nreturn 0;\r\n}\r\n}\r\nif (new_ra == NULL) {\r\nwrite_unlock_bh(&ip6_ra_lock);\r\nreturn -ENOBUFS;\r\n}\r\nnew_ra->sk = sk;\r\nnew_ra->sel = sel;\r\nnew_ra->next = ra;\r\n*rap = new_ra;\r\nsock_hold(sk);\r\nwrite_unlock_bh(&ip6_ra_lock);\r\nreturn 0;\r\n}\r\nstatic\r\nstruct ipv6_txoptions *ipv6_update_options(struct sock *sk,\r\nstruct ipv6_txoptions *opt)\r\n{\r\nif (inet_sk(sk)->is_icsk) {\r\nif (opt &&\r\n!((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\r\ninet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nicsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\r\nicsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n}\r\nopt = xchg(&inet6_sk(sk)->opt, opt);\r\n} else {\r\nspin_lock(&sk->sk_dst_lock);\r\nopt = xchg(&inet6_sk(sk)->opt, opt);\r\nspin_unlock(&sk->sk_dst_lock);\r\n}\r\nsk_dst_reset(sk);\r\nreturn opt;\r\n}\r\nstatic int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nint val, valbool;\r\nint retv = -ENOPROTOOPT;\r\nif (optval == NULL)\r\nval=0;\r\nelse {\r\nif (optlen >= sizeof(int)) {\r\nif (get_user(val, (int __user *) optval))\r\nreturn -EFAULT;\r\n} else\r\nval = 0;\r\n}\r\nvalbool = (val!=0);\r\nif (ip6_mroute_opt(optname))\r\nreturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase IPV6_ADDRFORM:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val == PF_INET) {\r\nstruct ipv6_txoptions *opt;\r\nstruct sk_buff *pktopt;\r\nif (sk->sk_type == SOCK_RAW)\r\nbreak;\r\nif (sk->sk_protocol == IPPROTO_UDP ||\r\nsk->sk_protocol == IPPROTO_UDPLITE) {\r\nstruct udp_sock *up = udp_sk(sk);\r\nif (up->pending == AF_INET6) {\r\nretv = -EBUSY;\r\nbreak;\r\n}\r\n} else if (sk->sk_protocol != IPPROTO_TCP)\r\nbreak;\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nretv = -ENOTCONN;\r\nbreak;\r\n}\r\nif (ipv6_only_sock(sk) ||\r\n!ipv6_addr_v4mapped(&np->daddr)) {\r\nretv = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\nfl6_free_socklist(sk);\r\nipv6_sock_mc_close(sk);\r\nsk_refcnt_debug_dec(sk);\r\nif (sk->sk_protocol == IPPROTO_TCP) {\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nlocal_bh_disable();\r\nsock_prot_inuse_add(net, sk->sk_prot, -1);\r\nsock_prot_inuse_add(net, &tcp_prot, 1);\r\nlocal_bh_enable();\r\nsk->sk_prot = &tcp_prot;\r\nicsk->icsk_af_ops = &ipv4_specific;\r\nsk->sk_socket->ops = &inet_stream_ops;\r\nsk->sk_family = PF_INET;\r\ntcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\r\n} else {\r\nstruct proto *prot = &udp_prot;\r\nif (sk->sk_protocol == IPPROTO_UDPLITE)\r\nprot = &udplite_prot;\r\nlocal_bh_disable();\r\nsock_prot_inuse_add(net, sk->sk_prot, -1);\r\nsock_prot_inuse_add(net, prot, 1);\r\nlocal_bh_enable();\r\nsk->sk_prot = prot;\r\nsk->sk_socket->ops = &inet_dgram_ops;\r\nsk->sk_family = PF_INET;\r\n}\r\nopt = xchg(&np->opt, NULL);\r\nif (opt)\r\nsock_kfree_s(sk, opt, opt->tot_len);\r\npktopt = xchg(&np->pktoptions, NULL);\r\nkfree_skb(pktopt);\r\nsk->sk_destruct = inet_sock_destruct;\r\nsk_refcnt_debug_inc(sk);\r\nmodule_put(THIS_MODULE);\r\nretv = 0;\r\nbreak;\r\n}\r\ngoto e_inval;\r\ncase IPV6_V6ONLY:\r\nif (optlen < sizeof(int) ||\r\ninet_sk(sk)->inet_num)\r\ngoto e_inval;\r\nnp->ipv6only = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVPKTINFO:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxinfo = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_2292PKTINFO:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxoinfo = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVHOPLIMIT:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxhlim = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_2292HOPLIMIT:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxohlim = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVRTHDR:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.srcrt = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_2292RTHDR:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.osrcrt = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVHOPOPTS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.hopopts = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_2292HOPOPTS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.ohopopts = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVDSTOPTS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.dstopts = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_2292DSTOPTS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.odstopts = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_TCLASS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val < -1 || val > 0xff)\r\ngoto e_inval;\r\nif (val == -1)\r\nval = 0;\r\nnp->tclass = val;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVTCLASS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxtclass = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_FLOWINFO:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxflow = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVPATHMTU:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxpmtu = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_TRANSPARENT:\r\nif (valbool && !ns_capable(net->user_ns, CAP_NET_ADMIN) &&\r\n!ns_capable(net->user_ns, CAP_NET_RAW)) {\r\nretv = -EPERM;\r\nbreak;\r\n}\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\ninet_sk(sk)->transparent = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVORIGDSTADDR:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->rxopt.bits.rxorigdstaddr = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_HOPOPTS:\r\ncase IPV6_RTHDRDSTOPTS:\r\ncase IPV6_RTHDR:\r\ncase IPV6_DSTOPTS:\r\n{\r\nstruct ipv6_txoptions *opt;\r\nif (optlen == 0)\r\noptval = NULL;\r\nelse if (optval == NULL)\r\ngoto e_inval;\r\nelse if (optlen < sizeof(struct ipv6_opt_hdr) ||\r\noptlen & 0x7 || optlen > 8 * 255)\r\ngoto e_inval;\r\nretv = -EPERM;\r\nif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\r\nbreak;\r\nopt = ipv6_renew_options(sk, np->opt, optname,\r\n(struct ipv6_opt_hdr __user *)optval,\r\noptlen);\r\nif (IS_ERR(opt)) {\r\nretv = PTR_ERR(opt);\r\nbreak;\r\n}\r\nretv = -EINVAL;\r\nif (optname == IPV6_RTHDR && opt && opt->srcrt) {\r\nstruct ipv6_rt_hdr *rthdr = opt->srcrt;\r\nswitch (rthdr->type) {\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\ncase IPV6_SRCRT_TYPE_2:\r\nif (rthdr->hdrlen != 2 ||\r\nrthdr->segments_left != 1)\r\ngoto sticky_done;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto sticky_done;\r\n}\r\n}\r\nretv = 0;\r\nopt = ipv6_update_options(sk, opt);\r\nsticky_done:\r\nif (opt)\r\nsock_kfree_s(sk, opt, opt->tot_len);\r\nbreak;\r\n}\r\ncase IPV6_PKTINFO:\r\n{\r\nstruct in6_pktinfo pkt;\r\nif (optlen == 0)\r\ngoto e_inval;\r\nelse if (optlen < sizeof(struct in6_pktinfo) || optval == NULL)\r\ngoto e_inval;\r\nif (copy_from_user(&pkt, optval, sizeof(struct in6_pktinfo))) {\r\nretv = -EFAULT;\r\nbreak;\r\n}\r\nif (sk->sk_bound_dev_if && pkt.ipi6_ifindex != sk->sk_bound_dev_if)\r\ngoto e_inval;\r\nnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\r\nnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\r\nretv = 0;\r\nbreak;\r\n}\r\ncase IPV6_2292PKTOPTIONS:\r\n{\r\nstruct ipv6_txoptions *opt = NULL;\r\nstruct msghdr msg;\r\nstruct flowi6 fl6;\r\nint junk;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nfl6.flowi6_mark = sk->sk_mark;\r\nif (optlen == 0)\r\ngoto update;\r\nretv = -EINVAL;\r\nif (optlen > 64*1024)\r\nbreak;\r\nopt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\r\nretv = -ENOBUFS;\r\nif (opt == NULL)\r\nbreak;\r\nmemset(opt, 0, sizeof(*opt));\r\nopt->tot_len = sizeof(*opt) + optlen;\r\nretv = -EFAULT;\r\nif (copy_from_user(opt+1, optval, optlen))\r\ngoto done;\r\nmsg.msg_controllen = optlen;\r\nmsg.msg_control = (void*)(opt+1);\r\nretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, opt, &junk,\r\n&junk, &junk);\r\nif (retv)\r\ngoto done;\r\nupdate:\r\nretv = 0;\r\nopt = ipv6_update_options(sk, opt);\r\ndone:\r\nif (opt)\r\nsock_kfree_s(sk, opt, opt->tot_len);\r\nbreak;\r\n}\r\ncase IPV6_UNICAST_HOPS:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val > 255 || val < -1)\r\ngoto e_inval;\r\nnp->hop_limit = val;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_MULTICAST_HOPS:\r\nif (sk->sk_type == SOCK_STREAM)\r\nbreak;\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val > 255 || val < -1)\r\ngoto e_inval;\r\nnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\r\nretv = 0;\r\nbreak;\r\ncase IPV6_MULTICAST_LOOP:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val != valbool)\r\ngoto e_inval;\r\nnp->mc_loop = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_UNICAST_IF:\r\n{\r\nstruct net_device *dev = NULL;\r\nint ifindex;\r\nif (optlen != sizeof(int))\r\ngoto e_inval;\r\nifindex = (__force int)ntohl((__force __be32)val);\r\nif (ifindex == 0) {\r\nnp->ucast_oif = 0;\r\nretv = 0;\r\nbreak;\r\n}\r\ndev = dev_get_by_index(net, ifindex);\r\nretv = -EADDRNOTAVAIL;\r\nif (!dev)\r\nbreak;\r\ndev_put(dev);\r\nretv = -EINVAL;\r\nif (sk->sk_bound_dev_if)\r\nbreak;\r\nnp->ucast_oif = ifindex;\r\nretv = 0;\r\nbreak;\r\n}\r\ncase IPV6_MULTICAST_IF:\r\nif (sk->sk_type == SOCK_STREAM)\r\nbreak;\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val) {\r\nstruct net_device *dev;\r\nif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != val)\r\ngoto e_inval;\r\ndev = dev_get_by_index(net, val);\r\nif (!dev) {\r\nretv = -ENODEV;\r\nbreak;\r\n}\r\ndev_put(dev);\r\n}\r\nnp->mcast_oif = val;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_ADD_MEMBERSHIP:\r\ncase IPV6_DROP_MEMBERSHIP:\r\n{\r\nstruct ipv6_mreq mreq;\r\nif (optlen < sizeof(struct ipv6_mreq))\r\ngoto e_inval;\r\nretv = -EPROTO;\r\nif (inet_sk(sk)->is_icsk)\r\nbreak;\r\nretv = -EFAULT;\r\nif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\r\nbreak;\r\nif (optname == IPV6_ADD_MEMBERSHIP)\r\nretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\r\nelse\r\nretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\r\nbreak;\r\n}\r\ncase IPV6_JOIN_ANYCAST:\r\ncase IPV6_LEAVE_ANYCAST:\r\n{\r\nstruct ipv6_mreq mreq;\r\nif (optlen < sizeof(struct ipv6_mreq))\r\ngoto e_inval;\r\nretv = -EFAULT;\r\nif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\r\nbreak;\r\nif (optname == IPV6_JOIN_ANYCAST)\r\nretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\r\nelse\r\nretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\r\nbreak;\r\n}\r\ncase MCAST_JOIN_GROUP:\r\ncase MCAST_LEAVE_GROUP:\r\n{\r\nstruct group_req greq;\r\nstruct sockaddr_in6 *psin6;\r\nif (optlen < sizeof(struct group_req))\r\ngoto e_inval;\r\nretv = -EFAULT;\r\nif (copy_from_user(&greq, optval, sizeof(struct group_req)))\r\nbreak;\r\nif (greq.gr_group.ss_family != AF_INET6) {\r\nretv = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\npsin6 = (struct sockaddr_in6 *)&greq.gr_group;\r\nif (optname == MCAST_JOIN_GROUP)\r\nretv = ipv6_sock_mc_join(sk, greq.gr_interface,\r\n&psin6->sin6_addr);\r\nelse\r\nretv = ipv6_sock_mc_drop(sk, greq.gr_interface,\r\n&psin6->sin6_addr);\r\nbreak;\r\n}\r\ncase MCAST_JOIN_SOURCE_GROUP:\r\ncase MCAST_LEAVE_SOURCE_GROUP:\r\ncase MCAST_BLOCK_SOURCE:\r\ncase MCAST_UNBLOCK_SOURCE:\r\n{\r\nstruct group_source_req greqs;\r\nint omode, add;\r\nif (optlen < sizeof(struct group_source_req))\r\ngoto e_inval;\r\nif (copy_from_user(&greqs, optval, sizeof(greqs))) {\r\nretv = -EFAULT;\r\nbreak;\r\n}\r\nif (greqs.gsr_group.ss_family != AF_INET6 ||\r\ngreqs.gsr_source.ss_family != AF_INET6) {\r\nretv = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\nif (optname == MCAST_BLOCK_SOURCE) {\r\nomode = MCAST_EXCLUDE;\r\nadd = 1;\r\n} else if (optname == MCAST_UNBLOCK_SOURCE) {\r\nomode = MCAST_EXCLUDE;\r\nadd = 0;\r\n} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\r\nstruct sockaddr_in6 *psin6;\r\npsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;\r\nretv = ipv6_sock_mc_join(sk, greqs.gsr_interface,\r\n&psin6->sin6_addr);\r\nif (retv && retv != -EADDRINUSE)\r\nbreak;\r\nomode = MCAST_INCLUDE;\r\nadd = 1;\r\n} else {\r\nomode = MCAST_INCLUDE;\r\nadd = 0;\r\n}\r\nretv = ip6_mc_source(add, omode, sk, &greqs);\r\nbreak;\r\n}\r\ncase MCAST_MSFILTER:\r\n{\r\nstruct group_filter *gsf;\r\nif (optlen < GROUP_FILTER_SIZE(0))\r\ngoto e_inval;\r\nif (optlen > sysctl_optmem_max) {\r\nretv = -ENOBUFS;\r\nbreak;\r\n}\r\ngsf = kmalloc(optlen,GFP_KERNEL);\r\nif (!gsf) {\r\nretv = -ENOBUFS;\r\nbreak;\r\n}\r\nretv = -EFAULT;\r\nif (copy_from_user(gsf, optval, optlen)) {\r\nkfree(gsf);\r\nbreak;\r\n}\r\nif (gsf->gf_numsrc >= 0x1ffffffU ||\r\ngsf->gf_numsrc > sysctl_mld_max_msf) {\r\nkfree(gsf);\r\nretv = -ENOBUFS;\r\nbreak;\r\n}\r\nif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\r\nkfree(gsf);\r\nretv = -EINVAL;\r\nbreak;\r\n}\r\nretv = ip6_mc_msfilter(sk, gsf);\r\nkfree(gsf);\r\nbreak;\r\n}\r\ncase IPV6_ROUTER_ALERT:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nretv = ip6_ra_control(sk, val);\r\nbreak;\r\ncase IPV6_MTU_DISCOVER:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_PROBE)\r\ngoto e_inval;\r\nnp->pmtudisc = val;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_MTU:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val && val < IPV6_MIN_MTU)\r\ngoto e_inval;\r\nnp->frag_size = val;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_RECVERR:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->recverr = valbool;\r\nif (!val)\r\nskb_queue_purge(&sk->sk_error_queue);\r\nretv = 0;\r\nbreak;\r\ncase IPV6_FLOWINFO_SEND:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nnp->sndflow = valbool;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_FLOWLABEL_MGR:\r\nretv = ipv6_flowlabel_opt(sk, optval, optlen);\r\nbreak;\r\ncase IPV6_IPSEC_POLICY:\r\ncase IPV6_XFRM_POLICY:\r\nretv = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nbreak;\r\nretv = xfrm_user_policy(sk, optname, optval, optlen);\r\nbreak;\r\ncase IPV6_ADDR_PREFERENCES:\r\n{\r\nunsigned int pref = 0;\r\nunsigned int prefmask = ~0;\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nretv = -EINVAL;\r\nswitch (val & (IPV6_PREFER_SRC_PUBLIC|\r\nIPV6_PREFER_SRC_TMP|\r\nIPV6_PREFER_SRC_PUBTMP_DEFAULT)) {\r\ncase IPV6_PREFER_SRC_PUBLIC:\r\npref |= IPV6_PREFER_SRC_PUBLIC;\r\nbreak;\r\ncase IPV6_PREFER_SRC_TMP:\r\npref |= IPV6_PREFER_SRC_TMP;\r\nbreak;\r\ncase IPV6_PREFER_SRC_PUBTMP_DEFAULT:\r\nbreak;\r\ncase 0:\r\ngoto pref_skip_pubtmp;\r\ndefault:\r\ngoto e_inval;\r\n}\r\nprefmask &= ~(IPV6_PREFER_SRC_PUBLIC|\r\nIPV6_PREFER_SRC_TMP);\r\npref_skip_pubtmp:\r\nswitch (val & (IPV6_PREFER_SRC_HOME|IPV6_PREFER_SRC_COA)) {\r\ncase IPV6_PREFER_SRC_HOME:\r\nbreak;\r\ncase IPV6_PREFER_SRC_COA:\r\npref |= IPV6_PREFER_SRC_COA;\r\ncase 0:\r\ngoto pref_skip_coa;\r\ndefault:\r\ngoto e_inval;\r\n}\r\nprefmask &= ~IPV6_PREFER_SRC_COA;\r\npref_skip_coa:\r\nswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {\r\ncase IPV6_PREFER_SRC_CGA:\r\ncase IPV6_PREFER_SRC_NONCGA:\r\ncase 0:\r\nbreak;\r\ndefault:\r\ngoto e_inval;\r\n}\r\nnp->srcprefs = (np->srcprefs & prefmask) | pref;\r\nretv = 0;\r\nbreak;\r\n}\r\ncase IPV6_MINHOPCOUNT:\r\nif (optlen < sizeof(int))\r\ngoto e_inval;\r\nif (val < 0 || val > 255)\r\ngoto e_inval;\r\nnp->min_hopcount = val;\r\nretv = 0;\r\nbreak;\r\ncase IPV6_DONTFRAG:\r\nnp->dontfrag = valbool;\r\nretv = 0;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn retv;\r\ne_inval:\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nint ipv6_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nint err;\r\nif (level == SOL_IP && sk->sk_type != SOCK_RAW)\r\nreturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\r\nif (level != SOL_IPV6)\r\nreturn -ENOPROTOOPT;\r\nerr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\r\noptname != IPV6_XFRM_POLICY) {\r\nlock_sock(sk);\r\nerr = nf_setsockopt(sk, PF_INET6, optname, optval,\r\noptlen);\r\nrelease_sock(sk);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nint compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nint err;\r\nif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\r\nif (udp_prot.compat_setsockopt != NULL)\r\nreturn udp_prot.compat_setsockopt(sk, level, optname,\r\noptval, optlen);\r\nreturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\r\n}\r\nif (level != SOL_IPV6)\r\nreturn -ENOPROTOOPT;\r\nif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\r\nreturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\r\nipv6_setsockopt);\r\nerr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\r\noptname != IPV6_XFRM_POLICY) {\r\nlock_sock(sk);\r\nerr = compat_nf_setsockopt(sk, PF_INET6, optname,\r\noptval, optlen);\r\nrelease_sock(sk);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic int ipv6_getsockopt_sticky(struct sock *sk, struct ipv6_txoptions *opt,\r\nint optname, char __user *optval, int len)\r\n{\r\nstruct ipv6_opt_hdr *hdr;\r\nif (!opt)\r\nreturn 0;\r\nswitch(optname) {\r\ncase IPV6_HOPOPTS:\r\nhdr = opt->hopopt;\r\nbreak;\r\ncase IPV6_RTHDRDSTOPTS:\r\nhdr = opt->dst0opt;\r\nbreak;\r\ncase IPV6_RTHDR:\r\nhdr = (struct ipv6_opt_hdr *)opt->srcrt;\r\nbreak;\r\ncase IPV6_DSTOPTS:\r\nhdr = opt->dst1opt;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!hdr)\r\nreturn 0;\r\nlen = min_t(unsigned int, len, ipv6_optlen(hdr));\r\nif (copy_to_user(optval, hdr, len))\r\nreturn -EFAULT;\r\nreturn len;\r\n}\r\nstatic int do_ipv6_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen, unsigned int flags)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nint len;\r\nint val;\r\nif (ip6_mroute_opt(optname))\r\nreturn ip6_mroute_getsockopt(sk, optname, optval, optlen);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nswitch (optname) {\r\ncase IPV6_ADDRFORM:\r\nif (sk->sk_protocol != IPPROTO_UDP &&\r\nsk->sk_protocol != IPPROTO_UDPLITE &&\r\nsk->sk_protocol != IPPROTO_TCP)\r\nreturn -ENOPROTOOPT;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nval = sk->sk_family;\r\nbreak;\r\ncase MCAST_MSFILTER:\r\n{\r\nstruct group_filter gsf;\r\nint err;\r\nif (len < GROUP_FILTER_SIZE(0))\r\nreturn -EINVAL;\r\nif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0)))\r\nreturn -EFAULT;\r\nif (gsf.gf_group.ss_family != AF_INET6)\r\nreturn -EADDRNOTAVAIL;\r\nlock_sock(sk);\r\nerr = ip6_mc_msfget(sk, &gsf,\r\n(struct group_filter __user *)optval, optlen);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\ncase IPV6_2292PKTOPTIONS:\r\n{\r\nstruct msghdr msg;\r\nstruct sk_buff *skb;\r\nif (sk->sk_type != SOCK_STREAM)\r\nreturn -ENOPROTOOPT;\r\nmsg.msg_control = optval;\r\nmsg.msg_controllen = len;\r\nmsg.msg_flags = flags;\r\nlock_sock(sk);\r\nskb = np->pktoptions;\r\nif (skb)\r\natomic_inc(&skb->users);\r\nrelease_sock(sk);\r\nif (skb) {\r\nint err = ip6_datagram_recv_ctl(sk, &msg, skb);\r\nkfree_skb(skb);\r\nif (err)\r\nreturn err;\r\n} else {\r\nif (np->rxopt.bits.rxinfo) {\r\nstruct in6_pktinfo src_info;\r\nsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\r\nnp->sticky_pktinfo.ipi6_ifindex;\r\nsrc_info.ipi6_addr = np->mcast_oif ? np->daddr : np->sticky_pktinfo.ipi6_addr;\r\nput_cmsg(&msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);\r\n}\r\nif (np->rxopt.bits.rxhlim) {\r\nint hlim = np->mcast_hops;\r\nput_cmsg(&msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\r\n}\r\nif (np->rxopt.bits.rxtclass) {\r\nint tclass = np->rcv_tclass;\r\nput_cmsg(&msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\r\n}\r\nif (np->rxopt.bits.rxoinfo) {\r\nstruct in6_pktinfo src_info;\r\nsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\r\nnp->sticky_pktinfo.ipi6_ifindex;\r\nsrc_info.ipi6_addr = np->mcast_oif ? np->daddr : np->sticky_pktinfo.ipi6_addr;\r\nput_cmsg(&msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\r\n}\r\nif (np->rxopt.bits.rxohlim) {\r\nint hlim = np->mcast_hops;\r\nput_cmsg(&msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\r\n}\r\n}\r\nlen -= msg.msg_controllen;\r\nreturn put_user(len, optlen);\r\n}\r\ncase IPV6_MTU:\r\n{\r\nstruct dst_entry *dst;\r\nval = 0;\r\nrcu_read_lock();\r\ndst = __sk_dst_get(sk);\r\nif (dst)\r\nval = dst_mtu(dst);\r\nrcu_read_unlock();\r\nif (!val)\r\nreturn -ENOTCONN;\r\nbreak;\r\n}\r\ncase IPV6_V6ONLY:\r\nval = np->ipv6only;\r\nbreak;\r\ncase IPV6_RECVPKTINFO:\r\nval = np->rxopt.bits.rxinfo;\r\nbreak;\r\ncase IPV6_2292PKTINFO:\r\nval = np->rxopt.bits.rxoinfo;\r\nbreak;\r\ncase IPV6_RECVHOPLIMIT:\r\nval = np->rxopt.bits.rxhlim;\r\nbreak;\r\ncase IPV6_2292HOPLIMIT:\r\nval = np->rxopt.bits.rxohlim;\r\nbreak;\r\ncase IPV6_RECVRTHDR:\r\nval = np->rxopt.bits.srcrt;\r\nbreak;\r\ncase IPV6_2292RTHDR:\r\nval = np->rxopt.bits.osrcrt;\r\nbreak;\r\ncase IPV6_HOPOPTS:\r\ncase IPV6_RTHDRDSTOPTS:\r\ncase IPV6_RTHDR:\r\ncase IPV6_DSTOPTS:\r\n{\r\nlock_sock(sk);\r\nlen = ipv6_getsockopt_sticky(sk, np->opt,\r\noptname, optval, len);\r\nrelease_sock(sk);\r\nif (len < 0)\r\nreturn len;\r\nreturn put_user(len, optlen);\r\n}\r\ncase IPV6_RECVHOPOPTS:\r\nval = np->rxopt.bits.hopopts;\r\nbreak;\r\ncase IPV6_2292HOPOPTS:\r\nval = np->rxopt.bits.ohopopts;\r\nbreak;\r\ncase IPV6_RECVDSTOPTS:\r\nval = np->rxopt.bits.dstopts;\r\nbreak;\r\ncase IPV6_2292DSTOPTS:\r\nval = np->rxopt.bits.odstopts;\r\nbreak;\r\ncase IPV6_TCLASS:\r\nval = np->tclass;\r\nbreak;\r\ncase IPV6_RECVTCLASS:\r\nval = np->rxopt.bits.rxtclass;\r\nbreak;\r\ncase IPV6_FLOWINFO:\r\nval = np->rxopt.bits.rxflow;\r\nbreak;\r\ncase IPV6_RECVPATHMTU:\r\nval = np->rxopt.bits.rxpmtu;\r\nbreak;\r\ncase IPV6_PATHMTU:\r\n{\r\nstruct dst_entry *dst;\r\nstruct ip6_mtuinfo mtuinfo;\r\nif (len < sizeof(mtuinfo))\r\nreturn -EINVAL;\r\nlen = sizeof(mtuinfo);\r\nmemset(&mtuinfo, 0, sizeof(mtuinfo));\r\nrcu_read_lock();\r\ndst = __sk_dst_get(sk);\r\nif (dst)\r\nmtuinfo.ip6m_mtu = dst_mtu(dst);\r\nrcu_read_unlock();\r\nif (!mtuinfo.ip6m_mtu)\r\nreturn -ENOTCONN;\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (copy_to_user(optval, &mtuinfo, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\nbreak;\r\n}\r\ncase IPV6_TRANSPARENT:\r\nval = inet_sk(sk)->transparent;\r\nbreak;\r\ncase IPV6_RECVORIGDSTADDR:\r\nval = np->rxopt.bits.rxorigdstaddr;\r\nbreak;\r\ncase IPV6_UNICAST_HOPS:\r\ncase IPV6_MULTICAST_HOPS:\r\n{\r\nstruct dst_entry *dst;\r\nif (optname == IPV6_UNICAST_HOPS)\r\nval = np->hop_limit;\r\nelse\r\nval = np->mcast_hops;\r\nif (val < 0) {\r\nrcu_read_lock();\r\ndst = __sk_dst_get(sk);\r\nif (dst)\r\nval = ip6_dst_hoplimit(dst);\r\nrcu_read_unlock();\r\n}\r\nif (val < 0)\r\nval = sock_net(sk)->ipv6.devconf_all->hop_limit;\r\nbreak;\r\n}\r\ncase IPV6_MULTICAST_LOOP:\r\nval = np->mc_loop;\r\nbreak;\r\ncase IPV6_MULTICAST_IF:\r\nval = np->mcast_oif;\r\nbreak;\r\ncase IPV6_UNICAST_IF:\r\nval = (__force int)htonl((__u32) np->ucast_oif);\r\nbreak;\r\ncase IPV6_MTU_DISCOVER:\r\nval = np->pmtudisc;\r\nbreak;\r\ncase IPV6_RECVERR:\r\nval = np->recverr;\r\nbreak;\r\ncase IPV6_FLOWINFO_SEND:\r\nval = np->sndflow;\r\nbreak;\r\ncase IPV6_ADDR_PREFERENCES:\r\nval = 0;\r\nif (np->srcprefs & IPV6_PREFER_SRC_TMP)\r\nval |= IPV6_PREFER_SRC_TMP;\r\nelse if (np->srcprefs & IPV6_PREFER_SRC_PUBLIC)\r\nval |= IPV6_PREFER_SRC_PUBLIC;\r\nelse {\r\nval |= IPV6_PREFER_SRC_PUBTMP_DEFAULT;\r\n}\r\nif (np->srcprefs & IPV6_PREFER_SRC_COA)\r\nval |= IPV6_PREFER_SRC_COA;\r\nelse\r\nval |= IPV6_PREFER_SRC_HOME;\r\nbreak;\r\ncase IPV6_MINHOPCOUNT:\r\nval = np->min_hopcount;\r\nbreak;\r\ncase IPV6_DONTFRAG:\r\nval = np->dontfrag;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nlen = min_t(unsigned int, sizeof(int), len);\r\nif(put_user(len, optlen))\r\nreturn -EFAULT;\r\nif(copy_to_user(optval,&val,len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nint err;\r\nif (level == SOL_IP && sk->sk_type != SOCK_RAW)\r\nreturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\r\nif(level != SOL_IPV6)\r\nreturn -ENOPROTOOPT;\r\nerr = do_ipv6_getsockopt(sk, level, optname, optval, optlen, 0);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\r\nint len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nerr = nf_getsockopt(sk, PF_INET6, optname, optval,\r\n&len);\r\nrelease_sock(sk);\r\nif (err >= 0)\r\nerr = put_user(len, optlen);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nint compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nint err;\r\nif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\r\nif (udp_prot.compat_getsockopt != NULL)\r\nreturn udp_prot.compat_getsockopt(sk, level, optname,\r\noptval, optlen);\r\nreturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\r\n}\r\nif (level != SOL_IPV6)\r\nreturn -ENOPROTOOPT;\r\nif (optname == MCAST_MSFILTER)\r\nreturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\r\nipv6_getsockopt);\r\nerr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\r\nMSG_CMSG_COMPAT);\r\n#ifdef CONFIG_NETFILTER\r\nif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\r\nint len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nerr = compat_nf_getsockopt(sk, PF_INET6,\r\noptname, optval, &len);\r\nrelease_sock(sk);\r\nif (err >= 0)\r\nerr = put_user(len, optlen);\r\n}\r\n#endif\r\nreturn err;\r\n}
