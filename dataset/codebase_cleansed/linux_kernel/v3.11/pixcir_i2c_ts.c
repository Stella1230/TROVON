static void pixcir_ts_poscheck(struct pixcir_i2c_ts_data *data)\r\n{\r\nstruct pixcir_i2c_ts_data *tsdata = data;\r\nu8 rdbuf[10], wrbuf[1] = { 0 };\r\nu8 touch;\r\nint ret;\r\nret = i2c_master_send(tsdata->client, wrbuf, sizeof(wrbuf));\r\nif (ret != sizeof(wrbuf)) {\r\ndev_err(&tsdata->client->dev,\r\n"%s: i2c_master_send failed(), ret=%d\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\nret = i2c_master_recv(tsdata->client, rdbuf, sizeof(rdbuf));\r\nif (ret != sizeof(rdbuf)) {\r\ndev_err(&tsdata->client->dev,\r\n"%s: i2c_master_recv failed(), ret=%d\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\ntouch = rdbuf[0];\r\nif (touch) {\r\nu16 posx1 = (rdbuf[3] << 8) | rdbuf[2];\r\nu16 posy1 = (rdbuf[5] << 8) | rdbuf[4];\r\nu16 posx2 = (rdbuf[7] << 8) | rdbuf[6];\r\nu16 posy2 = (rdbuf[9] << 8) | rdbuf[8];\r\ninput_report_key(tsdata->input, BTN_TOUCH, 1);\r\ninput_report_abs(tsdata->input, ABS_X, posx1);\r\ninput_report_abs(tsdata->input, ABS_Y, posy1);\r\ninput_report_abs(tsdata->input, ABS_MT_POSITION_X, posx1);\r\ninput_report_abs(tsdata->input, ABS_MT_POSITION_Y, posy1);\r\ninput_mt_sync(tsdata->input);\r\nif (touch == 2) {\r\ninput_report_abs(tsdata->input,\r\nABS_MT_POSITION_X, posx2);\r\ninput_report_abs(tsdata->input,\r\nABS_MT_POSITION_Y, posy2);\r\ninput_mt_sync(tsdata->input);\r\n}\r\n} else {\r\ninput_report_key(tsdata->input, BTN_TOUCH, 0);\r\n}\r\ninput_sync(tsdata->input);\r\n}\r\nstatic irqreturn_t pixcir_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct pixcir_i2c_ts_data *tsdata = dev_id;\r\nwhile (!tsdata->exiting) {\r\npixcir_ts_poscheck(tsdata);\r\nif (tsdata->chip->attb_read_val())\r\nbreak;\r\nmsleep(20);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pixcir_i2c_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int pixcir_i2c_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int pixcir_i2c_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct pixcir_ts_platform_data *pdata = client->dev.platform_data;\r\nstruct pixcir_i2c_ts_data *tsdata;\r\nstruct input_dev *input;\r\nint error;\r\nif (!pdata) {\r\ndev_err(&client->dev, "platform data not defined\n");\r\nreturn -EINVAL;\r\n}\r\ntsdata = kzalloc(sizeof(*tsdata), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!tsdata || !input) {\r\ndev_err(&client->dev, "Failed to allocate driver data!\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntsdata->client = client;\r\ntsdata->input = input;\r\ntsdata->chip = pdata;\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &client->dev;\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\ninput_set_abs_params(input, ABS_X, 0, pdata->x_max, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, pdata->y_max, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, pdata->x_max, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, pdata->y_max, 0, 0);\r\ninput_set_drvdata(input, tsdata);\r\nerror = request_threaded_irq(client->irq, NULL, pixcir_ts_isr,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->name, tsdata);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to request touchscreen IRQ.\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, tsdata);\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, tsdata);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(tsdata);\r\nreturn error;\r\n}\r\nstatic int pixcir_i2c_ts_remove(struct i2c_client *client)\r\n{\r\nstruct pixcir_i2c_ts_data *tsdata = i2c_get_clientdata(client);\r\ndevice_init_wakeup(&client->dev, 0);\r\ntsdata->exiting = true;\r\nmb();\r\nfree_irq(client->irq, tsdata);\r\ninput_unregister_device(tsdata->input);\r\nkfree(tsdata);\r\nreturn 0;\r\n}
