static int show_latency(struct seq_file *m, void *v)\r\n{\r\nu64 cpuclk, avg, max, min;\r\nstruct latency_info curr_li = li;\r\ncpuclk = octeon_get_clock_rate();\r\nmax = (curr_li.max_latency * 1000000000) / cpuclk;\r\nmin = (curr_li.min_latency * 1000000000) / cpuclk;\r\navg = (curr_li.latency_sum * 1000000000) / (cpuclk * curr_li.interrupt_cnt);\r\nseq_printf(m, "cnt: %10lld, avg: %7lld ns, max: %7lld ns, min: %7lld ns\n",\r\ncurr_li.interrupt_cnt, avg, max, min);\r\nreturn 0;\r\n}\r\nstatic int oct_ilm_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_latency, NULL);\r\n}\r\nstatic int reset_statistics(void *data, u64 value)\r\n{\r\nreset_stats = true;\r\nreturn 0;\r\n}\r\nstatic int init_debufs(void)\r\n{\r\nstruct dentry *show_dentry;\r\ndir = debugfs_create_dir("oct_ilm", 0);\r\nif (!dir) {\r\npr_err("oct_ilm: failed to create debugfs entry oct_ilm\n");\r\nreturn -1;\r\n}\r\nshow_dentry = debugfs_create_file("statistics", 0222, dir, NULL,\r\n&oct_ilm_ops);\r\nif (!show_dentry) {\r\npr_err("oct_ilm: failed to create debugfs entry oct_ilm/statistics\n");\r\nreturn -1;\r\n}\r\nshow_dentry = debugfs_create_file("reset", 0222, dir, NULL,\r\n&reset_statistics_ops);\r\nif (!show_dentry) {\r\npr_err("oct_ilm: failed to create debugfs entry oct_ilm/reset\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_latency_info(struct latency_info *li, int startup)\r\n{\r\nint interval = 1;\r\nif (startup) {\r\nli->io_interval = (octeon_get_io_clock_rate() * interval) / 1000;\r\nli->cpu_interval = (octeon_get_clock_rate() * interval) / 1000;\r\n}\r\nli->timer_start1 = 0;\r\nli->timer_start2 = 0;\r\nli->max_latency = 0;\r\nli->min_latency = (u64)-1;\r\nli->latency_sum = 0;\r\nli->interrupt_cnt = 0;\r\n}\r\nstatic void start_timer(int timer, u64 interval)\r\n{\r\nunion cvmx_ciu_timx timx;\r\nunsigned long flags;\r\ntimx.u64 = 0;\r\ntimx.s.one_shot = 1;\r\ntimx.s.len = interval;\r\nraw_local_irq_save(flags);\r\nli.timer_start1 = read_c0_cvmcount();\r\ncvmx_write_csr(CVMX_CIU_TIMX(timer), timx.u64);\r\ntimx.u64 = cvmx_read_csr(CVMX_CIU_TIMX(timer));\r\nli.timer_start2 = read_c0_cvmcount();\r\nraw_local_irq_restore(flags);\r\n}\r\nstatic irqreturn_t cvm_oct_ciu_timer_interrupt(int cpl, void *dev_id)\r\n{\r\nu64 last_latency;\r\nu64 last_int_cnt;\r\nif (reset_stats) {\r\ninit_latency_info(&li, 0);\r\nreset_stats = false;\r\n} else {\r\nlast_int_cnt = read_c0_cvmcount();\r\nlast_latency = last_int_cnt - (li.timer_start1 + li.cpu_interval);\r\nli.interrupt_cnt++;\r\nli.latency_sum += last_latency;\r\nif (last_latency > li.max_latency)\r\nli.max_latency = last_latency;\r\nif (last_latency < li.min_latency)\r\nli.min_latency = last_latency;\r\n}\r\nstart_timer(TIMER_NUM, li.io_interval);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void disable_timer(int timer)\r\n{\r\nunion cvmx_ciu_timx timx;\r\ntimx.s.one_shot = 0;\r\ntimx.s.len = 0;\r\ncvmx_write_csr(CVMX_CIU_TIMX(timer), timx.u64);\r\ntimx.u64 = cvmx_read_csr(CVMX_CIU_TIMX(timer));\r\n}\r\nstatic __init int oct_ilm_module_init(void)\r\n{\r\nint rc;\r\nint irq = OCTEON_IRQ_TIMER0 + TIMER_NUM;\r\nrc = init_debufs();\r\nif (rc) {\r\nWARN(1, "Could not create debugfs entries");\r\nreturn rc;\r\n}\r\nrc = request_irq(irq, cvm_oct_ciu_timer_interrupt, IRQF_NO_THREAD,\r\n"oct_ilm", 0);\r\nif (rc) {\r\nWARN(1, "Could not acquire IRQ %d", irq);\r\ngoto err_irq;\r\n}\r\ninit_latency_info(&li, 1);\r\nstart_timer(TIMER_NUM, li.io_interval);\r\nreturn 0;\r\nerr_irq:\r\ndebugfs_remove_recursive(dir);\r\nreturn rc;\r\n}\r\nstatic __exit void oct_ilm_module_exit(void)\r\n{\r\ndisable_timer(TIMER_NUM);\r\nif (dir)\r\ndebugfs_remove_recursive(dir);\r\nfree_irq(OCTEON_IRQ_TIMER0 + TIMER_NUM, 0);\r\n}
