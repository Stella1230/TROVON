static void _write_clktrctrl(u8 c, s16 module, u32 mask)\r\n{\r\nu32 v;\r\nv = omap2_cm_read_mod_reg(module, OMAP2_CM_CLKSTCTRL);\r\nv &= ~mask;\r\nv |= c << __ffs(mask);\r\nomap2_cm_write_mod_reg(v, module, OMAP2_CM_CLKSTCTRL);\r\n}\r\nbool omap2xxx_cm_is_clkdm_in_hwsup(s16 module, u32 mask)\r\n{\r\nu32 v;\r\nv = omap2_cm_read_mod_reg(module, OMAP2_CM_CLKSTCTRL);\r\nv &= mask;\r\nv >>= __ffs(mask);\r\nreturn (v == OMAP24XX_CLKSTCTRL_ENABLE_AUTO) ? 1 : 0;\r\n}\r\nvoid omap2xxx_cm_clkdm_enable_hwsup(s16 module, u32 mask)\r\n{\r\n_write_clktrctrl(OMAP24XX_CLKSTCTRL_ENABLE_AUTO, module, mask);\r\n}\r\nvoid omap2xxx_cm_clkdm_disable_hwsup(s16 module, u32 mask)\r\n{\r\n_write_clktrctrl(OMAP24XX_CLKSTCTRL_DISABLE_AUTO, module, mask);\r\n}\r\nstatic void _omap2xxx_set_dpll_autoidle(u8 m)\r\n{\r\nu32 v;\r\nv = omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);\r\nv &= ~OMAP24XX_AUTO_DPLL_MASK;\r\nv |= m << OMAP24XX_AUTO_DPLL_SHIFT;\r\nomap2_cm_write_mod_reg(v, PLL_MOD, CM_AUTOIDLE);\r\n}\r\nvoid omap2xxx_cm_set_dpll_disable_autoidle(void)\r\n{\r\n_omap2xxx_set_dpll_autoidle(OMAP2XXX_DPLL_AUTOIDLE_LOW_POWER_STOP);\r\n}\r\nvoid omap2xxx_cm_set_dpll_auto_low_power_stop(void)\r\n{\r\n_omap2xxx_set_dpll_autoidle(DPLL_AUTOIDLE_DISABLE);\r\n}\r\nstatic void _omap2xxx_set_apll_autoidle(u8 m, u32 mask)\r\n{\r\nu32 v;\r\nv = omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);\r\nv &= ~mask;\r\nv |= m << __ffs(mask);\r\nomap2_cm_write_mod_reg(v, PLL_MOD, CM_AUTOIDLE);\r\n}\r\nvoid omap2xxx_cm_set_apll54_disable_autoidle(void)\r\n{\r\n_omap2xxx_set_apll_autoidle(OMAP2XXX_APLL_AUTOIDLE_LOW_POWER_STOP,\r\nOMAP24XX_AUTO_54M_MASK);\r\n}\r\nvoid omap2xxx_cm_set_apll54_auto_low_power_stop(void)\r\n{\r\n_omap2xxx_set_apll_autoidle(OMAP2XXX_APLL_AUTOIDLE_DISABLE,\r\nOMAP24XX_AUTO_54M_MASK);\r\n}\r\nvoid omap2xxx_cm_set_apll96_disable_autoidle(void)\r\n{\r\n_omap2xxx_set_apll_autoidle(OMAP2XXX_APLL_AUTOIDLE_LOW_POWER_STOP,\r\nOMAP24XX_AUTO_96M_MASK);\r\n}\r\nvoid omap2xxx_cm_set_apll96_auto_low_power_stop(void)\r\n{\r\n_omap2xxx_set_apll_autoidle(OMAP2XXX_APLL_AUTOIDLE_DISABLE,\r\nOMAP24XX_AUTO_96M_MASK);\r\n}\r\nstatic int _omap2xxx_apll_enable(u8 enable_bit, u8 status_bit)\r\n{\r\nu32 v, m;\r\nm = EN_APLL_LOCKED << enable_bit;\r\nv = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);\r\nif (v & m)\r\nreturn 0;\r\nv |= m;\r\nomap2_cm_write_mod_reg(v, PLL_MOD, CM_CLKEN);\r\nomap2xxx_cm_wait_module_ready(PLL_MOD, 1, status_bit);\r\nreturn 0;\r\n}\r\nstatic void _omap2xxx_apll_disable(u8 enable_bit)\r\n{\r\nu32 v;\r\nv = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);\r\nv &= ~(EN_APLL_LOCKED << enable_bit);\r\nomap2_cm_write_mod_reg(v, PLL_MOD, CM_CLKEN);\r\n}\r\nint omap2xxx_cm_apll54_enable(void)\r\n{\r\nreturn _omap2xxx_apll_enable(OMAP24XX_EN_54M_PLL_SHIFT,\r\nOMAP24XX_ST_54M_APLL_SHIFT);\r\n}\r\nint omap2xxx_cm_apll96_enable(void)\r\n{\r\nreturn _omap2xxx_apll_enable(OMAP24XX_EN_96M_PLL_SHIFT,\r\nOMAP24XX_ST_96M_APLL_SHIFT);\r\n}\r\nvoid omap2xxx_cm_apll54_disable(void)\r\n{\r\n_omap2xxx_apll_disable(OMAP24XX_EN_54M_PLL_SHIFT);\r\n}\r\nvoid omap2xxx_cm_apll96_disable(void)\r\n{\r\n_omap2xxx_apll_disable(OMAP24XX_EN_96M_PLL_SHIFT);\r\n}\r\nint omap2xxx_cm_split_idlest_reg(void __iomem *idlest_reg, s16 *prcm_inst,\r\nu8 *idlest_reg_id)\r\n{\r\nunsigned long offs;\r\nu8 idlest_offs;\r\nint i;\r\nif (idlest_reg < cm_base || idlest_reg > (cm_base + 0x0fff))\r\nreturn -EINVAL;\r\nidlest_offs = (unsigned long)idlest_reg & 0xff;\r\nfor (i = 0; i < ARRAY_SIZE(omap2xxx_cm_idlest_offs); i++) {\r\nif (idlest_offs == omap2xxx_cm_idlest_offs[i]) {\r\n*idlest_reg_id = i + 1;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(omap2xxx_cm_idlest_offs))\r\nreturn -EINVAL;\r\noffs = idlest_reg - cm_base;\r\noffs &= 0xff00;\r\n*prcm_inst = offs;\r\nreturn 0;\r\n}\r\nint omap2xxx_cm_wait_module_ready(s16 prcm_mod, u8 idlest_id, u8 idlest_shift)\r\n{\r\nint ena = 0, i = 0;\r\nu8 cm_idlest_reg;\r\nu32 mask;\r\nif (!idlest_id || (idlest_id > ARRAY_SIZE(omap2xxx_cm_idlest_offs)))\r\nreturn -EINVAL;\r\ncm_idlest_reg = omap2xxx_cm_idlest_offs[idlest_id - 1];\r\nmask = 1 << idlest_shift;\r\nena = mask;\r\nomap_test_timeout(((omap2_cm_read_mod_reg(prcm_mod, cm_idlest_reg) &\r\nmask) == ena), MAX_MODULE_READY_TIME, i);\r\nreturn (i < MAX_MODULE_READY_TIME) ? 0 : -EBUSY;\r\n}\r\nstatic void omap2xxx_clkdm_allow_idle(struct clockdomain *clkdm)\r\n{\r\nomap2xxx_cm_clkdm_enable_hwsup(clkdm->pwrdm.ptr->prcm_offs,\r\nclkdm->clktrctrl_mask);\r\n}\r\nstatic void omap2xxx_clkdm_deny_idle(struct clockdomain *clkdm)\r\n{\r\nomap2xxx_cm_clkdm_disable_hwsup(clkdm->pwrdm.ptr->prcm_offs,\r\nclkdm->clktrctrl_mask);\r\n}\r\nstatic int omap2xxx_clkdm_clk_enable(struct clockdomain *clkdm)\r\n{\r\nbool hwsup = false;\r\nif (!clkdm->clktrctrl_mask)\r\nreturn 0;\r\nhwsup = omap2xxx_cm_is_clkdm_in_hwsup(clkdm->pwrdm.ptr->prcm_offs,\r\nclkdm->clktrctrl_mask);\r\nif (!hwsup && clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nomap2xxx_clkdm_wakeup(clkdm);\r\nreturn 0;\r\n}\r\nstatic int omap2xxx_clkdm_clk_disable(struct clockdomain *clkdm)\r\n{\r\nbool hwsup = false;\r\nif (!clkdm->clktrctrl_mask)\r\nreturn 0;\r\nhwsup = omap2xxx_cm_is_clkdm_in_hwsup(clkdm->pwrdm.ptr->prcm_offs,\r\nclkdm->clktrctrl_mask);\r\nif (!hwsup && clkdm->flags & CLKDM_CAN_FORCE_SLEEP)\r\nomap2xxx_clkdm_sleep(clkdm);\r\nreturn 0;\r\n}\r\nint __init omap2xxx_cm_init(void)\r\n{\r\nif (!cpu_is_omap24xx())\r\nreturn 0;\r\nreturn cm_register(&omap2xxx_cm_ll_data);\r\n}\r\nstatic void __exit omap2xxx_cm_exit(void)\r\n{\r\nif (!cpu_is_omap24xx())\r\nreturn;\r\nWARN(cm_unregister(&omap2xxx_cm_ll_data),\r\n"%s: cm_ll_data function pointer mismatch\n", __func__);\r\n}
