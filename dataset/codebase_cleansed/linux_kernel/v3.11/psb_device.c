static int psb_output_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\npsb_intel_lvds_init(dev, &dev_priv->mode_dev);\r\npsb_intel_sdvo_init(dev, SDVOB);\r\nreturn 0;\r\n}\r\nstatic int psb_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn psb_brightness;\r\n}\r\nstatic int psb_backlight_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long core_clock;\r\nu16 bl_max_freq;\r\nuint32_t value;\r\nuint32_t blc_pwm_precision_factor;\r\nif (!dev_priv->lvds_bl) {\r\ndev_err(dev->dev, "Has no valid LVDS backlight info\n");\r\nreturn -ENOENT;\r\n}\r\nbl_max_freq = dev_priv->lvds_bl->freq;\r\nblc_pwm_precision_factor = PSB_BLC_PWM_PRECISION_FACTOR;\r\ncore_clock = dev_priv->core_freq;\r\nvalue = (core_clock * MHz) / BLC_PWM_FREQ_CALC_CONSTANT;\r\nvalue *= blc_pwm_precision_factor;\r\nvalue /= bl_max_freq;\r\nvalue /= blc_pwm_precision_factor;\r\nif (value > (unsigned long long)PSB_BLC_MAX_PWM_REG_FREQ ||\r\nvalue < (unsigned long long)PSB_BLC_MIN_PWM_REG_FREQ)\r\nreturn -ERANGE;\r\nelse {\r\nvalue &= PSB_BACKLIGHT_PWM_POLARITY_BIT_CLEAR;\r\nREG_WRITE(BLC_PWM_CTL,\r\n(value << PSB_BACKLIGHT_PWM_CTL_SHIFT) | (value));\r\n}\r\nreturn 0;\r\n}\r\nstatic int psb_set_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(psb_backlight_device);\r\nint level = bd->props.brightness;\r\nif (level < 1)\r\nlevel = 1;\r\npsb_intel_lvds_set_brightness(dev, level);\r\npsb_brightness = level;\r\nreturn 0;\r\n}\r\nstatic int psb_backlight_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint ret;\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = 100;\r\nprops.type = BACKLIGHT_PLATFORM;\r\npsb_backlight_device = backlight_device_register("psb-bl",\r\nNULL, (void *)dev, &psb_ops, &props);\r\nif (IS_ERR(psb_backlight_device))\r\nreturn PTR_ERR(psb_backlight_device);\r\nret = psb_backlight_setup(dev);\r\nif (ret < 0) {\r\nbacklight_device_unregister(psb_backlight_device);\r\npsb_backlight_device = NULL;\r\nreturn ret;\r\n}\r\npsb_backlight_device->props.brightness = 100;\r\npsb_backlight_device->props.max_brightness = 100;\r\nbacklight_update_status(psb_backlight_device);\r\ndev_priv->backlight_device = psb_backlight_device;\r\npsb_lid_timer_init(dev_priv);\r\nreturn 0;\r\n}\r\nstatic void psb_init_pm(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 gating = PSB_RSGX32(PSB_CR_CLKGATECTL);\r\ngating &= ~3;\r\ngating |= 1;\r\nPSB_WSGX32(gating, PSB_CR_CLKGATECTL);\r\nPSB_RSGX32(PSB_CR_CLKGATECTL);\r\n}\r\nstatic int psb_save_display_registers(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nstruct drm_connector *connector;\r\nstruct psb_state *regs = &dev_priv->regs.psb;\r\nregs->saveDSPARB = PSB_RVDC32(DSPARB);\r\nregs->saveDSPFW1 = PSB_RVDC32(DSPFW1);\r\nregs->saveDSPFW2 = PSB_RVDC32(DSPFW2);\r\nregs->saveDSPFW3 = PSB_RVDC32(DSPFW3);\r\nregs->saveDSPFW4 = PSB_RVDC32(DSPFW4);\r\nregs->saveDSPFW5 = PSB_RVDC32(DSPFW5);\r\nregs->saveDSPFW6 = PSB_RVDC32(DSPFW6);\r\nregs->saveCHICKENBIT = PSB_RVDC32(DSPCHICKENBIT);\r\ndrm_modeset_lock_all(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (drm_helper_crtc_in_use(crtc))\r\ncrtc->funcs->save(crtc);\r\n}\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->funcs->save)\r\nconnector->funcs->save(connector);\r\ndrm_modeset_unlock_all(dev);\r\nreturn 0;\r\n}\r\nstatic int psb_restore_display_registers(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nstruct drm_connector *connector;\r\nstruct psb_state *regs = &dev_priv->regs.psb;\r\nPSB_WVDC32(regs->saveDSPARB, DSPARB);\r\nPSB_WVDC32(regs->saveDSPFW1, DSPFW1);\r\nPSB_WVDC32(regs->saveDSPFW2, DSPFW2);\r\nPSB_WVDC32(regs->saveDSPFW3, DSPFW3);\r\nPSB_WVDC32(regs->saveDSPFW4, DSPFW4);\r\nPSB_WVDC32(regs->saveDSPFW5, DSPFW5);\r\nPSB_WVDC32(regs->saveDSPFW6, DSPFW6);\r\nPSB_WVDC32(regs->saveCHICKENBIT, DSPCHICKENBIT);\r\nPSB_WVDC32(0x80000000, VGACNTRL);\r\ndrm_modeset_lock_all(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\r\nif (drm_helper_crtc_in_use(crtc))\r\ncrtc->funcs->restore(crtc);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->funcs->restore)\r\nconnector->funcs->restore(connector);\r\ndrm_modeset_unlock_all(dev);\r\nreturn 0;\r\n}\r\nstatic int psb_power_down(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int psb_power_up(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psb_get_core_freq(struct drm_device *dev)\r\n{\r\nuint32_t clock;\r\nstruct pci_dev *pci_root = pci_get_bus_and_slot(0, 0);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\npci_write_config_dword(pci_root, 0xD0, 0xD0050300);\r\npci_read_config_dword(pci_root, 0xD4, &clock);\r\npci_dev_put(pci_root);\r\nswitch (clock & 0x07) {\r\ncase 0:\r\ndev_priv->core_freq = 100;\r\nbreak;\r\ncase 1:\r\ndev_priv->core_freq = 133;\r\nbreak;\r\ncase 2:\r\ndev_priv->core_freq = 150;\r\nbreak;\r\ncase 3:\r\ndev_priv->core_freq = 178;\r\nbreak;\r\ncase 4:\r\ndev_priv->core_freq = 200;\r\nbreak;\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ndev_priv->core_freq = 266;\r\nbreak;\r\ndefault:\r\ndev_priv->core_freq = 0;\r\n}\r\n}\r\nstatic int psb_chip_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\ndev_priv->regmap = psb_regmap;\r\npsb_get_core_freq(dev);\r\ngma_intel_setup_gmbus(dev);\r\npsb_intel_opregion_init(dev);\r\npsb_intel_init_bios(dev);\r\nreturn 0;\r\n}\r\nstatic void psb_chip_teardown(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\npsb_lid_timer_takedown(dev_priv);\r\ngma_intel_teardown_gmbus(dev);\r\n}
