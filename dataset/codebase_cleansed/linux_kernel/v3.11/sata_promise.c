static int pdc_common_port_start(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->host->dev;\r\nstruct pdc_port_priv *pp;\r\nint rc;\r\nrc = ata_bmdma_port_start(ap);\r\nif (rc)\r\nreturn rc;\r\npp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\npp->pkt = dmam_alloc_coherent(dev, 128, &pp->pkt_dma, GFP_KERNEL);\r\nif (!pp->pkt)\r\nreturn -ENOMEM;\r\nap->private_data = pp;\r\nreturn 0;\r\n}\r\nstatic int pdc_sata_port_start(struct ata_port *ap)\r\n{\r\nint rc;\r\nrc = pdc_common_port_start(ap);\r\nif (rc)\r\nreturn rc;\r\nif (ap->flags & PDC_FLAG_GEN_II) {\r\nvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\r\nunsigned int tmp;\r\ntmp = readl(sata_mmio + PDC_PHYMODE4);\r\ntmp = (tmp & ~3) | 1;\r\nwritel(tmp, sata_mmio + PDC_PHYMODE4);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pdc_fpdma_clear_interrupt_flag(struct ata_port *ap)\r\n{\r\nvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\r\nu32 tmp;\r\ntmp = readl(sata_mmio + PDC_FPDMA_CTLSTAT);\r\ntmp |= PDC_FPDMA_CTLSTAT_DMASETUP_INT_FLAG;\r\ntmp |= PDC_FPDMA_CTLSTAT_SETDB_INT_FLAG;\r\nwriteb(tmp >> 8, sata_mmio + PDC_FPDMA_CTLSTAT + 1);\r\nreadb(sata_mmio + PDC_FPDMA_CTLSTAT + 1);\r\n}\r\nstatic void pdc_fpdma_reset(struct ata_port *ap)\r\n{\r\nvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\r\nu8 tmp;\r\ntmp = (u8)readl(sata_mmio + PDC_FPDMA_CTLSTAT);\r\ntmp &= 0x7F;\r\ntmp |= PDC_FPDMA_CTLSTAT_RESET;\r\nwriteb(tmp, sata_mmio + PDC_FPDMA_CTLSTAT);\r\nreadl(sata_mmio + PDC_FPDMA_CTLSTAT);\r\nudelay(100);\r\ntmp &= ~PDC_FPDMA_CTLSTAT_RESET;\r\nwriteb(tmp, sata_mmio + PDC_FPDMA_CTLSTAT);\r\nreadl(sata_mmio + PDC_FPDMA_CTLSTAT);\r\npdc_fpdma_clear_interrupt_flag(ap);\r\n}\r\nstatic void pdc_not_at_command_packet_phase(struct ata_port *ap)\r\n{\r\nvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\r\nunsigned int i;\r\nu32 tmp;\r\nfor (i = 0; i < 100; ++i) {\r\nwritel(0, sata_mmio + PDC_INTERNAL_DEBUG_1);\r\ntmp = readl(sata_mmio + PDC_INTERNAL_DEBUG_2);\r\nif ((tmp & 0xF) != 1)\r\nbreak;\r\nudelay(100);\r\n}\r\n}\r\nstatic void pdc_clear_internal_debug_record_error_register(struct ata_port *ap)\r\n{\r\nvoid __iomem *sata_mmio = ap->ioaddr.scr_addr;\r\nwritel(0xffffffff, sata_mmio + PDC_SATA_ERROR);\r\nwritel(0xffff0000, sata_mmio + PDC_LINK_LAYER_ERRORS);\r\n}\r\nstatic void pdc_reset_port(struct ata_port *ap)\r\n{\r\nvoid __iomem *ata_ctlstat_mmio = ap->ioaddr.cmd_addr + PDC_CTLSTAT;\r\nunsigned int i;\r\nu32 tmp;\r\nif (ap->flags & PDC_FLAG_GEN_II)\r\npdc_not_at_command_packet_phase(ap);\r\ntmp = readl(ata_ctlstat_mmio);\r\ntmp |= PDC_RESET;\r\nwritel(tmp, ata_ctlstat_mmio);\r\nfor (i = 11; i > 0; i--) {\r\ntmp = readl(ata_ctlstat_mmio);\r\nif (tmp & PDC_RESET)\r\nbreak;\r\nudelay(100);\r\ntmp |= PDC_RESET;\r\nwritel(tmp, ata_ctlstat_mmio);\r\n}\r\ntmp &= ~PDC_RESET;\r\nwritel(tmp, ata_ctlstat_mmio);\r\nreadl(ata_ctlstat_mmio);\r\nif (sata_scr_valid(&ap->link) && (ap->flags & PDC_FLAG_GEN_II)) {\r\npdc_fpdma_reset(ap);\r\npdc_clear_internal_debug_record_error_register(ap);\r\n}\r\n}\r\nstatic int pdc_pata_cable_detect(struct ata_port *ap)\r\n{\r\nu8 tmp;\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\ntmp = readb(ata_mmio + PDC_CTLSTAT + 3);\r\nif (tmp & 0x01)\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic int pdc_sata_cable_detect(struct ata_port *ap)\r\n{\r\nreturn ATA_CBL_SATA;\r\n}\r\nstatic int pdc_sata_scr_read(struct ata_link *link,\r\nunsigned int sc_reg, u32 *val)\r\n{\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\n*val = readl(link->ap->ioaddr.scr_addr + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic int pdc_sata_scr_write(struct ata_link *link,\r\nunsigned int sc_reg, u32 val)\r\n{\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\nwritel(val, link->ap->ioaddr.scr_addr + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic void pdc_atapi_pkt(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\ndma_addr_t sg_table = ap->bmdma_prd_dma;\r\nunsigned int cdb_len = qc->dev->cdb_len;\r\nu8 *cdb = qc->cdb;\r\nstruct pdc_port_priv *pp = ap->private_data;\r\nu8 *buf = pp->pkt;\r\n__le32 *buf32 = (__le32 *) buf;\r\nunsigned int dev_sel, feature;\r\nswitch (qc->tf.protocol) {\r\ncase ATAPI_PROT_DMA:\r\nif (!(qc->tf.flags & ATA_TFLAG_WRITE))\r\nbuf32[0] = cpu_to_le32(PDC_PKT_READ);\r\nelse\r\nbuf32[0] = 0;\r\nbreak;\r\ncase ATAPI_PROT_NODATA:\r\nbuf32[0] = cpu_to_le32(PDC_PKT_NODATA);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nbuf32[1] = cpu_to_le32(sg_table);\r\nbuf32[2] = 0;\r\nif (sata_scr_valid(&ap->link))\r\ndev_sel = PDC_DEVICE_SATA;\r\nelse\r\ndev_sel = qc->tf.device;\r\nbuf[12] = (1 << 5) | ATA_REG_DEVICE;\r\nbuf[13] = dev_sel;\r\nbuf[14] = (1 << 5) | ATA_REG_DEVICE | PDC_PKT_CLEAR_BSY;\r\nbuf[15] = dev_sel;\r\nbuf[16] = (1 << 5) | ATA_REG_NSECT;\r\nbuf[17] = qc->tf.nsect;\r\nbuf[18] = (1 << 5) | ATA_REG_LBAL;\r\nbuf[19] = qc->tf.lbal;\r\nif (qc->tf.protocol != ATAPI_PROT_DMA)\r\nfeature = PDC_FEATURE_ATAPI_PIO;\r\nelse\r\nfeature = PDC_FEATURE_ATAPI_DMA;\r\nbuf[20] = (1 << 5) | ATA_REG_FEATURE;\r\nbuf[21] = feature;\r\nbuf[22] = (1 << 5) | ATA_REG_BYTEL;\r\nbuf[23] = qc->tf.lbam;\r\nbuf[24] = (1 << 5) | ATA_REG_BYTEH;\r\nbuf[25] = qc->tf.lbah;\r\nbuf[26] = (1 << 5) | ATA_REG_CMD;\r\nbuf[27] = qc->tf.command;\r\nbuf[28] = (1 << 5) | ATA_REG_DEVICE | PDC_PKT_WAIT_DRDY;\r\nbuf[29] = dev_sel;\r\nBUG_ON(cdb_len & ~0x1E);\r\nbuf[30] = (((cdb_len >> 1) & 7) << 5) | ATA_REG_DATA | PDC_LAST_REG;\r\nmemcpy(buf+31, cdb, cdb_len);\r\n}\r\nstatic void pdc_fill_sg(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_bmdma_prd *prd = ap->bmdma_prd;\r\nstruct scatterlist *sg;\r\nconst u32 SG_COUNT_ASIC_BUG = 41*4;\r\nunsigned int si, idx;\r\nu32 len;\r\nif (!(qc->flags & ATA_QCFLAG_DMAMAP))\r\nreturn;\r\nidx = 0;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\nu32 addr, offset;\r\nu32 sg_len;\r\naddr = (u32) sg_dma_address(sg);\r\nsg_len = sg_dma_len(sg);\r\nwhile (sg_len) {\r\noffset = addr & 0xffff;\r\nlen = sg_len;\r\nif ((offset + sg_len) > 0x10000)\r\nlen = 0x10000 - offset;\r\nprd[idx].addr = cpu_to_le32(addr);\r\nprd[idx].flags_len = cpu_to_le32(len & 0xffff);\r\nVPRINTK("PRD[%u] = (0x%X, 0x%X)\n", idx, addr, len);\r\nidx++;\r\nsg_len -= len;\r\naddr += len;\r\n}\r\n}\r\nlen = le32_to_cpu(prd[idx - 1].flags_len);\r\nif (len > SG_COUNT_ASIC_BUG) {\r\nu32 addr;\r\nVPRINTK("Splitting last PRD.\n");\r\naddr = le32_to_cpu(prd[idx - 1].addr);\r\nprd[idx - 1].flags_len = cpu_to_le32(len - SG_COUNT_ASIC_BUG);\r\nVPRINTK("PRD[%u] = (0x%X, 0x%X)\n", idx - 1, addr, SG_COUNT_ASIC_BUG);\r\naddr = addr + len - SG_COUNT_ASIC_BUG;\r\nlen = SG_COUNT_ASIC_BUG;\r\nprd[idx].addr = cpu_to_le32(addr);\r\nprd[idx].flags_len = cpu_to_le32(len);\r\nVPRINTK("PRD[%u] = (0x%X, 0x%X)\n", idx, addr, len);\r\nidx++;\r\n}\r\nprd[idx - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);\r\n}\r\nstatic void pdc_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct pdc_port_priv *pp = qc->ap->private_data;\r\nunsigned int i;\r\nVPRINTK("ENTER\n");\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_DMA:\r\npdc_fill_sg(qc);\r\ncase ATA_PROT_NODATA:\r\ni = pdc_pkt_header(&qc->tf, qc->ap->bmdma_prd_dma,\r\nqc->dev->devno, pp->pkt);\r\nif (qc->tf.flags & ATA_TFLAG_LBA48)\r\ni = pdc_prep_lba48(&qc->tf, pp->pkt, i);\r\nelse\r\ni = pdc_prep_lba28(&qc->tf, pp->pkt, i);\r\npdc_pkt_footer(&qc->tf, pp->pkt, i);\r\nbreak;\r\ncase ATAPI_PROT_PIO:\r\npdc_fill_sg(qc);\r\nbreak;\r\ncase ATAPI_PROT_DMA:\r\npdc_fill_sg(qc);\r\ncase ATAPI_PROT_NODATA:\r\npdc_atapi_pkt(qc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int pdc_is_sataii_tx4(unsigned long flags)\r\n{\r\nconst unsigned long mask = PDC_FLAG_GEN_II | PDC_FLAG_4_PORTS;\r\nreturn (flags & mask) == mask;\r\n}\r\nstatic unsigned int pdc_port_no_to_ata_no(unsigned int port_no,\r\nint is_sataii_tx4)\r\n{\r\nstatic const unsigned char sataii_tx4_port_remap[4] = { 3, 1, 0, 2};\r\nreturn is_sataii_tx4 ? sataii_tx4_port_remap[port_no] : port_no;\r\n}\r\nstatic unsigned int pdc_sata_nr_ports(const struct ata_port *ap)\r\n{\r\nreturn (ap->flags & PDC_FLAG_4_PORTS) ? 4 : 2;\r\n}\r\nstatic unsigned int pdc_sata_ata_port_to_ata_no(const struct ata_port *ap)\r\n{\r\nconst struct ata_host *host = ap->host;\r\nunsigned int nr_ports = pdc_sata_nr_ports(ap);\r\nunsigned int i;\r\nfor (i = 0; i < nr_ports && host->ports[i] != ap; ++i)\r\n;\r\nBUG_ON(i >= nr_ports);\r\nreturn pdc_port_no_to_ata_no(i, pdc_is_sataii_tx4(ap->flags));\r\n}\r\nstatic void pdc_freeze(struct ata_port *ap)\r\n{\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\nu32 tmp;\r\ntmp = readl(ata_mmio + PDC_CTLSTAT);\r\ntmp |= PDC_IRQ_DISABLE;\r\ntmp &= ~PDC_DMA_ENABLE;\r\nwritel(tmp, ata_mmio + PDC_CTLSTAT);\r\nreadl(ata_mmio + PDC_CTLSTAT);\r\n}\r\nstatic void pdc_sata_freeze(struct ata_port *ap)\r\n{\r\nstruct ata_host *host = ap->host;\r\nvoid __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];\r\nunsigned int hotplug_offset = PDC2_SATA_PLUG_CSR;\r\nunsigned int ata_no = pdc_sata_ata_port_to_ata_no(ap);\r\nu32 hotplug_status;\r\nhotplug_status = readl(host_mmio + hotplug_offset);\r\nhotplug_status |= 0x11 << (ata_no + 16);\r\nwritel(hotplug_status, host_mmio + hotplug_offset);\r\nreadl(host_mmio + hotplug_offset);\r\npdc_freeze(ap);\r\n}\r\nstatic void pdc_thaw(struct ata_port *ap)\r\n{\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\nu32 tmp;\r\nreadl(ata_mmio + PDC_COMMAND);\r\ntmp = readl(ata_mmio + PDC_CTLSTAT);\r\ntmp &= ~PDC_IRQ_DISABLE;\r\nwritel(tmp, ata_mmio + PDC_CTLSTAT);\r\nreadl(ata_mmio + PDC_CTLSTAT);\r\n}\r\nstatic void pdc_sata_thaw(struct ata_port *ap)\r\n{\r\nstruct ata_host *host = ap->host;\r\nvoid __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];\r\nunsigned int hotplug_offset = PDC2_SATA_PLUG_CSR;\r\nunsigned int ata_no = pdc_sata_ata_port_to_ata_no(ap);\r\nu32 hotplug_status;\r\npdc_thaw(ap);\r\nhotplug_status = readl(host_mmio + hotplug_offset);\r\nhotplug_status |= 0x11 << ata_no;\r\nhotplug_status &= ~(0x11 << (ata_no + 16));\r\nwritel(hotplug_status, host_mmio + hotplug_offset);\r\nreadl(host_mmio + hotplug_offset);\r\n}\r\nstatic int pdc_pata_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\npdc_reset_port(link->ap);\r\nreturn ata_sff_softreset(link, class, deadline);\r\n}\r\nstatic unsigned int pdc_ata_port_to_ata_no(const struct ata_port *ap)\r\n{\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\nvoid __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];\r\nreturn (ata_mmio - host_mmio - 0x200) / 0x80;\r\n}\r\nstatic void pdc_hard_reset_port(struct ata_port *ap)\r\n{\r\nvoid __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];\r\nvoid __iomem *pcictl_b1_mmio = host_mmio + PDC_PCI_CTL + 1;\r\nunsigned int ata_no = pdc_ata_port_to_ata_no(ap);\r\nstruct pdc_host_priv *hpriv = ap->host->private_data;\r\nu8 tmp;\r\nspin_lock(&hpriv->hard_reset_lock);\r\ntmp = readb(pcictl_b1_mmio);\r\ntmp &= ~(0x10 << ata_no);\r\nwriteb(tmp, pcictl_b1_mmio);\r\nreadb(pcictl_b1_mmio);\r\nudelay(100);\r\ntmp |= (0x10 << ata_no);\r\nwriteb(tmp, pcictl_b1_mmio);\r\nreadb(pcictl_b1_mmio);\r\nspin_unlock(&hpriv->hard_reset_lock);\r\n}\r\nstatic int pdc_sata_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nif (link->ap->flags & PDC_FLAG_GEN_II)\r\npdc_not_at_command_packet_phase(link->ap);\r\npdc_hard_reset_port(link->ap);\r\npdc_reset_port(link->ap);\r\nreturn sata_std_hardreset(link, class, deadline);\r\n}\r\nstatic void pdc_error_handler(struct ata_port *ap)\r\n{\r\nif (!(ap->pflags & ATA_PFLAG_FROZEN))\r\npdc_reset_port(ap);\r\nata_sff_error_handler(ap);\r\n}\r\nstatic void pdc_post_internal_cmd(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nif (qc->flags & ATA_QCFLAG_FAILED)\r\npdc_reset_port(ap);\r\n}\r\nstatic void pdc_error_intr(struct ata_port *ap, struct ata_queued_cmd *qc,\r\nu32 port_status, u32 err_mask)\r\n{\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nunsigned int ac_err_mask = 0;\r\nata_ehi_clear_desc(ehi);\r\nata_ehi_push_desc(ehi, "port_status 0x%08x", port_status);\r\nport_status &= err_mask;\r\nif (port_status & PDC_DRIVE_ERR)\r\nac_err_mask |= AC_ERR_DEV;\r\nif (port_status & (PDC_OVERRUN_ERR | PDC_UNDERRUN_ERR))\r\nac_err_mask |= AC_ERR_OTHER;\r\nif (port_status & (PDC2_ATA_HBA_ERR | PDC2_ATA_DMA_CNT_ERR))\r\nac_err_mask |= AC_ERR_ATA_BUS;\r\nif (port_status & (PDC_PH_ERR | PDC_SH_ERR | PDC_DH_ERR | PDC2_HTO_ERR\r\n| PDC_PCI_SYS_ERR | PDC1_PCI_PARITY_ERR))\r\nac_err_mask |= AC_ERR_HOST_BUS;\r\nif (sata_scr_valid(&ap->link)) {\r\nu32 serror;\r\npdc_sata_scr_read(&ap->link, SCR_ERROR, &serror);\r\nehi->serror |= serror;\r\n}\r\nqc->err_mask |= ac_err_mask;\r\npdc_reset_port(ap);\r\nata_port_abort(ap);\r\n}\r\nstatic unsigned int pdc_host_intr(struct ata_port *ap,\r\nstruct ata_queued_cmd *qc)\r\n{\r\nunsigned int handled = 0;\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\nu32 port_status, err_mask;\r\nerr_mask = PDC_ERR_MASK;\r\nif (ap->flags & PDC_FLAG_GEN_II)\r\nerr_mask &= ~PDC1_ERR_MASK;\r\nelse\r\nerr_mask &= ~PDC2_ERR_MASK;\r\nport_status = readl(ata_mmio + PDC_GLOBAL_CTL);\r\nif (unlikely(port_status & err_mask)) {\r\npdc_error_intr(ap, qc, port_status, err_mask);\r\nreturn 1;\r\n}\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_DMA:\r\ncase ATA_PROT_NODATA:\r\ncase ATAPI_PROT_DMA:\r\ncase ATAPI_PROT_NODATA:\r\nqc->err_mask |= ac_err_mask(ata_wait_idle(ap));\r\nata_qc_complete(qc);\r\nhandled = 1;\r\nbreak;\r\ndefault:\r\nap->stats.idle_irq++;\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic void pdc_irq_clear(struct ata_port *ap)\r\n{\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\nreadl(ata_mmio + PDC_COMMAND);\r\n}\r\nstatic irqreturn_t pdc_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct ata_port *ap;\r\nu32 mask = 0;\r\nunsigned int i, tmp;\r\nunsigned int handled = 0;\r\nvoid __iomem *host_mmio;\r\nunsigned int hotplug_offset, ata_no;\r\nu32 hotplug_status;\r\nint is_sataii_tx4;\r\nVPRINTK("ENTER\n");\r\nif (!host || !host->iomap[PDC_MMIO_BAR]) {\r\nVPRINTK("QUICK EXIT\n");\r\nreturn IRQ_NONE;\r\n}\r\nhost_mmio = host->iomap[PDC_MMIO_BAR];\r\nspin_lock(&host->lock);\r\nif (host->ports[0]->flags & PDC_FLAG_GEN_II) {\r\nhotplug_offset = PDC2_SATA_PLUG_CSR;\r\nhotplug_status = readl(host_mmio + hotplug_offset);\r\nif (hotplug_status & 0xff)\r\nwritel(hotplug_status | 0xff, host_mmio + hotplug_offset);\r\nhotplug_status &= 0xff;\r\n} else\r\nhotplug_status = 0;\r\nmask = readl(host_mmio + PDC_INT_SEQMASK);\r\nif (mask == 0xffffffff && hotplug_status == 0) {\r\nVPRINTK("QUICK EXIT 2\n");\r\ngoto done_irq;\r\n}\r\nmask &= 0xffff;\r\nif (mask == 0 && hotplug_status == 0) {\r\nVPRINTK("QUICK EXIT 3\n");\r\ngoto done_irq;\r\n}\r\nwritel(mask, host_mmio + PDC_INT_SEQMASK);\r\nis_sataii_tx4 = pdc_is_sataii_tx4(host->ports[0]->flags);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nVPRINTK("port %u\n", i);\r\nap = host->ports[i];\r\nata_no = pdc_port_no_to_ata_no(i, is_sataii_tx4);\r\ntmp = hotplug_status & (0x11 << ata_no);\r\nif (tmp) {\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nata_ehi_clear_desc(ehi);\r\nata_ehi_hotplugged(ehi);\r\nata_ehi_push_desc(ehi, "hotplug_status %#x", tmp);\r\nata_port_freeze(ap);\r\n++handled;\r\ncontinue;\r\n}\r\ntmp = mask & (1 << (i + 1));\r\nif (tmp) {\r\nstruct ata_queued_cmd *qc;\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)))\r\nhandled += pdc_host_intr(ap, qc);\r\n}\r\n}\r\nVPRINTK("EXIT\n");\r\ndone_irq:\r\nspin_unlock(&host->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pdc_packet_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pdc_port_priv *pp = ap->private_data;\r\nvoid __iomem *host_mmio = ap->host->iomap[PDC_MMIO_BAR];\r\nvoid __iomem *ata_mmio = ap->ioaddr.cmd_addr;\r\nunsigned int port_no = ap->port_no;\r\nu8 seq = (u8) (port_no + 1);\r\nVPRINTK("ENTER, ap %p\n", ap);\r\nwritel(0x00000001, host_mmio + (seq * 4));\r\nreadl(host_mmio + (seq * 4));\r\npp->pkt[2] = seq;\r\nwmb();\r\nwritel(pp->pkt_dma, ata_mmio + PDC_PKT_SUBMIT);\r\nreadl(ata_mmio + PDC_PKT_SUBMIT);\r\n}\r\nstatic unsigned int pdc_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nswitch (qc->tf.protocol) {\r\ncase ATAPI_PROT_NODATA:\r\nif (qc->dev->flags & ATA_DFLAG_CDB_INTR)\r\nbreak;\r\ncase ATA_PROT_NODATA:\r\nif (qc->tf.flags & ATA_TFLAG_POLLING)\r\nbreak;\r\ncase ATAPI_PROT_DMA:\r\ncase ATA_PROT_DMA:\r\npdc_packet_start(qc);\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nstatic void pdc_tf_load_mmio(struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nWARN_ON(tf->protocol == ATA_PROT_DMA || tf->protocol == ATAPI_PROT_DMA);\r\nata_sff_tf_load(ap, tf);\r\n}\r\nstatic void pdc_exec_command_mmio(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nWARN_ON(tf->protocol == ATA_PROT_DMA || tf->protocol == ATAPI_PROT_DMA);\r\nata_sff_exec_command(ap, tf);\r\n}\r\nstatic int pdc_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nu8 *scsicmd = qc->scsicmd->cmnd;\r\nint pio = 1;\r\nswitch (scsicmd[0]) {\r\ncase WRITE_12:\r\ncase WRITE_10:\r\ncase WRITE_6:\r\ncase READ_12:\r\ncase READ_10:\r\ncase READ_6:\r\ncase 0xad:\r\ncase 0xbe:\r\npio = 0;\r\n}\r\nif (scsicmd[0] == WRITE_10) {\r\nunsigned int lba =\r\n(scsicmd[2] << 24) |\r\n(scsicmd[3] << 16) |\r\n(scsicmd[4] << 8) |\r\nscsicmd[5];\r\nif (lba >= 0xFFFF4FA2)\r\npio = 1;\r\n}\r\nreturn pio;\r\n}\r\nstatic int pdc_old_sata_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nreturn 1;\r\n}\r\nstatic void pdc_ata_setup_port(struct ata_port *ap,\r\nvoid __iomem *base, void __iomem *scr_addr)\r\n{\r\nap->ioaddr.cmd_addr = base;\r\nap->ioaddr.data_addr = base;\r\nap->ioaddr.feature_addr =\r\nap->ioaddr.error_addr = base + 0x4;\r\nap->ioaddr.nsect_addr = base + 0x8;\r\nap->ioaddr.lbal_addr = base + 0xc;\r\nap->ioaddr.lbam_addr = base + 0x10;\r\nap->ioaddr.lbah_addr = base + 0x14;\r\nap->ioaddr.device_addr = base + 0x18;\r\nap->ioaddr.command_addr =\r\nap->ioaddr.status_addr = base + 0x1c;\r\nap->ioaddr.altstatus_addr =\r\nap->ioaddr.ctl_addr = base + 0x38;\r\nap->ioaddr.scr_addr = scr_addr;\r\n}\r\nstatic void pdc_host_init(struct ata_host *host)\r\n{\r\nvoid __iomem *host_mmio = host->iomap[PDC_MMIO_BAR];\r\nint is_gen2 = host->ports[0]->flags & PDC_FLAG_GEN_II;\r\nint hotplug_offset;\r\nu32 tmp;\r\nif (is_gen2)\r\nhotplug_offset = PDC2_SATA_PLUG_CSR;\r\nelse\r\nhotplug_offset = PDC_SATA_PLUG_CSR;\r\ntmp = readl(host_mmio + PDC_FLASH_CTL);\r\ntmp |= 0x02000;\r\nif (!is_gen2)\r\ntmp |= 0x10000;\r\nwritel(tmp, host_mmio + PDC_FLASH_CTL);\r\ntmp = readl(host_mmio + hotplug_offset);\r\nwritel(tmp | 0xff, host_mmio + hotplug_offset);\r\ntmp = readl(host_mmio + hotplug_offset);\r\nif (is_gen2)\r\nwritel(tmp & ~0xff0000, host_mmio + hotplug_offset);\r\nelse\r\nwritel(tmp | 0xff0000, host_mmio + hotplug_offset);\r\nif (is_gen2)\r\nreturn;\r\ntmp = readl(host_mmio + PDC_TBG_MODE);\r\ntmp &= ~0x30000;\r\ntmp |= 0x10000;\r\nwritel(tmp, host_mmio + PDC_TBG_MODE);\r\nreadl(host_mmio + PDC_TBG_MODE);\r\nmsleep(10);\r\ntmp = readl(host_mmio + PDC_SLEW_CTL);\r\ntmp &= 0xFFFFF03F;\r\ntmp |= 0x00000900;\r\nwritel(tmp, host_mmio + PDC_SLEW_CTL);\r\n}\r\nstatic int pdc_ata_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nconst struct ata_port_info *pi = &pdc_port_info[ent->driver_data];\r\nconst struct ata_port_info *ppi[PDC_MAX_PORTS];\r\nstruct ata_host *host;\r\nstruct pdc_host_priv *hpriv;\r\nvoid __iomem *host_mmio;\r\nint n_ports, i, rc;\r\nint is_sataii_tx4;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions(pdev, 1 << PDC_MMIO_BAR, DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhost_mmio = pcim_iomap_table(pdev)[PDC_MMIO_BAR];\r\nn_ports = 2;\r\nif (pi->flags & PDC_FLAG_4_PORTS)\r\nn_ports = 4;\r\nfor (i = 0; i < n_ports; i++)\r\nppi[i] = pi;\r\nif (pi->flags & PDC_FLAG_SATA_PATA) {\r\nu8 tmp = readb(host_mmio + PDC_FLASH_CTL + 1);\r\nif (!(tmp & 0x80))\r\nppi[n_ports++] = pi + 1;\r\n}\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\r\nif (!host) {\r\ndev_err(&pdev->dev, "failed to allocate host\n");\r\nreturn -ENOMEM;\r\n}\r\nhpriv = devm_kzalloc(&pdev->dev, sizeof *hpriv, GFP_KERNEL);\r\nif (!hpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&hpriv->hard_reset_lock);\r\nhost->private_data = hpriv;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nis_sataii_tx4 = pdc_is_sataii_tx4(pi->flags);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nunsigned int ata_no = pdc_port_no_to_ata_no(i, is_sataii_tx4);\r\nunsigned int ata_offset = 0x200 + ata_no * 0x80;\r\nunsigned int scr_offset = 0x400 + ata_no * 0x100;\r\npdc_ata_setup_port(ap, host_mmio + ata_offset, host_mmio + scr_offset);\r\nata_port_pbar_desc(ap, PDC_MMIO_BAR, -1, "mmio");\r\nata_port_pbar_desc(ap, PDC_MMIO_BAR, ata_offset, "ata");\r\n}\r\npdc_host_init(host);\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, pdc_interrupt, IRQF_SHARED,\r\n&pdc_ata_sht);\r\n}
