static int it913x_rd_regs(struct it913x_state *state,\r\nu32 reg, u8 *data, u8 count)\r\n{\r\nint ret;\r\nu8 b[3];\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = state->i2c_addr, .flags = 0,\r\n.buf = b, .len = sizeof(b) },\r\n{ .addr = state->i2c_addr, .flags = I2C_M_RD,\r\n.buf = data, .len = count }\r\n};\r\nb[0] = (u8)(reg >> 16) & 0xff;\r\nb[1] = (u8)(reg >> 8) & 0xff;\r\nb[2] = (u8) reg & 0xff;\r\nb[0] |= 0x80;\r\nret = i2c_transfer(state->i2c_adap, msg, 2);\r\nreturn ret;\r\n}\r\nstatic int it913x_rd_reg(struct it913x_state *state, u32 reg)\r\n{\r\nint ret;\r\nu8 b[1];\r\nret = it913x_rd_regs(state, reg, &b[0], sizeof(b));\r\nreturn (ret < 0) ? -ENODEV : b[0];\r\n}\r\nstatic int it913x_wr_regs(struct it913x_state *state,\r\nu8 pro, u32 reg, u8 buf[], u8 count)\r\n{\r\nu8 b[256];\r\nstruct i2c_msg msg[1] = {\r\n{ .addr = state->i2c_addr, .flags = 0,\r\n.buf = b, .len = 3 + count }\r\n};\r\nint ret;\r\nb[0] = (u8)(reg >> 16) & 0xff;\r\nb[1] = (u8)(reg >> 8) & 0xff;\r\nb[2] = (u8) reg & 0xff;\r\nmemcpy(&b[3], buf, count);\r\nif (pro == PRO_DMOD)\r\nb[0] |= 0x80;\r\nret = i2c_transfer(state->i2c_adap, msg, 1);\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int it913x_wr_reg(struct it913x_state *state,\r\nu8 pro, u32 reg, u32 data)\r\n{\r\nint ret;\r\nu8 b[4];\r\nu8 s;\r\nb[0] = data >> 24;\r\nb[1] = (data >> 16) & 0xff;\r\nb[2] = (data >> 8) & 0xff;\r\nb[3] = data & 0xff;\r\nif (data < 0x100)\r\ns = 3;\r\nelse if (data < 0x1000)\r\ns = 2;\r\nelse if (data < 0x100000)\r\ns = 1;\r\nelse\r\ns = 0;\r\nret = it913x_wr_regs(state, pro, reg, &b[s], sizeof(b) - s);\r\nreturn ret;\r\n}\r\nstatic int it913x_script_loader(struct it913x_state *state,\r\nstruct it913xset *loadscript)\r\n{\r\nint ret, i;\r\nif (loadscript == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 1000; ++i) {\r\nif (loadscript[i].pro == 0xff)\r\nbreak;\r\nret = it913x_wr_regs(state, loadscript[i].pro,\r\nloadscript[i].address,\r\nloadscript[i].reg, loadscript[i].count);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int it913x_init(struct dvb_frontend *fe)\r\n{\r\nstruct it913x_state *state = fe->tuner_priv;\r\nint ret, i, reg;\r\nu8 val, nv_val;\r\nu8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};\r\nu8 b[2];\r\nreg = it913x_rd_reg(state, 0xec86);\r\nswitch (reg) {\r\ncase 0:\r\nstate->tun_clk_mode = reg;\r\nstate->tun_xtal = 2000;\r\nstate->tun_fdiv = 3;\r\nval = 16;\r\nbreak;\r\ncase -ENODEV:\r\nreturn -ENODEV;\r\ncase 1:\r\ndefault:\r\nstate->tun_clk_mode = reg;\r\nstate->tun_xtal = 640;\r\nstate->tun_fdiv = 1;\r\nval = 6;\r\nbreak;\r\n}\r\nreg = it913x_rd_reg(state, 0xed03);\r\nif (reg < 0)\r\nreturn -ENODEV;\r\nelse if (reg < ARRAY_SIZE(nv))\r\nnv_val = nv[reg];\r\nelse\r\nnv_val = 2;\r\nfor (i = 0; i < 50; i++) {\r\nret = it913x_rd_regs(state, 0xed23, &b[0], sizeof(b));\r\nreg = (b[1] << 8) + b[0];\r\nif (reg > 0)\r\nbreak;\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nudelay(2000);\r\n}\r\nstate->tun_fn_min = state->tun_xtal * reg;\r\nstate->tun_fn_min /= (state->tun_fdiv * nv_val);\r\ndev_dbg(&state->i2c_adap->dev, "%s: Tuner fn_min %d\n", __func__,\r\nstate->tun_fn_min);\r\nif (state->chip_ver > 1)\r\nmsleep(50);\r\nelse {\r\nfor (i = 0; i < 50; i++) {\r\nreg = it913x_rd_reg(state, 0xec82);\r\nif (reg > 0)\r\nbreak;\r\nif (reg < 0)\r\nreturn -ENODEV;\r\nudelay(2000);\r\n}\r\n}\r\nret = it913x_wr_reg(state, PRO_DMOD, 0xec40, 0x1);\r\nret |= it913x_wr_reg(state, PRO_DMOD, 0xfba8, 0x0);\r\nret |= it913x_wr_reg(state, PRO_DMOD, 0xec57, 0x0);\r\nret |= it913x_wr_reg(state, PRO_DMOD, 0xec58, 0x0);\r\nreturn it913x_wr_reg(state, PRO_DMOD, 0xed81, val);\r\n}\r\nstatic int it9137_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct it913x_state *state = fe->tuner_priv;\r\nstruct it913xset *set_tuner = set_it9137_template;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 bandwidth = p->bandwidth_hz;\r\nu32 frequency_m = p->frequency;\r\nint ret, reg;\r\nu32 frequency = frequency_m / 1000;\r\nu32 freq, temp_f, tmp;\r\nu16 iqik_m_cal;\r\nu16 n_div;\r\nu8 n;\r\nu8 l_band;\r\nu8 lna_band;\r\nu8 bw;\r\nif (state->firmware_ver == 1)\r\nset_tuner = set_it9135_template;\r\nelse\r\nset_tuner = set_it9137_template;\r\ndev_dbg(&state->i2c_adap->dev, "%s: Tuner Frequency %d Bandwidth %d\n",\r\n__func__, frequency, bandwidth);\r\nif (frequency >= 51000 && frequency <= 440000) {\r\nl_band = 0;\r\nlna_band = 0;\r\n} else if (frequency > 440000 && frequency <= 484000) {\r\nl_band = 1;\r\nlna_band = 1;\r\n} else if (frequency > 484000 && frequency <= 533000) {\r\nl_band = 1;\r\nlna_band = 2;\r\n} else if (frequency > 533000 && frequency <= 587000) {\r\nl_band = 1;\r\nlna_band = 3;\r\n} else if (frequency > 587000 && frequency <= 645000) {\r\nl_band = 1;\r\nlna_band = 4;\r\n} else if (frequency > 645000 && frequency <= 710000) {\r\nl_band = 1;\r\nlna_band = 5;\r\n} else if (frequency > 710000 && frequency <= 782000) {\r\nl_band = 1;\r\nlna_band = 6;\r\n} else if (frequency > 782000 && frequency <= 860000) {\r\nl_band = 1;\r\nlna_band = 7;\r\n} else if (frequency > 1450000 && frequency <= 1492000) {\r\nl_band = 1;\r\nlna_band = 0;\r\n} else if (frequency > 1660000 && frequency <= 1685000) {\r\nl_band = 1;\r\nlna_band = 1;\r\n} else\r\nreturn -EINVAL;\r\nset_tuner[0].reg[0] = lna_band;\r\nswitch (bandwidth) {\r\ncase 5000000:\r\nbw = 0;\r\nbreak;\r\ncase 6000000:\r\nbw = 2;\r\nbreak;\r\ncase 7000000:\r\nbw = 4;\r\nbreak;\r\ndefault:\r\ncase 8000000:\r\nbw = 6;\r\nbreak;\r\n}\r\nset_tuner[1].reg[0] = bw;\r\nset_tuner[2].reg[0] = 0xa0 | (l_band << 3);\r\nif (frequency > 53000 && frequency <= 74000) {\r\nn_div = 48;\r\nn = 0;\r\n} else if (frequency > 74000 && frequency <= 111000) {\r\nn_div = 32;\r\nn = 1;\r\n} else if (frequency > 111000 && frequency <= 148000) {\r\nn_div = 24;\r\nn = 2;\r\n} else if (frequency > 148000 && frequency <= 222000) {\r\nn_div = 16;\r\nn = 3;\r\n} else if (frequency > 222000 && frequency <= 296000) {\r\nn_div = 12;\r\nn = 4;\r\n} else if (frequency > 296000 && frequency <= 445000) {\r\nn_div = 8;\r\nn = 5;\r\n} else if (frequency > 445000 && frequency <= state->tun_fn_min) {\r\nn_div = 6;\r\nn = 6;\r\n} else if (frequency > state->tun_fn_min && frequency <= 950000) {\r\nn_div = 4;\r\nn = 7;\r\n} else if (frequency > 1450000 && frequency <= 1680000) {\r\nn_div = 2;\r\nn = 0;\r\n} else\r\nreturn -EINVAL;\r\nreg = it913x_rd_reg(state, 0xed81);\r\niqik_m_cal = (u16)reg * n_div;\r\nif (reg < 0x20) {\r\nif (state->tun_clk_mode == 0)\r\niqik_m_cal = (iqik_m_cal * 9) >> 5;\r\nelse\r\niqik_m_cal >>= 1;\r\n} else {\r\niqik_m_cal = 0x40 - iqik_m_cal;\r\nif (state->tun_clk_mode == 0)\r\niqik_m_cal = ~((iqik_m_cal * 9) >> 5);\r\nelse\r\niqik_m_cal = ~(iqik_m_cal >> 1);\r\n}\r\ntemp_f = frequency * (u32)n_div * (u32)state->tun_fdiv;\r\nfreq = temp_f / state->tun_xtal;\r\ntmp = freq * state->tun_xtal;\r\nif ((temp_f - tmp) >= (state->tun_xtal >> 1))\r\nfreq++;\r\nfreq += (u32) n << 13;\r\ntemp_f = freq + (u32)iqik_m_cal;\r\nset_tuner[3].reg[0] = temp_f & 0xff;\r\nset_tuner[4].reg[0] = (temp_f >> 8) & 0xff;\r\ndev_dbg(&state->i2c_adap->dev, "%s: High Frequency = %04x\n",\r\n__func__, temp_f);\r\nset_tuner[5].reg[0] = freq & 0xff;\r\nset_tuner[6].reg[0] = (freq >> 8) & 0xff;\r\ndev_dbg(&state->i2c_adap->dev, "%s: low Frequency = %04x\n",\r\n__func__, freq);\r\nret = it913x_script_loader(state, set_tuner);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct it913x_state *state = fe->tuner_priv;\r\nreturn it913x_script_loader(state, it9137_tuner_off);\r\n}\r\nstatic int it913x_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *it913x_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c_adap, u8 i2c_addr, u8 config)\r\n{\r\nstruct it913x_state *state = NULL;\r\nstate = kzalloc(sizeof(struct it913x_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->i2c_adap = i2c_adap;\r\nstate->i2c_addr = i2c_addr;\r\nswitch (config) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\nstate->chip_ver = 0x01;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nstate->chip_ver = 0x02;\r\nbreak;\r\ndefault:\r\ndev_dbg(&i2c_adap->dev,\r\n"%s: invalid config=%02x\n", __func__, config);\r\ngoto error;\r\n}\r\nstate->tuner_type = config;\r\nstate->firmware_ver = 1;\r\nfe->tuner_priv = state;\r\nmemcpy(&fe->ops.tuner_ops, &it913x_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\ndev_info(&i2c_adap->dev,\r\n"%s: ITE Tech IT913X successfully attached\n",\r\nKBUILD_MODNAME);\r\ndev_dbg(&i2c_adap->dev, "%s: config=%02x chip_ver=%02x\n",\r\n__func__, config, state->chip_ver);\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
