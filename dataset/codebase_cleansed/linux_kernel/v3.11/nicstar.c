static int nicstar_init_one(struct pci_dev *pcidev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic int index = -1;\r\nunsigned int error;\r\nindex++;\r\ncards[index] = NULL;\r\nerror = ns_init_card(index, pcidev);\r\nif (error) {\r\ncards[index--] = NULL;\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nreturn -ENODEV;\r\n}\r\nstatic void nicstar_remove_one(struct pci_dev *pcidev)\r\n{\r\nint i, j;\r\nns_dev *card = pci_get_drvdata(pcidev);\r\nstruct sk_buff *hb;\r\nstruct sk_buff *iovb;\r\nstruct sk_buff *lb;\r\nstruct sk_buff *sb;\r\ni = card->index;\r\nif (cards[i] == NULL)\r\nreturn;\r\nif (card->atmdev->phy && card->atmdev->phy->stop)\r\ncard->atmdev->phy->stop(card->atmdev);\r\nwritel(0x00000000, card->membase + CFG);\r\natm_dev_deregister(card->atmdev);\r\npci_disable_device(pcidev);\r\nj = 0;\r\nPRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);\r\nwhile ((hb = skb_dequeue(&card->hbpool.queue)) != NULL) {\r\ndev_kfree_skb_any(hb);\r\nj++;\r\n}\r\nPRINTK("nicstar%d: %d huge buffers freed.\n", i, j);\r\nj = 0;\r\nPRINTK("nicstar%d: freeing %d iovec buffers.\n", i,\r\ncard->iovpool.count);\r\nwhile ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL) {\r\ndev_kfree_skb_any(iovb);\r\nj++;\r\n}\r\nPRINTK("nicstar%d: %d iovec buffers freed.\n", i, j);\r\nwhile ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)\r\ndev_kfree_skb_any(lb);\r\nwhile ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)\r\ndev_kfree_skb_any(sb);\r\nfree_scq(card, card->scq0, NULL);\r\nfor (j = 0; j < NS_FRSCD_NUM; j++) {\r\nif (card->scd2vc[j] != NULL)\r\nfree_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);\r\n}\r\nidr_destroy(&card->idr);\r\npci_free_consistent(card->pcidev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,\r\ncard->rsq.org, card->rsq.dma);\r\npci_free_consistent(card->pcidev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,\r\ncard->tsq.org, card->tsq.dma);\r\nfree_irq(card->pcidev->irq, card);\r\niounmap(card->membase);\r\nkfree(card);\r\n}\r\nstatic int __init nicstar_init(void)\r\n{\r\nunsigned error = 0;\r\nXPRINTK("nicstar: nicstar_init() called.\n");\r\nerror = pci_register_driver(&nicstar_driver);\r\nTXPRINTK("nicstar: TX debug enabled.\n");\r\nRXPRINTK("nicstar: RX debug enabled.\n");\r\nPRINTK("nicstar: General debug enabled.\n");\r\n#ifdef PHY_LOOPBACK\r\nprintk("nicstar: using PHY loopback.\n");\r\n#endif\r\nXPRINTK("nicstar: nicstar_init() returned.\n");\r\nif (!error) {\r\ninit_timer(&ns_timer);\r\nns_timer.expires = jiffies + NS_POLL_PERIOD;\r\nns_timer.data = 0UL;\r\nns_timer.function = ns_poll;\r\nadd_timer(&ns_timer);\r\n}\r\nreturn error;\r\n}\r\nstatic void __exit nicstar_cleanup(void)\r\n{\r\nXPRINTK("nicstar: nicstar_cleanup() called.\n");\r\ndel_timer(&ns_timer);\r\npci_unregister_driver(&nicstar_driver);\r\nXPRINTK("nicstar: nicstar_cleanup() returned.\n");\r\n}\r\nstatic u32 ns_read_sram(ns_dev * card, u32 sram_address)\r\n{\r\nunsigned long flags;\r\nu32 data;\r\nsram_address <<= 2;\r\nsram_address &= 0x0007FFFC;\r\nsram_address |= 0x50000000;\r\nspin_lock_irqsave(&card->res_lock, flags);\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(sram_address, card->membase + CMD);\r\nwhile (CMD_BUSY(card)) ;\r\ndata = readl(card->membase + DR0);\r\nspin_unlock_irqrestore(&card->res_lock, flags);\r\nreturn data;\r\n}\r\nstatic void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,\r\nint count)\r\n{\r\nunsigned long flags;\r\nint i, c;\r\ncount--;\r\nc = count;\r\nc <<= 2;\r\nspin_lock_irqsave(&card->res_lock, flags);\r\nwhile (CMD_BUSY(card)) ;\r\nfor (i = 0; i <= c; i += 4)\r\nwritel(*(value++), card->membase + i);\r\nsram_address <<= 2;\r\nsram_address &= 0x0007FFFC;\r\nsram_address |= (0x40000000 | count);\r\nwritel(sram_address, card->membase + CMD);\r\nspin_unlock_irqrestore(&card->res_lock, flags);\r\n}\r\nstatic int ns_init_card(int i, struct pci_dev *pcidev)\r\n{\r\nint j;\r\nstruct ns_dev *card = NULL;\r\nunsigned char pci_latency;\r\nunsigned error;\r\nu32 data;\r\nu32 u32d[4];\r\nu32 ns_cfg_rctsize;\r\nint bcount;\r\nunsigned long membase;\r\nerror = 0;\r\nif (pci_enable_device(pcidev)) {\r\nprintk("nicstar%d: can't enable PCI device\n", i);\r\nerror = 2;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nif ((pci_set_dma_mask(pcidev, DMA_BIT_MASK(32)) != 0) ||\r\n(pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(32)) != 0)) {\r\nprintk(KERN_WARNING\r\n"nicstar%d: No suitable DMA available.\n", i);\r\nerror = 2;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nif ((card = kmalloc(sizeof(ns_dev), GFP_KERNEL)) == NULL) {\r\nprintk\r\n("nicstar%d: can't allocate memory for device structure.\n",\r\ni);\r\nerror = 2;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\ncards[i] = card;\r\nspin_lock_init(&card->int_lock);\r\nspin_lock_init(&card->res_lock);\r\npci_set_drvdata(pcidev, card);\r\ncard->index = i;\r\ncard->atmdev = NULL;\r\ncard->pcidev = pcidev;\r\nmembase = pci_resource_start(pcidev, 1);\r\ncard->membase = ioremap(membase, NS_IOREMAP_SIZE);\r\nif (!card->membase) {\r\nprintk("nicstar%d: can't ioremap() membase.\n", i);\r\nerror = 3;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nPRINTK("nicstar%d: membase at 0x%p.\n", i, card->membase);\r\npci_set_master(pcidev);\r\nif (pci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency) != 0) {\r\nprintk("nicstar%d: can't read PCI latency timer.\n", i);\r\nerror = 6;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\n#ifdef NS_PCI_LATENCY\r\nif (pci_latency < NS_PCI_LATENCY) {\r\nPRINTK("nicstar%d: setting PCI latency timer to %d.\n", i,\r\nNS_PCI_LATENCY);\r\nfor (j = 1; j < 4; j++) {\r\nif (pci_write_config_byte\r\n(pcidev, PCI_LATENCY_TIMER, NS_PCI_LATENCY) != 0)\r\nbreak;\r\n}\r\nif (j == 4) {\r\nprintk\r\n("nicstar%d: can't set PCI latency timer to %d.\n",\r\ni, NS_PCI_LATENCY);\r\nerror = 7;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\n}\r\n#endif\r\ndata = readl(card->membase + STAT);\r\nif (data & NS_STAT_TMROF)\r\nwritel(NS_STAT_TMROF, card->membase + STAT);\r\nwritel(NS_CFG_SWRST, card->membase + CFG);\r\nNS_DELAY;\r\nwritel(0x00000000, card->membase + CFG);\r\nwritel(0x00000008, card->membase + GP);\r\nNS_DELAY;\r\nwritel(0x00000001, card->membase + GP);\r\nNS_DELAY;\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);\r\nNS_DELAY;\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);\r\nwhile (CMD_BUSY(card)) ;\r\ndata = readl(card->membase + DR0);\r\nswitch (data) {\r\ncase 0x00000009:\r\nprintk("nicstar%d: PHY seems to be 25 Mbps.\n", i);\r\ncard->max_pcr = ATM_25_PCR;\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(0x00000008, card->membase + DR0);\r\nwritel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);\r\nwritel(NS_STAT_SFBQF, card->membase + STAT);\r\n#ifdef PHY_LOOPBACK\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(0x00000022, card->membase + DR0);\r\nwritel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);\r\n#endif\r\nbreak;\r\ncase 0x00000030:\r\ncase 0x00000031:\r\nprintk("nicstar%d: PHY seems to be 155 Mbps.\n", i);\r\ncard->max_pcr = ATM_OC3_PCR;\r\n#ifdef PHY_LOOPBACK\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(0x00000002, card->membase + DR0);\r\nwritel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk("nicstar%d: unknown PHY type (0x%08X).\n", i, data);\r\nerror = 8;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nwritel(0x00000000, card->membase + GP);\r\ndata = 0x76543210;\r\nns_write_sram(card, 0x1C003, &data, 1);\r\ndata = 0x89ABCDEF;\r\nns_write_sram(card, 0x14003, &data, 1);\r\nif (ns_read_sram(card, 0x14003) == 0x89ABCDEF &&\r\nns_read_sram(card, 0x1C003) == 0x76543210)\r\ncard->sram_size = 128;\r\nelse\r\ncard->sram_size = 32;\r\nPRINTK("nicstar%d: %dK x 32bit SRAM size.\n", i, card->sram_size);\r\ncard->rct_size = NS_MAX_RCTSIZE;\r\n#if (NS_MAX_RCTSIZE == 4096)\r\nif (card->sram_size == 128)\r\nprintk\r\n("nicstar%d: limiting maximum VCI. See NS_MAX_RCTSIZE in nicstar.h\n",\r\ni);\r\n#elif (NS_MAX_RCTSIZE == 16384)\r\nif (card->sram_size == 32) {\r\nprintk\r\n("nicstar%d: wasting memory. See NS_MAX_RCTSIZE in nicstar.h\n",\r\ni);\r\ncard->rct_size = 4096;\r\n}\r\n#else\r\n#error NS_MAX_RCTSIZE must be either 4096 or 16384 in nicstar.c\r\n#endif\r\ncard->vpibits = NS_VPIBITS;\r\nif (card->rct_size == 4096)\r\ncard->vcibits = 12 - NS_VPIBITS;\r\nelse\r\ncard->vcibits = 14 - NS_VPIBITS;\r\nif (mac[i] == NULL)\r\nnicstar_init_eprom(card->membase);\r\nwritel(0x00000000, card->membase + VPM);\r\ncard->tsq.org = pci_alloc_consistent(card->pcidev,\r\nNS_TSQSIZE + NS_TSQ_ALIGNMENT,\r\n&card->tsq.dma);\r\nif (card->tsq.org == NULL) {\r\nprintk("nicstar%d: can't allocate TSQ.\n", i);\r\nerror = 10;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\ncard->tsq.base = PTR_ALIGN(card->tsq.org, NS_TSQ_ALIGNMENT);\r\ncard->tsq.next = card->tsq.base;\r\ncard->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);\r\nfor (j = 0; j < NS_TSQ_NUM_ENTRIES; j++)\r\nns_tsi_init(card->tsq.base + j);\r\nwritel(0x00000000, card->membase + TSQH);\r\nwritel(ALIGN(card->tsq.dma, NS_TSQ_ALIGNMENT), card->membase + TSQB);\r\nPRINTK("nicstar%d: TSQ base at 0x%p.\n", i, card->tsq.base);\r\ncard->rsq.org = pci_alloc_consistent(card->pcidev,\r\nNS_RSQSIZE + NS_RSQ_ALIGNMENT,\r\n&card->rsq.dma);\r\nif (card->rsq.org == NULL) {\r\nprintk("nicstar%d: can't allocate RSQ.\n", i);\r\nerror = 11;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\ncard->rsq.base = PTR_ALIGN(card->rsq.org, NS_RSQ_ALIGNMENT);\r\ncard->rsq.next = card->rsq.base;\r\ncard->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);\r\nfor (j = 0; j < NS_RSQ_NUM_ENTRIES; j++)\r\nns_rsqe_init(card->rsq.base + j);\r\nwritel(0x00000000, card->membase + RSQH);\r\nwritel(ALIGN(card->rsq.dma, NS_RSQ_ALIGNMENT), card->membase + RSQB);\r\nPRINTK("nicstar%d: RSQ base at 0x%p.\n", i, card->rsq.base);\r\ncard->scq1 = NULL;\r\ncard->scq2 = NULL;\r\ncard->scq0 = get_scq(card, VBR_SCQSIZE, NS_VRSCD0);\r\nif (card->scq0 == NULL) {\r\nprintk("nicstar%d: can't get SCQ0.\n", i);\r\nerror = 12;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nu32d[0] = scq_virt_to_bus(card->scq0, card->scq0->base);\r\nu32d[1] = (u32) 0x00000000;\r\nu32d[2] = (u32) 0xffffffff;\r\nu32d[3] = (u32) 0x00000000;\r\nns_write_sram(card, NS_VRSCD0, u32d, 4);\r\nns_write_sram(card, NS_VRSCD1, u32d, 4);\r\nns_write_sram(card, NS_VRSCD2, u32d, 4);\r\ncard->scq0->scd = NS_VRSCD0;\r\nPRINTK("nicstar%d: VBR-SCQ0 base at 0x%p.\n", i, card->scq0->base);\r\ncard->tst_addr = NS_TST0;\r\ncard->tst_free_entries = NS_TST_NUM_ENTRIES;\r\ndata = NS_TST_OPCODE_VARIABLE;\r\nfor (j = 0; j < NS_TST_NUM_ENTRIES; j++)\r\nns_write_sram(card, NS_TST0 + j, &data, 1);\r\ndata = ns_tste_make(NS_TST_OPCODE_END, NS_TST0);\r\nns_write_sram(card, NS_TST0 + NS_TST_NUM_ENTRIES, &data, 1);\r\nfor (j = 0; j < NS_TST_NUM_ENTRIES; j++)\r\nns_write_sram(card, NS_TST1 + j, &data, 1);\r\ndata = ns_tste_make(NS_TST_OPCODE_END, NS_TST1);\r\nns_write_sram(card, NS_TST1 + NS_TST_NUM_ENTRIES, &data, 1);\r\nfor (j = 0; j < NS_TST_NUM_ENTRIES; j++)\r\ncard->tste2vc[j] = NULL;\r\nwritel(NS_TST0 << 2, card->membase + TSTB);\r\n#ifdef RCQ_SUPPORT\r\nu32d[0] = NS_RCTE_RAWCELLINTEN;\r\n#else\r\nu32d[0] = 0x00000000;\r\n#endif\r\nu32d[1] = 0x00000000;\r\nu32d[2] = 0x00000000;\r\nu32d[3] = 0xFFFFFFFF;\r\nfor (j = 0; j < card->rct_size; j++)\r\nns_write_sram(card, j * 4, u32d, 4);\r\nmemset(card->vcmap, 0, NS_MAX_RCTSIZE * sizeof(vc_map));\r\nfor (j = 0; j < NS_FRSCD_NUM; j++)\r\ncard->scd2vc[j] = NULL;\r\ncard->sbnr.min = MIN_SB;\r\ncard->sbnr.init = NUM_SB;\r\ncard->sbnr.max = MAX_SB;\r\ncard->lbnr.min = MIN_LB;\r\ncard->lbnr.init = NUM_LB;\r\ncard->lbnr.max = MAX_LB;\r\ncard->iovnr.min = MIN_IOVB;\r\ncard->iovnr.init = NUM_IOVB;\r\ncard->iovnr.max = MAX_IOVB;\r\ncard->hbnr.min = MIN_HB;\r\ncard->hbnr.init = NUM_HB;\r\ncard->hbnr.max = MAX_HB;\r\ncard->sm_handle = 0x00000000;\r\ncard->sm_addr = 0x00000000;\r\ncard->lg_handle = 0x00000000;\r\ncard->lg_addr = 0x00000000;\r\ncard->efbie = 1;\r\nidr_init(&card->idr);\r\nskb_queue_head_init(&card->hbpool.queue);\r\ncard->hbpool.count = 0;\r\nfor (j = 0; j < NUM_HB; j++) {\r\nstruct sk_buff *hb;\r\nhb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);\r\nif (hb == NULL) {\r\nprintk\r\n("nicstar%d: can't allocate %dth of %d huge buffers.\n",\r\ni, j, NUM_HB);\r\nerror = 13;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nNS_PRV_BUFTYPE(hb) = BUF_NONE;\r\nskb_queue_tail(&card->hbpool.queue, hb);\r\ncard->hbpool.count++;\r\n}\r\nskb_queue_head_init(&card->lbpool.queue);\r\ncard->lbpool.count = 0;\r\nfor (j = 0; j < NUM_LB; j++) {\r\nstruct sk_buff *lb;\r\nlb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);\r\nif (lb == NULL) {\r\nprintk\r\n("nicstar%d: can't allocate %dth of %d large buffers.\n",\r\ni, j, NUM_LB);\r\nerror = 14;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nNS_PRV_BUFTYPE(lb) = BUF_LG;\r\nskb_queue_tail(&card->lbpool.queue, lb);\r\nskb_reserve(lb, NS_SMBUFSIZE);\r\npush_rxbufs(card, lb);\r\nif (j == 1) {\r\ncard->rcbuf = lb;\r\ncard->rawcell = (struct ns_rcqe *) lb->data;\r\ncard->rawch = NS_PRV_DMA(lb);\r\n}\r\n}\r\nif ((bcount =\r\nns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min) {\r\nprintk\r\n("nicstar%d: Strange... Just allocated %d large buffers and lfbqc = %d.\n",\r\ni, j, bcount);\r\nerror = 14;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nskb_queue_head_init(&card->sbpool.queue);\r\ncard->sbpool.count = 0;\r\nfor (j = 0; j < NUM_SB; j++) {\r\nstruct sk_buff *sb;\r\nsb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);\r\nif (sb == NULL) {\r\nprintk\r\n("nicstar%d: can't allocate %dth of %d small buffers.\n",\r\ni, j, NUM_SB);\r\nerror = 15;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nNS_PRV_BUFTYPE(sb) = BUF_SM;\r\nskb_queue_tail(&card->sbpool.queue, sb);\r\nskb_reserve(sb, NS_AAL0_HEADER);\r\npush_rxbufs(card, sb);\r\n}\r\nif ((bcount =\r\nns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min) {\r\nprintk\r\n("nicstar%d: Strange... Just allocated %d small buffers and sfbqc = %d.\n",\r\ni, j, bcount);\r\nerror = 15;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nskb_queue_head_init(&card->iovpool.queue);\r\ncard->iovpool.count = 0;\r\nfor (j = 0; j < NUM_IOVB; j++) {\r\nstruct sk_buff *iovb;\r\niovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);\r\nif (iovb == NULL) {\r\nprintk\r\n("nicstar%d: can't allocate %dth of %d iovec buffers.\n",\r\ni, j, NUM_IOVB);\r\nerror = 16;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nNS_PRV_BUFTYPE(iovb) = BUF_NONE;\r\nskb_queue_tail(&card->iovpool.queue, iovb);\r\ncard->iovpool.count++;\r\n}\r\nif (card->rct_size == 4096)\r\nns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES;\r\nelse\r\nns_cfg_rctsize = NS_CFG_RCTSIZE_16384_ENTRIES;\r\ncard->efbie = 1;\r\ncard->intcnt = 0;\r\nif (request_irq\r\n(pcidev->irq, &ns_irq_handler, IRQF_SHARED, "nicstar", card) != 0) {\r\nprintk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);\r\nerror = 9;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\ncard->atmdev = atm_dev_register("nicstar", &card->pcidev->dev, &atm_ops,\r\n-1, NULL);\r\nif (card->atmdev == NULL) {\r\nprintk("nicstar%d: can't register device.\n", i);\r\nerror = 17;\r\nns_init_card_error(card, error);\r\nreturn error;\r\n}\r\nif (ns_parse_mac(mac[i], card->atmdev->esi)) {\r\nnicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,\r\ncard->atmdev->esi, 6);\r\nif (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) ==\r\n0) {\r\nnicstar_read_eprom(card->membase,\r\nNICSTAR_EPROM_MAC_ADDR_OFFSET_ALT,\r\ncard->atmdev->esi, 6);\r\n}\r\n}\r\nprintk("nicstar%d: MAC address %pM\n", i, card->atmdev->esi);\r\ncard->atmdev->dev_data = card;\r\ncard->atmdev->ci_range.vpi_bits = card->vpibits;\r\ncard->atmdev->ci_range.vci_bits = card->vcibits;\r\ncard->atmdev->link_rate = card->max_pcr;\r\ncard->atmdev->phy = NULL;\r\n#ifdef CONFIG_ATM_NICSTAR_USE_SUNI\r\nif (card->max_pcr == ATM_OC3_PCR)\r\nsuni_init(card->atmdev);\r\n#endif\r\n#ifdef CONFIG_ATM_NICSTAR_USE_IDT77105\r\nif (card->max_pcr == ATM_25_PCR)\r\nidt77105_init(card->atmdev);\r\n#endif\r\nif (card->atmdev->phy && card->atmdev->phy->start)\r\ncard->atmdev->phy->start(card->atmdev);\r\nwritel(NS_CFG_RXPATH | NS_CFG_SMBUFSIZE | NS_CFG_LGBUFSIZE | NS_CFG_EFBIE | NS_CFG_RSQSIZE | NS_CFG_VPIBITS | ns_cfg_rctsize | NS_CFG_RXINT_NODELAY | NS_CFG_RAWIE |\r\nNS_CFG_RSQAFIE | NS_CFG_TXEN | NS_CFG_TXIE | NS_CFG_TSQFIE_OPT |\r\nNS_CFG_PHYIE, card->membase + CFG);\r\nnum_cards++;\r\nreturn error;\r\n}\r\nstatic void ns_init_card_error(ns_dev *card, int error)\r\n{\r\nif (error >= 17) {\r\nwritel(0x00000000, card->membase + CFG);\r\n}\r\nif (error >= 16) {\r\nstruct sk_buff *iovb;\r\nwhile ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)\r\ndev_kfree_skb_any(iovb);\r\n}\r\nif (error >= 15) {\r\nstruct sk_buff *sb;\r\nwhile ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)\r\ndev_kfree_skb_any(sb);\r\nfree_scq(card, card->scq0, NULL);\r\n}\r\nif (error >= 14) {\r\nstruct sk_buff *lb;\r\nwhile ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)\r\ndev_kfree_skb_any(lb);\r\n}\r\nif (error >= 13) {\r\nstruct sk_buff *hb;\r\nwhile ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)\r\ndev_kfree_skb_any(hb);\r\n}\r\nif (error >= 12) {\r\nkfree(card->rsq.org);\r\n}\r\nif (error >= 11) {\r\nkfree(card->tsq.org);\r\n}\r\nif (error >= 10) {\r\nfree_irq(card->pcidev->irq, card);\r\n}\r\nif (error >= 4) {\r\niounmap(card->membase);\r\n}\r\nif (error >= 3) {\r\npci_disable_device(card->pcidev);\r\nkfree(card);\r\n}\r\n}\r\nstatic scq_info *get_scq(ns_dev *card, int size, u32 scd)\r\n{\r\nscq_info *scq;\r\nint i;\r\nif (size != VBR_SCQSIZE && size != CBR_SCQSIZE)\r\nreturn NULL;\r\nscq = kmalloc(sizeof(scq_info), GFP_KERNEL);\r\nif (!scq)\r\nreturn NULL;\r\nscq->org = pci_alloc_consistent(card->pcidev, 2 * size, &scq->dma);\r\nif (!scq->org) {\r\nkfree(scq);\r\nreturn NULL;\r\n}\r\nscq->skb = kmalloc(sizeof(struct sk_buff *) *\r\n(size / NS_SCQE_SIZE), GFP_KERNEL);\r\nif (!scq->skb) {\r\nkfree(scq->org);\r\nkfree(scq);\r\nreturn NULL;\r\n}\r\nscq->num_entries = size / NS_SCQE_SIZE;\r\nscq->base = PTR_ALIGN(scq->org, size);\r\nscq->next = scq->base;\r\nscq->last = scq->base + (scq->num_entries - 1);\r\nscq->tail = scq->last;\r\nscq->scd = scd;\r\nscq->num_entries = size / NS_SCQE_SIZE;\r\nscq->tbd_count = 0;\r\ninit_waitqueue_head(&scq->scqfull_waitq);\r\nscq->full = 0;\r\nspin_lock_init(&scq->lock);\r\nfor (i = 0; i < scq->num_entries; i++)\r\nscq->skb[i] = NULL;\r\nreturn scq;\r\n}\r\nstatic void free_scq(ns_dev *card, scq_info *scq, struct atm_vcc *vcc)\r\n{\r\nint i;\r\nif (scq->num_entries == VBR_SCQ_NUM_ENTRIES)\r\nfor (i = 0; i < scq->num_entries; i++) {\r\nif (scq->skb[i] != NULL) {\r\nvcc = ATM_SKB(scq->skb[i])->vcc;\r\nif (vcc->pop != NULL)\r\nvcc->pop(vcc, scq->skb[i]);\r\nelse\r\ndev_kfree_skb_any(scq->skb[i]);\r\n}\r\n} else {\r\nif (vcc == NULL) {\r\nprintk\r\n("nicstar: free_scq() called with vcc == NULL for fixed rate scq.");\r\nfor (i = 0; i < scq->num_entries; i++)\r\ndev_kfree_skb_any(scq->skb[i]);\r\n} else\r\nfor (i = 0; i < scq->num_entries; i++) {\r\nif (scq->skb[i] != NULL) {\r\nif (vcc->pop != NULL)\r\nvcc->pop(vcc, scq->skb[i]);\r\nelse\r\ndev_kfree_skb_any(scq->skb[i]);\r\n}\r\n}\r\n}\r\nkfree(scq->skb);\r\npci_free_consistent(card->pcidev,\r\n2 * (scq->num_entries == VBR_SCQ_NUM_ENTRIES ?\r\nVBR_SCQSIZE : CBR_SCQSIZE),\r\nscq->org, scq->dma);\r\nkfree(scq);\r\n}\r\nstatic void push_rxbufs(ns_dev * card, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *handle1, *handle2;\r\nint id1, id2;\r\nu32 addr1, addr2;\r\nu32 stat;\r\nunsigned long flags;\r\nhandle2 = NULL;\r\naddr2 = 0;\r\nhandle1 = skb;\r\naddr1 = pci_map_single(card->pcidev,\r\nskb->data,\r\n(NS_PRV_BUFTYPE(skb) == BUF_SM\r\n? NS_SMSKBSIZE : NS_LGSKBSIZE),\r\nPCI_DMA_TODEVICE);\r\nNS_PRV_DMA(skb) = addr1;\r\n#ifdef GENERAL_DEBUG\r\nif (!addr1)\r\nprintk("nicstar%d: push_rxbufs called with addr1 = 0.\n",\r\ncard->index);\r\n#endif\r\nstat = readl(card->membase + STAT);\r\ncard->sbfqc = ns_stat_sfbqc_get(stat);\r\ncard->lbfqc = ns_stat_lfbqc_get(stat);\r\nif (NS_PRV_BUFTYPE(skb) == BUF_SM) {\r\nif (!addr2) {\r\nif (card->sm_addr) {\r\naddr2 = card->sm_addr;\r\nhandle2 = card->sm_handle;\r\ncard->sm_addr = 0x00000000;\r\ncard->sm_handle = 0x00000000;\r\n} else {\r\ncard->sm_addr = addr1;\r\ncard->sm_handle = handle1;\r\n}\r\n}\r\n} else {\r\nif (!addr2) {\r\nif (card->lg_addr) {\r\naddr2 = card->lg_addr;\r\nhandle2 = card->lg_handle;\r\ncard->lg_addr = 0x00000000;\r\ncard->lg_handle = 0x00000000;\r\n} else {\r\ncard->lg_addr = addr1;\r\ncard->lg_handle = handle1;\r\n}\r\n}\r\n}\r\nif (addr2) {\r\nif (NS_PRV_BUFTYPE(skb) == BUF_SM) {\r\nif (card->sbfqc >= card->sbnr.max) {\r\nskb_unlink(handle1, &card->sbpool.queue);\r\ndev_kfree_skb_any(handle1);\r\nskb_unlink(handle2, &card->sbpool.queue);\r\ndev_kfree_skb_any(handle2);\r\nreturn;\r\n} else\r\ncard->sbfqc += 2;\r\n} else {\r\nif (card->lbfqc >= card->lbnr.max) {\r\nskb_unlink(handle1, &card->lbpool.queue);\r\ndev_kfree_skb_any(handle1);\r\nskb_unlink(handle2, &card->lbpool.queue);\r\ndev_kfree_skb_any(handle2);\r\nreturn;\r\n} else\r\ncard->lbfqc += 2;\r\n}\r\nid1 = idr_alloc(&card->idr, handle1, 0, 0, GFP_ATOMIC);\r\nif (id1 < 0)\r\ngoto out;\r\nid2 = idr_alloc(&card->idr, handle2, 0, 0, GFP_ATOMIC);\r\nif (id2 < 0)\r\ngoto out;\r\nspin_lock_irqsave(&card->res_lock, flags);\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(addr2, card->membase + DR3);\r\nwritel(id2, card->membase + DR2);\r\nwritel(addr1, card->membase + DR1);\r\nwritel(id1, card->membase + DR0);\r\nwritel(NS_CMD_WRITE_FREEBUFQ | NS_PRV_BUFTYPE(skb),\r\ncard->membase + CMD);\r\nspin_unlock_irqrestore(&card->res_lock, flags);\r\nXPRINTK("nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\n",\r\ncard->index,\r\n(NS_PRV_BUFTYPE(skb) == BUF_SM ? "small" : "large"),\r\naddr1, addr2);\r\n}\r\nif (!card->efbie && card->sbfqc >= card->sbnr.min &&\r\ncard->lbfqc >= card->lbnr.min) {\r\ncard->efbie = 1;\r\nwritel((readl(card->membase + CFG) | NS_CFG_EFBIE),\r\ncard->membase + CFG);\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic irqreturn_t ns_irq_handler(int irq, void *dev_id)\r\n{\r\nu32 stat_r;\r\nns_dev *card;\r\nstruct atm_dev *dev;\r\nunsigned long flags;\r\ncard = (ns_dev *) dev_id;\r\ndev = card->atmdev;\r\ncard->intcnt++;\r\nPRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);\r\nspin_lock_irqsave(&card->int_lock, flags);\r\nstat_r = readl(card->membase + STAT);\r\nif (stat_r & NS_STAT_TSIF) {\r\nTXPRINTK("nicstar%d: TSI interrupt\n", card->index);\r\nprocess_tsq(card);\r\nwritel(NS_STAT_TSIF, card->membase + STAT);\r\n}\r\nif (stat_r & NS_STAT_TXICP) {\r\nwritel(NS_STAT_TXICP, card->membase + STAT);\r\nTXPRINTK("nicstar%d: Incomplete CS-PDU transmitted.\n",\r\ncard->index);\r\n}\r\nif (stat_r & NS_STAT_TSQF) {\r\nwritel(NS_STAT_TSQF, card->membase + STAT);\r\nPRINTK("nicstar%d: TSQ full.\n", card->index);\r\nprocess_tsq(card);\r\n}\r\nif (stat_r & NS_STAT_TMROF) {\r\nwritel(NS_STAT_TMROF, card->membase + STAT);\r\nPRINTK("nicstar%d: Timer overflow.\n", card->index);\r\n}\r\nif (stat_r & NS_STAT_PHYI) {\r\nwritel(NS_STAT_PHYI, card->membase + STAT);\r\nPRINTK("nicstar%d: PHY interrupt.\n", card->index);\r\nif (dev->phy && dev->phy->interrupt) {\r\ndev->phy->interrupt(dev);\r\n}\r\n}\r\nif (stat_r & NS_STAT_SFBQF) {\r\nwritel(NS_STAT_SFBQF, card->membase + STAT);\r\nprintk("nicstar%d: Small free buffer queue is full.\n",\r\ncard->index);\r\n}\r\nif (stat_r & NS_STAT_LFBQF) {\r\nwritel(NS_STAT_LFBQF, card->membase + STAT);\r\nprintk("nicstar%d: Large free buffer queue is full.\n",\r\ncard->index);\r\n}\r\nif (stat_r & NS_STAT_RSQF) {\r\nwritel(NS_STAT_RSQF, card->membase + STAT);\r\nprintk("nicstar%d: RSQ full.\n", card->index);\r\nprocess_rsq(card);\r\n}\r\nif (stat_r & NS_STAT_EOPDU) {\r\nRXPRINTK("nicstar%d: End of CS-PDU received.\n", card->index);\r\nprocess_rsq(card);\r\nwritel(NS_STAT_EOPDU, card->membase + STAT);\r\n}\r\nif (stat_r & NS_STAT_RAWCF) {\r\nwritel(NS_STAT_RAWCF, card->membase + STAT);\r\n#ifndef RCQ_SUPPORT\r\nprintk("nicstar%d: Raw cell received and no support yet...\n",\r\ncard->index);\r\n#endif\r\nwhile (readl(card->membase + RAWCT) != card->rawch) {\r\nif (ns_rcqe_islast(card->rawcell)) {\r\nstruct sk_buff *oldbuf;\r\noldbuf = card->rcbuf;\r\ncard->rcbuf = idr_find(&card->idr,\r\nns_rcqe_nextbufhandle(card->rawcell));\r\ncard->rawch = NS_PRV_DMA(card->rcbuf);\r\ncard->rawcell = (struct ns_rcqe *)\r\ncard->rcbuf->data;\r\nrecycle_rx_buf(card, oldbuf);\r\n} else {\r\ncard->rawch += NS_RCQE_SIZE;\r\ncard->rawcell++;\r\n}\r\n}\r\n}\r\nif (stat_r & NS_STAT_SFBQE) {\r\nint i;\r\nstruct sk_buff *sb;\r\nwritel(NS_STAT_SFBQE, card->membase + STAT);\r\nprintk("nicstar%d: Small free buffer queue empty.\n",\r\ncard->index);\r\nfor (i = 0; i < card->sbnr.min; i++) {\r\nsb = dev_alloc_skb(NS_SMSKBSIZE);\r\nif (sb == NULL) {\r\nwritel(readl(card->membase + CFG) &\r\n~NS_CFG_EFBIE, card->membase + CFG);\r\ncard->efbie = 0;\r\nbreak;\r\n}\r\nNS_PRV_BUFTYPE(sb) = BUF_SM;\r\nskb_queue_tail(&card->sbpool.queue, sb);\r\nskb_reserve(sb, NS_AAL0_HEADER);\r\npush_rxbufs(card, sb);\r\n}\r\ncard->sbfqc = i;\r\nprocess_rsq(card);\r\n}\r\nif (stat_r & NS_STAT_LFBQE) {\r\nint i;\r\nstruct sk_buff *lb;\r\nwritel(NS_STAT_LFBQE, card->membase + STAT);\r\nprintk("nicstar%d: Large free buffer queue empty.\n",\r\ncard->index);\r\nfor (i = 0; i < card->lbnr.min; i++) {\r\nlb = dev_alloc_skb(NS_LGSKBSIZE);\r\nif (lb == NULL) {\r\nwritel(readl(card->membase + CFG) &\r\n~NS_CFG_EFBIE, card->membase + CFG);\r\ncard->efbie = 0;\r\nbreak;\r\n}\r\nNS_PRV_BUFTYPE(lb) = BUF_LG;\r\nskb_queue_tail(&card->lbpool.queue, lb);\r\nskb_reserve(lb, NS_SMBUFSIZE);\r\npush_rxbufs(card, lb);\r\n}\r\ncard->lbfqc = i;\r\nprocess_rsq(card);\r\n}\r\nif (stat_r & NS_STAT_RSQAF) {\r\nwritel(NS_STAT_RSQAF, card->membase + STAT);\r\nRXPRINTK("nicstar%d: RSQ almost full.\n", card->index);\r\nprocess_rsq(card);\r\n}\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\nPRINTK("nicstar%d: end of interrupt service\n", card->index);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ns_open(struct atm_vcc *vcc)\r\n{\r\nns_dev *card;\r\nvc_map *vc;\r\nunsigned long tmpl, modl;\r\nint tcr, tcra;\r\nint n = 0;\r\nu32 u32d[4];\r\nint frscdi = 0;\r\nint inuse;\r\nshort vpi = vcc->vpi;\r\nint vci = vcc->vci;\r\ncard = (ns_dev *) vcc->dev->dev_data;\r\nPRINTK("nicstar%d: opening vpi.vci %d.%d \n", card->index, (int)vpi,\r\nvci);\r\nif (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {\r\nPRINTK("nicstar%d: unsupported AAL.\n", card->index);\r\nreturn -EINVAL;\r\n}\r\nvc = &(card->vcmap[vpi << card->vcibits | vci]);\r\nvcc->dev_data = vc;\r\ninuse = 0;\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE && vc->tx)\r\ninuse = 1;\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE && vc->rx)\r\ninuse += 2;\r\nif (inuse) {\r\nprintk("nicstar%d: %s vci already in use.\n", card->index,\r\ninuse == 1 ? "tx" : inuse == 2 ? "rx" : "tx and rx");\r\nreturn -EINVAL;\r\n}\r\nset_bit(ATM_VF_ADDR, &vcc->flags);\r\nif (!test_bit(ATM_VF_PARTIAL, &vcc->flags)) {\r\nscq_info *scq;\r\nset_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nif (vcc->qos.txtp.traffic_class == ATM_CBR) {\r\nif (vcc->qos.txtp.max_pcr == 0 && vcc->qos.txtp.pcr == 0\r\n&& vcc->qos.txtp.min_pcr == 0) {\r\nPRINTK\r\n("nicstar%d: trying to open a CBR vc with cell rate = 0 \n",\r\ncard->index);\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn -EINVAL;\r\n}\r\ntcr = atm_pcr_goal(&(vcc->qos.txtp));\r\ntcra = tcr >= 0 ? tcr : -tcr;\r\nPRINTK("nicstar%d: target cell rate = %d.\n",\r\ncard->index, vcc->qos.txtp.max_pcr);\r\ntmpl =\r\n(unsigned long)tcra *(unsigned long)\r\nNS_TST_NUM_ENTRIES;\r\nmodl = tmpl % card->max_pcr;\r\nn = (int)(tmpl / card->max_pcr);\r\nif (tcr > 0) {\r\nif (modl > 0)\r\nn++;\r\n} else if (tcr == 0) {\r\nif ((n =\r\n(card->tst_free_entries -\r\nNS_TST_RESERVED)) <= 0) {\r\nPRINTK\r\n("nicstar%d: no CBR bandwidth free.\n",\r\ncard->index);\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (n == 0) {\r\nprintk\r\n("nicstar%d: selected bandwidth < granularity.\n",\r\ncard->index);\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn -EINVAL;\r\n}\r\nif (n > (card->tst_free_entries - NS_TST_RESERVED)) {\r\nPRINTK\r\n("nicstar%d: not enough free CBR bandwidth.\n",\r\ncard->index);\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn -EINVAL;\r\n} else\r\ncard->tst_free_entries -= n;\r\nXPRINTK("nicstar%d: writing %d tst entries.\n",\r\ncard->index, n);\r\nfor (frscdi = 0; frscdi < NS_FRSCD_NUM; frscdi++) {\r\nif (card->scd2vc[frscdi] == NULL) {\r\ncard->scd2vc[frscdi] = vc;\r\nbreak;\r\n}\r\n}\r\nif (frscdi == NS_FRSCD_NUM) {\r\nPRINTK\r\n("nicstar%d: no SCD available for CBR channel.\n",\r\ncard->index);\r\ncard->tst_free_entries += n;\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn -EBUSY;\r\n}\r\nvc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;\r\nscq = get_scq(card, CBR_SCQSIZE, vc->cbr_scd);\r\nif (scq == NULL) {\r\nPRINTK("nicstar%d: can't get fixed rate SCQ.\n",\r\ncard->index);\r\ncard->scd2vc[frscdi] = NULL;\r\ncard->tst_free_entries += n;\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn -ENOMEM;\r\n}\r\nvc->scq = scq;\r\nu32d[0] = scq_virt_to_bus(scq, scq->base);\r\nu32d[1] = (u32) 0x00000000;\r\nu32d[2] = (u32) 0xffffffff;\r\nu32d[3] = (u32) 0x00000000;\r\nns_write_sram(card, vc->cbr_scd, u32d, 4);\r\nfill_tst(card, n, vc);\r\n} else if (vcc->qos.txtp.traffic_class == ATM_UBR) {\r\nvc->cbr_scd = 0x00000000;\r\nvc->scq = card->scq0;\r\n}\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE) {\r\nvc->tx = 1;\r\nvc->tx_vcc = vcc;\r\nvc->tbd_count = 0;\r\n}\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nu32 status;\r\nvc->rx = 1;\r\nvc->rx_vcc = vcc;\r\nvc->rx_iov = NULL;\r\nif (vcc->qos.aal == ATM_AAL5)\r\nstatus = NS_RCTE_AAL5 | NS_RCTE_CONNECTOPEN;\r\nelse\r\nstatus = NS_RCTE_AAL0 | NS_RCTE_CONNECTOPEN;\r\n#ifdef RCQ_SUPPORT\r\nstatus |= NS_RCTE_RAWCELLINTEN;\r\n#endif\r\nns_write_sram(card,\r\nNS_RCT +\r\n(vpi << card->vcibits | vci) *\r\nNS_RCT_ENTRY_SIZE, &status, 1);\r\n}\r\n}\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nreturn 0;\r\n}\r\nstatic void ns_close(struct atm_vcc *vcc)\r\n{\r\nvc_map *vc;\r\nns_dev *card;\r\nu32 data;\r\nint i;\r\nvc = vcc->dev_data;\r\ncard = vcc->dev->dev_data;\r\nPRINTK("nicstar%d: closing vpi.vci %d.%d \n", card->index,\r\n(int)vcc->vpi, vcc->vci);\r\nclear_bit(ATM_VF_READY, &vcc->flags);\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nu32 addr;\r\nunsigned long flags;\r\naddr =\r\nNS_RCT +\r\n(vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;\r\nspin_lock_irqsave(&card->res_lock, flags);\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(NS_CMD_CLOSE_CONNECTION | addr << 2,\r\ncard->membase + CMD);\r\nspin_unlock_irqrestore(&card->res_lock, flags);\r\nvc->rx = 0;\r\nif (vc->rx_iov != NULL) {\r\nstruct sk_buff *iovb;\r\nu32 stat;\r\nstat = readl(card->membase + STAT);\r\ncard->sbfqc = ns_stat_sfbqc_get(stat);\r\ncard->lbfqc = ns_stat_lfbqc_get(stat);\r\nPRINTK\r\n("nicstar%d: closing a VC with pending rx buffers.\n",\r\ncard->index);\r\niovb = vc->rx_iov;\r\nrecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\r\nNS_PRV_IOVCNT(iovb));\r\nNS_PRV_IOVCNT(iovb) = 0;\r\nspin_lock_irqsave(&card->int_lock, flags);\r\nrecycle_iov_buf(card, iovb);\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\nvc->rx_iov = NULL;\r\n}\r\n}\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE) {\r\nvc->tx = 0;\r\n}\r\nif (vcc->qos.txtp.traffic_class == ATM_CBR) {\r\nunsigned long flags;\r\nns_scqe *scqep;\r\nscq_info *scq;\r\nscq = vc->scq;\r\nfor (;;) {\r\nspin_lock_irqsave(&scq->lock, flags);\r\nscqep = scq->next;\r\nif (scqep == scq->base)\r\nscqep = scq->last;\r\nelse\r\nscqep--;\r\nif (scqep == scq->tail) {\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nbreak;\r\n}\r\nif (!ns_scqe_is_tsr(scqep) && scq->tail != scq->next) {\r\nns_scqe tsr;\r\nu32 scdi, scqi;\r\nu32 data;\r\nint index;\r\ntsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);\r\nscdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;\r\nscqi = scq->next - scq->base;\r\ntsr.word_2 = ns_tsr_mkword_2(scdi, scqi);\r\ntsr.word_3 = 0x00000000;\r\ntsr.word_4 = 0x00000000;\r\n*scq->next = tsr;\r\nindex = (int)scqi;\r\nscq->skb[index] = NULL;\r\nif (scq->next == scq->last)\r\nscq->next = scq->base;\r\nelse\r\nscq->next++;\r\ndata = scq_virt_to_bus(scq, scq->next);\r\nns_write_sram(card, scq->scd, &data, 1);\r\n}\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nschedule();\r\n}\r\ndata = NS_TST_OPCODE_VARIABLE;\r\nfor (i = 0; i < NS_TST_NUM_ENTRIES; i++) {\r\nif (card->tste2vc[i] == vc) {\r\nns_write_sram(card, card->tst_addr + i, &data,\r\n1);\r\ncard->tste2vc[i] = NULL;\r\ncard->tst_free_entries++;\r\n}\r\n}\r\ncard->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;\r\nfree_scq(card, vc->scq, vcc);\r\n}\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE) {\r\nunsigned long flags;\r\nscq_info *scq = card->scq0;\r\nspin_lock_irqsave(&scq->lock, flags);\r\nfor (i = 0; i < scq->num_entries; i++) {\r\nif (scq->skb[i] && ATM_SKB(scq->skb[i])->vcc == vcc) {\r\nATM_SKB(scq->skb[i])->vcc = NULL;\r\natm_return(vcc, scq->skb[i]->truesize);\r\nPRINTK\r\n("nicstar: deleted pending vcc mapping\n");\r\n}\r\n}\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\n}\r\nvcc->dev_data = NULL;\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\n#ifdef RX_DEBUG\r\n{\r\nu32 stat, cfg;\r\nstat = readl(card->membase + STAT);\r\ncfg = readl(card->membase + CFG);\r\nprintk("STAT = 0x%08X CFG = 0x%08X \n", stat, cfg);\r\nprintk\r\n("TSQ: base = 0x%p next = 0x%p last = 0x%p TSQT = 0x%08X \n",\r\ncard->tsq.base, card->tsq.next,\r\ncard->tsq.last, readl(card->membase + TSQT));\r\nprintk\r\n("RSQ: base = 0x%p next = 0x%p last = 0x%p RSQT = 0x%08X \n",\r\ncard->rsq.base, card->rsq.next,\r\ncard->rsq.last, readl(card->membase + RSQT));\r\nprintk("Empty free buffer queue interrupt %s \n",\r\ncard->efbie ? "enabled" : "disabled");\r\nprintk("SBCNT = %d count = %d LBCNT = %d count = %d \n",\r\nns_stat_sfbqc_get(stat), card->sbpool.count,\r\nns_stat_lfbqc_get(stat), card->lbpool.count);\r\nprintk("hbpool.count = %d iovpool.count = %d \n",\r\ncard->hbpool.count, card->iovpool.count);\r\n}\r\n#endif\r\n}\r\nstatic void fill_tst(ns_dev * card, int n, vc_map * vc)\r\n{\r\nu32 new_tst;\r\nunsigned long cl;\r\nint e, r;\r\nu32 data;\r\nnew_tst = card->tst_addr;\r\nfor (e = 0; e < NS_TST_NUM_ENTRIES; e++) {\r\nif (card->tste2vc[e] == NULL)\r\nbreak;\r\n}\r\nif (e == NS_TST_NUM_ENTRIES) {\r\nprintk("nicstar%d: No free TST entries found. \n", card->index);\r\nreturn;\r\n}\r\nr = n;\r\ncl = NS_TST_NUM_ENTRIES;\r\ndata = ns_tste_make(NS_TST_OPCODE_FIXED, vc->cbr_scd);\r\nwhile (r > 0) {\r\nif (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL) {\r\ncard->tste2vc[e] = vc;\r\nns_write_sram(card, new_tst + e, &data, 1);\r\ncl -= NS_TST_NUM_ENTRIES;\r\nr--;\r\n}\r\nif (++e == NS_TST_NUM_ENTRIES) {\r\ne = 0;\r\n}\r\ncl += n;\r\n}\r\ndata = ns_tste_make(NS_TST_OPCODE_END, new_tst);\r\nns_write_sram(card, new_tst + NS_TST_NUM_ENTRIES, &data, 1);\r\nns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);\r\ncard->tst_addr = new_tst;\r\n}\r\nstatic int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nns_dev *card;\r\nvc_map *vc;\r\nscq_info *scq;\r\nunsigned long buflen;\r\nns_scqe scqe;\r\nu32 flags;\r\ncard = vcc->dev->dev_data;\r\nTXPRINTK("nicstar%d: ns_send() called.\n", card->index);\r\nif ((vc = (vc_map *) vcc->dev_data) == NULL) {\r\nprintk("nicstar%d: vcc->dev_data == NULL on ns_send().\n",\r\ncard->index);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!vc->tx) {\r\nprintk("nicstar%d: Trying to transmit on a non-tx VC.\n",\r\ncard->index);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nif (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {\r\nprintk("nicstar%d: Only AAL0 and AAL5 are supported.\n",\r\ncard->index);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nif (skb_shinfo(skb)->nr_frags != 0) {\r\nprintk("nicstar%d: No scatter-gather yet.\n", card->index);\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nATM_SKB(skb)->vcc = vcc;\r\nNS_PRV_DMA(skb) = pci_map_single(card->pcidev, skb->data,\r\nskb->len, PCI_DMA_TODEVICE);\r\nif (vcc->qos.aal == ATM_AAL5) {\r\nbuflen = (skb->len + 47 + 8) / 48 * 48;\r\nflags = NS_TBD_AAL5;\r\nscqe.word_2 = cpu_to_le32(NS_PRV_DMA(skb));\r\nscqe.word_3 = cpu_to_le32(skb->len);\r\nscqe.word_4 =\r\nns_tbd_mkword_4(0, (u32) vcc->vpi, (u32) vcc->vci, 0,\r\nATM_SKB(skb)->\r\natm_options & ATM_ATMOPT_CLP ? 1 : 0);\r\nflags |= NS_TBD_EOPDU;\r\n} else {\r\nbuflen = ATM_CELL_PAYLOAD;\r\nflags = NS_TBD_AAL0;\r\nscqe.word_2 = cpu_to_le32(NS_PRV_DMA(skb) + NS_AAL0_HEADER);\r\nscqe.word_3 = cpu_to_le32(0x00000000);\r\nif (*skb->data & 0x02)\r\nflags |= NS_TBD_EOPDU;\r\nscqe.word_4 =\r\ncpu_to_le32(*((u32 *) skb->data) & ~NS_TBD_VC_MASK);\r\nscqe.word_4 |=\r\ncpu_to_le32((((u32) vcc->\r\nvpi) << NS_TBD_VPI_SHIFT | ((u32) vcc->\r\nvci) <<\r\nNS_TBD_VCI_SHIFT) & NS_TBD_VC_MASK);\r\n}\r\nif (vcc->qos.txtp.traffic_class == ATM_CBR) {\r\nscqe.word_1 = ns_tbd_mkword_1_novbr(flags, (u32) buflen);\r\nscq = ((vc_map *) vcc->dev_data)->scq;\r\n} else {\r\nscqe.word_1 =\r\nns_tbd_mkword_1(flags, (u32) 1, (u32) 1, (u32) buflen);\r\nscq = card->scq0;\r\n}\r\nif (push_scqe(card, vc, scq, &scqe, skb) != 0) {\r\natomic_inc(&vcc->stats->tx_err);\r\ndev_kfree_skb_any(skb);\r\nreturn -EIO;\r\n}\r\natomic_inc(&vcc->stats->tx);\r\nreturn 0;\r\n}\r\nstatic int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,\r\nstruct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nns_scqe tsr;\r\nu32 scdi, scqi;\r\nint scq_is_vbr;\r\nu32 data;\r\nint index;\r\nspin_lock_irqsave(&scq->lock, flags);\r\nwhile (scq->tail == scq->next) {\r\nif (in_interrupt()) {\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nprintk("nicstar%d: Error pushing TBD.\n", card->index);\r\nreturn 1;\r\n}\r\nscq->full = 1;\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\ninterruptible_sleep_on_timeout(&scq->scqfull_waitq,\r\nSCQFULL_TIMEOUT);\r\nspin_lock_irqsave(&scq->lock, flags);\r\nif (scq->full) {\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nprintk("nicstar%d: Timeout pushing TBD.\n",\r\ncard->index);\r\nreturn 1;\r\n}\r\n}\r\n*scq->next = *tbd;\r\nindex = (int)(scq->next - scq->base);\r\nscq->skb[index] = skb;\r\nXPRINTK("nicstar%d: sending skb at 0x%p (pos %d).\n",\r\ncard->index, skb, index);\r\nXPRINTK("nicstar%d: TBD written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%p.\n",\r\ncard->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),\r\nle32_to_cpu(tbd->word_3), le32_to_cpu(tbd->word_4),\r\nscq->next);\r\nif (scq->next == scq->last)\r\nscq->next = scq->base;\r\nelse\r\nscq->next++;\r\nvc->tbd_count++;\r\nif (scq->num_entries == VBR_SCQ_NUM_ENTRIES) {\r\nscq->tbd_count++;\r\nscq_is_vbr = 1;\r\n} else\r\nscq_is_vbr = 0;\r\nif (vc->tbd_count >= MAX_TBD_PER_VC\r\n|| scq->tbd_count >= MAX_TBD_PER_SCQ) {\r\nint has_run = 0;\r\nwhile (scq->tail == scq->next) {\r\nif (in_interrupt()) {\r\ndata = scq_virt_to_bus(scq, scq->next);\r\nns_write_sram(card, scq->scd, &data, 1);\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nprintk("nicstar%d: Error pushing TSR.\n",\r\ncard->index);\r\nreturn 0;\r\n}\r\nscq->full = 1;\r\nif (has_run++)\r\nbreak;\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\ninterruptible_sleep_on_timeout(&scq->scqfull_waitq,\r\nSCQFULL_TIMEOUT);\r\nspin_lock_irqsave(&scq->lock, flags);\r\n}\r\nif (!scq->full) {\r\ntsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);\r\nif (scq_is_vbr)\r\nscdi = NS_TSR_SCDISVBR;\r\nelse\r\nscdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;\r\nscqi = scq->next - scq->base;\r\ntsr.word_2 = ns_tsr_mkword_2(scdi, scqi);\r\ntsr.word_3 = 0x00000000;\r\ntsr.word_4 = 0x00000000;\r\n*scq->next = tsr;\r\nindex = (int)scqi;\r\nscq->skb[index] = NULL;\r\nXPRINTK\r\n("nicstar%d: TSR written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%p.\n",\r\ncard->index, le32_to_cpu(tsr.word_1),\r\nle32_to_cpu(tsr.word_2), le32_to_cpu(tsr.word_3),\r\nle32_to_cpu(tsr.word_4), scq->next);\r\nif (scq->next == scq->last)\r\nscq->next = scq->base;\r\nelse\r\nscq->next++;\r\nvc->tbd_count = 0;\r\nscq->tbd_count = 0;\r\n} else\r\nPRINTK("nicstar%d: Timeout pushing TSR.\n",\r\ncard->index);\r\n}\r\ndata = scq_virt_to_bus(scq, scq->next);\r\nns_write_sram(card, scq->scd, &data, 1);\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void process_tsq(ns_dev * card)\r\n{\r\nu32 scdi;\r\nscq_info *scq;\r\nns_tsi *previous = NULL, *one_ahead, *two_ahead;\r\nint serviced_entries;\r\nserviced_entries = 0;\r\nif (card->tsq.next == card->tsq.last)\r\none_ahead = card->tsq.base;\r\nelse\r\none_ahead = card->tsq.next + 1;\r\nif (one_ahead == card->tsq.last)\r\ntwo_ahead = card->tsq.base;\r\nelse\r\ntwo_ahead = one_ahead + 1;\r\nwhile (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||\r\n!ns_tsi_isempty(two_ahead))\r\n{\r\nserviced_entries = 1;\r\nwhile (ns_tsi_isempty(card->tsq.next)) {\r\nif (card->tsq.next == card->tsq.last)\r\ncard->tsq.next = card->tsq.base;\r\nelse\r\ncard->tsq.next++;\r\n}\r\nif (!ns_tsi_tmrof(card->tsq.next)) {\r\nscdi = ns_tsi_getscdindex(card->tsq.next);\r\nif (scdi == NS_TSI_SCDISVBR)\r\nscq = card->scq0;\r\nelse {\r\nif (card->scd2vc[scdi] == NULL) {\r\nprintk\r\n("nicstar%d: could not find VC from SCD index.\n",\r\ncard->index);\r\nns_tsi_init(card->tsq.next);\r\nreturn;\r\n}\r\nscq = card->scd2vc[scdi]->scq;\r\n}\r\ndrain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));\r\nscq->full = 0;\r\nwake_up_interruptible(&(scq->scqfull_waitq));\r\n}\r\nns_tsi_init(card->tsq.next);\r\nprevious = card->tsq.next;\r\nif (card->tsq.next == card->tsq.last)\r\ncard->tsq.next = card->tsq.base;\r\nelse\r\ncard->tsq.next++;\r\nif (card->tsq.next == card->tsq.last)\r\none_ahead = card->tsq.base;\r\nelse\r\none_ahead = card->tsq.next + 1;\r\nif (one_ahead == card->tsq.last)\r\ntwo_ahead = card->tsq.base;\r\nelse\r\ntwo_ahead = one_ahead + 1;\r\n}\r\nif (serviced_entries)\r\nwritel(PTR_DIFF(previous, card->tsq.base),\r\ncard->membase + TSQH);\r\n}\r\nstatic void drain_scq(ns_dev * card, scq_info * scq, int pos)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *skb;\r\nint i;\r\nunsigned long flags;\r\nXPRINTK("nicstar%d: drain_scq() called, scq at 0x%p, pos %d.\n",\r\ncard->index, scq, pos);\r\nif (pos >= scq->num_entries) {\r\nprintk("nicstar%d: Bad index on drain_scq().\n", card->index);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&scq->lock, flags);\r\ni = (int)(scq->tail - scq->base);\r\nif (++i == scq->num_entries)\r\ni = 0;\r\nwhile (i != pos) {\r\nskb = scq->skb[i];\r\nXPRINTK("nicstar%d: freeing skb at 0x%p (index %d).\n",\r\ncard->index, skb, i);\r\nif (skb != NULL) {\r\npci_unmap_single(card->pcidev,\r\nNS_PRV_DMA(skb),\r\nskb->len,\r\nPCI_DMA_TODEVICE);\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (vcc && vcc->pop != NULL) {\r\nvcc->pop(vcc, skb);\r\n} else {\r\ndev_kfree_skb_irq(skb);\r\n}\r\nscq->skb[i] = NULL;\r\n}\r\nif (++i == scq->num_entries)\r\ni = 0;\r\n}\r\nscq->tail = scq->base + pos;\r\nspin_unlock_irqrestore(&scq->lock, flags);\r\n}\r\nstatic void process_rsq(ns_dev * card)\r\n{\r\nns_rsqe *previous;\r\nif (!ns_rsqe_valid(card->rsq.next))\r\nreturn;\r\ndo {\r\ndequeue_rx(card, card->rsq.next);\r\nns_rsqe_init(card->rsq.next);\r\nprevious = card->rsq.next;\r\nif (card->rsq.next == card->rsq.last)\r\ncard->rsq.next = card->rsq.base;\r\nelse\r\ncard->rsq.next++;\r\n} while (ns_rsqe_valid(card->rsq.next));\r\nwritel(PTR_DIFF(previous, card->rsq.base), card->membase + RSQH);\r\n}\r\nstatic void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)\r\n{\r\nu32 vpi, vci;\r\nvc_map *vc;\r\nstruct sk_buff *iovb;\r\nstruct iovec *iov;\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *skb;\r\nunsigned short aal5_len;\r\nint len;\r\nu32 stat;\r\nu32 id;\r\nstat = readl(card->membase + STAT);\r\ncard->sbfqc = ns_stat_sfbqc_get(stat);\r\ncard->lbfqc = ns_stat_lfbqc_get(stat);\r\nid = le32_to_cpu(rsqe->buffer_handle);\r\nskb = idr_find(&card->idr, id);\r\nif (!skb) {\r\nRXPRINTK(KERN_ERR\r\n"nicstar%d: idr_find() failed!\n", card->index);\r\nreturn;\r\n}\r\nidr_remove(&card->idr, id);\r\npci_dma_sync_single_for_cpu(card->pcidev,\r\nNS_PRV_DMA(skb),\r\n(NS_PRV_BUFTYPE(skb) == BUF_SM\r\n? NS_SMSKBSIZE : NS_LGSKBSIZE),\r\nPCI_DMA_FROMDEVICE);\r\npci_unmap_single(card->pcidev,\r\nNS_PRV_DMA(skb),\r\n(NS_PRV_BUFTYPE(skb) == BUF_SM\r\n? NS_SMSKBSIZE : NS_LGSKBSIZE),\r\nPCI_DMA_FROMDEVICE);\r\nvpi = ns_rsqe_vpi(rsqe);\r\nvci = ns_rsqe_vci(rsqe);\r\nif (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {\r\nprintk("nicstar%d: SDU received for out-of-range vc %d.%d.\n",\r\ncard->index, vpi, vci);\r\nrecycle_rx_buf(card, skb);\r\nreturn;\r\n}\r\nvc = &(card->vcmap[vpi << card->vcibits | vci]);\r\nif (!vc->rx) {\r\nRXPRINTK("nicstar%d: SDU received on non-rx vc %d.%d.\n",\r\ncard->index, vpi, vci);\r\nrecycle_rx_buf(card, skb);\r\nreturn;\r\n}\r\nvcc = vc->rx_vcc;\r\nif (vcc->qos.aal == ATM_AAL0) {\r\nstruct sk_buff *sb;\r\nunsigned char *cell;\r\nint i;\r\ncell = skb->data;\r\nfor (i = ns_rsqe_cellcount(rsqe); i; i--) {\r\nif ((sb = dev_alloc_skb(NS_SMSKBSIZE)) == NULL) {\r\nprintk\r\n("nicstar%d: Can't allocate buffers for aal0.\n",\r\ncard->index);\r\natomic_add(i, &vcc->stats->rx_drop);\r\nbreak;\r\n}\r\nif (!atm_charge(vcc, sb->truesize)) {\r\nRXPRINTK\r\n("nicstar%d: atm_charge() dropped aal0 packets.\n",\r\ncard->index);\r\natomic_add(i - 1, &vcc->stats->rx_drop);\r\ndev_kfree_skb_any(sb);\r\nbreak;\r\n}\r\n*((u32 *) sb->data) = le32_to_cpu(rsqe->word_1) << 4 |\r\n(ns_rsqe_clp(rsqe) ? 0x00000001 : 0x00000000);\r\nif (i == 1 && ns_rsqe_eopdu(rsqe))\r\n*((u32 *) sb->data) |= 0x00000002;\r\nskb_put(sb, NS_AAL0_HEADER);\r\nmemcpy(skb_tail_pointer(sb), cell, ATM_CELL_PAYLOAD);\r\nskb_put(sb, ATM_CELL_PAYLOAD);\r\nATM_SKB(sb)->vcc = vcc;\r\n__net_timestamp(sb);\r\nvcc->push(vcc, sb);\r\natomic_inc(&vcc->stats->rx);\r\ncell += ATM_CELL_PAYLOAD;\r\n}\r\nrecycle_rx_buf(card, skb);\r\nreturn;\r\n}\r\nif ((iovb = vc->rx_iov) == NULL) {\r\niovb = skb_dequeue(&(card->iovpool.queue));\r\nif (iovb == NULL) {\r\niovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC);\r\nif (iovb == NULL) {\r\nprintk("nicstar%d: Out of iovec buffers.\n",\r\ncard->index);\r\natomic_inc(&vcc->stats->rx_drop);\r\nrecycle_rx_buf(card, skb);\r\nreturn;\r\n}\r\nNS_PRV_BUFTYPE(iovb) = BUF_NONE;\r\n} else if (--card->iovpool.count < card->iovnr.min) {\r\nstruct sk_buff *new_iovb;\r\nif ((new_iovb =\r\nalloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL) {\r\nNS_PRV_BUFTYPE(iovb) = BUF_NONE;\r\nskb_queue_tail(&card->iovpool.queue, new_iovb);\r\ncard->iovpool.count++;\r\n}\r\n}\r\nvc->rx_iov = iovb;\r\nNS_PRV_IOVCNT(iovb) = 0;\r\niovb->len = 0;\r\niovb->data = iovb->head;\r\nskb_reset_tail_pointer(iovb);\r\n} else if (NS_PRV_IOVCNT(iovb) >= NS_MAX_IOVECS) {\r\nprintk("nicstar%d: received too big AAL5 SDU.\n", card->index);\r\natomic_inc(&vcc->stats->rx_err);\r\nrecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\r\nNS_MAX_IOVECS);\r\nNS_PRV_IOVCNT(iovb) = 0;\r\niovb->len = 0;\r\niovb->data = iovb->head;\r\nskb_reset_tail_pointer(iovb);\r\n}\r\niov = &((struct iovec *)iovb->data)[NS_PRV_IOVCNT(iovb)++];\r\niov->iov_base = (void *)skb;\r\niov->iov_len = ns_rsqe_cellcount(rsqe) * 48;\r\niovb->len += iov->iov_len;\r\n#ifdef EXTRA_DEBUG\r\nif (NS_PRV_IOVCNT(iovb) == 1) {\r\nif (NS_PRV_BUFTYPE(skb) != BUF_SM) {\r\nprintk\r\n("nicstar%d: Expected a small buffer, and this is not one.\n",\r\ncard->index);\r\nwhich_list(card, skb);\r\natomic_inc(&vcc->stats->rx_err);\r\nrecycle_rx_buf(card, skb);\r\nvc->rx_iov = NULL;\r\nrecycle_iov_buf(card, iovb);\r\nreturn;\r\n}\r\n} else {\r\nif (NS_PRV_BUFTYPE(skb) != BUF_LG) {\r\nprintk\r\n("nicstar%d: Expected a large buffer, and this is not one.\n",\r\ncard->index);\r\nwhich_list(card, skb);\r\natomic_inc(&vcc->stats->rx_err);\r\nrecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\r\nNS_PRV_IOVCNT(iovb));\r\nvc->rx_iov = NULL;\r\nrecycle_iov_buf(card, iovb);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nif (ns_rsqe_eopdu(rsqe)) {\r\nunsigned char *L1L2 = (unsigned char *)\r\n(skb->data + iov->iov_len - 6);\r\naal5_len = L1L2[0] << 8 | L1L2[1];\r\nlen = (aal5_len == 0x0000) ? 0x10000 : aal5_len;\r\nif (ns_rsqe_crcerr(rsqe) ||\r\nlen + 8 > iovb->len || len + (47 + 8) < iovb->len) {\r\nprintk("nicstar%d: AAL5 CRC error", card->index);\r\nif (len + 8 > iovb->len || len + (47 + 8) < iovb->len)\r\nprintk(" - PDU size mismatch.\n");\r\nelse\r\nprintk(".\n");\r\natomic_inc(&vcc->stats->rx_err);\r\nrecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\r\nNS_PRV_IOVCNT(iovb));\r\nvc->rx_iov = NULL;\r\nrecycle_iov_buf(card, iovb);\r\nreturn;\r\n}\r\nif (NS_PRV_IOVCNT(iovb) == 1) {\r\nif (!atm_charge(vcc, skb->truesize)) {\r\npush_rxbufs(card, skb);\r\natomic_inc(&vcc->stats->rx_drop);\r\n} else {\r\nskb_put(skb, len);\r\ndequeue_sm_buf(card, skb);\r\n#ifdef NS_USE_DESTRUCTORS\r\nskb->destructor = ns_sb_destructor;\r\n#endif\r\nATM_SKB(skb)->vcc = vcc;\r\n__net_timestamp(skb);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\n}\r\n} else if (NS_PRV_IOVCNT(iovb) == 2) {\r\nstruct sk_buff *sb;\r\nsb = (struct sk_buff *)(iov - 1)->iov_base;\r\nif (len <= NS_SMBUFSIZE) {\r\nif (!atm_charge(vcc, sb->truesize)) {\r\npush_rxbufs(card, sb);\r\natomic_inc(&vcc->stats->rx_drop);\r\n} else {\r\nskb_put(sb, len);\r\ndequeue_sm_buf(card, sb);\r\n#ifdef NS_USE_DESTRUCTORS\r\nsb->destructor = ns_sb_destructor;\r\n#endif\r\nATM_SKB(sb)->vcc = vcc;\r\n__net_timestamp(sb);\r\nvcc->push(vcc, sb);\r\natomic_inc(&vcc->stats->rx);\r\n}\r\npush_rxbufs(card, skb);\r\n} else {\r\nif (!atm_charge(vcc, skb->truesize)) {\r\npush_rxbufs(card, skb);\r\natomic_inc(&vcc->stats->rx_drop);\r\n} else {\r\ndequeue_lg_buf(card, skb);\r\n#ifdef NS_USE_DESTRUCTORS\r\nskb->destructor = ns_lb_destructor;\r\n#endif\r\nskb_push(skb, NS_SMBUFSIZE);\r\nskb_copy_from_linear_data(sb, skb->data,\r\nNS_SMBUFSIZE);\r\nskb_put(skb, len - NS_SMBUFSIZE);\r\nATM_SKB(skb)->vcc = vcc;\r\n__net_timestamp(skb);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\n}\r\npush_rxbufs(card, sb);\r\n}\r\n} else {\r\nstruct sk_buff *hb, *sb, *lb;\r\nint remaining, tocopy;\r\nint j;\r\nhb = skb_dequeue(&(card->hbpool.queue));\r\nif (hb == NULL) {\r\nhb = dev_alloc_skb(NS_HBUFSIZE);\r\nif (hb == NULL) {\r\nprintk\r\n("nicstar%d: Out of huge buffers.\n",\r\ncard->index);\r\natomic_inc(&vcc->stats->rx_drop);\r\nrecycle_iovec_rx_bufs(card,\r\n(struct iovec *)\r\niovb->data,\r\nNS_PRV_IOVCNT(iovb));\r\nvc->rx_iov = NULL;\r\nrecycle_iov_buf(card, iovb);\r\nreturn;\r\n} else if (card->hbpool.count < card->hbnr.min) {\r\nstruct sk_buff *new_hb;\r\nif ((new_hb =\r\ndev_alloc_skb(NS_HBUFSIZE)) !=\r\nNULL) {\r\nskb_queue_tail(&card->hbpool.\r\nqueue, new_hb);\r\ncard->hbpool.count++;\r\n}\r\n}\r\nNS_PRV_BUFTYPE(hb) = BUF_NONE;\r\n} else if (--card->hbpool.count < card->hbnr.min) {\r\nstruct sk_buff *new_hb;\r\nif ((new_hb =\r\ndev_alloc_skb(NS_HBUFSIZE)) != NULL) {\r\nNS_PRV_BUFTYPE(new_hb) = BUF_NONE;\r\nskb_queue_tail(&card->hbpool.queue,\r\nnew_hb);\r\ncard->hbpool.count++;\r\n}\r\nif (card->hbpool.count < card->hbnr.min) {\r\nif ((new_hb =\r\ndev_alloc_skb(NS_HBUFSIZE)) !=\r\nNULL) {\r\nNS_PRV_BUFTYPE(new_hb) =\r\nBUF_NONE;\r\nskb_queue_tail(&card->hbpool.\r\nqueue, new_hb);\r\ncard->hbpool.count++;\r\n}\r\n}\r\n}\r\niov = (struct iovec *)iovb->data;\r\nif (!atm_charge(vcc, hb->truesize)) {\r\nrecycle_iovec_rx_bufs(card, iov,\r\nNS_PRV_IOVCNT(iovb));\r\nif (card->hbpool.count < card->hbnr.max) {\r\nskb_queue_tail(&card->hbpool.queue, hb);\r\ncard->hbpool.count++;\r\n} else\r\ndev_kfree_skb_any(hb);\r\natomic_inc(&vcc->stats->rx_drop);\r\n} else {\r\nsb = (struct sk_buff *)iov->iov_base;\r\nskb_copy_from_linear_data(sb, hb->data,\r\niov->iov_len);\r\nskb_put(hb, iov->iov_len);\r\nremaining = len - iov->iov_len;\r\niov++;\r\npush_rxbufs(card, sb);\r\nfor (j = 1; j < NS_PRV_IOVCNT(iovb); j++) {\r\nlb = (struct sk_buff *)iov->iov_base;\r\ntocopy =\r\nmin_t(int, remaining, iov->iov_len);\r\nskb_copy_from_linear_data(lb,\r\nskb_tail_pointer\r\n(hb), tocopy);\r\nskb_put(hb, tocopy);\r\niov++;\r\nremaining -= tocopy;\r\npush_rxbufs(card, lb);\r\n}\r\n#ifdef EXTRA_DEBUG\r\nif (remaining != 0 || hb->len != len)\r\nprintk\r\n("nicstar%d: Huge buffer len mismatch.\n",\r\ncard->index);\r\n#endif\r\nATM_SKB(hb)->vcc = vcc;\r\n#ifdef NS_USE_DESTRUCTORS\r\nhb->destructor = ns_hb_destructor;\r\n#endif\r\n__net_timestamp(hb);\r\nvcc->push(vcc, hb);\r\natomic_inc(&vcc->stats->rx);\r\n}\r\n}\r\nvc->rx_iov = NULL;\r\nrecycle_iov_buf(card, iovb);\r\n}\r\n}\r\nstatic void ns_sb_destructor(struct sk_buff *sb)\r\n{\r\nns_dev *card;\r\nu32 stat;\r\ncard = (ns_dev *) ATM_SKB(sb)->vcc->dev->dev_data;\r\nstat = readl(card->membase + STAT);\r\ncard->sbfqc = ns_stat_sfbqc_get(stat);\r\ncard->lbfqc = ns_stat_lfbqc_get(stat);\r\ndo {\r\nsb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);\r\nif (sb == NULL)\r\nbreak;\r\nNS_PRV_BUFTYPE(sb) = BUF_SM;\r\nskb_queue_tail(&card->sbpool.queue, sb);\r\nskb_reserve(sb, NS_AAL0_HEADER);\r\npush_rxbufs(card, sb);\r\n} while (card->sbfqc < card->sbnr.min);\r\n}\r\nstatic void ns_lb_destructor(struct sk_buff *lb)\r\n{\r\nns_dev *card;\r\nu32 stat;\r\ncard = (ns_dev *) ATM_SKB(lb)->vcc->dev->dev_data;\r\nstat = readl(card->membase + STAT);\r\ncard->sbfqc = ns_stat_sfbqc_get(stat);\r\ncard->lbfqc = ns_stat_lfbqc_get(stat);\r\ndo {\r\nlb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);\r\nif (lb == NULL)\r\nbreak;\r\nNS_PRV_BUFTYPE(lb) = BUF_LG;\r\nskb_queue_tail(&card->lbpool.queue, lb);\r\nskb_reserve(lb, NS_SMBUFSIZE);\r\npush_rxbufs(card, lb);\r\n} while (card->lbfqc < card->lbnr.min);\r\n}\r\nstatic void ns_hb_destructor(struct sk_buff *hb)\r\n{\r\nns_dev *card;\r\ncard = (ns_dev *) ATM_SKB(hb)->vcc->dev->dev_data;\r\nwhile (card->hbpool.count < card->hbnr.init) {\r\nhb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);\r\nif (hb == NULL)\r\nbreak;\r\nNS_PRV_BUFTYPE(hb) = BUF_NONE;\r\nskb_queue_tail(&card->hbpool.queue, hb);\r\ncard->hbpool.count++;\r\n}\r\n}\r\nstatic void recycle_rx_buf(ns_dev * card, struct sk_buff *skb)\r\n{\r\nif (unlikely(NS_PRV_BUFTYPE(skb) == BUF_NONE)) {\r\nprintk("nicstar%d: What kind of rx buffer is this?\n",\r\ncard->index);\r\ndev_kfree_skb_any(skb);\r\n} else\r\npush_rxbufs(card, skb);\r\n}\r\nstatic void recycle_iovec_rx_bufs(ns_dev * card, struct iovec *iov, int count)\r\n{\r\nwhile (count-- > 0)\r\nrecycle_rx_buf(card, (struct sk_buff *)(iov++)->iov_base);\r\n}\r\nstatic void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb)\r\n{\r\nif (card->iovpool.count < card->iovnr.max) {\r\nskb_queue_tail(&card->iovpool.queue, iovb);\r\ncard->iovpool.count++;\r\n} else\r\ndev_kfree_skb_any(iovb);\r\n}\r\nstatic void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)\r\n{\r\nskb_unlink(sb, &card->sbpool.queue);\r\n#ifdef NS_USE_DESTRUCTORS\r\nif (card->sbfqc < card->sbnr.min)\r\n#else\r\nif (card->sbfqc < card->sbnr.init) {\r\nstruct sk_buff *new_sb;\r\nif ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {\r\nNS_PRV_BUFTYPE(new_sb) = BUF_SM;\r\nskb_queue_tail(&card->sbpool.queue, new_sb);\r\nskb_reserve(new_sb, NS_AAL0_HEADER);\r\npush_rxbufs(card, new_sb);\r\n}\r\n}\r\nif (card->sbfqc < card->sbnr.init)\r\n#endif\r\n{\r\nstruct sk_buff *new_sb;\r\nif ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {\r\nNS_PRV_BUFTYPE(new_sb) = BUF_SM;\r\nskb_queue_tail(&card->sbpool.queue, new_sb);\r\nskb_reserve(new_sb, NS_AAL0_HEADER);\r\npush_rxbufs(card, new_sb);\r\n}\r\n}\r\n}\r\nstatic void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)\r\n{\r\nskb_unlink(lb, &card->lbpool.queue);\r\n#ifdef NS_USE_DESTRUCTORS\r\nif (card->lbfqc < card->lbnr.min)\r\n#else\r\nif (card->lbfqc < card->lbnr.init) {\r\nstruct sk_buff *new_lb;\r\nif ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {\r\nNS_PRV_BUFTYPE(new_lb) = BUF_LG;\r\nskb_queue_tail(&card->lbpool.queue, new_lb);\r\nskb_reserve(new_lb, NS_SMBUFSIZE);\r\npush_rxbufs(card, new_lb);\r\n}\r\n}\r\nif (card->lbfqc < card->lbnr.init)\r\n#endif\r\n{\r\nstruct sk_buff *new_lb;\r\nif ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {\r\nNS_PRV_BUFTYPE(new_lb) = BUF_LG;\r\nskb_queue_tail(&card->lbpool.queue, new_lb);\r\nskb_reserve(new_lb, NS_SMBUFSIZE);\r\npush_rxbufs(card, new_lb);\r\n}\r\n}\r\n}\r\nstatic int ns_proc_read(struct atm_dev *dev, loff_t * pos, char *page)\r\n{\r\nu32 stat;\r\nns_dev *card;\r\nint left;\r\nleft = (int)*pos;\r\ncard = (ns_dev *) dev->dev_data;\r\nstat = readl(card->membase + STAT);\r\nif (!left--)\r\nreturn sprintf(page, "Pool count min init max \n");\r\nif (!left--)\r\nreturn sprintf(page, "Small %5d %5d %5d %5d \n",\r\nns_stat_sfbqc_get(stat), card->sbnr.min,\r\ncard->sbnr.init, card->sbnr.max);\r\nif (!left--)\r\nreturn sprintf(page, "Large %5d %5d %5d %5d \n",\r\nns_stat_lfbqc_get(stat), card->lbnr.min,\r\ncard->lbnr.init, card->lbnr.max);\r\nif (!left--)\r\nreturn sprintf(page, "Huge %5d %5d %5d %5d \n",\r\ncard->hbpool.count, card->hbnr.min,\r\ncard->hbnr.init, card->hbnr.max);\r\nif (!left--)\r\nreturn sprintf(page, "Iovec %5d %5d %5d %5d \n",\r\ncard->iovpool.count, card->iovnr.min,\r\ncard->iovnr.init, card->iovnr.max);\r\nif (!left--) {\r\nint retval;\r\nretval =\r\nsprintf(page, "Interrupt counter: %u \n", card->intcnt);\r\ncard->intcnt = 0;\r\nreturn retval;\r\n}\r\n#if 0\r\nif (card->max_pcr == ATM_25_PCR && !left--) {\r\nu32 phy_regs[4];\r\nu32 i;\r\nfor (i = 0; i < 4; i++) {\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(NS_CMD_READ_UTILITY | 0x00000200 | i,\r\ncard->membase + CMD);\r\nwhile (CMD_BUSY(card)) ;\r\nphy_regs[i] = readl(card->membase + DR0) & 0x000000FF;\r\n}\r\nreturn sprintf(page, "PHY regs: 0x%02X 0x%02X 0x%02X 0x%02X \n",\r\nphy_regs[0], phy_regs[1], phy_regs[2],\r\nphy_regs[3]);\r\n}\r\n#endif\r\n#if 0\r\nif (left-- < NS_TST_NUM_ENTRIES) {\r\nif (card->tste2vc[left + 1] == NULL)\r\nreturn sprintf(page, "%5d - VBR/UBR \n", left + 1);\r\nelse\r\nreturn sprintf(page, "%5d - %d %d \n", left + 1,\r\ncard->tste2vc[left + 1]->tx_vcc->vpi,\r\ncard->tste2vc[left + 1]->tx_vcc->vci);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)\r\n{\r\nns_dev *card;\r\npool_levels pl;\r\nlong btype;\r\nunsigned long flags;\r\ncard = dev->dev_data;\r\nswitch (cmd) {\r\ncase NS_GETPSTAT:\r\nif (get_user\r\n(pl.buftype, &((pool_levels __user *) arg)->buftype))\r\nreturn -EFAULT;\r\nswitch (pl.buftype) {\r\ncase NS_BUFTYPE_SMALL:\r\npl.count =\r\nns_stat_sfbqc_get(readl(card->membase + STAT));\r\npl.level.min = card->sbnr.min;\r\npl.level.init = card->sbnr.init;\r\npl.level.max = card->sbnr.max;\r\nbreak;\r\ncase NS_BUFTYPE_LARGE:\r\npl.count =\r\nns_stat_lfbqc_get(readl(card->membase + STAT));\r\npl.level.min = card->lbnr.min;\r\npl.level.init = card->lbnr.init;\r\npl.level.max = card->lbnr.max;\r\nbreak;\r\ncase NS_BUFTYPE_HUGE:\r\npl.count = card->hbpool.count;\r\npl.level.min = card->hbnr.min;\r\npl.level.init = card->hbnr.init;\r\npl.level.max = card->hbnr.max;\r\nbreak;\r\ncase NS_BUFTYPE_IOVEC:\r\npl.count = card->iovpool.count;\r\npl.level.min = card->iovnr.min;\r\npl.level.init = card->iovnr.init;\r\npl.level.max = card->iovnr.max;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nif (!copy_to_user((pool_levels __user *) arg, &pl, sizeof(pl)))\r\nreturn (sizeof(pl));\r\nelse\r\nreturn -EFAULT;\r\ncase NS_SETBUFLEV:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&pl, (pool_levels __user *) arg, sizeof(pl)))\r\nreturn -EFAULT;\r\nif (pl.level.min >= pl.level.init\r\n|| pl.level.init >= pl.level.max)\r\nreturn -EINVAL;\r\nif (pl.level.min == 0)\r\nreturn -EINVAL;\r\nswitch (pl.buftype) {\r\ncase NS_BUFTYPE_SMALL:\r\nif (pl.level.max > TOP_SB)\r\nreturn -EINVAL;\r\ncard->sbnr.min = pl.level.min;\r\ncard->sbnr.init = pl.level.init;\r\ncard->sbnr.max = pl.level.max;\r\nbreak;\r\ncase NS_BUFTYPE_LARGE:\r\nif (pl.level.max > TOP_LB)\r\nreturn -EINVAL;\r\ncard->lbnr.min = pl.level.min;\r\ncard->lbnr.init = pl.level.init;\r\ncard->lbnr.max = pl.level.max;\r\nbreak;\r\ncase NS_BUFTYPE_HUGE:\r\nif (pl.level.max > TOP_HB)\r\nreturn -EINVAL;\r\ncard->hbnr.min = pl.level.min;\r\ncard->hbnr.init = pl.level.init;\r\ncard->hbnr.max = pl.level.max;\r\nbreak;\r\ncase NS_BUFTYPE_IOVEC:\r\nif (pl.level.max > TOP_IOVB)\r\nreturn -EINVAL;\r\ncard->iovnr.min = pl.level.min;\r\ncard->iovnr.init = pl.level.init;\r\ncard->iovnr.max = pl.level.max;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase NS_ADJBUFLEV:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbtype = (long)arg;\r\nswitch (btype) {\r\ncase NS_BUFTYPE_SMALL:\r\nwhile (card->sbfqc < card->sbnr.init) {\r\nstruct sk_buff *sb;\r\nsb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);\r\nif (sb == NULL)\r\nreturn -ENOMEM;\r\nNS_PRV_BUFTYPE(sb) = BUF_SM;\r\nskb_queue_tail(&card->sbpool.queue, sb);\r\nskb_reserve(sb, NS_AAL0_HEADER);\r\npush_rxbufs(card, sb);\r\n}\r\nbreak;\r\ncase NS_BUFTYPE_LARGE:\r\nwhile (card->lbfqc < card->lbnr.init) {\r\nstruct sk_buff *lb;\r\nlb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);\r\nif (lb == NULL)\r\nreturn -ENOMEM;\r\nNS_PRV_BUFTYPE(lb) = BUF_LG;\r\nskb_queue_tail(&card->lbpool.queue, lb);\r\nskb_reserve(lb, NS_SMBUFSIZE);\r\npush_rxbufs(card, lb);\r\n}\r\nbreak;\r\ncase NS_BUFTYPE_HUGE:\r\nwhile (card->hbpool.count > card->hbnr.init) {\r\nstruct sk_buff *hb;\r\nspin_lock_irqsave(&card->int_lock, flags);\r\nhb = skb_dequeue(&card->hbpool.queue);\r\ncard->hbpool.count--;\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\nif (hb == NULL)\r\nprintk\r\n("nicstar%d: huge buffer count inconsistent.\n",\r\ncard->index);\r\nelse\r\ndev_kfree_skb_any(hb);\r\n}\r\nwhile (card->hbpool.count < card->hbnr.init) {\r\nstruct sk_buff *hb;\r\nhb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);\r\nif (hb == NULL)\r\nreturn -ENOMEM;\r\nNS_PRV_BUFTYPE(hb) = BUF_NONE;\r\nspin_lock_irqsave(&card->int_lock, flags);\r\nskb_queue_tail(&card->hbpool.queue, hb);\r\ncard->hbpool.count++;\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\n}\r\nbreak;\r\ncase NS_BUFTYPE_IOVEC:\r\nwhile (card->iovpool.count > card->iovnr.init) {\r\nstruct sk_buff *iovb;\r\nspin_lock_irqsave(&card->int_lock, flags);\r\niovb = skb_dequeue(&card->iovpool.queue);\r\ncard->iovpool.count--;\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\nif (iovb == NULL)\r\nprintk\r\n("nicstar%d: iovec buffer count inconsistent.\n",\r\ncard->index);\r\nelse\r\ndev_kfree_skb_any(iovb);\r\n}\r\nwhile (card->iovpool.count < card->iovnr.init) {\r\nstruct sk_buff *iovb;\r\niovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);\r\nif (iovb == NULL)\r\nreturn -ENOMEM;\r\nNS_PRV_BUFTYPE(iovb) = BUF_NONE;\r\nspin_lock_irqsave(&card->int_lock, flags);\r\nskb_queue_tail(&card->iovpool.queue, iovb);\r\ncard->iovpool.count++;\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nif (dev->phy && dev->phy->ioctl) {\r\nreturn dev->phy->ioctl(dev, cmd, arg);\r\n} else {\r\nprintk("nicstar%d: %s == NULL \n", card->index,\r\ndev->phy ? "dev->phy->ioctl" : "dev->phy");\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\n}\r\nstatic void which_list(ns_dev * card, struct sk_buff *skb)\r\n{\r\nprintk("skb buf_type: 0x%08x\n", NS_PRV_BUFTYPE(skb));\r\n}\r\nstatic void ns_poll(unsigned long arg)\r\n{\r\nint i;\r\nns_dev *card;\r\nunsigned long flags;\r\nu32 stat_r, stat_w;\r\nPRINTK("nicstar: Entering ns_poll().\n");\r\nfor (i = 0; i < num_cards; i++) {\r\ncard = cards[i];\r\nif (spin_is_locked(&card->int_lock)) {\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&card->int_lock, flags);\r\nstat_w = 0;\r\nstat_r = readl(card->membase + STAT);\r\nif (stat_r & NS_STAT_TSIF)\r\nstat_w |= NS_STAT_TSIF;\r\nif (stat_r & NS_STAT_EOPDU)\r\nstat_w |= NS_STAT_EOPDU;\r\nprocess_tsq(card);\r\nprocess_rsq(card);\r\nwritel(stat_w, card->membase + STAT);\r\nspin_unlock_irqrestore(&card->int_lock, flags);\r\n}\r\nmod_timer(&ns_timer, jiffies + NS_POLL_PERIOD);\r\nPRINTK("nicstar: Leaving ns_poll().\n");\r\n}\r\nstatic int ns_parse_mac(char *mac, unsigned char *esi)\r\n{\r\nint i, j;\r\nshort byte1, byte0;\r\nif (mac == NULL || esi == NULL)\r\nreturn -1;\r\nj = 0;\r\nfor (i = 0; i < 6; i++) {\r\nif ((byte1 = hex_to_bin(mac[j++])) < 0)\r\nreturn -1;\r\nif ((byte0 = hex_to_bin(mac[j++])) < 0)\r\nreturn -1;\r\nesi[i] = (unsigned char)(byte1 * 16 + byte0);\r\nif (i < 5) {\r\nif (mac[j++] != ':')\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ns_phy_put(struct atm_dev *dev, unsigned char value,\r\nunsigned long addr)\r\n{\r\nns_dev *card;\r\nunsigned long flags;\r\ncard = dev->dev_data;\r\nspin_lock_irqsave(&card->res_lock, flags);\r\nwhile (CMD_BUSY(card)) ;\r\nwritel((u32) value, card->membase + DR0);\r\nwritel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),\r\ncard->membase + CMD);\r\nspin_unlock_irqrestore(&card->res_lock, flags);\r\n}\r\nstatic unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr)\r\n{\r\nns_dev *card;\r\nunsigned long flags;\r\nu32 data;\r\ncard = dev->dev_data;\r\nspin_lock_irqsave(&card->res_lock, flags);\r\nwhile (CMD_BUSY(card)) ;\r\nwritel(NS_CMD_READ_UTILITY | 0x00000200 | (addr & 0x000000FF),\r\ncard->membase + CMD);\r\nwhile (CMD_BUSY(card)) ;\r\ndata = readl(card->membase + DR0) & 0x000000FF;\r\nspin_unlock_irqrestore(&card->res_lock, flags);\r\nreturn (unsigned char)data;\r\n}
