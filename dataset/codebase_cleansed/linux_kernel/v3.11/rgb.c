static inline struct tegra_rgb *to_rgb(struct tegra_output *output)\r\n{\r\nreturn container_of(output, struct tegra_rgb, output);\r\n}\r\nstatic void tegra_dc_write_regs(struct tegra_dc *dc,\r\nconst struct reg_entry *table,\r\nunsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++)\r\ntegra_dc_writel(dc, table[i].value, table[i].offset);\r\n}\r\nstatic int tegra_output_rgb_enable(struct tegra_output *output)\r\n{\r\nstruct tegra_dc *dc = to_tegra_dc(output->encoder.crtc);\r\ntegra_dc_write_regs(dc, rgb_enable, ARRAY_SIZE(rgb_enable));\r\nreturn 0;\r\n}\r\nstatic int tegra_output_rgb_disable(struct tegra_output *output)\r\n{\r\nstruct tegra_dc *dc = to_tegra_dc(output->encoder.crtc);\r\ntegra_dc_write_regs(dc, rgb_disable, ARRAY_SIZE(rgb_disable));\r\nreturn 0;\r\n}\r\nstatic int tegra_output_rgb_setup_clock(struct tegra_output *output,\r\nstruct clk *clk, unsigned long pclk)\r\n{\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nreturn clk_set_parent(clk, rgb->clk_parent);\r\n}\r\nstatic int tegra_output_rgb_check_mode(struct tegra_output *output,\r\nstruct drm_display_mode *mode,\r\nenum drm_mode_status *status)\r\n{\r\n*status = MODE_OK;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_probe(struct tegra_dc *dc)\r\n{\r\nstruct device_node *np;\r\nstruct tegra_rgb *rgb;\r\nint err;\r\nnp = of_get_child_by_name(dc->dev->of_node, "rgb");\r\nif (!np || !of_device_is_available(np))\r\nreturn -ENODEV;\r\nrgb = devm_kzalloc(dc->dev, sizeof(*rgb), GFP_KERNEL);\r\nif (!rgb)\r\nreturn -ENOMEM;\r\nrgb->clk = devm_clk_get(dc->dev, NULL);\r\nif (IS_ERR(rgb->clk)) {\r\ndev_err(dc->dev, "failed to get clock\n");\r\nreturn PTR_ERR(rgb->clk);\r\n}\r\nrgb->clk_parent = devm_clk_get(dc->dev, "parent");\r\nif (IS_ERR(rgb->clk_parent)) {\r\ndev_err(dc->dev, "failed to get parent clock\n");\r\nreturn PTR_ERR(rgb->clk_parent);\r\n}\r\nerr = clk_set_parent(rgb->clk, rgb->clk_parent);\r\nif (err < 0) {\r\ndev_err(dc->dev, "failed to set parent clock: %d\n", err);\r\nreturn err;\r\n}\r\nrgb->output.dev = dc->dev;\r\nrgb->output.of_node = np;\r\nerr = tegra_output_parse_dt(&rgb->output);\r\nif (err < 0)\r\nreturn err;\r\ndc->rgb = &rgb->output;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_init(struct drm_device *drm, struct tegra_dc *dc)\r\n{\r\nstruct tegra_rgb *rgb = to_rgb(dc->rgb);\r\nint err;\r\nif (!dc->rgb)\r\nreturn -ENODEV;\r\nrgb->output.type = TEGRA_OUTPUT_RGB;\r\nrgb->output.ops = &rgb_ops;\r\nerr = tegra_output_init(dc->base.dev, &rgb->output);\r\nif (err < 0) {\r\ndev_err(dc->dev, "output setup failed: %d\n", err);\r\nreturn err;\r\n}\r\nrgb->output.encoder.possible_crtcs = 1 << dc->pipe;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_exit(struct tegra_dc *dc)\r\n{\r\nif (dc->rgb) {\r\nint err;\r\nerr = tegra_output_disable(dc->rgb);\r\nif (err < 0) {\r\ndev_err(dc->dev, "output failed to disable: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_output_exit(dc->rgb);\r\nif (err < 0) {\r\ndev_err(dc->dev, "output cleanup failed: %d\n", err);\r\nreturn err;\r\n}\r\ndc->rgb = NULL;\r\n}\r\nreturn 0;\r\n}
