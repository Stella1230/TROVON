static void wait_for_xmit_empty(struct uart_port *port)\r\n{\r\nunsigned int timeout = 10000;\r\ndo {\r\nif (LPC32XX_HSU_TX_LEV(readl(LPC32XX_HSUART_LEVEL(\r\nport->membase))) == 0)\r\nbreak;\r\nif (--timeout == 0)\r\nbreak;\r\nudelay(1);\r\n} while (1);\r\n}\r\nstatic void wait_for_xmit_ready(struct uart_port *port)\r\n{\r\nunsigned int timeout = 10000;\r\nwhile (1) {\r\nif (LPC32XX_HSU_TX_LEV(readl(LPC32XX_HSUART_LEVEL(\r\nport->membase))) < 32)\r\nbreak;\r\nif (--timeout == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void lpc32xx_hsuart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwait_for_xmit_ready(port);\r\nwritel((u32)ch, LPC32XX_HSUART_FIFO(port->membase));\r\n}\r\nstatic void lpc32xx_hsuart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct lpc32xx_hsuart_port *up = &lpc32xx_hs_ports[co->index];\r\nunsigned long flags;\r\nint locked = 1;\r\ntouch_nmi_watchdog();\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&up->port.lock);\r\nelse\r\nspin_lock(&up->port.lock);\r\nuart_console_write(&up->port, s, count, lpc32xx_hsuart_console_putchar);\r\nwait_for_xmit_empty(&up->port);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init lpc32xx_hsuart_console_setup(struct console *co,\r\nchar *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= MAX_PORTS)\r\nco->index = 0;\r\nport = &lpc32xx_hs_ports[co->index].port;\r\nif (!port->membase)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init lpc32xx_hsuart_console_init(void)\r\n{\r\nregister_console(&lpc32xx_hsuart_console);\r\nreturn 0;\r\n}\r\nstatic unsigned int __serial_get_clock_div(unsigned long uartclk,\r\nunsigned long rate)\r\n{\r\nu32 div, goodrate, hsu_rate, l_hsu_rate, comprate;\r\nu32 rate_diff;\r\ndiv = uartclk / rate;\r\ngoodrate = hsu_rate = (div / 14) - 1;\r\nif (hsu_rate != 0)\r\nhsu_rate--;\r\nl_hsu_rate = hsu_rate + 3;\r\nrate_diff = 0xFFFFFFFF;\r\nwhile (hsu_rate < l_hsu_rate) {\r\ncomprate = uartclk / ((hsu_rate + 1) * 14);\r\nif (abs(comprate - rate) < rate_diff) {\r\ngoodrate = hsu_rate;\r\nrate_diff = abs(comprate - rate);\r\n}\r\nhsu_rate++;\r\n}\r\nif (hsu_rate > 0xFF)\r\nhsu_rate = 0xFF;\r\nreturn goodrate;\r\n}\r\nstatic void __serial_uart_flush(struct uart_port *port)\r\n{\r\nu32 tmp;\r\nint cnt = 0;\r\nwhile ((readl(LPC32XX_HSUART_LEVEL(port->membase)) > 0) &&\r\n(cnt++ < FIFO_READ_LIMIT))\r\ntmp = readl(LPC32XX_HSUART_FIFO(port->membase));\r\n}\r\nstatic void __serial_lpc32xx_rx(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned int tmp, flag;\r\ntmp = readl(LPC32XX_HSUART_FIFO(port->membase));\r\nwhile (!(tmp & LPC32XX_HSU_RX_EMPTY)) {\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (tmp & LPC32XX_HSU_ERROR_DATA) {\r\nwritel(LPC32XX_HSU_FE_INT,\r\nLPC32XX_HSUART_IIR(port->membase));\r\nport->icount.frame++;\r\nflag = TTY_FRAME;\r\ntty_insert_flip_char(tport, 0, TTY_FRAME);\r\n}\r\ntty_insert_flip_char(tport, (tmp & 0xFF), flag);\r\ntmp = readl(LPC32XX_HSUART_FIFO(port->membase));\r\n}\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic void __serial_lpc32xx_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int tmp;\r\nif (port->x_char) {\r\nwritel((u32)port->x_char, LPC32XX_HSUART_FIFO(port->membase));\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\ngoto exit_tx;\r\nwhile (LPC32XX_HSU_TX_LEV(readl(\r\nLPC32XX_HSUART_LEVEL(port->membase))) < 64) {\r\nwritel((u32) xmit->buf[xmit->tail],\r\nLPC32XX_HSUART_FIFO(port->membase));\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nexit_tx:\r\nif (uart_circ_empty(xmit)) {\r\ntmp = readl(LPC32XX_HSUART_CTRL(port->membase));\r\ntmp &= ~LPC32XX_HSU_TX_INT_EN;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\n}\r\n}\r\nstatic irqreturn_t serial_lpc32xx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct tty_port *tport = &port->state->port;\r\nu32 status;\r\nspin_lock(&port->lock);\r\nstatus = readl(LPC32XX_HSUART_IIR(port->membase));\r\nif (status & LPC32XX_HSU_BRK_INT) {\r\nwritel(LPC32XX_HSU_BRK_INT, LPC32XX_HSUART_IIR(port->membase));\r\nport->icount.brk++;\r\nuart_handle_break(port);\r\n}\r\nif (status & LPC32XX_HSU_FE_INT)\r\nwritel(LPC32XX_HSU_FE_INT, LPC32XX_HSUART_IIR(port->membase));\r\nif (status & LPC32XX_HSU_RX_OE_INT) {\r\nwritel(LPC32XX_HSU_RX_OE_INT,\r\nLPC32XX_HSUART_IIR(port->membase));\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\ntty_schedule_flip(tport);\r\n}\r\nif (status & (LPC32XX_HSU_RX_TIMEOUT_INT | LPC32XX_HSU_RX_TRIG_INT)) {\r\n__serial_lpc32xx_rx(port);\r\ntty_flip_buffer_push(tport);\r\n}\r\nif ((status & LPC32XX_HSU_TX_INT) && (!uart_tx_stopped(port))) {\r\nwritel(LPC32XX_HSU_TX_INT, LPC32XX_HSUART_IIR(port->membase));\r\n__serial_lpc32xx_tx(port);\r\n}\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int serial_lpc32xx_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int ret = 0;\r\nif (LPC32XX_HSU_TX_LEV(readl(LPC32XX_HSUART_LEVEL(port->membase))) == 0)\r\nret = TIOCSER_TEMT;\r\nreturn ret;\r\n}\r\nstatic void serial_lpc32xx_set_mctrl(struct uart_port *port,\r\nunsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int serial_lpc32xx_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void serial_lpc32xx_stop_tx(struct uart_port *port)\r\n{\r\nu32 tmp;\r\ntmp = readl(LPC32XX_HSUART_CTRL(port->membase));\r\ntmp &= ~LPC32XX_HSU_TX_INT_EN;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\n}\r\nstatic void serial_lpc32xx_start_tx(struct uart_port *port)\r\n{\r\nu32 tmp;\r\n__serial_lpc32xx_tx(port);\r\ntmp = readl(LPC32XX_HSUART_CTRL(port->membase));\r\ntmp |= LPC32XX_HSU_TX_INT_EN;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\n}\r\nstatic void serial_lpc32xx_stop_rx(struct uart_port *port)\r\n{\r\nu32 tmp;\r\ntmp = readl(LPC32XX_HSUART_CTRL(port->membase));\r\ntmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\nwritel((LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT |\r\nLPC32XX_HSU_FE_INT), LPC32XX_HSUART_IIR(port->membase));\r\n}\r\nstatic void serial_lpc32xx_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void serial_lpc32xx_break_ctl(struct uart_port *port,\r\nint break_state)\r\n{\r\nunsigned long flags;\r\nu32 tmp;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntmp = readl(LPC32XX_HSUART_CTRL(port->membase));\r\nif (break_state != 0)\r\ntmp |= LPC32XX_HSU_BREAK;\r\nelse\r\ntmp &= ~LPC32XX_HSU_BREAK;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void lpc32xx_loopback_set(resource_size_t mapbase, int state)\r\n{\r\nint bit;\r\nu32 tmp;\r\nswitch (mapbase) {\r\ncase LPC32XX_HS_UART1_BASE:\r\nbit = 0;\r\nbreak;\r\ncase LPC32XX_HS_UART2_BASE:\r\nbit = 1;\r\nbreak;\r\ncase LPC32XX_HS_UART7_BASE:\r\nbit = 6;\r\nbreak;\r\ndefault:\r\nWARN(1, "lpc32xx_hs: Warning: Unknown port at %08x\n", mapbase);\r\nreturn;\r\n}\r\ntmp = readl(LPC32XX_UARTCTL_CLOOP);\r\nif (state)\r\ntmp |= (1 << bit);\r\nelse\r\ntmp &= ~(1 << bit);\r\nwritel(tmp, LPC32XX_UARTCTL_CLOOP);\r\n}\r\nstatic int serial_lpc32xx_startup(struct uart_port *port)\r\n{\r\nint retval;\r\nunsigned long flags;\r\nu32 tmp;\r\nspin_lock_irqsave(&port->lock, flags);\r\n__serial_uart_flush(port);\r\nwritel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |\r\nLPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),\r\nLPC32XX_HSUART_IIR(port->membase));\r\nwritel(0xFF, LPC32XX_HSUART_RATE(port->membase));\r\ntmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |\r\nLPC32XX_HSU_OFFSET(20) | LPC32XX_HSU_TMO_INACT_4B;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\nlpc32xx_loopback_set(port->mapbase, 0);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nretval = request_irq(port->irq, serial_lpc32xx_interrupt,\r\n0, MODNAME, port);\r\nif (!retval)\r\nwritel((tmp | LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN),\r\nLPC32XX_HSUART_CTRL(port->membase));\r\nreturn retval;\r\n}\r\nstatic void serial_lpc32xx_shutdown(struct uart_port *port)\r\n{\r\nu32 tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |\r\nLPC32XX_HSU_OFFSET(20) | LPC32XX_HSU_TMO_INACT_4B;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\nlpc32xx_loopback_set(port->mapbase, 1);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void serial_lpc32xx_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nu32 tmp;\r\ntermios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);\r\ntermios->c_cflag |= CS8;\r\ntermios->c_cflag &= ~(HUPCL | CMSPAR | CLOCAL | CRTSCTS);\r\nbaud = uart_get_baud_rate(port, termios, old, 0,\r\nport->uartclk / 14);\r\nquot = __serial_get_clock_div(port->uartclk, baud);\r\nspin_lock_irqsave(&port->lock, flags);\r\ntmp = readl(LPC32XX_HSUART_CTRL(port->membase));\r\nif ((termios->c_cflag & CREAD) == 0)\r\ntmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);\r\nelse\r\ntmp |= LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN;\r\nwritel(tmp, LPC32XX_HSUART_CTRL(port->membase));\r\nwritel(quot, LPC32XX_HSUART_RATE(port->membase));\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nstatic const char *serial_lpc32xx_type(struct uart_port *port)\r\n{\r\nreturn MODNAME;\r\n}\r\nstatic void serial_lpc32xx_release_port(struct uart_port *port)\r\n{\r\nif ((port->iotype == UPIO_MEM32) && (port->mapbase)) {\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nrelease_mem_region(port->mapbase, SZ_4K);\r\n}\r\n}\r\nstatic int serial_lpc32xx_request_port(struct uart_port *port)\r\n{\r\nint ret = -ENODEV;\r\nif ((port->iotype == UPIO_MEM32) && (port->mapbase)) {\r\nret = 0;\r\nif (!request_mem_region(port->mapbase, SZ_4K, MODNAME))\r\nret = -EBUSY;\r\nelse if (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap(port->mapbase, SZ_4K);\r\nif (!port->membase) {\r\nrelease_mem_region(port->mapbase, SZ_4K);\r\nret = -ENOMEM;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial_lpc32xx_config_port(struct uart_port *port, int uflags)\r\n{\r\nint ret;\r\nret = serial_lpc32xx_request_port(port);\r\nif (ret < 0)\r\nreturn;\r\nport->type = PORT_UART00;\r\nport->fifosize = 64;\r\n__serial_uart_flush(port);\r\nwritel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |\r\nLPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),\r\nLPC32XX_HSUART_IIR(port->membase));\r\nwritel(0xFF, LPC32XX_HSUART_RATE(port->membase));\r\nwritel(LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |\r\nLPC32XX_HSU_OFFSET(20) | LPC32XX_HSU_TMO_INACT_4B,\r\nLPC32XX_HSUART_CTRL(port->membase));\r\n}\r\nstatic int serial_lpc32xx_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UART00)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int serial_hs_lpc32xx_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_hsuart_port *p = &lpc32xx_hs_ports[uarts_registered];\r\nint ret = 0;\r\nstruct resource *res;\r\nif (uarts_registered >= MAX_PORTS) {\r\ndev_err(&pdev->dev,\r\n"Error: Number of possible ports exceeded (%d)!\n",\r\nuarts_registered + 1);\r\nreturn -ENXIO;\r\n}\r\nmemset(p, 0, sizeof(*p));\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Error getting mem resource for HS UART port %d\n",\r\nuarts_registered);\r\nreturn -ENXIO;\r\n}\r\np->port.mapbase = res->start;\r\np->port.membase = NULL;\r\np->port.irq = platform_get_irq(pdev, 0);\r\nif (p->port.irq < 0) {\r\ndev_err(&pdev->dev, "Error getting irq for HS UART port %d\n",\r\nuarts_registered);\r\nreturn p->port.irq;\r\n}\r\np->port.iotype = UPIO_MEM32;\r\np->port.uartclk = LPC32XX_MAIN_OSC_FREQ;\r\np->port.regshift = 2;\r\np->port.flags = UPF_BOOT_AUTOCONF | UPF_FIXED_PORT | UPF_IOREMAP;\r\np->port.dev = &pdev->dev;\r\np->port.ops = &serial_lpc32xx_pops;\r\np->port.line = uarts_registered++;\r\nspin_lock_init(&p->port.lock);\r\nlpc32xx_loopback_set(p->port.mapbase, 1);\r\nret = uart_add_one_port(&lpc32xx_hs_reg, &p->port);\r\nplatform_set_drvdata(pdev, p);\r\nreturn ret;\r\n}\r\nstatic int serial_hs_lpc32xx_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_hsuart_port *p = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&lpc32xx_hs_reg, &p->port);\r\nreturn 0;\r\n}\r\nstatic int serial_hs_lpc32xx_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct lpc32xx_hsuart_port *p = platform_get_drvdata(pdev);\r\nuart_suspend_port(&lpc32xx_hs_reg, &p->port);\r\nreturn 0;\r\n}\r\nstatic int serial_hs_lpc32xx_resume(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_hsuart_port *p = platform_get_drvdata(pdev);\r\nuart_resume_port(&lpc32xx_hs_reg, &p->port);\r\nreturn 0;\r\n}\r\nstatic int __init lpc32xx_hsuart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&lpc32xx_hs_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&serial_hs_lpc32xx_driver);\r\nif (ret)\r\nuart_unregister_driver(&lpc32xx_hs_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit lpc32xx_hsuart_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_hs_lpc32xx_driver);\r\nuart_unregister_driver(&lpc32xx_hs_reg);\r\n}
