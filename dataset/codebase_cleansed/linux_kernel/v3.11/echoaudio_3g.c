static int check_asic_status(struct echoaudio *chip)\r\n{\r\nu32 box_status;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->ext_box_status = cpu_to_le32(E3G_ASIC_NOT_LOADED);\r\nchip->asic_loaded = FALSE;\r\nclear_handshake(chip);\r\nsend_vector(chip, DSP_VC_TEST_ASIC);\r\nif (wait_handshake(chip)) {\r\nchip->dsp_code = NULL;\r\nreturn -EIO;\r\n}\r\nbox_status = le32_to_cpu(chip->comm_page->ext_box_status);\r\nDE_INIT(("box_status=%x\n", box_status));\r\nif (box_status == E3G_ASIC_NOT_LOADED)\r\nreturn -ENODEV;\r\nchip->asic_loaded = TRUE;\r\nreturn box_status & E3G_BOX_TYPE_MASK;\r\n}\r\nstatic inline u32 get_frq_reg(struct echoaudio *chip)\r\n{\r\nreturn le32_to_cpu(chip->comm_page->e3g_frq_register);\r\n}\r\nstatic int write_control_reg(struct echoaudio *chip, u32 ctl, u32 frq,\r\nchar force)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nDE_ACT(("WriteControlReg: Setting 0x%x, 0x%x\n", ctl, frq));\r\nctl = cpu_to_le32(ctl);\r\nfrq = cpu_to_le32(frq);\r\nif (ctl != chip->comm_page->control_register ||\r\nfrq != chip->comm_page->e3g_frq_register || force) {\r\nchip->comm_page->e3g_frq_register = frq;\r\nchip->comm_page->control_register = ctl;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_WRITE_CONTROL_REG);\r\n}\r\nDE_ACT(("WriteControlReg: not written, no change\n"));\r\nreturn 0;\r\n}\r\nstatic int set_digital_mode(struct echoaudio *chip, u8 mode)\r\n{\r\nu8 previous_mode;\r\nint err, i, o;\r\nif (snd_BUG_ON(chip->pipe_alloc_mask))\r\nreturn -EAGAIN;\r\nif (snd_BUG_ON(!(chip->digital_modes & (1 << mode))))\r\nreturn -EINVAL;\r\nprevious_mode = chip->digital_mode;\r\nerr = dsp_set_digital_mode(chip, mode);\r\nif (err >= 0 && previous_mode != mode &&\r\n(previous_mode == DIGITAL_MODE_ADAT || mode == DIGITAL_MODE_ADAT)) {\r\nspin_lock_irq(&chip->lock);\r\nfor (o = 0; o < num_busses_out(chip); o++)\r\nfor (i = 0; i < num_busses_in(chip); i++)\r\nset_monitor_gain(chip, o, i,\r\nchip->monitor_gain[o][i]);\r\n#ifdef ECHOCARD_HAS_INPUT_GAIN\r\nfor (i = 0; i < num_busses_in(chip); i++)\r\nset_input_gain(chip, i, chip->input_gain[i]);\r\nupdate_input_line_level(chip);\r\n#endif\r\nfor (o = 0; o < num_busses_out(chip); o++)\r\nset_output_gain(chip, o, chip->output_gain[o]);\r\nupdate_output_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\n}\r\nreturn err;\r\n}\r\nstatic u32 set_spdif_bits(struct echoaudio *chip, u32 control_reg, u32 rate)\r\n{\r\ncontrol_reg &= E3G_SPDIF_FORMAT_CLEAR_MASK;\r\nswitch (rate) {\r\ncase 32000 :\r\ncontrol_reg |= E3G_SPDIF_SAMPLE_RATE0 | E3G_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 44100 :\r\nif (chip->professional_spdif)\r\ncontrol_reg |= E3G_SPDIF_SAMPLE_RATE0;\r\nbreak;\r\ncase 48000 :\r\ncontrol_reg |= E3G_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\n}\r\nif (chip->professional_spdif)\r\ncontrol_reg |= E3G_SPDIF_PRO_MODE;\r\nif (chip->non_audio_spdif)\r\ncontrol_reg |= E3G_SPDIF_NOT_AUDIO;\r\ncontrol_reg |= E3G_SPDIF_24_BIT | E3G_SPDIF_TWO_CHANNEL |\r\nE3G_SPDIF_COPY_PERMIT;\r\nreturn control_reg;\r\n}\r\nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\r\n{\r\nu32 control_reg;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\nchip->professional_spdif = prof;\r\ncontrol_reg = set_spdif_bits(chip, control_reg, chip->sample_rate);\r\nreturn write_control_reg(chip, control_reg, get_frq_reg(chip), 0);\r\n}\r\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\r\n{\r\nu32 clocks_from_dsp, clock_bits;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nclock_bits = ECHO_CLOCK_BIT_INTERNAL;\r\nif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_WORD)\r\nclock_bits |= ECHO_CLOCK_BIT_WORD;\r\nswitch(chip->digital_mode) {\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\nif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_SPDIF)\r\nclock_bits |= ECHO_CLOCK_BIT_SPDIF;\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\nif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_ADAT)\r\nclock_bits |= ECHO_CLOCK_BIT_ADAT;\r\nbreak;\r\n}\r\nreturn clock_bits;\r\n}\r\nstatic int load_asic(struct echoaudio *chip)\r\n{\r\nint box_type, err;\r\nif (chip->asic_loaded)\r\nreturn 0;\r\nmdelay(2);\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_3G_ASIC, FW_3G_ASIC);\r\nif (err < 0)\r\nreturn err;\r\nchip->asic_code = FW_3G_ASIC;\r\nmsleep(1000);\r\nbox_type = check_asic_status(chip);\r\nif (box_type >= 0) {\r\nerr = write_control_reg(chip, E3G_48KHZ,\r\nE3G_FREQ_REG_DEFAULT, TRUE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn box_type;\r\n}\r\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\r\n{\r\nu32 control_reg, clock, base_rate, frq_reg;\r\nif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\r\nDE_ACT(("set_sample_rate: Cannot set sample rate - "\r\n"clock not set to CLK_CLOCKININTERNAL\n"));\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\nset_input_clock(chip, chip->input_clock);\r\nreturn 0;\r\n}\r\nif (snd_BUG_ON(rate >= 50000 &&\r\nchip->digital_mode == DIGITAL_MODE_ADAT))\r\nreturn -EINVAL;\r\nclock = 0;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= E3G_CLOCK_CLEAR_MASK;\r\nswitch (rate) {\r\ncase 96000:\r\nclock = E3G_96KHZ;\r\nbreak;\r\ncase 88200:\r\nclock = E3G_88KHZ;\r\nbreak;\r\ncase 48000:\r\nclock = E3G_48KHZ;\r\nbreak;\r\ncase 44100:\r\nclock = E3G_44KHZ;\r\nbreak;\r\ncase 32000:\r\nclock = E3G_32KHZ;\r\nbreak;\r\ndefault:\r\nclock = E3G_CONTINUOUS_CLOCK;\r\nif (rate > 50000)\r\nclock |= E3G_DOUBLE_SPEED_MODE;\r\nbreak;\r\n}\r\ncontrol_reg |= clock;\r\ncontrol_reg = set_spdif_bits(chip, control_reg, rate);\r\nbase_rate = rate;\r\nif (base_rate > 50000)\r\nbase_rate /= 2;\r\nif (base_rate < 32000)\r\nbase_rate = 32000;\r\nfrq_reg = E3G_MAGIC_NUMBER / base_rate - 2;\r\nif (frq_reg > E3G_FREQ_REG_MAX)\r\nfrq_reg = E3G_FREQ_REG_MAX;\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\nDE_ACT(("SetSampleRate: %d clock %x\n", rate, control_reg));\r\nreturn write_control_reg(chip, control_reg, frq_reg, 0);\r\n}\r\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\r\n{\r\nu32 control_reg, clocks_from_dsp;\r\nDE_ACT(("set_input_clock:\n"));\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register) &\r\nE3G_CLOCK_CLEAR_MASK;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nswitch (clock) {\r\ncase ECHO_CLOCK_INTERNAL:\r\nDE_ACT(("Set Echo3G clock to INTERNAL\n"));\r\nchip->input_clock = ECHO_CLOCK_INTERNAL;\r\nreturn set_sample_rate(chip, chip->sample_rate);\r\ncase ECHO_CLOCK_SPDIF:\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\nDE_ACT(("Set Echo3G clock to SPDIF\n"));\r\ncontrol_reg |= E3G_SPDIF_CLOCK;\r\nif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_SPDIF96)\r\ncontrol_reg |= E3G_DOUBLE_SPEED_MODE;\r\nelse\r\ncontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_ADAT:\r\nif (chip->digital_mode != DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\nDE_ACT(("Set Echo3G clock to ADAT\n"));\r\ncontrol_reg |= E3G_ADAT_CLOCK;\r\ncontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_WORD:\r\nDE_ACT(("Set Echo3G clock to WORD\n"));\r\ncontrol_reg |= E3G_WORD_CLOCK;\r\nif (clocks_from_dsp & E3G_CLOCK_DETECT_BIT_WORD96)\r\ncontrol_reg |= E3G_DOUBLE_SPEED_MODE;\r\nelse\r\ncontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\r\nbreak;\r\ndefault:\r\nDE_ACT(("Input clock 0x%x not supported for Echo3G\n", clock));\r\nreturn -EINVAL;\r\n}\r\nchip->input_clock = clock;\r\nreturn write_control_reg(chip, control_reg, get_frq_reg(chip), 1);\r\n}\r\nstatic int dsp_set_digital_mode(struct echoaudio *chip, u8 mode)\r\n{\r\nu32 control_reg;\r\nint err, incompatible_clock;\r\nincompatible_clock = FALSE;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nif (chip->input_clock == ECHO_CLOCK_ADAT)\r\nincompatible_clock = TRUE;\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\nif (chip->input_clock == ECHO_CLOCK_SPDIF)\r\nincompatible_clock = TRUE;\r\nbreak;\r\ndefault:\r\nDE_ACT(("Digital mode not supported: %d\n", mode));\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&chip->lock);\r\nif (incompatible_clock) {\r\nchip->sample_rate = 48000;\r\nset_input_clock(chip, ECHO_CLOCK_INTERNAL);\r\n}\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= E3G_DIGITAL_MODE_CLEAR_MASK;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncontrol_reg |= E3G_SPDIF_OPTICAL_MODE;\r\nbreak;\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\ncontrol_reg |= E3G_ADAT_MODE;\r\ncontrol_reg &= ~E3G_DOUBLE_SPEED_MODE;\r\nbreak;\r\n}\r\nerr = write_control_reg(chip, control_reg, get_frq_reg(chip), 1);\r\nspin_unlock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\nchip->digital_mode = mode;\r\nDE_ACT(("set_digital_mode(%d)\n", chip->digital_mode));\r\nreturn incompatible_clock;\r\n}
