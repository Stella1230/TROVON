static unsigned int sh_cpufreq_get(unsigned int cpu)\r\n{\r\nreturn (clk_get_rate(&per_cpu(sh_cpuclk, cpu)) + 500) / 1000;\r\n}\r\nstatic int sh_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nstruct clk *cpuclk = &per_cpu(sh_cpuclk, cpu);\r\ncpumask_t cpus_allowed;\r\nstruct cpufreq_freqs freqs;\r\nstruct device *dev;\r\nlong freq;\r\ncpus_allowed = current->cpus_allowed;\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nBUG_ON(smp_processor_id() != cpu);\r\ndev = get_cpu_device(cpu);\r\nfreq = clk_round_rate(cpuclk, target_freq * 1000);\r\nif (freq < (policy->min * 1000) || freq > (policy->max * 1000))\r\nreturn -EINVAL;\r\ndev_dbg(dev, "requested frequency %u Hz\n", target_freq * 1000);\r\nfreqs.old = sh_cpufreq_get(cpu);\r\nfreqs.new = (freq + 500) / 1000;\r\nfreqs.flags = 0;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\nclk_set_rate(cpuclk, freq);\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\ndev_dbg(dev, "set frequency %lu Hz\n", freq);\r\nreturn 0;\r\n}\r\nstatic int sh_cpufreq_verify(struct cpufreq_policy *policy)\r\n{\r\nstruct clk *cpuclk = &per_cpu(sh_cpuclk, policy->cpu);\r\nstruct cpufreq_frequency_table *freq_table;\r\nfreq_table = cpuclk->nr_freqs ? cpuclk->freq_table : NULL;\r\nif (freq_table)\r\nreturn cpufreq_frequency_table_verify(policy, freq_table);\r\ncpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\npolicy->min = (clk_round_rate(cpuclk, 1) + 500) / 1000;\r\npolicy->max = (clk_round_rate(cpuclk, ~0UL) + 500) / 1000;\r\ncpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\nreturn 0;\r\n}\r\nstatic int sh_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nstruct clk *cpuclk = &per_cpu(sh_cpuclk, cpu);\r\nstruct cpufreq_frequency_table *freq_table;\r\nstruct device *dev;\r\ndev = get_cpu_device(cpu);\r\ncpuclk = clk_get(dev, "cpu_clk");\r\nif (IS_ERR(cpuclk)) {\r\ndev_err(dev, "couldn't get CPU clk\n");\r\nreturn PTR_ERR(cpuclk);\r\n}\r\npolicy->cur = sh_cpufreq_get(cpu);\r\nfreq_table = cpuclk->nr_freqs ? cpuclk->freq_table : NULL;\r\nif (freq_table) {\r\nint result;\r\nresult = cpufreq_frequency_table_cpuinfo(policy, freq_table);\r\nif (!result)\r\ncpufreq_frequency_table_get_attr(freq_table, cpu);\r\n} else {\r\ndev_notice(dev, "no frequency table found, falling back "\r\n"to rate rounding.\n");\r\npolicy->min = policy->cpuinfo.min_freq =\r\n(clk_round_rate(cpuclk, 1) + 500) / 1000;\r\npolicy->max = policy->cpuinfo.max_freq =\r\n(clk_round_rate(cpuclk, ~0UL) + 500) / 1000;\r\n}\r\npolicy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;\r\ndev_info(dev, "CPU Frequencies - Minimum %u.%03u MHz, "\r\n"Maximum %u.%03u MHz.\n",\r\npolicy->min / 1000, policy->min % 1000,\r\npolicy->max / 1000, policy->max % 1000);\r\nreturn 0;\r\n}\r\nstatic int sh_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nstruct clk *cpuclk = &per_cpu(sh_cpuclk, cpu);\r\ncpufreq_frequency_table_put_attr(cpu);\r\nclk_put(cpuclk);\r\nreturn 0;\r\n}\r\nstatic int __init sh_cpufreq_module_init(void)\r\n{\r\npr_notice("SuperH CPU frequency driver.\n");\r\nreturn cpufreq_register_driver(&sh_cpufreq_driver);\r\n}\r\nstatic void __exit sh_cpufreq_module_exit(void)\r\n{\r\ncpufreq_unregister_driver(&sh_cpufreq_driver);\r\n}
