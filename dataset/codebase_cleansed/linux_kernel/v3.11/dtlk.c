static ssize_t dtlk_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nunsigned int minor = iminor(file_inode(file));\r\nchar ch;\r\nint i = 0, retries;\r\nTRACE_TEXT("(dtlk_read");\r\nif (minor != DTLK_MINOR || !dtlk_has_indexing)\r\nreturn -EINVAL;\r\nfor (retries = 0; retries < loops_per_jiffy; retries++) {\r\nwhile (i < count && dtlk_readable()) {\r\nch = dtlk_read_lpc();\r\nif (put_user(ch, buf++))\r\nreturn -EFAULT;\r\ni++;\r\n}\r\nif (i)\r\nreturn i;\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nmsleep_interruptible(100);\r\n}\r\nif (retries == loops_per_jiffy)\r\nprintk(KERN_ERR "dtlk_read times out\n");\r\nTRACE_RET;\r\nreturn -EAGAIN;\r\n}\r\nstatic ssize_t dtlk_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nint i = 0, retries = 0, ch;\r\nTRACE_TEXT("(dtlk_write");\r\n#ifdef TRACING\r\nprintk(" \"");\r\n{\r\nint i, ch;\r\nfor (i = 0; i < count; i++) {\r\nif (get_user(ch, buf + i))\r\nreturn -EFAULT;\r\nif (' ' <= ch && ch <= '~')\r\nprintk("%c", ch);\r\nelse\r\nprintk("\\%03o", ch);\r\n}\r\nprintk("\"");\r\n}\r\n#endif\r\nif (iminor(file_inode(file)) != DTLK_MINOR)\r\nreturn -EINVAL;\r\nwhile (1) {\r\nwhile (i < count && !get_user(ch, buf) &&\r\n(ch == DTLK_CLEAR || dtlk_writeable())) {\r\ndtlk_write_tts(ch);\r\nbuf++;\r\ni++;\r\nif (i % 5 == 0)\r\nmsleep_interruptible(1);\r\nelse {\r\nfor (retries = 0;\r\nretries < loops_per_jiffy / (4000/HZ);\r\nretries++)\r\nif (inb_p(dtlk_port_tts) &\r\nTTS_WRITABLE)\r\nbreak;\r\n}\r\nretries = 0;\r\n}\r\nif (i == count)\r\nreturn i;\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nmsleep_interruptible(1);\r\nif (++retries > 10 * HZ) {\r\nprintk("dtlk: write timeout. "\r\n"inb_p(dtlk_port_tts) = 0x%02x\n",\r\ninb_p(dtlk_port_tts));\r\nTRACE_RET;\r\nreturn -EBUSY;\r\n}\r\n}\r\nTRACE_RET;\r\nreturn -EAGAIN;\r\n}\r\nstatic unsigned int dtlk_poll(struct file *file, poll_table * wait)\r\n{\r\nint mask = 0;\r\nunsigned long expires;\r\nTRACE_TEXT(" dtlk_poll");\r\npoll_wait(file, &dtlk_process_list, wait);\r\nif (dtlk_has_indexing && dtlk_readable()) {\r\ndel_timer(&dtlk_timer);\r\nmask = POLLIN | POLLRDNORM;\r\n}\r\nif (dtlk_writeable()) {\r\ndel_timer(&dtlk_timer);\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nexpires = jiffies + 3*HZ / 100;\r\nmod_timer(&dtlk_timer, expires);\r\nreturn mask;\r\n}\r\nstatic void dtlk_timer_tick(unsigned long data)\r\n{\r\nTRACE_TEXT(" dtlk_timer_tick");\r\nwake_up_interruptible(&dtlk_process_list);\r\n}\r\nstatic long dtlk_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nchar __user *argp = (char __user *)arg;\r\nstruct dtlk_settings *sp;\r\nchar portval;\r\nTRACE_TEXT(" dtlk_ioctl");\r\nswitch (cmd) {\r\ncase DTLK_INTERROGATE:\r\nmutex_lock(&dtlk_mutex);\r\nsp = dtlk_interrogate();\r\nmutex_unlock(&dtlk_mutex);\r\nif (copy_to_user(argp, sp, sizeof(struct dtlk_settings)))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase DTLK_STATUS:\r\nportval = inb_p(dtlk_port_tts);\r\nreturn put_user(portval, argp);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int dtlk_open(struct inode *inode, struct file *file)\r\n{\r\nTRACE_TEXT("(dtlk_open");\r\nnonseekable_open(inode, file);\r\nswitch (iminor(inode)) {\r\ncase DTLK_MINOR:\r\nif (dtlk_busy)\r\nreturn -EBUSY;\r\nreturn nonseekable_open(inode, file);\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\n}\r\nstatic int dtlk_release(struct inode *inode, struct file *file)\r\n{\r\nTRACE_TEXT("(dtlk_release");\r\nswitch (iminor(inode)) {\r\ncase DTLK_MINOR:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nTRACE_RET;\r\ndel_timer_sync(&dtlk_timer);\r\nreturn 0;\r\n}\r\nstatic int __init dtlk_init(void)\r\n{\r\nint err;\r\ndtlk_port_lpc = 0;\r\ndtlk_port_tts = 0;\r\ndtlk_busy = 0;\r\ndtlk_major = register_chrdev(0, "dtlk", &dtlk_fops);\r\nif (dtlk_major < 0) {\r\nprintk(KERN_ERR "DoubleTalk PC - cannot register device\n");\r\nreturn dtlk_major;\r\n}\r\nerr = dtlk_dev_probe();\r\nif (err) {\r\nunregister_chrdev(dtlk_major, "dtlk");\r\nreturn err;\r\n}\r\nprintk(", MAJOR %d\n", dtlk_major);\r\ninit_waitqueue_head(&dtlk_process_list);\r\nreturn 0;\r\n}\r\nstatic void __exit dtlk_cleanup (void)\r\n{\r\ndtlk_write_bytes("goodbye", 8);\r\nmsleep_interruptible(500);\r\ndtlk_write_tts(DTLK_CLEAR);\r\nunregister_chrdev(dtlk_major, "dtlk");\r\nrelease_region(dtlk_port_lpc, DTLK_IO_EXTENT);\r\n}\r\nstatic int dtlk_readable(void)\r\n{\r\n#ifdef TRACING\r\nprintk(" dtlk_readable=%u@%u", inb_p(dtlk_port_lpc) != 0x7f, jiffies);\r\n#endif\r\nreturn inb_p(dtlk_port_lpc) != 0x7f;\r\n}\r\nstatic int dtlk_writeable(void)\r\n{\r\n#ifdef TRACINGMORE\r\nprintk(" dtlk_writeable=%u", (inb_p(dtlk_port_tts) & TTS_WRITABLE)!=0);\r\n#endif\r\nreturn inb_p(dtlk_port_tts) & TTS_WRITABLE;\r\n}\r\nstatic int __init dtlk_dev_probe(void)\r\n{\r\nunsigned int testval = 0;\r\nint i = 0;\r\nstruct dtlk_settings *sp;\r\nif (dtlk_port_lpc | dtlk_port_tts)\r\nreturn -EBUSY;\r\nfor (i = 0; dtlk_portlist[i]; i++) {\r\n#if 0\r\nprintk("DoubleTalk PC - Port %03x = %04x\n",\r\ndtlk_portlist[i], (testval = inw_p(dtlk_portlist[i])));\r\n#endif\r\nif (!request_region(dtlk_portlist[i], DTLK_IO_EXTENT,\r\n"dtlk"))\r\ncontinue;\r\ntestval = inw_p(dtlk_portlist[i]);\r\nif ((testval &= 0xfbff) == 0x107f) {\r\ndtlk_port_lpc = dtlk_portlist[i];\r\ndtlk_port_tts = dtlk_port_lpc + 1;\r\nsp = dtlk_interrogate();\r\nprintk("DoubleTalk PC at %03x-%03x, "\r\n"ROM version %s, serial number %u",\r\ndtlk_portlist[i], dtlk_portlist[i] +\r\nDTLK_IO_EXTENT - 1,\r\nsp->rom_version, sp->serial_number);\r\noutb_p(0xff, dtlk_port_lpc);\r\ndtlk_write_bytes("\036\1@\0\0012I\r", 8);\r\nmsleep_interruptible(100);\r\ndtlk_has_indexing = dtlk_readable();\r\n#ifdef TRACING\r\nprintk(", indexing %d\n", dtlk_has_indexing);\r\n#endif\r\n#ifdef INSCOPE\r\n{\r\n#define LOOK \\r\nfor (i = 0; i < 10; i++) \\r\n{ \\r\nbuffer[b++] = inb_p(dtlk_port_lpc); \\r\n__delay(loops_per_jiffy/(1000000/HZ)); \\r\n}\r\nchar buffer[1000];\r\nint b = 0, i, j;\r\nLOOK\r\noutb_p(0xff, dtlk_port_lpc);\r\nbuffer[b++] = 0;\r\nLOOK\r\ndtlk_write_bytes("\0012I\r", 4);\r\nbuffer[b++] = 0;\r\n__delay(50 * loops_per_jiffy / (1000/HZ));\r\noutb_p(0xff, dtlk_port_lpc);\r\nbuffer[b++] = 0;\r\nLOOK\r\nprintk("\n");\r\nfor (j = 0; j < b; j++)\r\nprintk(" %02x", buffer[j]);\r\nprintk("\n");\r\n}\r\n#endif\r\n#ifdef OUTSCOPE\r\n{\r\n#define LOOK \\r\nfor (i = 0; i < 10; i++) \\r\n{ \\r\nbuffer[b++] = inb_p(dtlk_port_tts); \\r\n__delay(loops_per_jiffy/(1000000/HZ)); \\r\n}\r\nchar buffer[1000];\r\nint b = 0, i, j;\r\nmdelay(10);\r\nLOOK\r\noutb_p(0x03, dtlk_port_tts);\r\nbuffer[b++] = 0;\r\nLOOK\r\nLOOK\r\nprintk("\n");\r\nfor (j = 0; j < b; j++)\r\nprintk(" %02x", buffer[j]);\r\nprintk("\n");\r\n}\r\n#endif\r\ndtlk_write_bytes("Double Talk found", 18);\r\nreturn 0;\r\n}\r\nrelease_region(dtlk_portlist[i], DTLK_IO_EXTENT);\r\n}\r\nprintk(KERN_INFO "DoubleTalk PC - not found\n");\r\nreturn -ENODEV;\r\n}\r\nstatic struct dtlk_settings *dtlk_interrogate(void)\r\n{\r\nunsigned char *t;\r\nstatic char buf[sizeof(struct dtlk_settings) + 1];\r\nint total, i;\r\nstatic struct dtlk_settings status;\r\nTRACE_TEXT("(dtlk_interrogate");\r\ndtlk_write_bytes("\030\001?", 3);\r\nfor (total = 0, i = 0; i < 50; i++) {\r\nbuf[total] = dtlk_read_tts();\r\nif (total > 2 && buf[total] == 0x7f)\r\nbreak;\r\nif (total < sizeof(struct dtlk_settings))\r\ntotal++;\r\n}\r\nt = buf;\r\nstatus.serial_number = t[0] + t[1] * 256;\r\nt += 2;\r\ni = 0;\r\nwhile (*t != '\r') {\r\nstatus.rom_version[i] = *t;\r\nif (i < sizeof(status.rom_version) - 1)\r\ni++;\r\nt++;\r\n}\r\nstatus.rom_version[i] = 0;\r\nt++;\r\nstatus.mode = *t++;\r\nstatus.punc_level = *t++;\r\nstatus.formant_freq = *t++;\r\nstatus.pitch = *t++;\r\nstatus.speed = *t++;\r\nstatus.volume = *t++;\r\nstatus.tone = *t++;\r\nstatus.expression = *t++;\r\nstatus.ext_dict_loaded = *t++;\r\nstatus.ext_dict_status = *t++;\r\nstatus.free_ram = *t++;\r\nstatus.articulation = *t++;\r\nstatus.reverb = *t++;\r\nstatus.eob = *t++;\r\nstatus.has_indexing = dtlk_has_indexing;\r\nTRACE_RET;\r\nreturn &status;\r\n}\r\nstatic char dtlk_read_tts(void)\r\n{\r\nint portval, retries = 0;\r\nchar ch;\r\nTRACE_TEXT("(dtlk_read_tts");\r\ndo {\r\nportval = inb_p(dtlk_port_tts);\r\n} while ((portval & TTS_READABLE) == 0 &&\r\nretries++ < DTLK_MAX_RETRIES);\r\nif (retries > DTLK_MAX_RETRIES)\r\nprintk(KERN_ERR "dtlk_read_tts() timeout\n");\r\nch = inb_p(dtlk_port_tts);\r\nch &= 0x7f;\r\noutb_p(ch, dtlk_port_tts);\r\nretries = 0;\r\ndo {\r\nportval = inb_p(dtlk_port_tts);\r\n} while ((portval & TTS_READABLE) != 0 &&\r\nretries++ < DTLK_MAX_RETRIES);\r\nif (retries > DTLK_MAX_RETRIES)\r\nprintk(KERN_ERR "dtlk_read_tts() timeout\n");\r\nTRACE_RET;\r\nreturn ch;\r\n}\r\nstatic char dtlk_read_lpc(void)\r\n{\r\nint retries = 0;\r\nchar ch;\r\nTRACE_TEXT("(dtlk_read_lpc");\r\nch = inb_p(dtlk_port_lpc);\r\noutb_p(0xff, dtlk_port_lpc);\r\nretries = (loops_per_jiffy * 20) / (1000000/HZ);\r\nwhile (inb_p(dtlk_port_lpc) != 0x7f && --retries > 0);\r\nif (retries == 0)\r\nprintk(KERN_ERR "dtlk_read_lpc() timeout\n");\r\nTRACE_RET;\r\nreturn ch;\r\n}\r\nstatic char dtlk_write_bytes(const char *buf, int n)\r\n{\r\nchar val = 0;\r\nTRACE_TEXT("(dtlk_write_bytes");\r\nwhile (n-- > 0)\r\nval = dtlk_write_tts(*buf++);\r\nTRACE_RET;\r\nreturn val;\r\n}\r\nstatic char dtlk_write_tts(char ch)\r\n{\r\nint retries = 0;\r\n#ifdef TRACINGMORE\r\nprintk(" dtlk_write_tts(");\r\nif (' ' <= ch && ch <= '~')\r\nprintk("'%c'", ch);\r\nelse\r\nprintk("0x%02x", ch);\r\n#endif\r\nif (ch != DTLK_CLEAR)\r\nwhile ((inb_p(dtlk_port_tts) & TTS_WRITABLE) == 0 &&\r\nretries++ < DTLK_MAX_RETRIES)\r\n;\r\nif (retries > DTLK_MAX_RETRIES)\r\nprintk(KERN_ERR "dtlk_write_tts() timeout\n");\r\noutb_p(ch, dtlk_port_tts);\r\nfor (retries = 0; retries < loops_per_jiffy / (100000/HZ); retries++)\r\nif ((inb_p(dtlk_port_tts) & TTS_WRITABLE) == 0)\r\nbreak;\r\n#ifdef TRACINGMORE\r\nprintk(")\n");\r\n#endif\r\nreturn 0;\r\n}
