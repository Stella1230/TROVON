void\r\niscsi_iser_recv(struct iscsi_conn *conn,\r\nstruct iscsi_hdr *hdr, char *rx_data, int rx_data_len)\r\n{\r\nint rc = 0;\r\nint datalen;\r\nint ahslen;\r\ndatalen = ntoh24(hdr->dlength);\r\nif (datalen > rx_data_len || (datalen + 4) < rx_data_len) {\r\niser_err("wrong datalen %d (hdr), %d (IB)\n",\r\ndatalen, rx_data_len);\r\nrc = ISCSI_ERR_DATALEN;\r\ngoto error;\r\n}\r\nif (datalen != rx_data_len)\r\niser_dbg("aligned datalen (%d) hdr, %d (IB)\n",\r\ndatalen, rx_data_len);\r\nahslen = hdr->hlength * 4;\r\nrc = iscsi_complete_pdu(conn, hdr, rx_data, rx_data_len);\r\nif (rc && rc != ISCSI_ERR_NO_SCSI_CMD)\r\ngoto error;\r\nreturn;\r\nerror:\r\niscsi_conn_failure(conn, rc);\r\n}\r\nstatic int iscsi_iser_pdu_alloc(struct iscsi_task *task, uint8_t opcode)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\ntask->hdr = (struct iscsi_hdr *)&iser_task->desc.iscsi_header;\r\ntask->hdr_max = sizeof(iser_task->desc.iscsi_header);\r\nreturn 0;\r\n}\r\nint iser_initialize_task_headers(struct iscsi_task *task,\r\nstruct iser_tx_desc *tx_desc)\r\n{\r\nstruct iscsi_iser_conn *iser_conn = task->conn->dd_data;\r\nstruct iser_device *device = iser_conn->ib_conn->device;\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nu64 dma_addr;\r\ndma_addr = ib_dma_map_single(device->ib_device, (void *)tx_desc,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(device->ib_device, dma_addr))\r\nreturn -ENOMEM;\r\ntx_desc->dma_addr = dma_addr;\r\ntx_desc->tx_sg[0].addr = tx_desc->dma_addr;\r\ntx_desc->tx_sg[0].length = ISER_HEADERS_LEN;\r\ntx_desc->tx_sg[0].lkey = device->mr->lkey;\r\niser_task->iser_conn = iser_conn;\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_iser_task_init(struct iscsi_task *task)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nif (iser_initialize_task_headers(task, &iser_task->desc))\r\nreturn -ENOMEM;\r\nif (!task->sc)\r\nreturn 0;\r\niser_task->command_sent = 0;\r\niser_task_rdma_init(iser_task);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)\r\n{\r\nint error = 0;\r\niser_dbg("mtask xmit [cid %d itt 0x%x]\n", conn->id, task->itt);\r\nerror = iser_send_control(conn, task);\r\nreturn error;\r\n}\r\nstatic int\r\niscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,\r\nstruct iscsi_task *task)\r\n{\r\nstruct iscsi_r2t_info *r2t = &task->unsol_r2t;\r\nstruct iscsi_data hdr;\r\nint error = 0;\r\nwhile (iscsi_task_has_unsol_data(task)) {\r\niscsi_prep_data_out_pdu(task, r2t, &hdr);\r\niser_dbg("Sending data-out: itt 0x%x, data count %d\n",\r\nhdr.itt, r2t->data_count);\r\nerror = iser_send_data_out(conn, task, &hdr);\r\nif (error) {\r\nr2t->datasn--;\r\ngoto iscsi_iser_task_xmit_unsol_data_exit;\r\n}\r\nr2t->sent += r2t->data_count;\r\niser_dbg("Need to send %d more as data-out PDUs\n",\r\nr2t->data_length - r2t->sent);\r\n}\r\niscsi_iser_task_xmit_unsol_data_exit:\r\nreturn error;\r\n}\r\nstatic int\r\niscsi_iser_task_xmit(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nint error = 0;\r\nif (!task->sc)\r\nreturn iscsi_iser_mtask_xmit(conn, task);\r\nif (task->sc->sc_data_direction == DMA_TO_DEVICE) {\r\nBUG_ON(scsi_bufflen(task->sc) == 0);\r\niser_dbg("cmd [itt %x total %d imm %d unsol_data %d\n",\r\ntask->itt, scsi_bufflen(task->sc),\r\ntask->imm_count, task->unsol_r2t.data_length);\r\n}\r\niser_dbg("ctask xmit [cid %d itt 0x%x]\n",\r\nconn->id, task->itt);\r\nif (!iser_task->command_sent) {\r\nerror = iser_send_command(conn, task);\r\nif (error)\r\ngoto iscsi_iser_task_xmit_exit;\r\niser_task->command_sent = 1;\r\n}\r\nif (iscsi_task_has_unsol_data(task))\r\nerror = iscsi_iser_task_xmit_unsol_data(conn, task);\r\niscsi_iser_task_xmit_exit:\r\nreturn error;\r\n}\r\nstatic void iscsi_iser_cleanup_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nstruct iser_tx_desc *tx_desc = &iser_task->desc;\r\nstruct iscsi_iser_conn *iser_conn = task->conn->dd_data;\r\nstruct iser_device *device = iser_conn->ib_conn->device;\r\nib_dma_unmap_single(device->ib_device,\r\ntx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);\r\nif (!task->sc)\r\nreturn;\r\nif (iser_task->status == ISER_TASK_STATUS_STARTED) {\r\niser_task->status = ISER_TASK_STATUS_COMPLETED;\r\niser_task_rdma_finalize(iser_task);\r\n}\r\n}\r\nstatic struct iscsi_cls_conn *\r\niscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_iser_conn *iser_conn;\r\ncls_conn = iscsi_conn_setup(cls_session, sizeof(*iser_conn), conn_idx);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nconn->max_recv_dlength = ISER_RECV_DATA_SEG_LEN;\r\niser_conn = conn->dd_data;\r\nconn->dd_data = iser_conn;\r\niser_conn->iscsi_conn = conn;\r\nreturn cls_conn;\r\n}\r\nstatic void\r\niscsi_iser_conn_destroy(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_iser_conn *iser_conn = conn->dd_data;\r\nstruct iser_conn *ib_conn = iser_conn->ib_conn;\r\niscsi_conn_teardown(cls_conn);\r\nif (ib_conn) {\r\nib_conn->iser_conn = NULL;\r\niser_conn_put(ib_conn, 1);\r\n}\r\n}\r\nstatic int\r\niscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn, uint64_t transport_eph,\r\nint is_leading)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_iser_conn *iser_conn;\r\nstruct iser_conn *ib_conn;\r\nstruct iscsi_endpoint *ep;\r\nint error;\r\nerror = iscsi_conn_bind(cls_session, cls_conn, is_leading);\r\nif (error)\r\nreturn error;\r\nep = iscsi_lookup_endpoint(transport_eph);\r\nif (!ep) {\r\niser_err("can't bind eph %llx\n",\r\n(unsigned long long)transport_eph);\r\nreturn -EINVAL;\r\n}\r\nib_conn = ep->dd_data;\r\nif (iser_alloc_rx_descriptors(ib_conn))\r\nreturn -ENOMEM;\r\niser_info("binding iscsi/iser conn %p %p to ib_conn %p\n",\r\nconn, conn->dd_data, ib_conn);\r\niser_conn = conn->dd_data;\r\nib_conn->iser_conn = iser_conn;\r\niser_conn->ib_conn = ib_conn;\r\niser_conn_get(ib_conn);\r\nreturn 0;\r\n}\r\nstatic void\r\niscsi_iser_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_iser_conn *iser_conn = conn->dd_data;\r\nstruct iser_conn *ib_conn = iser_conn->ib_conn;\r\nif (ib_conn) {\r\niscsi_conn_stop(cls_conn, flag);\r\niser_conn_put(ib_conn, 1);\r\n}\r\niser_conn->ib_conn = NULL;\r\n}\r\nstatic void iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\niscsi_session_teardown(cls_session);\r\niscsi_host_remove(shost);\r\niscsi_host_free(shost);\r\n}\r\nstatic struct iscsi_cls_session *\r\niscsi_iser_session_create(struct iscsi_endpoint *ep,\r\nuint16_t cmds_max, uint16_t qdepth,\r\nuint32_t initial_cmdsn)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct Scsi_Host *shost;\r\nstruct iser_conn *ib_conn;\r\nshost = iscsi_host_alloc(&iscsi_iser_sht, 0, 0);\r\nif (!shost)\r\nreturn NULL;\r\nshost->transportt = iscsi_iser_scsi_transport;\r\nshost->max_lun = iscsi_max_lun;\r\nshost->max_id = 0;\r\nshost->max_channel = 0;\r\nshost->max_cmd_len = 16;\r\nif (ep)\r\nib_conn = ep->dd_data;\r\nif (iscsi_host_add(shost,\r\nep ? ib_conn->device->ib_device->dma_device : NULL))\r\ngoto free_host;\r\ncls_session = iscsi_session_setup(&iscsi_iser_transport, shost,\r\nISCSI_DEF_XMIT_CMDS_MAX, 0,\r\nsizeof(struct iscsi_iser_task),\r\ninitial_cmdsn, 0);\r\nif (!cls_session)\r\ngoto remove_host;\r\nsession = cls_session->dd_data;\r\nshost->can_queue = session->scsi_cmds_max;\r\nreturn cls_session;\r\nremove_host:\r\niscsi_host_remove(shost);\r\nfree_host:\r\niscsi_host_free(shost);\r\nreturn NULL;\r\n}\r\nstatic int\r\niscsi_iser_set_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf, int buflen)\r\n{\r\nint value;\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\nbreak;\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("DataDigest wasn't negotiated to None");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase ISCSI_PARAM_DATADGST_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("DataDigest wasn't negotiated to None");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase ISCSI_PARAM_IFMARKER_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("IFMarker wasn't negotiated to No");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase ISCSI_PARAM_OFMARKER_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("OFMarker wasn't negotiated to No");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ndefault:\r\nreturn iscsi_set_param(cls_conn, param, buf, buflen);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\niscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstats->txdata_octets = conn->txdata_octets;\r\nstats->rxdata_octets = conn->rxdata_octets;\r\nstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\r\nstats->dataout_pdus = conn->dataout_pdus_cnt;\r\nstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\r\nstats->datain_pdus = conn->datain_pdus_cnt;\r\nstats->r2t_pdus = conn->r2t_pdus_cnt;\r\nstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\r\nstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\r\nstats->custom_length = 4;\r\nstrcpy(stats->custom[0].desc, "qp_tx_queue_full");\r\nstats->custom[0].value = 0;\r\nstrcpy(stats->custom[1].desc, "fmr_map_not_avail");\r\nstats->custom[1].value = 0; ;\r\nstrcpy(stats->custom[2].desc, "eh_abort_cnt");\r\nstats->custom[2].value = conn->eh_abort_cnt;\r\nstrcpy(stats->custom[3].desc, "fmr_unalign_cnt");\r\nstats->custom[3].value = conn->fmr_unalign_cnt;\r\n}\r\nstatic int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iser_conn *ib_conn = ep->dd_data;\r\nint len;\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nif (!ib_conn || !ib_conn->cma_id)\r\nreturn -ENOTCONN;\r\nreturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\r\n&ib_conn->cma_id->route.addr.dst_addr,\r\nparam, buf);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic struct iscsi_endpoint *\r\niscsi_iser_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\r\nint non_blocking)\r\n{\r\nint err;\r\nstruct iser_conn *ib_conn;\r\nstruct iscsi_endpoint *ep;\r\nep = iscsi_create_endpoint(sizeof(*ib_conn));\r\nif (!ep)\r\nreturn ERR_PTR(-ENOMEM);\r\nib_conn = ep->dd_data;\r\nib_conn->ep = ep;\r\niser_conn_init(ib_conn);\r\nerr = iser_connect(ib_conn, NULL, (struct sockaddr_in *)dst_addr,\r\nnon_blocking);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nreturn ep;\r\n}\r\nstatic int\r\niscsi_iser_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\r\n{\r\nstruct iser_conn *ib_conn;\r\nint rc;\r\nib_conn = ep->dd_data;\r\nrc = wait_event_interruptible_timeout(ib_conn->wait,\r\nib_conn->state == ISER_CONN_UP,\r\nmsecs_to_jiffies(timeout_ms));\r\nif (!rc &&\r\n(ib_conn->state == ISER_CONN_TERMINATING ||\r\nib_conn->state == ISER_CONN_DOWN))\r\nrc = -1;\r\niser_info("ib conn %p rc = %d\n", ib_conn, rc);\r\nif (rc > 0)\r\nreturn 1;\r\nelse if (!rc)\r\nreturn 0;\r\nelse\r\nreturn rc;\r\n}\r\nstatic void\r\niscsi_iser_ep_disconnect(struct iscsi_endpoint *ep)\r\n{\r\nstruct iser_conn *ib_conn;\r\nib_conn = ep->dd_data;\r\nif (ib_conn->iser_conn)\r\niscsi_suspend_tx(ib_conn->iser_conn->iscsi_conn);\r\niser_info("ib conn %p state %d\n", ib_conn, ib_conn->state);\r\niser_conn_terminate(ib_conn);\r\n}\r\nstatic umode_t iser_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_PING_TMO:\r\ncase ISCSI_PARAM_RECV_TMO:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_FAST_ABORT:\r\ncase ISCSI_PARAM_ABORT_TMO:\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\ncase ISCSI_PARAM_TGT_RESET_TMO:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init iser_init(void)\r\n{\r\nint err;\r\niser_dbg("Starting iSER datamover...\n");\r\nif (iscsi_max_lun < 1) {\r\niser_err("Invalid max_lun value of %u\n", iscsi_max_lun);\r\nreturn -EINVAL;\r\n}\r\nmemset(&ig, 0, sizeof(struct iser_global));\r\nig.desc_cache = kmem_cache_create("iser_descriptors",\r\nsizeof(struct iser_tx_desc),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (ig.desc_cache == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&ig.device_list_mutex);\r\nINIT_LIST_HEAD(&ig.device_list);\r\nmutex_init(&ig.connlist_mutex);\r\nINIT_LIST_HEAD(&ig.connlist);\r\niscsi_iser_scsi_transport = iscsi_register_transport(\r\n&iscsi_iser_transport);\r\nif (!iscsi_iser_scsi_transport) {\r\niser_err("iscsi_register_transport failed\n");\r\nerr = -EINVAL;\r\ngoto register_transport_failure;\r\n}\r\nreturn 0;\r\nregister_transport_failure:\r\nkmem_cache_destroy(ig.desc_cache);\r\nreturn err;\r\n}\r\nstatic void __exit iser_exit(void)\r\n{\r\niser_dbg("Removing iSER datamover...\n");\r\niscsi_unregister_transport(&iscsi_iser_transport);\r\nkmem_cache_destroy(ig.desc_cache);\r\n}
