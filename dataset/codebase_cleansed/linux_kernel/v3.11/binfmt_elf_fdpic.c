static int __init init_elf_fdpic_binfmt(void)\r\n{\r\nregister_binfmt(&elf_fdpic_format);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_elf_fdpic_binfmt(void)\r\n{\r\nunregister_binfmt(&elf_fdpic_format);\r\n}\r\nstatic int is_elf_fdpic(struct elfhdr *hdr, struct file *file)\r\n{\r\nif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0)\r\nreturn 0;\r\nif (hdr->e_type != ET_EXEC && hdr->e_type != ET_DYN)\r\nreturn 0;\r\nif (!elf_check_arch(hdr) || !elf_check_fdpic(hdr))\r\nreturn 0;\r\nif (!file->f_op || !file->f_op->mmap)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\r\nstruct file *file)\r\n{\r\nstruct elf32_phdr *phdr;\r\nunsigned long size;\r\nint retval, loop;\r\nif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\r\nreturn -ENOMEM;\r\nif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\r\nreturn -ENOMEM;\r\nsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\r\nparams->phdrs = kmalloc(size, GFP_KERNEL);\r\nif (!params->phdrs)\r\nreturn -ENOMEM;\r\nretval = kernel_read(file, params->hdr.e_phoff,\r\n(char *) params->phdrs, size);\r\nif (unlikely(retval != size))\r\nreturn retval < 0 ? retval : -ENOEXEC;\r\nphdr = params->phdrs;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\r\nif (phdr->p_type != PT_GNU_STACK)\r\ncontinue;\r\nif (phdr->p_flags & PF_X)\r\nparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\r\nelse\r\nparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\r\nparams->stack_size = phdr->p_memsz;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_elf_fdpic_binary(struct linux_binprm *bprm)\r\n{\r\nstruct elf_fdpic_params exec_params, interp_params;\r\nstruct pt_regs *regs = current_pt_regs();\r\nstruct elf_phdr *phdr;\r\nunsigned long stack_size, entryaddr;\r\n#ifdef ELF_FDPIC_PLAT_INIT\r\nunsigned long dynaddr;\r\n#endif\r\n#ifndef CONFIG_MMU\r\nunsigned long stack_prot;\r\n#endif\r\nstruct file *interpreter = NULL;\r\nchar *interpreter_name = NULL;\r\nint executable_stack;\r\nint retval, i;\r\nkdebug("____ LOAD %d ____", current->pid);\r\nmemset(&exec_params, 0, sizeof(exec_params));\r\nmemset(&interp_params, 0, sizeof(interp_params));\r\nexec_params.hdr = *(struct elfhdr *) bprm->buf;\r\nexec_params.flags = ELF_FDPIC_FLAG_PRESENT | ELF_FDPIC_FLAG_EXECUTABLE;\r\nretval = -ENOEXEC;\r\nif (!is_elf_fdpic(&exec_params.hdr, bprm->file))\r\ngoto error;\r\nretval = elf_fdpic_fetch_phdrs(&exec_params, bprm->file);\r\nif (retval < 0)\r\ngoto error;\r\nphdr = exec_params.phdrs;\r\nfor (i = 0; i < exec_params.hdr.e_phnum; i++, phdr++) {\r\nswitch (phdr->p_type) {\r\ncase PT_INTERP:\r\nretval = -ENOMEM;\r\nif (phdr->p_filesz > PATH_MAX)\r\ngoto error;\r\nretval = -ENOENT;\r\nif (phdr->p_filesz < 2)\r\ngoto error;\r\ninterpreter_name = kmalloc(phdr->p_filesz, GFP_KERNEL);\r\nif (!interpreter_name)\r\ngoto error;\r\nretval = kernel_read(bprm->file,\r\nphdr->p_offset,\r\ninterpreter_name,\r\nphdr->p_filesz);\r\nif (unlikely(retval != phdr->p_filesz)) {\r\nif (retval >= 0)\r\nretval = -ENOEXEC;\r\ngoto error;\r\n}\r\nretval = -ENOENT;\r\nif (interpreter_name[phdr->p_filesz - 1] != '\0')\r\ngoto error;\r\nkdebug("Using ELF interpreter %s", interpreter_name);\r\ninterpreter = open_exec(interpreter_name);\r\nretval = PTR_ERR(interpreter);\r\nif (IS_ERR(interpreter)) {\r\ninterpreter = NULL;\r\ngoto error;\r\n}\r\nwould_dump(bprm, interpreter);\r\nretval = kernel_read(interpreter, 0, bprm->buf,\r\nBINPRM_BUF_SIZE);\r\nif (unlikely(retval != BINPRM_BUF_SIZE)) {\r\nif (retval >= 0)\r\nretval = -ENOEXEC;\r\ngoto error;\r\n}\r\ninterp_params.hdr = *((struct elfhdr *) bprm->buf);\r\nbreak;\r\ncase PT_LOAD:\r\n#ifdef CONFIG_MMU\r\nif (exec_params.load_addr == 0)\r\nexec_params.load_addr = phdr->p_vaddr;\r\n#endif\r\nbreak;\r\n}\r\n}\r\nif (elf_check_const_displacement(&exec_params.hdr))\r\nexec_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\r\nif (interpreter_name) {\r\nretval = -ELIBBAD;\r\nif (!is_elf_fdpic(&interp_params.hdr, interpreter))\r\ngoto error;\r\ninterp_params.flags = ELF_FDPIC_FLAG_PRESENT;\r\nretval = elf_fdpic_fetch_phdrs(&interp_params, interpreter);\r\nif (retval < 0)\r\ngoto error;\r\n}\r\nstack_size = exec_params.stack_size;\r\nif (exec_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\r\nexecutable_stack = EXSTACK_ENABLE_X;\r\nelse if (exec_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\r\nexecutable_stack = EXSTACK_DISABLE_X;\r\nelse\r\nexecutable_stack = EXSTACK_DEFAULT;\r\nif (stack_size == 0) {\r\nstack_size = interp_params.stack_size;\r\nif (interp_params.flags & ELF_FDPIC_FLAG_EXEC_STACK)\r\nexecutable_stack = EXSTACK_ENABLE_X;\r\nelse if (interp_params.flags & ELF_FDPIC_FLAG_NOEXEC_STACK)\r\nexecutable_stack = EXSTACK_DISABLE_X;\r\nelse\r\nexecutable_stack = EXSTACK_DEFAULT;\r\n}\r\nretval = -ENOEXEC;\r\nif (stack_size == 0)\r\ngoto error;\r\nif (elf_check_const_displacement(&interp_params.hdr))\r\ninterp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;\r\nretval = flush_old_exec(bprm);\r\nif (retval)\r\ngoto error;\r\nset_personality(PER_LINUX_FDPIC);\r\nif (elf_read_implies_exec(&exec_params.hdr, executable_stack))\r\ncurrent->personality |= READ_IMPLIES_EXEC;\r\nsetup_new_exec(bprm);\r\nset_binfmt(&elf_fdpic_format);\r\ncurrent->mm->start_code = 0;\r\ncurrent->mm->end_code = 0;\r\ncurrent->mm->start_stack = 0;\r\ncurrent->mm->start_data = 0;\r\ncurrent->mm->end_data = 0;\r\ncurrent->mm->context.exec_fdpic_loadmap = 0;\r\ncurrent->mm->context.interp_fdpic_loadmap = 0;\r\n#ifdef CONFIG_MMU\r\nelf_fdpic_arch_lay_out_mm(&exec_params,\r\n&interp_params,\r\n&current->mm->start_stack,\r\n&current->mm->start_brk);\r\nretval = setup_arg_pages(bprm, current->mm->start_stack,\r\nexecutable_stack);\r\nif (retval < 0) {\r\nsend_sig(SIGKILL, current, 0);\r\ngoto error_kill;\r\n}\r\n#endif\r\nretval = elf_fdpic_map_file(&exec_params, bprm->file, current->mm,\r\n"executable");\r\nif (retval < 0)\r\ngoto error_kill;\r\nif (interpreter_name) {\r\nretval = elf_fdpic_map_file(&interp_params, interpreter,\r\ncurrent->mm, "interpreter");\r\nif (retval < 0) {\r\nprintk(KERN_ERR "Unable to load interpreter\n");\r\ngoto error_kill;\r\n}\r\nallow_write_access(interpreter);\r\nfput(interpreter);\r\ninterpreter = NULL;\r\n}\r\n#ifdef CONFIG_MMU\r\nif (!current->mm->start_brk)\r\ncurrent->mm->start_brk = current->mm->end_data;\r\ncurrent->mm->brk = current->mm->start_brk =\r\nPAGE_ALIGN(current->mm->start_brk);\r\n#else\r\nstack_size = (stack_size + PAGE_SIZE - 1) & PAGE_MASK;\r\nif (stack_size < PAGE_SIZE * 2)\r\nstack_size = PAGE_SIZE * 2;\r\nstack_prot = PROT_READ | PROT_WRITE;\r\nif (executable_stack == EXSTACK_ENABLE_X ||\r\n(executable_stack == EXSTACK_DEFAULT && VM_STACK_FLAGS & VM_EXEC))\r\nstack_prot |= PROT_EXEC;\r\ncurrent->mm->start_brk = vm_mmap(NULL, 0, stack_size, stack_prot,\r\nMAP_PRIVATE | MAP_ANONYMOUS |\r\nMAP_UNINITIALIZED | MAP_GROWSDOWN,\r\n0);\r\nif (IS_ERR_VALUE(current->mm->start_brk)) {\r\nretval = current->mm->start_brk;\r\ncurrent->mm->start_brk = 0;\r\ngoto error_kill;\r\n}\r\ncurrent->mm->brk = current->mm->start_brk;\r\ncurrent->mm->context.end_brk = current->mm->start_brk;\r\ncurrent->mm->context.end_brk +=\r\n(stack_size > PAGE_SIZE) ? (stack_size - PAGE_SIZE) : 0;\r\ncurrent->mm->start_stack = current->mm->start_brk + stack_size;\r\n#endif\r\ninstall_exec_creds(bprm);\r\nif (create_elf_fdpic_tables(bprm, current->mm,\r\n&exec_params, &interp_params) < 0)\r\ngoto error_kill;\r\nkdebug("- start_code %lx", current->mm->start_code);\r\nkdebug("- end_code %lx", current->mm->end_code);\r\nkdebug("- start_data %lx", current->mm->start_data);\r\nkdebug("- end_data %lx", current->mm->end_data);\r\nkdebug("- start_brk %lx", current->mm->start_brk);\r\nkdebug("- brk %lx", current->mm->brk);\r\nkdebug("- start_stack %lx", current->mm->start_stack);\r\n#ifdef ELF_FDPIC_PLAT_INIT\r\ndynaddr = interp_params.dynamic_addr ?: exec_params.dynamic_addr;\r\nELF_FDPIC_PLAT_INIT(regs, exec_params.map_addr, interp_params.map_addr,\r\ndynaddr);\r\n#endif\r\nentryaddr = interp_params.entry_addr ?: exec_params.entry_addr;\r\nstart_thread(regs, entryaddr, current->mm->start_stack);\r\nretval = 0;\r\nerror:\r\nif (interpreter) {\r\nallow_write_access(interpreter);\r\nfput(interpreter);\r\n}\r\nkfree(interpreter_name);\r\nkfree(exec_params.phdrs);\r\nkfree(exec_params.loadmap);\r\nkfree(interp_params.phdrs);\r\nkfree(interp_params.loadmap);\r\nreturn retval;\r\nerror_kill:\r\nsend_sig(SIGSEGV, current, 0);\r\ngoto error;\r\n}\r\nstatic int create_elf_fdpic_tables(struct linux_binprm *bprm,\r\nstruct mm_struct *mm,\r\nstruct elf_fdpic_params *exec_params,\r\nstruct elf_fdpic_params *interp_params)\r\n{\r\nconst struct cred *cred = current_cred();\r\nunsigned long sp, csp, nitems;\r\nelf_caddr_t __user *argv, *envp;\r\nsize_t platform_len = 0, len;\r\nchar *k_platform, *k_base_platform;\r\nchar __user *u_platform, *u_base_platform, *p;\r\nint loop;\r\nint nr;\r\n#ifdef CONFIG_MMU\r\nsp = arch_align_stack(bprm->p);\r\n#else\r\nsp = mm->start_stack;\r\nif (elf_fdpic_transfer_args_to_stack(bprm, &sp) < 0)\r\nreturn -EFAULT;\r\n#endif\r\nk_platform = ELF_PLATFORM;\r\nu_platform = NULL;\r\nif (k_platform) {\r\nplatform_len = strlen(k_platform) + 1;\r\nsp -= platform_len;\r\nu_platform = (char __user *) sp;\r\nif (__copy_to_user(u_platform, k_platform, platform_len) != 0)\r\nreturn -EFAULT;\r\n}\r\nk_base_platform = ELF_BASE_PLATFORM;\r\nu_base_platform = NULL;\r\nif (k_base_platform) {\r\nplatform_len = strlen(k_base_platform) + 1;\r\nsp -= platform_len;\r\nu_base_platform = (char __user *) sp;\r\nif (__copy_to_user(u_base_platform, k_base_platform, platform_len) != 0)\r\nreturn -EFAULT;\r\n}\r\nsp &= ~7UL;\r\nlen = sizeof(struct elf32_fdpic_loadmap);\r\nlen += sizeof(struct elf32_fdpic_loadseg) * exec_params->loadmap->nsegs;\r\nsp = (sp - len) & ~7UL;\r\nexec_params->map_addr = sp;\r\nif (copy_to_user((void __user *) sp, exec_params->loadmap, len) != 0)\r\nreturn -EFAULT;\r\ncurrent->mm->context.exec_fdpic_loadmap = (unsigned long) sp;\r\nif (interp_params->loadmap) {\r\nlen = sizeof(struct elf32_fdpic_loadmap);\r\nlen += sizeof(struct elf32_fdpic_loadseg) *\r\ninterp_params->loadmap->nsegs;\r\nsp = (sp - len) & ~7UL;\r\ninterp_params->map_addr = sp;\r\nif (copy_to_user((void __user *) sp, interp_params->loadmap,\r\nlen) != 0)\r\nreturn -EFAULT;\r\ncurrent->mm->context.interp_fdpic_loadmap = (unsigned long) sp;\r\n}\r\n#define DLINFO_ITEMS 15\r\nnitems = 1 + DLINFO_ITEMS + (k_platform ? 1 : 0) +\r\n(k_base_platform ? 1 : 0) + AT_VECTOR_SIZE_ARCH;\r\nif (bprm->interp_flags & BINPRM_FLAGS_EXECFD)\r\nnitems++;\r\ncsp = sp;\r\nsp -= nitems * 2 * sizeof(unsigned long);\r\nsp -= (bprm->envc + 1) * sizeof(char *);\r\nsp -= (bprm->argc + 1) * sizeof(char *);\r\nsp -= 1 * sizeof(unsigned long);\r\ncsp -= sp & 15UL;\r\nsp -= sp & 15UL;\r\n#define NEW_AUX_ENT(id, val) \\r\ndo { \\r\nstruct { unsigned long _id, _val; } __user *ent; \\r\n\\r\nent = (void __user *) csp; \\r\n__put_user((id), &ent[nr]._id); \\r\n__put_user((val), &ent[nr]._val); \\r\nnr++; \\r\n} while (0)\r\nnr = 0;\r\ncsp -= 2 * sizeof(unsigned long);\r\nNEW_AUX_ENT(AT_NULL, 0);\r\nif (k_platform) {\r\nnr = 0;\r\ncsp -= 2 * sizeof(unsigned long);\r\nNEW_AUX_ENT(AT_PLATFORM,\r\n(elf_addr_t) (unsigned long) u_platform);\r\n}\r\nif (k_base_platform) {\r\nnr = 0;\r\ncsp -= 2 * sizeof(unsigned long);\r\nNEW_AUX_ENT(AT_BASE_PLATFORM,\r\n(elf_addr_t) (unsigned long) u_base_platform);\r\n}\r\nif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\r\nnr = 0;\r\ncsp -= 2 * sizeof(unsigned long);\r\nNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\r\n}\r\nnr = 0;\r\ncsp -= DLINFO_ITEMS * 2 * sizeof(unsigned long);\r\nNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\r\n#ifdef ELF_HWCAP2\r\nNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\r\n#endif\r\nNEW_AUX_ENT(AT_PAGESZ, PAGE_SIZE);\r\nNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\r\nNEW_AUX_ENT(AT_PHDR, exec_params->ph_addr);\r\nNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\r\nNEW_AUX_ENT(AT_PHNUM, exec_params->hdr.e_phnum);\r\nNEW_AUX_ENT(AT_BASE, interp_params->elfhdr_addr);\r\nNEW_AUX_ENT(AT_FLAGS, 0);\r\nNEW_AUX_ENT(AT_ENTRY, exec_params->entry_addr);\r\nNEW_AUX_ENT(AT_UID, (elf_addr_t) from_kuid_munged(cred->user_ns, cred->uid));\r\nNEW_AUX_ENT(AT_EUID, (elf_addr_t) from_kuid_munged(cred->user_ns, cred->euid));\r\nNEW_AUX_ENT(AT_GID, (elf_addr_t) from_kgid_munged(cred->user_ns, cred->gid));\r\nNEW_AUX_ENT(AT_EGID, (elf_addr_t) from_kgid_munged(cred->user_ns, cred->egid));\r\nNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\r\nNEW_AUX_ENT(AT_EXECFN, bprm->exec);\r\n#ifdef ARCH_DLINFO\r\nnr = 0;\r\ncsp -= AT_VECTOR_SIZE_ARCH * 2 * sizeof(unsigned long);\r\nARCH_DLINFO;\r\n#endif\r\n#undef NEW_AUX_ENT\r\ncsp -= (bprm->envc + 1) * sizeof(elf_caddr_t);\r\nenvp = (elf_caddr_t __user *) csp;\r\ncsp -= (bprm->argc + 1) * sizeof(elf_caddr_t);\r\nargv = (elf_caddr_t __user *) csp;\r\ncsp -= sizeof(unsigned long);\r\n__put_user(bprm->argc, (unsigned long __user *) csp);\r\nBUG_ON(csp != sp);\r\n#ifdef CONFIG_MMU\r\ncurrent->mm->arg_start = bprm->p;\r\n#else\r\ncurrent->mm->arg_start = current->mm->start_stack -\r\n(MAX_ARG_PAGES * PAGE_SIZE - bprm->p);\r\n#endif\r\np = (char __user *) current->mm->arg_start;\r\nfor (loop = bprm->argc; loop > 0; loop--) {\r\n__put_user((elf_caddr_t) p, argv++);\r\nlen = strnlen_user(p, MAX_ARG_STRLEN);\r\nif (!len || len > MAX_ARG_STRLEN)\r\nreturn -EINVAL;\r\np += len;\r\n}\r\n__put_user(NULL, argv);\r\ncurrent->mm->arg_end = (unsigned long) p;\r\ncurrent->mm->env_start = (unsigned long) p;\r\nfor (loop = bprm->envc; loop > 0; loop--) {\r\n__put_user((elf_caddr_t)(unsigned long) p, envp++);\r\nlen = strnlen_user(p, MAX_ARG_STRLEN);\r\nif (!len || len > MAX_ARG_STRLEN)\r\nreturn -EINVAL;\r\np += len;\r\n}\r\n__put_user(NULL, envp);\r\ncurrent->mm->env_end = (unsigned long) p;\r\nmm->start_stack = (unsigned long) sp;\r\nreturn 0;\r\n}\r\nstatic int elf_fdpic_transfer_args_to_stack(struct linux_binprm *bprm,\r\nunsigned long *_sp)\r\n{\r\nunsigned long index, stop, sp;\r\nchar *src;\r\nint ret = 0;\r\nstop = bprm->p >> PAGE_SHIFT;\r\nsp = *_sp;\r\nfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\r\nsrc = kmap(bprm->page[index]);\r\nsp -= PAGE_SIZE;\r\nif (copy_to_user((void *) sp, src, PAGE_SIZE) != 0)\r\nret = -EFAULT;\r\nkunmap(bprm->page[index]);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n*_sp = (*_sp - (MAX_ARG_PAGES * PAGE_SIZE - bprm->p)) & ~15;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int elf_fdpic_map_file(struct elf_fdpic_params *params,\r\nstruct file *file,\r\nstruct mm_struct *mm,\r\nconst char *what)\r\n{\r\nstruct elf32_fdpic_loadmap *loadmap;\r\n#ifdef CONFIG_MMU\r\nstruct elf32_fdpic_loadseg *mseg;\r\n#endif\r\nstruct elf32_fdpic_loadseg *seg;\r\nstruct elf32_phdr *phdr;\r\nunsigned long load_addr, stop;\r\nunsigned nloads, tmp;\r\nsize_t size;\r\nint loop, ret;\r\nnloads = 0;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++)\r\nif (params->phdrs[loop].p_type == PT_LOAD)\r\nnloads++;\r\nif (nloads == 0)\r\nreturn -ELIBBAD;\r\nsize = sizeof(*loadmap) + nloads * sizeof(*seg);\r\nloadmap = kzalloc(size, GFP_KERNEL);\r\nif (!loadmap)\r\nreturn -ENOMEM;\r\nparams->loadmap = loadmap;\r\nloadmap->version = ELF32_FDPIC_LOADMAP_VERSION;\r\nloadmap->nsegs = nloads;\r\nload_addr = params->load_addr;\r\nseg = loadmap->segs;\r\nswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\r\ncase ELF_FDPIC_FLAG_CONSTDISP:\r\ncase ELF_FDPIC_FLAG_CONTIGUOUS:\r\n#ifndef CONFIG_MMU\r\nret = elf_fdpic_map_file_constdisp_on_uclinux(params, file, mm);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n#endif\r\ndefault:\r\nret = elf_fdpic_map_file_by_direct_mmap(params, file, mm);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nif (params->hdr.e_entry) {\r\nseg = loadmap->segs;\r\nfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\r\nif (params->hdr.e_entry >= seg->p_vaddr &&\r\nparams->hdr.e_entry < seg->p_vaddr + seg->p_memsz) {\r\nparams->entry_addr =\r\n(params->hdr.e_entry - seg->p_vaddr) +\r\nseg->addr;\r\nbreak;\r\n}\r\n}\r\n}\r\nstop = params->hdr.e_phoff;\r\nstop += params->hdr.e_phnum * sizeof (struct elf_phdr);\r\nphdr = params->phdrs;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\r\nif (phdr->p_type != PT_LOAD)\r\ncontinue;\r\nif (phdr->p_offset > params->hdr.e_phoff ||\r\nphdr->p_offset + phdr->p_filesz < stop)\r\ncontinue;\r\nseg = loadmap->segs;\r\nfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\r\nif (phdr->p_vaddr >= seg->p_vaddr &&\r\nphdr->p_vaddr + phdr->p_filesz <=\r\nseg->p_vaddr + seg->p_memsz) {\r\nparams->ph_addr =\r\n(phdr->p_vaddr - seg->p_vaddr) +\r\nseg->addr +\r\nparams->hdr.e_phoff - phdr->p_offset;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nphdr = params->phdrs;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\r\nif (phdr->p_type != PT_DYNAMIC)\r\ncontinue;\r\nseg = loadmap->segs;\r\nfor (loop = loadmap->nsegs; loop > 0; loop--, seg++) {\r\nif (phdr->p_vaddr >= seg->p_vaddr &&\r\nphdr->p_vaddr + phdr->p_memsz <=\r\nseg->p_vaddr + seg->p_memsz) {\r\nparams->dynamic_addr =\r\n(phdr->p_vaddr - seg->p_vaddr) +\r\nseg->addr;\r\nif (phdr->p_memsz == 0 ||\r\nphdr->p_memsz % sizeof(Elf32_Dyn) != 0)\r\ngoto dynamic_error;\r\ntmp = phdr->p_memsz / sizeof(Elf32_Dyn);\r\nif (((Elf32_Dyn *)\r\nparams->dynamic_addr)[tmp - 1].d_tag != 0)\r\ngoto dynamic_error;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n#ifdef CONFIG_MMU\r\nnloads = loadmap->nsegs;\r\nmseg = loadmap->segs;\r\nseg = mseg + 1;\r\nfor (loop = 1; loop < nloads; loop++) {\r\nif (seg->p_vaddr - mseg->p_vaddr == seg->addr - mseg->addr) {\r\nload_addr = PAGE_ALIGN(mseg->addr + mseg->p_memsz);\r\nif (load_addr == (seg->addr & PAGE_MASK)) {\r\nmseg->p_memsz +=\r\nload_addr -\r\n(mseg->addr + mseg->p_memsz);\r\nmseg->p_memsz += seg->addr & ~PAGE_MASK;\r\nmseg->p_memsz += seg->p_memsz;\r\nloadmap->nsegs--;\r\ncontinue;\r\n}\r\n}\r\nmseg++;\r\nif (mseg != seg)\r\n*mseg = *seg;\r\n}\r\n#endif\r\nkdebug("Mapped Object [%s]:", what);\r\nkdebug("- elfhdr : %lx", params->elfhdr_addr);\r\nkdebug("- entry : %lx", params->entry_addr);\r\nkdebug("- PHDR[] : %lx", params->ph_addr);\r\nkdebug("- DYNAMIC[]: %lx", params->dynamic_addr);\r\nseg = loadmap->segs;\r\nfor (loop = 0; loop < loadmap->nsegs; loop++, seg++)\r\nkdebug("- LOAD[%d] : %08x-%08x [va=%x ms=%x]",\r\nloop,\r\nseg->addr, seg->addr + seg->p_memsz - 1,\r\nseg->p_vaddr, seg->p_memsz);\r\nreturn 0;\r\ndynamic_error:\r\nprintk("ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\n",\r\nwhat, file_inode(file)->i_ino);\r\nreturn -ELIBBAD;\r\n}\r\nstatic int elf_fdpic_map_file_constdisp_on_uclinux(\r\nstruct elf_fdpic_params *params,\r\nstruct file *file,\r\nstruct mm_struct *mm)\r\n{\r\nstruct elf32_fdpic_loadseg *seg;\r\nstruct elf32_phdr *phdr;\r\nunsigned long load_addr, base = ULONG_MAX, top = 0, maddr = 0, mflags;\r\nint loop, ret;\r\nload_addr = params->load_addr;\r\nseg = params->loadmap->segs;\r\nphdr = params->phdrs;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\r\nif (params->phdrs[loop].p_type != PT_LOAD)\r\ncontinue;\r\nif (base > phdr->p_vaddr)\r\nbase = phdr->p_vaddr;\r\nif (top < phdr->p_vaddr + phdr->p_memsz)\r\ntop = phdr->p_vaddr + phdr->p_memsz;\r\n}\r\nmflags = MAP_PRIVATE;\r\nif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\r\nmflags |= MAP_EXECUTABLE;\r\nmaddr = vm_mmap(NULL, load_addr, top - base,\r\nPROT_READ | PROT_WRITE | PROT_EXEC, mflags, 0);\r\nif (IS_ERR_VALUE(maddr))\r\nreturn (int) maddr;\r\nif (load_addr != 0)\r\nload_addr += PAGE_ALIGN(top - base);\r\nphdr = params->phdrs;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\r\nif (params->phdrs[loop].p_type != PT_LOAD)\r\ncontinue;\r\nseg->addr = maddr + (phdr->p_vaddr - base);\r\nseg->p_vaddr = phdr->p_vaddr;\r\nseg->p_memsz = phdr->p_memsz;\r\nret = read_code(file, seg->addr, phdr->p_offset,\r\nphdr->p_filesz);\r\nif (ret < 0)\r\nreturn ret;\r\nif (phdr->p_offset == 0)\r\nparams->elfhdr_addr = seg->addr;\r\nif (phdr->p_filesz < phdr->p_memsz) {\r\nif (clear_user((void *) (seg->addr + phdr->p_filesz),\r\nphdr->p_memsz - phdr->p_filesz))\r\nreturn -EFAULT;\r\n}\r\nif (mm) {\r\nif (phdr->p_flags & PF_X) {\r\nif (!mm->start_code) {\r\nmm->start_code = seg->addr;\r\nmm->end_code = seg->addr +\r\nphdr->p_memsz;\r\n}\r\n} else if (!mm->start_data) {\r\nmm->start_data = seg->addr;\r\nmm->end_data = seg->addr + phdr->p_memsz;\r\n}\r\n}\r\nseg++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elf_fdpic_map_file_by_direct_mmap(struct elf_fdpic_params *params,\r\nstruct file *file,\r\nstruct mm_struct *mm)\r\n{\r\nstruct elf32_fdpic_loadseg *seg;\r\nstruct elf32_phdr *phdr;\r\nunsigned long load_addr, delta_vaddr;\r\nint loop, dvset;\r\nload_addr = params->load_addr;\r\ndelta_vaddr = 0;\r\ndvset = 0;\r\nseg = params->loadmap->segs;\r\nphdr = params->phdrs;\r\nfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\r\nunsigned long maddr, disp, excess, excess1;\r\nint prot = 0, flags;\r\nif (phdr->p_type != PT_LOAD)\r\ncontinue;\r\nkdebug("[LOAD] va=%lx of=%lx fs=%lx ms=%lx",\r\n(unsigned long) phdr->p_vaddr,\r\n(unsigned long) phdr->p_offset,\r\n(unsigned long) phdr->p_filesz,\r\n(unsigned long) phdr->p_memsz);\r\nif (phdr->p_flags & PF_R) prot |= PROT_READ;\r\nif (phdr->p_flags & PF_W) prot |= PROT_WRITE;\r\nif (phdr->p_flags & PF_X) prot |= PROT_EXEC;\r\nflags = MAP_PRIVATE | MAP_DENYWRITE;\r\nif (params->flags & ELF_FDPIC_FLAG_EXECUTABLE)\r\nflags |= MAP_EXECUTABLE;\r\nmaddr = 0;\r\nswitch (params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) {\r\ncase ELF_FDPIC_FLAG_INDEPENDENT:\r\nbreak;\r\ncase ELF_FDPIC_FLAG_HONOURVADDR:\r\nmaddr = phdr->p_vaddr;\r\nflags |= MAP_FIXED;\r\nbreak;\r\ncase ELF_FDPIC_FLAG_CONSTDISP:\r\nif (!dvset) {\r\nmaddr = load_addr;\r\ndelta_vaddr = phdr->p_vaddr;\r\ndvset = 1;\r\n} else {\r\nmaddr = load_addr + phdr->p_vaddr - delta_vaddr;\r\nflags |= MAP_FIXED;\r\n}\r\nbreak;\r\ncase ELF_FDPIC_FLAG_CONTIGUOUS:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmaddr &= PAGE_MASK;\r\ndisp = phdr->p_vaddr & ~PAGE_MASK;\r\nmaddr = vm_mmap(file, maddr, phdr->p_memsz + disp, prot, flags,\r\nphdr->p_offset - disp);\r\nkdebug("mmap[%d] <file> sz=%lx pr=%x fl=%x of=%lx --> %08lx",\r\nloop, phdr->p_memsz + disp, prot, flags,\r\nphdr->p_offset - disp, maddr);\r\nif (IS_ERR_VALUE(maddr))\r\nreturn (int) maddr;\r\nif ((params->flags & ELF_FDPIC_FLAG_ARRANGEMENT) ==\r\nELF_FDPIC_FLAG_CONTIGUOUS)\r\nload_addr += PAGE_ALIGN(phdr->p_memsz + disp);\r\nseg->addr = maddr + disp;\r\nseg->p_vaddr = phdr->p_vaddr;\r\nseg->p_memsz = phdr->p_memsz;\r\nif (phdr->p_offset == 0)\r\nparams->elfhdr_addr = seg->addr;\r\nif (prot & PROT_WRITE && disp > 0) {\r\nkdebug("clear[%d] ad=%lx sz=%lx", loop, maddr, disp);\r\nif (clear_user((void __user *) maddr, disp))\r\nreturn -EFAULT;\r\nmaddr += disp;\r\n}\r\nexcess = phdr->p_memsz - phdr->p_filesz;\r\nexcess1 = PAGE_SIZE - ((maddr + phdr->p_filesz) & ~PAGE_MASK);\r\n#ifdef CONFIG_MMU\r\nif (excess > excess1) {\r\nunsigned long xaddr = maddr + phdr->p_filesz + excess1;\r\nunsigned long xmaddr;\r\nflags |= MAP_FIXED | MAP_ANONYMOUS;\r\nxmaddr = vm_mmap(NULL, xaddr, excess - excess1,\r\nprot, flags, 0);\r\nkdebug("mmap[%d] <anon>"\r\n" ad=%lx sz=%lx pr=%x fl=%x of=0 --> %08lx",\r\nloop, xaddr, excess - excess1, prot, flags,\r\nxmaddr);\r\nif (xmaddr != xaddr)\r\nreturn -ENOMEM;\r\n}\r\nif (prot & PROT_WRITE && excess1 > 0) {\r\nkdebug("clear[%d] ad=%lx sz=%lx",\r\nloop, maddr + phdr->p_filesz, excess1);\r\nif (clear_user((void __user *) maddr + phdr->p_filesz,\r\nexcess1))\r\nreturn -EFAULT;\r\n}\r\n#else\r\nif (excess > 0) {\r\nkdebug("clear[%d] ad=%lx sz=%lx",\r\nloop, maddr + phdr->p_filesz, excess);\r\nif (clear_user((void *) maddr + phdr->p_filesz, excess))\r\nreturn -EFAULT;\r\n}\r\n#endif\r\nif (mm) {\r\nif (phdr->p_flags & PF_X) {\r\nif (!mm->start_code) {\r\nmm->start_code = maddr;\r\nmm->end_code = maddr + phdr->p_memsz;\r\n}\r\n} else if (!mm->start_data) {\r\nmm->start_data = maddr;\r\nmm->end_data = maddr + phdr->p_memsz;\r\n}\r\n}\r\nseg++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int maydump(struct vm_area_struct *vma, unsigned long mm_flags)\r\n{\r\nint dump_ok;\r\nif (vma->vm_flags & VM_IO) {\r\nkdcore("%08lx: %08lx: no (IO)", vma->vm_start, vma->vm_flags);\r\nreturn 0;\r\n}\r\nif (!(vma->vm_flags & VM_READ)) {\r\nkdcore("%08lx: %08lx: no (!read)", vma->vm_start, vma->vm_flags);\r\nreturn 0;\r\n}\r\nif (vma->vm_flags & VM_SHARED) {\r\nif (file_inode(vma->vm_file)->i_nlink == 0) {\r\ndump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);\r\nkdcore("%08lx: %08lx: %s (share)", vma->vm_start,\r\nvma->vm_flags, dump_ok ? "yes" : "no");\r\nreturn dump_ok;\r\n}\r\ndump_ok = test_bit(MMF_DUMP_MAPPED_SHARED, &mm_flags);\r\nkdcore("%08lx: %08lx: %s (share)", vma->vm_start,\r\nvma->vm_flags, dump_ok ? "yes" : "no");\r\nreturn dump_ok;\r\n}\r\n#ifdef CONFIG_MMU\r\nif (!vma->anon_vma) {\r\ndump_ok = test_bit(MMF_DUMP_MAPPED_PRIVATE, &mm_flags);\r\nkdcore("%08lx: %08lx: %s (!anon)", vma->vm_start,\r\nvma->vm_flags, dump_ok ? "yes" : "no");\r\nreturn dump_ok;\r\n}\r\n#endif\r\ndump_ok = test_bit(MMF_DUMP_ANON_PRIVATE, &mm_flags);\r\nkdcore("%08lx: %08lx: %s", vma->vm_start, vma->vm_flags,\r\ndump_ok ? "yes" : "no");\r\nreturn dump_ok;\r\n}\r\nstatic int notesize(struct memelfnote *en)\r\n{\r\nint sz;\r\nsz = sizeof(struct elf_note);\r\nsz += roundup(strlen(en->name) + 1, 4);\r\nsz += roundup(en->datasz, 4);\r\nreturn sz;\r\n}\r\nstatic int alignfile(struct file *file, loff_t *foffset)\r\n{\r\nstatic const char buf[4] = { 0, };\r\nDUMP_WRITE(buf, roundup(*foffset, 4) - *foffset, foffset);\r\nreturn 1;\r\n}\r\nstatic int writenote(struct memelfnote *men, struct file *file,\r\nloff_t *foffset)\r\n{\r\nstruct elf_note en;\r\nen.n_namesz = strlen(men->name) + 1;\r\nen.n_descsz = men->datasz;\r\nen.n_type = men->type;\r\nDUMP_WRITE(&en, sizeof(en), foffset);\r\nDUMP_WRITE(men->name, en.n_namesz, foffset);\r\nif (!alignfile(file, foffset))\r\nreturn 0;\r\nDUMP_WRITE(men->data, men->datasz, foffset);\r\nif (!alignfile(file, foffset))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline void fill_elf_fdpic_header(struct elfhdr *elf, int segs)\r\n{\r\nmemcpy(elf->e_ident, ELFMAG, SELFMAG);\r\nelf->e_ident[EI_CLASS] = ELF_CLASS;\r\nelf->e_ident[EI_DATA] = ELF_DATA;\r\nelf->e_ident[EI_VERSION] = EV_CURRENT;\r\nelf->e_ident[EI_OSABI] = ELF_OSABI;\r\nmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\r\nelf->e_type = ET_CORE;\r\nelf->e_machine = ELF_ARCH;\r\nelf->e_version = EV_CURRENT;\r\nelf->e_entry = 0;\r\nelf->e_phoff = sizeof(struct elfhdr);\r\nelf->e_shoff = 0;\r\nelf->e_flags = ELF_FDPIC_CORE_EFLAGS;\r\nelf->e_ehsize = sizeof(struct elfhdr);\r\nelf->e_phentsize = sizeof(struct elf_phdr);\r\nelf->e_phnum = segs;\r\nelf->e_shentsize = 0;\r\nelf->e_shnum = 0;\r\nelf->e_shstrndx = 0;\r\nreturn;\r\n}\r\nstatic inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\r\n{\r\nphdr->p_type = PT_NOTE;\r\nphdr->p_offset = offset;\r\nphdr->p_vaddr = 0;\r\nphdr->p_paddr = 0;\r\nphdr->p_filesz = sz;\r\nphdr->p_memsz = 0;\r\nphdr->p_flags = 0;\r\nphdr->p_align = 0;\r\nreturn;\r\n}\r\nstatic inline void fill_note(struct memelfnote *note, const char *name, int type,\r\nunsigned int sz, void *data)\r\n{\r\nnote->name = name;\r\nnote->type = type;\r\nnote->datasz = sz;\r\nnote->data = data;\r\nreturn;\r\n}\r\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\r\nstruct task_struct *p, long signr)\r\n{\r\nprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\r\nprstatus->pr_sigpend = p->pending.signal.sig[0];\r\nprstatus->pr_sighold = p->blocked.sig[0];\r\nrcu_read_lock();\r\nprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\r\nrcu_read_unlock();\r\nprstatus->pr_pid = task_pid_vnr(p);\r\nprstatus->pr_pgrp = task_pgrp_vnr(p);\r\nprstatus->pr_sid = task_session_vnr(p);\r\nif (thread_group_leader(p)) {\r\nstruct task_cputime cputime;\r\nthread_group_cputime(p, &cputime);\r\ncputime_to_timeval(cputime.utime, &prstatus->pr_utime);\r\ncputime_to_timeval(cputime.stime, &prstatus->pr_stime);\r\n} else {\r\ncputime_t utime, stime;\r\ntask_cputime(p, &utime, &stime);\r\ncputime_to_timeval(utime, &prstatus->pr_utime);\r\ncputime_to_timeval(stime, &prstatus->pr_stime);\r\n}\r\ncputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\r\ncputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\r\nprstatus->pr_exec_fdpic_loadmap = p->mm->context.exec_fdpic_loadmap;\r\nprstatus->pr_interp_fdpic_loadmap = p->mm->context.interp_fdpic_loadmap;\r\n}\r\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\r\nstruct mm_struct *mm)\r\n{\r\nconst struct cred *cred;\r\nunsigned int i, len;\r\nmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\r\nlen = mm->arg_end - mm->arg_start;\r\nif (len >= ELF_PRARGSZ)\r\nlen = ELF_PRARGSZ - 1;\r\nif (copy_from_user(&psinfo->pr_psargs,\r\n(const char __user *) mm->arg_start, len))\r\nreturn -EFAULT;\r\nfor (i = 0; i < len; i++)\r\nif (psinfo->pr_psargs[i] == 0)\r\npsinfo->pr_psargs[i] = ' ';\r\npsinfo->pr_psargs[len] = 0;\r\nrcu_read_lock();\r\npsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\r\nrcu_read_unlock();\r\npsinfo->pr_pid = task_pid_vnr(p);\r\npsinfo->pr_pgrp = task_pgrp_vnr(p);\r\npsinfo->pr_sid = task_session_vnr(p);\r\ni = p->state ? ffz(~p->state) + 1 : 0;\r\npsinfo->pr_state = i;\r\npsinfo->pr_sname = (i > 5) ? '.' : "RSDTZW"[i];\r\npsinfo->pr_zomb = psinfo->pr_sname == 'Z';\r\npsinfo->pr_nice = task_nice(p);\r\npsinfo->pr_flag = p->flags;\r\nrcu_read_lock();\r\ncred = __task_cred(p);\r\nSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\r\nSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\r\nrcu_read_unlock();\r\nstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\r\nreturn 0;\r\n}\r\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\r\n{\r\nstruct task_struct *p = t->thread;\r\nint sz = 0;\r\nt->num_notes = 0;\r\nfill_prstatus(&t->prstatus, p, signr);\r\nelf_core_copy_task_regs(p, &t->prstatus.pr_reg);\r\nfill_note(&t->notes[0], "CORE", NT_PRSTATUS, sizeof(t->prstatus),\r\n&t->prstatus);\r\nt->num_notes++;\r\nsz += notesize(&t->notes[0]);\r\nt->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL, &t->fpu);\r\nif (t->prstatus.pr_fpvalid) {\r\nfill_note(&t->notes[1], "CORE", NT_PRFPREG, sizeof(t->fpu),\r\n&t->fpu);\r\nt->num_notes++;\r\nsz += notesize(&t->notes[1]);\r\n}\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\r\nfill_note(&t->notes[2], "LINUX", ELF_CORE_XFPREG_TYPE,\r\nsizeof(t->xfpu), &t->xfpu);\r\nt->num_notes++;\r\nsz += notesize(&t->notes[2]);\r\n}\r\n#endif\r\nreturn sz;\r\n}\r\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\r\nelf_addr_t e_shoff, int segs)\r\n{\r\nelf->e_shoff = e_shoff;\r\nelf->e_shentsize = sizeof(*shdr4extnum);\r\nelf->e_shnum = 1;\r\nelf->e_shstrndx = SHN_UNDEF;\r\nmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\r\nshdr4extnum->sh_type = SHT_NULL;\r\nshdr4extnum->sh_size = elf->e_shnum;\r\nshdr4extnum->sh_link = elf->e_shstrndx;\r\nshdr4extnum->sh_info = segs;\r\n}\r\nstatic int elf_fdpic_dump_segments(struct file *file, size_t *size,\r\nunsigned long *limit, unsigned long mm_flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nint err = 0;\r\nfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\r\nunsigned long addr;\r\nif (!maydump(vma, mm_flags))\r\ncontinue;\r\nfor (addr = vma->vm_start; addr < vma->vm_end;\r\naddr += PAGE_SIZE) {\r\nstruct page *page = get_dump_page(addr);\r\nif (page) {\r\nvoid *kaddr = kmap(page);\r\n*size += PAGE_SIZE;\r\nif (*size > *limit)\r\nerr = -EFBIG;\r\nelse if (!dump_write(file, kaddr, PAGE_SIZE))\r\nerr = -EIO;\r\nkunmap(page);\r\npage_cache_release(page);\r\n} else if (!dump_seek(file, PAGE_SIZE))\r\nerr = -EFBIG;\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int elf_fdpic_dump_segments(struct file *file, size_t *size,\r\nunsigned long *limit, unsigned long mm_flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\r\nif (!maydump(vma, mm_flags))\r\ncontinue;\r\nif ((*size += PAGE_SIZE) > *limit)\r\nreturn -EFBIG;\r\nif (!dump_write(file, (void *) vma->vm_start,\r\nvma->vm_end - vma->vm_start))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t elf_core_vma_data_size(unsigned long mm_flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nsize_t size = 0;\r\nfor (vma = current->mm->mmap; vma; vma = vma->vm_next)\r\nif (maydump(vma, mm_flags))\r\nsize += vma->vm_end - vma->vm_start;\r\nreturn size;\r\n}\r\nstatic int elf_fdpic_core_dump(struct coredump_params *cprm)\r\n{\r\n#define NUM_NOTES 6\r\nint has_dumped = 0;\r\nmm_segment_t fs;\r\nint segs;\r\nsize_t size = 0;\r\nint i;\r\nstruct vm_area_struct *vma;\r\nstruct elfhdr *elf = NULL;\r\nloff_t offset = 0, dataoff, foffset;\r\nint numnote;\r\nstruct memelfnote *notes = NULL;\r\nstruct elf_prstatus *prstatus = NULL;\r\nstruct elf_prpsinfo *psinfo = NULL;\r\nLIST_HEAD(thread_list);\r\nstruct list_head *t;\r\nelf_fpregset_t *fpu = NULL;\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nelf_fpxregset_t *xfpu = NULL;\r\n#endif\r\nint thread_status_size = 0;\r\nelf_addr_t *auxv;\r\nstruct elf_phdr *phdr4note = NULL;\r\nstruct elf_shdr *shdr4extnum = NULL;\r\nElf_Half e_phnum;\r\nelf_addr_t e_shoff;\r\nelf = kmalloc(sizeof(*elf), GFP_KERNEL);\r\nif (!elf)\r\ngoto cleanup;\r\nprstatus = kzalloc(sizeof(*prstatus), GFP_KERNEL);\r\nif (!prstatus)\r\ngoto cleanup;\r\npsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\r\nif (!psinfo)\r\ngoto cleanup;\r\nnotes = kmalloc(NUM_NOTES * sizeof(struct memelfnote), GFP_KERNEL);\r\nif (!notes)\r\ngoto cleanup;\r\nfpu = kmalloc(sizeof(*fpu), GFP_KERNEL);\r\nif (!fpu)\r\ngoto cleanup;\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nxfpu = kmalloc(sizeof(*xfpu), GFP_KERNEL);\r\nif (!xfpu)\r\ngoto cleanup;\r\n#endif\r\nif (cprm->siginfo->si_signo) {\r\nstruct core_thread *ct;\r\nstruct elf_thread_status *tmp;\r\nfor (ct = current->mm->core_state->dumper.next;\r\nct; ct = ct->next) {\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\ngoto cleanup;\r\ntmp->thread = ct->task;\r\nlist_add(&tmp->list, &thread_list);\r\n}\r\nlist_for_each(t, &thread_list) {\r\nstruct elf_thread_status *tmp;\r\nint sz;\r\ntmp = list_entry(t, struct elf_thread_status, list);\r\nsz = elf_dump_thread_status(cprm->siginfo->si_signo, tmp);\r\nthread_status_size += sz;\r\n}\r\n}\r\nfill_prstatus(prstatus, current, cprm->siginfo->si_signo);\r\nelf_core_copy_regs(&prstatus->pr_reg, cprm->regs);\r\nsegs = current->mm->map_count;\r\nsegs += elf_core_extra_phdrs();\r\nsegs++;\r\ne_phnum = segs > PN_XNUM ? PN_XNUM : segs;\r\nfill_elf_fdpic_header(elf, e_phnum);\r\nhas_dumped = 1;\r\nfill_note(notes + 0, "CORE", NT_PRSTATUS, sizeof(*prstatus), prstatus);\r\nfill_psinfo(psinfo, current->group_leader, current->mm);\r\nfill_note(notes + 1, "CORE", NT_PRPSINFO, sizeof(*psinfo), psinfo);\r\nnumnote = 2;\r\nauxv = (elf_addr_t *) current->mm->saved_auxv;\r\ni = 0;\r\ndo\r\ni += 2;\r\nwhile (auxv[i - 2] != AT_NULL);\r\nfill_note(&notes[numnote++], "CORE", NT_AUXV,\r\ni * sizeof(elf_addr_t), auxv);\r\nif ((prstatus->pr_fpvalid =\r\nelf_core_copy_task_fpregs(current, cprm->regs, fpu)))\r\nfill_note(notes + numnote++,\r\n"CORE", NT_PRFPREG, sizeof(*fpu), fpu);\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nif (elf_core_copy_task_xfpregs(current, xfpu))\r\nfill_note(notes + numnote++,\r\n"LINUX", ELF_CORE_XFPREG_TYPE, sizeof(*xfpu), xfpu);\r\n#endif\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\noffset += sizeof(*elf);\r\noffset += segs * sizeof(struct elf_phdr);\r\nfoffset = offset;\r\n{\r\nint sz = 0;\r\nfor (i = 0; i < numnote; i++)\r\nsz += notesize(notes + i);\r\nsz += thread_status_size;\r\nphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\r\nif (!phdr4note)\r\ngoto end_coredump;\r\nfill_elf_note_phdr(phdr4note, sz, offset);\r\noffset += sz;\r\n}\r\ndataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\r\noffset += elf_core_vma_data_size(cprm->mm_flags);\r\noffset += elf_core_extra_data_size();\r\ne_shoff = offset;\r\nif (e_phnum == PN_XNUM) {\r\nshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\r\nif (!shdr4extnum)\r\ngoto end_coredump;\r\nfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\r\n}\r\noffset = dataoff;\r\nsize += sizeof(*elf);\r\nif (size > cprm->limit || !dump_write(cprm->file, elf, sizeof(*elf)))\r\ngoto end_coredump;\r\nsize += sizeof(*phdr4note);\r\nif (size > cprm->limit\r\n|| !dump_write(cprm->file, phdr4note, sizeof(*phdr4note)))\r\ngoto end_coredump;\r\nfor (vma = current->mm->mmap; vma; vma = vma->vm_next) {\r\nstruct elf_phdr phdr;\r\nsize_t sz;\r\nsz = vma->vm_end - vma->vm_start;\r\nphdr.p_type = PT_LOAD;\r\nphdr.p_offset = offset;\r\nphdr.p_vaddr = vma->vm_start;\r\nphdr.p_paddr = 0;\r\nphdr.p_filesz = maydump(vma, cprm->mm_flags) ? sz : 0;\r\nphdr.p_memsz = sz;\r\noffset += phdr.p_filesz;\r\nphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\r\nif (vma->vm_flags & VM_WRITE)\r\nphdr.p_flags |= PF_W;\r\nif (vma->vm_flags & VM_EXEC)\r\nphdr.p_flags |= PF_X;\r\nphdr.p_align = ELF_EXEC_PAGESIZE;\r\nsize += sizeof(phdr);\r\nif (size > cprm->limit\r\n|| !dump_write(cprm->file, &phdr, sizeof(phdr)))\r\ngoto end_coredump;\r\n}\r\nif (!elf_core_write_extra_phdrs(cprm->file, offset, &size, cprm->limit))\r\ngoto end_coredump;\r\nfor (i = 0; i < numnote; i++)\r\nif (!writenote(notes + i, cprm->file, &foffset))\r\ngoto end_coredump;\r\nlist_for_each(t, &thread_list) {\r\nstruct elf_thread_status *tmp =\r\nlist_entry(t, struct elf_thread_status, list);\r\nfor (i = 0; i < tmp->num_notes; i++)\r\nif (!writenote(&tmp->notes[i], cprm->file, &foffset))\r\ngoto end_coredump;\r\n}\r\nif (!dump_seek(cprm->file, dataoff - foffset))\r\ngoto end_coredump;\r\nif (elf_fdpic_dump_segments(cprm->file, &size, &cprm->limit,\r\ncprm->mm_flags) < 0)\r\ngoto end_coredump;\r\nif (!elf_core_write_extra_data(cprm->file, &size, cprm->limit))\r\ngoto end_coredump;\r\nif (e_phnum == PN_XNUM) {\r\nsize += sizeof(*shdr4extnum);\r\nif (size > cprm->limit\r\n|| !dump_write(cprm->file, shdr4extnum,\r\nsizeof(*shdr4extnum)))\r\ngoto end_coredump;\r\n}\r\nif (cprm->file->f_pos != offset) {\r\nprintk(KERN_WARNING\r\n"elf_core_dump: file->f_pos (%lld) != offset (%lld)\n",\r\ncprm->file->f_pos, offset);\r\n}\r\nend_coredump:\r\nset_fs(fs);\r\ncleanup:\r\nwhile (!list_empty(&thread_list)) {\r\nstruct list_head *tmp = thread_list.next;\r\nlist_del(tmp);\r\nkfree(list_entry(tmp, struct elf_thread_status, list));\r\n}\r\nkfree(phdr4note);\r\nkfree(elf);\r\nkfree(prstatus);\r\nkfree(psinfo);\r\nkfree(notes);\r\nkfree(fpu);\r\nkfree(shdr4extnum);\r\n#ifdef ELF_CORE_COPY_XFPREGS\r\nkfree(xfpu);\r\n#endif\r\nreturn has_dumped;\r\n#undef NUM_NOTES\r\n}
