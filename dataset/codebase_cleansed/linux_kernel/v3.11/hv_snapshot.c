static void\r\nvss_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct hv_vss_msg *vss_msg;\r\nvss_msg = (struct hv_vss_msg *)msg->data;\r\nif (vss_msg->vss_hdr.operation == VSS_OP_REGISTER) {\r\npr_info("VSS daemon registered\n");\r\nvss_transaction.active = false;\r\nif (vss_transaction.recv_channel != NULL)\r\nhv_vss_onchannelcallback(vss_transaction.recv_channel);\r\nreturn;\r\n}\r\nvss_respond_to_host(vss_msg->error);\r\n}\r\nstatic void vss_send_op(struct work_struct *dummy)\r\n{\r\nint op = vss_transaction.msg->vss_hdr.operation;\r\nstruct cn_msg *msg;\r\nstruct hv_vss_msg *vss_msg;\r\nmsg = kzalloc(sizeof(*msg) + sizeof(*vss_msg), GFP_ATOMIC);\r\nif (!msg)\r\nreturn;\r\nvss_msg = (struct hv_vss_msg *)msg->data;\r\nmsg->id.idx = CN_VSS_IDX;\r\nmsg->id.val = CN_VSS_VAL;\r\nvss_msg->vss_hdr.operation = op;\r\nmsg->len = sizeof(struct hv_vss_msg);\r\ncn_netlink_send(msg, 0, GFP_ATOMIC);\r\nkfree(msg);\r\nreturn;\r\n}\r\nstatic void\r\nvss_respond_to_host(int error)\r\n{\r\nstruct icmsg_hdr *icmsghdrp;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nif (!vss_transaction.active) {\r\npr_warn("VSS: Transaction not active\n");\r\nreturn;\r\n}\r\nbuf_len = vss_transaction.recv_len;\r\nchannel = vss_transaction.recv_channel;\r\nreq_id = vss_transaction.recv_req_id;\r\nvss_transaction.active = false;\r\nicmsghdrp = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nif (channel->onchannel_callback == NULL)\r\nreturn;\r\nicmsghdrp->status = error;\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nvoid hv_vss_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_vss_msg *vss_msg;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct icmsg_negotiate *negop = NULL;\r\nif (vss_transaction.active) {\r\nvss_transaction.recv_channel = channel;\r\nreturn;\r\n}\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 2, &recvlen,\r\n&requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nvmbus_prep_negotiate_resp(icmsghdrp, negop,\r\nrecv_buffer, MAX_SRV_VER, MAX_SRV_VER);\r\nnegop = (struct icmsg_negotiate *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nif (negop->icversion_data[1].major < 5)\r\nnegop->icframe_vercnt = 0;\r\n} else {\r\nvss_msg = (struct hv_vss_msg *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nvss_transaction.recv_len = recvlen;\r\nvss_transaction.recv_channel = channel;\r\nvss_transaction.recv_req_id = requestid;\r\nvss_transaction.active = true;\r\nvss_transaction.msg = (struct hv_vss_msg *)vss_msg;\r\nswitch (vss_msg->vss_hdr.operation) {\r\ncase VSS_OP_FREEZE:\r\ncase VSS_OP_THAW:\r\nschedule_work(&vss_send_op_work);\r\nreturn;\r\ncase VSS_OP_HOT_BACKUP:\r\nvss_msg->vss_cf.flags =\r\nVSS_HBU_NO_AUTO_RECOVERY;\r\nvss_respond_to_host(0);\r\nreturn;\r\ncase VSS_OP_GET_DM_INFO:\r\nvss_msg->dm_info.flags = 0;\r\nvss_respond_to_host(0);\r\nreturn;\r\ndefault:\r\nvss_respond_to_host(0);\r\nreturn;\r\n}\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nint\r\nhv_vss_init(struct hv_util_service *srv)\r\n{\r\nint err;\r\nerr = cn_add_callback(&vss_id, vss_name, vss_cn_callback);\r\nif (err)\r\nreturn err;\r\nrecv_buffer = srv->recv_buffer;\r\nvss_transaction.active = true;\r\nreturn 0;\r\n}\r\nvoid hv_vss_deinit(void)\r\n{\r\ncn_del_callback(&vss_id);\r\ncancel_work_sync(&vss_send_op_work);\r\n}
