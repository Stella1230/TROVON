static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nunsigned short int tmpcip, id;\r\nunsigned char i, j, c, target_id, lun,cmdp;\r\nunsigned char *prd;\r\nstruct scsi_cmnd *workreq;\r\nunsigned int workport, tmport, tmport1;\r\nunsigned long adrcnt, k;\r\n#ifdef ED_DBGP\r\nunsigned long l;\r\n#endif\r\nint errstus;\r\nstruct Scsi_Host *host = dev_id;\r\nstruct atp_unit *dev = (struct atp_unit *)&host->hostdata;\r\nfor (c = 0; c < 2; c++) {\r\ntmport = dev->ioport[c] + 0x1f;\r\nj = inb(tmport);\r\nif ((j & 0x80) != 0)\r\n{\r\ngoto ch_sel;\r\n}\r\ndev->in_int[c] = 0;\r\n}\r\nreturn IRQ_NONE;\r\nch_sel:\r\n#ifdef ED_DBGP\r\nprintk("atp870u_intr_handle enter\n");\r\n#endif\r\ndev->in_int[c] = 1;\r\ncmdp = inb(dev->ioport[c] + 0x10);\r\nworkport = dev->ioport[c];\r\nif (dev->working[c] != 0) {\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmport1 = workport + 0x16;\r\nif ((inb(tmport1) & 0x80) == 0)\r\noutb((inb(tmport1) | 0x80), tmport1);\r\n}\r\ntmpcip = dev->pciport[c];\r\nif ((inb(tmpcip) & 0x08) != 0)\r\n{\r\ntmpcip += 0x2;\r\nfor (k=0; k < 1000; k++) {\r\nif ((inb(tmpcip) & 0x08) == 0) {\r\ngoto stop_dma;\r\n}\r\nif ((inb(tmpcip) & 0x01) == 0) {\r\ngoto stop_dma;\r\n}\r\n}\r\n}\r\nstop_dma:\r\ntmpcip = dev->pciport[c];\r\noutb(0x00, tmpcip);\r\ntmport -= 0x08;\r\ni = inb(tmport);\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmpcip += 2;\r\noutb(0x06, tmpcip);\r\ntmpcip -= 2;\r\n}\r\ntmport -= 0x02;\r\ntarget_id = inb(tmport);\r\ntmport += 0x02;\r\nif ((target_id & 0x40) != 0) {\r\ntarget_id = (target_id & 0x07) | 0x08;\r\n} else {\r\ntarget_id &= 0x07;\r\n}\r\nif ((j & 0x40) != 0) {\r\nif (dev->last_cmd[c] == 0xff) {\r\ndev->last_cmd[c] = target_id;\r\n}\r\ndev->last_cmd[c] |= 0x40;\r\n}\r\nif (dev->dev_id == ATP885_DEVID)\r\ndev->r1f[c][target_id] |= j;\r\n#ifdef ED_DBGP\r\nprintk("atp870u_intr_handle status = %x\n",i);\r\n#endif\r\nif (i == 0x85) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmport -= 0x05;\r\nadrcnt = 0;\r\n((unsigned char *) &adrcnt)[2] = inb(tmport++);\r\n((unsigned char *) &adrcnt)[1] = inb(tmport++);\r\n((unsigned char *) &adrcnt)[0] = inb(tmport);\r\nif (dev->id[c][target_id].last_len != adrcnt)\r\n{\r\nk = dev->id[c][target_id].last_len;\r\nk -= adrcnt;\r\ndev->id[c][target_id].tran_len = k;\r\ndev->id[c][target_id].last_len = adrcnt;\r\n}\r\n#ifdef ED_DBGP\r\nprintk("tmport = %x dev->id[c][target_id].last_len = %d dev->id[c][target_id].tran_len = %d\n",tmport,dev->id[c][target_id].last_len,dev->id[c][target_id].tran_len);\r\n#endif\r\n}\r\nif (dev->wide_id[c] != 0) {\r\ntmport = workport + 0x1b;\r\noutb(0x01, tmport);\r\nwhile ((inb(tmport) & 0x01) != 0x01) {\r\noutb(0x01, tmport);\r\n}\r\n}\r\nspin_lock_irqsave(dev->host->host_lock, flags);\r\nif (((dev->quhd[c] != dev->quend[c]) || (dev->last_cmd[c] != 0xff)) &&\r\n(dev->in_snd[c] == 0)) {\r\n#ifdef ED_DBGP\r\nprintk("Call sent_s870\n");\r\n#endif\r\nsend_s870(dev,c);\r\n}\r\nspin_unlock_irqrestore(dev->host->host_lock, flags);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("Status 0x85 return\n");\r\n#endif\r\ngoto handled;\r\n}\r\nif (i == 0x40) {\r\ndev->last_cmd[c] |= 0x40;\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\nif (i == 0x21) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\ntmport -= 0x05;\r\nadrcnt = 0;\r\n((unsigned char *) &adrcnt)[2] = inb(tmport++);\r\n((unsigned char *) &adrcnt)[1] = inb(tmport++);\r\n((unsigned char *) &adrcnt)[0] = inb(tmport);\r\nk = dev->id[c][target_id].last_len;\r\nk -= adrcnt;\r\ndev->id[c][target_id].tran_len = k;\r\ndev->id[c][target_id].last_len = adrcnt;\r\ntmport -= 0x04;\r\noutb(0x41, tmport);\r\ntmport += 0x08;\r\noutb(0x08, tmport);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\nif (dev->dev_id == ATP885_DEVID) {\r\nif ((i == 0x4c) || (i == 0x4d) || (i == 0x8c) || (i == 0x8d)) {\r\nif ((i == 0x4c) || (i == 0x8c))\r\ni=0x48;\r\nelse\r\ni=0x49;\r\n}\r\n}\r\nif ((i == 0x80) || (i == 0x8f)) {\r\n#ifdef ED_DBGP\r\nprintk(KERN_DEBUG "Device reselect\n");\r\n#endif\r\nlun = 0;\r\ntmport -= 0x07;\r\nif (cmdp == 0x44 || i==0x80) {\r\ntmport += 0x0d;\r\nlun = inb(tmport) & 0x07;\r\n} else {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (cmdp == 0x41) {\r\n#ifdef ED_DBGP\r\nprintk("cmdp = 0x41\n");\r\n#endif\r\ntmport += 0x02;\r\nadrcnt = 0;\r\n((unsigned char *) &adrcnt)[2] = inb(tmport++);\r\n((unsigned char *) &adrcnt)[1] = inb(tmport++);\r\n((unsigned char *) &adrcnt)[0] = inb(tmport);\r\nk = dev->id[c][target_id].last_len;\r\nk -= adrcnt;\r\ndev->id[c][target_id].tran_len = k;\r\ndev->id[c][target_id].last_len = adrcnt;\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n} else {\r\n#ifdef ED_DBGP\r\nprintk("cmdp != 0x41\n");\r\n#endif\r\noutb(0x46, tmport);\r\ndev->id[c][target_id].dirct = 0x00;\r\ntmport += 0x02;\r\noutb(0x00, tmport++);\r\noutb(0x00, tmport++);\r\noutb(0x00, tmport++);\r\ntmport += 0x03;\r\noutb(0x08, tmport);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\n}\r\nif (dev->last_cmd[c] != 0xff) {\r\ndev->last_cmd[c] |= 0x40;\r\n}\r\nif (dev->dev_id == ATP885_DEVID) {\r\nj = inb(dev->baseport + 0x29) & 0xfe;\r\noutb(j, dev->baseport + 0x29);\r\ntmport = workport + 0x16;\r\n} else {\r\ntmport = workport + 0x10;\r\noutb(0x45, tmport);\r\ntmport += 0x06;\r\n}\r\ntarget_id = inb(tmport);\r\nif ((target_id & 0x10) != 0) {\r\ntarget_id = (target_id & 0x07) | 0x08;\r\n} else {\r\ntarget_id &= 0x07;\r\n}\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmport = workport + 0x10;\r\noutb(0x45, tmport);\r\n}\r\nworkreq = dev->id[c][target_id].curr_req;\r\n#ifdef ED_DBGP\r\nscmd_printk(KERN_DEBUG, workreq, "CDB");\r\nfor (l = 0; l < workreq->cmd_len; l++)\r\nprintk(KERN_DEBUG " %x",workreq->cmnd[l]);\r\nprintk("\n");\r\n#endif\r\ntmport = workport + 0x0f;\r\noutb(lun, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[c][target_id].devsp, tmport++);\r\nadrcnt = dev->id[c][target_id].tran_len;\r\nk = dev->id[c][target_id].last_len;\r\noutb(((unsigned char *) &k)[2], tmport++);\r\noutb(((unsigned char *) &k)[1], tmport++);\r\noutb(((unsigned char *) &k)[0], tmport++);\r\n#ifdef ED_DBGP\r\nprintk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, inb(tmport-1), inb(tmport-2), inb(tmport-3));\r\n#endif\r\nj = target_id;\r\nif (target_id > 7) {\r\nj = (j & 0x07) | 0x40;\r\n}\r\nj |= dev->id[c][target_id].dirct;\r\noutb(j, tmport++);\r\noutb(0x80,tmport);\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmpcip = dev->pciport[c] + 1;\r\ni=inb(tmpcip) & 0xf3;\r\nif ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {\r\ni |= 0x0c;\r\n}\r\noutb(i,tmpcip);\r\n} else if ((dev->dev_id == ATP880_DEVID1) ||\r\n(dev->dev_id == ATP880_DEVID2) ) {\r\ntmport = workport - 0x05;\r\nif ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {\r\noutb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);\r\n} else {\r\noutb((unsigned char) (inb(tmport) & 0x3f), tmport);\r\n}\r\n} else {\r\ntmport = workport + 0x3a;\r\nif ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {\r\noutb((unsigned char) ((inb(tmport) & 0xf3) | 0x08), tmport);\r\n} else {\r\noutb((unsigned char) (inb(tmport) & 0xf3), tmport);\r\n}\r\n}\r\ntmport = workport + 0x1b;\r\nj = 0;\r\nid = 1;\r\nid = id << target_id;\r\nif ((id & dev->wide_id[c]) != 0) {\r\nj |= 0x01;\r\n}\r\noutb(j, tmport);\r\nwhile ((inb(tmport) & 0x01) != j) {\r\noutb(j,tmport);\r\n}\r\nif (dev->id[c][target_id].last_len == 0) {\r\ntmport = workport + 0x18;\r\noutb(0x08, tmport);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("dev->id[c][target_id].last_len = 0\n");\r\n#endif\r\ngoto handled;\r\n}\r\n#ifdef ED_DBGP\r\nprintk("target_id = %d adrcnt = %d\n",target_id,adrcnt);\r\n#endif\r\nprd = dev->id[c][target_id].prd_pos;\r\nwhile (adrcnt != 0) {\r\nid = ((unsigned short int *)prd)[2];\r\nif (id == 0) {\r\nk = 0x10000;\r\n} else {\r\nk = id;\r\n}\r\nif (k > adrcnt) {\r\n((unsigned short int *)prd)[2] = (unsigned short int)\r\n(k - adrcnt);\r\n((unsigned long *)prd)[0] += adrcnt;\r\nadrcnt = 0;\r\ndev->id[c][target_id].prd_pos = prd;\r\n} else {\r\nadrcnt -= k;\r\ndev->id[c][target_id].prdaddr += 0x08;\r\nprd += 0x08;\r\nif (adrcnt == 0) {\r\ndev->id[c][target_id].prd_pos = prd;\r\n}\r\n}\r\n}\r\ntmpcip = dev->pciport[c] + 0x04;\r\noutl(dev->id[c][target_id].prdaddr, tmpcip);\r\n#ifdef ED_DBGP\r\nprintk("dev->id[%d][%d].prdaddr 0x%8x\n", c, target_id, dev->id[c][target_id].prdaddr);\r\n#endif\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmpcip -= 0x04;\r\n} else {\r\ntmpcip -= 0x02;\r\noutb(0x06, tmpcip);\r\noutb(0x00, tmpcip);\r\ntmpcip -= 0x02;\r\n}\r\ntmport = workport + 0x18;\r\nif (dev->id[c][target_id].dirct != 0) {\r\noutb(0x08, tmport);\r\noutb(0x01, tmpcip);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("status 0x80 return dirct != 0\n");\r\n#endif\r\ngoto handled;\r\n}\r\noutb(0x08, tmport);\r\noutb(0x09, tmpcip);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("status 0x80 return dirct = 0\n");\r\n#endif\r\ngoto handled;\r\n}\r\nworkreq = dev->id[c][target_id].curr_req;\r\nif (i == 0x42) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40)\r\n{\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nerrstus = 0x02;\r\nworkreq->result = errstus;\r\ngoto go_42;\r\n}\r\nif (i == 0x16) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nerrstus = 0;\r\ntmport -= 0x08;\r\nerrstus = inb(tmport);\r\nif (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {\r\nprintk(KERN_WARNING "AEC67162 CRC ERROR !\n");\r\nerrstus = 0x02;\r\n}\r\nworkreq->result = errstus;\r\ngo_42:\r\nif (dev->dev_id == ATP885_DEVID) {\r\nj = inb(dev->baseport + 0x29) | 0x01;\r\noutb(j, dev->baseport + 0x29);\r\n}\r\nscsi_dma_unmap(workreq);\r\nspin_lock_irqsave(dev->host->host_lock, flags);\r\n(*workreq->scsi_done) (workreq);\r\n#ifdef ED_DBGP\r\nprintk("workreq->scsi_done\n");\r\n#endif\r\ndev->id[c][target_id].curr_req = NULL;\r\ndev->working[c]--;\r\nspin_unlock_irqrestore(dev->host->host_lock, flags);\r\nif (dev->wide_id[c] != 0) {\r\ntmport = workport + 0x1b;\r\noutb(0x01, tmport);\r\nwhile ((inb(tmport) & 0x01) != 0x01) {\r\noutb(0x01, tmport);\r\n}\r\n}\r\nspin_lock_irqsave(dev->host->host_lock, flags);\r\nif (((dev->last_cmd[c] != 0xff) || (dev->quhd[c] != dev->quend[c])) &&\r\n(dev->in_snd[c] == 0)) {\r\n#ifdef ED_DBGP\r\nprintk("Call sent_s870(scsi_done)\n");\r\n#endif\r\nsend_s870(dev,c);\r\n}\r\nspin_unlock_irqrestore(dev->host->host_lock, flags);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (i == 0x4f) {\r\ni = 0x89;\r\n}\r\ni &= 0x0f;\r\nif (i == 0x09) {\r\ntmpcip += 4;\r\noutl(dev->id[c][target_id].prdaddr, tmpcip);\r\ntmpcip = tmpcip - 2;\r\noutb(0x06, tmpcip);\r\noutb(0x00, tmpcip);\r\ntmpcip = tmpcip - 2;\r\ntmport = workport + 0x10;\r\noutb(0x41, tmport);\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmport += 2;\r\nk = dev->id[c][target_id].last_len;\r\noutb((unsigned char) (((unsigned char *) (&k))[2]), tmport++);\r\noutb((unsigned char) (((unsigned char *) (&k))[1]), tmport++);\r\noutb((unsigned char) (((unsigned char *) (&k))[0]), tmport);\r\ndev->id[c][target_id].dirct = 0x00;\r\ntmport += 0x04;\r\n} else {\r\ndev->id[c][target_id].dirct = 0x00;\r\ntmport += 0x08;\r\n}\r\noutb(0x08, tmport);\r\noutb(0x09, tmpcip);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\nif (i == 0x08) {\r\ntmpcip += 4;\r\noutl(dev->id[c][target_id].prdaddr, tmpcip);\r\ntmpcip = tmpcip - 2;\r\noutb(0x06, tmpcip);\r\noutb(0x00, tmpcip);\r\ntmpcip = tmpcip - 2;\r\ntmport = workport + 0x10;\r\noutb(0x41, tmport);\r\nif (dev->dev_id == ATP885_DEVID) {\r\ntmport += 2;\r\nk = dev->id[c][target_id].last_len;\r\noutb((unsigned char) (((unsigned char *) (&k))[2]), tmport++);\r\noutb((unsigned char) (((unsigned char *) (&k))[1]), tmport++);\r\noutb((unsigned char) (((unsigned char *) (&k))[0]), tmport++);\r\n} else {\r\ntmport += 5;\r\n}\r\noutb((unsigned char) (inb(tmport) | 0x20), tmport);\r\ndev->id[c][target_id].dirct = 0x20;\r\ntmport += 0x03;\r\noutb(0x08, tmport);\r\noutb(0x01, tmpcip);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\ntmport -= 0x07;\r\nif (i == 0x0a) {\r\noutb(0x30, tmport);\r\n} else {\r\noutb(0x46, tmport);\r\n}\r\ndev->id[c][target_id].dirct = 0x00;\r\ntmport += 0x02;\r\noutb(0x00, tmport++);\r\noutb(0x00, tmport++);\r\noutb(0x00, tmport++);\r\ntmport += 0x03;\r\noutb(0x08, tmport);\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n} else {\r\ndev->in_int[c] = 0;\r\ngoto handled;\r\n}\r\nhandled:\r\n#ifdef ED_DBGP\r\nprintk("atp870u_intr_handle exit\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nunsigned char c;\r\nunsigned int tmport,m;\r\nstruct atp_unit *dev;\r\nstruct Scsi_Host *host;\r\nc = scmd_channel(req_p);\r\nreq_p->sense_buffer[0]=0;\r\nscsi_set_resid(req_p, 0);\r\nif (scmd_channel(req_p) > 1) {\r\nreq_p->result = 0x00040000;\r\ndone(req_p);\r\n#ifdef ED_DBGP\r\nprintk("atp870u_queuecommand : req_p->device->channel > 1\n");\r\n#endif\r\nreturn 0;\r\n}\r\nhost = req_p->device->host;\r\ndev = (struct atp_unit *)&host->hostdata;\r\nm = 1;\r\nm = m << scmd_id(req_p);\r\nif ((m & dev->active_id[c]) == 0) {\r\nreq_p->result = 0x00040000;\r\ndone(req_p);\r\nreturn 0;\r\n}\r\nif (done) {\r\nreq_p->scsi_done = done;\r\n} else {\r\n#ifdef ED_DBGP\r\nprintk( "atp870u_queuecommand: done can't be NULL\n");\r\n#endif\r\nreq_p->result = 0;\r\ndone(req_p);\r\nreturn 0;\r\n}\r\ndev->quend[c]++;\r\nif (dev->quend[c] >= qcnt) {\r\ndev->quend[c] = 0;\r\n}\r\nif (dev->quhd[c] == dev->quend[c]) {\r\nif (dev->quend[c] == 0) {\r\ndev->quend[c] = qcnt;\r\n}\r\n#ifdef ED_DBGP\r\nprintk("atp870u_queuecommand : dev->quhd[c] == dev->quend[c]\n");\r\n#endif\r\ndev->quend[c]--;\r\nreq_p->result = 0x00020000;\r\ndone(req_p);\r\nreturn 0;\r\n}\r\ndev->quereq[c][dev->quend[c]] = req_p;\r\ntmport = dev->ioport[c] + 0x1c;\r\n#ifdef ED_DBGP\r\nprintk("dev->ioport[c] = %x inb(tmport) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],inb(tmport),c,dev->in_int[c],c,dev->in_snd[c]);\r\n#endif\r\nif ((inb(tmport) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {\r\n#ifdef ED_DBGP\r\nprintk("Call sent_s870(atp870u_queuecommand)\n");\r\n#endif\r\nsend_s870(dev,c);\r\n}\r\n#ifdef ED_DBGP\r\nprintk("atp870u_queuecommand : exit\n");\r\n#endif\r\nreturn 0;\r\n}\r\nunsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)\r\n{\r\nunsigned int tmport;\r\nunsigned short int i, k;\r\nunsigned char j;\r\ntmport = dev->ioport[0] + 0x1c;\r\noutw(*val, tmport);\r\nFUN_D7:\r\nfor (i = 0; i < 10; i++) {\r\nk = inw(tmport);\r\nj = (unsigned char) (k >> 8);\r\nif ((k & 0x8000) != 0) {\r\ngoto FUN_D7;\r\n}\r\n}\r\n*val |= 0x4000;\r\noutw(*val, tmport);\r\n*val &= 0xdfff;\r\noutw(*val, tmport);\r\nFUN_D5:\r\nfor (i = 0; i < 10; i++) {\r\nif ((inw(tmport) & 0x2000) != 0) {\r\ngoto FUN_D5;\r\n}\r\n}\r\n*val |= 0x8000;\r\n*val &= 0xe0ff;\r\noutw(*val, tmport);\r\n*val &= 0xbfff;\r\noutw(*val, tmport);\r\nFUN_D6:\r\nfor (i = 0; i < 10; i++) {\r\nif ((inw(tmport) & 0x4000) != 0) {\r\ngoto FUN_D6;\r\n}\r\n}\r\nreturn j;\r\n}\r\nstatic void tscam(struct Scsi_Host *host)\r\n{\r\nunsigned int tmport;\r\nunsigned char i, j, k;\r\nunsigned long n;\r\nunsigned short int m, assignid_map, val;\r\nunsigned char mbuf[33], quintet[2];\r\nstruct atp_unit *dev = (struct atp_unit *)&host->hostdata;\r\nstatic unsigned char g2q_tab[8] = {\r\n0x38, 0x31, 0x32, 0x2b, 0x34, 0x2d, 0x2e, 0x27\r\n};\r\ntmport = dev->ioport[0] + 1;\r\noutb(0x08, tmport++);\r\noutb(0x7f, tmport);\r\ntmport = dev->ioport[0] + 0x11;\r\noutb(0x20, tmport);\r\nif ((dev->scam_on & 0x40) == 0) {\r\nreturn;\r\n}\r\nm = 1;\r\nm <<= dev->host_id[0];\r\nj = 16;\r\nif (dev->chip_ver < 4) {\r\nm |= 0xff00;\r\nj = 8;\r\n}\r\nassignid_map = m;\r\ntmport = dev->ioport[0] + 0x02;\r\noutb(0x02, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\nfor (i = 0; i < j; i++) {\r\nm = 1;\r\nm = m << i;\r\nif ((m & assignid_map) != 0) {\r\ncontinue;\r\n}\r\ntmport = dev->ioport[0] + 0x0f;\r\noutb(0, tmport++);\r\ntmport += 0x02;\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\nif (i > 7) {\r\nk = (i & 0x07) | 0x40;\r\n} else {\r\nk = i;\r\n}\r\noutb(k, tmport++);\r\ntmport = dev->ioport[0] + 0x1b;\r\nif (dev->chip_ver == 4) {\r\noutb(0x01, tmport);\r\n} else {\r\noutb(0x00, tmport);\r\n}\r\nwait_rdyok:\r\ntmport = dev->ioport[0] + 0x18;\r\noutb(0x09, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nk = inb(tmport);\r\nif (k != 0x16) {\r\nif ((k == 0x85) || (k == 0x42)) {\r\ncontinue;\r\n}\r\ntmport = dev->ioport[0] + 0x10;\r\noutb(0x41, tmport);\r\ngoto wait_rdyok;\r\n}\r\nassignid_map |= m;\r\n}\r\ntmport = dev->ioport[0] + 0x02;\r\noutb(0x7f, tmport);\r\ntmport = dev->ioport[0] + 0x1b;\r\noutb(0x02, tmport);\r\noutb(0, 0x80);\r\nval = 0x0080;\r\ntmport = dev->ioport[0] + 0x1c;\r\noutw(val, tmport);\r\nval |= 0x0040;\r\noutw(val, tmport);\r\nval |= 0x0004;\r\noutw(val, tmport);\r\ninb(0x80);\r\nval &= 0x007f;\r\noutw(val, tmport);\r\nmdelay(128);\r\nval &= 0x00fb;\r\noutw(val, tmport);\r\nwait_nomsg:\r\nif ((inb(tmport) & 0x04) != 0) {\r\ngoto wait_nomsg;\r\n}\r\noutb(1, 0x80);\r\nudelay(100);\r\nfor (n = 0; n < 0x30000; n++) {\r\nif ((inb(tmport) & 0x80) != 0) {\r\ngoto wait_io;\r\n}\r\n}\r\ngoto TCM_SYNC;\r\nwait_io:\r\nfor (n = 0; n < 0x30000; n++) {\r\nif ((inb(tmport) & 0x81) == 0x0081) {\r\ngoto wait_io1;\r\n}\r\n}\r\ngoto TCM_SYNC;\r\nwait_io1:\r\ninb(0x80);\r\nval |= 0x8003;\r\noutw(val, tmport);\r\ninb(0x80);\r\nval &= 0x00bf;\r\noutw(val, tmport);\r\noutb(2, 0x80);\r\nTCM_SYNC:\r\nmdelay(2);\r\nudelay(48);\r\nif ((inb(tmport) & 0x80) == 0x00) {\r\noutw(0, tmport--);\r\noutb(0, tmport);\r\ntmport = dev->ioport[0] + 0x15;\r\noutb(0, tmport);\r\ntmport += 0x03;\r\noutb(0x09, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0)\r\ncpu_relax();\r\ntmport -= 0x08;\r\ninb(tmport);\r\nreturn;\r\n}\r\nval &= 0x00ff;\r\nval |= 0x3f00;\r\nfun_scam(dev, &val);\r\noutb(3, 0x80);\r\nval &= 0x00ff;\r\nval |= 0x2000;\r\nfun_scam(dev, &val);\r\noutb(4, 0x80);\r\ni = 8;\r\nj = 0;\r\nTCM_ID:\r\nif ((inw(tmport) & 0x2000) == 0) {\r\ngoto TCM_ID;\r\n}\r\noutb(5, 0x80);\r\nval &= 0x00ff;\r\nval |= 0x2000;\r\nk = fun_scam(dev, &val);\r\nif ((k & 0x03) == 0) {\r\ngoto TCM_5;\r\n}\r\nmbuf[j] <<= 0x01;\r\nmbuf[j] &= 0xfe;\r\nif ((k & 0x02) != 0) {\r\nmbuf[j] |= 0x01;\r\n}\r\ni--;\r\nif (i > 0) {\r\ngoto TCM_ID;\r\n}\r\nj++;\r\ni = 8;\r\ngoto TCM_ID;\r\nTCM_5:\r\ni = 15;\r\nj = mbuf[0];\r\nif ((j & 0x20) != 0) {\r\ni = 7;\r\n}\r\nif ((j & 0x06) == 0) {\r\ngoto G2Q5;\r\n}\r\nk = mbuf[1];\r\nsmall_id:\r\nm = 1;\r\nm <<= k;\r\nif ((m & assignid_map) == 0) {\r\ngoto G2Q_QUIN;\r\n}\r\nif (k > 0) {\r\nk--;\r\ngoto small_id;\r\n}\r\nG2Q5:\r\nk = i;\r\nG2Q_LP:\r\nm = 1;\r\nm <<= k;\r\nif ((m & assignid_map) == 0) {\r\ngoto G2Q_QUIN;\r\n}\r\nif (k > 0) {\r\nk--;\r\ngoto G2Q_LP;\r\n}\r\nG2Q_QUIN:\r\nassignid_map |= m;\r\nif (k < 8) {\r\nquintet[0] = 0x38;\r\n} else {\r\nquintet[0] = 0x31;\r\n}\r\nk &= 0x07;\r\nquintet[1] = g2q_tab[k];\r\nval &= 0x00ff;\r\nm = quintet[0] << 8;\r\nval |= m;\r\nfun_scam(dev, &val);\r\nval &= 0x00ff;\r\nm = quintet[1] << 8;\r\nval |= m;\r\nfun_scam(dev, &val);\r\ngoto TCM_SYNC;\r\n}\r\nstatic void is870(struct atp_unit *dev, unsigned int wkport)\r\n{\r\nunsigned int tmport;\r\nunsigned char i, j, k, rmb, n;\r\nunsigned short int m;\r\nstatic unsigned char mbuf[512];\r\nstatic unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };\r\nstatic unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };\r\nstatic unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\r\nstatic unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0c, 0x0e };\r\nstatic unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };\r\nstatic unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };\r\ntmport = wkport + 0x3a;\r\noutb((unsigned char) (inb(tmport) | 0x10), tmport);\r\nfor (i = 0; i < 16; i++) {\r\nif ((dev->chip_ver != 4) && (i > 7)) {\r\nbreak;\r\n}\r\nm = 1;\r\nm = m << i;\r\nif ((m & dev->active_id[0]) != 0) {\r\ncontinue;\r\n}\r\nif (i == dev->host_id[0]) {\r\nprintk(KERN_INFO " ID: %2d Host Adapter\n", dev->host_id[0]);\r\ncontinue;\r\n}\r\ntmport = wkport + 0x1b;\r\nif (dev->chip_ver == 4) {\r\noutb(0x01, tmport);\r\n} else {\r\noutb(0x00, tmport);\r\n}\r\ntmport = wkport + 1;\r\noutb(0x08, tmport++);\r\noutb(0x7f, tmport++);\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\nj = i;\r\nif ((j & 0x08) != 0) {\r\nj = (j & 0x07) | 0x40;\r\n}\r\noutb(j, tmport);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ndev->active_id[0] |= m;\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x04;\r\noutb(0x00, tmport);\r\nphase_cmd:\r\ntmport = wkport + 0x18;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\ntmport = wkport + 0x10;\r\noutb(0x41, tmport);\r\ngoto phase_cmd;\r\n}\r\nsel_ok:\r\ntmport = wkport + 3;\r\noutb(inqd[0], tmport++);\r\noutb(inqd[1], tmport++);\r\noutb(inqd[2], tmport++);\r\noutb(inqd[3], tmport++);\r\noutb(inqd[4], tmport++);\r\noutb(inqd[5], tmport);\r\ntmport += 0x07;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(inqd[6], tmport++);\r\noutb(inqd[7], tmport++);\r\ntmport += 0x03;\r\noutb(inqd[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntmport = wkport + 0x1b;\r\nif (dev->chip_ver == 4)\r\noutb(0x00, tmport);\r\ntmport = wkport + 0x18;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nj = 0;\r\nrd_inq_data:\r\nk = inb(tmport);\r\nif ((k & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[j++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto rd_inq_data;\r\n}\r\nif ((k & 0x80) == 0) {\r\ngoto rd_inq_data;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j == 0x16) {\r\ngoto inq_ok;\r\n}\r\ntmport = wkport + 0x10;\r\noutb(0x46, tmport);\r\ntmport += 0x02;\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\ntmport += 0x03;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x16) {\r\ngoto sel_ok;\r\n}\r\ninq_ok:\r\nmbuf[36] = 0;\r\nprintk(KERN_INFO " ID: %2d %s\n", i, &mbuf[8]);\r\ndev->id[0][i].devtype = mbuf[0];\r\nrmb = mbuf[1];\r\nn = mbuf[7];\r\nif (dev->chip_ver != 4) {\r\ngoto not_wide;\r\n}\r\nif ((mbuf[7] & 0x60) == 0) {\r\ngoto not_wide;\r\n}\r\nif ((dev->global_map[0] & 0x20) == 0) {\r\ngoto not_wide;\r\n}\r\ntmport = wkport + 0x1b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 3;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_wide:\r\nj = 0;\r\ntmport = wkport + 0x14;\r\noutb(0x05, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(wide[j++], tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_wide;\r\n}\r\ncontinue;\r\nwidep_out:\r\ntmport = wkport + 0x18;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(0, tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_in:\r\ntmport = wkport + 0x14;\r\noutb(0xff, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nwidep_in1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto widep_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto widep_in1;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_cmd:\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x14;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[1] != 0x02) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[2] != 0x03) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[3] != 0x01) {\r\ngoto not_wide;\r\n}\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[0] |= m;\r\nnot_wide:\r\nif ((dev->id[0][i].devtype == 0x00) || (dev->id[0][i].devtype == 0x07) || ((dev->id[0][i].devtype == 0x05) && ((n & 0x10) != 0))) {\r\ngoto set_sync;\r\n}\r\ncontinue;\r\nset_sync:\r\ntmport = wkport + 0x1b;\r\nj = 0;\r\nif ((m & dev->wide_id[0]) != 0) {\r\nj |= 0x01;\r\n}\r\noutb(j, tmport);\r\ntmport = wkport + 3;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_sync:\r\nj = 0;\r\ntmport = wkport + 0x14;\r\noutb(0x06, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\nif ((m & dev->wide_id[0]) != 0) {\r\noutb(synw[j++], tmport);\r\n} else {\r\nif ((m & dev->ultra_map[0]) != 0) {\r\noutb(synu[j++], tmport);\r\n} else {\r\noutb(synn[j++], tmport);\r\n}\r\n}\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_sync;\r\n}\r\ncontinue;\r\nphase_outs:\r\ntmport = wkport + 0x18;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00) {\r\nif ((inb(tmport) & 0x01) != 0x00) {\r\ntmport -= 0x06;\r\noutb(0x00, tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_ins:\r\ntmport = wkport + 0x14;\r\noutb(0xff, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nphase_ins1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0x00) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto phase_ins1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto phase_ins1;\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_cmds:\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntar_dcons:\r\ntmport = wkport + 0x14;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ncontinue;\r\n}\r\nif (mbuf[1] != 0x03) {\r\ncontinue;\r\n}\r\nif (mbuf[4] == 0x00) {\r\ncontinue;\r\n}\r\nif (mbuf[3] > 0x64) {\r\ncontinue;\r\n}\r\nif (mbuf[4] > 0x0c) {\r\nmbuf[4] = 0x0c;\r\n}\r\ndev->id[0][i].devsp = mbuf[4];\r\nif ((mbuf[3] < 0x0d) && (rmb == 0)) {\r\nj = 0xa0;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x1a) {\r\nj = 0x20;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x33) {\r\nj = 0x40;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x4c) {\r\nj = 0x50;\r\ngoto set_syn_ok;\r\n}\r\nj = 0x60;\r\nset_syn_ok:\r\ndev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;\r\n}\r\ntmport = wkport + 0x3a;\r\noutb((unsigned char) (inb(tmport) & 0xef), tmport);\r\n}\r\nstatic void is880(struct atp_unit *dev, unsigned int wkport)\r\n{\r\nunsigned int tmport;\r\nunsigned char i, j, k, rmb, n, lvdmode;\r\nunsigned short int m;\r\nstatic unsigned char mbuf[512];\r\nstatic unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };\r\nstatic unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };\r\nstatic unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\r\nunsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };\r\nstatic unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\r\nunsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };\r\nstatic unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };\r\nstatic unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };\r\nlvdmode = inb(wkport + 0x3f) & 0x40;\r\nfor (i = 0; i < 16; i++) {\r\nm = 1;\r\nm = m << i;\r\nif ((m & dev->active_id[0]) != 0) {\r\ncontinue;\r\n}\r\nif (i == dev->host_id[0]) {\r\nprintk(KERN_INFO " ID: %2d Host Adapter\n", dev->host_id[0]);\r\ncontinue;\r\n}\r\ntmport = wkport + 0x5b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 0x41;\r\noutb(0x08, tmport++);\r\noutb(0x7f, tmport++);\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\nj = i;\r\nif ((j & 0x08) != 0) {\r\nj = (j & 0x07) | 0x40;\r\n}\r\noutb(j, tmport);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ndev->active_id[0] |= m;\r\ntmport = wkport + 0x50;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x54;\r\noutb(0x00, tmport);\r\nphase_cmd:\r\ntmport = wkport + 0x58;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\ntmport = wkport + 0x50;\r\noutb(0x41, tmport);\r\ngoto phase_cmd;\r\n}\r\nsel_ok:\r\ntmport = wkport + 0x43;\r\noutb(inqd[0], tmport++);\r\noutb(inqd[1], tmport++);\r\noutb(inqd[2], tmport++);\r\noutb(inqd[3], tmport++);\r\noutb(inqd[4], tmport++);\r\noutb(inqd[5], tmport);\r\ntmport += 0x07;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(inqd[6], tmport++);\r\noutb(inqd[7], tmport++);\r\ntmport += 0x03;\r\noutb(inqd[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntmport = wkport + 0x5b;\r\noutb(0x00, tmport);\r\ntmport = wkport + 0x58;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nj = 0;\r\nrd_inq_data:\r\nk = inb(tmport);\r\nif ((k & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[j++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto rd_inq_data;\r\n}\r\nif ((k & 0x80) == 0) {\r\ngoto rd_inq_data;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j == 0x16) {\r\ngoto inq_ok;\r\n}\r\ntmport = wkport + 0x50;\r\noutb(0x46, tmport);\r\ntmport += 0x02;\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\ntmport += 0x03;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x16)\r\ngoto sel_ok;\r\ninq_ok:\r\nmbuf[36] = 0;\r\nprintk(KERN_INFO " ID: %2d %s\n", i, &mbuf[8]);\r\ndev->id[0][i].devtype = mbuf[0];\r\nrmb = mbuf[1];\r\nn = mbuf[7];\r\nif ((mbuf[7] & 0x60) == 0) {\r\ngoto not_wide;\r\n}\r\nif ((i < 8) && ((dev->global_map[0] & 0x20) == 0)) {\r\ngoto not_wide;\r\n}\r\nif (lvdmode == 0) {\r\ngoto chg_wide;\r\n}\r\nif (dev->sp[0][i] != 0x04)\r\n{\r\ngoto chg_wide;\r\n}\r\ntmport = wkport + 0x5b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 0x43;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_u3:\r\nj = 0;\r\ntmport = wkport + 0x54;\r\noutb(0x09, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(u3[j++], tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_u3;\r\n}\r\ncontinue;\r\nu3p_out:\r\ntmport = wkport + 0x58;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(0, tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\nu3p_in:\r\ntmport = wkport + 0x54;\r\noutb(0x09, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nu3p_in1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto u3p_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto u3p_in1;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\nu3p_cmd:\r\ntmport = wkport + 0x50;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x54;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[1] != 0x06) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[2] != 0x04) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[3] == 0x09) {\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[0] |= m;\r\ndev->id[0][i].devsp = 0xce;\r\ncontinue;\r\n}\r\nchg_wide:\r\ntmport = wkport + 0x5b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 0x43;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x11 && inb(tmport) != 0x8e)\r\ncontinue;\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_wide:\r\nj = 0;\r\ntmport = wkport + 0x54;\r\noutb(0x05, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(wide[j++], tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_wide;\r\n}\r\ncontinue;\r\nwidep_out:\r\ntmport = wkport + 0x58;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(0, tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_in:\r\ntmport = wkport + 0x54;\r\noutb(0xff, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nwidep_in1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto widep_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto widep_in1;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_cmd:\r\ntmport = wkport + 0x50;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x54;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[1] != 0x02) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[2] != 0x03) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[3] != 0x01) {\r\ngoto not_wide;\r\n}\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[0] |= m;\r\nnot_wide:\r\nif ((dev->id[0][i].devtype == 0x00) || (dev->id[0][i].devtype == 0x07) || ((dev->id[0][i].devtype == 0x05) && ((n & 0x10) != 0))) {\r\nm = 1;\r\nm = m << i;\r\nif ((dev->async[0] & m) != 0) {\r\ngoto set_sync;\r\n}\r\n}\r\ncontinue;\r\nset_sync:\r\nif (dev->sp[0][i] == 0x02) {\r\nsynu[4] = 0x0c;\r\nsynuw[4] = 0x0c;\r\n} else {\r\nif (dev->sp[0][i] >= 0x03) {\r\nsynu[4] = 0x0a;\r\nsynuw[4] = 0x0a;\r\n}\r\n}\r\ntmport = wkport + 0x5b;\r\nj = 0;\r\nif ((m & dev->wide_id[0]) != 0) {\r\nj |= 0x01;\r\n}\r\noutb(j, tmport);\r\ntmport = wkport + 0x43;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[0][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {\r\ncontinue;\r\n}\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_sync:\r\nj = 0;\r\ntmport = wkport + 0x54;\r\noutb(0x06, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\nif ((m & dev->wide_id[0]) != 0) {\r\nif ((m & dev->ultra_map[0]) != 0) {\r\noutb(synuw[j++], tmport);\r\n} else {\r\noutb(synw[j++], tmport);\r\n}\r\n} else {\r\nif ((m & dev->ultra_map[0]) != 0) {\r\noutb(synu[j++], tmport);\r\n} else {\r\noutb(synn[j++], tmport);\r\n}\r\n}\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_sync;\r\n}\r\ncontinue;\r\nphase_outs:\r\ntmport = wkport + 0x58;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00) {\r\nif ((inb(tmport) & 0x01) != 0x00) {\r\ntmport -= 0x06;\r\noutb(0x00, tmport);\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_ins:\r\ntmport = wkport + 0x54;\r\noutb(0x06, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nphase_ins1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0x00) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto phase_ins1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto phase_ins1;\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_cmds:\r\ntmport = wkport + 0x50;\r\noutb(0x30, tmport);\r\ntar_dcons:\r\ntmport = wkport + 0x54;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ncontinue;\r\n}\r\nif (mbuf[1] != 0x03) {\r\ncontinue;\r\n}\r\nif (mbuf[4] == 0x00) {\r\ncontinue;\r\n}\r\nif (mbuf[3] > 0x64) {\r\ncontinue;\r\n}\r\nif (mbuf[4] > 0x0e) {\r\nmbuf[4] = 0x0e;\r\n}\r\ndev->id[0][i].devsp = mbuf[4];\r\nif (mbuf[3] < 0x0c) {\r\nj = 0xb0;\r\ngoto set_syn_ok;\r\n}\r\nif ((mbuf[3] < 0x0d) && (rmb == 0)) {\r\nj = 0xa0;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x1a) {\r\nj = 0x20;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x33) {\r\nj = 0x40;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x4c) {\r\nj = 0x50;\r\ngoto set_syn_ok;\r\n}\r\nj = 0x60;\r\nset_syn_ok:\r\ndev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;\r\n}\r\n}\r\nstatic void atp870u_free_tables(struct Scsi_Host *host)\r\n{\r\nstruct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;\r\nint j, k;\r\nfor (j=0; j < 2; j++) {\r\nfor (k = 0; k < 16; k++) {\r\nif (!atp_dev->id[j][k].prd_table)\r\ncontinue;\r\npci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prd_bus);\r\natp_dev->id[j][k].prd_table = NULL;\r\n}\r\n}\r\n}\r\nstatic int atp870u_init_tables(struct Scsi_Host *host)\r\n{\r\nstruct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;\r\nint c,k;\r\nfor(c=0;c < 2;c++) {\r\nfor(k=0;k<16;k++) {\r\natp_dev->id[c][k].prd_table = pci_alloc_consistent(atp_dev->pdev, 1024, &(atp_dev->id[c][k].prd_bus));\r\nif (!atp_dev->id[c][k].prd_table) {\r\nprintk("atp870u_init_tables fail\n");\r\natp870u_free_tables(host);\r\nreturn -ENOMEM;\r\n}\r\natp_dev->id[c][k].prdaddr = atp_dev->id[c][k].prd_bus;\r\natp_dev->id[c][k].devsp=0x20;\r\natp_dev->id[c][k].devtype = 0x7f;\r\natp_dev->id[c][k].curr_req = NULL;\r\n}\r\natp_dev->active_id[c] = 0;\r\natp_dev->wide_id[c] = 0;\r\natp_dev->host_id[c] = 0x07;\r\natp_dev->quhd[c] = 0;\r\natp_dev->quend[c] = 0;\r\natp_dev->last_cmd[c] = 0xff;\r\natp_dev->in_snd[c] = 0;\r\natp_dev->in_int[c] = 0;\r\nfor (k = 0; k < qcnt; k++) {\r\natp_dev->quereq[c][k] = NULL;\r\n}\r\nfor (k = 0; k < 16; k++) {\r\natp_dev->id[c][k].curr_req = NULL;\r\natp_dev->sp[c][k] = 0x04;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned char k, m, c;\r\nunsigned long flags;\r\nunsigned int base_io, tmport, error,n;\r\nunsigned char host_id;\r\nstruct Scsi_Host *shpnt = NULL;\r\nstruct atp_unit *atpdev, *p;\r\nunsigned char setupdata[2][16];\r\nint count = 0;\r\natpdev = kzalloc(sizeof(*atpdev), GFP_KERNEL);\r\nif (!atpdev)\r\nreturn -ENOMEM;\r\nif (pci_enable_device(pdev))\r\ngoto err_eio;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_INFO "atp870u: use 32bit DMA mask.\n");\r\n} else {\r\nprintk(KERN_ERR "atp870u: DMA mask required but not available.\n");\r\ngoto err_eio;\r\n}\r\nif (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {\r\natpdev->chip_ver = pdev->revision;\r\nif (atpdev->chip_ver < 2)\r\ngoto err_eio;\r\n}\r\nswitch (ent->device) {\r\ncase PCI_DEVICE_ID_ARTOP_AEC7612UW:\r\ncase PCI_DEVICE_ID_ARTOP_AEC7612SUW:\r\ncase ATP880_DEVID1:\r\ncase ATP880_DEVID2:\r\ncase ATP885_DEVID:\r\natpdev->chip_ver = 0x04;\r\ndefault:\r\nbreak;\r\n}\r\nbase_io = pci_resource_start(pdev, 0);\r\nbase_io &= 0xfffffff8;\r\nif ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {\r\natpdev->chip_ver = pdev->revision;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\r\nhost_id = inb(base_io + 0x39);\r\nhost_id >>= 0x04;\r\nprintk(KERN_INFO " ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d"\r\n" IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);\r\natpdev->ioport[0] = base_io + 0x40;\r\natpdev->pciport[0] = base_io + 0x28;\r\natpdev->dev_id = ent->device;\r\natpdev->host_id[0] = host_id;\r\ntmport = base_io + 0x22;\r\natpdev->scam_on = inb(tmport);\r\ntmport += 0x13;\r\natpdev->global_map[0] = inb(tmport);\r\ntmport += 0x07;\r\natpdev->ultra_map[0] = inw(tmport);\r\nn = 0x3f09;\r\nnext_fblk_880:\r\nif (n >= 0x4000)\r\ngoto flash_ok_880;\r\nm = 0;\r\noutw(n, base_io + 0x34);\r\nn += 0x0002;\r\nif (inb(base_io + 0x30) == 0xff)\r\ngoto flash_ok_880;\r\natpdev->sp[0][m++] = inb(base_io + 0x30);\r\natpdev->sp[0][m++] = inb(base_io + 0x31);\r\natpdev->sp[0][m++] = inb(base_io + 0x32);\r\natpdev->sp[0][m++] = inb(base_io + 0x33);\r\noutw(n, base_io + 0x34);\r\nn += 0x0002;\r\natpdev->sp[0][m++] = inb(base_io + 0x30);\r\natpdev->sp[0][m++] = inb(base_io + 0x31);\r\natpdev->sp[0][m++] = inb(base_io + 0x32);\r\natpdev->sp[0][m++] = inb(base_io + 0x33);\r\noutw(n, base_io + 0x34);\r\nn += 0x0002;\r\natpdev->sp[0][m++] = inb(base_io + 0x30);\r\natpdev->sp[0][m++] = inb(base_io + 0x31);\r\natpdev->sp[0][m++] = inb(base_io + 0x32);\r\natpdev->sp[0][m++] = inb(base_io + 0x33);\r\noutw(n, base_io + 0x34);\r\nn += 0x0002;\r\natpdev->sp[0][m++] = inb(base_io + 0x30);\r\natpdev->sp[0][m++] = inb(base_io + 0x31);\r\natpdev->sp[0][m++] = inb(base_io + 0x32);\r\natpdev->sp[0][m++] = inb(base_io + 0x33);\r\nn += 0x0018;\r\ngoto next_fblk_880;\r\nflash_ok_880:\r\noutw(0, base_io + 0x34);\r\natpdev->ultra_map[0] = 0;\r\natpdev->async[0] = 0;\r\nfor (k = 0; k < 16; k++) {\r\nn = 1;\r\nn = n << k;\r\nif (atpdev->sp[0][k] > 1) {\r\natpdev->ultra_map[0] |= n;\r\n} else {\r\nif (atpdev->sp[0][k] == 0)\r\natpdev->async[0] |= n;\r\n}\r\n}\r\natpdev->async[0] = ~(atpdev->async[0]);\r\noutb(atpdev->global_map[0], base_io + 0x35);\r\nshpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));\r\nif (!shpnt)\r\ngoto err_nomem;\r\np = (struct atp_unit *)&shpnt->hostdata;\r\natpdev->host = shpnt;\r\natpdev->pdev = pdev;\r\npci_set_drvdata(pdev, p);\r\nmemcpy(p, atpdev, sizeof(*atpdev));\r\nif (atp870u_init_tables(shpnt) < 0) {\r\nprintk(KERN_ERR "Unable to allocate tables for Acard controller\n");\r\ngoto unregister;\r\n}\r\nif (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt)) {\r\nprintk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);\r\ngoto free_tables;\r\n}\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\ntmport = base_io + 0x38;\r\nk = inb(tmport) & 0x80;\r\noutb(k, tmport);\r\ntmport += 0x03;\r\noutb(0x20, tmport);\r\nmdelay(32);\r\noutb(0, tmport);\r\nmdelay(32);\r\ntmport = base_io + 0x5b;\r\ninb(tmport);\r\ntmport -= 0x04;\r\ninb(tmport);\r\ntmport = base_io + 0x40;\r\noutb((host_id | 0x08), tmport);\r\ntmport += 0x18;\r\noutb(0, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0)\r\nmdelay(1);\r\ntmport -= 0x08;\r\ninb(tmport);\r\ntmport = base_io + 0x41;\r\noutb(8, tmport++);\r\noutb(0x7f, tmport);\r\ntmport = base_io + 0x51;\r\noutb(0x20, tmport);\r\ntscam(shpnt);\r\nis880(p, base_io);\r\ntmport = base_io + 0x38;\r\noutb(0xb0, tmport);\r\nshpnt->max_id = 16;\r\nshpnt->this_id = host_id;\r\nshpnt->unique_id = base_io;\r\nshpnt->io_port = base_io;\r\nshpnt->n_io_port = 0x60;\r\nshpnt->irq = pdev->irq;\r\n} else if (ent->device == ATP885_DEVID) {\r\nprintk(KERN_INFO " ACARD AEC-67162 PCI Ultra3 LVD Host Adapter: IO:%x, IRQ:%d.\n"\r\n, base_io, pdev->irq);\r\natpdev->pdev = pdev;\r\natpdev->dev_id = ent->device;\r\natpdev->baseport = base_io;\r\natpdev->ioport[0] = base_io + 0x80;\r\natpdev->ioport[1] = base_io + 0xc0;\r\natpdev->pciport[0] = base_io + 0x40;\r\natpdev->pciport[1] = base_io + 0x50;\r\nshpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));\r\nif (!shpnt)\r\ngoto err_nomem;\r\np = (struct atp_unit *)&shpnt->hostdata;\r\natpdev->host = shpnt;\r\natpdev->pdev = pdev;\r\npci_set_drvdata(pdev, p);\r\nmemcpy(p, atpdev, sizeof(struct atp_unit));\r\nif (atp870u_init_tables(shpnt) < 0)\r\ngoto unregister;\r\n#ifdef ED_DBGP\r\nprintk("request_irq() shpnt %p hostdata %p\n", shpnt, p);\r\n#endif\r\nif (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt)) {\r\nprintk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");\r\ngoto free_tables;\r\n}\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nc=inb(base_io + 0x29);\r\noutb((c | 0x04),base_io + 0x29);\r\nn=0x1f80;\r\nnext_fblk_885:\r\nif (n >= 0x2000) {\r\ngoto flash_ok_885;\r\n}\r\noutw(n,base_io + 0x3c);\r\nif (inl(base_io + 0x38) == 0xffffffff) {\r\ngoto flash_ok_885;\r\n}\r\nfor (m=0; m < 2; m++) {\r\np->global_map[m]= 0;\r\nfor (k=0; k < 4; k++) {\r\noutw(n++,base_io + 0x3c);\r\n((unsigned long *)&setupdata[m][0])[k]=inl(base_io + 0x38);\r\n}\r\nfor (k=0; k < 4; k++) {\r\noutw(n++,base_io + 0x3c);\r\n((unsigned long *)&p->sp[m][0])[k]=inl(base_io + 0x38);\r\n}\r\nn += 8;\r\n}\r\ngoto next_fblk_885;\r\nflash_ok_885:\r\n#ifdef ED_DBGP\r\nprintk( "Flash Read OK\n");\r\n#endif\r\nc=inb(base_io + 0x29);\r\noutb((c & 0xfb),base_io + 0x29);\r\nfor (c=0;c < 2;c++) {\r\np->ultra_map[c]=0;\r\np->async[c] = 0;\r\nfor (k=0; k < 16; k++) {\r\nn=1;\r\nn = n << k;\r\nif (p->sp[c][k] > 1) {\r\np->ultra_map[c] |= n;\r\n} else {\r\nif (p->sp[c][k] == 0) {\r\np->async[c] |= n;\r\n}\r\n}\r\n}\r\np->async[c] = ~(p->async[c]);\r\nif (p->global_map[c] == 0) {\r\nk=setupdata[c][1];\r\nif ((k & 0x40) != 0)\r\np->global_map[c] |= 0x20;\r\nk &= 0x07;\r\np->global_map[c] |= k;\r\nif ((setupdata[c][2] & 0x04) != 0)\r\np->global_map[c] |= 0x08;\r\np->host_id[c] = setupdata[c][0] & 0x07;\r\n}\r\n}\r\nk = inb(base_io + 0x28) & 0x8f;\r\nk |= 0x10;\r\noutb(k, base_io + 0x28);\r\noutb(0x80, base_io + 0x41);\r\noutb(0x80, base_io + 0x51);\r\nmdelay(100);\r\noutb(0, base_io + 0x41);\r\noutb(0, base_io + 0x51);\r\nmdelay(1000);\r\ninb(base_io + 0x9b);\r\ninb(base_io + 0x97);\r\ninb(base_io + 0xdb);\r\ninb(base_io + 0xd7);\r\ntmport = base_io + 0x80;\r\nk=p->host_id[0];\r\nif (k > 7)\r\nk = (k & 0x07) | 0x40;\r\nk |= 0x08;\r\noutb(k, tmport);\r\ntmport += 0x18;\r\noutb(0, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0)\r\ncpu_relax();\r\ntmport -= 0x08;\r\ninb(tmport);\r\ntmport = base_io + 0x81;\r\noutb(8, tmport++);\r\noutb(0x7f, tmport);\r\ntmport = base_io + 0x91;\r\noutb(0x20, tmport);\r\ntmport = base_io + 0xc0;\r\nk=p->host_id[1];\r\nif (k > 7)\r\nk = (k & 0x07) | 0x40;\r\nk |= 0x08;\r\noutb(k, tmport);\r\ntmport += 0x18;\r\noutb(0, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0)\r\ncpu_relax();\r\ntmport -= 0x08;\r\ninb(tmport);\r\ntmport = base_io + 0xc1;\r\noutb(8, tmport++);\r\noutb(0x7f, tmport);\r\ntmport = base_io + 0xd1;\r\noutb(0x20, tmport);\r\ntscam_885();\r\nprintk(KERN_INFO " Scanning Channel A SCSI Device ...\n");\r\nis885(p, base_io + 0x80, 0);\r\nprintk(KERN_INFO " Scanning Channel B SCSI Device ...\n");\r\nis885(p, base_io + 0xc0, 1);\r\nk = inb(base_io + 0x28) & 0xcf;\r\nk |= 0xc0;\r\noutb(k, base_io + 0x28);\r\nk = inb(base_io + 0x1f) | 0x80;\r\noutb(k, base_io + 0x1f);\r\nk = inb(base_io + 0x29) | 0x01;\r\noutb(k, base_io + 0x29);\r\n#ifdef ED_DBGP\r\n#endif\r\nshpnt->max_id = 16;\r\nshpnt->max_lun = (p->global_map[0] & 0x07) + 1;\r\nshpnt->max_channel = 1;\r\nshpnt->this_id = p->host_id[0];\r\nshpnt->unique_id = base_io;\r\nshpnt->io_port = base_io;\r\nshpnt->n_io_port = 0xff;\r\nshpnt->irq = pdev->irq;\r\n} else {\r\nerror = pci_read_config_byte(pdev, 0x49, &host_id);\r\nprintk(KERN_INFO " ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: %d "\r\n"IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);\r\natpdev->ioport[0] = base_io;\r\natpdev->pciport[0] = base_io + 0x20;\r\natpdev->dev_id = ent->device;\r\nhost_id &= 0x07;\r\natpdev->host_id[0] = host_id;\r\ntmport = base_io + 0x22;\r\natpdev->scam_on = inb(tmport);\r\ntmport += 0x0b;\r\natpdev->global_map[0] = inb(tmport++);\r\natpdev->ultra_map[0] = inw(tmport);\r\nif (atpdev->ultra_map[0] == 0) {\r\natpdev->scam_on = 0x00;\r\natpdev->global_map[0] = 0x20;\r\natpdev->ultra_map[0] = 0xffff;\r\n}\r\nshpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));\r\nif (!shpnt)\r\ngoto err_nomem;\r\np = (struct atp_unit *)&shpnt->hostdata;\r\natpdev->host = shpnt;\r\natpdev->pdev = pdev;\r\npci_set_drvdata(pdev, p);\r\nmemcpy(p, atpdev, sizeof(*atpdev));\r\nif (atp870u_init_tables(shpnt) < 0)\r\ngoto unregister;\r\nif (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt)) {\r\nprintk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);\r\ngoto free_tables;\r\n}\r\nspin_lock_irqsave(shpnt->host_lock, flags);\r\nif (atpdev->chip_ver > 0x07) {\r\ntmport = base_io + 0x3e;\r\noutb(0x00, tmport);\r\n}\r\ntmport = base_io + 0x3a;\r\nk = (inb(tmport) & 0xf3) | 0x10;\r\noutb(k, tmport);\r\noutb((k & 0xdf), tmport);\r\nmdelay(32);\r\noutb(k, tmport);\r\nmdelay(32);\r\ntmport = base_io;\r\noutb((host_id | 0x08), tmport);\r\ntmport += 0x18;\r\noutb(0, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0)\r\nmdelay(1);\r\ntmport -= 0x08;\r\ninb(tmport);\r\ntmport = base_io + 1;\r\noutb(8, tmport++);\r\noutb(0x7f, tmport);\r\ntmport = base_io + 0x11;\r\noutb(0x20, tmport);\r\ntscam(shpnt);\r\nis870(p, base_io);\r\ntmport = base_io + 0x3a;\r\noutb((inb(tmport) & 0xef), tmport);\r\ntmport++;\r\noutb((inb(tmport) | 0x20), tmport);\r\nif (atpdev->chip_ver == 4)\r\nshpnt->max_id = 16;\r\nelse\r\nshpnt->max_id = 8;\r\nshpnt->this_id = host_id;\r\nshpnt->unique_id = base_io;\r\nshpnt->io_port = base_io;\r\nshpnt->n_io_port = 0x40;\r\nshpnt->irq = pdev->irq;\r\n}\r\nspin_unlock_irqrestore(shpnt->host_lock, flags);\r\nif(ent->device==ATP885_DEVID) {\r\nif(!request_region(base_io, 0xff, "atp870u"))\r\ngoto request_io_fail;\r\n} else if((ent->device==ATP880_DEVID1)||(ent->device==ATP880_DEVID2)) {\r\nif(!request_region(base_io, 0x60, "atp870u"))\r\ngoto request_io_fail;\r\n} else {\r\nif(!request_region(base_io, 0x40, "atp870u"))\r\ngoto request_io_fail;\r\n}\r\ncount++;\r\nif (scsi_add_host(shpnt, &pdev->dev))\r\ngoto scsi_add_fail;\r\nscsi_scan_host(shpnt);\r\n#ifdef ED_DBGP\r\nprintk("atp870u_prob : exit\n");\r\n#endif\r\nreturn 0;\r\nscsi_add_fail:\r\nprintk("atp870u_prob:scsi_add_fail\n");\r\nif(ent->device==ATP885_DEVID) {\r\nrelease_region(base_io, 0xff);\r\n} else if((ent->device==ATP880_DEVID1)||(ent->device==ATP880_DEVID2)) {\r\nrelease_region(base_io, 0x60);\r\n} else {\r\nrelease_region(base_io, 0x40);\r\n}\r\nrequest_io_fail:\r\nprintk("atp870u_prob:request_io_fail\n");\r\nfree_irq(pdev->irq, shpnt);\r\nfree_tables:\r\nprintk("atp870u_prob:free_table\n");\r\natp870u_free_tables(shpnt);\r\nunregister:\r\nprintk("atp870u_prob:unregister\n");\r\nscsi_host_put(shpnt);\r\nreturn -1;\r\nerr_eio:\r\nkfree(atpdev);\r\nreturn -EIO;\r\nerr_nomem:\r\nkfree(atpdev);\r\nreturn -ENOMEM;\r\n}\r\nstatic int atp870u_abort(struct scsi_cmnd * SCpnt)\r\n{\r\nunsigned char j, k, c;\r\nstruct scsi_cmnd *workrequ;\r\nunsigned int tmport;\r\nstruct atp_unit *dev;\r\nstruct Scsi_Host *host;\r\nhost = SCpnt->device->host;\r\ndev = (struct atp_unit *)&host->hostdata;\r\nc = scmd_channel(SCpnt);\r\nprintk(" atp870u: abort Channel = %x \n", c);\r\nprintk("working=%x last_cmd=%x ", dev->working[c], dev->last_cmd[c]);\r\nprintk(" quhdu=%x quendu=%x ", dev->quhd[c], dev->quend[c]);\r\ntmport = dev->ioport[c];\r\nfor (j = 0; j < 0x18; j++) {\r\nprintk(" r%2x=%2x", j, inb(tmport++));\r\n}\r\ntmport += 0x04;\r\nprintk(" r1c=%2x", inb(tmport));\r\ntmport += 0x03;\r\nprintk(" r1f=%2x in_snd=%2x ", inb(tmport), dev->in_snd[c]);\r\ntmport= dev->pciport[c];\r\nprintk(" d00=%2x", inb(tmport));\r\ntmport += 0x02;\r\nprintk(" d02=%2x", inb(tmport));\r\nfor(j=0;j<16;j++) {\r\nif (dev->id[c][j].curr_req != NULL) {\r\nworkrequ = dev->id[c][j].curr_req;\r\nprintk("\n que cdb= ");\r\nfor (k=0; k < workrequ->cmd_len; k++) {\r\nprintk(" %2x ",workrequ->cmnd[k]);\r\n}\r\nprintk(" last_lenu= %x ",(unsigned int)dev->id[c][j].last_len);\r\n}\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic const char *atp870u_info(struct Scsi_Host *notused)\r\n{\r\nstatic char buffer[128];\r\nstrcpy(buffer, "ACARD AEC-6710/6712/67160 PCI Ultra/W/LVD SCSI-3 Adapter Driver V2.6+ac ");\r\nreturn buffer;\r\n}\r\nstatic int atp870u_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)\r\n{\r\nseq_printf(m, "ACARD AEC-671X Driver Version: 2.6+ac\n");\r\nseq_printf(m, "\n");\r\nseq_printf(m, "Adapter Configuration:\n");\r\nseq_printf(m, " Base IO: %#.4lx\n", HBAptr->io_port);\r\nseq_printf(m, " IRQ: %d\n", HBAptr->irq);\r\nreturn 0;\r\n}\r\nstatic int atp870u_biosparam(struct scsi_device *disk, struct block_device *dev,\r\nsector_t capacity, int *ip)\r\n{\r\nint heads, sectors, cylinders;\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = (unsigned long)capacity / (heads * sectors);\r\nif (cylinders > 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = (unsigned long)capacity / (heads * sectors);\r\n}\r\nip[0] = heads;\r\nip[1] = sectors;\r\nip[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic void atp870u_remove (struct pci_dev *pdev)\r\n{\r\nstruct atp_unit *devext = pci_get_drvdata(pdev);\r\nstruct Scsi_Host *pshost = devext->host;\r\nscsi_remove_host(pshost);\r\nprintk(KERN_INFO "free_irq : %d\n",pshost->irq);\r\nfree_irq(pshost->irq, pshost);\r\nrelease_region(pshost->io_port, pshost->n_io_port);\r\nprintk(KERN_INFO "atp870u_free_tables : %p\n",pshost);\r\natp870u_free_tables(pshost);\r\nprintk(KERN_INFO "scsi_host_put : %p\n",pshost);\r\nscsi_host_put(pshost);\r\nprintk(KERN_INFO "pci_set_drvdata : %p\n",pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init atp870u_init(void)\r\n{\r\n#ifdef ED_DBGP\r\nprintk("atp870u_init: Entry\n");\r\n#endif\r\nreturn pci_register_driver(&atp870u_driver);\r\n}\r\nstatic void __exit atp870u_exit(void)\r\n{\r\n#ifdef ED_DBGP\r\nprintk("atp870u_exit: Entry\n");\r\n#endif\r\npci_unregister_driver(&atp870u_driver);\r\n}\r\nstatic void tscam_885(void)\r\n{\r\nunsigned char i;\r\nfor (i = 0; i < 0x2; i++) {\r\nmdelay(300);\r\n}\r\nreturn;\r\n}\r\nstatic void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)\r\n{\r\nunsigned int tmport;\r\nunsigned char i, j, k, rmb, n, lvdmode;\r\nunsigned short int m;\r\nstatic unsigned char mbuf[512];\r\nstatic unsigned char satn[9] = {0, 0, 0, 0, 0, 0, 0, 6, 6};\r\nstatic unsigned char inqd[9] = {0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6};\r\nstatic unsigned char synn[6] = {0x80, 1, 3, 1, 0x19, 0x0e};\r\nunsigned char synu[6] = {0x80, 1, 3, 1, 0x0a, 0x0e};\r\nstatic unsigned char synw[6] = {0x80, 1, 3, 1, 0x19, 0x0e};\r\nunsigned char synuw[6] = {0x80, 1, 3, 1, 0x0a, 0x0e};\r\nstatic unsigned char wide[6] = {0x80, 1, 2, 3, 1, 0};\r\nstatic unsigned char u3[9] = { 0x80,1,6,4,0x09,00,0x0e,0x01,0x02 };\r\nlvdmode=inb(wkport + 0x1b) >> 7;\r\nfor (i = 0; i < 16; i++) {\r\nm = 1;\r\nm = m << i;\r\nif ((m & dev->active_id[c]) != 0) {\r\ncontinue;\r\n}\r\nif (i == dev->host_id[c]) {\r\nprintk(KERN_INFO " ID: %2d Host Adapter\n", dev->host_id[c]);\r\ncontinue;\r\n}\r\ntmport = wkport + 0x1b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 0x01;\r\noutb(0x08, tmport++);\r\noutb(0x7f, tmport++);\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[c][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\nj = i;\r\nif ((j & 0x08) != 0) {\r\nj = (j & 0x07) | 0x40;\r\n}\r\noutb(j, tmport);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {\r\ncontinue;\r\n}\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ndev->active_id[c] |= m;\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x14;\r\noutb(0x00, tmport);\r\nphase_cmd:\r\ntmport = wkport + 0x18;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\ntmport = wkport + 0x10;\r\noutb(0x41, tmport);\r\ngoto phase_cmd;\r\n}\r\nsel_ok:\r\ntmport = wkport + 0x03;\r\noutb(inqd[0], tmport++);\r\noutb(inqd[1], tmport++);\r\noutb(inqd[2], tmport++);\r\noutb(inqd[3], tmport++);\r\noutb(inqd[4], tmport++);\r\noutb(inqd[5], tmport);\r\ntmport += 0x07;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[c][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(inqd[6], tmport++);\r\noutb(inqd[7], tmport++);\r\ntmport += 0x03;\r\noutb(inqd[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {\r\ncontinue;\r\n}\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntmport = wkport + 0x1b;\r\noutb(0x00, tmport);\r\ntmport = wkport + 0x18;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nj = 0;\r\nrd_inq_data:\r\nk = inb(tmport);\r\nif ((k & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[j++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto rd_inq_data;\r\n}\r\nif ((k & 0x80) == 0) {\r\ngoto rd_inq_data;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j == 0x16) {\r\ngoto inq_ok;\r\n}\r\ntmport = wkport + 0x10;\r\noutb(0x46, tmport);\r\ntmport += 0x02;\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\noutb(0, tmport++);\r\ntmport += 0x03;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif (inb(tmport) != 0x16) {\r\ngoto sel_ok;\r\n}\r\ninq_ok:\r\nmbuf[36] = 0;\r\nprintk( KERN_INFO" ID: %2d %s\n", i, &mbuf[8]);\r\ndev->id[c][i].devtype = mbuf[0];\r\nrmb = mbuf[1];\r\nn = mbuf[7];\r\nif ((mbuf[7] & 0x60) == 0) {\r\ngoto not_wide;\r\n}\r\nif ((i < 8) && ((dev->global_map[c] & 0x20) == 0)) {\r\ngoto not_wide;\r\n}\r\nif (lvdmode == 0) {\r\ngoto chg_wide;\r\n}\r\nif (dev->sp[c][i] != 0x04) {\r\ngoto chg_wide;\r\n}\r\ntmport = wkport + 0x1b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 0x03;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[c][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {\r\ncontinue;\r\n}\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_u3:\r\nj = 0;\r\ntmport = wkport + 0x14;\r\noutb(0x09, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(u3[j++], tmport);\r\ntmport += 0x06;\r\n}\r\ncpu_relax();\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_u3;\r\n}\r\ncontinue;\r\nu3p_out:\r\ntmport = wkport + 0x18;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(0, tmport);\r\ntmport += 0x06;\r\n}\r\ncpu_relax();\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\nu3p_in:\r\ntmport = wkport + 0x14;\r\noutb(0x09, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nu3p_in1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto u3p_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto u3p_in1;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\nu3p_cmd:\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x14;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00);\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[1] != 0x06) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[2] != 0x04) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[3] == 0x09) {\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[c] |= m;\r\ndev->id[c][i].devsp = 0xce;\r\n#ifdef ED_DBGP\r\nprintk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);\r\n#endif\r\ncontinue;\r\n}\r\nchg_wide:\r\ntmport = wkport + 0x1b;\r\noutb(0x01, tmport);\r\ntmport = wkport + 0x03;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[c][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {\r\ncontinue;\r\n}\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_wide:\r\nj = 0;\r\ntmport = wkport + 0x14;\r\noutb(0x05, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(wide[j++], tmport);\r\ntmport += 0x06;\r\n}\r\ncpu_relax();\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_wide;\r\n}\r\ncontinue;\r\nwidep_out:\r\ntmport = wkport + 0x18;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\noutb(0, tmport);\r\ntmport += 0x06;\r\n}\r\ncpu_relax();\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_in:\r\ntmport = wkport + 0x14;\r\noutb(0xff, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nwidep_in1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto widep_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto widep_in1;\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_cmd:\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntmport = wkport + 0x14;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[1] != 0x02) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[2] != 0x03) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[3] != 0x01) {\r\ngoto not_wide;\r\n}\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[c] |= m;\r\nnot_wide:\r\nif ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) ||\r\n((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {\r\nm = 1;\r\nm = m << i;\r\nif ((dev->async[c] & m) != 0) {\r\ngoto set_sync;\r\n}\r\n}\r\ncontinue;\r\nset_sync:\r\nif (dev->sp[c][i] == 0x02) {\r\nsynu[4]=0x0c;\r\nsynuw[4]=0x0c;\r\n} else {\r\nif (dev->sp[c][i] >= 0x03) {\r\nsynu[4]=0x0a;\r\nsynuw[4]=0x0a;\r\n}\r\n}\r\ntmport = wkport + 0x1b;\r\nj = 0;\r\nif ((m & dev->wide_id[c]) != 0) {\r\nj |= 0x01;\r\n}\r\noutb(j, tmport);\r\ntmport = wkport + 0x03;\r\noutb(satn[0], tmport++);\r\noutb(satn[1], tmport++);\r\noutb(satn[2], tmport++);\r\noutb(satn[3], tmport++);\r\noutb(satn[4], tmport++);\r\noutb(satn[5], tmport++);\r\ntmport += 0x06;\r\noutb(0, tmport);\r\ntmport += 0x02;\r\noutb(dev->id[c][i].devsp, tmport++);\r\noutb(0, tmport++);\r\noutb(satn[6], tmport++);\r\noutb(satn[7], tmport++);\r\ntmport += 0x03;\r\noutb(satn[8], tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nif ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {\r\ncontinue;\r\n}\r\nwhile (inb(tmport) != 0x8e)\r\ncpu_relax();\r\ntry_sync:\r\nj = 0;\r\ntmport = wkport + 0x14;\r\noutb(0x06, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0) {\r\nif ((inb(tmport) & 0x01) != 0) {\r\ntmport -= 0x06;\r\nif ((m & dev->wide_id[c]) != 0) {\r\nif ((m & dev->ultra_map[c]) != 0) {\r\noutb(synuw[j++], tmport);\r\n} else {\r\noutb(synw[j++], tmport);\r\n}\r\n} else {\r\nif ((m & dev->ultra_map[c]) != 0) {\r\noutb(synu[j++], tmport);\r\n} else {\r\noutb(synn[j++], tmport);\r\n}\r\n}\r\ntmport += 0x06;\r\n}\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = inb(tmport) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_sync;\r\n}\r\ncontinue;\r\nphase_outs:\r\ntmport = wkport + 0x18;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00) {\r\nif ((inb(tmport) & 0x01) != 0x00) {\r\ntmport -= 0x06;\r\noutb(0x00, tmport);\r\ntmport += 0x06;\r\n}\r\ncpu_relax();\r\n}\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_ins:\r\ntmport = wkport + 0x14;\r\noutb(0x06, tmport);\r\ntmport += 0x04;\r\noutb(0x20, tmport);\r\ntmport += 0x07;\r\nk = 0;\r\nphase_ins1:\r\nj = inb(tmport);\r\nif ((j & 0x01) != 0x00) {\r\ntmport -= 0x06;\r\nmbuf[k++] = inb(tmport);\r\ntmport += 0x06;\r\ngoto phase_ins1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto phase_ins1;\r\n}\r\ntmport -= 0x08;\r\nwhile ((inb(tmport) & 0x80) == 0x00);\r\nj = inb(tmport);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_cmds:\r\ntmport = wkport + 0x10;\r\noutb(0x30, tmport);\r\ntar_dcons:\r\ntmport = wkport + 0x14;\r\noutb(0x00, tmport);\r\ntmport += 0x04;\r\noutb(0x08, tmport);\r\ntmport += 0x07;\r\nwhile ((inb(tmport) & 0x80) == 0x00)\r\ncpu_relax();\r\ntmport -= 0x08;\r\nj = inb(tmport);\r\nif (j != 0x16) {\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ncontinue;\r\n}\r\nif (mbuf[1] != 0x03) {\r\ncontinue;\r\n}\r\nif (mbuf[4] == 0x00) {\r\ncontinue;\r\n}\r\nif (mbuf[3] > 0x64) {\r\ncontinue;\r\n}\r\nif (mbuf[4] > 0x0e) {\r\nmbuf[4] = 0x0e;\r\n}\r\ndev->id[c][i].devsp = mbuf[4];\r\nif (mbuf[3] < 0x0c){\r\nj = 0xb0;\r\ngoto set_syn_ok;\r\n}\r\nif ((mbuf[3] < 0x0d) && (rmb == 0)) {\r\nj = 0xa0;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x1a) {\r\nj = 0x20;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x33) {\r\nj = 0x40;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x4c) {\r\nj = 0x50;\r\ngoto set_syn_ok;\r\n}\r\nj = 0x60;\r\nset_syn_ok:\r\ndev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;\r\n#ifdef ED_DBGP\r\nprintk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);\r\n#endif\r\n}\r\ntmport = wkport + 0x16;\r\noutb(0x80, tmport);\r\n}
