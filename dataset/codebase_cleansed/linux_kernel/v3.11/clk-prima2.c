static inline unsigned long clkc_readl(unsigned reg)\r\n{\r\nreturn readl(sirfsoc_clk_vbase + reg);\r\n}\r\nstatic inline void clkc_writel(u32 val, unsigned reg)\r\n{\r\nwritel(val, sirfsoc_clk_vbase + reg);\r\n}\r\nstatic unsigned long pll_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long fin = parent_rate;\r\nstruct clk_pll *clk = to_pllclk(hw);\r\nu32 regcfg2 = clk->regofs + SIRFSOC_CLKC_PLL1_CFG2 -\r\nSIRFSOC_CLKC_PLL1_CFG0;\r\nif (clkc_readl(regcfg2) & BIT(2)) {\r\nreturn fin;\r\n} else {\r\nu32 cfg0 = clkc_readl(clk->regofs);\r\nu32 nf = (cfg0 & (BIT(13) - 1)) + 1;\r\nu32 nr = ((cfg0 >> 13) & (BIT(6) - 1)) + 1;\r\nu32 od = ((cfg0 >> 19) & (BIT(4) - 1)) + 1;\r\nWARN_ON(fin % MHZ);\r\nreturn fin / MHZ * nf / nr / od * MHZ;\r\n}\r\n}\r\nstatic long pll_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long fin, nf, nr, od;\r\nrate = rate - rate % MHZ;\r\nnf = rate / MHZ;\r\nif (nf > BIT(13))\r\nnf = BIT(13);\r\nif (nf < 1)\r\nnf = 1;\r\nfin = *parent_rate;\r\nnr = fin / MHZ;\r\nif (nr > BIT(6))\r\nnr = BIT(6);\r\nod = 1;\r\nreturn fin * nf / (nr * od);\r\n}\r\nstatic int pll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pll *clk = to_pllclk(hw);\r\nunsigned long fin, nf, nr, od, reg;\r\nnf = rate / MHZ;\r\nif (unlikely((rate % MHZ) || nf > BIT(13) || nf < 1))\r\nreturn -EINVAL;\r\nfin = parent_rate;\r\nBUG_ON(fin < MHZ);\r\nnr = fin / MHZ;\r\nBUG_ON((fin % MHZ) || nr > BIT(6));\r\nod = 1;\r\nreg = (nf - 1) | ((nr - 1) << 13) | ((od - 1) << 19);\r\nclkc_writel(reg, clk->regofs);\r\nreg = clk->regofs + SIRFSOC_CLKC_PLL1_CFG1 - SIRFSOC_CLKC_PLL1_CFG0;\r\nclkc_writel((nf >> 1) - 1, reg);\r\nreg = clk->regofs + SIRFSOC_CLKC_PLL1_CFG2 - SIRFSOC_CLKC_PLL1_CFG0;\r\nwhile (!(clkc_readl(reg) & BIT(6)))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int usb_pll_clk_enable(struct clk_hw *hw)\r\n{\r\nu32 reg = readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nreg &= ~(SIRFSOC_USBPHY_PLL_POWERDOWN | SIRFSOC_USBPHY_PLL_BYPASS);\r\nwritel(reg, sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nwhile (!(readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL) &\r\nSIRFSOC_USBPHY_PLL_LOCK))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void usb_pll_clk_disable(struct clk_hw *clk)\r\n{\r\nu32 reg = readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nreg |= (SIRFSOC_USBPHY_PLL_POWERDOWN | SIRFSOC_USBPHY_PLL_BYPASS);\r\nwritel(reg, sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\n}\r\nstatic unsigned long usb_pll_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nu32 reg = readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nreturn (reg & SIRFSOC_USBPHY_PLL_BYPASS) ? parent_rate : 48*MHZ;\r\n}\r\nstatic u8 dmn_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nu32 cfg = clkc_readl(clk->regofs);\r\nif (strcmp(hw->init->name, "io") == 0)\r\nreturn 4;\r\nWARN_ON((cfg & (BIT(3) - 1)) > 4);\r\nreturn cfg & (BIT(3) - 1);\r\n}\r\nstatic int dmn_clk_set_parent(struct clk_hw *hw, u8 parent)\r\n{\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nu32 cfg = clkc_readl(clk->regofs);\r\nif (strcmp(hw->init->name, "io") == 0)\r\nreturn -EINVAL;\r\ncfg &= ~(BIT(3) - 1);\r\nclkc_writel(cfg | parent, clk->regofs);\r\nwhile (clkc_readl(clk->regofs) & BIT(3))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic unsigned long dmn_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long fin = parent_rate;\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nu32 cfg = clkc_readl(clk->regofs);\r\nif (cfg & BIT(24)) {\r\nreturn fin;\r\n} else {\r\nu32 wait = (cfg >> 16) & (BIT(4) - 1);\r\nu32 hold = (cfg >> 20) & (BIT(4) - 1);\r\nreturn fin / (wait + hold + 2);\r\n}\r\n}\r\nstatic long dmn_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long fin;\r\nunsigned ratio, wait, hold;\r\nunsigned bits = (strcmp(hw->init->name, "mem") == 0) ? 3 : 4;\r\nfin = *parent_rate;\r\nratio = fin / rate;\r\nif (ratio < 2)\r\nratio = 2;\r\nif (ratio > BIT(bits + 1))\r\nratio = BIT(bits + 1);\r\nwait = (ratio >> 1) - 1;\r\nhold = ratio - wait - 2;\r\nreturn fin / (wait + hold + 2);\r\n}\r\nstatic int dmn_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nunsigned long fin;\r\nunsigned ratio, wait, hold, reg;\r\nunsigned bits = (strcmp(hw->init->name, "mem") == 0) ? 3 : 4;\r\nfin = parent_rate;\r\nratio = fin / rate;\r\nif (unlikely(ratio < 2 || ratio > BIT(bits + 1)))\r\nreturn -EINVAL;\r\nWARN_ON(fin % rate);\r\nwait = (ratio >> 1) - 1;\r\nhold = ratio - wait - 2;\r\nreg = clkc_readl(clk->regofs);\r\nreg &= ~(((BIT(bits) - 1) << 16) | ((BIT(bits) - 1) << 20));\r\nreg |= (wait << 16) | (hold << 20) | BIT(25);\r\nclkc_writel(reg, clk->regofs);\r\nwhile (clkc_readl(clk->regofs) & BIT(25))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int std_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nu32 reg;\r\nint bit;\r\nstruct clk_std *clk = to_stdclk(hw);\r\nbit = clk->enable_bit % 32;\r\nreg = clk->enable_bit / 32;\r\nreg = SIRFSOC_CLKC_CLK_EN0 + reg * sizeof(reg);\r\nreturn !!(clkc_readl(reg) & BIT(bit));\r\n}\r\nstatic int std_clk_enable(struct clk_hw *hw)\r\n{\r\nu32 val, reg;\r\nint bit;\r\nstruct clk_std *clk = to_stdclk(hw);\r\nBUG_ON(clk->enable_bit < 0 || clk->enable_bit > 63);\r\nbit = clk->enable_bit % 32;\r\nreg = clk->enable_bit / 32;\r\nreg = SIRFSOC_CLKC_CLK_EN0 + reg * sizeof(reg);\r\nval = clkc_readl(reg) | BIT(bit);\r\nclkc_writel(val, reg);\r\nreturn 0;\r\n}\r\nstatic void std_clk_disable(struct clk_hw *hw)\r\n{\r\nu32 val, reg;\r\nint bit;\r\nstruct clk_std *clk = to_stdclk(hw);\r\nBUG_ON(clk->enable_bit < 0 || clk->enable_bit > 63);\r\nbit = clk->enable_bit % 32;\r\nreg = clk->enable_bit / 32;\r\nreg = SIRFSOC_CLKC_CLK_EN0 + reg * sizeof(reg);\r\nval = clkc_readl(reg) & ~BIT(bit);\r\nclkc_writel(val, reg);\r\n}\r\nvoid __init sirfsoc_of_clk_init(void)\r\n{\r\nstruct device_node *np;\r\nint i;\r\nnp = of_find_matching_node(NULL, rsc_ids);\r\nif (!np)\r\npanic("unable to find compatible rsc node in dtb\n");\r\nsirfsoc_rsc_vbase = of_iomap(np, 0);\r\nif (!sirfsoc_rsc_vbase)\r\npanic("unable to map rsc registers\n");\r\nof_node_put(np);\r\nnp = of_find_matching_node(NULL, clkc_ids);\r\nif (!np)\r\nreturn;\r\nsirfsoc_clk_vbase = of_iomap(np, 0);\r\nif (!sirfsoc_clk_vbase)\r\npanic("unable to map clkc registers\n");\r\nprima2_clks[rtc] = clk_register_fixed_rate(NULL, "rtc", NULL,\r\nCLK_IS_ROOT, 32768);\r\nprima2_clks[osc]= clk_register_fixed_rate(NULL, "osc", NULL,\r\nCLK_IS_ROOT, 26000000);\r\nfor (i = pll1; i < maxclk; i++) {\r\nprima2_clks[i] = clk_register(NULL, prima2_clk_hw_array[i]);\r\nBUG_ON(IS_ERR(prima2_clks[i]));\r\n}\r\nclk_register_clkdev(prima2_clks[cpu], NULL, "cpu");\r\nclk_register_clkdev(prima2_clks[io], NULL, "io");\r\nclk_register_clkdev(prima2_clks[mem], NULL, "mem");\r\nclk_data.clks = prima2_clks;\r\nclk_data.clk_num = maxclk;\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\r\n}
