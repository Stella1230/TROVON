static inline int mac802154_fetch_skb_u8(struct sk_buff *skb, u8 *val)\r\n{\r\nif (unlikely(!pskb_may_pull(skb, 1)))\r\nreturn -EINVAL;\r\n*val = skb->data[0];\r\nskb_pull(skb, 1);\r\nreturn 0;\r\n}\r\nstatic inline int mac802154_fetch_skb_u16(struct sk_buff *skb, u16 *val)\r\n{\r\nif (unlikely(!pskb_may_pull(skb, 2)))\r\nreturn -EINVAL;\r\n*val = skb->data[0] | (skb->data[1] << 8);\r\nskb_pull(skb, 2);\r\nreturn 0;\r\n}\r\nstatic inline void mac802154_haddr_copy_swap(u8 *dest, const u8 *src)\r\n{\r\nint i;\r\nfor (i = 0; i < IEEE802154_ADDR_LEN; i++)\r\ndest[IEEE802154_ADDR_LEN - i - 1] = src[i];\r\n}\r\nstatic int\r\nmac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct mac802154_sub_if_data *priv = netdev_priv(dev);\r\nstruct sockaddr_ieee802154 *sa =\r\n(struct sockaddr_ieee802154 *)&ifr->ifr_addr;\r\nint err = -ENOIOCTLCMD;\r\nspin_lock_bh(&priv->mib_lock);\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\nif (priv->pan_id == IEEE802154_PANID_BROADCAST ||\r\npriv->short_addr == IEEE802154_ADDR_BROADCAST) {\r\nerr = -EADDRNOTAVAIL;\r\nbreak;\r\n}\r\nsa->family = AF_IEEE802154;\r\nsa->addr.addr_type = IEEE802154_ADDR_SHORT;\r\nsa->addr.pan_id = priv->pan_id;\r\nsa->addr.short_addr = priv->short_addr;\r\nerr = 0;\r\nbreak;\r\ncase SIOCSIFADDR:\r\ndev_warn(&dev->dev,\r\n"Using DEBUGing ioctl SIOCSIFADDR isn't recommened!\n");\r\nif (sa->family != AF_IEEE802154 ||\r\nsa->addr.addr_type != IEEE802154_ADDR_SHORT ||\r\nsa->addr.pan_id == IEEE802154_PANID_BROADCAST ||\r\nsa->addr.short_addr == IEEE802154_ADDR_BROADCAST ||\r\nsa->addr.short_addr == IEEE802154_ADDR_UNDEF) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\npriv->pan_id = sa->addr.pan_id;\r\npriv->short_addr = sa->addr.short_addr;\r\nerr = 0;\r\nbreak;\r\n}\r\nspin_unlock_bh(&priv->mib_lock);\r\nreturn err;\r\n}\r\nstatic int mac802154_wpan_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nmac802154_dev_set_ieee_addr(dev);\r\nreturn 0;\r\n}\r\nstatic int mac802154_header_create(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nunsigned short type,\r\nconst void *_daddr,\r\nconst void *_saddr,\r\nunsigned len)\r\n{\r\nconst struct ieee802154_addr *saddr = _saddr;\r\nconst struct ieee802154_addr *daddr = _daddr;\r\nstruct ieee802154_addr dev_addr;\r\nstruct mac802154_sub_if_data *priv = netdev_priv(dev);\r\nint pos = 2;\r\nu8 head[MAC802154_FRAME_HARD_HEADER_LEN];\r\nu16 fc;\r\nif (!daddr)\r\nreturn -EINVAL;\r\nhead[pos++] = mac_cb(skb)->seq;\r\nfc = mac_cb_type(skb);\r\nif (mac_cb_is_ackreq(skb))\r\nfc |= IEEE802154_FC_ACK_REQ;\r\nif (!saddr) {\r\nspin_lock_bh(&priv->mib_lock);\r\nif (priv->short_addr == IEEE802154_ADDR_BROADCAST ||\r\npriv->short_addr == IEEE802154_ADDR_UNDEF ||\r\npriv->pan_id == IEEE802154_PANID_BROADCAST) {\r\ndev_addr.addr_type = IEEE802154_ADDR_LONG;\r\nmemcpy(dev_addr.hwaddr, dev->dev_addr,\r\nIEEE802154_ADDR_LEN);\r\n} else {\r\ndev_addr.addr_type = IEEE802154_ADDR_SHORT;\r\ndev_addr.short_addr = priv->short_addr;\r\n}\r\ndev_addr.pan_id = priv->pan_id;\r\nsaddr = &dev_addr;\r\nspin_unlock_bh(&priv->mib_lock);\r\n}\r\nif (daddr->addr_type != IEEE802154_ADDR_NONE) {\r\nfc |= (daddr->addr_type << IEEE802154_FC_DAMODE_SHIFT);\r\nhead[pos++] = daddr->pan_id & 0xff;\r\nhead[pos++] = daddr->pan_id >> 8;\r\nif (daddr->addr_type == IEEE802154_ADDR_SHORT) {\r\nhead[pos++] = daddr->short_addr & 0xff;\r\nhead[pos++] = daddr->short_addr >> 8;\r\n} else {\r\nmac802154_haddr_copy_swap(head + pos, daddr->hwaddr);\r\npos += IEEE802154_ADDR_LEN;\r\n}\r\n}\r\nif (saddr->addr_type != IEEE802154_ADDR_NONE) {\r\nfc |= (saddr->addr_type << IEEE802154_FC_SAMODE_SHIFT);\r\nif ((saddr->pan_id == daddr->pan_id) &&\r\n(saddr->pan_id != IEEE802154_PANID_BROADCAST)) {\r\nfc |= IEEE802154_FC_INTRA_PAN;\r\n} else {\r\nhead[pos++] = saddr->pan_id & 0xff;\r\nhead[pos++] = saddr->pan_id >> 8;\r\n}\r\nif (saddr->addr_type == IEEE802154_ADDR_SHORT) {\r\nhead[pos++] = saddr->short_addr & 0xff;\r\nhead[pos++] = saddr->short_addr >> 8;\r\n} else {\r\nmac802154_haddr_copy_swap(head + pos, saddr->hwaddr);\r\npos += IEEE802154_ADDR_LEN;\r\n}\r\n}\r\nhead[0] = fc;\r\nhead[1] = fc >> 8;\r\nmemcpy(skb_push(skb, pos), head, pos);\r\nreturn pos;\r\n}\r\nstatic int\r\nmac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst u8 *hdr = skb_mac_header(skb);\r\nconst u8 *tail = skb_tail_pointer(skb);\r\nstruct ieee802154_addr *addr = (struct ieee802154_addr *)haddr;\r\nu16 fc;\r\nint da_type;\r\nif (hdr + 3 > tail)\r\ngoto malformed;\r\nfc = hdr[0] | (hdr[1] << 8);\r\nhdr += 3;\r\nda_type = IEEE802154_FC_DAMODE(fc);\r\naddr->addr_type = IEEE802154_FC_SAMODE(fc);\r\nswitch (da_type) {\r\ncase IEEE802154_ADDR_NONE:\r\nif (fc & IEEE802154_FC_INTRA_PAN)\r\ngoto malformed;\r\nbreak;\r\ncase IEEE802154_ADDR_LONG:\r\nif (fc & IEEE802154_FC_INTRA_PAN) {\r\nif (hdr + 2 > tail)\r\ngoto malformed;\r\naddr->pan_id = hdr[0] | (hdr[1] << 8);\r\nhdr += 2;\r\n}\r\nif (hdr + IEEE802154_ADDR_LEN > tail)\r\ngoto malformed;\r\nhdr += IEEE802154_ADDR_LEN;\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nif (fc & IEEE802154_FC_INTRA_PAN) {\r\nif (hdr + 2 > tail)\r\ngoto malformed;\r\naddr->pan_id = hdr[0] | (hdr[1] << 8);\r\nhdr += 2;\r\n}\r\nif (hdr + 2 > tail)\r\ngoto malformed;\r\nhdr += 2;\r\nbreak;\r\ndefault:\r\ngoto malformed;\r\n}\r\nswitch (addr->addr_type) {\r\ncase IEEE802154_ADDR_NONE:\r\nbreak;\r\ncase IEEE802154_ADDR_LONG:\r\nif (!(fc & IEEE802154_FC_INTRA_PAN)) {\r\nif (hdr + 2 > tail)\r\ngoto malformed;\r\naddr->pan_id = hdr[0] | (hdr[1] << 8);\r\nhdr += 2;\r\n}\r\nif (hdr + IEEE802154_ADDR_LEN > tail)\r\ngoto malformed;\r\nmac802154_haddr_copy_swap(addr->hwaddr, hdr);\r\nhdr += IEEE802154_ADDR_LEN;\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nif (!(fc & IEEE802154_FC_INTRA_PAN)) {\r\nif (hdr + 2 > tail)\r\ngoto malformed;\r\naddr->pan_id = hdr[0] | (hdr[1] << 8);\r\nhdr += 2;\r\n}\r\nif (hdr + 2 > tail)\r\ngoto malformed;\r\naddr->short_addr = hdr[0] | (hdr[1] << 8);\r\nhdr += 2;\r\nbreak;\r\ndefault:\r\ngoto malformed;\r\n}\r\nreturn sizeof(struct ieee802154_addr);\r\nmalformed:\r\npr_debug("malformed packet\n");\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t\r\nmac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv;\r\nu8 chan, page;\r\npriv = netdev_priv(dev);\r\nspin_lock_bh(&priv->mib_lock);\r\nchan = priv->chan;\r\npage = priv->page;\r\nspin_unlock_bh(&priv->mib_lock);\r\nif (chan == MAC802154_CHAN_NONE ||\r\npage >= WPAN_NUM_PAGES ||\r\nchan >= WPAN_NUM_CHANNELS) {\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb->skb_iif = dev->ifindex;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nreturn mac802154_tx(priv->hw, skb, page, chan);\r\n}\r\nvoid mac802154_wpan_setup(struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv;\r\ndev->addr_len = IEEE802154_ADDR_LEN;\r\nmemset(dev->broadcast, 0xff, IEEE802154_ADDR_LEN);\r\ndev->hard_header_len = MAC802154_FRAME_HARD_HEADER_LEN;\r\ndev->header_ops = &mac802154_header_ops;\r\ndev->needed_tailroom = 2;\r\ndev->mtu = IEEE802154_MTU;\r\ndev->tx_queue_len = 300;\r\ndev->type = ARPHRD_IEEE802154;\r\ndev->flags = IFF_NOARP | IFF_BROADCAST;\r\ndev->watchdog_timeo = 0;\r\ndev->destructor = free_netdev;\r\ndev->netdev_ops = &mac802154_wpan_ops;\r\ndev->ml_priv = &mac802154_mlme_wpan;\r\npriv = netdev_priv(dev);\r\npriv->type = IEEE802154_DEV_WPAN;\r\npriv->chan = MAC802154_CHAN_NONE;\r\npriv->page = 0;\r\nspin_lock_init(&priv->mib_lock);\r\nget_random_bytes(&priv->bsn, 1);\r\nget_random_bytes(&priv->dsn, 1);\r\npriv->pan_id = IEEE802154_PANID_BROADCAST;\r\npriv->short_addr = IEEE802154_ADDR_BROADCAST;\r\n}\r\nstatic int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nreturn netif_rx_ni(skb);\r\n}\r\nstatic int\r\nmac802154_subif_frame(struct mac802154_sub_if_data *sdata, struct sk_buff *skb)\r\n{\r\npr_debug("getting packet via slave interface %s\n", sdata->dev->name);\r\nspin_lock_bh(&sdata->mib_lock);\r\nswitch (mac_cb(skb)->da.addr_type) {\r\ncase IEEE802154_ADDR_NONE:\r\nif (mac_cb(skb)->sa.addr_type != IEEE802154_ADDR_NONE)\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nelse\r\nskb->pkt_type = PACKET_HOST;\r\nbreak;\r\ncase IEEE802154_ADDR_LONG:\r\nif (mac_cb(skb)->da.pan_id != sdata->pan_id &&\r\nmac_cb(skb)->da.pan_id != IEEE802154_PANID_BROADCAST)\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nelse if (!memcmp(mac_cb(skb)->da.hwaddr, sdata->dev->dev_addr,\r\nIEEE802154_ADDR_LEN))\r\nskb->pkt_type = PACKET_HOST;\r\nelse\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nif (mac_cb(skb)->da.pan_id != sdata->pan_id &&\r\nmac_cb(skb)->da.pan_id != IEEE802154_PANID_BROADCAST)\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nelse if (mac_cb(skb)->da.short_addr == sdata->short_addr)\r\nskb->pkt_type = PACKET_HOST;\r\nelse if (mac_cb(skb)->da.short_addr ==\r\nIEEE802154_ADDR_BROADCAST)\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_bh(&sdata->mib_lock);\r\nskb->dev = sdata->dev;\r\nsdata->dev->stats.rx_packets++;\r\nsdata->dev->stats.rx_bytes += skb->len;\r\nswitch (mac_cb_type(skb)) {\r\ncase IEEE802154_FC_TYPE_DATA:\r\nreturn mac802154_process_data(sdata->dev, skb);\r\ndefault:\r\npr_warning("ieee802154: bad frame received (type = %d)\n",\r\nmac_cb_type(skb));\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\n}\r\nstatic int mac802154_parse_frame_start(struct sk_buff *skb)\r\n{\r\nu8 *head = skb->data;\r\nu16 fc;\r\nif (mac802154_fetch_skb_u16(skb, &fc) ||\r\nmac802154_fetch_skb_u8(skb, &(mac_cb(skb)->seq)))\r\ngoto err;\r\npr_debug("fc: %04x dsn: %02x\n", fc, head[2]);\r\nmac_cb(skb)->flags = IEEE802154_FC_TYPE(fc);\r\nmac_cb(skb)->sa.addr_type = IEEE802154_FC_SAMODE(fc);\r\nmac_cb(skb)->da.addr_type = IEEE802154_FC_DAMODE(fc);\r\nif (fc & IEEE802154_FC_INTRA_PAN)\r\nmac_cb(skb)->flags |= MAC_CB_FLAG_INTRAPAN;\r\nif (mac_cb(skb)->da.addr_type != IEEE802154_ADDR_NONE) {\r\nif (mac802154_fetch_skb_u16(skb, &(mac_cb(skb)->da.pan_id)))\r\ngoto err;\r\nif (mac_cb_is_intrapan(skb))\r\nmac_cb(skb)->sa.pan_id = mac_cb(skb)->da.pan_id;\r\npr_debug("dest PAN addr: %04x\n", mac_cb(skb)->da.pan_id);\r\nif (mac_cb(skb)->da.addr_type == IEEE802154_ADDR_SHORT) {\r\nu16 *da = &(mac_cb(skb)->da.short_addr);\r\nif (mac802154_fetch_skb_u16(skb, da))\r\ngoto err;\r\npr_debug("destination address is short: %04x\n",\r\nmac_cb(skb)->da.short_addr);\r\n} else {\r\nif (!pskb_may_pull(skb, IEEE802154_ADDR_LEN))\r\ngoto err;\r\nmac802154_haddr_copy_swap(mac_cb(skb)->da.hwaddr,\r\nskb->data);\r\nskb_pull(skb, IEEE802154_ADDR_LEN);\r\npr_debug("destination address is hardware\n");\r\n}\r\n}\r\nif (mac_cb(skb)->sa.addr_type != IEEE802154_ADDR_NONE) {\r\nif (!(mac_cb_is_intrapan(skb))) {\r\nu16 *sa_pan = &(mac_cb(skb)->sa.pan_id);\r\nif (mac802154_fetch_skb_u16(skb, sa_pan))\r\ngoto err;\r\n}\r\npr_debug("source PAN addr: %04x\n", mac_cb(skb)->da.pan_id);\r\nif (mac_cb(skb)->sa.addr_type == IEEE802154_ADDR_SHORT) {\r\nu16 *sa = &(mac_cb(skb)->sa.short_addr);\r\nif (mac802154_fetch_skb_u16(skb, sa))\r\ngoto err;\r\npr_debug("source address is short: %04x\n",\r\nmac_cb(skb)->sa.short_addr);\r\n} else {\r\nif (!pskb_may_pull(skb, IEEE802154_ADDR_LEN))\r\ngoto err;\r\nmac802154_haddr_copy_swap(mac_cb(skb)->sa.hwaddr,\r\nskb->data);\r\nskb_pull(skb, IEEE802154_ADDR_LEN);\r\npr_debug("source address is hardware\n");\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nvoid mac802154_wpans_rx(struct mac802154_priv *priv, struct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct sk_buff *sskb;\r\nstruct mac802154_sub_if_data *sdata;\r\nret = mac802154_parse_frame_start(skb);\r\nif (ret) {\r\npr_debug("got invalid frame\n");\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sdata, &priv->slaves, list) {\r\nif (sdata->type != IEEE802154_DEV_WPAN)\r\ncontinue;\r\nsskb = skb_clone(skb, GFP_ATOMIC);\r\nif (sskb)\r\nmac802154_subif_frame(sdata, sskb);\r\n}\r\nrcu_read_unlock();\r\n}
