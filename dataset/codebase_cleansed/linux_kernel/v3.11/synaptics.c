static int synaptics_mode_cmd(struct psmouse *psmouse, unsigned char mode)\r\n{\r\nunsigned char param[1];\r\nif (psmouse_sliced_command(psmouse, mode))\r\nreturn -1;\r\nparam[0] = SYN_PS_SET_MODE2;\r\nif (ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint synaptics_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nparam[0] = 0;\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_SETRES);\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO);\r\nif (param[1] != 0x47)\r\nreturn -ENODEV;\r\nif (set_properties) {\r\npsmouse->vendor = "Synaptics";\r\npsmouse->name = "TouchPad";\r\n}\r\nreturn 0;\r\n}\r\nvoid synaptics_reset(struct psmouse *psmouse)\r\n{\r\nsynaptics_mode_cmd(psmouse, 0);\r\n}\r\nstatic int synaptics_invert_y(int y)\r\n{\r\nreturn YMAX_NOMINAL + YMIN_NOMINAL - y;\r\n}\r\nstatic int synaptics_send_cmd(struct psmouse *psmouse, unsigned char c, unsigned char *param)\r\n{\r\nif (psmouse_sliced_command(psmouse, c))\r\nreturn -1;\r\nif (ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int synaptics_model_id(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned char mi[3];\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_MODEL, mi))\r\nreturn -1;\r\npriv->model_id = (mi[0]<<16) | (mi[1]<<8) | mi[2];\r\nreturn 0;\r\n}\r\nstatic int synaptics_board_id(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned char bid[3];\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_MODES, bid))\r\nreturn -1;\r\npriv->board_id = ((bid[0] & 0xfc) << 6) | bid[1];\r\nreturn 0;\r\n}\r\nstatic int synaptics_firmware_id(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned char fwid[3];\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_FIRMWARE_ID, fwid))\r\nreturn -1;\r\npriv->firmware_id = (fwid[0] << 16) | (fwid[1] << 8) | fwid[2];\r\nreturn 0;\r\n}\r\nstatic int synaptics_capability(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned char cap[3];\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_CAPABILITIES, cap))\r\nreturn -1;\r\npriv->capabilities = (cap[0] << 16) | (cap[1] << 8) | cap[2];\r\npriv->ext_cap = priv->ext_cap_0c = 0;\r\nif (SYN_ID_FULL(priv->identity) < 0x705 &&\r\nSYN_CAP_SUBMODEL_ID(priv->capabilities) != 0x47) {\r\nreturn -1;\r\n}\r\nif (!SYN_CAP_EXTENDED(priv->capabilities))\r\npriv->capabilities = 0;\r\nif (SYN_EXT_CAP_REQUESTS(priv->capabilities) >= 1) {\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_EXT_CAPAB, cap)) {\r\npsmouse_warn(psmouse,\r\n"device claims to have extended capabilities, but I'm not able to read them.\n");\r\n} else {\r\npriv->ext_cap = (cap[0] << 16) | (cap[1] << 8) | cap[2];\r\nif (SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap) > 8)\r\npriv->ext_cap &= 0xff0fff;\r\n}\r\n}\r\nif (SYN_EXT_CAP_REQUESTS(priv->capabilities) >= 4) {\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_EXT_CAPAB_0C, cap)) {\r\npsmouse_warn(psmouse,\r\n"device claims to have extended capability 0x0c, but I'm not able to read it.\n");\r\n} else {\r\npriv->ext_cap_0c = (cap[0] << 16) | (cap[1] << 8) | cap[2];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int synaptics_identify(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned char id[3];\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_IDENTIFY, id))\r\nreturn -1;\r\npriv->identity = (id[0]<<16) | (id[1]<<8) | id[2];\r\nif (SYN_ID_IS_SYNAPTICS(priv->identity))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic int synaptics_resolution(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned char resp[3];\r\nif (SYN_ID_MAJOR(priv->identity) < 4)\r\nreturn 0;\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_RESOLUTION, resp) == 0) {\r\nif (resp[0] != 0 && (resp[1] & 0x80) && resp[2] != 0) {\r\npriv->x_res = resp[0];\r\npriv->y_res = resp[2];\r\n}\r\n}\r\nif (SYN_EXT_CAP_REQUESTS(priv->capabilities) >= 5 &&\r\nSYN_CAP_MAX_DIMENSIONS(priv->ext_cap_0c)) {\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_EXT_MAX_COORDS, resp)) {\r\npsmouse_warn(psmouse,\r\n"device claims to have max coordinates query, but I'm not able to read it.\n");\r\n} else {\r\npriv->x_max = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);\r\npriv->y_max = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);\r\n}\r\n}\r\nif (SYN_EXT_CAP_REQUESTS(priv->capabilities) >= 7 &&\r\nSYN_CAP_MIN_DIMENSIONS(priv->ext_cap_0c)) {\r\nif (synaptics_send_cmd(psmouse, SYN_QUE_EXT_MIN_COORDS, resp)) {\r\npsmouse_warn(psmouse,\r\n"device claims to have min coordinates query, but I'm not able to read it.\n");\r\n} else {\r\npriv->x_min = (resp[0] << 5) | ((resp[1] & 0x0f) << 1);\r\npriv->y_min = (resp[2] << 5) | ((resp[1] & 0xf0) >> 3);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int synaptics_query_hardware(struct psmouse *psmouse)\r\n{\r\nif (synaptics_identify(psmouse))\r\nreturn -1;\r\nif (synaptics_model_id(psmouse))\r\nreturn -1;\r\nif (synaptics_firmware_id(psmouse))\r\nreturn -1;\r\nif (synaptics_board_id(psmouse))\r\nreturn -1;\r\nif (synaptics_capability(psmouse))\r\nreturn -1;\r\nif (synaptics_resolution(psmouse))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int synaptics_set_advanced_gesture_mode(struct psmouse *psmouse)\r\n{\r\nstatic unsigned char param = 0xc8;\r\nstruct synaptics_data *priv = psmouse->private;\r\nif (!(SYN_CAP_ADV_GESTURE(priv->ext_cap_0c) ||\r\nSYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)))\r\nreturn 0;\r\nif (psmouse_sliced_command(psmouse, SYN_QUE_MODEL))\r\nreturn -1;\r\nif (ps2_command(&psmouse->ps2dev, &param, PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\npriv->capabilities |= BIT(1);\r\nreturn 0;\r\n}\r\nstatic int synaptics_set_mode(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\npriv->mode = 0;\r\nif (priv->absolute_mode)\r\npriv->mode |= SYN_BIT_ABSOLUTE_MODE;\r\nif (priv->disable_gesture)\r\npriv->mode |= SYN_BIT_DISABLE_GESTURE;\r\nif (psmouse->rate >= 80)\r\npriv->mode |= SYN_BIT_HIGH_RATE;\r\nif (SYN_CAP_EXTENDED(priv->capabilities))\r\npriv->mode |= SYN_BIT_W_MODE;\r\nif (synaptics_mode_cmd(psmouse, priv->mode))\r\nreturn -1;\r\nif (priv->absolute_mode &&\r\nsynaptics_set_advanced_gesture_mode(psmouse)) {\r\npsmouse_err(psmouse, "Advanced gesture mode init failed.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void synaptics_set_rate(struct psmouse *psmouse, unsigned int rate)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nif (rate >= 80) {\r\npriv->mode |= SYN_BIT_HIGH_RATE;\r\npsmouse->rate = 80;\r\n} else {\r\npriv->mode &= ~SYN_BIT_HIGH_RATE;\r\npsmouse->rate = 40;\r\n}\r\nsynaptics_mode_cmd(psmouse, priv->mode);\r\n}\r\nstatic int synaptics_pt_write(struct serio *serio, unsigned char c)\r\n{\r\nstruct psmouse *parent = serio_get_drvdata(serio->parent);\r\nchar rate_param = SYN_PS_CLIENT_CMD;\r\nif (psmouse_sliced_command(parent, c))\r\nreturn -1;\r\nif (ps2_command(&parent->ps2dev, &rate_param, PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int synaptics_pt_start(struct serio *serio)\r\n{\r\nstruct psmouse *parent = serio_get_drvdata(serio->parent);\r\nstruct synaptics_data *priv = parent->private;\r\nserio_pause_rx(parent->ps2dev.serio);\r\npriv->pt_port = serio;\r\nserio_continue_rx(parent->ps2dev.serio);\r\nreturn 0;\r\n}\r\nstatic void synaptics_pt_stop(struct serio *serio)\r\n{\r\nstruct psmouse *parent = serio_get_drvdata(serio->parent);\r\nstruct synaptics_data *priv = parent->private;\r\nserio_pause_rx(parent->ps2dev.serio);\r\npriv->pt_port = NULL;\r\nserio_continue_rx(parent->ps2dev.serio);\r\n}\r\nstatic int synaptics_is_pt_packet(unsigned char *buf)\r\n{\r\nreturn (buf[0] & 0xFC) == 0x84 && (buf[3] & 0xCC) == 0xC4;\r\n}\r\nstatic void synaptics_pass_pt_packet(struct serio *ptport, unsigned char *packet)\r\n{\r\nstruct psmouse *child = serio_get_drvdata(ptport);\r\nif (child && child->state == PSMOUSE_ACTIVATED) {\r\nserio_interrupt(ptport, packet[1], 0);\r\nserio_interrupt(ptport, packet[4], 0);\r\nserio_interrupt(ptport, packet[5], 0);\r\nif (child->pktsize == 4)\r\nserio_interrupt(ptport, packet[2], 0);\r\n} else\r\nserio_interrupt(ptport, packet[1], 0);\r\n}\r\nstatic void synaptics_pt_activate(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nstruct psmouse *child = serio_get_drvdata(priv->pt_port);\r\nif (child) {\r\nif (child->pktsize == 4)\r\npriv->mode |= SYN_BIT_FOUR_BYTE_CLIENT;\r\nelse\r\npriv->mode &= ~SYN_BIT_FOUR_BYTE_CLIENT;\r\nif (synaptics_mode_cmd(psmouse, priv->mode))\r\npsmouse_warn(psmouse,\r\n"failed to switch guest protocol\n");\r\n}\r\n}\r\nstatic void synaptics_pt_create(struct psmouse *psmouse)\r\n{\r\nstruct serio *serio;\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!serio) {\r\npsmouse_err(psmouse,\r\n"not enough memory for pass-through port\n");\r\nreturn;\r\n}\r\nserio->id.type = SERIO_PS_PSTHRU;\r\nstrlcpy(serio->name, "Synaptics pass-through", sizeof(serio->name));\r\nstrlcpy(serio->phys, "synaptics-pt/serio0", sizeof(serio->name));\r\nserio->write = synaptics_pt_write;\r\nserio->start = synaptics_pt_start;\r\nserio->stop = synaptics_pt_stop;\r\nserio->parent = psmouse->ps2dev.serio;\r\npsmouse->pt_activate = synaptics_pt_activate;\r\npsmouse_info(psmouse, "serio: %s port at %s\n",\r\nserio->name, psmouse->phys);\r\nserio_register_port(serio);\r\n}\r\nstatic void synaptics_mt_state_set(struct synaptics_mt_state *state, int count,\r\nint sgm, int agm)\r\n{\r\nstate->count = count;\r\nstate->sgm = sgm;\r\nstate->agm = agm;\r\n}\r\nstatic void synaptics_parse_agm(const unsigned char buf[],\r\nstruct synaptics_data *priv,\r\nstruct synaptics_hw_state *hw)\r\n{\r\nstruct synaptics_hw_state *agm = &priv->agm;\r\nint agm_packet_type;\r\nagm_packet_type = (buf[5] & 0x30) >> 4;\r\nswitch (agm_packet_type) {\r\ncase 1:\r\nagm->w = hw->w;\r\nagm->x = (((buf[4] & 0x0f) << 8) | buf[1]) << 1;\r\nagm->y = (((buf[4] & 0xf0) << 4) | buf[2]) << 1;\r\nagm->z = ((buf[3] & 0x30) | (buf[5] & 0x0f)) << 1;\r\nbreak;\r\ncase 2:\r\nsynaptics_mt_state_set(&agm->mt_state, buf[1], buf[2], buf[4]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npriv->agm_pending = true;\r\n}\r\nstatic int synaptics_parse_hw_state(const unsigned char buf[],\r\nstruct synaptics_data *priv,\r\nstruct synaptics_hw_state *hw)\r\n{\r\nmemset(hw, 0, sizeof(struct synaptics_hw_state));\r\nif (SYN_MODEL_NEWABS(priv->model_id)) {\r\nhw->w = (((buf[0] & 0x30) >> 2) |\r\n((buf[0] & 0x04) >> 1) |\r\n((buf[3] & 0x04) >> 2));\r\nhw->left = (buf[0] & 0x01) ? 1 : 0;\r\nhw->right = (buf[0] & 0x02) ? 1 : 0;\r\nif (SYN_CAP_CLICKPAD(priv->ext_cap_0c)) {\r\nhw->left = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;\r\n} else if (SYN_CAP_MIDDLE_BUTTON(priv->capabilities)) {\r\nhw->middle = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;\r\nif (hw->w == 2)\r\nhw->scroll = (signed char)(buf[1]);\r\n}\r\nif (SYN_CAP_FOUR_BUTTON(priv->capabilities)) {\r\nhw->up = ((buf[0] ^ buf[3]) & 0x01) ? 1 : 0;\r\nhw->down = ((buf[0] ^ buf[3]) & 0x02) ? 1 : 0;\r\n}\r\nif ((SYN_CAP_ADV_GESTURE(priv->ext_cap_0c) ||\r\nSYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)) &&\r\nhw->w == 2) {\r\nsynaptics_parse_agm(buf, priv, hw);\r\nreturn 1;\r\n}\r\nhw->x = (((buf[3] & 0x10) << 8) |\r\n((buf[1] & 0x0f) << 8) |\r\nbuf[4]);\r\nhw->y = (((buf[3] & 0x20) << 7) |\r\n((buf[1] & 0xf0) << 4) |\r\nbuf[5]);\r\nhw->z = buf[2];\r\nif (SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap) &&\r\n((buf[0] ^ buf[3]) & 0x02)) {\r\nswitch (SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap) & ~0x01) {\r\ndefault:\r\nbreak;\r\ncase 8:\r\nhw->ext_buttons |= ((buf[5] & 0x08)) ? 0x80 : 0;\r\nhw->ext_buttons |= ((buf[4] & 0x08)) ? 0x40 : 0;\r\ncase 6:\r\nhw->ext_buttons |= ((buf[5] & 0x04)) ? 0x20 : 0;\r\nhw->ext_buttons |= ((buf[4] & 0x04)) ? 0x10 : 0;\r\ncase 4:\r\nhw->ext_buttons |= ((buf[5] & 0x02)) ? 0x08 : 0;\r\nhw->ext_buttons |= ((buf[4] & 0x02)) ? 0x04 : 0;\r\ncase 2:\r\nhw->ext_buttons |= ((buf[5] & 0x01)) ? 0x02 : 0;\r\nhw->ext_buttons |= ((buf[4] & 0x01)) ? 0x01 : 0;\r\n}\r\n}\r\n} else {\r\nhw->x = (((buf[1] & 0x1f) << 8) | buf[2]);\r\nhw->y = (((buf[4] & 0x1f) << 8) | buf[5]);\r\nhw->z = (((buf[0] & 0x30) << 2) | (buf[3] & 0x3F));\r\nhw->w = (((buf[1] & 0x80) >> 4) | ((buf[0] & 0x04) >> 1));\r\nhw->left = (buf[0] & 0x01) ? 1 : 0;\r\nhw->right = (buf[0] & 0x02) ? 1 : 0;\r\n}\r\nif (hw->x > X_MAX_POSITIVE)\r\nhw->x -= 1 << ABS_POS_BITS;\r\nelse if (hw->x == X_MAX_POSITIVE)\r\nhw->x = XMAX;\r\nif (hw->y > Y_MAX_POSITIVE)\r\nhw->y -= 1 << ABS_POS_BITS;\r\nelse if (hw->y == Y_MAX_POSITIVE)\r\nhw->y = YMAX;\r\nreturn 0;\r\n}\r\nstatic void synaptics_report_semi_mt_slot(struct input_dev *dev, int slot,\r\nbool active, int x, int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, synaptics_invert_y(y));\r\n}\r\n}\r\nstatic void synaptics_report_semi_mt_data(struct input_dev *dev,\r\nconst struct synaptics_hw_state *a,\r\nconst struct synaptics_hw_state *b,\r\nint num_fingers)\r\n{\r\nif (num_fingers >= 2) {\r\nsynaptics_report_semi_mt_slot(dev, 0, true, min(a->x, b->x),\r\nmin(a->y, b->y));\r\nsynaptics_report_semi_mt_slot(dev, 1, true, max(a->x, b->x),\r\nmax(a->y, b->y));\r\n} else if (num_fingers == 1) {\r\nsynaptics_report_semi_mt_slot(dev, 0, true, a->x, a->y);\r\nsynaptics_report_semi_mt_slot(dev, 1, false, 0, 0);\r\n} else {\r\nsynaptics_report_semi_mt_slot(dev, 0, false, 0, 0);\r\nsynaptics_report_semi_mt_slot(dev, 1, false, 0, 0);\r\n}\r\n}\r\nstatic void synaptics_report_buttons(struct psmouse *psmouse,\r\nconst struct synaptics_hw_state *hw)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct synaptics_data *priv = psmouse->private;\r\nint i;\r\ninput_report_key(dev, BTN_LEFT, hw->left);\r\ninput_report_key(dev, BTN_RIGHT, hw->right);\r\nif (SYN_CAP_MIDDLE_BUTTON(priv->capabilities))\r\ninput_report_key(dev, BTN_MIDDLE, hw->middle);\r\nif (SYN_CAP_FOUR_BUTTON(priv->capabilities)) {\r\ninput_report_key(dev, BTN_FORWARD, hw->up);\r\ninput_report_key(dev, BTN_BACK, hw->down);\r\n}\r\nfor (i = 0; i < SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap); i++)\r\ninput_report_key(dev, BTN_0 + i, hw->ext_buttons & (1 << i));\r\n}\r\nstatic void synaptics_report_slot(struct input_dev *dev, int slot,\r\nconst struct synaptics_hw_state *hw)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, (hw != NULL));\r\nif (!hw)\r\nreturn;\r\ninput_report_abs(dev, ABS_MT_POSITION_X, hw->x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, synaptics_invert_y(hw->y));\r\ninput_report_abs(dev, ABS_MT_PRESSURE, hw->z);\r\n}\r\nstatic void synaptics_report_mt_data(struct psmouse *psmouse,\r\nstruct synaptics_mt_state *mt_state,\r\nconst struct synaptics_hw_state *sgm)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct synaptics_data *priv = psmouse->private;\r\nstruct synaptics_hw_state *agm = &priv->agm;\r\nstruct synaptics_mt_state *old = &priv->mt_state;\r\nswitch (mt_state->count) {\r\ncase 0:\r\nsynaptics_report_slot(dev, 0, NULL);\r\nsynaptics_report_slot(dev, 1, NULL);\r\nbreak;\r\ncase 1:\r\nif (mt_state->sgm == -1) {\r\nsynaptics_report_slot(dev, 0, NULL);\r\nsynaptics_report_slot(dev, 1, NULL);\r\n} else if (mt_state->sgm == 0) {\r\nsynaptics_report_slot(dev, 0, sgm);\r\nsynaptics_report_slot(dev, 1, NULL);\r\n} else {\r\nsynaptics_report_slot(dev, 0, NULL);\r\nsynaptics_report_slot(dev, 1, sgm);\r\n}\r\nbreak;\r\ndefault:\r\nif (mt_state->sgm != -1 &&\r\n(mt_state->sgm == old->sgm ||\r\nold->sgm == -1 || mt_state->agm == old->sgm))\r\nsynaptics_report_slot(dev, 0, sgm);\r\nelse\r\nsynaptics_report_slot(dev, 0, NULL);\r\nif (mt_state->agm != -1 &&\r\n(mt_state->agm == old->agm ||\r\n(old->agm == -1 &&\r\n(old->sgm == -1 || mt_state->agm == old->sgm))))\r\nsynaptics_report_slot(dev, 1, agm);\r\nelse\r\nsynaptics_report_slot(dev, 1, NULL);\r\nbreak;\r\n}\r\ninput_mt_report_pointer_emulation(dev, false);\r\ninput_mt_report_finger_count(dev, mt_state->count);\r\nsynaptics_report_buttons(psmouse, sgm);\r\ninput_sync(dev);\r\n}\r\nstatic void synaptics_image_sensor_0f(struct synaptics_data *priv,\r\nstruct synaptics_mt_state *mt_state)\r\n{\r\nsynaptics_mt_state_set(mt_state, 0, -1, -1);\r\npriv->mt_state_lost = false;\r\n}\r\nstatic void synaptics_image_sensor_1f(struct synaptics_data *priv,\r\nstruct synaptics_mt_state *mt_state)\r\n{\r\nstruct synaptics_hw_state *agm = &priv->agm;\r\nstruct synaptics_mt_state *old = &priv->mt_state;\r\nif (priv->agm_pending && agm->z == 0) {\r\nsynaptics_mt_state_set(mt_state, 1, 0, -1);\r\npriv->mt_state_lost = false;\r\nreturn;\r\n}\r\nswitch (old->count) {\r\ncase 0:\r\nsynaptics_mt_state_set(mt_state, 1, 0, -1);\r\nbreak;\r\ncase 1:\r\nif (priv->mt_state_lost ||\r\n(priv->agm_pending && old->sgm <= 0))\r\nsynaptics_mt_state_set(mt_state, 1, 1, -1);\r\nelse if (old->sgm == -1)\r\nsynaptics_mt_state_set(mt_state, 1, 0, -1);\r\nbreak;\r\ncase 2:\r\nif (priv->mt_state_lost) {\r\nsynaptics_mt_state_set(mt_state, 1, -1, -1);\r\nbreak;\r\n}\r\nsynaptics_mt_state_set(mt_state, 1, old->agm, -1);\r\nbreak;\r\ncase 3:\r\nsynaptics_mt_state_set(mt_state, 1, -1, -1);\r\npriv->mt_state_lost = true;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nbreak;\r\n}\r\n}\r\nstatic void synaptics_image_sensor_2f(struct synaptics_data *priv,\r\nstruct synaptics_mt_state *mt_state)\r\n{\r\nstruct synaptics_mt_state *old = &priv->mt_state;\r\nswitch (old->count) {\r\ncase 0:\r\nsynaptics_mt_state_set(mt_state, 2, 0, 1);\r\nbreak;\r\ncase 1:\r\nif (old->sgm >= 1)\r\nsynaptics_mt_state_set(mt_state, 2, 0, old->sgm);\r\nelse\r\nsynaptics_mt_state_set(mt_state, 2, 0, 1);\r\nbreak;\r\ncase 2:\r\nif (priv->mt_state_lost)\r\nsynaptics_mt_state_set(mt_state, 2, 0, 1);\r\nbreak;\r\ncase 3:\r\nsynaptics_mt_state_set(mt_state, 2, -1, -1);\r\npriv->mt_state_lost = true;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nbreak;\r\n}\r\n}\r\nstatic void synaptics_image_sensor_3f(struct synaptics_data *priv,\r\nstruct synaptics_mt_state *mt_state)\r\n{\r\nstruct synaptics_mt_state *old = &priv->mt_state;\r\nswitch (old->count) {\r\ncase 0:\r\nsynaptics_mt_state_set(mt_state, 3, 0, 2);\r\nbreak;\r\ncase 1:\r\nif (old->sgm >= 2)\r\nsynaptics_mt_state_set(mt_state, 3, 0, old->sgm);\r\nelse\r\nsynaptics_mt_state_set(mt_state, 3, 0, 2);\r\nbreak;\r\ncase 2:\r\nif (old->agm >= 3) {\r\nsynaptics_mt_state_set(mt_state, 3, 0, old->agm);\r\nbreak;\r\n}\r\nif (priv->mt_state_lost) {\r\nsynaptics_mt_state_set(mt_state, 3, -1, -1);\r\nbreak;\r\n}\r\nsynaptics_mt_state_set(mt_state, 3, 0, -1);\r\nbreak;\r\ncase 3:\r\nif (old->agm <= 2)\r\nsynaptics_mt_state_set(mt_state, 3, 0, 2);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nbreak;\r\n}\r\n}\r\nstatic void synaptics_image_sensor_45f(struct synaptics_data *priv,\r\nstruct synaptics_mt_state *mt_state)\r\n{\r\npriv->mt_state_lost = false;\r\n}\r\nstatic void synaptics_image_sensor_process(struct psmouse *psmouse,\r\nstruct synaptics_hw_state *sgm)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nstruct synaptics_hw_state *agm = &priv->agm;\r\nstruct synaptics_mt_state mt_state;\r\nmt_state = agm->mt_state;\r\nif (sgm->z == 0)\r\nsynaptics_image_sensor_0f(priv, &mt_state);\r\nelse if (sgm->w >= 4)\r\nsynaptics_image_sensor_1f(priv, &mt_state);\r\nelse if (sgm->w == 0)\r\nsynaptics_image_sensor_2f(priv, &mt_state);\r\nelse if (sgm->w == 1 && mt_state.count <= 3)\r\nsynaptics_image_sensor_3f(priv, &mt_state);\r\nelse\r\nsynaptics_image_sensor_45f(priv, &mt_state);\r\nsynaptics_report_mt_data(psmouse, &mt_state, sgm);\r\npriv->mt_state = agm->mt_state = mt_state;\r\npriv->agm_pending = false;\r\n}\r\nstatic void synaptics_process_packet(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct synaptics_data *priv = psmouse->private;\r\nstruct synaptics_hw_state hw;\r\nint num_fingers;\r\nint finger_width;\r\nif (synaptics_parse_hw_state(psmouse->packet, priv, &hw))\r\nreturn;\r\nif (SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)) {\r\nsynaptics_image_sensor_process(psmouse, &hw);\r\nreturn;\r\n}\r\nif (hw.scroll) {\r\npriv->scroll += hw.scroll;\r\nwhile (priv->scroll >= 4) {\r\ninput_report_key(dev, BTN_BACK, !hw.down);\r\ninput_sync(dev);\r\ninput_report_key(dev, BTN_BACK, hw.down);\r\ninput_sync(dev);\r\npriv->scroll -= 4;\r\n}\r\nwhile (priv->scroll <= -4) {\r\ninput_report_key(dev, BTN_FORWARD, !hw.up);\r\ninput_sync(dev);\r\ninput_report_key(dev, BTN_FORWARD, hw.up);\r\ninput_sync(dev);\r\npriv->scroll += 4;\r\n}\r\nreturn;\r\n}\r\nif (hw.z > 0 && hw.x > 1) {\r\nnum_fingers = 1;\r\nfinger_width = 5;\r\nif (SYN_CAP_EXTENDED(priv->capabilities)) {\r\nswitch (hw.w) {\r\ncase 0 ... 1:\r\nif (SYN_CAP_MULTIFINGER(priv->capabilities))\r\nnum_fingers = hw.w + 2;\r\nbreak;\r\ncase 2:\r\nif (SYN_MODEL_PEN(priv->model_id))\r\n;\r\nbreak;\r\ncase 4 ... 15:\r\nif (SYN_CAP_PALMDETECT(priv->capabilities))\r\nfinger_width = hw.w;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nnum_fingers = 0;\r\nfinger_width = 0;\r\n}\r\nif (SYN_CAP_ADV_GESTURE(priv->ext_cap_0c))\r\nsynaptics_report_semi_mt_data(dev, &hw, &priv->agm,\r\nnum_fingers);\r\nif (hw.z > 30) input_report_key(dev, BTN_TOUCH, 1);\r\nif (hw.z < 25) input_report_key(dev, BTN_TOUCH, 0);\r\nif (num_fingers > 0) {\r\ninput_report_abs(dev, ABS_X, hw.x);\r\ninput_report_abs(dev, ABS_Y, synaptics_invert_y(hw.y));\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, hw.z);\r\nif (SYN_CAP_PALMDETECT(priv->capabilities))\r\ninput_report_abs(dev, ABS_TOOL_WIDTH, finger_width);\r\ninput_report_key(dev, BTN_TOOL_FINGER, num_fingers == 1);\r\nif (SYN_CAP_MULTIFINGER(priv->capabilities)) {\r\ninput_report_key(dev, BTN_TOOL_DOUBLETAP, num_fingers == 2);\r\ninput_report_key(dev, BTN_TOOL_TRIPLETAP, num_fingers == 3);\r\n}\r\nsynaptics_report_buttons(psmouse, &hw);\r\ninput_sync(dev);\r\n}\r\nstatic int synaptics_validate_byte(struct psmouse *psmouse,\r\nint idx, unsigned char pkt_type)\r\n{\r\nstatic const unsigned char newabs_mask[] = { 0xC8, 0x00, 0x00, 0xC8, 0x00 };\r\nstatic const unsigned char newabs_rel_mask[] = { 0xC0, 0x00, 0x00, 0xC0, 0x00 };\r\nstatic const unsigned char newabs_rslt[] = { 0x80, 0x00, 0x00, 0xC0, 0x00 };\r\nstatic const unsigned char oldabs_mask[] = { 0xC0, 0x60, 0x00, 0xC0, 0x60 };\r\nstatic const unsigned char oldabs_rslt[] = { 0xC0, 0x00, 0x00, 0x80, 0x00 };\r\nconst char *packet = psmouse->packet;\r\nif (idx < 0 || idx > 4)\r\nreturn 0;\r\nswitch (pkt_type) {\r\ncase SYN_NEWABS:\r\ncase SYN_NEWABS_RELAXED:\r\nreturn (packet[idx] & newabs_rel_mask[idx]) == newabs_rslt[idx];\r\ncase SYN_NEWABS_STRICT:\r\nreturn (packet[idx] & newabs_mask[idx]) == newabs_rslt[idx];\r\ncase SYN_OLDABS:\r\nreturn (packet[idx] & oldabs_mask[idx]) == oldabs_rslt[idx];\r\ndefault:\r\npsmouse_err(psmouse, "unknown packet type %d\n", pkt_type);\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned char synaptics_detect_pkt_type(struct psmouse *psmouse)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\nif (!synaptics_validate_byte(psmouse, i, SYN_NEWABS_STRICT)) {\r\npsmouse_info(psmouse, "using relaxed packet validation\n");\r\nreturn SYN_NEWABS_RELAXED;\r\n}\r\nreturn SYN_NEWABS_STRICT;\r\n}\r\nstatic psmouse_ret_t synaptics_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nif (psmouse->pktcnt >= 6) {\r\nif (unlikely(priv->pkt_type == SYN_NEWABS))\r\npriv->pkt_type = synaptics_detect_pkt_type(psmouse);\r\nif (SYN_CAP_PASS_THROUGH(priv->capabilities) &&\r\nsynaptics_is_pt_packet(psmouse->packet)) {\r\nif (priv->pt_port)\r\nsynaptics_pass_pt_packet(priv->pt_port, psmouse->packet);\r\n} else\r\nsynaptics_process_packet(psmouse);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn synaptics_validate_byte(psmouse, psmouse->pktcnt - 1, priv->pkt_type) ?\r\nPSMOUSE_GOOD_DATA : PSMOUSE_BAD_DATA;\r\n}\r\nstatic void set_abs_position_params(struct input_dev *dev,\r\nstruct synaptics_data *priv, int x_code,\r\nint y_code)\r\n{\r\nint x_min = priv->x_min ?: XMIN_NOMINAL;\r\nint x_max = priv->x_max ?: XMAX_NOMINAL;\r\nint y_min = priv->y_min ?: YMIN_NOMINAL;\r\nint y_max = priv->y_max ?: YMAX_NOMINAL;\r\nint fuzz = SYN_CAP_REDUCED_FILTERING(priv->ext_cap_0c) ?\r\nSYN_REDUCED_FILTER_FUZZ : 0;\r\ninput_set_abs_params(dev, x_code, x_min, x_max, fuzz, 0);\r\ninput_set_abs_params(dev, y_code, y_min, y_max, fuzz, 0);\r\ninput_abs_set_res(dev, x_code, priv->x_res);\r\ninput_abs_set_res(dev, y_code, priv->y_res);\r\n}\r\nstatic void set_input_params(struct input_dev *dev, struct synaptics_data *priv)\r\n{\r\nint i;\r\n__set_bit(INPUT_PROP_POINTER, dev->propbit);\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(BTN_LEFT, dev->keybit);\r\n__set_bit(BTN_RIGHT, dev->keybit);\r\nif (SYN_CAP_MIDDLE_BUTTON(priv->capabilities))\r\n__set_bit(BTN_MIDDLE, dev->keybit);\r\nif (!priv->absolute_mode) {\r\n__set_bit(EV_REL, dev->evbit);\r\n__set_bit(REL_X, dev->relbit);\r\n__set_bit(REL_Y, dev->relbit);\r\nreturn;\r\n}\r\n__set_bit(EV_ABS, dev->evbit);\r\nset_abs_position_params(dev, priv, ABS_X, ABS_Y);\r\ninput_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);\r\nif (SYN_CAP_IMAGE_SENSOR(priv->ext_cap_0c)) {\r\nset_abs_position_params(dev, priv, ABS_MT_POSITION_X,\r\nABS_MT_POSITION_Y);\r\ninput_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);\r\ninput_mt_init_slots(dev, 2, INPUT_MT_POINTER);\r\n__set_bit(BTN_TOOL_QUADTAP, dev->keybit);\r\n__set_bit(BTN_TOOL_QUINTTAP, dev->keybit);\r\n} else if (SYN_CAP_ADV_GESTURE(priv->ext_cap_0c)) {\r\n__set_bit(INPUT_PROP_SEMI_MT, dev->propbit);\r\ninput_mt_init_slots(dev, 2, 0);\r\nset_abs_position_params(dev, priv, ABS_MT_POSITION_X,\r\nABS_MT_POSITION_Y);\r\n}\r\nif (SYN_CAP_PALMDETECT(priv->capabilities))\r\ninput_set_abs_params(dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\nif (SYN_CAP_MULTIFINGER(priv->capabilities)) {\r\n__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, dev->keybit);\r\n}\r\nif (SYN_CAP_FOUR_BUTTON(priv->capabilities) ||\r\nSYN_CAP_MIDDLE_BUTTON(priv->capabilities)) {\r\n__set_bit(BTN_FORWARD, dev->keybit);\r\n__set_bit(BTN_BACK, dev->keybit);\r\n}\r\nfor (i = 0; i < SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap); i++)\r\n__set_bit(BTN_0 + i, dev->keybit);\r\n__clear_bit(EV_REL, dev->evbit);\r\n__clear_bit(REL_X, dev->relbit);\r\n__clear_bit(REL_Y, dev->relbit);\r\nif (SYN_CAP_CLICKPAD(priv->ext_cap_0c)) {\r\n__set_bit(INPUT_PROP_BUTTONPAD, dev->propbit);\r\n__clear_bit(BTN_RIGHT, dev->keybit);\r\n__clear_bit(BTN_MIDDLE, dev->keybit);\r\n}\r\n}\r\nstatic ssize_t synaptics_show_disable_gesture(struct psmouse *psmouse,\r\nvoid *data, char *buf)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nreturn sprintf(buf, "%c\n", priv->disable_gesture ? '1' : '0');\r\n}\r\nstatic ssize_t synaptics_set_disable_gesture(struct psmouse *psmouse,\r\nvoid *data, const char *buf,\r\nsize_t len)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (value == priv->disable_gesture)\r\nreturn len;\r\npriv->disable_gesture = value;\r\nif (value)\r\npriv->mode |= SYN_BIT_DISABLE_GESTURE;\r\nelse\r\npriv->mode &= ~SYN_BIT_DISABLE_GESTURE;\r\nif (synaptics_mode_cmd(psmouse, priv->mode))\r\nreturn -EIO;\r\nreturn len;\r\n}\r\nstatic void synaptics_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nif (!priv->absolute_mode && SYN_ID_DISGEST_SUPPORTED(priv->identity))\r\ndevice_remove_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_disable_gesture.dattr);\r\nsynaptics_reset(psmouse);\r\nkfree(priv);\r\npsmouse->private = NULL;\r\n}\r\nstatic int synaptics_reconnect(struct psmouse *psmouse)\r\n{\r\nstruct synaptics_data *priv = psmouse->private;\r\nstruct synaptics_data old_priv = *priv;\r\nunsigned char param[2];\r\nint retry = 0;\r\nint error;\r\ndo {\r\npsmouse_reset(psmouse);\r\nif (retry) {\r\nssleep(1);\r\n}\r\nps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETID);\r\nerror = synaptics_detect(psmouse, 0);\r\n} while (error && ++retry < 3);\r\nif (error)\r\nreturn -1;\r\nif (retry > 1)\r\npsmouse_dbg(psmouse, "reconnected after %d tries\n", retry);\r\nif (synaptics_query_hardware(psmouse)) {\r\npsmouse_err(psmouse, "Unable to query device.\n");\r\nreturn -1;\r\n}\r\nif (synaptics_set_mode(psmouse)) {\r\npsmouse_err(psmouse, "Unable to initialize device.\n");\r\nreturn -1;\r\n}\r\nif (old_priv.identity != priv->identity ||\r\nold_priv.model_id != priv->model_id ||\r\nold_priv.capabilities != priv->capabilities ||\r\nold_priv.ext_cap != priv->ext_cap) {\r\npsmouse_err(psmouse,\r\n"hardware appears to be different: id(%ld-%ld), model(%ld-%ld), caps(%lx-%lx), ext(%lx-%lx).\n",\r\nold_priv.identity, priv->identity,\r\nold_priv.model_id, priv->model_id,\r\nold_priv.capabilities, priv->capabilities,\r\nold_priv.ext_cap, priv->ext_cap);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init synaptics_module_init(void)\r\n{\r\nimpaired_toshiba_kbc = dmi_check_system(toshiba_dmi_table);\r\nbroken_olpc_ec = dmi_check_system(olpc_dmi_table);\r\n}\r\nstatic int __synaptics_init(struct psmouse *psmouse, bool absolute_mode)\r\n{\r\nstruct synaptics_data *priv;\r\nint err = -1;\r\nif (absolute_mode && broken_olpc_ec) {\r\npsmouse_info(psmouse,\r\n"OLPC XO detected, not enabling Synaptics protocol.\n");\r\nreturn -ENODEV;\r\n}\r\npsmouse->private = priv = kzalloc(sizeof(struct synaptics_data), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npsmouse_reset(psmouse);\r\nif (synaptics_query_hardware(psmouse)) {\r\npsmouse_err(psmouse, "Unable to query device.\n");\r\ngoto init_fail;\r\n}\r\npriv->absolute_mode = absolute_mode;\r\nif (SYN_ID_DISGEST_SUPPORTED(priv->identity))\r\npriv->disable_gesture = true;\r\nif (synaptics_set_mode(psmouse)) {\r\npsmouse_err(psmouse, "Unable to initialize device.\n");\r\ngoto init_fail;\r\n}\r\npriv->pkt_type = SYN_MODEL_NEWABS(priv->model_id) ? SYN_NEWABS : SYN_OLDABS;\r\npsmouse_info(psmouse,\r\n"Touchpad model: %ld, fw: %ld.%ld, id: %#lx, caps: %#lx/%#lx/%#lx, board id: %lu, fw id: %lu\n",\r\nSYN_ID_MODEL(priv->identity),\r\nSYN_ID_MAJOR(priv->identity), SYN_ID_MINOR(priv->identity),\r\npriv->model_id,\r\npriv->capabilities, priv->ext_cap, priv->ext_cap_0c,\r\npriv->board_id, priv->firmware_id);\r\nset_input_params(psmouse->dev, priv);\r\npsmouse->model = ((priv->model_id & 0x00ff0000) >> 8) |\r\n(priv->model_id & 0x000000ff);\r\nif (absolute_mode) {\r\npsmouse->protocol_handler = synaptics_process_byte;\r\npsmouse->pktsize = 6;\r\n} else {\r\npsmouse->protocol_handler = psmouse_process_byte;\r\npsmouse->pktsize = 3;\r\n}\r\npsmouse->set_rate = synaptics_set_rate;\r\npsmouse->disconnect = synaptics_disconnect;\r\npsmouse->reconnect = synaptics_reconnect;\r\npsmouse->cleanup = synaptics_reset;\r\npsmouse->resync_time = 0;\r\nif (SYN_CAP_PASS_THROUGH(priv->capabilities))\r\nsynaptics_pt_create(psmouse);\r\nif (psmouse->rate >= 80 && impaired_toshiba_kbc) {\r\npsmouse_info(psmouse,\r\n"Toshiba %s detected, limiting rate to 40pps.\n",\r\ndmi_get_system_info(DMI_PRODUCT_NAME));\r\npsmouse->rate = 40;\r\n}\r\nif (!priv->absolute_mode && SYN_ID_DISGEST_SUPPORTED(priv->identity)) {\r\nerr = device_create_file(&psmouse->ps2dev.serio->dev,\r\n&psmouse_attr_disable_gesture.dattr);\r\nif (err) {\r\npsmouse_err(psmouse,\r\n"Failed to create disable_gesture attribute (%d)",\r\nerr);\r\ngoto init_fail;\r\n}\r\n}\r\nreturn 0;\r\ninit_fail:\r\nkfree(priv);\r\nreturn err;\r\n}\r\nint synaptics_init(struct psmouse *psmouse)\r\n{\r\nreturn __synaptics_init(psmouse, true);\r\n}\r\nint synaptics_init_relative(struct psmouse *psmouse)\r\n{\r\nreturn __synaptics_init(psmouse, false);\r\n}\r\nbool synaptics_supported(void)\r\n{\r\nreturn true;\r\n}\r\nvoid __init synaptics_module_init(void)\r\n{\r\n}\r\nint synaptics_init(struct psmouse *psmouse)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nbool synaptics_supported(void)\r\n{\r\nreturn false;\r\n}
