static int check_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan)\r\n{\r\nunsigned int chansegment[32];\r\nunsigned int i, nowmustbechan, seglen, segpos;\r\nif (n_chan < 1) {\r\ncomedi_error(dev, "range/channel list is empty!");\r\nreturn 0;\r\n}\r\nif (n_chan == 1)\r\nreturn 1;\r\nchansegment[0] = chanlist[0];\r\nfor (i = 1, seglen = 1; i < n_chan; i++, seglen++) {\r\nif (chanlist[0] == chanlist[i])\r\nbreak;\r\nif ((CR_CHAN(chanlist[i]) & 1) &&\r\n(CR_AREF(chanlist[i]) == AREF_DIFF)) {\r\ncomedi_error(dev, "Odd channel cannot be differential input!\n");\r\nreturn 0;\r\n}\r\nnowmustbechan = (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;\r\nif (CR_AREF(chansegment[i - 1]) == AREF_DIFF)\r\nnowmustbechan = (nowmustbechan + 1) % s->n_chan;\r\nif (nowmustbechan != CR_CHAN(chanlist[i])) {\r\nprintk("channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",\r\ni, CR_CHAN(chanlist[i]), nowmustbechan,\r\nCR_CHAN(chanlist[0]));\r\nreturn 0;\r\n}\r\nchansegment[i] = chanlist[i];\r\n}\r\nfor (i = 0, segpos = 0; i < n_chan; i++) {\r\nif (chanlist[i] != chansegment[i % seglen]) {\r\nprintk("bad channel, reference or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",\r\ni, CR_CHAN(chansegment[i]),\r\nCR_RANGE(chansegment[i]),\r\nCR_AREF(chansegment[i]),\r\nCR_CHAN(chanlist[i % seglen]),\r\nCR_RANGE(chanlist[i % seglen]),\r\nCR_AREF(chansegment[i % seglen]));\r\nreturn 0;\r\n}\r\n}\r\nreturn seglen;\r\n}\r\nstatic void setup_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan,\r\nunsigned int seglen)\r\n{\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nstruct pci1710_private *devpriv = dev->private;\r\nunsigned int i, range, chanprog;\r\ndevpriv->act_chanlist_len = seglen;\r\ndevpriv->act_chanlist_pos = 0;\r\nfor (i = 0; i < seglen; i++) {\r\nchanprog = muxonechan[CR_CHAN(chanlist[i])];\r\noutw(chanprog, dev->iobase + PCI171x_MUX);\r\nrange = this_board->rangecode_ai[CR_RANGE(chanlist[i])];\r\nif (CR_AREF(chanlist[i]) == AREF_DIFF)\r\nrange |= 0x0020;\r\noutw(range, dev->iobase + PCI171x_RANGE);\r\n#ifdef PCI171x_PARANOIDCHECK\r\ndevpriv->act_chanlist[i] =\r\n(CR_CHAN(chanlist[i]) << 12) & 0xf000;\r\n#endif\r\n}\r\n#ifdef PCI171x_PARANOIDCHECK\r\nfor ( ; i < n_chan; i++) {\r\ndevpriv->act_chanlist[i] =\r\n(CR_CHAN(chanlist[i]) << 12) & 0xf000;\r\n}\r\n#endif\r\ndevpriv->ai_et_MuxVal =\r\nCR_CHAN(chanlist[0]) | (CR_CHAN(chanlist[seglen - 1]) << 8);\r\noutw(devpriv->ai_et_MuxVal, dev->iobase + PCI171x_MUX);\r\n}\r\nstatic int pci171x_insn_read_ai(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nint n, timeout;\r\n#ifdef PCI171x_PARANOIDCHECK\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nunsigned int idata;\r\n#endif\r\ndevpriv->CntrlReg &= Control_CNT0;\r\ndevpriv->CntrlReg |= Control_SW;\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\nsetup_channel_list(dev, s, &insn->chanspec, 1, 1);\r\nfor (n = 0; n < insn->n; n++) {\r\noutw(0, dev->iobase + PCI171x_SOFTTRG);\r\ntimeout = 100;\r\nwhile (timeout--) {\r\nif (!(inw(dev->iobase + PCI171x_STATUS) & Status_FE))\r\ngoto conv_finish;\r\n}\r\ncomedi_error(dev, "A/D insn timeout");\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\ndata[n] = 0;\r\nreturn -ETIME;\r\nconv_finish:\r\n#ifdef PCI171x_PARANOIDCHECK\r\nidata = inw(dev->iobase + PCI171x_AD_DATA);\r\nif (this_board->cardtype != TYPE_PCI1713)\r\nif ((idata & 0xf000) != devpriv->act_chanlist[0]) {\r\ncomedi_error(dev, "A/D insn data droput!");\r\nreturn -ETIME;\r\n}\r\ndata[n] = idata & 0x0fff;\r\n#else\r\ndata[n] = inw(dev->iobase + PCI171x_AD_DATA) & 0x0fff;\r\n#endif\r\n}\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\nreturn n;\r\n}\r\nstatic int pci171x_insn_write_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nint n, chan, range, ofs;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\nif (chan) {\r\ndevpriv->da_ranges &= 0xfb;\r\ndevpriv->da_ranges |= (range << 2);\r\noutw(devpriv->da_ranges, dev->iobase + PCI171x_DAREF);\r\nofs = PCI171x_DA2;\r\n} else {\r\ndevpriv->da_ranges &= 0xfe;\r\ndevpriv->da_ranges |= range;\r\noutw(devpriv->da_ranges, dev->iobase + PCI171x_DAREF);\r\nofs = PCI171x_DA1;\r\n}\r\nfor (n = 0; n < insn->n; n++)\r\noutw(data[n], dev->iobase + ofs);\r\ndevpriv->ao_data[chan] = data[n];\r\nreturn n;\r\n}\r\nstatic int pci171x_insn_read_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nint n, chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = devpriv->ao_data[chan];\r\nreturn n;\r\n}\r\nstatic int pci171x_insn_bits_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inw(dev->iobase + PCI171x_DI);\r\nreturn insn->n;\r\n}\r\nstatic int pci171x_insn_bits_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\noutw(s->state, dev->iobase + PCI171x_DO);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void start_pacer(struct comedi_device *dev, int mode,\r\nunsigned int divisor1, unsigned int divisor2)\r\n{\r\noutw(0xb4, dev->iobase + PCI171x_CNTCTRL);\r\noutw(0x74, dev->iobase + PCI171x_CNTCTRL);\r\nif (mode == 1) {\r\noutw(divisor2 & 0xff, dev->iobase + PCI171x_CNT2);\r\noutw((divisor2 >> 8) & 0xff, dev->iobase + PCI171x_CNT2);\r\noutw(divisor1 & 0xff, dev->iobase + PCI171x_CNT1);\r\noutw((divisor1 >> 8) & 0xff, dev->iobase + PCI171x_CNT1);\r\n}\r\n}\r\nstatic int pci171x_insn_counter_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int msb, lsb, ccntrl;\r\nint i;\r\nccntrl = 0xD2;\r\nfor (i = 0; i < insn->n; i++) {\r\noutw(ccntrl, dev->iobase + PCI171x_CNTCTRL);\r\nlsb = inw(dev->iobase + PCI171x_CNT0) & 0xFF;\r\nmsb = inw(dev->iobase + PCI171x_CNT0) & 0xFF;\r\ndata[0] = lsb | (msb << 8);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int pci171x_insn_counter_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nuint msb, lsb, ccntrl, status;\r\nlsb = data[0] & 0x00FF;\r\nmsb = (data[0] & 0xFF00) >> 8;\r\noutw(lsb, dev->iobase + PCI171x_CNT0);\r\noutw(msb, dev->iobase + PCI171x_CNT0);\r\nif (devpriv->cnt0_write_wait) {\r\nccntrl = 0xE2;\r\ndo {\r\noutw(ccntrl, dev->iobase + PCI171x_CNTCTRL);\r\nstatus = inw(dev->iobase + PCI171x_CNT0) & 0xFF;\r\n} while (status & 0x40);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int pci171x_insn_counter_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\n#ifdef unused\r\nstruct pci1710_private *devpriv = dev->private;\r\nuint ccntrl = 0;\r\ndevpriv->cnt0_write_wait = data[0] & 0x20;\r\nif (!(data[0] & 0x10)) {\r\ndevpriv->CntrlReg &= ~Control_CNT0;\r\n} else {\r\ndevpriv->CntrlReg |= Control_CNT0;\r\n}\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\nif (data[0] & 0x01)\r\nccntrl |= Counter_M0;\r\nif (data[0] & 0x02)\r\nccntrl |= Counter_M1;\r\nif (data[0] & 0x04)\r\nccntrl |= Counter_M2;\r\nif (data[0] & 0x08)\r\nccntrl |= Counter_BCD;\r\nccntrl |= Counter_RW0;\r\nccntrl |= Counter_RW1;\r\noutw(ccntrl, dev->iobase + PCI171x_CNTCTRL);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int pci1720_insn_write_ao(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nint n, rangereg, chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nrangereg = devpriv->da_ranges & (~(0x03 << (chan << 1)));\r\nrangereg |= (CR_RANGE(insn->chanspec) << (chan << 1));\r\nif (rangereg != devpriv->da_ranges) {\r\noutb(rangereg, dev->iobase + PCI1720_RANGE);\r\ndevpriv->da_ranges = rangereg;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\noutw(data[n], dev->iobase + PCI1720_DA0 + (chan << 1));\r\noutb(0, dev->iobase + PCI1720_SYNCOUT);\r\n}\r\ndevpriv->ao_data[chan] = data[n];\r\nreturn n;\r\n}\r\nstatic int pci171x_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nstruct pci1710_private *devpriv = dev->private;\r\nswitch (this_board->cardtype) {\r\ndefault:\r\ndevpriv->CntrlReg &= Control_CNT0;\r\ndevpriv->CntrlReg |= Control_SW;\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\nstart_pacer(dev, -1, 0, 0);\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\nbreak;\r\n}\r\ndevpriv->ai_do = 0;\r\ndevpriv->ai_act_scan = 0;\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_buf_ptr = 0;\r\ndevpriv->neverending_ai = 0;\r\nreturn 0;\r\n}\r\nstatic void interrupt_pci1710_every_sample(void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pci1710_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nint m;\r\n#ifdef PCI171x_PARANOIDCHECK\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nshort sampl;\r\n#endif\r\nm = inw(dev->iobase + PCI171x_STATUS);\r\nif (m & Status_FE) {\r\nprintk("comedi%d: A/D FIFO empty (%4x)\n", dev->minor, m);\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nif (m & Status_FF) {\r\nprintk\r\n("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",\r\ndev->minor, m);\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\nfor (; !(inw(dev->iobase + PCI171x_STATUS) & Status_FE);) {\r\n#ifdef PCI171x_PARANOIDCHECK\r\nsampl = inw(dev->iobase + PCI171x_AD_DATA);\r\nif (this_board->cardtype != TYPE_PCI1713)\r\nif ((sampl & 0xf000) !=\r\ndevpriv->act_chanlist[s->async->cur_chan]) {\r\nprintk\r\n("comedi: A/D data dropout: received data from channel %d, expected %d!\n",\r\n(sampl & 0xf000) >> 12,\r\n(devpriv->\r\nact_chanlist[s->\r\nasync->cur_chan] & 0xf000) >>\r\n12);\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |=\r\nCOMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\ncomedi_buf_put(s->async, sampl & 0x0fff);\r\n#else\r\ncomedi_buf_put(s->async,\r\ninw(dev->iobase + PCI171x_AD_DATA) & 0x0fff);\r\n#endif\r\n++s->async->cur_chan;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan)\r\ns->async->cur_chan = 0;\r\nif (s->async->cur_chan == 0) {\r\ndevpriv->ai_act_scan++;\r\nif ((!devpriv->neverending_ai) &&\r\n(devpriv->ai_act_scan >= devpriv->ai_scans)) {\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\n}\r\n}\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\ncomedi_event(dev, s);\r\n}\r\nstatic int move_block_from_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n, int turn)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nint i, j;\r\n#ifdef PCI171x_PARANOIDCHECK\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nint sampl;\r\n#endif\r\nj = s->async->cur_chan;\r\nfor (i = 0; i < n; i++) {\r\n#ifdef PCI171x_PARANOIDCHECK\r\nsampl = inw(dev->iobase + PCI171x_AD_DATA);\r\nif (this_board->cardtype != TYPE_PCI1713)\r\nif ((sampl & 0xf000) != devpriv->act_chanlist[j]) {\r\nprintk\r\n("comedi%d: A/D FIFO data dropout: received data from channel %d, expected %d! (%d/%d/%d/%d/%d/%4x)\n",\r\ndev->minor, (sampl & 0xf000) >> 12,\r\n(devpriv->act_chanlist[j] & 0xf000) >> 12,\r\ni, j, devpriv->ai_act_scan, n, turn,\r\nsampl);\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |=\r\nCOMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn 1;\r\n}\r\ncomedi_buf_put(s->async, sampl & 0x0fff);\r\n#else\r\ncomedi_buf_put(s->async,\r\ninw(dev->iobase + PCI171x_AD_DATA) & 0x0fff);\r\n#endif\r\nj++;\r\nif (j >= devpriv->ai_n_chan) {\r\nj = 0;\r\ndevpriv->ai_act_scan++;\r\n}\r\n}\r\ns->async->cur_chan = j;\r\nreturn 0;\r\n}\r\nstatic void interrupt_pci1710_half_fifo(void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nstruct pci1710_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nint m, samplesinbuf;\r\nm = inw(dev->iobase + PCI171x_STATUS);\r\nif (!(m & Status_FH)) {\r\nprintk("comedi%d: A/D FIFO not half full! (%4x)\n",\r\ndev->minor, m);\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nif (m & Status_FF) {\r\nprintk\r\n("comedi%d: A/D FIFO Full status (Fatal Error!) (%4x)\n",\r\ndev->minor, m);\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nsamplesinbuf = this_board->fifo_half_size;\r\nif (samplesinbuf * sizeof(short) >= devpriv->ai_data_len) {\r\nm = devpriv->ai_data_len / sizeof(short);\r\nif (move_block_from_fifo(dev, s, m, 0))\r\nreturn;\r\nsamplesinbuf -= m;\r\n}\r\nif (samplesinbuf) {\r\nif (move_block_from_fifo(dev, s, samplesinbuf, 1))\r\nreturn;\r\n}\r\nif (!devpriv->neverending_ai)\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npci171x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\ncomedi_event(dev, s);\r\n}\r\nstatic irqreturn_t interrupt_service_pci1710(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pci1710_private *devpriv = dev->private;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nif (!(inw(dev->iobase + PCI171x_STATUS) & Status_IRQ))\r\nreturn IRQ_NONE;\r\nif (devpriv->ai_et) {\r\ndevpriv->ai_et = 0;\r\ndevpriv->CntrlReg &= Control_CNT0;\r\ndevpriv->CntrlReg |= Control_SW;\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\ndevpriv->CntrlReg = devpriv->ai_et_CntrlReg;\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\noutw(devpriv->ai_et_MuxVal, dev->iobase + PCI171x_MUX);\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\nstart_pacer(dev, 1, devpriv->ai_et_div1, devpriv->ai_et_div2);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->ai_eos) {\r\ninterrupt_pci1710_every_sample(d);\r\n} else {\r\ninterrupt_pci1710_half_fifo(d);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pci171x_ai_docmd_and_mode(int mode, struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nstruct pci1710_private *devpriv = dev->private;\r\nunsigned int divisor1 = 0, divisor2 = 0;\r\nunsigned int seglen;\r\nstart_pacer(dev, -1, 0, 0);\r\nseglen = check_channel_list(dev, s, devpriv->ai_chanlist,\r\ndevpriv->ai_n_chan);\r\nif (seglen < 1)\r\nreturn -EINVAL;\r\nsetup_channel_list(dev, s, devpriv->ai_chanlist,\r\ndevpriv->ai_n_chan, seglen);\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\ndevpriv->ai_do = mode;\r\ndevpriv->ai_act_scan = 0;\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_buf_ptr = 0;\r\ndevpriv->neverending_ai = 0;\r\ndevpriv->CntrlReg &= Control_CNT0;\r\nif ((devpriv->ai_flags & TRIG_WAKE_EOS)) {\r\ndevpriv->ai_eos = 1;\r\n} else {\r\ndevpriv->CntrlReg |= Control_ONEFH;\r\ndevpriv->ai_eos = 0;\r\n}\r\nif ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1))\r\ndevpriv->neverending_ai = 1;\r\nelse\r\ndevpriv->neverending_ai = 0;\r\nswitch (mode) {\r\ncase 1:\r\ncase 2:\r\nif (devpriv->ai_timer1 < this_board->ai_ns_min)\r\ndevpriv->ai_timer1 = this_board->ai_ns_min;\r\ndevpriv->CntrlReg |= Control_PACER | Control_IRQEN;\r\nif (mode == 2) {\r\ndevpriv->ai_et_CntrlReg = devpriv->CntrlReg;\r\ndevpriv->CntrlReg &=\r\n~(Control_PACER | Control_ONEFH | Control_GATE);\r\ndevpriv->CntrlReg |= Control_EXT;\r\ndevpriv->ai_et = 1;\r\n} else {\r\ndevpriv->ai_et = 0;\r\n}\r\ni8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,\r\n&divisor2, &devpriv->ai_timer1,\r\ndevpriv->ai_flags & TRIG_ROUND_MASK);\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\nif (mode != 2) {\r\nstart_pacer(dev, mode, divisor1, divisor2);\r\n} else {\r\ndevpriv->ai_et_div1 = divisor1;\r\ndevpriv->ai_et_div2 = divisor2;\r\n}\r\nbreak;\r\ncase 3:\r\ndevpriv->CntrlReg |= Control_EXT | Control_IRQEN;\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci171x_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nstruct pci1710_private *devpriv = dev->private;\r\nint err = 0;\r\nint tmp;\r\nunsigned int divisor1 = 0, divisor2 = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->convert_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg,\r\nthis_board->ai_ns_min);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer(devpriv->i8254_osc_base, &divisor1,\r\n&divisor2, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->convert_arg < this_board->ai_ns_min)\r\ncmd->convert_arg = this_board->ai_ns_min;\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nif (!check_channel_list(dev, s, cmd->chanlist,\r\ncmd->chanlist_len))\r\nreturn 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci171x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\ndevpriv->ai_n_chan = cmd->chanlist_len;\r\ndevpriv->ai_chanlist = cmd->chanlist;\r\ndevpriv->ai_flags = cmd->flags;\r\ndevpriv->ai_data_len = s->async->prealloc_bufsz;\r\ndevpriv->ai_data = s->async->prealloc_buf;\r\ndevpriv->ai_timer1 = 0;\r\ndevpriv->ai_timer2 = 0;\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->ai_scans = cmd->stop_arg;\r\nelse\r\ndevpriv->ai_scans = 0;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_timer1 = cmd->convert_arg;\r\nreturn pci171x_ai_docmd_and_mode(cmd->start_src ==\r\nTRIG_EXT ? 2 : 1, dev,\r\ns);\r\n}\r\nif (cmd->convert_src == TRIG_EXT) {\r\nreturn pci171x_ai_docmd_and_mode(3, dev, s);\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int pci171x_reset(struct comedi_device *dev)\r\n{\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nstruct pci1710_private *devpriv = dev->private;\r\noutw(0x30, dev->iobase + PCI171x_CNTCTRL);\r\ndevpriv->CntrlReg = Control_SW | Control_CNT0;\r\noutw(devpriv->CntrlReg, dev->iobase + PCI171x_CONTROL);\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\nstart_pacer(dev, -1, 0, 0);\r\ndevpriv->da_ranges = 0;\r\nif (this_board->n_aochan) {\r\noutb(devpriv->da_ranges, dev->iobase + PCI171x_DAREF);\r\noutw(0, dev->iobase + PCI171x_DA1);\r\ndevpriv->ao_data[0] = 0x0000;\r\nif (this_board->n_aochan > 1) {\r\noutw(0, dev->iobase + PCI171x_DA2);\r\ndevpriv->ao_data[1] = 0x0000;\r\n}\r\n}\r\noutw(0, dev->iobase + PCI171x_DO);\r\noutb(0, dev->iobase + PCI171x_CLRFIFO);\r\noutb(0, dev->iobase + PCI171x_CLRINT);\r\nreturn 0;\r\n}\r\nstatic int pci1720_reset(struct comedi_device *dev)\r\n{\r\nstruct pci1710_private *devpriv = dev->private;\r\noutb(Syncont_SC0, dev->iobase + PCI1720_SYNCONT);\r\ndevpriv->da_ranges = 0xAA;\r\noutb(devpriv->da_ranges, dev->iobase + PCI1720_RANGE);\r\noutw(0x0800, dev->iobase + PCI1720_DA0);\r\noutw(0x0800, dev->iobase + PCI1720_DA1);\r\noutw(0x0800, dev->iobase + PCI1720_DA2);\r\noutw(0x0800, dev->iobase + PCI1720_DA3);\r\noutb(0, dev->iobase + PCI1720_SYNCOUT);\r\ndevpriv->ao_data[0] = 0x0800;\r\ndevpriv->ao_data[1] = 0x0800;\r\ndevpriv->ao_data[2] = 0x0800;\r\ndevpriv->ao_data[3] = 0x0800;\r\nreturn 0;\r\n}\r\nstatic int pci1710_reset(struct comedi_device *dev)\r\n{\r\nconst struct boardtype *this_board = comedi_board(dev);\r\nswitch (this_board->cardtype) {\r\ncase TYPE_PCI1720:\r\nreturn pci1720_reset(dev);\r\ndefault:\r\nreturn pci171x_reset(dev);\r\n}\r\n}\r\nstatic int pci1710_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct boardtype *this_board = NULL;\r\nstruct pci1710_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret, subdev, n_subdevices;\r\nif (context < ARRAY_SIZE(boardtypes))\r\nthis_board = &boardtypes[context];\r\nif (!this_board)\r\nreturn -ENODEV;\r\ndev->board_ptr = this_board;\r\ndev->board_name = this_board->name;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->iobase = pci_resource_start(pcidev, 2);\r\nn_subdevices = 0;\r\nif (this_board->n_aichan)\r\nn_subdevices++;\r\nif (this_board->n_aochan)\r\nn_subdevices++;\r\nif (this_board->n_dichan)\r\nn_subdevices++;\r\nif (this_board->n_dochan)\r\nn_subdevices++;\r\nif (this_board->n_counter)\r\nn_subdevices++;\r\nret = comedi_alloc_subdevices(dev, n_subdevices);\r\nif (ret)\r\nreturn ret;\r\npci1710_reset(dev);\r\nif (this_board->have_irq && pcidev->irq) {\r\nret = request_irq(pcidev->irq, interrupt_service_pci1710,\r\nIRQF_SHARED, dev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nsubdev = 0;\r\nif (this_board->n_aichan) {\r\ns = &dev->subdevices[subdev];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND;\r\nif (this_board->n_aichand)\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = this_board->n_aichan;\r\ns->maxdata = this_board->ai_maxdata;\r\ns->len_chanlist = this_board->n_aichan;\r\ns->range_table = this_board->rangelist_ai;\r\ns->cancel = pci171x_ai_cancel;\r\ns->insn_read = pci171x_insn_read_ai;\r\nif (dev->irq) {\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmdtest = pci171x_ai_cmdtest;\r\ns->do_cmd = pci171x_ai_cmd;\r\n}\r\ndevpriv->i8254_osc_base = 100;\r\nsubdev++;\r\n}\r\nif (this_board->n_aochan) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = this_board->n_aochan;\r\ns->maxdata = this_board->ao_maxdata;\r\ns->len_chanlist = this_board->n_aochan;\r\ns->range_table = this_board->rangelist_ao;\r\nswitch (this_board->cardtype) {\r\ncase TYPE_PCI1720:\r\ns->insn_write = pci1720_insn_write_ao;\r\nbreak;\r\ndefault:\r\ns->insn_write = pci171x_insn_write_ao;\r\nbreak;\r\n}\r\ns->insn_read = pci171x_insn_read_ao;\r\nsubdev++;\r\n}\r\nif (this_board->n_dichan) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = this_board->n_dichan;\r\ns->maxdata = 1;\r\ns->len_chanlist = this_board->n_dichan;\r\ns->range_table = &range_digital;\r\ns->io_bits = 0;\r\ns->insn_bits = pci171x_insn_bits_di;\r\nsubdev++;\r\n}\r\nif (this_board->n_dochan) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = this_board->n_dochan;\r\ns->maxdata = 1;\r\ns->len_chanlist = this_board->n_dochan;\r\ns->range_table = &range_digital;\r\ns->io_bits = (1 << this_board->n_dochan) - 1;\r\ns->state = 0;\r\ns->insn_bits = pci171x_insn_bits_do;\r\nsubdev++;\r\n}\r\nif (this_board->n_counter) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = this_board->n_counter;\r\ns->len_chanlist = this_board->n_counter;\r\ns->maxdata = 0xffff;\r\ns->range_table = &range_unknown;\r\ns->insn_read = pci171x_insn_counter_read;\r\ns->insn_write = pci171x_insn_counter_write;\r\ns->insn_config = pci171x_insn_counter_config;\r\nsubdev++;\r\n}\r\ndev_info(dev->class_dev, "%s attached, irq %sabled\n",\r\ndev->board_name, dev->irq ? "en" : "dis");\r\nreturn 0;\r\n}\r\nstatic void pci1710_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\npci1710_reset(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int adv_pci1710_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &adv_pci1710_driver,\r\nid->driver_data);\r\n}
