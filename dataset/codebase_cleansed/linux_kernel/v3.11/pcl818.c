static int pcl818_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint timeout;\r\noutb(0, dev->iobase + PCL818_CONTROL);\r\noutb(muxonechan[CR_CHAN(insn->chanspec)], dev->iobase + PCL818_MUX);\r\noutb(CR_RANGE(insn->chanspec), dev->iobase + PCL818_RANGE);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\noutb(0, dev->iobase + PCL818_AD_LO);\r\ntimeout = 100;\r\nwhile (timeout--) {\r\nif (inb(dev->iobase + PCL818_STATUS) & 0x10)\r\ngoto conv_finish;\r\nudelay(1);\r\n}\r\ncomedi_error(dev, "A/D insn timeout");\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\nreturn -EIO;\r\nconv_finish:\r\ndata[n] = ((inb(dev->iobase + PCL818_AD_HI) << 4) |\r\n(inb(dev->iobase + PCL818_AD_LO) >> 4));\r\n}\r\nreturn n;\r\n}\r\nstatic int pcl818_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nint n;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = devpriv->ao_readback[chan];\r\nreturn n;\r\n}\r\nstatic int pcl818_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nint n;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->ao_readback[chan] = data[n];\r\noutb((data[n] & 0x000f) << 4, dev->iobase +\r\n(chan ? PCL718_DA2_LO : PCL818_DA_LO));\r\noutb((data[n] & 0x0ff0) >> 4, dev->iobase +\r\n(chan ? PCL718_DA2_HI : PCL818_DA_HI));\r\n}\r\nreturn n;\r\n}\r\nstatic int pcl818_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + PCL818_DI_LO) |\r\n(inb(dev->iobase + PCL818_DI_HI) << 8);\r\nreturn insn->n;\r\n}\r\nstatic int pcl818_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\noutb(s->state & 0xff, dev->iobase + PCL818_DO_LO);\r\noutb((s->state >> 8), dev->iobase + PCL818_DO_HI);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nint low;\r\nint timeout = 50;\r\nwhile (timeout--) {\r\nif (inb(dev->iobase + PCL818_STATUS) & 0x10)\r\ngoto conv_finish;\r\nudelay(1);\r\n}\r\noutb(0, dev->iobase + PCL818_STATUS);\r\ncomedi_error(dev, "A/D mode1/3 IRQ without DRDY!");\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\nconv_finish:\r\nlow = inb(dev->iobase + PCL818_AD_LO);\r\ncomedi_buf_put(s->async, ((inb(dev->iobase + PCL818_AD_HI) << 4) | (low >> 4)));\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\nif ((low & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {\r\nprintk\r\n("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",\r\n(low & 0xf),\r\ndevpriv->act_chanlist[devpriv->act_chanlist_pos]);\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\ndevpriv->act_chanlist_pos++;\r\nif (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)\r\ndevpriv->act_chanlist_pos = 0;\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan) {\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_act_scan--;\r\n}\r\nif (!devpriv->neverending_ai) {\r\nif (devpriv->ai_act_scan == 0) {\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nint i, len, bufptr;\r\nunsigned long flags;\r\nshort *ptr;\r\ndisable_dma(devpriv->dma);\r\ndevpriv->next_dma_buf = 1 - devpriv->next_dma_buf;\r\nif ((devpriv->dma_runs_to_end) > -1 || devpriv->neverending_ai) {\r\nset_dma_mode(devpriv->dma, DMA_MODE_READ);\r\nflags = claim_dma_lock();\r\nset_dma_addr(devpriv->dma,\r\ndevpriv->hwdmaptr[devpriv->next_dma_buf]);\r\nif (devpriv->dma_runs_to_end || devpriv->neverending_ai) {\r\nset_dma_count(devpriv->dma,\r\ndevpriv->hwdmasize[devpriv->\r\nnext_dma_buf]);\r\n} else {\r\nset_dma_count(devpriv->dma, devpriv->last_dma_run);\r\n}\r\nrelease_dma_lock(flags);\r\nenable_dma(devpriv->dma);\r\n}\r\nprintk("comedi: A/D mode1/3 IRQ \n");\r\ndevpriv->dma_runs_to_end--;\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\nptr = (short *)devpriv->dmabuf[1 - devpriv->next_dma_buf];\r\nlen = devpriv->hwdmasize[0] >> 1;\r\nbufptr = 0;\r\nfor (i = 0; i < len; i++) {\r\nif ((ptr[bufptr] & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {\r\nprintk\r\n("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",\r\n(ptr[bufptr] & 0xf),\r\ndevpriv->act_chanlist[devpriv->act_chanlist_pos],\r\ndevpriv->act_chanlist_pos);\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\ncomedi_buf_put(s->async, ptr[bufptr++] >> 4);\r\ndevpriv->act_chanlist_pos++;\r\nif (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)\r\ndevpriv->act_chanlist_pos = 0;\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan) {\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_act_scan--;\r\n}\r\nif (!devpriv->neverending_ai)\r\nif (devpriv->ai_act_scan == 0) {\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (len > 0)\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\nint i, len, lo;\r\noutb(0, dev->iobase + PCL818_FI_INTCLR);\r\nlo = inb(dev->iobase + PCL818_FI_STATUS);\r\nif (lo & 4) {\r\ncomedi_error(dev, "A/D mode1/3 FIFO overflow!");\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (lo & 1) {\r\ncomedi_error(dev, "A/D mode1/3 FIFO interrupt without data!");\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (lo & 2)\r\nlen = 512;\r\nelse\r\nlen = 0;\r\nfor (i = 0; i < len; i++) {\r\nlo = inb(dev->iobase + PCL818_FI_DATALO);\r\nif ((lo & 0xf) != devpriv->act_chanlist[devpriv->act_chanlist_pos]) {\r\nprintk\r\n("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",\r\n(lo & 0xf),\r\ndevpriv->act_chanlist[devpriv->act_chanlist_pos]);\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\ncomedi_buf_put(s->async, (lo >> 4) | (inb(dev->iobase + PCL818_FI_DATAHI) << 4));\r\ndevpriv->act_chanlist_pos++;\r\nif (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)\r\ndevpriv->act_chanlist_pos = 0;\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan) {\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_act_scan--;\r\n}\r\nif (!devpriv->neverending_ai)\r\nif (devpriv->ai_act_scan == 0) {\r\npcl818_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (len > 0)\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t interrupt_pcl818(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (!dev->attached) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->irq_blocked && devpriv->irq_was_now_closed) {\r\nif ((devpriv->neverending_ai || (!devpriv->neverending_ai &&\r\ndevpriv->ai_act_scan > 0)) &&\r\n(devpriv->ai_mode == INT_TYPE_AI1_DMA ||\r\ndevpriv->ai_mode == INT_TYPE_AI3_DMA)) {\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\ndevpriv->ai_act_scan = 0;\r\ndevpriv->neverending_ai = 0;\r\npcl818_ai_cancel(dev, s);\r\n}\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\nreturn IRQ_HANDLED;\r\n}\r\nswitch (devpriv->ai_mode) {\r\ncase INT_TYPE_AI1_DMA:\r\ncase INT_TYPE_AI3_DMA:\r\nreturn interrupt_pcl818_ai_mode13_dma(irq, d);\r\ncase INT_TYPE_AI1_INT:\r\ncase INT_TYPE_AI3_INT:\r\nreturn interrupt_pcl818_ai_mode13_int(irq, d);\r\ncase INT_TYPE_AI1_FIFO:\r\ncase INT_TYPE_AI3_FIFO:\r\nreturn interrupt_pcl818_ai_mode13_fifo(irq, d);\r\n#ifdef PCL818_MODE13_AO\r\ncase INT_TYPE_AO1_INT:\r\ncase INT_TYPE_AO3_INT:\r\nreturn interrupt_pcl818_ao_mode13_int(irq, d);\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\nif ((!dev->irq) || (!devpriv->irq_free) || (!devpriv->irq_blocked)\r\n|| (!devpriv->ai_mode)) {\r\ncomedi_error(dev, "bad IRQ!");\r\nreturn IRQ_NONE;\r\n}\r\ncomedi_error(dev, "IRQ from unknown source!");\r\nreturn IRQ_NONE;\r\n}\r\nstatic void pcl818_ai_mode13dma_int(int mode, struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nunsigned int flags;\r\nunsigned int bytes;\r\nprintk("mode13dma_int, mode: %d\n", mode);\r\ndisable_dma(devpriv->dma);\r\nbytes = devpriv->hwdmasize[0];\r\nif (!devpriv->neverending_ai) {\r\nbytes = devpriv->ai_n_chan * devpriv->ai_scans * sizeof(short);\r\ndevpriv->dma_runs_to_end = bytes / devpriv->hwdmasize[0];\r\ndevpriv->last_dma_run = bytes % devpriv->hwdmasize[0];\r\ndevpriv->dma_runs_to_end--;\r\nif (devpriv->dma_runs_to_end >= 0)\r\nbytes = devpriv->hwdmasize[0];\r\n}\r\ndevpriv->next_dma_buf = 0;\r\nset_dma_mode(devpriv->dma, DMA_MODE_READ);\r\nflags = claim_dma_lock();\r\nclear_dma_ff(devpriv->dma);\r\nset_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);\r\nset_dma_count(devpriv->dma, bytes);\r\nrelease_dma_lock(flags);\r\nenable_dma(devpriv->dma);\r\nif (mode == 1) {\r\ndevpriv->ai_mode = INT_TYPE_AI1_DMA;\r\noutb(0x87 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);\r\n} else {\r\ndevpriv->ai_mode = INT_TYPE_AI3_DMA;\r\noutb(0x86 | (dev->irq << 4), dev->iobase + PCL818_CONTROL);\r\n};\r\n}\r\nstatic int pcl818_ai_cmd_mode(int mode, struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint divisor1 = 0, divisor2 = 0;\r\nunsigned int seglen;\r\ndev_dbg(dev->class_dev, "pcl818_ai_cmd_mode()\n");\r\nif (!dev->irq) {\r\ncomedi_error(dev, "IRQ not defined!");\r\nreturn -EINVAL;\r\n}\r\nif (devpriv->irq_blocked)\r\nreturn -EBUSY;\r\nstart_pacer(dev, -1, 0, 0);\r\nseglen = check_channel_list(dev, s, devpriv->ai_chanlist,\r\ndevpriv->ai_n_chan);\r\nif (seglen < 1)\r\nreturn -EINVAL;\r\nsetup_channel_list(dev, s, devpriv->ai_chanlist,\r\ndevpriv->ai_n_chan, seglen);\r\nudelay(1);\r\ndevpriv->ai_act_scan = devpriv->ai_scans;\r\ndevpriv->ai_act_chan = 0;\r\ndevpriv->irq_blocked = 1;\r\ndevpriv->irq_was_now_closed = 0;\r\ndevpriv->neverending_ai = 0;\r\ndevpriv->act_chanlist_pos = 0;\r\ndevpriv->dma_runs_to_end = 0;\r\nif ((devpriv->ai_scans == 0) || (devpriv->ai_scans == -1))\r\ndevpriv->neverending_ai = 1;\r\nif (mode == 1) {\r\ni8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,\r\n&divisor2, &cmd->convert_arg,\r\nTRIG_ROUND_NEAREST);\r\nif (divisor1 == 1) {\r\ndivisor1 = 2;\r\ndivisor2 /= 2;\r\n}\r\nif (divisor2 == 1) {\r\ndivisor2 = 2;\r\ndivisor1 /= 2;\r\n}\r\n}\r\noutb(0, dev->iobase + PCL818_CNTENABLE);\r\nswitch (devpriv->dma) {\r\ncase 1:\r\ncase 3:\r\npcl818_ai_mode13dma_int(mode, dev, s);\r\nbreak;\r\ncase 0:\r\nif (!devpriv->usefifo) {\r\nif (mode == 1) {\r\ndevpriv->ai_mode = INT_TYPE_AI1_INT;\r\noutb(0x83 | (dev->irq << 4),\r\ndev->iobase + PCL818_CONTROL);\r\n} else {\r\ndevpriv->ai_mode = INT_TYPE_AI3_INT;\r\noutb(0x82 | (dev->irq << 4),\r\ndev->iobase + PCL818_CONTROL);\r\n}\r\n} else {\r\noutb(1, dev->iobase + PCL818_FI_ENABLE);\r\nif (mode == 1) {\r\ndevpriv->ai_mode = INT_TYPE_AI1_FIFO;\r\noutb(0x03, dev->iobase + PCL818_CONTROL);\r\n} else {\r\ndevpriv->ai_mode = INT_TYPE_AI3_FIFO;\r\noutb(0x02, dev->iobase + PCL818_CONTROL);\r\n}\r\n}\r\n}\r\nstart_pacer(dev, mode, divisor1, divisor2);\r\ndev_dbg(dev->class_dev, "pcl818_ai_cmd_mode() end\n");\r\nreturn 0;\r\n}\r\nstatic void start_pacer(struct comedi_device *dev, int mode,\r\nunsigned int divisor1, unsigned int divisor2)\r\n{\r\noutb(0xb4, dev->iobase + PCL818_CTRCTL);\r\noutb(0x74, dev->iobase + PCL818_CTRCTL);\r\nudelay(1);\r\nif (mode == 1) {\r\noutb(divisor2 & 0xff, dev->iobase + PCL818_CTR2);\r\noutb((divisor2 >> 8) & 0xff, dev->iobase + PCL818_CTR2);\r\noutb(divisor1 & 0xff, dev->iobase + PCL818_CTR1);\r\noutb((divisor1 >> 8) & 0xff, dev->iobase + PCL818_CTR1);\r\n}\r\n}\r\nstatic int check_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan)\r\n{\r\nunsigned int chansegment[16];\r\nunsigned int i, nowmustbechan, seglen, segpos;\r\nif (n_chan < 1) {\r\ncomedi_error(dev, "range/channel list is empty!");\r\nreturn 0;\r\n}\r\nif (n_chan > 1) {\r\nchansegment[0] = chanlist[0];\r\nfor (i = 1, seglen = 1; i < n_chan; i++, seglen++) {\r\nif (chanlist[0] == chanlist[i])\r\nbreak;\r\nnowmustbechan =\r\n(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;\r\nif (nowmustbechan != CR_CHAN(chanlist[i])) {\r\nprintk\r\n("comedi%d: pcl818: channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",\r\ndev->minor, i, CR_CHAN(chanlist[i]),\r\nnowmustbechan, CR_CHAN(chanlist[0]));\r\nreturn 0;\r\n}\r\nchansegment[i] = chanlist[i];\r\n}\r\nfor (i = 0, segpos = 0; i < n_chan; i++) {\r\nif (chanlist[i] != chansegment[i % seglen]) {\r\nprintk\r\n("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",\r\ndev->minor, i, CR_CHAN(chansegment[i]),\r\nCR_RANGE(chansegment[i]),\r\nCR_AREF(chansegment[i]),\r\nCR_CHAN(chanlist[i % seglen]),\r\nCR_RANGE(chanlist[i % seglen]),\r\nCR_AREF(chansegment[i % seglen]));\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\nseglen = 1;\r\n}\r\nprintk("check_channel_list: seglen %d\n", seglen);\r\nreturn seglen;\r\n}\r\nstatic void setup_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan,\r\nunsigned int seglen)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nint i;\r\ndevpriv->act_chanlist_len = seglen;\r\ndevpriv->act_chanlist_pos = 0;\r\nfor (i = 0; i < seglen; i++) {\r\ndevpriv->act_chanlist[i] = CR_CHAN(chanlist[i]);\r\noutb(muxonechan[CR_CHAN(chanlist[i])], dev->iobase + PCL818_MUX);\r\noutb(CR_RANGE(chanlist[i]), dev->iobase + PCL818_RANGE);\r\n}\r\nudelay(1);\r\noutb(devpriv->act_chanlist[0] | (devpriv->act_chanlist[seglen -\r\n1] << 4),\r\ndev->iobase + PCL818_MUX);\r\n}\r\nstatic int check_single_ended(unsigned int port)\r\n{\r\nif (inb(port + PCL818_STATUS) & 0x20)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct pcl818_board *board = comedi_board(dev);\r\nstruct pcl818_private *devpriv = dev->private;\r\nint err = 0;\r\nint tmp, divisor1 = 0, divisor2 = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->convert_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ns_min);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer(devpriv->i8253_osc_base, &divisor1,\r\n&divisor2, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->convert_arg < board->ns_min)\r\ncmd->convert_arg = board->ns_min;\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nif (!check_channel_list(dev, s, cmd->chanlist,\r\ncmd->chanlist_len))\r\nreturn 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint retval;\r\ndev_dbg(dev->class_dev, "pcl818_ai_cmd()\n");\r\ndevpriv->ai_n_chan = cmd->chanlist_len;\r\ndevpriv->ai_chanlist = cmd->chanlist;\r\ndevpriv->ai_flags = cmd->flags;\r\ndevpriv->ai_data_len = s->async->prealloc_bufsz;\r\ndevpriv->ai_data = s->async->prealloc_buf;\r\ndevpriv->ai_timer1 = 0;\r\ndevpriv->ai_timer2 = 0;\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->ai_scans = cmd->stop_arg;\r\nelse\r\ndevpriv->ai_scans = 0;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->ai_timer1 = cmd->convert_arg;\r\nretval = pcl818_ai_cmd_mode(1, dev, s);\r\ndev_dbg(dev->class_dev, "pcl818_ai_cmd() end\n");\r\nreturn retval;\r\n}\r\nif (cmd->convert_src == TRIG_EXT) {\r\nreturn pcl818_ai_cmd_mode(3, dev, s);\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int pcl818_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (devpriv->irq_blocked > 0) {\r\ndev_dbg(dev->class_dev, "pcl818_ai_cancel()\n");\r\ndevpriv->irq_was_now_closed = 1;\r\nswitch (devpriv->ai_mode) {\r\ncase INT_TYPE_AI1_DMA:\r\ncase INT_TYPE_AI3_DMA:\r\nif (devpriv->neverending_ai ||\r\n(!devpriv->neverending_ai &&\r\ndevpriv->ai_act_scan > 0)) {\r\ngoto end;\r\n}\r\ndisable_dma(devpriv->dma);\r\ncase INT_TYPE_AI1_INT:\r\ncase INT_TYPE_AI3_INT:\r\ncase INT_TYPE_AI1_FIFO:\r\ncase INT_TYPE_AI3_FIFO:\r\n#ifdef PCL818_MODE13_AO\r\ncase INT_TYPE_AO1_INT:\r\ncase INT_TYPE_AO3_INT:\r\n#endif\r\noutb(inb(dev->iobase + PCL818_CONTROL) & 0x73, dev->iobase + PCL818_CONTROL);\r\nudelay(1);\r\nstart_pacer(dev, -1, 0, 0);\r\noutb(0, dev->iobase + PCL818_AD_LO);\r\ninb(dev->iobase + PCL818_AD_LO);\r\ninb(dev->iobase + PCL818_AD_HI);\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\noutb(0, dev->iobase + PCL818_CONTROL);\r\nif (devpriv->usefifo) {\r\noutb(0, dev->iobase + PCL818_FI_INTCLR);\r\noutb(0, dev->iobase + PCL818_FI_FLUSH);\r\noutb(0, dev->iobase + PCL818_FI_ENABLE);\r\n}\r\ndevpriv->irq_blocked = 0;\r\ndevpriv->last_int_sub = s;\r\ndevpriv->neverending_ai = 0;\r\ndevpriv->ai_mode = 0;\r\ndevpriv->irq_was_now_closed = 0;\r\nbreak;\r\n}\r\n}\r\nend:\r\ndev_dbg(dev->class_dev, "pcl818_ai_cancel() end\n");\r\nreturn 0;\r\n}\r\nstatic int pcl818_check(unsigned long iobase)\r\n{\r\noutb(0x00, iobase + PCL818_MUX);\r\nudelay(1);\r\nif (inb(iobase + PCL818_MUX) != 0x00)\r\nreturn 1;\r\noutb(0x55, iobase + PCL818_MUX);\r\nudelay(1);\r\nif (inb(iobase + PCL818_MUX) != 0x55)\r\nreturn 1;\r\noutb(0x00, iobase + PCL818_MUX);\r\nudelay(1);\r\noutb(0x18, iobase + PCL818_CONTROL);\r\nudelay(1);\r\nif (inb(iobase + PCL818_CONTROL) != 0x18)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pcl818_reset(struct comedi_device *dev)\r\n{\r\nconst struct pcl818_board *board = comedi_board(dev);\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (devpriv->usefifo) {\r\noutb(0, dev->iobase + PCL818_FI_INTCLR);\r\noutb(0, dev->iobase + PCL818_FI_FLUSH);\r\noutb(0, dev->iobase + PCL818_FI_ENABLE);\r\n}\r\noutb(0, dev->iobase + PCL818_DA_LO);\r\noutb(0, dev->iobase + PCL818_DA_HI);\r\nudelay(1);\r\noutb(0, dev->iobase + PCL818_DO_HI);\r\noutb(0, dev->iobase + PCL818_DO_LO);\r\nudelay(1);\r\noutb(0, dev->iobase + PCL818_CONTROL);\r\noutb(0, dev->iobase + PCL818_CNTENABLE);\r\noutb(0, dev->iobase + PCL818_MUX);\r\noutb(0, dev->iobase + PCL818_CLRINT);\r\noutb(0xb0, dev->iobase + PCL818_CTRCTL);\r\noutb(0x70, dev->iobase + PCL818_CTRCTL);\r\noutb(0x30, dev->iobase + PCL818_CTRCTL);\r\nif (board->is_818) {\r\noutb(0, dev->iobase + PCL818_RANGE);\r\n} else {\r\noutb(0, dev->iobase + PCL718_DA2_LO);\r\noutb(0, dev->iobase + PCL718_DA2_HI);\r\n}\r\n}\r\nstatic int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcl818_board *board = comedi_board(dev);\r\nstruct pcl818_private *devpriv;\r\nint ret;\r\nunsigned int irq;\r\nint dma;\r\nunsigned long pages;\r\nstruct comedi_subdevice *s;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\ndevpriv->io_range = board->io_range;\r\nif ((board->fifo) && (it->options[2] == -1)) {\r\ndevpriv->io_range = PCLx1xFIFO_RANGE;\r\ndevpriv->usefifo = 1;\r\n}\r\nret = comedi_request_region(dev, it->options[0], devpriv->io_range);\r\nif (ret)\r\nreturn ret;\r\nif (pcl818_check(dev->iobase)) {\r\ncomedi_error(dev, "I can't detect board. FAIL!\n");\r\nreturn -EIO;\r\n}\r\nirq = 0;\r\nif (board->IRQbits != 0) {\r\nirq = it->options[1];\r\nif (irq) {\r\nif (((1 << irq) & board->IRQbits) == 0) {\r\nprintk\r\n(", IRQ %u is out of allowed range, DISABLING IT",\r\nirq);\r\nirq = 0;\r\n} else {\r\nif (request_irq(irq, interrupt_pcl818, 0,\r\ndev->board_name, dev)) {\r\nprintk\r\n(", unable to allocate IRQ %u, DISABLING IT",\r\nirq);\r\nirq = 0;\r\n} else {\r\nprintk(KERN_DEBUG "irq=%u", irq);\r\n}\r\n}\r\n}\r\n}\r\ndev->irq = irq;\r\nif (irq)\r\ndevpriv->irq_free = 1;\r\nelse\r\ndevpriv->irq_free = 0;\r\ndevpriv->irq_blocked = 0;\r\ndevpriv->ai_mode = 0;\r\ndma = 0;\r\ndevpriv->dma = dma;\r\nif (!devpriv->irq_free)\r\ngoto no_dma;\r\nif (board->DMAbits != 0) {\r\ndma = it->options[2];\r\nif (dma < 1)\r\ngoto no_dma;\r\nif (((1 << dma) & board->DMAbits) == 0) {\r\nprintk(KERN_ERR "DMA is out of allowed range, FAIL!\n");\r\nreturn -EINVAL;\r\n}\r\nret = request_dma(dma, dev->board_name);\r\nif (ret)\r\nreturn -EBUSY;\r\ndevpriv->dma = dma;\r\npages = 2;\r\ndevpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);\r\nif (!devpriv->dmabuf[0])\r\nreturn -EBUSY;\r\ndevpriv->dmapages[0] = pages;\r\ndevpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);\r\ndevpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;\r\ndevpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);\r\nif (!devpriv->dmabuf[1])\r\nreturn -EBUSY;\r\ndevpriv->dmapages[1] = pages;\r\ndevpriv->hwdmaptr[1] = virt_to_bus((void *)devpriv->dmabuf[1]);\r\ndevpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;\r\n}\r\nno_dma:\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\nif (!board->n_aichan_se) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\ns->type = COMEDI_SUBD_AI;\r\ndevpriv->sub_ai = s;\r\ns->subdev_flags = SDF_READABLE;\r\nif (check_single_ended(dev->iobase)) {\r\ns->n_chan = board->n_aichan_se;\r\ns->subdev_flags |= SDF_COMMON | SDF_GROUND;\r\nprintk(", %dchans S.E. DAC", s->n_chan);\r\n} else {\r\ns->n_chan = board->n_aichan_diff;\r\ns->subdev_flags |= SDF_DIFF;\r\nprintk(", %dchans DIFF DAC", s->n_chan);\r\n}\r\ns->maxdata = board->ai_maxdata;\r\ns->len_chanlist = s->n_chan;\r\ns->range_table = board->ai_range_type;\r\ns->cancel = pcl818_ai_cancel;\r\ns->insn_read = pcl818_ai_insn_read;\r\nif (irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmdtest = ai_cmdtest;\r\ns->do_cmd = ai_cmd;\r\n}\r\nif (board->is_818) {\r\nif ((it->options[4] == 1) || (it->options[4] == 10))\r\ns->range_table = &range_pcl818l_h_ai;\r\n} else {\r\nswitch (it->options[4]) {\r\ncase 0:\r\ns->range_table = &range_bipolar10;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_bipolar5;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_bipolar2_5;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range718_bipolar1;\r\nbreak;\r\ncase 4:\r\ns->range_table = &range718_bipolar0_5;\r\nbreak;\r\ncase 6:\r\ns->range_table = &range_unipolar10;\r\nbreak;\r\ncase 7:\r\ns->range_table = &range_unipolar5;\r\nbreak;\r\ncase 8:\r\ns->range_table = &range718_unipolar2;\r\nbreak;\r\ncase 9:\r\ns->range_table = &range718_unipolar1;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_unknown;\r\nbreak;\r\n}\r\n}\r\n}\r\ns = &dev->subdevices[1];\r\nif (!board->n_aochan) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = board->ao_maxdata;\r\ns->len_chanlist = board->n_aochan;\r\ns->range_table = board->ao_range_type;\r\ns->insn_read = pcl818_ao_insn_read;\r\ns->insn_write = pcl818_ao_insn_write;\r\nif (board->is_818) {\r\nif ((it->options[4] == 1) || (it->options[4] == 10))\r\ns->range_table = &range_unipolar10;\r\nif (it->options[4] == 2)\r\ns->range_table = &range_unknown;\r\n} else {\r\nif ((it->options[5] == 1) || (it->options[5] == 10))\r\ns->range_table = &range_unipolar10;\r\nif (it->options[5] == 2)\r\ns->range_table = &range_unknown;\r\n}\r\n}\r\ns = &dev->subdevices[2];\r\nif (!board->n_dichan) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = board->n_dichan;\r\ns->maxdata = 1;\r\ns->len_chanlist = board->n_dichan;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl818_di_insn_bits;\r\n}\r\ns = &dev->subdevices[3];\r\nif (!board->n_dochan) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->n_dochan;\r\ns->maxdata = 1;\r\ns->len_chanlist = board->n_dochan;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl818_do_insn_bits;\r\n}\r\nif ((it->options[3] == 0) || (it->options[3] == 10))\r\ndevpriv->i8253_osc_base = 100;\r\nelse\r\ndevpriv->i8253_osc_base = 1000;\r\ndevpriv->ns_min = board->ns_min;\r\nif (!board->is_818) {\r\nif ((it->options[6] == 1) || (it->options[6] == 100))\r\ndevpriv->ns_min = 10000;\r\n}\r\npcl818_reset(dev);\r\nprintk("\n");\r\nreturn 0;\r\n}\r\nstatic void pcl818_detach(struct comedi_device *dev)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (devpriv) {\r\npcl818_ai_cancel(dev, devpriv->sub_ai);\r\npcl818_reset(dev);\r\nif (devpriv->dma)\r\nfree_dma(devpriv->dma);\r\nif (devpriv->dmabuf[0])\r\nfree_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);\r\nif (devpriv->dmabuf[1])\r\nfree_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);\r\n}\r\ncomedi_legacy_detach(dev);\r\n}
