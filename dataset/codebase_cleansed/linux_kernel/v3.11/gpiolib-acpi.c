static int acpi_gpiochip_find(struct gpio_chip *gc, void *data)\r\n{\r\nif (!gc->dev)\r\nreturn false;\r\nreturn ACPI_HANDLE(gc->dev) == data;\r\n}\r\nint acpi_get_gpio(char *path, int pin)\r\n{\r\nstruct gpio_chip *chip;\r\nacpi_handle handle;\r\nacpi_status status;\r\nstatus = acpi_get_handle(NULL, path, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nchip = gpiochip_find(handle, acpi_gpiochip_find);\r\nif (!chip)\r\nreturn -ENODEV;\r\nif (!gpio_is_valid(chip->base + pin))\r\nreturn -EINVAL;\r\nreturn chip->base + pin;\r\n}\r\nstatic irqreturn_t acpi_gpio_irq_handler(int irq, void *data)\r\n{\r\nacpi_handle handle = data;\r\nacpi_evaluate_object(handle, NULL, NULL, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t acpi_gpio_irq_handler_evt(int irq, void *data)\r\n{\r\nstruct acpi_gpio_evt_pin *evt_pin = data;\r\nstruct acpi_object_list args;\r\nunion acpi_object arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = evt_pin->pin;\r\nargs.count = 1;\r\nargs.pointer = &arg;\r\nacpi_evaluate_object(evt_pin->evt_handle, NULL, &args, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void acpi_gpio_evt_dh(acpi_handle handle, void *data)\r\n{\r\n}\r\nvoid acpi_gpiochip_request_interrupts(struct gpio_chip *chip)\r\n{\r\nstruct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};\r\nstruct acpi_resource *res;\r\nacpi_handle handle, evt_handle;\r\nstruct list_head *evt_pins = NULL;\r\nacpi_status status;\r\nunsigned int pin;\r\nint irq, ret;\r\nchar ev_name[5];\r\nif (!chip->dev || !chip->to_irq)\r\nreturn;\r\nhandle = ACPI_HANDLE(chip->dev);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_get_event_resources(handle, &buf);\r\nif (ACPI_FAILURE(status))\r\nreturn;\r\nstatus = acpi_get_handle(handle, "_EVT", &evt_handle);\r\nif (ACPI_SUCCESS(status)) {\r\nevt_pins = kzalloc(sizeof(*evt_pins), GFP_KERNEL);\r\nif (evt_pins) {\r\nINIT_LIST_HEAD(evt_pins);\r\nstatus = acpi_attach_data(handle, acpi_gpio_evt_dh,\r\nevt_pins);\r\nif (ACPI_FAILURE(status)) {\r\nkfree(evt_pins);\r\nevt_pins = NULL;\r\n}\r\n}\r\n}\r\nfor (res = buf.pointer;\r\nres && (res->type != ACPI_RESOURCE_TYPE_END_TAG);\r\nres = ACPI_NEXT_RESOURCE(res)) {\r\nirq_handler_t handler = NULL;\r\nvoid *data;\r\nif (res->type != ACPI_RESOURCE_TYPE_GPIO ||\r\nres->data.gpio.connection_type !=\r\nACPI_RESOURCE_GPIO_TYPE_INT)\r\ncontinue;\r\npin = res->data.gpio.pin_table[0];\r\nif (pin > chip->ngpio)\r\ncontinue;\r\nirq = chip->to_irq(chip, pin);\r\nif (irq < 0)\r\ncontinue;\r\nif (pin <= 255) {\r\nacpi_handle ev_handle;\r\nsprintf(ev_name, "_%c%02X",\r\nres->data.gpio.triggering ? 'E' : 'L', pin);\r\nstatus = acpi_get_handle(handle, ev_name, &ev_handle);\r\nif (ACPI_SUCCESS(status)) {\r\nhandler = acpi_gpio_irq_handler;\r\ndata = ev_handle;\r\n}\r\n}\r\nif (!handler && evt_pins) {\r\nstruct acpi_gpio_evt_pin *evt_pin;\r\nevt_pin = kzalloc(sizeof(*evt_pin), GFP_KERNEL);\r\nif (!evt_pin)\r\ncontinue;\r\nlist_add_tail(&evt_pin->node, evt_pins);\r\nevt_pin->evt_handle = evt_handle;\r\nevt_pin->pin = pin;\r\nevt_pin->irq = irq;\r\nhandler = acpi_gpio_irq_handler_evt;\r\ndata = evt_pin;\r\n}\r\nif (!handler)\r\ncontinue;\r\nret = devm_request_threaded_irq(chip->dev, irq, NULL, handler,\r\n0, "GPIO-signaled-ACPI-event",\r\ndata);\r\nif (ret)\r\ndev_err(chip->dev,\r\n"Failed to request IRQ %d ACPI event handler\n",\r\nirq);\r\n}\r\n}\r\nstatic int acpi_find_gpio(struct acpi_resource *ares, void *data)\r\n{\r\nstruct acpi_gpio_lookup *lookup = data;\r\nif (ares->type != ACPI_RESOURCE_TYPE_GPIO)\r\nreturn 1;\r\nif (lookup->n++ == lookup->index && lookup->gpio < 0) {\r\nconst struct acpi_resource_gpio *agpio = &ares->data.gpio;\r\nlookup->gpio = acpi_get_gpio(agpio->resource_source.string_ptr,\r\nagpio->pin_table[0]);\r\nlookup->info.gpioint =\r\nagpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT;\r\n}\r\nreturn 1;\r\n}\r\nint acpi_get_gpio_by_index(struct device *dev, int index,\r\nstruct acpi_gpio_info *info)\r\n{\r\nstruct acpi_gpio_lookup lookup;\r\nstruct list_head resource_list;\r\nstruct acpi_device *adev;\r\nacpi_handle handle;\r\nint ret;\r\nif (!dev)\r\nreturn -EINVAL;\r\nhandle = ACPI_HANDLE(dev);\r\nif (!handle || acpi_bus_get_device(handle, &adev))\r\nreturn -ENODEV;\r\nmemset(&lookup, 0, sizeof(lookup));\r\nlookup.index = index;\r\nlookup.gpio = -ENODEV;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list, acpi_find_gpio,\r\n&lookup);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (lookup.gpio >= 0 && info)\r\n*info = lookup.info;\r\nreturn lookup.gpio;\r\n}\r\nvoid acpi_gpiochip_free_interrupts(struct gpio_chip *chip)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct list_head *evt_pins;\r\nstruct acpi_gpio_evt_pin *evt_pin, *ep;\r\nif (!chip->dev || !chip->to_irq)\r\nreturn;\r\nhandle = ACPI_HANDLE(chip->dev);\r\nif (!handle)\r\nreturn;\r\nstatus = acpi_get_data(handle, acpi_gpio_evt_dh, (void **)&evt_pins);\r\nif (ACPI_FAILURE(status))\r\nreturn;\r\nlist_for_each_entry_safe_reverse(evt_pin, ep, evt_pins, node) {\r\ndevm_free_irq(chip->dev, evt_pin->irq, evt_pin);\r\nlist_del(&evt_pin->node);\r\nkfree(evt_pin);\r\n}\r\nacpi_detach_data(handle, acpi_gpio_evt_dh);\r\nkfree(evt_pins);\r\n}
