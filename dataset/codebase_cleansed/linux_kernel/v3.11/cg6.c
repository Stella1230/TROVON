static int cg6_sync(struct fb_info *info)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct cg6_fbc __iomem *fbc = par->fbc;\r\nint limit = 10000;\r\ndo {\r\nif (!(sbus_readl(&fbc->s) & 0x10000000))\r\nbreak;\r\nudelay(10);\r\n} while (--limit > 0);\r\nreturn 0;\r\n}\r\nstatic void cg6_switch_from_graph(struct cg6_par *par)\r\n{\r\nstruct cg6_thc __iomem *thc = par->thc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&par->lock, flags);\r\nsbus_writel(CG6_THC_CURSOFF, &thc->thc_cursxy);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic int cg6_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\ncg6_switch_from_graph(par);\r\nif (var->xoffset || var->yoffset || var->vmode)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void cg6_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct cg6_fbc __iomem *fbc = par->fbc;\r\nunsigned long flags;\r\ns32 val;\r\nspin_lock_irqsave(&par->lock, flags);\r\ncg6_sync(info);\r\nsbus_writel(rect->color, &fbc->fg);\r\nsbus_writel(~(u32)0, &fbc->pixelm);\r\nsbus_writel(0xea80ff00, &fbc->alu);\r\nsbus_writel(0, &fbc->s);\r\nsbus_writel(0, &fbc->clip);\r\nsbus_writel(~(u32)0, &fbc->pm);\r\nsbus_writel(rect->dy, &fbc->arecty);\r\nsbus_writel(rect->dx, &fbc->arectx);\r\nsbus_writel(rect->dy + rect->height, &fbc->arecty);\r\nsbus_writel(rect->dx + rect->width, &fbc->arectx);\r\ndo {\r\nval = sbus_readl(&fbc->draw);\r\n} while (val < 0 && (val & 0x20000000));\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic void cg6_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct cg6_fbc __iomem *fbc = par->fbc;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&par->lock, flags);\r\ncg6_sync(info);\r\nsbus_writel(0xff, &fbc->fg);\r\nsbus_writel(0x00, &fbc->bg);\r\nsbus_writel(~0, &fbc->pixelm);\r\nsbus_writel(0xe880cccc, &fbc->alu);\r\nsbus_writel(0, &fbc->s);\r\nsbus_writel(0, &fbc->clip);\r\nsbus_writel(area->sy, &fbc->y0);\r\nsbus_writel(area->sx, &fbc->x0);\r\nsbus_writel(area->sy + area->height - 1, &fbc->y1);\r\nsbus_writel(area->sx + area->width - 1, &fbc->x1);\r\nsbus_writel(area->dy, &fbc->y2);\r\nsbus_writel(area->dx, &fbc->x2);\r\nsbus_writel(area->dy + area->height - 1, &fbc->y3);\r\nsbus_writel(area->dx + area->width - 1, &fbc->x3);\r\ndo {\r\ni = sbus_readl(&fbc->blit);\r\n} while (i < 0 && (i & 0x20000000));\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic void cg6_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct cg6_fbc __iomem *fbc = par->fbc;\r\nconst u8 *data = image->data;\r\nunsigned long flags;\r\nu32 x, y;\r\nint i, width;\r\nif (image->depth > 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&par->lock, flags);\r\ncg6_sync(info);\r\nsbus_writel(image->fg_color, &fbc->fg);\r\nsbus_writel(image->bg_color, &fbc->bg);\r\nsbus_writel(0x140000, &fbc->mode);\r\nsbus_writel(0xe880fc30, &fbc->alu);\r\nsbus_writel(~(u32)0, &fbc->pixelm);\r\nsbus_writel(0, &fbc->s);\r\nsbus_writel(0, &fbc->clip);\r\nsbus_writel(0xff, &fbc->pm);\r\nsbus_writel(32, &fbc->incx);\r\nsbus_writel(0, &fbc->incy);\r\nx = image->dx;\r\ny = image->dy;\r\nfor (i = 0; i < image->height; i++) {\r\nwidth = image->width;\r\nwhile (width >= 32) {\r\nu32 val;\r\nsbus_writel(y, &fbc->y0);\r\nsbus_writel(x, &fbc->x0);\r\nsbus_writel(x + 32 - 1, &fbc->x1);\r\nval = ((u32)data[0] << 24) |\r\n((u32)data[1] << 16) |\r\n((u32)data[2] << 8) |\r\n((u32)data[3] << 0);\r\nsbus_writel(val, &fbc->font);\r\ndata += 4;\r\nx += 32;\r\nwidth -= 32;\r\n}\r\nif (width) {\r\nu32 val;\r\nsbus_writel(y, &fbc->y0);\r\nsbus_writel(x, &fbc->x0);\r\nsbus_writel(x + width - 1, &fbc->x1);\r\nif (width <= 8) {\r\nval = (u32) data[0] << 24;\r\ndata += 1;\r\n} else if (width <= 16) {\r\nval = ((u32) data[0] << 24) |\r\n((u32) data[1] << 16);\r\ndata += 2;\r\n} else {\r\nval = ((u32) data[0] << 24) |\r\n((u32) data[1] << 16) |\r\n((u32) data[2] << 8);\r\ndata += 3;\r\n}\r\nsbus_writel(val, &fbc->font);\r\n}\r\ny += 1;\r\nx = image->dx;\r\n}\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic int cg6_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct bt_regs __iomem *bt = par->bt;\r\nunsigned long flags;\r\nif (regno >= 256)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nspin_lock_irqsave(&par->lock, flags);\r\nsbus_writel((u32)regno << 24, &bt->addr);\r\nsbus_writel((u32)red << 24, &bt->color_map);\r\nsbus_writel((u32)green << 24, &bt->color_map);\r\nsbus_writel((u32)blue << 24, &bt->color_map);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cg6_blank(int blank, struct fb_info *info)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct cg6_thc __iomem *thc = par->thc;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&par->lock, flags);\r\nval = sbus_readl(&thc->thc_misc);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nval |= CG6_THC_MISC_VIDEO;\r\npar->flags &= ~CG6_FLAG_BLANKED;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nval &= ~CG6_THC_MISC_VIDEO;\r\npar->flags |= CG6_FLAG_BLANKED;\r\nbreak;\r\n}\r\nsbus_writel(val, &thc->thc_misc);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cg6_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nreturn sbusfb_mmap_helper(cg6_mmap_map,\r\ninfo->fix.smem_start, info->fix.smem_len,\r\npar->which_io, vma);\r\n}\r\nstatic int cg6_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn sbusfb_ioctl_helper(cmd, arg, info,\r\nFBTYPE_SUNFAST_COLOR, 8, info->fix.smem_len);\r\n}\r\nstatic void cg6_init_fix(struct fb_info *info, int linebytes)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nconst char *cg6_cpu_name, *cg6_card_name;\r\nu32 conf;\r\nconf = sbus_readl(par->fhc);\r\nswitch (conf & CG6_FHC_CPU_MASK) {\r\ncase CG6_FHC_CPU_SPARC:\r\ncg6_cpu_name = "sparc";\r\nbreak;\r\ncase CG6_FHC_CPU_68020:\r\ncg6_cpu_name = "68020";\r\nbreak;\r\ndefault:\r\ncg6_cpu_name = "i386";\r\nbreak;\r\n};\r\nif (((conf >> CG6_FHC_REV_SHIFT) & CG6_FHC_REV_MASK) >= 11) {\r\nif (info->fix.smem_len <= 0x100000)\r\ncg6_card_name = "TGX";\r\nelse\r\ncg6_card_name = "TGX+";\r\n} else {\r\nif (info->fix.smem_len <= 0x100000)\r\ncg6_card_name = "GX";\r\nelse\r\ncg6_card_name = "GX+";\r\n}\r\nsprintf(info->fix.id, "%s %s", cg6_card_name, cg6_cpu_name);\r\ninfo->fix.id[sizeof(info->fix.id) - 1] = 0;\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = linebytes;\r\ninfo->fix.accel = FB_ACCEL_SUN_CGSIX;\r\n}\r\nstatic void cg6_bt_init(struct cg6_par *par)\r\n{\r\nstruct bt_regs __iomem *bt = par->bt;\r\nsbus_writel(0x04 << 24, &bt->addr);\r\nsbus_writel(0xff << 24, &bt->control);\r\nsbus_writel(0x05 << 24, &bt->addr);\r\nsbus_writel(0x00 << 24, &bt->control);\r\nsbus_writel(0x06 << 24, &bt->addr);\r\nsbus_writel(0x73 << 24, &bt->control);\r\nsbus_writel(0x07 << 24, &bt->addr);\r\nsbus_writel(0x00 << 24, &bt->control);\r\n}\r\nstatic void cg6_chip_init(struct fb_info *info)\r\n{\r\nstruct cg6_par *par = (struct cg6_par *)info->par;\r\nstruct cg6_tec __iomem *tec = par->tec;\r\nstruct cg6_fbc __iomem *fbc = par->fbc;\r\nstruct cg6_thc __iomem *thc = par->thc;\r\nu32 rev, conf, mode;\r\nint i;\r\nsbus_writel(CG6_THC_CURSOFF, &thc->thc_cursxy);\r\nsbus_writel(0, &tec->tec_matrix);\r\nsbus_writel(0, &tec->tec_clip);\r\nsbus_writel(0, &tec->tec_vdc);\r\nrev = (sbus_readl(par->fhc) >> CG6_FHC_REV_SHIFT) & CG6_FHC_REV_MASK;\r\nif (rev < 5) {\r\nconf = (sbus_readl(par->fhc) & CG6_FHC_RES_MASK) |\r\nCG6_FHC_CPU_68020 | CG6_FHC_TEST |\r\n(11 << CG6_FHC_TEST_X_SHIFT) |\r\n(11 << CG6_FHC_TEST_Y_SHIFT);\r\nif (rev < 2)\r\nconf |= CG6_FHC_DST_DISABLE;\r\nsbus_writel(conf, par->fhc);\r\n}\r\nmode = sbus_readl(&fbc->mode);\r\ndo {\r\ni = sbus_readl(&fbc->s);\r\n} while (i & 0x10000000);\r\nmode &= ~(CG6_FBC_BLIT_MASK | CG6_FBC_MODE_MASK |\r\nCG6_FBC_DRAW_MASK | CG6_FBC_BWRITE0_MASK |\r\nCG6_FBC_BWRITE1_MASK | CG6_FBC_BREAD_MASK |\r\nCG6_FBC_BDISP_MASK);\r\nmode |= (CG6_FBC_BLIT_SRC | CG6_FBC_MODE_COLOR8 |\r\nCG6_FBC_DRAW_RENDER | CG6_FBC_BWRITE0_ENABLE |\r\nCG6_FBC_BWRITE1_DISABLE | CG6_FBC_BREAD_0 |\r\nCG6_FBC_BDISP_0);\r\nsbus_writel(mode, &fbc->mode);\r\nsbus_writel(0, &fbc->clip);\r\nsbus_writel(0, &fbc->offx);\r\nsbus_writel(0, &fbc->offy);\r\nsbus_writel(0, &fbc->clipminx);\r\nsbus_writel(0, &fbc->clipminy);\r\nsbus_writel(info->var.xres - 1, &fbc->clipmaxx);\r\nsbus_writel(info->var.yres - 1, &fbc->clipmaxy);\r\n}\r\nstatic void cg6_unmap_regs(struct platform_device *op, struct fb_info *info,\r\nstruct cg6_par *par)\r\n{\r\nif (par->fbc)\r\nof_iounmap(&op->resource[0], par->fbc, 4096);\r\nif (par->tec)\r\nof_iounmap(&op->resource[0], par->tec, sizeof(struct cg6_tec));\r\nif (par->thc)\r\nof_iounmap(&op->resource[0], par->thc, sizeof(struct cg6_thc));\r\nif (par->bt)\r\nof_iounmap(&op->resource[0], par->bt, sizeof(struct bt_regs));\r\nif (par->fhc)\r\nof_iounmap(&op->resource[0], par->fhc, sizeof(u32));\r\nif (info->screen_base)\r\nof_iounmap(&op->resource[0], info->screen_base,\r\ninfo->fix.smem_len);\r\n}\r\nstatic int cg6_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct fb_info *info;\r\nstruct cg6_par *par;\r\nint linebytes, err;\r\nint dblbuf;\r\ninfo = framebuffer_alloc(sizeof(struct cg6_par), &op->dev);\r\nerr = -ENOMEM;\r\nif (!info)\r\ngoto out_err;\r\npar = info->par;\r\nspin_lock_init(&par->lock);\r\ninfo->fix.smem_start = op->resource[0].start;\r\npar->which_io = op->resource[0].flags & IORESOURCE_BITS;\r\nsbusfb_fill_var(&info->var, dp, 8);\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\nlinebytes = of_getintprop_default(dp, "linebytes",\r\ninfo->var.xres);\r\ninfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\r\ndblbuf = of_getintprop_default(dp, "dblbuf", 0);\r\nif (dblbuf)\r\ninfo->fix.smem_len *= 4;\r\npar->fbc = of_ioremap(&op->resource[0], CG6_FBC_OFFSET,\r\n4096, "cgsix fbc");\r\npar->tec = of_ioremap(&op->resource[0], CG6_TEC_OFFSET,\r\nsizeof(struct cg6_tec), "cgsix tec");\r\npar->thc = of_ioremap(&op->resource[0], CG6_THC_OFFSET,\r\nsizeof(struct cg6_thc), "cgsix thc");\r\npar->bt = of_ioremap(&op->resource[0], CG6_BROOKTREE_OFFSET,\r\nsizeof(struct bt_regs), "cgsix dac");\r\npar->fhc = of_ioremap(&op->resource[0], CG6_FHC_OFFSET,\r\nsizeof(u32), "cgsix fhc");\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\r\nFBINFO_READS_FAST;\r\ninfo->fbops = &cg6_ops;\r\ninfo->screen_base = of_ioremap(&op->resource[0], CG6_RAM_OFFSET,\r\ninfo->fix.smem_len, "cgsix ram");\r\nif (!par->fbc || !par->tec || !par->thc ||\r\n!par->bt || !par->fhc || !info->screen_base)\r\ngoto out_unmap_regs;\r\ninfo->var.accel_flags = FB_ACCELF_TEXT;\r\ncg6_bt_init(par);\r\ncg6_chip_init(info);\r\ncg6_blank(FB_BLANK_UNBLANK, info);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0))\r\ngoto out_unmap_regs;\r\nfb_set_cmap(&info->cmap, info);\r\ncg6_init_fix(info, linebytes);\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto out_dealloc_cmap;\r\ndev_set_drvdata(&op->dev, info);\r\nprintk(KERN_INFO "%s: CGsix [%s] at %lx:%lx\n",\r\ndp->full_name, info->fix.id,\r\npar->which_io, info->fix.smem_start);\r\nreturn 0;\r\nout_dealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_unmap_regs:\r\ncg6_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int cg6_remove(struct platform_device *op)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&op->dev);\r\nstruct cg6_par *par = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\ncg6_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\ndev_set_drvdata(&op->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init cg6_init(void)\r\n{\r\nif (fb_get_options("cg6fb", NULL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&cg6_driver);\r\n}\r\nstatic void __exit cg6_exit(void)\r\n{\r\nplatform_driver_unregister(&cg6_driver);\r\n}
