void tty_buffer_free_all(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *thead;\r\nwhile ((thead = buf->head) != NULL) {\r\nbuf->head = thead->next;\r\nkfree(thead);\r\n}\r\nwhile ((thead = buf->free) != NULL) {\r\nbuf->free = thead->next;\r\nkfree(thead);\r\n}\r\nbuf->tail = NULL;\r\nbuf->memory_used = 0;\r\n}\r\nstatic struct tty_buffer *tty_buffer_alloc(struct tty_port *port, size_t size)\r\n{\r\nstruct tty_buffer *p;\r\nif (port->buf.memory_used + size > 65536)\r\nreturn NULL;\r\np = kmalloc(sizeof(struct tty_buffer) + 2 * size, GFP_ATOMIC);\r\nif (p == NULL)\r\nreturn NULL;\r\np->used = 0;\r\np->size = size;\r\np->next = NULL;\r\np->commit = 0;\r\np->read = 0;\r\np->char_buf_ptr = (char *)(p->data);\r\np->flag_buf_ptr = (unsigned char *)p->char_buf_ptr + size;\r\nport->buf.memory_used += size;\r\nreturn p;\r\n}\r\nstatic void tty_buffer_free(struct tty_port *port, struct tty_buffer *b)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nbuf->memory_used -= b->size;\r\nWARN_ON(buf->memory_used < 0);\r\nif (b->size >= 512)\r\nkfree(b);\r\nelse {\r\nb->next = buf->free;\r\nbuf->free = b;\r\n}\r\n}\r\nstatic void __tty_buffer_flush(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *thead;\r\nif (unlikely(buf->head == NULL))\r\nreturn;\r\nwhile ((thead = buf->head->next) != NULL) {\r\ntty_buffer_free(port, buf->head);\r\nbuf->head = thead;\r\n}\r\nWARN_ON(buf->head != buf->tail);\r\nbuf->head->read = buf->head->commit;\r\n}\r\nvoid tty_buffer_flush(struct tty_struct *tty)\r\n{\r\nstruct tty_port *port = tty->port;\r\nstruct tty_bufhead *buf = &port->buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&buf->lock, flags);\r\nif (test_bit(TTYP_FLUSHING, &port->iflags)) {\r\nset_bit(TTYP_FLUSHPENDING, &port->iflags);\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\nwait_event(tty->read_wait,\r\ntest_bit(TTYP_FLUSHPENDING, &port->iflags) == 0);\r\nreturn;\r\n} else\r\n__tty_buffer_flush(port);\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\n}\r\nstatic struct tty_buffer *tty_buffer_find(struct tty_port *port, size_t size)\r\n{\r\nstruct tty_buffer **tbh = &port->buf.free;\r\nwhile ((*tbh) != NULL) {\r\nstruct tty_buffer *t = *tbh;\r\nif (t->size >= size) {\r\n*tbh = t->next;\r\nt->next = NULL;\r\nt->used = 0;\r\nt->commit = 0;\r\nt->read = 0;\r\nport->buf.memory_used += t->size;\r\nreturn t;\r\n}\r\ntbh = &((*tbh)->next);\r\n}\r\nsize = (size + 0xFF) & ~0xFF;\r\nreturn tty_buffer_alloc(port, size);\r\n}\r\nint tty_buffer_request_room(struct tty_port *port, size_t size)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *b, *n;\r\nint left;\r\nunsigned long flags;\r\nspin_lock_irqsave(&buf->lock, flags);\r\nb = buf->tail;\r\nif (b != NULL)\r\nleft = b->size - b->used;\r\nelse\r\nleft = 0;\r\nif (left < size) {\r\nif ((n = tty_buffer_find(port, size)) != NULL) {\r\nif (b != NULL) {\r\nb->next = n;\r\nb->commit = b->used;\r\n} else\r\nbuf->head = n;\r\nbuf->tail = n;\r\n} else\r\nsize = left;\r\n}\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\nreturn size;\r\n}\r\nint tty_insert_flip_string_fixed_flag(struct tty_port *port,\r\nconst unsigned char *chars, char flag, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(port, goal);\r\nstruct tty_buffer *tb = port->buf.tail;\r\nif (unlikely(space == 0)) {\r\nbreak;\r\n}\r\nmemcpy(tb->char_buf_ptr + tb->used, chars, space);\r\nmemset(tb->flag_buf_ptr + tb->used, flag, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nint tty_insert_flip_string_flags(struct tty_port *port,\r\nconst unsigned char *chars, const char *flags, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(port, goal);\r\nstruct tty_buffer *tb = port->buf.tail;\r\nif (unlikely(space == 0)) {\r\nbreak;\r\n}\r\nmemcpy(tb->char_buf_ptr + tb->used, chars, space);\r\nmemcpy(tb->flag_buf_ptr + tb->used, flags, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\nflags += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nvoid tty_schedule_flip(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nunsigned long flags;\r\nWARN_ON(port->low_latency);\r\nspin_lock_irqsave(&buf->lock, flags);\r\nif (buf->tail != NULL)\r\nbuf->tail->commit = buf->tail->used;\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\nschedule_work(&buf->work);\r\n}\r\nint tty_prepare_flip_string(struct tty_port *port, unsigned char **chars,\r\nsize_t size)\r\n{\r\nint space = tty_buffer_request_room(port, size);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = port->buf.tail;\r\n*chars = tb->char_buf_ptr + tb->used;\r\nmemset(tb->flag_buf_ptr + tb->used, TTY_NORMAL, space);\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nint tty_prepare_flip_string_flags(struct tty_port *port,\r\nunsigned char **chars, char **flags, size_t size)\r\n{\r\nint space = tty_buffer_request_room(port, size);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = port->buf.tail;\r\n*chars = tb->char_buf_ptr + tb->used;\r\n*flags = tb->flag_buf_ptr + tb->used;\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nstatic void flush_to_ldisc(struct work_struct *work)\r\n{\r\nstruct tty_port *port = container_of(work, struct tty_port, buf.work);\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nstruct tty_ldisc *disc;\r\ntty = port->itty;\r\nif (tty == NULL)\r\nreturn;\r\ndisc = tty_ldisc_ref(tty);\r\nif (disc == NULL)\r\nreturn;\r\nspin_lock_irqsave(&buf->lock, flags);\r\nif (!test_and_set_bit(TTYP_FLUSHING, &port->iflags)) {\r\nstruct tty_buffer *head;\r\nwhile ((head = buf->head) != NULL) {\r\nint count;\r\nchar *char_buf;\r\nunsigned char *flag_buf;\r\ncount = head->commit - head->read;\r\nif (!count) {\r\nif (head->next == NULL)\r\nbreak;\r\nbuf->head = head->next;\r\ntty_buffer_free(port, head);\r\ncontinue;\r\n}\r\nif (!tty->receive_room)\r\nbreak;\r\nif (count > tty->receive_room)\r\ncount = tty->receive_room;\r\nchar_buf = head->char_buf_ptr + head->read;\r\nflag_buf = head->flag_buf_ptr + head->read;\r\nhead->read += count;\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\ndisc->ops->receive_buf(tty, char_buf,\r\nflag_buf, count);\r\nspin_lock_irqsave(&buf->lock, flags);\r\nif (test_bit(TTYP_FLUSHPENDING, &port->iflags)) {\r\n__tty_buffer_flush(port);\r\nclear_bit(TTYP_FLUSHPENDING, &port->iflags);\r\nwake_up(&tty->read_wait);\r\nbreak;\r\n}\r\n}\r\nclear_bit(TTYP_FLUSHING, &port->iflags);\r\n}\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\ntty_ldisc_deref(disc);\r\n}\r\nvoid tty_flush_to_ldisc(struct tty_struct *tty)\r\n{\r\nif (!tty->port->low_latency)\r\nflush_work(&tty->port->buf.work);\r\n}\r\nvoid tty_flip_buffer_push(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&buf->lock, flags);\r\nif (buf->tail != NULL)\r\nbuf->tail->commit = buf->tail->used;\r\nspin_unlock_irqrestore(&buf->lock, flags);\r\nif (port->low_latency)\r\nflush_to_ldisc(&buf->work);\r\nelse\r\nschedule_work(&buf->work);\r\n}\r\nvoid tty_buffer_init(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nspin_lock_init(&buf->lock);\r\nbuf->head = NULL;\r\nbuf->tail = NULL;\r\nbuf->free = NULL;\r\nbuf->memory_used = 0;\r\nINIT_WORK(&buf->work, flush_to_ldisc);\r\n}
