static inline void xd_set_err_code(struct rts51x_chip *chip, u8 err_code)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nxd_card->err_code = err_code;\r\n}\r\nstatic int xd_set_init_para(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval;\r\nif (chip->asic_code)\r\nxd_card->xd_clock = 47;\r\nelse\r\nxd_card->xd_clock = CLK_50;\r\nretval = switch_clock(chip, xd_card->xd_clock);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_switch_clock(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval;\r\nretval = rts51x_select_card(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = switch_clock(chip, xd_card->xd_clock);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_id(struct rts51x_chip *chip, u8 id_cmd, u8 *id_buf,\r\nu8 buf_len)\r\n{\r\nint retval, i;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_DAT, 0xFF, id_cmd);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_ID);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nfor (i = 0; i < 4; i++) {\r\nrts51x_add_cmd(chip, READ_REG_CMD, (u16) (XD_ADDRESS1 + i), 0,\r\n0);\r\n}\r\nretval = rts51x_send_cmd(chip, MODE_CR, 20);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 5, 20);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nif (id_buf && buf_len) {\r\nif (buf_len > 4)\r\nbuf_len = 4;\r\nrts51x_read_rsp_buf(chip, 1, id_buf, buf_len);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void xd_assign_phy_addr(struct rts51x_chip *chip, u32 addr, u8 mode)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nswitch (mode) {\r\ncase XD_RW_ADDR:\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS0, 0xFF, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS1, 0xFF,\r\n(u8) addr);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS2, 0xFF,\r\n(u8) (addr >> 8));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS3, 0xFF,\r\n(u8) (addr >> 16));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CFG, 0xFF,\r\nxd_card->addr_cycle | XD_CALC_ECC |\r\nXD_BA_NO_TRANSFORM);\r\nbreak;\r\ncase XD_ERASE_ADDR:\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS0, 0xFF,\r\n(u8) addr);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS1, 0xFF,\r\n(u8) (addr >> 8));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS2, 0xFF,\r\n(u8) (addr >> 16));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CFG, 0xFF,\r\n(xd_card->addr_cycle - 1) |\r\nXD_CALC_ECC | XD_BA_NO_TRANSFORM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int xd_read_redundant(struct rts51x_chip *chip, u32 page_addr, u8 *buf,\r\nint buf_len)\r\n{\r\nint retval, i;\r\nrts51x_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_REDUNDANT);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nfor (i = 0; i < 6; i++) {\r\nrts51x_add_cmd(chip, READ_REG_CMD, (u16) (XD_PAGE_STATUS + i),\r\n0, 0);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nrts51x_add_cmd(chip, READ_REG_CMD, (u16) (XD_RESERVED0 + i), 0,\r\n0);\r\n}\r\nrts51x_add_cmd(chip, READ_REG_CMD, XD_PARITY, 0, 0);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 11, 500);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nif (buf && buf_len) {\r\nif (buf_len > 11)\r\nbuf_len = 11;\r\nrts51x_read_rsp_buf(chip, 1, buf, buf_len);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_data_from_ppb(struct rts51x_chip *chip, int offset, u8 *buf,\r\nint buf_len)\r\n{\r\nint retval, i;\r\nif (!buf || (buf_len <= 0))\r\nTRACE_RET(chip, STATUS_FAIL);\r\nrts51x_init_cmd(chip);\r\nfor (i = 0; i < buf_len; i++) {\r\nrts51x_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + offset + i, 0,\r\n0);\r\n}\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, buf_len, 200);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nrts51x_read_rsp_buf(chip, 0, buf, buf_len);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_cis(struct rts51x_chip *chip, u32 page_addr, u8 *buf,\r\nint buf_len)\r\n{\r\nint retval;\r\nu8 reg;\r\nif (!buf || (buf_len < 10))\r\nTRACE_RET(chip, STATUS_FAIL);\r\nrts51x_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01,\r\nPINGPONG_BUFFER);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\r\nXD_AUTO_CHK_DATA_STATUS, XD_AUTO_CHK_DATA_STATUS);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_PAGES);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END | XD_PPB_EMPTY,\r\nXD_TRANSFER_END | XD_PPB_EMPTY);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 1, 500);\r\nif (retval == STATUS_TIMEDOUT) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nRTS51X_READ_REG(chip, XD_PAGE_STATUS, &reg);\r\nif (reg != XD_GPG) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nRTS51X_READ_REG(chip, XD_CTL, &reg);\r\nif (!(reg & XD_ECC1_ERROR) || !(reg & XD_ECC1_UNCORRECTABLE)) {\r\nretval = xd_read_data_from_ppb(chip, 0, buf, buf_len);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (reg & XD_ECC1_ERROR) {\r\nu8 ecc_bit, ecc_byte;\r\nRTS51X_READ_REG(chip, XD_ECC_BIT1, &ecc_bit);\r\nRTS51X_READ_REG(chip, XD_ECC_BYTE1, &ecc_byte);\r\nRTS51X_DEBUGP("ECC_BIT1 = 0x%x, ECC_BYTE1 = 0x%x\n",\r\necc_bit, ecc_byte);\r\nif (ecc_byte < buf_len) {\r\nRTS51X_DEBUGP("Before correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\nbuf[ecc_byte] ^= (1 << ecc_bit);\r\nRTS51X_DEBUGP("After correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\n}\r\n}\r\n} else if (!(reg & XD_ECC2_ERROR) || !(reg & XD_ECC2_UNCORRECTABLE)) {\r\nRTS51X_WRITE_REG(chip, CARD_STOP, XD_STOP | XD_CLR_ERR,\r\nXD_STOP | XD_CLR_ERR);\r\nretval = xd_read_data_from_ppb(chip, 256, buf, buf_len);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (reg & XD_ECC2_ERROR) {\r\nu8 ecc_bit, ecc_byte;\r\nRTS51X_READ_REG(chip, XD_ECC_BIT2, &ecc_bit);\r\nRTS51X_READ_REG(chip, XD_ECC_BYTE2, &ecc_byte);\r\nRTS51X_DEBUGP("ECC_BIT2 = 0x%x, ECC_BYTE2 = 0x%x\n",\r\necc_bit, ecc_byte);\r\nif (ecc_byte < buf_len) {\r\nRTS51X_DEBUGP("Before correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\nbuf[ecc_byte] ^= (1 << ecc_bit);\r\nRTS51X_DEBUGP("After correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\n}\r\n}\r\n} else {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void xd_pull_ctl_disable(struct rts51x_chip *chip)\r\n{\r\nif (CHECK_PKG(chip, LQFP48)) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\r\n} else {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x56);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\r\n}\r\n}\r\nstatic void xd_pull_ctl_enable(struct rts51x_chip *chip)\r\n{\r\nif (CHECK_PKG(chip, LQFP48)) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0xAA);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\r\n} else {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0xA5);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x59);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\r\n}\r\n}\r\nstatic int reset_xd(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval, i, j;\r\nu8 id_buf[4], redunt[11];\r\nretval = rts51x_select_card(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS, 0xFF,\r\nXD_PGSTS_NOT_FF);\r\nif (chip->asic_code)\r\nxd_pull_ctl_disable(chip);\r\nelse\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\r\n(FPGA_XD_PULL_CTL_EN1 & FPGA_XD_PULL_CTL_EN3));\r\nif (!chip->option.FT2_fast_mode) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_INIT, XD_NO_AUTO_PWR_OFF,\r\n0);\r\nif (CHECK_PKG(chip, LQFP48) ||\r\nchip->option.rts5129_D3318_off_enable) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL,\r\nDV3318_AUTO_PWR_OFF,\r\nDV3318_AUTO_PWR_OFF);\r\n}\r\n}\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, 0);\r\nif (!chip->option.FT2_fast_mode) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, POWER_MASK,\r\nPOWER_OFF);\r\n}\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (!chip->option.FT2_fast_mode) {\r\n#ifdef SD_XD_IO_FOLLOW_PWR\r\nif (CHECK_PKG(chip, LQFP48)\r\n|| chip->option.rts5129_D3318_off_enable) {\r\nrts51x_write_register(chip, CARD_PWR_CTL,\r\nLDO_OFF, LDO_OFF);\r\n}\r\n#endif\r\nwait_timeout(250);\r\n#ifdef SD_XD_IO_FOLLOW_PWR\r\nif (CHECK_PKG(chip, LQFP48)\r\n|| chip->option.rts5129_D3318_off_enable) {\r\nrts51x_init_cmd(chip);\r\nif (chip->asic_code) {\r\nxd_pull_ctl_enable(chip);\r\n} else {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD,\r\nFPGA_PULL_CTL, 0xFF,\r\n(FPGA_XD_PULL_CTL_EN1 &\r\nFPGA_XD_PULL_CTL_EN2));\r\n}\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n#endif\r\nretval = rts51x_card_power_on(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n#ifdef SUPPORT_OCP\r\nwait_timeout(50);\r\nrts51x_get_card_status(chip, &(chip->card_status));\r\nchip->ocp_stat = (chip->card_status >> 4) & 0x03;\r\nif (chip->ocp_stat & (MS_OCP_NOW | MS_OCP_EVER)) {\r\nRTS51X_DEBUGP("Over current, OCPSTAT is 0x%x\n",\r\nchip->ocp_stat);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n#endif\r\n}\r\nrts51x_init_cmd(chip);\r\nif (chip->asic_code)\r\nxd_pull_ctl_enable(chip);\r\nelse\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\r\n(FPGA_XD_PULL_CTL_EN1 & FPGA_XD_PULL_CTL_EN2));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN,\r\nXD_OUTPUT_EN);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CTL, XD_CE_DISEN, XD_CE_DISEN);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nif (!chip->option.FT2_fast_mode)\r\nwait_timeout(200);\r\nretval = xd_set_init_para(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nfor (i = 0; i < 4; i++) {\r\nu8 xd_dat, xd_ctl;\r\nif (monitor_card_cd(chip, XD_CARD) == CD_NOT_EXIST)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_DTCTL, 0xFF,\r\nXD_TIME_SETUP_STEP * 3 + XD_TIME_RW_STEP *\r\n(2 + i + chip->option.rts51x_xd_rw_step)\r\n+ XD_TIME_RWN_STEP * (i + chip->option.rts51x_xd_rwn_step));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CATCTL, 0xFF,\r\nXD_TIME_SETUP_STEP * 3 + XD_TIME_RW_STEP * (4 +\r\ni) + XD_TIME_RWN_STEP * (3 + i));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_RESET);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nrts51x_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\r\nrts51x_add_cmd(chip, READ_REG_CMD, XD_CTL, 0, 0);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nretval = rts51x_get_rsp(chip, 3, 100);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nxd_dat = chip->rsp_buf[1];\r\nxd_ctl = chip->rsp_buf[2];\r\nRTS51X_DEBUGP("XD_DAT: 0x%x, XD_CTL: 0x%x\n", xd_dat, xd_ctl);\r\nif (((xd_dat & READY_FLAG) != READY_STATE)\r\n|| !(xd_ctl & XD_RDY))\r\ncontinue;\r\nretval = xd_read_id(chip, READ_ID, id_buf, 4);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nRTS51X_DEBUGP("READ_ID: 0x%x 0x%x 0x%x 0x%x\n",\r\nid_buf[0], id_buf[1], id_buf[2], id_buf[3]);\r\nxd_card->device_code = id_buf[1];\r\nswitch (xd_card->device_code) {\r\ncase XD_4M_X8_512_1:\r\ncase XD_4M_X8_512_2:\r\nxd_card->block_shift = 4;\r\nxd_card->page_off = 0x0F;\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 1;\r\nxd_card->capacity = 8000;\r\nXD_SET_4MB(xd_card);\r\nbreak;\r\ncase XD_8M_X8_512:\r\nxd_card->block_shift = 4;\r\nxd_card->page_off = 0x0F;\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 1;\r\nxd_card->capacity = 16000;\r\nbreak;\r\ncase XD_16M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 1;\r\nxd_card->capacity = 32000;\r\nbreak;\r\ncase XD_32M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 2;\r\nxd_card->capacity = 64000;\r\nbreak;\r\ncase XD_64M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 4;\r\nxd_card->capacity = 128000;\r\nbreak;\r\ncase XD_128M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 8;\r\nxd_card->capacity = 256000;\r\nbreak;\r\ncase XD_256M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 16;\r\nxd_card->capacity = 512000;\r\nbreak;\r\ncase XD_512M_X8:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 32;\r\nxd_card->capacity = 1024000;\r\nbreak;\r\ncase xD_1G_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 64;\r\nxd_card->capacity = 2048000;\r\nbreak;\r\ncase xD_2G_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 128;\r\nxd_card->capacity = 4096000;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nfor (j = 0; j < 10; j++) {\r\nretval = xd_read_id(chip, READ_ID, id_buf, 4);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (id_buf[1] != xd_card->device_code)\r\nbreak;\r\n}\r\nif (j == 10)\r\nbreak;\r\n}\r\nif (i == 4) {\r\nxd_card->block_shift = 0;\r\nxd_card->page_off = 0;\r\nxd_card->addr_cycle = 0;\r\nxd_card->capacity = 0;\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = xd_read_id(chip, READ_xD_ID, id_buf, 4);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nRTS51X_DEBUGP("READ_xD_ID: 0x%x 0x%x 0x%x 0x%x\n",\r\nid_buf[0], id_buf[1], id_buf[2], id_buf[3]);\r\nif (id_buf[2] != XD_ID_CODE)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nfor (i = 0; i < 24; i++) {\r\nu32 page_addr;\r\nif (monitor_card_cd(chip, XD_CARD) == CD_NOT_EXIST)\r\nTRACE_RET(chip, STATUS_FAIL);\r\npage_addr = (u32) i << xd_card->block_shift;\r\nfor (j = 0; j < 3; j++) {\r\nretval = xd_read_redundant(chip, page_addr, redunt, 11);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\n}\r\nif (j == 3)\r\ncontinue;\r\nif (redunt[BLOCK_STATUS] != XD_GBLK)\r\ncontinue;\r\nj = 0;\r\nif (redunt[PAGE_STATUS] != XD_GPG) {\r\nfor (j = 1; j <= 8; j++) {\r\nretval =\r\nxd_read_redundant(chip, page_addr + j,\r\nredunt, 11);\r\nif (retval == STATUS_SUCCESS) {\r\nif (redunt[PAGE_STATUS] == XD_GPG)\r\nbreak;\r\n}\r\n}\r\nif (j == 9)\r\nbreak;\r\n}\r\nif ((redunt[BLOCK_STATUS] == XD_GBLK)\r\n&& (redunt[PARITY] & XD_BA1_ALL0)) {\r\nu8 buf[10];\r\npage_addr += j;\r\nretval = xd_read_cis(chip, page_addr, buf, 10);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif ((buf[0] == 0x01) && (buf[1] == 0x03)\r\n&& (buf[2] == 0xD9)\r\n&& (buf[3] == 0x01) && (buf[4] == 0xFF)\r\n&& (buf[5] == 0x18) && (buf[6] == 0x02)\r\n&& (buf[7] == 0xDF) && (buf[8] == 0x01)\r\n&& (buf[9] == 0x20)) {\r\nxd_card->cis_block = (u16) i;\r\n}\r\n}\r\nbreak;\r\n}\r\nRTS51X_DEBUGP("CIS block: 0x%x\n", xd_card->cis_block);\r\nif (xd_card->cis_block == 0xFFFF)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nchip->capacity[chip->card2lun[XD_CARD]] = xd_card->capacity;\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_check_data_blank(u8 *redunt)\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\nif (redunt[PAGE_STATUS + i] != 0xFF)\r\nreturn 0;\r\n}\r\nif ((redunt[PARITY] & (XD_ECC1_ALL1 | XD_ECC2_ALL1)) !=\r\n(XD_ECC1_ALL1 | XD_ECC2_ALL1))\r\nreturn 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (redunt[RESERVED0 + i] != 0xFF)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic u16 xd_load_log_block_addr(u8 *redunt)\r\n{\r\nu16 addr = 0xFFFF;\r\nif (redunt[PARITY] & XD_BA1_BA2_EQL)\r\naddr =\r\n((u16) redunt[BLOCK_ADDR1_H] << 8) | redunt[BLOCK_ADDR1_L];\r\nelse if (redunt[PARITY] & XD_BA1_VALID)\r\naddr =\r\n((u16) redunt[BLOCK_ADDR1_H] << 8) | redunt[BLOCK_ADDR1_L];\r\nelse if (redunt[PARITY] & XD_BA2_VALID)\r\naddr =\r\n((u16) redunt[BLOCK_ADDR2_H] << 8) | redunt[BLOCK_ADDR2_L];\r\nreturn addr;\r\n}\r\nstatic int xd_init_l2p_tbl(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint size, i;\r\nRTS51X_DEBUGP("xd_init_l2p_tbl: zone_cnt = %d\n", xd_card->zone_cnt);\r\nif (xd_card->zone_cnt < 1)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nsize = xd_card->zone_cnt * sizeof(struct zone_entry);\r\nRTS51X_DEBUGP("Buffer size for l2p table is %d\n", size);\r\nxd_card->zone = vmalloc(size);\r\nif (!xd_card->zone)\r\nTRACE_RET(chip, STATUS_NOMEM);\r\nfor (i = 0; i < xd_card->zone_cnt; i++) {\r\nxd_card->zone[i].build_flag = 0;\r\nxd_card->zone[i].l2p_table = NULL;\r\nxd_card->zone[i].free_table = NULL;\r\nxd_card->zone[i].get_index = 0;\r\nxd_card->zone[i].set_index = 0;\r\nxd_card->zone[i].unused_blk_cnt = 0;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic inline void free_zone(struct zone_entry *zone)\r\n{\r\nRTS51X_DEBUGP("free_zone\n");\r\nif (!zone)\r\nreturn;\r\nzone->build_flag = 0;\r\nzone->set_index = 0;\r\nzone->get_index = 0;\r\nzone->unused_blk_cnt = 0;\r\nif (zone->l2p_table) {\r\nvfree(zone->l2p_table);\r\nzone->l2p_table = NULL;\r\n}\r\nif (zone->free_table) {\r\nvfree(zone->free_table);\r\nzone->free_table = NULL;\r\n}\r\n}\r\nstatic void xd_set_unused_block(struct rts51x_chip *chip, u32 phy_blk)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct zone_entry *zone;\r\nint zone_no;\r\nzone_no = (int)phy_blk >> 10;\r\nif (zone_no >= xd_card->zone_cnt) {\r\nRTS51X_DEBUGP("Set unused block to invalid zone"\r\n"(zone_no = %d, zone_cnt = %d)\n",\r\nzone_no, xd_card->zone_cnt);\r\nreturn;\r\n}\r\nzone = &(xd_card->zone[zone_no]);\r\nif (zone->free_table == NULL) {\r\nif (xd_build_l2p_tbl(chip, zone_no) != STATUS_SUCCESS)\r\nreturn;\r\n}\r\nif ((zone->set_index >= XD_FREE_TABLE_CNT)\r\n|| (zone->set_index < 0)) {\r\nfree_zone(zone);\r\nRTS51X_DEBUGP("Set unused block fail, invalid set_index\n");\r\nreturn;\r\n}\r\nRTS51X_DEBUGP("Set unused block to index %d\n", zone->set_index);\r\nzone->free_table[zone->set_index++] = (u16) (phy_blk & 0x3ff);\r\nif (zone->set_index >= XD_FREE_TABLE_CNT)\r\nzone->set_index = 0;\r\nzone->unused_blk_cnt++;\r\n}\r\nstatic u32 xd_get_unused_block(struct rts51x_chip *chip, int zone_no)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct zone_entry *zone;\r\nu32 phy_blk;\r\nif (zone_no >= xd_card->zone_cnt) {\r\nRTS51X_DEBUGP("Get unused block from invalid zone"\r\n"(zone_no = %d, zone_cnt = %d)\n",\r\nzone_no, xd_card->zone_cnt);\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nzone = &(xd_card->zone[zone_no]);\r\nif ((zone->unused_blk_cnt == 0) ||\r\n(zone->set_index == zone->get_index)) {\r\nfree_zone(zone);\r\nRTS51X_DEBUGP("Get unused block fail,"\r\n"no unused block available\n");\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nif ((zone->get_index >= XD_FREE_TABLE_CNT) || (zone->get_index < 0)) {\r\nfree_zone(zone);\r\nRTS51X_DEBUGP("Get unused block fail, invalid get_index\n");\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nRTS51X_DEBUGP("Get unused block from index %d\n", zone->get_index);\r\nphy_blk = zone->free_table[zone->get_index];\r\nzone->free_table[zone->get_index++] = 0xFFFF;\r\nif (zone->get_index >= XD_FREE_TABLE_CNT)\r\nzone->get_index = 0;\r\nzone->unused_blk_cnt--;\r\nphy_blk += ((u32) (zone_no) << 10);\r\nreturn phy_blk;\r\n}\r\nstatic void xd_set_l2p_tbl(struct rts51x_chip *chip, int zone_no, u16 log_off,\r\nu16 phy_off)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct zone_entry *zone;\r\nzone = &(xd_card->zone[zone_no]);\r\nzone->l2p_table[log_off] = phy_off;\r\n}\r\nstatic u32 xd_get_l2p_tbl(struct rts51x_chip *chip, int zone_no, u16 log_off)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct zone_entry *zone;\r\nint retval;\r\nzone = &(xd_card->zone[zone_no]);\r\nif (zone->l2p_table[log_off] == 0xFFFF) {\r\nu32 phy_blk = 0;\r\nint i;\r\nretval = xd_delay_write(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nRTS51X_DEBUGP("In xd_get_l2p_tbl,"\r\n"delay write fail!\n");\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nif (zone->unused_blk_cnt <= 0) {\r\nRTS51X_DEBUGP("No unused block!\n");\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nfor (i = 0; i < zone->unused_blk_cnt; i++) {\r\nphy_blk = xd_get_unused_block(chip, zone_no);\r\nif (phy_blk == BLK_NOT_FOUND) {\r\nRTS51X_DEBUGP("No unused block available!\n");\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nretval =\r\nxd_init_page(chip, phy_blk, log_off, 0,\r\nxd_card->page_off + 1);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\n}\r\nif (i >= zone->unused_blk_cnt) {\r\nRTS51X_DEBUGP("No good unused block available!\n");\r\nTRACE_RET(chip, BLK_NOT_FOUND);\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16) (phy_blk & 0x3FF));\r\nreturn phy_blk;\r\n}\r\nreturn (u32) zone->l2p_table[log_off] + ((u32) (zone_no) << 10);\r\n}\r\nint rts51x_reset_xd_card(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval;\r\nmemset(xd_card, 0, sizeof(struct xd_info));\r\nxd_card->block_shift = 0;\r\nxd_card->page_off = 0;\r\nxd_card->addr_cycle = 0;\r\nxd_card->capacity = 0;\r\nxd_card->zone_cnt = 0;\r\nxd_card->cis_block = 0xFFFF;\r\nxd_card->delay_write.delay_write_flag = 0;\r\nrts51x_enable_card_clock(chip, XD_CARD);\r\nretval = reset_xd(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nif (chip->option.reset_or_rw_fail_set_pad_drive) {\r\nrts51x_write_register(chip, CARD_DRIVE_SEL,\r\nSD20_DRIVE_MASK, DRIVE_8mA);\r\n}\r\nTRACE_RET(chip, retval);\r\n}\r\nretval = xd_init_l2p_tbl(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_mark_bad_block(struct rts51x_chip *chip, u32 phy_blk)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval;\r\nu32 page_addr;\r\nu8 reg = 0;\r\nRTS51X_DEBUGP("mark block 0x%x as bad block\n", phy_blk);\r\nif (phy_blk == BLK_NOT_FOUND)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, XD_GPG);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF,\r\nXD_LATER_BBLK);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR2_H, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR2_L, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED0, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED1, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED2, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED3, 0xFF, 0xFF);\r\npage_addr = phy_blk << xd_card->block_shift;\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF,\r\nxd_card->page_off + 1);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_WRITE_REDUNDANT);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nretval = rts51x_get_rsp(chip, 1, 100);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nrts51x_ep0_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR)\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nelse\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_init_page(struct rts51x_chip *chip, u32 phy_blk, u16 logoff,\r\nu8 start_page, u8 end_page)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval;\r\nu32 page_addr;\r\nu8 reg = 0;\r\nRTS51X_DEBUGP("Init block 0x%x\n", phy_blk);\r\nif (start_page > end_page)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nif (phy_blk == BLK_NOT_FOUND)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, 0xFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H, 0xFF,\r\n(u8) (logoff >> 8));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF,\r\n(u8) logoff);\r\npage_addr = (phy_blk << xd_card->block_shift) + start_page;\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_BA_TRANSFORM,\r\nXD_BA_TRANSFORM);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF,\r\n(end_page - start_page));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_WRITE_REDUNDANT);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nretval = rts51x_get_rsp(chip, 1, 500);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nrts51x_ep0_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\n} else {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\n}\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_copy_page(struct rts51x_chip *chip,\r\nu32 old_blk, u32 new_blk, u8 start_page, u8 end_page)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nu32 old_page, new_page;\r\nu8 i, reg = 0;\r\nint retval;\r\nRTS51X_DEBUGP("Copy page from block 0x%x to block 0x%x\n", old_blk,\r\nnew_blk);\r\nif (start_page > end_page)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nif ((old_blk == BLK_NOT_FOUND) || (new_blk == BLK_NOT_FOUND))\r\nTRACE_RET(chip, STATUS_FAIL);\r\nold_page = (old_blk << xd_card->block_shift) + start_page;\r\nnew_page = (new_blk << xd_card->block_shift) + start_page;\r\nXD_CLR_BAD_NEWBLK(xd_card);\r\nRTS51X_WRITE_REG(chip, CARD_DATA_SOURCE, 0x01, PINGPONG_BUFFER);\r\nfor (i = start_page; i < end_page; i++) {\r\nif (monitor_card_cd(chip, XD_CARD) == CD_NOT_EXIST) {\r\nRTS51X_WRITE_REG(chip, CARD_STOP, XD_STOP | XD_CLR_ERR,\r\nXD_STOP | XD_CLR_ERR);\r\nxd_set_err_code(chip, XD_NO_CARD);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nrts51x_init_cmd(chip);\r\nxd_assign_phy_addr(chip, old_page, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\r\nXD_AUTO_CHK_DATA_STATUS, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_PAGES);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rts51x_send_cmd(chip, MODE_CR | STAGE_XD_STATUS, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 4, 500);\r\nif ((retval != STATUS_SUCCESS) ||\r\n(chip->rsp_buf[2] & (XD_ECC1_ERROR | XD_ECC2_ERROR))) {\r\nrts51x_clear_xd_error(chip);\r\nreg = 0;\r\nrts51x_ep0_read_register(chip, XD_CTL, &reg);\r\nif (reg & (XD_ECC1_ERROR | XD_ECC2_ERROR)) {\r\nwait_timeout(100);\r\nif (monitor_card_cd(chip, XD_CARD) ==\r\nCD_NOT_EXIST) {\r\nxd_set_err_code(chip, XD_NO_CARD);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (((reg &\r\n(XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE))\r\n== (XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE))\r\n|| ((reg & (XD_ECC2_ERROR |\r\nXD_ECC2_UNCORRECTABLE)) ==\r\n(XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE))) {\r\nRTS51X_WRITE_REG(chip, XD_PAGE_STATUS,\r\n0xFF, XD_BPG);\r\nRTS51X_WRITE_REG(chip, XD_BLOCK_STATUS,\r\n0xFF, XD_GBLK);\r\nXD_SET_BAD_OLDBLK(xd_card);\r\nRTS51X_DEBUGP("old block 0x%x"\r\n"ecc error\n", old_blk);\r\n}\r\n} else {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nif (XD_CHK_BAD_OLDBLK(xd_card))\r\nrts51x_clear_xd_error(chip);\r\nrts51x_init_cmd(chip);\r\nxd_assign_phy_addr(chip, new_page, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_WRITE_PAGES);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 1, 300);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nreg = 0;\r\nrts51x_ep0_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, new_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nXD_SET_BAD_NEWBLK(xd_card);\r\n} else {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\n}\r\nTRACE_RET(chip, retval);\r\n}\r\nold_page++;\r\nnew_page++;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_reset_cmd(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nu8 xd_dat, xd_ctl;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_RESET);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nrts51x_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\r\nrts51x_add_cmd(chip, READ_REG_CMD, XD_CTL, 0, 0);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 3, 100);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nxd_dat = chip->rsp_buf[1];\r\nxd_ctl = chip->rsp_buf[2];\r\nif (((xd_dat & READY_FLAG) == READY_STATE) && (xd_ctl & XD_RDY))\r\nreturn STATUS_SUCCESS;\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nstatic int xd_erase_block(struct rts51x_chip *chip, u32 phy_blk)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nu32 page_addr;\r\nu8 reg = 0, xd_dat;\r\nint i, retval;\r\nif (phy_blk == BLK_NOT_FOUND)\r\nTRACE_RET(chip, STATUS_FAIL);\r\npage_addr = phy_blk << xd_card->block_shift;\r\nfor (i = 0; i < 3; i++) {\r\nrts51x_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_ERASE_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_ERASE);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nrts51x_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 2, 300);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nrts51x_ep0_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n} else {\r\nxd_set_err_code(chip, XD_ERASE_FAIL);\r\n}\r\nretval = xd_reset_cmd(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\ncontinue;\r\n}\r\nxd_dat = chip->rsp_buf[1];\r\nif (xd_dat & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_ERASE_FAIL);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nstatic int xd_build_l2p_tbl(struct rts51x_chip *chip, int zone_no)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct zone_entry *zone;\r\nint retval;\r\nu32 start, end, i;\r\nu16 max_logoff, cur_fst_page_logoff, cur_lst_page_logoff,\r\nent_lst_page_logoff;\r\nu8 redunt[11];\r\nRTS51X_DEBUGP("xd_build_l2p_tbl: %d\n", zone_no);\r\nif (xd_card->zone == NULL) {\r\nretval = xd_init_l2p_tbl(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n}\r\nif (xd_card->zone[zone_no].build_flag) {\r\nRTS51X_DEBUGP("l2p table of zone %d has been built\n",\r\nzone_no);\r\nreturn STATUS_SUCCESS;\r\n}\r\nzone = &(xd_card->zone[zone_no]);\r\nif (zone->l2p_table == NULL) {\r\nzone->l2p_table = vmalloc(2000);\r\nif (zone->l2p_table == NULL)\r\nTRACE_GOTO(chip, Build_Fail);\r\n}\r\nmemset((u8 *) (zone->l2p_table), 0xff, 2000);\r\nif (zone->free_table == NULL) {\r\nzone->free_table = vmalloc(XD_FREE_TABLE_CNT * 2);\r\nif (zone->free_table == NULL)\r\nTRACE_GOTO(chip, Build_Fail);\r\n}\r\nmemset((u8 *) (zone->free_table), 0xff, XD_FREE_TABLE_CNT * 2);\r\nif (zone_no == 0) {\r\nif (xd_card->cis_block == 0xFFFF)\r\nstart = 0;\r\nelse\r\nstart = xd_card->cis_block + 1;\r\nif (XD_CHK_4MB(xd_card)) {\r\nend = 0x200;\r\nmax_logoff = 499;\r\n} else {\r\nend = 0x400;\r\nmax_logoff = 999;\r\n}\r\n} else {\r\nstart = (u32) (zone_no) << 10;\r\nend = (u32) (zone_no + 1) << 10;\r\nmax_logoff = 999;\r\n}\r\nRTS51X_DEBUGP("start block 0x%x, end block 0x%x\n", start, end);\r\nzone->set_index = zone->get_index = 0;\r\nzone->unused_blk_cnt = 0;\r\nfor (i = start; i < end; i++) {\r\nu32 page_addr = i << xd_card->block_shift;\r\nu32 phy_block;\r\nretval = xd_read_redundant(chip, page_addr, redunt, 11);\r\nif (retval != STATUS_SUCCESS)\r\ncontinue;\r\nif (redunt[BLOCK_STATUS] != 0xFF) {\r\nRTS51X_DEBUGP("bad block\n");\r\ncontinue;\r\n}\r\nif (xd_check_data_blank(redunt)) {\r\nRTS51X_DEBUGP("blank block\n");\r\nxd_set_unused_block(chip, i);\r\ncontinue;\r\n}\r\ncur_fst_page_logoff = xd_load_log_block_addr(redunt);\r\nif ((cur_fst_page_logoff == 0xFFFF)\r\n|| (cur_fst_page_logoff > max_logoff)) {\r\nretval = xd_erase_block(chip, i);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, i);\r\ncontinue;\r\n}\r\nif ((zone_no == 0) && (cur_fst_page_logoff == 0)\r\n&& (redunt[PAGE_STATUS] != XD_GPG))\r\nXD_SET_MBR_FAIL(xd_card);\r\nif (zone->l2p_table[cur_fst_page_logoff] == 0xFFFF) {\r\nzone->l2p_table[cur_fst_page_logoff] =\r\n(u16) (i & 0x3FF);\r\ncontinue;\r\n}\r\nphy_block =\r\nzone->l2p_table[cur_fst_page_logoff] +\r\n((u32) ((zone_no) << 10));\r\npage_addr = ((i + 1) << xd_card->block_shift) - 1;\r\nretval = xd_read_redundant(chip, page_addr, redunt, 11);\r\nif (retval != STATUS_SUCCESS)\r\ncontinue;\r\ncur_lst_page_logoff = xd_load_log_block_addr(redunt);\r\nif (cur_lst_page_logoff == cur_fst_page_logoff) {\r\nint m;\r\npage_addr =\r\n((phy_block + 1) << xd_card->block_shift) - 1;\r\nfor (m = 0; m < 3; m++) {\r\nretval =\r\nxd_read_redundant(chip, page_addr, redunt,\r\n11);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\n}\r\nif (m == 3) {\r\nzone->l2p_table[cur_fst_page_logoff] =\r\n(u16) (i & 0x3FF);\r\nretval = xd_erase_block(chip, phy_block);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, phy_block);\r\ncontinue;\r\n}\r\nent_lst_page_logoff = xd_load_log_block_addr(redunt);\r\nif (ent_lst_page_logoff != cur_fst_page_logoff) {\r\nzone->l2p_table[cur_fst_page_logoff] =\r\n(u16) (i & 0x3FF);\r\nretval = xd_erase_block(chip, phy_block);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, phy_block);\r\ncontinue;\r\n} else {\r\nretval = xd_erase_block(chip, i);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, i);\r\n}\r\n} else {\r\nretval = xd_erase_block(chip, i);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, i);\r\n}\r\n}\r\nif (XD_CHK_4MB(xd_card))\r\nend = 500;\r\nelse\r\nend = 1000;\r\ni = 0;\r\nfor (start = 0; start < end; start++) {\r\nif (zone->l2p_table[start] == 0xFFFF)\r\ni++;\r\n}\r\nRTS51X_DEBUGP("Block count %d, invalid L2P entry %d\n", end, i);\r\nRTS51X_DEBUGP("Total unused block: %d\n", zone->unused_blk_cnt);\r\nif ((zone->unused_blk_cnt - i) < 1)\r\nchip->card_wp |= XD_CARD;\r\nzone->build_flag = 1;\r\nreturn STATUS_SUCCESS;\r\nBuild_Fail:\r\nif (zone->l2p_table) {\r\nvfree(zone->l2p_table);\r\nzone->l2p_table = NULL;\r\n}\r\nif (zone->free_table) {\r\nvfree(zone->free_table);\r\nzone->free_table = NULL;\r\n}\r\nreturn STATUS_FAIL;\r\n}\r\nstatic int xd_send_cmd(struct rts51x_chip *chip, u8 cmd)\r\n{\r\nint retval;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_DAT, 0xFF, cmd);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_SET_CMD);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 1, 200);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nTRACE_RET(chip, retval);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_multiple_pages(struct rts51x_chip *chip, u32 phy_blk,\r\nu32 log_blk, u8 start_page, u8 end_page,\r\nu8 *buf, void **ptr, unsigned int *offset)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nu32 page_addr, new_blk;\r\nu16 log_off;\r\nu8 reg_val, page_cnt;\r\nint zone_no, retval, i;\r\nif (start_page > end_page)\r\nTRACE_RET(chip, STATUS_FAIL);\r\npage_cnt = end_page - start_page;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16) (log_blk % 1000);\r\nif ((phy_blk & 0x3FF) == 0x3FF) {\r\nfor (i = 0; i < 256; i++) {\r\npage_addr = ((u32) i) << xd_card->block_shift;\r\nretval = xd_read_redundant(chip, page_addr, NULL, 0);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\nif (monitor_card_cd(chip, XD_CARD) == CD_NOT_EXIST) {\r\nxd_set_err_code(chip, XD_NO_CARD);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\n}\r\npage_addr = (phy_blk << xd_card->block_shift) + start_page;\r\nrts51x_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_PPB_TO_SIE,\r\nXD_PPB_TO_SIE);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01,\r\nRING_BUFFER);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, page_cnt);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\r\nXD_AUTO_CHK_DATA_STATUS, XD_AUTO_CHK_DATA_STATUS);\r\nrts51x_trans_dma_enable(chip->srb->sc_data_direction, chip, page_cnt * 512,\r\nDMA_512);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_PAGES);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END | XD_PPB_EMPTY,\r\nXD_TRANSFER_END | XD_PPB_EMPTY);\r\nretval = rts51x_send_cmd(chip, MODE_CDIR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval =\r\nrts51x_transfer_data_partial(chip, RCV_BULK_PIPE(chip), (void *)buf,\r\nptr, offset, page_cnt * 512,\r\nscsi_sg_count(chip->srb), NULL, 2000);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nif (retval == STATUS_TIMEDOUT) {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nTRACE_RET(chip, retval);\r\n} else {\r\nTRACE_GOTO(chip, Fail);\r\n}\r\n}\r\nretval = rts51x_get_rsp(chip, 1, 200);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nif (retval == STATUS_TIMEDOUT) {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nTRACE_RET(chip, retval);\r\n} else {\r\nTRACE_GOTO(chip, Fail);\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\nFail:\r\nrts51x_ep0_read_register(chip, XD_PAGE_STATUS, &reg_val);\r\nRTS51X_DEBUGP("XD_PAGE_STATUS: 0x%x\n", reg_val);\r\nif (reg_val != XD_GPG)\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nrts51x_ep0_read_register(chip, XD_CTL, &reg_val);\r\nRTS51X_DEBUGP("XD_CTL: 0x%x\n", reg_val);\r\nif (((reg_val & (XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE))\r\n== (XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE))\r\n|| ((reg_val & (XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE))\r\n== (XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE))) {\r\nwait_timeout(100);\r\nif (monitor_card_cd(chip, XD_CARD) == CD_NOT_EXIST) {\r\nxd_set_err_code(chip, XD_NO_CARD);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nxd_set_err_code(chip, XD_ECC_ERROR);\r\nnew_blk = xd_get_unused_block(chip, zone_no);\r\nif (new_blk == NO_NEW_BLK) {\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval =\r\nxd_copy_page(chip, phy_blk, new_blk, 0,\r\nxd_card->page_off + 1);\r\nif (retval != STATUS_SUCCESS) {\r\nif (!XD_CHK_BAD_NEWBLK(xd_card)) {\r\nretval = xd_erase_block(chip, new_blk);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, new_blk);\r\n} else {\r\nXD_CLR_BAD_NEWBLK(xd_card);\r\n}\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16) (new_blk & 0x3FF));\r\nxd_erase_block(chip, phy_blk);\r\nxd_mark_bad_block(chip, phy_blk);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n}\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nstatic int xd_finish_write(struct rts51x_chip *chip,\r\nu32 old_blk, u32 new_blk, u32 log_blk, u8 page_off)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval, zone_no;\r\nu16 log_off;\r\nRTS51X_DEBUGP("xd_finish_write, old_blk = 0x%x, new_blk = 0x%x,"\r\n"log_blk = 0x%x\n", old_blk, new_blk, log_blk);\r\nif (page_off > xd_card->page_off)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16) (log_blk % 1000);\r\nif (old_blk == BLK_NOT_FOUND) {\r\nretval = xd_init_page(chip, new_blk, log_off,\r\npage_off, xd_card->page_off + 1);\r\nif (retval != STATUS_SUCCESS) {\r\nretval = xd_erase_block(chip, new_blk);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, new_blk);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else {\r\nretval = xd_copy_page(chip, old_blk, new_blk,\r\npage_off, xd_card->page_off + 1);\r\nif (retval != STATUS_SUCCESS) {\r\nif (!XD_CHK_BAD_NEWBLK(xd_card)) {\r\nretval = xd_erase_block(chip, new_blk);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, new_blk);\r\n}\r\nXD_CLR_BAD_NEWBLK(xd_card);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval = xd_erase_block(chip, old_blk);\r\nif (retval == STATUS_SUCCESS) {\r\nif (XD_CHK_BAD_OLDBLK(xd_card)) {\r\nxd_mark_bad_block(chip, old_blk);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n} else {\r\nxd_set_unused_block(chip, old_blk);\r\n}\r\n} else {\r\nxd_set_err_code(chip, XD_NO_ERROR);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n}\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16) (new_blk & 0x3FF));\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_prepare_write(struct rts51x_chip *chip,\r\nu32 old_blk, u32 new_blk, u32 log_blk, u8 page_off)\r\n{\r\nint retval;\r\nRTS51X_DEBUGP("xd_prepare_write, old_blk = 0x%x, new_blk = 0x%x,"\r\n"log_blk = 0x%x, page_off = %d\n",\r\nold_blk, new_blk, log_blk, (int)page_off);\r\nif (page_off) {\r\nretval = xd_copy_page(chip, old_blk, new_blk, 0, page_off);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_write_multiple_pages(struct rts51x_chip *chip, u32 old_blk,\r\nu32 new_blk, u32 log_blk, u8 start_page,\r\nu8 end_page, u8 *buf, void **ptr,\r\nunsigned int *offset)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nu32 page_addr;\r\nint zone_no, retval;\r\nu16 log_off;\r\nu8 page_cnt, reg_val;\r\nRTS51X_DEBUGP("xd_write_multiple_pages, old_blk = 0x%x,"\r\n"new_blk = 0x%x, log_blk = 0x%x\n",\r\nold_blk, new_blk, log_blk);\r\nif (start_page > end_page)\r\nTRACE_RET(chip, STATUS_FAIL);\r\npage_cnt = end_page - start_page;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16) (log_blk % 1000);\r\npage_addr = (new_blk << xd_card->block_shift) + start_page;\r\nretval = xd_send_cmd(chip, READ1_1);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H, 0xFF,\r\n(u8) (log_off >> 8));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF,\r\n(u8) log_off);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, XD_GBLK);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, XD_GPG);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_BA_TRANSFORM,\r\nXD_BA_TRANSFORM);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, page_cnt);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01,\r\nRING_BUFFER);\r\nrts51x_trans_dma_enable(chip->srb->sc_data_direction, chip, page_cnt * 512,\r\nDMA_512);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_WRITE_PAGES);\r\nrts51x_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nretval = rts51x_send_cmd(chip, MODE_CDOR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval =\r\nrts51x_transfer_data_partial(chip, SND_BULK_PIPE(chip), (void *)buf,\r\nptr, offset, page_cnt * 512,\r\nscsi_sg_count(chip->srb), NULL, 2000);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nif (retval == STATUS_TIMEDOUT) {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nTRACE_RET(chip, retval);\r\n} else {\r\nTRACE_GOTO(chip, Fail);\r\n}\r\n}\r\nretval = rts51x_get_rsp(chip, 1, 200);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_clear_xd_error(chip);\r\nif (retval == STATUS_TIMEDOUT) {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nTRACE_RET(chip, retval);\r\n} else {\r\nTRACE_GOTO(chip, Fail);\r\n}\r\n}\r\nif (end_page == (xd_card->page_off + 1)) {\r\nxd_card->delay_write.delay_write_flag = 0;\r\nif (old_blk != BLK_NOT_FOUND) {\r\nretval = xd_erase_block(chip, old_blk);\r\nif (retval == STATUS_SUCCESS) {\r\nif (XD_CHK_BAD_OLDBLK(xd_card)) {\r\nxd_mark_bad_block(chip, old_blk);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n} else {\r\nxd_set_unused_block(chip, old_blk);\r\n}\r\n} else {\r\nxd_set_err_code(chip, XD_NO_ERROR);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n}\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16) (new_blk & 0x3FF));\r\n}\r\nreturn STATUS_SUCCESS;\r\nFail:\r\nrts51x_ep0_read_register(chip, XD_DAT, &reg_val);\r\nRTS51X_DEBUGP("XD_DAT: 0x%x\n", reg_val);\r\nif (reg_val & PROGRAM_ERROR) {\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nxd_mark_bad_block(chip, new_blk);\r\n}\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nstatic int xd_delay_write(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct xd_delay_write_tag *delay_write = &(xd_card->delay_write);\r\nint retval;\r\nif (delay_write->delay_write_flag) {\r\nRTS51X_DEBUGP("xd_delay_write\n");\r\nretval = xd_switch_clock(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\ndelay_write->delay_write_flag = 0;\r\nretval = xd_finish_write(chip,\r\ndelay_write->old_phyblock,\r\ndelay_write->new_phyblock,\r\ndelay_write->logblock,\r\ndelay_write->pageoff);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_xd_rw(struct scsi_cmnd *srb, struct rts51x_chip *chip, u32 start_sector,\r\nu16 sector_cnt)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nunsigned int lun = SCSI_LUN(srb);\r\nstruct xd_delay_write_tag *delay_write = &(xd_card->delay_write);\r\nint retval, zone_no;\r\nu32 log_blk, old_blk = 0, new_blk = 0;\r\nu16 log_off, total_sec_cnt = sector_cnt;\r\nu8 start_page, end_page = 0, page_cnt;\r\nu8 *buf;\r\nvoid *ptr = NULL;\r\nunsigned int offset = 0;\r\nxd_set_err_code(chip, XD_NO_ERROR);\r\nxd_card->counter = 0;\r\nRTS51X_DEBUGP("rts51x_xd_rw: scsi_bufflen = %d, scsi_sg_count = %d\n",\r\nscsi_bufflen(srb), scsi_sg_count(srb));\r\nRTS51X_DEBUGP("Data direction: %s\n",\r\n(srb->sc_data_direction ==\r\nDMA_TO_DEVICE) ? "write" : "read");\r\nbuf = (u8 *) scsi_sglist(srb);\r\nretval = xd_switch_clock(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nlog_blk = start_sector >> xd_card->block_shift;\r\nstart_page = (u8) start_sector & xd_card->page_off;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16) (log_blk % 1000);\r\nRTS51X_DEBUGP("log_blk = 0x%x\n", log_blk);\r\nif (xd_card->zone[zone_no].build_flag == 0) {\r\nretval = xd_build_l2p_tbl(chip, zone_no);\r\nif (retval != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nrts51x_set_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, retval);\r\n}\r\n}\r\nif (srb->sc_data_direction == DMA_TO_DEVICE) {\r\nif (delay_write->delay_write_flag &&\r\n(delay_write->logblock == log_blk) &&\r\n(start_page > delay_write->pageoff)) {\r\ndelay_write->delay_write_flag = 0;\r\nif (delay_write->old_phyblock != BLK_NOT_FOUND) {\r\nretval = xd_copy_page(chip,\r\ndelay_write->old_phyblock,\r\ndelay_write->new_phyblock,\r\ndelay_write->pageoff,\r\nstart_page);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, retval);\r\n}\r\n}\r\nold_blk = delay_write->old_phyblock;\r\nnew_blk = delay_write->new_phyblock;\r\n} else if (delay_write->delay_write_flag &&\r\n(delay_write->logblock == log_blk) &&\r\n(start_page == delay_write->pageoff)) {\r\ndelay_write->delay_write_flag = 0;\r\nold_blk = delay_write->old_phyblock;\r\nnew_blk = delay_write->new_phyblock;\r\n} else {\r\nretval = xd_delay_write(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, retval);\r\n}\r\nold_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\r\nnew_blk = xd_get_unused_block(chip, zone_no);\r\nif ((old_blk == BLK_NOT_FOUND)\r\n|| (new_blk == BLK_NOT_FOUND)) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, retval);\r\n}\r\nretval =\r\nxd_prepare_write(chip, old_blk, new_blk, log_blk,\r\nstart_page);\r\nif (retval != STATUS_SUCCESS) {\r\nif (monitor_card_cd(chip, XD_CARD) ==\r\nCD_NOT_EXIST) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, retval);\r\n}\r\n}\r\n} else {\r\nretval = xd_delay_write(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nif (monitor_card_cd(chip, XD_CARD) == CD_NOT_EXIST) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, retval);\r\n}\r\nold_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\r\nif (old_blk == BLK_NOT_FOUND) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nRTS51X_DEBUGP("old_blk = 0x%x\n", old_blk);\r\nif (srb->sc_data_direction == DMA_TO_DEVICE)\r\nRTS51X_DEBUGP("new_blk = 0x%x\n", new_blk);\r\nwhile (total_sec_cnt) {\r\nif ((start_page + total_sec_cnt) > (xd_card->page_off + 1))\r\nend_page = xd_card->page_off + 1;\r\nelse\r\nend_page = start_page + (u8) total_sec_cnt;\r\npage_cnt = end_page - start_page;\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE) {\r\nretval = xd_read_multiple_pages(chip, old_blk, log_blk,\r\nstart_page, end_page,\r\nbuf, &ptr, &offset);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n} else {\r\nretval =\r\nxd_write_multiple_pages(chip, old_blk, new_blk,\r\nlog_blk, start_page,\r\nend_page, buf, &ptr,\r\n&offset);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\ntotal_sec_cnt -= page_cnt;\r\nif (total_sec_cnt == 0)\r\nbreak;\r\nlog_blk++;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16) (log_blk % 1000);\r\nif (xd_card->zone[zone_no].build_flag == 0) {\r\nretval = xd_build_l2p_tbl(chip, zone_no);\r\nif (retval != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nTRACE_RET(chip, retval);\r\n}\r\n}\r\nold_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\r\nif (old_blk == BLK_NOT_FOUND) {\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\n} else {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\n}\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (srb->sc_data_direction == DMA_TO_DEVICE) {\r\nnew_blk = xd_get_unused_block(chip, zone_no);\r\nif (new_blk == BLK_NOT_FOUND) {\r\nrts51x_set_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\n}\r\nstart_page = 0;\r\n}\r\nif ((srb->sc_data_direction == DMA_TO_DEVICE) &&\r\n(end_page != (xd_card->page_off + 1))) {\r\ndelay_write->delay_write_flag = 1;\r\ndelay_write->old_phyblock = old_blk;\r\ndelay_write->new_phyblock = new_blk;\r\ndelay_write->logblock = log_blk;\r\ndelay_write->pageoff = end_page;\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rts51x_xd_free_l2p_tbl(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint i = 0;\r\nif (xd_card->zone != NULL) {\r\nfor (i = 0; i < xd_card->zone_cnt; i++) {\r\nif (xd_card->zone[i].l2p_table != NULL) {\r\nvfree(xd_card->zone[i].l2p_table);\r\nxd_card->zone[i].l2p_table = NULL;\r\n}\r\nif (xd_card->zone[i].free_table != NULL) {\r\nvfree(xd_card->zone[i].free_table);\r\nxd_card->zone[i].free_table = NULL;\r\n}\r\n}\r\nvfree(xd_card->zone);\r\nxd_card->zone = NULL;\r\n}\r\n}\r\nvoid rts51x_xd_cleanup_work(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nif (xd_card->delay_write.delay_write_flag) {\r\nRTS51X_DEBUGP("xD: delay write\n");\r\nxd_delay_write(chip);\r\nxd_card->counter = 0;\r\n}\r\n}\r\nstatic int xd_power_off_card3v3(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_CLK_EN, XD_CLK_EN, 0);\r\nif (chip->asic_code)\r\nxd_pull_ctl_disable(chip);\r\nelse\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF, 0xDF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, 0);\r\nif (!chip->option.FT2_fast_mode) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, POWER_MASK,\r\nPOWER_OFF);\r\nif (CHECK_PKG(chip, LQFP48)\r\n|| chip->option.rts5129_D3318_off_enable)\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL,\r\nDV3318_AUTO_PWR_OFF, 0);\r\n}\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_release_xd_card(struct rts51x_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nint retval;\r\nRTS51X_DEBUGP("rts51x_release_xd_card\n");\r\nchip->card_ready &= ~XD_CARD;\r\nchip->card_fail &= ~XD_CARD;\r\nchip->card_wp &= ~XD_CARD;\r\nxd_card->delay_write.delay_write_flag = 0;\r\nrts51x_xd_free_l2p_tbl(chip);\r\nrts51x_write_register(chip, SFSM_ED, HW_CMD_STOP, HW_CMD_STOP);\r\nretval = xd_power_off_card3v3(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (chip->asic_code && CHECK_PKG(chip, QFN24))\r\nwait_timeout(20);\r\nreturn STATUS_SUCCESS;\r\n}
