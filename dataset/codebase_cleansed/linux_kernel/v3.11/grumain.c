int gru_cpu_fault_map_id(void)\r\n{\r\n#ifdef CONFIG_IA64\r\nreturn uv_blade_processor_id() % GRU_NUM_TFM;\r\n#else\r\nint cpu = smp_processor_id();\r\nint id, core;\r\ncore = uv_cpu_core_number(cpu);\r\nid = core + UV_MAX_INT_CORES * uv_cpu_socket_number(cpu);\r\nreturn id;\r\n#endif\r\n}\r\nstatic int gru_wrap_asid(struct gru_state *gru)\r\n{\r\ngru_dbg(grudev, "gid %d\n", gru->gs_gid);\r\nSTAT(asid_wrap);\r\ngru->gs_asid_gen++;\r\nreturn MIN_ASID;\r\n}\r\nstatic int gru_reset_asid_limit(struct gru_state *gru, int asid)\r\n{\r\nint i, gid, inuse_asid, limit;\r\ngru_dbg(grudev, "gid %d, asid 0x%x\n", gru->gs_gid, asid);\r\nSTAT(asid_next);\r\nlimit = MAX_ASID;\r\nif (asid >= limit)\r\nasid = gru_wrap_asid(gru);\r\ngru_flush_all_tlb(gru);\r\ngid = gru->gs_gid;\r\nagain:\r\nfor (i = 0; i < GRU_NUM_CCH; i++) {\r\nif (!gru->gs_gts[i] || is_kernel_context(gru->gs_gts[i]))\r\ncontinue;\r\ninuse_asid = gru->gs_gts[i]->ts_gms->ms_asids[gid].mt_asid;\r\ngru_dbg(grudev, "gid %d, gts %p, gms %p, inuse 0x%x, cxt %d\n",\r\ngru->gs_gid, gru->gs_gts[i], gru->gs_gts[i]->ts_gms,\r\ninuse_asid, i);\r\nif (inuse_asid == asid) {\r\nasid += ASID_INC;\r\nif (asid >= limit) {\r\nlimit = MAX_ASID;\r\nif (asid >= MAX_ASID)\r\nasid = gru_wrap_asid(gru);\r\ngoto again;\r\n}\r\n}\r\nif ((inuse_asid > asid) && (inuse_asid < limit))\r\nlimit = inuse_asid;\r\n}\r\ngru->gs_asid_limit = limit;\r\ngru->gs_asid = asid;\r\ngru_dbg(grudev, "gid %d, new asid 0x%x, new_limit 0x%x\n", gru->gs_gid,\r\nasid, limit);\r\nreturn asid;\r\n}\r\nstatic int gru_assign_asid(struct gru_state *gru)\r\n{\r\nint asid;\r\ngru->gs_asid += ASID_INC;\r\nasid = gru->gs_asid;\r\nif (asid >= gru->gs_asid_limit)\r\nasid = gru_reset_asid_limit(gru, asid);\r\ngru_dbg(grudev, "gid %d, asid 0x%x\n", gru->gs_gid, asid);\r\nreturn asid;\r\n}\r\nstatic unsigned long reserve_resources(unsigned long *p, int n, int mmax,\r\nchar *idx)\r\n{\r\nunsigned long bits = 0;\r\nint i;\r\nwhile (n--) {\r\ni = find_first_bit(p, mmax);\r\nif (i == mmax)\r\nBUG();\r\n__clear_bit(i, p);\r\n__set_bit(i, &bits);\r\nif (idx)\r\n*idx++ = i;\r\n}\r\nreturn bits;\r\n}\r\nunsigned long gru_reserve_cb_resources(struct gru_state *gru, int cbr_au_count,\r\nchar *cbmap)\r\n{\r\nreturn reserve_resources(&gru->gs_cbr_map, cbr_au_count, GRU_CBR_AU,\r\ncbmap);\r\n}\r\nunsigned long gru_reserve_ds_resources(struct gru_state *gru, int dsr_au_count,\r\nchar *dsmap)\r\n{\r\nreturn reserve_resources(&gru->gs_dsr_map, dsr_au_count, GRU_DSR_AU,\r\ndsmap);\r\n}\r\nstatic void reserve_gru_resources(struct gru_state *gru,\r\nstruct gru_thread_state *gts)\r\n{\r\ngru->gs_active_contexts++;\r\ngts->ts_cbr_map =\r\ngru_reserve_cb_resources(gru, gts->ts_cbr_au_count,\r\ngts->ts_cbr_idx);\r\ngts->ts_dsr_map =\r\ngru_reserve_ds_resources(gru, gts->ts_dsr_au_count, NULL);\r\n}\r\nstatic void free_gru_resources(struct gru_state *gru,\r\nstruct gru_thread_state *gts)\r\n{\r\ngru->gs_active_contexts--;\r\ngru->gs_cbr_map |= gts->ts_cbr_map;\r\ngru->gs_dsr_map |= gts->ts_dsr_map;\r\n}\r\nstatic int check_gru_resources(struct gru_state *gru, int cbr_au_count,\r\nint dsr_au_count, int max_active_contexts)\r\n{\r\nreturn hweight64(gru->gs_cbr_map) >= cbr_au_count\r\n&& hweight64(gru->gs_dsr_map) >= dsr_au_count\r\n&& gru->gs_active_contexts < max_active_contexts;\r\n}\r\nstatic int gru_load_mm_tracker(struct gru_state *gru,\r\nstruct gru_thread_state *gts)\r\n{\r\nstruct gru_mm_struct *gms = gts->ts_gms;\r\nstruct gru_mm_tracker *asids = &gms->ms_asids[gru->gs_gid];\r\nunsigned short ctxbitmap = (1 << gts->ts_ctxnum);\r\nint asid;\r\nspin_lock(&gms->ms_asid_lock);\r\nasid = asids->mt_asid;\r\nspin_lock(&gru->gs_asid_lock);\r\nif (asid == 0 || (asids->mt_ctxbitmap == 0 && asids->mt_asid_gen !=\r\ngru->gs_asid_gen)) {\r\nasid = gru_assign_asid(gru);\r\nasids->mt_asid = asid;\r\nasids->mt_asid_gen = gru->gs_asid_gen;\r\nSTAT(asid_new);\r\n} else {\r\nSTAT(asid_reuse);\r\n}\r\nspin_unlock(&gru->gs_asid_lock);\r\nBUG_ON(asids->mt_ctxbitmap & ctxbitmap);\r\nasids->mt_ctxbitmap |= ctxbitmap;\r\nif (!test_bit(gru->gs_gid, gms->ms_asidmap))\r\n__set_bit(gru->gs_gid, gms->ms_asidmap);\r\nspin_unlock(&gms->ms_asid_lock);\r\ngru_dbg(grudev,\r\n"gid %d, gts %p, gms %p, ctxnum %d, asid 0x%x, asidmap 0x%lx\n",\r\ngru->gs_gid, gts, gms, gts->ts_ctxnum, asid,\r\ngms->ms_asidmap[0]);\r\nreturn asid;\r\n}\r\nstatic void gru_unload_mm_tracker(struct gru_state *gru,\r\nstruct gru_thread_state *gts)\r\n{\r\nstruct gru_mm_struct *gms = gts->ts_gms;\r\nstruct gru_mm_tracker *asids;\r\nunsigned short ctxbitmap;\r\nasids = &gms->ms_asids[gru->gs_gid];\r\nctxbitmap = (1 << gts->ts_ctxnum);\r\nspin_lock(&gms->ms_asid_lock);\r\nspin_lock(&gru->gs_asid_lock);\r\nBUG_ON((asids->mt_ctxbitmap & ctxbitmap) != ctxbitmap);\r\nasids->mt_ctxbitmap ^= ctxbitmap;\r\ngru_dbg(grudev, "gid %d, gts %p, gms %p, ctxnum 0x%d, asidmap 0x%lx\n",\r\ngru->gs_gid, gts, gms, gts->ts_ctxnum, gms->ms_asidmap[0]);\r\nspin_unlock(&gru->gs_asid_lock);\r\nspin_unlock(&gms->ms_asid_lock);\r\n}\r\nvoid gts_drop(struct gru_thread_state *gts)\r\n{\r\nif (gts && atomic_dec_return(&gts->ts_refcnt) == 0) {\r\nif (gts->ts_gms)\r\ngru_drop_mmu_notifier(gts->ts_gms);\r\nkfree(gts);\r\nSTAT(gts_free);\r\n}\r\n}\r\nstatic struct gru_thread_state *gru_find_current_gts_nolock(struct gru_vma_data\r\n*vdata, int tsid)\r\n{\r\nstruct gru_thread_state *gts;\r\nlist_for_each_entry(gts, &vdata->vd_head, ts_next)\r\nif (gts->ts_tsid == tsid)\r\nreturn gts;\r\nreturn NULL;\r\n}\r\nstruct gru_thread_state *gru_alloc_gts(struct vm_area_struct *vma,\r\nint cbr_au_count, int dsr_au_count,\r\nunsigned char tlb_preload_count, int options, int tsid)\r\n{\r\nstruct gru_thread_state *gts;\r\nstruct gru_mm_struct *gms;\r\nint bytes;\r\nbytes = DSR_BYTES(dsr_au_count) + CBR_BYTES(cbr_au_count);\r\nbytes += sizeof(struct gru_thread_state);\r\ngts = kmalloc(bytes, GFP_KERNEL);\r\nif (!gts)\r\nreturn ERR_PTR(-ENOMEM);\r\nSTAT(gts_alloc);\r\nmemset(gts, 0, sizeof(struct gru_thread_state));\r\natomic_set(&gts->ts_refcnt, 1);\r\nmutex_init(&gts->ts_ctxlock);\r\ngts->ts_cbr_au_count = cbr_au_count;\r\ngts->ts_dsr_au_count = dsr_au_count;\r\ngts->ts_tlb_preload_count = tlb_preload_count;\r\ngts->ts_user_options = options;\r\ngts->ts_user_blade_id = -1;\r\ngts->ts_user_chiplet_id = -1;\r\ngts->ts_tsid = tsid;\r\ngts->ts_ctxnum = NULLCTX;\r\ngts->ts_tlb_int_select = -1;\r\ngts->ts_cch_req_slice = -1;\r\ngts->ts_sizeavail = GRU_SIZEAVAIL(PAGE_SHIFT);\r\nif (vma) {\r\ngts->ts_mm = current->mm;\r\ngts->ts_vma = vma;\r\ngms = gru_register_mmu_notifier();\r\nif (IS_ERR(gms))\r\ngoto err;\r\ngts->ts_gms = gms;\r\n}\r\ngru_dbg(grudev, "alloc gts %p\n", gts);\r\nreturn gts;\r\nerr:\r\ngts_drop(gts);\r\nreturn ERR_CAST(gms);\r\n}\r\nstruct gru_vma_data *gru_alloc_vma_data(struct vm_area_struct *vma, int tsid)\r\n{\r\nstruct gru_vma_data *vdata = NULL;\r\nvdata = kmalloc(sizeof(*vdata), GFP_KERNEL);\r\nif (!vdata)\r\nreturn NULL;\r\nSTAT(vdata_alloc);\r\nINIT_LIST_HEAD(&vdata->vd_head);\r\nspin_lock_init(&vdata->vd_lock);\r\ngru_dbg(grudev, "alloc vdata %p\n", vdata);\r\nreturn vdata;\r\n}\r\nstruct gru_thread_state *gru_find_thread_state(struct vm_area_struct *vma,\r\nint tsid)\r\n{\r\nstruct gru_vma_data *vdata = vma->vm_private_data;\r\nstruct gru_thread_state *gts;\r\nspin_lock(&vdata->vd_lock);\r\ngts = gru_find_current_gts_nolock(vdata, tsid);\r\nspin_unlock(&vdata->vd_lock);\r\ngru_dbg(grudev, "vma %p, gts %p\n", vma, gts);\r\nreturn gts;\r\n}\r\nstruct gru_thread_state *gru_alloc_thread_state(struct vm_area_struct *vma,\r\nint tsid)\r\n{\r\nstruct gru_vma_data *vdata = vma->vm_private_data;\r\nstruct gru_thread_state *gts, *ngts;\r\ngts = gru_alloc_gts(vma, vdata->vd_cbr_au_count,\r\nvdata->vd_dsr_au_count,\r\nvdata->vd_tlb_preload_count,\r\nvdata->vd_user_options, tsid);\r\nif (IS_ERR(gts))\r\nreturn gts;\r\nspin_lock(&vdata->vd_lock);\r\nngts = gru_find_current_gts_nolock(vdata, tsid);\r\nif (ngts) {\r\ngts_drop(gts);\r\ngts = ngts;\r\nSTAT(gts_double_allocate);\r\n} else {\r\nlist_add(&gts->ts_next, &vdata->vd_head);\r\n}\r\nspin_unlock(&vdata->vd_lock);\r\ngru_dbg(grudev, "vma %p, gts %p\n", vma, gts);\r\nreturn gts;\r\n}\r\nstatic void gru_free_gru_context(struct gru_thread_state *gts)\r\n{\r\nstruct gru_state *gru;\r\ngru = gts->ts_gru;\r\ngru_dbg(grudev, "gts %p, gid %d\n", gts, gru->gs_gid);\r\nspin_lock(&gru->gs_lock);\r\ngru->gs_gts[gts->ts_ctxnum] = NULL;\r\nfree_gru_resources(gru, gts);\r\nBUG_ON(test_bit(gts->ts_ctxnum, &gru->gs_context_map) == 0);\r\n__clear_bit(gts->ts_ctxnum, &gru->gs_context_map);\r\ngts->ts_ctxnum = NULLCTX;\r\ngts->ts_gru = NULL;\r\ngts->ts_blade = -1;\r\nspin_unlock(&gru->gs_lock);\r\ngts_drop(gts);\r\nSTAT(free_context);\r\n}\r\nstatic void prefetch_data(void *p, int num, int stride)\r\n{\r\nwhile (num-- > 0) {\r\nprefetchw(p);\r\np += stride;\r\n}\r\n}\r\nstatic inline long gru_copy_handle(void *d, void *s)\r\n{\r\nmemcpy(d, s, GRU_HANDLE_BYTES);\r\nreturn GRU_HANDLE_BYTES;\r\n}\r\nstatic void gru_prefetch_context(void *gseg, void *cb, void *cbe,\r\nunsigned long cbrmap, unsigned long length)\r\n{\r\nint i, scr;\r\nprefetch_data(gseg + GRU_DS_BASE, length / GRU_CACHE_LINE_BYTES,\r\nGRU_CACHE_LINE_BYTES);\r\nfor_each_cbr_in_allocation_map(i, &cbrmap, scr) {\r\nprefetch_data(cb, 1, GRU_CACHE_LINE_BYTES);\r\nprefetch_data(cbe + i * GRU_HANDLE_STRIDE, 1,\r\nGRU_CACHE_LINE_BYTES);\r\ncb += GRU_HANDLE_STRIDE;\r\n}\r\n}\r\nstatic void gru_load_context_data(void *save, void *grubase, int ctxnum,\r\nunsigned long cbrmap, unsigned long dsrmap,\r\nint data_valid)\r\n{\r\nvoid *gseg, *cb, *cbe;\r\nunsigned long length;\r\nint i, scr;\r\ngseg = grubase + ctxnum * GRU_GSEG_STRIDE;\r\ncb = gseg + GRU_CB_BASE;\r\ncbe = grubase + GRU_CBE_BASE;\r\nlength = hweight64(dsrmap) * GRU_DSR_AU_BYTES;\r\ngru_prefetch_context(gseg, cb, cbe, cbrmap, length);\r\nfor_each_cbr_in_allocation_map(i, &cbrmap, scr) {\r\nif (data_valid) {\r\nsave += gru_copy_handle(cb, save);\r\nsave += gru_copy_handle(cbe + i * GRU_HANDLE_STRIDE,\r\nsave);\r\n} else {\r\nmemset(cb, 0, GRU_CACHE_LINE_BYTES);\r\nmemset(cbe + i * GRU_HANDLE_STRIDE, 0,\r\nGRU_CACHE_LINE_BYTES);\r\n}\r\nmb();\r\ngru_flush_cache(cbe + i * GRU_HANDLE_STRIDE);\r\ncb += GRU_HANDLE_STRIDE;\r\n}\r\nif (data_valid)\r\nmemcpy(gseg + GRU_DS_BASE, save, length);\r\nelse\r\nmemset(gseg + GRU_DS_BASE, 0, length);\r\n}\r\nstatic void gru_unload_context_data(void *save, void *grubase, int ctxnum,\r\nunsigned long cbrmap, unsigned long dsrmap)\r\n{\r\nvoid *gseg, *cb, *cbe;\r\nunsigned long length;\r\nint i, scr;\r\ngseg = grubase + ctxnum * GRU_GSEG_STRIDE;\r\ncb = gseg + GRU_CB_BASE;\r\ncbe = grubase + GRU_CBE_BASE;\r\nlength = hweight64(dsrmap) * GRU_DSR_AU_BYTES;\r\nfor_each_cbr_in_allocation_map(i, &cbrmap, scr)\r\ngru_flush_cache(cbe + i * GRU_HANDLE_STRIDE);\r\nmb();\r\ngru_prefetch_context(gseg, cb, cbe, cbrmap, length);\r\nfor_each_cbr_in_allocation_map(i, &cbrmap, scr) {\r\nsave += gru_copy_handle(save, cb);\r\nsave += gru_copy_handle(save, cbe + i * GRU_HANDLE_STRIDE);\r\ncb += GRU_HANDLE_STRIDE;\r\n}\r\nmemcpy(save, gseg + GRU_DS_BASE, length);\r\n}\r\nvoid gru_unload_context(struct gru_thread_state *gts, int savestate)\r\n{\r\nstruct gru_state *gru = gts->ts_gru;\r\nstruct gru_context_configuration_handle *cch;\r\nint ctxnum = gts->ts_ctxnum;\r\nif (!is_kernel_context(gts))\r\nzap_vma_ptes(gts->ts_vma, UGRUADDR(gts), GRU_GSEG_PAGESIZE);\r\ncch = get_cch(gru->gs_gru_base_vaddr, ctxnum);\r\ngru_dbg(grudev, "gts %p, cbrmap 0x%lx, dsrmap 0x%lx\n",\r\ngts, gts->ts_cbr_map, gts->ts_dsr_map);\r\nlock_cch_handle(cch);\r\nif (cch_interrupt_sync(cch))\r\nBUG();\r\nif (!is_kernel_context(gts))\r\ngru_unload_mm_tracker(gru, gts);\r\nif (savestate) {\r\ngru_unload_context_data(gts->ts_gdata, gru->gs_gru_base_vaddr,\r\nctxnum, gts->ts_cbr_map,\r\ngts->ts_dsr_map);\r\ngts->ts_data_valid = 1;\r\n}\r\nif (cch_deallocate(cch))\r\nBUG();\r\nunlock_cch_handle(cch);\r\ngru_free_gru_context(gts);\r\n}\r\nvoid gru_load_context(struct gru_thread_state *gts)\r\n{\r\nstruct gru_state *gru = gts->ts_gru;\r\nstruct gru_context_configuration_handle *cch;\r\nint i, err, asid, ctxnum = gts->ts_ctxnum;\r\ncch = get_cch(gru->gs_gru_base_vaddr, ctxnum);\r\nlock_cch_handle(cch);\r\ncch->tfm_fault_bit_enable =\r\n(gts->ts_user_options == GRU_OPT_MISS_FMM_POLL\r\n|| gts->ts_user_options == GRU_OPT_MISS_FMM_INTR);\r\ncch->tlb_int_enable = (gts->ts_user_options == GRU_OPT_MISS_FMM_INTR);\r\nif (cch->tlb_int_enable) {\r\ngts->ts_tlb_int_select = gru_cpu_fault_map_id();\r\ncch->tlb_int_select = gts->ts_tlb_int_select;\r\n}\r\nif (gts->ts_cch_req_slice >= 0) {\r\ncch->req_slice_set_enable = 1;\r\ncch->req_slice = gts->ts_cch_req_slice;\r\n} else {\r\ncch->req_slice_set_enable =0;\r\n}\r\ncch->tfm_done_bit_enable = 0;\r\ncch->dsr_allocation_map = gts->ts_dsr_map;\r\ncch->cbr_allocation_map = gts->ts_cbr_map;\r\nif (is_kernel_context(gts)) {\r\ncch->unmap_enable = 1;\r\ncch->tfm_done_bit_enable = 1;\r\ncch->cb_int_enable = 1;\r\ncch->tlb_int_select = 0;\r\n} else {\r\ncch->unmap_enable = 0;\r\ncch->tfm_done_bit_enable = 0;\r\ncch->cb_int_enable = 0;\r\nasid = gru_load_mm_tracker(gru, gts);\r\nfor (i = 0; i < 8; i++) {\r\ncch->asid[i] = asid + i;\r\ncch->sizeavail[i] = gts->ts_sizeavail;\r\n}\r\n}\r\nerr = cch_allocate(cch);\r\nif (err) {\r\ngru_dbg(grudev,\r\n"err %d: cch %p, gts %p, cbr 0x%lx, dsr 0x%lx\n",\r\nerr, cch, gts, gts->ts_cbr_map, gts->ts_dsr_map);\r\nBUG();\r\n}\r\ngru_load_context_data(gts->ts_gdata, gru->gs_gru_base_vaddr, ctxnum,\r\ngts->ts_cbr_map, gts->ts_dsr_map, gts->ts_data_valid);\r\nif (cch_start(cch))\r\nBUG();\r\nunlock_cch_handle(cch);\r\ngru_dbg(grudev, "gid %d, gts %p, cbrmap 0x%lx, dsrmap 0x%lx, tie %d, tis %d\n",\r\ngts->ts_gru->gs_gid, gts, gts->ts_cbr_map, gts->ts_dsr_map,\r\n(gts->ts_user_options == GRU_OPT_MISS_FMM_INTR), gts->ts_tlb_int_select);\r\n}\r\nint gru_update_cch(struct gru_thread_state *gts)\r\n{\r\nstruct gru_context_configuration_handle *cch;\r\nstruct gru_state *gru = gts->ts_gru;\r\nint i, ctxnum = gts->ts_ctxnum, ret = 0;\r\ncch = get_cch(gru->gs_gru_base_vaddr, ctxnum);\r\nlock_cch_handle(cch);\r\nif (cch->state == CCHSTATE_ACTIVE) {\r\nif (gru->gs_gts[gts->ts_ctxnum] != gts)\r\ngoto exit;\r\nif (cch_interrupt(cch))\r\nBUG();\r\nfor (i = 0; i < 8; i++)\r\ncch->sizeavail[i] = gts->ts_sizeavail;\r\ngts->ts_tlb_int_select = gru_cpu_fault_map_id();\r\ncch->tlb_int_select = gru_cpu_fault_map_id();\r\ncch->tfm_fault_bit_enable =\r\n(gts->ts_user_options == GRU_OPT_MISS_FMM_POLL\r\n|| gts->ts_user_options == GRU_OPT_MISS_FMM_INTR);\r\nif (cch_start(cch))\r\nBUG();\r\nret = 1;\r\n}\r\nexit:\r\nunlock_cch_handle(cch);\r\nreturn ret;\r\n}\r\nstatic int gru_retarget_intr(struct gru_thread_state *gts)\r\n{\r\nif (gts->ts_tlb_int_select < 0\r\n|| gts->ts_tlb_int_select == gru_cpu_fault_map_id())\r\nreturn 0;\r\ngru_dbg(grudev, "retarget from %d to %d\n", gts->ts_tlb_int_select,\r\ngru_cpu_fault_map_id());\r\nreturn gru_update_cch(gts);\r\n}\r\nstatic int gru_check_chiplet_assignment(struct gru_state *gru,\r\nstruct gru_thread_state *gts)\r\n{\r\nint blade_id;\r\nint chiplet_id;\r\nblade_id = gts->ts_user_blade_id;\r\nif (blade_id < 0)\r\nblade_id = uv_numa_blade_id();\r\nchiplet_id = gts->ts_user_chiplet_id;\r\nreturn gru->gs_blade_id == blade_id &&\r\n(chiplet_id < 0 || chiplet_id == gru->gs_chiplet_id);\r\n}\r\nvoid gru_check_context_placement(struct gru_thread_state *gts)\r\n{\r\nstruct gru_state *gru;\r\ngru = gts->ts_gru;\r\nif (!gru || gts->ts_tgid_owner != current->tgid)\r\nreturn;\r\nif (!gru_check_chiplet_assignment(gru, gts)) {\r\nSTAT(check_context_unload);\r\ngru_unload_context(gts, 1);\r\n} else if (gru_retarget_intr(gts)) {\r\nSTAT(check_context_retarget_intr);\r\n}\r\n}\r\nstatic int is_gts_stealable(struct gru_thread_state *gts,\r\nstruct gru_blade_state *bs)\r\n{\r\nif (is_kernel_context(gts))\r\nreturn down_write_trylock(&bs->bs_kgts_sema);\r\nelse\r\nreturn mutex_trylock(&gts->ts_ctxlock);\r\n}\r\nstatic void gts_stolen(struct gru_thread_state *gts,\r\nstruct gru_blade_state *bs)\r\n{\r\nif (is_kernel_context(gts)) {\r\nup_write(&bs->bs_kgts_sema);\r\nSTAT(steal_kernel_context);\r\n} else {\r\nmutex_unlock(&gts->ts_ctxlock);\r\nSTAT(steal_user_context);\r\n}\r\n}\r\nvoid gru_steal_context(struct gru_thread_state *gts)\r\n{\r\nstruct gru_blade_state *blade;\r\nstruct gru_state *gru, *gru0;\r\nstruct gru_thread_state *ngts = NULL;\r\nint ctxnum, ctxnum0, flag = 0, cbr, dsr;\r\nint blade_id;\r\nblade_id = gts->ts_user_blade_id;\r\nif (blade_id < 0)\r\nblade_id = uv_numa_blade_id();\r\ncbr = gts->ts_cbr_au_count;\r\ndsr = gts->ts_dsr_au_count;\r\nblade = gru_base[blade_id];\r\nspin_lock(&blade->bs_lock);\r\nctxnum = next_ctxnum(blade->bs_lru_ctxnum);\r\ngru = blade->bs_lru_gru;\r\nif (ctxnum == 0)\r\ngru = next_gru(blade, gru);\r\nblade->bs_lru_gru = gru;\r\nblade->bs_lru_ctxnum = ctxnum;\r\nctxnum0 = ctxnum;\r\ngru0 = gru;\r\nwhile (1) {\r\nif (gru_check_chiplet_assignment(gru, gts)) {\r\nif (check_gru_resources(gru, cbr, dsr, GRU_NUM_CCH))\r\nbreak;\r\nspin_lock(&gru->gs_lock);\r\nfor (; ctxnum < GRU_NUM_CCH; ctxnum++) {\r\nif (flag && gru == gru0 && ctxnum == ctxnum0)\r\nbreak;\r\nngts = gru->gs_gts[ctxnum];\r\nif (ngts && is_gts_stealable(ngts, blade))\r\nbreak;\r\nngts = NULL;\r\n}\r\nspin_unlock(&gru->gs_lock);\r\nif (ngts || (flag && gru == gru0 && ctxnum == ctxnum0))\r\nbreak;\r\n}\r\nif (flag && gru == gru0)\r\nbreak;\r\nflag = 1;\r\nctxnum = 0;\r\ngru = next_gru(blade, gru);\r\n}\r\nspin_unlock(&blade->bs_lock);\r\nif (ngts) {\r\ngts->ustats.context_stolen++;\r\nngts->ts_steal_jiffies = jiffies;\r\ngru_unload_context(ngts, is_kernel_context(ngts) ? 0 : 1);\r\ngts_stolen(ngts, blade);\r\n} else {\r\nSTAT(steal_context_failed);\r\n}\r\ngru_dbg(grudev,\r\n"stole gid %d, ctxnum %d from gts %p. Need cb %d, ds %d;"\r\n" avail cb %ld, ds %ld\n",\r\ngru->gs_gid, ctxnum, ngts, cbr, dsr, hweight64(gru->gs_cbr_map),\r\nhweight64(gru->gs_dsr_map));\r\n}\r\nstatic int gru_assign_context_number(struct gru_state *gru)\r\n{\r\nint ctxnum;\r\nctxnum = find_first_zero_bit(&gru->gs_context_map, GRU_NUM_CCH);\r\n__set_bit(ctxnum, &gru->gs_context_map);\r\nreturn ctxnum;\r\n}\r\nstruct gru_state *gru_assign_gru_context(struct gru_thread_state *gts)\r\n{\r\nstruct gru_state *gru, *grux;\r\nint i, max_active_contexts;\r\nint blade_id = gts->ts_user_blade_id;\r\nif (blade_id < 0)\r\nblade_id = uv_numa_blade_id();\r\nagain:\r\ngru = NULL;\r\nmax_active_contexts = GRU_NUM_CCH;\r\nfor_each_gru_on_blade(grux, blade_id, i) {\r\nif (!gru_check_chiplet_assignment(grux, gts))\r\ncontinue;\r\nif (check_gru_resources(grux, gts->ts_cbr_au_count,\r\ngts->ts_dsr_au_count,\r\nmax_active_contexts)) {\r\ngru = grux;\r\nmax_active_contexts = grux->gs_active_contexts;\r\nif (max_active_contexts == 0)\r\nbreak;\r\n}\r\n}\r\nif (gru) {\r\nspin_lock(&gru->gs_lock);\r\nif (!check_gru_resources(gru, gts->ts_cbr_au_count,\r\ngts->ts_dsr_au_count, GRU_NUM_CCH)) {\r\nspin_unlock(&gru->gs_lock);\r\ngoto again;\r\n}\r\nreserve_gru_resources(gru, gts);\r\ngts->ts_gru = gru;\r\ngts->ts_blade = gru->gs_blade_id;\r\ngts->ts_ctxnum = gru_assign_context_number(gru);\r\natomic_inc(&gts->ts_refcnt);\r\ngru->gs_gts[gts->ts_ctxnum] = gts;\r\nspin_unlock(&gru->gs_lock);\r\nSTAT(assign_context);\r\ngru_dbg(grudev,\r\n"gseg %p, gts %p, gid %d, ctx %d, cbr %d, dsr %d\n",\r\ngseg_virtual_address(gts->ts_gru, gts->ts_ctxnum), gts,\r\ngts->ts_gru->gs_gid, gts->ts_ctxnum,\r\ngts->ts_cbr_au_count, gts->ts_dsr_au_count);\r\n} else {\r\ngru_dbg(grudev, "failed to allocate a GTS %s\n", "");\r\nSTAT(assign_context_failed);\r\n}\r\nreturn gru;\r\n}\r\nint gru_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct gru_thread_state *gts;\r\nunsigned long paddr, vaddr;\r\nvaddr = (unsigned long)vmf->virtual_address;\r\ngru_dbg(grudev, "vma %p, vaddr 0x%lx (0x%lx)\n",\r\nvma, vaddr, GSEG_BASE(vaddr));\r\nSTAT(nopfn);\r\ngts = gru_find_thread_state(vma, TSID(vaddr, vma));\r\nif (!gts)\r\nreturn VM_FAULT_SIGBUS;\r\nagain:\r\nmutex_lock(&gts->ts_ctxlock);\r\npreempt_disable();\r\ngru_check_context_placement(gts);\r\nif (!gts->ts_gru) {\r\nSTAT(load_user_context);\r\nif (!gru_assign_gru_context(gts)) {\r\npreempt_enable();\r\nmutex_unlock(&gts->ts_ctxlock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(GRU_ASSIGN_DELAY);\r\nif (gts->ts_steal_jiffies + GRU_STEAL_DELAY < jiffies)\r\ngru_steal_context(gts);\r\ngoto again;\r\n}\r\ngru_load_context(gts);\r\npaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\r\nremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\r\npaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\r\nvma->vm_page_prot);\r\n}\r\npreempt_enable();\r\nmutex_unlock(&gts->ts_ctxlock);\r\nreturn VM_FAULT_NOPAGE;\r\n}
