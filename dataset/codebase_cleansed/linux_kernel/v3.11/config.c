int bvme6000_parse_bootinfo(const struct bi_record *bi)\r\n{\r\nif (bi->tag == BI_VME_TYPE)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nvoid bvme6000_reset(void)\r\n{\r\nvolatile PitRegsPtr pit = (PitRegsPtr)BVME_PIT_BASE;\r\nprintk ("\r\n\nCalled bvme6000_reset\r\n"\r\n"\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r");\r\npit->pcddr |= 0x10;\r\nwhile(1)\r\n;\r\n}\r\nstatic void bvme6000_get_model(char *model)\r\n{\r\nsprintf(model, "BVME%d000", m68k_cputype == CPU_68060 ? 6 : 4);\r\n}\r\nstatic void __init bvme6000_init_IRQ(void)\r\n{\r\nm68k_setup_user_interrupt(VEC_USER, 192);\r\n}\r\nvoid __init config_bvme6000(void)\r\n{\r\nvolatile PitRegsPtr pit = (PitRegsPtr)BVME_PIT_BASE;\r\nif (!vme_brdtype) {\r\nif (m68k_cputype == CPU_68060)\r\nvme_brdtype = VME_TYPE_BVME6000;\r\nelse\r\nvme_brdtype = VME_TYPE_BVME4000;\r\n}\r\n#if 0\r\nbvme6000_set_vectors();\r\n#endif\r\nmach_max_dma_address = 0xffffffff;\r\nmach_sched_init = bvme6000_sched_init;\r\nmach_init_IRQ = bvme6000_init_IRQ;\r\narch_gettimeoffset = bvme6000_gettimeoffset;\r\nmach_hwclk = bvme6000_hwclk;\r\nmach_set_clock_mmss = bvme6000_set_clock_mmss;\r\nmach_reset = bvme6000_reset;\r\nmach_get_model = bvme6000_get_model;\r\nprintk ("Board is %sconfigured as a System Controller\n",\r\n*config_reg_ptr & BVME_CONFIG_SW1 ? "" : "not ");\r\npit->pgcr = 0x00;\r\npit->psrr = 0x18;\r\npit->pacr = 0x00;\r\npit->padr = 0x00;\r\npit->paddr = 0x00;\r\npit->pbcr = 0x80;\r\npit->pbdr = 0xbc | (*config_reg_ptr & BVME_CONFIG_SW1 ? 0 : 0x40);\r\npit->pbddr = 0xf3;\r\npit->pcdr = 0x01;\r\npit->pcddr = 0x03;\r\nbvme_acr_addrctl = 0;\r\n}\r\nirqreturn_t bvme6000_abort_int (int irq, void *dev_id)\r\n{\r\nunsigned long *new = (unsigned long *)vectors;\r\nunsigned long *old = (unsigned long *)0xf8000000;\r\nwhile (*(volatile unsigned char *)BVME_LOCAL_IRQ_STAT & BVME_ABORT_STATUS)\r\n;\r\n*(new+4) = *(old+4);\r\n*(new+9) = *(old+9);\r\n*(new+47) = *(old+47);\r\n*(new+0x1f) = *(old+0x1f);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bvme6000_timer_int (int irq, void *dev_id)\r\n{\r\nvolatile RtcPtr_t rtc = (RtcPtr_t)BVME_RTC_BASE;\r\nunsigned char msr = rtc->msr & 0xc0;\r\nrtc->msr = msr | 0x20;\r\nreturn tick_handler(irq, dev_id);\r\n}\r\nvoid bvme6000_sched_init (irq_handler_t timer_routine)\r\n{\r\nvolatile RtcPtr_t rtc = (RtcPtr_t)BVME_RTC_BASE;\r\nunsigned char msr = rtc->msr & 0xc0;\r\nrtc->msr = 0;\r\ntick_handler = timer_routine;\r\nif (request_irq(BVME_IRQ_RTC, bvme6000_timer_int, 0,\r\n"timer", bvme6000_timer_int))\r\npanic ("Couldn't register timer int");\r\nrtc->t1cr_omr = 0x04;\r\nrtc->t1msb = 39999 >> 8;\r\nrtc->t1lsb = 39999 & 0xff;\r\nrtc->irr_icr1 &= 0xef;\r\nrtc->msr = 0x40;\r\nrtc->pfr_icr0 = 0x80;\r\nrtc->irr_icr1 = 0;\r\nrtc->t1cr_omr = 0x0a;\r\nrtc->t0cr_rtmr &= 0xdf;\r\nrtc->msr = 0;\r\nrtc->t1cr_omr = 0x05;\r\nrtc->msr = msr;\r\nif (request_irq(BVME_IRQ_ABORT, bvme6000_abort_int, 0,\r\n"abort", bvme6000_abort_int))\r\npanic ("Couldn't register abort int");\r\n}\r\nu32 bvme6000_gettimeoffset(void)\r\n{\r\nvolatile RtcPtr_t rtc = (RtcPtr_t)BVME_RTC_BASE;\r\nvolatile PitRegsPtr pit = (PitRegsPtr)BVME_PIT_BASE;\r\nunsigned char msr = rtc->msr & 0xc0;\r\nunsigned char t1int, t1op;\r\nu32 v = 800000, ov;\r\nrtc->msr = 0;\r\ndo {\r\nov = v;\r\nt1int = rtc->msr & 0x20;\r\nt1op = pit->pcdr & 0x04;\r\nrtc->t1cr_omr |= 0x40;\r\nv = rtc->t1msb << 8;\r\nv |= rtc->t1lsb;\r\n} while (t1int != (rtc->msr & 0x20) ||\r\nt1op != (pit->pcdr & 0x04) ||\r\nabs(ov-v) > 80 ||\r\nv > 39960);\r\nv = 39999 - v;\r\nif (!t1op)\r\nv += 40000;\r\nv /= 8;\r\nif (t1int)\r\nv += 10000;\r\nrtc->msr = msr;\r\nreturn v * 1000;\r\n}\r\nint bvme6000_hwclk(int op, struct rtc_time *t)\r\n{\r\nvolatile RtcPtr_t rtc = (RtcPtr_t)BVME_RTC_BASE;\r\nunsigned char msr = rtc->msr & 0xc0;\r\nrtc->msr = 0x40;\r\nif (op)\r\n{\r\nrtc->t0cr_rtmr = t->tm_year%4;\r\nrtc->bcd_tenms = 0;\r\nrtc->bcd_sec = bin2bcd(t->tm_sec);\r\nrtc->bcd_min = bin2bcd(t->tm_min);\r\nrtc->bcd_hr = bin2bcd(t->tm_hour);\r\nrtc->bcd_dom = bin2bcd(t->tm_mday);\r\nrtc->bcd_mth = bin2bcd(t->tm_mon + 1);\r\nrtc->bcd_year = bin2bcd(t->tm_year%100);\r\nif (t->tm_wday >= 0)\r\nrtc->bcd_dow = bin2bcd(t->tm_wday+1);\r\nrtc->t0cr_rtmr = t->tm_year%4 | 0x08;\r\n}\r\nelse\r\n{\r\ndo {\r\nt->tm_sec = bcd2bin(rtc->bcd_sec);\r\nt->tm_min = bcd2bin(rtc->bcd_min);\r\nt->tm_hour = bcd2bin(rtc->bcd_hr);\r\nt->tm_mday = bcd2bin(rtc->bcd_dom);\r\nt->tm_mon = bcd2bin(rtc->bcd_mth)-1;\r\nt->tm_year = bcd2bin(rtc->bcd_year);\r\nif (t->tm_year < 70)\r\nt->tm_year += 100;\r\nt->tm_wday = bcd2bin(rtc->bcd_dow)-1;\r\n} while (t->tm_sec != bcd2bin(rtc->bcd_sec));\r\n}\r\nrtc->msr = msr;\r\nreturn 0;\r\n}\r\nint bvme6000_set_clock_mmss (unsigned long nowtime)\r\n{\r\nint retval = 0;\r\nshort real_seconds = nowtime % 60, real_minutes = (nowtime / 60) % 60;\r\nunsigned char rtc_minutes, rtc_tenms;\r\nvolatile RtcPtr_t rtc = (RtcPtr_t)BVME_RTC_BASE;\r\nunsigned char msr = rtc->msr & 0xc0;\r\nunsigned long flags;\r\nvolatile int i;\r\nrtc->msr = 0;\r\nrtc_minutes = bcd2bin (rtc->bcd_min);\r\nif ((rtc_minutes < real_minutes\r\n? real_minutes - rtc_minutes\r\n: rtc_minutes - real_minutes) < 30)\r\n{\r\nlocal_irq_save(flags);\r\nrtc_tenms = rtc->bcd_tenms;\r\nwhile (rtc_tenms == rtc->bcd_tenms)\r\n;\r\nfor (i = 0; i < 1000; i++)\r\n;\r\nrtc->bcd_min = bin2bcd(real_minutes);\r\nrtc->bcd_sec = bin2bcd(real_seconds);\r\nlocal_irq_restore(flags);\r\n}\r\nelse\r\nretval = -1;\r\nrtc->msr = msr;\r\nreturn retval;\r\n}
