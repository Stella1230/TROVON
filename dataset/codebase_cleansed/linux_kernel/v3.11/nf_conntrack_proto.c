static int\r\nnf_ct_register_sysctl(struct net *net,\r\nstruct ctl_table_header **header,\r\nconst char *path,\r\nstruct ctl_table *table)\r\n{\r\nif (*header == NULL) {\r\n*header = register_net_sysctl(net, path, table);\r\nif (*header == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnf_ct_unregister_sysctl(struct ctl_table_header **header,\r\nstruct ctl_table **table,\r\nunsigned int users)\r\n{\r\nif (users > 0)\r\nreturn;\r\nunregister_net_sysctl_table(*header);\r\nkfree(*table);\r\n*header = NULL;\r\n*table = NULL;\r\n}\r\nstruct nf_conntrack_l4proto *\r\n__nf_ct_l4proto_find(u_int16_t l3proto, u_int8_t l4proto)\r\n{\r\nif (unlikely(l3proto >= AF_MAX || nf_ct_protos[l3proto] == NULL))\r\nreturn &nf_conntrack_l4proto_generic;\r\nreturn rcu_dereference(nf_ct_protos[l3proto][l4proto]);\r\n}\r\nstruct nf_conntrack_l3proto *\r\nnf_ct_l3proto_find_get(u_int16_t l3proto)\r\n{\r\nstruct nf_conntrack_l3proto *p;\r\nrcu_read_lock();\r\np = __nf_ct_l3proto_find(l3proto);\r\nif (!try_module_get(p->me))\r\np = &nf_conntrack_l3proto_generic;\r\nrcu_read_unlock();\r\nreturn p;\r\n}\r\nvoid nf_ct_l3proto_put(struct nf_conntrack_l3proto *p)\r\n{\r\nmodule_put(p->me);\r\n}\r\nint\r\nnf_ct_l3proto_try_module_get(unsigned short l3proto)\r\n{\r\nint ret;\r\nstruct nf_conntrack_l3proto *p;\r\nretry: p = nf_ct_l3proto_find_get(l3proto);\r\nif (p == &nf_conntrack_l3proto_generic) {\r\nret = request_module("nf_conntrack-%d", l3proto);\r\nif (!ret)\r\ngoto retry;\r\nreturn -EPROTOTYPE;\r\n}\r\nreturn 0;\r\n}\r\nvoid nf_ct_l3proto_module_put(unsigned short l3proto)\r\n{\r\nstruct nf_conntrack_l3proto *p;\r\nrcu_read_lock();\r\np = __nf_ct_l3proto_find(l3proto);\r\nmodule_put(p->me);\r\nrcu_read_unlock();\r\n}\r\nstruct nf_conntrack_l4proto *\r\nnf_ct_l4proto_find_get(u_int16_t l3num, u_int8_t l4num)\r\n{\r\nstruct nf_conntrack_l4proto *p;\r\nrcu_read_lock();\r\np = __nf_ct_l4proto_find(l3num, l4num);\r\nif (!try_module_get(p->me))\r\np = &nf_conntrack_l4proto_generic;\r\nrcu_read_unlock();\r\nreturn p;\r\n}\r\nvoid nf_ct_l4proto_put(struct nf_conntrack_l4proto *p)\r\n{\r\nmodule_put(p->me);\r\n}\r\nstatic int kill_l3proto(struct nf_conn *i, void *data)\r\n{\r\nreturn nf_ct_l3num(i) == ((struct nf_conntrack_l3proto *)data)->l3proto;\r\n}\r\nstatic int kill_l4proto(struct nf_conn *i, void *data)\r\n{\r\nstruct nf_conntrack_l4proto *l4proto;\r\nl4proto = (struct nf_conntrack_l4proto *)data;\r\nreturn nf_ct_protonum(i) == l4proto->l4proto &&\r\nnf_ct_l3num(i) == l4proto->l3proto;\r\n}\r\nstatic struct nf_ip_net *nf_ct_l3proto_net(struct net *net,\r\nstruct nf_conntrack_l3proto *l3proto)\r\n{\r\nif (l3proto->l3proto == PF_INET)\r\nreturn &net->ct.nf_ct_proto;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int nf_ct_l3proto_register_sysctl(struct net *net,\r\nstruct nf_conntrack_l3proto *l3proto)\r\n{\r\nint err = 0;\r\nstruct nf_ip_net *in = nf_ct_l3proto_net(net, l3proto);\r\nif (in == NULL)\r\nreturn 0;\r\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)\r\nif (in->ctl_table != NULL) {\r\nerr = nf_ct_register_sysctl(net,\r\n&in->ctl_table_header,\r\nl3proto->ctl_table_path,\r\nin->ctl_table);\r\nif (err < 0) {\r\nkfree(in->ctl_table);\r\nin->ctl_table = NULL;\r\n}\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic void nf_ct_l3proto_unregister_sysctl(struct net *net,\r\nstruct nf_conntrack_l3proto *l3proto)\r\n{\r\nstruct nf_ip_net *in = nf_ct_l3proto_net(net, l3proto);\r\nif (in == NULL)\r\nreturn;\r\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)\r\nif (in->ctl_table_header != NULL)\r\nnf_ct_unregister_sysctl(&in->ctl_table_header,\r\n&in->ctl_table,\r\n0);\r\n#endif\r\n}\r\nint nf_ct_l3proto_register(struct nf_conntrack_l3proto *proto)\r\n{\r\nint ret = 0;\r\nstruct nf_conntrack_l3proto *old;\r\nif (proto->l3proto >= AF_MAX)\r\nreturn -EBUSY;\r\nif (proto->tuple_to_nlattr && !proto->nlattr_tuple_size)\r\nreturn -EINVAL;\r\nmutex_lock(&nf_ct_proto_mutex);\r\nold = rcu_dereference_protected(nf_ct_l3protos[proto->l3proto],\r\nlockdep_is_held(&nf_ct_proto_mutex));\r\nif (old != &nf_conntrack_l3proto_generic) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nif (proto->nlattr_tuple_size)\r\nproto->nla_size = 3 * proto->nlattr_tuple_size();\r\nrcu_assign_pointer(nf_ct_l3protos[proto->l3proto], proto);\r\nout_unlock:\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nreturn ret;\r\n}\r\nint nf_ct_l3proto_pernet_register(struct net *net,\r\nstruct nf_conntrack_l3proto *proto)\r\n{\r\nint ret = 0;\r\nif (proto->init_net) {\r\nret = proto->init_net(net);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn nf_ct_l3proto_register_sysctl(net, proto);\r\n}\r\nvoid nf_ct_l3proto_unregister(struct nf_conntrack_l3proto *proto)\r\n{\r\nBUG_ON(proto->l3proto >= AF_MAX);\r\nmutex_lock(&nf_ct_proto_mutex);\r\nBUG_ON(rcu_dereference_protected(nf_ct_l3protos[proto->l3proto],\r\nlockdep_is_held(&nf_ct_proto_mutex)\r\n) != proto);\r\nrcu_assign_pointer(nf_ct_l3protos[proto->l3proto],\r\n&nf_conntrack_l3proto_generic);\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nsynchronize_rcu();\r\n}\r\nvoid nf_ct_l3proto_pernet_unregister(struct net *net,\r\nstruct nf_conntrack_l3proto *proto)\r\n{\r\nnf_ct_l3proto_unregister_sysctl(net, proto);\r\nnf_ct_iterate_cleanup(net, kill_l3proto, proto);\r\n}\r\nstatic struct nf_proto_net *nf_ct_l4proto_net(struct net *net,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\nif (l4proto->get_net_proto) {\r\nreturn l4proto->get_net_proto(net);\r\n} else if (l4proto->net_id) {\r\nreturn net_generic(net, *l4proto->net_id);\r\n}\r\nreturn NULL;\r\n}\r\nstatic\r\nint nf_ct_l4proto_register_sysctl(struct net *net,\r\nstruct nf_proto_net *pn,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_SYSCTL\r\nif (pn->ctl_table != NULL) {\r\nerr = nf_ct_register_sysctl(net,\r\n&pn->ctl_table_header,\r\n"net/netfilter",\r\npn->ctl_table);\r\nif (err < 0) {\r\nif (!pn->users) {\r\nkfree(pn->ctl_table);\r\npn->ctl_table = NULL;\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT\r\nif (l4proto->l3proto != AF_INET6 && pn->ctl_compat_table != NULL) {\r\nif (err < 0) {\r\nnf_ct_kfree_compat_sysctl_table(pn);\r\ngoto out;\r\n}\r\nerr = nf_ct_register_sysctl(net,\r\n&pn->ctl_compat_header,\r\n"net/ipv4/netfilter",\r\npn->ctl_compat_table);\r\nif (err == 0)\r\ngoto out;\r\nnf_ct_kfree_compat_sysctl_table(pn);\r\nnf_ct_unregister_sysctl(&pn->ctl_table_header,\r\n&pn->ctl_table,\r\npn->users);\r\n}\r\nout:\r\n#endif\r\n#endif\r\nreturn err;\r\n}\r\nstatic\r\nvoid nf_ct_l4proto_unregister_sysctl(struct net *net,\r\nstruct nf_proto_net *pn,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (pn->ctl_table_header != NULL)\r\nnf_ct_unregister_sysctl(&pn->ctl_table_header,\r\n&pn->ctl_table,\r\npn->users);\r\n#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT\r\nif (l4proto->l3proto != AF_INET6 && pn->ctl_compat_header != NULL)\r\nnf_ct_unregister_sysctl(&pn->ctl_compat_header,\r\n&pn->ctl_compat_table,\r\n0);\r\n#endif\r\n#endif\r\n}\r\nint nf_ct_l4proto_register(struct nf_conntrack_l4proto *l4proto)\r\n{\r\nint ret = 0;\r\nif (l4proto->l3proto >= PF_MAX)\r\nreturn -EBUSY;\r\nif ((l4proto->to_nlattr && !l4proto->nlattr_size)\r\n|| (l4proto->tuple_to_nlattr && !l4proto->nlattr_tuple_size))\r\nreturn -EINVAL;\r\nmutex_lock(&nf_ct_proto_mutex);\r\nif (!nf_ct_protos[l4proto->l3proto]) {\r\nstruct nf_conntrack_l4proto __rcu **proto_array;\r\nint i;\r\nproto_array = kmalloc(MAX_NF_CT_PROTO *\r\nsizeof(struct nf_conntrack_l4proto *),\r\nGFP_KERNEL);\r\nif (proto_array == NULL) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < MAX_NF_CT_PROTO; i++)\r\nRCU_INIT_POINTER(proto_array[i], &nf_conntrack_l4proto_generic);\r\nsmp_wmb();\r\nnf_ct_protos[l4proto->l3proto] = proto_array;\r\n} else if (rcu_dereference_protected(\r\nnf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\nlockdep_is_held(&nf_ct_proto_mutex)\r\n) != &nf_conntrack_l4proto_generic) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nl4proto->nla_size = 0;\r\nif (l4proto->nlattr_size)\r\nl4proto->nla_size += l4proto->nlattr_size();\r\nif (l4proto->nlattr_tuple_size)\r\nl4proto->nla_size += 3 * l4proto->nlattr_tuple_size();\r\nrcu_assign_pointer(nf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\nl4proto);\r\nout_unlock:\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nreturn ret;\r\n}\r\nint nf_ct_l4proto_pernet_register(struct net *net,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\nint ret = 0;\r\nstruct nf_proto_net *pn = NULL;\r\nif (l4proto->init_net) {\r\nret = l4proto->init_net(net, l4proto->l3proto);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\npn = nf_ct_l4proto_net(net, l4proto);\r\nif (pn == NULL)\r\ngoto out;\r\nret = nf_ct_l4proto_register_sysctl(net, pn, l4proto);\r\nif (ret < 0)\r\ngoto out;\r\npn->users++;\r\nout:\r\nreturn ret;\r\n}\r\nvoid nf_ct_l4proto_unregister(struct nf_conntrack_l4proto *l4proto)\r\n{\r\nBUG_ON(l4proto->l3proto >= PF_MAX);\r\nmutex_lock(&nf_ct_proto_mutex);\r\nBUG_ON(rcu_dereference_protected(\r\nnf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\nlockdep_is_held(&nf_ct_proto_mutex)\r\n) != l4proto);\r\nrcu_assign_pointer(nf_ct_protos[l4proto->l3proto][l4proto->l4proto],\r\n&nf_conntrack_l4proto_generic);\r\nmutex_unlock(&nf_ct_proto_mutex);\r\nsynchronize_rcu();\r\n}\r\nvoid nf_ct_l4proto_pernet_unregister(struct net *net,\r\nstruct nf_conntrack_l4proto *l4proto)\r\n{\r\nstruct nf_proto_net *pn = NULL;\r\npn = nf_ct_l4proto_net(net, l4proto);\r\nif (pn == NULL)\r\nreturn;\r\npn->users--;\r\nnf_ct_l4proto_unregister_sysctl(net, pn, l4proto);\r\nnf_ct_iterate_cleanup(net, kill_l4proto, l4proto);\r\n}\r\nint nf_conntrack_proto_pernet_init(struct net *net)\r\n{\r\nint err;\r\nstruct nf_proto_net *pn = nf_ct_l4proto_net(net,\r\n&nf_conntrack_l4proto_generic);\r\nerr = nf_conntrack_l4proto_generic.init_net(net,\r\nnf_conntrack_l4proto_generic.l3proto);\r\nif (err < 0)\r\nreturn err;\r\nerr = nf_ct_l4proto_register_sysctl(net,\r\npn,\r\n&nf_conntrack_l4proto_generic);\r\nif (err < 0)\r\nreturn err;\r\npn->users++;\r\nreturn 0;\r\n}\r\nvoid nf_conntrack_proto_pernet_fini(struct net *net)\r\n{\r\nstruct nf_proto_net *pn = nf_ct_l4proto_net(net,\r\n&nf_conntrack_l4proto_generic);\r\npn->users--;\r\nnf_ct_l4proto_unregister_sysctl(net,\r\npn,\r\n&nf_conntrack_l4proto_generic);\r\n}\r\nint nf_conntrack_proto_init(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < AF_MAX; i++)\r\nrcu_assign_pointer(nf_ct_l3protos[i],\r\n&nf_conntrack_l3proto_generic);\r\nreturn 0;\r\n}\r\nvoid nf_conntrack_proto_fini(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < PF_MAX; i++)\r\nkfree(nf_ct_protos[i]);\r\n}
