void rts51x_do_remaining_work(struct rts51x_chip *chip)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nif (chip->card_ready & SD_CARD) {\r\nif (sd_card->seq_mode) {\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nsd_card->counter++;\r\n} else {\r\nsd_card->counter = 0;\r\n}\r\n}\r\nif (chip->card_ready & XD_CARD) {\r\nif (xd_card->delay_write.delay_write_flag) {\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nxd_card->counter++;\r\n} else {\r\nxd_card->counter = 0;\r\n}\r\n}\r\nif (chip->card_ready & MS_CARD) {\r\nif (CHK_MSPRO(ms_card)) {\r\nif (ms_card->seq_mode) {\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nms_card->counter++;\r\n} else {\r\nms_card->counter = 0;\r\n}\r\n} else {\r\nif (ms_card->delay_write.delay_write_flag) {\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nms_card->counter++;\r\n} else {\r\nms_card->counter = 0;\r\n}\r\n}\r\n}\r\nif (sd_card->counter > POLLING_WAIT_CNT)\r\nrts51x_sd_cleanup_work(chip);\r\nif (xd_card->counter > POLLING_WAIT_CNT)\r\nrts51x_xd_cleanup_work(chip);\r\nif (ms_card->counter > POLLING_WAIT_CNT)\r\nrts51x_ms_cleanup_work(chip);\r\n}\r\nstatic void do_rts51x_reset_xd_card(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nif (chip->card2lun[XD_CARD] >= MAX_ALLOWED_LUN_CNT)\r\nreturn;\r\nretval = rts51x_reset_xd_card(chip);\r\nif (retval == STATUS_SUCCESS) {\r\nchip->card_ready |= XD_CARD;\r\nchip->card_fail &= ~XD_CARD;\r\nchip->rw_card[chip->card2lun[XD_CARD]] = rts51x_xd_rw;\r\n} else {\r\nchip->card_ready &= ~XD_CARD;\r\nchip->card_fail |= XD_CARD;\r\nchip->capacity[chip->card2lun[XD_CARD]] = 0;\r\nchip->rw_card[chip->card2lun[XD_CARD]] = NULL;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, POWER_MASK,\r\nPOWER_OFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_CLK_EN, XD_CLK_EN, 0);\r\nrts51x_send_cmd(chip, MODE_C, 100);\r\n}\r\n}\r\nvoid rts51x_do_rts51x_reset_sd_card(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nif (chip->card2lun[SD_CARD] >= MAX_ALLOWED_LUN_CNT)\r\nreturn;\r\nretval = rts51x_reset_sd_card(chip);\r\nif (retval == STATUS_SUCCESS) {\r\nchip->card_ready |= SD_CARD;\r\nchip->card_fail &= ~SD_CARD;\r\nchip->rw_card[chip->card2lun[SD_CARD]] = rts51x_sd_rw;\r\n} else {\r\nchip->card_ready &= ~SD_CARD;\r\nchip->card_fail |= SD_CARD;\r\nchip->capacity[chip->card2lun[SD_CARD]] = 0;\r\nchip->rw_card[chip->card2lun[SD_CARD]] = NULL;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_OE, SD_OUTPUT_EN, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, POWER_MASK,\r\nPOWER_OFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_CLK_EN, SD_CLK_EN, 0);\r\nrts51x_send_cmd(chip, MODE_C, 100);\r\n}\r\n}\r\nstatic void do_rts51x_reset_ms_card(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nif (chip->card2lun[MS_CARD] >= MAX_ALLOWED_LUN_CNT)\r\nreturn;\r\nretval = rts51x_reset_ms_card(chip);\r\nif (retval == STATUS_SUCCESS) {\r\nchip->card_ready |= MS_CARD;\r\nchip->card_fail &= ~MS_CARD;\r\nchip->rw_card[chip->card2lun[MS_CARD]] = rts51x_ms_rw;\r\n} else {\r\nchip->card_ready &= ~MS_CARD;\r\nchip->card_fail |= MS_CARD;\r\nchip->capacity[chip->card2lun[MS_CARD]] = 0;\r\nchip->rw_card[chip->card2lun[MS_CARD]] = NULL;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_OE, MS_OUTPUT_EN, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_PWR_CTL, POWER_MASK,\r\nPOWER_OFF);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_CLK_EN, MS_CLK_EN, 0);\r\nrts51x_send_cmd(chip, MODE_C, 100);\r\n}\r\n}\r\nstatic void card_cd_debounce(struct rts51x_chip *chip, u8 *need_reset,\r\nu8 *need_release)\r\n{\r\nint retval;\r\nu8 release_map = 0, reset_map = 0;\r\nu8 value;\r\nretval = rts51x_get_card_status(chip, &(chip->card_status));\r\n#ifdef SUPPORT_OCP\r\nchip->ocp_stat = (chip->card_status >> 4) & 0x03;\r\n#endif\r\nif (retval != STATUS_SUCCESS)\r\ngoto Exit_Debounce;\r\nif (chip->card_exist) {\r\nretval = rts51x_read_register(chip, CARD_INT_PEND, &value);\r\nif (retval != STATUS_SUCCESS) {\r\nrts51x_ep0_write_register(chip, MC_FIFO_CTL, FIFO_FLUSH,\r\nFIFO_FLUSH);\r\nrts51x_ep0_write_register(chip, SFSM_ED, 0xf8, 0xf8);\r\nvalue = 0;\r\n}\r\nif (chip->card_exist & XD_CARD) {\r\nif (!(chip->card_status & XD_CD))\r\nrelease_map |= XD_CARD;\r\n} else if (chip->card_exist & SD_CARD) {\r\nif (!(chip->card_status & SD_CD) || (value & SD_INT))\r\nrelease_map |= SD_CARD;\r\n} else if (chip->card_exist & MS_CARD) {\r\nif (!(chip->card_status & MS_CD) || (value & MS_INT))\r\nrelease_map |= MS_CARD;\r\n}\r\n} else {\r\nif (chip->card_status & XD_CD)\r\nreset_map |= XD_CARD;\r\nelse if (chip->card_status & SD_CD)\r\nreset_map |= SD_CARD;\r\nelse if (chip->card_status & MS_CD)\r\nreset_map |= MS_CARD;\r\n}\r\nif (CHECK_PKG(chip, QFN24) && reset_map) {\r\nif (chip->card_exist & XD_CARD) {\r\nreset_map = 0;\r\ngoto Exit_Debounce;\r\n}\r\n}\r\nif (reset_map) {\r\nint xd_cnt = 0, sd_cnt = 0, ms_cnt = 0;\r\nint i;\r\nfor (i = 0; i < (chip->option.debounce_num); i++) {\r\nretval =\r\nrts51x_get_card_status(chip, &(chip->card_status));\r\nif (retval != STATUS_SUCCESS) {\r\nreset_map = release_map = 0;\r\ngoto Exit_Debounce;\r\n}\r\nif (chip->card_status & XD_CD)\r\nxd_cnt++;\r\nelse\r\nxd_cnt = 0;\r\nif (chip->card_status & SD_CD)\r\nsd_cnt++;\r\nelse\r\nsd_cnt = 0;\r\nif (chip->card_status & MS_CD)\r\nms_cnt++;\r\nelse\r\nms_cnt = 0;\r\nwait_timeout(30);\r\n}\r\nreset_map = 0;\r\nif (!(chip->card_exist & XD_CARD)\r\n&& (xd_cnt > (chip->option.debounce_num - 1))) {\r\nreset_map |= XD_CARD;\r\n}\r\nif (!(chip->card_exist & SD_CARD)\r\n&& (sd_cnt > (chip->option.debounce_num - 1))) {\r\nreset_map |= SD_CARD;\r\n}\r\nif (!(chip->card_exist & MS_CARD)\r\n&& (ms_cnt > (chip->option.debounce_num - 1))) {\r\nreset_map |= MS_CARD;\r\n}\r\n}\r\nrts51x_write_register(chip, CARD_INT_PEND, XD_INT | MS_INT | SD_INT,\r\nXD_INT | MS_INT | SD_INT);\r\nExit_Debounce:\r\nif (need_reset)\r\n*need_reset = reset_map;\r\nif (need_release)\r\n*need_release = release_map;\r\n}\r\nvoid rts51x_init_cards(struct rts51x_chip *chip)\r\n{\r\nu8 need_reset = 0, need_release = 0;\r\ncard_cd_debounce(chip, &need_reset, &need_release);\r\nif (need_release) {\r\nRTS51X_DEBUGP("need_release = 0x%x\n", need_release);\r\nrts51x_prepare_run(chip);\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\n#ifdef SUPPORT_OCP\r\nif (chip->ocp_stat & (MS_OCP_NOW | MS_OCP_EVER)) {\r\nrts51x_write_register(chip, OCPCTL, MS_OCP_CLEAR,\r\nMS_OCP_CLEAR);\r\nchip->ocp_stat = 0;\r\nRTS51X_DEBUGP("Clear OCP status.\n");\r\n}\r\n#endif\r\nif (need_release & XD_CARD) {\r\nchip->card_exist &= ~XD_CARD;\r\nchip->card_ejected = 0;\r\nif (chip->card_ready & XD_CARD) {\r\nrts51x_release_xd_card(chip);\r\nchip->rw_card[chip->card2lun[XD_CARD]] = NULL;\r\nclear_bit(chip->card2lun[XD_CARD],\r\n&(chip->lun_mc));\r\n}\r\n}\r\nif (need_release & SD_CARD) {\r\nchip->card_exist &= ~SD_CARD;\r\nchip->card_ejected = 0;\r\nif (chip->card_ready & SD_CARD) {\r\nrts51x_release_sd_card(chip);\r\nchip->rw_card[chip->card2lun[SD_CARD]] = NULL;\r\nclear_bit(chip->card2lun[SD_CARD],\r\n&(chip->lun_mc));\r\n}\r\n}\r\nif (need_release & MS_CARD) {\r\nchip->card_exist &= ~MS_CARD;\r\nchip->card_ejected = 0;\r\nif (chip->card_ready & MS_CARD) {\r\nrts51x_release_ms_card(chip);\r\nchip->rw_card[chip->card2lun[MS_CARD]] = NULL;\r\nclear_bit(chip->card2lun[MS_CARD],\r\n&(chip->lun_mc));\r\n}\r\n}\r\n}\r\nif (need_reset && !chip->card_ready) {\r\nRTS51X_DEBUGP("need_reset = 0x%x\n", need_reset);\r\nrts51x_prepare_run(chip);\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nif (need_reset & XD_CARD) {\r\nchip->card_exist |= XD_CARD;\r\ndo_rts51x_reset_xd_card(chip);\r\n} else if (need_reset & SD_CARD) {\r\nchip->card_exist |= SD_CARD;\r\nrts51x_do_rts51x_reset_sd_card(chip);\r\n} else if (need_reset & MS_CARD) {\r\nchip->card_exist |= MS_CARD;\r\ndo_rts51x_reset_ms_card(chip);\r\n}\r\n}\r\n}\r\nvoid rts51x_release_cards(struct rts51x_chip *chip)\r\n{\r\nif (chip->card_ready & SD_CARD) {\r\nrts51x_sd_cleanup_work(chip);\r\nrts51x_release_sd_card(chip);\r\nchip->card_ready &= ~SD_CARD;\r\n}\r\nif (chip->card_ready & XD_CARD) {\r\nrts51x_xd_cleanup_work(chip);\r\nrts51x_release_xd_card(chip);\r\nchip->card_ready &= ~XD_CARD;\r\n}\r\nif (chip->card_ready & MS_CARD) {\r\nrts51x_ms_cleanup_work(chip);\r\nrts51x_release_ms_card(chip);\r\nchip->card_ready &= ~MS_CARD;\r\n}\r\n}\r\nstatic inline u8 double_depth(u8 depth)\r\n{\r\nreturn ((depth > 1) ? (depth - 1) : depth);\r\n}\r\nint rts51x_switch_ssc_clock(struct rts51x_chip *chip, int clk)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nint retval;\r\nu8 N = (u8) (clk - 2), min_N, max_N;\r\nu8 mcu_cnt, div, max_div, ssc_depth;\r\nint sd_vpclk_phase_reset = 0;\r\nif (chip->cur_clk == clk)\r\nreturn STATUS_SUCCESS;\r\nmin_N = 60;\r\nmax_N = 120;\r\nmax_div = CLK_DIV_4;\r\nRTS51X_DEBUGP("Switch SSC clock to %dMHz\n", clk);\r\nif ((clk <= 2) || (N > max_N))\r\nTRACE_RET(chip, STATUS_FAIL);\r\nmcu_cnt = (u8) (60 / clk + 3);\r\nif (mcu_cnt > 15)\r\nmcu_cnt = 15;\r\ndiv = CLK_DIV_1;\r\nwhile ((N < min_N) && (div < max_div)) {\r\nN = (N + 2) * 2 - 2;\r\ndiv++;\r\n}\r\nRTS51X_DEBUGP("N = %d, div = %d\n", N, div);\r\nif (chip->option.ssc_en) {\r\nif (chip->cur_card == SD_CARD) {\r\nif (CHK_SD_SDR104(sd_card)) {\r\nssc_depth = chip->option.ssc_depth_sd_sdr104;\r\n} else if (CHK_SD_SDR50(sd_card)) {\r\nssc_depth = chip->option.ssc_depth_sd_sdr50;\r\n} else if (CHK_SD_DDR50(sd_card)) {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_sd_ddr50);\r\n} else if (CHK_SD_HS(sd_card)) {\r\nssc_depth =\r\ndouble_depth(chip->option.ssc_depth_sd_hs);\r\n} else if (CHK_MMC_52M(sd_card)\r\n|| CHK_MMC_DDR52(sd_card)) {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_mmc_52m);\r\n} else {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_low_speed);\r\n}\r\n} else if (chip->cur_card == MS_CARD) {\r\nif (CHK_MSPRO(ms_card)) {\r\nif (CHK_HG8BIT(ms_card)) {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_ms_hg);\r\n} else {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_ms_4bit);\r\n}\r\n} else {\r\nif (CHK_MS4BIT(ms_card)) {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_ms_4bit);\r\n} else {\r\nssc_depth =\r\ndouble_depth(chip->option.\r\nssc_depth_low_speed);\r\n}\r\n}\r\n} else {\r\nssc_depth =\r\ndouble_depth(chip->option.ssc_depth_low_speed);\r\n}\r\nif (ssc_depth) {\r\nif (div == CLK_DIV_2) {\r\nif (ssc_depth > 1)\r\nssc_depth -= 1;\r\nelse\r\nssc_depth = SSC_DEPTH_2M;\r\n} else if (div == CLK_DIV_4) {\r\nif (ssc_depth > 2)\r\nssc_depth -= 2;\r\nelse\r\nssc_depth = SSC_DEPTH_2M;\r\n}\r\n}\r\n} else {\r\nssc_depth = 0;\r\n}\r\nRTS51X_DEBUGP("ssc_depth = %d\n", ssc_depth);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, CLK_CHANGE);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, 0x3F,\r\n(div << 4) | mcu_cnt);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SSC_CTL2, SSC_DEPTH_MASK,\r\nssc_depth);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, N);\r\nif (sd_vpclk_phase_reset) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, PHASE_NOT_RESET);\r\n}\r\nretval = rts51x_send_cmd(chip, MODE_C, 2000);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (chip->option.ssc_en && ssc_depth)\r\nrts51x_write_register(chip, SSC_CTL1, 0xff, 0xD0);\r\nelse\r\nrts51x_write_register(chip, SSC_CTL1, 0xff, 0x50);\r\nudelay(100);\r\nRTS51X_WRITE_REG(chip, CLK_DIV, CLK_CHANGE, 0);\r\nchip->cur_clk = clk;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_switch_normal_clock(struct rts51x_chip *chip, int clk)\r\n{\r\nint retval;\r\nu8 sel, div, mcu_cnt;\r\nint sd_vpclk_phase_reset = 0;\r\nif (chip->cur_clk == clk)\r\nreturn STATUS_SUCCESS;\r\nif (chip->cur_card == SD_CARD) {\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nif (CHK_SD30_SPEED(sd_card) || CHK_MMC_DDR52(sd_card))\r\nsd_vpclk_phase_reset = 1;\r\n}\r\nswitch (clk) {\r\ncase CLK_20:\r\nRTS51X_DEBUGP("Switch clock to 20MHz\n");\r\nsel = SSC_80;\r\ndiv = CLK_DIV_4;\r\nmcu_cnt = 5;\r\nbreak;\r\ncase CLK_30:\r\nRTS51X_DEBUGP("Switch clock to 30MHz\n");\r\nsel = SSC_60;\r\ndiv = CLK_DIV_2;\r\nmcu_cnt = 4;\r\nbreak;\r\ncase CLK_40:\r\nRTS51X_DEBUGP("Switch clock to 40MHz\n");\r\nsel = SSC_80;\r\ndiv = CLK_DIV_2;\r\nmcu_cnt = 3;\r\nbreak;\r\ncase CLK_50:\r\nRTS51X_DEBUGP("Switch clock to 50MHz\n");\r\nsel = SSC_100;\r\ndiv = CLK_DIV_2;\r\nmcu_cnt = 3;\r\nbreak;\r\ncase CLK_60:\r\nRTS51X_DEBUGP("Switch clock to 60MHz\n");\r\nsel = SSC_60;\r\ndiv = CLK_DIV_1;\r\nmcu_cnt = 3;\r\nbreak;\r\ncase CLK_80:\r\nRTS51X_DEBUGP("Switch clock to 80MHz\n");\r\nsel = SSC_80;\r\ndiv = CLK_DIV_1;\r\nmcu_cnt = 2;\r\nbreak;\r\ncase CLK_100:\r\nRTS51X_DEBUGP("Switch clock to 100MHz\n");\r\nsel = SSC_100;\r\ndiv = CLK_DIV_1;\r\nmcu_cnt = 2;\r\nbreak;\r\ndefault:\r\nRTS51X_DEBUGP("Try to switch to an illegal clock (%d)\n",\r\nclk);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (!sd_vpclk_phase_reset) {\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE,\r\nCLK_CHANGE);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, 0x3F,\r\n(div << 4) | mcu_cnt);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SSC_CLK_FPGA_SEL, 0xFF,\r\nsel);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, 0);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n} else {\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE,\r\nCLK_CHANGE);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK1_CTL,\r\nPHASE_NOT_RESET, 0);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CLK_DIV, 0x3F,\r\n(div << 4) | mcu_cnt);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SSC_CLK_FPGA_SEL, 0xFF,\r\nsel);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nudelay(200);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, PHASE_NOT_RESET);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, SD_VPCLK1_CTL,\r\nPHASE_NOT_RESET, PHASE_NOT_RESET);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nudelay(200);\r\nRTS51X_WRITE_REG(chip, CLK_DIV, CLK_CHANGE, 0);\r\n}\r\nchip->cur_clk = clk;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_card_rw(struct scsi_cmnd *srb, struct rts51x_chip *chip, u32 sec_addr,\r\nu16 sec_cnt)\r\n{\r\nint retval;\r\nunsigned int lun = SCSI_LUN(srb);\r\nint i;\r\nif (chip->rw_card[lun] == NULL)\r\nreturn STATUS_FAIL;\r\nRTS51X_DEBUGP("%s card, sector addr: 0x%x, sector cnt: %d\n",\r\n(srb->sc_data_direction ==\r\nDMA_TO_DEVICE) ? "Write" : "Read", sec_addr, sec_cnt);\r\nchip->rw_need_retry = 0;\r\nfor (i = 0; i < 3; i++) {\r\nretval = chip->rw_card[lun] (srb, chip, sec_addr, sec_cnt);\r\nif (retval != STATUS_SUCCESS) {\r\nCATCH_TRIGGER(chip);\r\nif (chip->option.reset_or_rw_fail_set_pad_drive) {\r\nrts51x_write_register(chip, CARD_DRIVE_SEL,\r\nSD20_DRIVE_MASK,\r\nDRIVE_8mA);\r\n}\r\n}\r\nif (!chip->rw_need_retry)\r\nbreak;\r\nRTS51X_DEBUGP("Retry RW, (i = %d\n)", i);\r\n}\r\nreturn retval;\r\n}\r\nu8 rts51x_get_lun_card(struct rts51x_chip *chip, unsigned int lun)\r\n{\r\nif ((chip->card_ready & chip->lun2card[lun]) == XD_CARD)\r\nreturn (u8) XD_CARD;\r\nelse if ((chip->card_ready & chip->lun2card[lun]) == SD_CARD)\r\nreturn (u8) SD_CARD;\r\nelse if ((chip->card_ready & chip->lun2card[lun]) == MS_CARD)\r\nreturn (u8) MS_CARD;\r\nreturn 0;\r\n}\r\nstatic int card_share_mode(struct rts51x_chip *chip, int card)\r\n{\r\nu8 value;\r\nif (card == SD_CARD)\r\nvalue = CARD_SHARE_SD;\r\nelse if (card == MS_CARD)\r\nvalue = CARD_SHARE_MS;\r\nelse if (card == XD_CARD)\r\nvalue = CARD_SHARE_XD;\r\nelse\r\nTRACE_RET(chip, STATUS_FAIL);\r\nRTS51X_WRITE_REG(chip, CARD_SHARE_MODE, CARD_SHARE_MASK, value);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_select_card(struct rts51x_chip *chip, int card)\r\n{\r\nint retval;\r\nif (chip->cur_card != card) {\r\nu8 mod;\r\nif (card == SD_CARD)\r\nmod = SD_MOD_SEL;\r\nelse if (card == MS_CARD)\r\nmod = MS_MOD_SEL;\r\nelse if (card == XD_CARD)\r\nmod = XD_MOD_SEL;\r\nelse\r\nTRACE_RET(chip, STATUS_FAIL);\r\nRTS51X_WRITE_REG(chip, CARD_SELECT, 0x07, mod);\r\nchip->cur_card = card;\r\nretval = card_share_mode(chip, card);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rts51x_eject_card(struct rts51x_chip *chip, unsigned int lun)\r\n{\r\nRTS51X_DEBUGP("eject card\n");\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nrts51x_do_remaining_work(chip);\r\nif ((chip->card_ready & chip->lun2card[lun]) == SD_CARD) {\r\nrts51x_release_sd_card(chip);\r\nchip->card_ejected |= SD_CARD;\r\nchip->card_ready &= ~SD_CARD;\r\nchip->capacity[lun] = 0;\r\n} else if ((chip->card_ready & chip->lun2card[lun]) == XD_CARD) {\r\nrts51x_release_xd_card(chip);\r\nchip->card_ejected |= XD_CARD;\r\nchip->card_ready &= ~XD_CARD;\r\nchip->capacity[lun] = 0;\r\n} else if ((chip->card_ready & chip->lun2card[lun]) == MS_CARD) {\r\nrts51x_release_ms_card(chip);\r\nchip->card_ejected |= MS_CARD;\r\nchip->card_ready &= ~MS_CARD;\r\nchip->capacity[lun] = 0;\r\n}\r\nrts51x_write_register(chip, CARD_INT_PEND, XD_INT | MS_INT | SD_INT,\r\nXD_INT | MS_INT | SD_INT);\r\n}\r\nvoid rts51x_trans_dma_enable(enum dma_data_direction dir, struct rts51x_chip *chip,\r\nu32 byte_cnt, u8 pack_size)\r\n{\r\nif (pack_size > DMA_1024)\r\npack_size = DMA_512;\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01,\r\nRING_BUFFER);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, MC_DMA_TC3, 0xFF,\r\n(u8) (byte_cnt >> 24));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, MC_DMA_TC2, 0xFF,\r\n(u8) (byte_cnt >> 16));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, MC_DMA_TC1, 0xFF,\r\n(u8) (byte_cnt >> 8));\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, MC_DMA_TC0, 0xFF, (u8) byte_cnt);\r\nif (dir == DMA_FROM_DEVICE) {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, MC_DMA_CTL,\r\n0x03 | DMA_PACK_SIZE_MASK,\r\nDMA_DIR_FROM_CARD | DMA_EN | pack_size);\r\n} else {\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, MC_DMA_CTL,\r\n0x03 | DMA_PACK_SIZE_MASK,\r\nDMA_DIR_TO_CARD | DMA_EN | pack_size);\r\n}\r\n}\r\nint rts51x_enable_card_clock(struct rts51x_chip *chip, u8 card)\r\n{\r\nu8 clk_en = 0;\r\nif (card & XD_CARD)\r\nclk_en |= XD_CLK_EN;\r\nif (card & SD_CARD)\r\nclk_en |= SD_CLK_EN;\r\nif (card & MS_CARD)\r\nclk_en |= MS_CLK_EN;\r\nRTS51X_WRITE_REG(chip, CARD_CLK_EN, clk_en, clk_en);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_card_power_on(struct rts51x_chip *chip, u8 card)\r\n{\r\nu8 mask, val1, val2;\r\nmask = POWER_MASK;\r\nval1 = PARTIAL_POWER_ON;\r\nval2 = POWER_ON;\r\n#ifdef SD_XD_IO_FOLLOW_PWR\r\nif ((card == SD_CARD) || (card == XD_CARD)) {\r\nRTS51X_WRITE_REG(chip, CARD_PWR_CTL, mask | LDO3318_PWR_MASK,\r\nval1 | LDO_SUSPEND);\r\n} else {\r\n#endif\r\nRTS51X_WRITE_REG(chip, CARD_PWR_CTL, mask, val1);\r\n#ifdef SD_XD_IO_FOLLOW_PWR\r\n}\r\n#endif\r\nudelay(chip->option.pwr_delay);\r\nRTS51X_WRITE_REG(chip, CARD_PWR_CTL, mask, val2);\r\n#ifdef SD_XD_IO_FOLLOW_PWR\r\nif (card == SD_CARD) {\r\nrts51x_write_register(chip, CARD_PWR_CTL, LDO3318_PWR_MASK,\r\nLDO_ON);\r\n}\r\n#endif\r\nreturn STATUS_SUCCESS;\r\n}\r\nint monitor_card_cd(struct rts51x_chip *chip, u8 card)\r\n{\r\nint retval;\r\nu8 card_cd[32] = { 0 };\r\ncard_cd[SD_CARD] = SD_CD;\r\ncard_cd[XD_CARD] = XD_CD;\r\ncard_cd[MS_CARD] = MS_CD;\r\nretval = rts51x_get_card_status(chip, &(chip->card_status));\r\nif (retval != STATUS_SUCCESS)\r\nreturn CD_NOT_EXIST;\r\nif (chip->card_status & card_cd[card])\r\nreturn CD_EXIST;\r\nreturn CD_NOT_EXIST;\r\n}\r\nint rts51x_toggle_gpio(struct rts51x_chip *chip, u8 gpio)\r\n{\r\nint retval;\r\nu8 temp_reg;\r\nu8 gpio_output[4] = {\r\n0x01,\r\n};\r\nu8 gpio_oe[4] = {\r\n0x02,\r\n};\r\nif (chip->rts5179) {\r\nretval = rts51x_ep0_read_register(chip, CARD_GPIO, &temp_reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\ntemp_reg ^= gpio_oe[gpio];\r\ntemp_reg &= 0xfe;\r\nretval =\r\nrts51x_ep0_write_register(chip, CARD_GPIO, 0x03, temp_reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\n} else {\r\nretval = rts51x_ep0_read_register(chip, CARD_GPIO, &temp_reg);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\ntemp_reg ^= gpio_output[gpio];\r\nretval =\r\nrts51x_ep0_write_register(chip, CARD_GPIO, 0xFF,\r\ntemp_reg | gpio_oe[gpio]);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_turn_on_led(struct rts51x_chip *chip, u8 gpio)\r\n{\r\nint retval;\r\nu8 gpio_oe[4] = {\r\n0x02,\r\n};\r\nu8 gpio_mask[4] = {\r\n0x03,\r\n};\r\nretval =\r\nrts51x_ep0_write_register(chip, CARD_GPIO, gpio_mask[gpio],\r\ngpio_oe[gpio]);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_turn_off_led(struct rts51x_chip *chip, u8 gpio)\r\n{\r\nint retval;\r\nu8 gpio_output[4] = {\r\n0x01,\r\n};\r\nu8 gpio_oe[4] = {\r\n0x02,\r\n};\r\nu8 gpio_mask[4] = {\r\n0x03,\r\n};\r\nretval =\r\nrts51x_ep0_write_register(chip, CARD_GPIO, gpio_mask[gpio],\r\ngpio_oe[gpio] | gpio_output[gpio]);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nreturn STATUS_SUCCESS;\r\n}
