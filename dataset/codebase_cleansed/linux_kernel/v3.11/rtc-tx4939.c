static struct tx4939rtc_plat_data *get_tx4939rtc_plat_data(struct device *dev)\r\n{\r\nreturn platform_get_drvdata(to_platform_device(dev));\r\n}\r\nstatic int tx4939_rtc_cmd(struct tx4939_rtc_reg __iomem *rtcreg, int cmd)\r\n{\r\nint i = 0;\r\n__raw_writel(cmd, &rtcreg->ctl);\r\nwhile (__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_BUSY) {\r\nif (i++ > 200 * 100)\r\nreturn -EBUSY;\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic int tx4939_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nint i, ret;\r\nunsigned char buf[6];\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nbuf[2] = secs;\r\nbuf[3] = secs >> 8;\r\nbuf[4] = secs >> 16;\r\nbuf[5] = secs >> 24;\r\nspin_lock_irq(&pdata->lock);\r\n__raw_writel(0, &rtcreg->adr);\r\nfor (i = 0; i < 6; i++)\r\n__raw_writel(buf[i], &rtcreg->dat);\r\nret = tx4939_rtc_cmd(rtcreg,\r\nTX4939_RTCCTL_COMMAND_SETTIME |\r\n(__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_ALME));\r\nspin_unlock_irq(&pdata->lock);\r\nreturn ret;\r\n}\r\nstatic int tx4939_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nint i, ret;\r\nunsigned long sec;\r\nunsigned char buf[6];\r\nspin_lock_irq(&pdata->lock);\r\nret = tx4939_rtc_cmd(rtcreg,\r\nTX4939_RTCCTL_COMMAND_GETTIME |\r\n(__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_ALME));\r\nif (ret) {\r\nspin_unlock_irq(&pdata->lock);\r\nreturn ret;\r\n}\r\n__raw_writel(2, &rtcreg->adr);\r\nfor (i = 2; i < 6; i++)\r\nbuf[i] = __raw_readl(&rtcreg->dat);\r\nspin_unlock_irq(&pdata->lock);\r\nsec = (buf[5] << 24) | (buf[4] << 16) | (buf[3] << 8) | buf[2];\r\nrtc_time_to_tm(sec, tm);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int tx4939_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nint i, ret;\r\nunsigned long sec;\r\nunsigned char buf[6];\r\nif (alrm->time.tm_sec < 0 ||\r\nalrm->time.tm_min < 0 ||\r\nalrm->time.tm_hour < 0 ||\r\nalrm->time.tm_mday < 0 ||\r\nalrm->time.tm_mon < 0 ||\r\nalrm->time.tm_year < 0)\r\nreturn -EINVAL;\r\nrtc_tm_to_time(&alrm->time, &sec);\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nbuf[2] = sec;\r\nbuf[3] = sec >> 8;\r\nbuf[4] = sec >> 16;\r\nbuf[5] = sec >> 24;\r\nspin_lock_irq(&pdata->lock);\r\n__raw_writel(0, &rtcreg->adr);\r\nfor (i = 0; i < 6; i++)\r\n__raw_writel(buf[i], &rtcreg->dat);\r\nret = tx4939_rtc_cmd(rtcreg, TX4939_RTCCTL_COMMAND_SETALARM |\r\n(alrm->enabled ? TX4939_RTCCTL_ALME : 0));\r\nspin_unlock_irq(&pdata->lock);\r\nreturn ret;\r\n}\r\nstatic int tx4939_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nint i, ret;\r\nunsigned long sec;\r\nunsigned char buf[6];\r\nu32 ctl;\r\nspin_lock_irq(&pdata->lock);\r\nret = tx4939_rtc_cmd(rtcreg,\r\nTX4939_RTCCTL_COMMAND_GETALARM |\r\n(__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_ALME));\r\nif (ret) {\r\nspin_unlock_irq(&pdata->lock);\r\nreturn ret;\r\n}\r\n__raw_writel(2, &rtcreg->adr);\r\nfor (i = 2; i < 6; i++)\r\nbuf[i] = __raw_readl(&rtcreg->dat);\r\nctl = __raw_readl(&rtcreg->ctl);\r\nalrm->enabled = (ctl & TX4939_RTCCTL_ALME) ? 1 : 0;\r\nalrm->pending = (ctl & TX4939_RTCCTL_ALMD) ? 1 : 0;\r\nspin_unlock_irq(&pdata->lock);\r\nsec = (buf[5] << 24) | (buf[4] << 16) | (buf[3] << 8) | buf[2];\r\nrtc_time_to_tm(sec, &alrm->time);\r\nreturn rtc_valid_tm(&alrm->time);\r\n}\r\nstatic int tx4939_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nspin_lock_irq(&pdata->lock);\r\ntx4939_rtc_cmd(pdata->rtcreg,\r\nTX4939_RTCCTL_COMMAND_NOP |\r\n(enabled ? TX4939_RTCCTL_ALME : 0));\r\nspin_unlock_irq(&pdata->lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tx4939_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev_id);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nunsigned long events = RTC_IRQF;\r\nspin_lock(&pdata->lock);\r\nif (__raw_readl(&rtcreg->ctl) & TX4939_RTCCTL_ALMD) {\r\nevents |= RTC_AF;\r\ntx4939_rtc_cmd(rtcreg, TX4939_RTCCTL_COMMAND_NOP);\r\n}\r\nspin_unlock(&pdata->lock);\r\nif (likely(pdata->rtc))\r\nrtc_update_irq(pdata->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t tx4939_rtc_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nssize_t count;\r\nspin_lock_irq(&pdata->lock);\r\nfor (count = 0; size > 0 && pos < TX4939_RTC_REG_RAMSIZE;\r\ncount++, size--) {\r\n__raw_writel(pos++, &rtcreg->adr);\r\n*buf++ = __raw_readl(&rtcreg->dat);\r\n}\r\nspin_unlock_irq(&pdata->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t tx4939_rtc_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct tx4939rtc_plat_data *pdata = get_tx4939rtc_plat_data(dev);\r\nstruct tx4939_rtc_reg __iomem *rtcreg = pdata->rtcreg;\r\nssize_t count;\r\nspin_lock_irq(&pdata->lock);\r\nfor (count = 0; size > 0 && pos < TX4939_RTC_REG_RAMSIZE;\r\ncount++, size--) {\r\n__raw_writel(pos++, &rtcreg->adr);\r\n__raw_writel(*buf++, &rtcreg->dat);\r\n}\r\nspin_unlock_irq(&pdata->lock);\r\nreturn count;\r\n}\r\nstatic int __init tx4939_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc;\r\nstruct tx4939rtc_plat_data *pdata;\r\nstruct resource *res;\r\nint irq, ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -ENODEV;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pdata);\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name))\r\nreturn -EBUSY;\r\npdata->rtcreg = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!pdata->rtcreg)\r\nreturn -EBUSY;\r\nspin_lock_init(&pdata->lock);\r\ntx4939_rtc_cmd(pdata->rtcreg, TX4939_RTCCTL_COMMAND_NOP);\r\nif (devm_request_irq(&pdev->dev, irq, tx4939_rtc_interrupt,\r\n0, pdev->name, &pdev->dev) < 0)\r\nreturn -EBUSY;\r\nrtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&tx4939_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\npdata->rtc = rtc;\r\nret = sysfs_create_bin_file(&pdev->dev.kobj, &tx4939_rtc_nvram_attr);\r\nreturn ret;\r\n}\r\nstatic int __exit tx4939_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct tx4939rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nsysfs_remove_bin_file(&pdev->dev.kobj, &tx4939_rtc_nvram_attr);\r\nspin_lock_irq(&pdata->lock);\r\ntx4939_rtc_cmd(pdata->rtcreg, TX4939_RTCCTL_COMMAND_NOP);\r\nspin_unlock_irq(&pdata->lock);\r\nreturn 0;\r\n}
