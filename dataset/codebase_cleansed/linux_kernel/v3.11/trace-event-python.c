static void handler_call_die(const char *handler_name)\r\n{\r\nPyErr_Print();\r\nPy_FatalError("problem in Python trace event handler");\r\n}\r\nstatic void define_value(enum print_arg_type field_type,\r\nconst char *ev_name,\r\nconst char *field_name,\r\nconst char *field_value,\r\nconst char *field_str)\r\n{\r\nconst char *handler_name = "define_flag_value";\r\nPyObject *handler, *t, *retval;\r\nunsigned long long value;\r\nunsigned n = 0;\r\nif (field_type == PRINT_SYMBOL)\r\nhandler_name = "define_symbolic_value";\r\nt = PyTuple_New(4);\r\nif (!t)\r\nPy_FatalError("couldn't create Python tuple");\r\nvalue = eval_flag(field_value);\r\nPyTuple_SetItem(t, n++, PyString_FromString(ev_name));\r\nPyTuple_SetItem(t, n++, PyString_FromString(field_name));\r\nPyTuple_SetItem(t, n++, PyInt_FromLong(value));\r\nPyTuple_SetItem(t, n++, PyString_FromString(field_str));\r\nhandler = PyDict_GetItemString(main_dict, handler_name);\r\nif (handler && PyCallable_Check(handler)) {\r\nretval = PyObject_CallObject(handler, t);\r\nif (retval == NULL)\r\nhandler_call_die(handler_name);\r\n}\r\nPy_DECREF(t);\r\n}\r\nstatic void define_values(enum print_arg_type field_type,\r\nstruct print_flag_sym *field,\r\nconst char *ev_name,\r\nconst char *field_name)\r\n{\r\ndefine_value(field_type, ev_name, field_name, field->value,\r\nfield->str);\r\nif (field->next)\r\ndefine_values(field_type, field->next, ev_name, field_name);\r\n}\r\nstatic void define_field(enum print_arg_type field_type,\r\nconst char *ev_name,\r\nconst char *field_name,\r\nconst char *delim)\r\n{\r\nconst char *handler_name = "define_flag_field";\r\nPyObject *handler, *t, *retval;\r\nunsigned n = 0;\r\nif (field_type == PRINT_SYMBOL)\r\nhandler_name = "define_symbolic_field";\r\nif (field_type == PRINT_FLAGS)\r\nt = PyTuple_New(3);\r\nelse\r\nt = PyTuple_New(2);\r\nif (!t)\r\nPy_FatalError("couldn't create Python tuple");\r\nPyTuple_SetItem(t, n++, PyString_FromString(ev_name));\r\nPyTuple_SetItem(t, n++, PyString_FromString(field_name));\r\nif (field_type == PRINT_FLAGS)\r\nPyTuple_SetItem(t, n++, PyString_FromString(delim));\r\nhandler = PyDict_GetItemString(main_dict, handler_name);\r\nif (handler && PyCallable_Check(handler)) {\r\nretval = PyObject_CallObject(handler, t);\r\nif (retval == NULL)\r\nhandler_call_die(handler_name);\r\n}\r\nPy_DECREF(t);\r\n}\r\nstatic void define_event_symbols(struct event_format *event,\r\nconst char *ev_name,\r\nstruct print_arg *args)\r\n{\r\nswitch (args->type) {\r\ncase PRINT_NULL:\r\nbreak;\r\ncase PRINT_ATOM:\r\ndefine_value(PRINT_FLAGS, ev_name, cur_field_name, "0",\r\nargs->atom.atom);\r\nzero_flag_atom = 0;\r\nbreak;\r\ncase PRINT_FIELD:\r\nif (cur_field_name)\r\nfree(cur_field_name);\r\ncur_field_name = strdup(args->field.name);\r\nbreak;\r\ncase PRINT_FLAGS:\r\ndefine_event_symbols(event, ev_name, args->flags.field);\r\ndefine_field(PRINT_FLAGS, ev_name, cur_field_name,\r\nargs->flags.delim);\r\ndefine_values(PRINT_FLAGS, args->flags.flags, ev_name,\r\ncur_field_name);\r\nbreak;\r\ncase PRINT_SYMBOL:\r\ndefine_event_symbols(event, ev_name, args->symbol.field);\r\ndefine_field(PRINT_SYMBOL, ev_name, cur_field_name, NULL);\r\ndefine_values(PRINT_SYMBOL, args->symbol.symbols, ev_name,\r\ncur_field_name);\r\nbreak;\r\ncase PRINT_HEX:\r\ndefine_event_symbols(event, ev_name, args->hex.field);\r\ndefine_event_symbols(event, ev_name, args->hex.size);\r\nbreak;\r\ncase PRINT_STRING:\r\nbreak;\r\ncase PRINT_TYPE:\r\ndefine_event_symbols(event, ev_name, args->typecast.item);\r\nbreak;\r\ncase PRINT_OP:\r\nif (strcmp(args->op.op, ":") == 0)\r\nzero_flag_atom = 1;\r\ndefine_event_symbols(event, ev_name, args->op.left);\r\ndefine_event_symbols(event, ev_name, args->op.right);\r\nbreak;\r\ndefault:\r\ncase PRINT_BSTRING:\r\ncase PRINT_DYNAMIC_ARRAY:\r\ncase PRINT_FUNC:\r\nreturn;\r\n}\r\nif (args->next)\r\ndefine_event_symbols(event, ev_name, args->next);\r\n}\r\nstatic inline struct event_format *find_cache_event(struct perf_evsel *evsel)\r\n{\r\nstatic char ev_name[256];\r\nstruct event_format *event;\r\nint type = evsel->attr.config;\r\nif (events[type])\r\nreturn events[type];\r\nevents[type] = event = evsel->tp_format;\r\nif (!event)\r\nreturn NULL;\r\nsprintf(ev_name, "%s__%s", event->system, event->name);\r\ndefine_event_symbols(event, ev_name, event->print_fmt.args);\r\nreturn event;\r\n}\r\nstatic void python_process_tracepoint(union perf_event *perf_event\r\n__maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine __maybe_unused,\r\nstruct addr_location *al)\r\n{\r\nPyObject *handler, *retval, *context, *t, *obj, *dict = NULL;\r\nstatic char handler_name[256];\r\nstruct format_field *field;\r\nunsigned long long val;\r\nunsigned long s, ns;\r\nstruct event_format *event;\r\nunsigned n = 0;\r\nint pid;\r\nint cpu = sample->cpu;\r\nvoid *data = sample->raw_data;\r\nunsigned long long nsecs = sample->time;\r\nstruct thread *thread = al->thread;\r\nchar *comm = thread->comm;\r\nt = PyTuple_New(MAX_FIELDS);\r\nif (!t)\r\nPy_FatalError("couldn't create Python tuple");\r\nevent = find_cache_event(evsel);\r\nif (!event)\r\ndie("ug! no event found for type %d", (int)evsel->attr.config);\r\npid = raw_field_value(event, "common_pid", data);\r\nsprintf(handler_name, "%s__%s", event->system, event->name);\r\nhandler = PyDict_GetItemString(main_dict, handler_name);\r\nif (handler && !PyCallable_Check(handler))\r\nhandler = NULL;\r\nif (!handler) {\r\ndict = PyDict_New();\r\nif (!dict)\r\nPy_FatalError("couldn't create Python dict");\r\n}\r\ns = nsecs / NSECS_PER_SEC;\r\nns = nsecs - s * NSECS_PER_SEC;\r\nscripting_context->event_data = data;\r\nscripting_context->pevent = evsel->tp_format->pevent;\r\ncontext = PyCObject_FromVoidPtr(scripting_context, NULL);\r\nPyTuple_SetItem(t, n++, PyString_FromString(handler_name));\r\nPyTuple_SetItem(t, n++, context);\r\nif (handler) {\r\nPyTuple_SetItem(t, n++, PyInt_FromLong(cpu));\r\nPyTuple_SetItem(t, n++, PyInt_FromLong(s));\r\nPyTuple_SetItem(t, n++, PyInt_FromLong(ns));\r\nPyTuple_SetItem(t, n++, PyInt_FromLong(pid));\r\nPyTuple_SetItem(t, n++, PyString_FromString(comm));\r\n} else {\r\nPyDict_SetItemString(dict, "common_cpu", PyInt_FromLong(cpu));\r\nPyDict_SetItemString(dict, "common_s", PyInt_FromLong(s));\r\nPyDict_SetItemString(dict, "common_ns", PyInt_FromLong(ns));\r\nPyDict_SetItemString(dict, "common_pid", PyInt_FromLong(pid));\r\nPyDict_SetItemString(dict, "common_comm", PyString_FromString(comm));\r\n}\r\nfor (field = event->format.fields; field; field = field->next) {\r\nif (field->flags & FIELD_IS_STRING) {\r\nint offset;\r\nif (field->flags & FIELD_IS_DYNAMIC) {\r\noffset = *(int *)(data + field->offset);\r\noffset &= 0xffff;\r\n} else\r\noffset = field->offset;\r\nobj = PyString_FromString((char *)data + offset);\r\n} else {\r\nval = read_size(event, data + field->offset,\r\nfield->size);\r\nif (field->flags & FIELD_IS_SIGNED) {\r\nif ((long long)val >= LONG_MIN &&\r\n(long long)val <= LONG_MAX)\r\nobj = PyInt_FromLong(val);\r\nelse\r\nobj = PyLong_FromLongLong(val);\r\n} else {\r\nif (val <= LONG_MAX)\r\nobj = PyInt_FromLong(val);\r\nelse\r\nobj = PyLong_FromUnsignedLongLong(val);\r\n}\r\n}\r\nif (handler)\r\nPyTuple_SetItem(t, n++, obj);\r\nelse\r\nPyDict_SetItemString(dict, field->name, obj);\r\n}\r\nif (!handler)\r\nPyTuple_SetItem(t, n++, dict);\r\nif (_PyTuple_Resize(&t, n) == -1)\r\nPy_FatalError("error resizing Python tuple");\r\nif (handler) {\r\nretval = PyObject_CallObject(handler, t);\r\nif (retval == NULL)\r\nhandler_call_die(handler_name);\r\n} else {\r\nhandler = PyDict_GetItemString(main_dict, "trace_unhandled");\r\nif (handler && PyCallable_Check(handler)) {\r\nretval = PyObject_CallObject(handler, t);\r\nif (retval == NULL)\r\nhandler_call_die("trace_unhandled");\r\n}\r\nPy_DECREF(dict);\r\n}\r\nPy_DECREF(t);\r\n}\r\nstatic void python_process_general_event(union perf_event *perf_event\r\n__maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine __maybe_unused,\r\nstruct addr_location *al)\r\n{\r\nPyObject *handler, *retval, *t, *dict;\r\nstatic char handler_name[64];\r\nunsigned n = 0;\r\nstruct thread *thread = al->thread;\r\nt = PyTuple_New(MAX_FIELDS);\r\nif (!t)\r\nPy_FatalError("couldn't create Python tuple");\r\ndict = PyDict_New();\r\nif (!dict)\r\nPy_FatalError("couldn't create Python dictionary");\r\nsnprintf(handler_name, sizeof(handler_name), "%s", "process_event");\r\nhandler = PyDict_GetItemString(main_dict, handler_name);\r\nif (!handler || !PyCallable_Check(handler))\r\ngoto exit;\r\nPyDict_SetItemString(dict, "ev_name", PyString_FromString(perf_evsel__name(evsel)));\r\nPyDict_SetItemString(dict, "attr", PyString_FromStringAndSize(\r\n(const char *)&evsel->attr, sizeof(evsel->attr)));\r\nPyDict_SetItemString(dict, "sample", PyString_FromStringAndSize(\r\n(const char *)sample, sizeof(*sample)));\r\nPyDict_SetItemString(dict, "raw_buf", PyString_FromStringAndSize(\r\n(const char *)sample->raw_data, sample->raw_size));\r\nPyDict_SetItemString(dict, "comm",\r\nPyString_FromString(thread->comm));\r\nif (al->map) {\r\nPyDict_SetItemString(dict, "dso",\r\nPyString_FromString(al->map->dso->name));\r\n}\r\nif (al->sym) {\r\nPyDict_SetItemString(dict, "symbol",\r\nPyString_FromString(al->sym->name));\r\n}\r\nPyTuple_SetItem(t, n++, dict);\r\nif (_PyTuple_Resize(&t, n) == -1)\r\nPy_FatalError("error resizing Python tuple");\r\nretval = PyObject_CallObject(handler, t);\r\nif (retval == NULL)\r\nhandler_call_die(handler_name);\r\nexit:\r\nPy_DECREF(dict);\r\nPy_DECREF(t);\r\n}\r\nstatic void python_process_event(union perf_event *perf_event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine,\r\nstruct addr_location *al)\r\n{\r\nswitch (evsel->attr.type) {\r\ncase PERF_TYPE_TRACEPOINT:\r\npython_process_tracepoint(perf_event, sample, evsel,\r\nmachine, al);\r\nbreak;\r\ndefault:\r\npython_process_general_event(perf_event, sample, evsel,\r\nmachine, al);\r\n}\r\n}\r\nstatic int run_start_sub(void)\r\n{\r\nPyObject *handler, *retval;\r\nint err = 0;\r\nmain_module = PyImport_AddModule("__main__");\r\nif (main_module == NULL)\r\nreturn -1;\r\nPy_INCREF(main_module);\r\nmain_dict = PyModule_GetDict(main_module);\r\nif (main_dict == NULL) {\r\nerr = -1;\r\ngoto error;\r\n}\r\nPy_INCREF(main_dict);\r\nhandler = PyDict_GetItemString(main_dict, "trace_begin");\r\nif (handler == NULL || !PyCallable_Check(handler))\r\ngoto out;\r\nretval = PyObject_CallObject(handler, NULL);\r\nif (retval == NULL)\r\nhandler_call_die("trace_begin");\r\nPy_DECREF(retval);\r\nreturn err;\r\nerror:\r\nPy_XDECREF(main_dict);\r\nPy_XDECREF(main_module);\r\nout:\r\nreturn err;\r\n}\r\nstatic int python_start_script(const char *script, int argc, const char **argv)\r\n{\r\nconst char **command_line;\r\nchar buf[PATH_MAX];\r\nint i, err = 0;\r\nFILE *fp;\r\ncommand_line = malloc((argc + 1) * sizeof(const char *));\r\ncommand_line[0] = script;\r\nfor (i = 1; i < argc + 1; i++)\r\ncommand_line[i] = argv[i - 1];\r\nPy_Initialize();\r\ninitperf_trace_context();\r\nPySys_SetArgv(argc + 1, (char **)command_line);\r\nfp = fopen(script, "r");\r\nif (!fp) {\r\nsprintf(buf, "Can't open python script \"%s\"", script);\r\nperror(buf);\r\nerr = -1;\r\ngoto error;\r\n}\r\nerr = PyRun_SimpleFile(fp, script);\r\nif (err) {\r\nfprintf(stderr, "Error running python script %s\n", script);\r\ngoto error;\r\n}\r\nerr = run_start_sub();\r\nif (err) {\r\nfprintf(stderr, "Error starting python script %s\n", script);\r\ngoto error;\r\n}\r\nfree(command_line);\r\nreturn err;\r\nerror:\r\nPy_Finalize();\r\nfree(command_line);\r\nreturn err;\r\n}\r\nstatic int python_stop_script(void)\r\n{\r\nPyObject *handler, *retval;\r\nint err = 0;\r\nhandler = PyDict_GetItemString(main_dict, "trace_end");\r\nif (handler == NULL || !PyCallable_Check(handler))\r\ngoto out;\r\nretval = PyObject_CallObject(handler, NULL);\r\nif (retval == NULL)\r\nhandler_call_die("trace_end");\r\nelse\r\nPy_DECREF(retval);\r\nout:\r\nPy_XDECREF(main_dict);\r\nPy_XDECREF(main_module);\r\nPy_Finalize();\r\nreturn err;\r\n}\r\nstatic int python_generate_script(struct pevent *pevent, const char *outfile)\r\n{\r\nstruct event_format *event = NULL;\r\nstruct format_field *f;\r\nchar fname[PATH_MAX];\r\nint not_first, count;\r\nFILE *ofp;\r\nsprintf(fname, "%s.py", outfile);\r\nofp = fopen(fname, "w");\r\nif (ofp == NULL) {\r\nfprintf(stderr, "couldn't open %s\n", fname);\r\nreturn -1;\r\n}\r\nfprintf(ofp, "# perf script event handlers, "\r\n"generated by perf script -g python\n");\r\nfprintf(ofp, "# Licensed under the terms of the GNU GPL"\r\n" License version 2\n\n");\r\nfprintf(ofp, "# The common_* event handler fields are the most useful "\r\n"fields common to\n");\r\nfprintf(ofp, "# all events. They don't necessarily correspond to "\r\n"the 'common_*' fields\n");\r\nfprintf(ofp, "# in the format files. Those fields not available as "\r\n"handler params can\n");\r\nfprintf(ofp, "# be retrieved using Python functions of the form "\r\n"common_*(context).\n");\r\nfprintf(ofp, "# See the perf-trace-python Documentation for the list "\r\n"of available functions.\n\n");\r\nfprintf(ofp, "import os\n");\r\nfprintf(ofp, "import sys\n\n");\r\nfprintf(ofp, "sys.path.append(os.environ['PERF_EXEC_PATH'] + \\\n");\r\nfprintf(ofp, "\t'/scripts/python/Perf-Trace-Util/lib/Perf/Trace')\n");\r\nfprintf(ofp, "\nfrom perf_trace_context import *\n");\r\nfprintf(ofp, "from Core import *\n\n\n");\r\nfprintf(ofp, "def trace_begin():\n");\r\nfprintf(ofp, "\tprint \"in trace_begin\"\n\n");\r\nfprintf(ofp, "def trace_end():\n");\r\nfprintf(ofp, "\tprint \"in trace_end\"\n\n");\r\nwhile ((event = trace_find_next_event(pevent, event))) {\r\nfprintf(ofp, "def %s__%s(", event->system, event->name);\r\nfprintf(ofp, "event_name, ");\r\nfprintf(ofp, "context, ");\r\nfprintf(ofp, "common_cpu,\n");\r\nfprintf(ofp, "\tcommon_secs, ");\r\nfprintf(ofp, "common_nsecs, ");\r\nfprintf(ofp, "common_pid, ");\r\nfprintf(ofp, "common_comm,\n\t");\r\nnot_first = 0;\r\ncount = 0;\r\nfor (f = event->format.fields; f; f = f->next) {\r\nif (not_first++)\r\nfprintf(ofp, ", ");\r\nif (++count % 5 == 0)\r\nfprintf(ofp, "\n\t");\r\nfprintf(ofp, "%s", f->name);\r\n}\r\nfprintf(ofp, "):\n");\r\nfprintf(ofp, "\t\tprint_header(event_name, common_cpu, "\r\n"common_secs, common_nsecs,\n\t\t\t"\r\n"common_pid, common_comm)\n\n");\r\nfprintf(ofp, "\t\tprint \"");\r\nnot_first = 0;\r\ncount = 0;\r\nfor (f = event->format.fields; f; f = f->next) {\r\nif (not_first++)\r\nfprintf(ofp, ", ");\r\nif (count && count % 3 == 0) {\r\nfprintf(ofp, "\" \\\n\t\t\"");\r\n}\r\ncount++;\r\nfprintf(ofp, "%s=", f->name);\r\nif (f->flags & FIELD_IS_STRING ||\r\nf->flags & FIELD_IS_FLAG ||\r\nf->flags & FIELD_IS_SYMBOLIC)\r\nfprintf(ofp, "%%s");\r\nelse if (f->flags & FIELD_IS_SIGNED)\r\nfprintf(ofp, "%%d");\r\nelse\r\nfprintf(ofp, "%%u");\r\n}\r\nfprintf(ofp, "\\n\" %% \\\n\t\t(");\r\nnot_first = 0;\r\ncount = 0;\r\nfor (f = event->format.fields; f; f = f->next) {\r\nif (not_first++)\r\nfprintf(ofp, ", ");\r\nif (++count % 5 == 0)\r\nfprintf(ofp, "\n\t\t");\r\nif (f->flags & FIELD_IS_FLAG) {\r\nif ((count - 1) % 5 != 0) {\r\nfprintf(ofp, "\n\t\t");\r\ncount = 4;\r\n}\r\nfprintf(ofp, "flag_str(\"");\r\nfprintf(ofp, "%s__%s\", ", event->system,\r\nevent->name);\r\nfprintf(ofp, "\"%s\", %s)", f->name,\r\nf->name);\r\n} else if (f->flags & FIELD_IS_SYMBOLIC) {\r\nif ((count - 1) % 5 != 0) {\r\nfprintf(ofp, "\n\t\t");\r\ncount = 4;\r\n}\r\nfprintf(ofp, "symbol_str(\"");\r\nfprintf(ofp, "%s__%s\", ", event->system,\r\nevent->name);\r\nfprintf(ofp, "\"%s\", %s)", f->name,\r\nf->name);\r\n} else\r\nfprintf(ofp, "%s", f->name);\r\n}\r\nfprintf(ofp, "),\n\n");\r\n}\r\nfprintf(ofp, "def trace_unhandled(event_name, context, "\r\n"event_fields_dict):\n");\r\nfprintf(ofp, "\t\tprint ' '.join(['%%s=%%s'%%(k,str(v))"\r\n"for k,v in sorted(event_fields_dict.items())])\n\n");\r\nfprintf(ofp, "def print_header("\r\n"event_name, cpu, secs, nsecs, pid, comm):\n"\r\n"\tprint \"%%-20s %%5u %%05u.%%09u %%8u %%-20s \" %% \\\n\t"\r\n"(event_name, cpu, secs, nsecs, pid, comm),\n");\r\nfclose(ofp);\r\nfprintf(stderr, "generated Python script: %s\n", fname);\r\nreturn 0;\r\n}
