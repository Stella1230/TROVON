static void sgiioc4_init_hwif_ports(struct ide_hw *hw,\r\nunsigned long data_port,\r\nunsigned long ctrl_port,\r\nunsigned long irq_port)\r\n{\r\nunsigned long reg = data_port;\r\nint i;\r\nfor (i = 0; i <= 7; i++)\r\nhw->io_ports_array[i] = reg + i * 4;\r\nhw->io_ports.ctl_addr = ctrl_port;\r\nhw->io_ports.irq_addr = irq_port;\r\n}\r\nstatic int sgiioc4_checkirq(ide_hwif_t *hwif)\r\n{\r\nunsigned long intr_addr = hwif->io_ports.irq_addr + IOC4_INTR_REG * 4;\r\nif (readl((void __iomem *)intr_addr) & 0x03)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sgiioc4_clearirq(ide_drive_t *drive)\r\n{\r\nu32 intr_reg;\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_io_ports *io_ports = &hwif->io_ports;\r\nunsigned long other_ir = io_ports->irq_addr + (IOC4_INTR_REG << 2);\r\nintr_reg = readl((void __iomem *)other_ir);\r\nif (intr_reg & 0x03) {\r\nu8 stat = sgiioc4_read_status(hwif);\r\nint count = 0;\r\nstat = sgiioc4_read_status(hwif);\r\nwhile ((stat & ATA_BUSY) && (count++ < 100)) {\r\nudelay(1);\r\nstat = sgiioc4_read_status(hwif);\r\n}\r\nif (intr_reg & 0x02) {\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu32 pci_err_addr_low, pci_err_addr_high,\r\npci_stat_cmd_reg;\r\npci_err_addr_low =\r\nreadl((void __iomem *)io_ports->irq_addr);\r\npci_err_addr_high =\r\nreadl((void __iomem *)(io_ports->irq_addr + 4));\r\npci_read_config_dword(dev, PCI_COMMAND,\r\n&pci_stat_cmd_reg);\r\nprintk(KERN_ERR "%s(%s): PCI Bus Error when doing DMA: "\r\n"status-cmd reg is 0x%x\n",\r\n__func__, drive->name, pci_stat_cmd_reg);\r\nprintk(KERN_ERR "%s(%s): PCI Error Address is 0x%x%x\n",\r\n__func__, drive->name,\r\npci_err_addr_high, pci_err_addr_low);\r\npci_write_config_dword(dev, PCI_COMMAND, 0x00000146);\r\n}\r\nwritel(0x03, (void __iomem *)other_ir);\r\nintr_reg = readl((void __iomem *)other_ir);\r\n}\r\nreturn intr_reg & 3;\r\n}\r\nstatic void sgiioc4_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long ioc4_dma_addr = hwif->dma_base + IOC4_DMA_CTRL * 4;\r\nunsigned int reg = readl((void __iomem *)ioc4_dma_addr);\r\nunsigned int temp_reg = reg | IOC4_S_DMA_START;\r\nwritel(temp_reg, (void __iomem *)ioc4_dma_addr);\r\n}\r\nstatic u32 sgiioc4_ide_dma_stop(ide_hwif_t *hwif, u64 dma_base)\r\n{\r\nunsigned long ioc4_dma_addr = dma_base + IOC4_DMA_CTRL * 4;\r\nu32 ioc4_dma;\r\nint count;\r\ncount = 0;\r\nioc4_dma = readl((void __iomem *)ioc4_dma_addr);\r\nwhile ((ioc4_dma & IOC4_S_DMA_STOP) && (count++ < 200)) {\r\nudelay(1);\r\nioc4_dma = readl((void __iomem *)ioc4_dma_addr);\r\n}\r\nreturn ioc4_dma;\r\n}\r\nstatic int sgiioc4_dma_end(ide_drive_t *drive)\r\n{\r\nu32 ioc4_dma, bc_dev, bc_mem, num, valid = 0, cnt = 0;\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long dma_base = hwif->dma_base;\r\nint dma_stat = 0;\r\nunsigned long *ending_dma = ide_get_hwifdata(hwif);\r\nwritel(IOC4_S_DMA_STOP, (void __iomem *)(dma_base + IOC4_DMA_CTRL * 4));\r\nioc4_dma = sgiioc4_ide_dma_stop(hwif, dma_base);\r\nif (ioc4_dma & IOC4_S_DMA_STOP) {\r\nprintk(KERN_ERR\r\n"%s(%s): IOC4 DMA STOP bit is still 1 :"\r\n"ioc4_dma_reg 0x%x\n",\r\n__func__, drive->name, ioc4_dma);\r\ndma_stat = 1;\r\n}\r\nwhile ((cnt++ < 200) && (!valid)) {\r\nfor (num = 0; num < 16; num++) {\r\nif (ending_dma[num]) {\r\nvalid = 1;\r\nbreak;\r\n}\r\n}\r\nudelay(1);\r\n}\r\nif (!valid) {\r\nprintk(KERN_ERR "%s(%s) : DMA incomplete\n", __func__,\r\ndrive->name);\r\ndma_stat = 1;\r\n}\r\nbc_dev = readl((void __iomem *)(dma_base + IOC4_BC_DEV * 4));\r\nbc_mem = readl((void __iomem *)(dma_base + IOC4_BC_MEM * 4));\r\nif ((bc_dev & 0x01FF) || (bc_mem & 0x1FF)) {\r\nif (bc_dev > bc_mem + 8) {\r\nprintk(KERN_ERR\r\n"%s(%s): WARNING!! byte_count_dev %d "\r\n"!= byte_count_mem %d\n",\r\n__func__, drive->name, bc_dev, bc_mem);\r\n}\r\n}\r\nreturn dma_stat;\r\n}\r\nstatic void sgiioc4_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\n}\r\nstatic int sgiioc4_dma_test_irq(ide_drive_t *drive)\r\n{\r\nreturn sgiioc4_checkirq(drive->hwif);\r\n}\r\nstatic void sgiioc4_dma_host_set(ide_drive_t *drive, int on)\r\n{\r\nif (!on)\r\nsgiioc4_clearirq(drive);\r\n}\r\nstatic void sgiioc4_resetproc(ide_drive_t *drive)\r\n{\r\nstruct ide_cmd *cmd = &drive->hwif->cmd;\r\nsgiioc4_dma_end(drive);\r\nide_dma_unmap_sg(drive, cmd);\r\nsgiioc4_clearirq(drive);\r\n}\r\nstatic void sgiioc4_dma_lost_irq(ide_drive_t *drive)\r\n{\r\nsgiioc4_resetproc(drive);\r\nide_dma_lost_irq(drive);\r\n}\r\nstatic u8 sgiioc4_read_status(ide_hwif_t *hwif)\r\n{\r\nunsigned long port = hwif->io_ports.status_addr;\r\nu8 reg = (u8) readb((void __iomem *) port);\r\nif (!(reg & ATA_BUSY)) {\r\nunsigned long other_ir = port - 0x110;\r\nunsigned int intr_reg = (u32) readl((void __iomem *) other_ir);\r\nif (intr_reg & 0x03) {\r\nwritel(0x03, (void __iomem *) other_ir);\r\nintr_reg = (u32) readl((void __iomem *) other_ir);\r\n}\r\n}\r\nreturn reg;\r\n}\r\nstatic int ide_dma_sgiioc4(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long dma_base = pci_resource_start(dev, 0) + IOC4_DMA_OFFSET;\r\nint num_ports = sizeof(struct ioc4_dma_regs);\r\nvoid *pad;\r\nprintk(KERN_INFO " %s: MMIO-DMA\n", hwif->name);\r\nif (request_mem_region(dma_base, num_ports, hwif->name) == NULL) {\r\nprintk(KERN_ERR "%s(%s) -- ERROR: addresses 0x%08lx to 0x%08lx "\r\n"already in use\n", __func__, hwif->name,\r\ndma_base, dma_base + num_ports - 1);\r\nreturn -1;\r\n}\r\nhwif->dma_base = (unsigned long)hwif->io_ports.irq_addr +\r\nIOC4_DMA_OFFSET;\r\nhwif->sg_max_nents = IOC4_PRD_ENTRIES;\r\nhwif->prd_max_nents = IOC4_PRD_ENTRIES;\r\nhwif->prd_ent_size = IOC4_PRD_BYTES;\r\nif (ide_allocate_dma_engine(hwif))\r\ngoto dma_pci_alloc_failure;\r\npad = pci_alloc_consistent(dev, IOC4_IDE_CACHELINE_SIZE,\r\n(dma_addr_t *)&hwif->extra_base);\r\nif (pad) {\r\nide_set_hwifdata(hwif, pad);\r\nreturn 0;\r\n}\r\nide_release_dma_engine(hwif);\r\nprintk(KERN_ERR "%s(%s) -- ERROR: Unable to allocate DMA maps\n",\r\n__func__, hwif->name);\r\nprintk(KERN_INFO "%s: changing from DMA to PIO mode", hwif->name);\r\ndma_pci_alloc_failure:\r\nrelease_mem_region(dma_base, num_ports);\r\nreturn -1;\r\n}\r\nstatic void sgiioc4_configure_for_dma(int dma_direction, ide_drive_t *drive)\r\n{\r\nu32 ioc4_dma;\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long dma_base = hwif->dma_base;\r\nunsigned long ioc4_dma_addr = dma_base + IOC4_DMA_CTRL * 4;\r\nu32 dma_addr, ending_dma_addr;\r\nioc4_dma = readl((void __iomem *)ioc4_dma_addr);\r\nif (ioc4_dma & IOC4_S_DMA_ACTIVE) {\r\nprintk(KERN_WARNING "%s(%s): Warning!! DMA from previous "\r\n"transfer was still active\n", __func__, drive->name);\r\nwritel(IOC4_S_DMA_STOP, (void __iomem *)ioc4_dma_addr);\r\nioc4_dma = sgiioc4_ide_dma_stop(hwif, dma_base);\r\nif (ioc4_dma & IOC4_S_DMA_STOP)\r\nprintk(KERN_ERR "%s(%s): IOC4 DMA STOP bit is "\r\n"still 1\n", __func__, drive->name);\r\n}\r\nioc4_dma = readl((void __iomem *)ioc4_dma_addr);\r\nif (ioc4_dma & IOC4_S_DMA_ERROR) {\r\nprintk(KERN_WARNING "%s(%s): Warning!! DMA Error during "\r\n"previous transfer, status 0x%x\n",\r\n__func__, drive->name, ioc4_dma);\r\nwritel(IOC4_S_DMA_STOP, (void __iomem *)ioc4_dma_addr);\r\nioc4_dma = sgiioc4_ide_dma_stop(hwif, dma_base);\r\nif (ioc4_dma & IOC4_S_DMA_STOP)\r\nprintk(KERN_ERR "%s(%s): IOC4 DMA STOP bit is "\r\n"still 1\n", __func__, drive->name);\r\n}\r\ndma_addr = cpu_to_le32(hwif->dmatable_dma);\r\nwritel(dma_addr, (void __iomem *)(dma_base + IOC4_DMA_PTR_L * 4));\r\nmemset(ide_get_hwifdata(hwif), 0, IOC4_IDE_CACHELINE_SIZE);\r\nending_dma_addr = cpu_to_le32(hwif->extra_base);\r\nwritel(ending_dma_addr, (void __iomem *)(dma_base +\r\nIOC4_DMA_END_ADDR * 4));\r\nwritel(dma_direction, (void __iomem *)ioc4_dma_addr);\r\n}\r\nstatic int sgiioc4_build_dmatable(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned int *table = hwif->dmatable_cpu;\r\nunsigned int count = 0, i = cmd->sg_nents;\r\nstruct scatterlist *sg = hwif->sg_table;\r\nwhile (i && sg_dma_len(sg)) {\r\ndma_addr_t cur_addr;\r\nint cur_len;\r\ncur_addr = sg_dma_address(sg);\r\ncur_len = sg_dma_len(sg);\r\nwhile (cur_len) {\r\nif (count++ >= IOC4_PRD_ENTRIES) {\r\nprintk(KERN_WARNING\r\n"%s: DMA table too small\n",\r\ndrive->name);\r\nreturn 0;\r\n} else {\r\nu32 bcount =\r\n0x10000 - (cur_addr & 0xffff);\r\nif (bcount > cur_len)\r\nbcount = cur_len;\r\n*table = 0x0;\r\ntable++;\r\n*table = cpu_to_be32(cur_addr);\r\ntable++;\r\n*table = 0x0;\r\ntable++;\r\n*table = cpu_to_be32(bcount);\r\ntable++;\r\ncur_addr += bcount;\r\ncur_len -= bcount;\r\n}\r\n}\r\nsg = sg_next(sg);\r\ni--;\r\n}\r\nif (count) {\r\ntable--;\r\n*table |= cpu_to_be32(0x80000000);\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgiioc4_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nint ddir;\r\nu8 write = !!(cmd->tf_flags & IDE_TFLAG_WRITE);\r\nif (sgiioc4_build_dmatable(drive, cmd) == 0)\r\nreturn 1;\r\nif (write)\r\nddir = IOC4_DMA_READ;\r\nelse\r\nddir = IOC4_DMA_WRITE;\r\nsgiioc4_configure_for_dma(ddir, drive);\r\nreturn 0;\r\n}\r\nstatic int sgiioc4_ide_setup_pci_device(struct pci_dev *dev)\r\n{\r\nunsigned long cmd_base, irqport;\r\nunsigned long bar0, cmd_phys_base, ctl;\r\nvoid __iomem *virt_base;\r\nstruct ide_hw hw, *hws[] = { &hw };\r\nint rc;\r\nbar0 = pci_resource_start(dev, 0);\r\nvirt_base = pci_ioremap_bar(dev, 0);\r\nif (virt_base == NULL) {\r\nprintk(KERN_ERR "%s: Unable to remap BAR 0 address: 0x%lx\n",\r\nDRV_NAME, bar0);\r\nreturn -ENOMEM;\r\n}\r\ncmd_base = (unsigned long)virt_base + IOC4_CMD_OFFSET;\r\nctl = (unsigned long)virt_base + IOC4_CTRL_OFFSET;\r\nirqport = (unsigned long)virt_base + IOC4_INTR_OFFSET;\r\ncmd_phys_base = bar0 + IOC4_CMD_OFFSET;\r\nif (request_mem_region(cmd_phys_base, IOC4_CMD_CTL_BLK_SIZE,\r\nDRV_NAME) == NULL) {\r\nprintk(KERN_ERR "%s %s -- ERROR: addresses 0x%08lx to 0x%08lx "\r\n"already in use\n", DRV_NAME, pci_name(dev),\r\ncmd_phys_base, cmd_phys_base + IOC4_CMD_CTL_BLK_SIZE);\r\nrc = -EBUSY;\r\ngoto req_mem_rgn_err;\r\n}\r\nmemset(&hw, 0, sizeof(hw));\r\nsgiioc4_init_hwif_ports(&hw, cmd_base, ctl, irqport);\r\nhw.irq = dev->irq;\r\nhw.dev = &dev->dev;\r\nwritel(0x03, (void __iomem *)(irqport + IOC4_INTR_SET * 4));\r\nrc = ide_host_add(&sgiioc4_port_info, hws, 1, NULL);\r\nif (!rc)\r\nreturn 0;\r\nrelease_mem_region(cmd_phys_base, IOC4_CMD_CTL_BLK_SIZE);\r\nreq_mem_rgn_err:\r\niounmap(virt_base);\r\nreturn rc;\r\n}\r\nstatic unsigned int pci_init_sgiioc4(struct pci_dev *dev)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "%s: IDE controller at PCI slot %s, revision %d\n",\r\nDRV_NAME, pci_name(dev), dev->revision);\r\nif (dev->revision < IOC4_SUPPORTED_FIRMWARE_REV) {\r\nprintk(KERN_ERR "Skipping %s IDE controller in slot %s: "\r\n"firmware is obsolete - please upgrade to "\r\n"revision46 or higher\n",\r\nDRV_NAME, pci_name(dev));\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nret = sgiioc4_ide_setup_pci_device(dev);\r\nout:\r\nreturn ret;\r\n}\r\nint ioc4_ide_attach_one(struct ioc4_driver_data *idd)\r\n{\r\nif (idd->idd_variant == IOC4_VARIANT_PCI_RT)\r\nreturn 0;\r\nreturn pci_init_sgiioc4(idd->idd_pdev);\r\n}\r\nstatic int __init ioc4_ide_init(void)\r\n{\r\nreturn ioc4_register_submodule(&ioc4_ide_submodule);\r\n}
