static int is_pci_dev(struct device *dev)\r\n{\r\nreturn (dev->bus == &pci_bus_type);\r\n}\r\nstatic void ata_acpi_clear_gtf(struct ata_device *dev)\r\n{\r\nkfree(dev->gtf_cache);\r\ndev->gtf_cache = NULL;\r\n}\r\nacpi_handle ata_ap_acpi_handle(struct ata_port *ap)\r\n{\r\nif (ap->flags & ATA_FLAG_ACPI_SATA)\r\nreturn NULL;\r\nreturn ap->scsi_host ?\r\nDEVICE_ACPI_HANDLE(&ap->scsi_host->shost_gendev) : NULL;\r\n}\r\nacpi_handle ata_dev_acpi_handle(struct ata_device *dev)\r\n{\r\nacpi_integer adr;\r\nstruct ata_port *ap = dev->link->ap;\r\nif (libata_noacpi || dev->flags & ATA_DFLAG_ACPI_DISABLED)\r\nreturn NULL;\r\nif (ap->flags & ATA_FLAG_ACPI_SATA) {\r\nif (!sata_pmp_attached(ap))\r\nadr = SATA_ADR(ap->port_no, NO_PORT_MULT);\r\nelse\r\nadr = SATA_ADR(ap->port_no, dev->link->pmp);\r\nreturn acpi_get_child(DEVICE_ACPI_HANDLE(ap->host->dev), adr);\r\n} else\r\nreturn acpi_get_child(ata_ap_acpi_handle(ap), dev->devno);\r\n}\r\nstatic void ata_acpi_detach_device(struct ata_port *ap, struct ata_device *dev)\r\n{\r\nif (dev)\r\ndev->flags |= ATA_DFLAG_DETACH;\r\nelse {\r\nstruct ata_link *tlink;\r\nstruct ata_device *tdev;\r\nata_for_each_link(tlink, ap, EDGE)\r\nata_for_each_dev(tdev, tlink, ALL)\r\ntdev->flags |= ATA_DFLAG_DETACH;\r\n}\r\nata_port_schedule_eh(ap);\r\n}\r\nstatic void ata_acpi_handle_hotplug(struct ata_port *ap, struct ata_device *dev,\r\nu32 event)\r\n{\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nint wait = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nata_ehi_push_desc(ehi, "ACPI event");\r\nata_ehi_hotplugged(ehi);\r\nata_port_freeze(ap);\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nata_ehi_push_desc(ehi, "ACPI event");\r\nata_acpi_detach_device(ap, dev);\r\nwait = 1;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (wait) {\r\nata_port_wait_eh(ap);\r\nflush_work(&ap->hotplug_task.work);\r\n}\r\n}\r\nstatic void ata_acpi_dev_notify_dock(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct ata_device *dev = data;\r\nata_acpi_handle_hotplug(dev->link->ap, dev, event);\r\n}\r\nstatic void ata_acpi_ap_notify_dock(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct ata_port *ap = data;\r\nata_acpi_handle_hotplug(ap, NULL, event);\r\n}\r\nstatic void ata_acpi_uevent(struct ata_port *ap, struct ata_device *dev,\r\nu32 event)\r\n{\r\nstruct kobject *kobj = NULL;\r\nchar event_string[20];\r\nchar *envp[] = { event_string, NULL };\r\nif (dev) {\r\nif (dev->sdev)\r\nkobj = &dev->sdev->sdev_gendev.kobj;\r\n} else\r\nkobj = &ap->dev->kobj;\r\nif (kobj) {\r\nsnprintf(event_string, 20, "BAY_EVENT=%d", event);\r\nkobject_uevent_env(kobj, KOBJ_CHANGE, envp);\r\n}\r\n}\r\nstatic void ata_acpi_ap_uevent(acpi_handle handle, u32 event, void *data)\r\n{\r\nata_acpi_uevent(data, NULL, event);\r\n}\r\nstatic void ata_acpi_dev_uevent(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct ata_device *dev = data;\r\nata_acpi_uevent(dev->link->ap, dev, event);\r\n}\r\nvoid ata_acpi_hotplug_init(struct ata_host *host)\r\n{\r\nint i;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nacpi_handle handle;\r\nstruct ata_device *dev;\r\nif (!ap)\r\ncontinue;\r\nhandle = ata_ap_acpi_handle(ap);\r\nif (handle) {\r\nregister_hotplug_dock_device(handle,\r\n&ata_acpi_ap_dock_ops, ap,\r\nNULL, NULL);\r\n}\r\nata_for_each_dev(dev, &ap->link, ALL) {\r\nhandle = ata_dev_acpi_handle(dev);\r\nif (!handle)\r\ncontinue;\r\nregister_hotplug_dock_device(handle,\r\n&ata_acpi_dev_dock_ops,\r\ndev, NULL, NULL);\r\n}\r\n}\r\n}\r\nvoid ata_acpi_dissociate(struct ata_host *host)\r\n{\r\nint i;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\r\nif (ata_ap_acpi_handle(ap) && gtm)\r\nata_acpi_stm(ap, gtm);\r\n}\r\n}\r\nstatic int __ata_acpi_gtm(struct ata_port *ap, acpi_handle handle,\r\nstruct ata_acpi_gtm *gtm)\r\n{\r\nstruct acpi_buffer output = { .length = ACPI_ALLOCATE_BUFFER };\r\nunion acpi_object *out_obj;\r\nacpi_status status;\r\nint rc = 0;\r\nstatus = acpi_evaluate_object(handle, "_GTM", NULL, &output);\r\nrc = -ENOENT;\r\nif (status == AE_NOT_FOUND)\r\ngoto out_free;\r\nrc = -EINVAL;\r\nif (ACPI_FAILURE(status)) {\r\nata_port_err(ap, "ACPI get timing mode failed (AE 0x%x)\n",\r\nstatus);\r\ngoto out_free;\r\n}\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nata_port_warn(ap, "_GTM returned unexpected object type 0x%x\n",\r\nout_obj->type);\r\ngoto out_free;\r\n}\r\nif (out_obj->buffer.length != sizeof(struct ata_acpi_gtm)) {\r\nata_port_err(ap, "_GTM returned invalid length %d\n",\r\nout_obj->buffer.length);\r\ngoto out_free;\r\n}\r\nmemcpy(gtm, out_obj->buffer.pointer, sizeof(struct ata_acpi_gtm));\r\nrc = 0;\r\nout_free:\r\nkfree(output.pointer);\r\nreturn rc;\r\n}\r\nint ata_acpi_gtm(struct ata_port *ap, struct ata_acpi_gtm *gtm)\r\n{\r\nif (ata_ap_acpi_handle(ap))\r\nreturn __ata_acpi_gtm(ap, ata_ap_acpi_handle(ap), gtm);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nint ata_acpi_stm(struct ata_port *ap, const struct ata_acpi_gtm *stm)\r\n{\r\nacpi_status status;\r\nstruct ata_acpi_gtm stm_buf = *stm;\r\nstruct acpi_object_list input;\r\nunion acpi_object in_params[3];\r\nin_params[0].type = ACPI_TYPE_BUFFER;\r\nin_params[0].buffer.length = sizeof(struct ata_acpi_gtm);\r\nin_params[0].buffer.pointer = (u8 *)&stm_buf;\r\nin_params[1].type = ACPI_TYPE_BUFFER;\r\nin_params[1].buffer.length = 512;\r\nin_params[1].buffer.pointer = (u8 *)ap->link.device[0].id;\r\nin_params[2].type = ACPI_TYPE_BUFFER;\r\nin_params[2].buffer.length = 512;\r\nin_params[2].buffer.pointer = (u8 *)ap->link.device[1].id;\r\ninput.count = 3;\r\ninput.pointer = in_params;\r\nstatus = acpi_evaluate_object(ata_ap_acpi_handle(ap), "_STM", &input,\r\nNULL);\r\nif (status == AE_NOT_FOUND)\r\nreturn -ENOENT;\r\nif (ACPI_FAILURE(status)) {\r\nata_port_err(ap, "ACPI set timing mode failed (status=0x%x)\n",\r\nstatus);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ata_dev_get_GTF(struct ata_device *dev, struct ata_acpi_gtf **gtf)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nacpi_status status;\r\nstruct acpi_buffer output;\r\nunion acpi_object *out_obj;\r\nint rc = 0;\r\nif (dev->gtf_cache) {\r\nout_obj = dev->gtf_cache;\r\ngoto done;\r\n}\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: ENTER: port#: %d\n",\r\n__func__, ap->port_no);\r\nstatus = acpi_evaluate_object(ata_dev_acpi_handle(dev), "_GTF", NULL,\r\n&output);\r\nout_obj = dev->gtf_cache = output.pointer;\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND) {\r\nata_dev_warn(dev, "_GTF evaluation failed (AE 0x%x)\n",\r\nstatus);\r\nrc = -EINVAL;\r\n}\r\ngoto out_free;\r\n}\r\nif (!output.length || !output.pointer) {\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: Run _GTF: length or ptr is NULL (0x%llx, 0x%p)\n",\r\n__func__,\r\n(unsigned long long)output.length,\r\noutput.pointer);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nata_dev_warn(dev, "_GTF unexpected object type 0x%x\n",\r\nout_obj->type);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (out_obj->buffer.length % REGS_PER_GTF) {\r\nata_dev_warn(dev, "unexpected _GTF length (%d)\n",\r\nout_obj->buffer.length);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\ndone:\r\nrc = out_obj->buffer.length / REGS_PER_GTF;\r\nif (gtf) {\r\n*gtf = (void *)out_obj->buffer.pointer;\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: returning gtf=%p, gtf_count=%d\n",\r\n__func__, *gtf, rc);\r\n}\r\nreturn rc;\r\nout_free:\r\nata_acpi_clear_gtf(dev);\r\nreturn rc;\r\n}\r\nunsigned long ata_acpi_gtm_xfermask(struct ata_device *dev,\r\nconst struct ata_acpi_gtm *gtm)\r\n{\r\nunsigned long xfer_mask = 0;\r\nunsigned int type;\r\nint unit;\r\nu8 mode;\r\nunit = dev->devno;\r\nif (!(gtm->flags & 0x10))\r\nunit = 0;\r\nmode = ata_timing_cycle2mode(ATA_SHIFT_PIO, gtm->drive[unit].pio);\r\nxfer_mask |= ata_xfer_mode2mask(mode);\r\nif (!(gtm->flags & (1 << (2 * unit))))\r\ntype = ATA_SHIFT_MWDMA;\r\nelse\r\ntype = ATA_SHIFT_UDMA;\r\nmode = ata_timing_cycle2mode(type, gtm->drive[unit].dma);\r\nxfer_mask |= ata_xfer_mode2mask(mode);\r\nreturn xfer_mask;\r\n}\r\nint ata_acpi_cbl_80wire(struct ata_port *ap, const struct ata_acpi_gtm *gtm)\r\n{\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nunsigned long xfer_mask, udma_mask;\r\nxfer_mask = ata_acpi_gtm_xfermask(dev, gtm);\r\nata_unpack_xfermask(xfer_mask, NULL, NULL, &udma_mask);\r\nif (udma_mask & ~ATA_UDMA_MASK_40C)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ata_acpi_gtf_to_tf(struct ata_device *dev,\r\nconst struct ata_acpi_gtf *gtf,\r\nstruct ata_taskfile *tf)\r\n{\r\nata_tf_init(dev, tf);\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf->protocol = ATA_PROT_NODATA;\r\ntf->feature = gtf->tf[0];\r\ntf->nsect = gtf->tf[1];\r\ntf->lbal = gtf->tf[2];\r\ntf->lbam = gtf->tf[3];\r\ntf->lbah = gtf->tf[4];\r\ntf->device = gtf->tf[5];\r\ntf->command = gtf->tf[6];\r\n}\r\nstatic int ata_acpi_filter_tf(struct ata_device *dev,\r\nconst struct ata_taskfile *tf,\r\nconst struct ata_taskfile *ptf)\r\n{\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_SETXFER) {\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_XFER)\r\nreturn 1;\r\n}\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_LOCK) {\r\nif (tf->command == ATA_CMD_CONF_OVERLAY &&\r\ntf->feature == ATA_DCO_FREEZE_LOCK)\r\nreturn 1;\r\nif (tf->command == ATA_CMD_SEC_FREEZE_LOCK)\r\nreturn 1;\r\nif ((!ptf || ptf->command != ATA_CMD_READ_NATIVE_MAX) &&\r\ntf->command == ATA_CMD_SET_MAX &&\r\n(tf->feature == ATA_SET_MAX_LOCK ||\r\ntf->feature == ATA_SET_MAX_FREEZE_LOCK))\r\nreturn 1;\r\n}\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_SATA_ENABLE) {\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_DIPM &&\r\ntf->nsect == SATA_DIPM)\r\nreturn 1;\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_FPDMA_OFFSET &&\r\n(tf->nsect == SATA_FPDMA_OFFSET ||\r\ntf->nsect == SATA_FPDMA_IN_ORDER))\r\nreturn 1;\r\nif (dev->gtf_filter & ATA_ACPI_FILTER_FPDMA_AA &&\r\ntf->nsect == SATA_FPDMA_AA)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ata_acpi_run_tf(struct ata_device *dev,\r\nconst struct ata_acpi_gtf *gtf,\r\nconst struct ata_acpi_gtf *prev_gtf)\r\n{\r\nstruct ata_taskfile *pptf = NULL;\r\nstruct ata_taskfile tf, ptf, rtf;\r\nunsigned int err_mask;\r\nconst char *level;\r\nconst char *descr;\r\nchar msg[60];\r\nint rc;\r\nif ((gtf->tf[0] == 0) && (gtf->tf[1] == 0) && (gtf->tf[2] == 0)\r\n&& (gtf->tf[3] == 0) && (gtf->tf[4] == 0) && (gtf->tf[5] == 0)\r\n&& (gtf->tf[6] == 0))\r\nreturn 0;\r\nata_acpi_gtf_to_tf(dev, gtf, &tf);\r\nif (prev_gtf) {\r\nata_acpi_gtf_to_tf(dev, prev_gtf, &ptf);\r\npptf = &ptf;\r\n}\r\nif (!ata_acpi_filter_tf(dev, &tf, pptf)) {\r\nrtf = tf;\r\nerr_mask = ata_exec_internal(dev, &rtf, NULL,\r\nDMA_NONE, NULL, 0, 0);\r\nswitch (err_mask) {\r\ncase 0:\r\nlevel = KERN_DEBUG;\r\nsnprintf(msg, sizeof(msg), "succeeded");\r\nrc = 1;\r\nbreak;\r\ncase AC_ERR_DEV:\r\nlevel = KERN_INFO;\r\nsnprintf(msg, sizeof(msg),\r\n"rejected by device (Stat=0x%02x Err=0x%02x)",\r\nrtf.command, rtf.feature);\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nlevel = KERN_ERR;\r\nsnprintf(msg, sizeof(msg),\r\n"failed (Emask=0x%x Stat=0x%02x Err=0x%02x)",\r\nerr_mask, rtf.command, rtf.feature);\r\nrc = -EIO;\r\nbreak;\r\n}\r\n} else {\r\nlevel = KERN_INFO;\r\nsnprintf(msg, sizeof(msg), "filtered out");\r\nrc = 0;\r\n}\r\ndescr = ata_get_cmd_descript(tf.command);\r\nata_dev_printk(dev, level,\r\n"ACPI cmd %02x/%02x:%02x:%02x:%02x:%02x:%02x (%s) %s\n",\r\ntf.command, tf.feature, tf.nsect, tf.lbal,\r\ntf.lbam, tf.lbah, tf.device,\r\n(descr ? descr : "unknown"), msg);\r\nreturn rc;\r\n}\r\nstatic int ata_acpi_exec_tfs(struct ata_device *dev, int *nr_executed)\r\n{\r\nstruct ata_acpi_gtf *gtf = NULL, *pgtf = NULL;\r\nint gtf_count, i, rc;\r\nrc = ata_dev_get_GTF(dev, &gtf);\r\nif (rc < 0)\r\nreturn rc;\r\ngtf_count = rc;\r\nfor (i = 0; i < gtf_count; i++, gtf++) {\r\nrc = ata_acpi_run_tf(dev, gtf, pgtf);\r\nif (rc < 0)\r\nbreak;\r\nif (rc) {\r\n(*nr_executed)++;\r\npgtf = gtf;\r\n}\r\n}\r\nata_acpi_clear_gtf(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int ata_acpi_push_id(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nunion acpi_object in_params[1];\r\nif (ata_msg_probe(ap))\r\nata_dev_dbg(dev, "%s: ix = %d, port#: %d\n",\r\n__func__, dev->devno, ap->port_no);\r\ninput.count = 1;\r\ninput.pointer = in_params;\r\nin_params[0].type = ACPI_TYPE_BUFFER;\r\nin_params[0].buffer.length = sizeof(dev->id[0]) * ATA_ID_WORDS;\r\nin_params[0].buffer.pointer = (u8 *)dev->id;\r\nswap_buf_le16(dev->id, ATA_ID_WORDS);\r\nstatus = acpi_evaluate_object(ata_dev_acpi_handle(dev), "_SDD", &input,\r\nNULL);\r\nswap_buf_le16(dev->id, ATA_ID_WORDS);\r\nif (status == AE_NOT_FOUND)\r\nreturn -ENOENT;\r\nif (ACPI_FAILURE(status)) {\r\nata_dev_warn(dev, "ACPI _SDD failed (AE 0x%x)\n", status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint ata_acpi_on_suspend(struct ata_port *ap)\r\n{\r\nreturn 0;\r\n}\r\nvoid ata_acpi_on_resume(struct ata_port *ap)\r\n{\r\nconst struct ata_acpi_gtm *gtm = ata_acpi_init_gtm(ap);\r\nstruct ata_device *dev;\r\nif (ata_ap_acpi_handle(ap) && gtm) {\r\nata_acpi_stm(ap, gtm);\r\nata_for_each_dev(dev, &ap->link, ALL) {\r\nata_acpi_clear_gtf(dev);\r\nif (ata_dev_enabled(dev) &&\r\nata_dev_get_GTF(dev, NULL) >= 0)\r\ndev->flags |= ATA_DFLAG_ACPI_PENDING;\r\n}\r\n} else {\r\nata_for_each_dev(dev, &ap->link, ALL) {\r\nata_acpi_clear_gtf(dev);\r\nif (ata_dev_enabled(dev))\r\ndev->flags |= ATA_DFLAG_ACPI_PENDING;\r\n}\r\n}\r\n}\r\nstatic int ata_acpi_choose_suspend_state(struct ata_device *dev, bool runtime)\r\n{\r\nint d_max_in = ACPI_STATE_D3_COLD;\r\nif (!runtime)\r\ngoto out;\r\nif (dev->class == ATA_DEV_ATAPI &&\r\n!(zpodd_dev_enabled(dev) && zpodd_zpready(dev)))\r\nd_max_in = ACPI_STATE_D3_HOT;\r\nout:\r\nreturn acpi_pm_device_sleep_state(&dev->sdev->sdev_gendev,\r\nNULL, d_max_in);\r\n}\r\nstatic void sata_acpi_set_state(struct ata_port *ap, pm_message_t state)\r\n{\r\nbool runtime = PMSG_IS_AUTO(state);\r\nstruct ata_device *dev;\r\nacpi_handle handle;\r\nint acpi_state;\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nhandle = ata_dev_acpi_handle(dev);\r\nif (!handle)\r\ncontinue;\r\nif (!(state.event & PM_EVENT_RESUME)) {\r\nacpi_state = ata_acpi_choose_suspend_state(dev, runtime);\r\nif (acpi_state == ACPI_STATE_D0)\r\ncontinue;\r\nif (runtime && zpodd_dev_enabled(dev) &&\r\nacpi_state == ACPI_STATE_D3_COLD)\r\nzpodd_enable_run_wake(dev);\r\nacpi_bus_set_power(handle, acpi_state);\r\n} else {\r\nif (runtime && zpodd_dev_enabled(dev))\r\nzpodd_disable_run_wake(dev);\r\nacpi_bus_set_power(handle, ACPI_STATE_D0);\r\n}\r\n}\r\n}\r\nstatic void pata_acpi_set_state(struct ata_port *ap, pm_message_t state)\r\n{\r\nstruct ata_device *dev;\r\nacpi_handle port_handle;\r\nport_handle = ata_ap_acpi_handle(ap);\r\nif (!port_handle)\r\nreturn;\r\nif (state.event & PM_EVENT_RESUME)\r\nacpi_bus_set_power(port_handle, ACPI_STATE_D0);\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nacpi_handle dev_handle = ata_dev_acpi_handle(dev);\r\nif (!dev_handle)\r\ncontinue;\r\nacpi_bus_set_power(dev_handle, state.event & PM_EVENT_RESUME ?\r\nACPI_STATE_D0 : ACPI_STATE_D3);\r\n}\r\nif (!(state.event & PM_EVENT_RESUME))\r\nacpi_bus_set_power(port_handle, ACPI_STATE_D3);\r\n}\r\nvoid ata_acpi_set_state(struct ata_port *ap, pm_message_t state)\r\n{\r\nif (ap->flags & ATA_FLAG_ACPI_SATA)\r\nsata_acpi_set_state(ap, state);\r\nelse\r\npata_acpi_set_state(ap, state);\r\n}\r\nint ata_acpi_on_devcfg(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct ata_eh_context *ehc = &ap->link.eh_context;\r\nint acpi_sata = ap->flags & ATA_FLAG_ACPI_SATA;\r\nint nr_executed = 0;\r\nint rc;\r\nif (!ata_dev_acpi_handle(dev))\r\nreturn 0;\r\nif (!(dev->flags & ATA_DFLAG_ACPI_PENDING) &&\r\n!(acpi_sata && (ehc->i.flags & ATA_EHI_DID_HARDRESET)))\r\nreturn 0;\r\nif (acpi_sata) {\r\nrc = ata_acpi_push_id(dev);\r\nif (rc && rc != -ENOENT)\r\ngoto acpi_err;\r\n}\r\nrc = ata_acpi_exec_tfs(dev, &nr_executed);\r\nif (rc)\r\ngoto acpi_err;\r\ndev->flags &= ~ATA_DFLAG_ACPI_PENDING;\r\nif (nr_executed) {\r\nrc = ata_dev_reread_id(dev, 0);\r\nif (rc < 0) {\r\nata_dev_err(dev,\r\n"failed to IDENTIFY after ACPI commands\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\nacpi_err:\r\nif (rc == -EINVAL && !nr_executed && !(ap->pflags & ATA_PFLAG_FROZEN))\r\nreturn 0;\r\nif (!(dev->flags & ATA_DFLAG_ACPI_FAILED)) {\r\ndev->flags |= ATA_DFLAG_ACPI_FAILED;\r\nreturn rc;\r\n}\r\ndev->flags |= ATA_DFLAG_ACPI_DISABLED;\r\nata_dev_warn(dev, "ACPI: failed the second time, disabled\n");\r\nif (!nr_executed && !(ap->pflags & ATA_PFLAG_FROZEN))\r\nreturn 0;\r\nreturn rc;\r\n}\r\nvoid ata_acpi_on_disable(struct ata_device *dev)\r\n{\r\nata_acpi_clear_gtf(dev);\r\n}\r\nstatic int compat_pci_ata(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->tdev.parent;\r\nstruct pci_dev *pdev;\r\nif (!is_pci_dev(dev))\r\nreturn 0;\r\npdev = to_pci_dev(dev);\r\nif ((pdev->class >> 8) != PCI_CLASS_STORAGE_SATA &&\r\n(pdev->class >> 8) != PCI_CLASS_STORAGE_IDE)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ata_acpi_bind_host(struct ata_port *ap, acpi_handle *handle)\r\n{\r\nif (libata_noacpi || ap->flags & ATA_FLAG_ACPI_SATA)\r\nreturn -ENODEV;\r\n*handle = acpi_get_child(DEVICE_ACPI_HANDLE(ap->tdev.parent),\r\nap->port_no);\r\nif (!*handle)\r\nreturn -ENODEV;\r\nif (__ata_acpi_gtm(ap, *handle, &ap->__acpi_init_gtm) == 0)\r\nap->pflags |= ATA_PFLAG_INIT_GTM_VALID;\r\nreturn 0;\r\n}\r\nstatic int ata_acpi_bind_device(struct ata_port *ap, struct scsi_device *sdev,\r\nacpi_handle *handle)\r\n{\r\nstruct ata_device *ata_dev;\r\nif (ap->flags & ATA_FLAG_ACPI_SATA) {\r\nif (!sata_pmp_attached(ap))\r\nata_dev = &ap->link.device[sdev->id];\r\nelse\r\nata_dev = &ap->pmp_link[sdev->channel].device[sdev->id];\r\n}\r\nelse {\r\nata_dev = &ap->link.device[sdev->id];\r\n}\r\n*handle = ata_dev_acpi_handle(ata_dev);\r\nif (!*handle)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int is_ata_port(const struct device *dev)\r\n{\r\nreturn dev->type == &ata_port_type;\r\n}\r\nstatic struct ata_port *dev_to_ata_port(struct device *dev)\r\n{\r\nwhile (!is_ata_port(dev)) {\r\nif (!dev->parent)\r\nreturn NULL;\r\ndev = dev->parent;\r\n}\r\nreturn to_ata_port(dev);\r\n}\r\nstatic int ata_acpi_find_device(struct device *dev, acpi_handle *handle)\r\n{\r\nstruct ata_port *ap = dev_to_ata_port(dev);\r\nif (!ap)\r\nreturn -ENODEV;\r\nif (!compat_pci_ata(ap))\r\nreturn -ENODEV;\r\nif (scsi_is_host_device(dev))\r\nreturn ata_acpi_bind_host(ap, handle);\r\nelse if (scsi_is_sdev_device(dev)) {\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nreturn ata_acpi_bind_device(ap, sdev, handle);\r\n} else\r\nreturn -ENODEV;\r\n}\r\nint ata_acpi_register(void)\r\n{\r\nreturn scsi_register_acpi_bus_type(&ata_acpi_bus);\r\n}\r\nvoid ata_acpi_unregister(void)\r\n{\r\nscsi_unregister_acpi_bus_type(&ata_acpi_bus);\r\n}
