static int dgrp_mon_open(struct inode *inode, struct file *file)\r\n{\r\nstruct nd_struct *nd;\r\nstruct timeval tv;\r\nuint32_t time;\r\nu8 *buf;\r\nint rtn;\r\nrtn = try_module_get(THIS_MODULE);\r\nif (!rtn)\r\nreturn -ENXIO;\r\nrtn = 0;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nrtn = -EPERM;\r\ngoto done;\r\n}\r\nif (file->private_data) {\r\nrtn = -EINVAL;\r\ngoto done;\r\n}\r\nnd = PDE_DATA(inode);\r\nif (!nd) {\r\nrtn = -ENXIO;\r\ngoto done;\r\n}\r\nfile->private_data = (void *) nd;\r\ndown(&nd->nd_mon_semaphore);\r\nif (nd->nd_mon_buf) {\r\nrtn = -EBUSY;\r\ngoto done_up;\r\n}\r\nnd->nd_mon_buf = kmalloc(MON_MAX, GFP_KERNEL);\r\nif (!nd->nd_mon_buf) {\r\nrtn = -ENOMEM;\r\ngoto done_up;\r\n}\r\nbuf = nd->nd_mon_buf;\r\nstrcpy(buf, RPDUMP_MAGIC);\r\nbuf += strlen(buf) + 1;\r\ndo_gettimeofday(&tv);\r\ntime = (uint32_t) (tv.tv_sec & 0xffffffff);\r\nput_unaligned_be32(time, buf);\r\nput_unaligned_be16(0, buf + 4);\r\nbuf += 6;\r\nif (nd->nd_tx_module) {\r\nbuf[0] = RPDUMP_CLIENT;\r\nput_unaligned_be32(0, buf + 1);\r\nput_unaligned_be16(1, buf + 5);\r\nbuf[7] = 0xf0 + nd->nd_tx_module;\r\nbuf += 8;\r\n}\r\nif (nd->nd_rx_module) {\r\nbuf[0] = RPDUMP_SERVER;\r\nput_unaligned_be32(0, buf + 1);\r\nput_unaligned_be16(1, buf + 5);\r\nbuf[7] = 0xf0 + nd->nd_rx_module;\r\nbuf += 8;\r\n}\r\nnd->nd_mon_out = 0;\r\nnd->nd_mon_in = buf - nd->nd_mon_buf;\r\nnd->nd_mon_lbolt = jiffies;\r\ndone_up:\r\nup(&nd->nd_mon_semaphore);\r\ndone:\r\nif (rtn)\r\nmodule_put(THIS_MODULE);\r\nreturn rtn;\r\n}\r\nstatic int dgrp_mon_release(struct inode *inode, struct file *file)\r\n{\r\nstruct nd_struct *nd;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\ngoto done;\r\ndown(&nd->nd_mon_semaphore);\r\nkfree(nd->nd_mon_buf);\r\nnd->nd_mon_buf = NULL;\r\nnd->nd_mon_out = nd->nd_mon_in;\r\nif (nd->nd_mon_flag & MON_WAIT_SPACE) {\r\nnd->nd_mon_flag &= ~MON_WAIT_SPACE;\r\nwake_up_interruptible(&nd->nd_mon_wqueue);\r\n}\r\nup(&nd->nd_mon_semaphore);\r\ndown(&nd->nd_net_semaphore);\r\nup(&nd->nd_net_semaphore);\r\ndone:\r\nmodule_put(THIS_MODULE);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t dgrp_mon_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct nd_struct *nd;\r\nint r;\r\nint offset = 0;\r\nint res = 0;\r\nssize_t rtn;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\nreturn -ENXIO;\r\ndown(&nd->nd_mon_semaphore);\r\nfor (;;) {\r\nres = (nd->nd_mon_in - nd->nd_mon_out) & MON_MASK;\r\nif (res)\r\nbreak;\r\nnd->nd_mon_flag |= MON_WAIT_DATA;\r\nup(&nd->nd_mon_semaphore);\r\nrtn = wait_event_interruptible(nd->nd_mon_wqueue,\r\n((nd->nd_mon_flag & MON_WAIT_DATA) == 0));\r\nif (rtn)\r\nreturn rtn;\r\ndown(&nd->nd_mon_semaphore);\r\n}\r\nif (res > count)\r\nres = count;\r\nr = MON_MAX - nd->nd_mon_out;\r\nif (r <= res) {\r\nrtn = copy_to_user((void __user *)buf,\r\nnd->nd_mon_buf + nd->nd_mon_out, r);\r\nif (rtn) {\r\nup(&nd->nd_mon_semaphore);\r\nreturn -EFAULT;\r\n}\r\nnd->nd_mon_out = 0;\r\nres -= r;\r\noffset = r;\r\n}\r\nrtn = copy_to_user((void __user *) buf + offset,\r\nnd->nd_mon_buf + nd->nd_mon_out, res);\r\nif (rtn) {\r\nup(&nd->nd_mon_semaphore);\r\nreturn -EFAULT;\r\n}\r\nnd->nd_mon_out += res;\r\n*ppos += res;\r\nup(&nd->nd_mon_semaphore);\r\nif (nd->nd_mon_flag & MON_WAIT_SPACE) {\r\nnd->nd_mon_flag &= ~MON_WAIT_SPACE;\r\nwake_up_interruptible(&nd->nd_mon_wqueue);\r\n}\r\nreturn res;\r\n}\r\nstatic long dgrp_mon_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn -EINVAL;\r\n}
