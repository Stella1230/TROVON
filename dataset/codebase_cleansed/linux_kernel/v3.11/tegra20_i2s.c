static int tegra20_i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct tegra20_i2s *i2s = dev_get_drvdata(dev);\r\nclk_disable_unprepare(i2s->clk_i2s);\r\nreturn 0;\r\n}\r\nstatic int tegra20_i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct tegra20_i2s *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(i2s->clk_i2s);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra20_i2s_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct tegra20_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned int mask, val;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask = TEGRA20_I2S_CTRL_MASTER_ENABLE;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval = TEGRA20_I2S_CTRL_MASTER_ENABLE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask |= TEGRA20_I2S_CTRL_BIT_FORMAT_MASK |\r\nTEGRA20_I2S_CTRL_LRCK_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nval |= TEGRA20_I2S_CTRL_BIT_FORMAT_DSP;\r\nval |= TEGRA20_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nval |= TEGRA20_I2S_CTRL_BIT_FORMAT_DSP;\r\nval |= TEGRA20_I2S_CTRL_LRCK_R_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= TEGRA20_I2S_CTRL_BIT_FORMAT_I2S;\r\nval |= TEGRA20_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval |= TEGRA20_I2S_CTRL_BIT_FORMAT_RJM;\r\nval |= TEGRA20_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval |= TEGRA20_I2S_CTRL_BIT_FORMAT_LJM;\r\nval |= TEGRA20_I2S_CTRL_LRCK_L_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, TEGRA20_I2S_CTRL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int tegra20_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct tegra20_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned int mask, val;\r\nint ret, sample_size, srate, i2sclock, bitcnt;\r\nmask = TEGRA20_I2S_CTRL_BIT_SIZE_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = TEGRA20_I2S_CTRL_BIT_SIZE_16;\r\nsample_size = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval = TEGRA20_I2S_CTRL_BIT_SIZE_24;\r\nsample_size = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nval = TEGRA20_I2S_CTRL_BIT_SIZE_32;\r\nsample_size = 32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask |= TEGRA20_I2S_CTRL_FIFO_FORMAT_MASK;\r\nval |= TEGRA20_I2S_CTRL_FIFO_FORMAT_PACKED;\r\nregmap_update_bits(i2s->regmap, TEGRA20_I2S_CTRL, mask, val);\r\nsrate = params_rate(params);\r\ni2sclock = srate * params_channels(params) * sample_size * 2;\r\nret = clk_set_rate(i2s->clk_i2s, i2sclock);\r\nif (ret) {\r\ndev_err(dev, "Can't set I2S clock rate: %d\n", ret);\r\nreturn ret;\r\n}\r\nbitcnt = (i2sclock / (2 * srate)) - 1;\r\nif (bitcnt < 0 || bitcnt > TEGRA20_I2S_TIMING_CHANNEL_BIT_COUNT_MASK_US)\r\nreturn -EINVAL;\r\nval = bitcnt << TEGRA20_I2S_TIMING_CHANNEL_BIT_COUNT_SHIFT;\r\nif (i2sclock % (2 * srate))\r\nval |= TEGRA20_I2S_TIMING_NON_SYM_ENABLE;\r\nregmap_write(i2s->regmap, TEGRA20_I2S_TIMING, val);\r\nregmap_write(i2s->regmap, TEGRA20_I2S_FIFO_SCR,\r\nTEGRA20_I2S_FIFO_SCR_FIFO2_ATN_LVL_FOUR_SLOTS |\r\nTEGRA20_I2S_FIFO_SCR_FIFO1_ATN_LVL_FOUR_SLOTS);\r\nreturn 0;\r\n}\r\nstatic void tegra20_i2s_start_playback(struct tegra20_i2s *i2s)\r\n{\r\nregmap_update_bits(i2s->regmap, TEGRA20_I2S_CTRL,\r\nTEGRA20_I2S_CTRL_FIFO1_ENABLE,\r\nTEGRA20_I2S_CTRL_FIFO1_ENABLE);\r\n}\r\nstatic void tegra20_i2s_stop_playback(struct tegra20_i2s *i2s)\r\n{\r\nregmap_update_bits(i2s->regmap, TEGRA20_I2S_CTRL,\r\nTEGRA20_I2S_CTRL_FIFO1_ENABLE, 0);\r\n}\r\nstatic void tegra20_i2s_start_capture(struct tegra20_i2s *i2s)\r\n{\r\nregmap_update_bits(i2s->regmap, TEGRA20_I2S_CTRL,\r\nTEGRA20_I2S_CTRL_FIFO2_ENABLE,\r\nTEGRA20_I2S_CTRL_FIFO2_ENABLE);\r\n}\r\nstatic void tegra20_i2s_stop_capture(struct tegra20_i2s *i2s)\r\n{\r\nregmap_update_bits(i2s->regmap, TEGRA20_I2S_CTRL,\r\nTEGRA20_I2S_CTRL_FIFO2_ENABLE, 0);\r\n}\r\nstatic int tegra20_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tegra20_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ntegra20_i2s_start_playback(i2s);\r\nelse\r\ntegra20_i2s_start_capture(i2s);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ntegra20_i2s_stop_playback(i2s);\r\nelse\r\ntegra20_i2s_stop_capture(i2s);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra20_i2s_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct tegra20_i2s *i2s = snd_soc_dai_get_drvdata(dai);\r\ndai->capture_dma_data = &i2s->capture_dma_data;\r\ndai->playback_dma_data = &i2s->playback_dma_data;\r\nreturn 0;\r\n}\r\nstatic bool tegra20_i2s_wr_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA20_I2S_CTRL:\r\ncase TEGRA20_I2S_STATUS:\r\ncase TEGRA20_I2S_TIMING:\r\ncase TEGRA20_I2S_FIFO_SCR:\r\ncase TEGRA20_I2S_PCM_CTRL:\r\ncase TEGRA20_I2S_NW_CTRL:\r\ncase TEGRA20_I2S_TDM_CTRL:\r\ncase TEGRA20_I2S_TDM_TX_RX_CTRL:\r\ncase TEGRA20_I2S_FIFO1:\r\ncase TEGRA20_I2S_FIFO2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool tegra20_i2s_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA20_I2S_STATUS:\r\ncase TEGRA20_I2S_FIFO_SCR:\r\ncase TEGRA20_I2S_FIFO1:\r\ncase TEGRA20_I2S_FIFO2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool tegra20_i2s_precious_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA20_I2S_FIFO1:\r\ncase TEGRA20_I2S_FIFO2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic int tegra20_i2s_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra20_i2s *i2s;\r\nstruct resource *mem, *memregion, *dmareq;\r\nu32 of_dma[2];\r\nu32 dma_ch;\r\nvoid __iomem *regs;\r\nint ret;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_i2s), GFP_KERNEL);\r\nif (!i2s) {\r\ndev_err(&pdev->dev, "Can't allocate tegra20_i2s\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(&pdev->dev, i2s);\r\ni2s->dai = tegra20_i2s_dai_template;\r\ni2s->dai.name = dev_name(&pdev->dev);\r\ni2s->clk_i2s = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2s->clk_i2s)) {\r\ndev_err(&pdev->dev, "Can't retrieve i2s clock\n");\r\nret = PTR_ERR(i2s->clk_i2s);\r\ngoto err;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "No memory resource\n");\r\nret = -ENODEV;\r\ngoto err_clk_put;\r\n}\r\ndmareq = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dmareq) {\r\nif (of_property_read_u32_array(pdev->dev.of_node,\r\n"nvidia,dma-request-selector",\r\nof_dma, 2) < 0) {\r\ndev_err(&pdev->dev, "No DMA resource\n");\r\nret = -ENODEV;\r\ngoto err_clk_put;\r\n}\r\ndma_ch = of_dma[1];\r\n} else {\r\ndma_ch = dmareq->start;\r\n}\r\nmemregion = devm_request_mem_region(&pdev->dev, mem->start,\r\nresource_size(mem), DRV_NAME);\r\nif (!memregion) {\r\ndev_err(&pdev->dev, "Memory region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_clk_put;\r\n}\r\nregs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!regs) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_clk_put;\r\n}\r\ni2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\r\n&tegra20_i2s_regmap_config);\r\nif (IS_ERR(i2s->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nret = PTR_ERR(i2s->regmap);\r\ngoto err_clk_put;\r\n}\r\ni2s->capture_dma_data.addr = mem->start + TEGRA20_I2S_FIFO2;\r\ni2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->capture_dma_data.maxburst = 4;\r\ni2s->capture_dma_data.slave_id = dma_ch;\r\ni2s->playback_dma_data.addr = mem->start + TEGRA20_I2S_FIFO1;\r\ni2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->playback_dma_data.maxburst = 4;\r\ni2s->playback_dma_data.slave_id = dma_ch;\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = tegra20_i2s_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nret = snd_soc_register_component(&pdev->dev, &tegra20_i2s_component,\r\n&i2s->dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto err_suspend;\r\n}\r\nret = tegra_pcm_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM: %d\n", ret);\r\ngoto err_unregister_component;\r\n}\r\nreturn 0;\r\nerr_unregister_component:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra20_i2s_runtime_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nerr_clk_put:\r\nclk_put(i2s->clk_i2s);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tegra20_i2s_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra20_i2s *i2s = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra20_i2s_runtime_suspend(&pdev->dev);\r\ntegra_pcm_platform_unregister(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nclk_put(i2s->clk_i2s);\r\nreturn 0;\r\n}
