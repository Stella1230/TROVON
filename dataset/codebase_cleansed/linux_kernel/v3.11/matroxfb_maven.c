static int get_ctrl_id(__u32 v4l2_id) {\r\nint i;\r\nfor (i = 0; i < MAVCTRLS; i++) {\r\nif (v4l2_id < maven_controls[i].desc.id) {\r\nif (maven_controls[i].desc.id == 0x08000000) {\r\nreturn -EINVAL;\r\n}\r\nreturn -ENOENT;\r\n}\r\nif (v4l2_id == maven_controls[i].desc.id) {\r\nreturn i;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int* get_ctrl_ptr(struct maven_data* md, int idx) {\r\nreturn (int*)((char*)(md->primary_head) + maven_controls[idx].control);\r\n}\r\nstatic int maven_get_reg(struct i2c_client* c, char reg) {\r\nchar dst;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = c->addr,\r\n.flags = I2C_M_REV_DIR_ADDR,\r\n.len = sizeof(reg),\r\n.buf = &reg\r\n},\r\n{\r\n.addr = c->addr,\r\n.flags = I2C_M_RD | I2C_M_NOSTART,\r\n.len = sizeof(dst),\r\n.buf = &dst\r\n}\r\n};\r\ns32 err;\r\nerr = i2c_transfer(c->adapter, msgs, 2);\r\nif (err < 0)\r\nprintk(KERN_INFO "ReadReg(%d) failed\n", reg);\r\nreturn dst & 0xFF;\r\n}\r\nstatic int maven_set_reg(struct i2c_client* c, int reg, int val) {\r\ns32 err;\r\nerr = i2c_smbus_write_byte_data(c, reg, val);\r\nif (err)\r\nprintk(KERN_INFO "WriteReg(%d) failed\n", reg);\r\nreturn err;\r\n}\r\nstatic int maven_set_reg_pair(struct i2c_client* c, int reg, int val) {\r\ns32 err;\r\nerr = i2c_smbus_write_word_data(c, reg, val);\r\nif (err)\r\nprintk(KERN_INFO "WriteRegPair(%d) failed\n", reg);\r\nreturn err;\r\n}\r\nstatic int matroxfb_PLL_mavenclock(const struct matrox_pll_features2* pll,\r\nconst struct matrox_pll_ctl* ctl,\r\nunsigned int htotal, unsigned int vtotal,\r\nunsigned int* in, unsigned int* feed, unsigned int* post,\r\nunsigned int* h2) {\r\nunsigned int besth2 = 0;\r\nunsigned int fxtal = ctl->ref_freq;\r\nunsigned int fmin = pll->vco_freq_min / ctl->den;\r\nunsigned int fwant;\r\nunsigned int p;\r\nunsigned int scrlen;\r\nunsigned int fmax;\r\nDBG(__func__)\r\nscrlen = htotal * (vtotal - 1);\r\nfwant = htotal * vtotal;\r\nfmax = pll->vco_freq_max / ctl->den;\r\ndprintk(KERN_DEBUG "want: %u, xtal: %u, h: %u, v: %u, fmax: %u\n",\r\nfwant, fxtal, htotal, vtotal, fmax);\r\nfor (p = 1; p <= pll->post_shift_max; p++) {\r\nif (fwant * 2 > fmax)\r\nbreak;\r\nfwant *= 2;\r\n}\r\nif (fwant > fmax)\r\nreturn 0;\r\nfor (; p-- > 0; fwant >>= 1) {\r\nunsigned int m;\r\nif (fwant < fmin) break;\r\nfor (m = pll->in_div_min; m <= pll->in_div_max; m++) {\r\nunsigned int n;\r\nunsigned int dvd;\r\nunsigned int ln;\r\nn = (fwant * m) / fxtal;\r\nif (n < pll->feed_div_min)\r\ncontinue;\r\nif (n > pll->feed_div_max)\r\nbreak;\r\nln = fxtal * n;\r\ndvd = m << p;\r\nif (ln % dvd)\r\ncontinue;\r\nln = ln / dvd;\r\nif (ln < scrlen + 2)\r\ncontinue;\r\nln = ln - scrlen;\r\nif (ln > htotal)\r\ncontinue;\r\ndprintk(KERN_DEBUG "Match: %u / %u / %u / %u\n", n, m, p, ln);\r\nif (ln > besth2) {\r\ndprintk(KERN_DEBUG "Better...\n");\r\n*h2 = besth2 = ln;\r\n*post = p;\r\n*in = m;\r\n*feed = n;\r\n}\r\n}\r\n}\r\nif (besth2 < 2)\r\nreturn 0;\r\ndprintk(KERN_ERR "clk: %02X %02X %02X %d %d\n", *in, *feed, *post, fxtal, fwant);\r\nreturn fxtal * (*feed) / (*in) * ctl->den;\r\n}\r\nstatic int matroxfb_mavenclock(const struct matrox_pll_ctl *ctl,\r\nunsigned int htotal, unsigned int vtotal,\r\nunsigned int* in, unsigned int* feed, unsigned int* post,\r\nunsigned int* htotal2) {\r\nunsigned int fvco;\r\nunsigned int uninitialized_var(p);\r\nfvco = matroxfb_PLL_mavenclock(&maven1000_pll, ctl, htotal, vtotal, in, feed, &p, htotal2);\r\nif (!fvco)\r\nreturn -EINVAL;\r\np = (1 << p) - 1;\r\nif (fvco <= 100000000)\r\n;\r\nelse if (fvco <= 140000000)\r\np |= 0x08;\r\nelse if (fvco <= 180000000)\r\np |= 0x10;\r\nelse\r\np |= 0x18;\r\n*post = p;\r\nreturn 0;\r\n}\r\nstatic void DAC1064_calcclock(unsigned int freq, unsigned int fmax,\r\nunsigned int* in, unsigned int* feed, unsigned int* post) {\r\nunsigned int fvco;\r\nunsigned int p;\r\nfvco = matroxfb_PLL_calcclock(&maven_pll, freq, fmax, in, feed, &p);\r\np = (1 << p) - 1;\r\nif (fvco <= 100000)\r\n;\r\nelse if (fvco <= 140000)\r\np |= 0x08;\r\nelse if (fvco <= 180000)\r\np |= 0x10;\r\nelse\r\np |= 0x18;\r\n*post = p;\r\nreturn;\r\n}\r\nstatic unsigned char maven_compute_deflicker (const struct maven_data* md) {\r\nunsigned char df;\r\ndf = (md->version == MGATVO_B?0x40:0x00);\r\nswitch (md->primary_head->altout.tvo_params.deflicker) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ndf |= 0xB1;\r\nbreak;\r\ncase 2:\r\ndf |= 0xA2;\r\nbreak;\r\n}\r\nreturn df;\r\n}\r\nstatic void maven_compute_bwlevel (const struct maven_data* md,\r\nint *bl, int *wl) {\r\nconst int b = md->primary_head->altout.tvo_params.brightness + BLMIN;\r\nconst int c = md->primary_head->altout.tvo_params.contrast;\r\n*bl = max(b - c, BLMIN);\r\n*wl = min(b + c, WLMAX);\r\n}\r\nstatic const struct maven_gamma* maven_compute_gamma (const struct maven_data* md) {\r\nreturn maven_gamma + md->primary_head->altout.tvo_params.gamma;\r\n}\r\nstatic void maven_init_TVdata(const struct maven_data* md, struct mavenregs* data) {\r\nstatic struct mavenregs palregs = { {\r\n0x2A, 0x09, 0x8A, 0xCB,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x7E,\r\n0x44,\r\n0x9C,\r\n0x2E,\r\n0x21,\r\n0x00,\r\n0x3F, 0x03,\r\n0x3F, 0x03,\r\n0x1A,\r\n0x2A,\r\n0x1C, 0x3D, 0x14,\r\n0x9C, 0x01,\r\n0x00,\r\n0xFE,\r\n0x7E,\r\n0x60,\r\n0x05,\r\n0x89, 0x03,\r\n0x72,\r\n0x07,\r\n0x72,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x08,\r\n0x04,\r\n0x00,\r\n0x1A,\r\n0x55, 0x01,\r\n0x26,\r\n0x07, 0x7E,\r\n0x02, 0x54,\r\n0xB0, 0x00,\r\n0x14,\r\n0x49,\r\n0x00,\r\n0x00,\r\n0xA3,\r\n0xC8,\r\n0x22,\r\n0x02,\r\n0x22,\r\n0x3F, 0x03,\r\n0x00,\r\n0x00,\r\n}, MATROXFB_OUTPUT_MODE_PAL, 625, 50 };\r\nstatic struct mavenregs ntscregs = { {\r\n0x21, 0xF0, 0x7C, 0x1F,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x7E,\r\n0x43,\r\n0x7E,\r\n0x3D,\r\n0x00,\r\n0x00,\r\n0x41, 0x00,\r\n0x3C, 0x00,\r\n0x17,\r\n0x21,\r\n0x1B, 0x1B, 0x24,\r\n0x83, 0x01,\r\n0x00,\r\n0x0F,\r\n0x0F,\r\n0x60,\r\n0x05,\r\n0x89, 0x02,\r\n0x5F,\r\n0x04,\r\n0x5F,\r\n0x01,\r\n0x02,\r\n0x00,\r\n0x0A,\r\n0x05,\r\n0x00,\r\n0x10,\r\n0xFF, 0x03,\r\n0x24,\r\n0x0F, 0x78,\r\n0x00, 0x00,\r\n0xB2, 0x04,\r\n0x14,\r\n0x02,\r\n0x00,\r\n0x00,\r\n0xA3,\r\n0xC8,\r\n0x15,\r\n0x05,\r\n0x3B,\r\n0x3C, 0x00,\r\n0x00,\r\n0x00,\r\n}, MATROXFB_OUTPUT_MODE_NTSC, 525, 60 };\r\nstruct matrox_fb_info *minfo = md->primary_head;\r\nif (minfo->outputs[1].mode == MATROXFB_OUTPUT_MODE_PAL)\r\n*data = palregs;\r\nelse\r\n*data = ntscregs;\r\ndata->regs[0x93] = maven_compute_deflicker(md);\r\n{\r\nconst struct maven_gamma* g;\r\ng = maven_compute_gamma(md);\r\ndata->regs[0x83] = g->reg83;\r\ndata->regs[0x84] = g->reg84;\r\ndata->regs[0x85] = g->reg85;\r\ndata->regs[0x86] = g->reg86;\r\ndata->regs[0x87] = g->reg87;\r\ndata->regs[0x88] = g->reg88;\r\ndata->regs[0x89] = g->reg89;\r\ndata->regs[0x8A] = g->reg8a;\r\ndata->regs[0x8B] = g->reg8b;\r\n}\r\n{\r\nint bl, wl;\r\nmaven_compute_bwlevel (md, &bl, &wl);\r\ndata->regs[0x0e] = bl >> 2;\r\ndata->regs[0x0f] = bl & 3;\r\ndata->regs[0x1e] = wl >> 2;\r\ndata->regs[0x1f] = wl & 3;\r\n}\r\n{\r\ndata->regs[0x20] =\r\ndata->regs[0x22] = minfo->altout.tvo_params.saturation;\r\n}\r\ndata->regs[0x25] = minfo->altout.tvo_params.hue;\r\nreturn;\r\n}\r\nstatic void maven_init_TV(struct i2c_client* c, const struct mavenregs* m) {\r\nint val;\r\nmaven_set_reg(c, 0x3E, 0x01);\r\nmaven_get_reg(c, 0x82);\r\nmaven_set_reg(c, 0x8C, 0x00);\r\nmaven_get_reg(c, 0x94);\r\nmaven_set_reg(c, 0x94, 0xA2);\r\nmaven_set_reg_pair(c, 0x8E, 0x1EFF);\r\nmaven_set_reg(c, 0xC6, 0x01);\r\nmaven_get_reg(c, 0x06);\r\nmaven_set_reg(c, 0x06, 0xF9);\r\nLR(0x00); LR(0x01); LR(0x02); LR(0x03);\r\nLR(0x04);\r\nLR(0x2C);\r\nLR(0x08);\r\nLR(0x0A);\r\nLR(0x09);\r\nLR(0x29);\r\nLRP(0x31);\r\nLRP(0x17);\r\nLR(0x0B);\r\nLR(0x0C);\r\nif (m->mode == MATROXFB_OUTPUT_MODE_PAL) {\r\nmaven_set_reg(c, 0x35, 0x10);\r\n} else {\r\nmaven_set_reg(c, 0x35, 0x0F);\r\n}\r\nLRP(0x10);\r\nLRP(0x0E);\r\nLRP(0x1E);\r\nLR(0x20);\r\nLR(0x22);\r\nLR(0x25);\r\nLR(0x34);\r\nLR(0x33);\r\nLR(0x19);\r\nLR(0x12);\r\nLR(0x3B);\r\nLR(0x13);\r\nLR(0x39);\r\nLR(0x1D);\r\nLR(0x3A);\r\nLR(0x24);\r\nLR(0x14);\r\nLR(0x15);\r\nLR(0x16);\r\nLRP(0x2D);\r\nLRP(0x2F);\r\nLR(0x1A);\r\nLR(0x1B);\r\nLR(0x1C);\r\nLR(0x23);\r\nLR(0x26);\r\nLR(0x28);\r\nLR(0x27);\r\nLR(0x21);\r\nLRP(0x2A);\r\nif (m->mode == MATROXFB_OUTPUT_MODE_PAL)\r\nmaven_set_reg(c, 0x35, 0x1D);\r\nelse\r\nmaven_set_reg(c, 0x35, 0x1C);\r\nLRP(0x3C);\r\nLR(0x37);\r\nLR(0x38);\r\nmaven_set_reg(c, 0xB3, 0x01);\r\nmaven_get_reg(c, 0xB0);\r\nmaven_set_reg(c, 0xB0, 0x08);\r\nmaven_get_reg(c, 0xB9);\r\nmaven_set_reg(c, 0xB9, 0x78);\r\nmaven_get_reg(c, 0xBF);\r\nmaven_set_reg(c, 0xBF, 0x02);\r\nmaven_get_reg(c, 0x94);\r\nmaven_set_reg(c, 0x94, 0xB3);\r\nLR(0x80);\r\nLR(0x81);\r\nLR(0x82);\r\nmaven_set_reg(c, 0x8C, 0x20);\r\nmaven_get_reg(c, 0x8D);\r\nmaven_set_reg(c, 0x8D, 0x10);\r\nLR(0x90);\r\nLR(0x91);\r\nLR(0x92);\r\nLRP(0x9A);\r\nLRP(0x9C);\r\nLRP(0x9E);\r\nLRP(0xA0);\r\nLRP(0xA2);\r\nLRP(0xA4);\r\nLRP(0xA6);\r\nLRP(0xA8);\r\nLRP(0x98);\r\nLRP(0xAE);\r\nLRP(0x96);\r\nLRP(0xAA);\r\nLRP(0xAC);\r\nLR(0xBE);\r\nLR(0xC2);\r\nmaven_get_reg(c, 0x8D);\r\nmaven_set_reg(c, 0x8D, 0x04);\r\nLR(0x20);\r\nLR(0x22);\r\nLR(0x93);\r\nLR(0x20);\r\nLR(0x22);\r\nLR(0x25);\r\nLRP(0x0E);\r\nLRP(0x1E);\r\nLRP(0x0E);\r\nLRP(0x1E);\r\nLR(0x83);\r\nLR(0x84);\r\nLR(0x85);\r\nLR(0x86);\r\nLR(0x87);\r\nLR(0x88);\r\nLR(0x89);\r\nLR(0x8A);\r\nLR(0x8B);\r\nval = maven_get_reg(c, 0x8D);\r\nval &= 0x14;\r\nmaven_set_reg(c, 0x8D, val);\r\nLR(0x33);\r\nLR(0x19);\r\nLR(0x12);\r\nLR(0x3B);\r\nLR(0x13);\r\nLR(0x39);\r\nLR(0x1D);\r\nLR(0x3A);\r\nLR(0x24);\r\nLR(0x14);\r\nLR(0x15);\r\nLR(0x16);\r\nLRP(0x2D);\r\nLRP(0x2F);\r\nLR(0x1A);\r\nLR(0x1B);\r\nLR(0x1C);\r\nLR(0x23);\r\nLR(0x26);\r\nLR(0x28);\r\nLR(0x27);\r\nLR(0x21);\r\nLRP(0x2A);\r\nif (m->mode == MATROXFB_OUTPUT_MODE_PAL)\r\nmaven_set_reg(c, 0x35, 0x1D);\r\nelse\r\nmaven_set_reg(c, 0x35, 0x1C);\r\nLRP(0x3C);\r\nLR(0x37);\r\nLR(0x38);\r\nmaven_get_reg(c, 0xB0);\r\nLR(0xB0);\r\nLR(0x90);\r\nLR(0xBE);\r\nLR(0xC2);\r\nLRP(0x9A);\r\nLRP(0xA2);\r\nLRP(0x9E);\r\nLRP(0xA6);\r\nLRP(0xAA);\r\nLRP(0xAC);\r\nmaven_set_reg(c, 0x3E, 0x00);\r\nmaven_set_reg(c, 0x95, 0x20);\r\n}\r\nstatic int maven_find_exact_clocks(unsigned int ht, unsigned int vt,\r\nstruct mavenregs* m) {\r\nunsigned int x;\r\nunsigned int err = ~0;\r\nm->regs[0x80] = 0x0F;\r\nm->regs[0x81] = 0x07;\r\nm->regs[0x82] = 0x81;\r\nfor (x = 0; x < 8; x++) {\r\nunsigned int c;\r\nunsigned int uninitialized_var(a), uninitialized_var(b),\r\nuninitialized_var(h2);\r\nunsigned int h = ht + 2 + x;\r\nif (!matroxfb_mavenclock((m->mode == MATROXFB_OUTPUT_MODE_PAL) ? &maven_PAL : &maven_NTSC, h, vt, &a, &b, &c, &h2)) {\r\nunsigned int diff = h - h2;\r\nif (diff < err) {\r\nerr = diff;\r\nm->regs[0x80] = a - 1;\r\nm->regs[0x81] = b - 1;\r\nm->regs[0x82] = c | 0x80;\r\nm->hcorr = h2 - 2;\r\nm->htotal = h - 2;\r\n}\r\n}\r\n}\r\nreturn err != ~0U;\r\n}\r\nstatic inline int maven_compute_timming(struct maven_data* md,\r\nstruct my_timming* mt,\r\nstruct mavenregs* m) {\r\nunsigned int tmpi;\r\nunsigned int a, bv, c;\r\nstruct matrox_fb_info *minfo = md->primary_head;\r\nm->mode = minfo->outputs[1].mode;\r\nif (m->mode != MATROXFB_OUTPUT_MODE_MONITOR) {\r\nunsigned int lmargin;\r\nunsigned int umargin;\r\nunsigned int vslen;\r\nunsigned int hcrt;\r\nunsigned int slen;\r\nmaven_init_TVdata(md, m);\r\nif (maven_find_exact_clocks(mt->HTotal, mt->VTotal, m) == 0)\r\nreturn -EINVAL;\r\nlmargin = mt->HTotal - mt->HSyncEnd;\r\nslen = mt->HSyncEnd - mt->HSyncStart;\r\nhcrt = mt->HTotal - slen - mt->delay;\r\numargin = mt->VTotal - mt->VSyncEnd;\r\nvslen = mt->VSyncEnd - mt->VSyncStart;\r\nif (m->hcorr < mt->HTotal)\r\nhcrt += m->hcorr;\r\nif (hcrt > mt->HTotal)\r\nhcrt -= mt->HTotal;\r\nif (hcrt + 2 > mt->HTotal)\r\nhcrt = 0;\r\nm->regs[0x96] = m->hcorr;\r\nm->regs[0x97] = m->hcorr >> 8;\r\nm->regs[0x98] = 0x00; m->regs[0x99] = 0x00;\r\nm->regs[0x9A] = lmargin;\r\nm->regs[0x9B] = lmargin >> 8;\r\nm->regs[0x9C] = 0x04;\r\nm->regs[0x9D] = 0x00;\r\nm->regs[0xA0] = m->htotal;\r\nm->regs[0xA1] = m->htotal >> 8;\r\nm->regs[0xA2] = mt->VTotal - mt->VSyncStart - 1;\r\nm->regs[0xA3] = (mt->VTotal - mt->VSyncStart - 1) >> 8;\r\nif (md->version == MGATVO_B) {\r\nm->regs[0xA4] = 0x04;\r\nm->regs[0xA5] = 0x00;\r\n} else {\r\nm->regs[0xA4] = 0x01;\r\nm->regs[0xA5] = 0x00;\r\n}\r\nm->regs[0xA6] = 0x00;\r\nm->regs[0xA7] = 0x00;\r\nm->regs[0xA8] = mt->VTotal - 1;\r\nm->regs[0xA9] = (mt->VTotal - 1) >> 8;\r\nm->regs[0xAA] = hcrt;\r\nm->regs[0xAB] = hcrt >> 8;\r\nm->regs[0xAC] = mt->VTotal - 2;\r\nm->regs[0xAD] = (mt->VTotal - 2) >> 8;\r\nm->regs[0xAE] = 0x01;\r\nm->regs[0xAF] = 0x00;\r\n{\r\nint hdec;\r\nint hlen;\r\nunsigned int ibmin = 4 + lmargin + mt->HDisplay;\r\nunsigned int ib;\r\nint i;\r\nif (mt->HTotal)\r\nhdec = 94208 / (mt->HTotal);\r\nelse\r\nhdec = 0x81;\r\nif (hdec > 0x81)\r\nhdec = 0x81;\r\nif (hdec < 0x41)\r\nhdec = 0x41;\r\nhdec--;\r\nhlen = 98304 - 128 - ((lmargin + mt->HDisplay - 8) * hdec);\r\nif (hlen < 0)\r\nhlen = 0;\r\nhlen = hlen >> 8;\r\nif (hlen > 0xFF)\r\nhlen = 0xFF;\r\ni = 1;\r\ndo {\r\nib = ((0x3C0000 * i - 0x8000)/ hdec + 0x05E7) >> 8;\r\ni++;\r\n} while (ib < ibmin);\r\nif (ib >= m->htotal + 2) {\r\nib = ibmin;\r\n}\r\nm->regs[0x90] = hdec;\r\nm->regs[0xC2] = hlen;\r\nm->regs[0x9E] = ib;\r\nm->regs[0x9F] = ib >> 8;\r\n}\r\n{\r\nint vdec;\r\nint vlen;\r\n#define MATROX_USE64BIT_DIVIDE\r\nif (mt->VTotal) {\r\n#ifdef MATROX_USE64BIT_DIVIDE\r\nu64 f1;\r\nu32 a;\r\nu32 b;\r\na = m->vlines * (m->htotal + 2);\r\nb = (mt->VTotal - 1) * (m->htotal + 2) + m->hcorr + 2;\r\nf1 = ((u64)a) << 15;\r\ndo_div(f1, b);\r\nvdec = f1;\r\n#else\r\nvdec = m->vlines * 32768 / mt->VTotal;\r\n#endif\r\n} else\r\nvdec = 0x8000;\r\nif (vdec > 0x8000)\r\nvdec = 0x8000;\r\nvlen = (vslen + umargin + mt->VDisplay) * vdec;\r\nvlen = (vlen >> 16) - 146;\r\nif (vlen < 0)\r\nvlen = 0;\r\nif (vlen > 0xFF)\r\nvlen = 0xFF;\r\nvdec--;\r\nm->regs[0x91] = vdec;\r\nm->regs[0x92] = vdec >> 8;\r\nm->regs[0xBE] = vlen;\r\n}\r\nm->regs[0xB0] = 0x08;\r\nreturn 0;\r\n}\r\nDAC1064_calcclock(mt->pixclock, 450000, &a, &bv, &c);\r\nm->regs[0x80] = a;\r\nm->regs[0x81] = bv;\r\nm->regs[0x82] = c | 0x80;\r\nm->regs[0xB3] = 0x01;\r\nm->regs[0x94] = 0xB2;\r\nm->regs[0x96] = mt->HTotal;\r\nm->regs[0x97] = mt->HTotal >> 8;\r\nm->regs[0x98] = 0x00;\r\nm->regs[0x99] = 0x00;\r\ntmpi = mt->HSyncEnd - mt->HSyncStart;\r\nm->regs[0x9A] = tmpi;\r\nm->regs[0x9B] = tmpi >> 8;\r\ntmpi = mt->HTotal - mt->HSyncStart;\r\nm->regs[0x9C] = tmpi;\r\nm->regs[0x9D] = tmpi >> 8;\r\ntmpi += mt->HDisplay;\r\nm->regs[0x9E] = tmpi;\r\nm->regs[0x9F] = tmpi >> 8;\r\ntmpi = mt->HTotal + 1;\r\nm->regs[0xA0] = tmpi;\r\nm->regs[0xA1] = tmpi >> 8;\r\ntmpi = mt->VSyncEnd - mt->VSyncStart - 1;\r\nm->regs[0xA2] = tmpi;\r\nm->regs[0xA3] = tmpi >> 8;\r\ntmpi = mt->VTotal - mt->VSyncStart;\r\nm->regs[0xA4] = tmpi;\r\nm->regs[0xA5] = tmpi >> 8;\r\ntmpi = mt->VTotal - 1;\r\nm->regs[0xA6] = tmpi;\r\nm->regs[0xA7] = tmpi >> 8;\r\nm->regs[0xA8] = tmpi;\r\nm->regs[0xA9] = tmpi >> 8;\r\ntmpi = mt->HTotal - mt->delay;\r\nm->regs[0xAA] = tmpi;\r\nm->regs[0xAB] = tmpi >> 8;\r\ntmpi = mt->VTotal - 2;\r\nm->regs[0xAC] = tmpi;\r\nm->regs[0xAD] = tmpi >> 8;\r\nm->regs[0xAE] = 0x00;\r\nm->regs[0xAF] = 0x00;\r\nm->regs[0xB0] = 0x03;\r\nm->regs[0xB1] = 0xA0;\r\nm->regs[0x8C] = 0x20;\r\nm->regs[0x8D] = 0x04;\r\nm->regs[0xB9] = 0x1A;\r\nm->regs[0xBF] = 0x22;\r\nreturn 0;\r\n}\r\nstatic int maven_program_timming(struct maven_data* md,\r\nconst struct mavenregs* m) {\r\nstruct i2c_client *c = md->client;\r\nif (m->mode == MATROXFB_OUTPUT_MODE_MONITOR) {\r\nLR(0x80);\r\nLR(0x81);\r\nLR(0x82);\r\nLR(0xB3);\r\nLR(0x94);\r\nLRP(0x96);\r\nLRP(0x98);\r\nLRP(0x9A);\r\nLRP(0x9C);\r\nLRP(0x9E);\r\nLRP(0xA0);\r\nLRP(0xA2);\r\nLRP(0xA4);\r\nLRP(0xA6);\r\nLRP(0xA8);\r\nLRP(0xAA);\r\nLRP(0xAC);\r\nLRP(0xAE);\r\nLR(0xB0);\r\nLR(0xB1);\r\nLR(0x8C);\r\nLR(0x8D);\r\nLR(0xB9);\r\nLR(0xBF);\r\n} else {\r\nmaven_init_TV(c, m);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int maven_resync(struct maven_data* md) {\r\nstruct i2c_client *c = md->client;\r\nmaven_set_reg(c, 0x95, 0x20);\r\nreturn 0;\r\n}\r\nstatic int maven_get_queryctrl (struct maven_data* md,\r\nstruct v4l2_queryctrl *p) {\r\nint i;\r\ni = get_ctrl_id(p->id);\r\nif (i >= 0) {\r\n*p = maven_controls[i].desc;\r\nreturn 0;\r\n}\r\nif (i == -ENOENT) {\r\nstatic const struct v4l2_queryctrl disctrl =\r\n{ .flags = V4L2_CTRL_FLAG_DISABLED };\r\ni = p->id;\r\n*p = disctrl;\r\np->id = i;\r\nsprintf(p->name, "Ctrl #%08X", i);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int maven_set_control (struct maven_data* md,\r\nstruct v4l2_control *p) {\r\nint i;\r\ni = get_ctrl_id(p->id);\r\nif (i < 0) return -EINVAL;\r\nif (p->value == *get_ctrl_ptr(md, i)) return 0;\r\nif (p->value > maven_controls[i].desc.maximum) return -EINVAL;\r\nif (p->value < maven_controls[i].desc.minimum) return -EINVAL;\r\n*get_ctrl_ptr(md, i) = p->value;\r\nswitch (p->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\n{\r\nint blacklevel, whitelevel;\r\nmaven_compute_bwlevel(md, &blacklevel, &whitelevel);\r\nblacklevel = (blacklevel >> 2) | ((blacklevel & 3) << 8);\r\nwhitelevel = (whitelevel >> 2) | ((whitelevel & 3) << 8);\r\nmaven_set_reg_pair(md->client, 0x0e, blacklevel);\r\nmaven_set_reg_pair(md->client, 0x1e, whitelevel);\r\n}\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\n{\r\nmaven_set_reg(md->client, 0x20, p->value);\r\nmaven_set_reg(md->client, 0x22, p->value);\r\n}\r\nbreak;\r\ncase V4L2_CID_HUE:\r\n{\r\nmaven_set_reg(md->client, 0x25, p->value);\r\n}\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\n{\r\nconst struct maven_gamma* g;\r\ng = maven_compute_gamma(md);\r\nmaven_set_reg(md->client, 0x83, g->reg83);\r\nmaven_set_reg(md->client, 0x84, g->reg84);\r\nmaven_set_reg(md->client, 0x85, g->reg85);\r\nmaven_set_reg(md->client, 0x86, g->reg86);\r\nmaven_set_reg(md->client, 0x87, g->reg87);\r\nmaven_set_reg(md->client, 0x88, g->reg88);\r\nmaven_set_reg(md->client, 0x89, g->reg89);\r\nmaven_set_reg(md->client, 0x8a, g->reg8a);\r\nmaven_set_reg(md->client, 0x8b, g->reg8b);\r\n}\r\nbreak;\r\ncase MATROXFB_CID_TESTOUT:\r\n{\r\nunsigned char val\r\n= maven_get_reg(md->client, 0x8d);\r\nif (p->value) val |= 0x10;\r\nelse val &= ~0x10;\r\nmaven_set_reg(md->client, 0x8d, val);\r\n}\r\nbreak;\r\ncase MATROXFB_CID_DEFLICKER:\r\n{\r\nmaven_set_reg(md->client, 0x93, maven_compute_deflicker(md));\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int maven_get_control (struct maven_data* md,\r\nstruct v4l2_control *p) {\r\nint i;\r\ni = get_ctrl_id(p->id);\r\nif (i < 0) return -EINVAL;\r\np->value = *get_ctrl_ptr(md, i);\r\nreturn 0;\r\n}\r\nstatic int maven_out_compute(void* md, struct my_timming* mt) {\r\n#define mdinfo ((struct maven_data*)md)\r\n#define minfo (mdinfo->primary_head)\r\nreturn maven_compute_timming(md, mt, &minfo->hw.maven);\r\n#undef minfo\r\n#undef mdinfo\r\n}\r\nstatic int maven_out_program(void* md) {\r\n#define mdinfo ((struct maven_data*)md)\r\n#define minfo (mdinfo->primary_head)\r\nreturn maven_program_timming(md, &minfo->hw.maven);\r\n#undef minfo\r\n#undef mdinfo\r\n}\r\nstatic int maven_out_start(void* md) {\r\nreturn maven_resync(md);\r\n}\r\nstatic int maven_out_verify_mode(void* md, u_int32_t arg) {\r\nswitch (arg) {\r\ncase MATROXFB_OUTPUT_MODE_PAL:\r\ncase MATROXFB_OUTPUT_MODE_NTSC:\r\ncase MATROXFB_OUTPUT_MODE_MONITOR:\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int maven_out_get_queryctrl(void* md, struct v4l2_queryctrl* p) {\r\nreturn maven_get_queryctrl(md, p);\r\n}\r\nstatic int maven_out_get_ctrl(void* md, struct v4l2_control* p) {\r\nreturn maven_get_control(md, p);\r\n}\r\nstatic int maven_out_set_ctrl(void* md, struct v4l2_control* p) {\r\nreturn maven_set_control(md, p);\r\n}\r\nstatic int maven_init_client(struct i2c_client* clnt) {\r\nstruct maven_data* md = i2c_get_clientdata(clnt);\r\nstruct matrox_fb_info *minfo = container_of(clnt->adapter,\r\nstruct i2c_bit_adapter,\r\nadapter)->minfo;\r\nmd->primary_head = minfo;\r\nmd->client = clnt;\r\ndown_write(&minfo->altout.lock);\r\nminfo->outputs[1].output = &maven_altout;\r\nminfo->outputs[1].src = minfo->outputs[1].default_src;\r\nminfo->outputs[1].data = md;\r\nminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nup_write(&minfo->altout.lock);\r\nif (maven_get_reg(clnt, 0xB2) < 0x14) {\r\nmd->version = MGATVO_B;\r\n} else {\r\nmd->version = MGATVO_C;\r\n}\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < MAVCTRLS; ++i) {\r\n*get_ctrl_ptr(md, i) = maven_controls[i].desc.default_value;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int maven_shutdown_client(struct i2c_client* clnt) {\r\nstruct maven_data* md = i2c_get_clientdata(clnt);\r\nif (md->primary_head) {\r\nstruct matrox_fb_info *minfo = md->primary_head;\r\ndown_write(&minfo->altout.lock);\r\nminfo->outputs[1].src = MATROXFB_SRC_NONE;\r\nminfo->outputs[1].output = NULL;\r\nminfo->outputs[1].data = NULL;\r\nminfo->outputs[1].mode = MATROXFB_OUTPUT_MODE_MONITOR;\r\nup_write(&minfo->altout.lock);\r\nmd->primary_head = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int maven_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint err = -ENODEV;\r\nstruct maven_data* data;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_WORD_DATA |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_NOSTART |\r\nI2C_FUNC_PROTOCOL_MANGLING))\r\ngoto ERROR0;\r\nif (!(data = kzalloc(sizeof(*data), GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto ERROR0;\r\n}\r\ni2c_set_clientdata(client, data);\r\nerr = maven_init_client(client);\r\nif (err)\r\ngoto ERROR4;\r\nreturn 0;\r\nERROR4:;\r\nkfree(data);\r\nERROR0:;\r\nreturn err;\r\n}\r\nstatic int maven_remove(struct i2c_client *client)\r\n{\r\nmaven_shutdown_client(client);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init matroxfb_maven_init(void)\r\n{\r\nreturn i2c_add_driver(&maven_driver);\r\n}\r\nstatic void __exit matroxfb_maven_exit(void)\r\n{\r\ni2c_del_driver(&maven_driver);\r\n}
