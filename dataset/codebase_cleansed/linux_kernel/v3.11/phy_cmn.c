void wlc_phyreg_enter(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nwlapi_bmac_ucode_wake_override_phyreg_set(pi->sh->physhim);\r\n}\r\nvoid wlc_phyreg_exit(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nwlapi_bmac_ucode_wake_override_phyreg_clear(pi->sh->physhim);\r\n}\r\nvoid wlc_radioreg_enter(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nwlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, MCTL_LOCK_RADIO);\r\nudelay(10);\r\n}\r\nvoid wlc_radioreg_exit(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\n(void)bcma_read16(pi->d11core, D11REGOFFS(phyversion));\r\npi->phy_wreg = 0;\r\nwlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);\r\n}\r\nu16 read_radio_reg(struct brcms_phy *pi, u16 addr)\r\n{\r\nu16 data;\r\nif ((addr == RADIO_IDCODE))\r\nreturn 0xffff;\r\nswitch (pi->pubpi.phy_type) {\r\ncase PHY_TYPE_N:\r\nif (!CONF_HAS(PHYTYPE, PHY_TYPE_N))\r\nbreak;\r\nif (NREV_GE(pi->pubpi.phy_rev, 7))\r\naddr |= RADIO_2057_READ_OFF;\r\nelse\r\naddr |= RADIO_2055_READ_OFF;\r\nbreak;\r\ncase PHY_TYPE_LCN:\r\nif (!CONF_HAS(PHYTYPE, PHY_TYPE_LCN))\r\nbreak;\r\naddr |= RADIO_2064_READ_OFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((D11REV_GE(pi->sh->corerev, 24)) ||\r\n(D11REV_IS(pi->sh->corerev, 22)\r\n&& (pi->pubpi.phy_type != PHY_TYPE_SSN))) {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), addr);\r\ndata = bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\r\n} else {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phy4waddr), addr);\r\ndata = bcma_read16(pi->d11core, D11REGOFFS(phy4wdatalo));\r\n}\r\npi->phy_wreg = 0;\r\nreturn data;\r\n}\r\nvoid write_radio_reg(struct brcms_phy *pi, u16 addr, u16 val)\r\n{\r\nif ((D11REV_GE(pi->sh->corerev, 24)) ||\r\n(D11REV_IS(pi->sh->corerev, 22)\r\n&& (pi->pubpi.phy_type != PHY_TYPE_SSN))) {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), addr);\r\nbcma_write16(pi->d11core, D11REGOFFS(radioregdata), val);\r\n} else {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phy4waddr), addr);\r\nbcma_write16(pi->d11core, D11REGOFFS(phy4wdatalo), val);\r\n}\r\nif ((pi->d11core->bus->hosttype == BCMA_HOSTTYPE_PCI) &&\r\n(++pi->phy_wreg >= pi->phy_wreg_limit)) {\r\n(void)bcma_read32(pi->d11core, D11REGOFFS(maccontrol));\r\npi->phy_wreg = 0;\r\n}\r\n}\r\nstatic u32 read_radio_id(struct brcms_phy *pi)\r\n{\r\nu32 id;\r\nif (D11REV_GE(pi->sh->corerev, 24)) {\r\nu32 b0, b1, b2;\r\nbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), 0);\r\nb0 = (u32) bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\r\nbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), 1);\r\nb1 = (u32) bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\r\nbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), 2);\r\nb2 = (u32) bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\r\nid = ((b0 & 0xf) << 28) | (((b2 << 8) | b1) << 12) | ((b0 >> 4)\r\n& 0xf);\r\n} else {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phy4waddr), RADIO_IDCODE);\r\nid = (u32) bcma_read16(pi->d11core, D11REGOFFS(phy4wdatalo));\r\nid |= (u32) bcma_read16(pi->d11core,\r\nD11REGOFFS(phy4wdatahi)) << 16;\r\n}\r\npi->phy_wreg = 0;\r\nreturn id;\r\n}\r\nvoid and_radio_reg(struct brcms_phy *pi, u16 addr, u16 val)\r\n{\r\nu16 rval;\r\nrval = read_radio_reg(pi, addr);\r\nwrite_radio_reg(pi, addr, (rval & val));\r\n}\r\nvoid or_radio_reg(struct brcms_phy *pi, u16 addr, u16 val)\r\n{\r\nu16 rval;\r\nrval = read_radio_reg(pi, addr);\r\nwrite_radio_reg(pi, addr, (rval | val));\r\n}\r\nvoid xor_radio_reg(struct brcms_phy *pi, u16 addr, u16 mask)\r\n{\r\nu16 rval;\r\nrval = read_radio_reg(pi, addr);\r\nwrite_radio_reg(pi, addr, (rval ^ mask));\r\n}\r\nvoid mod_radio_reg(struct brcms_phy *pi, u16 addr, u16 mask, u16 val)\r\n{\r\nu16 rval;\r\nrval = read_radio_reg(pi, addr);\r\nwrite_radio_reg(pi, addr, (rval & ~mask) | (val & mask));\r\n}\r\nvoid write_phy_channel_reg(struct brcms_phy *pi, uint val)\r\n{\r\nbcma_write16(pi->d11core, D11REGOFFS(phychannel), val);\r\n}\r\nu16 read_phy_reg(struct brcms_phy *pi, u16 addr)\r\n{\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\r\npi->phy_wreg = 0;\r\nreturn bcma_read16(pi->d11core, D11REGOFFS(phyregdata));\r\n}\r\nvoid write_phy_reg(struct brcms_phy *pi, u16 addr, u16 val)\r\n{\r\n#ifdef CONFIG_BCM47XX\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\r\nbcma_write16(pi->d11core, D11REGOFFS(phyregdata), val);\r\nif (addr == 0x72)\r\n(void)bcma_read16(pi->d11core, D11REGOFFS(phyregdata));\r\n#else\r\nbcma_write32(pi->d11core, D11REGOFFS(phyregaddr), addr | (val << 16));\r\nif ((pi->d11core->bus->hosttype == BCMA_HOSTTYPE_PCI) &&\r\n(++pi->phy_wreg >= pi->phy_wreg_limit)) {\r\npi->phy_wreg = 0;\r\n(void)bcma_read16(pi->d11core, D11REGOFFS(phyversion));\r\n}\r\n#endif\r\n}\r\nvoid and_phy_reg(struct brcms_phy *pi, u16 addr, u16 val)\r\n{\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\r\nbcma_mask16(pi->d11core, D11REGOFFS(phyregdata), val);\r\npi->phy_wreg = 0;\r\n}\r\nvoid or_phy_reg(struct brcms_phy *pi, u16 addr, u16 val)\r\n{\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\r\nbcma_set16(pi->d11core, D11REGOFFS(phyregdata), val);\r\npi->phy_wreg = 0;\r\n}\r\nvoid mod_phy_reg(struct brcms_phy *pi, u16 addr, u16 mask, u16 val)\r\n{\r\nval &= mask;\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\r\nbcma_maskset16(pi->d11core, D11REGOFFS(phyregdata), ~mask, val);\r\npi->phy_wreg = 0;\r\n}\r\nstatic void wlc_set_phy_uninitted(struct brcms_phy *pi)\r\n{\r\nint i, j;\r\npi->initialized = false;\r\npi->tx_vos = 0xffff;\r\npi->nrssi_table_delta = 0x7fffffff;\r\npi->rc_cal = 0xffff;\r\npi->mintxbias = 0xffff;\r\npi->txpwridx = -1;\r\nif (ISNPHY(pi)) {\r\npi->phy_spuravoid = SPURAVOID_DISABLE;\r\nif (NREV_GE(pi->pubpi.phy_rev, 3)\r\n&& NREV_LT(pi->pubpi.phy_rev, 7))\r\npi->phy_spuravoid = SPURAVOID_AUTO;\r\npi->nphy_papd_skip = 0;\r\npi->nphy_papd_epsilon_offset[0] = 0xf588;\r\npi->nphy_papd_epsilon_offset[1] = 0xf588;\r\npi->nphy_txpwr_idx[0] = 128;\r\npi->nphy_txpwr_idx[1] = 128;\r\npi->nphy_txpwrindex[0].index_internal = 40;\r\npi->nphy_txpwrindex[1].index_internal = 40;\r\npi->phy_pabias = 0;\r\n} else {\r\npi->phy_spuravoid = SPURAVOID_AUTO;\r\n}\r\npi->radiopwr = 0xffff;\r\nfor (i = 0; i < STATIC_NUM_RF; i++) {\r\nfor (j = 0; j < STATIC_NUM_BB; j++)\r\npi->stats_11b_txpower[i][j] = -1;\r\n}\r\n}\r\nstruct shared_phy *wlc_phy_shared_attach(struct shared_phy_params *shp)\r\n{\r\nstruct shared_phy *sh;\r\nsh = kzalloc(sizeof(struct shared_phy), GFP_ATOMIC);\r\nif (sh == NULL)\r\nreturn NULL;\r\nsh->physhim = shp->physhim;\r\nsh->unit = shp->unit;\r\nsh->corerev = shp->corerev;\r\nsh->vid = shp->vid;\r\nsh->did = shp->did;\r\nsh->chip = shp->chip;\r\nsh->chiprev = shp->chiprev;\r\nsh->chippkg = shp->chippkg;\r\nsh->sromrev = shp->sromrev;\r\nsh->boardtype = shp->boardtype;\r\nsh->boardrev = shp->boardrev;\r\nsh->boardflags = shp->boardflags;\r\nsh->boardflags2 = shp->boardflags2;\r\nsh->fast_timer = PHY_SW_TIMER_FAST;\r\nsh->slow_timer = PHY_SW_TIMER_SLOW;\r\nsh->glacial_timer = PHY_SW_TIMER_GLACIAL;\r\nsh->rssi_mode = RSSI_ANT_MERGE_MAX;\r\nreturn sh;\r\n}\r\nstatic void wlc_phy_timercb_phycal(struct brcms_phy *pi)\r\n{\r\nuint delay = 5;\r\nif (PHY_PERICAL_MPHASE_PENDING(pi)) {\r\nif (!pi->sh->up) {\r\nwlc_phy_cal_perical_mphase_reset(pi);\r\nreturn;\r\n}\r\nif (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)) {\r\ndelay = 1000;\r\nwlc_phy_cal_perical_mphase_restart(pi);\r\n} else\r\nwlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_AUTO);\r\nwlapi_add_timer(pi->phycal_timer, delay, 0);\r\nreturn;\r\n}\r\n}\r\nstatic u32 wlc_phy_get_radio_ver(struct brcms_phy *pi)\r\n{\r\nu32 ver;\r\nver = read_radio_id(pi);\r\nreturn ver;\r\n}\r\nstruct brcms_phy_pub *\r\nwlc_phy_attach(struct shared_phy *sh, struct bcma_device *d11core,\r\nint bandtype, struct wiphy *wiphy)\r\n{\r\nstruct brcms_phy *pi;\r\nu32 sflags = 0;\r\nuint phyversion;\r\nu32 idcode;\r\nint i;\r\nif (D11REV_IS(sh->corerev, 4))\r\nsflags = SISF_2G_PHY | SISF_5G_PHY;\r\nelse\r\nsflags = bcma_aread32(d11core, BCMA_IOST);\r\nif (bandtype == BRCM_BAND_5G) {\r\nif ((sflags & (SISF_5G_PHY | SISF_DB_PHY)) == 0)\r\nreturn NULL;\r\n}\r\npi = sh->phy_head;\r\nif ((sflags & SISF_DB_PHY) && pi) {\r\nwlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);\r\npi->refcnt++;\r\nreturn &pi->pubpi_ro;\r\n}\r\npi = kzalloc(sizeof(struct brcms_phy), GFP_ATOMIC);\r\nif (pi == NULL)\r\nreturn NULL;\r\npi->wiphy = wiphy;\r\npi->d11core = d11core;\r\npi->sh = sh;\r\npi->phy_init_por = true;\r\npi->phy_wreg_limit = PHY_WREG_LIMIT;\r\npi->txpwr_percent = 100;\r\npi->do_initcal = true;\r\npi->phycal_tempdelta = 0;\r\nif (bandtype == BRCM_BAND_2G && (sflags & SISF_2G_PHY))\r\npi->pubpi.coreflags = SICF_GMODE;\r\nwlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);\r\nphyversion = bcma_read16(pi->d11core, D11REGOFFS(phyversion));\r\npi->pubpi.phy_type = PHY_TYPE(phyversion);\r\npi->pubpi.phy_rev = phyversion & PV_PV_MASK;\r\nif (pi->pubpi.phy_type == PHY_TYPE_LCNXN) {\r\npi->pubpi.phy_type = PHY_TYPE_N;\r\npi->pubpi.phy_rev += LCNXN_BASEREV;\r\n}\r\npi->pubpi.phy_corenum = PHY_CORE_NUM_2;\r\npi->pubpi.ana_rev = (phyversion & PV_AV_MASK) >> PV_AV_SHIFT;\r\nif (pi->pubpi.phy_type != PHY_TYPE_N &&\r\npi->pubpi.phy_type != PHY_TYPE_LCN)\r\ngoto err;\r\nif (bandtype == BRCM_BAND_5G) {\r\nif (!ISNPHY(pi))\r\ngoto err;\r\n} else if (!ISNPHY(pi) && !ISLCNPHY(pi)) {\r\ngoto err;\r\n}\r\nwlc_phy_anacore((struct brcms_phy_pub *) pi, ON);\r\nidcode = wlc_phy_get_radio_ver(pi);\r\npi->pubpi.radioid =\r\n(idcode & IDCODE_ID_MASK) >> IDCODE_ID_SHIFT;\r\npi->pubpi.radiorev =\r\n(idcode & IDCODE_REV_MASK) >> IDCODE_REV_SHIFT;\r\npi->pubpi.radiover =\r\n(idcode & IDCODE_VER_MASK) >> IDCODE_VER_SHIFT;\r\nif (!VALID_RADIO(pi, pi->pubpi.radioid))\r\ngoto err;\r\nwlc_phy_switch_radio((struct brcms_phy_pub *) pi, OFF);\r\nwlc_set_phy_uninitted(pi);\r\npi->bw = WL_CHANSPEC_BW_20;\r\npi->radio_chanspec = (bandtype == BRCM_BAND_2G) ?\r\nch20mhz_chspec(1) : ch20mhz_chspec(36);\r\npi->rxiq_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;\r\npi->rxiq_antsel = ANT_RX_DIV_DEF;\r\npi->watchdog_override = true;\r\npi->cal_type_override = PHY_PERICAL_AUTO;\r\npi->nphy_saved_noisevars.bufcount = 0;\r\nif (ISNPHY(pi))\r\npi->min_txpower = PHY_TXPWR_MIN_NPHY;\r\nelse\r\npi->min_txpower = PHY_TXPWR_MIN;\r\npi->sh->phyrxchain = 0x3;\r\npi->rx2tx_biasentry = -1;\r\npi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;\r\npi->phy_txcore_enable_temp =\r\nPHY_CHAIN_TX_DISABLE_TEMP - PHY_HYSTERESIS_DELTATEMP;\r\npi->phy_tempsense_offset = 0;\r\npi->phy_txcore_heatedup = false;\r\npi->nphy_lastcal_temp = -50;\r\npi->phynoise_polling = true;\r\nif (ISNPHY(pi) || ISLCNPHY(pi))\r\npi->phynoise_polling = false;\r\nfor (i = 0; i < TXP_NUM_RATES; i++) {\r\npi->txpwr_limit[i] = BRCMS_TXPWR_MAX;\r\npi->txpwr_env_limit[i] = BRCMS_TXPWR_MAX;\r\npi->tx_user_target[i] = BRCMS_TXPWR_MAX;\r\n}\r\npi->radiopwr_override = RADIOPWR_OVERRIDE_DEF;\r\npi->user_txpwr_at_rfport = false;\r\nif (ISNPHY(pi)) {\r\npi->phycal_timer = wlapi_init_timer(pi->sh->physhim,\r\nwlc_phy_timercb_phycal,\r\npi, "phycal");\r\nif (!pi->phycal_timer)\r\ngoto err;\r\nif (!wlc_phy_attach_nphy(pi))\r\ngoto err;\r\n} else if (ISLCNPHY(pi)) {\r\nif (!wlc_phy_attach_lcnphy(pi))\r\ngoto err;\r\n}\r\npi->refcnt++;\r\npi->next = pi->sh->phy_head;\r\nsh->phy_head = pi;\r\nmemcpy(&pi->pubpi_ro, &pi->pubpi, sizeof(struct brcms_phy_pub));\r\nreturn &pi->pubpi_ro;\r\nerr:\r\nkfree(pi);\r\nreturn NULL;\r\n}\r\nvoid wlc_phy_detach(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (pih) {\r\nif (--pi->refcnt)\r\nreturn;\r\nif (pi->phycal_timer) {\r\nwlapi_free_timer(pi->phycal_timer);\r\npi->phycal_timer = NULL;\r\n}\r\nif (pi->sh->phy_head == pi)\r\npi->sh->phy_head = pi->next;\r\nelse if (pi->sh->phy_head->next == pi)\r\npi->sh->phy_head->next = NULL;\r\nif (pi->pi_fptr.detach)\r\n(pi->pi_fptr.detach)(pi);\r\nkfree(pi);\r\n}\r\n}\r\nbool\r\nwlc_phy_get_phyversion(struct brcms_phy_pub *pih, u16 *phytype, u16 *phyrev,\r\nu16 *radioid, u16 *radiover)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\n*phytype = (u16) pi->pubpi.phy_type;\r\n*phyrev = (u16) pi->pubpi.phy_rev;\r\n*radioid = pi->pubpi.radioid;\r\n*radiover = pi->pubpi.radiorev;\r\nreturn true;\r\n}\r\nbool wlc_phy_get_encore(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nreturn pi->pubpi.abgphy_encore;\r\n}\r\nu32 wlc_phy_get_coreflags(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nreturn pi->pubpi.coreflags;\r\n}\r\nvoid wlc_phy_anacore(struct brcms_phy_pub *pih, bool on)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (ISNPHY(pi)) {\r\nif (on) {\r\nif (NREV_GE(pi->pubpi.phy_rev, 3)) {\r\nwrite_phy_reg(pi, 0xa6, 0x0d);\r\nwrite_phy_reg(pi, 0x8f, 0x0);\r\nwrite_phy_reg(pi, 0xa7, 0x0d);\r\nwrite_phy_reg(pi, 0xa5, 0x0);\r\n} else {\r\nwrite_phy_reg(pi, 0xa5, 0x0);\r\n}\r\n} else {\r\nif (NREV_GE(pi->pubpi.phy_rev, 3)) {\r\nwrite_phy_reg(pi, 0x8f, 0x07ff);\r\nwrite_phy_reg(pi, 0xa6, 0x0fd);\r\nwrite_phy_reg(pi, 0xa5, 0x07ff);\r\nwrite_phy_reg(pi, 0xa7, 0x0fd);\r\n} else {\r\nwrite_phy_reg(pi, 0xa5, 0x7fff);\r\n}\r\n}\r\n} else if (ISLCNPHY(pi)) {\r\nif (on) {\r\nand_phy_reg(pi, 0x43b,\r\n~((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));\r\n} else {\r\nor_phy_reg(pi, 0x43c,\r\n(0x1 << 0) | (0x1 << 1) | (0x1 << 2));\r\nor_phy_reg(pi, 0x43b,\r\n(0x1 << 0) | (0x1 << 1) | (0x1 << 2));\r\n}\r\n}\r\n}\r\nu32 wlc_phy_clk_bwbits(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nu32 phy_bw_clkbits = 0;\r\nif (pi && (ISNPHY(pi) || ISLCNPHY(pi))) {\r\nswitch (pi->bw) {\r\ncase WL_CHANSPEC_BW_10:\r\nphy_bw_clkbits = SICF_BW10;\r\nbreak;\r\ncase WL_CHANSPEC_BW_20:\r\nphy_bw_clkbits = SICF_BW20;\r\nbreak;\r\ncase WL_CHANSPEC_BW_40:\r\nphy_bw_clkbits = SICF_BW40;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn phy_bw_clkbits;\r\n}\r\nvoid wlc_phy_por_inform(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->phy_init_por = true;\r\n}\r\nvoid wlc_phy_edcrs_lock(struct brcms_phy_pub *pih, bool lock)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\npi->edcrs_threshold_lock = lock;\r\nwrite_phy_reg(pi, 0x22c, 0x46b);\r\nwrite_phy_reg(pi, 0x22d, 0x46b);\r\nwrite_phy_reg(pi, 0x22e, 0x3c0);\r\nwrite_phy_reg(pi, 0x22f, 0x3c0);\r\n}\r\nvoid wlc_phy_initcal_enable(struct brcms_phy_pub *pih, bool initcal)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\npi->do_initcal = initcal;\r\n}\r\nvoid wlc_phy_hw_clk_state_upd(struct brcms_phy_pub *pih, bool newstate)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (!pi || !pi->sh)\r\nreturn;\r\npi->sh->clk = newstate;\r\n}\r\nvoid wlc_phy_hw_state_upd(struct brcms_phy_pub *pih, bool newstate)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (!pi || !pi->sh)\r\nreturn;\r\npi->sh->up = newstate;\r\n}\r\nvoid wlc_phy_init(struct brcms_phy_pub *pih, u16 chanspec)\r\n{\r\nu32 mc;\r\nvoid (*phy_init)(struct brcms_phy *) = NULL;\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (pi->init_in_progress)\r\nreturn;\r\npi->init_in_progress = true;\r\npi->radio_chanspec = chanspec;\r\nmc = bcma_read32(pi->d11core, D11REGOFFS(maccontrol));\r\nif (WARN(mc & MCTL_EN_MAC, "HW error MAC running on init"))\r\nreturn;\r\nif (!(pi->measure_hold & PHY_HOLD_FOR_SCAN))\r\npi->measure_hold |= PHY_HOLD_FOR_NOT_ASSOC;\r\nif (WARN(!(bcma_aread32(pi->d11core, BCMA_IOST) & SISF_FCLKA),\r\n"HW error SISF_FCLKA\n"))\r\nreturn;\r\nphy_init = pi->pi_fptr.init;\r\nif (phy_init == NULL)\r\nreturn;\r\nwlc_phy_anacore(pih, ON);\r\nif (CHSPEC_BW(pi->radio_chanspec) != pi->bw)\r\nwlapi_bmac_bw_set(pi->sh->physhim,\r\nCHSPEC_BW(pi->radio_chanspec));\r\npi->nphy_gain_boost = true;\r\nwlc_phy_switch_radio((struct brcms_phy_pub *) pi, ON);\r\n(*phy_init)(pi);\r\npi->phy_init_por = false;\r\nif (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))\r\nwlc_phy_do_dummy_tx(pi, true, OFF);\r\nif (!(ISNPHY(pi)))\r\nwlc_phy_txpower_update_shm(pi);\r\nwlc_phy_ant_rxdiv_set((struct brcms_phy_pub *) pi, pi->sh->rx_antdiv);\r\npi->init_in_progress = false;\r\n}\r\nvoid wlc_phy_cal_init(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nvoid (*cal_init)(struct brcms_phy *) = NULL;\r\nif (WARN((bcma_read32(pi->d11core, D11REGOFFS(maccontrol)) &\r\nMCTL_EN_MAC) != 0, "HW error: MAC enabled during phy cal\n"))\r\nreturn;\r\nif (!pi->initialized) {\r\ncal_init = pi->pi_fptr.calinit;\r\nif (cal_init)\r\n(*cal_init)(pi);\r\npi->initialized = true;\r\n}\r\n}\r\nint wlc_phy_down(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nint callbacks = 0;\r\nif (pi->phycal_timer\r\n&& !wlapi_del_timer(pi->phycal_timer))\r\ncallbacks++;\r\npi->nphy_iqcal_chanspec_2G = 0;\r\npi->nphy_iqcal_chanspec_5G = 0;\r\nreturn callbacks;\r\n}\r\nvoid\r\nwlc_phy_table_addr(struct brcms_phy *pi, uint tbl_id, uint tbl_offset,\r\nu16 tblAddr, u16 tblDataHi, u16 tblDataLo)\r\n{\r\nwrite_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);\r\npi->tbl_data_hi = tblDataHi;\r\npi->tbl_data_lo = tblDataLo;\r\nif (pi->sh->chip == BCMA_CHIP_ID_BCM43224 &&\r\npi->sh->chiprev == 1) {\r\npi->tbl_addr = tblAddr;\r\npi->tbl_save_id = tbl_id;\r\npi->tbl_save_offset = tbl_offset;\r\n}\r\n}\r\nvoid wlc_phy_table_data_write(struct brcms_phy *pi, uint width, u32 val)\r\n{\r\nif ((pi->sh->chip == BCMA_CHIP_ID_BCM43224) &&\r\n(pi->sh->chiprev == 1) &&\r\n(pi->tbl_save_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {\r\nread_phy_reg(pi, pi->tbl_data_lo);\r\nwrite_phy_reg(pi, pi->tbl_addr,\r\n(pi->tbl_save_id << 10) | pi->tbl_save_offset);\r\npi->tbl_save_offset++;\r\n}\r\nif (width == 32) {\r\nwrite_phy_reg(pi, pi->tbl_data_hi, (u16) (val >> 16));\r\nwrite_phy_reg(pi, pi->tbl_data_lo, (u16) val);\r\n} else {\r\nwrite_phy_reg(pi, pi->tbl_data_lo, (u16) val);\r\n}\r\n}\r\nvoid\r\nwlc_phy_write_table(struct brcms_phy *pi, const struct phytbl_info *ptbl_info,\r\nu16 tblAddr, u16 tblDataHi, u16 tblDataLo)\r\n{\r\nuint idx;\r\nuint tbl_id = ptbl_info->tbl_id;\r\nuint tbl_offset = ptbl_info->tbl_offset;\r\nuint tbl_width = ptbl_info->tbl_width;\r\nconst u8 *ptbl_8b = (const u8 *)ptbl_info->tbl_ptr;\r\nconst u16 *ptbl_16b = (const u16 *)ptbl_info->tbl_ptr;\r\nconst u32 *ptbl_32b = (const u32 *)ptbl_info->tbl_ptr;\r\nwrite_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);\r\nfor (idx = 0; idx < ptbl_info->tbl_len; idx++) {\r\nif ((pi->sh->chip == BCMA_CHIP_ID_BCM43224) &&\r\n(pi->sh->chiprev == 1) &&\r\n(tbl_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {\r\nread_phy_reg(pi, tblDataLo);\r\nwrite_phy_reg(pi, tblAddr,\r\n(tbl_id << 10) | (tbl_offset + idx));\r\n}\r\nif (tbl_width == 32) {\r\nwrite_phy_reg(pi, tblDataHi,\r\n(u16) (ptbl_32b[idx] >> 16));\r\nwrite_phy_reg(pi, tblDataLo, (u16) ptbl_32b[idx]);\r\n} else if (tbl_width == 16) {\r\nwrite_phy_reg(pi, tblDataLo, ptbl_16b[idx]);\r\n} else {\r\nwrite_phy_reg(pi, tblDataLo, ptbl_8b[idx]);\r\n}\r\n}\r\n}\r\nvoid\r\nwlc_phy_read_table(struct brcms_phy *pi, const struct phytbl_info *ptbl_info,\r\nu16 tblAddr, u16 tblDataHi, u16 tblDataLo)\r\n{\r\nuint idx;\r\nuint tbl_id = ptbl_info->tbl_id;\r\nuint tbl_offset = ptbl_info->tbl_offset;\r\nuint tbl_width = ptbl_info->tbl_width;\r\nu8 *ptbl_8b = (u8 *)ptbl_info->tbl_ptr;\r\nu16 *ptbl_16b = (u16 *)ptbl_info->tbl_ptr;\r\nu32 *ptbl_32b = (u32 *)ptbl_info->tbl_ptr;\r\nwrite_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);\r\nfor (idx = 0; idx < ptbl_info->tbl_len; idx++) {\r\nif ((pi->sh->chip == BCMA_CHIP_ID_BCM43224) &&\r\n(pi->sh->chiprev == 1)) {\r\n(void)read_phy_reg(pi, tblDataLo);\r\nwrite_phy_reg(pi, tblAddr,\r\n(tbl_id << 10) | (tbl_offset + idx));\r\n}\r\nif (tbl_width == 32) {\r\nptbl_32b[idx] = read_phy_reg(pi, tblDataLo);\r\nptbl_32b[idx] |= (read_phy_reg(pi, tblDataHi) << 16);\r\n} else if (tbl_width == 16) {\r\nptbl_16b[idx] = read_phy_reg(pi, tblDataLo);\r\n} else {\r\nptbl_8b[idx] = (u8) read_phy_reg(pi, tblDataLo);\r\n}\r\n}\r\n}\r\nuint\r\nwlc_phy_init_radio_regs_allbands(struct brcms_phy *pi,\r\nstruct radio_20xx_regs *radioregs)\r\n{\r\nuint i = 0;\r\ndo {\r\nif (radioregs[i].do_init)\r\nwrite_radio_reg(pi, radioregs[i].address,\r\n(u16) radioregs[i].init);\r\ni++;\r\n} while (radioregs[i].address != 0xffff);\r\nreturn i;\r\n}\r\nuint\r\nwlc_phy_init_radio_regs(struct brcms_phy *pi,\r\nconst struct radio_regs *radioregs,\r\nu16 core_offset)\r\n{\r\nuint i = 0;\r\nuint count = 0;\r\ndo {\r\nif (CHSPEC_IS5G(pi->radio_chanspec)) {\r\nif (radioregs[i].do_init_a) {\r\nwrite_radio_reg(pi,\r\nradioregs[i].\r\naddress | core_offset,\r\n(u16) radioregs[i].init_a);\r\nif (ISNPHY(pi) && (++count % 4 == 0))\r\nBRCMS_PHY_WAR_PR51571(pi);\r\n}\r\n} else {\r\nif (radioregs[i].do_init_g) {\r\nwrite_radio_reg(pi,\r\nradioregs[i].\r\naddress | core_offset,\r\n(u16) radioregs[i].init_g);\r\nif (ISNPHY(pi) && (++count % 4 == 0))\r\nBRCMS_PHY_WAR_PR51571(pi);\r\n}\r\n}\r\ni++;\r\n} while (radioregs[i].address != 0xffff);\r\nreturn i;\r\n}\r\nvoid wlc_phy_do_dummy_tx(struct brcms_phy *pi, bool ofdm, bool pa_on)\r\n{\r\n#define DUMMY_PKT_LEN 20\r\nstruct bcma_device *core = pi->d11core;\r\nint i, count;\r\nu8 ofdmpkt[DUMMY_PKT_LEN] = {\r\n0xcc, 0x01, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00\r\n};\r\nu8 cckpkt[DUMMY_PKT_LEN] = {\r\n0x6e, 0x84, 0x0b, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00\r\n};\r\nu32 *dummypkt;\r\ndummypkt = (u32 *) (ofdm ? ofdmpkt : cckpkt);\r\nwlapi_bmac_write_template_ram(pi->sh->physhim, 0, DUMMY_PKT_LEN,\r\ndummypkt);\r\nbcma_write16(core, D11REGOFFS(xmtsel), 0);\r\nif (D11REV_GE(pi->sh->corerev, 11))\r\nbcma_write16(core, D11REGOFFS(wepctl), 0x100);\r\nelse\r\nbcma_write16(core, D11REGOFFS(wepctl), 0);\r\nbcma_write16(core, D11REGOFFS(txe_phyctl),\r\n(ofdm ? 1 : 0) | PHY_TXC_ANT_0);\r\nif (ISNPHY(pi) || ISLCNPHY(pi))\r\nbcma_write16(core, D11REGOFFS(txe_phyctl1), 0x1A02);\r\nbcma_write16(core, D11REGOFFS(txe_wm_0), 0);\r\nbcma_write16(core, D11REGOFFS(txe_wm_1), 0);\r\nbcma_write16(core, D11REGOFFS(xmttplatetxptr), 0);\r\nbcma_write16(core, D11REGOFFS(xmttxcnt), DUMMY_PKT_LEN);\r\nbcma_write16(core, D11REGOFFS(xmtsel),\r\n((8 << 8) | (1 << 5) | (1 << 2) | 2));\r\nbcma_write16(core, D11REGOFFS(txe_ctl), 0);\r\nif (!pa_on) {\r\nif (ISNPHY(pi))\r\nwlc_phy_pa_override_nphy(pi, OFF);\r\n}\r\nif (ISNPHY(pi) || ISLCNPHY(pi))\r\nbcma_write16(core, D11REGOFFS(txe_aux), 0xD0);\r\nelse\r\nbcma_write16(core, D11REGOFFS(txe_aux), ((1 << 5) | (1 << 4)));\r\n(void)bcma_read16(core, D11REGOFFS(txe_aux));\r\ni = 0;\r\ncount = ofdm ? 30 : 250;\r\nwhile ((i++ < count)\r\n&& (bcma_read16(core, D11REGOFFS(txe_status)) & (1 << 7)))\r\nudelay(10);\r\ni = 0;\r\nwhile ((i++ < 10) &&\r\n((bcma_read16(core, D11REGOFFS(txe_status)) & (1 << 10)) == 0))\r\nudelay(10);\r\ni = 0;\r\nwhile ((i++ < 10) &&\r\n((bcma_read16(core, D11REGOFFS(ifsstat)) & (1 << 8))))\r\nudelay(10);\r\nif (!pa_on) {\r\nif (ISNPHY(pi))\r\nwlc_phy_pa_override_nphy(pi, ON);\r\n}\r\n}\r\nvoid wlc_phy_hold_upd(struct brcms_phy_pub *pih, u32 id, bool set)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (set)\r\nmboolset(pi->measure_hold, id);\r\nelse\r\nmboolclr(pi->measure_hold, id);\r\nreturn;\r\n}\r\nvoid wlc_phy_mute_upd(struct brcms_phy_pub *pih, bool mute, u32 flags)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (mute)\r\nmboolset(pi->measure_hold, PHY_HOLD_FOR_MUTE);\r\nelse\r\nmboolclr(pi->measure_hold, PHY_HOLD_FOR_MUTE);\r\nif (!mute && (flags & PHY_MUTE_FOR_PREISM))\r\npi->nphy_perical_last = pi->sh->now - pi->sh->glacial_timer;\r\nreturn;\r\n}\r\nvoid wlc_phy_clear_tssi(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (ISNPHY(pi)) {\r\nreturn;\r\n} else {\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_0, NULL_TSSI_W);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_1, NULL_TSSI_W);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_0, NULL_TSSI_W);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_1, NULL_TSSI_W);\r\n}\r\n}\r\nstatic bool wlc_phy_cal_txpower_recalc_sw(struct brcms_phy *pi)\r\n{\r\nreturn false;\r\n}\r\nvoid wlc_phy_switch_radio(struct brcms_phy_pub *pih, bool on)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\n(void)bcma_read32(pi->d11core, D11REGOFFS(maccontrol));\r\nif (ISNPHY(pi)) {\r\nwlc_phy_switch_radio_nphy(pi, on);\r\n} else if (ISLCNPHY(pi)) {\r\nif (on) {\r\nand_phy_reg(pi, 0x44c,\r\n~((0x1 << 8) |\r\n(0x1 << 9) |\r\n(0x1 << 10) | (0x1 << 11) | (0x1 << 12)));\r\nand_phy_reg(pi, 0x4b0, ~((0x1 << 3) | (0x1 << 11)));\r\nand_phy_reg(pi, 0x4f9, ~(0x1 << 3));\r\n} else {\r\nand_phy_reg(pi, 0x44d,\r\n~((0x1 << 10) |\r\n(0x1 << 11) |\r\n(0x1 << 12) | (0x1 << 13) | (0x1 << 14)));\r\nor_phy_reg(pi, 0x44c,\r\n(0x1 << 8) |\r\n(0x1 << 9) |\r\n(0x1 << 10) | (0x1 << 11) | (0x1 << 12));\r\nand_phy_reg(pi, 0x4b7, ~((0x7f << 8)));\r\nand_phy_reg(pi, 0x4b1, ~((0x1 << 13)));\r\nor_phy_reg(pi, 0x4b0, (0x1 << 3) | (0x1 << 11));\r\nand_phy_reg(pi, 0x4fa, ~((0x1 << 3)));\r\nor_phy_reg(pi, 0x4f9, (0x1 << 3));\r\n}\r\n}\r\n}\r\nu16 wlc_phy_bw_state_get(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nreturn pi->bw;\r\n}\r\nvoid wlc_phy_bw_state_set(struct brcms_phy_pub *ppi, u16 bw)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->bw = bw;\r\n}\r\nvoid wlc_phy_chanspec_radio_set(struct brcms_phy_pub *ppi, u16 newch)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->radio_chanspec = newch;\r\n}\r\nu16 wlc_phy_chanspec_get(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nreturn pi->radio_chanspec;\r\n}\r\nvoid wlc_phy_chanspec_set(struct brcms_phy_pub *ppi, u16 chanspec)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nu16 m_cur_channel;\r\nvoid (*chanspec_set)(struct brcms_phy *, u16) = NULL;\r\nm_cur_channel = CHSPEC_CHANNEL(chanspec);\r\nif (CHSPEC_IS5G(chanspec))\r\nm_cur_channel |= D11_CURCHANNEL_5G;\r\nif (CHSPEC_IS40(chanspec))\r\nm_cur_channel |= D11_CURCHANNEL_40;\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_CURCHANNEL, m_cur_channel);\r\nchanspec_set = pi->pi_fptr.chanset;\r\nif (chanspec_set)\r\n(*chanspec_set)(pi, chanspec);\r\n}\r\nint wlc_phy_chanspec_freq2bandrange_lpssn(uint freq)\r\n{\r\nint range = -1;\r\nif (freq < 2500)\r\nrange = WL_CHAN_FREQ_RANGE_2G;\r\nelse if (freq <= 5320)\r\nrange = WL_CHAN_FREQ_RANGE_5GL;\r\nelse if (freq <= 5700)\r\nrange = WL_CHAN_FREQ_RANGE_5GM;\r\nelse\r\nrange = WL_CHAN_FREQ_RANGE_5GH;\r\nreturn range;\r\n}\r\nint wlc_phy_chanspec_bandrange_get(struct brcms_phy *pi, u16 chanspec)\r\n{\r\nint range = -1;\r\nuint channel = CHSPEC_CHANNEL(chanspec);\r\nuint freq = wlc_phy_channel2freq(channel);\r\nif (ISNPHY(pi))\r\nrange = wlc_phy_get_chan_freq_range_nphy(pi, channel);\r\nelse if (ISLCNPHY(pi))\r\nrange = wlc_phy_chanspec_freq2bandrange_lpssn(freq);\r\nreturn range;\r\n}\r\nvoid wlc_phy_chanspec_ch14_widefilter_set(struct brcms_phy_pub *ppi,\r\nbool wide_filter)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->channel_14_wide_filter = wide_filter;\r\n}\r\nint wlc_phy_channel2freq(uint channel)\r\n{\r\nuint i;\r\nfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++)\r\nif (chan_info_all[i].chan == channel)\r\nreturn chan_info_all[i].freq;\r\nreturn 0;\r\n}\r\nvoid\r\nwlc_phy_chanspec_band_validch(struct brcms_phy_pub *ppi, uint band,\r\nstruct brcms_chanvec *channels)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nuint i;\r\nuint channel;\r\nmemset(channels, 0, sizeof(struct brcms_chanvec));\r\nfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {\r\nchannel = chan_info_all[i].chan;\r\nif ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)\r\n&& (channel <= LAST_REF5_CHANNUM))\r\ncontinue;\r\nif ((band == BRCM_BAND_2G && channel <= CH_MAX_2G_CHANNEL) ||\r\n(band == BRCM_BAND_5G && channel > CH_MAX_2G_CHANNEL))\r\nsetbit(channels->vec, channel);\r\n}\r\n}\r\nu16 wlc_phy_chanspec_band_firstch(struct brcms_phy_pub *ppi, uint band)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nuint i;\r\nuint channel;\r\nu16 chspec;\r\nfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {\r\nchannel = chan_info_all[i].chan;\r\nif (ISNPHY(pi) && pi->bw == WL_CHANSPEC_BW_40) {\r\nuint j;\r\nfor (j = 0; j < ARRAY_SIZE(chan_info_all); j++) {\r\nif (chan_info_all[j].chan ==\r\nchannel + CH_10MHZ_APART)\r\nbreak;\r\n}\r\nif (j == ARRAY_SIZE(chan_info_all))\r\ncontinue;\r\nchannel = upper_20_sb(channel);\r\nchspec = channel | WL_CHANSPEC_BW_40 |\r\nWL_CHANSPEC_CTL_SB_LOWER;\r\nif (band == BRCM_BAND_2G)\r\nchspec |= WL_CHANSPEC_BAND_2G;\r\nelse\r\nchspec |= WL_CHANSPEC_BAND_5G;\r\n} else\r\nchspec = ch20mhz_chspec(channel);\r\nif ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)\r\n&& (channel <= LAST_REF5_CHANNUM))\r\ncontinue;\r\nif ((band == BRCM_BAND_2G && channel <= CH_MAX_2G_CHANNEL) ||\r\n(band == BRCM_BAND_5G && channel > CH_MAX_2G_CHANNEL))\r\nreturn chspec;\r\n}\r\nreturn (u16) INVCHANSPEC;\r\n}\r\nint wlc_phy_txpower_get(struct brcms_phy_pub *ppi, uint *qdbm, bool *override)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\n*qdbm = pi->tx_user_target[0];\r\nif (override != NULL)\r\n*override = pi->txpwroverride;\r\nreturn 0;\r\n}\r\nvoid wlc_phy_txpower_target_set(struct brcms_phy_pub *ppi,\r\nstruct txpwr_limits *txpwr)\r\n{\r\nbool mac_enabled = false;\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_CCK],\r\n&txpwr->cck[0], BRCMS_NUM_RATES_CCK);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM],\r\n&txpwr->ofdm[0], BRCMS_NUM_RATES_OFDM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM_20_CDD],\r\n&txpwr->ofdm_cdd[0], BRCMS_NUM_RATES_OFDM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM_40_SISO],\r\n&txpwr->ofdm_40_siso[0], BRCMS_NUM_RATES_OFDM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM_40_CDD],\r\n&txpwr->ofdm_40_cdd[0], BRCMS_NUM_RATES_OFDM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_SISO],\r\n&txpwr->mcs_20_siso[0], BRCMS_NUM_RATES_MCS_1_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_CDD],\r\n&txpwr->mcs_20_cdd[0], BRCMS_NUM_RATES_MCS_1_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_STBC],\r\n&txpwr->mcs_20_stbc[0], BRCMS_NUM_RATES_MCS_1_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_SDM],\r\n&txpwr->mcs_20_mimo[0], BRCMS_NUM_RATES_MCS_2_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_SISO],\r\n&txpwr->mcs_40_siso[0], BRCMS_NUM_RATES_MCS_1_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_CDD],\r\n&txpwr->mcs_40_cdd[0], BRCMS_NUM_RATES_MCS_1_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_STBC],\r\n&txpwr->mcs_40_stbc[0], BRCMS_NUM_RATES_MCS_1_STREAM);\r\nmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_SDM],\r\n&txpwr->mcs_40_mimo[0], BRCMS_NUM_RATES_MCS_2_STREAM);\r\nif (bcma_read32(pi->d11core, D11REGOFFS(maccontrol)) & MCTL_EN_MAC)\r\nmac_enabled = true;\r\nif (mac_enabled)\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nwlc_phy_txpower_recalc_target(pi);\r\nwlc_phy_cal_txpower_recalc_sw(pi);\r\nif (mac_enabled)\r\nwlapi_enable_mac(pi->sh->physhim);\r\n}\r\nint wlc_phy_txpower_set(struct brcms_phy_pub *ppi, uint qdbm, bool override)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nint i;\r\nif (qdbm > 127)\r\nreturn -EINVAL;\r\nfor (i = 0; i < TXP_NUM_RATES; i++)\r\npi->tx_user_target[i] = (u8) qdbm;\r\npi->txpwroverride = false;\r\nif (pi->sh->up) {\r\nif (!SCAN_INPROG_PHY(pi)) {\r\nbool suspend;\r\nsuspend = (0 == (bcma_read32(pi->d11core,\r\nD11REGOFFS(maccontrol)) &\r\nMCTL_EN_MAC));\r\nif (!suspend)\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nwlc_phy_txpower_recalc_target(pi);\r\nwlc_phy_cal_txpower_recalc_sw(pi);\r\nif (!suspend)\r\nwlapi_enable_mac(pi->sh->physhim);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nwlc_phy_txpower_sromlimit(struct brcms_phy_pub *ppi, uint channel, u8 *min_pwr,\r\nu8 *max_pwr, int txp_rate_idx)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nuint i;\r\n*min_pwr = pi->min_txpower * BRCMS_TXPWR_DB_FACTOR;\r\nif (ISNPHY(pi)) {\r\nif (txp_rate_idx < 0)\r\ntxp_rate_idx = TXP_FIRST_CCK;\r\nwlc_phy_txpower_sromlimit_get_nphy(pi, channel, max_pwr,\r\n(u8) txp_rate_idx);\r\n} else if ((channel <= CH_MAX_2G_CHANNEL)) {\r\nif (txp_rate_idx < 0)\r\ntxp_rate_idx = TXP_FIRST_CCK;\r\n*max_pwr = pi->tx_srom_max_rate_2g[txp_rate_idx];\r\n} else {\r\n*max_pwr = BRCMS_TXPWR_MAX;\r\nif (txp_rate_idx < 0)\r\ntxp_rate_idx = TXP_FIRST_OFDM;\r\nfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {\r\nif (channel == chan_info_all[i].chan)\r\nbreak;\r\n}\r\nif (pi->hwtxpwr) {\r\n*max_pwr = pi->hwtxpwr[i];\r\n} else {\r\nif ((i >= FIRST_MID_5G_CHAN) && (i <= LAST_MID_5G_CHAN))\r\n*max_pwr =\r\npi->tx_srom_max_rate_5g_mid[txp_rate_idx];\r\nif ((i >= FIRST_HIGH_5G_CHAN)\r\n&& (i <= LAST_HIGH_5G_CHAN))\r\n*max_pwr =\r\npi->tx_srom_max_rate_5g_hi[txp_rate_idx];\r\nif ((i >= FIRST_LOW_5G_CHAN) && (i <= LAST_LOW_5G_CHAN))\r\n*max_pwr =\r\npi->tx_srom_max_rate_5g_low[txp_rate_idx];\r\n}\r\n}\r\n}\r\nvoid\r\nwlc_phy_txpower_sromlimit_max_get(struct brcms_phy_pub *ppi, uint chan,\r\nu8 *max_txpwr, u8 *min_txpwr)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nu8 tx_pwr_max = 0;\r\nu8 tx_pwr_min = 255;\r\nu8 max_num_rate;\r\nu8 maxtxpwr, mintxpwr, rate, pactrl;\r\npactrl = 0;\r\nmax_num_rate = ISNPHY(pi) ? TXP_NUM_RATES :\r\nISLCNPHY(pi) ? (TXP_LAST_SISO_MCS_20 +\r\n1) : (TXP_LAST_OFDM + 1);\r\nfor (rate = 0; rate < max_num_rate; rate++) {\r\nwlc_phy_txpower_sromlimit(ppi, chan, &mintxpwr, &maxtxpwr,\r\nrate);\r\nmaxtxpwr = (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;\r\nmaxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;\r\ntx_pwr_max = max(tx_pwr_max, maxtxpwr);\r\ntx_pwr_min = min(tx_pwr_min, maxtxpwr);\r\n}\r\n*max_txpwr = tx_pwr_max;\r\n*min_txpwr = tx_pwr_min;\r\n}\r\nvoid\r\nwlc_phy_txpower_boardlimit_band(struct brcms_phy_pub *ppi, uint bandunit,\r\ns32 *max_pwr, s32 *min_pwr, u32 *step_pwr)\r\n{\r\nreturn;\r\n}\r\nu8 wlc_phy_txpower_get_target_min(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nreturn pi->tx_power_min;\r\n}\r\nu8 wlc_phy_txpower_get_target_max(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nreturn pi->tx_power_max;\r\n}\r\nstatic s8 wlc_phy_env_measure_vbat(struct brcms_phy *pi)\r\n{\r\nif (ISLCNPHY(pi))\r\nreturn wlc_lcnphy_vbatsense(pi, 0);\r\nelse\r\nreturn 0;\r\n}\r\nstatic s8 wlc_phy_env_measure_temperature(struct brcms_phy *pi)\r\n{\r\nif (ISLCNPHY(pi))\r\nreturn wlc_lcnphy_tempsense_degree(pi, 0);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void wlc_phy_upd_env_txpwr_rate_limits(struct brcms_phy *pi, u32 band)\r\n{\r\nu8 i;\r\ns8 temp, vbat;\r\nfor (i = 0; i < TXP_NUM_RATES; i++)\r\npi->txpwr_env_limit[i] = BRCMS_TXPWR_MAX;\r\nvbat = wlc_phy_env_measure_vbat(pi);\r\ntemp = wlc_phy_env_measure_temperature(pi);\r\n}\r\nstatic s8\r\nwlc_user_txpwr_antport_to_rfport(struct brcms_phy *pi, uint chan, u32 band,\r\nu8 rate)\r\n{\r\ns8 offset = 0;\r\nif (!pi->user_txpwr_at_rfport)\r\nreturn offset;\r\nreturn offset;\r\n}\r\nvoid wlc_phy_txpower_recalc_target(struct brcms_phy *pi)\r\n{\r\nu8 maxtxpwr, mintxpwr, rate, pactrl;\r\nuint target_chan;\r\nu8 tx_pwr_target[TXP_NUM_RATES];\r\nu8 tx_pwr_max = 0;\r\nu8 tx_pwr_min = 255;\r\nu8 tx_pwr_max_rate_ind = 0;\r\nu8 max_num_rate;\r\nu8 start_rate = 0;\r\nu16 chspec;\r\nu32 band = CHSPEC2BAND(pi->radio_chanspec);\r\nvoid (*txpwr_recalc_fn)(struct brcms_phy *) = NULL;\r\nchspec = pi->radio_chanspec;\r\nif (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE)\r\ntarget_chan = CHSPEC_CHANNEL(chspec);\r\nelse if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_UPPER)\r\ntarget_chan = upper_20_sb(CHSPEC_CHANNEL(chspec));\r\nelse\r\ntarget_chan = lower_20_sb(CHSPEC_CHANNEL(chspec));\r\npactrl = 0;\r\nif (ISLCNPHY(pi)) {\r\nu32 offset_mcs, i;\r\nif (CHSPEC_IS40(pi->radio_chanspec)) {\r\noffset_mcs = pi->mcs40_po;\r\nfor (i = TXP_FIRST_SISO_MCS_20;\r\ni <= TXP_LAST_SISO_MCS_20; i++) {\r\npi->tx_srom_max_rate_2g[i - 8] =\r\npi->tx_srom_max_2g -\r\n((offset_mcs & 0xf) * 2);\r\noffset_mcs >>= 4;\r\n}\r\n} else {\r\noffset_mcs = pi->mcs20_po;\r\nfor (i = TXP_FIRST_SISO_MCS_20;\r\ni <= TXP_LAST_SISO_MCS_20; i++) {\r\npi->tx_srom_max_rate_2g[i - 8] =\r\npi->tx_srom_max_2g -\r\n((offset_mcs & 0xf) * 2);\r\noffset_mcs >>= 4;\r\n}\r\n}\r\n}\r\nmax_num_rate = ((ISNPHY(pi)) ? (TXP_NUM_RATES) :\r\n((ISLCNPHY(pi)) ?\r\n(TXP_LAST_SISO_MCS_20 + 1) : (TXP_LAST_OFDM + 1)));\r\nwlc_phy_upd_env_txpwr_rate_limits(pi, band);\r\nfor (rate = start_rate; rate < max_num_rate; rate++) {\r\ntx_pwr_target[rate] = pi->tx_user_target[rate];\r\nif (pi->user_txpwr_at_rfport)\r\ntx_pwr_target[rate] +=\r\nwlc_user_txpwr_antport_to_rfport(pi,\r\ntarget_chan,\r\nband,\r\nrate);\r\nwlc_phy_txpower_sromlimit((struct brcms_phy_pub *) pi,\r\ntarget_chan,\r\n&mintxpwr, &maxtxpwr, rate);\r\nmaxtxpwr = min(maxtxpwr, pi->txpwr_limit[rate]);\r\nmaxtxpwr = (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;\r\nmaxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;\r\nmaxtxpwr = min(maxtxpwr, tx_pwr_target[rate]);\r\nif (pi->txpwr_percent <= 100)\r\nmaxtxpwr = (maxtxpwr * pi->txpwr_percent) / 100;\r\ntx_pwr_target[rate] = max(maxtxpwr, mintxpwr);\r\ntx_pwr_target[rate] =\r\nmin(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);\r\nif (tx_pwr_target[rate] > tx_pwr_max)\r\ntx_pwr_max_rate_ind = rate;\r\ntx_pwr_max = max(tx_pwr_max, tx_pwr_target[rate]);\r\ntx_pwr_min = min(tx_pwr_min, tx_pwr_target[rate]);\r\n}\r\nmemset(pi->tx_power_offset, 0, sizeof(pi->tx_power_offset));\r\npi->tx_power_max = tx_pwr_max;\r\npi->tx_power_min = tx_pwr_min;\r\npi->tx_power_max_rate_ind = tx_pwr_max_rate_ind;\r\nfor (rate = 0; rate < max_num_rate; rate++) {\r\npi->tx_power_target[rate] = tx_pwr_target[rate];\r\nif (!pi->hwpwrctrl || ISNPHY(pi))\r\npi->tx_power_offset[rate] =\r\npi->tx_power_max - pi->tx_power_target[rate];\r\nelse\r\npi->tx_power_offset[rate] =\r\npi->tx_power_target[rate] - pi->tx_power_min;\r\n}\r\ntxpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;\r\nif (txpwr_recalc_fn)\r\n(*txpwr_recalc_fn)(pi);\r\n}\r\nstatic void\r\nwlc_phy_txpower_reg_limit_calc(struct brcms_phy *pi, struct txpwr_limits *txpwr,\r\nu16 chanspec)\r\n{\r\nu8 tmp_txpwr_limit[2 * BRCMS_NUM_RATES_OFDM];\r\nu8 *txpwr_ptr1 = NULL, *txpwr_ptr2 = NULL;\r\nint rate_start_index = 0, rate1, rate2, k;\r\nfor (rate1 = WL_TX_POWER_CCK_FIRST, rate2 = 0;\r\nrate2 < WL_TX_POWER_CCK_NUM; rate1++, rate2++)\r\npi->txpwr_limit[rate1] = txpwr->cck[rate2];\r\nfor (rate1 = WL_TX_POWER_OFDM_FIRST, rate2 = 0;\r\nrate2 < WL_TX_POWER_OFDM_NUM; rate1++, rate2++)\r\npi->txpwr_limit[rate1] = txpwr->ofdm[rate2];\r\nif (ISNPHY(pi)) {\r\nfor (k = 0; k < 4; k++) {\r\nswitch (k) {\r\ncase 0:\r\ntxpwr_ptr1 = txpwr->mcs_20_siso;\r\ntxpwr_ptr2 = txpwr->ofdm;\r\nrate_start_index = WL_TX_POWER_OFDM_FIRST;\r\nbreak;\r\ncase 1:\r\ntxpwr_ptr1 = txpwr->mcs_20_cdd;\r\ntxpwr_ptr2 = txpwr->ofdm_cdd;\r\nrate_start_index = WL_TX_POWER_OFDM20_CDD_FIRST;\r\nbreak;\r\ncase 2:\r\ntxpwr_ptr1 = txpwr->mcs_40_siso;\r\ntxpwr_ptr2 = txpwr->ofdm_40_siso;\r\nrate_start_index =\r\nWL_TX_POWER_OFDM40_SISO_FIRST;\r\nbreak;\r\ncase 3:\r\ntxpwr_ptr1 = txpwr->mcs_40_cdd;\r\ntxpwr_ptr2 = txpwr->ofdm_40_cdd;\r\nrate_start_index = WL_TX_POWER_OFDM40_CDD_FIRST;\r\nbreak;\r\n}\r\nfor (rate2 = 0; rate2 < BRCMS_NUM_RATES_OFDM;\r\nrate2++) {\r\ntmp_txpwr_limit[rate2] = 0;\r\ntmp_txpwr_limit[BRCMS_NUM_RATES_OFDM + rate2] =\r\ntxpwr_ptr1[rate2];\r\n}\r\nwlc_phy_mcs_to_ofdm_powers_nphy(\r\ntmp_txpwr_limit, 0,\r\nBRCMS_NUM_RATES_OFDM -\r\n1, BRCMS_NUM_RATES_OFDM);\r\nfor (rate1 = rate_start_index, rate2 = 0;\r\nrate2 < BRCMS_NUM_RATES_OFDM; rate1++, rate2++)\r\npi->txpwr_limit[rate1] =\r\nmin(txpwr_ptr2[rate2],\r\ntmp_txpwr_limit[rate2]);\r\n}\r\nfor (k = 0; k < 4; k++) {\r\nswitch (k) {\r\ncase 0:\r\ntxpwr_ptr1 = txpwr->ofdm;\r\ntxpwr_ptr2 = txpwr->mcs_20_siso;\r\nrate_start_index = WL_TX_POWER_MCS20_SISO_FIRST;\r\nbreak;\r\ncase 1:\r\ntxpwr_ptr1 = txpwr->ofdm_cdd;\r\ntxpwr_ptr2 = txpwr->mcs_20_cdd;\r\nrate_start_index = WL_TX_POWER_MCS20_CDD_FIRST;\r\nbreak;\r\ncase 2:\r\ntxpwr_ptr1 = txpwr->ofdm_40_siso;\r\ntxpwr_ptr2 = txpwr->mcs_40_siso;\r\nrate_start_index = WL_TX_POWER_MCS40_SISO_FIRST;\r\nbreak;\r\ncase 3:\r\ntxpwr_ptr1 = txpwr->ofdm_40_cdd;\r\ntxpwr_ptr2 = txpwr->mcs_40_cdd;\r\nrate_start_index = WL_TX_POWER_MCS40_CDD_FIRST;\r\nbreak;\r\n}\r\nfor (rate2 = 0; rate2 < BRCMS_NUM_RATES_OFDM;\r\nrate2++) {\r\ntmp_txpwr_limit[rate2] = 0;\r\ntmp_txpwr_limit[BRCMS_NUM_RATES_OFDM + rate2] =\r\ntxpwr_ptr1[rate2];\r\n}\r\nwlc_phy_ofdm_to_mcs_powers_nphy(\r\ntmp_txpwr_limit, 0,\r\nBRCMS_NUM_RATES_OFDM -\r\n1, BRCMS_NUM_RATES_OFDM);\r\nfor (rate1 = rate_start_index, rate2 = 0;\r\nrate2 < BRCMS_NUM_RATES_MCS_1_STREAM;\r\nrate1++, rate2++)\r\npi->txpwr_limit[rate1] =\r\nmin(txpwr_ptr2[rate2],\r\ntmp_txpwr_limit[rate2]);\r\n}\r\nfor (k = 0; k < 2; k++) {\r\nswitch (k) {\r\ncase 0:\r\nrate_start_index = WL_TX_POWER_MCS20_STBC_FIRST;\r\ntxpwr_ptr1 = txpwr->mcs_20_stbc;\r\nbreak;\r\ncase 1:\r\nrate_start_index = WL_TX_POWER_MCS40_STBC_FIRST;\r\ntxpwr_ptr1 = txpwr->mcs_40_stbc;\r\nbreak;\r\n}\r\nfor (rate1 = rate_start_index, rate2 = 0;\r\nrate2 < BRCMS_NUM_RATES_MCS_1_STREAM;\r\nrate1++, rate2++)\r\npi->txpwr_limit[rate1] = txpwr_ptr1[rate2];\r\n}\r\nfor (k = 0; k < 2; k++) {\r\nswitch (k) {\r\ncase 0:\r\nrate_start_index = WL_TX_POWER_MCS20_SDM_FIRST;\r\ntxpwr_ptr1 = txpwr->mcs_20_mimo;\r\nbreak;\r\ncase 1:\r\nrate_start_index = WL_TX_POWER_MCS40_SDM_FIRST;\r\ntxpwr_ptr1 = txpwr->mcs_40_mimo;\r\nbreak;\r\n}\r\nfor (rate1 = rate_start_index, rate2 = 0;\r\nrate2 < BRCMS_NUM_RATES_MCS_2_STREAM;\r\nrate1++, rate2++)\r\npi->txpwr_limit[rate1] = txpwr_ptr1[rate2];\r\n}\r\npi->txpwr_limit[WL_TX_POWER_MCS_32] = txpwr->mcs32;\r\npi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST] =\r\nmin(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],\r\npi->txpwr_limit[WL_TX_POWER_MCS_32]);\r\npi->txpwr_limit[WL_TX_POWER_MCS_32] =\r\npi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST];\r\n}\r\n}\r\nvoid wlc_phy_txpwr_percent_set(struct brcms_phy_pub *ppi, u8 txpwr_percent)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->txpwr_percent = txpwr_percent;\r\n}\r\nvoid wlc_phy_machwcap_set(struct brcms_phy_pub *ppi, u32 machwcap)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->sh->machwcap = machwcap;\r\n}\r\nvoid wlc_phy_runbist_config(struct brcms_phy_pub *ppi, bool start_end)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nu16 rxc;\r\nrxc = 0;\r\nif (start_end == ON) {\r\nif (!ISNPHY(pi))\r\nreturn;\r\nif (NREV_IS(pi->pubpi.phy_rev, 3)\r\n|| NREV_IS(pi->pubpi.phy_rev, 4)) {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr),\r\n0xa0);\r\nbcma_set16(pi->d11core, D11REGOFFS(phyregdata),\r\n0x1 << 15);\r\n}\r\n} else {\r\nif (NREV_IS(pi->pubpi.phy_rev, 3)\r\n|| NREV_IS(pi->pubpi.phy_rev, 4)) {\r\nbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr),\r\n0xa0);\r\nbcma_write16(pi->d11core, D11REGOFFS(phyregdata), rxc);\r\n}\r\nwlc_phy_por_inform(ppi);\r\n}\r\n}\r\nvoid\r\nwlc_phy_txpower_limit_set(struct brcms_phy_pub *ppi, struct txpwr_limits *txpwr,\r\nu16 chanspec)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nwlc_phy_txpower_reg_limit_calc(pi, txpwr, chanspec);\r\nif (ISLCNPHY(pi)) {\r\nint i, j;\r\nfor (i = TXP_FIRST_OFDM_20_CDD, j = 0;\r\nj < BRCMS_NUM_RATES_MCS_1_STREAM; i++, j++) {\r\nif (txpwr->mcs_20_siso[j])\r\npi->txpwr_limit[i] = txpwr->mcs_20_siso[j];\r\nelse\r\npi->txpwr_limit[i] = txpwr->ofdm[j];\r\n}\r\n}\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nwlc_phy_txpower_recalc_target(pi);\r\nwlc_phy_cal_txpower_recalc_sw(pi);\r\nwlapi_enable_mac(pi->sh->physhim);\r\n}\r\nvoid wlc_phy_ofdm_rateset_war(struct brcms_phy_pub *pih, bool war)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\npi->ofdm_rateset_war = war;\r\n}\r\nvoid wlc_phy_bf_preempt_enable(struct brcms_phy_pub *pih, bool bf_preempt)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\npi->bf_preempt_4306 = bf_preempt;\r\n}\r\nvoid wlc_phy_txpower_update_shm(struct brcms_phy *pi)\r\n{\r\nint j;\r\nif (ISNPHY(pi))\r\nreturn;\r\nif (!pi->sh->clk)\r\nreturn;\r\nif (pi->hwpwrctrl) {\r\nu16 offset;\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_MAX, 63);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_N,\r\n1 << NUM_TSSI_FRAMES);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_TARGET,\r\npi->tx_power_min << NUM_TSSI_FRAMES);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_CUR,\r\npi->hwpwr_txcur);\r\nfor (j = TXP_FIRST_OFDM; j <= TXP_LAST_OFDM; j++) {\r\nconst u8 ucode_ofdm_rates[] = {\r\n0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c\r\n};\r\noffset = wlapi_bmac_rate_shm_offset(\r\npi->sh->physhim,\r\nucode_ofdm_rates[j - TXP_FIRST_OFDM]);\r\nwlapi_bmac_write_shm(pi->sh->physhim, offset + 6,\r\npi->tx_power_offset[j]);\r\nwlapi_bmac_write_shm(pi->sh->physhim, offset + 14,\r\n-(pi->tx_power_offset[j] / 2));\r\n}\r\nwlapi_bmac_mhf(pi->sh->physhim, MHF2, MHF2_HWPWRCTL,\r\nMHF2_HWPWRCTL, BRCM_BAND_ALL);\r\n} else {\r\nint i;\r\nfor (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++)\r\npi->tx_power_offset[i] =\r\n(u8) roundup(pi->tx_power_offset[i], 8);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,\r\n(u16)\r\n((pi->tx_power_offset[TXP_FIRST_OFDM]\r\n+ 7) >> 3));\r\n}\r\n}\r\nbool wlc_phy_txpower_hw_ctrl_get(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nif (ISNPHY(pi))\r\nreturn pi->nphy_txpwrctrl;\r\nelse\r\nreturn pi->hwpwrctrl;\r\n}\r\nvoid wlc_phy_txpower_hw_ctrl_set(struct brcms_phy_pub *ppi, bool hwpwrctrl)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nbool suspend;\r\nif (!pi->hwpwrctrl_capable)\r\nreturn;\r\npi->hwpwrctrl = hwpwrctrl;\r\npi->nphy_txpwrctrl = hwpwrctrl;\r\npi->txpwrctrl = hwpwrctrl;\r\nif (ISNPHY(pi)) {\r\nsuspend = (0 == (bcma_read32(pi->d11core,\r\nD11REGOFFS(maccontrol)) &\r\nMCTL_EN_MAC));\r\nif (!suspend)\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nwlc_phy_txpwrctrl_enable_nphy(pi, pi->nphy_txpwrctrl);\r\nif (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF)\r\nwlc_phy_txpwr_fixpower_nphy(pi);\r\nelse\r\nmod_phy_reg(pi, 0x1e7, (0x7f << 0),\r\npi->saved_txpwr_idx);\r\nif (!suspend)\r\nwlapi_enable_mac(pi->sh->physhim);\r\n}\r\n}\r\nvoid wlc_phy_txpower_ipa_upd(struct brcms_phy *pi)\r\n{\r\nif (NREV_GE(pi->pubpi.phy_rev, 3)) {\r\npi->ipa2g_on = (pi->srom_fem2g.extpagain == 2);\r\npi->ipa5g_on = (pi->srom_fem5g.extpagain == 2);\r\n} else {\r\npi->ipa2g_on = false;\r\npi->ipa5g_on = false;\r\n}\r\n}\r\nstatic u32 wlc_phy_txpower_est_power_nphy(struct brcms_phy *pi)\r\n{\r\ns16 tx0_status, tx1_status;\r\nu16 estPower1, estPower2;\r\nu8 pwr0, pwr1, adj_pwr0, adj_pwr1;\r\nu32 est_pwr;\r\nestPower1 = read_phy_reg(pi, 0x118);\r\nestPower2 = read_phy_reg(pi, 0x119);\r\nif ((estPower1 & (0x1 << 8)) == (0x1 << 8))\r\npwr0 = (u8) (estPower1 & (0xff << 0)) >> 0;\r\nelse\r\npwr0 = 0x80;\r\nif ((estPower2 & (0x1 << 8)) == (0x1 << 8))\r\npwr1 = (u8) (estPower2 & (0xff << 0)) >> 0;\r\nelse\r\npwr1 = 0x80;\r\ntx0_status = read_phy_reg(pi, 0x1ed);\r\ntx1_status = read_phy_reg(pi, 0x1ee);\r\nif ((tx0_status & (0x1 << 15)) == (0x1 << 15))\r\nadj_pwr0 = (u8) (tx0_status & (0xff << 0)) >> 0;\r\nelse\r\nadj_pwr0 = 0x80;\r\nif ((tx1_status & (0x1 << 15)) == (0x1 << 15))\r\nadj_pwr1 = (u8) (tx1_status & (0xff << 0)) >> 0;\r\nelse\r\nadj_pwr1 = 0x80;\r\nest_pwr = (u32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) |\r\nadj_pwr1);\r\nreturn est_pwr;\r\n}\r\nvoid\r\nwlc_phy_txpower_get_current(struct brcms_phy_pub *ppi, struct tx_power *power,\r\nuint channel)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nuint rate, num_rates;\r\nu8 min_pwr, max_pwr;\r\n#if WL_TX_POWER_RATES != TXP_NUM_RATES\r\n#error "struct tx_power out of sync with this fn"\r\n#endif\r\nif (ISNPHY(pi)) {\r\npower->rf_cores = 2;\r\npower->flags |= (WL_TX_POWER_F_MIMO);\r\nif (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)\r\npower->flags |=\r\n(WL_TX_POWER_F_ENABLED | WL_TX_POWER_F_HW);\r\n} else if (ISLCNPHY(pi)) {\r\npower->rf_cores = 1;\r\npower->flags |= (WL_TX_POWER_F_SISO);\r\nif (pi->radiopwr_override == RADIOPWR_OVERRIDE_DEF)\r\npower->flags |= WL_TX_POWER_F_ENABLED;\r\nif (pi->hwpwrctrl)\r\npower->flags |= WL_TX_POWER_F_HW;\r\n}\r\nnum_rates = ((ISNPHY(pi)) ? (TXP_NUM_RATES) :\r\n((ISLCNPHY(pi)) ?\r\n(TXP_LAST_OFDM_20_CDD + 1) : (TXP_LAST_OFDM + 1)));\r\nfor (rate = 0; rate < num_rates; rate++) {\r\npower->user_limit[rate] = pi->tx_user_target[rate];\r\nwlc_phy_txpower_sromlimit(ppi, channel, &min_pwr, &max_pwr,\r\nrate);\r\npower->board_limit[rate] = (u8) max_pwr;\r\npower->target[rate] = pi->tx_power_target[rate];\r\n}\r\nif (ISNPHY(pi)) {\r\nu32 est_pout;\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nwlc_phyreg_enter((struct brcms_phy_pub *) pi);\r\nest_pout = wlc_phy_txpower_est_power_nphy(pi);\r\nwlc_phyreg_exit((struct brcms_phy_pub *) pi);\r\nwlapi_enable_mac(pi->sh->physhim);\r\npower->est_Pout[0] = (est_pout >> 8) & 0xff;\r\npower->est_Pout[1] = est_pout & 0xff;\r\npower->est_Pout_act[0] = est_pout >> 24;\r\npower->est_Pout_act[1] = (est_pout >> 16) & 0xff;\r\nif (power->est_Pout[0] == 0x80)\r\npower->est_Pout[0] = 0;\r\nif (power->est_Pout[1] == 0x80)\r\npower->est_Pout[1] = 0;\r\nif (power->est_Pout_act[0] == 0x80)\r\npower->est_Pout_act[0] = 0;\r\nif (power->est_Pout_act[1] == 0x80)\r\npower->est_Pout_act[1] = 0;\r\npower->est_Pout_cck = 0;\r\npower->tx_power_max[0] = pi->tx_power_max;\r\npower->tx_power_max[1] = pi->tx_power_max;\r\npower->tx_power_max_rate_ind[0] = pi->tx_power_max_rate_ind;\r\npower->tx_power_max_rate_ind[1] = pi->tx_power_max_rate_ind;\r\n} else if (pi->hwpwrctrl && pi->sh->up) {\r\nwlc_phyreg_enter(ppi);\r\nif (ISLCNPHY(pi)) {\r\npower->tx_power_max[0] = pi->tx_power_max;\r\npower->tx_power_max[1] = pi->tx_power_max;\r\npower->tx_power_max_rate_ind[0] =\r\npi->tx_power_max_rate_ind;\r\npower->tx_power_max_rate_ind[1] =\r\npi->tx_power_max_rate_ind;\r\nif (wlc_phy_tpc_isenabled_lcnphy(pi))\r\npower->flags |=\r\n(WL_TX_POWER_F_HW |\r\nWL_TX_POWER_F_ENABLED);\r\nelse\r\npower->flags &=\r\n~(WL_TX_POWER_F_HW |\r\nWL_TX_POWER_F_ENABLED);\r\nwlc_lcnphy_get_tssi(pi, (s8 *) &power->est_Pout[0],\r\n(s8 *) &power->est_Pout_cck);\r\n}\r\nwlc_phyreg_exit(ppi);\r\n}\r\n}\r\nvoid wlc_phy_antsel_type_set(struct brcms_phy_pub *ppi, u8 antsel_type)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\npi->antsel_type = antsel_type;\r\n}\r\nbool wlc_phy_test_ison(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nreturn pi->phytest_on;\r\n}\r\nvoid wlc_phy_ant_rxdiv_set(struct brcms_phy_pub *ppi, u8 val)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nbool suspend;\r\npi->sh->rx_antdiv = val;\r\nif (!(ISNPHY(pi) && D11REV_IS(pi->sh->corerev, 16))) {\r\nif (val > ANT_RX_DIV_FORCE_1)\r\nwlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV,\r\nMHF1_ANTDIV, BRCM_BAND_ALL);\r\nelse\r\nwlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV, 0,\r\nBRCM_BAND_ALL);\r\n}\r\nif (ISNPHY(pi))\r\nreturn;\r\nif (!pi->sh->clk)\r\nreturn;\r\nsuspend = (0 == (bcma_read32(pi->d11core, D11REGOFFS(maccontrol)) &\r\nMCTL_EN_MAC));\r\nif (!suspend)\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nif (ISLCNPHY(pi)) {\r\nif (val > ANT_RX_DIV_FORCE_1) {\r\nmod_phy_reg(pi, 0x410, (0x1 << 1), 0x01 << 1);\r\nmod_phy_reg(pi, 0x410,\r\n(0x1 << 0),\r\n((ANT_RX_DIV_START_1 == val) ? 1 : 0) << 0);\r\n} else {\r\nmod_phy_reg(pi, 0x410, (0x1 << 1), 0x00 << 1);\r\nmod_phy_reg(pi, 0x410, (0x1 << 0), (u16) val << 0);\r\n}\r\n}\r\nif (!suspend)\r\nwlapi_enable_mac(pi->sh->physhim);\r\nreturn;\r\n}\r\nstatic bool\r\nwlc_phy_noise_calc_phy(struct brcms_phy *pi, u32 *cmplx_pwr, s8 *pwr_ant)\r\n{\r\ns8 cmplx_pwr_dbm[PHY_CORE_MAX];\r\nu8 i;\r\nmemset((u8 *) cmplx_pwr_dbm, 0, sizeof(cmplx_pwr_dbm));\r\nwlc_phy_compute_dB(cmplx_pwr, cmplx_pwr_dbm, pi->pubpi.phy_corenum);\r\nfor (i = 0; i < pi->pubpi.phy_corenum; i++) {\r\nif (NREV_GE(pi->pubpi.phy_rev, 3))\r\ncmplx_pwr_dbm[i] += (s8) PHY_NOISE_OFFSETFACT_4322;\r\nelse\r\ncmplx_pwr_dbm[i] += (s8) (16 - (15) * 3 - 70);\r\n}\r\nfor (i = 0; i < pi->pubpi.phy_corenum; i++) {\r\npi->nphy_noise_win[i][pi->nphy_noise_index] = cmplx_pwr_dbm[i];\r\npwr_ant[i] = cmplx_pwr_dbm[i];\r\n}\r\npi->nphy_noise_index =\r\nMODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);\r\nreturn true;\r\n}\r\nstatic void wlc_phy_noise_cb(struct brcms_phy *pi, u8 channel, s8 noise_dbm)\r\n{\r\nif (!pi->phynoise_state)\r\nreturn;\r\nif (pi->phynoise_state & PHY_NOISE_STATE_MON) {\r\nif (pi->phynoise_chan_watchdog == channel) {\r\npi->sh->phy_noise_window[pi->sh->phy_noise_index] =\r\nnoise_dbm;\r\npi->sh->phy_noise_index =\r\nMODINC(pi->sh->phy_noise_index, MA_WINDOW_SZ);\r\n}\r\npi->phynoise_state &= ~PHY_NOISE_STATE_MON;\r\n}\r\nif (pi->phynoise_state & PHY_NOISE_STATE_EXTERNAL)\r\npi->phynoise_state &= ~PHY_NOISE_STATE_EXTERNAL;\r\n}\r\nstatic s8 wlc_phy_noise_read_shmem(struct brcms_phy *pi)\r\n{\r\nu32 cmplx_pwr[PHY_CORE_MAX];\r\ns8 noise_dbm_ant[PHY_CORE_MAX];\r\nu16 lo, hi;\r\nu32 cmplx_pwr_tot = 0;\r\ns8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\r\nu8 idx, core;\r\nmemset((u8 *) cmplx_pwr, 0, sizeof(cmplx_pwr));\r\nmemset((u8 *) noise_dbm_ant, 0, sizeof(noise_dbm_ant));\r\nfor (idx = 0, core = 0; core < pi->pubpi.phy_corenum; idx += 2,\r\ncore++) {\r\nlo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(idx));\r\nhi = wlapi_bmac_read_shm(pi->sh->physhim,\r\nM_PWRIND_MAP(idx + 1));\r\ncmplx_pwr[core] = (hi << 16) + lo;\r\ncmplx_pwr_tot += cmplx_pwr[core];\r\nif (cmplx_pwr[core] == 0)\r\nnoise_dbm_ant[core] = PHY_NOISE_FIXED_VAL_NPHY;\r\nelse\r\ncmplx_pwr[core] >>= PHY_NOISE_SAMPLE_LOG_NUM_UCODE;\r\n}\r\nif (cmplx_pwr_tot != 0)\r\nwlc_phy_noise_calc_phy(pi, cmplx_pwr, noise_dbm_ant);\r\nfor (core = 0; core < pi->pubpi.phy_corenum; core++) {\r\npi->nphy_noise_win[core][pi->nphy_noise_index] =\r\nnoise_dbm_ant[core];\r\nif (noise_dbm_ant[core] > noise_dbm)\r\nnoise_dbm = noise_dbm_ant[core];\r\n}\r\npi->nphy_noise_index =\r\nMODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);\r\nreturn noise_dbm;\r\n}\r\nvoid wlc_phy_noise_sample_intr(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nu16 jssi_aux;\r\nu8 channel = 0;\r\ns8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\r\nif (ISLCNPHY(pi)) {\r\nu32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;\r\nu16 lo, hi;\r\ns32 pwr_offset_dB, gain_dB;\r\nu16 status_0, status_1;\r\njssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);\r\nchannel = jssi_aux & D11_CURCHANNEL_MAX;\r\nlo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP0);\r\nhi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP1);\r\ncmplx_pwr0 = (hi << 16) + lo;\r\nlo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP2);\r\nhi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP3);\r\ncmplx_pwr1 = (hi << 16) + lo;\r\ncmplx_pwr = (cmplx_pwr0 + cmplx_pwr1) >> 6;\r\nstatus_0 = 0x44;\r\nstatus_1 = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_0);\r\nif ((cmplx_pwr > 0 && cmplx_pwr < 500)\r\n&& ((status_1 & 0xc000) == 0x4000)) {\r\nwlc_phy_compute_dB(&cmplx_pwr, &noise_dbm,\r\npi->pubpi.phy_corenum);\r\npwr_offset_dB = (read_phy_reg(pi, 0x434) & 0xFF);\r\nif (pwr_offset_dB > 127)\r\npwr_offset_dB -= 256;\r\nnoise_dbm += (s8) (pwr_offset_dB - 30);\r\ngain_dB = (status_0 & 0x1ff);\r\nnoise_dbm -= (s8) (gain_dB);\r\n} else {\r\nnoise_dbm = PHY_NOISE_FIXED_VAL_LCNPHY;\r\n}\r\n} else if (ISNPHY(pi)) {\r\njssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);\r\nchannel = jssi_aux & D11_CURCHANNEL_MAX;\r\nnoise_dbm = wlc_phy_noise_read_shmem(pi);\r\n}\r\nwlc_phy_noise_cb(pi, channel, noise_dbm);\r\n}\r\nstatic void\r\nwlc_phy_noise_sample_request(struct brcms_phy_pub *pih, u8 reason, u8 ch)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\ns8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\r\nbool sampling_in_progress = (pi->phynoise_state != 0);\r\nbool wait_for_intr = true;\r\nswitch (reason) {\r\ncase PHY_NOISE_SAMPLE_MON:\r\npi->phynoise_chan_watchdog = ch;\r\npi->phynoise_state |= PHY_NOISE_STATE_MON;\r\nbreak;\r\ncase PHY_NOISE_SAMPLE_EXTERNAL:\r\npi->phynoise_state |= PHY_NOISE_STATE_EXTERNAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (sampling_in_progress)\r\nreturn;\r\npi->phynoise_now = pi->sh->now;\r\nif (pi->phy_fixed_noise) {\r\nif (ISNPHY(pi)) {\r\npi->nphy_noise_win[WL_ANT_IDX_1][pi->nphy_noise_index] =\r\nPHY_NOISE_FIXED_VAL_NPHY;\r\npi->nphy_noise_win[WL_ANT_IDX_2][pi->nphy_noise_index] =\r\nPHY_NOISE_FIXED_VAL_NPHY;\r\npi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,\r\nPHY_NOISE_WINDOW_SZ);\r\nnoise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\r\n} else {\r\nnoise_dbm = PHY_NOISE_FIXED_VAL;\r\n}\r\nwait_for_intr = false;\r\ngoto done;\r\n}\r\nif (ISLCNPHY(pi)) {\r\nif (!pi->phynoise_polling\r\n|| (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_0, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);\r\nbcma_set32(pi->d11core, D11REGOFFS(maccommand),\r\nMCMD_BG_NOISE);\r\n} else {\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nwlc_lcnphy_deaf_mode(pi, (bool) 0);\r\nnoise_dbm = (s8) wlc_lcnphy_rx_signal_power(pi, 20);\r\nwlc_lcnphy_deaf_mode(pi, (bool) 1);\r\nwlapi_enable_mac(pi->sh->physhim);\r\nwait_for_intr = false;\r\n}\r\n} else if (ISNPHY(pi)) {\r\nif (!pi->phynoise_polling\r\n|| (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);\r\nwlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);\r\nbcma_set32(pi->d11core, D11REGOFFS(maccommand),\r\nMCMD_BG_NOISE);\r\n} else {\r\nstruct phy_iq_est est[PHY_CORE_MAX];\r\nu32 cmplx_pwr[PHY_CORE_MAX];\r\ns8 noise_dbm_ant[PHY_CORE_MAX];\r\nu16 log_num_samps, num_samps, classif_state = 0;\r\nu8 wait_time = 32;\r\nu8 wait_crs = 0;\r\nu8 i;\r\nmemset((u8 *) est, 0, sizeof(est));\r\nmemset((u8 *) cmplx_pwr, 0, sizeof(cmplx_pwr));\r\nmemset((u8 *) noise_dbm_ant, 0, sizeof(noise_dbm_ant));\r\nlog_num_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;\r\nnum_samps = 1 << log_num_samps;\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nclassif_state = wlc_phy_classifier_nphy(pi, 0, 0);\r\nwlc_phy_classifier_nphy(pi, 3, 0);\r\nwlc_phy_rx_iq_est_nphy(pi, est, num_samps, wait_time,\r\nwait_crs);\r\nwlc_phy_classifier_nphy(pi, (0x7 << 0), classif_state);\r\nwlapi_enable_mac(pi->sh->physhim);\r\nfor (i = 0; i < pi->pubpi.phy_corenum; i++)\r\ncmplx_pwr[i] = (est[i].i_pwr + est[i].q_pwr) >>\r\nlog_num_samps;\r\nwlc_phy_noise_calc_phy(pi, cmplx_pwr, noise_dbm_ant);\r\nfor (i = 0; i < pi->pubpi.phy_corenum; i++) {\r\npi->nphy_noise_win[i][pi->nphy_noise_index] =\r\nnoise_dbm_ant[i];\r\nif (noise_dbm_ant[i] > noise_dbm)\r\nnoise_dbm = noise_dbm_ant[i];\r\n}\r\npi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,\r\nPHY_NOISE_WINDOW_SZ);\r\nwait_for_intr = false;\r\n}\r\n}\r\ndone:\r\nif (!wait_for_intr)\r\nwlc_phy_noise_cb(pi, ch, noise_dbm);\r\n}\r\nvoid wlc_phy_noise_sample_request_external(struct brcms_phy_pub *pih)\r\n{\r\nu8 channel;\r\nchannel = CHSPEC_CHANNEL(wlc_phy_chanspec_get(pih));\r\nwlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);\r\n}\r\nvoid wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_cmplx_pwr_dB, u8 core)\r\n{\r\nu8 msb, secondmsb, i;\r\nu32 tmp;\r\nfor (i = 0; i < core; i++) {\r\nsecondmsb = 0;\r\ntmp = cmplx_pwr[i];\r\nmsb = fls(tmp);\r\nif (msb)\r\nsecondmsb = (u8) ((tmp >> (--msb - 1)) & 1);\r\np_cmplx_pwr_dB[i] = (s8) (3 * msb + 2 * secondmsb);\r\n}\r\n}\r\nint wlc_phy_rssi_compute(struct brcms_phy_pub *pih,\r\nstruct d11rxhdr *rxh)\r\n{\r\nint rssi = rxh->PhyRxStatus_1 & PRXS1_JSSI_MASK;\r\nuint radioid = pih->radioid;\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif ((pi->sh->corerev >= 11)\r\n&& !(rxh->RxStatus2 & RXS_PHYRXST_VALID)) {\r\nrssi = BRCMS_RSSI_INVALID;\r\ngoto end;\r\n}\r\nif (ISLCNPHY(pi)) {\r\nu8 gidx = (rxh->PhyRxStatus_2 & 0xFC00) >> 10;\r\nstruct brcms_phy_lcnphy *pi_lcn = pi->u.pi_lcnphy;\r\nif (rssi > 127)\r\nrssi -= 256;\r\nrssi = rssi + lcnphy_gain_index_offset_for_pkt_rssi[gidx];\r\nif ((rssi > -46) && (gidx > 18))\r\nrssi = rssi + 7;\r\nrssi = rssi + pi_lcn->lcnphy_pkteng_rssi_slope;\r\nrssi = rssi + 2;\r\n}\r\nif (ISLCNPHY(pi)) {\r\nif (rssi > 127)\r\nrssi -= 256;\r\n} else if (radioid == BCM2055_ID || radioid == BCM2056_ID\r\n|| radioid == BCM2057_ID) {\r\nrssi = wlc_phy_rssi_compute_nphy(pi, rxh);\r\n}\r\nend:\r\nreturn rssi;\r\n}\r\nvoid wlc_phy_freqtrack_start(struct brcms_phy_pub *pih)\r\n{\r\nreturn;\r\n}\r\nvoid wlc_phy_freqtrack_end(struct brcms_phy_pub *pih)\r\n{\r\nreturn;\r\n}\r\nvoid wlc_phy_set_deaf(struct brcms_phy_pub *ppi, bool user_flag)\r\n{\r\nstruct brcms_phy *pi;\r\npi = (struct brcms_phy *) ppi;\r\nif (ISLCNPHY(pi))\r\nwlc_lcnphy_deaf_mode(pi, true);\r\nelse if (ISNPHY(pi))\r\nwlc_nphy_deaf_mode(pi, true);\r\n}\r\nvoid wlc_phy_watchdog(struct brcms_phy_pub *pih)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nbool delay_phy_cal = false;\r\npi->sh->now++;\r\nif (!pi->watchdog_override)\r\nreturn;\r\nif (!(SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)))\r\nwlc_phy_noise_sample_request((struct brcms_phy_pub *) pi,\r\nPHY_NOISE_SAMPLE_MON,\r\nCHSPEC_CHANNEL(pi->\r\nradio_chanspec));\r\nif (pi->phynoise_state && (pi->sh->now - pi->phynoise_now) > 5)\r\npi->phynoise_state = 0;\r\nif ((!pi->phycal_txpower) ||\r\n((pi->sh->now - pi->phycal_txpower) >= pi->sh->fast_timer)) {\r\nif (!SCAN_INPROG_PHY(pi) && wlc_phy_cal_txpower_recalc_sw(pi))\r\npi->phycal_txpower = pi->sh->now;\r\n}\r\nif ((SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)\r\n|| ASSOC_INPROG_PHY(pi)))\r\nreturn;\r\nif (ISNPHY(pi) && !pi->disable_percal && !delay_phy_cal) {\r\nif ((pi->nphy_perical != PHY_PERICAL_DISABLE) &&\r\n(pi->nphy_perical != PHY_PERICAL_MANUAL) &&\r\n((pi->sh->now - pi->nphy_perical_last) >=\r\npi->sh->glacial_timer))\r\nwlc_phy_cal_perical((struct brcms_phy_pub *) pi,\r\nPHY_PERICAL_WATCHDOG);\r\nwlc_phy_txpwr_papd_cal_nphy(pi);\r\n}\r\nif (ISLCNPHY(pi)) {\r\nif (pi->phy_forcecal ||\r\n((pi->sh->now - pi->phy_lastcal) >=\r\npi->sh->glacial_timer)) {\r\nif (!(SCAN_RM_IN_PROGRESS(pi) || ASSOC_INPROG_PHY(pi)))\r\nwlc_lcnphy_calib_modes(\r\npi,\r\nLCNPHY_PERICAL_TEMPBASED_TXPWRCTRL);\r\nif (!\r\n(SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)\r\n|| ASSOC_INPROG_PHY(pi)\r\n|| pi->carrier_suppr_disable\r\n|| pi->disable_percal))\r\nwlc_lcnphy_calib_modes(pi,\r\nPHY_PERICAL_WATCHDOG);\r\n}\r\n}\r\n}\r\nvoid wlc_phy_BSSinit(struct brcms_phy_pub *pih, bool bonlyap, int rssi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nuint i;\r\nuint k;\r\nfor (i = 0; i < MA_WINDOW_SZ; i++)\r\npi->sh->phy_noise_window[i] = (s8) (rssi & 0xff);\r\nif (ISLCNPHY(pi)) {\r\nfor (i = 0; i < MA_WINDOW_SZ; i++)\r\npi->sh->phy_noise_window[i] =\r\nPHY_NOISE_FIXED_VAL_LCNPHY;\r\n}\r\npi->sh->phy_noise_index = 0;\r\nfor (i = 0; i < PHY_NOISE_WINDOW_SZ; i++) {\r\nfor (k = WL_ANT_IDX_1; k < WL_ANT_RX_MAX; k++)\r\npi->nphy_noise_win[k][i] = PHY_NOISE_FIXED_VAL_NPHY;\r\n}\r\npi->nphy_noise_index = 0;\r\n}\r\nvoid\r\nwlc_phy_papd_decode_epsilon(u32 epsilon, s32 *eps_real, s32 *eps_imag)\r\n{\r\n*eps_imag = (epsilon >> 13);\r\nif (*eps_imag > 0xfff)\r\n*eps_imag -= 0x2000;\r\n*eps_real = (epsilon & 0x1fff);\r\nif (*eps_real > 0xfff)\r\n*eps_real -= 0x2000;\r\n}\r\nvoid wlc_phy_cal_perical_mphase_reset(struct brcms_phy *pi)\r\n{\r\nwlapi_del_timer(pi->phycal_timer);\r\npi->cal_type_override = PHY_PERICAL_AUTO;\r\npi->mphase_cal_phase_id = MPHASE_CAL_STATE_IDLE;\r\npi->mphase_txcal_cmdidx = 0;\r\n}\r\nstatic void\r\nwlc_phy_cal_perical_mphase_schedule(struct brcms_phy *pi, uint delay)\r\n{\r\nif ((pi->nphy_perical != PHY_PERICAL_MPHASE) &&\r\n(pi->nphy_perical != PHY_PERICAL_MANUAL))\r\nreturn;\r\nwlapi_del_timer(pi->phycal_timer);\r\npi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;\r\nwlapi_add_timer(pi->phycal_timer, delay, 0);\r\n}\r\nvoid wlc_phy_cal_perical(struct brcms_phy_pub *pih, u8 reason)\r\n{\r\ns16 nphy_currtemp = 0;\r\ns16 delta_temp = 0;\r\nbool do_periodic_cal = true;\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nif (!ISNPHY(pi))\r\nreturn;\r\nif ((pi->nphy_perical == PHY_PERICAL_DISABLE) ||\r\n(pi->nphy_perical == PHY_PERICAL_MANUAL))\r\nreturn;\r\nswitch (reason) {\r\ncase PHY_PERICAL_DRIVERUP:\r\nbreak;\r\ncase PHY_PERICAL_PHYINIT:\r\nif (pi->nphy_perical == PHY_PERICAL_MPHASE) {\r\nif (PHY_PERICAL_MPHASE_PENDING(pi))\r\nwlc_phy_cal_perical_mphase_reset(pi);\r\nwlc_phy_cal_perical_mphase_schedule(\r\npi,\r\nPHY_PERICAL_INIT_DELAY);\r\n}\r\nbreak;\r\ncase PHY_PERICAL_JOIN_BSS:\r\ncase PHY_PERICAL_START_IBSS:\r\ncase PHY_PERICAL_UP_BSS:\r\nif ((pi->nphy_perical == PHY_PERICAL_MPHASE) &&\r\nPHY_PERICAL_MPHASE_PENDING(pi))\r\nwlc_phy_cal_perical_mphase_reset(pi);\r\npi->first_cal_after_assoc = true;\r\npi->cal_type_override = PHY_PERICAL_FULL;\r\nif (pi->phycal_tempdelta)\r\npi->nphy_lastcal_temp = wlc_phy_tempsense_nphy(pi);\r\nwlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_FULL);\r\nbreak;\r\ncase PHY_PERICAL_WATCHDOG:\r\nif (pi->phycal_tempdelta) {\r\nnphy_currtemp = wlc_phy_tempsense_nphy(pi);\r\ndelta_temp =\r\n(nphy_currtemp > pi->nphy_lastcal_temp) ?\r\nnphy_currtemp - pi->nphy_lastcal_temp :\r\npi->nphy_lastcal_temp - nphy_currtemp;\r\nif ((delta_temp < (s16) pi->phycal_tempdelta) &&\r\n(pi->nphy_txiqlocal_chanspec ==\r\npi->radio_chanspec))\r\ndo_periodic_cal = false;\r\nelse\r\npi->nphy_lastcal_temp = nphy_currtemp;\r\n}\r\nif (do_periodic_cal) {\r\nif (pi->nphy_perical == PHY_PERICAL_MPHASE) {\r\nif (!PHY_PERICAL_MPHASE_PENDING(pi))\r\nwlc_phy_cal_perical_mphase_schedule(\r\npi,\r\nPHY_PERICAL_WDOG_DELAY);\r\n} else if (pi->nphy_perical == PHY_PERICAL_SPHASE)\r\nwlc_phy_cal_perical_nphy_run(pi,\r\nPHY_PERICAL_AUTO);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid wlc_phy_cal_perical_mphase_restart(struct brcms_phy *pi)\r\n{\r\npi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;\r\npi->mphase_txcal_cmdidx = 0;\r\n}\r\nu8 wlc_phy_nbits(s32 value)\r\n{\r\ns32 abs_val;\r\nu8 nbits = 0;\r\nabs_val = abs(value);\r\nwhile ((abs_val >> nbits) > 0)\r\nnbits++;\r\nreturn nbits;\r\n}\r\nvoid wlc_phy_stf_chain_init(struct brcms_phy_pub *pih, u8 txchain, u8 rxchain)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\npi->sh->hw_phytxchain = txchain;\r\npi->sh->hw_phyrxchain = rxchain;\r\npi->sh->phytxchain = txchain;\r\npi->sh->phyrxchain = rxchain;\r\npi->pubpi.phy_corenum = (u8)hweight8(pi->sh->phyrxchain);\r\n}\r\nvoid wlc_phy_stf_chain_set(struct brcms_phy_pub *pih, u8 txchain, u8 rxchain)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\npi->sh->phytxchain = txchain;\r\nif (ISNPHY(pi))\r\nwlc_phy_rxcore_setstate_nphy(pih, rxchain);\r\npi->pubpi.phy_corenum = (u8)hweight8(pi->sh->phyrxchain);\r\n}\r\nvoid wlc_phy_stf_chain_get(struct brcms_phy_pub *pih, u8 *txchain, u8 *rxchain)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\n*txchain = pi->sh->phytxchain;\r\n*rxchain = pi->sh->phyrxchain;\r\n}\r\nu8 wlc_phy_stf_chain_active_get(struct brcms_phy_pub *pih)\r\n{\r\ns16 nphy_currtemp;\r\nu8 active_bitmap;\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nactive_bitmap = (pi->phy_txcore_heatedup) ? 0x31 : 0x33;\r\nif (!pi->watchdog_override)\r\nreturn active_bitmap;\r\nif (NREV_GE(pi->pubpi.phy_rev, 6)) {\r\nwlapi_suspend_mac_and_wait(pi->sh->physhim);\r\nnphy_currtemp = wlc_phy_tempsense_nphy(pi);\r\nwlapi_enable_mac(pi->sh->physhim);\r\nif (!pi->phy_txcore_heatedup) {\r\nif (nphy_currtemp >= pi->phy_txcore_disable_temp) {\r\nactive_bitmap &= 0xFD;\r\npi->phy_txcore_heatedup = true;\r\n}\r\n} else {\r\nif (nphy_currtemp <= pi->phy_txcore_enable_temp) {\r\nactive_bitmap |= 0x2;\r\npi->phy_txcore_heatedup = false;\r\n}\r\n}\r\n}\r\nreturn active_bitmap;\r\n}\r\ns8 wlc_phy_stf_ssmode_get(struct brcms_phy_pub *pih, u16 chanspec)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) pih;\r\nu8 siso_mcs_id, cdd_mcs_id;\r\nsiso_mcs_id =\r\n(CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_SISO :\r\nTXP_FIRST_MCS_20_SISO;\r\ncdd_mcs_id =\r\n(CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_CDD :\r\nTXP_FIRST_MCS_20_CDD;\r\nif (pi->tx_power_target[siso_mcs_id] >\r\n(pi->tx_power_target[cdd_mcs_id] + 12))\r\nreturn PHY_TXC1_MODE_SISO;\r\nelse\r\nreturn PHY_TXC1_MODE_CDD;\r\n}\r\nconst u8 *wlc_phy_get_ofdm_rate_lookup(void)\r\n{\r\nreturn ofdm_rate_lookup;\r\n}\r\nvoid wlc_lcnphy_epa_switch(struct brcms_phy *pi, bool mode)\r\n{\r\nif ((pi->sh->chip == BCMA_CHIP_ID_BCM4313) &&\r\n(pi->sh->boardflags & BFL_FEM)) {\r\nif (mode) {\r\nu16 txant = 0;\r\ntxant = wlapi_bmac_get_txant(pi->sh->physhim);\r\nif (txant == 1) {\r\nmod_phy_reg(pi, 0x44d, (0x1 << 2), (1) << 2);\r\nmod_phy_reg(pi, 0x44c, (0x1 << 2), (1) << 2);\r\n}\r\nbcma_chipco_gpio_control(&pi->d11core->bus->drv_cc,\r\n0x0, 0x0);\r\nbcma_chipco_gpio_out(&pi->d11core->bus->drv_cc,\r\n~0x40, 0x40);\r\nbcma_chipco_gpio_outen(&pi->d11core->bus->drv_cc,\r\n~0x40, 0x40);\r\n} else {\r\nmod_phy_reg(pi, 0x44c, (0x1 << 2), (0) << 2);\r\nmod_phy_reg(pi, 0x44d, (0x1 << 2), (0) << 2);\r\nbcma_chipco_gpio_out(&pi->d11core->bus->drv_cc,\r\n~0x40, 0x00);\r\nbcma_chipco_gpio_outen(&pi->d11core->bus->drv_cc,\r\n~0x40, 0x00);\r\nbcma_chipco_gpio_control(&pi->d11core->bus->drv_cc,\r\n0x0, 0x40);\r\n}\r\n}\r\n}\r\nvoid wlc_phy_ldpc_override_set(struct brcms_phy_pub *ppi, bool ldpc)\r\n{\r\nreturn;\r\n}\r\nvoid\r\nwlc_phy_get_pwrdet_offsets(struct brcms_phy *pi, s8 *cckoffset, s8 *ofdmoffset)\r\n{\r\n*cckoffset = 0;\r\n*ofdmoffset = 0;\r\n}\r\ns8 wlc_phy_upd_rssi_offset(struct brcms_phy *pi, s8 rssi, u16 chanspec)\r\n{\r\nreturn rssi;\r\n}\r\nbool wlc_phy_txpower_ipa_ison(struct brcms_phy_pub *ppi)\r\n{\r\nstruct brcms_phy *pi = (struct brcms_phy *) ppi;\r\nif (ISNPHY(pi))\r\nreturn wlc_phy_n_txpower_ipa_ison(pi);\r\nelse\r\nreturn 0;\r\n}
