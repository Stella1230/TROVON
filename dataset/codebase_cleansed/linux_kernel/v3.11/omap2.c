static int omap_prefetch_enable(int cs, int fifo_th, int dma_mode,\r\nunsigned int u32_count, int is_write, struct omap_nand_info *info)\r\n{\r\nu32 val;\r\nif (fifo_th > PREFETCH_FIFOTHRESHOLD_MAX)\r\nreturn -1;\r\nif (readl(info->reg.gpmc_prefetch_control))\r\nreturn -EBUSY;\r\nwritel(u32_count, info->reg.gpmc_prefetch_config2);\r\nval = ((cs << PREFETCH_CONFIG1_CS_SHIFT) |\r\nPREFETCH_FIFOTHRESHOLD(fifo_th) | ENABLE_PREFETCH |\r\n(dma_mode << DMA_MPU_MODE_SHIFT) | (0x1 & is_write));\r\nwritel(val, info->reg.gpmc_prefetch_config1);\r\nwritel(0x1, info->reg.gpmc_prefetch_control);\r\nreturn 0;\r\n}\r\nstatic int omap_prefetch_reset(int cs, struct omap_nand_info *info)\r\n{\r\nu32 config1;\r\nconfig1 = readl(info->reg.gpmc_prefetch_config1);\r\nif (((config1 >> PREFETCH_CONFIG1_CS_SHIFT) & CS_MASK) != cs)\r\nreturn -EINVAL;\r\nwritel(0x0, info->reg.gpmc_prefetch_control);\r\nwritel(0x0, info->reg.gpmc_prefetch_config1);\r\nreturn 0;\r\n}\r\nstatic void omap_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nif (cmd != NAND_CMD_NONE) {\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, info->reg.gpmc_nand_command);\r\nelse if (ctrl & NAND_ALE)\r\nwriteb(cmd, info->reg.gpmc_nand_address);\r\nelse\r\nwriteb(cmd, info->reg.gpmc_nand_data);\r\n}\r\n}\r\nstatic void omap_read_buf8(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nioread8_rep(nand->IO_ADDR_R, buf, len);\r\n}\r\nstatic void omap_write_buf8(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nu_char *p = (u_char *)buf;\r\nu32 status = 0;\r\nwhile (len--) {\r\niowrite8(*p++, info->nand.IO_ADDR_W);\r\ndo {\r\nstatus = readl(info->reg.gpmc_status) &\r\nSTATUS_BUFF_EMPTY;\r\n} while (!status);\r\n}\r\n}\r\nstatic void omap_read_buf16(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nioread16_rep(nand->IO_ADDR_R, buf, len / 2);\r\n}\r\nstatic void omap_write_buf16(struct mtd_info *mtd, const u_char * buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nu16 *p = (u16 *) buf;\r\nu32 status = 0;\r\nlen >>= 1;\r\nwhile (len--) {\r\niowrite16(*p++, info->nand.IO_ADDR_W);\r\ndo {\r\nstatus = readl(info->reg.gpmc_status) &\r\nSTATUS_BUFF_EMPTY;\r\n} while (!status);\r\n}\r\n}\r\nstatic void omap_read_buf_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nuint32_t r_count = 0;\r\nint ret = 0;\r\nu32 *p = (u32 *)buf;\r\nif (len % 4) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, buf, len % 4);\r\nelse\r\nomap_read_buf8(mtd, buf, len % 4);\r\np = (u32 *) (buf + len % 4);\r\nlen -= len % 4;\r\n}\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x0, info);\r\nif (ret) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, (u_char *)p, len);\r\nelse\r\nomap_read_buf8(mtd, (u_char *)p, len);\r\n} else {\r\ndo {\r\nr_count = readl(info->reg.gpmc_prefetch_status);\r\nr_count = PREFETCH_STATUS_FIFO_CNT(r_count);\r\nr_count = r_count >> 2;\r\nioread32_rep(info->nand.IO_ADDR_R, p, r_count);\r\np += r_count;\r\nlen -= r_count << 2;\r\n} while (len);\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\n}\r\n}\r\nstatic void omap_write_buf_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nuint32_t w_count = 0;\r\nint i = 0, ret = 0;\r\nu16 *p = (u16 *)buf;\r\nunsigned long tim, limit;\r\nu32 val;\r\nif (len % 2 != 0) {\r\nwriteb(*buf, info->nand.IO_ADDR_W);\r\np = (u16 *)(buf + 1);\r\nlen--;\r\n}\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x1, info);\r\nif (ret) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_write_buf16(mtd, (u_char *)p, len);\r\nelse\r\nomap_write_buf8(mtd, (u_char *)p, len);\r\n} else {\r\nwhile (len) {\r\nw_count = readl(info->reg.gpmc_prefetch_status);\r\nw_count = PREFETCH_STATUS_FIFO_CNT(w_count);\r\nw_count = w_count >> 1;\r\nfor (i = 0; (i < w_count) && len; i++, len -= 2)\r\niowrite16(*p++, info->nand.IO_ADDR_W);\r\n}\r\ntim = 0;\r\nlimit = (loops_per_jiffy *\r\nmsecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\ndo {\r\ncpu_relax();\r\nval = readl(info->reg.gpmc_prefetch_status);\r\nval = PREFETCH_STATUS_COUNT(val);\r\n} while (val && (tim++ < limit));\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\n}\r\n}\r\nstatic void omap_nand_dma_callback(void *data)\r\n{\r\ncomplete((struct completion *) data);\r\n}\r\nstatic inline int omap_nand_dma_transfer(struct mtd_info *mtd, void *addr,\r\nunsigned int len, int is_write)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nstruct dma_async_tx_descriptor *tx;\r\nenum dma_data_direction dir = is_write ? DMA_TO_DEVICE :\r\nDMA_FROM_DEVICE;\r\nstruct scatterlist sg;\r\nunsigned long tim, limit;\r\nunsigned n;\r\nint ret;\r\nu32 val;\r\nif (addr >= high_memory) {\r\nstruct page *p1;\r\nif (((size_t)addr & PAGE_MASK) !=\r\n((size_t)(addr + len - 1) & PAGE_MASK))\r\ngoto out_copy;\r\np1 = vmalloc_to_page(addr);\r\nif (!p1)\r\ngoto out_copy;\r\naddr = page_address(p1) + ((size_t)addr & ~PAGE_MASK);\r\n}\r\nsg_init_one(&sg, addr, len);\r\nn = dma_map_sg(info->dma->device->dev, &sg, 1, dir);\r\nif (n == 0) {\r\ndev_err(&info->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n", len);\r\ngoto out_copy;\r\n}\r\ntx = dmaengine_prep_slave_sg(info->dma, &sg, n,\r\nis_write ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tx)\r\ngoto out_copy_unmap;\r\ntx->callback = omap_nand_dma_callback;\r\ntx->callback_param = &info->comp;\r\ndmaengine_submit(tx);\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x1, len, is_write, info);\r\nif (ret)\r\ngoto out_copy_unmap;\r\ninit_completion(&info->comp);\r\ndma_async_issue_pending(info->dma);\r\nwait_for_completion(&info->comp);\r\ntim = 0;\r\nlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\ndo {\r\ncpu_relax();\r\nval = readl(info->reg.gpmc_prefetch_status);\r\nval = PREFETCH_STATUS_COUNT(val);\r\n} while (val && (tim++ < limit));\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\ndma_unmap_sg(info->dma->device->dev, &sg, 1, dir);\r\nreturn 0;\r\nout_copy_unmap:\r\ndma_unmap_sg(info->dma->device->dev, &sg, 1, dir);\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nis_write == 0 ? omap_read_buf16(mtd, (u_char *) addr, len)\r\n: omap_write_buf16(mtd, (u_char *) addr, len);\r\nelse\r\nis_write == 0 ? omap_read_buf8(mtd, (u_char *) addr, len)\r\n: omap_write_buf8(mtd, (u_char *) addr, len);\r\nreturn 0;\r\n}\r\nstatic void omap_read_buf_dma_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nif (len <= mtd->oobsize)\r\nomap_read_buf_pref(mtd, buf, len);\r\nelse\r\nomap_nand_dma_transfer(mtd, buf, len, 0x0);\r\n}\r\nstatic void omap_write_buf_dma_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nif (len <= mtd->oobsize)\r\nomap_write_buf_pref(mtd, buf, len);\r\nelse\r\nomap_nand_dma_transfer(mtd, (u_char *) buf, len, 0x1);\r\n}\r\nstatic irqreturn_t omap_nand_irq(int this_irq, void *dev)\r\n{\r\nstruct omap_nand_info *info = (struct omap_nand_info *) dev;\r\nu32 bytes;\r\nbytes = readl(info->reg.gpmc_prefetch_status);\r\nbytes = PREFETCH_STATUS_FIFO_CNT(bytes);\r\nbytes = bytes & 0xFFFC;\r\nif (info->iomode == OMAP_NAND_IO_WRITE) {\r\nif (this_irq == info->gpmc_irq_count)\r\ngoto done;\r\nif (info->buf_len && (info->buf_len < bytes))\r\nbytes = info->buf_len;\r\nelse if (!info->buf_len)\r\nbytes = 0;\r\niowrite32_rep(info->nand.IO_ADDR_W,\r\n(u32 *)info->buf, bytes >> 2);\r\ninfo->buf = info->buf + bytes;\r\ninfo->buf_len -= bytes;\r\n} else {\r\nioread32_rep(info->nand.IO_ADDR_R,\r\n(u32 *)info->buf, bytes >> 2);\r\ninfo->buf = info->buf + bytes;\r\nif (this_irq == info->gpmc_irq_count)\r\ngoto done;\r\n}\r\nreturn IRQ_HANDLED;\r\ndone:\r\ncomplete(&info->comp);\r\ndisable_irq_nosync(info->gpmc_irq_fifo);\r\ndisable_irq_nosync(info->gpmc_irq_count);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void omap_read_buf_irq_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nint ret = 0;\r\nif (len <= mtd->oobsize) {\r\nomap_read_buf_pref(mtd, buf, len);\r\nreturn;\r\n}\r\ninfo->iomode = OMAP_NAND_IO_READ;\r\ninfo->buf = buf;\r\ninit_completion(&info->comp);\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX/2, 0x0, len, 0x0, info);\r\nif (ret)\r\ngoto out_copy;\r\ninfo->buf_len = len;\r\nenable_irq(info->gpmc_irq_count);\r\nenable_irq(info->gpmc_irq_fifo);\r\nwait_for_completion(&info->comp);\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\nreturn;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, buf, len);\r\nelse\r\nomap_read_buf8(mtd, buf, len);\r\n}\r\nstatic void omap_write_buf_irq_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nint ret = 0;\r\nunsigned long tim, limit;\r\nu32 val;\r\nif (len <= mtd->oobsize) {\r\nomap_write_buf_pref(mtd, buf, len);\r\nreturn;\r\n}\r\ninfo->iomode = OMAP_NAND_IO_WRITE;\r\ninfo->buf = (u_char *) buf;\r\ninit_completion(&info->comp);\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\n(PREFETCH_FIFOTHRESHOLD_MAX * 3) / 8, 0x0, len, 0x1, info);\r\nif (ret)\r\ngoto out_copy;\r\ninfo->buf_len = len;\r\nenable_irq(info->gpmc_irq_count);\r\nenable_irq(info->gpmc_irq_fifo);\r\nwait_for_completion(&info->comp);\r\ntim = 0;\r\nlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\ndo {\r\nval = readl(info->reg.gpmc_prefetch_status);\r\nval = PREFETCH_STATUS_COUNT(val);\r\ncpu_relax();\r\n} while (val && (tim++ < limit));\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\nreturn;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_write_buf16(mtd, buf, len);\r\nelse\r\nomap_write_buf8(mtd, buf, len);\r\n}\r\nstatic void gen_true_ecc(u8 *ecc_buf)\r\n{\r\nu32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) |\r\n((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);\r\necc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) |\r\nP16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp));\r\necc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) |\r\nP256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));\r\necc_buf[2] = ~(P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) |\r\nP1e(tmp) | P2048o(tmp) | P2048e(tmp));\r\n}\r\nstatic int omap_compare_ecc(u8 *ecc_data1,\r\nu8 *ecc_data2,\r\nu8 *page_data)\r\n{\r\nuint i;\r\nu8 tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];\r\nu8 comp0_bit[8], comp1_bit[8], comp2_bit[8];\r\nu8 ecc_bit[24];\r\nu8 ecc_sum = 0;\r\nu8 find_bit = 0;\r\nuint find_byte = 0;\r\nint isEccFF;\r\nisEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);\r\ngen_true_ecc(ecc_data1);\r\ngen_true_ecc(ecc_data2);\r\nfor (i = 0; i <= 2; i++) {\r\n*(ecc_data1 + i) = ~(*(ecc_data1 + i));\r\n*(ecc_data2 + i) = ~(*(ecc_data2 + i));\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp0_bit[i] = *ecc_data1 % 2;\r\n*ecc_data1 = *ecc_data1 / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp1_bit[i] = *(ecc_data1 + 1) % 2;\r\n*(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp2_bit[i] = *(ecc_data1 + 2) % 2;\r\n*(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp0_bit[i] = *ecc_data2 % 2;\r\n*ecc_data2 = *ecc_data2 / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp1_bit[i] = *(ecc_data2 + 1) % 2;\r\n*(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp2_bit[i] = *(ecc_data2 + 2) % 2;\r\n*(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;\r\n}\r\nfor (i = 0; i < 6; i++)\r\necc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];\r\nfor (i = 0; i < 8; i++)\r\necc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];\r\nfor (i = 0; i < 8; i++)\r\necc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];\r\necc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];\r\necc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];\r\nfor (i = 0; i < 24; i++)\r\necc_sum += ecc_bit[i];\r\nswitch (ecc_sum) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\npr_debug("ECC UNCORRECTED_ERROR 1\n");\r\nreturn -1;\r\ncase 11:\r\npr_debug("ECC UNCORRECTED_ERROR B\n");\r\nreturn -1;\r\ncase 12:\r\nfind_byte = (ecc_bit[23] << 8) +\r\n(ecc_bit[21] << 7) +\r\n(ecc_bit[19] << 6) +\r\n(ecc_bit[17] << 5) +\r\n(ecc_bit[15] << 4) +\r\n(ecc_bit[13] << 3) +\r\n(ecc_bit[11] << 2) +\r\n(ecc_bit[9] << 1) +\r\necc_bit[7];\r\nfind_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];\r\npr_debug("Correcting single bit ECC error at offset: "\r\n"%d, bit: %d\n", find_byte, find_bit);\r\npage_data[find_byte] ^= (1 << find_bit);\r\nreturn 1;\r\ndefault:\r\nif (isEccFF) {\r\nif (ecc_data2[0] == 0 &&\r\necc_data2[1] == 0 &&\r\necc_data2[2] == 0)\r\nreturn 0;\r\n}\r\npr_debug("UNCORRECTED_ERROR default\n");\r\nreturn -1;\r\n}\r\n}\r\nstatic int omap_correct_data(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nint blockCnt = 0, i = 0, ret = 0;\r\nint stat = 0;\r\nif ((info->nand.ecc.mode == NAND_ECC_HW) &&\r\n(info->nand.ecc.size == 2048))\r\nblockCnt = 4;\r\nelse\r\nblockCnt = 1;\r\nfor (i = 0; i < blockCnt; i++) {\r\nif (memcmp(read_ecc, calc_ecc, 3) != 0) {\r\nret = omap_compare_ecc(read_ecc, calc_ecc, dat);\r\nif (ret < 0)\r\nreturn ret;\r\nstat += ret;\r\n}\r\nread_ecc += 3;\r\ncalc_ecc += 3;\r\ndat += 512;\r\n}\r\nreturn stat;\r\n}\r\nstatic int omap_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nu32 val;\r\nval = readl(info->reg.gpmc_ecc_config);\r\nif (((val >> ECC_CONFIG_CS_SHIFT) & ~CS_MASK) != info->gpmc_cs)\r\nreturn -EINVAL;\r\nval = readl(info->reg.gpmc_ecc1_result);\r\n*ecc_code++ = val;\r\n*ecc_code++ = val >> 16;\r\n*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);\r\nreturn 0;\r\n}\r\nstatic void omap_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nunsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\r\nu32 val;\r\nval = ECCCLEAR | ECC1;\r\nwritel(val, info->reg.gpmc_ecc_control);\r\nval = ((((info->nand.ecc.size >> 1) - 1) << ECCSIZE1_SHIFT) |\r\nECC1RESULTSIZE);\r\nwritel(val, info->reg.gpmc_ecc_size_config);\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\ncase NAND_ECC_WRITE:\r\nwritel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);\r\nbreak;\r\ncase NAND_ECC_READSYN:\r\nwritel(ECCCLEAR, info->reg.gpmc_ecc_control);\r\nbreak;\r\ndefault:\r\ndev_info(&info->pdev->dev,\r\n"error: unrecognized Mode[%d]!\n", mode);\r\nbreak;\r\n}\r\nval = (dev_width << 7) | (info->gpmc_cs << 1) | (0x1);\r\nwritel(val, info->reg.gpmc_ecc_config);\r\n}\r\nstatic int omap_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nunsigned long timeo = jiffies;\r\nint status, state = this->state;\r\nif (state == FL_ERASING)\r\ntimeo += msecs_to_jiffies(400);\r\nelse\r\ntimeo += msecs_to_jiffies(20);\r\nwriteb(NAND_CMD_STATUS & 0xFF, info->reg.gpmc_nand_command);\r\nwhile (time_before(jiffies, timeo)) {\r\nstatus = readb(info->reg.gpmc_nand_data);\r\nif (status & NAND_STATUS_READY)\r\nbreak;\r\ncond_resched();\r\n}\r\nstatus = readb(info->reg.gpmc_nand_data);\r\nreturn status;\r\n}\r\nstatic int omap_dev_ready(struct mtd_info *mtd)\r\n{\r\nunsigned int val = 0;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nval = readl(info->reg.gpmc_status);\r\nif ((val & 0x100) == 0x100) {\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void omap3_enable_hwecc_bch(struct mtd_info *mtd, int mode)\r\n{\r\nint nerrors;\r\nunsigned int dev_width, nsectors;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nu32 val, wr_mode;\r\nunsigned int ecc_size1, ecc_size0;\r\nwr_mode = BCH_WRAPMODE_6;\r\necc_size0 = BCH_ECC_SIZE0;\r\necc_size1 = BCH_ECC_SIZE1;\r\nnsectors = 1;\r\nnerrors = info->nand.ecc.strength;\r\nif (info->is_elm_used && (mtd->writesize <= 4096)) {\r\nif (mode == NAND_ECC_READ) {\r\nwr_mode = BCH_WRAPMODE_1;\r\necc_size0 = (nerrors == 8) ?\r\nBCH8R_ECC_SIZE0 : BCH4R_ECC_SIZE0;\r\necc_size1 = (nerrors == 8) ?\r\nBCH8R_ECC_SIZE1 : BCH4R_ECC_SIZE1;\r\n}\r\nnsectors = info->nand.ecc.steps;\r\n}\r\nwritel(ECC1, info->reg.gpmc_ecc_control);\r\nval = (ecc_size1 << ECCSIZE1_SHIFT) | (ecc_size0 << ECCSIZE0_SHIFT);\r\nwritel(val, info->reg.gpmc_ecc_size_config);\r\ndev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\r\nval = ((1 << 16) |\r\n(((nerrors == 8) ? 1 : 0) << 12) |\r\n(wr_mode << 8) |\r\n(dev_width << 7) |\r\n(((nsectors-1) & 0x7) << 4) |\r\n(info->gpmc_cs << 1) |\r\n(0x1));\r\nwritel(val, info->reg.gpmc_ecc_config);\r\nwritel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);\r\n}\r\nstatic int omap3_calculate_ecc_bch4(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nunsigned long nsectors, val1, val2;\r\nint i;\r\nnsectors = ((readl(info->reg.gpmc_ecc_config) >> 4) & 0x7) + 1;\r\nfor (i = 0; i < nsectors; i++) {\r\nval1 = readl(info->reg.gpmc_bch_result0[i]);\r\nval2 = readl(info->reg.gpmc_bch_result1[i]);\r\n*ecc_code++ = 0x28 ^ ((val2 >> 12) & 0xFF);\r\n*ecc_code++ = 0x13 ^ ((val2 >> 4) & 0xFF);\r\n*ecc_code++ = 0xcc ^ (((val2 & 0xF) << 4)|((val1 >> 28) & 0xF));\r\n*ecc_code++ = 0x39 ^ ((val1 >> 20) & 0xFF);\r\n*ecc_code++ = 0x96 ^ ((val1 >> 12) & 0xFF);\r\n*ecc_code++ = 0xac ^ ((val1 >> 4) & 0xFF);\r\n*ecc_code++ = 0x7f ^ ((val1 & 0xF) << 4);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap3_calculate_ecc_bch8(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nunsigned long nsectors, val1, val2, val3, val4;\r\nint i;\r\nnsectors = ((readl(info->reg.gpmc_ecc_config) >> 4) & 0x7) + 1;\r\nfor (i = 0; i < nsectors; i++) {\r\nval1 = readl(info->reg.gpmc_bch_result0[i]);\r\nval2 = readl(info->reg.gpmc_bch_result1[i]);\r\nval3 = readl(info->reg.gpmc_bch_result2[i]);\r\nval4 = readl(info->reg.gpmc_bch_result3[i]);\r\n*ecc_code++ = 0xef ^ (val4 & 0xFF);\r\n*ecc_code++ = 0x51 ^ ((val3 >> 24) & 0xFF);\r\n*ecc_code++ = 0x2e ^ ((val3 >> 16) & 0xFF);\r\n*ecc_code++ = 0x09 ^ ((val3 >> 8) & 0xFF);\r\n*ecc_code++ = 0xed ^ (val3 & 0xFF);\r\n*ecc_code++ = 0x93 ^ ((val2 >> 24) & 0xFF);\r\n*ecc_code++ = 0x9a ^ ((val2 >> 16) & 0xFF);\r\n*ecc_code++ = 0xc2 ^ ((val2 >> 8) & 0xFF);\r\n*ecc_code++ = 0x97 ^ (val2 & 0xFF);\r\n*ecc_code++ = 0x79 ^ ((val1 >> 24) & 0xFF);\r\n*ecc_code++ = 0xe5 ^ ((val1 >> 16) & 0xFF);\r\n*ecc_code++ = 0x24 ^ ((val1 >> 8) & 0xFF);\r\n*ecc_code++ = 0xb5 ^ (val1 & 0xFF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap3_calculate_ecc_bch(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nunsigned long nsectors, bch_val1, bch_val2, bch_val3, bch_val4;\r\nint i, eccbchtsel;\r\nnsectors = ((readl(info->reg.gpmc_ecc_config) >> 4) & 0x7) + 1;\r\neccbchtsel = ((readl(info->reg.gpmc_ecc_config) >> 12) & 0x3);\r\nfor (i = 0; i < nsectors; i++) {\r\nbch_val1 = readl(info->reg.gpmc_bch_result0[i]);\r\nbch_val2 = readl(info->reg.gpmc_bch_result1[i]);\r\nif (eccbchtsel) {\r\nbch_val3 = readl(info->reg.gpmc_bch_result2[i]);\r\nbch_val4 = readl(info->reg.gpmc_bch_result3[i]);\r\n}\r\nif (eccbchtsel) {\r\n*ecc_code++ = (bch_val4 & 0xFF);\r\n*ecc_code++ = ((bch_val3 >> 24) & 0xFF);\r\n*ecc_code++ = ((bch_val3 >> 16) & 0xFF);\r\n*ecc_code++ = ((bch_val3 >> 8) & 0xFF);\r\n*ecc_code++ = (bch_val3 & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 24) & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 16) & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 8) & 0xFF);\r\n*ecc_code++ = (bch_val2 & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 24) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 16) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 8) & 0xFF);\r\n*ecc_code++ = (bch_val1 & 0xFF);\r\n*ecc_code++ = 0x0;\r\n} else {\r\n*ecc_code++ = ((bch_val2 >> 12) & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 4) & 0xFF);\r\n*ecc_code++ = ((bch_val2 & 0xF) << 4) |\r\n((bch_val1 >> 28) & 0xF);\r\n*ecc_code++ = ((bch_val1 >> 20) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 12) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 4) & 0xFF);\r\n*ecc_code++ = ((bch_val1 & 0xF) << 4);\r\n*ecc_code++ = 0x0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int erased_sector_bitflips(u_char *data, u_char *oob,\r\nstruct omap_nand_info *info)\r\n{\r\nint flip_bits = 0, i;\r\nfor (i = 0; i < info->nand.ecc.size; i++) {\r\nflip_bits += hweight8(~data[i]);\r\nif (flip_bits > info->nand.ecc.strength)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < info->nand.ecc.bytes - 1; i++) {\r\nflip_bits += hweight8(~oob[i]);\r\nif (flip_bits > info->nand.ecc.strength)\r\nreturn 0;\r\n}\r\nif (flip_bits) {\r\nmemset(data, 0xFF, info->nand.ecc.size);\r\nmemset(oob, 0xFF, info->nand.ecc.bytes);\r\n}\r\nreturn flip_bits;\r\n}\r\nstatic int omap_elm_correct_data(struct mtd_info *mtd, u_char *data,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nint eccsteps = info->nand.ecc.steps;\r\nint i , j, stat = 0;\r\nint eccsize, eccflag, ecc_vector_size;\r\nstruct elm_errorvec err_vec[ERROR_VECTOR_MAX];\r\nu_char *ecc_vec = calc_ecc;\r\nu_char *spare_ecc = read_ecc;\r\nu_char *erased_ecc_vec;\r\nenum bch_ecc type;\r\nbool is_error_reported = false;\r\nmemset(err_vec, 0, sizeof(err_vec));\r\nif (info->nand.ecc.strength == BCH8_MAX_ERROR) {\r\ntype = BCH8_ECC;\r\nerased_ecc_vec = bch8_vector;\r\n} else {\r\ntype = BCH4_ECC;\r\nerased_ecc_vec = bch4_vector;\r\n}\r\necc_vector_size = info->nand.ecc.bytes;\r\neccsize = ecc_vector_size - 1;\r\nfor (i = 0; i < eccsteps ; i++) {\r\neccflag = 0;\r\nfor (j = 0; (j < eccsize); j++) {\r\nif (calc_ecc[j] != 0) {\r\neccflag = 1;\r\nbreak;\r\n}\r\n}\r\nif (eccflag == 1) {\r\nunsigned int threshold = min_t(unsigned int, 4,\r\ninfo->nand.ecc.strength / 2);\r\nif (hweight8(~read_ecc[eccsize]) >= threshold) {\r\nerr_vec[i].error_reported = true;\r\nis_error_reported = true;\r\n} else {\r\nint bitflip_count;\r\nu_char *buf = &data[info->nand.ecc.size * i];\r\nif (memcmp(calc_ecc, erased_ecc_vec, eccsize)) {\r\nbitflip_count = erased_sector_bitflips(\r\nbuf, read_ecc, info);\r\nif (bitflip_count)\r\nstat += bitflip_count;\r\nelse\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\ncalc_ecc += ecc_vector_size;\r\nread_ecc += ecc_vector_size;\r\n}\r\nif (!is_error_reported)\r\nreturn 0;\r\nelm_decode_bch_error_page(info->elm_dev, ecc_vec, err_vec);\r\nfor (i = 0; i < eccsteps; i++) {\r\nif (err_vec[i].error_reported) {\r\nfor (j = 0; j < err_vec[i].error_count; j++) {\r\nu32 bit_pos, byte_pos, error_max, pos;\r\nif (type == BCH8_ECC)\r\nerror_max = BCH8_ECC_MAX;\r\nelse\r\nerror_max = BCH4_ECC_MAX;\r\nif (info->nand.ecc.strength == BCH8_MAX_ERROR)\r\npos = err_vec[i].error_loc[j];\r\nelse\r\npos = err_vec[i].error_loc[j] +\r\nBCH4_BIT_PAD;\r\nbit_pos = pos % 8;\r\nbyte_pos = (error_max - pos - 1) / 8;\r\nif (pos < error_max) {\r\nif (byte_pos < 512)\r\ndata[byte_pos] ^= 1 << bit_pos;\r\nelse\r\nspare_ecc[byte_pos - 512] ^=\r\n1 << bit_pos;\r\n}\r\n}\r\n}\r\nstat += err_vec[i].error_count;\r\ndata += info->nand.ecc.size;\r\nspare_ecc += ecc_vector_size;\r\n}\r\nfor (i = 0; i < eccsteps; i++)\r\nif (err_vec[i].error_uncorrectable)\r\nreturn -EINVAL;\r\nreturn stat;\r\n}\r\nstatic int omap3_correct_data_bch(struct mtd_info *mtd, u_char *data,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nint i, count;\r\nunsigned int errloc[8];\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\ncount = decode_bch(info->bch, NULL, 512, read_ecc, calc_ecc, NULL,\r\nerrloc);\r\nif (count > 0) {\r\nfor (i = 0; i < count; i++) {\r\nif (errloc[i] < 8*512)\r\ndata[errloc[i]/8] ^= 1 << (errloc[i] & 7);\r\npr_debug("corrected bitflip %u\n", errloc[i]);\r\n}\r\n} else if (count < 0) {\r\npr_err("ecc unrecoverable error\n");\r\n}\r\nreturn count;\r\n}\r\nstatic int omap_write_page_bch(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint i;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->ecc.calculate(mtd, buf, &ecc_calc[0]);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int omap_read_page_bch(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *oob = &chip->oob_poi[eccpos[0]];\r\nuint32_t oob_pos = mtd->writesize + chip->ecc.layout->eccpos[0];\r\nint stat;\r\nunsigned int max_bitflips = 0;\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, oob_pos, -1);\r\nchip->read_buf(mtd, oob, chip->ecc.total);\r\nchip->ecc.calculate(mtd, buf, ecc_calc);\r\nmemcpy(ecc_code, &chip->oob_poi[eccpos[0]], chip->ecc.total);\r\nstat = chip->ecc.correct(mtd, buf, ecc_code, ecc_calc);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic void omap3_free_bch(struct mtd_info *mtd)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nif (info->bch) {\r\nfree_bch(info->bch);\r\ninfo->bch = NULL;\r\n}\r\n}\r\nstatic int omap3_init_bch(struct mtd_info *mtd, int ecc_opt)\r\n{\r\nint max_errors;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\n#ifdef CONFIG_MTD_NAND_OMAP_BCH8\r\nconst int hw_errors = BCH8_MAX_ERROR;\r\n#else\r\nconst int hw_errors = BCH4_MAX_ERROR;\r\n#endif\r\nenum bch_ecc bch_type;\r\nconst __be32 *parp;\r\nint lenp;\r\nstruct device_node *elm_node;\r\ninfo->bch = NULL;\r\nmax_errors = (ecc_opt == OMAP_ECC_BCH8_CODE_HW) ?\r\nBCH8_MAX_ERROR : BCH4_MAX_ERROR;\r\nif (max_errors != hw_errors) {\r\npr_err("cannot configure %d-bit BCH ecc, only %d-bit supported",\r\nmax_errors, hw_errors);\r\ngoto fail;\r\n}\r\ninfo->nand.ecc.size = 512;\r\ninfo->nand.ecc.hwctl = omap3_enable_hwecc_bch;\r\ninfo->nand.ecc.mode = NAND_ECC_HW;\r\ninfo->nand.ecc.strength = max_errors;\r\nif (hw_errors == BCH8_MAX_ERROR)\r\nbch_type = BCH8_ECC;\r\nelse\r\nbch_type = BCH4_ECC;\r\nparp = of_get_property(info->of_node, "elm_id", &lenp);\r\nif ((parp == NULL) && (lenp != (sizeof(void *) * 2))) {\r\npr_err("Missing elm_id property, fall back to Software BCH\n");\r\ninfo->is_elm_used = false;\r\n} else {\r\nstruct platform_device *pdev;\r\nelm_node = of_find_node_by_phandle(be32_to_cpup(parp));\r\npdev = of_find_device_by_node(elm_node);\r\ninfo->elm_dev = &pdev->dev;\r\nif (elm_config(info->elm_dev, bch_type) == 0)\r\ninfo->is_elm_used = true;\r\n}\r\nif (info->is_elm_used && (mtd->writesize <= 4096)) {\r\nif (hw_errors == BCH8_MAX_ERROR)\r\ninfo->nand.ecc.bytes = BCH8_SIZE;\r\nelse\r\ninfo->nand.ecc.bytes = BCH4_SIZE;\r\ninfo->nand.ecc.correct = omap_elm_correct_data;\r\ninfo->nand.ecc.calculate = omap3_calculate_ecc_bch;\r\ninfo->nand.ecc.read_page = omap_read_page_bch;\r\ninfo->nand.ecc.write_page = omap_write_page_bch;\r\n} else {\r\ninfo->bch = init_bch(13, max_errors,\r\n0x201b );\r\nif (!info->bch)\r\ngoto fail;\r\ninfo->nand.ecc.correct = omap3_correct_data_bch;\r\nif (max_errors == 8) {\r\ninfo->nand.ecc.bytes = 13;\r\ninfo->nand.ecc.calculate = omap3_calculate_ecc_bch8;\r\n} else {\r\ninfo->nand.ecc.bytes = 7;\r\ninfo->nand.ecc.calculate = omap3_calculate_ecc_bch4;\r\n}\r\n}\r\npr_info("enabling NAND BCH ecc with %d-bit correction\n", max_errors);\r\nreturn 0;\r\nfail:\r\nomap3_free_bch(mtd);\r\nreturn -1;\r\n}\r\nstatic int omap3_init_bch_tail(struct mtd_info *mtd)\r\n{\r\nint i, steps, offset;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nstruct nand_ecclayout *layout = &info->ecclayout;\r\nsteps = mtd->writesize/info->nand.ecc.size;\r\nlayout->eccbytes = steps*info->nand.ecc.bytes;\r\nif (mtd->oobsize < 64) {\r\npr_err("BCH ecc is not supported on small page devices\n");\r\ngoto fail;\r\n}\r\nif (layout->eccbytes+2 > mtd->oobsize) {\r\npr_err("no oob layout available for oobsize %d eccbytes %u\n",\r\nmtd->oobsize, layout->eccbytes);\r\ngoto fail;\r\n}\r\nif (info->is_elm_used && (info->nand.ecc.bytes == BCH8_SIZE))\r\noffset = 2;\r\nelse\r\noffset = mtd->oobsize - layout->eccbytes;\r\nfor (i = 0; i < layout->eccbytes; i++)\r\nlayout->eccpos[i] = offset + i;\r\nif (info->is_elm_used && (info->nand.ecc.bytes == BCH8_SIZE))\r\nlayout->oobfree[0].offset = 2 + layout->eccbytes * steps;\r\nelse\r\nlayout->oobfree[0].offset = 2;\r\nlayout->oobfree[0].length = mtd->oobsize-2-layout->eccbytes;\r\ninfo->nand.ecc.layout = layout;\r\nif (!(info->nand.options & NAND_BUSWIDTH_16))\r\ninfo->nand.badblock_pattern = &bb_descrip_flashbased;\r\nreturn 0;\r\nfail:\r\nomap3_free_bch(mtd);\r\nreturn -1;\r\n}\r\nstatic int omap3_init_bch(struct mtd_info *mtd, int ecc_opt)\r\n{\r\npr_err("CONFIG_MTD_NAND_OMAP_BCH is not enabled\n");\r\nreturn -1;\r\n}\r\nstatic int omap3_init_bch_tail(struct mtd_info *mtd)\r\n{\r\nreturn -1;\r\n}\r\nstatic void omap3_free_bch(struct mtd_info *mtd)\r\n{\r\n}\r\nstatic int omap_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_nand_info *info;\r\nstruct omap_nand_platform_data *pdata;\r\nint err;\r\nint i, offset;\r\ndma_cap_mask_t mask;\r\nunsigned sig;\r\nstruct resource *res;\r\nstruct mtd_part_parser_data ppdata = {};\r\npdata = pdev->dev.platform_data;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = kzalloc(sizeof(struct omap_nand_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, info);\r\nspin_lock_init(&info->controller.lock);\r\ninit_waitqueue_head(&info->controller.wq);\r\ninfo->pdev = pdev;\r\ninfo->gpmc_cs = pdata->cs;\r\ninfo->reg = pdata->reg;\r\ninfo->mtd.priv = &info->nand;\r\ninfo->mtd.name = dev_name(&pdev->dev);\r\ninfo->mtd.owner = THIS_MODULE;\r\ninfo->nand.options = pdata->devsize;\r\ninfo->nand.options |= NAND_SKIP_BBTSCAN;\r\n#ifdef CONFIG_MTD_NAND_OMAP_BCH\r\ninfo->of_node = pdata->of_node;\r\n#endif\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\nerr = -EINVAL;\r\ndev_err(&pdev->dev, "error getting memory resource\n");\r\ngoto out_free_info;\r\n}\r\ninfo->phys_base = res->start;\r\ninfo->mem_size = resource_size(res);\r\nif (!request_mem_region(info->phys_base, info->mem_size,\r\npdev->dev.driver->name)) {\r\nerr = -EBUSY;\r\ngoto out_free_info;\r\n}\r\ninfo->nand.IO_ADDR_R = ioremap(info->phys_base, info->mem_size);\r\nif (!info->nand.IO_ADDR_R) {\r\nerr = -ENOMEM;\r\ngoto out_release_mem_region;\r\n}\r\ninfo->nand.controller = &info->controller;\r\ninfo->nand.IO_ADDR_W = info->nand.IO_ADDR_R;\r\ninfo->nand.cmd_ctrl = omap_hwcontrol;\r\nif (pdata->dev_ready) {\r\ninfo->nand.dev_ready = omap_dev_ready;\r\ninfo->nand.chip_delay = 0;\r\n} else {\r\ninfo->nand.waitfunc = omap_wait;\r\ninfo->nand.chip_delay = 50;\r\n}\r\nswitch (pdata->xfer_type) {\r\ncase NAND_OMAP_PREFETCH_POLLED:\r\ninfo->nand.read_buf = omap_read_buf_pref;\r\ninfo->nand.write_buf = omap_write_buf_pref;\r\nbreak;\r\ncase NAND_OMAP_POLLED:\r\nif (info->nand.options & NAND_BUSWIDTH_16) {\r\ninfo->nand.read_buf = omap_read_buf16;\r\ninfo->nand.write_buf = omap_write_buf16;\r\n} else {\r\ninfo->nand.read_buf = omap_read_buf8;\r\ninfo->nand.write_buf = omap_write_buf8;\r\n}\r\nbreak;\r\ncase NAND_OMAP_PREFETCH_DMA:\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nsig = OMAP24XX_DMA_GPMC;\r\ninfo->dma = dma_request_channel(mask, omap_dma_filter_fn, &sig);\r\nif (!info->dma) {\r\ndev_err(&pdev->dev, "DMA engine request failed\n");\r\nerr = -ENXIO;\r\ngoto out_release_mem_region;\r\n} else {\r\nstruct dma_slave_config cfg;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.src_addr = info->phys_base;\r\ncfg.dst_addr = info->phys_base;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.src_maxburst = 16;\r\ncfg.dst_maxburst = 16;\r\nerr = dmaengine_slave_config(info->dma, &cfg);\r\nif (err) {\r\ndev_err(&pdev->dev, "DMA engine slave config failed: %d\n",\r\nerr);\r\ngoto out_release_mem_region;\r\n}\r\ninfo->nand.read_buf = omap_read_buf_dma_pref;\r\ninfo->nand.write_buf = omap_write_buf_dma_pref;\r\n}\r\nbreak;\r\ncase NAND_OMAP_PREFETCH_IRQ:\r\ninfo->gpmc_irq_fifo = platform_get_irq(pdev, 0);\r\nif (info->gpmc_irq_fifo <= 0) {\r\ndev_err(&pdev->dev, "error getting fifo irq\n");\r\nerr = -ENODEV;\r\ngoto out_release_mem_region;\r\n}\r\nerr = request_irq(info->gpmc_irq_fifo, omap_nand_irq,\r\nIRQF_SHARED, "gpmc-nand-fifo", info);\r\nif (err) {\r\ndev_err(&pdev->dev, "requesting irq(%d) error:%d",\r\ninfo->gpmc_irq_fifo, err);\r\ninfo->gpmc_irq_fifo = 0;\r\ngoto out_release_mem_region;\r\n}\r\ninfo->gpmc_irq_count = platform_get_irq(pdev, 1);\r\nif (info->gpmc_irq_count <= 0) {\r\ndev_err(&pdev->dev, "error getting count irq\n");\r\nerr = -ENODEV;\r\ngoto out_release_mem_region;\r\n}\r\nerr = request_irq(info->gpmc_irq_count, omap_nand_irq,\r\nIRQF_SHARED, "gpmc-nand-count", info);\r\nif (err) {\r\ndev_err(&pdev->dev, "requesting irq(%d) error:%d",\r\ninfo->gpmc_irq_count, err);\r\ninfo->gpmc_irq_count = 0;\r\ngoto out_release_mem_region;\r\n}\r\ninfo->nand.read_buf = omap_read_buf_irq_pref;\r\ninfo->nand.write_buf = omap_write_buf_irq_pref;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"xfer_type(%d) not supported!\n", pdata->xfer_type);\r\nerr = -EINVAL;\r\ngoto out_release_mem_region;\r\n}\r\nif (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_DEFAULT)\r\ninfo->nand.ecc.mode = NAND_ECC_SOFT;\r\nelse if ((pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW) ||\r\n(pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE)) {\r\ninfo->nand.ecc.bytes = 3;\r\ninfo->nand.ecc.size = 512;\r\ninfo->nand.ecc.strength = 1;\r\ninfo->nand.ecc.calculate = omap_calculate_ecc;\r\ninfo->nand.ecc.hwctl = omap_enable_hwecc;\r\ninfo->nand.ecc.correct = omap_correct_data;\r\ninfo->nand.ecc.mode = NAND_ECC_HW;\r\n} else if ((pdata->ecc_opt == OMAP_ECC_BCH4_CODE_HW) ||\r\n(pdata->ecc_opt == OMAP_ECC_BCH8_CODE_HW)) {\r\nerr = omap3_init_bch(&info->mtd, pdata->ecc_opt);\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto out_release_mem_region;\r\n}\r\n}\r\nif (nand_scan_ident(&info->mtd, 1, NULL)) {\r\ninfo->nand.options ^= NAND_BUSWIDTH_16;\r\nif (nand_scan_ident(&info->mtd, 1, NULL)) {\r\nerr = -ENXIO;\r\ngoto out_release_mem_region;\r\n}\r\n}\r\nif (pdata->ecc_opt == OMAP_ECC_HAMMING_CODE_HW_ROMCODE) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\noffset = 2;\r\nelse {\r\noffset = 1;\r\ninfo->nand.badblock_pattern = &bb_descrip_flashbased;\r\n}\r\nomap_oobinfo.eccbytes = 3 * (info->mtd.oobsize/16);\r\nfor (i = 0; i < omap_oobinfo.eccbytes; i++)\r\nomap_oobinfo.eccpos[i] = i+offset;\r\nomap_oobinfo.oobfree->offset = offset + omap_oobinfo.eccbytes;\r\nomap_oobinfo.oobfree->length = info->mtd.oobsize -\r\n(offset + omap_oobinfo.eccbytes);\r\ninfo->nand.ecc.layout = &omap_oobinfo;\r\n} else if ((pdata->ecc_opt == OMAP_ECC_BCH4_CODE_HW) ||\r\n(pdata->ecc_opt == OMAP_ECC_BCH8_CODE_HW)) {\r\nerr = omap3_init_bch_tail(&info->mtd);\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto out_release_mem_region;\r\n}\r\n}\r\nif (nand_scan_tail(&info->mtd)) {\r\nerr = -ENXIO;\r\ngoto out_release_mem_region;\r\n}\r\nppdata.of_node = pdata->of_node;\r\nmtd_device_parse_register(&info->mtd, NULL, &ppdata, pdata->parts,\r\npdata->nr_parts);\r\nplatform_set_drvdata(pdev, &info->mtd);\r\nreturn 0;\r\nout_release_mem_region:\r\nif (info->dma)\r\ndma_release_channel(info->dma);\r\nif (info->gpmc_irq_count > 0)\r\nfree_irq(info->gpmc_irq_count, info);\r\nif (info->gpmc_irq_fifo > 0)\r\nfree_irq(info->gpmc_irq_fifo, info);\r\nrelease_mem_region(info->phys_base, info->mem_size);\r\nout_free_info:\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int omap_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nomap3_free_bch(&info->mtd);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (info->dma)\r\ndma_release_channel(info->dma);\r\nif (info->gpmc_irq_count > 0)\r\nfree_irq(info->gpmc_irq_count, info);\r\nif (info->gpmc_irq_fifo > 0)\r\nfree_irq(info->gpmc_irq_fifo, info);\r\nnand_release(&info->mtd);\r\niounmap(info->nand.IO_ADDR_R);\r\nrelease_mem_region(info->phys_base, info->mem_size);\r\nkfree(info);\r\nreturn 0;\r\n}
