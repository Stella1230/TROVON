static void sudmac_writel(struct sudmac_chan *sc, u32 data, u32 reg)\r\n{\r\niowrite32(data, sc->base + reg);\r\n}\r\nstatic u32 sudmac_readl(struct sudmac_chan *sc, u32 reg)\r\n{\r\nreturn ioread32(sc->base + reg);\r\n}\r\nstatic bool sudmac_is_busy(struct sudmac_chan *sc)\r\n{\r\nu32 den = sudmac_readl(sc, SUDMAC_CH0DEN + sc->offset);\r\nif (den)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void sudmac_set_reg(struct sudmac_chan *sc, struct sudmac_regs *hw,\r\nstruct shdma_desc *sdesc)\r\n{\r\nsudmac_writel(sc, sc->cfg, SUDMAC_CH0CFG + sc->offset);\r\nsudmac_writel(sc, hw->base_addr, SUDMAC_CH0BA + sc->offset);\r\nsudmac_writel(sc, hw->base_byte_count, SUDMAC_CH0BBC + sc->offset);\r\n}\r\nstatic void sudmac_start(struct sudmac_chan *sc)\r\n{\r\nu32 dintctrl = sudmac_readl(sc, SUDMAC_DINTCTRL);\r\nsudmac_writel(sc, dintctrl | sc->dint_end_bit, SUDMAC_DINTCTRL);\r\nsudmac_writel(sc, 1, SUDMAC_CH0DEN + sc->offset);\r\n}\r\nstatic void sudmac_start_xfer(struct shdma_chan *schan,\r\nstruct shdma_desc *sdesc)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nstruct sudmac_desc *sd = to_desc(sdesc);\r\nsudmac_set_reg(sc, &sd->hw, sdesc);\r\nsudmac_start(sc);\r\n}\r\nstatic bool sudmac_channel_busy(struct shdma_chan *schan)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nreturn sudmac_is_busy(sc);\r\n}\r\nstatic void sudmac_setup_xfer(struct shdma_chan *schan, int slave_id)\r\n{\r\n}\r\nstatic const struct sudmac_slave_config *sudmac_find_slave(\r\nstruct sudmac_chan *sc, int slave_id)\r\n{\r\nstruct sudmac_device *sdev = to_sdev(sc);\r\nstruct sudmac_pdata *pdata = sdev->pdata;\r\nconst struct sudmac_slave_config *cfg;\r\nint i;\r\nfor (i = 0, cfg = pdata->slave; i < pdata->slave_num; i++, cfg++)\r\nif (cfg->slave_id == slave_id)\r\nreturn cfg;\r\nreturn NULL;\r\n}\r\nstatic int sudmac_set_slave(struct shdma_chan *schan, int slave_id, bool try)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nconst struct sudmac_slave_config *cfg = sudmac_find_slave(sc, slave_id);\r\nif (!cfg)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic inline void sudmac_dma_halt(struct sudmac_chan *sc)\r\n{\r\nu32 dintctrl = sudmac_readl(sc, SUDMAC_DINTCTRL);\r\nsudmac_writel(sc, 0, SUDMAC_CH0DEN + sc->offset);\r\nsudmac_writel(sc, dintctrl & ~sc->dint_end_bit, SUDMAC_DINTCTRL);\r\nsudmac_writel(sc, sc->dint_end_bit, SUDMAC_DINTSTSCLR);\r\n}\r\nstatic int sudmac_desc_setup(struct shdma_chan *schan,\r\nstruct shdma_desc *sdesc,\r\ndma_addr_t src, dma_addr_t dst, size_t *len)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nstruct sudmac_desc *sd = to_desc(sdesc);\r\ndev_dbg(sc->shdma_chan.dev, "%s: src=%x, dst=%x, len=%d\n",\r\n__func__, src, dst, *len);\r\nif (*len > schan->max_xfer_len)\r\n*len = schan->max_xfer_len;\r\nif (dst)\r\nsd->hw.base_addr = dst;\r\nelse if (src)\r\nsd->hw.base_addr = src;\r\nsd->hw.base_byte_count = *len;\r\nreturn 0;\r\n}\r\nstatic void sudmac_halt(struct shdma_chan *schan)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nsudmac_dma_halt(sc);\r\n}\r\nstatic bool sudmac_chan_irq(struct shdma_chan *schan, int irq)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nu32 dintsts = sudmac_readl(sc, SUDMAC_DINTSTS);\r\nif (!(dintsts & sc->dint_end_bit))\r\nreturn false;\r\nsudmac_dma_halt(sc);\r\nreturn true;\r\n}\r\nstatic size_t sudmac_get_partial(struct shdma_chan *schan,\r\nstruct shdma_desc *sdesc)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nstruct sudmac_desc *sd = to_desc(sdesc);\r\nu32 current_byte_count = sudmac_readl(sc, SUDMAC_CH0CBC + sc->offset);\r\nreturn sd->hw.base_byte_count - current_byte_count;\r\n}\r\nstatic bool sudmac_desc_completed(struct shdma_chan *schan,\r\nstruct shdma_desc *sdesc)\r\n{\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nstruct sudmac_desc *sd = to_desc(sdesc);\r\nu32 current_addr = sudmac_readl(sc, SUDMAC_CH0CA + sc->offset);\r\nreturn sd->hw.base_addr + sd->hw.base_byte_count == current_addr;\r\n}\r\nstatic int sudmac_chan_probe(struct sudmac_device *su_dev, int id, int irq,\r\nunsigned long flags)\r\n{\r\nstruct shdma_dev *sdev = &su_dev->shdma_dev;\r\nstruct platform_device *pdev = to_platform_device(sdev->dma_dev.dev);\r\nstruct sudmac_chan *sc;\r\nstruct shdma_chan *schan;\r\nint err;\r\nsc = devm_kzalloc(&pdev->dev, sizeof(struct sudmac_chan), GFP_KERNEL);\r\nif (!sc) {\r\ndev_err(sdev->dma_dev.dev,\r\n"No free memory for allocating dma channels!\n");\r\nreturn -ENOMEM;\r\n}\r\nschan = &sc->shdma_chan;\r\nschan->max_xfer_len = 64 * 1024 * 1024 - 1;\r\nshdma_chan_probe(sdev, schan, id);\r\nsc->base = su_dev->chan_reg;\r\nsc->offset = su_dev->pdata->channel->offset;\r\nif (su_dev->pdata->channel->config & SUDMAC_TX_BUFFER_MODE)\r\nsc->cfg |= SUDMAC_SENDBUFM;\r\nif (su_dev->pdata->channel->config & SUDMAC_RX_END_MODE)\r\nsc->cfg |= SUDMAC_RCVENDM;\r\nsc->cfg |= (su_dev->pdata->channel->wait << 4) & SUDMAC_LBA_WAIT;\r\nif (su_dev->pdata->channel->dint_end_bit & SUDMAC_DMA_BIT_CH0)\r\nsc->dint_end_bit |= SUDMAC_CH0ENDE;\r\nif (su_dev->pdata->channel->dint_end_bit & SUDMAC_DMA_BIT_CH1)\r\nsc->dint_end_bit |= SUDMAC_CH1ENDE;\r\nif (pdev->id >= 0)\r\nsnprintf(sc->dev_id, sizeof(sc->dev_id), "sudmac%d.%d",\r\npdev->id, id);\r\nelse\r\nsnprintf(sc->dev_id, sizeof(sc->dev_id), "sudmac%d", id);\r\nerr = shdma_request_irq(schan, irq, flags, sc->dev_id);\r\nif (err) {\r\ndev_err(sdev->dma_dev.dev,\r\n"DMA channel %d request_irq failed %d\n", id, err);\r\ngoto err_no_irq;\r\n}\r\nreturn 0;\r\nerr_no_irq:\r\nshdma_chan_remove(schan);\r\nreturn err;\r\n}\r\nstatic void sudmac_chan_remove(struct sudmac_device *su_dev)\r\n{\r\nstruct dma_device *dma_dev = &su_dev->shdma_dev.dma_dev;\r\nstruct shdma_chan *schan;\r\nint i;\r\nshdma_for_each_chan(schan, &su_dev->shdma_dev, i) {\r\nstruct sudmac_chan *sc = to_chan(schan);\r\nBUG_ON(!schan);\r\nshdma_free_irq(&sc->shdma_chan);\r\nshdma_chan_remove(schan);\r\n}\r\ndma_dev->chancnt = 0;\r\n}\r\nstatic dma_addr_t sudmac_slave_addr(struct shdma_chan *schan)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct shdma_desc *sudmac_embedded_desc(void *buf, int i)\r\n{\r\nreturn &((struct sudmac_desc *)buf)[i].shdma_desc;\r\n}\r\nstatic int sudmac_probe(struct platform_device *pdev)\r\n{\r\nstruct sudmac_pdata *pdata = pdev->dev.platform_data;\r\nint err, i;\r\nstruct sudmac_device *su_dev;\r\nstruct dma_device *dma_dev;\r\nstruct resource *chan, *irq_res;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nchan = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!chan || !irq_res)\r\nreturn -ENODEV;\r\nerr = -ENOMEM;\r\nsu_dev = devm_kzalloc(&pdev->dev, sizeof(struct sudmac_device),\r\nGFP_KERNEL);\r\nif (!su_dev) {\r\ndev_err(&pdev->dev, "Not enough memory\n");\r\nreturn err;\r\n}\r\ndma_dev = &su_dev->shdma_dev.dma_dev;\r\nsu_dev->chan_reg = devm_request_and_ioremap(&pdev->dev, chan);\r\nif (!su_dev->chan_reg)\r\nreturn err;\r\ndma_cap_set(DMA_SLAVE, dma_dev->cap_mask);\r\nsu_dev->shdma_dev.ops = &sudmac_shdma_ops;\r\nsu_dev->shdma_dev.desc_size = sizeof(struct sudmac_desc);\r\nerr = shdma_init(&pdev->dev, &su_dev->shdma_dev, pdata->channel_num);\r\nif (err < 0)\r\nreturn err;\r\nsu_dev->pdata = pdev->dev.platform_data;\r\nplatform_set_drvdata(pdev, su_dev);\r\nfor (i = 0; i < pdata->channel_num; i++) {\r\nerr = sudmac_chan_probe(su_dev, i, irq_res->start, IRQF_SHARED);\r\nif (err)\r\ngoto chan_probe_err;\r\n}\r\nerr = dma_async_device_register(&su_dev->shdma_dev.dma_dev);\r\nif (err < 0)\r\ngoto chan_probe_err;\r\nreturn err;\r\nchan_probe_err:\r\nsudmac_chan_remove(su_dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nshdma_cleanup(&su_dev->shdma_dev);\r\nreturn err;\r\n}\r\nstatic int sudmac_remove(struct platform_device *pdev)\r\n{\r\nstruct sudmac_device *su_dev = platform_get_drvdata(pdev);\r\nstruct dma_device *dma_dev = &su_dev->shdma_dev.dma_dev;\r\ndma_async_device_unregister(dma_dev);\r\nsudmac_chan_remove(su_dev);\r\nshdma_cleanup(&su_dev->shdma_dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
