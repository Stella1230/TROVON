s64 perf_atoll(const char *str)\r\n{\r\nunsigned int i;\r\ns64 length = -1, unit = 1;\r\nif (!isdigit(str[0]))\r\ngoto out_err;\r\nfor (i = 1; i < strlen(str); i++) {\r\nswitch (str[i]) {\r\ncase 'B':\r\ncase 'b':\r\nbreak;\r\ncase 'K':\r\nif (str[i + 1] != 'B')\r\ngoto out_err;\r\nelse\r\ngoto kilo;\r\ncase 'k':\r\nif (str[i + 1] != 'b')\r\ngoto out_err;\r\nkilo:\r\nunit = K;\r\nbreak;\r\ncase 'M':\r\nif (str[i + 1] != 'B')\r\ngoto out_err;\r\nelse\r\ngoto mega;\r\ncase 'm':\r\nif (str[i + 1] != 'b')\r\ngoto out_err;\r\nmega:\r\nunit = K * K;\r\nbreak;\r\ncase 'G':\r\nif (str[i + 1] != 'B')\r\ngoto out_err;\r\nelse\r\ngoto giga;\r\ncase 'g':\r\nif (str[i + 1] != 'b')\r\ngoto out_err;\r\ngiga:\r\nunit = K * K * K;\r\nbreak;\r\ncase 'T':\r\nif (str[i + 1] != 'B')\r\ngoto out_err;\r\nelse\r\ngoto tera;\r\ncase 't':\r\nif (str[i + 1] != 'b')\r\ngoto out_err;\r\ntera:\r\nunit = K * K * K * K;\r\nbreak;\r\ncase '\0':\r\nunit = 1;\r\nbreak;\r\ndefault:\r\nif (!isdigit(str[i]))\r\ngoto out_err;\r\nbreak;\r\n}\r\n}\r\nlength = atoll(str) * unit;\r\ngoto out;\r\nout_err:\r\nlength = -1;\r\nout:\r\nreturn length;\r\n}\r\nstatic const char *skip_sep(const char *cp)\r\n{\r\nwhile (*cp && isspace(*cp))\r\ncp++;\r\nreturn cp;\r\n}\r\nstatic const char *skip_arg(const char *cp)\r\n{\r\nwhile (*cp && !isspace(*cp))\r\ncp++;\r\nreturn cp;\r\n}\r\nstatic int count_argc(const char *str)\r\n{\r\nint count = 0;\r\nwhile (*str) {\r\nstr = skip_sep(str);\r\nif (*str) {\r\ncount++;\r\nstr = skip_arg(str);\r\n}\r\n}\r\nreturn count;\r\n}\r\nvoid argv_free(char **argv)\r\n{\r\nchar **p;\r\nfor (p = argv; *p; p++)\r\nfree(*p);\r\nfree(argv);\r\n}\r\nchar **argv_split(const char *str, int *argcp)\r\n{\r\nint argc = count_argc(str);\r\nchar **argv = zalloc(sizeof(*argv) * (argc+1));\r\nchar **argvp;\r\nif (argv == NULL)\r\ngoto out;\r\nif (argcp)\r\n*argcp = argc;\r\nargvp = argv;\r\nwhile (*str) {\r\nstr = skip_sep(str);\r\nif (*str) {\r\nconst char *p = str;\r\nchar *t;\r\nstr = skip_arg(str);\r\nt = strndup(p, str-p);\r\nif (t == NULL)\r\ngoto fail;\r\n*argvp++ = t;\r\n}\r\n}\r\n*argvp = NULL;\r\nout:\r\nreturn argv;\r\nfail:\r\nargv_free(argv);\r\nreturn NULL;\r\n}\r\nstatic bool __match_charclass(const char *pat, char c, const char **npat)\r\n{\r\nbool complement = false, ret = true;\r\nif (*pat == '!') {\r\ncomplement = true;\r\npat++;\r\n}\r\nif (*pat++ == c)\r\ngoto end;\r\nwhile (*pat && *pat != ']') {\r\nif (*pat == '-' && *(pat + 1) != ']') {\r\nif (*(pat - 1) <= c && c <= *(pat + 1))\r\ngoto end;\r\nif (*(pat - 1) > *(pat + 1))\r\ngoto error;\r\npat += 2;\r\n} else if (*pat++ == c)\r\ngoto end;\r\n}\r\nif (!*pat)\r\ngoto error;\r\nret = false;\r\nend:\r\nwhile (*pat && *pat != ']')\r\npat++;\r\nif (!*pat)\r\ngoto error;\r\n*npat = pat + 1;\r\nreturn complement ? !ret : ret;\r\nerror:\r\nreturn false;\r\n}\r\nstatic bool __match_glob(const char *str, const char *pat, bool ignore_space)\r\n{\r\nwhile (*str && *pat && *pat != '*') {\r\nif (ignore_space) {\r\nif (isspace(*str)) {\r\nstr++;\r\ncontinue;\r\n}\r\nif (isspace(*pat)) {\r\npat++;\r\ncontinue;\r\n}\r\n}\r\nif (*pat == '?') {\r\nstr++;\r\npat++;\r\ncontinue;\r\n} else if (*pat == '[')\r\nif (__match_charclass(pat + 1, *str, &pat)) {\r\nstr++;\r\ncontinue;\r\n} else\r\nreturn false;\r\nelse if (*pat == '\\')\r\npat++;\r\nif (*str++ != *pat++)\r\nreturn false;\r\n}\r\nif (*pat == '*') {\r\nwhile (*pat == '*')\r\npat++;\r\nif (!*pat)\r\nreturn true;\r\nwhile (*str)\r\nif (__match_glob(str++, pat, ignore_space))\r\nreturn true;\r\n}\r\nreturn !*str && !*pat;\r\n}\r\nbool strglobmatch(const char *str, const char *pat)\r\n{\r\nreturn __match_glob(str, pat, false);\r\n}\r\nbool strlazymatch(const char *str, const char *pat)\r\n{\r\nreturn __match_glob(str, pat, true);\r\n}\r\nint strtailcmp(const char *s1, const char *s2)\r\n{\r\nint i1 = strlen(s1);\r\nint i2 = strlen(s2);\r\nwhile (--i1 >= 0 && --i2 >= 0) {\r\nif (s1[i1] != s2[i2])\r\nreturn s1[i1] - s2[i2];\r\n}\r\nreturn 0;\r\n}\r\nchar *strxfrchar(char *s, char from, char to)\r\n{\r\nchar *p = s;\r\nwhile ((p = strchr(p, from)) != NULL)\r\n*p++ = to;\r\nreturn s;\r\n}\r\nchar *ltrim(char *s)\r\n{\r\nint len = strlen(s);\r\nwhile (len && isspace(*s)) {\r\nlen--;\r\ns++;\r\n}\r\nreturn s;\r\n}\r\nchar *rtrim(char *s)\r\n{\r\nsize_t size = strlen(s);\r\nchar *end;\r\nif (!size)\r\nreturn s;\r\nend = s + size - 1;\r\nwhile (end >= s && isspace(*end))\r\nend--;\r\n*(end + 1) = '\0';\r\nreturn s;\r\n}\r\nvoid *memdup(const void *src, size_t len)\r\n{\r\nvoid *p;\r\np = malloc(len);\r\nif (p)\r\nmemcpy(p, src, len);\r\nreturn p;\r\n}
