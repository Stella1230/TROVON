static const char *vga_iostate_to_str(unsigned int iostate)\r\n{\r\niostate &= VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\r\nswitch (iostate) {\r\ncase VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM:\r\nreturn "io+mem";\r\ncase VGA_RSRC_LEGACY_IO:\r\nreturn "io";\r\ncase VGA_RSRC_LEGACY_MEM:\r\nreturn "mem";\r\n}\r\nreturn "none";\r\n}\r\nstatic int vga_str_to_iostate(char *buf, int str_size, int *io_state)\r\n{\r\nif (strncmp(buf, "none", 4) == 0) {\r\n*io_state = VGA_RSRC_NONE;\r\nreturn 1;\r\n}\r\nif (strncmp(buf, "io+mem", 6) == 0)\r\ngoto both;\r\nelse if (strncmp(buf, "io", 2) == 0)\r\ngoto both;\r\nelse if (strncmp(buf, "mem", 3) == 0)\r\ngoto both;\r\nreturn 0;\r\nboth:\r\n*io_state = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\r\nreturn 1;\r\n}\r\nstatic struct vga_device *vgadev_find(struct pci_dev *pdev)\r\n{\r\nstruct vga_device *vgadev;\r\nlist_for_each_entry(vgadev, &vga_list, list)\r\nif (pdev == vgadev->pdev)\r\nreturn vgadev;\r\nreturn NULL;\r\n}\r\nstruct pci_dev *vga_default_device(void)\r\n{\r\nreturn vga_default;\r\n}\r\nvoid vga_set_default_device(struct pci_dev *pdev)\r\n{\r\nif (vga_default == pdev)\r\nreturn;\r\npci_dev_put(vga_default);\r\nvga_default = pci_dev_get(pdev);\r\n}\r\nstatic inline void vga_irq_set_state(struct vga_device *vgadev, bool state)\r\n{\r\nif (vgadev->irq_set_state)\r\nvgadev->irq_set_state(vgadev->cookie, state);\r\n}\r\nstatic void vga_check_first_use(void)\r\n{\r\nif (!vga_arbiter_used) {\r\nvga_arbiter_used = true;\r\nvga_arbiter_notify_clients();\r\n}\r\n}\r\nstatic struct vga_device *__vga_tryget(struct vga_device *vgadev,\r\nunsigned int rsrc)\r\n{\r\nunsigned int wants, legacy_wants, match;\r\nstruct vga_device *conflict;\r\nunsigned int pci_bits;\r\nu32 flags = 0;\r\nif ((rsrc & VGA_RSRC_NORMAL_IO) &&\r\n(vgadev->decodes & VGA_RSRC_LEGACY_IO))\r\nrsrc |= VGA_RSRC_LEGACY_IO;\r\nif ((rsrc & VGA_RSRC_NORMAL_MEM) &&\r\n(vgadev->decodes & VGA_RSRC_LEGACY_MEM))\r\nrsrc |= VGA_RSRC_LEGACY_MEM;\r\npr_debug("%s: %d\n", __func__, rsrc);\r\npr_debug("%s: owns: %d\n", __func__, vgadev->owns);\r\nwants = rsrc & ~vgadev->owns;\r\nif (wants == 0)\r\ngoto lock_them;\r\nlegacy_wants = wants & VGA_RSRC_LEGACY_MASK;\r\nif (legacy_wants == 0)\r\ngoto enable_them;\r\nlist_for_each_entry(conflict, &vga_list, list) {\r\nunsigned int lwants = legacy_wants;\r\nunsigned int change_bridge = 0;\r\nif (vgadev == conflict)\r\ncontinue;\r\nif (!vga_conflicts(vgadev->pdev, conflict->pdev))\r\ncontinue;\r\nif (vgadev->pdev->bus != conflict->pdev->bus) {\r\nchange_bridge = 1;\r\nlwants = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\r\n}\r\nif (conflict->locks & lwants)\r\nreturn conflict;\r\nWARN_ON(conflict->owns & ~conflict->decodes);\r\nmatch = lwants & conflict->owns;\r\nif (!match)\r\ncontinue;\r\nflags = 0;\r\npci_bits = 0;\r\nif (!conflict->bridge_has_one_vga) {\r\nvga_irq_set_state(conflict, false);\r\nflags |= PCI_VGA_STATE_CHANGE_DECODES;\r\nif (lwants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))\r\npci_bits |= PCI_COMMAND_MEMORY;\r\nif (lwants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))\r\npci_bits |= PCI_COMMAND_IO;\r\n}\r\nif (change_bridge)\r\nflags |= PCI_VGA_STATE_CHANGE_BRIDGE;\r\npci_set_vga_state(conflict->pdev, false, pci_bits, flags);\r\nconflict->owns &= ~lwants;\r\nif (lwants & VGA_RSRC_LEGACY_MEM)\r\nconflict->owns &= ~VGA_RSRC_NORMAL_MEM;\r\nif (lwants & VGA_RSRC_LEGACY_IO)\r\nconflict->owns &= ~VGA_RSRC_NORMAL_IO;\r\n}\r\nenable_them:\r\nflags = 0;\r\npci_bits = 0;\r\nif (!vgadev->bridge_has_one_vga) {\r\nflags |= PCI_VGA_STATE_CHANGE_DECODES;\r\nif (wants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))\r\npci_bits |= PCI_COMMAND_MEMORY;\r\nif (wants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))\r\npci_bits |= PCI_COMMAND_IO;\r\n}\r\nif (!!(wants & VGA_RSRC_LEGACY_MASK))\r\nflags |= PCI_VGA_STATE_CHANGE_BRIDGE;\r\npci_set_vga_state(vgadev->pdev, true, pci_bits, flags);\r\nif (!vgadev->bridge_has_one_vga) {\r\nvga_irq_set_state(vgadev, true);\r\n}\r\nvgadev->owns |= (wants & vgadev->decodes);\r\nlock_them:\r\nvgadev->locks |= (rsrc & VGA_RSRC_LEGACY_MASK);\r\nif (rsrc & VGA_RSRC_LEGACY_IO)\r\nvgadev->io_lock_cnt++;\r\nif (rsrc & VGA_RSRC_LEGACY_MEM)\r\nvgadev->mem_lock_cnt++;\r\nif (rsrc & VGA_RSRC_NORMAL_IO)\r\nvgadev->io_norm_cnt++;\r\nif (rsrc & VGA_RSRC_NORMAL_MEM)\r\nvgadev->mem_norm_cnt++;\r\nreturn NULL;\r\n}\r\nstatic void __vga_put(struct vga_device *vgadev, unsigned int rsrc)\r\n{\r\nunsigned int old_locks = vgadev->locks;\r\npr_debug("%s\n", __func__);\r\nif ((rsrc & VGA_RSRC_NORMAL_IO) && vgadev->io_norm_cnt > 0) {\r\nvgadev->io_norm_cnt--;\r\nif (vgadev->decodes & VGA_RSRC_LEGACY_IO)\r\nrsrc |= VGA_RSRC_LEGACY_IO;\r\n}\r\nif ((rsrc & VGA_RSRC_NORMAL_MEM) && vgadev->mem_norm_cnt > 0) {\r\nvgadev->mem_norm_cnt--;\r\nif (vgadev->decodes & VGA_RSRC_LEGACY_MEM)\r\nrsrc |= VGA_RSRC_LEGACY_MEM;\r\n}\r\nif ((rsrc & VGA_RSRC_LEGACY_IO) && vgadev->io_lock_cnt > 0)\r\nvgadev->io_lock_cnt--;\r\nif ((rsrc & VGA_RSRC_LEGACY_MEM) && vgadev->mem_lock_cnt > 0)\r\nvgadev->mem_lock_cnt--;\r\nif (vgadev->io_lock_cnt == 0)\r\nvgadev->locks &= ~VGA_RSRC_LEGACY_IO;\r\nif (vgadev->mem_lock_cnt == 0)\r\nvgadev->locks &= ~VGA_RSRC_LEGACY_MEM;\r\nif (old_locks != vgadev->locks)\r\nwake_up_all(&vga_wait_queue);\r\n}\r\nint vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)\r\n{\r\nstruct vga_device *vgadev, *conflict;\r\nunsigned long flags;\r\nwait_queue_t wait;\r\nint rc = 0;\r\nvga_check_first_use();\r\nif (pdev == NULL)\r\npdev = vga_default_device();\r\nif (pdev == NULL)\r\nreturn 0;\r\nfor (;;) {\r\nspin_lock_irqsave(&vga_lock, flags);\r\nvgadev = vgadev_find(pdev);\r\nif (vgadev == NULL) {\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\nconflict = __vga_tryget(vgadev, rsrc);\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nif (conflict == NULL)\r\nbreak;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&vga_wait_queue, &wait);\r\nset_current_state(interruptible ?\r\nTASK_INTERRUPTIBLE :\r\nTASK_UNINTERRUPTIBLE);\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\nschedule();\r\nremove_wait_queue(&vga_wait_queue, &wait);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nreturn rc;\r\n}\r\nint vga_tryget(struct pci_dev *pdev, unsigned int rsrc)\r\n{\r\nstruct vga_device *vgadev;\r\nunsigned long flags;\r\nint rc = 0;\r\nvga_check_first_use();\r\nif (pdev == NULL)\r\npdev = vga_default_device();\r\nif (pdev == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&vga_lock, flags);\r\nvgadev = vgadev_find(pdev);\r\nif (vgadev == NULL) {\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\nif (__vga_tryget(vgadev, rsrc))\r\nrc = -EBUSY;\r\nbail:\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nreturn rc;\r\n}\r\nvoid vga_put(struct pci_dev *pdev, unsigned int rsrc)\r\n{\r\nstruct vga_device *vgadev;\r\nunsigned long flags;\r\nif (pdev == NULL)\r\npdev = vga_default_device();\r\nif (pdev == NULL)\r\nreturn;\r\nspin_lock_irqsave(&vga_lock, flags);\r\nvgadev = vgadev_find(pdev);\r\nif (vgadev == NULL)\r\ngoto bail;\r\n__vga_put(vgadev, rsrc);\r\nbail:\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\n}\r\nstatic void vga_arbiter_check_bridge_sharing(struct vga_device *vgadev)\r\n{\r\nstruct vga_device *same_bridge_vgadev;\r\nstruct pci_bus *new_bus, *bus;\r\nstruct pci_dev *new_bridge, *bridge;\r\nvgadev->bridge_has_one_vga = true;\r\nif (list_empty(&vga_list))\r\nreturn;\r\nnew_bus = vgadev->pdev->bus;\r\nwhile (new_bus) {\r\nnew_bridge = new_bus->self;\r\nlist_for_each_entry(same_bridge_vgadev, &vga_list, list) {\r\nbus = same_bridge_vgadev->pdev->bus;\r\nbridge = bus->self;\r\nif (new_bridge == bridge) {\r\nsame_bridge_vgadev->bridge_has_one_vga = false;\r\n}\r\nwhile (bus) {\r\nbridge = bus->self;\r\nif (bridge) {\r\nif (bridge == vgadev->pdev->bus->self)\r\nvgadev->bridge_has_one_vga = false;\r\n}\r\nbus = bus->parent;\r\n}\r\n}\r\nnew_bus = new_bus->parent;\r\n}\r\n}\r\nstatic bool vga_arbiter_add_pci_device(struct pci_dev *pdev)\r\n{\r\nstruct vga_device *vgadev;\r\nunsigned long flags;\r\nstruct pci_bus *bus;\r\nstruct pci_dev *bridge;\r\nu16 cmd;\r\nif ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\r\nreturn false;\r\nvgadev = kmalloc(sizeof(struct vga_device), GFP_KERNEL);\r\nif (vgadev == NULL) {\r\npr_err("vgaarb: failed to allocate pci device\n");\r\nreturn false;\r\n}\r\nmemset(vgadev, 0, sizeof(*vgadev));\r\nspin_lock_irqsave(&vga_lock, flags);\r\nif (vgadev_find(pdev) != NULL) {\r\nBUG_ON(1);\r\ngoto fail;\r\n}\r\nvgadev->pdev = pdev;\r\nvgadev->decodes = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |\r\nVGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\r\nvga_decode_count++;\r\npci_read_config_word(pdev, PCI_COMMAND, &cmd);\r\nif (cmd & PCI_COMMAND_IO)\r\nvgadev->owns |= VGA_RSRC_LEGACY_IO;\r\nif (cmd & PCI_COMMAND_MEMORY)\r\nvgadev->owns |= VGA_RSRC_LEGACY_MEM;\r\nbus = pdev->bus;\r\nwhile (bus) {\r\nbridge = bus->self;\r\nif (bridge) {\r\nu16 l;\r\npci_read_config_word(bridge, PCI_BRIDGE_CONTROL,\r\n&l);\r\nif (!(l & PCI_BRIDGE_CTL_VGA)) {\r\nvgadev->owns = 0;\r\nbreak;\r\n}\r\n}\r\nbus = bus->parent;\r\n}\r\n#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE\r\nif (vga_default == NULL &&\r\n((vgadev->owns & VGA_RSRC_LEGACY_MASK) == VGA_RSRC_LEGACY_MASK))\r\nvga_set_default_device(pdev);\r\n#endif\r\nvga_arbiter_check_bridge_sharing(vgadev);\r\nlist_add(&vgadev->list, &vga_list);\r\nvga_count++;\r\npr_info("vgaarb: device added: PCI:%s,decodes=%s,owns=%s,locks=%s\n",\r\npci_name(pdev),\r\nvga_iostate_to_str(vgadev->decodes),\r\nvga_iostate_to_str(vgadev->owns),\r\nvga_iostate_to_str(vgadev->locks));\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nreturn true;\r\nfail:\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nkfree(vgadev);\r\nreturn false;\r\n}\r\nstatic bool vga_arbiter_del_pci_device(struct pci_dev *pdev)\r\n{\r\nstruct vga_device *vgadev;\r\nunsigned long flags;\r\nbool ret = true;\r\nspin_lock_irqsave(&vga_lock, flags);\r\nvgadev = vgadev_find(pdev);\r\nif (vgadev == NULL) {\r\nret = false;\r\ngoto bail;\r\n}\r\n#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE\r\nif (vga_default == pdev)\r\nvga_set_default_device(NULL);\r\n#endif\r\nif (vgadev->decodes & (VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM))\r\nvga_decode_count--;\r\nlist_del(&vgadev->list);\r\nvga_count--;\r\nvga_arb_device_card_gone(pdev);\r\nwake_up_all(&vga_wait_queue);\r\nbail:\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nkfree(vgadev);\r\nreturn ret;\r\n}\r\nstatic inline void vga_update_device_decodes(struct vga_device *vgadev,\r\nint new_decodes)\r\n{\r\nint old_decodes;\r\nstruct vga_device *new_vgadev, *conflict;\r\nold_decodes = vgadev->decodes;\r\nvgadev->decodes = new_decodes;\r\npr_info("vgaarb: device changed decodes: PCI:%s,olddecodes=%s,decodes=%s:owns=%s\n",\r\npci_name(vgadev->pdev),\r\nvga_iostate_to_str(old_decodes),\r\nvga_iostate_to_str(vgadev->decodes),\r\nvga_iostate_to_str(vgadev->owns));\r\nif ((vgadev->owns & old_decodes) && (vga_count > 1)) {\r\nvgadev->owns &= ~old_decodes;\r\nlist_for_each_entry(new_vgadev, &vga_list, list) {\r\nif ((new_vgadev != vgadev) &&\r\n(new_vgadev->decodes & VGA_RSRC_LEGACY_MASK)) {\r\npr_info("vgaarb: transferring owner from PCI:%s to PCI:%s\n", pci_name(vgadev->pdev), pci_name(new_vgadev->pdev));\r\nconflict = __vga_tryget(new_vgadev, VGA_RSRC_LEGACY_MASK);\r\nif (!conflict)\r\n__vga_put(new_vgadev, VGA_RSRC_LEGACY_MASK);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (old_decodes != new_decodes) {\r\nif (new_decodes & (VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM))\r\nvga_decode_count++;\r\nelse\r\nvga_decode_count--;\r\n}\r\npr_debug("vgaarb: decoding count now is: %d\n", vga_decode_count);\r\n}\r\nstatic void __vga_set_legacy_decoding(struct pci_dev *pdev, unsigned int decodes, bool userspace)\r\n{\r\nstruct vga_device *vgadev;\r\nunsigned long flags;\r\ndecodes &= VGA_RSRC_LEGACY_MASK;\r\nspin_lock_irqsave(&vga_lock, flags);\r\nvgadev = vgadev_find(pdev);\r\nif (vgadev == NULL)\r\ngoto bail;\r\nif (userspace && vgadev->set_vga_decode)\r\ngoto bail;\r\nvga_update_device_decodes(vgadev, decodes);\r\nbail:\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\n}\r\nvoid vga_set_legacy_decoding(struct pci_dev *pdev, unsigned int decodes)\r\n{\r\n__vga_set_legacy_decoding(pdev, decodes, false);\r\n}\r\nstatic int vga_pci_str_to_vars(char *buf, int count, unsigned int *domain,\r\nunsigned int *bus, unsigned int *devfn)\r\n{\r\nint n;\r\nunsigned int slot, func;\r\nn = sscanf(buf, "PCI:%x:%x:%x.%x", domain, bus, &slot, &func);\r\nif (n != 4)\r\nreturn 0;\r\n*devfn = PCI_DEVFN(slot, func);\r\nreturn 1;\r\n}\r\nstatic ssize_t vga_arb_read(struct file *file, char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct vga_arb_private *priv = file->private_data;\r\nstruct vga_device *vgadev;\r\nstruct pci_dev *pdev;\r\nunsigned long flags;\r\nsize_t len;\r\nint rc;\r\nchar *lbuf;\r\nlbuf = kmalloc(1024, GFP_KERNEL);\r\nif (lbuf == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&vga_lock, flags);\r\npdev = priv->target;\r\nif (pdev == NULL || pdev == PCI_INVALID_CARD) {\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nlen = sprintf(lbuf, "invalid");\r\ngoto done;\r\n}\r\nvgadev = vgadev_find(pdev);\r\nif (vgadev == NULL) {\r\nif (pdev == priv->target)\r\nvga_arb_device_card_gone(pdev);\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\nlen = sprintf(lbuf, "invalid");\r\ngoto done;\r\n}\r\nlen = snprintf(lbuf, 1024,\r\n"count:%d,PCI:%s,decodes=%s,owns=%s,locks=%s(%d:%d)\n",\r\nvga_decode_count, pci_name(pdev),\r\nvga_iostate_to_str(vgadev->decodes),\r\nvga_iostate_to_str(vgadev->owns),\r\nvga_iostate_to_str(vgadev->locks),\r\nvgadev->io_lock_cnt, vgadev->mem_lock_cnt);\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\ndone:\r\nif (len > count)\r\nlen = count;\r\nrc = copy_to_user(buf, lbuf, len);\r\nkfree(lbuf);\r\nif (rc)\r\nreturn -EFAULT;\r\nreturn len;\r\n}\r\nstatic ssize_t vga_arb_write(struct file *file, const char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct vga_arb_private *priv = file->private_data;\r\nstruct vga_arb_user_card *uc = NULL;\r\nstruct pci_dev *pdev;\r\nunsigned int io_state;\r\nchar *kbuf, *curr_pos;\r\nsize_t remaining = count;\r\nint ret_val;\r\nint i;\r\nkbuf = kmalloc(count + 1, GFP_KERNEL);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kbuf, buf, count)) {\r\nkfree(kbuf);\r\nreturn -EFAULT;\r\n}\r\ncurr_pos = kbuf;\r\nkbuf[count] = '\0';\r\nif (strncmp(curr_pos, "lock ", 5) == 0) {\r\ncurr_pos += 5;\r\nremaining -= 5;\r\npr_debug("client 0x%p called 'lock'\n", priv);\r\nif (!vga_str_to_iostate(curr_pos, remaining, &io_state)) {\r\nret_val = -EPROTO;\r\ngoto done;\r\n}\r\nif (io_state == VGA_RSRC_NONE) {\r\nret_val = -EPROTO;\r\ngoto done;\r\n}\r\npdev = priv->target;\r\nif (priv->target == NULL) {\r\nret_val = -ENODEV;\r\ngoto done;\r\n}\r\nvga_get_uninterruptible(pdev, io_state);\r\nfor (i = 0; i < MAX_USER_CARDS; i++) {\r\nif (priv->cards[i].pdev == pdev) {\r\nif (io_state & VGA_RSRC_LEGACY_IO)\r\npriv->cards[i].io_cnt++;\r\nif (io_state & VGA_RSRC_LEGACY_MEM)\r\npriv->cards[i].mem_cnt++;\r\nbreak;\r\n}\r\n}\r\nret_val = count;\r\ngoto done;\r\n} else if (strncmp(curr_pos, "unlock ", 7) == 0) {\r\ncurr_pos += 7;\r\nremaining -= 7;\r\npr_debug("client 0x%p called 'unlock'\n", priv);\r\nif (strncmp(curr_pos, "all", 3) == 0)\r\nio_state = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\r\nelse {\r\nif (!vga_str_to_iostate\r\n(curr_pos, remaining, &io_state)) {\r\nret_val = -EPROTO;\r\ngoto done;\r\n}\r\n}\r\npdev = priv->target;\r\nif (priv->target == NULL) {\r\nret_val = -ENODEV;\r\ngoto done;\r\n}\r\nfor (i = 0; i < MAX_USER_CARDS; i++) {\r\nif (priv->cards[i].pdev == pdev)\r\nuc = &priv->cards[i];\r\n}\r\nif (!uc) {\r\nret_val = -EINVAL;\r\ngoto done;\r\n}\r\nif (io_state & VGA_RSRC_LEGACY_IO && uc->io_cnt == 0) {\r\nret_val = -EINVAL;\r\ngoto done;\r\n}\r\nif (io_state & VGA_RSRC_LEGACY_MEM && uc->mem_cnt == 0) {\r\nret_val = -EINVAL;\r\ngoto done;\r\n}\r\nvga_put(pdev, io_state);\r\nif (io_state & VGA_RSRC_LEGACY_IO)\r\nuc->io_cnt--;\r\nif (io_state & VGA_RSRC_LEGACY_MEM)\r\nuc->mem_cnt--;\r\nret_val = count;\r\ngoto done;\r\n} else if (strncmp(curr_pos, "trylock ", 8) == 0) {\r\ncurr_pos += 8;\r\nremaining -= 8;\r\npr_debug("client 0x%p called 'trylock'\n", priv);\r\nif (!vga_str_to_iostate(curr_pos, remaining, &io_state)) {\r\nret_val = -EPROTO;\r\ngoto done;\r\n}\r\npdev = priv->target;\r\nif (priv->target == NULL) {\r\nret_val = -ENODEV;\r\ngoto done;\r\n}\r\nif (vga_tryget(pdev, io_state)) {\r\nfor (i = 0; i < MAX_USER_CARDS; i++) {\r\nif (priv->cards[i].pdev == pdev) {\r\nif (io_state & VGA_RSRC_LEGACY_IO)\r\npriv->cards[i].io_cnt++;\r\nif (io_state & VGA_RSRC_LEGACY_MEM)\r\npriv->cards[i].mem_cnt++;\r\nbreak;\r\n}\r\n}\r\nret_val = count;\r\ngoto done;\r\n} else {\r\nret_val = -EBUSY;\r\ngoto done;\r\n}\r\n} else if (strncmp(curr_pos, "target ", 7) == 0) {\r\nunsigned int domain, bus, devfn;\r\nstruct vga_device *vgadev;\r\ncurr_pos += 7;\r\nremaining -= 7;\r\npr_debug("client 0x%p called 'target'\n", priv);\r\nif (!strncmp(curr_pos, "default", 7))\r\npdev = pci_dev_get(vga_default_device());\r\nelse {\r\nif (!vga_pci_str_to_vars(curr_pos, remaining,\r\n&domain, &bus, &devfn)) {\r\nret_val = -EPROTO;\r\ngoto done;\r\n}\r\npr_debug("vgaarb: %s ==> %x:%x:%x.%x\n", curr_pos,\r\ndomain, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\r\npdev = pci_get_domain_bus_and_slot(domain, bus, devfn);\r\npr_debug("vgaarb: pdev %p\n", pdev);\r\nif (!pdev) {\r\npr_err("vgaarb: invalid PCI address %x:%x:%x\n",\r\ndomain, bus, devfn);\r\nret_val = -ENODEV;\r\ngoto done;\r\n}\r\n}\r\nvgadev = vgadev_find(pdev);\r\npr_debug("vgaarb: vgadev %p\n", vgadev);\r\nif (vgadev == NULL) {\r\npr_err("vgaarb: this pci device is not a vga device\n");\r\npci_dev_put(pdev);\r\nret_val = -ENODEV;\r\ngoto done;\r\n}\r\npriv->target = pdev;\r\nfor (i = 0; i < MAX_USER_CARDS; i++) {\r\nif (priv->cards[i].pdev == pdev)\r\nbreak;\r\nif (priv->cards[i].pdev == NULL) {\r\npriv->cards[i].pdev = pdev;\r\npriv->cards[i].io_cnt = 0;\r\npriv->cards[i].mem_cnt = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_USER_CARDS) {\r\npr_err("vgaarb: maximum user cards (%d) number reached!\n",\r\nMAX_USER_CARDS);\r\npci_dev_put(pdev);\r\nret_val = -ENOMEM;\r\ngoto done;\r\n}\r\nret_val = count;\r\npci_dev_put(pdev);\r\ngoto done;\r\n} else if (strncmp(curr_pos, "decodes ", 8) == 0) {\r\ncurr_pos += 8;\r\nremaining -= 8;\r\npr_debug("vgaarb: client 0x%p called 'decodes'\n", priv);\r\nif (!vga_str_to_iostate(curr_pos, remaining, &io_state)) {\r\nret_val = -EPROTO;\r\ngoto done;\r\n}\r\npdev = priv->target;\r\nif (priv->target == NULL) {\r\nret_val = -ENODEV;\r\ngoto done;\r\n}\r\n__vga_set_legacy_decoding(pdev, io_state, true);\r\nret_val = count;\r\ngoto done;\r\n}\r\nkfree(kbuf);\r\nreturn -EPROTO;\r\ndone:\r\nkfree(kbuf);\r\nreturn ret_val;\r\n}\r\nstatic unsigned int vga_arb_fpoll(struct file *file, poll_table * wait)\r\n{\r\nstruct vga_arb_private *priv = file->private_data;\r\npr_debug("%s\n", __func__);\r\nif (priv == NULL)\r\nreturn -ENODEV;\r\npoll_wait(file, &vga_wait_queue, wait);\r\nreturn POLLIN;\r\n}\r\nstatic int vga_arb_open(struct inode *inode, struct file *file)\r\n{\r\nstruct vga_arb_private *priv;\r\nunsigned long flags;\r\npr_debug("%s\n", __func__);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\nfile->private_data = priv;\r\nspin_lock_irqsave(&vga_user_lock, flags);\r\nlist_add(&priv->list, &vga_user_list);\r\nspin_unlock_irqrestore(&vga_user_lock, flags);\r\npriv->target = vga_default_device();\r\npriv->cards[0].pdev = priv->target;\r\npriv->cards[0].io_cnt = 0;\r\npriv->cards[0].mem_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic int vga_arb_release(struct inode *inode, struct file *file)\r\n{\r\nstruct vga_arb_private *priv = file->private_data;\r\nstruct vga_arb_user_card *uc;\r\nunsigned long flags;\r\nint i;\r\npr_debug("%s\n", __func__);\r\nif (priv == NULL)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&vga_user_lock, flags);\r\nlist_del(&priv->list);\r\nfor (i = 0; i < MAX_USER_CARDS; i++) {\r\nuc = &priv->cards[i];\r\nif (uc->pdev == NULL)\r\ncontinue;\r\npr_debug("uc->io_cnt == %d, uc->mem_cnt == %d\n",\r\nuc->io_cnt, uc->mem_cnt);\r\nwhile (uc->io_cnt--)\r\nvga_put(uc->pdev, VGA_RSRC_LEGACY_IO);\r\nwhile (uc->mem_cnt--)\r\nvga_put(uc->pdev, VGA_RSRC_LEGACY_MEM);\r\n}\r\nspin_unlock_irqrestore(&vga_user_lock, flags);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic void vga_arb_device_card_gone(struct pci_dev *pdev)\r\n{\r\n}\r\nstatic void vga_arbiter_notify_clients(void)\r\n{\r\nstruct vga_device *vgadev;\r\nunsigned long flags;\r\nuint32_t new_decodes;\r\nbool new_state;\r\nif (!vga_arbiter_used)\r\nreturn;\r\nspin_lock_irqsave(&vga_lock, flags);\r\nlist_for_each_entry(vgadev, &vga_list, list) {\r\nif (vga_count > 1)\r\nnew_state = false;\r\nelse\r\nnew_state = true;\r\nif (vgadev->set_vga_decode) {\r\nnew_decodes = vgadev->set_vga_decode(vgadev->cookie, new_state);\r\nvga_update_device_decodes(vgadev, new_decodes);\r\n}\r\n}\r\nspin_unlock_irqrestore(&vga_lock, flags);\r\n}\r\nstatic int pci_notify(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct device *dev = data;\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nbool notify = false;\r\npr_debug("%s\n", __func__);\r\nif (action == BUS_NOTIFY_ADD_DEVICE)\r\nnotify = vga_arbiter_add_pci_device(pdev);\r\nelse if (action == BUS_NOTIFY_DEL_DEVICE)\r\nnotify = vga_arbiter_del_pci_device(pdev);\r\nif (notify)\r\nvga_arbiter_notify_clients();\r\nreturn 0;\r\n}\r\nstatic int __init vga_arb_device_init(void)\r\n{\r\nint rc;\r\nstruct pci_dev *pdev;\r\nstruct vga_device *vgadev;\r\nrc = misc_register(&vga_arb_device);\r\nif (rc < 0)\r\npr_err("vgaarb: error %d registering device\n", rc);\r\nbus_register_notifier(&pci_bus_type, &pci_notifier);\r\npdev = NULL;\r\nwhile ((pdev =\r\npci_get_subsys(PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\r\nPCI_ANY_ID, pdev)) != NULL)\r\nvga_arbiter_add_pci_device(pdev);\r\npr_info("vgaarb: loaded\n");\r\nlist_for_each_entry(vgadev, &vga_list, list) {\r\nif (vgadev->bridge_has_one_vga)\r\npr_info("vgaarb: bridge control possible %s\n", pci_name(vgadev->pdev));\r\nelse\r\npr_info("vgaarb: no bridge control possible %s\n", pci_name(vgadev->pdev));\r\n}\r\nreturn rc;\r\n}
