static void ptrace_child(void)\r\n{\r\nint ret;\r\nint pid = os_getpid(), ppid = getppid();\r\nint sc_result;\r\nif (change_sig(SIGWINCH, 0) < 0 ||\r\nptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {\r\nperror("ptrace");\r\nkill(pid, SIGKILL);\r\n}\r\nkill(pid, SIGSTOP);\r\nsc_result = os_getpid();\r\nif (sc_result == pid)\r\nret = 1;\r\nelse if (sc_result == ppid)\r\nret = 0;\r\nelse\r\nret = 2;\r\nexit(ret);\r\n}\r\nstatic void fatal_perror(const char *str)\r\n{\r\nperror(str);\r\nexit(1);\r\n}\r\nstatic void fatal(char *fmt, ...)\r\n{\r\nva_list list;\r\nva_start(list, fmt);\r\nvfprintf(stderr, fmt, list);\r\nva_end(list);\r\nexit(1);\r\n}\r\nstatic void non_fatal(char *fmt, ...)\r\n{\r\nva_list list;\r\nva_start(list, fmt);\r\nvfprintf(stderr, fmt, list);\r\nva_end(list);\r\n}\r\nstatic int start_ptraced_child(void)\r\n{\r\nint pid, n, status;\r\npid = fork();\r\nif (pid == 0)\r\nptrace_child();\r\nelse if (pid < 0)\r\nfatal_perror("start_ptraced_child : fork failed");\r\nCATCH_EINTR(n = waitpid(pid, &status, WUNTRACED));\r\nif (n < 0)\r\nfatal_perror("check_ptrace : waitpid failed");\r\nif (!WIFSTOPPED(status) || (WSTOPSIG(status) != SIGSTOP))\r\nfatal("check_ptrace : expected SIGSTOP, got status = %d",\r\nstatus);\r\nreturn pid;\r\n}\r\nstatic int stop_ptraced_child(int pid, int exitcode, int mustexit)\r\n{\r\nint status, n, ret = 0;\r\nif (ptrace(PTRACE_CONT, pid, 0, 0) < 0) {\r\nperror("stop_ptraced_child : ptrace failed");\r\nreturn -1;\r\n}\r\nCATCH_EINTR(n = waitpid(pid, &status, 0));\r\nif (!WIFEXITED(status) || (WEXITSTATUS(status) != exitcode)) {\r\nint exit_with = WEXITSTATUS(status);\r\nif (exit_with == 2)\r\nnon_fatal("check_ptrace : child exited with status 2. "\r\n"\nDisabling SYSEMU support.\n");\r\nnon_fatal("check_ptrace : child exited with exitcode %d, while "\r\n"expecting %d; status 0x%x\n", exit_with,\r\nexitcode, status);\r\nif (mustexit)\r\nexit(1);\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init skas0_cmd_param(char *str, int* add)\r\n{\r\ndisable_ptrace_faultinfo = 1;\r\ndisable_ptrace_ldt = 1;\r\ndisable_proc_mm = 1;\r\ndisable_switch_mm = 1;\r\nreturn 0;\r\n}\r\nstatic int __init nosysemu_cmd_param(char *str, int* add)\r\n{\r\nforce_sysemu_disabled = 1;\r\nreturn 0;\r\n}\r\nstatic void __init check_sysemu(void)\r\n{\r\nunsigned long regs[MAX_REG_NR];\r\nint pid, n, status, count=0;\r\nnon_fatal("Checking syscall emulation patch for ptrace...");\r\nsysemu_supported = 0;\r\npid = start_ptraced_child();\r\nif (ptrace(PTRACE_SYSEMU, pid, 0, 0) < 0)\r\ngoto fail;\r\nCATCH_EINTR(n = waitpid(pid, &status, WUNTRACED));\r\nif (n < 0)\r\nfatal_perror("check_sysemu : wait failed");\r\nif (!WIFSTOPPED(status) || (WSTOPSIG(status) != SIGTRAP))\r\nfatal("check_sysemu : expected SIGTRAP, got status = %d\n",\r\nstatus);\r\nif (ptrace(PTRACE_GETREGS, pid, 0, regs) < 0)\r\nfatal_perror("check_sysemu : PTRACE_GETREGS failed");\r\nif (PT_SYSCALL_NR(regs) != __NR_getpid) {\r\nnon_fatal("check_sysemu got system call number %d, "\r\n"expected %d...", PT_SYSCALL_NR(regs), __NR_getpid);\r\ngoto fail;\r\n}\r\nn = ptrace(PTRACE_POKEUSER, pid, PT_SYSCALL_RET_OFFSET, os_getpid());\r\nif (n < 0) {\r\nnon_fatal("check_sysemu : failed to modify system call "\r\n"return");\r\ngoto fail;\r\n}\r\nif (stop_ptraced_child(pid, 0, 0) < 0)\r\ngoto fail_stopped;\r\nsysemu_supported = 1;\r\nnon_fatal("OK\n");\r\nset_using_sysemu(!force_sysemu_disabled);\r\nnon_fatal("Checking advanced syscall emulation patch for ptrace...");\r\npid = start_ptraced_child();\r\nif ((ptrace(PTRACE_OLDSETOPTIONS, pid, 0,\r\n(void *) PTRACE_O_TRACESYSGOOD) < 0))\r\nfatal_perror("check_sysemu: PTRACE_OLDSETOPTIONS failed");\r\nwhile (1) {\r\ncount++;\r\nif (ptrace(PTRACE_SYSEMU_SINGLESTEP, pid, 0, 0) < 0)\r\ngoto fail;\r\nCATCH_EINTR(n = waitpid(pid, &status, WUNTRACED));\r\nif (n < 0)\r\nfatal_perror("check_sysemu: wait failed");\r\nif (WIFSTOPPED(status) &&\r\n(WSTOPSIG(status) == (SIGTRAP|0x80))) {\r\nif (!count) {\r\nnon_fatal("check_sysemu: SYSEMU_SINGLESTEP "\r\n"doesn't singlestep");\r\ngoto fail;\r\n}\r\nn = ptrace(PTRACE_POKEUSER, pid, PT_SYSCALL_RET_OFFSET,\r\nos_getpid());\r\nif (n < 0)\r\nfatal_perror("check_sysemu : failed to modify "\r\n"system call return");\r\nbreak;\r\n}\r\nelse if (WIFSTOPPED(status) && (WSTOPSIG(status) == SIGTRAP))\r\ncount++;\r\nelse {\r\nnon_fatal("check_sysemu: expected SIGTRAP or "\r\n"(SIGTRAP | 0x80), got status = %d\n",\r\nstatus);\r\ngoto fail;\r\n}\r\n}\r\nif (stop_ptraced_child(pid, 0, 0) < 0)\r\ngoto fail_stopped;\r\nsysemu_supported = 2;\r\nnon_fatal("OK\n");\r\nif (!force_sysemu_disabled)\r\nset_using_sysemu(sysemu_supported);\r\nreturn;\r\nfail:\r\nstop_ptraced_child(pid, 1, 0);\r\nfail_stopped:\r\nnon_fatal("missing\n");\r\n}\r\nstatic void __init check_ptrace(void)\r\n{\r\nint pid, syscall, n, status;\r\nnon_fatal("Checking that ptrace can change system call numbers...");\r\npid = start_ptraced_child();\r\nif ((ptrace(PTRACE_OLDSETOPTIONS, pid, 0,\r\n(void *) PTRACE_O_TRACESYSGOOD) < 0))\r\nfatal_perror("check_ptrace: PTRACE_OLDSETOPTIONS failed");\r\nwhile (1) {\r\nif (ptrace(PTRACE_SYSCALL, pid, 0, 0) < 0)\r\nfatal_perror("check_ptrace : ptrace failed");\r\nCATCH_EINTR(n = waitpid(pid, &status, WUNTRACED));\r\nif (n < 0)\r\nfatal_perror("check_ptrace : wait failed");\r\nif (!WIFSTOPPED(status) ||\r\n(WSTOPSIG(status) != (SIGTRAP | 0x80)))\r\nfatal("check_ptrace : expected (SIGTRAP|0x80), "\r\n"got status = %d", status);\r\nsyscall = ptrace(PTRACE_PEEKUSER, pid, PT_SYSCALL_NR_OFFSET,\r\n0);\r\nif (syscall == __NR_getpid) {\r\nn = ptrace(PTRACE_POKEUSER, pid, PT_SYSCALL_NR_OFFSET,\r\n__NR_getppid);\r\nif (n < 0)\r\nfatal_perror("check_ptrace : failed to modify "\r\n"system call");\r\nbreak;\r\n}\r\n}\r\nstop_ptraced_child(pid, 0, 1);\r\nnon_fatal("OK\n");\r\ncheck_sysemu();\r\n}\r\nstatic void __init check_coredump_limit(void)\r\n{\r\nstruct rlimit lim;\r\nint err = getrlimit(RLIMIT_CORE, &lim);\r\nif (err) {\r\nperror("Getting core dump limit");\r\nreturn;\r\n}\r\nprintf("Core dump limits :\n\tsoft - ");\r\nif (lim.rlim_cur == RLIM_INFINITY)\r\nprintf("NONE\n");\r\nelse printf("%lu\n", lim.rlim_cur);\r\nprintf("\thard - ");\r\nif (lim.rlim_max == RLIM_INFINITY)\r\nprintf("NONE\n");\r\nelse printf("%lu\n", lim.rlim_max);\r\n}\r\nvoid __init os_early_checks(void)\r\n{\r\nint pid;\r\ncheck_coredump_limit();\r\ncheck_ptrace();\r\ncheck_tmpexec();\r\npid = start_ptraced_child();\r\nif (init_registers(pid))\r\nfatal("Failed to initialize default registers");\r\nstop_ptraced_child(pid, 1, 1);\r\n}\r\nstatic int __init noprocmm_cmd_param(char *str, int* add)\r\n{\r\ndisable_proc_mm = 1;\r\nreturn 0;\r\n}\r\nstatic int __init noptracefaultinfo_cmd_param(char *str, int* add)\r\n{\r\ndisable_ptrace_faultinfo = 1;\r\nreturn 0;\r\n}\r\nstatic int __init noptraceldt_cmd_param(char *str, int* add)\r\n{\r\ndisable_ptrace_ldt = 1;\r\nreturn 0;\r\n}\r\nstatic inline void check_skas3_ptrace_faultinfo(void)\r\n{\r\nstruct ptrace_faultinfo fi;\r\nint pid, n;\r\nnon_fatal(" - PTRACE_FAULTINFO...");\r\npid = start_ptraced_child();\r\nn = ptrace(PTRACE_FAULTINFO, pid, 0, &fi);\r\nif (n < 0) {\r\nif (errno == EIO)\r\nnon_fatal("not found\n");\r\nelse\r\nperror("not found");\r\n} else if (disable_ptrace_faultinfo)\r\nnon_fatal("found but disabled on command line\n");\r\nelse {\r\nptrace_faultinfo = 1;\r\nnon_fatal("found\n");\r\n}\r\nstop_ptraced_child(pid, 1, 1);\r\n}\r\nstatic inline void check_skas3_ptrace_ldt(void)\r\n{\r\n#ifdef PTRACE_LDT\r\nint pid, n;\r\nunsigned char ldtbuf[40];\r\nstruct ptrace_ldt ldt_op = (struct ptrace_ldt) {\r\n.func = 2,\r\n.ptr = ldtbuf,\r\n.bytecount = sizeof(ldtbuf)};\r\nnon_fatal(" - PTRACE_LDT...");\r\npid = start_ptraced_child();\r\nn = ptrace(PTRACE_LDT, pid, 0, (unsigned long) &ldt_op);\r\nif (n < 0) {\r\nif (errno == EIO)\r\nnon_fatal("not found\n");\r\nelse\r\nperror("not found");\r\n} else if (disable_ptrace_ldt)\r\nnon_fatal("found, but use is disabled\n");\r\nelse {\r\nptrace_ldt = 1;\r\nnon_fatal("found\n");\r\n}\r\nstop_ptraced_child(pid, 1, 1);\r\n#endif\r\n}\r\nstatic inline void check_skas3_proc_mm(void)\r\n{\r\nnon_fatal(" - /proc/mm...");\r\nif (access("/proc/mm", W_OK) < 0)\r\nperror("not found");\r\nelse if (disable_proc_mm)\r\nnon_fatal("found but disabled on command line\n");\r\nelse {\r\nproc_mm = 1;\r\nnon_fatal("found\n");\r\n}\r\n}\r\nvoid can_do_skas(void)\r\n{\r\nnon_fatal("Checking for the skas3 patch in the host:\n");\r\ncheck_skas3_proc_mm();\r\ncheck_skas3_ptrace_faultinfo();\r\ncheck_skas3_ptrace_ldt();\r\nif (!proc_mm || !ptrace_faultinfo || !ptrace_ldt)\r\nskas_needs_stub = 1;\r\n}\r\nint __init parse_iomem(char *str, int *add)\r\n{\r\nstruct iomem_region *new;\r\nstruct stat64 buf;\r\nchar *file, *driver;\r\nint fd, size;\r\ndriver = str;\r\nfile = strchr(str,',');\r\nif (file == NULL) {\r\nfprintf(stderr, "parse_iomem : failed to parse iomem\n");\r\ngoto out;\r\n}\r\n*file = '\0';\r\nfile++;\r\nfd = open(file, O_RDWR, 0);\r\nif (fd < 0) {\r\nperror("parse_iomem - Couldn't open io file");\r\ngoto out;\r\n}\r\nif (fstat64(fd, &buf) < 0) {\r\nperror("parse_iomem - cannot stat_fd file");\r\ngoto out_close;\r\n}\r\nnew = malloc(sizeof(*new));\r\nif (new == NULL) {\r\nperror("Couldn't allocate iomem_region struct");\r\ngoto out_close;\r\n}\r\nsize = (buf.st_size + UM_KERN_PAGE_SIZE) & ~(UM_KERN_PAGE_SIZE - 1);\r\n*new = ((struct iomem_region) { .next = iomem_regions,\r\n.driver = driver,\r\n.fd = fd,\r\n.size = size,\r\n.phys = 0,\r\n.virt = 0 });\r\niomem_regions = new;\r\niomem_size += new->size + UM_KERN_PAGE_SIZE;\r\nreturn 0;\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn 1;\r\n}
