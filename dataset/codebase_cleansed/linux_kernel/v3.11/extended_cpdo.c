static floatx80 floatx80_rsf(struct roundingData *roundData, floatx80 rFn, floatx80 rFm)\r\n{\r\nreturn floatx80_sub(roundData, rFm, rFn);\r\n}\r\nstatic floatx80 floatx80_rdv(struct roundingData *roundData, floatx80 rFn, floatx80 rFm)\r\n{\r\nreturn floatx80_div(roundData, rFm, rFn);\r\n}\r\nstatic floatx80 floatx80_mvf(struct roundingData *roundData, floatx80 rFm)\r\n{\r\nreturn rFm;\r\n}\r\nstatic floatx80 floatx80_mnf(struct roundingData *roundData, floatx80 rFm)\r\n{\r\nrFm.high ^= 0x8000;\r\nreturn rFm;\r\n}\r\nstatic floatx80 floatx80_abs(struct roundingData *roundData, floatx80 rFm)\r\n{\r\nrFm.high &= 0x7fff;\r\nreturn rFm;\r\n}\r\nunsigned int ExtendedCPDO(struct roundingData *roundData, const unsigned int opcode, FPREG * rFd)\r\n{\r\nFPA11 *fpa11 = GET_FPA11();\r\nfloatx80 rFm;\r\nunsigned int Fm, opc_mask_shift;\r\nFm = getFm(opcode);\r\nif (CONSTANT_FM(opcode)) {\r\nrFm = getExtendedConstant(Fm);\r\n} else {\r\nswitch (fpa11->fType[Fm]) {\r\ncase typeSingle:\r\nrFm = float32_to_floatx80(fpa11->fpreg[Fm].fSingle);\r\nbreak;\r\ncase typeDouble:\r\nrFm = float64_to_floatx80(fpa11->fpreg[Fm].fDouble);\r\nbreak;\r\ncase typeExtended:\r\nrFm = fpa11->fpreg[Fm].fExtended;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nopc_mask_shift = (opcode & MASK_ARITHMETIC_OPCODE) >> 20;\r\nif (!MONADIC_INSTRUCTION(opcode)) {\r\nunsigned int Fn = getFn(opcode);\r\nfloatx80 rFn;\r\nswitch (fpa11->fType[Fn]) {\r\ncase typeSingle:\r\nrFn = float32_to_floatx80(fpa11->fpreg[Fn].fSingle);\r\nbreak;\r\ncase typeDouble:\r\nrFn = float64_to_floatx80(fpa11->fpreg[Fn].fDouble);\r\nbreak;\r\ncase typeExtended:\r\nrFn = fpa11->fpreg[Fn].fExtended;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (dyadic_extended[opc_mask_shift]) {\r\nrFd->fExtended = dyadic_extended[opc_mask_shift](roundData, rFn, rFm);\r\n} else {\r\nreturn 0;\r\n}\r\n} else {\r\nif (monadic_extended[opc_mask_shift]) {\r\nrFd->fExtended = monadic_extended[opc_mask_shift](roundData, rFm);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}
