static void h5_link_control(struct hci_uart *hu, const void *data, size_t len)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nstruct sk_buff *nskb;\r\nnskb = alloc_skb(3, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nbt_cb(nskb)->pkt_type = HCI_3WIRE_LINK_PKT;\r\nmemcpy(skb_put(nskb, len), data, len);\r\nskb_queue_tail(&h5->unrel, nskb);\r\n}\r\nstatic u8 h5_cfg_field(struct h5 *h5)\r\n{\r\nu8 field = 0;\r\nfield |= (h5->tx_win & 7);\r\nreturn field;\r\n}\r\nstatic void h5_timed_event(unsigned long arg)\r\n{\r\nconst unsigned char sync_req[] = { 0x01, 0x7e };\r\nunsigned char conf_req[] = { 0x03, 0xfc, 0x01 };\r\nstruct hci_uart *hu = (struct hci_uart *) arg;\r\nstruct h5 *h5 = hu->priv;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nBT_DBG("%s", hu->hdev->name);\r\nif (h5->state == H5_UNINITIALIZED)\r\nh5_link_control(hu, sync_req, sizeof(sync_req));\r\nif (h5->state == H5_INITIALIZED) {\r\nconf_req[2] = h5_cfg_field(h5);\r\nh5_link_control(hu, conf_req, sizeof(conf_req));\r\n}\r\nif (h5->state != H5_ACTIVE) {\r\nmod_timer(&h5->timer, jiffies + H5_SYNC_TIMEOUT);\r\ngoto wakeup;\r\n}\r\nif (h5->sleep != H5_AWAKE) {\r\nh5->sleep = H5_SLEEPING;\r\ngoto wakeup;\r\n}\r\nBT_DBG("hu %p retransmitting %u pkts", hu, h5->unack.qlen);\r\nspin_lock_irqsave_nested(&h5->unack.lock, flags, SINGLE_DEPTH_NESTING);\r\nwhile ((skb = __skb_dequeue_tail(&h5->unack)) != NULL) {\r\nh5->tx_seq = (h5->tx_seq - 1) & 0x07;\r\nskb_queue_head(&h5->rel, skb);\r\n}\r\nspin_unlock_irqrestore(&h5->unack.lock, flags);\r\nwakeup:\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int h5_open(struct hci_uart *hu)\r\n{\r\nstruct h5 *h5;\r\nconst unsigned char sync[] = { 0x01, 0x7e };\r\nBT_DBG("hu %p", hu);\r\nh5 = kzalloc(sizeof(*h5), GFP_KERNEL);\r\nif (!h5)\r\nreturn -ENOMEM;\r\nhu->priv = h5;\r\nskb_queue_head_init(&h5->unack);\r\nskb_queue_head_init(&h5->rel);\r\nskb_queue_head_init(&h5->unrel);\r\nh5_reset_rx(h5);\r\ninit_timer(&h5->timer);\r\nh5->timer.function = h5_timed_event;\r\nh5->timer.data = (unsigned long) hu;\r\nh5->tx_win = H5_TX_WIN_MAX;\r\nset_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags);\r\nh5_link_control(hu, sync, sizeof(sync));\r\nmod_timer(&h5->timer, jiffies + H5_SYNC_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic int h5_close(struct hci_uart *hu)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nskb_queue_purge(&h5->unack);\r\nskb_queue_purge(&h5->rel);\r\nskb_queue_purge(&h5->unrel);\r\ndel_timer(&h5->timer);\r\nkfree(h5);\r\nreturn 0;\r\n}\r\nstatic void h5_pkt_cull(struct h5 *h5)\r\n{\r\nstruct sk_buff *skb, *tmp;\r\nunsigned long flags;\r\nint i, to_remove;\r\nu8 seq;\r\nspin_lock_irqsave(&h5->unack.lock, flags);\r\nto_remove = skb_queue_len(&h5->unack);\r\nif (to_remove == 0)\r\ngoto unlock;\r\nseq = h5->tx_seq;\r\nwhile (to_remove > 0) {\r\nif (h5->rx_ack == seq)\r\nbreak;\r\nto_remove--;\r\nseq = (seq - 1) % 8;\r\n}\r\nif (seq != h5->rx_ack)\r\nBT_ERR("Controller acked invalid packet");\r\ni = 0;\r\nskb_queue_walk_safe(&h5->unack, skb, tmp) {\r\nif (i++ >= to_remove)\r\nbreak;\r\n__skb_unlink(skb, &h5->unack);\r\nkfree_skb(skb);\r\n}\r\nif (skb_queue_empty(&h5->unack))\r\ndel_timer(&h5->timer);\r\nunlock:\r\nspin_unlock_irqrestore(&h5->unack.lock, flags);\r\n}\r\nstatic void h5_handle_internal_rx(struct hci_uart *hu)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nconst unsigned char sync_req[] = { 0x01, 0x7e };\r\nconst unsigned char sync_rsp[] = { 0x02, 0x7d };\r\nunsigned char conf_req[] = { 0x03, 0xfc, 0x01 };\r\nconst unsigned char conf_rsp[] = { 0x04, 0x7b };\r\nconst unsigned char wakeup_req[] = { 0x05, 0xfa };\r\nconst unsigned char woken_req[] = { 0x06, 0xf9 };\r\nconst unsigned char sleep_req[] = { 0x07, 0x78 };\r\nconst unsigned char *hdr = h5->rx_skb->data;\r\nconst unsigned char *data = &h5->rx_skb->data[4];\r\nBT_DBG("%s", hu->hdev->name);\r\nif (H5_HDR_PKT_TYPE(hdr) != HCI_3WIRE_LINK_PKT)\r\nreturn;\r\nif (H5_HDR_LEN(hdr) < 2)\r\nreturn;\r\nconf_req[2] = h5_cfg_field(h5);\r\nif (memcmp(data, sync_req, 2) == 0) {\r\nh5_link_control(hu, sync_rsp, 2);\r\n} else if (memcmp(data, sync_rsp, 2) == 0) {\r\nh5->state = H5_INITIALIZED;\r\nh5_link_control(hu, conf_req, 3);\r\n} else if (memcmp(data, conf_req, 2) == 0) {\r\nh5_link_control(hu, conf_rsp, 2);\r\nh5_link_control(hu, conf_req, 3);\r\n} else if (memcmp(data, conf_rsp, 2) == 0) {\r\nif (H5_HDR_LEN(hdr) > 2)\r\nh5->tx_win = (data[2] & 7);\r\nBT_DBG("Three-wire init complete. tx_win %u", h5->tx_win);\r\nh5->state = H5_ACTIVE;\r\nhci_uart_init_ready(hu);\r\nreturn;\r\n} else if (memcmp(data, sleep_req, 2) == 0) {\r\nBT_DBG("Peer went to sleep");\r\nh5->sleep = H5_SLEEPING;\r\nreturn;\r\n} else if (memcmp(data, woken_req, 2) == 0) {\r\nBT_DBG("Peer woke up");\r\nh5->sleep = H5_AWAKE;\r\n} else if (memcmp(data, wakeup_req, 2) == 0) {\r\nBT_DBG("Peer requested wakeup");\r\nh5_link_control(hu, woken_req, 2);\r\nh5->sleep = H5_AWAKE;\r\n} else {\r\nBT_DBG("Link Control: 0x%02hhx 0x%02hhx", data[0], data[1]);\r\nreturn;\r\n}\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void h5_complete_rx_pkt(struct hci_uart *hu)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nconst unsigned char *hdr = h5->rx_skb->data;\r\nif (H5_HDR_RELIABLE(hdr)) {\r\nh5->tx_ack = (h5->tx_ack + 1) % 8;\r\nset_bit(H5_TX_ACK_REQ, &h5->flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nh5->rx_ack = H5_HDR_ACK(hdr);\r\nh5_pkt_cull(h5);\r\nswitch (H5_HDR_PKT_TYPE(hdr)) {\r\ncase HCI_EVENT_PKT:\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_SCODATA_PKT:\r\nbt_cb(h5->rx_skb)->pkt_type = H5_HDR_PKT_TYPE(hdr);\r\nskb_pull(h5->rx_skb, 4);\r\nhci_recv_frame(h5->rx_skb);\r\nh5->rx_skb = NULL;\r\nbreak;\r\ndefault:\r\nh5_handle_internal_rx(hu);\r\nbreak;\r\n}\r\nh5_reset_rx(h5);\r\n}\r\nstatic int h5_rx_crc(struct hci_uart *hu, unsigned char c)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nh5_complete_rx_pkt(hu);\r\nh5_reset_rx(h5);\r\nreturn 0;\r\n}\r\nstatic int h5_rx_payload(struct hci_uart *hu, unsigned char c)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nconst unsigned char *hdr = h5->rx_skb->data;\r\nif (H5_HDR_CRC(hdr)) {\r\nh5->rx_func = h5_rx_crc;\r\nh5->rx_pending = 2;\r\n} else {\r\nh5_complete_rx_pkt(hu);\r\nh5_reset_rx(h5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int h5_rx_3wire_hdr(struct hci_uart *hu, unsigned char c)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nconst unsigned char *hdr = h5->rx_skb->data;\r\nBT_DBG("%s rx: seq %u ack %u crc %u rel %u type %u len %u",\r\nhu->hdev->name, H5_HDR_SEQ(hdr), H5_HDR_ACK(hdr),\r\nH5_HDR_CRC(hdr), H5_HDR_RELIABLE(hdr), H5_HDR_PKT_TYPE(hdr),\r\nH5_HDR_LEN(hdr));\r\nif (((hdr[0] + hdr[1] + hdr[2] + hdr[3]) & 0xff) != 0xff) {\r\nBT_ERR("Invalid header checksum");\r\nh5_reset_rx(h5);\r\nreturn 0;\r\n}\r\nif (H5_HDR_RELIABLE(hdr) && H5_HDR_SEQ(hdr) != h5->tx_ack) {\r\nBT_ERR("Out-of-order packet arrived (%u != %u)",\r\nH5_HDR_SEQ(hdr), h5->tx_ack);\r\nh5_reset_rx(h5);\r\nreturn 0;\r\n}\r\nif (h5->state != H5_ACTIVE &&\r\nH5_HDR_PKT_TYPE(hdr) != HCI_3WIRE_LINK_PKT) {\r\nBT_ERR("Non-link packet received in non-active state");\r\nh5_reset_rx(h5);\r\n}\r\nh5->rx_func = h5_rx_payload;\r\nh5->rx_pending = H5_HDR_LEN(hdr);\r\nreturn 0;\r\n}\r\nstatic int h5_rx_pkt_start(struct hci_uart *hu, unsigned char c)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nif (c == SLIP_DELIMITER)\r\nreturn 1;\r\nh5->rx_func = h5_rx_3wire_hdr;\r\nh5->rx_pending = 4;\r\nh5->rx_skb = bt_skb_alloc(H5_MAX_LEN, GFP_ATOMIC);\r\nif (!h5->rx_skb) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nh5_reset_rx(h5);\r\nreturn -ENOMEM;\r\n}\r\nh5->rx_skb->dev = (void *) hu->hdev;\r\nreturn 0;\r\n}\r\nstatic int h5_rx_delimiter(struct hci_uart *hu, unsigned char c)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nif (c == SLIP_DELIMITER)\r\nh5->rx_func = h5_rx_pkt_start;\r\nreturn 1;\r\n}\r\nstatic void h5_unslip_one_byte(struct h5 *h5, unsigned char c)\r\n{\r\nconst u8 delim = SLIP_DELIMITER, esc = SLIP_ESC;\r\nconst u8 *byte = &c;\r\nif (!test_bit(H5_RX_ESC, &h5->flags) && c == SLIP_ESC) {\r\nset_bit(H5_RX_ESC, &h5->flags);\r\nreturn;\r\n}\r\nif (test_and_clear_bit(H5_RX_ESC, &h5->flags)) {\r\nswitch (c) {\r\ncase SLIP_ESC_DELIM:\r\nbyte = &delim;\r\nbreak;\r\ncase SLIP_ESC_ESC:\r\nbyte = &esc;\r\nbreak;\r\ndefault:\r\nBT_ERR("Invalid esc byte 0x%02hhx", c);\r\nh5_reset_rx(h5);\r\nreturn;\r\n}\r\n}\r\nmemcpy(skb_put(h5->rx_skb, 1), byte, 1);\r\nh5->rx_pending--;\r\nBT_DBG("unsliped 0x%02hhx, rx_pending %zu", *byte, h5->rx_pending);\r\n}\r\nstatic void h5_reset_rx(struct h5 *h5)\r\n{\r\nif (h5->rx_skb) {\r\nkfree_skb(h5->rx_skb);\r\nh5->rx_skb = NULL;\r\n}\r\nh5->rx_func = h5_rx_delimiter;\r\nh5->rx_pending = 0;\r\nclear_bit(H5_RX_ESC, &h5->flags);\r\n}\r\nstatic int h5_recv(struct hci_uart *hu, void *data, int count)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nunsigned char *ptr = data;\r\nBT_DBG("%s pending %zu count %d", hu->hdev->name, h5->rx_pending,\r\ncount);\r\nwhile (count > 0) {\r\nint processed;\r\nif (h5->rx_pending > 0) {\r\nif (*ptr == SLIP_DELIMITER) {\r\nBT_ERR("Too short H5 packet");\r\nh5_reset_rx(h5);\r\ncontinue;\r\n}\r\nh5_unslip_one_byte(h5, *ptr);\r\nptr++; count--;\r\ncontinue;\r\n}\r\nprocessed = h5->rx_func(hu, *ptr);\r\nif (processed < 0)\r\nreturn processed;\r\nptr += processed;\r\ncount -= processed;\r\n}\r\nreturn 0;\r\n}\r\nstatic int h5_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nif (skb->len > 0xfff) {\r\nBT_ERR("Packet too long (%u bytes)", skb->len);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (h5->state != H5_ACTIVE) {\r\nBT_ERR("Ignoring HCI data in non-active state");\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_COMMAND_PKT:\r\nskb_queue_tail(&h5->rel, skb);\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nskb_queue_tail(&h5->unrel, skb);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown packet type %u", bt_cb(skb)->pkt_type);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void h5_slip_delim(struct sk_buff *skb)\r\n{\r\nconst char delim = SLIP_DELIMITER;\r\nmemcpy(skb_put(skb, 1), &delim, 1);\r\n}\r\nstatic void h5_slip_one_byte(struct sk_buff *skb, u8 c)\r\n{\r\nconst char esc_delim[2] = { SLIP_ESC, SLIP_ESC_DELIM };\r\nconst char esc_esc[2] = { SLIP_ESC, SLIP_ESC_ESC };\r\nswitch (c) {\r\ncase SLIP_DELIMITER:\r\nmemcpy(skb_put(skb, 2), &esc_delim, 2);\r\nbreak;\r\ncase SLIP_ESC:\r\nmemcpy(skb_put(skb, 2), &esc_esc, 2);\r\nbreak;\r\ndefault:\r\nmemcpy(skb_put(skb, 1), &c, 1);\r\n}\r\n}\r\nstatic bool valid_packet_type(u8 type)\r\n{\r\nswitch (type) {\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_COMMAND_PKT:\r\ncase HCI_SCODATA_PKT:\r\ncase HCI_3WIRE_LINK_PKT:\r\ncase HCI_3WIRE_ACK_PKT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic struct sk_buff *h5_prepare_pkt(struct hci_uart *hu, u8 pkt_type,\r\nconst u8 *data, size_t len)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nstruct sk_buff *nskb;\r\nu8 hdr[4];\r\nint i;\r\nif (!valid_packet_type(pkt_type)) {\r\nBT_ERR("Unknown packet type %u", pkt_type);\r\nreturn NULL;\r\n}\r\nnskb = alloc_skb((len + 6) * 2 + 2, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn NULL;\r\nbt_cb(nskb)->pkt_type = pkt_type;\r\nh5_slip_delim(nskb);\r\nhdr[0] = h5->tx_ack << 3;\r\nclear_bit(H5_TX_ACK_REQ, &h5->flags);\r\nif (pkt_type == HCI_ACLDATA_PKT || pkt_type == HCI_COMMAND_PKT) {\r\nhdr[0] |= 1 << 7;\r\nhdr[0] |= h5->tx_seq;\r\nh5->tx_seq = (h5->tx_seq + 1) % 8;\r\n}\r\nhdr[1] = pkt_type | ((len & 0x0f) << 4);\r\nhdr[2] = len >> 4;\r\nhdr[3] = ~((hdr[0] + hdr[1] + hdr[2]) & 0xff);\r\nBT_DBG("%s tx: seq %u ack %u crc %u rel %u type %u len %u",\r\nhu->hdev->name, H5_HDR_SEQ(hdr), H5_HDR_ACK(hdr),\r\nH5_HDR_CRC(hdr), H5_HDR_RELIABLE(hdr), H5_HDR_PKT_TYPE(hdr),\r\nH5_HDR_LEN(hdr));\r\nfor (i = 0; i < 4; i++)\r\nh5_slip_one_byte(nskb, hdr[i]);\r\nfor (i = 0; i < len; i++)\r\nh5_slip_one_byte(nskb, data[i]);\r\nh5_slip_delim(nskb);\r\nreturn nskb;\r\n}\r\nstatic struct sk_buff *h5_dequeue(struct hci_uart *hu)\r\n{\r\nstruct h5 *h5 = hu->priv;\r\nunsigned long flags;\r\nstruct sk_buff *skb, *nskb;\r\nif (h5->sleep != H5_AWAKE) {\r\nconst unsigned char wakeup_req[] = { 0x05, 0xfa };\r\nif (h5->sleep == H5_WAKING_UP)\r\nreturn NULL;\r\nh5->sleep = H5_WAKING_UP;\r\nBT_DBG("Sending wakeup request");\r\nmod_timer(&h5->timer, jiffies + HZ / 100);\r\nreturn h5_prepare_pkt(hu, HCI_3WIRE_LINK_PKT, wakeup_req, 2);\r\n}\r\nif ((skb = skb_dequeue(&h5->unrel)) != NULL) {\r\nnskb = h5_prepare_pkt(hu, bt_cb(skb)->pkt_type,\r\nskb->data, skb->len);\r\nif (nskb) {\r\nkfree_skb(skb);\r\nreturn nskb;\r\n}\r\nskb_queue_head(&h5->unrel, skb);\r\nBT_ERR("Could not dequeue pkt because alloc_skb failed");\r\n}\r\nspin_lock_irqsave_nested(&h5->unack.lock, flags, SINGLE_DEPTH_NESTING);\r\nif (h5->unack.qlen >= h5->tx_win)\r\ngoto unlock;\r\nif ((skb = skb_dequeue(&h5->rel)) != NULL) {\r\nnskb = h5_prepare_pkt(hu, bt_cb(skb)->pkt_type,\r\nskb->data, skb->len);\r\nif (nskb) {\r\n__skb_queue_tail(&h5->unack, skb);\r\nmod_timer(&h5->timer, jiffies + H5_ACK_TIMEOUT);\r\nspin_unlock_irqrestore(&h5->unack.lock, flags);\r\nreturn nskb;\r\n}\r\nskb_queue_head(&h5->rel, skb);\r\nBT_ERR("Could not dequeue pkt because alloc_skb failed");\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&h5->unack.lock, flags);\r\nif (test_bit(H5_TX_ACK_REQ, &h5->flags))\r\nreturn h5_prepare_pkt(hu, HCI_3WIRE_ACK_PKT, NULL, 0);\r\nreturn NULL;\r\n}\r\nstatic int h5_flush(struct hci_uart *hu)\r\n{\r\nBT_DBG("hu %p", hu);\r\nreturn 0;\r\n}\r\nint __init h5_init(void)\r\n{\r\nint err = hci_uart_register_proto(&h5p);\r\nif (!err)\r\nBT_INFO("HCI Three-wire UART (H5) protocol initialized");\r\nelse\r\nBT_ERR("HCI Three-wire UART (H5) protocol init failed");\r\nreturn err;\r\n}\r\nint __exit h5_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&h5p);\r\n}
