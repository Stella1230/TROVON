static void cpc_tty_signal_off(pc300dev_t *pc300dev, unsigned char signal)\r\n{\r\npc300ch_t *pc300chan = (pc300ch_t *)pc300dev->chan;\r\npc300_t *card = (pc300_t *) pc300chan->card;\r\nint ch = pc300chan->channel;\r\nunsigned long flags;\r\nCPC_TTY_DBG("%s-tty: Clear signal %x\n",\r\npc300dev->dev->name, signal);\r\nCPC_TTY_LOCK(card, flags);\r\ncpc_writeb(card->hw.scabase + M_REG(CTL,ch),\r\ncpc_readb(card->hw.scabase+M_REG(CTL,ch))& signal);\r\nCPC_TTY_UNLOCK(card,flags);\r\n}\r\nstatic void cpc_tty_signal_on(pc300dev_t *pc300dev, unsigned char signal)\r\n{\r\npc300ch_t *pc300chan = (pc300ch_t *)pc300dev->chan;\r\npc300_t *card = (pc300_t *) pc300chan->card;\r\nint ch = pc300chan->channel;\r\nunsigned long flags;\r\nCPC_TTY_DBG("%s-tty: Set signal %x\n",\r\npc300dev->dev->name, signal);\r\nCPC_TTY_LOCK(card, flags);\r\ncpc_writeb(card->hw.scabase + M_REG(CTL,ch),\r\ncpc_readb(card->hw.scabase+M_REG(CTL,ch))& ~signal);\r\nCPC_TTY_UNLOCK(card,flags);\r\n}\r\nvoid cpc_tty_init(pc300dev_t *pc300dev)\r\n{\r\nunsigned long port;\r\nint aux;\r\nst_cpc_tty_area * cpc_tty;\r\nport = pc300dev->dev->name[4] - '0';\r\nif (port >= CPC_TTY_NPORTS) {\r\nprintk("%s-tty: invalid interface selected (0-%i): %li",\r\npc300dev->dev->name,\r\nCPC_TTY_NPORTS-1,port);\r\nreturn;\r\n}\r\nif (cpc_tty_cnt == 0) {\r\nCPC_TTY_DBG("%s-tty: driver init, major:%i, minor range:%i=%i\n",\r\npc300dev->dev->name,\r\nCPC_TTY_MAJOR, CPC_TTY_MINOR_START,\r\nCPC_TTY_MINOR_START+CPC_TTY_NPORTS);\r\nmemset(&serial_drv,0,sizeof(struct tty_driver));\r\nserial_drv.magic = TTY_DRIVER_MAGIC;\r\nserial_drv.owner = THIS_MODULE;\r\nserial_drv.driver_name = "pc300_tty";\r\nserial_drv.name = "ttyCP";\r\nserial_drv.major = CPC_TTY_MAJOR;\r\nserial_drv.minor_start = CPC_TTY_MINOR_START;\r\nserial_drv.num = CPC_TTY_NPORTS;\r\nserial_drv.type = TTY_DRIVER_TYPE_SERIAL;\r\nserial_drv.subtype = SERIAL_TYPE_NORMAL;\r\nserial_drv.init_termios = tty_std_termios;\r\nserial_drv.init_termios.c_cflag = B9600|CS8|CREAD|HUPCL|CLOCAL;\r\nserial_drv.flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(&serial_drv, &pc300_ops);\r\nif (tty_register_driver(&serial_drv)) {\r\nprintk("%s-tty: Failed to register serial driver! ",\r\npc300dev->dev->name);\r\nreturn;\r\n}\r\nmemset((void *)cpc_tty_area, 0,\r\nsizeof(st_cpc_tty_area) * CPC_TTY_NPORTS);\r\n}\r\ncpc_tty = &cpc_tty_area[port];\r\nif (cpc_tty->state != CPC_TTY_ST_IDLE) {\r\nCPC_TTY_DBG("%s-tty: TTY port %i, already in use.\n",\r\npc300dev->dev->name, port);\r\nreturn;\r\n}\r\ncpc_tty_cnt++;\r\ncpc_tty->state = CPC_TTY_ST_INIT;\r\ncpc_tty->num_open= 0;\r\ncpc_tty->tty_minor = port + CPC_TTY_MINOR_START;\r\ncpc_tty->pc300dev = pc300dev;\r\nINIT_WORK(&cpc_tty->tty_tx_work, cpc_tty_tx_work);\r\nINIT_WORK(&cpc_tty->tty_rx_work, cpc_tty_rx_work);\r\ncpc_tty->buf_rx.first = cpc_tty->buf_rx.last = NULL;\r\npc300dev->cpc_tty = (void *)cpc_tty;\r\naux = strlen(pc300dev->dev->name);\r\nmemcpy(cpc_tty->name, pc300dev->dev->name, aux);\r\nmemcpy(&cpc_tty->name[aux], "-tty", 5);\r\ncpc_open(pc300dev->dev);\r\ncpc_tty_signal_off(pc300dev, CTL_DTR);\r\nCPC_TTY_DBG("%s: Initializing TTY Sync Driver, tty major#%d minor#%i\n",\r\ncpc_tty->name,CPC_TTY_MAJOR,cpc_tty->tty_minor);\r\nreturn;\r\n}\r\nstatic int cpc_tty_open(struct tty_struct *tty, struct file *flip)\r\n{\r\nint port ;\r\nst_cpc_tty_area *cpc_tty;\r\nif (!tty) {\r\nreturn -ENODEV;\r\n}\r\nport = tty->index;\r\nif ((port < 0) || (port >= CPC_TTY_NPORTS)){\r\nCPC_TTY_DBG("pc300_tty: open invalid port %d\n", port);\r\nreturn -ENODEV;\r\n}\r\ncpc_tty = &cpc_tty_area[port];\r\nif (cpc_tty->state == CPC_TTY_ST_IDLE){\r\nCPC_TTY_DBG("%s: open - invalid interface, port=%d\n",\r\ncpc_tty->name, tty->index);\r\nreturn -ENODEV;\r\n}\r\nif (cpc_tty->num_open == 0) {\r\nif (!cpc_tty_area[port].buf_tx){\r\ncpc_tty_area[port].buf_tx = kmalloc(CPC_TTY_MAX_MTU,GFP_KERNEL);\r\nif (!cpc_tty_area[port].buf_tx) {\r\nCPC_TTY_DBG("%s: error in memory allocation\n",cpc_tty->name);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (cpc_tty_area[port].buf_rx.first) {\r\nunsigned char * aux;\r\nwhile (cpc_tty_area[port].buf_rx.first) {\r\naux = (unsigned char *)cpc_tty_area[port].buf_rx.first;\r\ncpc_tty_area[port].buf_rx.first = cpc_tty_area[port].buf_rx.first->next;\r\nkfree(aux);\r\n}\r\ncpc_tty_area[port].buf_rx.first = NULL;\r\ncpc_tty_area[port].buf_rx.last = NULL;\r\n}\r\ncpc_tty_area[port].state = CPC_TTY_ST_OPEN;\r\ncpc_tty_area[port].tty = tty;\r\ntty->driver_data = &cpc_tty_area[port];\r\ncpc_tty_signal_on(cpc_tty->pc300dev, CTL_DTR);\r\n}\r\ncpc_tty->num_open++;\r\nCPC_TTY_DBG("%s: opening TTY driver\n", cpc_tty->name);\r\nreturn 0;\r\n}\r\nstatic void cpc_tty_close(struct tty_struct *tty, struct file *flip)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nunsigned long flags;\r\nint res;\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlx-tty: no TTY in close\n");\r\nreturn;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif ((cpc_tty->tty != tty)|| (cpc_tty->state != CPC_TTY_ST_OPEN)) {\r\nCPC_TTY_DBG("%s: TTY is not opened\n",cpc_tty->name);\r\nreturn;\r\n}\r\nif (!cpc_tty->num_open) {\r\nCPC_TTY_DBG("%s: TTY is closed\n",cpc_tty->name);\r\nreturn;\r\n}\r\nif (--cpc_tty->num_open > 0) {\r\nCPC_TTY_DBG("%s: TTY closed\n",cpc_tty->name);\r\nreturn;\r\n}\r\ncpc_tty_signal_off(cpc_tty->pc300dev, CTL_DTR);\r\nCPC_TTY_LOCK(cpc_tty->pc300dev->chan->card, flags);\r\ncpc_tty->tty = NULL;\r\ncpc_tty->state = CPC_TTY_ST_INIT;\r\nCPC_TTY_UNLOCK(cpc_tty->pc300dev->chan->card, flags);\r\nif (cpc_tty->buf_rx.first) {\r\nunsigned char * aux;\r\nwhile (cpc_tty->buf_rx.first) {\r\naux = (unsigned char *)cpc_tty->buf_rx.first;\r\ncpc_tty->buf_rx.first = cpc_tty->buf_rx.first->next;\r\nkfree(aux);\r\n}\r\ncpc_tty->buf_rx.first = NULL;\r\ncpc_tty->buf_rx.last = NULL;\r\n}\r\nkfree(cpc_tty->buf_tx);\r\ncpc_tty->buf_tx = NULL;\r\nCPC_TTY_DBG("%s: TTY closed\n",cpc_tty->name);\r\nif (!serial_drv.refcount && cpc_tty_unreg_flag) {\r\ncpc_tty_unreg_flag = 0;\r\nCPC_TTY_DBG("%s: unregister the tty driver\n", cpc_tty->name);\r\nif ((res=tty_unregister_driver(&serial_drv))) {\r\nCPC_TTY_DBG("%s: ERROR ->unregister the tty driver error=%d\n",\r\ncpc_tty->name,res);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int cpc_tty_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\npc300ch_t *pc300chan;\r\npc300_t *card;\r\nint ch;\r\nunsigned long flags;\r\nstruct net_device_stats *stats;\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlcX-tty: no TTY in write\n");\r\nreturn -ENODEV;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif ((cpc_tty->tty != tty) || (cpc_tty->state != CPC_TTY_ST_OPEN)) {\r\nCPC_TTY_DBG("%s: TTY is not opened\n", cpc_tty->name);\r\nreturn -ENODEV;\r\n}\r\nif (count > CPC_TTY_MAX_MTU) {\r\nCPC_TTY_DBG("%s: count is invalid\n",cpc_tty->name);\r\nreturn -EINVAL;\r\n}\r\nCPC_TTY_DBG("%s: cpc_tty_write data len=%i\n",cpc_tty->name,count);\r\npc300chan = (pc300ch_t *)((pc300dev_t*)cpc_tty->pc300dev)->chan;\r\nstats = &cpc_tty->pc300dev->dev->stats;\r\ncard = (pc300_t *) pc300chan->card;\r\nch = pc300chan->channel;\r\nif (cpc_readb(card->hw.scabase + M_REG(ST3,ch)) & ST3_DCD) {\r\nCPC_TTY_DBG("%s : DCD is OFF\n", cpc_tty->name);\r\nstats->tx_errors++;\r\nstats->tx_carrier_errors++;\r\nCPC_TTY_LOCK(card, flags);\r\ncpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_BUF_CLR);\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED1 << (2 *ch)));\r\n}\r\nCPC_TTY_UNLOCK(card, flags);\r\nreturn -EINVAL;\r\n}\r\nif (cpc_tty_send_to_card(cpc_tty->pc300dev, (void*)buf, count)) {\r\nCPC_TTY_DBG("%s: trasmition error\n", cpc_tty->name);\r\nreturn 0;\r\n}\r\nreturn count;\r\n}\r\nstatic int cpc_tty_write_room(struct tty_struct *tty)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlcX-tty: no TTY to write room\n");\r\nreturn -ENODEV;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif ((cpc_tty->tty != tty) || (cpc_tty->state != CPC_TTY_ST_OPEN)) {\r\nCPC_TTY_DBG("%s: TTY is not opened\n",cpc_tty->name);\r\nreturn -ENODEV;\r\n}\r\nCPC_TTY_DBG("%s: write room\n",cpc_tty->name);\r\nreturn CPC_TTY_MAX_MTU;\r\n}\r\nstatic int cpc_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlcX-tty: no TTY to chars in buffer\n");\r\nreturn -ENODEV;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif ((cpc_tty->tty != tty) || (cpc_tty->state != CPC_TTY_ST_OPEN)) {\r\nCPC_TTY_DBG("%s: TTY is not opened\n",cpc_tty->name);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pc300_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nCPC_TTY_DBG("%s: set:%x clear:%x\n", __func__, set, clear);\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlcX-tty: no TTY to chars in buffer\n");\r\nreturn -ENODEV;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif (set & TIOCM_RTS)\r\ncpc_tty_signal_on(cpc_tty->pc300dev, CTL_RTS);\r\nif (set & TIOCM_DTR)\r\ncpc_tty_signal_on(cpc_tty->pc300dev, CTL_DTR);\r\nif (clear & TIOCM_RTS)\r\ncpc_tty_signal_off(cpc_tty->pc300dev, CTL_RTS);\r\nif (clear & TIOCM_DTR)\r\ncpc_tty_signal_off(cpc_tty->pc300dev, CTL_DTR);\r\nreturn 0;\r\n}\r\nstatic int pc300_tiocmget(struct tty_struct *tty)\r\n{\r\nunsigned int result;\r\nunsigned char status;\r\nunsigned long flags;\r\nst_cpc_tty_area *cpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\npc300dev_t *pc300dev = cpc_tty->pc300dev;\r\npc300ch_t *pc300chan = (pc300ch_t *)pc300dev->chan;\r\npc300_t *card = (pc300_t *) pc300chan->card;\r\nint ch = pc300chan->channel;\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nCPC_TTY_DBG("%s-tty: tiocmget\n",\r\n((struct net_device*)(pc300dev->hdlc))->name);\r\nCPC_TTY_LOCK(card, flags);\r\nstatus = cpc_readb(card->hw.scabase+M_REG(CTL,ch));\r\nCPC_TTY_UNLOCK(card,flags);\r\nresult = ((status & CTL_DTR) ? TIOCM_DTR : 0) |\r\n((status & CTL_RTS) ? TIOCM_RTS : 0);\r\nreturn result;\r\n}\r\nstatic void cpc_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlcX-tty: no TTY to flush buffer\n");\r\nreturn;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif ((cpc_tty->tty != tty) || (cpc_tty->state != CPC_TTY_ST_OPEN)) {\r\nCPC_TTY_DBG("%s: TTY is not opened\n",cpc_tty->name);\r\nreturn;\r\n}\r\nCPC_TTY_DBG("%s: call wake_up_interruptible\n",cpc_tty->name);\r\ntty_wakeup(tty);\r\nreturn;\r\n}\r\nstatic void cpc_tty_hangup(struct tty_struct *tty)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nint res;\r\nif (!tty || !tty->driver_data ) {\r\nCPC_TTY_DBG("hdlcX-tty: no TTY to hangup\n");\r\nreturn ;\r\n}\r\ncpc_tty = (st_cpc_tty_area *) tty->driver_data;\r\nif ((cpc_tty->tty != tty) || (cpc_tty->state != CPC_TTY_ST_OPEN)) {\r\nCPC_TTY_DBG("%s: TTY is not opened\n",cpc_tty->name);\r\nreturn ;\r\n}\r\nif (!serial_drv.refcount && cpc_tty_unreg_flag) {\r\ncpc_tty_unreg_flag = 0;\r\nCPC_TTY_DBG("%s: unregister the tty driver\n", cpc_tty->name);\r\nif ((res=tty_unregister_driver(&serial_drv))) {\r\nCPC_TTY_DBG("%s: ERROR ->unregister the tty driver error=%d\n",\r\ncpc_tty->name,res);\r\n}\r\n}\r\ncpc_tty_signal_off(cpc_tty->pc300dev, CTL_DTR);\r\n}\r\nstatic void cpc_tty_rx_work(struct work_struct *work)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nunsigned long port;\r\nint i, j;\r\nvolatile st_cpc_rx_buf *buf;\r\nchar flags=0,flg_rx=1;\r\nstruct tty_ldisc *ld;\r\nif (cpc_tty_cnt == 0) return;\r\nfor (i=0; (i < 4) && flg_rx ; i++) {\r\nflg_rx = 0;\r\ncpc_tty = container_of(work, st_cpc_tty_area, tty_rx_work);\r\nport = cpc_tty - cpc_tty_area;\r\nfor (j=0; j < CPC_TTY_NPORTS; j++) {\r\ncpc_tty = &cpc_tty_area[port];\r\nif ((buf=cpc_tty->buf_rx.first) != NULL) {\r\nif (cpc_tty->tty) {\r\nld = tty_ldisc_ref(cpc_tty->tty);\r\nif (ld) {\r\nif (ld->ops->receive_buf) {\r\nCPC_TTY_DBG("%s: call line disc. receive_buf\n",cpc_tty->name);\r\nld->ops->receive_buf(cpc_tty->tty, (char *)(buf->data), &flags, buf->size);\r\n}\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\ncpc_tty->buf_rx.first = cpc_tty->buf_rx.first->next;\r\nkfree((void *)buf);\r\nbuf = cpc_tty->buf_rx.first;\r\nflg_rx = 1;\r\n}\r\nif (++port == CPC_TTY_NPORTS) port = 0;\r\n}\r\n}\r\n}\r\nstatic void cpc_tty_rx_disc_frame(pc300ch_t *pc300chan)\r\n{\r\nvolatile pcsca_bd_t __iomem * ptdescr;\r\nvolatile unsigned char status;\r\npc300_t *card = (pc300_t *)pc300chan->card;\r\nint ch = pc300chan->channel;\r\nptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase +\r\nRX_BD_ADDR(ch, pc300chan->rx_first_bd));\r\nwhile (pc300chan->rx_first_bd != pc300chan->rx_last_bd) {\r\nstatus = cpc_readb(&ptdescr->status);\r\ncpc_writeb(&ptdescr->status, 0);\r\ncpc_writeb(&ptdescr->len, 0);\r\npc300chan->rx_first_bd = (pc300chan->rx_first_bd + 1) &\r\n(N_DMA_RX_BUF - 1);\r\nif (status & DST_EOM) {\r\nbreak;\r\n}\r\nptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase + cpc_readl(&ptdescr->next));\r\n}\r\n}\r\nvoid cpc_tty_receive(pc300dev_t *pc300dev)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\npc300ch_t *pc300chan = (pc300ch_t *)pc300dev->chan;\r\npc300_t *card = (pc300_t *)pc300chan->card;\r\nint ch = pc300chan->channel;\r\nvolatile pcsca_bd_t __iomem * ptdescr;\r\nstruct net_device_stats *stats = &pc300dev->dev->stats;\r\nint rx_len, rx_aux;\r\nvolatile unsigned char status;\r\nunsigned short first_bd = pc300chan->rx_first_bd;\r\nst_cpc_rx_buf *new = NULL;\r\nunsigned char dsr_rx;\r\nif (pc300dev->cpc_tty == NULL) {\r\nreturn;\r\n}\r\ndsr_rx = cpc_readb(card->hw.scabase + DSR_RX(ch));\r\ncpc_tty = pc300dev->cpc_tty;\r\nwhile (1) {\r\nrx_len = 0;\r\nptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase + RX_BD_ADDR(ch, first_bd));\r\nwhile ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {\r\nrx_len += cpc_readw(&ptdescr->len);\r\nfirst_bd = (first_bd + 1) & (N_DMA_RX_BUF - 1);\r\nif (status & DST_EOM) {\r\nbreak;\r\n}\r\nptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase+cpc_readl(&ptdescr->next));\r\n}\r\nif (!rx_len) {\r\nif (dsr_rx & DSR_BOF) {\r\ncpc_writel(card->hw.scabase + DRX_REG(EDAL, ch),\r\nRX_BD_ADDR(ch, pc300chan->rx_last_bd));\r\n}\r\nkfree(new);\r\nreturn;\r\n}\r\nif (rx_len > CPC_TTY_MAX_MTU) {\r\nCPC_TTY_DBG("%s: frame size is invalid.\n",cpc_tty->name);\r\nstats->rx_errors++;\r\nstats->rx_frame_errors++;\r\ncpc_tty_rx_disc_frame(pc300chan);\r\ncontinue;\r\n}\r\nnew = kmalloc(rx_len + sizeof(st_cpc_rx_buf), GFP_ATOMIC);\r\nif (!new) {\r\ncpc_tty_rx_disc_frame(pc300chan);\r\ncontinue;\r\n}\r\nptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase +\r\nRX_BD_ADDR(ch, pc300chan->rx_first_bd));\r\nrx_len = 0;\r\nwhile ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {\r\nrx_aux = cpc_readw(&ptdescr->len);\r\nif ((status & (DST_OVR | DST_CRC | DST_RBIT | DST_SHRT | DST_ABT))\r\n|| (rx_aux > BD_DEF_LEN)) {\r\nCPC_TTY_DBG("%s: reception error\n", cpc_tty->name);\r\nstats->rx_errors++;\r\nif (status & DST_OVR) {\r\nstats->rx_fifo_errors++;\r\n}\r\nif (status & DST_CRC) {\r\nstats->rx_crc_errors++;\r\n}\r\nif ((status & (DST_RBIT | DST_SHRT | DST_ABT)) ||\r\n(rx_aux > BD_DEF_LEN)) {\r\nstats->rx_frame_errors++;\r\n}\r\nCPC_TTY_DBG("%s: reception error - discard descriptors",\r\ncpc_tty->name);\r\ncpc_tty_rx_disc_frame(pc300chan);\r\nrx_len = 0;\r\nkfree(new);\r\nnew = NULL;\r\nbreak;\r\n}\r\nif (cpc_tty->state != CPC_TTY_ST_OPEN) {\r\ncpc_tty_rx_disc_frame(pc300chan);\r\nstats->rx_dropped++;\r\nrx_len = 0;\r\nkfree(new);\r\nnew = NULL;\r\nbreak;\r\n}\r\nif (rx_aux != 0) {\r\nmemcpy_fromio((new->data + rx_len),\r\n(void __iomem *)(card->hw.rambase +\r\ncpc_readl(&ptdescr->ptbuf)), rx_aux);\r\nrx_len += rx_aux;\r\n}\r\ncpc_writeb(&ptdescr->status,0);\r\ncpc_writeb(&ptdescr->len, 0);\r\npc300chan->rx_first_bd = (pc300chan->rx_first_bd + 1) &\r\n(N_DMA_RX_BUF -1);\r\nif (status & DST_EOM)break;\r\nptdescr = (pcsca_bd_t __iomem *) (card->hw.rambase +\r\ncpc_readl(&ptdescr->next));\r\n}\r\npc300chan->rx_last_bd = (pc300chan->rx_first_bd - 1) &\r\n(N_DMA_RX_BUF - 1) ;\r\nif (!(dsr_rx & DSR_BOF)) {\r\ncpc_writel(card->hw.scabase + DRX_REG(EDAL, ch),\r\nRX_BD_ADDR(ch, pc300chan->rx_last_bd));\r\n}\r\nif (rx_len != 0) {\r\nstats->rx_bytes += rx_len;\r\nif (pc300dev->trace_on) {\r\ncpc_tty_trace(pc300dev, new->data,rx_len, 'R');\r\n}\r\nnew->size = rx_len;\r\nnew->next = NULL;\r\nif (cpc_tty->buf_rx.first == NULL) {\r\ncpc_tty->buf_rx.first = new;\r\ncpc_tty->buf_rx.last = new;\r\n} else {\r\ncpc_tty->buf_rx.last->next = new;\r\ncpc_tty->buf_rx.last = new;\r\n}\r\nschedule_work(&(cpc_tty->tty_rx_work));\r\nstats->rx_packets++;\r\n}\r\n}\r\n}\r\nstatic void cpc_tty_tx_work(struct work_struct *work)\r\n{\r\nst_cpc_tty_area *cpc_tty =\r\ncontainer_of(work, st_cpc_tty_area, tty_tx_work);\r\nstruct tty_struct *tty;\r\nCPC_TTY_DBG("%s: cpc_tty_tx_work init\n",cpc_tty->name);\r\nif ((tty = cpc_tty->tty) == NULL) {\r\nCPC_TTY_DBG("%s: the interface is not opened\n",cpc_tty->name);\r\nreturn;\r\n}\r\ntty_wakeup(tty);\r\n}\r\nstatic int cpc_tty_send_to_card(pc300dev_t *dev,void* buf, int len)\r\n{\r\npc300ch_t *chan = (pc300ch_t *)dev->chan;\r\npc300_t *card = (pc300_t *)chan->card;\r\nint ch = chan->channel;\r\nstruct net_device_stats *stats = &dev->dev->stats;\r\nunsigned long flags;\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nint i, nchar;\r\nint tosend = len;\r\nint nbuf = ((len - 1)/BD_DEF_LEN) + 1;\r\nunsigned char *pdata=buf;\r\nCPC_TTY_DBG("%s:cpc_tty_send_to_cars len=%i",\r\n(st_cpc_tty_area *)dev->cpc_tty->name,len);\r\nif (nbuf >= card->chan[ch].nfree_tx_bd) {\r\nreturn 1;\r\n}\r\nCPC_TTY_DBG("%s: call dma_buf_write\n",\r\n(st_cpc_tty_area *)dev->cpc_tty->name);\r\nfor (i = 0 ; i < nbuf ; i++) {\r\nptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase +\r\nTX_BD_ADDR(ch, card->chan[ch].tx_next_bd));\r\nnchar = (BD_DEF_LEN > tosend) ? tosend : BD_DEF_LEN;\r\nif (cpc_readb(&ptdescr->status) & DST_OSB) {\r\nmemcpy_toio((void __iomem *)(card->hw.rambase +\r\ncpc_readl(&ptdescr->ptbuf)),\r\n&pdata[len - tosend],\r\nnchar);\r\ncard->chan[ch].nfree_tx_bd--;\r\nif ((i + 1) == nbuf) {\r\ncpc_writeb(&ptdescr->status, DST_EOM);\r\n} else {\r\ncpc_writeb(&ptdescr->status, 0);\r\n}\r\ncpc_writew(&ptdescr->len, nchar);\r\n} else {\r\nCPC_TTY_DBG("%s: error in dma_buf_write\n",\r\n(st_cpc_tty_area *)dev->cpc_tty->name);\r\nstats->tx_dropped++;\r\nreturn 1;\r\n}\r\ntosend -= nchar;\r\ncard->chan[ch].tx_next_bd =\r\n(card->chan[ch].tx_next_bd + 1) & (N_DMA_TX_BUF - 1);\r\n}\r\nif (dev->trace_on) {\r\ncpc_tty_trace(dev, buf, len,'T');\r\n}\r\nCPC_TTY_DBG("%s: start transmission\n",\r\n(st_cpc_tty_area *)dev->cpc_tty->name);\r\nCPC_TTY_LOCK(card, flags);\r\ncpc_writeb(card->hw.scabase + DTX_REG(EDAL, ch),\r\nTX_BD_ADDR(ch, chan->tx_next_bd));\r\ncpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_ENA);\r\ncpc_writeb(card->hw.scabase + DSR_TX(ch), DSR_DE);\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) |\r\n(CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\nCPC_TTY_UNLOCK(card, flags);\r\nreturn 0;\r\n}\r\nstatic void cpc_tty_trace(pc300dev_t *dev, char* buf, int len, char rxtx)\r\n{\r\nstruct sk_buff *skb;\r\nif ((skb = dev_alloc_skb(10 + len)) == NULL) {\r\nCPC_TTY_DBG("%s: tty_trace - out of memory\n", dev->dev->name);\r\nreturn;\r\n}\r\nskb_put (skb, 10 + len);\r\nskb->dev = dev->dev;\r\nskb->protocol = htons(ETH_P_CUST);\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_HOST;\r\nskb->len = 10 + len;\r\nskb_copy_to_linear_data(skb, dev->dev->name, 5);\r\nskb->data[5] = '[';\r\nskb->data[6] = rxtx;\r\nskb->data[7] = ']';\r\nskb->data[8] = ':';\r\nskb->data[9] = ' ';\r\nskb_copy_to_linear_data_offset(skb, 10, buf, len);\r\nnetif_rx(skb);\r\n}\r\nvoid cpc_tty_unregister_service(pc300dev_t *pc300dev)\r\n{\r\nst_cpc_tty_area *cpc_tty;\r\nulong flags;\r\nint res;\r\nif ((cpc_tty= (st_cpc_tty_area *) pc300dev->cpc_tty) == NULL) {\r\nCPC_TTY_DBG("%s: interface is not TTY\n", pc300dev->dev->name);\r\nreturn;\r\n}\r\nCPC_TTY_DBG("%s: cpc_tty_unregister_service", cpc_tty->name);\r\nif (cpc_tty->pc300dev != pc300dev) {\r\nCPC_TTY_DBG("%s: invalid tty ptr=%s\n",\r\npc300dev->dev->name, cpc_tty->name);\r\nreturn;\r\n}\r\nif (--cpc_tty_cnt == 0) {\r\nif (serial_drv.refcount) {\r\nCPC_TTY_DBG("%s: unregister is not possible, refcount=%d",\r\ncpc_tty->name, serial_drv.refcount);\r\ncpc_tty_cnt++;\r\ncpc_tty_unreg_flag = 1;\r\nreturn;\r\n} else {\r\nCPC_TTY_DBG("%s: unregister the tty driver\n", cpc_tty->name);\r\nif ((res=tty_unregister_driver(&serial_drv))) {\r\nCPC_TTY_DBG("%s: ERROR ->unregister the tty driver error=%d\n",\r\ncpc_tty->name,res);\r\n}\r\n}\r\n}\r\nCPC_TTY_LOCK(pc300dev->chan->card,flags);\r\ncpc_tty->tty = NULL;\r\nCPC_TTY_UNLOCK(pc300dev->chan->card, flags);\r\ncpc_tty->tty_minor = 0;\r\ncpc_tty->state = CPC_TTY_ST_IDLE;\r\n}\r\nvoid cpc_tty_trigger_poll(pc300dev_t *pc300dev)\r\n{\r\nst_cpc_tty_area *cpc_tty = (st_cpc_tty_area *)pc300dev->cpc_tty;\r\nif (!cpc_tty) {\r\nreturn;\r\n}\r\nschedule_work(&(cpc_tty->tty_tx_work));\r\n}
