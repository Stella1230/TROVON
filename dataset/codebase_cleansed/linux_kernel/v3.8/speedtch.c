static void speedtch_set_swbuff(struct speedtch_instance_data *instance, int state)\r\n{\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\nint ret;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x32, 0x40, state ? 0x01 : 0x00, 0x00, NULL, 0, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm,\r\n"%sabling SW buffering: usb_control_msg returned %d\n",\r\nstate ? "En" : "Dis", ret);\r\nelse\r\nusb_dbg(usbatm, "speedtch_set_swbuff: %sbled SW buffering\n", state ? "En" : "Dis");\r\n}\r\nstatic void speedtch_test_sequence(struct speedtch_instance_data *instance)\r\n{\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\nunsigned char *buf = instance->scratch_buffer;\r\nint ret;\r\nbuf[0] = 0x1c;\r\nbuf[1] = 0x50;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x0b, 0x00, buf, 2, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URB147: %d\n", __func__, ret);\r\nbuf[0] = 0x32;\r\nbuf[1] = 0x00;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x02, 0x00, buf, 2, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URB148: %d\n", __func__, ret);\r\nbuf[0] = 0x01;\r\nbuf[1] = 0x00;\r\nbuf[2] = 0x01;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x03, 0x00, buf, 3, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URB149: %d\n", __func__, ret);\r\nbuf[0] = 0x01;\r\nbuf[1] = 0x00;\r\nbuf[2] = 0x01;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x04, 0x00, buf, 3, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URB150: %d\n", __func__, ret);\r\nbuf[0] = instance->params.ModemMode;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x11, 0x00, buf, 1, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URBext1: %d\n", __func__, ret);\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x14, 0x00,\r\ninstance->params.ModemOption,\r\nMODEM_OPTION_LENGTH, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URBext2: %d\n", __func__, ret);\r\nbuf[0] = instance->params.BMaxDSL & 0xff;\r\nbuf[1] = instance->params.BMaxDSL >> 8;\r\nret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\r\n0x01, 0x40, 0x12, 0x00, buf, 2, CTRL_TIMEOUT);\r\nif (ret < 0)\r\nusb_warn(usbatm, "%s failed on URBext3: %d\n", __func__, ret);\r\n}\r\nstatic int speedtch_upload_firmware(struct speedtch_instance_data *instance,\r\nconst struct firmware *fw1,\r\nconst struct firmware *fw2)\r\n{\r\nunsigned char *buffer;\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\nint actual_length;\r\nint ret = 0;\r\nint offset;\r\nusb_dbg(usbatm, "%s entered\n", __func__);\r\nif (!(buffer = (unsigned char *)__get_free_page(GFP_KERNEL))) {\r\nret = -ENOMEM;\r\nusb_dbg(usbatm, "%s: no memory for buffer!\n", __func__);\r\ngoto out;\r\n}\r\nif (!usb_ifnum_to_if(usb_dev, 2)) {\r\nret = -ENODEV;\r\nusb_dbg(usbatm, "%s: interface not found!\n", __func__);\r\ngoto out_free;\r\n}\r\nif (dl_512_first) {\r\nret = usb_bulk_msg(usb_dev, usb_rcvbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\r\nbuffer, 0x200, &actual_length, 2000);\r\nif (ret < 0 && ret != -ETIMEDOUT)\r\nusb_warn(usbatm, "%s: read BLOCK0 from modem failed (%d)!\n", __func__, ret);\r\nelse\r\nusb_dbg(usbatm, "%s: BLOCK0 downloaded (%d bytes)\n", __func__, ret);\r\n}\r\nfor (offset = 0; offset < fw1->size; offset += PAGE_SIZE) {\r\nint thislen = min_t(int, PAGE_SIZE, fw1->size - offset);\r\nmemcpy(buffer, fw1->data + offset, thislen);\r\nret = usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\r\nbuffer, thislen, &actual_length, DATA_TIMEOUT);\r\nif (ret < 0) {\r\nusb_err(usbatm, "%s: write BLOCK1 to modem failed (%d)!\n", __func__, ret);\r\ngoto out_free;\r\n}\r\nusb_dbg(usbatm, "%s: BLOCK1 uploaded (%zu bytes)\n", __func__, fw1->size);\r\n}\r\nret = usb_bulk_msg(usb_dev, usb_rcvbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\r\nbuffer, 0x200, &actual_length, DATA_TIMEOUT);\r\nif (ret < 0) {\r\nusb_err(usbatm, "%s: read BLOCK2 from modem failed (%d)!\n", __func__, ret);\r\ngoto out_free;\r\n}\r\nusb_dbg(usbatm, "%s: BLOCK2 downloaded (%d bytes)\n", __func__, actual_length);\r\nfor (offset = 0; offset < fw2->size; offset += PAGE_SIZE) {\r\nint thislen = min_t(int, PAGE_SIZE, fw2->size - offset);\r\nmemcpy(buffer, fw2->data + offset, thislen);\r\nret = usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\r\nbuffer, thislen, &actual_length, DATA_TIMEOUT);\r\nif (ret < 0) {\r\nusb_err(usbatm, "%s: write BLOCK3 to modem failed (%d)!\n", __func__, ret);\r\ngoto out_free;\r\n}\r\n}\r\nusb_dbg(usbatm, "%s: BLOCK3 uploaded (%zu bytes)\n", __func__, fw2->size);\r\nret = usb_bulk_msg(usb_dev, usb_rcvbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\r\nbuffer, 0x200, &actual_length, DATA_TIMEOUT);\r\nif (ret < 0) {\r\nusb_err(usbatm, "%s: read BLOCK4 from modem failed (%d)!\n", __func__, ret);\r\ngoto out_free;\r\n}\r\nusb_dbg(usbatm, "%s: BLOCK4 downloaded (%d bytes)\n", __func__, actual_length);\r\nmsleep_interruptible(1000);\r\nif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, instance->params.altsetting)) < 0) {\r\nusb_err(usbatm, "%s: setting interface to %d failed (%d)!\n", __func__, instance->params.altsetting, ret);\r\ngoto out_free;\r\n}\r\nif (sw_buffering)\r\nspeedtch_set_swbuff(instance, 1);\r\nspeedtch_test_sequence(instance);\r\nret = 0;\r\nout_free:\r\nfree_page((unsigned long)buffer);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int speedtch_find_firmware(struct usbatm_data *usbatm, struct usb_interface *intf,\r\nint phase, const struct firmware **fw_p)\r\n{\r\nstruct device *dev = &intf->dev;\r\nconst u16 bcdDevice = le16_to_cpu(interface_to_usbdev(intf)->descriptor.bcdDevice);\r\nconst u8 major_revision = bcdDevice >> 8;\r\nconst u8 minor_revision = bcdDevice & 0xff;\r\nchar buf[24];\r\nsprintf(buf, "speedtch-%d.bin.%x.%02x", phase, major_revision, minor_revision);\r\nusb_dbg(usbatm, "%s: looking for %s\n", __func__, buf);\r\nif (request_firmware(fw_p, buf, dev)) {\r\nsprintf(buf, "speedtch-%d.bin.%x", phase, major_revision);\r\nusb_dbg(usbatm, "%s: looking for %s\n", __func__, buf);\r\nif (request_firmware(fw_p, buf, dev)) {\r\nsprintf(buf, "speedtch-%d.bin", phase);\r\nusb_dbg(usbatm, "%s: looking for %s\n", __func__, buf);\r\nif (request_firmware(fw_p, buf, dev)) {\r\nusb_err(usbatm, "%s: no stage %d firmware found!\n", __func__, phase);\r\nreturn -ENOENT;\r\n}\r\n}\r\n}\r\nusb_info(usbatm, "found stage %d firmware %s\n", phase, buf);\r\nreturn 0;\r\n}\r\nstatic int speedtch_heavy_init(struct usbatm_data *usbatm, struct usb_interface *intf)\r\n{\r\nconst struct firmware *fw1, *fw2;\r\nstruct speedtch_instance_data *instance = usbatm->driver_data;\r\nint ret;\r\nif ((ret = speedtch_find_firmware(usbatm, intf, 1, &fw1)) < 0)\r\nreturn ret;\r\nif ((ret = speedtch_find_firmware(usbatm, intf, 2, &fw2)) < 0) {\r\nrelease_firmware(fw1);\r\nreturn ret;\r\n}\r\nif ((ret = speedtch_upload_firmware(instance, fw1, fw2)) < 0)\r\nusb_err(usbatm, "%s: firmware upload failed (%d)!\n", __func__, ret);\r\nrelease_firmware(fw2);\r\nrelease_firmware(fw1);\r\nreturn ret;\r\n}\r\nstatic int speedtch_read_status(struct speedtch_instance_data *instance)\r\n{\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\nunsigned char *buf = instance->scratch_buffer;\r\nint ret;\r\nmemset(buf, 0, 16);\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x12, 0xc0, 0x07, 0x00, buf + OFFSET_7, SIZE_7,\r\nCTRL_TIMEOUT);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: MSG 7 failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x12, 0xc0, 0x0b, 0x00, buf + OFFSET_b, SIZE_b,\r\nCTRL_TIMEOUT);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: MSG B failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x12, 0xc0, 0x0d, 0x00, buf + OFFSET_d, SIZE_d,\r\nCTRL_TIMEOUT);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: MSG D failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x01, 0xc0, 0x0e, 0x00, buf + OFFSET_e, SIZE_e,\r\nCTRL_TIMEOUT);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: MSG E failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x01, 0xc0, 0x0f, 0x00, buf + OFFSET_f, SIZE_f,\r\nCTRL_TIMEOUT);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: MSG F failed\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int speedtch_start_synchro(struct speedtch_instance_data *instance)\r\n{\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\nunsigned char *buf = instance->scratch_buffer;\r\nint ret;\r\natm_dbg(usbatm, "%s entered\n", __func__);\r\nmemset(buf, 0, 2);\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x12, 0xc0, 0x04, 0x00,\r\nbuf, 2, CTRL_TIMEOUT);\r\nif (ret < 0)\r\natm_warn(usbatm, "failed to start ADSL synchronisation: %d\n", ret);\r\nelse\r\natm_dbg(usbatm, "%s: modem prodded. %d bytes returned: %02x %02x\n",\r\n__func__, ret, buf[0], buf[1]);\r\nreturn ret;\r\n}\r\nstatic void speedtch_check_status(struct work_struct *work)\r\n{\r\nstruct speedtch_instance_data *instance =\r\ncontainer_of(work, struct speedtch_instance_data,\r\nstatus_check_work);\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nstruct atm_dev *atm_dev = usbatm->atm_dev;\r\nunsigned char *buf = instance->scratch_buffer;\r\nint down_speed, up_speed, ret;\r\nunsigned char status;\r\n#ifdef VERBOSE_DEBUG\r\natm_dbg(usbatm, "%s entered\n", __func__);\r\n#endif\r\nret = speedtch_read_status(instance);\r\nif (ret < 0) {\r\natm_warn(usbatm, "error %d fetching device status\n", ret);\r\ninstance->poll_delay = min(2 * instance->poll_delay, MAX_POLL_DELAY);\r\nreturn;\r\n}\r\ninstance->poll_delay = max(instance->poll_delay / 2, MIN_POLL_DELAY);\r\nstatus = buf[OFFSET_7];\r\nif ((status != instance->last_status) || !status) {\r\natm_dbg(usbatm, "%s: line state 0x%02x\n", __func__, status);\r\nswitch (status) {\r\ncase 0:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\nif (instance->last_status)\r\natm_info(usbatm, "ADSL line is down\n");\r\nret = speedtch_start_synchro(instance);\r\nbreak;\r\ncase 0x08:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_UNKNOWN);\r\natm_info(usbatm, "ADSL line is blocked?\n");\r\nbreak;\r\ncase 0x10:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\r\natm_info(usbatm, "ADSL line is synchronising\n");\r\nbreak;\r\ncase 0x20:\r\ndown_speed = buf[OFFSET_b] | (buf[OFFSET_b + 1] << 8)\r\n| (buf[OFFSET_b + 2] << 16) | (buf[OFFSET_b + 3] << 24);\r\nup_speed = buf[OFFSET_b + 4] | (buf[OFFSET_b + 5] << 8)\r\n| (buf[OFFSET_b + 6] << 16) | (buf[OFFSET_b + 7] << 24);\r\nif (!(down_speed & 0x0000ffff) && !(up_speed & 0x0000ffff)) {\r\ndown_speed >>= 16;\r\nup_speed >>= 16;\r\n}\r\natm_dev->link_rate = down_speed * 1000 / 424;\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_FOUND);\r\natm_info(usbatm,\r\n"ADSL line is up (%d kb/s down | %d kb/s up)\n",\r\ndown_speed, up_speed);\r\nbreak;\r\ndefault:\r\natm_dev_signal_change(atm_dev, ATM_PHY_SIG_UNKNOWN);\r\natm_info(usbatm, "unknown line state %02x\n", status);\r\nbreak;\r\n}\r\ninstance->last_status = status;\r\n}\r\n}\r\nstatic void speedtch_status_poll(unsigned long data)\r\n{\r\nstruct speedtch_instance_data *instance = (void *)data;\r\nschedule_work(&instance->status_check_work);\r\nif (instance->poll_delay < MAX_POLL_DELAY)\r\nmod_timer(&instance->status_check_timer, jiffies + msecs_to_jiffies(instance->poll_delay));\r\nelse\r\natm_warn(instance->usbatm, "Too many failures - disabling line status polling\n");\r\n}\r\nstatic void speedtch_resubmit_int(unsigned long data)\r\n{\r\nstruct speedtch_instance_data *instance = (void *)data;\r\nstruct urb *int_urb = instance->int_urb;\r\nint ret;\r\natm_dbg(instance->usbatm, "%s entered\n", __func__);\r\nif (int_urb) {\r\nret = usb_submit_urb(int_urb, GFP_ATOMIC);\r\nif (!ret)\r\nschedule_work(&instance->status_check_work);\r\nelse {\r\natm_dbg(instance->usbatm, "%s: usb_submit_urb failed with result %d\n", __func__, ret);\r\nmod_timer(&instance->resubmit_timer, jiffies + msecs_to_jiffies(RESUBMIT_DELAY));\r\n}\r\n}\r\n}\r\nstatic void speedtch_handle_int(struct urb *int_urb)\r\n{\r\nstruct speedtch_instance_data *instance = int_urb->context;\r\nstruct usbatm_data *usbatm = instance->usbatm;\r\nunsigned int count = int_urb->actual_length;\r\nint status = int_urb->status;\r\nint ret;\r\nstatic const unsigned char up_int[6] = { 0xa1, 0x00, 0x01, 0x00, 0x00, 0x00 };\r\nstatic const unsigned char down_int[6] = { 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\natm_dbg(usbatm, "%s entered\n", __func__);\r\nif (status < 0) {\r\natm_dbg(usbatm, "%s: nonzero urb status %d!\n", __func__, status);\r\ngoto fail;\r\n}\r\nif ((count == 6) && !memcmp(up_int, instance->int_data, 6)) {\r\ndel_timer(&instance->status_check_timer);\r\natm_info(usbatm, "DSL line goes up\n");\r\n} else if ((count == 6) && !memcmp(down_int, instance->int_data, 6)) {\r\natm_info(usbatm, "DSL line goes down\n");\r\n} else {\r\nint i;\r\natm_dbg(usbatm, "%s: unknown interrupt packet of length %d:", __func__, count);\r\nfor (i = 0; i < count; i++)\r\nprintk(" %02x", instance->int_data[i]);\r\nprintk("\n");\r\ngoto fail;\r\n}\r\nif ((int_urb = instance->int_urb)) {\r\nret = usb_submit_urb(int_urb, GFP_ATOMIC);\r\nschedule_work(&instance->status_check_work);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: usb_submit_urb failed with result %d\n", __func__, ret);\r\ngoto fail;\r\n}\r\n}\r\nreturn;\r\nfail:\r\nif ((int_urb = instance->int_urb))\r\nmod_timer(&instance->resubmit_timer, jiffies + msecs_to_jiffies(RESUBMIT_DELAY));\r\n}\r\nstatic int speedtch_atm_start(struct usbatm_data *usbatm, struct atm_dev *atm_dev)\r\n{\r\nstruct usb_device *usb_dev = usbatm->usb_dev;\r\nstruct speedtch_instance_data *instance = usbatm->driver_data;\r\nint i, ret;\r\nunsigned char mac_str[13];\r\natm_dbg(usbatm, "%s entered\n", __func__);\r\nmemset(atm_dev->esi, 0, sizeof(atm_dev->esi));\r\nif (usb_string(usb_dev, usb_dev->descriptor.iSerialNumber, mac_str, sizeof(mac_str)) == 12) {\r\nfor (i = 0; i < 6; i++)\r\natm_dev->esi[i] = (hex_to_bin(mac_str[i * 2]) << 4) +\r\nhex_to_bin(mac_str[i * 2 + 1]);\r\n}\r\nret = speedtch_start_synchro(instance);\r\nif (instance->int_urb) {\r\nret = usb_submit_urb(instance->int_urb, GFP_KERNEL);\r\nif (ret < 0) {\r\natm_dbg(usbatm, "%s: submission of interrupt URB failed (%d)!\n", __func__, ret);\r\nusb_free_urb(instance->int_urb);\r\ninstance->int_urb = NULL;\r\n}\r\n}\r\nmod_timer(&instance->status_check_timer, jiffies + msecs_to_jiffies(1000));\r\nreturn 0;\r\n}\r\nstatic void speedtch_atm_stop(struct usbatm_data *usbatm, struct atm_dev *atm_dev)\r\n{\r\nstruct speedtch_instance_data *instance = usbatm->driver_data;\r\nstruct urb *int_urb = instance->int_urb;\r\natm_dbg(usbatm, "%s entered\n", __func__);\r\ndel_timer_sync(&instance->status_check_timer);\r\ninstance->int_urb = NULL;\r\nmb();\r\nusb_kill_urb(int_urb);\r\ndel_timer_sync(&instance->resubmit_timer);\r\nusb_kill_urb(int_urb);\r\ndel_timer_sync(&instance->resubmit_timer);\r\nusb_free_urb(int_urb);\r\nflush_work(&instance->status_check_work);\r\n}\r\nstatic int speedtch_pre_reset(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int speedtch_post_reset(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic void speedtch_release_interfaces(struct usb_device *usb_dev,\r\nint num_interfaces)\r\n{\r\nstruct usb_interface *cur_intf;\r\nint i;\r\nfor (i = 0; i < num_interfaces; i++)\r\nif ((cur_intf = usb_ifnum_to_if(usb_dev, i))) {\r\nusb_set_intfdata(cur_intf, NULL);\r\nusb_driver_release_interface(&speedtch_usb_driver, cur_intf);\r\n}\r\n}\r\nstatic int speedtch_bind(struct usbatm_data *usbatm,\r\nstruct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct usb_interface *cur_intf, *data_intf;\r\nstruct speedtch_instance_data *instance;\r\nint ifnum = intf->altsetting->desc.bInterfaceNumber;\r\nint num_interfaces = usb_dev->actconfig->desc.bNumInterfaces;\r\nint i, ret;\r\nint use_isoc;\r\nusb_dbg(usbatm, "%s entered\n", __func__);\r\nif (usb_dev->descriptor.bDeviceClass != USB_CLASS_VENDOR_SPEC) {\r\nusb_err(usbatm, "%s: wrong device class %d\n", __func__, usb_dev->descriptor.bDeviceClass);\r\nreturn -ENODEV;\r\n}\r\nif (!(data_intf = usb_ifnum_to_if(usb_dev, INTERFACE_DATA))) {\r\nusb_err(usbatm, "%s: data interface not found!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < num_interfaces; i++) {\r\ncur_intf = usb_ifnum_to_if(usb_dev, i);\r\nif ((i != ifnum) && cur_intf) {\r\nret = usb_driver_claim_interface(&speedtch_usb_driver, cur_intf, usbatm);\r\nif (ret < 0) {\r\nusb_err(usbatm, "%s: failed to claim interface %2d (%d)!\n", __func__, i, ret);\r\nspeedtch_release_interfaces(usb_dev, i);\r\nreturn ret;\r\n}\r\n}\r\n}\r\ninstance = kzalloc(sizeof(*instance), GFP_KERNEL);\r\nif (!instance) {\r\nusb_err(usbatm, "%s: no memory for instance data!\n", __func__);\r\nret = -ENOMEM;\r\ngoto fail_release;\r\n}\r\ninstance->usbatm = usbatm;\r\ninstance->params.altsetting = altsetting;\r\ninstance->params.BMaxDSL = BMaxDSL;\r\ninstance->params.ModemMode = ModemMode;\r\nmemcpy(instance->params.ModemOption, DEFAULT_MODEM_OPTION, MODEM_OPTION_LENGTH);\r\nmemcpy(instance->params.ModemOption, ModemOption, num_ModemOption);\r\nuse_isoc = enable_isoc;\r\nif (instance->params.altsetting)\r\nif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, instance->params.altsetting)) < 0) {\r\nusb_err(usbatm, "%s: setting interface to %2d failed (%d)!\n", __func__, instance->params.altsetting, ret);\r\ninstance->params.altsetting = 0;\r\n}\r\nif (!instance->params.altsetting && use_isoc)\r\nif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, DEFAULT_ISOC_ALTSETTING)) < 0) {\r\nusb_dbg(usbatm, "%s: setting interface to %2d failed (%d)!\n", __func__, DEFAULT_ISOC_ALTSETTING, ret);\r\nuse_isoc = 0;\r\n}\r\nif (use_isoc) {\r\nconst struct usb_host_interface *desc = data_intf->cur_altsetting;\r\nconst __u8 target_address = USB_DIR_IN | usbatm->driver->isoc_in;\r\nuse_isoc = 0;\r\nfor (i = 0; i < desc->desc.bNumEndpoints; i++) {\r\nconst struct usb_endpoint_descriptor *endpoint_desc = &desc->endpoint[i].desc;\r\nif ((endpoint_desc->bEndpointAddress == target_address)) {\r\nuse_isoc =\r\nusb_endpoint_xfer_isoc(endpoint_desc);\r\nbreak;\r\n}\r\n}\r\nif (!use_isoc)\r\nusb_info(usbatm, "isochronous transfer not supported - using bulk\n");\r\n}\r\nif (!use_isoc && !instance->params.altsetting)\r\nif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, DEFAULT_BULK_ALTSETTING)) < 0) {\r\nusb_err(usbatm, "%s: setting interface to %2d failed (%d)!\n", __func__, DEFAULT_BULK_ALTSETTING, ret);\r\ngoto fail_free;\r\n}\r\nif (!instance->params.altsetting)\r\ninstance->params.altsetting = use_isoc ? DEFAULT_ISOC_ALTSETTING : DEFAULT_BULK_ALTSETTING;\r\nusbatm->flags |= (use_isoc ? UDSL_USE_ISOC : 0);\r\nINIT_WORK(&instance->status_check_work, speedtch_check_status);\r\ninit_timer(&instance->status_check_timer);\r\ninstance->status_check_timer.function = speedtch_status_poll;\r\ninstance->status_check_timer.data = (unsigned long)instance;\r\ninstance->last_status = 0xff;\r\ninstance->poll_delay = MIN_POLL_DELAY;\r\ninit_timer(&instance->resubmit_timer);\r\ninstance->resubmit_timer.function = speedtch_resubmit_int;\r\ninstance->resubmit_timer.data = (unsigned long)instance;\r\ninstance->int_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (instance->int_urb)\r\nusb_fill_int_urb(instance->int_urb, usb_dev,\r\nusb_rcvintpipe(usb_dev, ENDPOINT_INT),\r\ninstance->int_data, sizeof(instance->int_data),\r\nspeedtch_handle_int, instance, 50);\r\nelse\r\nusb_dbg(usbatm, "%s: no memory for interrupt urb!\n", __func__);\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n0x12, 0xc0, 0x07, 0x00,\r\ninstance->scratch_buffer + OFFSET_7, SIZE_7, 500);\r\nusbatm->flags |= (ret == SIZE_7 ? UDSL_SKIP_HEAVY_INIT : 0);\r\nusb_dbg(usbatm, "%s: firmware %s loaded\n", __func__, usbatm->flags & UDSL_SKIP_HEAVY_INIT ? "already" : "not");\r\nif (!(usbatm->flags & UDSL_SKIP_HEAVY_INIT))\r\nif ((ret = usb_reset_device(usb_dev)) < 0) {\r\nusb_err(usbatm, "%s: device reset failed (%d)!\n", __func__, ret);\r\ngoto fail_free;\r\n}\r\nusbatm->driver_data = instance;\r\nreturn 0;\r\nfail_free:\r\nusb_free_urb(instance->int_urb);\r\nkfree(instance);\r\nfail_release:\r\nspeedtch_release_interfaces(usb_dev, num_interfaces);\r\nreturn ret;\r\n}\r\nstatic void speedtch_unbind(struct usbatm_data *usbatm, struct usb_interface *intf)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct speedtch_instance_data *instance = usbatm->driver_data;\r\nusb_dbg(usbatm, "%s entered\n", __func__);\r\nspeedtch_release_interfaces(usb_dev, usb_dev->actconfig->desc.bNumInterfaces);\r\nusb_free_urb(instance->int_urb);\r\nkfree(instance);\r\n}\r\nstatic int speedtch_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nreturn usbatm_usb_probe(intf, id, &speedtch_usbatm_driver);\r\n}
