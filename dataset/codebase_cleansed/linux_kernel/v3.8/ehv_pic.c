void ehv_pic_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int src = virq_to_hw(d->irq);\r\nev_int_set_mask(src, 0);\r\n}\r\nvoid ehv_pic_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int src = virq_to_hw(d->irq);\r\nev_int_set_mask(src, 1);\r\n}\r\nvoid ehv_pic_end_irq(struct irq_data *d)\r\n{\r\nunsigned int src = virq_to_hw(d->irq);\r\nev_int_eoi(src);\r\n}\r\nvoid ehv_pic_direct_end_irq(struct irq_data *d)\r\n{\r\nout_be32(mpic_percpu_base_vaddr + MPIC_EOI / 4, 0);\r\n}\r\nint ehv_pic_set_affinity(struct irq_data *d, const struct cpumask *dest,\r\nbool force)\r\n{\r\nunsigned int src = virq_to_hw(d->irq);\r\nunsigned int config, prio, cpu_dest;\r\nint cpuid = irq_choose_cpu(dest);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ehv_pic_lock, flags);\r\nev_int_get_config(src, &config, &prio, &cpu_dest);\r\nev_int_set_config(src, config, prio, cpuid);\r\nspin_unlock_irqrestore(&ehv_pic_lock, flags);\r\nreturn 0;\r\n}\r\nstatic unsigned int ehv_pic_type_to_vecpri(unsigned int type)\r\n{\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nreturn EHV_PIC_INFO(VECPRI_SENSE_EDGE) |\r\nEHV_PIC_INFO(VECPRI_POLARITY_POSITIVE);\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nreturn EHV_PIC_INFO(VECPRI_SENSE_EDGE) |\r\nEHV_PIC_INFO(VECPRI_POLARITY_NEGATIVE);\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nreturn EHV_PIC_INFO(VECPRI_SENSE_LEVEL) |\r\nEHV_PIC_INFO(VECPRI_POLARITY_POSITIVE);\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ndefault:\r\nreturn EHV_PIC_INFO(VECPRI_SENSE_LEVEL) |\r\nEHV_PIC_INFO(VECPRI_POLARITY_NEGATIVE);\r\n}\r\n}\r\nint ehv_pic_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nunsigned int src = virq_to_hw(d->irq);\r\nstruct irq_desc *desc = irq_to_desc(d->irq);\r\nunsigned int vecpri, vold, vnew, prio, cpu_dest;\r\nunsigned long flags;\r\nif (flow_type == IRQ_TYPE_NONE)\r\nflow_type = IRQ_TYPE_LEVEL_LOW;\r\nirq_settings_clr_level(desc);\r\nirq_settings_set_trigger_mask(desc, flow_type);\r\nif (flow_type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\r\nirq_settings_set_level(desc);\r\nvecpri = ehv_pic_type_to_vecpri(flow_type);\r\nspin_lock_irqsave(&ehv_pic_lock, flags);\r\nev_int_get_config(src, &vold, &prio, &cpu_dest);\r\nvnew = vold & ~(EHV_PIC_INFO(VECPRI_POLARITY_MASK) |\r\nEHV_PIC_INFO(VECPRI_SENSE_MASK));\r\nvnew |= vecpri;\r\nprio = 8;\r\nev_int_set_config(src, vecpri, prio, cpu_dest);\r\nspin_unlock_irqrestore(&ehv_pic_lock, flags);\r\nreturn 0;\r\n}\r\nunsigned int ehv_pic_get_irq(void)\r\n{\r\nint irq;\r\nBUG_ON(global_ehv_pic == NULL);\r\nif (global_ehv_pic->coreint_flag)\r\nirq = mfspr(SPRN_EPR);\r\nelse\r\nev_int_iack(0, &irq);\r\nif (irq == 0xFFFF)\r\nreturn NO_IRQ;\r\nreturn irq_linear_revmap(global_ehv_pic->irqhost, irq);\r\n}\r\nstatic int ehv_pic_host_match(struct irq_domain *h, struct device_node *node)\r\n{\r\nreturn h->of_node == NULL || h->of_node == node;\r\n}\r\nstatic int ehv_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct ehv_pic *ehv_pic = h->host_data;\r\nstruct irq_chip *chip;\r\nchip = &ehv_pic->hc_irq;\r\nif (mpic_percpu_base_vaddr)\r\nif (hwirq_intspec[hw] & IRQ_TYPE_MPIC_DIRECT)\r\nchip = &ehv_pic_direct_eoi_irq_chip;\r\nirq_set_chip_data(virq, chip);\r\nirq_set_chip_and_handler(virq, chip, handle_fasteoi_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int ehv_pic_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\nstatic unsigned char map_of_senses_to_linux_irqtype[4] = {\r\nIRQ_TYPE_EDGE_FALLING,\r\nIRQ_TYPE_EDGE_RISING,\r\nIRQ_TYPE_LEVEL_LOW,\r\nIRQ_TYPE_LEVEL_HIGH,\r\n};\r\n*out_hwirq = intspec[0];\r\nif (intsize > 1) {\r\nhwirq_intspec[intspec[0]] = intspec[1];\r\n*out_flags = map_of_senses_to_linux_irqtype[intspec[1] &\r\n~IRQ_TYPE_MPIC_DIRECT];\r\n} else {\r\n*out_flags = IRQ_TYPE_NONE;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init ehv_pic_init(void)\r\n{\r\nstruct device_node *np, *np2;\r\nstruct ehv_pic *ehv_pic;\r\nint coreint_flag = 1;\r\nnp = of_find_compatible_node(NULL, NULL, "epapr,hv-pic");\r\nif (!np) {\r\npr_err("ehv_pic_init: could not find epapr,hv-pic node\n");\r\nreturn;\r\n}\r\nif (!of_find_property(np, "has-external-proxy", NULL))\r\ncoreint_flag = 0;\r\nehv_pic = kzalloc(sizeof(struct ehv_pic), GFP_KERNEL);\r\nif (!ehv_pic) {\r\nof_node_put(np);\r\nreturn;\r\n}\r\nehv_pic->irqhost = irq_domain_add_linear(np, NR_EHV_PIC_INTS,\r\n&ehv_pic_host_ops, ehv_pic);\r\nif (!ehv_pic->irqhost) {\r\nof_node_put(np);\r\nkfree(ehv_pic);\r\nreturn;\r\n}\r\nnp2 = of_find_compatible_node(NULL, NULL, "fsl,hv-mpic-per-cpu");\r\nif (np2) {\r\nmpic_percpu_base_vaddr = of_iomap(np2, 0);\r\nif (!mpic_percpu_base_vaddr)\r\npr_err("ehv_pic_init: of_iomap failed\n");\r\nof_node_put(np2);\r\n}\r\nehv_pic->hc_irq = ehv_pic_irq_chip;\r\nehv_pic->hc_irq.irq_set_affinity = ehv_pic_set_affinity;\r\nehv_pic->coreint_flag = coreint_flag;\r\nglobal_ehv_pic = ehv_pic;\r\nirq_set_default_host(global_ehv_pic->irqhost);\r\n}
