static inline struct saa7127_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa7127_state, sd);\r\n}\r\nstatic int saa7127_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int saa7127_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (i2c_smbus_write_byte_data(client, reg, val) == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "I2C Write Problem\n");\r\nreturn -1;\r\n}\r\nstatic int saa7127_write_inittab(struct v4l2_subdev *sd,\r\nconst struct i2c_reg_value *regs)\r\n{\r\nwhile (regs->reg != 0) {\r\nsaa7127_write(sd, regs->reg, regs->value);\r\nregs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_vps(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nint enable = (data->line != 0);\r\nif (enable && (data->field != 0 || data->line != 16))\r\nreturn -EINVAL;\r\nif (state->vps_enable != enable) {\r\nv4l2_dbg(1, debug, sd, "Turn VPS Signal %s\n", enable ? "on" : "off");\r\nsaa7127_write(sd, 0x54, enable << 7);\r\nstate->vps_enable = enable;\r\n}\r\nif (!enable)\r\nreturn 0;\r\nstate->vps_data[0] = data->data[2];\r\nstate->vps_data[1] = data->data[8];\r\nstate->vps_data[2] = data->data[9];\r\nstate->vps_data[3] = data->data[10];\r\nstate->vps_data[4] = data->data[11];\r\nv4l2_dbg(1, debug, sd, "Set VPS data %*ph\n", 5, state->vps_data);\r\nsaa7127_write(sd, 0x55, state->vps_data[0]);\r\nsaa7127_write(sd, 0x56, state->vps_data[1]);\r\nsaa7127_write(sd, 0x57, state->vps_data[2]);\r\nsaa7127_write(sd, 0x58, state->vps_data[3]);\r\nsaa7127_write(sd, 0x59, state->vps_data[4]);\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_cc(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nu16 cc = data->data[1] << 8 | data->data[0];\r\nint enable = (data->line != 0);\r\nif (enable && (data->field != 0 || data->line != 21))\r\nreturn -EINVAL;\r\nif (state->cc_enable != enable) {\r\nv4l2_dbg(1, debug, sd,\r\n"Turn CC %s\n", enable ? "on" : "off");\r\nsaa7127_write(sd, SAA7127_REG_CLOSED_CAPTION,\r\n(state->xds_enable << 7) | (enable << 6) | 0x11);\r\nstate->cc_enable = enable;\r\n}\r\nif (!enable)\r\nreturn 0;\r\nv4l2_dbg(2, debug, sd, "CC data: %04x\n", cc);\r\nsaa7127_write(sd, SAA7127_REG_LINE_21_ODD_0, cc & 0xff);\r\nsaa7127_write(sd, SAA7127_REG_LINE_21_ODD_1, cc >> 8);\r\nstate->cc_data = cc;\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_xds(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nu16 xds = data->data[1] << 8 | data->data[0];\r\nint enable = (data->line != 0);\r\nif (enable && (data->field != 1 || data->line != 21))\r\nreturn -EINVAL;\r\nif (state->xds_enable != enable) {\r\nv4l2_dbg(1, debug, sd, "Turn XDS %s\n", enable ? "on" : "off");\r\nsaa7127_write(sd, SAA7127_REG_CLOSED_CAPTION,\r\n(enable << 7) | (state->cc_enable << 6) | 0x11);\r\nstate->xds_enable = enable;\r\n}\r\nif (!enable)\r\nreturn 0;\r\nv4l2_dbg(2, debug, sd, "XDS data: %04x\n", xds);\r\nsaa7127_write(sd, SAA7127_REG_LINE_21_EVEN_0, xds & 0xff);\r\nsaa7127_write(sd, SAA7127_REG_LINE_21_EVEN_1, xds >> 8);\r\nstate->xds_data = xds;\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_wss(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nint enable = (data->line != 0);\r\nif (enable && (data->field != 0 || data->line != 23))\r\nreturn -EINVAL;\r\nif (state->wss_enable != enable) {\r\nv4l2_dbg(1, debug, sd, "Turn WSS %s\n", enable ? "on" : "off");\r\nsaa7127_write(sd, 0x27, enable << 7);\r\nstate->wss_enable = enable;\r\n}\r\nif (!enable)\r\nreturn 0;\r\nsaa7127_write(sd, 0x26, data->data[0]);\r\nsaa7127_write(sd, 0x27, 0x80 | (data->data[1] & 0x3f));\r\nv4l2_dbg(1, debug, sd,\r\n"WSS mode: %s\n", wss_strs[data->data[0] & 0xf]);\r\nstate->wss_mode = (data->data[1] & 0x3f) << 8 | data->data[0];\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_video_enable(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nif (enable) {\r\nv4l2_dbg(1, debug, sd, "Enable Video Output\n");\r\nsaa7127_write(sd, 0x2d, state->reg_2d);\r\nsaa7127_write(sd, 0x61, state->reg_61);\r\n} else {\r\nv4l2_dbg(1, debug, sd, "Disable Video Output\n");\r\nsaa7127_write(sd, 0x2d, (state->reg_2d & 0xf0));\r\nsaa7127_write(sd, 0x61, (state->reg_61 | 0xc0));\r\n}\r\nstate->video_enable = enable;\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nconst struct i2c_reg_value *inittab;\r\nif (std & V4L2_STD_525_60) {\r\nv4l2_dbg(1, debug, sd, "Selecting 60 Hz video Standard\n");\r\ninittab = saa7127_init_config_60hz;\r\nstate->reg_61 = SAA7127_60HZ_DAC_CONTROL;\r\n} else if (state->ident == V4L2_IDENT_SAA7129 &&\r\n(std & V4L2_STD_SECAM) &&\r\n!(std & (V4L2_STD_625_50 & ~V4L2_STD_SECAM))) {\r\nv4l2_dbg(1, debug, sd,\r\n"Selecting 50 Hz SECAM video Standard\n");\r\ninittab = saa7127_init_config_50hz_secam;\r\nstate->reg_61 = SAA7127_50HZ_SECAM_DAC_CONTROL;\r\n} else {\r\nv4l2_dbg(1, debug, sd, "Selecting 50 Hz PAL video Standard\n");\r\ninittab = saa7127_init_config_50hz_pal;\r\nstate->reg_61 = SAA7127_50HZ_PAL_DAC_CONTROL;\r\n}\r\nsaa7127_write_inittab(sd, inittab);\r\nstate->std = std;\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_output_type(struct v4l2_subdev *sd, int output)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nswitch (output) {\r\ncase SAA7127_OUTPUT_TYPE_RGB:\r\nstate->reg_2d = 0x0f;\r\nstate->reg_3a = 0x13;\r\nbreak;\r\ncase SAA7127_OUTPUT_TYPE_COMPOSITE:\r\nif (state->ident == V4L2_IDENT_SAA7129)\r\nstate->reg_2d = 0x20;\r\nelse\r\nstate->reg_2d = 0x08;\r\nstate->reg_3a = 0x13;\r\nbreak;\r\ncase SAA7127_OUTPUT_TYPE_SVIDEO:\r\nif (state->ident == V4L2_IDENT_SAA7129)\r\nstate->reg_2d = 0x18;\r\nelse\r\nstate->reg_2d = 0xff;\r\nstate->reg_3a = 0x13;\r\nbreak;\r\ncase SAA7127_OUTPUT_TYPE_YUV_V:\r\nstate->reg_2d = 0x4f;\r\nstate->reg_3a = 0x0b;\r\nbreak;\r\ncase SAA7127_OUTPUT_TYPE_YUV_C:\r\nstate->reg_2d = 0x0f;\r\nstate->reg_3a = 0x0b;\r\nbreak;\r\ncase SAA7127_OUTPUT_TYPE_BOTH:\r\nif (state->ident == V4L2_IDENT_SAA7129)\r\nstate->reg_2d = 0x38;\r\nelse\r\nstate->reg_2d = 0xbf;\r\nstate->reg_3a = 0x13;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd,\r\n"Selecting %s output type\n", output_strs[output]);\r\nsaa7127_write(sd, 0x2d, state->reg_2d);\r\nsaa7127_write(sd, 0x3a, state->reg_3a | state->reg_3a_cb);\r\nstate->output_type = output;\r\nreturn 0;\r\n}\r\nstatic int saa7127_set_input_type(struct v4l2_subdev *sd, int input)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nswitch (input) {\r\ncase SAA7127_INPUT_TYPE_NORMAL:\r\nv4l2_dbg(1, debug, sd, "Selecting Normal Encoder Input\n");\r\nstate->reg_3a_cb = 0;\r\nbreak;\r\ncase SAA7127_INPUT_TYPE_TEST_IMAGE:\r\nv4l2_dbg(1, debug, sd, "Selecting Color Bar generator\n");\r\nstate->reg_3a_cb = 0x80;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsaa7127_write(sd, 0x3a, state->reg_3a | state->reg_3a_cb);\r\nstate->input_type = input;\r\nreturn 0;\r\n}\r\nstatic int saa7127_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nif (state->std == std)\r\nreturn 0;\r\nreturn saa7127_set_std(sd, std);\r\n}\r\nstatic int saa7127_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nint rc = 0;\r\nif (state->input_type != input)\r\nrc = saa7127_set_input_type(sd, input);\r\nif (rc == 0 && state->output_type != output)\r\nrc = saa7127_set_output_type(sd, output);\r\nreturn rc;\r\n}\r\nstatic int saa7127_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nif (state->video_enable == enable)\r\nreturn 0;\r\nreturn saa7127_set_video_enable(sd, enable);\r\n}\r\nstatic int saa7127_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nmemset(fmt->service_lines, 0, sizeof(fmt->service_lines));\r\nif (state->vps_enable)\r\nfmt->service_lines[0][16] = V4L2_SLICED_VPS;\r\nif (state->wss_enable)\r\nfmt->service_lines[0][23] = V4L2_SLICED_WSS_625;\r\nif (state->cc_enable) {\r\nfmt->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\r\nfmt->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\r\n}\r\nfmt->service_set =\r\n(state->vps_enable ? V4L2_SLICED_VPS : 0) |\r\n(state->wss_enable ? V4L2_SLICED_WSS_625 : 0) |\r\n(state->cc_enable ? V4L2_SLICED_CAPTION_525 : 0);\r\nreturn 0;\r\n}\r\nstatic int saa7127_s_vbi_data(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *data)\r\n{\r\nswitch (data->id) {\r\ncase V4L2_SLICED_WSS_625:\r\nreturn saa7127_set_wss(sd, data);\r\ncase V4L2_SLICED_VPS:\r\nreturn saa7127_set_vps(sd, data);\r\ncase V4L2_SLICED_CAPTION_525:\r\nif (data->field == 0)\r\nreturn saa7127_set_cc(sd, data);\r\nreturn saa7127_set_xds(sd, data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7127_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->val = saa7127_read(sd, reg->reg & 0xff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int saa7127_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nsaa7127_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int saa7127_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, state->ident, 0);\r\n}\r\nstatic int saa7127_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct saa7127_state *state = to_state(sd);\r\nv4l2_info(sd, "Standard: %s\n", (state->std & V4L2_STD_525_60) ? "60 Hz" : "50 Hz");\r\nv4l2_info(sd, "Input: %s\n", state->input_type ? "color bars" : "normal");\r\nv4l2_info(sd, "Output: %s\n", state->video_enable ?\r\noutput_strs[state->output_type] : "disabled");\r\nv4l2_info(sd, "WSS: %s\n", state->wss_enable ?\r\nwss_strs[state->wss_mode] : "disabled");\r\nv4l2_info(sd, "VPS: %s\n", state->vps_enable ? "enabled" : "disabled");\r\nv4l2_info(sd, "CC: %s\n", state->cc_enable ? "enabled" : "disabled");\r\nreturn 0;\r\n}\r\nstatic int saa7127_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa7127_state *state;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_sliced_vbi_data vbi = { 0, 0, 0, 0 };\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, debug, client, "detecting saa7127 client on address 0x%x\n",\r\nclient->addr << 1);\r\nstate = kzalloc(sizeof(struct saa7127_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa7127_ops);\r\nif ((saa7127_read(sd, 0) & 0xe4) != 0 ||\r\n(saa7127_read(sd, 0x29) & 0x3f) != 0x1d) {\r\nv4l2_dbg(1, debug, sd, "saa7127 not found\n");\r\nkfree(state);\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_data) {\r\nstate->ident = id->driver_data;\r\n} else {\r\nint read_result;\r\nread_result = saa7127_read(sd, SAA7129_REG_FADE_KEY_COL2);\r\nsaa7127_write(sd, SAA7129_REG_FADE_KEY_COL2, 0xaa);\r\nif (saa7127_read(sd, SAA7129_REG_FADE_KEY_COL2) == 0xaa) {\r\nsaa7127_write(sd, SAA7129_REG_FADE_KEY_COL2,\r\nread_result);\r\nstate->ident = V4L2_IDENT_SAA7129;\r\nstrlcpy(client->name, "saa7129", I2C_NAME_SIZE);\r\n} else {\r\nstate->ident = V4L2_IDENT_SAA7127;\r\nstrlcpy(client->name, "saa7127", I2C_NAME_SIZE);\r\n}\r\n}\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nv4l2_dbg(1, debug, sd, "Configuring encoder\n");\r\nsaa7127_write_inittab(sd, saa7127_init_config_common);\r\nsaa7127_set_std(sd, V4L2_STD_NTSC);\r\nsaa7127_set_output_type(sd, SAA7127_OUTPUT_TYPE_BOTH);\r\nsaa7127_set_vps(sd, &vbi);\r\nsaa7127_set_wss(sd, &vbi);\r\nsaa7127_set_cc(sd, &vbi);\r\nsaa7127_set_xds(sd, &vbi);\r\nif (test_image == 1)\r\nsaa7127_set_input_type(sd, SAA7127_INPUT_TYPE_TEST_IMAGE);\r\nelse\r\nsaa7127_set_input_type(sd, SAA7127_INPUT_TYPE_NORMAL);\r\nsaa7127_set_video_enable(sd, 1);\r\nif (state->ident == V4L2_IDENT_SAA7129)\r\nsaa7127_write_inittab(sd, saa7129_init_config_extra);\r\nreturn 0;\r\n}\r\nstatic int saa7127_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nsaa7127_set_video_enable(sd, 0);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
