static int spi_ppc4xx_txrx(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct ppc4xx_spi *hw;\r\nu8 data;\r\ndev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",\r\nt->tx_buf, t->rx_buf, t->len);\r\nhw = spi_master_get_devdata(spi->master);\r\nhw->tx = t->tx_buf;\r\nhw->rx = t->rx_buf;\r\nhw->len = t->len;\r\nhw->count = 0;\r\ndata = hw->tx ? hw->tx[0] : 0;\r\nout_8(&hw->regs->txd, data);\r\nout_8(&hw->regs->cr, SPI_PPC4XX_CR_STR);\r\nwait_for_completion(&hw->done);\r\nreturn hw->count;\r\n}\r\nstatic int spi_ppc4xx_setupxfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);\r\nstruct spi_ppc4xx_cs *cs = spi->controller_state;\r\nint scr;\r\nu8 cdm = 0;\r\nu32 speed;\r\nu8 bits_per_word;\r\nbits_per_word = spi->bits_per_word;\r\nspeed = spi->max_speed_hz;\r\nif (t) {\r\nif (t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nif (t->speed_hz)\r\nspeed = min(t->speed_hz, spi->max_speed_hz);\r\n}\r\nif (bits_per_word != 8) {\r\ndev_err(&spi->dev, "invalid bits-per-word (%d)\n",\r\nbits_per_word);\r\nreturn -EINVAL;\r\n}\r\nif (!speed || (speed > spi->max_speed_hz)) {\r\ndev_err(&spi->dev, "invalid speed_hz (%d)\n", speed);\r\nreturn -EINVAL;\r\n}\r\nout_8(&hw->regs->mode, cs->mode);\r\nscr = (hw->opb_freq / speed) - 1;\r\nif (scr > 0)\r\ncdm = min(scr, 0xff);\r\ndev_dbg(&spi->dev, "setting pre-scaler to %d (hz %d)\n", cdm, speed);\r\nif (in_8(&hw->regs->cdm) != cdm)\r\nout_8(&hw->regs->cdm, cdm);\r\nspin_lock(&hw->bitbang.lock);\r\nif (!hw->bitbang.busy) {\r\nhw->bitbang.chipselect(spi, BITBANG_CS_INACTIVE);\r\n}\r\nspin_unlock(&hw->bitbang.lock);\r\nreturn 0;\r\n}\r\nstatic int spi_ppc4xx_setup(struct spi_device *spi)\r\n{\r\nstruct spi_ppc4xx_cs *cs = spi->controller_state;\r\nif (spi->bits_per_word != 8) {\r\ndev_err(&spi->dev, "invalid bits-per-word (%d)\n",\r\nspi->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nif (!spi->max_speed_hz) {\r\ndev_err(&spi->dev, "invalid max_speed_hz (must be non-zero)\n");\r\nreturn -EINVAL;\r\n}\r\nif (cs == NULL) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi->controller_state = cs;\r\n}\r\ncs->mode = SPI_PPC4XX_MODE_SPE;\r\nswitch (spi->mode & (SPI_CPHA | SPI_CPOL)) {\r\ncase SPI_MODE_0:\r\ncs->mode |= SPI_CLK_MODE0;\r\nbreak;\r\ncase SPI_MODE_1:\r\ncs->mode |= SPI_CLK_MODE1;\r\nbreak;\r\ncase SPI_MODE_2:\r\ncs->mode |= SPI_CLK_MODE2;\r\nbreak;\r\ncase SPI_MODE_3:\r\ncs->mode |= SPI_CLK_MODE3;\r\nbreak;\r\n}\r\nif (spi->mode & SPI_LSB_FIRST)\r\ncs->mode |= SPI_PPC4XX_MODE_RD;\r\nreturn 0;\r\n}\r\nstatic void spi_ppc4xx_chipsel(struct spi_device *spi, int value)\r\n{\r\nstruct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);\r\nunsigned int cs = spi->chip_select;\r\nunsigned int cspol;\r\nif (!hw->master->num_chipselect || hw->gpios[cs] == -EEXIST)\r\nreturn;\r\ncspol = spi->mode & SPI_CS_HIGH ? 1 : 0;\r\nif (value == BITBANG_CS_INACTIVE)\r\ncspol = !cspol;\r\ngpio_set_value(hw->gpios[cs], cspol);\r\n}\r\nstatic irqreturn_t spi_ppc4xx_int(int irq, void *dev_id)\r\n{\r\nstruct ppc4xx_spi *hw;\r\nu8 status;\r\nu8 data;\r\nunsigned int count;\r\nhw = (struct ppc4xx_spi *)dev_id;\r\nstatus = in_8(&hw->regs->sr);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (unlikely(status & SPI_PPC4XX_SR_BSY)) {\r\nu8 lstatus;\r\nint cnt = 0;\r\ndev_dbg(hw->dev, "got interrupt but spi still busy?\n");\r\ndo {\r\nndelay(10);\r\nlstatus = in_8(&hw->regs->sr);\r\n} while (++cnt < 100 && lstatus & SPI_PPC4XX_SR_BSY);\r\nif (cnt >= 100) {\r\ndev_err(hw->dev, "busywait: too many loops!\n");\r\ncomplete(&hw->done);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nstatus = in_8(&hw->regs->sr);\r\ndev_dbg(hw->dev, "loops %d status %x\n", cnt, status);\r\n}\r\n}\r\ncount = hw->count;\r\nhw->count++;\r\ndata = in_8(&hw->regs->rxd);\r\nif (hw->rx)\r\nhw->rx[count] = data;\r\ncount++;\r\nif (count < hw->len) {\r\ndata = hw->tx ? hw->tx[count] : 0;\r\nout_8(&hw->regs->txd, data);\r\nout_8(&hw->regs->cr, SPI_PPC4XX_CR_STR);\r\n} else {\r\ncomplete(&hw->done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spi_ppc4xx_cleanup(struct spi_device *spi)\r\n{\r\nkfree(spi->controller_state);\r\n}\r\nstatic void spi_ppc4xx_enable(struct ppc4xx_spi *hw)\r\n{\r\ndcri_clrset(SDR0, SDR0_PFC1, 0x80000000 >> 14, 0);\r\n}\r\nstatic void free_gpios(struct ppc4xx_spi *hw)\r\n{\r\nif (hw->master->num_chipselect) {\r\nint i;\r\nfor (i = 0; i < hw->master->num_chipselect; i++)\r\nif (gpio_is_valid(hw->gpios[i]))\r\ngpio_free(hw->gpios[i]);\r\nkfree(hw->gpios);\r\nhw->gpios = NULL;\r\n}\r\n}\r\nstatic int __init spi_ppc4xx_of_probe(struct platform_device *op)\r\n{\r\nstruct ppc4xx_spi *hw;\r\nstruct spi_master *master;\r\nstruct spi_bitbang *bbp;\r\nstruct resource resource;\r\nstruct device_node *np = op->dev.of_node;\r\nstruct device *dev = &op->dev;\r\nstruct device_node *opbnp;\r\nint ret;\r\nint num_gpios;\r\nconst unsigned int *clk;\r\nmaster = spi_alloc_master(dev, sizeof *hw);\r\nif (master == NULL)\r\nreturn -ENOMEM;\r\nmaster->dev.of_node = np;\r\ndev_set_drvdata(dev, master);\r\nhw = spi_master_get_devdata(master);\r\nhw->master = spi_master_get(master);\r\nhw->dev = dev;\r\ninit_completion(&hw->done);\r\nnum_gpios = of_gpio_count(np);\r\nif (num_gpios) {\r\nint i;\r\nhw->gpios = kzalloc(sizeof(int) * num_gpios, GFP_KERNEL);\r\nif (!hw->gpios) {\r\nret = -ENOMEM;\r\ngoto free_master;\r\n}\r\nfor (i = 0; i < num_gpios; i++) {\r\nint gpio;\r\nenum of_gpio_flags flags;\r\ngpio = of_get_gpio_flags(np, i, &flags);\r\nhw->gpios[i] = gpio;\r\nif (gpio_is_valid(gpio)) {\r\nret = gpio_request(gpio, np->name);\r\nif (ret < 0) {\r\ndev_err(dev, "can't request gpio "\r\n"#%d: %d\n", i, ret);\r\ngoto free_gpios;\r\n}\r\ngpio_direction_output(gpio,\r\n!!(flags & OF_GPIO_ACTIVE_LOW));\r\n} else if (gpio == -EEXIST) {\r\n;\r\n} else {\r\ndev_err(dev, "invalid gpio #%d: %d\n", i, gpio);\r\nret = -EINVAL;\r\ngoto free_gpios;\r\n}\r\n}\r\n}\r\nbbp = &hw->bitbang;\r\nbbp->master = hw->master;\r\nbbp->setup_transfer = spi_ppc4xx_setupxfer;\r\nbbp->chipselect = spi_ppc4xx_chipsel;\r\nbbp->txrx_bufs = spi_ppc4xx_txrx;\r\nbbp->use_dma = 0;\r\nbbp->master->setup = spi_ppc4xx_setup;\r\nbbp->master->cleanup = spi_ppc4xx_cleanup;\r\nbbp->master->mode_bits =\r\nSPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST;\r\nbbp->master->num_chipselect = num_gpios;\r\nopbnp = of_find_compatible_node(NULL, NULL, "ibm,opb");\r\nif (opbnp == NULL) {\r\ndev_err(dev, "OPB: cannot find node\n");\r\nret = -ENODEV;\r\ngoto free_gpios;\r\n}\r\nclk = of_get_property(opbnp, "clock-frequency", NULL);\r\nif (clk == NULL) {\r\ndev_err(dev, "OPB: no clock-frequency property set\n");\r\nof_node_put(opbnp);\r\nret = -ENODEV;\r\ngoto free_gpios;\r\n}\r\nhw->opb_freq = *clk;\r\nhw->opb_freq >>= 2;\r\nof_node_put(opbnp);\r\nret = of_address_to_resource(np, 0, &resource);\r\nif (ret) {\r\ndev_err(dev, "error while parsing device node resource\n");\r\ngoto free_gpios;\r\n}\r\nhw->mapbase = resource.start;\r\nhw->mapsize = resource_size(&resource);\r\nif (hw->mapsize < sizeof(struct spi_ppc4xx_regs)) {\r\ndev_err(dev, "too small to map registers\n");\r\nret = -EINVAL;\r\ngoto free_gpios;\r\n}\r\nhw->irqnum = irq_of_parse_and_map(np, 0);\r\nret = request_irq(hw->irqnum, spi_ppc4xx_int,\r\n0, "spi_ppc4xx_of", (void *)hw);\r\nif (ret) {\r\ndev_err(dev, "unable to allocate interrupt\n");\r\ngoto free_gpios;\r\n}\r\nif (!request_mem_region(hw->mapbase, hw->mapsize, DRIVER_NAME)) {\r\ndev_err(dev, "resource unavailable\n");\r\nret = -EBUSY;\r\ngoto request_mem_error;\r\n}\r\nhw->regs = ioremap(hw->mapbase, sizeof(struct spi_ppc4xx_regs));\r\nif (!hw->regs) {\r\ndev_err(dev, "unable to memory map registers\n");\r\nret = -ENXIO;\r\ngoto map_io_error;\r\n}\r\nspi_ppc4xx_enable(hw);\r\ndev->dma_mask = 0;\r\nret = spi_bitbang_start(bbp);\r\nif (ret) {\r\ndev_err(dev, "failed to register SPI master\n");\r\ngoto unmap_regs;\r\n}\r\ndev_info(dev, "driver initialized\n");\r\nreturn 0;\r\nunmap_regs:\r\niounmap(hw->regs);\r\nmap_io_error:\r\nrelease_mem_region(hw->mapbase, hw->mapsize);\r\nrequest_mem_error:\r\nfree_irq(hw->irqnum, hw);\r\nfree_gpios:\r\nfree_gpios(hw);\r\nfree_master:\r\ndev_set_drvdata(dev, NULL);\r\nspi_master_put(master);\r\ndev_err(dev, "initialization failed\n");\r\nreturn ret;\r\n}\r\nstatic int __exit spi_ppc4xx_of_remove(struct platform_device *op)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(&op->dev);\r\nstruct ppc4xx_spi *hw = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&hw->bitbang);\r\ndev_set_drvdata(&op->dev, NULL);\r\nrelease_mem_region(hw->mapbase, hw->mapsize);\r\nfree_irq(hw->irqnum, hw);\r\niounmap(hw->regs);\r\nfree_gpios(hw);\r\nreturn 0;\r\n}
