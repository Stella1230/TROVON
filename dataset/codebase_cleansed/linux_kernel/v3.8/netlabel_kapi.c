int netlbl_cfg_map_del(const char *domain,\r\nu16 family,\r\nconst void *addr,\r\nconst void *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nif (addr == NULL && mask == NULL) {\r\nreturn netlbl_domhsh_remove(domain, audit_info);\r\n} else if (addr != NULL && mask != NULL) {\r\nswitch (family) {\r\ncase AF_INET:\r\nreturn netlbl_domhsh_remove_af4(domain, addr, mask,\r\naudit_info);\r\ndefault:\r\nreturn -EPFNOSUPPORT;\r\n}\r\n} else\r\nreturn -EINVAL;\r\n}\r\nint netlbl_cfg_unlbl_map_add(const char *domain,\r\nu16 family,\r\nconst void *addr,\r\nconst void *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct netlbl_dom_map *entry;\r\nstruct netlbl_domaddr_map *addrmap = NULL;\r\nstruct netlbl_domaddr4_map *map4 = NULL;\r\nstruct netlbl_domaddr6_map *map6 = NULL;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nif (domain != NULL) {\r\nentry->domain = kstrdup(domain, GFP_ATOMIC);\r\nif (entry->domain == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\n}\r\nif (addr == NULL && mask == NULL)\r\nentry->type = NETLBL_NLTYPE_UNLABELED;\r\nelse if (addr != NULL && mask != NULL) {\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\r\nif (addrmap == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\nswitch (family) {\r\ncase AF_INET: {\r\nconst struct in_addr *addr4 = addr;\r\nconst struct in_addr *mask4 = mask;\r\nmap4 = kzalloc(sizeof(*map4), GFP_ATOMIC);\r\nif (map4 == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\nmap4->type = NETLBL_NLTYPE_UNLABELED;\r\nmap4->list.addr = addr4->s_addr & mask4->s_addr;\r\nmap4->list.mask = mask4->s_addr;\r\nmap4->list.valid = 1;\r\nret_val = netlbl_af4list_add(&map4->list,\r\n&addrmap->list4);\r\nif (ret_val != 0)\r\ngoto cfg_unlbl_map_add_failure;\r\nbreak;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6: {\r\nconst struct in6_addr *addr6 = addr;\r\nconst struct in6_addr *mask6 = mask;\r\nmap6 = kzalloc(sizeof(*map6), GFP_ATOMIC);\r\nif (map6 == NULL)\r\ngoto cfg_unlbl_map_add_failure;\r\nmap6->type = NETLBL_NLTYPE_UNLABELED;\r\nmap6->list.addr = *addr6;\r\nmap6->list.addr.s6_addr32[0] &= mask6->s6_addr32[0];\r\nmap6->list.addr.s6_addr32[1] &= mask6->s6_addr32[1];\r\nmap6->list.addr.s6_addr32[2] &= mask6->s6_addr32[2];\r\nmap6->list.addr.s6_addr32[3] &= mask6->s6_addr32[3];\r\nmap6->list.mask = *mask6;\r\nmap6->list.valid = 1;\r\nret_val = netlbl_af6list_add(&map6->list,\r\n&addrmap->list6);\r\nif (ret_val != 0)\r\ngoto cfg_unlbl_map_add_failure;\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\ngoto cfg_unlbl_map_add_failure;\r\nbreak;\r\n}\r\nentry->type_def.addrsel = addrmap;\r\nentry->type = NETLBL_NLTYPE_ADDRSELECT;\r\n} else {\r\nret_val = -EINVAL;\r\ngoto cfg_unlbl_map_add_failure;\r\n}\r\nret_val = netlbl_domhsh_add(entry, audit_info);\r\nif (ret_val != 0)\r\ngoto cfg_unlbl_map_add_failure;\r\nreturn 0;\r\ncfg_unlbl_map_add_failure:\r\nkfree(entry->domain);\r\nkfree(entry);\r\nkfree(addrmap);\r\nkfree(map4);\r\nkfree(map6);\r\nreturn ret_val;\r\n}\r\nint netlbl_cfg_unlbl_static_add(struct net *net,\r\nconst char *dev_name,\r\nconst void *addr,\r\nconst void *mask,\r\nu16 family,\r\nu32 secid,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nu32 addr_len;\r\nswitch (family) {\r\ncase AF_INET:\r\naddr_len = sizeof(struct in_addr);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\naddr_len = sizeof(struct in6_addr);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EPFNOSUPPORT;\r\n}\r\nreturn netlbl_unlhsh_add(net,\r\ndev_name, addr, mask, addr_len,\r\nsecid, audit_info);\r\n}\r\nint netlbl_cfg_unlbl_static_del(struct net *net,\r\nconst char *dev_name,\r\nconst void *addr,\r\nconst void *mask,\r\nu16 family,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nu32 addr_len;\r\nswitch (family) {\r\ncase AF_INET:\r\naddr_len = sizeof(struct in_addr);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\naddr_len = sizeof(struct in6_addr);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EPFNOSUPPORT;\r\n}\r\nreturn netlbl_unlhsh_remove(net,\r\ndev_name, addr, mask, addr_len,\r\naudit_info);\r\n}\r\nint netlbl_cfg_cipsov4_add(struct cipso_v4_doi *doi_def,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nreturn cipso_v4_doi_add(doi_def, audit_info);\r\n}\r\nvoid netlbl_cfg_cipsov4_del(u32 doi, struct netlbl_audit *audit_info)\r\n{\r\ncipso_v4_doi_remove(doi, audit_info);\r\n}\r\nint netlbl_cfg_cipsov4_map_add(u32 doi,\r\nconst char *domain,\r\nconst struct in_addr *addr,\r\nconst struct in_addr *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct cipso_v4_doi *doi_def;\r\nstruct netlbl_dom_map *entry;\r\nstruct netlbl_domaddr_map *addrmap = NULL;\r\nstruct netlbl_domaddr4_map *addrinfo = NULL;\r\ndoi_def = cipso_v4_doi_getdef(doi);\r\nif (doi_def == NULL)\r\nreturn -ENOENT;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\ngoto out_entry;\r\nif (domain != NULL) {\r\nentry->domain = kstrdup(domain, GFP_ATOMIC);\r\nif (entry->domain == NULL)\r\ngoto out_domain;\r\n}\r\nif (addr == NULL && mask == NULL) {\r\nentry->type_def.cipsov4 = doi_def;\r\nentry->type = NETLBL_NLTYPE_CIPSOV4;\r\n} else if (addr != NULL && mask != NULL) {\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\r\nif (addrmap == NULL)\r\ngoto out_addrmap;\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\naddrinfo = kzalloc(sizeof(*addrinfo), GFP_ATOMIC);\r\nif (addrinfo == NULL)\r\ngoto out_addrinfo;\r\naddrinfo->type_def.cipsov4 = doi_def;\r\naddrinfo->type = NETLBL_NLTYPE_CIPSOV4;\r\naddrinfo->list.addr = addr->s_addr & mask->s_addr;\r\naddrinfo->list.mask = mask->s_addr;\r\naddrinfo->list.valid = 1;\r\nret_val = netlbl_af4list_add(&addrinfo->list, &addrmap->list4);\r\nif (ret_val != 0)\r\ngoto cfg_cipsov4_map_add_failure;\r\nentry->type_def.addrsel = addrmap;\r\nentry->type = NETLBL_NLTYPE_ADDRSELECT;\r\n} else {\r\nret_val = -EINVAL;\r\ngoto out_addrmap;\r\n}\r\nret_val = netlbl_domhsh_add(entry, audit_info);\r\nif (ret_val != 0)\r\ngoto cfg_cipsov4_map_add_failure;\r\nreturn 0;\r\ncfg_cipsov4_map_add_failure:\r\nkfree(addrinfo);\r\nout_addrinfo:\r\nkfree(addrmap);\r\nout_addrmap:\r\nkfree(entry->domain);\r\nout_domain:\r\nkfree(entry);\r\nout_entry:\r\ncipso_v4_doi_putdef(doi_def);\r\nreturn ret_val;\r\n}\r\nint netlbl_secattr_catmap_walk(struct netlbl_lsm_secattr_catmap *catmap,\r\nu32 offset)\r\n{\r\nstruct netlbl_lsm_secattr_catmap *iter = catmap;\r\nu32 node_idx;\r\nu32 node_bit;\r\nNETLBL_CATMAP_MAPTYPE bitmap;\r\nif (offset > iter->startbit) {\r\nwhile (offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {\r\niter = iter->next;\r\nif (iter == NULL)\r\nreturn -ENOENT;\r\n}\r\nnode_idx = (offset - iter->startbit) / NETLBL_CATMAP_MAPSIZE;\r\nnode_bit = offset - iter->startbit -\r\n(NETLBL_CATMAP_MAPSIZE * node_idx);\r\n} else {\r\nnode_idx = 0;\r\nnode_bit = 0;\r\n}\r\nbitmap = iter->bitmap[node_idx] >> node_bit;\r\nfor (;;) {\r\nif (bitmap != 0) {\r\nwhile ((bitmap & NETLBL_CATMAP_BIT) == 0) {\r\nbitmap >>= 1;\r\nnode_bit++;\r\n}\r\nreturn iter->startbit +\r\n(NETLBL_CATMAP_MAPSIZE * node_idx) + node_bit;\r\n}\r\nif (++node_idx >= NETLBL_CATMAP_MAPCNT) {\r\nif (iter->next != NULL) {\r\niter = iter->next;\r\nnode_idx = 0;\r\n} else\r\nreturn -ENOENT;\r\n}\r\nbitmap = iter->bitmap[node_idx];\r\nnode_bit = 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint netlbl_secattr_catmap_walk_rng(struct netlbl_lsm_secattr_catmap *catmap,\r\nu32 offset)\r\n{\r\nstruct netlbl_lsm_secattr_catmap *iter = catmap;\r\nu32 node_idx;\r\nu32 node_bit;\r\nNETLBL_CATMAP_MAPTYPE bitmask;\r\nNETLBL_CATMAP_MAPTYPE bitmap;\r\nif (offset > iter->startbit) {\r\nwhile (offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {\r\niter = iter->next;\r\nif (iter == NULL)\r\nreturn -ENOENT;\r\n}\r\nnode_idx = (offset - iter->startbit) / NETLBL_CATMAP_MAPSIZE;\r\nnode_bit = offset - iter->startbit -\r\n(NETLBL_CATMAP_MAPSIZE * node_idx);\r\n} else {\r\nnode_idx = 0;\r\nnode_bit = 0;\r\n}\r\nbitmask = NETLBL_CATMAP_BIT << node_bit;\r\nfor (;;) {\r\nbitmap = iter->bitmap[node_idx];\r\nwhile (bitmask != 0 && (bitmap & bitmask) != 0) {\r\nbitmask <<= 1;\r\nnode_bit++;\r\n}\r\nif (bitmask != 0)\r\nreturn iter->startbit +\r\n(NETLBL_CATMAP_MAPSIZE * node_idx) +\r\nnode_bit - 1;\r\nelse if (++node_idx >= NETLBL_CATMAP_MAPCNT) {\r\nif (iter->next == NULL)\r\nreturn iter->startbit + NETLBL_CATMAP_SIZE - 1;\r\niter = iter->next;\r\nnode_idx = 0;\r\n}\r\nbitmask = NETLBL_CATMAP_BIT;\r\nnode_bit = 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint netlbl_secattr_catmap_setbit(struct netlbl_lsm_secattr_catmap *catmap,\r\nu32 bit,\r\ngfp_t flags)\r\n{\r\nstruct netlbl_lsm_secattr_catmap *iter = catmap;\r\nu32 node_bit;\r\nu32 node_idx;\r\nwhile (iter->next != NULL &&\r\nbit >= (iter->startbit + NETLBL_CATMAP_SIZE))\r\niter = iter->next;\r\nif (bit >= (iter->startbit + NETLBL_CATMAP_SIZE)) {\r\niter->next = netlbl_secattr_catmap_alloc(flags);\r\nif (iter->next == NULL)\r\nreturn -ENOMEM;\r\niter = iter->next;\r\niter->startbit = bit & ~(NETLBL_CATMAP_SIZE - 1);\r\n}\r\nnode_idx = (bit - iter->startbit) / NETLBL_CATMAP_MAPSIZE;\r\nnode_bit = bit - iter->startbit - (NETLBL_CATMAP_MAPSIZE * node_idx);\r\niter->bitmap[node_idx] |= NETLBL_CATMAP_BIT << node_bit;\r\nreturn 0;\r\n}\r\nint netlbl_secattr_catmap_setrng(struct netlbl_lsm_secattr_catmap *catmap,\r\nu32 start,\r\nu32 end,\r\ngfp_t flags)\r\n{\r\nint ret_val = 0;\r\nstruct netlbl_lsm_secattr_catmap *iter = catmap;\r\nu32 iter_max_spot;\r\nu32 spot;\r\nwhile (iter->next != NULL &&\r\nstart >= (iter->startbit + NETLBL_CATMAP_SIZE))\r\niter = iter->next;\r\niter_max_spot = iter->startbit + NETLBL_CATMAP_SIZE;\r\nfor (spot = start; spot <= end && ret_val == 0; spot++) {\r\nif (spot >= iter_max_spot && iter->next != NULL) {\r\niter = iter->next;\r\niter_max_spot = iter->startbit + NETLBL_CATMAP_SIZE;\r\n}\r\nret_val = netlbl_secattr_catmap_setbit(iter, spot, flags);\r\n}\r\nreturn ret_val;\r\n}\r\nint netlbl_enabled(void)\r\n{\r\nreturn (atomic_read(&netlabel_mgmt_protocount) > 0);\r\n}\r\nint netlbl_sock_setattr(struct sock *sk,\r\nu16 family,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct netlbl_dom_map *dom_entry;\r\nrcu_read_lock();\r\ndom_entry = netlbl_domhsh_getentry(secattr->domain);\r\nif (dom_entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto socket_setattr_return;\r\n}\r\nswitch (family) {\r\ncase AF_INET:\r\nswitch (dom_entry->type) {\r\ncase NETLBL_NLTYPE_ADDRSELECT:\r\nret_val = -EDESTADDRREQ;\r\nbreak;\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_sock_setattr(sk,\r\ndom_entry->type_def.cipsov4,\r\nsecattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nret_val = 0;\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nsocket_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nvoid netlbl_sock_delattr(struct sock *sk)\r\n{\r\ncipso_v4_sock_delattr(sk);\r\n}\r\nint netlbl_sock_getattr(struct sock *sk,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nswitch (sk->sk_family) {\r\ncase AF_INET:\r\nret_val = cipso_v4_sock_getattr(sk, secattr);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = -ENOMSG;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nreturn ret_val;\r\n}\r\nint netlbl_conn_setattr(struct sock *sk,\r\nstruct sockaddr *addr,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct sockaddr_in *addr4;\r\nstruct netlbl_domaddr4_map *af4_entry;\r\nrcu_read_lock();\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\naddr4 = (struct sockaddr_in *)addr;\r\naf4_entry = netlbl_domhsh_getentry_af4(secattr->domain,\r\naddr4->sin_addr.s_addr);\r\nif (af4_entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto conn_setattr_return;\r\n}\r\nswitch (af4_entry->type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_sock_setattr(sk,\r\naf4_entry->type_def.cipsov4,\r\nsecattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\ncipso_v4_sock_delattr(sk);\r\nret_val = 0;\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nconn_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nint netlbl_req_setattr(struct request_sock *req,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct netlbl_dom_map *dom_entry;\r\nstruct netlbl_domaddr4_map *af4_entry;\r\nu32 proto_type;\r\nstruct cipso_v4_doi *proto_cv4;\r\nrcu_read_lock();\r\ndom_entry = netlbl_domhsh_getentry(secattr->domain);\r\nif (dom_entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto req_setattr_return;\r\n}\r\nswitch (req->rsk_ops->family) {\r\ncase AF_INET:\r\nif (dom_entry->type == NETLBL_NLTYPE_ADDRSELECT) {\r\nstruct inet_request_sock *req_inet = inet_rsk(req);\r\naf4_entry = netlbl_domhsh_getentry_af4(secattr->domain,\r\nreq_inet->rmt_addr);\r\nif (af4_entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto req_setattr_return;\r\n}\r\nproto_type = af4_entry->type;\r\nproto_cv4 = af4_entry->type_def.cipsov4;\r\n} else {\r\nproto_type = dom_entry->type;\r\nproto_cv4 = dom_entry->type_def.cipsov4;\r\n}\r\nswitch (proto_type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_req_setattr(req, proto_cv4, secattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\ncipso_v4_req_delattr(req);\r\nret_val = 0;\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nreq_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nvoid netlbl_req_delattr(struct request_sock *req)\r\n{\r\ncipso_v4_req_delattr(req);\r\n}\r\nint netlbl_skbuff_setattr(struct sk_buff *skb,\r\nu16 family,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nint ret_val;\r\nstruct iphdr *hdr4;\r\nstruct netlbl_domaddr4_map *af4_entry;\r\nrcu_read_lock();\r\nswitch (family) {\r\ncase AF_INET:\r\nhdr4 = ip_hdr(skb);\r\naf4_entry = netlbl_domhsh_getentry_af4(secattr->domain,\r\nhdr4->daddr);\r\nif (af4_entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto skbuff_setattr_return;\r\n}\r\nswitch (af4_entry->type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = cipso_v4_skbuff_setattr(skb,\r\naf4_entry->type_def.cipsov4,\r\nsecattr);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nret_val = cipso_v4_skbuff_delattr(skb);\r\nbreak;\r\ndefault:\r\nret_val = -ENOENT;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nret_val = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EPROTONOSUPPORT;\r\n}\r\nskbuff_setattr_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nint netlbl_skbuff_getattr(const struct sk_buff *skb,\r\nu16 family,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\nif (CIPSO_V4_OPTEXIST(skb) &&\r\ncipso_v4_skbuff_getattr(skb, secattr) == 0)\r\nreturn 0;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nbreak;\r\n#endif\r\n}\r\nreturn netlbl_unlabel_getattr(skb, family, secattr);\r\n}\r\nvoid netlbl_skbuff_err(struct sk_buff *skb, int error, int gateway)\r\n{\r\nif (CIPSO_V4_OPTEXIST(skb))\r\ncipso_v4_error(skb, error, gateway);\r\n}\r\nvoid netlbl_cache_invalidate(void)\r\n{\r\ncipso_v4_cache_invalidate();\r\n}\r\nint netlbl_cache_add(const struct sk_buff *skb,\r\nconst struct netlbl_lsm_secattr *secattr)\r\n{\r\nif ((secattr->flags & NETLBL_SECATTR_CACHE) == 0)\r\nreturn -ENOMSG;\r\nif (CIPSO_V4_OPTEXIST(skb))\r\nreturn cipso_v4_cache_add(skb, secattr);\r\nreturn -ENOMSG;\r\n}\r\nstruct audit_buffer *netlbl_audit_start(int type,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nreturn netlbl_audit_start_common(type, audit_info);\r\n}\r\nstatic int __init netlbl_init(void)\r\n{\r\nint ret_val;\r\nprintk(KERN_INFO "NetLabel: Initializing\n");\r\nprintk(KERN_INFO "NetLabel: domain hash size = %u\n",\r\n(1 << NETLBL_DOMHSH_BITSIZE));\r\nprintk(KERN_INFO "NetLabel: protocols ="\r\n" UNLABELED"\r\n" CIPSOv4"\r\n"\n");\r\nret_val = netlbl_domhsh_init(NETLBL_DOMHSH_BITSIZE);\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nret_val = netlbl_unlabel_init(NETLBL_UNLHSH_BITSIZE);\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nret_val = netlbl_netlink_init();\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nret_val = netlbl_unlabel_defconf();\r\nif (ret_val != 0)\r\ngoto init_failure;\r\nprintk(KERN_INFO "NetLabel: unlabeled traffic allowed by default\n");\r\nreturn 0;\r\ninit_failure:\r\npanic("NetLabel: failed to initialize properly (%d)\n", ret_val);\r\n}
