static inline void buffer_filled(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q,\r\nstruct cx231xx_buffer *buf)\r\n{\r\ncx231xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\ndo_gettimeofday(&buf->vb.ts);\r\nif (dev->USE_ISO)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\nelse\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic inline void print_err_status(struct cx231xx *dev, int packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\ncx231xx_isocdbg("URB status %d [%s].\n", status, errmsg);\r\n} else {\r\ncx231xx_isocdbg("URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline void get_next_buf(struct cx231xx_dmaqueue *dma_q,\r\nstruct cx231xx_buffer **buf)\r\n{\r\nstruct cx231xx_video_mode *vmode =\r\ncontainer_of(dma_q, struct cx231xx_video_mode, vidq);\r\nstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\r\nchar *outp;\r\nif (list_empty(&dma_q->active)) {\r\ncx231xx_isocdbg("No active queue to serve\n");\r\nif (dev->USE_ISO)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\nelse\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct cx231xx_buffer, vb.queue);\r\noutp = videobuf_to_vmalloc(&(*buf)->vb);\r\nmemset(outp, 0, (*buf)->vb.size);\r\nif (dev->USE_ISO)\r\ndev->video_mode.isoc_ctl.buf = *buf;\r\nelse\r\ndev->video_mode.bulk_ctl.buf = *buf;\r\nreturn;\r\n}\r\nstatic inline int cx231xx_isoc_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nint i, rc = 1;\r\nunsigned char *p_buffer;\r\nu32 bytes_parsed = 0, buffer_size = 0;\r\nu8 sav_eav = 0;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length <= 0) {\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length >\r\ndev->video_mode.max_pkt_size) {\r\ncx231xx_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\np_buffer = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nbuffer_size = urb->iso_frame_desc[i].actual_length;\r\nbytes_parsed = 0;\r\nif (dma_q->is_partial_line) {\r\nsav_eav = dma_q->last_sav;\r\n} else {\r\nsav_eav =\r\ncx231xx_find_boundary_SAV_EAV(p_buffer,\r\ndma_q->partial_buf,\r\n&bytes_parsed);\r\n}\r\nsav_eav &= 0xF0;\r\nif (sav_eav) {\r\nbytes_parsed += cx231xx_get_video_line(dev, dma_q,\r\nsav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\nwhile (bytes_parsed < buffer_size) {\r\nu32 bytes_used = 0;\r\nsav_eav = cx231xx_find_next_SAV_EAV(\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed,\r\n&bytes_used);\r\nbytes_parsed += bytes_used;\r\nsav_eav &= 0xF0;\r\nif (sav_eav && (bytes_parsed < buffer_size)) {\r\nbytes_parsed += cx231xx_get_video_line(dev,\r\ndma_q, sav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\n}\r\nmemcpy(dma_q->partial_buf, p_buffer + buffer_size - 4, 4);\r\nbytes_parsed = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline int cx231xx_bulk_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nint rc = 1;\r\nunsigned char *p_buffer;\r\nu32 bytes_parsed = 0, buffer_size = 0;\r\nu8 sav_eav = 0;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nif (1) {\r\np_buffer = urb->transfer_buffer;\r\nbuffer_size = urb->actual_length;\r\nbytes_parsed = 0;\r\nif (dma_q->is_partial_line) {\r\nsav_eav = dma_q->last_sav;\r\n} else {\r\nsav_eav =\r\ncx231xx_find_boundary_SAV_EAV(p_buffer,\r\ndma_q->partial_buf,\r\n&bytes_parsed);\r\n}\r\nsav_eav &= 0xF0;\r\nif (sav_eav) {\r\nbytes_parsed += cx231xx_get_video_line(dev, dma_q,\r\nsav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\nwhile (bytes_parsed < buffer_size) {\r\nu32 bytes_used = 0;\r\nsav_eav = cx231xx_find_next_SAV_EAV(\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed,\r\n&bytes_used);\r\nbytes_parsed += bytes_used;\r\nsav_eav &= 0xF0;\r\nif (sav_eav && (bytes_parsed < buffer_size)) {\r\nbytes_parsed += cx231xx_get_video_line(dev,\r\ndma_q, sav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\n}\r\nmemcpy(dma_q->partial_buf, p_buffer + buffer_size - 4, 4);\r\nbytes_parsed = 0;\r\n}\r\nreturn rc;\r\n}\r\nu8 cx231xx_find_boundary_SAV_EAV(u8 *p_buffer, u8 *partial_buf,\r\nu32 *p_bytes_used)\r\n{\r\nu32 bytes_used;\r\nu8 boundary_bytes[8];\r\nu8 sav_eav = 0;\r\n*p_bytes_used = 0;\r\nmemcpy(boundary_bytes, partial_buf, 4);\r\nmemcpy(boundary_bytes + 4, p_buffer, 4);\r\nsav_eav = cx231xx_find_next_SAV_EAV((u8 *)&boundary_bytes, 8,\r\n&bytes_used);\r\nif (sav_eav) {\r\n*p_bytes_used = bytes_used - 4;\r\n}\r\nreturn sav_eav;\r\n}\r\nu8 cx231xx_find_next_SAV_EAV(u8 *p_buffer, u32 buffer_size, u32 *p_bytes_used)\r\n{\r\nu32 i;\r\nu8 sav_eav = 0;\r\nif (buffer_size < 4) {\r\n*p_bytes_used = buffer_size;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < (buffer_size - 3); i++) {\r\nif ((p_buffer[i] == 0xFF) &&\r\n(p_buffer[i + 1] == 0x00) && (p_buffer[i + 2] == 0x00)) {\r\n*p_bytes_used = i + 4;\r\nsav_eav = p_buffer[i + 3];\r\nreturn sav_eav;\r\n}\r\n}\r\n*p_bytes_used = buffer_size;\r\nreturn 0;\r\n}\r\nu32 cx231xx_get_video_line(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q, u8 sav_eav,\r\nu8 *p_buffer, u32 buffer_size)\r\n{\r\nu32 bytes_copied = 0;\r\nint current_field = -1;\r\nswitch (sav_eav) {\r\ncase SAV_ACTIVE_VIDEO_FIELD1:\r\nif ((buffer_size > 3) && (p_buffer[0] == 0xFF) &&\r\n(p_buffer[1] == 0x00) && (p_buffer[2] == 0x00) &&\r\n((p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD1) ||\r\n(p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD2) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD1) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD2)))\r\nreturn bytes_copied;\r\ncurrent_field = 1;\r\nbreak;\r\ncase SAV_ACTIVE_VIDEO_FIELD2:\r\nif ((buffer_size > 3) && (p_buffer[0] == 0xFF) &&\r\n(p_buffer[1] == 0x00) && (p_buffer[2] == 0x00) &&\r\n((p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD1) ||\r\n(p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD2) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD1) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD2)))\r\nreturn bytes_copied;\r\ncurrent_field = 2;\r\nbreak;\r\n}\r\ndma_q->last_sav = sav_eav;\r\nbytes_copied = cx231xx_copy_video_line(dev, dma_q, p_buffer,\r\nbuffer_size, current_field);\r\nreturn bytes_copied;\r\n}\r\nu32 cx231xx_copy_video_line(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q, u8 *p_line,\r\nu32 length, int field_number)\r\n{\r\nu32 bytes_to_copy;\r\nstruct cx231xx_buffer *buf;\r\nu32 _line_size = dev->width * 2;\r\nif (dma_q->current_field != field_number)\r\ncx231xx_reset_video_buffer(dev, dma_q);\r\nif (dev->USE_ISO)\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nelse\r\nbuf = dev->video_mode.bulk_ctl.buf;\r\ndma_q->current_field = field_number;\r\nbytes_to_copy = dma_q->bytes_left_in_line;\r\nif (bytes_to_copy > length)\r\nbytes_to_copy = length;\r\nif (dma_q->lines_completed >= dma_q->lines_per_field) {\r\ndma_q->bytes_left_in_line -= bytes_to_copy;\r\ndma_q->is_partial_line = (dma_q->bytes_left_in_line == 0) ?\r\n0 : 1;\r\nreturn 0;\r\n}\r\ndma_q->is_partial_line = 1;\r\nif (!buf) {\r\ndma_q->bytes_left_in_line -= bytes_to_copy;\r\ndma_q->is_partial_line = (dma_q->bytes_left_in_line == 0)\r\n? 0 : 1;\r\nreturn bytes_to_copy;\r\n}\r\ncx231xx_do_copy(dev, dma_q, p_line, bytes_to_copy);\r\ndma_q->pos += bytes_to_copy;\r\ndma_q->bytes_left_in_line -= bytes_to_copy;\r\nif (dma_q->bytes_left_in_line == 0) {\r\ndma_q->bytes_left_in_line = _line_size;\r\ndma_q->lines_completed++;\r\ndma_q->is_partial_line = 0;\r\nif (cx231xx_is_buffer_done(dev, dma_q) && buf) {\r\nbuffer_filled(dev, dma_q, buf);\r\ndma_q->pos = 0;\r\nbuf = NULL;\r\ndma_q->lines_completed = 0;\r\n}\r\n}\r\nreturn bytes_to_copy;\r\n}\r\nvoid cx231xx_reset_video_buffer(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q)\r\n{\r\nstruct cx231xx_buffer *buf;\r\nif (dma_q->current_field == 1) {\r\nif (dma_q->lines_completed >= dma_q->lines_per_field)\r\ndma_q->field1_done = 1;\r\nelse\r\ndma_q->field1_done = 0;\r\n}\r\nif (dev->USE_ISO)\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nelse\r\nbuf = dev->video_mode.bulk_ctl.buf;\r\nif (buf == NULL) {\r\nget_next_buf(dma_q, &buf);\r\ndma_q->pos = 0;\r\ndma_q->field1_done = 0;\r\ndma_q->current_field = -1;\r\n}\r\ndma_q->bytes_left_in_line = dev->width << 1;\r\ndma_q->lines_completed = 0;\r\n}\r\nint cx231xx_do_copy(struct cx231xx *dev, struct cx231xx_dmaqueue *dma_q,\r\nu8 *p_buffer, u32 bytes_to_copy)\r\n{\r\nu8 *p_out_buffer = NULL;\r\nu32 current_line_bytes_copied = 0;\r\nstruct cx231xx_buffer *buf;\r\nu32 _line_size = dev->width << 1;\r\nvoid *startwrite;\r\nint offset, lencopy;\r\nif (dev->USE_ISO)\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nelse\r\nbuf = dev->video_mode.bulk_ctl.buf;\r\nif (buf == NULL)\r\nreturn -1;\r\np_out_buffer = videobuf_to_vmalloc(&buf->vb);\r\ncurrent_line_bytes_copied = _line_size - dma_q->bytes_left_in_line;\r\noffset = (dma_q->current_field == 1) ? 0 : _line_size;\r\nstartwrite = p_out_buffer + offset;\r\nstartwrite += (dma_q->lines_completed * _line_size * 2);\r\nstartwrite += current_line_bytes_copied;\r\nlencopy = dma_q->bytes_left_in_line > bytes_to_copy ?\r\nbytes_to_copy : dma_q->bytes_left_in_line;\r\nif ((u8 *)(startwrite + lencopy) > (u8 *)(p_out_buffer + buf->vb.size))\r\nreturn 0;\r\ncx231xx_swab((u16 *) p_buffer, (u16 *) startwrite, (u16) lencopy);\r\nreturn 0;\r\n}\r\nvoid cx231xx_swab(u16 *from, u16 *to, u16 len)\r\n{\r\nu16 i;\r\nif (len <= 0)\r\nreturn;\r\nfor (i = 0; i < len / 2; i++)\r\nto[i] = (from[i] << 8) | (from[i] >> 8);\r\n}\r\nu8 cx231xx_is_buffer_done(struct cx231xx *dev, struct cx231xx_dmaqueue *dma_q)\r\n{\r\nu8 buffer_complete = 0;\r\nbuffer_complete = ((dma_q->current_field == 2) &&\r\n(dma_q->lines_completed >= dma_q->lines_per_field) &&\r\ndma_q->field1_done);\r\nreturn buffer_complete;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\n*size = (fh->dev->width * fh->dev->height * dev->format->depth + 7)>>3;\r\nif (0 == *count)\r\n*count = CX231XX_DEF_BUF;\r\nif (*count < CX231XX_MIN_BUF)\r\n*count = CX231XX_MIN_BUF;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct cx231xx_buffer *buf)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned long flags = 0;\r\nif (in_interrupt())\r\nBUG();\r\nspin_lock_irqsave(&dev->video_mode.slock, flags);\r\nif (dev->USE_ISO) {\r\nif (dev->video_mode.isoc_ctl.buf == buf)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\n} else {\r\nif (dev->video_mode.bulk_ctl.buf == buf)\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->video_mode.slock, flags);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx *dev = fh->dev;\r\nint rc = 0, urb_init = 0;\r\nbuf->vb.size = (fh->dev->width * fh->dev->height * dev->format->depth\r\n+ 7) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nbuf->vb.width = dev->width;\r\nbuf->vb.height = dev->height;\r\nbuf->vb.field = field;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nif (dev->USE_ISO) {\r\nif (!dev->video_mode.isoc_ctl.num_bufs)\r\nurb_init = 1;\r\n} else {\r\nif (!dev->video_mode.bulk_ctl.num_bufs)\r\nurb_init = 1;\r\n}\r\nif (urb_init) {\r\ndev->mode_tv = 0;\r\nif (dev->USE_ISO)\r\nrc = cx231xx_init_isoc(dev, CX231XX_NUM_PACKETS,\r\nCX231XX_NUM_BUFS,\r\ndev->video_mode.max_pkt_size,\r\ncx231xx_isoc_copy);\r\nelse\r\nrc = cx231xx_init_bulk(dev, CX231XX_NUM_PACKETS,\r\nCX231XX_NUM_BUFS,\r\ndev->video_mode.max_pkt_size,\r\ncx231xx_bulk_copy);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\nstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = (struct cx231xx *)fh->dev;\r\ncx231xx_isocdbg("cx231xx: called buffer_release\n");\r\nfree_buffer(vq, buf);\r\n}\r\nvoid video_mux(struct cx231xx *dev, int index)\r\n{\r\ndev->video_input = index;\r\ndev->ctl_ainput = INPUT(index)->amux;\r\ncx231xx_set_video_input_mux(dev, index);\r\ncx25840_call(dev, video, s_routing, INPUT(index)->vmux, 0, 0);\r\ncx231xx_set_audio_input(dev, dev->ctl_ainput);\r\ncx231xx_info("video_mux : %d\n", index);\r\ncx231xx_do_mode_ctrl_overrides(dev);\r\n}\r\nstatic int res_get(struct cx231xx_fh *fh)\r\n{\r\nstruct cx231xx *dev = fh->dev;\r\nint rc = 0;\r\nif (fh->stream_on)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (dev->stream_on)\r\nreturn -EBUSY;\r\ndev->stream_on = 1;\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (dev->vbi_stream_on)\r\nreturn -EBUSY;\r\ndev->vbi_stream_on = 1;\r\n} else\r\nreturn -EINVAL;\r\nfh->stream_on = 1;\r\nreturn rc;\r\n}\r\nstatic int res_check(struct cx231xx_fh *fh)\r\n{\r\nreturn fh->stream_on;\r\n}\r\nstatic void res_free(struct cx231xx_fh *fh)\r\n{\r\nstruct cx231xx *dev = fh->dev;\r\nfh->stream_on = 0;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ndev->stream_on = 0;\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\ndev->vbi_stream_on = 0;\r\n}\r\nstatic int check_dev(struct cx231xx *dev)\r\n{\r\nif (dev->state & DEV_DISCONNECTED) {\r\ncx231xx_errdev("v4l2 ioctl: device not present\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.pixelformat = dev->format->fourcc;\r\nf->fmt.pix.bytesperline = (dev->width * dev->format->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * dev->height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic struct cx231xx_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(format); i++)\r\nif (format[i].fourcc == fourcc)\r\nreturn &format[i];\r\nreturn NULL;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned int width = f->fmt.pix.width;\r\nunsigned int height = f->fmt.pix.height;\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\nstruct cx231xx_fmt *fmt;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt) {\r\ncx231xx_videodbg("Fourcc format (%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&width, 48, maxw, 1, &height, 32, maxh, 1, 0);\r\nf->fmt.pix.width = width;\r\nf->fmt.pix.height = height;\r\nf->fmt.pix.pixelformat = fmt->fourcc;\r\nf->fmt.pix.bytesperline = (dev->width * fmt->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nstruct cx231xx_fmt *fmt;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nvidioc_try_fmt_vid_cap(file, priv, f);\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nif (videobuf_queue_is_busy(&fh->vb_vidq)) {\r\ncx231xx_errdev("%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (dev->stream_on && !fh->stream_on) {\r\ncx231xx_errdev("%s device in use by another fh\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\ndev->format = fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\ncall_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nreturn rc;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\n*id = dev->norm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nstruct v4l2_format f;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\ncx231xx_info("vidioc_s_std : 0x%x\n", (unsigned int)*norm);\r\ndev->norm = *norm;\r\nf.fmt.pix.width = dev->width;\r\nf.fmt.pix.height = dev->height;\r\nvidioc_try_fmt_vid_cap(file, priv, &f);\r\ncall_all(dev, core, s_std, dev->norm);\r\nv4l2_fill_mbus_format(&mbus_fmt, &f.fmt.pix, V4L2_MBUS_FMT_FIXED);\r\ncall_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f.fmt.pix, &mbus_fmt);\r\ndev->width = f.fmt.pix.width;\r\ndev->height = f.fmt.pix.height;\r\ncx231xx_do_mode_ctrl_overrides(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nu32 gen_stat;\r\nunsigned int ret, n;\r\nn = i->index;\r\nif (n >= MAX_CX231XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\nif ((CX231XX_VMUX_TELEVISION == INPUT(n)->type) ||\r\n(CX231XX_VMUX_CABLE == INPUT(n)->type))\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->std = dev->vdev->tvnorms;\r\nif (n == dev->video_input) {\r\nret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\nGEN_STAT, 2, &gen_stat, 4);\r\nif (ret > 0) {\r\nif ((gen_stat & FLD_VPRES) == 0x00)\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif ((gen_stat & FLD_HLOCK) == 0x00)\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\n*i = dev->video_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\ndev->mode_tv = 0;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (i >= MAX_CX231XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i)->type)\r\nreturn -EINVAL;\r\nvideo_mux(dev, i);\r\nif (INPUT(i)->type == CX231XX_VMUX_TELEVISION ||\r\nINPUT(i)->type == CX231XX_VMUX_CABLE) {\r\ncall_all(dev, core, s_std, dev->norm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nswitch (a->index) {\r\ncase CX231XX_AMUX_VIDEO:\r\nstrcpy(a->name, "Television");\r\nbreak;\r\ncase CX231XX_AMUX_LINE_IN:\r\nstrcpy(a->name, "Line In");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\na->index = dev->ctl_ainput;\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, const struct v4l2_audio *a)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint status = 0;\r\nif (a->index != dev->ctl_ainput)\r\nreturn -EINVAL;\r\ndev->ctl_ainput = INPUT(a->index)->amux;\r\nstatus = cx231xx_set_audio_input(dev, dev->ctl_ainput);\r\nreturn status;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint id = qc->id;\r\nint i;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nqc->id = v4l2_ctrl_next(ctrl_classes, qc->id);\r\nif (unlikely(qc->id == 0))\r\nreturn -EINVAL;\r\nmemset(qc, 0, sizeof(*qc));\r\nqc->id = id;\r\nif (qc->id < V4L2_CID_BASE || qc->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < CX231XX_CTLS; i++)\r\nif (cx231xx_ctls[i].v.id == qc->id)\r\nbreak;\r\nif (i == CX231XX_CTLS) {\r\n*qc = no_ctl;\r\nreturn 0;\r\n}\r\n*qc = cx231xx_ctls[i].v;\r\ncall_all(dev, core, queryctrl, qc);\r\nif (qc->type)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\ncall_all(dev, core, g_ctrl, ctrl);\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\ncall_all(dev, core, s_ctrl, ctrl);\r\nreturn rc;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Tuner");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\nt->signal = 0xffff;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\n#if 0\r\ncall_all(dev, tuner, s_tuner, t);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nf->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->ctl_freq;\r\ncall_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nu32 if_frequency = 5400000;\r\ncx231xx_info("Enter vidioc_s_frequency()f->frequency=%d;f->type=%d\n",\r\nf->frequency, f->type);\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nif (unlikely(0 == fh->radio && f->type != V4L2_TUNER_ANALOG_TV))\r\nreturn -EINVAL;\r\nif (unlikely(1 == fh->radio && f->type != V4L2_TUNER_RADIO))\r\nreturn -EINVAL;\r\nrc = cx231xx_tuner_pre_channel_change(dev);\r\ndev->ctl_freq = f->frequency;\r\ncall_all(dev, tuner, s_frequency, f);\r\nrc = cx231xx_tuner_post_channel_change(dev);\r\nif (dev->tuner_type == TUNER_NXP_TDA18271) {\r\nif (dev->norm & (V4L2_STD_MN | V4L2_STD_NTSC_443))\r\nif_frequency = 5400000;\r\nelse if (dev->norm & V4L2_STD_B)\r\nif_frequency = 6000000;\r\nelse if (dev->norm & (V4L2_STD_PAL_DK | V4L2_STD_SECAM_DK))\r\nif_frequency = 6900000;\r\nelse if (dev->norm & V4L2_STD_GH)\r\nif_frequency = 7100000;\r\nelse if (dev->norm & V4L2_STD_PAL_I)\r\nif_frequency = 7250000;\r\nelse if (dev->norm & V4L2_STD_SECAM_L)\r\nif_frequency = 6900000;\r\nelse if (dev->norm & V4L2_STD_SECAM_LC)\r\nif_frequency = 1250000;\r\ncx231xx_info("if_frequency is set to %d\n", if_frequency);\r\ncx231xx_set_Colibri_For_LowIF(dev, if_frequency, 1, 1);\r\nupdate_HH_register_after_set_DIF(dev);\r\n}\r\ncx231xx_info("Set New FREQUENCY to %d\n", f->frequency);\r\nreturn rc;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint ret = 0;\r\nu8 value[4] = { 0, 0, 0, 0 };\r\nu32 data = 0;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\nswitch (reg->match.addr) {\r\ncase 0:\r\nret = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER,\r\n(u16)reg->reg, value, 4);\r\nreg->val = value[0] | value[1] << 8 |\r\nvalue[2] << 16 | value[3] << 24;\r\nbreak;\r\ncase 1:\r\nret = cx231xx_read_i2c_data(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2, &data, 1);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 14:\r\nret = cx231xx_read_i2c_data(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2, &data, 4);\r\nreg->val = le32_to_cpu(data);\r\nbreak;\r\ncase 2:\r\nret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2, &data, 1);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 24:\r\nret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2, &data, 4);\r\nreg->val = le32_to_cpu(data);\r\nbreak;\r\ncase 3:\r\nret = cx231xx_read_i2c_data(dev,\r\nI2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1,\r\n&data, 1);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 34:\r\nret =\r\ncx231xx_read_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1, &data, 4);\r\nreg->val = le32_to_cpu(data);\r\nbreak;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\ncase V4L2_CHIP_MATCH_I2C_DRIVER:\r\ncall_all(dev, core, g_register, reg);\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nswitch (reg->match.addr) {\r\ncase 0:\r\nret = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER,\r\n(u16)reg->reg, value, 4);\r\nreg->val = value[0] | value[1] << 8 |\r\nvalue[2] << 16 | value[3] << 24;\r\nbreak;\r\ncase 0x600:\r\nret = cx231xx_read_i2c_master(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2,\r\n&data, 1 , 0);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 0x880:\r\nif (reg->reg < 0x0b) {\r\nret = cx231xx_read_i2c_master(dev,\r\nVID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2,\r\n&data, 1 , 0);\r\nreg->val = le32_to_cpu(data & 0xff);\r\n} else {\r\nret = cx231xx_read_i2c_master(dev,\r\nVID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2,\r\n&data, 4 , 0);\r\nreg->val = le32_to_cpu(data);\r\n}\r\nbreak;\r\ncase 0x980:\r\nret = cx231xx_read_i2c_master(dev,\r\nI2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1,\r\n&data, 1 , 0);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 0x400:\r\nret =\r\ncx231xx_read_i2c_master(dev, 0x40,\r\n(u16)reg->reg, 1,\r\n&data, 1 , 0);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 0xc01:\r\nret =\r\ncx231xx_read_i2c_master(dev, 0xc0,\r\n(u16)reg->reg, 2,\r\n&data, 38, 1);\r\nreg->val = le32_to_cpu(data);\r\nbreak;\r\ncase 0x022:\r\nret =\r\ncx231xx_read_i2c_master(dev, 0x02,\r\n(u16)reg->reg, 1,\r\n&data, 1, 2);\r\nreg->val = le32_to_cpu(data & 0xff);\r\nbreak;\r\ncase 0x322:\r\nret = cx231xx_read_i2c_master(dev,\r\n0x32,\r\n(u16)reg->reg, 1,\r\n&data, 4 , 2);\r\nreg->val = le32_to_cpu(data);\r\nbreak;\r\ncase 0x342:\r\nret = cx231xx_read_i2c_master(dev,\r\n0x34,\r\n(u16)reg->reg, 1,\r\n&data, 4 , 2);\r\nreg->val = le32_to_cpu(data);\r\nbreak;\r\ndefault:\r\ncx231xx_info("no match device address!!\n");\r\nbreak;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\ndefault:\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\n}\r\ncall_all(dev, core, g_register, reg);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint ret = 0;\r\n__le64 buf;\r\nu32 value;\r\nu8 data[4] = { 0, 0, 0, 0 };\r\nbuf = cpu_to_le64(reg->val);\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_HOST:\r\n{\r\nvalue = (u32) buf & 0xffffffff;\r\nswitch (reg->match.addr) {\r\ncase 0:\r\ndata[0] = (u8) value;\r\ndata[1] = (u8) (value >> 8);\r\ndata[2] = (u8) (value >> 16);\r\ndata[3] = (u8) (value >> 24);\r\nret = cx231xx_write_ctrl_reg(dev,\r\nVRT_SET_REGISTER,\r\n(u16)reg->reg, data,\r\n4);\r\nbreak;\r\ncase 1:\r\nret = cx231xx_write_i2c_data(dev,\r\nAFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 1);\r\nbreak;\r\ncase 14:\r\nret = cx231xx_write_i2c_data(dev,\r\nAFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 4);\r\nbreak;\r\ncase 2:\r\nret =\r\ncx231xx_write_i2c_data(dev,\r\nVID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 1);\r\nbreak;\r\ncase 24:\r\nret =\r\ncx231xx_write_i2c_data(dev,\r\nVID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 4);\r\nbreak;\r\ncase 3:\r\nret =\r\ncx231xx_write_i2c_data(dev,\r\nI2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1,\r\nvalue, 1);\r\nbreak;\r\ncase 34:\r\nret =\r\ncx231xx_write_i2c_data(dev,\r\nI2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1,\r\nvalue, 4);\r\nbreak;\r\n}\r\n}\r\nreturn ret < 0 ? ret : 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\n{\r\nvalue = (u32) buf & 0xffffffff;\r\nswitch (reg->match.addr) {\r\ncase 0:\r\ndata[0] = (u8) value;\r\ndata[1] = (u8) (value >> 8);\r\ndata[2] = (u8) (value >> 16);\r\ndata[3] = (u8) (value >> 24);\r\nret = cx231xx_write_ctrl_reg(dev,\r\nVRT_SET_REGISTER,\r\n(u16)reg->reg, data,\r\n4);\r\nbreak;\r\ncase 0x600:\r\nret = cx231xx_write_i2c_master(dev,\r\nAFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 1 , 0);\r\nbreak;\r\ncase 0x880:\r\nif (reg->reg < 0x0b)\r\ncx231xx_write_i2c_master(dev,\r\nVID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 1, 0);\r\nelse\r\ncx231xx_write_i2c_master(dev,\r\nVID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2,\r\nvalue, 4, 0);\r\nbreak;\r\ncase 0x980:\r\nret =\r\ncx231xx_write_i2c_master(dev,\r\nI2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1,\r\nvalue, 1, 0);\r\nbreak;\r\ncase 0x400:\r\nret =\r\ncx231xx_write_i2c_master(dev,\r\n0x40,\r\n(u16)reg->reg, 1,\r\nvalue, 1, 0);\r\nbreak;\r\ncase 0xc01:\r\nret =\r\ncx231xx_write_i2c_master(dev,\r\n0xc0,\r\n(u16)reg->reg, 1,\r\nvalue, 1, 1);\r\nbreak;\r\ncase 0x022:\r\nret =\r\ncx231xx_write_i2c_master(dev,\r\n0x02,\r\n(u16)reg->reg, 1,\r\nvalue, 1, 2);\r\ncase 0x322:\r\nret =\r\ncx231xx_write_i2c_master(dev,\r\n0x32,\r\n(u16)reg->reg, 1,\r\nvalue, 4, 2);\r\nbreak;\r\ncase 0x342:\r\nret =\r\ncx231xx_write_i2c_master(dev,\r\n0x34,\r\n(u16)reg->reg, 1,\r\nvalue, 4, 2);\r\nbreak;\r\ndefault:\r\ncx231xx_info("no match device address, "\r\n"the value is %x\n", reg->match.addr);\r\nbreak;\r\n}\r\n}\r\ndefault:\r\nbreak;\r\n}\r\ncall_all(dev, core, s_register, reg);\r\nreturn ret;\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cc)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nif (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncc->bounds.left = 0;\r\ncc->bounds.top = 0;\r\ncc->bounds.width = dev->width;\r\ncc->bounds.height = dev->height;\r\ncc->defrect = cc->bounds;\r\ncc->pixelaspect.numerator = 54;\r\ncc->pixelaspect.denominator = 59;\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = res_get(fh);\r\nif (likely(rc >= 0))\r\nrc = videobuf_streamon(&fh->vb_vidq);\r\ncall_all(dev, video, s_stream, 1);\r\nreturn rc;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(fh->type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nif (type != fh->type)\r\nreturn -EINVAL;\r\ncx25840_call(dev, video, s_stream, 0);\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(fh);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nstrlcpy(cap->driver, "cx231xx", sizeof(cap->driver));\r\nstrlcpy(cap->card, cx231xx_boards[dev->model].name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VBI_CAPTURE |\r\n#if 0\r\nV4L2_CAP_SLICED_VBI_CAPTURE |\r\n#endif\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(format)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, format[f->index].name, sizeof(f->description));\r\nf->pixelformat = format[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_sliced_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nf->fmt.sliced.service_set = 0;\r\ncall_all(dev, vbi, g_sliced_fmt, &f->fmt.sliced);\r\nif (f->fmt.sliced.service_set == 0)\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nstatic int vidioc_try_set_sliced_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\ncall_all(dev, vbi, g_sliced_fmt, &f->fmt.sliced);\r\nif (f->fmt.sliced.service_set == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nf->fmt.vbi.sampling_rate = 6750000 * 4;\r\nf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 0;\r\nf->fmt.vbi.start[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE : NTSC_VBI_START_LINE;\r\nf->fmt.vbi.count[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_LINES : NTSC_VBI_LINES;\r\nf->fmt.vbi.start[1] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE + 312 : NTSC_VBI_START_LINE + 263;\r\nf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nif (dev->vbi_stream_on && !fh->stream_on) {\r\ncx231xx_errdev("%s device in use by another fh\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nf->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nf->fmt.vbi.sampling_rate = 6750000 * 4;\r\nf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 0;\r\nf->fmt.vbi.flags = 0;\r\nf->fmt.vbi.start[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE : NTSC_VBI_START_LINE;\r\nf->fmt.vbi.count[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_LINES : NTSC_VBI_LINES;\r\nf->fmt.vbi.start[1] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE + 312 : NTSC_VBI_START_LINE + 263;\r\nf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_reqbufs(&fh->vb_vidq, rb);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_querybuf(&fh->vb_vidq, b);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_qbuf(&fh->vb_vidq, b);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_dqbuf(&fh->vb_vidq, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int radio_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx231xx *dev = ((struct cx231xx_fh *)priv)->dev;\r\nstrlcpy(cap->driver, "cx231xx", sizeof(cap->driver));\r\nstrlcpy(cap->card, cx231xx_boards[dev->model].name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx *dev = ((struct cx231xx_fh *)priv)->dev;\r\nif (unlikely(t->index > 0))\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nt->type = V4L2_TUNER_RADIO;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_enum_input(struct file *file, void *priv, struct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, "Radio");\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nif (unlikely(a->index))\r\nreturn -EINVAL;\r\nstrcpy(a->name, "Radio");\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx *dev = ((struct cx231xx_fh *)priv)->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_audio(struct file *file, void *fh, const struct v4l2_audio *a)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_s_input(struct file *file, void *fh, unsigned int i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nint i;\r\nif (c->id < V4L2_CID_BASE || c->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nif (c->id == V4L2_CID_AUDIO_MUTE) {\r\nfor (i = 0; i < CX231XX_CTLS; i++) {\r\nif (cx231xx_ctls[i].v.id == c->id)\r\nbreak;\r\n}\r\nif (i == CX231XX_CTLS)\r\nreturn -EINVAL;\r\n*c = cx231xx_ctls[i].v;\r\n} else\r\n*c = no_ctl;\r\nreturn 0;\r\n}\r\nstatic int cx231xx_v4l2_open(struct file *filp)\r\n{\r\nint errCode = 0, radio = 0;\r\nstruct video_device *vdev = video_devdata(filp);\r\nstruct cx231xx *dev = video_drvdata(filp);\r\nstruct cx231xx_fh *fh;\r\nenum v4l2_buf_type fh_type = 0;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nfh_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nfh_type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nradio = 1;\r\nbreak;\r\n}\r\ncx231xx_videodbg("open dev=%s type=%s users=%d\n",\r\nvideo_device_node_name(vdev), v4l2_type_names[fh_type],\r\ndev->users);\r\n#if 0\r\nerrCode = cx231xx_set_mode(dev, CX231XX_ANALOG_MODE);\r\nif (errCode < 0) {\r\ncx231xx_errdev\r\n("Device locked on digital mode. Can't open analog\n");\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nfh = kzalloc(sizeof(struct cx231xx_fh), GFP_KERNEL);\r\nif (!fh) {\r\ncx231xx_errdev("cx231xx-video.c: Out of memory?!\n");\r\nreturn -ENOMEM;\r\n}\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\nkfree(fh);\r\nreturn -ERESTARTSYS;\r\n}\r\nfh->dev = dev;\r\nfh->radio = radio;\r\nfh->type = fh_type;\r\nfilp->private_data = fh;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && dev->users == 0) {\r\ndev->width = norm_maxw(dev);\r\ndev->height = norm_maxh(dev);\r\nif (dev->board.external_av)\r\ncx231xx_set_power_mode(dev,\r\nPOLARIS_AVMODE_ENXTERNAL_AV);\r\nelse\r\ncx231xx_set_power_mode(dev, POLARIS_AVMODE_ANALOGT_TV);\r\n#if 0\r\ncx231xx_set_mode(dev, CX231XX_ANALOG_MODE);\r\n#endif\r\ncx231xx_set_video_alternate(dev);\r\ncx231xx_config_i2c(dev);\r\ndev->video_input = dev->video_input > 2 ? 2 : dev->video_input;\r\n}\r\nif (fh->radio) {\r\ncx231xx_videodbg("video_open: setting radio device\n");\r\ncall_all(dev, tuner, s_radio);\r\n}\r\ndev->users++;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &cx231xx_video_qops,\r\nNULL, &dev->video_mode.slock,\r\nfh->type, V4L2_FIELD_INTERLACED,\r\nsizeof(struct cx231xx_buffer),\r\nfh, &dev->lock);\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 0);\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &cx231xx_vbi_qops,\r\nNULL, &dev->vbi_mode.slock,\r\nfh->type, V4L2_FIELD_SEQ_TB,\r\nsizeof(struct cx231xx_buffer),\r\nfh, &dev->lock);\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn errCode;\r\n}\r\nvoid cx231xx_release_analog_resources(struct cx231xx *dev)\r\n{\r\nif (dev->radio_dev) {\r\nif (video_is_registered(dev->radio_dev))\r\nvideo_unregister_device(dev->radio_dev);\r\nelse\r\nvideo_device_release(dev->radio_dev);\r\ndev->radio_dev = NULL;\r\n}\r\nif (dev->vbi_dev) {\r\ncx231xx_info("V4L2 device %s deregistered\n",\r\nvideo_device_node_name(dev->vbi_dev));\r\nif (video_is_registered(dev->vbi_dev))\r\nvideo_unregister_device(dev->vbi_dev);\r\nelse\r\nvideo_device_release(dev->vbi_dev);\r\ndev->vbi_dev = NULL;\r\n}\r\nif (dev->vdev) {\r\ncx231xx_info("V4L2 device %s deregistered\n",\r\nvideo_device_node_name(dev->vdev));\r\nif (dev->board.has_417)\r\ncx231xx_417_unregister(dev);\r\nif (video_is_registered(dev->vdev))\r\nvideo_unregister_device(dev->vdev);\r\nelse\r\nvideo_device_release(dev->vdev);\r\ndev->vdev = NULL;\r\n}\r\n}\r\nstatic int cx231xx_close(struct file *filp)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ncx231xx_videodbg("users=%d\n", dev->users);\r\ncx231xx_videodbg("users=%d\n", dev->users);\r\nif (res_check(fh))\r\nres_free(fh);\r\nif (!dev->board.no_alt_vanc)\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nvideobuf_stop(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nif (dev->state & DEV_DISCONNECTED) {\r\nif (atomic_read(&dev->devlist_count) > 0) {\r\ncx231xx_release_resources(dev);\r\nfh->dev = NULL;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\ncx231xx_uninit_vbi_isoc(dev);\r\nif (!dev->vbi_or_sliced_cc_mode)\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 0);\r\nelse\r\ncx231xx_set_alt_setting(dev, INDEX_HANC, 0);\r\nkfree(fh);\r\ndev->users--;\r\nwake_up_interruptible_nr(&dev->open, 1);\r\nreturn 0;\r\n}\r\ndev->users--;\r\nif (!dev->users) {\r\nvideobuf_stop(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nif (dev->state & DEV_DISCONNECTED) {\r\ncx231xx_release_resources(dev);\r\nfh->dev = NULL;\r\nreturn 0;\r\n}\r\ncall_all(dev, core, s_power, 0);\r\nif (dev->USE_ISO)\r\ncx231xx_uninit_isoc(dev);\r\nelse\r\ncx231xx_uninit_bulk(dev);\r\ncx231xx_set_mode(dev, CX231XX_SUSPEND);\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 0);\r\n}\r\nkfree(fh);\r\nwake_up_interruptible_nr(&dev->open, 1);\r\nreturn 0;\r\n}\r\nstatic int cx231xx_v4l2_close(struct file *filp)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nmutex_lock(&dev->lock);\r\nrc = cx231xx_close(filp);\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ncx231xx_v4l2_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ||\r\n(fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)) {\r\nrc = res_get(fh);\r\nif (unlikely(rc < 0))\r\nreturn rc;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nrc = videobuf_read_stream(&fh->vb_vidq, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int cx231xx_v4l2_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = res_get(fh);\r\nif (unlikely(rc < 0))\r\nreturn POLLERR;\r\nif ((V4L2_BUF_TYPE_VIDEO_CAPTURE == fh->type) ||\r\n(V4L2_BUF_TYPE_VBI_CAPTURE == fh->type)) {\r\nunsigned int res;\r\nmutex_lock(&dev->lock);\r\nres = videobuf_poll_stream(filp, &fh->vb_vidq, wait);\r\nmutex_unlock(&dev->lock);\r\nreturn res;\r\n}\r\nreturn POLLERR;\r\n}\r\nstatic int cx231xx_v4l2_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = res_get(fh);\r\nif (unlikely(rc < 0))\r\nreturn rc;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nrc = videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\nmutex_unlock(&dev->lock);\r\ncx231xx_videodbg("vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end -\r\n(unsigned long)vma->vm_start, rc);\r\nreturn rc;\r\n}\r\nstatic struct video_device *cx231xx_vdev_init(struct cx231xx *dev,\r\nconst struct video_device\r\n*template, const char *type_name)\r\n{\r\nstruct video_device *vfd;\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nvfd->debug = video_debug;\r\nvfd->lock = &dev->lock;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s", dev->name, type_name);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nint cx231xx_register_analog_devices(struct cx231xx *dev)\r\n{\r\nint ret;\r\ncx231xx_info("%s: v4l2 driver version %s\n",\r\ndev->name, CX231XX_VERSION);\r\ndev->width = norm_maxw(dev);\r\ndev->height = norm_maxh(dev);\r\ndev->interlaced = 0;\r\ndev->format = &format[0];\r\nvideo_mux(dev, dev->video_input);\r\ndev->mute = 1;\r\ndev->volume = 0x1f;\r\ndev->vdev = cx231xx_vdev_init(dev, &cx231xx_video_template, "video");\r\nif (!dev->vdev) {\r\ncx231xx_errdev("cannot allocate video_device.\n");\r\nreturn -ENODEV;\r\n}\r\nret = video_register_device(dev->vdev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->devno]);\r\nif (ret) {\r\ncx231xx_errdev("unable to register video device (error=%i).\n",\r\nret);\r\nreturn ret;\r\n}\r\ncx231xx_info("%s/0: registered device %s [v4l2]\n",\r\ndev->name, video_device_node_name(dev->vdev));\r\nmemcpy(&cx231xx_vbi_template, &cx231xx_video_template,\r\nsizeof(cx231xx_vbi_template));\r\nstrcpy(cx231xx_vbi_template.name, "cx231xx-vbi");\r\ndev->vbi_dev = cx231xx_vdev_init(dev, &cx231xx_vbi_template, "vbi");\r\nret = video_register_device(dev->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[dev->devno]);\r\nif (ret < 0) {\r\ncx231xx_errdev("unable to register vbi device\n");\r\nreturn ret;\r\n}\r\ncx231xx_info("%s/0: registered device %s\n",\r\ndev->name, video_device_node_name(dev->vbi_dev));\r\nif (cx231xx_boards[dev->model].radio.type == CX231XX_RADIO) {\r\ndev->radio_dev = cx231xx_vdev_init(dev, &cx231xx_radio_template,\r\n"radio");\r\nif (!dev->radio_dev) {\r\ncx231xx_errdev("cannot allocate video_device.\n");\r\nreturn -ENODEV;\r\n}\r\nret = video_register_device(dev->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr[dev->devno]);\r\nif (ret < 0) {\r\ncx231xx_errdev("can't register radio device\n");\r\nreturn ret;\r\n}\r\ncx231xx_info("Registered radio device as %s\n",\r\nvideo_device_node_name(dev->radio_dev));\r\n}\r\ncx231xx_info("V4L2 device registered as %s and %s\n",\r\nvideo_device_node_name(dev->vdev),\r\nvideo_device_node_name(dev->vbi_dev));\r\nreturn 0;\r\n}
