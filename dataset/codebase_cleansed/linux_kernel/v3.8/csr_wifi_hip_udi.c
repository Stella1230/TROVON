s32 unifi_print_status(card_t *card, char *str, s32 *remain)\r\n{\r\nchar *p = str;\r\nsdio_config_data_t *cfg;\r\nu16 i, n;\r\ns32 remaining = *remain;\r\ns32 written;\r\n#ifdef CSR_UNSAFE_SDIO_ACCESS\r\ns32 iostate;\r\nCsrResult r;\r\nstatic const char *const states[] = {\r\n"AWAKE", "DROWSY", "TORPID"\r\n};\r\n#define SHARED_READ_RETRY_LIMIT 10\r\nu8 b;\r\n#endif\r\nif (remaining <= 0)\r\n{\r\nreturn 0;\r\n}\r\ni = n = 0;\r\nwritten = scnprintf(p, remaining, "Chip ID %u\n",\r\n(u16)card->chip_id);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "Chip Version %04X\n",\r\ncard->chip_version);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "HIP v%u.%u\n",\r\n(card->config_data.version >> 8) & 0xFF,\r\ncard->config_data.version & 0xFF);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "Build %u: %s\n",\r\ncard->build_id, card->build_id_string);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\ncfg = &card->config_data;\r\nwritten = scnprintf(p, remaining, "sdio ctrl offset %u\n",\r\ncfg->sdio_ctrl_offset);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "fromhost sigbuf handle %u\n",\r\ncfg->fromhost_sigbuf_handle);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "tohost_sigbuf_handle %u\n",\r\ncfg->tohost_sigbuf_handle);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "num_fromhost_sig_frags %u\n",\r\ncfg->num_fromhost_sig_frags);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "num_tohost_sig_frags %u\n",\r\ncfg->num_tohost_sig_frags);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "num_fromhost_data_slots %u\n",\r\ncfg->num_fromhost_data_slots);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "num_tohost_data_slots %u\n",\r\ncfg->num_tohost_data_slots);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "data_slot_size %u\n",\r\ncfg->data_slot_size);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "overlay_size %u\n",\r\n(u16)cfg->overlay_size);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "data_slot_round %u\n",\r\ncfg->data_slot_round);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "sig_frag_size %u\n",\r\ncfg->sig_frag_size);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "tohost_sig_pad %u\n",\r\ncfg->tohost_signal_padding);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "\nInternal state:\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "Last PHY PANIC: %04x:%04x\n",\r\ncard->last_phy_panic_code, card->last_phy_panic_arg);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "Last MAC PANIC: %04x:%04x\n",\r\ncard->last_mac_panic_code, card->last_mac_panic_arg);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "fhsr: %u\n",\r\n(u16)card->from_host_signals_r);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "fhsw: %u\n",\r\n(u16)card->from_host_signals_w);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "thsr: %u\n",\r\n(u16)card->to_host_signals_r);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "thsw: %u\n",\r\n(u16)card->to_host_signals_w);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining,\r\n"fh buffer contains: %d signals, %td bytes\n",\r\ncard->fh_buffer.count,\r\ncard->fh_buffer.ptr - card->fh_buffer.buf);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "paused: ");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nfor (i = 0; i < sizeof(card->tx_q_paused_flag) / sizeof(card->tx_q_paused_flag[0]); i++)\r\n{\r\nwritten = scnprintf(p, remaining, card->tx_q_paused_flag[i]?"1" : "0");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\nwritten = scnprintf(p, remaining, "\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining,\r\n"fh command q: %u waiting, %u free of %u:\n",\r\nCSR_WIFI_HIP_Q_SLOTS_USED(&card->fh_command_queue),\r\nCSR_WIFI_HIP_Q_SLOTS_FREE(&card->fh_command_queue),\r\nUNIFI_SOFT_COMMAND_Q_LENGTH);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\nwritten = scnprintf(p, remaining,\r\n"fh traffic q[%u]: %u waiting, %u free of %u:\n",\r\ni,\r\nCSR_WIFI_HIP_Q_SLOTS_USED(&card->fh_traffic_queue[i]),\r\nCSR_WIFI_HIP_Q_SLOTS_FREE(&card->fh_traffic_queue[i]),\r\nUNIFI_SOFT_TRAFFIC_Q_LENGTH);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\nwritten = scnprintf(p, remaining, "fh data slots free: %u\n",\r\ncard->from_host_data?CardGetFreeFromHostDataSlots(card) : 0);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "From host data slots:");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nn = card->config_data.num_fromhost_data_slots;\r\nfor (i = 0; i < n && card->from_host_data; i++)\r\n{\r\nwritten = scnprintf(p, remaining, " %u",\r\n(u16)card->from_host_data[i].bd.data_length);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\nwritten = scnprintf(p, remaining, "\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "To host data slots:");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nn = card->config_data.num_tohost_data_slots;\r\nfor (i = 0; i < n && card->to_host_data; i++)\r\n{\r\nwritten = scnprintf(p, remaining, " %u",\r\n(u16)card->to_host_data[i].data_length);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\nwritten = scnprintf(p, remaining, "\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n#ifdef CSR_UNSAFE_SDIO_ACCESS\r\nwritten = scnprintf(p, remaining, "Host State: %s\n", states[card->host_state]);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nr = unifi_check_io_status(card, &iostate);\r\nif (iostate == 1)\r\n{\r\nwritten = scnprintf(p, remaining, "I/O Check: F1 disabled\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\nelse\r\n{\r\nif (iostate == 1)\r\n{\r\nwritten = scnprintf(p, remaining, "I/O Check: pending interrupt\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\nwritten = scnprintf(p, remaining, "BH reason interrupt = %d\n",\r\ncard->bh_reason_unifi);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "BH reason host = %d\n",\r\ncard->bh_reason_host);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nfor (i = 0; i < SHARED_READ_RETRY_LIMIT; i++)\r\n{\r\nr = unifi_read_8_or_16(card, card->sdio_ctrl_addr + 2, &b);\r\nif ((r == CSR_RESULT_SUCCESS) && (!(b & 0x80)))\r\n{\r\nwritten = scnprintf(p, remaining, "fhsr: %u (driver thinks is %u)\n",\r\nb, card->from_host_signals_r);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nbreak;\r\n}\r\n}\r\niostate = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);\r\nwritten = scnprintf(p, remaining, "thsw: %u (driver thinks is %u)\n",\r\niostate, card->to_host_signals_w);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n}\r\n#endif\r\nwritten = scnprintf(p, remaining, "\nStats:\n");\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "Total SDIO bytes: R=%u W=%u\n",\r\ncard->sdio_bytes_read, card->sdio_bytes_written);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\nwritten = scnprintf(p, remaining, "Interrupts generated on card: %u\n",\r\ncard->unifi_interrupt_seq);\r\nUNIFI_SNPRINTF_RET(p, remaining, written);\r\n*remain = remaining;\r\nreturn (p - str);\r\n}
