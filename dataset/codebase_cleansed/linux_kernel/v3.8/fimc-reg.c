void fimc_hw_reset(struct fimc_dev *dev)\r\n{\r\nu32 cfg;\r\ncfg = readl(dev->regs + FIMC_REG_CISRCFMT);\r\ncfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\r\nwritel(cfg, dev->regs + FIMC_REG_CISRCFMT);\r\ncfg = readl(dev->regs + FIMC_REG_CIGCTRL);\r\ncfg |= (FIMC_REG_CIGCTRL_SWRST | FIMC_REG_CIGCTRL_IRQ_LEVEL);\r\nwritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\r\nudelay(10);\r\ncfg = readl(dev->regs + FIMC_REG_CIGCTRL);\r\ncfg &= ~FIMC_REG_CIGCTRL_SWRST;\r\nwritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\r\nif (dev->variant->out_buf_count > 4)\r\nfimc_hw_set_dma_seq(dev, 0xF);\r\n}\r\nstatic u32 fimc_hw_get_in_flip(struct fimc_ctx *ctx)\r\n{\r\nu32 flip = FIMC_REG_MSCTRL_FLIP_NORMAL;\r\nif (ctx->hflip)\r\nflip = FIMC_REG_MSCTRL_FLIP_X_MIRROR;\r\nif (ctx->vflip)\r\nflip = FIMC_REG_MSCTRL_FLIP_Y_MIRROR;\r\nif (ctx->rotation <= 90)\r\nreturn flip;\r\nreturn (flip ^ FIMC_REG_MSCTRL_FLIP_180) & FIMC_REG_MSCTRL_FLIP_180;\r\n}\r\nstatic u32 fimc_hw_get_target_flip(struct fimc_ctx *ctx)\r\n{\r\nu32 flip = FIMC_REG_CITRGFMT_FLIP_NORMAL;\r\nif (ctx->hflip)\r\nflip |= FIMC_REG_CITRGFMT_FLIP_X_MIRROR;\r\nif (ctx->vflip)\r\nflip |= FIMC_REG_CITRGFMT_FLIP_Y_MIRROR;\r\nif (ctx->rotation <= 90)\r\nreturn flip;\r\nreturn (flip ^ FIMC_REG_CITRGFMT_FLIP_180) & FIMC_REG_CITRGFMT_FLIP_180;\r\n}\r\nvoid fimc_hw_set_rotation(struct fimc_ctx *ctx)\r\n{\r\nu32 cfg, flip;\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\ncfg = readl(dev->regs + FIMC_REG_CITRGFMT);\r\ncfg &= ~(FIMC_REG_CITRGFMT_INROT90 | FIMC_REG_CITRGFMT_OUTROT90 |\r\nFIMC_REG_CITRGFMT_FLIP_180);\r\nif (ctx->rotation == 90 || ctx->rotation == 270) {\r\nif (ctx->out_path == FIMC_IO_LCDFIFO)\r\ncfg |= FIMC_REG_CITRGFMT_INROT90;\r\nelse\r\ncfg |= FIMC_REG_CITRGFMT_OUTROT90;\r\n}\r\nif (ctx->out_path == FIMC_IO_DMA) {\r\ncfg |= fimc_hw_get_target_flip(ctx);\r\nwritel(cfg, dev->regs + FIMC_REG_CITRGFMT);\r\n} else {\r\nflip = readl(dev->regs + FIMC_REG_MSCTRL);\r\nflip &= ~FIMC_REG_MSCTRL_FLIP_MASK;\r\nflip |= fimc_hw_get_in_flip(ctx);\r\nwritel(flip, dev->regs + FIMC_REG_MSCTRL);\r\n}\r\n}\r\nvoid fimc_hw_set_target_format(struct fimc_ctx *ctx)\r\n{\r\nu32 cfg;\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_frame *frame = &ctx->d_frame;\r\ndbg("w= %d, h= %d color: %d", frame->width,\r\nframe->height, frame->fmt->color);\r\ncfg = readl(dev->regs + FIMC_REG_CITRGFMT);\r\ncfg &= ~(FIMC_REG_CITRGFMT_FMT_MASK | FIMC_REG_CITRGFMT_HSIZE_MASK |\r\nFIMC_REG_CITRGFMT_VSIZE_MASK);\r\nswitch (frame->fmt->color) {\r\ncase FIMC_FMT_RGB444...FIMC_FMT_RGB888:\r\ncfg |= FIMC_REG_CITRGFMT_RGB;\r\nbreak;\r\ncase FIMC_FMT_YCBCR420:\r\ncfg |= FIMC_REG_CITRGFMT_YCBCR420;\r\nbreak;\r\ncase FIMC_FMT_YCBYCR422...FIMC_FMT_CRYCBY422:\r\nif (frame->fmt->colplanes == 1)\r\ncfg |= FIMC_REG_CITRGFMT_YCBCR422_1P;\r\nelse\r\ncfg |= FIMC_REG_CITRGFMT_YCBCR422;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ctx->rotation == 90 || ctx->rotation == 270)\r\ncfg |= (frame->height << 16) | frame->width;\r\nelse\r\ncfg |= (frame->width << 16) | frame->height;\r\nwritel(cfg, dev->regs + FIMC_REG_CITRGFMT);\r\ncfg = readl(dev->regs + FIMC_REG_CITAREA);\r\ncfg &= ~FIMC_REG_CITAREA_MASK;\r\ncfg |= (frame->width * frame->height);\r\nwritel(cfg, dev->regs + FIMC_REG_CITAREA);\r\n}\r\nstatic void fimc_hw_set_out_dma_size(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_frame *frame = &ctx->d_frame;\r\nu32 cfg;\r\ncfg = (frame->f_height << 16) | frame->f_width;\r\nwritel(cfg, dev->regs + FIMC_REG_ORGOSIZE);\r\ncfg = readl(dev->regs + FIMC_REG_CIGCTRL);\r\nif (frame->f_width >= 1280)\r\ncfg |= FIMC_REG_CIGCTRL_CSC_ITU601_709;\r\nelse\r\ncfg &= ~FIMC_REG_CIGCTRL_CSC_ITU601_709;\r\nwritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\r\n}\r\nvoid fimc_hw_set_out_dma(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_frame *frame = &ctx->d_frame;\r\nstruct fimc_dma_offset *offset = &frame->dma_offset;\r\nstruct fimc_fmt *fmt = frame->fmt;\r\nu32 cfg;\r\ncfg = (offset->y_v << 16) | offset->y_h;\r\nwritel(cfg, dev->regs + FIMC_REG_CIOYOFF);\r\ncfg = (offset->cb_v << 16) | offset->cb_h;\r\nwritel(cfg, dev->regs + FIMC_REG_CIOCBOFF);\r\ncfg = (offset->cr_v << 16) | offset->cr_h;\r\nwritel(cfg, dev->regs + FIMC_REG_CIOCROFF);\r\nfimc_hw_set_out_dma_size(ctx);\r\ncfg = readl(dev->regs + FIMC_REG_CIOCTRL);\r\ncfg &= ~(FIMC_REG_CIOCTRL_ORDER2P_MASK |\r\nFIMC_REG_CIOCTRL_ORDER422_MASK |\r\nFIMC_REG_CIOCTRL_YCBCR_PLANE_MASK |\r\nFIMC_REG_CIOCTRL_RGB16FMT_MASK);\r\nif (fmt->colplanes == 1)\r\ncfg |= ctx->out_order_1p;\r\nelse if (fmt->colplanes == 2)\r\ncfg |= ctx->out_order_2p | FIMC_REG_CIOCTRL_YCBCR_2PLANE;\r\nelse if (fmt->colplanes == 3)\r\ncfg |= FIMC_REG_CIOCTRL_YCBCR_3PLANE;\r\nif (fmt->color == FIMC_FMT_RGB565)\r\ncfg |= FIMC_REG_CIOCTRL_RGB565;\r\nelse if (fmt->color == FIMC_FMT_RGB555)\r\ncfg |= FIMC_REG_CIOCTRL_ARGB1555;\r\nelse if (fmt->color == FIMC_FMT_RGB444)\r\ncfg |= FIMC_REG_CIOCTRL_ARGB4444;\r\nwritel(cfg, dev->regs + FIMC_REG_CIOCTRL);\r\n}\r\nstatic void fimc_hw_en_autoload(struct fimc_dev *dev, int enable)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_ORGISIZE);\r\nif (enable)\r\ncfg |= FIMC_REG_CIREAL_ISIZE_AUTOLOAD_EN;\r\nelse\r\ncfg &= ~FIMC_REG_CIREAL_ISIZE_AUTOLOAD_EN;\r\nwritel(cfg, dev->regs + FIMC_REG_ORGISIZE);\r\n}\r\nvoid fimc_hw_en_lastirq(struct fimc_dev *dev, int enable)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_CIOCTRL);\r\nif (enable)\r\ncfg |= FIMC_REG_CIOCTRL_LASTIRQ_ENABLE;\r\nelse\r\ncfg &= ~FIMC_REG_CIOCTRL_LASTIRQ_ENABLE;\r\nwritel(cfg, dev->regs + FIMC_REG_CIOCTRL);\r\n}\r\nvoid fimc_hw_set_prescaler(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_scaler *sc = &ctx->scaler;\r\nu32 cfg, shfactor;\r\nshfactor = 10 - (sc->hfactor + sc->vfactor);\r\ncfg = shfactor << 28;\r\ncfg |= (sc->pre_hratio << 16) | sc->pre_vratio;\r\nwritel(cfg, dev->regs + FIMC_REG_CISCPRERATIO);\r\ncfg = (sc->pre_dst_width << 16) | sc->pre_dst_height;\r\nwritel(cfg, dev->regs + FIMC_REG_CISCPREDST);\r\n}\r\nstatic void fimc_hw_set_scaler(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_scaler *sc = &ctx->scaler;\r\nstruct fimc_frame *src_frame = &ctx->s_frame;\r\nstruct fimc_frame *dst_frame = &ctx->d_frame;\r\nu32 cfg = readl(dev->regs + FIMC_REG_CISCCTRL);\r\ncfg &= ~(FIMC_REG_CISCCTRL_CSCR2Y_WIDE | FIMC_REG_CISCCTRL_CSCY2R_WIDE |\r\nFIMC_REG_CISCCTRL_SCALEUP_H | FIMC_REG_CISCCTRL_SCALEUP_V |\r\nFIMC_REG_CISCCTRL_SCALERBYPASS | FIMC_REG_CISCCTRL_ONE2ONE |\r\nFIMC_REG_CISCCTRL_INRGB_FMT_MASK | FIMC_REG_CISCCTRL_OUTRGB_FMT_MASK |\r\nFIMC_REG_CISCCTRL_INTERLACE | FIMC_REG_CISCCTRL_RGB_EXT);\r\nif (!(ctx->flags & FIMC_COLOR_RANGE_NARROW))\r\ncfg |= (FIMC_REG_CISCCTRL_CSCR2Y_WIDE |\r\nFIMC_REG_CISCCTRL_CSCY2R_WIDE);\r\nif (!sc->enabled)\r\ncfg |= FIMC_REG_CISCCTRL_SCALERBYPASS;\r\nif (sc->scaleup_h)\r\ncfg |= FIMC_REG_CISCCTRL_SCALEUP_H;\r\nif (sc->scaleup_v)\r\ncfg |= FIMC_REG_CISCCTRL_SCALEUP_V;\r\nif (sc->copy_mode)\r\ncfg |= FIMC_REG_CISCCTRL_ONE2ONE;\r\nif (ctx->in_path == FIMC_IO_DMA) {\r\nswitch (src_frame->fmt->color) {\r\ncase FIMC_FMT_RGB565:\r\ncfg |= FIMC_REG_CISCCTRL_INRGB_FMT_RGB565;\r\nbreak;\r\ncase FIMC_FMT_RGB666:\r\ncfg |= FIMC_REG_CISCCTRL_INRGB_FMT_RGB666;\r\nbreak;\r\ncase FIMC_FMT_RGB888:\r\ncfg |= FIMC_REG_CISCCTRL_INRGB_FMT_RGB888;\r\nbreak;\r\n}\r\n}\r\nif (ctx->out_path == FIMC_IO_DMA) {\r\nu32 color = dst_frame->fmt->color;\r\nif (color >= FIMC_FMT_RGB444 && color <= FIMC_FMT_RGB565)\r\ncfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB565;\r\nelse if (color == FIMC_FMT_RGB666)\r\ncfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB666;\r\nelse if (color == FIMC_FMT_RGB888)\r\ncfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB888;\r\n} else {\r\ncfg |= FIMC_REG_CISCCTRL_OUTRGB_FMT_RGB888;\r\nif (ctx->flags & FIMC_SCAN_MODE_INTERLACED)\r\ncfg |= FIMC_REG_CISCCTRL_INTERLACE;\r\n}\r\nwritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\r\n}\r\nvoid fimc_hw_set_mainscaler(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_variant *variant = dev->variant;\r\nstruct fimc_scaler *sc = &ctx->scaler;\r\nu32 cfg;\r\ndbg("main_hratio= 0x%X main_vratio= 0x%X",\r\nsc->main_hratio, sc->main_vratio);\r\nfimc_hw_set_scaler(ctx);\r\ncfg = readl(dev->regs + FIMC_REG_CISCCTRL);\r\ncfg &= ~(FIMC_REG_CISCCTRL_MHRATIO_MASK |\r\nFIMC_REG_CISCCTRL_MVRATIO_MASK);\r\nif (variant->has_mainscaler_ext) {\r\ncfg |= FIMC_REG_CISCCTRL_MHRATIO_EXT(sc->main_hratio);\r\ncfg |= FIMC_REG_CISCCTRL_MVRATIO_EXT(sc->main_vratio);\r\nwritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\r\ncfg = readl(dev->regs + FIMC_REG_CIEXTEN);\r\ncfg &= ~(FIMC_REG_CIEXTEN_MVRATIO_EXT_MASK |\r\nFIMC_REG_CIEXTEN_MHRATIO_EXT_MASK);\r\ncfg |= FIMC_REG_CIEXTEN_MHRATIO_EXT(sc->main_hratio);\r\ncfg |= FIMC_REG_CIEXTEN_MVRATIO_EXT(sc->main_vratio);\r\nwritel(cfg, dev->regs + FIMC_REG_CIEXTEN);\r\n} else {\r\ncfg |= FIMC_REG_CISCCTRL_MHRATIO(sc->main_hratio);\r\ncfg |= FIMC_REG_CISCCTRL_MVRATIO(sc->main_vratio);\r\nwritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\r\n}\r\n}\r\nvoid fimc_hw_en_capture(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nu32 cfg = readl(dev->regs + FIMC_REG_CIIMGCPT);\r\nif (ctx->out_path == FIMC_IO_DMA) {\r\ncfg |= FIMC_REG_CIIMGCPT_CPT_FREN_ENABLE |\r\nFIMC_REG_CIIMGCPT_IMGCPTEN;\r\n} else {\r\ncfg &= ~(FIMC_REG_CIIMGCPT_CPT_FREN_ENABLE |\r\nFIMC_REG_CIIMGCPT_CPT_FRMOD_CNT);\r\ncfg |= FIMC_REG_CIIMGCPT_IMGCPTEN;\r\n}\r\nif (ctx->scaler.enabled)\r\ncfg |= FIMC_REG_CIIMGCPT_IMGCPTEN_SC;\r\ncfg |= FIMC_REG_CIIMGCPT_IMGCPTEN;\r\nwritel(cfg, dev->regs + FIMC_REG_CIIMGCPT);\r\n}\r\nvoid fimc_hw_set_effect(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_effect *effect = &ctx->effect;\r\nu32 cfg = 0;\r\nif (effect->type != FIMC_REG_CIIMGEFF_FIN_BYPASS) {\r\ncfg |= FIMC_REG_CIIMGEFF_IE_SC_AFTER |\r\nFIMC_REG_CIIMGEFF_IE_ENABLE;\r\ncfg |= effect->type;\r\nif (effect->type == FIMC_REG_CIIMGEFF_FIN_ARBITRARY)\r\ncfg |= (effect->pat_cb << 13) | effect->pat_cr;\r\n}\r\nwritel(cfg, dev->regs + FIMC_REG_CIIMGEFF);\r\n}\r\nvoid fimc_hw_set_rgb_alpha(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_frame *frame = &ctx->d_frame;\r\nu32 cfg;\r\nif (!(frame->fmt->flags & FMT_HAS_ALPHA))\r\nreturn;\r\ncfg = readl(dev->regs + FIMC_REG_CIOCTRL);\r\ncfg &= ~FIMC_REG_CIOCTRL_ALPHA_OUT_MASK;\r\ncfg |= (frame->alpha << 4);\r\nwritel(cfg, dev->regs + FIMC_REG_CIOCTRL);\r\n}\r\nstatic void fimc_hw_set_in_dma_size(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_frame *frame = &ctx->s_frame;\r\nu32 cfg_o = 0;\r\nu32 cfg_r = 0;\r\nif (FIMC_IO_LCDFIFO == ctx->out_path)\r\ncfg_r |= FIMC_REG_CIREAL_ISIZE_AUTOLOAD_EN;\r\ncfg_o |= (frame->f_height << 16) | frame->f_width;\r\ncfg_r |= (frame->height << 16) | frame->width;\r\nwritel(cfg_o, dev->regs + FIMC_REG_ORGISIZE);\r\nwritel(cfg_r, dev->regs + FIMC_REG_CIREAL_ISIZE);\r\n}\r\nvoid fimc_hw_set_in_dma(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nstruct fimc_frame *frame = &ctx->s_frame;\r\nstruct fimc_dma_offset *offset = &frame->dma_offset;\r\nu32 cfg;\r\ncfg = (offset->y_v << 16) | offset->y_h;\r\nwritel(cfg, dev->regs + FIMC_REG_CIIYOFF);\r\ncfg = (offset->cb_v << 16) | offset->cb_h;\r\nwritel(cfg, dev->regs + FIMC_REG_CIICBOFF);\r\ncfg = (offset->cr_v << 16) | offset->cr_h;\r\nwritel(cfg, dev->regs + FIMC_REG_CIICROFF);\r\nfimc_hw_set_in_dma_size(ctx);\r\nfimc_hw_en_autoload(dev, ctx->out_path == FIMC_IO_LCDFIFO);\r\ncfg = readl(dev->regs + FIMC_REG_MSCTRL);\r\ncfg &= ~(FIMC_REG_MSCTRL_INFORMAT_MASK\r\n| FIMC_REG_MSCTRL_IN_BURST_COUNT_MASK\r\n| FIMC_REG_MSCTRL_INPUT_MASK\r\n| FIMC_REG_MSCTRL_C_INT_IN_MASK\r\n| FIMC_REG_MSCTRL_2P_IN_ORDER_MASK);\r\ncfg |= (FIMC_REG_MSCTRL_IN_BURST_COUNT(4)\r\n| FIMC_REG_MSCTRL_INPUT_MEMORY\r\n| FIMC_REG_MSCTRL_FIFO_CTRL_FULL);\r\nswitch (frame->fmt->color) {\r\ncase FIMC_FMT_RGB565...FIMC_FMT_RGB888:\r\ncfg |= FIMC_REG_MSCTRL_INFORMAT_RGB;\r\nbreak;\r\ncase FIMC_FMT_YCBCR420:\r\ncfg |= FIMC_REG_MSCTRL_INFORMAT_YCBCR420;\r\nif (frame->fmt->colplanes == 2)\r\ncfg |= ctx->in_order_2p | FIMC_REG_MSCTRL_C_INT_IN_2PLANE;\r\nelse\r\ncfg |= FIMC_REG_MSCTRL_C_INT_IN_3PLANE;\r\nbreak;\r\ncase FIMC_FMT_YCBYCR422...FIMC_FMT_CRYCBY422:\r\nif (frame->fmt->colplanes == 1) {\r\ncfg |= ctx->in_order_1p\r\n| FIMC_REG_MSCTRL_INFORMAT_YCBCR422_1P;\r\n} else {\r\ncfg |= FIMC_REG_MSCTRL_INFORMAT_YCBCR422;\r\nif (frame->fmt->colplanes == 2)\r\ncfg |= ctx->in_order_2p\r\n| FIMC_REG_MSCTRL_C_INT_IN_2PLANE;\r\nelse\r\ncfg |= FIMC_REG_MSCTRL_C_INT_IN_3PLANE;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(cfg, dev->regs + FIMC_REG_MSCTRL);\r\ncfg = readl(dev->regs + FIMC_REG_CIDMAPARAM);\r\ncfg &= ~FIMC_REG_CIDMAPARAM_TILE_MASK;\r\nif (tiled_fmt(ctx->s_frame.fmt))\r\ncfg |= FIMC_REG_CIDMAPARAM_R_64X32;\r\nif (tiled_fmt(ctx->d_frame.fmt))\r\ncfg |= FIMC_REG_CIDMAPARAM_W_64X32;\r\nwritel(cfg, dev->regs + FIMC_REG_CIDMAPARAM);\r\n}\r\nvoid fimc_hw_set_input_path(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nu32 cfg = readl(dev->regs + FIMC_REG_MSCTRL);\r\ncfg &= ~FIMC_REG_MSCTRL_INPUT_MASK;\r\nif (ctx->in_path == FIMC_IO_DMA)\r\ncfg |= FIMC_REG_MSCTRL_INPUT_MEMORY;\r\nelse\r\ncfg |= FIMC_REG_MSCTRL_INPUT_EXTCAM;\r\nwritel(cfg, dev->regs + FIMC_REG_MSCTRL);\r\n}\r\nvoid fimc_hw_set_output_path(struct fimc_ctx *ctx)\r\n{\r\nstruct fimc_dev *dev = ctx->fimc_dev;\r\nu32 cfg = readl(dev->regs + FIMC_REG_CISCCTRL);\r\ncfg &= ~FIMC_REG_CISCCTRL_LCDPATHEN_FIFO;\r\nif (ctx->out_path == FIMC_IO_LCDFIFO)\r\ncfg |= FIMC_REG_CISCCTRL_LCDPATHEN_FIFO;\r\nwritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\r\n}\r\nvoid fimc_hw_set_input_addr(struct fimc_dev *dev, struct fimc_addr *paddr)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_CIREAL_ISIZE);\r\ncfg |= FIMC_REG_CIREAL_ISIZE_ADDR_CH_DIS;\r\nwritel(cfg, dev->regs + FIMC_REG_CIREAL_ISIZE);\r\nwritel(paddr->y, dev->regs + FIMC_REG_CIIYSA(0));\r\nwritel(paddr->cb, dev->regs + FIMC_REG_CIICBSA(0));\r\nwritel(paddr->cr, dev->regs + FIMC_REG_CIICRSA(0));\r\ncfg &= ~FIMC_REG_CIREAL_ISIZE_ADDR_CH_DIS;\r\nwritel(cfg, dev->regs + FIMC_REG_CIREAL_ISIZE);\r\n}\r\nvoid fimc_hw_set_output_addr(struct fimc_dev *dev,\r\nstruct fimc_addr *paddr, int index)\r\n{\r\nint i = (index == -1) ? 0 : index;\r\ndo {\r\nwritel(paddr->y, dev->regs + FIMC_REG_CIOYSA(i));\r\nwritel(paddr->cb, dev->regs + FIMC_REG_CIOCBSA(i));\r\nwritel(paddr->cr, dev->regs + FIMC_REG_CIOCRSA(i));\r\ndbg("dst_buf[%d]: 0x%X, cb: 0x%X, cr: 0x%X",\r\ni, paddr->y, paddr->cb, paddr->cr);\r\n} while (index == -1 && ++i < FIMC_MAX_OUT_BUFS);\r\n}\r\nint fimc_hw_set_camera_polarity(struct fimc_dev *fimc,\r\nstruct s5p_fimc_isp_info *cam)\r\n{\r\nu32 cfg = readl(fimc->regs + FIMC_REG_CIGCTRL);\r\ncfg &= ~(FIMC_REG_CIGCTRL_INVPOLPCLK | FIMC_REG_CIGCTRL_INVPOLVSYNC |\r\nFIMC_REG_CIGCTRL_INVPOLHREF | FIMC_REG_CIGCTRL_INVPOLHSYNC |\r\nFIMC_REG_CIGCTRL_INVPOLFIELD);\r\nif (cam->flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncfg |= FIMC_REG_CIGCTRL_INVPOLPCLK;\r\nif (cam->flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncfg |= FIMC_REG_CIGCTRL_INVPOLVSYNC;\r\nif (cam->flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncfg |= FIMC_REG_CIGCTRL_INVPOLHREF;\r\nif (cam->flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncfg |= FIMC_REG_CIGCTRL_INVPOLHSYNC;\r\nif (cam->flags & V4L2_MBUS_FIELD_EVEN_LOW)\r\ncfg |= FIMC_REG_CIGCTRL_INVPOLFIELD;\r\nwritel(cfg, fimc->regs + FIMC_REG_CIGCTRL);\r\nreturn 0;\r\n}\r\nint fimc_hw_set_camera_source(struct fimc_dev *fimc,\r\nstruct s5p_fimc_isp_info *cam)\r\n{\r\nstruct fimc_frame *f = &fimc->vid_cap.ctx->s_frame;\r\nu32 cfg = 0;\r\nu32 bus_width;\r\nint i;\r\nif (cam->bus_type == FIMC_ITU_601 || cam->bus_type == FIMC_ITU_656) {\r\nfor (i = 0; i < ARRAY_SIZE(pix_desc); i++) {\r\nif (fimc->vid_cap.mf.code == pix_desc[i].pixelcode) {\r\ncfg = pix_desc[i].cisrcfmt;\r\nbus_width = pix_desc[i].bus_width;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(pix_desc)) {\r\nv4l2_err(&fimc->vid_cap.vfd,\r\n"Camera color format not supported: %d\n",\r\nfimc->vid_cap.mf.code);\r\nreturn -EINVAL;\r\n}\r\nif (cam->bus_type == FIMC_ITU_601) {\r\nif (bus_width == 8)\r\ncfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\r\nelse if (bus_width == 16)\r\ncfg |= FIMC_REG_CISRCFMT_ITU601_16BIT;\r\n}\r\n} else if (cam->bus_type == FIMC_MIPI_CSI2) {\r\nif (fimc_fmt_is_user_defined(f->fmt->color))\r\ncfg |= FIMC_REG_CISRCFMT_ITU601_8BIT;\r\n}\r\ncfg |= (f->o_width << 16) | f->o_height;\r\nwritel(cfg, fimc->regs + FIMC_REG_CISRCFMT);\r\nreturn 0;\r\n}\r\nvoid fimc_hw_set_camera_offset(struct fimc_dev *fimc, struct fimc_frame *f)\r\n{\r\nu32 hoff2, voff2;\r\nu32 cfg = readl(fimc->regs + FIMC_REG_CIWDOFST);\r\ncfg &= ~(FIMC_REG_CIWDOFST_HOROFF_MASK | FIMC_REG_CIWDOFST_VEROFF_MASK);\r\ncfg |= FIMC_REG_CIWDOFST_OFF_EN |\r\n(f->offs_h << 16) | f->offs_v;\r\nwritel(cfg, fimc->regs + FIMC_REG_CIWDOFST);\r\nhoff2 = f->o_width - f->width - f->offs_h;\r\nvoff2 = f->o_height - f->height - f->offs_v;\r\ncfg = (hoff2 << 16) | voff2;\r\nwritel(cfg, fimc->regs + FIMC_REG_CIWDOFST2);\r\n}\r\nint fimc_hw_set_camera_type(struct fimc_dev *fimc,\r\nstruct s5p_fimc_isp_info *cam)\r\n{\r\nu32 cfg, tmp;\r\nstruct fimc_vid_cap *vid_cap = &fimc->vid_cap;\r\nu32 csis_data_alignment = 32;\r\ncfg = readl(fimc->regs + FIMC_REG_CIGCTRL);\r\ncfg &= ~(FIMC_REG_CIGCTRL_TESTPAT_MASK | FIMC_REG_CIGCTRL_SELCAM_ITU_A |\r\nFIMC_REG_CIGCTRL_SELCAM_MIPI | FIMC_REG_CIGCTRL_CAMIF_SELWB |\r\nFIMC_REG_CIGCTRL_SELCAM_MIPI_A | FIMC_REG_CIGCTRL_CAM_JPEG);\r\nswitch (cam->bus_type) {\r\ncase FIMC_MIPI_CSI2:\r\ncfg |= FIMC_REG_CIGCTRL_SELCAM_MIPI;\r\nif (cam->mux_id == 0)\r\ncfg |= FIMC_REG_CIGCTRL_SELCAM_MIPI_A;\r\nswitch (vid_cap->mf.code) {\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ntmp = FIMC_REG_CSIIMGFMT_YCBCR422_8BIT;\r\nbreak;\r\ncase V4L2_MBUS_FMT_JPEG_1X8:\r\ncase V4L2_MBUS_FMT_S5C_UYVY_JPEG_1X8:\r\ntmp = FIMC_REG_CSIIMGFMT_USER(1);\r\ncfg |= FIMC_REG_CIGCTRL_CAM_JPEG;\r\nbreak;\r\ndefault:\r\nv4l2_err(&vid_cap->vfd,\r\n"Not supported camera pixel format: %#x\n",\r\nvid_cap->mf.code);\r\nreturn -EINVAL;\r\n}\r\ntmp |= (csis_data_alignment == 32) << 8;\r\nwritel(tmp, fimc->regs + FIMC_REG_CSIIMGFMT);\r\nbreak;\r\ncase FIMC_ITU_601...FIMC_ITU_656:\r\nif (cam->mux_id == 0)\r\ncfg |= FIMC_REG_CIGCTRL_SELCAM_ITU_A;\r\nbreak;\r\ncase FIMC_LCD_WB:\r\ncfg |= FIMC_REG_CIGCTRL_CAMIF_SELWB;\r\nbreak;\r\ndefault:\r\nv4l2_err(&vid_cap->vfd, "Invalid camera bus type selected\n");\r\nreturn -EINVAL;\r\n}\r\nwritel(cfg, fimc->regs + FIMC_REG_CIGCTRL);\r\nreturn 0;\r\n}\r\nvoid fimc_hw_clear_irq(struct fimc_dev *dev)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_CIGCTRL);\r\ncfg |= FIMC_REG_CIGCTRL_IRQ_CLR;\r\nwritel(cfg, dev->regs + FIMC_REG_CIGCTRL);\r\n}\r\nvoid fimc_hw_enable_scaler(struct fimc_dev *dev, bool on)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_CISCCTRL);\r\nif (on)\r\ncfg |= FIMC_REG_CISCCTRL_SCALERSTART;\r\nelse\r\ncfg &= ~FIMC_REG_CISCCTRL_SCALERSTART;\r\nwritel(cfg, dev->regs + FIMC_REG_CISCCTRL);\r\n}\r\nvoid fimc_hw_activate_input_dma(struct fimc_dev *dev, bool on)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_MSCTRL);\r\nif (on)\r\ncfg |= FIMC_REG_MSCTRL_ENVID;\r\nelse\r\ncfg &= ~FIMC_REG_MSCTRL_ENVID;\r\nwritel(cfg, dev->regs + FIMC_REG_MSCTRL);\r\n}\r\nvoid fimc_hw_dis_capture(struct fimc_dev *dev)\r\n{\r\nu32 cfg = readl(dev->regs + FIMC_REG_CIIMGCPT);\r\ncfg &= ~(FIMC_REG_CIIMGCPT_IMGCPTEN | FIMC_REG_CIIMGCPT_IMGCPTEN_SC);\r\nwritel(cfg, dev->regs + FIMC_REG_CIIMGCPT);\r\n}\r\ns32 fimc_hw_get_frame_index(struct fimc_dev *dev)\r\n{\r\ns32 reg;\r\nif (dev->variant->has_cistatus2) {\r\nreg = readl(dev->regs + FIMC_REG_CISTATUS2) & 0x3f;\r\nreturn reg - 1;\r\n}\r\nreg = readl(dev->regs + FIMC_REG_CISTATUS);\r\nreturn (reg & FIMC_REG_CISTATUS_FRAMECNT_MASK) >>\r\nFIMC_REG_CISTATUS_FRAMECNT_SHIFT;\r\n}\r\ns32 fimc_hw_get_prev_frame_index(struct fimc_dev *dev)\r\n{\r\ns32 reg;\r\nif (!dev->variant->has_cistatus2)\r\nreturn -1;\r\nreg = readl(dev->regs + FIMC_REG_CISTATUS2);\r\nreturn ((reg >> 7) & 0x3f) - 1;\r\n}\r\nvoid fimc_activate_capture(struct fimc_ctx *ctx)\r\n{\r\nfimc_hw_enable_scaler(ctx->fimc_dev, ctx->scaler.enabled);\r\nfimc_hw_en_capture(ctx);\r\n}\r\nvoid fimc_deactivate_capture(struct fimc_dev *fimc)\r\n{\r\nfimc_hw_en_lastirq(fimc, true);\r\nfimc_hw_dis_capture(fimc);\r\nfimc_hw_enable_scaler(fimc, false);\r\nfimc_hw_en_lastirq(fimc, false);\r\n}
