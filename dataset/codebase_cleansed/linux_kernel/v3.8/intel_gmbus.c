static inline struct intel_gmbus *\r\nto_intel_gmbus(struct i2c_adapter *i2c)\r\n{\r\nreturn container_of(i2c, struct intel_gmbus, adapter);\r\n}\r\nvoid\r\ngma_intel_i2c_reset(struct drm_device *dev)\r\n{\r\nREG_WRITE(GMBUS0, 0);\r\n}\r\nstatic void intel_i2c_quirk_set(struct drm_psb_private *dev_priv, bool enable)\r\n{\r\n}\r\nstatic u32 get_reserved(struct intel_gpio *gpio)\r\n{\r\nstruct drm_psb_private *dev_priv = gpio->dev_priv;\r\nstruct drm_device *dev = dev_priv->dev;\r\nu32 reserved = 0;\r\nreserved = REG_READ(gpio->reg) &\r\n(GPIO_DATA_PULLUP_DISABLE |\r\nGPIO_CLOCK_PULLUP_DISABLE);\r\nreturn reserved;\r\n}\r\nstatic int get_clock(void *data)\r\n{\r\nstruct intel_gpio *gpio = data;\r\nstruct drm_psb_private *dev_priv = gpio->dev_priv;\r\nstruct drm_device *dev = dev_priv->dev;\r\nu32 reserved = get_reserved(gpio);\r\nREG_WRITE(gpio->reg, reserved | GPIO_CLOCK_DIR_MASK);\r\nREG_WRITE(gpio->reg, reserved);\r\nreturn (REG_READ(gpio->reg) & GPIO_CLOCK_VAL_IN) != 0;\r\n}\r\nstatic int get_data(void *data)\r\n{\r\nstruct intel_gpio *gpio = data;\r\nstruct drm_psb_private *dev_priv = gpio->dev_priv;\r\nstruct drm_device *dev = dev_priv->dev;\r\nu32 reserved = get_reserved(gpio);\r\nREG_WRITE(gpio->reg, reserved | GPIO_DATA_DIR_MASK);\r\nREG_WRITE(gpio->reg, reserved);\r\nreturn (REG_READ(gpio->reg) & GPIO_DATA_VAL_IN) != 0;\r\n}\r\nstatic void set_clock(void *data, int state_high)\r\n{\r\nstruct intel_gpio *gpio = data;\r\nstruct drm_psb_private *dev_priv = gpio->dev_priv;\r\nstruct drm_device *dev = dev_priv->dev;\r\nu32 reserved = get_reserved(gpio);\r\nu32 clock_bits;\r\nif (state_high)\r\nclock_bits = GPIO_CLOCK_DIR_IN | GPIO_CLOCK_DIR_MASK;\r\nelse\r\nclock_bits = GPIO_CLOCK_DIR_OUT | GPIO_CLOCK_DIR_MASK |\r\nGPIO_CLOCK_VAL_MASK;\r\nREG_WRITE(gpio->reg, reserved | clock_bits);\r\nREG_READ(gpio->reg);\r\n}\r\nstatic void set_data(void *data, int state_high)\r\n{\r\nstruct intel_gpio *gpio = data;\r\nstruct drm_psb_private *dev_priv = gpio->dev_priv;\r\nstruct drm_device *dev = dev_priv->dev;\r\nu32 reserved = get_reserved(gpio);\r\nu32 data_bits;\r\nif (state_high)\r\ndata_bits = GPIO_DATA_DIR_IN | GPIO_DATA_DIR_MASK;\r\nelse\r\ndata_bits = GPIO_DATA_DIR_OUT | GPIO_DATA_DIR_MASK |\r\nGPIO_DATA_VAL_MASK;\r\nREG_WRITE(gpio->reg, reserved | data_bits);\r\nREG_READ(gpio->reg);\r\n}\r\nstatic struct i2c_adapter *\r\nintel_gpio_create(struct drm_psb_private *dev_priv, u32 pin)\r\n{\r\nstatic const int map_pin_to_reg[] = {\r\n0,\r\nGPIOB,\r\nGPIOA,\r\nGPIOC,\r\nGPIOD,\r\nGPIOE,\r\n0,\r\nGPIOF,\r\n};\r\nstruct intel_gpio *gpio;\r\nif (pin >= ARRAY_SIZE(map_pin_to_reg) || !map_pin_to_reg[pin])\r\nreturn NULL;\r\ngpio = kzalloc(sizeof(struct intel_gpio), GFP_KERNEL);\r\nif (gpio == NULL)\r\nreturn NULL;\r\ngpio->reg = map_pin_to_reg[pin];\r\ngpio->dev_priv = dev_priv;\r\nsnprintf(gpio->adapter.name, sizeof(gpio->adapter.name),\r\n"gma500 GPIO%c", "?BACDE?F"[pin]);\r\ngpio->adapter.owner = THIS_MODULE;\r\ngpio->adapter.algo_data = &gpio->algo;\r\ngpio->adapter.dev.parent = &dev_priv->dev->pdev->dev;\r\ngpio->algo.setsda = set_data;\r\ngpio->algo.setscl = set_clock;\r\ngpio->algo.getsda = get_data;\r\ngpio->algo.getscl = get_clock;\r\ngpio->algo.udelay = I2C_RISEFALL_TIME;\r\ngpio->algo.timeout = usecs_to_jiffies(2200);\r\ngpio->algo.data = gpio;\r\nif (i2c_bit_add_bus(&gpio->adapter))\r\ngoto out_free;\r\nreturn &gpio->adapter;\r\nout_free:\r\nkfree(gpio);\r\nreturn NULL;\r\n}\r\nstatic int\r\nintel_i2c_quirk_xfer(struct drm_psb_private *dev_priv,\r\nstruct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct intel_gpio *gpio = container_of(adapter,\r\nstruct intel_gpio,\r\nadapter);\r\nint ret;\r\ngma_intel_i2c_reset(dev_priv->dev);\r\nintel_i2c_quirk_set(dev_priv, true);\r\nset_data(gpio, 1);\r\nset_clock(gpio, 1);\r\nudelay(I2C_RISEFALL_TIME);\r\nret = adapter->algo->master_xfer(adapter, msgs, num);\r\nset_data(gpio, 1);\r\nset_clock(gpio, 1);\r\nintel_i2c_quirk_set(dev_priv, false);\r\nreturn ret;\r\n}\r\nstatic int\r\ngmbus_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct intel_gmbus *bus = container_of(adapter,\r\nstruct intel_gmbus,\r\nadapter);\r\nstruct drm_psb_private *dev_priv = adapter->algo_data;\r\nstruct drm_device *dev = dev_priv->dev;\r\nint i, reg_offset;\r\nif (bus->force_bit)\r\nreturn intel_i2c_quirk_xfer(dev_priv,\r\nbus->force_bit, msgs, num);\r\nreg_offset = 0;\r\nREG_WRITE(GMBUS0 + reg_offset, bus->reg0);\r\nfor (i = 0; i < num; i++) {\r\nu16 len = msgs[i].len;\r\nu8 *buf = msgs[i].buf;\r\nif (msgs[i].flags & I2C_M_RD) {\r\nREG_WRITE(GMBUS1 + reg_offset,\r\nGMBUS_CYCLE_WAIT | (i + 1 == num ? GMBUS_CYCLE_STOP : 0) |\r\n(len << GMBUS_BYTE_COUNT_SHIFT) |\r\n(msgs[i].addr << GMBUS_SLAVE_ADDR_SHIFT) |\r\nGMBUS_SLAVE_READ | GMBUS_SW_RDY);\r\nREG_READ(GMBUS2+reg_offset);\r\ndo {\r\nu32 val, loop = 0;\r\nif (wait_for(REG_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_RDY), 50))\r\ngoto timeout;\r\nif (REG_READ(GMBUS2 + reg_offset) & GMBUS_SATOER)\r\ngoto clear_err;\r\nval = REG_READ(GMBUS3 + reg_offset);\r\ndo {\r\n*buf++ = val & 0xff;\r\nval >>= 8;\r\n} while (--len && ++loop < 4);\r\n} while (len);\r\n} else {\r\nu32 val, loop;\r\nval = loop = 0;\r\ndo {\r\nval |= *buf++ << (8 * loop);\r\n} while (--len && ++loop < 4);\r\nREG_WRITE(GMBUS3 + reg_offset, val);\r\nREG_WRITE(GMBUS1 + reg_offset,\r\n(i + 1 == num ? GMBUS_CYCLE_STOP : GMBUS_CYCLE_WAIT) |\r\n(msgs[i].len << GMBUS_BYTE_COUNT_SHIFT) |\r\n(msgs[i].addr << GMBUS_SLAVE_ADDR_SHIFT) |\r\nGMBUS_SLAVE_WRITE | GMBUS_SW_RDY);\r\nREG_READ(GMBUS2+reg_offset);\r\nwhile (len) {\r\nif (wait_for(REG_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_RDY), 50))\r\ngoto timeout;\r\nif (REG_READ(GMBUS2 + reg_offset) & GMBUS_SATOER)\r\ngoto clear_err;\r\nval = loop = 0;\r\ndo {\r\nval |= *buf++ << (8 * loop);\r\n} while (--len && ++loop < 4);\r\nREG_WRITE(GMBUS3 + reg_offset, val);\r\nREG_READ(GMBUS2+reg_offset);\r\n}\r\n}\r\nif (i + 1 < num && wait_for(REG_READ(GMBUS2 + reg_offset) & (GMBUS_SATOER | GMBUS_HW_WAIT_PHASE), 50))\r\ngoto timeout;\r\nif (REG_READ(GMBUS2 + reg_offset) & GMBUS_SATOER)\r\ngoto clear_err;\r\n}\r\ngoto done;\r\nclear_err:\r\nREG_WRITE(GMBUS1 + reg_offset, GMBUS_SW_CLR_INT);\r\nREG_WRITE(GMBUS1 + reg_offset, 0);\r\ndone:\r\nREG_WRITE(GMBUS0 + reg_offset, 0);\r\nreturn i;\r\ntimeout:\r\nDRM_INFO("GMBUS timed out, falling back to bit banging on pin %d [%s]\n",\r\nbus->reg0 & 0xff, bus->adapter.name);\r\nREG_WRITE(GMBUS0 + reg_offset, 0);\r\nbus->force_bit = intel_gpio_create(dev_priv, bus->reg0 & 0xff);\r\nif (!bus->force_bit)\r\nreturn -ENOMEM;\r\nreturn intel_i2c_quirk_xfer(dev_priv, bus->force_bit, msgs, num);\r\n}\r\nstatic u32 gmbus_func(struct i2c_adapter *adapter)\r\n{\r\nstruct intel_gmbus *bus = container_of(adapter,\r\nstruct intel_gmbus,\r\nadapter);\r\nif (bus->force_bit)\r\nbus->force_bit->algo->functionality(bus->force_bit);\r\nreturn (I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL);\r\n}\r\nint gma_intel_setup_gmbus(struct drm_device *dev)\r\n{\r\nstatic const char *names[GMBUS_NUM_PORTS] = {\r\n"disabled",\r\n"ssc",\r\n"vga",\r\n"panel",\r\n"dpc",\r\n"dpb",\r\n"reserved",\r\n"dpd",\r\n};\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint ret, i;\r\ndev_priv->gmbus = kcalloc(GMBUS_NUM_PORTS, sizeof(struct intel_gmbus),\r\nGFP_KERNEL);\r\nif (dev_priv->gmbus == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < GMBUS_NUM_PORTS; i++) {\r\nstruct intel_gmbus *bus = &dev_priv->gmbus[i];\r\nbus->adapter.owner = THIS_MODULE;\r\nbus->adapter.class = I2C_CLASS_DDC;\r\nsnprintf(bus->adapter.name,\r\nsizeof(bus->adapter.name),\r\n"gma500 gmbus %s",\r\nnames[i]);\r\nbus->adapter.dev.parent = &dev->pdev->dev;\r\nbus->adapter.algo_data = dev_priv;\r\nbus->adapter.algo = &gmbus_algorithm;\r\nret = i2c_add_adapter(&bus->adapter);\r\nif (ret)\r\ngoto err;\r\nbus->reg0 = i | GMBUS_RATE_100KHZ;\r\nbus->force_bit = intel_gpio_create(dev_priv, i);\r\n}\r\ngma_intel_i2c_reset(dev_priv->dev);\r\nreturn 0;\r\nerr:\r\nwhile (--i) {\r\nstruct intel_gmbus *bus = &dev_priv->gmbus[i];\r\ni2c_del_adapter(&bus->adapter);\r\n}\r\nkfree(dev_priv->gmbus);\r\ndev_priv->gmbus = NULL;\r\nreturn ret;\r\n}\r\nvoid gma_intel_gmbus_set_speed(struct i2c_adapter *adapter, int speed)\r\n{\r\nstruct intel_gmbus *bus = to_intel_gmbus(adapter);\r\nbus->reg0 = (bus->reg0 & ~(0x3 << 8)) | (speed << 8);\r\n}\r\nvoid gma_intel_gmbus_force_bit(struct i2c_adapter *adapter, bool force_bit)\r\n{\r\nstruct intel_gmbus *bus = to_intel_gmbus(adapter);\r\nif (force_bit) {\r\nif (bus->force_bit == NULL) {\r\nstruct drm_psb_private *dev_priv = adapter->algo_data;\r\nbus->force_bit = intel_gpio_create(dev_priv,\r\nbus->reg0 & 0xff);\r\n}\r\n} else {\r\nif (bus->force_bit) {\r\ni2c_del_adapter(bus->force_bit);\r\nkfree(bus->force_bit);\r\nbus->force_bit = NULL;\r\n}\r\n}\r\n}\r\nvoid gma_intel_teardown_gmbus(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint i;\r\nif (dev_priv->gmbus == NULL)\r\nreturn;\r\nfor (i = 0; i < GMBUS_NUM_PORTS; i++) {\r\nstruct intel_gmbus *bus = &dev_priv->gmbus[i];\r\nif (bus->force_bit) {\r\ni2c_del_adapter(bus->force_bit);\r\nkfree(bus->force_bit);\r\n}\r\ni2c_del_adapter(&bus->adapter);\r\n}\r\nkfree(dev_priv->gmbus);\r\ndev_priv->gmbus = NULL;\r\n}
