static inline struct crypto_gcm_req_priv_ctx *crypto_gcm_reqctx(\r\nstruct aead_request *req)\r\n{\r\nunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\r\nreturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\r\n}\r\nstatic void crypto_gcm_setkey_done(struct crypto_async_request *req, int err)\r\n{\r\nstruct crypto_gcm_setkey_result *result = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nresult->err = err;\r\ncomplete(&result->completion);\r\n}\r\nstatic int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ahash *ghash = ctx->ghash;\r\nstruct crypto_ablkcipher *ctr = ctx->ctr;\r\nstruct {\r\nbe128 hash;\r\nu8 iv[8];\r\nstruct crypto_gcm_setkey_result result;\r\nstruct scatterlist sg[1];\r\nstruct ablkcipher_request req;\r\n} *data;\r\nint err;\r\ncrypto_ablkcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(ctr, key, keylen);\r\nif (err)\r\nreturn err;\r\ncrypto_aead_set_flags(aead, crypto_ablkcipher_get_flags(ctr) &\r\nCRYPTO_TFM_RES_MASK);\r\ndata = kzalloc(sizeof(*data) + crypto_ablkcipher_reqsize(ctr),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninit_completion(&data->result.completion);\r\nsg_init_one(data->sg, &data->hash, sizeof(data->hash));\r\nablkcipher_request_set_tfm(&data->req, ctr);\r\nablkcipher_request_set_callback(&data->req, CRYPTO_TFM_REQ_MAY_SLEEP |\r\nCRYPTO_TFM_REQ_MAY_BACKLOG,\r\ncrypto_gcm_setkey_done,\r\n&data->result);\r\nablkcipher_request_set_crypt(&data->req, data->sg, data->sg,\r\nsizeof(data->hash), data->iv);\r\nerr = crypto_ablkcipher_encrypt(&data->req);\r\nif (err == -EINPROGRESS || err == -EBUSY) {\r\nerr = wait_for_completion_interruptible(\r\n&data->result.completion);\r\nif (!err)\r\nerr = data->result.err;\r\n}\r\nif (err)\r\ngoto out;\r\ncrypto_ahash_clear_flags(ghash, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(ghash, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(ghash, (u8 *)&data->hash, sizeof(be128));\r\ncrypto_aead_set_flags(aead, crypto_ahash_get_flags(ghash) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int crypto_gcm_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 4:\r\ncase 8:\r\ncase 12:\r\ncase 13:\r\ncase 14:\r\ncase 15:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void crypto_gcm_init_crypt(struct ablkcipher_request *ablk_req,\r\nstruct aead_request *req,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct scatterlist *dst;\r\n__be32 counter = cpu_to_be32(1);\r\nmemset(pctx->auth_tag, 0, sizeof(pctx->auth_tag));\r\nmemcpy(req->iv + 12, &counter, 4);\r\nsg_init_table(pctx->src, 2);\r\nsg_set_buf(pctx->src, pctx->auth_tag, sizeof(pctx->auth_tag));\r\nscatterwalk_sg_chain(pctx->src, 2, req->src);\r\ndst = pctx->src;\r\nif (req->src != req->dst) {\r\nsg_init_table(pctx->dst, 2);\r\nsg_set_buf(pctx->dst, pctx->auth_tag, sizeof(pctx->auth_tag));\r\nscatterwalk_sg_chain(pctx->dst, 2, req->dst);\r\ndst = pctx->dst;\r\n}\r\nablkcipher_request_set_tfm(ablk_req, ctx->ctr);\r\nablkcipher_request_set_crypt(ablk_req, pctx->src, dst,\r\ncryptlen + sizeof(pctx->auth_tag),\r\nreq->iv);\r\n}\r\nstatic inline unsigned int gcm_remain(unsigned int len)\r\n{\r\nlen &= 0xfU;\r\nreturn len ? 16 - len : 0;\r\n}\r\nstatic int gcm_hash_update(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx,\r\ncrypto_completion_t complete,\r\nstruct scatterlist *src,\r\nunsigned int len)\r\n{\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\ncomplete, req);\r\nahash_request_set_crypt(ahreq, src, NULL, len);\r\nreturn crypto_ahash_update(ahreq);\r\n}\r\nstatic int gcm_hash_remain(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx,\r\nunsigned int remain,\r\ncrypto_completion_t complete)\r\n{\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\ncomplete, req);\r\nsg_init_one(pctx->src, gcm_zeroes, remain);\r\nahash_request_set_crypt(ahreq, pctx->src, NULL, remain);\r\nreturn crypto_ahash_update(ahreq);\r\n}\r\nstatic int gcm_hash_len(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx)\r\n{\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nu128 lengths;\r\nlengths.a = cpu_to_be64(req->assoclen * 8);\r\nlengths.b = cpu_to_be64(gctx->cryptlen * 8);\r\nmemcpy(pctx->iauth_tag, &lengths, 16);\r\nsg_init_one(pctx->src, pctx->iauth_tag, 16);\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\ngcm_hash_len_done, req);\r\nahash_request_set_crypt(ahreq, pctx->src,\r\nNULL, sizeof(lengths));\r\nreturn crypto_ahash_update(ahreq);\r\n}\r\nstatic int gcm_hash_final(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx)\r\n{\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\ngcm_hash_final_done, req);\r\nahash_request_set_crypt(ahreq, NULL, pctx->iauth_tag, 0);\r\nreturn crypto_ahash_final(ahreq);\r\n}\r\nstatic void __gcm_hash_final_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nif (!err)\r\ncrypto_xor(pctx->auth_tag, pctx->iauth_tag, 16);\r\ngctx->complete(req, err);\r\n}\r\nstatic void gcm_hash_final_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_final_done(req, err);\r\n}\r\nstatic void __gcm_hash_len_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nif (!err) {\r\nerr = gcm_hash_final(req, pctx);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\n}\r\n__gcm_hash_final_done(req, err);\r\n}\r\nstatic void gcm_hash_len_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_len_done(req, err);\r\n}\r\nstatic void __gcm_hash_crypt_remain_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nif (!err) {\r\nerr = gcm_hash_len(req, pctx);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\n}\r\n__gcm_hash_len_done(req, err);\r\n}\r\nstatic void gcm_hash_crypt_remain_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_crypt_remain_done(req, err);\r\n}\r\nstatic void __gcm_hash_crypt_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nunsigned int remain;\r\nif (!err) {\r\nremain = gcm_remain(gctx->cryptlen);\r\nBUG_ON(!remain);\r\nerr = gcm_hash_remain(req, pctx, remain,\r\ngcm_hash_crypt_remain_done);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\n}\r\n__gcm_hash_crypt_remain_done(req, err);\r\n}\r\nstatic void gcm_hash_crypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_crypt_done(req, err);\r\n}\r\nstatic void __gcm_hash_assoc_remain_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\ncrypto_completion_t complete;\r\nunsigned int remain = 0;\r\nif (!err && gctx->cryptlen) {\r\nremain = gcm_remain(gctx->cryptlen);\r\ncomplete = remain ? gcm_hash_crypt_done :\r\ngcm_hash_crypt_remain_done;\r\nerr = gcm_hash_update(req, pctx, complete,\r\ngctx->src, gctx->cryptlen);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\n}\r\nif (remain)\r\n__gcm_hash_crypt_done(req, err);\r\nelse\r\n__gcm_hash_crypt_remain_done(req, err);\r\n}\r\nstatic void gcm_hash_assoc_remain_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_assoc_remain_done(req, err);\r\n}\r\nstatic void __gcm_hash_assoc_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nunsigned int remain;\r\nif (!err) {\r\nremain = gcm_remain(req->assoclen);\r\nBUG_ON(!remain);\r\nerr = gcm_hash_remain(req, pctx, remain,\r\ngcm_hash_assoc_remain_done);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\n}\r\n__gcm_hash_assoc_remain_done(req, err);\r\n}\r\nstatic void gcm_hash_assoc_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_assoc_done(req, err);\r\n}\r\nstatic void __gcm_hash_init_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\ncrypto_completion_t complete;\r\nunsigned int remain = 0;\r\nif (!err && req->assoclen) {\r\nremain = gcm_remain(req->assoclen);\r\ncomplete = remain ? gcm_hash_assoc_done :\r\ngcm_hash_assoc_remain_done;\r\nerr = gcm_hash_update(req, pctx, complete,\r\nreq->assoc, req->assoclen);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\n}\r\nif (remain)\r\n__gcm_hash_assoc_done(req, err);\r\nelse\r\n__gcm_hash_assoc_remain_done(req, err);\r\n}\r\nstatic void gcm_hash_init_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\n__gcm_hash_init_done(req, err);\r\n}\r\nstatic int gcm_hash(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx)\r\n{\r\nstruct ahash_request *ahreq = &pctx->u.ahreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nstruct crypto_gcm_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nunsigned int remain;\r\ncrypto_completion_t complete;\r\nint err;\r\nahash_request_set_tfm(ahreq, ctx->ghash);\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\ngcm_hash_init_done, req);\r\nerr = crypto_ahash_init(ahreq);\r\nif (err)\r\nreturn err;\r\nremain = gcm_remain(req->assoclen);\r\ncomplete = remain ? gcm_hash_assoc_done : gcm_hash_assoc_remain_done;\r\nerr = gcm_hash_update(req, pctx, complete, req->assoc, req->assoclen);\r\nif (err)\r\nreturn err;\r\nif (remain) {\r\nerr = gcm_hash_remain(req, pctx, remain,\r\ngcm_hash_assoc_remain_done);\r\nif (err)\r\nreturn err;\r\n}\r\nremain = gcm_remain(gctx->cryptlen);\r\ncomplete = remain ? gcm_hash_crypt_done : gcm_hash_crypt_remain_done;\r\nerr = gcm_hash_update(req, pctx, complete, gctx->src, gctx->cryptlen);\r\nif (err)\r\nreturn err;\r\nif (remain) {\r\nerr = gcm_hash_remain(req, pctx, remain,\r\ngcm_hash_crypt_remain_done);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = gcm_hash_len(req, pctx);\r\nif (err)\r\nreturn err;\r\nerr = gcm_hash_final(req, pctx);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void gcm_enc_copy_hash(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nu8 *auth_tag = pctx->auth_tag;\r\nscatterwalk_map_and_copy(auth_tag, req->dst, req->cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\n}\r\nstatic void gcm_enc_hash_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nif (!err)\r\ngcm_enc_copy_hash(req, pctx);\r\naead_request_complete(req, err);\r\n}\r\nstatic void gcm_encrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nif (!err) {\r\nerr = gcm_hash(req, pctx);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\nelse if (!err) {\r\ncrypto_xor(pctx->auth_tag, pctx->iauth_tag, 16);\r\ngcm_enc_copy_hash(req, pctx);\r\n}\r\n}\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_gcm_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->u.abreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nint err;\r\ncrypto_gcm_init_crypt(abreq, req, req->cryptlen);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\ngcm_encrypt_done, req);\r\ngctx->src = req->dst;\r\ngctx->cryptlen = req->cryptlen;\r\ngctx->complete = gcm_enc_hash_done;\r\nerr = crypto_ablkcipher_encrypt(abreq);\r\nif (err)\r\nreturn err;\r\nerr = gcm_hash(req, pctx);\r\nif (err)\r\nreturn err;\r\ncrypto_xor(pctx->auth_tag, pctx->iauth_tag, 16);\r\ngcm_enc_copy_hash(req, pctx);\r\nreturn 0;\r\n}\r\nstatic int crypto_gcm_verify(struct aead_request *req,\r\nstruct crypto_gcm_req_priv_ctx *pctx)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nu8 *auth_tag = pctx->auth_tag;\r\nu8 *iauth_tag = pctx->iauth_tag;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen - authsize;\r\ncrypto_xor(auth_tag, iauth_tag, 16);\r\nscatterwalk_map_and_copy(iauth_tag, req->src, cryptlen, authsize, 0);\r\nreturn memcmp(iauth_tag, auth_tag, authsize) ? -EBADMSG : 0;\r\n}\r\nstatic void gcm_decrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nif (!err)\r\nerr = crypto_gcm_verify(req, pctx);\r\naead_request_complete(req, err);\r\n}\r\nstatic void gcm_dec_hash_done(struct aead_request *req, int err)\r\n{\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->u.abreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nif (!err) {\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\ngcm_decrypt_done, req);\r\ncrypto_gcm_init_crypt(abreq, req, gctx->cryptlen);\r\nerr = crypto_ablkcipher_decrypt(abreq);\r\nif (err == -EINPROGRESS || err == -EBUSY)\r\nreturn;\r\nelse if (!err)\r\nerr = crypto_gcm_verify(req, pctx);\r\n}\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_gcm_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->u.abreq;\r\nstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen;\r\nint err;\r\nif (cryptlen < authsize)\r\nreturn -EINVAL;\r\ncryptlen -= authsize;\r\ngctx->src = req->src;\r\ngctx->cryptlen = cryptlen;\r\ngctx->complete = gcm_dec_hash_done;\r\nerr = gcm_hash(req, pctx);\r\nif (err)\r\nreturn err;\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\ngcm_decrypt_done, req);\r\ncrypto_gcm_init_crypt(abreq, req, cryptlen);\r\nerr = crypto_ablkcipher_decrypt(abreq);\r\nif (err)\r\nreturn err;\r\nreturn crypto_gcm_verify(req, pctx);\r\n}\r\nstatic int crypto_gcm_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct gcm_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nstruct crypto_gcm_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_ablkcipher *ctr;\r\nstruct crypto_ahash *ghash;\r\nunsigned long align;\r\nint err;\r\nghash = crypto_spawn_ahash(&ictx->ghash);\r\nif (IS_ERR(ghash))\r\nreturn PTR_ERR(ghash);\r\nctr = crypto_spawn_skcipher(&ictx->ctr);\r\nerr = PTR_ERR(ctr);\r\nif (IS_ERR(ctr))\r\ngoto err_free_hash;\r\nctx->ctr = ctr;\r\nctx->ghash = ghash;\r\nalign = crypto_tfm_alg_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ntfm->crt_aead.reqsize = align +\r\noffsetof(struct crypto_gcm_req_priv_ctx, u) +\r\nmax(sizeof(struct ablkcipher_request) +\r\ncrypto_ablkcipher_reqsize(ctr),\r\nsizeof(struct ahash_request) +\r\ncrypto_ahash_reqsize(ghash));\r\nreturn 0;\r\nerr_free_hash:\r\ncrypto_free_ahash(ghash);\r\nreturn err;\r\n}\r\nstatic void crypto_gcm_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_gcm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_ahash(ctx->ghash);\r\ncrypto_free_ablkcipher(ctx->ctr);\r\n}\r\nstatic struct crypto_instance *crypto_gcm_alloc_common(struct rtattr **tb,\r\nconst char *full_name,\r\nconst char *ctr_name,\r\nconst char *ghash_name)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *ctr;\r\nstruct crypto_alg *ghash_alg;\r\nstruct ahash_alg *ghash_ahash_alg;\r\nstruct gcm_instance_ctx *ctx;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nerr = PTR_ERR(algt);\r\nif (IS_ERR(algt))\r\nreturn ERR_PTR(err);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nghash_alg = crypto_find_alg(ghash_name, &crypto_ahash_type,\r\nCRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK);\r\nerr = PTR_ERR(ghash_alg);\r\nif (IS_ERR(ghash_alg))\r\nreturn ERR_PTR(err);\r\nerr = -ENOMEM;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst)\r\ngoto out_put_ghash;\r\nctx = crypto_instance_ctx(inst);\r\nghash_ahash_alg = container_of(ghash_alg, struct ahash_alg, halg.base);\r\nerr = crypto_init_ahash_spawn(&ctx->ghash, &ghash_ahash_alg->halg,\r\ninst);\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ctx->ctr, inst);\r\nerr = crypto_grab_skcipher(&ctx->ctr, ctr_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_ghash;\r\nctr = crypto_skcipher_spawn_alg(&ctx->ctr);\r\nif (ctr->cra_ablkcipher.ivsize != 16)\r\ngoto out_put_ctr;\r\nerr = -EINVAL;\r\nif (ctr->cra_blocksize != 1)\r\ngoto out_put_ctr;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"gcm_base(%s,%s)", ctr->cra_driver_name,\r\nghash_alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_put_ctr;\r\nmemcpy(inst->alg.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\r\ninst->alg.cra_flags |= ctr->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = ctr->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = ctr->cra_alignmask | (__alignof__(u64) - 1);\r\ninst->alg.cra_type = &crypto_aead_type;\r\ninst->alg.cra_aead.ivsize = 16;\r\ninst->alg.cra_aead.maxauthsize = 16;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_gcm_ctx);\r\ninst->alg.cra_init = crypto_gcm_init_tfm;\r\ninst->alg.cra_exit = crypto_gcm_exit_tfm;\r\ninst->alg.cra_aead.setkey = crypto_gcm_setkey;\r\ninst->alg.cra_aead.setauthsize = crypto_gcm_setauthsize;\r\ninst->alg.cra_aead.encrypt = crypto_gcm_encrypt;\r\ninst->alg.cra_aead.decrypt = crypto_gcm_decrypt;\r\nout:\r\ncrypto_mod_put(ghash_alg);\r\nreturn inst;\r\nout_put_ctr:\r\ncrypto_drop_skcipher(&ctx->ctr);\r\nerr_drop_ghash:\r\ncrypto_drop_ahash(&ctx->ghash);\r\nerr_free_inst:\r\nkfree(inst);\r\nout_put_ghash:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic struct crypto_instance *crypto_gcm_alloc(struct rtattr **tb)\r\n{\r\nint err;\r\nconst char *cipher_name;\r\nchar ctr_name[CRYPTO_MAX_ALG_NAME];\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nerr = PTR_ERR(cipher_name);\r\nif (IS_ERR(cipher_name))\r\nreturn ERR_PTR(err);\r\nif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, "ctr(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "gcm(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nreturn crypto_gcm_alloc_common(tb, full_name, ctr_name, "ghash");\r\n}\r\nstatic void crypto_gcm_free(struct crypto_instance *inst)\r\n{\r\nstruct gcm_instance_ctx *ctx = crypto_instance_ctx(inst);\r\ncrypto_drop_skcipher(&ctx->ctr);\r\ncrypto_drop_ahash(&ctx->ghash);\r\nkfree(inst);\r\n}\r\nstatic struct crypto_instance *crypto_gcm_base_alloc(struct rtattr **tb)\r\n{\r\nint err;\r\nconst char *ctr_name;\r\nconst char *ghash_name;\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\nctr_name = crypto_attr_alg_name(tb[1]);\r\nerr = PTR_ERR(ctr_name);\r\nif (IS_ERR(ctr_name))\r\nreturn ERR_PTR(err);\r\nghash_name = crypto_attr_alg_name(tb[2]);\r\nerr = PTR_ERR(ghash_name);\r\nif (IS_ERR(ghash_name))\r\nreturn ERR_PTR(err);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "gcm_base(%s,%s)",\r\nctr_name, ghash_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nreturn crypto_gcm_alloc_common(tb, full_name, ctr_name, ghash_name);\r\n}\r\nstatic int crypto_rfc4106_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\nkeylen -= 4;\r\nmemcpy(ctx->nonce, key + keylen, 4);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4106_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);\r\nswitch (authsize) {\r\ncase 8:\r\ncase 12:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic struct aead_request *crypto_rfc4106_crypt(struct aead_request *req)\r\n{\r\nstruct aead_request *subreq = aead_request_ctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_aead *child = ctx->child;\r\nu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\r\ncrypto_aead_alignmask(child) + 1);\r\nmemcpy(iv, ctx->nonce, 4);\r\nmemcpy(iv + 4, req->iv, 8);\r\naead_request_set_tfm(subreq, child);\r\naead_request_set_callback(subreq, req->base.flags, req->base.complete,\r\nreq->base.data);\r\naead_request_set_crypt(subreq, req->src, req->dst, req->cryptlen, iv);\r\naead_request_set_assoc(subreq, req->assoc, req->assoclen);\r\nreturn subreq;\r\n}\r\nstatic int crypto_rfc4106_encrypt(struct aead_request *req)\r\n{\r\nreq = crypto_rfc4106_crypt(req);\r\nreturn crypto_aead_encrypt(req);\r\n}\r\nstatic int crypto_rfc4106_decrypt(struct aead_request *req)\r\n{\r\nreq = crypto_rfc4106_crypt(req);\r\nreturn crypto_aead_decrypt(req);\r\n}\r\nstatic int crypto_rfc4106_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_aead_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_rfc4106_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nunsigned long align;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nctx->child = aead;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ntfm->crt_aead.reqsize = sizeof(struct aead_request) +\r\nALIGN(crypto_aead_reqsize(aead),\r\ncrypto_tfm_ctx_alignment()) +\r\nalign + 16;\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc4106_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_rfc4106_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_rfc4106_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct crypto_alg *alg;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nerr = PTR_ERR(algt);\r\nif (IS_ERR(algt))\r\nreturn ERR_PTR(err);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nerr = PTR_ERR(ccm_name);\r\nif (IS_ERR(ccm_name))\r\nreturn ERR_PTR(err);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn ERR_PTR(-ENOMEM);\r\nspawn = crypto_instance_ctx(inst);\r\ncrypto_set_aead_spawn(spawn, inst);\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_aead_spawn_alg(spawn);\r\nerr = -EINVAL;\r\nif (alg->cra_aead.ivsize != 16)\r\ngoto out_drop_alg;\r\nif (alg->cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4106(%s)", alg->cra_name) >= CRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4106(%s)", alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\r\ninst->alg.cra_flags |= alg->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_nivaead_type;\r\ninst->alg.cra_aead.ivsize = 8;\r\ninst->alg.cra_aead.maxauthsize = 16;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_rfc4106_ctx);\r\ninst->alg.cra_init = crypto_rfc4106_init_tfm;\r\ninst->alg.cra_exit = crypto_rfc4106_exit_tfm;\r\ninst->alg.cra_aead.setkey = crypto_rfc4106_setkey;\r\ninst->alg.cra_aead.setauthsize = crypto_rfc4106_setauthsize;\r\ninst->alg.cra_aead.encrypt = crypto_rfc4106_encrypt;\r\ninst->alg.cra_aead.decrypt = crypto_rfc4106_decrypt;\r\ninst->alg.cra_aead.geniv = "seqiv";\r\nout:\r\nreturn inst;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_rfc4106_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic inline struct crypto_rfc4543_req_ctx *crypto_rfc4543_reqctx(\r\nstruct aead_request *req)\r\n{\r\nunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\r\nreturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\r\n}\r\nstatic int crypto_rfc4543_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\nkeylen -= 4;\r\nmemcpy(ctx->nonce, key + keylen, 4);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4543_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);\r\nif (authsize != 16)\r\nreturn -EINVAL;\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic struct aead_request *crypto_rfc4543_crypt(struct aead_request *req,\r\nint enc)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_rfc4543_req_ctx *rctx = crypto_rfc4543_reqctx(req);\r\nstruct aead_request *subreq = &rctx->subreq;\r\nstruct scatterlist *dst = req->dst;\r\nstruct scatterlist *cipher = rctx->cipher;\r\nstruct scatterlist *payload = rctx->payload;\r\nstruct scatterlist *assoc = rctx->assoc;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int assoclen = req->assoclen;\r\nstruct page *dstp;\r\nu8 *vdst;\r\nu8 *iv = PTR_ALIGN((u8 *)(rctx + 1) + crypto_aead_reqsize(ctx->child),\r\ncrypto_aead_alignmask(ctx->child) + 1);\r\nmemcpy(iv, ctx->nonce, 4);\r\nmemcpy(iv + 4, req->iv, 8);\r\nif (enc)\r\nmemset(rctx->auth_tag, 0, authsize);\r\nelse\r\nscatterwalk_map_and_copy(rctx->auth_tag, dst,\r\nreq->cryptlen - authsize,\r\nauthsize, 0);\r\nsg_init_one(cipher, rctx->auth_tag, authsize);\r\ndstp = sg_page(dst);\r\nvdst = PageHighMem(dstp) ? NULL : page_address(dstp) + dst->offset;\r\nsg_init_table(payload, 2);\r\nsg_set_buf(payload, req->iv, 8);\r\nscatterwalk_crypto_chain(payload, dst, vdst == req->iv + 8, 2);\r\nassoclen += 8 + req->cryptlen - (enc ? 0 : authsize);\r\nsg_init_table(assoc, 2);\r\nsg_set_page(assoc, sg_page(req->assoc), req->assoc->length,\r\nreq->assoc->offset);\r\nscatterwalk_crypto_chain(assoc, payload, 0, 2);\r\naead_request_set_tfm(subreq, ctx->child);\r\naead_request_set_callback(subreq, req->base.flags, req->base.complete,\r\nreq->base.data);\r\naead_request_set_crypt(subreq, cipher, cipher, enc ? 0 : authsize, iv);\r\naead_request_set_assoc(subreq, assoc, assoclen);\r\nreturn subreq;\r\n}\r\nstatic int crypto_rfc4543_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4543_req_ctx *rctx = crypto_rfc4543_reqctx(req);\r\nstruct aead_request *subreq;\r\nint err;\r\nsubreq = crypto_rfc4543_crypt(req, 1);\r\nerr = crypto_aead_encrypt(subreq);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(rctx->auth_tag, req->dst, req->cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\nreturn 0;\r\n}\r\nstatic int crypto_rfc4543_decrypt(struct aead_request *req)\r\n{\r\nreq = crypto_rfc4543_crypt(req, 0);\r\nreturn crypto_aead_decrypt(req);\r\n}\r\nstatic int crypto_rfc4543_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_aead_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_rfc4543_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nunsigned long align;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nctx->child = aead;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ntfm->crt_aead.reqsize = sizeof(struct crypto_rfc4543_req_ctx) +\r\nALIGN(crypto_aead_reqsize(aead),\r\ncrypto_tfm_ctx_alignment()) +\r\nalign + 16;\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc4543_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_rfc4543_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_rfc4543_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct crypto_alg *alg;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nerr = PTR_ERR(algt);\r\nif (IS_ERR(algt))\r\nreturn ERR_PTR(err);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nerr = PTR_ERR(ccm_name);\r\nif (IS_ERR(ccm_name))\r\nreturn ERR_PTR(err);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn ERR_PTR(-ENOMEM);\r\nspawn = crypto_instance_ctx(inst);\r\ncrypto_set_aead_spawn(spawn, inst);\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_aead_spawn_alg(spawn);\r\nerr = -EINVAL;\r\nif (alg->cra_aead.ivsize != 16)\r\ngoto out_drop_alg;\r\nif (alg->cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4543(%s)", alg->cra_name) >= CRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4543(%s)", alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\r\ninst->alg.cra_flags |= alg->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_nivaead_type;\r\ninst->alg.cra_aead.ivsize = 8;\r\ninst->alg.cra_aead.maxauthsize = 16;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_rfc4543_ctx);\r\ninst->alg.cra_init = crypto_rfc4543_init_tfm;\r\ninst->alg.cra_exit = crypto_rfc4543_exit_tfm;\r\ninst->alg.cra_aead.setkey = crypto_rfc4543_setkey;\r\ninst->alg.cra_aead.setauthsize = crypto_rfc4543_setauthsize;\r\ninst->alg.cra_aead.encrypt = crypto_rfc4543_encrypt;\r\ninst->alg.cra_aead.decrypt = crypto_rfc4543_decrypt;\r\ninst->alg.cra_aead.geniv = "seqiv";\r\nout:\r\nreturn inst;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_rfc4543_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_gcm_module_init(void)\r\n{\r\nint err;\r\ngcm_zeroes = kzalloc(16, GFP_KERNEL);\r\nif (!gcm_zeroes)\r\nreturn -ENOMEM;\r\nerr = crypto_register_template(&crypto_gcm_base_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_gcm_tmpl);\r\nif (err)\r\ngoto out_undo_base;\r\nerr = crypto_register_template(&crypto_rfc4106_tmpl);\r\nif (err)\r\ngoto out_undo_gcm;\r\nerr = crypto_register_template(&crypto_rfc4543_tmpl);\r\nif (err)\r\ngoto out_undo_rfc4106;\r\nreturn 0;\r\nout_undo_rfc4106:\r\ncrypto_unregister_template(&crypto_rfc4106_tmpl);\r\nout_undo_gcm:\r\ncrypto_unregister_template(&crypto_gcm_tmpl);\r\nout_undo_base:\r\ncrypto_unregister_template(&crypto_gcm_base_tmpl);\r\nout:\r\nkfree(gcm_zeroes);\r\nreturn err;\r\n}\r\nstatic void __exit crypto_gcm_module_exit(void)\r\n{\r\nkfree(gcm_zeroes);\r\ncrypto_unregister_template(&crypto_rfc4543_tmpl);\r\ncrypto_unregister_template(&crypto_rfc4106_tmpl);\r\ncrypto_unregister_template(&crypto_gcm_tmpl);\r\ncrypto_unregister_template(&crypto_gcm_base_tmpl);\r\n}
