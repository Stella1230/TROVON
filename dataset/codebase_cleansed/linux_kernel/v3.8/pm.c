static void realmode_switch_hook(void)\r\n{\r\nif (boot_params.hdr.realmode_swtch) {\r\nasm volatile("lcallw *%0"\r\n: : "m" (boot_params.hdr.realmode_swtch)\r\n: "eax", "ebx", "ecx", "edx");\r\n} else {\r\nasm volatile("cli");\r\noutb(0x80, 0x70);\r\nio_delay();\r\n}\r\n}\r\nstatic void mask_all_interrupts(void)\r\n{\r\noutb(0xff, 0xa1);\r\nio_delay();\r\noutb(0xfb, 0x21);\r\nio_delay();\r\n}\r\nstatic void reset_coprocessor(void)\r\n{\r\noutb(0, 0xf0);\r\nio_delay();\r\noutb(0, 0xf1);\r\nio_delay();\r\n}\r\nstatic void setup_gdt(void)\r\n{\r\nstatic const u64 boot_gdt[] __attribute__((aligned(16))) = {\r\n[GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff),\r\n[GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff),\r\n[GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103),\r\n};\r\nstatic struct gdt_ptr gdt;\r\ngdt.len = sizeof(boot_gdt)-1;\r\ngdt.ptr = (u32)&boot_gdt + (ds() << 4);\r\nasm volatile("lgdtl %0" : : "m" (gdt));\r\n}\r\nstatic void setup_idt(void)\r\n{\r\nstatic const struct gdt_ptr null_idt = {0, 0};\r\nasm volatile("lidtl %0" : : "m" (null_idt));\r\n}\r\nvoid go_to_protected_mode(void)\r\n{\r\nrealmode_switch_hook();\r\nif (enable_a20()) {\r\nputs("A20 gate not responding, unable to boot...\n");\r\ndie();\r\n}\r\nreset_coprocessor();\r\nmask_all_interrupts();\r\nsetup_idt();\r\nsetup_gdt();\r\nprotected_mode_jump(boot_params.hdr.code32_start,\r\n(u32)&boot_params + (ds() << 4));\r\n}
