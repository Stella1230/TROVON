static enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)\r\n{\r\nstruct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx, tmr);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nctx->expired = 1;\r\nctx->ticks++;\r\nwake_up_locked(&ctx->wqh);\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nvoid timerfd_clock_was_set(void)\r\n{\r\nktime_t moffs = ktime_get_monotonic_offset();\r\nstruct timerfd_ctx *ctx;\r\nunsigned long flags;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ctx, &cancel_list, clist) {\r\nif (!ctx->might_cancel)\r\ncontinue;\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nif (ctx->moffs.tv64 != moffs.tv64) {\r\nctx->moffs.tv64 = KTIME_MAX;\r\nctx->ticks++;\r\nwake_up_locked(&ctx->wqh);\r\n}\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void timerfd_remove_cancel(struct timerfd_ctx *ctx)\r\n{\r\nif (ctx->might_cancel) {\r\nctx->might_cancel = false;\r\nspin_lock(&cancel_lock);\r\nlist_del_rcu(&ctx->clist);\r\nspin_unlock(&cancel_lock);\r\n}\r\n}\r\nstatic bool timerfd_canceled(struct timerfd_ctx *ctx)\r\n{\r\nif (!ctx->might_cancel || ctx->moffs.tv64 != KTIME_MAX)\r\nreturn false;\r\nctx->moffs = ktime_get_monotonic_offset();\r\nreturn true;\r\n}\r\nstatic void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\r\n{\r\nif (ctx->clockid == CLOCK_REALTIME && (flags & TFD_TIMER_ABSTIME) &&\r\n(flags & TFD_TIMER_CANCEL_ON_SET)) {\r\nif (!ctx->might_cancel) {\r\nctx->might_cancel = true;\r\nspin_lock(&cancel_lock);\r\nlist_add_rcu(&ctx->clist, &cancel_list);\r\nspin_unlock(&cancel_lock);\r\n}\r\n} else if (ctx->might_cancel) {\r\ntimerfd_remove_cancel(ctx);\r\n}\r\n}\r\nstatic ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)\r\n{\r\nktime_t remaining;\r\nremaining = hrtimer_expires_remaining(&ctx->tmr);\r\nreturn remaining.tv64 < 0 ? ktime_set(0, 0): remaining;\r\n}\r\nstatic int timerfd_setup(struct timerfd_ctx *ctx, int flags,\r\nconst struct itimerspec *ktmr)\r\n{\r\nenum hrtimer_mode htmode;\r\nktime_t texp;\r\nint clockid = ctx->clockid;\r\nhtmode = (flags & TFD_TIMER_ABSTIME) ?\r\nHRTIMER_MODE_ABS: HRTIMER_MODE_REL;\r\ntexp = timespec_to_ktime(ktmr->it_value);\r\nctx->expired = 0;\r\nctx->ticks = 0;\r\nctx->tintv = timespec_to_ktime(ktmr->it_interval);\r\nhrtimer_init(&ctx->tmr, clockid, htmode);\r\nhrtimer_set_expires(&ctx->tmr, texp);\r\nctx->tmr.function = timerfd_tmrproc;\r\nif (texp.tv64 != 0) {\r\nhrtimer_start(&ctx->tmr, texp, htmode);\r\nif (timerfd_canceled(ctx))\r\nreturn -ECANCELED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int timerfd_release(struct inode *inode, struct file *file)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\ntimerfd_remove_cancel(ctx);\r\nhrtimer_cancel(&ctx->tmr);\r\nkfree_rcu(ctx, rcu);\r\nreturn 0;\r\n}\r\nstatic unsigned int timerfd_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\nunsigned int events = 0;\r\nunsigned long flags;\r\npoll_wait(file, &ctx->wqh, wait);\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nif (ctx->ticks)\r\nevents |= POLLIN;\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\nreturn events;\r\n}\r\nstatic ssize_t timerfd_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct timerfd_ctx *ctx = file->private_data;\r\nssize_t res;\r\nu64 ticks = 0;\r\nif (count < sizeof(ticks))\r\nreturn -EINVAL;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nif (file->f_flags & O_NONBLOCK)\r\nres = -EAGAIN;\r\nelse\r\nres = wait_event_interruptible_locked_irq(ctx->wqh, ctx->ticks);\r\nif (timerfd_canceled(ctx)) {\r\nctx->ticks = 0;\r\nctx->expired = 0;\r\nres = -ECANCELED;\r\n}\r\nif (ctx->ticks) {\r\nticks = ctx->ticks;\r\nif (ctx->expired && ctx->tintv.tv64) {\r\nticks += hrtimer_forward_now(&ctx->tmr,\r\nctx->tintv) - 1;\r\nhrtimer_restart(&ctx->tmr);\r\n}\r\nctx->expired = 0;\r\nctx->ticks = 0;\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nif (ticks)\r\nres = put_user(ticks, (u64 __user *) buf) ? -EFAULT: sizeof(ticks);\r\nreturn res;\r\n}\r\nstatic int timerfd_fget(int fd, struct fd *p)\r\n{\r\nstruct fd f = fdget(fd);\r\nif (!f.file)\r\nreturn -EBADF;\r\nif (f.file->f_op != &timerfd_fops) {\r\nfdput(f);\r\nreturn -EINVAL;\r\n}\r\n*p = f;\r\nreturn 0;\r\n}
