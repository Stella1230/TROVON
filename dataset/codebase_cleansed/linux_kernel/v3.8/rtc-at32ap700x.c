static int at32_rtc_readtime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rtc_at32ap700x *rtc = dev_get_drvdata(dev);\r\nunsigned long now;\r\nnow = rtc_readl(rtc, VAL);\r\nrtc_time_to_tm(now, tm);\r\nreturn 0;\r\n}\r\nstatic int at32_rtc_settime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rtc_at32ap700x *rtc = dev_get_drvdata(dev);\r\nunsigned long now;\r\nint ret;\r\nret = rtc_tm_to_time(tm, &now);\r\nif (ret == 0)\r\nrtc_writel(rtc, VAL, now);\r\nreturn ret;\r\n}\r\nstatic int at32_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct rtc_at32ap700x *rtc = dev_get_drvdata(dev);\r\nspin_lock_irq(&rtc->lock);\r\nrtc_time_to_tm(rtc->alarm_time, &alrm->time);\r\nalrm->enabled = rtc_readl(rtc, IMR) & RTC_BIT(IMR_TOPI) ? 1 : 0;\r\nalrm->pending = rtc_readl(rtc, ISR) & RTC_BIT(ISR_TOPI) ? 1 : 0;\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int at32_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct rtc_at32ap700x *rtc = dev_get_drvdata(dev);\r\nunsigned long rtc_unix_time;\r\nunsigned long alarm_unix_time;\r\nint ret;\r\nrtc_unix_time = rtc_readl(rtc, VAL);\r\nret = rtc_tm_to_time(&alrm->time, &alarm_unix_time);\r\nif (ret)\r\nreturn ret;\r\nif (alarm_unix_time < rtc_unix_time)\r\nreturn -EINVAL;\r\nspin_lock_irq(&rtc->lock);\r\nrtc->alarm_time = alarm_unix_time;\r\nrtc_writel(rtc, TOP, rtc->alarm_time);\r\nif (alrm->enabled)\r\nrtc_writel(rtc, CTRL, rtc_readl(rtc, CTRL)\r\n| RTC_BIT(CTRL_TOPEN));\r\nelse\r\nrtc_writel(rtc, CTRL, rtc_readl(rtc, CTRL)\r\n& ~RTC_BIT(CTRL_TOPEN));\r\nspin_unlock_irq(&rtc->lock);\r\nreturn ret;\r\n}\r\nstatic int at32_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct rtc_at32ap700x *rtc = dev_get_drvdata(dev);\r\nint ret = 0;\r\nspin_lock_irq(&rtc->lock);\r\nif(enabled) {\r\nif (rtc_readl(rtc, VAL) > rtc->alarm_time) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nrtc_writel(rtc, CTRL, rtc_readl(rtc, CTRL)\r\n| RTC_BIT(CTRL_TOPEN));\r\nrtc_writel(rtc, ICR, RTC_BIT(ICR_TOPI));\r\nrtc_writel(rtc, IER, RTC_BIT(IER_TOPI));\r\n} else {\r\nrtc_writel(rtc, CTRL, rtc_readl(rtc, CTRL)\r\n& ~RTC_BIT(CTRL_TOPEN));\r\nrtc_writel(rtc, IDR, RTC_BIT(IDR_TOPI));\r\nrtc_writel(rtc, ICR, RTC_BIT(ICR_TOPI));\r\n}\r\nout:\r\nspin_unlock_irq(&rtc->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t at32_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rtc_at32ap700x *rtc = (struct rtc_at32ap700x *)dev_id;\r\nunsigned long isr = rtc_readl(rtc, ISR);\r\nunsigned long events = 0;\r\nint ret = IRQ_NONE;\r\nspin_lock(&rtc->lock);\r\nif (isr & RTC_BIT(ISR_TOPI)) {\r\nrtc_writel(rtc, ICR, RTC_BIT(ICR_TOPI));\r\nrtc_writel(rtc, IDR, RTC_BIT(IDR_TOPI));\r\nrtc_writel(rtc, CTRL, rtc_readl(rtc, CTRL)\r\n& ~RTC_BIT(CTRL_TOPEN));\r\nrtc_writel(rtc, VAL, rtc->alarm_time);\r\nevents = RTC_AF | RTC_IRQF;\r\nrtc_update_irq(rtc->rtc, 1, events);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock(&rtc->lock);\r\nreturn ret;\r\n}\r\nstatic int __init at32_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nstruct rtc_at32ap700x *rtc;\r\nint irq;\r\nint ret;\r\nrtc = kzalloc(sizeof(struct rtc_at32ap700x), GFP_KERNEL);\r\nif (!rtc) {\r\ndev_dbg(&pdev->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_dbg(&pdev->dev, "no mmio resource defined\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_dbg(&pdev->dev, "could not get irq\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nrtc->irq = irq;\r\nrtc->regs = ioremap(regs->start, resource_size(regs));\r\nif (!rtc->regs) {\r\nret = -ENOMEM;\r\ndev_dbg(&pdev->dev, "could not map I/O memory\n");\r\ngoto out;\r\n}\r\nspin_lock_init(&rtc->lock);\r\nif (!(rtc_readl(rtc, CTRL) & RTC_BIT(CTRL_EN))) {\r\nrtc_writel(rtc, CTRL, RTC_BIT(CTRL_PCLR));\r\nrtc_writel(rtc, IDR, RTC_BIT(IDR_TOPI));\r\nrtc_writel(rtc, CTRL, RTC_BF(CTRL_PSEL, 0xe)\r\n| RTC_BIT(CTRL_EN));\r\n}\r\nret = request_irq(irq, at32_rtc_interrupt, IRQF_SHARED, "rtc", rtc);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "could not request irq %d\n", irq);\r\ngoto out_iounmap;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->rtc = rtc_device_register(pdev->name, &pdev->dev,\r\n&at32_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\ndev_dbg(&pdev->dev, "could not register rtc device\n");\r\nret = PTR_ERR(rtc->rtc);\r\ngoto out_free_irq;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\ndev_info(&pdev->dev, "Atmel RTC for AT32AP700x at %08lx irq %ld\n",\r\n(unsigned long)rtc->regs, rtc->irq);\r\nreturn 0;\r\nout_free_irq:\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(irq, rtc);\r\nout_iounmap:\r\niounmap(rtc->regs);\r\nout:\r\nkfree(rtc);\r\nreturn ret;\r\n}\r\nstatic int __exit at32_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_at32ap700x *rtc = platform_get_drvdata(pdev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nfree_irq(rtc->irq, rtc);\r\niounmap(rtc->regs);\r\nrtc_device_unregister(rtc->rtc);\r\nkfree(rtc);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init at32_rtc_init(void)\r\n{\r\nreturn platform_driver_probe(&at32_rtc_driver, at32_rtc_probe);\r\n}\r\nstatic void __exit at32_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&at32_rtc_driver);\r\n}
