static inline struct saa711x_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa711x_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct saa711x_state, hdl)->sd;\r\n}\r\nstatic inline int saa711x_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int saa711x_has_reg(const int id, const u8 reg)\r\n{\r\nif (id == V4L2_IDENT_SAA7111)\r\nreturn reg < 0x20 && reg != 0x01 && reg != 0x0f &&\r\n(reg < 0x13 || reg > 0x19) && reg != 0x1d && reg != 0x1e;\r\nif (id == V4L2_IDENT_SAA7111A)\r\nreturn reg < 0x20 && reg != 0x01 && reg != 0x0f &&\r\nreg != 0x14 && reg != 0x18 && reg != 0x19 &&\r\nreg != 0x1d && reg != 0x1e;\r\nif (unlikely((reg >= 0x3b && reg <= 0x3f) || reg == 0x5c || reg == 0x5f ||\r\nreg == 0xa3 || reg == 0xa7 || reg == 0xab || reg == 0xaf || (reg >= 0xb5 && reg <= 0xb7) ||\r\nreg == 0xd3 || reg == 0xd7 || reg == 0xdb || reg == 0xdf || (reg >= 0xe5 && reg <= 0xe7) ||\r\nreg == 0x82 || (reg >= 0x89 && reg <= 0x8e)))\r\nreturn 0;\r\nswitch (id) {\r\ncase V4L2_IDENT_SAA7113:\r\nreturn reg != 0x14 && (reg < 0x18 || reg > 0x1e) && (reg < 0x20 || reg > 0x3f) &&\r\nreg != 0x5d && reg < 0x63;\r\ncase V4L2_IDENT_SAA7114:\r\nreturn (reg < 0x1a || reg > 0x1e) && (reg < 0x20 || reg > 0x2f) &&\r\n(reg < 0x63 || reg > 0x7f) && reg != 0x33 && reg != 0x37 &&\r\nreg != 0x81 && reg < 0xf0;\r\ncase V4L2_IDENT_SAA7115:\r\nreturn (reg < 0x20 || reg > 0x2f) && reg != 0x65 && (reg < 0xfc || reg > 0xfe);\r\ncase V4L2_IDENT_SAA7118:\r\nreturn (reg < 0x1a || reg > 0x1d) && (reg < 0x20 || reg > 0x22) &&\r\n(reg < 0x26 || reg > 0x28) && reg != 0x33 && reg != 0x37 &&\r\n(reg < 0x63 || reg > 0x7f) && reg != 0x81 && reg < 0xf0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int saa711x_writeregs(struct v4l2_subdev *sd, const unsigned char *regs)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nunsigned char reg, data;\r\nwhile (*regs != 0x00) {\r\nreg = *(regs++);\r\ndata = *(regs++);\r\nif (saa711x_has_reg(state->ident, reg)) {\r\nif (saa711x_write(sd, reg, data) < 0)\r\nreturn -1;\r\n} else {\r\nv4l2_dbg(1, debug, sd, "tried to access reserved reg 0x%02x\n", reg);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int saa711x_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int saa711x_odd_parity(u8 c)\r\n{\r\nc ^= (c >> 4);\r\nc ^= (c >> 2);\r\nc ^= (c >> 1);\r\nreturn c & 1;\r\n}\r\nstatic int saa711x_decode_vps(u8 *dst, u8 *p)\r\n{\r\nstatic const u8 biphase_tbl[] = {\r\n0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\r\n0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\r\n0xd2, 0x5a, 0x52, 0xd2, 0x96, 0x1e, 0x16, 0x96,\r\n0x92, 0x1a, 0x12, 0x92, 0xd2, 0x5a, 0x52, 0xd2,\r\n0xd0, 0x58, 0x50, 0xd0, 0x94, 0x1c, 0x14, 0x94,\r\n0x90, 0x18, 0x10, 0x90, 0xd0, 0x58, 0x50, 0xd0,\r\n0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\r\n0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\r\n0xe1, 0x69, 0x61, 0xe1, 0xa5, 0x2d, 0x25, 0xa5,\r\n0xa1, 0x29, 0x21, 0xa1, 0xe1, 0x69, 0x61, 0xe1,\r\n0xc3, 0x4b, 0x43, 0xc3, 0x87, 0x0f, 0x07, 0x87,\r\n0x83, 0x0b, 0x03, 0x83, 0xc3, 0x4b, 0x43, 0xc3,\r\n0xc1, 0x49, 0x41, 0xc1, 0x85, 0x0d, 0x05, 0x85,\r\n0x81, 0x09, 0x01, 0x81, 0xc1, 0x49, 0x41, 0xc1,\r\n0xe1, 0x69, 0x61, 0xe1, 0xa5, 0x2d, 0x25, 0xa5,\r\n0xa1, 0x29, 0x21, 0xa1, 0xe1, 0x69, 0x61, 0xe1,\r\n0xe0, 0x68, 0x60, 0xe0, 0xa4, 0x2c, 0x24, 0xa4,\r\n0xa0, 0x28, 0x20, 0xa0, 0xe0, 0x68, 0x60, 0xe0,\r\n0xc2, 0x4a, 0x42, 0xc2, 0x86, 0x0e, 0x06, 0x86,\r\n0x82, 0x0a, 0x02, 0x82, 0xc2, 0x4a, 0x42, 0xc2,\r\n0xc0, 0x48, 0x40, 0xc0, 0x84, 0x0c, 0x04, 0x84,\r\n0x80, 0x08, 0x00, 0x80, 0xc0, 0x48, 0x40, 0xc0,\r\n0xe0, 0x68, 0x60, 0xe0, 0xa4, 0x2c, 0x24, 0xa4,\r\n0xa0, 0x28, 0x20, 0xa0, 0xe0, 0x68, 0x60, 0xe0,\r\n0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\r\n0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\r\n0xd2, 0x5a, 0x52, 0xd2, 0x96, 0x1e, 0x16, 0x96,\r\n0x92, 0x1a, 0x12, 0x92, 0xd2, 0x5a, 0x52, 0xd2,\r\n0xd0, 0x58, 0x50, 0xd0, 0x94, 0x1c, 0x14, 0x94,\r\n0x90, 0x18, 0x10, 0x90, 0xd0, 0x58, 0x50, 0xd0,\r\n0xf0, 0x78, 0x70, 0xf0, 0xb4, 0x3c, 0x34, 0xb4,\r\n0xb0, 0x38, 0x30, 0xb0, 0xf0, 0x78, 0x70, 0xf0,\r\n};\r\nint i;\r\nu8 c, err = 0;\r\nfor (i = 0; i < 2 * 13; i += 2) {\r\nerr |= biphase_tbl[p[i]] | biphase_tbl[p[i + 1]];\r\nc = (biphase_tbl[p[i + 1]] & 0xf) | ((biphase_tbl[p[i]] & 0xf) << 4);\r\ndst[i / 2] = c;\r\n}\r\nreturn err & 0xf0;\r\n}\r\nstatic int saa711x_decode_wss(u8 *p)\r\n{\r\nstatic const int wss_bits[8] = {\r\n0, 0, 0, 1, 0, 1, 1, 1\r\n};\r\nunsigned char parity;\r\nint wss = 0;\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nint b1 = wss_bits[p[i] & 7];\r\nint b2 = wss_bits[(p[i] >> 3) & 7];\r\nif (b1 == b2)\r\nreturn -1;\r\nwss |= b2 << i;\r\n}\r\nparity = wss & 15;\r\nparity ^= parity >> 2;\r\nparity ^= parity >> 1;\r\nif (!(parity & 1))\r\nreturn -1;\r\nreturn wss;\r\n}\r\nstatic int saa711x_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nu32 acpf;\r\nu32 acni;\r\nu32 hz;\r\nu64 f;\r\nu8 acc = 0;\r\nif (!saa711x_has_reg(state->ident, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD))\r\nreturn 0;\r\nv4l2_dbg(1, debug, sd, "set audio clock freq: %d\n", freq);\r\nif (freq < 32000 || freq > 48000)\r\nreturn -EINVAL;\r\nhz = (state->std & V4L2_STD_525_60) ? 5994 : 5000;\r\nacpf = (25600 * freq) / hz;\r\nf = freq;\r\nf = f << 31;\r\ndo_div(f, state->crystal_freq);\r\nacni = f;\r\nif (state->ucgc) {\r\nacpf = acpf * state->cgcdiv / 16;\r\nacni = acni * state->cgcdiv / 16;\r\nacc = 0x80;\r\nif (state->cgcdiv == 3)\r\nacc |= 0x40;\r\n}\r\nif (state->apll)\r\nacc |= 0x08;\r\nsaa711x_write(sd, R_38_CLK_RATIO_AMXCLK_TO_ASCLK, 0x03);\r\nsaa711x_write(sd, R_39_CLK_RATIO_ASCLK_TO_ALRCLK, 0x10);\r\nsaa711x_write(sd, R_3A_AUD_CLK_GEN_BASIC_SETUP, acc);\r\nsaa711x_write(sd, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD, acpf & 0xff);\r\nsaa711x_write(sd, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD+1,\r\n(acpf >> 8) & 0xff);\r\nsaa711x_write(sd, R_30_AUD_MAST_CLK_CYCLES_PER_FIELD+2,\r\n(acpf >> 16) & 0x03);\r\nsaa711x_write(sd, R_34_AUD_MAST_CLK_NOMINAL_INC, acni & 0xff);\r\nsaa711x_write(sd, R_34_AUD_MAST_CLK_NOMINAL_INC+1, (acni >> 8) & 0xff);\r\nsaa711x_write(sd, R_34_AUD_MAST_CLK_NOMINAL_INC+2, (acni >> 16) & 0x3f);\r\nstate->audclk_freq = freq;\r\nreturn 0;\r\n}\r\nstatic int saa711x_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct saa711x_state *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_CHROMA_AGC:\r\nif (state->agc->val)\r\nstate->gain->val =\r\nsaa711x_read(sd, R_0F_CHROMA_GAIN_CNTL) & 0x7f;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct saa711x_state *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsaa711x_write(sd, R_0A_LUMA_BRIGHT_CNTL, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsaa711x_write(sd, R_0B_LUMA_CONTRAST_CNTL, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsaa711x_write(sd, R_0C_CHROMA_SAT_CNTL, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nsaa711x_write(sd, R_0D_CHROMA_HUE_CNTL, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CHROMA_AGC:\r\nif (state->agc->val)\r\nsaa711x_write(sd, R_0F_CHROMA_GAIN_CNTL, state->gain->val);\r\nelse\r\nsaa711x_write(sd, R_0F_CHROMA_GAIN_CNTL, state->gain->val | 0x80);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa711x_set_size(struct v4l2_subdev *sd, int width, int height)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nint HPSC, HFSC;\r\nint VSCY;\r\nint res;\r\nint is_50hz = state->std & V4L2_STD_625_50;\r\nint Vsrc = is_50hz ? 576 : 480;\r\nv4l2_dbg(1, debug, sd, "decoder set size to %ix%i\n", width, height);\r\nif ((width < 1) || (width > 1440))\r\nreturn -EINVAL;\r\nif ((height < 1) || (height > Vsrc))\r\nreturn -EINVAL;\r\nif (!saa711x_has_reg(state->ident, R_D0_B_HORIZ_PRESCALING)) {\r\nif (width != 720)\r\nreturn -EINVAL;\r\nif (height != Vsrc)\r\nreturn -EINVAL;\r\n}\r\nstate->width = width;\r\nstate->height = height;\r\nif (!saa711x_has_reg(state->ident, R_CC_B_HORIZ_OUTPUT_WINDOW_LENGTH))\r\nreturn 0;\r\nsaa711x_write(sd, R_CC_B_HORIZ_OUTPUT_WINDOW_LENGTH,\r\n(u8) (width & 0xff));\r\nsaa711x_write(sd, R_CD_B_HORIZ_OUTPUT_WINDOW_LENGTH_MSB,\r\n(u8) ((width >> 8) & 0xff));\r\nres = height / 2;\r\nif (!is_50hz)\r\nres += (VRES_60HZ - 480) >> 1;\r\nsaa711x_write(sd, R_CE_B_VERT_OUTPUT_WINDOW_LENGTH,\r\n(u8) (res & 0xff));\r\nsaa711x_write(sd, R_CF_B_VERT_OUTPUT_WINDOW_LENGTH_MSB,\r\n(u8) ((res >> 8) & 0xff));\r\nHPSC = (int)(720 / width);\r\nHPSC = HPSC ? HPSC : 1;\r\nHFSC = (int)((1024 * 720) / (HPSC * width));\r\nsaa711x_write(sd, R_D0_B_HORIZ_PRESCALING,\r\n(u8) (HPSC & 0x3f));\r\nv4l2_dbg(1, debug, sd, "Hpsc: 0x%05x, Hfsc: 0x%05x\n", HPSC, HFSC);\r\nsaa711x_write(sd, R_D8_B_HORIZ_LUMA_SCALING_INC,\r\n(u8) (HFSC & 0xff));\r\nsaa711x_write(sd, R_D9_B_HORIZ_LUMA_SCALING_INC_MSB,\r\n(u8) ((HFSC >> 8) & 0xff));\r\nsaa711x_write(sd, R_DC_B_HORIZ_CHROMA_SCALING,\r\n(u8) ((HFSC >> 1) & 0xff));\r\nsaa711x_write(sd, R_DD_B_HORIZ_CHROMA_SCALING_MSB,\r\n(u8) ((HFSC >> 9) & 0xff));\r\nVSCY = (int)((1024 * Vsrc) / height);\r\nv4l2_dbg(1, debug, sd, "Vsrc: %d, Vscy: 0x%05x\n", Vsrc, VSCY);\r\nsaa711x_write(sd, R_D5_B_LUMA_CONTRAST_CNTL,\r\n(u8) (64 * 1024 / VSCY));\r\nsaa711x_write(sd, R_D6_B_CHROMA_SATURATION_CNTL,\r\n(u8) (64 * 1024 / VSCY));\r\nsaa711x_write(sd, R_E0_B_VERT_LUMA_SCALING_INC,\r\n(u8) (VSCY & 0xff));\r\nsaa711x_write(sd, R_E1_B_VERT_LUMA_SCALING_INC_MSB,\r\n(u8) ((VSCY >> 8) & 0xff));\r\nsaa711x_write(sd, R_E2_B_VERT_CHROMA_SCALING_INC,\r\n(u8) (VSCY & 0xff));\r\nsaa711x_write(sd, R_E3_B_VERT_CHROMA_SCALING_INC_MSB,\r\n(u8) ((VSCY >> 8) & 0xff));\r\nsaa711x_writeregs(sd, saa7115_cfg_reset_scaler);\r\nsaa711x_write(sd, R_80_GLOBAL_CNTL_1,\r\nsaa711x_read(sd, R_80_GLOBAL_CNTL_1) | 0x20);\r\nreturn 0;\r\n}\r\nstatic void saa711x_set_v4lstd(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nif (std == state->std)\r\nreturn;\r\nstate->std = std;\r\nif (std & V4L2_STD_525_60) {\r\nv4l2_dbg(1, debug, sd, "decoder set standard 60 Hz\n");\r\nsaa711x_writeregs(sd, saa7115_cfg_60hz_video);\r\nsaa711x_set_size(sd, 720, 480);\r\n} else {\r\nv4l2_dbg(1, debug, sd, "decoder set standard 50 Hz\n");\r\nsaa711x_writeregs(sd, saa7115_cfg_50hz_video);\r\nsaa711x_set_size(sd, 720, 576);\r\n}\r\nif (state->ident <= V4L2_IDENT_SAA7113) {\r\nu8 reg = saa711x_read(sd, R_0E_CHROMA_CNTL_1) & 0x8f;\r\nif (std == V4L2_STD_PAL_M) {\r\nreg |= 0x30;\r\n} else if (std == V4L2_STD_PAL_Nc) {\r\nreg |= 0x20;\r\n} else if (std == V4L2_STD_PAL_60) {\r\nreg |= 0x10;\r\n} else if (std == V4L2_STD_NTSC_M_JP) {\r\nreg |= 0x40;\r\n} else if (std & V4L2_STD_SECAM) {\r\nreg |= 0x50;\r\n}\r\nsaa711x_write(sd, R_0E_CHROMA_CNTL_1, reg);\r\n} else {\r\nint taskb = saa711x_read(sd, R_80_GLOBAL_CNTL_1) & 0x10;\r\nif (taskb && state->ident == V4L2_IDENT_SAA7114) {\r\nsaa711x_writeregs(sd, saa7115_cfg_vbi_on);\r\n}\r\nsaa711x_s_clock_freq(sd, state->audclk_freq);\r\n}\r\n}\r\nstatic void saa711x_set_lcr(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nint is_50hz = (state->std & V4L2_STD_625_50);\r\nu8 lcr[24];\r\nint i, x;\r\n#if 1\r\nif (!saa711x_has_reg(state->ident, R_41_LCR_BASE))\r\nreturn;\r\n#else\r\nif (state->ident != V4L2_IDENT_SAA7115)\r\nreturn;\r\n#endif\r\nfor (i = 0; i <= 23; i++)\r\nlcr[i] = 0xff;\r\nif (fmt == NULL) {\r\nif (is_50hz)\r\nfor (i = 6; i <= 23; i++)\r\nlcr[i] = 0xdd;\r\nelse\r\nfor (i = 10; i <= 21; i++)\r\nlcr[i] = 0xdd;\r\n} else {\r\nif (is_50hz) {\r\nfor (i = 0; i <= 5; i++)\r\nfmt->service_lines[0][i] =\r\nfmt->service_lines[1][i] = 0;\r\n}\r\nelse {\r\nfor (i = 0; i <= 9; i++)\r\nfmt->service_lines[0][i] =\r\nfmt->service_lines[1][i] = 0;\r\nfor (i = 22; i <= 23; i++)\r\nfmt->service_lines[0][i] =\r\nfmt->service_lines[1][i] = 0;\r\n}\r\nfor (i = 6; i <= 23; i++) {\r\nlcr[i] = 0;\r\nfor (x = 0; x <= 1; x++) {\r\nswitch (fmt->service_lines[1-x][i]) {\r\ncase 0:\r\nlcr[i] |= 0xf << (4 * x);\r\nbreak;\r\ncase V4L2_SLICED_TELETEXT_B:\r\nlcr[i] |= 1 << (4 * x);\r\nbreak;\r\ncase V4L2_SLICED_CAPTION_525:\r\nlcr[i] |= 4 << (4 * x);\r\nbreak;\r\ncase V4L2_SLICED_WSS_625:\r\nlcr[i] |= 5 << (4 * x);\r\nbreak;\r\ncase V4L2_SLICED_VPS:\r\nlcr[i] |= 7 << (4 * x);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 2; i <= 23; i++) {\r\nsaa711x_write(sd, i - 2 + R_41_LCR_BASE, lcr[i]);\r\n}\r\nsaa711x_writeregs(sd, fmt == NULL ?\r\nsaa7115_cfg_vbi_on :\r\nsaa7115_cfg_vbi_off);\r\n}\r\nstatic int saa711x_g_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *sliced)\r\n{\r\nstatic u16 lcr2vbi[] = {\r\n0, V4L2_SLICED_TELETEXT_B, 0,\r\n0, V4L2_SLICED_CAPTION_525,\r\nV4L2_SLICED_WSS_625, 0,\r\nV4L2_SLICED_VPS, 0, 0, 0, 0,\r\n0, 0, 0, 0\r\n};\r\nint i;\r\nmemset(sliced->service_lines, 0, sizeof(sliced->service_lines));\r\nsliced->service_set = 0;\r\nif (saa711x_read(sd, R_80_GLOBAL_CNTL_1) & 0x10)\r\nreturn 0;\r\nfor (i = 2; i <= 23; i++) {\r\nu8 v = saa711x_read(sd, i - 2 + R_41_LCR_BASE);\r\nsliced->service_lines[0][i] = lcr2vbi[v >> 4];\r\nsliced->service_lines[1][i] = lcr2vbi[v & 0xf];\r\nsliced->service_set |=\r\nsliced->service_lines[0][i] | sliced->service_lines[1][i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_raw_fmt(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt)\r\n{\r\nsaa711x_set_lcr(sd, NULL);\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_sliced_fmt(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt)\r\n{\r\nsaa711x_set_lcr(sd, fmt);\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)\r\n{\r\nif (fmt->code != V4L2_MBUS_FMT_FIXED)\r\nreturn -EINVAL;\r\nfmt->field = V4L2_FIELD_INTERLACED;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn saa711x_set_size(sd, fmt->width, fmt->height);\r\n}\r\nstatic int saa711x_decode_vbi_line(struct v4l2_subdev *sd, struct v4l2_decode_vbi_line *vbi)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nstatic const char vbi_no_data_pattern[] = {\r\n0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0\r\n};\r\nu8 *p = vbi->p;\r\nu32 wss;\r\nint id1, id2;\r\nvbi->type = 0;\r\nid1 = p[2];\r\nid2 = p[3];\r\nif (state->std & V4L2_STD_525_60)\r\nid1 ^= 0x40;\r\np += 4;\r\nvbi->p = p;\r\nvbi->is_second_field = ((id1 & 0x40) != 0);\r\nvbi->line = (id1 & 0x3f) << 3;\r\nvbi->line |= (id2 & 0x70) >> 4;\r\nid2 &= 0xf;\r\nif (!memcmp(p, vbi_no_data_pattern, sizeof(vbi_no_data_pattern)))\r\nreturn 0;\r\nswitch (id2) {\r\ncase 1:\r\nvbi->type = V4L2_SLICED_TELETEXT_B;\r\nbreak;\r\ncase 4:\r\nif (!saa711x_odd_parity(p[0]) || !saa711x_odd_parity(p[1]))\r\nreturn 0;\r\nvbi->type = V4L2_SLICED_CAPTION_525;\r\nbreak;\r\ncase 5:\r\nwss = saa711x_decode_wss(p);\r\nif (wss == -1)\r\nreturn 0;\r\np[0] = wss & 0xff;\r\np[1] = wss >> 8;\r\nvbi->type = V4L2_SLICED_WSS_625;\r\nbreak;\r\ncase 7:\r\nif (saa711x_decode_vps(p, p) != 0)\r\nreturn 0;\r\nvbi->type = V4L2_SLICED_VPS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa711x_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nint status;\r\nif (state->radio)\r\nreturn 0;\r\nstatus = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\r\nv4l2_dbg(1, debug, sd, "status: 0x%02x\n", status);\r\nvt->signal = ((status & (1 << 6)) == 0) ? 0xffff : 0x0;\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nstate->radio = 0;\r\nsaa711x_set_v4lstd(sd, std);\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nstate->radio = 1;\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nu8 mask = (state->ident <= V4L2_IDENT_SAA7111A) ? 0xf8 : 0xf0;\r\nv4l2_dbg(1, debug, sd, "decoder set input %d output %d\n",\r\ninput, output);\r\nif (state->ident <= V4L2_IDENT_SAA7113 &&\r\n(input == SAA7115_COMPOSITE4 ||\r\ninput == SAA7115_COMPOSITE5)) {\r\nreturn -EINVAL;\r\n}\r\nif (input > SAA7115_SVIDEO3)\r\nreturn -EINVAL;\r\nif (state->input == input && state->output == output)\r\nreturn 0;\r\nv4l2_dbg(1, debug, sd, "now setting %s input %s output\n",\r\n(input >= SAA7115_SVIDEO0) ? "S-Video" : "Composite",\r\n(output == SAA7115_IPORT_ON) ? "iport on" : "iport off");\r\nstate->input = input;\r\nif (state->ident <= V4L2_IDENT_SAA7111A) {\r\nif (input >= SAA7115_COMPOSITE4)\r\ninput -= 2;\r\nsaa711x_write(sd, R_10_CHROMA_CNTL_2,\r\n(saa711x_read(sd, R_10_CHROMA_CNTL_2) & 0x3f) |\r\n((output & 0xc0) ^ 0x40));\r\nsaa711x_write(sd, R_13_RT_X_PORT_OUT_CNTL,\r\n(saa711x_read(sd, R_13_RT_X_PORT_OUT_CNTL) & 0xf0) |\r\n((output & 2) ? 0x0a : 0));\r\n}\r\nsaa711x_write(sd, R_02_INPUT_CNTL_1,\r\n(saa711x_read(sd, R_02_INPUT_CNTL_1) & mask) |\r\ninput);\r\nsaa711x_write(sd, R_09_LUMA_CNTL,\r\n(saa711x_read(sd, R_09_LUMA_CNTL) & 0x7f) |\r\n(state->input >= SAA7115_SVIDEO0 ? 0x80 : 0x0));\r\nstate->output = output;\r\nif (state->ident == V4L2_IDENT_SAA7114 ||\r\nstate->ident == V4L2_IDENT_SAA7115) {\r\nsaa711x_write(sd, R_83_X_PORT_I_O_ENA_AND_OUT_CLK,\r\n(saa711x_read(sd, R_83_X_PORT_I_O_ENA_AND_OUT_CLK) & 0xfe) |\r\n(state->output & 0x01));\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_gpio(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nif (state->ident > V4L2_IDENT_SAA7111A)\r\nreturn -EINVAL;\r\nsaa711x_write(sd, 0x11, (saa711x_read(sd, 0x11) & 0x7f) |\r\n(val ? 0x80 : 0));\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s output\n",\r\nenable ? "enable" : "disable");\r\nif (state->enable == enable)\r\nreturn 0;\r\nstate->enable = enable;\r\nif (!saa711x_has_reg(state->ident, R_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED))\r\nreturn 0;\r\nsaa711x_write(sd, R_87_I_PORT_I_O_ENA_OUT_CLK_AND_GATED, state->enable);\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_crystal_freq(struct v4l2_subdev *sd, u32 freq, u32 flags)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nif (freq != SAA7115_FREQ_32_11_MHZ && freq != SAA7115_FREQ_24_576_MHZ)\r\nreturn -EINVAL;\r\nstate->crystal_freq = freq;\r\nstate->cgcdiv = (flags & SAA7115_FREQ_FL_CGCDIV) ? 3 : 4;\r\nstate->ucgc = (flags & SAA7115_FREQ_FL_UCGC) ? 1 : 0;\r\nstate->apll = (flags & SAA7115_FREQ_FL_APLL) ? 1 : 0;\r\nsaa711x_s_clock_freq(sd, state->audclk_freq);\r\nreturn 0;\r\n}\r\nstatic int saa711x_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nv4l2_dbg(1, debug, sd, "decoder RESET\n");\r\nsaa711x_writeregs(sd, saa7115_cfg_reset_scaler);\r\nreturn 0;\r\n}\r\nstatic int saa711x_g_vbi_data(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_data *data)\r\n{\r\nswitch (data->id) {\r\ncase V4L2_SLICED_WSS_625:\r\nif (saa711x_read(sd, 0x6b) & 0xc0)\r\nreturn -EIO;\r\ndata->data[0] = saa711x_read(sd, 0x6c);\r\ndata->data[1] = saa711x_read(sd, 0x6d);\r\nreturn 0;\r\ncase V4L2_SLICED_CAPTION_525:\r\nif (data->field == 0) {\r\nif (saa711x_read(sd, 0x66) & 0x30)\r\nreturn -EIO;\r\ndata->data[0] = saa711x_read(sd, 0x69);\r\ndata->data[1] = saa711x_read(sd, 0x6a);\r\nreturn 0;\r\n}\r\nif (saa711x_read(sd, 0x66) & 0xc0)\r\nreturn -EIO;\r\ndata->data[0] = saa711x_read(sd, 0x67);\r\ndata->data[1] = saa711x_read(sd, 0x68);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int saa711x_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nint reg1f, reg1e;\r\nreg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\r\nv4l2_dbg(1, debug, sd, "Status byte 2 (0x1f)=0x%02x\n", reg1f);\r\nif (reg1f & 0x40)\r\ngoto ret;\r\nif (reg1f & 0x20)\r\n*std &= V4L2_STD_525_60;\r\nelse\r\n*std &= V4L2_STD_625_50;\r\nif (state->ident != V4L2_IDENT_SAA7115)\r\ngoto ret;\r\nreg1e = saa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC);\r\nswitch (reg1e & 0x03) {\r\ncase 1:\r\n*std &= V4L2_STD_NTSC;\r\nbreak;\r\ncase 2:\r\n*std &= V4L2_STD_PAL | V4L2_STD_PAL_N | V4L2_STD_PAL_Nc |\r\nV4L2_STD_PAL_M | V4L2_STD_PAL_60;\r\nbreak;\r\ncase 3:\r\n*std &= V4L2_STD_SECAM;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nv4l2_dbg(1, debug, sd, "Status byte 1 (0x1e)=0x%02x\n", reg1e);\r\nret:\r\nv4l2_dbg(1, debug, sd, "detected std mask = %08Lx\n", *std);\r\nreturn 0;\r\n}\r\nstatic int saa711x_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nint reg1e = 0x80;\r\nint reg1f;\r\n*status = V4L2_IN_ST_NO_SIGNAL;\r\nif (state->ident == V4L2_IDENT_SAA7115)\r\nreg1e = saa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC);\r\nreg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\r\nif ((reg1f & 0xc1) == 0x81 && (reg1e & 0xc0) == 0x80)\r\n*status = 0;\r\nreturn 0;\r\n}\r\nstatic int saa711x_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->val = saa711x_read(sd, reg->reg & 0xff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int saa711x_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nsaa711x_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int saa711x_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, state->ident, 0);\r\n}\r\nstatic int saa711x_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct saa711x_state *state = to_state(sd);\r\nint reg1e, reg1f;\r\nint signalOk;\r\nint vcr;\r\nv4l2_info(sd, "Audio frequency: %d Hz\n", state->audclk_freq);\r\nif (state->ident != V4L2_IDENT_SAA7115) {\r\nreg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\r\nsignalOk = (reg1f & 0xc1) == 0x81;\r\nv4l2_info(sd, "Video signal: %s\n", signalOk ? "ok" : "bad");\r\nv4l2_info(sd, "Frequency: %s\n", (reg1f & 0x20) ? "60 Hz" : "50 Hz");\r\nreturn 0;\r\n}\r\nreg1e = saa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC);\r\nreg1f = saa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC);\r\nsignalOk = (reg1f & 0xc1) == 0x81 && (reg1e & 0xc0) == 0x80;\r\nvcr = !(reg1f & 0x10);\r\nif (state->input >= 6)\r\nv4l2_info(sd, "Input: S-Video %d\n", state->input - 6);\r\nelse\r\nv4l2_info(sd, "Input: Composite %d\n", state->input);\r\nv4l2_info(sd, "Video signal: %s\n", signalOk ? (vcr ? "VCR" : "broadcast/DVD") : "bad");\r\nv4l2_info(sd, "Frequency: %s\n", (reg1f & 0x20) ? "60 Hz" : "50 Hz");\r\nswitch (reg1e & 0x03) {\r\ncase 1:\r\nv4l2_info(sd, "Detected format: NTSC\n");\r\nbreak;\r\ncase 2:\r\nv4l2_info(sd, "Detected format: PAL\n");\r\nbreak;\r\ncase 3:\r\nv4l2_info(sd, "Detected format: SECAM\n");\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Detected format: BW/No color\n");\r\nbreak;\r\n}\r\nv4l2_info(sd, "Width, Height: %d, %d\n", state->width, state->height);\r\nv4l2_ctrl_handler_log_status(&state->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int saa711x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa711x_state *state;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint i;\r\nchar name[17];\r\nchar chip_id;\r\nint autodetect = !id || id->driver_data == 1;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nfor (i = 0; i < 0x0f; i++) {\r\ni2c_smbus_write_byte_data(client, 0, i);\r\nname[i] = (i2c_smbus_read_byte_data(client, 0) & 0x0f) + '0';\r\nif (name[i] > '9')\r\nname[i] += 'a' - '9' - 1;\r\n}\r\nname[i] = '\0';\r\nchip_id = name[5];\r\nif (memcmp(name + 1, "f711", 4)) {\r\nv4l_dbg(1, debug, client, "chip found @ 0x%x (ID %s) does not match a known saa711x chip.\n",\r\nclient->addr << 1, name);\r\nreturn -ENODEV;\r\n}\r\nif (!autodetect && id->name[6] != chip_id) {\r\nv4l_warn(client, "found saa711%c while %s was expected\n",\r\nchip_id, id->name);\r\n}\r\nsnprintf(client->name, sizeof(client->name), "saa711%c", chip_id);\r\nv4l_info(client, "saa711%c found (%s) @ 0x%x (%s)\n", chip_id, name,\r\nclient->addr << 1, client->adapter->name);\r\nstate = kzalloc(sizeof(struct saa711x_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa711x_ops);\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nstate->agc = v4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\r\nV4L2_CID_CHROMA_AGC, 0, 1, 1, 1);\r\nstate->gain = v4l2_ctrl_new_std(hdl, &saa711x_ctrl_ops,\r\nV4L2_CID_CHROMA_GAIN, 0, 127, 1, 40);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nkfree(state);\r\nreturn err;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &state->agc, 0, true);\r\nstate->input = -1;\r\nstate->output = SAA7115_IPORT_ON;\r\nstate->enable = 1;\r\nstate->radio = 0;\r\nswitch (chip_id) {\r\ncase '1':\r\nstate->ident = V4L2_IDENT_SAA7111;\r\nif (saa711x_read(sd, R_00_CHIP_VERSION) & 0xf0) {\r\nv4l_info(client, "saa7111a variant found\n");\r\nstate->ident = V4L2_IDENT_SAA7111A;\r\n}\r\nbreak;\r\ncase '3':\r\nstate->ident = V4L2_IDENT_SAA7113;\r\nbreak;\r\ncase '4':\r\nstate->ident = V4L2_IDENT_SAA7114;\r\nbreak;\r\ncase '5':\r\nstate->ident = V4L2_IDENT_SAA7115;\r\nbreak;\r\ncase '8':\r\nstate->ident = V4L2_IDENT_SAA7118;\r\nbreak;\r\ndefault:\r\nstate->ident = V4L2_IDENT_SAA7111;\r\nv4l2_info(sd, "WARNING: Chip is not known - Falling back to saa7111\n");\r\nbreak;\r\n}\r\nstate->audclk_freq = 48000;\r\nv4l2_dbg(1, debug, sd, "writing init values\n");\r\nstate->crystal_freq = SAA7115_FREQ_24_576_MHZ;\r\nswitch (state->ident) {\r\ncase V4L2_IDENT_SAA7111:\r\ncase V4L2_IDENT_SAA7111A:\r\nsaa711x_writeregs(sd, saa7111_init);\r\nbreak;\r\ncase V4L2_IDENT_SAA7113:\r\nsaa711x_writeregs(sd, saa7113_init);\r\nbreak;\r\ndefault:\r\nstate->crystal_freq = SAA7115_FREQ_32_11_MHZ;\r\nsaa711x_writeregs(sd, saa7115_init_auto_input);\r\n}\r\nif (state->ident > V4L2_IDENT_SAA7111A)\r\nsaa711x_writeregs(sd, saa7115_init_misc);\r\nsaa711x_set_v4lstd(sd, V4L2_STD_NTSC);\r\nv4l2_ctrl_handler_setup(hdl);\r\nv4l2_dbg(1, debug, sd, "status: (1E) 0x%02x, (1F) 0x%02x\n",\r\nsaa711x_read(sd, R_1E_STATUS_BYTE_1_VD_DEC),\r\nsaa711x_read(sd, R_1F_STATUS_BYTE_2_VD_DEC));\r\nreturn 0;\r\n}\r\nstatic int saa711x_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
