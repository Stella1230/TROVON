static void pl010_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int cr;\r\ncr = readb(uap->port.membase + UART010_CR);\r\ncr &= ~UART010_CR_TIE;\r\nwritel(cr, uap->port.membase + UART010_CR);\r\n}\r\nstatic void pl010_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int cr;\r\ncr = readb(uap->port.membase + UART010_CR);\r\ncr |= UART010_CR_TIE;\r\nwritel(cr, uap->port.membase + UART010_CR);\r\n}\r\nstatic void pl010_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int cr;\r\ncr = readb(uap->port.membase + UART010_CR);\r\ncr &= ~(UART010_CR_RIE | UART010_CR_RTIE);\r\nwritel(cr, uap->port.membase + UART010_CR);\r\n}\r\nstatic void pl010_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int cr;\r\ncr = readb(uap->port.membase + UART010_CR);\r\ncr |= UART010_CR_MSIE;\r\nwritel(cr, uap->port.membase + UART010_CR);\r\n}\r\nstatic void pl010_rx_chars(struct uart_amba_port *uap)\r\n{\r\nstruct tty_struct *tty = uap->port.state->port.tty;\r\nunsigned int status, ch, flag, rsr, max_count = 256;\r\nstatus = readb(uap->port.membase + UART01x_FR);\r\nwhile (UART_RX_DATA(status) && max_count--) {\r\nch = readb(uap->port.membase + UART01x_DR);\r\nflag = TTY_NORMAL;\r\nuap->port.icount.rx++;\r\nrsr = readb(uap->port.membase + UART01x_RSR) | UART_DUMMY_RSR_RX;\r\nif (unlikely(rsr & UART01x_RSR_ANY)) {\r\nwritel(0, uap->port.membase + UART01x_ECR);\r\nif (rsr & UART01x_RSR_BE) {\r\nrsr &= ~(UART01x_RSR_FE | UART01x_RSR_PE);\r\nuap->port.icount.brk++;\r\nif (uart_handle_break(&uap->port))\r\ngoto ignore_char;\r\n} else if (rsr & UART01x_RSR_PE)\r\nuap->port.icount.parity++;\r\nelse if (rsr & UART01x_RSR_FE)\r\nuap->port.icount.frame++;\r\nif (rsr & UART01x_RSR_OE)\r\nuap->port.icount.overrun++;\r\nrsr &= uap->port.read_status_mask;\r\nif (rsr & UART01x_RSR_BE)\r\nflag = TTY_BREAK;\r\nelse if (rsr & UART01x_RSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (rsr & UART01x_RSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&uap->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&uap->port, rsr, UART01x_RSR_OE, ch, flag);\r\nignore_char:\r\nstatus = readb(uap->port.membase + UART01x_FR);\r\n}\r\nspin_unlock(&uap->port.lock);\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&uap->port.lock);\r\n}\r\nstatic void pl010_tx_chars(struct uart_amba_port *uap)\r\n{\r\nstruct circ_buf *xmit = &uap->port.state->xmit;\r\nint count;\r\nif (uap->port.x_char) {\r\nwritel(uap->port.x_char, uap->port.membase + UART01x_DR);\r\nuap->port.icount.tx++;\r\nuap->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&uap->port)) {\r\npl010_stop_tx(&uap->port);\r\nreturn;\r\n}\r\ncount = uap->port.fifosize >> 1;\r\ndo {\r\nwritel(xmit->buf[xmit->tail], uap->port.membase + UART01x_DR);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nuap->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\nif (uart_circ_empty(xmit))\r\npl010_stop_tx(&uap->port);\r\n}\r\nstatic void pl010_modem_status(struct uart_amba_port *uap)\r\n{\r\nunsigned int status, delta;\r\nwritel(0, uap->port.membase + UART010_ICR);\r\nstatus = readb(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\r\ndelta = status ^ uap->old_status;\r\nuap->old_status = status;\r\nif (!delta)\r\nreturn;\r\nif (delta & UART01x_FR_DCD)\r\nuart_handle_dcd_change(&uap->port, status & UART01x_FR_DCD);\r\nif (delta & UART01x_FR_DSR)\r\nuap->port.icount.dsr++;\r\nif (delta & UART01x_FR_CTS)\r\nuart_handle_cts_change(&uap->port, status & UART01x_FR_CTS);\r\nwake_up_interruptible(&uap->port.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t pl010_int(int irq, void *dev_id)\r\n{\r\nstruct uart_amba_port *uap = dev_id;\r\nunsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;\r\nint handled = 0;\r\nspin_lock(&uap->port.lock);\r\nstatus = readb(uap->port.membase + UART010_IIR);\r\nif (status) {\r\ndo {\r\nif (status & (UART010_IIR_RTIS | UART010_IIR_RIS))\r\npl010_rx_chars(uap);\r\nif (status & UART010_IIR_MIS)\r\npl010_modem_status(uap);\r\nif (status & UART010_IIR_TIS)\r\npl010_tx_chars(uap);\r\nif (pass_counter-- == 0)\r\nbreak;\r\nstatus = readb(uap->port.membase + UART010_IIR);\r\n} while (status & (UART010_IIR_RTIS | UART010_IIR_RIS |\r\nUART010_IIR_TIS));\r\nhandled = 1;\r\n}\r\nspin_unlock(&uap->port.lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned int pl010_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int status = readb(uap->port.membase + UART01x_FR);\r\nreturn status & UART01x_FR_BUSY ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int pl010_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int result = 0;\r\nunsigned int status;\r\nstatus = readb(uap->port.membase + UART01x_FR);\r\nif (status & UART01x_FR_DCD)\r\nresult |= TIOCM_CAR;\r\nif (status & UART01x_FR_DSR)\r\nresult |= TIOCM_DSR;\r\nif (status & UART01x_FR_CTS)\r\nresult |= TIOCM_CTS;\r\nreturn result;\r\n}\r\nstatic void pl010_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nif (uap->data)\r\nuap->data->set_mctrl(uap->dev, uap->port.membase, mctrl);\r\n}\r\nstatic void pl010_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned long flags;\r\nunsigned int lcr_h;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nlcr_h = readb(uap->port.membase + UART010_LCRH);\r\nif (break_state == -1)\r\nlcr_h |= UART01x_LCRH_BRK;\r\nelse\r\nlcr_h &= ~UART01x_LCRH_BRK;\r\nwritel(lcr_h, uap->port.membase + UART010_LCRH);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic int pl010_startup(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nint retval;\r\nretval = clk_prepare_enable(uap->clk);\r\nif (retval)\r\ngoto out;\r\nuap->port.uartclk = clk_get_rate(uap->clk);\r\nretval = request_irq(uap->port.irq, pl010_int, 0, "uart-pl010", uap);\r\nif (retval)\r\ngoto clk_dis;\r\nuap->old_status = readb(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;\r\nwritel(UART01x_CR_UARTEN | UART010_CR_RIE | UART010_CR_RTIE,\r\nuap->port.membase + UART010_CR);\r\nreturn 0;\r\nclk_dis:\r\nclk_disable_unprepare(uap->clk);\r\nout:\r\nreturn retval;\r\n}\r\nstatic void pl010_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nfree_irq(uap->port.irq, uap);\r\nwritel(0, uap->port.membase + UART010_CR);\r\nwritel(readb(uap->port.membase + UART010_LCRH) &\r\n~(UART01x_LCRH_BRK | UART01x_LCRH_FEN),\r\nuap->port.membase + UART010_LCRH);\r\nclk_disable_unprepare(uap->clk);\r\n}\r\nstatic void\r\npl010_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int lcr_h, old_cr;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, uap->port.uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr_h = UART01x_LCRH_WLEN_5;\r\nbreak;\r\ncase CS6:\r\nlcr_h = UART01x_LCRH_WLEN_6;\r\nbreak;\r\ncase CS7:\r\nlcr_h = UART01x_LCRH_WLEN_7;\r\nbreak;\r\ndefault:\r\nlcr_h = UART01x_LCRH_WLEN_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr_h |= UART01x_LCRH_STP2;\r\nif (termios->c_cflag & PARENB) {\r\nlcr_h |= UART01x_LCRH_PEN;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr_h |= UART01x_LCRH_EPS;\r\n}\r\nif (uap->port.fifosize > 1)\r\nlcr_h |= UART01x_LCRH_FEN;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nuap->port.read_status_mask = UART01x_RSR_OE;\r\nif (termios->c_iflag & INPCK)\r\nuap->port.read_status_mask |= UART01x_RSR_FE | UART01x_RSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nuap->port.read_status_mask |= UART01x_RSR_BE;\r\nuap->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nuap->port.ignore_status_mask |= UART01x_RSR_FE | UART01x_RSR_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nuap->port.ignore_status_mask |= UART01x_RSR_BE;\r\nif (termios->c_iflag & IGNPAR)\r\nuap->port.ignore_status_mask |= UART01x_RSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nuap->port.ignore_status_mask |= UART_DUMMY_RSR_RX;\r\nold_cr = readb(uap->port.membase + UART010_CR) & ~UART010_CR_MSIE;\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\nold_cr |= UART010_CR_MSIE;\r\nwritel(0, uap->port.membase + UART010_CR);\r\nquot -= 1;\r\nwritel((quot & 0xf00) >> 8, uap->port.membase + UART010_LCRM);\r\nwritel(quot & 0xff, uap->port.membase + UART010_LCRL);\r\nwritel(lcr_h, uap->port.membase + UART010_LCRH);\r\nwritel(old_cr, uap->port.membase + UART010_CR);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic void pl010_set_ldisc(struct uart_port *port, int new)\r\n{\r\nif (new == N_PPS) {\r\nport->flags |= UPF_HARDPPS_CD;\r\npl010_enable_ms(port);\r\n} else\r\nport->flags &= ~UPF_HARDPPS_CD;\r\n}\r\nstatic const char *pl010_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_AMBA ? "AMBA" : NULL;\r\n}\r\nstatic void pl010_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, UART_PORT_SIZE);\r\n}\r\nstatic int pl010_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, UART_PORT_SIZE, "uart-pl010")\r\n!= NULL ? 0 : -EBUSY;\r\n}\r\nstatic void pl010_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_AMBA;\r\npl010_request_port(port);\r\n}\r\n}\r\nstatic int pl010_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)\r\nret = -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= nr_irqs)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void pl010_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_amba_port *uap = (struct uart_amba_port *)port;\r\nunsigned int status;\r\ndo {\r\nstatus = readb(uap->port.membase + UART01x_FR);\r\nbarrier();\r\n} while (!UART_TX_READY(status));\r\nwritel(ch, uap->port.membase + UART01x_DR);\r\n}\r\nstatic void\r\npl010_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_amba_port *uap = amba_ports[co->index];\r\nunsigned int status, old_cr;\r\nclk_enable(uap->clk);\r\nold_cr = readb(uap->port.membase + UART010_CR);\r\nwritel(UART01x_CR_UARTEN, uap->port.membase + UART010_CR);\r\nuart_console_write(&uap->port, s, count, pl010_console_putchar);\r\ndo {\r\nstatus = readb(uap->port.membase + UART01x_FR);\r\nbarrier();\r\n} while (status & UART01x_FR_BUSY);\r\nwritel(old_cr, uap->port.membase + UART010_CR);\r\nclk_disable(uap->clk);\r\n}\r\nstatic void __init\r\npl010_console_get_options(struct uart_amba_port *uap, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (readb(uap->port.membase + UART010_CR) & UART01x_CR_UARTEN) {\r\nunsigned int lcr_h, quot;\r\nlcr_h = readb(uap->port.membase + UART010_LCRH);\r\n*parity = 'n';\r\nif (lcr_h & UART01x_LCRH_PEN) {\r\nif (lcr_h & UART01x_LCRH_EPS)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif ((lcr_h & 0x60) == UART01x_LCRH_WLEN_7)\r\n*bits = 7;\r\nelse\r\n*bits = 8;\r\nquot = readb(uap->port.membase + UART010_LCRL) |\r\nreadb(uap->port.membase + UART010_LCRM) << 8;\r\n*baud = uap->port.uartclk / (16 * (quot + 1));\r\n}\r\n}\r\nstatic int __init pl010_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_amba_port *uap;\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index >= UART_NR)\r\nco->index = 0;\r\nuap = amba_ports[co->index];\r\nif (!uap)\r\nreturn -ENODEV;\r\nret = clk_prepare(uap->clk);\r\nif (ret)\r\nreturn ret;\r\nuap->port.uartclk = clk_get_rate(uap->clk);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\npl010_console_get_options(uap, &baud, &parity, &bits);\r\nreturn uart_set_options(&uap->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int pl010_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct uart_amba_port *uap;\r\nvoid __iomem *base;\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\r\nif (amba_ports[i] == NULL)\r\nbreak;\r\nif (i == ARRAY_SIZE(amba_ports)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nuap = kzalloc(sizeof(struct uart_amba_port), GFP_KERNEL);\r\nif (!uap) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbase = ioremap(dev->res.start, resource_size(&dev->res));\r\nif (!base) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nuap->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(uap->clk)) {\r\nret = PTR_ERR(uap->clk);\r\ngoto unmap;\r\n}\r\nuap->port.dev = &dev->dev;\r\nuap->port.mapbase = dev->res.start;\r\nuap->port.membase = base;\r\nuap->port.iotype = UPIO_MEM;\r\nuap->port.irq = dev->irq[0];\r\nuap->port.fifosize = 16;\r\nuap->port.ops = &amba_pl010_pops;\r\nuap->port.flags = UPF_BOOT_AUTOCONF;\r\nuap->port.line = i;\r\nuap->dev = dev;\r\nuap->data = dev->dev.platform_data;\r\namba_ports[i] = uap;\r\namba_set_drvdata(dev, uap);\r\nret = uart_add_one_port(&amba_reg, &uap->port);\r\nif (ret) {\r\namba_set_drvdata(dev, NULL);\r\namba_ports[i] = NULL;\r\nclk_put(uap->clk);\r\nunmap:\r\niounmap(base);\r\nfree:\r\nkfree(uap);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pl010_remove(struct amba_device *dev)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nint i;\r\namba_set_drvdata(dev, NULL);\r\nuart_remove_one_port(&amba_reg, &uap->port);\r\nfor (i = 0; i < ARRAY_SIZE(amba_ports); i++)\r\nif (amba_ports[i] == uap)\r\namba_ports[i] = NULL;\r\niounmap(uap->port.membase);\r\nclk_put(uap->clk);\r\nkfree(uap);\r\nreturn 0;\r\n}\r\nstatic int pl010_suspend(struct amba_device *dev, pm_message_t state)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nif (uap)\r\nuart_suspend_port(&amba_reg, &uap->port);\r\nreturn 0;\r\n}\r\nstatic int pl010_resume(struct amba_device *dev)\r\n{\r\nstruct uart_amba_port *uap = amba_get_drvdata(dev);\r\nif (uap)\r\nuart_resume_port(&amba_reg, &uap->port);\r\nreturn 0;\r\n}\r\nstatic int __init pl010_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: AMBA driver\n");\r\nret = uart_register_driver(&amba_reg);\r\nif (ret == 0) {\r\nret = amba_driver_register(&pl010_driver);\r\nif (ret)\r\nuart_unregister_driver(&amba_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit pl010_exit(void)\r\n{\r\namba_driver_unregister(&pl010_driver);\r\nuart_unregister_driver(&amba_reg);\r\n}
