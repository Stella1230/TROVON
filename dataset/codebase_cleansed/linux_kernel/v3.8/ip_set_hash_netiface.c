static void\r\nrbtree_destroy(struct rb_root *root)\r\n{\r\nstruct rb_node *p, *n = root->rb_node;\r\nstruct iface_node *node;\r\nwhile (n) {\r\nif (n->rb_left) {\r\nn = n->rb_left;\r\ncontinue;\r\n}\r\nif (n->rb_right) {\r\nn = n->rb_right;\r\ncontinue;\r\n}\r\np = rb_parent(n);\r\nnode = rb_entry(n, struct iface_node, node);\r\nif (!p)\r\n*root = RB_ROOT;\r\nelse if (p->rb_left == n)\r\np->rb_left = NULL;\r\nelse if (p->rb_right == n)\r\np->rb_right = NULL;\r\nkfree(node);\r\nn = p;\r\n}\r\n}\r\nstatic int\r\niface_test(struct rb_root *root, const char **iface)\r\n{\r\nstruct rb_node *n = root->rb_node;\r\nwhile (n) {\r\nconst char *d = iface_data(n);\r\nint res = strcmp(*iface, d);\r\nif (res < 0)\r\nn = n->rb_left;\r\nelse if (res > 0)\r\nn = n->rb_right;\r\nelse {\r\n*iface = d;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\niface_add(struct rb_root *root, const char **iface)\r\n{\r\nstruct rb_node **n = &(root->rb_node), *p = NULL;\r\nstruct iface_node *d;\r\nwhile (*n) {\r\nchar *ifname = iface_data(*n);\r\nint res = strcmp(*iface, ifname);\r\np = *n;\r\nif (res < 0)\r\nn = &((*n)->rb_left);\r\nelse if (res > 0)\r\nn = &((*n)->rb_right);\r\nelse {\r\n*iface = ifname;\r\nreturn 0;\r\n}\r\n}\r\nd = kzalloc(sizeof(*d), GFP_ATOMIC);\r\nif (!d)\r\nreturn -ENOMEM;\r\nstrcpy(d->iface, *iface);\r\nrb_link_node(&d->node, p, n);\r\nrb_insert_color(&d->node, root);\r\n*iface = d->iface;\r\nreturn 0;\r\n}\r\nstatic inline bool\r\nhash_netiface4_data_equal(const struct hash_netiface4_elem *ip1,\r\nconst struct hash_netiface4_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ip1->ip == ip2->ip &&\r\nip1->cidr == ip2->cidr &&\r\n(++*multi) &&\r\nip1->physdev == ip2->physdev &&\r\nip1->iface == ip2->iface;\r\n}\r\nstatic inline bool\r\nhash_netiface4_data_isnull(const struct hash_netiface4_elem *elem)\r\n{\r\nreturn elem->elem == 0;\r\n}\r\nstatic inline void\r\nhash_netiface4_data_copy(struct hash_netiface4_elem *dst,\r\nconst struct hash_netiface4_elem *src)\r\n{\r\nmemcpy(dst, src, sizeof(*dst));\r\n}\r\nstatic inline void\r\nhash_netiface4_data_flags(struct hash_netiface4_elem *dst, u32 flags)\r\n{\r\ndst->nomatch = flags & IPSET_FLAG_NOMATCH;\r\n}\r\nstatic inline int\r\nhash_netiface4_data_match(const struct hash_netiface4_elem *elem)\r\n{\r\nreturn elem->nomatch ? -ENOTEMPTY : 1;\r\n}\r\nstatic inline void\r\nhash_netiface4_data_netmask(struct hash_netiface4_elem *elem, u8 cidr)\r\n{\r\nelem->ip &= ip_set_netmask(cidr);\r\nelem->cidr = cidr;\r\n}\r\nstatic inline void\r\nhash_netiface4_data_zero_out(struct hash_netiface4_elem *elem)\r\n{\r\nelem->elem = 0;\r\n}\r\nstatic bool\r\nhash_netiface4_data_list(struct sk_buff *skb,\r\nconst struct hash_netiface4_elem *data)\r\n{\r\nu32 flags = data->physdev ? IPSET_FLAG_PHYSDEV : 0;\r\nif (data->nomatch)\r\nflags |= IPSET_FLAG_NOMATCH;\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr) ||\r\nnla_put_string(skb, IPSET_ATTR_IFACE, data->iface) ||\r\n(flags &&\r\nnla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic bool\r\nhash_netiface4_data_tlist(struct sk_buff *skb,\r\nconst struct hash_netiface4_elem *data)\r\n{\r\nconst struct hash_netiface4_telem *tdata =\r\n(const struct hash_netiface4_telem *)data;\r\nu32 flags = data->physdev ? IPSET_FLAG_PHYSDEV : 0;\r\nif (data->nomatch)\r\nflags |= IPSET_FLAG_NOMATCH;\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr) ||\r\nnla_put_string(skb, IPSET_ATTR_IFACE, data->iface) ||\r\n(flags &&\r\nnla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))) ||\r\nnla_put_net32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(tdata->timeout))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic inline void\r\nhash_netiface4_data_next(struct ip_set_hash *h,\r\nconst struct hash_netiface4_elem *d)\r\n{\r\nh->next.ip = d->ip;\r\n}\r\nstatic int\r\nhash_netiface4_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netiface4_elem data = {\r\n.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK,\r\n.elem = 1,\r\n};\r\nint ret;\r\nif (data.cidr == 0)\r\nreturn -EINVAL;\r\nif (adt == IPSET_TEST)\r\ndata.cidr = HOST_MASK;\r\nip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &data.ip);\r\ndata.ip &= ip_set_netmask(data.cidr);\r\n#define IFACE(dir) (par->dir ? par->dir->name : NULL)\r\n#define PHYSDEV(dir) (nf_bridge->dir ? nf_bridge->dir->name : NULL)\r\n#define SRCDIR (opt->flags & IPSET_DIM_TWO_SRC)\r\nif (opt->cmdflags & IPSET_FLAG_PHYSDEV) {\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nconst struct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nif (!nf_bridge)\r\nreturn -EINVAL;\r\ndata.iface = SRCDIR ? PHYSDEV(physindev) : PHYSDEV(physoutdev);\r\ndata.physdev = 1;\r\n#else\r\ndata.iface = NULL;\r\n#endif\r\n} else\r\ndata.iface = SRCDIR ? IFACE(in) : IFACE(out);\r\nif (!data.iface)\r\nreturn -EINVAL;\r\nret = iface_test(&h->rbtree, &data.iface);\r\nif (adt == IPSET_ADD) {\r\nif (!ret) {\r\nret = iface_add(&h->rbtree, &data.iface);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else if (!ret)\r\nreturn ret;\r\nreturn adtfn(set, &data, opt_timeout(opt, h), opt->cmdflags);\r\n}\r\nstatic int\r\nhash_netiface4_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netiface4_elem data = { .cidr = HOST_MASK, .elem = 1 };\r\nu32 ip = 0, ip_to, last;\r\nu32 timeout = h->timeout;\r\nchar iface[IFNAMSIZ];\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!tb[IPSET_ATTR_IFACE] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_CIDR]) {\r\ndata.cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (data.cidr > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\n}\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(h->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nstrcpy(iface, nla_data(tb[IPSET_ATTR_IFACE]));\r\ndata.iface = iface;\r\nret = iface_test(&h->rbtree, &data.iface);\r\nif (adt == IPSET_ADD) {\r\nif (!ret) {\r\nret = iface_add(&h->rbtree, &data.iface);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else if (!ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\nif (cadt_flags & IPSET_FLAG_PHYSDEV)\r\ndata.physdev = 1;\r\nif (adt == IPSET_ADD && (cadt_flags & IPSET_FLAG_NOMATCH))\r\nflags |= (cadt_flags << 16);\r\n}\r\nif (adt == IPSET_TEST || !tb[IPSET_ATTR_IP_TO]) {\r\ndata.ip = htonl(ip & ip_set_hostmask(data.cidr));\r\nret = adtfn(set, &data, timeout, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip_to < ip)\r\nswap(ip, ip_to);\r\nif (ip + UINT_MAX == ip_to)\r\nreturn -IPSET_ERR_HASH_RANGE;\r\n} else {\r\nip_set_mask_from_to(ip, ip_to, data.cidr);\r\n}\r\nif (retried)\r\nip = ntohl(h->next.ip);\r\nwhile (!after(ip, ip_to)) {\r\ndata.ip = htonl(ip);\r\nlast = ip_set_range_to_cidr(ip, ip_to, &data.cidr);\r\nret = adtfn(set, &data, timeout, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\nip = last + 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\nhash_netiface_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct ip_set_hash *x = a->data;\r\nconst struct ip_set_hash *y = b->data;\r\nreturn x->maxelem == y->maxelem &&\r\nx->timeout == y->timeout;\r\n}\r\nstatic inline bool\r\nhash_netiface6_data_equal(const struct hash_netiface6_elem *ip1,\r\nconst struct hash_netiface6_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ipv6_addr_cmp(&ip1->ip.in6, &ip2->ip.in6) == 0 &&\r\nip1->cidr == ip2->cidr &&\r\n(++*multi) &&\r\nip1->physdev == ip2->physdev &&\r\nip1->iface == ip2->iface;\r\n}\r\nstatic inline bool\r\nhash_netiface6_data_isnull(const struct hash_netiface6_elem *elem)\r\n{\r\nreturn elem->elem == 0;\r\n}\r\nstatic inline void\r\nhash_netiface6_data_copy(struct hash_netiface6_elem *dst,\r\nconst struct hash_netiface6_elem *src)\r\n{\r\nmemcpy(dst, src, sizeof(*dst));\r\n}\r\nstatic inline void\r\nhash_netiface6_data_flags(struct hash_netiface6_elem *dst, u32 flags)\r\n{\r\ndst->nomatch = flags & IPSET_FLAG_NOMATCH;\r\n}\r\nstatic inline int\r\nhash_netiface6_data_match(const struct hash_netiface6_elem *elem)\r\n{\r\nreturn elem->nomatch ? -ENOTEMPTY : 1;\r\n}\r\nstatic inline void\r\nhash_netiface6_data_zero_out(struct hash_netiface6_elem *elem)\r\n{\r\nelem->elem = 0;\r\n}\r\nstatic inline void\r\nip6_netmask(union nf_inet_addr *ip, u8 prefix)\r\n{\r\nip->ip6[0] &= ip_set_netmask6(prefix)[0];\r\nip->ip6[1] &= ip_set_netmask6(prefix)[1];\r\nip->ip6[2] &= ip_set_netmask6(prefix)[2];\r\nip->ip6[3] &= ip_set_netmask6(prefix)[3];\r\n}\r\nstatic inline void\r\nhash_netiface6_data_netmask(struct hash_netiface6_elem *elem, u8 cidr)\r\n{\r\nip6_netmask(&elem->ip, cidr);\r\nelem->cidr = cidr;\r\n}\r\nstatic bool\r\nhash_netiface6_data_list(struct sk_buff *skb,\r\nconst struct hash_netiface6_elem *data)\r\n{\r\nu32 flags = data->physdev ? IPSET_FLAG_PHYSDEV : 0;\r\nif (data->nomatch)\r\nflags |= IPSET_FLAG_NOMATCH;\r\nif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &data->ip.in6) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr) ||\r\nnla_put_string(skb, IPSET_ATTR_IFACE, data->iface) ||\r\n(flags &&\r\nnla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic bool\r\nhash_netiface6_data_tlist(struct sk_buff *skb,\r\nconst struct hash_netiface6_elem *data)\r\n{\r\nconst struct hash_netiface6_telem *e =\r\n(const struct hash_netiface6_telem *)data;\r\nu32 flags = data->physdev ? IPSET_FLAG_PHYSDEV : 0;\r\nif (data->nomatch)\r\nflags |= IPSET_FLAG_NOMATCH;\r\nif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &e->ip.in6) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr) ||\r\nnla_put_string(skb, IPSET_ATTR_IFACE, data->iface) ||\r\n(flags &&\r\nnla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))) ||\r\nnla_put_net32(skb, IPSET_ATTR_TIMEOUT,\r\nhtonl(ip_set_timeout_get(e->timeout))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn 1;\r\n}\r\nstatic inline void\r\nhash_netiface6_data_next(struct ip_set_hash *h,\r\nconst struct hash_netiface6_elem *d)\r\n{\r\n}\r\nstatic int\r\nhash_netiface6_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netiface6_elem data = {\r\n.cidr = h->nets[0].cidr ? h->nets[0].cidr : HOST_MASK,\r\n.elem = 1,\r\n};\r\nint ret;\r\nif (data.cidr == 0)\r\nreturn -EINVAL;\r\nif (adt == IPSET_TEST)\r\ndata.cidr = HOST_MASK;\r\nip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &data.ip.in6);\r\nip6_netmask(&data.ip, data.cidr);\r\nif (opt->cmdflags & IPSET_FLAG_PHYSDEV) {\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nconst struct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nif (!nf_bridge)\r\nreturn -EINVAL;\r\ndata.iface = SRCDIR ? PHYSDEV(physindev) : PHYSDEV(physoutdev);\r\ndata.physdev = 1;\r\n#else\r\ndata.iface = NULL;\r\n#endif\r\n} else\r\ndata.iface = SRCDIR ? IFACE(in) : IFACE(out);\r\nif (!data.iface)\r\nreturn -EINVAL;\r\nret = iface_test(&h->rbtree, &data.iface);\r\nif (adt == IPSET_ADD) {\r\nif (!ret) {\r\nret = iface_add(&h->rbtree, &data.iface);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else if (!ret)\r\nreturn ret;\r\nreturn adtfn(set, &data, opt_timeout(opt, h), opt->cmdflags);\r\n}\r\nstatic int\r\nhash_netiface6_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct ip_set_hash *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netiface6_elem data = { .cidr = HOST_MASK, .elem = 1 };\r\nu32 timeout = h->timeout;\r\nchar iface[IFNAMSIZ];\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!tb[IPSET_ATTR_IFACE] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (unlikely(tb[IPSET_ATTR_IP_TO]))\r\nreturn -IPSET_ERR_HASH_RANGE_UNSUPPORTED;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &data.ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_CIDR])\r\ndata.cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (data.cidr > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip6_netmask(&data.ip, data.cidr);\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(h->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nstrcpy(iface, nla_data(tb[IPSET_ATTR_IFACE]));\r\ndata.iface = iface;\r\nret = iface_test(&h->rbtree, &data.iface);\r\nif (adt == IPSET_ADD) {\r\nif (!ret) {\r\nret = iface_add(&h->rbtree, &data.iface);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else if (!ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\nif (cadt_flags & IPSET_FLAG_PHYSDEV)\r\ndata.physdev = 1;\r\nif (adt == IPSET_ADD && (cadt_flags & IPSET_FLAG_NOMATCH))\r\nflags |= (cadt_flags << 16);\r\n}\r\nret = adtfn(set, &data, timeout, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic int\r\nhash_netiface_create(struct ip_set *set, struct nlattr *tb[], u32 flags)\r\n{\r\nstruct ip_set_hash *h;\r\nu32 hashsize = IPSET_DEFAULT_HASHSIZE, maxelem = IPSET_DEFAULT_MAXELEM;\r\nu8 hbits;\r\nsize_t hsize;\r\nif (!(set->family == NFPROTO_IPV4 || set->family == NFPROTO_IPV6))\r\nreturn -IPSET_ERR_INVALID_FAMILY;\r\nif (unlikely(!ip_set_optattr_netorder(tb, IPSET_ATTR_HASHSIZE) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_MAXELEM) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_HASHSIZE]) {\r\nhashsize = ip_set_get_h32(tb[IPSET_ATTR_HASHSIZE]);\r\nif (hashsize < IPSET_MIMINAL_HASHSIZE)\r\nhashsize = IPSET_MIMINAL_HASHSIZE;\r\n}\r\nif (tb[IPSET_ATTR_MAXELEM])\r\nmaxelem = ip_set_get_h32(tb[IPSET_ATTR_MAXELEM]);\r\nh = kzalloc(sizeof(*h)\r\n+ sizeof(struct ip_set_hash_nets)\r\n* (set->family == NFPROTO_IPV4 ? 32 : 128), GFP_KERNEL);\r\nif (!h)\r\nreturn -ENOMEM;\r\nh->maxelem = maxelem;\r\nget_random_bytes(&h->initval, sizeof(h->initval));\r\nh->timeout = IPSET_NO_TIMEOUT;\r\nh->ahash_max = AHASH_MAX_SIZE;\r\nhbits = htable_bits(hashsize);\r\nhsize = htable_size(hbits);\r\nif (hsize == 0) {\r\nkfree(h);\r\nreturn -ENOMEM;\r\n}\r\nh->table = ip_set_alloc(hsize);\r\nif (!h->table) {\r\nkfree(h);\r\nreturn -ENOMEM;\r\n}\r\nh->table->htable_bits = hbits;\r\nh->rbtree = RB_ROOT;\r\nset->data = h;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nh->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nset->variant = set->family == NFPROTO_IPV4\r\n? &hash_netiface4_tvariant : &hash_netiface6_tvariant;\r\nif (set->family == NFPROTO_IPV4)\r\nhash_netiface4_gc_init(set);\r\nelse\r\nhash_netiface6_gc_init(set);\r\n} else {\r\nset->variant = set->family == NFPROTO_IPV4\r\n? &hash_netiface4_variant : &hash_netiface6_variant;\r\n}\r\npr_debug("create %s hashsize %u (%u) maxelem %u: %p(%p)\n",\r\nset->name, jhash_size(h->table->htable_bits),\r\nh->table->htable_bits, h->maxelem, set->data, h->table);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhash_netiface_init(void)\r\n{\r\nreturn ip_set_type_register(&hash_netiface_type);\r\n}\r\nstatic void __exit\r\nhash_netiface_fini(void)\r\n{\r\nip_set_type_unregister(&hash_netiface_type);\r\n}
