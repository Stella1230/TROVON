static inline unsigned tiocm_to_gigaset(unsigned state)\r\n{\r\nreturn ((state & TIOCM_DTR) ? 1 : 0) | ((state & TIOCM_RTS) ? 2 : 0);\r\n}\r\nstatic int gigaset_set_modem_ctrl(struct cardstate *cs, unsigned old_state,\r\nunsigned new_state)\r\n{\r\nstruct usb_device *udev = cs->hw.usb->udev;\r\nunsigned mask, val;\r\nint r;\r\nmask = tiocm_to_gigaset(old_state ^ new_state);\r\nval = tiocm_to_gigaset(new_state);\r\ngig_dbg(DEBUG_USBREQ, "set flags 0x%02x with mask 0x%02x", val, mask);\r\nr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 7, 0x41,\r\n(val & 0xff) | ((mask & 0xff) << 8), 0,\r\nNULL, 0, 2000 );\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int set_value(struct cardstate *cs, u8 req, u16 val)\r\n{\r\nstruct usb_device *udev = cs->hw.usb->udev;\r\nint r, r2;\r\ngig_dbg(DEBUG_USBREQ, "request %02x (%04x)",\r\n(unsigned)req, (unsigned)val);\r\nr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x12, 0x41,\r\n0xf , 0, NULL, 0, 2000 );\r\nif (r < 0) {\r\ndev_err(&udev->dev, "error %d on request 0x12\n", -r);\r\nreturn r;\r\n}\r\nr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), req, 0x41,\r\nval, 0, NULL, 0, 2000 );\r\nif (r < 0)\r\ndev_err(&udev->dev, "error %d on request 0x%02x\n",\r\n-r, (unsigned)req);\r\nr2 = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x19, 0x41,\r\n0, 0, cs->hw.usb->bchars, 6, 2000 );\r\nif (r2 < 0)\r\ndev_err(&udev->dev, "error %d on request 0x19\n", -r2);\r\nreturn r < 0 ? r : (r2 < 0 ? r2 : 0);\r\n}\r\nstatic int gigaset_baud_rate(struct cardstate *cs, unsigned cflag)\r\n{\r\nu16 val;\r\nu32 rate;\r\ncflag &= CBAUD;\r\nswitch (cflag) {\r\ncase B300: rate = 300; break;\r\ncase B600: rate = 600; break;\r\ncase B1200: rate = 1200; break;\r\ncase B2400: rate = 2400; break;\r\ncase B4800: rate = 4800; break;\r\ncase B9600: rate = 9600; break;\r\ncase B19200: rate = 19200; break;\r\ncase B38400: rate = 38400; break;\r\ncase B57600: rate = 57600; break;\r\ncase B115200: rate = 115200; break;\r\ndefault:\r\nrate = 9600;\r\ndev_err(cs->dev, "unsupported baudrate request 0x%x,"\r\n" using default of B9600\n", cflag);\r\n}\r\nval = 0x383fff / rate + 1;\r\nreturn set_value(cs, 1, val);\r\n}\r\nstatic int gigaset_set_line_ctrl(struct cardstate *cs, unsigned cflag)\r\n{\r\nu16 val = 0;\r\nif (cflag & PARENB)\r\nval |= (cflag & PARODD) ? 0x10 : 0x20;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nval |= 5 << 8; break;\r\ncase CS6:\r\nval |= 6 << 8; break;\r\ncase CS7:\r\nval |= 7 << 8; break;\r\ncase CS8:\r\nval |= 8 << 8; break;\r\ndefault:\r\ndev_err(cs->dev, "CSIZE was not CS5-CS8, using default of 8\n");\r\nval |= 8 << 8;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB) {\r\nif ((cflag & CSIZE) == CS5)\r\nval |= 1;\r\nelse\r\nval |= 2;\r\n}\r\nreturn set_value(cs, 3, val);\r\n}\r\nstatic int gigaset_init_bchannel(struct bc_state *bcs)\r\n{\r\ngigaset_bchannel_up(bcs);\r\nreturn 0;\r\n}\r\nstatic int gigaset_close_bchannel(struct bc_state *bcs)\r\n{\r\ngigaset_bchannel_down(bcs);\r\nreturn 0;\r\n}\r\nstatic void gigaset_modem_fill(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nstruct bc_state *bcs = &cs->bcs[0];\r\nstruct cmdbuf_t *cb;\r\nint again;\r\ngig_dbg(DEBUG_OUTPUT, "modem_fill");\r\nif (cs->hw.usb->busy) {\r\ngig_dbg(DEBUG_OUTPUT, "modem_fill: busy");\r\nreturn;\r\n}\r\ndo {\r\nagain = 0;\r\nif (!bcs->tx_skb) {\r\ncb = cs->cmdbuf;\r\nif (cb) {\r\ngig_dbg(DEBUG_OUTPUT, "modem_fill: cb");\r\nif (send_cb(cs, cb) < 0) {\r\ngig_dbg(DEBUG_OUTPUT,\r\n"modem_fill: send_cb failed");\r\nagain = 1;\r\n}\r\n} else {\r\nbcs->tx_skb = skb_dequeue(&bcs->squeue);\r\nif (bcs->tx_skb)\r\ngig_dbg(DEBUG_INTR,\r\n"Dequeued skb (Adr: %lx)!",\r\n(unsigned long) bcs->tx_skb);\r\n}\r\n}\r\nif (bcs->tx_skb) {\r\ngig_dbg(DEBUG_OUTPUT, "modem_fill: tx_skb");\r\nif (write_modem(cs) < 0) {\r\ngig_dbg(DEBUG_OUTPUT,\r\n"modem_fill: write_modem failed");\r\nagain = 1;\r\n}\r\n}\r\n} while (again);\r\n}\r\nstatic void gigaset_read_int_callback(struct urb *urb)\r\n{\r\nstruct cardstate *cs = urb->context;\r\nstruct inbuf_t *inbuf = cs->inbuf;\r\nint status = urb->status;\r\nint r;\r\nunsigned numbytes;\r\nunsigned char *src;\r\nunsigned long flags;\r\nif (!status) {\r\nnumbytes = urb->actual_length;\r\nif (numbytes) {\r\nsrc = cs->hw.usb->rcvbuf;\r\nif (unlikely(*src))\r\ndev_warn(cs->dev,\r\n"%s: There was no leading 0, but 0x%02x!\n",\r\n__func__, (unsigned) *src);\r\n++src;\r\n--numbytes;\r\nif (gigaset_fill_inbuf(inbuf, src, numbytes)) {\r\ngig_dbg(DEBUG_INTR, "%s-->BH", __func__);\r\ngigaset_schedule_event(inbuf->cs);\r\n}\r\n} else\r\ngig_dbg(DEBUG_INTR, "Received zero block length");\r\n} else {\r\ngig_dbg(DEBUG_ANY, "%s - nonzero status received: %d",\r\n__func__, status);\r\nif (status == -ENOENT || status == -ESHUTDOWN)\r\nreturn;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!cs->connected) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\npr_err("%s: disconnected\n", __func__);\r\nreturn;\r\n}\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (r)\r\ndev_err(cs->dev, "error %d resubmitting URB\n", -r);\r\n}\r\nstatic void gigaset_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct cardstate *cs = urb->context;\r\nint status = urb->status;\r\nunsigned long flags;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ngig_dbg(DEBUG_ANY, "%s: killed", __func__);\r\ncs->hw.usb->busy = 0;\r\nreturn;\r\ndefault:\r\ndev_err(cs->dev, "bulk transfer failed (status %d)\n",\r\n-status);\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!cs->connected) {\r\npr_err("%s: disconnected\n", __func__);\r\n} else {\r\ncs->hw.usb->busy = 0;\r\ntasklet_schedule(&cs->write_tasklet);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\nstatic int send_cb(struct cardstate *cs, struct cmdbuf_t *cb)\r\n{\r\nstruct cmdbuf_t *tcb;\r\nunsigned long flags;\r\nint count;\r\nint status = -ENOENT;\r\nstruct usb_cardstate *ucs = cs->hw.usb;\r\ndo {\r\nif (!cb->len) {\r\ntcb = cb;\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\ncs->cmdbytes -= cs->curlen;\r\ngig_dbg(DEBUG_OUTPUT, "send_cb: sent %u bytes, %u left",\r\ncs->curlen, cs->cmdbytes);\r\ncs->cmdbuf = cb = cb->next;\r\nif (cb) {\r\ncb->prev = NULL;\r\ncs->curlen = cb->len;\r\n} else {\r\ncs->lastcmdbuf = NULL;\r\ncs->curlen = 0;\r\n}\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nif (tcb->wake_tasklet)\r\ntasklet_schedule(tcb->wake_tasklet);\r\nkfree(tcb);\r\n}\r\nif (cb) {\r\ncount = min(cb->len, ucs->bulk_out_size);\r\ngig_dbg(DEBUG_OUTPUT, "send_cb: send %d bytes", count);\r\nusb_fill_bulk_urb(ucs->bulk_out_urb, ucs->udev,\r\nusb_sndbulkpipe(ucs->udev,\r\nucs->bulk_out_endpointAddr & 0x0f),\r\ncb->buf + cb->offset, count,\r\ngigaset_write_bulk_callback, cs);\r\ncb->offset += count;\r\ncb->len -= count;\r\nucs->busy = 1;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nstatus = cs->connected ?\r\nusb_submit_urb(ucs->bulk_out_urb, GFP_ATOMIC) :\r\n-ENODEV;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (status) {\r\nucs->busy = 0;\r\ndev_err(cs->dev,\r\n"could not submit urb (error %d)\n",\r\n-status);\r\ncb->len = 0;\r\n}\r\n}\r\n} while (cb && status);\r\nreturn status;\r\n}\r\nstatic int gigaset_write_cmd(struct cardstate *cs, struct cmdbuf_t *cb)\r\n{\r\nunsigned long flags;\r\ngigaset_dbg_buffer(cs->mstate != MS_LOCKED ?\r\nDEBUG_TRANSCMD : DEBUG_LOCKCMD,\r\n"CMD Transmit", cb->len, cb->buf);\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\ncb->prev = cs->lastcmdbuf;\r\nif (cs->lastcmdbuf)\r\ncs->lastcmdbuf->next = cb;\r\nelse {\r\ncs->cmdbuf = cb;\r\ncs->curlen = cb->len;\r\n}\r\ncs->cmdbytes += cb->len;\r\ncs->lastcmdbuf = cb;\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->connected)\r\ntasklet_schedule(&cs->write_tasklet);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn cb->len;\r\n}\r\nstatic int gigaset_write_room(struct cardstate *cs)\r\n{\r\nunsigned bytes;\r\nbytes = cs->cmdbytes;\r\nreturn bytes < IF_WRITEBUF ? IF_WRITEBUF - bytes : 0;\r\n}\r\nstatic int gigaset_chars_in_buffer(struct cardstate *cs)\r\n{\r\nreturn cs->cmdbytes;\r\n}\r\nstatic int gigaset_brkchars(struct cardstate *cs, const unsigned char buf[6])\r\n{\r\nstruct usb_device *udev = cs->hw.usb->udev;\r\ngigaset_dbg_buffer(DEBUG_USBREQ, "brkchars", 6, buf);\r\nmemcpy(cs->hw.usb->bchars, buf, 6);\r\nreturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x19, 0x41,\r\n0, 0, &buf, 6, 2000);\r\n}\r\nstatic void gigaset_freebcshw(struct bc_state *bcs)\r\n{\r\n}\r\nstatic int gigaset_initbcshw(struct bc_state *bcs)\r\n{\r\nbcs->hw.usb = NULL;\r\nreturn 0;\r\n}\r\nstatic void gigaset_reinitbcshw(struct bc_state *bcs)\r\n{\r\n}\r\nstatic void gigaset_freecshw(struct cardstate *cs)\r\n{\r\ntasklet_kill(&cs->write_tasklet);\r\nkfree(cs->hw.usb);\r\n}\r\nstatic int gigaset_initcshw(struct cardstate *cs)\r\n{\r\nstruct usb_cardstate *ucs;\r\ncs->hw.usb = ucs =\r\nkmalloc(sizeof(struct usb_cardstate), GFP_KERNEL);\r\nif (!ucs) {\r\npr_err("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nucs->bchars[0] = 0;\r\nucs->bchars[1] = 0;\r\nucs->bchars[2] = 0;\r\nucs->bchars[3] = 0;\r\nucs->bchars[4] = 0x11;\r\nucs->bchars[5] = 0x13;\r\nucs->bulk_out_buffer = NULL;\r\nucs->bulk_out_urb = NULL;\r\nucs->read_urb = NULL;\r\ntasklet_init(&cs->write_tasklet,\r\ngigaset_modem_fill, (unsigned long) cs);\r\nreturn 0;\r\n}\r\nstatic int write_modem(struct cardstate *cs)\r\n{\r\nint ret = 0;\r\nint count;\r\nstruct bc_state *bcs = &cs->bcs[0];\r\nstruct usb_cardstate *ucs = cs->hw.usb;\r\nunsigned long flags;\r\ngig_dbg(DEBUG_OUTPUT, "len: %d...", bcs->tx_skb->len);\r\nif (!bcs->tx_skb->len) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\nreturn -EINVAL;\r\n}\r\ncount = min(bcs->tx_skb->len, (unsigned) ucs->bulk_out_size);\r\nskb_copy_from_linear_data(bcs->tx_skb, ucs->bulk_out_buffer, count);\r\nskb_pull(bcs->tx_skb, count);\r\nucs->busy = 1;\r\ngig_dbg(DEBUG_OUTPUT, "write_modem: send %d bytes", count);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->connected) {\r\nusb_fill_bulk_urb(ucs->bulk_out_urb, ucs->udev,\r\nusb_sndbulkpipe(ucs->udev,\r\nucs->bulk_out_endpointAddr &\r\n0x0f),\r\nucs->bulk_out_buffer, count,\r\ngigaset_write_bulk_callback, cs);\r\nret = usb_submit_urb(ucs->bulk_out_urb, GFP_ATOMIC);\r\n} else {\r\nret = -ENODEV;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (ret) {\r\ndev_err(cs->dev, "could not submit urb (error %d)\n", -ret);\r\nucs->busy = 0;\r\n}\r\nif (!bcs->tx_skb->len) {\r\ngigaset_skb_sent(bcs, bcs->tx_skb);\r\ngig_dbg(DEBUG_INTR, "kfree skb (Adr: %lx)!",\r\n(unsigned long) bcs->tx_skb);\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int gigaset_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nint retval;\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *hostif = interface->cur_altsetting;\r\nstruct cardstate *cs = NULL;\r\nstruct usb_cardstate *ucs = NULL;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint buffer_size;\r\ngig_dbg(DEBUG_ANY, "%s: Check if device matches ...", __func__);\r\nif ((le16_to_cpu(udev->descriptor.idVendor) != USB_M105_VENDOR_ID) ||\r\n(le16_to_cpu(udev->descriptor.idProduct) != USB_M105_PRODUCT_ID)) {\r\ngig_dbg(DEBUG_ANY, "device ID (0x%x, 0x%x) not for me - skip",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nreturn -ENODEV;\r\n}\r\nif (hostif->desc.bInterfaceNumber != 0) {\r\ngig_dbg(DEBUG_ANY, "interface %d not for me - skip",\r\nhostif->desc.bInterfaceNumber);\r\nreturn -ENODEV;\r\n}\r\nif (hostif->desc.bAlternateSetting != 0) {\r\ndev_notice(&udev->dev, "unsupported altsetting %d - skip",\r\nhostif->desc.bAlternateSetting);\r\nreturn -ENODEV;\r\n}\r\nif (hostif->desc.bInterfaceClass != 255) {\r\ndev_notice(&udev->dev, "unsupported interface class %d - skip",\r\nhostif->desc.bInterfaceClass);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&udev->dev, "%s: Device matched ... !\n", __func__);\r\ncs = gigaset_initcs(driver, 1, 1, 0, cidmode, GIGASET_MODULENAME);\r\nif (!cs)\r\nreturn -ENODEV;\r\nucs = cs->hw.usb;\r\nusb_get_dev(udev);\r\nucs->udev = udev;\r\nucs->interface = interface;\r\ncs->dev = &interface->dev;\r\nusb_set_intfdata(interface, cs);\r\nendpoint = &hostif->endpoint[0].desc;\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\nucs->bulk_out_size = buffer_size;\r\nucs->bulk_out_endpointAddr = endpoint->bEndpointAddress;\r\nucs->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!ucs->bulk_out_buffer) {\r\ndev_err(cs->dev, "Couldn't allocate bulk_out_buffer\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nucs->bulk_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ucs->bulk_out_urb) {\r\ndev_err(cs->dev, "Couldn't allocate bulk_out_urb\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nendpoint = &hostif->endpoint[1].desc;\r\nucs->busy = 0;\r\nucs->read_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ucs->read_urb) {\r\ndev_err(cs->dev, "No free urbs available\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\nucs->rcvbuf_size = buffer_size;\r\nucs->int_in_endpointAddr = endpoint->bEndpointAddress;\r\nucs->rcvbuf = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!ucs->rcvbuf) {\r\ndev_err(cs->dev, "Couldn't allocate rcvbuf\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nusb_fill_int_urb(ucs->read_urb, udev,\r\nusb_rcvintpipe(udev,\r\nendpoint->bEndpointAddress & 0x0f),\r\nucs->rcvbuf, buffer_size,\r\ngigaset_read_int_callback,\r\ncs, endpoint->bInterval);\r\nretval = usb_submit_urb(ucs->read_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(cs->dev, "Could not submit URB (error %d)\n", -retval);\r\ngoto error;\r\n}\r\nif (startmode == SM_LOCKED)\r\ncs->mstate = MS_LOCKED;\r\nretval = gigaset_start(cs);\r\nif (retval < 0) {\r\ntasklet_kill(&cs->write_tasklet);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nusb_kill_urb(ucs->read_urb);\r\nkfree(ucs->bulk_out_buffer);\r\nusb_free_urb(ucs->bulk_out_urb);\r\nkfree(ucs->rcvbuf);\r\nusb_free_urb(ucs->read_urb);\r\nusb_set_intfdata(interface, NULL);\r\nucs->read_urb = ucs->bulk_out_urb = NULL;\r\nucs->rcvbuf = ucs->bulk_out_buffer = NULL;\r\nusb_put_dev(ucs->udev);\r\nucs->udev = NULL;\r\nucs->interface = NULL;\r\ngigaset_freecs(cs);\r\nreturn retval;\r\n}\r\nstatic void gigaset_disconnect(struct usb_interface *interface)\r\n{\r\nstruct cardstate *cs;\r\nstruct usb_cardstate *ucs;\r\ncs = usb_get_intfdata(interface);\r\nucs = cs->hw.usb;\r\ndev_info(cs->dev, "disconnecting Gigaset USB adapter\n");\r\nusb_kill_urb(ucs->read_urb);\r\ngigaset_stop(cs);\r\nusb_set_intfdata(interface, NULL);\r\ntasklet_kill(&cs->write_tasklet);\r\nusb_kill_urb(ucs->bulk_out_urb);\r\nkfree(ucs->bulk_out_buffer);\r\nusb_free_urb(ucs->bulk_out_urb);\r\nkfree(ucs->rcvbuf);\r\nusb_free_urb(ucs->read_urb);\r\nucs->read_urb = ucs->bulk_out_urb = NULL;\r\nucs->rcvbuf = ucs->bulk_out_buffer = NULL;\r\nusb_put_dev(ucs->udev);\r\nucs->interface = NULL;\r\nucs->udev = NULL;\r\ncs->dev = NULL;\r\ngigaset_freecs(cs);\r\n}\r\nstatic int gigaset_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct cardstate *cs = usb_get_intfdata(intf);\r\ncs->connected = 0;\r\nusb_kill_urb(cs->hw.usb->read_urb);\r\ntasklet_kill(&cs->write_tasklet);\r\nusb_kill_urb(cs->hw.usb->bulk_out_urb);\r\ngig_dbg(DEBUG_SUSPEND, "suspend complete");\r\nreturn 0;\r\n}\r\nstatic int gigaset_resume(struct usb_interface *intf)\r\n{\r\nstruct cardstate *cs = usb_get_intfdata(intf);\r\nint rc;\r\ncs->connected = 1;\r\nrc = usb_submit_urb(cs->hw.usb->read_urb, GFP_KERNEL);\r\nif (rc) {\r\ndev_err(cs->dev, "Could not submit read URB (error %d)\n", -rc);\r\nreturn rc;\r\n}\r\ngig_dbg(DEBUG_SUSPEND, "resume complete");\r\nreturn 0;\r\n}\r\nstatic int gigaset_pre_reset(struct usb_interface *intf)\r\n{\r\nreturn gigaset_suspend(intf, PMSG_ON);\r\n}\r\nstatic int __init usb_gigaset_init(void)\r\n{\r\nint result;\r\ndriver = gigaset_initdriver(GIGASET_MINOR, GIGASET_MINORS,\r\nGIGASET_MODULENAME, GIGASET_DEVNAME,\r\n&ops, THIS_MODULE);\r\nif (driver == NULL) {\r\nresult = -ENOMEM;\r\ngoto error;\r\n}\r\nresult = usb_register(&gigaset_usb_driver);\r\nif (result < 0) {\r\npr_err("error %d registering USB driver\n", -result);\r\ngoto error;\r\n}\r\npr_info(DRIVER_DESC "\n");\r\nreturn 0;\r\nerror:\r\nif (driver)\r\ngigaset_freedriver(driver);\r\ndriver = NULL;\r\nreturn result;\r\n}\r\nstatic void __exit usb_gigaset_exit(void)\r\n{\r\nint i;\r\ngigaset_blockdriver(driver);\r\nfor (i = 0; i < driver->minors; i++)\r\ngigaset_shutdown(driver->cs + i);\r\nusb_deregister(&gigaset_usb_driver);\r\ngigaset_freedriver(driver);\r\ndriver = NULL;\r\n}
