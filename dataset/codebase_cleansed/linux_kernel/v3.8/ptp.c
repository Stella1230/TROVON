static int efx_ptp_enable(struct efx_nic *efx)\r\n{\r\nu8 inbuf[MC_CMD_PTP_IN_ENABLE_LEN];\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ENABLE);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_QUEUE,\r\nefx->ptp_data->channel->channel);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_MODE, efx->ptp_data->mode);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic int efx_ptp_disable(struct efx_nic *efx)\r\n{\r\nu8 inbuf[MC_CMD_PTP_IN_DISABLE_LEN];\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_DISABLE);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic void efx_ptp_deliver_rx_queue(struct sk_buff_head *q)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(q))) {\r\nlocal_bh_disable();\r\nnetif_receive_skb(skb);\r\nlocal_bh_enable();\r\n}\r\n}\r\nstatic void efx_ptp_handle_no_channel(struct efx_nic *efx)\r\n{\r\nnetif_err(efx, drv, efx->net_dev,\r\n"ERROR: PTP requires MSI-X and 1 additional interrupt"\r\n"vector. PTP disabled\n");\r\n}\r\nstatic void efx_ptp_send_times(struct efx_nic *efx,\r\nstruct pps_event_time *last_time)\r\n{\r\nstruct pps_event_time now;\r\nstruct timespec limit;\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct timespec start;\r\nint *mc_running = ptp->start.addr;\r\npps_get_ts(&now);\r\nstart = now.ts_real;\r\nlimit = now.ts_real;\r\ntimespec_add_ns(&limit, SYNCHRONISE_PERIOD_NS);\r\nwhile ((timespec_compare(&now.ts_real, &limit) < 0) &&\r\nACCESS_ONCE(*mc_running)) {\r\nstruct timespec update_time;\r\nunsigned int host_time;\r\nupdate_time = now.ts_real;\r\ntimespec_add_ns(&update_time, SYNCHRONISATION_GRANULARITY_NS);\r\ndo {\r\npps_get_ts(&now);\r\n} while ((timespec_compare(&now.ts_real, &update_time) < 0) &&\r\nACCESS_ONCE(*mc_running));\r\nhost_time = (now.ts_real.tv_sec << MC_NANOSECOND_BITS |\r\nnow.ts_real.tv_nsec);\r\n_efx_writed(efx, cpu_to_le32(host_time),\r\nFR_CZ_MC_TREG_SMEM + MC_SMEM_P0_PTP_TIME_OFST);\r\n}\r\n*last_time = now;\r\n}\r\nstatic void efx_ptp_read_timeset(u8 *data, struct efx_ptp_timeset *timeset)\r\n{\r\nunsigned start_ns, end_ns;\r\ntimeset->host_start = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_HOSTSTART);\r\ntimeset->seconds = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_SECONDS);\r\ntimeset->nanoseconds = MCDI_DWORD(data,\r\nPTP_OUT_SYNCHRONIZE_NANOSECONDS);\r\ntimeset->host_end = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_HOSTEND),\r\ntimeset->waitns = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_WAITNS);\r\nstart_ns = timeset->host_start & MC_NANOSECOND_MASK;\r\nend_ns = timeset->host_end & MC_NANOSECOND_MASK;\r\nif (end_ns < start_ns)\r\nend_ns += NSEC_PER_SEC;\r\ntimeset->window = end_ns - start_ns;\r\n}\r\nstatic int efx_ptp_process_times(struct efx_nic *efx, u8 *synch_buf,\r\nsize_t response_length,\r\nconst struct pps_event_time *last_time)\r\n{\r\nunsigned number_readings = (response_length /\r\nMC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_LEN);\r\nunsigned i;\r\nunsigned min;\r\nunsigned min_set = 0;\r\nunsigned total;\r\nunsigned ngood = 0;\r\nunsigned last_good = 0;\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nbool min_valid = false;\r\nu32 last_sec;\r\nu32 start_sec;\r\nstruct timespec delta;\r\nif (number_readings == 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < number_readings; i++) {\r\nefx_ptp_read_timeset(synch_buf, &ptp->timeset[i]);\r\nsynch_buf += MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_LEN;\r\nif (ptp->timeset[i].window > SYNCHRONISATION_GRANULARITY_NS) {\r\nif (min_valid) {\r\nif (ptp->timeset[i].window < min_set)\r\nmin_set = ptp->timeset[i].window;\r\n} else {\r\nmin_valid = true;\r\nmin_set = ptp->timeset[i].window;\r\n}\r\n}\r\n}\r\nif (min_valid) {\r\nif (ptp->base_sync_valid && (min_set > ptp->base_sync_ns))\r\nmin = ptp->base_sync_ns;\r\nelse\r\nmin = min_set;\r\n} else {\r\nmin = SYNCHRONISATION_GRANULARITY_NS;\r\n}\r\ntotal = 0;\r\nfor (i = 0; i < number_readings; i++)\r\nif (ptp->timeset[i].window > ptp->timeset[i].waitns) {\r\nunsigned win;\r\nwin = ptp->timeset[i].window - ptp->timeset[i].waitns;\r\nif (win >= MIN_SYNCHRONISATION_NS &&\r\nwin < MAX_SYNCHRONISATION_NS) {\r\ntotal += ptp->timeset[i].window;\r\nngood++;\r\nlast_good = i;\r\n}\r\n}\r\nif (ngood == 0) {\r\nnetif_warn(efx, drv, efx->net_dev,\r\n"PTP no suitable synchronisations %dns %dns\n",\r\nptp->base_sync_ns, min_set);\r\nreturn -EAGAIN;\r\n}\r\nptp->last_sync_ns = DIV_ROUND_UP(total, ngood);\r\nif (!ptp->base_sync_valid || (ptp->last_sync_ns < ptp->base_sync_ns)) {\r\nptp->base_sync_valid = true;\r\nptp->base_sync_ns = ptp->last_sync_ns;\r\n}\r\ndelta.tv_nsec =\r\nptp->timeset[last_good].nanoseconds +\r\nlast_time->ts_real.tv_nsec -\r\n(ptp->timeset[last_good].host_start & MC_NANOSECOND_MASK);\r\nstart_sec = ptp->timeset[last_good].host_start >> MC_NANOSECOND_BITS;\r\nlast_sec = last_time->ts_real.tv_sec & MC_SECOND_MASK;\r\nif (start_sec != last_sec) {\r\nif (((start_sec + 1) & MC_SECOND_MASK) != last_sec) {\r\nnetif_warn(efx, hw, efx->net_dev,\r\n"PTP bad synchronisation seconds\n");\r\nreturn -EAGAIN;\r\n} else {\r\ndelta.tv_sec = 1;\r\n}\r\n} else {\r\ndelta.tv_sec = 0;\r\n}\r\nptp->host_time_pps = *last_time;\r\npps_sub_ts(&ptp->host_time_pps, delta);\r\nreturn 0;\r\n}\r\nstatic int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nu8 synch_buf[MC_CMD_PTP_OUT_SYNCHRONIZE_LENMAX];\r\nsize_t response_length;\r\nint rc;\r\nunsigned long timeout;\r\nstruct pps_event_time last_time = {};\r\nunsigned int loops = 0;\r\nint *start = ptp->start.addr;\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_OP, MC_CMD_PTP_OP_SYNCHRONIZE);\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_NUMTIMESETS,\r\nnum_readings);\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_START_ADDR_LO,\r\n(u32)ptp->start.dma_addr);\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_START_ADDR_HI,\r\n(u32)((u64)ptp->start.dma_addr >> 32));\r\nACCESS_ONCE(*start) = 0;\r\nefx_mcdi_rpc_start(efx, MC_CMD_PTP, synch_buf,\r\nMC_CMD_PTP_IN_SYNCHRONIZE_LEN);\r\ntimeout = jiffies + msecs_to_jiffies(MAX_SYNCHRONISE_WAIT_MS);\r\nwhile (!ACCESS_ONCE(*start) && (time_before(jiffies, timeout))) {\r\nudelay(20);\r\nloops++;\r\n}\r\nif (ACCESS_ONCE(*start))\r\nefx_ptp_send_times(efx, &last_time);\r\nrc = efx_mcdi_rpc_finish(efx, MC_CMD_PTP,\r\nMC_CMD_PTP_IN_SYNCHRONIZE_LEN,\r\nsynch_buf, sizeof(synch_buf),\r\n&response_length);\r\nif (rc == 0)\r\nrc = efx_ptp_process_times(efx, synch_buf, response_length,\r\n&last_time);\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_xmit_skb(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nu8 *txbuf = efx->ptp_data->txbuf;\r\nstruct skb_shared_hwtstamps timestamps;\r\nint rc = -EIO;\r\nsize_t len = ALIGN(MC_CMD_PTP_IN_TRANSMIT_LEN(skb->len), 4);\r\nu8 txtime[MC_CMD_PTP_OUT_TRANSMIT_LEN];\r\nMCDI_SET_DWORD(txbuf, PTP_IN_OP, MC_CMD_PTP_OP_TRANSMIT);\r\nMCDI_SET_DWORD(txbuf, PTP_IN_TRANSMIT_LENGTH, skb->len);\r\nif (skb_shinfo(skb)->nr_frags != 0) {\r\nrc = skb_linearize(skb);\r\nif (rc != 0)\r\ngoto fail;\r\n}\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nrc = skb_checksum_help(skb);\r\nif (rc != 0)\r\ngoto fail;\r\n}\r\nskb_copy_from_linear_data(skb,\r\n&txbuf[MC_CMD_PTP_IN_TRANSMIT_PACKET_OFST],\r\nlen);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP, txbuf, len, txtime,\r\nsizeof(txtime), &len);\r\nif (rc != 0)\r\ngoto fail;\r\nmemset(&timestamps, 0, sizeof(timestamps));\r\ntimestamps.hwtstamp = ktime_set(\r\nMCDI_DWORD(txtime, PTP_OUT_TRANSMIT_SECONDS),\r\nMCDI_DWORD(txtime, PTP_OUT_TRANSMIT_NANOSECONDS));\r\nskb_tstamp_tx(skb, &timestamps);\r\nrc = 0;\r\nfail:\r\ndev_kfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic void efx_ptp_drop_time_expired_events(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct list_head *cursor;\r\nstruct list_head *next;\r\nspin_lock_bh(&ptp->evt_lock);\r\nif (!list_empty(&ptp->evt_list)) {\r\nlist_for_each_safe(cursor, next, &ptp->evt_list) {\r\nstruct efx_ptp_event_rx *evt;\r\nevt = list_entry(cursor, struct efx_ptp_event_rx,\r\nlink);\r\nif (time_after(jiffies, evt->expiry)) {\r\nlist_move(&evt->link, &ptp->evt_free_list);\r\nnetif_warn(efx, hw, efx->net_dev,\r\n"PTP rx event dropped\n");\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&ptp->evt_lock);\r\n}\r\nstatic enum ptp_packet_state efx_ptp_match_rx(struct efx_nic *efx,\r\nstruct sk_buff *skb)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nbool evts_waiting;\r\nstruct list_head *cursor;\r\nstruct list_head *next;\r\nstruct efx_ptp_match *match;\r\nenum ptp_packet_state rc = PTP_PACKET_STATE_UNMATCHED;\r\nspin_lock_bh(&ptp->evt_lock);\r\nevts_waiting = !list_empty(&ptp->evt_list);\r\nspin_unlock_bh(&ptp->evt_lock);\r\nif (!evts_waiting)\r\nreturn PTP_PACKET_STATE_UNMATCHED;\r\nmatch = (struct efx_ptp_match *)skb->cb;\r\nspin_lock_bh(&ptp->evt_lock);\r\nlist_for_each_safe(cursor, next, &ptp->evt_list) {\r\nstruct efx_ptp_event_rx *evt;\r\nevt = list_entry(cursor, struct efx_ptp_event_rx, link);\r\nif ((evt->seq0 == match->words[0]) &&\r\n(evt->seq1 == match->words[1])) {\r\nstruct skb_shared_hwtstamps *timestamps;\r\ntimestamps = skb_hwtstamps(skb);\r\ntimestamps->hwtstamp = evt->hwtimestamp;\r\nmatch->state = PTP_PACKET_STATE_MATCHED;\r\nrc = PTP_PACKET_STATE_MATCHED;\r\nlist_move(&evt->link, &ptp->evt_free_list);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&ptp->evt_lock);\r\nreturn rc;\r\n}\r\nstatic bool efx_ptp_process_events(struct efx_nic *efx, struct sk_buff_head *q)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nbool rc = false;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&ptp->rxq))) {\r\nstruct efx_ptp_match *match;\r\nmatch = (struct efx_ptp_match *)skb->cb;\r\nif (match->state == PTP_PACKET_STATE_MATCH_UNWANTED) {\r\n__skb_queue_tail(q, skb);\r\n} else if (efx_ptp_match_rx(efx, skb) ==\r\nPTP_PACKET_STATE_MATCHED) {\r\nrc = true;\r\n__skb_queue_tail(q, skb);\r\n} else if (time_after(jiffies, match->expiry)) {\r\nmatch->state = PTP_PACKET_STATE_TIMED_OUT;\r\nnetif_warn(efx, rx_err, efx->net_dev,\r\n"PTP packet - no timestamp seen\n");\r\n__skb_queue_tail(q, skb);\r\n} else {\r\nskb_queue_head(&ptp->rxq, skb);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic inline void efx_ptp_process_rx(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nlocal_bh_disable();\r\nnetif_receive_skb(skb);\r\nlocal_bh_enable();\r\n}\r\nstatic int efx_ptp_start(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct efx_filter_spec rxfilter;\r\nint rc;\r\nptp->reset_required = false;\r\nefx_filter_init_rx(&rxfilter, EFX_FILTER_PRI_REQUIRED, 0,\r\nefx_rx_queue_index(\r\nefx_channel_get_rx_queue(ptp->channel)));\r\nrc = efx_filter_set_ipv4_local(&rxfilter, IPPROTO_UDP,\r\nhtonl(PTP_ADDRESS),\r\nhtons(PTP_EVENT_PORT));\r\nif (rc != 0)\r\nreturn rc;\r\nrc = efx_filter_insert_filter(efx, &rxfilter, true);\r\nif (rc < 0)\r\nreturn rc;\r\nptp->rxfilter_event = rc;\r\nefx_filter_init_rx(&rxfilter, EFX_FILTER_PRI_REQUIRED, 0,\r\nefx_rx_queue_index(\r\nefx_channel_get_rx_queue(ptp->channel)));\r\nrc = efx_filter_set_ipv4_local(&rxfilter, IPPROTO_UDP,\r\nhtonl(PTP_ADDRESS),\r\nhtons(PTP_GENERAL_PORT));\r\nif (rc != 0)\r\ngoto fail;\r\nrc = efx_filter_insert_filter(efx, &rxfilter, true);\r\nif (rc < 0)\r\ngoto fail;\r\nptp->rxfilter_general = rc;\r\nrc = efx_ptp_enable(efx);\r\nif (rc != 0)\r\ngoto fail2;\r\nptp->evt_frag_idx = 0;\r\nptp->current_adjfreq = 0;\r\nptp->rxfilter_installed = true;\r\nreturn 0;\r\nfail2:\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_general);\r\nfail:\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_event);\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_stop(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nint rc = efx_ptp_disable(efx);\r\nstruct list_head *cursor;\r\nstruct list_head *next;\r\nif (ptp->rxfilter_installed) {\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_general);\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_event);\r\nptp->rxfilter_installed = false;\r\n}\r\nefx_ptp_deliver_rx_queue(&efx->ptp_data->rxq);\r\nskb_queue_purge(&efx->ptp_data->txq);\r\nspin_lock_bh(&efx->ptp_data->evt_lock);\r\nlist_for_each_safe(cursor, next, &efx->ptp_data->evt_list) {\r\nlist_move(cursor, &efx->ptp_data->evt_free_list);\r\n}\r\nspin_unlock_bh(&efx->ptp_data->evt_lock);\r\nreturn rc;\r\n}\r\nstatic void efx_ptp_pps_worker(struct work_struct *work)\r\n{\r\nstruct efx_ptp_data *ptp =\r\ncontainer_of(work, struct efx_ptp_data, pps_work);\r\nstruct efx_nic *efx = ptp->channel->efx;\r\nstruct ptp_clock_event ptp_evt;\r\nif (efx_ptp_synchronize(efx, PTP_SYNC_ATTEMPTS))\r\nreturn;\r\nptp_evt.type = PTP_CLOCK_PPSUSR;\r\nptp_evt.pps_times = ptp->host_time_pps;\r\nptp_clock_event(ptp->phc_clock, &ptp_evt);\r\n}\r\nstatic void efx_ptp_worker(struct work_struct *work)\r\n{\r\nstruct efx_ptp_data *ptp_data =\r\ncontainer_of(work, struct efx_ptp_data, work);\r\nstruct efx_nic *efx = ptp_data->channel->efx;\r\nstruct sk_buff *skb;\r\nstruct sk_buff_head tempq;\r\nif (ptp_data->reset_required) {\r\nefx_ptp_stop(efx);\r\nefx_ptp_start(efx);\r\nreturn;\r\n}\r\nefx_ptp_drop_time_expired_events(efx);\r\n__skb_queue_head_init(&tempq);\r\nif (efx_ptp_process_events(efx, &tempq) ||\r\n!skb_queue_empty(&ptp_data->txq)) {\r\nwhile ((skb = skb_dequeue(&ptp_data->txq)))\r\nefx_ptp_xmit_skb(efx, skb);\r\n}\r\nwhile ((skb = __skb_dequeue(&tempq)))\r\nefx_ptp_process_rx(efx, skb);\r\n}\r\nstatic int efx_ptp_probe_channel(struct efx_channel *channel)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nstruct efx_ptp_data *ptp;\r\nint rc = 0;\r\nunsigned int pos;\r\nchannel->irq_moderation = 0;\r\nchannel->rx_queue.core_index = 0;\r\nptp = kzalloc(sizeof(struct efx_ptp_data), GFP_KERNEL);\r\nefx->ptp_data = ptp;\r\nif (!efx->ptp_data)\r\nreturn -ENOMEM;\r\nrc = efx_nic_alloc_buffer(efx, &ptp->start, sizeof(int));\r\nif (rc != 0)\r\ngoto fail1;\r\nptp->channel = channel;\r\nskb_queue_head_init(&ptp->rxq);\r\nskb_queue_head_init(&ptp->txq);\r\nptp->workwq = create_singlethread_workqueue("sfc_ptp");\r\nif (!ptp->workwq) {\r\nrc = -ENOMEM;\r\ngoto fail2;\r\n}\r\nINIT_WORK(&ptp->work, efx_ptp_worker);\r\nptp->config.flags = 0;\r\nptp->config.tx_type = HWTSTAMP_TX_OFF;\r\nptp->config.rx_filter = HWTSTAMP_FILTER_NONE;\r\nINIT_LIST_HEAD(&ptp->evt_list);\r\nINIT_LIST_HEAD(&ptp->evt_free_list);\r\nspin_lock_init(&ptp->evt_lock);\r\nfor (pos = 0; pos < MAX_RECEIVE_EVENTS; pos++)\r\nlist_add(&ptp->rx_evts[pos].link, &ptp->evt_free_list);\r\nptp->phc_clock_info.owner = THIS_MODULE;\r\nsnprintf(ptp->phc_clock_info.name,\r\nsizeof(ptp->phc_clock_info.name),\r\n"%pm", efx->net_dev->perm_addr);\r\nptp->phc_clock_info.max_adj = MAX_PPB;\r\nptp->phc_clock_info.n_alarm = 0;\r\nptp->phc_clock_info.n_ext_ts = 0;\r\nptp->phc_clock_info.n_per_out = 0;\r\nptp->phc_clock_info.pps = 1;\r\nptp->phc_clock_info.adjfreq = efx_phc_adjfreq;\r\nptp->phc_clock_info.adjtime = efx_phc_adjtime;\r\nptp->phc_clock_info.gettime = efx_phc_gettime;\r\nptp->phc_clock_info.settime = efx_phc_settime;\r\nptp->phc_clock_info.enable = efx_phc_enable;\r\nptp->phc_clock = ptp_clock_register(&ptp->phc_clock_info,\r\n&efx->pci_dev->dev);\r\nif (!ptp->phc_clock)\r\ngoto fail3;\r\nINIT_WORK(&ptp->pps_work, efx_ptp_pps_worker);\r\nptp->pps_workwq = create_singlethread_workqueue("sfc_pps");\r\nif (!ptp->pps_workwq) {\r\nrc = -ENOMEM;\r\ngoto fail4;\r\n}\r\nptp->nic_ts_enabled = false;\r\nreturn 0;\r\nfail4:\r\nptp_clock_unregister(efx->ptp_data->phc_clock);\r\nfail3:\r\ndestroy_workqueue(efx->ptp_data->workwq);\r\nfail2:\r\nefx_nic_free_buffer(efx, &ptp->start);\r\nfail1:\r\nkfree(efx->ptp_data);\r\nefx->ptp_data = NULL;\r\nreturn rc;\r\n}\r\nstatic void efx_ptp_remove_channel(struct efx_channel *channel)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nif (!efx->ptp_data)\r\nreturn;\r\n(void)efx_ptp_disable(channel->efx);\r\ncancel_work_sync(&efx->ptp_data->work);\r\ncancel_work_sync(&efx->ptp_data->pps_work);\r\nskb_queue_purge(&efx->ptp_data->rxq);\r\nskb_queue_purge(&efx->ptp_data->txq);\r\nptp_clock_unregister(efx->ptp_data->phc_clock);\r\ndestroy_workqueue(efx->ptp_data->workwq);\r\ndestroy_workqueue(efx->ptp_data->pps_workwq);\r\nefx_nic_free_buffer(efx, &efx->ptp_data->start);\r\nkfree(efx->ptp_data);\r\n}\r\nstatic void efx_ptp_get_channel_name(struct efx_channel *channel,\r\nchar *buf, size_t len)\r\n{\r\nsnprintf(buf, len, "%s-ptp", channel->efx->name);\r\n}\r\nbool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nreturn efx->ptp_data &&\r\nefx->ptp_data->enabled &&\r\nskb->len >= PTP_MIN_LENGTH &&\r\nskb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM &&\r\nlikely(skb->protocol == htons(ETH_P_IP)) &&\r\nip_hdr(skb)->protocol == IPPROTO_UDP &&\r\nudp_hdr(skb)->dest == htons(PTP_EVENT_PORT);\r\n}\r\nstatic void efx_ptp_rx(struct efx_channel *channel, struct sk_buff *skb)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct efx_ptp_match *match = (struct efx_ptp_match *)skb->cb;\r\nu8 *data;\r\nunsigned int version;\r\nmatch->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);\r\nif (ptp->mode == MC_CMD_PTP_MODE_V1) {\r\nif (skb->len < PTP_V1_MIN_LENGTH) {\r\nnetif_receive_skb(skb);\r\nreturn;\r\n}\r\nversion = ntohs(*(__be16 *)&skb->data[PTP_V1_VERSION_OFFSET]);\r\nif (version != PTP_VERSION_V1) {\r\nnetif_receive_skb(skb);\r\nreturn;\r\n}\r\n} else {\r\nif (skb->len < PTP_V2_MIN_LENGTH) {\r\nnetif_receive_skb(skb);\r\nreturn;\r\n}\r\nversion = skb->data[PTP_V2_VERSION_OFFSET];\r\nBUG_ON(ptp->mode != MC_CMD_PTP_MODE_V2);\r\nBUILD_BUG_ON(PTP_V1_UUID_OFFSET != PTP_V2_MC_UUID_OFFSET);\r\nBUILD_BUG_ON(PTP_V1_UUID_LENGTH != PTP_V2_MC_UUID_LENGTH);\r\nBUILD_BUG_ON(PTP_V1_SEQUENCE_OFFSET != PTP_V2_SEQUENCE_OFFSET);\r\nBUILD_BUG_ON(PTP_V1_SEQUENCE_LENGTH != PTP_V2_SEQUENCE_LENGTH);\r\nif ((version & PTP_VERSION_V2_MASK) != PTP_VERSION_V2) {\r\nnetif_receive_skb(skb);\r\nreturn;\r\n}\r\n}\r\nif (ntohs(*(__be16 *)&skb->data[PTP_DPORT_OFFSET]) == PTP_EVENT_PORT) {\r\nstruct skb_shared_hwtstamps *timestamps;\r\nmatch->state = PTP_PACKET_STATE_UNMATCHED;\r\ntimestamps = skb_hwtstamps(skb);\r\nmemset(timestamps, 0, sizeof(*timestamps));\r\ndata = skb->data + PTP_V1_UUID_OFFSET;\r\nmatch->words[0] = (data[0] |\r\n(data[1] << 8) |\r\n(data[2] << 16) |\r\n(data[3] << 24));\r\nmatch->words[1] = (data[4] |\r\n(data[5] << 8) |\r\n(skb->data[PTP_V1_SEQUENCE_OFFSET +\r\nPTP_V1_SEQUENCE_LENGTH - 1] <<\r\n16));\r\n} else {\r\nmatch->state = PTP_PACKET_STATE_MATCH_UNWANTED;\r\n}\r\nskb_queue_tail(&ptp->rxq, skb);\r\nqueue_work(ptp->workwq, &ptp->work);\r\n}\r\nint efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nskb_queue_tail(&ptp->txq, skb);\r\nif ((udp_hdr(skb)->dest == htons(PTP_EVENT_PORT)) &&\r\n(skb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM))\r\nefx_xmit_hwtstamp_pending(skb);\r\nqueue_work(ptp->workwq, &ptp->work);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int efx_ptp_change_mode(struct efx_nic *efx, bool enable_wanted,\r\nunsigned int new_mode)\r\n{\r\nif ((enable_wanted != efx->ptp_data->enabled) ||\r\n(enable_wanted && (efx->ptp_data->mode != new_mode))) {\r\nint rc;\r\nif (enable_wanted) {\r\nif (efx->ptp_data->enabled &&\r\n(efx->ptp_data->mode != new_mode)) {\r\nefx->ptp_data->enabled = false;\r\nrc = efx_ptp_stop(efx);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nefx->ptp_data->mode = new_mode;\r\nrc = efx_ptp_start(efx);\r\nif (rc == 0) {\r\nrc = efx_ptp_synchronize(efx,\r\nPTP_SYNC_ATTEMPTS * 2);\r\nif (rc != 0)\r\nefx_ptp_stop(efx);\r\n}\r\n} else {\r\nrc = efx_ptp_stop(efx);\r\n}\r\nif (rc != 0)\r\nreturn rc;\r\nefx->ptp_data->enabled = enable_wanted;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_ptp_ts_init(struct efx_nic *efx, struct hwtstamp_config *init)\r\n{\r\nbool enable_wanted = false;\r\nunsigned int new_mode;\r\nint rc;\r\nif (init->flags)\r\nreturn -EINVAL;\r\nif ((init->tx_type != HWTSTAMP_TX_OFF) &&\r\n(init->tx_type != HWTSTAMP_TX_ON))\r\nreturn -ERANGE;\r\nnew_mode = efx->ptp_data->mode;\r\nswitch (init->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ninit->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nnew_mode = MC_CMD_PTP_MODE_V1;\r\nenable_wanted = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ninit->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nnew_mode = MC_CMD_PTP_MODE_V2;\r\nenable_wanted = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\nreturn -ERANGE;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nif (init->tx_type != HWTSTAMP_TX_OFF)\r\nenable_wanted = true;\r\nrc = efx_ptp_change_mode(efx, enable_wanted, new_mode);\r\nif (rc != 0)\r\nreturn rc;\r\nefx->ptp_data->config = *init;\r\nreturn 0;\r\n}\r\nint\r\nefx_ptp_get_ts_info(struct net_device *net_dev, struct ethtool_ts_info *ts_info)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nif (!ptp)\r\nreturn -EOPNOTSUPP;\r\nts_info->so_timestamping = (SOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE);\r\nts_info->phc_index = ptp_clock_index(ptp->phc_clock);\r\nts_info->tx_types = 1 << HWTSTAMP_TX_OFF | 1 << HWTSTAMP_TX_ON;\r\nts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE |\r\n1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT |\r\n1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC |\r\n1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ |\r\n1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT |\r\n1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC |\r\n1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);\r\nreturn 0;\r\n}\r\nint efx_ptp_ioctl(struct efx_nic *efx, struct ifreq *ifr, int cmd)\r\n{\r\nstruct hwtstamp_config config;\r\nint rc;\r\nif (!efx->ptp_data)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nrc = efx_ptp_ts_init(efx, &config);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config))\r\n? -EFAULT : 0;\r\n}\r\nstatic void ptp_event_failure(struct efx_nic *efx, int expected_frag_len)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP unexpected event length: got %d expected %d\n",\r\nptp->evt_frag_idx, expected_frag_len);\r\nptp->reset_required = true;\r\nqueue_work(ptp->workwq, &ptp->work);\r\n}\r\nstatic void ptp_event_rx(struct efx_nic *efx, struct efx_ptp_data *ptp)\r\n{\r\nstruct efx_ptp_event_rx *evt = NULL;\r\nif (ptp->evt_frag_idx != 3) {\r\nptp_event_failure(efx, 3);\r\nreturn;\r\n}\r\nspin_lock_bh(&ptp->evt_lock);\r\nif (!list_empty(&ptp->evt_free_list)) {\r\nevt = list_first_entry(&ptp->evt_free_list,\r\nstruct efx_ptp_event_rx, link);\r\nlist_del(&evt->link);\r\nevt->seq0 = EFX_QWORD_FIELD(ptp->evt_frags[2], MCDI_EVENT_DATA);\r\nevt->seq1 = (EFX_QWORD_FIELD(ptp->evt_frags[2],\r\nMCDI_EVENT_SRC) |\r\n(EFX_QWORD_FIELD(ptp->evt_frags[1],\r\nMCDI_EVENT_SRC) << 8) |\r\n(EFX_QWORD_FIELD(ptp->evt_frags[0],\r\nMCDI_EVENT_SRC) << 16));\r\nevt->hwtimestamp = ktime_set(\r\nEFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA),\r\nEFX_QWORD_FIELD(ptp->evt_frags[1], MCDI_EVENT_DATA));\r\nevt->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);\r\nlist_add_tail(&evt->link, &ptp->evt_list);\r\nqueue_work(ptp->workwq, &ptp->work);\r\n} else {\r\nnetif_err(efx, rx_err, efx->net_dev, "No free PTP event");\r\n}\r\nspin_unlock_bh(&ptp->evt_lock);\r\n}\r\nstatic void ptp_event_fault(struct efx_nic *efx, struct efx_ptp_data *ptp)\r\n{\r\nint code = EFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA);\r\nif (ptp->evt_frag_idx != 1) {\r\nptp_event_failure(efx, 1);\r\nreturn;\r\n}\r\nnetif_err(efx, hw, efx->net_dev, "PTP error %d\n", code);\r\n}\r\nstatic void ptp_event_pps(struct efx_nic *efx, struct efx_ptp_data *ptp)\r\n{\r\nif (ptp->nic_ts_enabled)\r\nqueue_work(ptp->pps_workwq, &ptp->pps_work);\r\n}\r\nvoid efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nint code = EFX_QWORD_FIELD(*ev, MCDI_EVENT_CODE);\r\nif (!ptp->enabled)\r\nreturn;\r\nif (ptp->evt_frag_idx == 0) {\r\nptp->evt_code = code;\r\n} else if (ptp->evt_code != code) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP out of sequence event %d\n", code);\r\nptp->evt_frag_idx = 0;\r\n}\r\nptp->evt_frags[ptp->evt_frag_idx++] = *ev;\r\nif (!MCDI_EVENT_FIELD(*ev, CONT)) {\r\nswitch (code) {\r\ncase MCDI_EVENT_CODE_PTP_RX:\r\nptp_event_rx(efx, ptp);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PTP_FAULT:\r\nptp_event_fault(efx, ptp);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PTP_PPS:\r\nptp_event_pps(efx, ptp);\r\nbreak;\r\ndefault:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP unknown event %d\n", code);\r\nbreak;\r\n}\r\nptp->evt_frag_idx = 0;\r\n} else if (MAX_EVENT_FRAGS == ptp->evt_frag_idx) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP too many event fragments\n");\r\nptp->evt_frag_idx = 0;\r\n}\r\n}\r\nstatic int efx_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nstruct efx_nic *efx = ptp_data->channel->efx;\r\nu8 inadj[MC_CMD_PTP_IN_ADJUST_LEN];\r\ns64 adjustment_ns;\r\nint rc;\r\nif (delta > MAX_PPB)\r\ndelta = MAX_PPB;\r\nelse if (delta < -MAX_PPB)\r\ndelta = -MAX_PPB;\r\nadjustment_ns = (((s64)delta * PPB_SCALE_WORD) >>\r\n(PPB_EXTRA_BITS + MAX_PPB_BITS));\r\nMCDI_SET_DWORD(inadj, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);\r\nMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_FREQ_LO, (u32)adjustment_ns);\r\nMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_FREQ_HI,\r\n(u32)(adjustment_ns >> 32));\r\nMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_SECONDS, 0);\r\nMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_NANOSECONDS, 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP, inadj, sizeof(inadj),\r\nNULL, 0, NULL);\r\nif (rc != 0)\r\nreturn rc;\r\nptp_data->current_adjfreq = delta;\r\nreturn 0;\r\n}\r\nstatic int efx_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nstruct efx_nic *efx = ptp_data->channel->efx;\r\nstruct timespec delta_ts = ns_to_timespec(delta);\r\nu8 inbuf[MC_CMD_PTP_IN_ADJUST_LEN];\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_FREQ_LO, 0);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_FREQ_HI, 0);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_SECONDS, (u32)delta_ts.tv_sec);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_NANOSECONDS, (u32)delta_ts.tv_nsec);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic int efx_phc_gettime(struct ptp_clock_info *ptp, struct timespec *ts)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nstruct efx_nic *efx = ptp_data->channel->efx;\r\nu8 inbuf[MC_CMD_PTP_IN_READ_NIC_TIME_LEN];\r\nu8 outbuf[MC_CMD_PTP_OUT_READ_NIC_TIME_LEN];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_READ_NIC_TIME);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc != 0)\r\nreturn rc;\r\nts->tv_sec = MCDI_DWORD(outbuf, PTP_OUT_READ_NIC_TIME_SECONDS);\r\nts->tv_nsec = MCDI_DWORD(outbuf, PTP_OUT_READ_NIC_TIME_NANOSECONDS);\r\nreturn 0;\r\n}\r\nstatic int efx_phc_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec *e_ts)\r\n{\r\nint rc;\r\nstruct timespec time_now;\r\nstruct timespec delta;\r\nrc = efx_phc_gettime(ptp, &time_now);\r\nif (rc != 0)\r\nreturn rc;\r\ndelta = timespec_sub(*e_ts, time_now);\r\nefx_phc_adjtime(ptp, timespec_to_ns(&delta));\r\nif (rc != 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int efx_phc_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *request,\r\nint enable)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nif (request->type != PTP_CLK_REQ_PPS)\r\nreturn -EOPNOTSUPP;\r\nptp_data->nic_ts_enabled = !!enable;\r\nreturn 0;\r\n}\r\nvoid efx_ptp_probe(struct efx_nic *efx)\r\n{\r\nif (efx_ptp_disable(efx) == 0)\r\nefx->extra_channel_type[EFX_EXTRA_CHANNEL_PTP] =\r\n&efx_ptp_channel_type;\r\n}
