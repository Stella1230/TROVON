static inline void\r\ndecode_bits(const char *prefix, const struct bits *bits, int num, u32 val)\r\n{\r\nprintk("%s %08x: ", prefix, val);\r\nwhile (num--) {\r\nconst char *str = val & bits->mask ? bits->set : bits->unset;\r\nif (str)\r\nprintk("%s ", str);\r\nbits++;\r\n}\r\n}\r\nstatic void decode_ISR(unsigned int val)\r\n{\r\ndecode_bits(KERN_DEBUG "ISR", isr_bits, ARRAY_SIZE(isr_bits), val);\r\nprintk("\n");\r\n}\r\nstatic void decode_ICR(unsigned int val)\r\n{\r\ndecode_bits(KERN_DEBUG "ICR", icr_bits, ARRAY_SIZE(icr_bits), val);\r\nprintk("\n");\r\n}\r\nstatic void i2c_pxa_show_state(struct pxa_i2c *i2c, int lno, const char *fname)\r\n{\r\ndev_dbg(&i2c->adap.dev, "state:%s:%d: ISR=%08x, ICR=%08x, IBMR=%02x\n", fname, lno,\r\nreadl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));\r\n}\r\nstatic void i2c_pxa_scream_blue_murder(struct pxa_i2c *i2c, const char *why)\r\n{\r\nunsigned int i;\r\nprintk(KERN_ERR "i2c: error: %s\n", why);\r\nprintk(KERN_ERR "i2c: msg_num: %d msg_idx: %d msg_ptr: %d\n",\r\ni2c->msg_num, i2c->msg_idx, i2c->msg_ptr);\r\nprintk(KERN_ERR "i2c: ICR: %08x ISR: %08x\n",\r\nreadl(_ICR(i2c)), readl(_ISR(i2c)));\r\nprintk(KERN_DEBUG "i2c: log: ");\r\nfor (i = 0; i < i2c->irqlogidx; i++)\r\nprintk("[%08x:%08x] ", i2c->isrlog[i], i2c->icrlog[i]);\r\nprintk("\n");\r\n}\r\nstatic inline int i2c_pxa_is_slavemode(struct pxa_i2c *i2c)\r\n{\r\nreturn !(readl(_ICR(i2c)) & ICR_SCLE);\r\n}\r\nstatic void i2c_pxa_abort(struct pxa_i2c *i2c)\r\n{\r\nint i = 250;\r\nif (i2c_pxa_is_slavemode(i2c)) {\r\ndev_dbg(&i2c->adap.dev, "%s: called in slave mode\n", __func__);\r\nreturn;\r\n}\r\nwhile ((i > 0) && (readl(_IBMR(i2c)) & 0x1) == 0) {\r\nunsigned long icr = readl(_ICR(i2c));\r\nicr &= ~ICR_START;\r\nicr |= ICR_ACKNAK | ICR_STOP | ICR_TB;\r\nwritel(icr, _ICR(i2c));\r\nshow_state(i2c);\r\nmdelay(1);\r\ni --;\r\n}\r\nwritel(readl(_ICR(i2c)) & ~(ICR_MA | ICR_START | ICR_STOP),\r\n_ICR(i2c));\r\n}\r\nstatic int i2c_pxa_wait_bus_not_busy(struct pxa_i2c *i2c)\r\n{\r\nint timeout = DEF_TIMEOUT;\r\nwhile (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {\r\nif ((readl(_ISR(i2c)) & ISR_SAD) != 0)\r\ntimeout += 4;\r\nmsleep(2);\r\nshow_state(i2c);\r\n}\r\nif (timeout < 0)\r\nshow_state(i2c);\r\nreturn timeout < 0 ? I2C_RETRY : 0;\r\n}\r\nstatic int i2c_pxa_wait_master(struct pxa_i2c *i2c)\r\n{\r\nunsigned long timeout = jiffies + HZ*4;\r\nwhile (time_before(jiffies, timeout)) {\r\nif (i2c_debug > 1)\r\ndev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",\r\n__func__, (long)jiffies, readl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));\r\nif (readl(_ISR(i2c)) & ISR_SAD) {\r\nif (i2c_debug > 0)\r\ndev_dbg(&i2c->adap.dev, "%s: Slave detected\n", __func__);\r\ngoto out;\r\n}\r\nif ((readl(_ISR(i2c)) & (ISR_UB | ISR_IBB)) == 0 && readl(_IBMR(i2c)) == 3) {\r\nif (i2c_debug > 0)\r\ndev_dbg(&i2c->adap.dev, "%s: done\n", __func__);\r\nreturn 1;\r\n}\r\nmsleep(1);\r\n}\r\nif (i2c_debug > 0)\r\ndev_dbg(&i2c->adap.dev, "%s: did not free\n", __func__);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_set_master(struct pxa_i2c *i2c)\r\n{\r\nif (i2c_debug)\r\ndev_dbg(&i2c->adap.dev, "setting to bus master\n");\r\nif ((readl(_ISR(i2c)) & (ISR_UB | ISR_IBB)) != 0) {\r\ndev_dbg(&i2c->adap.dev, "%s: unit is busy\n", __func__);\r\nif (!i2c_pxa_wait_master(i2c)) {\r\ndev_dbg(&i2c->adap.dev, "%s: error: unit busy\n", __func__);\r\nreturn I2C_RETRY;\r\n}\r\n}\r\nwritel(readl(_ICR(i2c)) | ICR_SCLE, _ICR(i2c));\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_wait_slave(struct pxa_i2c *i2c)\r\n{\r\nunsigned long timeout = jiffies + HZ*1;\r\nshow_state(i2c);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (i2c_debug > 1)\r\ndev_dbg(&i2c->adap.dev, "%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",\r\n__func__, (long)jiffies, readl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));\r\nif ((readl(_ISR(i2c)) & (ISR_UB|ISR_IBB)) == 0 ||\r\n(readl(_ISR(i2c)) & ISR_SAD) != 0 ||\r\n(readl(_ICR(i2c)) & ICR_SCLE) == 0) {\r\nif (i2c_debug > 1)\r\ndev_dbg(&i2c->adap.dev, "%s: done\n", __func__);\r\nreturn 1;\r\n}\r\nmsleep(1);\r\n}\r\nif (i2c_debug > 0)\r\ndev_dbg(&i2c->adap.dev, "%s: did not free\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void i2c_pxa_set_slave(struct pxa_i2c *i2c, int errcode)\r\n{\r\nshow_state(i2c);\r\nif (errcode < 0) {\r\nudelay(100);\r\n} else {\r\nif (readl(_ICR(i2c)) & ICR_STOP) {\r\nudelay(100);\r\nwritel(readl(_ICR(i2c)) & ~ICR_STOP, _ICR(i2c));\r\n}\r\nif (!i2c_pxa_wait_slave(i2c)) {\r\ndev_err(&i2c->adap.dev, "%s: wait timedout\n",\r\n__func__);\r\nreturn;\r\n}\r\n}\r\nwritel(readl(_ICR(i2c)) & ~(ICR_STOP|ICR_ACKNAK|ICR_MA), _ICR(i2c));\r\nwritel(readl(_ICR(i2c)) & ~ICR_SCLE, _ICR(i2c));\r\nif (i2c_debug) {\r\ndev_dbg(&i2c->adap.dev, "ICR now %08x, ISR %08x\n", readl(_ICR(i2c)), readl(_ISR(i2c)));\r\ndecode_ICR(readl(_ICR(i2c)));\r\n}\r\n}\r\nstatic void i2c_pxa_reset(struct pxa_i2c *i2c)\r\n{\r\npr_debug("Resetting I2C Controller Unit\n");\r\ni2c_pxa_abort(i2c);\r\nwritel(ICR_UR, _ICR(i2c));\r\nwritel(I2C_ISR_INIT, _ISR(i2c));\r\nwritel(readl(_ICR(i2c)) & ~ICR_UR, _ICR(i2c));\r\nif (i2c->reg_isar)\r\nwritel(i2c->slave_addr, _ISAR(i2c));\r\nwritel(I2C_ICR_INIT | (i2c->fast_mode ? ICR_FM : 0), _ICR(i2c));\r\n#ifdef CONFIG_I2C_PXA_SLAVE\r\ndev_info(&i2c->adap.dev, "Enabling slave mode\n");\r\nwritel(readl(_ICR(i2c)) | ICR_SADIE | ICR_ALDIE | ICR_SSDIE, _ICR(i2c));\r\n#endif\r\ni2c_pxa_set_slave(i2c, 0);\r\nwritel(readl(_ICR(i2c)) | ICR_IUE, _ICR(i2c));\r\nudelay(100);\r\n}\r\nstatic void i2c_pxa_slave_txempty(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nif (isr & ISR_BED) {\r\n} else {\r\nint ret = 0;\r\nif (i2c->slave != NULL)\r\nret = i2c->slave->read(i2c->slave->data);\r\nwritel(ret, _IDBR(i2c));\r\nwritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\r\n}\r\n}\r\nstatic void i2c_pxa_slave_rxfull(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nunsigned int byte = readl(_IDBR(i2c));\r\nif (i2c->slave != NULL)\r\ni2c->slave->write(i2c->slave->data, byte);\r\nwritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\r\n}\r\nstatic void i2c_pxa_slave_start(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nint timeout;\r\nif (i2c_debug > 0)\r\ndev_dbg(&i2c->adap.dev, "SAD, mode is slave-%cx\n",\r\n(isr & ISR_RWM) ? 'r' : 't');\r\nif (i2c->slave != NULL)\r\ni2c->slave->event(i2c->slave->data,\r\n(isr & ISR_RWM) ? I2C_SLAVE_EVENT_START_READ : I2C_SLAVE_EVENT_START_WRITE);\r\nwritel(readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP), _ICR(i2c));\r\nwritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\r\ntimeout = 0x10000;\r\nwhile (1) {\r\nif ((readl(_IBMR(i2c)) & 2) == 2)\r\nbreak;\r\ntimeout--;\r\nif (timeout <= 0) {\r\ndev_err(&i2c->adap.dev, "timeout waiting for SCL high\n");\r\nbreak;\r\n}\r\n}\r\nwritel(readl(_ICR(i2c)) & ~ICR_SCLE, _ICR(i2c));\r\n}\r\nstatic void i2c_pxa_slave_stop(struct pxa_i2c *i2c)\r\n{\r\nif (i2c_debug > 2)\r\ndev_dbg(&i2c->adap.dev, "ISR: SSD (Slave Stop)\n");\r\nif (i2c->slave != NULL)\r\ni2c->slave->event(i2c->slave->data, I2C_SLAVE_EVENT_STOP);\r\nif (i2c_debug > 2)\r\ndev_dbg(&i2c->adap.dev, "ISR: SSD (Slave Stop) acked\n");\r\nif (i2c->msg)\r\ni2c_pxa_master_complete(i2c, I2C_RETRY);\r\n}\r\nstatic void i2c_pxa_slave_txempty(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nif (isr & ISR_BED) {\r\n} else {\r\nwritel(0, _IDBR(i2c));\r\nwritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\r\n}\r\n}\r\nstatic void i2c_pxa_slave_rxfull(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nwritel(readl(_ICR(i2c)) | ICR_TB | ICR_ACKNAK, _ICR(i2c));\r\n}\r\nstatic void i2c_pxa_slave_start(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nint timeout;\r\nwritel(readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP), _ICR(i2c));\r\nwritel(readl(_ICR(i2c)) | ICR_TB | ICR_ACKNAK, _ICR(i2c));\r\ntimeout = 0x10000;\r\nwhile (1) {\r\nif ((readl(_IBMR(i2c)) & 2) == 2)\r\nbreak;\r\ntimeout--;\r\nif (timeout <= 0) {\r\ndev_err(&i2c->adap.dev, "timeout waiting for SCL high\n");\r\nbreak;\r\n}\r\n}\r\nwritel(readl(_ICR(i2c)) & ~ICR_SCLE, _ICR(i2c));\r\n}\r\nstatic void i2c_pxa_slave_stop(struct pxa_i2c *i2c)\r\n{\r\nif (i2c->msg)\r\ni2c_pxa_master_complete(i2c, I2C_RETRY);\r\n}\r\nstatic inline unsigned int i2c_pxa_addr_byte(struct i2c_msg *msg)\r\n{\r\nunsigned int addr = (msg->addr & 0x7f) << 1;\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 1;\r\nreturn addr;\r\n}\r\nstatic inline void i2c_pxa_start_message(struct pxa_i2c *i2c)\r\n{\r\nu32 icr;\r\nwritel(i2c_pxa_addr_byte(i2c->msg), _IDBR(i2c));\r\nicr = readl(_ICR(i2c)) & ~(ICR_STOP | ICR_ALDIE);\r\nwritel(icr | ICR_START | ICR_TB, _ICR(i2c));\r\n}\r\nstatic inline void i2c_pxa_stop_message(struct pxa_i2c *i2c)\r\n{\r\nu32 icr;\r\nicr = readl(_ICR(i2c));\r\nicr &= ~(ICR_STOP | ICR_ACKNAK);\r\nwritel(icr, _ICR(i2c));\r\n}\r\nstatic int i2c_pxa_pio_set_master(struct pxa_i2c *i2c)\r\n{\r\nlong timeout = 2 * DEF_TIMEOUT;\r\nwhile (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {\r\nudelay(1000);\r\nshow_state(i2c);\r\n}\r\nif (timeout < 0) {\r\nshow_state(i2c);\r\ndev_err(&i2c->adap.dev,\r\n"i2c_pxa: timeout waiting for bus free\n");\r\nreturn I2C_RETRY;\r\n}\r\nwritel(readl(_ICR(i2c)) | ICR_SCLE, _ICR(i2c));\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,\r\nstruct i2c_msg *msg, int num)\r\n{\r\nunsigned long timeout = 500000;\r\nint ret = 0;\r\nret = i2c_pxa_pio_set_master(i2c);\r\nif (ret)\r\ngoto out;\r\ni2c->msg = msg;\r\ni2c->msg_num = num;\r\ni2c->msg_idx = 0;\r\ni2c->msg_ptr = 0;\r\ni2c->irqlogidx = 0;\r\ni2c_pxa_start_message(i2c);\r\nwhile (i2c->msg_num > 0 && --timeout) {\r\ni2c_pxa_handler(0, i2c);\r\nudelay(10);\r\n}\r\ni2c_pxa_stop_message(i2c);\r\nret = i2c->msg_idx;\r\nout:\r\nif (timeout == 0)\r\ni2c_pxa_scream_blue_murder(i2c, "timeout");\r\nreturn ret;\r\n}\r\nstatic int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)\r\n{\r\nlong timeout;\r\nint ret;\r\nret = i2c_pxa_wait_bus_not_busy(i2c);\r\nif (ret) {\r\ndev_err(&i2c->adap.dev, "i2c_pxa: timeout waiting for bus free\n");\r\ngoto out;\r\n}\r\nret = i2c_pxa_set_master(i2c);\r\nif (ret) {\r\ndev_err(&i2c->adap.dev, "i2c_pxa_set_master: error %d\n", ret);\r\ngoto out;\r\n}\r\nspin_lock_irq(&i2c->lock);\r\ni2c->msg = msg;\r\ni2c->msg_num = num;\r\ni2c->msg_idx = 0;\r\ni2c->msg_ptr = 0;\r\ni2c->irqlogidx = 0;\r\ni2c_pxa_start_message(i2c);\r\nspin_unlock_irq(&i2c->lock);\r\ntimeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);\r\ni2c_pxa_stop_message(i2c);\r\nret = i2c->msg_idx;\r\nif (!timeout && i2c->msg_num) {\r\ni2c_pxa_scream_blue_murder(i2c, "timeout");\r\nret = I2C_RETRY;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int i2c_pxa_pio_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct pxa_i2c *i2c = adap->algo_data;\r\nint ret, i;\r\nif (!(readl(_ICR(i2c)) & ICR_IUE))\r\ni2c_pxa_reset(i2c);\r\nfor (i = adap->retries; i >= 0; i--) {\r\nret = i2c_pxa_do_pio_xfer(i2c, msgs, num);\r\nif (ret != I2C_RETRY)\r\ngoto out;\r\nif (i2c_debug)\r\ndev_dbg(&adap->dev, "Retrying transmission\n");\r\nudelay(100);\r\n}\r\ni2c_pxa_scream_blue_murder(i2c, "exhausted retries");\r\nret = -EREMOTEIO;\r\nout:\r\ni2c_pxa_set_slave(i2c, ret);\r\nreturn ret;\r\n}\r\nstatic void i2c_pxa_master_complete(struct pxa_i2c *i2c, int ret)\r\n{\r\ni2c->msg_ptr = 0;\r\ni2c->msg = NULL;\r\ni2c->msg_idx ++;\r\ni2c->msg_num = 0;\r\nif (ret)\r\ni2c->msg_idx = ret;\r\nif (!i2c->use_pio)\r\nwake_up(&i2c->wait);\r\n}\r\nstatic void i2c_pxa_irq_txempty(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nu32 icr = readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP|ICR_ACKNAK|ICR_TB);\r\nagain:\r\nif (isr & ISR_ALD) {\r\ni2c_pxa_scream_blue_murder(i2c, "ALD set");\r\nreturn;\r\n}\r\nif (isr & ISR_BED) {\r\nint ret = BUS_ERROR;\r\nif (isr & ISR_ACKNAK) {\r\nif (i2c->msg_ptr == 0 && i2c->msg_idx == 0)\r\nret = I2C_RETRY;\r\nelse\r\nret = XFER_NAKED;\r\n}\r\ni2c_pxa_master_complete(i2c, ret);\r\n} else if (isr & ISR_RWM) {\r\nif (i2c->msg_ptr == i2c->msg->len - 1 &&\r\ni2c->msg_idx == i2c->msg_num - 1)\r\nicr |= ICR_STOP | ICR_ACKNAK;\r\nicr |= ICR_ALDIE | ICR_TB;\r\n} else if (i2c->msg_ptr < i2c->msg->len) {\r\nwritel(i2c->msg->buf[i2c->msg_ptr++], _IDBR(i2c));\r\nicr |= ICR_ALDIE | ICR_TB;\r\nif (i2c->msg_ptr == i2c->msg->len &&\r\ni2c->msg_idx == i2c->msg_num - 1)\r\nicr |= ICR_STOP;\r\n} else if (i2c->msg_idx < i2c->msg_num - 1) {\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx ++;\r\ni2c->msg++;\r\nif (i2c->msg->flags & I2C_M_NOSTART)\r\ngoto again;\r\nwritel(i2c_pxa_addr_byte(i2c->msg), _IDBR(i2c));\r\nicr &= ~ICR_ALDIE;\r\nicr |= ICR_START | ICR_TB;\r\n} else {\r\nif (i2c->msg->len == 0) {\r\ni2c_pxa_reset(i2c);\r\n}\r\ni2c_pxa_master_complete(i2c, 0);\r\n}\r\ni2c->icrlog[i2c->irqlogidx-1] = icr;\r\nwritel(icr, _ICR(i2c));\r\nshow_state(i2c);\r\n}\r\nstatic void i2c_pxa_irq_rxfull(struct pxa_i2c *i2c, u32 isr)\r\n{\r\nu32 icr = readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP|ICR_ACKNAK|ICR_TB);\r\ni2c->msg->buf[i2c->msg_ptr++] = readl(_IDBR(i2c));\r\nif (i2c->msg_ptr < i2c->msg->len) {\r\nif (i2c->msg_ptr == i2c->msg->len - 1)\r\nicr |= ICR_STOP | ICR_ACKNAK;\r\nicr |= ICR_ALDIE | ICR_TB;\r\n} else {\r\ni2c_pxa_master_complete(i2c, 0);\r\n}\r\ni2c->icrlog[i2c->irqlogidx-1] = icr;\r\nwritel(icr, _ICR(i2c));\r\n}\r\nstatic irqreturn_t i2c_pxa_handler(int this_irq, void *dev_id)\r\n{\r\nstruct pxa_i2c *i2c = dev_id;\r\nu32 isr = readl(_ISR(i2c));\r\nif (!(isr & VALID_INT_SOURCE))\r\nreturn IRQ_NONE;\r\nif (i2c_debug > 2 && 0) {\r\ndev_dbg(&i2c->adap.dev, "%s: ISR=%08x, ICR=%08x, IBMR=%02x\n",\r\n__func__, isr, readl(_ICR(i2c)), readl(_IBMR(i2c)));\r\ndecode_ISR(isr);\r\n}\r\nif (i2c->irqlogidx < ARRAY_SIZE(i2c->isrlog))\r\ni2c->isrlog[i2c->irqlogidx++] = isr;\r\nshow_state(i2c);\r\nwritel(isr & VALID_INT_SOURCE, _ISR(i2c));\r\nif (isr & ISR_SAD)\r\ni2c_pxa_slave_start(i2c, isr);\r\nif (isr & ISR_SSD)\r\ni2c_pxa_slave_stop(i2c);\r\nif (i2c_pxa_is_slavemode(i2c)) {\r\nif (isr & ISR_ITE)\r\ni2c_pxa_slave_txempty(i2c, isr);\r\nif (isr & ISR_IRF)\r\ni2c_pxa_slave_rxfull(i2c, isr);\r\n} else if (i2c->msg) {\r\nif (isr & ISR_ITE)\r\ni2c_pxa_irq_txempty(i2c, isr);\r\nif (isr & ISR_IRF)\r\ni2c_pxa_irq_rxfull(i2c, isr);\r\n} else {\r\ni2c_pxa_scream_blue_murder(i2c, "spurious irq");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i2c_pxa_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct pxa_i2c *i2c = adap->algo_data;\r\nint ret, i;\r\nfor (i = adap->retries; i >= 0; i--) {\r\nret = i2c_pxa_do_xfer(i2c, msgs, num);\r\nif (ret != I2C_RETRY)\r\ngoto out;\r\nif (i2c_debug)\r\ndev_dbg(&adap->dev, "Retrying transmission\n");\r\nudelay(100);\r\n}\r\ni2c_pxa_scream_blue_murder(i2c, "exhausted retries");\r\nret = -EREMOTEIO;\r\nout:\r\ni2c_pxa_set_slave(i2c, ret);\r\nreturn ret;\r\n}\r\nstatic u32 i2c_pxa_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int i2c_pxa_probe_dt(struct platform_device *pdev, struct pxa_i2c *i2c,\r\nenum pxa_i2c_types *i2c_types)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(i2c_pxa_dt_ids, &pdev->dev);\r\nint ret;\r\nif (!of_id)\r\nreturn 1;\r\nret = of_alias_get_id(np, "i2c");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\npdev->id = ret;\r\nif (of_get_property(np, "mrvl,i2c-polling", NULL))\r\ni2c->use_pio = 1;\r\nif (of_get_property(np, "mrvl,i2c-fast-mode", NULL))\r\ni2c->fast_mode = 1;\r\n*i2c_types = (u32)(of_id->data);\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_probe_pdata(struct platform_device *pdev,\r\nstruct pxa_i2c *i2c,\r\nenum pxa_i2c_types *i2c_types)\r\n{\r\nstruct i2c_pxa_platform_data *plat = pdev->dev.platform_data;\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\n*i2c_types = id->driver_data;\r\nif (plat) {\r\ni2c->use_pio = plat->use_pio;\r\ni2c->fast_mode = plat->fast_mode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_probe(struct platform_device *dev)\r\n{\r\nstruct i2c_pxa_platform_data *plat = dev->dev.platform_data;\r\nenum pxa_i2c_types i2c_type;\r\nstruct pxa_i2c *i2c;\r\nstruct resource *res = NULL;\r\nint ret, irq;\r\ni2c = kzalloc(sizeof(struct pxa_i2c), GFP_KERNEL);\r\nif (!i2c) {\r\nret = -ENOMEM;\r\ngoto emalloc;\r\n}\r\nret = i2c_pxa_probe_dt(dev, i2c, &i2c_type);\r\nif (ret > 0)\r\nret = i2c_pxa_probe_pdata(dev, i2c, &i2c_type);\r\nif (ret < 0)\r\ngoto eclk;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(dev, 0);\r\nif (res == NULL || irq < 0) {\r\nret = -ENODEV;\r\ngoto eclk;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), res->name)) {\r\nret = -ENOMEM;\r\ngoto eclk;\r\n}\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.retries = 5;\r\nspin_lock_init(&i2c->lock);\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->adap.nr = dev->id;\r\nsnprintf(i2c->adap.name, sizeof(i2c->adap.name), "pxa_i2c-i2c.%u",\r\ni2c->adap.nr);\r\ni2c->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(i2c->clk)) {\r\nret = PTR_ERR(i2c->clk);\r\ngoto eclk;\r\n}\r\ni2c->reg_base = ioremap(res->start, resource_size(res));\r\nif (!i2c->reg_base) {\r\nret = -EIO;\r\ngoto eremap;\r\n}\r\ni2c->reg_ibmr = i2c->reg_base + pxa_reg_layout[i2c_type].ibmr;\r\ni2c->reg_idbr = i2c->reg_base + pxa_reg_layout[i2c_type].idbr;\r\ni2c->reg_icr = i2c->reg_base + pxa_reg_layout[i2c_type].icr;\r\ni2c->reg_isr = i2c->reg_base + pxa_reg_layout[i2c_type].isr;\r\nif (i2c_type != REGS_CE4100)\r\ni2c->reg_isar = i2c->reg_base + pxa_reg_layout[i2c_type].isar;\r\ni2c->iobase = res->start;\r\ni2c->iosize = resource_size(res);\r\ni2c->irq = irq;\r\ni2c->slave_addr = I2C_PXA_SLAVE_ADDR;\r\nif (plat) {\r\n#ifdef CONFIG_I2C_PXA_SLAVE\r\ni2c->slave_addr = plat->slave_addr;\r\ni2c->slave = plat->slave;\r\n#endif\r\ni2c->adap.class = plat->class;\r\n}\r\nclk_enable(i2c->clk);\r\nif (i2c->use_pio) {\r\ni2c->adap.algo = &i2c_pxa_pio_algorithm;\r\n} else {\r\ni2c->adap.algo = &i2c_pxa_algorithm;\r\nret = request_irq(irq, i2c_pxa_handler, IRQF_SHARED,\r\ni2c->adap.name, i2c);\r\nif (ret)\r\ngoto ereqirq;\r\n}\r\ni2c_pxa_reset(i2c);\r\ni2c->adap.algo_data = i2c;\r\ni2c->adap.dev.parent = &dev->dev;\r\n#ifdef CONFIG_OF\r\ni2c->adap.dev.of_node = dev->dev.of_node;\r\n#endif\r\nret = i2c_add_numbered_adapter(&i2c->adap);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "I2C: Failed to add bus\n");\r\ngoto eadapt;\r\n}\r\nof_i2c_register_devices(&i2c->adap);\r\nplatform_set_drvdata(dev, i2c);\r\n#ifdef CONFIG_I2C_PXA_SLAVE\r\nprintk(KERN_INFO "I2C: %s: PXA I2C adapter, slave address %d\n",\r\ndev_name(&i2c->adap.dev), i2c->slave_addr);\r\n#else\r\nprintk(KERN_INFO "I2C: %s: PXA I2C adapter\n",\r\ndev_name(&i2c->adap.dev));\r\n#endif\r\nreturn 0;\r\neadapt:\r\nif (!i2c->use_pio)\r\nfree_irq(irq, i2c);\r\nereqirq:\r\nclk_disable(i2c->clk);\r\niounmap(i2c->reg_base);\r\neremap:\r\nclk_put(i2c->clk);\r\neclk:\r\nkfree(i2c);\r\nemalloc:\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn ret;\r\n}\r\nstatic int __exit i2c_pxa_remove(struct platform_device *dev)\r\n{\r\nstruct pxa_i2c *i2c = platform_get_drvdata(dev);\r\nplatform_set_drvdata(dev, NULL);\r\ni2c_del_adapter(&i2c->adap);\r\nif (!i2c->use_pio)\r\nfree_irq(i2c->irq, i2c);\r\nclk_disable(i2c->clk);\r\nclk_put(i2c->clk);\r\niounmap(i2c->reg_base);\r\nrelease_mem_region(i2c->iobase, i2c->iosize);\r\nkfree(i2c);\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pxa_i2c *i2c = platform_get_drvdata(pdev);\r\nclk_disable(i2c->clk);\r\nreturn 0;\r\n}\r\nstatic int i2c_pxa_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pxa_i2c *i2c = platform_get_drvdata(pdev);\r\nclk_enable(i2c->clk);\r\ni2c_pxa_reset(i2c);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_adap_pxa_init(void)\r\n{\r\nreturn platform_driver_register(&i2c_pxa_driver);\r\n}\r\nstatic void __exit i2c_adap_pxa_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_pxa_driver);\r\n}
