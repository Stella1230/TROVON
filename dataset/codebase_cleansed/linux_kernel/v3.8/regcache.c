static int regcache_hw_init(struct regmap *map)\r\n{\r\nint i, j;\r\nint ret;\r\nint count;\r\nunsigned int val;\r\nvoid *tmp_buf;\r\nif (!map->num_reg_defaults_raw)\r\nreturn -EINVAL;\r\nif (!map->reg_defaults_raw) {\r\nu32 cache_bypass = map->cache_bypass;\r\ndev_warn(map->dev, "No cache defaults, reading back from HW\n");\r\nmap->cache_bypass = 1;\r\ntmp_buf = kmalloc(map->cache_size_raw, GFP_KERNEL);\r\nif (!tmp_buf)\r\nreturn -EINVAL;\r\nret = regmap_bulk_read(map, 0, tmp_buf,\r\nmap->num_reg_defaults_raw);\r\nmap->cache_bypass = cache_bypass;\r\nif (ret < 0) {\r\nkfree(tmp_buf);\r\nreturn ret;\r\n}\r\nmap->reg_defaults_raw = tmp_buf;\r\nmap->cache_free = 1;\r\n}\r\nfor (count = 0, i = 0; i < map->num_reg_defaults_raw; i++) {\r\nval = regcache_get_val(map->reg_defaults_raw,\r\ni, map->cache_word_size);\r\nif (regmap_volatile(map, i * map->reg_stride))\r\ncontinue;\r\ncount++;\r\n}\r\nmap->reg_defaults = kmalloc(count * sizeof(struct reg_default),\r\nGFP_KERNEL);\r\nif (!map->reg_defaults) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nmap->num_reg_defaults = count;\r\nfor (i = 0, j = 0; i < map->num_reg_defaults_raw; i++) {\r\nval = regcache_get_val(map->reg_defaults_raw,\r\ni, map->cache_word_size);\r\nif (regmap_volatile(map, i * map->reg_stride))\r\ncontinue;\r\nmap->reg_defaults[j].reg = i * map->reg_stride;\r\nmap->reg_defaults[j].def = val;\r\nj++;\r\n}\r\nreturn 0;\r\nerr_free:\r\nif (map->cache_free)\r\nkfree(map->reg_defaults_raw);\r\nreturn ret;\r\n}\r\nint regcache_init(struct regmap *map, const struct regmap_config *config)\r\n{\r\nint ret;\r\nint i;\r\nvoid *tmp_buf;\r\nfor (i = 0; i < config->num_reg_defaults; i++)\r\nif (config->reg_defaults[i].reg % map->reg_stride)\r\nreturn -EINVAL;\r\nif (map->cache_type == REGCACHE_NONE) {\r\nmap->cache_bypass = true;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cache_types); i++)\r\nif (cache_types[i]->type == map->cache_type)\r\nbreak;\r\nif (i == ARRAY_SIZE(cache_types)) {\r\ndev_err(map->dev, "Could not match compress type: %d\n",\r\nmap->cache_type);\r\nreturn -EINVAL;\r\n}\r\nmap->num_reg_defaults = config->num_reg_defaults;\r\nmap->num_reg_defaults_raw = config->num_reg_defaults_raw;\r\nmap->reg_defaults_raw = config->reg_defaults_raw;\r\nmap->cache_word_size = DIV_ROUND_UP(config->val_bits, 8);\r\nmap->cache_size_raw = map->cache_word_size * config->num_reg_defaults_raw;\r\nmap->cache = NULL;\r\nmap->cache_ops = cache_types[i];\r\nif (!map->cache_ops->read ||\r\n!map->cache_ops->write ||\r\n!map->cache_ops->name)\r\nreturn -EINVAL;\r\nif (config->reg_defaults) {\r\nif (!map->num_reg_defaults)\r\nreturn -EINVAL;\r\ntmp_buf = kmemdup(config->reg_defaults, map->num_reg_defaults *\r\nsizeof(struct reg_default), GFP_KERNEL);\r\nif (!tmp_buf)\r\nreturn -ENOMEM;\r\nmap->reg_defaults = tmp_buf;\r\n} else if (map->num_reg_defaults_raw) {\r\nret = regcache_hw_init(map);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!map->max_register)\r\nmap->max_register = map->num_reg_defaults_raw;\r\nif (map->cache_ops->init) {\r\ndev_dbg(map->dev, "Initializing %s cache\n",\r\nmap->cache_ops->name);\r\nret = map->cache_ops->init(map);\r\nif (ret)\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nkfree(map->reg_defaults);\r\nif (map->cache_free)\r\nkfree(map->reg_defaults_raw);\r\nreturn ret;\r\n}\r\nvoid regcache_exit(struct regmap *map)\r\n{\r\nif (map->cache_type == REGCACHE_NONE)\r\nreturn;\r\nBUG_ON(!map->cache_ops);\r\nkfree(map->reg_defaults);\r\nif (map->cache_free)\r\nkfree(map->reg_defaults_raw);\r\nif (map->cache_ops->exit) {\r\ndev_dbg(map->dev, "Destroying %s cache\n",\r\nmap->cache_ops->name);\r\nmap->cache_ops->exit(map);\r\n}\r\n}\r\nint regcache_read(struct regmap *map,\r\nunsigned int reg, unsigned int *value)\r\n{\r\nint ret;\r\nif (map->cache_type == REGCACHE_NONE)\r\nreturn -ENOSYS;\r\nBUG_ON(!map->cache_ops);\r\nif (!regmap_volatile(map, reg)) {\r\nret = map->cache_ops->read(map, reg, value);\r\nif (ret == 0)\r\ntrace_regmap_reg_read_cache(map->dev, reg, *value);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint regcache_write(struct regmap *map,\r\nunsigned int reg, unsigned int value)\r\n{\r\nif (map->cache_type == REGCACHE_NONE)\r\nreturn 0;\r\nBUG_ON(!map->cache_ops);\r\nif (!regmap_writeable(map, reg))\r\nreturn -EIO;\r\nif (!regmap_volatile(map, reg))\r\nreturn map->cache_ops->write(map, reg, value);\r\nreturn 0;\r\n}\r\nint regcache_sync(struct regmap *map)\r\n{\r\nint ret = 0;\r\nunsigned int i;\r\nconst char *name;\r\nunsigned int bypass;\r\nBUG_ON(!map->cache_ops || !map->cache_ops->sync);\r\nmap->lock(map);\r\nbypass = map->cache_bypass;\r\ndev_dbg(map->dev, "Syncing %s cache\n",\r\nmap->cache_ops->name);\r\nname = map->cache_ops->name;\r\ntrace_regcache_sync(map->dev, name, "start");\r\nif (!map->cache_dirty)\r\ngoto out;\r\nmap->cache_bypass = 1;\r\nfor (i = 0; i < map->patch_regs; i++) {\r\nif (map->patch[i].reg % map->reg_stride) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = _regmap_write(map, map->patch[i].reg, map->patch[i].def);\r\nif (ret != 0) {\r\ndev_err(map->dev, "Failed to write %x = %x: %d\n",\r\nmap->patch[i].reg, map->patch[i].def, ret);\r\ngoto out;\r\n}\r\n}\r\nmap->cache_bypass = 0;\r\nret = map->cache_ops->sync(map, 0, map->max_register);\r\nif (ret == 0)\r\nmap->cache_dirty = false;\r\nout:\r\ntrace_regcache_sync(map->dev, name, "stop");\r\nmap->cache_bypass = bypass;\r\nmap->unlock(map);\r\nreturn ret;\r\n}\r\nint regcache_sync_region(struct regmap *map, unsigned int min,\r\nunsigned int max)\r\n{\r\nint ret = 0;\r\nconst char *name;\r\nunsigned int bypass;\r\nBUG_ON(!map->cache_ops || !map->cache_ops->sync);\r\nmap->lock(map);\r\nbypass = map->cache_bypass;\r\nname = map->cache_ops->name;\r\ndev_dbg(map->dev, "Syncing %s cache from %d-%d\n", name, min, max);\r\ntrace_regcache_sync(map->dev, name, "start region");\r\nif (!map->cache_dirty)\r\ngoto out;\r\nret = map->cache_ops->sync(map, min, max);\r\nout:\r\ntrace_regcache_sync(map->dev, name, "stop region");\r\nmap->cache_bypass = bypass;\r\nmap->unlock(map);\r\nreturn ret;\r\n}\r\nvoid regcache_cache_only(struct regmap *map, bool enable)\r\n{\r\nmap->lock(map);\r\nWARN_ON(map->cache_bypass && enable);\r\nmap->cache_only = enable;\r\ntrace_regmap_cache_only(map->dev, enable);\r\nmap->unlock(map);\r\n}\r\nvoid regcache_mark_dirty(struct regmap *map)\r\n{\r\nmap->lock(map);\r\nmap->cache_dirty = true;\r\nmap->unlock(map);\r\n}\r\nvoid regcache_cache_bypass(struct regmap *map, bool enable)\r\n{\r\nmap->lock(map);\r\nWARN_ON(map->cache_only && enable);\r\nmap->cache_bypass = enable;\r\ntrace_regmap_cache_bypass(map->dev, enable);\r\nmap->unlock(map);\r\n}\r\nbool regcache_set_val(void *base, unsigned int idx,\r\nunsigned int val, unsigned int word_size)\r\n{\r\nswitch (word_size) {\r\ncase 1: {\r\nu8 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ncase 2: {\r\nu16 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ncase 4: {\r\nu32 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn false;\r\n}\r\nunsigned int regcache_get_val(const void *base, unsigned int idx,\r\nunsigned int word_size)\r\n{\r\nif (!base)\r\nreturn -EINVAL;\r\nswitch (word_size) {\r\ncase 1: {\r\nconst u8 *cache = base;\r\nreturn cache[idx];\r\n}\r\ncase 2: {\r\nconst u16 *cache = base;\r\nreturn cache[idx];\r\n}\r\ncase 4: {\r\nconst u32 *cache = base;\r\nreturn cache[idx];\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn -1;\r\n}\r\nstatic int regcache_default_cmp(const void *a, const void *b)\r\n{\r\nconst struct reg_default *_a = a;\r\nconst struct reg_default *_b = b;\r\nreturn _a->reg - _b->reg;\r\n}\r\nint regcache_lookup_reg(struct regmap *map, unsigned int reg)\r\n{\r\nstruct reg_default key;\r\nstruct reg_default *r;\r\nkey.reg = reg;\r\nkey.def = 0;\r\nr = bsearch(&key, map->reg_defaults, map->num_reg_defaults,\r\nsizeof(struct reg_default), regcache_default_cmp);\r\nif (r)\r\nreturn r - map->reg_defaults;\r\nelse\r\nreturn -ENOENT;\r\n}
