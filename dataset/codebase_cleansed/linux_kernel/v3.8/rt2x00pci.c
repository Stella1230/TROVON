int rt2x00pci_regbusy_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nconst struct rt2x00_field32 field,\r\nu32 *reg)\r\n{\r\nunsigned int i;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn 0;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2x00pci_register_read(rt2x00dev, offset, reg);\r\nif (!rt2x00_get_field32(*reg, field))\r\nreturn 1;\r\nudelay(REGISTER_BUSY_DELAY);\r\n}\r\nERROR(rt2x00dev, "Indirect register access failed: "\r\n"offset=0x%.08x, value=0x%.08x\n", offset, *reg);\r\n*reg = ~0;\r\nreturn 0;\r\n}\r\nbool rt2x00pci_rxdone(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue = rt2x00dev->rx;\r\nstruct queue_entry *entry;\r\nstruct queue_entry_priv_pci *entry_priv;\r\nstruct skb_frame_desc *skbdesc;\r\nint max_rx = 16;\r\nwhile (--max_rx) {\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX);\r\nentry_priv = entry->priv_data;\r\nif (rt2x00dev->ops->lib->get_entry_state(entry))\r\nbreak;\r\nskbdesc = get_skb_frame_desc(entry->skb);\r\nskbdesc->desc = entry_priv->desc;\r\nskbdesc->desc_len = entry->queue->desc_size;\r\nrt2x00lib_dmastart(entry);\r\nrt2x00lib_dmadone(entry);\r\nrt2x00lib_rxdone(entry, GFP_ATOMIC);\r\n}\r\nreturn !max_rx;\r\n}\r\nvoid rt2x00pci_flush_queue(struct data_queue *queue, bool drop)\r\n{\r\nunsigned int i;\r\nfor (i = 0; !rt2x00queue_empty(queue) && i < 10; i++)\r\nmsleep(10);\r\n}\r\nstatic int rt2x00pci_alloc_queue_dma(struct rt2x00_dev *rt2x00dev,\r\nstruct data_queue *queue)\r\n{\r\nstruct queue_entry_priv_pci *entry_priv;\r\nvoid *addr;\r\ndma_addr_t dma;\r\nunsigned int i;\r\naddr = dma_alloc_coherent(rt2x00dev->dev,\r\nqueue->limit * queue->desc_size,\r\n&dma, GFP_KERNEL);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nmemset(addr, 0, queue->limit * queue->desc_size);\r\nfor (i = 0; i < queue->limit; i++) {\r\nentry_priv = queue->entries[i].priv_data;\r\nentry_priv->desc = addr + i * queue->desc_size;\r\nentry_priv->desc_dma = dma + i * queue->desc_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rt2x00pci_free_queue_dma(struct rt2x00_dev *rt2x00dev,\r\nstruct data_queue *queue)\r\n{\r\nstruct queue_entry_priv_pci *entry_priv =\r\nqueue->entries[0].priv_data;\r\nif (entry_priv->desc)\r\ndma_free_coherent(rt2x00dev->dev,\r\nqueue->limit * queue->desc_size,\r\nentry_priv->desc, entry_priv->desc_dma);\r\nentry_priv->desc = NULL;\r\n}\r\nint rt2x00pci_initialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nint status;\r\nqueue_for_each(rt2x00dev, queue) {\r\nstatus = rt2x00pci_alloc_queue_dma(rt2x00dev, queue);\r\nif (status)\r\ngoto exit;\r\n}\r\nstatus = request_irq(rt2x00dev->irq,\r\nrt2x00dev->ops->lib->irq_handler,\r\nIRQF_SHARED, rt2x00dev->name, rt2x00dev);\r\nif (status) {\r\nERROR(rt2x00dev, "IRQ %d allocation failed (error %d).\n",\r\nrt2x00dev->irq, status);\r\ngoto exit;\r\n}\r\nreturn 0;\r\nexit:\r\nqueue_for_each(rt2x00dev, queue)\r\nrt2x00pci_free_queue_dma(rt2x00dev, queue);\r\nreturn status;\r\n}\r\nvoid rt2x00pci_uninitialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nfree_irq(rt2x00dev->irq, rt2x00dev);\r\nqueue_for_each(rt2x00dev, queue)\r\nrt2x00pci_free_queue_dma(rt2x00dev, queue);\r\n}\r\nstatic void rt2x00pci_free_reg(struct rt2x00_dev *rt2x00dev)\r\n{\r\nkfree(rt2x00dev->rf);\r\nrt2x00dev->rf = NULL;\r\nkfree(rt2x00dev->eeprom);\r\nrt2x00dev->eeprom = NULL;\r\nif (rt2x00dev->csr.base) {\r\niounmap(rt2x00dev->csr.base);\r\nrt2x00dev->csr.base = NULL;\r\n}\r\n}\r\nstatic int rt2x00pci_alloc_reg(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(rt2x00dev->dev);\r\nrt2x00dev->csr.base = pci_ioremap_bar(pci_dev, 0);\r\nif (!rt2x00dev->csr.base)\r\ngoto exit;\r\nrt2x00dev->eeprom = kzalloc(rt2x00dev->ops->eeprom_size, GFP_KERNEL);\r\nif (!rt2x00dev->eeprom)\r\ngoto exit;\r\nrt2x00dev->rf = kzalloc(rt2x00dev->ops->rf_size, GFP_KERNEL);\r\nif (!rt2x00dev->rf)\r\ngoto exit;\r\nreturn 0;\r\nexit:\r\nERROR_PROBE("Failed to allocate registers.\n");\r\nrt2x00pci_free_reg(rt2x00dev);\r\nreturn -ENOMEM;\r\n}\r\nint rt2x00pci_probe(struct pci_dev *pci_dev, const struct rt2x00_ops *ops)\r\n{\r\nstruct ieee80211_hw *hw;\r\nstruct rt2x00_dev *rt2x00dev;\r\nint retval;\r\nu16 chip;\r\nretval = pci_enable_device(pci_dev);\r\nif (retval) {\r\nERROR_PROBE("Enable device failed.\n");\r\nreturn retval;\r\n}\r\nretval = pci_request_regions(pci_dev, pci_name(pci_dev));\r\nif (retval) {\r\nERROR_PROBE("PCI request regions failed.\n");\r\ngoto exit_disable_device;\r\n}\r\npci_set_master(pci_dev);\r\nif (pci_set_mwi(pci_dev))\r\nERROR_PROBE("MWI not available.\n");\r\nif (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {\r\nERROR_PROBE("PCI DMA not supported.\n");\r\nretval = -EIO;\r\ngoto exit_release_regions;\r\n}\r\nhw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);\r\nif (!hw) {\r\nERROR_PROBE("Failed to allocate hardware.\n");\r\nretval = -ENOMEM;\r\ngoto exit_release_regions;\r\n}\r\npci_set_drvdata(pci_dev, hw);\r\nrt2x00dev = hw->priv;\r\nrt2x00dev->dev = &pci_dev->dev;\r\nrt2x00dev->ops = ops;\r\nrt2x00dev->hw = hw;\r\nrt2x00dev->irq = pci_dev->irq;\r\nrt2x00dev->name = pci_name(pci_dev);\r\nif (pci_is_pcie(pci_dev))\r\nrt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);\r\nelse\r\nrt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCI);\r\nretval = rt2x00pci_alloc_reg(rt2x00dev);\r\nif (retval)\r\ngoto exit_free_device;\r\npci_read_config_word(pci_dev, PCI_DEVICE_ID, &chip);\r\nrt2x00dev->chip.rt = chip;\r\nretval = rt2x00lib_probe_dev(rt2x00dev);\r\nif (retval)\r\ngoto exit_free_reg;\r\nreturn 0;\r\nexit_free_reg:\r\nrt2x00pci_free_reg(rt2x00dev);\r\nexit_free_device:\r\nieee80211_free_hw(hw);\r\nexit_release_regions:\r\npci_release_regions(pci_dev);\r\nexit_disable_device:\r\npci_disable_device(pci_dev);\r\npci_set_drvdata(pci_dev, NULL);\r\nreturn retval;\r\n}\r\nvoid rt2x00pci_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nrt2x00lib_remove_dev(rt2x00dev);\r\nrt2x00pci_free_reg(rt2x00dev);\r\nieee80211_free_hw(hw);\r\npci_set_drvdata(pci_dev, NULL);\r\npci_disable_device(pci_dev);\r\npci_release_regions(pci_dev);\r\n}\r\nint rt2x00pci_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nint retval;\r\nretval = rt2x00lib_suspend(rt2x00dev, state);\r\nif (retval)\r\nreturn retval;\r\npci_save_state(pci_dev);\r\npci_disable_device(pci_dev);\r\nreturn pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));\r\n}\r\nint rt2x00pci_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nif (pci_set_power_state(pci_dev, PCI_D0) ||\r\npci_enable_device(pci_dev)) {\r\nERROR(rt2x00dev, "Failed to resume device.\n");\r\nreturn -EIO;\r\n}\r\npci_restore_state(pci_dev);\r\nreturn rt2x00lib_resume(rt2x00dev);\r\n}
