static inline void davinci_i2c_write_reg(struct davinci_i2c_dev *i2c_dev,\r\nint reg, u16 val)\r\n{\r\n__raw_writew(val, i2c_dev->base + reg);\r\n}\r\nstatic inline u16 davinci_i2c_read_reg(struct davinci_i2c_dev *i2c_dev, int reg)\r\n{\r\nreturn __raw_readw(i2c_dev->base + reg);\r\n}\r\nstatic void generic_i2c_clock_pulse(unsigned int scl_pin)\r\n{\r\nu16 i;\r\nif (scl_pin) {\r\nfor (i = 0; i < 9; i++) {\r\ngpio_set_value(scl_pin, 0);\r\nudelay(20);\r\ngpio_set_value(scl_pin, 1);\r\nudelay(20);\r\n}\r\n}\r\n}\r\nstatic void i2c_recover_bus(struct davinci_i2c_dev *dev)\r\n{\r\nu32 flag = 0;\r\nstruct davinci_i2c_platform_data *pdata = dev->pdata;\r\ndev_err(dev->dev, "initiating i2c bus recovery\n");\r\nflag = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\r\nflag |= DAVINCI_I2C_MDR_NACK;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);\r\ngeneric_i2c_clock_pulse(pdata->scl_pin);\r\nflag = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\r\nflag |= DAVINCI_I2C_MDR_STP;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);\r\n}\r\nstatic inline void davinci_i2c_reset_ctrl(struct davinci_i2c_dev *i2c_dev,\r\nint val)\r\n{\r\nu16 w;\r\nw = davinci_i2c_read_reg(i2c_dev, DAVINCI_I2C_MDR_REG);\r\nif (!val)\r\nw &= ~DAVINCI_I2C_MDR_IRS;\r\nelse\r\nw |= DAVINCI_I2C_MDR_IRS;\r\ndavinci_i2c_write_reg(i2c_dev, DAVINCI_I2C_MDR_REG, w);\r\n}\r\nstatic void i2c_davinci_calc_clk_dividers(struct davinci_i2c_dev *dev)\r\n{\r\nstruct davinci_i2c_platform_data *pdata = dev->pdata;\r\nu16 psc;\r\nu32 clk;\r\nu32 d;\r\nu32 clkh;\r\nu32 clkl;\r\nu32 input_clock = clk_get_rate(dev->clk);\r\npsc = (input_clock / 7000000) - 1;\r\nif ((input_clock / (psc + 1)) > 12000000)\r\npsc++;\r\nd = (psc >= 2) ? 5 : 7 - psc;\r\nclk = ((input_clock / (psc + 1)) / (pdata->bus_freq * 1000)) - (d << 1);\r\nclkh = clk >> 1;\r\nclkl = clk - clkh;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_PSC_REG, psc);\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_CLKH_REG, clkh);\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_CLKL_REG, clkl);\r\ndev_dbg(dev->dev, "input_clock = %d, CLK = %d\n", input_clock, clk);\r\n}\r\nstatic int i2c_davinci_init(struct davinci_i2c_dev *dev)\r\n{\r\nstruct davinci_i2c_platform_data *pdata = dev->pdata;\r\ndavinci_i2c_reset_ctrl(dev, 0);\r\ni2c_davinci_calc_clk_dividers(dev);\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_OAR_REG, 0x08);\r\ndev_dbg(dev->dev, "PSC = %d\n",\r\ndavinci_i2c_read_reg(dev, DAVINCI_I2C_PSC_REG));\r\ndev_dbg(dev->dev, "CLKL = %d\n",\r\ndavinci_i2c_read_reg(dev, DAVINCI_I2C_CLKL_REG));\r\ndev_dbg(dev->dev, "CLKH = %d\n",\r\ndavinci_i2c_read_reg(dev, DAVINCI_I2C_CLKH_REG));\r\ndev_dbg(dev->dev, "bus_freq = %dkHz, bus_delay = %d\n",\r\npdata->bus_freq, pdata->bus_delay);\r\ndavinci_i2c_reset_ctrl(dev, 1);\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, I2C_DAVINCI_INTR_ALL);\r\nreturn 0;\r\n}\r\nstatic int i2c_davinci_wait_bus_not_busy(struct davinci_i2c_dev *dev,\r\nchar allow_sleep)\r\n{\r\nunsigned long timeout;\r\nstatic u16 to_cnt;\r\ntimeout = jiffies + dev->adapter.timeout;\r\nwhile (davinci_i2c_read_reg(dev, DAVINCI_I2C_STR_REG)\r\n& DAVINCI_I2C_STR_BB) {\r\nif (to_cnt <= DAVINCI_I2C_MAX_TRIES) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(dev->dev,\r\n"timeout waiting for bus ready\n");\r\nto_cnt++;\r\nreturn -ETIMEDOUT;\r\n} else {\r\nto_cnt = 0;\r\ni2c_recover_bus(dev);\r\ni2c_davinci_init(dev);\r\n}\r\n}\r\nif (allow_sleep)\r\nschedule_timeout(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_davinci_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg, int stop)\r\n{\r\nstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\r\nstruct davinci_i2c_platform_data *pdata = dev->pdata;\r\nu32 flag;\r\nu16 w;\r\nint r;\r\nif (pdata->bus_delay)\r\nudelay(pdata->bus_delay);\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_SAR_REG, msg->addr);\r\ndev->buf = msg->buf;\r\ndev->buf_len = msg->len;\r\ndev->stop = stop;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_CNT_REG, dev->buf_len);\r\nINIT_COMPLETION(dev->cmd_complete);\r\ndev->cmd_err = 0;\r\nflag = DAVINCI_I2C_MDR_IRS | DAVINCI_I2C_MDR_MST;\r\nif (msg->flags & I2C_M_TEN)\r\nflag |= DAVINCI_I2C_MDR_XA;\r\nif (!(msg->flags & I2C_M_RD))\r\nflag |= DAVINCI_I2C_MDR_TRX;\r\nif (msg->len == 0)\r\nflag |= DAVINCI_I2C_MDR_RM;\r\nw = davinci_i2c_read_reg(dev, DAVINCI_I2C_IMR_REG);\r\nif (msg->flags & I2C_M_RD)\r\nw |= DAVINCI_I2C_IMR_RRDY;\r\nelse\r\nw |= DAVINCI_I2C_IMR_XRDY;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, w);\r\ndev->terminate = 0;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);\r\nif ((!(msg->flags & I2C_M_RD)) && dev->buf_len) {\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_DXR_REG, *dev->buf++);\r\ndev->buf_len--;\r\n}\r\nflag |= DAVINCI_I2C_MDR_STT;\r\nif (stop && msg->len != 0)\r\nflag |= DAVINCI_I2C_MDR_STP;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);\r\nr = wait_for_completion_interruptible_timeout(&dev->cmd_complete,\r\ndev->adapter.timeout);\r\nif (r == 0) {\r\ndev_err(dev->dev, "controller timed out\n");\r\ni2c_recover_bus(dev);\r\ni2c_davinci_init(dev);\r\ndev->buf_len = 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nif (dev->buf_len) {\r\nif (r >= 0) {\r\ndev_err(dev->dev, "abnormal termination buf_len=%i\n",\r\ndev->buf_len);\r\nr = -EREMOTEIO;\r\n}\r\ndev->terminate = 1;\r\nwmb();\r\ndev->buf_len = 0;\r\n}\r\nif (r < 0)\r\nreturn r;\r\nif (likely(!dev->cmd_err))\r\nreturn msg->len;\r\nif (dev->cmd_err & DAVINCI_I2C_STR_AL) {\r\ni2c_davinci_init(dev);\r\nreturn -EIO;\r\n}\r\nif (dev->cmd_err & DAVINCI_I2C_STR_NACK) {\r\nif (msg->flags & I2C_M_IGNORE_NAK)\r\nreturn msg->len;\r\nif (stop) {\r\nw = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\r\nw |= DAVINCI_I2C_MDR_STP;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);\r\n}\r\nreturn -EREMOTEIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\ni2c_davinci_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint i;\r\nint ret;\r\ndev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);\r\nret = i2c_davinci_wait_bus_not_busy(dev, 1);\r\nif (ret < 0) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < num; i++) {\r\nret = i2c_davinci_xfer_msg(adap, &msgs[i], (i == (num - 1)));\r\ndev_dbg(dev->dev, "%s [%d/%d] ret: %d\n", __func__, i + 1, num,\r\nret);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_CPU_FREQ\r\ncomplete(&dev->xfr_complete);\r\n#endif\r\nreturn num;\r\n}\r\nstatic u32 i2c_davinci_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void terminate_read(struct davinci_i2c_dev *dev)\r\n{\r\nu16 w = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\r\nw |= DAVINCI_I2C_MDR_NACK;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);\r\ndavinci_i2c_read_reg(dev, DAVINCI_I2C_DRR_REG);\r\nif (!dev->terminate)\r\ndev_err(dev->dev, "RDR IRQ while no data requested\n");\r\n}\r\nstatic void terminate_write(struct davinci_i2c_dev *dev)\r\n{\r\nu16 w = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\r\nw |= DAVINCI_I2C_MDR_RM | DAVINCI_I2C_MDR_STP;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);\r\nif (!dev->terminate)\r\ndev_dbg(dev->dev, "TDR IRQ while no data to send\n");\r\n}\r\nstatic irqreturn_t i2c_davinci_isr(int this_irq, void *dev_id)\r\n{\r\nstruct davinci_i2c_dev *dev = dev_id;\r\nu32 stat;\r\nint count = 0;\r\nu16 w;\r\nwhile ((stat = davinci_i2c_read_reg(dev, DAVINCI_I2C_IVR_REG))) {\r\ndev_dbg(dev->dev, "%s: stat=0x%x\n", __func__, stat);\r\nif (count++ == 100) {\r\ndev_warn(dev->dev, "Too much work in one IRQ\n");\r\nbreak;\r\n}\r\nswitch (stat) {\r\ncase DAVINCI_I2C_IVR_AL:\r\ndev->cmd_err |= DAVINCI_I2C_STR_AL;\r\ndev->buf_len = 0;\r\ncomplete(&dev->cmd_complete);\r\nbreak;\r\ncase DAVINCI_I2C_IVR_NACK:\r\ndev->cmd_err |= DAVINCI_I2C_STR_NACK;\r\ndev->buf_len = 0;\r\ncomplete(&dev->cmd_complete);\r\nbreak;\r\ncase DAVINCI_I2C_IVR_ARDY:\r\ndavinci_i2c_write_reg(dev,\r\nDAVINCI_I2C_STR_REG, DAVINCI_I2C_STR_ARDY);\r\nif (((dev->buf_len == 0) && (dev->stop != 0)) ||\r\n(dev->cmd_err & DAVINCI_I2C_STR_NACK)) {\r\nw = davinci_i2c_read_reg(dev,\r\nDAVINCI_I2C_MDR_REG);\r\nw |= DAVINCI_I2C_MDR_STP;\r\ndavinci_i2c_write_reg(dev,\r\nDAVINCI_I2C_MDR_REG, w);\r\n}\r\ncomplete(&dev->cmd_complete);\r\nbreak;\r\ncase DAVINCI_I2C_IVR_RDR:\r\nif (dev->buf_len) {\r\n*dev->buf++ =\r\ndavinci_i2c_read_reg(dev,\r\nDAVINCI_I2C_DRR_REG);\r\ndev->buf_len--;\r\nif (dev->buf_len)\r\ncontinue;\r\ndavinci_i2c_write_reg(dev,\r\nDAVINCI_I2C_STR_REG,\r\nDAVINCI_I2C_IMR_RRDY);\r\n} else {\r\nterminate_read(dev);\r\n}\r\nbreak;\r\ncase DAVINCI_I2C_IVR_XRDY:\r\nif (dev->buf_len) {\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_DXR_REG,\r\n*dev->buf++);\r\ndev->buf_len--;\r\nif (dev->buf_len)\r\ncontinue;\r\nw = davinci_i2c_read_reg(dev,\r\nDAVINCI_I2C_IMR_REG);\r\nw &= ~DAVINCI_I2C_IMR_XRDY;\r\ndavinci_i2c_write_reg(dev,\r\nDAVINCI_I2C_IMR_REG,\r\nw);\r\n} else {\r\nterminate_write(dev);\r\n}\r\nbreak;\r\ncase DAVINCI_I2C_IVR_SCD:\r\ndavinci_i2c_write_reg(dev,\r\nDAVINCI_I2C_STR_REG, DAVINCI_I2C_STR_SCD);\r\ncomplete(&dev->cmd_complete);\r\nbreak;\r\ncase DAVINCI_I2C_IVR_AAS:\r\ndev_dbg(dev->dev, "Address as slave interrupt\n");\r\nbreak;\r\ndefault:\r\ndev_warn(dev->dev, "Unrecognized irq stat %d\n", stat);\r\nbreak;\r\n}\r\n}\r\nreturn count ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int i2c_davinci_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct davinci_i2c_dev *dev;\r\ndev = container_of(nb, struct davinci_i2c_dev, freq_transition);\r\nif (val == CPUFREQ_PRECHANGE) {\r\nwait_for_completion(&dev->xfr_complete);\r\ndavinci_i2c_reset_ctrl(dev, 0);\r\n} else if (val == CPUFREQ_POSTCHANGE) {\r\ni2c_davinci_calc_clk_dividers(dev);\r\ndavinci_i2c_reset_ctrl(dev, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int i2c_davinci_cpufreq_register(struct davinci_i2c_dev *dev)\r\n{\r\ndev->freq_transition.notifier_call = i2c_davinci_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&dev->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void i2c_davinci_cpufreq_deregister(struct davinci_i2c_dev *dev)\r\n{\r\ncpufreq_unregister_notifier(&dev->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int i2c_davinci_cpufreq_register(struct davinci_i2c_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void i2c_davinci_cpufreq_deregister(struct davinci_i2c_dev *dev)\r\n{\r\n}\r\nstatic int davinci_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *mem, *irq, *ioarea;\r\nint r;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -ENODEV;\r\n}\r\nioarea = request_mem_region(mem->start, resource_size(mem),\r\npdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "I2C region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\ndev = kzalloc(sizeof(struct davinci_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\nr = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\ninit_completion(&dev->cmd_complete);\r\n#ifdef CONFIG_CPU_FREQ\r\ninit_completion(&dev->xfr_complete);\r\n#endif\r\ndev->dev = get_device(&pdev->dev);\r\ndev->irq = irq->start;\r\ndev->pdata = dev->dev->platform_data;\r\nplatform_set_drvdata(pdev, dev);\r\nif (!dev->pdata && pdev->dev.of_node) {\r\nu32 prop;\r\ndev->pdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct davinci_i2c_platform_data), GFP_KERNEL);\r\nif (!dev->pdata) {\r\nr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nmemcpy(dev->pdata, &davinci_i2c_platform_data_default,\r\nsizeof(struct davinci_i2c_platform_data));\r\nif (!of_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&prop))\r\ndev->pdata->bus_freq = prop / 1000;\r\n} else if (!dev->pdata) {\r\ndev->pdata = &davinci_i2c_platform_data_default;\r\n}\r\ndev->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\nr = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nclk_prepare_enable(dev->clk);\r\ndev->base = ioremap(mem->start, resource_size(mem));\r\nif (!dev->base) {\r\nr = -EBUSY;\r\ngoto err_mem_ioremap;\r\n}\r\ni2c_davinci_init(dev);\r\nr = request_irq(dev->irq, i2c_davinci_isr, 0, pdev->name, dev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);\r\ngoto err_unuse_clocks;\r\n}\r\nr = i2c_davinci_cpufreq_register(dev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to register cpufreq\n");\r\ngoto err_free_irq;\r\n}\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON;\r\nstrlcpy(adap->name, "DaVinci I2C adapter", sizeof(adap->name));\r\nadap->algo = &i2c_davinci_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->timeout = DAVINCI_I2C_TIMEOUT;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->nr = pdev->id;\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure adding adapter\n");\r\ngoto err_free_irq;\r\n}\r\nof_i2c_register_devices(adap);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_unuse_clocks:\r\niounmap(dev->base);\r\nerr_mem_ioremap:\r\nclk_disable_unprepare(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\nerr_free_mem:\r\nplatform_set_drvdata(pdev, NULL);\r\nput_device(&pdev->dev);\r\nkfree(dev);\r\nerr_release_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn r;\r\n}\r\nstatic int davinci_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_i2c_dev *dev = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\ni2c_davinci_cpufreq_deregister(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&dev->adapter);\r\nput_device(&pdev->dev);\r\nclk_disable_unprepare(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\ndavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, 0);\r\nfree_irq(dev->irq, dev);\r\niounmap(dev->base);\r\nkfree(dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn 0;\r\n}\r\nstatic int davinci_i2c_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct davinci_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\ndavinci_i2c_reset_ctrl(i2c_dev, 0);\r\nclk_disable_unprepare(i2c_dev->clk);\r\nreturn 0;\r\n}\r\nstatic int davinci_i2c_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct davinci_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\nclk_prepare_enable(i2c_dev->clk);\r\ndavinci_i2c_reset_ctrl(i2c_dev, 1);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_register(&davinci_i2c_driver);\r\n}\r\nstatic void __exit davinci_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&davinci_i2c_driver);\r\n}
