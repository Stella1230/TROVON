static int gdbstub_read_wait(void)\r\n{\r\nint ret = -1;\r\nint i;\r\nif (unlikely(gdbstub_use_prev_in_buf)) {\r\nif (gdbstub_prev_in_buf_pos < gdbstub_use_prev_in_buf)\r\nreturn remcom_in_buffer[gdbstub_prev_in_buf_pos++];\r\nelse\r\ngdbstub_use_prev_in_buf = 0;\r\n}\r\nwhile (ret < 0)\r\nfor (i = 0; kdb_poll_funcs[i] != NULL; i++) {\r\nret = kdb_poll_funcs[i]();\r\nif (ret > 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int gdbstub_read_wait(void)\r\n{\r\nint ret = dbg_io_ops->read_char();\r\nwhile (ret == NO_POLL_CHAR)\r\nret = dbg_io_ops->read_char();\r\nreturn ret;\r\n}\r\nstatic void get_packet(char *buffer)\r\n{\r\nunsigned char checksum;\r\nunsigned char xmitcsum;\r\nint count;\r\nchar ch;\r\ndo {\r\nwhile ((ch = (gdbstub_read_wait())) != '$')\r\n;\r\nkgdb_connected = 1;\r\nchecksum = 0;\r\nxmitcsum = -1;\r\ncount = 0;\r\nwhile (count < (BUFMAX - 1)) {\r\nch = gdbstub_read_wait();\r\nif (ch == '#')\r\nbreak;\r\nchecksum = checksum + ch;\r\nbuffer[count] = ch;\r\ncount = count + 1;\r\n}\r\nif (ch == '#') {\r\nxmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\r\nxmitcsum += hex_to_bin(gdbstub_read_wait());\r\nif (checksum != xmitcsum)\r\ndbg_io_ops->write_char('-');\r\nelse\r\ndbg_io_ops->write_char('+');\r\nif (dbg_io_ops->flush)\r\ndbg_io_ops->flush();\r\n}\r\nbuffer[count] = 0;\r\n} while (checksum != xmitcsum);\r\n}\r\nstatic void put_packet(char *buffer)\r\n{\r\nunsigned char checksum;\r\nint count;\r\nchar ch;\r\nwhile (1) {\r\ndbg_io_ops->write_char('$');\r\nchecksum = 0;\r\ncount = 0;\r\nwhile ((ch = buffer[count])) {\r\ndbg_io_ops->write_char(ch);\r\nchecksum += ch;\r\ncount++;\r\n}\r\ndbg_io_ops->write_char('#');\r\ndbg_io_ops->write_char(hex_asc_hi(checksum));\r\ndbg_io_ops->write_char(hex_asc_lo(checksum));\r\nif (dbg_io_ops->flush)\r\ndbg_io_ops->flush();\r\nch = gdbstub_read_wait();\r\nif (ch == 3)\r\nch = gdbstub_read_wait();\r\nif (ch == '+')\r\nreturn;\r\nif (ch == '$') {\r\ndbg_io_ops->write_char('-');\r\nif (dbg_io_ops->flush)\r\ndbg_io_ops->flush();\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid gdbstub_msg_write(const char *s, int len)\r\n{\r\nchar *bufptr;\r\nint wcount;\r\nint i;\r\nif (len == 0)\r\nlen = strlen(s);\r\ngdbmsgbuf[0] = 'O';\r\nwhile (len > 0) {\r\nbufptr = gdbmsgbuf + 1;\r\nif ((len << 1) > (BUFMAX - 2))\r\nwcount = (BUFMAX - 2) >> 1;\r\nelse\r\nwcount = len;\r\nfor (i = 0; i < wcount; i++)\r\nbufptr = hex_byte_pack(bufptr, s[i]);\r\n*bufptr = '\0';\r\ns += wcount;\r\nlen -= wcount;\r\nput_packet(gdbmsgbuf);\r\n}\r\n}\r\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\r\n{\r\nchar *tmp;\r\nint err;\r\ntmp = buf + count;\r\nerr = probe_kernel_read(tmp, mem, count);\r\nif (err)\r\nreturn NULL;\r\nwhile (count > 0) {\r\nbuf = hex_byte_pack(buf, *tmp);\r\ntmp++;\r\ncount--;\r\n}\r\n*buf = 0;\r\nreturn buf;\r\n}\r\nint kgdb_hex2mem(char *buf, char *mem, int count)\r\n{\r\nchar *tmp_raw;\r\nchar *tmp_hex;\r\ntmp_raw = buf + count * 2;\r\ntmp_hex = tmp_raw - 1;\r\nwhile (tmp_hex >= buf) {\r\ntmp_raw--;\r\n*tmp_raw = hex_to_bin(*tmp_hex--);\r\n*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\r\n}\r\nreturn probe_kernel_write(mem, tmp_raw, count);\r\n}\r\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\r\n{\r\nint hex_val;\r\nint num = 0;\r\nint negate = 0;\r\n*long_val = 0;\r\nif (**ptr == '-') {\r\nnegate = 1;\r\n(*ptr)++;\r\n}\r\nwhile (**ptr) {\r\nhex_val = hex_to_bin(**ptr);\r\nif (hex_val < 0)\r\nbreak;\r\n*long_val = (*long_val << 4) | hex_val;\r\nnum++;\r\n(*ptr)++;\r\n}\r\nif (negate)\r\n*long_val = -*long_val;\r\nreturn num;\r\n}\r\nstatic int kgdb_ebin2mem(char *buf, char *mem, int count)\r\n{\r\nint size = 0;\r\nchar *c = buf;\r\nwhile (count-- > 0) {\r\nc[size] = *buf++;\r\nif (c[size] == 0x7d)\r\nc[size] = *buf++ ^ 0x20;\r\nsize++;\r\n}\r\nreturn probe_kernel_write(mem, c, size);\r\n}\r\nvoid pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\r\n{\r\nint i;\r\nint idx = 0;\r\nchar *ptr = (char *)gdb_regs;\r\nfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\r\ndbg_get_reg(i, ptr + idx, regs);\r\nidx += dbg_reg_def[i].size;\r\n}\r\n}\r\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\r\n{\r\nint i;\r\nint idx = 0;\r\nchar *ptr = (char *)gdb_regs;\r\nfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\r\ndbg_set_reg(i, ptr + idx, regs);\r\nidx += dbg_reg_def[i].size;\r\n}\r\n}\r\nstatic int write_mem_msg(int binary)\r\n{\r\nchar *ptr = &remcom_in_buffer[1];\r\nunsigned long addr;\r\nunsigned long length;\r\nint err;\r\nif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\r\nkgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\r\nif (binary)\r\nerr = kgdb_ebin2mem(ptr, (char *)addr, length);\r\nelse\r\nerr = kgdb_hex2mem(ptr, (char *)addr, length);\r\nif (err)\r\nreturn err;\r\nif (CACHE_FLUSH_IS_SAFE)\r\nflush_icache_range(addr, addr + length);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void error_packet(char *pkt, int error)\r\n{\r\nerror = -error;\r\npkt[0] = 'E';\r\npkt[1] = hex_asc[(error / 10)];\r\npkt[2] = hex_asc[(error % 10)];\r\npkt[3] = '\0';\r\n}\r\nstatic char *pack_threadid(char *pkt, unsigned char *id)\r\n{\r\nunsigned char *limit;\r\nint lzero = 1;\r\nlimit = id + (BUF_THREAD_ID_SIZE / 2);\r\nwhile (id < limit) {\r\nif (!lzero || *id != 0) {\r\npkt = hex_byte_pack(pkt, *id);\r\nlzero = 0;\r\n}\r\nid++;\r\n}\r\nif (lzero)\r\npkt = hex_byte_pack(pkt, 0);\r\nreturn pkt;\r\n}\r\nstatic void int_to_threadref(unsigned char *id, int value)\r\n{\r\nput_unaligned_be32(value, id);\r\n}\r\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\r\n{\r\nif (tid == 0 || tid == -1)\r\ntid = -atomic_read(&kgdb_active) - 2;\r\nif (tid < -1 && tid > -NR_CPUS - 2) {\r\nif (kgdb_info[-tid - 2].task)\r\nreturn kgdb_info[-tid - 2].task;\r\nelse\r\nreturn idle_task(-tid - 2);\r\n}\r\nif (tid <= 0) {\r\nprintk(KERN_ERR "KGDB: Internal thread select error\n");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nreturn find_task_by_pid_ns(tid, &init_pid_ns);\r\n}\r\nstatic inline int shadow_pid(int realpid)\r\n{\r\nif (realpid)\r\nreturn realpid;\r\nreturn -raw_smp_processor_id() - 2;\r\n}\r\nstatic void gdb_cmd_status(struct kgdb_state *ks)\r\n{\r\ndbg_remove_all_break();\r\nremcom_out_buffer[0] = 'S';\r\nhex_byte_pack(&remcom_out_buffer[1], ks->signo);\r\n}\r\nstatic void gdb_get_regs_helper(struct kgdb_state *ks)\r\n{\r\nstruct task_struct *thread;\r\nvoid *local_debuggerinfo;\r\nint i;\r\nthread = kgdb_usethread;\r\nif (!thread) {\r\nthread = kgdb_info[ks->cpu].task;\r\nlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\r\n} else {\r\nlocal_debuggerinfo = NULL;\r\nfor_each_online_cpu(i) {\r\nif (thread == kgdb_info[i].task)\r\nlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\r\n}\r\n}\r\nif (local_debuggerinfo) {\r\npt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\r\n} else {\r\nsleeping_thread_to_gdb_regs(gdb_regs, thread);\r\n}\r\n}\r\nstatic void gdb_cmd_getregs(struct kgdb_state *ks)\r\n{\r\ngdb_get_regs_helper(ks);\r\nkgdb_mem2hex((char *)gdb_regs, remcom_out_buffer, NUMREGBYTES);\r\n}\r\nstatic void gdb_cmd_setregs(struct kgdb_state *ks)\r\n{\r\nkgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs, NUMREGBYTES);\r\nif (kgdb_usethread && kgdb_usethread != current) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\n} else {\r\ngdb_regs_to_pt_regs(gdb_regs, ks->linux_regs);\r\nstrcpy(remcom_out_buffer, "OK");\r\n}\r\n}\r\nstatic void gdb_cmd_memread(struct kgdb_state *ks)\r\n{\r\nchar *ptr = &remcom_in_buffer[1];\r\nunsigned long length;\r\nunsigned long addr;\r\nchar *err;\r\nif (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&\r\nkgdb_hex2long(&ptr, &length) > 0) {\r\nerr = kgdb_mem2hex((char *)addr, remcom_out_buffer, length);\r\nif (!err)\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\n} else {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\n}\r\n}\r\nstatic void gdb_cmd_memwrite(struct kgdb_state *ks)\r\n{\r\nint err = write_mem_msg(0);\r\nif (err)\r\nerror_packet(remcom_out_buffer, err);\r\nelse\r\nstrcpy(remcom_out_buffer, "OK");\r\n}\r\nstatic char *gdb_hex_reg_helper(int regnum, char *out)\r\n{\r\nint i;\r\nint offset = 0;\r\nfor (i = 0; i < regnum; i++)\r\noffset += dbg_reg_def[i].size;\r\nreturn kgdb_mem2hex((char *)gdb_regs + offset, out,\r\ndbg_reg_def[i].size);\r\n}\r\nstatic void gdb_cmd_reg_get(struct kgdb_state *ks)\r\n{\r\nunsigned long regnum;\r\nchar *ptr = &remcom_in_buffer[1];\r\nkgdb_hex2long(&ptr, &regnum);\r\nif (regnum >= DBG_MAX_REG_NUM) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nreturn;\r\n}\r\ngdb_get_regs_helper(ks);\r\ngdb_hex_reg_helper(regnum, remcom_out_buffer);\r\n}\r\nstatic void gdb_cmd_reg_set(struct kgdb_state *ks)\r\n{\r\nunsigned long regnum;\r\nchar *ptr = &remcom_in_buffer[1];\r\nint i = 0;\r\nkgdb_hex2long(&ptr, &regnum);\r\nif (*ptr++ != '=' ||\r\n!(!kgdb_usethread || kgdb_usethread == current) ||\r\n!dbg_get_reg(regnum, gdb_regs, ks->linux_regs)) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nreturn;\r\n}\r\nmemset(gdb_regs, 0, sizeof(gdb_regs));\r\nwhile (i < sizeof(gdb_regs) * 2)\r\nif (hex_to_bin(ptr[i]) >= 0)\r\ni++;\r\nelse\r\nbreak;\r\ni = i / 2;\r\nkgdb_hex2mem(ptr, (char *)gdb_regs, i);\r\ndbg_set_reg(regnum, gdb_regs, ks->linux_regs);\r\nstrcpy(remcom_out_buffer, "OK");\r\n}\r\nstatic void gdb_cmd_binwrite(struct kgdb_state *ks)\r\n{\r\nint err = write_mem_msg(1);\r\nif (err)\r\nerror_packet(remcom_out_buffer, err);\r\nelse\r\nstrcpy(remcom_out_buffer, "OK");\r\n}\r\nstatic void gdb_cmd_detachkill(struct kgdb_state *ks)\r\n{\r\nint error;\r\nif (remcom_in_buffer[0] == 'D') {\r\nerror = dbg_remove_all_break();\r\nif (error < 0) {\r\nerror_packet(remcom_out_buffer, error);\r\n} else {\r\nstrcpy(remcom_out_buffer, "OK");\r\nkgdb_connected = 0;\r\n}\r\nput_packet(remcom_out_buffer);\r\n} else {\r\ndbg_remove_all_break();\r\nkgdb_connected = 0;\r\n}\r\n}\r\nstatic int gdb_cmd_reboot(struct kgdb_state *ks)\r\n{\r\nif (strcmp(remcom_in_buffer, "R0") == 0) {\r\nprintk(KERN_CRIT "Executing emergency reboot\n");\r\nstrcpy(remcom_out_buffer, "OK");\r\nput_packet(remcom_out_buffer);\r\nmachine_emergency_restart();\r\nkgdb_connected = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gdb_cmd_query(struct kgdb_state *ks)\r\n{\r\nstruct task_struct *g;\r\nstruct task_struct *p;\r\nunsigned char thref[BUF_THREAD_ID_SIZE];\r\nchar *ptr;\r\nint i;\r\nint cpu;\r\nint finished = 0;\r\nswitch (remcom_in_buffer[1]) {\r\ncase 's':\r\ncase 'f':\r\nif (memcmp(remcom_in_buffer + 2, "ThreadInfo", 10))\r\nbreak;\r\ni = 0;\r\nremcom_out_buffer[0] = 'm';\r\nptr = remcom_out_buffer + 1;\r\nif (remcom_in_buffer[1] == 'f') {\r\nfor_each_online_cpu(cpu) {\r\nks->thr_query = 0;\r\nint_to_threadref(thref, -cpu - 2);\r\nptr = pack_threadid(ptr, thref);\r\n*(ptr++) = ',';\r\ni++;\r\n}\r\n}\r\ndo_each_thread(g, p) {\r\nif (i >= ks->thr_query && !finished) {\r\nint_to_threadref(thref, p->pid);\r\nptr = pack_threadid(ptr, thref);\r\n*(ptr++) = ',';\r\nks->thr_query++;\r\nif (ks->thr_query % KGDB_MAX_THREAD_QUERY == 0)\r\nfinished = 1;\r\n}\r\ni++;\r\n} while_each_thread(g, p);\r\n*(--ptr) = '\0';\r\nbreak;\r\ncase 'C':\r\nstrcpy(remcom_out_buffer, "QC");\r\nks->threadid = shadow_pid(current->pid);\r\nint_to_threadref(thref, ks->threadid);\r\npack_threadid(remcom_out_buffer + 2, thref);\r\nbreak;\r\ncase 'T':\r\nif (memcmp(remcom_in_buffer + 1, "ThreadExtraInfo,", 16))\r\nbreak;\r\nks->threadid = 0;\r\nptr = remcom_in_buffer + 17;\r\nkgdb_hex2long(&ptr, &ks->threadid);\r\nif (!getthread(ks->linux_regs, ks->threadid)) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nbreak;\r\n}\r\nif ((int)ks->threadid > 0) {\r\nkgdb_mem2hex(getthread(ks->linux_regs,\r\nks->threadid)->comm,\r\nremcom_out_buffer, 16);\r\n} else {\r\nstatic char tmpstr[23 + BUF_THREAD_ID_SIZE];\r\nsprintf(tmpstr, "shadowCPU%d",\r\n(int)(-ks->threadid - 2));\r\nkgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));\r\n}\r\nbreak;\r\n#ifdef CONFIG_KGDB_KDB\r\ncase 'R':\r\nif (strncmp(remcom_in_buffer, "qRcmd,", 6) == 0) {\r\nint len = strlen(remcom_in_buffer + 6);\r\nif ((len % 2) != 0) {\r\nstrcpy(remcom_out_buffer, "E01");\r\nbreak;\r\n}\r\nkgdb_hex2mem(remcom_in_buffer + 6,\r\nremcom_out_buffer, len);\r\nlen = len / 2;\r\nremcom_out_buffer[len++] = 0;\r\nkdb_parse(remcom_out_buffer);\r\nstrcpy(remcom_out_buffer, "OK");\r\n}\r\nbreak;\r\n#endif\r\n}\r\n}\r\nstatic void gdb_cmd_task(struct kgdb_state *ks)\r\n{\r\nstruct task_struct *thread;\r\nchar *ptr;\r\nswitch (remcom_in_buffer[1]) {\r\ncase 'g':\r\nptr = &remcom_in_buffer[2];\r\nkgdb_hex2long(&ptr, &ks->threadid);\r\nthread = getthread(ks->linux_regs, ks->threadid);\r\nif (!thread && ks->threadid > 0) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nbreak;\r\n}\r\nkgdb_usethread = thread;\r\nks->kgdb_usethreadid = ks->threadid;\r\nstrcpy(remcom_out_buffer, "OK");\r\nbreak;\r\ncase 'c':\r\nptr = &remcom_in_buffer[2];\r\nkgdb_hex2long(&ptr, &ks->threadid);\r\nif (!ks->threadid) {\r\nkgdb_contthread = NULL;\r\n} else {\r\nthread = getthread(ks->linux_regs, ks->threadid);\r\nif (!thread && ks->threadid > 0) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nbreak;\r\n}\r\nkgdb_contthread = thread;\r\n}\r\nstrcpy(remcom_out_buffer, "OK");\r\nbreak;\r\n}\r\n}\r\nstatic void gdb_cmd_thread(struct kgdb_state *ks)\r\n{\r\nchar *ptr = &remcom_in_buffer[1];\r\nstruct task_struct *thread;\r\nkgdb_hex2long(&ptr, &ks->threadid);\r\nthread = getthread(ks->linux_regs, ks->threadid);\r\nif (thread)\r\nstrcpy(remcom_out_buffer, "OK");\r\nelse\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\n}\r\nstatic void gdb_cmd_break(struct kgdb_state *ks)\r\n{\r\nchar *bpt_type = &remcom_in_buffer[1];\r\nchar *ptr = &remcom_in_buffer[2];\r\nunsigned long addr;\r\nunsigned long length;\r\nint error = 0;\r\nif (arch_kgdb_ops.set_hw_breakpoint && *bpt_type >= '1') {\r\nif (*bpt_type > '4')\r\nreturn;\r\n} else {\r\nif (*bpt_type != '0' && *bpt_type != '1')\r\nreturn;\r\n}\r\nif (*bpt_type == '1' && !(arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT))\r\nreturn;\r\nif (*(ptr++) != ',') {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nreturn;\r\n}\r\nif (!kgdb_hex2long(&ptr, &addr)) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nreturn;\r\n}\r\nif (*(ptr++) != ',' ||\r\n!kgdb_hex2long(&ptr, &length)) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nreturn;\r\n}\r\nif (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')\r\nerror = dbg_set_sw_break(addr);\r\nelse if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')\r\nerror = dbg_remove_sw_break(addr);\r\nelse if (remcom_in_buffer[0] == 'Z')\r\nerror = arch_kgdb_ops.set_hw_breakpoint(addr,\r\n(int)length, *bpt_type - '0');\r\nelse if (remcom_in_buffer[0] == 'z')\r\nerror = arch_kgdb_ops.remove_hw_breakpoint(addr,\r\n(int) length, *bpt_type - '0');\r\nif (error == 0)\r\nstrcpy(remcom_out_buffer, "OK");\r\nelse\r\nerror_packet(remcom_out_buffer, error);\r\n}\r\nstatic int gdb_cmd_exception_pass(struct kgdb_state *ks)\r\n{\r\nif (remcom_in_buffer[1] == '0' && remcom_in_buffer[2] == '9') {\r\nks->pass_exception = 1;\r\nremcom_in_buffer[0] = 'c';\r\n} else if (remcom_in_buffer[1] == '1' && remcom_in_buffer[2] == '5') {\r\nks->pass_exception = 1;\r\nremcom_in_buffer[0] = 'D';\r\ndbg_remove_all_break();\r\nkgdb_connected = 0;\r\nreturn 1;\r\n} else {\r\ngdbstub_msg_write("KGDB only knows signal 9 (pass)"\r\n" and 15 (pass and disconnect)\n"\r\n"Executing a continue without signal passing\n", 0);\r\nremcom_in_buffer[0] = 'c';\r\n}\r\nreturn -1;\r\n}\r\nint gdb_serial_stub(struct kgdb_state *ks)\r\n{\r\nint error = 0;\r\nint tmp;\r\nmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\r\nkgdb_usethread = kgdb_info[ks->cpu].task;\r\nks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\r\nks->pass_exception = 0;\r\nif (kgdb_connected) {\r\nunsigned char thref[BUF_THREAD_ID_SIZE];\r\nchar *ptr;\r\nptr = remcom_out_buffer;\r\n*ptr++ = 'T';\r\nptr = hex_byte_pack(ptr, ks->signo);\r\nptr += strlen(strcpy(ptr, "thread:"));\r\nint_to_threadref(thref, shadow_pid(current->pid));\r\nptr = pack_threadid(ptr, thref);\r\n*ptr++ = ';';\r\nput_packet(remcom_out_buffer);\r\n}\r\nwhile (1) {\r\nerror = 0;\r\nmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\r\nget_packet(remcom_in_buffer);\r\nswitch (remcom_in_buffer[0]) {\r\ncase '?':\r\ngdb_cmd_status(ks);\r\nbreak;\r\ncase 'g':\r\ngdb_cmd_getregs(ks);\r\nbreak;\r\ncase 'G':\r\ngdb_cmd_setregs(ks);\r\nbreak;\r\ncase 'm':\r\ngdb_cmd_memread(ks);\r\nbreak;\r\ncase 'M':\r\ngdb_cmd_memwrite(ks);\r\nbreak;\r\n#if DBG_MAX_REG_NUM > 0\r\ncase 'p':\r\ngdb_cmd_reg_get(ks);\r\nbreak;\r\ncase 'P':\r\ngdb_cmd_reg_set(ks);\r\nbreak;\r\n#endif\r\ncase 'X':\r\ngdb_cmd_binwrite(ks);\r\nbreak;\r\ncase 'D':\r\ncase 'k':\r\ngdb_cmd_detachkill(ks);\r\ngoto default_handle;\r\ncase 'R':\r\nif (gdb_cmd_reboot(ks))\r\ngoto default_handle;\r\nbreak;\r\ncase 'q':\r\ngdb_cmd_query(ks);\r\nbreak;\r\ncase 'H':\r\ngdb_cmd_task(ks);\r\nbreak;\r\ncase 'T':\r\ngdb_cmd_thread(ks);\r\nbreak;\r\ncase 'z':\r\ncase 'Z':\r\ngdb_cmd_break(ks);\r\nbreak;\r\n#ifdef CONFIG_KGDB_KDB\r\ncase '3':\r\nif (remcom_in_buffer[1] == '\0') {\r\ngdb_cmd_detachkill(ks);\r\nreturn DBG_PASS_EVENT;\r\n}\r\n#endif\r\ncase 'C':\r\ntmp = gdb_cmd_exception_pass(ks);\r\nif (tmp > 0)\r\ngoto default_handle;\r\nif (tmp == 0)\r\nbreak;\r\ncase 'c':\r\ncase 's':\r\nif (kgdb_contthread && kgdb_contthread != current) {\r\nerror_packet(remcom_out_buffer, -EINVAL);\r\nbreak;\r\n}\r\ndbg_activate_sw_breakpoints();\r\ndefault:\r\ndefault_handle:\r\nerror = kgdb_arch_handle_exception(ks->ex_vector,\r\nks->signo,\r\nks->err_code,\r\nremcom_in_buffer,\r\nremcom_out_buffer,\r\nks->linux_regs);\r\nif (error >= 0 || remcom_in_buffer[0] == 'D' ||\r\nremcom_in_buffer[0] == 'k') {\r\nerror = 0;\r\ngoto kgdb_exit;\r\n}\r\n}\r\nput_packet(remcom_out_buffer);\r\n}\r\nkgdb_exit:\r\nif (ks->pass_exception)\r\nerror = 1;\r\nreturn error;\r\n}\r\nint gdbstub_state(struct kgdb_state *ks, char *cmd)\r\n{\r\nint error;\r\nswitch (cmd[0]) {\r\ncase 'e':\r\nerror = kgdb_arch_handle_exception(ks->ex_vector,\r\nks->signo,\r\nks->err_code,\r\nremcom_in_buffer,\r\nremcom_out_buffer,\r\nks->linux_regs);\r\nreturn error;\r\ncase 's':\r\ncase 'c':\r\nstrcpy(remcom_in_buffer, cmd);\r\nreturn 0;\r\ncase '$':\r\nstrcpy(remcom_in_buffer, cmd);\r\ngdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\r\ngdbstub_prev_in_buf_pos = 0;\r\nreturn 0;\r\n}\r\ndbg_io_ops->write_char('+');\r\nput_packet(remcom_out_buffer);\r\nreturn 0;\r\n}\r\nvoid gdbstub_exit(int status)\r\n{\r\nunsigned char checksum, ch, buffer[3];\r\nint loop;\r\nif (!kgdb_connected)\r\nreturn;\r\nkgdb_connected = 0;\r\nif (!dbg_io_ops || dbg_kdb_mode)\r\nreturn;\r\nbuffer[0] = 'W';\r\nbuffer[1] = hex_asc_hi(status);\r\nbuffer[2] = hex_asc_lo(status);\r\ndbg_io_ops->write_char('$');\r\nchecksum = 0;\r\nfor (loop = 0; loop < 3; loop++) {\r\nch = buffer[loop];\r\nchecksum += ch;\r\ndbg_io_ops->write_char(ch);\r\n}\r\ndbg_io_ops->write_char('#');\r\ndbg_io_ops->write_char(hex_asc_hi(checksum));\r\ndbg_io_ops->write_char(hex_asc_lo(checksum));\r\nif (dbg_io_ops->flush)\r\ndbg_io_ops->flush();\r\n}
