static void sym_add_default(struct symbol *sym, const char *def)\r\n{\r\nstruct property *prop = prop_alloc(P_DEFAULT, sym);\r\nprop->expr = expr_alloc_symbol(sym_lookup(def, SYMBOL_CONST));\r\n}\r\nvoid sym_init(void)\r\n{\r\nstruct symbol *sym;\r\nstruct utsname uts;\r\nstatic bool inited = false;\r\nif (inited)\r\nreturn;\r\ninited = true;\r\nuname(&uts);\r\nsym = sym_lookup("UNAME_RELEASE", 0);\r\nsym->type = S_STRING;\r\nsym->flags |= SYMBOL_AUTO;\r\nsym_add_default(sym, uts.release);\r\n}\r\nenum symbol_type sym_get_type(struct symbol *sym)\r\n{\r\nenum symbol_type type = sym->type;\r\nif (type == S_TRISTATE) {\r\nif (sym_is_choice_value(sym) && sym->visible == yes)\r\ntype = S_BOOLEAN;\r\nelse if (modules_val == no)\r\ntype = S_BOOLEAN;\r\n}\r\nreturn type;\r\n}\r\nconst char *sym_type_name(enum symbol_type type)\r\n{\r\nswitch (type) {\r\ncase S_BOOLEAN:\r\nreturn "boolean";\r\ncase S_TRISTATE:\r\nreturn "tristate";\r\ncase S_INT:\r\nreturn "integer";\r\ncase S_HEX:\r\nreturn "hex";\r\ncase S_STRING:\r\nreturn "string";\r\ncase S_UNKNOWN:\r\nreturn "unknown";\r\ncase S_OTHER:\r\nbreak;\r\n}\r\nreturn "???";\r\n}\r\nstruct property *sym_get_choice_prop(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nfor_all_choices(sym, prop)\r\nreturn prop;\r\nreturn NULL;\r\n}\r\nstruct property *sym_get_env_prop(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nfor_all_properties(sym, prop, P_ENV)\r\nreturn prop;\r\nreturn NULL;\r\n}\r\nstruct property *sym_get_default_prop(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nfor_all_defaults(sym, prop) {\r\nprop->visible.tri = expr_calc_value(prop->visible.expr);\r\nif (prop->visible.tri != no)\r\nreturn prop;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct property *sym_get_range_prop(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nfor_all_properties(sym, prop, P_RANGE) {\r\nprop->visible.tri = expr_calc_value(prop->visible.expr);\r\nif (prop->visible.tri != no)\r\nreturn prop;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sym_get_range_val(struct symbol *sym, int base)\r\n{\r\nsym_calc_value(sym);\r\nswitch (sym->type) {\r\ncase S_INT:\r\nbase = 10;\r\nbreak;\r\ncase S_HEX:\r\nbase = 16;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn strtol(sym->curr.val, NULL, base);\r\n}\r\nstatic void sym_validate_range(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nint base, val, val2;\r\nchar str[64];\r\nswitch (sym->type) {\r\ncase S_INT:\r\nbase = 10;\r\nbreak;\r\ncase S_HEX:\r\nbase = 16;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nprop = sym_get_range_prop(sym);\r\nif (!prop)\r\nreturn;\r\nval = strtol(sym->curr.val, NULL, base);\r\nval2 = sym_get_range_val(prop->expr->left.sym, base);\r\nif (val >= val2) {\r\nval2 = sym_get_range_val(prop->expr->right.sym, base);\r\nif (val <= val2)\r\nreturn;\r\n}\r\nif (sym->type == S_INT)\r\nsprintf(str, "%d", val2);\r\nelse\r\nsprintf(str, "0x%x", val2);\r\nsym->curr.val = strdup(str);\r\n}\r\nstatic void sym_calc_visibility(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\ntristate tri;\r\ntri = no;\r\nfor_all_prompts(sym, prop) {\r\nprop->visible.tri = expr_calc_value(prop->visible.expr);\r\ntri = EXPR_OR(tri, prop->visible.tri);\r\n}\r\nif (tri == mod && (sym->type != S_TRISTATE || modules_val == no))\r\ntri = yes;\r\nif (sym->visible != tri) {\r\nsym->visible = tri;\r\nsym_set_changed(sym);\r\n}\r\nif (sym_is_choice_value(sym))\r\nreturn;\r\ntri = yes;\r\nif (sym->dir_dep.expr)\r\ntri = expr_calc_value(sym->dir_dep.expr);\r\nif (tri == mod)\r\ntri = yes;\r\nif (sym->dir_dep.tri != tri) {\r\nsym->dir_dep.tri = tri;\r\nsym_set_changed(sym);\r\n}\r\ntri = no;\r\nif (sym->rev_dep.expr)\r\ntri = expr_calc_value(sym->rev_dep.expr);\r\nif (tri == mod && sym_get_type(sym) == S_BOOLEAN)\r\ntri = yes;\r\nif (sym->rev_dep.tri != tri) {\r\nsym->rev_dep.tri = tri;\r\nsym_set_changed(sym);\r\n}\r\n}\r\nstruct symbol *sym_choice_default(struct symbol *sym)\r\n{\r\nstruct symbol *def_sym;\r\nstruct property *prop;\r\nstruct expr *e;\r\nfor_all_defaults(sym, prop) {\r\nprop->visible.tri = expr_calc_value(prop->visible.expr);\r\nif (prop->visible.tri == no)\r\ncontinue;\r\ndef_sym = prop_get_symbol(prop);\r\nif (def_sym->visible != no)\r\nreturn def_sym;\r\n}\r\nprop = sym_get_choice_prop(sym);\r\nexpr_list_for_each_sym(prop->expr, e, def_sym)\r\nif (def_sym->visible != no)\r\nreturn def_sym;\r\nreturn NULL;\r\n}\r\nstatic struct symbol *sym_calc_choice(struct symbol *sym)\r\n{\r\nstruct symbol *def_sym;\r\nstruct property *prop;\r\nstruct expr *e;\r\nint flags;\r\nflags = sym->flags;\r\nprop = sym_get_choice_prop(sym);\r\nexpr_list_for_each_sym(prop->expr, e, def_sym) {\r\nsym_calc_visibility(def_sym);\r\nif (def_sym->visible != no)\r\nflags &= def_sym->flags;\r\n}\r\nsym->flags &= flags | ~SYMBOL_DEF_USER;\r\ndef_sym = sym->def[S_DEF_USER].val;\r\nif (def_sym && def_sym->visible != no)\r\nreturn def_sym;\r\ndef_sym = sym_choice_default(sym);\r\nif (def_sym == NULL)\r\nsym->curr.tri = no;\r\nreturn def_sym;\r\n}\r\nvoid sym_calc_value(struct symbol *sym)\r\n{\r\nstruct symbol_value newval, oldval;\r\nstruct property *prop;\r\nstruct expr *e;\r\nif (!sym)\r\nreturn;\r\nif (sym->flags & SYMBOL_VALID)\r\nreturn;\r\nsym->flags |= SYMBOL_VALID;\r\noldval = sym->curr;\r\nswitch (sym->type) {\r\ncase S_INT:\r\ncase S_HEX:\r\ncase S_STRING:\r\nnewval = symbol_empty.curr;\r\nbreak;\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nnewval = symbol_no.curr;\r\nbreak;\r\ndefault:\r\nsym->curr.val = sym->name;\r\nsym->curr.tri = no;\r\nreturn;\r\n}\r\nif (!sym_is_choice_value(sym))\r\nsym->flags &= ~SYMBOL_WRITE;\r\nsym_calc_visibility(sym);\r\nsym->curr = newval;\r\nswitch (sym_get_type(sym)) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nif (sym_is_choice_value(sym) && sym->visible == yes) {\r\nprop = sym_get_choice_prop(sym);\r\nnewval.tri = (prop_get_symbol(prop)->curr.val == sym) ? yes : no;\r\n} else {\r\nif (sym->visible != no) {\r\nsym->flags |= SYMBOL_WRITE;\r\nif (sym_has_value(sym)) {\r\nnewval.tri = EXPR_AND(sym->def[S_DEF_USER].tri,\r\nsym->visible);\r\ngoto calc_newval;\r\n}\r\n}\r\nif (sym->rev_dep.tri != no)\r\nsym->flags |= SYMBOL_WRITE;\r\nif (!sym_is_choice(sym)) {\r\nprop = sym_get_default_prop(sym);\r\nif (prop) {\r\nsym->flags |= SYMBOL_WRITE;\r\nnewval.tri = EXPR_AND(expr_calc_value(prop->expr),\r\nprop->visible.tri);\r\n}\r\n}\r\ncalc_newval:\r\nif (sym->dir_dep.tri == no && sym->rev_dep.tri != no) {\r\nstruct expr *e;\r\ne = expr_simplify_unmet_dep(sym->rev_dep.expr,\r\nsym->dir_dep.expr);\r\nfprintf(stderr, "warning: (");\r\nexpr_fprint(e, stderr);\r\nfprintf(stderr, ") selects %s which has unmet direct dependencies (",\r\nsym->name);\r\nexpr_fprint(sym->dir_dep.expr, stderr);\r\nfprintf(stderr, ")\n");\r\nexpr_free(e);\r\n}\r\nnewval.tri = EXPR_OR(newval.tri, sym->rev_dep.tri);\r\n}\r\nif (newval.tri == mod && sym_get_type(sym) == S_BOOLEAN)\r\nnewval.tri = yes;\r\nbreak;\r\ncase S_STRING:\r\ncase S_HEX:\r\ncase S_INT:\r\nif (sym->visible != no) {\r\nsym->flags |= SYMBOL_WRITE;\r\nif (sym_has_value(sym)) {\r\nnewval.val = sym->def[S_DEF_USER].val;\r\nbreak;\r\n}\r\n}\r\nprop = sym_get_default_prop(sym);\r\nif (prop) {\r\nstruct symbol *ds = prop_get_symbol(prop);\r\nif (ds) {\r\nsym->flags |= SYMBOL_WRITE;\r\nsym_calc_value(ds);\r\nnewval.val = ds->curr.val;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nsym->curr = newval;\r\nif (sym_is_choice(sym) && newval.tri == yes)\r\nsym->curr.val = sym_calc_choice(sym);\r\nsym_validate_range(sym);\r\nif (memcmp(&oldval, &sym->curr, sizeof(oldval))) {\r\nsym_set_changed(sym);\r\nif (modules_sym == sym) {\r\nsym_set_all_changed();\r\nmodules_val = modules_sym->curr.tri;\r\n}\r\n}\r\nif (sym_is_choice(sym)) {\r\nstruct symbol *choice_sym;\r\nprop = sym_get_choice_prop(sym);\r\nexpr_list_for_each_sym(prop->expr, e, choice_sym) {\r\nif ((sym->flags & SYMBOL_WRITE) &&\r\nchoice_sym->visible != no)\r\nchoice_sym->flags |= SYMBOL_WRITE;\r\nif (sym->flags & SYMBOL_CHANGED)\r\nsym_set_changed(choice_sym);\r\n}\r\n}\r\nif (sym->flags & SYMBOL_AUTO)\r\nsym->flags &= ~SYMBOL_WRITE;\r\n}\r\nvoid sym_clear_all_valid(void)\r\n{\r\nstruct symbol *sym;\r\nint i;\r\nfor_all_symbols(i, sym)\r\nsym->flags &= ~SYMBOL_VALID;\r\nsym_add_change_count(1);\r\nif (modules_sym)\r\nsym_calc_value(modules_sym);\r\n}\r\nvoid sym_set_changed(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nsym->flags |= SYMBOL_CHANGED;\r\nfor (prop = sym->prop; prop; prop = prop->next) {\r\nif (prop->menu)\r\nprop->menu->flags |= MENU_CHANGED;\r\n}\r\n}\r\nvoid sym_set_all_changed(void)\r\n{\r\nstruct symbol *sym;\r\nint i;\r\nfor_all_symbols(i, sym)\r\nsym_set_changed(sym);\r\n}\r\nbool sym_tristate_within_range(struct symbol *sym, tristate val)\r\n{\r\nint type = sym_get_type(sym);\r\nif (sym->visible == no)\r\nreturn false;\r\nif (type != S_BOOLEAN && type != S_TRISTATE)\r\nreturn false;\r\nif (type == S_BOOLEAN && val == mod)\r\nreturn false;\r\nif (sym->visible <= sym->rev_dep.tri)\r\nreturn false;\r\nif (sym_is_choice_value(sym) && sym->visible == yes)\r\nreturn val == yes;\r\nreturn val >= sym->rev_dep.tri && val <= sym->visible;\r\n}\r\nbool sym_set_tristate_value(struct symbol *sym, tristate val)\r\n{\r\ntristate oldval = sym_get_tristate_value(sym);\r\nif (oldval != val && !sym_tristate_within_range(sym, val))\r\nreturn false;\r\nif (!(sym->flags & SYMBOL_DEF_USER)) {\r\nsym->flags |= SYMBOL_DEF_USER;\r\nsym_set_changed(sym);\r\n}\r\nif (sym_is_choice_value(sym) && val == yes) {\r\nstruct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));\r\nstruct property *prop;\r\nstruct expr *e;\r\ncs->def[S_DEF_USER].val = sym;\r\ncs->flags |= SYMBOL_DEF_USER;\r\nprop = sym_get_choice_prop(cs);\r\nfor (e = prop->expr; e; e = e->left.expr) {\r\nif (e->right.sym->visible != no)\r\ne->right.sym->flags |= SYMBOL_DEF_USER;\r\n}\r\n}\r\nsym->def[S_DEF_USER].tri = val;\r\nif (oldval != val)\r\nsym_clear_all_valid();\r\nreturn true;\r\n}\r\ntristate sym_toggle_tristate_value(struct symbol *sym)\r\n{\r\ntristate oldval, newval;\r\noldval = newval = sym_get_tristate_value(sym);\r\ndo {\r\nswitch (newval) {\r\ncase no:\r\nnewval = mod;\r\nbreak;\r\ncase mod:\r\nnewval = yes;\r\nbreak;\r\ncase yes:\r\nnewval = no;\r\nbreak;\r\n}\r\nif (sym_set_tristate_value(sym, newval))\r\nbreak;\r\n} while (oldval != newval);\r\nreturn newval;\r\n}\r\nbool sym_string_valid(struct symbol *sym, const char *str)\r\n{\r\nsigned char ch;\r\nswitch (sym->type) {\r\ncase S_STRING:\r\nreturn true;\r\ncase S_INT:\r\nch = *str++;\r\nif (ch == '-')\r\nch = *str++;\r\nif (!isdigit(ch))\r\nreturn false;\r\nif (ch == '0' && *str != 0)\r\nreturn false;\r\nwhile ((ch = *str++)) {\r\nif (!isdigit(ch))\r\nreturn false;\r\n}\r\nreturn true;\r\ncase S_HEX:\r\nif (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))\r\nstr += 2;\r\nch = *str++;\r\ndo {\r\nif (!isxdigit(ch))\r\nreturn false;\r\n} while ((ch = *str++));\r\nreturn true;\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nswitch (str[0]) {\r\ncase 'y': case 'Y':\r\ncase 'm': case 'M':\r\ncase 'n': case 'N':\r\nreturn true;\r\n}\r\nreturn false;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nbool sym_string_within_range(struct symbol *sym, const char *str)\r\n{\r\nstruct property *prop;\r\nint val;\r\nswitch (sym->type) {\r\ncase S_STRING:\r\nreturn sym_string_valid(sym, str);\r\ncase S_INT:\r\nif (!sym_string_valid(sym, str))\r\nreturn false;\r\nprop = sym_get_range_prop(sym);\r\nif (!prop)\r\nreturn true;\r\nval = strtol(str, NULL, 10);\r\nreturn val >= sym_get_range_val(prop->expr->left.sym, 10) &&\r\nval <= sym_get_range_val(prop->expr->right.sym, 10);\r\ncase S_HEX:\r\nif (!sym_string_valid(sym, str))\r\nreturn false;\r\nprop = sym_get_range_prop(sym);\r\nif (!prop)\r\nreturn true;\r\nval = strtol(str, NULL, 16);\r\nreturn val >= sym_get_range_val(prop->expr->left.sym, 16) &&\r\nval <= sym_get_range_val(prop->expr->right.sym, 16);\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nswitch (str[0]) {\r\ncase 'y': case 'Y':\r\nreturn sym_tristate_within_range(sym, yes);\r\ncase 'm': case 'M':\r\nreturn sym_tristate_within_range(sym, mod);\r\ncase 'n': case 'N':\r\nreturn sym_tristate_within_range(sym, no);\r\n}\r\nreturn false;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nbool sym_set_string_value(struct symbol *sym, const char *newval)\r\n{\r\nconst char *oldval;\r\nchar *val;\r\nint size;\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nswitch (newval[0]) {\r\ncase 'y': case 'Y':\r\nreturn sym_set_tristate_value(sym, yes);\r\ncase 'm': case 'M':\r\nreturn sym_set_tristate_value(sym, mod);\r\ncase 'n': case 'N':\r\nreturn sym_set_tristate_value(sym, no);\r\n}\r\nreturn false;\r\ndefault:\r\n;\r\n}\r\nif (!sym_string_within_range(sym, newval))\r\nreturn false;\r\nif (!(sym->flags & SYMBOL_DEF_USER)) {\r\nsym->flags |= SYMBOL_DEF_USER;\r\nsym_set_changed(sym);\r\n}\r\noldval = sym->def[S_DEF_USER].val;\r\nsize = strlen(newval) + 1;\r\nif (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {\r\nsize += 2;\r\nsym->def[S_DEF_USER].val = val = malloc(size);\r\n*val++ = '0';\r\n*val++ = 'x';\r\n} else if (!oldval || strcmp(oldval, newval))\r\nsym->def[S_DEF_USER].val = val = malloc(size);\r\nelse\r\nreturn true;\r\nstrcpy(val, newval);\r\nfree((void *)oldval);\r\nsym_clear_all_valid();\r\nreturn true;\r\n}\r\nconst char *sym_get_string_default(struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nstruct symbol *ds;\r\nconst char *str;\r\ntristate val;\r\nsym_calc_visibility(sym);\r\nsym_calc_value(modules_sym);\r\nval = symbol_no.curr.tri;\r\nstr = symbol_empty.curr.val;\r\nprop = sym_get_default_prop(sym);\r\nif (prop != NULL) {\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nval = EXPR_AND(expr_calc_value(prop->expr), prop->visible.tri);\r\nbreak;\r\ndefault:\r\nds = prop_get_symbol(prop);\r\nif (ds != NULL) {\r\nsym_calc_value(ds);\r\nstr = (const char *)ds->curr.val;\r\n}\r\n}\r\n}\r\nval = EXPR_OR(val, sym->rev_dep.tri);\r\nif (val == mod)\r\nif (!sym_is_choice_value(sym) && modules_sym->curr.tri == no)\r\nval = yes;\r\nif (sym->type == S_BOOLEAN && val == mod)\r\nval = yes;\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nswitch (val) {\r\ncase no: return "n";\r\ncase mod: return "m";\r\ncase yes: return "y";\r\n}\r\ncase S_INT:\r\ncase S_HEX:\r\nreturn str;\r\ncase S_STRING:\r\nreturn str;\r\ncase S_OTHER:\r\ncase S_UNKNOWN:\r\nbreak;\r\n}\r\nreturn "";\r\n}\r\nconst char *sym_get_string_value(struct symbol *sym)\r\n{\r\ntristate val;\r\nswitch (sym->type) {\r\ncase S_BOOLEAN:\r\ncase S_TRISTATE:\r\nval = sym_get_tristate_value(sym);\r\nswitch (val) {\r\ncase no:\r\nreturn "n";\r\ncase mod:\r\nsym_calc_value(modules_sym);\r\nreturn (modules_sym->curr.tri == no) ? "n" : "m";\r\ncase yes:\r\nreturn "y";\r\n}\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn (const char *)sym->curr.val;\r\n}\r\nbool sym_is_changable(struct symbol *sym)\r\n{\r\nreturn sym->visible > sym->rev_dep.tri;\r\n}\r\nstatic unsigned strhash(const char *s)\r\n{\r\nunsigned hash = 2166136261U;\r\nfor (; *s; s++)\r\nhash = (hash ^ *s) * 0x01000193;\r\nreturn hash;\r\n}\r\nstruct symbol *sym_lookup(const char *name, int flags)\r\n{\r\nstruct symbol *symbol;\r\nchar *new_name;\r\nint hash;\r\nif (name) {\r\nif (name[0] && !name[1]) {\r\nswitch (name[0]) {\r\ncase 'y': return &symbol_yes;\r\ncase 'm': return &symbol_mod;\r\ncase 'n': return &symbol_no;\r\n}\r\n}\r\nhash = strhash(name) % SYMBOL_HASHSIZE;\r\nfor (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {\r\nif (symbol->name &&\r\n!strcmp(symbol->name, name) &&\r\n(flags ? symbol->flags & flags\r\n: !(symbol->flags & (SYMBOL_CONST|SYMBOL_CHOICE))))\r\nreturn symbol;\r\n}\r\nnew_name = strdup(name);\r\n} else {\r\nnew_name = NULL;\r\nhash = 0;\r\n}\r\nsymbol = malloc(sizeof(*symbol));\r\nmemset(symbol, 0, sizeof(*symbol));\r\nsymbol->name = new_name;\r\nsymbol->type = S_UNKNOWN;\r\nsymbol->flags |= flags;\r\nsymbol->next = symbol_hash[hash];\r\nsymbol_hash[hash] = symbol;\r\nreturn symbol;\r\n}\r\nstruct symbol *sym_find(const char *name)\r\n{\r\nstruct symbol *symbol = NULL;\r\nint hash = 0;\r\nif (!name)\r\nreturn NULL;\r\nif (name[0] && !name[1]) {\r\nswitch (name[0]) {\r\ncase 'y': return &symbol_yes;\r\ncase 'm': return &symbol_mod;\r\ncase 'n': return &symbol_no;\r\n}\r\n}\r\nhash = strhash(name) % SYMBOL_HASHSIZE;\r\nfor (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {\r\nif (symbol->name &&\r\n!strcmp(symbol->name, name) &&\r\n!(symbol->flags & SYMBOL_CONST))\r\nbreak;\r\n}\r\nreturn symbol;\r\n}\r\nconst char *sym_expand_string_value(const char *in)\r\n{\r\nconst char *src;\r\nchar *res;\r\nsize_t reslen;\r\nreslen = strlen(in) + 1;\r\nres = malloc(reslen);\r\nres[0] = '\0';\r\nwhile ((src = strchr(in, '$'))) {\r\nchar *p, name[SYMBOL_MAXLENGTH];\r\nconst char *symval = "";\r\nstruct symbol *sym;\r\nsize_t newlen;\r\nstrncat(res, in, src - in);\r\nsrc++;\r\np = name;\r\nwhile (isalnum(*src) || *src == '_')\r\n*p++ = *src++;\r\n*p = '\0';\r\nsym = sym_find(name);\r\nif (sym != NULL) {\r\nsym_calc_value(sym);\r\nsymval = sym_get_string_value(sym);\r\n}\r\nnewlen = strlen(res) + strlen(symval) + strlen(src) + 1;\r\nif (newlen > reslen) {\r\nreslen = newlen;\r\nres = realloc(res, reslen);\r\n}\r\nstrcat(res, symval);\r\nin = src;\r\n}\r\nstrcat(res, in);\r\nreturn res;\r\n}\r\nconst char *sym_escape_string_value(const char *in)\r\n{\r\nconst char *p;\r\nsize_t reslen;\r\nchar *res;\r\nsize_t l;\r\nreslen = strlen(in) + strlen("\"\"") + 1;\r\np = in;\r\nfor (;;) {\r\nl = strcspn(p, "\"\\");\r\np += l;\r\nif (p[0] == '\0')\r\nbreak;\r\nreslen++;\r\np++;\r\n}\r\nres = malloc(reslen);\r\nres[0] = '\0';\r\nstrcat(res, "\"");\r\np = in;\r\nfor (;;) {\r\nl = strcspn(p, "\"\\");\r\nstrncat(res, p, l);\r\np += l;\r\nif (p[0] == '\0')\r\nbreak;\r\nstrcat(res, "\\");\r\nstrncat(res, p++, 1);\r\n}\r\nstrcat(res, "\"");\r\nreturn res;\r\n}\r\nstruct symbol **sym_re_search(const char *pattern)\r\n{\r\nstruct symbol *sym, **sym_arr = NULL;\r\nint i, cnt, size;\r\nregex_t re;\r\ncnt = size = 0;\r\nif (strlen(pattern) == 0)\r\nreturn NULL;\r\nif (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB|REG_ICASE))\r\nreturn NULL;\r\nfor_all_symbols(i, sym) {\r\nif (sym->flags & SYMBOL_CONST || !sym->name)\r\ncontinue;\r\nif (regexec(&re, sym->name, 0, NULL, 0))\r\ncontinue;\r\nif (cnt + 1 >= size) {\r\nvoid *tmp = sym_arr;\r\nsize += 16;\r\nsym_arr = realloc(sym_arr, size * sizeof(struct symbol *));\r\nif (!sym_arr) {\r\nfree(tmp);\r\nreturn NULL;\r\n}\r\n}\r\nsym_calc_value(sym);\r\nsym_arr[cnt++] = sym;\r\n}\r\nif (sym_arr)\r\nsym_arr[cnt] = NULL;\r\nregfree(&re);\r\nreturn sym_arr;\r\n}\r\nstatic void dep_stack_insert(struct dep_stack *stack, struct symbol *sym)\r\n{\r\nmemset(stack, 0, sizeof(*stack));\r\nif (check_top)\r\ncheck_top->next = stack;\r\nstack->prev = check_top;\r\nstack->sym = sym;\r\ncheck_top = stack;\r\n}\r\nstatic void dep_stack_remove(void)\r\n{\r\ncheck_top = check_top->prev;\r\nif (check_top)\r\ncheck_top->next = NULL;\r\n}\r\nstatic void sym_check_print_recursive(struct symbol *last_sym)\r\n{\r\nstruct dep_stack *stack;\r\nstruct symbol *sym, *next_sym;\r\nstruct menu *menu = NULL;\r\nstruct property *prop;\r\nstruct dep_stack cv_stack;\r\nif (sym_is_choice_value(last_sym)) {\r\ndep_stack_insert(&cv_stack, last_sym);\r\nlast_sym = prop_get_symbol(sym_get_choice_prop(last_sym));\r\n}\r\nfor (stack = check_top; stack != NULL; stack = stack->prev)\r\nif (stack->sym == last_sym)\r\nbreak;\r\nif (!stack) {\r\nfprintf(stderr, "unexpected recursive dependency error\n");\r\nreturn;\r\n}\r\nfor (; stack; stack = stack->next) {\r\nsym = stack->sym;\r\nnext_sym = stack->next ? stack->next->sym : last_sym;\r\nprop = stack->prop;\r\nif (prop == NULL)\r\nprop = stack->sym->prop;\r\nif (sym_is_choice(sym) || sym_is_choice_value(sym)) {\r\nfor (prop = sym->prop; prop; prop = prop->next) {\r\nmenu = prop->menu;\r\nif (prop->menu)\r\nbreak;\r\n}\r\n}\r\nif (stack->sym == last_sym)\r\nfprintf(stderr, "%s:%d:error: recursive dependency detected!\n",\r\nprop->file->name, prop->lineno);\r\nif (stack->expr) {\r\nfprintf(stderr, "%s:%d:\tsymbol %s %s value contains %s\n",\r\nprop->file->name, prop->lineno,\r\nsym->name ? sym->name : "<choice>",\r\nprop_get_type_name(prop->type),\r\nnext_sym->name ? next_sym->name : "<choice>");\r\n} else if (stack->prop) {\r\nfprintf(stderr, "%s:%d:\tsymbol %s depends on %s\n",\r\nprop->file->name, prop->lineno,\r\nsym->name ? sym->name : "<choice>",\r\nnext_sym->name ? next_sym->name : "<choice>");\r\n} else if (sym_is_choice(sym)) {\r\nfprintf(stderr, "%s:%d:\tchoice %s contains symbol %s\n",\r\nmenu->file->name, menu->lineno,\r\nsym->name ? sym->name : "<choice>",\r\nnext_sym->name ? next_sym->name : "<choice>");\r\n} else if (sym_is_choice_value(sym)) {\r\nfprintf(stderr, "%s:%d:\tsymbol %s is part of choice %s\n",\r\nmenu->file->name, menu->lineno,\r\nsym->name ? sym->name : "<choice>",\r\nnext_sym->name ? next_sym->name : "<choice>");\r\n} else {\r\nfprintf(stderr, "%s:%d:\tsymbol %s is selected by %s\n",\r\nprop->file->name, prop->lineno,\r\nsym->name ? sym->name : "<choice>",\r\nnext_sym->name ? next_sym->name : "<choice>");\r\n}\r\n}\r\nif (check_top == &cv_stack)\r\ndep_stack_remove();\r\n}\r\nstatic struct symbol *sym_check_expr_deps(struct expr *e)\r\n{\r\nstruct symbol *sym;\r\nif (!e)\r\nreturn NULL;\r\nswitch (e->type) {\r\ncase E_OR:\r\ncase E_AND:\r\nsym = sym_check_expr_deps(e->left.expr);\r\nif (sym)\r\nreturn sym;\r\nreturn sym_check_expr_deps(e->right.expr);\r\ncase E_NOT:\r\nreturn sym_check_expr_deps(e->left.expr);\r\ncase E_EQUAL:\r\ncase E_UNEQUAL:\r\nsym = sym_check_deps(e->left.sym);\r\nif (sym)\r\nreturn sym;\r\nreturn sym_check_deps(e->right.sym);\r\ncase E_SYMBOL:\r\nreturn sym_check_deps(e->left.sym);\r\ndefault:\r\nbreak;\r\n}\r\nprintf("Oops! How to check %d?\n", e->type);\r\nreturn NULL;\r\n}\r\nstatic struct symbol *sym_check_sym_deps(struct symbol *sym)\r\n{\r\nstruct symbol *sym2;\r\nstruct property *prop;\r\nstruct dep_stack stack;\r\ndep_stack_insert(&stack, sym);\r\nsym2 = sym_check_expr_deps(sym->rev_dep.expr);\r\nif (sym2)\r\ngoto out;\r\nfor (prop = sym->prop; prop; prop = prop->next) {\r\nif (prop->type == P_CHOICE || prop->type == P_SELECT)\r\ncontinue;\r\nstack.prop = prop;\r\nsym2 = sym_check_expr_deps(prop->visible.expr);\r\nif (sym2)\r\nbreak;\r\nif (prop->type != P_DEFAULT || sym_is_choice(sym))\r\ncontinue;\r\nstack.expr = prop->expr;\r\nsym2 = sym_check_expr_deps(prop->expr);\r\nif (sym2)\r\nbreak;\r\nstack.expr = NULL;\r\n}\r\nout:\r\ndep_stack_remove();\r\nreturn sym2;\r\n}\r\nstatic struct symbol *sym_check_choice_deps(struct symbol *choice)\r\n{\r\nstruct symbol *sym, *sym2;\r\nstruct property *prop;\r\nstruct expr *e;\r\nstruct dep_stack stack;\r\ndep_stack_insert(&stack, choice);\r\nprop = sym_get_choice_prop(choice);\r\nexpr_list_for_each_sym(prop->expr, e, sym)\r\nsym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);\r\nchoice->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);\r\nsym2 = sym_check_sym_deps(choice);\r\nchoice->flags &= ~SYMBOL_CHECK;\r\nif (sym2)\r\ngoto out;\r\nexpr_list_for_each_sym(prop->expr, e, sym) {\r\nsym2 = sym_check_sym_deps(sym);\r\nif (sym2)\r\nbreak;\r\n}\r\nout:\r\nexpr_list_for_each_sym(prop->expr, e, sym)\r\nsym->flags &= ~SYMBOL_CHECK;\r\nif (sym2 && sym_is_choice_value(sym2) &&\r\nprop_get_symbol(sym_get_choice_prop(sym2)) == choice)\r\nsym2 = choice;\r\ndep_stack_remove();\r\nreturn sym2;\r\n}\r\nstruct symbol *sym_check_deps(struct symbol *sym)\r\n{\r\nstruct symbol *sym2;\r\nstruct property *prop;\r\nif (sym->flags & SYMBOL_CHECK) {\r\nsym_check_print_recursive(sym);\r\nreturn sym;\r\n}\r\nif (sym->flags & SYMBOL_CHECKED)\r\nreturn NULL;\r\nif (sym_is_choice_value(sym)) {\r\nstruct dep_stack stack;\r\ndep_stack_insert(&stack, sym);\r\nprop = sym_get_choice_prop(sym);\r\nsym2 = sym_check_deps(prop_get_symbol(prop));\r\ndep_stack_remove();\r\n} else if (sym_is_choice(sym)) {\r\nsym2 = sym_check_choice_deps(sym);\r\n} else {\r\nsym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);\r\nsym2 = sym_check_sym_deps(sym);\r\nsym->flags &= ~SYMBOL_CHECK;\r\n}\r\nif (sym2 && sym2 == sym)\r\nsym2 = NULL;\r\nreturn sym2;\r\n}\r\nstruct property *prop_alloc(enum prop_type type, struct symbol *sym)\r\n{\r\nstruct property *prop;\r\nstruct property **propp;\r\nprop = malloc(sizeof(*prop));\r\nmemset(prop, 0, sizeof(*prop));\r\nprop->type = type;\r\nprop->sym = sym;\r\nprop->file = current_file;\r\nprop->lineno = zconf_lineno();\r\nif (sym) {\r\nfor (propp = &sym->prop; *propp; propp = &(*propp)->next)\r\n;\r\n*propp = prop;\r\n}\r\nreturn prop;\r\n}\r\nstruct symbol *prop_get_symbol(struct property *prop)\r\n{\r\nif (prop->expr && (prop->expr->type == E_SYMBOL ||\r\nprop->expr->type == E_LIST))\r\nreturn prop->expr->left.sym;\r\nreturn NULL;\r\n}\r\nconst char *prop_get_type_name(enum prop_type type)\r\n{\r\nswitch (type) {\r\ncase P_PROMPT:\r\nreturn "prompt";\r\ncase P_ENV:\r\nreturn "env";\r\ncase P_COMMENT:\r\nreturn "comment";\r\ncase P_MENU:\r\nreturn "menu";\r\ncase P_DEFAULT:\r\nreturn "default";\r\ncase P_CHOICE:\r\nreturn "choice";\r\ncase P_SELECT:\r\nreturn "select";\r\ncase P_RANGE:\r\nreturn "range";\r\ncase P_SYMBOL:\r\nreturn "symbol";\r\ncase P_UNKNOWN:\r\nbreak;\r\n}\r\nreturn "unknown";\r\n}\r\nstatic void prop_add_env(const char *env)\r\n{\r\nstruct symbol *sym, *sym2;\r\nstruct property *prop;\r\nchar *p;\r\nsym = current_entry->sym;\r\nsym->flags |= SYMBOL_AUTO;\r\nfor_all_properties(sym, prop, P_ENV) {\r\nsym2 = prop_get_symbol(prop);\r\nif (strcmp(sym2->name, env))\r\nmenu_warn(current_entry, "redefining environment symbol from %s",\r\nsym2->name);\r\nreturn;\r\n}\r\nprop = prop_alloc(P_ENV, sym);\r\nprop->expr = expr_alloc_symbol(sym_lookup(env, SYMBOL_CONST));\r\nsym_env_list = expr_alloc_one(E_LIST, sym_env_list);\r\nsym_env_list->right.sym = sym;\r\np = getenv(env);\r\nif (p)\r\nsym_add_default(sym, p);\r\nelse\r\nmenu_warn(current_entry, "environment variable %s undefined", env);\r\n}
