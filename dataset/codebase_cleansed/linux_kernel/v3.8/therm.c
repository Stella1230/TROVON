static u16\r\ntherm_table(struct nouveau_bios *bios, u8 *ver, u8 *hdr, u8 *len, u8 *cnt)\r\n{\r\nstruct bit_entry bit_P;\r\nu16 therm = 0;\r\nif (!bit_entry(bios, 'P', &bit_P)) {\r\nif (bit_P.version == 1)\r\ntherm = nv_ro16(bios, bit_P.offset + 12);\r\nelse if (bit_P.version == 2)\r\ntherm = nv_ro16(bios, bit_P.offset + 16);\r\nelse\r\nnv_error(bios,\r\n"unknown offset for thermal in BIT P %d\n",\r\nbit_P.version);\r\n}\r\nif (!therm)\r\nreturn 0x0000;\r\n*ver = nv_ro08(bios, therm + 0);\r\n*hdr = nv_ro08(bios, therm + 1);\r\n*len = nv_ro08(bios, therm + 2);\r\n*cnt = nv_ro08(bios, therm + 3);\r\nreturn therm + nv_ro08(bios, therm + 1);\r\n}\r\nu16\r\nnvbios_therm_entry(struct nouveau_bios *bios, int idx, u8 *ver, u8 *len)\r\n{\r\nu8 hdr, cnt;\r\nu16 therm = therm_table(bios, ver, &hdr, len, &cnt);\r\nif (therm && idx < cnt)\r\nreturn therm + idx * *len;\r\nreturn 0x0000;\r\n}\r\nint\r\nnvbios_therm_sensor_parse(struct nouveau_bios *bios,\r\nenum nvbios_therm_domain domain,\r\nstruct nvbios_therm_sensor *sensor)\r\n{\r\ns8 thrs_section, sensor_section, offset;\r\nu8 ver, len, i;\r\nu16 entry;\r\nif (domain != NVBIOS_THERM_DOMAIN_CORE)\r\nreturn -EINVAL;\r\nthrs_section = 0;\r\nsensor_section = -1;\r\ni = 0;\r\nwhile ((entry = nvbios_therm_entry(bios, i++, &ver, &len))) {\r\ns16 value = nv_ro16(bios, entry + 1);\r\nswitch (nv_ro08(bios, entry + 0)) {\r\ncase 0x0:\r\nthrs_section = value;\r\nif (value > 0)\r\nreturn 0;\r\nbreak;\r\ncase 0x01:\r\nsensor_section++;\r\nif (sensor_section == 0) {\r\noffset = ((s8) nv_ro08(bios, entry + 2)) / 2;\r\nsensor->offset_constant = offset;\r\n}\r\nbreak;\r\ncase 0x04:\r\nif (thrs_section == 0) {\r\nsensor->thrs_critical.temp = (value & 0xff0) >> 4;\r\nsensor->thrs_critical.hysteresis = value & 0xf;\r\n}\r\nbreak;\r\ncase 0x07:\r\nif (thrs_section == 0) {\r\nsensor->thrs_down_clock.temp = (value & 0xff0) >> 4;\r\nsensor->thrs_down_clock.hysteresis = value & 0xf;\r\n}\r\nbreak;\r\ncase 0x08:\r\nif (thrs_section == 0) {\r\nsensor->thrs_fan_boost.temp = (value & 0xff0) >> 4;\r\nsensor->thrs_fan_boost.hysteresis = value & 0xf;\r\n}\r\nbreak;\r\ncase 0x10:\r\nif (sensor_section == 0)\r\nsensor->offset_num = value;\r\nbreak;\r\ncase 0x11:\r\nif (sensor_section == 0)\r\nsensor->offset_den = value;\r\nbreak;\r\ncase 0x12:\r\nif (sensor_section == 0)\r\nsensor->slope_mult = value;\r\nbreak;\r\ncase 0x13:\r\nif (sensor_section == 0)\r\nsensor->slope_div = value;\r\nbreak;\r\ncase 0x32:\r\nif (thrs_section == 0) {\r\nsensor->thrs_shutdown.temp = (value & 0xff0) >> 4;\r\nsensor->thrs_shutdown.hysteresis = value & 0xf;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnvbios_therm_fan_parse(struct nouveau_bios *bios,\r\nstruct nvbios_therm_fan *fan)\r\n{\r\nu8 ver, len, i;\r\nu16 entry;\r\ni = 0;\r\nwhile ((entry = nvbios_therm_entry(bios, i++, &ver, &len))) {\r\ns16 value = nv_ro16(bios, entry + 1);\r\nswitch (nv_ro08(bios, entry + 0)) {\r\ncase 0x22:\r\nfan->min_duty = value & 0xff;\r\nfan->max_duty = (value & 0xff00) >> 8;\r\nbreak;\r\ncase 0x26:\r\nfan->pwm_freq = value;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
