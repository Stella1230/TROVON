static inline int\r\ntcindex_filter_is_set(struct tcindex_filter_result *r)\r\n{\r\nreturn tcf_exts_is_predicative(&r->exts) || r->res.classid;\r\n}\r\nstatic struct tcindex_filter_result *\r\ntcindex_lookup(struct tcindex_data *p, u16 key)\r\n{\r\nstruct tcindex_filter *f;\r\nif (p->perfect)\r\nreturn tcindex_filter_is_set(p->perfect + key) ?\r\np->perfect + key : NULL;\r\nelse if (p->h) {\r\nfor (f = p->h[key % p->hash]; f; f = f->next)\r\nif (f->key == key)\r\nreturn &f->result;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int tcindex_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcindex_filter_result *f;\r\nint key = (skb->tc_index & p->mask) >> p->shift;\r\npr_debug("tcindex_classify(skb %p,tp %p,res %p),p %p\n",\r\nskb, tp, res, p);\r\nf = tcindex_lookup(p, key);\r\nif (!f) {\r\nif (!p->fall_through)\r\nreturn -1;\r\nres->classid = TC_H_MAKE(TC_H_MAJ(tp->q->handle), key);\r\nres->class = 0;\r\npr_debug("alg 0x%x\n", res->classid);\r\nreturn 0;\r\n}\r\n*res = f->res;\r\npr_debug("map 0x%x\n", res->classid);\r\nreturn tcf_exts_exec(skb, &f->exts, res);\r\n}\r\nstatic unsigned long tcindex_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcindex_filter_result *r;\r\npr_debug("tcindex_get(tp %p,handle 0x%08x)\n", tp, handle);\r\nif (p->perfect && handle >= p->alloc_hash)\r\nreturn 0;\r\nr = tcindex_lookup(p, handle);\r\nreturn r && tcindex_filter_is_set(r) ? (unsigned long) r : 0UL;\r\n}\r\nstatic void tcindex_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\npr_debug("tcindex_put(tp %p,f 0x%lx)\n", tp, f);\r\n}\r\nstatic int tcindex_init(struct tcf_proto *tp)\r\n{\r\nstruct tcindex_data *p;\r\npr_debug("tcindex_init(tp %p)\n", tp);\r\np = kzalloc(sizeof(struct tcindex_data), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->mask = 0xffff;\r\np->hash = DEFAULT_HASH_SIZE;\r\np->fall_through = 1;\r\ntp->root = p;\r\nreturn 0;\r\n}\r\nstatic int\r\n__tcindex_delete(struct tcf_proto *tp, unsigned long arg, int lock)\r\n{\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcindex_filter_result *r = (struct tcindex_filter_result *) arg;\r\nstruct tcindex_filter *f = NULL;\r\npr_debug("tcindex_delete(tp %p,arg 0x%lx),p %p,f %p\n", tp, arg, p, f);\r\nif (p->perfect) {\r\nif (!r->res.class)\r\nreturn -ENOENT;\r\n} else {\r\nint i;\r\nstruct tcindex_filter **walk = NULL;\r\nfor (i = 0; i < p->hash; i++)\r\nfor (walk = p->h+i; *walk; walk = &(*walk)->next)\r\nif (&(*walk)->result == r)\r\ngoto found;\r\nreturn -ENOENT;\r\nfound:\r\nf = *walk;\r\nif (lock)\r\ntcf_tree_lock(tp);\r\n*walk = f->next;\r\nif (lock)\r\ntcf_tree_unlock(tp);\r\n}\r\ntcf_unbind_filter(tp, &r->res);\r\ntcf_exts_destroy(tp, &r->exts);\r\nkfree(f);\r\nreturn 0;\r\n}\r\nstatic int tcindex_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nreturn __tcindex_delete(tp, arg, 1);\r\n}\r\nstatic inline int\r\nvalid_perfect_hash(struct tcindex_data *p)\r\n{\r\nreturn p->hash > (p->mask >> p->shift);\r\n}\r\nstatic int\r\ntcindex_set_parms(struct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct tcindex_data *p, struct tcindex_filter_result *r,\r\nstruct nlattr **tb, struct nlattr *est)\r\n{\r\nint err, balloc = 0;\r\nstruct tcindex_filter_result new_filter_result, *old_r = r;\r\nstruct tcindex_filter_result cr;\r\nstruct tcindex_data cp;\r\nstruct tcindex_filter *f = NULL;\r\nstruct tcf_exts e;\r\nerr = tcf_exts_validate(tp, tb, est, &e, &tcindex_ext_map);\r\nif (err < 0)\r\nreturn err;\r\nmemcpy(&cp, p, sizeof(cp));\r\nmemset(&new_filter_result, 0, sizeof(new_filter_result));\r\nif (old_r)\r\nmemcpy(&cr, r, sizeof(cr));\r\nelse\r\nmemset(&cr, 0, sizeof(cr));\r\nif (tb[TCA_TCINDEX_HASH])\r\ncp.hash = nla_get_u32(tb[TCA_TCINDEX_HASH]);\r\nif (tb[TCA_TCINDEX_MASK])\r\ncp.mask = nla_get_u16(tb[TCA_TCINDEX_MASK]);\r\nif (tb[TCA_TCINDEX_SHIFT])\r\ncp.shift = nla_get_u32(tb[TCA_TCINDEX_SHIFT]);\r\nerr = -EBUSY;\r\nif (cp.perfect) {\r\nif (!valid_perfect_hash(&cp) ||\r\ncp.hash > cp.alloc_hash)\r\ngoto errout;\r\n} else if (cp.h && cp.hash != cp.alloc_hash)\r\ngoto errout;\r\nerr = -EINVAL;\r\nif (tb[TCA_TCINDEX_FALL_THROUGH])\r\ncp.fall_through = nla_get_u32(tb[TCA_TCINDEX_FALL_THROUGH]);\r\nif (!cp.hash) {\r\nif ((cp.mask >> cp.shift) < PERFECT_HASH_THRESHOLD)\r\ncp.hash = (cp.mask >> cp.shift) + 1;\r\nelse\r\ncp.hash = DEFAULT_HASH_SIZE;\r\n}\r\nif (!cp.perfect && !cp.h)\r\ncp.alloc_hash = cp.hash;\r\nif (cp.perfect || valid_perfect_hash(&cp))\r\nif (handle >= cp.alloc_hash)\r\ngoto errout;\r\nerr = -ENOMEM;\r\nif (!cp.perfect && !cp.h) {\r\nif (valid_perfect_hash(&cp)) {\r\ncp.perfect = kcalloc(cp.hash, sizeof(*r), GFP_KERNEL);\r\nif (!cp.perfect)\r\ngoto errout;\r\nballoc = 1;\r\n} else {\r\ncp.h = kcalloc(cp.hash, sizeof(f), GFP_KERNEL);\r\nif (!cp.h)\r\ngoto errout;\r\nballoc = 2;\r\n}\r\n}\r\nif (cp.perfect)\r\nr = cp.perfect + handle;\r\nelse\r\nr = tcindex_lookup(&cp, handle) ? : &new_filter_result;\r\nif (r == &new_filter_result) {\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (!f)\r\ngoto errout_alloc;\r\n}\r\nif (tb[TCA_TCINDEX_CLASSID]) {\r\ncr.res.classid = nla_get_u32(tb[TCA_TCINDEX_CLASSID]);\r\ntcf_bind_filter(tp, &cr.res, base);\r\n}\r\ntcf_exts_change(tp, &cr.exts, &e);\r\ntcf_tree_lock(tp);\r\nif (old_r && old_r != r)\r\nmemset(old_r, 0, sizeof(*old_r));\r\nmemcpy(p, &cp, sizeof(cp));\r\nmemcpy(r, &cr, sizeof(cr));\r\nif (r == &new_filter_result) {\r\nstruct tcindex_filter **fp;\r\nf->key = handle;\r\nf->result = new_filter_result;\r\nf->next = NULL;\r\nfor (fp = p->h+(handle % p->hash); *fp; fp = &(*fp)->next)\r\n;\r\n*fp = f;\r\n}\r\ntcf_tree_unlock(tp);\r\nreturn 0;\r\nerrout_alloc:\r\nif (balloc == 1)\r\nkfree(cp.perfect);\r\nelse if (balloc == 2)\r\nkfree(cp.h);\r\nerrout:\r\ntcf_exts_destroy(tp, &e);\r\nreturn err;\r\n}\r\nstatic int\r\ntcindex_change(struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct nlattr **tca, unsigned long *arg)\r\n{\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_TCINDEX_MAX + 1];\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcindex_filter_result *r = (struct tcindex_filter_result *) *arg;\r\nint err;\r\npr_debug("tcindex_change(tp %p,handle 0x%08x,tca %p,arg %p),opt %p,"\r\n"p %p,r %p,*arg 0x%lx\n",\r\ntp, handle, tca, arg, opt, p, r, arg ? *arg : 0L);\r\nif (!opt)\r\nreturn 0;\r\nerr = nla_parse_nested(tb, TCA_TCINDEX_MAX, opt, tcindex_policy);\r\nif (err < 0)\r\nreturn err;\r\nreturn tcindex_set_parms(tp, base, handle, p, r, tb, tca[TCA_RATE]);\r\n}\r\nstatic void tcindex_walk(struct tcf_proto *tp, struct tcf_walker *walker)\r\n{\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcindex_filter *f, *next;\r\nint i;\r\npr_debug("tcindex_walk(tp %p,walker %p),p %p\n", tp, walker, p);\r\nif (p->perfect) {\r\nfor (i = 0; i < p->hash; i++) {\r\nif (!p->perfect[i].res.class)\r\ncontinue;\r\nif (walker->count >= walker->skip) {\r\nif (walker->fn(tp,\r\n(unsigned long) (p->perfect+i), walker)\r\n< 0) {\r\nwalker->stop = 1;\r\nreturn;\r\n}\r\n}\r\nwalker->count++;\r\n}\r\n}\r\nif (!p->h)\r\nreturn;\r\nfor (i = 0; i < p->hash; i++) {\r\nfor (f = p->h[i]; f; f = next) {\r\nnext = f->next;\r\nif (walker->count >= walker->skip) {\r\nif (walker->fn(tp, (unsigned long) &f->result,\r\nwalker) < 0) {\r\nwalker->stop = 1;\r\nreturn;\r\n}\r\n}\r\nwalker->count++;\r\n}\r\n}\r\n}\r\nstatic int tcindex_destroy_element(struct tcf_proto *tp,\r\nunsigned long arg, struct tcf_walker *walker)\r\n{\r\nreturn __tcindex_delete(tp, arg, 0);\r\n}\r\nstatic void tcindex_destroy(struct tcf_proto *tp)\r\n{\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcf_walker walker;\r\npr_debug("tcindex_destroy(tp %p),p %p\n", tp, p);\r\nwalker.count = 0;\r\nwalker.skip = 0;\r\nwalker.fn = &tcindex_destroy_element;\r\ntcindex_walk(tp, &walker);\r\nkfree(p->perfect);\r\nkfree(p->h);\r\nkfree(p);\r\ntp->root = NULL;\r\n}\r\nstatic int tcindex_dump(struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct tcindex_data *p = PRIV(tp);\r\nstruct tcindex_filter_result *r = (struct tcindex_filter_result *) fh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\npr_debug("tcindex_dump(tp %p,fh 0x%lx,skb %p,t %p),p %p,r %p,b %p\n",\r\ntp, fh, skb, t, p, r, b);\r\npr_debug("p->perfect %p p->h %p\n", p->perfect, p->h);\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (!fh) {\r\nt->tcm_handle = ~0;\r\nif (nla_put_u32(skb, TCA_TCINDEX_HASH, p->hash) ||\r\nnla_put_u16(skb, TCA_TCINDEX_MASK, p->mask) ||\r\nnla_put_u32(skb, TCA_TCINDEX_SHIFT, p->shift) ||\r\nnla_put_u32(skb, TCA_TCINDEX_FALL_THROUGH, p->fall_through))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n} else {\r\nif (p->perfect) {\r\nt->tcm_handle = r-p->perfect;\r\n} else {\r\nstruct tcindex_filter *f;\r\nint i;\r\nt->tcm_handle = 0;\r\nfor (i = 0; !t->tcm_handle && i < p->hash; i++) {\r\nfor (f = p->h[i]; !t->tcm_handle && f;\r\nf = f->next) {\r\nif (&f->result == r)\r\nt->tcm_handle = f->key;\r\n}\r\n}\r\n}\r\npr_debug("handle = %d\n", t->tcm_handle);\r\nif (r->res.class &&\r\nnla_put_u32(skb, TCA_TCINDEX_CLASSID, r->res.classid))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &r->exts, &tcindex_ext_map) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &r->exts, &tcindex_ext_map) < 0)\r\ngoto nla_put_failure;\r\n}\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init init_tcindex(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_tcindex_ops);\r\n}\r\nstatic void __exit exit_tcindex(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_tcindex_ops);\r\n}
