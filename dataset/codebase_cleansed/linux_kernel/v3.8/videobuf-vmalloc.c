static void videobuf_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct videobuf_mapping *map = vma->vm_private_data;\r\ndprintk(2, "vm_open %p [count=%u,vma=%08lx-%08lx]\n", map,\r\nmap->count, vma->vm_start, vma->vm_end);\r\nmap->count++;\r\n}\r\nstatic void videobuf_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct videobuf_mapping *map = vma->vm_private_data;\r\nstruct videobuf_queue *q = map->q;\r\nint i;\r\ndprintk(2, "vm_close %p [count=%u,vma=%08lx-%08lx]\n", map,\r\nmap->count, vma->vm_start, vma->vm_end);\r\nmap->count--;\r\nif (0 == map->count) {\r\nstruct videobuf_vmalloc_memory *mem;\r\ndprintk(1, "munmap %p q=%p\n", map, q);\r\nvideobuf_queue_lock(q);\r\nif (q->streaming)\r\nvideobuf_queue_cancel(q);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nif (q->bufs[i]->map != map)\r\ncontinue;\r\nmem = q->bufs[i]->priv;\r\nif (mem) {\r\nMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\r\ndprintk(1, "%s: buf[%d] freeing (%p)\n",\r\n__func__, i, mem->vaddr);\r\nvfree(mem->vaddr);\r\nmem->vaddr = NULL;\r\n}\r\nq->bufs[i]->map = NULL;\r\nq->bufs[i]->baddr = 0;\r\n}\r\nkfree(map);\r\nvideobuf_queue_unlock(q);\r\n}\r\nreturn;\r\n}\r\nstatic struct videobuf_buffer *__videobuf_alloc_vb(size_t size)\r\n{\r\nstruct videobuf_vmalloc_memory *mem;\r\nstruct videobuf_buffer *vb;\r\nvb = kzalloc(size + sizeof(*mem), GFP_KERNEL);\r\nif (!vb)\r\nreturn vb;\r\nmem = vb->priv = ((char *)vb) + size;\r\nmem->magic = MAGIC_VMAL_MEM;\r\ndprintk(1, "%s: allocated at %p(%ld+%ld) & %p(%ld)\n",\r\n__func__, vb, (long)sizeof(*vb), (long)size - sizeof(*vb),\r\nmem, (long)sizeof(*mem));\r\nreturn vb;\r\n}\r\nstatic int __videobuf_iolock(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nstruct v4l2_framebuffer *fbuf)\r\n{\r\nstruct videobuf_vmalloc_memory *mem = vb->priv;\r\nint pages;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\r\nswitch (vb->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\ndprintk(1, "%s memory method MMAP\n", __func__);\r\nif (!mem->vaddr) {\r\nprintk(KERN_ERR "memory is not alloced/mmapped.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\npages = PAGE_ALIGN(vb->size);\r\ndprintk(1, "%s memory method USERPTR\n", __func__);\r\nif (vb->baddr) {\r\nprintk(KERN_ERR "USERPTR is currently not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmem->vaddr = vmalloc_user(pages);\r\nif (!mem->vaddr) {\r\nprintk(KERN_ERR "vmalloc (%d pages) failed\n", pages);\r\nreturn -ENOMEM;\r\n}\r\ndprintk(1, "vmalloc is at addr %p (%d pages)\n",\r\nmem->vaddr, pages);\r\n#if 0\r\nint rc;\r\nif (!vb->baddr)\r\nreturn 0;\r\nrc = remap_vmalloc_range(mem->vma, (void *)vb->baddr, 0);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "mmap: remap failed with error %d", rc);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\ndefault:\r\ndprintk(1, "%s memory method OVERLAY/unknown\n", __func__);\r\nprintk(KERN_ERR "Memory method currently unsupported.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct videobuf_vmalloc_memory *mem;\r\nstruct videobuf_mapping *map;\r\nint retval, pages;\r\ndprintk(1, "%s\n", __func__);\r\nmap = kzalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);\r\nif (NULL == map)\r\nreturn -ENOMEM;\r\nbuf->map = map;\r\nmap->q = q;\r\nbuf->baddr = vma->vm_start;\r\nmem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\r\npages = PAGE_ALIGN(vma->vm_end - vma->vm_start);\r\nmem->vaddr = vmalloc_user(pages);\r\nif (!mem->vaddr) {\r\nprintk(KERN_ERR "vmalloc (%d pages) failed\n", pages);\r\ngoto error;\r\n}\r\ndprintk(1, "vmalloc is at addr %p (%d pages)\n", mem->vaddr, pages);\r\nretval = remap_vmalloc_range(vma, mem->vaddr, 0);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "mmap: remap failed with error %d. ", retval);\r\nvfree(mem->vaddr);\r\ngoto error;\r\n}\r\nvma->vm_ops = &videobuf_vm_ops;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_private_data = map;\r\ndprintk(1, "mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n",\r\nmap, q, vma->vm_start, vma->vm_end,\r\n(long int)buf->bsize,\r\nvma->vm_pgoff, buf->i);\r\nvideobuf_vm_open(vma);\r\nreturn 0;\r\nerror:\r\nmem = NULL;\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nvoid videobuf_queue_vmalloc_init(struct videobuf_queue *q,\r\nconst struct videobuf_queue_ops *ops,\r\nstruct device *dev,\r\nspinlock_t *irqlock,\r\nenum v4l2_buf_type type,\r\nenum v4l2_field field,\r\nunsigned int msize,\r\nvoid *priv,\r\nstruct mutex *ext_lock)\r\n{\r\nvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\r\npriv, &qops, ext_lock);\r\n}\r\nvoid *videobuf_to_vmalloc(struct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_vmalloc_memory *mem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\r\nreturn mem->vaddr;\r\n}\r\nvoid videobuf_vmalloc_free(struct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_vmalloc_memory *mem = buf->priv;\r\nif ((buf->memory != V4L2_MEMORY_USERPTR) || buf->baddr)\r\nreturn;\r\nif (!mem)\r\nreturn;\r\nMAGIC_CHECK(mem->magic, MAGIC_VMAL_MEM);\r\nvfree(mem->vaddr);\r\nmem->vaddr = NULL;\r\nreturn;\r\n}
