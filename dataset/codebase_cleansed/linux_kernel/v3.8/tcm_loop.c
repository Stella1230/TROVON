static int tcm_loop_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\r\nreturn 0;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn 1;\r\n}\r\nstatic void tcm_loop_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\r\n}\r\nstatic int tcm_loop_proc_info(struct Scsi_Host *host, char *buffer,\r\nchar **start, off_t offset,\r\nint length, int inout)\r\n{\r\nreturn sprintf(buffer, "tcm_loop_proc_info()\n");\r\n}\r\nstatic int pseudo_lld_bus_match(struct device *dev,\r\nstruct device_driver *dev_driver)\r\n{\r\nreturn 1;\r\n}\r\nstatic int tcm_loop_change_queue_depth(\r\nstruct scsi_device *sdev,\r\nint depth,\r\nint reason)\r\n{\r\nswitch (reason) {\r\ncase SCSI_QDEPTH_DEFAULT:\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ncase SCSI_QDEPTH_QFULL:\r\nscsi_track_queue_full(sdev, depth);\r\nbreak;\r\ncase SCSI_QDEPTH_RAMP_UP:\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn sdev->queue_depth;\r\n}\r\nstatic int tcm_loop_sam_attr(struct scsi_cmnd *sc)\r\n{\r\nif (sc->device->tagged_supported) {\r\nswitch (sc->tag) {\r\ncase HEAD_OF_QUEUE_TAG:\r\nreturn MSG_HEAD_TAG;\r\ncase ORDERED_QUEUE_TAG:\r\nreturn MSG_ORDERED_TAG;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn MSG_SIMPLE_TAG;\r\n}\r\nstatic void tcm_loop_submission_work(struct work_struct *work)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd =\r\ncontainer_of(work, struct tcm_loop_cmd, work);\r\nstruct se_cmd *se_cmd = &tl_cmd->tl_se_cmd;\r\nstruct scsi_cmnd *sc = tl_cmd->sc;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\nstruct scatterlist *sgl_bidi = NULL;\r\nu32 sgl_bidi_count = 0;\r\nint rc;\r\ntl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\r\ntl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\r\nif (!tl_tpg->tl_hba) {\r\nset_host_byte(sc, DID_NO_CONNECT);\r\ngoto out_done;\r\n}\r\ntl_nexus = tl_hba->tl_nexus;\r\nif (!tl_nexus) {\r\nscmd_printk(KERN_ERR, sc, "TCM_Loop I_T Nexus"\r\n" does not exist\n");\r\nset_host_byte(sc, DID_ERROR);\r\ngoto out_done;\r\n}\r\nif (scsi_bidi_cmnd(sc)) {\r\nstruct scsi_data_buffer *sdb = scsi_in(sc);\r\nsgl_bidi = sdb->table.sgl;\r\nsgl_bidi_count = sdb->table.nents;\r\nse_cmd->se_cmd_flags |= SCF_BIDI;\r\n}\r\nrc = target_submit_cmd_map_sgls(se_cmd, tl_nexus->se_sess, sc->cmnd,\r\n&tl_cmd->tl_sense_buf[0], tl_cmd->sc->device->lun,\r\nscsi_bufflen(sc), tcm_loop_sam_attr(sc),\r\nsc->sc_data_direction, 0,\r\nscsi_sglist(sc), scsi_sg_count(sc),\r\nsgl_bidi, sgl_bidi_count);\r\nif (rc < 0) {\r\nset_host_byte(sc, DID_NO_CONNECT);\r\ngoto out_done;\r\n}\r\nreturn;\r\nout_done:\r\nsc->scsi_done(sc);\r\nreturn;\r\n}\r\nstatic int tcm_loop_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd;\r\npr_debug("tcm_loop_queuecommand() %d:%d:%d:%d got CDB: 0x%02x"\r\n" scsi_buf_len: %u\n", sc->device->host->host_no,\r\nsc->device->id, sc->device->channel, sc->device->lun,\r\nsc->cmnd[0], scsi_bufflen(sc));\r\ntl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_ATOMIC);\r\nif (!tl_cmd) {\r\npr_err("Unable to allocate struct tcm_loop_cmd\n");\r\nset_host_byte(sc, DID_ERROR);\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\ntl_cmd->sc = sc;\r\nINIT_WORK(&tl_cmd->work, tcm_loop_submission_work);\r\nqueue_work(tcm_loop_workqueue, &tl_cmd->work);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_device_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct se_cmd *se_cmd = NULL;\r\nstruct se_portal_group *se_tpg;\r\nstruct se_session *se_sess;\r\nstruct tcm_loop_cmd *tl_cmd = NULL;\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nstruct tcm_loop_tmr *tl_tmr = NULL;\r\nstruct tcm_loop_tpg *tl_tpg;\r\nint ret = FAILED, rc;\r\ntl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\r\ntl_nexus = tl_hba->tl_nexus;\r\nif (!tl_nexus) {\r\npr_err("Unable to perform device reset without"\r\n" active I_T Nexus\n");\r\nreturn FAILED;\r\n}\r\nse_sess = tl_nexus->se_sess;\r\ntl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\r\nse_tpg = &tl_tpg->tl_se_tpg;\r\ntl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);\r\nif (!tl_cmd) {\r\npr_err("Unable to allocate memory for tl_cmd\n");\r\nreturn FAILED;\r\n}\r\ntl_tmr = kzalloc(sizeof(struct tcm_loop_tmr), GFP_KERNEL);\r\nif (!tl_tmr) {\r\npr_err("Unable to allocate memory for tl_tmr\n");\r\ngoto release;\r\n}\r\ninit_waitqueue_head(&tl_tmr->tl_tmr_wait);\r\nse_cmd = &tl_cmd->tl_se_cmd;\r\ntransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess, 0,\r\nDMA_NONE, MSG_SIMPLE_TAG,\r\n&tl_cmd->tl_sense_buf[0]);\r\nrc = core_tmr_alloc_req(se_cmd, tl_tmr, TMR_LUN_RESET, GFP_KERNEL);\r\nif (rc < 0)\r\ngoto release;\r\nif (transport_lookup_tmr_lun(se_cmd, sc->device->lun) < 0)\r\ngoto release;\r\ntransport_generic_handle_tmr(se_cmd);\r\nwait_event(tl_tmr->tl_tmr_wait, atomic_read(&tl_tmr->tmr_complete));\r\nret = (se_cmd->se_tmr_req->response == TMR_FUNCTION_COMPLETE) ?\r\nSUCCESS : FAILED;\r\nrelease:\r\nif (se_cmd)\r\ntransport_generic_free_cmd(se_cmd, 1);\r\nelse\r\nkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\r\nkfree(tl_tmr);\r\nreturn ret;\r\n}\r\nstatic int tcm_loop_slave_alloc(struct scsi_device *sd)\r\n{\r\nset_bit(QUEUE_FLAG_BIDI, &sd->request_queue->queue_flags);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_slave_configure(struct scsi_device *sd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_driver_probe(struct device *dev)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct Scsi_Host *sh;\r\nint error;\r\ntl_hba = to_tcm_loop_hba(dev);\r\nsh = scsi_host_alloc(&tcm_loop_driver_template,\r\nsizeof(struct tcm_loop_hba));\r\nif (!sh) {\r\npr_err("Unable to allocate struct scsi_host\n");\r\nreturn -ENODEV;\r\n}\r\ntl_hba->sh = sh;\r\n*((struct tcm_loop_hba **)sh->hostdata) = tl_hba;\r\nsh->max_id = 2;\r\nsh->max_lun = 0;\r\nsh->max_channel = 0;\r\nsh->max_cmd_len = TL_SCSI_MAX_CMD_LEN;\r\nerror = scsi_add_host(sh, &tl_hba->dev);\r\nif (error) {\r\npr_err("%s: scsi_add_host failed\n", __func__);\r\nscsi_host_put(sh);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_driver_remove(struct device *dev)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct Scsi_Host *sh;\r\ntl_hba = to_tcm_loop_hba(dev);\r\nsh = tl_hba->sh;\r\nscsi_remove_host(sh);\r\nscsi_host_put(sh);\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_release_adapter(struct device *dev)\r\n{\r\nstruct tcm_loop_hba *tl_hba = to_tcm_loop_hba(dev);\r\nkfree(tl_hba);\r\n}\r\nstatic int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\r\n{\r\nint ret;\r\ntl_hba->dev.bus = &tcm_loop_lld_bus;\r\ntl_hba->dev.parent = tcm_loop_primary;\r\ntl_hba->dev.release = &tcm_loop_release_adapter;\r\ndev_set_name(&tl_hba->dev, "tcm_loop_adapter_%d", tcm_loop_host_id);\r\nret = device_register(&tl_hba->dev);\r\nif (ret) {\r\npr_err("device_register() failed for"\r\n" tl_hba->dev: %d\n", ret);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_alloc_core_bus(void)\r\n{\r\nint ret;\r\ntcm_loop_primary = root_device_register("tcm_loop_0");\r\nif (IS_ERR(tcm_loop_primary)) {\r\npr_err("Unable to allocate tcm_loop_primary\n");\r\nreturn PTR_ERR(tcm_loop_primary);\r\n}\r\nret = bus_register(&tcm_loop_lld_bus);\r\nif (ret) {\r\npr_err("bus_register() failed for tcm_loop_lld_bus\n");\r\ngoto dev_unreg;\r\n}\r\nret = driver_register(&tcm_loop_driverfs);\r\nif (ret) {\r\npr_err("driver_register() failed for"\r\n"tcm_loop_driverfs\n");\r\ngoto bus_unreg;\r\n}\r\npr_debug("Initialized TCM Loop Core Bus\n");\r\nreturn ret;\r\nbus_unreg:\r\nbus_unregister(&tcm_loop_lld_bus);\r\ndev_unreg:\r\nroot_device_unregister(tcm_loop_primary);\r\nreturn ret;\r\n}\r\nstatic void tcm_loop_release_core_bus(void)\r\n{\r\ndriver_unregister(&tcm_loop_driverfs);\r\nbus_unregister(&tcm_loop_lld_bus);\r\nroot_device_unregister(tcm_loop_primary);\r\npr_debug("Releasing TCM Loop Core BUS\n");\r\n}\r\nstatic char *tcm_loop_get_fabric_name(void)\r\n{\r\nreturn "loopback";\r\n}\r\nstatic u8 tcm_loop_get_fabric_proto_ident(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = se_tpg->se_tpg_fabric_ptr;\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nswitch (tl_hba->tl_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\nreturn sas_get_fabric_proto_ident(se_tpg);\r\ncase SCSI_PROTOCOL_FCP:\r\nreturn fc_get_fabric_proto_ident(se_tpg);\r\ncase SCSI_PROTOCOL_ISCSI:\r\nreturn iscsi_get_fabric_proto_ident(se_tpg);\r\ndefault:\r\npr_err("Unknown tl_proto_id: 0x%02x, using"\r\n" SAS emulation\n", tl_hba->tl_proto_id);\r\nbreak;\r\n}\r\nreturn sas_get_fabric_proto_ident(se_tpg);\r\n}\r\nstatic char *tcm_loop_get_endpoint_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = se_tpg->se_tpg_fabric_ptr;\r\nreturn &tl_tpg->tl_hba->tl_wwn_address[0];\r\n}\r\nstatic u16 tcm_loop_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = se_tpg->se_tpg_fabric_ptr;\r\nreturn tl_tpg->tl_tpgt;\r\n}\r\nstatic u32 tcm_loop_get_default_depth(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic u32 tcm_loop_get_pr_transport_id(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nint *format_code,\r\nunsigned char *buf)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = se_tpg->se_tpg_fabric_ptr;\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nswitch (tl_hba->tl_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\nreturn sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\r\nformat_code, buf);\r\ncase SCSI_PROTOCOL_FCP:\r\nreturn fc_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\r\nformat_code, buf);\r\ncase SCSI_PROTOCOL_ISCSI:\r\nreturn iscsi_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\r\nformat_code, buf);\r\ndefault:\r\npr_err("Unknown tl_proto_id: 0x%02x, using"\r\n" SAS emulation\n", tl_hba->tl_proto_id);\r\nbreak;\r\n}\r\nreturn sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\r\nformat_code, buf);\r\n}\r\nstatic u32 tcm_loop_get_pr_transport_id_len(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nint *format_code)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = se_tpg->se_tpg_fabric_ptr;\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nswitch (tl_hba->tl_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\nreturn sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\r\nformat_code);\r\ncase SCSI_PROTOCOL_FCP:\r\nreturn fc_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\r\nformat_code);\r\ncase SCSI_PROTOCOL_ISCSI:\r\nreturn iscsi_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\r\nformat_code);\r\ndefault:\r\npr_err("Unknown tl_proto_id: 0x%02x, using"\r\n" SAS emulation\n", tl_hba->tl_proto_id);\r\nbreak;\r\n}\r\nreturn sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\r\nformat_code);\r\n}\r\nstatic char *tcm_loop_parse_pr_out_transport_id(\r\nstruct se_portal_group *se_tpg,\r\nconst char *buf,\r\nu32 *out_tid_len,\r\nchar **port_nexus_ptr)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = se_tpg->se_tpg_fabric_ptr;\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nswitch (tl_hba->tl_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\nreturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\r\nport_nexus_ptr);\r\ncase SCSI_PROTOCOL_FCP:\r\nreturn fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\r\nport_nexus_ptr);\r\ncase SCSI_PROTOCOL_ISCSI:\r\nreturn iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\r\nport_nexus_ptr);\r\ndefault:\r\npr_err("Unknown tl_proto_id: 0x%02x, using"\r\n" SAS emulation\n", tl_hba->tl_proto_id);\r\nbreak;\r\n}\r\nreturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\r\nport_nexus_ptr);\r\n}\r\nstatic int tcm_loop_check_demo_mode(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int tcm_loop_check_demo_mode_cache(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_check_demo_mode_write_protect(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_check_prod_mode_write_protect(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct se_node_acl *tcm_loop_tpg_alloc_fabric_acl(\r\nstruct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_loop_nacl *tl_nacl;\r\ntl_nacl = kzalloc(sizeof(struct tcm_loop_nacl), GFP_KERNEL);\r\nif (!tl_nacl) {\r\npr_err("Unable to allocate struct tcm_loop_nacl\n");\r\nreturn NULL;\r\n}\r\nreturn &tl_nacl->se_node_acl;\r\n}\r\nstatic void tcm_loop_tpg_release_fabric_acl(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl)\r\n{\r\nstruct tcm_loop_nacl *tl_nacl = container_of(se_nacl,\r\nstruct tcm_loop_nacl, se_node_acl);\r\nkfree(tl_nacl);\r\n}\r\nstatic u32 tcm_loop_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic u32 tcm_loop_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 1;\r\n}\r\nstatic void tcm_loop_set_default_node_attributes(struct se_node_acl *se_acl)\r\n{\r\nreturn;\r\n}\r\nstatic u32 tcm_loop_get_task_tag(struct se_cmd *se_cmd)\r\n{\r\nreturn 1;\r\n}\r\nstatic int tcm_loop_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nreturn tl_cmd->sc_cmd_state;\r\n}\r\nstatic int tcm_loop_shutdown_session(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_close_session(struct se_session *se_sess)\r\n{\r\nreturn;\r\n}\r\nstatic int tcm_loop_write_pending(struct se_cmd *se_cmd)\r\n{\r\ntarget_execute_cmd(se_cmd);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nstruct scsi_cmnd *sc = tl_cmd->sc;\r\npr_debug("tcm_loop_queue_data_in() called for scsi_cmnd: %p"\r\n" cdb: 0x%02x\n", sc, sc->cmnd[0]);\r\nsc->result = SAM_STAT_GOOD;\r\nset_host_byte(sc, DID_OK);\r\nif ((se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) ||\r\n(se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT))\r\nscsi_set_resid(sc, se_cmd->residual_count);\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nstruct scsi_cmnd *sc = tl_cmd->sc;\r\npr_debug("tcm_loop_queue_status() called for scsi_cmnd: %p"\r\n" cdb: 0x%02x\n", sc, sc->cmnd[0]);\r\nif (se_cmd->sense_buffer &&\r\n((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\r\n(se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\r\nmemcpy(sc->sense_buffer, se_cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE);\r\nsc->result = SAM_STAT_CHECK_CONDITION;\r\nset_driver_byte(sc, DRIVER_SENSE);\r\n} else\r\nsc->result = se_cmd->scsi_status;\r\nset_host_byte(sc, DID_OK);\r\nif ((se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) ||\r\n(se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT))\r\nscsi_set_resid(sc, se_cmd->residual_count);\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\nstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\r\nstruct tcm_loop_tmr *tl_tmr = se_tmr->fabric_tmr_ptr;\r\natomic_set(&tl_tmr->tmr_complete, 1);\r\nwake_up(&tl_tmr->tl_tmr_wait);\r\nreturn 0;\r\n}\r\nstatic char *tcm_loop_dump_proto_id(struct tcm_loop_hba *tl_hba)\r\n{\r\nswitch (tl_hba->tl_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\nreturn "SAS";\r\ncase SCSI_PROTOCOL_FCP:\r\nreturn "FCP";\r\ncase SCSI_PROTOCOL_ISCSI:\r\nreturn "iSCSI";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "Unknown";\r\n}\r\nstatic int tcm_loop_port_link(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_lun *lun)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\natomic_inc(&tl_tpg->tl_tpg_port_count);\r\nsmp_mb__after_atomic_inc();\r\nscsi_add_device(tl_hba->sh, 0, tl_tpg->tl_tpgt, lun->unpacked_lun);\r\npr_debug("TCM_Loop_ConfigFS: Port Link Successful\n");\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_port_unlink(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_lun *se_lun)\r\n{\r\nstruct scsi_device *sd;\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\ntl_tpg = container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\r\ntl_hba = tl_tpg->tl_hba;\r\nsd = scsi_device_lookup(tl_hba->sh, 0, tl_tpg->tl_tpgt,\r\nse_lun->unpacked_lun);\r\nif (!sd) {\r\npr_err("Unable to locate struct scsi_device for %d:%d:"\r\n"%d\n", 0, tl_tpg->tl_tpgt, se_lun->unpacked_lun);\r\nreturn;\r\n}\r\nscsi_remove_device(sd);\r\nscsi_device_put(sd);\r\natomic_dec(&tl_tpg->tl_tpg_port_count);\r\nsmp_mb__after_atomic_dec();\r\npr_debug("TCM_Loop_ConfigFS: Port Unlink Successful\n");\r\n}\r\nstatic int tcm_loop_make_nexus(\r\nstruct tcm_loop_tpg *tl_tpg,\r\nconst char *name)\r\n{\r\nstruct se_portal_group *se_tpg;\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nint ret = -ENOMEM;\r\nif (tl_tpg->tl_hba->tl_nexus) {\r\npr_debug("tl_tpg->tl_hba->tl_nexus already exists\n");\r\nreturn -EEXIST;\r\n}\r\nse_tpg = &tl_tpg->tl_se_tpg;\r\ntl_nexus = kzalloc(sizeof(struct tcm_loop_nexus), GFP_KERNEL);\r\nif (!tl_nexus) {\r\npr_err("Unable to allocate struct tcm_loop_nexus\n");\r\nreturn -ENOMEM;\r\n}\r\ntl_nexus->se_sess = transport_init_session();\r\nif (IS_ERR(tl_nexus->se_sess)) {\r\nret = PTR_ERR(tl_nexus->se_sess);\r\ngoto out;\r\n}\r\ntl_nexus->se_sess->se_node_acl = core_tpg_check_initiator_node_acl(\r\nse_tpg, (unsigned char *)name);\r\nif (!tl_nexus->se_sess->se_node_acl) {\r\ntransport_free_session(tl_nexus->se_sess);\r\ngoto out;\r\n}\r\n__transport_register_session(se_tpg, tl_nexus->se_sess->se_node_acl,\r\ntl_nexus->se_sess, tl_nexus);\r\ntl_tpg->tl_hba->tl_nexus = tl_nexus;\r\npr_debug("TCM_Loop_ConfigFS: Established I_T Nexus to emulated"\r\n" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tl_hba),\r\nname);\r\nreturn 0;\r\nout:\r\nkfree(tl_nexus);\r\nreturn ret;\r\n}\r\nstatic int tcm_loop_drop_nexus(\r\nstruct tcm_loop_tpg *tpg)\r\n{\r\nstruct se_session *se_sess;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nstruct tcm_loop_hba *tl_hba = tpg->tl_hba;\r\ntl_nexus = tpg->tl_hba->tl_nexus;\r\nif (!tl_nexus)\r\nreturn -ENODEV;\r\nse_sess = tl_nexus->se_sess;\r\nif (!se_sess)\r\nreturn -ENODEV;\r\nif (atomic_read(&tpg->tl_tpg_port_count)) {\r\npr_err("Unable to remove TCM_Loop I_T Nexus with"\r\n" active TPG port count: %d\n",\r\natomic_read(&tpg->tl_tpg_port_count));\r\nreturn -EPERM;\r\n}\r\npr_debug("TCM_Loop_ConfigFS: Removing I_T Nexus to emulated"\r\n" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tl_hba),\r\ntl_nexus->se_sess->se_node_acl->initiatorname);\r\ntransport_deregister_session(tl_nexus->se_sess);\r\ntpg->tl_hba->tl_nexus = NULL;\r\nkfree(tl_nexus);\r\nreturn 0;\r\n}\r\nstatic ssize_t tcm_loop_tpg_show_nexus(\r\nstruct se_portal_group *se_tpg,\r\nchar *page)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_nexus *tl_nexus;\r\nssize_t ret;\r\ntl_nexus = tl_tpg->tl_hba->tl_nexus;\r\nif (!tl_nexus)\r\nreturn -ENODEV;\r\nret = snprintf(page, PAGE_SIZE, "%s\n",\r\ntl_nexus->se_sess->se_node_acl->initiatorname);\r\nreturn ret;\r\n}\r\nstatic ssize_t tcm_loop_tpg_store_nexus(\r\nstruct se_portal_group *se_tpg,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nunsigned char i_port[TL_WWN_ADDR_LEN], *ptr, *port_ptr;\r\nint ret;\r\nif (!strncmp(page, "NULL", 4)) {\r\nret = tcm_loop_drop_nexus(tl_tpg);\r\nreturn (!ret) ? count : ret;\r\n}\r\nif (strlen(page) >= TL_WWN_ADDR_LEN) {\r\npr_err("Emulated NAA Sas Address: %s, exceeds"\r\n" max: %d\n", page, TL_WWN_ADDR_LEN);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(&i_port[0], TL_WWN_ADDR_LEN, "%s", page);\r\nptr = strstr(i_port, "naa.");\r\nif (ptr) {\r\nif (tl_hba->tl_proto_id != SCSI_PROTOCOL_SAS) {\r\npr_err("Passed SAS Initiator Port %s does not"\r\n" match target port protoid: %s\n", i_port,\r\ntcm_loop_dump_proto_id(tl_hba));\r\nreturn -EINVAL;\r\n}\r\nport_ptr = &i_port[0];\r\ngoto check_newline;\r\n}\r\nptr = strstr(i_port, "fc.");\r\nif (ptr) {\r\nif (tl_hba->tl_proto_id != SCSI_PROTOCOL_FCP) {\r\npr_err("Passed FCP Initiator Port %s does not"\r\n" match target port protoid: %s\n", i_port,\r\ntcm_loop_dump_proto_id(tl_hba));\r\nreturn -EINVAL;\r\n}\r\nport_ptr = &i_port[3];\r\ngoto check_newline;\r\n}\r\nptr = strstr(i_port, "iqn.");\r\nif (ptr) {\r\nif (tl_hba->tl_proto_id != SCSI_PROTOCOL_ISCSI) {\r\npr_err("Passed iSCSI Initiator Port %s does not"\r\n" match target port protoid: %s\n", i_port,\r\ntcm_loop_dump_proto_id(tl_hba));\r\nreturn -EINVAL;\r\n}\r\nport_ptr = &i_port[0];\r\ngoto check_newline;\r\n}\r\npr_err("Unable to locate prefix for emulated Initiator Port:"\r\n" %s\n", i_port);\r\nreturn -EINVAL;\r\ncheck_newline:\r\nif (i_port[strlen(i_port)-1] == '\n')\r\ni_port[strlen(i_port)-1] = '\0';\r\nret = tcm_loop_make_nexus(tl_tpg, port_ptr);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstruct se_portal_group *tcm_loop_make_naa_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_loop_hba *tl_hba = container_of(wwn,\r\nstruct tcm_loop_hba, tl_hba_wwn);\r\nstruct tcm_loop_tpg *tl_tpg;\r\nchar *tpgt_str, *end_ptr;\r\nint ret;\r\nunsigned short int tpgt;\r\ntpgt_str = strstr(name, "tpgt_");\r\nif (!tpgt_str) {\r\npr_err("Unable to locate \"tpgt_#\" directory"\r\n" group\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntpgt_str += 5;\r\ntpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\r\nif (tpgt >= TL_TPGS_PER_HBA) {\r\npr_err("Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:"\r\n" %u\n", tpgt, TL_TPGS_PER_HBA);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\r\ntl_tpg->tl_hba = tl_hba;\r\ntl_tpg->tl_tpgt = tpgt;\r\nret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\r\nwwn, &tl_tpg->tl_se_tpg, tl_tpg,\r\nTRANSPORT_TPG_TYPE_NORMAL);\r\nif (ret < 0)\r\nreturn ERR_PTR(-ENOMEM);\r\npr_debug("TCM_Loop_ConfigFS: Allocated Emulated %s"\r\n" Target Port %s,t,0x%04x\n", tcm_loop_dump_proto_id(tl_hba),\r\nconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\r\nreturn &tl_tpg->tl_se_tpg;\r\n}\r\nvoid tcm_loop_drop_naa_tpg(\r\nstruct se_portal_group *se_tpg)\r\n{\r\nstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba;\r\nunsigned short tpgt;\r\ntl_hba = tl_tpg->tl_hba;\r\ntpgt = tl_tpg->tl_tpgt;\r\ntcm_loop_drop_nexus(tl_tpg);\r\ncore_tpg_deregister(se_tpg);\r\ntl_tpg->tl_hba = NULL;\r\ntl_tpg->tl_tpgt = 0;\r\npr_debug("TCM_Loop_ConfigFS: Deallocated Emulated %s"\r\n" Target Port %s,t,0x%04x\n", tcm_loop_dump_proto_id(tl_hba),\r\nconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\r\n}\r\nstruct se_wwn *tcm_loop_make_scsi_hba(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct Scsi_Host *sh;\r\nchar *ptr;\r\nint ret, off = 0;\r\ntl_hba = kzalloc(sizeof(struct tcm_loop_hba), GFP_KERNEL);\r\nif (!tl_hba) {\r\npr_err("Unable to allocate struct tcm_loop_hba\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nptr = strstr(name, "naa.");\r\nif (ptr) {\r\ntl_hba->tl_proto_id = SCSI_PROTOCOL_SAS;\r\ngoto check_len;\r\n}\r\nptr = strstr(name, "fc.");\r\nif (ptr) {\r\ntl_hba->tl_proto_id = SCSI_PROTOCOL_FCP;\r\noff = 3;\r\ngoto check_len;\r\n}\r\nptr = strstr(name, "iqn.");\r\nif (!ptr) {\r\npr_err("Unable to locate prefix for emulated Target "\r\n"Port: %s\n", name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntl_hba->tl_proto_id = SCSI_PROTOCOL_ISCSI;\r\ncheck_len:\r\nif (strlen(name) >= TL_WWN_ADDR_LEN) {\r\npr_err("Emulated NAA %s Address: %s, exceeds"\r\n" max: %d\n", name, tcm_loop_dump_proto_id(tl_hba),\r\nTL_WWN_ADDR_LEN);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsnprintf(&tl_hba->tl_wwn_address[0], TL_WWN_ADDR_LEN, "%s", &name[off]);\r\nret = tcm_loop_setup_hba_bus(tl_hba, tcm_loop_hba_no_cnt);\r\nif (ret)\r\ngoto out;\r\nsh = tl_hba->sh;\r\ntcm_loop_hba_no_cnt++;\r\npr_debug("TCM_Loop_ConfigFS: Allocated emulated Target"\r\n" %s Address: %s at Linux/SCSI Host ID: %d\n",\r\ntcm_loop_dump_proto_id(tl_hba), name, sh->host_no);\r\nreturn &tl_hba->tl_hba_wwn;\r\nout:\r\nkfree(tl_hba);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid tcm_loop_drop_scsi_hba(\r\nstruct se_wwn *wwn)\r\n{\r\nstruct tcm_loop_hba *tl_hba = container_of(wwn,\r\nstruct tcm_loop_hba, tl_hba_wwn);\r\npr_debug("TCM_Loop_ConfigFS: Deallocating emulated Target"\r\n" SAS Address: %s at Linux/SCSI Host ID: %d\n",\r\ntl_hba->tl_wwn_address, tl_hba->sh->host_no);\r\ndevice_unregister(&tl_hba->dev);\r\n}\r\nstatic ssize_t tcm_loop_wwn_show_attr_version(\r\nstruct target_fabric_configfs *tf,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "TCM Loopback Fabric module %s\n", TCM_LOOP_VERSION);\r\n}\r\nstatic int tcm_loop_register_configfs(void)\r\n{\r\nstruct target_fabric_configfs *fabric;\r\nint ret;\r\ntcm_loop_hba_no_cnt = 0;\r\nfabric = target_fabric_configfs_init(THIS_MODULE, "loopback");\r\nif (IS_ERR(fabric)) {\r\npr_err("tcm_loop_register_configfs() failed!\n");\r\nreturn PTR_ERR(fabric);\r\n}\r\nfabric->tf_ops.get_fabric_name = &tcm_loop_get_fabric_name;\r\nfabric->tf_ops.get_fabric_proto_ident = &tcm_loop_get_fabric_proto_ident;\r\nfabric->tf_ops.tpg_get_wwn = &tcm_loop_get_endpoint_wwn;\r\nfabric->tf_ops.tpg_get_tag = &tcm_loop_get_tag;\r\nfabric->tf_ops.tpg_get_default_depth = &tcm_loop_get_default_depth;\r\nfabric->tf_ops.tpg_get_pr_transport_id = &tcm_loop_get_pr_transport_id;\r\nfabric->tf_ops.tpg_get_pr_transport_id_len =\r\n&tcm_loop_get_pr_transport_id_len;\r\nfabric->tf_ops.tpg_parse_pr_out_transport_id =\r\n&tcm_loop_parse_pr_out_transport_id;\r\nfabric->tf_ops.tpg_check_demo_mode = &tcm_loop_check_demo_mode;\r\nfabric->tf_ops.tpg_check_demo_mode_cache =\r\n&tcm_loop_check_demo_mode_cache;\r\nfabric->tf_ops.tpg_check_demo_mode_write_protect =\r\n&tcm_loop_check_demo_mode_write_protect;\r\nfabric->tf_ops.tpg_check_prod_mode_write_protect =\r\n&tcm_loop_check_prod_mode_write_protect;\r\nfabric->tf_ops.tpg_alloc_fabric_acl = &tcm_loop_tpg_alloc_fabric_acl;\r\nfabric->tf_ops.tpg_release_fabric_acl =\r\n&tcm_loop_tpg_release_fabric_acl;\r\nfabric->tf_ops.tpg_get_inst_index = &tcm_loop_get_inst_index;\r\nfabric->tf_ops.check_stop_free = &tcm_loop_check_stop_free;\r\nfabric->tf_ops.release_cmd = &tcm_loop_release_cmd;\r\nfabric->tf_ops.shutdown_session = &tcm_loop_shutdown_session;\r\nfabric->tf_ops.close_session = &tcm_loop_close_session;\r\nfabric->tf_ops.sess_get_index = &tcm_loop_sess_get_index;\r\nfabric->tf_ops.sess_get_initiator_sid = NULL;\r\nfabric->tf_ops.write_pending = &tcm_loop_write_pending;\r\nfabric->tf_ops.write_pending_status = &tcm_loop_write_pending_status;\r\nfabric->tf_ops.set_default_node_attributes =\r\n&tcm_loop_set_default_node_attributes;\r\nfabric->tf_ops.get_task_tag = &tcm_loop_get_task_tag;\r\nfabric->tf_ops.get_cmd_state = &tcm_loop_get_cmd_state;\r\nfabric->tf_ops.queue_data_in = &tcm_loop_queue_data_in;\r\nfabric->tf_ops.queue_status = &tcm_loop_queue_status;\r\nfabric->tf_ops.queue_tm_rsp = &tcm_loop_queue_tm_rsp;\r\nfabric->tf_ops.fabric_make_wwn = &tcm_loop_make_scsi_hba;\r\nfabric->tf_ops.fabric_drop_wwn = &tcm_loop_drop_scsi_hba;\r\nfabric->tf_ops.fabric_make_tpg = &tcm_loop_make_naa_tpg;\r\nfabric->tf_ops.fabric_drop_tpg = &tcm_loop_drop_naa_tpg;\r\nfabric->tf_ops.fabric_post_link = &tcm_loop_port_link;\r\nfabric->tf_ops.fabric_pre_unlink = &tcm_loop_port_unlink;\r\nfabric->tf_ops.fabric_make_np = NULL;\r\nfabric->tf_ops.fabric_drop_np = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;\r\nret = target_fabric_configfs_register(fabric);\r\nif (ret < 0) {\r\npr_err("target_fabric_configfs_register() for"\r\n" TCM_Loop failed!\n");\r\ntarget_fabric_configfs_free(fabric);\r\nreturn -1;\r\n}\r\ntcm_loop_fabric_configfs = fabric;\r\npr_debug("TCM_LOOP[0] - Set fabric ->"\r\n" tcm_loop_fabric_configfs\n");\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_deregister_configfs(void)\r\n{\r\nif (!tcm_loop_fabric_configfs)\r\nreturn;\r\ntarget_fabric_configfs_deregister(tcm_loop_fabric_configfs);\r\ntcm_loop_fabric_configfs = NULL;\r\npr_debug("TCM_LOOP[0] - Cleared"\r\n" tcm_loop_fabric_configfs\n");\r\n}\r\nstatic int __init tcm_loop_fabric_init(void)\r\n{\r\nint ret = -ENOMEM;\r\ntcm_loop_workqueue = alloc_workqueue("tcm_loop", 0, 0);\r\nif (!tcm_loop_workqueue)\r\ngoto out;\r\ntcm_loop_cmd_cache = kmem_cache_create("tcm_loop_cmd_cache",\r\nsizeof(struct tcm_loop_cmd),\r\n__alignof__(struct tcm_loop_cmd),\r\n0, NULL);\r\nif (!tcm_loop_cmd_cache) {\r\npr_debug("kmem_cache_create() for"\r\n" tcm_loop_cmd_cache failed\n");\r\ngoto out_destroy_workqueue;\r\n}\r\nret = tcm_loop_alloc_core_bus();\r\nif (ret)\r\ngoto out_destroy_cache;\r\nret = tcm_loop_register_configfs();\r\nif (ret)\r\ngoto out_release_core_bus;\r\nreturn 0;\r\nout_release_core_bus:\r\ntcm_loop_release_core_bus();\r\nout_destroy_cache:\r\nkmem_cache_destroy(tcm_loop_cmd_cache);\r\nout_destroy_workqueue:\r\ndestroy_workqueue(tcm_loop_workqueue);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit tcm_loop_fabric_exit(void)\r\n{\r\ntcm_loop_deregister_configfs();\r\ntcm_loop_release_core_bus();\r\nkmem_cache_destroy(tcm_loop_cmd_cache);\r\ndestroy_workqueue(tcm_loop_workqueue);\r\n}
