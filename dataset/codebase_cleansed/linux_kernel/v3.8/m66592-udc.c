static inline u16 get_usb_speed(struct m66592 *m66592)\r\n{\r\nreturn (m66592_read(m66592, M66592_DVSTCTR) & M66592_RHST);\r\n}\r\nstatic void enable_pipe_irq(struct m66592 *m66592, u16 pipenum,\r\nunsigned long reg)\r\n{\r\nu16 tmp;\r\ntmp = m66592_read(m66592, M66592_INTENB0);\r\nm66592_bclr(m66592, M66592_BEMPE | M66592_NRDYE | M66592_BRDYE,\r\nM66592_INTENB0);\r\nm66592_bset(m66592, (1 << pipenum), reg);\r\nm66592_write(m66592, tmp, M66592_INTENB0);\r\n}\r\nstatic void disable_pipe_irq(struct m66592 *m66592, u16 pipenum,\r\nunsigned long reg)\r\n{\r\nu16 tmp;\r\ntmp = m66592_read(m66592, M66592_INTENB0);\r\nm66592_bclr(m66592, M66592_BEMPE | M66592_NRDYE | M66592_BRDYE,\r\nM66592_INTENB0);\r\nm66592_bclr(m66592, (1 << pipenum), reg);\r\nm66592_write(m66592, tmp, M66592_INTENB0);\r\n}\r\nstatic void m66592_usb_connect(struct m66592 *m66592)\r\n{\r\nm66592_bset(m66592, M66592_CTRE, M66592_INTENB0);\r\nm66592_bset(m66592, M66592_WDST | M66592_RDST | M66592_CMPL,\r\nM66592_INTENB0);\r\nm66592_bset(m66592, M66592_BEMPE | M66592_BRDYE, M66592_INTENB0);\r\nm66592_bset(m66592, M66592_DPRPU, M66592_SYSCFG);\r\n}\r\nstatic void m66592_usb_disconnect(struct m66592 *m66592)\r\n__releases(m66592->lock)\r\n__acquires(m66592->lock)\r\n{\r\nm66592_bclr(m66592, M66592_CTRE, M66592_INTENB0);\r\nm66592_bclr(m66592, M66592_WDST | M66592_RDST | M66592_CMPL,\r\nM66592_INTENB0);\r\nm66592_bclr(m66592, M66592_BEMPE | M66592_BRDYE, M66592_INTENB0);\r\nm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\r\nm66592->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock(&m66592->lock);\r\nm66592->driver->disconnect(&m66592->gadget);\r\nspin_lock(&m66592->lock);\r\ndisable_controller(m66592);\r\nINIT_LIST_HEAD(&m66592->ep[0].queue);\r\n}\r\nstatic inline u16 control_reg_get_pid(struct m66592 *m66592, u16 pipenum)\r\n{\r\nu16 pid = 0;\r\nunsigned long offset;\r\nif (pipenum == 0)\r\npid = m66592_read(m66592, M66592_DCPCTR) & M66592_PID;\r\nelse if (pipenum < M66592_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\npid = m66592_read(m66592, offset) & M66592_PID;\r\n} else\r\npr_err("unexpect pipe num (%d)\n", pipenum);\r\nreturn pid;\r\n}\r\nstatic inline void control_reg_set_pid(struct m66592 *m66592, u16 pipenum,\r\nu16 pid)\r\n{\r\nunsigned long offset;\r\nif (pipenum == 0)\r\nm66592_mdfy(m66592, pid, M66592_PID, M66592_DCPCTR);\r\nelse if (pipenum < M66592_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nm66592_mdfy(m66592, pid, M66592_PID, offset);\r\n} else\r\npr_err("unexpect pipe num (%d)\n", pipenum);\r\n}\r\nstatic inline void pipe_start(struct m66592 *m66592, u16 pipenum)\r\n{\r\ncontrol_reg_set_pid(m66592, pipenum, M66592_PID_BUF);\r\n}\r\nstatic inline void pipe_stop(struct m66592 *m66592, u16 pipenum)\r\n{\r\ncontrol_reg_set_pid(m66592, pipenum, M66592_PID_NAK);\r\n}\r\nstatic inline void pipe_stall(struct m66592 *m66592, u16 pipenum)\r\n{\r\ncontrol_reg_set_pid(m66592, pipenum, M66592_PID_STALL);\r\n}\r\nstatic inline u16 control_reg_get(struct m66592 *m66592, u16 pipenum)\r\n{\r\nu16 ret = 0;\r\nunsigned long offset;\r\nif (pipenum == 0)\r\nret = m66592_read(m66592, M66592_DCPCTR);\r\nelse if (pipenum < M66592_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nret = m66592_read(m66592, offset);\r\n} else\r\npr_err("unexpect pipe num (%d)\n", pipenum);\r\nreturn ret;\r\n}\r\nstatic inline void control_reg_sqclr(struct m66592 *m66592, u16 pipenum)\r\n{\r\nunsigned long offset;\r\npipe_stop(m66592, pipenum);\r\nif (pipenum == 0)\r\nm66592_bset(m66592, M66592_SQCLR, M66592_DCPCTR);\r\nelse if (pipenum < M66592_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nm66592_bset(m66592, M66592_SQCLR, offset);\r\n} else\r\npr_err("unexpect pipe num(%d)\n", pipenum);\r\n}\r\nstatic inline int get_buffer_size(struct m66592 *m66592, u16 pipenum)\r\n{\r\nu16 tmp;\r\nint size;\r\nif (pipenum == 0) {\r\ntmp = m66592_read(m66592, M66592_DCPCFG);\r\nif ((tmp & M66592_CNTMD) != 0)\r\nsize = 256;\r\nelse {\r\ntmp = m66592_read(m66592, M66592_DCPMAXP);\r\nsize = tmp & M66592_MAXP;\r\n}\r\n} else {\r\nm66592_write(m66592, pipenum, M66592_PIPESEL);\r\ntmp = m66592_read(m66592, M66592_PIPECFG);\r\nif ((tmp & M66592_CNTMD) != 0) {\r\ntmp = m66592_read(m66592, M66592_PIPEBUF);\r\nsize = ((tmp >> 10) + 1) * 64;\r\n} else {\r\ntmp = m66592_read(m66592, M66592_PIPEMAXP);\r\nsize = tmp & M66592_MXPS;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic inline void pipe_change(struct m66592 *m66592, u16 pipenum)\r\n{\r\nstruct m66592_ep *ep = m66592->pipenum2ep[pipenum];\r\nunsigned short mbw;\r\nif (ep->use_dma)\r\nreturn;\r\nm66592_mdfy(m66592, pipenum, M66592_CURPIPE, ep->fifosel);\r\nndelay(450);\r\nif (m66592->pdata->on_chip)\r\nmbw = M66592_MBW_32;\r\nelse\r\nmbw = M66592_MBW_16;\r\nm66592_bset(m66592, mbw, ep->fifosel);\r\n}\r\nstatic int pipe_buffer_setting(struct m66592 *m66592,\r\nstruct m66592_pipe_info *info)\r\n{\r\nu16 bufnum = 0, buf_bsize = 0;\r\nu16 pipecfg = 0;\r\nif (info->pipe == 0)\r\nreturn -EINVAL;\r\nm66592_write(m66592, info->pipe, M66592_PIPESEL);\r\nif (info->dir_in)\r\npipecfg |= M66592_DIR;\r\npipecfg |= info->type;\r\npipecfg |= info->epnum;\r\nswitch (info->type) {\r\ncase M66592_INT:\r\nbufnum = 4 + (info->pipe - M66592_BASE_PIPENUM_INT);\r\nbuf_bsize = 0;\r\nbreak;\r\ncase M66592_BULK:\r\nif (info->pipe >= M66592_BASE_PIPENUM_BULK)\r\nbufnum = info->pipe - M66592_BASE_PIPENUM_BULK;\r\nelse\r\nbufnum = info->pipe - M66592_BASE_PIPENUM_ISOC;\r\nbufnum = M66592_BASE_BUFNUM + (bufnum * 16);\r\nbuf_bsize = 7;\r\npipecfg |= M66592_DBLB;\r\nif (!info->dir_in)\r\npipecfg |= M66592_SHTNAK;\r\nbreak;\r\ncase M66592_ISO:\r\nbufnum = M66592_BASE_BUFNUM +\r\n(info->pipe - M66592_BASE_PIPENUM_ISOC) * 16;\r\nbuf_bsize = 7;\r\nbreak;\r\n}\r\nif (buf_bsize && ((bufnum + 16) >= M66592_MAX_BUFNUM)) {\r\npr_err("m66592 pipe memory is insufficient\n");\r\nreturn -ENOMEM;\r\n}\r\nm66592_write(m66592, pipecfg, M66592_PIPECFG);\r\nm66592_write(m66592, (buf_bsize << 10) | (bufnum), M66592_PIPEBUF);\r\nm66592_write(m66592, info->maxpacket, M66592_PIPEMAXP);\r\nif (info->interval)\r\ninfo->interval--;\r\nm66592_write(m66592, info->interval, M66592_PIPEPERI);\r\nreturn 0;\r\n}\r\nstatic void pipe_buffer_release(struct m66592 *m66592,\r\nstruct m66592_pipe_info *info)\r\n{\r\nif (info->pipe == 0)\r\nreturn;\r\nif (is_bulk_pipe(info->pipe)) {\r\nm66592->bulk--;\r\n} else if (is_interrupt_pipe(info->pipe))\r\nm66592->interrupt--;\r\nelse if (is_isoc_pipe(info->pipe)) {\r\nm66592->isochronous--;\r\nif (info->type == M66592_BULK)\r\nm66592->bulk--;\r\n} else\r\npr_err("ep_release: unexpect pipenum (%d)\n",\r\ninfo->pipe);\r\n}\r\nstatic void pipe_initialize(struct m66592_ep *ep)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\nunsigned short mbw;\r\nm66592_mdfy(m66592, 0, M66592_CURPIPE, ep->fifosel);\r\nm66592_write(m66592, M66592_ACLRM, ep->pipectr);\r\nm66592_write(m66592, 0, ep->pipectr);\r\nm66592_write(m66592, M66592_SQCLR, ep->pipectr);\r\nif (ep->use_dma) {\r\nm66592_mdfy(m66592, ep->pipenum, M66592_CURPIPE, ep->fifosel);\r\nndelay(450);\r\nif (m66592->pdata->on_chip)\r\nmbw = M66592_MBW_32;\r\nelse\r\nmbw = M66592_MBW_16;\r\nm66592_bset(m66592, mbw, ep->fifosel);\r\n}\r\n}\r\nstatic void m66592_ep_setting(struct m66592 *m66592, struct m66592_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc,\r\nu16 pipenum, int dma)\r\n{\r\nif ((pipenum != 0) && dma) {\r\nif (m66592->num_dma == 0) {\r\nm66592->num_dma++;\r\nep->use_dma = 1;\r\nep->fifoaddr = M66592_D0FIFO;\r\nep->fifosel = M66592_D0FIFOSEL;\r\nep->fifoctr = M66592_D0FIFOCTR;\r\nep->fifotrn = M66592_D0FIFOTRN;\r\n} else if (!m66592->pdata->on_chip && m66592->num_dma == 1) {\r\nm66592->num_dma++;\r\nep->use_dma = 1;\r\nep->fifoaddr = M66592_D1FIFO;\r\nep->fifosel = M66592_D1FIFOSEL;\r\nep->fifoctr = M66592_D1FIFOCTR;\r\nep->fifotrn = M66592_D1FIFOTRN;\r\n} else {\r\nep->use_dma = 0;\r\nep->fifoaddr = M66592_CFIFO;\r\nep->fifosel = M66592_CFIFOSEL;\r\nep->fifoctr = M66592_CFIFOCTR;\r\nep->fifotrn = 0;\r\n}\r\n} else {\r\nep->use_dma = 0;\r\nep->fifoaddr = M66592_CFIFO;\r\nep->fifosel = M66592_CFIFOSEL;\r\nep->fifoctr = M66592_CFIFOCTR;\r\nep->fifotrn = 0;\r\n}\r\nep->pipectr = get_pipectr_addr(pipenum);\r\nep->pipenum = pipenum;\r\nep->ep.maxpacket = usb_endpoint_maxp(desc);\r\nm66592->pipenum2ep[pipenum] = ep;\r\nm66592->epaddr2ep[desc->bEndpointAddress&USB_ENDPOINT_NUMBER_MASK] = ep;\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\nstatic void m66592_ep_release(struct m66592_ep *ep)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\nu16 pipenum = ep->pipenum;\r\nif (pipenum == 0)\r\nreturn;\r\nif (ep->use_dma)\r\nm66592->num_dma--;\r\nep->pipenum = 0;\r\nep->busy = 0;\r\nep->use_dma = 0;\r\n}\r\nstatic int alloc_pipe_config(struct m66592_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\nstruct m66592_pipe_info info;\r\nint dma = 0;\r\nint *counter;\r\nint ret;\r\nep->ep.desc = desc;\r\nBUG_ON(ep->pipenum);\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (m66592->bulk >= M66592_MAX_NUM_BULK) {\r\nif (m66592->isochronous >= M66592_MAX_NUM_ISOC) {\r\npr_err("bulk pipe is insufficient\n");\r\nreturn -ENODEV;\r\n} else {\r\ninfo.pipe = M66592_BASE_PIPENUM_ISOC\r\n+ m66592->isochronous;\r\ncounter = &m66592->isochronous;\r\n}\r\n} else {\r\ninfo.pipe = M66592_BASE_PIPENUM_BULK + m66592->bulk;\r\ncounter = &m66592->bulk;\r\n}\r\ninfo.type = M66592_BULK;\r\ndma = 1;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (m66592->interrupt >= M66592_MAX_NUM_INT) {\r\npr_err("interrupt pipe is insufficient\n");\r\nreturn -ENODEV;\r\n}\r\ninfo.pipe = M66592_BASE_PIPENUM_INT + m66592->interrupt;\r\ninfo.type = M66592_INT;\r\ncounter = &m66592->interrupt;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (m66592->isochronous >= M66592_MAX_NUM_ISOC) {\r\npr_err("isochronous pipe is insufficient\n");\r\nreturn -ENODEV;\r\n}\r\ninfo.pipe = M66592_BASE_PIPENUM_ISOC + m66592->isochronous;\r\ninfo.type = M66592_ISO;\r\ncounter = &m66592->isochronous;\r\nbreak;\r\ndefault:\r\npr_err("unexpect xfer type\n");\r\nreturn -EINVAL;\r\n}\r\nep->type = info.type;\r\ninfo.epnum = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\r\ninfo.maxpacket = usb_endpoint_maxp(desc);\r\ninfo.interval = desc->bInterval;\r\nif (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\r\ninfo.dir_in = 1;\r\nelse\r\ninfo.dir_in = 0;\r\nret = pipe_buffer_setting(m66592, &info);\r\nif (ret < 0) {\r\npr_err("pipe_buffer_setting fail\n");\r\nreturn ret;\r\n}\r\n(*counter)++;\r\nif ((counter == &m66592->isochronous) && info.type == M66592_BULK)\r\nm66592->bulk++;\r\nm66592_ep_setting(m66592, ep, desc, info.pipe, dma);\r\npipe_initialize(ep);\r\nreturn 0;\r\n}\r\nstatic int free_pipe_config(struct m66592_ep *ep)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\nstruct m66592_pipe_info info;\r\ninfo.pipe = ep->pipenum;\r\ninfo.type = ep->type;\r\npipe_buffer_release(m66592, &info);\r\nm66592_ep_release(ep);\r\nreturn 0;\r\n}\r\nstatic void pipe_irq_enable(struct m66592 *m66592, u16 pipenum)\r\n{\r\nenable_irq_ready(m66592, pipenum);\r\nenable_irq_nrdy(m66592, pipenum);\r\n}\r\nstatic void pipe_irq_disable(struct m66592 *m66592, u16 pipenum)\r\n{\r\ndisable_irq_ready(m66592, pipenum);\r\ndisable_irq_nrdy(m66592, pipenum);\r\n}\r\nstatic void control_end(struct m66592 *m66592, unsigned ccpl)\r\n{\r\nm66592->ep[0].internal_ccpl = ccpl;\r\npipe_start(m66592, 0);\r\nm66592_bset(m66592, M66592_CCPL, M66592_DCPCTR);\r\n}\r\nstatic void start_ep0_write(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\npipe_change(m66592, ep->pipenum);\r\nm66592_mdfy(m66592, M66592_ISEL | M66592_PIPE0,\r\n(M66592_ISEL | M66592_CURPIPE),\r\nM66592_CFIFOSEL);\r\nm66592_write(m66592, M66592_BCLR, ep->fifoctr);\r\nif (req->req.length == 0) {\r\nm66592_bset(m66592, M66592_BVAL, ep->fifoctr);\r\npipe_start(m66592, 0);\r\ntransfer_complete(ep, req, 0);\r\n} else {\r\nm66592_write(m66592, ~M66592_BEMP0, M66592_BEMPSTS);\r\nirq_ep0_write(ep, req);\r\n}\r\n}\r\nstatic void start_packet_write(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\nu16 tmp;\r\npipe_change(m66592, ep->pipenum);\r\ndisable_irq_empty(m66592, ep->pipenum);\r\npipe_start(m66592, ep->pipenum);\r\ntmp = m66592_read(m66592, ep->fifoctr);\r\nif (unlikely((tmp & M66592_FRDY) == 0))\r\npipe_irq_enable(m66592, ep->pipenum);\r\nelse\r\nirq_packet_write(ep, req);\r\n}\r\nstatic void start_packet_read(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nstruct m66592 *m66592 = ep->m66592;\r\nu16 pipenum = ep->pipenum;\r\nif (ep->pipenum == 0) {\r\nm66592_mdfy(m66592, M66592_PIPE0,\r\n(M66592_ISEL | M66592_CURPIPE),\r\nM66592_CFIFOSEL);\r\nm66592_write(m66592, M66592_BCLR, ep->fifoctr);\r\npipe_start(m66592, pipenum);\r\npipe_irq_enable(m66592, pipenum);\r\n} else {\r\nif (ep->use_dma) {\r\nm66592_bset(m66592, M66592_TRCLR, ep->fifosel);\r\npipe_change(m66592, pipenum);\r\nm66592_bset(m66592, M66592_TRENB, ep->fifosel);\r\nm66592_write(m66592,\r\n(req->req.length + ep->ep.maxpacket - 1)\r\n/ ep->ep.maxpacket,\r\nep->fifotrn);\r\n}\r\npipe_start(m66592, pipenum);\r\npipe_irq_enable(m66592, pipenum);\r\n}\r\n}\r\nstatic void start_packet(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\r\nstart_packet_write(ep, req);\r\nelse\r\nstart_packet_read(ep, req);\r\n}\r\nstatic void start_ep0(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nu16 ctsq;\r\nctsq = m66592_read(ep->m66592, M66592_INTSTS0) & M66592_CTSQ;\r\nswitch (ctsq) {\r\ncase M66592_CS_RDDS:\r\nstart_ep0_write(ep, req);\r\nbreak;\r\ncase M66592_CS_WRDS:\r\nstart_packet_read(ep, req);\r\nbreak;\r\ncase M66592_CS_WRND:\r\ncontrol_end(ep->m66592, 0);\r\nbreak;\r\ndefault:\r\npr_err("start_ep0: unexpect ctsq(%x)\n", ctsq);\r\nbreak;\r\n}\r\n}\r\nstatic void init_controller(struct m66592 *m66592)\r\n{\r\nunsigned int endian;\r\nif (m66592->pdata->on_chip) {\r\nif (m66592->pdata->endian)\r\nendian = 0;\r\nelse\r\nendian = M66592_LITTLE;\r\nm66592_bset(m66592, M66592_HSE, M66592_SYSCFG);\r\nm66592_bclr(m66592, M66592_USBE, M66592_SYSCFG);\r\nm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\r\nm66592_bset(m66592, M66592_USBE, M66592_SYSCFG);\r\nm66592_bset(m66592, 0x8000, M66592_DVSTCTR);\r\nm66592_bset(m66592, 0x1000, M66592_TESTMODE);\r\nm66592_bclr(m66592, 0x8000, M66592_DVSTCTR);\r\nm66592_bset(m66592, M66592_INTL, M66592_INTENB1);\r\nm66592_write(m66592, 0, M66592_CFBCFG);\r\nm66592_write(m66592, 0, M66592_D0FBCFG);\r\nm66592_bset(m66592, endian, M66592_CFBCFG);\r\nm66592_bset(m66592, endian, M66592_D0FBCFG);\r\n} else {\r\nunsigned int clock, vif, irq_sense;\r\nif (m66592->pdata->endian)\r\nendian = M66592_BIGEND;\r\nelse\r\nendian = 0;\r\nif (m66592->pdata->vif)\r\nvif = M66592_LDRV;\r\nelse\r\nvif = 0;\r\nswitch (m66592->pdata->xtal) {\r\ncase M66592_PLATDATA_XTAL_12MHZ:\r\nclock = M66592_XTAL12;\r\nbreak;\r\ncase M66592_PLATDATA_XTAL_24MHZ:\r\nclock = M66592_XTAL24;\r\nbreak;\r\ncase M66592_PLATDATA_XTAL_48MHZ:\r\nclock = M66592_XTAL48;\r\nbreak;\r\ndefault:\r\npr_warning("m66592-udc: xtal configuration error\n");\r\nclock = 0;\r\n}\r\nswitch (m66592->irq_trigger) {\r\ncase IRQF_TRIGGER_LOW:\r\nirq_sense = M66592_INTL;\r\nbreak;\r\ncase IRQF_TRIGGER_FALLING:\r\nirq_sense = 0;\r\nbreak;\r\ndefault:\r\npr_warning("m66592-udc: irq trigger config error\n");\r\nirq_sense = 0;\r\n}\r\nm66592_bset(m66592,\r\n(vif & M66592_LDRV) | (endian & M66592_BIGEND),\r\nM66592_PINCFG);\r\nm66592_bset(m66592, M66592_HSE, M66592_SYSCFG);\r\nm66592_mdfy(m66592, clock & M66592_XTAL, M66592_XTAL,\r\nM66592_SYSCFG);\r\nm66592_bclr(m66592, M66592_USBE, M66592_SYSCFG);\r\nm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\r\nm66592_bset(m66592, M66592_USBE, M66592_SYSCFG);\r\nm66592_bset(m66592, M66592_XCKE, M66592_SYSCFG);\r\nmsleep(3);\r\nm66592_bset(m66592, M66592_RCKE | M66592_PLLC, M66592_SYSCFG);\r\nmsleep(1);\r\nm66592_bset(m66592, M66592_SCKE, M66592_SYSCFG);\r\nm66592_bset(m66592, irq_sense & M66592_INTL, M66592_INTENB1);\r\nm66592_write(m66592, M66592_BURST | M66592_CPU_ADR_RD_WR,\r\nM66592_DMA0CFG);\r\n}\r\n}\r\nstatic void disable_controller(struct m66592 *m66592)\r\n{\r\nm66592_bclr(m66592, M66592_UTST, M66592_TESTMODE);\r\nif (!m66592->pdata->on_chip) {\r\nm66592_bclr(m66592, M66592_SCKE, M66592_SYSCFG);\r\nudelay(1);\r\nm66592_bclr(m66592, M66592_PLLC, M66592_SYSCFG);\r\nudelay(1);\r\nm66592_bclr(m66592, M66592_RCKE, M66592_SYSCFG);\r\nudelay(1);\r\nm66592_bclr(m66592, M66592_XCKE, M66592_SYSCFG);\r\n}\r\n}\r\nstatic void m66592_start_xclock(struct m66592 *m66592)\r\n{\r\nu16 tmp;\r\nif (!m66592->pdata->on_chip) {\r\ntmp = m66592_read(m66592, M66592_SYSCFG);\r\nif (!(tmp & M66592_XCKE))\r\nm66592_bset(m66592, M66592_XCKE, M66592_SYSCFG);\r\n}\r\n}\r\nstatic void transfer_complete(struct m66592_ep *ep,\r\nstruct m66592_request *req, int status)\r\n__releases(m66592->lock)\r\n__acquires(m66592->lock)\r\n{\r\nint restart = 0;\r\nif (unlikely(ep->pipenum == 0)) {\r\nif (ep->internal_ccpl) {\r\nep->internal_ccpl = 0;\r\nreturn;\r\n}\r\n}\r\nlist_del_init(&req->queue);\r\nif (ep->m66592->gadget.speed == USB_SPEED_UNKNOWN)\r\nreq->req.status = -ESHUTDOWN;\r\nelse\r\nreq->req.status = status;\r\nif (!list_empty(&ep->queue))\r\nrestart = 1;\r\nspin_unlock(&ep->m66592->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&ep->m66592->lock);\r\nif (restart) {\r\nreq = list_entry(ep->queue.next, struct m66592_request, queue);\r\nif (ep->ep.desc)\r\nstart_packet(ep, req);\r\n}\r\n}\r\nstatic void irq_ep0_write(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nint i;\r\nu16 tmp;\r\nunsigned bufsize;\r\nsize_t size;\r\nvoid *buf;\r\nu16 pipenum = ep->pipenum;\r\nstruct m66592 *m66592 = ep->m66592;\r\npipe_change(m66592, pipenum);\r\nm66592_bset(m66592, M66592_ISEL, ep->fifosel);\r\ni = 0;\r\ndo {\r\ntmp = m66592_read(m66592, ep->fifoctr);\r\nif (i++ > 100000) {\r\npr_err("pipe0 is busy. maybe cpu i/o bus "\r\n"conflict. please power off this controller.");\r\nreturn;\r\n}\r\nndelay(1);\r\n} while ((tmp & M66592_FRDY) == 0);\r\nbufsize = get_buffer_size(m66592, pipenum);\r\nbuf = req->req.buf + req->req.actual;\r\nsize = min(bufsize, req->req.length - req->req.actual);\r\nif (req->req.buf) {\r\nif (size > 0)\r\nm66592_write_fifo(m66592, ep, buf, size);\r\nif ((size == 0) || ((size % ep->ep.maxpacket) != 0))\r\nm66592_bset(m66592, M66592_BVAL, ep->fifoctr);\r\n}\r\nreq->req.actual += size;\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (size % ep->ep.maxpacket)\r\n|| (size == 0)) {\r\ndisable_irq_ready(m66592, pipenum);\r\ndisable_irq_empty(m66592, pipenum);\r\n} else {\r\ndisable_irq_ready(m66592, pipenum);\r\nenable_irq_empty(m66592, pipenum);\r\n}\r\npipe_start(m66592, pipenum);\r\n}\r\nstatic void irq_packet_write(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nu16 tmp;\r\nunsigned bufsize;\r\nsize_t size;\r\nvoid *buf;\r\nu16 pipenum = ep->pipenum;\r\nstruct m66592 *m66592 = ep->m66592;\r\npipe_change(m66592, pipenum);\r\ntmp = m66592_read(m66592, ep->fifoctr);\r\nif (unlikely((tmp & M66592_FRDY) == 0)) {\r\npipe_stop(m66592, pipenum);\r\npipe_irq_disable(m66592, pipenum);\r\npr_err("write fifo not ready. pipnum=%d\n", pipenum);\r\nreturn;\r\n}\r\nbufsize = get_buffer_size(m66592, pipenum);\r\nbuf = req->req.buf + req->req.actual;\r\nsize = min(bufsize, req->req.length - req->req.actual);\r\nif (req->req.buf) {\r\nm66592_write_fifo(m66592, ep, buf, size);\r\nif ((size == 0)\r\n|| ((size % ep->ep.maxpacket) != 0)\r\n|| ((bufsize != ep->ep.maxpacket)\r\n&& (bufsize > size)))\r\nm66592_bset(m66592, M66592_BVAL, ep->fifoctr);\r\n}\r\nreq->req.actual += size;\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (size % ep->ep.maxpacket)\r\n|| (size == 0)) {\r\ndisable_irq_ready(m66592, pipenum);\r\nenable_irq_empty(m66592, pipenum);\r\n} else {\r\ndisable_irq_empty(m66592, pipenum);\r\npipe_irq_enable(m66592, pipenum);\r\n}\r\n}\r\nstatic void irq_packet_read(struct m66592_ep *ep, struct m66592_request *req)\r\n{\r\nu16 tmp;\r\nint rcv_len, bufsize, req_len;\r\nint size;\r\nvoid *buf;\r\nu16 pipenum = ep->pipenum;\r\nstruct m66592 *m66592 = ep->m66592;\r\nint finish = 0;\r\npipe_change(m66592, pipenum);\r\ntmp = m66592_read(m66592, ep->fifoctr);\r\nif (unlikely((tmp & M66592_FRDY) == 0)) {\r\nreq->req.status = -EPIPE;\r\npipe_stop(m66592, pipenum);\r\npipe_irq_disable(m66592, pipenum);\r\npr_err("read fifo not ready");\r\nreturn;\r\n}\r\nrcv_len = tmp & M66592_DTLN;\r\nbufsize = get_buffer_size(m66592, pipenum);\r\nbuf = req->req.buf + req->req.actual;\r\nreq_len = req->req.length - req->req.actual;\r\nif (rcv_len < bufsize)\r\nsize = min(rcv_len, req_len);\r\nelse\r\nsize = min(bufsize, req_len);\r\nreq->req.actual += size;\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (size % ep->ep.maxpacket)\r\n|| (size == 0)) {\r\npipe_stop(m66592, pipenum);\r\npipe_irq_disable(m66592, pipenum);\r\nfinish = 1;\r\n}\r\nif (req->req.buf) {\r\nif (size == 0)\r\nm66592_write(m66592, M66592_BCLR, ep->fifoctr);\r\nelse\r\nm66592_read_fifo(m66592, ep->fifoaddr, buf, size);\r\n}\r\nif ((ep->pipenum != 0) && finish)\r\ntransfer_complete(ep, req, 0);\r\n}\r\nstatic void irq_pipe_ready(struct m66592 *m66592, u16 status, u16 enb)\r\n{\r\nu16 check;\r\nu16 pipenum;\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nif ((status & M66592_BRDY0) && (enb & M66592_BRDY0)) {\r\nm66592_write(m66592, ~M66592_BRDY0, M66592_BRDYSTS);\r\nm66592_mdfy(m66592, M66592_PIPE0, M66592_CURPIPE,\r\nM66592_CFIFOSEL);\r\nep = &m66592->ep[0];\r\nreq = list_entry(ep->queue.next, struct m66592_request, queue);\r\nirq_packet_read(ep, req);\r\n} else {\r\nfor (pipenum = 1; pipenum < M66592_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif ((status & check) && (enb & check)) {\r\nm66592_write(m66592, ~check, M66592_BRDYSTS);\r\nep = m66592->pipenum2ep[pipenum];\r\nreq = list_entry(ep->queue.next,\r\nstruct m66592_request, queue);\r\nif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\r\nirq_packet_write(ep, req);\r\nelse\r\nirq_packet_read(ep, req);\r\n}\r\n}\r\n}\r\n}\r\nstatic void irq_pipe_empty(struct m66592 *m66592, u16 status, u16 enb)\r\n{\r\nu16 tmp;\r\nu16 check;\r\nu16 pipenum;\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nif ((status & M66592_BEMP0) && (enb & M66592_BEMP0)) {\r\nm66592_write(m66592, ~M66592_BEMP0, M66592_BEMPSTS);\r\nep = &m66592->ep[0];\r\nreq = list_entry(ep->queue.next, struct m66592_request, queue);\r\nirq_ep0_write(ep, req);\r\n} else {\r\nfor (pipenum = 1; pipenum < M66592_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif ((status & check) && (enb & check)) {\r\nm66592_write(m66592, ~check, M66592_BEMPSTS);\r\ntmp = control_reg_get(m66592, pipenum);\r\nif ((tmp & M66592_INBUFM) == 0) {\r\ndisable_irq_empty(m66592, pipenum);\r\npipe_irq_disable(m66592, pipenum);\r\npipe_stop(m66592, pipenum);\r\nep = m66592->pipenum2ep[pipenum];\r\nreq = list_entry(ep->queue.next,\r\nstruct m66592_request,\r\nqueue);\r\nif (!list_empty(&ep->queue))\r\ntransfer_complete(ep, req, 0);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void get_status(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\r\n__releases(m66592->lock)\r\n__acquires(m66592->lock)\r\n{\r\nstruct m66592_ep *ep;\r\nu16 pid;\r\nu16 status = 0;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nstatus = 1 << USB_DEVICE_SELF_POWERED;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nstatus = 0;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\r\npid = control_reg_get_pid(m66592, ep->pipenum);\r\nif (pid == M66592_PID_STALL)\r\nstatus = 1 << USB_ENDPOINT_HALT;\r\nelse\r\nstatus = 0;\r\nbreak;\r\ndefault:\r\npipe_stall(m66592, 0);\r\nreturn;\r\n}\r\nm66592->ep0_data = cpu_to_le16(status);\r\nm66592->ep0_req->buf = &m66592->ep0_data;\r\nm66592->ep0_req->length = 2;\r\nspin_unlock(&m66592->lock);\r\nm66592_queue(m66592->gadget.ep0, m66592->ep0_req, GFP_KERNEL);\r\nspin_lock(&m66592->lock);\r\n}\r\nstatic void clear_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\r\n{\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\ncontrol_end(m66592, 1);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\ncontrol_end(m66592, 1);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\r\npipe_stop(m66592, ep->pipenum);\r\ncontrol_reg_sqclr(m66592, ep->pipenum);\r\ncontrol_end(m66592, 1);\r\nreq = list_entry(ep->queue.next,\r\nstruct m66592_request, queue);\r\nif (ep->busy) {\r\nep->busy = 0;\r\nif (list_empty(&ep->queue))\r\nbreak;\r\nstart_packet(ep, req);\r\n} else if (!list_empty(&ep->queue))\r\npipe_start(m66592, ep->pipenum);\r\n}\r\nbreak;\r\ndefault:\r\npipe_stall(m66592, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void set_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\r\n{\r\nu16 tmp;\r\nint timeout = 3000;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nswitch (le16_to_cpu(ctrl->wValue)) {\r\ncase USB_DEVICE_TEST_MODE:\r\ncontrol_end(m66592, 1);\r\ndo {\r\ntmp = m66592_read(m66592, M66592_INTSTS0) &\r\nM66592_CTSQ;\r\nudelay(1);\r\n} while (tmp != M66592_CS_IDST || timeout-- > 0);\r\nif (tmp == M66592_CS_IDST)\r\nm66592_bset(m66592,\r\nle16_to_cpu(ctrl->wIndex >> 8),\r\nM66592_TESTMODE);\r\nbreak;\r\ndefault:\r\npipe_stall(m66592, 0);\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\ncontrol_end(m66592, 1);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nstruct m66592_ep *ep;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\r\npipe_stall(m66592, ep->pipenum);\r\ncontrol_end(m66592, 1);\r\n}\r\nbreak;\r\ndefault:\r\npipe_stall(m66592, 0);\r\nbreak;\r\n}\r\n}\r\nstatic int setup_packet(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\r\n{\r\nu16 *p = (u16 *)ctrl;\r\nunsigned long offset = M66592_USBREQ;\r\nint i, ret = 0;\r\nm66592_write(m66592, ~M66592_VALID, M66592_INTSTS0);\r\nfor (i = 0; i < 4; i++)\r\np[i] = m66592_read(m66592, offset + i*2);\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nget_status(m66592, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nclear_feature(m66592, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nset_feature(m66592, ctrl);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\n} else\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic void m66592_update_usb_speed(struct m66592 *m66592)\r\n{\r\nu16 speed = get_usb_speed(m66592);\r\nswitch (speed) {\r\ncase M66592_HSMODE:\r\nm66592->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase M66592_FSMODE:\r\nm66592->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ndefault:\r\nm66592->gadget.speed = USB_SPEED_UNKNOWN;\r\npr_err("USB speed unknown\n");\r\n}\r\n}\r\nstatic void irq_device_state(struct m66592 *m66592)\r\n{\r\nu16 dvsq;\r\ndvsq = m66592_read(m66592, M66592_INTSTS0) & M66592_DVSQ;\r\nm66592_write(m66592, ~M66592_DVST, M66592_INTSTS0);\r\nif (dvsq == M66592_DS_DFLT) {\r\nm66592->driver->disconnect(&m66592->gadget);\r\nm66592_update_usb_speed(m66592);\r\n}\r\nif (m66592->old_dvsq == M66592_DS_CNFG && dvsq != M66592_DS_CNFG)\r\nm66592_update_usb_speed(m66592);\r\nif ((dvsq == M66592_DS_CNFG || dvsq == M66592_DS_ADDS)\r\n&& m66592->gadget.speed == USB_SPEED_UNKNOWN)\r\nm66592_update_usb_speed(m66592);\r\nm66592->old_dvsq = dvsq;\r\n}\r\nstatic void irq_control_stage(struct m66592 *m66592)\r\n__releases(m66592->lock)\r\n__acquires(m66592->lock)\r\n{\r\nstruct usb_ctrlrequest ctrl;\r\nu16 ctsq;\r\nctsq = m66592_read(m66592, M66592_INTSTS0) & M66592_CTSQ;\r\nm66592_write(m66592, ~M66592_CTRT, M66592_INTSTS0);\r\nswitch (ctsq) {\r\ncase M66592_CS_IDST: {\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nep = &m66592->ep[0];\r\nreq = list_entry(ep->queue.next, struct m66592_request, queue);\r\ntransfer_complete(ep, req, 0);\r\n}\r\nbreak;\r\ncase M66592_CS_RDDS:\r\ncase M66592_CS_WRDS:\r\ncase M66592_CS_WRND:\r\nif (setup_packet(m66592, &ctrl)) {\r\nspin_unlock(&m66592->lock);\r\nif (m66592->driver->setup(&m66592->gadget, &ctrl) < 0)\r\npipe_stall(m66592, 0);\r\nspin_lock(&m66592->lock);\r\n}\r\nbreak;\r\ncase M66592_CS_RDSS:\r\ncase M66592_CS_WRSS:\r\ncontrol_end(m66592, 0);\r\nbreak;\r\ndefault:\r\npr_err("ctrl_stage: unexpect ctsq(%x)\n", ctsq);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t m66592_irq(int irq, void *_m66592)\r\n{\r\nstruct m66592 *m66592 = _m66592;\r\nu16 intsts0;\r\nu16 intenb0;\r\nu16 brdysts, nrdysts, bempsts;\r\nu16 brdyenb, nrdyenb, bempenb;\r\nu16 savepipe;\r\nu16 mask0;\r\nspin_lock(&m66592->lock);\r\nintsts0 = m66592_read(m66592, M66592_INTSTS0);\r\nintenb0 = m66592_read(m66592, M66592_INTENB0);\r\nif (m66592->pdata->on_chip && !intsts0 && !intenb0) {\r\nm66592_start_xclock(m66592);\r\nintsts0 = m66592_read(m66592, M66592_INTSTS0);\r\nintenb0 = m66592_read(m66592, M66592_INTENB0);\r\n}\r\nsavepipe = m66592_read(m66592, M66592_CFIFOSEL);\r\nmask0 = intsts0 & intenb0;\r\nif (mask0) {\r\nbrdysts = m66592_read(m66592, M66592_BRDYSTS);\r\nnrdysts = m66592_read(m66592, M66592_NRDYSTS);\r\nbempsts = m66592_read(m66592, M66592_BEMPSTS);\r\nbrdyenb = m66592_read(m66592, M66592_BRDYENB);\r\nnrdyenb = m66592_read(m66592, M66592_NRDYENB);\r\nbempenb = m66592_read(m66592, M66592_BEMPENB);\r\nif (mask0 & M66592_VBINT) {\r\nm66592_write(m66592, 0xffff & ~M66592_VBINT,\r\nM66592_INTSTS0);\r\nm66592_start_xclock(m66592);\r\nm66592->old_vbus = m66592_read(m66592, M66592_INTSTS0)\r\n& M66592_VBSTS;\r\nm66592->scount = M66592_MAX_SAMPLING;\r\nmod_timer(&m66592->timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\nif (intsts0 & M66592_DVSQ)\r\nirq_device_state(m66592);\r\nif ((intsts0 & M66592_BRDY) && (intenb0 & M66592_BRDYE)\r\n&& (brdysts & brdyenb)) {\r\nirq_pipe_ready(m66592, brdysts, brdyenb);\r\n}\r\nif ((intsts0 & M66592_BEMP) && (intenb0 & M66592_BEMPE)\r\n&& (bempsts & bempenb)) {\r\nirq_pipe_empty(m66592, bempsts, bempenb);\r\n}\r\nif (intsts0 & M66592_CTRT)\r\nirq_control_stage(m66592);\r\n}\r\nm66592_write(m66592, savepipe, M66592_CFIFOSEL);\r\nspin_unlock(&m66592->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void m66592_timer(unsigned long _m66592)\r\n{\r\nstruct m66592 *m66592 = (struct m66592 *)_m66592;\r\nunsigned long flags;\r\nu16 tmp;\r\nspin_lock_irqsave(&m66592->lock, flags);\r\ntmp = m66592_read(m66592, M66592_SYSCFG);\r\nif (!(tmp & M66592_RCKE)) {\r\nm66592_bset(m66592, M66592_RCKE | M66592_PLLC, M66592_SYSCFG);\r\nudelay(10);\r\nm66592_bset(m66592, M66592_SCKE, M66592_SYSCFG);\r\n}\r\nif (m66592->scount > 0) {\r\ntmp = m66592_read(m66592, M66592_INTSTS0) & M66592_VBSTS;\r\nif (tmp == m66592->old_vbus) {\r\nm66592->scount--;\r\nif (m66592->scount == 0) {\r\nif (tmp == M66592_VBSTS)\r\nm66592_usb_connect(m66592);\r\nelse\r\nm66592_usb_disconnect(m66592);\r\n} else {\r\nmod_timer(&m66592->timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\n} else {\r\nm66592->scount = M66592_MAX_SAMPLING;\r\nm66592->old_vbus = tmp;\r\nmod_timer(&m66592->timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\n}\r\nspin_unlock_irqrestore(&m66592->lock, flags);\r\n}\r\nstatic int m66592_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct m66592_ep *ep;\r\nep = container_of(_ep, struct m66592_ep, ep);\r\nreturn alloc_pipe_config(ep, desc);\r\n}\r\nstatic int m66592_disable(struct usb_ep *_ep)\r\n{\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct m66592_ep, ep);\r\nBUG_ON(!ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct m66592_request, queue);\r\nspin_lock_irqsave(&ep->m66592->lock, flags);\r\ntransfer_complete(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->m66592->lock, flags);\r\n}\r\npipe_irq_disable(ep->m66592, ep->pipenum);\r\nreturn free_pipe_config(ep);\r\n}\r\nstatic struct usb_request *m66592_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct m66592_request *req;\r\nreq = kzalloc(sizeof(struct m66592_request), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void m66592_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct m66592_request *req;\r\nreq = container_of(_req, struct m66592_request, req);\r\nkfree(req);\r\n}\r\nstatic int m66592_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nunsigned long flags;\r\nint request = 0;\r\nep = container_of(_ep, struct m66592_ep, ep);\r\nreq = container_of(_req, struct m66592_request, req);\r\nif (ep->m66592->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&ep->m66592->lock, flags);\r\nif (list_empty(&ep->queue))\r\nrequest = 1;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreq->req.actual = 0;\r\nreq->req.status = -EINPROGRESS;\r\nif (ep->ep.desc == NULL)\r\nstart_ep0(ep, req);\r\nelse {\r\nif (request && !ep->busy)\r\nstart_packet(ep, req);\r\n}\r\nspin_unlock_irqrestore(&ep->m66592->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int m66592_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct m66592_ep, ep);\r\nreq = container_of(_req, struct m66592_request, req);\r\nspin_lock_irqsave(&ep->m66592->lock, flags);\r\nif (!list_empty(&ep->queue))\r\ntransfer_complete(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->m66592->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int m66592_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct m66592_ep *ep;\r\nstruct m66592_request *req;\r\nunsigned long flags;\r\nint ret = 0;\r\nep = container_of(_ep, struct m66592_ep, ep);\r\nreq = list_entry(ep->queue.next, struct m66592_request, queue);\r\nspin_lock_irqsave(&ep->m66592->lock, flags);\r\nif (!list_empty(&ep->queue)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nif (value) {\r\nep->busy = 1;\r\npipe_stall(ep->m66592, ep->pipenum);\r\n} else {\r\nep->busy = 0;\r\npipe_stop(ep->m66592, ep->pipenum);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ep->m66592->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void m66592_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct m66592_ep *ep;\r\nunsigned long flags;\r\nep = container_of(_ep, struct m66592_ep, ep);\r\nspin_lock_irqsave(&ep->m66592->lock, flags);\r\nif (list_empty(&ep->queue) && !ep->busy) {\r\npipe_stop(ep->m66592, ep->pipenum);\r\nm66592_bclr(ep->m66592, M66592_BCLR, ep->fifoctr);\r\n}\r\nspin_unlock_irqrestore(&ep->m66592->lock, flags);\r\n}\r\nstatic int m66592_start(struct usb_gadget_driver *driver,\r\nint (*bind)(struct usb_gadget *, struct usb_gadget_driver *))\r\n{\r\nstruct m66592 *m66592 = the_controller;\r\nint retval;\r\nif (!driver\r\n|| driver->max_speed < USB_SPEED_HIGH\r\n|| !bind\r\n|| !driver->setup)\r\nreturn -EINVAL;\r\nif (!m66592)\r\nreturn -ENODEV;\r\nif (m66592->driver)\r\nreturn -EBUSY;\r\ndriver->driver.bus = NULL;\r\nm66592->driver = driver;\r\nm66592->gadget.dev.driver = &driver->driver;\r\nretval = device_add(&m66592->gadget.dev);\r\nif (retval) {\r\npr_err("device_add error (%d)\n", retval);\r\ngoto error;\r\n}\r\nretval = bind(&m66592->gadget, driver);\r\nif (retval) {\r\npr_err("bind to driver error (%d)\n", retval);\r\ndevice_del(&m66592->gadget.dev);\r\ngoto error;\r\n}\r\nm66592_bset(m66592, M66592_VBSE | M66592_URST, M66592_INTENB0);\r\nif (m66592_read(m66592, M66592_INTSTS0) & M66592_VBSTS) {\r\nm66592_start_xclock(m66592);\r\nm66592->old_vbus = m66592_read(m66592,\r\nM66592_INTSTS0) & M66592_VBSTS;\r\nm66592->scount = M66592_MAX_SAMPLING;\r\nmod_timer(&m66592->timer, jiffies + msecs_to_jiffies(50));\r\n}\r\nreturn 0;\r\nerror:\r\nm66592->driver = NULL;\r\nm66592->gadget.dev.driver = NULL;\r\nreturn retval;\r\n}\r\nstatic int m66592_stop(struct usb_gadget_driver *driver)\r\n{\r\nstruct m66592 *m66592 = the_controller;\r\nunsigned long flags;\r\nif (driver != m66592->driver || !driver->unbind)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&m66592->lock, flags);\r\nif (m66592->gadget.speed != USB_SPEED_UNKNOWN)\r\nm66592_usb_disconnect(m66592);\r\nspin_unlock_irqrestore(&m66592->lock, flags);\r\nm66592_bclr(m66592, M66592_VBSE | M66592_URST, M66592_INTENB0);\r\ndriver->unbind(&m66592->gadget);\r\nm66592->gadget.dev.driver = NULL;\r\ninit_controller(m66592);\r\ndisable_controller(m66592);\r\ndevice_del(&m66592->gadget.dev);\r\nm66592->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic int m66592_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct m66592 *m66592 = gadget_to_m66592(_gadget);\r\nreturn m66592_read(m66592, M66592_FRMNUM) & 0x03FF;\r\n}\r\nstatic int m66592_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct m66592 *m66592 = gadget_to_m66592(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&m66592->lock, flags);\r\nif (is_on)\r\nm66592_bset(m66592, M66592_DPRPU, M66592_SYSCFG);\r\nelse\r\nm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\r\nspin_unlock_irqrestore(&m66592->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __exit m66592_remove(struct platform_device *pdev)\r\n{\r\nstruct m66592 *m66592 = dev_get_drvdata(&pdev->dev);\r\nusb_del_gadget_udc(&m66592->gadget);\r\ndel_timer_sync(&m66592->timer);\r\niounmap(m66592->reg);\r\nfree_irq(platform_get_irq(pdev, 0), m66592);\r\nm66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);\r\nif (m66592->pdata->on_chip) {\r\nclk_disable(m66592->clk);\r\nclk_put(m66592->clk);\r\n}\r\nkfree(m66592);\r\nreturn 0;\r\n}\r\nstatic void nop_completion(struct usb_ep *ep, struct usb_request *r)\r\n{\r\n}\r\nstatic int __init m66592_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res, *ires;\r\nvoid __iomem *reg = NULL;\r\nstruct m66592 *m66592 = NULL;\r\nchar clk_name[8];\r\nint ret = 0;\r\nint i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\npr_err("platform_get_resource error.\n");\r\ngoto clean_up;\r\n}\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!ires) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev,\r\n"platform_get_resource IORESOURCE_IRQ error.\n");\r\ngoto clean_up;\r\n}\r\nreg = ioremap(res->start, resource_size(res));\r\nif (reg == NULL) {\r\nret = -ENOMEM;\r\npr_err("ioremap error.\n");\r\ngoto clean_up;\r\n}\r\nif (pdev->dev.platform_data == NULL) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nret = -ENODEV;\r\ngoto clean_up;\r\n}\r\nm66592 = kzalloc(sizeof(struct m66592), GFP_KERNEL);\r\nif (m66592 == NULL) {\r\nret = -ENOMEM;\r\npr_err("kzalloc error\n");\r\ngoto clean_up;\r\n}\r\nm66592->pdata = pdev->dev.platform_data;\r\nm66592->irq_trigger = ires->flags & IRQF_TRIGGER_MASK;\r\nspin_lock_init(&m66592->lock);\r\ndev_set_drvdata(&pdev->dev, m66592);\r\nm66592->gadget.ops = &m66592_gadget_ops;\r\ndevice_initialize(&m66592->gadget.dev);\r\ndev_set_name(&m66592->gadget.dev, "gadget");\r\nm66592->gadget.max_speed = USB_SPEED_HIGH;\r\nm66592->gadget.dev.parent = &pdev->dev;\r\nm66592->gadget.dev.dma_mask = pdev->dev.dma_mask;\r\nm66592->gadget.dev.release = pdev->dev.release;\r\nm66592->gadget.name = udc_name;\r\ninit_timer(&m66592->timer);\r\nm66592->timer.function = m66592_timer;\r\nm66592->timer.data = (unsigned long)m66592;\r\nm66592->reg = reg;\r\nret = request_irq(ires->start, m66592_irq, IRQF_SHARED,\r\nudc_name, m66592);\r\nif (ret < 0) {\r\npr_err("request_irq error (%d)\n", ret);\r\ngoto clean_up;\r\n}\r\nif (m66592->pdata->on_chip) {\r\nsnprintf(clk_name, sizeof(clk_name), "usbf%d", pdev->id);\r\nm66592->clk = clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(m66592->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock \"%s\"\n",\r\nclk_name);\r\nret = PTR_ERR(m66592->clk);\r\ngoto clean_up2;\r\n}\r\nclk_enable(m66592->clk);\r\n}\r\nINIT_LIST_HEAD(&m66592->gadget.ep_list);\r\nm66592->gadget.ep0 = &m66592->ep[0].ep;\r\nINIT_LIST_HEAD(&m66592->gadget.ep0->ep_list);\r\nfor (i = 0; i < M66592_MAX_NUM_PIPE; i++) {\r\nstruct m66592_ep *ep = &m66592->ep[i];\r\nif (i != 0) {\r\nINIT_LIST_HEAD(&m66592->ep[i].ep.ep_list);\r\nlist_add_tail(&m66592->ep[i].ep.ep_list,\r\n&m66592->gadget.ep_list);\r\n}\r\nep->m66592 = m66592;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->ep.name = m66592_ep_name[i];\r\nep->ep.ops = &m66592_ep_ops;\r\nep->ep.maxpacket = 512;\r\n}\r\nm66592->ep[0].ep.maxpacket = 64;\r\nm66592->ep[0].pipenum = 0;\r\nm66592->ep[0].fifoaddr = M66592_CFIFO;\r\nm66592->ep[0].fifosel = M66592_CFIFOSEL;\r\nm66592->ep[0].fifoctr = M66592_CFIFOCTR;\r\nm66592->ep[0].fifotrn = 0;\r\nm66592->ep[0].pipectr = get_pipectr_addr(0);\r\nm66592->pipenum2ep[0] = &m66592->ep[0];\r\nm66592->epaddr2ep[0] = &m66592->ep[0];\r\nthe_controller = m66592;\r\nm66592->ep0_req = m66592_alloc_request(&m66592->ep[0].ep, GFP_KERNEL);\r\nif (m66592->ep0_req == NULL)\r\ngoto clean_up3;\r\nm66592->ep0_req->complete = nop_completion;\r\ninit_controller(m66592);\r\nret = usb_add_gadget_udc(&pdev->dev, &m66592->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\ndev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);\r\nreturn 0;\r\nerr_add_udc:\r\nm66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);\r\nclean_up3:\r\nif (m66592->pdata->on_chip) {\r\nclk_disable(m66592->clk);\r\nclk_put(m66592->clk);\r\n}\r\nclean_up2:\r\nfree_irq(ires->start, m66592);\r\nclean_up:\r\nif (m66592) {\r\nif (m66592->ep0_req)\r\nm66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);\r\nkfree(m66592);\r\n}\r\nif (reg)\r\niounmap(reg);\r\nreturn ret;\r\n}\r\nstatic int __init m66592_udc_init(void)\r\n{\r\nreturn platform_driver_probe(&m66592_driver, m66592_probe);\r\n}\r\nstatic void __exit m66592_udc_cleanup(void)\r\n{\r\nplatform_driver_unregister(&m66592_driver);\r\n}
