static int request_is_queued(struct adb_request *req) {\r\nstruct adb_request *cur;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ncur = current_req;\r\nwhile (cur) {\r\nif (cur == req) {\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\ncur = cur->next;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int macii_probe(void)\r\n{\r\nif (macintosh_config->adb_type != MAC_ADB_II) return -ENODEV;\r\nvia = via1;\r\nprintk("adb: Mac II ADB Driver v1.0 for Unified ADB\n");\r\nreturn 0;\r\n}\r\nint macii_init(void)\r\n{\r\nunsigned long flags;\r\nint err;\r\nlocal_irq_save(flags);\r\nerr = macii_init_via();\r\nif (err) goto out;\r\nerr = request_irq(IRQ_MAC_ADB, macii_interrupt, 0, "ADB",\r\nmacii_interrupt);\r\nif (err) goto out;\r\nmacii_state = idle;\r\nout:\r\nlocal_irq_restore(flags);\r\nreturn err;\r\n}\r\nstatic int macii_init_via(void)\r\n{\r\nunsigned char x;\r\nvia[DIRB] = (via[DIRB] | ST_EVEN | ST_ODD) & ~CTLR_IRQ;\r\nvia[B] |= ST_IDLE;\r\nlast_status = via[B] & (ST_MASK|CTLR_IRQ);\r\nvia[ACR] = (via[ACR] & ~SR_CTRL) | SR_EXT;\r\nx = via[SR];\r\nreturn 0;\r\n}\r\nstatic void macii_queue_poll(void)\r\n{\r\nint device_mask;\r\nint next_device;\r\nstatic struct adb_request req;\r\nif (!autopoll_devs) return;\r\ndevice_mask = (1 << (((command_byte & 0xF0) >> 4) + 1)) - 1;\r\nif (autopoll_devs & ~device_mask)\r\nnext_device = ffs(autopoll_devs & ~device_mask) - 1;\r\nelse\r\nnext_device = ffs(autopoll_devs) - 1;\r\nBUG_ON(request_is_queued(&req));\r\nadb_request(&req, NULL, ADBREQ_NOSEND, 1,\r\nADB_READREG(next_device, 0));\r\nreq.sent = 0;\r\nreq.complete = 0;\r\nreq.reply_len = 0;\r\nreq.next = current_req;\r\nif (current_req != NULL) {\r\ncurrent_req = &req;\r\n} else {\r\ncurrent_req = &req;\r\nlast_req = &req;\r\n}\r\n}\r\nstatic int macii_send_request(struct adb_request *req, int sync)\r\n{\r\nint err;\r\nunsigned long flags;\r\nBUG_ON(request_is_queued(req));\r\nlocal_irq_save(flags);\r\nerr = macii_write(req);\r\nlocal_irq_restore(flags);\r\nif (!err && sync) {\r\nwhile (!req->complete) {\r\nmacii_poll();\r\n}\r\nBUG_ON(request_is_queued(req));\r\n}\r\nreturn err;\r\n}\r\nstatic int macii_write(struct adb_request *req)\r\n{\r\nif (req->nbytes < 2 || req->data[0] != ADB_PACKET || req->nbytes > 15) {\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nreq->next = NULL;\r\nreq->sent = 0;\r\nreq->complete = 0;\r\nreq->reply_len = 0;\r\nif (current_req != NULL) {\r\nlast_req->next = req;\r\nlast_req = req;\r\n} else {\r\ncurrent_req = req;\r\nlast_req = req;\r\nif (macii_state == idle) macii_start();\r\n}\r\nreturn 0;\r\n}\r\nstatic int macii_autopoll(int devs)\r\n{\r\nstatic struct adb_request req;\r\nunsigned long flags;\r\nint err = 0;\r\nautopoll_devs = devs & 0xFFFE;\r\nif (!autopoll_devs) return 0;\r\nlocal_irq_save(flags);\r\nif (current_req == NULL) {\r\nadb_request(&req, NULL, ADBREQ_NOSEND, 1,\r\nADB_READREG(ffs(autopoll_devs) - 1, 0));\r\nerr = macii_write(&req);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn err;\r\n}\r\nstatic inline int need_autopoll(void) {\r\nif ((command_byte & 0x0F) == 0x0C &&\r\n((1 << ((command_byte & 0xF0) >> 4)) & autopoll_devs))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void macii_poll(void)\r\n{\r\ndisable_irq(IRQ_MAC_ADB);\r\nmacii_interrupt(0, NULL);\r\nenable_irq(IRQ_MAC_ADB);\r\n}\r\nstatic int macii_reset_bus(void)\r\n{\r\nstatic struct adb_request req;\r\nif (request_is_queued(&req))\r\nreturn 0;\r\nadb_request(&req, NULL, 0, 1, ADB_BUSRESET);\r\nudelay(3000);\r\nreturn 0;\r\n}\r\nstatic void macii_start(void)\r\n{\r\nstruct adb_request *req;\r\nreq = current_req;\r\nBUG_ON(req == NULL);\r\nBUG_ON(macii_state != idle);\r\ncommand_byte = req->data[1];\r\nvia[ACR] |= SR_OUT;\r\nvia[SR] = req->data[1];\r\nvia[B] = (via[B] & ~ST_MASK) | ST_CMD;\r\nmacii_state = sending;\r\ndata_index = 2;\r\n}\r\nstatic irqreturn_t macii_interrupt(int irq, void *arg)\r\n{\r\nint x;\r\nstatic int entered;\r\nstruct adb_request *req;\r\nif (!arg) {\r\nif (via[IFR] & SR_INT)\r\nvia[IFR] = SR_INT;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nBUG_ON(entered++);\r\nlast_status = status;\r\nstatus = via[B] & (ST_MASK|CTLR_IRQ);\r\nswitch (macii_state) {\r\ncase idle:\r\nif (reading_reply) {\r\nreply_ptr = current_req->reply;\r\n} else {\r\nBUG_ON(current_req != NULL);\r\nreply_ptr = reply_buf;\r\n}\r\nx = via[SR];\r\nif ((status & CTLR_IRQ) && (x == 0xFF)) {\r\nreply_len = 0;\r\nsrq_asserted = 0;\r\nmacii_state = read_done;\r\n} else {\r\nmacii_state = reading;\r\n*reply_ptr = x;\r\nreply_len = 1;\r\n}\r\nvia[B] = (via[B] & ~ST_MASK) | ST_EVEN;\r\nbreak;\r\ncase sending:\r\nreq = current_req;\r\nif (data_index >= req->nbytes) {\r\nreq->sent = 1;\r\nmacii_state = idle;\r\nif (req->reply_expected) {\r\nreading_reply = 1;\r\n} else {\r\nreq->complete = 1;\r\ncurrent_req = req->next;\r\nif (req->done) (*req->done)(req);\r\nif (current_req)\r\nmacii_start();\r\nelse\r\nif (need_autopoll())\r\nmacii_autopoll(autopoll_devs);\r\n}\r\nif (macii_state == idle) {\r\nvia[ACR] &= ~SR_OUT;\r\nx = via[SR];\r\nvia[B] = (via[B] & ~ST_MASK) | ST_IDLE;\r\n}\r\n} else {\r\nvia[SR] = req->data[data_index++];\r\nif ( (via[B] & ST_MASK) == ST_CMD ) {\r\nvia[B] = (via[B] & ~ST_MASK) | ST_EVEN;\r\n} else {\r\nvia[B] ^= ST_MASK;\r\n}\r\n}\r\nbreak;\r\ncase reading:\r\nx = via[SR];\r\nBUG_ON((status & ST_MASK) == ST_CMD ||\r\n(status & ST_MASK) == ST_IDLE);\r\nsrq_asserted = 0;\r\nif (!(status & CTLR_IRQ)) {\r\nif (x == 0xFF) {\r\nif (!(last_status & CTLR_IRQ)) {\r\nmacii_state = read_done;\r\nreply_len = 0;\r\nsrq_asserted = 1;\r\n}\r\n} else if (x == 0x00) {\r\nmacii_state = read_done;\r\nif (!(last_status & CTLR_IRQ))\r\nsrq_asserted = 1;\r\n}\r\n}\r\nif (macii_state == reading) {\r\nBUG_ON(reply_len > 15);\r\nreply_ptr++;\r\n*reply_ptr = x;\r\nreply_len++;\r\n}\r\nvia[B] ^= ST_MASK;\r\nbreak;\r\ncase read_done:\r\nx = via[SR];\r\nif (reading_reply) {\r\nreading_reply = 0;\r\nreq = current_req;\r\nreq->reply_len = reply_len;\r\nreq->complete = 1;\r\ncurrent_req = req->next;\r\nif (req->done) (*req->done)(req);\r\n} else if (reply_len && autopoll_devs)\r\nadb_input(reply_buf, reply_len, 0);\r\nmacii_state = idle;\r\nif (srq_asserted)\r\nmacii_queue_poll();\r\nif (current_req)\r\nmacii_start();\r\nelse\r\nif (need_autopoll())\r\nmacii_autopoll(autopoll_devs);\r\nif (macii_state == idle)\r\nvia[B] = (via[B] & ~ST_MASK) | ST_IDLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nentered--;\r\nreturn IRQ_HANDLED;\r\n}
