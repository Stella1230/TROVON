static cycle_t tc_get_cycles(struct clocksource *cs)\r\n{\r\nunsigned long flags;\r\nu32 lower, upper;\r\nraw_local_irq_save(flags);\r\ndo {\r\nupper = __raw_readl(tcaddr + ATMEL_TC_REG(1, CV));\r\nlower = __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));\r\n} while (upper != __raw_readl(tcaddr + ATMEL_TC_REG(1, CV)));\r\nraw_local_irq_restore(flags);\r\nreturn (upper << 16) | lower;\r\n}\r\nstatic cycle_t tc_get_cycles32(struct clocksource *cs)\r\n{\r\nreturn __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));\r\n}\r\nstatic struct tc_clkevt_device *to_tc_clkevt(struct clock_event_device *clkevt)\r\n{\r\nreturn container_of(clkevt, struct tc_clkevt_device, clkevt);\r\n}\r\nstatic void tc_mode(enum clock_event_mode m, struct clock_event_device *d)\r\n{\r\nstruct tc_clkevt_device *tcd = to_tc_clkevt(d);\r\nvoid __iomem *regs = tcd->regs;\r\nif (tcd->clkevt.mode == CLOCK_EVT_MODE_PERIODIC\r\n|| tcd->clkevt.mode == CLOCK_EVT_MODE_ONESHOT) {\r\n__raw_writel(0xff, regs + ATMEL_TC_REG(2, IDR));\r\n__raw_writel(ATMEL_TC_CLKDIS, regs + ATMEL_TC_REG(2, CCR));\r\nclk_disable(tcd->clk);\r\n}\r\nswitch (m) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nclk_enable(tcd->clk);\r\n__raw_writel(timer_clock\r\n| ATMEL_TC_WAVE | ATMEL_TC_WAVESEL_UP_AUTO,\r\nregs + ATMEL_TC_REG(2, CMR));\r\n__raw_writel((32768 + HZ/2) / HZ, tcaddr + ATMEL_TC_REG(2, RC));\r\n__raw_writel(ATMEL_TC_CPCS, regs + ATMEL_TC_REG(2, IER));\r\n__raw_writel(ATMEL_TC_CLKEN | ATMEL_TC_SWTRG,\r\nregs + ATMEL_TC_REG(2, CCR));\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nclk_enable(tcd->clk);\r\n__raw_writel(timer_clock | ATMEL_TC_CPCSTOP\r\n| ATMEL_TC_WAVE | ATMEL_TC_WAVESEL_UP_AUTO,\r\nregs + ATMEL_TC_REG(2, CMR));\r\n__raw_writel(ATMEL_TC_CPCS, regs + ATMEL_TC_REG(2, IER));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int tc_next_event(unsigned long delta, struct clock_event_device *d)\r\n{\r\n__raw_writel(delta, tcaddr + ATMEL_TC_REG(2, RC));\r\n__raw_writel(ATMEL_TC_CLKEN | ATMEL_TC_SWTRG,\r\ntcaddr + ATMEL_TC_REG(2, CCR));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ch2_irq(int irq, void *handle)\r\n{\r\nstruct tc_clkevt_device *dev = handle;\r\nunsigned int sr;\r\nsr = __raw_readl(dev->regs + ATMEL_TC_REG(2, SR));\r\nif (sr & ATMEL_TC_CPCS) {\r\ndev->clkevt.event_handler(&dev->clkevt);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void __init setup_clkevents(struct atmel_tc *tc, int clk32k_divisor_idx)\r\n{\r\nstruct clk *t2_clk = tc->clk[2];\r\nint irq = tc->irq[2];\r\nclkevt.regs = tc->regs;\r\nclkevt.clk = t2_clk;\r\ntc_irqaction.dev_id = &clkevt;\r\ntimer_clock = clk32k_divisor_idx;\r\nclkevt.clkevt.mult = div_sc(32768, NSEC_PER_SEC, clkevt.clkevt.shift);\r\nclkevt.clkevt.max_delta_ns\r\n= clockevent_delta2ns(0xffff, &clkevt.clkevt);\r\nclkevt.clkevt.min_delta_ns = clockevent_delta2ns(1, &clkevt.clkevt) + 1;\r\nclkevt.clkevt.cpumask = cpumask_of(0);\r\nclockevents_register_device(&clkevt.clkevt);\r\nsetup_irq(irq, &tc_irqaction);\r\n}\r\nstatic void __init setup_clkevents(struct atmel_tc *tc, int clk32k_divisor_idx)\r\n{\r\n}\r\nstatic void __init tcb_setup_dual_chan(struct atmel_tc *tc, int mck_divisor_idx)\r\n{\r\n__raw_writel(mck_divisor_idx\r\n| ATMEL_TC_WAVE\r\n| ATMEL_TC_WAVESEL_UP\r\n| ATMEL_TC_ACPA_SET\r\n| ATMEL_TC_ACPC_CLEAR,\r\ntcaddr + ATMEL_TC_REG(0, CMR));\r\n__raw_writel(0x0000, tcaddr + ATMEL_TC_REG(0, RA));\r\n__raw_writel(0x8000, tcaddr + ATMEL_TC_REG(0, RC));\r\n__raw_writel(0xff, tcaddr + ATMEL_TC_REG(0, IDR));\r\n__raw_writel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(0, CCR));\r\n__raw_writel(ATMEL_TC_XC1\r\n| ATMEL_TC_WAVE\r\n| ATMEL_TC_WAVESEL_UP,\r\ntcaddr + ATMEL_TC_REG(1, CMR));\r\n__raw_writel(0xff, tcaddr + ATMEL_TC_REG(1, IDR));\r\n__raw_writel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(1, CCR));\r\n__raw_writel(ATMEL_TC_TC1XC1S_TIOA0, tcaddr + ATMEL_TC_BMR);\r\n__raw_writel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);\r\n}\r\nstatic void __init tcb_setup_single_chan(struct atmel_tc *tc, int mck_divisor_idx)\r\n{\r\n__raw_writel(mck_divisor_idx\r\n| ATMEL_TC_WAVE\r\n| ATMEL_TC_WAVESEL_UP,\r\ntcaddr + ATMEL_TC_REG(0, CMR));\r\n__raw_writel(0xff, tcaddr + ATMEL_TC_REG(0, IDR));\r\n__raw_writel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(0, CCR));\r\n__raw_writel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);\r\n}\r\nstatic int __init tcb_clksrc_init(void)\r\n{\r\nstatic char bootinfo[] __initdata\r\n= KERN_DEBUG "%s: tc%d at %d.%03d MHz\n";\r\nstruct platform_device *pdev;\r\nstruct atmel_tc *tc;\r\nstruct clk *t0_clk;\r\nu32 rate, divided_rate = 0;\r\nint best_divisor_idx = -1;\r\nint clk32k_divisor_idx = -1;\r\nint i;\r\ntc = atmel_tc_alloc(CONFIG_ATMEL_TCB_CLKSRC_BLOCK, clksrc.name);\r\nif (!tc) {\r\npr_debug("can't alloc TC for clocksource\n");\r\nreturn -ENODEV;\r\n}\r\ntcaddr = tc->regs;\r\npdev = tc->pdev;\r\nt0_clk = tc->clk[0];\r\nclk_enable(t0_clk);\r\nrate = (u32) clk_get_rate(t0_clk);\r\nfor (i = 0; i < 5; i++) {\r\nunsigned divisor = atmel_tc_divisors[i];\r\nunsigned tmp;\r\nif (!divisor) {\r\nclk32k_divisor_idx = i;\r\ncontinue;\r\n}\r\ntmp = rate / divisor;\r\npr_debug("TC: %u / %-3u [%d] --> %u\n", rate, divisor, i, tmp);\r\nif (best_divisor_idx > 0) {\r\nif (tmp < 5 * 1000 * 1000)\r\ncontinue;\r\n}\r\ndivided_rate = tmp;\r\nbest_divisor_idx = i;\r\n}\r\nprintk(bootinfo, clksrc.name, CONFIG_ATMEL_TCB_CLKSRC_BLOCK,\r\ndivided_rate / 1000000,\r\n((divided_rate + 500000) % 1000000) / 1000);\r\nif (tc->tcb_config && tc->tcb_config->counter_width == 32) {\r\nclksrc.read = tc_get_cycles32;\r\ntcb_setup_single_chan(tc, best_divisor_idx);\r\n} else {\r\nclk_enable(tc->clk[1]);\r\ntcb_setup_dual_chan(tc, best_divisor_idx);\r\n}\r\nclocksource_register_hz(&clksrc, divided_rate);\r\nsetup_clkevents(tc, clk32k_divisor_idx);\r\nreturn 0;\r\n}
