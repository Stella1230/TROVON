static int cifs_calc_signature(struct smb_rqst *rqst,\r\nstruct TCP_Server_Info *server, char *signature)\r\n{\r\nint i;\r\nint rc;\r\nstruct kvec *iov = rqst->rq_iov;\r\nint n_vec = rqst->rq_nvec;\r\nif (iov == NULL || signature == NULL || server == NULL)\r\nreturn -EINVAL;\r\nif (!server->secmech.sdescmd5) {\r\ncERROR(1, "%s: Can't generate signature", __func__);\r\nreturn -1;\r\n}\r\nrc = crypto_shash_init(&server->secmech.sdescmd5->shash);\r\nif (rc) {\r\ncERROR(1, "%s: Could not init md5", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_update(&server->secmech.sdescmd5->shash,\r\nserver->session_key.response, server->session_key.len);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with response", __func__);\r\nreturn rc;\r\n}\r\nfor (i = 0; i < n_vec; i++) {\r\nif (iov[i].iov_len == 0)\r\ncontinue;\r\nif (iov[i].iov_base == NULL) {\r\ncERROR(1, "null iovec entry");\r\nreturn -EIO;\r\n}\r\nif (i == 0) {\r\nif (iov[0].iov_len <= 8)\r\nbreak;\r\nrc =\r\ncrypto_shash_update(&server->secmech.sdescmd5->shash,\r\niov[i].iov_base + 4, iov[i].iov_len - 4);\r\n} else {\r\nrc =\r\ncrypto_shash_update(&server->secmech.sdescmd5->shash,\r\niov[i].iov_base, iov[i].iov_len);\r\n}\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with payload",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < rqst->rq_npages; i++) {\r\nstruct kvec p_iov;\r\ncifs_rqst_page_to_kvec(rqst, i, &p_iov);\r\ncrypto_shash_update(&server->secmech.sdescmd5->shash,\r\np_iov.iov_base, p_iov.iov_len);\r\nkunmap(rqst->rq_pages[i]);\r\n}\r\nrc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\r\nif (rc)\r\ncERROR(1, "%s: Could not generate md5 hash", __func__);\r\nreturn rc;\r\n}\r\nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\r\n__u32 *pexpected_response_sequence_number)\r\n{\r\nint rc = 0;\r\nchar smb_signature[20];\r\nstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\r\nif ((cifs_pdu == NULL) || (server == NULL))\r\nreturn -EINVAL;\r\nif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\r\nserver->tcpStatus == CifsNeedNegotiate)\r\nreturn rc;\r\nif (!server->session_estab) {\r\nmemcpy(cifs_pdu->Signature.SecuritySignature, "BSRSPYL", 8);\r\nreturn rc;\r\n}\r\ncifs_pdu->Signature.Sequence.SequenceNumber =\r\ncpu_to_le32(server->sequence_number);\r\ncifs_pdu->Signature.Sequence.Reserved = 0;\r\n*pexpected_response_sequence_number = server->sequence_number++;\r\nserver->sequence_number++;\r\nrc = cifs_calc_signature(rqst, server, smb_signature);\r\nif (rc)\r\nmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\r\nelse\r\nmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\r\nreturn rc;\r\n}\r\nint cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\r\n__u32 *pexpected_response_sequence)\r\n{\r\nstruct smb_rqst rqst = { .rq_iov = iov,\r\n.rq_nvec = n_vec };\r\nreturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\r\n}\r\nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\r\n__u32 *pexpected_response_sequence_number)\r\n{\r\nstruct kvec iov;\r\niov.iov_base = cifs_pdu;\r\niov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\r\nreturn cifs_sign_smbv(&iov, 1, server,\r\npexpected_response_sequence_number);\r\n}\r\nint cifs_verify_signature(struct smb_rqst *rqst,\r\nstruct TCP_Server_Info *server,\r\n__u32 expected_sequence_number)\r\n{\r\nunsigned int rc;\r\nchar server_response_sig[8];\r\nchar what_we_think_sig_should_be[20];\r\nstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\r\nif (cifs_pdu == NULL || server == NULL)\r\nreturn -EINVAL;\r\nif (!server->session_estab)\r\nreturn 0;\r\nif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\r\nstruct smb_com_lock_req *pSMB =\r\n(struct smb_com_lock_req *)cifs_pdu;\r\nif (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\r\nreturn 0;\r\n}\r\nif (memcmp(cifs_pdu->Signature.SecuritySignature, "BSRSPYL ", 8) == 0)\r\ncFYI(1, "dummy signature received for smb command 0x%x",\r\ncifs_pdu->Command);\r\nmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\r\ncifs_pdu->Signature.Sequence.SequenceNumber =\r\ncpu_to_le32(expected_sequence_number);\r\ncifs_pdu->Signature.Sequence.Reserved = 0;\r\nmutex_lock(&server->srv_mutex);\r\nrc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\r\nmutex_unlock(&server->srv_mutex);\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\r\nreturn -EACCES;\r\nelse\r\nreturn 0;\r\n}\r\nint setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nunsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;\r\nchar temp_key[CIFS_SESS_KEY_SIZE];\r\nif (!ses)\r\nreturn -EINVAL;\r\nses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\ncERROR(1, "NTLM can't allocate (%u bytes) memory", temp_len);\r\nreturn -ENOMEM;\r\n}\r\nses->auth_key.len = temp_len;\r\nrc = SMBNTencrypt(ses->password, ses->server->cryptkey,\r\nses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);\r\nif (rc) {\r\ncFYI(1, "%s Can't generate NTLM response, error: %d",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nrc = E_md4hash(ses->password, temp_key, nls_cp);\r\nif (rc) {\r\ncFYI(1, "%s Can't generate NT hash, error: %d", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);\r\nif (rc)\r\ncFYI(1, "%s Can't generate NTLM session key, error: %d",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nint calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\r\nchar *lnm_session_key)\r\n{\r\nint i;\r\nint rc;\r\nchar password_with_pad[CIFS_ENCPWD_SIZE];\r\nmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\r\nif (password)\r\nstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\r\nif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\r\nmemset(lnm_session_key, 0, CIFS_SESS_KEY_SIZE);\r\nmemcpy(lnm_session_key, password_with_pad,\r\nCIFS_ENCPWD_SIZE);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\r\npassword_with_pad[i] = toupper(password_with_pad[i]);\r\nrc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\r\nreturn rc;\r\n}\r\nstatic int\r\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nunsigned int dlen;\r\nunsigned int size = 2 * sizeof(struct ntlmssp2_name);\r\nchar *defdmname = "WORKGROUP";\r\nunsigned char *blobptr;\r\nstruct ntlmssp2_name *attrptr;\r\nif (!ses->domainName) {\r\nses->domainName = kstrdup(defdmname, GFP_KERNEL);\r\nif (!ses->domainName)\r\nreturn -ENOMEM;\r\n}\r\ndlen = strlen(ses->domainName);\r\nses->auth_key.len = size + 2 * dlen;\r\nses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\nses->auth_key.len = 0;\r\ncERROR(1, "Challenge target info allocation failure");\r\nreturn -ENOMEM;\r\n}\r\nblobptr = ses->auth_key.response;\r\nattrptr = (struct ntlmssp2_name *) blobptr;\r\nattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\r\nattrptr->length = cpu_to_le16(2 * dlen);\r\nblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\r\ncifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\r\nreturn 0;\r\n}\r\nstatic int\r\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nunsigned int attrsize;\r\nunsigned int type;\r\nunsigned int onesize = sizeof(struct ntlmssp2_name);\r\nunsigned char *blobptr;\r\nunsigned char *blobend;\r\nstruct ntlmssp2_name *attrptr;\r\nif (!ses->auth_key.len || !ses->auth_key.response)\r\nreturn 0;\r\nblobptr = ses->auth_key.response;\r\nblobend = blobptr + ses->auth_key.len;\r\nwhile (blobptr + onesize < blobend) {\r\nattrptr = (struct ntlmssp2_name *) blobptr;\r\ntype = le16_to_cpu(attrptr->type);\r\nif (type == NTLMSSP_AV_EOL)\r\nbreak;\r\nblobptr += 2;\r\nattrsize = le16_to_cpu(attrptr->length);\r\nblobptr += 2;\r\nif (blobptr + attrsize > blobend)\r\nbreak;\r\nif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\r\nif (!attrsize)\r\nbreak;\r\nif (!ses->domainName) {\r\nses->domainName =\r\nkmalloc(attrsize + 1, GFP_KERNEL);\r\nif (!ses->domainName)\r\nreturn -ENOMEM;\r\ncifs_from_utf16(ses->domainName,\r\n(__le16 *)blobptr, attrsize, attrsize,\r\nnls_cp, false);\r\nbreak;\r\n}\r\n}\r\nblobptr += attrsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\r\nconst struct nls_table *nls_cp)\r\n{\r\nint rc = 0;\r\nint len;\r\nchar nt_hash[CIFS_NTHASH_SIZE];\r\nwchar_t *user;\r\nwchar_t *domain;\r\nwchar_t *server;\r\nif (!ses->server->secmech.sdeschmacmd5) {\r\ncERROR(1, "calc_ntlmv2_hash: can't generate ntlmv2 hash");\r\nreturn -1;\r\n}\r\nE_md4hash(ses->password, nt_hash, nls_cp);\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,\r\nCIFS_NTHASH_SIZE);\r\nif (rc) {\r\ncERROR(1, "%s: Could not set NT Hash as a key", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\r\nif (rc) {\r\ncERROR(1, "calc_ntlmv2_hash: could not init hmacmd5");\r\nreturn rc;\r\n}\r\nlen = ses->user_name ? strlen(ses->user_name) : 0;\r\nuser = kmalloc(2 + (len * 2), GFP_KERNEL);\r\nif (user == NULL) {\r\ncERROR(1, "calc_ntlmv2_hash: user mem alloc failure");\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nif (len) {\r\nlen = cifs_strtoUTF16((__le16 *)user, ses->user_name, len, nls_cp);\r\nUniStrupr(user);\r\n} else {\r\nmemset(user, '\0', 2);\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\n(char *)user, 2 * len);\r\nkfree(user);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with user", __func__);\r\nreturn rc;\r\n}\r\nif (ses->domainName) {\r\nlen = strlen(ses->domainName);\r\ndomain = kmalloc(2 + (len * 2), GFP_KERNEL);\r\nif (domain == NULL) {\r\ncERROR(1, "calc_ntlmv2_hash: domain mem alloc failure");\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\r\nnls_cp);\r\nrc =\r\ncrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\n(char *)domain, 2 * len);\r\nkfree(domain);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with domain",\r\n__func__);\r\nreturn rc;\r\n}\r\n} else if (ses->serverName) {\r\nlen = strlen(ses->serverName);\r\nserver = kmalloc(2 + (len * 2), GFP_KERNEL);\r\nif (server == NULL) {\r\ncERROR(1, "calc_ntlmv2_hash: server mem alloc failure");\r\nrc = -ENOMEM;\r\nreturn rc;\r\n}\r\nlen = cifs_strtoUTF16((__le16 *)server, ses->serverName, len,\r\nnls_cp);\r\nrc =\r\ncrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\n(char *)server, 2 * len);\r\nkfree(server);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with server",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\r\nntlmv2_hash);\r\nif (rc)\r\ncERROR(1, "%s: Could not generate md5 hash", __func__);\r\nreturn rc;\r\n}\r\nstatic int\r\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\r\n{\r\nint rc;\r\nunsigned int offset = CIFS_SESS_KEY_SIZE + 8;\r\nif (!ses->server->secmech.sdeschmacmd5) {\r\ncERROR(1, "calc_ntlmv2_hash: can't generate ntlmv2 hash");\r\nreturn -1;\r\n}\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\r\nntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\r\nif (rc) {\r\ncERROR(1, "%s: Could not set NTLMV2 Hash as a key", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\r\nif (rc) {\r\ncERROR(1, "CalcNTLMv2_response: could not init hmacmd5");\r\nreturn rc;\r\n}\r\nif (ses->server->secType == RawNTLMSSP)\r\nmemcpy(ses->auth_key.response + offset,\r\nses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\r\nelse\r\nmemcpy(ses->auth_key.response + offset,\r\nses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\nses->auth_key.response + offset, ses->auth_key.len - offset);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with response", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\r\nses->auth_key.response + CIFS_SESS_KEY_SIZE);\r\nif (rc)\r\ncERROR(1, "%s: Could not generate md5 hash", __func__);\r\nreturn rc;\r\n}\r\nint\r\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\r\n{\r\nint rc;\r\nint baselen;\r\nunsigned int tilen;\r\nstruct ntlmv2_resp *buf;\r\nchar ntlmv2_hash[16];\r\nunsigned char *tiblob = NULL;\r\nif (ses->server->secType == RawNTLMSSP) {\r\nif (!ses->domainName) {\r\nrc = find_domain_name(ses, nls_cp);\r\nif (rc) {\r\ncERROR(1, "error %d finding domain name", rc);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\n}\r\n} else {\r\nrc = build_avpair_blob(ses, nls_cp);\r\nif (rc) {\r\ncERROR(1, "error %d building av pair blob", rc);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\n}\r\nbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\r\ntilen = ses->auth_key.len;\r\ntiblob = ses->auth_key.response;\r\nses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\r\nif (!ses->auth_key.response) {\r\nrc = ENOMEM;\r\nses->auth_key.len = 0;\r\ncERROR(1, "%s: Can't allocate auth blob", __func__);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nses->auth_key.len += baselen;\r\nbuf = (struct ntlmv2_resp *)\r\n(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\r\nbuf->blob_signature = cpu_to_le32(0x00000101);\r\nbuf->reserved = 0;\r\nbuf->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\r\nget_random_bytes(&buf->client_chal, sizeof(buf->client_chal));\r\nbuf->reserved2 = 0;\r\nmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\r\nrc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\r\nif (rc) {\r\ncERROR(1, "could not get v2 hash rc %d", rc);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nrc = CalcNTLMv2_response(ses, ntlmv2_hash);\r\nif (rc) {\r\ncERROR(1, "Could not calculate CR1 rc: %d", rc);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nrc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\r\nntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\r\nif (rc) {\r\ncERROR(1, "%s: Could not set NTLMV2 Hash as a key", __func__);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nrc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\r\nif (rc) {\r\ncERROR(1, "%s: Could not init hmacmd5", __func__);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nrc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\r\nses->auth_key.response + CIFS_SESS_KEY_SIZE,\r\nCIFS_HMAC_MD5_HASH_SIZE);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with response", __func__);\r\ngoto setup_ntlmv2_rsp_ret;\r\n}\r\nrc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\r\nses->auth_key.response);\r\nif (rc)\r\ncERROR(1, "%s: Could not generate md5 hash", __func__);\r\nsetup_ntlmv2_rsp_ret:\r\nkfree(tiblob);\r\nreturn rc;\r\n}\r\nint\r\ncalc_seckey(struct cifs_ses *ses)\r\n{\r\nint rc;\r\nstruct crypto_blkcipher *tfm_arc4;\r\nstruct scatterlist sgin, sgout;\r\nstruct blkcipher_desc desc;\r\nunsigned char sec_key[CIFS_SESS_KEY_SIZE];\r\nget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\r\ntfm_arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm_arc4)) {\r\nrc = PTR_ERR(tfm_arc4);\r\ncERROR(1, "could not allocate crypto API arc4");\r\nreturn rc;\r\n}\r\ndesc.tfm = tfm_arc4;\r\nrc = crypto_blkcipher_setkey(tfm_arc4, ses->auth_key.response,\r\nCIFS_SESS_KEY_SIZE);\r\nif (rc) {\r\ncERROR(1, "%s: Could not set response as a key", __func__);\r\nreturn rc;\r\n}\r\nsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\r\nsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\r\nrc = crypto_blkcipher_encrypt(&desc, &sgout, &sgin, CIFS_CPHTXT_SIZE);\r\nif (rc) {\r\ncERROR(1, "could not encrypt session key rc: %d", rc);\r\ncrypto_free_blkcipher(tfm_arc4);\r\nreturn rc;\r\n}\r\nmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\r\nses->auth_key.len = CIFS_SESS_KEY_SIZE;\r\ncrypto_free_blkcipher(tfm_arc4);\r\nreturn rc;\r\n}\r\nvoid\r\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\r\n{\r\nif (server->secmech.hmacsha256)\r\ncrypto_free_shash(server->secmech.hmacsha256);\r\nif (server->secmech.md5)\r\ncrypto_free_shash(server->secmech.md5);\r\nif (server->secmech.hmacmd5)\r\ncrypto_free_shash(server->secmech.hmacmd5);\r\nkfree(server->secmech.sdeschmacsha256);\r\nkfree(server->secmech.sdeschmacmd5);\r\nkfree(server->secmech.sdescmd5);\r\n}\r\nint\r\ncifs_crypto_shash_allocate(struct TCP_Server_Info *server)\r\n{\r\nint rc;\r\nunsigned int size;\r\nserver->secmech.hmacmd5 = crypto_alloc_shash("hmac(md5)", 0, 0);\r\nif (IS_ERR(server->secmech.hmacmd5)) {\r\ncERROR(1, "could not allocate crypto hmacmd5");\r\nreturn PTR_ERR(server->secmech.hmacmd5);\r\n}\r\nserver->secmech.md5 = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(server->secmech.md5)) {\r\ncERROR(1, "could not allocate crypto md5");\r\nrc = PTR_ERR(server->secmech.md5);\r\ngoto crypto_allocate_md5_fail;\r\n}\r\nserver->secmech.hmacsha256 = crypto_alloc_shash("hmac(sha256)", 0, 0);\r\nif (IS_ERR(server->secmech.hmacsha256)) {\r\ncERROR(1, "could not allocate crypto hmacsha256\n");\r\nrc = PTR_ERR(server->secmech.hmacsha256);\r\ngoto crypto_allocate_hmacsha256_fail;\r\n}\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.hmacmd5);\r\nserver->secmech.sdeschmacmd5 = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdeschmacmd5) {\r\ncERROR(1, "cifs_crypto_shash_allocate: can't alloc hmacmd5");\r\nrc = -ENOMEM;\r\ngoto crypto_allocate_hmacmd5_sdesc_fail;\r\n}\r\nserver->secmech.sdeschmacmd5->shash.tfm = server->secmech.hmacmd5;\r\nserver->secmech.sdeschmacmd5->shash.flags = 0x0;\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.md5);\r\nserver->secmech.sdescmd5 = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdescmd5) {\r\ncERROR(1, "cifs_crypto_shash_allocate: can't alloc md5");\r\nrc = -ENOMEM;\r\ngoto crypto_allocate_md5_sdesc_fail;\r\n}\r\nserver->secmech.sdescmd5->shash.tfm = server->secmech.md5;\r\nserver->secmech.sdescmd5->shash.flags = 0x0;\r\nsize = sizeof(struct shash_desc) +\r\ncrypto_shash_descsize(server->secmech.hmacsha256);\r\nserver->secmech.sdeschmacsha256 = kmalloc(size, GFP_KERNEL);\r\nif (!server->secmech.sdeschmacsha256) {\r\ncERROR(1, "%s: Can't alloc hmacsha256\n", __func__);\r\nrc = -ENOMEM;\r\ngoto crypto_allocate_hmacsha256_sdesc_fail;\r\n}\r\nserver->secmech.sdeschmacsha256->shash.tfm = server->secmech.hmacsha256;\r\nserver->secmech.sdeschmacsha256->shash.flags = 0x0;\r\nreturn 0;\r\ncrypto_allocate_hmacsha256_sdesc_fail:\r\nkfree(server->secmech.sdescmd5);\r\ncrypto_allocate_md5_sdesc_fail:\r\nkfree(server->secmech.sdeschmacmd5);\r\ncrypto_allocate_hmacmd5_sdesc_fail:\r\ncrypto_free_shash(server->secmech.hmacsha256);\r\ncrypto_allocate_hmacsha256_fail:\r\ncrypto_free_shash(server->secmech.md5);\r\ncrypto_allocate_md5_fail:\r\ncrypto_free_shash(server->secmech.hmacmd5);\r\nreturn rc;\r\n}
