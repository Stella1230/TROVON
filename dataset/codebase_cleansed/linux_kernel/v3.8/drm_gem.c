int\r\ndrm_gem_init(struct drm_device *dev)\r\n{\r\nstruct drm_gem_mm *mm;\r\nspin_lock_init(&dev->object_name_lock);\r\nidr_init(&dev->object_name_idr);\r\nmm = kzalloc(sizeof(struct drm_gem_mm), GFP_KERNEL);\r\nif (!mm) {\r\nDRM_ERROR("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->mm_private = mm;\r\nif (drm_ht_create(&mm->offset_hash, 12)) {\r\nkfree(mm);\r\nreturn -ENOMEM;\r\n}\r\nif (drm_mm_init(&mm->offset_manager, DRM_FILE_PAGE_OFFSET_START,\r\nDRM_FILE_PAGE_OFFSET_SIZE)) {\r\ndrm_ht_remove(&mm->offset_hash);\r\nkfree(mm);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\ndrm_gem_destroy(struct drm_device *dev)\r\n{\r\nstruct drm_gem_mm *mm = dev->mm_private;\r\ndrm_mm_takedown(&mm->offset_manager);\r\ndrm_ht_remove(&mm->offset_hash);\r\nkfree(mm);\r\ndev->mm_private = NULL;\r\n}\r\nint drm_gem_object_init(struct drm_device *dev,\r\nstruct drm_gem_object *obj, size_t size)\r\n{\r\nBUG_ON((size & (PAGE_SIZE - 1)) != 0);\r\nobj->dev = dev;\r\nobj->filp = shmem_file_setup("drm mm object", size, VM_NORESERVE);\r\nif (IS_ERR(obj->filp))\r\nreturn PTR_ERR(obj->filp);\r\nkref_init(&obj->refcount);\r\natomic_set(&obj->handle_count, 0);\r\nobj->size = size;\r\nreturn 0;\r\n}\r\nint drm_gem_private_object_init(struct drm_device *dev,\r\nstruct drm_gem_object *obj, size_t size)\r\n{\r\nBUG_ON((size & (PAGE_SIZE - 1)) != 0);\r\nobj->dev = dev;\r\nobj->filp = NULL;\r\nkref_init(&obj->refcount);\r\natomic_set(&obj->handle_count, 0);\r\nobj->size = size;\r\nreturn 0;\r\n}\r\nstruct drm_gem_object *\r\ndrm_gem_object_alloc(struct drm_device *dev, size_t size)\r\n{\r\nstruct drm_gem_object *obj;\r\nobj = kzalloc(sizeof(*obj), GFP_KERNEL);\r\nif (!obj)\r\ngoto free;\r\nif (drm_gem_object_init(dev, obj, size) != 0)\r\ngoto free;\r\nif (dev->driver->gem_init_object != NULL &&\r\ndev->driver->gem_init_object(obj) != 0) {\r\ngoto fput;\r\n}\r\nreturn obj;\r\nfput:\r\nfput(obj->filp);\r\nfree:\r\nkfree(obj);\r\nreturn NULL;\r\n}\r\nstatic void\r\ndrm_gem_remove_prime_handles(struct drm_gem_object *obj, struct drm_file *filp)\r\n{\r\nif (obj->import_attach) {\r\ndrm_prime_remove_imported_buf_handle(&filp->prime,\r\nobj->import_attach->dmabuf);\r\n}\r\nif (obj->export_dma_buf) {\r\ndrm_prime_remove_imported_buf_handle(&filp->prime,\r\nobj->export_dma_buf);\r\n}\r\n}\r\nint\r\ndrm_gem_handle_delete(struct drm_file *filp, u32 handle)\r\n{\r\nstruct drm_device *dev;\r\nstruct drm_gem_object *obj;\r\nspin_lock(&filp->table_lock);\r\nobj = idr_find(&filp->object_idr, handle);\r\nif (obj == NULL) {\r\nspin_unlock(&filp->table_lock);\r\nreturn -EINVAL;\r\n}\r\ndev = obj->dev;\r\nidr_remove(&filp->object_idr, handle);\r\nspin_unlock(&filp->table_lock);\r\ndrm_gem_remove_prime_handles(obj, filp);\r\nif (dev->driver->gem_close_object)\r\ndev->driver->gem_close_object(obj, filp);\r\ndrm_gem_object_handle_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nint\r\ndrm_gem_handle_create(struct drm_file *file_priv,\r\nstruct drm_gem_object *obj,\r\nu32 *handlep)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nint ret;\r\nagain:\r\nif (idr_pre_get(&file_priv->object_idr, GFP_KERNEL) == 0)\r\nreturn -ENOMEM;\r\nspin_lock(&file_priv->table_lock);\r\nret = idr_get_new_above(&file_priv->object_idr, obj, 1, (int *)handlep);\r\nspin_unlock(&file_priv->table_lock);\r\nif (ret == -EAGAIN)\r\ngoto again;\r\nelse if (ret)\r\nreturn ret;\r\ndrm_gem_object_handle_reference(obj);\r\nif (dev->driver->gem_open_object) {\r\nret = dev->driver->gem_open_object(obj, file_priv);\r\nif (ret) {\r\ndrm_gem_handle_delete(file_priv, *handlep);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\ndrm_gem_free_mmap_offset(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct drm_gem_mm *mm = dev->mm_private;\r\nstruct drm_map_list *list = &obj->map_list;\r\ndrm_ht_remove_item(&mm->offset_hash, &list->hash);\r\ndrm_mm_put_block(list->file_offset_node);\r\nkfree(list->map);\r\nlist->map = NULL;\r\n}\r\nint\r\ndrm_gem_create_mmap_offset(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct drm_gem_mm *mm = dev->mm_private;\r\nstruct drm_map_list *list;\r\nstruct drm_local_map *map;\r\nint ret;\r\nlist = &obj->map_list;\r\nlist->map = kzalloc(sizeof(struct drm_map_list), GFP_KERNEL);\r\nif (!list->map)\r\nreturn -ENOMEM;\r\nmap = list->map;\r\nmap->type = _DRM_GEM;\r\nmap->size = obj->size;\r\nmap->handle = obj;\r\nlist->file_offset_node = drm_mm_search_free(&mm->offset_manager,\r\nobj->size / PAGE_SIZE, 0, false);\r\nif (!list->file_offset_node) {\r\nDRM_ERROR("failed to allocate offset for bo %d\n", obj->name);\r\nret = -ENOSPC;\r\ngoto out_free_list;\r\n}\r\nlist->file_offset_node = drm_mm_get_block(list->file_offset_node,\r\nobj->size / PAGE_SIZE, 0);\r\nif (!list->file_offset_node) {\r\nret = -ENOMEM;\r\ngoto out_free_list;\r\n}\r\nlist->hash.key = list->file_offset_node->start;\r\nret = drm_ht_insert_item(&mm->offset_hash, &list->hash);\r\nif (ret) {\r\nDRM_ERROR("failed to add to map hash\n");\r\ngoto out_free_mm;\r\n}\r\nreturn 0;\r\nout_free_mm:\r\ndrm_mm_put_block(list->file_offset_node);\r\nout_free_list:\r\nkfree(list->map);\r\nlist->map = NULL;\r\nreturn ret;\r\n}\r\nstruct drm_gem_object *\r\ndrm_gem_object_lookup(struct drm_device *dev, struct drm_file *filp,\r\nu32 handle)\r\n{\r\nstruct drm_gem_object *obj;\r\nspin_lock(&filp->table_lock);\r\nobj = idr_find(&filp->object_idr, handle);\r\nif (obj == NULL) {\r\nspin_unlock(&filp->table_lock);\r\nreturn NULL;\r\n}\r\ndrm_gem_object_reference(obj);\r\nspin_unlock(&filp->table_lock);\r\nreturn obj;\r\n}\r\nint\r\ndrm_gem_close_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_gem_close *args = data;\r\nint ret;\r\nif (!(dev->driver->driver_features & DRIVER_GEM))\r\nreturn -ENODEV;\r\nret = drm_gem_handle_delete(file_priv, args->handle);\r\nreturn ret;\r\n}\r\nint\r\ndrm_gem_flink_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_gem_flink *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nif (!(dev->driver->driver_features & DRIVER_GEM))\r\nreturn -ENODEV;\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (obj == NULL)\r\nreturn -ENOENT;\r\nagain:\r\nif (idr_pre_get(&dev->object_name_idr, GFP_KERNEL) == 0) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nspin_lock(&dev->object_name_lock);\r\nif (!obj->name) {\r\nret = idr_get_new_above(&dev->object_name_idr, obj, 1,\r\n&obj->name);\r\nargs->name = (uint64_t) obj->name;\r\nspin_unlock(&dev->object_name_lock);\r\nif (ret == -EAGAIN)\r\ngoto again;\r\nelse if (ret)\r\ngoto err;\r\ndrm_gem_object_reference(obj);\r\n} else {\r\nargs->name = (uint64_t) obj->name;\r\nspin_unlock(&dev->object_name_lock);\r\nret = 0;\r\n}\r\nerr:\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nint\r\ndrm_gem_open_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_gem_open *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nu32 handle;\r\nif (!(dev->driver->driver_features & DRIVER_GEM))\r\nreturn -ENODEV;\r\nspin_lock(&dev->object_name_lock);\r\nobj = idr_find(&dev->object_name_idr, (int) args->name);\r\nif (obj)\r\ndrm_gem_object_reference(obj);\r\nspin_unlock(&dev->object_name_lock);\r\nif (!obj)\r\nreturn -ENOENT;\r\nret = drm_gem_handle_create(file_priv, obj, &handle);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nargs->size = obj->size;\r\nreturn 0;\r\n}\r\nvoid\r\ndrm_gem_open(struct drm_device *dev, struct drm_file *file_private)\r\n{\r\nidr_init(&file_private->object_idr);\r\nspin_lock_init(&file_private->table_lock);\r\n}\r\nstatic int\r\ndrm_gem_object_release_handle(int id, void *ptr, void *data)\r\n{\r\nstruct drm_file *file_priv = data;\r\nstruct drm_gem_object *obj = ptr;\r\nstruct drm_device *dev = obj->dev;\r\ndrm_gem_remove_prime_handles(obj, file_priv);\r\nif (dev->driver->gem_close_object)\r\ndev->driver->gem_close_object(obj, file_priv);\r\ndrm_gem_object_handle_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nvoid\r\ndrm_gem_release(struct drm_device *dev, struct drm_file *file_private)\r\n{\r\nidr_for_each(&file_private->object_idr,\r\n&drm_gem_object_release_handle, file_private);\r\nidr_remove_all(&file_private->object_idr);\r\nidr_destroy(&file_private->object_idr);\r\n}\r\nvoid\r\ndrm_gem_object_release(struct drm_gem_object *obj)\r\n{\r\nif (obj->filp)\r\nfput(obj->filp);\r\n}\r\nvoid\r\ndrm_gem_object_free(struct kref *kref)\r\n{\r\nstruct drm_gem_object *obj = (struct drm_gem_object *) kref;\r\nstruct drm_device *dev = obj->dev;\r\nBUG_ON(!mutex_is_locked(&dev->struct_mutex));\r\nif (dev->driver->gem_free_object != NULL)\r\ndev->driver->gem_free_object(obj);\r\n}\r\nstatic void drm_gem_object_ref_bug(struct kref *list_kref)\r\n{\r\nBUG();\r\n}\r\nvoid drm_gem_object_handle_free(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nspin_lock(&dev->object_name_lock);\r\nif (obj->name) {\r\nidr_remove(&dev->object_name_idr, obj->name);\r\nobj->name = 0;\r\nspin_unlock(&dev->object_name_lock);\r\nkref_put(&obj->refcount, drm_gem_object_ref_bug);\r\n} else\r\nspin_unlock(&dev->object_name_lock);\r\n}\r\nvoid drm_gem_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *obj = vma->vm_private_data;\r\ndrm_gem_object_reference(obj);\r\nmutex_lock(&obj->dev->struct_mutex);\r\ndrm_vm_open_locked(obj->dev, vma);\r\nmutex_unlock(&obj->dev->struct_mutex);\r\n}\r\nvoid drm_gem_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *obj = vma->vm_private_data;\r\nstruct drm_device *dev = obj->dev;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_vm_close_locked(obj->dev, vma);\r\ndrm_gem_object_unreference(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nint drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = filp->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nstruct drm_gem_mm *mm = dev->mm_private;\r\nstruct drm_local_map *map = NULL;\r\nstruct drm_gem_object *obj;\r\nstruct drm_hash_item *hash;\r\nint ret = 0;\r\nif (drm_device_is_unplugged(dev))\r\nreturn -ENODEV;\r\nmutex_lock(&dev->struct_mutex);\r\nif (drm_ht_find_item(&mm->offset_hash, vma->vm_pgoff, &hash)) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn drm_mmap(filp, vma);\r\n}\r\nmap = drm_hash_entry(hash, struct drm_map_list, hash)->map;\r\nif (!map ||\r\n((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN))) {\r\nret = -EPERM;\r\ngoto out_unlock;\r\n}\r\nif (map->size < vma->vm_end - vma->vm_start) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nobj = map->handle;\r\nif (!obj->dev->driver->gem_vm_ops) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_ops = obj->dev->driver->gem_vm_ops;\r\nvma->vm_private_data = map->handle;\r\nvma->vm_page_prot = pgprot_writecombine(vm_get_page_prot(vma->vm_flags));\r\ndrm_gem_object_reference(obj);\r\ndrm_vm_open_locked(dev, vma);\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
