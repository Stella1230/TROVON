static unsigned long div2_recalc(struct clk *clk)\r\n{\r\nreturn clk->parent->rate / 2;\r\n}\r\nstatic unsigned long div7_recalc(struct clk *clk)\r\n{\r\nreturn clk->parent->rate / 7;\r\n}\r\nstatic unsigned long div13_recalc(struct clk *clk)\r\n{\r\nreturn clk->parent->rate / 13;\r\n}\r\nstatic unsigned long pll_recalc(struct clk *clk)\r\n{\r\nunsigned long mult = 1;\r\nif (__raw_readl(PLLECR) & (1 << clk->enable_bit)) {\r\nmult = (((__raw_readl(clk->enable_reg) >> 24) & 0x3f) + 1);\r\nswitch (clk->enable_bit) {\r\ncase 1:\r\ncase 2:\r\nif (__raw_readl(clk->enable_reg) & (1 << 20))\r\nmult *= 2;\r\n}\r\n}\r\nreturn clk->parent->rate * mult;\r\n}\r\nstatic void div4_kick(struct clk *clk)\r\n{\r\nunsigned long value;\r\nvalue = __raw_readl(FRQCRB);\r\nvalue |= (1 << 31);\r\n__raw_writel(value, FRQCRB);\r\n}\r\nstatic unsigned long dsiphy_recalc(struct clk *clk)\r\n{\r\nu32 value;\r\nvalue = __raw_readl(clk->mapping->base);\r\nif (!(value & 0x000B8000))\r\nreturn clk->parent->rate;\r\nvalue &= 0x3f;\r\nvalue += 1;\r\nif ((value < 12) ||\r\n(value > 33)) {\r\npr_err("DSIPHY has wrong value (%d)", value);\r\nreturn 0;\r\n}\r\nreturn clk->parent->rate / value;\r\n}\r\nstatic long dsiphy_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk_rate_mult_range_round(clk, 12, 33, rate);\r\n}\r\nstatic void dsiphy_disable(struct clk *clk)\r\n{\r\nu32 value;\r\nvalue = __raw_readl(clk->mapping->base);\r\nvalue &= ~0x000B8000;\r\n__raw_writel(value , clk->mapping->base);\r\n}\r\nstatic int dsiphy_enable(struct clk *clk)\r\n{\r\nu32 value;\r\nint multi;\r\nvalue = __raw_readl(clk->mapping->base);\r\nmulti = (value & 0x3f) + 1;\r\nif ((multi < 12) || (multi > 33))\r\nreturn -EIO;\r\n__raw_writel(value | 0x000B8000, clk->mapping->base);\r\nreturn 0;\r\n}\r\nstatic int dsiphy_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 value;\r\nint idx;\r\nidx = rate / clk->parent->rate;\r\nif ((idx < 12) || (idx > 33))\r\nreturn -EINVAL;\r\nidx += -1;\r\nvalue = __raw_readl(clk->mapping->base);\r\nvalue = (value & ~0x3f) + idx;\r\n__raw_writel(value, clk->mapping->base);\r\nreturn 0;\r\n}\r\nvoid __init sh73a0_clock_init(void)\r\n{\r\nint k, ret = 0;\r\n__raw_writel(0x108, SD0CKCR);\r\n__raw_writel(0x108, SD1CKCR);\r\n__raw_writel(0x108, SD2CKCR);\r\nswitch ((__raw_readl(CKSCR) >> 28) & 0x03) {\r\ncase 0:\r\nmain_clk.parent = &sh73a0_extal1_clk;\r\nbreak;\r\ncase 1:\r\nmain_clk.parent = &extal1_div2_clk;\r\nbreak;\r\ncase 2:\r\nmain_clk.parent = &sh73a0_extal2_clk;\r\nbreak;\r\ncase 3:\r\nmain_clk.parent = &extal2_div2_clk;\r\nbreak;\r\n}\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)\r\nret = clk_register(main_clks[k]);\r\nif (!ret)\r\nret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);\r\nif (!ret)\r\nret = sh_clk_div6_reparent_register(div6_clks, DIV6_NR);\r\nif (!ret)\r\nret = sh_clk_mstp_register(mstp_clks, MSTP_NR);\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(late_main_clks)); k++)\r\nret = clk_register(late_main_clks[k]);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nif (!ret)\r\nshmobile_clk_init();\r\nelse\r\npanic("failed to setup sh73a0 clocks\n");\r\n}
