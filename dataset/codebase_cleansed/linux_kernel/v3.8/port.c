void mlx4_init_mac_table(struct mlx4_dev *dev, struct mlx4_mac_table *table)\r\n{\r\nint i;\r\nmutex_init(&table->mutex);\r\nfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\r\ntable->entries[i] = 0;\r\ntable->refs[i] = 0;\r\n}\r\ntable->max = 1 << dev->caps.log_num_macs;\r\ntable->total = 0;\r\n}\r\nvoid mlx4_init_vlan_table(struct mlx4_dev *dev, struct mlx4_vlan_table *table)\r\n{\r\nint i;\r\nmutex_init(&table->mutex);\r\nfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\r\ntable->entries[i] = 0;\r\ntable->refs[i] = 0;\r\n}\r\ntable->max = (1 << dev->caps.log_num_vlans) - MLX4_VLAN_REGULAR;\r\ntable->total = 0;\r\n}\r\nstatic int mlx4_uc_steer_add(struct mlx4_dev *dev, u8 port,\r\nu64 mac, int *qpn, u64 *reg_id)\r\n{\r\n__be64 be_mac;\r\nint err;\r\nmac &= MLX4_MAC_MASK;\r\nbe_mac = cpu_to_be64(mac << 16);\r\nswitch (dev->caps.steering_mode) {\r\ncase MLX4_STEERING_MODE_B0: {\r\nstruct mlx4_qp qp;\r\nu8 gid[16] = {0};\r\nqp.qpn = *qpn;\r\nmemcpy(&gid[10], &be_mac, ETH_ALEN);\r\ngid[5] = port;\r\nerr = mlx4_unicast_attach(dev, &qp, gid, 0, MLX4_PROT_ETH);\r\nbreak;\r\n}\r\ncase MLX4_STEERING_MODE_DEVICE_MANAGED: {\r\nstruct mlx4_spec_list spec_eth = { {NULL} };\r\n__be64 mac_mask = cpu_to_be64(MLX4_MAC_MASK << 16);\r\nstruct mlx4_net_trans_rule rule = {\r\n.queue_mode = MLX4_NET_TRANS_Q_FIFO,\r\n.exclusive = 0,\r\n.allow_loopback = 1,\r\n.promisc_mode = MLX4_FS_PROMISC_NONE,\r\n.priority = MLX4_DOMAIN_NIC,\r\n};\r\nrule.port = port;\r\nrule.qpn = *qpn;\r\nINIT_LIST_HEAD(&rule.list);\r\nspec_eth.id = MLX4_NET_TRANS_RULE_ID_ETH;\r\nmemcpy(spec_eth.eth.dst_mac, &be_mac, ETH_ALEN);\r\nmemcpy(spec_eth.eth.dst_mac_msk, &mac_mask, ETH_ALEN);\r\nlist_add_tail(&spec_eth.list, &rule.list);\r\nerr = mlx4_flow_attach(dev, &rule, reg_id);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err)\r\nmlx4_warn(dev, "Failed Attaching Unicast\n");\r\nreturn err;\r\n}\r\nstatic void mlx4_uc_steer_release(struct mlx4_dev *dev, u8 port,\r\nu64 mac, int qpn, u64 reg_id)\r\n{\r\nswitch (dev->caps.steering_mode) {\r\ncase MLX4_STEERING_MODE_B0: {\r\nstruct mlx4_qp qp;\r\nu8 gid[16] = {0};\r\n__be64 be_mac;\r\nqp.qpn = qpn;\r\nmac &= MLX4_MAC_MASK;\r\nbe_mac = cpu_to_be64(mac << 16);\r\nmemcpy(&gid[10], &be_mac, ETH_ALEN);\r\ngid[5] = port;\r\nmlx4_unicast_detach(dev, &qp, gid, MLX4_PROT_ETH);\r\nbreak;\r\n}\r\ncase MLX4_STEERING_MODE_DEVICE_MANAGED: {\r\nmlx4_flow_detach(dev, reg_id);\r\nbreak;\r\n}\r\ndefault:\r\nmlx4_err(dev, "Invalid steering mode.\n");\r\n}\r\n}\r\nstatic int validate_index(struct mlx4_dev *dev,\r\nstruct mlx4_mac_table *table, int index)\r\n{\r\nint err = 0;\r\nif (index < 0 || index >= table->max || !table->entries[index]) {\r\nmlx4_warn(dev, "No valid Mac entry for the given index\n");\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int find_index(struct mlx4_dev *dev,\r\nstruct mlx4_mac_table *table, u64 mac)\r\n{\r\nint i;\r\nfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\r\nif ((mac & MLX4_MAC_MASK) ==\r\n(MLX4_MAC_MASK & be64_to_cpu(table->entries[i])))\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint mlx4_get_eth_qp(struct mlx4_dev *dev, u8 port, u64 mac, int *qpn)\r\n{\r\nstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\r\nstruct mlx4_mac_entry *entry;\r\nint index = 0;\r\nint err = 0;\r\nu64 reg_id;\r\nmlx4_dbg(dev, "Registering MAC: 0x%llx for adding\n",\r\n(unsigned long long) mac);\r\nindex = mlx4_register_mac(dev, port, mac);\r\nif (index < 0) {\r\nerr = index;\r\nmlx4_err(dev, "Failed adding MAC: 0x%llx\n",\r\n(unsigned long long) mac);\r\nreturn err;\r\n}\r\nif (dev->caps.steering_mode == MLX4_STEERING_MODE_A0) {\r\n*qpn = info->base_qpn + index;\r\nreturn 0;\r\n}\r\nerr = mlx4_qp_reserve_range(dev, 1, 1, qpn);\r\nmlx4_dbg(dev, "Reserved qp %d\n", *qpn);\r\nif (err) {\r\nmlx4_err(dev, "Failed to reserve qp for mac registration\n");\r\ngoto qp_err;\r\n}\r\nerr = mlx4_uc_steer_add(dev, port, mac, qpn, &reg_id);\r\nif (err)\r\ngoto steer_err;\r\nentry = kmalloc(sizeof *entry, GFP_KERNEL);\r\nif (!entry) {\r\nerr = -ENOMEM;\r\ngoto alloc_err;\r\n}\r\nentry->mac = mac;\r\nentry->reg_id = reg_id;\r\nerr = radix_tree_insert(&info->mac_tree, *qpn, entry);\r\nif (err)\r\ngoto insert_err;\r\nreturn 0;\r\ninsert_err:\r\nkfree(entry);\r\nalloc_err:\r\nmlx4_uc_steer_release(dev, port, mac, *qpn, reg_id);\r\nsteer_err:\r\nmlx4_qp_release_range(dev, *qpn, 1);\r\nqp_err:\r\nmlx4_unregister_mac(dev, port, mac);\r\nreturn err;\r\n}\r\nvoid mlx4_put_eth_qp(struct mlx4_dev *dev, u8 port, u64 mac, int qpn)\r\n{\r\nstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\r\nstruct mlx4_mac_entry *entry;\r\nmlx4_dbg(dev, "Registering MAC: 0x%llx for deleting\n",\r\n(unsigned long long) mac);\r\nmlx4_unregister_mac(dev, port, mac);\r\nif (dev->caps.steering_mode != MLX4_STEERING_MODE_A0) {\r\nentry = radix_tree_lookup(&info->mac_tree, qpn);\r\nif (entry) {\r\nmlx4_dbg(dev, "Releasing qp: port %d, mac 0x%llx,"\r\n" qpn %d\n", port,\r\n(unsigned long long) mac, qpn);\r\nmlx4_uc_steer_release(dev, port, entry->mac,\r\nqpn, entry->reg_id);\r\nmlx4_qp_release_range(dev, qpn, 1);\r\nradix_tree_delete(&info->mac_tree, qpn);\r\nkfree(entry);\r\n}\r\n}\r\n}\r\nstatic int mlx4_set_port_mac_table(struct mlx4_dev *dev, u8 port,\r\n__be64 *entries)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nu32 in_mod;\r\nint err;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmemcpy(mailbox->buf, entries, MLX4_MAC_TABLE_SIZE);\r\nin_mod = MLX4_SET_PORT_MAC_TABLE << 8 | port;\r\nerr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint __mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac)\r\n{\r\nstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\r\nstruct mlx4_mac_table *table = &info->mac_table;\r\nint i, err = 0;\r\nint free = -1;\r\nmlx4_dbg(dev, "Registering MAC: 0x%llx for port %d\n",\r\n(unsigned long long) mac, port);\r\nmutex_lock(&table->mutex);\r\nfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\r\nif (free < 0 && !table->entries[i]) {\r\nfree = i;\r\ncontinue;\r\n}\r\nif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nmlx4_dbg(dev, "Free MAC index is %d\n", free);\r\nif (table->total == table->max) {\r\nerr = -ENOSPC;\r\ngoto out;\r\n}\r\ntable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\r\nerr = mlx4_set_port_mac_table(dev, port, table->entries);\r\nif (unlikely(err)) {\r\nmlx4_err(dev, "Failed adding MAC: 0x%llx\n",\r\n(unsigned long long) mac);\r\ntable->entries[free] = 0;\r\ngoto out;\r\n}\r\nerr = free;\r\n++table->total;\r\nout:\r\nmutex_unlock(&table->mutex);\r\nreturn err;\r\n}\r\nint mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac)\r\n{\r\nu64 out_param;\r\nint err;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&out_param, port);\r\nerr = mlx4_cmd_imm(dev, mac, &out_param, RES_MAC,\r\nRES_OP_RESERVE_AND_MAP, MLX4_CMD_ALLOC_RES,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\r\nif (err)\r\nreturn err;\r\nreturn get_param_l(&out_param);\r\n}\r\nreturn __mlx4_register_mac(dev, port, mac);\r\n}\r\nvoid __mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, u64 mac)\r\n{\r\nstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\r\nstruct mlx4_mac_table *table = &info->mac_table;\r\nint index;\r\nindex = find_index(dev, table, mac);\r\nmutex_lock(&table->mutex);\r\nif (validate_index(dev, table, index))\r\ngoto out;\r\ntable->entries[index] = 0;\r\nmlx4_set_port_mac_table(dev, port, table->entries);\r\n--table->total;\r\nout:\r\nmutex_unlock(&table->mutex);\r\n}\r\nvoid mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, u64 mac)\r\n{\r\nu64 out_param;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&out_param, port);\r\n(void) mlx4_cmd_imm(dev, mac, &out_param, RES_MAC,\r\nRES_OP_RESERVE_AND_MAP, MLX4_CMD_FREE_RES,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\r\nreturn;\r\n}\r\n__mlx4_unregister_mac(dev, port, mac);\r\nreturn;\r\n}\r\nint mlx4_replace_mac(struct mlx4_dev *dev, u8 port, int qpn, u64 new_mac)\r\n{\r\nstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\r\nstruct mlx4_mac_table *table = &info->mac_table;\r\nstruct mlx4_mac_entry *entry;\r\nint index = qpn - info->base_qpn;\r\nint err = 0;\r\nif (dev->caps.steering_mode != MLX4_STEERING_MODE_A0) {\r\nentry = radix_tree_lookup(&info->mac_tree, qpn);\r\nif (!entry)\r\nreturn -EINVAL;\r\nmlx4_uc_steer_release(dev, port, entry->mac,\r\nqpn, entry->reg_id);\r\nmlx4_unregister_mac(dev, port, entry->mac);\r\nentry->mac = new_mac;\r\nentry->reg_id = 0;\r\nmlx4_register_mac(dev, port, new_mac);\r\nerr = mlx4_uc_steer_add(dev, port, entry->mac,\r\n&qpn, &entry->reg_id);\r\nreturn err;\r\n}\r\nmutex_lock(&table->mutex);\r\nerr = validate_index(dev, table, index);\r\nif (err)\r\ngoto out;\r\ntable->entries[index] = cpu_to_be64(new_mac | MLX4_MAC_VALID);\r\nerr = mlx4_set_port_mac_table(dev, port, table->entries);\r\nif (unlikely(err)) {\r\nmlx4_err(dev, "Failed adding MAC: 0x%llx\n",\r\n(unsigned long long) new_mac);\r\ntable->entries[index] = 0;\r\n}\r\nout:\r\nmutex_unlock(&table->mutex);\r\nreturn err;\r\n}\r\nstatic int mlx4_set_port_vlan_table(struct mlx4_dev *dev, u8 port,\r\n__be32 *entries)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nu32 in_mod;\r\nint err;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmemcpy(mailbox->buf, entries, MLX4_VLAN_TABLE_SIZE);\r\nin_mod = MLX4_SET_PORT_VLAN_TABLE << 8 | port;\r\nerr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_find_cached_vlan(struct mlx4_dev *dev, u8 port, u16 vid, int *idx)\r\n{\r\nstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\r\nint i;\r\nfor (i = 0; i < MLX4_MAX_VLAN_NUM; ++i) {\r\nif (table->refs[i] &&\r\n(vid == (MLX4_VLAN_MASK &\r\nbe32_to_cpu(table->entries[i])))) {\r\n*idx = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int __mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan,\r\nint *index)\r\n{\r\nstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\r\nint i, err = 0;\r\nint free = -1;\r\nmutex_lock(&table->mutex);\r\nif (table->total == table->max) {\r\nerr = -ENOSPC;\r\ngoto out;\r\n}\r\nfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\r\nif (free < 0 && (table->refs[i] == 0)) {\r\nfree = i;\r\ncontinue;\r\n}\r\nif (table->refs[i] &&\r\n(vlan == (MLX4_VLAN_MASK &\r\nbe32_to_cpu(table->entries[i])))) {\r\n*index = i;\r\n++table->refs[i];\r\ngoto out;\r\n}\r\n}\r\nif (free < 0) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ntable->refs[free] = 1;\r\ntable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\r\nerr = mlx4_set_port_vlan_table(dev, port, table->entries);\r\nif (unlikely(err)) {\r\nmlx4_warn(dev, "Failed adding vlan: %u\n", vlan);\r\ntable->refs[free] = 0;\r\ntable->entries[free] = 0;\r\ngoto out;\r\n}\r\n*index = free;\r\n++table->total;\r\nout:\r\nmutex_unlock(&table->mutex);\r\nreturn err;\r\n}\r\nint mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\r\n{\r\nu64 out_param;\r\nint err;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&out_param, port);\r\nerr = mlx4_cmd_imm(dev, vlan, &out_param, RES_VLAN,\r\nRES_OP_RESERVE_AND_MAP, MLX4_CMD_ALLOC_RES,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\r\nif (!err)\r\n*index = get_param_l(&out_param);\r\nreturn err;\r\n}\r\nreturn __mlx4_register_vlan(dev, port, vlan, index);\r\n}\r\nstatic void __mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, int index)\r\n{\r\nstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\r\nif (index < MLX4_VLAN_REGULAR) {\r\nmlx4_warn(dev, "Trying to free special vlan index %d\n", index);\r\nreturn;\r\n}\r\nmutex_lock(&table->mutex);\r\nif (!table->refs[index]) {\r\nmlx4_warn(dev, "No vlan entry for index %d\n", index);\r\ngoto out;\r\n}\r\nif (--table->refs[index]) {\r\nmlx4_dbg(dev, "Have more references for index %d,"\r\n"no need to modify vlan table\n", index);\r\ngoto out;\r\n}\r\ntable->entries[index] = 0;\r\nmlx4_set_port_vlan_table(dev, port, table->entries);\r\n--table->total;\r\nout:\r\nmutex_unlock(&table->mutex);\r\n}\r\nvoid mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, int index)\r\n{\r\nu64 in_param;\r\nint err;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&in_param, port);\r\nerr = mlx4_cmd(dev, in_param, RES_VLAN, RES_OP_RESERVE_AND_MAP,\r\nMLX4_CMD_FREE_RES, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_WRAPPED);\r\nif (!err)\r\nmlx4_warn(dev, "Failed freeing vlan at index:%d\n",\r\nindex);\r\nreturn;\r\n}\r\n__mlx4_unregister_vlan(dev, port, index);\r\n}\r\nint mlx4_get_port_ib_caps(struct mlx4_dev *dev, u8 port, __be32 *caps)\r\n{\r\nstruct mlx4_cmd_mailbox *inmailbox, *outmailbox;\r\nu8 *inbuf, *outbuf;\r\nint err;\r\ninmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(inmailbox))\r\nreturn PTR_ERR(inmailbox);\r\noutmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(outmailbox)) {\r\nmlx4_free_cmd_mailbox(dev, inmailbox);\r\nreturn PTR_ERR(outmailbox);\r\n}\r\ninbuf = inmailbox->buf;\r\noutbuf = outmailbox->buf;\r\nmemset(inbuf, 0, 256);\r\nmemset(outbuf, 0, 256);\r\ninbuf[0] = 1;\r\ninbuf[1] = 1;\r\ninbuf[2] = 1;\r\ninbuf[3] = 1;\r\n*(__be16 *) (&inbuf[16]) = cpu_to_be16(0x0015);\r\n*(__be32 *) (&inbuf[20]) = cpu_to_be32(port);\r\nerr = mlx4_cmd_box(dev, inmailbox->dma, outmailbox->dma, port, 3,\r\nMLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (!err)\r\n*caps = *(__be32 *) (outbuf + 84);\r\nmlx4_free_cmd_mailbox(dev, inmailbox);\r\nmlx4_free_cmd_mailbox(dev, outmailbox);\r\nreturn err;\r\n}\r\nstatic int mlx4_common_set_port(struct mlx4_dev *dev, int slave, u32 in_mod,\r\nu8 op_mod, struct mlx4_cmd_mailbox *inbox)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_port_info *port_info;\r\nstruct mlx4_mfunc_master_ctx *master = &priv->mfunc.master;\r\nstruct mlx4_slave_state *slave_st = &master->slave_state[slave];\r\nstruct mlx4_set_port_rqp_calc_context *qpn_context;\r\nstruct mlx4_set_port_general_context *gen_context;\r\nint reset_qkey_viols;\r\nint port;\r\nint is_eth;\r\nu32 in_modifier;\r\nu32 promisc;\r\nu16 mtu, prev_mtu;\r\nint err;\r\nint i;\r\n__be32 agg_cap_mask;\r\n__be32 slave_cap_mask;\r\n__be32 new_cap_mask;\r\nport = in_mod & 0xff;\r\nin_modifier = in_mod >> 8;\r\nis_eth = op_mod;\r\nport_info = &priv->port[port];\r\nif (is_eth) {\r\nif (slave != dev->caps.function &&\r\nin_modifier != MLX4_SET_PORT_GENERAL) {\r\nmlx4_warn(dev, "denying SET_PORT for slave:%d\n",\r\nslave);\r\nreturn -EINVAL;\r\n}\r\nswitch (in_modifier) {\r\ncase MLX4_SET_PORT_RQP_CALC:\r\nqpn_context = inbox->buf;\r\nqpn_context->base_qpn =\r\ncpu_to_be32(port_info->base_qpn);\r\nqpn_context->n_mac = 0x7;\r\npromisc = be32_to_cpu(qpn_context->promisc) >>\r\nSET_PORT_PROMISC_SHIFT;\r\nqpn_context->promisc = cpu_to_be32(\r\npromisc << SET_PORT_PROMISC_SHIFT |\r\nport_info->base_qpn);\r\npromisc = be32_to_cpu(qpn_context->mcast) >>\r\nSET_PORT_MC_PROMISC_SHIFT;\r\nqpn_context->mcast = cpu_to_be32(\r\npromisc << SET_PORT_MC_PROMISC_SHIFT |\r\nport_info->base_qpn);\r\nbreak;\r\ncase MLX4_SET_PORT_GENERAL:\r\ngen_context = inbox->buf;\r\nmtu = be16_to_cpu(gen_context->mtu);\r\nmtu = min_t(int, mtu, dev->caps.eth_mtu_cap[port]);\r\nprev_mtu = slave_st->mtu[port];\r\nslave_st->mtu[port] = mtu;\r\nif (mtu > master->max_mtu[port])\r\nmaster->max_mtu[port] = mtu;\r\nif (mtu < prev_mtu && prev_mtu ==\r\nmaster->max_mtu[port]) {\r\nslave_st->mtu[port] = mtu;\r\nmaster->max_mtu[port] = mtu;\r\nfor (i = 0; i < dev->num_slaves; i++) {\r\nmaster->max_mtu[port] =\r\nmax(master->max_mtu[port],\r\nmaster->slave_state[i].mtu[port]);\r\n}\r\n}\r\ngen_context->mtu = cpu_to_be16(master->max_mtu[port]);\r\nbreak;\r\n}\r\nreturn mlx4_cmd(dev, inbox->dma, in_mod, op_mod,\r\nMLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_NATIVE);\r\n}\r\nif (dev->flags & MLX4_FLAG_OLD_PORT_CMDS) {\r\nreset_qkey_viols = (*(u8 *) inbox->buf) & 0x40;\r\nnew_cap_mask = ((__be32 *) inbox->buf)[2];\r\n} else {\r\nreset_qkey_viols = ((u8 *) inbox->buf)[3] & 0x1;\r\nnew_cap_mask = ((__be32 *) inbox->buf)[1];\r\n}\r\nif (slave != mlx4_master_func_num(dev) &&\r\n(be32_to_cpu(new_cap_mask) & MLX4_PORT_CAP_IS_SM))\r\nreturn -EINVAL;\r\nif (mlx4_is_mfunc(dev) &&\r\n(be32_to_cpu(new_cap_mask) & MLX4_PORT_CAP_DEV_MGMT_SUP))\r\nreturn -EINVAL;\r\nagg_cap_mask = 0;\r\nslave_cap_mask =\r\npriv->mfunc.master.slave_state[slave].ib_cap_mask[port];\r\npriv->mfunc.master.slave_state[slave].ib_cap_mask[port] = new_cap_mask;\r\nfor (i = 0; i < dev->num_slaves; i++)\r\nagg_cap_mask |=\r\npriv->mfunc.master.slave_state[i].ib_cap_mask[port];\r\nif (slave != dev->caps.function)\r\nmemset(inbox->buf, 0, 256);\r\nif (dev->flags & MLX4_FLAG_OLD_PORT_CMDS) {\r\n*(u8 *) inbox->buf |= !!reset_qkey_viols << 6;\r\n((__be32 *) inbox->buf)[2] = agg_cap_mask;\r\n} else {\r\n((u8 *) inbox->buf)[3] |= !!reset_qkey_viols;\r\n((__be32 *) inbox->buf)[1] = agg_cap_mask;\r\n}\r\nerr = mlx4_cmd(dev, inbox->dma, port, is_eth, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\nif (err)\r\npriv->mfunc.master.slave_state[slave].ib_cap_mask[port] =\r\nslave_cap_mask;\r\nreturn err;\r\n}\r\nint mlx4_SET_PORT_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nreturn mlx4_common_set_port(dev, slave, vhcr->in_modifier,\r\nvhcr->op_modifier, inbox);\r\n}\r\nint mlx4_SET_PORT(struct mlx4_dev *dev, u8 port, int pkey_tbl_sz)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nint err, vl_cap, pkey_tbl_flag = 0;\r\nif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\r\nreturn 0;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmemset(mailbox->buf, 0, 256);\r\n((__be32 *) mailbox->buf)[1] = dev->caps.ib_port_def_cap[port];\r\nif (pkey_tbl_sz >= 0 && mlx4_is_master(dev)) {\r\npkey_tbl_flag = 1;\r\n((__be16 *) mailbox->buf)[20] = cpu_to_be16(pkey_tbl_sz);\r\n}\r\nfor (vl_cap = 8; vl_cap >= 1; vl_cap >>= 1) {\r\n((__be32 *) mailbox->buf)[0] = cpu_to_be32(\r\n(1 << MLX4_CHANGE_PORT_MTU_CAP) |\r\n(1 << MLX4_CHANGE_PORT_VL_CAP) |\r\n(pkey_tbl_flag << MLX4_CHANGE_PORT_PKEY_TBL_SZ) |\r\n(dev->caps.port_ib_mtu[port] << MLX4_SET_PORT_MTU_CAP) |\r\n(vl_cap << MLX4_SET_PORT_VL_CAP));\r\nerr = mlx4_cmd(dev, mailbox->dma, port, 0, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);\r\nif (err != -ENOMEM)\r\nbreak;\r\n}\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_SET_PORT_general(struct mlx4_dev *dev, u8 port, int mtu,\r\nu8 pptx, u8 pfctx, u8 pprx, u8 pfcrx)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_set_port_general_context *context;\r\nint err;\r\nu32 in_mod;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ncontext = mailbox->buf;\r\nmemset(context, 0, sizeof *context);\r\ncontext->flags = SET_PORT_GEN_ALL_VALID;\r\ncontext->mtu = cpu_to_be16(mtu);\r\ncontext->pptx = (pptx * (!pfctx)) << 7;\r\ncontext->pfctx = pfctx;\r\ncontext->pprx = (pprx * (!pfcrx)) << 7;\r\ncontext->pfcrx = pfcrx;\r\nin_mod = MLX4_SET_PORT_GENERAL << 8 | port;\r\nerr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_SET_PORT_qpn_calc(struct mlx4_dev *dev, u8 port, u32 base_qpn,\r\nu8 promisc)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_set_port_rqp_calc_context *context;\r\nint err;\r\nu32 in_mod;\r\nu32 m_promisc = (dev->caps.flags & MLX4_DEV_CAP_FLAG_VEP_MC_STEER) ?\r\nMCAST_DIRECT : MCAST_DEFAULT;\r\nif (dev->caps.steering_mode != MLX4_STEERING_MODE_A0)\r\nreturn 0;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ncontext = mailbox->buf;\r\nmemset(context, 0, sizeof *context);\r\ncontext->base_qpn = cpu_to_be32(base_qpn);\r\ncontext->n_mac = dev->caps.log_num_macs;\r\ncontext->promisc = cpu_to_be32(promisc << SET_PORT_PROMISC_SHIFT |\r\nbase_qpn);\r\ncontext->mcast = cpu_to_be32(m_promisc << SET_PORT_MC_PROMISC_SHIFT |\r\nbase_qpn);\r\ncontext->intra_no_vlan = 0;\r\ncontext->no_vlan = MLX4_NO_VLAN_IDX;\r\ncontext->intra_vlan_miss = 0;\r\ncontext->vlan_miss = MLX4_VLAN_MISS_IDX;\r\nin_mod = MLX4_SET_PORT_RQP_CALC << 8 | port;\r\nerr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_SET_PORT_PRIO2TC(struct mlx4_dev *dev, u8 port, u8 *prio2tc)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_set_port_prio2tc_context *context;\r\nint err;\r\nu32 in_mod;\r\nint i;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ncontext = mailbox->buf;\r\nmemset(context, 0, sizeof *context);\r\nfor (i = 0; i < MLX4_NUM_UP; i += 2)\r\ncontext->prio2tc[i >> 1] = prio2tc[i] << 4 | prio2tc[i + 1];\r\nin_mod = MLX4_SET_PORT_PRIO2TC << 8 | port;\r\nerr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_SET_PORT_SCHEDULER(struct mlx4_dev *dev, u8 port, u8 *tc_tx_bw,\r\nu8 *pg, u16 *ratelimit)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_set_port_scheduler_context *context;\r\nint err;\r\nu32 in_mod;\r\nint i;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ncontext = mailbox->buf;\r\nmemset(context, 0, sizeof *context);\r\nfor (i = 0; i < MLX4_NUM_TC; i++) {\r\nstruct mlx4_port_scheduler_tc_cfg_be *tc = &context->tc[i];\r\nu16 r = ratelimit && ratelimit[i] ? ratelimit[i] :\r\nMLX4_RATELIMIT_DEFAULT;\r\ntc->pg = htons(pg[i]);\r\ntc->bw_precentage = htons(tc_tx_bw[i]);\r\ntc->max_bw_units = htons(MLX4_RATELIMIT_UNITS);\r\ntc->max_bw_value = htons(r);\r\n}\r\nin_mod = MLX4_SET_PORT_SCHEDULER << 8 | port;\r\nerr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mlx4_SET_MCAST_FLTR_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err = 0;\r\nreturn err;\r\n}\r\nint mlx4_SET_MCAST_FLTR(struct mlx4_dev *dev, u8 port,\r\nu64 mac, u64 clear, u8 mode)\r\n{\r\nreturn mlx4_cmd(dev, (mac | (clear << 63)), port, mode,\r\nMLX4_CMD_SET_MCAST_FLTR, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_WRAPPED);\r\n}\r\nint mlx4_SET_VLAN_FLTR_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nint err = 0;\r\nreturn err;\r\n}\r\nint mlx4_common_dump_eth_stats(struct mlx4_dev *dev, int slave,\r\nu32 in_mod, struct mlx4_cmd_mailbox *outbox)\r\n{\r\nreturn mlx4_cmd_box(dev, 0, outbox->dma, in_mod, 0,\r\nMLX4_CMD_DUMP_ETH_STATS, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_NATIVE);\r\n}\r\nint mlx4_DUMP_ETH_STATS_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nif (slave != dev->caps.function)\r\nreturn 0;\r\nreturn mlx4_common_dump_eth_stats(dev, slave,\r\nvhcr->in_modifier, outbox);\r\n}\r\nvoid mlx4_set_stats_bitmap(struct mlx4_dev *dev, u64 *stats_bitmap)\r\n{\r\nif (!mlx4_is_mfunc(dev)) {\r\n*stats_bitmap = 0;\r\nreturn;\r\n}\r\n*stats_bitmap = (MLX4_STATS_TRAFFIC_COUNTERS_MASK |\r\nMLX4_STATS_TRAFFIC_DROPS_MASK |\r\nMLX4_STATS_PORT_COUNTERS_MASK);\r\nif (mlx4_is_master(dev))\r\n*stats_bitmap |= MLX4_STATS_ERROR_COUNTERS_MASK;\r\n}
