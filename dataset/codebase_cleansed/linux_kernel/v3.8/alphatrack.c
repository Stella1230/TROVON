static void usb_alphatrack_abort_transfers(struct usb_alphatrack *dev)\r\n{\r\nif (dev->interrupt_in_running) {\r\ndev->interrupt_in_running = 0;\r\nif (dev->intf)\r\nusb_kill_urb(dev->interrupt_in_urb);\r\n}\r\nif (dev->interrupt_out_busy)\r\nif (dev->intf)\r\nusb_kill_urb(dev->interrupt_out_urb);\r\n}\r\nstatic void usb_alphatrack_delete(struct usb_alphatrack *dev)\r\n{\r\nusb_alphatrack_abort_transfers(dev);\r\nusb_free_urb(dev->interrupt_in_urb);\r\nusb_free_urb(dev->interrupt_out_urb);\r\nkfree(dev->ring_buffer);\r\nkfree(dev->interrupt_in_buffer);\r\nkfree(dev->interrupt_out_buffer);\r\nkfree(dev);\r\n}\r\nstatic void usb_alphatrack_interrupt_in_callback(struct urb *urb)\r\n{\r\nstruct usb_alphatrack *dev = urb->context;\r\nunsigned int next_ring_head;\r\nint retval = -1;\r\nif (urb->status) {\r\nif (urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET || urb->status == -ESHUTDOWN) {\r\ngoto exit;\r\n} else {\r\ndbg_info(&dev->intf->dev,\r\n"%s: nonzero status received: %d\n", __func__,\r\nurb->status);\r\ngoto resubmit;\r\n}\r\n}\r\nif (urb->actual_length != INPUT_CMD_SIZE) {\r\ndev_warn(&dev->intf->dev,\r\n"Urb length was %d bytes!!"\r\n"Do something intelligent\n", urb->actual_length);\r\n} else {\r\nalphatrack_ocmd_info(&dev->intf->dev,\r\n&(*dev->ring_buffer)[dev->ring_tail].cmd,\r\n"%s", "bla");\r\nif (memcmp\r\n(dev->interrupt_in_buffer, dev->oldi_buffer,\r\nINPUT_CMD_SIZE) == 0) {\r\ngoto resubmit;\r\n}\r\nmemcpy(dev->oldi_buffer, dev->interrupt_in_buffer,\r\nINPUT_CMD_SIZE);\r\n#if SUPPRESS_EXTRA_OFFLINE_EVENTS\r\nif (dev->offline == 2 && dev->interrupt_in_buffer[1] == 0xff)\r\ngoto resubmit;\r\nif (dev->offline == 1 && dev->interrupt_in_buffer[1] == 0xff) {\r\ndev->offline = 2;\r\ngoto resubmit;\r\n}\r\nif (dev->offline > 0 && dev->interrupt_in_buffer[1] != 0xff)\r\ndev->offline = 0;\r\nif (dev->offline == 0 && dev->interrupt_in_buffer[1] == 0xff)\r\ndev->offline = 1;\r\n#endif\r\ndbg_info(&dev->intf->dev, "%s: head, tail are %x, %x\n",\r\n__func__, dev->ring_head, dev->ring_tail);\r\nnext_ring_head = (dev->ring_head + 1) % ring_buffer_size;\r\nif (next_ring_head != dev->ring_tail) {\r\nmemcpy(&((*dev->ring_buffer)[dev->ring_head]),\r\ndev->interrupt_in_buffer, urb->actual_length);\r\ndev->ring_head = next_ring_head;\r\nretval = 0;\r\nmemset(dev->interrupt_in_buffer, 0, urb->actual_length);\r\n} else {\r\ndev_warn(&dev->intf->dev,\r\n"Ring buffer overflow, %d bytes dropped\n",\r\nurb->actual_length);\r\nmemset(dev->interrupt_in_buffer, 0, urb->actual_length);\r\n}\r\n}\r\nresubmit:\r\nif (dev->interrupt_in_running && dev->intf) {\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&dev->intf->dev,\r\n"usb_submit_urb failed (%d)\n", retval);\r\n}\r\nexit:\r\ndev->interrupt_in_done = 1;\r\nwake_up_interruptible(&dev->read_wait);\r\n}\r\nstatic void usb_alphatrack_interrupt_out_callback(struct urb *urb)\r\n{\r\nstruct usb_alphatrack *dev = urb->context;\r\nif (urb->status && !(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\ndbg_info(&dev->intf->dev,\r\n"%s - nonzero write interrupt status received: %d\n",\r\n__func__, urb->status);\r\natomic_dec(&dev->writes_pending);\r\ndev->interrupt_out_busy = 0;\r\nwake_up_interruptible(&dev->write_wait);\r\n}\r\nstatic int usb_alphatrack_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_alphatrack *dev;\r\nint subminor;\r\nint retval = 0;\r\nstruct usb_interface *interface;\r\nnonseekable_open(inode, file);\r\nsubminor = iminor(inode);\r\nmutex_lock(&disconnect_mutex);\r\ninterface = usb_find_interface(&usb_alphatrack_driver, subminor);\r\nif (!interface) {\r\npr_err("%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto unlock_disconnect_exit;\r\n}\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nretval = -ENODEV;\r\ngoto unlock_disconnect_exit;\r\n}\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto unlock_disconnect_exit;\r\n}\r\nif (dev->open_count) {\r\nretval = -EBUSY;\r\ngoto unlock_exit;\r\n}\r\ndev->open_count = 1;\r\ndev->ring_head = 0;\r\ndev->ring_tail = 0;\r\nusb_fill_int_urb(dev->interrupt_in_urb,\r\ninterface_to_usbdev(interface),\r\nusb_rcvintpipe(interface_to_usbdev(interface),\r\ndev->interrupt_in_endpoint->\r\nbEndpointAddress),\r\ndev->interrupt_in_buffer,\r\ndev->interrupt_in_endpoint_size,\r\nusb_alphatrack_interrupt_in_callback, dev,\r\ndev->interrupt_in_interval);\r\ndev->interrupt_in_running = 1;\r\ndev->interrupt_in_done = 0;\r\ndev->enable = 1;\r\ndev->offline = 0;\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&interface->dev,\r\n"Couldn't submit interrupt_in_urb %d\n", retval);\r\ndev->interrupt_in_running = 0;\r\ndev->open_count = 0;\r\ngoto unlock_exit;\r\n}\r\nfile->private_data = dev;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nunlock_disconnect_exit:\r\nmutex_unlock(&disconnect_mutex);\r\nreturn retval;\r\n}\r\nstatic int usb_alphatrack_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_alphatrack *dev;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->open_count != 1) {\r\nretval = -ENODEV;\r\ngoto unlock_exit;\r\n}\r\nif (dev->intf == NULL) {\r\nmutex_unlock(&dev->mtx);\r\nusb_alphatrack_delete(dev);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (dev->interrupt_out_busy)\r\nwait_event_interruptible_timeout(dev->write_wait,\r\n!dev->interrupt_out_busy,\r\n2 * HZ);\r\nusb_alphatrack_abort_transfers(dev);\r\ndev->open_count = 0;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic unsigned int usb_alphatrack_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct usb_alphatrack *dev;\r\nunsigned int mask = 0;\r\ndev = file->private_data;\r\npoll_wait(file, &dev->read_wait, wait);\r\npoll_wait(file, &dev->write_wait, wait);\r\nif (dev->ring_head != dev->ring_tail)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (!dev->interrupt_out_busy)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic ssize_t usb_alphatrack_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_alphatrack *dev;\r\nint retval = 0;\r\nint c = 0;\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->intf == NULL) {\r\nretval = -ENODEV;\r\npr_err("%s: No device or device unplugged %d\n",\r\n__func__, retval);\r\ngoto unlock_exit;\r\n}\r\nwhile (dev->ring_head == dev->ring_tail) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\ndev->interrupt_in_done = 0;\r\nretval =\r\nwait_event_interruptible(dev->read_wait,\r\ndev->interrupt_in_done);\r\nif (retval < 0)\r\ngoto unlock_exit;\r\n}\r\nalphatrack_ocmd_info(&dev->intf->dev,\r\n&(*dev->ring_buffer)[dev->ring_tail].cmd, "%s",\r\n": copying to userspace");\r\nc = 0;\r\nwhile ((c < count) && (dev->ring_tail != dev->ring_head)) {\r\nif (copy_to_user\r\n(&buffer[c], &(*dev->ring_buffer)[dev->ring_tail],\r\nINPUT_CMD_SIZE)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\ndev->ring_tail = (dev->ring_tail + 1) % ring_buffer_size;\r\nc += INPUT_CMD_SIZE;\r\ndbg_info(&dev->intf->dev, "%s: head, tail are %x, %x\n",\r\n__func__, dev->ring_head, dev->ring_tail);\r\n}\r\nretval = c;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic ssize_t usb_alphatrack_write(struct file *file,\r\nconst char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct usb_alphatrack *dev;\r\nsize_t bytes_to_write;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->intf == NULL) {\r\nretval = -ENODEV;\r\npr_err("%s: No device or device unplugged %d\n",\r\n__func__, retval);\r\ngoto unlock_exit;\r\n}\r\nif (dev->interrupt_out_busy) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\nretval =\r\nwait_event_interruptible(dev->write_wait,\r\n!dev->interrupt_out_busy);\r\nif (retval < 0)\r\ngoto unlock_exit;\r\n}\r\nbytes_to_write =\r\nmin(count, write_buffer_size * dev->interrupt_out_endpoint_size);\r\nif (bytes_to_write < count)\r\ndev_warn(&dev->intf->dev,\r\n"Write buffer overflow, %zd bytes dropped\n",\r\ncount - bytes_to_write);\r\ndbg_info(&dev->intf->dev, "%s: count = %zd, bytes_to_write = %zd\n",\r\n__func__, count, bytes_to_write);\r\nif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL) {\r\ndev_err(&dev->intf->dev, "Endpoint should not be be null!\n");\r\ngoto unlock_exit;\r\n}\r\nusb_fill_int_urb(dev->interrupt_out_urb,\r\ninterface_to_usbdev(dev->intf),\r\nusb_sndintpipe(interface_to_usbdev(dev->intf),\r\ndev->interrupt_out_endpoint->\r\nbEndpointAddress),\r\ndev->interrupt_out_buffer, bytes_to_write,\r\nusb_alphatrack_interrupt_out_callback, dev,\r\ndev->interrupt_out_interval);\r\ndev->interrupt_out_busy = 1;\r\natomic_inc(&dev->writes_pending);\r\nwmb();\r\nretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev->interrupt_out_busy = 0;\r\ndev_err(&dev->intf->dev,\r\n"Couldn't submit interrupt_out_urb %d\n", retval);\r\natomic_dec(&dev->writes_pending);\r\ngoto unlock_exit;\r\n}\r\nretval = bytes_to_write;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int usb_alphatrack_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_alphatrack *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nint true_size;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&intf->dev, "Out of memory\n");\r\ngoto exit;\r\n}\r\nmutex_init(&dev->mtx);\r\ndev->intf = intf;\r\ninit_waitqueue_head(&dev->read_wait);\r\ninit_waitqueue_head(&dev->write_wait);\r\niface_desc = intf->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint))\r\ndev->interrupt_in_endpoint = endpoint;\r\nif (usb_endpoint_is_int_out(endpoint))\r\ndev->interrupt_out_endpoint = endpoint;\r\n}\r\nif (dev->interrupt_in_endpoint == NULL) {\r\ndev_err(&intf->dev, "Interrupt in endpoint not found\n");\r\ngoto error;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL)\r\ndev_warn(&intf->dev,\r\n"Interrupt out endpoint not found"\r\n"(using control endpoint instead)\n");\r\ndev->interrupt_in_endpoint_size =\r\nle16_to_cpu(dev->interrupt_in_endpoint->wMaxPacketSize);\r\nif (dev->interrupt_in_endpoint_size != 64)\r\ndev_warn(&intf->dev, "Interrupt in endpoint size is not 64!\n");\r\nif (ring_buffer_size == 0)\r\nring_buffer_size = RING_BUFFER_SIZE;\r\ntrue_size = min(ring_buffer_size, RING_BUFFER_SIZE);\r\ndev->ring_buffer =\r\nkmalloc((true_size * sizeof(struct alphatrack_icmd)), GFP_KERNEL);\r\nif (!dev->ring_buffer) {\r\ndev_err(&intf->dev,\r\n"Couldn't allocate input ring_buffer of size %d\n",\r\ntrue_size);\r\ngoto error;\r\n}\r\ndev->interrupt_in_buffer =\r\nkmalloc(dev->interrupt_in_endpoint_size, GFP_KERNEL);\r\nif (!dev->interrupt_in_buffer) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_in_buffer\n");\r\ngoto error;\r\n}\r\ndev->oldi_buffer = kmalloc(dev->interrupt_in_endpoint_size, GFP_KERNEL);\r\nif (!dev->oldi_buffer) {\r\ndev_err(&intf->dev, "Couldn't allocate old buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_in_urb) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_in_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_endpoint_size =\r\ndev->interrupt_out_endpoint ? le16_to_cpu(dev->\r\ninterrupt_out_endpoint->\r\nwMaxPacketSize) : udev->\r\ndescriptor.bMaxPacketSize0;\r\nif (dev->interrupt_out_endpoint_size != 64)\r\ndev_warn(&intf->dev,\r\n"Interrupt out endpoint size is not 64!)\n");\r\nif (write_buffer_size == 0)\r\nwrite_buffer_size = WRITE_BUFFER_SIZE;\r\ntrue_size = min(write_buffer_size, WRITE_BUFFER_SIZE);\r\ndev->interrupt_out_buffer =\r\nkmalloc(true_size * dev->interrupt_out_endpoint_size, GFP_KERNEL);\r\nif (!dev->interrupt_out_buffer) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_out_buffer\n");\r\ngoto error;\r\n}\r\ndev->write_buffer =\r\nkmalloc(true_size * sizeof(struct alphatrack_ocmd), GFP_KERNEL);\r\nif (!dev->write_buffer) {\r\ndev_err(&intf->dev, "Couldn't allocate write_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_out_urb) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_out_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_interval =\r\nmin_interrupt_in_interval >\r\ndev->interrupt_in_endpoint->\r\nbInterval ? min_interrupt_in_interval : dev->interrupt_in_endpoint->\r\nbInterval;\r\nif (dev->interrupt_out_endpoint)\r\ndev->interrupt_out_interval =\r\nmin_interrupt_out_interval >\r\ndev->interrupt_out_endpoint->\r\nbInterval ? min_interrupt_out_interval : dev->\r\ninterrupt_out_endpoint->bInterval;\r\nusb_set_intfdata(intf, dev);\r\natomic_set(&dev->writes_pending, 0);\r\nretval = usb_register_dev(intf, &usb_alphatrack_class);\r\nif (retval) {\r\ndev_err(&intf->dev,\r\n"Not able to get a minor for this device.\n");\r\nusb_set_intfdata(intf, NULL);\r\ngoto error;\r\n}\r\ndev_info(&intf->dev,\r\n"Alphatrack Device #%d now attached to major %d minor %d\n",\r\n(intf->minor - USB_ALPHATRACK_MINOR_BASE), USB_MAJOR,\r\nintf->minor);\r\nexit:\r\nreturn retval;\r\nerror:\r\nusb_alphatrack_delete(dev);\r\nreturn retval;\r\n}\r\nstatic void usb_alphatrack_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_alphatrack *dev;\r\nint minor;\r\nmutex_lock(&disconnect_mutex);\r\ndev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nmutex_lock(&dev->mtx);\r\nminor = intf->minor;\r\nusb_deregister_dev(intf, &usb_alphatrack_class);\r\nif (!dev->open_count) {\r\nmutex_unlock(&dev->mtx);\r\nusb_alphatrack_delete(dev);\r\n} else {\r\ndev->intf = NULL;\r\nmutex_unlock(&dev->mtx);\r\n}\r\natomic_set(&dev->writes_pending, 0);\r\nmutex_unlock(&disconnect_mutex);\r\ndev_info(&intf->dev, "Alphatrack Surface #%d now disconnected\n",\r\n(minor - USB_ALPHATRACK_MINOR_BASE));\r\n}
