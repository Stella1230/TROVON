static struct oz_serial_ctx *oz_cdev_claim_ctx(struct oz_pd *pd)\r\n{\r\nstruct oz_serial_ctx *ctx;\r\nspin_lock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\nctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\r\nif (ctx)\r\natomic_inc(&ctx->ref_count);\r\nspin_unlock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\nreturn ctx;\r\n}\r\nstatic void oz_cdev_release_ctx(struct oz_serial_ctx *ctx)\r\n{\r\nif (atomic_dec_and_test(&ctx->ref_count)) {\r\noz_trace("Dealloc serial context.\n");\r\nkfree(ctx);\r\n}\r\n}\r\nint oz_cdev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct oz_cdev *dev;\r\noz_trace("oz_cdev_open()\n");\r\noz_trace("major = %d minor = %d\n", imajor(inode), iminor(inode));\r\ndev = container_of(inode->i_cdev, struct oz_cdev, cdev);\r\nfilp->private_data = dev;\r\nreturn 0;\r\n}\r\nint oz_cdev_release(struct inode *inode, struct file *filp)\r\n{\r\noz_trace("oz_cdev_release()\n");\r\nreturn 0;\r\n}\r\nssize_t oz_cdev_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *fpos)\r\n{\r\nint n;\r\nint ix;\r\nstruct oz_pd *pd;\r\nstruct oz_serial_ctx *ctx = 0;\r\nspin_lock_bh(&g_cdev.lock);\r\npd = g_cdev.active_pd;\r\nif (pd)\r\noz_pd_get(pd);\r\nspin_unlock_bh(&g_cdev.lock);\r\nif (pd == NULL)\r\nreturn -1;\r\nctx = oz_cdev_claim_ctx(pd);\r\nif (ctx == NULL)\r\ngoto out2;\r\nn = ctx->rd_in - ctx->rd_out;\r\nif (n < 0)\r\nn += OZ_RD_BUF_SZ;\r\nif (count > n)\r\ncount = n;\r\nix = ctx->rd_out;\r\nn = OZ_RD_BUF_SZ - ix;\r\nif (n > count)\r\nn = count;\r\nif (copy_to_user(buf, &ctx->rd_buf[ix], n)) {\r\ncount = 0;\r\ngoto out1;\r\n}\r\nix += n;\r\nif (ix == OZ_RD_BUF_SZ)\r\nix = 0;\r\nif (n < count) {\r\nif (copy_to_user(&buf[n], ctx->rd_buf, count-n)) {\r\ncount = 0;\r\ngoto out1;\r\n}\r\nix = count-n;\r\n}\r\nctx->rd_out = ix;\r\nout1:\r\noz_cdev_release_ctx(ctx);\r\nout2:\r\noz_pd_put(pd);\r\nreturn count;\r\n}\r\nssize_t oz_cdev_write(struct file *filp, const char __user *buf, size_t count,\r\nloff_t *fpos)\r\n{\r\nstruct oz_pd *pd;\r\nstruct oz_elt_buf *eb;\r\nstruct oz_elt_info *ei = 0;\r\nstruct oz_elt *elt;\r\nstruct oz_app_hdr *app_hdr;\r\nstruct oz_serial_ctx *ctx;\r\nspin_lock_bh(&g_cdev.lock);\r\npd = g_cdev.active_pd;\r\nif (pd)\r\noz_pd_get(pd);\r\nspin_unlock_bh(&g_cdev.lock);\r\nif (pd == NULL)\r\nreturn -1;\r\neb = &pd->elt_buff;\r\nei = oz_elt_info_alloc(eb);\r\nif (ei == NULL) {\r\ncount = 0;\r\ngoto out;\r\n}\r\nelt = (struct oz_elt *)ei->data;\r\napp_hdr = (struct oz_app_hdr *)(elt+1);\r\nelt->length = sizeof(struct oz_app_hdr) + count;\r\nelt->type = OZ_ELT_APP_DATA;\r\nei->app_id = OZ_APPID_SERIAL;\r\nei->length = elt->length + sizeof(struct oz_elt);\r\napp_hdr->app_id = OZ_APPID_SERIAL;\r\nif (copy_from_user(app_hdr+1, buf, count))\r\ngoto out;\r\nspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\r\nctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\r\nif (ctx) {\r\napp_hdr->elt_seq_num = ctx->tx_seq_num++;\r\nif (ctx->tx_seq_num == 0)\r\nctx->tx_seq_num = 1;\r\nspin_lock(&eb->lock);\r\nif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\r\nei = 0;\r\nspin_unlock(&eb->lock);\r\n}\r\nspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\r\nout:\r\nif (ei) {\r\ncount = 0;\r\nspin_lock_bh(&eb->lock);\r\noz_elt_info_free(eb, ei);\r\nspin_unlock_bh(&eb->lock);\r\n}\r\noz_pd_put(pd);\r\nreturn count;\r\n}\r\nstatic int oz_set_active_pd(u8 *addr)\r\n{\r\nint rc = 0;\r\nstruct oz_pd *pd;\r\nstruct oz_pd *old_pd;\r\npd = oz_pd_find(addr);\r\nif (pd) {\r\nspin_lock_bh(&g_cdev.lock);\r\nmemcpy(g_cdev.active_addr, addr, ETH_ALEN);\r\nold_pd = g_cdev.active_pd;\r\ng_cdev.active_pd = pd;\r\nspin_unlock_bh(&g_cdev.lock);\r\nif (old_pd)\r\noz_pd_put(old_pd);\r\n} else {\r\nif (is_zero_ether_addr(addr)) {\r\nspin_lock_bh(&g_cdev.lock);\r\npd = g_cdev.active_pd;\r\ng_cdev.active_pd = 0;\r\nmemset(g_cdev.active_addr, 0,\r\nsizeof(g_cdev.active_addr));\r\nspin_unlock_bh(&g_cdev.lock);\r\nif (pd)\r\noz_pd_put(pd);\r\n} else {\r\nrc = -1;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nlong oz_cdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint rc = 0;\r\nif (_IOC_TYPE(cmd) != OZ_IOCTL_MAGIC)\r\nreturn -ENOTTY;\r\nif (_IOC_NR(cmd) > OZ_IOCTL_MAX)\r\nreturn -ENOTTY;\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nrc = !access_ok(VERIFY_WRITE, (void __user *)arg,\r\n_IOC_SIZE(cmd));\r\nelse if (_IOC_DIR(cmd) & _IOC_WRITE)\r\nrc = !access_ok(VERIFY_READ, (void __user *)arg,\r\n_IOC_SIZE(cmd));\r\nif (rc)\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase OZ_IOCTL_GET_PD_LIST: {\r\nstruct oz_pd_list list;\r\noz_trace("OZ_IOCTL_GET_PD_LIST\n");\r\nlist.count = oz_get_pd_list(list.addr, OZ_MAX_PDS);\r\nif (copy_to_user((void __user *)arg, &list,\r\nsizeof(list)))\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase OZ_IOCTL_SET_ACTIVE_PD: {\r\nu8 addr[ETH_ALEN];\r\noz_trace("OZ_IOCTL_SET_ACTIVE_PD\n");\r\nif (copy_from_user(addr, (void __user *)arg, ETH_ALEN))\r\nreturn -EFAULT;\r\nrc = oz_set_active_pd(addr);\r\n}\r\nbreak;\r\ncase OZ_IOCTL_GET_ACTIVE_PD: {\r\nu8 addr[ETH_ALEN];\r\noz_trace("OZ_IOCTL_GET_ACTIVE_PD\n");\r\nspin_lock_bh(&g_cdev.lock);\r\nmemcpy(addr, g_cdev.active_addr, ETH_ALEN);\r\nspin_unlock_bh(&g_cdev.lock);\r\nif (copy_to_user((void __user *)arg, addr, ETH_ALEN))\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase OZ_IOCTL_ADD_BINDING:\r\ncase OZ_IOCTL_REMOVE_BINDING: {\r\nstruct oz_binding_info b;\r\nif (copy_from_user(&b, (void __user *)arg,\r\nsizeof(struct oz_binding_info))) {\r\nreturn -EFAULT;\r\n}\r\nb.name[OZ_MAX_BINDING_LEN-1] = 0;\r\nif (cmd == OZ_IOCTL_ADD_BINDING)\r\noz_binding_add(b.name);\r\nelse\r\noz_binding_remove(b.name);\r\n}\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nunsigned int oz_cdev_poll(struct file *filp, poll_table *wait)\r\n{\r\nunsigned int ret = 0;\r\nstruct oz_cdev *dev = filp->private_data;\r\noz_trace("Poll called wait = %p\n", wait);\r\nspin_lock_bh(&dev->lock);\r\nif (dev->active_pd) {\r\nstruct oz_serial_ctx *ctx = oz_cdev_claim_ctx(dev->active_pd);\r\nif (ctx) {\r\nif (ctx->rd_in != ctx->rd_out)\r\nret |= POLLIN | POLLRDNORM;\r\noz_cdev_release_ctx(ctx);\r\n}\r\n}\r\nspin_unlock_bh(&dev->lock);\r\nif (wait)\r\npoll_wait(filp, &dev->rdq, wait);\r\nreturn ret;\r\n}\r\nint oz_cdev_register(void)\r\n{\r\nint err;\r\nstruct device *dev;\r\nmemset(&g_cdev, 0, sizeof(g_cdev));\r\nerr = alloc_chrdev_region(&g_cdev.devnum, 0, 1, "ozwpan");\r\nif (err < 0)\r\ngoto out3;\r\noz_trace("Alloc dev number %d:%d\n", MAJOR(g_cdev.devnum),\r\nMINOR(g_cdev.devnum));\r\ncdev_init(&g_cdev.cdev, &oz_fops);\r\ng_cdev.cdev.owner = THIS_MODULE;\r\ng_cdev.cdev.ops = &oz_fops;\r\nspin_lock_init(&g_cdev.lock);\r\ninit_waitqueue_head(&g_cdev.rdq);\r\nerr = cdev_add(&g_cdev.cdev, g_cdev.devnum, 1);\r\nif (err < 0) {\r\noz_trace("Failed to add cdev\n");\r\ngoto out2;\r\n}\r\ng_oz_class = class_create(THIS_MODULE, "ozmo_wpan");\r\nif (IS_ERR(g_oz_class)) {\r\noz_trace("Failed to register ozmo_wpan class\n");\r\ngoto out1;\r\n}\r\ndev = device_create(g_oz_class, NULL, g_cdev.devnum, NULL, "ozwpan");\r\nif (IS_ERR(dev)) {\r\noz_trace("Failed to create sysfs entry for cdev\n");\r\ngoto out1;\r\n}\r\nreturn 0;\r\nout1:\r\ncdev_del(&g_cdev.cdev);\r\nout2:\r\nunregister_chrdev_region(g_cdev.devnum, 1);\r\nout3:\r\nreturn err;\r\n}\r\nint oz_cdev_deregister(void)\r\n{\r\ncdev_del(&g_cdev.cdev);\r\nunregister_chrdev_region(g_cdev.devnum, 1);\r\nif (g_oz_class) {\r\ndevice_destroy(g_oz_class, g_cdev.devnum);\r\nclass_destroy(g_oz_class);\r\n}\r\nreturn 0;\r\n}\r\nint oz_cdev_init(void)\r\n{\r\noz_event_log(OZ_EVT_SERVICE, 1, OZ_APPID_SERIAL, 0, 0);\r\noz_app_enable(OZ_APPID_SERIAL, 1);\r\nreturn 0;\r\n}\r\nvoid oz_cdev_term(void)\r\n{\r\noz_event_log(OZ_EVT_SERVICE, 2, OZ_APPID_SERIAL, 0, 0);\r\noz_app_enable(OZ_APPID_SERIAL, 0);\r\n}\r\nint oz_cdev_start(struct oz_pd *pd, int resume)\r\n{\r\nstruct oz_serial_ctx *ctx;\r\nstruct oz_serial_ctx *old_ctx = 0;\r\noz_event_log(OZ_EVT_SERVICE, 3, OZ_APPID_SERIAL, 0, resume);\r\nif (resume) {\r\noz_trace("Serial service resumed.\n");\r\nreturn 0;\r\n}\r\nctx = kzalloc(sizeof(struct oz_serial_ctx), GFP_ATOMIC);\r\nif (ctx == NULL)\r\nreturn -ENOMEM;\r\natomic_set(&ctx->ref_count, 1);\r\nctx->tx_seq_num = 1;\r\nspin_lock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\nold_ctx = pd->app_ctx[OZ_APPID_SERIAL-1];\r\nif (old_ctx) {\r\nspin_unlock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\nkfree(ctx);\r\n} else {\r\npd->app_ctx[OZ_APPID_SERIAL-1] = ctx;\r\nspin_unlock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\n}\r\nspin_lock(&g_cdev.lock);\r\nif ((g_cdev.active_pd == NULL) &&\r\n(memcmp(pd->mac_addr, g_cdev.active_addr, ETH_ALEN) == 0)) {\r\noz_pd_get(pd);\r\ng_cdev.active_pd = pd;\r\noz_trace("Active PD arrived.\n");\r\n}\r\nspin_unlock(&g_cdev.lock);\r\noz_trace("Serial service started.\n");\r\nreturn 0;\r\n}\r\nvoid oz_cdev_stop(struct oz_pd *pd, int pause)\r\n{\r\nstruct oz_serial_ctx *ctx;\r\noz_event_log(OZ_EVT_SERVICE, 4, OZ_APPID_SERIAL, 0, pause);\r\nif (pause) {\r\noz_trace("Serial service paused.\n");\r\nreturn;\r\n}\r\nspin_lock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\nctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\r\npd->app_ctx[OZ_APPID_SERIAL-1] = 0;\r\nspin_unlock_bh(&pd->app_lock[OZ_APPID_SERIAL-1]);\r\nif (ctx)\r\noz_cdev_release_ctx(ctx);\r\nspin_lock(&g_cdev.lock);\r\nif (pd == g_cdev.active_pd)\r\ng_cdev.active_pd = 0;\r\nelse\r\npd = 0;\r\nspin_unlock(&g_cdev.lock);\r\nif (pd) {\r\noz_pd_put(pd);\r\noz_trace("Active PD departed.\n");\r\n}\r\noz_trace("Serial service stopped.\n");\r\n}\r\nvoid oz_cdev_rx(struct oz_pd *pd, struct oz_elt *elt)\r\n{\r\nstruct oz_serial_ctx *ctx;\r\nstruct oz_app_hdr *app_hdr;\r\nu8 *data;\r\nint len;\r\nint space;\r\nint copy_sz;\r\nint ix;\r\nctx = oz_cdev_claim_ctx(pd);\r\nif (ctx == NULL) {\r\noz_trace("Cannot claim serial context.\n");\r\nreturn;\r\n}\r\napp_hdr = (struct oz_app_hdr *)(elt+1);\r\nif (app_hdr->elt_seq_num != 0) {\r\nif (((ctx->rx_seq_num - app_hdr->elt_seq_num) & 0x80) == 0) {\r\noz_trace("Duplicate element:%02x %02x\n",\r\napp_hdr->elt_seq_num, ctx->rx_seq_num);\r\ngoto out;\r\n}\r\n}\r\nctx->rx_seq_num = app_hdr->elt_seq_num;\r\nlen = elt->length - sizeof(struct oz_app_hdr);\r\ndata = ((u8 *)(elt+1)) + sizeof(struct oz_app_hdr);\r\nif (len <= 0)\r\ngoto out;\r\nspace = ctx->rd_out - ctx->rd_in - 1;\r\nif (space < 0)\r\nspace += OZ_RD_BUF_SZ;\r\nif (len > space) {\r\noz_trace("Not enough space:%d %d\n", len, space);\r\nlen = space;\r\n}\r\nix = ctx->rd_in;\r\ncopy_sz = OZ_RD_BUF_SZ - ix;\r\nif (copy_sz > len)\r\ncopy_sz = len;\r\nmemcpy(&ctx->rd_buf[ix], data, copy_sz);\r\nlen -= copy_sz;\r\nix += copy_sz;\r\nif (ix == OZ_RD_BUF_SZ)\r\nix = 0;\r\nif (len) {\r\nmemcpy(ctx->rd_buf, data+copy_sz, len);\r\nix = len;\r\n}\r\nctx->rd_in = ix;\r\nwake_up(&g_cdev.rdq);\r\nout:\r\noz_cdev_release_ctx(ctx);\r\n}\r\nvoid oz_cdev_heartbeat(struct oz_pd *pd)\r\n{\r\n}
