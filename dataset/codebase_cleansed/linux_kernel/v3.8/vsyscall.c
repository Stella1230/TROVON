static int __init vdso_setup(char *s)\r\n{\r\nvdso_enabled = simple_strtoul(s, NULL, 0);\r\nreturn 1;\r\n}\r\nint __init vsyscall_init(void)\r\n{\r\nvoid *syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\r\nsyscall_pages[0] = virt_to_page(syscall_page);\r\nmemcpy(syscall_page,\r\n&vsyscall_trapa_start,\r\n&vsyscall_trapa_end - &vsyscall_trapa_start);\r\nreturn 0;\r\n}\r\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long addr;\r\nint ret;\r\ndown_write(&mm->mmap_sem);\r\naddr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);\r\nif (IS_ERR_VALUE(addr)) {\r\nret = addr;\r\ngoto up_fail;\r\n}\r\nret = install_special_mapping(mm, addr, PAGE_SIZE,\r\nVM_READ | VM_EXEC |\r\nVM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC,\r\nsyscall_pages);\r\nif (unlikely(ret))\r\ngoto up_fail;\r\ncurrent->mm->context.vdso = (void *)addr;\r\nup_fail:\r\nup_write(&mm->mmap_sem);\r\nreturn ret;\r\n}\r\nconst char *arch_vma_name(struct vm_area_struct *vma)\r\n{\r\nif (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)\r\nreturn "[vdso]";\r\nreturn NULL;\r\n}\r\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\r\n{\r\nreturn NULL;\r\n}\r\nint in_gate_area(struct mm_struct *mm, unsigned long address)\r\n{\r\nreturn 0;\r\n}\r\nint in_gate_area_no_mm(unsigned long address)\r\n{\r\nreturn 0;\r\n}
