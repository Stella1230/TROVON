void vpa_init(int cpu)\r\n{\r\nint hwcpu = get_hard_smp_processor_id(cpu);\r\nunsigned long addr;\r\nlong ret;\r\nstruct paca_struct *pp;\r\nstruct dtl_entry *dtl;\r\nif (cpu_has_feature(CPU_FTR_ALTIVEC))\r\nlppaca_of(cpu).vmxregs_in_use = 1;\r\naddr = __pa(&lppaca_of(cpu));\r\nret = register_vpa(hwcpu, addr);\r\nif (ret) {\r\npr_err("WARNING: VPA registration for cpu %d (hw %d) of area "\r\n"%lx failed with %ld\n", cpu, hwcpu, addr, ret);\r\nreturn;\r\n}\r\naddr = __pa(&slb_shadow[cpu]);\r\nif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\r\nret = register_slb_shadow(hwcpu, addr);\r\nif (ret)\r\npr_err("WARNING: SLB shadow buffer registration for "\r\n"cpu %d (hw %d) of area %lx failed with %ld\n",\r\ncpu, hwcpu, addr, ret);\r\n}\r\npp = &paca[cpu];\r\ndtl = pp->dispatch_log;\r\nif (dtl) {\r\npp->dtl_ridx = 0;\r\npp->dtl_curr = dtl;\r\nlppaca_of(cpu).dtl_idx = 0;\r\ndtl->enqueue_to_dispatch_time = DISPATCH_LOG_BYTES;\r\nret = register_dtl(hwcpu, __pa(dtl));\r\nif (ret)\r\npr_err("WARNING: DTL registration of cpu %d (hw %d) "\r\n"failed with %ld\n", smp_processor_id(),\r\nhwcpu, ret);\r\nlppaca_of(cpu).dtl_enable_mask = 2;\r\n}\r\n}\r\nstatic long pSeries_lpar_hpte_insert(unsigned long hpte_group,\r\nunsigned long vpn, unsigned long pa,\r\nunsigned long rflags, unsigned long vflags,\r\nint psize, int ssize)\r\n{\r\nunsigned long lpar_rc;\r\nunsigned long flags;\r\nunsigned long slot;\r\nunsigned long hpte_v, hpte_r;\r\nif (!(vflags & HPTE_V_BOLTED))\r\npr_devel("hpte_insert(group=%lx, vpn=%016lx, "\r\n"pa=%016lx, rflags=%lx, vflags=%lx, psize=%d)\n",\r\nhpte_group, vpn, pa, rflags, vflags, psize);\r\nhpte_v = hpte_encode_v(vpn, psize, ssize) | vflags | HPTE_V_VALID;\r\nhpte_r = hpte_encode_r(pa, psize) | rflags;\r\nif (!(vflags & HPTE_V_BOLTED))\r\npr_devel(" hpte_v=%016lx, hpte_r=%016lx\n", hpte_v, hpte_r);\r\nflags = 0;\r\nif ((rflags & _PAGE_NO_CACHE) & !(rflags & _PAGE_WRITETHRU))\r\nhpte_r &= ~_PAGE_COHERENT;\r\nif (firmware_has_feature(FW_FEATURE_XCMO) && !(hpte_r & HPTE_R_N))\r\nflags |= H_COALESCE_CAND;\r\nlpar_rc = plpar_pte_enter(flags, hpte_group, hpte_v, hpte_r, &slot);\r\nif (unlikely(lpar_rc == H_PTEG_FULL)) {\r\nif (!(vflags & HPTE_V_BOLTED))\r\npr_devel(" full\n");\r\nreturn -1;\r\n}\r\nif (unlikely(lpar_rc != H_SUCCESS)) {\r\nif (!(vflags & HPTE_V_BOLTED))\r\npr_devel(" lpar err %lu\n", lpar_rc);\r\nreturn -2;\r\n}\r\nif (!(vflags & HPTE_V_BOLTED))\r\npr_devel(" -> slot: %lu\n", slot & 7);\r\nreturn (slot & 7) | (!!(vflags & HPTE_V_SECONDARY) << 3);\r\n}\r\nstatic long pSeries_lpar_hpte_remove(unsigned long hpte_group)\r\n{\r\nunsigned long slot_offset;\r\nunsigned long lpar_rc;\r\nint i;\r\nunsigned long dummy1, dummy2;\r\nslot_offset = mftb() & 0x7;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nlpar_rc = plpar_pte_remove(H_ANDCOND, hpte_group + slot_offset,\r\n(0x1UL << 4), &dummy1, &dummy2);\r\nif (lpar_rc == H_SUCCESS)\r\nreturn i;\r\nBUG_ON(lpar_rc != H_NOT_FOUND);\r\nslot_offset++;\r\nslot_offset &= 0x7;\r\n}\r\nreturn -1;\r\n}\r\nstatic void pSeries_lpar_hptab_clear(void)\r\n{\r\nunsigned long size_bytes = 1UL << ppc64_pft_size;\r\nunsigned long hpte_count = size_bytes >> 4;\r\nstruct {\r\nunsigned long pteh;\r\nunsigned long ptel;\r\n} ptes[4];\r\nlong lpar_rc;\r\nunsigned long i, j;\r\nfor (i = 0; i < hpte_count; i += 4) {\r\nlpar_rc = plpar_pte_read_4_raw(0, i, (void *)ptes);\r\nif (lpar_rc != H_SUCCESS)\r\ncontinue;\r\nfor (j = 0; j < 4; j++){\r\nif ((ptes[j].pteh & HPTE_V_VRMA_MASK) ==\r\nHPTE_V_VRMA_MASK)\r\ncontinue;\r\nif (ptes[j].pteh & HPTE_V_VALID)\r\nplpar_pte_remove_raw(0, i + j, 0,\r\n&(ptes[j].pteh), &(ptes[j].ptel));\r\n}\r\n}\r\n}\r\nstatic long pSeries_lpar_hpte_updatepp(unsigned long slot,\r\nunsigned long newpp,\r\nunsigned long vpn,\r\nint psize, int ssize, int local)\r\n{\r\nunsigned long lpar_rc;\r\nunsigned long flags = (newpp & 7) | H_AVPN;\r\nunsigned long want_v;\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\npr_devel(" update: avpnv=%016lx, hash=%016lx, f=%lx, psize: %d ...",\r\nwant_v, slot, flags, psize);\r\nlpar_rc = plpar_pte_protect(flags, slot, want_v);\r\nif (lpar_rc == H_NOT_FOUND) {\r\npr_devel("not found !\n");\r\nreturn -1;\r\n}\r\npr_devel("ok\n");\r\nBUG_ON(lpar_rc != H_SUCCESS);\r\nreturn 0;\r\n}\r\nstatic unsigned long pSeries_lpar_hpte_getword0(unsigned long slot)\r\n{\r\nunsigned long dword0;\r\nunsigned long lpar_rc;\r\nunsigned long dummy_word1;\r\nunsigned long flags;\r\nflags = 0;\r\nlpar_rc = plpar_pte_read(flags, slot, &dword0, &dummy_word1);\r\nBUG_ON(lpar_rc != H_SUCCESS);\r\nreturn dword0;\r\n}\r\nstatic long pSeries_lpar_hpte_find(unsigned long vpn, int psize, int ssize)\r\n{\r\nunsigned long hash;\r\nunsigned long i;\r\nlong slot;\r\nunsigned long want_v, hpte_v;\r\nhash = hpt_hash(vpn, mmu_psize_defs[psize].shift, ssize);\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhpte_v = pSeries_lpar_hpte_getword0(slot);\r\nif (HPTE_V_COMPARE(hpte_v, want_v) && (hpte_v & HPTE_V_VALID))\r\nreturn slot;\r\n++slot;\r\n}\r\nreturn -1;\r\n}\r\nstatic void pSeries_lpar_hpte_updateboltedpp(unsigned long newpp,\r\nunsigned long ea,\r\nint psize, int ssize)\r\n{\r\nunsigned long vpn;\r\nunsigned long lpar_rc, slot, vsid, flags;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nslot = pSeries_lpar_hpte_find(vpn, psize, ssize);\r\nBUG_ON(slot == -1);\r\nflags = newpp & 7;\r\nlpar_rc = plpar_pte_protect(flags, slot, 0);\r\nBUG_ON(lpar_rc != H_SUCCESS);\r\n}\r\nstatic void pSeries_lpar_hpte_invalidate(unsigned long slot, unsigned long vpn,\r\nint psize, int ssize, int local)\r\n{\r\nunsigned long want_v;\r\nunsigned long lpar_rc;\r\nunsigned long dummy1, dummy2;\r\npr_devel(" inval : slot=%lx, vpn=%016lx, psize: %d, local: %d\n",\r\nslot, vpn, psize, local);\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nlpar_rc = plpar_pte_remove(H_AVPN, slot, want_v, &dummy1, &dummy2);\r\nif (lpar_rc == H_NOT_FOUND)\r\nreturn;\r\nBUG_ON(lpar_rc != H_SUCCESS);\r\n}\r\nstatic void pSeries_lpar_hpte_removebolted(unsigned long ea,\r\nint psize, int ssize)\r\n{\r\nunsigned long vpn;\r\nunsigned long slot, vsid;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nslot = pSeries_lpar_hpte_find(vpn, psize, ssize);\r\nBUG_ON(slot == -1);\r\npSeries_lpar_hpte_invalidate(slot, vpn, psize, ssize, 0);\r\n}\r\nstatic void pSeries_lpar_flush_hash_range(unsigned long number, int local)\r\n{\r\nunsigned long vpn;\r\nunsigned long i, pix, rc;\r\nunsigned long flags = 0;\r\nstruct ppc64_tlb_batch *batch = &__get_cpu_var(ppc64_tlb_batch);\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nunsigned long param[9];\r\nunsigned long hash, index, shift, hidx, slot;\r\nreal_pte_t pte;\r\nint psize, ssize;\r\nif (lock_tlbie)\r\nspin_lock_irqsave(&pSeries_lpar_tlbie_lock, flags);\r\npsize = batch->psize;\r\nssize = batch->ssize;\r\npix = 0;\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize, vpn, index, shift) {\r\nhash = hpt_hash(vpn, shift, ssize);\r\nhidx = __rpte_to_hidx(pte, index);\r\nif (hidx & _PTEIDX_SECONDARY)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += hidx & _PTEIDX_GROUP_IX;\r\nif (!firmware_has_feature(FW_FEATURE_BULK_REMOVE)) {\r\npSeries_lpar_hpte_invalidate(slot, vpn, psize,\r\nssize, local);\r\n} else {\r\nparam[pix] = HBR_REQUEST | HBR_AVPN | slot;\r\nparam[pix+1] = hpte_encode_avpn(vpn, psize,\r\nssize);\r\npix += 2;\r\nif (pix == 8) {\r\nrc = plpar_hcall9(H_BULK_REMOVE, param,\r\nparam[0], param[1], param[2],\r\nparam[3], param[4], param[5],\r\nparam[6], param[7]);\r\nBUG_ON(rc != H_SUCCESS);\r\npix = 0;\r\n}\r\n}\r\n} pte_iterate_hashed_end();\r\n}\r\nif (pix) {\r\nparam[pix] = HBR_END;\r\nrc = plpar_hcall9(H_BULK_REMOVE, param, param[0], param[1],\r\nparam[2], param[3], param[4], param[5],\r\nparam[6], param[7]);\r\nBUG_ON(rc != H_SUCCESS);\r\n}\r\nif (lock_tlbie)\r\nspin_unlock_irqrestore(&pSeries_lpar_tlbie_lock, flags);\r\n}\r\nstatic int __init disable_bulk_remove(char *str)\r\n{\r\nif (strcmp(str, "off") == 0 &&\r\nfirmware_has_feature(FW_FEATURE_BULK_REMOVE)) {\r\nprintk(KERN_INFO "Disabling BULK_REMOVE firmware feature");\r\npowerpc_firmware_features &= ~FW_FEATURE_BULK_REMOVE;\r\n}\r\nreturn 1;\r\n}\r\nvoid __init hpte_init_lpar(void)\r\n{\r\nppc_md.hpte_invalidate = pSeries_lpar_hpte_invalidate;\r\nppc_md.hpte_updatepp = pSeries_lpar_hpte_updatepp;\r\nppc_md.hpte_updateboltedpp = pSeries_lpar_hpte_updateboltedpp;\r\nppc_md.hpte_insert = pSeries_lpar_hpte_insert;\r\nppc_md.hpte_remove = pSeries_lpar_hpte_remove;\r\nppc_md.hpte_removebolted = pSeries_lpar_hpte_removebolted;\r\nppc_md.flush_hash_range = pSeries_lpar_flush_hash_range;\r\nppc_md.hpte_clear_all = pSeries_lpar_hptab_clear;\r\n}\r\nstatic int __init cmo_free_hint(char *str)\r\n{\r\nchar *parm;\r\nparm = strstrip(str);\r\nif (strcasecmp(parm, "no") == 0 || strcasecmp(parm, "off") == 0) {\r\nprintk(KERN_INFO "cmo_free_hint: CMO free page hinting is not active.\n");\r\ncmo_free_hint_flag = 0;\r\nreturn 1;\r\n}\r\ncmo_free_hint_flag = 1;\r\nprintk(KERN_INFO "cmo_free_hint: CMO free page hinting is active.\n");\r\nif (strcasecmp(parm, "yes") == 0 || strcasecmp(parm, "on") == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pSeries_set_page_state(struct page *page, int order,\r\nunsigned long state)\r\n{\r\nint i, j;\r\nunsigned long cmo_page_sz, addr;\r\ncmo_page_sz = cmo_get_page_size();\r\naddr = __pa((unsigned long)page_address(page));\r\nfor (i = 0; i < (1 << order); i++, addr += PAGE_SIZE) {\r\nfor (j = 0; j < PAGE_SIZE; j += cmo_page_sz)\r\nplpar_hcall_norets(H_PAGE_INIT, state, addr + j, 0);\r\n}\r\n}\r\nvoid arch_free_page(struct page *page, int order)\r\n{\r\nif (!cmo_free_hint_flag || !firmware_has_feature(FW_FEATURE_CMO))\r\nreturn;\r\npSeries_set_page_state(page, order, H_PAGE_SET_UNUSED);\r\n}\r\nvoid hcall_tracepoint_regfunc(void)\r\n{\r\nhcall_tracepoint_refcount++;\r\n}\r\nvoid hcall_tracepoint_unregfunc(void)\r\n{\r\nhcall_tracepoint_refcount--;\r\n}\r\nvoid __trace_hcall_entry(unsigned long opcode, unsigned long *args)\r\n{\r\nunsigned long flags;\r\nunsigned int *depth;\r\nif (opcode == H_CEDE)\r\nreturn;\r\nlocal_irq_save(flags);\r\ndepth = &__get_cpu_var(hcall_trace_depth);\r\nif (*depth)\r\ngoto out;\r\n(*depth)++;\r\npreempt_disable();\r\ntrace_hcall_entry(opcode, args);\r\n(*depth)--;\r\nout:\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __trace_hcall_exit(long opcode, unsigned long retval,\r\nunsigned long *retbuf)\r\n{\r\nunsigned long flags;\r\nunsigned int *depth;\r\nif (opcode == H_CEDE)\r\nreturn;\r\nlocal_irq_save(flags);\r\ndepth = &__get_cpu_var(hcall_trace_depth);\r\nif (*depth)\r\ngoto out;\r\n(*depth)++;\r\ntrace_hcall_exit(opcode, retval, retbuf);\r\npreempt_enable();\r\n(*depth)--;\r\nout:\r\nlocal_irq_restore(flags);\r\n}\r\nint h_get_mpp(struct hvcall_mpp_data *mpp_data)\r\n{\r\nint rc;\r\nunsigned long retbuf[PLPAR_HCALL9_BUFSIZE];\r\nrc = plpar_hcall9(H_GET_MPP, retbuf);\r\nmpp_data->entitled_mem = retbuf[0];\r\nmpp_data->mapped_mem = retbuf[1];\r\nmpp_data->group_num = (retbuf[2] >> 2 * 8) & 0xffff;\r\nmpp_data->pool_num = retbuf[2] & 0xffff;\r\nmpp_data->mem_weight = (retbuf[3] >> 7 * 8) & 0xff;\r\nmpp_data->unallocated_mem_weight = (retbuf[3] >> 6 * 8) & 0xff;\r\nmpp_data->unallocated_entitlement = retbuf[3] & 0xffffffffffff;\r\nmpp_data->pool_size = retbuf[4];\r\nmpp_data->loan_request = retbuf[5];\r\nmpp_data->backing_mem = retbuf[6];\r\nreturn rc;\r\n}\r\nint h_get_mpp_x(struct hvcall_mpp_x_data *mpp_x_data)\r\n{\r\nint rc;\r\nunsigned long retbuf[PLPAR_HCALL9_BUFSIZE] = { 0 };\r\nrc = plpar_hcall9(H_GET_MPP_X, retbuf);\r\nmpp_x_data->coalesced_bytes = retbuf[0];\r\nmpp_x_data->pool_coalesced_bytes = retbuf[1];\r\nmpp_x_data->pool_purr_cycles = retbuf[2];\r\nmpp_x_data->pool_spurr_cycles = retbuf[3];\r\nreturn rc;\r\n}
