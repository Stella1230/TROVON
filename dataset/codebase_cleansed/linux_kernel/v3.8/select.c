static long __estimate_accuracy(struct timespec *tv)\r\n{\r\nlong slack;\r\nint divfactor = 1000;\r\nif (tv->tv_sec < 0)\r\nreturn 0;\r\nif (task_nice(current) > 0)\r\ndivfactor = divfactor / 5;\r\nif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\r\nreturn MAX_SLACK;\r\nslack = tv->tv_nsec / divfactor;\r\nslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\r\nif (slack > MAX_SLACK)\r\nreturn MAX_SLACK;\r\nreturn slack;\r\n}\r\nlong select_estimate_accuracy(struct timespec *tv)\r\n{\r\nunsigned long ret;\r\nstruct timespec now;\r\nif (rt_task(current))\r\nreturn 0;\r\nktime_get_ts(&now);\r\nnow = timespec_sub(*tv, now);\r\nret = __estimate_accuracy(&now);\r\nif (ret < current->timer_slack_ns)\r\nreturn current->timer_slack_ns;\r\nreturn ret;\r\n}\r\nvoid poll_initwait(struct poll_wqueues *pwq)\r\n{\r\ninit_poll_funcptr(&pwq->pt, __pollwait);\r\npwq->polling_task = current;\r\npwq->triggered = 0;\r\npwq->error = 0;\r\npwq->table = NULL;\r\npwq->inline_index = 0;\r\n}\r\nstatic void free_poll_entry(struct poll_table_entry *entry)\r\n{\r\nremove_wait_queue(entry->wait_address, &entry->wait);\r\nfput(entry->filp);\r\n}\r\nvoid poll_freewait(struct poll_wqueues *pwq)\r\n{\r\nstruct poll_table_page * p = pwq->table;\r\nint i;\r\nfor (i = 0; i < pwq->inline_index; i++)\r\nfree_poll_entry(pwq->inline_entries + i);\r\nwhile (p) {\r\nstruct poll_table_entry * entry;\r\nstruct poll_table_page *old;\r\nentry = p->entry;\r\ndo {\r\nentry--;\r\nfree_poll_entry(entry);\r\n} while (entry > p->entries);\r\nold = p;\r\np = p->next;\r\nfree_page((unsigned long) old);\r\n}\r\n}\r\nstatic struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\r\n{\r\nstruct poll_table_page *table = p->table;\r\nif (p->inline_index < N_INLINE_POLL_ENTRIES)\r\nreturn p->inline_entries + p->inline_index++;\r\nif (!table || POLL_TABLE_FULL(table)) {\r\nstruct poll_table_page *new_table;\r\nnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\r\nif (!new_table) {\r\np->error = -ENOMEM;\r\nreturn NULL;\r\n}\r\nnew_table->entry = new_table->entries;\r\nnew_table->next = table;\r\np->table = new_table;\r\ntable = new_table;\r\n}\r\nreturn table->entry++;\r\n}\r\nstatic int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\r\n{\r\nstruct poll_wqueues *pwq = wait->private;\r\nDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\r\nsmp_wmb();\r\npwq->triggered = 1;\r\nreturn default_wake_function(&dummy_wait, mode, sync, key);\r\n}\r\nstatic int pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)\r\n{\r\nstruct poll_table_entry *entry;\r\nentry = container_of(wait, struct poll_table_entry, wait);\r\nif (key && !((unsigned long)key & entry->key))\r\nreturn 0;\r\nreturn __pollwake(wait, mode, sync, key);\r\n}\r\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\r\npoll_table *p)\r\n{\r\nstruct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);\r\nstruct poll_table_entry *entry = poll_get_entry(pwq);\r\nif (!entry)\r\nreturn;\r\nentry->filp = get_file(filp);\r\nentry->wait_address = wait_address;\r\nentry->key = p->_key;\r\ninit_waitqueue_func_entry(&entry->wait, pollwake);\r\nentry->wait.private = pwq;\r\nadd_wait_queue(wait_address, &entry->wait);\r\n}\r\nint poll_schedule_timeout(struct poll_wqueues *pwq, int state,\r\nktime_t *expires, unsigned long slack)\r\n{\r\nint rc = -EINTR;\r\nset_current_state(state);\r\nif (!pwq->triggered)\r\nrc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\r\n__set_current_state(TASK_RUNNING);\r\nset_mb(pwq->triggered, 0);\r\nreturn rc;\r\n}\r\nint poll_select_set_timeout(struct timespec *to, long sec, long nsec)\r\n{\r\nstruct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\r\nif (!timespec_valid(&ts))\r\nreturn -EINVAL;\r\nif (!sec && !nsec) {\r\nto->tv_sec = to->tv_nsec = 0;\r\n} else {\r\nktime_get_ts(to);\r\n*to = timespec_add_safe(*to, ts);\r\n}\r\nreturn 0;\r\n}\r\nstatic int poll_select_copy_remaining(struct timespec *end_time, void __user *p,\r\nint timeval, int ret)\r\n{\r\nstruct timespec rts;\r\nstruct timeval rtv;\r\nif (!p)\r\nreturn ret;\r\nif (current->personality & STICKY_TIMEOUTS)\r\ngoto sticky;\r\nif (!end_time->tv_sec && !end_time->tv_nsec)\r\nreturn ret;\r\nktime_get_ts(&rts);\r\nrts = timespec_sub(*end_time, rts);\r\nif (rts.tv_sec < 0)\r\nrts.tv_sec = rts.tv_nsec = 0;\r\nif (timeval) {\r\nif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\r\nmemset(&rtv, 0, sizeof(rtv));\r\nrtv.tv_sec = rts.tv_sec;\r\nrtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\r\nif (!copy_to_user(p, &rtv, sizeof(rtv)))\r\nreturn ret;\r\n} else if (!copy_to_user(p, &rts, sizeof(rts)))\r\nreturn ret;\r\nsticky:\r\nif (ret == -ERESTARTNOHAND)\r\nret = -EINTR;\r\nreturn ret;\r\n}\r\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\r\n{\r\nunsigned long *open_fds;\r\nunsigned long set;\r\nint max;\r\nstruct fdtable *fdt;\r\nset = ~(~0UL << (n & (BITS_PER_LONG-1)));\r\nn /= BITS_PER_LONG;\r\nfdt = files_fdtable(current->files);\r\nopen_fds = fdt->open_fds + n;\r\nmax = 0;\r\nif (set) {\r\nset &= BITS(fds, n);\r\nif (set) {\r\nif (!(set & ~*open_fds))\r\ngoto get_max;\r\nreturn -EBADF;\r\n}\r\n}\r\nwhile (n) {\r\nopen_fds--;\r\nn--;\r\nset = BITS(fds, n);\r\nif (!set)\r\ncontinue;\r\nif (set & ~*open_fds)\r\nreturn -EBADF;\r\nif (max)\r\ncontinue;\r\nget_max:\r\ndo {\r\nmax++;\r\nset >>= 1;\r\n} while (set);\r\nmax += n * BITS_PER_LONG;\r\n}\r\nreturn max;\r\n}\r\nstatic inline void wait_key_set(poll_table *wait, unsigned long in,\r\nunsigned long out, unsigned long bit)\r\n{\r\nwait->_key = POLLEX_SET;\r\nif (in & bit)\r\nwait->_key |= POLLIN_SET;\r\nif (out & bit)\r\nwait->_key |= POLLOUT_SET;\r\n}\r\nint do_select(int n, fd_set_bits *fds, struct timespec *end_time)\r\n{\r\nktime_t expire, *to = NULL;\r\nstruct poll_wqueues table;\r\npoll_table *wait;\r\nint retval, i, timed_out = 0;\r\nunsigned long slack = 0;\r\nrcu_read_lock();\r\nretval = max_select_fd(n, fds);\r\nrcu_read_unlock();\r\nif (retval < 0)\r\nreturn retval;\r\nn = retval;\r\npoll_initwait(&table);\r\nwait = &table.pt;\r\nif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\r\nwait->_qproc = NULL;\r\ntimed_out = 1;\r\n}\r\nif (end_time && !timed_out)\r\nslack = select_estimate_accuracy(end_time);\r\nretval = 0;\r\nfor (;;) {\r\nunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\r\ninp = fds->in; outp = fds->out; exp = fds->ex;\r\nrinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\r\nfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\r\nunsigned long in, out, ex, all_bits, bit = 1, mask, j;\r\nunsigned long res_in = 0, res_out = 0, res_ex = 0;\r\nin = *inp++; out = *outp++; ex = *exp++;\r\nall_bits = in | out | ex;\r\nif (all_bits == 0) {\r\ni += BITS_PER_LONG;\r\ncontinue;\r\n}\r\nfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\r\nstruct fd f;\r\nif (i >= n)\r\nbreak;\r\nif (!(bit & all_bits))\r\ncontinue;\r\nf = fdget(i);\r\nif (f.file) {\r\nconst struct file_operations *f_op;\r\nf_op = f.file->f_op;\r\nmask = DEFAULT_POLLMASK;\r\nif (f_op && f_op->poll) {\r\nwait_key_set(wait, in, out, bit);\r\nmask = (*f_op->poll)(f.file, wait);\r\n}\r\nfdput(f);\r\nif ((mask & POLLIN_SET) && (in & bit)) {\r\nres_in |= bit;\r\nretval++;\r\nwait->_qproc = NULL;\r\n}\r\nif ((mask & POLLOUT_SET) && (out & bit)) {\r\nres_out |= bit;\r\nretval++;\r\nwait->_qproc = NULL;\r\n}\r\nif ((mask & POLLEX_SET) && (ex & bit)) {\r\nres_ex |= bit;\r\nretval++;\r\nwait->_qproc = NULL;\r\n}\r\n}\r\n}\r\nif (res_in)\r\n*rinp = res_in;\r\nif (res_out)\r\n*routp = res_out;\r\nif (res_ex)\r\n*rexp = res_ex;\r\ncond_resched();\r\n}\r\nwait->_qproc = NULL;\r\nif (retval || timed_out || signal_pending(current))\r\nbreak;\r\nif (table.error) {\r\nretval = table.error;\r\nbreak;\r\n}\r\nif (end_time && !to) {\r\nexpire = timespec_to_ktime(*end_time);\r\nto = &expire;\r\n}\r\nif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\r\nto, slack))\r\ntimed_out = 1;\r\n}\r\npoll_freewait(&table);\r\nreturn retval;\r\n}\r\nint core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\r\nfd_set __user *exp, struct timespec *end_time)\r\n{\r\nfd_set_bits fds;\r\nvoid *bits;\r\nint ret, max_fds;\r\nunsigned int size;\r\nstruct fdtable *fdt;\r\nlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\r\nret = -EINVAL;\r\nif (n < 0)\r\ngoto out_nofds;\r\nrcu_read_lock();\r\nfdt = files_fdtable(current->files);\r\nmax_fds = fdt->max_fds;\r\nrcu_read_unlock();\r\nif (n > max_fds)\r\nn = max_fds;\r\nsize = FDS_BYTES(n);\r\nbits = stack_fds;\r\nif (size > sizeof(stack_fds) / 6) {\r\nret = -ENOMEM;\r\nbits = kmalloc(6 * size, GFP_KERNEL);\r\nif (!bits)\r\ngoto out_nofds;\r\n}\r\nfds.in = bits;\r\nfds.out = bits + size;\r\nfds.ex = bits + 2*size;\r\nfds.res_in = bits + 3*size;\r\nfds.res_out = bits + 4*size;\r\nfds.res_ex = bits + 5*size;\r\nif ((ret = get_fd_set(n, inp, fds.in)) ||\r\n(ret = get_fd_set(n, outp, fds.out)) ||\r\n(ret = get_fd_set(n, exp, fds.ex)))\r\ngoto out;\r\nzero_fd_set(n, fds.res_in);\r\nzero_fd_set(n, fds.res_out);\r\nzero_fd_set(n, fds.res_ex);\r\nret = do_select(n, &fds, end_time);\r\nif (ret < 0)\r\ngoto out;\r\nif (!ret) {\r\nret = -ERESTARTNOHAND;\r\nif (signal_pending(current))\r\ngoto out;\r\nret = 0;\r\n}\r\nif (set_fd_set(n, inp, fds.res_in) ||\r\nset_fd_set(n, outp, fds.res_out) ||\r\nset_fd_set(n, exp, fds.res_ex))\r\nret = -EFAULT;\r\nout:\r\nif (bits != stack_fds)\r\nkfree(bits);\r\nout_nofds:\r\nreturn ret;\r\n}\r\nstatic long do_pselect(int n, fd_set __user *inp, fd_set __user *outp,\r\nfd_set __user *exp, struct timespec __user *tsp,\r\nconst sigset_t __user *sigmask, size_t sigsetsize)\r\n{\r\nsigset_t ksigmask, sigsaved;\r\nstruct timespec ts, end_time, *to = NULL;\r\nint ret;\r\nif (tsp) {\r\nif (copy_from_user(&ts, tsp, sizeof(ts)))\r\nreturn -EFAULT;\r\nto = &end_time;\r\nif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\r\nreturn -EINVAL;\r\n}\r\nif (sigmask) {\r\nif (sigsetsize != sizeof(sigset_t))\r\nreturn -EINVAL;\r\nif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\r\nreturn -EFAULT;\r\nsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\r\nsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\r\n}\r\nret = core_sys_select(n, inp, outp, exp, to);\r\nret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\r\nif (ret == -ERESTARTNOHAND) {\r\nif (sigmask) {\r\nmemcpy(&current->saved_sigmask, &sigsaved,\r\nsizeof(sigsaved));\r\nset_restore_sigmask();\r\n}\r\n} else if (sigmask)\r\nsigprocmask(SIG_SETMASK, &sigsaved, NULL);\r\nreturn ret;\r\n}\r\nstatic inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait)\r\n{\r\nunsigned int mask;\r\nint fd;\r\nmask = 0;\r\nfd = pollfd->fd;\r\nif (fd >= 0) {\r\nstruct fd f = fdget(fd);\r\nmask = POLLNVAL;\r\nif (f.file) {\r\nmask = DEFAULT_POLLMASK;\r\nif (f.file->f_op && f.file->f_op->poll) {\r\npwait->_key = pollfd->events|POLLERR|POLLHUP;\r\nmask = f.file->f_op->poll(f.file, pwait);\r\n}\r\nmask &= pollfd->events | POLLERR | POLLHUP;\r\nfdput(f);\r\n}\r\n}\r\npollfd->revents = mask;\r\nreturn mask;\r\n}\r\nstatic int do_poll(unsigned int nfds, struct poll_list *list,\r\nstruct poll_wqueues *wait, struct timespec *end_time)\r\n{\r\npoll_table* pt = &wait->pt;\r\nktime_t expire, *to = NULL;\r\nint timed_out = 0, count = 0;\r\nunsigned long slack = 0;\r\nif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\r\npt->_qproc = NULL;\r\ntimed_out = 1;\r\n}\r\nif (end_time && !timed_out)\r\nslack = select_estimate_accuracy(end_time);\r\nfor (;;) {\r\nstruct poll_list *walk;\r\nfor (walk = list; walk != NULL; walk = walk->next) {\r\nstruct pollfd * pfd, * pfd_end;\r\npfd = walk->entries;\r\npfd_end = pfd + walk->len;\r\nfor (; pfd != pfd_end; pfd++) {\r\nif (do_pollfd(pfd, pt)) {\r\ncount++;\r\npt->_qproc = NULL;\r\n}\r\n}\r\n}\r\npt->_qproc = NULL;\r\nif (!count) {\r\ncount = wait->error;\r\nif (signal_pending(current))\r\ncount = -EINTR;\r\n}\r\nif (count || timed_out)\r\nbreak;\r\nif (end_time && !to) {\r\nexpire = timespec_to_ktime(*end_time);\r\nto = &expire;\r\n}\r\nif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\r\ntimed_out = 1;\r\n}\r\nreturn count;\r\n}\r\nint do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\r\nstruct timespec *end_time)\r\n{\r\nstruct poll_wqueues table;\r\nint err = -EFAULT, fdcount, len, size;\r\nlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\r\nstruct poll_list *const head = (struct poll_list *)stack_pps;\r\nstruct poll_list *walk = head;\r\nunsigned long todo = nfds;\r\nif (nfds > rlimit(RLIMIT_NOFILE))\r\nreturn -EINVAL;\r\nlen = min_t(unsigned int, nfds, N_STACK_PPS);\r\nfor (;;) {\r\nwalk->next = NULL;\r\nwalk->len = len;\r\nif (!len)\r\nbreak;\r\nif (copy_from_user(walk->entries, ufds + nfds-todo,\r\nsizeof(struct pollfd) * walk->len))\r\ngoto out_fds;\r\ntodo -= walk->len;\r\nif (!todo)\r\nbreak;\r\nlen = min(todo, POLLFD_PER_PAGE);\r\nsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\r\nwalk = walk->next = kmalloc(size, GFP_KERNEL);\r\nif (!walk) {\r\nerr = -ENOMEM;\r\ngoto out_fds;\r\n}\r\n}\r\npoll_initwait(&table);\r\nfdcount = do_poll(nfds, head, &table, end_time);\r\npoll_freewait(&table);\r\nfor (walk = head; walk; walk = walk->next) {\r\nstruct pollfd *fds = walk->entries;\r\nint j;\r\nfor (j = 0; j < walk->len; j++, ufds++)\r\nif (__put_user(fds[j].revents, &ufds->revents))\r\ngoto out_fds;\r\n}\r\nerr = fdcount;\r\nout_fds:\r\nwalk = head->next;\r\nwhile (walk) {\r\nstruct poll_list *pos = walk;\r\nwalk = walk->next;\r\nkfree(pos);\r\n}\r\nreturn err;\r\n}\r\nstatic long do_restart_poll(struct restart_block *restart_block)\r\n{\r\nstruct pollfd __user *ufds = restart_block->poll.ufds;\r\nint nfds = restart_block->poll.nfds;\r\nstruct timespec *to = NULL, end_time;\r\nint ret;\r\nif (restart_block->poll.has_timeout) {\r\nend_time.tv_sec = restart_block->poll.tv_sec;\r\nend_time.tv_nsec = restart_block->poll.tv_nsec;\r\nto = &end_time;\r\n}\r\nret = do_sys_poll(ufds, nfds, to);\r\nif (ret == -EINTR) {\r\nrestart_block->fn = do_restart_poll;\r\nret = -ERESTART_RESTARTBLOCK;\r\n}\r\nreturn ret;\r\n}
