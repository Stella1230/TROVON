static int intelfb_create(struct intel_fbdev *ifbdev,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct drm_device *dev = ifbdev->helper.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_mode_fb_cmd2 mode_cmd = {};\r\nstruct drm_i915_gem_object *obj;\r\nstruct device *device = &dev->pdev->dev;\r\nint size, ret;\r\nif (sizes->surface_bpp == 24)\r\nsizes->surface_bpp = 32;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = ALIGN(mode_cmd.width * ((sizes->surface_bpp + 7) /\r\n8), 64);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nsize = ALIGN(size, PAGE_SIZE);\r\nobj = i915_gem_alloc_object(dev, size);\r\nif (!obj) {\r\nDRM_ERROR("failed to allocate framebuffer\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nret = intel_pin_and_fence_fb_obj(dev, obj, NULL);\r\nif (ret) {\r\nDRM_ERROR("failed to pin fb: %d\n", ret);\r\ngoto out_unref;\r\n}\r\ninfo = framebuffer_alloc(0, device);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out_unpin;\r\n}\r\ninfo->par = ifbdev;\r\nret = intel_framebuffer_init(dev, &ifbdev->ifb, &mode_cmd, obj);\r\nif (ret)\r\ngoto out_unpin;\r\nfb = &ifbdev->ifb.base;\r\nifbdev->helper.fb = fb;\r\nifbdev->helper.fbdev = info;\r\nstrcpy(info->fix.id, "inteldrmfb");\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_CAN_FORCE_OUTPUT;\r\ninfo->fbops = &intelfb_ops;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto out_unpin;\r\n}\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto out_unpin;\r\n}\r\ninfo->apertures->ranges[0].base = dev->mode_config.fb_base;\r\ninfo->apertures->ranges[0].size =\r\ndev_priv->mm.gtt->gtt_mappable_entries << PAGE_SHIFT;\r\ninfo->fix.smem_start = dev->mode_config.fb_base + obj->gtt_offset;\r\ninfo->fix.smem_len = size;\r\ninfo->screen_base =\r\nioremap_wc(dev_priv->mm.gtt_base_addr + obj->gtt_offset,\r\nsize);\r\nif (!info->screen_base) {\r\nret = -ENOSPC;\r\ngoto out_unpin;\r\n}\r\ninfo->screen_size = size;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &ifbdev->helper, sizes->fb_width, sizes->fb_height);\r\nDRM_DEBUG_KMS("allocated %dx%d fb: 0x%08x, bo %p\n",\r\nfb->width, fb->height,\r\nobj->gtt_offset, obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nvga_switcheroo_client_fb_set(dev->pdev, info);\r\nreturn 0;\r\nout_unpin:\r\ni915_gem_object_unpin(obj);\r\nout_unref:\r\ndrm_gem_object_unreference(&obj->base);\r\nmutex_unlock(&dev->struct_mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int intel_fb_find_or_create_single(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct intel_fbdev *ifbdev = (struct intel_fbdev *)helper;\r\nint new_fb = 0;\r\nint ret;\r\nif (!helper->fb) {\r\nret = intelfb_create(ifbdev, sizes);\r\nif (ret)\r\nreturn ret;\r\nnew_fb = 1;\r\n}\r\nreturn new_fb;\r\n}\r\nstatic void intel_fbdev_destroy(struct drm_device *dev,\r\nstruct intel_fbdev *ifbdev)\r\n{\r\nstruct fb_info *info;\r\nstruct intel_framebuffer *ifb = &ifbdev->ifb;\r\nif (ifbdev->helper.fbdev) {\r\ninfo = ifbdev->helper.fbdev;\r\nunregister_framebuffer(info);\r\niounmap(info->screen_base);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\ndrm_fb_helper_fini(&ifbdev->helper);\r\ndrm_framebuffer_cleanup(&ifb->base);\r\nif (ifb->obj) {\r\ndrm_gem_object_unreference_unlocked(&ifb->obj->base);\r\nifb->obj = NULL;\r\n}\r\n}\r\nint intel_fbdev_init(struct drm_device *dev)\r\n{\r\nstruct intel_fbdev *ifbdev;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nint ret;\r\nifbdev = kzalloc(sizeof(struct intel_fbdev), GFP_KERNEL);\r\nif (!ifbdev)\r\nreturn -ENOMEM;\r\ndev_priv->fbdev = ifbdev;\r\nifbdev->helper.funcs = &intel_fb_helper_funcs;\r\nret = drm_fb_helper_init(dev, &ifbdev->helper,\r\ndev_priv->num_pipe,\r\nINTELFB_CONN_LIMIT);\r\nif (ret) {\r\nkfree(ifbdev);\r\nreturn ret;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(&ifbdev->helper);\r\ndrm_fb_helper_initial_config(&ifbdev->helper, 32);\r\nreturn 0;\r\n}\r\nvoid intel_fbdev_fini(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nif (!dev_priv->fbdev)\r\nreturn;\r\nintel_fbdev_destroy(dev, dev_priv->fbdev);\r\nkfree(dev_priv->fbdev);\r\ndev_priv->fbdev = NULL;\r\n}\r\nvoid intel_fbdev_set_suspend(struct drm_device *dev, int state)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nif (!dev_priv->fbdev)\r\nreturn;\r\nfb_set_suspend(dev_priv->fbdev->helper.fbdev, state);\r\n}\r\nvoid intel_fb_output_poll_changed(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\ndrm_fb_helper_hotplug_event(&dev_priv->fbdev->helper);\r\n}\r\nvoid intel_fb_restore_mode(struct drm_device *dev)\r\n{\r\nint ret;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_mode_config *config = &dev->mode_config;\r\nstruct drm_plane *plane;\r\nmutex_lock(&dev->mode_config.mutex);\r\nret = drm_fb_helper_restore_fbdev_mode(&dev_priv->fbdev->helper);\r\nif (ret)\r\nDRM_DEBUG("failed to restore crtc mode\n");\r\nlist_for_each_entry(plane, &config->plane_list, head)\r\nplane->funcs->disable_plane(plane);\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}
