static inline int i2c_slave_did_write_ack(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\nreturn au0828_read(dev, AU0828_I2C_STATUS_201) &\r\nAU0828_I2C_STATUS_NO_WRITE_ACK ? 0 : 1;\r\n}\r\nstatic inline int i2c_slave_did_read_ack(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\nreturn au0828_read(dev, AU0828_I2C_STATUS_201) &\r\nAU0828_I2C_STATUS_NO_READ_ACK ? 0 : 1;\r\n}\r\nstatic int i2c_wait_read_ack(struct i2c_adapter *i2c_adap)\r\n{\r\nint count;\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nif (!i2c_slave_did_read_ack(i2c_adap))\r\nbreak;\r\nudelay(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int i2c_is_read_busy(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\nreturn au0828_read(dev, AU0828_I2C_STATUS_201) &\r\nAU0828_I2C_STATUS_READ_DONE ? 0 : 1;\r\n}\r\nstatic int i2c_wait_read_done(struct i2c_adapter *i2c_adap)\r\n{\r\nint count;\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nif (!i2c_is_read_busy(i2c_adap))\r\nbreak;\r\nudelay(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int i2c_is_write_done(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\nreturn au0828_read(dev, AU0828_I2C_STATUS_201) &\r\nAU0828_I2C_STATUS_WRITE_DONE ? 1 : 0;\r\n}\r\nstatic int i2c_wait_write_done(struct i2c_adapter *i2c_adap)\r\n{\r\nint count;\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nif (i2c_is_write_done(i2c_adap))\r\nbreak;\r\nudelay(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int i2c_is_busy(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\nreturn au0828_read(dev, AU0828_I2C_STATUS_201) &\r\nAU0828_I2C_STATUS_BUSY ? 1 : 0;\r\n}\r\nstatic int i2c_wait_done(struct i2c_adapter *i2c_adap)\r\n{\r\nint count;\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nif (!i2c_is_busy(i2c_adap))\r\nbreak;\r\nudelay(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int i2c_sendbytes(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg, int joined_rlen)\r\n{\r\nint i, strobe = 0;\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\ndprintk(4, "%s()\n", __func__);\r\nau0828_write(dev, AU0828_I2C_MULTIBYTE_MODE_2FF, 0x01);\r\nif (((dev->board.tuner_type == TUNER_XC5000) ||\r\n(dev->board.tuner_type == TUNER_XC5000C)) &&\r\n(dev->board.tuner_addr == msg->addr) &&\r\n(msg->len == 64)) {\r\nau0828_write(dev, AU0828_I2C_CLK_DIVIDER_202,\r\nAU0828_I2C_CLK_250KHZ);\r\n} else {\r\nau0828_write(dev, AU0828_I2C_CLK_DIVIDER_202,\r\ndev->board.i2c_clk_divider);\r\n}\r\nau0828_write(dev, AU0828_I2C_DEST_ADDR_203, msg->addr << 1);\r\ndprintk(4, "SEND: %02x\n", msg->addr);\r\nif (msg->len == 0) {\r\nau0828_write(dev, AU0828_I2C_TRIGGER_200,\r\nAU0828_I2C_TRIGGER_READ);\r\nif (!i2c_wait_done(i2c_adap))\r\nreturn -EIO;\r\nif (i2c_wait_read_ack(i2c_adap))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < msg->len;) {\r\ndprintk(4, " %02x\n", msg->buf[i]);\r\nau0828_write(dev, AU0828_I2C_WRITE_FIFO_205, msg->buf[i]);\r\nstrobe++;\r\ni++;\r\nif ((strobe >= 4) || (i >= msg->len)) {\r\nif (i < msg->len)\r\nau0828_write(dev, AU0828_I2C_TRIGGER_200,\r\nAU0828_I2C_TRIGGER_WRITE |\r\nAU0828_I2C_TRIGGER_HOLD);\r\nelse\r\nau0828_write(dev, AU0828_I2C_TRIGGER_200,\r\nAU0828_I2C_TRIGGER_WRITE);\r\nstrobe = 0;\r\nif (!i2c_wait_write_done(i2c_adap))\r\nreturn -EIO;\r\n}\r\n}\r\nif (!i2c_wait_done(i2c_adap))\r\nreturn -EIO;\r\ndprintk(4, "\n");\r\nreturn msg->len;\r\n}\r\nstatic int i2c_readbytes(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg, int joined)\r\n{\r\nstruct au0828_dev *dev = i2c_adap->algo_data;\r\nint i;\r\ndprintk(4, "%s()\n", __func__);\r\nau0828_write(dev, AU0828_I2C_MULTIBYTE_MODE_2FF, 0x01);\r\nau0828_write(dev, AU0828_I2C_CLK_DIVIDER_202,\r\ndev->board.i2c_clk_divider);\r\nau0828_write(dev, AU0828_I2C_DEST_ADDR_203, msg->addr << 1);\r\ndprintk(4, " RECV:\n");\r\nif (msg->len == 0) {\r\nau0828_write(dev, AU0828_I2C_TRIGGER_200,\r\nAU0828_I2C_TRIGGER_READ);\r\nif (i2c_wait_read_ack(i2c_adap))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < msg->len;) {\r\ni++;\r\nif (i < msg->len)\r\nau0828_write(dev, AU0828_I2C_TRIGGER_200,\r\nAU0828_I2C_TRIGGER_READ |\r\nAU0828_I2C_TRIGGER_HOLD);\r\nelse\r\nau0828_write(dev, AU0828_I2C_TRIGGER_200,\r\nAU0828_I2C_TRIGGER_READ);\r\nif (!i2c_wait_read_done(i2c_adap))\r\nreturn -EIO;\r\nmsg->buf[i-1] = au0828_read(dev, AU0828_I2C_READ_FIFO_209) &\r\n0xff;\r\ndprintk(4, " %02x\n", msg->buf[i-1]);\r\n}\r\nif (!i2c_wait_done(i2c_adap))\r\nreturn -EIO;\r\ndprintk(4, "\n");\r\nreturn msg->len;\r\n}\r\nstatic int i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nint i, retval = 0;\r\ndprintk(4, "%s(num = %d)\n", __func__, num);\r\nfor (i = 0; i < num; i++) {\r\ndprintk(4, "%s(num = %d) addr = 0x%02x len = 0x%x\n",\r\n__func__, num, msgs[i].addr, msgs[i].len);\r\nif (msgs[i].flags & I2C_M_RD) {\r\nretval = i2c_readbytes(i2c_adap, &msgs[i], 0);\r\n} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\r\nmsgs[i].addr == msgs[i + 1].addr) {\r\nretval = i2c_sendbytes(i2c_adap, &msgs[i],\r\nmsgs[i + 1].len);\r\nif (retval < 0)\r\ngoto err;\r\ni++;\r\nretval = i2c_readbytes(i2c_adap, &msgs[i], 1);\r\n} else {\r\nretval = i2c_sendbytes(i2c_adap, &msgs[i], 0);\r\n}\r\nif (retval < 0)\r\ngoto err;\r\n}\r\nreturn num;\r\nerr:\r\nreturn retval;\r\n}\r\nstatic u32 au0828_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\r\n}\r\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\r\n{\r\nunsigned char buf;\r\nint i, rc;\r\nfor (i = 0; i < 128; i++) {\r\nc->addr = i;\r\nrc = i2c_master_recv(c, &buf, 0);\r\nif (rc < 0)\r\ncontinue;\r\nprintk(KERN_INFO "%s: i2c scan: found device @ 0x%x [%s]\n",\r\nname, i << 1, i2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\n}\r\nint au0828_i2c_register(struct au0828_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nmemcpy(&dev->i2c_adap, &au0828_i2c_adap_template,\r\nsizeof(dev->i2c_adap));\r\nmemcpy(&dev->i2c_algo, &au0828_i2c_algo_template,\r\nsizeof(dev->i2c_algo));\r\nmemcpy(&dev->i2c_client, &au0828_i2c_client_template,\r\nsizeof(dev->i2c_client));\r\ndev->i2c_adap.dev.parent = &dev->usbdev->dev;\r\nstrlcpy(dev->i2c_adap.name, DRIVER_NAME,\r\nsizeof(dev->i2c_adap.name));\r\ndev->i2c_adap.algo = &dev->i2c_algo;\r\ndev->i2c_adap.algo_data = dev;\r\ni2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\r\ni2c_add_adapter(&dev->i2c_adap);\r\ndev->i2c_client.adapter = &dev->i2c_adap;\r\nif (0 == dev->i2c_rc) {\r\nprintk(KERN_INFO "%s: i2c bus registered\n", DRIVER_NAME);\r\nif (i2c_scan)\r\ndo_i2c_scan(DRIVER_NAME, &dev->i2c_client);\r\n} else\r\nprintk(KERN_INFO "%s: i2c bus register FAILED\n", DRIVER_NAME);\r\nreturn dev->i2c_rc;\r\n}\r\nint au0828_i2c_unregister(struct au0828_dev *dev)\r\n{\r\ni2c_del_adapter(&dev->i2c_adap);\r\nreturn 0;\r\n}
