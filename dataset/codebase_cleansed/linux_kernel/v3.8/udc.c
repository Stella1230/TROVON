static inline int hw_ep_bit(int num, int dir)\r\n{\r\nreturn num + (dir ? 16 : 0);\r\n}\r\nstatic inline int ep_to_bit(struct ci13xxx *ci, int n)\r\n{\r\nint fill = 16 - ci->hw_ep_max / 2;\r\nif (n >= ci->hw_ep_max / 2)\r\nn += fill;\r\nreturn n;\r\n}\r\nstatic int hw_device_state(struct ci13xxx *ci, u32 dma)\r\n{\r\nif (dma) {\r\nhw_write(ci, OP_ENDPTLISTADDR, ~0, dma);\r\nhw_write(ci, OP_USBINTR, ~0,\r\nUSBi_UI|USBi_UEI|USBi_PCI|USBi_URI|USBi_SLI);\r\n} else {\r\nhw_write(ci, OP_USBINTR, ~0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_ep_flush(struct ci13xxx *ci, int num, int dir)\r\n{\r\nint n = hw_ep_bit(num, dir);\r\ndo {\r\nhw_write(ci, OP_ENDPTFLUSH, BIT(n), BIT(n));\r\nwhile (hw_read(ci, OP_ENDPTFLUSH, BIT(n)))\r\ncpu_relax();\r\n} while (hw_read(ci, OP_ENDPTSTAT, BIT(n)));\r\nreturn 0;\r\n}\r\nstatic int hw_ep_disable(struct ci13xxx *ci, int num, int dir)\r\n{\r\nhw_ep_flush(ci, num, dir);\r\nhw_write(ci, OP_ENDPTCTRL + num,\r\ndir ? ENDPTCTRL_TXE : ENDPTCTRL_RXE, 0);\r\nreturn 0;\r\n}\r\nstatic int hw_ep_enable(struct ci13xxx *ci, int num, int dir, int type)\r\n{\r\nu32 mask, data;\r\nif (dir) {\r\nmask = ENDPTCTRL_TXT;\r\ndata = type << ffs_nr(mask);\r\nmask |= ENDPTCTRL_TXS;\r\nmask |= ENDPTCTRL_TXR;\r\ndata |= ENDPTCTRL_TXR;\r\nmask |= ENDPTCTRL_TXE;\r\ndata |= ENDPTCTRL_TXE;\r\n} else {\r\nmask = ENDPTCTRL_RXT;\r\ndata = type << ffs_nr(mask);\r\nmask |= ENDPTCTRL_RXS;\r\nmask |= ENDPTCTRL_RXR;\r\ndata |= ENDPTCTRL_RXR;\r\nmask |= ENDPTCTRL_RXE;\r\ndata |= ENDPTCTRL_RXE;\r\n}\r\nhw_write(ci, OP_ENDPTCTRL + num, mask, data);\r\nreturn 0;\r\n}\r\nstatic int hw_ep_get_halt(struct ci13xxx *ci, int num, int dir)\r\n{\r\nu32 mask = dir ? ENDPTCTRL_TXS : ENDPTCTRL_RXS;\r\nreturn hw_read(ci, OP_ENDPTCTRL + num, mask) ? 1 : 0;\r\n}\r\nstatic int hw_test_and_clear_setup_status(struct ci13xxx *ci, int n)\r\n{\r\nn = ep_to_bit(ci, n);\r\nreturn hw_test_and_clear(ci, OP_ENDPTSETUPSTAT, BIT(n));\r\n}\r\nstatic int hw_ep_prime(struct ci13xxx *ci, int num, int dir, int is_ctrl)\r\n{\r\nint n = hw_ep_bit(num, dir);\r\nif (is_ctrl && dir == RX && hw_read(ci, OP_ENDPTSETUPSTAT, BIT(num)))\r\nreturn -EAGAIN;\r\nhw_write(ci, OP_ENDPTPRIME, BIT(n), BIT(n));\r\nwhile (hw_read(ci, OP_ENDPTPRIME, BIT(n)))\r\ncpu_relax();\r\nif (is_ctrl && dir == RX && hw_read(ci, OP_ENDPTSETUPSTAT, BIT(num)))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int hw_ep_set_halt(struct ci13xxx *ci, int num, int dir, int value)\r\n{\r\nif (value != 0 && value != 1)\r\nreturn -EINVAL;\r\ndo {\r\nenum ci13xxx_regs reg = OP_ENDPTCTRL + num;\r\nu32 mask_xs = dir ? ENDPTCTRL_TXS : ENDPTCTRL_RXS;\r\nu32 mask_xr = dir ? ENDPTCTRL_TXR : ENDPTCTRL_RXR;\r\nhw_write(ci, reg, mask_xs|mask_xr,\r\nvalue ? mask_xs : mask_xr);\r\n} while (value != hw_ep_get_halt(ci, num, dir));\r\nreturn 0;\r\n}\r\nstatic int hw_port_is_high_speed(struct ci13xxx *ci)\r\n{\r\nreturn ci->hw_bank.lpm ? hw_read(ci, OP_DEVLC, DEVLC_PSPD) :\r\nhw_read(ci, OP_PORTSC, PORTSC_HSP);\r\n}\r\nstatic u32 hw_read_intr_enable(struct ci13xxx *ci)\r\n{\r\nreturn hw_read(ci, OP_USBINTR, ~0);\r\n}\r\nstatic u32 hw_read_intr_status(struct ci13xxx *ci)\r\n{\r\nreturn hw_read(ci, OP_USBSTS, ~0);\r\n}\r\nstatic int hw_test_and_clear_complete(struct ci13xxx *ci, int n)\r\n{\r\nn = ep_to_bit(ci, n);\r\nreturn hw_test_and_clear(ci, OP_ENDPTCOMPLETE, BIT(n));\r\n}\r\nstatic u32 hw_test_and_clear_intr_active(struct ci13xxx *ci)\r\n{\r\nu32 reg = hw_read_intr_status(ci) & hw_read_intr_enable(ci);\r\nhw_write(ci, OP_USBSTS, ~0, reg);\r\nreturn reg;\r\n}\r\nstatic void hw_enable_vbus_intr(struct ci13xxx *ci)\r\n{\r\nhw_write(ci, OP_OTGSC, OTGSC_AVVIS, OTGSC_AVVIS);\r\nhw_write(ci, OP_OTGSC, OTGSC_AVVIE, OTGSC_AVVIE);\r\nqueue_work(ci->wq, &ci->vbus_work);\r\n}\r\nstatic void hw_disable_vbus_intr(struct ci13xxx *ci)\r\n{\r\nhw_write(ci, OP_OTGSC, OTGSC_AVVIE, 0);\r\n}\r\nstatic int hw_test_and_clear_setup_guard(struct ci13xxx *ci)\r\n{\r\nreturn hw_test_and_write(ci, OP_USBCMD, USBCMD_SUTW, 0);\r\n}\r\nstatic int hw_test_and_set_setup_guard(struct ci13xxx *ci)\r\n{\r\nreturn hw_test_and_write(ci, OP_USBCMD, USBCMD_SUTW, USBCMD_SUTW);\r\n}\r\nstatic void hw_usb_set_address(struct ci13xxx *ci, u8 value)\r\n{\r\nhw_write(ci, OP_DEVICEADDR, DEVICEADDR_USBADR,\r\nvalue << ffs_nr(DEVICEADDR_USBADR));\r\n}\r\nstatic int hw_usb_reset(struct ci13xxx *ci)\r\n{\r\nhw_usb_set_address(ci, 0);\r\nhw_write(ci, OP_ENDPTFLUSH, ~0, ~0);\r\nhw_write(ci, OP_ENDPTSETUPSTAT, 0, 0);\r\nhw_write(ci, OP_ENDPTCOMPLETE, 0, 0);\r\nwhile (hw_read(ci, OP_ENDPTPRIME, ~0))\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic void vbus_work(struct work_struct *work)\r\n{\r\nstruct ci13xxx *ci = container_of(work, struct ci13xxx, vbus_work);\r\nif (hw_read(ci, OP_OTGSC, OTGSC_AVV))\r\nusb_gadget_vbus_connect(&ci->gadget);\r\nelse\r\nusb_gadget_vbus_disconnect(&ci->gadget);\r\n}\r\nstatic inline u8 _usb_addr(struct ci13xxx_ep *ep)\r\n{\r\nreturn ((ep->dir == TX) ? USB_ENDPOINT_DIR_MASK : 0) | ep->num;\r\n}\r\nstatic int _hardware_enqueue(struct ci13xxx_ep *mEp, struct ci13xxx_req *mReq)\r\n{\r\nstruct ci13xxx *ci = mEp->ci;\r\nunsigned i;\r\nint ret = 0;\r\nunsigned length = mReq->req.length;\r\nif (mReq->req.status == -EALREADY)\r\nreturn -EALREADY;\r\nmReq->req.status = -EALREADY;\r\nif (mReq->req.zero && length && (length % mEp->ep.maxpacket == 0)) {\r\nmReq->zptr = dma_pool_alloc(mEp->td_pool, GFP_ATOMIC,\r\n&mReq->zdma);\r\nif (mReq->zptr == NULL)\r\nreturn -ENOMEM;\r\nmemset(mReq->zptr, 0, sizeof(*mReq->zptr));\r\nmReq->zptr->next = TD_TERMINATE;\r\nmReq->zptr->token = TD_STATUS_ACTIVE;\r\nif (!mReq->req.no_interrupt)\r\nmReq->zptr->token |= TD_IOC;\r\n}\r\nret = usb_gadget_map_request(&ci->gadget, &mReq->req, mEp->dir);\r\nif (ret)\r\nreturn ret;\r\nmemset(mReq->ptr, 0, sizeof(*mReq->ptr));\r\nmReq->ptr->token = length << ffs_nr(TD_TOTAL_BYTES);\r\nmReq->ptr->token &= TD_TOTAL_BYTES;\r\nmReq->ptr->token |= TD_STATUS_ACTIVE;\r\nif (mReq->zptr) {\r\nmReq->ptr->next = mReq->zdma;\r\n} else {\r\nmReq->ptr->next = TD_TERMINATE;\r\nif (!mReq->req.no_interrupt)\r\nmReq->ptr->token |= TD_IOC;\r\n}\r\nmReq->ptr->page[0] = mReq->req.dma;\r\nfor (i = 1; i < 5; i++)\r\nmReq->ptr->page[i] =\r\n(mReq->req.dma + i * CI13XXX_PAGE_SIZE) & ~TD_RESERVED_MASK;\r\nif (!list_empty(&mEp->qh.queue)) {\r\nstruct ci13xxx_req *mReqPrev;\r\nint n = hw_ep_bit(mEp->num, mEp->dir);\r\nint tmp_stat;\r\nmReqPrev = list_entry(mEp->qh.queue.prev,\r\nstruct ci13xxx_req, queue);\r\nif (mReqPrev->zptr)\r\nmReqPrev->zptr->next = mReq->dma & TD_ADDR_MASK;\r\nelse\r\nmReqPrev->ptr->next = mReq->dma & TD_ADDR_MASK;\r\nwmb();\r\nif (hw_read(ci, OP_ENDPTPRIME, BIT(n)))\r\ngoto done;\r\ndo {\r\nhw_write(ci, OP_USBCMD, USBCMD_ATDTW, USBCMD_ATDTW);\r\ntmp_stat = hw_read(ci, OP_ENDPTSTAT, BIT(n));\r\n} while (!hw_read(ci, OP_USBCMD, USBCMD_ATDTW));\r\nhw_write(ci, OP_USBCMD, USBCMD_ATDTW, 0);\r\nif (tmp_stat)\r\ngoto done;\r\n}\r\nmEp->qh.ptr->td.next = mReq->dma;\r\nmEp->qh.ptr->td.token &= ~TD_STATUS;\r\nmEp->qh.ptr->cap |= QH_ZLT;\r\nwmb();\r\nret = hw_ep_prime(ci, mEp->num, mEp->dir,\r\nmEp->type == USB_ENDPOINT_XFER_CONTROL);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int _hardware_dequeue(struct ci13xxx_ep *mEp, struct ci13xxx_req *mReq)\r\n{\r\nif (mReq->req.status != -EALREADY)\r\nreturn -EINVAL;\r\nif ((TD_STATUS_ACTIVE & mReq->ptr->token) != 0)\r\nreturn -EBUSY;\r\nif (mReq->zptr) {\r\nif ((TD_STATUS_ACTIVE & mReq->zptr->token) != 0)\r\nreturn -EBUSY;\r\ndma_pool_free(mEp->td_pool, mReq->zptr, mReq->zdma);\r\nmReq->zptr = NULL;\r\n}\r\nmReq->req.status = 0;\r\nusb_gadget_unmap_request(&mEp->ci->gadget, &mReq->req, mEp->dir);\r\nmReq->req.status = mReq->ptr->token & TD_STATUS;\r\nif ((TD_STATUS_HALTED & mReq->req.status) != 0)\r\nmReq->req.status = -1;\r\nelse if ((TD_STATUS_DT_ERR & mReq->req.status) != 0)\r\nmReq->req.status = -1;\r\nelse if ((TD_STATUS_TR_ERR & mReq->req.status) != 0)\r\nmReq->req.status = -1;\r\nmReq->req.actual = mReq->ptr->token & TD_TOTAL_BYTES;\r\nmReq->req.actual >>= ffs_nr(TD_TOTAL_BYTES);\r\nmReq->req.actual = mReq->req.length - mReq->req.actual;\r\nmReq->req.actual = mReq->req.status ? 0 : mReq->req.actual;\r\nreturn mReq->req.actual;\r\n}\r\nstatic int _ep_nuke(struct ci13xxx_ep *mEp)\r\n__releases(mEp->lock)\r\n__acquires(mEp->lock)\r\n{\r\nif (mEp == NULL)\r\nreturn -EINVAL;\r\nhw_ep_flush(mEp->ci, mEp->num, mEp->dir);\r\nwhile (!list_empty(&mEp->qh.queue)) {\r\nstruct ci13xxx_req *mReq = \\r\nlist_entry(mEp->qh.queue.next,\r\nstruct ci13xxx_req, queue);\r\nlist_del_init(&mReq->queue);\r\nmReq->req.status = -ESHUTDOWN;\r\nif (mReq->req.complete != NULL) {\r\nspin_unlock(mEp->lock);\r\nmReq->req.complete(&mEp->ep, &mReq->req);\r\nspin_lock(mEp->lock);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int _gadget_stop_activity(struct usb_gadget *gadget)\r\n{\r\nstruct usb_ep *ep;\r\nstruct ci13xxx *ci = container_of(gadget, struct ci13xxx, gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nci->gadget.speed = USB_SPEED_UNKNOWN;\r\nci->remote_wakeup = 0;\r\nci->suspended = 0;\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\ngadget_for_each_ep(ep, gadget) {\r\nusb_ep_fifo_flush(ep);\r\n}\r\nusb_ep_fifo_flush(&ci->ep0out->ep);\r\nusb_ep_fifo_flush(&ci->ep0in->ep);\r\nif (ci->driver)\r\nci->driver->disconnect(gadget);\r\ngadget_for_each_ep(ep, gadget) {\r\nusb_ep_disable(ep);\r\n}\r\nif (ci->status != NULL) {\r\nusb_ep_free_request(&ci->ep0in->ep, ci->status);\r\nci->status = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isr_reset_handler(struct ci13xxx *ci)\r\n__releases(ci->lock)\r\n__acquires(ci->lock)\r\n{\r\nint retval;\r\ndbg_event(0xFF, "BUS RST", 0);\r\nspin_unlock(&ci->lock);\r\nretval = _gadget_stop_activity(&ci->gadget);\r\nif (retval)\r\ngoto done;\r\nretval = hw_usb_reset(ci);\r\nif (retval)\r\ngoto done;\r\nci->status = usb_ep_alloc_request(&ci->ep0in->ep, GFP_ATOMIC);\r\nif (ci->status == NULL)\r\nretval = -ENOMEM;\r\ndone:\r\nspin_lock(&ci->lock);\r\nif (retval)\r\ndev_err(ci->dev, "error: %i\n", retval);\r\n}\r\nstatic void isr_get_status_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nif (ep == NULL || req == NULL)\r\nreturn;\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic int isr_get_status_response(struct ci13xxx *ci,\r\nstruct usb_ctrlrequest *setup)\r\n__releases(mEp->lock)\r\n__acquires(mEp->lock)\r\n{\r\nstruct ci13xxx_ep *mEp = ci->ep0in;\r\nstruct usb_request *req = NULL;\r\ngfp_t gfp_flags = GFP_ATOMIC;\r\nint dir, num, retval;\r\nif (mEp == NULL || setup == NULL)\r\nreturn -EINVAL;\r\nspin_unlock(mEp->lock);\r\nreq = usb_ep_alloc_request(&mEp->ep, gfp_flags);\r\nspin_lock(mEp->lock);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->complete = isr_get_status_complete;\r\nreq->length = 2;\r\nreq->buf = kzalloc(req->length, gfp_flags);\r\nif (req->buf == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_free_req;\r\n}\r\nif ((setup->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\r\n*(u16 *)req->buf = ci->remote_wakeup << 1;\r\nretval = 0;\r\n} else if ((setup->bRequestType & USB_RECIP_MASK) \\r\n== USB_RECIP_ENDPOINT) {\r\ndir = (le16_to_cpu(setup->wIndex) & USB_ENDPOINT_DIR_MASK) ?\r\nTX : RX;\r\nnum = le16_to_cpu(setup->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\n*(u16 *)req->buf = hw_ep_get_halt(ci, num, dir);\r\n}\r\nspin_unlock(mEp->lock);\r\nretval = usb_ep_queue(&mEp->ep, req, gfp_flags);\r\nspin_lock(mEp->lock);\r\nif (retval)\r\ngoto err_free_buf;\r\nreturn 0;\r\nerr_free_buf:\r\nkfree(req->buf);\r\nerr_free_req:\r\nspin_unlock(mEp->lock);\r\nusb_ep_free_request(&mEp->ep, req);\r\nspin_lock(mEp->lock);\r\nreturn retval;\r\n}\r\nstatic void\r\nisr_setup_status_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ci13xxx *ci = req->context;\r\nunsigned long flags;\r\nif (ci->setaddr) {\r\nhw_usb_set_address(ci, ci->address);\r\nci->setaddr = false;\r\n}\r\nspin_lock_irqsave(&ci->lock, flags);\r\nif (ci->test_mode)\r\nhw_port_test_set(ci, ci->test_mode);\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\n}\r\nstatic int isr_setup_status_phase(struct ci13xxx *ci)\r\n__releases(mEp->lock)\r\n__acquires(mEp->lock)\r\n{\r\nint retval;\r\nstruct ci13xxx_ep *mEp;\r\nmEp = (ci->ep0_dir == TX) ? ci->ep0out : ci->ep0in;\r\nci->status->context = ci;\r\nci->status->complete = isr_setup_status_complete;\r\nspin_unlock(mEp->lock);\r\nretval = usb_ep_queue(&mEp->ep, ci->status, GFP_ATOMIC);\r\nspin_lock(mEp->lock);\r\nreturn retval;\r\n}\r\nstatic int isr_tr_complete_low(struct ci13xxx_ep *mEp)\r\n__releases(mEp->lock)\r\n__acquires(mEp->lock)\r\n{\r\nstruct ci13xxx_req *mReq, *mReqTemp;\r\nstruct ci13xxx_ep *mEpTemp = mEp;\r\nint retval = 0;\r\nlist_for_each_entry_safe(mReq, mReqTemp, &mEp->qh.queue,\r\nqueue) {\r\nretval = _hardware_dequeue(mEp, mReq);\r\nif (retval < 0)\r\nbreak;\r\nlist_del_init(&mReq->queue);\r\ndbg_done(_usb_addr(mEp), mReq->ptr->token, retval);\r\nif (mReq->req.complete != NULL) {\r\nspin_unlock(mEp->lock);\r\nif ((mEp->type == USB_ENDPOINT_XFER_CONTROL) &&\r\nmReq->req.length)\r\nmEpTemp = mEp->ci->ep0in;\r\nmReq->req.complete(&mEpTemp->ep, &mReq->req);\r\nspin_lock(mEp->lock);\r\n}\r\n}\r\nif (retval == -EBUSY)\r\nretval = 0;\r\nif (retval < 0)\r\ndbg_event(_usb_addr(mEp), "DONE", retval);\r\nreturn retval;\r\n}\r\nstatic void isr_tr_complete_handler(struct ci13xxx *ci)\r\n__releases(ci->lock)\r\n__acquires(ci->lock)\r\n{\r\nunsigned i;\r\nu8 tmode = 0;\r\nfor (i = 0; i < ci->hw_ep_max; i++) {\r\nstruct ci13xxx_ep *mEp = &ci->ci13xxx_ep[i];\r\nint type, num, dir, err = -EINVAL;\r\nstruct usb_ctrlrequest req;\r\nif (mEp->ep.desc == NULL)\r\ncontinue;\r\nif (hw_test_and_clear_complete(ci, i)) {\r\nerr = isr_tr_complete_low(mEp);\r\nif (mEp->type == USB_ENDPOINT_XFER_CONTROL) {\r\nif (err > 0)\r\nerr = isr_setup_status_phase(ci);\r\nif (err < 0) {\r\ndbg_event(_usb_addr(mEp),\r\n"ERROR", err);\r\nspin_unlock(&ci->lock);\r\nif (usb_ep_set_halt(&mEp->ep))\r\ndev_err(ci->dev,\r\n"error: ep_set_halt\n");\r\nspin_lock(&ci->lock);\r\n}\r\n}\r\n}\r\nif (mEp->type != USB_ENDPOINT_XFER_CONTROL ||\r\n!hw_test_and_clear_setup_status(ci, i))\r\ncontinue;\r\nif (i != 0) {\r\ndev_warn(ci->dev, "ctrl traffic at endpoint %d\n", i);\r\ncontinue;\r\n}\r\n_ep_nuke(ci->ep0out);\r\n_ep_nuke(ci->ep0in);\r\ndo {\r\nhw_test_and_set_setup_guard(ci);\r\nmemcpy(&req, &mEp->qh.ptr->setup, sizeof(req));\r\n} while (!hw_test_and_clear_setup_guard(ci));\r\ntype = req.bRequestType;\r\nci->ep0_dir = (type & USB_DIR_IN) ? TX : RX;\r\ndbg_setup(_usb_addr(mEp), &req);\r\nswitch (req.bRequest) {\r\ncase USB_REQ_CLEAR_FEATURE:\r\nif (type == (USB_DIR_OUT|USB_RECIP_ENDPOINT) &&\r\nle16_to_cpu(req.wValue) ==\r\nUSB_ENDPOINT_HALT) {\r\nif (req.wLength != 0)\r\nbreak;\r\nnum = le16_to_cpu(req.wIndex);\r\ndir = num & USB_ENDPOINT_DIR_MASK;\r\nnum &= USB_ENDPOINT_NUMBER_MASK;\r\nif (dir)\r\nnum += ci->hw_ep_max/2;\r\nif (!ci->ci13xxx_ep[num].wedge) {\r\nspin_unlock(&ci->lock);\r\nerr = usb_ep_clear_halt(\r\n&ci->ci13xxx_ep[num].ep);\r\nspin_lock(&ci->lock);\r\nif (err)\r\nbreak;\r\n}\r\nerr = isr_setup_status_phase(ci);\r\n} else if (type == (USB_DIR_OUT|USB_RECIP_DEVICE) &&\r\nle16_to_cpu(req.wValue) ==\r\nUSB_DEVICE_REMOTE_WAKEUP) {\r\nif (req.wLength != 0)\r\nbreak;\r\nci->remote_wakeup = 0;\r\nerr = isr_setup_status_phase(ci);\r\n} else {\r\ngoto delegate;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif (type != (USB_DIR_IN|USB_RECIP_DEVICE) &&\r\ntype != (USB_DIR_IN|USB_RECIP_ENDPOINT) &&\r\ntype != (USB_DIR_IN|USB_RECIP_INTERFACE))\r\ngoto delegate;\r\nif (le16_to_cpu(req.wLength) != 2 ||\r\nle16_to_cpu(req.wValue) != 0)\r\nbreak;\r\nerr = isr_get_status_response(ci, &req);\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (type != (USB_DIR_OUT|USB_RECIP_DEVICE))\r\ngoto delegate;\r\nif (le16_to_cpu(req.wLength) != 0 ||\r\nle16_to_cpu(req.wIndex) != 0)\r\nbreak;\r\nci->address = (u8)le16_to_cpu(req.wValue);\r\nci->setaddr = true;\r\nerr = isr_setup_status_phase(ci);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nif (type == (USB_DIR_OUT|USB_RECIP_ENDPOINT) &&\r\nle16_to_cpu(req.wValue) ==\r\nUSB_ENDPOINT_HALT) {\r\nif (req.wLength != 0)\r\nbreak;\r\nnum = le16_to_cpu(req.wIndex);\r\ndir = num & USB_ENDPOINT_DIR_MASK;\r\nnum &= USB_ENDPOINT_NUMBER_MASK;\r\nif (dir)\r\nnum += ci->hw_ep_max/2;\r\nspin_unlock(&ci->lock);\r\nerr = usb_ep_set_halt(&ci->ci13xxx_ep[num].ep);\r\nspin_lock(&ci->lock);\r\nif (!err)\r\nisr_setup_status_phase(ci);\r\n} else if (type == (USB_DIR_OUT|USB_RECIP_DEVICE)) {\r\nif (req.wLength != 0)\r\nbreak;\r\nswitch (le16_to_cpu(req.wValue)) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nci->remote_wakeup = 1;\r\nerr = isr_setup_status_phase(ci);\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\ntmode = le16_to_cpu(req.wIndex) >> 8;\r\nswitch (tmode) {\r\ncase TEST_J:\r\ncase TEST_K:\r\ncase TEST_SE0_NAK:\r\ncase TEST_PACKET:\r\ncase TEST_FORCE_EN:\r\nci->test_mode = tmode;\r\nerr = isr_setup_status_phase(\r\nci);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\ngoto delegate;\r\n}\r\n} else {\r\ngoto delegate;\r\n}\r\nbreak;\r\ndefault:\r\ndelegate:\r\nif (req.wLength == 0)\r\nci->ep0_dir = TX;\r\nspin_unlock(&ci->lock);\r\nerr = ci->driver->setup(&ci->gadget, &req);\r\nspin_lock(&ci->lock);\r\nbreak;\r\n}\r\nif (err < 0) {\r\ndbg_event(_usb_addr(mEp), "ERROR", err);\r\nspin_unlock(&ci->lock);\r\nif (usb_ep_set_halt(&mEp->ep))\r\ndev_err(ci->dev, "error: ep_set_halt\n");\r\nspin_lock(&ci->lock);\r\n}\r\n}\r\n}\r\nstatic int ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nint retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL || desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(mEp->lock, flags);\r\nmEp->ep.desc = desc;\r\nif (!list_empty(&mEp->qh.queue))\r\ndev_warn(mEp->ci->dev, "enabling a non-empty endpoint!\n");\r\nmEp->dir = usb_endpoint_dir_in(desc) ? TX : RX;\r\nmEp->num = usb_endpoint_num(desc);\r\nmEp->type = usb_endpoint_type(desc);\r\nmEp->ep.maxpacket = usb_endpoint_maxp(desc);\r\ndbg_event(_usb_addr(mEp), "ENABLE", 0);\r\nmEp->qh.ptr->cap = 0;\r\nif (mEp->type == USB_ENDPOINT_XFER_CONTROL)\r\nmEp->qh.ptr->cap |= QH_IOS;\r\nelse if (mEp->type == USB_ENDPOINT_XFER_ISOC)\r\nmEp->qh.ptr->cap &= ~QH_MULT;\r\nelse\r\nmEp->qh.ptr->cap &= ~QH_ZLT;\r\nmEp->qh.ptr->cap |=\r\n(mEp->ep.maxpacket << ffs_nr(QH_MAX_PKT)) & QH_MAX_PKT;\r\nmEp->qh.ptr->td.next |= TD_TERMINATE;\r\nif (mEp->num)\r\nretval |= hw_ep_enable(mEp->ci, mEp->num, mEp->dir, mEp->type);\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ep_disable(struct usb_ep *ep)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nint direction, retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL)\r\nreturn -EINVAL;\r\nelse if (mEp->ep.desc == NULL)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(mEp->lock, flags);\r\ndirection = mEp->dir;\r\ndo {\r\ndbg_event(_usb_addr(mEp), "DISABLE", 0);\r\nretval |= _ep_nuke(mEp);\r\nretval |= hw_ep_disable(mEp->ci, mEp->num, mEp->dir);\r\nif (mEp->type == USB_ENDPOINT_XFER_CONTROL)\r\nmEp->dir = (mEp->dir == TX) ? RX : TX;\r\n} while (mEp->dir != direction);\r\nmEp->ep.desc = NULL;\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn retval;\r\n}\r\nstatic struct usb_request *ep_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nstruct ci13xxx_req *mReq = NULL;\r\nif (ep == NULL)\r\nreturn NULL;\r\nmReq = kzalloc(sizeof(struct ci13xxx_req), gfp_flags);\r\nif (mReq != NULL) {\r\nINIT_LIST_HEAD(&mReq->queue);\r\nmReq->ptr = dma_pool_alloc(mEp->td_pool, gfp_flags,\r\n&mReq->dma);\r\nif (mReq->ptr == NULL) {\r\nkfree(mReq);\r\nmReq = NULL;\r\n}\r\n}\r\ndbg_event(_usb_addr(mEp), "ALLOC", mReq == NULL);\r\nreturn (mReq == NULL) ? NULL : &mReq->req;\r\n}\r\nstatic void ep_free_request(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nstruct ci13xxx_req *mReq = container_of(req, struct ci13xxx_req, req);\r\nunsigned long flags;\r\nif (ep == NULL || req == NULL) {\r\nreturn;\r\n} else if (!list_empty(&mReq->queue)) {\r\ndev_err(mEp->ci->dev, "freeing queued request\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(mEp->lock, flags);\r\nif (mReq->ptr)\r\ndma_pool_free(mEp->td_pool, mReq->ptr, mReq->dma);\r\nkfree(mReq);\r\ndbg_event(_usb_addr(mEp), "FREE", 0);\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\n}\r\nstatic int ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t __maybe_unused gfp_flags)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nstruct ci13xxx_req *mReq = container_of(req, struct ci13xxx_req, req);\r\nstruct ci13xxx *ci = mEp->ci;\r\nint retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL || req == NULL || mEp->ep.desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(mEp->lock, flags);\r\nif (mEp->type == USB_ENDPOINT_XFER_CONTROL) {\r\nif (req->length)\r\nmEp = (ci->ep0_dir == RX) ?\r\nci->ep0out : ci->ep0in;\r\nif (!list_empty(&mEp->qh.queue)) {\r\n_ep_nuke(mEp);\r\nretval = -EOVERFLOW;\r\ndev_warn(mEp->ci->dev, "endpoint ctrl %X nuked\n",\r\n_usb_addr(mEp));\r\n}\r\n}\r\nif (!list_empty(&mReq->queue)) {\r\nretval = -EBUSY;\r\ndev_err(mEp->ci->dev, "request already in queue\n");\r\ngoto done;\r\n}\r\nif (req->length > 4 * CI13XXX_PAGE_SIZE) {\r\nreq->length = 4 * CI13XXX_PAGE_SIZE;\r\nretval = -EMSGSIZE;\r\ndev_warn(mEp->ci->dev, "request length truncated\n");\r\n}\r\ndbg_queue(_usb_addr(mEp), req, retval);\r\nmReq->req.status = -EINPROGRESS;\r\nmReq->req.actual = 0;\r\nretval = _hardware_enqueue(mEp, mReq);\r\nif (retval == -EALREADY) {\r\ndbg_event(_usb_addr(mEp), "QUEUE", retval);\r\nretval = 0;\r\n}\r\nif (!retval)\r\nlist_add_tail(&mReq->queue, &mEp->qh.queue);\r\ndone:\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ep_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nstruct ci13xxx_req *mReq = container_of(req, struct ci13xxx_req, req);\r\nunsigned long flags;\r\nif (ep == NULL || req == NULL || mReq->req.status != -EALREADY ||\r\nmEp->ep.desc == NULL || list_empty(&mReq->queue) ||\r\nlist_empty(&mEp->qh.queue))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(mEp->lock, flags);\r\ndbg_event(_usb_addr(mEp), "DEQUEUE", 0);\r\nhw_ep_flush(mEp->ci, mEp->num, mEp->dir);\r\nlist_del_init(&mReq->queue);\r\nusb_gadget_unmap_request(&mEp->ci->gadget, req, mEp->dir);\r\nreq->status = -ECONNRESET;\r\nif (mReq->req.complete != NULL) {\r\nspin_unlock(mEp->lock);\r\nmReq->req.complete(&mEp->ep, &mReq->req);\r\nspin_lock(mEp->lock);\r\n}\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ep_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nint direction, retval = 0;\r\nunsigned long flags;\r\nif (ep == NULL || mEp->ep.desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(mEp->lock, flags);\r\n#ifndef STALL_IN\r\nif (value && mEp->type == USB_ENDPOINT_XFER_BULK && mEp->dir == TX &&\r\n!list_empty(&mEp->qh.queue)) {\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\n#endif\r\ndirection = mEp->dir;\r\ndo {\r\ndbg_event(_usb_addr(mEp), "HALT", value);\r\nretval |= hw_ep_set_halt(mEp->ci, mEp->num, mEp->dir, value);\r\nif (!value)\r\nmEp->wedge = 0;\r\nif (mEp->type == USB_ENDPOINT_XFER_CONTROL)\r\nmEp->dir = (mEp->dir == TX) ? RX : TX;\r\n} while (mEp->dir != direction);\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ep_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nunsigned long flags;\r\nif (ep == NULL || mEp->ep.desc == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(mEp->lock, flags);\r\ndbg_event(_usb_addr(mEp), "WEDGE", 0);\r\nmEp->wedge = 1;\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\nreturn usb_ep_set_halt(ep);\r\n}\r\nstatic void ep_fifo_flush(struct usb_ep *ep)\r\n{\r\nstruct ci13xxx_ep *mEp = container_of(ep, struct ci13xxx_ep, ep);\r\nunsigned long flags;\r\nif (ep == NULL) {\r\ndev_err(mEp->ci->dev, "%02X: -EINVAL\n", _usb_addr(mEp));\r\nreturn;\r\n}\r\nspin_lock_irqsave(mEp->lock, flags);\r\ndbg_event(_usb_addr(mEp), "FFLUSH", 0);\r\nhw_ep_flush(mEp->ci, mEp->num, mEp->dir);\r\nspin_unlock_irqrestore(mEp->lock, flags);\r\n}\r\nstatic int ci13xxx_vbus_session(struct usb_gadget *_gadget, int is_active)\r\n{\r\nstruct ci13xxx *ci = container_of(_gadget, struct ci13xxx, gadget);\r\nunsigned long flags;\r\nint gadget_ready = 0;\r\nif (!(ci->platdata->flags & CI13XXX_PULLUP_ON_VBUS))\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nci->vbus_active = is_active;\r\nif (ci->driver)\r\ngadget_ready = 1;\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nif (gadget_ready) {\r\nif (is_active) {\r\npm_runtime_get_sync(&_gadget->dev);\r\nhw_device_reset(ci, USBMODE_CM_DC);\r\nhw_enable_vbus_intr(ci);\r\nhw_device_state(ci, ci->ep0out->qh.dma);\r\n} else {\r\nhw_device_state(ci, 0);\r\nif (ci->platdata->notify_event)\r\nci->platdata->notify_event(ci,\r\nCI13XXX_CONTROLLER_STOPPED_EVENT);\r\n_gadget_stop_activity(&ci->gadget);\r\npm_runtime_put_sync(&_gadget->dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci13xxx_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct ci13xxx *ci = container_of(_gadget, struct ci13xxx, gadget);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nif (!ci->remote_wakeup) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (!hw_read(ci, OP_PORTSC, PORTSC_SUSP)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nhw_write(ci, OP_PORTSC, PORTSC_FPR, PORTSC_FPR);\r\nout:\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ci13xxx_vbus_draw(struct usb_gadget *_gadget, unsigned mA)\r\n{\r\nstruct ci13xxx *ci = container_of(_gadget, struct ci13xxx, gadget);\r\nif (ci->transceiver)\r\nreturn usb_phy_set_power(ci->transceiver, mA);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int ci13xxx_pullup(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct ci13xxx *ci = container_of(_gadget, struct ci13xxx, gadget);\r\nif (is_on)\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);\r\nelse\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, 0);\r\nreturn 0;\r\n}\r\nstatic int init_eps(struct ci13xxx *ci)\r\n{\r\nint retval = 0, i, j;\r\nfor (i = 0; i < ci->hw_ep_max/2; i++)\r\nfor (j = RX; j <= TX; j++) {\r\nint k = i + j * ci->hw_ep_max/2;\r\nstruct ci13xxx_ep *mEp = &ci->ci13xxx_ep[k];\r\nscnprintf(mEp->name, sizeof(mEp->name), "ep%i%s", i,\r\n(j == TX) ? "in" : "out");\r\nmEp->ci = ci;\r\nmEp->lock = &ci->lock;\r\nmEp->td_pool = ci->td_pool;\r\nmEp->ep.name = mEp->name;\r\nmEp->ep.ops = &usb_ep_ops;\r\nmEp->ep.maxpacket = (unsigned short)~0;\r\nINIT_LIST_HEAD(&mEp->qh.queue);\r\nmEp->qh.ptr = dma_pool_alloc(ci->qh_pool, GFP_KERNEL,\r\n&mEp->qh.dma);\r\nif (mEp->qh.ptr == NULL)\r\nretval = -ENOMEM;\r\nelse\r\nmemset(mEp->qh.ptr, 0, sizeof(*mEp->qh.ptr));\r\nif (i == 0) {\r\nif (j == RX)\r\nci->ep0out = mEp;\r\nelse\r\nci->ep0in = mEp;\r\nmEp->ep.maxpacket = CTRL_PAYLOAD_MAX;\r\ncontinue;\r\n}\r\nlist_add_tail(&mEp->ep.ep_list, &ci->gadget.ep_list);\r\n}\r\nreturn retval;\r\n}\r\nstatic void destroy_eps(struct ci13xxx *ci)\r\n{\r\nint i;\r\nfor (i = 0; i < ci->hw_ep_max; i++) {\r\nstruct ci13xxx_ep *mEp = &ci->ci13xxx_ep[i];\r\ndma_pool_free(ci->qh_pool, mEp->qh.ptr, mEp->qh.dma);\r\n}\r\n}\r\nstatic int ci13xxx_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct ci13xxx *ci = container_of(gadget, struct ci13xxx, gadget);\r\nunsigned long flags;\r\nint retval = -ENOMEM;\r\nif (driver->disconnect == NULL)\r\nreturn -EINVAL;\r\nci->ep0out->ep.desc = &ctrl_endpt_out_desc;\r\nretval = usb_ep_enable(&ci->ep0out->ep);\r\nif (retval)\r\nreturn retval;\r\nci->ep0in->ep.desc = &ctrl_endpt_in_desc;\r\nretval = usb_ep_enable(&ci->ep0in->ep);\r\nif (retval)\r\nreturn retval;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nci->driver = driver;\r\npm_runtime_get_sync(&ci->gadget.dev);\r\nif (ci->platdata->flags & CI13XXX_PULLUP_ON_VBUS) {\r\nif (ci->vbus_active) {\r\nif (ci->platdata->flags & CI13XXX_REGS_SHARED) {\r\nhw_device_reset(ci, USBMODE_CM_DC);\r\nhw_enable_vbus_intr(ci);\r\n}\r\n} else {\r\npm_runtime_put_sync(&ci->gadget.dev);\r\ngoto done;\r\n}\r\n}\r\nretval = hw_device_state(ci, ci->ep0out->qh.dma);\r\nif (retval)\r\npm_runtime_put_sync(&ci->gadget.dev);\r\ndone:\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ci13xxx_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct ci13xxx *ci = container_of(gadget, struct ci13xxx, gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ci->lock, flags);\r\nif (!(ci->platdata->flags & CI13XXX_PULLUP_ON_VBUS) ||\r\nci->vbus_active) {\r\nhw_device_state(ci, 0);\r\nif (ci->platdata->notify_event)\r\nci->platdata->notify_event(ci,\r\nCI13XXX_CONTROLLER_STOPPED_EVENT);\r\nci->driver = NULL;\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\n_gadget_stop_activity(&ci->gadget);\r\nspin_lock_irqsave(&ci->lock, flags);\r\npm_runtime_put(&ci->gadget.dev);\r\n}\r\nspin_unlock_irqrestore(&ci->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t udc_irq(struct ci13xxx *ci)\r\n{\r\nirqreturn_t retval;\r\nu32 intr;\r\nif (ci == NULL)\r\nreturn IRQ_HANDLED;\r\nspin_lock(&ci->lock);\r\nif (ci->platdata->flags & CI13XXX_REGS_SHARED) {\r\nif (hw_read(ci, OP_USBMODE, USBMODE_CM) !=\r\nUSBMODE_CM_DC) {\r\nspin_unlock(&ci->lock);\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nintr = hw_test_and_clear_intr_active(ci);\r\ndbg_interrupt(intr);\r\nif (intr) {\r\nif (USBi_URI & intr)\r\nisr_reset_handler(ci);\r\nif (USBi_PCI & intr) {\r\nci->gadget.speed = hw_port_is_high_speed(ci) ?\r\nUSB_SPEED_HIGH : USB_SPEED_FULL;\r\nif (ci->suspended && ci->driver->resume) {\r\nspin_unlock(&ci->lock);\r\nci->driver->resume(&ci->gadget);\r\nspin_lock(&ci->lock);\r\nci->suspended = 0;\r\n}\r\n}\r\nif (USBi_UI & intr)\r\nisr_tr_complete_handler(ci);\r\nif (USBi_SLI & intr) {\r\nif (ci->gadget.speed != USB_SPEED_UNKNOWN &&\r\nci->driver->suspend) {\r\nci->suspended = 1;\r\nspin_unlock(&ci->lock);\r\nci->driver->suspend(&ci->gadget);\r\nspin_lock(&ci->lock);\r\n}\r\n}\r\nretval = IRQ_HANDLED;\r\n} else {\r\nretval = IRQ_NONE;\r\n}\r\nintr = hw_read(ci, OP_OTGSC, ~0);\r\nhw_write(ci, OP_OTGSC, ~0, intr);\r\nif (intr & (OTGSC_AVVIE & OTGSC_AVVIS))\r\nqueue_work(ci->wq, &ci->vbus_work);\r\nspin_unlock(&ci->lock);\r\nreturn retval;\r\n}\r\nstatic void udc_release(struct device *dev)\r\n{\r\n}\r\nstatic int udc_start(struct ci13xxx *ci)\r\n{\r\nstruct device *dev = ci->dev;\r\nint retval = 0;\r\nspin_lock_init(&ci->lock);\r\nci->gadget.ops = &usb_gadget_ops;\r\nci->gadget.speed = USB_SPEED_UNKNOWN;\r\nci->gadget.max_speed = USB_SPEED_HIGH;\r\nci->gadget.is_otg = 0;\r\nci->gadget.name = ci->platdata->name;\r\nINIT_LIST_HEAD(&ci->gadget.ep_list);\r\ndev_set_name(&ci->gadget.dev, "gadget");\r\nci->gadget.dev.dma_mask = dev->dma_mask;\r\nci->gadget.dev.coherent_dma_mask = dev->coherent_dma_mask;\r\nci->gadget.dev.parent = dev;\r\nci->gadget.dev.release = udc_release;\r\nci->qh_pool = dma_pool_create("ci13xxx_qh", dev,\r\nsizeof(struct ci13xxx_qh),\r\n64, CI13XXX_PAGE_SIZE);\r\nif (ci->qh_pool == NULL)\r\nreturn -ENOMEM;\r\nci->td_pool = dma_pool_create("ci13xxx_td", dev,\r\nsizeof(struct ci13xxx_td),\r\n64, CI13XXX_PAGE_SIZE);\r\nif (ci->td_pool == NULL) {\r\nretval = -ENOMEM;\r\ngoto free_qh_pool;\r\n}\r\nretval = init_eps(ci);\r\nif (retval)\r\ngoto free_pools;\r\nci->gadget.ep0 = &ci->ep0in->ep;\r\nif (ci->global_phy)\r\nci->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (ci->platdata->flags & CI13XXX_REQUIRE_TRANSCEIVER) {\r\nif (ci->transceiver == NULL) {\r\nretval = -ENODEV;\r\ngoto destroy_eps;\r\n}\r\n}\r\nif (!(ci->platdata->flags & CI13XXX_REGS_SHARED)) {\r\nretval = hw_device_reset(ci, USBMODE_CM_DC);\r\nif (retval)\r\ngoto put_transceiver;\r\nhw_enable_vbus_intr(ci);\r\n}\r\nretval = device_register(&ci->gadget.dev);\r\nif (retval) {\r\nput_device(&ci->gadget.dev);\r\ngoto put_transceiver;\r\n}\r\nretval = dbg_create_files(&ci->gadget.dev);\r\nif (retval)\r\ngoto unreg_device;\r\nif (!IS_ERR_OR_NULL(ci->transceiver)) {\r\nretval = otg_set_peripheral(ci->transceiver->otg,\r\n&ci->gadget);\r\nif (retval)\r\ngoto remove_dbg;\r\n}\r\nretval = usb_add_gadget_udc(dev, &ci->gadget);\r\nif (retval)\r\ngoto remove_trans;\r\npm_runtime_no_callbacks(&ci->gadget.dev);\r\npm_runtime_enable(&ci->gadget.dev);\r\nreturn retval;\r\nremove_trans:\r\nif (!IS_ERR_OR_NULL(ci->transceiver)) {\r\notg_set_peripheral(ci->transceiver->otg, NULL);\r\nif (ci->global_phy)\r\nusb_put_phy(ci->transceiver);\r\n}\r\ndev_err(dev, "error = %i\n", retval);\r\nremove_dbg:\r\ndbg_remove_files(&ci->gadget.dev);\r\nunreg_device:\r\ndevice_unregister(&ci->gadget.dev);\r\nput_transceiver:\r\nif (!IS_ERR_OR_NULL(ci->transceiver) && ci->global_phy)\r\nusb_put_phy(ci->transceiver);\r\ndestroy_eps:\r\ndestroy_eps(ci);\r\nfree_pools:\r\ndma_pool_destroy(ci->td_pool);\r\nfree_qh_pool:\r\ndma_pool_destroy(ci->qh_pool);\r\nreturn retval;\r\n}\r\nstatic void udc_stop(struct ci13xxx *ci)\r\n{\r\nif (ci == NULL)\r\nreturn;\r\nhw_disable_vbus_intr(ci);\r\ncancel_work_sync(&ci->vbus_work);\r\nusb_del_gadget_udc(&ci->gadget);\r\ndestroy_eps(ci);\r\ndma_pool_destroy(ci->td_pool);\r\ndma_pool_destroy(ci->qh_pool);\r\nif (!IS_ERR_OR_NULL(ci->transceiver)) {\r\notg_set_peripheral(ci->transceiver->otg, NULL);\r\nif (ci->global_phy)\r\nusb_put_phy(ci->transceiver);\r\n}\r\ndbg_remove_files(&ci->gadget.dev);\r\ndevice_unregister(&ci->gadget.dev);\r\nmemset(&ci->gadget, 0, sizeof(ci->gadget));\r\n}\r\nint ci_hdrc_gadget_init(struct ci13xxx *ci)\r\n{\r\nstruct ci_role_driver *rdrv;\r\nif (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_DC))\r\nreturn -ENXIO;\r\nrdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);\r\nif (!rdrv)\r\nreturn -ENOMEM;\r\nrdrv->start = udc_start;\r\nrdrv->stop = udc_stop;\r\nrdrv->irq = udc_irq;\r\nrdrv->name = "gadget";\r\nci->roles[CI_ROLE_GADGET] = rdrv;\r\nINIT_WORK(&ci->vbus_work, vbus_work);\r\nreturn 0;\r\n}
