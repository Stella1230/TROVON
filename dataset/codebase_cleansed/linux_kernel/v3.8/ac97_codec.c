static int snd_ac97_valid_reg(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nswitch (ac97->id) {\r\ncase AC97_ID_ST_AC97_ID4:\r\nif (reg == 0x08)\r\nreturn 0;\r\ncase AC97_ID_ST7597:\r\nif (reg == 0x22 || reg == 0x7a)\r\nreturn 1;\r\ncase AC97_ID_AK4540:\r\ncase AC97_ID_AK4542:\r\nif (reg <= 0x1c || reg == 0x20 || reg == 0x26 || reg >= 0x7c)\r\nreturn 1;\r\nreturn 0;\r\ncase AC97_ID_AD1819:\r\ncase AC97_ID_AD1881:\r\ncase AC97_ID_AD1881A:\r\nif (reg >= 0x3a && reg <= 0x6e)\r\nreturn 0;\r\nreturn 1;\r\ncase AC97_ID_AD1885:\r\ncase AC97_ID_AD1886:\r\ncase AC97_ID_AD1886A:\r\ncase AC97_ID_AD1887:\r\nif (reg == 0x5a)\r\nreturn 1;\r\nif (reg >= 0x3c && reg <= 0x6e)\r\nreturn 0;\r\nreturn 1;\r\ncase AC97_ID_STAC9700:\r\ncase AC97_ID_STAC9704:\r\ncase AC97_ID_STAC9705:\r\ncase AC97_ID_STAC9708:\r\ncase AC97_ID_STAC9721:\r\ncase AC97_ID_STAC9744:\r\ncase AC97_ID_STAC9756:\r\nif (reg <= 0x3a || reg >= 0x5a)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid snd_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short value)\r\n{\r\nif (!snd_ac97_valid_reg(ac97, reg))\r\nreturn;\r\nif ((ac97->id & 0xffffff00) == AC97_ID_ALC100) {\r\nif (reg == AC97_MASTER || reg == AC97_HEADPHONE)\r\nac97->bus->ops->write(ac97, AC97_RESET, 0);\r\n}\r\nac97->bus->ops->write(ac97, reg, value);\r\n}\r\nunsigned short snd_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nif (!snd_ac97_valid_reg(ac97, reg))\r\nreturn 0;\r\nreturn ac97->bus->ops->read(ac97, reg);\r\n}\r\nstatic inline unsigned short snd_ac97_read_cache(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nif (! test_bit(reg, ac97->reg_accessed)) {\r\nac97->regs[reg] = ac97->bus->ops->read(ac97, reg);\r\n}\r\nreturn ac97->regs[reg];\r\n}\r\nvoid snd_ac97_write_cache(struct snd_ac97 *ac97, unsigned short reg, unsigned short value)\r\n{\r\nif (!snd_ac97_valid_reg(ac97, reg))\r\nreturn;\r\nmutex_lock(&ac97->reg_mutex);\r\nac97->regs[reg] = value;\r\nac97->bus->ops->write(ac97, reg, value);\r\nset_bit(reg, ac97->reg_accessed);\r\nmutex_unlock(&ac97->reg_mutex);\r\n}\r\nint snd_ac97_update(struct snd_ac97 *ac97, unsigned short reg, unsigned short value)\r\n{\r\nint change;\r\nif (!snd_ac97_valid_reg(ac97, reg))\r\nreturn -EINVAL;\r\nmutex_lock(&ac97->reg_mutex);\r\nchange = ac97->regs[reg] != value;\r\nif (change) {\r\nac97->regs[reg] = value;\r\nac97->bus->ops->write(ac97, reg, value);\r\n}\r\nset_bit(reg, ac97->reg_accessed);\r\nmutex_unlock(&ac97->reg_mutex);\r\nreturn change;\r\n}\r\nint snd_ac97_update_bits(struct snd_ac97 *ac97, unsigned short reg, unsigned short mask, unsigned short value)\r\n{\r\nint change;\r\nif (!snd_ac97_valid_reg(ac97, reg))\r\nreturn -EINVAL;\r\nmutex_lock(&ac97->reg_mutex);\r\nchange = snd_ac97_update_bits_nolock(ac97, reg, mask, value);\r\nmutex_unlock(&ac97->reg_mutex);\r\nreturn change;\r\n}\r\nint snd_ac97_update_bits_nolock(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short mask, unsigned short value)\r\n{\r\nint change;\r\nunsigned short old, new;\r\nold = snd_ac97_read_cache(ac97, reg);\r\nnew = (old & ~mask) | (value & mask);\r\nchange = old != new;\r\nif (change) {\r\nac97->regs[reg] = new;\r\nac97->bus->ops->write(ac97, reg, new);\r\n}\r\nset_bit(reg, ac97->reg_accessed);\r\nreturn change;\r\n}\r\nstatic int snd_ac97_ad18xx_update_pcm_bits(struct snd_ac97 *ac97, int codec, unsigned short mask, unsigned short value)\r\n{\r\nint change;\r\nunsigned short old, new, cfg;\r\nmutex_lock(&ac97->page_mutex);\r\nold = ac97->spec.ad18xx.pcmreg[codec];\r\nnew = (old & ~mask) | (value & mask);\r\nchange = old != new;\r\nif (change) {\r\nmutex_lock(&ac97->reg_mutex);\r\ncfg = snd_ac97_read_cache(ac97, AC97_AD_SERIAL_CFG);\r\nac97->spec.ad18xx.pcmreg[codec] = new;\r\nac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,\r\n(cfg & ~0x7000) |\r\nac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);\r\nac97->bus->ops->write(ac97, AC97_PCM, new);\r\nac97->bus->ops->write(ac97, AC97_AD_SERIAL_CFG,\r\ncfg | 0x7000);\r\nmutex_unlock(&ac97->reg_mutex);\r\n}\r\nmutex_unlock(&ac97->page_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_ac97_info_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct ac97_enum *e = (struct ac97_enum *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = e->shift_l == e->shift_r ? 1 : 2;\r\nuinfo->value.enumerated.items = e->mask;\r\nif (uinfo->value.enumerated.item > e->mask - 1)\r\nuinfo->value.enumerated.item = e->mask - 1;\r\nstrcpy(uinfo->value.enumerated.name, e->texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_get_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nstruct ac97_enum *e = (struct ac97_enum *)kcontrol->private_value;\r\nunsigned short val, bitmask;\r\nfor (bitmask = 1; bitmask < e->mask; bitmask <<= 1)\r\n;\r\nval = snd_ac97_read_cache(ac97, e->reg);\r\nucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);\r\nif (e->shift_l != e->shift_r)\r\nucontrol->value.enumerated.item[1] = (val >> e->shift_r) & (bitmask - 1);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_put_enum_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nstruct ac97_enum *e = (struct ac97_enum *)kcontrol->private_value;\r\nunsigned short val;\r\nunsigned short mask, bitmask;\r\nfor (bitmask = 1; bitmask < e->mask; bitmask <<= 1)\r\n;\r\nif (ucontrol->value.enumerated.item[0] > e->mask - 1)\r\nreturn -EINVAL;\r\nval = ucontrol->value.enumerated.item[0] << e->shift_l;\r\nmask = (bitmask - 1) << e->shift_l;\r\nif (e->shift_l != e->shift_r) {\r\nif (ucontrol->value.enumerated.item[1] > e->mask - 1)\r\nreturn -EINVAL;\r\nval |= ucontrol->value.enumerated.item[1] << e->shift_r;\r\nmask |= (bitmask - 1) << e->shift_r;\r\n}\r\nreturn snd_ac97_update_bits(ac97, e->reg, mask, val);\r\n}\r\nstatic int snd_ac97_page_save(struct snd_ac97 *ac97, int reg, struct snd_kcontrol *kcontrol)\r\n{\r\nint page_save = -1;\r\nif ((kcontrol->private_value & (1<<25)) &&\r\n(ac97->ext_id & AC97_EI_REV_MASK) >= AC97_EI_REV_23 &&\r\n(reg >= 0x60 && reg < 0x70)) {\r\nunsigned short page = (kcontrol->private_value >> 26) & 0x0f;\r\nmutex_lock(&ac97->page_mutex);\r\npage_save = snd_ac97_read(ac97, AC97_INT_PAGING) & AC97_PAGE_MASK;\r\nsnd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page);\r\n}\r\nreturn page_save;\r\n}\r\nstatic void snd_ac97_page_restore(struct snd_ac97 *ac97, int page_save)\r\n{\r\nif (page_save >= 0) {\r\nsnd_ac97_update_bits(ac97, AC97_INT_PAGING, AC97_PAGE_MASK, page_save);\r\nmutex_unlock(&ac97->page_mutex);\r\n}\r\n}\r\nstatic int snd_ac97_info_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = shift == rshift ? 1 : 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0x01;\r\nint page_save;\r\npage_save = snd_ac97_page_save(ac97, reg, kcontrol);\r\nucontrol->value.integer.value[0] = (snd_ac97_read_cache(ac97, reg) >> shift) & mask;\r\nif (shift != rshift)\r\nucontrol->value.integer.value[1] = (snd_ac97_read_cache(ac97, reg) >> rshift) & mask;\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nif (shift != rshift)\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nsnd_ac97_page_restore(ac97, page_save);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0x01;\r\nint err, page_save;\r\nunsigned short val, val2, val_mask;\r\npage_save = snd_ac97_page_save(ac97, reg, kcontrol);\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval_mask = mask << shift;\r\nval = val << shift;\r\nif (shift != rshift) {\r\nval2 = (ucontrol->value.integer.value[1] & mask);\r\nif (invert)\r\nval2 = mask - val2;\r\nval_mask |= mask << rshift;\r\nval |= val2 << rshift;\r\n}\r\nerr = snd_ac97_update_bits(ac97, reg, val_mask, val);\r\nsnd_ac97_page_restore(ac97, page_save);\r\n#ifdef CONFIG_SND_AC97_POWER_SAVE\r\nif ((val_mask & AC97_PD_EAPD) &&\r\n(kcontrol->private_value & (1<<30))) {\r\nif (val & AC97_PD_EAPD)\r\nac97->power_up &= ~(1 << (reg>>1));\r\nelse\r\nac97->power_up |= 1 << (reg>>1);\r\nupdate_power_regs(ac97);\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic void set_inv_eapd(struct snd_ac97 *ac97, struct snd_kcontrol *kctl)\r\n{\r\nkctl->private_value = AC97_SINGLE_VALUE(AC97_POWERDOWN, 15, 1, 0);\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN, (1<<15), (1<<15));\r\nac97->scaps |= AC97_SCAP_INV_EAPD;\r\n}\r\nstatic int snd_ac97_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_spdif_cmask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_NONAUDIO |\r\nIEC958_AES0_CON_EMPHASIS_5015 |\r\nIEC958_AES0_CON_NOT_COPYRIGHT;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |\r\nIEC958_AES1_CON_ORIGINAL;\r\nucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_spdif_pmask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PRO_FS |\r\nIEC958_AES0_PRO_EMPHASIS_5015;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_spdif_default_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ac97->reg_mutex);\r\nucontrol->value.iec958.status[0] = ac97->spdif_status & 0xff;\r\nucontrol->value.iec958.status[1] = (ac97->spdif_status >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (ac97->spdif_status >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (ac97->spdif_status >> 24) & 0xff;\r\nmutex_unlock(&ac97->reg_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_spdif_default_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nunsigned int new = 0;\r\nunsigned short val = 0;\r\nint change;\r\nnew = val = ucontrol->value.iec958.status[0] & (IEC958_AES0_PROFESSIONAL|IEC958_AES0_NONAUDIO);\r\nif (ucontrol->value.iec958.status[0] & IEC958_AES0_PROFESSIONAL) {\r\nnew |= ucontrol->value.iec958.status[0] & (IEC958_AES0_PRO_FS|IEC958_AES0_PRO_EMPHASIS_5015);\r\nswitch (new & IEC958_AES0_PRO_FS) {\r\ncase IEC958_AES0_PRO_FS_44100: val |= 0<<12; break;\r\ncase IEC958_AES0_PRO_FS_48000: val |= 2<<12; break;\r\ncase IEC958_AES0_PRO_FS_32000: val |= 3<<12; break;\r\ndefault: val |= 1<<12; break;\r\n}\r\nif ((new & IEC958_AES0_PRO_EMPHASIS) == IEC958_AES0_PRO_EMPHASIS_5015)\r\nval |= 1<<3;\r\n} else {\r\nnew |= ucontrol->value.iec958.status[0] & (IEC958_AES0_CON_EMPHASIS_5015|IEC958_AES0_CON_NOT_COPYRIGHT);\r\nnew |= ((ucontrol->value.iec958.status[1] & (IEC958_AES1_CON_CATEGORY|IEC958_AES1_CON_ORIGINAL)) << 8);\r\nnew |= ((ucontrol->value.iec958.status[3] & IEC958_AES3_CON_FS) << 24);\r\nif ((new & IEC958_AES0_CON_EMPHASIS) == IEC958_AES0_CON_EMPHASIS_5015)\r\nval |= 1<<3;\r\nif (!(new & IEC958_AES0_CON_NOT_COPYRIGHT))\r\nval |= 1<<2;\r\nval |= ((new >> 8) & 0xff) << 4;\r\nswitch ((new >> 24) & 0xff) {\r\ncase IEC958_AES3_CON_FS_44100: val |= 0<<12; break;\r\ncase IEC958_AES3_CON_FS_48000: val |= 2<<12; break;\r\ncase IEC958_AES3_CON_FS_32000: val |= 3<<12; break;\r\ndefault: val |= 1<<12; break;\r\n}\r\n}\r\nmutex_lock(&ac97->reg_mutex);\r\nchange = ac97->spdif_status != new;\r\nac97->spdif_status = new;\r\nif (ac97->flags & AC97_CS_SPDIF) {\r\nint x = (val >> 12) & 0x03;\r\nswitch (x) {\r\ncase 0: x = 1; break;\r\ncase 2: x = 0; break;\r\ndefault: x = 0; break;\r\n}\r\nchange |= snd_ac97_update_bits_nolock(ac97, AC97_CSR_SPDIF, 0x3fff, ((val & 0xcfff) | (x << 12)));\r\n} else if (ac97->flags & AC97_CX_SPDIF) {\r\nint v;\r\nv = new & (IEC958_AES0_CON_EMPHASIS_5015|IEC958_AES0_CON_NOT_COPYRIGHT) ? 0 : AC97_CXR_COPYRGT;\r\nv |= new & IEC958_AES0_NONAUDIO ? AC97_CXR_SPDIF_AC3 : AC97_CXR_SPDIF_PCM;\r\nchange |= snd_ac97_update_bits_nolock(ac97, AC97_CXR_AUDIO_MISC,\r\nAC97_CXR_SPDIF_MASK | AC97_CXR_COPYRGT,\r\nv);\r\n} else if (ac97->id == AC97_ID_YMF743) {\r\nchange |= snd_ac97_update_bits_nolock(ac97,\r\nAC97_YMF7X3_DIT_CTRL,\r\n0xff38,\r\n((val << 4) & 0xff00) |\r\n((val << 2) & 0x0038));\r\n} else {\r\nunsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);\r\nsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nchange |= snd_ac97_update_bits_nolock(ac97, AC97_SPDIF, 0x3fff, val);\r\nif (extst & AC97_EA_SPDIF) {\r\nsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);\r\n}\r\n}\r\nmutex_unlock(&ac97->reg_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_ac97_put_spsa(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nunsigned short value, old, new;\r\nint change;\r\nvalue = (ucontrol->value.integer.value[0] & mask);\r\nmutex_lock(&ac97->reg_mutex);\r\nmask <<= shift;\r\nvalue <<= shift;\r\nold = snd_ac97_read_cache(ac97, reg);\r\nnew = (old & ~mask) | value;\r\nchange = old != new;\r\nif (change) {\r\nunsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);\r\nsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nchange = snd_ac97_update_bits_nolock(ac97, reg, mask, value);\r\nif (extst & AC97_EA_SPDIF)\r\nsnd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);\r\n}\r\nmutex_unlock(&ac97->reg_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_ac97_ad18xx_pcm_info_bits(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint mask = (kcontrol->private_value >> 16) & 0x0f;\r\nint lshift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES))\r\nuinfo->count = 2;\r\nelse\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_ad18xx_pcm_get_bits(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint codec = kcontrol->private_value & 3;\r\nint lshift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nucontrol->value.integer.value[0] = mask - ((ac97->spec.ad18xx.pcmreg[codec] >> lshift) & mask);\r\nif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES))\r\nucontrol->value.integer.value[1] = mask - ((ac97->spec.ad18xx.pcmreg[codec] >> rshift) & mask);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_ad18xx_pcm_put_bits(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint codec = kcontrol->private_value & 3;\r\nint lshift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nunsigned short val, valmask;\r\nval = (mask - (ucontrol->value.integer.value[0] & mask)) << lshift;\r\nvalmask = mask << lshift;\r\nif (lshift != rshift && (ac97->flags & AC97_STEREO_MUTES)) {\r\nval |= (mask - (ucontrol->value.integer.value[1] & mask)) << rshift;\r\nvalmask |= mask << rshift;\r\n}\r\nreturn snd_ac97_ad18xx_update_pcm_bits(ac97, codec, valmask, val);\r\n}\r\nstatic int snd_ac97_ad18xx_pcm_info_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 31;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_ad18xx_pcm_get_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint codec = kcontrol->private_value & 3;\r\nmutex_lock(&ac97->page_mutex);\r\nucontrol->value.integer.value[0] = 31 - ((ac97->spec.ad18xx.pcmreg[codec] >> 0) & 31);\r\nucontrol->value.integer.value[1] = 31 - ((ac97->spec.ad18xx.pcmreg[codec] >> 8) & 31);\r\nmutex_unlock(&ac97->page_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_ad18xx_pcm_put_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint codec = kcontrol->private_value & 3;\r\nunsigned short val1, val2;\r\nval1 = 31 - (ucontrol->value.integer.value[0] & 31);\r\nval2 = 31 - (ucontrol->value.integer.value[1] & 31);\r\nreturn snd_ac97_ad18xx_update_pcm_bits(ac97, codec, 0x1f1f, (val1 << 8) | val2);\r\n}\r\nstatic int snd_ac97_bus_free(struct snd_ac97_bus *bus)\r\n{\r\nif (bus) {\r\nsnd_ac97_bus_proc_done(bus);\r\nkfree(bus->pcms);\r\nif (bus->private_free)\r\nbus->private_free(bus);\r\nkfree(bus);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_bus_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ac97_bus *bus = device->device_data;\r\nreturn snd_ac97_bus_free(bus);\r\n}\r\nstatic int snd_ac97_free(struct snd_ac97 *ac97)\r\n{\r\nif (ac97) {\r\n#ifdef CONFIG_SND_AC97_POWER_SAVE\r\ncancel_delayed_work_sync(&ac97->power_work);\r\n#endif\r\nsnd_ac97_proc_done(ac97);\r\nif (ac97->bus)\r\nac97->bus->codec[ac97->num] = NULL;\r\nif (ac97->private_free)\r\nac97->private_free(ac97);\r\nkfree(ac97);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ac97 *ac97 = device->device_data;\r\nsnd_ac97_powerdown(ac97);\r\nreturn snd_ac97_free(ac97);\r\n}\r\nstatic int snd_ac97_try_volume_mix(struct snd_ac97 * ac97, int reg)\r\n{\r\nunsigned short val, mask = AC97_MUTE_MASK_MONO;\r\nif (! snd_ac97_valid_reg(ac97, reg))\r\nreturn 0;\r\nswitch (reg) {\r\ncase AC97_MASTER_TONE:\r\nreturn ac97->caps & AC97_BC_BASS_TREBLE ? 1 : 0;\r\ncase AC97_HEADPHONE:\r\nreturn ac97->caps & AC97_BC_HEADPHONE ? 1 : 0;\r\ncase AC97_REC_GAIN_MIC:\r\nreturn ac97->caps & AC97_BC_DEDICATED_MIC ? 1 : 0;\r\ncase AC97_3D_CONTROL:\r\nif (ac97->caps & AC97_BC_3D_TECH_ID_MASK) {\r\nval = snd_ac97_read(ac97, reg);\r\nreturn val == 0;\r\n}\r\nreturn 0;\r\ncase AC97_CENTER_LFE_MASTER:\r\nif ((ac97->ext_id & AC97_EI_CDAC) == 0)\r\nreturn 0;\r\nbreak;\r\ncase AC97_CENTER_LFE_MASTER+1:\r\nif ((ac97->ext_id & AC97_EI_LDAC) == 0)\r\nreturn 0;\r\nreg = AC97_CENTER_LFE_MASTER;\r\nmask = 0x0080;\r\nbreak;\r\ncase AC97_SURROUND_MASTER:\r\nif ((ac97->ext_id & AC97_EI_SDAC) == 0)\r\nreturn 0;\r\nbreak;\r\n}\r\nval = snd_ac97_read(ac97, reg);\r\nif (!(val & mask)) {\r\nsnd_ac97_write_cache(ac97, reg, val | mask);\r\nval = snd_ac97_read(ac97, reg);\r\nval = snd_ac97_read(ac97, reg);\r\nif (!(val & mask))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void check_volume_resolution(struct snd_ac97 *ac97, int reg, unsigned char *lo_max, unsigned char *hi_max)\r\n{\r\nunsigned short cbit[3] = { 0x20, 0x10, 0x01 };\r\nunsigned char max[3] = { 63, 31, 15 };\r\nint i;\r\nif (ac97->res_table) {\r\nconst struct snd_ac97_res_table *tbl;\r\nfor (tbl = ac97->res_table; tbl->reg; tbl++) {\r\nif (tbl->reg == reg) {\r\n*lo_max = tbl->bits & 0xff;\r\n*hi_max = (tbl->bits >> 8) & 0xff;\r\nreturn;\r\n}\r\n}\r\n}\r\n*lo_max = *hi_max = 0;\r\nfor (i = 0 ; i < ARRAY_SIZE(cbit); i++) {\r\nunsigned short val;\r\nsnd_ac97_write(\r\nac97, reg,\r\nAC97_MUTE_MASK_STEREO | cbit[i] | (cbit[i] << 8)\r\n);\r\nval = snd_ac97_read(ac97, reg);\r\nval = snd_ac97_read(ac97, reg);\r\nif (! *lo_max && (val & 0x7f) == cbit[i])\r\n*lo_max = max[i];\r\nif (! *hi_max && ((val >> 8) & 0x7f) == cbit[i])\r\n*hi_max = max[i];\r\nif (*lo_max && *hi_max)\r\nbreak;\r\n}\r\n}\r\nstatic int snd_ac97_try_bit(struct snd_ac97 * ac97, int reg, int bit)\r\n{\r\nunsigned short mask, val, orig, res;\r\nmask = 1 << bit;\r\norig = snd_ac97_read(ac97, reg);\r\nval = orig ^ mask;\r\nsnd_ac97_write(ac97, reg, val);\r\nres = snd_ac97_read(ac97, reg);\r\nsnd_ac97_write_cache(ac97, reg, orig);\r\nreturn res == val;\r\n}\r\nstatic void snd_ac97_change_volume_params2(struct snd_ac97 * ac97, int reg, int shift, unsigned char *max)\r\n{\r\nunsigned short val, val1;\r\n*max = 63;\r\nval = AC97_MUTE_MASK_STEREO | (0x20 << shift);\r\nsnd_ac97_write(ac97, reg, val);\r\nval1 = snd_ac97_read(ac97, reg);\r\nif (val != val1) {\r\n*max = 31;\r\n}\r\nsnd_ac97_write_cache(ac97, reg, AC97_MUTE_MASK_STEREO);\r\n}\r\nstatic inline int printable(unsigned int x)\r\n{\r\nx &= 0xff;\r\nif (x < ' ' || x >= 0x71) {\r\nif (x <= 0x89)\r\nreturn x - 0x71 + 'A';\r\nreturn '?';\r\n}\r\nreturn x;\r\n}\r\nstatic struct snd_kcontrol *snd_ac97_cnew(const struct snd_kcontrol_new *_template,\r\nstruct snd_ac97 * ac97)\r\n{\r\nstruct snd_kcontrol_new template;\r\nmemcpy(&template, _template, sizeof(template));\r\ntemplate.index = ac97->num;\r\nreturn snd_ctl_new1(&template, ac97);\r\n}\r\nstatic int snd_ac97_cmute_new_stereo(struct snd_card *card, char *name, int reg,\r\nint check_stereo, int check_amix,\r\nstruct snd_ac97 *ac97)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nunsigned short val, val1, mute_mask;\r\nif (! snd_ac97_valid_reg(ac97, reg))\r\nreturn 0;\r\nmute_mask = AC97_MUTE_MASK_MONO;\r\nval = snd_ac97_read(ac97, reg);\r\nif (check_stereo || (ac97->flags & AC97_STEREO_MUTES)) {\r\nval1 = val | AC97_MUTE_MASK_STEREO;\r\nsnd_ac97_write(ac97, reg, val1);\r\nif (val1 == snd_ac97_read(ac97, reg))\r\nmute_mask = AC97_MUTE_MASK_STEREO;\r\n}\r\nif (mute_mask == AC97_MUTE_MASK_STEREO) {\r\nstruct snd_kcontrol_new tmp = AC97_DOUBLE(name, reg, 15, 7, 1, 1);\r\nif (check_amix)\r\ntmp.private_value |= (1 << 30);\r\ntmp.index = ac97->num;\r\nkctl = snd_ctl_new1(&tmp, ac97);\r\n} else {\r\nstruct snd_kcontrol_new tmp = AC97_SINGLE(name, reg, 15, 1, 1);\r\nif (check_amix)\r\ntmp.private_value |= (1 << 30);\r\ntmp.index = ac97->num;\r\nkctl = snd_ctl_new1(&tmp, ac97);\r\n}\r\nerr = snd_ctl_add(card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nsnd_ac97_write_cache(ac97, reg, val | mute_mask);\r\nreturn 0;\r\n}\r\nstatic const unsigned int *find_db_scale(unsigned int maxval)\r\n{\r\nswitch (maxval) {\r\ncase 0x0f: return db_scale_4bit;\r\ncase 0x1f: return db_scale_5bit;\r\ncase 0x3f: return db_scale_6bit;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void set_tlv_db_scale(struct snd_kcontrol *kctl, const unsigned int *tlv)\r\n{\r\nkctl->tlv.p = tlv;\r\nif (tlv)\r\nkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\n}\r\nstatic int snd_ac97_cvol_new(struct snd_card *card, char *name, int reg, unsigned int lo_max,\r\nunsigned int hi_max, struct snd_ac97 *ac97)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nif (! snd_ac97_valid_reg(ac97, reg))\r\nreturn 0;\r\nif (hi_max) {\r\nstruct snd_kcontrol_new tmp = AC97_DOUBLE(name, reg, 8, 0, lo_max, 1);\r\ntmp.index = ac97->num;\r\nkctl = snd_ctl_new1(&tmp, ac97);\r\n} else {\r\nstruct snd_kcontrol_new tmp = AC97_SINGLE(name, reg, 0, lo_max, 1);\r\ntmp.index = ac97->num;\r\nkctl = snd_ctl_new1(&tmp, ac97);\r\n}\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nif (reg >= AC97_PHONE && reg <= AC97_PCM)\r\nset_tlv_db_scale(kctl, db_scale_5bit_12db_max);\r\nelse\r\nset_tlv_db_scale(kctl, find_db_scale(lo_max));\r\nerr = snd_ctl_add(card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nsnd_ac97_write_cache(\r\nac97, reg,\r\n(snd_ac97_read(ac97, reg) & AC97_MUTE_MASK_STEREO)\r\n| lo_max | (hi_max << 8)\r\n);\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_cmix_new_stereo(struct snd_card *card, const char *pfx,\r\nint reg, int check_stereo, int check_amix,\r\nstruct snd_ac97 *ac97)\r\n{\r\nint err;\r\nchar name[44];\r\nunsigned char lo_max, hi_max;\r\nif (! snd_ac97_valid_reg(ac97, reg))\r\nreturn 0;\r\nif (snd_ac97_try_bit(ac97, reg, 15)) {\r\nsprintf(name, "%s Switch", pfx);\r\nif ((err = snd_ac97_cmute_new_stereo(card, name, reg,\r\ncheck_stereo, check_amix,\r\nac97)) < 0)\r\nreturn err;\r\n}\r\ncheck_volume_resolution(ac97, reg, &lo_max, &hi_max);\r\nif (lo_max) {\r\nsprintf(name, "%s Volume", pfx);\r\nif ((err = snd_ac97_cvol_new(card, name, reg, lo_max, hi_max, ac97)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_mixer_build(struct snd_ac97 * ac97)\r\n{\r\nstruct snd_card *card = ac97->bus->card;\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nunsigned int idx;\r\nunsigned char max;\r\nif (snd_ac97_try_volume_mix(ac97, AC97_MASTER)) {\r\nif (ac97->flags & AC97_HAS_NO_MASTER_VOL)\r\nerr = snd_ac97_cmute_new(card, "Master Playback Switch",\r\nAC97_MASTER, 0, ac97);\r\nelse\r\nerr = snd_ac97_cmix_new(card, "Master Playback",\r\nAC97_MASTER, 0, ac97);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nac97->regs[AC97_CENTER_LFE_MASTER] = AC97_MUTE_MASK_STEREO;\r\nif ((snd_ac97_try_volume_mix(ac97, AC97_CENTER_LFE_MASTER))\r\n&& !(ac97->flags & AC97_AD_MULTI)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_center[0], ac97))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_center[1], ac97))) < 0)\r\nreturn err;\r\nsnd_ac97_change_volume_params2(ac97, AC97_CENTER_LFE_MASTER, 0, &max);\r\nkctl->private_value &= ~(0xff << 16);\r\nkctl->private_value |= (int)max << 16;\r\nset_tlv_db_scale(kctl, find_db_scale(max));\r\nsnd_ac97_write_cache(ac97, AC97_CENTER_LFE_MASTER, ac97->regs[AC97_CENTER_LFE_MASTER] | max);\r\n}\r\nif ((snd_ac97_try_volume_mix(ac97, AC97_CENTER_LFE_MASTER+1))\r\n&& !(ac97->flags & AC97_AD_MULTI)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_lfe[0], ac97))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_lfe[1], ac97))) < 0)\r\nreturn err;\r\nsnd_ac97_change_volume_params2(ac97, AC97_CENTER_LFE_MASTER, 8, &max);\r\nkctl->private_value &= ~(0xff << 16);\r\nkctl->private_value |= (int)max << 16;\r\nset_tlv_db_scale(kctl, find_db_scale(max));\r\nsnd_ac97_write_cache(ac97, AC97_CENTER_LFE_MASTER, ac97->regs[AC97_CENTER_LFE_MASTER] | max << 8);\r\n}\r\nif ((snd_ac97_try_volume_mix(ac97, AC97_SURROUND_MASTER))\r\n&& !(ac97->flags & AC97_AD_MULTI)) {\r\nif ((err = snd_ac97_cmix_new_stereo(card, "Surround Playback",\r\nAC97_SURROUND_MASTER, 1, 0,\r\nac97)) < 0)\r\nreturn err;\r\n}\r\nif (snd_ac97_try_volume_mix(ac97, AC97_HEADPHONE)) {\r\nif ((err = snd_ac97_cmix_new(card, "Headphone Playback",\r\nAC97_HEADPHONE, 0, ac97)) < 0)\r\nreturn err;\r\n}\r\nif (snd_ac97_try_volume_mix(ac97, AC97_MASTER_MONO)) {\r\nif ((err = snd_ac97_cmix_new(card, "Master Mono Playback",\r\nAC97_MASTER_MONO, 0, ac97)) < 0)\r\nreturn err;\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_TONE)) {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_MASTER_TONE)) {\r\nfor (idx = 0; idx < 2; idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_tone[idx], ac97))) < 0)\r\nreturn err;\r\nif (ac97->id == AC97_ID_YMF743 ||\r\nac97->id == AC97_ID_YMF753) {\r\nkctl->private_value &= ~(0xff << 16);\r\nkctl->private_value |= 7 << 16;\r\n}\r\n}\r\nsnd_ac97_write_cache(ac97, AC97_MASTER_TONE, 0x0f0f);\r\n}\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_PC_BEEP) &&\r\n((ac97->flags & AC97_HAS_PC_BEEP) ||\r\nsnd_ac97_try_volume_mix(ac97, AC97_PC_BEEP))) {\r\nfor (idx = 0; idx < 2; idx++)\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_pc_beep[idx], ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_4bit);\r\nsnd_ac97_write_cache(\r\nac97,\r\nAC97_PC_BEEP,\r\n(snd_ac97_read(ac97, AC97_PC_BEEP)\r\n| AC97_MUTE_MASK_MONO | 0x001e)\r\n);\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_PHONE)) {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {\r\nif ((err = snd_ac97_cmix_new(card, "Phone Playback",\r\nAC97_PHONE, 1, ac97)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_MIC)) {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_MIC)) {\r\nif ((err = snd_ac97_cmix_new(card, "Mic Playback",\r\nAC97_MIC, 1, ac97)) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_mic_boost, ac97))) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (snd_ac97_try_volume_mix(ac97, AC97_LINE)) {\r\nif ((err = snd_ac97_cmix_new(card, "Line Playback",\r\nAC97_LINE, 1, ac97)) < 0)\r\nreturn err;\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_CD)) {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_CD)) {\r\nif ((err = snd_ac97_cmix_new(card, "CD Playback",\r\nAC97_CD, 1, ac97)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_VIDEO)) {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_VIDEO)) {\r\nif ((err = snd_ac97_cmix_new(card, "Video Playback",\r\nAC97_VIDEO, 1, ac97)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_AUX)) {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_AUX)) {\r\nif ((err = snd_ac97_cmix_new(card, "Aux Playback",\r\nAC97_AUX, 1, ac97)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (ac97->flags & AC97_AD_MULTI) {\r\nunsigned short init_val;\r\nif (ac97->flags & AC97_STEREO_MUTES)\r\ninit_val = 0x9f9f;\r\nelse\r\ninit_val = 0x9f1f;\r\nfor (idx = 0; idx < 2; idx++)\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_pcm[idx], ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_5bit);\r\nac97->spec.ad18xx.pcmreg[0] = init_val;\r\nif (ac97->scaps & AC97_SCAP_SURROUND_DAC) {\r\nfor (idx = 0; idx < 2; idx++)\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_surround[idx], ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_5bit);\r\nac97->spec.ad18xx.pcmreg[1] = init_val;\r\n}\r\nif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC) {\r\nfor (idx = 0; idx < 2; idx++)\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_center[idx], ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_5bit);\r\nfor (idx = 0; idx < 2; idx++)\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_ad18xx_lfe[idx], ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_5bit);\r\nac97->spec.ad18xx.pcmreg[2] = init_val;\r\n}\r\nsnd_ac97_write_cache(ac97, AC97_PCM, init_val);\r\n} else {\r\nif (!(ac97->flags & AC97_HAS_NO_STD_PCM)) {\r\nif (ac97->flags & AC97_HAS_NO_PCM_VOL)\r\nerr = snd_ac97_cmute_new(card,\r\n"PCM Playback Switch",\r\nAC97_PCM, 0, ac97);\r\nelse\r\nerr = snd_ac97_cmix_new(card, "PCM Playback",\r\nAC97_PCM, 0, ac97);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (!(ac97->flags & AC97_HAS_NO_REC_GAIN)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_src, ac97))) < 0)\r\nreturn err;\r\nif (snd_ac97_try_bit(ac97, AC97_REC_GAIN, 15)) {\r\nerr = snd_ac97_cmute_new(card, "Capture Switch",\r\nAC97_REC_GAIN, 0, ac97);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_control_capture_vol, ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_rec_gain);\r\nsnd_ac97_write_cache(ac97, AC97_REC_SEL, 0x0000);\r\nsnd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x0000);\r\n}\r\nif (snd_ac97_try_volume_mix(ac97, AC97_REC_GAIN_MIC)) {\r\nfor (idx = 0; idx < 2; idx++)\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_mic_capture[idx], ac97))) < 0)\r\nreturn err;\r\nset_tlv_db_scale(kctl, db_scale_rec_gain);\r\nsnd_ac97_write_cache(ac97, AC97_REC_GAIN_MIC, 0x0000);\r\n}\r\nif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 15)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_PCM_OUT], ac97))) < 0)\r\nreturn err;\r\n}\r\nif (ac97->caps & AC97_BC_SIM_STEREO) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_STEREO_ENHANCEMENT], ac97))) < 0)\r\nreturn err;\r\n}\r\nif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 13)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_3D], ac97))) < 0)\r\nreturn err;\r\n}\r\nif (ac97->caps & AC97_BC_LOUDNESS) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_LOUDNESS], ac97))) < 0)\r\nreturn err;\r\n}\r\nif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 9)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_MONO], ac97))) < 0)\r\nreturn err;\r\n}\r\nif (snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 8)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_MIC], ac97))) < 0)\r\nreturn err;\r\n}\r\nif (enable_loopback && snd_ac97_try_bit(ac97, AC97_GENERAL_PURPOSE, 7)) {\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_general[AC97_GENERAL_LOOPBACK], ac97))) < 0)\r\nreturn err;\r\n}\r\nsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, ~AC97_GP_DRSS_MASK, 0x0000);\r\nif (ac97->build_ops->build_3d) {\r\nac97->build_ops->build_3d(ac97);\r\n} else {\r\nif (snd_ac97_try_volume_mix(ac97, AC97_3D_CONTROL)) {\r\nunsigned short val;\r\nval = 0x0707;\r\nsnd_ac97_write(ac97, AC97_3D_CONTROL, val);\r\nval = snd_ac97_read(ac97, AC97_3D_CONTROL);\r\nval = val == 0x0606;\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_3d[0], ac97))) < 0)\r\nreturn err;\r\nif (val)\r\nkctl->private_value = AC97_3D_CONTROL | (9 << 8) | (7 << 16);\r\nif ((err = snd_ctl_add(card, kctl = snd_ac97_cnew(&snd_ac97_controls_3d[1], ac97))) < 0)\r\nreturn err;\r\nif (val)\r\nkctl->private_value = AC97_3D_CONTROL | (1 << 8) | (7 << 16);\r\nsnd_ac97_write_cache(ac97, AC97_3D_CONTROL, 0x0000);\r\n}\r\n}\r\nif (ac97->subsystem_vendor == 0x1043 &&\r\nac97->subsystem_device == 0x810f)\r\nac97->ext_id |= AC97_EI_SPDIF;\r\nif ((ac97->ext_id & AC97_EI_SPDIF) && !(ac97->scaps & AC97_SCAP_NO_SPDIF)) {\r\nif (ac97->build_ops->build_spdif) {\r\nif ((err = ac97->build_ops->build_spdif(ac97)) < 0)\r\nreturn err;\r\n} else {\r\nfor (idx = 0; idx < 5; idx++)\r\nif ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_spdif[idx], ac97))) < 0)\r\nreturn err;\r\nif (ac97->build_ops->build_post_spdif) {\r\nif ((err = ac97->build_ops->build_post_spdif(ac97)) < 0)\r\nreturn err;\r\n}\r\nsnd_ac97_write_cache(ac97, AC97_SPDIF, 0x2a20);\r\nac97->rates[AC97_RATES_SPDIF] = snd_ac97_determine_spdif_rates(ac97);\r\n}\r\nac97->spdif_status = SNDRV_PCM_DEFAULT_CON_SPDIF;\r\n}\r\nif (ac97->build_ops->build_specific)\r\nif ((err = ac97->build_ops->build_specific(ac97)) < 0)\r\nreturn err;\r\nif (snd_ac97_try_bit(ac97, AC97_POWERDOWN, 15)) {\r\nkctl = snd_ac97_cnew(&snd_ac97_control_eapd, ac97);\r\nif (! kctl)\r\nreturn -ENOMEM;\r\nif (ac97->scaps & AC97_SCAP_INV_EAPD)\r\nset_inv_eapd(ac97, kctl);\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_modem_build(struct snd_card *card, struct snd_ac97 * ac97)\r\n{\r\nint err, idx;\r\nsnd_ac97_write(ac97, AC97_GPIO_CFG, 0xffff & ~(AC97_GPIO_LINE1_OH));\r\nsnd_ac97_write(ac97, AC97_GPIO_POLARITY, 0xffff & ~(AC97_GPIO_LINE1_OH));\r\nsnd_ac97_write(ac97, AC97_GPIO_STICKY, 0xffff);\r\nsnd_ac97_write(ac97, AC97_GPIO_WAKEUP, 0x0);\r\nsnd_ac97_write(ac97, AC97_MISC_AFE, 0x0);\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ac97_controls_modem_switches); idx++)\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_ac97_controls_modem_switches[idx], ac97))) < 0)\r\nreturn err;\r\nif (ac97->build_ops->build_specific)\r\nif ((err = ac97->build_ops->build_specific(ac97)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_test_rate(struct snd_ac97 *ac97, int reg, int shadow_reg, int rate)\r\n{\r\nunsigned short val;\r\nunsigned int tmp;\r\ntmp = ((unsigned int)rate * ac97->bus->clock) / 48000;\r\nsnd_ac97_write_cache(ac97, reg, tmp & 0xffff);\r\nif (shadow_reg)\r\nsnd_ac97_write_cache(ac97, shadow_reg, tmp & 0xffff);\r\nval = snd_ac97_read(ac97, reg);\r\nreturn val == (tmp & 0xffff);\r\n}\r\nstatic void snd_ac97_determine_rates(struct snd_ac97 *ac97, int reg, int shadow_reg, unsigned int *r_result)\r\n{\r\nunsigned int result = 0;\r\nunsigned short saved;\r\nif (ac97->bus->no_vra) {\r\n*r_result = SNDRV_PCM_RATE_48000;\r\nif ((ac97->flags & AC97_DOUBLE_RATE) &&\r\nreg == AC97_PCM_FRONT_DAC_RATE)\r\n*r_result |= SNDRV_PCM_RATE_96000;\r\nreturn;\r\n}\r\nsaved = snd_ac97_read(ac97, reg);\r\nif ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\r\nAC97_EA_DRA, 0);\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 11000))\r\nresult |= SNDRV_PCM_RATE_CONTINUOUS;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 8000))\r\nresult |= SNDRV_PCM_RATE_8000;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 11025))\r\nresult |= SNDRV_PCM_RATE_11025;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 16000))\r\nresult |= SNDRV_PCM_RATE_16000;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 22050))\r\nresult |= SNDRV_PCM_RATE_22050;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 32000))\r\nresult |= SNDRV_PCM_RATE_32000;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 44100))\r\nresult |= SNDRV_PCM_RATE_44100;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 48000))\r\nresult |= SNDRV_PCM_RATE_48000;\r\nif ((ac97->flags & AC97_DOUBLE_RATE) &&\r\nreg == AC97_PCM_FRONT_DAC_RATE) {\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\r\nAC97_EA_DRA, AC97_EA_DRA);\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 64000 / 2))\r\nresult |= SNDRV_PCM_RATE_64000;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 88200 / 2))\r\nresult |= SNDRV_PCM_RATE_88200;\r\nif (snd_ac97_test_rate(ac97, reg, shadow_reg, 96000 / 2))\r\nresult |= SNDRV_PCM_RATE_96000;\r\nif (!snd_ac97_test_rate(ac97, reg, shadow_reg, 76100 / 2))\r\nresult &= ~SNDRV_PCM_RATE_CONTINUOUS;\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\r\nAC97_EA_DRA, 0);\r\n}\r\nsnd_ac97_write_cache(ac97, reg, saved);\r\nif (shadow_reg)\r\nsnd_ac97_write_cache(ac97, shadow_reg, saved);\r\n*r_result = result;\r\n}\r\nstatic unsigned int snd_ac97_determine_spdif_rates(struct snd_ac97 *ac97)\r\n{\r\nunsigned int result = 0;\r\nint i;\r\nstatic unsigned short ctl_bits[] = {\r\nAC97_SC_SPSR_44K, AC97_SC_SPSR_32K, AC97_SC_SPSR_48K\r\n};\r\nstatic unsigned int rate_bits[] = {\r\nSNDRV_PCM_RATE_44100, SNDRV_PCM_RATE_32000, SNDRV_PCM_RATE_48000\r\n};\r\nfor (i = 0; i < (int)ARRAY_SIZE(ctl_bits); i++) {\r\nsnd_ac97_update_bits(ac97, AC97_SPDIF, AC97_SC_SPSR_MASK, ctl_bits[i]);\r\nif ((snd_ac97_read(ac97, AC97_SPDIF) & AC97_SC_SPSR_MASK) == ctl_bits[i])\r\nresult |= rate_bits[i];\r\n}\r\nreturn result;\r\n}\r\nstatic const struct ac97_codec_id *look_for_codec_id(const struct ac97_codec_id *table,\r\nunsigned int id)\r\n{\r\nconst struct ac97_codec_id *pid;\r\nfor (pid = table; pid->id; pid++)\r\nif (pid->id == (id & pid->mask))\r\nreturn pid;\r\nreturn NULL;\r\n}\r\nvoid snd_ac97_get_name(struct snd_ac97 *ac97, unsigned int id, char *name, int modem)\r\n{\r\nconst struct ac97_codec_id *pid;\r\nsprintf(name, "0x%x %c%c%c", id,\r\nprintable(id >> 24),\r\nprintable(id >> 16),\r\nprintable(id >> 8));\r\npid = look_for_codec_id(snd_ac97_codec_id_vendors, id);\r\nif (! pid)\r\nreturn;\r\nstrcpy(name, pid->name);\r\nif (ac97 && pid->patch) {\r\nif ((modem && (pid->flags & AC97_MODEM_PATCH)) ||\r\n(! modem && ! (pid->flags & AC97_MODEM_PATCH)))\r\npid->patch(ac97);\r\n}\r\npid = look_for_codec_id(snd_ac97_codec_ids, id);\r\nif (pid) {\r\nstrcat(name, " ");\r\nstrcat(name, pid->name);\r\nif (pid->mask != 0xffffffff)\r\nsprintf(name + strlen(name), " rev %d", id & ~pid->mask);\r\nif (ac97 && pid->patch) {\r\nif ((modem && (pid->flags & AC97_MODEM_PATCH)) ||\r\n(! modem && ! (pid->flags & AC97_MODEM_PATCH)))\r\npid->patch(ac97);\r\n}\r\n} else\r\nsprintf(name + strlen(name), " id %x", id & 0xff);\r\n}\r\nconst char *snd_ac97_get_short_name(struct snd_ac97 *ac97)\r\n{\r\nconst struct ac97_codec_id *pid;\r\nfor (pid = snd_ac97_codec_ids; pid->id; pid++)\r\nif (pid->id == (ac97->id & pid->mask))\r\nreturn pid->name;\r\nreturn "unknown codec";\r\n}\r\nstatic int ac97_reset_wait(struct snd_ac97 *ac97, int timeout, int with_modem)\r\n{\r\nunsigned long end_time;\r\nunsigned short val;\r\nend_time = jiffies + timeout;\r\ndo {\r\nsnd_ac97_read(ac97, AC97_RESET);\r\nsnd_ac97_read(ac97, AC97_VENDOR_ID1);\r\nsnd_ac97_read(ac97, AC97_VENDOR_ID2);\r\nif (with_modem) {\r\nval = snd_ac97_read(ac97, AC97_EXTENDED_MID);\r\nif (val != 0xffff && (val & 1) != 0)\r\nreturn 0;\r\n}\r\nif (ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR) {\r\nval = snd_ac97_read(ac97, AC97_VENDOR_ID1);\r\nif (val != 0 && val != 0xffff)\r\nreturn 0;\r\n} else {\r\nsnd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a05);\r\nif ((snd_ac97_read(ac97, AC97_REC_GAIN) & 0x7fff) == 0x0a05)\r\nreturn 0;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nreturn -ENODEV;\r\n}\r\nint snd_ac97_bus(struct snd_card *card, int num, struct snd_ac97_bus_ops *ops,\r\nvoid *private_data, struct snd_ac97_bus **rbus)\r\n{\r\nint err;\r\nstruct snd_ac97_bus *bus;\r\nstatic struct snd_device_ops dev_ops = {\r\n.dev_free = snd_ac97_bus_dev_free,\r\n};\r\nif (snd_BUG_ON(!card))\r\nreturn -EINVAL;\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (bus == NULL)\r\nreturn -ENOMEM;\r\nbus->card = card;\r\nbus->num = num;\r\nbus->ops = ops;\r\nbus->private_data = private_data;\r\nbus->clock = 48000;\r\nspin_lock_init(&bus->bus_lock);\r\nsnd_ac97_bus_proc_init(bus);\r\nif ((err = snd_device_new(card, SNDRV_DEV_BUS, bus, &dev_ops)) < 0) {\r\nsnd_ac97_bus_free(bus);\r\nreturn err;\r\n}\r\nif (rbus)\r\n*rbus = bus;\r\nreturn 0;\r\n}\r\nstatic void ac97_device_release(struct device * dev)\r\n{\r\n}\r\nstatic int snd_ac97_dev_register(struct snd_device *device)\r\n{\r\nstruct snd_ac97 *ac97 = device->device_data;\r\nint err;\r\nac97->dev.bus = &ac97_bus_type;\r\nac97->dev.parent = ac97->bus->card->dev;\r\nac97->dev.release = ac97_device_release;\r\ndev_set_name(&ac97->dev, "%d-%d:%s",\r\nac97->bus->card->number, ac97->num,\r\nsnd_ac97_get_short_name(ac97));\r\nif ((err = device_register(&ac97->dev)) < 0) {\r\nsnd_printk(KERN_ERR "Can't register ac97 bus\n");\r\nac97->dev.bus = NULL;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ac97_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_ac97 *ac97 = device->device_data;\r\nif (ac97->dev.bus)\r\ndevice_unregister(&ac97->dev);\r\nreturn 0;\r\n}\r\nstatic void do_update_power(struct work_struct *work)\r\n{\r\nupdate_power_regs(\r\ncontainer_of(work, struct snd_ac97, power_work.work));\r\n}\r\nint snd_ac97_mixer(struct snd_ac97_bus *bus, struct snd_ac97_template *template, struct snd_ac97 **rac97)\r\n{\r\nint err;\r\nstruct snd_ac97 *ac97;\r\nstruct snd_card *card;\r\nchar name[64];\r\nunsigned long end_time;\r\nunsigned int reg;\r\nconst struct ac97_codec_id *pid;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ac97_dev_free,\r\n.dev_register = snd_ac97_dev_register,\r\n.dev_disconnect = snd_ac97_dev_disconnect,\r\n};\r\nif (rac97)\r\n*rac97 = NULL;\r\nif (snd_BUG_ON(!bus || !template))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(template->num >= 4))\r\nreturn -EINVAL;\r\nif (bus->codec[template->num])\r\nreturn -EBUSY;\r\ncard = bus->card;\r\nac97 = kzalloc(sizeof(*ac97), GFP_KERNEL);\r\nif (ac97 == NULL)\r\nreturn -ENOMEM;\r\nac97->private_data = template->private_data;\r\nac97->private_free = template->private_free;\r\nac97->bus = bus;\r\nac97->pci = template->pci;\r\nac97->num = template->num;\r\nac97->addr = template->addr;\r\nac97->scaps = template->scaps;\r\nac97->res_table = template->res_table;\r\nbus->codec[ac97->num] = ac97;\r\nmutex_init(&ac97->reg_mutex);\r\nmutex_init(&ac97->page_mutex);\r\n#ifdef CONFIG_SND_AC97_POWER_SAVE\r\nINIT_DELAYED_WORK(&ac97->power_work, do_update_power);\r\n#endif\r\n#ifdef CONFIG_PCI\r\nif (ac97->pci) {\r\npci_read_config_word(ac97->pci, PCI_SUBSYSTEM_VENDOR_ID, &ac97->subsystem_vendor);\r\npci_read_config_word(ac97->pci, PCI_SUBSYSTEM_ID, &ac97->subsystem_device);\r\n}\r\n#endif\r\nif (bus->ops->reset) {\r\nbus->ops->reset(ac97);\r\ngoto __access_ok;\r\n}\r\nac97->id = snd_ac97_read(ac97, AC97_VENDOR_ID1) << 16;\r\nac97->id |= snd_ac97_read(ac97, AC97_VENDOR_ID2);\r\nif (ac97->id && ac97->id != (unsigned int)-1) {\r\npid = look_for_codec_id(snd_ac97_codec_ids, ac97->id);\r\nif (pid && (pid->flags & AC97_DEFAULT_POWER_OFF))\r\ngoto __access_ok;\r\n}\r\nif (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO))\r\nsnd_ac97_write(ac97, AC97_RESET, 0);\r\nif (!(ac97->scaps & AC97_SCAP_SKIP_MODEM))\r\nsnd_ac97_write(ac97, AC97_EXTENDED_MID, 0);\r\nif (bus->ops->wait)\r\nbus->ops->wait(ac97);\r\nelse {\r\nudelay(50);\r\nif (ac97->scaps & AC97_SCAP_SKIP_AUDIO)\r\nerr = ac97_reset_wait(ac97, msecs_to_jiffies(500), 1);\r\nelse {\r\nerr = ac97_reset_wait(ac97, msecs_to_jiffies(500), 0);\r\nif (err < 0)\r\nerr = ac97_reset_wait(ac97,\r\nmsecs_to_jiffies(500), 1);\r\n}\r\nif (err < 0) {\r\nsnd_printk(KERN_WARNING "AC'97 %d does not respond - RESET\n", ac97->num);\r\n}\r\n}\r\n__access_ok:\r\nac97->id = snd_ac97_read(ac97, AC97_VENDOR_ID1) << 16;\r\nac97->id |= snd_ac97_read(ac97, AC97_VENDOR_ID2);\r\nif (! (ac97->scaps & AC97_SCAP_DETECT_BY_VENDOR) &&\r\n(ac97->id == 0x00000000 || ac97->id == 0xffffffff)) {\r\nsnd_printk(KERN_ERR "AC'97 %d access is not valid [0x%x], removing mixer.\n", ac97->num, ac97->id);\r\nsnd_ac97_free(ac97);\r\nreturn -EIO;\r\n}\r\npid = look_for_codec_id(snd_ac97_codec_ids, ac97->id);\r\nif (pid)\r\nac97->flags |= pid->flags;\r\nif (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO) && !(ac97->scaps & AC97_SCAP_AUDIO)) {\r\nsnd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x8a06);\r\nif (((err = snd_ac97_read(ac97, AC97_REC_GAIN)) & 0x7fff) == 0x0a06)\r\nac97->scaps |= AC97_SCAP_AUDIO;\r\n}\r\nif (ac97->scaps & AC97_SCAP_AUDIO) {\r\nac97->caps = snd_ac97_read(ac97, AC97_RESET);\r\nac97->ext_id = snd_ac97_read(ac97, AC97_EXTENDED_ID);\r\nif (ac97->ext_id == 0xffff)\r\nac97->ext_id = 0;\r\n}\r\nif (!(ac97->scaps & AC97_SCAP_SKIP_MODEM) && !(ac97->scaps & AC97_SCAP_MODEM)) {\r\nac97->ext_mid = snd_ac97_read(ac97, AC97_EXTENDED_MID);\r\nif (ac97->ext_mid == 0xffff)\r\nac97->ext_mid = 0;\r\nif (ac97->ext_mid & 1)\r\nac97->scaps |= AC97_SCAP_MODEM;\r\n}\r\nif (!ac97_is_audio(ac97) && !ac97_is_modem(ac97)) {\r\nif (!(ac97->scaps & (AC97_SCAP_SKIP_AUDIO|AC97_SCAP_SKIP_MODEM)))\r\nsnd_printk(KERN_ERR "AC'97 %d access error (not audio or modem codec)\n", ac97->num);\r\nsnd_ac97_free(ac97);\r\nreturn -EACCES;\r\n}\r\nif (bus->ops->reset)\r\ngoto __ready_ok;\r\nif (ac97_is_audio(ac97)) {\r\nsnd_ac97_write_cache(ac97, AC97_POWERDOWN, 0);\r\nif (! (ac97->flags & AC97_DEFAULT_POWER_OFF)) {\r\nsnd_ac97_write_cache(ac97, AC97_RESET, 0);\r\nudelay(100);\r\nsnd_ac97_write_cache(ac97, AC97_POWERDOWN, 0);\r\n}\r\nsnd_ac97_write_cache(ac97, AC97_GENERAL_PURPOSE, 0);\r\nend_time = jiffies + msecs_to_jiffies(5000);\r\ndo {\r\nif ((snd_ac97_read(ac97, AC97_POWERDOWN) & 0x0f) == 0x0f)\r\ngoto __ready_ok;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printk(KERN_WARNING "AC'97 %d analog subsections not ready\n", ac97->num);\r\n}\r\nif (ac97_is_modem(ac97)) {\r\nunsigned char tmp;\r\ntmp = AC97_MEA_GPIO;\r\nif (ac97->ext_mid & AC97_MEI_LINE1) {\r\nsnd_ac97_write_cache(ac97, AC97_LINE1_RATE, 8000);\r\ntmp |= AC97_MEA_ADC1 | AC97_MEA_DAC1;\r\n}\r\nif (ac97->ext_mid & AC97_MEI_LINE2) {\r\nsnd_ac97_write_cache(ac97, AC97_LINE2_RATE, 8000);\r\ntmp |= AC97_MEA_ADC2 | AC97_MEA_DAC2;\r\n}\r\nif (ac97->ext_mid & AC97_MEI_HANDSET) {\r\nsnd_ac97_write_cache(ac97, AC97_HANDSET_RATE, 8000);\r\ntmp |= AC97_MEA_HADC | AC97_MEA_HDAC;\r\n}\r\nsnd_ac97_write_cache(ac97, AC97_EXTENDED_MSTATUS, 0);\r\nudelay(100);\r\nsnd_ac97_write_cache(ac97, AC97_EXTENDED_MSTATUS, 0);\r\nend_time = jiffies + msecs_to_jiffies(100);\r\ndo {\r\nif ((snd_ac97_read(ac97, AC97_EXTENDED_MSTATUS) & tmp) == tmp)\r\ngoto __ready_ok;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printk(KERN_WARNING "MC'97 %d converters and GPIO not ready (0x%x)\n", ac97->num, snd_ac97_read(ac97, AC97_EXTENDED_MSTATUS));\r\n}\r\n__ready_ok:\r\nif (ac97_is_audio(ac97))\r\nac97->addr = (ac97->ext_id & AC97_EI_ADDR_MASK) >> AC97_EI_ADDR_SHIFT;\r\nelse\r\nac97->addr = (ac97->ext_mid & AC97_MEI_ADDR_MASK) >> AC97_MEI_ADDR_SHIFT;\r\nif (ac97->ext_id & 0x01c9) {\r\nreg = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);\r\nreg |= ac97->ext_id & 0x01c0;\r\nif (! bus->no_vra)\r\nreg |= ac97->ext_id & 0x0009;\r\nsnd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, reg);\r\n}\r\nif ((ac97->ext_id & AC97_EI_DRA) && bus->dra) {\r\nsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, AC97_GP_DRSS_MASK, AC97_GP_DRSS_78);\r\nif ((snd_ac97_read(ac97, AC97_GENERAL_PURPOSE) & AC97_GP_DRSS_MASK) == AC97_GP_DRSS_78)\r\nac97->flags |= AC97_DOUBLE_RATE;\r\nsnd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE, AC97_GP_DRSS_MASK, 0);\r\n}\r\nif (ac97->ext_id & AC97_EI_VRA) {\r\nsnd_ac97_determine_rates(ac97, AC97_PCM_FRONT_DAC_RATE, 0, &ac97->rates[AC97_RATES_FRONT_DAC]);\r\nsnd_ac97_determine_rates(ac97, AC97_PCM_LR_ADC_RATE, 0, &ac97->rates[AC97_RATES_ADC]);\r\n} else {\r\nac97->rates[AC97_RATES_FRONT_DAC] = SNDRV_PCM_RATE_48000;\r\nif (ac97->flags & AC97_DOUBLE_RATE)\r\nac97->rates[AC97_RATES_FRONT_DAC] |= SNDRV_PCM_RATE_96000;\r\nac97->rates[AC97_RATES_ADC] = SNDRV_PCM_RATE_48000;\r\n}\r\nif (ac97->ext_id & AC97_EI_SPDIF) {\r\nac97->rates[AC97_RATES_SPDIF] = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_32000;\r\n}\r\nif (ac97->ext_id & AC97_EI_VRM) {\r\nsnd_ac97_determine_rates(ac97, AC97_PCM_MIC_ADC_RATE, 0, &ac97->rates[AC97_RATES_MIC_ADC]);\r\n} else {\r\nac97->rates[AC97_RATES_MIC_ADC] = SNDRV_PCM_RATE_48000;\r\n}\r\nif (ac97->ext_id & AC97_EI_SDAC) {\r\nsnd_ac97_determine_rates(ac97, AC97_PCM_SURR_DAC_RATE, AC97_PCM_FRONT_DAC_RATE, &ac97->rates[AC97_RATES_SURR_DAC]);\r\nac97->scaps |= AC97_SCAP_SURROUND_DAC;\r\n}\r\nif (ac97->ext_id & AC97_EI_LDAC) {\r\nsnd_ac97_determine_rates(ac97, AC97_PCM_LFE_DAC_RATE, AC97_PCM_FRONT_DAC_RATE, &ac97->rates[AC97_RATES_LFE_DAC]);\r\nac97->scaps |= AC97_SCAP_CENTER_LFE_DAC;\r\n}\r\nif (bus->ops->init)\r\nbus->ops->init(ac97);\r\nsnd_ac97_get_name(ac97, ac97->id, name, !ac97_is_audio(ac97));\r\nsnd_ac97_get_name(NULL, ac97->id, name, !ac97_is_audio(ac97));\r\nif (! ac97->build_ops)\r\nac97->build_ops = &null_build_ops;\r\nif (ac97_is_audio(ac97)) {\r\nchar comp[16];\r\nif (card->mixername[0] == '\0') {\r\nstrcpy(card->mixername, name);\r\n} else {\r\nif (strlen(card->mixername) + 1 + strlen(name) + 1 <= sizeof(card->mixername)) {\r\nstrcat(card->mixername, ",");\r\nstrcat(card->mixername, name);\r\n}\r\n}\r\nsprintf(comp, "AC97a:%08x", ac97->id);\r\nif ((err = snd_component_add(card, comp)) < 0) {\r\nsnd_ac97_free(ac97);\r\nreturn err;\r\n}\r\nif (snd_ac97_mixer_build(ac97) < 0) {\r\nsnd_ac97_free(ac97);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (ac97_is_modem(ac97)) {\r\nchar comp[16];\r\nif (card->mixername[0] == '\0') {\r\nstrcpy(card->mixername, name);\r\n} else {\r\nif (strlen(card->mixername) + 1 + strlen(name) + 1 <= sizeof(card->mixername)) {\r\nstrcat(card->mixername, ",");\r\nstrcat(card->mixername, name);\r\n}\r\n}\r\nsprintf(comp, "AC97m:%08x", ac97->id);\r\nif ((err = snd_component_add(card, comp)) < 0) {\r\nsnd_ac97_free(ac97);\r\nreturn err;\r\n}\r\nif (snd_ac97_modem_build(card, ac97) < 0) {\r\nsnd_ac97_free(ac97);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (ac97_is_audio(ac97))\r\nupdate_power_regs(ac97);\r\nsnd_ac97_proc_init(ac97);\r\nif ((err = snd_device_new(card, SNDRV_DEV_CODEC, ac97, &ops)) < 0) {\r\nsnd_ac97_free(ac97);\r\nreturn err;\r\n}\r\n*rac97 = ac97;\r\nreturn 0;\r\n}\r\nstatic void snd_ac97_powerdown(struct snd_ac97 *ac97)\r\n{\r\nunsigned short power;\r\nif (ac97_is_audio(ac97)) {\r\nsnd_ac97_write(ac97, AC97_MASTER, 0x9f9f);\r\nsnd_ac97_write(ac97, AC97_HEADPHONE, 0x9f9f);\r\n}\r\npower = ac97->regs[AC97_EXTENDED_STATUS];\r\nif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\r\npower |= AC97_EA_PRJ;\r\nif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\r\npower |= AC97_EA_PRI | AC97_EA_PRK;\r\npower |= AC97_EA_PRL;\r\nsnd_ac97_write(ac97, AC97_EXTENDED_STATUS, power);\r\nif (ac97->scaps & AC97_SCAP_INV_EAPD)\r\npower = ac97->regs[AC97_POWERDOWN] & ~AC97_PD_EAPD;\r\nelse if (! (ac97->scaps & AC97_SCAP_EAPD_LED))\r\npower = ac97->regs[AC97_POWERDOWN] | AC97_PD_EAPD;\r\npower |= AC97_PD_PR6;\r\npower |= AC97_PD_PR0 | AC97_PD_PR1;\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, power);\r\nudelay(100);\r\npower |= AC97_PD_PR2;\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, power);\r\nif (ac97_is_power_save_mode(ac97)) {\r\npower |= AC97_PD_PR3;\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, power);\r\nudelay(100);\r\npower |= AC97_PD_PR4 | AC97_PD_PR5;\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, power);\r\n}\r\n}\r\nint snd_ac97_update_power(struct snd_ac97 *ac97, int reg, int powerup)\r\n{\r\nint i;\r\nif (! ac97)\r\nreturn 0;\r\nif (reg) {\r\nif (reg == AC97_SPDIF)\r\nreg = AC97_PCM_FRONT_DAC_RATE;\r\nfor (i = 0; i < PWIDX_SIZE; i++) {\r\nif (power_regs[i].reg == reg) {\r\nif (powerup)\r\nac97->power_up |= (1 << i);\r\nelse\r\nac97->power_up &= ~(1 << i);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ac97_is_power_save_mode(ac97) && !powerup)\r\nschedule_delayed_work(&ac97->power_work,\r\nmsecs_to_jiffies(power_save * 1000));\r\nelse {\r\ncancel_delayed_work(&ac97->power_work);\r\nupdate_power_regs(ac97);\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_power_regs(struct snd_ac97 *ac97)\r\n{\r\nunsigned int power_up, bits;\r\nint i;\r\npower_up = (1 << PWIDX_FRONT) | (1 << PWIDX_ADC);\r\npower_up |= (1 << PWIDX_MIC);\r\nif (ac97->scaps & AC97_SCAP_SURROUND_DAC)\r\npower_up |= (1 << PWIDX_SURR);\r\nif (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)\r\npower_up |= (1 << PWIDX_CLFE);\r\n#ifdef CONFIG_SND_AC97_POWER_SAVE\r\nif (ac97_is_power_save_mode(ac97))\r\npower_up = ac97->power_up;\r\n#endif\r\nif (power_up) {\r\nif (ac97->regs[AC97_POWERDOWN] & AC97_PD_PR2) {\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\r\nAC97_PD_PR3, 0);\r\nmsleep(1);\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\r\nAC97_PD_PR2, 0);\r\n}\r\n}\r\nfor (i = 0; i < PWIDX_SIZE; i++) {\r\nif (power_up & (1 << i))\r\nbits = 0;\r\nelse\r\nbits = power_regs[i].mask;\r\nsnd_ac97_update_bits(ac97, power_regs[i].power_reg,\r\npower_regs[i].mask, bits);\r\n}\r\nif (! power_up) {\r\nif (! (ac97->regs[AC97_POWERDOWN] & AC97_PD_PR2)) {\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\r\nAC97_PD_PR2, AC97_PD_PR2);\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN,\r\nAC97_PD_PR3, AC97_PD_PR3);\r\n}\r\n}\r\n}\r\nvoid snd_ac97_suspend(struct snd_ac97 *ac97)\r\n{\r\nif (! ac97)\r\nreturn;\r\nif (ac97->build_ops->suspend)\r\nac97->build_ops->suspend(ac97);\r\n#ifdef CONFIG_SND_AC97_POWER_SAVE\r\ncancel_delayed_work_sync(&ac97->power_work);\r\n#endif\r\nsnd_ac97_powerdown(ac97);\r\n}\r\nstatic void snd_ac97_restore_status(struct snd_ac97 *ac97)\r\n{\r\nint i;\r\nfor (i = 2; i < 0x7c ; i += 2) {\r\nif (i == AC97_POWERDOWN || i == AC97_EXTENDED_ID)\r\ncontinue;\r\nif (test_bit(i, ac97->reg_accessed)) {\r\nsnd_ac97_write(ac97, i, ac97->regs[i]);\r\nsnd_ac97_read(ac97, i);\r\n}\r\n}\r\n}\r\nstatic void snd_ac97_restore_iec958(struct snd_ac97 *ac97)\r\n{\r\nif (ac97->ext_id & AC97_EI_SPDIF) {\r\nif (ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_SPDIF) {\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);\r\nsnd_ac97_write(ac97, AC97_EXTENDED_STATUS, ac97->regs[AC97_EXTENDED_STATUS]);\r\nif (ac97->flags & AC97_CS_SPDIF)\r\nsnd_ac97_write(ac97, AC97_CSR_SPDIF, ac97->regs[AC97_CSR_SPDIF]);\r\nelse\r\nsnd_ac97_write(ac97, AC97_SPDIF, ac97->regs[AC97_SPDIF]);\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);\r\n}\r\n}\r\n}\r\nvoid snd_ac97_resume(struct snd_ac97 *ac97)\r\n{\r\nunsigned long end_time;\r\nif (! ac97)\r\nreturn;\r\nif (ac97->bus->ops->reset) {\r\nac97->bus->ops->reset(ac97);\r\ngoto __reset_ready;\r\n}\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, 0);\r\nif (! (ac97->flags & AC97_DEFAULT_POWER_OFF)) {\r\nif (!(ac97->scaps & AC97_SCAP_SKIP_AUDIO))\r\nsnd_ac97_write(ac97, AC97_RESET, 0);\r\nelse if (!(ac97->scaps & AC97_SCAP_SKIP_MODEM))\r\nsnd_ac97_write(ac97, AC97_EXTENDED_MID, 0);\r\nudelay(100);\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, 0);\r\n}\r\nsnd_ac97_write(ac97, AC97_GENERAL_PURPOSE, 0);\r\nsnd_ac97_write(ac97, AC97_POWERDOWN, ac97->regs[AC97_POWERDOWN]);\r\nif (ac97_is_audio(ac97)) {\r\nac97->bus->ops->write(ac97, AC97_MASTER, 0x8101);\r\nend_time = jiffies + msecs_to_jiffies(100);\r\ndo {\r\nif (snd_ac97_read(ac97, AC97_MASTER) == 0x8101)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nac97->bus->ops->write(ac97, AC97_MASTER, AC97_MUTE_MASK_MONO);\r\nif (snd_ac97_read(ac97, AC97_MASTER) != AC97_MUTE_MASK_MONO)\r\nmsleep(250);\r\n} else {\r\nend_time = jiffies + msecs_to_jiffies(100);\r\ndo {\r\nunsigned short val = snd_ac97_read(ac97, AC97_EXTENDED_MID);\r\nif (val != 0xffff && (val & 1) != 0)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\n}\r\n__reset_ready:\r\nif (ac97->bus->ops->init)\r\nac97->bus->ops->init(ac97);\r\nif (ac97->build_ops->resume)\r\nac97->build_ops->resume(ac97);\r\nelse {\r\nsnd_ac97_restore_status(ac97);\r\nsnd_ac97_restore_iec958(ac97);\r\n}\r\n}\r\nstatic void set_ctl_name(char *dst, const char *src, const char *suffix)\r\n{\r\nif (suffix)\r\nsprintf(dst, "%s %s", src, suffix);\r\nelse\r\nstrcpy(dst, src);\r\n}\r\nstatic int snd_ac97_remove_ctl(struct snd_ac97 *ac97, const char *name,\r\nconst char *suffix)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nmemset(&id, 0, sizeof(id));\r\nset_ctl_name(id.name, name, suffix);\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nreturn snd_ctl_remove_id(ac97->bus->card, &id);\r\n}\r\nstatic struct snd_kcontrol *ctl_find(struct snd_ac97 *ac97, const char *name, const char *suffix)\r\n{\r\nstruct snd_ctl_elem_id sid;\r\nmemset(&sid, 0, sizeof(sid));\r\nset_ctl_name(sid.name, name, suffix);\r\nsid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nreturn snd_ctl_find_id(ac97->bus->card, &sid);\r\n}\r\nstatic int snd_ac97_rename_ctl(struct snd_ac97 *ac97, const char *src,\r\nconst char *dst, const char *suffix)\r\n{\r\nstruct snd_kcontrol *kctl = ctl_find(ac97, src, suffix);\r\nif (kctl) {\r\nset_ctl_name(kctl->id.name, dst, suffix);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void snd_ac97_rename_vol_ctl(struct snd_ac97 *ac97, const char *src,\r\nconst char *dst)\r\n{\r\nsnd_ac97_rename_ctl(ac97, src, dst, "Switch");\r\nsnd_ac97_rename_ctl(ac97, src, dst, "Volume");\r\n}\r\nstatic int snd_ac97_swap_ctl(struct snd_ac97 *ac97, const char *s1,\r\nconst char *s2, const char *suffix)\r\n{\r\nstruct snd_kcontrol *kctl1, *kctl2;\r\nkctl1 = ctl_find(ac97, s1, suffix);\r\nkctl2 = ctl_find(ac97, s2, suffix);\r\nif (kctl1 && kctl2) {\r\nset_ctl_name(kctl1->id.name, s2, suffix);\r\nset_ctl_name(kctl2->id.name, s1, suffix);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int bind_hp_volsw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nint err = snd_ac97_put_volsw(kcontrol, ucontrol);\r\nif (err > 0) {\r\nunsigned long priv_saved = kcontrol->private_value;\r\nkcontrol->private_value = (kcontrol->private_value & ~0xff) | AC97_HEADPHONE;\r\nsnd_ac97_put_volsw(kcontrol, ucontrol);\r\nkcontrol->private_value = priv_saved;\r\n}\r\nreturn err;\r\n}\r\nstatic int tune_hp_only(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_kcontrol *msw = ctl_find(ac97, "Master Playback Switch", NULL);\r\nstruct snd_kcontrol *mvol = ctl_find(ac97, "Master Playback Volume", NULL);\r\nif (! msw || ! mvol)\r\nreturn -ENOENT;\r\nmsw->put = bind_hp_volsw_put;\r\nmvol->put = bind_hp_volsw_put;\r\nsnd_ac97_remove_ctl(ac97, "Headphone Playback", "Switch");\r\nsnd_ac97_remove_ctl(ac97, "Headphone Playback", "Volume");\r\nreturn 0;\r\n}\r\nstatic int tune_hp_only(struct snd_ac97 *ac97)\r\n{\r\nif (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)\r\nreturn -ENOENT;\r\nsnd_ac97_remove_ctl(ac97, "Master Playback", "Switch");\r\nsnd_ac97_remove_ctl(ac97, "Master Playback", "Volume");\r\nsnd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");\r\nreturn 0;\r\n}\r\nstatic int tune_swap_hp(struct snd_ac97 *ac97)\r\n{\r\nif (ctl_find(ac97, "Headphone Playback Switch", NULL) == NULL)\r\nreturn -ENOENT;\r\nsnd_ac97_rename_vol_ctl(ac97, "Master Playback", "Line-Out Playback");\r\nsnd_ac97_rename_vol_ctl(ac97, "Headphone Playback", "Master Playback");\r\nreturn 0;\r\n}\r\nstatic int tune_swap_surround(struct snd_ac97 *ac97)\r\n{\r\nif (snd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Switch") ||\r\nsnd_ac97_swap_ctl(ac97, "Master Playback", "Surround Playback", "Volume"))\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic int tune_ad_sharing(struct snd_ac97 *ac97)\r\n{\r\nunsigned short scfg;\r\nif ((ac97->id & 0xffffff00) != 0x41445300) {\r\nsnd_printk(KERN_ERR "ac97_quirk AD_SHARING is only for AD codecs\n");\r\nreturn -EINVAL;\r\n}\r\nscfg = snd_ac97_read(ac97, AC97_AD_SERIAL_CFG);\r\nsnd_ac97_write_cache(ac97, AC97_AD_SERIAL_CFG, scfg | 0x0200);\r\nreturn 0;\r\n}\r\nstatic int tune_alc_jack(struct snd_ac97 *ac97)\r\n{\r\nif ((ac97->id & 0xffffff00) != 0x414c4700) {\r\nsnd_printk(KERN_ERR "ac97_quirk ALC_JACK is only for Realtek codecs\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_ac97_update_bits(ac97, 0x7a, 0x20, 0x20);\r\nsnd_ac97_update_bits(ac97, 0x7a, 0x01, 0x01);\r\nif (ac97->id == AC97_ID_ALC658D)\r\nsnd_ac97_update_bits(ac97, 0x74, 0x0800, 0x0800);\r\nreturn snd_ctl_add(ac97->bus->card, snd_ac97_cnew(&snd_ac97_alc_jack_detect, ac97));\r\n}\r\nstatic int tune_inv_eapd(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_kcontrol *kctl = ctl_find(ac97, "External Amplifier", NULL);\r\nif (! kctl)\r\nreturn -ENOENT;\r\nset_inv_eapd(ac97, kctl);\r\nreturn 0;\r\n}\r\nstatic int master_mute_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nint err = snd_ac97_put_volsw(kcontrol, ucontrol);\r\nif (err > 0) {\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint shift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nunsigned short mask;\r\nif (shift != rshift)\r\nmask = AC97_MUTE_MASK_STEREO;\r\nelse\r\nmask = AC97_MUTE_MASK_MONO;\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN, AC97_PD_EAPD,\r\n(ac97->regs[AC97_MASTER] & mask) == mask ?\r\nAC97_PD_EAPD : 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int tune_mute_led(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_kcontrol *msw = ctl_find(ac97, "Master Playback Switch", NULL);\r\nif (! msw)\r\nreturn -ENOENT;\r\nmsw->put = master_mute_sw_put;\r\nsnd_ac97_remove_ctl(ac97, "External Amplifier", NULL);\r\nsnd_ac97_update_bits(\r\nac97, AC97_POWERDOWN,\r\nAC97_PD_EAPD, AC97_PD_EAPD\r\n);\r\nac97->scaps |= AC97_SCAP_EAPD_LED;\r\nreturn 0;\r\n}\r\nstatic int hp_master_mute_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint err = bind_hp_volsw_put(kcontrol, ucontrol);\r\nif (err > 0) {\r\nstruct snd_ac97 *ac97 = snd_kcontrol_chip(kcontrol);\r\nint shift = (kcontrol->private_value >> 8) & 0x0f;\r\nint rshift = (kcontrol->private_value >> 12) & 0x0f;\r\nunsigned short mask;\r\nif (shift != rshift)\r\nmask = AC97_MUTE_MASK_STEREO;\r\nelse\r\nmask = AC97_MUTE_MASK_MONO;\r\nsnd_ac97_update_bits(ac97, AC97_POWERDOWN, AC97_PD_EAPD,\r\n(ac97->regs[AC97_MASTER] & mask) == mask ?\r\nAC97_PD_EAPD : 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int tune_hp_mute_led(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_kcontrol *msw = ctl_find(ac97, "Master Playback Switch", NULL);\r\nstruct snd_kcontrol *mvol = ctl_find(ac97, "Master Playback Volume", NULL);\r\nif (! msw || ! mvol)\r\nreturn -ENOENT;\r\nmsw->put = hp_master_mute_sw_put;\r\nmvol->put = bind_hp_volsw_put;\r\nsnd_ac97_remove_ctl(ac97, "External Amplifier", NULL);\r\nsnd_ac97_remove_ctl(ac97, "Headphone Playback", "Switch");\r\nsnd_ac97_remove_ctl(ac97, "Headphone Playback", "Volume");\r\nsnd_ac97_update_bits(\r\nac97, AC97_POWERDOWN,\r\nAC97_PD_EAPD, AC97_PD_EAPD\r\n);\r\nreturn 0;\r\n}\r\nstatic int apply_quirk(struct snd_ac97 *ac97, int type)\r\n{\r\nif (type <= 0)\r\nreturn 0;\r\nelse if (type >= ARRAY_SIZE(applicable_quirks))\r\nreturn -EINVAL;\r\nif (applicable_quirks[type].func)\r\nreturn applicable_quirks[type].func(ac97);\r\nreturn 0;\r\n}\r\nstatic int apply_quirk_str(struct snd_ac97 *ac97, const char *typestr)\r\n{\r\nint i;\r\nstruct quirk_table *q;\r\nfor (i = 0; i < ARRAY_SIZE(applicable_quirks); i++) {\r\nq = &applicable_quirks[i];\r\nif (q->name && ! strcmp(typestr, q->name))\r\nreturn apply_quirk(ac97, i);\r\n}\r\nif (*typestr >= '0' && *typestr <= '9')\r\nreturn apply_quirk(ac97, (int)simple_strtoul(typestr, NULL, 10));\r\nreturn -EINVAL;\r\n}\r\nint snd_ac97_tune_hardware(struct snd_ac97 *ac97, struct ac97_quirk *quirk, const char *override)\r\n{\r\nint result;\r\nif (override && strcmp(override, "-1") && strcmp(override, "default")) {\r\nresult = apply_quirk_str(ac97, override);\r\nif (result < 0)\r\nsnd_printk(KERN_ERR "applying quirk type %s failed (%d)\n", override, result);\r\nreturn result;\r\n}\r\nif (! quirk)\r\nreturn -EINVAL;\r\nfor (; quirk->subvendor; quirk++) {\r\nif (quirk->subvendor != ac97->subsystem_vendor)\r\ncontinue;\r\nif ((! quirk->mask && quirk->subdevice == ac97->subsystem_device) ||\r\nquirk->subdevice == (quirk->mask & ac97->subsystem_device)) {\r\nif (quirk->codec_id && quirk->codec_id != ac97->id)\r\ncontinue;\r\nsnd_printdd("ac97 quirk for %s (%04x:%04x)\n", quirk->name, ac97->subsystem_vendor, ac97->subsystem_device);\r\nresult = apply_quirk(ac97, quirk->type);\r\nif (result < 0)\r\nsnd_printk(KERN_ERR "applying quirk type %d for %s failed (%d)\n", quirk->type, quirk->name, result);\r\nreturn result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init alsa_ac97_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_ac97_exit(void)\r\n{\r\n}
