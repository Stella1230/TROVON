static struct mxs_dma_chan *to_mxs_dma_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct mxs_dma_chan, chan);\r\n}\r\nint mxs_dma_is_apbh(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nreturn dma_is_apbh(mxs_dma);\r\n}\r\nint mxs_dma_is_apbx(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nreturn !dma_is_apbh(mxs_dma);\r\n}\r\nstatic void mxs_dma_reset_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\r\nwritel(1 << (chan_id + BP_APBH_CTRL0_RESET_CHANNEL),\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\nelse\r\nwritel(1 << (chan_id + BP_APBHX_CHANNEL_CTRL_RESET_CHANNEL),\r\nmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_SET);\r\n}\r\nstatic void mxs_dma_enable_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nwritel(mxs_chan->ccw_phys,\r\nmxs_dma->base + HW_APBHX_CHn_NXTCMDAR(mxs_dma, chan_id));\r\nwritel(1, mxs_dma->base + HW_APBHX_CHn_SEMA(mxs_dma, chan_id));\r\n}\r\nstatic void mxs_dma_disable_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nmxs_chan->status = DMA_SUCCESS;\r\n}\r\nstatic void mxs_dma_pause_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\nelse\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_SET);\r\nmxs_chan->status = DMA_PAUSED;\r\n}\r\nstatic void mxs_dma_resume_chan(struct mxs_dma_chan *mxs_chan)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint chan_id = mxs_chan->chan.chan_id;\r\nif (dma_is_apbh(mxs_dma) && apbh_is_old(mxs_dma))\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_CLR);\r\nelse\r\nwritel(1 << chan_id,\r\nmxs_dma->base + HW_APBHX_CHANNEL_CTRL + STMP_OFFSET_REG_CLR);\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\n}\r\nstatic dma_cookie_t mxs_dma_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nreturn dma_cookie_assign(tx);\r\n}\r\nstatic void mxs_dma_tasklet(unsigned long data)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = (struct mxs_dma_chan *) data;\r\nif (mxs_chan->desc.callback)\r\nmxs_chan->desc.callback(mxs_chan->desc.callback_param);\r\n}\r\nstatic irqreturn_t mxs_dma_int_handler(int irq, void *dev_id)\r\n{\r\nstruct mxs_dma_engine *mxs_dma = dev_id;\r\nu32 stat1, stat2;\r\nstat1 = readl(mxs_dma->base + HW_APBHX_CTRL1);\r\nstat1 &= MXS_DMA_CHANNELS_MASK;\r\nwritel(stat1, mxs_dma->base + HW_APBHX_CTRL1 + STMP_OFFSET_REG_CLR);\r\nstat2 = readl(mxs_dma->base + HW_APBHX_CTRL2);\r\nwritel(stat2, mxs_dma->base + HW_APBHX_CTRL2 + STMP_OFFSET_REG_CLR);\r\nstat2 = ((stat2 >> MXS_DMA_CHANNELS) & stat2) |\r\n(~(stat2 >> MXS_DMA_CHANNELS) & stat2 & ~stat1);\r\nstat1 = (stat2 << MXS_DMA_CHANNELS) | stat1;\r\nwhile (stat1) {\r\nint channel = fls(stat1) - 1;\r\nstruct mxs_dma_chan *mxs_chan =\r\n&mxs_dma->mxs_chans[channel % MXS_DMA_CHANNELS];\r\nif (channel >= MXS_DMA_CHANNELS) {\r\ndev_dbg(mxs_dma->dma_device.dev,\r\n"%s: error in channel %d\n", __func__,\r\nchannel - MXS_DMA_CHANNELS);\r\nmxs_chan->status = DMA_ERROR;\r\nmxs_dma_reset_chan(mxs_chan);\r\n} else {\r\nif (mxs_chan->flags & MXS_DMA_SG_LOOP)\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\nelse\r\nmxs_chan->status = DMA_SUCCESS;\r\n}\r\nstat1 &= ~(1 << channel);\r\nif (mxs_chan->status == DMA_SUCCESS)\r\ndma_cookie_complete(&mxs_chan->desc);\r\ntasklet_schedule(&mxs_chan->tasklet);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxs_dma_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_data *data = chan->private;\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint ret;\r\nif (!data)\r\nreturn -EINVAL;\r\nmxs_chan->chan_irq = data->chan_irq;\r\nmxs_chan->ccw = dma_alloc_coherent(mxs_dma->dma_device.dev,\r\nCCW_BLOCK_SIZE, &mxs_chan->ccw_phys,\r\nGFP_KERNEL);\r\nif (!mxs_chan->ccw) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nmemset(mxs_chan->ccw, 0, CCW_BLOCK_SIZE);\r\nif (mxs_chan->chan_irq != NO_IRQ) {\r\nret = request_irq(mxs_chan->chan_irq, mxs_dma_int_handler,\r\n0, "mxs-dma", mxs_dma);\r\nif (ret)\r\ngoto err_irq;\r\n}\r\nret = clk_prepare_enable(mxs_dma->clk);\r\nif (ret)\r\ngoto err_clk;\r\nmxs_dma_reset_chan(mxs_chan);\r\ndma_async_tx_descriptor_init(&mxs_chan->desc, chan);\r\nmxs_chan->desc.tx_submit = mxs_dma_tx_submit;\r\nasync_tx_ack(&mxs_chan->desc);\r\nreturn 0;\r\nerr_clk:\r\nfree_irq(mxs_chan->chan_irq, mxs_dma);\r\nerr_irq:\r\ndma_free_coherent(mxs_dma->dma_device.dev, CCW_BLOCK_SIZE,\r\nmxs_chan->ccw, mxs_chan->ccw_phys);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic void mxs_dma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nmxs_dma_disable_chan(mxs_chan);\r\nfree_irq(mxs_chan->chan_irq, mxs_dma);\r\ndma_free_coherent(mxs_dma->dma_device.dev, CCW_BLOCK_SIZE,\r\nmxs_chan->ccw, mxs_chan->ccw_phys);\r\nclk_disable_unprepare(mxs_dma->clk);\r\n}\r\nstatic struct dma_async_tx_descriptor *mxs_dma_prep_slave_sg(\r\nstruct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nstruct mxs_dma_ccw *ccw;\r\nstruct scatterlist *sg;\r\nint i, j;\r\nu32 *pio;\r\nbool append = flags & DMA_PREP_INTERRUPT;\r\nint idx = append ? mxs_chan->desc_count : 0;\r\nif (mxs_chan->status == DMA_IN_PROGRESS && !append)\r\nreturn NULL;\r\nif (sg_len + (append ? idx : 0) > NUM_CCW) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"maximum number of sg exceeded: %d > %d\n",\r\nsg_len, NUM_CCW);\r\ngoto err_out;\r\n}\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\nmxs_chan->flags = 0;\r\nif (append) {\r\nBUG_ON(idx < 1);\r\nccw = &mxs_chan->ccw[idx - 1];\r\nccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * idx;\r\nccw->bits |= CCW_CHAIN;\r\nccw->bits &= ~CCW_IRQ;\r\nccw->bits &= ~CCW_DEC_SEM;\r\n} else {\r\nidx = 0;\r\n}\r\nif (direction == DMA_TRANS_NONE) {\r\nccw = &mxs_chan->ccw[idx++];\r\npio = (u32 *) sgl;\r\nfor (j = 0; j < sg_len;)\r\nccw->pio_words[j++] = *pio++;\r\nccw->bits = 0;\r\nccw->bits |= CCW_IRQ;\r\nccw->bits |= CCW_DEC_SEM;\r\nif (flags & DMA_CTRL_ACK)\r\nccw->bits |= CCW_WAIT4END;\r\nccw->bits |= CCW_HALT_ON_TERM;\r\nccw->bits |= CCW_TERM_FLUSH;\r\nccw->bits |= BF_CCW(sg_len, PIO_NUM);\r\nccw->bits |= BF_CCW(MXS_DMA_CMD_NO_XFER, COMMAND);\r\n} else {\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\nif (sg_dma_len(sg) > MAX_XFER_BYTES) {\r\ndev_err(mxs_dma->dma_device.dev, "maximum bytes for sg entry exceeded: %d > %d\n",\r\nsg_dma_len(sg), MAX_XFER_BYTES);\r\ngoto err_out;\r\n}\r\nccw = &mxs_chan->ccw[idx++];\r\nccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * idx;\r\nccw->bufaddr = sg->dma_address;\r\nccw->xfer_bytes = sg_dma_len(sg);\r\nccw->bits = 0;\r\nccw->bits |= CCW_CHAIN;\r\nccw->bits |= CCW_HALT_ON_TERM;\r\nccw->bits |= CCW_TERM_FLUSH;\r\nccw->bits |= BF_CCW(direction == DMA_DEV_TO_MEM ?\r\nMXS_DMA_CMD_WRITE : MXS_DMA_CMD_READ,\r\nCOMMAND);\r\nif (i + 1 == sg_len) {\r\nccw->bits &= ~CCW_CHAIN;\r\nccw->bits |= CCW_IRQ;\r\nccw->bits |= CCW_DEC_SEM;\r\nif (flags & DMA_CTRL_ACK)\r\nccw->bits |= CCW_WAIT4END;\r\n}\r\n}\r\n}\r\nmxs_chan->desc_count = idx;\r\nreturn &mxs_chan->desc;\r\nerr_out:\r\nmxs_chan->status = DMA_ERROR;\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *mxs_dma_prep_dma_cyclic(\r\nstruct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,\r\nsize_t period_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nstruct mxs_dma_engine *mxs_dma = mxs_chan->mxs_dma;\r\nint num_periods = buf_len / period_len;\r\nint i = 0, buf = 0;\r\nif (mxs_chan->status == DMA_IN_PROGRESS)\r\nreturn NULL;\r\nmxs_chan->status = DMA_IN_PROGRESS;\r\nmxs_chan->flags |= MXS_DMA_SG_LOOP;\r\nif (num_periods > NUM_CCW) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"maximum number of sg exceeded: %d > %d\n",\r\nnum_periods, NUM_CCW);\r\ngoto err_out;\r\n}\r\nif (period_len > MAX_XFER_BYTES) {\r\ndev_err(mxs_dma->dma_device.dev,\r\n"maximum period size exceeded: %d > %d\n",\r\nperiod_len, MAX_XFER_BYTES);\r\ngoto err_out;\r\n}\r\nwhile (buf < buf_len) {\r\nstruct mxs_dma_ccw *ccw = &mxs_chan->ccw[i];\r\nif (i + 1 == num_periods)\r\nccw->next = mxs_chan->ccw_phys;\r\nelse\r\nccw->next = mxs_chan->ccw_phys + sizeof(*ccw) * (i + 1);\r\nccw->bufaddr = dma_addr;\r\nccw->xfer_bytes = period_len;\r\nccw->bits = 0;\r\nccw->bits |= CCW_CHAIN;\r\nccw->bits |= CCW_IRQ;\r\nccw->bits |= CCW_HALT_ON_TERM;\r\nccw->bits |= CCW_TERM_FLUSH;\r\nccw->bits |= BF_CCW(direction == DMA_DEV_TO_MEM ?\r\nMXS_DMA_CMD_WRITE : MXS_DMA_CMD_READ, COMMAND);\r\ndma_addr += period_len;\r\nbuf += period_len;\r\ni++;\r\n}\r\nmxs_chan->desc_count = i;\r\nreturn &mxs_chan->desc;\r\nerr_out:\r\nmxs_chan->status = DMA_ERROR;\r\nreturn NULL;\r\n}\r\nstatic int mxs_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase DMA_TERMINATE_ALL:\r\nmxs_dma_reset_chan(mxs_chan);\r\nmxs_dma_disable_chan(mxs_chan);\r\nbreak;\r\ncase DMA_PAUSE:\r\nmxs_dma_pause_chan(mxs_chan);\r\nbreak;\r\ncase DMA_RESUME:\r\nmxs_dma_resume_chan(mxs_chan);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum dma_status mxs_dma_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie, struct dma_tx_state *txstate)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\ndma_cookie_t last_used;\r\nlast_used = chan->cookie;\r\ndma_set_tx_state(txstate, chan->completed_cookie, last_used, 0);\r\nreturn mxs_chan->status;\r\n}\r\nstatic void mxs_dma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct mxs_dma_chan *mxs_chan = to_mxs_dma_chan(chan);\r\nmxs_dma_enable_chan(mxs_chan);\r\n}\r\nstatic int __init mxs_dma_init(struct mxs_dma_engine *mxs_dma)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(mxs_dma->clk);\r\nif (ret)\r\nreturn ret;\r\nret = stmp_reset_block(mxs_dma->base);\r\nif (ret)\r\ngoto err_out;\r\nif (dma_is_apbh(mxs_dma)) {\r\nwritel(BM_APBH_CTRL0_APB_BURST_EN,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\nwritel(BM_APBH_CTRL0_APB_BURST8_EN,\r\nmxs_dma->base + HW_APBHX_CTRL0 + STMP_OFFSET_REG_SET);\r\n}\r\nwritel(MXS_DMA_CHANNELS_MASK << MXS_DMA_CHANNELS,\r\nmxs_dma->base + HW_APBHX_CTRL1 + STMP_OFFSET_REG_SET);\r\nerr_out:\r\nclk_disable_unprepare(mxs_dma->clk);\r\nreturn ret;\r\n}\r\nstatic int __init mxs_dma_probe(struct platform_device *pdev)\r\n{\r\nconst struct platform_device_id *id_entry;\r\nconst struct of_device_id *of_id;\r\nconst struct mxs_dma_type *dma_type;\r\nstruct mxs_dma_engine *mxs_dma;\r\nstruct resource *iores;\r\nint ret, i;\r\nmxs_dma = kzalloc(sizeof(*mxs_dma), GFP_KERNEL);\r\nif (!mxs_dma)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(mxs_dma_dt_ids, &pdev->dev);\r\nif (of_id)\r\nid_entry = of_id->data;\r\nelse\r\nid_entry = platform_get_device_id(pdev);\r\ndma_type = (struct mxs_dma_type *)id_entry->driver_data;\r\nmxs_dma->type = dma_type->type;\r\nmxs_dma->dev_id = dma_type->id;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!request_mem_region(iores->start, resource_size(iores),\r\npdev->name)) {\r\nret = -EBUSY;\r\ngoto err_request_region;\r\n}\r\nmxs_dma->base = ioremap(iores->start, resource_size(iores));\r\nif (!mxs_dma->base) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nmxs_dma->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mxs_dma->clk)) {\r\nret = PTR_ERR(mxs_dma->clk);\r\ngoto err_clk;\r\n}\r\ndma_cap_set(DMA_SLAVE, mxs_dma->dma_device.cap_mask);\r\ndma_cap_set(DMA_CYCLIC, mxs_dma->dma_device.cap_mask);\r\nINIT_LIST_HEAD(&mxs_dma->dma_device.channels);\r\nfor (i = 0; i < MXS_DMA_CHANNELS; i++) {\r\nstruct mxs_dma_chan *mxs_chan = &mxs_dma->mxs_chans[i];\r\nmxs_chan->mxs_dma = mxs_dma;\r\nmxs_chan->chan.device = &mxs_dma->dma_device;\r\ndma_cookie_init(&mxs_chan->chan);\r\ntasklet_init(&mxs_chan->tasklet, mxs_dma_tasklet,\r\n(unsigned long) mxs_chan);\r\nlist_add_tail(&mxs_chan->chan.device_node,\r\n&mxs_dma->dma_device.channels);\r\n}\r\nret = mxs_dma_init(mxs_dma);\r\nif (ret)\r\ngoto err_init;\r\nmxs_dma->dma_device.dev = &pdev->dev;\r\nmxs_dma->dma_device.dev->dma_parms = &mxs_dma->dma_parms;\r\ndma_set_max_seg_size(mxs_dma->dma_device.dev, MAX_XFER_BYTES);\r\nmxs_dma->dma_device.device_alloc_chan_resources = mxs_dma_alloc_chan_resources;\r\nmxs_dma->dma_device.device_free_chan_resources = mxs_dma_free_chan_resources;\r\nmxs_dma->dma_device.device_tx_status = mxs_dma_tx_status;\r\nmxs_dma->dma_device.device_prep_slave_sg = mxs_dma_prep_slave_sg;\r\nmxs_dma->dma_device.device_prep_dma_cyclic = mxs_dma_prep_dma_cyclic;\r\nmxs_dma->dma_device.device_control = mxs_dma_control;\r\nmxs_dma->dma_device.device_issue_pending = mxs_dma_issue_pending;\r\nret = dma_async_device_register(&mxs_dma->dma_device);\r\nif (ret) {\r\ndev_err(mxs_dma->dma_device.dev, "unable to register\n");\r\ngoto err_init;\r\n}\r\ndev_info(mxs_dma->dma_device.dev, "initialized\n");\r\nreturn 0;\r\nerr_init:\r\nclk_put(mxs_dma->clk);\r\nerr_clk:\r\niounmap(mxs_dma->base);\r\nerr_ioremap:\r\nrelease_mem_region(iores->start, resource_size(iores));\r\nerr_request_region:\r\nkfree(mxs_dma);\r\nreturn ret;\r\n}\r\nstatic int __init mxs_dma_module_init(void)\r\n{\r\nreturn platform_driver_probe(&mxs_dma_driver, mxs_dma_probe);\r\n}
