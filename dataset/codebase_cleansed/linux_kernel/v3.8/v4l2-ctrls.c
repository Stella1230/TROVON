static bool is_cur_manual(const struct v4l2_ctrl *master)\r\n{\r\nreturn master->is_auto && master->cur.val == master->manual_mode_value;\r\n}\r\nstatic bool is_new_manual(const struct v4l2_ctrl *master)\r\n{\r\nreturn master->is_auto && master->val == master->manual_mode_value;\r\n}\r\nconst char * const *v4l2_ctrl_get_menu(u32 id)\r\n{\r\nstatic const char * const mpeg_audio_sampling_freq[] = {\r\n"44.1 kHz",\r\n"48 kHz",\r\n"32 kHz",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_encoding[] = {\r\n"MPEG-1/2 Layer I",\r\n"MPEG-1/2 Layer II",\r\n"MPEG-1/2 Layer III",\r\n"MPEG-2/4 AAC",\r\n"AC-3",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_l1_bitrate[] = {\r\n"32 kbps",\r\n"64 kbps",\r\n"96 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"288 kbps",\r\n"320 kbps",\r\n"352 kbps",\r\n"384 kbps",\r\n"416 kbps",\r\n"448 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_l2_bitrate[] = {\r\n"32 kbps",\r\n"48 kbps",\r\n"56 kbps",\r\n"64 kbps",\r\n"80 kbps",\r\n"96 kbps",\r\n"112 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"320 kbps",\r\n"384 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_l3_bitrate[] = {\r\n"32 kbps",\r\n"40 kbps",\r\n"48 kbps",\r\n"56 kbps",\r\n"64 kbps",\r\n"80 kbps",\r\n"96 kbps",\r\n"112 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"320 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_ac3_bitrate[] = {\r\n"32 kbps",\r\n"40 kbps",\r\n"48 kbps",\r\n"56 kbps",\r\n"64 kbps",\r\n"80 kbps",\r\n"96 kbps",\r\n"112 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"320 kbps",\r\n"384 kbps",\r\n"448 kbps",\r\n"512 kbps",\r\n"576 kbps",\r\n"640 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_mode[] = {\r\n"Stereo",\r\n"Joint Stereo",\r\n"Dual",\r\n"Mono",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_mode_extension[] = {\r\n"Bound 4",\r\n"Bound 8",\r\n"Bound 12",\r\n"Bound 16",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_emphasis[] = {\r\n"No Emphasis",\r\n"50/15 us",\r\n"CCITT J17",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_crc[] = {\r\n"No CRC",\r\n"16-bit CRC",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_dec_playback[] = {\r\n"Auto",\r\n"Stereo",\r\n"Left",\r\n"Right",\r\n"Mono",\r\n"Swapped Stereo",\r\nNULL\r\n};\r\nstatic const char * const mpeg_video_encoding[] = {\r\n"MPEG-1",\r\n"MPEG-2",\r\n"MPEG-4 AVC",\r\nNULL\r\n};\r\nstatic const char * const mpeg_video_aspect[] = {\r\n"1x1",\r\n"4x3",\r\n"16x9",\r\n"2.21x1",\r\nNULL\r\n};\r\nstatic const char * const mpeg_video_bitrate_mode[] = {\r\n"Variable Bitrate",\r\n"Constant Bitrate",\r\nNULL\r\n};\r\nstatic const char * const mpeg_stream_type[] = {\r\n"MPEG-2 Program Stream",\r\n"MPEG-2 Transport Stream",\r\n"MPEG-1 System Stream",\r\n"MPEG-2 DVD-compatible Stream",\r\n"MPEG-1 VCD-compatible Stream",\r\n"MPEG-2 SVCD-compatible Stream",\r\nNULL\r\n};\r\nstatic const char * const mpeg_stream_vbi_fmt[] = {\r\n"No VBI",\r\n"Private Packet, IVTV Format",\r\nNULL\r\n};\r\nstatic const char * const camera_power_line_frequency[] = {\r\n"Disabled",\r\n"50 Hz",\r\n"60 Hz",\r\n"Auto",\r\nNULL\r\n};\r\nstatic const char * const camera_exposure_auto[] = {\r\n"Auto Mode",\r\n"Manual Mode",\r\n"Shutter Priority Mode",\r\n"Aperture Priority Mode",\r\nNULL\r\n};\r\nstatic const char * const camera_exposure_metering[] = {\r\n"Average",\r\n"Center Weighted",\r\n"Spot",\r\nNULL\r\n};\r\nstatic const char * const camera_auto_focus_range[] = {\r\n"Auto",\r\n"Normal",\r\n"Macro",\r\n"Infinity",\r\nNULL\r\n};\r\nstatic const char * const colorfx[] = {\r\n"None",\r\n"Black & White",\r\n"Sepia",\r\n"Negative",\r\n"Emboss",\r\n"Sketch",\r\n"Sky Blue",\r\n"Grass Green",\r\n"Skin Whiten",\r\n"Vivid",\r\n"Aqua",\r\n"Art Freeze",\r\n"Silhouette",\r\n"Solarization",\r\n"Antique",\r\n"Set Cb/Cr",\r\nNULL\r\n};\r\nstatic const char * const auto_n_preset_white_balance[] = {\r\n"Manual",\r\n"Auto",\r\n"Incandescent",\r\n"Fluorescent",\r\n"Fluorescent H",\r\n"Horizon",\r\n"Daylight",\r\n"Flash",\r\n"Cloudy",\r\n"Shade",\r\nNULL,\r\n};\r\nstatic const char * const camera_iso_sensitivity_auto[] = {\r\n"Manual",\r\n"Auto",\r\nNULL\r\n};\r\nstatic const char * const scene_mode[] = {\r\n"None",\r\n"Backlight",\r\n"Beach/Snow",\r\n"Candle Light",\r\n"Dusk/Dawn",\r\n"Fall Colors",\r\n"Fireworks",\r\n"Landscape",\r\n"Night",\r\n"Party/Indoor",\r\n"Portrait",\r\n"Sports",\r\n"Sunset",\r\n"Text",\r\nNULL\r\n};\r\nstatic const char * const tune_preemphasis[] = {\r\n"No Preemphasis",\r\n"50 Microseconds",\r\n"75 Microseconds",\r\nNULL,\r\n};\r\nstatic const char * const header_mode[] = {\r\n"Separate Buffer",\r\n"Joined With 1st Frame",\r\nNULL,\r\n};\r\nstatic const char * const multi_slice[] = {\r\n"Single",\r\n"Max Macroblocks",\r\n"Max Bytes",\r\nNULL,\r\n};\r\nstatic const char * const entropy_mode[] = {\r\n"CAVLC",\r\n"CABAC",\r\nNULL,\r\n};\r\nstatic const char * const mpeg_h264_level[] = {\r\n"1",\r\n"1b",\r\n"1.1",\r\n"1.2",\r\n"1.3",\r\n"2",\r\n"2.1",\r\n"2.2",\r\n"3",\r\n"3.1",\r\n"3.2",\r\n"4",\r\n"4.1",\r\n"4.2",\r\n"5",\r\n"5.1",\r\nNULL,\r\n};\r\nstatic const char * const h264_loop_filter[] = {\r\n"Enabled",\r\n"Disabled",\r\n"Disabled at Slice Boundary",\r\nNULL,\r\n};\r\nstatic const char * const h264_profile[] = {\r\n"Baseline",\r\n"Constrained Baseline",\r\n"Main",\r\n"Extended",\r\n"High",\r\n"High 10",\r\n"High 422",\r\n"High 444 Predictive",\r\n"High 10 Intra",\r\n"High 422 Intra",\r\n"High 444 Intra",\r\n"CAVLC 444 Intra",\r\n"Scalable Baseline",\r\n"Scalable High",\r\n"Scalable High Intra",\r\n"Multiview High",\r\nNULL,\r\n};\r\nstatic const char * const vui_sar_idc[] = {\r\n"Unspecified",\r\n"1:1",\r\n"12:11",\r\n"10:11",\r\n"16:11",\r\n"40:33",\r\n"24:11",\r\n"20:11",\r\n"32:11",\r\n"80:33",\r\n"18:11",\r\n"15:11",\r\n"64:33",\r\n"160:99",\r\n"4:3",\r\n"3:2",\r\n"2:1",\r\n"Extended SAR",\r\nNULL,\r\n};\r\nstatic const char * const h264_fp_arrangement_type[] = {\r\n"Checkerboard",\r\n"Column",\r\n"Row",\r\n"Side by Side",\r\n"Top Bottom",\r\n"Temporal",\r\nNULL,\r\n};\r\nstatic const char * const h264_fmo_map_type[] = {\r\n"Interleaved Slices",\r\n"Scattered Slices",\r\n"Foreground with Leftover",\r\n"Box Out",\r\n"Raster Scan",\r\n"Wipe Scan",\r\n"Explicit",\r\nNULL,\r\n};\r\nstatic const char * const mpeg_mpeg4_level[] = {\r\n"0",\r\n"0b",\r\n"1",\r\n"2",\r\n"3",\r\n"3b",\r\n"4",\r\n"5",\r\nNULL,\r\n};\r\nstatic const char * const mpeg4_profile[] = {\r\n"Simple",\r\n"Advanced Simple",\r\n"Core",\r\n"Simple Scalable",\r\n"Advanced Coding Efficency",\r\nNULL,\r\n};\r\nstatic const char * const flash_led_mode[] = {\r\n"Off",\r\n"Flash",\r\n"Torch",\r\nNULL,\r\n};\r\nstatic const char * const flash_strobe_source[] = {\r\n"Software",\r\n"External",\r\nNULL,\r\n};\r\nstatic const char * const jpeg_chroma_subsampling[] = {\r\n"4:4:4",\r\n"4:2:2",\r\n"4:2:0",\r\n"4:1:1",\r\n"4:1:0",\r\n"Gray",\r\nNULL,\r\n};\r\nstatic const char * const dv_tx_mode[] = {\r\n"DVI-D",\r\n"HDMI",\r\nNULL,\r\n};\r\nstatic const char * const dv_rgb_range[] = {\r\n"Automatic",\r\n"RGB limited range (16-235)",\r\n"RGB full range (0-255)",\r\nNULL,\r\n};\r\nswitch (id) {\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\nreturn mpeg_audio_sampling_freq;\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nreturn mpeg_audio_encoding;\r\ncase V4L2_CID_MPEG_AUDIO_L1_BITRATE:\r\nreturn mpeg_audio_l1_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nreturn mpeg_audio_l2_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_L3_BITRATE:\r\nreturn mpeg_audio_l3_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nreturn mpeg_audio_ac3_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_MODE:\r\nreturn mpeg_audio_mode;\r\ncase V4L2_CID_MPEG_AUDIO_MODE_EXTENSION:\r\nreturn mpeg_audio_mode_extension;\r\ncase V4L2_CID_MPEG_AUDIO_EMPHASIS:\r\nreturn mpeg_audio_emphasis;\r\ncase V4L2_CID_MPEG_AUDIO_CRC:\r\nreturn mpeg_audio_crc;\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:\r\ncase V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK:\r\nreturn mpeg_audio_dec_playback;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn mpeg_video_encoding;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nreturn mpeg_video_aspect;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nreturn mpeg_video_bitrate_mode;\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nreturn mpeg_stream_type;\r\ncase V4L2_CID_MPEG_STREAM_VBI_FMT:\r\nreturn mpeg_stream_vbi_fmt;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nreturn camera_power_line_frequency;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn camera_exposure_auto;\r\ncase V4L2_CID_EXPOSURE_METERING:\r\nreturn camera_exposure_metering;\r\ncase V4L2_CID_AUTO_FOCUS_RANGE:\r\nreturn camera_auto_focus_range;\r\ncase V4L2_CID_COLORFX:\r\nreturn colorfx;\r\ncase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\r\nreturn auto_n_preset_white_balance;\r\ncase V4L2_CID_ISO_SENSITIVITY_AUTO:\r\nreturn camera_iso_sensitivity_auto;\r\ncase V4L2_CID_SCENE_MODE:\r\nreturn scene_mode;\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\nreturn tune_preemphasis;\r\ncase V4L2_CID_FLASH_LED_MODE:\r\nreturn flash_led_mode;\r\ncase V4L2_CID_FLASH_STROBE_SOURCE:\r\nreturn flash_strobe_source;\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\nreturn header_mode;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\nreturn multi_slice;\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\r\nreturn entropy_mode;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\nreturn mpeg_h264_level;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\r\nreturn h264_loop_filter;\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\nreturn h264_profile;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\r\nreturn vui_sar_idc;\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:\r\nreturn h264_fp_arrangement_type;\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE:\r\nreturn h264_fmo_map_type;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\r\nreturn mpeg_mpeg4_level;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\r\nreturn mpeg4_profile;\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\nreturn jpeg_chroma_subsampling;\r\ncase V4L2_CID_DV_TX_MODE:\r\nreturn dv_tx_mode;\r\ncase V4L2_CID_DV_TX_RGB_RANGE:\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\nreturn dv_rgb_range;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nconst char *v4l2_ctrl_get_name(u32 id)\r\n{\r\nswitch (id) {\r\ncase V4L2_CID_USER_CLASS: return "User Controls";\r\ncase V4L2_CID_BRIGHTNESS: return "Brightness";\r\ncase V4L2_CID_CONTRAST: return "Contrast";\r\ncase V4L2_CID_SATURATION: return "Saturation";\r\ncase V4L2_CID_HUE: return "Hue";\r\ncase V4L2_CID_AUDIO_VOLUME: return "Volume";\r\ncase V4L2_CID_AUDIO_BALANCE: return "Balance";\r\ncase V4L2_CID_AUDIO_BASS: return "Bass";\r\ncase V4L2_CID_AUDIO_TREBLE: return "Treble";\r\ncase V4L2_CID_AUDIO_MUTE: return "Mute";\r\ncase V4L2_CID_AUDIO_LOUDNESS: return "Loudness";\r\ncase V4L2_CID_BLACK_LEVEL: return "Black Level";\r\ncase V4L2_CID_AUTO_WHITE_BALANCE: return "White Balance, Automatic";\r\ncase V4L2_CID_DO_WHITE_BALANCE: return "Do White Balance";\r\ncase V4L2_CID_RED_BALANCE: return "Red Balance";\r\ncase V4L2_CID_BLUE_BALANCE: return "Blue Balance";\r\ncase V4L2_CID_GAMMA: return "Gamma";\r\ncase V4L2_CID_EXPOSURE: return "Exposure";\r\ncase V4L2_CID_AUTOGAIN: return "Gain, Automatic";\r\ncase V4L2_CID_GAIN: return "Gain";\r\ncase V4L2_CID_HFLIP: return "Horizontal Flip";\r\ncase V4L2_CID_VFLIP: return "Vertical Flip";\r\ncase V4L2_CID_HCENTER: return "Horizontal Center";\r\ncase V4L2_CID_VCENTER: return "Vertical Center";\r\ncase V4L2_CID_POWER_LINE_FREQUENCY: return "Power Line Frequency";\r\ncase V4L2_CID_HUE_AUTO: return "Hue, Automatic";\r\ncase V4L2_CID_WHITE_BALANCE_TEMPERATURE: return "White Balance Temperature";\r\ncase V4L2_CID_SHARPNESS: return "Sharpness";\r\ncase V4L2_CID_BACKLIGHT_COMPENSATION: return "Backlight Compensation";\r\ncase V4L2_CID_CHROMA_AGC: return "Chroma AGC";\r\ncase V4L2_CID_COLOR_KILLER: return "Color Killer";\r\ncase V4L2_CID_COLORFX: return "Color Effects";\r\ncase V4L2_CID_AUTOBRIGHTNESS: return "Brightness, Automatic";\r\ncase V4L2_CID_BAND_STOP_FILTER: return "Band-Stop Filter";\r\ncase V4L2_CID_ROTATE: return "Rotate";\r\ncase V4L2_CID_BG_COLOR: return "Background Color";\r\ncase V4L2_CID_CHROMA_GAIN: return "Chroma Gain";\r\ncase V4L2_CID_ILLUMINATORS_1: return "Illuminator 1";\r\ncase V4L2_CID_ILLUMINATORS_2: return "Illuminator 2";\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE: return "Min Number of Capture Buffers";\r\ncase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT: return "Min Number of Output Buffers";\r\ncase V4L2_CID_ALPHA_COMPONENT: return "Alpha Component";\r\ncase V4L2_CID_COLORFX_CBCR: return "Color Effects, CbCr";\r\ncase V4L2_CID_MPEG_CLASS: return "MPEG Encoder Controls";\r\ncase V4L2_CID_MPEG_STREAM_TYPE: return "Stream Type";\r\ncase V4L2_CID_MPEG_STREAM_PID_PMT: return "Stream PMT Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PID_AUDIO: return "Stream Audio Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PID_VIDEO: return "Stream Video Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PID_PCR: return "Stream PCR Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: return "Stream PES Audio ID";\r\ncase V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: return "Stream PES Video ID";\r\ncase V4L2_CID_MPEG_STREAM_VBI_FMT: return "Stream VBI Format";\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: return "Audio Sampling Frequency";\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING: return "Audio Encoding";\r\ncase V4L2_CID_MPEG_AUDIO_L1_BITRATE: return "Audio Layer I Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE: return "Audio Layer II Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_L3_BITRATE: return "Audio Layer III Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_MODE: return "Audio Stereo Mode";\r\ncase V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: return "Audio Stereo Mode Extension";\r\ncase V4L2_CID_MPEG_AUDIO_EMPHASIS: return "Audio Emphasis";\r\ncase V4L2_CID_MPEG_AUDIO_CRC: return "Audio CRC";\r\ncase V4L2_CID_MPEG_AUDIO_MUTE: return "Audio Mute";\r\ncase V4L2_CID_MPEG_AUDIO_AAC_BITRATE: return "Audio AAC Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE: return "Audio AC-3 Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK: return "Audio Playback";\r\ncase V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: return "Audio Multilingual Playback";\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING: return "Video Encoding";\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT: return "Video Aspect";\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES: return "Video B Frames";\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE: return "Video GOP Size";\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE: return "Video GOP Closure";\r\ncase V4L2_CID_MPEG_VIDEO_PULLDOWN: return "Video Pulldown";\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE: return "Video Bitrate Mode";\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE: return "Video Bitrate";\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: return "Video Peak Bitrate";\r\ncase V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: return "Video Temporal Decimation";\r\ncase V4L2_CID_MPEG_VIDEO_MUTE: return "Video Mute";\r\ncase V4L2_CID_MPEG_VIDEO_MUTE_YUV: return "Video Mute YUV";\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE: return "Decoder Slice Interface";\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER: return "MPEG4 Loop Filter Enable";\r\ncase V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB: return "Number of Intra Refresh MBs";\r\ncase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE: return "Frame Level Rate Control Enable";\r\ncase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE: return "H264 MB Level Rate Control";\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE: return "Sequence Header Mode";\r\ncase V4L2_CID_MPEG_VIDEO_MAX_REF_PIC: return "Max Number of Reference Pics";\r\ncase V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP: return "H263 I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP: return "H263 P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP: return "H263 B-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_MIN_QP: return "H263 Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_MAX_QP: return "H263 Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP: return "H264 I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP: return "H264 P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP: return "H264 B-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_MAX_QP: return "H264 Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP: return "H264 Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM: return "H264 8x8 Transform Enable";\r\ncase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE: return "H264 CPB Buffer Size";\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE: return "H264 Entropy Mode";\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_PERIOD: return "H264 I-Frame Period";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL: return "H264 Level";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA: return "H264 Loop Filter Alpha Offset";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA: return "H264 Loop Filter Beta Offset";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE: return "H264 Loop Filter Mode";\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE: return "H264 Profile";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT: return "Vertical Size of SAR";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH: return "Horizontal Size of SAR";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE: return "Aspect Ratio VUI Enable";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC: return "VUI Aspect Ratio IDC";\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING: return "H264 Enable Frame Packing SEI";\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0: return "H264 Set Curr. Frame as Frame0";\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE: return "H264 FP Arrangement Type";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO: return "H264 Flexible MB Ordering";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE: return "H264 Map Type for FMO";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP: return "H264 FMO Number of Slice Groups";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION: return "H264 FMO Direction of Change";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE: return "H264 FMO Size of 1st Slice Grp";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH: return "H264 FMO No. of Consecutive MBs";\r\ncase V4L2_CID_MPEG_VIDEO_H264_ASO: return "H264 Arbitrary Slice Ordering";\r\ncase V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER: return "H264 ASO Slice Order";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING: return "Enable H264 Hierarchical Coding";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE: return "H264 Hierarchical Coding Type";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER:return "H264 Number of HC Layers";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP:\r\nreturn "H264 Set QP Value for HC Layers";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP: return "MPEG4 I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP: return "MPEG4 P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP: return "MPEG4 B-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP: return "MPEG4 Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP: return "MPEG4 Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL: return "MPEG4 Level";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE: return "MPEG4 Profile";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_QPEL: return "Quarter Pixel Search Enable";\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES: return "Maximum Bytes in a Slice";\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB: return "Number of MBs in a Slice";\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE: return "Slice Partitioning Method";\r\ncase V4L2_CID_MPEG_VIDEO_VBV_SIZE: return "VBV Buffer Size";\r\ncase V4L2_CID_MPEG_VIDEO_DEC_PTS: return "Video Decoder PTS";\r\ncase V4L2_CID_MPEG_VIDEO_DEC_FRAME: return "Video Decoder Frame Count";\r\ncase V4L2_CID_MPEG_VIDEO_VBV_DELAY: return "Initial Delay for VBV Control";\r\ncase V4L2_CID_CAMERA_CLASS: return "Camera Controls";\r\ncase V4L2_CID_EXPOSURE_AUTO: return "Auto Exposure";\r\ncase V4L2_CID_EXPOSURE_ABSOLUTE: return "Exposure Time, Absolute";\r\ncase V4L2_CID_EXPOSURE_AUTO_PRIORITY: return "Exposure, Dynamic Framerate";\r\ncase V4L2_CID_PAN_RELATIVE: return "Pan, Relative";\r\ncase V4L2_CID_TILT_RELATIVE: return "Tilt, Relative";\r\ncase V4L2_CID_PAN_RESET: return "Pan, Reset";\r\ncase V4L2_CID_TILT_RESET: return "Tilt, Reset";\r\ncase V4L2_CID_PAN_ABSOLUTE: return "Pan, Absolute";\r\ncase V4L2_CID_TILT_ABSOLUTE: return "Tilt, Absolute";\r\ncase V4L2_CID_FOCUS_ABSOLUTE: return "Focus, Absolute";\r\ncase V4L2_CID_FOCUS_RELATIVE: return "Focus, Relative";\r\ncase V4L2_CID_FOCUS_AUTO: return "Focus, Automatic Continuous";\r\ncase V4L2_CID_ZOOM_ABSOLUTE: return "Zoom, Absolute";\r\ncase V4L2_CID_ZOOM_RELATIVE: return "Zoom, Relative";\r\ncase V4L2_CID_ZOOM_CONTINUOUS: return "Zoom, Continuous";\r\ncase V4L2_CID_PRIVACY: return "Privacy";\r\ncase V4L2_CID_IRIS_ABSOLUTE: return "Iris, Absolute";\r\ncase V4L2_CID_IRIS_RELATIVE: return "Iris, Relative";\r\ncase V4L2_CID_AUTO_EXPOSURE_BIAS: return "Auto Exposure, Bias";\r\ncase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: return "White Balance, Auto & Preset";\r\ncase V4L2_CID_WIDE_DYNAMIC_RANGE: return "Wide Dynamic Range";\r\ncase V4L2_CID_IMAGE_STABILIZATION: return "Image Stabilization";\r\ncase V4L2_CID_ISO_SENSITIVITY: return "ISO Sensitivity";\r\ncase V4L2_CID_ISO_SENSITIVITY_AUTO: return "ISO Sensitivity, Auto";\r\ncase V4L2_CID_EXPOSURE_METERING: return "Exposure, Metering Mode";\r\ncase V4L2_CID_SCENE_MODE: return "Scene Mode";\r\ncase V4L2_CID_3A_LOCK: return "3A Lock";\r\ncase V4L2_CID_AUTO_FOCUS_START: return "Auto Focus, Start";\r\ncase V4L2_CID_AUTO_FOCUS_STOP: return "Auto Focus, Stop";\r\ncase V4L2_CID_AUTO_FOCUS_STATUS: return "Auto Focus, Status";\r\ncase V4L2_CID_AUTO_FOCUS_RANGE: return "Auto Focus, Range";\r\ncase V4L2_CID_FM_TX_CLASS: return "FM Radio Modulator Controls";\r\ncase V4L2_CID_RDS_TX_DEVIATION: return "RDS Signal Deviation";\r\ncase V4L2_CID_RDS_TX_PI: return "RDS Program ID";\r\ncase V4L2_CID_RDS_TX_PTY: return "RDS Program Type";\r\ncase V4L2_CID_RDS_TX_PS_NAME: return "RDS PS Name";\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT: return "RDS Radio Text";\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED: return "Audio Limiter Feature Enabled";\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: return "Audio Limiter Release Time";\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION: return "Audio Limiter Deviation";\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED: return "Audio Compression Enabled";\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN: return "Audio Compression Gain";\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: return "Audio Compression Threshold";\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: return "Audio Compression Attack Time";\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: return "Audio Compression Release Time";\r\ncase V4L2_CID_PILOT_TONE_ENABLED: return "Pilot Tone Feature Enabled";\r\ncase V4L2_CID_PILOT_TONE_DEVIATION: return "Pilot Tone Deviation";\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY: return "Pilot Tone Frequency";\r\ncase V4L2_CID_TUNE_PREEMPHASIS: return "Pre-Emphasis";\r\ncase V4L2_CID_TUNE_POWER_LEVEL: return "Tune Power Level";\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR: return "Tune Antenna Capacitor";\r\ncase V4L2_CID_FLASH_CLASS: return "Flash Controls";\r\ncase V4L2_CID_FLASH_LED_MODE: return "LED Mode";\r\ncase V4L2_CID_FLASH_STROBE_SOURCE: return "Strobe Source";\r\ncase V4L2_CID_FLASH_STROBE: return "Strobe";\r\ncase V4L2_CID_FLASH_STROBE_STOP: return "Stop Strobe";\r\ncase V4L2_CID_FLASH_STROBE_STATUS: return "Strobe Status";\r\ncase V4L2_CID_FLASH_TIMEOUT: return "Strobe Timeout";\r\ncase V4L2_CID_FLASH_INTENSITY: return "Intensity, Flash Mode";\r\ncase V4L2_CID_FLASH_TORCH_INTENSITY: return "Intensity, Torch Mode";\r\ncase V4L2_CID_FLASH_INDICATOR_INTENSITY: return "Intensity, Indicator";\r\ncase V4L2_CID_FLASH_FAULT: return "Faults";\r\ncase V4L2_CID_FLASH_CHARGE: return "Charge";\r\ncase V4L2_CID_FLASH_READY: return "Ready to Strobe";\r\ncase V4L2_CID_JPEG_CLASS: return "JPEG Compression Controls";\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING: return "Chroma Subsampling";\r\ncase V4L2_CID_JPEG_RESTART_INTERVAL: return "Restart Interval";\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY: return "Compression Quality";\r\ncase V4L2_CID_JPEG_ACTIVE_MARKER: return "Active Markers";\r\ncase V4L2_CID_IMAGE_SOURCE_CLASS: return "Image Source Controls";\r\ncase V4L2_CID_VBLANK: return "Vertical Blanking";\r\ncase V4L2_CID_HBLANK: return "Horizontal Blanking";\r\ncase V4L2_CID_ANALOGUE_GAIN: return "Analogue Gain";\r\ncase V4L2_CID_IMAGE_PROC_CLASS: return "Image Processing Controls";\r\ncase V4L2_CID_LINK_FREQ: return "Link Frequency";\r\ncase V4L2_CID_PIXEL_RATE: return "Pixel Rate";\r\ncase V4L2_CID_TEST_PATTERN: return "Test Pattern";\r\ncase V4L2_CID_DV_CLASS: return "Digital Video Controls";\r\ncase V4L2_CID_DV_TX_HOTPLUG: return "Hotplug Present";\r\ncase V4L2_CID_DV_TX_RXSENSE: return "RxSense Present";\r\ncase V4L2_CID_DV_TX_EDID_PRESENT: return "EDID Present";\r\ncase V4L2_CID_DV_TX_MODE: return "Transmit Mode";\r\ncase V4L2_CID_DV_TX_RGB_RANGE: return "Tx RGB Quantization Range";\r\ncase V4L2_CID_DV_RX_POWER_PRESENT: return "Power Present";\r\ncase V4L2_CID_DV_RX_RGB_RANGE: return "Rx RGB Quantization Range";\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nvoid v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,\r\ns32 *min, s32 *max, s32 *step, s32 *def, u32 *flags)\r\n{\r\n*name = v4l2_ctrl_get_name(id);\r\n*flags = 0;\r\nswitch (id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ncase V4L2_CID_AUDIO_LOUDNESS:\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\ncase V4L2_CID_AUTOGAIN:\r\ncase V4L2_CID_HFLIP:\r\ncase V4L2_CID_VFLIP:\r\ncase V4L2_CID_HUE_AUTO:\r\ncase V4L2_CID_CHROMA_AGC:\r\ncase V4L2_CID_COLOR_KILLER:\r\ncase V4L2_CID_AUTOBRIGHTNESS:\r\ncase V4L2_CID_MPEG_AUDIO_MUTE:\r\ncase V4L2_CID_MPEG_VIDEO_MUTE:\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\r\ncase V4L2_CID_MPEG_VIDEO_PULLDOWN:\r\ncase V4L2_CID_EXPOSURE_AUTO_PRIORITY:\r\ncase V4L2_CID_FOCUS_AUTO:\r\ncase V4L2_CID_PRIVACY:\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED:\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED:\r\ncase V4L2_CID_PILOT_TONE_ENABLED:\r\ncase V4L2_CID_ILLUMINATORS_1:\r\ncase V4L2_CID_ILLUMINATORS_2:\r\ncase V4L2_CID_FLASH_STROBE_STATUS:\r\ncase V4L2_CID_FLASH_CHARGE:\r\ncase V4L2_CID_FLASH_READY:\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER:\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE:\r\ncase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\r\ncase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_QPEL:\r\ncase V4L2_CID_WIDE_DYNAMIC_RANGE:\r\ncase V4L2_CID_IMAGE_STABILIZATION:\r\n*type = V4L2_CTRL_TYPE_BOOLEAN;\r\n*min = 0;\r\n*max = *step = 1;\r\nbreak;\r\ncase V4L2_CID_PAN_RESET:\r\ncase V4L2_CID_TILT_RESET:\r\ncase V4L2_CID_FLASH_STROBE:\r\ncase V4L2_CID_FLASH_STROBE_STOP:\r\ncase V4L2_CID_AUTO_FOCUS_START:\r\ncase V4L2_CID_AUTO_FOCUS_STOP:\r\n*type = V4L2_CTRL_TYPE_BUTTON;\r\n*flags |= V4L2_CTRL_FLAG_WRITE_ONLY;\r\n*min = *max = *step = *def = 0;\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\ncase V4L2_CID_MPEG_AUDIO_L1_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_L3_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_MODE:\r\ncase V4L2_CID_MPEG_AUDIO_MODE_EXTENSION:\r\ncase V4L2_CID_MPEG_AUDIO_EMPHASIS:\r\ncase V4L2_CID_MPEG_AUDIO_CRC:\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:\r\ncase V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK:\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\ncase V4L2_CID_MPEG_STREAM_VBI_FMT:\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\ncase V4L2_CID_AUTO_FOCUS_RANGE:\r\ncase V4L2_CID_COLORFX:\r\ncase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\ncase V4L2_CID_FLASH_LED_MODE:\r\ncase V4L2_CID_FLASH_STROBE_SOURCE:\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE:\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\ncase V4L2_CID_ISO_SENSITIVITY_AUTO:\r\ncase V4L2_CID_EXPOSURE_METERING:\r\ncase V4L2_CID_SCENE_MODE:\r\ncase V4L2_CID_DV_TX_MODE:\r\ncase V4L2_CID_DV_TX_RGB_RANGE:\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\ncase V4L2_CID_TEST_PATTERN:\r\n*type = V4L2_CTRL_TYPE_MENU;\r\nbreak;\r\ncase V4L2_CID_LINK_FREQ:\r\n*type = V4L2_CTRL_TYPE_INTEGER_MENU;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\n*type = V4L2_CTRL_TYPE_STRING;\r\nbreak;\r\ncase V4L2_CID_ISO_SENSITIVITY:\r\ncase V4L2_CID_AUTO_EXPOSURE_BIAS:\r\n*type = V4L2_CTRL_TYPE_INTEGER_MENU;\r\nbreak;\r\ncase V4L2_CID_USER_CLASS:\r\ncase V4L2_CID_CAMERA_CLASS:\r\ncase V4L2_CID_MPEG_CLASS:\r\ncase V4L2_CID_FM_TX_CLASS:\r\ncase V4L2_CID_FLASH_CLASS:\r\ncase V4L2_CID_JPEG_CLASS:\r\ncase V4L2_CID_IMAGE_SOURCE_CLASS:\r\ncase V4L2_CID_IMAGE_PROC_CLASS:\r\ncase V4L2_CID_DV_CLASS:\r\n*type = V4L2_CTRL_TYPE_CTRL_CLASS;\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_WRITE_ONLY;\r\n*min = *max = *step = *def = 0;\r\nbreak;\r\ncase V4L2_CID_BG_COLOR:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\n*step = 1;\r\n*min = 0;\r\n*max = 0xFFFFFF;\r\nbreak;\r\ncase V4L2_CID_FLASH_FAULT:\r\ncase V4L2_CID_JPEG_ACTIVE_MARKER:\r\ncase V4L2_CID_3A_LOCK:\r\ncase V4L2_CID_AUTO_FOCUS_STATUS:\r\ncase V4L2_CID_DV_TX_HOTPLUG:\r\ncase V4L2_CID_DV_TX_RXSENSE:\r\ncase V4L2_CID_DV_TX_EDID_PRESENT:\r\ncase V4L2_CID_DV_RX_POWER_PRESENT:\r\n*type = V4L2_CTRL_TYPE_BITMASK;\r\nbreak;\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\r\ncase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DEC_FRAME:\r\ncase V4L2_CID_MPEG_VIDEO_DEC_PTS:\r\n*flags |= V4L2_CTRL_FLAG_VOLATILE;\r\ncase V4L2_CID_PIXEL_RATE:\r\n*type = V4L2_CTRL_TYPE_INTEGER64;\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\n*min = *max = *step = *def = 0;\r\nbreak;\r\ndefault:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\nbreak;\r\n}\r\nswitch (id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\ncase V4L2_CID_MPEG_AUDIO_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\n*flags |= V4L2_CTRL_FLAG_UPDATE;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncase V4L2_CID_AUDIO_BALANCE:\r\ncase V4L2_CID_AUDIO_BASS:\r\ncase V4L2_CID_AUDIO_TREBLE:\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_RED_BALANCE:\r\ncase V4L2_CID_BLUE_BALANCE:\r\ncase V4L2_CID_GAMMA:\r\ncase V4L2_CID_SHARPNESS:\r\ncase V4L2_CID_CHROMA_GAIN:\r\ncase V4L2_CID_RDS_TX_DEVIATION:\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME:\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION:\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN:\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD:\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME:\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME:\r\ncase V4L2_CID_PILOT_TONE_DEVIATION:\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY:\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\n*flags |= V4L2_CTRL_FLAG_SLIDER;\r\nbreak;\r\ncase V4L2_CID_PAN_RELATIVE:\r\ncase V4L2_CID_TILT_RELATIVE:\r\ncase V4L2_CID_FOCUS_RELATIVE:\r\ncase V4L2_CID_IRIS_RELATIVE:\r\ncase V4L2_CID_ZOOM_RELATIVE:\r\n*flags |= V4L2_CTRL_FLAG_WRITE_ONLY;\r\nbreak;\r\ncase V4L2_CID_FLASH_STROBE_STATUS:\r\ncase V4L2_CID_AUTO_FOCUS_STATUS:\r\ncase V4L2_CID_FLASH_READY:\r\ncase V4L2_CID_DV_TX_HOTPLUG:\r\ncase V4L2_CID_DV_TX_RXSENSE:\r\ncase V4L2_CID_DV_TX_EDID_PRESENT:\r\ncase V4L2_CID_DV_RX_POWER_PRESENT:\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nbreak;\r\n}\r\n}\r\nstatic bool type_is_int(const struct v4l2_ctrl *ctrl)\r\n{\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\ncase V4L2_CTRL_TYPE_STRING:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic void fill_event(struct v4l2_event *ev, struct v4l2_ctrl *ctrl, u32 changes)\r\n{\r\nmemset(ev->reserved, 0, sizeof(ev->reserved));\r\nev->type = V4L2_EVENT_CTRL;\r\nev->id = ctrl->id;\r\nev->u.ctrl.changes = changes;\r\nev->u.ctrl.type = ctrl->type;\r\nev->u.ctrl.flags = ctrl->flags;\r\nif (ctrl->type == V4L2_CTRL_TYPE_STRING)\r\nev->u.ctrl.value64 = 0;\r\nelse\r\nev->u.ctrl.value64 = ctrl->cur.val64;\r\nev->u.ctrl.minimum = ctrl->minimum;\r\nev->u.ctrl.maximum = ctrl->maximum;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU\r\n|| ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nev->u.ctrl.step = 1;\r\nelse\r\nev->u.ctrl.step = ctrl->step;\r\nev->u.ctrl.default_value = ctrl->default_value;\r\n}\r\nstatic void send_event(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 changes)\r\n{\r\nstruct v4l2_event ev;\r\nstruct v4l2_subscribed_event *sev;\r\nif (list_empty(&ctrl->ev_subs))\r\nreturn;\r\nfill_event(&ev, ctrl, changes);\r\nlist_for_each_entry(sev, &ctrl->ev_subs, node)\r\nif (sev->fh != fh ||\r\n(sev->flags & V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK))\r\nv4l2_event_queue_fh(sev->fh, &ev);\r\n}\r\nstatic int cur_to_user(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nu32 len;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_STRING:\r\nlen = strlen(ctrl->cur.string);\r\nif (c->size < len + 1) {\r\nc->size = len + 1;\r\nreturn -ENOSPC;\r\n}\r\nreturn copy_to_user(c->string, ctrl->cur.string,\r\nlen + 1) ? -EFAULT : 0;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nc->value64 = ctrl->cur.val64;\r\nbreak;\r\ndefault:\r\nc->value = ctrl->cur.val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int user_to_new(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nint ret;\r\nu32 size;\r\nctrl->is_new = 1;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nctrl->val64 = c->value64;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nsize = c->size;\r\nif (size == 0)\r\nreturn -ERANGE;\r\nif (size > ctrl->maximum + 1)\r\nsize = ctrl->maximum + 1;\r\nret = copy_from_user(ctrl->string, c->string, size);\r\nif (!ret) {\r\nchar last = ctrl->string[size - 1];\r\nctrl->string[size - 1] = 0;\r\nif (strlen(ctrl->string) == ctrl->maximum && last)\r\nreturn -ERANGE;\r\n}\r\nreturn ret ? -EFAULT : 0;\r\ndefault:\r\nctrl->val = c->value;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int new_to_user(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nu32 len;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_STRING:\r\nlen = strlen(ctrl->string);\r\nif (c->size < len + 1) {\r\nc->size = ctrl->maximum + 1;\r\nreturn -ENOSPC;\r\n}\r\nreturn copy_to_user(c->string, ctrl->string,\r\nlen + 1) ? -EFAULT : 0;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nc->value64 = ctrl->val64;\r\nbreak;\r\ndefault:\r\nc->value = ctrl->val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void new_to_cur(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl,\r\nbool update_inactive)\r\n{\r\nbool changed = false;\r\nif (ctrl == NULL)\r\nreturn;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\nchanged = true;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nchanged = strcmp(ctrl->string, ctrl->cur.string);\r\nstrcpy(ctrl->cur.string, ctrl->string);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nchanged = ctrl->val64 != ctrl->cur.val64;\r\nctrl->cur.val64 = ctrl->val64;\r\nbreak;\r\ndefault:\r\nchanged = ctrl->val != ctrl->cur.val;\r\nctrl->cur.val = ctrl->val;\r\nbreak;\r\n}\r\nif (update_inactive) {\r\nctrl->flags &=\r\n~(V4L2_CTRL_FLAG_INACTIVE | V4L2_CTRL_FLAG_VOLATILE);\r\nif (!is_cur_manual(ctrl->cluster[0])) {\r\nctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\nif (ctrl->cluster[0]->has_volatiles)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\n}\r\nfh = NULL;\r\n}\r\nif (changed || update_inactive) {\r\nif (!ctrl->is_new)\r\nfh = NULL;\r\nsend_event(fh, ctrl,\r\n(changed ? V4L2_EVENT_CTRL_CH_VALUE : 0) |\r\n(update_inactive ? V4L2_EVENT_CTRL_CH_FLAGS : 0));\r\n}\r\n}\r\nstatic void cur_to_new(struct v4l2_ctrl *ctrl)\r\n{\r\nif (ctrl == NULL)\r\nreturn;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_STRING:\r\nstrcpy(ctrl->string, ctrl->cur.string);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nctrl->val64 = ctrl->cur.val64;\r\nbreak;\r\ndefault:\r\nctrl->val = ctrl->cur.val;\r\nbreak;\r\n}\r\n}\r\nstatic int cluster_changed(struct v4l2_ctrl *master)\r\n{\r\nint diff = 0;\r\nint i;\r\nfor (i = 0; !diff && i < master->ncontrols; i++) {\r\nstruct v4l2_ctrl *ctrl = master->cluster[i];\r\nif (ctrl == NULL)\r\ncontinue;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\nreturn 1;\r\ncase V4L2_CTRL_TYPE_STRING:\r\ndiff = strcmp(ctrl->string, ctrl->cur.string);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\ndiff = ctrl->val64 != ctrl->cur.val64;\r\nbreak;\r\ndefault:\r\ndiff = ctrl->val != ctrl->cur.val;\r\nbreak;\r\n}\r\n}\r\nreturn diff;\r\n}\r\nstatic int validate_new(const struct v4l2_ctrl *ctrl,\r\nstruct v4l2_ext_control *c)\r\n{\r\nsize_t len;\r\nu32 offset;\r\ns32 val;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nval = c->value + ctrl->step / 2;\r\nval = clamp(val, ctrl->minimum, ctrl->maximum);\r\noffset = val - ctrl->minimum;\r\noffset = ctrl->step * (offset / ctrl->step);\r\nc->value = ctrl->minimum + offset;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nc->value = !!c->value;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\nif (c->value < ctrl->minimum || c->value > ctrl->maximum)\r\nreturn -ERANGE;\r\nif (ctrl->menu_skip_mask & (1 << c->value))\r\nreturn -EINVAL;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU &&\r\nctrl->qmenu[c->value][0] == '\0')\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\nc->value &= ctrl->maximum;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\ncase V4L2_CTRL_TYPE_CTRL_CLASS:\r\nc->value = 0;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nlen = strlen(c->string);\r\nif (len < ctrl->minimum)\r\nreturn -ERANGE;\r\nif ((len - ctrl->minimum) % ctrl->step)\r\nreturn -ERANGE;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline u32 node2id(struct list_head *node)\r\n{\r\nreturn list_entry(node, struct v4l2_ctrl_ref, node)->ctrl->id;\r\n}\r\nstatic inline int handler_set_err(struct v4l2_ctrl_handler *hdl, int err)\r\n{\r\nif (hdl->error == 0)\r\nhdl->error = err;\r\nreturn err;\r\n}\r\nint v4l2_ctrl_handler_init(struct v4l2_ctrl_handler *hdl,\r\nunsigned nr_of_controls_hint)\r\n{\r\nhdl->lock = &hdl->_lock;\r\nmutex_init(hdl->lock);\r\nINIT_LIST_HEAD(&hdl->ctrls);\r\nINIT_LIST_HEAD(&hdl->ctrl_refs);\r\nhdl->nr_of_buckets = 1 + nr_of_controls_hint / 8;\r\nhdl->buckets = kcalloc(hdl->nr_of_buckets, sizeof(hdl->buckets[0]),\r\nGFP_KERNEL);\r\nhdl->error = hdl->buckets ? 0 : -ENOMEM;\r\nreturn hdl->error;\r\n}\r\nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl)\r\n{\r\nstruct v4l2_ctrl_ref *ref, *next_ref;\r\nstruct v4l2_ctrl *ctrl, *next_ctrl;\r\nstruct v4l2_subscribed_event *sev, *next_sev;\r\nif (hdl == NULL || hdl->buckets == NULL)\r\nreturn;\r\nmutex_lock(hdl->lock);\r\nlist_for_each_entry_safe(ref, next_ref, &hdl->ctrl_refs, node) {\r\nlist_del(&ref->node);\r\nkfree(ref);\r\n}\r\nlist_for_each_entry_safe(ctrl, next_ctrl, &hdl->ctrls, node) {\r\nlist_del(&ctrl->node);\r\nlist_for_each_entry_safe(sev, next_sev, &ctrl->ev_subs, node)\r\nlist_del(&sev->node);\r\nkfree(ctrl);\r\n}\r\nkfree(hdl->buckets);\r\nhdl->buckets = NULL;\r\nhdl->cached = NULL;\r\nhdl->error = 0;\r\nmutex_unlock(hdl->lock);\r\n}\r\nstatic struct v4l2_ctrl_ref *find_private_ref(\r\nstruct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nid -= V4L2_CID_PRIVATE_BASE;\r\nlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\r\nif (V4L2_CTRL_ID2CLASS(ref->ctrl->id) == V4L2_CTRL_CLASS_USER &&\r\nV4L2_CTRL_DRIVER_PRIV(ref->ctrl->id)) {\r\nif (!type_is_int(ref->ctrl))\r\ncontinue;\r\nif (id == 0)\r\nreturn ref;\r\nid--;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct v4l2_ctrl_ref *find_ref(struct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nint bucket;\r\nid &= V4L2_CTRL_ID_MASK;\r\nif (id >= V4L2_CID_PRIVATE_BASE)\r\nreturn find_private_ref(hdl, id);\r\nbucket = id % hdl->nr_of_buckets;\r\nif (hdl->cached && hdl->cached->ctrl->id == id)\r\nreturn hdl->cached;\r\nref = hdl->buckets ? hdl->buckets[bucket] : NULL;\r\nwhile (ref && ref->ctrl->id != id)\r\nref = ref->next;\r\nif (ref)\r\nhdl->cached = ref;\r\nreturn ref;\r\n}\r\nstatic struct v4l2_ctrl_ref *find_ref_lock(\r\nstruct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref = NULL;\r\nif (hdl) {\r\nmutex_lock(hdl->lock);\r\nref = find_ref(hdl, id);\r\nmutex_unlock(hdl->lock);\r\n}\r\nreturn ref;\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_find(struct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref = find_ref_lock(hdl, id);\r\nreturn ref ? ref->ctrl : NULL;\r\n}\r\nstatic int handler_new_ref(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nstruct v4l2_ctrl_ref *new_ref;\r\nu32 id = ctrl->id;\r\nu32 class_ctrl = V4L2_CTRL_ID2CLASS(id) | 1;\r\nint bucket = id % hdl->nr_of_buckets;\r\nif (id != class_ctrl && find_ref_lock(hdl, class_ctrl) == NULL)\r\nif (!v4l2_ctrl_new_std(hdl, NULL, class_ctrl, 0, 0, 0, 0))\r\nreturn hdl->error;\r\nif (hdl->error)\r\nreturn hdl->error;\r\nnew_ref = kzalloc(sizeof(*new_ref), GFP_KERNEL);\r\nif (!new_ref)\r\nreturn handler_set_err(hdl, -ENOMEM);\r\nnew_ref->ctrl = ctrl;\r\nif (ctrl->handler == hdl) {\r\nctrl->cluster = &new_ref->ctrl;\r\nctrl->ncontrols = 1;\r\n}\r\nINIT_LIST_HEAD(&new_ref->node);\r\nmutex_lock(hdl->lock);\r\nif (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev)) {\r\nlist_add_tail(&new_ref->node, &hdl->ctrl_refs);\r\ngoto insert_in_hash;\r\n}\r\nlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\r\nif (ref->ctrl->id < id)\r\ncontinue;\r\nif (ref->ctrl->id == id) {\r\nkfree(new_ref);\r\ngoto unlock;\r\n}\r\nlist_add(&new_ref->node, ref->node.prev);\r\nbreak;\r\n}\r\ninsert_in_hash:\r\nnew_ref->next = hdl->buckets[bucket];\r\nhdl->buckets[bucket] = new_ref;\r\nunlock:\r\nmutex_unlock(hdl->lock);\r\nreturn 0;\r\n}\r\nstatic struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, const char *name, enum v4l2_ctrl_type type,\r\ns32 min, s32 max, u32 step, s32 def,\r\nu32 flags, const char * const *qmenu,\r\nconst s64 *qmenu_int, void *priv)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nunsigned sz_extra = 0;\r\nif (hdl->error)\r\nreturn NULL;\r\nif (id == 0 || name == NULL || id >= V4L2_CID_PRIVATE_BASE ||\r\n(type == V4L2_CTRL_TYPE_INTEGER && step == 0) ||\r\n(type == V4L2_CTRL_TYPE_BITMASK && max == 0) ||\r\n(type == V4L2_CTRL_TYPE_MENU && qmenu == NULL) ||\r\n(type == V4L2_CTRL_TYPE_INTEGER_MENU && qmenu_int == NULL) ||\r\n(type == V4L2_CTRL_TYPE_STRING && max == 0)) {\r\nhandler_set_err(hdl, -ERANGE);\r\nreturn NULL;\r\n}\r\nif (type != V4L2_CTRL_TYPE_BITMASK && max < min) {\r\nhandler_set_err(hdl, -ERANGE);\r\nreturn NULL;\r\n}\r\nif ((type == V4L2_CTRL_TYPE_INTEGER ||\r\ntype == V4L2_CTRL_TYPE_MENU ||\r\ntype == V4L2_CTRL_TYPE_INTEGER_MENU ||\r\ntype == V4L2_CTRL_TYPE_BOOLEAN) &&\r\n(def < min || def > max)) {\r\nhandler_set_err(hdl, -ERANGE);\r\nreturn NULL;\r\n}\r\nif (type == V4L2_CTRL_TYPE_BITMASK && ((def & ~max) || min || step)) {\r\nhandler_set_err(hdl, -ERANGE);\r\nreturn NULL;\r\n}\r\nif (type == V4L2_CTRL_TYPE_BUTTON)\r\nflags |= V4L2_CTRL_FLAG_WRITE_ONLY;\r\nelse if (type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\nflags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nelse if (type == V4L2_CTRL_TYPE_STRING)\r\nsz_extra += 2 * (max + 1);\r\nctrl = kzalloc(sizeof(*ctrl) + sz_extra, GFP_KERNEL);\r\nif (ctrl == NULL) {\r\nhandler_set_err(hdl, -ENOMEM);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&ctrl->node);\r\nINIT_LIST_HEAD(&ctrl->ev_subs);\r\nctrl->handler = hdl;\r\nctrl->ops = ops;\r\nctrl->id = id;\r\nctrl->name = name;\r\nctrl->type = type;\r\nctrl->flags = flags;\r\nctrl->minimum = min;\r\nctrl->maximum = max;\r\nctrl->step = step;\r\nif (type == V4L2_CTRL_TYPE_MENU)\r\nctrl->qmenu = qmenu;\r\nelse if (type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nctrl->qmenu_int = qmenu_int;\r\nctrl->priv = priv;\r\nctrl->cur.val = ctrl->val = ctrl->default_value = def;\r\nif (ctrl->type == V4L2_CTRL_TYPE_STRING) {\r\nctrl->cur.string = (char *)&ctrl[1] + sz_extra - (max + 1);\r\nctrl->string = (char *)&ctrl[1] + sz_extra - 2 * (max + 1);\r\nif (ctrl->minimum)\r\nmemset(ctrl->cur.string, ' ', ctrl->minimum);\r\n}\r\nif (handler_new_ref(hdl, ctrl)) {\r\nkfree(ctrl);\r\nreturn NULL;\r\n}\r\nmutex_lock(hdl->lock);\r\nlist_add_tail(&ctrl->node, &hdl->ctrls);\r\nmutex_unlock(hdl->lock);\r\nreturn ctrl;\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_config *cfg, void *priv)\r\n{\r\nbool is_menu;\r\nstruct v4l2_ctrl *ctrl;\r\nconst char *name = cfg->name;\r\nconst char * const *qmenu = cfg->qmenu;\r\nconst s64 *qmenu_int = cfg->qmenu_int;\r\nenum v4l2_ctrl_type type = cfg->type;\r\nu32 flags = cfg->flags;\r\ns32 min = cfg->min;\r\ns32 max = cfg->max;\r\nu32 step = cfg->step;\r\ns32 def = cfg->def;\r\nif (name == NULL)\r\nv4l2_ctrl_fill(cfg->id, &name, &type, &min, &max, &step,\r\n&def, &flags);\r\nis_menu = (cfg->type == V4L2_CTRL_TYPE_MENU ||\r\ncfg->type == V4L2_CTRL_TYPE_INTEGER_MENU);\r\nif (is_menu)\r\nWARN_ON(step);\r\nelse\r\nWARN_ON(cfg->menu_skip_mask);\r\nif (cfg->type == V4L2_CTRL_TYPE_MENU && qmenu == NULL)\r\nqmenu = v4l2_ctrl_get_menu(cfg->id);\r\nelse if (cfg->type == V4L2_CTRL_TYPE_INTEGER_MENU &&\r\nqmenu_int == NULL) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nctrl = v4l2_ctrl_new(hdl, cfg->ops, cfg->id, name,\r\ntype, min, max,\r\nis_menu ? cfg->menu_skip_mask : step,\r\ndef, flags, qmenu, qmenu_int, priv);\r\nif (ctrl)\r\nctrl->is_private = cfg->is_private;\r\nreturn ctrl;\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, s32 min, s32 max, u32 step, s32 def)\r\n{\r\nconst char *name;\r\nenum v4l2_ctrl_type type;\r\nu32 flags;\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type == V4L2_CTRL_TYPE_MENU\r\n|| type == V4L2_CTRL_TYPE_INTEGER_MENU) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, id, name, type,\r\nmin, max, step, def, flags, NULL, NULL, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, s32 max, s32 mask, s32 def)\r\n{\r\nconst char * const *qmenu = v4l2_ctrl_get_menu(id);\r\nconst char *name;\r\nenum v4l2_ctrl_type type;\r\ns32 min;\r\ns32 step;\r\nu32 flags;\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type != V4L2_CTRL_TYPE_MENU) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, id, name, type,\r\n0, max, mask, def, flags, qmenu, NULL, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu_items(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops, u32 id, s32 max,\r\ns32 mask, s32 def, const char * const *qmenu)\r\n{\r\nenum v4l2_ctrl_type type;\r\nconst char *name;\r\nu32 flags;\r\ns32 step;\r\ns32 min;\r\nif (v4l2_ctrl_get_menu(id)) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type != V4L2_CTRL_TYPE_MENU || qmenu == NULL) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, id, name, type, 0, max, mask, def,\r\nflags, qmenu, NULL, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_int_menu(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, s32 max, s32 def, const s64 *qmenu_int)\r\n{\r\nconst char *name;\r\nenum v4l2_ctrl_type type;\r\ns32 min;\r\ns32 step;\r\nu32 flags;\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type != V4L2_CTRL_TYPE_INTEGER_MENU) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, id, name, type,\r\n0, max, 0, def, flags, NULL, qmenu_int, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_add_ctrl(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nif (hdl == NULL || hdl->error)\r\nreturn NULL;\r\nif (ctrl == NULL) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nif (ctrl->handler == hdl)\r\nreturn ctrl;\r\nreturn handler_new_ref(hdl, ctrl) ? NULL : ctrl;\r\n}\r\nint v4l2_ctrl_add_handler(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ctrl_handler *add,\r\nbool (*filter)(const struct v4l2_ctrl *ctrl))\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nint ret = 0;\r\nif (!hdl || !add || hdl == add)\r\nreturn 0;\r\nif (hdl->error)\r\nreturn hdl->error;\r\nmutex_lock(add->lock);\r\nlist_for_each_entry(ref, &add->ctrl_refs, node) {\r\nstruct v4l2_ctrl *ctrl = ref->ctrl;\r\nif (ctrl->is_private)\r\ncontinue;\r\nif (ctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\ncontinue;\r\nif (filter && !filter(ctrl))\r\ncontinue;\r\nret = handler_new_ref(hdl, ctrl);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(add->lock);\r\nreturn ret;\r\n}\r\nbool v4l2_ctrl_radio_filter(const struct v4l2_ctrl *ctrl)\r\n{\r\nif (V4L2_CTRL_ID2CLASS(ctrl->id) == V4L2_CTRL_CLASS_FM_TX)\r\nreturn true;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncase V4L2_CID_AUDIO_BALANCE:\r\ncase V4L2_CID_AUDIO_BASS:\r\ncase V4L2_CID_AUDIO_TREBLE:\r\ncase V4L2_CID_AUDIO_LOUDNESS:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nvoid v4l2_ctrl_cluster(unsigned ncontrols, struct v4l2_ctrl **controls)\r\n{\r\nbool has_volatiles = false;\r\nint i;\r\nBUG_ON(ncontrols == 0 || controls[0] == NULL);\r\nfor (i = 0; i < ncontrols; i++) {\r\nif (controls[i]) {\r\ncontrols[i]->cluster = controls;\r\ncontrols[i]->ncontrols = ncontrols;\r\nif (controls[i]->flags & V4L2_CTRL_FLAG_VOLATILE)\r\nhas_volatiles = true;\r\n}\r\n}\r\ncontrols[0]->has_volatiles = has_volatiles;\r\n}\r\nvoid v4l2_ctrl_auto_cluster(unsigned ncontrols, struct v4l2_ctrl **controls,\r\nu8 manual_val, bool set_volatile)\r\n{\r\nstruct v4l2_ctrl *master = controls[0];\r\nu32 flag = 0;\r\nint i;\r\nv4l2_ctrl_cluster(ncontrols, controls);\r\nWARN_ON(ncontrols <= 1);\r\nWARN_ON(manual_val < master->minimum || manual_val > master->maximum);\r\nWARN_ON(set_volatile && !has_op(master, g_volatile_ctrl));\r\nmaster->is_auto = true;\r\nmaster->has_volatiles = set_volatile;\r\nmaster->manual_mode_value = manual_val;\r\nmaster->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nif (!is_cur_manual(master))\r\nflag = V4L2_CTRL_FLAG_INACTIVE |\r\n(set_volatile ? V4L2_CTRL_FLAG_VOLATILE : 0);\r\nfor (i = 1; i < ncontrols; i++)\r\nif (controls[i])\r\ncontrols[i]->flags |= flag;\r\n}\r\nvoid v4l2_ctrl_activate(struct v4l2_ctrl *ctrl, bool active)\r\n{\r\nbool inactive = !active;\r\nbool old;\r\nif (ctrl == NULL)\r\nreturn;\r\nif (inactive)\r\nold = test_and_set_bit(4, &ctrl->flags);\r\nelse\r\nold = test_and_clear_bit(4, &ctrl->flags);\r\nif (old != inactive)\r\nsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_FLAGS);\r\n}\r\nvoid v4l2_ctrl_grab(struct v4l2_ctrl *ctrl, bool grabbed)\r\n{\r\nbool old;\r\nif (ctrl == NULL)\r\nreturn;\r\nv4l2_ctrl_lock(ctrl);\r\nif (grabbed)\r\nold = test_and_set_bit(1, &ctrl->flags);\r\nelse\r\nold = test_and_clear_bit(1, &ctrl->flags);\r\nif (old != grabbed)\r\nsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_FLAGS);\r\nv4l2_ctrl_unlock(ctrl);\r\n}\r\nstatic void log_ctrl(const struct v4l2_ctrl *ctrl,\r\nconst char *prefix, const char *colon)\r\n{\r\nif (ctrl->flags & (V4L2_CTRL_FLAG_DISABLED | V4L2_CTRL_FLAG_WRITE_ONLY))\r\nreturn;\r\nif (ctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\nreturn;\r\nprintk(KERN_INFO "%s%s%s: ", prefix, colon, ctrl->name);\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nprintk(KERN_CONT "%d", ctrl->cur.val);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nprintk(KERN_CONT "%s", ctrl->cur.val ? "true" : "false");\r\nbreak;\r\ncase V4L2_CTRL_TYPE_MENU:\r\nprintk(KERN_CONT "%s", ctrl->qmenu[ctrl->cur.val]);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\nprintk(KERN_CONT "%lld", ctrl->qmenu_int[ctrl->cur.val]);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\nprintk(KERN_CONT "0x%08x", ctrl->cur.val);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nprintk(KERN_CONT "%lld", ctrl->cur.val64);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nprintk(KERN_CONT "%s", ctrl->cur.string);\r\nbreak;\r\ndefault:\r\nprintk(KERN_CONT "unknown type %d", ctrl->type);\r\nbreak;\r\n}\r\nif (ctrl->flags & (V4L2_CTRL_FLAG_INACTIVE |\r\nV4L2_CTRL_FLAG_GRABBED |\r\nV4L2_CTRL_FLAG_VOLATILE)) {\r\nif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\r\nprintk(KERN_CONT " inactive");\r\nif (ctrl->flags & V4L2_CTRL_FLAG_GRABBED)\r\nprintk(KERN_CONT " grabbed");\r\nif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE)\r\nprintk(KERN_CONT " volatile");\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nvoid v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler *hdl,\r\nconst char *prefix)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nconst char *colon = "";\r\nint len;\r\nif (hdl == NULL)\r\nreturn;\r\nif (prefix == NULL)\r\nprefix = "";\r\nlen = strlen(prefix);\r\nif (len && prefix[len - 1] != ' ')\r\ncolon = ": ";\r\nmutex_lock(hdl->lock);\r\nlist_for_each_entry(ctrl, &hdl->ctrls, node)\r\nif (!(ctrl->flags & V4L2_CTRL_FLAG_DISABLED))\r\nlog_ctrl(ctrl, prefix, colon);\r\nmutex_unlock(hdl->lock);\r\n}\r\nint v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nint ret = 0;\r\nif (hdl == NULL)\r\nreturn 0;\r\nmutex_lock(hdl->lock);\r\nlist_for_each_entry(ctrl, &hdl->ctrls, node)\r\nctrl->done = false;\r\nlist_for_each_entry(ctrl, &hdl->ctrls, node) {\r\nstruct v4l2_ctrl *master = ctrl->cluster[0];\r\nint i;\r\nif (ctrl->done || ctrl->type == V4L2_CTRL_TYPE_BUTTON ||\r\n(ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY))\r\ncontinue;\r\nfor (i = 0; i < master->ncontrols; i++) {\r\nif (master->cluster[i]) {\r\ncur_to_new(master->cluster[i]);\r\nmaster->cluster[i]->is_new = 1;\r\nmaster->cluster[i]->done = true;\r\n}\r\n}\r\nret = call_op(master, s_ctrl);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(hdl->lock);\r\nreturn ret;\r\n}\r\nint v4l2_queryctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_queryctrl *qc)\r\n{\r\nu32 id = qc->id & V4L2_CTRL_ID_MASK;\r\nstruct v4l2_ctrl_ref *ref;\r\nstruct v4l2_ctrl *ctrl;\r\nif (hdl == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(hdl->lock);\r\nref = find_ref(hdl, id);\r\nif ((qc->id & V4L2_CTRL_FLAG_NEXT_CTRL) && !list_empty(&hdl->ctrl_refs)) {\r\nif (id >= node2id(hdl->ctrl_refs.prev)) {\r\nref = NULL;\r\n} else if (ref) {\r\nref = list_entry(ref->node.next, typeof(*ref), node);\r\n} else {\r\nlist_for_each_entry(ref, &hdl->ctrl_refs, node)\r\nif (id < ref->ctrl->id)\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(hdl->lock);\r\nif (!ref)\r\nreturn -EINVAL;\r\nctrl = ref->ctrl;\r\nmemset(qc, 0, sizeof(*qc));\r\nif (id >= V4L2_CID_PRIVATE_BASE)\r\nqc->id = id;\r\nelse\r\nqc->id = ctrl->id;\r\nstrlcpy(qc->name, ctrl->name, sizeof(qc->name));\r\nqc->minimum = ctrl->minimum;\r\nqc->maximum = ctrl->maximum;\r\nqc->default_value = ctrl->default_value;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU\r\n|| ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nqc->step = 1;\r\nelse\r\nqc->step = ctrl->step;\r\nqc->flags = ctrl->flags;\r\nqc->type = ctrl->type;\r\nreturn 0;\r\n}\r\nint v4l2_subdev_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)\r\n{\r\nif (qc->id & V4L2_CTRL_FLAG_NEXT_CTRL)\r\nreturn -EINVAL;\r\nreturn v4l2_queryctrl(sd->ctrl_handler, qc);\r\n}\r\nint v4l2_querymenu(struct v4l2_ctrl_handler *hdl, struct v4l2_querymenu *qm)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nu32 i = qm->index;\r\nctrl = v4l2_ctrl_find(hdl, qm->id);\r\nif (!ctrl)\r\nreturn -EINVAL;\r\nqm->reserved = 0;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_MENU:\r\nif (ctrl->qmenu == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\nif (ctrl->qmenu_int == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (i < ctrl->minimum || i > ctrl->maximum)\r\nreturn -EINVAL;\r\nif (ctrl->menu_skip_mask & (1 << i))\r\nreturn -EINVAL;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU) {\r\nif (ctrl->qmenu[i] == NULL || ctrl->qmenu[i][0] == '\0')\r\nreturn -EINVAL;\r\nstrlcpy(qm->name, ctrl->qmenu[i], sizeof(qm->name));\r\n} else {\r\nqm->value = ctrl->qmenu_int[i];\r\n}\r\nreturn 0;\r\n}\r\nint v4l2_subdev_querymenu(struct v4l2_subdev *sd, struct v4l2_querymenu *qm)\r\n{\r\nreturn v4l2_querymenu(sd->ctrl_handler, qm);\r\n}\r\nstatic int prepare_ext_ctrls(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ext_controls *cs,\r\nstruct v4l2_ctrl_helper *helpers)\r\n{\r\nstruct v4l2_ctrl_helper *h;\r\nbool have_clusters = false;\r\nu32 i;\r\nfor (i = 0, h = helpers; i < cs->count; i++, h++) {\r\nstruct v4l2_ext_control *c = &cs->controls[i];\r\nstruct v4l2_ctrl_ref *ref;\r\nstruct v4l2_ctrl *ctrl;\r\nu32 id = c->id & V4L2_CTRL_ID_MASK;\r\ncs->error_idx = i;\r\nif (cs->ctrl_class && V4L2_CTRL_ID2CLASS(id) != cs->ctrl_class)\r\nreturn -EINVAL;\r\nif (id >= V4L2_CID_PRIVATE_BASE)\r\nreturn -EINVAL;\r\nref = find_ref_lock(hdl, id);\r\nif (ref == NULL)\r\nreturn -EINVAL;\r\nctrl = ref->ctrl;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_DISABLED)\r\nreturn -EINVAL;\r\nif (ctrl->cluster[0]->ncontrols > 1)\r\nhave_clusters = true;\r\nif (ctrl->cluster[0] != ctrl)\r\nref = find_ref_lock(hdl, ctrl->cluster[0]->id);\r\nh->mref = ref;\r\nh->ctrl = ctrl;\r\nh->next = 0;\r\n}\r\nif (!have_clusters)\r\nreturn 0;\r\nmutex_lock(hdl->lock);\r\nfor (i = 0; i < cs->count; i++)\r\nhelpers[i].mref->helper = NULL;\r\nfor (i = 0, h = helpers; i < cs->count; i++, h++) {\r\nstruct v4l2_ctrl_ref *mref = h->mref;\r\nif (mref->helper) {\r\nmref->helper->next = i;\r\nh->mref = NULL;\r\n}\r\nmref->helper = h;\r\n}\r\nmutex_unlock(hdl->lock);\r\nreturn 0;\r\n}\r\nstatic int class_check(struct v4l2_ctrl_handler *hdl, u32 ctrl_class)\r\n{\r\nif (ctrl_class == 0)\r\nreturn list_empty(&hdl->ctrl_refs) ? -EINVAL : 0;\r\nreturn find_ref_lock(hdl, ctrl_class | 1) ? 0 : -EINVAL;\r\n}\r\nint v4l2_g_ext_ctrls(struct v4l2_ctrl_handler *hdl, struct v4l2_ext_controls *cs)\r\n{\r\nstruct v4l2_ctrl_helper helper[4];\r\nstruct v4l2_ctrl_helper *helpers = helper;\r\nint ret;\r\nint i, j;\r\ncs->error_idx = cs->count;\r\ncs->ctrl_class = V4L2_CTRL_ID2CLASS(cs->ctrl_class);\r\nif (hdl == NULL)\r\nreturn -EINVAL;\r\nif (cs->count == 0)\r\nreturn class_check(hdl, cs->ctrl_class);\r\nif (cs->count > ARRAY_SIZE(helper)) {\r\nhelpers = kmalloc_array(cs->count, sizeof(helper[0]),\r\nGFP_KERNEL);\r\nif (helpers == NULL)\r\nreturn -ENOMEM;\r\n}\r\nret = prepare_ext_ctrls(hdl, cs, helpers);\r\ncs->error_idx = cs->count;\r\nfor (i = 0; !ret && i < cs->count; i++)\r\nif (helpers[i].ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY)\r\nret = -EACCES;\r\nfor (i = 0; !ret && i < cs->count; i++) {\r\nint (*ctrl_to_user)(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl) = cur_to_user;\r\nstruct v4l2_ctrl *master;\r\nif (helpers[i].mref == NULL)\r\ncontinue;\r\nmaster = helpers[i].mref->ctrl;\r\ncs->error_idx = i;\r\nv4l2_ctrl_lock(master);\r\nif ((master->flags & V4L2_CTRL_FLAG_VOLATILE) ||\r\n(master->has_volatiles && !is_cur_manual(master))) {\r\nfor (j = 0; j < master->ncontrols; j++)\r\ncur_to_new(master->cluster[j]);\r\nret = call_op(master, g_volatile_ctrl);\r\nctrl_to_user = new_to_user;\r\n}\r\nif (!ret) {\r\nu32 idx = i;\r\ndo {\r\nret = ctrl_to_user(cs->controls + idx,\r\nhelpers[idx].ctrl);\r\nidx = helpers[idx].next;\r\n} while (!ret && idx);\r\n}\r\nv4l2_ctrl_unlock(master);\r\n}\r\nif (cs->count > ARRAY_SIZE(helper))\r\nkfree(helpers);\r\nreturn ret;\r\n}\r\nint v4l2_subdev_g_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *cs)\r\n{\r\nreturn v4l2_g_ext_ctrls(sd->ctrl_handler, cs);\r\n}\r\nstatic int get_ctrl(struct v4l2_ctrl *ctrl, struct v4l2_ext_control *c)\r\n{\r\nstruct v4l2_ctrl *master = ctrl->cluster[0];\r\nint ret = 0;\r\nint i;\r\nif (ctrl->type == V4L2_CTRL_TYPE_STRING)\r\nreturn -EINVAL;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY)\r\nreturn -EACCES;\r\nv4l2_ctrl_lock(master);\r\nif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {\r\nfor (i = 0; i < master->ncontrols; i++)\r\ncur_to_new(master->cluster[i]);\r\nret = call_op(master, g_volatile_ctrl);\r\nnew_to_user(c, ctrl);\r\n} else {\r\ncur_to_user(c, ctrl);\r\n}\r\nv4l2_ctrl_unlock(master);\r\nreturn ret;\r\n}\r\nint v4l2_g_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_control *control)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, control->id);\r\nstruct v4l2_ext_control c;\r\nint ret;\r\nif (ctrl == NULL || !type_is_int(ctrl))\r\nreturn -EINVAL;\r\nret = get_ctrl(ctrl, &c);\r\ncontrol->value = c.value;\r\nreturn ret;\r\n}\r\nint v4l2_subdev_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)\r\n{\r\nreturn v4l2_g_ctrl(sd->ctrl_handler, control);\r\n}\r\ns32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_ext_control c;\r\nWARN_ON(!type_is_int(ctrl));\r\nc.value = 0;\r\nget_ctrl(ctrl, &c);\r\nreturn c.value;\r\n}\r\ns64 v4l2_ctrl_g_ctrl_int64(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_ext_control c;\r\nWARN_ON(ctrl->type != V4L2_CTRL_TYPE_INTEGER64);\r\nc.value = 0;\r\nget_ctrl(ctrl, &c);\r\nreturn c.value;\r\n}\r\nstatic int try_or_set_cluster(struct v4l2_fh *fh,\r\nstruct v4l2_ctrl *master, bool set)\r\n{\r\nbool update_flag;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < master->ncontrols; i++) {\r\nstruct v4l2_ctrl *ctrl = master->cluster[i];\r\nif (ctrl == NULL)\r\ncontinue;\r\nif (!ctrl->is_new) {\r\ncur_to_new(ctrl);\r\ncontinue;\r\n}\r\nif (set && (ctrl->flags & V4L2_CTRL_FLAG_GRABBED))\r\nreturn -EBUSY;\r\n}\r\nret = call_op(master, try_ctrl);\r\nif (ret || !set || !cluster_changed(master))\r\nreturn ret;\r\nret = call_op(master, s_ctrl);\r\nif (ret)\r\nreturn ret;\r\nupdate_flag = is_cur_manual(master) != is_new_manual(master);\r\nfor (i = 0; i < master->ncontrols; i++)\r\nnew_to_cur(fh, master->cluster[i], update_flag && i > 0);\r\nreturn 0;\r\n}\r\nstatic int validate_ctrls(struct v4l2_ext_controls *cs,\r\nstruct v4l2_ctrl_helper *helpers, bool set)\r\n{\r\nunsigned i;\r\nint ret = 0;\r\ncs->error_idx = cs->count;\r\nfor (i = 0; i < cs->count; i++) {\r\nstruct v4l2_ctrl *ctrl = helpers[i].ctrl;\r\ncs->error_idx = i;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY)\r\nreturn -EACCES;\r\nif (set && (ctrl->flags & V4L2_CTRL_FLAG_GRABBED))\r\nreturn -EBUSY;\r\nret = validate_new(ctrl, &cs->controls[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_from_auto_cluster(struct v4l2_ctrl *master)\r\n{\r\nint i;\r\nfor (i = 0; i < master->ncontrols; i++)\r\ncur_to_new(master->cluster[i]);\r\nif (!call_op(master, g_volatile_ctrl))\r\nfor (i = 1; i < master->ncontrols; i++)\r\nif (master->cluster[i])\r\nmaster->cluster[i]->is_new = 1;\r\n}\r\nstatic int try_set_ext_ctrls(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ext_controls *cs,\r\nbool set)\r\n{\r\nstruct v4l2_ctrl_helper helper[4];\r\nstruct v4l2_ctrl_helper *helpers = helper;\r\nunsigned i, j;\r\nint ret;\r\ncs->error_idx = cs->count;\r\ncs->ctrl_class = V4L2_CTRL_ID2CLASS(cs->ctrl_class);\r\nif (hdl == NULL)\r\nreturn -EINVAL;\r\nif (cs->count == 0)\r\nreturn class_check(hdl, cs->ctrl_class);\r\nif (cs->count > ARRAY_SIZE(helper)) {\r\nhelpers = kmalloc_array(cs->count, sizeof(helper[0]),\r\nGFP_KERNEL);\r\nif (!helpers)\r\nreturn -ENOMEM;\r\n}\r\nret = prepare_ext_ctrls(hdl, cs, helpers);\r\nif (!ret)\r\nret = validate_ctrls(cs, helpers, set);\r\nif (ret && set)\r\ncs->error_idx = cs->count;\r\nfor (i = 0; !ret && i < cs->count; i++) {\r\nstruct v4l2_ctrl *master;\r\nu32 idx = i;\r\nif (helpers[i].mref == NULL)\r\ncontinue;\r\ncs->error_idx = i;\r\nmaster = helpers[i].mref->ctrl;\r\nv4l2_ctrl_lock(master);\r\nfor (j = 0; j < master->ncontrols; j++)\r\nif (master->cluster[j])\r\nmaster->cluster[j]->is_new = 0;\r\nif (master->is_auto && master->has_volatiles &&\r\n!is_cur_manual(master)) {\r\ns32 new_auto_val = master->manual_mode_value + 1;\r\nu32 tmp_idx = idx;\r\ndo {\r\nif (helpers[tmp_idx].ctrl == master)\r\nnew_auto_val = cs->controls[tmp_idx].value;\r\ntmp_idx = helpers[tmp_idx].next;\r\n} while (tmp_idx);\r\nif (new_auto_val == master->manual_mode_value)\r\nupdate_from_auto_cluster(master);\r\n}\r\ndo {\r\nret = user_to_new(cs->controls + idx, helpers[idx].ctrl);\r\nidx = helpers[idx].next;\r\n} while (!ret && idx);\r\nif (!ret)\r\nret = try_or_set_cluster(fh, master, set);\r\nif (!ret) {\r\nidx = i;\r\ndo {\r\nret = new_to_user(cs->controls + idx,\r\nhelpers[idx].ctrl);\r\nidx = helpers[idx].next;\r\n} while (!ret && idx);\r\n}\r\nv4l2_ctrl_unlock(master);\r\n}\r\nif (cs->count > ARRAY_SIZE(helper))\r\nkfree(helpers);\r\nreturn ret;\r\n}\r\nint v4l2_try_ext_ctrls(struct v4l2_ctrl_handler *hdl, struct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(NULL, hdl, cs, false);\r\n}\r\nint v4l2_s_ext_ctrls(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(fh, hdl, cs, true);\r\n}\r\nint v4l2_subdev_try_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(NULL, sd->ctrl_handler, cs, false);\r\n}\r\nint v4l2_subdev_s_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(NULL, sd->ctrl_handler, cs, true);\r\n}\r\nstatic int set_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl,\r\nstruct v4l2_ext_control *c)\r\n{\r\nstruct v4l2_ctrl *master = ctrl->cluster[0];\r\nint ret;\r\nint i;\r\nif (ctrl->type == V4L2_CTRL_TYPE_STRING)\r\nreturn -EINVAL;\r\nret = validate_new(ctrl, c);\r\nif (ret)\r\nreturn ret;\r\nv4l2_ctrl_lock(ctrl);\r\nfor (i = 0; i < master->ncontrols; i++)\r\nif (master->cluster[i])\r\nmaster->cluster[i]->is_new = 0;\r\nif (master->is_auto && master->has_volatiles && ctrl == master &&\r\n!is_cur_manual(master) && c->value == master->manual_mode_value)\r\nupdate_from_auto_cluster(master);\r\nuser_to_new(c, ctrl);\r\nret = try_or_set_cluster(fh, master, true);\r\ncur_to_user(c, ctrl);\r\nv4l2_ctrl_unlock(ctrl);\r\nreturn ret;\r\n}\r\nint v4l2_s_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_control *control)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, control->id);\r\nstruct v4l2_ext_control c;\r\nint ret;\r\nif (ctrl == NULL || !type_is_int(ctrl))\r\nreturn -EINVAL;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY)\r\nreturn -EACCES;\r\nc.value = control->value;\r\nret = set_ctrl(fh, ctrl, &c);\r\ncontrol->value = c.value;\r\nreturn ret;\r\n}\r\nint v4l2_subdev_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)\r\n{\r\nreturn v4l2_s_ctrl(NULL, sd->ctrl_handler, control);\r\n}\r\nint v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)\r\n{\r\nstruct v4l2_ext_control c;\r\nWARN_ON(!type_is_int(ctrl));\r\nc.value = val;\r\nreturn set_ctrl(NULL, ctrl, &c);\r\n}\r\nint v4l2_ctrl_s_ctrl_int64(struct v4l2_ctrl *ctrl, s64 val)\r\n{\r\nstruct v4l2_ext_control c;\r\nWARN_ON(ctrl->type != V4L2_CTRL_TYPE_INTEGER64);\r\nc.value64 = val;\r\nreturn set_ctrl(NULL, ctrl, &c);\r\n}\r\nstatic int v4l2_ctrl_add_event(struct v4l2_subscribed_event *sev, unsigned elems)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(sev->fh->ctrl_handler, sev->id);\r\nif (ctrl == NULL)\r\nreturn -EINVAL;\r\nv4l2_ctrl_lock(ctrl);\r\nlist_add_tail(&sev->node, &ctrl->ev_subs);\r\nif (ctrl->type != V4L2_CTRL_TYPE_CTRL_CLASS &&\r\n(sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL)) {\r\nstruct v4l2_event ev;\r\nu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\r\nif (!(ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY))\r\nchanges |= V4L2_EVENT_CTRL_CH_VALUE;\r\nfill_event(&ev, ctrl, changes);\r\nsev->elems = elems;\r\nv4l2_event_queue_fh(sev->fh, &ev);\r\n}\r\nv4l2_ctrl_unlock(ctrl);\r\nreturn 0;\r\n}\r\nstatic void v4l2_ctrl_del_event(struct v4l2_subscribed_event *sev)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(sev->fh->ctrl_handler, sev->id);\r\nv4l2_ctrl_lock(ctrl);\r\nlist_del(&sev->node);\r\nv4l2_ctrl_unlock(ctrl);\r\n}\r\nvoid v4l2_ctrl_replace(struct v4l2_event *old, const struct v4l2_event *new)\r\n{\r\nu32 old_changes = old->u.ctrl.changes;\r\nold->u.ctrl = new->u.ctrl;\r\nold->u.ctrl.changes |= old_changes;\r\n}\r\nvoid v4l2_ctrl_merge(const struct v4l2_event *old, struct v4l2_event *new)\r\n{\r\nnew->u.ctrl.changes |= old->u.ctrl.changes;\r\n}\r\nint v4l2_ctrl_log_status(struct file *file, void *fh)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_fh *vfh = file->private_data;\r\nif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) && vfd->v4l2_dev)\r\nv4l2_ctrl_handler_log_status(vfh->ctrl_handler,\r\nvfd->v4l2_dev->name);\r\nreturn 0;\r\n}\r\nint v4l2_ctrl_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nif (sub->type == V4L2_EVENT_CTRL)\r\nreturn v4l2_event_subscribe(fh, sub, 0, &v4l2_ctrl_sub_ev_ops);\r\nreturn -EINVAL;\r\n}\r\nunsigned int v4l2_ctrl_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct v4l2_fh *fh = file->private_data;\r\nif (v4l2_event_pending(fh))\r\nreturn POLLPRI;\r\npoll_wait(file, &fh->wait, wait);\r\nreturn 0;\r\n}
