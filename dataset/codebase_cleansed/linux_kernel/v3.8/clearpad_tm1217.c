static int cp_tm1217_read(struct cp_tm1217_device *ts,\r\nu8 *req, int size)\r\n{\r\nint i, retval;\r\nretval = i2c_master_send(ts->client, &req[0], 1);\r\nif (retval != 1) {\r\ndev_err(ts->dev, "cp_tm1217: I2C send failed\n");\r\nreturn retval;\r\n}\r\nmsleep(WAIT_FOR_RESPONSE);\r\nfor (i = 0; i < MAX_RETRIES; i++) {\r\nretval = i2c_master_recv(ts->client, &req[1], size);\r\nif (retval == size) {\r\nbreak;\r\n} else {\r\nmsleep(INCREMENTAL_DELAY);\r\ndev_dbg(ts->dev, "cp_tm1217: Retry count is %d\n", i);\r\n}\r\n}\r\nif (retval != size)\r\ndev_err(ts->dev, "cp_tm1217: Read from device failed\n");\r\nreturn retval;\r\n}\r\nstatic int cp_tm1217_write(struct cp_tm1217_device *ts,\r\nu8 *req, int size)\r\n{\r\nint retval;\r\nretval = i2c_master_send(ts->client, &req[0], size + 1);\r\nif (retval != size + 1) {\r\ndev_err(ts->dev, "cp_tm1217: I2C write failed: %d\n", retval);\r\nreturn retval;\r\n}\r\nmsleep(WAIT_FOR_RESPONSE);\r\nreturn size;\r\n}\r\nstatic int cp_tm1217_mask_interrupt(struct cp_tm1217_device *ts)\r\n{\r\nu8 req[2];\r\nint retval;\r\nreq[0] = TMA1217_INTERRUPT_ENABLE;\r\nreq[1] = 0x0;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nif (retval != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int cp_tm1217_unmask_interrupt(struct cp_tm1217_device *ts)\r\n{\r\nu8 req[2];\r\nint retval;\r\nreq[0] = TMA1217_INTERRUPT_ENABLE;\r\nreq[1] = 0xa;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nif (retval != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void process_touch(struct cp_tm1217_device *ts, int index)\r\n{\r\nint retval;\r\nstruct input_dev_info *input_info =\r\n(struct input_dev_info *)&ts->cp_input_info[index];\r\nu8 xy_data[6];\r\nif (index == 0)\r\nxy_data[0] = TMA1217_FINGER1_X_HIGHER8;\r\nelse\r\nxy_data[0] = TMA1217_FINGER2_X_HIGHER8;\r\nretval = cp_tm1217_read(ts, xy_data, 5);\r\nif (retval < 5) {\r\ndev_err(ts->dev, "cp_tm1217: XY read from device failed\n");\r\nreturn;\r\n}\r\ninput_info->touch.x = (xy_data[1] << 4)\r\n| (xy_data[3] & 0x0F);\r\ninput_info->touch.y = (xy_data[2] << 4)\r\n| ((xy_data[3] & 0xF0) >> 4);\r\ninput_report_abs(input_info->input, ABS_X, input_info->touch.x);\r\ninput_report_abs(input_info->input, ABS_Y, input_info->touch.y);\r\ninput_sync(input_info->input);\r\n}\r\nstatic void cp_tm1217_get_data(struct cp_tm1217_device *ts)\r\n{\r\nu8 req[2];\r\nint retval, i, finger_touched = 0;\r\ndo {\r\nreq[0] = TMA1217_FINGER_STATE;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nif (retval != 1) {\r\ndev_err(ts->dev,\r\n"cp_tm1217: Read from device failed\n");\r\ncontinue;\r\n}\r\nfinger_touched = 0;\r\nfor (i = 0; i < TOUCH_SUPPORTED; i++) {\r\nif (req[1] & 0x3) {\r\nfinger_touched++;\r\nif (ts->cp_input_info[i].touch.button == 0) {\r\ninput_report_key(\r\nts->cp_input_info[i].input,\r\nBTN_TOUCH, 1);\r\nts->cp_input_info[i].touch.button = 1;\r\n}\r\nprocess_touch(ts, i);\r\n} else {\r\nif (ts->cp_input_info[i].touch.button == 1) {\r\ninput_report_key(\r\nts->cp_input_info[i].input,\r\nBTN_TOUCH, 0);\r\ninput_sync(ts->cp_input_info[i].input);\r\nts->cp_input_info[i].touch.button = 0;\r\n}\r\n}\r\nreq[1] = req[1] >> 2;\r\n}\r\nmsleep(DELAY_BTWIN_SAMPLE);\r\n} while (finger_touched > 0);\r\n}\r\nstatic irqreturn_t cp_tm1217_sample_thread(int irq, void *handle)\r\n{\r\nstruct cp_tm1217_device *ts = (struct cp_tm1217_device *) handle;\r\nu8 req[2];\r\nint retval;\r\nmutex_lock(&ts->thread_mutex);\r\nif (ts->thread_running == 1) {\r\nmutex_unlock(&ts->thread_mutex);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nts->thread_running = 1;\r\nmutex_unlock(&ts->thread_mutex);\r\n}\r\nretval = cp_tm1217_mask_interrupt(ts);\r\nreq[0] = TMA1217_INT_STATUS;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nif (retval != 1)\r\ngoto exit_thread;\r\nif (!(req[1] & 0x8))\r\ngoto exit_thread;\r\ncp_tm1217_get_data(ts);\r\nexit_thread:\r\nretval = cp_tm1217_unmask_interrupt(ts);\r\nmutex_lock(&ts->thread_mutex);\r\nts->thread_running = 0;\r\nmutex_unlock(&ts->thread_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cp_tm1217_init_data(struct cp_tm1217_device *ts)\r\n{\r\nint retval;\r\nu8 req[2];\r\nreq[0] = TMA1217_MANUFACTURER_ID;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->vinfo.vendor_id = req[1];\r\nreq[0] = TMA1217_PRODUCT_FAMILY;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->vinfo.product_family = req[1];\r\nreq[0] = TMA1217_FIRMWARE_REVISION;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->vinfo.firmware_rev = req[1];\r\nreq[0] = TMA1217_SERIAL_NO_HIGH;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->vinfo.serial_no = (req[1] << 8);\r\nreq[0] = TMA1217_SERIAL_NO_LOW;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->vinfo.serial_no = ts->vinfo.serial_no | req[1];\r\nreq[0] = TMA1217_MAX_X_HIGHER4;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->dinfo.maxX = (req[1] & 0xF) << 8;\r\nreq[0] = TMA1217_MAX_X_LOWER8;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->dinfo.maxX = ts->dinfo.maxX | req[1];\r\nreq[0] = TMA1217_MAX_Y_HIGHER4;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->dinfo.maxY = (req[1] & 0xF) << 8;\r\nreq[0] = TMA1217_MAX_Y_LOWER8;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nts->dinfo.maxY = ts->dinfo.maxY | req[1];\r\nreturn 0;\r\n}\r\nstatic int cp_tm1217_setup_gpio_irq(struct cp_tm1217_device *ts)\r\n{\r\nint retval;\r\nretval = gpio_request(ts->gpio, "cp_tm1217_touch");\r\nif (retval < 0) {\r\ndev_err(ts->dev, "cp_tm1217: GPIO request failed error %d\n",\r\nretval);\r\nreturn retval;\r\n}\r\nretval = gpio_direction_input(ts->gpio);\r\nif (retval < 0) {\r\ndev_err(ts->dev,\r\n"cp_tm1217: GPIO direction configuration failed, error %d\n",\r\nretval);\r\ngpio_free(ts->gpio);\r\nreturn retval;\r\n}\r\nretval = gpio_to_irq(ts->gpio);\r\nif (retval < 0) {\r\ndev_err(ts->dev,\r\n"cp_tm1217: GPIO to IRQ failed, error %d\n", retval);\r\ngpio_free(ts->gpio);\r\n}\r\ndev_dbg(ts->dev,\r\n"cp_tm1217: Got IRQ number is %d for GPIO %d\n",\r\nretval, ts->gpio);\r\nreturn retval;\r\n}\r\nstatic int cp_tm1217_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cp_tm1217_device *ts;\r\nstruct input_dev *input_dev;\r\nstruct input_dev_info *input_info;\r\nstruct cp_tm1217_platform_data *pdata;\r\nu8 req[2];\r\nint i, retval;\r\npdata = client->dev.platform_data;\r\nts = kzalloc(sizeof(struct cp_tm1217_device), GFP_KERNEL);\r\nif (!ts) {\r\ndev_err(&client->dev,\r\n"cp_tm1217: Private Device Struct alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nts->client = client;\r\nts->dev = &client->dev;\r\ni2c_set_clientdata(client, ts);\r\nts->thread_running = 0;\r\nmutex_init(&ts->thread_mutex);\r\nreq[0] = TMA1217_DEVICE_CMD_RESET;\r\nreq[1] = 0x1;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nif (retval != 1) {\r\ndev_err(ts->dev, "cp_tm1217: Controller reset failed\n");\r\nkfree(ts);\r\nreturn -EIO;\r\n}\r\nreq[0] = TMA1217_INT_STATUS;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nretval = cp_tm1217_mask_interrupt(ts);\r\ncp_tm1217_init_data(ts);\r\nfor (i = 0; i < TOUCH_SUPPORTED; i++) {\r\ninput_dev = input_allocate_device();\r\nif (input_dev == NULL) {\r\ndev_err(ts->dev,\r\n"cp_tm1217:Input Device Struct alloc failed\n");\r\nretval = -ENOMEM;\r\ngoto fail;\r\n}\r\ninput_info = &ts->cp_input_info[i];\r\nsnprintf(input_info->name, sizeof(input_info->name),\r\n"cp_tm1217_touchscreen_%d", i);\r\ninput_dev->name = input_info->name;\r\nsnprintf(input_info->phys, sizeof(input_info->phys),\r\n"%s/input%d", dev_name(&client->dev), i);\r\ninput_dev->phys = input_info->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, ts->dinfo.maxX, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, ts->dinfo.maxY, 0, 0);\r\nretval = input_register_device(input_dev);\r\nif (retval) {\r\ndev_err(ts->dev,\r\n"Input dev registration failed for %s\n",\r\ninput_dev->name);\r\ninput_free_device(input_dev);\r\ngoto fail;\r\n}\r\ninput_info->input = input_dev;\r\n}\r\nreq[0] = TMA1217_REPORT_MODE;\r\nreq[1] = 0x02;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nreq[0] = TMA1217_DEVICE_CTRL;\r\nreq[1] = 0x84;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nreq[0] = TMA1217_DEV_STATUS;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nif (req[1] != 0) {\r\ndev_err(ts->dev,\r\n"cp_tm1217: Device Status 0x%x != 0: config failed\n",\r\nreq[1]);\r\nretval = -EIO;\r\ngoto fail;\r\n}\r\nif (pdata && pdata->gpio) {\r\nts->gpio = pdata->gpio;\r\nretval = cp_tm1217_setup_gpio_irq(ts);\r\n} else\r\nretval = client->irq;\r\nif (retval < 0) {\r\ndev_err(ts->dev, "cp_tm1217: GPIO request failed error %d\n",\r\nretval);\r\ngoto fail;\r\n}\r\nclient->irq = retval;\r\nretval = request_threaded_irq(client->irq,\r\nNULL, cp_tm1217_sample_thread,\r\nIRQF_TRIGGER_FALLING, "cp_tm1217_touch", ts);\r\nif (retval < 0) {\r\ndev_err(ts->dev, "cp_tm1217: Request IRQ error %d\n", retval);\r\ngoto fail_gpio;\r\n}\r\nretval = cp_tm1217_unmask_interrupt(ts);\r\nif (retval == 0)\r\nreturn 0;\r\nfree_irq(client->irq, ts);\r\nfail_gpio:\r\nif (ts->gpio)\r\ngpio_free(ts->gpio);\r\nfail:\r\nfor (i = 0; i < TOUCH_SUPPORTED; i++) {\r\nif (ts->cp_input_info[i].input) {\r\ninput_unregister_device(ts->cp_input_info[i].input);\r\ninput_free_device(ts->cp_input_info[i].input);\r\n}\r\n}\r\nkfree(ts);\r\nreturn retval;\r\n}\r\nstatic int cp_tm1217_suspend(struct i2c_client *client, pm_message_t mesg)\r\n{\r\nstruct cp_tm1217_device *ts = i2c_get_clientdata(client);\r\nu8 req[2];\r\nint retval;\r\nreq[0] = TMA1217_DEVICE_CTRL;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nreq[1] = (req[1] & 0xF8) | 0x1;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int cp_tm1217_resume(struct i2c_client *client)\r\n{\r\nstruct cp_tm1217_device *ts = i2c_get_clientdata(client);\r\nu8 req[2];\r\nint retval;\r\nreq[0] = TMA1217_DEVICE_CTRL;\r\nretval = cp_tm1217_read(ts, req, 1);\r\nreq[1] = (req[1] & 0xF8) | 0x4;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nreq[0] = TMA1217_REPORT_MODE;\r\nreq[1] = 0x02;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nreq[0] = TMA1217_DEVICE_CTRL;\r\nreq[1] = 0x84;\r\nretval = cp_tm1217_write(ts, req, 1);\r\nretval = cp_tm1217_unmask_interrupt(ts);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int cp_tm1217_remove(struct i2c_client *client)\r\n{\r\nstruct cp_tm1217_device *ts = i2c_get_clientdata(client);\r\nint i;\r\nfree_irq(client->irq, ts);\r\nif (ts->gpio)\r\ngpio_free(ts->gpio);\r\nfor (i = 0; i < TOUCH_SUPPORTED; i++)\r\ninput_unregister_device(ts->cp_input_info[i].input);\r\nkfree(ts);\r\nreturn 0;\r\n}
