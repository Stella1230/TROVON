int ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2)\r\n{\r\nstruct ebitmap_node *n1, *n2;\r\nif (e1->highbit != e2->highbit)\r\nreturn 0;\r\nn1 = e1->node;\r\nn2 = e2->node;\r\nwhile (n1 && n2 &&\r\n(n1->startbit == n2->startbit) &&\r\n!memcmp(n1->maps, n2->maps, EBITMAP_SIZE / 8)) {\r\nn1 = n1->next;\r\nn2 = n2->next;\r\n}\r\nif (n1 || n2)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\r\n{\r\nstruct ebitmap_node *n, *new, *prev;\r\nebitmap_init(dst);\r\nn = src->node;\r\nprev = NULL;\r\nwhile (n) {\r\nnew = kzalloc(sizeof(*new), GFP_ATOMIC);\r\nif (!new) {\r\nebitmap_destroy(dst);\r\nreturn -ENOMEM;\r\n}\r\nnew->startbit = n->startbit;\r\nmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\r\nnew->next = NULL;\r\nif (prev)\r\nprev->next = new;\r\nelse\r\ndst->node = new;\r\nprev = new;\r\nn = n->next;\r\n}\r\ndst->highbit = src->highbit;\r\nreturn 0;\r\n}\r\nint ebitmap_netlbl_export(struct ebitmap *ebmap,\r\nstruct netlbl_lsm_secattr_catmap **catmap)\r\n{\r\nstruct ebitmap_node *e_iter = ebmap->node;\r\nstruct netlbl_lsm_secattr_catmap *c_iter;\r\nu32 cmap_idx, cmap_sft;\r\nint i;\r\nif (e_iter == NULL) {\r\n*catmap = NULL;\r\nreturn 0;\r\n}\r\nc_iter = netlbl_secattr_catmap_alloc(GFP_ATOMIC);\r\nif (c_iter == NULL)\r\nreturn -ENOMEM;\r\n*catmap = c_iter;\r\nc_iter->startbit = e_iter->startbit & ~(NETLBL_CATMAP_SIZE - 1);\r\nwhile (e_iter) {\r\nfor (i = 0; i < EBITMAP_UNIT_NUMS; i++) {\r\nunsigned int delta, e_startbit, c_endbit;\r\ne_startbit = e_iter->startbit + i * EBITMAP_UNIT_SIZE;\r\nc_endbit = c_iter->startbit + NETLBL_CATMAP_SIZE;\r\nif (e_startbit >= c_endbit) {\r\nc_iter->next\r\n= netlbl_secattr_catmap_alloc(GFP_ATOMIC);\r\nif (c_iter->next == NULL)\r\ngoto netlbl_export_failure;\r\nc_iter = c_iter->next;\r\nc_iter->startbit\r\n= e_startbit & ~(NETLBL_CATMAP_SIZE - 1);\r\n}\r\ndelta = e_startbit - c_iter->startbit;\r\ncmap_idx = delta / NETLBL_CATMAP_MAPSIZE;\r\ncmap_sft = delta % NETLBL_CATMAP_MAPSIZE;\r\nc_iter->bitmap[cmap_idx]\r\n|= e_iter->maps[i] << cmap_sft;\r\n}\r\ne_iter = e_iter->next;\r\n}\r\nreturn 0;\r\nnetlbl_export_failure:\r\nnetlbl_secattr_catmap_free(*catmap);\r\nreturn -ENOMEM;\r\n}\r\nint ebitmap_netlbl_import(struct ebitmap *ebmap,\r\nstruct netlbl_lsm_secattr_catmap *catmap)\r\n{\r\nstruct ebitmap_node *e_iter = NULL;\r\nstruct ebitmap_node *emap_prev = NULL;\r\nstruct netlbl_lsm_secattr_catmap *c_iter = catmap;\r\nu32 c_idx, c_pos, e_idx, e_sft;\r\ndo {\r\nfor (c_idx = 0; c_idx < NETLBL_CATMAP_MAPCNT; c_idx++) {\r\nunsigned int delta;\r\nu64 map = c_iter->bitmap[c_idx];\r\nif (!map)\r\ncontinue;\r\nc_pos = c_iter->startbit\r\n+ c_idx * NETLBL_CATMAP_MAPSIZE;\r\nif (!e_iter\r\n|| c_pos >= e_iter->startbit + EBITMAP_SIZE) {\r\ne_iter = kzalloc(sizeof(*e_iter), GFP_ATOMIC);\r\nif (!e_iter)\r\ngoto netlbl_import_failure;\r\ne_iter->startbit\r\n= c_pos - (c_pos % EBITMAP_SIZE);\r\nif (emap_prev == NULL)\r\nebmap->node = e_iter;\r\nelse\r\nemap_prev->next = e_iter;\r\nemap_prev = e_iter;\r\n}\r\ndelta = c_pos - e_iter->startbit;\r\ne_idx = delta / EBITMAP_UNIT_SIZE;\r\ne_sft = delta % EBITMAP_UNIT_SIZE;\r\nwhile (map) {\r\ne_iter->maps[e_idx++] |= map & (-1UL);\r\nmap = EBITMAP_SHIFT_UNIT_SIZE(map);\r\n}\r\n}\r\nc_iter = c_iter->next;\r\n} while (c_iter);\r\nif (e_iter != NULL)\r\nebmap->highbit = e_iter->startbit + EBITMAP_SIZE;\r\nelse\r\nebitmap_destroy(ebmap);\r\nreturn 0;\r\nnetlbl_import_failure:\r\nebitmap_destroy(ebmap);\r\nreturn -ENOMEM;\r\n}\r\nint ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2)\r\n{\r\nstruct ebitmap_node *n1, *n2;\r\nint i;\r\nif (e1->highbit < e2->highbit)\r\nreturn 0;\r\nn1 = e1->node;\r\nn2 = e2->node;\r\nwhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\r\nif (n1->startbit < n2->startbit) {\r\nn1 = n1->next;\r\ncontinue;\r\n}\r\nfor (i = 0; i < EBITMAP_UNIT_NUMS; i++) {\r\nif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\r\nreturn 0;\r\n}\r\nn1 = n1->next;\r\nn2 = n2->next;\r\n}\r\nif (n2)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\r\n{\r\nstruct ebitmap_node *n;\r\nif (e->highbit < bit)\r\nreturn 0;\r\nn = e->node;\r\nwhile (n && (n->startbit <= bit)) {\r\nif ((n->startbit + EBITMAP_SIZE) > bit)\r\nreturn ebitmap_node_get_bit(n, bit);\r\nn = n->next;\r\n}\r\nreturn 0;\r\n}\r\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\r\n{\r\nstruct ebitmap_node *n, *prev, *new;\r\nprev = NULL;\r\nn = e->node;\r\nwhile (n && n->startbit <= bit) {\r\nif ((n->startbit + EBITMAP_SIZE) > bit) {\r\nif (value) {\r\nebitmap_node_set_bit(n, bit);\r\n} else {\r\nunsigned int s;\r\nebitmap_node_clr_bit(n, bit);\r\ns = find_first_bit(n->maps, EBITMAP_SIZE);\r\nif (s < EBITMAP_SIZE)\r\nreturn 0;\r\nif (!n->next) {\r\nif (prev)\r\ne->highbit = prev->startbit\r\n+ EBITMAP_SIZE;\r\nelse\r\ne->highbit = 0;\r\n}\r\nif (prev)\r\nprev->next = n->next;\r\nelse\r\ne->node = n->next;\r\nkfree(n);\r\n}\r\nreturn 0;\r\n}\r\nprev = n;\r\nn = n->next;\r\n}\r\nif (!value)\r\nreturn 0;\r\nnew = kzalloc(sizeof(*new), GFP_ATOMIC);\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->startbit = bit - (bit % EBITMAP_SIZE);\r\nebitmap_node_set_bit(new, bit);\r\nif (!n)\r\ne->highbit = new->startbit + EBITMAP_SIZE;\r\nif (prev) {\r\nnew->next = prev->next;\r\nprev->next = new;\r\n} else {\r\nnew->next = e->node;\r\ne->node = new;\r\n}\r\nreturn 0;\r\n}\r\nvoid ebitmap_destroy(struct ebitmap *e)\r\n{\r\nstruct ebitmap_node *n, *temp;\r\nif (!e)\r\nreturn;\r\nn = e->node;\r\nwhile (n) {\r\ntemp = n;\r\nn = n->next;\r\nkfree(temp);\r\n}\r\ne->highbit = 0;\r\ne->node = NULL;\r\nreturn;\r\n}\r\nint ebitmap_read(struct ebitmap *e, void *fp)\r\n{\r\nstruct ebitmap_node *n = NULL;\r\nu32 mapunit, count, startbit, index;\r\nu64 map;\r\n__le32 buf[3];\r\nint rc, i;\r\nebitmap_init(e);\r\nrc = next_entry(buf, fp, sizeof buf);\r\nif (rc < 0)\r\ngoto out;\r\nmapunit = le32_to_cpu(buf[0]);\r\ne->highbit = le32_to_cpu(buf[1]);\r\ncount = le32_to_cpu(buf[2]);\r\nif (mapunit != BITS_PER_U64) {\r\nprintk(KERN_ERR "SELinux: ebitmap: map size %u does not "\r\n"match my size %Zd (high bit was %d)\n",\r\nmapunit, BITS_PER_U64, e->highbit);\r\ngoto bad;\r\n}\r\ne->highbit += EBITMAP_SIZE - 1;\r\ne->highbit -= (e->highbit % EBITMAP_SIZE);\r\nif (!e->highbit) {\r\ne->node = NULL;\r\ngoto ok;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nrc = next_entry(&startbit, fp, sizeof(u32));\r\nif (rc < 0) {\r\nprintk(KERN_ERR "SELinux: ebitmap: truncated map\n");\r\ngoto bad;\r\n}\r\nstartbit = le32_to_cpu(startbit);\r\nif (startbit & (mapunit - 1)) {\r\nprintk(KERN_ERR "SELinux: ebitmap start bit (%d) is "\r\n"not a multiple of the map unit size (%u)\n",\r\nstartbit, mapunit);\r\ngoto bad;\r\n}\r\nif (startbit > e->highbit - mapunit) {\r\nprintk(KERN_ERR "SELinux: ebitmap start bit (%d) is "\r\n"beyond the end of the bitmap (%u)\n",\r\nstartbit, (e->highbit - mapunit));\r\ngoto bad;\r\n}\r\nif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\r\nstruct ebitmap_node *tmp;\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp) {\r\nprintk(KERN_ERR\r\n"SELinux: ebitmap: out of memory\n");\r\nrc = -ENOMEM;\r\ngoto bad;\r\n}\r\ntmp->startbit = startbit - (startbit % EBITMAP_SIZE);\r\nif (n)\r\nn->next = tmp;\r\nelse\r\ne->node = tmp;\r\nn = tmp;\r\n} else if (startbit <= n->startbit) {\r\nprintk(KERN_ERR "SELinux: ebitmap: start bit %d"\r\n" comes after start bit %d\n",\r\nstartbit, n->startbit);\r\ngoto bad;\r\n}\r\nrc = next_entry(&map, fp, sizeof(u64));\r\nif (rc < 0) {\r\nprintk(KERN_ERR "SELinux: ebitmap: truncated map\n");\r\ngoto bad;\r\n}\r\nmap = le64_to_cpu(map);\r\nindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\r\nwhile (map) {\r\nn->maps[index++] = map & (-1UL);\r\nmap = EBITMAP_SHIFT_UNIT_SIZE(map);\r\n}\r\n}\r\nok:\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nbad:\r\nif (!rc)\r\nrc = -EINVAL;\r\nebitmap_destroy(e);\r\ngoto out;\r\n}\r\nint ebitmap_write(struct ebitmap *e, void *fp)\r\n{\r\nstruct ebitmap_node *n;\r\nu32 count;\r\n__le32 buf[3];\r\nu64 map;\r\nint bit, last_bit, last_startbit, rc;\r\nbuf[0] = cpu_to_le32(BITS_PER_U64);\r\ncount = 0;\r\nlast_bit = 0;\r\nlast_startbit = -1;\r\nebitmap_for_each_positive_bit(e, n, bit) {\r\nif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\r\ncount++;\r\nlast_startbit = rounddown(bit, BITS_PER_U64);\r\n}\r\nlast_bit = roundup(bit + 1, BITS_PER_U64);\r\n}\r\nbuf[1] = cpu_to_le32(last_bit);\r\nbuf[2] = cpu_to_le32(count);\r\nrc = put_entry(buf, sizeof(u32), 3, fp);\r\nif (rc)\r\nreturn rc;\r\nmap = 0;\r\nlast_startbit = INT_MIN;\r\nebitmap_for_each_positive_bit(e, n, bit) {\r\nif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\r\n__le64 buf64[1];\r\nif (!map) {\r\nlast_startbit = rounddown(bit, BITS_PER_U64);\r\nmap = (u64)1 << (bit - last_startbit);\r\ncontinue;\r\n}\r\nbuf[0] = cpu_to_le32(last_startbit);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nbuf64[0] = cpu_to_le64(map);\r\nrc = put_entry(buf64, sizeof(u64), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nmap = 0;\r\nlast_startbit = rounddown(bit, BITS_PER_U64);\r\n}\r\nmap |= (u64)1 << (bit - last_startbit);\r\n}\r\nif (map) {\r\n__le64 buf64[1];\r\nbuf[0] = cpu_to_le32(last_startbit);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nbuf64[0] = cpu_to_le64(map);\r\nrc = put_entry(buf64, sizeof(u64), 1, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}
