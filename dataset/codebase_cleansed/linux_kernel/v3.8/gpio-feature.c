static struct device_node *get_gpio(char *name,\r\nchar *altname,\r\nint *gpioptr,\r\nint *gpioactiveptr)\r\n{\r\nstruct device_node *np, *gpio;\r\nconst u32 *reg;\r\nconst char *audio_gpio;\r\n*gpioptr = -1;\r\nnp = of_find_node_by_name(NULL, name);\r\nif (!np) {\r\ngpio = of_find_node_by_name(NULL, "gpio");\r\nif (!gpio)\r\nreturn NULL;\r\nwhile ((np = of_get_next_child(gpio, np))) {\r\naudio_gpio = of_get_property(np, "audio-gpio", NULL);\r\nif (!audio_gpio)\r\ncontinue;\r\nif (strcmp(audio_gpio, name) == 0)\r\nbreak;\r\nif (altname && (strcmp(audio_gpio, altname) == 0))\r\nbreak;\r\n}\r\nif (!np)\r\nreturn NULL;\r\n}\r\nreg = of_get_property(np, "reg", NULL);\r\nif (!reg)\r\nreturn NULL;\r\n*gpioptr = *reg;\r\nif (*gpioptr < 0x50)\r\n*gpioptr += 0x50;\r\nreg = of_get_property(np, "audio-gpio-active-state", NULL);\r\nif (!reg)\r\n*gpioactiveptr = 0;\r\nelse\r\n*gpioactiveptr = *reg;\r\nreturn np;\r\n}\r\nstatic void get_irq(struct device_node * np, int *irqptr)\r\n{\r\nif (np)\r\n*irqptr = irq_of_parse_and_map(np, 0);\r\nelse\r\n*irqptr = NO_IRQ;\r\n}\r\nstatic void ftr_gpio_set_hw_reset(struct gpio_runtime *rt, int on)\r\n{\r\nint v;\r\nif (unlikely(!rt)) return;\r\nif (hw_reset_gpio < 0)\r\nreturn;\r\nv = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL,\r\nhw_reset_gpio, 0);\r\nv = SWITCH_GPIO(hw_reset, v, on);\r\npmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,\r\nhw_reset_gpio, v);\r\n}\r\nstatic void ftr_gpio_all_amps_off(struct gpio_runtime *rt)\r\n{\r\nint saved;\r\nif (unlikely(!rt)) return;\r\nsaved = rt->implementation_private;\r\nftr_gpio_set_headphone(rt, 0);\r\nftr_gpio_set_amp(rt, 0);\r\nftr_gpio_set_lineout(rt, 0);\r\nif (methods.set_master)\r\nftr_gpio_set_master(rt, 0);\r\nrt->implementation_private = saved;\r\n}\r\nstatic void ftr_gpio_all_amps_restore(struct gpio_runtime *rt)\r\n{\r\nint s;\r\nif (unlikely(!rt)) return;\r\ns = rt->implementation_private;\r\nftr_gpio_set_headphone(rt, (s>>0)&1);\r\nftr_gpio_set_amp(rt, (s>>1)&1);\r\nftr_gpio_set_lineout(rt, (s>>2)&1);\r\nif (methods.set_master)\r\nftr_gpio_set_master(rt, (s>>3)&1);\r\n}\r\nstatic void ftr_handle_notify(struct work_struct *work)\r\n{\r\nstruct gpio_notification *notif =\r\ncontainer_of(work, struct gpio_notification, work.work);\r\nmutex_lock(&notif->mutex);\r\nif (notif->notify)\r\nnotif->notify(notif->data);\r\nmutex_unlock(&notif->mutex);\r\n}\r\nstatic void gpio_enable_dual_edge(int gpio)\r\n{\r\nint v;\r\nif (gpio == -1)\r\nreturn;\r\nv = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, gpio, 0);\r\nv |= 0x80;\r\npmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, gpio, v);\r\n}\r\nstatic void ftr_gpio_init(struct gpio_runtime *rt)\r\n{\r\nget_gpio("headphone-mute", NULL,\r\n&headphone_mute_gpio,\r\n&headphone_mute_gpio_activestate);\r\nget_gpio("amp-mute", NULL,\r\n&amp_mute_gpio,\r\n&amp_mute_gpio_activestate);\r\nget_gpio("lineout-mute", NULL,\r\n&lineout_mute_gpio,\r\n&lineout_mute_gpio_activestate);\r\nget_gpio("hw-reset", "audio-hw-reset",\r\n&hw_reset_gpio,\r\n&hw_reset_gpio_activestate);\r\nif (get_gpio("master-mute", NULL,\r\n&master_mute_gpio,\r\n&master_mute_gpio_activestate)) {\r\nmethods.set_master = ftr_gpio_set_master;\r\nmethods.get_master = ftr_gpio_get_master;\r\n}\r\nheadphone_detect_node = get_gpio("headphone-detect", NULL,\r\n&headphone_detect_gpio,\r\n&headphone_detect_gpio_activestate);\r\nlineout_detect_node = get_gpio("lineout-detect", "line-output-detect",\r\n&lineout_detect_gpio,\r\n&lineout_detect_gpio_activestate);\r\nlinein_detect_node = get_gpio("linein-detect", "line-input-detect",\r\n&linein_detect_gpio,\r\n&linein_detect_gpio_activestate);\r\ngpio_enable_dual_edge(headphone_detect_gpio);\r\ngpio_enable_dual_edge(lineout_detect_gpio);\r\ngpio_enable_dual_edge(linein_detect_gpio);\r\nget_irq(headphone_detect_node, &headphone_detect_irq);\r\nget_irq(lineout_detect_node, &lineout_detect_irq);\r\nget_irq(linein_detect_node, &linein_detect_irq);\r\nftr_gpio_all_amps_off(rt);\r\nrt->implementation_private = 0;\r\nINIT_DELAYED_WORK(&rt->headphone_notify.work, ftr_handle_notify);\r\nINIT_DELAYED_WORK(&rt->line_in_notify.work, ftr_handle_notify);\r\nINIT_DELAYED_WORK(&rt->line_out_notify.work, ftr_handle_notify);\r\nmutex_init(&rt->headphone_notify.mutex);\r\nmutex_init(&rt->line_in_notify.mutex);\r\nmutex_init(&rt->line_out_notify.mutex);\r\n}\r\nstatic void ftr_gpio_exit(struct gpio_runtime *rt)\r\n{\r\nftr_gpio_all_amps_off(rt);\r\nrt->implementation_private = 0;\r\nif (rt->headphone_notify.notify)\r\nfree_irq(headphone_detect_irq, &rt->headphone_notify);\r\nif (rt->line_in_notify.gpio_private)\r\nfree_irq(linein_detect_irq, &rt->line_in_notify);\r\nif (rt->line_out_notify.gpio_private)\r\nfree_irq(lineout_detect_irq, &rt->line_out_notify);\r\ncancel_delayed_work_sync(&rt->headphone_notify.work);\r\ncancel_delayed_work_sync(&rt->line_in_notify.work);\r\ncancel_delayed_work_sync(&rt->line_out_notify.work);\r\nmutex_destroy(&rt->headphone_notify.mutex);\r\nmutex_destroy(&rt->line_in_notify.mutex);\r\nmutex_destroy(&rt->line_out_notify.mutex);\r\n}\r\nstatic irqreturn_t ftr_handle_notify_irq(int xx, void *data)\r\n{\r\nstruct gpio_notification *notif = data;\r\nschedule_delayed_work(&notif->work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ftr_set_notify(struct gpio_runtime *rt,\r\nenum notify_type type,\r\nnotify_func_t notify,\r\nvoid *data)\r\n{\r\nstruct gpio_notification *notif;\r\nnotify_func_t old;\r\nint irq;\r\nchar *name;\r\nint err = -EBUSY;\r\nswitch (type) {\r\ncase AOA_NOTIFY_HEADPHONE:\r\nnotif = &rt->headphone_notify;\r\nname = "headphone-detect";\r\nirq = headphone_detect_irq;\r\nbreak;\r\ncase AOA_NOTIFY_LINE_IN:\r\nnotif = &rt->line_in_notify;\r\nname = "linein-detect";\r\nirq = linein_detect_irq;\r\nbreak;\r\ncase AOA_NOTIFY_LINE_OUT:\r\nnotif = &rt->line_out_notify;\r\nname = "lineout-detect";\r\nirq = lineout_detect_irq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (irq == NO_IRQ)\r\nreturn -ENODEV;\r\nmutex_lock(&notif->mutex);\r\nold = notif->notify;\r\nif (!old && !notify) {\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\nif (old && notify) {\r\nif (old == notify && notif->data == data)\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\nif (old && !notify)\r\nfree_irq(irq, notif);\r\nif (!old && notify) {\r\nerr = request_irq(irq, ftr_handle_notify_irq, 0, name, notif);\r\nif (err)\r\ngoto out_unlock;\r\n}\r\nnotif->notify = notify;\r\nnotif->data = data;\r\nerr = 0;\r\nout_unlock:\r\nmutex_unlock(&notif->mutex);\r\nreturn err;\r\n}\r\nstatic int ftr_get_detect(struct gpio_runtime *rt,\r\nenum notify_type type)\r\n{\r\nint gpio, ret, active;\r\nswitch (type) {\r\ncase AOA_NOTIFY_HEADPHONE:\r\ngpio = headphone_detect_gpio;\r\nactive = headphone_detect_gpio_activestate;\r\nbreak;\r\ncase AOA_NOTIFY_LINE_IN:\r\ngpio = linein_detect_gpio;\r\nactive = linein_detect_gpio_activestate;\r\nbreak;\r\ncase AOA_NOTIFY_LINE_OUT:\r\ngpio = lineout_detect_gpio;\r\nactive = lineout_detect_gpio_activestate;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (gpio == -1)\r\nreturn -ENODEV;\r\nret = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, gpio, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ((ret >> 1) & 1) == active;\r\n}
