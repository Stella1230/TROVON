int sock_diag_check_cookie(void *sk, __u32 *cookie)\r\n{\r\nif ((cookie[0] != INET_DIAG_NOCOOKIE ||\r\ncookie[1] != INET_DIAG_NOCOOKIE) &&\r\n((u32)(unsigned long)sk != cookie[0] ||\r\n(u32)((((unsigned long)sk) >> 31) >> 1) != cookie[1]))\r\nreturn -ESTALE;\r\nelse\r\nreturn 0;\r\n}\r\nvoid sock_diag_save_cookie(void *sk, __u32 *cookie)\r\n{\r\ncookie[0] = (u32)(unsigned long)sk;\r\ncookie[1] = (u32)(((unsigned long)sk >> 31) >> 1);\r\n}\r\nint sock_diag_put_meminfo(struct sock *sk, struct sk_buff *skb, int attrtype)\r\n{\r\nu32 mem[SK_MEMINFO_VARS];\r\nmem[SK_MEMINFO_RMEM_ALLOC] = sk_rmem_alloc_get(sk);\r\nmem[SK_MEMINFO_RCVBUF] = sk->sk_rcvbuf;\r\nmem[SK_MEMINFO_WMEM_ALLOC] = sk_wmem_alloc_get(sk);\r\nmem[SK_MEMINFO_SNDBUF] = sk->sk_sndbuf;\r\nmem[SK_MEMINFO_FWD_ALLOC] = sk->sk_forward_alloc;\r\nmem[SK_MEMINFO_WMEM_QUEUED] = sk->sk_wmem_queued;\r\nmem[SK_MEMINFO_OPTMEM] = atomic_read(&sk->sk_omem_alloc);\r\nmem[SK_MEMINFO_BACKLOG] = sk->sk_backlog.len;\r\nreturn nla_put(skb, attrtype, sizeof(mem), &mem);\r\n}\r\nvoid sock_diag_register_inet_compat(int (*fn)(struct sk_buff *skb, struct nlmsghdr *nlh))\r\n{\r\nmutex_lock(&sock_diag_table_mutex);\r\ninet_rcv_compat = fn;\r\nmutex_unlock(&sock_diag_table_mutex);\r\n}\r\nvoid sock_diag_unregister_inet_compat(int (*fn)(struct sk_buff *skb, struct nlmsghdr *nlh))\r\n{\r\nmutex_lock(&sock_diag_table_mutex);\r\ninet_rcv_compat = NULL;\r\nmutex_unlock(&sock_diag_table_mutex);\r\n}\r\nint sock_diag_register(const struct sock_diag_handler *hndl)\r\n{\r\nint err = 0;\r\nif (hndl->family >= AF_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&sock_diag_table_mutex);\r\nif (sock_diag_handlers[hndl->family])\r\nerr = -EBUSY;\r\nelse\r\nsock_diag_handlers[hndl->family] = hndl;\r\nmutex_unlock(&sock_diag_table_mutex);\r\nreturn err;\r\n}\r\nvoid sock_diag_unregister(const struct sock_diag_handler *hnld)\r\n{\r\nint family = hnld->family;\r\nif (family >= AF_MAX)\r\nreturn;\r\nmutex_lock(&sock_diag_table_mutex);\r\nBUG_ON(sock_diag_handlers[family] != hnld);\r\nsock_diag_handlers[family] = NULL;\r\nmutex_unlock(&sock_diag_table_mutex);\r\n}\r\nstatic const inline struct sock_diag_handler *sock_diag_lock_handler(int family)\r\n{\r\nif (sock_diag_handlers[family] == NULL)\r\nrequest_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK,\r\nNETLINK_SOCK_DIAG, family);\r\nmutex_lock(&sock_diag_table_mutex);\r\nreturn sock_diag_handlers[family];\r\n}\r\nstatic inline void sock_diag_unlock_handler(const struct sock_diag_handler *h)\r\n{\r\nmutex_unlock(&sock_diag_table_mutex);\r\n}\r\nstatic int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nint err;\r\nstruct sock_diag_req *req = nlmsg_data(nlh);\r\nconst struct sock_diag_handler *hndl;\r\nif (nlmsg_len(nlh) < sizeof(*req))\r\nreturn -EINVAL;\r\nhndl = sock_diag_lock_handler(req->sdiag_family);\r\nif (hndl == NULL)\r\nerr = -ENOENT;\r\nelse\r\nerr = hndl->dump(skb, nlh);\r\nsock_diag_unlock_handler(hndl);\r\nreturn err;\r\n}\r\nstatic int sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nint ret;\r\nswitch (nlh->nlmsg_type) {\r\ncase TCPDIAG_GETSOCK:\r\ncase DCCPDIAG_GETSOCK:\r\nif (inet_rcv_compat == NULL)\r\nrequest_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK,\r\nNETLINK_SOCK_DIAG, AF_INET);\r\nmutex_lock(&sock_diag_table_mutex);\r\nif (inet_rcv_compat != NULL)\r\nret = inet_rcv_compat(skb, nlh);\r\nelse\r\nret = -EOPNOTSUPP;\r\nmutex_unlock(&sock_diag_table_mutex);\r\nreturn ret;\r\ncase SOCK_DIAG_BY_FAMILY:\r\nreturn __sock_diag_rcv_msg(skb, nlh);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void sock_diag_rcv(struct sk_buff *skb)\r\n{\r\nmutex_lock(&sock_diag_mutex);\r\nnetlink_rcv_skb(skb, &sock_diag_rcv_msg);\r\nmutex_unlock(&sock_diag_mutex);\r\n}\r\nstatic int __net_init diag_net_init(struct net *net)\r\n{\r\nstruct netlink_kernel_cfg cfg = {\r\n.input = sock_diag_rcv,\r\n};\r\nnet->diag_nlsk = netlink_kernel_create(net, NETLINK_SOCK_DIAG, &cfg);\r\nreturn net->diag_nlsk == NULL ? -ENOMEM : 0;\r\n}\r\nstatic void __net_exit diag_net_exit(struct net *net)\r\n{\r\nnetlink_kernel_release(net->diag_nlsk);\r\nnet->diag_nlsk = NULL;\r\n}\r\nstatic int __init sock_diag_init(void)\r\n{\r\nreturn register_pernet_subsys(&diag_net_ops);\r\n}\r\nstatic void __exit sock_diag_exit(void)\r\n{\r\nunregister_pernet_subsys(&diag_net_ops);\r\n}
