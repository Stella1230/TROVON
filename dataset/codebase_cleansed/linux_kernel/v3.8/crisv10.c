void debug_log_func(int line, const char *string, int value)\r\n{\r\nif (debug_log_pos < DEBUG_LOG_SIZE) {\r\ndebug_log[debug_log_pos].time = jiffies;\r\ndebug_log[debug_log_pos].timer_data = *R_TIMER_DATA;\r\ndebug_log[debug_log_pos].string = string;\r\ndebug_log[debug_log_pos].value = value;\r\ndebug_log_pos++;\r\n}\r\n}\r\nstatic void update_char_time(struct e100_serial * info)\r\n{\r\ntcflag_t cflags = info->port.tty->termios.c_cflag;\r\nint bits;\r\nif ((cflags & CSIZE) == CS7)\r\nbits = 9;\r\nelse\r\nbits = 10;\r\nif (cflags & CSTOPB)\r\nbits++;\r\nif (cflags & PARENB)\r\nbits++;\r\ninfo->char_time_usec = ((bits * 1000000) / info->baud) + 1;\r\ninfo->flush_time_usec = 4*info->char_time_usec;\r\nif (info->flush_time_usec < MIN_FLUSH_TIME_USEC)\r\ninfo->flush_time_usec = MIN_FLUSH_TIME_USEC;\r\n}\r\nstatic int\r\ncflag_to_baud(unsigned int cflag)\r\n{\r\nstatic int baud_table[] = {\r\n0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 };\r\nstatic int ext_baud_table[] = {\r\n0, 57600, 115200, 230400, 460800, 921600, 1843200, 6250000,\r\n0, 0, 0, 0, 0, 0, 0, 0 };\r\nif (cflag & CBAUDEX)\r\nreturn ext_baud_table[(cflag & CBAUD) & ~CBAUDEX];\r\nelse\r\nreturn baud_table[cflag & CBAUD];\r\n}\r\nstatic unsigned char\r\ncflag_to_etrax_baud(unsigned int cflag)\r\n{\r\nchar retval;\r\nstatic char baud_table[] = {\r\n-1, -1, -1, -1, -1, -1, -1, 0, 1, 2, -1, 3, 4, 5, 6, 7 };\r\nstatic char ext_baud_table[] = {\r\n-1, 8, 9, 10, 11, 12, 13, 14, -1, -1, -1, -1, -1, -1, -1, -1 };\r\nif (cflag & CBAUDEX)\r\nretval = ext_baud_table[(cflag & CBAUD) & ~CBAUDEX];\r\nelse\r\nretval = baud_table[cflag & CBAUD];\r\nif (retval < 0) {\r\nprintk(KERN_WARNING "serdriver tried setting invalid baud rate, flags %x.\n", cflag);\r\nretval = 5;\r\n}\r\nreturn retval | (retval << 4);\r\n}\r\nstatic inline void\r\ne100_dtr(struct e100_serial *info, int set)\r\n{\r\n#ifndef CONFIG_SVINTO_SIM\r\nunsigned char mask = e100_modem_pins[info->line].dtr_mask;\r\n#ifdef SERIAL_DEBUG_IO\r\nprintk("ser%i dtr %i mask: 0x%02X\n", info->line, set, mask);\r\nprintk("ser%i shadow before 0x%02X get: %i\n",\r\ninfo->line, *e100_modem_pins[info->line].dtr_shadow,\r\nE100_DTR_GET(info));\r\n#endif\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n*e100_modem_pins[info->line].dtr_shadow &= ~mask;\r\n*e100_modem_pins[info->line].dtr_shadow |= (set ? 0 : mask);\r\n*e100_modem_pins[info->line].dtr_port = *e100_modem_pins[info->line].dtr_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\n#ifdef SERIAL_DEBUG_IO\r\nprintk("ser%i shadow after 0x%02X get: %i\n",\r\ninfo->line, *e100_modem_pins[info->line].dtr_shadow,\r\nE100_DTR_GET(info));\r\n#endif\r\n#endif\r\n}\r\nstatic inline void\r\ne100_rts(struct e100_serial *info, int set)\r\n{\r\n#ifndef CONFIG_SVINTO_SIM\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ninfo->rx_ctrl &= ~E100_RTS_MASK;\r\ninfo->rx_ctrl |= (set ? 0 : E100_RTS_MASK);\r\ninfo->ioport[REG_REC_CTRL] = info->rx_ctrl;\r\nlocal_irq_restore(flags);\r\n#ifdef SERIAL_DEBUG_IO\r\nprintk("ser%i rts %i\n", info->line, set);\r\n#endif\r\n#endif\r\n}\r\nstatic inline void\r\ne100_ri_out(struct e100_serial *info, int set)\r\n{\r\n#ifndef CONFIG_SVINTO_SIM\r\n{\r\nunsigned char mask = e100_modem_pins[info->line].ri_mask;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n*e100_modem_pins[info->line].ri_shadow &= ~mask;\r\n*e100_modem_pins[info->line].ri_shadow |= (set ? 0 : mask);\r\n*e100_modem_pins[info->line].ri_port = *e100_modem_pins[info->line].ri_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\n#endif\r\n}\r\nstatic inline void\r\ne100_cd_out(struct e100_serial *info, int set)\r\n{\r\n#ifndef CONFIG_SVINTO_SIM\r\n{\r\nunsigned char mask = e100_modem_pins[info->line].cd_mask;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n*e100_modem_pins[info->line].cd_shadow &= ~mask;\r\n*e100_modem_pins[info->line].cd_shadow |= (set ? 0 : mask);\r\n*e100_modem_pins[info->line].cd_port = *e100_modem_pins[info->line].cd_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\n#endif\r\n}\r\nstatic inline void\r\ne100_disable_rx(struct e100_serial *info)\r\n{\r\n#ifndef CONFIG_SVINTO_SIM\r\ninfo->ioport[REG_REC_CTRL] =\r\n(info->rx_ctrl &= ~IO_MASK(R_SERIAL0_REC_CTRL, rec_enable));\r\n#endif\r\n}\r\nstatic inline void\r\ne100_enable_rx(struct e100_serial *info)\r\n{\r\n#ifndef CONFIG_SVINTO_SIM\r\ninfo->ioport[REG_REC_CTRL] =\r\n(info->rx_ctrl |= IO_MASK(R_SERIAL0_REC_CTRL, rec_enable));\r\n#endif\r\n}\r\nstatic inline void\r\ne100_disable_rxdma_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("rxdma_irq(%d): 0\n",info->line);\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ disable_rxdma_irq %i\n", info->line));\r\n*R_IRQ_MASK2_CLR = (info->irq << 2) | (info->irq << 3);\r\n}\r\nstatic inline void\r\ne100_enable_rxdma_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("rxdma_irq(%d): 1\n",info->line);\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ enable_rxdma_irq %i\n", info->line));\r\n*R_IRQ_MASK2_SET = (info->irq << 2) | (info->irq << 3);\r\n}\r\nstatic void e100_disable_txdma_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("txdma_irq(%d): 0\n",info->line);\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ disable_txdma_irq %i\n", info->line));\r\n*R_IRQ_MASK2_CLR = info->irq;\r\n}\r\nstatic void e100_enable_txdma_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("txdma_irq(%d): 1\n",info->line);\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ enable_txdma_irq %i\n", info->line));\r\n*R_IRQ_MASK2_SET = info->irq;\r\n}\r\nstatic void e100_disable_txdma_channel(struct e100_serial *info)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nDFLOW(DEBUG_LOG(info->line, "disable_txdma_channel %i\n", info->line));\r\nif (info->line == 0) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma6)) ==\r\nIO_STATE(R_GEN_CONFIG, dma6, serial0)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma6);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma6, unused);\r\n}\r\n} else if (info->line == 1) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma8)) ==\r\nIO_STATE(R_GEN_CONFIG, dma8, serial1)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma8);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma8, usb);\r\n}\r\n} else if (info->line == 2) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma2)) ==\r\nIO_STATE(R_GEN_CONFIG, dma2, serial2)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma2);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma2, par0);\r\n}\r\n} else if (info->line == 3) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma4)) ==\r\nIO_STATE(R_GEN_CONFIG, dma4, serial3)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma4);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma4, par1);\r\n}\r\n}\r\n*R_GEN_CONFIG = genconfig_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void e100_enable_txdma_channel(struct e100_serial *info)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nDFLOW(DEBUG_LOG(info->line, "enable_txdma_channel %i\n", info->line));\r\nif (info->line == 0) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma6);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma6, serial0);\r\n} else if (info->line == 1) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma8);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma8, serial1);\r\n} else if (info->line == 2) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma2);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma2, serial2);\r\n} else if (info->line == 3) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma4);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma4, serial3);\r\n}\r\n*R_GEN_CONFIG = genconfig_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void e100_disable_rxdma_channel(struct e100_serial *info)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (info->line == 0) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma7)) ==\r\nIO_STATE(R_GEN_CONFIG, dma7, serial0)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma7);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma7, unused);\r\n}\r\n} else if (info->line == 1) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma9)) ==\r\nIO_STATE(R_GEN_CONFIG, dma9, serial1)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma9);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma9, usb);\r\n}\r\n} else if (info->line == 2) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma3)) ==\r\nIO_STATE(R_GEN_CONFIG, dma3, serial2)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma3);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma3, par0);\r\n}\r\n} else if (info->line == 3) {\r\nif ((genconfig_shadow & IO_MASK(R_GEN_CONFIG, dma5)) ==\r\nIO_STATE(R_GEN_CONFIG, dma5, serial3)) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma5);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma5, par1);\r\n}\r\n}\r\n*R_GEN_CONFIG = genconfig_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void e100_enable_rxdma_channel(struct e100_serial *info)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (info->line == 0) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma7);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma7, serial0);\r\n} else if (info->line == 1) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma9);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma9, serial1);\r\n} else if (info->line == 2) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma3);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma3, serial2);\r\n} else if (info->line == 3) {\r\ngenconfig_shadow &= ~IO_MASK(R_GEN_CONFIG, dma5);\r\ngenconfig_shadow |= IO_STATE(R_GEN_CONFIG, dma5, serial3);\r\n}\r\n*R_GEN_CONFIG = genconfig_shadow;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline void\r\ne100_disable_serial_data_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_irq(%d): 0\n",info->line);\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ disable data_irq %i\n", info->line));\r\n*R_IRQ_MASK1_CLR = (1U << (8+2*info->line));\r\n}\r\nstatic inline void\r\ne100_enable_serial_data_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_irq(%d): 1\n",info->line);\r\nprintk("**** %d = %d\n",\r\n(8+2*info->line),\r\n(1U << (8+2*info->line)));\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ enable data_irq %i\n", info->line));\r\n*R_IRQ_MASK1_SET = (1U << (8+2*info->line));\r\n}\r\nstatic inline void\r\ne100_disable_serial_tx_ready_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_tx_irq(%d): 0\n",info->line);\r\n#endif\r\nDINTR1(DEBUG_LOG(info->line,"IRQ disable ready_irq %i\n", info->line));\r\n*R_IRQ_MASK1_CLR = (1U << (8+1+2*info->line));\r\n}\r\nstatic inline void\r\ne100_enable_serial_tx_ready_irq(struct e100_serial *info)\r\n{\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("ser_tx_irq(%d): 1\n",info->line);\r\nprintk("**** %d = %d\n",\r\n(8+1+2*info->line),\r\n(1U << (8+1+2*info->line)));\r\n#endif\r\nDINTR2(DEBUG_LOG(info->line,"IRQ enable ready_irq %i\n", info->line));\r\n*R_IRQ_MASK1_SET = (1U << (8+1+2*info->line));\r\n}\r\nstatic inline void e100_enable_rx_irq(struct e100_serial *info)\r\n{\r\nif (info->uses_dma_in)\r\ne100_enable_rxdma_irq(info);\r\nelse\r\ne100_enable_serial_data_irq(info);\r\n}\r\nstatic inline void e100_disable_rx_irq(struct e100_serial *info)\r\n{\r\nif (info->uses_dma_in)\r\ne100_disable_rxdma_irq(info);\r\nelse\r\ne100_disable_serial_data_irq(info);\r\n}\r\nstatic int\r\ne100_enable_rs485(struct tty_struct *tty, struct serial_rs485 *r)\r\n{\r\nstruct e100_serial * info = (struct e100_serial *)tty->driver_data;\r\n#if defined(CONFIG_ETRAX_RS485_ON_PA)\r\n*R_PORT_PA_DATA = port_pa_data_shadow |= (1 << rs485_pa_bit);\r\n#endif\r\n#if defined(CONFIG_ETRAX_RS485_ON_PORT_G)\r\nREG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow,\r\nrs485_port_g_bit, 1);\r\n#endif\r\n#if defined(CONFIG_ETRAX_RS485_LTC1387)\r\nREG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow,\r\nCONFIG_ETRAX_RS485_LTC1387_DXEN_PORT_G_BIT, 1);\r\nREG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow,\r\nCONFIG_ETRAX_RS485_LTC1387_RXEN_PORT_G_BIT, 1);\r\n#endif\r\ninfo->rs485 = *r;\r\nif (info->rs485.delay_rts_before_send >= 1000)\r\ninfo->rs485.delay_rts_before_send = 1000;\r\nreturn 0;\r\n}\r\nstatic int\r\ne100_write_rs485(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct e100_serial * info = (struct e100_serial *)tty->driver_data;\r\nint old_value = (info->rs485.flags) & SER_RS485_ENABLED;\r\ninfo->rs485.flags |= SER_RS485_ENABLED;\r\ncount = rs_write(tty, buf, count);\r\nif (!old_value)\r\ninfo->rs485.flags &= ~(SER_RS485_ENABLED);\r\nreturn count;\r\n}\r\nstatic void rs485_toggle_rts_timer_function(unsigned long data)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)data;\r\nfast_timers_rs485[info->line].function = NULL;\r\ne100_rts(info, (info->rs485.flags & SER_RS485_RTS_AFTER_SEND));\r\n#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)\r\ne100_enable_rx(info);\r\ne100_enable_rx_irq(info);\r\n#endif\r\n}\r\nstatic void\r\nrs_stop(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nif (info) {\r\nunsigned long flags;\r\nunsigned long xoff;\r\nlocal_irq_save(flags);\r\nDFLOW(DEBUG_LOG(info->line, "XOFF rs_stop xmit %i\n",\r\nCIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,SERIAL_XMIT_SIZE)));\r\nxoff = IO_FIELD(R_SERIAL0_XOFF, xoff_char,\r\nSTOP_CHAR(info->port.tty));\r\nxoff |= IO_STATE(R_SERIAL0_XOFF, tx_stop, stop);\r\nif (tty->termios.c_iflag & IXON ) {\r\nxoff |= IO_STATE(R_SERIAL0_XOFF, auto_xoff, enable);\r\n}\r\n*((unsigned long *)&info->ioport[REG_XOFF]) = xoff;\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void\r\nrs_start(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nif (info) {\r\nunsigned long flags;\r\nunsigned long xoff;\r\nlocal_irq_save(flags);\r\nDFLOW(DEBUG_LOG(info->line, "XOFF rs_start xmit %i\n",\r\nCIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,SERIAL_XMIT_SIZE)));\r\nxoff = IO_FIELD(R_SERIAL0_XOFF, xoff_char, STOP_CHAR(tty));\r\nxoff |= IO_STATE(R_SERIAL0_XOFF, tx_stop, enable);\r\nif (tty->termios.c_iflag & IXON ) {\r\nxoff |= IO_STATE(R_SERIAL0_XOFF, auto_xoff, enable);\r\n}\r\n*((unsigned long *)&info->ioport[REG_XOFF]) = xoff;\r\nif (!info->uses_dma_out &&\r\ninfo->xmit.head != info->xmit.tail && info->xmit.buf)\r\ne100_enable_serial_tx_ready_irq(info);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void rs_sched_event(struct e100_serial *info, int event)\r\n{\r\nif (info->event & (1 << event))\r\nreturn;\r\ninfo->event |= 1 << event;\r\nschedule_work(&info->work);\r\n}\r\nstatic void\r\ntransmit_chars_dma(struct e100_serial *info)\r\n{\r\nunsigned int c, sentl;\r\nstruct etrax_dma_descr *descr;\r\n#ifdef CONFIG_SVINTO_SIM\r\nif (info->xmit.tail)\r\nprintk("Error in serial.c:transmit_chars-dma(), tail!=0\n");\r\nif (info->xmit.head != info->xmit.tail) {\r\nSIMCOUT(info->xmit.buf + info->xmit.tail,\r\nCIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE));\r\ninfo->xmit.head = info->xmit.tail;\r\ninfo->tr_running = 0;\r\n}\r\nreturn;\r\n#endif\r\n*info->oclrintradr =\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_descr, do) |\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_eop, do);\r\n#ifdef SERIAL_DEBUG_INTR\r\nif (info->line == SERIAL_DEBUG_LINE)\r\nprintk("tc\n");\r\n#endif\r\nif (!info->tr_running) {\r\nprintk(KERN_WARNING "Achtung: transmit_chars_dma with !tr_running\n");\r\nreturn;\r\n}\r\ndescr = &info->tr_descr;\r\nif (!(descr->status & d_stop)) {\r\nsentl = descr->sw_len;\r\n} else\r\nsentl = descr->hw_len;\r\nDFLOW(DEBUG_LOG(info->line, "TX %i done\n", sentl));\r\ninfo->icount.tx += sentl;\r\ninfo->xmit.tail = (info->xmit.tail + sentl) & (SERIAL_XMIT_SIZE - 1);\r\nif (CIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE) < WAKEUP_CHARS)\r\nrs_sched_event(info, RS_EVENT_WRITE_WAKEUP);\r\nc = CIRC_CNT_TO_END(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\nif (c >= 4*WAKEUP_CHARS)\r\nc = c/2;\r\nif (c <= 0) {\r\ninfo->tr_running = 0;\r\n#if defined(CONFIG_ETRAX_RS485) && defined(CONFIG_ETRAX_FAST_TIMER)\r\nif (info->rs485.flags & SER_RS485_ENABLED) {\r\nstart_one_shot_timer(&fast_timers_rs485[info->line],\r\nrs485_toggle_rts_timer_function,\r\n(unsigned long)info,\r\ninfo->char_time_usec*2,\r\n"RS-485");\r\n}\r\n#endif\r\nreturn;\r\n}\r\nDFLOW(DEBUG_LOG(info->line, "TX %i\n", c));\r\ndescr->ctrl = d_int | d_eol | d_wait;\r\ndescr->sw_len = c;\r\ndescr->buf = virt_to_phys(info->xmit.buf + info->xmit.tail);\r\ndescr->status = 0;\r\n*info->ofirstadr = virt_to_phys(descr);\r\n*info->ocmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, start);\r\n}\r\nstatic void\r\nstart_transmit(struct e100_serial *info)\r\n{\r\n#if 0\r\nif (info->line == SERIAL_DEBUG_LINE)\r\nprintk("x\n");\r\n#endif\r\ninfo->tr_descr.sw_len = 0;\r\ninfo->tr_descr.hw_len = 0;\r\ninfo->tr_descr.status = 0;\r\ninfo->tr_running = 1;\r\nif (info->uses_dma_out)\r\ntransmit_chars_dma(info);\r\nelse\r\ne100_enable_serial_tx_ready_irq(info);\r\n}\r\nstatic struct etrax_recv_buffer *\r\nalloc_recv_buffer(unsigned int size)\r\n{\r\nstruct etrax_recv_buffer *buffer;\r\nif (!(buffer = kmalloc(sizeof *buffer + size, GFP_ATOMIC)))\r\nreturn NULL;\r\nbuffer->next = NULL;\r\nbuffer->length = 0;\r\nbuffer->error = TTY_NORMAL;\r\nreturn buffer;\r\n}\r\nstatic void\r\nappend_recv_buffer(struct e100_serial *info, struct etrax_recv_buffer *buffer)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (!info->first_recv_buffer)\r\ninfo->first_recv_buffer = buffer;\r\nelse\r\ninfo->last_recv_buffer->next = buffer;\r\ninfo->last_recv_buffer = buffer;\r\ninfo->recv_cnt += buffer->length;\r\nif (info->recv_cnt > info->max_recv_cnt)\r\ninfo->max_recv_cnt = info->recv_cnt;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nadd_char_and_flag(struct e100_serial *info, unsigned char data, unsigned char flag)\r\n{\r\nstruct etrax_recv_buffer *buffer;\r\nif (info->uses_dma_in) {\r\nif (!(buffer = alloc_recv_buffer(4)))\r\nreturn 0;\r\nbuffer->length = 1;\r\nbuffer->error = flag;\r\nbuffer->buffer[0] = data;\r\nappend_recv_buffer(info, buffer);\r\ninfo->icount.rx++;\r\n} else {\r\nstruct tty_struct *tty = info->port.tty;\r\ntty_insert_flip_char(tty, data, flag);\r\ninfo->icount.rx++;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned int handle_descr_data(struct e100_serial *info,\r\nstruct etrax_dma_descr *descr,\r\nunsigned int recvl)\r\n{\r\nstruct etrax_recv_buffer *buffer = phys_to_virt(descr->buf) - sizeof *buffer;\r\nif (info->recv_cnt + recvl > 65536) {\r\nprintk(KERN_WARNING\r\n"%s: Too much pending incoming serial data! Dropping %u bytes.\n", __func__, recvl);\r\nreturn 0;\r\n}\r\nbuffer->length = recvl;\r\nif (info->errorcode == ERRCODE_SET_BREAK)\r\nbuffer->error = TTY_BREAK;\r\ninfo->errorcode = 0;\r\nappend_recv_buffer(info, buffer);\r\nif (!(buffer = alloc_recv_buffer(SERIAL_DESCR_BUF_SIZE)))\r\npanic("%s: Failed to allocate memory for receive buffer!\n", __func__);\r\ndescr->buf = virt_to_phys(buffer->buffer);\r\nreturn recvl;\r\n}\r\nstatic unsigned int handle_all_descr_data(struct e100_serial *info)\r\n{\r\nstruct etrax_dma_descr *descr;\r\nunsigned int recvl;\r\nunsigned int ret = 0;\r\nwhile (1)\r\n{\r\ndescr = &info->rec_descr[info->cur_rec_descr];\r\nif (descr == phys_to_virt(*info->idescradr))\r\nbreak;\r\nif (++info->cur_rec_descr == SERIAL_RECV_DESCRIPTORS)\r\ninfo->cur_rec_descr = 0;\r\nif (!(descr->status & d_eop)) {\r\nrecvl = descr->sw_len;\r\n} else {\r\nrecvl = descr->hw_len;\r\n}\r\ndescr->status = 0;\r\nDFLOW( DEBUG_LOG(info->line, "RX %lu\n", recvl);\r\nif (info->port.tty->stopped) {\r\nunsigned char *buf = phys_to_virt(descr->buf);\r\nDEBUG_LOG(info->line, "rx 0x%02X\n", buf[0]);\r\nDEBUG_LOG(info->line, "rx 0x%02X\n", buf[1]);\r\nDEBUG_LOG(info->line, "rx 0x%02X\n", buf[2]);\r\n}\r\n);\r\ninfo->icount.rx += recvl;\r\nret += handle_descr_data(info, descr, recvl);\r\n}\r\nreturn ret;\r\n}\r\nstatic void receive_chars_dma(struct e100_serial *info)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned char rstat;\r\n#ifdef CONFIG_SVINTO_SIM\r\nreturn;\r\n#endif\r\n*info->iclrintradr =\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_descr, do) |\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_eop, do);\r\ntty = info->port.tty;\r\nif (!tty)\r\nreturn;\r\n#ifdef SERIAL_HANDLE_EARLY_ERRORS\r\nif (info->uses_dma_in)\r\ne100_enable_serial_data_irq(info);\r\n#endif\r\nif (info->errorcode == ERRCODE_INSERT_BREAK)\r\nadd_char_and_flag(info, '\0', TTY_BREAK);\r\nhandle_all_descr_data(info);\r\nrstat = info->ioport[REG_STATUS];\r\nif (rstat & IO_MASK(R_SERIAL0_STATUS, xoff_detect) ) {\r\nDFLOW(DEBUG_LOG(info->line, "XOFF detect stat %x\n", rstat));\r\n}\r\nif (rstat & SER_ERROR_MASK) {\r\nunsigned char data = info->ioport[REG_DATA];\r\nPROCSTAT(ser_stat[info->line].errors_cnt++);\r\nDEBUG_LOG(info->line, "#dERR: s d 0x%04X\n",\r\n((rstat & SER_ERROR_MASK) << 8) | data);\r\nif (rstat & SER_PAR_ERR_MASK)\r\nadd_char_and_flag(info, data, TTY_PARITY);\r\nelse if (rstat & SER_OVERRUN_MASK)\r\nadd_char_and_flag(info, data, TTY_OVERRUN);\r\nelse if (rstat & SER_FRAMING_ERR_MASK)\r\nadd_char_and_flag(info, data, TTY_FRAME);\r\n}\r\nSTART_FLUSH_FAST_TIMER(info, "receive_chars");\r\n*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, restart);\r\n}\r\nstatic int start_recv_dma(struct e100_serial *info)\r\n{\r\nstruct etrax_dma_descr *descr = info->rec_descr;\r\nstruct etrax_recv_buffer *buffer;\r\nint i;\r\nfor (i = 0; i < SERIAL_RECV_DESCRIPTORS; i++) {\r\nif (!(buffer = alloc_recv_buffer(SERIAL_DESCR_BUF_SIZE)))\r\npanic("%s: Failed to allocate memory for receive buffer!\n", __func__);\r\ndescr[i].ctrl = d_int;\r\ndescr[i].buf = virt_to_phys(buffer->buffer);\r\ndescr[i].sw_len = SERIAL_DESCR_BUF_SIZE;\r\ndescr[i].hw_len = 0;\r\ndescr[i].status = 0;\r\ndescr[i].next = virt_to_phys(&descr[i+1]);\r\n}\r\ndescr[i-1].next = virt_to_phys(&descr[0]);\r\ninfo->cur_rec_descr = 0;\r\n*info->ifirstadr = virt_to_phys(&descr[info->cur_rec_descr]);\r\n*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, start);\r\nreturn 1;\r\n}\r\nstatic void\r\nstart_receive(struct e100_serial *info)\r\n{\r\n#ifdef CONFIG_SVINTO_SIM\r\nreturn;\r\n#endif\r\nif (info->uses_dma_in) {\r\n*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, reset);\r\nwhile (IO_EXTRACT(R_DMA_CH6_CMD, cmd, *info->icmdadr) ==\r\nIO_STATE_VALUE(R_DMA_CH6_CMD, cmd, reset));\r\nstart_recv_dma(info);\r\n}\r\n}\r\nstatic irqreturn_t\r\ntr_interrupt(int irq, void *dev_id)\r\n{\r\nstruct e100_serial *info;\r\nunsigned long ireg;\r\nint i;\r\nint handled = 0;\r\n#ifdef CONFIG_SVINTO_SIM\r\n{\r\nconst char *s = "What? tr_interrupt in simulator??\n";\r\nSIMCOUT(s,strlen(s));\r\n}\r\nreturn IRQ_HANDLED;\r\n#endif\r\nireg = *R_IRQ_MASK2_RD;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\ninfo = rs_table + i;\r\nif (!info->enabled || !info->uses_dma_out)\r\ncontinue;\r\nif (ireg & info->irq) {\r\nhandled = 1;\r\nDINTR2(DEBUG_LOG(info->line, "tr_interrupt %i\n", i));\r\nPROCSTAT(ser_stat[info->line].tx_dma_ints++);\r\ninfo->last_tx_active_usec = GET_JIFFIES_USEC();\r\ninfo->last_tx_active = jiffies;\r\ntransmit_chars_dma(info);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic irqreturn_t\r\nrec_interrupt(int irq, void *dev_id)\r\n{\r\nstruct e100_serial *info;\r\nunsigned long ireg;\r\nint i;\r\nint handled = 0;\r\n#ifdef CONFIG_SVINTO_SIM\r\n{\r\nconst char *s = "What? rec_interrupt in simulator??\n";\r\nSIMCOUT(s,strlen(s));\r\n}\r\nreturn IRQ_HANDLED;\r\n#endif\r\nireg = *R_IRQ_MASK2_RD;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\ninfo = rs_table + i;\r\nif (!info->enabled || !info->uses_dma_in)\r\ncontinue;\r\nif (ireg & ((info->irq << 2) | (info->irq << 3))) {\r\nhandled = 1;\r\nreceive_chars_dma(info);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int force_eop_if_needed(struct e100_serial *info)\r\n{\r\nunsigned char rstat = info->ioport[REG_STATUS];\r\nif (rstat & SER_ERROR_MASK) {\r\nDEBUG_LOG(info->line, "timeout err: rstat 0x%03X\n",\r\nrstat | (info->line << 8));\r\nreturn 0;\r\n}\r\nif (rstat & SER_DATA_AVAIL_MASK) {\r\nTIMERD(DEBUG_LOG(info->line, "timeout: rstat 0x%03X\n",\r\nrstat | (info->line << 8)));\r\n(void)info->ioport[REG_DATA];\r\ninfo->forced_eop = 0;\r\nSTART_FLUSH_FAST_TIMER(info, "magic");\r\nreturn 0;\r\n}\r\nif (!info->forced_eop) {\r\ninfo->forced_eop = 1;\r\nPROCSTAT(ser_stat[info->line].timeout_flush_cnt++);\r\nTIMERD(DEBUG_LOG(info->line, "timeout EOP %i\n", info->line));\r\nFORCE_EOP(info);\r\n}\r\nreturn 1;\r\n}\r\nstatic void flush_to_flip_buffer(struct e100_serial *info)\r\n{\r\nstruct tty_struct *tty;\r\nstruct etrax_recv_buffer *buffer;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ntty = info->port.tty;\r\nif (!tty) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nwhile ((buffer = info->first_recv_buffer) != NULL) {\r\nunsigned int count = buffer->length;\r\ntty_insert_flip_string(tty, buffer->buffer, count);\r\ninfo->recv_cnt -= count;\r\nif (count == buffer->length) {\r\ninfo->first_recv_buffer = buffer->next;\r\nkfree(buffer);\r\n} else {\r\nbuffer->length -= count;\r\nmemmove(buffer->buffer, buffer->buffer + count, buffer->length);\r\nbuffer->error = TTY_NORMAL;\r\n}\r\n}\r\nif (!info->first_recv_buffer)\r\ninfo->last_recv_buffer = NULL;\r\nlocal_irq_restore(flags);\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void check_flush_timeout(struct e100_serial *info)\r\n{\r\nflush_to_flip_buffer(info);\r\nif (info->first_recv_buffer)\r\nSTART_FLUSH_FAST_TIMER_TIME(info, "flip", 2000);\r\nforce_eop_if_needed(info);\r\n}\r\nstatic void flush_timeout_function(unsigned long data)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)data;\r\nfast_timers[info->line].function = NULL;\r\nserial_fast_timer_expired++;\r\nTIMERD(DEBUG_LOG(info->line, "flush_timout %i ", info->line));\r\nTIMERD(DEBUG_LOG(info->line, "num expired: %i\n", serial_fast_timer_expired));\r\ncheck_flush_timeout(info);\r\n}\r\nstatic void\r\ntimed_flush_handler(unsigned long ptr)\r\n{\r\nstruct e100_serial *info;\r\nint i;\r\n#ifdef CONFIG_SVINTO_SIM\r\nreturn;\r\n#endif\r\nfor (i = 0; i < NR_PORTS; i++) {\r\ninfo = rs_table + i;\r\nif (info->uses_dma_in)\r\ncheck_flush_timeout(info);\r\n}\r\nmod_timer(&flush_timer, jiffies + CONFIG_ETRAX_SERIAL_RX_TIMEOUT_TICKS);\r\n}\r\nstatic\r\nstruct e100_serial * handle_ser_rx_interrupt_no_dma(struct e100_serial *info)\r\n{\r\nunsigned long data_read;\r\nstruct tty_struct *tty = info->port.tty;\r\nif (!tty) {\r\nprintk("!NO TTY!\n");\r\nreturn info;\r\n}\r\ndata_read = *((unsigned long *)&info->ioport[REG_DATA_STATUS32]);\r\nmore_data:\r\nif (data_read & IO_MASK(R_SERIAL0_READ, xoff_detect) ) {\r\nDFLOW(DEBUG_LOG(info->line, "XOFF detect\n", 0));\r\n}\r\nDINTR2(DEBUG_LOG(info->line, "ser_rx %c\n", IO_EXTRACT(R_SERIAL0_READ, data_in, data_read)));\r\nif (data_read & ( IO_MASK(R_SERIAL0_READ, framing_err) |\r\nIO_MASK(R_SERIAL0_READ, par_err) |\r\nIO_MASK(R_SERIAL0_READ, overrun) )) {\r\ninfo->last_rx_active_usec = GET_JIFFIES_USEC();\r\ninfo->last_rx_active = jiffies;\r\nDINTR1(DEBUG_LOG(info->line, "ser_rx err stat_data %04X\n", data_read));\r\nDLOG_INT_TRIG(\r\nif (!log_int_trig1_pos) {\r\nlog_int_trig1_pos = log_int_pos;\r\nlog_int(rdpc(), 0, 0);\r\n}\r\n);\r\nif ( ((data_read & IO_MASK(R_SERIAL0_READ, data_in)) == 0) &&\r\n(data_read & IO_MASK(R_SERIAL0_READ, framing_err)) ) {\r\nif (!info->break_detected_cnt) {\r\nDEBUG_LOG(info->line, "#BRK start\n", 0);\r\n}\r\nif (data_read & IO_MASK(R_SERIAL0_READ, rxd)) {\r\nDEBUG_LOG(info->line, "# BL BRK\n", 0);\r\ninfo->errorcode = ERRCODE_INSERT_BREAK;\r\n}\r\ninfo->break_detected_cnt++;\r\n} else {\r\nif (info->break_detected_cnt) {\r\nDEBUG_LOG(info->line, "EBRK %i\n", info->break_detected_cnt);\r\ninfo->errorcode = ERRCODE_INSERT_BREAK;\r\n} else {\r\nunsigned char data = IO_EXTRACT(R_SERIAL0_READ,\r\ndata_in, data_read);\r\nchar flag = TTY_NORMAL;\r\nif (info->errorcode == ERRCODE_INSERT_BREAK) {\r\nstruct tty_struct *tty = info->port.tty;\r\ntty_insert_flip_char(tty, 0, flag);\r\ninfo->icount.rx++;\r\n}\r\nif (data_read & IO_MASK(R_SERIAL0_READ, par_err)) {\r\ninfo->icount.parity++;\r\nflag = TTY_PARITY;\r\n} else if (data_read & IO_MASK(R_SERIAL0_READ, overrun)) {\r\ninfo->icount.overrun++;\r\nflag = TTY_OVERRUN;\r\n} else if (data_read & IO_MASK(R_SERIAL0_READ, framing_err)) {\r\ninfo->icount.frame++;\r\nflag = TTY_FRAME;\r\n}\r\ntty_insert_flip_char(tty, data, flag);\r\ninfo->errorcode = 0;\r\n}\r\ninfo->break_detected_cnt = 0;\r\n}\r\n} else if (data_read & IO_MASK(R_SERIAL0_READ, data_avail)) {\r\nDLOG_INT_TRIG(\r\nif (!log_int_trig1_pos) {\r\nif (log_int_pos >= log_int_size) {\r\nlog_int_pos = 0;\r\n}\r\nlog_int_trig0_pos = log_int_pos;\r\nlog_int(rdpc(), 0, 0);\r\n}\r\n);\r\ntty_insert_flip_char(tty,\r\nIO_EXTRACT(R_SERIAL0_READ, data_in, data_read),\r\nTTY_NORMAL);\r\n} else {\r\nDEBUG_LOG(info->line, "ser_rx int but no data_avail %08lX\n", data_read);\r\n}\r\ninfo->icount.rx++;\r\ndata_read = *((unsigned long *)&info->ioport[REG_DATA_STATUS32]);\r\nif (data_read & IO_MASK(R_SERIAL0_READ, data_avail)) {\r\nDEBUG_LOG(info->line, "ser_rx %c in loop\n", IO_EXTRACT(R_SERIAL0_READ, data_in, data_read));\r\ngoto more_data;\r\n}\r\ntty_flip_buffer_push(info->port.tty);\r\nreturn info;\r\n}\r\nstatic struct e100_serial* handle_ser_rx_interrupt(struct e100_serial *info)\r\n{\r\nunsigned char rstat;\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("Interrupt from serport %d\n", i);\r\n#endif\r\nif (!info->uses_dma_in) {\r\nreturn handle_ser_rx_interrupt_no_dma(info);\r\n}\r\nrstat = info->ioport[REG_STATUS];\r\nif (rstat & IO_MASK(R_SERIAL0_STATUS, xoff_detect) ) {\r\nDFLOW(DEBUG_LOG(info->line, "XOFF detect\n", 0));\r\n}\r\nif (rstat & SER_ERROR_MASK) {\r\nunsigned char data;\r\ninfo->last_rx_active_usec = GET_JIFFIES_USEC();\r\ninfo->last_rx_active = jiffies;\r\ndata = info->ioport[REG_DATA];\r\nDINTR1(DEBUG_LOG(info->line, "ser_rx! %c\n", data));\r\nDINTR1(DEBUG_LOG(info->line, "ser_rx err stat %02X\n", rstat));\r\nif (!data && (rstat & SER_FRAMING_ERR_MASK)) {\r\nif (!info->break_detected_cnt) {\r\nDEBUG_LOG(info->line, "#BRK start\n", 0);\r\n}\r\nif (rstat & SER_RXD_MASK) {\r\nDEBUG_LOG(info->line, "# BL BRK\n", 0);\r\ninfo->errorcode = ERRCODE_INSERT_BREAK;\r\n}\r\ninfo->break_detected_cnt++;\r\n} else {\r\nif (info->break_detected_cnt) {\r\nDEBUG_LOG(info->line, "EBRK %i\n", info->break_detected_cnt);\r\ninfo->errorcode = ERRCODE_INSERT_BREAK;\r\n} else {\r\nif (info->errorcode == ERRCODE_INSERT_BREAK) {\r\ninfo->icount.brk++;\r\nadd_char_and_flag(info, '\0', TTY_BREAK);\r\n}\r\nif (rstat & SER_PAR_ERR_MASK) {\r\ninfo->icount.parity++;\r\nadd_char_and_flag(info, data, TTY_PARITY);\r\n} else if (rstat & SER_OVERRUN_MASK) {\r\ninfo->icount.overrun++;\r\nadd_char_and_flag(info, data, TTY_OVERRUN);\r\n} else if (rstat & SER_FRAMING_ERR_MASK) {\r\ninfo->icount.frame++;\r\nadd_char_and_flag(info, data, TTY_FRAME);\r\n}\r\ninfo->errorcode = 0;\r\n}\r\ninfo->break_detected_cnt = 0;\r\nDEBUG_LOG(info->line, "#iERR s d %04X\n",\r\n((rstat & SER_ERROR_MASK) << 8) | data);\r\n}\r\nPROCSTAT(ser_stat[info->line].early_errors_cnt++);\r\n} else {\r\nunsigned long curr_time_u = GET_JIFFIES_USEC();\r\nunsigned long curr_time = jiffies;\r\nif (info->break_detected_cnt) {\r\nlong elapsed_usec =\r\n(curr_time - info->last_rx_active) * (1000000/HZ) +\r\ncurr_time_u - info->last_rx_active_usec;\r\nif (elapsed_usec < 2*info->char_time_usec) {\r\nDEBUG_LOG(info->line, "FBRK %i\n", info->line);\r\ninfo->errorcode = ERRCODE_SET_BREAK;\r\n} else {\r\nDEBUG_LOG(info->line, "Not end of BRK (V)%i\n", info->line);\r\n}\r\nDEBUG_LOG(info->line, "num brk %i\n", info->break_detected_cnt);\r\n}\r\n#ifdef SERIAL_DEBUG_INTR\r\nprintk("** OK, disabling ser_interrupts\n");\r\n#endif\r\ne100_disable_serial_data_irq(info);\r\nDINTR2(DEBUG_LOG(info->line, "ser_rx OK %d\n", info->line));\r\ninfo->break_detected_cnt = 0;\r\nPROCSTAT(ser_stat[info->line].ser_ints_ok_cnt++);\r\n}\r\n*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, restart);\r\nSTART_FLUSH_FAST_TIMER(info, "ser_int");\r\nreturn info;\r\n}\r\nstatic void handle_ser_tx_interrupt(struct e100_serial *info)\r\n{\r\nunsigned long flags;\r\nif (info->x_char) {\r\nunsigned char rstat;\r\nDFLOW(DEBUG_LOG(info->line, "tx_int: xchar 0x%02X\n", info->x_char));\r\nlocal_irq_save(flags);\r\nrstat = info->ioport[REG_STATUS];\r\nDFLOW(DEBUG_LOG(info->line, "stat %x\n", rstat));\r\ninfo->ioport[REG_TR_DATA] = info->x_char;\r\ninfo->icount.tx++;\r\ninfo->x_char = 0;\r\ne100_enable_serial_tx_ready_irq(info);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nif (info->uses_dma_out) {\r\nunsigned char rstat;\r\nint i;\r\nDFLOW(DEBUG_LOG(info->line, "tx_int: xchar sent\n", 0));\r\nlocal_irq_save(flags);\r\nrstat = info->ioport[REG_STATUS];\r\nDFLOW(DEBUG_LOG(info->line, "stat %x\n", rstat));\r\ne100_disable_serial_tx_ready_irq(info);\r\nif (info->port.tty->stopped)\r\nrs_stop(info->port.tty);\r\ne100_enable_txdma_channel(info);\r\nfor(i = 6; i > 0; i--)\r\nnop();\r\n*info->ocmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, continue);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nif (info->xmit.head == info->xmit.tail\r\n|| info->port.tty->stopped\r\n|| info->port.tty->hw_stopped) {\r\nDFLOW(DEBUG_LOG(info->line, "tx_int: stopped %i\n",\r\ninfo->port.tty->stopped));\r\ne100_disable_serial_tx_ready_irq(info);\r\ninfo->tr_running = 0;\r\nreturn;\r\n}\r\nDINTR2(DEBUG_LOG(info->line, "tx_int %c\n", info->xmit.buf[info->xmit.tail]));\r\nlocal_irq_save(flags);\r\ninfo->ioport[REG_TR_DATA] = info->xmit.buf[info->xmit.tail];\r\ninfo->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);\r\ninfo->icount.tx++;\r\nif (info->xmit.head == info->xmit.tail) {\r\n#if defined(CONFIG_ETRAX_RS485) && defined(CONFIG_ETRAX_FAST_TIMER)\r\nif (info->rs485.flags & SER_RS485_ENABLED) {\r\nstart_one_shot_timer(&fast_timers_rs485[info->line],\r\nrs485_toggle_rts_timer_function,\r\n(unsigned long)info,\r\ninfo->char_time_usec*2,\r\n"RS-485");\r\n}\r\n#endif\r\ninfo->last_tx_active_usec = GET_JIFFIES_USEC();\r\ninfo->last_tx_active = jiffies;\r\ne100_disable_serial_tx_ready_irq(info);\r\ninfo->tr_running = 0;\r\nDFLOW(DEBUG_LOG(info->line, "tx_int: stop2\n", 0));\r\n} else {\r\ne100_enable_serial_tx_ready_irq(info);\r\n}\r\nlocal_irq_restore(flags);\r\nif (CIRC_CNT(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE) < WAKEUP_CHARS)\r\nrs_sched_event(info, RS_EVENT_WRITE_WAKEUP);\r\n}\r\nstatic irqreturn_t\r\nser_interrupt(int irq, void *dev_id)\r\n{\r\nstatic volatile int tx_started = 0;\r\nstruct e100_serial *info;\r\nint i;\r\nunsigned long flags;\r\nunsigned long irq_mask1_rd;\r\nunsigned long data_mask = (1 << (8+2*0));\r\nint handled = 0;\r\nstatic volatile unsigned long reentered_ready_mask = 0;\r\nlocal_irq_save(flags);\r\nirq_mask1_rd = *R_IRQ_MASK1_RD;\r\ninfo = rs_table;\r\nirq_mask1_rd &= e100_ser_int_mask;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nif (irq_mask1_rd & data_mask) {\r\nhandled = 1;\r\nhandle_ser_rx_interrupt(info);\r\n}\r\ninfo += 1;\r\ndata_mask <<= 2;\r\n}\r\nif (!tx_started) {\r\nunsigned long ready_mask;\r\nunsigned long\r\ntx_started = 1;\r\nirq_mask1_rd &= (IO_MASK(R_IRQ_MASK1_RD, ser0_ready) |\r\nIO_MASK(R_IRQ_MASK1_RD, ser1_ready) |\r\nIO_MASK(R_IRQ_MASK1_RD, ser2_ready) |\r\nIO_MASK(R_IRQ_MASK1_RD, ser3_ready));\r\nwhile (irq_mask1_rd) {\r\n*R_IRQ_MASK1_CLR = irq_mask1_rd;\r\n*R_VECT_MASK_SET = IO_STATE(R_VECT_MASK_SET, serial, set);\r\nlocal_irq_enable();\r\nready_mask = (1 << (8+1+2*0));\r\ninfo = rs_table;\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nif (irq_mask1_rd & ready_mask) {\r\nhandled = 1;\r\nhandle_ser_tx_interrupt(info);\r\n}\r\ninfo += 1;\r\nready_mask <<= 2;\r\n}\r\nlocal_irq_disable();\r\nirq_mask1_rd = reentered_ready_mask;\r\n}\r\nlocal_irq_disable();\r\ntx_started = 0;\r\n} else {\r\nunsigned long ready_mask;\r\nready_mask = irq_mask1_rd & (IO_MASK(R_IRQ_MASK1_RD, ser0_ready) |\r\nIO_MASK(R_IRQ_MASK1_RD, ser1_ready) |\r\nIO_MASK(R_IRQ_MASK1_RD, ser2_ready) |\r\nIO_MASK(R_IRQ_MASK1_RD, ser3_ready));\r\nif (ready_mask) {\r\nreentered_ready_mask |= ready_mask;\r\n*R_IRQ_MASK1_CLR = ready_mask;\r\nDFLOW(DEBUG_LOG(SERIAL_DEBUG_LINE, "ser_int reentered with TX %X\n", ready_mask));\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void\r\ndo_softint(struct work_struct *work)\r\n{\r\nstruct e100_serial *info;\r\nstruct tty_struct *tty;\r\ninfo = container_of(work, struct e100_serial, work);\r\ntty = info->port.tty;\r\nif (!tty)\r\nreturn;\r\nif (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event))\r\ntty_wakeup(tty);\r\n}\r\nstatic int\r\nstartup(struct e100_serial * info)\r\n{\r\nunsigned long flags;\r\nunsigned long xmit_page;\r\nint i;\r\nxmit_page = get_zeroed_page(GFP_KERNEL);\r\nif (!xmit_page)\r\nreturn -ENOMEM;\r\nlocal_irq_save(flags);\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nlocal_irq_restore(flags);\r\nfree_page(xmit_page);\r\nreturn 0;\r\n}\r\nif (info->xmit.buf)\r\nfree_page(xmit_page);\r\nelse\r\ninfo->xmit.buf = (unsigned char *) xmit_page;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("starting up ttyS%d (xmit_buf 0x%p)...\n", info->line, info->xmit.buf);\r\n#endif\r\n#ifdef CONFIG_SVINTO_SIM\r\nif (info->port.tty)\r\nclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\ninfo->first_recv_buffer = info->last_recv_buffer = NULL;\r\ninfo->recv_cnt = info->max_recv_cnt = 0;\r\nfor (i = 0; i < SERIAL_RECV_DESCRIPTORS; i++)\r\ninfo->rec_descr[i].buf = NULL;\r\nchange_speed(info);\r\n#else\r\nif (info->dma_in_enabled) {\r\ninfo->uses_dma_in = 1;\r\ne100_enable_rxdma_channel(info);\r\n*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, reset);\r\nwhile (IO_EXTRACT(R_DMA_CH6_CMD, cmd, *info->icmdadr) ==\r\nIO_STATE_VALUE(R_DMA_CH6_CMD, cmd, reset));\r\n*info->iclrintradr =\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_descr, do) |\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_eop, do);\r\n} else {\r\ne100_disable_rxdma_channel(info);\r\n}\r\nif (info->dma_out_enabled) {\r\ninfo->uses_dma_out = 1;\r\ne100_enable_txdma_channel(info);\r\n*info->ocmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, reset);\r\nwhile (IO_EXTRACT(R_DMA_CH6_CMD, cmd, *info->ocmdadr) ==\r\nIO_STATE_VALUE(R_DMA_CH6_CMD, cmd, reset));\r\n*info->oclrintradr =\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_descr, do) |\r\nIO_STATE(R_DMA_CH6_CLR_INTR, clr_eop, do);\r\n} else {\r\ne100_disable_txdma_channel(info);\r\n}\r\nif (info->port.tty)\r\nclear_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\ninfo->first_recv_buffer = info->last_recv_buffer = NULL;\r\ninfo->recv_cnt = info->max_recv_cnt = 0;\r\nfor (i = 0; i < SERIAL_RECV_DESCRIPTORS; i++)\r\ninfo->rec_descr[i].buf = 0;\r\n#ifdef SERIAL_HANDLE_EARLY_ERRORS\r\ne100_enable_serial_data_irq(info);\r\n#endif\r\nchange_speed(info);\r\n(void)info->ioport[REG_DATA];\r\nif (info->uses_dma_out)\r\ne100_enable_txdma_irq(info);\r\ne100_enable_rx_irq(info);\r\ninfo->tr_running = 0;\r\nstart_receive(info);\r\ninfo->tr_descr.sw_len = 0;\r\ninfo->tr_descr.hw_len = 0;\r\ninfo->tr_descr.status = 0;\r\ne100_rts(info, 1);\r\ne100_dtr(info, 1);\r\n#endif\r\ninfo->flags |= ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nshutdown(struct e100_serial * info)\r\n{\r\nunsigned long flags;\r\nstruct etrax_dma_descr *descr = info->rec_descr;\r\nstruct etrax_recv_buffer *buffer;\r\nint i;\r\n#ifndef CONFIG_SVINTO_SIM\r\nDFLOW(DEBUG_LOG(info->line, "shutdown %i\n", info->line));\r\ne100_disable_rx(info);\r\ninfo->ioport[REG_TR_CTRL] = (info->tx_ctrl &= ~0x40);\r\nif (info->uses_dma_in) {\r\ne100_disable_rxdma_irq(info);\r\n*info->icmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, reset);\r\ninfo->uses_dma_in = 0;\r\n} else {\r\ne100_disable_serial_data_irq(info);\r\n}\r\nif (info->uses_dma_out) {\r\ne100_disable_txdma_irq(info);\r\ninfo->tr_running = 0;\r\n*info->ocmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, reset);\r\ninfo->uses_dma_out = 0;\r\n} else {\r\ne100_disable_serial_tx_ready_irq(info);\r\ninfo->tr_running = 0;\r\n}\r\n#endif\r\nif (!(info->flags & ASYNC_INITIALIZED))\r\nreturn;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("Shutting down serial port %d (irq %d)....\n", info->line,\r\ninfo->irq);\r\n#endif\r\nlocal_irq_save(flags);\r\nif (info->xmit.buf) {\r\nfree_page((unsigned long)info->xmit.buf);\r\ninfo->xmit.buf = NULL;\r\n}\r\nfor (i = 0; i < SERIAL_RECV_DESCRIPTORS; i++)\r\nif (descr[i].buf) {\r\nbuffer = phys_to_virt(descr[i].buf) - sizeof *buffer;\r\nkfree(buffer);\r\ndescr[i].buf = 0;\r\n}\r\nif (!info->port.tty || (info->port.tty->termios.c_cflag & HUPCL)) {\r\ne100_dtr(info, 0);\r\ne100_rts(info, 0);\r\n}\r\nif (info->port.tty)\r\nset_bit(TTY_IO_ERROR, &info->port.tty->flags);\r\ninfo->flags &= ~ASYNC_INITIALIZED;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nchange_speed(struct e100_serial *info)\r\n{\r\nunsigned int cflag;\r\nunsigned long xoff;\r\nunsigned long flags;\r\nif (!info->port.tty)\r\nreturn;\r\nif (!info->ioport)\r\nreturn;\r\ncflag = info->port.tty->termios.c_cflag;\r\nif ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST) {\r\nu32 mask = 0xFF << (info->line*8);\r\nunsigned long alt_source =\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_rec, normal) |\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_tr, normal);\r\nDBAUD(printk("Custom baudrate: baud_base/divisor %lu/%i\n",\r\n(unsigned long)info->baud_base, info->custom_divisor));\r\nif (info->baud_base == SERIAL_PRESCALE_BASE) {\r\nu16 divisor = info->custom_divisor;\r\nalt_source =\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_rec, prescale) |\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_tr, prescale);\r\nalt_source = 0x11;\r\nDBAUD(printk("Writing SERIAL_PRESCALE: divisor %i\n", divisor));\r\n*R_SERIAL_PRESCALE = divisor;\r\ninfo->baud = SERIAL_PRESCALE_BASE/divisor;\r\n}\r\n#ifdef CONFIG_ETRAX_EXTERN_PB6CLK_ENABLED\r\nelse if ((info->baud_base==CONFIG_ETRAX_EXTERN_PB6CLK_FREQ/8 &&\r\ninfo->custom_divisor == 1) ||\r\n(info->baud_base==CONFIG_ETRAX_EXTERN_PB6CLK_FREQ &&\r\ninfo->custom_divisor == 8)) {\r\nalt_source =\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_rec, extern) |\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_tr, extern);\r\nDBAUD(printk("using external baudrate: %lu\n", CONFIG_ETRAX_EXTERN_PB6CLK_FREQ/8));\r\ninfo->baud = CONFIG_ETRAX_EXTERN_PB6CLK_FREQ/8;\r\n}\r\n#endif\r\nelse\r\n{\r\nprintk(KERN_WARNING "Bad baud_base/custom_divisor: %lu/%i\n",\r\n(unsigned long)info->baud_base, info->custom_divisor);\r\n}\r\nr_alt_ser_baudrate_shadow &= ~mask;\r\nr_alt_ser_baudrate_shadow |= (alt_source << (info->line*8));\r\n*R_ALT_SER_BAUDRATE = r_alt_ser_baudrate_shadow;\r\n} else {\r\nu32 mask = 0xFF << (info->line*8);\r\nunsigned long alt_source =\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_rec, normal) |\r\nIO_STATE(R_ALT_SER_BAUDRATE, ser0_tr, normal);\r\nr_alt_ser_baudrate_shadow &= ~mask;\r\nr_alt_ser_baudrate_shadow |= (alt_source << (info->line*8));\r\n#ifndef CONFIG_SVINTO_SIM\r\n*R_ALT_SER_BAUDRATE = r_alt_ser_baudrate_shadow;\r\n#endif\r\ninfo->baud = cflag_to_baud(cflag);\r\n#ifndef CONFIG_SVINTO_SIM\r\ninfo->ioport[REG_BAUD] = cflag_to_etrax_baud(cflag);\r\n#endif\r\n}\r\n#ifndef CONFIG_SVINTO_SIM\r\nlocal_irq_save(flags);\r\ninfo->rx_ctrl &= ~(IO_MASK(R_SERIAL0_REC_CTRL, rec_bitnr) |\r\nIO_MASK(R_SERIAL0_REC_CTRL, rec_par_en) |\r\nIO_MASK(R_SERIAL0_REC_CTRL, rec_par));\r\ninfo->tx_ctrl &= ~(IO_MASK(R_SERIAL0_TR_CTRL, tr_bitnr) |\r\nIO_MASK(R_SERIAL0_TR_CTRL, tr_par_en) |\r\nIO_MASK(R_SERIAL0_TR_CTRL, tr_par) |\r\nIO_MASK(R_SERIAL0_TR_CTRL, stop_bits) |\r\nIO_MASK(R_SERIAL0_TR_CTRL, auto_cts));\r\nif ((cflag & CSIZE) == CS7) {\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_bitnr, tr_7bit);\r\ninfo->rx_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_bitnr, rec_7bit);\r\n}\r\nif (cflag & CSTOPB) {\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, stop_bits, two_bits);\r\n}\r\nif (cflag & PARENB) {\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_par_en, enable);\r\ninfo->rx_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_par_en, enable);\r\n}\r\nif (cflag & CMSPAR) {\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_stick_par, stick);\r\ninfo->rx_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_stick_par, stick);\r\n}\r\nif (cflag & PARODD) {\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_par, odd);\r\ninfo->rx_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_par, odd);\r\n}\r\nif (cflag & CRTSCTS) {\r\nDFLOW(DEBUG_LOG(info->line, "FLOW auto_cts enabled\n", 0));\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, auto_cts, active);\r\n}\r\ninfo->tx_ctrl |= IO_STATE(R_SERIAL0_TR_CTRL, tr_enable, enable);\r\ninfo->rx_ctrl |= IO_STATE(R_SERIAL0_REC_CTRL, rec_enable, enable);\r\ninfo->ioport[REG_TR_CTRL] = info->tx_ctrl;\r\ninfo->ioport[REG_REC_CTRL] = info->rx_ctrl;\r\nxoff = IO_FIELD(R_SERIAL0_XOFF, xoff_char, STOP_CHAR(info->port.tty));\r\nxoff |= IO_STATE(R_SERIAL0_XOFF, tx_stop, enable);\r\nif (info->port.tty->termios.c_iflag & IXON ) {\r\nDFLOW(DEBUG_LOG(info->line, "FLOW XOFF enabled 0x%02X\n",\r\nSTOP_CHAR(info->port.tty)));\r\nxoff |= IO_STATE(R_SERIAL0_XOFF, auto_xoff, enable);\r\n}\r\n*((unsigned long *)&info->ioport[REG_XOFF]) = xoff;\r\nlocal_irq_restore(flags);\r\n#endif\r\nupdate_char_time(info);\r\n}\r\nstatic void\r\nrs_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nif (info->tr_running ||\r\ninfo->xmit.head == info->xmit.tail ||\r\ntty->stopped ||\r\ntty->hw_stopped ||\r\n!info->xmit.buf)\r\nreturn;\r\n#ifdef SERIAL_DEBUG_FLOW\r\nprintk("rs_flush_chars\n");\r\n#endif\r\nlocal_irq_save(flags);\r\nstart_transmit(info);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int rs_raw_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint c, ret = 0;\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nif (!tty || !info->xmit.buf)\r\nreturn 0;\r\n#ifdef SERIAL_DEBUG_DATA\r\nif (info->line == SERIAL_DEBUG_LINE)\r\nprintk("rs_raw_write (%d), status %d\n",\r\ncount, info->ioport[REG_STATUS]);\r\n#endif\r\n#ifdef CONFIG_SVINTO_SIM\r\nSIMCOUT(buf, count);\r\nreturn count;\r\n#endif\r\nlocal_save_flags(flags);\r\nDFLOW(DEBUG_LOG(info->line, "write count %i ", count));\r\nDFLOW(DEBUG_LOG(info->line, "ldisc %i\n", tty->ldisc.chars_in_buffer(tty)));\r\nlocal_irq_disable();\r\nwhile (count) {\r\nc = CIRC_SPACE_TO_END(info->xmit.head,\r\ninfo->xmit.tail,\r\nSERIAL_XMIT_SIZE);\r\nif (count < c)\r\nc = count;\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(info->xmit.buf + info->xmit.head, buf, c);\r\ninfo->xmit.head = (info->xmit.head + c) &\r\n(SERIAL_XMIT_SIZE-1);\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nlocal_irq_restore(flags);\r\nDFLOW(DEBUG_LOG(info->line, "write ret %i\n", ret));\r\nif (info->xmit.head != info->xmit.tail &&\r\n!tty->stopped &&\r\n!tty->hw_stopped &&\r\n!info->tr_running) {\r\nstart_transmit(info);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nrs_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\n#if defined(CONFIG_ETRAX_RS485)\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nif (info->rs485.flags & SER_RS485_ENABLED)\r\n{\r\n#ifdef CONFIG_ETRAX_FAST_TIMER\r\nfast_timers_rs485[info->line].function = NULL;\r\ndel_fast_timer(&fast_timers_rs485[info->line]);\r\n#endif\r\ne100_rts(info, (info->rs485.flags & SER_RS485_RTS_ON_SEND));\r\n#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)\r\ne100_disable_rx(info);\r\ne100_enable_rx_irq(info);\r\n#endif\r\nif (info->rs485.delay_rts_before_send > 0)\r\nmsleep(info->rs485.delay_rts_before_send);\r\n}\r\n#endif\r\ncount = rs_raw_write(tty, buf, count);\r\n#if defined(CONFIG_ETRAX_RS485)\r\nif (info->rs485.flags & SER_RS485_ENABLED)\r\n{\r\nunsigned int val;\r\ntty_wait_until_sent(tty, 0);\r\n#ifdef CONFIG_ETRAX_FAST_TIMER\r\nschedule_usleep(info->char_time_usec * 2);\r\n#endif\r\ndo{\r\nget_lsr_info(info, &val);\r\n}while (!(val & TIOCSER_TEMT));\r\ne100_rts(info, (info->rs485.flags & SER_RS485_RTS_AFTER_SEND));\r\n#if defined(CONFIG_ETRAX_RS485_DISABLE_RECEIVER)\r\ne100_enable_rx(info);\r\ne100_enable_rxdma_irq(info);\r\n#endif\r\n}\r\n#endif\r\nreturn count;\r\n}\r\nstatic int\r\nrs_write_room(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nreturn CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic int\r\nrs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nreturn CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic void\r\nrs_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nlocal_irq_restore(flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void rs_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (info->uses_dma_out) {\r\n*info->ocmdadr = IO_STATE(R_DMA_CH6_CMD, cmd, hold);\r\nwhile (IO_EXTRACT(R_DMA_CH6_CMD, cmd, *info->ocmdadr) !=\r\nIO_STATE_VALUE(R_DMA_CH6_CMD, cmd, hold));\r\ne100_disable_txdma_channel(info);\r\n}\r\nif (tty->stopped)\r\nrs_start(tty);\r\nDFLOW(DEBUG_LOG(info->line, "rs_send_xchar 0x%02X\n", ch));\r\ninfo->x_char = ch;\r\ne100_enable_serial_tx_ready_irq(info);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nrs_throttle(struct tty_struct * tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk("throttle %s: %lu....\n", tty_name(tty, buf),\r\n(unsigned long)tty->ldisc.chars_in_buffer(tty));\r\n#endif\r\nDFLOW(DEBUG_LOG(info->line,"rs_throttle %lu\n", tty->ldisc.chars_in_buffer(tty)));\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\ne100_rts(info, 0);\r\n}\r\nif (I_IXOFF(tty))\r\nrs_send_xchar(tty, STOP_CHAR(tty));\r\n}\r\nstatic void\r\nrs_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\n#ifdef SERIAL_DEBUG_THROTTLE\r\nchar buf[64];\r\nprintk("unthrottle %s: %lu....\n", tty_name(tty, buf),\r\n(unsigned long)tty->ldisc.chars_in_buffer(tty));\r\n#endif\r\nDFLOW(DEBUG_LOG(info->line,"rs_unthrottle ldisc %d\n", tty->ldisc.chars_in_buffer(tty)));\r\nDFLOW(DEBUG_LOG(info->line,"rs_unthrottle flip.count: %i\n", tty->flip.count));\r\nif (tty->termios.c_cflag & CRTSCTS) {\r\ne100_rts(info, 1);\r\n}\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nrs_send_xchar(tty, START_CHAR(tty));\r\n}\r\n}\r\nstatic int\r\nget_serial_info(struct e100_serial * info,\r\nstruct serial_struct * retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = info->type;\r\ntmp.line = info->line;\r\ntmp.port = (int)info->ioport;\r\ntmp.irq = info->irq;\r\ntmp.flags = info->flags;\r\ntmp.baud_base = info->baud_base;\r\ntmp.close_delay = info->close_delay;\r\ntmp.closing_wait = info->closing_wait;\r\ntmp.custom_divisor = info->custom_divisor;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nset_serial_info(struct e100_serial *info,\r\nstruct serial_struct *new_info)\r\n{\r\nstruct serial_struct new_serial;\r\nstruct e100_serial old_info;\r\nint retval = 0;\r\nif (copy_from_user(&new_serial, new_info, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nold_info = *info;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((new_serial.type != info->type) ||\r\n(new_serial.close_delay != info->close_delay) ||\r\n((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(info->flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\ninfo->flags = ((info->flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\ngoto check_and_exit;\r\n}\r\nif (info->count > 1)\r\nreturn -EBUSY;\r\ninfo->baud_base = new_serial.baud_base;\r\ninfo->flags = ((info->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\ninfo->custom_divisor = new_serial.custom_divisor;\r\ninfo->type = new_serial.type;\r\ninfo->close_delay = new_serial.close_delay;\r\ninfo->closing_wait = new_serial.closing_wait;\r\ninfo->port.tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\ncheck_and_exit:\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nchange_speed(info);\r\n} else\r\nretval = startup(info);\r\nreturn retval;\r\n}\r\nstatic int\r\nget_lsr_info(struct e100_serial * info, unsigned int *value)\r\n{\r\nunsigned int result = TIOCSER_TEMT;\r\n#ifndef CONFIG_SVINTO_SIM\r\nunsigned long curr_time = jiffies;\r\nunsigned long curr_time_usec = GET_JIFFIES_USEC();\r\nunsigned long elapsed_usec =\r\n(curr_time - info->last_tx_active) * 1000000/HZ +\r\ncurr_time_usec - info->last_tx_active_usec;\r\nif (info->xmit.head != info->xmit.tail ||\r\nelapsed_usec < 2*info->char_time_usec) {\r\nresult = 0;\r\n}\r\n#endif\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nchar *get_control_state_str(int MLines, char *s)\r\n{\r\nint i = 0;\r\ns[0]='\0';\r\nwhile (control_state_str[i].str != NULL) {\r\nif (MLines & control_state_str[i].state) {\r\nif (s[0] != '\0') {\r\nstrcat(s, ", ");\r\n}\r\nstrcat(s, control_state_str[i].str);\r\n}\r\ni++;\r\n}\r\nreturn s;\r\n}\r\nstatic int\r\nrs_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nif (!info->ioport)\r\nreturn -EIO;\r\nlocal_irq_save(flags);\r\nif (break_state == -1) {\r\ninfo->tx_ctrl &= 0x3F;\r\n} else {\r\ninfo->tx_ctrl |= (0x80 | 0x40);\r\n}\r\ninfo->ioport[REG_TR_CTRL] = info->tx_ctrl;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nrs_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (clear & TIOCM_RTS)\r\ne100_rts(info, 0);\r\nif (clear & TIOCM_DTR)\r\ne100_dtr(info, 0);\r\nif (clear & TIOCM_RI)\r\ne100_ri_out(info, 0);\r\nif (clear & TIOCM_CD)\r\ne100_cd_out(info, 0);\r\nif (set & TIOCM_RTS)\r\ne100_rts(info, 1);\r\nif (set & TIOCM_DTR)\r\ne100_dtr(info, 1);\r\nif (set & TIOCM_RI)\r\ne100_ri_out(info, 1);\r\nif (set & TIOCM_CD)\r\ne100_cd_out(info, 1);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nrs_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned int result;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nresult =\r\n(!E100_RTS_GET(info) ? TIOCM_RTS : 0)\r\n| (!E100_DTR_GET(info) ? TIOCM_DTR : 0)\r\n| (!E100_RI_GET(info) ? TIOCM_RNG : 0)\r\n| (!E100_DSR_GET(info) ? TIOCM_DSR : 0)\r\n| (!E100_CD_GET(info) ? TIOCM_CAR : 0)\r\n| (!E100_CTS_GET(info) ? TIOCM_CTS : 0);\r\nlocal_irq_restore(flags);\r\n#ifdef SERIAL_DEBUG_IO\r\nprintk(KERN_DEBUG "ser%i: modem state: %i 0x%08X\n",\r\ninfo->line, result, result);\r\n{\r\nchar s[100];\r\nget_control_state_str(result, s);\r\nprintk(KERN_DEBUG "state: %s\n", s);\r\n}\r\n#endif\r\nreturn result;\r\n}\r\nstatic int\r\nrs_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct e100_serial * info = (struct e100_serial *)tty->driver_data;\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD) &&\r\n(cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(info,\r\n(struct serial_struct *) arg);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(info,\r\n(struct serial_struct *) arg);\r\ncase TIOCSERGETLSR:\r\nreturn get_lsr_info(info, (unsigned int *) arg);\r\ncase TIOCSERGSTRUCT:\r\nif (copy_to_user((struct e100_serial *) arg,\r\ninfo, sizeof(struct e100_serial)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n#if defined(CONFIG_ETRAX_RS485)\r\ncase TIOCSERSETRS485:\r\n{\r\nstruct rs485_control rs485ctrl;\r\nstruct serial_rs485 rs485data;\r\nprintk(KERN_DEBUG "The use of this ioctl is deprecated. Use TIOCSRS485 instead\n");\r\nif (copy_from_user(&rs485ctrl, (struct rs485_control *)arg,\r\nsizeof(rs485ctrl)))\r\nreturn -EFAULT;\r\nrs485data.delay_rts_before_send = rs485ctrl.delay_rts_before_send;\r\nrs485data.flags = 0;\r\nif (rs485ctrl.enabled)\r\nrs485data.flags |= SER_RS485_ENABLED;\r\nelse\r\nrs485data.flags &= ~(SER_RS485_ENABLED);\r\nif (rs485ctrl.rts_on_send)\r\nrs485data.flags |= SER_RS485_RTS_ON_SEND;\r\nelse\r\nrs485data.flags &= ~(SER_RS485_RTS_ON_SEND);\r\nif (rs485ctrl.rts_after_sent)\r\nrs485data.flags |= SER_RS485_RTS_AFTER_SEND;\r\nelse\r\nrs485data.flags &= ~(SER_RS485_RTS_AFTER_SEND);\r\nreturn e100_enable_rs485(tty, &rs485data);\r\n}\r\ncase TIOCSRS485:\r\n{\r\nstruct serial_rs485 rs485data;\r\nif (copy_from_user(&rs485data, (struct rs485_control *)arg,\r\nsizeof(rs485data)))\r\nreturn -EFAULT;\r\nreturn e100_enable_rs485(tty, &rs485data);\r\n}\r\ncase TIOCGRS485:\r\n{\r\nstruct serial_rs485 *rs485data =\r\n&(((struct e100_serial *)tty->driver_data)->rs485);\r\nif (copy_to_user((struct serial_rs485 *) arg,\r\nrs485data,\r\nsizeof(struct serial_rs485)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase TIOCSERWRRS485:\r\n{\r\nstruct rs485_write rs485wr;\r\nif (copy_from_user(&rs485wr, (struct rs485_write *)arg,\r\nsizeof(rs485wr)))\r\nreturn -EFAULT;\r\nreturn e100_write_rs485(tty, rs485wr.outc, rs485wr.outc_size);\r\n}\r\n#endif\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nrs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nchange_speed(info);\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios.c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nrs_start(tty);\r\n}\r\n}\r\nstatic void\r\nrs_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct e100_serial * info = (struct e100_serial *)tty->driver_data;\r\nunsigned long flags;\r\nif (!info)\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (tty_hung_up_p(filp)) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("[%d] rs_close ttyS%d, count = %d\n", current->pid,\r\ninfo->line, info->count);\r\n#endif\r\nif ((tty->count == 1) && (info->count != 1)) {\r\nprintk(KERN_ERR\r\n"rs_close: bad serial port count; tty->count is 1, "\r\n"info->count is %d\n", info->count);\r\ninfo->count = 1;\r\n}\r\nif (--info->count < 0) {\r\nprintk(KERN_ERR "rs_close: bad serial port count for ttyS%d: %d\n",\r\ninfo->line, info->count);\r\ninfo->count = 0;\r\n}\r\nif (info->count) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\ninfo->flags |= ASYNC_CLOSING;\r\nif (info->flags & ASYNC_NORMAL_ACTIVE)\r\ninfo->normal_termios = tty->termios;\r\ntty->closing = 1;\r\nif (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)\r\ntty_wait_until_sent(tty, info->closing_wait);\r\n#ifdef SERIAL_HANDLE_EARLY_ERRORS\r\ne100_disable_serial_data_irq(info);\r\n#endif\r\n#ifndef CONFIG_SVINTO_SIM\r\ne100_disable_rx(info);\r\ne100_disable_rx_irq(info);\r\nif (info->flags & ASYNC_INITIALIZED) {\r\nrs_wait_until_sent(tty, HZ);\r\n}\r\n#endif\r\nshutdown(info);\r\nrs_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ntty->closing = 0;\r\ninfo->event = 0;\r\ninfo->port.tty = NULL;\r\nif (info->blocked_open) {\r\nif (info->close_delay)\r\nschedule_timeout_interruptible(info->close_delay);\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\ninfo->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);\r\nwake_up_interruptible(&info->close_wait);\r\nlocal_irq_restore(flags);\r\n#if defined(CONFIG_ETRAX_RS485)\r\nif (info->rs485.flags & SER_RS485_ENABLED) {\r\ninfo->rs485.flags &= ~(SER_RS485_ENABLED);\r\n#if defined(CONFIG_ETRAX_RS485_ON_PA)\r\n*R_PORT_PA_DATA = port_pa_data_shadow &= ~(1 << rs485_pa_bit);\r\n#endif\r\n#if defined(CONFIG_ETRAX_RS485_ON_PORT_G)\r\nREG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow,\r\nrs485_port_g_bit, 0);\r\n#endif\r\n#if defined(CONFIG_ETRAX_RS485_LTC1387)\r\nREG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow,\r\nCONFIG_ETRAX_RS485_LTC1387_DXEN_PORT_G_BIT, 0);\r\nREG_SHADOW_SET(R_PORT_G_DATA, port_g_data_shadow,\r\nCONFIG_ETRAX_RS485_LTC1387_RXEN_PORT_G_BIT, 0);\r\n#endif\r\n}\r\n#endif\r\nif (info->dma_in_enabled) {\r\nfree_irq(info->dma_in_irq_nbr, info);\r\ncris_free_dma(info->dma_in_nbr, info->dma_in_irq_description);\r\ninfo->uses_dma_in = 0;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk(KERN_DEBUG "DMA irq '%s' freed\n",\r\ninfo->dma_in_irq_description);\r\n#endif\r\n}\r\nif (info->dma_out_enabled) {\r\nfree_irq(info->dma_out_irq_nbr, info);\r\ncris_free_dma(info->dma_out_nbr, info->dma_out_irq_description);\r\ninfo->uses_dma_out = 0;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk(KERN_DEBUG "DMA irq '%s' freed\n",\r\ninfo->dma_out_irq_description);\r\n#endif\r\n}\r\n}\r\nstatic void rs_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nunsigned long orig_jiffies;\r\nstruct e100_serial *info = (struct e100_serial *)tty->driver_data;\r\nunsigned long curr_time = jiffies;\r\nunsigned long curr_time_usec = GET_JIFFIES_USEC();\r\nlong elapsed_usec =\r\n(curr_time - info->last_tx_active) * (1000000/HZ) +\r\ncurr_time_usec - info->last_tx_active_usec;\r\norig_jiffies = jiffies;\r\nwhile (info->xmit.head != info->xmit.tail ||\r\n(*info->ostatusadr & 0x007f) ||\r\n(elapsed_usec < 2*info->char_time_usec)) {\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\ncurr_time = jiffies;\r\ncurr_time_usec = GET_JIFFIES_USEC();\r\nelapsed_usec =\r\n(curr_time - info->last_tx_active) * (1000000/HZ) +\r\ncurr_time_usec - info->last_tx_active_usec;\r\n}\r\nset_current_state(TASK_RUNNING);\r\n}\r\nvoid\r\nrs_hangup(struct tty_struct *tty)\r\n{\r\nstruct e100_serial * info = (struct e100_serial *)tty->driver_data;\r\nrs_flush_buffer(tty);\r\nshutdown(info);\r\ninfo->event = 0;\r\ninfo->count = 0;\r\ninfo->flags &= ~ASYNC_NORMAL_ACTIVE;\r\ninfo->port.tty = NULL;\r\nwake_up_interruptible(&info->open_wait);\r\n}\r\nstatic int\r\nblock_til_ready(struct tty_struct *tty, struct file * filp,\r\nstruct e100_serial *info)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nint retval;\r\nint do_clocal = 0, extra_count = 0;\r\nif (tty_hung_up_p(filp) ||\r\n(info->flags & ASYNC_CLOSING)) {\r\nwait_event_interruptible_tty(tty, info->close_wait,\r\n!(info->flags & ASYNC_CLOSING));\r\n#ifdef SERIAL_DO_RESTART\r\nif (info->flags & ASYNC_HUP_NOTIFY)\r\nreturn -EAGAIN;\r\nelse\r\nreturn -ERESTARTSYS;\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nif ((filp->f_flags & O_NONBLOCK) ||\r\n(tty->flags & (1 << TTY_IO_ERROR))) {\r\ninfo->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nif (tty->termios.c_cflag & CLOCAL) {\r\ndo_clocal = 1;\r\n}\r\nretval = 0;\r\nadd_wait_queue(&info->open_wait, &wait);\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready before block: ttyS%d, count = %d\n",\r\ninfo->line, info->count);\r\n#endif\r\nlocal_irq_save(flags);\r\nif (!tty_hung_up_p(filp)) {\r\nextra_count++;\r\ninfo->count--;\r\n}\r\nlocal_irq_restore(flags);\r\ninfo->blocked_open++;\r\nwhile (1) {\r\nlocal_irq_save(flags);\r\ne100_rts(info, 1);\r\ne100_dtr(info, 1);\r\nlocal_irq_restore(flags);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (tty_hung_up_p(filp) ||\r\n!(info->flags & ASYNC_INITIALIZED)) {\r\n#ifdef SERIAL_DO_RESTART\r\nif (info->flags & ASYNC_HUP_NOTIFY)\r\nretval = -EAGAIN;\r\nelse\r\nretval = -ERESTARTSYS;\r\n#else\r\nretval = -EAGAIN;\r\n#endif\r\nbreak;\r\n}\r\nif (!(info->flags & ASYNC_CLOSING) && do_clocal)\r\nbreak;\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready blocking: ttyS%d, count = %d\n",\r\ninfo->line, info->count);\r\n#endif\r\ntty_unlock(tty);\r\nschedule();\r\ntty_lock(tty);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&info->open_wait, &wait);\r\nif (extra_count)\r\ninfo->count++;\r\ninfo->blocked_open--;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("block_til_ready after blocking: ttyS%d, count = %d\n",\r\ninfo->line, info->count);\r\n#endif\r\nif (retval)\r\nreturn retval;\r\ninfo->flags |= ASYNC_NORMAL_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic void\r\ndeinit_port(struct e100_serial *info)\r\n{\r\nif (info->dma_out_enabled) {\r\ncris_free_dma(info->dma_out_nbr, info->dma_out_irq_description);\r\nfree_irq(info->dma_out_irq_nbr, info);\r\n}\r\nif (info->dma_in_enabled) {\r\ncris_free_dma(info->dma_in_nbr, info->dma_in_irq_description);\r\nfree_irq(info->dma_in_irq_nbr, info);\r\n}\r\n}\r\nstatic int\r\nrs_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct e100_serial *info;\r\nint retval;\r\nint allocated_resources = 0;\r\ninfo = rs_table + tty->index;\r\nif (!info->enabled)\r\nreturn -ENODEV;\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("[%d] rs_open %s, count = %d\n", current->pid, tty->name,\r\ninfo->count);\r\n#endif\r\ninfo->count++;\r\ntty->driver_data = info;\r\ninfo->port.tty = tty;\r\ntty->low_latency = !!(info->flags & ASYNC_LOW_LATENCY);\r\nif (tty_hung_up_p(filp) ||\r\n(info->flags & ASYNC_CLOSING)) {\r\nwait_event_interruptible_tty(tty, info->close_wait,\r\n!(info->flags & ASYNC_CLOSING));\r\n#ifdef SERIAL_DO_RESTART\r\nreturn ((info->flags & ASYNC_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\n#else\r\nreturn -EAGAIN;\r\n#endif\r\n}\r\nif (info->count == 1) {\r\nallocated_resources = 1;\r\nif (info->dma_in_enabled) {\r\nif (request_irq(info->dma_in_irq_nbr,\r\nrec_interrupt,\r\ninfo->dma_in_irq_flags,\r\ninfo->dma_in_irq_description,\r\ninfo)) {\r\nprintk(KERN_WARNING "DMA irq '%s' busy; "\r\n"falling back to non-DMA mode\n",\r\ninfo->dma_in_irq_description);\r\ninfo->dma_in_enabled = 0;\r\n} else if (cris_request_dma(info->dma_in_nbr,\r\ninfo->dma_in_irq_description,\r\nDMA_VERBOSE_ON_ERROR,\r\ninfo->dma_owner)) {\r\nfree_irq(info->dma_in_irq_nbr, info);\r\nprintk(KERN_WARNING "DMA '%s' busy; "\r\n"falling back to non-DMA mode\n",\r\ninfo->dma_in_irq_description);\r\ninfo->dma_in_enabled = 0;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nelse\r\nprintk(KERN_DEBUG "DMA irq '%s' allocated\n",\r\ninfo->dma_in_irq_description);\r\n#endif\r\n}\r\nif (info->dma_out_enabled) {\r\nif (request_irq(info->dma_out_irq_nbr,\r\ntr_interrupt,\r\ninfo->dma_out_irq_flags,\r\ninfo->dma_out_irq_description,\r\ninfo)) {\r\nprintk(KERN_WARNING "DMA irq '%s' busy; "\r\n"falling back to non-DMA mode\n",\r\ninfo->dma_out_irq_description);\r\ninfo->dma_out_enabled = 0;\r\n} else if (cris_request_dma(info->dma_out_nbr,\r\ninfo->dma_out_irq_description,\r\nDMA_VERBOSE_ON_ERROR,\r\ninfo->dma_owner)) {\r\nfree_irq(info->dma_out_irq_nbr, info);\r\nprintk(KERN_WARNING "DMA '%s' busy; "\r\n"falling back to non-DMA mode\n",\r\ninfo->dma_out_irq_description);\r\ninfo->dma_out_enabled = 0;\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nelse\r\nprintk(KERN_DEBUG "DMA irq '%s' allocated\n",\r\ninfo->dma_out_irq_description);\r\n#endif\r\n}\r\n}\r\nretval = startup(info);\r\nif (retval) {\r\nif (allocated_resources)\r\ndeinit_port(info);\r\nreturn retval;\r\n}\r\nretval = block_til_ready(tty, filp, info);\r\nif (retval) {\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open returning after block_til_ready with %d\n",\r\nretval);\r\n#endif\r\nif (allocated_resources)\r\ndeinit_port(info);\r\nreturn retval;\r\n}\r\nif ((info->count == 1) && (info->flags & ASYNC_SPLIT_TERMIOS)) {\r\ntty->termios = info->normal_termios;\r\nchange_speed(info);\r\n}\r\n#ifdef SERIAL_DEBUG_OPEN\r\nprintk("rs_open ttyS%d successful...\n", info->line);\r\n#endif\r\nDLOG_INT_TRIG( log_int_pos = 0);\r\nDFLIP( if (info->line == SERIAL_DEBUG_LINE) {\r\ninfo->icount.rx = 0;\r\n} );\r\nreturn 0;\r\n}\r\nstatic void seq_line_info(struct seq_file *m, struct e100_serial *info)\r\n{\r\nunsigned long tmp;\r\nseq_printf(m, "%d: uart:E100 port:%lX irq:%d",\r\ninfo->line, (unsigned long)info->ioport, info->irq);\r\nif (!info->ioport || (info->type == PORT_UNKNOWN)) {\r\nseq_printf(m, "\n");\r\nreturn;\r\n}\r\nseq_printf(m, " baud:%d", info->baud);\r\nseq_printf(m, " tx:%lu rx:%lu",\r\n(unsigned long)info->icount.tx,\r\n(unsigned long)info->icount.rx);\r\ntmp = CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\nif (tmp)\r\nseq_printf(m, " tx_pend:%lu/%lu",\r\n(unsigned long)tmp,\r\n(unsigned long)SERIAL_XMIT_SIZE);\r\nseq_printf(m, " rx_pend:%lu/%lu",\r\n(unsigned long)info->recv_cnt,\r\n(unsigned long)info->max_recv_cnt);\r\n#if 1\r\nif (info->port.tty) {\r\nif (info->port.tty->stopped)\r\nseq_printf(m, " stopped:%i",\r\n(int)info->port.tty->stopped);\r\nif (info->port.tty->hw_stopped)\r\nseq_printf(m, " hw_stopped:%i",\r\n(int)info->port.tty->hw_stopped);\r\n}\r\n{\r\nunsigned char rstat = info->ioport[REG_STATUS];\r\nif (rstat & IO_MASK(R_SERIAL0_STATUS, xoff_detect))\r\nseq_printf(m, " xoff_detect:1");\r\n}\r\n#endif\r\nif (info->icount.frame)\r\nseq_printf(m, " fe:%lu", (unsigned long)info->icount.frame);\r\nif (info->icount.parity)\r\nseq_printf(m, " pe:%lu", (unsigned long)info->icount.parity);\r\nif (info->icount.brk)\r\nseq_printf(m, " brk:%lu", (unsigned long)info->icount.brk);\r\nif (info->icount.overrun)\r\nseq_printf(m, " oe:%lu", (unsigned long)info->icount.overrun);\r\nif (!E100_RTS_GET(info))\r\nseq_puts(m, "|RTS");\r\nif (!E100_CTS_GET(info))\r\nseq_puts(m, "|CTS");\r\nif (!E100_DTR_GET(info))\r\nseq_puts(m, "|DTR");\r\nif (!E100_DSR_GET(info))\r\nseq_puts(m, "|DSR");\r\nif (!E100_CD_GET(info))\r\nseq_puts(m, "|CD");\r\nif (!E100_RI_GET(info))\r\nseq_puts(m, "|RI");\r\nseq_puts(m, "\n");\r\n}\r\nstatic int crisv10_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nseq_printf(m, "serinfo:1.0 driver:%s\n", serial_version);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nif (!rs_table[i].enabled)\r\ncontinue;\r\nseq_line_info(m, &rs_table[i]);\r\n}\r\n#ifdef DEBUG_LOG_INCLUDED\r\nfor (i = 0; i < debug_log_pos; i++) {\r\nseq_printf(m, "%-4i %lu.%lu ",\r\ni, debug_log[i].time,\r\ntimer_data_to_ns(debug_log[i].timer_data));\r\nseq_printf(m, debug_log[i].string, debug_log[i].value);\r\n}\r\nseq_printf(m, "debug_log %i/%i\n", i, DEBUG_LOG_SIZE);\r\ndebug_log_pos = 0;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int crisv10_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, crisv10_proc_show, NULL);\r\n}\r\nstatic void show_serial_version(void)\r\n{\r\nprintk(KERN_INFO\r\n"ETRAX 100LX serial-driver %s, "\r\n"(c) 2000-2004 Axis Communications AB\r\n",\r\n&serial_version[11]);\r\n}\r\nstatic int __init rs_init(void)\r\n{\r\nint i;\r\nstruct e100_serial *info;\r\nstruct tty_driver *driver = alloc_tty_driver(NR_PORTS);\r\nif (!driver)\r\nreturn -ENOMEM;\r\nshow_serial_version();\r\n#if !defined(CONFIG_ETRAX_SERIAL_FAST_TIMER)\r\nsetup_timer(&flush_timer, timed_flush_handler, 0);\r\nmod_timer(&flush_timer, jiffies + 5);\r\n#endif\r\n#if defined(CONFIG_ETRAX_RS485)\r\n#if defined(CONFIG_ETRAX_RS485_ON_PA)\r\nif (cris_io_interface_allocate_pins(if_serial_0, 'a', rs485_pa_bit,\r\nrs485_pa_bit)) {\r\nprintk(KERN_ERR "ETRAX100LX serial: Could not allocate "\r\n"RS485 pin\n");\r\nput_tty_driver(driver);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\n#if defined(CONFIG_ETRAX_RS485_ON_PORT_G)\r\nif (cris_io_interface_allocate_pins(if_serial_0, 'g', rs485_pa_bit,\r\nrs485_port_g_bit)) {\r\nprintk(KERN_ERR "ETRAX100LX serial: Could not allocate "\r\n"RS485 pin\n");\r\nput_tty_driver(driver);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\n#endif\r\ndriver->driver_name = "serial";\r\ndriver->name = "ttyS";\r\ndriver->major = TTY_MAJOR;\r\ndriver->minor_start = 64;\r\ndriver->type = TTY_DRIVER_TYPE_SERIAL;\r\ndriver->subtype = SERIAL_TYPE_NORMAL;\r\ndriver->init_termios = tty_std_termios;\r\ndriver->init_termios.c_cflag =\r\nB115200 | CS8 | CREAD | HUPCL | CLOCAL;\r\ndriver->init_termios.c_ispeed = 115200;\r\ndriver->init_termios.c_ospeed = 115200;\r\ndriver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(driver, &rs_ops);\r\nserial_driver = driver;\r\nfor (i = 0, info = rs_table; i < NR_PORTS; i++,info++) {\r\nif (info->enabled) {\r\nif (cris_request_io_interface(info->io_if,\r\ninfo->io_if_description)) {\r\nprintk(KERN_ERR "ETRAX100LX async serial: "\r\n"Could not allocate IO pins for "\r\n"%s, port %d\n",\r\ninfo->io_if_description, i);\r\ninfo->enabled = 0;\r\n}\r\n}\r\ntty_port_init(&info->port);\r\ninfo->uses_dma_in = 0;\r\ninfo->uses_dma_out = 0;\r\ninfo->line = i;\r\ninfo->port.tty = NULL;\r\ninfo->type = PORT_ETRAX;\r\ninfo->tr_running = 0;\r\ninfo->forced_eop = 0;\r\ninfo->baud_base = DEF_BAUD_BASE;\r\ninfo->custom_divisor = 0;\r\ninfo->flags = 0;\r\ninfo->close_delay = 5*HZ/10;\r\ninfo->closing_wait = 30*HZ;\r\ninfo->x_char = 0;\r\ninfo->event = 0;\r\ninfo->count = 0;\r\ninfo->blocked_open = 0;\r\ninfo->normal_termios = driver->init_termios;\r\ninit_waitqueue_head(&info->open_wait);\r\ninit_waitqueue_head(&info->close_wait);\r\ninfo->xmit.buf = NULL;\r\ninfo->xmit.tail = info->xmit.head = 0;\r\ninfo->first_recv_buffer = info->last_recv_buffer = NULL;\r\ninfo->recv_cnt = info->max_recv_cnt = 0;\r\ninfo->last_tx_active_usec = 0;\r\ninfo->last_tx_active = 0;\r\n#if defined(CONFIG_ETRAX_RS485)\r\ninfo->rs485.flags &= ~(SER_RS485_RTS_ON_SEND);\r\ninfo->rs485.flags |= SER_RS485_RTS_AFTER_SEND;\r\ninfo->rs485.delay_rts_before_send = 0;\r\ninfo->rs485.flags &= ~(SER_RS485_ENABLED);\r\n#endif\r\nINIT_WORK(&info->work, do_softint);\r\nif (info->enabled) {\r\nprintk(KERN_INFO "%s%d at %p is a builtin UART with DMA\n",\r\nserial_driver->name, info->line, info->ioport);\r\n}\r\ntty_port_link_device(&info->port, driver, i);\r\n}\r\nif (tty_register_driver(driver))\r\npanic("Couldn't register serial driver\n");\r\n#ifdef CONFIG_ETRAX_FAST_TIMER\r\n#ifdef CONFIG_ETRAX_SERIAL_FAST_TIMER\r\nmemset(fast_timers, 0, sizeof(fast_timers));\r\n#endif\r\n#ifdef CONFIG_ETRAX_RS485\r\nmemset(fast_timers_rs485, 0, sizeof(fast_timers_rs485));\r\n#endif\r\nfast_timer_init();\r\n#endif\r\n#ifndef CONFIG_SVINTO_SIM\r\n#ifndef CONFIG_ETRAX_KGDB\r\nif (request_irq(SERIAL_IRQ_NBR, ser_interrupt,\r\nIRQF_SHARED, "serial ", driver))\r\npanic("%s: Failed to request irq8", __func__);\r\n#endif\r\n#endif\r\nreturn 0;\r\n}
