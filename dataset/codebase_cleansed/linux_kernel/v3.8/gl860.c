static int gl860_build_control_table(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct ctrl *sd_ctrls;\r\nint nCtrls = 0;\r\nif (_MI1320_)\r\nsd_ctrls = sd_ctrls_mi1320;\r\nelse if (_MI2020_)\r\nsd_ctrls = sd_ctrls_mi2020;\r\nelse if (_OV2640_)\r\nsd_ctrls = sd_ctrls_ov2640;\r\nelse if (_OV9655_)\r\nsd_ctrls = sd_ctrls_ov9655;\r\nelse\r\nreturn 0;\r\nmemset(sd_ctrls, 0, GL860_NCTRLS * sizeof(struct ctrl));\r\nSET_MY_CTRL(V4L2_CID_BRIGHTNESS,\r\nV4L2_CTRL_TYPE_INTEGER, "Brightness", brightness)\r\nSET_MY_CTRL(V4L2_CID_SHARPNESS,\r\nV4L2_CTRL_TYPE_INTEGER, "Sharpness", sharpness)\r\nSET_MY_CTRL(V4L2_CID_CONTRAST,\r\nV4L2_CTRL_TYPE_INTEGER, "Contrast", contrast)\r\nSET_MY_CTRL(V4L2_CID_GAMMA,\r\nV4L2_CTRL_TYPE_INTEGER, "Gamma", gamma)\r\nSET_MY_CTRL(V4L2_CID_HUE,\r\nV4L2_CTRL_TYPE_INTEGER, "Palette", hue)\r\nSET_MY_CTRL(V4L2_CID_SATURATION,\r\nV4L2_CTRL_TYPE_INTEGER, "Saturation", saturation)\r\nSET_MY_CTRL(V4L2_CID_WHITE_BALANCE_TEMPERATURE,\r\nV4L2_CTRL_TYPE_INTEGER, "White Bal.", whitebal)\r\nSET_MY_CTRL(V4L2_CID_BACKLIGHT_COMPENSATION,\r\nV4L2_CTRL_TYPE_INTEGER, "Backlight" , backlight)\r\nSET_MY_CTRL(V4L2_CID_HFLIP,\r\nV4L2_CTRL_TYPE_BOOLEAN, "Mirror", mirror)\r\nSET_MY_CTRL(V4L2_CID_VFLIP,\r\nV4L2_CTRL_TYPE_BOOLEAN, "Flip", flip)\r\nSET_MY_CTRL(V4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CTRL_TYPE_BOOLEAN, "AC power 50Hz", AC50Hz)\r\nreturn nCtrls;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nu16 vendor_id, product_id;\r\nvendor_id = id->idVendor;\r\nproduct_id = id->idProduct;\r\nsd->nbRightUp = 1;\r\nsd->nbIm = -1;\r\nsd->sensor = 0xff;\r\nif (strcmp(sensor, "MI1320") == 0)\r\nsd->sensor = ID_MI1320;\r\nelse if (strcmp(sensor, "OV2640") == 0)\r\nsd->sensor = ID_OV2640;\r\nelse if (strcmp(sensor, "OV9655") == 0)\r\nsd->sensor = ID_OV9655;\r\nelse if (strcmp(sensor, "MI2020") == 0)\r\nsd->sensor = ID_MI2020;\r\nif (gl860_guess_sensor(gspca_dev, vendor_id, product_id) == -1)\r\nreturn -1;\r\ncam = &gspca_dev->cam;\r\nswitch (sd->sensor) {\r\ncase ID_MI1320:\r\ngspca_dev->sd_desc = &sd_desc_mi1320;\r\ncam->cam_mode = mi1320_mode;\r\ncam->nmodes = ARRAY_SIZE(mi1320_mode);\r\ndev_init_settings = mi1320_init_settings;\r\nbreak;\r\ncase ID_MI2020:\r\ngspca_dev->sd_desc = &sd_desc_mi2020;\r\ncam->cam_mode = mi2020_mode;\r\ncam->nmodes = ARRAY_SIZE(mi2020_mode);\r\ndev_init_settings = mi2020_init_settings;\r\nbreak;\r\ncase ID_OV2640:\r\ngspca_dev->sd_desc = &sd_desc_ov2640;\r\ncam->cam_mode = ov2640_mode;\r\ncam->nmodes = ARRAY_SIZE(ov2640_mode);\r\ndev_init_settings = ov2640_init_settings;\r\nbreak;\r\ncase ID_OV9655:\r\ngspca_dev->sd_desc = &sd_desc_ov9655;\r\ncam->cam_mode = ov9655_mode;\r\ncam->nmodes = ARRAY_SIZE(ov9655_mode);\r\ndev_init_settings = ov9655_init_settings;\r\nbreak;\r\n}\r\ndev_init_settings(gspca_dev);\r\nif (AC50Hz != 0xff)\r\n((struct sd *) gspca_dev)->vcur.AC50Hz = AC50Hz;\r\ngl860_build_control_table(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreturn sd->dev_init_at_startup(gspca_dev);\r\n}\r\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreturn sd->dev_configure_alt(gspca_dev);\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreturn sd->dev_init_pre_alt(gspca_dev);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!sd->gspca_dev.present)\r\nreturn;\r\nreturn sd->dev_post_unset_alt(gspca_dev);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstatic s32 nSkipped;\r\ns32 mode = (s32) gspca_dev->curr_mode;\r\ns32 nToSkip =\r\nsd->swapRB * (gspca_dev->cam.cam_mode[mode].bytesperline + 1);\r\nswitch (*(s16 *) data) {\r\ncase 0x0202:\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\nnSkipped = 0;\r\nif (sd->nbIm >= 0 && sd->nbIm < 10)\r\nsd->nbIm++;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\nbreak;\r\ndefault:\r\ndata += 2;\r\nlen -= 2;\r\nif (nSkipped + len <= nToSkip)\r\nnSkipped += len;\r\nelse {\r\nif (nSkipped < nToSkip && nSkipped + len > nToSkip) {\r\ndata += nToSkip - nSkipped;\r\nlen -= nToSkip - nSkipped;\r\nnSkipped = nToSkip + 1;\r\n}\r\ngspca_frame_add(gspca_dev,\r\nINTER_PACKET, data, len);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void sd_callback(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!_OV9655_) {\r\nu8 state;\r\nu8 upsideDown;\r\nctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0000, 1, (void *)&state);\r\nupsideDown = (state == 0xc8 || state == 0x40);\r\nif (upsideDown && sd->nbRightUp > -4) {\r\nif (sd->nbRightUp > 0)\r\nsd->nbRightUp = 0;\r\nif (sd->nbRightUp == -3) {\r\nsd->mirrorMask = 1;\r\nsd->waitSet = 1;\r\n}\r\nsd->nbRightUp--;\r\n}\r\nif (!upsideDown && sd->nbRightUp < 4) {\r\nif (sd->nbRightUp < 0)\r\nsd->nbRightUp = 0;\r\nif (sd->nbRightUp == 3) {\r\nsd->mirrorMask = 0;\r\nsd->waitSet = 1;\r\n}\r\nsd->nbRightUp++;\r\n}\r\n}\r\nif (sd->waitSet)\r\nsd->dev_camera_settings(gspca_dev);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id,\r\n&sd_desc_mi1320, sizeof(struct sd), THIS_MODULE);\r\n}\r\nstatic void sd_disconnect(struct usb_interface *intf)\r\n{\r\ngspca_disconnect(intf);\r\n}\r\nint gl860_RTx(struct gspca_dev *gspca_dev,\r\nunsigned char pref, u32 req, u16 val, u16 index,\r\ns32 len, void *pdata)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\ns32 r = 0;\r\nif (pref == 0x40) {\r\nif (len > 0) {\r\nmemcpy(gspca_dev->usb_buf, pdata, len);\r\nr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nreq, pref, val, index,\r\ngspca_dev->usb_buf,\r\nlen, 400 + 200 * (len > 1));\r\n} else {\r\nr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nreq, pref, val, index, NULL, len, 400);\r\n}\r\n} else {\r\nif (len > 0) {\r\nr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nreq, pref, val, index,\r\ngspca_dev->usb_buf,\r\nlen, 400 + 200 * (len > 1));\r\nmemcpy(pdata, gspca_dev->usb_buf, len);\r\n} else {\r\nr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nreq, pref, val, index, NULL, len, 400);\r\n}\r\n}\r\nif (r < 0)\r\npr_err("ctrl transfer failed %4d [p%02x r%d v%04x i%04x len%d]\n",\r\nr, pref, req, val, index, len);\r\nelse if (len > 1 && r < len)\r\nPDEBUG(D_ERR, "short ctrl transfer %d/%d", r, len);\r\nmsleep(1);\r\nreturn r;\r\n}\r\nint fetch_validx(struct gspca_dev *gspca_dev, struct validx *tbl, int len)\r\n{\r\nint n;\r\nfor (n = 0; n < len; n++) {\r\nif (tbl[n].idx != 0xffff)\r\nctrl_out(gspca_dev, 0x40, 1, tbl[n].val,\r\ntbl[n].idx, 0, NULL);\r\nelse if (tbl[n].val == 0xffff)\r\nbreak;\r\nelse\r\nmsleep(tbl[n].val);\r\n}\r\nreturn n;\r\n}\r\nint keep_on_fetching_validx(struct gspca_dev *gspca_dev, struct validx *tbl,\r\nint len, int n)\r\n{\r\nwhile (++n < len) {\r\nif (tbl[n].idx != 0xffff)\r\nctrl_out(gspca_dev, 0x40, 1, tbl[n].val, tbl[n].idx,\r\n0, NULL);\r\nelse if (tbl[n].val == 0xffff)\r\nbreak;\r\nelse\r\nmsleep(tbl[n].val);\r\n}\r\nreturn n;\r\n}\r\nvoid fetch_idxdata(struct gspca_dev *gspca_dev, struct idxdata *tbl, int len)\r\n{\r\nint n;\r\nfor (n = 0; n < len; n++) {\r\nif (memcmp(tbl[n].data, "\xff\xff\xff", 3) != 0)\r\nctrl_out(gspca_dev, 0x40, 3, 0x7a00, tbl[n].idx,\r\n3, tbl[n].data);\r\nelse\r\nmsleep(tbl[n].idx);\r\n}\r\n}\r\nstatic int gl860_guess_sensor(struct gspca_dev *gspca_dev,\r\nu16 vendor_id, u16 product_id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 probe, nb26, nb96, nOV, ntry;\r\nif (product_id == 0xf191)\r\nsd->sensor = ID_MI1320;\r\nif (sd->sensor == 0xff) {\r\nctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0004, 1, &probe);\r\nctrl_in(gspca_dev, 0xc0, 2, 0x0000, 0x0004, 1, &probe);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0000, 0x0000, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0010, 0x0010, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0008, 0x00c0, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0001, 0x00c1, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0001, 0x00c2, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0020, 0x0006, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x006a, 0x000d, 0, NULL);\r\nmsleep(56);\r\nPDEBUG(D_PROBE, "probing for sensor MI2020 or OVXXXX");\r\nnOV = 0;\r\nfor (ntry = 0; ntry < 4; ntry++) {\r\nctrl_out(gspca_dev, 0x40, 1, 0x0040, 0x0000, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x0063, 0x0006, 0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x7a00, 0x8030, 0, NULL);\r\nmsleep(10);\r\nctrl_in(gspca_dev, 0xc0, 2, 0x7a00, 0x8030, 1, &probe);\r\nPDEBUG(D_PROBE, "probe=0x%02x", probe);\r\nif (probe == 0xff)\r\nnOV++;\r\n}\r\nif (nOV) {\r\nPDEBUG(D_PROBE, "0xff -> OVXXXX");\r\nPDEBUG(D_PROBE, "probing for sensor OV2640 or OV9655");\r\nnb26 = nb96 = 0;\r\nfor (ntry = 0; ntry < 4; ntry++) {\r\nctrl_out(gspca_dev, 0x40, 1, 0x0040, 0x0000,\r\n0, NULL);\r\nmsleep(3);\r\nctrl_out(gspca_dev, 0x40, 1, 0x6000, 0x800a,\r\n0, NULL);\r\nmsleep(10);\r\nctrl_in(gspca_dev, 0xc0, 2, 0x6000, 0x800a,\r\n1, &probe);\r\nif (probe == 0x26 || probe == 0x40) {\r\nPDEBUG(D_PROBE,\r\n"probe=0x%02x -> OV2640",\r\nprobe);\r\nsd->sensor = ID_OV2640;\r\nnb26 += 4;\r\nbreak;\r\n}\r\nif (probe == 0x96 || probe == 0x55) {\r\nPDEBUG(D_PROBE,\r\n"probe=0x%02x -> OV9655",\r\nprobe);\r\nsd->sensor = ID_OV9655;\r\nnb96 += 4;\r\nbreak;\r\n}\r\nPDEBUG(D_PROBE, "probe=0x%02x", probe);\r\nif (probe == 0x00)\r\nnb26++;\r\nif (probe == 0xff)\r\nnb96++;\r\nmsleep(3);\r\n}\r\nif (nb26 < 4 && nb96 < 4)\r\nreturn -1;\r\n} else {\r\nPDEBUG(D_PROBE, "Not any 0xff -> MI2020");\r\nsd->sensor = ID_MI2020;\r\n}\r\n}\r\nif (_MI1320_) {\r\nPDEBUG(D_PROBE, "05e3:f191 sensor MI1320 (1.3M)");\r\n} else if (_MI2020_) {\r\nPDEBUG(D_PROBE, "05e3:0503 sensor MI2020 (2.0M)");\r\n} else if (_OV9655_) {\r\nPDEBUG(D_PROBE, "05e3:0503 sensor OV9655 (1.3M)");\r\n} else if (_OV2640_) {\r\nPDEBUG(D_PROBE, "05e3:0503 sensor OV2640 (2.0M)");\r\n} else {\r\nPDEBUG(D_PROBE, "***** Unknown sensor *****");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}
