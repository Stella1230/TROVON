static char *smk_fetch(const char *name, struct inode *ip, struct dentry *dp)\r\n{\r\nint rc;\r\nchar *buffer;\r\nchar *result = NULL;\r\nif (ip->i_op->getxattr == NULL)\r\nreturn NULL;\r\nbuffer = kzalloc(SMK_LONGLABEL, GFP_KERNEL);\r\nif (buffer == NULL)\r\nreturn NULL;\r\nrc = ip->i_op->getxattr(dp, name, buffer, SMK_LONGLABEL);\r\nif (rc > 0)\r\nresult = smk_import(buffer, rc);\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstruct inode_smack *new_inode_smack(char *smack)\r\n{\r\nstruct inode_smack *isp;\r\nisp = kzalloc(sizeof(struct inode_smack), GFP_NOFS);\r\nif (isp == NULL)\r\nreturn NULL;\r\nisp->smk_inode = smack;\r\nisp->smk_flags = 0;\r\nmutex_init(&isp->smk_lock);\r\nreturn isp;\r\n}\r\nstatic struct task_smack *new_task_smack(char *task, char *forked, gfp_t gfp)\r\n{\r\nstruct task_smack *tsp;\r\ntsp = kzalloc(sizeof(struct task_smack), gfp);\r\nif (tsp == NULL)\r\nreturn NULL;\r\ntsp->smk_task = task;\r\ntsp->smk_forked = forked;\r\nINIT_LIST_HEAD(&tsp->smk_rules);\r\nmutex_init(&tsp->smk_rules_lock);\r\nreturn tsp;\r\n}\r\nstatic int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,\r\ngfp_t gfp)\r\n{\r\nstruct smack_rule *nrp;\r\nstruct smack_rule *orp;\r\nint rc = 0;\r\nINIT_LIST_HEAD(nhead);\r\nlist_for_each_entry_rcu(orp, ohead, list) {\r\nnrp = kzalloc(sizeof(struct smack_rule), gfp);\r\nif (nrp == NULL) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\n*nrp = *orp;\r\nlist_add_rcu(&nrp->list, nhead);\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_ptrace_access_check(struct task_struct *ctp, unsigned int mode)\r\n{\r\nint rc;\r\nstruct smk_audit_info ad;\r\nchar *tsp;\r\nrc = cap_ptrace_access_check(ctp, mode);\r\nif (rc != 0)\r\nreturn rc;\r\ntsp = smk_of_task(task_security(ctp));\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\r\nsmk_ad_setfield_u_tsk(&ad, ctp);\r\nrc = smk_curacc(tsp, MAY_READWRITE, &ad);\r\nreturn rc;\r\n}\r\nstatic int smack_ptrace_traceme(struct task_struct *ptp)\r\n{\r\nint rc;\r\nstruct smk_audit_info ad;\r\nchar *tsp;\r\nrc = cap_ptrace_traceme(ptp);\r\nif (rc != 0)\r\nreturn rc;\r\ntsp = smk_of_task(task_security(ptp));\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\r\nsmk_ad_setfield_u_tsk(&ad, ptp);\r\nrc = smk_curacc(tsp, MAY_READWRITE, &ad);\r\nreturn rc;\r\n}\r\nstatic int smack_syslog(int typefrom_file)\r\n{\r\nint rc = 0;\r\nchar *sp = smk_of_current();\r\nif (smack_privileged(CAP_MAC_OVERRIDE))\r\nreturn 0;\r\nif (sp != smack_known_floor.smk_known)\r\nrc = -EACCES;\r\nreturn rc;\r\n}\r\nstatic int smack_sb_alloc_security(struct super_block *sb)\r\n{\r\nstruct superblock_smack *sbsp;\r\nsbsp = kzalloc(sizeof(struct superblock_smack), GFP_KERNEL);\r\nif (sbsp == NULL)\r\nreturn -ENOMEM;\r\nsbsp->smk_root = smack_known_floor.smk_known;\r\nsbsp->smk_default = smack_known_floor.smk_known;\r\nsbsp->smk_floor = smack_known_floor.smk_known;\r\nsbsp->smk_hat = smack_known_hat.smk_known;\r\nsbsp->smk_initialized = 0;\r\nsb->s_security = sbsp;\r\nreturn 0;\r\n}\r\nstatic void smack_sb_free_security(struct super_block *sb)\r\n{\r\nkfree(sb->s_security);\r\nsb->s_security = NULL;\r\n}\r\nstatic int smack_sb_copy_data(char *orig, char *smackopts)\r\n{\r\nchar *cp, *commap, *otheropts, *dp;\r\notheropts = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (otheropts == NULL)\r\nreturn -ENOMEM;\r\nfor (cp = orig, commap = orig; commap != NULL; cp = commap + 1) {\r\nif (strstr(cp, SMK_FSDEFAULT) == cp)\r\ndp = smackopts;\r\nelse if (strstr(cp, SMK_FSFLOOR) == cp)\r\ndp = smackopts;\r\nelse if (strstr(cp, SMK_FSHAT) == cp)\r\ndp = smackopts;\r\nelse if (strstr(cp, SMK_FSROOT) == cp)\r\ndp = smackopts;\r\nelse\r\ndp = otheropts;\r\ncommap = strchr(cp, ',');\r\nif (commap != NULL)\r\n*commap = '\0';\r\nif (*dp != '\0')\r\nstrcat(dp, ",");\r\nstrcat(dp, cp);\r\n}\r\nstrcpy(orig, otheropts);\r\nfree_page((unsigned long)otheropts);\r\nreturn 0;\r\n}\r\nstatic int smack_sb_kern_mount(struct super_block *sb, int flags, void *data)\r\n{\r\nstruct dentry *root = sb->s_root;\r\nstruct inode *inode = root->d_inode;\r\nstruct superblock_smack *sp = sb->s_security;\r\nstruct inode_smack *isp;\r\nchar *op;\r\nchar *commap;\r\nchar *nsp;\r\nif (sp->smk_initialized != 0)\r\nreturn 0;\r\nsp->smk_initialized = 1;\r\nfor (op = data; op != NULL; op = commap) {\r\ncommap = strchr(op, ',');\r\nif (commap != NULL)\r\n*commap++ = '\0';\r\nif (strncmp(op, SMK_FSHAT, strlen(SMK_FSHAT)) == 0) {\r\nop += strlen(SMK_FSHAT);\r\nnsp = smk_import(op, 0);\r\nif (nsp != NULL)\r\nsp->smk_hat = nsp;\r\n} else if (strncmp(op, SMK_FSFLOOR, strlen(SMK_FSFLOOR)) == 0) {\r\nop += strlen(SMK_FSFLOOR);\r\nnsp = smk_import(op, 0);\r\nif (nsp != NULL)\r\nsp->smk_floor = nsp;\r\n} else if (strncmp(op, SMK_FSDEFAULT,\r\nstrlen(SMK_FSDEFAULT)) == 0) {\r\nop += strlen(SMK_FSDEFAULT);\r\nnsp = smk_import(op, 0);\r\nif (nsp != NULL)\r\nsp->smk_default = nsp;\r\n} else if (strncmp(op, SMK_FSROOT, strlen(SMK_FSROOT)) == 0) {\r\nop += strlen(SMK_FSROOT);\r\nnsp = smk_import(op, 0);\r\nif (nsp != NULL)\r\nsp->smk_root = nsp;\r\n}\r\n}\r\nisp = inode->i_security;\r\nif (isp == NULL)\r\ninode->i_security = new_inode_smack(sp->smk_root);\r\nelse\r\nisp->smk_inode = sp->smk_root;\r\nreturn 0;\r\n}\r\nstatic int smack_sb_statfs(struct dentry *dentry)\r\n{\r\nstruct superblock_smack *sbp = dentry->d_sb->s_security;\r\nint rc;\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nrc = smk_curacc(sbp->smk_floor, MAY_READ, &ad);\r\nreturn rc;\r\n}\r\nstatic int smack_sb_mount(const char *dev_name, struct path *path,\r\nconst char *type, unsigned long flags, void *data)\r\n{\r\nstruct superblock_smack *sbp = path->dentry->d_sb->s_security;\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\r\nsmk_ad_setfield_u_fs_path(&ad, *path);\r\nreturn smk_curacc(sbp->smk_floor, MAY_WRITE, &ad);\r\n}\r\nstatic int smack_sb_umount(struct vfsmount *mnt, int flags)\r\n{\r\nstruct superblock_smack *sbp;\r\nstruct smk_audit_info ad;\r\nstruct path path;\r\npath.dentry = mnt->mnt_root;\r\npath.mnt = mnt;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\r\nsmk_ad_setfield_u_fs_path(&ad, path);\r\nsbp = path.dentry->d_sb->s_security;\r\nreturn smk_curacc(sbp->smk_floor, MAY_WRITE, &ad);\r\n}\r\nstatic int smack_bprm_set_creds(struct linux_binprm *bprm)\r\n{\r\nstruct inode *inode = bprm->file->f_path.dentry->d_inode;\r\nstruct task_smack *bsp = bprm->cred->security;\r\nstruct inode_smack *isp;\r\nint rc;\r\nrc = cap_bprm_set_creds(bprm);\r\nif (rc != 0)\r\nreturn rc;\r\nif (bprm->cred_prepared)\r\nreturn 0;\r\nisp = inode->i_security;\r\nif (isp->smk_task == NULL || isp->smk_task == bsp->smk_task)\r\nreturn 0;\r\nif (bprm->unsafe)\r\nreturn -EPERM;\r\nbsp->smk_task = isp->smk_task;\r\nbprm->per_clear |= PER_CLEAR_ON_SETID;\r\nreturn 0;\r\n}\r\nstatic void smack_bprm_committing_creds(struct linux_binprm *bprm)\r\n{\r\nstruct task_smack *bsp = bprm->cred->security;\r\nif (bsp->smk_task != bsp->smk_forked)\r\ncurrent->pdeath_signal = 0;\r\n}\r\nstatic int smack_bprm_secureexec(struct linux_binprm *bprm)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nint ret = cap_bprm_secureexec(bprm);\r\nif (!ret && (tsp->smk_task != tsp->smk_forked))\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic int smack_inode_alloc_security(struct inode *inode)\r\n{\r\ninode->i_security = new_inode_smack(smk_of_current());\r\nif (inode->i_security == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void smack_inode_free_security(struct inode *inode)\r\n{\r\nkfree(inode->i_security);\r\ninode->i_security = NULL;\r\n}\r\nstatic int smack_inode_init_security(struct inode *inode, struct inode *dir,\r\nconst struct qstr *qstr, char **name,\r\nvoid **value, size_t *len)\r\n{\r\nstruct smack_known *skp;\r\nstruct inode_smack *issp = inode->i_security;\r\nchar *csp = smk_of_current();\r\nchar *isp = smk_of_inode(inode);\r\nchar *dsp = smk_of_inode(dir);\r\nint may;\r\nif (name) {\r\n*name = kstrdup(XATTR_SMACK_SUFFIX, GFP_NOFS);\r\nif (*name == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (value) {\r\nskp = smk_find_entry(csp);\r\nrcu_read_lock();\r\nmay = smk_access_entry(csp, dsp, &skp->smk_rules);\r\nrcu_read_unlock();\r\nif (may > 0 && ((may & MAY_TRANSMUTE) != 0) &&\r\nsmk_inode_transmutable(dir)) {\r\nisp = dsp;\r\nissp->smk_flags |= SMK_INODE_CHANGED;\r\n}\r\n*value = kstrdup(isp, GFP_NOFS);\r\nif (*value == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (len)\r\n*len = strlen(isp) + 1;\r\nreturn 0;\r\n}\r\nstatic int smack_inode_link(struct dentry *old_dentry, struct inode *dir,\r\nstruct dentry *new_dentry)\r\n{\r\nchar *isp;\r\nstruct smk_audit_info ad;\r\nint rc;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\r\nisp = smk_of_inode(old_dentry->d_inode);\r\nrc = smk_curacc(isp, MAY_WRITE, &ad);\r\nif (rc == 0 && new_dentry->d_inode != NULL) {\r\nisp = smk_of_inode(new_dentry->d_inode);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\r\nrc = smk_curacc(isp, MAY_WRITE, &ad);\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_inode_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *ip = dentry->d_inode;\r\nstruct smk_audit_info ad;\r\nint rc;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nrc = smk_curacc(smk_of_inode(ip), MAY_WRITE, &ad);\r\nif (rc == 0) {\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, NULL);\r\nsmk_ad_setfield_u_fs_inode(&ad, dir);\r\nrc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_inode_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct smk_audit_info ad;\r\nint rc;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nrc = smk_curacc(smk_of_inode(dentry->d_inode), MAY_WRITE, &ad);\r\nif (rc == 0) {\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, NULL);\r\nsmk_ad_setfield_u_fs_inode(&ad, dir);\r\nrc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_inode_rename(struct inode *old_inode,\r\nstruct dentry *old_dentry,\r\nstruct inode *new_inode,\r\nstruct dentry *new_dentry)\r\n{\r\nint rc;\r\nchar *isp;\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\r\nisp = smk_of_inode(old_dentry->d_inode);\r\nrc = smk_curacc(isp, MAY_READWRITE, &ad);\r\nif (rc == 0 && new_dentry->d_inode != NULL) {\r\nisp = smk_of_inode(new_dentry->d_inode);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\r\nrc = smk_curacc(isp, MAY_READWRITE, &ad);\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_inode_permission(struct inode *inode, int mask)\r\n{\r\nstruct smk_audit_info ad;\r\nint no_block = mask & MAY_NOT_BLOCK;\r\nmask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);\r\nif (mask == 0)\r\nreturn 0;\r\nif (no_block)\r\nreturn -ECHILD;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\r\nsmk_ad_setfield_u_fs_inode(&ad, inode);\r\nreturn smk_curacc(smk_of_inode(inode), mask, &ad);\r\n}\r\nstatic int smack_inode_setattr(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nstruct smk_audit_info ad;\r\nif (iattr->ia_valid & ATTR_FORCE)\r\nreturn 0;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nreturn smk_curacc(smk_of_inode(dentry->d_inode), MAY_WRITE, &ad);\r\n}\r\nstatic int smack_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)\r\n{\r\nstruct smk_audit_info ad;\r\nstruct path path;\r\npath.dentry = dentry;\r\npath.mnt = mnt;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\r\nsmk_ad_setfield_u_fs_path(&ad, path);\r\nreturn smk_curacc(smk_of_inode(dentry->d_inode), MAY_READ, &ad);\r\n}\r\nstatic int smack_inode_setxattr(struct dentry *dentry, const char *name,\r\nconst void *value, size_t size, int flags)\r\n{\r\nstruct smk_audit_info ad;\r\nint rc = 0;\r\nif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKIPOUT) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nrc = -EPERM;\r\nif (size == 0 || size >= SMK_LONGLABEL ||\r\nsmk_import(value, size) == NULL)\r\nrc = -EINVAL;\r\n} else if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nrc = -EPERM;\r\nif (size != TRANS_TRUE_SIZE ||\r\nstrncmp(value, TRANS_TRUE, TRANS_TRUE_SIZE) != 0)\r\nrc = -EINVAL;\r\n} else\r\nrc = cap_inode_setxattr(dentry, name, value, size, flags);\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nif (rc == 0)\r\nrc = smk_curacc(smk_of_inode(dentry->d_inode), MAY_WRITE, &ad);\r\nreturn rc;\r\n}\r\nstatic void smack_inode_post_setxattr(struct dentry *dentry, const char *name,\r\nconst void *value, size_t size, int flags)\r\n{\r\nchar *nsp;\r\nstruct inode_smack *isp = dentry->d_inode->i_security;\r\nif (strcmp(name, XATTR_NAME_SMACK) == 0) {\r\nnsp = smk_import(value, size);\r\nif (nsp != NULL)\r\nisp->smk_inode = nsp;\r\nelse\r\nisp->smk_inode = smack_known_invalid.smk_known;\r\n} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0) {\r\nnsp = smk_import(value, size);\r\nif (nsp != NULL)\r\nisp->smk_task = nsp;\r\nelse\r\nisp->smk_task = smack_known_invalid.smk_known;\r\n} else if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\r\nnsp = smk_import(value, size);\r\nif (nsp != NULL)\r\nisp->smk_mmap = nsp;\r\nelse\r\nisp->smk_mmap = smack_known_invalid.smk_known;\r\n} else if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0)\r\nisp->smk_flags |= SMK_INODE_TRANSMUTE;\r\nreturn;\r\n}\r\nstatic int smack_inode_getxattr(struct dentry *dentry, const char *name)\r\n{\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nreturn smk_curacc(smk_of_inode(dentry->d_inode), MAY_READ, &ad);\r\n}\r\nstatic int smack_inode_removexattr(struct dentry *dentry, const char *name)\r\n{\r\nstruct inode_smack *isp;\r\nstruct smk_audit_info ad;\r\nint rc = 0;\r\nif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKIPOUT) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0 ||\r\nstrcmp(name, XATTR_NAME_SMACKMMAP)) {\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nrc = -EPERM;\r\n} else\r\nrc = cap_inode_removexattr(dentry, name);\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\r\nsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\r\nif (rc == 0)\r\nrc = smk_curacc(smk_of_inode(dentry->d_inode), MAY_WRITE, &ad);\r\nif (rc == 0) {\r\nisp = dentry->d_inode->i_security;\r\nisp->smk_task = NULL;\r\nisp->smk_mmap = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_inode_getsecurity(const struct inode *inode,\r\nconst char *name, void **buffer,\r\nbool alloc)\r\n{\r\nstruct socket_smack *ssp;\r\nstruct socket *sock;\r\nstruct super_block *sbp;\r\nstruct inode *ip = (struct inode *)inode;\r\nchar *isp;\r\nint ilen;\r\nint rc = 0;\r\nif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\r\nisp = smk_of_inode(inode);\r\nilen = strlen(isp) + 1;\r\n*buffer = isp;\r\nreturn ilen;\r\n}\r\nsbp = ip->i_sb;\r\nif (sbp->s_magic != SOCKFS_MAGIC)\r\nreturn -EOPNOTSUPP;\r\nsock = SOCKET_I(ip);\r\nif (sock == NULL || sock->sk == NULL)\r\nreturn -EOPNOTSUPP;\r\nssp = sock->sk->sk_security;\r\nif (strcmp(name, XATTR_SMACK_IPIN) == 0)\r\nisp = ssp->smk_in;\r\nelse if (strcmp(name, XATTR_SMACK_IPOUT) == 0)\r\nisp = ssp->smk_out;\r\nelse\r\nreturn -EOPNOTSUPP;\r\nilen = strlen(isp) + 1;\r\nif (rc == 0) {\r\n*buffer = isp;\r\nrc = ilen;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_inode_listsecurity(struct inode *inode, char *buffer,\r\nsize_t buffer_size)\r\n{\r\nint len = strlen(XATTR_NAME_SMACK);\r\nif (buffer != NULL && len <= buffer_size) {\r\nmemcpy(buffer, XATTR_NAME_SMACK, len);\r\nreturn len;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void smack_inode_getsecid(const struct inode *inode, u32 *secid)\r\n{\r\nstruct inode_smack *isp = inode->i_security;\r\n*secid = smack_to_secid(isp->smk_inode);\r\n}\r\nstatic int smack_file_permission(struct file *file, int mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic int smack_file_alloc_security(struct file *file)\r\n{\r\nfile->f_security = smk_of_current();\r\nreturn 0;\r\n}\r\nstatic void smack_file_free_security(struct file *file)\r\n{\r\nfile->f_security = NULL;\r\n}\r\nstatic int smack_file_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint rc = 0;\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\r\nsmk_ad_setfield_u_fs_path(&ad, file->f_path);\r\nif (_IOC_DIR(cmd) & _IOC_WRITE)\r\nrc = smk_curacc(file->f_security, MAY_WRITE, &ad);\r\nif (rc == 0 && (_IOC_DIR(cmd) & _IOC_READ))\r\nrc = smk_curacc(file->f_security, MAY_READ, &ad);\r\nreturn rc;\r\n}\r\nstatic int smack_file_lock(struct file *file, unsigned int cmd)\r\n{\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\r\nsmk_ad_setfield_u_fs_path(&ad, file->f_path);\r\nreturn smk_curacc(file->f_security, MAY_WRITE, &ad);\r\n}\r\nstatic int smack_file_fcntl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct smk_audit_info ad;\r\nint rc = 0;\r\nswitch (cmd) {\r\ncase F_GETLK:\r\ncase F_SETLK:\r\ncase F_SETLKW:\r\ncase F_SETOWN:\r\ncase F_SETSIG:\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\r\nsmk_ad_setfield_u_fs_path(&ad, file->f_path);\r\nrc = smk_curacc(file->f_security, MAY_WRITE, &ad);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_mmap_file(struct file *file,\r\nunsigned long reqprot, unsigned long prot,\r\nunsigned long flags)\r\n{\r\nstruct smack_known *skp;\r\nstruct smack_rule *srp;\r\nstruct task_smack *tsp;\r\nchar *sp;\r\nchar *msmack;\r\nchar *osmack;\r\nstruct inode_smack *isp;\r\nstruct dentry *dp;\r\nint may;\r\nint mmay;\r\nint tmay;\r\nint rc;\r\nif (file == NULL || file->f_dentry == NULL)\r\nreturn 0;\r\ndp = file->f_dentry;\r\nif (dp->d_inode == NULL)\r\nreturn 0;\r\nisp = dp->d_inode->i_security;\r\nif (isp->smk_mmap == NULL)\r\nreturn 0;\r\nmsmack = isp->smk_mmap;\r\ntsp = current_security();\r\nsp = smk_of_current();\r\nskp = smk_find_entry(sp);\r\nrc = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(srp, &skp->smk_rules, list) {\r\nosmack = srp->smk_object;\r\nif (msmack == osmack)\r\ncontinue;\r\nmay = smk_access_entry(srp->smk_subject, osmack,\r\n&tsp->smk_rules);\r\nif (may == -ENOENT)\r\nmay = srp->smk_access;\r\nelse\r\nmay &= srp->smk_access;\r\nif (may == 0)\r\ncontinue;\r\nskp = smk_find_entry(msmack);\r\nmmay = smk_access_entry(msmack, osmack, &skp->smk_rules);\r\nif (mmay == -ENOENT) {\r\nrc = -EACCES;\r\nbreak;\r\n}\r\ntmay = smk_access_entry(msmack, osmack, &tsp->smk_rules);\r\nif (tmay != -ENOENT)\r\nmmay &= tmay;\r\nif ((may | mmay) != mmay) {\r\nrc = -EACCES;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstatic int smack_file_set_fowner(struct file *file)\r\n{\r\nfile->f_security = smk_of_current();\r\nreturn 0;\r\n}\r\nstatic int smack_file_send_sigiotask(struct task_struct *tsk,\r\nstruct fown_struct *fown, int signum)\r\n{\r\nstruct file *file;\r\nint rc;\r\nchar *tsp = smk_of_task(tsk->cred->security);\r\nstruct smk_audit_info ad;\r\nfile = container_of(fown, struct file, f_owner);\r\nrc = smk_access(file->f_security, tsp, MAY_WRITE, NULL);\r\nif (rc != 0 && has_capability(tsk, CAP_MAC_OVERRIDE))\r\nrc = 0;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\r\nsmk_ad_setfield_u_tsk(&ad, tsk);\r\nsmack_log(file->f_security, tsp, MAY_WRITE, rc, &ad);\r\nreturn rc;\r\n}\r\nstatic int smack_file_receive(struct file *file)\r\n{\r\nint may = 0;\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\r\nsmk_ad_setfield_u_fs_path(&ad, file->f_path);\r\nif (file->f_mode & FMODE_READ)\r\nmay = MAY_READ;\r\nif (file->f_mode & FMODE_WRITE)\r\nmay |= MAY_WRITE;\r\nreturn smk_curacc(file->f_security, may, &ad);\r\n}\r\nstatic int smack_file_open(struct file *file, const struct cred *cred)\r\n{\r\nstruct inode_smack *isp = file->f_path.dentry->d_inode->i_security;\r\nfile->f_security = isp->smk_inode;\r\nreturn 0;\r\n}\r\nstatic int smack_cred_alloc_blank(struct cred *cred, gfp_t gfp)\r\n{\r\nstruct task_smack *tsp;\r\ntsp = new_task_smack(NULL, NULL, gfp);\r\nif (tsp == NULL)\r\nreturn -ENOMEM;\r\ncred->security = tsp;\r\nreturn 0;\r\n}\r\nstatic void smack_cred_free(struct cred *cred)\r\n{\r\nstruct task_smack *tsp = cred->security;\r\nstruct smack_rule *rp;\r\nstruct list_head *l;\r\nstruct list_head *n;\r\nif (tsp == NULL)\r\nreturn;\r\ncred->security = NULL;\r\nlist_for_each_safe(l, n, &tsp->smk_rules) {\r\nrp = list_entry(l, struct smack_rule, list);\r\nlist_del(&rp->list);\r\nkfree(rp);\r\n}\r\nkfree(tsp);\r\n}\r\nstatic int smack_cred_prepare(struct cred *new, const struct cred *old,\r\ngfp_t gfp)\r\n{\r\nstruct task_smack *old_tsp = old->security;\r\nstruct task_smack *new_tsp;\r\nint rc;\r\nnew_tsp = new_task_smack(old_tsp->smk_task, old_tsp->smk_task, gfp);\r\nif (new_tsp == NULL)\r\nreturn -ENOMEM;\r\nrc = smk_copy_rules(&new_tsp->smk_rules, &old_tsp->smk_rules, gfp);\r\nif (rc != 0)\r\nreturn rc;\r\nnew->security = new_tsp;\r\nreturn 0;\r\n}\r\nstatic void smack_cred_transfer(struct cred *new, const struct cred *old)\r\n{\r\nstruct task_smack *old_tsp = old->security;\r\nstruct task_smack *new_tsp = new->security;\r\nnew_tsp->smk_task = old_tsp->smk_task;\r\nnew_tsp->smk_forked = old_tsp->smk_task;\r\nmutex_init(&new_tsp->smk_rules_lock);\r\nINIT_LIST_HEAD(&new_tsp->smk_rules);\r\n}\r\nstatic int smack_kernel_act_as(struct cred *new, u32 secid)\r\n{\r\nstruct task_smack *new_tsp = new->security;\r\nchar *smack = smack_from_secid(secid);\r\nif (smack == NULL)\r\nreturn -EINVAL;\r\nnew_tsp->smk_task = smack;\r\nreturn 0;\r\n}\r\nstatic int smack_kernel_create_files_as(struct cred *new,\r\nstruct inode *inode)\r\n{\r\nstruct inode_smack *isp = inode->i_security;\r\nstruct task_smack *tsp = new->security;\r\ntsp->smk_forked = isp->smk_inode;\r\ntsp->smk_task = isp->smk_inode;\r\nreturn 0;\r\n}\r\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\r\nconst char *caller)\r\n{\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\r\nsmk_ad_setfield_u_tsk(&ad, p);\r\nreturn smk_curacc(smk_of_task(task_security(p)), access, &ad);\r\n}\r\nstatic int smack_task_setpgid(struct task_struct *p, pid_t pgid)\r\n{\r\nreturn smk_curacc_on_task(p, MAY_WRITE, __func__);\r\n}\r\nstatic int smack_task_getpgid(struct task_struct *p)\r\n{\r\nreturn smk_curacc_on_task(p, MAY_READ, __func__);\r\n}\r\nstatic int smack_task_getsid(struct task_struct *p)\r\n{\r\nreturn smk_curacc_on_task(p, MAY_READ, __func__);\r\n}\r\nstatic void smack_task_getsecid(struct task_struct *p, u32 *secid)\r\n{\r\n*secid = smack_to_secid(smk_of_task(task_security(p)));\r\n}\r\nstatic int smack_task_setnice(struct task_struct *p, int nice)\r\n{\r\nint rc;\r\nrc = cap_task_setnice(p, nice);\r\nif (rc == 0)\r\nrc = smk_curacc_on_task(p, MAY_WRITE, __func__);\r\nreturn rc;\r\n}\r\nstatic int smack_task_setioprio(struct task_struct *p, int ioprio)\r\n{\r\nint rc;\r\nrc = cap_task_setioprio(p, ioprio);\r\nif (rc == 0)\r\nrc = smk_curacc_on_task(p, MAY_WRITE, __func__);\r\nreturn rc;\r\n}\r\nstatic int smack_task_getioprio(struct task_struct *p)\r\n{\r\nreturn smk_curacc_on_task(p, MAY_READ, __func__);\r\n}\r\nstatic int smack_task_setscheduler(struct task_struct *p)\r\n{\r\nint rc;\r\nrc = cap_task_setscheduler(p);\r\nif (rc == 0)\r\nrc = smk_curacc_on_task(p, MAY_WRITE, __func__);\r\nreturn rc;\r\n}\r\nstatic int smack_task_getscheduler(struct task_struct *p)\r\n{\r\nreturn smk_curacc_on_task(p, MAY_READ, __func__);\r\n}\r\nstatic int smack_task_movememory(struct task_struct *p)\r\n{\r\nreturn smk_curacc_on_task(p, MAY_WRITE, __func__);\r\n}\r\nstatic int smack_task_kill(struct task_struct *p, struct siginfo *info,\r\nint sig, u32 secid)\r\n{\r\nstruct smk_audit_info ad;\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\r\nsmk_ad_setfield_u_tsk(&ad, p);\r\nif (secid == 0)\r\nreturn smk_curacc(smk_of_task(task_security(p)), MAY_WRITE,\r\n&ad);\r\nreturn smk_access(smack_from_secid(secid),\r\nsmk_of_task(task_security(p)), MAY_WRITE, &ad);\r\n}\r\nstatic int smack_task_wait(struct task_struct *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic void smack_task_to_inode(struct task_struct *p, struct inode *inode)\r\n{\r\nstruct inode_smack *isp = inode->i_security;\r\nisp->smk_inode = smk_of_task(task_security(p));\r\n}\r\nstatic int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)\r\n{\r\nchar *csp = smk_of_current();\r\nstruct socket_smack *ssp;\r\nssp = kzalloc(sizeof(struct socket_smack), gfp_flags);\r\nif (ssp == NULL)\r\nreturn -ENOMEM;\r\nssp->smk_in = csp;\r\nssp->smk_out = csp;\r\nssp->smk_packet = NULL;\r\nsk->sk_security = ssp;\r\nreturn 0;\r\n}\r\nstatic void smack_sk_free_security(struct sock *sk)\r\n{\r\nkfree(sk->sk_security);\r\n}\r\nstatic char *smack_host_label(struct sockaddr_in *sip)\r\n{\r\nstruct smk_netlbladdr *snp;\r\nstruct in_addr *siap = &sip->sin_addr;\r\nif (siap->s_addr == 0)\r\nreturn NULL;\r\nlist_for_each_entry_rcu(snp, &smk_netlbladdr_list, list)\r\nif ((&snp->smk_host.sin_addr)->s_addr ==\r\n(siap->s_addr & (&snp->smk_mask)->s_addr)) {\r\nif (snp->smk_label == smack_cipso_option)\r\nreturn NULL;\r\nreturn snp->smk_label;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int smack_netlabel(struct sock *sk, int labeled)\r\n{\r\nstruct smack_known *skp;\r\nstruct socket_smack *ssp = sk->sk_security;\r\nint rc = 0;\r\nlocal_bh_disable();\r\nbh_lock_sock_nested(sk);\r\nif (ssp->smk_out == smack_net_ambient ||\r\nlabeled == SMACK_UNLABELED_SOCKET)\r\nnetlbl_sock_delattr(sk);\r\nelse {\r\nskp = smk_find_entry(ssp->smk_out);\r\nrc = netlbl_sock_setattr(sk, sk->sk_family, &skp->smk_netlabel);\r\n}\r\nbh_unlock_sock(sk);\r\nlocal_bh_enable();\r\nreturn rc;\r\n}\r\nstatic int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\r\n{\r\nint rc;\r\nint sk_lbl;\r\nchar *hostsp;\r\nstruct socket_smack *ssp = sk->sk_security;\r\nstruct smk_audit_info ad;\r\nrcu_read_lock();\r\nhostsp = smack_host_label(sap);\r\nif (hostsp != NULL) {\r\n#ifdef CONFIG_AUDIT\r\nstruct lsm_network_audit net;\r\nsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\r\nad.a.u.net->family = sap->sin_family;\r\nad.a.u.net->dport = sap->sin_port;\r\nad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\r\n#endif\r\nsk_lbl = SMACK_UNLABELED_SOCKET;\r\nrc = smk_access(ssp->smk_out, hostsp, MAY_WRITE, &ad);\r\n} else {\r\nsk_lbl = SMACK_CIPSO_SOCKET;\r\nrc = 0;\r\n}\r\nrcu_read_unlock();\r\nif (rc != 0)\r\nreturn rc;\r\nreturn smack_netlabel(sk, sk_lbl);\r\n}\r\nstatic int smack_inode_setsecurity(struct inode *inode, const char *name,\r\nconst void *value, size_t size, int flags)\r\n{\r\nchar *sp;\r\nstruct inode_smack *nsp = inode->i_security;\r\nstruct socket_smack *ssp;\r\nstruct socket *sock;\r\nint rc = 0;\r\nif (value == NULL || size > SMK_LONGLABEL || size == 0)\r\nreturn -EACCES;\r\nsp = smk_import(value, size);\r\nif (sp == NULL)\r\nreturn -EINVAL;\r\nif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\r\nnsp->smk_inode = sp;\r\nnsp->smk_flags |= SMK_INODE_INSTANT;\r\nreturn 0;\r\n}\r\nif (inode->i_sb->s_magic != SOCKFS_MAGIC)\r\nreturn -EOPNOTSUPP;\r\nsock = SOCKET_I(inode);\r\nif (sock == NULL || sock->sk == NULL)\r\nreturn -EOPNOTSUPP;\r\nssp = sock->sk->sk_security;\r\nif (strcmp(name, XATTR_SMACK_IPIN) == 0)\r\nssp->smk_in = sp;\r\nelse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {\r\nssp->smk_out = sp;\r\nif (sock->sk->sk_family != PF_UNIX) {\r\nrc = smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\r\nif (rc != 0)\r\nprintk(KERN_WARNING\r\n"Smack: \"%s\" netlbl error %d.\n",\r\n__func__, -rc);\r\n}\r\n} else\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int smack_socket_post_create(struct socket *sock, int family,\r\nint type, int protocol, int kern)\r\n{\r\nif (family != PF_INET || sock->sk == NULL)\r\nreturn 0;\r\nreturn smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\r\n}\r\nstatic int smack_socket_connect(struct socket *sock, struct sockaddr *sap,\r\nint addrlen)\r\n{\r\nif (sock->sk == NULL || sock->sk->sk_family != PF_INET)\r\nreturn 0;\r\nif (addrlen < sizeof(struct sockaddr_in))\r\nreturn -EINVAL;\r\nreturn smack_netlabel_send(sock->sk, (struct sockaddr_in *)sap);\r\n}\r\nstatic int smack_flags_to_may(int flags)\r\n{\r\nint may = 0;\r\nif (flags & S_IRUGO)\r\nmay |= MAY_READ;\r\nif (flags & S_IWUGO)\r\nmay |= MAY_WRITE;\r\nif (flags & S_IXUGO)\r\nmay |= MAY_EXEC;\r\nreturn may;\r\n}\r\nstatic int smack_msg_msg_alloc_security(struct msg_msg *msg)\r\n{\r\nmsg->security = smk_of_current();\r\nreturn 0;\r\n}\r\nstatic void smack_msg_msg_free_security(struct msg_msg *msg)\r\n{\r\nmsg->security = NULL;\r\n}\r\nstatic char *smack_of_shm(struct shmid_kernel *shp)\r\n{\r\nreturn (char *)shp->shm_perm.security;\r\n}\r\nstatic int smack_shm_alloc_security(struct shmid_kernel *shp)\r\n{\r\nstruct kern_ipc_perm *isp = &shp->shm_perm;\r\nisp->security = smk_of_current();\r\nreturn 0;\r\n}\r\nstatic void smack_shm_free_security(struct shmid_kernel *shp)\r\n{\r\nstruct kern_ipc_perm *isp = &shp->shm_perm;\r\nisp->security = NULL;\r\n}\r\nstatic int smk_curacc_shm(struct shmid_kernel *shp, int access)\r\n{\r\nchar *ssp = smack_of_shm(shp);\r\nstruct smk_audit_info ad;\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\r\nad.a.u.ipc_id = shp->shm_perm.id;\r\n#endif\r\nreturn smk_curacc(ssp, access, &ad);\r\n}\r\nstatic int smack_shm_associate(struct shmid_kernel *shp, int shmflg)\r\n{\r\nint may;\r\nmay = smack_flags_to_may(shmflg);\r\nreturn smk_curacc_shm(shp, may);\r\n}\r\nstatic int smack_shm_shmctl(struct shmid_kernel *shp, int cmd)\r\n{\r\nint may;\r\nswitch (cmd) {\r\ncase IPC_STAT:\r\ncase SHM_STAT:\r\nmay = MAY_READ;\r\nbreak;\r\ncase IPC_SET:\r\ncase SHM_LOCK:\r\ncase SHM_UNLOCK:\r\ncase IPC_RMID:\r\nmay = MAY_READWRITE;\r\nbreak;\r\ncase IPC_INFO:\r\ncase SHM_INFO:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn smk_curacc_shm(shp, may);\r\n}\r\nstatic int smack_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr,\r\nint shmflg)\r\n{\r\nint may;\r\nmay = smack_flags_to_may(shmflg);\r\nreturn smk_curacc_shm(shp, may);\r\n}\r\nstatic char *smack_of_sem(struct sem_array *sma)\r\n{\r\nreturn (char *)sma->sem_perm.security;\r\n}\r\nstatic int smack_sem_alloc_security(struct sem_array *sma)\r\n{\r\nstruct kern_ipc_perm *isp = &sma->sem_perm;\r\nisp->security = smk_of_current();\r\nreturn 0;\r\n}\r\nstatic void smack_sem_free_security(struct sem_array *sma)\r\n{\r\nstruct kern_ipc_perm *isp = &sma->sem_perm;\r\nisp->security = NULL;\r\n}\r\nstatic int smk_curacc_sem(struct sem_array *sma, int access)\r\n{\r\nchar *ssp = smack_of_sem(sma);\r\nstruct smk_audit_info ad;\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\r\nad.a.u.ipc_id = sma->sem_perm.id;\r\n#endif\r\nreturn smk_curacc(ssp, access, &ad);\r\n}\r\nstatic int smack_sem_associate(struct sem_array *sma, int semflg)\r\n{\r\nint may;\r\nmay = smack_flags_to_may(semflg);\r\nreturn smk_curacc_sem(sma, may);\r\n}\r\nstatic int smack_sem_semctl(struct sem_array *sma, int cmd)\r\n{\r\nint may;\r\nswitch (cmd) {\r\ncase GETPID:\r\ncase GETNCNT:\r\ncase GETZCNT:\r\ncase GETVAL:\r\ncase GETALL:\r\ncase IPC_STAT:\r\ncase SEM_STAT:\r\nmay = MAY_READ;\r\nbreak;\r\ncase SETVAL:\r\ncase SETALL:\r\ncase IPC_RMID:\r\ncase IPC_SET:\r\nmay = MAY_READWRITE;\r\nbreak;\r\ncase IPC_INFO:\r\ncase SEM_INFO:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn smk_curacc_sem(sma, may);\r\n}\r\nstatic int smack_sem_semop(struct sem_array *sma, struct sembuf *sops,\r\nunsigned nsops, int alter)\r\n{\r\nreturn smk_curacc_sem(sma, MAY_READWRITE);\r\n}\r\nstatic int smack_msg_queue_alloc_security(struct msg_queue *msq)\r\n{\r\nstruct kern_ipc_perm *kisp = &msq->q_perm;\r\nkisp->security = smk_of_current();\r\nreturn 0;\r\n}\r\nstatic void smack_msg_queue_free_security(struct msg_queue *msq)\r\n{\r\nstruct kern_ipc_perm *kisp = &msq->q_perm;\r\nkisp->security = NULL;\r\n}\r\nstatic char *smack_of_msq(struct msg_queue *msq)\r\n{\r\nreturn (char *)msq->q_perm.security;\r\n}\r\nstatic int smk_curacc_msq(struct msg_queue *msq, int access)\r\n{\r\nchar *msp = smack_of_msq(msq);\r\nstruct smk_audit_info ad;\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\r\nad.a.u.ipc_id = msq->q_perm.id;\r\n#endif\r\nreturn smk_curacc(msp, access, &ad);\r\n}\r\nstatic int smack_msg_queue_associate(struct msg_queue *msq, int msqflg)\r\n{\r\nint may;\r\nmay = smack_flags_to_may(msqflg);\r\nreturn smk_curacc_msq(msq, may);\r\n}\r\nstatic int smack_msg_queue_msgctl(struct msg_queue *msq, int cmd)\r\n{\r\nint may;\r\nswitch (cmd) {\r\ncase IPC_STAT:\r\ncase MSG_STAT:\r\nmay = MAY_READ;\r\nbreak;\r\ncase IPC_SET:\r\ncase IPC_RMID:\r\nmay = MAY_READWRITE;\r\nbreak;\r\ncase IPC_INFO:\r\ncase MSG_INFO:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn smk_curacc_msq(msq, may);\r\n}\r\nstatic int smack_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg,\r\nint msqflg)\r\n{\r\nint may;\r\nmay = smack_flags_to_may(msqflg);\r\nreturn smk_curacc_msq(msq, may);\r\n}\r\nstatic int smack_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,\r\nstruct task_struct *target, long type, int mode)\r\n{\r\nreturn smk_curacc_msq(msq, MAY_READWRITE);\r\n}\r\nstatic int smack_ipc_permission(struct kern_ipc_perm *ipp, short flag)\r\n{\r\nchar *isp = ipp->security;\r\nint may = smack_flags_to_may(flag);\r\nstruct smk_audit_info ad;\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\r\nad.a.u.ipc_id = ipp->id;\r\n#endif\r\nreturn smk_curacc(isp, may, &ad);\r\n}\r\nstatic void smack_ipc_getsecid(struct kern_ipc_perm *ipp, u32 *secid)\r\n{\r\nchar *smack = ipp->security;\r\n*secid = smack_to_secid(smack);\r\n}\r\nstatic void smack_d_instantiate(struct dentry *opt_dentry, struct inode *inode)\r\n{\r\nstruct super_block *sbp;\r\nstruct superblock_smack *sbsp;\r\nstruct inode_smack *isp;\r\nchar *csp = smk_of_current();\r\nchar *fetched;\r\nchar *final;\r\nchar trattr[TRANS_TRUE_SIZE];\r\nint transflag = 0;\r\nint rc;\r\nstruct dentry *dp;\r\nif (inode == NULL)\r\nreturn;\r\nisp = inode->i_security;\r\nmutex_lock(&isp->smk_lock);\r\nif (isp->smk_flags & SMK_INODE_INSTANT)\r\ngoto unlockandout;\r\nsbp = inode->i_sb;\r\nsbsp = sbp->s_security;\r\nfinal = sbsp->smk_default;\r\nif (opt_dentry->d_parent == opt_dentry) {\r\nisp->smk_inode = sbsp->smk_root;\r\nisp->smk_flags |= SMK_INODE_INSTANT;\r\ngoto unlockandout;\r\n}\r\nswitch (sbp->s_magic) {\r\ncase SMACK_MAGIC:\r\nfinal = smack_known_star.smk_known;\r\nbreak;\r\ncase PIPEFS_MAGIC:\r\nfinal = smack_known_star.smk_known;\r\nbreak;\r\ncase DEVPTS_SUPER_MAGIC:\r\nfinal = csp;\r\nbreak;\r\ncase SOCKFS_MAGIC:\r\nfinal = smack_known_star.smk_known;\r\nbreak;\r\ncase PROC_SUPER_MAGIC:\r\nbreak;\r\ncase TMPFS_MAGIC:\r\nfinal = smack_known_star.smk_known;\r\ndefault:\r\nif (S_ISSOCK(inode->i_mode)) {\r\nfinal = smack_known_star.smk_known;\r\nbreak;\r\n}\r\nif (inode->i_op->getxattr == NULL)\r\nbreak;\r\ndp = dget(opt_dentry);\r\nfetched = smk_fetch(XATTR_NAME_SMACK, inode, dp);\r\nif (fetched != NULL)\r\nfinal = fetched;\r\nif (S_ISDIR(inode->i_mode)) {\r\nif (isp->smk_flags & SMK_INODE_CHANGED) {\r\nisp->smk_flags &= ~SMK_INODE_CHANGED;\r\nrc = inode->i_op->setxattr(dp,\r\nXATTR_NAME_SMACKTRANSMUTE,\r\nTRANS_TRUE, TRANS_TRUE_SIZE,\r\n0);\r\n} else {\r\nrc = inode->i_op->getxattr(dp,\r\nXATTR_NAME_SMACKTRANSMUTE, trattr,\r\nTRANS_TRUE_SIZE);\r\nif (rc >= 0 && strncmp(trattr, TRANS_TRUE,\r\nTRANS_TRUE_SIZE) != 0)\r\nrc = -EINVAL;\r\n}\r\nif (rc >= 0)\r\ntransflag = SMK_INODE_TRANSMUTE;\r\n}\r\nisp->smk_task = smk_fetch(XATTR_NAME_SMACKEXEC, inode, dp);\r\nisp->smk_mmap = smk_fetch(XATTR_NAME_SMACKMMAP, inode, dp);\r\ndput(dp);\r\nbreak;\r\n}\r\nif (final == NULL)\r\nisp->smk_inode = csp;\r\nelse\r\nisp->smk_inode = final;\r\nisp->smk_flags |= (SMK_INODE_INSTANT | transflag);\r\nunlockandout:\r\nmutex_unlock(&isp->smk_lock);\r\nreturn;\r\n}\r\nstatic int smack_getprocattr(struct task_struct *p, char *name, char **value)\r\n{\r\nchar *cp;\r\nint slen;\r\nif (strcmp(name, "current") != 0)\r\nreturn -EINVAL;\r\ncp = kstrdup(smk_of_task(task_security(p)), GFP_KERNEL);\r\nif (cp == NULL)\r\nreturn -ENOMEM;\r\nslen = strlen(cp);\r\n*value = cp;\r\nreturn slen;\r\n}\r\nstatic int smack_setprocattr(struct task_struct *p, char *name,\r\nvoid *value, size_t size)\r\n{\r\nstruct task_smack *tsp;\r\nstruct cred *new;\r\nchar *newsmack;\r\nif (p != current)\r\nreturn -EPERM;\r\nif (!smack_privileged(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (value == NULL || size == 0 || size >= SMK_LONGLABEL)\r\nreturn -EINVAL;\r\nif (strcmp(name, "current") != 0)\r\nreturn -EINVAL;\r\nnewsmack = smk_import(value, size);\r\nif (newsmack == NULL)\r\nreturn -EINVAL;\r\nif (newsmack == smack_known_web.smk_known)\r\nreturn -EPERM;\r\nnew = prepare_creds();\r\nif (new == NULL)\r\nreturn -ENOMEM;\r\ntsp = new->security;\r\ntsp->smk_task = newsmack;\r\ncommit_creds(new);\r\nreturn size;\r\n}\r\nstatic int smack_unix_stream_connect(struct sock *sock,\r\nstruct sock *other, struct sock *newsk)\r\n{\r\nstruct socket_smack *ssp = sock->sk_security;\r\nstruct socket_smack *osp = other->sk_security;\r\nstruct socket_smack *nsp = newsk->sk_security;\r\nstruct smk_audit_info ad;\r\nint rc = 0;\r\n#ifdef CONFIG_AUDIT\r\nstruct lsm_network_audit net;\r\nsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\r\nsmk_ad_setfield_u_net_sk(&ad, other);\r\n#endif\r\nif (!smack_privileged(CAP_MAC_OVERRIDE))\r\nrc = smk_access(ssp->smk_out, osp->smk_in, MAY_WRITE, &ad);\r\nif (rc == 0) {\r\nnsp->smk_packet = ssp->smk_out;\r\nssp->smk_packet = osp->smk_out;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smack_unix_may_send(struct socket *sock, struct socket *other)\r\n{\r\nstruct socket_smack *ssp = sock->sk->sk_security;\r\nstruct socket_smack *osp = other->sk->sk_security;\r\nstruct smk_audit_info ad;\r\nint rc = 0;\r\n#ifdef CONFIG_AUDIT\r\nstruct lsm_network_audit net;\r\nsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\r\nsmk_ad_setfield_u_net_sk(&ad, other->sk);\r\n#endif\r\nif (!smack_privileged(CAP_MAC_OVERRIDE))\r\nrc = smk_access(ssp->smk_out, osp->smk_in, MAY_WRITE, &ad);\r\nreturn rc;\r\n}\r\nstatic int smack_socket_sendmsg(struct socket *sock, struct msghdr *msg,\r\nint size)\r\n{\r\nstruct sockaddr_in *sip = (struct sockaddr_in *) msg->msg_name;\r\nif (sip == NULL || sip->sin_family != AF_INET)\r\nreturn 0;\r\nreturn smack_netlabel_send(sock->sk, sip);\r\n}\r\nstatic char *smack_from_secattr(struct netlbl_lsm_secattr *sap,\r\nstruct socket_smack *ssp)\r\n{\r\nstruct smack_known *kp;\r\nchar *sp;\r\nint found = 0;\r\nif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\r\nrcu_read_lock();\r\nlist_for_each_entry(kp, &smack_known_list, list) {\r\nif (sap->attr.mls.lvl != kp->smk_netlabel.attr.mls.lvl)\r\ncontinue;\r\nif (memcmp(sap->attr.mls.cat,\r\nkp->smk_netlabel.attr.mls.cat,\r\nSMK_CIPSOLEN) != 0)\r\ncontinue;\r\nfound = 1;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (found)\r\nreturn kp->smk_known;\r\nif (ssp != NULL && ssp->smk_in == smack_known_star.smk_known)\r\nreturn smack_known_web.smk_known;\r\nreturn smack_known_star.smk_known;\r\n}\r\nif ((sap->flags & NETLBL_SECATTR_SECID) != 0) {\r\nsp = smack_from_secid(sap->attr.secid);\r\nBUG_ON(sp == NULL);\r\nreturn sp;\r\n}\r\nreturn smack_net_ambient;\r\n}\r\nstatic int smack_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct netlbl_lsm_secattr secattr;\r\nstruct socket_smack *ssp = sk->sk_security;\r\nchar *csp;\r\nint rc;\r\nstruct smk_audit_info ad;\r\n#ifdef CONFIG_AUDIT\r\nstruct lsm_network_audit net;\r\n#endif\r\nif (sk->sk_family != PF_INET && sk->sk_family != PF_INET6)\r\nreturn 0;\r\nnetlbl_secattr_init(&secattr);\r\nrc = netlbl_skbuff_getattr(skb, sk->sk_family, &secattr);\r\nif (rc == 0)\r\ncsp = smack_from_secattr(&secattr, ssp);\r\nelse\r\ncsp = smack_net_ambient;\r\nnetlbl_secattr_destroy(&secattr);\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\r\nad.a.u.net->family = sk->sk_family;\r\nad.a.u.net->netif = skb->skb_iif;\r\nipv4_skb_to_auditdata(skb, &ad.a, NULL);\r\n#endif\r\nrc = smk_access(csp, ssp->smk_in, MAY_WRITE, &ad);\r\nif (rc != 0)\r\nnetlbl_skbuff_err(skb, rc, 0);\r\nreturn rc;\r\n}\r\nstatic int smack_socket_getpeersec_stream(struct socket *sock,\r\nchar __user *optval,\r\nint __user *optlen, unsigned len)\r\n{\r\nstruct socket_smack *ssp;\r\nchar *rcp = "";\r\nint slen = 1;\r\nint rc = 0;\r\nssp = sock->sk->sk_security;\r\nif (ssp->smk_packet != NULL) {\r\nrcp = ssp->smk_packet;\r\nslen = strlen(rcp) + 1;\r\n}\r\nif (slen > len)\r\nrc = -ERANGE;\r\nelse if (copy_to_user(optval, rcp, slen) != 0)\r\nrc = -EFAULT;\r\nif (put_user(slen, optlen) != 0)\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nstatic int smack_socket_getpeersec_dgram(struct socket *sock,\r\nstruct sk_buff *skb, u32 *secid)\r\n{\r\nstruct netlbl_lsm_secattr secattr;\r\nstruct socket_smack *ssp = NULL;\r\nchar *sp;\r\nint family = PF_UNSPEC;\r\nu32 s = 0;\r\nint rc;\r\nif (skb != NULL) {\r\nif (skb->protocol == htons(ETH_P_IP))\r\nfamily = PF_INET;\r\nelse if (skb->protocol == htons(ETH_P_IPV6))\r\nfamily = PF_INET6;\r\n}\r\nif (family == PF_UNSPEC && sock != NULL)\r\nfamily = sock->sk->sk_family;\r\nif (family == PF_UNIX) {\r\nssp = sock->sk->sk_security;\r\ns = smack_to_secid(ssp->smk_out);\r\n} else if (family == PF_INET || family == PF_INET6) {\r\nif (sock != NULL && sock->sk != NULL)\r\nssp = sock->sk->sk_security;\r\nnetlbl_secattr_init(&secattr);\r\nrc = netlbl_skbuff_getattr(skb, family, &secattr);\r\nif (rc == 0) {\r\nsp = smack_from_secattr(&secattr, ssp);\r\ns = smack_to_secid(sp);\r\n}\r\nnetlbl_secattr_destroy(&secattr);\r\n}\r\n*secid = s;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void smack_sock_graft(struct sock *sk, struct socket *parent)\r\n{\r\nstruct socket_smack *ssp;\r\nif (sk == NULL ||\r\n(sk->sk_family != PF_INET && sk->sk_family != PF_INET6))\r\nreturn;\r\nssp = sk->sk_security;\r\nssp->smk_in = ssp->smk_out = smk_of_current();\r\n}\r\nstatic int smack_inet_conn_request(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *req)\r\n{\r\nu16 family = sk->sk_family;\r\nstruct smack_known *skp;\r\nstruct socket_smack *ssp = sk->sk_security;\r\nstruct netlbl_lsm_secattr secattr;\r\nstruct sockaddr_in addr;\r\nstruct iphdr *hdr;\r\nchar *sp;\r\nchar *hsp;\r\nint rc;\r\nstruct smk_audit_info ad;\r\n#ifdef CONFIG_AUDIT\r\nstruct lsm_network_audit net;\r\n#endif\r\nif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\r\nfamily = PF_INET;\r\nnetlbl_secattr_init(&secattr);\r\nrc = netlbl_skbuff_getattr(skb, family, &secattr);\r\nif (rc == 0)\r\nsp = smack_from_secattr(&secattr, ssp);\r\nelse\r\nsp = smack_known_huh.smk_known;\r\nnetlbl_secattr_destroy(&secattr);\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\r\nad.a.u.net->family = family;\r\nad.a.u.net->netif = skb->skb_iif;\r\nipv4_skb_to_auditdata(skb, &ad.a, NULL);\r\n#endif\r\nrc = smk_access(sp, ssp->smk_in, MAY_WRITE, &ad);\r\nif (rc != 0)\r\nreturn rc;\r\nreq->peer_secid = smack_to_secid(sp);\r\nhdr = ip_hdr(skb);\r\naddr.sin_addr.s_addr = hdr->saddr;\r\nrcu_read_lock();\r\nhsp = smack_host_label(&addr);\r\nrcu_read_unlock();\r\nif (hsp == NULL) {\r\nskp = smk_find_entry(sp);\r\nrc = netlbl_req_setattr(req, &skp->smk_netlabel);\r\n} else\r\nnetlbl_req_delattr(req);\r\nreturn rc;\r\n}\r\nstatic void smack_inet_csk_clone(struct sock *sk,\r\nconst struct request_sock *req)\r\n{\r\nstruct socket_smack *ssp = sk->sk_security;\r\nif (req->peer_secid != 0)\r\nssp->smk_packet = smack_from_secid(req->peer_secid);\r\nelse\r\nssp->smk_packet = NULL;\r\n}\r\nstatic int smack_key_alloc(struct key *key, const struct cred *cred,\r\nunsigned long flags)\r\n{\r\nkey->security = smk_of_task(cred->security);\r\nreturn 0;\r\n}\r\nstatic void smack_key_free(struct key *key)\r\n{\r\nkey->security = NULL;\r\n}\r\nstatic int smack_key_permission(key_ref_t key_ref,\r\nconst struct cred *cred, key_perm_t perm)\r\n{\r\nstruct key *keyp;\r\nstruct smk_audit_info ad;\r\nchar *tsp = smk_of_task(cred->security);\r\nkeyp = key_ref_to_ptr(key_ref);\r\nif (keyp == NULL)\r\nreturn -EINVAL;\r\nif (keyp->security == NULL)\r\nreturn 0;\r\nif (tsp == NULL)\r\nreturn -EACCES;\r\n#ifdef CONFIG_AUDIT\r\nsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_KEY);\r\nad.a.u.key_struct.key = keyp->serial;\r\nad.a.u.key_struct.key_desc = keyp->description;\r\n#endif\r\nreturn smk_access(tsp, keyp->security,\r\nMAY_READWRITE, &ad);\r\n}\r\nstatic int smack_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\r\n{\r\nchar **rule = (char **)vrule;\r\n*rule = NULL;\r\nif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\r\nreturn -EINVAL;\r\nif (op != Audit_equal && op != Audit_not_equal)\r\nreturn -EINVAL;\r\n*rule = smk_import(rulestr, 0);\r\nreturn 0;\r\n}\r\nstatic int smack_audit_rule_known(struct audit_krule *krule)\r\n{\r\nstruct audit_field *f;\r\nint i;\r\nfor (i = 0; i < krule->field_count; i++) {\r\nf = &krule->fields[i];\r\nif (f->type == AUDIT_SUBJ_USER || f->type == AUDIT_OBJ_USER)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smack_audit_rule_match(u32 secid, u32 field, u32 op, void *vrule,\r\nstruct audit_context *actx)\r\n{\r\nchar *smack;\r\nchar *rule = vrule;\r\nif (!rule) {\r\naudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"Smack: missing rule\n");\r\nreturn -ENOENT;\r\n}\r\nif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\r\nreturn 0;\r\nsmack = smack_from_secid(secid);\r\nif (op == Audit_equal)\r\nreturn (rule == smack);\r\nif (op == Audit_not_equal)\r\nreturn (rule != smack);\r\nreturn 0;\r\n}\r\nstatic void smack_audit_rule_free(void *vrule)\r\n{\r\n}\r\nstatic int smack_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\r\n{\r\nchar *sp = smack_from_secid(secid);\r\nif (secdata)\r\n*secdata = sp;\r\n*seclen = strlen(sp);\r\nreturn 0;\r\n}\r\nstatic int smack_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\r\n{\r\n*secid = smack_to_secid(secdata);\r\nreturn 0;\r\n}\r\nstatic void smack_release_secctx(char *secdata, u32 seclen)\r\n{\r\n}\r\nstatic int smack_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\r\n{\r\nreturn smack_inode_setsecurity(inode, XATTR_SMACK_SUFFIX, ctx, ctxlen, 0);\r\n}\r\nstatic int smack_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\r\n{\r\nreturn __vfs_setxattr_noperm(dentry, XATTR_NAME_SMACK, ctx, ctxlen, 0);\r\n}\r\nstatic int smack_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\r\n{\r\nint len = 0;\r\nlen = smack_inode_getsecurity(inode, XATTR_SMACK_SUFFIX, ctx, true);\r\nif (len < 0)\r\nreturn len;\r\n*ctxlen = len;\r\nreturn 0;\r\n}\r\nstatic __init void init_smack_known_list(void)\r\n{\r\nmutex_init(&smack_known_huh.smk_rules_lock);\r\nmutex_init(&smack_known_hat.smk_rules_lock);\r\nmutex_init(&smack_known_floor.smk_rules_lock);\r\nmutex_init(&smack_known_star.smk_rules_lock);\r\nmutex_init(&smack_known_invalid.smk_rules_lock);\r\nmutex_init(&smack_known_web.smk_rules_lock);\r\nINIT_LIST_HEAD(&smack_known_huh.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_hat.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_star.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_floor.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_invalid.smk_rules);\r\nINIT_LIST_HEAD(&smack_known_web.smk_rules);\r\nlist_add(&smack_known_huh.list, &smack_known_list);\r\nlist_add(&smack_known_hat.list, &smack_known_list);\r\nlist_add(&smack_known_star.list, &smack_known_list);\r\nlist_add(&smack_known_floor.list, &smack_known_list);\r\nlist_add(&smack_known_invalid.list, &smack_known_list);\r\nlist_add(&smack_known_web.list, &smack_known_list);\r\n}\r\nstatic __init int smack_init(void)\r\n{\r\nstruct cred *cred;\r\nstruct task_smack *tsp;\r\nif (!security_module_enable(&smack_ops))\r\nreturn 0;\r\ntsp = new_task_smack(smack_known_floor.smk_known,\r\nsmack_known_floor.smk_known, GFP_KERNEL);\r\nif (tsp == NULL)\r\nreturn -ENOMEM;\r\nprintk(KERN_INFO "Smack: Initializing.\n");\r\ncred = (struct cred *) current->cred;\r\ncred->security = tsp;\r\ninit_smack_known_list();\r\nif (register_security(&smack_ops))\r\npanic("smack: Unable to register with kernel.\n");\r\nreturn 0;\r\n}
