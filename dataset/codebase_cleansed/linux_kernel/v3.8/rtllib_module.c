void _setup_timer(struct timer_list *ptimer, void *fun, unsigned long data)\r\n{\r\nptimer->function = fun;\r\nptimer->data = data;\r\ninit_timer(ptimer);\r\n}\r\nstatic inline int rtllib_networks_allocate(struct rtllib_device *ieee)\r\n{\r\nif (ieee->networks)\r\nreturn 0;\r\nieee->networks = kzalloc(\r\nMAX_NETWORK_COUNT * sizeof(struct rtllib_network),\r\nGFP_KERNEL);\r\nif (!ieee->networks) {\r\nprintk(KERN_WARNING "%s: Out of memory allocating beacons\n",\r\nieee->dev->name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void rtllib_networks_free(struct rtllib_device *ieee)\r\n{\r\nif (!ieee->networks)\r\nreturn;\r\nkfree(ieee->networks);\r\nieee->networks = NULL;\r\n}\r\nstatic inline void rtllib_networks_initialize(struct rtllib_device *ieee)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&ieee->network_free_list);\r\nINIT_LIST_HEAD(&ieee->network_list);\r\nfor (i = 0; i < MAX_NETWORK_COUNT; i++)\r\nlist_add_tail(&ieee->networks[i].list,\r\n&ieee->network_free_list);\r\n}\r\nstruct net_device *alloc_rtllib(int sizeof_priv)\r\n{\r\nstruct rtllib_device *ieee = NULL;\r\nstruct net_device *dev;\r\nint i, err;\r\nRTLLIB_DEBUG_INFO("Initializing...\n");\r\ndev = alloc_etherdev(sizeof(struct rtllib_device) + sizeof_priv);\r\nif (!dev) {\r\nRTLLIB_ERROR("Unable to network device.\n");\r\ngoto failed;\r\n}\r\nieee = (struct rtllib_device *)netdev_priv_rsl(dev);\r\nmemset(ieee, 0, sizeof(struct rtllib_device)+sizeof_priv);\r\nieee->dev = dev;\r\nerr = rtllib_networks_allocate(ieee);\r\nif (err) {\r\nRTLLIB_ERROR("Unable to allocate beacon storage: %d\n",\r\nerr);\r\ngoto failed;\r\n}\r\nrtllib_networks_initialize(ieee);\r\nieee->fts = DEFAULT_FTS;\r\nieee->scan_age = DEFAULT_MAX_SCAN_AGE;\r\nieee->open_wep = 1;\r\nieee->host_encrypt = 1;\r\nieee->host_decrypt = 1;\r\nieee->ieee802_1x = 1;\r\nieee->rtllib_ap_sec_type = rtllib_ap_sec_type;\r\nspin_lock_init(&ieee->lock);\r\nspin_lock_init(&ieee->wpax_suitlist_lock);\r\nspin_lock_init(&ieee->bw_spinlock);\r\nspin_lock_init(&ieee->reorder_spinlock);\r\natomic_set(&(ieee->atm_chnlop), 0);\r\natomic_set(&(ieee->atm_swbw), 0);\r\nlib80211_crypt_info_init(&ieee->crypt_info, "RTLLIB", &ieee->lock);\r\nieee->bHalfNMode = false;\r\nieee->wpa_enabled = 0;\r\nieee->tkip_countermeasures = 0;\r\nieee->drop_unencrypted = 0;\r\nieee->privacy_invoked = 0;\r\nieee->ieee802_1x = 1;\r\nieee->raw_tx = 0;\r\nieee->hwsec_active = 0;\r\nmemset(ieee->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\r\nrtllib_softmac_init(ieee);\r\nieee->pHTInfo = kzalloc(sizeof(struct rt_hi_throughput), GFP_KERNEL);\r\nif (ieee->pHTInfo == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc memory for HTInfo\n");\r\nreturn NULL;\r\n}\r\nHTUpdateDefaultSetting(ieee);\r\nHTInitializeHTInfo(ieee);\r\nTSInitialize(ieee);\r\nfor (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&ieee->ibss_mac_hash[i]);\r\nfor (i = 0; i < 17; i++) {\r\nieee->last_rxseq_num[i] = -1;\r\nieee->last_rxfrag_num[i] = -1;\r\nieee->last_packet_time[i] = 0;\r\n}\r\nreturn dev;\r\nfailed:\r\nif (dev)\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nvoid free_rtllib(struct net_device *dev)\r\n{\r\nstruct rtllib_device *ieee = (struct rtllib_device *)\r\nnetdev_priv_rsl(dev);\r\nkfree(ieee->pHTInfo);\r\nieee->pHTInfo = NULL;\r\nrtllib_softmac_free(ieee);\r\nlib80211_crypt_info_free(&ieee->crypt_info);\r\nrtllib_networks_free(ieee);\r\nfree_netdev(dev);\r\n}\r\nstatic int show_debug_level(char *page, char **start, off_t offset,\r\nint count, int *eof, void *data)\r\n{\r\nreturn snprintf(page, count, "0x%08X\n", rtllib_debug_level);\r\n}\r\nstatic int store_debug_level(struct file *file, const char __user *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar buf[] = "0x00000000";\r\nunsigned long len = min((unsigned long)sizeof(buf) - 1, count);\r\nchar *p = (char *)buf;\r\nunsigned long val;\r\nif (copy_from_user(buf, buffer, len))\r\nreturn count;\r\nbuf[len] = 0;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\np++;\r\nif (p[0] == 'x' || p[0] == 'X')\r\np++;\r\nval = simple_strtoul(p, &p, 16);\r\n} else\r\nval = simple_strtoul(p, &p, 10);\r\nif (p == buf)\r\nprintk(KERN_INFO DRV_NAME\r\n": %s is not in hex or decimal form.\n", buf);\r\nelse\r\nrtllib_debug_level = val;\r\nreturn strnlen(buf, count);\r\n}\r\nint __init rtllib_init(void)\r\n{\r\nstruct proc_dir_entry *e;\r\nrtllib_debug_level = debug;\r\nrtllib_proc = create_proc_entry(DRV_NAME, S_IFDIR, init_net.proc_net);\r\nif (rtllib_proc == NULL) {\r\nRTLLIB_ERROR("Unable to create " DRV_NAME\r\n" proc directory\n");\r\nreturn -EIO;\r\n}\r\ne = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR,\r\nrtllib_proc);\r\nif (!e) {\r\nremove_proc_entry(DRV_NAME, init_net.proc_net);\r\nrtllib_proc = NULL;\r\nreturn -EIO;\r\n}\r\ne->read_proc = show_debug_level;\r\ne->write_proc = store_debug_level;\r\ne->data = NULL;\r\nreturn 0;\r\n}\r\nvoid __exit rtllib_exit(void)\r\n{\r\nif (rtllib_proc) {\r\nremove_proc_entry("debug_level", rtllib_proc);\r\nremove_proc_entry(DRV_NAME, init_net.proc_net);\r\nrtllib_proc = NULL;\r\n}\r\n}
