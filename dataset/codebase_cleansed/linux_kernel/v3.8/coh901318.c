static void coh901318_list_print(struct coh901318_chan *cohc,\r\nstruct coh901318_lli *lli)\r\n{\r\nstruct coh901318_lli *l = lli;\r\nint i = 0;\r\nwhile (l) {\r\ndev_vdbg(COHC_2_DEV(cohc), "i %d, lli %p, ctrl 0x%x, src 0x%x"\r\n", dst 0x%x, link 0x%x virt_link_addr 0x%p\n",\r\ni, l, l->control, l->src_addr, l->dst_addr,\r\nl->link_addr, l->virt_link_addr);\r\ni++;\r\nl = l->virt_link_addr;\r\n}\r\n}\r\nstatic int coh901318_debugfs_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nu64 started_channels = debugfs_dma_base->pm.started_channels;\r\nint pool_count = debugfs_dma_base->pool.debugfs_pool_counter;\r\nint i;\r\nint ret = 0;\r\nchar *dev_buf;\r\nchar *tmp;\r\nint dev_size;\r\ndev_buf = kmalloc(4*1024, GFP_KERNEL);\r\nif (dev_buf == NULL)\r\ngoto err_kmalloc;\r\ntmp = dev_buf;\r\ntmp += sprintf(tmp, "DMA -- enabled dma channels\n");\r\nfor (i = 0; i < debugfs_dma_base->platform->max_channels; i++)\r\nif (started_channels & (1 << i))\r\ntmp += sprintf(tmp, "channel %d\n", i);\r\ntmp += sprintf(tmp, "Pool alloc nbr %d\n", pool_count);\r\ndev_size = tmp - dev_buf;\r\nif (*f_pos > dev_size)\r\ngoto out;\r\nif (count > dev_size - *f_pos)\r\ncount = dev_size - *f_pos;\r\nif (copy_to_user(buf, dev_buf + *f_pos, count))\r\nret = -EINVAL;\r\nret = count;\r\n*f_pos += count;\r\nout:\r\nkfree(dev_buf);\r\nreturn ret;\r\nerr_kmalloc:\r\nreturn 0;\r\n}\r\nstatic int __init init_coh901318_debugfs(void)\r\n{\r\ndma_dentry = debugfs_create_dir("dma", NULL);\r\n(void) debugfs_create_file("status",\r\nS_IFREG | S_IRUGO,\r\ndma_dentry, NULL,\r\n&coh901318_debugfs_status_operations);\r\nreturn 0;\r\n}\r\nstatic void __exit exit_coh901318_debugfs(void)\r\n{\r\ndebugfs_remove_recursive(dma_dentry);\r\n}\r\nstatic inline struct coh901318_chan *to_coh901318_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct coh901318_chan, chan);\r\n}\r\nstatic inline dma_addr_t\r\ncohc_dev_addr(struct coh901318_chan *cohc)\r\n{\r\nif (cohc->runtime_addr)\r\nreturn cohc->runtime_addr;\r\nreturn cohc->base->platform->chan_conf[cohc->id].dev_addr;\r\n}\r\nstatic inline const struct coh901318_params *\r\ncohc_chan_param(struct coh901318_chan *cohc)\r\n{\r\nreturn &cohc->base->platform->chan_conf[cohc->id].param;\r\n}\r\nstatic inline const struct coh_dma_channel *\r\ncohc_chan_conf(struct coh901318_chan *cohc)\r\n{\r\nreturn &cohc->base->platform->chan_conf[cohc->id];\r\n}\r\nstatic void enable_powersave(struct coh901318_chan *cohc)\r\n{\r\nunsigned long flags;\r\nstruct powersave *pm = &cohc->base->pm;\r\nspin_lock_irqsave(&pm->lock, flags);\r\npm->started_channels &= ~(1ULL << cohc->id);\r\nif (!pm->started_channels) {\r\ncohc->base->platform->access_memory_state(cohc->base->dev,\r\nfalse);\r\n}\r\nspin_unlock_irqrestore(&pm->lock, flags);\r\n}\r\nstatic void disable_powersave(struct coh901318_chan *cohc)\r\n{\r\nunsigned long flags;\r\nstruct powersave *pm = &cohc->base->pm;\r\nspin_lock_irqsave(&pm->lock, flags);\r\nif (!pm->started_channels) {\r\ncohc->base->platform->access_memory_state(cohc->base->dev,\r\ntrue);\r\n}\r\npm->started_channels |= (1ULL << cohc->id);\r\nspin_unlock_irqrestore(&pm->lock, flags);\r\n}\r\nstatic inline int coh901318_set_ctrl(struct coh901318_chan *cohc, u32 control)\r\n{\r\nint channel = cohc->id;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\nwritel(control,\r\nvirtbase + COH901318_CX_CTRL +\r\nCOH901318_CX_CTRL_SPACING * channel);\r\nreturn 0;\r\n}\r\nstatic inline int coh901318_set_conf(struct coh901318_chan *cohc, u32 conf)\r\n{\r\nint channel = cohc->id;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\nwritel(conf,\r\nvirtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING*channel);\r\nreturn 0;\r\n}\r\nstatic int coh901318_start(struct coh901318_chan *cohc)\r\n{\r\nu32 val;\r\nint channel = cohc->id;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\ndisable_powersave(cohc);\r\nval = readl(virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING * channel);\r\nval |= COH901318_CX_CFG_CH_ENABLE;\r\nwritel(val, virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING * channel);\r\nreturn 0;\r\n}\r\nstatic int coh901318_prep_linked_list(struct coh901318_chan *cohc,\r\nstruct coh901318_lli *lli)\r\n{\r\nint channel = cohc->id;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\nBUG_ON(readl(virtbase + COH901318_CX_STAT +\r\nCOH901318_CX_STAT_SPACING*channel) &\r\nCOH901318_CX_STAT_ACTIVE);\r\nwritel(lli->src_addr,\r\nvirtbase + COH901318_CX_SRC_ADDR +\r\nCOH901318_CX_SRC_ADDR_SPACING * channel);\r\nwritel(lli->dst_addr, virtbase +\r\nCOH901318_CX_DST_ADDR +\r\nCOH901318_CX_DST_ADDR_SPACING * channel);\r\nwritel(lli->link_addr, virtbase + COH901318_CX_LNK_ADDR +\r\nCOH901318_CX_LNK_ADDR_SPACING * channel);\r\nwritel(lli->control, virtbase + COH901318_CX_CTRL +\r\nCOH901318_CX_CTRL_SPACING * channel);\r\nreturn 0;\r\n}\r\nstatic struct coh901318_desc *\r\ncoh901318_desc_get(struct coh901318_chan *cohc)\r\n{\r\nstruct coh901318_desc *desc;\r\nif (list_empty(&cohc->free)) {\r\ndesc = kzalloc(sizeof(struct coh901318_desc), GFP_NOWAIT);\r\nif (desc == NULL)\r\ngoto out;\r\nINIT_LIST_HEAD(&desc->node);\r\ndma_async_tx_descriptor_init(&desc->desc, &cohc->chan);\r\n} else {\r\ndesc = list_first_entry(&cohc->free,\r\nstruct coh901318_desc,\r\nnode);\r\nlist_del(&desc->node);\r\ndesc->sg = NULL;\r\ndesc->sg_len = 0;\r\ndesc->desc.callback = NULL;\r\ndesc->desc.callback_param = NULL;\r\n}\r\nout:\r\nreturn desc;\r\n}\r\nstatic void\r\ncoh901318_desc_free(struct coh901318_chan *cohc, struct coh901318_desc *cohd)\r\n{\r\nlist_add_tail(&cohd->node, &cohc->free);\r\n}\r\nstatic void\r\ncoh901318_desc_submit(struct coh901318_chan *cohc, struct coh901318_desc *desc)\r\n{\r\nlist_add_tail(&desc->node, &cohc->active);\r\n}\r\nstatic struct coh901318_desc *\r\ncoh901318_first_active_get(struct coh901318_chan *cohc)\r\n{\r\nstruct coh901318_desc *d;\r\nif (list_empty(&cohc->active))\r\nreturn NULL;\r\nd = list_first_entry(&cohc->active,\r\nstruct coh901318_desc,\r\nnode);\r\nreturn d;\r\n}\r\nstatic void\r\ncoh901318_desc_remove(struct coh901318_desc *cohd)\r\n{\r\nlist_del(&cohd->node);\r\n}\r\nstatic void\r\ncoh901318_desc_queue(struct coh901318_chan *cohc, struct coh901318_desc *desc)\r\n{\r\nlist_add_tail(&desc->node, &cohc->queue);\r\n}\r\nstatic struct coh901318_desc *\r\ncoh901318_first_queued(struct coh901318_chan *cohc)\r\n{\r\nstruct coh901318_desc *d;\r\nif (list_empty(&cohc->queue))\r\nreturn NULL;\r\nd = list_first_entry(&cohc->queue,\r\nstruct coh901318_desc,\r\nnode);\r\nreturn d;\r\n}\r\nstatic inline u32 coh901318_get_bytes_in_lli(struct coh901318_lli *in_lli)\r\n{\r\nstruct coh901318_lli *lli = in_lli;\r\nu32 bytes = 0;\r\nwhile (lli) {\r\nbytes += lli->control & COH901318_CX_CTRL_TC_VALUE_MASK;\r\nlli = lli->virt_link_addr;\r\n}\r\nreturn bytes;\r\n}\r\nstatic u32 coh901318_get_bytes_left(struct dma_chan *chan)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nstruct coh901318_desc *cohd;\r\nstruct list_head *pos;\r\nunsigned long flags;\r\nu32 left = 0;\r\nint i = 0;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\nlist_for_each(pos, &cohc->active) {\r\ncohd = list_entry(pos, struct coh901318_desc, node);\r\nif (i == 0) {\r\nstruct coh901318_lli *lli;\r\ndma_addr_t ladd;\r\nleft = readl(cohc->base->virtbase +\r\nCOH901318_CX_CTRL +\r\nCOH901318_CX_CTRL_SPACING * cohc->id) &\r\nCOH901318_CX_CTRL_TC_VALUE_MASK;\r\nladd = readl(cohc->base->virtbase +\r\nCOH901318_CX_LNK_ADDR +\r\nCOH901318_CX_LNK_ADDR_SPACING *\r\ncohc->id) &\r\n~COH901318_CX_LNK_LINK_IMMEDIATE;\r\nif (!ladd)\r\ncontinue;\r\nlli = cohd->lli;\r\nwhile (lli && lli->link_addr != ladd)\r\nlli = lli->virt_link_addr;\r\nif (lli)\r\nlli = lli->virt_link_addr;\r\nleft += coh901318_get_bytes_in_lli(lli);\r\n} else {\r\nleft += coh901318_get_bytes_in_lli(cohd->lli);\r\n}\r\ni++;\r\n}\r\nlist_for_each(pos, &cohc->queue) {\r\ncohd = list_entry(pos, struct coh901318_desc, node);\r\nleft += coh901318_get_bytes_in_lli(cohd->lli);\r\n}\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nreturn left;\r\n}\r\nstatic void coh901318_pause(struct dma_chan *chan)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nint channel = cohc->id;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\nval = readl(virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING * channel);\r\nif ((val & COH901318_CX_CTRL_TC_ENABLE) == 0 &&\r\n(val & COH901318_CX_CFG_CH_ENABLE))\r\ncohc->stopped = 1;\r\nval &= ~COH901318_CX_CFG_CH_ENABLE;\r\nwritel(val, virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING * channel);\r\nwritel(val, virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING * channel);\r\nwhile (readl(virtbase + COH901318_CX_STAT+COH901318_CX_STAT_SPACING *\r\nchannel) & COH901318_CX_STAT_ACTIVE)\r\ncpu_relax();\r\nif ((readl(virtbase + COH901318_CX_CTRL+COH901318_CX_CTRL_SPACING *\r\nchannel) & COH901318_CX_CTRL_TC_VALUE_MASK) > 0)\r\ncohc->stopped = 1;\r\nenable_powersave(cohc);\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\n}\r\nstatic void coh901318_resume(struct dma_chan *chan)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nint channel = cohc->id;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\ndisable_powersave(cohc);\r\nif (cohc->stopped) {\r\nval = readl(cohc->base->virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING * channel);\r\nval |= COH901318_CX_CFG_CH_ENABLE;\r\nwritel(val, cohc->base->virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING*channel);\r\ncohc->stopped = 0;\r\n}\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\n}\r\nbool coh901318_filter_id(struct dma_chan *chan, void *chan_id)\r\n{\r\nunsigned int ch_nr = (unsigned int) chan_id;\r\nif (ch_nr == to_coh901318_chan(chan)->id)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int coh901318_config(struct coh901318_chan *cohc,\r\nstruct coh901318_params *param)\r\n{\r\nunsigned long flags;\r\nconst struct coh901318_params *p;\r\nint channel = cohc->id;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\nif (param)\r\np = param;\r\nelse\r\np = &cohc->base->platform->chan_conf[channel].param;\r\nif (channel < 32) {\r\nwritel(1 << channel, virtbase + COH901318_BE_INT_CLEAR1);\r\nwritel(1 << channel, virtbase + COH901318_TC_INT_CLEAR1);\r\n} else {\r\nwritel(1 << (channel - 32), virtbase +\r\nCOH901318_BE_INT_CLEAR2);\r\nwritel(1 << (channel - 32), virtbase +\r\nCOH901318_TC_INT_CLEAR2);\r\n}\r\ncoh901318_set_conf(cohc, p->config);\r\ncoh901318_set_ctrl(cohc, p->ctrl_lli_last);\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct coh901318_desc *coh901318_queue_start(struct coh901318_chan *cohc)\r\n{\r\nstruct coh901318_desc *cohd;\r\ncohd = coh901318_first_queued(cohc);\r\nif (cohd != NULL) {\r\ncoh901318_desc_remove(cohd);\r\ncohc->busy = 1;\r\ncoh901318_desc_submit(cohc, cohd);\r\ncoh901318_set_conf(cohc, cohd->head_config);\r\ncoh901318_set_ctrl(cohc, cohd->head_ctrl);\r\ncoh901318_prep_linked_list(cohc, cohd->lli);\r\ncoh901318_start(cohc);\r\n}\r\nreturn cohd;\r\n}\r\nstatic void dma_tasklet(unsigned long data)\r\n{\r\nstruct coh901318_chan *cohc = (struct coh901318_chan *) data;\r\nstruct coh901318_desc *cohd_fin;\r\nunsigned long flags;\r\ndma_async_tx_callback callback;\r\nvoid *callback_param;\r\ndev_vdbg(COHC_2_DEV(cohc), "[%s] chan_id %d"\r\n" nbr_active_done %ld\n", __func__,\r\ncohc->id, cohc->nbr_active_done);\r\nspin_lock_irqsave(&cohc->lock, flags);\r\ncohd_fin = coh901318_first_active_get(cohc);\r\nif (cohd_fin == NULL)\r\ngoto err;\r\ncallback = cohd_fin->desc.callback;\r\ncallback_param = cohd_fin->desc.callback_param;\r\ndma_cookie_complete(&cohd_fin->desc);\r\ncoh901318_lli_free(&cohc->base->pool, &cohd_fin->lli);\r\ncoh901318_desc_remove(cohd_fin);\r\ncoh901318_desc_free(cohc, cohd_fin);\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nif (callback)\r\ncallback(callback_param);\r\nspin_lock_irqsave(&cohc->lock, flags);\r\ncohc->nbr_active_done--;\r\nif (cohc->nbr_active_done) {\r\ndev_dbg(COHC_2_DEV(cohc), "scheduling tasklet again, new IRQs "\r\n"came in while we were scheduling this tasklet\n");\r\nif (cohc_chan_conf(cohc)->priority_high)\r\ntasklet_hi_schedule(&cohc->tasklet);\r\nelse\r\ntasklet_schedule(&cohc->tasklet);\r\n}\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nreturn;\r\nerr:\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\ndev_err(COHC_2_DEV(cohc), "[%s] No active dma desc\n", __func__);\r\n}\r\nstatic void dma_tc_handle(struct coh901318_chan *cohc)\r\n{\r\nif (!cohc->allocated) {\r\ndev_err(COHC_2_DEV(cohc), "spurious interrupt from "\r\n"unallocated channel\n");\r\nreturn;\r\n}\r\nspin_lock(&cohc->lock);\r\nBUG_ON(list_empty(&cohc->active));\r\ncohc->nbr_active_done++;\r\nif (coh901318_queue_start(cohc) == NULL)\r\ncohc->busy = 0;\r\nspin_unlock(&cohc->lock);\r\nif (cohc_chan_conf(cohc)->priority_high)\r\ntasklet_hi_schedule(&cohc->tasklet);\r\nelse\r\ntasklet_schedule(&cohc->tasklet);\r\n}\r\nstatic irqreturn_t dma_irq_handler(int irq, void *dev_id)\r\n{\r\nu32 status1;\r\nu32 status2;\r\nint i;\r\nint ch;\r\nstruct coh901318_base *base = dev_id;\r\nstruct coh901318_chan *cohc;\r\nvoid __iomem *virtbase = base->virtbase;\r\nstatus1 = readl(virtbase + COH901318_INT_STATUS1);\r\nstatus2 = readl(virtbase + COH901318_INT_STATUS2);\r\nif (unlikely(status1 == 0 && status2 == 0)) {\r\ndev_warn(base->dev, "spurious DMA IRQ from no channel!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nwhile (status1) {\r\ni = ffs(status1) - 1;\r\nch = i;\r\ncohc = &base->chans[ch];\r\nspin_lock(&cohc->lock);\r\nstatus1 &= ~(1 << i);\r\nif (test_bit(i, virtbase + COH901318_BE_INT_STATUS1)) {\r\ndev_crit(COHC_2_DEV(cohc),\r\n"DMA bus error on channel %d!\n", ch);\r\nBUG_ON(1);\r\n__set_bit(i, virtbase + COH901318_BE_INT_CLEAR1);\r\n} else {\r\nif (unlikely(!test_bit(i, virtbase +\r\nCOH901318_TC_INT_STATUS1))) {\r\ndev_warn(COHC_2_DEV(cohc),\r\n"ignoring interrupt not caused by terminal count on channel %d\n", ch);\r\nBUG_ON(1);\r\n__set_bit(i, virtbase + COH901318_TC_INT_CLEAR1);\r\n} else {\r\nif (!(readl(virtbase + COH901318_CX_STAT +\r\nCOH901318_CX_STAT_SPACING*ch) &\r\nCOH901318_CX_STAT_ENABLED)) {\r\nenable_powersave(cohc);\r\n}\r\n__set_bit(i, virtbase + COH901318_TC_INT_CLEAR1);\r\ndma_tc_handle(cohc);\r\n}\r\n}\r\nspin_unlock(&cohc->lock);\r\n}\r\nwhile (status2) {\r\ni = ffs(status2) - 1;\r\nch = i + 32;\r\ncohc = &base->chans[ch];\r\nspin_lock(&cohc->lock);\r\nstatus2 &= ~(1 << i);\r\nif (test_bit(i, virtbase + COH901318_BE_INT_STATUS2)) {\r\ndev_crit(COHC_2_DEV(cohc),\r\n"DMA bus error on channel %d!\n", ch);\r\nBUG_ON(1);\r\n__set_bit(i, virtbase + COH901318_BE_INT_CLEAR2);\r\n} else {\r\nif (unlikely(!test_bit(i, virtbase +\r\nCOH901318_TC_INT_STATUS2))) {\r\ndev_warn(COHC_2_DEV(cohc),\r\n"ignoring interrupt not caused by terminal count on channel %d\n", ch);\r\n__set_bit(i, virtbase + COH901318_TC_INT_CLEAR2);\r\nBUG_ON(1);\r\n} else {\r\nif (!(readl(virtbase + COH901318_CX_STAT +\r\nCOH901318_CX_STAT_SPACING*ch) &\r\nCOH901318_CX_STAT_ENABLED)) {\r\nenable_powersave(cohc);\r\n}\r\n__set_bit(i, virtbase + COH901318_TC_INT_CLEAR2);\r\ndma_tc_handle(cohc);\r\n}\r\n}\r\nspin_unlock(&cohc->lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int coh901318_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nunsigned long flags;\r\ndev_vdbg(COHC_2_DEV(cohc), "[%s] DMA channel %d\n",\r\n__func__, cohc->id);\r\nif (chan->client_count > 1)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\ncoh901318_config(cohc, NULL);\r\ncohc->allocated = 1;\r\ndma_cookie_init(chan);\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nreturn 1;\r\n}\r\nstatic void\r\ncoh901318_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nint channel = cohc->id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\nwritel(0x00000000U, cohc->base->virtbase + COH901318_CX_CFG +\r\nCOH901318_CX_CFG_SPACING*channel);\r\nwritel(0x00000000U, cohc->base->virtbase + COH901318_CX_CTRL +\r\nCOH901318_CX_CTRL_SPACING*channel);\r\ncohc->allocated = 0;\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nchan->device->device_control(chan, DMA_TERMINATE_ALL, 0);\r\n}\r\nstatic dma_cookie_t\r\ncoh901318_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct coh901318_desc *cohd = container_of(tx, struct coh901318_desc,\r\ndesc);\r\nstruct coh901318_chan *cohc = to_coh901318_chan(tx->chan);\r\nunsigned long flags;\r\ndma_cookie_t cookie;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\ncookie = dma_cookie_assign(tx);\r\ncoh901318_desc_queue(cohc, cohd);\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nreturn cookie;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\ncoh901318_prep_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\r\nsize_t size, unsigned long flags)\r\n{\r\nstruct coh901318_lli *lli;\r\nstruct coh901318_desc *cohd;\r\nunsigned long flg;\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nint lli_len;\r\nu32 ctrl_last = cohc_chan_param(cohc)->ctrl_lli_last;\r\nint ret;\r\nspin_lock_irqsave(&cohc->lock, flg);\r\ndev_vdbg(COHC_2_DEV(cohc),\r\n"[%s] channel %d src 0x%x dest 0x%x size %d\n",\r\n__func__, cohc->id, src, dest, size);\r\nif (flags & DMA_PREP_INTERRUPT)\r\nctrl_last |= COH901318_CX_CTRL_TC_IRQ_ENABLE;\r\nlli_len = size >> MAX_DMA_PACKET_SIZE_SHIFT;\r\nif ((lli_len << MAX_DMA_PACKET_SIZE_SHIFT) < size)\r\nlli_len++;\r\nlli = coh901318_lli_alloc(&cohc->base->pool, lli_len);\r\nif (lli == NULL)\r\ngoto err;\r\nret = coh901318_lli_fill_memcpy(\r\n&cohc->base->pool, lli, src, size, dest,\r\ncohc_chan_param(cohc)->ctrl_lli_chained,\r\nctrl_last);\r\nif (ret)\r\ngoto err;\r\nCOH_DBG(coh901318_list_print(cohc, lli));\r\ncohd = coh901318_desc_get(cohc);\r\ncohd->lli = lli;\r\ncohd->flags = flags;\r\ncohd->desc.tx_submit = coh901318_tx_submit;\r\nspin_unlock_irqrestore(&cohc->lock, flg);\r\nreturn &cohd->desc;\r\nerr:\r\nspin_unlock_irqrestore(&cohc->lock, flg);\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\ncoh901318_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction direction,\r\nunsigned long flags, void *context)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nstruct coh901318_lli *lli;\r\nstruct coh901318_desc *cohd;\r\nconst struct coh901318_params *params;\r\nstruct scatterlist *sg;\r\nint len = 0;\r\nint size;\r\nint i;\r\nu32 ctrl_chained = cohc_chan_param(cohc)->ctrl_lli_chained;\r\nu32 ctrl = cohc_chan_param(cohc)->ctrl_lli;\r\nu32 ctrl_last = cohc_chan_param(cohc)->ctrl_lli_last;\r\nu32 config;\r\nunsigned long flg;\r\nint ret;\r\nif (!sgl)\r\ngoto out;\r\nif (sg_dma_len(sgl) == 0)\r\ngoto out;\r\nspin_lock_irqsave(&cohc->lock, flg);\r\ndev_vdbg(COHC_2_DEV(cohc), "[%s] sg_len %d dir %d\n",\r\n__func__, sg_len, direction);\r\nif (flags & DMA_PREP_INTERRUPT)\r\nctrl_last |= COH901318_CX_CTRL_TC_IRQ_ENABLE;\r\nparams = cohc_chan_param(cohc);\r\nconfig = params->config;\r\nctrl_chained |= cohc->runtime_ctrl;\r\nctrl_last |= cohc->runtime_ctrl;\r\nctrl |= cohc->runtime_ctrl;\r\nif (direction == DMA_MEM_TO_DEV) {\r\nu32 tx_flags = COH901318_CX_CTRL_PRDD_SOURCE |\r\nCOH901318_CX_CTRL_SRC_ADDR_INC_ENABLE;\r\nconfig |= COH901318_CX_CFG_RM_MEMORY_TO_PRIMARY;\r\nctrl_chained |= tx_flags;\r\nctrl_last |= tx_flags;\r\nctrl |= tx_flags;\r\n} else if (direction == DMA_DEV_TO_MEM) {\r\nu32 rx_flags = COH901318_CX_CTRL_PRDD_DEST |\r\nCOH901318_CX_CTRL_DST_ADDR_INC_ENABLE;\r\nconfig |= COH901318_CX_CFG_RM_PRIMARY_TO_MEMORY;\r\nctrl_chained |= rx_flags;\r\nctrl_last |= rx_flags;\r\nctrl |= rx_flags;\r\n} else\r\ngoto err_direction;\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\nunsigned int factor;\r\nsize = sg_dma_len(sg);\r\nif (size <= MAX_DMA_PACKET_SIZE) {\r\nlen++;\r\ncontinue;\r\n}\r\nfactor = size >> MAX_DMA_PACKET_SIZE_SHIFT;\r\nif ((factor << MAX_DMA_PACKET_SIZE_SHIFT) < size)\r\nfactor++;\r\nlen += factor;\r\n}\r\npr_debug("Allocate %d lli:s for this transfer\n", len);\r\nlli = coh901318_lli_alloc(&cohc->base->pool, len);\r\nif (lli == NULL)\r\ngoto err_dma_alloc;\r\nret = coh901318_lli_fill_sg(&cohc->base->pool, lli, sgl, sg_len,\r\ncohc_dev_addr(cohc),\r\nctrl_chained,\r\nctrl,\r\nctrl_last,\r\ndirection, COH901318_CX_CTRL_TC_IRQ_ENABLE);\r\nif (ret)\r\ngoto err_lli_fill;\r\nCOH_DBG(coh901318_list_print(cohc, lli));\r\ncohd = coh901318_desc_get(cohc);\r\ncohd->head_config = config;\r\ncohd->head_ctrl = lli->control;\r\ncohd->dir = direction;\r\ncohd->flags = flags;\r\ncohd->desc.tx_submit = coh901318_tx_submit;\r\ncohd->lli = lli;\r\nspin_unlock_irqrestore(&cohc->lock, flg);\r\nreturn &cohd->desc;\r\nerr_lli_fill:\r\nerr_dma_alloc:\r\nerr_direction:\r\nspin_unlock_irqrestore(&cohc->lock, flg);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic enum dma_status\r\ncoh901318_tx_status(struct dma_chan *chan, dma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nenum dma_status ret;\r\nret = dma_cookie_status(chan, cookie, txstate);\r\ndma_set_residue(txstate, coh901318_get_bytes_left(chan));\r\nif (ret == DMA_IN_PROGRESS && cohc->stopped)\r\nret = DMA_PAUSED;\r\nreturn ret;\r\n}\r\nstatic void\r\ncoh901318_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&cohc->lock, flags);\r\nif (!cohc->busy)\r\ncoh901318_queue_start(cohc);\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\n}\r\nstatic void coh901318_dma_set_runtimeconfig(struct dma_chan *chan,\r\nstruct dma_slave_config *config)\r\n{\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\ndma_addr_t addr;\r\nenum dma_slave_buswidth addr_width;\r\nu32 maxburst;\r\nu32 runtime_ctrl = 0;\r\nint i = 0;\r\nif (config->direction == DMA_DEV_TO_MEM) {\r\naddr = config->src_addr;\r\naddr_width = config->src_addr_width;\r\nmaxburst = config->src_maxburst;\r\n} else if (config->direction == DMA_MEM_TO_DEV) {\r\naddr = config->dst_addr;\r\naddr_width = config->dst_addr_width;\r\nmaxburst = config->dst_maxburst;\r\n} else {\r\ndev_err(COHC_2_DEV(cohc), "illegal channel mode\n");\r\nreturn;\r\n}\r\ndev_dbg(COHC_2_DEV(cohc), "configure channel for %d byte transfers\n",\r\naddr_width);\r\nswitch (addr_width) {\r\ncase DMA_SLAVE_BUSWIDTH_1_BYTE:\r\nruntime_ctrl |=\r\nCOH901318_CX_CTRL_SRC_BUS_SIZE_8_BITS |\r\nCOH901318_CX_CTRL_DST_BUS_SIZE_8_BITS;\r\nwhile (i < ARRAY_SIZE(burst_sizes)) {\r\nif (burst_sizes[i].burst_8bit <= maxburst)\r\nbreak;\r\ni++;\r\n}\r\nbreak;\r\ncase DMA_SLAVE_BUSWIDTH_2_BYTES:\r\nruntime_ctrl |=\r\nCOH901318_CX_CTRL_SRC_BUS_SIZE_16_BITS |\r\nCOH901318_CX_CTRL_DST_BUS_SIZE_16_BITS;\r\nwhile (i < ARRAY_SIZE(burst_sizes)) {\r\nif (burst_sizes[i].burst_16bit <= maxburst)\r\nbreak;\r\ni++;\r\n}\r\nbreak;\r\ncase DMA_SLAVE_BUSWIDTH_4_BYTES:\r\nruntime_ctrl |=\r\nCOH901318_CX_CTRL_SRC_BUS_SIZE_32_BITS |\r\nCOH901318_CX_CTRL_DST_BUS_SIZE_32_BITS;\r\nwhile (i < ARRAY_SIZE(burst_sizes)) {\r\nif (burst_sizes[i].burst_32bit <= maxburst)\r\nbreak;\r\ni++;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(COHC_2_DEV(cohc),\r\n"bad runtimeconfig: alien address width\n");\r\nreturn;\r\n}\r\nruntime_ctrl |= burst_sizes[i].reg;\r\ndev_dbg(COHC_2_DEV(cohc),\r\n"selected burst size %d bytes for address width %d bytes, maxburst %d\n",\r\nburst_sizes[i].burst_8bit, addr_width, maxburst);\r\ncohc->runtime_addr = addr;\r\ncohc->runtime_ctrl = runtime_ctrl;\r\n}\r\nstatic int\r\ncoh901318_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nunsigned long flags;\r\nstruct coh901318_chan *cohc = to_coh901318_chan(chan);\r\nstruct coh901318_desc *cohd;\r\nvoid __iomem *virtbase = cohc->base->virtbase;\r\nif (cmd == DMA_SLAVE_CONFIG) {\r\nstruct dma_slave_config *config =\r\n(struct dma_slave_config *) arg;\r\ncoh901318_dma_set_runtimeconfig(chan, config);\r\nreturn 0;\r\n}\r\nif (cmd == DMA_PAUSE) {\r\ncoh901318_pause(chan);\r\nreturn 0;\r\n}\r\nif (cmd == DMA_RESUME) {\r\ncoh901318_resume(chan);\r\nreturn 0;\r\n}\r\nif (cmd != DMA_TERMINATE_ALL)\r\nreturn -ENXIO;\r\ncoh901318_pause(chan);\r\nspin_lock_irqsave(&cohc->lock, flags);\r\nif (cohc->id < 32) {\r\nwritel(1 << cohc->id, virtbase + COH901318_BE_INT_CLEAR1);\r\nwritel(1 << cohc->id, virtbase + COH901318_TC_INT_CLEAR1);\r\n} else {\r\nwritel(1 << (cohc->id - 32), virtbase +\r\nCOH901318_BE_INT_CLEAR2);\r\nwritel(1 << (cohc->id - 32), virtbase +\r\nCOH901318_TC_INT_CLEAR2);\r\n}\r\nenable_powersave(cohc);\r\nwhile ((cohd = coh901318_first_active_get(cohc))) {\r\ncoh901318_lli_free(&cohc->base->pool, &cohd->lli);\r\ncoh901318_desc_remove(cohd);\r\ncoh901318_desc_free(cohc, cohd);\r\n}\r\nwhile ((cohd = coh901318_first_queued(cohc))) {\r\ncoh901318_lli_free(&cohc->base->pool, &cohd->lli);\r\ncoh901318_desc_remove(cohd);\r\ncoh901318_desc_free(cohc, cohd);\r\n}\r\ncohc->nbr_active_done = 0;\r\ncohc->busy = 0;\r\nspin_unlock_irqrestore(&cohc->lock, flags);\r\nreturn 0;\r\n}\r\nvoid coh901318_base_init(struct dma_device *dma, const int *pick_chans,\r\nstruct coh901318_base *base)\r\n{\r\nint chans_i;\r\nint i = 0;\r\nstruct coh901318_chan *cohc;\r\nINIT_LIST_HEAD(&dma->channels);\r\nfor (chans_i = 0; pick_chans[chans_i] != -1; chans_i += 2) {\r\nfor (i = pick_chans[chans_i]; i <= pick_chans[chans_i+1]; i++) {\r\ncohc = &base->chans[i];\r\ncohc->base = base;\r\ncohc->chan.device = dma;\r\ncohc->id = i;\r\nspin_lock_init(&cohc->lock);\r\ncohc->nbr_active_done = 0;\r\ncohc->busy = 0;\r\nINIT_LIST_HEAD(&cohc->free);\r\nINIT_LIST_HEAD(&cohc->active);\r\nINIT_LIST_HEAD(&cohc->queue);\r\ntasklet_init(&cohc->tasklet, dma_tasklet,\r\n(unsigned long) cohc);\r\nlist_add_tail(&cohc->chan.device_node,\r\n&dma->channels);\r\n}\r\n}\r\n}\r\nstatic int __init coh901318_probe(struct platform_device *pdev)\r\n{\r\nint err = 0;\r\nstruct coh901318_platform *pdata;\r\nstruct coh901318_base *base;\r\nint irq;\r\nstruct resource *io;\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!io)\r\nreturn -ENODEV;\r\nif (devm_request_mem_region(&pdev->dev,\r\nio->start,\r\nresource_size(io),\r\npdev->dev.driver->name) == NULL)\r\nreturn -ENOMEM;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nbase = devm_kzalloc(&pdev->dev,\r\nALIGN(sizeof(struct coh901318_base), 4) +\r\npdata->max_channels *\r\nsizeof(struct coh901318_chan),\r\nGFP_KERNEL);\r\nif (!base)\r\nreturn -ENOMEM;\r\nbase->chans = ((void *)base) + ALIGN(sizeof(struct coh901318_base), 4);\r\nbase->virtbase = devm_ioremap(&pdev->dev, io->start, resource_size(io));\r\nif (!base->virtbase)\r\nreturn -ENOMEM;\r\nbase->dev = &pdev->dev;\r\nbase->platform = pdata;\r\nspin_lock_init(&base->pm.lock);\r\nbase->pm.started_channels = 0;\r\nCOH901318_DEBUGFS_ASSIGN(debugfs_dma_base, base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nerr = devm_request_irq(&pdev->dev, irq, dma_irq_handler, IRQF_DISABLED,\r\n"coh901318", base);\r\nif (err)\r\nreturn err;\r\nerr = coh901318_pool_create(&base->pool, &pdev->dev,\r\nsizeof(struct coh901318_lli),\r\n32);\r\nif (err)\r\nreturn err;\r\ncoh901318_base_init(&base->dma_slave, base->platform->chans_slave,\r\nbase);\r\ndma_cap_zero(base->dma_slave.cap_mask);\r\ndma_cap_set(DMA_SLAVE, base->dma_slave.cap_mask);\r\nbase->dma_slave.device_alloc_chan_resources = coh901318_alloc_chan_resources;\r\nbase->dma_slave.device_free_chan_resources = coh901318_free_chan_resources;\r\nbase->dma_slave.device_prep_slave_sg = coh901318_prep_slave_sg;\r\nbase->dma_slave.device_tx_status = coh901318_tx_status;\r\nbase->dma_slave.device_issue_pending = coh901318_issue_pending;\r\nbase->dma_slave.device_control = coh901318_control;\r\nbase->dma_slave.dev = &pdev->dev;\r\nerr = dma_async_device_register(&base->dma_slave);\r\nif (err)\r\ngoto err_register_slave;\r\ncoh901318_base_init(&base->dma_memcpy, base->platform->chans_memcpy,\r\nbase);\r\ndma_cap_zero(base->dma_memcpy.cap_mask);\r\ndma_cap_set(DMA_MEMCPY, base->dma_memcpy.cap_mask);\r\nbase->dma_memcpy.device_alloc_chan_resources = coh901318_alloc_chan_resources;\r\nbase->dma_memcpy.device_free_chan_resources = coh901318_free_chan_resources;\r\nbase->dma_memcpy.device_prep_dma_memcpy = coh901318_prep_memcpy;\r\nbase->dma_memcpy.device_tx_status = coh901318_tx_status;\r\nbase->dma_memcpy.device_issue_pending = coh901318_issue_pending;\r\nbase->dma_memcpy.device_control = coh901318_control;\r\nbase->dma_memcpy.dev = &pdev->dev;\r\nbase->dma_memcpy.copy_align = 2;\r\nerr = dma_async_device_register(&base->dma_memcpy);\r\nif (err)\r\ngoto err_register_memcpy;\r\nplatform_set_drvdata(pdev, base);\r\ndev_info(&pdev->dev, "Initialized COH901318 DMA on virtual base 0x%08x\n",\r\n(u32) base->virtbase);\r\nreturn err;\r\nerr_register_memcpy:\r\ndma_async_device_unregister(&base->dma_slave);\r\nerr_register_slave:\r\ncoh901318_pool_destroy(&base->pool);\r\nreturn err;\r\n}\r\nstatic int __exit coh901318_remove(struct platform_device *pdev)\r\n{\r\nstruct coh901318_base *base = platform_get_drvdata(pdev);\r\ndma_async_device_unregister(&base->dma_memcpy);\r\ndma_async_device_unregister(&base->dma_slave);\r\ncoh901318_pool_destroy(&base->pool);\r\nreturn 0;\r\n}\r\nint __init coh901318_init(void)\r\n{\r\nreturn platform_driver_probe(&coh901318_driver, coh901318_probe);\r\n}\r\nvoid __exit coh901318_exit(void)\r\n{\r\nplatform_driver_unregister(&coh901318_driver);\r\n}
