static int clk_busy_wait(void __iomem *reg, u8 shift)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(10);\r\nwhile (readl_relaxed(reg) & (1 << shift))\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic inline struct clk_busy_divider *to_clk_busy_divider(struct clk_hw *hw)\r\n{\r\nstruct clk_divider *div = container_of(hw, struct clk_divider, hw);\r\nreturn container_of(div, struct clk_busy_divider, div);\r\n}\r\nstatic unsigned long clk_busy_divider_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_busy_divider *busy = to_clk_busy_divider(hw);\r\nreturn busy->div_ops->recalc_rate(&busy->div.hw, parent_rate);\r\n}\r\nstatic long clk_busy_divider_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_busy_divider *busy = to_clk_busy_divider(hw);\r\nreturn busy->div_ops->round_rate(&busy->div.hw, rate, prate);\r\n}\r\nstatic int clk_busy_divider_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_busy_divider *busy = to_clk_busy_divider(hw);\r\nint ret;\r\nret = busy->div_ops->set_rate(&busy->div.hw, rate, parent_rate);\r\nif (!ret)\r\nret = clk_busy_wait(busy->reg, busy->shift);\r\nreturn ret;\r\n}\r\nstruct clk *imx_clk_busy_divider(const char *name, const char *parent_name,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nvoid __iomem *busy_reg, u8 busy_shift)\r\n{\r\nstruct clk_busy_divider *busy;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nbusy = kzalloc(sizeof(*busy), GFP_KERNEL);\r\nif (!busy)\r\nreturn ERR_PTR(-ENOMEM);\r\nbusy->reg = busy_reg;\r\nbusy->shift = busy_shift;\r\nbusy->div.reg = reg;\r\nbusy->div.shift = shift;\r\nbusy->div.width = width;\r\nbusy->div.lock = &imx_ccm_lock;\r\nbusy->div_ops = &clk_divider_ops;\r\ninit.name = name;\r\ninit.ops = &clk_busy_divider_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nbusy->div.hw.init = &init;\r\nclk = clk_register(NULL, &busy->div.hw);\r\nif (IS_ERR(clk))\r\nkfree(busy);\r\nreturn clk;\r\n}\r\nstatic inline struct clk_busy_mux *to_clk_busy_mux(struct clk_hw *hw)\r\n{\r\nstruct clk_mux *mux = container_of(hw, struct clk_mux, hw);\r\nreturn container_of(mux, struct clk_busy_mux, mux);\r\n}\r\nstatic u8 clk_busy_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_busy_mux *busy = to_clk_busy_mux(hw);\r\nreturn busy->mux_ops->get_parent(&busy->mux.hw);\r\n}\r\nstatic int clk_busy_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_busy_mux *busy = to_clk_busy_mux(hw);\r\nint ret;\r\nret = busy->mux_ops->set_parent(&busy->mux.hw, index);\r\nif (!ret)\r\nret = clk_busy_wait(busy->reg, busy->shift);\r\nreturn ret;\r\n}\r\nstruct clk *imx_clk_busy_mux(const char *name, void __iomem *reg, u8 shift,\r\nu8 width, void __iomem *busy_reg, u8 busy_shift,\r\nconst char **parent_names, int num_parents)\r\n{\r\nstruct clk_busy_mux *busy;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nbusy = kzalloc(sizeof(*busy), GFP_KERNEL);\r\nif (!busy)\r\nreturn ERR_PTR(-ENOMEM);\r\nbusy->reg = busy_reg;\r\nbusy->shift = busy_shift;\r\nbusy->mux.reg = reg;\r\nbusy->mux.shift = shift;\r\nbusy->mux.width = width;\r\nbusy->mux.lock = &imx_ccm_lock;\r\nbusy->mux_ops = &clk_mux_ops;\r\ninit.name = name;\r\ninit.ops = &clk_busy_mux_ops;\r\ninit.flags = 0;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nbusy->mux.hw.init = &init;\r\nclk = clk_register(NULL, &busy->mux.hw);\r\nif (IS_ERR(clk))\r\nkfree(busy);\r\nreturn clk;\r\n}
