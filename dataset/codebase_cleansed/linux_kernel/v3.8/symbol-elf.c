static inline uint8_t elf_sym__type(const GElf_Sym *sym)\r\n{\r\nreturn GELF_ST_TYPE(sym->st_info);\r\n}\r\nstatic inline int elf_sym__is_function(const GElf_Sym *sym)\r\n{\r\nreturn elf_sym__type(sym) == STT_FUNC &&\r\nsym->st_name != 0 &&\r\nsym->st_shndx != SHN_UNDEF;\r\n}\r\nstatic inline bool elf_sym__is_object(const GElf_Sym *sym)\r\n{\r\nreturn elf_sym__type(sym) == STT_OBJECT &&\r\nsym->st_name != 0 &&\r\nsym->st_shndx != SHN_UNDEF;\r\n}\r\nstatic inline int elf_sym__is_label(const GElf_Sym *sym)\r\n{\r\nreturn elf_sym__type(sym) == STT_NOTYPE &&\r\nsym->st_name != 0 &&\r\nsym->st_shndx != SHN_UNDEF &&\r\nsym->st_shndx != SHN_ABS;\r\n}\r\nstatic bool elf_sym__is_a(GElf_Sym *sym, enum map_type type)\r\n{\r\nswitch (type) {\r\ncase MAP__FUNCTION:\r\nreturn elf_sym__is_function(sym);\r\ncase MAP__VARIABLE:\r\nreturn elf_sym__is_object(sym);\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline const char *elf_sym__name(const GElf_Sym *sym,\r\nconst Elf_Data *symstrs)\r\n{\r\nreturn symstrs->d_buf + sym->st_name;\r\n}\r\nstatic inline const char *elf_sec__name(const GElf_Shdr *shdr,\r\nconst Elf_Data *secstrs)\r\n{\r\nreturn secstrs->d_buf + shdr->sh_name;\r\n}\r\nstatic inline int elf_sec__is_text(const GElf_Shdr *shdr,\r\nconst Elf_Data *secstrs)\r\n{\r\nreturn strstr(elf_sec__name(shdr, secstrs), "text") != NULL;\r\n}\r\nstatic inline bool elf_sec__is_data(const GElf_Shdr *shdr,\r\nconst Elf_Data *secstrs)\r\n{\r\nreturn strstr(elf_sec__name(shdr, secstrs), "data") != NULL;\r\n}\r\nstatic bool elf_sec__is_a(GElf_Shdr *shdr, Elf_Data *secstrs,\r\nenum map_type type)\r\n{\r\nswitch (type) {\r\ncase MAP__FUNCTION:\r\nreturn elf_sec__is_text(shdr, secstrs);\r\ncase MAP__VARIABLE:\r\nreturn elf_sec__is_data(shdr, secstrs);\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic size_t elf_addr_to_index(Elf *elf, GElf_Addr addr)\r\n{\r\nElf_Scn *sec = NULL;\r\nGElf_Shdr shdr;\r\nsize_t cnt = 1;\r\nwhile ((sec = elf_nextscn(elf, sec)) != NULL) {\r\ngelf_getshdr(sec, &shdr);\r\nif ((addr >= shdr.sh_addr) &&\r\n(addr < (shdr.sh_addr + shdr.sh_size)))\r\nreturn cnt;\r\n++cnt;\r\n}\r\nreturn -1;\r\n}\r\nstatic Elf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,\r\nGElf_Shdr *shp, const char *name,\r\nsize_t *idx)\r\n{\r\nElf_Scn *sec = NULL;\r\nsize_t cnt = 1;\r\nif (!elf_rawdata(elf_getscn(elf, ep->e_shstrndx), NULL))\r\nreturn NULL;\r\nwhile ((sec = elf_nextscn(elf, sec)) != NULL) {\r\nchar *str;\r\ngelf_getshdr(sec, shp);\r\nstr = elf_strptr(elf, ep->e_shstrndx, shp->sh_name);\r\nif (!strcmp(name, str)) {\r\nif (idx)\r\n*idx = cnt;\r\nbreak;\r\n}\r\n++cnt;\r\n}\r\nreturn sec;\r\n}\r\nint dso__synthesize_plt_symbols(struct dso *dso, struct symsrc *ss, struct map *map,\r\nsymbol_filter_t filter)\r\n{\r\nuint32_t nr_rel_entries, idx;\r\nGElf_Sym sym;\r\nu64 plt_offset;\r\nGElf_Shdr shdr_plt;\r\nstruct symbol *f;\r\nGElf_Shdr shdr_rel_plt, shdr_dynsym;\r\nElf_Data *reldata, *syms, *symstrs;\r\nElf_Scn *scn_plt_rel, *scn_symstrs, *scn_dynsym;\r\nsize_t dynsym_idx;\r\nGElf_Ehdr ehdr;\r\nchar sympltname[1024];\r\nElf *elf;\r\nint nr = 0, symidx, err = 0;\r\nif (!ss->dynsym)\r\nreturn 0;\r\nelf = ss->elf;\r\nehdr = ss->ehdr;\r\nscn_dynsym = ss->dynsym;\r\nshdr_dynsym = ss->dynshdr;\r\ndynsym_idx = ss->dynsym_idx;\r\nif (scn_dynsym == NULL)\r\ngoto out_elf_end;\r\nscn_plt_rel = elf_section_by_name(elf, &ehdr, &shdr_rel_plt,\r\n".rela.plt", NULL);\r\nif (scn_plt_rel == NULL) {\r\nscn_plt_rel = elf_section_by_name(elf, &ehdr, &shdr_rel_plt,\r\n".rel.plt", NULL);\r\nif (scn_plt_rel == NULL)\r\ngoto out_elf_end;\r\n}\r\nerr = -1;\r\nif (shdr_rel_plt.sh_link != dynsym_idx)\r\ngoto out_elf_end;\r\nif (elf_section_by_name(elf, &ehdr, &shdr_plt, ".plt", NULL) == NULL)\r\ngoto out_elf_end;\r\nreldata = elf_getdata(scn_plt_rel, NULL);\r\nif (reldata == NULL)\r\ngoto out_elf_end;\r\nsyms = elf_getdata(scn_dynsym, NULL);\r\nif (syms == NULL)\r\ngoto out_elf_end;\r\nscn_symstrs = elf_getscn(elf, shdr_dynsym.sh_link);\r\nif (scn_symstrs == NULL)\r\ngoto out_elf_end;\r\nsymstrs = elf_getdata(scn_symstrs, NULL);\r\nif (symstrs == NULL)\r\ngoto out_elf_end;\r\nif (symstrs->d_size == 0)\r\ngoto out_elf_end;\r\nnr_rel_entries = shdr_rel_plt.sh_size / shdr_rel_plt.sh_entsize;\r\nplt_offset = shdr_plt.sh_offset;\r\nif (shdr_rel_plt.sh_type == SHT_RELA) {\r\nGElf_Rela pos_mem, *pos;\r\nelf_section__for_each_rela(reldata, pos, pos_mem, idx,\r\nnr_rel_entries) {\r\nsymidx = GELF_R_SYM(pos->r_info);\r\nplt_offset += shdr_plt.sh_entsize;\r\ngelf_getsym(syms, symidx, &sym);\r\nsnprintf(sympltname, sizeof(sympltname),\r\n"%s@plt", elf_sym__name(&sym, symstrs));\r\nf = symbol__new(plt_offset, shdr_plt.sh_entsize,\r\nSTB_GLOBAL, sympltname);\r\nif (!f)\r\ngoto out_elf_end;\r\nif (filter && filter(map, f))\r\nsymbol__delete(f);\r\nelse {\r\nsymbols__insert(&dso->symbols[map->type], f);\r\n++nr;\r\n}\r\n}\r\n} else if (shdr_rel_plt.sh_type == SHT_REL) {\r\nGElf_Rel pos_mem, *pos;\r\nelf_section__for_each_rel(reldata, pos, pos_mem, idx,\r\nnr_rel_entries) {\r\nsymidx = GELF_R_SYM(pos->r_info);\r\nplt_offset += shdr_plt.sh_entsize;\r\ngelf_getsym(syms, symidx, &sym);\r\nsnprintf(sympltname, sizeof(sympltname),\r\n"%s@plt", elf_sym__name(&sym, symstrs));\r\nf = symbol__new(plt_offset, shdr_plt.sh_entsize,\r\nSTB_GLOBAL, sympltname);\r\nif (!f)\r\ngoto out_elf_end;\r\nif (filter && filter(map, f))\r\nsymbol__delete(f);\r\nelse {\r\nsymbols__insert(&dso->symbols[map->type], f);\r\n++nr;\r\n}\r\n}\r\n}\r\nerr = 0;\r\nout_elf_end:\r\nif (err == 0)\r\nreturn nr;\r\npr_debug("%s: problems reading %s PLT info.\n",\r\n__func__, dso->long_name);\r\nreturn 0;\r\n}\r\nstatic int elf_read_build_id(Elf *elf, void *bf, size_t size)\r\n{\r\nint err = -1;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nElf_Data *data;\r\nElf_Scn *sec;\r\nElf_Kind ek;\r\nvoid *ptr;\r\nif (size < BUILD_ID_SIZE)\r\ngoto out;\r\nek = elf_kind(elf);\r\nif (ek != ELF_K_ELF)\r\ngoto out;\r\nif (gelf_getehdr(elf, &ehdr) == NULL) {\r\npr_err("%s: cannot get elf header.\n", __func__);\r\ngoto out;\r\n}\r\ndo {\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".note.gnu.build-id", NULL);\r\nif (sec)\r\nbreak;\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".notes", NULL);\r\nif (sec)\r\nbreak;\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".note", NULL);\r\nif (sec)\r\nbreak;\r\nreturn err;\r\n} while (0);\r\ndata = elf_getdata(sec, NULL);\r\nif (data == NULL)\r\ngoto out;\r\nptr = data->d_buf;\r\nwhile (ptr < (data->d_buf + data->d_size)) {\r\nGElf_Nhdr *nhdr = ptr;\r\nsize_t namesz = NOTE_ALIGN(nhdr->n_namesz),\r\ndescsz = NOTE_ALIGN(nhdr->n_descsz);\r\nconst char *name;\r\nptr += sizeof(*nhdr);\r\nname = ptr;\r\nptr += namesz;\r\nif (nhdr->n_type == NT_GNU_BUILD_ID &&\r\nnhdr->n_namesz == sizeof("GNU")) {\r\nif (memcmp(name, "GNU", sizeof("GNU")) == 0) {\r\nsize_t sz = min(size, descsz);\r\nmemcpy(bf, ptr, sz);\r\nmemset(bf + sz, 0, size - sz);\r\nerr = descsz;\r\nbreak;\r\n}\r\n}\r\nptr += descsz;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint filename__read_build_id(const char *filename, void *bf, size_t size)\r\n{\r\nint fd, err = -1;\r\nElf *elf;\r\nif (size < BUILD_ID_SIZE)\r\ngoto out;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\ngoto out;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL) {\r\npr_debug2("%s: cannot read %s ELF file.\n", __func__, filename);\r\ngoto out_close;\r\n}\r\nerr = elf_read_build_id(elf, bf, size);\r\nelf_end(elf);\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nint sysfs__read_build_id(const char *filename, void *build_id, size_t size)\r\n{\r\nint fd, err = -1;\r\nif (size < BUILD_ID_SIZE)\r\ngoto out;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\ngoto out;\r\nwhile (1) {\r\nchar bf[BUFSIZ];\r\nGElf_Nhdr nhdr;\r\nsize_t namesz, descsz;\r\nif (read(fd, &nhdr, sizeof(nhdr)) != sizeof(nhdr))\r\nbreak;\r\nnamesz = NOTE_ALIGN(nhdr.n_namesz);\r\ndescsz = NOTE_ALIGN(nhdr.n_descsz);\r\nif (nhdr.n_type == NT_GNU_BUILD_ID &&\r\nnhdr.n_namesz == sizeof("GNU")) {\r\nif (read(fd, bf, namesz) != (ssize_t)namesz)\r\nbreak;\r\nif (memcmp(bf, "GNU", sizeof("GNU")) == 0) {\r\nsize_t sz = min(descsz, size);\r\nif (read(fd, build_id, sz) == (ssize_t)sz) {\r\nmemset(build_id + sz, 0, size - sz);\r\nerr = 0;\r\nbreak;\r\n}\r\n} else if (read(fd, bf, descsz) != (ssize_t)descsz)\r\nbreak;\r\n} else {\r\nint n = namesz + descsz;\r\nif (read(fd, bf, n) != n)\r\nbreak;\r\n}\r\n}\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nint filename__read_debuglink(const char *filename, char *debuglink,\r\nsize_t size)\r\n{\r\nint fd, err = -1;\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nElf_Data *data;\r\nElf_Scn *sec;\r\nElf_Kind ek;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\ngoto out;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL) {\r\npr_debug2("%s: cannot read %s ELF file.\n", __func__, filename);\r\ngoto out_close;\r\n}\r\nek = elf_kind(elf);\r\nif (ek != ELF_K_ELF)\r\ngoto out_close;\r\nif (gelf_getehdr(elf, &ehdr) == NULL) {\r\npr_err("%s: cannot get elf header.\n", __func__);\r\ngoto out_close;\r\n}\r\nsec = elf_section_by_name(elf, &ehdr, &shdr,\r\n".gnu_debuglink", NULL);\r\nif (sec == NULL)\r\ngoto out_close;\r\ndata = elf_getdata(sec, NULL);\r\nif (data == NULL)\r\ngoto out_close;\r\nstrncpy(debuglink, data->d_buf, size);\r\nelf_end(elf);\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nstatic int dso__swap_init(struct dso *dso, unsigned char eidata)\r\n{\r\nstatic unsigned int const endian = 1;\r\ndso->needs_swap = DSO_SWAP__NO;\r\nswitch (eidata) {\r\ncase ELFDATA2LSB:\r\nif (*(unsigned char const *)&endian != 1)\r\ndso->needs_swap = DSO_SWAP__YES;\r\nbreak;\r\ncase ELFDATA2MSB:\r\nif (*(unsigned char const *)&endian != 0)\r\ndso->needs_swap = DSO_SWAP__YES;\r\nbreak;\r\ndefault:\r\npr_err("unrecognized DSO data encoding %d\n", eidata);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nbool symsrc__possibly_runtime(struct symsrc *ss)\r\n{\r\nreturn ss->dynsym || ss->opdsec;\r\n}\r\nbool symsrc__has_symtab(struct symsrc *ss)\r\n{\r\nreturn ss->symtab != NULL;\r\n}\r\nvoid symsrc__destroy(struct symsrc *ss)\r\n{\r\nfree(ss->name);\r\nelf_end(ss->elf);\r\nclose(ss->fd);\r\n}\r\nint symsrc__init(struct symsrc *ss, struct dso *dso, const char *name,\r\nenum dso_binary_type type)\r\n{\r\nint err = -1;\r\nGElf_Ehdr ehdr;\r\nElf *elf;\r\nint fd;\r\nfd = open(name, O_RDONLY);\r\nif (fd < 0)\r\nreturn -1;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL) {\r\npr_debug("%s: cannot read %s ELF file.\n", __func__, name);\r\ngoto out_close;\r\n}\r\nif (gelf_getehdr(elf, &ehdr) == NULL) {\r\npr_debug("%s: cannot get elf header.\n", __func__);\r\ngoto out_elf_end;\r\n}\r\nif (dso__swap_init(dso, ehdr.e_ident[EI_DATA]))\r\ngoto out_elf_end;\r\nif (dso->has_build_id) {\r\nu8 build_id[BUILD_ID_SIZE];\r\nif (elf_read_build_id(elf, build_id, BUILD_ID_SIZE) < 0)\r\ngoto out_elf_end;\r\nif (!dso__build_id_equal(dso, build_id))\r\ngoto out_elf_end;\r\n}\r\nss->symtab = elf_section_by_name(elf, &ehdr, &ss->symshdr, ".symtab",\r\nNULL);\r\nif (ss->symshdr.sh_type != SHT_SYMTAB)\r\nss->symtab = NULL;\r\nss->dynsym_idx = 0;\r\nss->dynsym = elf_section_by_name(elf, &ehdr, &ss->dynshdr, ".dynsym",\r\n&ss->dynsym_idx);\r\nif (ss->dynshdr.sh_type != SHT_DYNSYM)\r\nss->dynsym = NULL;\r\nss->opdidx = 0;\r\nss->opdsec = elf_section_by_name(elf, &ehdr, &ss->opdshdr, ".opd",\r\n&ss->opdidx);\r\nif (ss->opdshdr.sh_type != SHT_PROGBITS)\r\nss->opdsec = NULL;\r\nif (dso->kernel == DSO_TYPE_USER) {\r\nGElf_Shdr shdr;\r\nss->adjust_symbols = (ehdr.e_type == ET_EXEC ||\r\nelf_section_by_name(elf, &ehdr, &shdr,\r\n".gnu.prelink_undo",\r\nNULL) != NULL);\r\n} else {\r\nss->adjust_symbols = 0;\r\n}\r\nss->name = strdup(name);\r\nif (!ss->name)\r\ngoto out_elf_end;\r\nss->elf = elf;\r\nss->fd = fd;\r\nss->ehdr = ehdr;\r\nss->type = type;\r\nreturn 0;\r\nout_elf_end:\r\nelf_end(elf);\r\nout_close:\r\nclose(fd);\r\nreturn err;\r\n}\r\nint dso__load_sym(struct dso *dso, struct map *map,\r\nstruct symsrc *syms_ss, struct symsrc *runtime_ss,\r\nsymbol_filter_t filter, int kmodule)\r\n{\r\nstruct kmap *kmap = dso->kernel ? map__kmap(map) : NULL;\r\nstruct map *curr_map = map;\r\nstruct dso *curr_dso = dso;\r\nElf_Data *symstrs, *secstrs;\r\nuint32_t nr_syms;\r\nint err = -1;\r\nuint32_t idx;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nElf_Data *syms, *opddata = NULL;\r\nGElf_Sym sym;\r\nElf_Scn *sec, *sec_strndx;\r\nElf *elf;\r\nint nr = 0;\r\ndso->symtab_type = syms_ss->type;\r\nif (!syms_ss->symtab) {\r\nsyms_ss->symtab = syms_ss->dynsym;\r\nsyms_ss->symshdr = syms_ss->dynshdr;\r\n}\r\nelf = syms_ss->elf;\r\nehdr = syms_ss->ehdr;\r\nsec = syms_ss->symtab;\r\nshdr = syms_ss->symshdr;\r\nif (runtime_ss->opdsec)\r\nopddata = elf_rawdata(runtime_ss->opdsec, NULL);\r\nsyms = elf_getdata(sec, NULL);\r\nif (syms == NULL)\r\ngoto out_elf_end;\r\nsec = elf_getscn(elf, shdr.sh_link);\r\nif (sec == NULL)\r\ngoto out_elf_end;\r\nsymstrs = elf_getdata(sec, NULL);\r\nif (symstrs == NULL)\r\ngoto out_elf_end;\r\nsec_strndx = elf_getscn(elf, ehdr.e_shstrndx);\r\nif (sec_strndx == NULL)\r\ngoto out_elf_end;\r\nsecstrs = elf_getdata(sec_strndx, NULL);\r\nif (secstrs == NULL)\r\ngoto out_elf_end;\r\nnr_syms = shdr.sh_size / shdr.sh_entsize;\r\nmemset(&sym, 0, sizeof(sym));\r\ndso->adjust_symbols = runtime_ss->adjust_symbols;\r\nelf_symtab__for_each_symbol(syms, nr_syms, idx, sym) {\r\nstruct symbol *f;\r\nconst char *elf_name = elf_sym__name(&sym, symstrs);\r\nchar *demangled = NULL;\r\nint is_label = elf_sym__is_label(&sym);\r\nconst char *section_name;\r\nbool used_opd = false;\r\nif (kmap && kmap->ref_reloc_sym && kmap->ref_reloc_sym->name &&\r\nstrcmp(elf_name, kmap->ref_reloc_sym->name) == 0)\r\nkmap->ref_reloc_sym->unrelocated_addr = sym.st_value;\r\nif (!is_label && !elf_sym__is_a(&sym, map->type))\r\ncontinue;\r\nif (ehdr.e_machine == EM_ARM) {\r\nif (!strcmp(elf_name, "$a") ||\r\n!strcmp(elf_name, "$d") ||\r\n!strcmp(elf_name, "$t"))\r\ncontinue;\r\n}\r\nif (runtime_ss->opdsec && sym.st_shndx == runtime_ss->opdidx) {\r\nu32 offset = sym.st_value - syms_ss->opdshdr.sh_addr;\r\nu64 *opd = opddata->d_buf + offset;\r\nsym.st_value = DSO__SWAP(dso, u64, *opd);\r\nsym.st_shndx = elf_addr_to_index(runtime_ss->elf,\r\nsym.st_value);\r\nused_opd = true;\r\n}\r\nsec = elf_getscn(runtime_ss->elf, sym.st_shndx);\r\nif (!sec)\r\ngoto out_elf_end;\r\ngelf_getshdr(sec, &shdr);\r\nif (is_label && !elf_sec__is_a(&shdr, secstrs, map->type))\r\ncontinue;\r\nsection_name = elf_sec__name(&shdr, secstrs);\r\nif ((ehdr.e_machine == EM_ARM) &&\r\n(map->type == MAP__FUNCTION) &&\r\n(sym.st_value & 1))\r\n--sym.st_value;\r\nif (dso->kernel != DSO_TYPE_USER || kmodule) {\r\nchar dso_name[PATH_MAX];\r\nif (strcmp(section_name,\r\n(curr_dso->short_name +\r\ndso->short_name_len)) == 0)\r\ngoto new_symbol;\r\nif (strcmp(section_name, ".text") == 0) {\r\ncurr_map = map;\r\ncurr_dso = dso;\r\ngoto new_symbol;\r\n}\r\nsnprintf(dso_name, sizeof(dso_name),\r\n"%s%s", dso->short_name, section_name);\r\ncurr_map = map_groups__find_by_name(kmap->kmaps, map->type, dso_name);\r\nif (curr_map == NULL) {\r\nu64 start = sym.st_value;\r\nif (kmodule)\r\nstart += map->start + shdr.sh_offset;\r\ncurr_dso = dso__new(dso_name);\r\nif (curr_dso == NULL)\r\ngoto out_elf_end;\r\ncurr_dso->kernel = dso->kernel;\r\ncurr_dso->long_name = dso->long_name;\r\ncurr_dso->long_name_len = dso->long_name_len;\r\ncurr_map = map__new2(start, curr_dso,\r\nmap->type);\r\nif (curr_map == NULL) {\r\ndso__delete(curr_dso);\r\ngoto out_elf_end;\r\n}\r\ncurr_map->map_ip = identity__map_ip;\r\ncurr_map->unmap_ip = identity__map_ip;\r\ncurr_dso->symtab_type = dso->symtab_type;\r\nmap_groups__insert(kmap->kmaps, curr_map);\r\ndsos__add(&dso->node, curr_dso);\r\ndso__set_loaded(curr_dso, map->type);\r\n} else\r\ncurr_dso = curr_map->dso;\r\ngoto new_symbol;\r\n}\r\nif ((used_opd && runtime_ss->adjust_symbols)\r\n|| (!used_opd && syms_ss->adjust_symbols)) {\r\npr_debug4("%s: adjusting symbol: st_value: %#" PRIx64 " "\r\n"sh_addr: %#" PRIx64 " sh_offset: %#" PRIx64 "\n", __func__,\r\n(u64)sym.st_value, (u64)shdr.sh_addr,\r\n(u64)shdr.sh_offset);\r\nsym.st_value -= shdr.sh_addr - shdr.sh_offset;\r\n}\r\ndemangled = bfd_demangle(NULL, elf_name, DMGL_PARAMS | DMGL_ANSI);\r\nif (demangled != NULL)\r\nelf_name = demangled;\r\nnew_symbol:\r\nf = symbol__new(sym.st_value, sym.st_size,\r\nGELF_ST_BIND(sym.st_info), elf_name);\r\nfree(demangled);\r\nif (!f)\r\ngoto out_elf_end;\r\nif (filter && filter(curr_map, f))\r\nsymbol__delete(f);\r\nelse {\r\nsymbols__insert(&curr_dso->symbols[curr_map->type], f);\r\nnr++;\r\n}\r\n}\r\nif (nr > 0) {\r\nsymbols__fixup_duplicate(&dso->symbols[map->type]);\r\nsymbols__fixup_end(&dso->symbols[map->type]);\r\nif (kmap) {\r\n__map_groups__fixup_end(kmap->kmaps, map->type);\r\n}\r\n}\r\nerr = nr;\r\nout_elf_end:\r\nreturn err;\r\n}\r\nvoid symbol__elf_init(void)\r\n{\r\nelf_version(EV_CURRENT);\r\n}
