static int pacpi_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pata_acpi *acpi = ap->private_data;\r\nif (ata_ap_acpi_handle(ap) == NULL || ata_acpi_gtm(ap, &acpi->gtm) < 0)\r\nreturn -ENODEV;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic int pacpi_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pata_acpi *acpi = ap->private_data;\r\nif ((acpi->mask[0] | acpi->mask[1]) & (0xF8 << ATA_SHIFT_UDMA))\r\nreturn ATA_CBL_PATA80;\r\nelse\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic unsigned long pacpi_discover_modes(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pata_acpi *acpi = ap->private_data;\r\nstruct ata_acpi_gtm probe;\r\nunsigned int xfer_mask;\r\nprobe = acpi->gtm;\r\nata_acpi_gtm(ap, &probe);\r\nxfer_mask = ata_acpi_gtm_xfermask(adev, &probe);\r\nif (xfer_mask & (0xF8 << ATA_SHIFT_UDMA))\r\nap->cbl = ATA_CBL_PATA80;\r\nreturn xfer_mask;\r\n}\r\nstatic unsigned long pacpi_mode_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nstruct pata_acpi *acpi = adev->link->ap->private_data;\r\nreturn mask & acpi->mask[adev->devno];\r\n}\r\nstatic void pacpi_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nint unit = adev->devno;\r\nstruct pata_acpi *acpi = ap->private_data;\r\nconst struct ata_timing *t;\r\nif (!(acpi->gtm.flags & 0x10))\r\nunit = 0;\r\nt = ata_timing_find_mode(adev->pio_mode);\r\nacpi->gtm.drive[unit].pio = t->cycle;\r\nata_acpi_stm(ap, &acpi->gtm);\r\nata_acpi_gtm(ap, &acpi->gtm);\r\n}\r\nstatic void pacpi_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nint unit = adev->devno;\r\nstruct pata_acpi *acpi = ap->private_data;\r\nconst struct ata_timing *t;\r\nif (!(acpi->gtm.flags & 0x10))\r\nunit = 0;\r\nt = ata_timing_find_mode(adev->dma_mode);\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nacpi->gtm.drive[unit].dma = t->udma;\r\nacpi->gtm.flags |= (1 << (2 * unit));\r\n} else {\r\nacpi->gtm.drive[unit].dma = t->cycle;\r\nacpi->gtm.flags &= ~(1 << (2 * unit));\r\n}\r\nata_acpi_stm(ap, &acpi->gtm);\r\nata_acpi_gtm(ap, &acpi->gtm);\r\n}\r\nstatic unsigned int pacpi_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct pata_acpi *acpi = ap->private_data;\r\nif (acpi->gtm.flags & 0x10)\r\nreturn ata_bmdma_qc_issue(qc);\r\nif (adev != acpi->last) {\r\npacpi_set_piomode(ap, adev);\r\nif (ata_dma_enabled(adev))\r\npacpi_set_dmamode(ap, adev);\r\nacpi->last = adev;\r\n}\r\nreturn ata_bmdma_qc_issue(qc);\r\n}\r\nstatic int pacpi_port_start(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct pata_acpi *acpi;\r\nif (ata_ap_acpi_handle(ap) == NULL)\r\nreturn -ENODEV;\r\nacpi = ap->private_data = devm_kzalloc(&pdev->dev, sizeof(struct pata_acpi), GFP_KERNEL);\r\nif (ap->private_data == NULL)\r\nreturn -ENOMEM;\r\nacpi->mask[0] = pacpi_discover_modes(ap, &ap->link.device[0]);\r\nacpi->mask[1] = pacpi_discover_modes(ap, &ap->link.device[1]);\r\nreturn ata_bmdma_port_start(ap);\r\n}\r\nstatic int pacpi_init_one (struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &pacpi_ops,\r\n};\r\nconst struct ata_port_info *ppi[] = { &info, NULL };\r\nif (pdev->vendor == PCI_VENDOR_ID_ATI) {\r\nint rc = pcim_enable_device(pdev);\r\nif (rc < 0)\r\nreturn rc;\r\npcim_pin_device(pdev);\r\n}\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &pacpi_sht, NULL, 0);\r\n}
