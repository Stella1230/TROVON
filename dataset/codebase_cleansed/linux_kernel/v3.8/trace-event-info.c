static void *malloc_or_die(unsigned int size)\r\n{\r\nvoid *data;\r\ndata = malloc(size);\r\nif (!data)\r\ndie("malloc");\r\nreturn data;\r\n}\r\nstatic const char *find_debugfs(void)\r\n{\r\nconst char *path = debugfs_mount(NULL);\r\nif (!path)\r\ndie("Your kernel not support debugfs filesystem");\r\nreturn path;\r\n}\r\nstatic const char *find_tracing_dir(void)\r\n{\r\nstatic char *tracing;\r\nstatic int tracing_found;\r\nconst char *debugfs;\r\nif (tracing_found)\r\nreturn tracing;\r\ndebugfs = find_debugfs();\r\ntracing = malloc_or_die(strlen(debugfs) + 9);\r\nsprintf(tracing, "%s/tracing", debugfs);\r\ntracing_found = 1;\r\nreturn tracing;\r\n}\r\nstatic char *get_tracing_file(const char *name)\r\n{\r\nconst char *tracing;\r\nchar *file;\r\ntracing = find_tracing_dir();\r\nif (!tracing)\r\nreturn NULL;\r\nfile = malloc_or_die(strlen(tracing) + strlen(name) + 2);\r\nsprintf(file, "%s/%s", tracing, name);\r\nreturn file;\r\n}\r\nstatic void put_tracing_file(char *file)\r\n{\r\nfree(file);\r\n}\r\nstatic ssize_t write_or_die(const void *buf, size_t len)\r\n{\r\nint ret;\r\nif (calc_data_size) {\r\ncalc_data_size += len;\r\nreturn len;\r\n}\r\nret = write(output_fd, buf, len);\r\nif (ret < 0)\r\ndie("writing to '%s'", output_file);\r\nreturn ret;\r\n}\r\nint bigendian(void)\r\n{\r\nunsigned char str[] = { 0x1, 0x2, 0x3, 0x4, 0x0, 0x0, 0x0, 0x0};\r\nunsigned int *ptr;\r\nptr = (unsigned int *)(void *)str;\r\nreturn *ptr == 0x01020304;\r\n}\r\nstatic void record_file(const char *file, size_t hdr_sz)\r\n{\r\nunsigned long long size = 0;\r\nchar buf[BUFSIZ], *sizep;\r\noff_t hdr_pos = lseek(output_fd, 0, SEEK_CUR);\r\nint r, fd;\r\nfd = open(file, O_RDONLY);\r\nif (fd < 0)\r\ndie("Can't read '%s'", file);\r\nif (hdr_sz)\r\nwrite_or_die(&size, hdr_sz);\r\ndo {\r\nr = read(fd, buf, BUFSIZ);\r\nif (r > 0) {\r\nsize += r;\r\nwrite_or_die(buf, r);\r\n}\r\n} while (r > 0);\r\nclose(fd);\r\nsizep = (char*)&size;\r\nif (bigendian())\r\nsizep += sizeof(u64) - hdr_sz;\r\nif (hdr_sz && pwrite(output_fd, sizep, hdr_sz, hdr_pos) < 0)\r\ndie("writing to %s", output_file);\r\n}\r\nstatic void read_header_files(void)\r\n{\r\nchar *path;\r\nstruct stat st;\r\npath = get_tracing_file("events/header_page");\r\nif (stat(path, &st) < 0)\r\ndie("can't read '%s'", path);\r\nwrite_or_die("header_page", 12);\r\nrecord_file(path, 8);\r\nput_tracing_file(path);\r\npath = get_tracing_file("events/header_event");\r\nif (stat(path, &st) < 0)\r\ndie("can't read '%s'", path);\r\nwrite_or_die("header_event", 13);\r\nrecord_file(path, 8);\r\nput_tracing_file(path);\r\n}\r\nstatic bool name_in_tp_list(char *sys, struct tracepoint_path *tps)\r\n{\r\nwhile (tps) {\r\nif (!strcmp(sys, tps->name))\r\nreturn true;\r\ntps = tps->next;\r\n}\r\nreturn false;\r\n}\r\nstatic void copy_event_system(const char *sys, struct tracepoint_path *tps)\r\n{\r\nstruct dirent *dent;\r\nstruct stat st;\r\nchar *format;\r\nDIR *dir;\r\nint count = 0;\r\nint ret;\r\ndir = opendir(sys);\r\nif (!dir)\r\ndie("can't read directory '%s'", sys);\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\n!name_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\nformat = malloc_or_die(strlen(sys) + strlen(dent->d_name) + 10);\r\nsprintf(format, "%s/%s/format", sys, dent->d_name);\r\nret = stat(format, &st);\r\nfree(format);\r\nif (ret < 0)\r\ncontinue;\r\ncount++;\r\n}\r\nwrite_or_die(&count, 4);\r\nrewinddir(dir);\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\n!name_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\nformat = malloc_or_die(strlen(sys) + strlen(dent->d_name) + 10);\r\nsprintf(format, "%s/%s/format", sys, dent->d_name);\r\nret = stat(format, &st);\r\nif (ret >= 0)\r\nrecord_file(format, 8);\r\nfree(format);\r\n}\r\nclosedir(dir);\r\n}\r\nstatic void read_ftrace_files(struct tracepoint_path *tps)\r\n{\r\nchar *path;\r\npath = get_tracing_file("events/ftrace");\r\ncopy_event_system(path, tps);\r\nput_tracing_file(path);\r\n}\r\nstatic bool system_in_tp_list(char *sys, struct tracepoint_path *tps)\r\n{\r\nwhile (tps) {\r\nif (!strcmp(sys, tps->system))\r\nreturn true;\r\ntps = tps->next;\r\n}\r\nreturn false;\r\n}\r\nstatic void read_event_files(struct tracepoint_path *tps)\r\n{\r\nstruct dirent *dent;\r\nstruct stat st;\r\nchar *path;\r\nchar *sys;\r\nDIR *dir;\r\nint count = 0;\r\nint ret;\r\npath = get_tracing_file("events");\r\ndir = opendir(path);\r\nif (!dir)\r\ndie("can't read directory '%s'", path);\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\nstrcmp(dent->d_name, "ftrace") == 0 ||\r\n!system_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\ncount++;\r\n}\r\nwrite_or_die(&count, 4);\r\nrewinddir(dir);\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\nstrcmp(dent->d_name, "ftrace") == 0 ||\r\n!system_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\nsys = malloc_or_die(strlen(path) + strlen(dent->d_name) + 2);\r\nsprintf(sys, "%s/%s", path, dent->d_name);\r\nret = stat(sys, &st);\r\nif (ret >= 0) {\r\nwrite_or_die(dent->d_name, strlen(dent->d_name) + 1);\r\ncopy_event_system(sys, tps);\r\n}\r\nfree(sys);\r\n}\r\nclosedir(dir);\r\nput_tracing_file(path);\r\n}\r\nstatic void read_proc_kallsyms(void)\r\n{\r\nunsigned int size;\r\nconst char *path = "/proc/kallsyms";\r\nstruct stat st;\r\nint ret;\r\nret = stat(path, &st);\r\nif (ret < 0) {\r\nsize = 0;\r\nwrite_or_die(&size, 4);\r\nreturn;\r\n}\r\nrecord_file(path, 4);\r\n}\r\nstatic void read_ftrace_printk(void)\r\n{\r\nunsigned int size;\r\nchar *path;\r\nstruct stat st;\r\nint ret;\r\npath = get_tracing_file("printk_formats");\r\nret = stat(path, &st);\r\nif (ret < 0) {\r\nsize = 0;\r\nwrite_or_die(&size, 4);\r\ngoto out;\r\n}\r\nrecord_file(path, 4);\r\nout:\r\nput_tracing_file(path);\r\n}\r\nstatic struct tracepoint_path *\r\nget_tracepoints_path(struct list_head *pattrs)\r\n{\r\nstruct tracepoint_path path, *ppath = &path;\r\nstruct perf_evsel *pos;\r\nint nr_tracepoints = 0;\r\nlist_for_each_entry(pos, pattrs, node) {\r\nif (pos->attr.type != PERF_TYPE_TRACEPOINT)\r\ncontinue;\r\n++nr_tracepoints;\r\nppath->next = tracepoint_id_to_path(pos->attr.config);\r\nif (!ppath->next)\r\ndie("%s\n", "No memory to alloc tracepoints list");\r\nppath = ppath->next;\r\n}\r\nreturn nr_tracepoints > 0 ? path.next : NULL;\r\n}\r\nstatic void\r\nput_tracepoints_path(struct tracepoint_path *tps)\r\n{\r\nwhile (tps) {\r\nstruct tracepoint_path *t = tps;\r\ntps = tps->next;\r\nfree(t->name);\r\nfree(t->system);\r\nfree(t);\r\n}\r\n}\r\nbool have_tracepoints(struct list_head *pattrs)\r\n{\r\nstruct perf_evsel *pos;\r\nlist_for_each_entry(pos, pattrs, node)\r\nif (pos->attr.type == PERF_TYPE_TRACEPOINT)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void tracing_data_header(void)\r\n{\r\nchar buf[20];\r\nbuf[0] = 23;\r\nbuf[1] = 8;\r\nbuf[2] = 68;\r\nmemcpy(buf + 3, "tracing", 7);\r\nwrite_or_die(buf, 10);\r\nwrite_or_die(VERSION, strlen(VERSION) + 1);\r\nif (bigendian())\r\nbuf[0] = 1;\r\nelse\r\nbuf[0] = 0;\r\nread_trace_init(buf[0], buf[0]);\r\nwrite_or_die(buf, 1);\r\nbuf[0] = sizeof(long);\r\nwrite_or_die(buf, 1);\r\npage_size = sysconf(_SC_PAGESIZE);\r\nwrite_or_die(&page_size, 4);\r\n}\r\nstruct tracing_data *tracing_data_get(struct list_head *pattrs,\r\nint fd, bool temp)\r\n{\r\nstruct tracepoint_path *tps;\r\nstruct tracing_data *tdata;\r\noutput_fd = fd;\r\ntps = get_tracepoints_path(pattrs);\r\nif (!tps)\r\nreturn NULL;\r\ntdata = malloc_or_die(sizeof(*tdata));\r\ntdata->temp = temp;\r\ntdata->size = 0;\r\nif (temp) {\r\nint temp_fd;\r\nsnprintf(tdata->temp_file, sizeof(tdata->temp_file),\r\n"/tmp/perf-XXXXXX");\r\nif (!mkstemp(tdata->temp_file))\r\ndie("Can't make temp file");\r\ntemp_fd = open(tdata->temp_file, O_RDWR);\r\nif (temp_fd < 0)\r\ndie("Can't read '%s'", tdata->temp_file);\r\noutput_fd = temp_fd;\r\n}\r\ntracing_data_header();\r\nread_header_files();\r\nread_ftrace_files(tps);\r\nread_event_files(tps);\r\nread_proc_kallsyms();\r\nread_ftrace_printk();\r\nif (temp) {\r\ntdata->size = lseek(output_fd, 0, SEEK_CUR);\r\nclose(output_fd);\r\noutput_fd = fd;\r\n}\r\nput_tracepoints_path(tps);\r\nreturn tdata;\r\n}\r\nvoid tracing_data_put(struct tracing_data *tdata)\r\n{\r\nif (tdata->temp) {\r\nrecord_file(tdata->temp_file, 0);\r\nunlink(tdata->temp_file);\r\n}\r\nfree(tdata);\r\n}\r\nint read_tracing_data(int fd, struct list_head *pattrs)\r\n{\r\nstruct tracing_data *tdata;\r\ntdata = tracing_data_get(pattrs, fd, false);\r\nif (!tdata)\r\nreturn -ENOMEM;\r\ntracing_data_put(tdata);\r\nreturn 0;\r\n}
