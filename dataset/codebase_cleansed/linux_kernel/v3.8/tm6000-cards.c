void tm6000_flash_led(struct tm6000_core *dev, u8 state)\r\n{\r\nif (!dev->gpio.power_led)\r\nreturn;\r\nif (state) {\r\nswitch (dev->model) {\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_TWINHAN_TU501:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.power_led, 0x00);\r\nbreak;\r\ncase TM6010_BOARD_BEHOLD_WANDER:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER:\r\ncase TM6010_BOARD_BEHOLD_WANDER_LITE:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER_LITE:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.power_led, 0x01);\r\nbreak;\r\n}\r\n}\r\nelse {\r\nswitch (dev->model) {\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_TWINHAN_TU501:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.power_led, 0x01);\r\nbreak;\r\ncase TM6010_BOARD_BEHOLD_WANDER:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER:\r\ncase TM6010_BOARD_BEHOLD_WANDER_LITE:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER_LITE:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.power_led, 0x00);\r\nbreak;\r\n}\r\n}\r\n}\r\nint tm6000_xc5000_callback(void *ptr, int component, int command, int arg)\r\n{\r\nint rc = 0;\r\nstruct tm6000_core *dev = ptr;\r\nif (dev->tuner_type != TUNER_XC5000)\r\nreturn 0;\r\nswitch (command) {\r\ncase XC5000_TUNER_RESET:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x00);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint tm6000_tuner_callback(void *ptr, int component, int command, int arg)\r\n{\r\nint rc = 0;\r\nstruct tm6000_core *dev = ptr;\r\nif (dev->tuner_type != TUNER_XC2028)\r\nreturn 0;\r\nswitch (command) {\r\ncase XC2028_RESET_CLK:\r\ntm6000_ir_wait(dev, 0);\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT,\r\n0x02, arg);\r\nmsleep(10);\r\nrc = tm6000_i2c_reset(dev, 10);\r\nbreak;\r\ncase XC2028_TUNER_RESET:\r\nswitch (arg) {\r\ncase 0:\r\nswitch (dev->model) {\r\ncase TM5600_BOARD_10MOONS_UT821:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\n0x300, 0x01);\r\nmsleep(10);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x00);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\n0x300, 0x00);\r\nmsleep(10);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\n0x300, 0x01);\r\nbreak;\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_TWINHAN_TU501:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\nmsleep(60);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x00);\r\nmsleep(75);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\nmsleep(60);\r\nbreak;\r\ndefault:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x00);\r\nmsleep(130);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\nmsleep(130);\r\nbreak;\r\n}\r\ntm6000_ir_wait(dev, 1);\r\nbreak;\r\ncase 1:\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT,\r\n0x02, 0x01);\r\nmsleep(10);\r\nbreak;\r\ncase 2:\r\nrc = tm6000_i2c_reset(dev, 100);\r\nbreak;\r\n}\r\nbreak;\r\ncase XC2028_I2C_FLUSH:\r\ntm6000_set_reg(dev, REQ_50_SET_START, 0, 0);\r\ntm6000_set_reg(dev, REQ_51_SET_STOP, 0, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint tm6000_cards_setup(struct tm6000_core *dev)\r\n{\r\nswitch (dev->model) {\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_TWINHAN_TU501:\r\ncase TM6010_BOARD_GENERIC:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.tuner_on, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_on, 0x00);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_reset, 0x00);\r\nmsleep(50);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_reset, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_on, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.ir, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.power_led, 0x00);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.dvb_led, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_on, 0x00);\r\nmsleep(15);\r\nbreak;\r\ncase TM6010_BOARD_BEHOLD_WANDER:\r\ncase TM6010_BOARD_BEHOLD_WANDER_LITE:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.power_led, 0x01);\r\nmsleep(15);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_reset, 0x00);\r\nmsleep(50);\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.demod_reset, 0x01);\r\nmsleep(15);\r\nbreak;\r\ncase TM6010_BOARD_BEHOLD_VOYAGER:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER_LITE:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, dev->gpio.power_led, 0x01);\r\nmsleep(15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (dev->gpio.tuner_reset) {\r\nint rc;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nrc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x00);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "Error %i doing tuner reset\n", rc);\r\nreturn rc;\r\n}\r\nmsleep(10);\r\nrc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.tuner_reset, 0x01);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "Error %i doing tuner reset\n", rc);\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nprintk(KERN_ERR "Tuner reset is not configured\n");\r\nreturn -1;\r\n}\r\nmsleep(50);\r\nreturn 0;\r\n}\r\nstatic void tm6000_config_tuner(struct tm6000_core *dev)\r\n{\r\nstruct tuner_setup tun_setup;\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev, &dev->i2c_adap,\r\n"tuner", dev->tuner_addr, NULL);\r\nmemset(&tun_setup, 0, sizeof(tun_setup));\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = dev->tuner_addr;\r\ntun_setup.mode_mask = 0;\r\nif (dev->caps.has_tuner)\r\ntun_setup.mode_mask |= (T_ANALOG_TV | T_RADIO);\r\nswitch (dev->tuner_type) {\r\ncase TUNER_XC2028:\r\ntun_setup.tuner_callback = tm6000_tuner_callback;\r\nbreak;\r\ncase TUNER_XC5000:\r\ntun_setup.tuner_callback = tm6000_xc5000_callback;\r\nbreak;\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_type_addr, &tun_setup);\r\nswitch (dev->tuner_type) {\r\ncase TUNER_XC2028: {\r\nstruct v4l2_priv_tun_config xc2028_cfg;\r\nstruct xc2028_ctrl ctl;\r\nmemset(&xc2028_cfg, 0, sizeof(xc2028_cfg));\r\nmemset(&ctl, 0, sizeof(ctl));\r\nctl.demod = XC3028_FE_ZARLINK456;\r\nxc2028_cfg.tuner = TUNER_XC2028;\r\nxc2028_cfg.priv = &ctl;\r\nswitch (dev->model) {\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_TWINHAN_TU501:\r\nctl.max_len = 80;\r\nctl.fname = "xc3028L-v36.fw";\r\nbreak;\r\ndefault:\r\nif (dev->dev_type == TM6010)\r\nctl.fname = "xc3028-v27.fw";\r\nelse\r\nctl.fname = "xc3028-v24.fw";\r\n}\r\nprintk(KERN_INFO "Setting firmware parameters for xc2028\n");\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_config,\r\n&xc2028_cfg);\r\n}\r\nbreak;\r\ncase TUNER_XC5000:\r\n{\r\nstruct v4l2_priv_tun_config xc5000_cfg;\r\nstruct xc5000_config ctl = {\r\n.i2c_address = dev->tuner_addr,\r\n.if_khz = 4570,\r\n.radio_input = XC5000_RADIO_FM1_MONO,\r\n};\r\nxc5000_cfg.tuner = TUNER_XC5000;\r\nxc5000_cfg.priv = &ctl;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_config,\r\n&xc5000_cfg);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unknown tuner type. Tuner is not configured.\n");\r\nbreak;\r\n}\r\n}\r\nstatic int fill_board_specific_data(struct tm6000_core *dev)\r\n{\r\nint rc;\r\ndev->dev_type = tm6000_boards[dev->model].type;\r\ndev->tuner_type = tm6000_boards[dev->model].tuner_type;\r\ndev->tuner_addr = tm6000_boards[dev->model].tuner_addr;\r\ndev->gpio = tm6000_boards[dev->model].gpio;\r\ndev->ir_codes = tm6000_boards[dev->model].ir_codes;\r\ndev->demod_addr = tm6000_boards[dev->model].demod_addr;\r\ndev->caps = tm6000_boards[dev->model].caps;\r\ndev->vinput[0] = tm6000_boards[dev->model].vinput[0];\r\ndev->vinput[1] = tm6000_boards[dev->model].vinput[1];\r\ndev->vinput[2] = tm6000_boards[dev->model].vinput[2];\r\ndev->rinput = tm6000_boards[dev->model].rinput;\r\nswitch (dev->model) {\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ndev->quirks |= TM6000_QUIRK_NO_USB_DELAY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrc = tm6000_init(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn v4l2_device_register(&dev->udev->dev, &dev->v4l2_dev);\r\n}\r\nstatic void use_alternative_detection_method(struct tm6000_core *dev)\r\n{\r\nint i, model = -1;\r\nif (!dev->eedata_size)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(tm6000_boards); i++) {\r\nif (!tm6000_boards[i].eename_size)\r\ncontinue;\r\nif (dev->eedata_size < tm6000_boards[i].eename_pos +\r\ntm6000_boards[i].eename_size)\r\ncontinue;\r\nif (!memcmp(&dev->eedata[tm6000_boards[i].eename_pos],\r\ntm6000_boards[i].eename,\r\ntm6000_boards[i].eename_size)) {\r\nmodel = i;\r\nbreak;\r\n}\r\n}\r\nif (model < 0) {\r\nprintk(KERN_INFO "Device has eeprom but is currently unknown\n");\r\nreturn;\r\n}\r\ndev->model = model;\r\nprintk(KERN_INFO "Device identified via eeprom as %s (type = %d)\n",\r\ntm6000_boards[model].name, model);\r\n}\r\nstatic void request_module_async(struct work_struct *work)\r\n{\r\nstruct tm6000_core *dev = container_of(work, struct tm6000_core,\r\nrequest_module_wk);\r\nrequest_module("tm6000-alsa");\r\nif (dev->caps.has_dvb)\r\nrequest_module("tm6000-dvb");\r\n}\r\nstatic void request_modules(struct tm6000_core *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct tm6000_core *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nstatic int tm6000_init_dev(struct tm6000_core *dev)\r\n{\r\nstruct v4l2_frequency f;\r\nint rc = 0;\r\nmutex_init(&dev->lock);\r\nmutex_lock(&dev->lock);\r\nif (!is_generic(dev->model)) {\r\nrc = fill_board_specific_data(dev);\r\nif (rc < 0)\r\ngoto err;\r\nrc = tm6000_i2c_register(dev);\r\nif (rc < 0)\r\ngoto err;\r\n} else {\r\nrc = tm6000_i2c_register(dev);\r\nif (rc < 0)\r\ngoto err;\r\nuse_alternative_detection_method(dev);\r\nrc = fill_board_specific_data(dev);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\ndev->width = 720;\r\ndev->height = 480;\r\ndev->norm = V4L2_STD_PAL_M;\r\ntm6000_config_tuner(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std, dev->norm);\r\nf.tuner = 0;\r\nf.type = V4L2_TUNER_ANALOG_TV;\r\nf.frequency = 3092;\r\ndev->freq = f.frequency;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, &f);\r\nif (dev->caps.has_tda9874)\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev, &dev->i2c_adap,\r\n"tvaudio", I2C_ADDR_TDA9874, NULL);\r\nrc = tm6000_v4l2_register(dev);\r\nif (rc < 0)\r\ngoto err;\r\ntm6000_add_into_devlist(dev);\r\ntm6000_init_extension(dev);\r\ntm6000_ir_init(dev);\r\nrequest_modules(dev);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nstatic void get_max_endpoint(struct usb_device *udev,\r\nstruct usb_host_interface *alt,\r\nchar *msgtype,\r\nstruct usb_host_endpoint *curr_e,\r\nstruct tm6000_endpoint *tm_ep)\r\n{\r\nu16 tmp = le16_to_cpu(curr_e->desc.wMaxPacketSize);\r\nunsigned int size = tmp & 0x7ff;\r\nif (udev->speed == USB_SPEED_HIGH)\r\nsize = size * hb_mult(tmp);\r\nif (size > tm_ep->maxsize) {\r\ntm_ep->endp = curr_e;\r\ntm_ep->maxsize = size;\r\ntm_ep->bInterfaceNumber = alt->desc.bInterfaceNumber;\r\ntm_ep->bAlternateSetting = alt->desc.bAlternateSetting;\r\nprintk(KERN_INFO "tm6000: %s endpoint: 0x%02x (max size=%u bytes)\n",\r\nmsgtype, curr_e->desc.bEndpointAddress,\r\nsize);\r\n}\r\n}\r\nstatic int tm6000_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev;\r\nstruct tm6000_core *dev = NULL;\r\nint i, rc = 0;\r\nint nr = 0;\r\nchar *speed;\r\nusbdev = usb_get_dev(interface_to_usbdev(interface));\r\nrc = usb_set_interface(usbdev, 0, 1);\r\nif (rc < 0)\r\ngoto err;\r\nnr = find_first_zero_bit(&tm6000_devused, TM6000_MAXBOARDS);\r\nif (nr >= TM6000_MAXBOARDS) {\r\nprintk(KERN_ERR "tm6000: Supports only %i tm60xx boards.\n", TM6000_MAXBOARDS);\r\nusb_put_dev(usbdev);\r\nreturn -ENOMEM;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "tm6000" ": out of memory!\n");\r\nusb_put_dev(usbdev);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&dev->slock);\r\nmutex_init(&dev->usb_lock);\r\nset_bit(nr, &tm6000_devused);\r\nsnprintf(dev->name, 29, "tm6000 #%d", nr);\r\ndev->model = id->driver_info;\r\nif (card[nr] < ARRAY_SIZE(tm6000_boards))\r\ndev->model = card[nr];\r\ndev->udev = usbdev;\r\ndev->devno = nr;\r\nswitch (usbdev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "1.5";\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ncase USB_SPEED_FULL:\r\nspeed = "12";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "480";\r\nbreak;\r\ndefault:\r\nspeed = "unknown";\r\n}\r\nfor (i = 0; i < interface->num_altsetting; i++) {\r\nint ep;\r\nfor (ep = 0; ep < interface->altsetting[i].desc.bNumEndpoints; ep++) {\r\nstruct usb_host_endpoint *e;\r\nint dir_out;\r\ne = &interface->altsetting[i].endpoint[ep];\r\ndir_out = ((e->desc.bEndpointAddress &\r\nUSB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);\r\nprintk(KERN_INFO "tm6000: alt %d, interface %i, class %i\n",\r\ni,\r\ninterface->altsetting[i].desc.bInterfaceNumber,\r\ninterface->altsetting[i].desc.bInterfaceClass);\r\nswitch (e->desc.bmAttributes) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (!dir_out) {\r\nget_max_endpoint(usbdev,\r\n&interface->altsetting[i],\r\n"Bulk IN", e,\r\n&dev->bulk_in);\r\n} else {\r\nget_max_endpoint(usbdev,\r\n&interface->altsetting[i],\r\n"Bulk OUT", e,\r\n&dev->bulk_out);\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (!dir_out) {\r\nget_max_endpoint(usbdev,\r\n&interface->altsetting[i],\r\n"ISOC IN", e,\r\n&dev->isoc_in);\r\n} else {\r\nget_max_endpoint(usbdev,\r\n&interface->altsetting[i],\r\n"ISOC OUT", e,\r\n&dev->isoc_out);\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (!dir_out) {\r\nget_max_endpoint(usbdev,\r\n&interface->altsetting[i],\r\n"INT IN", e,\r\n&dev->int_in);\r\n} else {\r\nget_max_endpoint(usbdev,\r\n&interface->altsetting[i],\r\n"INT OUT", e,\r\n&dev->int_out);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO "tm6000: New video device @ %s Mbps (%04x:%04x, ifnum %d)\n",\r\nspeed,\r\nle16_to_cpu(dev->udev->descriptor.idVendor),\r\nle16_to_cpu(dev->udev->descriptor.idProduct),\r\ninterface->altsetting->desc.bInterfaceNumber);\r\nif (!dev->isoc_in.endp) {\r\nprintk(KERN_ERR "tm6000: probing error: no IN ISOC endpoint!\n");\r\nrc = -ENODEV;\r\ngoto err;\r\n}\r\nusb_set_intfdata(interface, dev);\r\nprintk(KERN_INFO "tm6000: Found %s\n", tm6000_boards[dev->model].name);\r\nrc = tm6000_init_dev(dev);\r\nif (rc < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nprintk(KERN_ERR "tm6000: Error %d while registering\n", rc);\r\nclear_bit(nr, &tm6000_devused);\r\nusb_put_dev(usbdev);\r\nkfree(dev);\r\nreturn rc;\r\n}\r\nstatic void tm6000_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct tm6000_core *dev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!dev)\r\nreturn;\r\nprintk(KERN_INFO "tm6000: disconnecting %s\n", dev->name);\r\nflush_request_modules(dev);\r\ntm6000_ir_fini(dev);\r\nif (dev->gpio.power_led) {\r\nswitch (dev->model) {\r\ncase TM6010_BOARD_HAUPPAUGE_900H:\r\ncase TM6010_BOARD_TERRATEC_CINERGY_HYBRID_XE:\r\ncase TM6010_BOARD_TWINHAN_TU501:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.power_led, 0x01);\r\nmsleep(15);\r\nbreak;\r\ncase TM6010_BOARD_BEHOLD_WANDER:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER:\r\ncase TM6010_BOARD_BEHOLD_WANDER_LITE:\r\ncase TM6010_BOARD_BEHOLD_VOYAGER_LITE:\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.power_led, 0x00);\r\nmsleep(15);\r\nbreak;\r\n}\r\n}\r\ntm6000_v4l2_unregister(dev);\r\ntm6000_i2c_unregister(dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\ndev->state |= DEV_DISCONNECTED;\r\nusb_put_dev(dev->udev);\r\ntm6000_close_extension(dev);\r\ntm6000_remove_from_devlist(dev);\r\nclear_bit(dev->devno, &tm6000_devused);\r\nkfree(dev);\r\n}
