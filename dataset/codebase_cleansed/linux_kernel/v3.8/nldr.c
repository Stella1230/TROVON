static inline bool is_equal_uuid(struct dsp_uuid *uuid1,\r\nstruct dsp_uuid *uuid2)\r\n{\r\nreturn !memcmp(uuid1, uuid2, sizeof(struct dsp_uuid));\r\n}\r\nint nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,\r\nconst struct dcd_nodeprops *node_props,\r\nstruct nldr_nodeobject **nldr_nodeobj,\r\nbool *pf_phase_split)\r\n{\r\nstruct nldr_nodeobject *nldr_node_obj = NULL;\r\nint status = 0;\r\n*nldr_nodeobj = NULL;\r\nnldr_node_obj = kzalloc(sizeof(struct nldr_nodeobject), GFP_KERNEL);\r\nif (nldr_node_obj == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nnldr_node_obj->phase_split = pf_phase_split;\r\nnldr_node_obj->pers_libs = 0;\r\nnldr_node_obj->nldr_obj = nldr_obj;\r\nnldr_node_obj->priv_ref = priv_ref;\r\nnldr_node_obj->uuid = node_props->ndb_props.ui_node_id;\r\nif (node_props->load_type == NLDR_DYNAMICLOAD) {\r\nnldr_node_obj->dynamic = true;\r\nnldr_node_obj->seg_id[CREATEDATAFLAGBIT] = (u16)\r\n(node_props->data_mem_seg_mask >> CREATEBIT) &\r\nSEGMASK;\r\nnldr_node_obj->code_data_flag_mask |=\r\n((node_props->data_mem_seg_mask >>\r\n(CREATEBIT + FLAGBIT)) & 1) << CREATEDATAFLAGBIT;\r\nnldr_node_obj->seg_id[CREATECODEFLAGBIT] = (u16)\r\n(node_props->code_mem_seg_mask >>\r\nCREATEBIT) & SEGMASK;\r\nnldr_node_obj->code_data_flag_mask |=\r\n((node_props->code_mem_seg_mask >>\r\n(CREATEBIT + FLAGBIT)) & 1) << CREATECODEFLAGBIT;\r\nnldr_node_obj->seg_id[EXECUTEDATAFLAGBIT] = (u16)\r\n(node_props->data_mem_seg_mask >>\r\nEXECUTEBIT) & SEGMASK;\r\nnldr_node_obj->code_data_flag_mask |=\r\n((node_props->data_mem_seg_mask >>\r\n(EXECUTEBIT + FLAGBIT)) & 1) <<\r\nEXECUTEDATAFLAGBIT;\r\nnldr_node_obj->seg_id[EXECUTECODEFLAGBIT] = (u16)\r\n(node_props->code_mem_seg_mask >>\r\nEXECUTEBIT) & SEGMASK;\r\nnldr_node_obj->code_data_flag_mask |=\r\n((node_props->code_mem_seg_mask >>\r\n(EXECUTEBIT + FLAGBIT)) & 1) <<\r\nEXECUTECODEFLAGBIT;\r\nnldr_node_obj->seg_id[DELETEDATAFLAGBIT] = (u16)\r\n(node_props->data_mem_seg_mask >> DELETEBIT) &\r\nSEGMASK;\r\nnldr_node_obj->code_data_flag_mask |=\r\n((node_props->data_mem_seg_mask >>\r\n(DELETEBIT + FLAGBIT)) & 1) << DELETEDATAFLAGBIT;\r\nnldr_node_obj->seg_id[DELETECODEFLAGBIT] = (u16)\r\n(node_props->code_mem_seg_mask >>\r\nDELETEBIT) & SEGMASK;\r\nnldr_node_obj->code_data_flag_mask |=\r\n((node_props->code_mem_seg_mask >>\r\n(DELETEBIT + FLAGBIT)) & 1) << DELETECODEFLAGBIT;\r\n} else {\r\nnldr_node_obj->root.lib = nldr_obj->base_lib;\r\nif (node_props->load_type == NLDR_OVLYLOAD)\r\nnldr_node_obj->overlay = true;\r\n}\r\n*nldr_nodeobj = (struct nldr_nodeobject *)nldr_node_obj;\r\n}\r\nif (status && nldr_node_obj)\r\nkfree(nldr_node_obj);\r\nreturn status;\r\n}\r\nint nldr_create(struct nldr_object **nldr,\r\nstruct dev_object *hdev_obj,\r\nconst struct nldr_attrs *pattrs)\r\n{\r\nstruct cod_manager *cod_mgr;\r\nchar *psz_coff_buf = NULL;\r\nchar sz_zl_file[COD_MAXPATHLENGTH];\r\nstruct nldr_object *nldr_obj = NULL;\r\nstruct dbll_attrs save_attrs;\r\nstruct dbll_attrs new_attrs;\r\ndbll_flags flags;\r\nu32 ul_entry;\r\nu16 dload_segs = 0;\r\nstruct mem_seg_info *mem_info_obj;\r\nu32 ul_len = 0;\r\nu32 ul_addr;\r\nstruct rmm_segment *rmm_segs = NULL;\r\nu16 i;\r\nint status = 0;\r\nnldr_obj = kzalloc(sizeof(struct nldr_object), GFP_KERNEL);\r\nif (nldr_obj) {\r\nnldr_obj->dev_obj = hdev_obj;\r\ndev_get_cod_mgr(hdev_obj, &cod_mgr);\r\nif (cod_mgr) {\r\nstatus = cod_get_loader(cod_mgr, &nldr_obj->dbll);\r\nstatus = cod_get_base_lib(cod_mgr, &nldr_obj->base_lib);\r\nstatus =\r\ncod_get_base_name(cod_mgr, sz_zl_file,\r\nCOD_MAXPATHLENGTH);\r\n}\r\nstatus = 0;\r\nnldr_obj->dsp_mau_size = pattrs->dsp_mau_size;\r\nnldr_obj->dsp_word_size = pattrs->dsp_word_size;\r\nnldr_obj->ldr_fxns = ldr_fxns;\r\nif (!(nldr_obj->ldr_fxns.init_fxn()))\r\nstatus = -ENOMEM;\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nif (!status)\r\nstatus = dcd_create_manager(NULL, &nldr_obj->dcd_mgr);\r\nif (!status) {\r\nstatus =\r\nnldr_obj->ldr_fxns.get_sect_fxn(nldr_obj->base_lib,\r\nDYNMEMSECT, &ul_addr,\r\n&ul_len);\r\nif (!status) {\r\npsz_coff_buf =\r\nkzalloc(ul_len * nldr_obj->dsp_mau_size,\r\nGFP_KERNEL);\r\nif (!psz_coff_buf)\r\nstatus = -ENOMEM;\r\n} else {\r\nstatus = 0;\r\nul_len = 0;\r\ndev_dbg(bridge, "%s: failed - no dynamic loading mem "\r\n"segments: 0x%x\n", __func__, status);\r\n}\r\n}\r\nif (!status && ul_len > 0) {\r\nstatus =\r\nnldr_obj->ldr_fxns.read_sect_fxn(nldr_obj->base_lib,\r\nDYNMEMSECT, psz_coff_buf,\r\nul_len);\r\n}\r\nif (!status && ul_len > 0) {\r\ndload_segs = (u16) (*((u32 *) psz_coff_buf));\r\nif (dload_segs > MAXMEMSEGS)\r\nstatus = -EBADF;\r\n}\r\nif (!status && dload_segs > 0) {\r\nrmm_segs = kzalloc(sizeof(struct rmm_segment) * dload_segs,\r\nGFP_KERNEL);\r\nnldr_obj->seg_table =\r\nkzalloc(sizeof(u32) * dload_segs, GFP_KERNEL);\r\nif (rmm_segs == NULL || nldr_obj->seg_table == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nnldr_obj->dload_segs = dload_segs;\r\nmem_info_obj = (struct mem_seg_info *)(psz_coff_buf +\r\nsizeof(u32));\r\nfor (i = 0; i < dload_segs; i++) {\r\nrmm_segs[i].base = (mem_info_obj + i)->base;\r\nrmm_segs[i].length = (mem_info_obj + i)->len;\r\nrmm_segs[i].space = 0;\r\nnldr_obj->seg_table[i] =\r\n(mem_info_obj + i)->type;\r\ndev_dbg(bridge,\r\n"(proc) DLL MEMSEGMENT: %d, "\r\n"Base: 0x%x, Length: 0x%x\n", i,\r\nrmm_segs[i].base, rmm_segs[i].length);\r\n}\r\n}\r\n}\r\nif (!status)\r\nstatus = rmm_create(&nldr_obj->rmm, rmm_segs, dload_segs);\r\nif (!status) {\r\nnldr_obj->ldr_fxns.get_attrs_fxn(nldr_obj->dbll, &save_attrs);\r\nnew_attrs = save_attrs;\r\nnew_attrs.alloc = (dbll_alloc_fxn) remote_alloc;\r\nnew_attrs.free = (dbll_free_fxn) remote_free;\r\nnew_attrs.sym_lookup = (dbll_sym_lookup) get_symbol_value;\r\nnew_attrs.sym_handle = nldr_obj;\r\nnew_attrs.write = (dbll_write_fxn) pattrs->write;\r\nnldr_obj->ovly_fxn = pattrs->ovly;\r\nnldr_obj->write_fxn = pattrs->write;\r\nnldr_obj->ldr_attrs = new_attrs;\r\n}\r\nkfree(rmm_segs);\r\nkfree(psz_coff_buf);\r\nif (!status) {\r\nstatus =\r\ncod_get_base_name(cod_mgr, sz_zl_file, COD_MAXPATHLENGTH);\r\nstatus =\r\ndcd_get_objects(nldr_obj->dcd_mgr, sz_zl_file,\r\nadd_ovly_node, (void *)nldr_obj);\r\nif (!status && nldr_obj->ovly_nodes > 0) {\r\nnldr_obj->ovly_table =\r\nkzalloc(sizeof(struct ovly_node) *\r\nnldr_obj->ovly_nodes, GFP_KERNEL);\r\nnldr_obj->ovly_nid = 0;\r\nstatus = dcd_get_objects(nldr_obj->dcd_mgr, sz_zl_file,\r\nadd_ovly_node,\r\n(void *)nldr_obj);\r\n}\r\n}\r\nif (!status && nldr_obj->ovly_nodes > 0) {\r\nsave_attrs.write = fake_ovly_write;\r\nsave_attrs.log_write = add_ovly_info;\r\nsave_attrs.log_write_handle = nldr_obj;\r\nflags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;\r\nstatus = nldr_obj->ldr_fxns.load_fxn(nldr_obj->base_lib, flags,\r\n&save_attrs, &ul_entry);\r\n}\r\nif (!status) {\r\n*nldr = (struct nldr_object *)nldr_obj;\r\n} else {\r\nif (nldr_obj)\r\nnldr_delete((struct nldr_object *)nldr_obj);\r\n*nldr = NULL;\r\n}\r\nreturn status;\r\n}\r\nvoid nldr_delete(struct nldr_object *nldr_obj)\r\n{\r\nstruct ovly_sect *ovly_section;\r\nstruct ovly_sect *next;\r\nu16 i;\r\nnldr_obj->ldr_fxns.exit_fxn();\r\nif (nldr_obj->rmm)\r\nrmm_delete(nldr_obj->rmm);\r\nkfree(nldr_obj->seg_table);\r\nif (nldr_obj->dcd_mgr)\r\ndcd_destroy_manager(nldr_obj->dcd_mgr);\r\nif (nldr_obj->ovly_table) {\r\nfor (i = 0; i < nldr_obj->ovly_nodes; i++) {\r\novly_section =\r\nnldr_obj->ovly_table[i].create_sects_list;\r\nwhile (ovly_section) {\r\nnext = ovly_section->next_sect;\r\nkfree(ovly_section);\r\novly_section = next;\r\n}\r\novly_section =\r\nnldr_obj->ovly_table[i].delete_sects_list;\r\nwhile (ovly_section) {\r\nnext = ovly_section->next_sect;\r\nkfree(ovly_section);\r\novly_section = next;\r\n}\r\novly_section =\r\nnldr_obj->ovly_table[i].execute_sects_list;\r\nwhile (ovly_section) {\r\nnext = ovly_section->next_sect;\r\nkfree(ovly_section);\r\novly_section = next;\r\n}\r\novly_section = nldr_obj->ovly_table[i].other_sects_list;\r\nwhile (ovly_section) {\r\nnext = ovly_section->next_sect;\r\nkfree(ovly_section);\r\novly_section = next;\r\n}\r\n}\r\nkfree(nldr_obj->ovly_table);\r\n}\r\nkfree(nldr_obj);\r\n}\r\nint nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,\r\nchar *str_fxn, u32 * addr)\r\n{\r\nstruct dbll_sym_val *dbll_sym;\r\nstruct nldr_object *nldr_obj;\r\nint status = 0;\r\nbool status1 = false;\r\ns32 i = 0;\r\nstruct lib_node root = { NULL, 0, NULL };\r\nnldr_obj = nldr_node_obj->nldr_obj;\r\nif (nldr_node_obj->dynamic && *nldr_node_obj->phase_split) {\r\nswitch (nldr_node_obj->phase) {\r\ncase NLDR_CREATE:\r\nroot = nldr_node_obj->create_lib;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nroot = nldr_node_obj->execute_lib;\r\nbreak;\r\ncase NLDR_DELETE:\r\nroot = nldr_node_obj->delete_lib;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nroot = nldr_node_obj->root;\r\n}\r\nstatus1 =\r\nnldr_obj->ldr_fxns.get_c_addr_fxn(root.lib, str_fxn, &dbll_sym);\r\nif (!status1)\r\nstatus1 =\r\nnldr_obj->ldr_fxns.get_addr_fxn(root.lib, str_fxn,\r\n&dbll_sym);\r\nif (!status1) {\r\nfor (i = 0; i < root.dep_libs; i++) {\r\nstatus1 =\r\nnldr_obj->ldr_fxns.get_addr_fxn(root.dep_libs_tree\r\n[i].lib, str_fxn,\r\n&dbll_sym);\r\nif (!status1) {\r\nstatus1 =\r\nnldr_obj->ldr_fxns.\r\nget_c_addr_fxn(root.dep_libs_tree[i].lib,\r\nstr_fxn, &dbll_sym);\r\n}\r\nif (status1) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!status1) {\r\nfor (i = 0; i < nldr_node_obj->pers_libs; i++) {\r\nstatus1 =\r\nnldr_obj->ldr_fxns.\r\nget_addr_fxn(nldr_node_obj->pers_lib_table[i].lib,\r\nstr_fxn, &dbll_sym);\r\nif (!status1) {\r\nstatus1 =\r\nnldr_obj->ldr_fxns.\r\nget_c_addr_fxn(nldr_node_obj->pers_lib_table\r\n[i].lib, str_fxn, &dbll_sym);\r\n}\r\nif (status1) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (status1)\r\n*addr = dbll_sym->value;\r\nelse\r\nstatus = -ESPIPE;\r\nreturn status;\r\n}\r\nint nldr_get_rmm_manager(struct nldr_object *nldr,\r\nstruct rmm_target_obj **rmm_mgr)\r\n{\r\nint status = 0;\r\nstruct nldr_object *nldr_obj = nldr;\r\nif (nldr) {\r\n*rmm_mgr = nldr_obj->rmm;\r\n} else {\r\n*rmm_mgr = NULL;\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint nldr_load(struct nldr_nodeobject *nldr_node_obj,\r\nenum nldr_phase phase)\r\n{\r\nstruct nldr_object *nldr_obj;\r\nstruct dsp_uuid lib_uuid;\r\nint status = 0;\r\nnldr_obj = nldr_node_obj->nldr_obj;\r\nif (nldr_node_obj->dynamic) {\r\nnldr_node_obj->phase = phase;\r\nlib_uuid = nldr_node_obj->uuid;\r\nstatus =\r\nload_lib(nldr_node_obj, &nldr_node_obj->root, lib_uuid,\r\nfalse, nldr_node_obj->lib_path, phase, 0);\r\nif (!status) {\r\nif (*nldr_node_obj->phase_split) {\r\nswitch (phase) {\r\ncase NLDR_CREATE:\r\nnldr_node_obj->create_lib =\r\nnldr_node_obj->root;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nnldr_node_obj->execute_lib =\r\nnldr_node_obj->root;\r\nbreak;\r\ncase NLDR_DELETE:\r\nnldr_node_obj->delete_lib =\r\nnldr_node_obj->root;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n} else {\r\nif (nldr_node_obj->overlay)\r\nstatus = load_ovly(nldr_node_obj, phase);\r\n}\r\nreturn status;\r\n}\r\nint nldr_unload(struct nldr_nodeobject *nldr_node_obj,\r\nenum nldr_phase phase)\r\n{\r\nint status = 0;\r\nstruct lib_node *root_lib = NULL;\r\ns32 i = 0;\r\nif (nldr_node_obj != NULL) {\r\nif (nldr_node_obj->dynamic) {\r\nif (*nldr_node_obj->phase_split) {\r\nswitch (phase) {\r\ncase NLDR_CREATE:\r\nroot_lib = &nldr_node_obj->create_lib;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nroot_lib = &nldr_node_obj->execute_lib;\r\nbreak;\r\ncase NLDR_DELETE:\r\nroot_lib = &nldr_node_obj->delete_lib;\r\nfor (i = 0;\r\ni < nldr_node_obj->pers_libs;\r\ni++) {\r\nunload_lib(nldr_node_obj,\r\n&nldr_node_obj->\r\npers_lib_table[i]);\r\n}\r\nnldr_node_obj->pers_libs = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nroot_lib = &nldr_node_obj->root;\r\n}\r\nif (root_lib)\r\nunload_lib(nldr_node_obj, root_lib);\r\n} else {\r\nif (nldr_node_obj->overlay)\r\nunload_ovly(nldr_node_obj, phase);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int add_ovly_info(void *handle, struct dbll_sect_info *sect_info,\r\nu32 addr, u32 bytes)\r\n{\r\nchar *node_name;\r\nchar *sect_name = (char *)sect_info->name;\r\nbool sect_exists = false;\r\nchar seps = ':';\r\nchar *pch;\r\nu16 i;\r\nstruct nldr_object *nldr_obj = (struct nldr_object *)handle;\r\nint status = 0;\r\nif (sect_info->sect_load_addr == sect_info->sect_run_addr)\r\ngoto func_end;\r\nfor (i = 0; i < nldr_obj->ovly_nodes; i++) {\r\nnode_name = nldr_obj->ovly_table[i].node_name;\r\nif (strncmp(node_name, sect_name + 1, strlen(node_name)) == 0) {\r\nbreak;\r\n}\r\n}\r\nif (!(i < nldr_obj->ovly_nodes))\r\ngoto func_end;\r\nfor (pch = sect_name + 1; *pch && *pch != seps; pch++)\r\n;\r\nif (*pch) {\r\npch++;\r\nif (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {\r\nstatus =\r\nadd_ovly_sect(nldr_obj,\r\n&nldr_obj->\r\novly_table[i].create_sects_list,\r\nsect_info, &sect_exists, addr, bytes);\r\nif (!status && !sect_exists)\r\nnldr_obj->ovly_table[i].create_sects++;\r\n} else if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {\r\nstatus =\r\nadd_ovly_sect(nldr_obj,\r\n&nldr_obj->\r\novly_table[i].delete_sects_list,\r\nsect_info, &sect_exists, addr, bytes);\r\nif (!status && !sect_exists)\r\nnldr_obj->ovly_table[i].delete_sects++;\r\n} else if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {\r\nstatus =\r\nadd_ovly_sect(nldr_obj,\r\n&nldr_obj->\r\novly_table[i].execute_sects_list,\r\nsect_info, &sect_exists, addr, bytes);\r\nif (!status && !sect_exists)\r\nnldr_obj->ovly_table[i].execute_sects++;\r\n} else {\r\nstatus =\r\nadd_ovly_sect(nldr_obj,\r\n&nldr_obj->\r\novly_table[i].other_sects_list,\r\nsect_info, &sect_exists, addr, bytes);\r\nif (!status && !sect_exists)\r\nnldr_obj->ovly_table[i].other_sects++;\r\n}\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nstatic int add_ovly_node(struct dsp_uuid *uuid_obj,\r\nenum dsp_dcdobjtype obj_type, void *handle)\r\n{\r\nstruct nldr_object *nldr_obj = (struct nldr_object *)handle;\r\nchar *node_name = NULL;\r\nchar *pbuf = NULL;\r\nu32 len;\r\nstruct dcd_genericobj obj_def;\r\nint status = 0;\r\nif (obj_type != DSP_DCDNODETYPE)\r\ngoto func_end;\r\nstatus =\r\ndcd_get_object_def(nldr_obj->dcd_mgr, uuid_obj, obj_type,\r\n&obj_def);\r\nif (status)\r\ngoto func_end;\r\nif (obj_def.obj_data.node_obj.load_type == NLDR_OVLYLOAD) {\r\nif (nldr_obj->ovly_table == NULL) {\r\nnldr_obj->ovly_nodes++;\r\n} else {\r\nnldr_obj->ovly_table[nldr_obj->ovly_nid].uuid =\r\n*uuid_obj;\r\nlen =\r\nstrlen(obj_def.obj_data.node_obj.ndb_props.ac_name);\r\nnode_name = obj_def.obj_data.node_obj.ndb_props.ac_name;\r\npbuf = kzalloc(len + 1, GFP_KERNEL);\r\nif (pbuf == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nstrncpy(pbuf, node_name, len);\r\nnldr_obj->ovly_table[nldr_obj->ovly_nid].\r\nnode_name = pbuf;\r\nnldr_obj->ovly_nid++;\r\n}\r\n}\r\n}\r\nkfree(obj_def.obj_data.node_obj.str_create_phase_fxn);\r\nkfree(obj_def.obj_data.node_obj.str_execute_phase_fxn);\r\nkfree(obj_def.obj_data.node_obj.str_delete_phase_fxn);\r\nkfree(obj_def.obj_data.node_obj.str_i_alg_name);\r\nfunc_end:\r\nreturn status;\r\n}\r\nstatic int add_ovly_sect(struct nldr_object *nldr_obj,\r\nstruct ovly_sect **lst,\r\nstruct dbll_sect_info *sect_inf,\r\nbool *exists, u32 addr, u32 bytes)\r\n{\r\nstruct ovly_sect *new_sect = NULL;\r\nstruct ovly_sect *last_sect;\r\nstruct ovly_sect *ovly_section;\r\nint status = 0;\r\novly_section = last_sect = *lst;\r\n*exists = false;\r\nwhile (ovly_section) {\r\nif (ovly_section->sect_load_addr == addr) {\r\n*exists = true;\r\nbreak;\r\n}\r\nlast_sect = ovly_section;\r\novly_section = ovly_section->next_sect;\r\n}\r\nif (!ovly_section) {\r\nnew_sect = kzalloc(sizeof(struct ovly_sect), GFP_KERNEL);\r\nif (new_sect == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nnew_sect->sect_load_addr = addr;\r\nnew_sect->sect_run_addr = sect_inf->sect_run_addr +\r\n(addr - sect_inf->sect_load_addr);\r\nnew_sect->size = bytes;\r\nnew_sect->page = sect_inf->type;\r\n}\r\nif (!status) {\r\nif (*lst == NULL) {\r\n*lst = new_sect;\r\n} else {\r\nlast_sect->next_sect = new_sect;\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic s32 fake_ovly_write(void *handle, u32 dsp_address, void *buf, u32 bytes,\r\ns32 mtype)\r\n{\r\nreturn (s32) bytes;\r\n}\r\nstatic void free_sects(struct nldr_object *nldr_obj,\r\nstruct ovly_sect *phase_sects, u16 alloc_num)\r\n{\r\nstruct ovly_sect *ovly_section = phase_sects;\r\nu16 i = 0;\r\nbool ret;\r\nwhile (ovly_section && i < alloc_num) {\r\nret =\r\nrmm_free(nldr_obj->rmm, 0, ovly_section->sect_run_addr,\r\novly_section->size, true);\r\novly_section = ovly_section->next_sect;\r\ni++;\r\n}\r\n}\r\nstatic bool get_symbol_value(void *handle, void *parg, void *rmm_handle,\r\nchar *sym_name, struct dbll_sym_val **sym)\r\n{\r\nstruct nldr_object *nldr_obj = (struct nldr_object *)handle;\r\nstruct nldr_nodeobject *nldr_node_obj =\r\n(struct nldr_nodeobject *)rmm_handle;\r\nstruct lib_node *root = (struct lib_node *)parg;\r\nu16 i;\r\nbool status = false;\r\nstatus = nldr_obj->ldr_fxns.get_addr_fxn(nldr_obj->base_lib,\r\nsym_name, sym);\r\nif (!status)\r\nstatus =\r\nnldr_obj->ldr_fxns.get_c_addr_fxn(nldr_obj->base_lib,\r\nsym_name, sym);\r\nif (!status) {\r\nstatus = nldr_obj->ldr_fxns.get_addr_fxn(root->lib, sym_name,\r\nsym);\r\nif (!status) {\r\nstatus =\r\nnldr_obj->ldr_fxns.get_c_addr_fxn(root->lib,\r\nsym_name, sym);\r\n}\r\n}\r\nif (!status) {\r\nfor (i = 0; i < root->dep_libs; i++) {\r\nstatus =\r\nnldr_obj->ldr_fxns.get_addr_fxn(root->\r\ndep_libs_tree\r\n[i].lib,\r\nsym_name, sym);\r\nif (!status) {\r\nstatus =\r\nnldr_obj->ldr_fxns.\r\nget_c_addr_fxn(root->dep_libs_tree[i].lib,\r\nsym_name, sym);\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!status) {\r\nfor (i = 0; i < nldr_node_obj->pers_libs; i++) {\r\nstatus =\r\nnldr_obj->ldr_fxns.\r\nget_addr_fxn(nldr_node_obj->pers_lib_table[i].lib,\r\nsym_name, sym);\r\nif (!status) {\r\nstatus = nldr_obj->ldr_fxns.get_c_addr_fxn\r\n(nldr_node_obj->pers_lib_table[i].lib,\r\nsym_name, sym);\r\n}\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int load_lib(struct nldr_nodeobject *nldr_node_obj,\r\nstruct lib_node *root, struct dsp_uuid uuid,\r\nbool root_prstnt,\r\nstruct dbll_library_obj **lib_path,\r\nenum nldr_phase phase, u16 depth)\r\n{\r\nstruct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;\r\nu16 nd_libs = 0;\r\nu16 np_libs = 0;\r\nu16 nd_libs_loaded = 0;\r\nu16 i;\r\nu32 entry;\r\nu32 dw_buf_size = NLDR_MAXPATHLENGTH;\r\ndbll_flags flags = DBLL_SYMB | DBLL_CODE | DBLL_DATA | DBLL_DYNAMIC;\r\nstruct dbll_attrs new_attrs;\r\nchar *psz_file_name = NULL;\r\nstruct dsp_uuid *dep_lib_uui_ds = NULL;\r\nbool *persistent_dep_libs = NULL;\r\nint status = 0;\r\nbool lib_status = false;\r\nstruct lib_node *dep_lib;\r\nif (depth > MAXDEPTH) {\r\n}\r\nroot->lib = NULL;\r\npsz_file_name = kzalloc(DBLL_MAXPATHLENGTH, GFP_KERNEL);\r\nif (psz_file_name == NULL)\r\nstatus = -ENOMEM;\r\nif (!status) {\r\nif (depth == 0) {\r\nstatus =\r\ndcd_get_library_name(nldr_node_obj->nldr_obj->\r\ndcd_mgr, &uuid, psz_file_name,\r\n&dw_buf_size, phase,\r\nnldr_node_obj->phase_split);\r\n} else {\r\nstatus =\r\ndcd_get_library_name(nldr_node_obj->nldr_obj->\r\ndcd_mgr, &uuid, psz_file_name,\r\n&dw_buf_size, NLDR_NOPHASE,\r\nNULL);\r\n}\r\n}\r\nif (!status) {\r\nstatus =\r\nnldr_obj->ldr_fxns.open_fxn(nldr_obj->dbll, psz_file_name,\r\nDBLL_NOLOAD, &root->lib);\r\n}\r\nkfree(psz_file_name);\r\nif (!status && root_prstnt) {\r\nlib_status =\r\nfind_in_persistent_lib_array(nldr_node_obj, root->lib);\r\nif (lib_status) {\r\nnldr_obj->ldr_fxns.close_fxn(root->lib);\r\nreturn 0;\r\n}\r\n}\r\nif (!status) {\r\nfor (i = 0; i < depth; i++) {\r\nif (root->lib == lib_path[i]) {\r\nstatus = -EILSEQ;\r\n}\r\n}\r\n}\r\nif (!status) {\r\nlib_path[depth] = root->lib;\r\ndepth++;\r\nstatus =\r\ndcd_get_num_dep_libs(nldr_node_obj->nldr_obj->dcd_mgr,\r\n&uuid, &nd_libs, &np_libs, phase);\r\n}\r\nif (!status) {\r\nif (!(*nldr_node_obj->phase_split))\r\nnp_libs = 0;\r\nroot->dep_libs = nd_libs - np_libs;\r\nif (nd_libs > 0) {\r\ndep_lib_uui_ds = kzalloc(sizeof(struct dsp_uuid) *\r\nnd_libs, GFP_KERNEL);\r\npersistent_dep_libs =\r\nkzalloc(sizeof(bool) * nd_libs, GFP_KERNEL);\r\nif (!dep_lib_uui_ds || !persistent_dep_libs)\r\nstatus = -ENOMEM;\r\nif (root->dep_libs > 0) {\r\nroot->dep_libs_tree = kzalloc\r\n(sizeof(struct lib_node) *\r\n(root->dep_libs), GFP_KERNEL);\r\nif (!(root->dep_libs_tree))\r\nstatus = -ENOMEM;\r\n}\r\nif (!status) {\r\nstatus =\r\ndcd_get_dep_libs(nldr_node_obj->\r\nnldr_obj->dcd_mgr, &uuid,\r\nnd_libs, dep_lib_uui_ds,\r\npersistent_dep_libs,\r\nphase);\r\n}\r\n}\r\n}\r\nif (!status) {\r\nfor (i = 0; i < nd_libs; i++) {\r\nif (!root_prstnt && persistent_dep_libs[i] &&\r\n*nldr_node_obj->phase_split) {\r\nif ((nldr_node_obj->pers_libs) >= MAXLIBS) {\r\nstatus = -EILSEQ;\r\nbreak;\r\n}\r\ndep_lib =\r\n&nldr_node_obj->pers_lib_table\r\n[nldr_node_obj->pers_libs];\r\n} else {\r\nif (root_prstnt)\r\npersistent_dep_libs[i] = true;\r\ndep_lib = &root->dep_libs_tree[nd_libs_loaded];\r\n}\r\nstatus = load_lib(nldr_node_obj, dep_lib,\r\ndep_lib_uui_ds[i],\r\npersistent_dep_libs[i], lib_path,\r\nphase, depth);\r\nif (!status) {\r\nif ((status != 0) &&\r\n!root_prstnt && persistent_dep_libs[i] &&\r\n*nldr_node_obj->phase_split) {\r\n(nldr_node_obj->pers_libs)++;\r\n} else {\r\nif (!persistent_dep_libs[i] ||\r\n!(*nldr_node_obj->phase_split)) {\r\nnd_libs_loaded++;\r\n}\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!status) {\r\nnew_attrs = nldr_obj->ldr_attrs;\r\nnew_attrs.sym_arg = root;\r\nnew_attrs.rmm_handle = nldr_node_obj;\r\nnew_attrs.input_params = nldr_node_obj->priv_ref;\r\nnew_attrs.base_image = false;\r\nstatus =\r\nnldr_obj->ldr_fxns.load_fxn(root->lib, flags, &new_attrs,\r\n&entry);\r\n}\r\nif (status) {\r\nif (phase != NLDR_EXECUTE) {\r\nfor (i = 0; i < nldr_node_obj->pers_libs; i++)\r\nunload_lib(nldr_node_obj,\r\n&nldr_node_obj->pers_lib_table[i]);\r\nnldr_node_obj->pers_libs = 0;\r\n}\r\nfor (i = 0; i < nd_libs_loaded; i++)\r\nunload_lib(nldr_node_obj, &root->dep_libs_tree[i]);\r\nif (root->lib)\r\nnldr_obj->ldr_fxns.close_fxn(root->lib);\r\n}\r\ndepth--;\r\nkfree(dep_lib_uui_ds);\r\ndep_lib_uui_ds = NULL;\r\nkfree(persistent_dep_libs);\r\npersistent_dep_libs = NULL;\r\nreturn status;\r\n}\r\nstatic int load_ovly(struct nldr_nodeobject *nldr_node_obj,\r\nenum nldr_phase phase)\r\n{\r\nstruct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;\r\nstruct ovly_node *po_node = NULL;\r\nstruct ovly_sect *phase_sects = NULL;\r\nstruct ovly_sect *other_sects_list = NULL;\r\nu16 i;\r\nu16 alloc_num = 0;\r\nu16 other_alloc = 0;\r\nu16 *ref_count = NULL;\r\nu16 *other_ref = NULL;\r\nu32 bytes;\r\nstruct ovly_sect *ovly_section;\r\nint status = 0;\r\nfor (i = 0; i < nldr_obj->ovly_nodes; i++) {\r\nif (is_equal_uuid\r\n(&nldr_node_obj->uuid, &nldr_obj->ovly_table[i].uuid)) {\r\npo_node = &(nldr_obj->ovly_table[i]);\r\nbreak;\r\n}\r\n}\r\nif (!po_node) {\r\nstatus = -ENOENT;\r\ngoto func_end;\r\n}\r\nswitch (phase) {\r\ncase NLDR_CREATE:\r\nref_count = &(po_node->create_ref);\r\nother_ref = &(po_node->other_ref);\r\nphase_sects = po_node->create_sects_list;\r\nother_sects_list = po_node->other_sects_list;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nref_count = &(po_node->execute_ref);\r\nphase_sects = po_node->execute_sects_list;\r\nbreak;\r\ncase NLDR_DELETE:\r\nref_count = &(po_node->delete_ref);\r\nphase_sects = po_node->delete_sects_list;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ref_count == NULL)\r\ngoto func_end;\r\nif (*ref_count != 0)\r\ngoto func_end;\r\novly_section = phase_sects;\r\nwhile (ovly_section) {\r\nstatus = rmm_alloc(nldr_obj->rmm, 0, ovly_section->size, 0,\r\n&(ovly_section->sect_run_addr), true);\r\nif (!status) {\r\novly_section = ovly_section->next_sect;\r\nalloc_num++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (other_ref && *other_ref == 0) {\r\nif (!status) {\r\novly_section = other_sects_list;\r\nwhile (ovly_section) {\r\nstatus =\r\nrmm_alloc(nldr_obj->rmm, 0,\r\novly_section->size, 0,\r\n&(ovly_section->sect_run_addr),\r\ntrue);\r\nif (!status) {\r\novly_section = ovly_section->next_sect;\r\nother_alloc++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (*ref_count == 0) {\r\nif (!status) {\r\novly_section = phase_sects;\r\nwhile (ovly_section && !status) {\r\nbytes =\r\n(*nldr_obj->ovly_fxn) (nldr_node_obj->\r\npriv_ref,\r\novly_section->\r\nsect_run_addr,\r\novly_section->\r\nsect_load_addr,\r\novly_section->size,\r\novly_section->page);\r\nif (bytes != ovly_section->size)\r\nstatus = -EPERM;\r\novly_section = ovly_section->next_sect;\r\n}\r\n}\r\n}\r\nif (other_ref && *other_ref == 0) {\r\nif (!status) {\r\novly_section = other_sects_list;\r\nwhile (ovly_section && !status) {\r\nbytes =\r\n(*nldr_obj->ovly_fxn) (nldr_node_obj->\r\npriv_ref,\r\novly_section->\r\nsect_run_addr,\r\novly_section->\r\nsect_load_addr,\r\novly_section->size,\r\novly_section->page);\r\nif (bytes != ovly_section->size)\r\nstatus = -EPERM;\r\novly_section = ovly_section->next_sect;\r\n}\r\n}\r\n}\r\nif (status) {\r\nfree_sects(nldr_obj, phase_sects, alloc_num);\r\nfree_sects(nldr_obj, other_sects_list, other_alloc);\r\n}\r\nfunc_end:\r\nif (!status && (ref_count != NULL)) {\r\n*ref_count += 1;\r\nif (other_ref)\r\n*other_ref += 1;\r\n}\r\nreturn status;\r\n}\r\nstatic int remote_alloc(void **ref, u16 mem_sect, u32 size,\r\nu32 align, u32 *dsp_address,\r\ns32 segmnt_id, s32 req,\r\nbool reserve)\r\n{\r\nstruct nldr_nodeobject *hnode = (struct nldr_nodeobject *)ref;\r\nstruct nldr_object *nldr_obj;\r\nstruct rmm_target_obj *rmm;\r\nu16 mem_phase_bit = MAXFLAGS;\r\nu16 segid = 0;\r\nu16 i;\r\nu16 mem_sect_type;\r\nu32 word_size;\r\nstruct rmm_addr *rmm_addr_obj = (struct rmm_addr *)dsp_address;\r\nbool mem_load_req = false;\r\nint status = -ENOMEM;\r\nnldr_obj = hnode->nldr_obj;\r\nrmm = nldr_obj->rmm;\r\nword_size =\r\n(size + nldr_obj->dsp_word_size -\r\n1) / nldr_obj->dsp_word_size;\r\nalign = lcm(GEM_CACHE_LINE_SIZE, align);\r\ndev_dbg(bridge, "%s: memory align to 0x%x\n", __func__, align);\r\nif (segmnt_id != -1) {\r\nrmm_addr_obj->segid = segmnt_id;\r\nsegid = segmnt_id;\r\nmem_load_req = req;\r\n} else {\r\nswitch (hnode->phase) {\r\ncase NLDR_CREATE:\r\nmem_phase_bit = CREATEDATAFLAGBIT;\r\nbreak;\r\ncase NLDR_DELETE:\r\nmem_phase_bit = DELETEDATAFLAGBIT;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nmem_phase_bit = EXECUTEDATAFLAGBIT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (mem_sect == DBLL_CODE)\r\nmem_phase_bit++;\r\nif (mem_phase_bit < MAXFLAGS)\r\nsegid = hnode->seg_id[mem_phase_bit];\r\nif ((hnode->code_data_flag_mask >> mem_phase_bit) & 0x1)\r\nmem_load_req = true;\r\n}\r\nmem_sect_type = (mem_sect == DBLL_CODE) ? DYNM_CODE : DYNM_DATA;\r\nif (segid == NULLID) {\r\ngoto func_cont;\r\n}\r\nif (segid <= MAXSEGID) {\r\nrmm_addr_obj->segid = segid;\r\nstatus =\r\nrmm_alloc(rmm, segid, word_size, align, dsp_address, false);\r\nif (status) {\r\ndev_dbg(bridge, "%s: Unable allocate from segment %d\n",\r\n__func__, segid);\r\n}\r\n} else {\r\nmem_sect_type |= segid == MEMINTERNALID ?\r\nDYNM_INTERNAL : DYNM_EXTERNAL;\r\nfor (i = 0; i < nldr_obj->dload_segs; i++) {\r\nif ((nldr_obj->seg_table[i] & mem_sect_type) !=\r\nmem_sect_type)\r\ncontinue;\r\nstatus = rmm_alloc(rmm, i, word_size, align,\r\ndsp_address, false);\r\nif (!status) {\r\nrmm_addr_obj->segid = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nfunc_cont:\r\nif (status == -ENOMEM && !mem_load_req) {\r\ndev_dbg(bridge, "%s: Preferred segment unavailable, trying "\r\n"another\n", __func__);\r\nfor (i = 0; i < nldr_obj->dload_segs; i++) {\r\nif ((nldr_obj->seg_table[i] & mem_sect_type) !=\r\nmem_sect_type)\r\ncontinue;\r\nstatus = rmm_alloc(rmm, i, word_size, align,\r\ndsp_address, false);\r\nif (!status) {\r\nrmm_addr_obj->segid = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int remote_free(void **ref, u16 space, u32 dsp_address,\r\nu32 size, bool reserve)\r\n{\r\nstruct nldr_object *nldr_obj = (struct nldr_object *)ref;\r\nstruct rmm_target_obj *rmm;\r\nu32 word_size;\r\nint status = -ENOMEM;\r\nrmm = nldr_obj->rmm;\r\nword_size =\r\n(size + nldr_obj->dsp_word_size -\r\n1) / nldr_obj->dsp_word_size;\r\nif (rmm_free(rmm, space, dsp_address, word_size, reserve))\r\nstatus = 0;\r\nreturn status;\r\n}\r\nstatic void unload_lib(struct nldr_nodeobject *nldr_node_obj,\r\nstruct lib_node *root)\r\n{\r\nstruct dbll_attrs new_attrs;\r\nstruct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;\r\nu16 i;\r\nfor (i = 0; i < root->dep_libs; i++)\r\nunload_lib(nldr_node_obj, &root->dep_libs_tree[i]);\r\nroot->dep_libs = 0;\r\nnew_attrs = nldr_obj->ldr_attrs;\r\nnew_attrs.rmm_handle = nldr_obj->rmm;\r\nnew_attrs.input_params = nldr_node_obj->priv_ref;\r\nnew_attrs.base_image = false;\r\nnew_attrs.sym_arg = root;\r\nif (root->lib) {\r\nnldr_obj->ldr_fxns.unload_fxn(root->lib, &new_attrs);\r\nnldr_obj->ldr_fxns.close_fxn(root->lib);\r\n}\r\nkfree(root->dep_libs_tree);\r\nroot->dep_libs_tree = NULL;\r\n}\r\nstatic void unload_ovly(struct nldr_nodeobject *nldr_node_obj,\r\nenum nldr_phase phase)\r\n{\r\nstruct nldr_object *nldr_obj = nldr_node_obj->nldr_obj;\r\nstruct ovly_node *po_node = NULL;\r\nstruct ovly_sect *phase_sects = NULL;\r\nstruct ovly_sect *other_sects_list = NULL;\r\nu16 i;\r\nu16 alloc_num = 0;\r\nu16 other_alloc = 0;\r\nu16 *ref_count = NULL;\r\nu16 *other_ref = NULL;\r\nfor (i = 0; i < nldr_obj->ovly_nodes; i++) {\r\nif (is_equal_uuid\r\n(&nldr_node_obj->uuid, &nldr_obj->ovly_table[i].uuid)) {\r\npo_node = &(nldr_obj->ovly_table[i]);\r\nbreak;\r\n}\r\n}\r\nif (!po_node)\r\nreturn;\r\nswitch (phase) {\r\ncase NLDR_CREATE:\r\nref_count = &(po_node->create_ref);\r\nphase_sects = po_node->create_sects_list;\r\nalloc_num = po_node->create_sects;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nref_count = &(po_node->execute_ref);\r\nphase_sects = po_node->execute_sects_list;\r\nalloc_num = po_node->execute_sects;\r\nbreak;\r\ncase NLDR_DELETE:\r\nref_count = &(po_node->delete_ref);\r\nother_ref = &(po_node->other_ref);\r\nphase_sects = po_node->delete_sects_list;\r\nother_sects_list = po_node->other_sects_list;\r\nalloc_num = po_node->delete_sects;\r\nother_alloc = po_node->other_sects;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ref_count && (*ref_count > 0)) {\r\n*ref_count -= 1;\r\nif (other_ref) {\r\n*other_ref -= 1;\r\n}\r\n}\r\nif (ref_count && *ref_count == 0) {\r\nfree_sects(nldr_obj, phase_sects, alloc_num);\r\n}\r\nif (other_ref && *other_ref == 0)\r\nfree_sects(nldr_obj, other_sects_list, other_alloc);\r\n}\r\nstatic bool find_in_persistent_lib_array(struct nldr_nodeobject *nldr_node_obj,\r\nstruct dbll_library_obj *lib)\r\n{\r\ns32 i = 0;\r\nfor (i = 0; i < nldr_node_obj->pers_libs; i++) {\r\nif (lib == nldr_node_obj->pers_lib_table[i].lib)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint nldr_find_addr(struct nldr_nodeobject *nldr_node, u32 sym_addr,\r\nu32 offset_range, void *offset_output, char *sym_name)\r\n{\r\nint status = 0;\r\nbool status1 = false;\r\ns32 i = 0;\r\nstruct lib_node root = { NULL, 0, NULL };\r\npr_debug("%s(0x%x, 0x%x, 0x%x, 0x%x, %s)\n", __func__, (u32) nldr_node,\r\nsym_addr, offset_range, (u32) offset_output, sym_name);\r\nif (nldr_node->dynamic && *nldr_node->phase_split) {\r\nswitch (nldr_node->phase) {\r\ncase NLDR_CREATE:\r\nroot = nldr_node->create_lib;\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nroot = nldr_node->execute_lib;\r\nbreak;\r\ncase NLDR_DELETE:\r\nroot = nldr_node->delete_lib;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nroot = nldr_node->root;\r\n}\r\nstatus1 = dbll_find_dsp_symbol(root.lib, sym_addr,\r\noffset_range, offset_output, sym_name);\r\nif (!status1)\r\nfor (i = 0; i < root.dep_libs; i++) {\r\nstatus1 = dbll_find_dsp_symbol(\r\nroot.dep_libs_tree[i].lib, sym_addr,\r\noffset_range, offset_output, sym_name);\r\nif (status1)\r\nbreak;\r\n}\r\nif (!status1)\r\nfor (i = 0; i < nldr_node->pers_libs; i++) {\r\nstatus1 = dbll_find_dsp_symbol(\r\nnldr_node->pers_lib_table[i].lib, sym_addr,\r\noffset_range, offset_output, sym_name);\r\nif (status1)\r\nbreak;\r\n}\r\nif (!status1) {\r\npr_debug("%s: Address 0x%x not found in range %d.\n",\r\n__func__, sym_addr, offset_range);\r\nstatus = -ESPIPE;\r\n}\r\nreturn status;\r\n}
