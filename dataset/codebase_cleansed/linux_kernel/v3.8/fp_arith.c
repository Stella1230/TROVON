struct fp_ext *\r\nfp_fabs(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fabs\n");\r\nfp_monadic_check(dest, src);\r\ndest->sign = 0;\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fneg(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fneg\n");\r\nfp_monadic_check(dest, src);\r\ndest->sign = !dest->sign;\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fadd(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\nint diff;\r\ndprint(PINSTR, "fadd\n");\r\nfp_dyadic_check(dest, src);\r\nif (IS_INF(dest)) {\r\nif (IS_INF(src) && (src->sign != dest->sign))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_INF(src)) {\r\nfp_copy_ext(dest, src);\r\nreturn dest;\r\n}\r\nif (IS_ZERO(dest)) {\r\nif (IS_ZERO(src)) {\r\nif (src->sign != dest->sign) {\r\nif (FPDATA->rnd == FPCR_ROUND_RM)\r\ndest->sign = 1;\r\nelse\r\ndest->sign = 0;\r\n}\r\n} else\r\nfp_copy_ext(dest, src);\r\nreturn dest;\r\n}\r\ndest->lowmant = src->lowmant = 0;\r\nif ((diff = dest->exp - src->exp) > 0)\r\nfp_denormalize(src, diff);\r\nelse if ((diff = -diff) > 0)\r\nfp_denormalize(dest, diff);\r\nif (dest->sign == src->sign) {\r\nif (fp_addmant(dest, src))\r\nif (!fp_addcarry(dest))\r\nreturn dest;\r\n} else {\r\nif (dest->mant.m64 < src->mant.m64) {\r\nfp_submant(dest, src, dest);\r\ndest->sign = !dest->sign;\r\n} else\r\nfp_submant(dest, dest, src);\r\n}\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fsub(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fsub ");\r\nsrc->sign = !src->sign;\r\nreturn fp_fadd(dest, src);\r\n}\r\nstruct fp_ext *\r\nfp_fcmp(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fcmp ");\r\nFPDATA->temp[1] = *dest;\r\nsrc->sign = !src->sign;\r\nreturn fp_fadd(&FPDATA->temp[1], src);\r\n}\r\nstruct fp_ext *\r\nfp_ftst(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "ftst\n");\r\n(void)dest;\r\nreturn src;\r\n}\r\nstruct fp_ext *\r\nfp_fmul(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\nunion fp_mant128 temp;\r\nint exp;\r\ndprint(PINSTR, "fmul\n");\r\nfp_dyadic_check(dest, src);\r\ndest->sign = src->sign ^ dest->sign;\r\nif (IS_INF(dest)) {\r\nif (IS_ZERO(src))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_INF(src)) {\r\nif (IS_ZERO(dest))\r\nfp_set_nan(dest);\r\nelse\r\nfp_copy_ext(dest, src);\r\nreturn dest;\r\n}\r\nif (IS_ZERO(dest) || IS_ZERO(src)) {\r\ndest->exp = 0;\r\ndest->mant.m64 = 0;\r\ndest->lowmant = 0;\r\nreturn dest;\r\n}\r\nexp = dest->exp + src->exp - 0x3ffe;\r\nif ((long)dest->mant.m32[0] >= 0)\r\nexp -= fp_overnormalize(dest);\r\nif ((long)src->mant.m32[0] >= 0)\r\nexp -= fp_overnormalize(src);\r\nfp_multiplymant(&temp, dest, src);\r\nif ((long)temp.m32[0] > 0) {\r\nexp--;\r\nfp_putmant128(dest, &temp, 1);\r\n} else\r\nfp_putmant128(dest, &temp, 0);\r\nif (exp >= 0x7fff) {\r\nfp_set_ovrflw(dest);\r\nreturn dest;\r\n}\r\ndest->exp = exp;\r\nif (exp < 0) {\r\nfp_set_sr(FPSR_EXC_UNFL);\r\nfp_denormalize(dest, -exp);\r\n}\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fdiv(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\nunion fp_mant128 temp;\r\nint exp;\r\ndprint(PINSTR, "fdiv\n");\r\nfp_dyadic_check(dest, src);\r\ndest->sign = src->sign ^ dest->sign;\r\nif (IS_INF(dest)) {\r\nif (IS_INF(src))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_INF(src)) {\r\ndest->exp = 0;\r\ndest->mant.m64 = 0;\r\ndest->lowmant = 0;\r\nreturn dest;\r\n}\r\nif (IS_ZERO(dest)) {\r\nif (IS_ZERO(src))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_ZERO(src)) {\r\nfp_set_sr(FPSR_EXC_DZ);\r\ndest->exp = 0x7fff;\r\ndest->mant.m64 = 0;\r\nreturn dest;\r\n}\r\nexp = dest->exp - src->exp + 0x3fff;\r\nif ((long)dest->mant.m32[0] >= 0)\r\nexp -= fp_overnormalize(dest);\r\nif ((long)src->mant.m32[0] >= 0)\r\nexp -= fp_overnormalize(src);\r\nfp_dividemant(&temp, dest, src);\r\nif (!temp.m32[0]) {\r\nexp--;\r\nfp_putmant128(dest, &temp, 32);\r\n} else\r\nfp_putmant128(dest, &temp, 31);\r\nif (exp >= 0x7fff) {\r\nfp_set_ovrflw(dest);\r\nreturn dest;\r\n}\r\ndest->exp = exp;\r\nif (exp < 0) {\r\nfp_set_sr(FPSR_EXC_UNFL);\r\nfp_denormalize(dest, -exp);\r\n}\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fsglmul(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\nint exp;\r\ndprint(PINSTR, "fsglmul\n");\r\nfp_dyadic_check(dest, src);\r\ndest->sign = src->sign ^ dest->sign;\r\nif (IS_INF(dest)) {\r\nif (IS_ZERO(src))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_INF(src)) {\r\nif (IS_ZERO(dest))\r\nfp_set_nan(dest);\r\nelse\r\nfp_copy_ext(dest, src);\r\nreturn dest;\r\n}\r\nif (IS_ZERO(dest) || IS_ZERO(src)) {\r\ndest->exp = 0;\r\ndest->mant.m64 = 0;\r\ndest->lowmant = 0;\r\nreturn dest;\r\n}\r\nexp = dest->exp + src->exp - 0x3ffe;\r\nfp_mul64(dest->mant.m32[0], dest->mant.m32[1],\r\ndest->mant.m32[0] & 0xffffff00,\r\nsrc->mant.m32[0] & 0xffffff00);\r\nif (exp >= 0x7fff) {\r\nfp_set_ovrflw(dest);\r\nreturn dest;\r\n}\r\ndest->exp = exp;\r\nif (exp < 0) {\r\nfp_set_sr(FPSR_EXC_UNFL);\r\nfp_denormalize(dest, -exp);\r\n}\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fsgldiv(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\nint exp;\r\nunsigned long quot, rem;\r\ndprint(PINSTR, "fsgldiv\n");\r\nfp_dyadic_check(dest, src);\r\ndest->sign = src->sign ^ dest->sign;\r\nif (IS_INF(dest)) {\r\nif (IS_INF(src))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_INF(src)) {\r\ndest->exp = 0;\r\ndest->mant.m64 = 0;\r\ndest->lowmant = 0;\r\nreturn dest;\r\n}\r\nif (IS_ZERO(dest)) {\r\nif (IS_ZERO(src))\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_ZERO(src)) {\r\nfp_set_sr(FPSR_EXC_DZ);\r\ndest->exp = 0x7fff;\r\ndest->mant.m64 = 0;\r\nreturn dest;\r\n}\r\nexp = dest->exp - src->exp + 0x3fff;\r\ndest->mant.m32[0] &= 0xffffff00;\r\nsrc->mant.m32[0] &= 0xffffff00;\r\nif (dest->mant.m32[0] >= src->mant.m32[0]) {\r\nfp_sub64(dest->mant, src->mant);\r\nfp_div64(quot, rem, dest->mant.m32[0], 0, src->mant.m32[0]);\r\ndest->mant.m32[0] = 0x80000000 | (quot >> 1);\r\ndest->mant.m32[1] = (quot & 1) | rem;\r\n} else {\r\nfp_div64(quot, rem, dest->mant.m32[0], 0, src->mant.m32[0]);\r\ndest->mant.m32[0] = quot;\r\ndest->mant.m32[1] = rem;\r\nexp--;\r\n}\r\nif (exp >= 0x7fff) {\r\nfp_set_ovrflw(dest);\r\nreturn dest;\r\n}\r\ndest->exp = exp;\r\nif (exp < 0) {\r\nfp_set_sr(FPSR_EXC_UNFL);\r\nfp_denormalize(dest, -exp);\r\n}\r\nreturn dest;\r\n}\r\nstatic void fp_roundint(struct fp_ext *dest, int mode)\r\n{\r\nunion fp_mant64 oldmant;\r\nunsigned long mask;\r\nif (!fp_normalize_ext(dest))\r\nreturn;\r\nif (IS_INF(dest) || IS_ZERO(dest))\r\nreturn;\r\noldmant = dest->mant;\r\nswitch (dest->exp) {\r\ncase 0 ... 0x3ffe:\r\ndest->mant.m64 = 0;\r\nbreak;\r\ncase 0x3fff ... 0x401e:\r\ndest->mant.m32[0] &= 0xffffffffU << (0x401e - dest->exp);\r\ndest->mant.m32[1] = 0;\r\nif (oldmant.m64 == dest->mant.m64)\r\nreturn;\r\nbreak;\r\ncase 0x401f ... 0x403e:\r\ndest->mant.m32[1] &= 0xffffffffU << (0x403e - dest->exp);\r\nif (oldmant.m32[1] == dest->mant.m32[1])\r\nreturn;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfp_set_sr(FPSR_EXC_INEX2);\r\nswitch (mode) {\r\ncase FPCR_ROUND_RN:\r\nswitch (dest->exp) {\r\ncase 0 ... 0x3ffd:\r\nreturn;\r\ncase 0x3ffe:\r\nif (oldmant.m64 == (1ULL << 63))\r\nreturn;\r\nbreak;\r\ncase 0x3fff ... 0x401d:\r\nmask = 1 << (0x401d - dest->exp);\r\nif (!(oldmant.m32[0] & mask))\r\nreturn;\r\nif (oldmant.m32[0] & (mask << 1))\r\nbreak;\r\nif (!(oldmant.m32[0] << (dest->exp - 0x3ffd)) &&\r\n!oldmant.m32[1])\r\nreturn;\r\nbreak;\r\ncase 0x401e:\r\nif (!(oldmant.m32[1] >= 0))\r\nreturn;\r\nif (oldmant.m32[0] & 1)\r\nbreak;\r\nif (!(oldmant.m32[1] << 1))\r\nreturn;\r\nbreak;\r\ncase 0x401f ... 0x403d:\r\nmask = 1 << (0x403d - dest->exp);\r\nif (!(oldmant.m32[1] & mask))\r\nreturn;\r\nif (oldmant.m32[1] & (mask << 1))\r\nbreak;\r\nif (!(oldmant.m32[1] << (dest->exp - 0x401d)))\r\nreturn;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nbreak;\r\ncase FPCR_ROUND_RZ:\r\nreturn;\r\ndefault:\r\nif (dest->sign ^ (mode - FPCR_ROUND_RM))\r\nbreak;\r\nreturn;\r\n}\r\nswitch (dest->exp) {\r\ncase 0 ... 0x3ffe:\r\ndest->exp = 0x3fff;\r\ndest->mant.m64 = 1ULL << 63;\r\nbreak;\r\ncase 0x3fff ... 0x401e:\r\nmask = 1 << (0x401e - dest->exp);\r\nif (dest->mant.m32[0] += mask)\r\nbreak;\r\ndest->mant.m32[0] = 0x80000000;\r\ndest->exp++;\r\nbreak;\r\ncase 0x401f ... 0x403e:\r\nmask = 1 << (0x403e - dest->exp);\r\nif (dest->mant.m32[1] += mask)\r\nbreak;\r\nif (dest->mant.m32[0] += 1)\r\nbreak;\r\ndest->mant.m32[0] = 0x80000000;\r\ndest->exp++;\r\nbreak;\r\n}\r\n}\r\nstatic struct fp_ext *\r\nmodrem_kernel(struct fp_ext *dest, struct fp_ext *src, int mode)\r\n{\r\nstruct fp_ext tmp;\r\nfp_dyadic_check(dest, src);\r\nif (IS_INF(dest) || IS_ZERO(src)) {\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_ZERO(dest) || IS_INF(src))\r\nreturn dest;\r\nfp_copy_ext(&tmp, dest);\r\nfp_fdiv(&tmp, src);\r\nfp_roundint(&tmp, mode);\r\nfp_fmul(&tmp, src);\r\nfp_fsub(dest, &tmp);\r\nfp_set_quotient((dest->mant.m64 & 0x7f) | (dest->sign << 7));\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fmod(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fmod\n");\r\nreturn modrem_kernel(dest, src, FPCR_ROUND_RZ);\r\n}\r\nstruct fp_ext *\r\nfp_frem(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "frem\n");\r\nreturn modrem_kernel(dest, src, FPCR_ROUND_RN);\r\n}\r\nstruct fp_ext *\r\nfp_fint(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fint\n");\r\nfp_copy_ext(dest, src);\r\nfp_roundint(dest, FPDATA->rnd);\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fintrz(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\ndprint(PINSTR, "fintrz\n");\r\nfp_copy_ext(dest, src);\r\nfp_roundint(dest, FPCR_ROUND_RZ);\r\nreturn dest;\r\n}\r\nstruct fp_ext *\r\nfp_fscale(struct fp_ext *dest, struct fp_ext *src)\r\n{\r\nint scale, oldround;\r\ndprint(PINSTR, "fscale\n");\r\nfp_dyadic_check(dest, src);\r\nif (IS_INF(src)) {\r\nfp_set_nan(dest);\r\nreturn dest;\r\n}\r\nif (IS_INF(dest))\r\nreturn dest;\r\nif (IS_ZERO(src) || IS_ZERO(dest))\r\nreturn dest;\r\nif (src->exp >= 0x400c) {\r\nfp_set_ovrflw(dest);\r\nreturn dest;\r\n}\r\noldround = FPDATA->rnd;\r\nFPDATA->rnd = FPCR_ROUND_RZ;\r\nscale = fp_conv_ext2long(src);\r\nFPDATA->rnd = oldround;\r\nscale += dest->exp;\r\nif (scale >= 0x7fff) {\r\nfp_set_ovrflw(dest);\r\n} else if (scale <= 0) {\r\nfp_set_sr(FPSR_EXC_UNFL);\r\nfp_denormalize(dest, -scale);\r\n} else\r\ndest->exp = scale;\r\nreturn dest;\r\n}
