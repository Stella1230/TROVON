acpi_status acpi_ut_initialize_interfaces(void)\r\n{\r\nu32 i;\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\r\nacpi_gbl_supported_interfaces = acpi_default_supported_interfaces;\r\nfor (i = 0;\r\ni < (ACPI_ARRAY_LENGTH(acpi_default_supported_interfaces) - 1);\r\ni++) {\r\nacpi_default_supported_interfaces[i].next =\r\n&acpi_default_supported_interfaces[(acpi_size) i + 1];\r\n}\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_ut_interface_terminate(void)\r\n{\r\nstruct acpi_interface_info *next_interface;\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\r\nnext_interface = acpi_gbl_supported_interfaces;\r\nwhile (next_interface) {\r\nacpi_gbl_supported_interfaces = next_interface->next;\r\nif (next_interface->flags & ACPI_OSI_DYNAMIC) {\r\nACPI_FREE(next_interface->name);\r\nACPI_FREE(next_interface);\r\n}\r\nnext_interface = acpi_gbl_supported_interfaces;\r\n}\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\n}\r\nacpi_status acpi_ut_install_interface(acpi_string interface_name)\r\n{\r\nstruct acpi_interface_info *interface_info;\r\ninterface_info =\r\nACPI_ALLOCATE_ZEROED(sizeof(struct acpi_interface_info));\r\nif (!interface_info) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\ninterface_info->name =\r\nACPI_ALLOCATE_ZEROED(ACPI_STRLEN(interface_name) + 1);\r\nif (!interface_info->name) {\r\nACPI_FREE(interface_info);\r\nreturn (AE_NO_MEMORY);\r\n}\r\nACPI_STRCPY(interface_info->name, interface_name);\r\ninterface_info->flags = ACPI_OSI_DYNAMIC;\r\ninterface_info->next = acpi_gbl_supported_interfaces;\r\nacpi_gbl_supported_interfaces = interface_info;\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_ut_remove_interface(acpi_string interface_name)\r\n{\r\nstruct acpi_interface_info *previous_interface;\r\nstruct acpi_interface_info *next_interface;\r\nprevious_interface = next_interface = acpi_gbl_supported_interfaces;\r\nwhile (next_interface) {\r\nif (!ACPI_STRCMP(interface_name, next_interface->name)) {\r\nif (next_interface->flags & ACPI_OSI_DYNAMIC) {\r\nif (previous_interface == next_interface) {\r\nacpi_gbl_supported_interfaces =\r\nnext_interface->next;\r\n} else {\r\nprevious_interface->next =\r\nnext_interface->next;\r\n}\r\nACPI_FREE(next_interface->name);\r\nACPI_FREE(next_interface);\r\n} else {\r\nif (next_interface->flags & ACPI_OSI_INVALID) {\r\nreturn (AE_NOT_EXIST);\r\n}\r\nnext_interface->flags |= ACPI_OSI_INVALID;\r\n}\r\nreturn (AE_OK);\r\n}\r\nprevious_interface = next_interface;\r\nnext_interface = next_interface->next;\r\n}\r\nreturn (AE_NOT_EXIST);\r\n}\r\nstruct acpi_interface_info *acpi_ut_get_interface(acpi_string interface_name)\r\n{\r\nstruct acpi_interface_info *next_interface;\r\nnext_interface = acpi_gbl_supported_interfaces;\r\nwhile (next_interface) {\r\nif (!ACPI_STRCMP(interface_name, next_interface->name)) {\r\nreturn (next_interface);\r\n}\r\nnext_interface = next_interface->next;\r\n}\r\nreturn (NULL);\r\n}\r\nacpi_status acpi_ut_osi_implementation(struct acpi_walk_state * walk_state)\r\n{\r\nunion acpi_operand_object *string_desc;\r\nunion acpi_operand_object *return_desc;\r\nstruct acpi_interface_info *interface_info;\r\nacpi_interface_handler interface_handler;\r\nu32 return_value;\r\nACPI_FUNCTION_TRACE(ut_osi_implementation);\r\nstring_desc = walk_state->arguments[0].object;\r\nif (!string_desc || (string_desc->common.type != ACPI_TYPE_STRING)) {\r\nreturn_ACPI_STATUS(AE_TYPE);\r\n}\r\nreturn_desc = acpi_ut_create_internal_object(ACPI_TYPE_INTEGER);\r\nif (!return_desc) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nreturn_value = 0;\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex, ACPI_WAIT_FOREVER);\r\ninterface_info = acpi_ut_get_interface(string_desc->string.pointer);\r\nif (interface_info && !(interface_info->flags & ACPI_OSI_INVALID)) {\r\nif (interface_info->value > acpi_gbl_osi_data) {\r\nacpi_gbl_osi_data = interface_info->value;\r\n}\r\nreturn_value = ACPI_UINT32_MAX;\r\n}\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\ninterface_handler = acpi_gbl_interface_handler;\r\nif (interface_handler) {\r\nreturn_value =\r\ninterface_handler(string_desc->string.pointer,\r\nreturn_value);\r\n}\r\nACPI_DEBUG_PRINT_RAW((ACPI_DB_INFO,\r\n"ACPI: BIOS _OSI(\"%s\") is %ssupported\n",\r\nstring_desc->string.pointer,\r\nreturn_value == 0 ? "not " : ""));\r\nreturn_desc->integer.value = return_value;\r\nwalk_state->return_desc = return_desc;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
