const char *get_system_type(void)\r\n{\r\nreturn "PowerTV";\r\n}\r\nvoid __init plat_mem_setup(void)\r\n{\r\npanic_on_oops = 1;\r\nregister_panic_notifier();\r\n#if 0\r\nmips_pcibios_init();\r\n#endif\r\nmips_reboot_setup();\r\n}\r\nstatic void register_panic_notifier()\r\n{\r\nstatic struct notifier_block panic_notifier = {\r\n.notifier_call = panic_handler,\r\n.next = NULL,\r\n.priority = INT_MAX\r\n};\r\natomic_notifier_chain_register(&panic_notifier_list, &panic_notifier);\r\n}\r\nstatic int panic_handler(struct notifier_block *notifier_block,\r\nunsigned long event, void *cause_string)\r\n{\r\nstruct pt_regs my_regs;\r\n{\r\nunsigned long at, v0, v1;\r\n__asm__ __volatile__ (\r\n".set noat\n"\r\nLONG_S_ "$at, %[at]\n"\r\nLONG_S_ "$2, %[v0]\n"\r\nLONG_S_ "$3, %[v1]\n"\r\n:\r\n[at] "=m" (at),\r\n[v0] "=m" (v0),\r\n[v1] "=m" (v1)\r\n:\r\n: "at"\r\n);\r\n__asm__ __volatile__ (\r\n".set noat\n"\r\n"move $at, %[pt_regs]\n"\r\nLONG_S_ "$4, " VAL(PT_R4) "($at)\n"\r\nLONG_S_ "$5, " VAL(PT_R5) "($at)\n"\r\nLONG_S_ "$6, " VAL(PT_R6) "($at)\n"\r\nLONG_S_ "$7, " VAL(PT_R7) "($at)\n"\r\nLONG_S_ "$8, " VAL(PT_R8) "($at)\n"\r\nLONG_S_ "$9, " VAL(PT_R9) "($at)\n"\r\nLONG_S_ "$10, " VAL(PT_R10) "($at)\n"\r\nLONG_S_ "$11, " VAL(PT_R11) "($at)\n"\r\nLONG_S_ "$12, " VAL(PT_R12) "($at)\n"\r\nLONG_S_ "$13, " VAL(PT_R13) "($at)\n"\r\nLONG_S_ "$14, " VAL(PT_R14) "($at)\n"\r\nLONG_S_ "$15, " VAL(PT_R15) "($at)\n"\r\nLONG_S_ "$16, " VAL(PT_R16) "($at)\n"\r\nLONG_S_ "$17, " VAL(PT_R17) "($at)\n"\r\nLONG_S_ "$18, " VAL(PT_R18) "($at)\n"\r\nLONG_S_ "$19, " VAL(PT_R19) "($at)\n"\r\nLONG_S_ "$20, " VAL(PT_R20) "($at)\n"\r\nLONG_S_ "$21, " VAL(PT_R21) "($at)\n"\r\nLONG_S_ "$22, " VAL(PT_R22) "($at)\n"\r\nLONG_S_ "$23, " VAL(PT_R23) "($at)\n"\r\nLONG_S_ "$24, " VAL(PT_R24) "($at)\n"\r\nLONG_S_ "$25, " VAL(PT_R25) "($at)\n"\r\nLONG_S_ "$26, " VAL(PT_R26) "($at)\n"\r\nLONG_S_ "$27, " VAL(PT_R27) "($at)\n"\r\nLONG_S_ "$gp, " VAL(PT_R28) "($at)\n"\r\nLONG_S_ "$sp, " VAL(PT_R29) "($at)\n"\r\nLONG_S_ "$fp, " VAL(PT_R30) "($at)\n"\r\nLONG_S_ "$ra, " VAL(PT_R31) "($at)\n"\r\nLONG_L_ "$8, %[at]\n"\r\nLONG_S_ "$8, " VAL(PT_R1) "($at)\n"\r\nLONG_L_ "$8, %[v0]\n"\r\nLONG_S_ "$8, " VAL(PT_R2) "($at)\n"\r\nLONG_L_ "$8, %[v1]\n"\r\nLONG_S_ "$8, " VAL(PT_R3) "($at)\n"\r\n:\r\n:\r\n[at] "m" (at),\r\n[v0] "m" (v0),\r\n[v1] "m" (v1),\r\n[pt_regs] "r" (&my_regs)\r\n: "at", "t0"\r\n);\r\n__asm__ __volatile__ (\r\n".set noat\n"\r\n"1:\n"\r\nPTR_LA_ "$at, 1b\n"\r\nLONG_S_ "$at, %[cp0_epc]\n"\r\n:\r\n[cp0_epc] "=m" (my_regs.cp0_epc)\r\n:\r\n: "at"\r\n);\r\nmy_regs.cp0_cause = read_c0_cause();\r\nmy_regs.cp0_status = read_c0_status();\r\n}\r\npr_crit("I'm feeling a bit sleepy. hmmmmm... perhaps a nap would... "\r\n"zzzz... \n");\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int rfmac_param(char *p)\r\n{\r\nu8 *q;\r\nbool is_high_nibble;\r\nint c;\r\nif (*p == '0' && *(p+1) == 'x')\r\np += 2;\r\nq = rfmac;\r\nis_high_nibble = true;\r\nfor (c = (unsigned char) *p++;\r\nisxdigit(c) && q - rfmac < ETH_ALEN;\r\nc = (unsigned char) *p++) {\r\nint nibble;\r\nnibble = (isdigit(c) ? (c - '0') :\r\n(isupper(c) ? c - 'A' + 10 : c - 'a' + 10));\r\nif (is_high_nibble)\r\n*q = nibble << 4;\r\nelse\r\n*q++ |= nibble;\r\nis_high_nibble = !is_high_nibble;\r\n}\r\nhave_rfmac = (c == '\0' && q - rfmac == ETH_ALEN);\r\nreturn 0;\r\n}\r\nvoid platform_random_ether_addr(u8 addr[ETH_ALEN])\r\n{\r\nconst int num_random_bytes = 2;\r\nconst unsigned char non_sciatl_oui_bits = 0xc0u;\r\nconst unsigned char mac_addr_locally_managed = (1 << 1);\r\nif (!have_rfmac) {\r\npr_warning("rfmac not available on command line; "\r\n"generating random MAC address\n");\r\neth_random_addr(addr);\r\n}\r\nelse {\r\nint i;\r\naddr[0] = non_sciatl_oui_bits | mac_addr_locally_managed;\r\nget_random_bytes(&addr[1], num_random_bytes);\r\nfor (i = 1 + num_random_bytes; i < ETH_ALEN; i++)\r\naddr[i] = rfmac[i];\r\n}\r\n}
