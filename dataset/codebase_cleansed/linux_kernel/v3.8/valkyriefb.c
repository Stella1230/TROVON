static int valkyriefb_set_par(struct fb_info *info)\r\n{\r\nstruct fb_info_valkyrie *p = (struct fb_info_valkyrie *) info;\r\nvolatile struct valkyrie_regs __iomem *valkyrie_regs = p->valkyrie_regs;\r\nstruct fb_par_valkyrie *par = info->par;\r\nstruct valkyrie_regvals *init;\r\nint err;\r\nif ((err = valkyrie_var_to_par(&info->var, par, info)))\r\nreturn err;\r\nvalkyrie_par_to_fix(par, &info->fix);\r\nout_8(&valkyrie_regs->status.r, 0);\r\nudelay(100);\r\ninit = par->init;\r\nout_8(&valkyrie_regs->mode.r, init->mode | 0x80);\r\nout_8(&valkyrie_regs->depth.r, par->cmode + 3);\r\nset_valkyrie_clock(init->clock_params);\r\nudelay(100);\r\nout_8(&valkyrie_regs->mode.r, init->mode);\r\nreturn 0;\r\n}\r\nstatic inline int valkyrie_par_to_var(struct fb_par_valkyrie *par,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nreturn mac_vmode_to_var(par->vmode, par->cmode, var);\r\n}\r\nstatic int\r\nvalkyriefb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nint err;\r\nstruct fb_par_valkyrie par;\r\nif ((err = valkyrie_var_to_par(var, &par, info)))\r\nreturn err;\r\nvalkyrie_par_to_var(&par, var);\r\nreturn 0;\r\n}\r\nstatic int valkyriefb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct fb_info_valkyrie *p = (struct fb_info_valkyrie *) info;\r\nstruct fb_par_valkyrie *par = info->par;\r\nstruct valkyrie_regvals *init = par->init;\r\nif (init == NULL)\r\nreturn 1;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nout_8(&p->valkyrie_regs->mode.r, init->mode);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nreturn 1;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nout_8(&p->valkyrie_regs->mode.r, init->mode | 0x40);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nout_8(&p->valkyrie_regs->mode.r, 0x66);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int valkyriefb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct fb_info_valkyrie *p = (struct fb_info_valkyrie *) info;\r\nvolatile struct cmap_regs __iomem *cmap_regs = p->cmap_regs;\r\nstruct fb_par_valkyrie *par = info->par;\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nout_8(&p->cmap_regs->addr, regno);\r\nudelay(1);\r\nout_8(&cmap_regs->lut, red);\r\nout_8(&cmap_regs->lut, green);\r\nout_8(&cmap_regs->lut, blue);\r\nif (regno < 16 && par->cmode == CMODE_16)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n(regno << 10) | (regno << 5) | regno;\r\nreturn 0;\r\n}\r\nstatic inline int valkyrie_vram_reqd(int video_mode, int color_mode)\r\n{\r\nint pitch;\r\nstruct valkyrie_regvals *init = valkyrie_reg_init[video_mode-1];\r\nif ((pitch = init->pitch[color_mode]) == 0)\r\npitch = 2 * init->pitch[0];\r\nreturn init->vres * pitch;\r\n}\r\nstatic void set_valkyrie_clock(unsigned char *params)\r\n{\r\nstruct adb_request req;\r\nint i;\r\n#ifdef CONFIG_ADB_CUDA\r\nfor (i = 0; i < 3; ++i) {\r\ncuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC,\r\n0x50, i + 1, params[i]);\r\nwhile (!req.complete)\r\ncuda_poll();\r\n}\r\n#endif\r\n}\r\nstatic void __init valkyrie_choose_mode(struct fb_info_valkyrie *p)\r\n{\r\np->sense = read_valkyrie_sense(p);\r\nprintk(KERN_INFO "Monitor sense value = 0x%x\n", p->sense);\r\n#if !defined(CONFIG_MAC) && defined(CONFIG_NVRAM)\r\nif (default_vmode == VMODE_NVRAM) {\r\ndefault_vmode = nvram_read_byte(NV_VMODE);\r\nif (default_vmode <= 0\r\n|| default_vmode > VMODE_MAX\r\n|| !valkyrie_reg_init[default_vmode - 1])\r\ndefault_vmode = VMODE_CHOOSE;\r\n}\r\n#endif\r\nif (default_vmode == VMODE_CHOOSE)\r\ndefault_vmode = mac_map_monitor_sense(p->sense);\r\nif (!valkyrie_reg_init[default_vmode - 1])\r\ndefault_vmode = VMODE_640_480_67;\r\n#if !defined(CONFIG_MAC) && defined(CONFIG_NVRAM)\r\nif (default_cmode == CMODE_NVRAM)\r\ndefault_cmode = nvram_read_byte(NV_CMODE);\r\n#endif\r\nif (default_cmode < CMODE_8 || default_cmode > CMODE_16\r\n|| valkyrie_reg_init[default_vmode-1]->pitch[default_cmode] == 0\r\n|| valkyrie_vram_reqd(default_vmode, default_cmode) > p->total_vram)\r\ndefault_cmode = CMODE_8;\r\nprintk(KERN_INFO "using video mode %d and color mode %d.\n",\r\ndefault_vmode, default_cmode);\r\n}\r\nint __init valkyriefb_init(void)\r\n{\r\nstruct fb_info_valkyrie *p;\r\nunsigned long frame_buffer_phys, cmap_regs_phys, flags;\r\nint err;\r\nchar *option = NULL;\r\nif (fb_get_options("valkyriefb", &option))\r\nreturn -ENODEV;\r\nvalkyriefb_setup(option);\r\n#ifdef CONFIG_MAC\r\nif (!MACH_IS_MAC)\r\nreturn -ENODEV;\r\nif (!(mac_bi_data.id == MAC_MODEL_Q630\r\n|| mac_bi_data.id == MAC_MODEL_P588))\r\nreturn -ENODEV;\r\nframe_buffer_phys = 0xf9000000;\r\ncmap_regs_phys = 0x50f24000;\r\nflags = IOMAP_NOCACHE_SER;\r\n#else\r\n{\r\nstruct device_node *dp;\r\nstruct resource r;\r\ndp = of_find_node_by_name(NULL, "valkyrie");\r\nif (dp == 0)\r\nreturn 0;\r\nif (of_address_to_resource(dp, 0, &r)) {\r\nprintk(KERN_ERR "can't find address for valkyrie\n");\r\nreturn 0;\r\n}\r\nframe_buffer_phys = r.start;\r\ncmap_regs_phys = r.start + 0x304000;\r\nflags = _PAGE_WRITETHRU;\r\n}\r\n#endif\r\np = kzalloc(sizeof(*p), GFP_ATOMIC);\r\nif (p == 0)\r\nreturn -ENOMEM;\r\nif (!request_mem_region(frame_buffer_phys, 0x100000, "valkyriefb")) {\r\nkfree(p);\r\nreturn 0;\r\n}\r\np->total_vram = 0x100000;\r\np->frame_buffer_phys = frame_buffer_phys;\r\np->frame_buffer = __ioremap(frame_buffer_phys, p->total_vram, flags);\r\np->cmap_regs_phys = cmap_regs_phys;\r\np->cmap_regs = ioremap(p->cmap_regs_phys, 0x1000);\r\np->valkyrie_regs_phys = cmap_regs_phys+0x6000;\r\np->valkyrie_regs = ioremap(p->valkyrie_regs_phys, 0x1000);\r\nerr = -ENOMEM;\r\nif (p->frame_buffer == NULL || p->cmap_regs == NULL\r\n|| p->valkyrie_regs == NULL) {\r\nprintk(KERN_ERR "valkyriefb: couldn't map resources\n");\r\ngoto out_free;\r\n}\r\nvalkyrie_choose_mode(p);\r\nmac_vmode_to_var(default_vmode, default_cmode, &p->info.var);\r\nerr = valkyrie_init_info(&p->info, p);\r\nif (err < 0)\r\ngoto out_free;\r\nvalkyrie_init_fix(&p->info.fix, p);\r\nif (valkyriefb_set_par(&p->info))\r\nprintk(KERN_ERR "valkyriefb: can't set default video mode\n");\r\nif ((err = register_framebuffer(&p->info)) != 0)\r\ngoto out_cmap_free;\r\nprintk(KERN_INFO "fb%d: valkyrie frame buffer device\n", p->info.node);\r\nreturn 0;\r\nout_cmap_free:\r\nfb_dealloc_cmap(&p->info.cmap);\r\nout_free:\r\nif (p->frame_buffer)\r\niounmap(p->frame_buffer);\r\nif (p->cmap_regs)\r\niounmap(p->cmap_regs);\r\nif (p->valkyrie_regs)\r\niounmap(p->valkyrie_regs);\r\nkfree(p);\r\nreturn err;\r\n}\r\nstatic int read_valkyrie_sense(struct fb_info_valkyrie *p)\r\n{\r\nint sense, in;\r\nout_8(&p->valkyrie_regs->msense.r, 0);\r\n__delay(20000);\r\nsense = ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x70) << 4;\r\nout_8(&p->valkyrie_regs->msense.r, 4);\r\n__delay(20000);\r\nsense |= ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x30);\r\nout_8(&p->valkyrie_regs->msense.r, 2);\r\n__delay(20000);\r\nsense |= ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x40) >> 3;\r\nsense |= (in & 0x10) >> 2;\r\nout_8(&p->valkyrie_regs->msense.r, 1);\r\n__delay(20000);\r\nsense |= ((in = in_8(&p->valkyrie_regs->msense.r)) & 0x60) >> 5;\r\nout_8(&p->valkyrie_regs->msense.r, 7);\r\nreturn sense;\r\n}\r\nstatic int valkyrie_var_to_par(struct fb_var_screeninfo *var,\r\nstruct fb_par_valkyrie *par, const struct fb_info *fb_info)\r\n{\r\nint vmode, cmode;\r\nstruct valkyrie_regvals *init;\r\nstruct fb_info_valkyrie *p = (struct fb_info_valkyrie *) fb_info;\r\nif (mac_var_to_vmode(var, &vmode, &cmode) != 0) {\r\nprintk(KERN_ERR "valkyriefb: can't do %dx%dx%d.\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (vmode < 1 || vmode > VMODE_MAX || !valkyrie_reg_init[vmode-1]) {\r\nprintk(KERN_ERR "valkyriefb: vmode %d not valid.\n", vmode);\r\nreturn -EINVAL;\r\n}\r\nif (cmode != CMODE_8 && cmode != CMODE_16) {\r\nprintk(KERN_ERR "valkyriefb: cmode %d not valid.\n", cmode);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres_virtual > var->xres || var->yres_virtual > var->yres\r\n|| var->xoffset != 0 || var->yoffset != 0) {\r\nreturn -EINVAL;\r\n}\r\ninit = valkyrie_reg_init[vmode-1];\r\nif (init->pitch[cmode] == 0) {\r\nprintk(KERN_ERR "valkyriefb: vmode %d does not support "\r\n"cmode %d.\n", vmode, cmode);\r\nreturn -EINVAL;\r\n}\r\nif (valkyrie_vram_reqd(vmode, cmode) > p->total_vram) {\r\nprintk(KERN_ERR "valkyriefb: not enough ram for vmode %d, "\r\n"cmode %d.\n", vmode, cmode);\r\nreturn -EINVAL;\r\n}\r\npar->vmode = vmode;\r\npar->cmode = cmode;\r\npar->init = init;\r\npar->xres = var->xres;\r\npar->yres = var->yres;\r\npar->vxres = par->xres;\r\npar->vyres = par->yres;\r\nreturn 0;\r\n}\r\nstatic void valkyrie_init_fix(struct fb_fix_screeninfo *fix, struct fb_info_valkyrie *p)\r\n{\r\nmemset(fix, 0, sizeof(*fix));\r\nstrcpy(fix->id, "valkyrie");\r\nfix->mmio_start = p->valkyrie_regs_phys;\r\nfix->mmio_len = sizeof(struct valkyrie_regs);\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->smem_start = p->frame_buffer_phys + 0x1000;\r\nfix->smem_len = p->total_vram;\r\nfix->type_aux = 0;\r\nfix->ywrapstep = 0;\r\nfix->ypanstep = 0;\r\nfix->xpanstep = 0;\r\n}\r\nstatic void valkyrie_par_to_fix(struct fb_par_valkyrie *par,\r\nstruct fb_fix_screeninfo *fix)\r\n{\r\nfix->smem_len = valkyrie_vram_reqd(par->vmode, par->cmode);\r\nfix->visual = (par->cmode == CMODE_8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\nfix->line_length = par->vxres << par->cmode;\r\n}\r\nstatic int __init valkyrie_init_info(struct fb_info *info,\r\nstruct fb_info_valkyrie *p)\r\n{\r\ninfo->fbops = &valkyriefb_ops;\r\ninfo->screen_base = p->frame_buffer + 0x1000;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->pseudo_palette = p->pseudo_palette;\r\ninfo->par = &p->par;\r\nreturn fb_alloc_cmap(&info->cmap, 256, 0);\r\n}\r\nint __init valkyriefb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "vmode:", 6)) {\r\nint vmode = simple_strtoul(this_opt+6, NULL, 0);\r\nif (vmode > 0 && vmode <= VMODE_MAX)\r\ndefault_vmode = vmode;\r\n}\r\nelse if (!strncmp(this_opt, "cmode:", 6)) {\r\nint depth = simple_strtoul(this_opt+6, NULL, 0);\r\nswitch (depth) {\r\ncase 8:\r\ndefault_cmode = CMODE_8;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\ndefault_cmode = CMODE_16;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
