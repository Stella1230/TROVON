static int vx_modify_board_clock(struct vx_core *chip, int sync)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_MODIFY_CLOCK);\r\nif (sync)\r\nrmh.Cmd[0] |= CMD_MODIFY_CLOCK_S_BIT;\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_modify_board_inputs(struct vx_core *chip)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_RESYNC_AUDIO_INPUTS);\r\nrmh.Cmd[0] |= 1 << 0;\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_read_one_cbit(struct vx_core *chip, int index)\r\n{\r\nunsigned long flags;\r\nint val;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif (chip->type >= VX_TYPE_VXPOCKET) {\r\nvx_outb(chip, CSUER, 1);\r\nvx_outb(chip, RUER, index & XX_UER_CBITS_OFFSET_MASK);\r\nval = (vx_inb(chip, RUER) >> 7) & 0x01;\r\n} else {\r\nvx_outl(chip, CSUER, 1);\r\nvx_outl(chip, RUER, index & XX_UER_CBITS_OFFSET_MASK);\r\nval = (vx_inl(chip, RUER) >> 7) & 0x01;\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn val;\r\n}\r\nstatic void vx_write_one_cbit(struct vx_core *chip, int index, int val)\r\n{\r\nunsigned long flags;\r\nval = !!val;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif (vx_is_pcmcia(chip)) {\r\nvx_outb(chip, CSUER, 0);\r\nvx_outb(chip, RUER, (val << 7) | (index & XX_UER_CBITS_OFFSET_MASK));\r\n} else {\r\nvx_outl(chip, CSUER, 0);\r\nvx_outl(chip, RUER, (val << 7) | (index & XX_UER_CBITS_OFFSET_MASK));\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int vx_read_uer_status(struct vx_core *chip, unsigned int *mode)\r\n{\r\nint val, freq;\r\nfreq = 0;\r\nif (vx_is_pcmcia(chip))\r\nval = vx_inb(chip, CSUER);\r\nelse\r\nval = vx_inl(chip, CSUER);\r\nif (val < 0)\r\nreturn val;\r\nif (val & VX_SUER_CLOCK_PRESENT_MASK) {\r\nswitch (val & VX_SUER_FREQ_MASK) {\r\ncase VX_SUER_FREQ_32KHz_MASK:\r\nfreq = 32000;\r\nbreak;\r\ncase VX_SUER_FREQ_44KHz_MASK:\r\nfreq = 44100;\r\nbreak;\r\ncase VX_SUER_FREQ_48KHz_MASK:\r\nfreq = 48000;\r\nbreak;\r\n}\r\n}\r\nif (val & VX_SUER_DATA_PRESENT_MASK)\r\n*mode = vx_read_one_cbit(chip, 0) ?\r\nVX_UER_MODE_PROFESSIONAL : VX_UER_MODE_CONSUMER;\r\nelse\r\n*mode = VX_UER_MODE_NOT_PRESENT;\r\nreturn freq;\r\n}\r\nstatic int vx_calc_clock_from_freq(struct vx_core *chip, int freq)\r\n{\r\nint hexfreq;\r\nif (snd_BUG_ON(freq <= 0))\r\nreturn 0;\r\nhexfreq = (28224000 * 10) / freq;\r\nhexfreq = (hexfreq + 5) / 10;\r\nif (snd_BUG_ON(hexfreq <= 0x00000200))\r\nreturn 0;\r\nif (hexfreq <= 0x03ff)\r\nreturn hexfreq - 0x00000201;\r\nif (hexfreq <= 0x07ff)\r\nreturn (hexfreq / 2) - 1;\r\nif (hexfreq <= 0x0fff)\r\nreturn (hexfreq / 4) + 0x000001ff;\r\nreturn 0x5fe;\r\n}\r\nstatic void vx_change_clock_source(struct vx_core *chip, int source)\r\n{\r\nunsigned long flags;\r\nvx_toggle_dac_mute(chip, 1);\r\nspin_lock_irqsave(&chip->lock, flags);\r\nchip->ops->set_clock_source(chip, source);\r\nchip->clock_source = source;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nvx_toggle_dac_mute(chip, 0);\r\n}\r\nvoid vx_set_internal_clock(struct vx_core *chip, unsigned int freq)\r\n{\r\nint clock;\r\nunsigned long flags;\r\nclock = vx_calc_clock_from_freq(chip, freq);\r\nsnd_printdd(KERN_DEBUG "set internal clock to 0x%x from freq %d\n", clock, freq);\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif (vx_is_pcmcia(chip)) {\r\nvx_outb(chip, HIFREQ, (clock >> 8) & 0x0f);\r\nvx_outb(chip, LOFREQ, clock & 0xff);\r\n} else {\r\nvx_outl(chip, HIFREQ, (clock >> 8) & 0x0f);\r\nvx_outl(chip, LOFREQ, clock & 0xff);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nvoid vx_set_iec958_status(struct vx_core *chip, unsigned int bits)\r\n{\r\nint i;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn;\r\nfor (i = 0; i < 32; i++)\r\nvx_write_one_cbit(chip, i, bits & (1 << i));\r\n}\r\nint vx_set_clock(struct vx_core *chip, unsigned int freq)\r\n{\r\nint src_changed = 0;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn 0;\r\nvx_sync_audio_source(chip);\r\nif (chip->clock_mode == VX_CLOCK_MODE_EXTERNAL ||\r\n(chip->clock_mode == VX_CLOCK_MODE_AUTO &&\r\nchip->audio_source == VX_AUDIO_SRC_DIGITAL)) {\r\nif (chip->clock_source != UER_SYNC) {\r\nvx_change_clock_source(chip, UER_SYNC);\r\nmdelay(6);\r\nsrc_changed = 1;\r\n}\r\n} else if (chip->clock_mode == VX_CLOCK_MODE_INTERNAL ||\r\n(chip->clock_mode == VX_CLOCK_MODE_AUTO &&\r\nchip->audio_source != VX_AUDIO_SRC_DIGITAL)) {\r\nif (chip->clock_source != INTERNAL_QUARTZ) {\r\nvx_change_clock_source(chip, INTERNAL_QUARTZ);\r\nsrc_changed = 1;\r\n}\r\nif (chip->freq == freq)\r\nreturn 0;\r\nvx_set_internal_clock(chip, freq);\r\nif (src_changed)\r\nvx_modify_board_inputs(chip);\r\n}\r\nif (chip->freq == freq)\r\nreturn 0;\r\nchip->freq = freq;\r\nvx_modify_board_clock(chip, 1);\r\nreturn 0;\r\n}\r\nint vx_change_frequency(struct vx_core *chip)\r\n{\r\nint freq;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn 0;\r\nif (chip->clock_source == INTERNAL_QUARTZ)\r\nreturn 0;\r\nfreq = vx_read_uer_status(chip, &chip->uer_detected);\r\nif (freq < 0)\r\nreturn freq;\r\nif (freq == 48000 || freq == 44100 || freq == 32000)\r\nchip->freq_detected = freq;\r\nreturn 0;\r\n}
