static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct s5k6aa, ctrls.handler)->sd;\r\n}\r\nstatic inline struct s5k6aa *to_s5k6aa(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct s5k6aa, sd);\r\n}\r\nstatic void s5k6aa_presets_data_init(struct s5k6aa *s5k6aa)\r\n{\r\nstruct s5k6aa_preset *preset = &s5k6aa->presets[0];\r\nint i;\r\nfor (i = 0; i < S5K6AA_MAX_PRESETS; i++) {\r\npreset->mbus_fmt.width = S5K6AA_OUT_WIDTH_DEF;\r\npreset->mbus_fmt.height = S5K6AA_OUT_HEIGHT_DEF;\r\npreset->mbus_fmt.code = s5k6aa_formats[0].code;\r\npreset->index = i;\r\npreset->clk_id = 0;\r\npreset++;\r\n}\r\ns5k6aa->fiv = &s5k6aa_intervals[S5K6AA_INTERVAL_DEF_INDEX];\r\ns5k6aa->preset = &s5k6aa->presets[0];\r\n}\r\nstatic int s5k6aa_i2c_read(struct i2c_client *client, u16 addr, u16 *val)\r\n{\r\nu8 wbuf[2] = {addr >> 8, addr & 0xFF};\r\nstruct i2c_msg msg[2];\r\nu8 rbuf[2];\r\nint ret;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 2;\r\nmsg[0].buf = wbuf;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = 2;\r\nmsg[1].buf = rbuf;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\n*val = be16_to_cpu(*((u16 *)rbuf));\r\nv4l2_dbg(3, debug, client, "i2c_read: 0x%04X : 0x%04x\n", addr, *val);\r\nreturn ret == 2 ? 0 : ret;\r\n}\r\nstatic int s5k6aa_i2c_write(struct i2c_client *client, u16 addr, u16 val)\r\n{\r\nu8 buf[4] = {addr >> 8, addr & 0xFF, val >> 8, val & 0xFF};\r\nint ret = i2c_master_send(client, buf, 4);\r\nv4l2_dbg(3, debug, client, "i2c_write: 0x%04X : 0x%04x\n", addr, val);\r\nreturn ret == 4 ? 0 : ret;\r\n}\r\nstatic int s5k6aa_write(struct i2c_client *c, u16 addr, u16 val)\r\n{\r\nint ret = s5k6aa_i2c_write(c, REG_CMDWR_ADDRL, addr);\r\nif (ret)\r\nreturn ret;\r\nreturn s5k6aa_i2c_write(c, REG_CMDBUF0_ADDR, val);\r\n}\r\nstatic int s5k6aa_read(struct i2c_client *client, u16 addr, u16 *val)\r\n{\r\nint ret = s5k6aa_i2c_write(client, REG_CMDRD_ADDRL, addr);\r\nif (ret)\r\nreturn ret;\r\nreturn s5k6aa_i2c_read(client, REG_CMDBUF0_ADDR, val);\r\n}\r\nstatic int s5k6aa_write_array(struct v4l2_subdev *sd,\r\nconst struct s5k6aa_regval *msg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu16 addr_incr = 0;\r\nint ret = 0;\r\nwhile (msg->addr != S5K6AA_TERM) {\r\nif (addr_incr != 2)\r\nret = s5k6aa_i2c_write(client, REG_CMDWR_ADDRL,\r\nmsg->addr);\r\nif (ret)\r\nbreak;\r\nret = s5k6aa_i2c_write(client, REG_CMDBUF0_ADDR, msg->val);\r\nif (ret)\r\nbreak;\r\naddr_incr = (msg + 1)->addr - msg->addr;\r\nmsg++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_set_ahb_address(struct i2c_client *client)\r\n{\r\nint ret = s5k6aa_i2c_write(client, AHB_MSB_ADDR_PTR, GEN_REG_OFFSH);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_i2c_write(client, REG_CMDRD_ADDRH, HOST_SWIF_OFFSH);\r\nif (ret)\r\nreturn ret;\r\nreturn s5k6aa_i2c_write(client, REG_CMDWR_ADDRH, HOST_SWIF_OFFSH);\r\n}\r\nstatic int s5k6aa_configure_pixel_clocks(struct s5k6aa *s5k6aa)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&s5k6aa->sd);\r\nunsigned long fmclk = s5k6aa->mclk_frequency / 1000;\r\nu16 status;\r\nint ret;\r\nif (WARN(fmclk < MIN_MCLK_FREQ_KHZ || fmclk > MAX_MCLK_FREQ_KHZ,\r\n"Invalid clock frequency: %ld\n", fmclk))\r\nreturn -EINVAL;\r\ns5k6aa->pclk_fmin = PCLK_FREQ_MIN;\r\ns5k6aa->pclk_fmax = PCLK_FREQ_MAX;\r\ns5k6aa->clk_fop = SYS_PLL_OUT_FREQ;\r\nret = s5k6aa_write(c, REG_I_INCLK_FREQ_H, fmclk >> 16);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_I_INCLK_FREQ_L, fmclk & 0xFFFF);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_I_USE_NPVI_CLOCKS, 1);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_I_OPCLK_4KHZ(0), s5k6aa->clk_fop);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_I_MIN_OUTRATE_4KHZ(0),\r\ns5k6aa->pclk_fmin);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_I_MAX_OUTRATE_4KHZ(0),\r\ns5k6aa->pclk_fmax);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_I_INIT_PARAMS_UPDATED, 1);\r\nif (!ret)\r\nret = s5k6aa_read(c, REG_I_ERROR_INFO, &status);\r\nreturn ret ? ret : (status ? -EINVAL : 0);\r\n}\r\nstatic int s5k6aa_set_mirror(struct s5k6aa *s5k6aa, int horiz_flip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nint index = s5k6aa->preset->index;\r\nunsigned int vflip = s5k6aa->ctrls.vflip->val ^ s5k6aa->inv_vflip;\r\nunsigned int flip = (horiz_flip ^ s5k6aa->inv_hflip) | (vflip << 1);\r\nreturn s5k6aa_write(client, REG_P_PREV_MIRROR(index), flip);\r\n}\r\nstatic int s5k6aa_set_awb(struct s5k6aa *s5k6aa, int awb)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&s5k6aa->sd);\r\nstruct s5k6aa_ctrls *ctrls = &s5k6aa->ctrls;\r\nu16 reg;\r\nint ret = s5k6aa_read(c, REG_DBG_AUTOALG_EN, &reg);\r\nif (!ret && !awb) {\r\nret = s5k6aa_write(c, REG_SF_RGAIN, ctrls->gain_red->val);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_SF_RGAIN_CHG, 1);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_write(c, REG_SF_GGAIN, ctrls->gain_green->val);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_SF_GGAIN_CHG, 1);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_write(c, REG_SF_BGAIN, ctrls->gain_blue->val);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_SF_BGAIN_CHG, 1);\r\n}\r\nif (!ret) {\r\nreg = awb ? reg | AALG_WB_EN_MASK : reg & ~AALG_WB_EN_MASK;\r\nret = s5k6aa_write(c, REG_DBG_AUTOALG_EN, reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_set_user_exposure(struct i2c_client *client, int exposure)\r\n{\r\nunsigned int time = exposure / 10;\r\nint ret = s5k6aa_write(client, REG_SF_USR_EXPOSURE_L, time & 0xffff);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_SF_USR_EXPOSURE_H, time >> 16);\r\nif (ret)\r\nreturn ret;\r\nreturn s5k6aa_write(client, REG_SF_USR_EXPOSURE_CHG, 1);\r\n}\r\nstatic int s5k6aa_set_user_gain(struct i2c_client *client, int gain)\r\n{\r\nint ret = s5k6aa_write(client, REG_SF_USR_TOT_GAIN, gain);\r\nif (ret)\r\nreturn ret;\r\nreturn s5k6aa_write(client, REG_SF_USR_TOT_GAIN_CHG, 1);\r\n}\r\nstatic int s5k6aa_set_auto_exposure(struct s5k6aa *s5k6aa, int value)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&s5k6aa->sd);\r\nunsigned int exp_time = s5k6aa->ctrls.exposure->val;\r\nu16 auto_alg;\r\nint ret = s5k6aa_read(c, REG_DBG_AUTOALG_EN, &auto_alg);\r\nif (ret)\r\nreturn ret;\r\nv4l2_dbg(1, debug, c, "man_exp: %d, auto_exp: %d, a_alg: 0x%x\n",\r\nexp_time, value, auto_alg);\r\nif (value == V4L2_EXPOSURE_AUTO) {\r\nauto_alg |= AALG_AE_EN_MASK | AALG_DIVLEI_EN_MASK;\r\n} else {\r\nret = s5k6aa_set_user_exposure(c, exp_time);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_set_user_gain(c, s5k6aa->ctrls.gain->val);\r\nif (ret)\r\nreturn ret;\r\nauto_alg &= ~(AALG_AE_EN_MASK | AALG_DIVLEI_EN_MASK);\r\n}\r\nreturn s5k6aa_write(c, REG_DBG_AUTOALG_EN, auto_alg);\r\n}\r\nstatic int s5k6aa_set_anti_flicker(struct s5k6aa *s5k6aa, int value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nu16 auto_alg;\r\nint ret;\r\nret = s5k6aa_read(client, REG_DBG_AUTOALG_EN, &auto_alg);\r\nif (ret)\r\nreturn ret;\r\nif (value == V4L2_CID_POWER_LINE_FREQUENCY_AUTO) {\r\nauto_alg |= AALG_FLICKER_EN_MASK;\r\n} else {\r\nauto_alg &= ~AALG_FLICKER_EN_MASK;\r\nret = s5k6aa_write(client, REG_SF_FLICKER_QUANT, value);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_write(client, REG_SF_FLICKER_QUANT_CHG, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn s5k6aa_write(client, REG_DBG_AUTOALG_EN, auto_alg);\r\n}\r\nstatic int s5k6aa_set_colorfx(struct s5k6aa *s5k6aa, int val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nstatic const struct v4l2_control colorfx[] = {\r\n{ V4L2_COLORFX_NONE, 0 },\r\n{ V4L2_COLORFX_BW, 1 },\r\n{ V4L2_COLORFX_NEGATIVE, 2 },\r\n{ V4L2_COLORFX_SEPIA, 3 },\r\n{ V4L2_COLORFX_SKY_BLUE, 4 },\r\n{ V4L2_COLORFX_SKETCH, 5 },\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(colorfx); i++) {\r\nif (colorfx[i].id == val)\r\nreturn s5k6aa_write(client, REG_G_SPEC_EFFECTS,\r\ncolorfx[i].value);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int s5k6aa_preview_config_status(struct i2c_client *client)\r\n{\r\nu16 error = 0;\r\nint ret = s5k6aa_read(client, REG_G_PREV_CFG_ERROR, &error);\r\nv4l2_dbg(1, debug, client, "error: 0x%x (%d)\n", error, ret);\r\nreturn ret ? ret : (error ? -EINVAL : 0);\r\n}\r\nstatic int s5k6aa_get_pixfmt_index(struct s5k6aa *s5k6aa,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(s5k6aa_formats); i++)\r\nif (mf->colorspace == s5k6aa_formats[i].colorspace &&\r\nmf->code == s5k6aa_formats[i].code)\r\nreturn i;\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_set_output_framefmt(struct s5k6aa *s5k6aa,\r\nstruct s5k6aa_preset *preset)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nint fmt_index = s5k6aa_get_pixfmt_index(s5k6aa, &preset->mbus_fmt);\r\nint ret;\r\nret = s5k6aa_write(client, REG_P_OUT_WIDTH(preset->index),\r\npreset->mbus_fmt.width);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_OUT_HEIGHT(preset->index),\r\npreset->mbus_fmt.height);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_FMT(preset->index),\r\ns5k6aa_formats[fmt_index].reg_p_fmt);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_set_input_params(struct s5k6aa *s5k6aa)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&s5k6aa->sd);\r\nstruct v4l2_rect *r = &s5k6aa->ccd_rect;\r\nint ret;\r\nret = s5k6aa_write(c, REG_G_PREVZOOM_IN_WIDTH, r->width);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_G_PREVZOOM_IN_HEIGHT, r->height);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_G_PREVZOOM_IN_XOFFS, r->left);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_G_PREVZOOM_IN_YOFFS, r->top);\r\nif (!ret)\r\nret = s5k6aa_write(c, REG_G_INPUTS_CHANGE_REQ, 1);\r\nif (!ret)\r\ns5k6aa->apply_crop = 0;\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_configure_video_bus(struct s5k6aa *s5k6aa,\r\nenum v4l2_mbus_type bus_type, int nlanes)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nu16 cfg = 0;\r\nint ret;\r\nif (bus_type == V4L2_MBUS_CSI2)\r\ncfg = nlanes;\r\nelse if (bus_type != V4L2_MBUS_PARALLEL)\r\nreturn -EINVAL;\r\nret = s5k6aa_write(client, REG_OIF_EN_MIPI_LANES, cfg);\r\nif (ret)\r\nreturn ret;\r\nreturn s5k6aa_write(client, REG_OIF_CFG_CHG, 1);\r\n}\r\nstatic int s5k6aa_new_config_sync(struct i2c_client *client, int timeout,\r\nint cid)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(timeout);\r\nu16 reg = 1;\r\nint ret;\r\nret = s5k6aa_write(client, REG_G_ACTIVE_PREV_CFG, cid);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_G_PREV_CFG_CHG, 1);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_G_NEW_CFG_SYNC, 1);\r\nif (timeout == 0)\r\nreturn ret;\r\nwhile (ret >= 0 && time_is_after_jiffies(end)) {\r\nret = s5k6aa_read(client, REG_G_NEW_CFG_SYNC, &reg);\r\nif (!reg)\r\nreturn 0;\r\nusleep_range(1000, 5000);\r\n}\r\nreturn ret ? ret : -ETIMEDOUT;\r\n}\r\nstatic int s5k6aa_set_prev_config(struct s5k6aa *s5k6aa,\r\nstruct s5k6aa_preset *preset)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nint idx = preset->index;\r\nu16 frame_rate_q;\r\nint ret;\r\nif (s5k6aa->fiv->reg_fr_time >= S5K6AA_MAX_HIGHRES_FR_TIME)\r\nframe_rate_q = FR_RATE_Q_BEST_FRRATE;\r\nelse\r\nframe_rate_q = FR_RATE_Q_BEST_QUALITY;\r\nret = s5k6aa_set_output_framefmt(s5k6aa, preset);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_MAX_OUT_RATE(idx),\r\ns5k6aa->pclk_fmax);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_MIN_OUT_RATE(idx),\r\ns5k6aa->pclk_fmin);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_CLK_INDEX(idx),\r\npreset->clk_id);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_FR_RATE_TYPE(idx),\r\nFR_RATE_DYNAMIC);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_FR_RATE_Q_TYPE(idx),\r\nframe_rate_q);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_MAX_FR_TIME(idx),\r\ns5k6aa->fiv->reg_fr_time + 33);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_P_MIN_FR_TIME(idx),\r\ns5k6aa->fiv->reg_fr_time - 33);\r\nif (!ret)\r\nret = s5k6aa_new_config_sync(client, 250, idx);\r\nif (!ret)\r\nret = s5k6aa_preview_config_status(client);\r\nif (!ret)\r\ns5k6aa->apply_cfg = 0;\r\nv4l2_dbg(1, debug, client, "Frame interval: %d +/- 3.3ms. (%d)\n",\r\ns5k6aa->fiv->reg_fr_time, ret);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_initialize_isp(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nint ret;\r\ns5k6aa->apply_crop = 1;\r\ns5k6aa->apply_cfg = 1;\r\nmsleep(100);\r\nret = s5k6aa_set_ahb_address(client);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_configure_video_bus(s5k6aa, s5k6aa->bus_type,\r\ns5k6aa->mipi_lanes);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_write_array(sd, s5k6aa_analog_config);\r\nif (ret)\r\nreturn ret;\r\nmsleep(20);\r\nreturn s5k6aa_configure_pixel_clocks(s5k6aa);\r\n}\r\nstatic int s5k6aa_gpio_set_value(struct s5k6aa *priv, int id, u32 val)\r\n{\r\nif (!gpio_is_valid(priv->gpio[id].gpio))\r\nreturn 0;\r\ngpio_set_value(priv->gpio[id].gpio, !!val);\r\nreturn 1;\r\n}\r\nstatic int s5k6aa_gpio_assert(struct s5k6aa *priv, int id)\r\n{\r\nreturn s5k6aa_gpio_set_value(priv, id, priv->gpio[id].level);\r\n}\r\nstatic int s5k6aa_gpio_deassert(struct s5k6aa *priv, int id)\r\n{\r\nreturn s5k6aa_gpio_set_value(priv, id, !priv->gpio[id].level);\r\n}\r\nstatic int __s5k6aa_power_on(struct s5k6aa *s5k6aa)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(S5K6AA_NUM_SUPPLIES, s5k6aa->supplies);\r\nif (ret)\r\nreturn ret;\r\nif (s5k6aa_gpio_deassert(s5k6aa, STBY))\r\nusleep_range(150, 200);\r\nif (s5k6aa->s_power)\r\nret = s5k6aa->s_power(1);\r\nusleep_range(4000, 4000);\r\nif (s5k6aa_gpio_deassert(s5k6aa, RST))\r\nmsleep(20);\r\nreturn ret;\r\n}\r\nstatic int __s5k6aa_power_off(struct s5k6aa *s5k6aa)\r\n{\r\nint ret;\r\nif (s5k6aa_gpio_assert(s5k6aa, RST))\r\nusleep_range(100, 150);\r\nif (s5k6aa->s_power) {\r\nret = s5k6aa->s_power(0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (s5k6aa_gpio_assert(s5k6aa, STBY))\r\nusleep_range(50, 100);\r\ns5k6aa->streaming = 0;\r\nreturn regulator_bulk_disable(S5K6AA_NUM_SUPPLIES, s5k6aa->supplies);\r\n}\r\nstatic int s5k6aa_set_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nint ret = 0;\r\nmutex_lock(&s5k6aa->lock);\r\nif (!on == s5k6aa->power) {\r\nif (on) {\r\nret = __s5k6aa_power_on(s5k6aa);\r\nif (!ret)\r\nret = s5k6aa_initialize_isp(sd);\r\n} else {\r\nret = __s5k6aa_power_off(s5k6aa);\r\n}\r\nif (!ret)\r\ns5k6aa->power += on ? 1 : -1;\r\n}\r\nmutex_unlock(&s5k6aa->lock);\r\nif (!on || ret || s5k6aa->power != 1)\r\nreturn ret;\r\nreturn v4l2_ctrl_handler_setup(sd->ctrl_handler);\r\n}\r\nstatic int __s5k6aa_stream(struct s5k6aa *s5k6aa, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nint ret = 0;\r\nret = s5k6aa_write(client, REG_G_ENABLE_PREV, enable);\r\nif (!ret)\r\nret = s5k6aa_write(client, REG_G_ENABLE_PREV_CHG, 1);\r\nif (!ret)\r\ns5k6aa->streaming = enable;\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nint ret = 0;\r\nmutex_lock(&s5k6aa->lock);\r\nif (s5k6aa->streaming == !on) {\r\nif (!ret && s5k6aa->apply_cfg)\r\nret = s5k6aa_set_prev_config(s5k6aa, s5k6aa->preset);\r\nif (s5k6aa->apply_crop)\r\nret = s5k6aa_set_input_params(s5k6aa);\r\nif (!ret)\r\nret = __s5k6aa_stream(s5k6aa, !!on);\r\n}\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_g_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nmutex_lock(&s5k6aa->lock);\r\nfi->interval = s5k6aa->fiv->interval;\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn 0;\r\n}\r\nstatic int __s5k6aa_set_frame_interval(struct s5k6aa *s5k6aa,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct v4l2_mbus_framefmt *mbus_fmt = &s5k6aa->preset->mbus_fmt;\r\nconst struct s5k6aa_interval *fiv = &s5k6aa_intervals[0];\r\nunsigned int err, min_err = UINT_MAX;\r\nunsigned int i, fr_time;\r\nif (fi->interval.denominator == 0)\r\nreturn -EINVAL;\r\nfr_time = fi->interval.numerator * 10000 / fi->interval.denominator;\r\nfor (i = 0; i < ARRAY_SIZE(s5k6aa_intervals); i++) {\r\nconst struct s5k6aa_interval *iv = &s5k6aa_intervals[i];\r\nif (mbus_fmt->width > iv->size.width ||\r\nmbus_fmt->height > iv->size.height)\r\ncontinue;\r\nerr = abs(iv->reg_fr_time - fr_time);\r\nif (err < min_err) {\r\nfiv = iv;\r\nmin_err = err;\r\n}\r\n}\r\ns5k6aa->fiv = fiv;\r\nv4l2_dbg(1, debug, &s5k6aa->sd, "Changed frame interval to %d us\n",\r\nfiv->reg_fr_time * 100);\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_s_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nint ret;\r\nv4l2_dbg(1, debug, sd, "Setting %d/%d frame interval\n",\r\nfi->interval.numerator, fi->interval.denominator);\r\nmutex_lock(&s5k6aa->lock);\r\nret = __s5k6aa_set_frame_interval(s5k6aa, fi);\r\ns5k6aa->apply_cfg = 1;\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_enum_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_interval_enum *fie)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nconst struct s5k6aa_interval *fi;\r\nint ret = 0;\r\nif (fie->index > ARRAY_SIZE(s5k6aa_intervals))\r\nreturn -EINVAL;\r\nv4l_bound_align_image(&fie->width, S5K6AA_WIN_WIDTH_MIN,\r\nS5K6AA_WIN_WIDTH_MAX, 1,\r\n&fie->height, S5K6AA_WIN_HEIGHT_MIN,\r\nS5K6AA_WIN_HEIGHT_MAX, 1, 0);\r\nmutex_lock(&s5k6aa->lock);\r\nfi = &s5k6aa_intervals[fie->index];\r\nif (fie->width > fi->size.width || fie->height > fi->size.height)\r\nret = -EINVAL;\r\nelse\r\nfie->interval = fi->interval;\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(s5k6aa_formats))\r\nreturn -EINVAL;\r\ncode->code = s5k6aa_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nint i = ARRAY_SIZE(s5k6aa_formats);\r\nif (fse->index > 0)\r\nreturn -EINVAL;\r\nwhile (--i)\r\nif (fse->code == s5k6aa_formats[i].code)\r\nbreak;\r\nfse->code = s5k6aa_formats[i].code;\r\nfse->min_width = S5K6AA_WIN_WIDTH_MIN;\r\nfse->max_width = S5K6AA_WIN_WIDTH_MAX;\r\nfse->max_height = S5K6AA_WIN_HEIGHT_MIN;\r\nfse->min_height = S5K6AA_WIN_HEIGHT_MAX;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_rect *\r\n__s5k6aa_get_crop_rect(struct s5k6aa *s5k6aa, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn &s5k6aa->ccd_rect;\r\nWARN_ON(which != V4L2_SUBDEV_FORMAT_TRY);\r\nreturn v4l2_subdev_get_try_crop(fh, 0);\r\n}\r\nstatic void s5k6aa_try_format(struct s5k6aa *s5k6aa,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nunsigned int index;\r\nv4l_bound_align_image(&mf->width, S5K6AA_WIN_WIDTH_MIN,\r\nS5K6AA_WIN_WIDTH_MAX, 1,\r\n&mf->height, S5K6AA_WIN_HEIGHT_MIN,\r\nS5K6AA_WIN_HEIGHT_MAX, 1, 0);\r\nif (mf->colorspace != V4L2_COLORSPACE_JPEG &&\r\nmf->colorspace != V4L2_COLORSPACE_REC709)\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nindex = s5k6aa_get_pixfmt_index(s5k6aa, mf);\r\nmf->colorspace = s5k6aa_formats[index].colorspace;\r\nmf->code = s5k6aa_formats[index].code;\r\nmf->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int s5k6aa_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nmemset(fmt->reserved, 0, sizeof(fmt->reserved));\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(fh, 0);\r\nfmt->format = *mf;\r\nreturn 0;\r\n}\r\nmutex_lock(&s5k6aa->lock);\r\nfmt->format = s5k6aa->preset->mbus_fmt;\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nstruct s5k6aa_preset *preset = s5k6aa->preset;\r\nstruct v4l2_mbus_framefmt *mf;\r\nstruct v4l2_rect *crop;\r\nint ret = 0;\r\nmutex_lock(&s5k6aa->lock);\r\ns5k6aa_try_format(s5k6aa, &fmt->format);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(fh, fmt->pad);\r\ncrop = v4l2_subdev_get_try_crop(fh, 0);\r\n} else {\r\nif (s5k6aa->streaming) {\r\nret = -EBUSY;\r\n} else {\r\nmf = &preset->mbus_fmt;\r\ncrop = &s5k6aa->ccd_rect;\r\ns5k6aa->apply_cfg = 1;\r\n}\r\n}\r\nif (ret == 0) {\r\nstruct v4l2_subdev_frame_interval fiv = {\r\n.interval = {0, 1}\r\n};\r\n*mf = fmt->format;\r\ncrop->width = clamp_t(unsigned int, crop->width, mf->width,\r\nS5K6AA_WIN_WIDTH_MAX);\r\ncrop->height = clamp_t(unsigned int, crop->height, mf->height,\r\nS5K6AA_WIN_HEIGHT_MAX);\r\ncrop->left = clamp_t(unsigned int, crop->left, 0,\r\nS5K6AA_WIN_WIDTH_MAX - crop->width);\r\ncrop->top = clamp_t(unsigned int, crop->top, 0,\r\nS5K6AA_WIN_HEIGHT_MAX - crop->height);\r\nret = __s5k6aa_set_frame_interval(s5k6aa, &fiv);\r\n}\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_get_crop(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nstruct v4l2_rect *rect;\r\nmemset(crop->reserved, 0, sizeof(crop->reserved));\r\nmutex_lock(&s5k6aa->lock);\r\nrect = __s5k6aa_get_crop_rect(s5k6aa, fh, crop->which);\r\ncrop->rect = *rect;\r\nmutex_unlock(&s5k6aa->lock);\r\nv4l2_dbg(1, debug, sd, "Current crop rectangle: (%d,%d)/%dx%d\n",\r\nrect->left, rect->top, rect->width, rect->height);\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_set_crop(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nunsigned int max_x, max_y;\r\nstruct v4l2_rect *crop_r;\r\nmutex_lock(&s5k6aa->lock);\r\ncrop_r = __s5k6aa_get_crop_rect(s5k6aa, fh, crop->which);\r\nif (crop->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nmf = &s5k6aa->preset->mbus_fmt;\r\ns5k6aa->apply_crop = 1;\r\n} else {\r\nmf = v4l2_subdev_get_try_format(fh, 0);\r\n}\r\nv4l_bound_align_image(&crop->rect.width, mf->width,\r\nS5K6AA_WIN_WIDTH_MAX, 1,\r\n&crop->rect.height, mf->height,\r\nS5K6AA_WIN_HEIGHT_MAX, 1, 0);\r\nmax_x = (S5K6AA_WIN_WIDTH_MAX - crop->rect.width) & ~1;\r\nmax_y = (S5K6AA_WIN_HEIGHT_MAX - crop->rect.height) & ~1;\r\ncrop->rect.left = clamp_t(unsigned int, crop->rect.left, 0, max_x);\r\ncrop->rect.top = clamp_t(unsigned int, crop->rect.top, 0, max_y);\r\n*crop_r = crop->rect;\r\nmutex_unlock(&s5k6aa->lock);\r\nv4l2_dbg(1, debug, sd, "Set crop rectangle: (%d,%d)/%dx%d\n",\r\ncrop_r->left, crop_r->top, crop_r->width, crop_r->height);\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nint idx, err = 0;\r\nv4l2_dbg(1, debug, sd, "ctrl: 0x%x, value: %d\n", ctrl->id, ctrl->val);\r\nmutex_lock(&s5k6aa->lock);\r\nif (s5k6aa->power == 0)\r\ngoto unlock;\r\nidx = s5k6aa->preset->index;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nerr = s5k6aa_set_awb(s5k6aa, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nerr = s5k6aa_write(client, REG_USER_BRIGHTNESS, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_COLORFX:\r\nerr = s5k6aa_set_colorfx(s5k6aa, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nerr = s5k6aa_write(client, REG_USER_CONTRAST, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nerr = s5k6aa_set_auto_exposure(s5k6aa, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nerr = s5k6aa_set_mirror(s5k6aa, ctrl->val);\r\nif (err)\r\nbreak;\r\nerr = s5k6aa_write(client, REG_G_PREV_CFG_CHG, 1);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nerr = s5k6aa_set_anti_flicker(s5k6aa, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nerr = s5k6aa_write(client, REG_USER_SATURATION, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nerr = s5k6aa_write(client, REG_USER_SHARPBLUR, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\r\nerr = s5k6aa_write(client, REG_P_COLORTEMP(idx), ctrl->val);\r\nif (err)\r\nbreak;\r\nerr = s5k6aa_write(client, REG_G_PREV_CFG_CHG, 1);\r\nbreak;\r\n}\r\nunlock:\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn err;\r\n}\r\nstatic int s5k6aa_log_status(struct v4l2_subdev *sd)\r\n{\r\nv4l2_ctrl_handler_log_status(sd->ctrl_handler, sd->name);\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_initialize_ctrls(struct s5k6aa *s5k6aa)\r\n{\r\nconst struct v4l2_ctrl_ops *ops = &s5k6aa_ctrl_ops;\r\nstruct s5k6aa_ctrls *ctrls = &s5k6aa->ctrls;\r\nstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\r\nint ret = v4l2_ctrl_handler_init(hdl, 16);\r\nif (ret)\r\nreturn ret;\r\nctrls->awb = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTO_WHITE_BALANCE,\r\n0, 1, 1, 1);\r\nctrls->gain_red = v4l2_ctrl_new_custom(hdl, &s5k6aa_ctrls[0], NULL);\r\nctrls->gain_green = v4l2_ctrl_new_custom(hdl, &s5k6aa_ctrls[1], NULL);\r\nctrls->gain_blue = v4l2_ctrl_new_custom(hdl, &s5k6aa_ctrls[2], NULL);\r\nv4l2_ctrl_auto_cluster(4, &ctrls->awb, 0, false);\r\nctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_cluster(2, &ctrls->hflip);\r\nctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,\r\nV4L2_CID_EXPOSURE_AUTO,\r\nV4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);\r\nctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,\r\n0, 6000000U, 1, 100000U);\r\nctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,\r\n0, 256, 1, 256);\r\nv4l2_ctrl_auto_cluster(3, &ctrls->auto_exp, 0, false);\r\nv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\r\nV4L2_CID_POWER_LINE_FREQUENCY_AUTO);\r\nv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_COLORFX,\r\nV4L2_COLORFX_SKY_BLUE, ~0x6f, V4L2_COLORFX_NONE);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_WHITE_BALANCE_TEMPERATURE,\r\n0, 256, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS, -127, 127, 1, 0);\r\nif (hdl->error) {\r\nret = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn ret;\r\n}\r\ns5k6aa->sd.ctrl_handler = hdl;\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format = v4l2_subdev_get_try_format(fh, 0);\r\nstruct v4l2_rect *crop = v4l2_subdev_get_try_crop(fh, 0);\r\nformat->colorspace = s5k6aa_formats[0].colorspace;\r\nformat->code = s5k6aa_formats[0].code;\r\nformat->width = S5K6AA_OUT_WIDTH_DEF;\r\nformat->height = S5K6AA_OUT_HEIGHT_DEF;\r\nformat->field = V4L2_FIELD_NONE;\r\ncrop->width = S5K6AA_WIN_WIDTH_MAX;\r\ncrop->height = S5K6AA_WIN_HEIGHT_MAX;\r\ncrop->left = 0;\r\ncrop->top = 0;\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_check_fw_revision(struct s5k6aa *s5k6aa)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&s5k6aa->sd);\r\nu16 api_ver = 0, fw_rev = 0;\r\nint ret = s5k6aa_set_ahb_address(client);\r\nif (!ret)\r\nret = s5k6aa_read(client, REG_FW_APIVER, &api_ver);\r\nif (!ret)\r\nret = s5k6aa_read(client, REG_FW_REVISION, &fw_rev);\r\nif (ret) {\r\nv4l2_err(&s5k6aa->sd, "FW revision check failed!\n");\r\nreturn ret;\r\n}\r\nv4l2_info(&s5k6aa->sd, "FW API ver.: 0x%X, FW rev.: 0x%X\n",\r\napi_ver, fw_rev);\r\nreturn api_ver == S5K6AAFX_FW_APIVER ? 0 : -ENODEV;\r\n}\r\nstatic int s5k6aa_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nint ret;\r\nmutex_lock(&s5k6aa->lock);\r\nret = __s5k6aa_power_on(s5k6aa);\r\nif (!ret) {\r\nmsleep(100);\r\nret = s5k6aa_check_fw_revision(s5k6aa);\r\n__s5k6aa_power_off(s5k6aa);\r\n}\r\nmutex_unlock(&s5k6aa->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_configure_gpio(int nr, int val, const char *name)\r\n{\r\nunsigned long flags = val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\nint ret;\r\nif (!gpio_is_valid(nr))\r\nreturn 0;\r\nret = gpio_request_one(nr, flags, name);\r\nif (!ret)\r\ngpio_export(nr, 0);\r\nreturn ret;\r\n}\r\nstatic void s5k6aa_free_gpios(struct s5k6aa *s5k6aa)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(s5k6aa->gpio); i++) {\r\nif (!gpio_is_valid(s5k6aa->gpio[i].gpio))\r\ncontinue;\r\ngpio_free(s5k6aa->gpio[i].gpio);\r\ns5k6aa->gpio[i].gpio = -EINVAL;\r\n}\r\n}\r\nstatic int s5k6aa_configure_gpios(struct s5k6aa *s5k6aa,\r\nconst struct s5k6aa_platform_data *pdata)\r\n{\r\nconst struct s5k6aa_gpio *gpio = &pdata->gpio_stby;\r\nint ret;\r\ns5k6aa->gpio[STBY].gpio = -EINVAL;\r\ns5k6aa->gpio[RST].gpio = -EINVAL;\r\nret = s5k6aa_configure_gpio(gpio->gpio, gpio->level, "S5K6AA_STBY");\r\nif (ret) {\r\ns5k6aa_free_gpios(s5k6aa);\r\nreturn ret;\r\n}\r\ns5k6aa->gpio[STBY] = *gpio;\r\nif (gpio_is_valid(gpio->gpio))\r\ngpio_set_value(gpio->gpio, 0);\r\ngpio = &pdata->gpio_reset;\r\nret = s5k6aa_configure_gpio(gpio->gpio, gpio->level, "S5K6AA_RST");\r\nif (ret) {\r\ns5k6aa_free_gpios(s5k6aa);\r\nreturn ret;\r\n}\r\ns5k6aa->gpio[RST] = *gpio;\r\nif (gpio_is_valid(gpio->gpio))\r\ngpio_set_value(gpio->gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int s5k6aa_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct s5k6aa_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_subdev *sd;\r\nstruct s5k6aa *s5k6aa;\r\nint i, ret;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "Platform data not specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->mclk_frequency == 0) {\r\ndev_err(&client->dev, "MCLK frequency not specified\n");\r\nreturn -EINVAL;\r\n}\r\ns5k6aa = devm_kzalloc(&client->dev, sizeof(*s5k6aa), GFP_KERNEL);\r\nif (!s5k6aa)\r\nreturn -ENOMEM;\r\nmutex_init(&s5k6aa->lock);\r\ns5k6aa->mclk_frequency = pdata->mclk_frequency;\r\ns5k6aa->bus_type = pdata->bus_type;\r\ns5k6aa->mipi_lanes = pdata->nlanes;\r\ns5k6aa->s_power = pdata->set_power;\r\ns5k6aa->inv_hflip = pdata->horiz_flip;\r\ns5k6aa->inv_vflip = pdata->vert_flip;\r\nsd = &s5k6aa->sd;\r\nv4l2_i2c_subdev_init(sd, client, &s5k6aa_subdev_ops);\r\nstrlcpy(sd->name, DRIVER_NAME, sizeof(sd->name));\r\nsd->internal_ops = &s5k6aa_subdev_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\ns5k6aa->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\nret = media_entity_init(&sd->entity, 1, &s5k6aa->pad, 0);\r\nif (ret)\r\nreturn ret;\r\nret = s5k6aa_configure_gpios(s5k6aa, pdata);\r\nif (ret)\r\ngoto out_err2;\r\nfor (i = 0; i < S5K6AA_NUM_SUPPLIES; i++)\r\ns5k6aa->supplies[i].supply = s5k6aa_supply_names[i];\r\nret = regulator_bulk_get(&client->dev, S5K6AA_NUM_SUPPLIES,\r\ns5k6aa->supplies);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to get regulators\n");\r\ngoto out_err3;\r\n}\r\nret = s5k6aa_initialize_ctrls(s5k6aa);\r\nif (ret)\r\ngoto out_err4;\r\ns5k6aa_presets_data_init(s5k6aa);\r\ns5k6aa->ccd_rect.width = S5K6AA_WIN_WIDTH_MAX;\r\ns5k6aa->ccd_rect.height = S5K6AA_WIN_HEIGHT_MAX;\r\ns5k6aa->ccd_rect.left = 0;\r\ns5k6aa->ccd_rect.top = 0;\r\nreturn 0;\r\nout_err4:\r\nregulator_bulk_free(S5K6AA_NUM_SUPPLIES, s5k6aa->supplies);\r\nout_err3:\r\ns5k6aa_free_gpios(s5k6aa);\r\nout_err2:\r\nmedia_entity_cleanup(&s5k6aa->sd.entity);\r\nreturn ret;\r\n}\r\nstatic int s5k6aa_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct s5k6aa *s5k6aa = to_s5k6aa(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nmedia_entity_cleanup(&sd->entity);\r\nregulator_bulk_free(S5K6AA_NUM_SUPPLIES, s5k6aa->supplies);\r\ns5k6aa_free_gpios(s5k6aa);\r\nreturn 0;\r\n}
