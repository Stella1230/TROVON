u32 rtl8192_CalculateBitShift(u32 dwBitMask)\r\n{\r\nu32 i;\r\nfor (i=0; i<=31; i++)\r\n{\r\nif (((dwBitMask>>i)&0x1) == 1)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nu8 rtl8192_phy_CheckIsLegalRFPath(struct net_device* dev, u32 eRFPath)\r\n{\r\nu8 ret = 1;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->rf_type == RF_2T4R)\r\nret = 0;\r\nelse if (priv->rf_type == RF_1T2R)\r\n{\r\nif (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)\r\nret = 1;\r\nelse if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_setBBreg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask, u32 dwData)\r\n{\r\nu32 OriginalValue, BitShift, NewValue;\r\nif(dwBitMask!= bMaskDWord)\r\n{\r\nOriginalValue = read_nic_dword(dev, dwRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(dwBitMask);\r\nNewValue = (((OriginalValue) & (~dwBitMask)) | (dwData << BitShift));\r\nwrite_nic_dword(dev, dwRegAddr, NewValue);\r\n}else\r\nwrite_nic_dword(dev, dwRegAddr, dwData);\r\nreturn;\r\n}\r\nu32 rtl8192_QueryBBReg(struct net_device* dev, u32 dwRegAddr, u32 dwBitMask)\r\n{\r\nu32 Ret = 0, OriginalValue, BitShift;\r\nOriginalValue = read_nic_dword(dev, dwRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(dwBitMask);\r\nRet =(OriginalValue & dwBitMask) >> BitShift;\r\nreturn (Ret);\r\n}\r\nu32 rtl8192_phy_RFSerialRead(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 ret = 0;\r\nu32 NewOffset = 0;\r\nBB_REGISTER_DEFINITION_T* pPhyReg = &priv->PHYRegDef[eRFPath];\r\nrtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);\r\nOffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256)\r\n{\r\nif (Offset >= 31)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );\r\nNewOffset = Offset -30;\r\n}\r\nelse if (Offset >= 16)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16) );\r\nNewOffset = Offset - 15;\r\n}\r\nelse\r\nNewOffset = Offset;\r\n}\r\nelse\r\n{\r\nRT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");\r\nNewOffset = Offset;\r\n}\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress, NewOffset);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x0);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x1);\r\nmsleep(1);\r\nret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData);\r\nif(priv->rf_chip == RF_8256)\r\n{\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(\r\ndev,\r\npPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_phy_RFSerialWrite(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 Offset, u32 Data)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 DataAndAddr = 0, NewOffset = 0;\r\nBB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256)\r\n{\r\nif (Offset >= 31)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath] << 16));\r\nNewOffset = Offset - 30;\r\n}\r\nelse if (Offset >= 16)\r\n{\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, (priv->RfReg0Value[eRFPath]<<16));\r\nNewOffset = Offset - 15;\r\n}\r\nelse\r\nNewOffset = Offset;\r\n}\r\nelse\r\n{\r\nRT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be 8256\n");\r\nNewOffset = Offset;\r\n}\r\nDataAndAddr = (Data<<16) | (NewOffset&0x3f);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\r\nif(Offset==0x0)\r\npriv->RfReg0Value[eRFPath] = Data;\r\nif(priv->rf_chip == RF_8256)\r\n{\r\nif(Offset != 0)\r\n{\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(\r\ndev,\r\npPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_phy_SetRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 Original_Value, BitShift, New_Value;\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\nreturn;\r\nif (priv->Rf_Mode == RF_OP_By_FW)\r\n{\r\nif (BitMask != bMask12Bits)\r\n{\r\nOriginal_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nNew_Value = ((Original_Value) & (~BitMask)) | (Data<< BitShift);\r\nphy_FwRFSerialWrite(dev, eRFPath, RegAddr, New_Value);\r\n}else\r\nphy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);\r\nudelay(200);\r\n}\r\nelse\r\n{\r\nif (BitMask != bMask12Bits)\r\n{\r\nOriginal_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) | (Data<< BitShift));\r\nrtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, New_Value);\r\n}else\r\nrtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);\r\n}\r\nreturn;\r\n}\r\nu32 rtl8192_phy_QueryRFReg(struct net_device* dev, RF90_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask)\r\n{\r\nu32 Original_Value, Readback_Value, BitShift;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\nreturn 0;\r\nif (priv->Rf_Mode == RF_OP_By_FW)\r\n{\r\nOriginal_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nReadback_Value = (Original_Value & BitMask) >> BitShift;\r\nudelay(200);\r\nreturn (Readback_Value);\r\n}\r\nelse\r\n{\r\nOriginal_Value = rtl8192_phy_RFSerialRead(dev, eRFPath, RegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nReadback_Value = (Original_Value & BitMask) >> BitShift;\r\nreturn (Readback_Value);\r\n}\r\n}\r\nstatic u32\r\nphy_FwRFSerialRead(\r\nstruct net_device* dev,\r\nRF90_RADIO_PATH_E eRFPath,\r\nu32 Offset )\r\n{\r\nu32 retValue = 0;\r\nu32 Data = 0;\r\nu8 time = 0;\r\nData |= ((Offset&0xFF)<<12);\r\nData |= ((eRFPath&0x3)<<20);\r\nData |= 0x80000000;\r\nwhile (read_nic_dword(dev, QPNR)&0x80000000)\r\n{\r\nif (time++ < 100)\r\n{\r\nudelay(10);\r\n}\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(dev, QPNR, Data);\r\nwhile (read_nic_dword(dev, QPNR)&0x80000000)\r\n{\r\nif (time++ < 100)\r\n{\r\nudelay(10);\r\n}\r\nelse\r\nreturn (0);\r\n}\r\nretValue = read_nic_dword(dev, RF_DATA);\r\nreturn (retValue);\r\n}\r\nstatic void\r\nphy_FwRFSerialWrite(\r\nstruct net_device* dev,\r\nRF90_RADIO_PATH_E eRFPath,\r\nu32 Offset,\r\nu32 Data )\r\n{\r\nu8 time = 0;\r\nData |= ((Offset&0xFF)<<12);\r\nData |= ((eRFPath&0x3)<<20);\r\nData |= 0x400000;\r\nData |= 0x80000000;\r\nwhile (read_nic_dword(dev, QPNR)&0x80000000)\r\n{\r\nif (time++ < 100)\r\n{\r\nudelay(10);\r\n}\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(dev, QPNR, Data);\r\n}\r\nvoid rtl8192_phy_configmac(struct net_device* dev)\r\n{\r\nu32 dwArrayLen = 0, i;\r\nu32* pdwArray = NULL;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif(priv->btxpowerdata_readfromEEPORM)\r\n{\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");\r\ndwArrayLen = MACPHY_Array_PGLength;\r\npdwArray = rtl819XMACPHY_Array_PG;\r\n}\r\nelse\r\n{\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array\n");\r\ndwArrayLen = MACPHY_ArrayLength;\r\npdwArray = rtl819XMACPHY_Array;\r\n}\r\nfor(i = 0; i<dwArrayLen; i=i+3){\r\nif(pdwArray[i] == 0x318)\r\n{\r\npdwArray[i+2] = 0x00000800;\r\n}\r\nRT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MACPHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",\r\npdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\nrtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_phyConfigBB(struct net_device* dev, u8 ConfigType)\r\n{\r\nu32 i;\r\n#ifdef TO_DO_LIST\r\nu32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;\r\nif(Adapter->bInHctTest)\r\n{\r\nPHY_REGArrayLen = PHY_REGArrayLengthDTM;\r\nAGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;\r\nRtl8190PHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;\r\nRtl8190AGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;\r\n}\r\n#endif\r\nif (ConfigType == BaseBand_Config_PHY_REG)\r\n{\r\nfor (i=0; i<PHY_REG_1T2RArrayLength; i+=2)\r\n{\r\nrtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i], bMaskDWord, rtl819XPHY_REG_1T2RArray[i+1]);\r\nRT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray[0] is %x Rtl819xUsbPHY_REGArray[1] is %x \n",i, rtl819XPHY_REG_1T2RArray[i], rtl819XPHY_REG_1T2RArray[i+1]);\r\n}\r\n}\r\nelse if (ConfigType == BaseBand_Config_AGC_TAB)\r\n{\r\nfor (i=0; i<AGCTAB_ArrayLength; i+=2)\r\n{\r\nrtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i], bMaskDWord, rtl819XAGCTAB_Array[i+1]);\r\nRT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] is %x rtl819XAGCTAB_Array[1] is %x \n",i, rtl819XAGCTAB_Array[i], rtl819XAGCTAB_Array[i+1]);\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_InitBBRFRegDef(struct net_device* dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;\r\n}\r\nu8 rtl8192_phy_checkBBAndRF(struct net_device* dev, HW90_BLOCK_E CheckBlock, RF90_RADIO_PATH_E eRFPath)\r\n{\r\nu8 ret = 0;\r\nu32 i, CheckTimes = 4, dwRegRead = 0;\r\nu32 WriteAddr[4];\r\nu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\r\nWriteAddr[HW90_BLOCK_MAC] = 0x100;\r\nWriteAddr[HW90_BLOCK_PHY0] = 0x900;\r\nWriteAddr[HW90_BLOCK_PHY1] = 0x800;\r\nWriteAddr[HW90_BLOCK_RF] = 0x3;\r\nRT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);\r\nfor(i=0 ; i < CheckTimes ; i++)\r\n{\r\nswitch(CheckBlock)\r\n{\r\ncase HW90_BLOCK_MAC:\r\nRT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write 0x100 here!");\r\nbreak;\r\ncase HW90_BLOCK_PHY0:\r\ncase HW90_BLOCK_PHY1:\r\nwrite_nic_dword(dev, WriteAddr[CheckBlock], WriteData[i]);\r\ndwRegRead = read_nic_dword(dev, WriteAddr[CheckBlock]);\r\nbreak;\r\ncase HW90_BLOCK_RF:\r\nWriteData[i] &= 0xfff;\r\nrtl8192_phy_SetRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits, WriteData[i]);\r\nmsleep(1);\r\ndwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath, WriteAddr[HW90_BLOCK_RF], bMask12Bits);\r\nmsleep(1);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\nif(dwRegRead != WriteData[i])\r\n{\r\nRT_TRACE((COMP_PHY|COMP_ERR), "====>error=====dwRegRead: %x, WriteData: %x \n", dwRegRead, WriteData[i]);\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_BB_Config_ParaFile(struct net_device* dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 bRegValue = 0, eCheckItem = 0, rtStatus = 0;\r\nu32 dwRegValue = 0;\r\nbRegValue = read_nic_byte(dev, BB_GLOBAL_RESET);\r\nwrite_nic_byte(dev, BB_GLOBAL_RESET,(bRegValue|BB_GLOBAL_RESET_BIT));\r\nmdelay(50);\r\ndwRegValue = read_nic_dword(dev, CPU_GEN);\r\nwrite_nic_dword(dev, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));\r\nfor(eCheckItem=(HW90_BLOCK_E)HW90_BLOCK_PHY0; eCheckItem<=HW90_BLOCK_PHY1; eCheckItem++)\r\n{\r\nrtStatus = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem, (RF90_RADIO_PATH_E)0);\r\nif(rtStatus != 0)\r\n{\r\nRT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():Check PHY%d Fail!!\n", eCheckItem-1);\r\nreturn ;\r\n}\r\n}\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);\r\nrtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);\r\ndwRegValue = read_nic_dword(dev, CPU_GEN);\r\nwrite_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));\r\nrtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);\r\nwrite_nic_byte_E(dev, 0x5e, 0x00);\r\nif (priv->card_8192_version == (u8)VERSION_819xU_A)\r\n{\r\ndwRegValue = (priv->AntennaTxPwDiff[1]<<4 | priv->AntennaTxPwDiff[0]);\r\nrtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC), dwRegValue);\r\ndwRegValue = priv->CrystalCap & 0xf;\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap, dwRegValue);\r\n}\r\npriv->bCckHighPower = (u8)(rtl8192_QueryBBReg(dev, rFPGA0_XA_HSSIParameter2, 0x200));\r\nreturn;\r\n}\r\nvoid rtl8192_BBConfig(struct net_device* dev)\r\n{\r\nrtl8192_InitBBRFRegDef(dev);\r\nrtl8192_BB_Config_ParaFile(dev);\r\nreturn;\r\n}\r\nvoid rtl8192_phy_getTxPower(struct net_device* dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->MCSTxPowerLevelOriginalOffset[0] =\r\nread_nic_dword(dev, rTxAGC_Rate18_06);\r\npriv->MCSTxPowerLevelOriginalOffset[1] =\r\nread_nic_dword(dev, rTxAGC_Rate54_24);\r\npriv->MCSTxPowerLevelOriginalOffset[2] =\r\nread_nic_dword(dev, rTxAGC_Mcs03_Mcs00);\r\npriv->MCSTxPowerLevelOriginalOffset[3] =\r\nread_nic_dword(dev, rTxAGC_Mcs07_Mcs04);\r\npriv->MCSTxPowerLevelOriginalOffset[4] =\r\nread_nic_dword(dev, rTxAGC_Mcs11_Mcs08);\r\npriv->MCSTxPowerLevelOriginalOffset[5] =\r\nread_nic_dword(dev, rTxAGC_Mcs15_Mcs12);\r\npriv->DefaultInitialGain[0] = read_nic_byte(dev, rOFDM0_XAAGCCore1);\r\npriv->DefaultInitialGain[1] = read_nic_byte(dev, rOFDM0_XBAGCCore1);\r\npriv->DefaultInitialGain[2] = read_nic_byte(dev, rOFDM0_XCAGCCore1);\r\npriv->DefaultInitialGain[3] = read_nic_byte(dev, rOFDM0_XDAGCCore1);\r\nRT_TRACE(COMP_INIT, "Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n",\r\npriv->DefaultInitialGain[0], priv->DefaultInitialGain[1],\r\npriv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);\r\npriv->framesync = read_nic_byte(dev, rOFDM0_RxDetector3);\r\npriv->framesyncC34 = read_nic_byte(dev, rOFDM0_RxDetector2);\r\nRT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x \n",\r\nrOFDM0_RxDetector3, priv->framesync);\r\npriv->SifsTime = read_nic_word(dev, SIFS);\r\nreturn;\r\n}\r\nvoid rtl8192_phy_setTxPower(struct net_device* dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nswitch(priv->rf_chip)\r\n{\r\ncase RF_8256:\r\nPHY_SetRF8256CCKTxPower(dev, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);\r\nbreak;\r\ndefault:\r\nRT_TRACE((COMP_PHY|COMP_ERR), "error RF chipID(8225 or 8258) in function %s()\n", __FUNCTION__);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_phy_RFConfig(struct net_device* dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nswitch(priv->rf_chip)\r\n{\r\ncase RF_8256:\r\nPHY_RF8256_Config(dev);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "error chip id\n");\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_phy_updateInitGain(struct net_device* dev)\r\n{\r\nreturn;\r\n}\r\nu8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device* dev, RF90_RADIO_PATH_E eRFPath)\r\n{\r\nint i;\r\nu8 ret = 0;\r\nswitch(eRFPath){\r\ncase RF90_PATH_A:\r\nfor(i = 0;i<RadioA_ArrayLength; i=i+2){\r\nif(rtl819XRadioA_Array[i] == 0xfe){\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioA_Array[i], bMask12Bits, rtl819XRadioA_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nfor(i = 0;i<RadioB_ArrayLength; i=i+2){\r\nif(rtl819XRadioB_Array[i] == 0xfe){\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioB_Array[i], bMask12Bits, rtl819XRadioB_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nfor(i = 0;i<RadioC_ArrayLength; i=i+2){\r\nif(rtl819XRadioC_Array[i] == 0xfe){\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioC_Array[i], bMask12Bits, rtl819XRadioC_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nfor(i = 0;i<RadioD_ArrayLength; i=i+2){\r\nif(rtl819XRadioD_Array[i] == 0xfe){\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath, rtl819XRadioD_Array[i], bMask12Bits, rtl819XRadioD_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nswitch(priv->rf_chip)\r\n{\r\ncase RF_8225:\r\n#ifdef TO_DO_LIST\r\nPHY_SetRF8225CckTxPower(Adapter, powerlevel);\r\nPHY_SetRF8225OfdmTxPower(Adapter, powerlevelOFDM24G);\r\n#endif\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256CCKTxPower(dev, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "unknown rf chip ID in rtl8192_SetTxPowerLevel()\n");\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nbool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerState)\r\n{\r\nbool bResult = true;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif(eRFPowerState == priv->ieee80211->eRFPowerState)\r\nreturn false;\r\nif(priv->SetRFPowerStateInProgress == true)\r\nreturn false;\r\npriv->SetRFPowerStateInProgress = true;\r\nswitch(priv->rf_chip)\r\n{\r\ncase RF_8256:\r\nswitch( eRFPowerState )\r\n{\r\ncase eRfOn:\r\nrtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x3);\r\nrtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3);\r\nrtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3);\r\nbreak;\r\ncase eRfSleep:\r\nbreak;\r\ncase eRfOff:\r\nrtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0);\r\nrtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);\r\nrtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0);\r\nbreak;\r\ndefault:\r\nbResult = false;\r\nRT_TRACE(COMP_ERR, "SetRFPowerState819xUsb(): unknow state to set: 0x%X!!!\n", eRFPowerState);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Not support rf_chip(%x)\n", priv->rf_chip);\r\nbreak;\r\n}\r\n#ifdef TO_DO_LIST\r\nif(bResult)\r\n{\r\npHalData->eRFPowerState = eRFPowerState;\r\nswitch(pHalData->RFChipID )\r\n{\r\ncase RF_8256:\r\nswitch(pHalData->eRFPowerState)\r\n{\r\ncase eRfOff:\r\nif(pMgntInfo->RfOffReason==RF_CHANGE_BY_IPS )\r\n{\r\nAdapter->HalFunc.LedControlHandler(Adapter,LED_CTL_NO_LINK);\r\n}\r\nelse\r\n{\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);\r\n}\r\nbreak;\r\ncase eRfOn:\r\nif( pMgntInfo->bMediaConnect == TRUE )\r\n{\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);\r\n}\r\nelse\r\n{\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_RF, DBG_LOUD, ("SetRFPowerState8190(): Unknown RF type\n"));\r\nbreak;\r\n}\r\n}\r\n#endif\r\npriv->SetRFPowerStateInProgress = false;\r\nreturn bResult;\r\n}\r\nu8 rtl8192_phy_SetSwChnlCmdArray(\r\nSwChnlCmd* CmdTable,\r\nu32 CmdTableIdx,\r\nu32 CmdTableSz,\r\nSwChnlCmdID CmdID,\r\nu32 Para1,\r\nu32 Para2,\r\nu32 msDelay\r\n)\r\n{\r\nSwChnlCmd* pCmd;\r\nif(CmdTable == NULL)\r\n{\r\nRT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot be NULL.\n");\r\nreturn false;\r\n}\r\nif(CmdTableIdx >= CmdTableSz)\r\n{\r\nRT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",\r\nCmdTableIdx, CmdTableSz);\r\nreturn false;\r\n}\r\npCmd = CmdTable + CmdTableIdx;\r\npCmd->CmdID = CmdID;\r\npCmd->Para1 = Para1;\r\npCmd->Para2 = Para2;\r\npCmd->msDelay = msDelay;\r\nreturn true;\r\n}\r\nu8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel, u8* stage, u8* step, u32* delay)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nSwChnlCmd PreCommonCmd[MAX_PRECMD_CNT];\r\nu32 PreCommonCmdCnt;\r\nSwChnlCmd PostCommonCmd[MAX_POSTCMD_CNT];\r\nu32 PostCommonCmdCnt;\r\nSwChnlCmd RfDependCmd[MAX_RFDEPENDCMD_CNT];\r\nu32 RfDependCmdCnt;\r\nSwChnlCmd *CurrentCmd = NULL;\r\nu8 eRFPath;\r\nRT_TRACE(COMP_CH, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);\r\nif (!IsLegalChannel(priv->ieee80211, channel))\r\n{\r\nRT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n", channel);\r\nreturn true;\r\n}\r\nPreCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,\r\nCmdID_SetTxPowerLevel, 0, 0, 0);\r\nrtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nPostCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nRfDependCmdCnt = 0;\r\nswitch( priv->rf_chip )\r\n{\r\ncase RF_8225:\r\nif (!(channel >= 1 && channel <= 14))\r\n{\r\nRT_TRACE(COMP_ERR, "illegal channel for Zebra 8225: %d\n", channel);\r\nreturn true;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg, rZebra1_Channel, RF_CHANNEL_TABLE_ZEBRA[channel], 10);\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8256:\r\nif (!(channel >= 1 && channel <= 14))\r\n{\r\nRT_TRACE(COMP_ERR, "illegal channel for Zebra 8256: %d\n", channel);\r\nreturn true;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg, rZebra1_Channel, channel, 10);\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);\r\nreturn true;\r\nbreak;\r\n}\r\ndo{\r\nswitch(*stage)\r\n{\r\ncase 0:\r\nCurrentCmd=&PreCommonCmd[*step];\r\nbreak;\r\ncase 1:\r\nCurrentCmd=&RfDependCmd[*step];\r\nbreak;\r\ncase 2:\r\nCurrentCmd=&PostCommonCmd[*step];\r\nbreak;\r\n}\r\nif(CurrentCmd->CmdID==CmdID_End)\r\n{\r\nif((*stage)==2)\r\n{\r\n(*delay)=CurrentCmd->msDelay;\r\nreturn true;\r\n}\r\nelse\r\n{\r\n(*stage)++;\r\n(*step)=0;\r\ncontinue;\r\n}\r\n}\r\nswitch(CurrentCmd->CmdID)\r\n{\r\ncase CmdID_SetTxPowerLevel:\r\nif(priv->card_8192_version == (u8)VERSION_819xU_A)\r\nrtl8192_SetTxPowerLevel(dev,channel);\r\nbreak;\r\ncase CmdID_WritePortUlong:\r\nwrite_nic_dword(dev, CurrentCmd->Para1, CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUshort:\r\nwrite_nic_word(dev, CurrentCmd->Para1, (u16)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUchar:\r\nwrite_nic_byte(dev, CurrentCmd->Para1, (u8)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_RF_WriteReg:\r\nfor(eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++)\r\n{\r\nrtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, bZebra1_ChannelNum, CurrentCmd->Para2);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}while(true);\r\n(*delay)=CurrentCmd->msDelay;\r\n(*step)++;\r\nreturn false;\r\n}\r\nvoid rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 delay = 0;\r\nwhile(!rtl8192_phy_SwChnlStepByStep(dev,channel,&priv->SwChnlStage,&priv->SwChnlStep,&delay))\r\n{\r\nif(!priv->up)\r\nbreak;\r\n}\r\n}\r\nvoid rtl8192_SwChnl_WorkItem(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_TRACE(COMP_CH, "==> SwChnlCallback819xUsbWorkItem(), chan:%d\n", priv->chan);\r\nrtl8192_phy_FinishSwChnlNow(dev , priv->chan);\r\nRT_TRACE(COMP_CH, "<== SwChnlCallback819xUsbWorkItem()\n");\r\n}\r\nu8 rtl8192_phy_SwChnl(struct net_device* dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_TRACE(COMP_CH, "=====>%s(), SwChnlInProgress:%d\n", __FUNCTION__, priv->SwChnlInProgress);\r\nif(!priv->up)\r\nreturn false;\r\nif(priv->SwChnlInProgress)\r\nreturn false;\r\nif (0)\r\n{\r\nu8 eRFPath;\r\nfor(eRFPath = 0; eRFPath < 2; eRFPath++){\r\nprintk("====>set channel:%x\n",rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, 0x7, bZebra1_ChannelNum));\r\nudelay(10);\r\n}\r\n}\r\nswitch(priv->ieee80211->mode)\r\n{\r\ncase WIRELESS_MODE_A:\r\ncase WIRELESS_MODE_N_5G:\r\nif (channel<=14){\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_B:\r\nif (channel>14){\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\ncase WIRELESS_MODE_N_24G:\r\nif (channel>14){\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14");\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\npriv->SwChnlInProgress = true;\r\nif(channel == 0)\r\nchannel = 1;\r\npriv->chan=channel;\r\npriv->SwChnlStage=0;\r\npriv->SwChnlStep=0;\r\nif(priv->up) {\r\nrtl8192_SwChnl_WorkItem(dev);\r\n}\r\npriv->SwChnlInProgress = false;\r\nreturn true;\r\n}\r\nvoid rtl8192_SetBWModeWorkItem(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 regBwOpMode;\r\nRT_TRACE(COMP_SWBW, "==>rtl8192_SetBWModeWorkItem() Switch to %s bandwidth\n", \\r\npriv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz")\r\nif(priv->rf_chip == RF_PSEUDO_11N)\r\n{\r\npriv->SetBWModeInProgress= false;\r\nreturn;\r\n}\r\nregBwOpMode = read_nic_byte(dev, BW_OPMODE);\r\nswitch(priv->CurrentChannelBW)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\nregBwOpMode |= BW_OPMODE_20MHZ;\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nregBwOpMode &= ~BW_OPMODE_20MHZ;\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",priv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch(priv->CurrentChannelBW)\r\n{\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);\r\npriv->cck_present_attentuation =\r\npriv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;\r\nif(priv->cck_present_attentuation > 22)\r\npriv->cck_present_attentuation= 22;\r\nif(priv->cck_present_attentuation< 0)\r\npriv->cck_present_attentuation = 0;\r\nRT_TRACE(COMP_INIT, "20M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);\r\nif(priv->chan == 14 && !priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = TRUE;\r\ndm_cck_txpower_adjust(dev,priv->bcck_in_ch14);\r\n}\r\nelse if(priv->chan != 14 && priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = FALSE;\r\ndm_cck_txpower_adjust(dev,priv->bcck_in_ch14);\r\n}\r\nelse\r\ndm_cck_txpower_adjust(dev,priv->bcck_in_ch14);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);\r\nrtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);\r\nrtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);\r\nrtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);\r\npriv->cck_present_attentuation =\r\npriv->cck_present_attentuation_40Mdefault + priv->cck_present_attentuation_difference;\r\nif(priv->cck_present_attentuation > 22)\r\npriv->cck_present_attentuation = 22;\r\nif(priv->cck_present_attentuation < 0)\r\npriv->cck_present_attentuation = 0;\r\nRT_TRACE(COMP_INIT, "40M, pHalData->CCKPresentAttentuation = %d\n", priv->cck_present_attentuation);\r\nif(priv->chan == 14 && !priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = true;\r\ndm_cck_txpower_adjust(dev,priv->bcck_in_ch14);\r\n}\r\nelse if(priv->chan!= 14 && priv->bcck_in_ch14)\r\n{\r\npriv->bcck_in_ch14 = false;\r\ndm_cck_txpower_adjust(dev,priv->bcck_in_ch14);\r\n}\r\nelse\r\ndm_cck_txpower_adjust(dev,priv->bcck_in_ch14);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n" ,priv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch( priv->rf_chip )\r\n{\r\ncase RF_8225:\r\n#ifdef TO_DO_LIST\r\nPHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);\r\n#endif\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ncase RF_PSEUDO_11N:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);\r\nbreak;\r\n}\r\npriv->SetBWModeInProgress= false;\r\nRT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)) );\r\n}\r\nvoid rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH Bandwidth, HT_EXTCHNL_OFFSET Offset)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif(priv->SetBWModeInProgress)\r\nreturn;\r\npriv->SetBWModeInProgress= true;\r\npriv->CurrentChannelBW = Bandwidth;\r\nif(Offset==HT_EXTCHNL_OFFSET_LOWER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse if(Offset==HT_EXTCHNL_OFFSET_UPPER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nelse\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nrtl8192_SetBWModeWorkItem(dev);\r\n}\r\nvoid InitialGain819xUsb(struct net_device *dev, u8 Operation)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->InitialGainOperateType = Operation;\r\nif(priv->up)\r\n{\r\nqueue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);\r\n}\r\n}\r\nextern void InitialGainOperateWorkItemCallBack(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = container_of(work,struct delayed_work,work);\r\nstruct r8192_priv *priv = container_of(dwork,struct r8192_priv,initialgain_operate_wq);\r\nstruct net_device *dev = priv->ieee80211->dev;\r\n#define SCAN_RX_INITIAL_GAIN 0x17\r\n#define POWER_DETECTION_TH 0x08\r\nu32 BitMask;\r\nu8 initial_gain;\r\nu8 Operation;\r\nOperation = priv->InitialGainOperateType;\r\nswitch(Operation)\r\n{\r\ncase IG_Backup:\r\nRT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");\r\ninitial_gain = SCAN_RX_INITIAL_GAIN;\r\nBitMask = bMaskByte0;\r\nif(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\r\npriv->initgain_backup.xaagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, BitMask);\r\npriv->initgain_backup.xbagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, BitMask);\r\npriv->initgain_backup.xcagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, BitMask);\r\npriv->initgain_backup.xdagccore1 = (u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, BitMask);\r\nBitMask = bMaskByte2;\r\npriv->initgain_backup.cca = (u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, BitMask);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",priv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",priv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n",priv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n",priv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x \n", initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);\r\nRT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x \n", POWER_DETECTION_TH);\r\nwrite_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);\r\nbreak;\r\ncase IG_Restore:\r\nRT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");\r\nBitMask = 0x7f;\r\nif(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\r\nrtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, BitMask, (u32)priv->initgain_backup.xaagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, BitMask, (u32)priv->initgain_backup.xbagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, BitMask, (u32)priv->initgain_backup.xcagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, BitMask, (u32)priv->initgain_backup.xdagccore1);\r\nBitMask = bMaskByte2;\r\nrtl8192_setBBreg(dev, rCCK0_CCA, BitMask, (u32)priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",priv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",priv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n",priv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n",priv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",priv->initgain_backup.cca);\r\n#ifdef RTL8190P\r\nSetTxPowerLevel8190(Adapter,priv->CurrentChannel);\r\n#endif\r\n#ifdef RTL8192E\r\nSetTxPowerLevel8190(Adapter,priv->CurrentChannel);\r\n#endif\r\nrtl8192_phy_setTxPower(dev,priv->ieee80211->current_network.channel);\r\nif(dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown IG Operation. \n");\r\nbreak;\r\n}\r\n}
