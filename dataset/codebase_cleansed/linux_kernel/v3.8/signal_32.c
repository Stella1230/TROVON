asmlinkage int\r\nsys_sigsuspend(old_sigset_t mask)\r\n{\r\nsigset_t blocked;\r\nsiginitset(&blocked, mask);\r\nreturn sigsuspend(&blocked);\r\n}\r\nasmlinkage int\r\nsys_sigaction(int sig, const struct old_sigaction __user *act,\r\nstruct old_sigaction __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nif (act) {\r\nold_sigset_t mask;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\r\n__get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\r\n__get_user(mask, &act->sa_mask))\r\nreturn -EFAULT;\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\r\n__put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\r\n__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage int\r\nsys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,\r\nunsigned long r6, unsigned long r7,\r\nstruct pt_regs __regs)\r\n{\r\nstruct pt_regs *regs = RELOC_HIDE(&__regs, 0);\r\nreturn do_sigaltstack(uss, uoss, regs->regs[15]);\r\n}\r\nstatic inline int restore_sigcontext_fpu(struct sigcontext __user *sc)\r\n{\r\nstruct task_struct *tsk = current;\r\nif (!(boot_cpu_data.flags & CPU_HAS_FPU))\r\nreturn 0;\r\nset_used_math();\r\nreturn __copy_from_user(&tsk->thread.xstate->hardfpu, &sc->sc_fpregs[0],\r\nsizeof(long)*(16*2+2));\r\n}\r\nstatic inline int save_sigcontext_fpu(struct sigcontext __user *sc,\r\nstruct pt_regs *regs)\r\n{\r\nstruct task_struct *tsk = current;\r\nif (!(boot_cpu_data.flags & CPU_HAS_FPU))\r\nreturn 0;\r\nif (!used_math())\r\nreturn __put_user(0, &sc->sc_ownedfp);\r\nif (__put_user(1, &sc->sc_ownedfp))\r\nreturn -EFAULT;\r\nclear_used_math();\r\nunlazy_fpu(tsk, regs);\r\nreturn __copy_to_user(&sc->sc_fpregs[0], &tsk->thread.xstate->hardfpu,\r\nsizeof(long)*(16*2+2));\r\n}\r\nstatic int\r\nrestore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc, int *r0_p)\r\n{\r\nunsigned int err = 0;\r\n#define COPY(x) err |= __get_user(regs->x, &sc->sc_##x)\r\nCOPY(regs[1]);\r\nCOPY(regs[2]); COPY(regs[3]);\r\nCOPY(regs[4]); COPY(regs[5]);\r\nCOPY(regs[6]); COPY(regs[7]);\r\nCOPY(regs[8]); COPY(regs[9]);\r\nCOPY(regs[10]); COPY(regs[11]);\r\nCOPY(regs[12]); COPY(regs[13]);\r\nCOPY(regs[14]); COPY(regs[15]);\r\nCOPY(gbr); COPY(mach);\r\nCOPY(macl); COPY(pr);\r\nCOPY(sr); COPY(pc);\r\n#undef COPY\r\n#ifdef CONFIG_SH_FPU\r\nif (boot_cpu_data.flags & CPU_HAS_FPU) {\r\nint owned_fp;\r\nstruct task_struct *tsk = current;\r\nregs->sr |= SR_FD;\r\nclear_fpu(tsk, regs);\r\nclear_used_math();\r\nerr |= __get_user (owned_fp, &sc->sc_ownedfp);\r\nif (owned_fp)\r\nerr |= restore_sigcontext_fpu(sc);\r\n}\r\n#endif\r\nregs->tra = -1;\r\nerr |= __get_user(*r0_p, &sc->sc_regs[0]);\r\nreturn err;\r\n}\r\nasmlinkage int sys_sigreturn(unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7,\r\nstruct pt_regs __regs)\r\n{\r\nstruct pt_regs *regs = RELOC_HIDE(&__regs, 0);\r\nstruct sigframe __user *frame = (struct sigframe __user *)regs->regs[15];\r\nsigset_t set;\r\nint r0;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__get_user(set.sig[0], &frame->sc.oldmask)\r\n|| (_NSIG_WORDS > 1\r\n&& __copy_from_user(&set.sig[1], &frame->extramask,\r\nsizeof(frame->extramask))))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (restore_sigcontext(regs, &frame->sc, &r0))\r\ngoto badframe;\r\nreturn r0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nasmlinkage int sys_rt_sigreturn(unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7,\r\nstruct pt_regs __regs)\r\n{\r\nstruct pt_regs *regs = RELOC_HIDE(&__regs, 0);\r\nstruct rt_sigframe __user *frame = (struct rt_sigframe __user *)regs->regs[15];\r\nsigset_t set;\r\nint r0;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (restore_sigcontext(regs, &frame->uc.uc_mcontext, &r0))\r\ngoto badframe;\r\nif (do_sigaltstack(&frame->uc.uc_stack, NULL,\r\nregs->regs[15]) == -EFAULT)\r\ngoto badframe;\r\nreturn r0;\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nstatic int\r\nsetup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\r\nunsigned long mask)\r\n{\r\nint err = 0;\r\n#define COPY(x) err |= __put_user(regs->x, &sc->sc_##x)\r\nCOPY(regs[0]); COPY(regs[1]);\r\nCOPY(regs[2]); COPY(regs[3]);\r\nCOPY(regs[4]); COPY(regs[5]);\r\nCOPY(regs[6]); COPY(regs[7]);\r\nCOPY(regs[8]); COPY(regs[9]);\r\nCOPY(regs[10]); COPY(regs[11]);\r\nCOPY(regs[12]); COPY(regs[13]);\r\nCOPY(regs[14]); COPY(regs[15]);\r\nCOPY(gbr); COPY(mach);\r\nCOPY(macl); COPY(pr);\r\nCOPY(sr); COPY(pc);\r\n#undef COPY\r\n#ifdef CONFIG_SH_FPU\r\nerr |= save_sigcontext_fpu(sc, regs);\r\n#endif\r\nerr |= __put_user(mask, &sc->oldmask);\r\nreturn err;\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, unsigned long sp, size_t frame_size)\r\n{\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (sas_ss_flags(sp) == 0)\r\nsp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nreturn (void __user *)((sp - (frame_size+UNWINDGUARD)) & -8ul);\r\n}\r\nstatic int setup_frame(int sig, struct k_sigaction *ka,\r\nsigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct sigframe __user *frame;\r\nint err = 0;\r\nint signal;\r\nframe = get_sigframe(ka, regs->regs[15], sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\ngoto give_sigsegv;\r\nsignal = current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32\r\n? current_thread_info()->exec_domain->signal_invmap[sig]\r\n: sig;\r\nerr |= setup_sigcontext(&frame->sc, regs, set->sig[0]);\r\nif (_NSIG_WORDS > 1)\r\nerr |= __copy_to_user(frame->extramask, &set->sig[1],\r\nsizeof(frame->extramask));\r\nif (ka->sa.sa_flags & SA_RESTORER) {\r\nregs->pr = (unsigned long) ka->sa.sa_restorer;\r\n#ifdef CONFIG_VSYSCALL\r\n} else if (likely(current->mm->context.vdso)) {\r\nregs->pr = VDSO_SYM(&__kernel_sigreturn);\r\n#endif\r\n} else {\r\nerr |= __put_user(MOVW(7), &frame->retcode[0]);\r\nerr |= __put_user(TRAP_NOARG, &frame->retcode[1]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[2]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[3]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[4]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[5]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[6]);\r\nerr |= __put_user((__NR_sigreturn), &frame->retcode[7]);\r\nregs->pr = (unsigned long) frame->retcode;\r\nflush_icache_range(regs->pr, regs->pr + sizeof(frame->retcode));\r\n}\r\nif (err)\r\ngoto give_sigsegv;\r\nregs->regs[15] = (unsigned long) frame;\r\nregs->regs[4] = signal;\r\nregs->regs[5] = 0;\r\nregs->regs[6] = (unsigned long) &frame->sc;\r\nif (current->personality & FDPIC_FUNCPTRS) {\r\nstruct fdpic_func_descriptor __user *funcptr =\r\n(struct fdpic_func_descriptor __user *)ka->sa.sa_handler;\r\nerr |= __get_user(regs->pc, &funcptr->text);\r\nerr |= __get_user(regs->regs[12], &funcptr->GOT);\r\n} else\r\nregs->pc = (unsigned long)ka->sa.sa_handler;\r\nif (err)\r\ngoto give_sigsegv;\r\nset_fs(USER_DS);\r\npr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",\r\ncurrent->comm, task_pid_nr(current), frame, regs->pc, regs->pr);\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn -EFAULT;\r\n}\r\nstatic int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *set, struct pt_regs *regs)\r\n{\r\nstruct rt_sigframe __user *frame;\r\nint err = 0;\r\nint signal;\r\nframe = get_sigframe(ka, regs->regs[15], sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\r\ngoto give_sigsegv;\r\nsignal = current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32\r\n? current_thread_info()->exec_domain->signal_invmap[sig]\r\n: sig;\r\nerr |= copy_siginfo_to_user(&frame->info, info);\r\nerr |= __put_user(0, &frame->uc.uc_flags);\r\nerr |= __put_user(NULL, &frame->uc.uc_link);\r\nerr |= __put_user((void *)current->sas_ss_sp,\r\n&frame->uc.uc_stack.ss_sp);\r\nerr |= __put_user(sas_ss_flags(regs->regs[15]),\r\n&frame->uc.uc_stack.ss_flags);\r\nerr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= setup_sigcontext(&frame->uc.uc_mcontext,\r\nregs, set->sig[0]);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (ka->sa.sa_flags & SA_RESTORER) {\r\nregs->pr = (unsigned long) ka->sa.sa_restorer;\r\n#ifdef CONFIG_VSYSCALL\r\n} else if (likely(current->mm->context.vdso)) {\r\nregs->pr = VDSO_SYM(&__kernel_rt_sigreturn);\r\n#endif\r\n} else {\r\nerr |= __put_user(MOVW(7), &frame->retcode[0]);\r\nerr |= __put_user(TRAP_NOARG, &frame->retcode[1]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[2]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[3]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[4]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[5]);\r\nerr |= __put_user(OR_R0_R0, &frame->retcode[6]);\r\nerr |= __put_user((__NR_rt_sigreturn), &frame->retcode[7]);\r\nregs->pr = (unsigned long) frame->retcode;\r\nflush_icache_range(regs->pr, regs->pr + sizeof(frame->retcode));\r\n}\r\nif (err)\r\ngoto give_sigsegv;\r\nregs->regs[15] = (unsigned long) frame;\r\nregs->regs[4] = signal;\r\nregs->regs[5] = (unsigned long) &frame->info;\r\nregs->regs[6] = (unsigned long) &frame->uc;\r\nif (current->personality & FDPIC_FUNCPTRS) {\r\nstruct fdpic_func_descriptor __user *funcptr =\r\n(struct fdpic_func_descriptor __user *)ka->sa.sa_handler;\r\nerr |= __get_user(regs->pc, &funcptr->text);\r\nerr |= __get_user(regs->regs[12], &funcptr->GOT);\r\n} else\r\nregs->pc = (unsigned long)ka->sa.sa_handler;\r\nif (err)\r\ngoto give_sigsegv;\r\nset_fs(USER_DS);\r\npr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",\r\ncurrent->comm, task_pid_nr(current), frame, regs->pc, regs->pr);\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn -EFAULT;\r\n}\r\nstatic inline void\r\nhandle_syscall_restart(unsigned long save_r0, struct pt_regs *regs,\r\nstruct sigaction *sa)\r\n{\r\nif (regs->tra < 0)\r\nreturn;\r\nswitch (regs->regs[0]) {\r\ncase -ERESTART_RESTARTBLOCK:\r\ncase -ERESTARTNOHAND:\r\nno_system_call_restart:\r\nregs->regs[0] = -EINTR;\r\nbreak;\r\ncase -ERESTARTSYS:\r\nif (!(sa->sa_flags & SA_RESTART))\r\ngoto no_system_call_restart;\r\ncase -ERESTARTNOINTR:\r\nregs->regs[0] = save_r0;\r\nregs->pc -= instruction_size(__raw_readw(regs->pc - 4));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhandle_signal(unsigned long sig, struct k_sigaction *ka, siginfo_t *info,\r\nstruct pt_regs *regs, unsigned int save_r0)\r\n{\r\nsigset_t *oldset = sigmask_to_save();\r\nint ret;\r\nif (ka->sa.sa_flags & SA_SIGINFO)\r\nret = setup_rt_frame(sig, ka, info, oldset, regs);\r\nelse\r\nret = setup_frame(sig, ka, oldset, regs);\r\nif (ret)\r\nreturn;\r\nsignal_delivered(sig, info, ka, regs,\r\ntest_thread_flag(TIF_SINGLESTEP));\r\n}\r\nstatic void do_signal(struct pt_regs *regs, unsigned int save_r0)\r\n{\r\nsiginfo_t info;\r\nint signr;\r\nstruct k_sigaction ka;\r\nif (!user_mode(regs))\r\nreturn;\r\nsignr = get_signal_to_deliver(&info, &ka, regs, NULL);\r\nif (signr > 0) {\r\nhandle_syscall_restart(save_r0, regs, &ka.sa);\r\nhandle_signal(signr, &ka, &info, regs, save_r0);\r\nreturn;\r\n}\r\nif (regs->tra >= 0) {\r\nif (regs->regs[0] == -ERESTARTNOHAND ||\r\nregs->regs[0] == -ERESTARTSYS ||\r\nregs->regs[0] == -ERESTARTNOINTR) {\r\nregs->regs[0] = save_r0;\r\nregs->pc -= instruction_size(__raw_readw(regs->pc - 4));\r\n} else if (regs->regs[0] == -ERESTART_RESTARTBLOCK) {\r\nregs->pc -= instruction_size(__raw_readw(regs->pc - 4));\r\nregs->regs[3] = __NR_restart_syscall;\r\n}\r\n}\r\nrestore_saved_sigmask();\r\n}\r\nasmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int save_r0,\r\nunsigned long thread_info_flags)\r\n{\r\nif (thread_info_flags & _TIF_SIGPENDING)\r\ndo_signal(regs, save_r0);\r\nif (thread_info_flags & _TIF_NOTIFY_RESUME) {\r\nclear_thread_flag(TIF_NOTIFY_RESUME);\r\ntracehook_notify_resume(regs);\r\n}\r\n}
