int mdfld_set_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev =\r\n(struct drm_device *)bl_get_data(mdfld_backlight_device);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint level = bd->props.brightness;\r\nDRM_DEBUG_DRIVER("backlight level set to %d\n", level);\r\nif (level < BRIGHTNESS_MIN_LEVEL)\r\nlevel = BRIGHTNESS_MIN_LEVEL;\r\nif (gma_power_begin(dev, false)) {\r\nu32 adjusted_level = 0;\r\nadjusted_level = level * dev_priv->blc_adj2;\r\nadjusted_level = adjusted_level / BLC_ADJUSTMENT_MAX;\r\ndev_priv->brightness_adjusted = adjusted_level;\r\nif (mdfld_get_panel_type(dev, 0) == TC35876X) {\r\nif (dev_priv->dpi_panel_on[0] ||\r\ndev_priv->dpi_panel_on[2])\r\ntc35876x_brightness_control(dev,\r\ndev_priv->brightness_adjusted);\r\n} else {\r\nif (dev_priv->dpi_panel_on[0])\r\nmdfld_dsi_brightness_control(dev, 0,\r\ndev_priv->brightness_adjusted);\r\n}\r\nif (dev_priv->dpi_panel_on[2])\r\nmdfld_dsi_brightness_control(dev, 2,\r\ndev_priv->brightness_adjusted);\r\ngma_power_end(dev);\r\n}\r\ndev_priv->brightness = level;\r\nreturn 0;\r\n}\r\nstatic int mdfld_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev =\r\n(struct drm_device *)bl_get_data(mdfld_backlight_device);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nDRM_DEBUG_DRIVER("brightness = 0x%x \n", dev_priv->brightness);\r\nreturn dev_priv->brightness;\r\n}\r\nstatic int device_backlight_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = (struct drm_psb_private *)\r\ndev->dev_private;\r\ndev_priv->blc_adj1 = BLC_ADJUSTMENT_MAX;\r\ndev_priv->blc_adj2 = BLC_ADJUSTMENT_MAX;\r\nreturn 0;\r\n}\r\nstatic int mdfld_backlight_init(struct drm_device *dev)\r\n{\r\nstruct backlight_properties props;\r\nint ret = 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = BRIGHTNESS_MAX_LEVEL;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nmdfld_backlight_device = backlight_device_register("mdfld-bl",\r\nNULL, (void *)dev, &mdfld_ops, &props);\r\nif (IS_ERR(mdfld_backlight_device))\r\nreturn PTR_ERR(mdfld_backlight_device);\r\nret = device_backlight_init(dev);\r\nif (ret)\r\nreturn ret;\r\nmdfld_backlight_device->props.brightness = BRIGHTNESS_MAX_LEVEL;\r\nmdfld_backlight_device->props.max_brightness = BRIGHTNESS_MAX_LEVEL;\r\nbacklight_update_status(mdfld_backlight_device);\r\nreturn 0;\r\n}\r\nstruct backlight_device *mdfld_get_backlight_device(void)\r\n{\r\n#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE\r\nreturn mdfld_backlight_device;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nstatic int mdfld_save_display_registers(struct drm_device *dev, int pipenum)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct medfield_state *regs = &dev_priv->regs.mdfld;\r\nstruct psb_pipe *pipe = &dev_priv->regs.pipe[pipenum];\r\nconst struct psb_offset *map = &dev_priv->regmap[pipenum];\r\nint i;\r\nu32 *mipi_val;\r\nu32 mipi_reg = MIPI;\r\nswitch (pipenum) {\r\ncase 0:\r\nmipi_val = &regs->saveMIPI;\r\nbreak;\r\ncase 1:\r\nmipi_val = &regs->saveMIPI;\r\nbreak;\r\ncase 2:\r\nmipi_reg = MIPI_C;\r\nmipi_val = &regs->saveMIPI_C;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("%s, invalid pipe number.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npipe->dpll = PSB_RVDC32(map->dpll);\r\npipe->fp0 = PSB_RVDC32(map->fp0);\r\npipe->conf = PSB_RVDC32(map->conf);\r\npipe->htotal = PSB_RVDC32(map->htotal);\r\npipe->hblank = PSB_RVDC32(map->hblank);\r\npipe->hsync = PSB_RVDC32(map->hsync);\r\npipe->vtotal = PSB_RVDC32(map->vtotal);\r\npipe->vblank = PSB_RVDC32(map->vblank);\r\npipe->vsync = PSB_RVDC32(map->vsync);\r\npipe->src = PSB_RVDC32(map->src);\r\npipe->stride = PSB_RVDC32(map->stride);\r\npipe->linoff = PSB_RVDC32(map->linoff);\r\npipe->tileoff = PSB_RVDC32(map->tileoff);\r\npipe->size = PSB_RVDC32(map->size);\r\npipe->pos = PSB_RVDC32(map->pos);\r\npipe->surf = PSB_RVDC32(map->surf);\r\npipe->cntr = PSB_RVDC32(map->cntr);\r\npipe->status = PSB_RVDC32(map->status);\r\nfor (i = 0; i < 256; i++)\r\npipe->palette[i] = PSB_RVDC32(map->palette + (i << 2));\r\nif (pipenum == 1) {\r\nregs->savePFIT_CONTROL = PSB_RVDC32(PFIT_CONTROL);\r\nregs->savePFIT_PGM_RATIOS = PSB_RVDC32(PFIT_PGM_RATIOS);\r\nregs->saveHDMIPHYMISCCTL = PSB_RVDC32(HDMIPHYMISCCTL);\r\nregs->saveHDMIB_CONTROL = PSB_RVDC32(HDMIB_CONTROL);\r\nreturn 0;\r\n}\r\n*mipi_val = PSB_RVDC32(mipi_reg);\r\nreturn 0;\r\n}\r\nstatic int mdfld_restore_display_registers(struct drm_device *dev, int pipenum)\r\n{\r\nu32 temp = 0;\r\nu32 device_ready_reg = DEVICE_READY_REG;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct mdfld_dsi_config *dsi_config = NULL;\r\nstruct medfield_state *regs = &dev_priv->regs.mdfld;\r\nstruct psb_pipe *pipe = &dev_priv->regs.pipe[pipenum];\r\nconst struct psb_offset *map = &dev_priv->regmap[pipenum];\r\nu32 i;\r\nu32 dpll;\r\nu32 timeout = 0;\r\nu32 mipi_reg = MIPI;\r\nu32 dpll_val = pipe->dpll;\r\nu32 mipi_val = regs->saveMIPI;\r\nswitch (pipenum) {\r\ncase 0:\r\ndpll_val &= ~DPLL_VCO_ENABLE;\r\ndsi_config = dev_priv->dsi_configs[0];\r\nbreak;\r\ncase 1:\r\ndpll_val &= ~DPLL_VCO_ENABLE;\r\nbreak;\r\ncase 2:\r\nmipi_reg = MIPI_C;\r\nmipi_val = regs->saveMIPI_C;\r\ndsi_config = dev_priv->dsi_configs[1];\r\nbreak;\r\ndefault:\r\nDRM_ERROR("%s, invalid pipe number.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nPSB_WVDC32(0x80000000, VGACNTRL);\r\nif (pipenum == 1) {\r\nPSB_WVDC32(dpll_val & ~DPLL_VCO_ENABLE, map->dpll);\r\nPSB_RVDC32(map->dpll);\r\nPSB_WVDC32(pipe->fp0, map->fp0);\r\n} else {\r\ndpll = PSB_RVDC32(map->dpll);\r\nif (!(dpll & DPLL_VCO_ENABLE)) {\r\nif (dpll & MDFLD_PWR_GATE_EN) {\r\ndpll &= ~MDFLD_PWR_GATE_EN;\r\nPSB_WVDC32(dpll, map->dpll);\r\nudelay(500);\r\n}\r\nPSB_WVDC32(pipe->fp0, map->fp0);\r\nPSB_WVDC32(dpll_val, map->dpll);\r\nudelay(500);\r\ndpll_val |= DPLL_VCO_ENABLE;\r\nPSB_WVDC32(dpll_val, map->dpll);\r\nPSB_RVDC32(map->dpll);\r\nwhile (timeout < 20000 &&\r\n!(PSB_RVDC32(map->conf) & PIPECONF_DSIPLL_LOCK)) {\r\nudelay(150);\r\ntimeout++;\r\n}\r\nif (timeout == 20000) {\r\nDRM_ERROR("%s, can't lock DSIPLL.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nPSB_WVDC32(pipe->htotal, map->htotal);\r\nPSB_WVDC32(pipe->hblank, map->hblank);\r\nPSB_WVDC32(pipe->hsync, map->hsync);\r\nPSB_WVDC32(pipe->vtotal, map->vtotal);\r\nPSB_WVDC32(pipe->vblank, map->vblank);\r\nPSB_WVDC32(pipe->vsync, map->vsync);\r\nPSB_WVDC32(pipe->src, map->src);\r\nPSB_WVDC32(pipe->status, map->status);\r\nPSB_WVDC32(pipe->stride, map->stride);\r\nPSB_WVDC32(pipe->linoff, map->linoff);\r\nPSB_WVDC32(pipe->tileoff, map->tileoff);\r\nPSB_WVDC32(pipe->size, map->size);\r\nPSB_WVDC32(pipe->pos, map->pos);\r\nPSB_WVDC32(pipe->surf, map->surf);\r\nif (pipenum == 1) {\r\nfor (i = 0; i < 256; i++)\r\nPSB_WVDC32(pipe->palette[i], map->palette + (i << 2));\r\nPSB_WVDC32(regs->savePFIT_CONTROL, PFIT_CONTROL);\r\nPSB_WVDC32(regs->savePFIT_PGM_RATIOS, PFIT_PGM_RATIOS);\r\nPSB_WVDC32(pipe->cntr & ~DISPLAY_PLANE_ENABLE, map->cntr);\r\nreturn 0;\r\n}\r\nPSB_WVDC32(mipi_val, mipi_reg);\r\nif (dsi_config)\r\nmdfld_dsi_controller_init(dsi_config, pipenum);\r\nif (in_atomic() || in_interrupt())\r\nmdelay(20);\r\nelse\r\nmsleep(20);\r\nPSB_WVDC32(pipe->cntr, map->cntr);\r\nif (in_atomic() || in_interrupt())\r\nmdelay(20);\r\nelse\r\nmsleep(20);\r\ntemp = REG_READ(mipi_reg);\r\ntemp |= LP_OUTPUT_HOLD_RELEASE;\r\nREG_WRITE(mipi_reg, temp);\r\nmdelay(1);\r\ntemp = REG_READ(device_ready_reg);\r\ntemp &= ~ULPS_MASK;\r\ntemp |= 0x3;\r\ntemp |= EXIT_ULPS_DEV_READY;\r\nREG_WRITE(device_ready_reg, temp);\r\nmdelay(1);\r\ntemp = REG_READ(device_ready_reg);\r\ntemp &= ~ULPS_MASK;\r\ntemp |= EXITING_ULPS;\r\nREG_WRITE(device_ready_reg, temp);\r\nmdelay(1);\r\nPSB_WVDC32(pipe->conf, map->conf);\r\nfor (i = 0; i < 256; i++)\r\nPSB_WVDC32(pipe->palette[i], map->palette + (i << 2));\r\nreturn 0;\r\n}\r\nstatic int mdfld_save_registers(struct drm_device *dev)\r\n{\r\nmdfld_save_display_registers(dev, 0);\r\nmdfld_save_display_registers(dev, 2);\r\nmdfld_disable_crtc(dev, 0);\r\nmdfld_disable_crtc(dev, 2);\r\nreturn 0;\r\n}\r\nstatic int mdfld_restore_registers(struct drm_device *dev)\r\n{\r\nmdfld_restore_display_registers(dev, 2);\r\nmdfld_restore_display_registers(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int mdfld_power_down(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mdfld_power_up(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mdfld_chip_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (pci_enable_msi(dev->pdev))\r\ndev_warn(dev->dev, "Enabling MSI failed!\n");\r\ndev_priv->regmap = mdfld_regmap;\r\nreturn mid_chip_setup(dev);\r\n}
