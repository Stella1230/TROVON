int dm355evm_msp_write(u8 value, u8 reg)\r\n{\r\nreturn i2c_smbus_write_byte_data(msp430, reg, value);\r\n}\r\nint dm355evm_msp_read(u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(msp430, reg);\r\n}\r\nstatic int msp_gpio_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nswitch (MSP_GPIO_REG(offset)) {\r\ncase DM355EVM_MSP_SWITCH1:\r\ncase DM355EVM_MSP_SWITCH2:\r\ncase DM355EVM_MSP_SDMMC:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int msp_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint reg, status;\r\nreg = MSP_GPIO_REG(offset);\r\nstatus = dm355evm_msp_read(reg);\r\nif (status < 0)\r\nreturn status;\r\nif (reg == DM355EVM_MSP_LED)\r\nmsp_led_cache = status;\r\nreturn status & MSP_GPIO_MASK(offset);\r\n}\r\nstatic int msp_gpio_out(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nint mask, bits;\r\nif (MSP_GPIO_REG(offset) != DM355EVM_MSP_LED)\r\nreturn -EINVAL;\r\nmask = MSP_GPIO_MASK(offset);\r\nbits = msp_led_cache;\r\nbits &= ~mask;\r\nif (value)\r\nbits |= mask;\r\nmsp_led_cache = bits;\r\nreturn dm355evm_msp_write(bits, DM355EVM_MSP_LED);\r\n}\r\nstatic void msp_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nmsp_gpio_out(chip, offset, value);\r\n}\r\nstatic struct device *add_child(struct i2c_client *client, const char *name,\r\nvoid *pdata, unsigned pdata_len,\r\nbool can_wakeup, int irq)\r\n{\r\nstruct platform_device *pdev;\r\nint status;\r\npdev = platform_device_alloc(name, -1);\r\nif (!pdev) {\r\ndev_dbg(&client->dev, "can't alloc dev\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\ndevice_init_wakeup(&pdev->dev, can_wakeup);\r\npdev->dev.parent = &client->dev;\r\nif (pdata) {\r\nstatus = platform_device_add_data(pdev, pdata, pdata_len);\r\nif (status < 0) {\r\ndev_dbg(&pdev->dev, "can't add platform_data\n");\r\ngoto err;\r\n}\r\n}\r\nif (irq) {\r\nstruct resource r = {\r\n.start = irq,\r\n.flags = IORESOURCE_IRQ,\r\n};\r\nstatus = platform_device_add_resources(pdev, &r, 1);\r\nif (status < 0) {\r\ndev_dbg(&pdev->dev, "can't add irq\n");\r\ngoto err;\r\n}\r\n}\r\nstatus = platform_device_add(pdev);\r\nerr:\r\nif (status < 0) {\r\nplatform_device_put(pdev);\r\ndev_err(&client->dev, "can't add %s dev\n", name);\r\nreturn ERR_PTR(status);\r\n}\r\nreturn &pdev->dev;\r\n}\r\nstatic int add_children(struct i2c_client *client)\r\n{\r\nstatic const struct {\r\nint offset;\r\nchar *label;\r\n} config_inputs[] = {\r\n{ 8 + 0, "sw6_1", },\r\n{ 8 + 1, "sw6_2", },\r\n{ 8 + 2, "sw6_3", },\r\n{ 8 + 3, "sw6_4", },\r\n{ 8 + 4, "NTSC/nPAL", },\r\n};\r\nstruct device *child;\r\nint status;\r\nint i;\r\ndm355evm_msp_gpio.dev = &client->dev;\r\nstatus = gpiochip_add(&dm355evm_msp_gpio);\r\nif (status < 0)\r\nreturn status;\r\nif (msp_has_leds()) {\r\n#define GPIO_LED(l) .name = l, .active_low = true\r\nstatic struct gpio_led evm_leds[] = {\r\n{ GPIO_LED("dm355evm::ds14"),\r\n.default_trigger = "heartbeat", },\r\n{ GPIO_LED("dm355evm::ds15"),\r\n.default_trigger = "mmc0", },\r\n{ GPIO_LED("dm355evm::ds16"),\r\n.default_trigger = "mmc1", },\r\n{ GPIO_LED("dm355evm::ds17"),\r\n.default_trigger = "nand-disk", },\r\n{ GPIO_LED("dm355evm::ds18"), },\r\n{ GPIO_LED("dm355evm::ds19"), },\r\n{ GPIO_LED("dm355evm::ds20"), },\r\n{ GPIO_LED("dm355evm::ds21"), },\r\n};\r\n#undef GPIO_LED\r\nstruct gpio_led_platform_data evm_led_data = {\r\n.num_leds = ARRAY_SIZE(evm_leds),\r\n.leds = evm_leds,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(evm_leds); i++)\r\nevm_leds[i].gpio = i + dm355evm_msp_gpio.base;\r\nchild = add_child(client, "leds-gpio",\r\n&evm_led_data, sizeof(evm_led_data),\r\nfalse, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(config_inputs); i++) {\r\nint gpio = dm355evm_msp_gpio.base + config_inputs[i].offset;\r\ngpio_request_one(gpio, GPIOF_IN, config_inputs[i].label);\r\ngpio_export(gpio, false);\r\n}\r\nif (client->dev.platform_data) {\r\nvoid (*mmcsd_setup)(unsigned) = client->dev.platform_data;\r\nmmcsd_setup(dm355evm_msp_gpio.base + 8 + 5);\r\n}\r\nif (msp_has_rtc()) {\r\nchild = add_child(client, "rtc-dm355evm",\r\nNULL, 0, false, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (msp_has_keyboard()) {\r\nchild = add_child(client, "dm355evm_keys",\r\nNULL, 0, true, client->irq);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dm355evm_command(unsigned command)\r\n{\r\nint status;\r\nstatus = dm355evm_msp_write(command, DM355EVM_MSP_COMMAND);\r\nif (status < 0)\r\ndev_err(&msp430->dev, "command %d failure %d\n",\r\ncommand, status);\r\n}\r\nstatic void dm355evm_power_off(void)\r\n{\r\ndm355evm_command(MSP_COMMAND_POWEROFF);\r\n}\r\nstatic int dm355evm_msp_remove(struct i2c_client *client)\r\n{\r\npm_power_off = NULL;\r\nmsp430 = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\ndm355evm_msp_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nint status;\r\nconst char *video = msp_has_tvp() ? "TVP5146" : "imager";\r\nif (msp430)\r\nreturn -EBUSY;\r\nmsp430 = client;\r\nstatus = dm355evm_msp_read(DM355EVM_MSP_FIRMREV);\r\nif (status < 0)\r\ngoto fail;\r\ndev_info(&client->dev, "firmware v.%02X, %s as video-in\n",\r\nstatus, video);\r\nstatus = dm355evm_msp_write(msp_has_tvp() ? 0 : MSP_VIDEO_IMAGER,\r\nDM355EVM_MSP_VIDEO_IN);\r\nif (status < 0)\r\ndev_warn(&client->dev, "error %d muxing %s as video-in\n",\r\nstatus, video);\r\nmsp_led_cache = 0xff;\r\ndm355evm_msp_write(msp_led_cache, DM355EVM_MSP_LED);\r\nstatus = add_children(client);\r\nif (status < 0)\r\ngoto fail;\r\npm_power_off = dm355evm_power_off;\r\nreturn 0;\r\nfail:\r\ndm355evm_msp_remove(client);\r\nreturn status;\r\n}\r\nstatic int __init dm355evm_msp_init(void)\r\n{\r\nreturn i2c_add_driver(&dm355evm_msp_driver);\r\n}\r\nstatic void __exit dm355evm_msp_exit(void)\r\n{\r\ni2c_del_driver(&dm355evm_msp_driver);\r\n}
