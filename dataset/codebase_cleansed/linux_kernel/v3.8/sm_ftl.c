ssize_t sm_attr_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sm_sysfs_attribute *sm_attr =\r\ncontainer_of(attr, struct sm_sysfs_attribute, dev_attr);\r\nstrncpy(buf, sm_attr->data, sm_attr->len);\r\nreturn sm_attr->len;\r\n}\r\nstruct attribute_group *sm_create_sysfs_attributes(struct sm_ftl *ftl)\r\n{\r\nstruct attribute_group *attr_group;\r\nstruct attribute **attributes;\r\nstruct sm_sysfs_attribute *vendor_attribute;\r\nint vendor_len = strnlen(ftl->cis_buffer + SM_CIS_VENDOR_OFFSET,\r\nSM_SMALL_PAGE - SM_CIS_VENDOR_OFFSET);\r\nchar *vendor = kmalloc(vendor_len, GFP_KERNEL);\r\nif (!vendor)\r\ngoto error1;\r\nmemcpy(vendor, ftl->cis_buffer + SM_CIS_VENDOR_OFFSET, vendor_len);\r\nvendor[vendor_len] = 0;\r\nvendor_attribute =\r\nkzalloc(sizeof(struct sm_sysfs_attribute), GFP_KERNEL);\r\nif (!vendor_attribute)\r\ngoto error2;\r\nsysfs_attr_init(&vendor_attribute->dev_attr.attr);\r\nvendor_attribute->data = vendor;\r\nvendor_attribute->len = vendor_len;\r\nvendor_attribute->dev_attr.attr.name = "vendor";\r\nvendor_attribute->dev_attr.attr.mode = S_IRUGO;\r\nvendor_attribute->dev_attr.show = sm_attr_show;\r\nattributes = kzalloc(sizeof(struct attribute *) * (NUM_ATTRIBUTES + 1),\r\nGFP_KERNEL);\r\nif (!attributes)\r\ngoto error3;\r\nattributes[0] = &vendor_attribute->dev_attr.attr;\r\nattr_group = kzalloc(sizeof(struct attribute_group), GFP_KERNEL);\r\nif (!attr_group)\r\ngoto error4;\r\nattr_group->attrs = attributes;\r\nreturn attr_group;\r\nerror4:\r\nkfree(attributes);\r\nerror3:\r\nkfree(vendor_attribute);\r\nerror2:\r\nkfree(vendor);\r\nerror1:\r\nreturn NULL;\r\n}\r\nvoid sm_delete_sysfs_attributes(struct sm_ftl *ftl)\r\n{\r\nstruct attribute **attributes = ftl->disk_attributes->attrs;\r\nint i;\r\nfor (i = 0; attributes[i] ; i++) {\r\nstruct device_attribute *dev_attr = container_of(attributes[i],\r\nstruct device_attribute, attr);\r\nstruct sm_sysfs_attribute *sm_attr =\r\ncontainer_of(dev_attr,\r\nstruct sm_sysfs_attribute, dev_attr);\r\nkfree(sm_attr->data);\r\nkfree(sm_attr);\r\n}\r\nkfree(ftl->disk_attributes->attrs);\r\nkfree(ftl->disk_attributes);\r\n}\r\nstatic int sm_get_lba(uint8_t *lba)\r\n{\r\nif ((lba[0] & 0xF8) != 0x10)\r\nreturn -2;\r\nif (hweight16(*(uint16_t *)lba) & 1)\r\nreturn -2;\r\nreturn (lba[1] >> 1) | ((lba[0] & 0x07) << 7);\r\n}\r\nstatic int sm_read_lba(struct sm_oob *oob)\r\n{\r\nstatic const uint32_t erased_pattern[4] = {\r\n0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\r\nuint16_t lba_test;\r\nint lba;\r\nif (!memcmp(oob, erased_pattern, SM_OOB_SIZE))\r\nreturn -1;\r\nlba_test = *(uint16_t *)oob->lba_copy1 ^ *(uint16_t*)oob->lba_copy2;\r\nif (lba_test && !is_power_of_2(lba_test))\r\nreturn -2;\r\nlba = sm_get_lba(oob->lba_copy1);\r\nif (lba == -2)\r\nlba = sm_get_lba(oob->lba_copy2);\r\nreturn lba;\r\n}\r\nstatic void sm_write_lba(struct sm_oob *oob, uint16_t lba)\r\n{\r\nuint8_t tmp[2];\r\nWARN_ON(lba >= 1000);\r\ntmp[0] = 0x10 | ((lba >> 7) & 0x07);\r\ntmp[1] = (lba << 1) & 0xFF;\r\nif (hweight16(*(uint16_t *)tmp) & 0x01)\r\ntmp[1] |= 1;\r\noob->lba_copy1[0] = oob->lba_copy2[0] = tmp[0];\r\noob->lba_copy1[1] = oob->lba_copy2[1] = tmp[1];\r\n}\r\nstatic loff_t sm_mkoffset(struct sm_ftl *ftl, int zone, int block, int boffset)\r\n{\r\nWARN_ON(boffset & (SM_SECTOR_SIZE - 1));\r\nWARN_ON(zone < 0 || zone >= ftl->zone_count);\r\nWARN_ON(block >= ftl->zone_size);\r\nWARN_ON(boffset >= ftl->block_size);\r\nif (block == -1)\r\nreturn -1;\r\nreturn (zone * SM_MAX_ZONE_SIZE + block) * ftl->block_size + boffset;\r\n}\r\nstatic void sm_break_offset(struct sm_ftl *ftl, loff_t offset,\r\nint *zone, int *block, int *boffset)\r\n{\r\n*boffset = do_div(offset, ftl->block_size);\r\n*block = do_div(offset, ftl->max_lba);\r\n*zone = offset >= ftl->zone_count ? -1 : offset;\r\n}\r\nstatic int sm_correct_sector(uint8_t *buffer, struct sm_oob *oob)\r\n{\r\nuint8_t ecc[3];\r\n__nand_calculate_ecc(buffer, SM_SMALL_PAGE, ecc);\r\nif (__nand_correct_data(buffer, ecc, oob->ecc1, SM_SMALL_PAGE) < 0)\r\nreturn -EIO;\r\nbuffer += SM_SMALL_PAGE;\r\n__nand_calculate_ecc(buffer, SM_SMALL_PAGE, ecc);\r\nif (__nand_correct_data(buffer, ecc, oob->ecc2, SM_SMALL_PAGE) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int sm_read_sector(struct sm_ftl *ftl,\r\nint zone, int block, int boffset,\r\nuint8_t *buffer, struct sm_oob *oob)\r\n{\r\nstruct mtd_info *mtd = ftl->trans->mtd;\r\nstruct mtd_oob_ops ops;\r\nstruct sm_oob tmp_oob;\r\nint ret = -EIO;\r\nint try = 0;\r\nif (block == -1) {\r\nmemset(buffer, 0xFF, SM_SECTOR_SIZE);\r\nreturn 0;\r\n}\r\nif (!oob)\r\noob = &tmp_oob;\r\nops.mode = ftl->smallpagenand ? MTD_OPS_RAW : MTD_OPS_PLACE_OOB;\r\nops.ooboffs = 0;\r\nops.ooblen = SM_OOB_SIZE;\r\nops.oobbuf = (void *)oob;\r\nops.len = SM_SECTOR_SIZE;\r\nops.datbuf = buffer;\r\nagain:\r\nif (try++) {\r\nif (zone == 0 && block == ftl->cis_block && boffset ==\r\nftl->cis_boffset)\r\nreturn ret;\r\nif (try == 3 || sm_recheck_media(ftl))\r\nreturn ret;\r\n}\r\nret = mtd_read_oob(mtd, sm_mkoffset(ftl, zone, block, boffset), &ops);\r\nif (ret != 0 && !mtd_is_bitflip_or_eccerr(ret)) {\r\ndbg("read of block %d at zone %d, failed due to error (%d)",\r\nblock, zone, ret);\r\ngoto again;\r\n}\r\nif (oob->reserved != 0xFFFFFFFF && !is_power_of_2(~oob->reserved))\r\ngoto again;\r\nWARN_ON(ops.oobretlen != SM_OOB_SIZE);\r\nWARN_ON(buffer && ops.retlen != SM_SECTOR_SIZE);\r\nif (!buffer)\r\nreturn 0;\r\nif (!sm_sector_valid(oob)) {\r\ndbg("read of block %d at zone %d, failed because it is marked"\r\n" as bad" , block, zone);\r\ngoto again;\r\n}\r\nif (mtd_is_eccerr(ret) ||\r\n(ftl->smallpagenand && sm_correct_sector(buffer, oob))) {\r\ndbg("read of block %d at zone %d, failed due to ECC error",\r\nblock, zone);\r\ngoto again;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sm_write_sector(struct sm_ftl *ftl,\r\nint zone, int block, int boffset,\r\nuint8_t *buffer, struct sm_oob *oob)\r\n{\r\nstruct mtd_oob_ops ops;\r\nstruct mtd_info *mtd = ftl->trans->mtd;\r\nint ret;\r\nBUG_ON(ftl->readonly);\r\nif (zone == 0 && (block == ftl->cis_block || block == 0)) {\r\ndbg("attempted to write the CIS!");\r\nreturn -EIO;\r\n}\r\nif (ftl->unstable)\r\nreturn -EIO;\r\nops.mode = ftl->smallpagenand ? MTD_OPS_RAW : MTD_OPS_PLACE_OOB;\r\nops.len = SM_SECTOR_SIZE;\r\nops.datbuf = buffer;\r\nops.ooboffs = 0;\r\nops.ooblen = SM_OOB_SIZE;\r\nops.oobbuf = (void *)oob;\r\nret = mtd_write_oob(mtd, sm_mkoffset(ftl, zone, block, boffset), &ops);\r\nif (ret) {\r\ndbg("write to block %d at zone %d, failed with error %d",\r\nblock, zone, ret);\r\nsm_recheck_media(ftl);\r\nreturn ret;\r\n}\r\nWARN_ON(ops.oobretlen != SM_OOB_SIZE);\r\nWARN_ON(buffer && ops.retlen != SM_SECTOR_SIZE);\r\nreturn 0;\r\n}\r\nstatic int sm_write_block(struct sm_ftl *ftl, uint8_t *buf,\r\nint zone, int block, int lba,\r\nunsigned long invalid_bitmap)\r\n{\r\nstruct sm_oob oob;\r\nint boffset;\r\nint retry = 0;\r\nmemset(&oob, 0xFF, SM_OOB_SIZE);\r\nsm_write_lba(&oob, lba);\r\nrestart:\r\nif (ftl->unstable)\r\nreturn -EIO;\r\nfor (boffset = 0; boffset < ftl->block_size;\r\nboffset += SM_SECTOR_SIZE) {\r\noob.data_status = 0xFF;\r\nif (test_bit(boffset / SM_SECTOR_SIZE, &invalid_bitmap)) {\r\nsm_printk("sector %d of block at LBA %d of zone %d"\r\n" coudn't be read, marking it as invalid",\r\nboffset / SM_SECTOR_SIZE, lba, zone);\r\noob.data_status = 0;\r\n}\r\nif (ftl->smallpagenand) {\r\n__nand_calculate_ecc(buf + boffset,\r\nSM_SMALL_PAGE, oob.ecc1);\r\n__nand_calculate_ecc(buf + boffset + SM_SMALL_PAGE,\r\nSM_SMALL_PAGE, oob.ecc2);\r\n}\r\nif (!sm_write_sector(ftl, zone, block, boffset,\r\nbuf + boffset, &oob))\r\ncontinue;\r\nif (!retry) {\r\nif (sm_erase_block(ftl, zone, block, 0))\r\nreturn -EIO;\r\nretry = 1;\r\ngoto restart;\r\n} else {\r\nsm_mark_block_bad(ftl, zone, block);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sm_mark_block_bad(struct sm_ftl *ftl, int zone, int block)\r\n{\r\nstruct sm_oob oob;\r\nint boffset;\r\nmemset(&oob, 0xFF, SM_OOB_SIZE);\r\noob.block_status = 0xF0;\r\nif (ftl->unstable)\r\nreturn;\r\nif (sm_recheck_media(ftl))\r\nreturn;\r\nsm_printk("marking block %d of zone %d as bad", block, zone);\r\nfor (boffset = 0; boffset < ftl->block_size; boffset += SM_SECTOR_SIZE)\r\nsm_write_sector(ftl, zone, block, boffset, NULL, &oob);\r\n}\r\nstatic int sm_erase_block(struct sm_ftl *ftl, int zone_num, uint16_t block,\r\nint put_free)\r\n{\r\nstruct ftl_zone *zone = &ftl->zones[zone_num];\r\nstruct mtd_info *mtd = ftl->trans->mtd;\r\nstruct erase_info erase;\r\nerase.mtd = mtd;\r\nerase.callback = sm_erase_callback;\r\nerase.addr = sm_mkoffset(ftl, zone_num, block, 0);\r\nerase.len = ftl->block_size;\r\nerase.priv = (u_long)ftl;\r\nif (ftl->unstable)\r\nreturn -EIO;\r\nBUG_ON(ftl->readonly);\r\nif (zone_num == 0 && (block == ftl->cis_block || block == 0)) {\r\nsm_printk("attempted to erase the CIS!");\r\nreturn -EIO;\r\n}\r\nif (mtd_erase(mtd, &erase)) {\r\nsm_printk("erase of block %d in zone %d failed",\r\nblock, zone_num);\r\ngoto error;\r\n}\r\nif (erase.state == MTD_ERASE_PENDING)\r\nwait_for_completion(&ftl->erase_completion);\r\nif (erase.state != MTD_ERASE_DONE) {\r\nsm_printk("erase of block %d in zone %d failed after wait",\r\nblock, zone_num);\r\ngoto error;\r\n}\r\nif (put_free)\r\nkfifo_in(&zone->free_sectors,\r\n(const unsigned char *)&block, sizeof(block));\r\nreturn 0;\r\nerror:\r\nsm_mark_block_bad(ftl, zone_num, block);\r\nreturn -EIO;\r\n}\r\nstatic void sm_erase_callback(struct erase_info *self)\r\n{\r\nstruct sm_ftl *ftl = (struct sm_ftl *)self->priv;\r\ncomplete(&ftl->erase_completion);\r\n}\r\nstatic int sm_check_block(struct sm_ftl *ftl, int zone, int block)\r\n{\r\nint boffset;\r\nstruct sm_oob oob;\r\nint lbas[] = { -3, 0, 0, 0 };\r\nint i = 0;\r\nint test_lba;\r\nfor (boffset = 0; boffset < ftl->block_size;\r\nboffset += SM_SECTOR_SIZE) {\r\nif (sm_read_sector(ftl, zone, block, boffset, NULL, &oob))\r\nreturn -2;\r\ntest_lba = sm_read_lba(&oob);\r\nif (lbas[i] != test_lba)\r\nlbas[++i] = test_lba;\r\nif (i == 3)\r\nreturn -EIO;\r\n}\r\nif (i == 2) {\r\nsm_erase_block(ftl, zone, block, 1);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint sm_get_media_info(struct sm_ftl *ftl, struct mtd_info *mtd)\r\n{\r\nint i;\r\nint size_in_megs = mtd->size / (1024 * 1024);\r\nftl->readonly = mtd->type == MTD_ROM;\r\nftl->zone_count = 1;\r\nftl->smallpagenand = 0;\r\nswitch (size_in_megs) {\r\ncase 1:\r\nftl->zone_size = 256;\r\nftl->max_lba = 250;\r\nftl->block_size = 8 * SM_SECTOR_SIZE;\r\nftl->smallpagenand = 1;\r\nbreak;\r\ncase 2:\r\nif (mtd->writesize == SM_SMALL_PAGE) {\r\nftl->zone_size = 512;\r\nftl->max_lba = 500;\r\nftl->block_size = 8 * SM_SECTOR_SIZE;\r\nftl->smallpagenand = 1;\r\n} else {\r\nif (!ftl->readonly)\r\nreturn -ENODEV;\r\nftl->zone_size = 256;\r\nftl->max_lba = 250;\r\nftl->block_size = 16 * SM_SECTOR_SIZE;\r\n}\r\nbreak;\r\ncase 4:\r\nftl->zone_size = 512;\r\nftl->max_lba = 500;\r\nftl->block_size = 16 * SM_SECTOR_SIZE;\r\nbreak;\r\ncase 8:\r\nftl->zone_size = 1024;\r\nftl->max_lba = 1000;\r\nftl->block_size = 16 * SM_SECTOR_SIZE;\r\n}\r\nif (size_in_megs >= 16) {\r\nftl->zone_count = size_in_megs / 16;\r\nftl->zone_size = 1024;\r\nftl->max_lba = 1000;\r\nftl->block_size = 32 * SM_SECTOR_SIZE;\r\n}\r\nif (mtd->erasesize > ftl->block_size)\r\nreturn -ENODEV;\r\nif (mtd->writesize > SM_SECTOR_SIZE)\r\nreturn -ENODEV;\r\nif (ftl->smallpagenand && mtd->oobsize < SM_SMALL_OOB_SIZE)\r\nreturn -ENODEV;\r\nif (!ftl->smallpagenand && mtd->oobsize < SM_OOB_SIZE)\r\nreturn -ENODEV;\r\nif (!mtd_has_oob(mtd))\r\nreturn -ENODEV;\r\nfor (i = 0 ; i < ARRAY_SIZE(chs_table) ; i++) {\r\nif (chs_table[i].size == size_in_megs) {\r\nftl->cylinders = chs_table[i].cyl;\r\nftl->heads = chs_table[i].head;\r\nftl->sectors = chs_table[i].sec;\r\nreturn 0;\r\n}\r\n}\r\nsm_printk("media has unknown size : %dMiB", size_in_megs);\r\nftl->cylinders = 985;\r\nftl->heads = 33;\r\nftl->sectors = 63;\r\nreturn 0;\r\n}\r\nstatic int sm_read_cis(struct sm_ftl *ftl)\r\n{\r\nstruct sm_oob oob;\r\nif (sm_read_sector(ftl,\r\n0, ftl->cis_block, ftl->cis_boffset, ftl->cis_buffer, &oob))\r\nreturn -EIO;\r\nif (!sm_sector_valid(&oob) || !sm_block_valid(&oob))\r\nreturn -EIO;\r\nif (!memcmp(ftl->cis_buffer + ftl->cis_page_offset,\r\ncis_signature, sizeof(cis_signature))) {\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int sm_find_cis(struct sm_ftl *ftl)\r\n{\r\nstruct sm_oob oob;\r\nint block, boffset;\r\nint block_found = 0;\r\nint cis_found = 0;\r\nfor (block = 0 ; block < ftl->zone_size - ftl->max_lba ; block++) {\r\nif (sm_read_sector(ftl, 0, block, 0, NULL, &oob))\r\ncontinue;\r\nif (!sm_block_valid(&oob))\r\ncontinue;\r\nblock_found = 1;\r\nbreak;\r\n}\r\nif (!block_found)\r\nreturn -EIO;\r\nfor (boffset = 0 ; boffset < ftl->block_size;\r\nboffset += SM_SECTOR_SIZE) {\r\nif (sm_read_sector(ftl, 0, block, boffset, NULL, &oob))\r\ncontinue;\r\nif (!sm_sector_valid(&oob))\r\ncontinue;\r\nbreak;\r\n}\r\nif (boffset == ftl->block_size)\r\nreturn -EIO;\r\nftl->cis_block = block;\r\nftl->cis_boffset = boffset;\r\nftl->cis_page_offset = 0;\r\ncis_found = !sm_read_cis(ftl);\r\nif (!cis_found) {\r\nftl->cis_page_offset = SM_SMALL_PAGE;\r\ncis_found = !sm_read_cis(ftl);\r\n}\r\nif (cis_found) {\r\ndbg("CIS block found at offset %x",\r\nblock * ftl->block_size +\r\nboffset + ftl->cis_page_offset);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int sm_recheck_media(struct sm_ftl *ftl)\r\n{\r\nif (sm_read_cis(ftl)) {\r\nif (!ftl->unstable) {\r\nsm_printk("media unstable, not allowing writes");\r\nftl->unstable = 1;\r\n}\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sm_init_zone(struct sm_ftl *ftl, int zone_num)\r\n{\r\nstruct ftl_zone *zone = &ftl->zones[zone_num];\r\nstruct sm_oob oob;\r\nuint16_t block;\r\nint lba;\r\nint i = 0;\r\nint len;\r\ndbg("initializing zone %d", zone_num);\r\nzone->lba_to_phys_table = kmalloc(ftl->max_lba * 2, GFP_KERNEL);\r\nif (!zone->lba_to_phys_table)\r\nreturn -ENOMEM;\r\nmemset(zone->lba_to_phys_table, -1, ftl->max_lba * 2);\r\nif (kfifo_alloc(&zone->free_sectors, ftl->zone_size * 2, GFP_KERNEL)) {\r\nkfree(zone->lba_to_phys_table);\r\nreturn -ENOMEM;\r\n}\r\nfor (block = 0 ; block < ftl->zone_size ; block++) {\r\nif (zone_num == 0 && block <= ftl->cis_block)\r\ncontinue;\r\nif (sm_read_sector(ftl, zone_num, block, 0, NULL, &oob))\r\nreturn -EIO;\r\nif (sm_block_erased(&oob)) {\r\nkfifo_in(&zone->free_sectors,\r\n(unsigned char *)&block, 2);\r\ncontinue;\r\n}\r\nif (!sm_block_valid(&oob)) {\r\ndbg("PH %04d <-> <marked bad>", block);\r\ncontinue;\r\n}\r\nlba = sm_read_lba(&oob);\r\nif (lba == -2 || lba >= ftl->max_lba) {\r\ndbg("PH %04d <-> LBA %04d(bad)", block, lba);\r\ncontinue;\r\n}\r\nif (zone->lba_to_phys_table[lba] < 0) {\r\ndbg_verbose("PH %04d <-> LBA %04d", block, lba);\r\nzone->lba_to_phys_table[lba] = block;\r\ncontinue;\r\n}\r\nsm_printk("collision"\r\n" of LBA %d between blocks %d and %d in zone %d",\r\nlba, zone->lba_to_phys_table[lba], block, zone_num);\r\nif (sm_check_block(ftl, zone_num, block))\r\ncontinue;\r\nif (sm_check_block(ftl, zone_num,\r\nzone->lba_to_phys_table[lba])) {\r\nzone->lba_to_phys_table[lba] = block;\r\ncontinue;\r\n}\r\nsm_printk("both blocks are valid, erasing the later");\r\nsm_erase_block(ftl, zone_num, block, 1);\r\n}\r\ndbg("zone initialized");\r\nzone->initialized = 1;\r\nif (!kfifo_len(&zone->free_sectors)) {\r\nsm_printk("no free blocks in zone %d", zone_num);\r\nreturn 0;\r\n}\r\nget_random_bytes(&i, 2);\r\ni %= (kfifo_len(&zone->free_sectors) / 2);\r\nwhile (i--) {\r\nlen = kfifo_out(&zone->free_sectors,\r\n(unsigned char *)&block, 2);\r\nWARN_ON(len != 2);\r\nkfifo_in(&zone->free_sectors, (const unsigned char *)&block, 2);\r\n}\r\nreturn 0;\r\n}\r\nstruct ftl_zone *sm_get_zone(struct sm_ftl *ftl, int zone_num)\r\n{\r\nstruct ftl_zone *zone;\r\nint error;\r\nBUG_ON(zone_num >= ftl->zone_count);\r\nzone = &ftl->zones[zone_num];\r\nif (!zone->initialized) {\r\nerror = sm_init_zone(ftl, zone_num);\r\nif (error)\r\nreturn ERR_PTR(error);\r\n}\r\nreturn zone;\r\n}\r\nvoid sm_cache_init(struct sm_ftl *ftl)\r\n{\r\nftl->cache_data_invalid_bitmap = 0xFFFFFFFF;\r\nftl->cache_clean = 1;\r\nftl->cache_zone = -1;\r\nftl->cache_block = -1;\r\n}\r\nvoid sm_cache_put(struct sm_ftl *ftl, char *buffer, int boffset)\r\n{\r\nmemcpy(ftl->cache_data + boffset, buffer, SM_SECTOR_SIZE);\r\nclear_bit(boffset / SM_SECTOR_SIZE, &ftl->cache_data_invalid_bitmap);\r\nftl->cache_clean = 0;\r\n}\r\nint sm_cache_get(struct sm_ftl *ftl, char *buffer, int boffset)\r\n{\r\nif (test_bit(boffset / SM_SECTOR_SIZE,\r\n&ftl->cache_data_invalid_bitmap))\r\nreturn -1;\r\nmemcpy(buffer, ftl->cache_data + boffset, SM_SECTOR_SIZE);\r\nreturn 0;\r\n}\r\nint sm_cache_flush(struct sm_ftl *ftl)\r\n{\r\nstruct ftl_zone *zone;\r\nint sector_num;\r\nuint16_t write_sector;\r\nint zone_num = ftl->cache_zone;\r\nint block_num;\r\nif (ftl->cache_clean)\r\nreturn 0;\r\nif (ftl->unstable)\r\nreturn -EIO;\r\nBUG_ON(zone_num < 0);\r\nzone = &ftl->zones[zone_num];\r\nblock_num = zone->lba_to_phys_table[ftl->cache_block];\r\nfor_each_set_bit(sector_num, &ftl->cache_data_invalid_bitmap,\r\nftl->block_size / SM_SECTOR_SIZE) {\r\nif (!sm_read_sector(ftl,\r\nzone_num, block_num, sector_num * SM_SECTOR_SIZE,\r\nftl->cache_data + sector_num * SM_SECTOR_SIZE, NULL))\r\nclear_bit(sector_num,\r\n&ftl->cache_data_invalid_bitmap);\r\n}\r\nrestart:\r\nif (ftl->unstable)\r\nreturn -EIO;\r\nif (kfifo_out(&zone->free_sectors,\r\n(unsigned char *)&write_sector, 2) != 2) {\r\ndbg("no free sectors for write!");\r\nreturn -EIO;\r\n}\r\nif (sm_write_block(ftl, ftl->cache_data, zone_num, write_sector,\r\nftl->cache_block, ftl->cache_data_invalid_bitmap))\r\ngoto restart;\r\nzone->lba_to_phys_table[ftl->cache_block] = write_sector;\r\nif (block_num > 0)\r\nsm_erase_block(ftl, zone_num, block_num, 1);\r\nsm_cache_init(ftl);\r\nreturn 0;\r\n}\r\nstatic void sm_cache_flush_timer(unsigned long data)\r\n{\r\nstruct sm_ftl *ftl = (struct sm_ftl *)data;\r\nqueue_work(cache_flush_workqueue, &ftl->flush_work);\r\n}\r\nstatic void sm_cache_flush_work(struct work_struct *work)\r\n{\r\nstruct sm_ftl *ftl = container_of(work, struct sm_ftl, flush_work);\r\nmutex_lock(&ftl->mutex);\r\nsm_cache_flush(ftl);\r\nmutex_unlock(&ftl->mutex);\r\nreturn;\r\n}\r\nstatic int sm_read(struct mtd_blktrans_dev *dev,\r\nunsigned long sect_no, char *buf)\r\n{\r\nstruct sm_ftl *ftl = dev->priv;\r\nstruct ftl_zone *zone;\r\nint error = 0, in_cache = 0;\r\nint zone_num, block, boffset;\r\nsm_break_offset(ftl, sect_no << 9, &zone_num, &block, &boffset);\r\nmutex_lock(&ftl->mutex);\r\nzone = sm_get_zone(ftl, zone_num);\r\nif (IS_ERR(zone)) {\r\nerror = PTR_ERR(zone);\r\ngoto unlock;\r\n}\r\nif (ftl->cache_zone == zone_num && ftl->cache_block == block) {\r\nin_cache = 1;\r\nif (!sm_cache_get(ftl, buf, boffset))\r\ngoto unlock;\r\n}\r\nblock = zone->lba_to_phys_table[block];\r\nif (block == -1) {\r\nmemset(buf, 0xFF, SM_SECTOR_SIZE);\r\ngoto unlock;\r\n}\r\nif (sm_read_sector(ftl, zone_num, block, boffset, buf, NULL)) {\r\nerror = -EIO;\r\ngoto unlock;\r\n}\r\nif (in_cache)\r\nsm_cache_put(ftl, buf, boffset);\r\nunlock:\r\nmutex_unlock(&ftl->mutex);\r\nreturn error;\r\n}\r\nstatic int sm_write(struct mtd_blktrans_dev *dev,\r\nunsigned long sec_no, char *buf)\r\n{\r\nstruct sm_ftl *ftl = dev->priv;\r\nstruct ftl_zone *zone;\r\nint error, zone_num, block, boffset;\r\nBUG_ON(ftl->readonly);\r\nsm_break_offset(ftl, sec_no << 9, &zone_num, &block, &boffset);\r\ndel_timer(&ftl->timer);\r\nmutex_lock(&ftl->mutex);\r\nzone = sm_get_zone(ftl, zone_num);\r\nif (IS_ERR(zone)) {\r\nerror = PTR_ERR(zone);\r\ngoto unlock;\r\n}\r\nif (ftl->cache_block != block || ftl->cache_zone != zone_num) {\r\nerror = sm_cache_flush(ftl);\r\nif (error)\r\ngoto unlock;\r\nftl->cache_block = block;\r\nftl->cache_zone = zone_num;\r\n}\r\nsm_cache_put(ftl, buf, boffset);\r\nunlock:\r\nmod_timer(&ftl->timer, jiffies + msecs_to_jiffies(cache_timeout));\r\nmutex_unlock(&ftl->mutex);\r\nreturn error;\r\n}\r\nstatic int sm_flush(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct sm_ftl *ftl = dev->priv;\r\nint retval;\r\nmutex_lock(&ftl->mutex);\r\nretval = sm_cache_flush(ftl);\r\nmutex_unlock(&ftl->mutex);\r\nreturn retval;\r\n}\r\nstatic int sm_release(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct sm_ftl *ftl = dev->priv;\r\nmutex_lock(&ftl->mutex);\r\ndel_timer_sync(&ftl->timer);\r\ncancel_work_sync(&ftl->flush_work);\r\nsm_cache_flush(ftl);\r\nmutex_unlock(&ftl->mutex);\r\nreturn 0;\r\n}\r\nstatic int sm_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\r\n{\r\nstruct sm_ftl *ftl = dev->priv;\r\ngeo->heads = ftl->heads;\r\ngeo->sectors = ftl->sectors;\r\ngeo->cylinders = ftl->cylinders;\r\nreturn 0;\r\n}\r\nstatic void sm_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\nstruct mtd_blktrans_dev *trans;\r\nstruct sm_ftl *ftl;\r\nftl = kzalloc(sizeof(struct sm_ftl), GFP_KERNEL);\r\nif (!ftl)\r\ngoto error1;\r\nmutex_init(&ftl->mutex);\r\nsetup_timer(&ftl->timer, sm_cache_flush_timer, (unsigned long)ftl);\r\nINIT_WORK(&ftl->flush_work, sm_cache_flush_work);\r\ninit_completion(&ftl->erase_completion);\r\nif (sm_get_media_info(ftl, mtd)) {\r\ndbg("found unsupported mtd device, aborting");\r\ngoto error2;\r\n}\r\nftl->cis_buffer = kzalloc(SM_SECTOR_SIZE, GFP_KERNEL);\r\nif (!ftl->cis_buffer)\r\ngoto error2;\r\nftl->zones = kzalloc(sizeof(struct ftl_zone) * ftl->zone_count,\r\nGFP_KERNEL);\r\nif (!ftl->zones)\r\ngoto error3;\r\nftl->cache_data = kzalloc(ftl->block_size, GFP_KERNEL);\r\nif (!ftl->cache_data)\r\ngoto error4;\r\nsm_cache_init(ftl);\r\ntrans = kzalloc(sizeof(struct mtd_blktrans_dev), GFP_KERNEL);\r\nif (!trans)\r\ngoto error5;\r\nftl->trans = trans;\r\ntrans->priv = ftl;\r\ntrans->tr = tr;\r\ntrans->mtd = mtd;\r\ntrans->devnum = -1;\r\ntrans->size = (ftl->block_size * ftl->max_lba * ftl->zone_count) >> 9;\r\ntrans->readonly = ftl->readonly;\r\nif (sm_find_cis(ftl)) {\r\ndbg("CIS not found on mtd device, aborting");\r\ngoto error6;\r\n}\r\nftl->disk_attributes = sm_create_sysfs_attributes(ftl);\r\nif (!ftl->disk_attributes)\r\ngoto error6;\r\ntrans->disk_attributes = ftl->disk_attributes;\r\nsm_printk("Found %d MiB xD/SmartMedia FTL on mtd%d",\r\n(int)(mtd->size / (1024 * 1024)), mtd->index);\r\ndbg("FTL layout:");\r\ndbg("%d zone(s), each consists of %d blocks (+%d spares)",\r\nftl->zone_count, ftl->max_lba,\r\nftl->zone_size - ftl->max_lba);\r\ndbg("each block consists of %d bytes",\r\nftl->block_size);\r\nif (add_mtd_blktrans_dev(trans)) {\r\ndbg("error in mtdblktrans layer");\r\ngoto error6;\r\n}\r\nreturn;\r\nerror6:\r\nkfree(trans);\r\nerror5:\r\nkfree(ftl->cache_data);\r\nerror4:\r\nkfree(ftl->zones);\r\nerror3:\r\nkfree(ftl->cis_buffer);\r\nerror2:\r\nkfree(ftl);\r\nerror1:\r\nreturn;\r\n}\r\nstatic void sm_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct sm_ftl *ftl = dev->priv;\r\nint i;\r\ndel_mtd_blktrans_dev(dev);\r\nftl->trans = NULL;\r\nfor (i = 0 ; i < ftl->zone_count; i++) {\r\nif (!ftl->zones[i].initialized)\r\ncontinue;\r\nkfree(ftl->zones[i].lba_to_phys_table);\r\nkfifo_free(&ftl->zones[i].free_sectors);\r\n}\r\nsm_delete_sysfs_attributes(ftl);\r\nkfree(ftl->cis_buffer);\r\nkfree(ftl->zones);\r\nkfree(ftl->cache_data);\r\nkfree(ftl);\r\n}\r\nstatic __init int sm_module_init(void)\r\n{\r\nint error = 0;\r\ncache_flush_workqueue = create_freezable_workqueue("smflush");\r\nif (IS_ERR(cache_flush_workqueue))\r\nreturn PTR_ERR(cache_flush_workqueue);\r\nerror = register_mtd_blktrans(&sm_ftl_ops);\r\nif (error)\r\ndestroy_workqueue(cache_flush_workqueue);\r\nreturn error;\r\n}\r\nstatic void __exit sm_module_exit(void)\r\n{\r\ndestroy_workqueue(cache_flush_workqueue);\r\nderegister_mtd_blktrans(&sm_ftl_ops);\r\n}
