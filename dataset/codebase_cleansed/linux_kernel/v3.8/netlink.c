static int handle_cmd(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *rep_buf;\r\nstruct nlmsghdr *rep_nlh;\r\nstruct nlmsghdr *req_nlh = info->nlhdr;\r\nstruct tipc_genlmsghdr *req_userhdr = info->userhdr;\r\nint hdr_space = NLMSG_SPACE(GENL_HDRLEN + TIPC_GENL_HDRLEN);\r\nu16 cmd;\r\nif ((req_userhdr->cmd & 0xC000) && (!capable(CAP_NET_ADMIN)))\r\ncmd = TIPC_CMD_NOT_NET_ADMIN;\r\nelse\r\ncmd = req_userhdr->cmd;\r\nrep_buf = tipc_cfg_do_cmd(req_userhdr->dest, cmd,\r\nNLMSG_DATA(req_nlh) + GENL_HDRLEN + TIPC_GENL_HDRLEN,\r\nNLMSG_PAYLOAD(req_nlh, GENL_HDRLEN + TIPC_GENL_HDRLEN),\r\nhdr_space);\r\nif (rep_buf) {\r\nskb_push(rep_buf, hdr_space);\r\nrep_nlh = nlmsg_hdr(rep_buf);\r\nmemcpy(rep_nlh, req_nlh, hdr_space);\r\nrep_nlh->nlmsg_len = rep_buf->len;\r\ngenlmsg_unicast(&init_net, rep_buf, NETLINK_CB(skb).portid);\r\n}\r\nreturn 0;\r\n}\r\nint tipc_netlink_start(void)\r\n{\r\nint res;\r\nres = genl_register_family_with_ops(&tipc_genl_family,\r\n&tipc_genl_ops, 1);\r\nif (res) {\r\npr_err("Failed to register netlink interface\n");\r\nreturn res;\r\n}\r\ntipc_genl_family_registered = 1;\r\nreturn 0;\r\n}\r\nvoid tipc_netlink_stop(void)\r\n{\r\nif (!tipc_genl_family_registered)\r\nreturn;\r\ngenl_unregister_family(&tipc_genl_family);\r\ntipc_genl_family_registered = 0;\r\n}
