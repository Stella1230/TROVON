static void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\r\n{\r\nconst __be32 *bp = *_bp;\r\nfid->vid = ntohl(*bp++);\r\nfid->vnode = ntohl(*bp++);\r\nfid->unique = ntohl(*bp++);\r\n*_bp = bp;\r\n}\r\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\r\nstruct afs_file_status *status,\r\nstruct afs_vnode *vnode,\r\nafs_dataversion_t *store_version)\r\n{\r\nafs_dataversion_t expected_version;\r\nconst __be32 *bp = *_bp;\r\numode_t mode;\r\nu64 data_version, size;\r\nu32 changed = 0;\r\n#define EXTRACT(DST) \\r\ndo { \\r\nu32 x = ntohl(*bp++); \\r\nchanged |= DST - x; \\r\nDST = x; \\r\n} while (0)\r\nstatus->if_version = ntohl(*bp++);\r\nEXTRACT(status->type);\r\nEXTRACT(status->nlink);\r\nsize = ntohl(*bp++);\r\ndata_version = ntohl(*bp++);\r\nEXTRACT(status->author);\r\nEXTRACT(status->owner);\r\nEXTRACT(status->caller_access);\r\nEXTRACT(status->anon_access);\r\nEXTRACT(status->mode);\r\nEXTRACT(status->parent.vnode);\r\nEXTRACT(status->parent.unique);\r\nbp++;\r\nstatus->mtime_client = ntohl(*bp++);\r\nstatus->mtime_server = ntohl(*bp++);\r\nEXTRACT(status->group);\r\nbp++;\r\ndata_version |= (u64) ntohl(*bp++) << 32;\r\nEXTRACT(status->lock_count);\r\nsize |= (u64) ntohl(*bp++) << 32;\r\nbp++;\r\n*_bp = bp;\r\nif (size != status->size) {\r\nstatus->size = size;\r\nchanged |= true;\r\n}\r\nstatus->mode &= S_IALLUGO;\r\n_debug("vnode time %lx, %lx",\r\nstatus->mtime_client, status->mtime_server);\r\nif (vnode) {\r\nstatus->parent.vid = vnode->fid.vid;\r\nif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\r\n_debug("vnode changed");\r\ni_size_write(&vnode->vfs_inode, size);\r\nvnode->vfs_inode.i_uid = status->owner;\r\nvnode->vfs_inode.i_gid = status->group;\r\nvnode->vfs_inode.i_generation = vnode->fid.unique;\r\nset_nlink(&vnode->vfs_inode, status->nlink);\r\nmode = vnode->vfs_inode.i_mode;\r\nmode &= ~S_IALLUGO;\r\nmode |= status->mode;\r\nbarrier();\r\nvnode->vfs_inode.i_mode = mode;\r\n}\r\nvnode->vfs_inode.i_ctime.tv_sec = status->mtime_server;\r\nvnode->vfs_inode.i_mtime = vnode->vfs_inode.i_ctime;\r\nvnode->vfs_inode.i_atime = vnode->vfs_inode.i_ctime;\r\nvnode->vfs_inode.i_version = data_version;\r\n}\r\nexpected_version = status->data_version;\r\nif (store_version)\r\nexpected_version = *store_version;\r\nif (expected_version != data_version) {\r\nstatus->data_version = data_version;\r\nif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\r\n_debug("vnode modified %llx on {%x:%u}",\r\n(unsigned long long) data_version,\r\nvnode->fid.vid, vnode->fid.vnode);\r\nset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\r\nset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\r\n}\r\n} else if (store_version) {\r\nstatus->data_version = data_version;\r\n}\r\n}\r\nstatic void xdr_decode_AFSCallBack(const __be32 **_bp, struct afs_vnode *vnode)\r\n{\r\nconst __be32 *bp = *_bp;\r\nvnode->cb_version = ntohl(*bp++);\r\nvnode->cb_expiry = ntohl(*bp++);\r\nvnode->cb_type = ntohl(*bp++);\r\nvnode->cb_expires = vnode->cb_expiry + get_seconds();\r\n*_bp = bp;\r\n}\r\nstatic void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\r\nstruct afs_callback *cb)\r\n{\r\nconst __be32 *bp = *_bp;\r\ncb->version = ntohl(*bp++);\r\ncb->expiry = ntohl(*bp++);\r\ncb->type = ntohl(*bp++);\r\n*_bp = bp;\r\n}\r\nstatic void xdr_decode_AFSVolSync(const __be32 **_bp,\r\nstruct afs_volsync *volsync)\r\n{\r\nconst __be32 *bp = *_bp;\r\nvolsync->creation = ntohl(*bp++);\r\nbp++;\r\nbp++;\r\nbp++;\r\nbp++;\r\nbp++;\r\n*_bp = bp;\r\n}\r\nstatic void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\r\n{\r\n__be32 *bp = *_bp;\r\nu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\r\nmask = 0;\r\nif (attr->ia_valid & ATTR_MTIME) {\r\nmask |= AFS_SET_MTIME;\r\nmtime = attr->ia_mtime.tv_sec;\r\n}\r\nif (attr->ia_valid & ATTR_UID) {\r\nmask |= AFS_SET_OWNER;\r\nowner = attr->ia_uid;\r\n}\r\nif (attr->ia_valid & ATTR_GID) {\r\nmask |= AFS_SET_GROUP;\r\ngroup = attr->ia_gid;\r\n}\r\nif (attr->ia_valid & ATTR_MODE) {\r\nmask |= AFS_SET_MODE;\r\nmode = attr->ia_mode & S_IALLUGO;\r\n}\r\n*bp++ = htonl(mask);\r\n*bp++ = htonl(mtime);\r\n*bp++ = htonl(owner);\r\n*bp++ = htonl(group);\r\n*bp++ = htonl(mode);\r\n*bp++ = 0;\r\n*_bp = bp;\r\n}\r\nstatic void xdr_decode_AFSFetchVolumeStatus(const __be32 **_bp,\r\nstruct afs_volume_status *vs)\r\n{\r\nconst __be32 *bp = *_bp;\r\nvs->vid = ntohl(*bp++);\r\nvs->parent_id = ntohl(*bp++);\r\nvs->online = ntohl(*bp++);\r\nvs->in_service = ntohl(*bp++);\r\nvs->blessed = ntohl(*bp++);\r\nvs->needs_salvage = ntohl(*bp++);\r\nvs->type = ntohl(*bp++);\r\nvs->min_quota = ntohl(*bp++);\r\nvs->max_quota = ntohl(*bp++);\r\nvs->blocks_in_use = ntohl(*bp++);\r\nvs->part_blocks_avail = ntohl(*bp++);\r\nvs->part_max_blocks = ntohl(*bp++);\r\n*_bp = bp;\r\n}\r\nstatic int afs_deliver_fs_fetch_status(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\n_enter(",,%u", last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\r\nxdr_decode_AFSCallBack(&bp, vnode);\r\nif (call->reply2)\r\nxdr_decode_AFSVolSync(&bp, call->reply2);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_fetch_file_status(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nstruct afs_volsync *volsync,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter(",%x,{%x:%u},,",\r\nkey_serial(key), vnode->fid.vid, vnode->fid.vnode);\r\ncall = afs_alloc_flat_call(&afs_RXFSFetchStatus, 16, (21 + 3 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->reply2 = volsync;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\nbp[0] = htonl(FSFETCHSTATUS);\r\nbp[1] = htonl(vnode->fid.vid);\r\nbp[2] = htonl(vnode->fid.vnode);\r\nbp[3] = htonl(vnode->fid.unique);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_fetch_data(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\nstruct page *page;\r\nvoid *buffer;\r\nint ret;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nswitch (call->unmarshall) {\r\ncase 0:\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nif (call->operation_ID != FSFETCHDATA64) {\r\ncall->unmarshall++;\r\ngoto no_msw;\r\n}\r\ncase 1:\r\n_debug("extract data length (MSW)");\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->count = ntohl(call->tmp);\r\n_debug("DATA length MSW: %u", call->count);\r\nif (call->count > 0)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nno_msw:\r\ncase 2:\r\n_debug("extract data length");\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->count = ntohl(call->tmp);\r\n_debug("DATA length: %u", call->count);\r\nif (call->count > PAGE_SIZE)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 3:\r\n_debug("extract data");\r\nif (call->count > 0) {\r\npage = call->reply3;\r\nbuffer = kmap_atomic(page);\r\nret = afs_extract_data(call, skb, last, buffer,\r\ncall->count);\r\nkunmap_atomic(buffer);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 4:\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\n(21 + 3 + 6) * 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\r\nxdr_decode_AFSCallBack(&bp, vnode);\r\nif (call->reply2)\r\nxdr_decode_AFSVolSync(&bp, call->reply2);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 5:\r\n_debug("trailer");\r\nif (skb->len != 0)\r\nreturn -EBADMSG;\r\nbreak;\r\n}\r\nif (!last)\r\nreturn 0;\r\nif (call->count < PAGE_SIZE) {\r\n_debug("clear");\r\npage = call->reply3;\r\nbuffer = kmap_atomic(page);\r\nmemset(buffer + call->count, 0, PAGE_SIZE - call->count);\r\nkunmap_atomic(buffer);\r\n}\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nstatic int afs_fs_fetch_data64(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\noff_t offset, size_t length,\r\nstruct page *buffer,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter("");\r\nASSERTCMP(length, <, ULONG_MAX);\r\ncall = afs_alloc_flat_call(&afs_RXFSFetchData64, 32, (21 + 3 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->reply2 = NULL;\r\ncall->reply3 = buffer;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->operation_ID = FSFETCHDATA64;\r\nbp = call->request;\r\nbp[0] = htonl(FSFETCHDATA64);\r\nbp[1] = htonl(vnode->fid.vid);\r\nbp[2] = htonl(vnode->fid.vnode);\r\nbp[3] = htonl(vnode->fid.unique);\r\nbp[4] = htonl(upper_32_bits(offset));\r\nbp[5] = htonl((u32) offset);\r\nbp[6] = 0;\r\nbp[7] = htonl((u32) length);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nint afs_fs_fetch_data(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\noff_t offset, size_t length,\r\nstruct page *buffer,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\nif (upper_32_bits(offset) || upper_32_bits(offset + length))\r\nreturn afs_fs_fetch_data64(server, key, vnode, offset, length,\r\nbuffer, wait_mode);\r\n_enter("");\r\ncall = afs_alloc_flat_call(&afs_RXFSFetchData, 24, (21 + 3 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->reply2 = NULL;\r\ncall->reply3 = buffer;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->operation_ID = FSFETCHDATA;\r\nbp = call->request;\r\nbp[0] = htonl(FSFETCHDATA);\r\nbp[1] = htonl(vnode->fid.vid);\r\nbp[2] = htonl(vnode->fid.vnode);\r\nbp[3] = htonl(vnode->fid.unique);\r\nbp[4] = htonl(offset);\r\nbp[5] = htonl(length);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_give_up_callbacks(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\n_enter(",{%u},%d", skb->len, last);\r\nif (skb->len > 0)\r\nreturn -EBADMSG;\r\nreturn 0;\r\n}\r\nint afs_fs_give_up_callbacks(struct afs_server *server,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t ncallbacks;\r\n__be32 *bp, *tp;\r\nint loop;\r\nncallbacks = CIRC_CNT(server->cb_break_head, server->cb_break_tail,\r\nARRAY_SIZE(server->cb_break));\r\n_enter("{%zu},", ncallbacks);\r\nif (ncallbacks == 0)\r\nreturn 0;\r\nif (ncallbacks > AFSCBMAX)\r\nncallbacks = AFSCBMAX;\r\n_debug("break %zu callbacks", ncallbacks);\r\ncall = afs_alloc_flat_call(&afs_RXFSGiveUpCallBacks,\r\n12 + ncallbacks * 6 * 4, 0);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\ntp = bp + 2 + ncallbacks * 3;\r\n*bp++ = htonl(FSGIVEUPCALLBACKS);\r\n*bp++ = htonl(ncallbacks);\r\n*tp++ = htonl(ncallbacks);\r\natomic_sub(ncallbacks, &server->cb_break_n);\r\nfor (loop = ncallbacks; loop > 0; loop--) {\r\nstruct afs_callback *cb =\r\n&server->cb_break[server->cb_break_tail];\r\n*bp++ = htonl(cb->fid.vid);\r\n*bp++ = htonl(cb->fid.vnode);\r\n*bp++ = htonl(cb->fid.unique);\r\n*tp++ = htonl(cb->version);\r\n*tp++ = htonl(cb->expiry);\r\n*tp++ = htonl(cb->type);\r\nsmp_mb();\r\nserver->cb_break_tail =\r\n(server->cb_break_tail + 1) &\r\n(ARRAY_SIZE(server->cb_break) - 1);\r\n}\r\nASSERT(ncallbacks > 0);\r\nwake_up_nr(&server->cb_break_waitq, ncallbacks);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_create_vnode(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\nxdr_decode_AFSFid(&bp, call->reply2);\r\nxdr_decode_AFSFetchStatus(&bp, call->reply3, NULL, NULL);\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\r\nxdr_decode_AFSCallBack_raw(&bp, call->reply4);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_create(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nconst char *name,\r\numode_t mode,\r\nstruct afs_fid *newfid,\r\nstruct afs_file_status *newstatus,\r\nstruct afs_callback *newcb,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t namesz, reqsz, padsz;\r\n__be32 *bp;\r\n_enter("");\r\nnamesz = strlen(name);\r\npadsz = (4 - (namesz & 3)) & 3;\r\nreqsz = (5 * 4) + namesz + padsz + (6 * 4);\r\ncall = afs_alloc_flat_call(&afs_RXFSCreateXXXX, reqsz,\r\n(3 + 21 + 21 + 3 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->reply2 = newfid;\r\ncall->reply3 = newstatus;\r\ncall->reply4 = newcb;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(S_ISDIR(mode) ? FSMAKEDIR : FSCREATEFILE);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\n*bp++ = htonl(namesz);\r\nmemcpy(bp, name, namesz);\r\nbp = (void *) bp + namesz;\r\nif (padsz > 0) {\r\nmemset(bp, 0, padsz);\r\nbp = (void *) bp + padsz;\r\n}\r\n*bp++ = htonl(AFS_SET_MODE);\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = htonl(mode & S_IALLUGO);\r\n*bp++ = 0;\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_remove(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_remove(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nconst char *name,\r\nbool isdir,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t namesz, reqsz, padsz;\r\n__be32 *bp;\r\n_enter("");\r\nnamesz = strlen(name);\r\npadsz = (4 - (namesz & 3)) & 3;\r\nreqsz = (5 * 4) + namesz + padsz;\r\ncall = afs_alloc_flat_call(&afs_RXFSRemoveXXXX, reqsz, (21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(isdir ? FSREMOVEDIR : FSREMOVEFILE);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\n*bp++ = htonl(namesz);\r\nmemcpy(bp, name, namesz);\r\nbp = (void *) bp + namesz;\r\nif (padsz > 0) {\r\nmemset(bp, 0, padsz);\r\nbp = (void *) bp + padsz;\r\n}\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_link(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *dvnode = call->reply, *vnode = call->reply2;\r\nconst __be32 *bp;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\r\nxdr_decode_AFSFetchStatus(&bp, &dvnode->status, dvnode, NULL);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_link(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *dvnode,\r\nstruct afs_vnode *vnode,\r\nconst char *name,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t namesz, reqsz, padsz;\r\n__be32 *bp;\r\n_enter("");\r\nnamesz = strlen(name);\r\npadsz = (4 - (namesz & 3)) & 3;\r\nreqsz = (5 * 4) + namesz + padsz + (3 * 4);\r\ncall = afs_alloc_flat_call(&afs_RXFSLink, reqsz, (21 + 21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = dvnode;\r\ncall->reply2 = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(FSLINK);\r\n*bp++ = htonl(dvnode->fid.vid);\r\n*bp++ = htonl(dvnode->fid.vnode);\r\n*bp++ = htonl(dvnode->fid.unique);\r\n*bp++ = htonl(namesz);\r\nmemcpy(bp, name, namesz);\r\nbp = (void *) bp + namesz;\r\nif (padsz > 0) {\r\nmemset(bp, 0, padsz);\r\nbp = (void *) bp + padsz;\r\n}\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_symlink(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\nxdr_decode_AFSFid(&bp, call->reply2);\r\nxdr_decode_AFSFetchStatus(&bp, call->reply3, NULL, NULL);\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_symlink(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nconst char *name,\r\nconst char *contents,\r\nstruct afs_fid *newfid,\r\nstruct afs_file_status *newstatus,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t namesz, reqsz, padsz, c_namesz, c_padsz;\r\n__be32 *bp;\r\n_enter("");\r\nnamesz = strlen(name);\r\npadsz = (4 - (namesz & 3)) & 3;\r\nc_namesz = strlen(contents);\r\nc_padsz = (4 - (c_namesz & 3)) & 3;\r\nreqsz = (6 * 4) + namesz + padsz + c_namesz + c_padsz + (6 * 4);\r\ncall = afs_alloc_flat_call(&afs_RXFSSymlink, reqsz,\r\n(3 + 21 + 21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->reply2 = newfid;\r\ncall->reply3 = newstatus;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(FSSYMLINK);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\n*bp++ = htonl(namesz);\r\nmemcpy(bp, name, namesz);\r\nbp = (void *) bp + namesz;\r\nif (padsz > 0) {\r\nmemset(bp, 0, padsz);\r\nbp = (void *) bp + padsz;\r\n}\r\n*bp++ = htonl(c_namesz);\r\nmemcpy(bp, contents, c_namesz);\r\nbp = (void *) bp + c_namesz;\r\nif (c_padsz > 0) {\r\nmemset(bp, 0, c_padsz);\r\nbp = (void *) bp + c_padsz;\r\n}\r\n*bp++ = htonl(AFS_SET_MODE);\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = htonl(S_IRWXUGO);\r\n*bp++ = 0;\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_rename(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *orig_dvnode = call->reply, *new_dvnode = call->reply2;\r\nconst __be32 *bp;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &orig_dvnode->status, orig_dvnode, NULL);\r\nif (new_dvnode != orig_dvnode)\r\nxdr_decode_AFSFetchStatus(&bp, &new_dvnode->status, new_dvnode,\r\nNULL);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_rename(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *orig_dvnode,\r\nconst char *orig_name,\r\nstruct afs_vnode *new_dvnode,\r\nconst char *new_name,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\nsize_t reqsz, o_namesz, o_padsz, n_namesz, n_padsz;\r\n__be32 *bp;\r\n_enter("");\r\no_namesz = strlen(orig_name);\r\no_padsz = (4 - (o_namesz & 3)) & 3;\r\nn_namesz = strlen(new_name);\r\nn_padsz = (4 - (n_namesz & 3)) & 3;\r\nreqsz = (4 * 4) +\r\n4 + o_namesz + o_padsz +\r\n(3 * 4) +\r\n4 + n_namesz + n_padsz;\r\ncall = afs_alloc_flat_call(&afs_RXFSRename, reqsz, (21 + 21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = orig_dvnode;\r\ncall->reply2 = new_dvnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(FSRENAME);\r\n*bp++ = htonl(orig_dvnode->fid.vid);\r\n*bp++ = htonl(orig_dvnode->fid.vnode);\r\n*bp++ = htonl(orig_dvnode->fid.unique);\r\n*bp++ = htonl(o_namesz);\r\nmemcpy(bp, orig_name, o_namesz);\r\nbp = (void *) bp + o_namesz;\r\nif (o_padsz > 0) {\r\nmemset(bp, 0, o_padsz);\r\nbp = (void *) bp + o_padsz;\r\n}\r\n*bp++ = htonl(new_dvnode->fid.vid);\r\n*bp++ = htonl(new_dvnode->fid.vnode);\r\n*bp++ = htonl(new_dvnode->fid.unique);\r\n*bp++ = htonl(n_namesz);\r\nmemcpy(bp, new_name, n_namesz);\r\nbp = (void *) bp + n_namesz;\r\nif (n_padsz > 0) {\r\nmemset(bp, 0, n_padsz);\r\nbp = (void *) bp + n_padsz;\r\n}\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_store_data(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\n_enter(",,%u", last);\r\nafs_transfer_reply(call, skb);\r\nif (!last) {\r\n_leave(" = 0 [more]");\r\nreturn 0;\r\n}\r\nif (call->reply_size != call->reply_max) {\r\n_leave(" = -EBADMSG [%u != %u]",\r\ncall->reply_size, call->reply_max);\r\nreturn -EBADMSG;\r\n}\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode,\r\n&call->store_version);\r\nafs_pages_written_back(vnode, call);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nstatic int afs_fs_store_data64(struct afs_server *server,\r\nstruct afs_writeback *wb,\r\npgoff_t first, pgoff_t last,\r\nunsigned offset, unsigned to,\r\nloff_t size, loff_t pos, loff_t i_size,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_vnode *vnode = wb->vnode;\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter(",%x,{%x:%u},,",\r\nkey_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\r\ncall = afs_alloc_flat_call(&afs_RXFSStoreData64,\r\n(4 + 6 + 3 * 2) * 4,\r\n(21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->wb = wb;\r\ncall->key = wb->key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->mapping = vnode->vfs_inode.i_mapping;\r\ncall->first = first;\r\ncall->last = last;\r\ncall->first_offset = offset;\r\ncall->last_to = to;\r\ncall->send_pages = true;\r\ncall->store_version = vnode->status.data_version + 1;\r\nbp = call->request;\r\n*bp++ = htonl(FSSTOREDATA64);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = htonl(pos >> 32);\r\n*bp++ = htonl((u32) pos);\r\n*bp++ = htonl(size >> 32);\r\n*bp++ = htonl((u32) size);\r\n*bp++ = htonl(i_size >> 32);\r\n*bp++ = htonl((u32) i_size);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nint afs_fs_store_data(struct afs_server *server, struct afs_writeback *wb,\r\npgoff_t first, pgoff_t last,\r\nunsigned offset, unsigned to,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_vnode *vnode = wb->vnode;\r\nstruct afs_call *call;\r\nloff_t size, pos, i_size;\r\n__be32 *bp;\r\n_enter(",%x,{%x:%u},,",\r\nkey_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\r\nsize = to - offset;\r\nif (first != last)\r\nsize += (loff_t)(last - first) << PAGE_SHIFT;\r\npos = (loff_t)first << PAGE_SHIFT;\r\npos += offset;\r\ni_size = i_size_read(&vnode->vfs_inode);\r\nif (pos + size > i_size)\r\ni_size = size + pos;\r\n_debug("size %llx, at %llx, i_size %llx",\r\n(unsigned long long) size, (unsigned long long) pos,\r\n(unsigned long long) i_size);\r\nif (pos >> 32 || i_size >> 32 || size >> 32 || (pos + size) >> 32)\r\nreturn afs_fs_store_data64(server, wb, first, last, offset, to,\r\nsize, pos, i_size, wait_mode);\r\ncall = afs_alloc_flat_call(&afs_RXFSStoreData,\r\n(4 + 6 + 3) * 4,\r\n(21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->wb = wb;\r\ncall->key = wb->key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->mapping = vnode->vfs_inode.i_mapping;\r\ncall->first = first;\r\ncall->last = last;\r\ncall->first_offset = offset;\r\ncall->last_to = to;\r\ncall->send_pages = true;\r\ncall->store_version = vnode->status.data_version + 1;\r\nbp = call->request;\r\n*bp++ = htonl(FSSTOREDATA);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = htonl(pos);\r\n*bp++ = htonl(size);\r\n*bp++ = htonl(i_size);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_store_status(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nafs_dataversion_t *store_version;\r\nstruct afs_vnode *vnode = call->reply;\r\nconst __be32 *bp;\r\n_enter(",,%u", last);\r\nafs_transfer_reply(call, skb);\r\nif (!last) {\r\n_leave(" = 0 [more]");\r\nreturn 0;\r\n}\r\nif (call->reply_size != call->reply_max) {\r\n_leave(" = -EBADMSG [%u != %u]",\r\ncall->reply_size, call->reply_max);\r\nreturn -EBADMSG;\r\n}\r\nstore_version = NULL;\r\nif (call->operation_ID == FSSTOREDATA)\r\nstore_version = &call->store_version;\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, store_version);\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nstatic int afs_fs_setattr_size64(struct afs_server *server, struct key *key,\r\nstruct afs_vnode *vnode, struct iattr *attr,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter(",%x,{%x:%u},,",\r\nkey_serial(key), vnode->fid.vid, vnode->fid.vnode);\r\nASSERT(attr->ia_valid & ATTR_SIZE);\r\ncall = afs_alloc_flat_call(&afs_RXFSStoreData64_as_Status,\r\n(4 + 6 + 3 * 2) * 4,\r\n(21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->store_version = vnode->status.data_version + 1;\r\ncall->operation_ID = FSSTOREDATA;\r\nbp = call->request;\r\n*bp++ = htonl(FSSTOREDATA64);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\nxdr_encode_AFS_StoreStatus(&bp, attr);\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = htonl(attr->ia_size >> 32);\r\n*bp++ = htonl((u32) attr->ia_size);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_fs_setattr_size(struct afs_server *server, struct key *key,\r\nstruct afs_vnode *vnode, struct iattr *attr,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter(",%x,{%x:%u},,",\r\nkey_serial(key), vnode->fid.vid, vnode->fid.vnode);\r\nASSERT(attr->ia_valid & ATTR_SIZE);\r\nif (attr->ia_size >> 32)\r\nreturn afs_fs_setattr_size64(server, key, vnode, attr,\r\nwait_mode);\r\ncall = afs_alloc_flat_call(&afs_RXFSStoreData_as_Status,\r\n(4 + 6 + 3) * 4,\r\n(21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->store_version = vnode->status.data_version + 1;\r\ncall->operation_ID = FSSTOREDATA;\r\nbp = call->request;\r\n*bp++ = htonl(FSSTOREDATA);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\nxdr_encode_AFS_StoreStatus(&bp, attr);\r\n*bp++ = 0;\r\n*bp++ = 0;\r\n*bp++ = htonl(attr->ia_size);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nint afs_fs_setattr(struct afs_server *server, struct key *key,\r\nstruct afs_vnode *vnode, struct iattr *attr,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\nif (attr->ia_valid & ATTR_SIZE)\r\nreturn afs_fs_setattr_size(server, key, vnode, attr,\r\nwait_mode);\r\n_enter(",%x,{%x:%u},,",\r\nkey_serial(key), vnode->fid.vid, vnode->fid.vnode);\r\ncall = afs_alloc_flat_call(&afs_RXFSStoreStatus,\r\n(4 + 6) * 4,\r\n(21 + 6) * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\ncall->operation_ID = FSSTORESTATUS;\r\nbp = call->request;\r\n*bp++ = htonl(FSSTORESTATUS);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\nxdr_encode_AFS_StoreStatus(&bp, attr);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_get_volume_status(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nconst __be32 *bp;\r\nchar *p;\r\nint ret;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nswitch (call->unmarshall) {\r\ncase 0:\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 1:\r\n_debug("extract status");\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\n12 * 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\nbp = call->buffer;\r\nxdr_decode_AFSFetchVolumeStatus(&bp, call->reply2);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 2:\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->count = ntohl(call->tmp);\r\n_debug("volname length: %u", call->count);\r\nif (call->count >= AFSNAMEMAX)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 3:\r\n_debug("extract volname");\r\nif (call->count > 0) {\r\nret = afs_extract_data(call, skb, last, call->reply3,\r\ncall->count);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n}\r\np = call->reply3;\r\np[call->count] = 0;\r\n_debug("volname '%s'", p);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nif ((call->count & 3) == 0) {\r\ncall->unmarshall++;\r\ngoto no_volname_padding;\r\n}\r\ncall->count = 4 - (call->count & 3);\r\ncase 4:\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\ncall->count);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nno_volname_padding:\r\ncase 5:\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->count = ntohl(call->tmp);\r\n_debug("offline msg length: %u", call->count);\r\nif (call->count >= AFSNAMEMAX)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 6:\r\n_debug("extract offline");\r\nif (call->count > 0) {\r\nret = afs_extract_data(call, skb, last, call->reply3,\r\ncall->count);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n}\r\np = call->reply3;\r\np[call->count] = 0;\r\n_debug("offline '%s'", p);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nif ((call->count & 3) == 0) {\r\ncall->unmarshall++;\r\ngoto no_offline_padding;\r\n}\r\ncall->count = 4 - (call->count & 3);\r\ncase 7:\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\ncall->count);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nno_offline_padding:\r\ncase 8:\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->count = ntohl(call->tmp);\r\n_debug("motd length: %u", call->count);\r\nif (call->count >= AFSNAMEMAX)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 9:\r\n_debug("extract motd");\r\nif (call->count > 0) {\r\nret = afs_extract_data(call, skb, last, call->reply3,\r\ncall->count);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n}\r\np = call->reply3;\r\np[call->count] = 0;\r\n_debug("motd '%s'", p);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nif ((call->count & 3) == 0) {\r\ncall->unmarshall++;\r\ngoto no_motd_padding;\r\n}\r\ncall->count = 4 - (call->count & 3);\r\ncase 10:\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\ncall->count);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nno_motd_padding:\r\ncase 11:\r\n_debug("trailer %d", skb->len);\r\nif (skb->len != 0)\r\nreturn -EBADMSG;\r\nbreak;\r\n}\r\nif (!last)\r\nreturn 0;\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nstatic void afs_get_volume_status_call_destructor(struct afs_call *call)\r\n{\r\nkfree(call->reply3);\r\ncall->reply3 = NULL;\r\nafs_flat_call_destructor(call);\r\n}\r\nint afs_fs_get_volume_status(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nstruct afs_volume_status *vs,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\nvoid *tmpbuf;\r\n_enter("");\r\ntmpbuf = kmalloc(AFSOPAQUEMAX, GFP_KERNEL);\r\nif (!tmpbuf)\r\nreturn -ENOMEM;\r\ncall = afs_alloc_flat_call(&afs_RXFSGetVolumeStatus, 2 * 4, 12 * 4);\r\nif (!call) {\r\nkfree(tmpbuf);\r\nreturn -ENOMEM;\r\n}\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->reply2 = vs;\r\ncall->reply3 = tmpbuf;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\nbp[0] = htonl(FSGETVOLUMESTATUS);\r\nbp[1] = htonl(vnode->fid.vid);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nstatic int afs_deliver_fs_xxxx_lock(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\nconst __be32 *bp;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nafs_transfer_reply(call, skb);\r\nif (!last)\r\nreturn 0;\r\nif (call->reply_size != call->reply_max)\r\nreturn -EBADMSG;\r\nbp = call->buffer;\r\n_leave(" = 0 [done]");\r\nreturn 0;\r\n}\r\nint afs_fs_set_lock(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nafs_lock_type_t type,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter("");\r\ncall = afs_alloc_flat_call(&afs_RXFSSetLock, 5 * 4, 6 * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(FSSETLOCK);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\n*bp++ = htonl(type);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nint afs_fs_extend_lock(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter("");\r\ncall = afs_alloc_flat_call(&afs_RXFSExtendLock, 4 * 4, 6 * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(FSEXTENDLOCK);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}\r\nint afs_fs_release_lock(struct afs_server *server,\r\nstruct key *key,\r\nstruct afs_vnode *vnode,\r\nconst struct afs_wait_mode *wait_mode)\r\n{\r\nstruct afs_call *call;\r\n__be32 *bp;\r\n_enter("");\r\ncall = afs_alloc_flat_call(&afs_RXFSReleaseLock, 4 * 4, 6 * 4);\r\nif (!call)\r\nreturn -ENOMEM;\r\ncall->key = key;\r\ncall->reply = vnode;\r\ncall->service_id = FS_SERVICE;\r\ncall->port = htons(AFS_FS_PORT);\r\nbp = call->request;\r\n*bp++ = htonl(FSRELEASELOCK);\r\n*bp++ = htonl(vnode->fid.vid);\r\n*bp++ = htonl(vnode->fid.vnode);\r\n*bp++ = htonl(vnode->fid.unique);\r\nreturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\r\n}
