int drm_lastclose(struct drm_device * dev)\r\n{\r\nstruct drm_vma_entry *vma, *vma_temp;\r\nDRM_DEBUG("\n");\r\nif (dev->driver->lastclose)\r\ndev->driver->lastclose(dev);\r\nDRM_DEBUG("driver lastclose completed\n");\r\nif (dev->irq_enabled && !drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_irq_uninstall(dev);\r\nmutex_lock(&dev->struct_mutex);\r\nif (drm_core_has_AGP(dev) && dev->agp &&\r\n!drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nstruct drm_agp_mem *entry, *tempe;\r\nlist_for_each_entry_safe(entry, tempe, &dev->agp->memory, head) {\r\nif (entry->bound)\r\ndrm_unbind_agp(entry->memory);\r\ndrm_free_agp(entry->memory, entry->pages);\r\nkfree(entry);\r\n}\r\nINIT_LIST_HEAD(&dev->agp->memory);\r\nif (dev->agp->acquired)\r\ndrm_agp_release(dev);\r\ndev->agp->acquired = 0;\r\ndev->agp->enabled = 0;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_SG) && dev->sg &&\r\n!drm_core_check_feature(dev, DRIVER_MODESET)) {\r\ndrm_sg_cleanup(dev->sg);\r\ndev->sg = NULL;\r\n}\r\nlist_for_each_entry_safe(vma, vma_temp, &dev->vmalist, head) {\r\nlist_del(&vma->head);\r\nkfree(vma);\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_HAVE_DMA) &&\r\n!drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_dma_takedown(dev);\r\ndev->dev_mapping = NULL;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("lastclose completed\n");\r\nreturn 0;\r\n}\r\nstatic int __init drm_core_init(void)\r\n{\r\nint ret = -ENOMEM;\r\ndrm_global_init();\r\nidr_init(&drm_minors_idr);\r\nif (register_chrdev(DRM_MAJOR, "drm", &drm_stub_fops))\r\ngoto err_p1;\r\ndrm_class = drm_sysfs_create(THIS_MODULE, "drm");\r\nif (IS_ERR(drm_class)) {\r\nprintk(KERN_ERR "DRM: Error creating drm class.\n");\r\nret = PTR_ERR(drm_class);\r\ngoto err_p2;\r\n}\r\ndrm_proc_root = proc_mkdir("dri", NULL);\r\nif (!drm_proc_root) {\r\nDRM_ERROR("Cannot create /proc/dri\n");\r\nret = -1;\r\ngoto err_p3;\r\n}\r\ndrm_debugfs_root = debugfs_create_dir("dri", NULL);\r\nif (!drm_debugfs_root) {\r\nDRM_ERROR("Cannot create /sys/kernel/debug/dri\n");\r\nret = -1;\r\ngoto err_p3;\r\n}\r\nDRM_INFO("Initialized %s %d.%d.%d %s\n",\r\nCORE_NAME, CORE_MAJOR, CORE_MINOR, CORE_PATCHLEVEL, CORE_DATE);\r\nreturn 0;\r\nerr_p3:\r\ndrm_sysfs_destroy();\r\nerr_p2:\r\nunregister_chrdev(DRM_MAJOR, "drm");\r\nidr_destroy(&drm_minors_idr);\r\nerr_p1:\r\nreturn ret;\r\n}\r\nstatic void __exit drm_core_exit(void)\r\n{\r\nremove_proc_entry("dri", NULL);\r\ndebugfs_remove(drm_debugfs_root);\r\ndrm_sysfs_destroy();\r\nunregister_chrdev(DRM_MAJOR, "drm");\r\nidr_remove_all(&drm_minors_idr);\r\nidr_destroy(&drm_minors_idr);\r\n}\r\nstatic int drm_copy_field(char *buf, size_t *buf_len, const char *value)\r\n{\r\nint len;\r\nlen = strlen(value);\r\nif (len > *buf_len)\r\nlen = *buf_len;\r\n*buf_len = strlen(value);\r\nif (len && buf)\r\nif (copy_to_user(buf, value, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int drm_version(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_version *version = data;\r\nint err;\r\nversion->version_major = dev->driver->major;\r\nversion->version_minor = dev->driver->minor;\r\nversion->version_patchlevel = dev->driver->patchlevel;\r\nerr = drm_copy_field(version->name, &version->name_len,\r\ndev->driver->name);\r\nif (!err)\r\nerr = drm_copy_field(version->date, &version->date_len,\r\ndev->driver->date);\r\nif (!err)\r\nerr = drm_copy_field(version->desc, &version->desc_len,\r\ndev->driver->desc);\r\nreturn err;\r\n}\r\nlong drm_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev;\r\nstruct drm_ioctl_desc *ioctl;\r\ndrm_ioctl_t *func;\r\nunsigned int nr = DRM_IOCTL_NR(cmd);\r\nint retcode = -EINVAL;\r\nchar stack_kdata[128];\r\nchar *kdata = NULL;\r\nunsigned int usize, asize;\r\ndev = file_priv->minor->dev;\r\nif (drm_device_is_unplugged(dev))\r\nreturn -ENODEV;\r\natomic_inc(&dev->ioctl_count);\r\natomic_inc(&dev->counts[_DRM_STAT_IOCTLS]);\r\n++file_priv->ioctl_count;\r\nDRM_DEBUG("pid=%d, cmd=0x%02x, nr=0x%02x, dev 0x%lx, auth=%d\n",\r\ntask_pid_nr(current), cmd, nr,\r\n(long)old_encode_dev(file_priv->minor->device),\r\nfile_priv->authenticated);\r\nif ((nr >= DRM_CORE_IOCTL_COUNT) &&\r\n((nr < DRM_COMMAND_BASE) || (nr >= DRM_COMMAND_END)))\r\ngoto err_i1;\r\nif ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END) &&\r\n(nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)) {\r\nu32 drv_size;\r\nioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];\r\ndrv_size = _IOC_SIZE(ioctl->cmd_drv);\r\nusize = asize = _IOC_SIZE(cmd);\r\nif (drv_size > asize)\r\nasize = drv_size;\r\n}\r\nelse if ((nr >= DRM_COMMAND_END) || (nr < DRM_COMMAND_BASE)) {\r\nioctl = &drm_ioctls[nr];\r\ncmd = ioctl->cmd;\r\nusize = asize = _IOC_SIZE(cmd);\r\n} else\r\ngoto err_i1;\r\nfunc = ioctl->func;\r\nif ((nr == DRM_IOCTL_NR(DRM_IOCTL_DMA)) && dev->driver->dma_ioctl)\r\nfunc = dev->driver->dma_ioctl;\r\nif (!func) {\r\nDRM_DEBUG("no function\n");\r\nretcode = -EINVAL;\r\n} else if (((ioctl->flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)) ||\r\n((ioctl->flags & DRM_AUTH) && !file_priv->authenticated) ||\r\n((ioctl->flags & DRM_MASTER) && !file_priv->is_master) ||\r\n(!(ioctl->flags & DRM_CONTROL_ALLOW) && (file_priv->minor->type == DRM_MINOR_CONTROL))) {\r\nretcode = -EACCES;\r\n} else {\r\nif (cmd & (IOC_IN | IOC_OUT)) {\r\nif (asize <= sizeof(stack_kdata)) {\r\nkdata = stack_kdata;\r\n} else {\r\nkdata = kmalloc(asize, GFP_KERNEL);\r\nif (!kdata) {\r\nretcode = -ENOMEM;\r\ngoto err_i1;\r\n}\r\n}\r\nif (asize > usize)\r\nmemset(kdata + usize, 0, asize - usize);\r\n}\r\nif (cmd & IOC_IN) {\r\nif (copy_from_user(kdata, (void __user *)arg,\r\nusize) != 0) {\r\nretcode = -EFAULT;\r\ngoto err_i1;\r\n}\r\n} else\r\nmemset(kdata, 0, usize);\r\nif (ioctl->flags & DRM_UNLOCKED)\r\nretcode = func(dev, kdata, file_priv);\r\nelse {\r\nmutex_lock(&drm_global_mutex);\r\nretcode = func(dev, kdata, file_priv);\r\nmutex_unlock(&drm_global_mutex);\r\n}\r\nif (cmd & IOC_OUT) {\r\nif (copy_to_user((void __user *)arg, kdata,\r\nusize) != 0)\r\nretcode = -EFAULT;\r\n}\r\n}\r\nerr_i1:\r\nif (kdata != stack_kdata)\r\nkfree(kdata);\r\natomic_dec(&dev->ioctl_count);\r\nif (retcode)\r\nDRM_DEBUG("ret = %d\n", retcode);\r\nreturn retcode;\r\n}\r\nstruct drm_local_map *drm_getsarea(struct drm_device *dev)\r\n{\r\nstruct drm_map_list *entry;\r\nlist_for_each_entry(entry, &dev->maplist, head) {\r\nif (entry->map && entry->map->type == _DRM_SHM &&\r\n(entry->map->flags & _DRM_CONTAINS_LOCK)) {\r\nreturn entry->map;\r\n}\r\n}\r\nreturn NULL;\r\n}
