static void mini6410_lcd_power_set(struct plat_lcd_data *pd,\r\nunsigned int power)\r\n{\r\nif (power)\r\ngpio_direction_output(S3C64XX_GPE(0), 1);\r\nelse\r\ngpio_direction_output(S3C64XX_GPE(0), 0);\r\n}\r\nstatic void __init mini6410_map_io(void)\r\n{\r\nu32 tmp;\r\ns3c64xx_init_io(NULL, 0);\r\ns3c24xx_init_clocks(12000000);\r\ns3c24xx_init_uarts(mini6410_uartcfgs, ARRAY_SIZE(mini6410_uartcfgs));\r\ntmp = __raw_readl(S3C64XX_SPCON);\r\ntmp &= ~S3C64XX_SPCON_LCD_SEL_MASK;\r\ntmp |= S3C64XX_SPCON_LCD_SEL_RGB;\r\n__raw_writel(tmp, S3C64XX_SPCON);\r\ntmp = __raw_readl(S3C64XX_MODEM_MIFPCON);\r\ntmp &= ~MIFPCON_LCD_BYPASS;\r\n__raw_writel(tmp, S3C64XX_MODEM_MIFPCON);\r\n}\r\nstatic int __init mini6410_features_setup(char *str)\r\n{\r\nif (str)\r\nstrlcpy(mini6410_features_str, str,\r\nsizeof(mini6410_features_str));\r\nreturn 1;\r\n}\r\nstatic void mini6410_parse_features(\r\nstruct mini6410_features_t *features,\r\nconst char *features_str)\r\n{\r\nconst char *fp = features_str;\r\nfeatures->done = 0;\r\nfeatures->lcd_index = 0;\r\nwhile (*fp) {\r\nchar f = *fp++;\r\nswitch (f) {\r\ncase '0'...'9':\r\nif (features->done & FEATURE_SCREEN) {\r\nprintk(KERN_INFO "MINI6410: '%c' ignored, "\r\n"screen type already set\n", f);\r\n} else {\r\nint li = f - '0';\r\nif (li >= ARRAY_SIZE(mini6410_lcd_pdata))\r\nprintk(KERN_INFO "MINI6410: '%c' out "\r\n"of range LCD mode\n", f);\r\nelse {\r\nfeatures->lcd_index = li;\r\n}\r\n}\r\nfeatures->done |= FEATURE_SCREEN;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init mini6410_machine_init(void)\r\n{\r\nu32 cs1;\r\nstruct mini6410_features_t features = { 0 };\r\nprintk(KERN_INFO "MINI6410: Option string mini6410=%s\n",\r\nmini6410_features_str);\r\nmini6410_parse_features(&features, mini6410_features_str);\r\nprintk(KERN_INFO "MINI6410: selected LCD display is %dx%d\n",\r\nmini6410_lcd_pdata[features.lcd_index].win[0]->xres,\r\nmini6410_lcd_pdata[features.lcd_index].win[0]->yres);\r\ns3c_nand_set_platdata(&mini6410_nand_info);\r\ns3c_fb_set_platdata(&mini6410_lcd_pdata[features.lcd_index]);\r\ns3c24xx_ts_set_platdata(NULL);\r\ncs1 = __raw_readl(S3C64XX_SROM_BW) &\r\n~(S3C64XX_SROM_BW__CS_MASK << S3C64XX_SROM_BW__NCS1__SHIFT);\r\ncs1 |= ((1 << S3C64XX_SROM_BW__DATAWIDTH__SHIFT) |\r\n(1 << S3C64XX_SROM_BW__WAITENABLE__SHIFT) |\r\n(1 << S3C64XX_SROM_BW__BYTEENABLE__SHIFT)) <<\r\nS3C64XX_SROM_BW__NCS1__SHIFT;\r\n__raw_writel(cs1, S3C64XX_SROM_BW);\r\n__raw_writel((0 << S3C64XX_SROM_BCX__PMC__SHIFT) |\r\n(6 << S3C64XX_SROM_BCX__TACP__SHIFT) |\r\n(4 << S3C64XX_SROM_BCX__TCAH__SHIFT) |\r\n(1 << S3C64XX_SROM_BCX__TCOH__SHIFT) |\r\n(13 << S3C64XX_SROM_BCX__TACC__SHIFT) |\r\n(4 << S3C64XX_SROM_BCX__TCOS__SHIFT) |\r\n(0 << S3C64XX_SROM_BCX__TACS__SHIFT), S3C64XX_SROM_BC1);\r\ngpio_request(S3C64XX_GPF(15), "LCD power");\r\ngpio_request(S3C64XX_GPE(0), "LCD power");\r\nplatform_add_devices(mini6410_devices, ARRAY_SIZE(mini6410_devices));\r\n}
