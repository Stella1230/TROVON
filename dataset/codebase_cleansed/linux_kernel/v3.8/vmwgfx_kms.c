void vmw_clip_cliprects(struct drm_clip_rect *rects,\r\nint num_rects,\r\nstruct vmw_clip_rect clip,\r\nSVGASignedRect *out_rects,\r\nint *out_num)\r\n{\r\nint i, k;\r\nfor (i = 0, k = 0; i < num_rects; i++) {\r\nint x1 = max_t(int, clip.x1, rects[i].x1);\r\nint y1 = max_t(int, clip.y1, rects[i].y1);\r\nint x2 = min_t(int, clip.x2, rects[i].x2);\r\nint y2 = min_t(int, clip.y2, rects[i].y2);\r\nif (x1 >= x2)\r\ncontinue;\r\nif (y1 >= y2)\r\ncontinue;\r\nout_rects[k].left = x1;\r\nout_rects[k].top = y1;\r\nout_rects[k].right = x2;\r\nout_rects[k].bottom = y2;\r\nk++;\r\n}\r\n*out_num = k;\r\n}\r\nvoid vmw_display_unit_cleanup(struct vmw_display_unit *du)\r\n{\r\nif (du->cursor_surface)\r\nvmw_surface_unreference(&du->cursor_surface);\r\nif (du->cursor_dmabuf)\r\nvmw_dmabuf_unreference(&du->cursor_dmabuf);\r\ndrm_crtc_cleanup(&du->crtc);\r\ndrm_encoder_cleanup(&du->encoder);\r\ndrm_connector_cleanup(&du->connector);\r\n}\r\nint vmw_cursor_update_image(struct vmw_private *dev_priv,\r\nu32 *image, u32 width, u32 height,\r\nu32 hotspotX, u32 hotspotY)\r\n{\r\nstruct {\r\nu32 cmd;\r\nSVGAFifoCmdDefineAlphaCursor cursor;\r\n} *cmd;\r\nu32 image_size = width * height * 4;\r\nu32 cmd_size = sizeof(*cmd) + image_size;\r\nif (!image)\r\nreturn -EINVAL;\r\ncmd = vmw_fifo_reserve(dev_priv, cmd_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\nmemcpy(&cmd[1], image, image_size);\r\ncmd->cmd = cpu_to_le32(SVGA_CMD_DEFINE_ALPHA_CURSOR);\r\ncmd->cursor.id = cpu_to_le32(0);\r\ncmd->cursor.width = cpu_to_le32(width);\r\ncmd->cursor.height = cpu_to_le32(height);\r\ncmd->cursor.hotspotX = cpu_to_le32(hotspotX);\r\ncmd->cursor.hotspotY = cpu_to_le32(hotspotY);\r\nvmw_fifo_commit(dev_priv, cmd_size);\r\nreturn 0;\r\n}\r\nint vmw_cursor_update_dmabuf(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *dmabuf,\r\nu32 width, u32 height,\r\nu32 hotspotX, u32 hotspotY)\r\n{\r\nstruct ttm_bo_kmap_obj map;\r\nunsigned long kmap_offset;\r\nunsigned long kmap_num;\r\nvoid *virtual;\r\nbool dummy;\r\nint ret;\r\nkmap_offset = 0;\r\nkmap_num = (width*height*4 + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nret = ttm_bo_reserve(&dmabuf->base, true, false, false, 0);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("reserve failed\n");\r\nreturn -EINVAL;\r\n}\r\nret = ttm_bo_kmap(&dmabuf->base, kmap_offset, kmap_num, &map);\r\nif (unlikely(ret != 0))\r\ngoto err_unreserve;\r\nvirtual = ttm_kmap_obj_virtual(&map, &dummy);\r\nret = vmw_cursor_update_image(dev_priv, virtual, width, height,\r\nhotspotX, hotspotY);\r\nttm_bo_kunmap(&map);\r\nerr_unreserve:\r\nttm_bo_unreserve(&dmabuf->base);\r\nreturn ret;\r\n}\r\nvoid vmw_cursor_update_position(struct vmw_private *dev_priv,\r\nbool show, int x, int y)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t count;\r\niowrite32(show ? 1 : 0, fifo_mem + SVGA_FIFO_CURSOR_ON);\r\niowrite32(x, fifo_mem + SVGA_FIFO_CURSOR_X);\r\niowrite32(y, fifo_mem + SVGA_FIFO_CURSOR_Y);\r\ncount = ioread32(fifo_mem + SVGA_FIFO_CURSOR_COUNT);\r\niowrite32(++count, fifo_mem + SVGA_FIFO_CURSOR_COUNT);\r\n}\r\nint vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,\r\nuint32_t handle, uint32_t width, uint32_t height)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nstruct vmw_surface *surface = NULL;\r\nstruct vmw_dma_buffer *dmabuf = NULL;\r\nint ret;\r\nif (handle && (width != 64 || height != 64))\r\nreturn -EINVAL;\r\nif (handle) {\r\nret = vmw_user_lookup_handle(dev_priv, tfile,\r\nhandle, &surface, &dmabuf);\r\nif (ret) {\r\nDRM_ERROR("failed to find surface or dmabuf: %i\n", ret);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (surface && !surface->snooper.image) {\r\nDRM_ERROR("surface not suitable for cursor\n");\r\nvmw_surface_unreference(&surface);\r\nreturn -EINVAL;\r\n}\r\nif (du->cursor_surface) {\r\ndu->cursor_surface->snooper.crtc = NULL;\r\nvmw_surface_unreference(&du->cursor_surface);\r\n}\r\nif (du->cursor_dmabuf)\r\nvmw_dmabuf_unreference(&du->cursor_dmabuf);\r\nif (surface) {\r\ndu->cursor_surface = surface;\r\ndu->cursor_surface->snooper.crtc = crtc;\r\ndu->cursor_age = du->cursor_surface->snooper.age;\r\nvmw_cursor_update_image(dev_priv, surface->snooper.image,\r\n64, 64, du->hotspot_x, du->hotspot_y);\r\n} else if (dmabuf) {\r\ndu->cursor_dmabuf = dmabuf;\r\nret = vmw_cursor_update_dmabuf(dev_priv, dmabuf, width, height,\r\ndu->hotspot_x, du->hotspot_y);\r\n} else {\r\nvmw_cursor_update_position(dev_priv, false, 0, 0);\r\nreturn 0;\r\n}\r\nvmw_cursor_update_position(dev_priv, true,\r\ndu->cursor_x + du->hotspot_x,\r\ndu->cursor_y + du->hotspot_y);\r\nreturn 0;\r\n}\r\nint vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nbool shown = du->cursor_surface || du->cursor_dmabuf ? true : false;\r\ndu->cursor_x = x + crtc->x;\r\ndu->cursor_y = y + crtc->y;\r\nvmw_cursor_update_position(dev_priv, shown,\r\ndu->cursor_x + du->hotspot_x,\r\ndu->cursor_y + du->hotspot_y);\r\nreturn 0;\r\n}\r\nvoid vmw_kms_cursor_snoop(struct vmw_surface *srf,\r\nstruct ttm_object_file *tfile,\r\nstruct ttm_buffer_object *bo,\r\nSVGA3dCmdHeader *header)\r\n{\r\nstruct ttm_bo_kmap_obj map;\r\nunsigned long kmap_offset;\r\nunsigned long kmap_num;\r\nSVGA3dCopyBox *box;\r\nunsigned box_count;\r\nvoid *virtual;\r\nbool dummy;\r\nstruct vmw_dma_cmd {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSurfaceDMA dma;\r\n} *cmd;\r\nint i, ret;\r\ncmd = container_of(header, struct vmw_dma_cmd, header);\r\nif (!srf->snooper.image)\r\nreturn;\r\nif (cmd->dma.host.face != 0 || cmd->dma.host.mipmap != 0) {\r\nDRM_ERROR("face and mipmap for cursors should never != 0\n");\r\nreturn;\r\n}\r\nif (cmd->header.size < 64) {\r\nDRM_ERROR("at least one full copy box must be given\n");\r\nreturn;\r\n}\r\nbox = (SVGA3dCopyBox *)&cmd[1];\r\nbox_count = (cmd->header.size - sizeof(SVGA3dCmdSurfaceDMA)) /\r\nsizeof(SVGA3dCopyBox);\r\nif (cmd->dma.guest.ptr.offset % PAGE_SIZE ||\r\nbox->x != 0 || box->y != 0 || box->z != 0 ||\r\nbox->srcx != 0 || box->srcy != 0 || box->srcz != 0 ||\r\nbox->d != 1 || box_count != 1) {\r\nDRM_ERROR("Cant snoop dma request for cursor!\n");\r\nDRM_ERROR("(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",\r\nbox->srcx, box->srcy, box->srcz,\r\nbox->x, box->y, box->z,\r\nbox->w, box->h, box->d, box_count,\r\ncmd->dma.guest.ptr.offset);\r\nreturn;\r\n}\r\nkmap_offset = cmd->dma.guest.ptr.offset >> PAGE_SHIFT;\r\nkmap_num = (64*64*4) >> PAGE_SHIFT;\r\nret = ttm_bo_reserve(bo, true, false, false, 0);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("reserve failed\n");\r\nreturn;\r\n}\r\nret = ttm_bo_kmap(bo, kmap_offset, kmap_num, &map);\r\nif (unlikely(ret != 0))\r\ngoto err_unreserve;\r\nvirtual = ttm_kmap_obj_virtual(&map, &dummy);\r\nif (box->w == 64 && cmd->dma.guest.pitch == 64*4) {\r\nmemcpy(srf->snooper.image, virtual, 64*64*4);\r\n} else {\r\nfor (i = 0; i < box->h; i++)\r\nmemcpy(srf->snooper.image + i * 64,\r\nvirtual + i * cmd->dma.guest.pitch,\r\nbox->w * 4);\r\n}\r\nsrf->snooper.age++;\r\nttm_bo_kunmap(&map);\r\nerr_unreserve:\r\nttm_bo_unreserve(bo);\r\n}\r\nvoid vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_display_unit *du;\r\nstruct drm_crtc *crtc;\r\nmutex_lock(&dev->mode_config.mutex);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\ndu = vmw_crtc_to_du(crtc);\r\nif (!du->cursor_surface ||\r\ndu->cursor_age == du->cursor_surface->snooper.age)\r\ncontinue;\r\ndu->cursor_age = du->cursor_surface->snooper.age;\r\nvmw_cursor_update_image(dev_priv,\r\ndu->cursor_surface->snooper.image,\r\n64, 64, du->hotspot_x, du->hotspot_y);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nint vmw_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nif (handle)\r\n*handle = 0;\r\nreturn 0;\r\n}\r\nvoid vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(framebuffer);\r\nstruct vmw_master *vmaster = vmw_master(vfbs->master);\r\nmutex_lock(&vmaster->fb_surf_mutex);\r\nlist_del(&vfbs->head);\r\nmutex_unlock(&vmaster->fb_surf_mutex);\r\ndrm_master_put(&vfbs->master);\r\ndrm_framebuffer_cleanup(framebuffer);\r\nvmw_surface_unreference(&vfbs->surface);\r\nttm_base_object_unref(&vfbs->base.user_obj);\r\nkfree(vfbs);\r\n}\r\nstatic int do_surface_dirty_sou(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips, int inc,\r\nstruct vmw_fence_obj **out_fence)\r\n{\r\nstruct vmw_display_unit *units[VMWGFX_NUM_DISPLAY_UNITS];\r\nstruct drm_clip_rect *clips_ptr;\r\nstruct drm_clip_rect *tmp;\r\nstruct drm_crtc *crtc;\r\nsize_t fifo_size;\r\nint i, num_units;\r\nint ret = 0;\r\nint left, right, top, bottom;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBlitSurfaceToScreen body;\r\n} *cmd;\r\nSVGASignedRect *blits;\r\nnum_units = 0;\r\nlist_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list,\r\nhead) {\r\nif (crtc->fb != &framebuffer->base)\r\ncontinue;\r\nunits[num_units++] = vmw_crtc_to_du(crtc);\r\n}\r\nBUG_ON(!clips || !num_clips);\r\ntmp = kzalloc(sizeof(*tmp) * num_clips, GFP_KERNEL);\r\nif (unlikely(tmp == NULL)) {\r\nDRM_ERROR("Temporary cliprect memory alloc failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nfifo_size = sizeof(*cmd) + sizeof(SVGASignedRect) * num_clips;\r\ncmd = kzalloc(fifo_size, GFP_KERNEL);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Temporary fifo memory alloc failed.\n");\r\nret = -ENOMEM;\r\ngoto out_free_tmp;\r\n}\r\nblits = (SVGASignedRect *)&cmd[1];\r\nleft = clips->x1;\r\nright = clips->x2;\r\ntop = clips->y1;\r\nbottom = clips->y2;\r\nfor (i = 1, clips_ptr = clips + inc;\r\ni < num_clips; i++, clips_ptr += inc) {\r\nleft = min_t(int, left, (int)clips_ptr->x1);\r\nright = max_t(int, right, (int)clips_ptr->x2);\r\ntop = min_t(int, top, (int)clips_ptr->y1);\r\nbottom = max_t(int, bottom, (int)clips_ptr->y2);\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN);\r\ncmd->header.size = cpu_to_le32(fifo_size - sizeof(cmd->header));\r\ncmd->body.srcRect.left = left;\r\ncmd->body.srcRect.right = right;\r\ncmd->body.srcRect.top = top;\r\ncmd->body.srcRect.bottom = bottom;\r\nclips_ptr = clips;\r\nfor (i = 0; i < num_clips; i++, clips_ptr += inc) {\r\ntmp[i].x1 = clips_ptr->x1 - left;\r\ntmp[i].x2 = clips_ptr->x2 - left;\r\ntmp[i].y1 = clips_ptr->y1 - top;\r\ntmp[i].y2 = clips_ptr->y2 - top;\r\n}\r\nfor (i = 0; i < num_units; i++) {\r\nstruct vmw_display_unit *unit = units[i];\r\nstruct vmw_clip_rect clip;\r\nint num;\r\nclip.x1 = left - unit->crtc.x;\r\nclip.y1 = top - unit->crtc.y;\r\nclip.x2 = right - unit->crtc.x;\r\nclip.y2 = bottom - unit->crtc.y;\r\nif (clip.x1 >= unit->crtc.mode.hdisplay ||\r\nclip.y1 >= unit->crtc.mode.vdisplay ||\r\nclip.x2 <= 0 || clip.y2 <= 0)\r\ncontinue;\r\ncmd->body.destRect.left = clip.x1;\r\ncmd->body.destRect.right = clip.x2;\r\ncmd->body.destRect.top = clip.y1;\r\ncmd->body.destRect.bottom = clip.y2;\r\nclip.x2 = unit->crtc.mode.hdisplay - clip.x1;\r\nclip.y2 = unit->crtc.mode.vdisplay - clip.y1;\r\nclip.x1 = 0 - clip.x1;\r\nclip.y1 = 0 - clip.y1;\r\ncmd->body.srcImage.sid = cpu_to_le32(framebuffer->user_handle);\r\ncmd->body.destScreenId = unit->unit;\r\nvmw_clip_cliprects(tmp, num_clips, clip, blits, &num);\r\nif (num == 0)\r\ncontinue;\r\nif (out_fence && *out_fence)\r\nvmw_fence_obj_unreference(out_fence);\r\nfifo_size = sizeof(*cmd) + sizeof(SVGASignedRect) * num;\r\ncmd->header.size = cpu_to_le32(fifo_size - sizeof(cmd->header));\r\nret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,\r\nfifo_size, 0, NULL, out_fence);\r\nif (unlikely(ret != 0))\r\nbreak;\r\n}\r\nkfree(cmd);\r\nout_free_tmp:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nint vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(framebuffer);\r\nstruct drm_clip_rect norect;\r\nint ret, inc = 1;\r\nif (unlikely(vfbs->master != file_priv->master))\r\nreturn -EINVAL;\r\nif (!dev_priv->sou_priv)\r\nreturn -EINVAL;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = framebuffer->width;\r\nnorect.y2 = framebuffer->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\ninc = 2;\r\n}\r\nret = do_surface_dirty_sou(dev_priv, file_priv, &vfbs->base,\r\nflags, color,\r\nclips, num_clips, inc, NULL);\r\nttm_read_unlock(&vmaster->lock);\r\nreturn 0;\r\n}\r\nstatic int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_surface *surface,\r\nstruct vmw_framebuffer **out,\r\nconst struct drm_mode_fb_cmd\r\n*mode_cmd)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_framebuffer_surface *vfbs;\r\nenum SVGA3dSurfaceFormat format;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nif (!dev_priv->sou_priv)\r\nreturn -ENOSYS;\r\nif (unlikely(!surface->scanout))\r\nreturn -EINVAL;\r\nif (unlikely(surface->mip_levels[0] != 1 ||\r\nsurface->num_sizes != 1 ||\r\nsurface->sizes[0].width < mode_cmd->width ||\r\nsurface->sizes[0].height < mode_cmd->height ||\r\nsurface->sizes[0].depth != 1)) {\r\nDRM_ERROR("Incompatible surface dimensions "\r\n"for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (mode_cmd->depth) {\r\ncase 32:\r\nformat = SVGA3D_A8R8G8B8;\r\nbreak;\r\ncase 24:\r\nformat = SVGA3D_X8R8G8B8;\r\nbreak;\r\ncase 16:\r\nformat = SVGA3D_R5G6B5;\r\nbreak;\r\ncase 15:\r\nformat = SVGA3D_A1R5G5B5;\r\nbreak;\r\ncase 8:\r\nformat = SVGA3D_LUMINANCE8;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid color depth: %d\n", mode_cmd->depth);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(format != surface->format)) {\r\nDRM_ERROR("Invalid surface format for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nvfbs = kzalloc(sizeof(*vfbs), GFP_KERNEL);\r\nif (!vfbs) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\nret = drm_framebuffer_init(dev, &vfbs->base.base,\r\n&vmw_framebuffer_surface_funcs);\r\nif (ret)\r\ngoto out_err2;\r\nif (!vmw_surface_reference(surface)) {\r\nDRM_ERROR("failed to reference surface %p\n", surface);\r\ngoto out_err3;\r\n}\r\nvfbs->base.base.bits_per_pixel = mode_cmd->bpp;\r\nvfbs->base.base.pitches[0] = mode_cmd->pitch;\r\nvfbs->base.base.depth = mode_cmd->depth;\r\nvfbs->base.base.width = mode_cmd->width;\r\nvfbs->base.base.height = mode_cmd->height;\r\nvfbs->surface = surface;\r\nvfbs->base.user_handle = mode_cmd->handle;\r\nvfbs->master = drm_master_get(file_priv->master);\r\nmutex_lock(&vmaster->fb_surf_mutex);\r\nlist_add_tail(&vfbs->head, &vmaster->fb_surf);\r\nmutex_unlock(&vmaster->fb_surf_mutex);\r\n*out = &vfbs->base;\r\nreturn 0;\r\nout_err3:\r\ndrm_framebuffer_cleanup(&vfbs->base.base);\r\nout_err2:\r\nkfree(vfbs);\r\nout_err1:\r\nreturn ret;\r\n}\r\nvoid vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(framebuffer);\r\ndrm_framebuffer_cleanup(framebuffer);\r\nvmw_dmabuf_unreference(&vfbd->buffer);\r\nttm_base_object_unref(&vfbd->base.user_obj);\r\nkfree(vfbd);\r\n}\r\nstatic int do_dmabuf_dirty_ldu(struct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips, int increment)\r\n{\r\nsize_t fifo_size;\r\nint i;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdUpdate body;\r\n} *cmd;\r\nfifo_size = sizeof(*cmd) * num_clips;\r\ncmd = vmw_fifo_reserve(dev_priv, fifo_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\nfor (i = 0; i < num_clips; i++, clips += increment) {\r\ncmd[i].header = cpu_to_le32(SVGA_CMD_UPDATE);\r\ncmd[i].body.x = cpu_to_le32(clips->x1);\r\ncmd[i].body.y = cpu_to_le32(clips->y1);\r\ncmd[i].body.width = cpu_to_le32(clips->x2 - clips->x1);\r\ncmd[i].body.height = cpu_to_le32(clips->y2 - clips->y1);\r\n}\r\nvmw_fifo_commit(dev_priv, fifo_size);\r\nreturn 0;\r\n}\r\nstatic int do_dmabuf_define_gmrfb(struct drm_file *file_priv,\r\nstruct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer)\r\n{\r\nint depth = framebuffer->base.depth;\r\nsize_t fifo_size;\r\nint ret;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdDefineGMRFB body;\r\n} *cmd;\r\nif (depth == 32)\r\ndepth = 24;\r\nfifo_size = sizeof(*cmd);\r\ncmd = kmalloc(fifo_size, GFP_KERNEL);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed to allocate temporary cmd buffer.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header = SVGA_CMD_DEFINE_GMRFB;\r\ncmd->body.format.bitsPerPixel = framebuffer->base.bits_per_pixel;\r\ncmd->body.format.colorDepth = depth;\r\ncmd->body.format.reserved = 0;\r\ncmd->body.bytesPerLine = framebuffer->base.pitches[0];\r\ncmd->body.ptr.gmrId = framebuffer->user_handle;\r\ncmd->body.ptr.offset = 0;\r\nret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,\r\nfifo_size, 0, NULL, NULL);\r\nkfree(cmd);\r\nreturn ret;\r\n}\r\nstatic int do_dmabuf_dirty_sou(struct drm_file *file_priv,\r\nstruct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips, int increment,\r\nstruct vmw_fence_obj **out_fence)\r\n{\r\nstruct vmw_display_unit *units[VMWGFX_NUM_DISPLAY_UNITS];\r\nstruct drm_clip_rect *clips_ptr;\r\nint i, k, num_units, ret;\r\nstruct drm_crtc *crtc;\r\nsize_t fifo_size;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdBlitGMRFBToScreen body;\r\n} *blits;\r\nret = do_dmabuf_define_gmrfb(file_priv, dev_priv, framebuffer);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nfifo_size = sizeof(*blits) * num_clips;\r\nblits = kmalloc(fifo_size, GFP_KERNEL);\r\nif (unlikely(blits == NULL)) {\r\nDRM_ERROR("Failed to allocate temporary cmd buffer.\n");\r\nreturn -ENOMEM;\r\n}\r\nnum_units = 0;\r\nlist_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list, head) {\r\nif (crtc->fb != &framebuffer->base)\r\ncontinue;\r\nunits[num_units++] = vmw_crtc_to_du(crtc);\r\n}\r\nfor (k = 0; k < num_units; k++) {\r\nstruct vmw_display_unit *unit = units[k];\r\nint hit_num = 0;\r\nclips_ptr = clips;\r\nfor (i = 0; i < num_clips; i++, clips_ptr += increment) {\r\nint clip_x1 = clips_ptr->x1 - unit->crtc.x;\r\nint clip_y1 = clips_ptr->y1 - unit->crtc.y;\r\nint clip_x2 = clips_ptr->x2 - unit->crtc.x;\r\nint clip_y2 = clips_ptr->y2 - unit->crtc.y;\r\nint move_x, move_y;\r\nif (clip_x1 >= unit->crtc.mode.hdisplay ||\r\nclip_y1 >= unit->crtc.mode.vdisplay ||\r\nclip_x2 <= 0 || clip_y2 <= 0)\r\ncontinue;\r\nclip_x2 = min_t(int, clip_x2, unit->crtc.mode.hdisplay);\r\nclip_y2 = min_t(int, clip_y2, unit->crtc.mode.vdisplay);\r\nmove_x = min_t(int, clip_x1, 0);\r\nmove_y = min_t(int, clip_y1, 0);\r\nblits[hit_num].header = SVGA_CMD_BLIT_GMRFB_TO_SCREEN;\r\nblits[hit_num].body.destScreenId = unit->unit;\r\nblits[hit_num].body.srcOrigin.x = clips_ptr->x1 - move_x;\r\nblits[hit_num].body.srcOrigin.y = clips_ptr->y1 - move_y;\r\nblits[hit_num].body.destRect.left = clip_x1 - move_x;\r\nblits[hit_num].body.destRect.top = clip_y1 - move_y;\r\nblits[hit_num].body.destRect.right = clip_x2;\r\nblits[hit_num].body.destRect.bottom = clip_y2;\r\nhit_num++;\r\n}\r\nif (hit_num == 0)\r\ncontinue;\r\nif (out_fence && *out_fence)\r\nvmw_fence_obj_unreference(out_fence);\r\nfifo_size = sizeof(*blits) * hit_num;\r\nret = vmw_execbuf_process(file_priv, dev_priv, NULL, blits,\r\nfifo_size, 0, NULL, out_fence);\r\nif (unlikely(ret != 0))\r\nbreak;\r\n}\r\nkfree(blits);\r\nreturn ret;\r\n}\r\nint vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(framebuffer);\r\nstruct drm_clip_rect norect;\r\nint ret, increment = 1;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = framebuffer->width;\r\nnorect.y2 = framebuffer->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\nincrement = 2;\r\n}\r\nif (dev_priv->ldu_priv) {\r\nret = do_dmabuf_dirty_ldu(dev_priv, &vfbd->base,\r\nflags, color,\r\nclips, num_clips, increment);\r\n} else {\r\nret = do_dmabuf_dirty_sou(file_priv, dev_priv, &vfbd->base,\r\nflags, color,\r\nclips, num_clips, increment, NULL);\r\n}\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nstatic int vmw_framebuffer_dmabuf_pin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(&vfb->base);\r\nint ret;\r\nBUG_ON(dev_priv->sou_priv);\r\nvmw_overlay_pause_all(dev_priv);\r\nret = vmw_dmabuf_to_start_of_vram(dev_priv, vfbd->buffer, true, false);\r\nvmw_overlay_resume_all(dev_priv);\r\nWARN_ON(ret != 0);\r\nreturn 0;\r\n}\r\nstatic int vmw_framebuffer_dmabuf_unpin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(&vfb->base);\r\nif (!vfbd->buffer) {\r\nWARN_ON(!vfbd->buffer);\r\nreturn 0;\r\n}\r\nreturn vmw_dmabuf_unpin(dev_priv, vfbd->buffer, false);\r\n}\r\nstatic int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *dmabuf,\r\nstruct vmw_framebuffer **out,\r\nconst struct drm_mode_fb_cmd\r\n*mode_cmd)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_framebuffer_dmabuf *vfbd;\r\nunsigned int requested_size;\r\nint ret;\r\nrequested_size = mode_cmd->height * mode_cmd->pitch;\r\nif (unlikely(requested_size > dmabuf->base.num_pages * PAGE_SIZE)) {\r\nDRM_ERROR("Screen buffer object size is too small "\r\n"for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev_priv->sou_priv) {\r\nswitch (mode_cmd->depth) {\r\ncase 32:\r\ncase 24:\r\nif (mode_cmd->bpp == 32)\r\nbreak;\r\nDRM_ERROR("Invalid color depth/bbp: %d %d\n",\r\nmode_cmd->depth, mode_cmd->bpp);\r\nreturn -EINVAL;\r\ncase 16:\r\ncase 15:\r\nif (mode_cmd->bpp == 16)\r\nbreak;\r\nDRM_ERROR("Invalid color depth/bbp: %d %d\n",\r\nmode_cmd->depth, mode_cmd->bpp);\r\nreturn -EINVAL;\r\ndefault:\r\nDRM_ERROR("Invalid color depth: %d\n", mode_cmd->depth);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvfbd = kzalloc(sizeof(*vfbd), GFP_KERNEL);\r\nif (!vfbd) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\nret = drm_framebuffer_init(dev, &vfbd->base.base,\r\n&vmw_framebuffer_dmabuf_funcs);\r\nif (ret)\r\ngoto out_err2;\r\nif (!vmw_dmabuf_reference(dmabuf)) {\r\nDRM_ERROR("failed to reference dmabuf %p\n", dmabuf);\r\ngoto out_err3;\r\n}\r\nvfbd->base.base.bits_per_pixel = mode_cmd->bpp;\r\nvfbd->base.base.pitches[0] = mode_cmd->pitch;\r\nvfbd->base.base.depth = mode_cmd->depth;\r\nvfbd->base.base.width = mode_cmd->width;\r\nvfbd->base.base.height = mode_cmd->height;\r\nif (!dev_priv->sou_priv) {\r\nvfbd->base.pin = vmw_framebuffer_dmabuf_pin;\r\nvfbd->base.unpin = vmw_framebuffer_dmabuf_unpin;\r\n}\r\nvfbd->base.dmabuf = true;\r\nvfbd->buffer = dmabuf;\r\nvfbd->base.user_handle = mode_cmd->handle;\r\n*out = &vfbd->base;\r\nreturn 0;\r\nout_err3:\r\ndrm_framebuffer_cleanup(&vfbd->base.base);\r\nout_err2:\r\nkfree(vfbd);\r\nout_err1:\r\nreturn ret;\r\n}\r\nstatic struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd2 *mode_cmd2)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_framebuffer *vfb = NULL;\r\nstruct vmw_surface *surface = NULL;\r\nstruct vmw_dma_buffer *bo = NULL;\r\nstruct ttm_base_object *user_obj;\r\nstruct drm_mode_fb_cmd mode_cmd;\r\nint ret;\r\nmode_cmd.width = mode_cmd2->width;\r\nmode_cmd.height = mode_cmd2->height;\r\nmode_cmd.pitch = mode_cmd2->pitches[0];\r\nmode_cmd.handle = mode_cmd2->handles[0];\r\ndrm_fb_get_bpp_depth(mode_cmd2->pixel_format, &mode_cmd.depth,\r\n&mode_cmd.bpp);\r\nif (!vmw_kms_validate_mode_vram(dev_priv,\r\nmode_cmd.pitch,\r\nmode_cmd.height)) {\r\nDRM_ERROR("VRAM size is too small for requested mode.\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nuser_obj = ttm_base_object_lookup(tfile, mode_cmd.handle);\r\nif (unlikely(user_obj == NULL)) {\r\nDRM_ERROR("Could not locate requested kms frame buffer.\n");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nret = vmw_user_lookup_handle(dev_priv, tfile,\r\nmode_cmd.handle,\r\n&surface, &bo);\r\nif (ret)\r\ngoto err_out;\r\nif (bo)\r\nret = vmw_kms_new_framebuffer_dmabuf(dev_priv, bo, &vfb,\r\n&mode_cmd);\r\nelse if (surface)\r\nret = vmw_kms_new_framebuffer_surface(dev_priv, file_priv,\r\nsurface, &vfb, &mode_cmd);\r\nelse\r\nBUG();\r\nerr_out:\r\nif (bo)\r\nvmw_dmabuf_unreference(&bo);\r\nif (surface)\r\nvmw_surface_unreference(&surface);\r\nif (ret) {\r\nDRM_ERROR("failed to create vmw_framebuffer: %i\n", ret);\r\nttm_base_object_unref(&user_obj);\r\nreturn ERR_PTR(ret);\r\n} else\r\nvfb->user_obj = user_obj;\r\nreturn &vfb->base;\r\n}\r\nint vmw_kms_present(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct vmw_surface *surface,\r\nuint32_t sid,\r\nint32_t destX, int32_t destY,\r\nstruct drm_vmw_rect *clips,\r\nuint32_t num_clips)\r\n{\r\nstruct vmw_display_unit *units[VMWGFX_NUM_DISPLAY_UNITS];\r\nstruct drm_clip_rect *tmp;\r\nstruct drm_crtc *crtc;\r\nsize_t fifo_size;\r\nint i, k, num_units;\r\nint ret = 0;\r\nint left, right, top, bottom;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBlitSurfaceToScreen body;\r\n} *cmd;\r\nSVGASignedRect *blits;\r\nnum_units = 0;\r\nlist_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list, head) {\r\nif (crtc->fb != &vfb->base)\r\ncontinue;\r\nunits[num_units++] = vmw_crtc_to_du(crtc);\r\n}\r\nBUG_ON(surface == NULL);\r\nBUG_ON(!clips || !num_clips);\r\ntmp = kzalloc(sizeof(*tmp) * num_clips, GFP_KERNEL);\r\nif (unlikely(tmp == NULL)) {\r\nDRM_ERROR("Temporary cliprect memory alloc failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nfifo_size = sizeof(*cmd) + sizeof(SVGASignedRect) * num_clips;\r\ncmd = kmalloc(fifo_size, GFP_KERNEL);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed to allocate temporary fifo memory.\n");\r\nret = -ENOMEM;\r\ngoto out_free_tmp;\r\n}\r\nleft = clips->x;\r\nright = clips->x + clips->w;\r\ntop = clips->y;\r\nbottom = clips->y + clips->h;\r\nfor (i = 1; i < num_clips; i++) {\r\nleft = min_t(int, left, (int)clips[i].x);\r\nright = max_t(int, right, (int)clips[i].x + clips[i].w);\r\ntop = min_t(int, top, (int)clips[i].y);\r\nbottom = max_t(int, bottom, (int)clips[i].y + clips[i].h);\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_BLIT_SURFACE_TO_SCREEN);\r\nblits = (SVGASignedRect *)&cmd[1];\r\ncmd->body.srcRect.left = left;\r\ncmd->body.srcRect.right = right;\r\ncmd->body.srcRect.top = top;\r\ncmd->body.srcRect.bottom = bottom;\r\nfor (i = 0; i < num_clips; i++) {\r\ntmp[i].x1 = clips[i].x - left;\r\ntmp[i].x2 = clips[i].x + clips[i].w - left;\r\ntmp[i].y1 = clips[i].y - top;\r\ntmp[i].y2 = clips[i].y + clips[i].h - top;\r\n}\r\nfor (k = 0; k < num_units; k++) {\r\nstruct vmw_display_unit *unit = units[k];\r\nstruct vmw_clip_rect clip;\r\nint num;\r\nclip.x1 = left + destX - unit->crtc.x;\r\nclip.y1 = top + destY - unit->crtc.y;\r\nclip.x2 = right + destX - unit->crtc.x;\r\nclip.y2 = bottom + destY - unit->crtc.y;\r\nif (clip.x1 >= unit->crtc.mode.hdisplay ||\r\nclip.y1 >= unit->crtc.mode.vdisplay ||\r\nclip.x2 <= 0 || clip.y2 <= 0)\r\ncontinue;\r\ncmd->body.destRect.left = clip.x1;\r\ncmd->body.destRect.right = clip.x2;\r\ncmd->body.destRect.top = clip.y1;\r\ncmd->body.destRect.bottom = clip.y2;\r\nclip.x2 = unit->crtc.mode.hdisplay - clip.x1;\r\nclip.y2 = unit->crtc.mode.vdisplay - clip.y1;\r\nclip.x1 = 0 - clip.x1;\r\nclip.y1 = 0 - clip.y1;\r\ncmd->body.srcImage.sid = sid;\r\ncmd->body.destScreenId = unit->unit;\r\nvmw_clip_cliprects(tmp, num_clips, clip, blits, &num);\r\nif (num == 0)\r\ncontinue;\r\nfifo_size = sizeof(*cmd) + sizeof(SVGASignedRect) * num;\r\ncmd->header.size = cpu_to_le32(fifo_size - sizeof(cmd->header));\r\nret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,\r\nfifo_size, 0, NULL, NULL);\r\nif (unlikely(ret != 0))\r\nbreak;\r\n}\r\nkfree(cmd);\r\nout_free_tmp:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nint vmw_kms_readback(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct drm_vmw_fence_rep __user *user_fence_rep,\r\nstruct drm_vmw_rect *clips,\r\nuint32_t num_clips)\r\n{\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(&vfb->base);\r\nstruct vmw_dma_buffer *dmabuf = vfbd->buffer;\r\nstruct vmw_display_unit *units[VMWGFX_NUM_DISPLAY_UNITS];\r\nstruct drm_crtc *crtc;\r\nsize_t fifo_size;\r\nint i, k, ret, num_units, blits_pos;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdDefineGMRFB body;\r\n} *cmd;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdBlitScreenToGMRFB body;\r\n} *blits;\r\nnum_units = 0;\r\nlist_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list, head) {\r\nif (crtc->fb != &vfb->base)\r\ncontinue;\r\nunits[num_units++] = vmw_crtc_to_du(crtc);\r\n}\r\nBUG_ON(dmabuf == NULL);\r\nBUG_ON(!clips || !num_clips);\r\nfifo_size = sizeof(*cmd) + sizeof(*blits) * num_clips * num_units;\r\ncmd = kmalloc(fifo_size, GFP_KERNEL);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed to allocate temporary fifo memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header = SVGA_CMD_DEFINE_GMRFB;\r\ncmd->body.format.bitsPerPixel = vfb->base.bits_per_pixel;\r\ncmd->body.format.colorDepth = vfb->base.depth;\r\ncmd->body.format.reserved = 0;\r\ncmd->body.bytesPerLine = vfb->base.pitches[0];\r\ncmd->body.ptr.gmrId = vfb->user_handle;\r\ncmd->body.ptr.offset = 0;\r\nblits = (void *)&cmd[1];\r\nblits_pos = 0;\r\nfor (i = 0; i < num_units; i++) {\r\nstruct drm_vmw_rect *c = clips;\r\nfor (k = 0; k < num_clips; k++, c++) {\r\nint clip_x1 = c->x - units[i]->crtc.x;\r\nint clip_x2 = c->x - units[i]->crtc.x + c->w;\r\nint clip_y1 = c->y - units[i]->crtc.y;\r\nint clip_y2 = c->y - units[i]->crtc.y + c->h;\r\nint dest_x = c->x;\r\nint dest_y = c->y;\r\nif (clip_x1 < 0)\r\ndest_x += -clip_x1;\r\nif (clip_y1 < 0)\r\ndest_y += -clip_y1;\r\nclip_x1 = max(clip_x1, 0);\r\nclip_y1 = max(clip_y1, 0);\r\nclip_x2 = min(clip_x2, units[i]->crtc.mode.hdisplay);\r\nclip_y2 = min(clip_y2, units[i]->crtc.mode.vdisplay);\r\nif (clip_x1 >= units[i]->crtc.mode.hdisplay ||\r\nclip_y1 >= units[i]->crtc.mode.vdisplay ||\r\nclip_x2 <= 0 || clip_y2 <= 0)\r\ncontinue;\r\nblits[blits_pos].header = SVGA_CMD_BLIT_SCREEN_TO_GMRFB;\r\nblits[blits_pos].body.srcScreenId = units[i]->unit;\r\nblits[blits_pos].body.destOrigin.x = dest_x;\r\nblits[blits_pos].body.destOrigin.y = dest_y;\r\nblits[blits_pos].body.srcRect.left = clip_x1;\r\nblits[blits_pos].body.srcRect.top = clip_y1;\r\nblits[blits_pos].body.srcRect.right = clip_x2;\r\nblits[blits_pos].body.srcRect.bottom = clip_y2;\r\nblits_pos++;\r\n}\r\n}\r\nfifo_size = sizeof(*cmd) + sizeof(*blits) * blits_pos;\r\nret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd, fifo_size,\r\n0, user_fence_rep, NULL);\r\nkfree(cmd);\r\nreturn ret;\r\n}\r\nint vmw_kms_init(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint ret;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = &vmw_kms_funcs;\r\ndev->mode_config.min_width = 1;\r\ndev->mode_config.min_height = 1;\r\ndev->mode_config.max_width = 8192;\r\ndev->mode_config.max_height = 8192;\r\nret = vmw_kms_init_screen_object_display(dev_priv);\r\nif (ret)\r\n(void)vmw_kms_init_legacy_display_system(dev_priv);\r\nreturn 0;\r\n}\r\nint vmw_kms_close(struct vmw_private *dev_priv)\r\n{\r\ndrm_mode_config_cleanup(dev_priv->dev);\r\nif (dev_priv->sou_priv)\r\nvmw_kms_close_screen_object_display(dev_priv);\r\nelse\r\nvmw_kms_close_legacy_display_system(dev_priv);\r\nreturn 0;\r\n}\r\nint vmw_kms_cursor_bypass_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_cursor_bypass_arg *arg = data;\r\nstruct vmw_display_unit *du;\r\nstruct drm_mode_object *obj;\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\nmutex_lock(&dev->mode_config.mutex);\r\nif (arg->flags & DRM_VMW_CURSOR_BYPASS_ALL) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = arg->xhot;\r\ndu->hotspot_y = arg->yhot;\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn 0;\r\n}\r\nobj = drm_mode_object_find(dev, arg->crtc_id, DRM_MODE_OBJECT_CRTC);\r\nif (!obj) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncrtc = obj_to_crtc(obj);\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = arg->xhot;\r\ndu->hotspot_y = arg->yhot;\r\nout:\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nint vmw_kms_write_svga(struct vmw_private *vmw_priv,\r\nunsigned width, unsigned height, unsigned pitch,\r\nunsigned bpp, unsigned depth)\r\n{\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_write(vmw_priv, SVGA_REG_PITCHLOCK, pitch);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\niowrite32(pitch, vmw_priv->mmio_virt + SVGA_FIFO_PITCHLOCK);\r\nvmw_write(vmw_priv, SVGA_REG_WIDTH, width);\r\nvmw_write(vmw_priv, SVGA_REG_HEIGHT, height);\r\nvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, bpp);\r\nif (vmw_read(vmw_priv, SVGA_REG_DEPTH) != depth) {\r\nDRM_ERROR("Invalid depth %u for %u bpp, host expects %u\n",\r\ndepth, bpp, vmw_read(vmw_priv, SVGA_REG_DEPTH));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_save_vga(struct vmw_private *vmw_priv)\r\n{\r\nstruct vmw_vga_topology_state *save;\r\nuint32_t i;\r\nvmw_priv->vga_width = vmw_read(vmw_priv, SVGA_REG_WIDTH);\r\nvmw_priv->vga_height = vmw_read(vmw_priv, SVGA_REG_HEIGHT);\r\nvmw_priv->vga_bpp = vmw_read(vmw_priv, SVGA_REG_BITS_PER_PIXEL);\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_priv->vga_pitchlock =\r\nvmw_read(vmw_priv, SVGA_REG_PITCHLOCK);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\nvmw_priv->vga_pitchlock = ioread32(vmw_priv->mmio_virt +\r\nSVGA_FIFO_PITCHLOCK);\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY))\r\nreturn 0;\r\nvmw_priv->num_displays = vmw_read(vmw_priv,\r\nSVGA_REG_NUM_GUEST_DISPLAYS);\r\nif (vmw_priv->num_displays == 0)\r\nvmw_priv->num_displays = 1;\r\nfor (i = 0; i < vmw_priv->num_displays; ++i) {\r\nsave = &vmw_priv->vga_save[i];\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, i);\r\nsave->primary = vmw_read(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY);\r\nsave->pos_x = vmw_read(vmw_priv, SVGA_REG_DISPLAY_POSITION_X);\r\nsave->pos_y = vmw_read(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y);\r\nsave->width = vmw_read(vmw_priv, SVGA_REG_DISPLAY_WIDTH);\r\nsave->height = vmw_read(vmw_priv, SVGA_REG_DISPLAY_HEIGHT);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\nif (i == 0 && vmw_priv->num_displays == 1 &&\r\nsave->width == 0 && save->height == 0) {\r\nsave->width = vmw_priv->vga_width - save->pos_x;\r\nsave->height = vmw_priv->vga_height - save->pos_y;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_restore_vga(struct vmw_private *vmw_priv)\r\n{\r\nstruct vmw_vga_topology_state *save;\r\nuint32_t i;\r\nvmw_write(vmw_priv, SVGA_REG_WIDTH, vmw_priv->vga_width);\r\nvmw_write(vmw_priv, SVGA_REG_HEIGHT, vmw_priv->vga_height);\r\nvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, vmw_priv->vga_bpp);\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_write(vmw_priv, SVGA_REG_PITCHLOCK,\r\nvmw_priv->vga_pitchlock);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\niowrite32(vmw_priv->vga_pitchlock,\r\nvmw_priv->mmio_virt + SVGA_FIFO_PITCHLOCK);\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY))\r\nreturn 0;\r\nfor (i = 0; i < vmw_priv->num_displays; ++i) {\r\nsave = &vmw_priv->vga_save[i];\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, i);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY, save->primary);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_X, save->pos_x);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y, save->pos_y);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_WIDTH, save->width);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_HEIGHT, save->height);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\n}\r\nreturn 0;\r\n}\r\nbool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv,\r\nuint32_t pitch,\r\nuint32_t height)\r\n{\r\nreturn ((u64) pitch * (u64) height) < (u64) dev_priv->vram_size;\r\n}\r\nu32 vmw_get_vblank_counter(struct drm_device *dev, int crtc)\r\n{\r\nreturn 0;\r\n}\r\nint vmw_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nvoid vmw_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\n}\r\nint vmw_du_update_layout(struct vmw_private *dev_priv, unsigned num,\r\nstruct drm_vmw_rect *rects)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_display_unit *du;\r\nstruct drm_connector *con;\r\nmutex_lock(&dev->mode_config.mutex);\r\n#if 0\r\n{\r\nunsigned int i;\r\nDRM_INFO("%s: new layout ", __func__);\r\nfor (i = 0; i < num; i++)\r\nDRM_INFO("(%i, %i %ux%u) ", rects[i].x, rects[i].y,\r\nrects[i].w, rects[i].h);\r\nDRM_INFO("\n");\r\n}\r\n#endif\r\nlist_for_each_entry(con, &dev->mode_config.connector_list, head) {\r\ndu = vmw_connector_to_du(con);\r\nif (num > du->unit) {\r\ndu->pref_width = rects[du->unit].w;\r\ndu->pref_height = rects[du->unit].h;\r\ndu->pref_active = true;\r\ndu->gui_x = rects[du->unit].x;\r\ndu->gui_y = rects[du->unit].y;\r\n} else {\r\ndu->pref_width = 800;\r\ndu->pref_height = 600;\r\ndu->pref_active = false;\r\n}\r\ncon->status = vmw_du_connector_detect(con, true);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn 0;\r\n}\r\nint vmw_du_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct drm_framebuffer *old_fb = crtc->fb;\r\nstruct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(fb);\r\nstruct drm_file *file_priv ;\r\nstruct vmw_fence_obj *fence = NULL;\r\nstruct drm_clip_rect clips;\r\nint ret;\r\nif (event == NULL)\r\nreturn -EINVAL;\r\nif (!dev_priv->sou_priv)\r\nreturn -ENOSYS;\r\nfile_priv = event->base.file_priv;\r\nif (!vmw_kms_screen_object_flippable(dev_priv, crtc))\r\nreturn -EINVAL;\r\ncrtc->fb = fb;\r\nclips.x1 = clips.y1 = 0;\r\nclips.x2 = fb->width;\r\nclips.y2 = fb->height;\r\nif (vfb->dmabuf)\r\nret = do_dmabuf_dirty_sou(file_priv, dev_priv, vfb,\r\n0, 0, &clips, 1, 1, &fence);\r\nelse\r\nret = do_surface_dirty_sou(dev_priv, file_priv, vfb,\r\n0, 0, &clips, 1, 1, &fence);\r\nif (ret != 0)\r\ngoto out_no_fence;\r\nif (!fence) {\r\nret = -EINVAL;\r\ngoto out_no_fence;\r\n}\r\nret = vmw_event_fence_action_queue(file_priv, fence,\r\n&event->base,\r\n&event->event.tv_sec,\r\n&event->event.tv_usec,\r\ntrue);\r\nvmw_fence_obj_unreference(&fence);\r\nif (vmw_crtc_to_du(crtc)->is_implicit)\r\nvmw_kms_screen_object_update_implicit_fb(dev_priv, crtc);\r\nreturn ret;\r\nout_no_fence:\r\ncrtc->fb = old_fb;\r\nreturn ret;\r\n}\r\nvoid vmw_du_crtc_save(struct drm_crtc *crtc)\r\n{\r\n}\r\nvoid vmw_du_crtc_restore(struct drm_crtc *crtc)\r\n{\r\n}\r\nvoid vmw_du_crtc_gamma_set(struct drm_crtc *crtc,\r\nu16 *r, u16 *g, u16 *b,\r\nuint32_t start, uint32_t size)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nDRM_DEBUG("%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n", i,\r\nr[i], g[i], b[i]);\r\nvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 0, r[i] >> 8);\r\nvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 1, g[i] >> 8);\r\nvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 2, b[i] >> 8);\r\n}\r\n}\r\nvoid vmw_du_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\n}\r\nvoid vmw_du_connector_save(struct drm_connector *connector)\r\n{\r\n}\r\nvoid vmw_du_connector_restore(struct drm_connector *connector)\r\n{\r\n}\r\nenum drm_connector_status\r\nvmw_du_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nuint32_t num_displays;\r\nstruct drm_device *dev = connector->dev;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_display_unit *du = vmw_connector_to_du(connector);\r\nmutex_lock(&dev_priv->hw_mutex);\r\nnum_displays = vmw_read(dev_priv, SVGA_REG_NUM_DISPLAYS);\r\nmutex_unlock(&dev_priv->hw_mutex);\r\nreturn ((vmw_connector_to_du(connector)->unit < num_displays &&\r\ndu->pref_active) ?\r\nconnector_status_connected : connector_status_disconnected);\r\n}\r\nstatic void vmw_guess_mode_timing(struct drm_display_mode *mode)\r\n{\r\nmode->hsync_start = mode->hdisplay + 50;\r\nmode->hsync_end = mode->hsync_start + 50;\r\nmode->htotal = mode->hsync_end + 50;\r\nmode->vsync_start = mode->vdisplay + 50;\r\nmode->vsync_end = mode->vsync_start + 50;\r\nmode->vtotal = mode->vsync_end + 50;\r\nmode->clock = (u32)mode->htotal * (u32)mode->vtotal / 100 * 6;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\n}\r\nint vmw_du_connector_fill_modes(struct drm_connector *connector,\r\nuint32_t max_width, uint32_t max_height)\r\n{\r\nstruct vmw_display_unit *du = vmw_connector_to_du(connector);\r\nstruct drm_device *dev = connector->dev;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode *bmode;\r\nstruct drm_display_mode prefmode = { DRM_MODE("preferred",\r\nDRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\nDRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC)\r\n};\r\nint i;\r\n{\r\nmode = drm_mode_duplicate(dev, &prefmode);\r\nif (!mode)\r\nreturn 0;\r\nmode->hdisplay = du->pref_width;\r\nmode->vdisplay = du->pref_height;\r\nvmw_guess_mode_timing(mode);\r\nif (vmw_kms_validate_mode_vram(dev_priv, mode->hdisplay * 2,\r\nmode->vdisplay)) {\r\ndrm_mode_probed_add(connector, mode);\r\n} else {\r\ndrm_mode_destroy(dev, mode);\r\nmode = NULL;\r\n}\r\nif (du->pref_mode) {\r\nlist_del_init(&du->pref_mode->head);\r\ndrm_mode_destroy(dev, du->pref_mode);\r\n}\r\ndu->pref_mode = mode;\r\n}\r\nfor (i = 0; vmw_kms_connector_builtin[i].type != 0; i++) {\r\nbmode = &vmw_kms_connector_builtin[i];\r\nif (bmode->hdisplay > max_width ||\r\nbmode->vdisplay > max_height)\r\ncontinue;\r\nif (!vmw_kms_validate_mode_vram(dev_priv, bmode->hdisplay * 2,\r\nbmode->vdisplay))\r\ncontinue;\r\nmode = drm_mode_duplicate(dev, bmode);\r\nif (!mode)\r\nreturn 0;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\nif (du->pref_mode)\r\nlist_move(&du->pref_mode->head, &connector->probed_modes);\r\ndrm_mode_connector_list_update(connector);\r\nreturn 1;\r\n}\r\nint vmw_du_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nreturn 0;\r\n}\r\nint vmw_kms_update_layout_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_update_layout_arg *arg =\r\n(struct drm_vmw_update_layout_arg *)data;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nvoid __user *user_rects;\r\nstruct drm_vmw_rect *rects;\r\nunsigned rects_size;\r\nint ret;\r\nint i;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (!arg->num_outputs) {\r\nstruct drm_vmw_rect def_rect = {0, 0, 800, 600};\r\nvmw_du_update_layout(dev_priv, 1, &def_rect);\r\ngoto out_unlock;\r\n}\r\nrects_size = arg->num_outputs * sizeof(struct drm_vmw_rect);\r\nrects = kcalloc(arg->num_outputs, sizeof(struct drm_vmw_rect),\r\nGFP_KERNEL);\r\nif (unlikely(!rects)) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nuser_rects = (void __user *)(unsigned long)arg->rects;\r\nret = copy_from_user(rects, user_rects, rects_size);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to get rects.\n");\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < arg->num_outputs; ++i) {\r\nif (rects[i].x < 0 ||\r\nrects[i].y < 0 ||\r\nrects[i].x + rects[i].w > mode_config->max_width ||\r\nrects[i].y + rects[i].h > mode_config->max_height) {\r\nDRM_ERROR("Invalid GUI layout.\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nvmw_du_update_layout(dev_priv, arg->num_outputs, rects);\r\nout_free:\r\nkfree(rects);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}
