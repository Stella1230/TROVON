static float32 float32_rsf(struct roundingData *roundData, float32 rFn, float32 rFm)\r\n{\r\nreturn float32_sub(roundData, rFm, rFn);\r\n}\r\nstatic float32 float32_rdv(struct roundingData *roundData, float32 rFn, float32 rFm)\r\n{\r\nreturn float32_div(roundData, rFm, rFn);\r\n}\r\nstatic float32 float32_mvf(struct roundingData *roundData, float32 rFm)\r\n{\r\nreturn rFm;\r\n}\r\nstatic float32 float32_mnf(struct roundingData *roundData, float32 rFm)\r\n{\r\nreturn rFm ^ 0x80000000;\r\n}\r\nstatic float32 float32_abs(struct roundingData *roundData, float32 rFm)\r\n{\r\nreturn rFm & 0x7fffffff;\r\n}\r\nunsigned int SingleCPDO(struct roundingData *roundData, const unsigned int opcode, FPREG * rFd)\r\n{\r\nFPA11 *fpa11 = GET_FPA11();\r\nfloat32 rFm;\r\nunsigned int Fm, opc_mask_shift;\r\nFm = getFm(opcode);\r\nif (CONSTANT_FM(opcode)) {\r\nrFm = getSingleConstant(Fm);\r\n} else if (fpa11->fType[Fm] == typeSingle) {\r\nrFm = fpa11->fpreg[Fm].fSingle;\r\n} else {\r\nreturn 0;\r\n}\r\nopc_mask_shift = (opcode & MASK_ARITHMETIC_OPCODE) >> 20;\r\nif (!MONADIC_INSTRUCTION(opcode)) {\r\nunsigned int Fn = getFn(opcode);\r\nfloat32 rFn;\r\nif (fpa11->fType[Fn] == typeSingle &&\r\ndyadic_single[opc_mask_shift]) {\r\nrFn = fpa11->fpreg[Fn].fSingle;\r\nrFd->fSingle = dyadic_single[opc_mask_shift](roundData, rFn, rFm);\r\n} else {\r\nreturn 0;\r\n}\r\n} else {\r\nif (monadic_single[opc_mask_shift]) {\r\nrFd->fSingle = monadic_single[opc_mask_shift](roundData, rFm);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}
