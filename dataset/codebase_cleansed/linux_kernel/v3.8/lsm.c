static void apparmor_cred_free(struct cred *cred)\r\n{\r\naa_free_task_context(cred->security);\r\ncred->security = NULL;\r\n}\r\nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\r\n{\r\nstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\r\nif (!cxt)\r\nreturn -ENOMEM;\r\ncred->security = cxt;\r\nreturn 0;\r\n}\r\nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\r\ngfp_t gfp)\r\n{\r\nstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\r\nif (!cxt)\r\nreturn -ENOMEM;\r\naa_dup_task_context(cxt, old->security);\r\nnew->security = cxt;\r\nreturn 0;\r\n}\r\nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\r\n{\r\nconst struct aa_task_cxt *old_cxt = old->security;\r\nstruct aa_task_cxt *new_cxt = new->security;\r\naa_dup_task_context(new_cxt, old_cxt);\r\n}\r\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\r\nunsigned int mode)\r\n{\r\nint error = cap_ptrace_access_check(child, mode);\r\nif (error)\r\nreturn error;\r\nreturn aa_ptrace(current, child, mode);\r\n}\r\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\r\n{\r\nint error = cap_ptrace_traceme(parent);\r\nif (error)\r\nreturn error;\r\nreturn aa_ptrace(parent, current, PTRACE_MODE_ATTACH);\r\n}\r\nstatic int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\r\nkernel_cap_t *inheritable, kernel_cap_t *permitted)\r\n{\r\nstruct aa_profile *profile;\r\nconst struct cred *cred;\r\nrcu_read_lock();\r\ncred = __task_cred(target);\r\nprofile = aa_cred_profile(cred);\r\n*effective = cred->cap_effective;\r\n*inheritable = cred->cap_inheritable;\r\n*permitted = cred->cap_permitted;\r\nif (!unconfined(profile) && !COMPLAIN_MODE(profile)) {\r\n*effective = cap_intersect(*effective, profile->caps.allow);\r\n*permitted = cap_intersect(*permitted, profile->caps.allow);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int apparmor_capable(const struct cred *cred, struct user_namespace *ns,\r\nint cap, int audit)\r\n{\r\nstruct aa_profile *profile;\r\nint error = cap_capable(cred, ns, cap, audit);\r\nif (!error) {\r\nprofile = aa_cred_profile(cred);\r\nif (!unconfined(profile))\r\nerror = aa_capable(current, profile, cap, audit);\r\n}\r\nreturn error;\r\n}\r\nstatic int common_perm(int op, struct path *path, u32 mask,\r\nstruct path_cond *cond)\r\n{\r\nstruct aa_profile *profile;\r\nint error = 0;\r\nprofile = __aa_current_profile();\r\nif (!unconfined(profile))\r\nerror = aa_path_perm(op, profile, path, 0, mask, cond);\r\nreturn error;\r\n}\r\nstatic int common_perm_dir_dentry(int op, struct path *dir,\r\nstruct dentry *dentry, u32 mask,\r\nstruct path_cond *cond)\r\n{\r\nstruct path path = { dir->mnt, dentry };\r\nreturn common_perm(op, &path, mask, cond);\r\n}\r\nstatic int common_perm_mnt_dentry(int op, struct vfsmount *mnt,\r\nstruct dentry *dentry, u32 mask)\r\n{\r\nstruct path path = { mnt, dentry };\r\nstruct path_cond cond = { dentry->d_inode->i_uid,\r\ndentry->d_inode->i_mode\r\n};\r\nreturn common_perm(op, &path, mask, &cond);\r\n}\r\nstatic int common_perm_rm(int op, struct path *dir,\r\nstruct dentry *dentry, u32 mask)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct path_cond cond = { };\r\nif (!inode || !dir->mnt || !mediated_filesystem(inode))\r\nreturn 0;\r\ncond.uid = inode->i_uid;\r\ncond.mode = inode->i_mode;\r\nreturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\r\n}\r\nstatic int common_perm_create(int op, struct path *dir, struct dentry *dentry,\r\nu32 mask, umode_t mode)\r\n{\r\nstruct path_cond cond = { current_fsuid(), mode };\r\nif (!dir->mnt || !mediated_filesystem(dir->dentry->d_inode))\r\nreturn 0;\r\nreturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\r\n}\r\nstatic int apparmor_path_unlink(struct path *dir, struct dentry *dentry)\r\n{\r\nreturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\r\n}\r\nstatic int apparmor_path_mkdir(struct path *dir, struct dentry *dentry,\r\numode_t mode)\r\n{\r\nreturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\r\nS_IFDIR);\r\n}\r\nstatic int apparmor_path_rmdir(struct path *dir, struct dentry *dentry)\r\n{\r\nreturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\r\n}\r\nstatic int apparmor_path_mknod(struct path *dir, struct dentry *dentry,\r\numode_t mode, unsigned int dev)\r\n{\r\nreturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\r\n}\r\nstatic int apparmor_path_truncate(struct path *path)\r\n{\r\nstruct path_cond cond = { path->dentry->d_inode->i_uid,\r\npath->dentry->d_inode->i_mode\r\n};\r\nif (!path->mnt || !mediated_filesystem(path->dentry->d_inode))\r\nreturn 0;\r\nreturn common_perm(OP_TRUNC, path, MAY_WRITE | AA_MAY_META_WRITE,\r\n&cond);\r\n}\r\nstatic int apparmor_path_symlink(struct path *dir, struct dentry *dentry,\r\nconst char *old_name)\r\n{\r\nreturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\r\nS_IFLNK);\r\n}\r\nstatic int apparmor_path_link(struct dentry *old_dentry, struct path *new_dir,\r\nstruct dentry *new_dentry)\r\n{\r\nstruct aa_profile *profile;\r\nint error = 0;\r\nif (!mediated_filesystem(old_dentry->d_inode))\r\nreturn 0;\r\nprofile = aa_current_profile();\r\nif (!unconfined(profile))\r\nerror = aa_path_link(profile, old_dentry, new_dir, new_dentry);\r\nreturn error;\r\n}\r\nstatic int apparmor_path_rename(struct path *old_dir, struct dentry *old_dentry,\r\nstruct path *new_dir, struct dentry *new_dentry)\r\n{\r\nstruct aa_profile *profile;\r\nint error = 0;\r\nif (!mediated_filesystem(old_dentry->d_inode))\r\nreturn 0;\r\nprofile = aa_current_profile();\r\nif (!unconfined(profile)) {\r\nstruct path old_path = { old_dir->mnt, old_dentry };\r\nstruct path new_path = { new_dir->mnt, new_dentry };\r\nstruct path_cond cond = { old_dentry->d_inode->i_uid,\r\nold_dentry->d_inode->i_mode\r\n};\r\nerror = aa_path_perm(OP_RENAME_SRC, profile, &old_path, 0,\r\nMAY_READ | AA_MAY_META_READ | MAY_WRITE |\r\nAA_MAY_META_WRITE | AA_MAY_DELETE,\r\n&cond);\r\nif (!error)\r\nerror = aa_path_perm(OP_RENAME_DEST, profile, &new_path,\r\n0, MAY_WRITE | AA_MAY_META_WRITE |\r\nAA_MAY_CREATE, &cond);\r\n}\r\nreturn error;\r\n}\r\nstatic int apparmor_path_chmod(struct path *path, umode_t mode)\r\n{\r\nif (!mediated_filesystem(path->dentry->d_inode))\r\nreturn 0;\r\nreturn common_perm_mnt_dentry(OP_CHMOD, path->mnt, path->dentry, AA_MAY_CHMOD);\r\n}\r\nstatic int apparmor_path_chown(struct path *path, kuid_t uid, kgid_t gid)\r\n{\r\nstruct path_cond cond = { path->dentry->d_inode->i_uid,\r\npath->dentry->d_inode->i_mode\r\n};\r\nif (!mediated_filesystem(path->dentry->d_inode))\r\nreturn 0;\r\nreturn common_perm(OP_CHOWN, path, AA_MAY_CHOWN, &cond);\r\n}\r\nstatic int apparmor_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)\r\n{\r\nif (!mediated_filesystem(dentry->d_inode))\r\nreturn 0;\r\nreturn common_perm_mnt_dentry(OP_GETATTR, mnt, dentry,\r\nAA_MAY_META_READ);\r\n}\r\nstatic int apparmor_file_open(struct file *file, const struct cred *cred)\r\n{\r\nstruct aa_file_cxt *fcxt = file->f_security;\r\nstruct aa_profile *profile;\r\nint error = 0;\r\nif (!mediated_filesystem(file->f_path.dentry->d_inode))\r\nreturn 0;\r\nif (current->in_execve) {\r\nfcxt->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\r\nreturn 0;\r\n}\r\nprofile = aa_cred_profile(cred);\r\nif (!unconfined(profile)) {\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct path_cond cond = { inode->i_uid, inode->i_mode };\r\nerror = aa_path_perm(OP_OPEN, profile, &file->f_path, 0,\r\naa_map_file_to_perms(file), &cond);\r\nfcxt->allow = aa_map_file_to_perms(file);\r\n}\r\nreturn error;\r\n}\r\nstatic int apparmor_file_alloc_security(struct file *file)\r\n{\r\nfile->f_security = aa_alloc_file_context(GFP_KERNEL);\r\nif (!file->f_security)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void apparmor_file_free_security(struct file *file)\r\n{\r\nstruct aa_file_cxt *cxt = file->f_security;\r\naa_free_file_context(cxt);\r\n}\r\nstatic int common_file_perm(int op, struct file *file, u32 mask)\r\n{\r\nstruct aa_file_cxt *fcxt = file->f_security;\r\nstruct aa_profile *profile, *fprofile = aa_cred_profile(file->f_cred);\r\nint error = 0;\r\nBUG_ON(!fprofile);\r\nif (!file->f_path.mnt ||\r\n!mediated_filesystem(file->f_path.dentry->d_inode))\r\nreturn 0;\r\nprofile = __aa_current_profile();\r\nif (!unconfined(profile) && !unconfined(fprofile) &&\r\n((fprofile != profile) || (mask & ~fcxt->allow)))\r\nerror = aa_file_perm(op, profile, file, mask);\r\nreturn error;\r\n}\r\nstatic int apparmor_file_permission(struct file *file, int mask)\r\n{\r\nreturn common_file_perm(OP_FPERM, file, mask);\r\n}\r\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\r\n{\r\nu32 mask = AA_MAY_LOCK;\r\nif (cmd == F_WRLCK)\r\nmask |= MAY_WRITE;\r\nreturn common_file_perm(OP_FLOCK, file, mask);\r\n}\r\nstatic int common_mmap(int op, struct file *file, unsigned long prot,\r\nunsigned long flags)\r\n{\r\nstruct dentry *dentry;\r\nint mask = 0;\r\nif (!file || !file->f_security)\r\nreturn 0;\r\nif (prot & PROT_READ)\r\nmask |= MAY_READ;\r\nif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\r\nmask |= MAY_WRITE;\r\nif (prot & PROT_EXEC)\r\nmask |= AA_EXEC_MMAP;\r\ndentry = file->f_path.dentry;\r\nreturn common_file_perm(op, file, mask);\r\n}\r\nstatic int apparmor_mmap_file(struct file *file, unsigned long reqprot,\r\nunsigned long prot, unsigned long flags)\r\n{\r\nreturn common_mmap(OP_FMMAP, file, prot, flags);\r\n}\r\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\r\nunsigned long reqprot, unsigned long prot)\r\n{\r\nreturn common_mmap(OP_FMPROT, vma->vm_file, prot,\r\n!(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\r\n}\r\nstatic int apparmor_getprocattr(struct task_struct *task, char *name,\r\nchar **value)\r\n{\r\nint error = -ENOENT;\r\nstruct aa_profile *profile;\r\nconst struct cred *cred = get_task_cred(task);\r\nstruct aa_task_cxt *cxt = cred->security;\r\nprofile = aa_cred_profile(cred);\r\nif (strcmp(name, "current") == 0)\r\nerror = aa_getprocattr(aa_newest_version(cxt->profile),\r\nvalue);\r\nelse if (strcmp(name, "prev") == 0 && cxt->previous)\r\nerror = aa_getprocattr(aa_newest_version(cxt->previous),\r\nvalue);\r\nelse if (strcmp(name, "exec") == 0 && cxt->onexec)\r\nerror = aa_getprocattr(aa_newest_version(cxt->onexec),\r\nvalue);\r\nelse\r\nerror = -EINVAL;\r\nput_cred(cred);\r\nreturn error;\r\n}\r\nstatic int apparmor_setprocattr(struct task_struct *task, char *name,\r\nvoid *value, size_t size)\r\n{\r\nchar *command, *args = value;\r\nsize_t arg_size;\r\nint error;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nif (args[size - 1] != '\0') {\r\nif (size == PAGE_SIZE)\r\nreturn -EINVAL;\r\nargs[size] = '\0';\r\n}\r\nif (current != task)\r\nreturn -EACCES;\r\nargs = value;\r\nargs = strim(args);\r\ncommand = strsep(&args, " ");\r\nif (!args)\r\nreturn -EINVAL;\r\nargs = skip_spaces(args);\r\nif (!*args)\r\nreturn -EINVAL;\r\narg_size = size - (args - (char *) value);\r\nif (strcmp(name, "current") == 0) {\r\nif (strcmp(command, "changehat") == 0) {\r\nerror = aa_setprocattr_changehat(args, arg_size,\r\n!AA_DO_TEST);\r\n} else if (strcmp(command, "permhat") == 0) {\r\nerror = aa_setprocattr_changehat(args, arg_size,\r\nAA_DO_TEST);\r\n} else if (strcmp(command, "changeprofile") == 0) {\r\nerror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\r\n!AA_DO_TEST);\r\n} else if (strcmp(command, "permprofile") == 0) {\r\nerror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\r\nAA_DO_TEST);\r\n} else if (strcmp(command, "permipc") == 0) {\r\nerror = aa_setprocattr_permipc(args);\r\n} else {\r\nstruct common_audit_data sa;\r\nstruct apparmor_audit_data aad = {0,};\r\nsa.type = LSM_AUDIT_DATA_NONE;\r\nsa.aad = &aad;\r\naad.op = OP_SETPROCATTR;\r\naad.info = name;\r\naad.error = -EINVAL;\r\nreturn aa_audit(AUDIT_APPARMOR_DENIED,\r\n__aa_current_profile(), GFP_KERNEL,\r\n&sa, NULL);\r\n}\r\n} else if (strcmp(name, "exec") == 0) {\r\nerror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\r\n!AA_DO_TEST);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (!error)\r\nerror = size;\r\nreturn error;\r\n}\r\nstatic int apparmor_task_setrlimit(struct task_struct *task,\r\nunsigned int resource, struct rlimit *new_rlim)\r\n{\r\nstruct aa_profile *profile = __aa_current_profile();\r\nint error = 0;\r\nif (!unconfined(profile))\r\nerror = aa_task_setrlimit(profile, task, resource, new_rlim);\r\nreturn error;\r\n}\r\nstatic int __init apparmor_enabled_setup(char *str)\r\n{\r\nunsigned long enabled;\r\nint error = strict_strtoul(str, 0, &enabled);\r\nif (!error)\r\napparmor_enabled = enabled ? 1 : 0;\r\nreturn 1;\r\n}\r\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (aa_g_lock_policy)\r\nreturn -EACCES;\r\nreturn param_set_bool(val, kp);\r\n}\r\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn param_get_bool(buffer, kp);\r\n}\r\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn param_set_bool(val, kp);\r\n}\r\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn param_get_bool(buffer, kp);\r\n}\r\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn param_set_uint(val, kp);\r\n}\r\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nreturn param_get_uint(buffer, kp);\r\n}\r\nstatic int param_get_audit(char *buffer, struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (!apparmor_enabled)\r\nreturn -EINVAL;\r\nreturn sprintf(buffer, "%s", audit_mode_names[aa_g_audit]);\r\n}\r\nstatic int param_set_audit(const char *val, struct kernel_param *kp)\r\n{\r\nint i;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (!apparmor_enabled)\r\nreturn -EINVAL;\r\nif (!val)\r\nreturn -EINVAL;\r\nfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\r\nif (strcmp(val, audit_mode_names[i]) == 0) {\r\naa_g_audit = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int param_get_mode(char *buffer, struct kernel_param *kp)\r\n{\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (!apparmor_enabled)\r\nreturn -EINVAL;\r\nreturn sprintf(buffer, "%s", profile_mode_names[aa_g_profile_mode]);\r\n}\r\nstatic int param_set_mode(const char *val, struct kernel_param *kp)\r\n{\r\nint i;\r\nif (!capable(CAP_MAC_ADMIN))\r\nreturn -EPERM;\r\nif (!apparmor_enabled)\r\nreturn -EINVAL;\r\nif (!val)\r\nreturn -EINVAL;\r\nfor (i = 0; i < APPARMOR_NAMES_MAX_INDEX; i++) {\r\nif (strcmp(val, profile_mode_names[i]) == 0) {\r\naa_g_profile_mode = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init set_init_cxt(void)\r\n{\r\nstruct cred *cred = (struct cred *)current->real_cred;\r\nstruct aa_task_cxt *cxt;\r\ncxt = aa_alloc_task_context(GFP_KERNEL);\r\nif (!cxt)\r\nreturn -ENOMEM;\r\ncxt->profile = aa_get_profile(root_ns->unconfined);\r\ncred->security = cxt;\r\nreturn 0;\r\n}\r\nstatic int __init apparmor_init(void)\r\n{\r\nint error;\r\nif (!apparmor_enabled || !security_module_enable(&apparmor_ops)) {\r\naa_info_message("AppArmor disabled by boot time parameter");\r\napparmor_enabled = 0;\r\nreturn 0;\r\n}\r\nerror = aa_alloc_root_ns();\r\nif (error) {\r\nAA_ERROR("Unable to allocate default profile namespace\n");\r\ngoto alloc_out;\r\n}\r\nerror = set_init_cxt();\r\nif (error) {\r\nAA_ERROR("Failed to set context on init task\n");\r\ngoto register_security_out;\r\n}\r\nerror = register_security(&apparmor_ops);\r\nif (error) {\r\nAA_ERROR("Unable to register AppArmor\n");\r\ngoto set_init_cxt_out;\r\n}\r\napparmor_initialized = 1;\r\nif (aa_g_profile_mode == APPARMOR_COMPLAIN)\r\naa_info_message("AppArmor initialized: complain mode enabled");\r\nelse if (aa_g_profile_mode == APPARMOR_KILL)\r\naa_info_message("AppArmor initialized: kill mode enabled");\r\nelse\r\naa_info_message("AppArmor initialized");\r\nreturn error;\r\nset_init_cxt_out:\r\naa_free_task_context(current->real_cred->security);\r\nregister_security_out:\r\naa_free_root_ns();\r\nalloc_out:\r\naa_destroy_aafs();\r\napparmor_enabled = 0;\r\nreturn error;\r\n}
