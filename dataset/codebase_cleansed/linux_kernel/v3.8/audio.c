static void\r\nactivate_substream(struct snd_usb_caiaqdev *dev,\r\nstruct snd_pcm_substream *sub)\r\n{\r\nspin_lock(&dev->spinlock);\r\nif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndev->sub_playback[sub->number] = sub;\r\nelse\r\ndev->sub_capture[sub->number] = sub;\r\nspin_unlock(&dev->spinlock);\r\n}\r\nstatic void\r\ndeactivate_substream(struct snd_usb_caiaqdev *dev,\r\nstruct snd_pcm_substream *sub)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndev->sub_playback[sub->number] = NULL;\r\nelse\r\ndev->sub_capture[sub->number] = NULL;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic int\r\nall_substreams_zero(struct snd_pcm_substream **subs)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_STREAMS; i++)\r\nif (subs[i] != NULL)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int stream_start(struct snd_usb_caiaqdev *dev)\r\n{\r\nint i, ret;\r\ndebug("%s(%p)\n", __func__, dev);\r\nif (dev->streaming)\r\nreturn -EINVAL;\r\nmemset(dev->sub_playback, 0, sizeof(dev->sub_playback));\r\nmemset(dev->sub_capture, 0, sizeof(dev->sub_capture));\r\ndev->input_panic = 0;\r\ndev->output_panic = 0;\r\ndev->first_packet = 4;\r\ndev->streaming = 1;\r\ndev->warned = 0;\r\nfor (i = 0; i < N_URBS; i++) {\r\nret = usb_submit_urb(dev->data_urbs_in[i], GFP_ATOMIC);\r\nif (ret) {\r\nlog("unable to trigger read #%d! (ret %d)\n", i, ret);\r\ndev->streaming = 0;\r\nreturn -EPIPE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void stream_stop(struct snd_usb_caiaqdev *dev)\r\n{\r\nint i;\r\ndebug("%s(%p)\n", __func__, dev);\r\nif (!dev->streaming)\r\nreturn;\r\ndev->streaming = 0;\r\nfor (i = 0; i < N_URBS; i++) {\r\nusb_kill_urb(dev->data_urbs_in[i]);\r\nif (test_bit(i, &dev->outurb_active_mask))\r\nusb_kill_urb(dev->data_urbs_out[i]);\r\n}\r\ndev->outurb_active_mask = 0;\r\n}\r\nstatic int snd_usb_caiaq_substream_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);\r\ndebug("%s(%p)\n", __func__, substream);\r\nsubstream->runtime->hw = dev->pcm_info;\r\nsnd_pcm_limit_hw_rates(substream->runtime);\r\nreturn 0;\r\n}\r\nstatic int snd_usb_caiaq_substream_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);\r\ndebug("%s(%p)\n", __func__, substream);\r\nif (all_substreams_zero(dev->sub_playback) &&\r\nall_substreams_zero(dev->sub_capture)) {\r\nstream_stop(dev);\r\ndev->pcm_info.rates = dev->samplerates;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usb_caiaq_pcm_hw_params(struct snd_pcm_substream *sub,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\ndebug("%s(%p)\n", __func__, sub);\r\nreturn snd_pcm_lib_malloc_pages(sub, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_usb_caiaq_pcm_hw_free(struct snd_pcm_substream *sub)\r\n{\r\nstruct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);\r\ndebug("%s(%p)\n", __func__, sub);\r\ndeactivate_substream(dev, sub);\r\nreturn snd_pcm_lib_free_pages(sub);\r\n}\r\nstatic int snd_usb_caiaq_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nint bytes_per_sample, bpp, ret, i;\r\nint index = substream->number;\r\nstruct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\ndebug("%s(%p)\n", __func__, substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nint out_pos;\r\nswitch (dev->spec.data_alignment) {\r\ncase 0:\r\ncase 2:\r\nout_pos = BYTES_PER_SAMPLE + 1;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nout_pos = 0;\r\nbreak;\r\n}\r\ndev->period_out_count[index] = out_pos;\r\ndev->audio_out_buf_pos[index] = out_pos;\r\n} else {\r\nint in_pos;\r\nswitch (dev->spec.data_alignment) {\r\ncase 0:\r\nin_pos = BYTES_PER_SAMPLE + 2;\r\nbreak;\r\ncase 2:\r\nin_pos = BYTES_PER_SAMPLE;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nin_pos = 0;\r\nbreak;\r\n}\r\ndev->period_in_count[index] = in_pos;\r\ndev->audio_in_buf_pos[index] = in_pos;\r\n}\r\nif (dev->streaming)\r\nreturn 0;\r\nfor (i=0; i < ARRAY_SIZE(rates); i++)\r\nif (runtime->rate == rates[i])\r\ndev->pcm_info.rates = 1 << i;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nbytes_per_sample = BYTES_PER_SAMPLE;\r\nif (dev->spec.data_alignment >= 2)\r\nbytes_per_sample++;\r\nbpp = ((runtime->rate / 8000) + CLOCK_DRIFT_TOLERANCE)\r\n* bytes_per_sample * CHANNELS_PER_STREAM * dev->n_streams;\r\nif (bpp > MAX_ENDPOINT_SIZE)\r\nbpp = MAX_ENDPOINT_SIZE;\r\nret = snd_usb_caiaq_set_audio_params(dev, runtime->rate,\r\nruntime->sample_bits, bpp);\r\nif (ret)\r\nreturn ret;\r\nret = stream_start(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->output_running = 0;\r\nwait_event_timeout(dev->prepare_wait_queue, dev->output_running, HZ);\r\nif (!dev->output_running) {\r\nstream_stop(dev);\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usb_caiaq_pcm_trigger(struct snd_pcm_substream *sub, int cmd)\r\n{\r\nstruct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);\r\ndebug("%s(%p) cmd %d\n", __func__, sub, cmd);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nactivate_substream(dev, sub);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndeactivate_substream(dev, sub);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_usb_caiaq_pcm_pointer(struct snd_pcm_substream *sub)\r\n{\r\nint index = sub->number;\r\nstruct snd_usb_caiaqdev *dev = snd_pcm_substream_chip(sub);\r\nsnd_pcm_uframes_t ptr;\r\nspin_lock(&dev->spinlock);\r\nif (dev->input_panic || dev->output_panic) {\r\nptr = SNDRV_PCM_POS_XRUN;\r\ngoto unlock;\r\n}\r\nif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nptr = bytes_to_frames(sub->runtime,\r\ndev->audio_out_buf_pos[index]);\r\nelse\r\nptr = bytes_to_frames(sub->runtime,\r\ndev->audio_in_buf_pos[index]);\r\nunlock:\r\nspin_unlock(&dev->spinlock);\r\nreturn ptr;\r\n}\r\nstatic void check_for_elapsed_periods(struct snd_usb_caiaqdev *dev,\r\nstruct snd_pcm_substream **subs)\r\n{\r\nint stream, pb, *cnt;\r\nstruct snd_pcm_substream *sub;\r\nfor (stream = 0; stream < dev->n_streams; stream++) {\r\nsub = subs[stream];\r\nif (!sub)\r\ncontinue;\r\npb = snd_pcm_lib_period_bytes(sub);\r\ncnt = (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\n&dev->period_out_count[stream] :\r\n&dev->period_in_count[stream];\r\nif (*cnt >= pb) {\r\nsnd_pcm_period_elapsed(sub);\r\n*cnt %= pb;\r\n}\r\n}\r\n}\r\nstatic void read_in_urb_mode0(struct snd_usb_caiaqdev *dev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nstruct snd_pcm_substream *sub;\r\nint stream, i;\r\nif (all_substreams_zero(dev->sub_capture))\r\nreturn;\r\nfor (i = 0; i < iso->actual_length;) {\r\nfor (stream = 0; stream < dev->n_streams; stream++, i++) {\r\nsub = dev->sub_capture[stream];\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\nchar *audio_buf = rt->dma_area;\r\nint sz = frames_to_bytes(rt, rt->buffer_size);\r\naudio_buf[dev->audio_in_buf_pos[stream]++]\r\n= usb_buf[i];\r\ndev->period_in_count[stream]++;\r\nif (dev->audio_in_buf_pos[stream] == sz)\r\ndev->audio_in_buf_pos[stream] = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void read_in_urb_mode2(struct snd_usb_caiaqdev *dev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nunsigned char check_byte;\r\nstruct snd_pcm_substream *sub;\r\nint stream, i;\r\nfor (i = 0; i < iso->actual_length;) {\r\nif (i % (dev->n_streams * BYTES_PER_SAMPLE_USB) == 0) {\r\nfor (stream = 0;\r\nstream < dev->n_streams;\r\nstream++, i++) {\r\nif (dev->first_packet)\r\ncontinue;\r\ncheck_byte = MAKE_CHECKBYTE(dev, stream, i);\r\nif ((usb_buf[i] & 0x3f) != check_byte)\r\ndev->input_panic = 1;\r\nif (usb_buf[i] & 0x80)\r\ndev->output_panic = 1;\r\n}\r\n}\r\ndev->first_packet = 0;\r\nfor (stream = 0; stream < dev->n_streams; stream++, i++) {\r\nsub = dev->sub_capture[stream];\r\nif (dev->input_panic)\r\nusb_buf[i] = 0;\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\nchar *audio_buf = rt->dma_area;\r\nint sz = frames_to_bytes(rt, rt->buffer_size);\r\naudio_buf[dev->audio_in_buf_pos[stream]++] =\r\nusb_buf[i];\r\ndev->period_in_count[stream]++;\r\nif (dev->audio_in_buf_pos[stream] == sz)\r\ndev->audio_in_buf_pos[stream] = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void read_in_urb_mode3(struct snd_usb_caiaqdev *dev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nint stream, i;\r\nif (iso->actual_length % (BYTES_PER_SAMPLE_USB * CHANNELS_PER_STREAM))\r\nreturn;\r\nfor (i = 0; i < iso->actual_length;) {\r\nfor (stream = 0; stream < dev->n_streams; stream++) {\r\nstruct snd_pcm_substream *sub = dev->sub_capture[stream];\r\nchar *audio_buf = NULL;\r\nint c, n, sz = 0;\r\nif (sub && !dev->input_panic) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\naudio_buf = rt->dma_area;\r\nsz = frames_to_bytes(rt, rt->buffer_size);\r\n}\r\nfor (c = 0; c < CHANNELS_PER_STREAM; c++) {\r\nif (audio_buf) {\r\nfor (n = 0; n < BYTES_PER_SAMPLE; n++) {\r\naudio_buf[dev->audio_in_buf_pos[stream]++] = usb_buf[i+n];\r\nif (dev->audio_in_buf_pos[stream] == sz)\r\ndev->audio_in_buf_pos[stream] = 0;\r\n}\r\ndev->period_in_count[stream] += BYTES_PER_SAMPLE;\r\n}\r\ni += BYTES_PER_SAMPLE;\r\nif (usb_buf[i] != ((stream << 1) | c) &&\r\n!dev->first_packet) {\r\nif (!dev->input_panic)\r\nprintk(" EXPECTED: %02x got %02x, c %d, stream %d, i %d\n",\r\n((stream << 1) | c), usb_buf[i], c, stream, i);\r\ndev->input_panic = 1;\r\n}\r\ni++;\r\n}\r\n}\r\n}\r\nif (dev->first_packet > 0)\r\ndev->first_packet--;\r\n}\r\nstatic void read_in_urb(struct snd_usb_caiaqdev *dev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nif (!dev->streaming)\r\nreturn;\r\nif (iso->actual_length < dev->bpp)\r\nreturn;\r\nswitch (dev->spec.data_alignment) {\r\ncase 0:\r\nread_in_urb_mode0(dev, urb, iso);\r\nbreak;\r\ncase 2:\r\nread_in_urb_mode2(dev, urb, iso);\r\nbreak;\r\ncase 3:\r\nread_in_urb_mode3(dev, urb, iso);\r\nbreak;\r\n}\r\nif ((dev->input_panic || dev->output_panic) && !dev->warned) {\r\ndebug("streaming error detected %s %s\n",\r\ndev->input_panic ? "(input)" : "",\r\ndev->output_panic ? "(output)" : "");\r\ndev->warned = 1;\r\n}\r\n}\r\nstatic void fill_out_urb_mode_0(struct snd_usb_caiaqdev *dev,\r\nstruct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nstruct snd_pcm_substream *sub;\r\nint stream, i;\r\nfor (i = 0; i < iso->length;) {\r\nfor (stream = 0; stream < dev->n_streams; stream++, i++) {\r\nsub = dev->sub_playback[stream];\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\nchar *audio_buf = rt->dma_area;\r\nint sz = frames_to_bytes(rt, rt->buffer_size);\r\nusb_buf[i] =\r\naudio_buf[dev->audio_out_buf_pos[stream]];\r\ndev->period_out_count[stream]++;\r\ndev->audio_out_buf_pos[stream]++;\r\nif (dev->audio_out_buf_pos[stream] == sz)\r\ndev->audio_out_buf_pos[stream] = 0;\r\n} else\r\nusb_buf[i] = 0;\r\n}\r\nif (dev->spec.data_alignment == 2 &&\r\ni % (dev->n_streams * BYTES_PER_SAMPLE_USB) ==\r\n(dev->n_streams * CHANNELS_PER_STREAM))\r\nfor (stream = 0; stream < dev->n_streams; stream++, i++)\r\nusb_buf[i] = MAKE_CHECKBYTE(dev, stream, i);\r\n}\r\n}\r\nstatic void fill_out_urb_mode_3(struct snd_usb_caiaqdev *dev,\r\nstruct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nint stream, i;\r\nfor (i = 0; i < iso->length;) {\r\nfor (stream = 0; stream < dev->n_streams; stream++) {\r\nstruct snd_pcm_substream *sub = dev->sub_playback[stream];\r\nchar *audio_buf = NULL;\r\nint c, n, sz = 0;\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\naudio_buf = rt->dma_area;\r\nsz = frames_to_bytes(rt, rt->buffer_size);\r\n}\r\nfor (c = 0; c < CHANNELS_PER_STREAM; c++) {\r\nfor (n = 0; n < BYTES_PER_SAMPLE; n++) {\r\nif (audio_buf) {\r\nusb_buf[i+n] = audio_buf[dev->audio_out_buf_pos[stream]++];\r\nif (dev->audio_out_buf_pos[stream] == sz)\r\ndev->audio_out_buf_pos[stream] = 0;\r\n} else {\r\nusb_buf[i+n] = 0;\r\n}\r\n}\r\nif (audio_buf)\r\ndev->period_out_count[stream] += BYTES_PER_SAMPLE;\r\ni += BYTES_PER_SAMPLE;\r\nusb_buf[i++] = (stream << 1) | c;\r\n}\r\n}\r\n}\r\n}\r\nstatic inline void fill_out_urb(struct snd_usb_caiaqdev *dev,\r\nstruct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nswitch (dev->spec.data_alignment) {\r\ncase 0:\r\ncase 2:\r\nfill_out_urb_mode_0(dev, urb, iso);\r\nbreak;\r\ncase 3:\r\nfill_out_urb_mode_3(dev, urb, iso);\r\nbreak;\r\n}\r\n}\r\nstatic void read_completed(struct urb *urb)\r\n{\r\nstruct snd_usb_caiaq_cb_info *info = urb->context;\r\nstruct snd_usb_caiaqdev *dev;\r\nstruct urb *out = NULL;\r\nint i, frame, len, send_it = 0, outframe = 0;\r\nsize_t offset = 0;\r\nif (urb->status || !info)\r\nreturn;\r\ndev = info->dev;\r\nif (!dev->streaming)\r\nreturn;\r\nfor (i = 0; i < N_URBS; i++)\r\nif (test_and_set_bit(i, &dev->outurb_active_mask) == 0) {\r\nout = dev->data_urbs_out[i];\r\nbreak;\r\n}\r\nif (!out) {\r\nlog("Unable to find an output urb to use\n");\r\ngoto requeue;\r\n}\r\nfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\r\nif (urb->iso_frame_desc[frame].status)\r\ncontinue;\r\nlen = urb->iso_frame_desc[outframe].actual_length;\r\nout->iso_frame_desc[outframe].length = len;\r\nout->iso_frame_desc[outframe].actual_length = 0;\r\nout->iso_frame_desc[outframe].offset = offset;\r\noffset += len;\r\nif (len > 0) {\r\nspin_lock(&dev->spinlock);\r\nfill_out_urb(dev, out, &out->iso_frame_desc[outframe]);\r\nread_in_urb(dev, urb, &urb->iso_frame_desc[frame]);\r\nspin_unlock(&dev->spinlock);\r\ncheck_for_elapsed_periods(dev, dev->sub_playback);\r\ncheck_for_elapsed_periods(dev, dev->sub_capture);\r\nsend_it = 1;\r\n}\r\noutframe++;\r\n}\r\nif (send_it) {\r\nout->number_of_packets = outframe;\r\nout->transfer_flags = URB_ISO_ASAP;\r\nusb_submit_urb(out, GFP_ATOMIC);\r\n} else {\r\nstruct snd_usb_caiaq_cb_info *oinfo = out->context;\r\nclear_bit(oinfo->index, &dev->outurb_active_mask);\r\n}\r\nrequeue:\r\nfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\r\nurb->iso_frame_desc[frame].offset = BYTES_PER_FRAME * frame;\r\nurb->iso_frame_desc[frame].length = BYTES_PER_FRAME;\r\nurb->iso_frame_desc[frame].actual_length = 0;\r\n}\r\nurb->number_of_packets = FRAMES_PER_URB;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void write_completed(struct urb *urb)\r\n{\r\nstruct snd_usb_caiaq_cb_info *info = urb->context;\r\nstruct snd_usb_caiaqdev *dev = info->dev;\r\nif (!dev->output_running) {\r\ndev->output_running = 1;\r\nwake_up(&dev->prepare_wait_queue);\r\n}\r\nclear_bit(info->index, &dev->outurb_active_mask);\r\n}\r\nstatic struct urb **alloc_urbs(struct snd_usb_caiaqdev *dev, int dir, int *ret)\r\n{\r\nint i, frame;\r\nstruct urb **urbs;\r\nstruct usb_device *usb_dev = dev->chip.dev;\r\nunsigned int pipe;\r\npipe = (dir == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nusb_sndisocpipe(usb_dev, ENDPOINT_PLAYBACK) :\r\nusb_rcvisocpipe(usb_dev, ENDPOINT_CAPTURE);\r\nurbs = kmalloc(N_URBS * sizeof(*urbs), GFP_KERNEL);\r\nif (!urbs) {\r\nlog("unable to kmalloc() urbs, OOM!?\n");\r\n*ret = -ENOMEM;\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < N_URBS; i++) {\r\nurbs[i] = usb_alloc_urb(FRAMES_PER_URB, GFP_KERNEL);\r\nif (!urbs[i]) {\r\nlog("unable to usb_alloc_urb(), OOM!?\n");\r\n*ret = -ENOMEM;\r\nreturn urbs;\r\n}\r\nurbs[i]->transfer_buffer =\r\nkmalloc(FRAMES_PER_URB * BYTES_PER_FRAME, GFP_KERNEL);\r\nif (!urbs[i]->transfer_buffer) {\r\nlog("unable to kmalloc() transfer buffer, OOM!?\n");\r\n*ret = -ENOMEM;\r\nreturn urbs;\r\n}\r\nfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\r\nstruct usb_iso_packet_descriptor *iso =\r\n&urbs[i]->iso_frame_desc[frame];\r\niso->offset = BYTES_PER_FRAME * frame;\r\niso->length = BYTES_PER_FRAME;\r\n}\r\nurbs[i]->dev = usb_dev;\r\nurbs[i]->pipe = pipe;\r\nurbs[i]->transfer_buffer_length = FRAMES_PER_URB\r\n* BYTES_PER_FRAME;\r\nurbs[i]->context = &dev->data_cb_info[i];\r\nurbs[i]->interval = 1;\r\nurbs[i]->transfer_flags = URB_ISO_ASAP;\r\nurbs[i]->number_of_packets = FRAMES_PER_URB;\r\nurbs[i]->complete = (dir == SNDRV_PCM_STREAM_CAPTURE) ?\r\nread_completed : write_completed;\r\n}\r\n*ret = 0;\r\nreturn urbs;\r\n}\r\nstatic void free_urbs(struct urb **urbs)\r\n{\r\nint i;\r\nif (!urbs)\r\nreturn;\r\nfor (i = 0; i < N_URBS; i++) {\r\nif (!urbs[i])\r\ncontinue;\r\nusb_kill_urb(urbs[i]);\r\nkfree(urbs[i]->transfer_buffer);\r\nusb_free_urb(urbs[i]);\r\n}\r\nkfree(urbs);\r\n}\r\nint snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *dev)\r\n{\r\nint i, ret;\r\ndev->n_audio_in = max(dev->spec.num_analog_audio_in,\r\ndev->spec.num_digital_audio_in) /\r\nCHANNELS_PER_STREAM;\r\ndev->n_audio_out = max(dev->spec.num_analog_audio_out,\r\ndev->spec.num_digital_audio_out) /\r\nCHANNELS_PER_STREAM;\r\ndev->n_streams = max(dev->n_audio_in, dev->n_audio_out);\r\ndebug("dev->n_audio_in = %d\n", dev->n_audio_in);\r\ndebug("dev->n_audio_out = %d\n", dev->n_audio_out);\r\ndebug("dev->n_streams = %d\n", dev->n_streams);\r\nif (dev->n_streams > MAX_STREAMS) {\r\nlog("unable to initialize device, too many streams.\n");\r\nreturn -EINVAL;\r\n}\r\nret = snd_pcm_new(dev->chip.card, dev->product_name, 0,\r\ndev->n_audio_out, dev->n_audio_in, &dev->pcm);\r\nif (ret < 0) {\r\nlog("snd_pcm_new() returned %d\n", ret);\r\nreturn ret;\r\n}\r\ndev->pcm->private_data = dev;\r\nstrlcpy(dev->pcm->name, dev->product_name, sizeof(dev->pcm->name));\r\nmemset(dev->sub_playback, 0, sizeof(dev->sub_playback));\r\nmemset(dev->sub_capture, 0, sizeof(dev->sub_capture));\r\nmemcpy(&dev->pcm_info, &snd_usb_caiaq_pcm_hardware,\r\nsizeof(snd_usb_caiaq_pcm_hardware));\r\ndev->samplerates = dev->pcm_info.rates;\r\nswitch (dev->chip.usb_id) {\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_SESSIONIO):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_GUITARRIGMOBILE):\r\ndev->samplerates |= SNDRV_PCM_RATE_192000;\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO2DJ):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORAUDIO2):\r\ndev->samplerates |= SNDRV_PCM_RATE_88200;\r\nbreak;\r\n}\r\nsnd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_usb_caiaq_ops);\r\nsnd_pcm_set_ops(dev->pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_usb_caiaq_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(dev->pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\nMAX_BUFFER_SIZE, MAX_BUFFER_SIZE);\r\ndev->data_cb_info =\r\nkmalloc(sizeof(struct snd_usb_caiaq_cb_info) * N_URBS,\r\nGFP_KERNEL);\r\nif (!dev->data_cb_info)\r\nreturn -ENOMEM;\r\ndev->outurb_active_mask = 0;\r\nBUILD_BUG_ON(N_URBS > (sizeof(dev->outurb_active_mask) * 8));\r\nfor (i = 0; i < N_URBS; i++) {\r\ndev->data_cb_info[i].dev = dev;\r\ndev->data_cb_info[i].index = i;\r\n}\r\ndev->data_urbs_in = alloc_urbs(dev, SNDRV_PCM_STREAM_CAPTURE, &ret);\r\nif (ret < 0) {\r\nkfree(dev->data_cb_info);\r\nfree_urbs(dev->data_urbs_in);\r\nreturn ret;\r\n}\r\ndev->data_urbs_out = alloc_urbs(dev, SNDRV_PCM_STREAM_PLAYBACK, &ret);\r\nif (ret < 0) {\r\nkfree(dev->data_cb_info);\r\nfree_urbs(dev->data_urbs_in);\r\nfree_urbs(dev->data_urbs_out);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *dev)\r\n{\r\ndebug("%s(%p)\n", __func__, dev);\r\nstream_stop(dev);\r\nfree_urbs(dev->data_urbs_in);\r\nfree_urbs(dev->data_urbs_out);\r\nkfree(dev->data_cb_info);\r\n}
