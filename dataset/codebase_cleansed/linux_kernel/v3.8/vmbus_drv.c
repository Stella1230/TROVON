static int vmbus_exists(void)\r\n{\r\nif (hv_acpi_dev == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void get_channel_info(struct hv_device *device,\r\nstruct hv_device_info *info)\r\n{\r\nstruct vmbus_channel_debug_info debug_info;\r\nif (!device->channel)\r\nreturn;\r\nvmbus_get_debug_info(device->channel, &debug_info);\r\ninfo->chn_id = debug_info.relid;\r\ninfo->chn_state = debug_info.state;\r\nmemcpy(&info->chn_type, &debug_info.interfacetype,\r\nsizeof(uuid_le));\r\nmemcpy(&info->chn_instance, &debug_info.interface_instance,\r\nsizeof(uuid_le));\r\ninfo->monitor_id = debug_info.monitorid;\r\ninfo->server_monitor_pending = debug_info.servermonitor_pending;\r\ninfo->server_monitor_latency = debug_info.servermonitor_latency;\r\ninfo->server_monitor_conn_id = debug_info.servermonitor_connectionid;\r\ninfo->client_monitor_pending = debug_info.clientmonitor_pending;\r\ninfo->client_monitor_latency = debug_info.clientmonitor_latency;\r\ninfo->client_monitor_conn_id = debug_info.clientmonitor_connectionid;\r\ninfo->inbound.int_mask = debug_info.inbound.current_interrupt_mask;\r\ninfo->inbound.read_idx = debug_info.inbound.current_read_index;\r\ninfo->inbound.write_idx = debug_info.inbound.current_write_index;\r\ninfo->inbound.bytes_avail_toread =\r\ndebug_info.inbound.bytes_avail_toread;\r\ninfo->inbound.bytes_avail_towrite =\r\ndebug_info.inbound.bytes_avail_towrite;\r\ninfo->outbound.int_mask =\r\ndebug_info.outbound.current_interrupt_mask;\r\ninfo->outbound.read_idx = debug_info.outbound.current_read_index;\r\ninfo->outbound.write_idx = debug_info.outbound.current_write_index;\r\ninfo->outbound.bytes_avail_toread =\r\ndebug_info.outbound.bytes_avail_toread;\r\ninfo->outbound.bytes_avail_towrite =\r\ndebug_info.outbound.bytes_avail_towrite;\r\n}\r\nstatic void print_alias_name(struct hv_device *hv_dev, char *alias_name)\r\n{\r\nint i;\r\nfor (i = 0; i < VMBUS_ALIAS_LEN; i += 2)\r\nsprintf(&alias_name[i], "%02x", hv_dev->dev_type.b[i/2]);\r\n}\r\nstatic ssize_t vmbus_show_device_attr(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(dev);\r\nstruct hv_device_info *device_info;\r\nchar alias_name[VMBUS_ALIAS_LEN + 1];\r\nint ret = 0;\r\ndevice_info = kzalloc(sizeof(struct hv_device_info), GFP_KERNEL);\r\nif (!device_info)\r\nreturn ret;\r\nget_channel_info(hv_dev, device_info);\r\nif (!strcmp(dev_attr->attr.name, "class_id")) {\r\nret = sprintf(buf, "{%pUl}\n", device_info->chn_type.b);\r\n} else if (!strcmp(dev_attr->attr.name, "device_id")) {\r\nret = sprintf(buf, "{%pUl}\n", device_info->chn_instance.b);\r\n} else if (!strcmp(dev_attr->attr.name, "modalias")) {\r\nprint_alias_name(hv_dev, alias_name);\r\nret = sprintf(buf, "vmbus:%s\n", alias_name);\r\n} else if (!strcmp(dev_attr->attr.name, "state")) {\r\nret = sprintf(buf, "%d\n", device_info->chn_state);\r\n} else if (!strcmp(dev_attr->attr.name, "id")) {\r\nret = sprintf(buf, "%d\n", device_info->chn_id);\r\n} else if (!strcmp(dev_attr->attr.name, "out_intr_mask")) {\r\nret = sprintf(buf, "%d\n", device_info->outbound.int_mask);\r\n} else if (!strcmp(dev_attr->attr.name, "out_read_index")) {\r\nret = sprintf(buf, "%d\n", device_info->outbound.read_idx);\r\n} else if (!strcmp(dev_attr->attr.name, "out_write_index")) {\r\nret = sprintf(buf, "%d\n", device_info->outbound.write_idx);\r\n} else if (!strcmp(dev_attr->attr.name, "out_read_bytes_avail")) {\r\nret = sprintf(buf, "%d\n",\r\ndevice_info->outbound.bytes_avail_toread);\r\n} else if (!strcmp(dev_attr->attr.name, "out_write_bytes_avail")) {\r\nret = sprintf(buf, "%d\n",\r\ndevice_info->outbound.bytes_avail_towrite);\r\n} else if (!strcmp(dev_attr->attr.name, "in_intr_mask")) {\r\nret = sprintf(buf, "%d\n", device_info->inbound.int_mask);\r\n} else if (!strcmp(dev_attr->attr.name, "in_read_index")) {\r\nret = sprintf(buf, "%d\n", device_info->inbound.read_idx);\r\n} else if (!strcmp(dev_attr->attr.name, "in_write_index")) {\r\nret = sprintf(buf, "%d\n", device_info->inbound.write_idx);\r\n} else if (!strcmp(dev_attr->attr.name, "in_read_bytes_avail")) {\r\nret = sprintf(buf, "%d\n",\r\ndevice_info->inbound.bytes_avail_toread);\r\n} else if (!strcmp(dev_attr->attr.name, "in_write_bytes_avail")) {\r\nret = sprintf(buf, "%d\n",\r\ndevice_info->inbound.bytes_avail_towrite);\r\n} else if (!strcmp(dev_attr->attr.name, "monitor_id")) {\r\nret = sprintf(buf, "%d\n", device_info->monitor_id);\r\n} else if (!strcmp(dev_attr->attr.name, "server_monitor_pending")) {\r\nret = sprintf(buf, "%d\n", device_info->server_monitor_pending);\r\n} else if (!strcmp(dev_attr->attr.name, "server_monitor_latency")) {\r\nret = sprintf(buf, "%d\n", device_info->server_monitor_latency);\r\n} else if (!strcmp(dev_attr->attr.name, "server_monitor_conn_id")) {\r\nret = sprintf(buf, "%d\n",\r\ndevice_info->server_monitor_conn_id);\r\n} else if (!strcmp(dev_attr->attr.name, "client_monitor_pending")) {\r\nret = sprintf(buf, "%d\n", device_info->client_monitor_pending);\r\n} else if (!strcmp(dev_attr->attr.name, "client_monitor_latency")) {\r\nret = sprintf(buf, "%d\n", device_info->client_monitor_latency);\r\n} else if (!strcmp(dev_attr->attr.name, "client_monitor_conn_id")) {\r\nret = sprintf(buf, "%d\n",\r\ndevice_info->client_monitor_conn_id);\r\n}\r\nkfree(device_info);\r\nreturn ret;\r\n}\r\nstatic int vmbus_uevent(struct device *device, struct kobj_uevent_env *env)\r\n{\r\nstruct hv_device *dev = device_to_hv_device(device);\r\nint ret;\r\nchar alias_name[VMBUS_ALIAS_LEN + 1];\r\nprint_alias_name(dev, alias_name);\r\nret = add_uevent_var(env, "MODALIAS=vmbus:%s", alias_name);\r\nreturn ret;\r\n}\r\nstatic inline bool is_null_guid(const __u8 *guid)\r\n{\r\nif (memcmp(guid, &null_guid, sizeof(uuid_le)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic const struct hv_vmbus_device_id *hv_vmbus_get_id(\r\nconst struct hv_vmbus_device_id *id,\r\n__u8 *guid)\r\n{\r\nfor (; !is_null_guid(id->guid); id++)\r\nif (!memcmp(&id->guid, guid, sizeof(uuid_le)))\r\nreturn id;\r\nreturn NULL;\r\n}\r\nstatic int vmbus_match(struct device *device, struct device_driver *driver)\r\n{\r\nstruct hv_driver *drv = drv_to_hv_drv(driver);\r\nstruct hv_device *hv_dev = device_to_hv_device(device);\r\nif (hv_vmbus_get_id(drv->id_table, hv_dev->dev_type.b))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vmbus_probe(struct device *child_device)\r\n{\r\nint ret = 0;\r\nstruct hv_driver *drv =\r\ndrv_to_hv_drv(child_device->driver);\r\nstruct hv_device *dev = device_to_hv_device(child_device);\r\nconst struct hv_vmbus_device_id *dev_id;\r\ndev_id = hv_vmbus_get_id(drv->id_table, dev->dev_type.b);\r\nif (drv->probe) {\r\nret = drv->probe(dev, dev_id);\r\nif (ret != 0)\r\npr_err("probe failed for device %s (%d)\n",\r\ndev_name(child_device), ret);\r\n} else {\r\npr_err("probe not set for driver %s\n",\r\ndev_name(child_device));\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vmbus_remove(struct device *child_device)\r\n{\r\nstruct hv_driver *drv = drv_to_hv_drv(child_device->driver);\r\nstruct hv_device *dev = device_to_hv_device(child_device);\r\nif (drv->remove)\r\ndrv->remove(dev);\r\nelse\r\npr_err("remove not set for driver %s\n",\r\ndev_name(child_device));\r\nreturn 0;\r\n}\r\nstatic void vmbus_shutdown(struct device *child_device)\r\n{\r\nstruct hv_driver *drv;\r\nstruct hv_device *dev = device_to_hv_device(child_device);\r\nif (!child_device->driver)\r\nreturn;\r\ndrv = drv_to_hv_drv(child_device->driver);\r\nif (drv->shutdown)\r\ndrv->shutdown(dev);\r\nreturn;\r\n}\r\nstatic void vmbus_device_release(struct device *device)\r\n{\r\nstruct hv_device *hv_dev = device_to_hv_device(device);\r\nkfree(hv_dev);\r\n}\r\nstatic void vmbus_onmessage_work(struct work_struct *work)\r\n{\r\nstruct onmessage_work_context *ctx;\r\nctx = container_of(work, struct onmessage_work_context,\r\nwork);\r\nvmbus_onmessage(&ctx->msg);\r\nkfree(ctx);\r\n}\r\nstatic void vmbus_on_msg_dpc(unsigned long data)\r\n{\r\nint cpu = smp_processor_id();\r\nvoid *page_addr = hv_context.synic_message_page[cpu];\r\nstruct hv_message *msg = (struct hv_message *)page_addr +\r\nVMBUS_MESSAGE_SINT;\r\nstruct onmessage_work_context *ctx;\r\nwhile (1) {\r\nif (msg->header.message_type == HVMSG_NONE) {\r\nbreak;\r\n} else {\r\nctx = kmalloc(sizeof(*ctx), GFP_ATOMIC);\r\nif (ctx == NULL)\r\ncontinue;\r\nINIT_WORK(&ctx->work, vmbus_onmessage_work);\r\nmemcpy(&ctx->msg, msg, sizeof(*msg));\r\nqueue_work(vmbus_connection.work_queue, &ctx->work);\r\n}\r\nmsg->header.message_type = HVMSG_NONE;\r\nsmp_mb();\r\nif (msg->header.message_flags.msg_pending) {\r\nwrmsrl(HV_X64_MSR_EOM, 0);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t vmbus_isr(int irq, void *dev_id)\r\n{\r\nint cpu = smp_processor_id();\r\nvoid *page_addr;\r\nstruct hv_message *msg;\r\nunion hv_synic_event_flags *event;\r\nbool handled = false;\r\npage_addr = hv_context.synic_event_page[cpu];\r\nevent = (union hv_synic_event_flags *)page_addr + VMBUS_MESSAGE_SINT;\r\nif (sync_test_and_clear_bit(0, (unsigned long *) &event->flags32[0])) {\r\nhandled = true;\r\ntasklet_schedule(&event_dpc);\r\n}\r\npage_addr = hv_context.synic_message_page[cpu];\r\nmsg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;\r\nif (msg->header.message_type != HVMSG_NONE) {\r\nhandled = true;\r\ntasklet_schedule(&msg_dpc);\r\n}\r\nif (handled)\r\nreturn IRQ_HANDLED;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nstatic int vmbus_bus_init(int irq)\r\n{\r\nint ret;\r\nunsigned int vector;\r\nret = hv_init();\r\nif (ret != 0) {\r\npr_err("Unable to initialize the hypervisor - 0x%x\n", ret);\r\nreturn ret;\r\n}\r\ntasklet_init(&msg_dpc, vmbus_on_msg_dpc, 0);\r\ntasklet_init(&event_dpc, vmbus_on_event, 0);\r\nret = bus_register(&hv_bus);\r\nif (ret)\r\ngoto err_cleanup;\r\nret = request_irq(irq, vmbus_isr, 0, driver_name, hv_acpi_dev);\r\nif (ret != 0) {\r\npr_err("Unable to request IRQ %d\n",\r\nirq);\r\ngoto err_unregister;\r\n}\r\nvector = IRQ0_VECTOR + irq;\r\non_each_cpu(hv_synic_init, (void *)&vector, 1);\r\nret = vmbus_connect();\r\nif (ret)\r\ngoto err_irq;\r\nvmbus_request_offers();\r\nreturn 0;\r\nerr_irq:\r\nfree_irq(irq, hv_acpi_dev);\r\nerr_unregister:\r\nbus_unregister(&hv_bus);\r\nerr_cleanup:\r\nhv_cleanup();\r\nreturn ret;\r\n}\r\nint __vmbus_driver_register(struct hv_driver *hv_driver, struct module *owner, const char *mod_name)\r\n{\r\nint ret;\r\npr_info("registering driver %s\n", hv_driver->name);\r\nret = vmbus_exists();\r\nif (ret < 0)\r\nreturn ret;\r\nhv_driver->driver.name = hv_driver->name;\r\nhv_driver->driver.owner = owner;\r\nhv_driver->driver.mod_name = mod_name;\r\nhv_driver->driver.bus = &hv_bus;\r\nret = driver_register(&hv_driver->driver);\r\nvmbus_request_offers();\r\nreturn ret;\r\n}\r\nvoid vmbus_driver_unregister(struct hv_driver *hv_driver)\r\n{\r\npr_info("unregistering driver %s\n", hv_driver->name);\r\nif (!vmbus_exists())\r\ndriver_unregister(&hv_driver->driver);\r\n}\r\nstruct hv_device *vmbus_device_create(uuid_le *type,\r\nuuid_le *instance,\r\nstruct vmbus_channel *channel)\r\n{\r\nstruct hv_device *child_device_obj;\r\nchild_device_obj = kzalloc(sizeof(struct hv_device), GFP_KERNEL);\r\nif (!child_device_obj) {\r\npr_err("Unable to allocate device object for child device\n");\r\nreturn NULL;\r\n}\r\nchild_device_obj->channel = channel;\r\nmemcpy(&child_device_obj->dev_type, type, sizeof(uuid_le));\r\nmemcpy(&child_device_obj->dev_instance, instance,\r\nsizeof(uuid_le));\r\nreturn child_device_obj;\r\n}\r\nint vmbus_device_register(struct hv_device *child_device_obj)\r\n{\r\nint ret = 0;\r\nstatic atomic_t device_num = ATOMIC_INIT(0);\r\ndev_set_name(&child_device_obj->device, "vmbus_0_%d",\r\natomic_inc_return(&device_num));\r\nchild_device_obj->device.bus = &hv_bus;\r\nchild_device_obj->device.parent = &hv_acpi_dev->dev;\r\nchild_device_obj->device.release = vmbus_device_release;\r\nret = device_register(&child_device_obj->device);\r\nif (ret)\r\npr_err("Unable to register child device\n");\r\nelse\r\npr_info("child device %s registered\n",\r\ndev_name(&child_device_obj->device));\r\nreturn ret;\r\n}\r\nvoid vmbus_device_unregister(struct hv_device *device_obj)\r\n{\r\ndevice_unregister(&device_obj->device);\r\npr_info("child device %s unregistered\n",\r\ndev_name(&device_obj->device));\r\n}\r\nstatic acpi_status vmbus_walk_resources(struct acpi_resource *res, void *irq)\r\n{\r\nif (res->type == ACPI_RESOURCE_TYPE_IRQ) {\r\nstruct acpi_resource_irq *irqp;\r\nirqp = &res->data.irq;\r\n*((unsigned int *)irq) = irqp->interrupts[0];\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int vmbus_acpi_add(struct acpi_device *device)\r\n{\r\nacpi_status result;\r\nhv_acpi_dev = device;\r\nresult = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nvmbus_walk_resources, &irq);\r\nif (ACPI_FAILURE(result)) {\r\ncomplete(&probe_event);\r\nreturn -ENODEV;\r\n}\r\ncomplete(&probe_event);\r\nreturn 0;\r\n}\r\nstatic int __init hv_acpi_init(void)\r\n{\r\nint ret, t;\r\nif (x86_hyper != &x86_hyper_ms_hyperv)\r\nreturn -ENODEV;\r\ninit_completion(&probe_event);\r\nret = acpi_bus_register_driver(&vmbus_acpi_driver);\r\nif (ret)\r\nreturn ret;\r\nt = wait_for_completion_timeout(&probe_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nif (irq <= 0) {\r\nret = -ENODEV;\r\ngoto cleanup;\r\n}\r\nret = vmbus_bus_init(irq);\r\nif (ret)\r\ngoto cleanup;\r\nreturn 0;\r\ncleanup:\r\nacpi_bus_unregister_driver(&vmbus_acpi_driver);\r\nhv_acpi_dev = NULL;\r\nreturn ret;\r\n}\r\nstatic void __exit vmbus_exit(void)\r\n{\r\nfree_irq(irq, hv_acpi_dev);\r\nvmbus_free_channels();\r\nbus_unregister(&hv_bus);\r\nhv_cleanup();\r\nacpi_bus_unregister_driver(&vmbus_acpi_driver);\r\n}
