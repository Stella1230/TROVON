static int drm_setup(struct drm_device * dev)\r\n{\r\nint i;\r\nint ret;\r\nif (dev->driver->firstopen) {\r\nret = dev->driver->firstopen(dev);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\natomic_set(&dev->ioctl_count, 0);\r\natomic_set(&dev->vma_count, 0);\r\nif (drm_core_check_feature(dev, DRIVER_HAVE_DMA) &&\r\n!drm_core_check_feature(dev, DRIVER_MODESET)) {\r\ndev->buf_use = 0;\r\natomic_set(&dev->buf_alloc, 0);\r\ni = drm_dma_setup(dev);\r\nif (i < 0)\r\nreturn i;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dev->counts); i++)\r\natomic_set(&dev->counts[i], 0);\r\ndev->sigdata.lock = NULL;\r\ndev->context_flag = 0;\r\ndev->interrupt_flag = 0;\r\ndev->dma_flag = 0;\r\ndev->last_context = 0;\r\ndev->last_switch = 0;\r\ndev->last_checked = 0;\r\ninit_waitqueue_head(&dev->context_wait);\r\ndev->if_version = 0;\r\ndev->ctx_start = 0;\r\ndev->lck_start = 0;\r\ndev->buf_async = NULL;\r\ninit_waitqueue_head(&dev->buf_readers);\r\ninit_waitqueue_head(&dev->buf_writers);\r\nDRM_DEBUG("\n");\r\nreturn 0;\r\n}\r\nint drm_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct drm_device *dev = NULL;\r\nint minor_id = iminor(inode);\r\nstruct drm_minor *minor;\r\nint retcode = 0;\r\nint need_setup = 0;\r\nstruct address_space *old_mapping;\r\nminor = idr_find(&drm_minors_idr, minor_id);\r\nif (!minor)\r\nreturn -ENODEV;\r\nif (!(dev = minor->dev))\r\nreturn -ENODEV;\r\nif (drm_device_is_unplugged(dev))\r\nreturn -ENODEV;\r\nif (!dev->open_count++)\r\nneed_setup = 1;\r\nmutex_lock(&dev->struct_mutex);\r\nold_mapping = dev->dev_mapping;\r\nif (old_mapping == NULL)\r\ndev->dev_mapping = &inode->i_data;\r\nihold(container_of(dev->dev_mapping, struct inode, i_data));\r\ninode->i_mapping = dev->dev_mapping;\r\nfilp->f_mapping = dev->dev_mapping;\r\nmutex_unlock(&dev->struct_mutex);\r\nretcode = drm_open_helper(inode, filp, dev);\r\nif (retcode)\r\ngoto err_undo;\r\natomic_inc(&dev->counts[_DRM_STAT_OPENS]);\r\nif (need_setup) {\r\nretcode = drm_setup(dev);\r\nif (retcode)\r\ngoto err_undo;\r\n}\r\nreturn 0;\r\nerr_undo:\r\nmutex_lock(&dev->struct_mutex);\r\nfilp->f_mapping = old_mapping;\r\ninode->i_mapping = old_mapping;\r\niput(container_of(dev->dev_mapping, struct inode, i_data));\r\ndev->dev_mapping = old_mapping;\r\nmutex_unlock(&dev->struct_mutex);\r\ndev->open_count--;\r\nreturn retcode;\r\n}\r\nint drm_stub_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct drm_device *dev = NULL;\r\nstruct drm_minor *minor;\r\nint minor_id = iminor(inode);\r\nint err = -ENODEV;\r\nconst struct file_operations *old_fops;\r\nDRM_DEBUG("\n");\r\nmutex_lock(&drm_global_mutex);\r\nminor = idr_find(&drm_minors_idr, minor_id);\r\nif (!minor)\r\ngoto out;\r\nif (!(dev = minor->dev))\r\ngoto out;\r\nif (drm_device_is_unplugged(dev))\r\ngoto out;\r\nold_fops = filp->f_op;\r\nfilp->f_op = fops_get(dev->driver->fops);\r\nif (filp->f_op == NULL) {\r\nfilp->f_op = old_fops;\r\ngoto out;\r\n}\r\nif (filp->f_op->open && (err = filp->f_op->open(inode, filp))) {\r\nfops_put(filp->f_op);\r\nfilp->f_op = fops_get(old_fops);\r\n}\r\nfops_put(old_fops);\r\nout:\r\nmutex_unlock(&drm_global_mutex);\r\nreturn err;\r\n}\r\nstatic int drm_cpu_valid(void)\r\n{\r\n#if defined(__i386__)\r\nif (boot_cpu_data.x86 == 3)\r\nreturn 0;\r\n#endif\r\n#if defined(__sparc__) && !defined(__sparc_v9__)\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int drm_open_helper(struct inode *inode, struct file *filp,\r\nstruct drm_device * dev)\r\n{\r\nint minor_id = iminor(inode);\r\nstruct drm_file *priv;\r\nint ret;\r\nif (filp->f_flags & O_EXCL)\r\nreturn -EBUSY;\r\nif (!drm_cpu_valid())\r\nreturn -EINVAL;\r\nif (dev->switch_power_state != DRM_SWITCH_POWER_ON)\r\nreturn -EINVAL;\r\nDRM_DEBUG("pid = %d, minor = %d\n", task_pid_nr(current), minor_id);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfilp->private_data = priv;\r\npriv->filp = filp;\r\npriv->uid = current_euid();\r\npriv->pid = get_pid(task_pid(current));\r\npriv->minor = idr_find(&drm_minors_idr, minor_id);\r\npriv->ioctl_count = 0;\r\npriv->authenticated = capable(CAP_SYS_ADMIN);\r\npriv->lock_count = 0;\r\nINIT_LIST_HEAD(&priv->lhead);\r\nINIT_LIST_HEAD(&priv->fbs);\r\nINIT_LIST_HEAD(&priv->event_list);\r\ninit_waitqueue_head(&priv->event_wait);\r\npriv->event_space = 4096;\r\nif (dev->driver->driver_features & DRIVER_GEM)\r\ndrm_gem_open(dev, priv);\r\nif (drm_core_check_feature(dev, DRIVER_PRIME))\r\ndrm_prime_init_file_private(&priv->prime);\r\nif (dev->driver->open) {\r\nret = dev->driver->open(dev, priv);\r\nif (ret < 0)\r\ngoto out_free;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (!priv->minor->master) {\r\npriv->minor->master = drm_master_create(priv->minor);\r\nif (!priv->minor->master) {\r\nmutex_unlock(&dev->struct_mutex);\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\npriv->is_master = 1;\r\npriv->master = drm_master_get(priv->minor->master);\r\npriv->authenticated = 1;\r\nmutex_unlock(&dev->struct_mutex);\r\nif (dev->driver->master_create) {\r\nret = dev->driver->master_create(dev, priv->master);\r\nif (ret) {\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_master_put(&priv->minor->master);\r\ndrm_master_put(&priv->master);\r\nmutex_unlock(&dev->struct_mutex);\r\ngoto out_free;\r\n}\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (dev->driver->master_set) {\r\nret = dev->driver->master_set(dev, priv, true);\r\nif (ret) {\r\ndrm_master_put(&priv->minor->master);\r\ndrm_master_put(&priv->master);\r\nmutex_unlock(&dev->struct_mutex);\r\ngoto out_free;\r\n}\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\n} else {\r\npriv->master = drm_master_get(priv->minor->master);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nlist_add(&priv->lhead, &dev->filelist);\r\nmutex_unlock(&dev->struct_mutex);\r\n#ifdef __alpha__\r\nif (!dev->hose) {\r\nstruct pci_dev *pci_dev;\r\npci_dev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);\r\nif (pci_dev) {\r\ndev->hose = pci_dev->sysdata;\r\npci_dev_put(pci_dev);\r\n}\r\nif (!dev->hose) {\r\nstruct pci_bus *b = pci_bus_b(pci_root_buses.next);\r\nif (b)\r\ndev->hose = b->sysdata;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\nout_free:\r\nkfree(priv);\r\nfilp->private_data = NULL;\r\nreturn ret;\r\n}\r\nint drm_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct drm_file *priv = filp->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nDRM_DEBUG("fd = %d, device = 0x%lx\n", fd,\r\n(long)old_encode_dev(priv->minor->device));\r\nreturn fasync_helper(fd, filp, on, &dev->buf_async);\r\n}\r\nstatic void drm_master_release(struct drm_device *dev, struct file *filp)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nif (drm_i_have_hw_lock(dev, file_priv)) {\r\nDRM_DEBUG("File %p released, freeing lock for context %d\n",\r\nfilp, _DRM_LOCKING_CONTEXT(file_priv->master->lock.hw_lock->lock));\r\ndrm_lock_free(&file_priv->master->lock,\r\n_DRM_LOCKING_CONTEXT(file_priv->master->lock.hw_lock->lock));\r\n}\r\n}\r\nstatic void drm_events_release(struct drm_file *file_priv)\r\n{\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nstruct drm_pending_event *e, *et;\r\nstruct drm_pending_vblank_event *v, *vt;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry_safe(v, vt, &dev->vblank_event_list, base.link)\r\nif (v->base.file_priv == file_priv) {\r\nlist_del(&v->base.link);\r\ndrm_vblank_put(dev, v->pipe);\r\nv->base.destroy(&v->base);\r\n}\r\nlist_for_each_entry_safe(e, et, &file_priv->event_list, link)\r\ne->destroy(e);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nint drm_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nint retcode = 0;\r\nmutex_lock(&drm_global_mutex);\r\nDRM_DEBUG("open_count = %d\n", dev->open_count);\r\nif (dev->driver->preclose)\r\ndev->driver->preclose(dev, file_priv);\r\nDRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",\r\ntask_pid_nr(current),\r\n(long)old_encode_dev(file_priv->minor->device),\r\ndev->open_count);\r\nif (file_priv->magic)\r\n(void) drm_remove_magic(file_priv->master, file_priv->magic);\r\nif (file_priv->minor->master)\r\ndrm_master_release(dev, filp);\r\nif (drm_core_check_feature(dev, DRIVER_HAVE_DMA))\r\ndrm_core_reclaim_buffers(dev, file_priv);\r\ndrm_events_release(file_priv);\r\nif (dev->driver->driver_features & DRIVER_MODESET)\r\ndrm_fb_release(file_priv);\r\nif (dev->driver->driver_features & DRIVER_GEM)\r\ndrm_gem_release(dev, file_priv);\r\nmutex_lock(&dev->ctxlist_mutex);\r\nif (!list_empty(&dev->ctxlist)) {\r\nstruct drm_ctx_list *pos, *n;\r\nlist_for_each_entry_safe(pos, n, &dev->ctxlist, head) {\r\nif (pos->tag == file_priv &&\r\npos->handle != DRM_KERNEL_CONTEXT) {\r\nif (dev->driver->context_dtor)\r\ndev->driver->context_dtor(dev,\r\npos->handle);\r\ndrm_ctxbitmap_free(dev, pos->handle);\r\nlist_del(&pos->head);\r\nkfree(pos);\r\n--dev->ctx_count;\r\n}\r\n}\r\n}\r\nmutex_unlock(&dev->ctxlist_mutex);\r\nmutex_lock(&dev->struct_mutex);\r\nif (file_priv->is_master) {\r\nstruct drm_master *master = file_priv->master;\r\nstruct drm_file *temp;\r\nlist_for_each_entry(temp, &dev->filelist, lhead) {\r\nif ((temp->master == file_priv->master) &&\r\n(temp != file_priv))\r\ntemp->authenticated = 0;\r\n}\r\nif (master->lock.hw_lock) {\r\nif (dev->sigdata.lock == master->lock.hw_lock)\r\ndev->sigdata.lock = NULL;\r\nmaster->lock.hw_lock = NULL;\r\nmaster->lock.file_priv = NULL;\r\nwake_up_interruptible_all(&master->lock.lock_queue);\r\n}\r\nif (file_priv->minor->master == file_priv->master) {\r\nif (dev->driver->master_drop)\r\ndev->driver->master_drop(dev, file_priv, true);\r\ndrm_master_put(&file_priv->minor->master);\r\n}\r\n}\r\nBUG_ON(dev->dev_mapping == NULL);\r\niput(container_of(dev->dev_mapping, struct inode, i_data));\r\ndrm_master_put(&file_priv->master);\r\nfile_priv->is_master = 0;\r\nlist_del(&file_priv->lhead);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (dev->driver->postclose)\r\ndev->driver->postclose(dev, file_priv);\r\nif (drm_core_check_feature(dev, DRIVER_PRIME))\r\ndrm_prime_destroy_file_private(&file_priv->prime);\r\nput_pid(file_priv->pid);\r\nkfree(file_priv);\r\natomic_inc(&dev->counts[_DRM_STAT_CLOSES]);\r\nif (!--dev->open_count) {\r\nif (atomic_read(&dev->ioctl_count)) {\r\nDRM_ERROR("Device busy: %d\n",\r\natomic_read(&dev->ioctl_count));\r\nretcode = -EBUSY;\r\n} else\r\nretcode = drm_lastclose(dev);\r\nif (drm_device_is_unplugged(dev))\r\ndrm_put_dev(dev);\r\n}\r\nmutex_unlock(&drm_global_mutex);\r\nreturn retcode;\r\n}\r\nstatic bool\r\ndrm_dequeue_event(struct drm_file *file_priv,\r\nsize_t total, size_t max, struct drm_pending_event **out)\r\n{\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nstruct drm_pending_event *e;\r\nunsigned long flags;\r\nbool ret = false;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\n*out = NULL;\r\nif (list_empty(&file_priv->event_list))\r\ngoto out;\r\ne = list_first_entry(&file_priv->event_list,\r\nstruct drm_pending_event, link);\r\nif (e->event->length + total > max)\r\ngoto out;\r\nfile_priv->event_space += e->event->length;\r\nlist_del(&e->link);\r\n*out = e;\r\nret = true;\r\nout:\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn ret;\r\n}\r\nssize_t drm_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_pending_event *e;\r\nsize_t total;\r\nssize_t ret;\r\nret = wait_event_interruptible(file_priv->event_wait,\r\n!list_empty(&file_priv->event_list));\r\nif (ret < 0)\r\nreturn ret;\r\ntotal = 0;\r\nwhile (drm_dequeue_event(file_priv, total, count, &e)) {\r\nif (copy_to_user(buffer + total,\r\ne->event, e->event->length)) {\r\ntotal = -EFAULT;\r\nbreak;\r\n}\r\ntotal += e->event->length;\r\ne->destroy(e);\r\n}\r\nreturn total;\r\n}\r\nunsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(filp, &file_priv->event_wait, wait);\r\nif (!list_empty(&file_priv->event_list))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}
