STATIC struct posix_acl *\r\nxfs_acl_from_disk(struct xfs_acl *aclp)\r\n{\r\nstruct posix_acl_entry *acl_e;\r\nstruct posix_acl *acl;\r\nstruct xfs_acl_entry *ace;\r\nunsigned int count, i;\r\ncount = be32_to_cpu(aclp->acl_cnt);\r\nif (count > XFS_ACL_MAX_ENTRIES)\r\nreturn ERR_PTR(-EFSCORRUPTED);\r\nacl = posix_acl_alloc(count, GFP_KERNEL);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < count; i++) {\r\nacl_e = &acl->a_entries[i];\r\nace = &aclp->acl_entry[i];\r\nacl_e->e_tag = be32_to_cpu(ace->ae_tag);\r\nacl_e->e_perm = be16_to_cpu(ace->ae_perm);\r\nswitch (acl_e->e_tag) {\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nacl_e->e_id = be32_to_cpu(ace->ae_id);\r\nbreak;\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\nacl_e->e_id = ACL_UNDEFINED_ID;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nreturn acl;\r\nfail:\r\nposix_acl_release(acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nSTATIC void\r\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\r\n{\r\nconst struct posix_acl_entry *acl_e;\r\nstruct xfs_acl_entry *ace;\r\nint i;\r\naclp->acl_cnt = cpu_to_be32(acl->a_count);\r\nfor (i = 0; i < acl->a_count; i++) {\r\nace = &aclp->acl_entry[i];\r\nacl_e = &acl->a_entries[i];\r\nace->ae_tag = cpu_to_be32(acl_e->e_tag);\r\nace->ae_id = cpu_to_be32(acl_e->e_id);\r\nace->ae_perm = cpu_to_be16(acl_e->e_perm);\r\n}\r\n}\r\nstruct posix_acl *\r\nxfs_get_acl(struct inode *inode, int type)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct posix_acl *acl;\r\nstruct xfs_acl *xfs_acl;\r\nint len = sizeof(struct xfs_acl);\r\nunsigned char *ea_name;\r\nint error;\r\nacl = get_cached_acl(inode, type);\r\nif (acl != ACL_NOT_CACHED)\r\nreturn acl;\r\ntrace_xfs_get_acl(ip);\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nea_name = SGI_ACL_FILE;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nea_name = SGI_ACL_DEFAULT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nxfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\r\nif (!xfs_acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nerror = -xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\r\n&len, ATTR_ROOT);\r\nif (error) {\r\nif (error == -ENOATTR) {\r\nacl = NULL;\r\ngoto out_update_cache;\r\n}\r\ngoto out;\r\n}\r\nacl = xfs_acl_from_disk(xfs_acl);\r\nif (IS_ERR(acl))\r\ngoto out;\r\nout_update_cache:\r\nset_cached_acl(inode, type, acl);\r\nout:\r\nkfree(xfs_acl);\r\nreturn acl;\r\n}\r\nSTATIC int\r\nxfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nunsigned char *ea_name;\r\nint error;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nea_name = SGI_ACL_FILE;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn acl ? -EACCES : 0;\r\nea_name = SGI_ACL_DEFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (acl) {\r\nstruct xfs_acl *xfs_acl;\r\nint len;\r\nxfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\r\nif (!xfs_acl)\r\nreturn -ENOMEM;\r\nxfs_acl_to_disk(xfs_acl, acl);\r\nlen = sizeof(struct xfs_acl) -\r\n(sizeof(struct xfs_acl_entry) *\r\n(XFS_ACL_MAX_ENTRIES - acl->a_count));\r\nerror = -xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\r\nlen, ATTR_ROOT);\r\nkfree(xfs_acl);\r\n} else {\r\nerror = -xfs_attr_remove(ip, ea_name, ATTR_ROOT);\r\nif (error == -ENOATTR)\r\nerror = 0;\r\n}\r\nif (!error)\r\nset_cached_acl(inode, type, acl);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_set_mode(struct inode *inode, umode_t mode)\r\n{\r\nint error = 0;\r\nif (mode != inode->i_mode) {\r\nstruct iattr iattr;\r\niattr.ia_valid = ATTR_MODE | ATTR_CTIME;\r\niattr.ia_mode = mode;\r\niattr.ia_ctime = current_fs_time(inode->i_sb);\r\nerror = -xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\r\n}\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_acl_exists(struct inode *inode, unsigned char *name)\r\n{\r\nint len = sizeof(struct xfs_acl);\r\nreturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\r\nATTR_ROOT|ATTR_KERNOVAL) == 0);\r\n}\r\nint\r\nposix_acl_access_exists(struct inode *inode)\r\n{\r\nreturn xfs_acl_exists(inode, SGI_ACL_FILE);\r\n}\r\nint\r\nposix_acl_default_exists(struct inode *inode)\r\n{\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn 0;\r\nreturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\r\n}\r\nint\r\nxfs_inherit_acl(struct inode *inode, struct posix_acl *acl)\r\n{\r\numode_t mode = inode->i_mode;\r\nint error = 0, inherit = 0;\r\nif (S_ISDIR(inode->i_mode)) {\r\nerror = xfs_set_acl(inode, ACL_TYPE_DEFAULT, acl);\r\nif (error)\r\ngoto out;\r\n}\r\nerror = posix_acl_create(&acl, GFP_KERNEL, &mode);\r\nif (error < 0)\r\nreturn error;\r\nif (error > 0)\r\ninherit = 1;\r\nerror = xfs_set_mode(inode, mode);\r\nif (error)\r\ngoto out;\r\nif (inherit)\r\nerror = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);\r\nout:\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nint\r\nxfs_acl_chmod(struct inode *inode)\r\n{\r\nstruct posix_acl *acl;\r\nint error;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nacl = xfs_get_acl(inode, ACL_TYPE_ACCESS);\r\nif (IS_ERR(acl) || !acl)\r\nreturn PTR_ERR(acl);\r\nerror = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\r\nif (error)\r\nreturn error;\r\nerror = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_xattr_acl_get(struct dentry *dentry, const char *name,\r\nvoid *value, size_t size, int type)\r\n{\r\nstruct posix_acl *acl;\r\nint error;\r\nacl = xfs_get_acl(dentry->d_inode, type);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (acl == NULL)\r\nreturn -ENODATA;\r\nerror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_xattr_acl_set(struct dentry *dentry, const char *name,\r\nconst void *value, size_t size, int flags, int type)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct posix_acl *acl = NULL;\r\nint error = 0;\r\nif (flags & XATTR_CREATE)\r\nreturn -EINVAL;\r\nif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\r\nreturn value ? -EACCES : 0;\r\nif ((current_fsuid() != inode->i_uid) && !capable(CAP_FOWNER))\r\nreturn -EPERM;\r\nif (!value)\r\ngoto set_acl;\r\nacl = posix_acl_from_xattr(&init_user_ns, value, size);\r\nif (!acl) {\r\ngoto out;\r\n}\r\nif (IS_ERR(acl)) {\r\nerror = PTR_ERR(acl);\r\ngoto out;\r\n}\r\nerror = posix_acl_valid(acl);\r\nif (error)\r\ngoto out_release;\r\nerror = -EINVAL;\r\nif (acl->a_count > XFS_ACL_MAX_ENTRIES)\r\ngoto out_release;\r\nif (type == ACL_TYPE_ACCESS) {\r\numode_t mode = inode->i_mode;\r\nerror = posix_acl_equiv_mode(acl, &mode);\r\nif (error <= 0) {\r\nposix_acl_release(acl);\r\nacl = NULL;\r\nif (error < 0)\r\nreturn error;\r\n}\r\nerror = xfs_set_mode(inode, mode);\r\nif (error)\r\ngoto out_release;\r\n}\r\nset_acl:\r\nerror = xfs_set_acl(inode, type, acl);\r\nout_release:\r\nposix_acl_release(acl);\r\nout:\r\nreturn error;\r\n}
