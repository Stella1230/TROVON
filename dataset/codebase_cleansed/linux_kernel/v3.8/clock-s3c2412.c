static int s3c2412_clkcon_enable(struct clk *clk, int enable)\r\n{\r\nunsigned int clocks = clk->ctrlbit;\r\nunsigned long clkcon;\r\nclkcon = __raw_readl(S3C2410_CLKCON);\r\nif (enable)\r\nclkcon |= clocks;\r\nelse\r\nclkcon &= ~clocks;\r\n__raw_writel(clkcon, S3C2410_CLKCON);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_upll_enable(struct clk *clk, int enable)\r\n{\r\nunsigned long upllcon = __raw_readl(S3C2410_UPLLCON);\r\nunsigned long orig = upllcon;\r\nif (!enable)\r\nupllcon |= S3C2412_PLLCON_OFF;\r\nelse\r\nupllcon &= ~S3C2412_PLLCON_OFF;\r\n__raw_writel(upllcon, S3C2410_UPLLCON);\r\nif (enable && (orig & S3C2412_PLLCON_OFF))\r\nudelay(150);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_setparent_usysclk(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nif (parent == &clk_urefclk)\r\nclksrc &= ~S3C2412_CLKSRC_USYSCLK_UPLL;\r\nelse if (parent == &clk_upll)\r\nclksrc |= S3C2412_CLKSRC_USYSCLK_UPLL;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\n__raw_writel(clksrc, S3C2412_CLKSRC);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_setparent_usbsrc(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nif (parent == &clk_usysclk)\r\nclksrc &= ~S3C2412_CLKSRC_USBCLK_HCLK;\r\nelse if (parent == &clk_h)\r\nclksrc |= S3C2412_CLKSRC_USBCLK_HCLK;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\n__raw_writel(clksrc, S3C2412_CLKSRC);\r\nreturn 0;\r\n}\r\nstatic unsigned long s3c2412_roundrate_usbsrc(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nint div;\r\nif (rate > parent_rate)\r\nreturn parent_rate;\r\ndiv = parent_rate / rate;\r\nif (div > 2)\r\ndiv = 2;\r\nreturn parent_rate / div;\r\n}\r\nstatic unsigned long s3c2412_getrate_usbsrc(struct clk *clk)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long div = __raw_readl(S3C2410_CLKDIVN);\r\nreturn parent_rate / ((div & S3C2412_CLKDIVN_USB48DIV) ? 2 : 1);\r\n}\r\nstatic int s3c2412_setrate_usbsrc(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long clkdivn = __raw_readl(S3C2410_CLKDIVN);\r\nrate = s3c2412_roundrate_usbsrc(clk, rate);\r\nif ((parent_rate / rate) == 2)\r\nclkdivn |= S3C2412_CLKDIVN_USB48DIV;\r\nelse\r\nclkdivn &= ~S3C2412_CLKDIVN_USB48DIV;\r\n__raw_writel(clkdivn, S3C2410_CLKDIVN);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_setparent_msysclk(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nif (parent == &clk_mdivclk)\r\nclksrc &= ~S3C2412_CLKSRC_MSYSCLK_MPLL;\r\nelse if (parent == &clk_mpll)\r\nclksrc |= S3C2412_CLKSRC_MSYSCLK_MPLL;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\n__raw_writel(clksrc, S3C2412_CLKSRC);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_setparent_armclk(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long flags;\r\nunsigned long clkdiv;\r\nunsigned long dvs;\r\nif (parent == &clk_msysclk || parent == &clk_f)\r\ndvs = 0;\r\nelse if (parent == &clk_h)\r\ndvs = S3C2412_CLKDIVN_DVSEN;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\nlocal_irq_save(flags);\r\nclkdiv = __raw_readl(S3C2410_CLKDIVN);\r\nclkdiv &= ~S3C2412_CLKDIVN_DVSEN;\r\nclkdiv |= dvs;\r\n__raw_writel(clkdiv, S3C2410_CLKDIVN);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic unsigned long s3c2412_roundrate_clksrc(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nint div;\r\nif (rate > parent_rate)\r\nreturn parent_rate;\r\ndiv = (rate / parent_rate);\r\nif (div < 1)\r\ndiv = 1;\r\nelse if (div > 16)\r\ndiv = 16;\r\nreturn parent_rate / div;\r\n}\r\nstatic int s3c2412_setparent_uart(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nif (parent == &clk_erefclk)\r\nclksrc &= ~S3C2412_CLKSRC_UARTCLK_MPLL;\r\nelse if (parent == &clk_mpll)\r\nclksrc |= S3C2412_CLKSRC_UARTCLK_MPLL;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\n__raw_writel(clksrc, S3C2412_CLKSRC);\r\nreturn 0;\r\n}\r\nstatic unsigned long s3c2412_getrate_uart(struct clk *clk)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long div = __raw_readl(S3C2410_CLKDIVN);\r\ndiv &= S3C2412_CLKDIVN_UARTDIV_MASK;\r\ndiv >>= S3C2412_CLKDIVN_UARTDIV_SHIFT;\r\nreturn parent_rate / (div + 1);\r\n}\r\nstatic int s3c2412_setrate_uart(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long clkdivn = __raw_readl(S3C2410_CLKDIVN);\r\nrate = s3c2412_roundrate_clksrc(clk, rate);\r\nclkdivn &= ~S3C2412_CLKDIVN_UARTDIV_MASK;\r\nclkdivn |= ((parent_rate / rate) - 1) << S3C2412_CLKDIVN_UARTDIV_SHIFT;\r\n__raw_writel(clkdivn, S3C2410_CLKDIVN);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_setparent_i2s(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nif (parent == &clk_erefclk)\r\nclksrc &= ~S3C2412_CLKSRC_I2SCLK_MPLL;\r\nelse if (parent == &clk_mpll)\r\nclksrc |= S3C2412_CLKSRC_I2SCLK_MPLL;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\n__raw_writel(clksrc, S3C2412_CLKSRC);\r\nreturn 0;\r\n}\r\nstatic unsigned long s3c2412_getrate_i2s(struct clk *clk)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long div = __raw_readl(S3C2410_CLKDIVN);\r\ndiv &= S3C2412_CLKDIVN_I2SDIV_MASK;\r\ndiv >>= S3C2412_CLKDIVN_I2SDIV_SHIFT;\r\nreturn parent_rate / (div + 1);\r\n}\r\nstatic int s3c2412_setrate_i2s(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long clkdivn = __raw_readl(S3C2410_CLKDIVN);\r\nrate = s3c2412_roundrate_clksrc(clk, rate);\r\nclkdivn &= ~S3C2412_CLKDIVN_I2SDIV_MASK;\r\nclkdivn |= ((parent_rate / rate) - 1) << S3C2412_CLKDIVN_I2SDIV_SHIFT;\r\n__raw_writel(clkdivn, S3C2410_CLKDIVN);\r\nreturn 0;\r\n}\r\nstatic int s3c2412_setparent_cam(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nif (parent == &clk_usysclk)\r\nclksrc &= ~S3C2412_CLKSRC_CAMCLK_HCLK;\r\nelse if (parent == &clk_h)\r\nclksrc |= S3C2412_CLKSRC_CAMCLK_HCLK;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\n__raw_writel(clksrc, S3C2412_CLKSRC);\r\nreturn 0;\r\n}\r\nstatic unsigned long s3c2412_getrate_cam(struct clk *clk)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long div = __raw_readl(S3C2410_CLKDIVN);\r\ndiv &= S3C2412_CLKDIVN_CAMDIV_MASK;\r\ndiv >>= S3C2412_CLKDIVN_CAMDIV_SHIFT;\r\nreturn parent_rate / (div + 1);\r\n}\r\nstatic int s3c2412_setrate_cam(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long clkdivn = __raw_readl(S3C2410_CLKDIVN);\r\nrate = s3c2412_roundrate_clksrc(clk, rate);\r\nclkdivn &= ~S3C2412_CLKDIVN_CAMDIV_MASK;\r\nclkdivn |= ((parent_rate / rate) - 1) << S3C2412_CLKDIVN_CAMDIV_SHIFT;\r\n__raw_writel(clkdivn, S3C2410_CLKDIVN);\r\nreturn 0;\r\n}\r\nstatic void __init s3c2412_clk_initparents(void)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2412_CLKSRC);\r\nstruct clk_init *cip = clks_src;\r\nstruct clk *src;\r\nint ptr;\r\nint ret;\r\nfor (ptr = 0; ptr < ARRAY_SIZE(clks_src); ptr++, cip++) {\r\nret = s3c24xx_register_clock(cip->clk);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Failed to register clock %s (%d)\n",\r\ncip->clk->name, ret);\r\n}\r\nsrc = (clksrc & cip->bit) ? cip->src_1 : cip->src_0;\r\nprintk(KERN_INFO "%s: parent %s\n", cip->clk->name, src->name);\r\nclk_set_parent(cip->clk, src);\r\n}\r\n}\r\nint __init s3c2412_baseclk_add(void)\r\n{\r\nunsigned long clkcon = __raw_readl(S3C2410_CLKCON);\r\nunsigned int dvs;\r\nstruct clk *clkp;\r\nint ret;\r\nint ptr;\r\nclk_upll.enable = s3c2412_upll_enable;\r\nclk_usb_bus.parent = &clk_usbsrc;\r\nclk_usb_bus.rate = 0x0;\r\nclk_f.parent = &clk_msysclk;\r\ns3c2412_clk_initparents();\r\nfor (ptr = 0; ptr < ARRAY_SIZE(clks); ptr++) {\r\nclkp = clks[ptr];\r\nret = s3c24xx_register_clock(clkp);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Failed to register clock %s (%d)\n",\r\nclkp->name, ret);\r\n}\r\n}\r\ndvs = __raw_readl(S3C2410_CLKDIVN) & S3C2412_CLKDIVN_DVSEN;\r\nif (dvs)\r\nclk_armclk.parent = &clk_h;\r\nprintk(KERN_INFO "S3C2412: DVS is %s\n", dvs ? "on" : "off");\r\nif (clk_get_rate(&clk_usb_bus) != (48 * 1000 * 1000)) {\r\nprintk(KERN_INFO "Warning: USB bus clock not at 48MHz\n");\r\nclk_set_parent(&clk_usysclk, &clk_upll);\r\nclk_set_parent(&clk_usbsrc, &clk_usysclk);\r\nclk_set_rate(&clk_usbsrc, 48*1000*1000);\r\n}\r\nprintk("S3C2412: upll %s, %ld.%03ld MHz, usb-bus %ld.%03ld MHz\n",\r\n(__raw_readl(S3C2410_UPLLCON) & S3C2412_PLLCON_OFF) ? "off":"on",\r\nprint_mhz(clk_get_rate(&clk_upll)),\r\nprint_mhz(clk_get_rate(&clk_usb_bus)));\r\nclkp = init_clocks;\r\nfor (ptr = 0; ptr < ARRAY_SIZE(init_clocks); ptr++, clkp++) {\r\nclkp->usage = clkcon & clkp->ctrlbit ? 1 : 0;\r\nret = s3c24xx_register_clock(clkp);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Failed to register clock %s (%d)\n",\r\nclkp->name, ret);\r\n}\r\n}\r\nclkp = init_clocks_disable;\r\nfor (ptr = 0; ptr < ARRAY_SIZE(init_clocks_disable); ptr++, clkp++) {\r\nret = s3c24xx_register_clock(clkp);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Failed to register clock %s (%d)\n",\r\nclkp->name, ret);\r\n}\r\ns3c2412_clkcon_enable(clkp, 0);\r\n}\r\nclkdev_add_table(s3c2412_clk_lookup, ARRAY_SIZE(s3c2412_clk_lookup));\r\ns3c_pwmclk_init();\r\nreturn 0;\r\n}
