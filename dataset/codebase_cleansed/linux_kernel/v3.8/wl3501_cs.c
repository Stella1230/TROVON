static int iw_valid_channel(int reg_domain, int channel)\r\n{\r\nint i, rc = 0;\r\nfor (i = 0; i < ARRAY_SIZE(iw_channel_table); i++)\r\nif (reg_domain == iw_channel_table[i].reg_domain) {\r\nrc = channel >= iw_channel_table[i].min &&\r\nchannel <= iw_channel_table[i].max;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int iw_default_channel(int reg_domain)\r\n{\r\nint i, rc = 1;\r\nfor (i = 0; i < ARRAY_SIZE(iw_channel_table); i++)\r\nif (reg_domain == iw_channel_table[i].reg_domain) {\r\nrc = iw_channel_table[i].deflt;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void iw_set_mgmt_info_element(enum iw_mgmt_info_element_ids id,\r\nstruct iw_mgmt_info_element *el,\r\nvoid *value, int len)\r\n{\r\nel->id = id;\r\nel->len = len;\r\nmemcpy(el->data, value, len);\r\n}\r\nstatic void iw_copy_mgmt_info_element(struct iw_mgmt_info_element *to,\r\nstruct iw_mgmt_info_element *from)\r\n{\r\niw_set_mgmt_info_element(from->id, to, from->data, from->len);\r\n}\r\nstatic inline void wl3501_switch_page(struct wl3501_card *this, u8 page)\r\n{\r\nwl3501_outb(page, this->base_addr + WL3501_NIC_BSS);\r\n}\r\nstatic int wl3501_get_flash_mac_addr(struct wl3501_card *this)\r\n{\r\nint base_addr = this->base_addr;\r\nwl3501_outb(WL3501_BSS_FPAGE3, base_addr + WL3501_NIC_BSS);\r\nwl3501_outb(0x00, base_addr + WL3501_NIC_LMAL);\r\nwl3501_outb(0x40, base_addr + WL3501_NIC_LMAH);\r\nWL3501_NOPLOOP(100);\r\nthis->mac_addr[0] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->mac_addr[1] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->mac_addr[2] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->mac_addr[3] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->mac_addr[4] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->mac_addr[5] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->reg_domain = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nwl3501_outb(WL3501_BSS_FPAGE0, base_addr + WL3501_NIC_BSS);\r\nwl3501_outb(0x04, base_addr + WL3501_NIC_LMAL);\r\nwl3501_outb(0x40, base_addr + WL3501_NIC_LMAH);\r\nWL3501_NOPLOOP(100);\r\nthis->version[0] = inb(base_addr + WL3501_NIC_IODPA);\r\nWL3501_NOPLOOP(100);\r\nthis->version[1] = inb(base_addr + WL3501_NIC_IODPA);\r\nwl3501_switch_page(this, WL3501_BSS_SPAGE0);\r\nreturn this->mac_addr[0] == 0x00 && this->mac_addr[1] == 0x60;\r\n}\r\nstatic void wl3501_set_to_wla(struct wl3501_card *this, u16 dest, void *src,\r\nint size)\r\n{\r\nwl3501_switch_page(this, (dest & 0x8000) ? WL3501_BSS_SPAGE1 :\r\nWL3501_BSS_SPAGE0);\r\nwl3501_outb(dest & 0xff, this->base_addr + WL3501_NIC_LMAL);\r\nwl3501_outb(((dest >> 8) & 0x7f), this->base_addr + WL3501_NIC_LMAH);\r\nwl3501_outsb(this->base_addr + WL3501_NIC_IODPA, src, size);\r\n}\r\nstatic void wl3501_get_from_wla(struct wl3501_card *this, u16 src, void *dest,\r\nint size)\r\n{\r\nwl3501_switch_page(this, (src & 0x8000) ? WL3501_BSS_SPAGE1 :\r\nWL3501_BSS_SPAGE0);\r\nwl3501_outb(src & 0xff, this->base_addr + WL3501_NIC_LMAL);\r\nwl3501_outb((src >> 8) & 0x7f, this->base_addr + WL3501_NIC_LMAH);\r\ninsb(this->base_addr + WL3501_NIC_IODPA, dest, size);\r\n}\r\nstatic u16 wl3501_get_tx_buffer(struct wl3501_card *this, u16 len)\r\n{\r\nu16 next, blk_cnt = 0, zero = 0;\r\nu16 full_len = sizeof(struct wl3501_80211_tx_hdr) + len;\r\nu16 ret = 0;\r\nif (full_len > this->tx_buffer_cnt * 254)\r\ngoto out;\r\nret = this->tx_buffer_head;\r\nwhile (full_len) {\r\nif (full_len < 254)\r\nfull_len = 0;\r\nelse\r\nfull_len -= 254;\r\nwl3501_get_from_wla(this, this->tx_buffer_head, &next,\r\nsizeof(next));\r\nif (!full_len)\r\nwl3501_set_to_wla(this, this->tx_buffer_head, &zero,\r\nsizeof(zero));\r\nthis->tx_buffer_head = next;\r\nblk_cnt++;\r\nif (!next && full_len) {\r\nthis->tx_buffer_head = ret;\r\nret = 0;\r\ngoto out;\r\n}\r\n}\r\nthis->tx_buffer_cnt -= blk_cnt;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void wl3501_free_tx_buffer(struct wl3501_card *this, u16 ptr)\r\n{\r\nif (!this->tx_buffer_head)\r\nthis->tx_buffer_head = ptr;\r\nelse\r\nwl3501_set_to_wla(this, this->tx_buffer_tail,\r\n&ptr, sizeof(ptr));\r\nwhile (ptr) {\r\nu16 next;\r\nthis->tx_buffer_cnt++;\r\nwl3501_get_from_wla(this, ptr, &next, sizeof(next));\r\nthis->tx_buffer_tail = ptr;\r\nptr = next;\r\n}\r\n}\r\nstatic int wl3501_esbq_req_test(struct wl3501_card *this)\r\n{\r\nu8 tmp = 0;\r\nwl3501_get_from_wla(this, this->esbq_req_head + 3, &tmp, sizeof(tmp));\r\nreturn tmp & 0x80;\r\n}\r\nstatic void wl3501_esbq_req(struct wl3501_card *this, u16 *ptr)\r\n{\r\nu16 tmp = 0;\r\nwl3501_set_to_wla(this, this->esbq_req_head, ptr, 2);\r\nwl3501_set_to_wla(this, this->esbq_req_head + 2, &tmp, sizeof(tmp));\r\nthis->esbq_req_head += 4;\r\nif (this->esbq_req_head >= this->esbq_req_end)\r\nthis->esbq_req_head = this->esbq_req_start;\r\n}\r\nstatic int wl3501_esbq_exec(struct wl3501_card *this, void *sig, int sig_size)\r\n{\r\nint rc = -EIO;\r\nif (wl3501_esbq_req_test(this)) {\r\nu16 ptr = wl3501_get_tx_buffer(this, sig_size);\r\nif (ptr) {\r\nwl3501_set_to_wla(this, ptr, sig, sig_size);\r\nwl3501_esbq_req(this, &ptr);\r\nrc = 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_mib_value(struct wl3501_card *this, u8 index,\r\nvoid *bf, int size)\r\n{\r\nstruct wl3501_get_req sig = {\r\n.sig_id = WL3501_SIG_GET_REQ,\r\n.mib_attrib = index,\r\n};\r\nunsigned long flags;\r\nint rc = -EIO;\r\nspin_lock_irqsave(&this->lock, flags);\r\nif (wl3501_esbq_req_test(this)) {\r\nu16 ptr = wl3501_get_tx_buffer(this, sizeof(sig));\r\nif (ptr) {\r\nwl3501_set_to_wla(this, ptr, &sig, sizeof(sig));\r\nwl3501_esbq_req(this, &ptr);\r\nthis->sig_get_confirm.mib_status = 255;\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nrc = wait_event_interruptible(this->wait,\r\nthis->sig_get_confirm.mib_status != 255);\r\nif (!rc)\r\nmemcpy(bf, this->sig_get_confirm.mib_value,\r\nsize);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_pwr_mgmt(struct wl3501_card *this, int suspend)\r\n{\r\nstruct wl3501_pwr_mgmt_req sig = {\r\n.sig_id = WL3501_SIG_PWR_MGMT_REQ,\r\n.pwr_save = suspend,\r\n.wake_up = !suspend,\r\n.receive_dtims = 10,\r\n};\r\nunsigned long flags;\r\nint rc = -EIO;\r\nspin_lock_irqsave(&this->lock, flags);\r\nif (wl3501_esbq_req_test(this)) {\r\nu16 ptr = wl3501_get_tx_buffer(this, sizeof(sig));\r\nif (ptr) {\r\nwl3501_set_to_wla(this, ptr, &sig, sizeof(sig));\r\nwl3501_esbq_req(this, &ptr);\r\nthis->sig_pwr_mgmt_confirm.status = 255;\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nrc = wait_event_interruptible(this->wait,\r\nthis->sig_pwr_mgmt_confirm.status != 255);\r\nprintk(KERN_INFO "%s: %s status=%d\n", __func__,\r\nsuspend ? "suspend" : "resume",\r\nthis->sig_pwr_mgmt_confirm.status);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_send_pkt(struct wl3501_card *this, u8 *data, u16 len)\r\n{\r\nu16 bf, sig_bf, next, tmplen, pktlen;\r\nstruct wl3501_md_req sig = {\r\n.sig_id = WL3501_SIG_MD_REQ,\r\n};\r\nu8 *pdata = (char *)data;\r\nint rc = -EIO;\r\nif (wl3501_esbq_req_test(this)) {\r\nsig_bf = wl3501_get_tx_buffer(this, sizeof(sig));\r\nrc = -ENOMEM;\r\nif (!sig_bf)\r\ngoto out;\r\nbf = wl3501_get_tx_buffer(this, len + 26 + 24);\r\nif (!bf) {\r\nwl3501_free_tx_buffer(this, sig_bf);\r\ngoto out;\r\n}\r\nrc = 0;\r\nmemcpy(&sig.daddr[0], pdata, 12);\r\npktlen = len - 12;\r\npdata += 12;\r\nsig.data = bf;\r\nif (((*pdata) * 256 + (*(pdata + 1))) > 1500) {\r\nu8 addr4[ETH_ALEN] = {\r\n[0] = 0xAA, [1] = 0xAA, [2] = 0x03, [4] = 0x00,\r\n};\r\nwl3501_set_to_wla(this, bf + 2 +\r\noffsetof(struct wl3501_tx_hdr, addr4),\r\naddr4, sizeof(addr4));\r\nsig.size = pktlen + 24 + 4 + 6;\r\nif (pktlen > (254 - sizeof(struct wl3501_tx_hdr))) {\r\ntmplen = 254 - sizeof(struct wl3501_tx_hdr);\r\npktlen -= tmplen;\r\n} else {\r\ntmplen = pktlen;\r\npktlen = 0;\r\n}\r\nwl3501_set_to_wla(this,\r\nbf + 2 + sizeof(struct wl3501_tx_hdr),\r\npdata, tmplen);\r\npdata += tmplen;\r\nwl3501_get_from_wla(this, bf, &next, sizeof(next));\r\nbf = next;\r\n} else {\r\nsig.size = pktlen + 24 + 4 - 2;\r\npdata += 2;\r\npktlen -= 2;\r\nif (pktlen > (254 - sizeof(struct wl3501_tx_hdr) + 6)) {\r\ntmplen = 254 - sizeof(struct wl3501_tx_hdr) + 6;\r\npktlen -= tmplen;\r\n} else {\r\ntmplen = pktlen;\r\npktlen = 0;\r\n}\r\nwl3501_set_to_wla(this, bf + 2 +\r\noffsetof(struct wl3501_tx_hdr, addr4),\r\npdata, tmplen);\r\npdata += tmplen;\r\nwl3501_get_from_wla(this, bf, &next, sizeof(next));\r\nbf = next;\r\n}\r\nwhile (pktlen > 0) {\r\nif (pktlen > 254) {\r\ntmplen = 254;\r\npktlen -= 254;\r\n} else {\r\ntmplen = pktlen;\r\npktlen = 0;\r\n}\r\nwl3501_set_to_wla(this, bf + 2, pdata, tmplen);\r\npdata += tmplen;\r\nwl3501_get_from_wla(this, bf, &next, sizeof(next));\r\nbf = next;\r\n}\r\nwl3501_set_to_wla(this, sig_bf, &sig, sizeof(sig));\r\nwl3501_esbq_req(this, &sig_bf);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_mgmt_resync(struct wl3501_card *this)\r\n{\r\nstruct wl3501_resync_req sig = {\r\n.sig_id = WL3501_SIG_RESYNC_REQ,\r\n};\r\nreturn wl3501_esbq_exec(this, &sig, sizeof(sig));\r\n}\r\nstatic inline int wl3501_fw_bss_type(struct wl3501_card *this)\r\n{\r\nreturn this->net_type == IW_MODE_INFRA ? WL3501_NET_TYPE_INFRA :\r\nWL3501_NET_TYPE_ADHOC;\r\n}\r\nstatic inline int wl3501_fw_cap_info(struct wl3501_card *this)\r\n{\r\nreturn this->net_type == IW_MODE_INFRA ? WL3501_MGMT_CAPABILITY_ESS :\r\nWL3501_MGMT_CAPABILITY_IBSS;\r\n}\r\nstatic int wl3501_mgmt_scan(struct wl3501_card *this, u16 chan_time)\r\n{\r\nstruct wl3501_scan_req sig = {\r\n.sig_id = WL3501_SIG_SCAN_REQ,\r\n.scan_type = WL3501_SCAN_TYPE_ACTIVE,\r\n.probe_delay = 0x10,\r\n.min_chan_time = chan_time,\r\n.max_chan_time = chan_time,\r\n.bss_type = wl3501_fw_bss_type(this),\r\n};\r\nthis->bss_cnt = this->join_sta_bss = 0;\r\nreturn wl3501_esbq_exec(this, &sig, sizeof(sig));\r\n}\r\nstatic int wl3501_mgmt_join(struct wl3501_card *this, u16 stas)\r\n{\r\nstruct wl3501_join_req sig = {\r\n.sig_id = WL3501_SIG_JOIN_REQ,\r\n.timeout = 10,\r\n.ds_pset = {\r\n.el = {\r\n.id = IW_MGMT_INFO_ELEMENT_DS_PARAMETER_SET,\r\n.len = 1,\r\n},\r\n.chan = this->chan,\r\n},\r\n};\r\nmemcpy(&sig.beacon_period, &this->bss_set[stas].beacon_period, 72);\r\nreturn wl3501_esbq_exec(this, &sig, sizeof(sig));\r\n}\r\nstatic int wl3501_mgmt_start(struct wl3501_card *this)\r\n{\r\nstruct wl3501_start_req sig = {\r\n.sig_id = WL3501_SIG_START_REQ,\r\n.beacon_period = 400,\r\n.dtim_period = 1,\r\n.ds_pset = {\r\n.el = {\r\n.id = IW_MGMT_INFO_ELEMENT_DS_PARAMETER_SET,\r\n.len = 1,\r\n},\r\n.chan = this->chan,\r\n},\r\n.bss_basic_rset = {\r\n.el = {\r\n.id = IW_MGMT_INFO_ELEMENT_SUPPORTED_RATES,\r\n.len = 2,\r\n},\r\n.data_rate_labels = {\r\n[0] = IW_MGMT_RATE_LABEL_MANDATORY |\r\nIW_MGMT_RATE_LABEL_1MBIT,\r\n[1] = IW_MGMT_RATE_LABEL_MANDATORY |\r\nIW_MGMT_RATE_LABEL_2MBIT,\r\n},\r\n},\r\n.operational_rset = {\r\n.el = {\r\n.id = IW_MGMT_INFO_ELEMENT_SUPPORTED_RATES,\r\n.len = 2,\r\n},\r\n.data_rate_labels = {\r\n[0] = IW_MGMT_RATE_LABEL_MANDATORY |\r\nIW_MGMT_RATE_LABEL_1MBIT,\r\n[1] = IW_MGMT_RATE_LABEL_MANDATORY |\r\nIW_MGMT_RATE_LABEL_2MBIT,\r\n},\r\n},\r\n.ibss_pset = {\r\n.el = {\r\n.id = IW_MGMT_INFO_ELEMENT_IBSS_PARAMETER_SET,\r\n.len = 2,\r\n},\r\n.atim_window = 10,\r\n},\r\n.bss_type = wl3501_fw_bss_type(this),\r\n.cap_info = wl3501_fw_cap_info(this),\r\n};\r\niw_copy_mgmt_info_element(&sig.ssid.el, &this->essid.el);\r\niw_copy_mgmt_info_element(&this->keep_essid.el, &this->essid.el);\r\nreturn wl3501_esbq_exec(this, &sig, sizeof(sig));\r\n}\r\nstatic void wl3501_mgmt_scan_confirm(struct wl3501_card *this, u16 addr)\r\n{\r\nu16 i = 0;\r\nint matchflag = 0;\r\nstruct wl3501_scan_confirm sig;\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nif (sig.status == WL3501_STATUS_SUCCESS) {\r\npr_debug("success");\r\nif ((this->net_type == IW_MODE_INFRA &&\r\n(sig.cap_info & WL3501_MGMT_CAPABILITY_ESS)) ||\r\n(this->net_type == IW_MODE_ADHOC &&\r\n(sig.cap_info & WL3501_MGMT_CAPABILITY_IBSS)) ||\r\nthis->net_type == IW_MODE_AUTO) {\r\nif (!this->essid.el.len)\r\nmatchflag = 1;\r\nelse if (this->essid.el.len == 3 &&\r\n!memcmp(this->essid.essid, "ANY", 3))\r\nmatchflag = 1;\r\nelse if (this->essid.el.len != sig.ssid.el.len)\r\nmatchflag = 0;\r\nelse if (memcmp(this->essid.essid, sig.ssid.essid,\r\nthis->essid.el.len))\r\nmatchflag = 0;\r\nelse\r\nmatchflag = 1;\r\nif (matchflag) {\r\nfor (i = 0; i < this->bss_cnt; i++) {\r\nif (!memcmp(this->bss_set[i].bssid,\r\nsig.bssid, ETH_ALEN)) {\r\nmatchflag = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (matchflag && (i < 20)) {\r\nmemcpy(&this->bss_set[i].beacon_period,\r\n&sig.beacon_period, 73);\r\nthis->bss_cnt++;\r\nthis->rssi = sig.rssi;\r\n}\r\n}\r\n} else if (sig.status == WL3501_STATUS_TIMEOUT) {\r\npr_debug("timeout");\r\nthis->join_sta_bss = 0;\r\nfor (i = this->join_sta_bss; i < this->bss_cnt; i++)\r\nif (!wl3501_mgmt_join(this, i))\r\nbreak;\r\nthis->join_sta_bss = i;\r\nif (this->join_sta_bss == this->bss_cnt) {\r\nif (this->net_type == IW_MODE_INFRA)\r\nwl3501_mgmt_scan(this, 100);\r\nelse {\r\nthis->adhoc_times++;\r\nif (this->adhoc_times > WL3501_MAX_ADHOC_TRIES)\r\nwl3501_mgmt_start(this);\r\nelse\r\nwl3501_mgmt_scan(this, 100);\r\n}\r\n}\r\n}\r\n}\r\nstatic int wl3501_block_interrupt(struct wl3501_card *this)\r\n{\r\nu8 old = inb(this->base_addr + WL3501_NIC_GCR);\r\nu8 new = old & (~(WL3501_GCR_ECINT | WL3501_GCR_INT2EC |\r\nWL3501_GCR_ENECINT));\r\nwl3501_outb(new, this->base_addr + WL3501_NIC_GCR);\r\nreturn old & WL3501_GCR_ENECINT;\r\n}\r\nstatic int wl3501_unblock_interrupt(struct wl3501_card *this)\r\n{\r\nu8 old = inb(this->base_addr + WL3501_NIC_GCR);\r\nu8 new = (old & ~(WL3501_GCR_ECINT | WL3501_GCR_INT2EC)) |\r\nWL3501_GCR_ENECINT;\r\nwl3501_outb(new, this->base_addr + WL3501_NIC_GCR);\r\nreturn old & WL3501_GCR_ENECINT;\r\n}\r\nstatic u16 wl3501_receive(struct wl3501_card *this, u8 *bf, u16 size)\r\n{\r\nu16 next_addr, next_addr1;\r\nu8 *data = bf + 12;\r\nsize -= 12;\r\nwl3501_get_from_wla(this, this->start_seg + 2,\r\n&next_addr, sizeof(next_addr));\r\nif (size > WL3501_BLKSZ - sizeof(struct wl3501_rx_hdr)) {\r\nwl3501_get_from_wla(this,\r\nthis->start_seg +\r\nsizeof(struct wl3501_rx_hdr), data,\r\nWL3501_BLKSZ -\r\nsizeof(struct wl3501_rx_hdr));\r\nsize -= WL3501_BLKSZ - sizeof(struct wl3501_rx_hdr);\r\ndata += WL3501_BLKSZ - sizeof(struct wl3501_rx_hdr);\r\n} else {\r\nwl3501_get_from_wla(this,\r\nthis->start_seg +\r\nsizeof(struct wl3501_rx_hdr),\r\ndata, size);\r\nsize = 0;\r\n}\r\nwhile (size > 0) {\r\nif (size > WL3501_BLKSZ - 5) {\r\nwl3501_get_from_wla(this, next_addr + 5, data,\r\nWL3501_BLKSZ - 5);\r\nsize -= WL3501_BLKSZ - 5;\r\ndata += WL3501_BLKSZ - 5;\r\nwl3501_get_from_wla(this, next_addr + 2, &next_addr1,\r\nsizeof(next_addr1));\r\nnext_addr = next_addr1;\r\n} else {\r\nwl3501_get_from_wla(this, next_addr + 5, data, size);\r\nsize = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void wl3501_esbq_req_free(struct wl3501_card *this)\r\n{\r\nu8 tmp;\r\nu16 addr;\r\nif (this->esbq_req_head == this->esbq_req_tail)\r\ngoto out;\r\nwl3501_get_from_wla(this, this->esbq_req_tail + 3, &tmp, sizeof(tmp));\r\nif (!(tmp & 0x80))\r\ngoto out;\r\nwl3501_get_from_wla(this, this->esbq_req_tail, &addr, sizeof(addr));\r\nwl3501_free_tx_buffer(this, addr);\r\nthis->esbq_req_tail += 4;\r\nif (this->esbq_req_tail >= this->esbq_req_end)\r\nthis->esbq_req_tail = this->esbq_req_start;\r\nout:\r\nreturn;\r\n}\r\nstatic int wl3501_esbq_confirm(struct wl3501_card *this)\r\n{\r\nu8 tmp;\r\nwl3501_get_from_wla(this, this->esbq_confirm + 3, &tmp, sizeof(tmp));\r\nreturn tmp & 0x80;\r\n}\r\nstatic void wl3501_online(struct net_device *dev)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nprintk(KERN_INFO "%s: Wireless LAN online. BSSID: %pM\n",\r\ndev->name, this->bssid);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void wl3501_esbq_confirm_done(struct wl3501_card *this)\r\n{\r\nu8 tmp = 0;\r\nwl3501_set_to_wla(this, this->esbq_confirm + 3, &tmp, sizeof(tmp));\r\nthis->esbq_confirm += 4;\r\nif (this->esbq_confirm >= this->esbq_confirm_end)\r\nthis->esbq_confirm = this->esbq_confirm_start;\r\n}\r\nstatic int wl3501_mgmt_auth(struct wl3501_card *this)\r\n{\r\nstruct wl3501_auth_req sig = {\r\n.sig_id = WL3501_SIG_AUTH_REQ,\r\n.type = WL3501_SYS_TYPE_OPEN,\r\n.timeout = 1000,\r\n};\r\npr_debug("entry");\r\nmemcpy(sig.mac_addr, this->bssid, ETH_ALEN);\r\nreturn wl3501_esbq_exec(this, &sig, sizeof(sig));\r\n}\r\nstatic int wl3501_mgmt_association(struct wl3501_card *this)\r\n{\r\nstruct wl3501_assoc_req sig = {\r\n.sig_id = WL3501_SIG_ASSOC_REQ,\r\n.timeout = 1000,\r\n.listen_interval = 5,\r\n.cap_info = this->cap_info,\r\n};\r\npr_debug("entry");\r\nmemcpy(sig.mac_addr, this->bssid, ETH_ALEN);\r\nreturn wl3501_esbq_exec(this, &sig, sizeof(sig));\r\n}\r\nstatic void wl3501_mgmt_join_confirm(struct net_device *dev, u16 addr)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nstruct wl3501_join_confirm sig;\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nif (sig.status == WL3501_STATUS_SUCCESS) {\r\nif (this->net_type == IW_MODE_INFRA) {\r\nif (this->join_sta_bss < this->bss_cnt) {\r\nconst int i = this->join_sta_bss;\r\nmemcpy(this->bssid,\r\nthis->bss_set[i].bssid, ETH_ALEN);\r\nthis->chan = this->bss_set[i].ds_pset.chan;\r\niw_copy_mgmt_info_element(&this->keep_essid.el,\r\n&this->bss_set[i].ssid.el);\r\nwl3501_mgmt_auth(this);\r\n}\r\n} else {\r\nconst int i = this->join_sta_bss;\r\nmemcpy(&this->bssid, &this->bss_set[i].bssid, ETH_ALEN);\r\nthis->chan = this->bss_set[i].ds_pset.chan;\r\niw_copy_mgmt_info_element(&this->keep_essid.el,\r\n&this->bss_set[i].ssid.el);\r\nwl3501_online(dev);\r\n}\r\n} else {\r\nint i;\r\nthis->join_sta_bss++;\r\nfor (i = this->join_sta_bss; i < this->bss_cnt; i++)\r\nif (!wl3501_mgmt_join(this, i))\r\nbreak;\r\nthis->join_sta_bss = i;\r\nif (this->join_sta_bss == this->bss_cnt) {\r\nif (this->net_type == IW_MODE_INFRA)\r\nwl3501_mgmt_scan(this, 100);\r\nelse {\r\nthis->adhoc_times++;\r\nif (this->adhoc_times > WL3501_MAX_ADHOC_TRIES)\r\nwl3501_mgmt_start(this);\r\nelse\r\nwl3501_mgmt_scan(this, 100);\r\n}\r\n}\r\n}\r\n}\r\nstatic inline void wl3501_alarm_interrupt(struct net_device *dev,\r\nstruct wl3501_card *this)\r\n{\r\nif (this->net_type == IW_MODE_INFRA) {\r\nprintk(KERN_INFO "Wireless LAN offline\n");\r\nnetif_stop_queue(dev);\r\nwl3501_mgmt_resync(this);\r\n}\r\n}\r\nstatic inline void wl3501_md_confirm_interrupt(struct net_device *dev,\r\nstruct wl3501_card *this,\r\nu16 addr)\r\n{\r\nstruct wl3501_md_confirm sig;\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nwl3501_free_tx_buffer(this, sig.data);\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline void wl3501_md_ind_interrupt(struct net_device *dev,\r\nstruct wl3501_card *this, u16 addr)\r\n{\r\nstruct wl3501_md_ind sig;\r\nstruct sk_buff *skb;\r\nu8 rssi, addr4[ETH_ALEN];\r\nu16 pkt_len;\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nthis->start_seg = sig.data;\r\nwl3501_get_from_wla(this,\r\nsig.data + offsetof(struct wl3501_rx_hdr, rssi),\r\n&rssi, sizeof(rssi));\r\nthis->rssi = rssi <= 63 ? (rssi * 100) / 64 : 255;\r\nwl3501_get_from_wla(this,\r\nsig.data +\r\noffsetof(struct wl3501_rx_hdr, addr4),\r\n&addr4, sizeof(addr4));\r\nif (!(addr4[0] == 0xAA && addr4[1] == 0xAA &&\r\naddr4[2] == 0x03 && addr4[4] == 0x00)) {\r\nprintk(KERN_INFO "Insupported packet type!\n");\r\nreturn;\r\n}\r\npkt_len = sig.size + 12 - 24 - 4 - 6;\r\nskb = dev_alloc_skb(pkt_len + 5);\r\nif (!skb) {\r\nprintk(KERN_WARNING "%s: Can't alloc a sk_buff of size %d.\n",\r\ndev->name, pkt_len);\r\ndev->stats.rx_dropped++;\r\n} else {\r\nskb->dev = dev;\r\nskb_reserve(skb, 2);\r\nskb_copy_to_linear_data(skb, (unsigned char *)&sig.daddr, 12);\r\nwl3501_receive(this, skb->data, pkt_len);\r\nskb_put(skb, pkt_len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic inline void wl3501_get_confirm_interrupt(struct wl3501_card *this,\r\nu16 addr, void *sig, int size)\r\n{\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &this->sig_get_confirm,\r\nsizeof(this->sig_get_confirm));\r\nwake_up(&this->wait);\r\n}\r\nstatic inline void wl3501_start_confirm_interrupt(struct net_device *dev,\r\nstruct wl3501_card *this,\r\nu16 addr)\r\n{\r\nstruct wl3501_start_confirm sig;\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nif (sig.status == WL3501_STATUS_SUCCESS)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline void wl3501_assoc_confirm_interrupt(struct net_device *dev,\r\nu16 addr)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nstruct wl3501_assoc_confirm sig;\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nif (sig.status == WL3501_STATUS_SUCCESS)\r\nwl3501_online(dev);\r\n}\r\nstatic inline void wl3501_auth_confirm_interrupt(struct wl3501_card *this,\r\nu16 addr)\r\n{\r\nstruct wl3501_auth_confirm sig;\r\npr_debug("entry");\r\nwl3501_get_from_wla(this, addr, &sig, sizeof(sig));\r\nif (sig.status == WL3501_STATUS_SUCCESS)\r\nwl3501_mgmt_association(this);\r\nelse\r\nwl3501_mgmt_resync(this);\r\n}\r\nstatic inline void wl3501_rx_interrupt(struct net_device *dev)\r\n{\r\nint morepkts;\r\nu16 addr;\r\nu8 sig_id;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\npr_debug("entry");\r\nloop:\r\nmorepkts = 0;\r\nif (!wl3501_esbq_confirm(this))\r\ngoto free;\r\nwl3501_get_from_wla(this, this->esbq_confirm, &addr, sizeof(addr));\r\nwl3501_get_from_wla(this, addr + 2, &sig_id, sizeof(sig_id));\r\nswitch (sig_id) {\r\ncase WL3501_SIG_DEAUTH_IND:\r\ncase WL3501_SIG_DISASSOC_IND:\r\ncase WL3501_SIG_ALARM:\r\nwl3501_alarm_interrupt(dev, this);\r\nbreak;\r\ncase WL3501_SIG_MD_CONFIRM:\r\nwl3501_md_confirm_interrupt(dev, this, addr);\r\nbreak;\r\ncase WL3501_SIG_MD_IND:\r\nwl3501_md_ind_interrupt(dev, this, addr);\r\nbreak;\r\ncase WL3501_SIG_GET_CONFIRM:\r\nwl3501_get_confirm_interrupt(this, addr,\r\n&this->sig_get_confirm,\r\nsizeof(this->sig_get_confirm));\r\nbreak;\r\ncase WL3501_SIG_PWR_MGMT_CONFIRM:\r\nwl3501_get_confirm_interrupt(this, addr,\r\n&this->sig_pwr_mgmt_confirm,\r\nsizeof(this->sig_pwr_mgmt_confirm));\r\nbreak;\r\ncase WL3501_SIG_START_CONFIRM:\r\nwl3501_start_confirm_interrupt(dev, this, addr);\r\nbreak;\r\ncase WL3501_SIG_SCAN_CONFIRM:\r\nwl3501_mgmt_scan_confirm(this, addr);\r\nbreak;\r\ncase WL3501_SIG_JOIN_CONFIRM:\r\nwl3501_mgmt_join_confirm(dev, addr);\r\nbreak;\r\ncase WL3501_SIG_ASSOC_CONFIRM:\r\nwl3501_assoc_confirm_interrupt(dev, addr);\r\nbreak;\r\ncase WL3501_SIG_AUTH_CONFIRM:\r\nwl3501_auth_confirm_interrupt(this, addr);\r\nbreak;\r\ncase WL3501_SIG_RESYNC_CONFIRM:\r\nwl3501_mgmt_resync(this);\r\nbreak;\r\n}\r\nwl3501_esbq_confirm_done(this);\r\nmorepkts = 1;\r\nfree:\r\nwl3501_esbq_req_free(this);\r\nif (morepkts)\r\ngoto loop;\r\n}\r\nstatic inline void wl3501_ack_interrupt(struct wl3501_card *this)\r\n{\r\nwl3501_outb(WL3501_GCR_ECINT, this->base_addr + WL3501_NIC_GCR);\r\n}\r\nstatic irqreturn_t wl3501_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct wl3501_card *this;\r\nthis = netdev_priv(dev);\r\nspin_lock(&this->lock);\r\nwl3501_ack_interrupt(this);\r\nwl3501_block_interrupt(this);\r\nwl3501_rx_interrupt(dev);\r\nwl3501_unblock_interrupt(this);\r\nspin_unlock(&this->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wl3501_reset_board(struct wl3501_card *this)\r\n{\r\nu8 tmp = 0;\r\nint i, rc = 0;\r\nwl3501_outb_p(WL3501_GCR_CORESET, this->base_addr + WL3501_NIC_GCR);\r\nwl3501_outb_p(0, this->base_addr + WL3501_NIC_GCR);\r\nwl3501_outb_p(WL3501_GCR_CORESET, this->base_addr + WL3501_NIC_GCR);\r\nwl3501_set_to_wla(this, 0x480, &tmp, sizeof(tmp));\r\nwl3501_outb_p(0, this->base_addr + WL3501_NIC_GCR);\r\nWL3501_NOPLOOP(1024 * 50);\r\nwl3501_unblock_interrupt(this);\r\nfor (i = 0; i < 10000; i++) {\r\nwl3501_get_from_wla(this, 0x480, &tmp, sizeof(tmp));\r\nif (tmp == 'W') {\r\ntmp = 'A';\r\nwl3501_set_to_wla(this, 0x480, &tmp, sizeof(tmp));\r\ngoto out;\r\n}\r\nWL3501_NOPLOOP(10);\r\n}\r\nprintk(KERN_WARNING "%s: failed to reset the board!\n", __func__);\r\nrc = -ENODEV;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_init_firmware(struct wl3501_card *this)\r\n{\r\nu16 ptr, next;\r\nint rc = wl3501_reset_board(this);\r\nif (rc)\r\ngoto fail;\r\nthis->card_name[0] = '\0';\r\nwl3501_get_from_wla(this, 0x1a00,\r\nthis->card_name, sizeof(this->card_name));\r\nthis->card_name[sizeof(this->card_name) - 1] = '\0';\r\nthis->firmware_date[0] = '\0';\r\nwl3501_get_from_wla(this, 0x1a40,\r\nthis->firmware_date, sizeof(this->firmware_date));\r\nthis->firmware_date[sizeof(this->firmware_date) - 1] = '\0';\r\nwl3501_switch_page(this, WL3501_BSS_SPAGE0);\r\nwl3501_get_from_wla(this, 0x482, &this->esbq_req_start, 2);\r\nwl3501_get_from_wla(this, 0x486, &this->esbq_req_end, 2);\r\nwl3501_get_from_wla(this, 0x488, &this->esbq_confirm_start, 2);\r\nwl3501_get_from_wla(this, 0x48c, &this->esbq_confirm_end, 2);\r\nwl3501_get_from_wla(this, 0x48e, &this->tx_buffer_head, 2);\r\nwl3501_get_from_wla(this, 0x492, &this->tx_buffer_size, 2);\r\nthis->esbq_req_tail = this->esbq_req_head = this->esbq_req_start;\r\nthis->esbq_req_end += this->esbq_req_start;\r\nthis->esbq_confirm = this->esbq_confirm_start;\r\nthis->esbq_confirm_end += this->esbq_confirm_start;\r\nthis->tx_buffer_cnt = 1;\r\nptr = this->tx_buffer_head;\r\nnext = ptr + WL3501_BLKSZ;\r\nwhile ((next - this->tx_buffer_head) < this->tx_buffer_size) {\r\nthis->tx_buffer_cnt++;\r\nwl3501_set_to_wla(this, ptr, &next, sizeof(next));\r\nptr = next;\r\nnext = ptr + WL3501_BLKSZ;\r\n}\r\nrc = 0;\r\nnext = 0;\r\nwl3501_set_to_wla(this, ptr, &next, sizeof(next));\r\nthis->tx_buffer_tail = ptr;\r\nout:\r\nreturn rc;\r\nfail:\r\nprintk(KERN_WARNING "%s: failed!\n", __func__);\r\ngoto out;\r\n}\r\nstatic int wl3501_close(struct net_device *dev)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = -ENODEV;\r\nunsigned long flags;\r\nstruct pcmcia_device *link;\r\nlink = this->p_dev;\r\nspin_lock_irqsave(&this->lock, flags);\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\nwl3501_ack_interrupt(this);\r\nwl3501_block_interrupt(this);\r\nrc = 0;\r\nprintk(KERN_INFO "%s: WL3501 closed\n", dev->name);\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int wl3501_reset(struct net_device *dev)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = -ENODEV;\r\nwl3501_block_interrupt(this);\r\nif (wl3501_init_firmware(this)) {\r\nprintk(KERN_WARNING "%s: Can't initialize Firmware!\n",\r\ndev->name);\r\nfree_irq(dev->irq, dev);\r\ngoto out;\r\n}\r\nnetif_stop_queue(dev);\r\nthis->adhoc_times = 0;\r\nwl3501_ack_interrupt(this);\r\nwl3501_unblock_interrupt(this);\r\nwl3501_mgmt_scan(this, 100);\r\npr_debug("%s: device reset", dev->name);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void wl3501_tx_timeout(struct net_device *dev)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nunsigned long flags;\r\nint rc;\r\nstats->tx_errors++;\r\nspin_lock_irqsave(&this->lock, flags);\r\nrc = wl3501_reset(dev);\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nif (rc)\r\nprintk(KERN_ERR "%s: Error %d resetting card on Tx timeout!\n",\r\ndev->name, rc);\r\nelse {\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic netdev_tx_t wl3501_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nint enabled, rc;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&this->lock, flags);\r\nenabled = wl3501_block_interrupt(this);\r\nrc = wl3501_send_pkt(this, skb->data, skb->len);\r\nif (enabled)\r\nwl3501_unblock_interrupt(this);\r\nif (rc) {\r\n++dev->stats.tx_dropped;\r\nnetif_stop_queue(dev);\r\n} else {\r\n++dev->stats.tx_packets;\r\ndev->stats.tx_bytes += skb->len;\r\nkfree_skb(skb);\r\nif (this->tx_buffer_cnt < 2)\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int wl3501_open(struct net_device *dev)\r\n{\r\nint rc = -ENODEV;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nunsigned long flags;\r\nstruct pcmcia_device *link;\r\nlink = this->p_dev;\r\nspin_lock_irqsave(&this->lock, flags);\r\nif (!pcmcia_dev_present(link))\r\ngoto out;\r\nnetif_device_attach(dev);\r\nlink->open++;\r\npr_debug("%s: Initialize WL3501 firmware...", dev->name);\r\nif (wl3501_init_firmware(this))\r\ngoto fail;\r\nthis->adhoc_times = 0;\r\nwl3501_ack_interrupt(this);\r\nwl3501_unblock_interrupt(this);\r\nwl3501_mgmt_scan(this, 100);\r\nrc = 0;\r\npr_debug("%s: WL3501 opened", dev->name);\r\nprintk(KERN_INFO "%s: Card Name: %s\n"\r\n"%s: Firmware Date: %s\n",\r\ndev->name, this->card_name,\r\ndev->name, this->firmware_date);\r\nout:\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nreturn rc;\r\nfail:\r\nprintk(KERN_WARNING "%s: Can't initialize firmware!\n", dev->name);\r\ngoto out;\r\n}\r\nstatic struct iw_statistics *wl3501_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nstruct iw_statistics *wstats = &this->wstats;\r\nu32 value;\r\nmemset(wstats, 0, sizeof(*wstats));\r\nwstats->status = netif_running(dev);\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_ICV_ERROR_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.code += value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_UNDECRYPTABLE_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.code += value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_EXCLUDED_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.code += value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_RETRY_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.retries = value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_FAILED_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.misc += value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_RTS_FAILURE_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.misc += value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_ACK_FAILURE_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.misc += value;\r\nif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_FRAME_DUPLICATE_COUNT,\r\n&value, sizeof(value)))\r\nwstats->discard.misc += value;\r\nreturn wstats;\r\n}\r\nstatic void wl3501_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nwhile (link->open > 0)\r\nwl3501_close(dev);\r\nnetif_device_detach(dev);\r\nwl3501_release(link);\r\nunregister_netdev(dev);\r\nif (link->priv)\r\nfree_netdev(link->priv);\r\n}\r\nstatic int wl3501_get_name(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstrlcpy(wrqu->name, "IEEE 802.11-DS", sizeof(wrqu->name));\r\nreturn 0;\r\n}\r\nstatic int wl3501_set_freq(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint channel = wrqu->freq.m;\r\nint rc = -EINVAL;\r\nif (iw_valid_channel(this->reg_domain, channel)) {\r\nthis->chan = channel;\r\nrc = wl3501_reset(dev);\r\n}\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_freq(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nwrqu->freq.m = ieee80211_dsss_chan_to_freq(this->chan) * 100000;\r\nwrqu->freq.e = 1;\r\nreturn 0;\r\n}\r\nstatic int wl3501_set_mode(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint rc = -EINVAL;\r\nif (wrqu->mode == IW_MODE_INFRA ||\r\nwrqu->mode == IW_MODE_ADHOC ||\r\nwrqu->mode == IW_MODE_AUTO) {\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nthis->net_type = wrqu->mode;\r\nrc = wl3501_reset(dev);\r\n}\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_mode(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nwrqu->mode = this->net_type;\r\nreturn 0;\r\n}\r\nstatic int wl3501_get_sens(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nwrqu->sens.value = this->rssi;\r\nwrqu->sens.disabled = !wrqu->sens.value;\r\nwrqu->sens.fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int wl3501_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nwrqu->data.length = sizeof(*range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 1;\r\nrange->throughput = 2 * 1000 * 1000;\r\nreturn 0;\r\n}\r\nstatic int wl3501_set_wap(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = -EINVAL;\r\nif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\r\ngoto out;\r\nif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data)) {\r\n} else\r\nmemcpy(this->bssid, wrqu->ap_addr.sa_data, ETH_ALEN);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_wap(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(wrqu->ap_addr.sa_data, this->bssid, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int wl3501_set_scan(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nreturn wl3501_reset(dev);\r\n}\r\nstatic int wl3501_get_scan(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint i;\r\nchar *current_ev = extra;\r\nstruct iw_event iwe;\r\nfor (i = 0; i < this->bss_cnt; ++i) {\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, this->bss_set[i].bssid, ETH_ALEN);\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\niwe.u.data.length = this->bss_set[i].ssid.el.len;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe,\r\nthis->bss_set[i].ssid.essid);\r\niwe.cmd = SIOCGIWMODE;\r\niwe.u.mode = this->bss_set[i].bss_type;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_UINT_LEN);\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = this->bss_set[i].ds_pset.chan;\r\niwe.u.freq.e = 0;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (this->bss_set[i].cap_info & WL3501_MGMT_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nextra + IW_SCAN_MAX_DATA,\r\n&iwe, NULL);\r\n}\r\nwrqu->data.length = (current_ev - extra);\r\nwrqu->data.flags = 0;\r\nreturn 0;\r\n}\r\nstatic int wl3501_set_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nif (wrqu->data.flags) {\r\niw_set_mgmt_info_element(IW_MGMT_INFO_ELEMENT_SSID,\r\n&this->essid.el,\r\nextra, wrqu->data.length);\r\n} else {\r\niw_set_mgmt_info_element(IW_MGMT_INFO_ELEMENT_SSID,\r\n&this->essid.el, "ANY", 3);\r\n}\r\nreturn wl3501_reset(dev);\r\n}\r\nstatic int wl3501_get_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&this->lock, flags);\r\nwrqu->essid.flags = 1;\r\nwrqu->essid.length = this->essid.el.len;\r\nmemcpy(extra, this->essid.essid, this->essid.el.len);\r\nspin_unlock_irqrestore(&this->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wl3501_set_nick(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nif (wrqu->data.length > sizeof(this->nick))\r\nreturn -E2BIG;\r\nstrlcpy(this->nick, extra, wrqu->data.length);\r\nreturn 0;\r\n}\r\nstatic int wl3501_get_nick(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nstrlcpy(extra, this->nick, 32);\r\nwrqu->data.length = strlen(extra);\r\nreturn 0;\r\n}\r\nstatic int wl3501_get_rate(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->bitrate.value = 2000000;\r\nwrqu->bitrate.fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int wl3501_get_rts_threshold(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu16 threshold;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_RTS_THRESHOLD,\r\n&threshold, sizeof(threshold));\r\nif (!rc) {\r\nwrqu->rts.value = threshold;\r\nwrqu->rts.disabled = threshold >= 2347;\r\nwrqu->rts.fixed = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_frag_threshold(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu16 threshold;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_FRAG_THRESHOLD,\r\n&threshold, sizeof(threshold));\r\nif (!rc) {\r\nwrqu->frag.value = threshold;\r\nwrqu->frag.disabled = threshold >= 2346;\r\nwrqu->frag.fixed = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu16 txpow;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = wl3501_get_mib_value(this,\r\nWL3501_MIB_ATTR_CURRENT_TX_PWR_LEVEL,\r\n&txpow, sizeof(txpow));\r\nif (!rc) {\r\nwrqu->txpower.value = txpow;\r\nwrqu->txpower.disabled = 0;\r\nwrqu->txpower.fixed = 0;\r\nwrqu->txpower.flags = IW_TXPOW_MWATT;\r\n}\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu8 retry;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = wl3501_get_mib_value(this,\r\nWL3501_MIB_ATTR_LONG_RETRY_LIMIT,\r\n&retry, sizeof(retry));\r\nif (rc)\r\ngoto out;\r\nif (wrqu->retry.flags & IW_RETRY_LONG) {\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\ngoto set_value;\r\n}\r\nrc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_SHORT_RETRY_LIMIT,\r\n&retry, sizeof(retry));\r\nif (rc)\r\ngoto out;\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;\r\nset_value:\r\nwrqu->retry.value = retry;\r\nwrqu->retry.disabled = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu8 implemented, restricted, keys[100], len_keys, tocopy;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = wl3501_get_mib_value(this,\r\nWL3501_MIB_ATTR_PRIV_OPT_IMPLEMENTED,\r\n&implemented, sizeof(implemented));\r\nif (rc)\r\ngoto out;\r\nif (!implemented) {\r\nwrqu->encoding.flags = IW_ENCODE_DISABLED;\r\ngoto out;\r\n}\r\nrc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_EXCLUDE_UNENCRYPTED,\r\n&restricted, sizeof(restricted));\r\nif (rc)\r\ngoto out;\r\nwrqu->encoding.flags = restricted ? IW_ENCODE_RESTRICTED :\r\nIW_ENCODE_OPEN;\r\nrc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_KEY_MAPPINGS_LEN,\r\n&len_keys, sizeof(len_keys));\r\nif (rc)\r\ngoto out;\r\nrc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_KEY_MAPPINGS,\r\nkeys, len_keys);\r\nif (rc)\r\ngoto out;\r\ntocopy = min_t(u16, len_keys, wrqu->encoding.length);\r\ntocopy = min_t(u8, tocopy, 100);\r\nwrqu->encoding.length = tocopy;\r\nmemcpy(extra, keys, tocopy);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu8 pwr_state;\r\nstruct wl3501_card *this = netdev_priv(dev);\r\nint rc = wl3501_get_mib_value(this,\r\nWL3501_MIB_ATTR_CURRENT_PWR_STATE,\r\n&pwr_state, sizeof(pwr_state));\r\nif (rc)\r\ngoto out;\r\nwrqu->power.disabled = !pwr_state;\r\nwrqu->power.flags = IW_POWER_ON;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int wl3501_probe(struct pcmcia_device *p_dev)\r\n{\r\nstruct net_device *dev;\r\nstruct wl3501_card *this;\r\np_dev->resource[0]->end = 16;\r\np_dev->resource[0]->flags = IO_DATA_PATH_WIDTH_8;\r\np_dev->config_flags = CONF_ENABLE_IRQ;\r\np_dev->config_index = 1;\r\ndev = alloc_etherdev(sizeof(struct wl3501_card));\r\nif (!dev)\r\ngoto out_link;\r\ndev->netdev_ops = &wl3501_netdev_ops;\r\ndev->watchdog_timeo = 5 * HZ;\r\nthis = netdev_priv(dev);\r\nthis->wireless_data.spy_data = &this->spy_data;\r\nthis->p_dev = p_dev;\r\ndev->wireless_data = &this->wireless_data;\r\ndev->wireless_handlers = &wl3501_handler_def;\r\nnetif_stop_queue(dev);\r\np_dev->priv = dev;\r\nreturn wl3501_config(p_dev);\r\nout_link:\r\nreturn -ENOMEM;\r\n}\r\nstatic int wl3501_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nint i = 0, j, ret;\r\nstruct wl3501_card *this;\r\nlink->io_lines = 5;\r\nfor (j = 0x280; j < 0x400; j += 0x20) {\r\nlink->resource[0]->start = j;\r\nlink->resource[1]->start = link->resource[0]->start + 0x10;\r\ni = pcmcia_request_io(link);\r\nif (i == 0)\r\nbreak;\r\n}\r\nif (i != 0)\r\ngoto failed;\r\nret = pcmcia_request_irq(link, wl3501_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif (register_netdev(dev)) {\r\nprintk(KERN_NOTICE "wl3501_cs: register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nthis = netdev_priv(dev);\r\nthis->base_addr = dev->base_addr;\r\nif (!wl3501_get_flash_mac_addr(this)) {\r\nprintk(KERN_WARNING "%s: Can't read MAC addr in flash ROM?\n",\r\ndev->name);\r\nunregister_netdev(dev);\r\ngoto failed;\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = ((char *)&this->mac_addr)[i];\r\nprintk(KERN_INFO "%s: wl3501 @ 0x%3.3x, IRQ %d, "\r\n"MAC addr in flash ROM:%pM\n",\r\ndev->name, this->base_addr, (int)dev->irq,\r\ndev->dev_addr);\r\nthis->net_type = IW_MODE_INFRA;\r\nthis->bss_cnt = 0;\r\nthis->join_sta_bss = 0;\r\nthis->adhoc_times = 0;\r\niw_set_mgmt_info_element(IW_MGMT_INFO_ELEMENT_SSID, &this->essid.el,\r\n"ANY", 3);\r\nthis->card_name[0] = '\0';\r\nthis->firmware_date[0] = '\0';\r\nthis->rssi = 255;\r\nthis->chan = iw_default_channel(this->reg_domain);\r\nstrlcpy(this->nick, "Planet WL3501", sizeof(this->nick));\r\nspin_lock_init(&this->lock);\r\ninit_waitqueue_head(&this->wait);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nfailed:\r\nwl3501_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void wl3501_release(struct pcmcia_device *link)\r\n{\r\npcmcia_disable_device(link);\r\n}\r\nstatic int wl3501_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nwl3501_pwr_mgmt(netdev_priv(dev), WL3501_SUSPEND);\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int wl3501_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nwl3501_pwr_mgmt(netdev_priv(dev), WL3501_RESUME);\r\nif (link->open) {\r\nwl3501_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init wl3501_init_module(void)\r\n{\r\nreturn pcmcia_register_driver(&wl3501_driver);\r\n}\r\nstatic void __exit wl3501_exit_module(void)\r\n{\r\npcmcia_unregister_driver(&wl3501_driver);\r\n}
