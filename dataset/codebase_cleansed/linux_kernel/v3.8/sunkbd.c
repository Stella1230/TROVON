static irqreturn_t sunkbd_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct sunkbd *sunkbd = serio_get_drvdata(serio);\r\nif (sunkbd->reset <= -1) {\r\nsunkbd->reset = data;\r\nwake_up_interruptible(&sunkbd->wait);\r\ngoto out;\r\n}\r\nif (sunkbd->layout == -1) {\r\nsunkbd->layout = data;\r\nwake_up_interruptible(&sunkbd->wait);\r\ngoto out;\r\n}\r\nswitch (data) {\r\ncase SUNKBD_RET_RESET:\r\nschedule_work(&sunkbd->tq);\r\nsunkbd->reset = -1;\r\nbreak;\r\ncase SUNKBD_RET_LAYOUT:\r\nsunkbd->layout = -1;\r\nbreak;\r\ncase SUNKBD_RET_ALLUP:\r\nbreak;\r\ndefault:\r\nif (!sunkbd->enabled)\r\nbreak;\r\nif (sunkbd->keycode[data & SUNKBD_KEY]) {\r\ninput_report_key(sunkbd->dev,\r\nsunkbd->keycode[data & SUNKBD_KEY],\r\n!(data & SUNKBD_RELEASE));\r\ninput_sync(sunkbd->dev);\r\n} else {\r\nprintk(KERN_WARNING\r\n"sunkbd.c: Unknown key (scancode %#x) %s.\n",\r\ndata & SUNKBD_KEY,\r\ndata & SUNKBD_RELEASE ? "released" : "pressed");\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sunkbd_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct sunkbd *sunkbd = input_get_drvdata(dev);\r\nswitch (type) {\r\ncase EV_LED:\r\nserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\r\nserio_write(sunkbd->serio,\r\n(!!test_bit(LED_CAPSL, dev->led) << 3) |\r\n(!!test_bit(LED_SCROLLL, dev->led) << 2) |\r\n(!!test_bit(LED_COMPOSE, dev->led) << 1) |\r\n!!test_bit(LED_NUML, dev->led));\r\nreturn 0;\r\ncase EV_SND:\r\nswitch (code) {\r\ncase SND_CLICK:\r\nserio_write(sunkbd->serio, SUNKBD_CMD_NOCLICK - value);\r\nreturn 0;\r\ncase SND_BELL:\r\nserio_write(sunkbd->serio, SUNKBD_CMD_BELLOFF - value);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int sunkbd_initialize(struct sunkbd *sunkbd)\r\n{\r\nsunkbd->reset = -2;\r\nserio_write(sunkbd->serio, SUNKBD_CMD_RESET);\r\nwait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\r\nif (sunkbd->reset < 0)\r\nreturn -1;\r\nsunkbd->type = sunkbd->reset;\r\nif (sunkbd->type == 4) {\r\nsunkbd->layout = -2;\r\nserio_write(sunkbd->serio, SUNKBD_CMD_LAYOUT);\r\nwait_event_interruptible_timeout(sunkbd->wait,\r\nsunkbd->layout >= 0, HZ / 4);\r\nif (sunkbd->layout < 0)\r\nreturn -1;\r\nif (sunkbd->layout & SUNKBD_LAYOUT_5_MASK)\r\nsunkbd->type = 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sunkbd_reinit(struct work_struct *work)\r\n{\r\nstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\r\nwait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\r\nserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\r\nserio_write(sunkbd->serio,\r\n(!!test_bit(LED_CAPSL, sunkbd->dev->led) << 3) |\r\n(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\r\n(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\r\n!!test_bit(LED_NUML, sunkbd->dev->led));\r\nserio_write(sunkbd->serio,\r\nSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\r\nserio_write(sunkbd->serio,\r\nSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\r\n}\r\nstatic void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\r\n{\r\nserio_pause_rx(sunkbd->serio);\r\nsunkbd->enabled = enable;\r\nserio_continue_rx(sunkbd->serio);\r\n}\r\nstatic int sunkbd_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct sunkbd *sunkbd;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nint i;\r\nsunkbd = kzalloc(sizeof(struct sunkbd), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!sunkbd || !input_dev)\r\ngoto fail1;\r\nsunkbd->serio = serio;\r\nsunkbd->dev = input_dev;\r\ninit_waitqueue_head(&sunkbd->wait);\r\nINIT_WORK(&sunkbd->tq, sunkbd_reinit);\r\nsnprintf(sunkbd->phys, sizeof(sunkbd->phys), "%s/input0", serio->phys);\r\nserio_set_drvdata(serio, sunkbd);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nif (sunkbd_initialize(sunkbd) < 0) {\r\nerr = -ENODEV;\r\ngoto fail3;\r\n}\r\nsnprintf(sunkbd->name, sizeof(sunkbd->name),\r\n"Sun Type %d keyboard", sunkbd->type);\r\nmemcpy(sunkbd->keycode, sunkbd_keycode, sizeof(sunkbd->keycode));\r\ninput_dev->name = sunkbd->name;\r\ninput_dev->phys = sunkbd->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_SUNKBD;\r\ninput_dev->id.product = sunkbd->type;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_set_drvdata(input_dev, sunkbd);\r\ninput_dev->event = sunkbd_event;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\r\nBIT_MASK(EV_SND) | BIT_MASK(EV_REP);\r\ninput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) | BIT_MASK(LED_COMPOSE) |\r\nBIT_MASK(LED_SCROLLL) | BIT_MASK(LED_NUML);\r\ninput_dev->sndbit[0] = BIT_MASK(SND_CLICK) | BIT_MASK(SND_BELL);\r\ninput_dev->keycode = sunkbd->keycode;\r\ninput_dev->keycodesize = sizeof(unsigned char);\r\ninput_dev->keycodemax = ARRAY_SIZE(sunkbd_keycode);\r\nfor (i = 0; i < ARRAY_SIZE(sunkbd_keycode); i++)\r\n__set_bit(sunkbd->keycode[i], input_dev->keybit);\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\nsunkbd_enable(sunkbd, true);\r\nerr = input_register_device(sunkbd->dev);\r\nif (err)\r\ngoto fail4;\r\nreturn 0;\r\nfail4: sunkbd_enable(sunkbd, false);\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(sunkbd);\r\nreturn err;\r\n}\r\nstatic void sunkbd_disconnect(struct serio *serio)\r\n{\r\nstruct sunkbd *sunkbd = serio_get_drvdata(serio);\r\nsunkbd_enable(sunkbd, false);\r\ninput_unregister_device(sunkbd->dev);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\nkfree(sunkbd);\r\n}
