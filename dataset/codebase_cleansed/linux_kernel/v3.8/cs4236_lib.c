static void snd_cs4236_ctrl_out(struct snd_wss *chip,\r\nunsigned char reg, unsigned char val)\r\n{\r\noutb(reg, chip->cport + 3);\r\noutb(chip->cimage[reg] = val, chip->cport + 4);\r\n}\r\nstatic unsigned char snd_cs4236_ctrl_in(struct snd_wss *chip, unsigned char reg)\r\n{\r\noutb(reg, chip->cport + 3);\r\nreturn inb(chip->cport + 4);\r\n}\r\nstatic int snd_cs4236_xrate(struct snd_pcm_runtime *runtime)\r\n{\r\nreturn snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clocks);\r\n}\r\nstatic unsigned char divisor_to_rate_register(unsigned int divisor)\r\n{\r\nswitch (divisor) {\r\ncase 353: return 1;\r\ncase 529: return 2;\r\ncase 617: return 3;\r\ncase 1058: return 4;\r\ncase 1764: return 5;\r\ncase 2117: return 6;\r\ncase 2558: return 7;\r\ndefault:\r\nif (divisor < 21 || divisor > 192) {\r\nsnd_BUG();\r\nreturn 192;\r\n}\r\nreturn divisor;\r\n}\r\n}\r\nstatic void snd_cs4236_playback_format(struct snd_wss *chip,\r\nstruct snd_pcm_hw_params *params,\r\nunsigned char pdfr)\r\n{\r\nunsigned long flags;\r\nunsigned char rate = divisor_to_rate_register(params->rate_den);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] | 0x10);\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, pdfr & 0xf0);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] & ~0x10);\r\nsnd_cs4236_ext_out(chip, CS4236_DAC_RATE, rate);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs4236_capture_format(struct snd_wss *chip,\r\nstruct snd_pcm_hw_params *params,\r\nunsigned char cdfr)\r\n{\r\nunsigned long flags;\r\nunsigned char rate = divisor_to_rate_register(params->rate_den);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] | 0x20);\r\nsnd_wss_out(chip, CS4231_REC_FORMAT, cdfr & 0xf0);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] & ~0x20);\r\nsnd_cs4236_ext_out(chip, CS4236_ADC_RATE, rate);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs4236_suspend(struct snd_wss *chip)\r\n{\r\nint reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nfor (reg = 0; reg < 32; reg++)\r\nchip->image[reg] = snd_wss_in(chip, reg);\r\nfor (reg = 0; reg < 18; reg++)\r\nchip->eimage[reg] = snd_cs4236_ext_in(chip, CS4236_I23VAL(reg));\r\nfor (reg = 2; reg < 9; reg++)\r\nchip->cimage[reg] = snd_cs4236_ctrl_in(chip, reg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs4236_resume(struct snd_wss *chip)\r\n{\r\nint reg;\r\nunsigned long flags;\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nfor (reg = 0; reg < 32; reg++) {\r\nswitch (reg) {\r\ncase CS4236_EXT_REG:\r\ncase CS4231_VERSION:\r\ncase 27:\r\ncase 29:\r\nbreak;\r\ndefault:\r\nsnd_wss_out(chip, reg, chip->image[reg]);\r\nbreak;\r\n}\r\n}\r\nfor (reg = 0; reg < 18; reg++)\r\nsnd_cs4236_ext_out(chip, CS4236_I23VAL(reg), chip->eimage[reg]);\r\nfor (reg = 2; reg < 9; reg++) {\r\nswitch (reg) {\r\ncase 7:\r\nbreak;\r\ndefault:\r\nsnd_cs4236_ctrl_out(chip, reg, chip->cimage[reg]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\n}\r\nint snd_cs4236_create(struct snd_card *card,\r\nunsigned long port,\r\nunsigned long cport,\r\nint irq, int dma1, int dma2,\r\nunsigned short hardware,\r\nunsigned short hwshare,\r\nstruct snd_wss **rchip)\r\n{\r\nstruct snd_wss *chip;\r\nunsigned char ver1, ver2;\r\nunsigned int reg;\r\nint err;\r\n*rchip = NULL;\r\nif (hardware == WSS_HW_DETECT)\r\nhardware = WSS_HW_DETECT3;\r\nerr = snd_wss_create(card, port, cport,\r\nirq, dma1, dma2, hardware, hwshare, &chip);\r\nif (err < 0)\r\nreturn err;\r\nif ((chip->hardware & WSS_HW_CS4236B_MASK) == 0) {\r\nsnd_printd("chip is not CS4236+, hardware=0x%x\n",\r\nchip->hardware);\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\n#if 0\r\n{\r\nint idx;\r\nfor (idx = 0; idx < 8; idx++)\r\nsnd_printk(KERN_DEBUG "CD%i = 0x%x\n",\r\nidx, inb(chip->cport + idx));\r\nfor (idx = 0; idx < 9; idx++)\r\nsnd_printk(KERN_DEBUG "C%i = 0x%x\n",\r\nidx, snd_cs4236_ctrl_in(chip, idx));\r\n}\r\n#endif\r\nif (cport < 0x100 || cport == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR "please, specify control port "\r\n"for CS4236+ chips\n");\r\nsnd_device_free(card, chip);\r\nreturn -ENODEV;\r\n}\r\nver1 = snd_cs4236_ctrl_in(chip, 1);\r\nver2 = snd_cs4236_ext_in(chip, CS4236_VERSION);\r\nsnd_printdd("CS4236: [0x%lx] C1 (version) = 0x%x, ext = 0x%x\n",\r\ncport, ver1, ver2);\r\nif (ver1 != ver2) {\r\nsnd_printk(KERN_ERR "CS4236+ chip detected, but "\r\n"control port 0x%lx is not valid\n", cport);\r\nsnd_device_free(card, chip);\r\nreturn -ENODEV;\r\n}\r\nsnd_cs4236_ctrl_out(chip, 0, 0x00);\r\nsnd_cs4236_ctrl_out(chip, 2, 0xff);\r\nsnd_cs4236_ctrl_out(chip, 3, 0x00);\r\nsnd_cs4236_ctrl_out(chip, 4, 0x80);\r\nreg = ((IEC958_AES1_CON_PCM_CODER & 3) << 6) |\r\nIEC958_AES0_CON_EMPHASIS_NONE;\r\nsnd_cs4236_ctrl_out(chip, 5, reg);\r\nsnd_cs4236_ctrl_out(chip, 6, IEC958_AES1_CON_PCM_CODER >> 2);\r\nsnd_cs4236_ctrl_out(chip, 7, 0x00);\r\nsnd_cs4236_ctrl_out(chip, 8, 0x8c);\r\nchip->rate_constraint = snd_cs4236_xrate;\r\nchip->set_playback_format = snd_cs4236_playback_format;\r\nchip->set_capture_format = snd_cs4236_capture_format;\r\n#ifdef CONFIG_PM\r\nchip->suspend = snd_cs4236_suspend;\r\nchip->resume = snd_cs4236_resume;\r\n#endif\r\nfor (reg = 0; reg < sizeof(snd_cs4236_ext_map); reg++)\r\nsnd_cs4236_ext_out(chip, CS4236_I23VAL(reg),\r\nsnd_cs4236_ext_map[reg]);\r\nsnd_wss_out(chip, CS4231_LEFT_INPUT, 0x40);\r\nsnd_wss_out(chip, CS4231_RIGHT_INPUT, 0x40);\r\nsnd_wss_out(chip, CS4231_AUX1_LEFT_INPUT, 0xff);\r\nsnd_wss_out(chip, CS4231_AUX1_RIGHT_INPUT, 0xff);\r\nsnd_wss_out(chip, CS4231_AUX2_LEFT_INPUT, 0xdf);\r\nsnd_wss_out(chip, CS4231_AUX2_RIGHT_INPUT, 0xdf);\r\nsnd_wss_out(chip, CS4231_RIGHT_LINE_IN, 0xff);\r\nsnd_wss_out(chip, CS4231_LEFT_LINE_IN, 0xff);\r\nsnd_wss_out(chip, CS4231_RIGHT_LINE_IN, 0xff);\r\nswitch (chip->hardware) {\r\ncase WSS_HW_CS4235:\r\ncase WSS_HW_CS4239:\r\nsnd_wss_out(chip, CS4235_LEFT_MASTER, 0xff);\r\nsnd_wss_out(chip, CS4235_RIGHT_MASTER, 0xff);\r\nbreak;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nint snd_cs4236_pcm(struct snd_wss *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_wss_pcm(chip, device, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->info_flags &= ~SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->eimage[CS4236_REG(reg)] >> shift) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = (chip->eimage[CS4236_REG(reg)] & ~(mask << shift)) | val;\r\nchange = val != chip->eimage[CS4236_REG(reg)];\r\nsnd_cs4236_ext_out(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_cs4236_get_singlec(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->cimage[reg] >> shift) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_put_singlec(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = (chip->cimage[reg] & ~(mask << shift)) | val;\r\nchange = val != chip->cimage[reg];\r\nsnd_cs4236_ctrl_out(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_cs4236_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->eimage[CS4236_REG(left_reg)] >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (chip->eimage[CS4236_REG(right_reg)] >> shift_right) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned short val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (left_reg != right_reg) {\r\nval1 = (chip->eimage[CS4236_REG(left_reg)] & ~(mask << shift_left)) | val1;\r\nval2 = (chip->eimage[CS4236_REG(right_reg)] & ~(mask << shift_right)) | val2;\r\nchange = val1 != chip->eimage[CS4236_REG(left_reg)] || val2 != chip->eimage[CS4236_REG(right_reg)];\r\nsnd_cs4236_ext_out(chip, left_reg, val1);\r\nsnd_cs4236_ext_out(chip, right_reg, val2);\r\n} else {\r\nval1 = (chip->eimage[CS4236_REG(left_reg)] & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\r\nchange = val1 != chip->eimage[CS4236_REG(left_reg)];\r\nsnd_cs4236_ext_out(chip, left_reg, val1);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_cs4236_get_double1(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (chip->eimage[CS4236_REG(right_reg)] >> shift_right) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_put_double1(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned short val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;\r\nval2 = (chip->eimage[CS4236_REG(right_reg)] & ~(mask << shift_right)) | val2;\r\nchange = val1 != chip->image[left_reg] || val2 != chip->eimage[CS4236_REG(right_reg)];\r\nsnd_wss_out(chip, left_reg, val1);\r\nsnd_cs4236_ext_out(chip, right_reg, val2);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic inline int snd_cs4236_mixer_master_digital_invert_volume(int vol)\r\n{\r\nreturn (vol < 64) ? 63 - vol : 64 + (71 - vol);\r\n}\r\nstatic int snd_cs4236_get_master_digital(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = snd_cs4236_mixer_master_digital_invert_volume(chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] & 0x7f);\r\nucontrol->value.integer.value[1] = snd_cs4236_mixer_master_digital_invert_volume(chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)] & 0x7f);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_put_master_digital(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned short val1, val2;\r\nval1 = snd_cs4236_mixer_master_digital_invert_volume(ucontrol->value.integer.value[0] & 0x7f);\r\nval2 = snd_cs4236_mixer_master_digital_invert_volume(ucontrol->value.integer.value[1] & 0x7f);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval1 = (chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] & ~0x7f) | val1;\r\nval2 = (chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)] & ~0x7f) | val2;\r\nchange = val1 != chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] || val2 != chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)];\r\nsnd_cs4236_ext_out(chip, CS4236_LEFT_MASTER, val1);\r\nsnd_cs4236_ext_out(chip, CS4236_RIGHT_MASTER, val2);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic inline int snd_cs4235_mixer_output_accu_get_volume(int vol)\r\n{\r\nswitch ((vol >> 5) & 3) {\r\ncase 0: return 1;\r\ncase 1: return 3;\r\ncase 2: return 2;\r\ncase 3: return 0;\r\n}\r\nreturn 3;\r\n}\r\nstatic inline int snd_cs4235_mixer_output_accu_set_volume(int vol)\r\n{\r\nswitch (vol & 3) {\r\ncase 0: return 3 << 5;\r\ncase 1: return 0 << 5;\r\ncase 2: return 2 << 5;\r\ncase 3: return 1 << 5;\r\n}\r\nreturn 1 << 5;\r\n}\r\nstatic int snd_cs4235_get_output_accu(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = snd_cs4235_mixer_output_accu_get_volume(chip->image[CS4235_LEFT_MASTER]);\r\nucontrol->value.integer.value[1] = snd_cs4235_mixer_output_accu_get_volume(chip->image[CS4235_RIGHT_MASTER]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4235_put_output_accu(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned short val1, val2;\r\nval1 = snd_cs4235_mixer_output_accu_set_volume(ucontrol->value.integer.value[0]);\r\nval2 = snd_cs4235_mixer_output_accu_set_volume(ucontrol->value.integer.value[1]);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval1 = (chip->image[CS4235_LEFT_MASTER] & ~(3 << 5)) | val1;\r\nval2 = (chip->image[CS4235_RIGHT_MASTER] & ~(3 << 5)) | val2;\r\nchange = val1 != chip->image[CS4235_LEFT_MASTER] || val2 != chip->image[CS4235_RIGHT_MASTER];\r\nsnd_wss_out(chip, CS4235_LEFT_MASTER, val1);\r\nsnd_wss_out(chip, CS4235_RIGHT_MASTER, val2);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_cs4236_get_iec958_switch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = chip->image[CS4231_ALT_FEATURE_1] & 0x02 ? 1 : 0;\r\n#if 0\r\nprintk(KERN_DEBUG "get valid: ALT = 0x%x, C3 = 0x%x, C4 = 0x%x, "\r\n"C5 = 0x%x, C6 = 0x%x, C8 = 0x%x\n",\r\nsnd_wss_in(chip, CS4231_ALT_FEATURE_1),\r\nsnd_cs4236_ctrl_in(chip, 3),\r\nsnd_cs4236_ctrl_in(chip, 4),\r\nsnd_cs4236_ctrl_in(chip, 5),\r\nsnd_cs4236_ctrl_in(chip, 6),\r\nsnd_cs4236_ctrl_in(chip, 8));\r\n#endif\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4236_put_iec958_switch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned short enable, val;\r\nenable = ucontrol->value.integer.value[0] & 1;\r\nmutex_lock(&chip->mce_mutex);\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = (chip->image[CS4231_ALT_FEATURE_1] & ~0x0e) | (0<<2) | (enable << 1);\r\nchange = val != chip->image[CS4231_ALT_FEATURE_1];\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1, val);\r\nval = snd_cs4236_ctrl_in(chip, 4) | 0xc0;\r\nsnd_cs4236_ctrl_out(chip, 4, val);\r\nudelay(100);\r\nval &= ~0x40;\r\nsnd_cs4236_ctrl_out(chip, 4, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\nmutex_unlock(&chip->mce_mutex);\r\n#if 0\r\nprintk(KERN_DEBUG "set valid: ALT = 0x%x, C3 = 0x%x, C4 = 0x%x, "\r\n"C5 = 0x%x, C6 = 0x%x, C8 = 0x%x\n",\r\nsnd_wss_in(chip, CS4231_ALT_FEATURE_1),\r\nsnd_cs4236_ctrl_in(chip, 3),\r\nsnd_cs4236_ctrl_in(chip, 4),\r\nsnd_cs4236_ctrl_in(chip, 5),\r\nsnd_cs4236_ctrl_in(chip, 6),\r\nsnd_cs4236_ctrl_in(chip, 8));\r\n#endif\r\nreturn change;\r\n}\r\nint snd_cs4236_mixer(struct snd_wss *chip)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx, count;\r\nint err;\r\nstruct snd_kcontrol_new *kcontrol;\r\nif (snd_BUG_ON(!chip || !chip->card))\r\nreturn -EINVAL;\r\ncard = chip->card;\r\nstrcpy(card->mixername, snd_wss_chip_id(chip));\r\nif (chip->hardware == WSS_HW_CS4235 ||\r\nchip->hardware == WSS_HW_CS4239) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cs4235_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4235_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n} else {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cs4236_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4236_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nswitch (chip->hardware) {\r\ncase WSS_HW_CS4235:\r\ncase WSS_HW_CS4239:\r\ncount = ARRAY_SIZE(snd_cs4236_3d_controls_cs4235);\r\nkcontrol = snd_cs4236_3d_controls_cs4235;\r\nbreak;\r\ncase WSS_HW_CS4237B:\r\ncount = ARRAY_SIZE(snd_cs4236_3d_controls_cs4237);\r\nkcontrol = snd_cs4236_3d_controls_cs4237;\r\nbreak;\r\ncase WSS_HW_CS4238B:\r\ncount = ARRAY_SIZE(snd_cs4236_3d_controls_cs4238);\r\nkcontrol = snd_cs4236_3d_controls_cs4238;\r\nbreak;\r\ndefault:\r\ncount = 0;\r\nkcontrol = NULL;\r\n}\r\nfor (idx = 0; idx < count; idx++, kcontrol++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(kcontrol, chip))) < 0)\r\nreturn err;\r\n}\r\nif (chip->hardware == WSS_HW_CS4237B ||\r\nchip->hardware == WSS_HW_CS4238B) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cs4236_iec958_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4236_iec958_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}
