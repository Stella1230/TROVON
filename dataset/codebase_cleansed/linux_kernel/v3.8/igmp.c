static void ip_ma_put(struct ip_mc_list *im)\r\n{\r\nif (atomic_dec_and_test(&im->refcnt)) {\r\nin_dev_put(im->interface);\r\nkfree_rcu(im, rcu);\r\n}\r\n}\r\nstatic void igmp_stop_timer(struct ip_mc_list *im)\r\n{\r\nspin_lock_bh(&im->lock);\r\nif (del_timer(&im->timer))\r\natomic_dec(&im->refcnt);\r\nim->tm_running = 0;\r\nim->reporter = 0;\r\nim->unsolicit_count = 0;\r\nspin_unlock_bh(&im->lock);\r\n}\r\nstatic void igmp_start_timer(struct ip_mc_list *im, int max_delay)\r\n{\r\nint tv = net_random() % max_delay;\r\nim->tm_running = 1;\r\nif (!mod_timer(&im->timer, jiffies+tv+2))\r\natomic_inc(&im->refcnt);\r\n}\r\nstatic void igmp_gq_start_timer(struct in_device *in_dev)\r\n{\r\nint tv = net_random() % in_dev->mr_maxdelay;\r\nin_dev->mr_gq_running = 1;\r\nif (!mod_timer(&in_dev->mr_gq_timer, jiffies+tv+2))\r\nin_dev_hold(in_dev);\r\n}\r\nstatic void igmp_ifc_start_timer(struct in_device *in_dev, int delay)\r\n{\r\nint tv = net_random() % delay;\r\nif (!mod_timer(&in_dev->mr_ifc_timer, jiffies+tv+2))\r\nin_dev_hold(in_dev);\r\n}\r\nstatic void igmp_mod_timer(struct ip_mc_list *im, int max_delay)\r\n{\r\nspin_lock_bh(&im->lock);\r\nim->unsolicit_count = 0;\r\nif (del_timer(&im->timer)) {\r\nif ((long)(im->timer.expires-jiffies) < max_delay) {\r\nadd_timer(&im->timer);\r\nim->tm_running = 1;\r\nspin_unlock_bh(&im->lock);\r\nreturn;\r\n}\r\natomic_dec(&im->refcnt);\r\n}\r\nigmp_start_timer(im, max_delay);\r\nspin_unlock_bh(&im->lock);\r\n}\r\nstatic int is_in(struct ip_mc_list *pmc, struct ip_sf_list *psf, int type,\r\nint gdeleted, int sdeleted)\r\n{\r\nswitch (type) {\r\ncase IGMPV3_MODE_IS_INCLUDE:\r\ncase IGMPV3_MODE_IS_EXCLUDE:\r\nif (gdeleted || sdeleted)\r\nreturn 0;\r\nif (!(pmc->gsquery && !psf->sf_gsresp)) {\r\nif (pmc->sfmode == MCAST_INCLUDE)\r\nreturn 1;\r\nif (psf->sf_count[MCAST_INCLUDE])\r\nreturn type == IGMPV3_MODE_IS_INCLUDE;\r\nreturn pmc->sfcount[MCAST_EXCLUDE] ==\r\npsf->sf_count[MCAST_EXCLUDE];\r\n}\r\nreturn 0;\r\ncase IGMPV3_CHANGE_TO_INCLUDE:\r\nif (gdeleted || sdeleted)\r\nreturn 0;\r\nreturn psf->sf_count[MCAST_INCLUDE] != 0;\r\ncase IGMPV3_CHANGE_TO_EXCLUDE:\r\nif (gdeleted || sdeleted)\r\nreturn 0;\r\nif (pmc->sfcount[MCAST_EXCLUDE] == 0 ||\r\npsf->sf_count[MCAST_INCLUDE])\r\nreturn 0;\r\nreturn pmc->sfcount[MCAST_EXCLUDE] ==\r\npsf->sf_count[MCAST_EXCLUDE];\r\ncase IGMPV3_ALLOW_NEW_SOURCES:\r\nif (gdeleted || !psf->sf_crcount)\r\nreturn 0;\r\nreturn (pmc->sfmode == MCAST_INCLUDE) ^ sdeleted;\r\ncase IGMPV3_BLOCK_OLD_SOURCES:\r\nif (pmc->sfmode == MCAST_INCLUDE)\r\nreturn gdeleted || (psf->sf_crcount && sdeleted);\r\nreturn psf->sf_crcount && !gdeleted && !sdeleted;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nigmp_scount(struct ip_mc_list *pmc, int type, int gdeleted, int sdeleted)\r\n{\r\nstruct ip_sf_list *psf;\r\nint scount = 0;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next) {\r\nif (!is_in(pmc, psf, type, gdeleted, sdeleted))\r\ncontinue;\r\nscount++;\r\n}\r\nreturn scount;\r\n}\r\nstatic struct sk_buff *igmpv3_newpack(struct net_device *dev, int size)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtable *rt;\r\nstruct iphdr *pip;\r\nstruct igmpv3_report *pig;\r\nstruct net *net = dev_net(dev);\r\nstruct flowi4 fl4;\r\nint hlen = LL_RESERVED_SPACE(dev);\r\nint tlen = dev->needed_tailroom;\r\nwhile (1) {\r\nskb = alloc_skb(size + hlen + tlen,\r\nGFP_ATOMIC | __GFP_NOWARN);\r\nif (skb)\r\nbreak;\r\nsize >>= 1;\r\nif (size < 256)\r\nreturn NULL;\r\n}\r\nigmp_skb_size(skb) = size;\r\nrt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\r\n0, 0,\r\nIPPROTO_IGMP, 0, dev->ifindex);\r\nif (IS_ERR(rt)) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nskb_dst_set(skb, &rt->dst);\r\nskb->dev = dev;\r\nskb_reserve(skb, hlen);\r\nskb_reset_network_header(skb);\r\npip = ip_hdr(skb);\r\nskb_put(skb, sizeof(struct iphdr) + 4);\r\npip->version = 4;\r\npip->ihl = (sizeof(struct iphdr)+4)>>2;\r\npip->tos = 0xc0;\r\npip->frag_off = htons(IP_DF);\r\npip->ttl = 1;\r\npip->daddr = fl4.daddr;\r\npip->saddr = fl4.saddr;\r\npip->protocol = IPPROTO_IGMP;\r\npip->tot_len = 0;\r\nip_select_ident(pip, &rt->dst, NULL);\r\n((u8 *)&pip[1])[0] = IPOPT_RA;\r\n((u8 *)&pip[1])[1] = 4;\r\n((u8 *)&pip[1])[2] = 0;\r\n((u8 *)&pip[1])[3] = 0;\r\nskb->transport_header = skb->network_header + sizeof(struct iphdr) + 4;\r\nskb_put(skb, sizeof(*pig));\r\npig = igmpv3_report_hdr(skb);\r\npig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;\r\npig->resv1 = 0;\r\npig->csum = 0;\r\npig->resv2 = 0;\r\npig->ngrec = 0;\r\nreturn skb;\r\n}\r\nstatic int igmpv3_sendpack(struct sk_buff *skb)\r\n{\r\nstruct igmphdr *pig = igmp_hdr(skb);\r\nconst int igmplen = skb->tail - skb->transport_header;\r\npig->csum = ip_compute_csum(igmp_hdr(skb), igmplen);\r\nreturn ip_local_out(skb);\r\n}\r\nstatic int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)\r\n{\r\nreturn sizeof(struct igmpv3_grec) + 4*igmp_scount(pmc, type, gdel, sdel);\r\n}\r\nstatic struct sk_buff *add_grhead(struct sk_buff *skb, struct ip_mc_list *pmc,\r\nint type, struct igmpv3_grec **ppgr)\r\n{\r\nstruct net_device *dev = pmc->interface->dev;\r\nstruct igmpv3_report *pih;\r\nstruct igmpv3_grec *pgr;\r\nif (!skb)\r\nskb = igmpv3_newpack(dev, dev->mtu);\r\nif (!skb)\r\nreturn NULL;\r\npgr = (struct igmpv3_grec *)skb_put(skb, sizeof(struct igmpv3_grec));\r\npgr->grec_type = type;\r\npgr->grec_auxwords = 0;\r\npgr->grec_nsrcs = 0;\r\npgr->grec_mca = pmc->multiaddr;\r\npih = igmpv3_report_hdr(skb);\r\npih->ngrec = htons(ntohs(pih->ngrec)+1);\r\n*ppgr = pgr;\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,\r\nint type, int gdeleted, int sdeleted)\r\n{\r\nstruct net_device *dev = pmc->interface->dev;\r\nstruct igmpv3_report *pih;\r\nstruct igmpv3_grec *pgr = NULL;\r\nstruct ip_sf_list *psf, *psf_next, *psf_prev, **psf_list;\r\nint scount, stotal, first, isquery, truncate;\r\nif (pmc->multiaddr == IGMP_ALL_HOSTS)\r\nreturn skb;\r\nisquery = type == IGMPV3_MODE_IS_INCLUDE ||\r\ntype == IGMPV3_MODE_IS_EXCLUDE;\r\ntruncate = type == IGMPV3_MODE_IS_EXCLUDE ||\r\ntype == IGMPV3_CHANGE_TO_EXCLUDE;\r\nstotal = scount = 0;\r\npsf_list = sdeleted ? &pmc->tomb : &pmc->sources;\r\nif (!*psf_list)\r\ngoto empty_source;\r\npih = skb ? igmpv3_report_hdr(skb) : NULL;\r\nif (truncate) {\r\nif (pih && pih->ngrec &&\r\nAVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {\r\nif (skb)\r\nigmpv3_sendpack(skb);\r\nskb = igmpv3_newpack(dev, dev->mtu);\r\n}\r\n}\r\nfirst = 1;\r\npsf_prev = NULL;\r\nfor (psf=*psf_list; psf; psf=psf_next) {\r\n__be32 *psrc;\r\npsf_next = psf->sf_next;\r\nif (!is_in(pmc, psf, type, gdeleted, sdeleted)) {\r\npsf_prev = psf;\r\ncontinue;\r\n}\r\nif (isquery)\r\npsf->sf_gsresp = 0;\r\nif (AVAILABLE(skb) < sizeof(__be32) +\r\nfirst*sizeof(struct igmpv3_grec)) {\r\nif (truncate && !first)\r\nbreak;\r\nif (pgr)\r\npgr->grec_nsrcs = htons(scount);\r\nif (skb)\r\nigmpv3_sendpack(skb);\r\nskb = igmpv3_newpack(dev, dev->mtu);\r\nfirst = 1;\r\nscount = 0;\r\n}\r\nif (first) {\r\nskb = add_grhead(skb, pmc, type, &pgr);\r\nfirst = 0;\r\n}\r\nif (!skb)\r\nreturn NULL;\r\npsrc = (__be32 *)skb_put(skb, sizeof(__be32));\r\n*psrc = psf->sf_inaddr;\r\nscount++; stotal++;\r\nif ((type == IGMPV3_ALLOW_NEW_SOURCES ||\r\ntype == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {\r\npsf->sf_crcount--;\r\nif ((sdeleted || gdeleted) && psf->sf_crcount == 0) {\r\nif (psf_prev)\r\npsf_prev->sf_next = psf->sf_next;\r\nelse\r\n*psf_list = psf->sf_next;\r\nkfree(psf);\r\ncontinue;\r\n}\r\n}\r\npsf_prev = psf;\r\n}\r\nempty_source:\r\nif (!stotal) {\r\nif (type == IGMPV3_ALLOW_NEW_SOURCES ||\r\ntype == IGMPV3_BLOCK_OLD_SOURCES)\r\nreturn skb;\r\nif (pmc->crcount || isquery) {\r\nif (skb && AVAILABLE(skb)<sizeof(struct igmpv3_grec)) {\r\nigmpv3_sendpack(skb);\r\nskb = NULL;\r\n}\r\nskb = add_grhead(skb, pmc, type, &pgr);\r\n}\r\n}\r\nif (pgr)\r\npgr->grec_nsrcs = htons(scount);\r\nif (isquery)\r\npmc->gsquery = 0;\r\nreturn skb;\r\n}\r\nstatic int igmpv3_send_report(struct in_device *in_dev, struct ip_mc_list *pmc)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint type;\r\nif (!pmc) {\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(in_dev, pmc) {\r\nif (pmc->multiaddr == IGMP_ALL_HOSTS)\r\ncontinue;\r\nspin_lock_bh(&pmc->lock);\r\nif (pmc->sfcount[MCAST_EXCLUDE])\r\ntype = IGMPV3_MODE_IS_EXCLUDE;\r\nelse\r\ntype = IGMPV3_MODE_IS_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\nspin_unlock_bh(&pmc->lock);\r\n}\r\nrcu_read_unlock();\r\n} else {\r\nspin_lock_bh(&pmc->lock);\r\nif (pmc->sfcount[MCAST_EXCLUDE])\r\ntype = IGMPV3_MODE_IS_EXCLUDE;\r\nelse\r\ntype = IGMPV3_MODE_IS_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\nspin_unlock_bh(&pmc->lock);\r\n}\r\nif (!skb)\r\nreturn 0;\r\nreturn igmpv3_sendpack(skb);\r\n}\r\nstatic void igmpv3_clear_zeros(struct ip_sf_list **ppsf)\r\n{\r\nstruct ip_sf_list *psf_prev, *psf_next, *psf;\r\npsf_prev = NULL;\r\nfor (psf=*ppsf; psf; psf = psf_next) {\r\npsf_next = psf->sf_next;\r\nif (psf->sf_crcount == 0) {\r\nif (psf_prev)\r\npsf_prev->sf_next = psf->sf_next;\r\nelse\r\n*ppsf = psf->sf_next;\r\nkfree(psf);\r\n} else\r\npsf_prev = psf;\r\n}\r\n}\r\nstatic void igmpv3_send_cr(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *pmc, *pmc_prev, *pmc_next;\r\nstruct sk_buff *skb = NULL;\r\nint type, dtype;\r\nrcu_read_lock();\r\nspin_lock_bh(&in_dev->mc_tomb_lock);\r\npmc_prev = NULL;\r\nfor (pmc=in_dev->mc_tomb; pmc; pmc=pmc_next) {\r\npmc_next = pmc->next;\r\nif (pmc->sfmode == MCAST_INCLUDE) {\r\ntype = IGMPV3_BLOCK_OLD_SOURCES;\r\ndtype = IGMPV3_BLOCK_OLD_SOURCES;\r\nskb = add_grec(skb, pmc, type, 1, 0);\r\nskb = add_grec(skb, pmc, dtype, 1, 1);\r\n}\r\nif (pmc->crcount) {\r\nif (pmc->sfmode == MCAST_EXCLUDE) {\r\ntype = IGMPV3_CHANGE_TO_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 1, 0);\r\n}\r\npmc->crcount--;\r\nif (pmc->crcount == 0) {\r\nigmpv3_clear_zeros(&pmc->tomb);\r\nigmpv3_clear_zeros(&pmc->sources);\r\n}\r\n}\r\nif (pmc->crcount == 0 && !pmc->tomb && !pmc->sources) {\r\nif (pmc_prev)\r\npmc_prev->next = pmc_next;\r\nelse\r\nin_dev->mc_tomb = pmc_next;\r\nin_dev_put(pmc->interface);\r\nkfree(pmc);\r\n} else\r\npmc_prev = pmc;\r\n}\r\nspin_unlock_bh(&in_dev->mc_tomb_lock);\r\nfor_each_pmc_rcu(in_dev, pmc) {\r\nspin_lock_bh(&pmc->lock);\r\nif (pmc->sfcount[MCAST_EXCLUDE]) {\r\ntype = IGMPV3_BLOCK_OLD_SOURCES;\r\ndtype = IGMPV3_ALLOW_NEW_SOURCES;\r\n} else {\r\ntype = IGMPV3_ALLOW_NEW_SOURCES;\r\ndtype = IGMPV3_BLOCK_OLD_SOURCES;\r\n}\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\nskb = add_grec(skb, pmc, dtype, 0, 1);\r\nif (pmc->crcount) {\r\nif (pmc->sfmode == MCAST_EXCLUDE)\r\ntype = IGMPV3_CHANGE_TO_EXCLUDE;\r\nelse\r\ntype = IGMPV3_CHANGE_TO_INCLUDE;\r\nskb = add_grec(skb, pmc, type, 0, 0);\r\npmc->crcount--;\r\n}\r\nspin_unlock_bh(&pmc->lock);\r\n}\r\nrcu_read_unlock();\r\nif (!skb)\r\nreturn;\r\n(void) igmpv3_sendpack(skb);\r\n}\r\nstatic int igmp_send_report(struct in_device *in_dev, struct ip_mc_list *pmc,\r\nint type)\r\n{\r\nstruct sk_buff *skb;\r\nstruct iphdr *iph;\r\nstruct igmphdr *ih;\r\nstruct rtable *rt;\r\nstruct net_device *dev = in_dev->dev;\r\nstruct net *net = dev_net(dev);\r\n__be32 group = pmc ? pmc->multiaddr : 0;\r\nstruct flowi4 fl4;\r\n__be32 dst;\r\nint hlen, tlen;\r\nif (type == IGMPV3_HOST_MEMBERSHIP_REPORT)\r\nreturn igmpv3_send_report(in_dev, pmc);\r\nelse if (type == IGMP_HOST_LEAVE_MESSAGE)\r\ndst = IGMP_ALL_ROUTER;\r\nelse\r\ndst = group;\r\nrt = ip_route_output_ports(net, &fl4, NULL, dst, 0,\r\n0, 0,\r\nIPPROTO_IGMP, 0, dev->ifindex);\r\nif (IS_ERR(rt))\r\nreturn -1;\r\nhlen = LL_RESERVED_SPACE(dev);\r\ntlen = dev->needed_tailroom;\r\nskb = alloc_skb(IGMP_SIZE + hlen + tlen, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nip_rt_put(rt);\r\nreturn -1;\r\n}\r\nskb_dst_set(skb, &rt->dst);\r\nskb_reserve(skb, hlen);\r\nskb_reset_network_header(skb);\r\niph = ip_hdr(skb);\r\nskb_put(skb, sizeof(struct iphdr) + 4);\r\niph->version = 4;\r\niph->ihl = (sizeof(struct iphdr)+4)>>2;\r\niph->tos = 0xc0;\r\niph->frag_off = htons(IP_DF);\r\niph->ttl = 1;\r\niph->daddr = dst;\r\niph->saddr = fl4.saddr;\r\niph->protocol = IPPROTO_IGMP;\r\nip_select_ident(iph, &rt->dst, NULL);\r\n((u8 *)&iph[1])[0] = IPOPT_RA;\r\n((u8 *)&iph[1])[1] = 4;\r\n((u8 *)&iph[1])[2] = 0;\r\n((u8 *)&iph[1])[3] = 0;\r\nih = (struct igmphdr *)skb_put(skb, sizeof(struct igmphdr));\r\nih->type = type;\r\nih->code = 0;\r\nih->csum = 0;\r\nih->group = group;\r\nih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\r\nreturn ip_local_out(skb);\r\n}\r\nstatic void igmp_gq_timer_expire(unsigned long data)\r\n{\r\nstruct in_device *in_dev = (struct in_device *)data;\r\nin_dev->mr_gq_running = 0;\r\nigmpv3_send_report(in_dev, NULL);\r\n__in_dev_put(in_dev);\r\n}\r\nstatic void igmp_ifc_timer_expire(unsigned long data)\r\n{\r\nstruct in_device *in_dev = (struct in_device *)data;\r\nigmpv3_send_cr(in_dev);\r\nif (in_dev->mr_ifc_count) {\r\nin_dev->mr_ifc_count--;\r\nigmp_ifc_start_timer(in_dev, IGMP_Unsolicited_Report_Interval);\r\n}\r\n__in_dev_put(in_dev);\r\n}\r\nstatic void igmp_ifc_event(struct in_device *in_dev)\r\n{\r\nif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev))\r\nreturn;\r\nin_dev->mr_ifc_count = in_dev->mr_qrv ? in_dev->mr_qrv :\r\nIGMP_Unsolicited_Report_Count;\r\nigmp_ifc_start_timer(in_dev, 1);\r\n}\r\nstatic void igmp_timer_expire(unsigned long data)\r\n{\r\nstruct ip_mc_list *im=(struct ip_mc_list *)data;\r\nstruct in_device *in_dev = im->interface;\r\nspin_lock(&im->lock);\r\nim->tm_running = 0;\r\nif (im->unsolicit_count) {\r\nim->unsolicit_count--;\r\nigmp_start_timer(im, IGMP_Unsolicited_Report_Interval);\r\n}\r\nim->reporter = 1;\r\nspin_unlock(&im->lock);\r\nif (IGMP_V1_SEEN(in_dev))\r\nigmp_send_report(in_dev, im, IGMP_HOST_MEMBERSHIP_REPORT);\r\nelse if (IGMP_V2_SEEN(in_dev))\r\nigmp_send_report(in_dev, im, IGMPV2_HOST_MEMBERSHIP_REPORT);\r\nelse\r\nigmp_send_report(in_dev, im, IGMPV3_HOST_MEMBERSHIP_REPORT);\r\nip_ma_put(im);\r\n}\r\nstatic int igmp_xmarksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\r\n{\r\nstruct ip_sf_list *psf;\r\nint i, scount;\r\nscount = 0;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next) {\r\nif (scount == nsrcs)\r\nbreak;\r\nfor (i=0; i<nsrcs; i++) {\r\nif (psf->sf_count[MCAST_INCLUDE] ||\r\npmc->sfcount[MCAST_EXCLUDE] !=\r\npsf->sf_count[MCAST_EXCLUDE])\r\nbreak;\r\nif (srcs[i] == psf->sf_inaddr) {\r\nscount++;\r\nbreak;\r\n}\r\n}\r\n}\r\npmc->gsquery = 0;\r\nif (scount == nsrcs)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int igmp_marksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\r\n{\r\nstruct ip_sf_list *psf;\r\nint i, scount;\r\nif (pmc->sfmode == MCAST_EXCLUDE)\r\nreturn igmp_xmarksources(pmc, nsrcs, srcs);\r\nscount = 0;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next) {\r\nif (scount == nsrcs)\r\nbreak;\r\nfor (i=0; i<nsrcs; i++)\r\nif (srcs[i] == psf->sf_inaddr) {\r\npsf->sf_gsresp = 1;\r\nscount++;\r\nbreak;\r\n}\r\n}\r\nif (!scount) {\r\npmc->gsquery = 0;\r\nreturn 0;\r\n}\r\npmc->gsquery = 1;\r\nreturn 1;\r\n}\r\nstatic bool igmp_heard_report(struct in_device *in_dev, __be32 group)\r\n{\r\nstruct ip_mc_list *im;\r\nif (group == IGMP_ALL_HOSTS)\r\nreturn false;\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(in_dev, im) {\r\nif (im->multiaddr == group) {\r\nigmp_stop_timer(im);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn false;\r\n}\r\nstatic bool igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\r\nint len)\r\n{\r\nstruct igmphdr *ih = igmp_hdr(skb);\r\nstruct igmpv3_query *ih3 = igmpv3_query_hdr(skb);\r\nstruct ip_mc_list *im;\r\n__be32 group = ih->group;\r\nint max_delay;\r\nint mark = 0;\r\nif (len == 8) {\r\nif (ih->code == 0) {\r\nmax_delay = IGMP_Query_Response_Interval;\r\nin_dev->mr_v1_seen = jiffies +\r\nIGMP_V1_Router_Present_Timeout;\r\ngroup = 0;\r\n} else {\r\nmax_delay = ih->code*(HZ/IGMP_TIMER_SCALE);\r\nin_dev->mr_v2_seen = jiffies +\r\nIGMP_V2_Router_Present_Timeout;\r\n}\r\nin_dev->mr_ifc_count = 0;\r\nif (del_timer(&in_dev->mr_ifc_timer))\r\n__in_dev_put(in_dev);\r\nigmpv3_clear_delrec(in_dev);\r\n} else if (len < 12) {\r\nreturn true;\r\n} else if (IGMP_V1_SEEN(in_dev)) {\r\nmax_delay = IGMP_Query_Response_Interval;\r\ngroup = 0;\r\n} else if (IGMP_V2_SEEN(in_dev)) {\r\nmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\r\nif (!max_delay)\r\nmax_delay = 1;\r\n} else {\r\nif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\r\nreturn true;\r\nih3 = igmpv3_query_hdr(skb);\r\nif (ih3->nsrcs) {\r\nif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)\r\n+ ntohs(ih3->nsrcs)*sizeof(__be32)))\r\nreturn true;\r\nih3 = igmpv3_query_hdr(skb);\r\n}\r\nmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\r\nif (!max_delay)\r\nmax_delay = 1;\r\nin_dev->mr_maxdelay = max_delay;\r\nif (ih3->qrv)\r\nin_dev->mr_qrv = ih3->qrv;\r\nif (!group) {\r\nif (ih3->nsrcs)\r\nreturn false;\r\nigmp_gq_start_timer(in_dev);\r\nreturn false;\r\n}\r\nmark = ih3->nsrcs != 0;\r\n}\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(in_dev, im) {\r\nint changed;\r\nif (group && group != im->multiaddr)\r\ncontinue;\r\nif (im->multiaddr == IGMP_ALL_HOSTS)\r\ncontinue;\r\nspin_lock_bh(&im->lock);\r\nif (im->tm_running)\r\nim->gsquery = im->gsquery && mark;\r\nelse\r\nim->gsquery = mark;\r\nchanged = !im->gsquery ||\r\nigmp_marksources(im, ntohs(ih3->nsrcs), ih3->srcs);\r\nspin_unlock_bh(&im->lock);\r\nif (changed)\r\nigmp_mod_timer(im, max_delay);\r\n}\r\nrcu_read_unlock();\r\nreturn false;\r\n}\r\nint igmp_rcv(struct sk_buff *skb)\r\n{\r\nstruct igmphdr *ih;\r\nstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\r\nint len = skb->len;\r\nbool dropped = true;\r\nif (in_dev == NULL)\r\ngoto drop;\r\nif (!pskb_may_pull(skb, sizeof(struct igmphdr)))\r\ngoto drop;\r\nswitch (skb->ip_summed) {\r\ncase CHECKSUM_COMPLETE:\r\nif (!csum_fold(skb->csum))\r\nbreak;\r\ncase CHECKSUM_NONE:\r\nskb->csum = 0;\r\nif (__skb_checksum_complete(skb))\r\ngoto drop;\r\n}\r\nih = igmp_hdr(skb);\r\nswitch (ih->type) {\r\ncase IGMP_HOST_MEMBERSHIP_QUERY:\r\ndropped = igmp_heard_query(in_dev, skb, len);\r\nbreak;\r\ncase IGMP_HOST_MEMBERSHIP_REPORT:\r\ncase IGMPV2_HOST_MEMBERSHIP_REPORT:\r\nif (rt_is_output_route(skb_rtable(skb)))\r\nbreak;\r\nif (skb->pkt_type == PACKET_MULTICAST ||\r\nskb->pkt_type == PACKET_BROADCAST)\r\ndropped = igmp_heard_report(in_dev, ih->group);\r\nbreak;\r\ncase IGMP_PIM:\r\n#ifdef CONFIG_IP_PIMSM_V1\r\nreturn pim_rcv_v1(skb);\r\n#endif\r\ncase IGMPV3_HOST_MEMBERSHIP_REPORT:\r\ncase IGMP_DVMRP:\r\ncase IGMP_TRACE:\r\ncase IGMP_HOST_LEAVE_MESSAGE:\r\ncase IGMP_MTRACE:\r\ncase IGMP_MTRACE_RESP:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndrop:\r\nif (dropped)\r\nkfree_skb(skb);\r\nelse\r\nconsume_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void ip_mc_filter_add(struct in_device *in_dev, __be32 addr)\r\n{\r\nchar buf[MAX_ADDR_LEN];\r\nstruct net_device *dev = in_dev->dev;\r\nif (arp_mc_map(addr, buf, dev, 0) == 0)\r\ndev_mc_add(dev, buf);\r\n}\r\nstatic void ip_mc_filter_del(struct in_device *in_dev, __be32 addr)\r\n{\r\nchar buf[MAX_ADDR_LEN];\r\nstruct net_device *dev = in_dev->dev;\r\nif (arp_mc_map(addr, buf, dev, 0) == 0)\r\ndev_mc_del(dev, buf);\r\n}\r\nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)\r\n{\r\nstruct ip_mc_list *pmc;\r\npmc = kzalloc(sizeof(*pmc), GFP_KERNEL);\r\nif (!pmc)\r\nreturn;\r\nspin_lock_bh(&im->lock);\r\npmc->interface = im->interface;\r\nin_dev_hold(in_dev);\r\npmc->multiaddr = im->multiaddr;\r\npmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\r\nIGMP_Unsolicited_Report_Count;\r\npmc->sfmode = im->sfmode;\r\nif (pmc->sfmode == MCAST_INCLUDE) {\r\nstruct ip_sf_list *psf;\r\npmc->tomb = im->tomb;\r\npmc->sources = im->sources;\r\nim->tomb = im->sources = NULL;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next)\r\npsf->sf_crcount = pmc->crcount;\r\n}\r\nspin_unlock_bh(&im->lock);\r\nspin_lock_bh(&in_dev->mc_tomb_lock);\r\npmc->next = in_dev->mc_tomb;\r\nin_dev->mc_tomb = pmc;\r\nspin_unlock_bh(&in_dev->mc_tomb_lock);\r\n}\r\nstatic void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr)\r\n{\r\nstruct ip_mc_list *pmc, *pmc_prev;\r\nstruct ip_sf_list *psf, *psf_next;\r\nspin_lock_bh(&in_dev->mc_tomb_lock);\r\npmc_prev = NULL;\r\nfor (pmc=in_dev->mc_tomb; pmc; pmc=pmc->next) {\r\nif (pmc->multiaddr == multiaddr)\r\nbreak;\r\npmc_prev = pmc;\r\n}\r\nif (pmc) {\r\nif (pmc_prev)\r\npmc_prev->next = pmc->next;\r\nelse\r\nin_dev->mc_tomb = pmc->next;\r\n}\r\nspin_unlock_bh(&in_dev->mc_tomb_lock);\r\nif (pmc) {\r\nfor (psf=pmc->tomb; psf; psf=psf_next) {\r\npsf_next = psf->sf_next;\r\nkfree(psf);\r\n}\r\nin_dev_put(pmc->interface);\r\nkfree(pmc);\r\n}\r\n}\r\nstatic void igmpv3_clear_delrec(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *pmc, *nextpmc;\r\nspin_lock_bh(&in_dev->mc_tomb_lock);\r\npmc = in_dev->mc_tomb;\r\nin_dev->mc_tomb = NULL;\r\nspin_unlock_bh(&in_dev->mc_tomb_lock);\r\nfor (; pmc; pmc = nextpmc) {\r\nnextpmc = pmc->next;\r\nip_mc_clear_src(pmc);\r\nin_dev_put(pmc->interface);\r\nkfree(pmc);\r\n}\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(in_dev, pmc) {\r\nstruct ip_sf_list *psf, *psf_next;\r\nspin_lock_bh(&pmc->lock);\r\npsf = pmc->tomb;\r\npmc->tomb = NULL;\r\nspin_unlock_bh(&pmc->lock);\r\nfor (; psf; psf=psf_next) {\r\npsf_next = psf->sf_next;\r\nkfree(psf);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void igmp_group_dropped(struct ip_mc_list *im)\r\n{\r\nstruct in_device *in_dev = im->interface;\r\n#ifdef CONFIG_IP_MULTICAST\r\nint reporter;\r\n#endif\r\nif (im->loaded) {\r\nim->loaded = 0;\r\nip_mc_filter_del(in_dev, im->multiaddr);\r\n}\r\n#ifdef CONFIG_IP_MULTICAST\r\nif (im->multiaddr == IGMP_ALL_HOSTS)\r\nreturn;\r\nreporter = im->reporter;\r\nigmp_stop_timer(im);\r\nif (!in_dev->dead) {\r\nif (IGMP_V1_SEEN(in_dev))\r\nreturn;\r\nif (IGMP_V2_SEEN(in_dev)) {\r\nif (reporter)\r\nigmp_send_report(in_dev, im, IGMP_HOST_LEAVE_MESSAGE);\r\nreturn;\r\n}\r\nigmpv3_add_delrec(in_dev, im);\r\nigmp_ifc_event(in_dev);\r\n}\r\n#endif\r\n}\r\nstatic void igmp_group_added(struct ip_mc_list *im)\r\n{\r\nstruct in_device *in_dev = im->interface;\r\nif (im->loaded == 0) {\r\nim->loaded = 1;\r\nip_mc_filter_add(in_dev, im->multiaddr);\r\n}\r\n#ifdef CONFIG_IP_MULTICAST\r\nif (im->multiaddr == IGMP_ALL_HOSTS)\r\nreturn;\r\nif (in_dev->dead)\r\nreturn;\r\nif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\r\nspin_lock_bh(&im->lock);\r\nigmp_start_timer(im, IGMP_Initial_Report_Delay);\r\nspin_unlock_bh(&im->lock);\r\nreturn;\r\n}\r\nim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\r\nIGMP_Unsolicited_Report_Count;\r\nigmp_ifc_event(in_dev);\r\n#endif\r\n}\r\nvoid ip_mc_inc_group(struct in_device *in_dev, __be32 addr)\r\n{\r\nstruct ip_mc_list *im;\r\nASSERT_RTNL();\r\nfor_each_pmc_rtnl(in_dev, im) {\r\nif (im->multiaddr == addr) {\r\nim->users++;\r\nip_mc_add_src(in_dev, &addr, MCAST_EXCLUDE, 0, NULL, 0);\r\ngoto out;\r\n}\r\n}\r\nim = kzalloc(sizeof(*im), GFP_KERNEL);\r\nif (!im)\r\ngoto out;\r\nim->users = 1;\r\nim->interface = in_dev;\r\nin_dev_hold(in_dev);\r\nim->multiaddr = addr;\r\nim->sfmode = MCAST_EXCLUDE;\r\nim->sfcount[MCAST_EXCLUDE] = 1;\r\natomic_set(&im->refcnt, 1);\r\nspin_lock_init(&im->lock);\r\n#ifdef CONFIG_IP_MULTICAST\r\nsetup_timer(&im->timer, &igmp_timer_expire, (unsigned long)im);\r\nim->unsolicit_count = IGMP_Unsolicited_Report_Count;\r\n#endif\r\nim->next_rcu = in_dev->mc_list;\r\nin_dev->mc_count++;\r\nrcu_assign_pointer(in_dev->mc_list, im);\r\n#ifdef CONFIG_IP_MULTICAST\r\nigmpv3_del_delrec(in_dev, im->multiaddr);\r\n#endif\r\nigmp_group_added(im);\r\nif (!in_dev->dead)\r\nip_rt_multicast_event(in_dev);\r\nout:\r\nreturn;\r\n}\r\nvoid ip_mc_rejoin_groups(struct in_device *in_dev)\r\n{\r\n#ifdef CONFIG_IP_MULTICAST\r\nstruct ip_mc_list *im;\r\nint type;\r\nfor_each_pmc_rcu(in_dev, im) {\r\nif (im->multiaddr == IGMP_ALL_HOSTS)\r\ncontinue;\r\nif (IGMP_V1_SEEN(in_dev))\r\ntype = IGMP_HOST_MEMBERSHIP_REPORT;\r\nelse if (IGMP_V2_SEEN(in_dev))\r\ntype = IGMPV2_HOST_MEMBERSHIP_REPORT;\r\nelse\r\ntype = IGMPV3_HOST_MEMBERSHIP_REPORT;\r\nigmp_send_report(in_dev, im, type);\r\n}\r\n#endif\r\n}\r\nvoid ip_mc_dec_group(struct in_device *in_dev, __be32 addr)\r\n{\r\nstruct ip_mc_list *i;\r\nstruct ip_mc_list __rcu **ip;\r\nASSERT_RTNL();\r\nfor (ip = &in_dev->mc_list;\r\n(i = rtnl_dereference(*ip)) != NULL;\r\nip = &i->next_rcu) {\r\nif (i->multiaddr == addr) {\r\nif (--i->users == 0) {\r\n*ip = i->next_rcu;\r\nin_dev->mc_count--;\r\nigmp_group_dropped(i);\r\nip_mc_clear_src(i);\r\nif (!in_dev->dead)\r\nip_rt_multicast_event(in_dev);\r\nip_ma_put(i);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid ip_mc_unmap(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *pmc;\r\nASSERT_RTNL();\r\nfor_each_pmc_rtnl(in_dev, pmc)\r\nigmp_group_dropped(pmc);\r\n}\r\nvoid ip_mc_remap(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *pmc;\r\nASSERT_RTNL();\r\nfor_each_pmc_rtnl(in_dev, pmc)\r\nigmp_group_added(pmc);\r\n}\r\nvoid ip_mc_down(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *pmc;\r\nASSERT_RTNL();\r\nfor_each_pmc_rtnl(in_dev, pmc)\r\nigmp_group_dropped(pmc);\r\n#ifdef CONFIG_IP_MULTICAST\r\nin_dev->mr_ifc_count = 0;\r\nif (del_timer(&in_dev->mr_ifc_timer))\r\n__in_dev_put(in_dev);\r\nin_dev->mr_gq_running = 0;\r\nif (del_timer(&in_dev->mr_gq_timer))\r\n__in_dev_put(in_dev);\r\nigmpv3_clear_delrec(in_dev);\r\n#endif\r\nip_mc_dec_group(in_dev, IGMP_ALL_HOSTS);\r\n}\r\nvoid ip_mc_init_dev(struct in_device *in_dev)\r\n{\r\nASSERT_RTNL();\r\nin_dev->mc_tomb = NULL;\r\n#ifdef CONFIG_IP_MULTICAST\r\nin_dev->mr_gq_running = 0;\r\nsetup_timer(&in_dev->mr_gq_timer, igmp_gq_timer_expire,\r\n(unsigned long)in_dev);\r\nin_dev->mr_ifc_count = 0;\r\nin_dev->mc_count = 0;\r\nsetup_timer(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire,\r\n(unsigned long)in_dev);\r\nin_dev->mr_qrv = IGMP_Unsolicited_Report_Count;\r\n#endif\r\nspin_lock_init(&in_dev->mc_tomb_lock);\r\n}\r\nvoid ip_mc_up(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *pmc;\r\nASSERT_RTNL();\r\nip_mc_inc_group(in_dev, IGMP_ALL_HOSTS);\r\nfor_each_pmc_rtnl(in_dev, pmc)\r\nigmp_group_added(pmc);\r\n}\r\nvoid ip_mc_destroy_dev(struct in_device *in_dev)\r\n{\r\nstruct ip_mc_list *i;\r\nASSERT_RTNL();\r\nip_mc_down(in_dev);\r\nwhile ((i = rtnl_dereference(in_dev->mc_list)) != NULL) {\r\nin_dev->mc_list = i->next_rcu;\r\nin_dev->mc_count--;\r\nip_mc_clear_src(i);\r\nip_ma_put(i);\r\n}\r\n}\r\nstatic struct in_device *ip_mc_find_dev(struct net *net, struct ip_mreqn *imr)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct in_device *idev = NULL;\r\nif (imr->imr_ifindex) {\r\nidev = inetdev_by_index(net, imr->imr_ifindex);\r\nreturn idev;\r\n}\r\nif (imr->imr_address.s_addr) {\r\ndev = __ip_dev_find(net, imr->imr_address.s_addr, false);\r\nif (!dev)\r\nreturn NULL;\r\n}\r\nif (!dev) {\r\nstruct rtable *rt = ip_route_output(net,\r\nimr->imr_multiaddr.s_addr,\r\n0, 0, 0);\r\nif (!IS_ERR(rt)) {\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\n}\r\n}\r\nif (dev) {\r\nimr->imr_ifindex = dev->ifindex;\r\nidev = __in_dev_get_rtnl(dev);\r\n}\r\nreturn idev;\r\n}\r\nstatic int ip_mc_del1_src(struct ip_mc_list *pmc, int sfmode,\r\n__be32 *psfsrc)\r\n{\r\nstruct ip_sf_list *psf, *psf_prev;\r\nint rv = 0;\r\npsf_prev = NULL;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next) {\r\nif (psf->sf_inaddr == *psfsrc)\r\nbreak;\r\npsf_prev = psf;\r\n}\r\nif (!psf || psf->sf_count[sfmode] == 0) {\r\nreturn -ESRCH;\r\n}\r\npsf->sf_count[sfmode]--;\r\nif (psf->sf_count[sfmode] == 0) {\r\nip_rt_multicast_event(pmc->interface);\r\n}\r\nif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\r\n#ifdef CONFIG_IP_MULTICAST\r\nstruct in_device *in_dev = pmc->interface;\r\n#endif\r\nif (psf_prev)\r\npsf_prev->sf_next = psf->sf_next;\r\nelse\r\npmc->sources = psf->sf_next;\r\n#ifdef CONFIG_IP_MULTICAST\r\nif (psf->sf_oldin &&\r\n!IGMP_V1_SEEN(in_dev) && !IGMP_V2_SEEN(in_dev)) {\r\npsf->sf_crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\r\nIGMP_Unsolicited_Report_Count;\r\npsf->sf_next = pmc->tomb;\r\npmc->tomb = psf;\r\nrv = 1;\r\n} else\r\n#endif\r\nkfree(psf);\r\n}\r\nreturn rv;\r\n}\r\nstatic int ip_mc_del_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\r\nint sfcount, __be32 *psfsrc, int delta)\r\n{\r\nstruct ip_mc_list *pmc;\r\nint changerec = 0;\r\nint i, err;\r\nif (!in_dev)\r\nreturn -ENODEV;\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(in_dev, pmc) {\r\nif (*pmca == pmc->multiaddr)\r\nbreak;\r\n}\r\nif (!pmc) {\r\nrcu_read_unlock();\r\nreturn -ESRCH;\r\n}\r\nspin_lock_bh(&pmc->lock);\r\nrcu_read_unlock();\r\n#ifdef CONFIG_IP_MULTICAST\r\nsf_markstate(pmc);\r\n#endif\r\nif (!delta) {\r\nerr = -EINVAL;\r\nif (!pmc->sfcount[sfmode])\r\ngoto out_unlock;\r\npmc->sfcount[sfmode]--;\r\n}\r\nerr = 0;\r\nfor (i=0; i<sfcount; i++) {\r\nint rv = ip_mc_del1_src(pmc, sfmode, &psfsrc[i]);\r\nchangerec |= rv > 0;\r\nif (!err && rv < 0)\r\nerr = rv;\r\n}\r\nif (pmc->sfmode == MCAST_EXCLUDE &&\r\npmc->sfcount[MCAST_EXCLUDE] == 0 &&\r\npmc->sfcount[MCAST_INCLUDE]) {\r\n#ifdef CONFIG_IP_MULTICAST\r\nstruct ip_sf_list *psf;\r\n#endif\r\npmc->sfmode = MCAST_INCLUDE;\r\n#ifdef CONFIG_IP_MULTICAST\r\npmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\r\nIGMP_Unsolicited_Report_Count;\r\nin_dev->mr_ifc_count = pmc->crcount;\r\nfor (psf=pmc->sources; psf; psf = psf->sf_next)\r\npsf->sf_crcount = 0;\r\nigmp_ifc_event(pmc->interface);\r\n} else if (sf_setstate(pmc) || changerec) {\r\nigmp_ifc_event(pmc->interface);\r\n#endif\r\n}\r\nout_unlock:\r\nspin_unlock_bh(&pmc->lock);\r\nreturn err;\r\n}\r\nstatic int ip_mc_add1_src(struct ip_mc_list *pmc, int sfmode,\r\n__be32 *psfsrc)\r\n{\r\nstruct ip_sf_list *psf, *psf_prev;\r\npsf_prev = NULL;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next) {\r\nif (psf->sf_inaddr == *psfsrc)\r\nbreak;\r\npsf_prev = psf;\r\n}\r\nif (!psf) {\r\npsf = kzalloc(sizeof(*psf), GFP_ATOMIC);\r\nif (!psf)\r\nreturn -ENOBUFS;\r\npsf->sf_inaddr = *psfsrc;\r\nif (psf_prev) {\r\npsf_prev->sf_next = psf;\r\n} else\r\npmc->sources = psf;\r\n}\r\npsf->sf_count[sfmode]++;\r\nif (psf->sf_count[sfmode] == 1) {\r\nip_rt_multicast_event(pmc->interface);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sf_markstate(struct ip_mc_list *pmc)\r\n{\r\nstruct ip_sf_list *psf;\r\nint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next)\r\nif (pmc->sfcount[MCAST_EXCLUDE]) {\r\npsf->sf_oldin = mca_xcount ==\r\npsf->sf_count[MCAST_EXCLUDE] &&\r\n!psf->sf_count[MCAST_INCLUDE];\r\n} else\r\npsf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;\r\n}\r\nstatic int sf_setstate(struct ip_mc_list *pmc)\r\n{\r\nstruct ip_sf_list *psf, *dpsf;\r\nint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\r\nint qrv = pmc->interface->mr_qrv;\r\nint new_in, rv;\r\nrv = 0;\r\nfor (psf=pmc->sources; psf; psf=psf->sf_next) {\r\nif (pmc->sfcount[MCAST_EXCLUDE]) {\r\nnew_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&\r\n!psf->sf_count[MCAST_INCLUDE];\r\n} else\r\nnew_in = psf->sf_count[MCAST_INCLUDE] != 0;\r\nif (new_in) {\r\nif (!psf->sf_oldin) {\r\nstruct ip_sf_list *prev = NULL;\r\nfor (dpsf=pmc->tomb; dpsf; dpsf=dpsf->sf_next) {\r\nif (dpsf->sf_inaddr == psf->sf_inaddr)\r\nbreak;\r\nprev = dpsf;\r\n}\r\nif (dpsf) {\r\nif (prev)\r\nprev->sf_next = dpsf->sf_next;\r\nelse\r\npmc->tomb = dpsf->sf_next;\r\nkfree(dpsf);\r\n}\r\npsf->sf_crcount = qrv;\r\nrv++;\r\n}\r\n} else if (psf->sf_oldin) {\r\npsf->sf_crcount = 0;\r\nfor (dpsf=pmc->tomb; dpsf; dpsf=dpsf->sf_next)\r\nif (dpsf->sf_inaddr == psf->sf_inaddr)\r\nbreak;\r\nif (!dpsf) {\r\ndpsf = kmalloc(sizeof(*dpsf), GFP_ATOMIC);\r\nif (!dpsf)\r\ncontinue;\r\n*dpsf = *psf;\r\ndpsf->sf_next = pmc->tomb;\r\npmc->tomb = dpsf;\r\n}\r\ndpsf->sf_crcount = qrv;\r\nrv++;\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\r\nint sfcount, __be32 *psfsrc, int delta)\r\n{\r\nstruct ip_mc_list *pmc;\r\nint isexclude;\r\nint i, err;\r\nif (!in_dev)\r\nreturn -ENODEV;\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(in_dev, pmc) {\r\nif (*pmca == pmc->multiaddr)\r\nbreak;\r\n}\r\nif (!pmc) {\r\nrcu_read_unlock();\r\nreturn -ESRCH;\r\n}\r\nspin_lock_bh(&pmc->lock);\r\nrcu_read_unlock();\r\n#ifdef CONFIG_IP_MULTICAST\r\nsf_markstate(pmc);\r\n#endif\r\nisexclude = pmc->sfmode == MCAST_EXCLUDE;\r\nif (!delta)\r\npmc->sfcount[sfmode]++;\r\nerr = 0;\r\nfor (i=0; i<sfcount; i++) {\r\nerr = ip_mc_add1_src(pmc, sfmode, &psfsrc[i]);\r\nif (err)\r\nbreak;\r\n}\r\nif (err) {\r\nint j;\r\nif (!delta)\r\npmc->sfcount[sfmode]--;\r\nfor (j=0; j<i; j++)\r\n(void) ip_mc_del1_src(pmc, sfmode, &psfsrc[j]);\r\n} else if (isexclude != (pmc->sfcount[MCAST_EXCLUDE] != 0)) {\r\n#ifdef CONFIG_IP_MULTICAST\r\nstruct ip_sf_list *psf;\r\nin_dev = pmc->interface;\r\n#endif\r\nif (pmc->sfcount[MCAST_EXCLUDE])\r\npmc->sfmode = MCAST_EXCLUDE;\r\nelse if (pmc->sfcount[MCAST_INCLUDE])\r\npmc->sfmode = MCAST_INCLUDE;\r\n#ifdef CONFIG_IP_MULTICAST\r\npmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\r\nIGMP_Unsolicited_Report_Count;\r\nin_dev->mr_ifc_count = pmc->crcount;\r\nfor (psf=pmc->sources; psf; psf = psf->sf_next)\r\npsf->sf_crcount = 0;\r\nigmp_ifc_event(in_dev);\r\n} else if (sf_setstate(pmc)) {\r\nigmp_ifc_event(in_dev);\r\n#endif\r\n}\r\nspin_unlock_bh(&pmc->lock);\r\nreturn err;\r\n}\r\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc)\r\n{\r\nstruct ip_sf_list *psf, *nextpsf;\r\nfor (psf=pmc->tomb; psf; psf=nextpsf) {\r\nnextpsf = psf->sf_next;\r\nkfree(psf);\r\n}\r\npmc->tomb = NULL;\r\nfor (psf=pmc->sources; psf; psf=nextpsf) {\r\nnextpsf = psf->sf_next;\r\nkfree(psf);\r\n}\r\npmc->sources = NULL;\r\npmc->sfmode = MCAST_EXCLUDE;\r\npmc->sfcount[MCAST_INCLUDE] = 0;\r\npmc->sfcount[MCAST_EXCLUDE] = 1;\r\n}\r\nint ip_mc_join_group(struct sock *sk , struct ip_mreqn *imr)\r\n{\r\nint err;\r\n__be32 addr = imr->imr_multiaddr.s_addr;\r\nstruct ip_mc_socklist *iml = NULL, *i;\r\nstruct in_device *in_dev;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nint ifindex;\r\nint count = 0;\r\nif (!ipv4_is_multicast(addr))\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nin_dev = ip_mc_find_dev(net, imr);\r\nif (!in_dev) {\r\niml = NULL;\r\nerr = -ENODEV;\r\ngoto done;\r\n}\r\nerr = -EADDRINUSE;\r\nifindex = imr->imr_ifindex;\r\nfor_each_pmc_rtnl(inet, i) {\r\nif (i->multi.imr_multiaddr.s_addr == addr &&\r\ni->multi.imr_ifindex == ifindex)\r\ngoto done;\r\ncount++;\r\n}\r\nerr = -ENOBUFS;\r\nif (count >= sysctl_igmp_max_memberships)\r\ngoto done;\r\niml = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL);\r\nif (iml == NULL)\r\ngoto done;\r\nmemcpy(&iml->multi, imr, sizeof(*imr));\r\niml->next_rcu = inet->mc_list;\r\niml->sflist = NULL;\r\niml->sfmode = MCAST_EXCLUDE;\r\nrcu_assign_pointer(inet->mc_list, iml);\r\nip_mc_inc_group(in_dev, addr);\r\nerr = 0;\r\ndone:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int ip_mc_leave_src(struct sock *sk, struct ip_mc_socklist *iml,\r\nstruct in_device *in_dev)\r\n{\r\nstruct ip_sf_socklist *psf = rtnl_dereference(iml->sflist);\r\nint err;\r\nif (psf == NULL) {\r\nreturn ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\r\niml->sfmode, 0, NULL, 0);\r\n}\r\nerr = ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\r\niml->sfmode, psf->sl_count, psf->sl_addr, 0);\r\nRCU_INIT_POINTER(iml->sflist, NULL);\r\natomic_sub(IP_SFLSIZE(psf->sl_max), &sk->sk_omem_alloc);\r\nkfree_rcu(psf, rcu);\r\nreturn err;\r\n}\r\nint ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_mc_socklist *iml;\r\nstruct ip_mc_socklist __rcu **imlp;\r\nstruct in_device *in_dev;\r\nstruct net *net = sock_net(sk);\r\n__be32 group = imr->imr_multiaddr.s_addr;\r\nu32 ifindex;\r\nint ret = -EADDRNOTAVAIL;\r\nrtnl_lock();\r\nin_dev = ip_mc_find_dev(net, imr);\r\nifindex = imr->imr_ifindex;\r\nfor (imlp = &inet->mc_list;\r\n(iml = rtnl_dereference(*imlp)) != NULL;\r\nimlp = &iml->next_rcu) {\r\nif (iml->multi.imr_multiaddr.s_addr != group)\r\ncontinue;\r\nif (ifindex) {\r\nif (iml->multi.imr_ifindex != ifindex)\r\ncontinue;\r\n} else if (imr->imr_address.s_addr && imr->imr_address.s_addr !=\r\niml->multi.imr_address.s_addr)\r\ncontinue;\r\n(void) ip_mc_leave_src(sk, iml, in_dev);\r\n*imlp = iml->next_rcu;\r\nif (in_dev)\r\nip_mc_dec_group(in_dev, group);\r\nrtnl_unlock();\r\natomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\r\nkfree_rcu(iml, rcu);\r\nreturn 0;\r\n}\r\nif (!in_dev)\r\nret = -ENODEV;\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nint ip_mc_source(int add, int omode, struct sock *sk, struct\r\nip_mreq_source *mreqs, int ifindex)\r\n{\r\nint err;\r\nstruct ip_mreqn imr;\r\n__be32 addr = mreqs->imr_multiaddr;\r\nstruct ip_mc_socklist *pmc;\r\nstruct in_device *in_dev = NULL;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_sf_socklist *psl;\r\nstruct net *net = sock_net(sk);\r\nint leavegroup = 0;\r\nint i, j, rv;\r\nif (!ipv4_is_multicast(addr))\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nimr.imr_multiaddr.s_addr = mreqs->imr_multiaddr;\r\nimr.imr_address.s_addr = mreqs->imr_interface;\r\nimr.imr_ifindex = ifindex;\r\nin_dev = ip_mc_find_dev(net, &imr);\r\nif (!in_dev) {\r\nerr = -ENODEV;\r\ngoto done;\r\n}\r\nerr = -EADDRNOTAVAIL;\r\nfor_each_pmc_rtnl(inet, pmc) {\r\nif ((pmc->multi.imr_multiaddr.s_addr ==\r\nimr.imr_multiaddr.s_addr) &&\r\n(pmc->multi.imr_ifindex == imr.imr_ifindex))\r\nbreak;\r\n}\r\nif (!pmc) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (pmc->sflist) {\r\nif (pmc->sfmode != omode) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\n} else if (pmc->sfmode != omode) {\r\nip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 0, NULL, 0);\r\nip_mc_del_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0,\r\nNULL, 0);\r\npmc->sfmode = omode;\r\n}\r\npsl = rtnl_dereference(pmc->sflist);\r\nif (!add) {\r\nif (!psl)\r\ngoto done;\r\nrv = !0;\r\nfor (i=0; i<psl->sl_count; i++) {\r\nrv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\r\nsizeof(__be32));\r\nif (rv == 0)\r\nbreak;\r\n}\r\nif (rv)\r\ngoto done;\r\nif (psl->sl_count == 1 && omode == MCAST_INCLUDE) {\r\nleavegroup = 1;\r\ngoto done;\r\n}\r\nip_mc_del_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\r\n&mreqs->imr_sourceaddr, 1);\r\nfor (j=i+1; j<psl->sl_count; j++)\r\npsl->sl_addr[j-1] = psl->sl_addr[j];\r\npsl->sl_count--;\r\nerr = 0;\r\ngoto done;\r\n}\r\nif (psl && psl->sl_count >= sysctl_igmp_max_msf) {\r\nerr = -ENOBUFS;\r\ngoto done;\r\n}\r\nif (!psl || psl->sl_count == psl->sl_max) {\r\nstruct ip_sf_socklist *newpsl;\r\nint count = IP_SFBLOCK;\r\nif (psl)\r\ncount += psl->sl_max;\r\nnewpsl = sock_kmalloc(sk, IP_SFLSIZE(count), GFP_KERNEL);\r\nif (!newpsl) {\r\nerr = -ENOBUFS;\r\ngoto done;\r\n}\r\nnewpsl->sl_max = count;\r\nnewpsl->sl_count = count - IP_SFBLOCK;\r\nif (psl) {\r\nfor (i=0; i<psl->sl_count; i++)\r\nnewpsl->sl_addr[i] = psl->sl_addr[i];\r\natomic_sub(IP_SFLSIZE(psl->sl_max), &sk->sk_omem_alloc);\r\nkfree_rcu(psl, rcu);\r\n}\r\nrcu_assign_pointer(pmc->sflist, newpsl);\r\npsl = newpsl;\r\n}\r\nrv = 1;\r\nfor (i=0; i<psl->sl_count; i++) {\r\nrv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\r\nsizeof(__be32));\r\nif (rv == 0)\r\nbreak;\r\n}\r\nif (rv == 0)\r\ngoto done;\r\nfor (j=psl->sl_count-1; j>=i; j--)\r\npsl->sl_addr[j+1] = psl->sl_addr[j];\r\npsl->sl_addr[i] = mreqs->imr_sourceaddr;\r\npsl->sl_count++;\r\nerr = 0;\r\nip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\r\n&mreqs->imr_sourceaddr, 1);\r\ndone:\r\nrtnl_unlock();\r\nif (leavegroup)\r\nreturn ip_mc_leave_group(sk, &imr);\r\nreturn err;\r\n}\r\nint ip_mc_msfilter(struct sock *sk, struct ip_msfilter *msf, int ifindex)\r\n{\r\nint err = 0;\r\nstruct ip_mreqn imr;\r\n__be32 addr = msf->imsf_multiaddr;\r\nstruct ip_mc_socklist *pmc;\r\nstruct in_device *in_dev;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_sf_socklist *newpsl, *psl;\r\nstruct net *net = sock_net(sk);\r\nint leavegroup = 0;\r\nif (!ipv4_is_multicast(addr))\r\nreturn -EINVAL;\r\nif (msf->imsf_fmode != MCAST_INCLUDE &&\r\nmsf->imsf_fmode != MCAST_EXCLUDE)\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nimr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\r\nimr.imr_address.s_addr = msf->imsf_interface;\r\nimr.imr_ifindex = ifindex;\r\nin_dev = ip_mc_find_dev(net, &imr);\r\nif (!in_dev) {\r\nerr = -ENODEV;\r\ngoto done;\r\n}\r\nif (msf->imsf_fmode == MCAST_INCLUDE && msf->imsf_numsrc == 0) {\r\nleavegroup = 1;\r\ngoto done;\r\n}\r\nfor_each_pmc_rtnl(inet, pmc) {\r\nif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\r\npmc->multi.imr_ifindex == imr.imr_ifindex)\r\nbreak;\r\n}\r\nif (!pmc) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (msf->imsf_numsrc) {\r\nnewpsl = sock_kmalloc(sk, IP_SFLSIZE(msf->imsf_numsrc),\r\nGFP_KERNEL);\r\nif (!newpsl) {\r\nerr = -ENOBUFS;\r\ngoto done;\r\n}\r\nnewpsl->sl_max = newpsl->sl_count = msf->imsf_numsrc;\r\nmemcpy(newpsl->sl_addr, msf->imsf_slist,\r\nmsf->imsf_numsrc * sizeof(msf->imsf_slist[0]));\r\nerr = ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\r\nmsf->imsf_fmode, newpsl->sl_count, newpsl->sl_addr, 0);\r\nif (err) {\r\nsock_kfree_s(sk, newpsl, IP_SFLSIZE(newpsl->sl_max));\r\ngoto done;\r\n}\r\n} else {\r\nnewpsl = NULL;\r\n(void) ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\r\nmsf->imsf_fmode, 0, NULL, 0);\r\n}\r\npsl = rtnl_dereference(pmc->sflist);\r\nif (psl) {\r\n(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\r\npsl->sl_count, psl->sl_addr, 0);\r\natomic_sub(IP_SFLSIZE(psl->sl_max), &sk->sk_omem_alloc);\r\nkfree_rcu(psl, rcu);\r\n} else\r\n(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\r\n0, NULL, 0);\r\nrcu_assign_pointer(pmc->sflist, newpsl);\r\npmc->sfmode = msf->imsf_fmode;\r\nerr = 0;\r\ndone:\r\nrtnl_unlock();\r\nif (leavegroup)\r\nerr = ip_mc_leave_group(sk, &imr);\r\nreturn err;\r\n}\r\nint ip_mc_msfget(struct sock *sk, struct ip_msfilter *msf,\r\nstruct ip_msfilter __user *optval, int __user *optlen)\r\n{\r\nint err, len, count, copycount;\r\nstruct ip_mreqn imr;\r\n__be32 addr = msf->imsf_multiaddr;\r\nstruct ip_mc_socklist *pmc;\r\nstruct in_device *in_dev;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_sf_socklist *psl;\r\nstruct net *net = sock_net(sk);\r\nif (!ipv4_is_multicast(addr))\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nimr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\r\nimr.imr_address.s_addr = msf->imsf_interface;\r\nimr.imr_ifindex = 0;\r\nin_dev = ip_mc_find_dev(net, &imr);\r\nif (!in_dev) {\r\nerr = -ENODEV;\r\ngoto done;\r\n}\r\nerr = -EADDRNOTAVAIL;\r\nfor_each_pmc_rtnl(inet, pmc) {\r\nif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\r\npmc->multi.imr_ifindex == imr.imr_ifindex)\r\nbreak;\r\n}\r\nif (!pmc)\r\ngoto done;\r\nmsf->imsf_fmode = pmc->sfmode;\r\npsl = rtnl_dereference(pmc->sflist);\r\nrtnl_unlock();\r\nif (!psl) {\r\nlen = 0;\r\ncount = 0;\r\n} else {\r\ncount = psl->sl_count;\r\n}\r\ncopycount = count < msf->imsf_numsrc ? count : msf->imsf_numsrc;\r\nlen = copycount * sizeof(psl->sl_addr[0]);\r\nmsf->imsf_numsrc = count;\r\nif (put_user(IP_MSFILTER_SIZE(copycount), optlen) ||\r\ncopy_to_user(optval, msf, IP_MSFILTER_SIZE(0))) {\r\nreturn -EFAULT;\r\n}\r\nif (len &&\r\ncopy_to_user(&optval->imsf_slist[0], psl->sl_addr, len))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndone:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint ip_mc_gsfget(struct sock *sk, struct group_filter *gsf,\r\nstruct group_filter __user *optval, int __user *optlen)\r\n{\r\nint err, i, count, copycount;\r\nstruct sockaddr_in *psin;\r\n__be32 addr;\r\nstruct ip_mc_socklist *pmc;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_sf_socklist *psl;\r\npsin = (struct sockaddr_in *)&gsf->gf_group;\r\nif (psin->sin_family != AF_INET)\r\nreturn -EINVAL;\r\naddr = psin->sin_addr.s_addr;\r\nif (!ipv4_is_multicast(addr))\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nerr = -EADDRNOTAVAIL;\r\nfor_each_pmc_rtnl(inet, pmc) {\r\nif (pmc->multi.imr_multiaddr.s_addr == addr &&\r\npmc->multi.imr_ifindex == gsf->gf_interface)\r\nbreak;\r\n}\r\nif (!pmc)\r\ngoto done;\r\ngsf->gf_fmode = pmc->sfmode;\r\npsl = rtnl_dereference(pmc->sflist);\r\nrtnl_unlock();\r\ncount = psl ? psl->sl_count : 0;\r\ncopycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;\r\ngsf->gf_numsrc = count;\r\nif (put_user(GROUP_FILTER_SIZE(copycount), optlen) ||\r\ncopy_to_user(optval, gsf, GROUP_FILTER_SIZE(0))) {\r\nreturn -EFAULT;\r\n}\r\nfor (i=0; i<copycount; i++) {\r\nstruct sockaddr_storage ss;\r\npsin = (struct sockaddr_in *)&ss;\r\nmemset(&ss, 0, sizeof(ss));\r\npsin->sin_family = AF_INET;\r\npsin->sin_addr.s_addr = psl->sl_addr[i];\r\nif (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\ndone:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint ip_mc_sf_allow(struct sock *sk, __be32 loc_addr, __be32 rmt_addr, int dif)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_mc_socklist *pmc;\r\nstruct ip_sf_socklist *psl;\r\nint i;\r\nint ret;\r\nret = 1;\r\nif (!ipv4_is_multicast(loc_addr))\r\ngoto out;\r\nrcu_read_lock();\r\nfor_each_pmc_rcu(inet, pmc) {\r\nif (pmc->multi.imr_multiaddr.s_addr == loc_addr &&\r\npmc->multi.imr_ifindex == dif)\r\nbreak;\r\n}\r\nret = inet->mc_all;\r\nif (!pmc)\r\ngoto unlock;\r\npsl = rcu_dereference(pmc->sflist);\r\nret = (pmc->sfmode == MCAST_EXCLUDE);\r\nif (!psl)\r\ngoto unlock;\r\nfor (i=0; i<psl->sl_count; i++) {\r\nif (psl->sl_addr[i] == rmt_addr)\r\nbreak;\r\n}\r\nret = 0;\r\nif (pmc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)\r\ngoto unlock;\r\nif (pmc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)\r\ngoto unlock;\r\nret = 1;\r\nunlock:\r\nrcu_read_unlock();\r\nout:\r\nreturn ret;\r\n}\r\nvoid ip_mc_drop_socket(struct sock *sk)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ip_mc_socklist *iml;\r\nstruct net *net = sock_net(sk);\r\nif (inet->mc_list == NULL)\r\nreturn;\r\nrtnl_lock();\r\nwhile ((iml = rtnl_dereference(inet->mc_list)) != NULL) {\r\nstruct in_device *in_dev;\r\ninet->mc_list = iml->next_rcu;\r\nin_dev = inetdev_by_index(net, iml->multi.imr_ifindex);\r\n(void) ip_mc_leave_src(sk, iml, in_dev);\r\nif (in_dev != NULL)\r\nip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);\r\natomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\r\nkfree_rcu(iml, rcu);\r\n}\r\nrtnl_unlock();\r\n}\r\nint ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u16 proto)\r\n{\r\nstruct ip_mc_list *im;\r\nstruct ip_sf_list *psf;\r\nint rv = 0;\r\nfor_each_pmc_rcu(in_dev, im) {\r\nif (im->multiaddr == mc_addr)\r\nbreak;\r\n}\r\nif (im && proto == IPPROTO_IGMP) {\r\nrv = 1;\r\n} else if (im) {\r\nif (src_addr) {\r\nfor (psf=im->sources; psf; psf=psf->sf_next) {\r\nif (psf->sf_inaddr == src_addr)\r\nbreak;\r\n}\r\nif (psf)\r\nrv = psf->sf_count[MCAST_INCLUDE] ||\r\npsf->sf_count[MCAST_EXCLUDE] !=\r\nim->sfcount[MCAST_EXCLUDE];\r\nelse\r\nrv = im->sfcount[MCAST_EXCLUDE] != 0;\r\n} else\r\nrv = 1;\r\n}\r\nreturn rv;\r\n}\r\nstatic inline struct ip_mc_list *igmp_mc_get_first(struct seq_file *seq)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ip_mc_list *im = NULL;\r\nstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\r\nstate->in_dev = NULL;\r\nfor_each_netdev_rcu(net, state->dev) {\r\nstruct in_device *in_dev;\r\nin_dev = __in_dev_get_rcu(state->dev);\r\nif (!in_dev)\r\ncontinue;\r\nim = rcu_dereference(in_dev->mc_list);\r\nif (im) {\r\nstate->in_dev = in_dev;\r\nbreak;\r\n}\r\n}\r\nreturn im;\r\n}\r\nstatic struct ip_mc_list *igmp_mc_get_next(struct seq_file *seq, struct ip_mc_list *im)\r\n{\r\nstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\r\nim = rcu_dereference(im->next_rcu);\r\nwhile (!im) {\r\nstate->dev = next_net_device_rcu(state->dev);\r\nif (!state->dev) {\r\nstate->in_dev = NULL;\r\nbreak;\r\n}\r\nstate->in_dev = __in_dev_get_rcu(state->dev);\r\nif (!state->in_dev)\r\ncontinue;\r\nim = rcu_dereference(state->in_dev->mc_list);\r\n}\r\nreturn im;\r\n}\r\nstatic struct ip_mc_list *igmp_mc_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ip_mc_list *im = igmp_mc_get_first(seq);\r\nif (im)\r\nwhile (pos && (im = igmp_mc_get_next(seq, im)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : im;\r\n}\r\nstatic void *igmp_mc_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rcu)\r\n{\r\nrcu_read_lock();\r\nreturn *pos ? igmp_mc_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *igmp_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ip_mc_list *im;\r\nif (v == SEQ_START_TOKEN)\r\nim = igmp_mc_get_first(seq);\r\nelse\r\nim = igmp_mc_get_next(seq, v);\r\n++*pos;\r\nreturn im;\r\n}\r\nstatic void igmp_mc_seq_stop(struct seq_file *seq, void *v)\r\n__releases(rcu)\r\n{\r\nstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\r\nstate->in_dev = NULL;\r\nstate->dev = NULL;\r\nrcu_read_unlock();\r\n}\r\nstatic int igmp_mc_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"Idx\tDevice : Count Querier\tGroup Users Timer\tReporter\n");\r\nelse {\r\nstruct ip_mc_list *im = (struct ip_mc_list *)v;\r\nstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\r\nchar *querier;\r\nlong delta;\r\n#ifdef CONFIG_IP_MULTICAST\r\nquerier = IGMP_V1_SEEN(state->in_dev) ? "V1" :\r\nIGMP_V2_SEEN(state->in_dev) ? "V2" :\r\n"V3";\r\n#else\r\nquerier = "NONE";\r\n#endif\r\nif (rcu_dereference(state->in_dev->mc_list) == im) {\r\nseq_printf(seq, "%d\t%-10s: %5d %7s\n",\r\nstate->dev->ifindex, state->dev->name, state->in_dev->mc_count, querier);\r\n}\r\ndelta = im->timer.expires - jiffies;\r\nseq_printf(seq,\r\n"\t\t\t\t%08X %5d %d:%08lX\t\t%d\n",\r\nim->multiaddr, im->users,\r\nim->tm_running,\r\nim->tm_running ? jiffies_delta_to_clock_t(delta) : 0,\r\nim->reporter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int igmp_mc_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &igmp_mc_seq_ops,\r\nsizeof(struct igmp_mc_iter_state));\r\n}\r\nstatic inline struct ip_sf_list *igmp_mcf_get_first(struct seq_file *seq)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ip_sf_list *psf = NULL;\r\nstruct ip_mc_list *im = NULL;\r\nstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\r\nstate->idev = NULL;\r\nstate->im = NULL;\r\nfor_each_netdev_rcu(net, state->dev) {\r\nstruct in_device *idev;\r\nidev = __in_dev_get_rcu(state->dev);\r\nif (unlikely(idev == NULL))\r\ncontinue;\r\nim = rcu_dereference(idev->mc_list);\r\nif (likely(im != NULL)) {\r\nspin_lock_bh(&im->lock);\r\npsf = im->sources;\r\nif (likely(psf != NULL)) {\r\nstate->im = im;\r\nstate->idev = idev;\r\nbreak;\r\n}\r\nspin_unlock_bh(&im->lock);\r\n}\r\n}\r\nreturn psf;\r\n}\r\nstatic struct ip_sf_list *igmp_mcf_get_next(struct seq_file *seq, struct ip_sf_list *psf)\r\n{\r\nstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\r\npsf = psf->sf_next;\r\nwhile (!psf) {\r\nspin_unlock_bh(&state->im->lock);\r\nstate->im = state->im->next;\r\nwhile (!state->im) {\r\nstate->dev = next_net_device_rcu(state->dev);\r\nif (!state->dev) {\r\nstate->idev = NULL;\r\ngoto out;\r\n}\r\nstate->idev = __in_dev_get_rcu(state->dev);\r\nif (!state->idev)\r\ncontinue;\r\nstate->im = rcu_dereference(state->idev->mc_list);\r\n}\r\nif (!state->im)\r\nbreak;\r\nspin_lock_bh(&state->im->lock);\r\npsf = state->im->sources;\r\n}\r\nout:\r\nreturn psf;\r\n}\r\nstatic struct ip_sf_list *igmp_mcf_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ip_sf_list *psf = igmp_mcf_get_first(seq);\r\nif (psf)\r\nwhile (pos && (psf = igmp_mcf_get_next(seq, psf)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : psf;\r\n}\r\nstatic void *igmp_mcf_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rcu)\r\n{\r\nrcu_read_lock();\r\nreturn *pos ? igmp_mcf_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *igmp_mcf_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ip_sf_list *psf;\r\nif (v == SEQ_START_TOKEN)\r\npsf = igmp_mcf_get_first(seq);\r\nelse\r\npsf = igmp_mcf_get_next(seq, v);\r\n++*pos;\r\nreturn psf;\r\n}\r\nstatic void igmp_mcf_seq_stop(struct seq_file *seq, void *v)\r\n__releases(rcu)\r\n{\r\nstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\r\nif (likely(state->im != NULL)) {\r\nspin_unlock_bh(&state->im->lock);\r\nstate->im = NULL;\r\n}\r\nstate->idev = NULL;\r\nstate->dev = NULL;\r\nrcu_read_unlock();\r\n}\r\nstatic int igmp_mcf_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ip_sf_list *psf = (struct ip_sf_list *)v;\r\nstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq,\r\n"%3s %6s "\r\n"%10s %10s %6s %6s\n", "Idx",\r\n"Device", "MCA",\r\n"SRC", "INC", "EXC");\r\n} else {\r\nseq_printf(seq,\r\n"%3d %6.6s 0x%08x "\r\n"0x%08x %6lu %6lu\n",\r\nstate->dev->ifindex, state->dev->name,\r\nntohl(state->im->multiaddr),\r\nntohl(psf->sf_inaddr),\r\npsf->sf_count[MCAST_INCLUDE],\r\npsf->sf_count[MCAST_EXCLUDE]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int igmp_mcf_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &igmp_mcf_seq_ops,\r\nsizeof(struct igmp_mcf_iter_state));\r\n}\r\nstatic int __net_init igmp_net_init(struct net *net)\r\n{\r\nstruct proc_dir_entry *pde;\r\npde = proc_net_fops_create(net, "igmp", S_IRUGO, &igmp_mc_seq_fops);\r\nif (!pde)\r\ngoto out_igmp;\r\npde = proc_net_fops_create(net, "mcfilter", S_IRUGO, &igmp_mcf_seq_fops);\r\nif (!pde)\r\ngoto out_mcfilter;\r\nreturn 0;\r\nout_mcfilter:\r\nproc_net_remove(net, "igmp");\r\nout_igmp:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit igmp_net_exit(struct net *net)\r\n{\r\nproc_net_remove(net, "mcfilter");\r\nproc_net_remove(net, "igmp");\r\n}\r\nint __init igmp_mc_proc_init(void)\r\n{\r\nreturn register_pernet_subsys(&igmp_net_ops);\r\n}
