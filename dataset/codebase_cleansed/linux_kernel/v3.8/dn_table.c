static inline dn_fib_idx_t dn_hash(dn_fib_key_t key, struct dn_zone *dz)\r\n{\r\nu16 h = le16_to_cpu(key.datum)>>(16 - dz->dz_order);\r\nh ^= (h >> 10);\r\nh ^= (h >> 6);\r\nh &= DZ_HASHMASK(dz);\r\nreturn *(dn_fib_idx_t *)&h;\r\n}\r\nstatic inline dn_fib_key_t dz_key(__le16 dst, struct dn_zone *dz)\r\n{\r\ndn_fib_key_t k;\r\nk.datum = dst & DZ_MASK(dz);\r\nreturn k;\r\n}\r\nstatic inline struct dn_fib_node **dn_chain_p(dn_fib_key_t key, struct dn_zone *dz)\r\n{\r\nreturn &dz->dz_hash[dn_hash(key, dz).datum];\r\n}\r\nstatic inline struct dn_fib_node *dz_chain(dn_fib_key_t key, struct dn_zone *dz)\r\n{\r\nreturn dz->dz_hash[dn_hash(key, dz).datum];\r\n}\r\nstatic inline int dn_key_eq(dn_fib_key_t a, dn_fib_key_t b)\r\n{\r\nreturn a.datum == b.datum;\r\n}\r\nstatic inline int dn_key_leq(dn_fib_key_t a, dn_fib_key_t b)\r\n{\r\nreturn a.datum <= b.datum;\r\n}\r\nstatic inline void dn_rebuild_zone(struct dn_zone *dz,\r\nstruct dn_fib_node **old_ht,\r\nint old_divisor)\r\n{\r\nstruct dn_fib_node *f, **fp, *next;\r\nint i;\r\nfor(i = 0; i < old_divisor; i++) {\r\nfor(f = old_ht[i]; f; f = next) {\r\nnext = f->fn_next;\r\nfor(fp = dn_chain_p(f->fn_key, dz);\r\n*fp && dn_key_leq((*fp)->fn_key, f->fn_key);\r\nfp = &(*fp)->fn_next)\r\n;\r\nf->fn_next = *fp;\r\n*fp = f;\r\n}\r\n}\r\n}\r\nstatic void dn_rehash_zone(struct dn_zone *dz)\r\n{\r\nstruct dn_fib_node **ht, **old_ht;\r\nint old_divisor, new_divisor;\r\nu32 new_hashmask;\r\nold_divisor = dz->dz_divisor;\r\nswitch (old_divisor) {\r\ncase 16:\r\nnew_divisor = 256;\r\nnew_hashmask = 0xFF;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "DECnet: dn_rehash_zone: BUG! %d\n",\r\nold_divisor);\r\ncase 256:\r\nnew_divisor = 1024;\r\nnew_hashmask = 0x3FF;\r\nbreak;\r\n}\r\nht = kcalloc(new_divisor, sizeof(struct dn_fib_node*), GFP_KERNEL);\r\nif (ht == NULL)\r\nreturn;\r\nwrite_lock_bh(&dn_fib_tables_lock);\r\nold_ht = dz->dz_hash;\r\ndz->dz_hash = ht;\r\ndz->dz_hashmask = new_hashmask;\r\ndz->dz_divisor = new_divisor;\r\ndn_rebuild_zone(dz, old_ht, old_divisor);\r\nwrite_unlock_bh(&dn_fib_tables_lock);\r\nkfree(old_ht);\r\n}\r\nstatic void dn_free_node(struct dn_fib_node *f)\r\n{\r\ndn_fib_release_info(DN_FIB_INFO(f));\r\nkmem_cache_free(dn_hash_kmem, f);\r\n}\r\nstatic struct dn_zone *dn_new_zone(struct dn_hash *table, int z)\r\n{\r\nint i;\r\nstruct dn_zone *dz = kzalloc(sizeof(struct dn_zone), GFP_KERNEL);\r\nif (!dz)\r\nreturn NULL;\r\nif (z) {\r\ndz->dz_divisor = 16;\r\ndz->dz_hashmask = 0x0F;\r\n} else {\r\ndz->dz_divisor = 1;\r\ndz->dz_hashmask = 0;\r\n}\r\ndz->dz_hash = kcalloc(dz->dz_divisor, sizeof(struct dn_fib_node *), GFP_KERNEL);\r\nif (!dz->dz_hash) {\r\nkfree(dz);\r\nreturn NULL;\r\n}\r\ndz->dz_order = z;\r\ndz->dz_mask = dnet_make_mask(z);\r\nfor(i = z + 1; i <= 16; i++)\r\nif (table->dh_zones[i])\r\nbreak;\r\nwrite_lock_bh(&dn_fib_tables_lock);\r\nif (i>16) {\r\ndz->dz_next = table->dh_zone_list;\r\ntable->dh_zone_list = dz;\r\n} else {\r\ndz->dz_next = table->dh_zones[i]->dz_next;\r\ntable->dh_zones[i]->dz_next = dz;\r\n}\r\ntable->dh_zones[z] = dz;\r\nwrite_unlock_bh(&dn_fib_tables_lock);\r\nreturn dz;\r\n}\r\nstatic int dn_fib_nh_match(struct rtmsg *r, struct nlmsghdr *nlh, struct dn_kern_rta *rta, struct dn_fib_info *fi)\r\n{\r\nstruct rtnexthop *nhp;\r\nint nhlen;\r\nif (rta->rta_priority && *rta->rta_priority != fi->fib_priority)\r\nreturn 1;\r\nif (rta->rta_oif || rta->rta_gw) {\r\nif ((!rta->rta_oif || *rta->rta_oif == fi->fib_nh->nh_oif) &&\r\n(!rta->rta_gw || memcmp(rta->rta_gw, &fi->fib_nh->nh_gw, 2) == 0))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif (rta->rta_mp == NULL)\r\nreturn 0;\r\nnhp = RTA_DATA(rta->rta_mp);\r\nnhlen = RTA_PAYLOAD(rta->rta_mp);\r\nfor_nexthops(fi) {\r\nint attrlen = nhlen - sizeof(struct rtnexthop);\r\n__le16 gw;\r\nif (attrlen < 0 || (nhlen -= nhp->rtnh_len) < 0)\r\nreturn -EINVAL;\r\nif (nhp->rtnh_ifindex && nhp->rtnh_ifindex != nh->nh_oif)\r\nreturn 1;\r\nif (attrlen) {\r\ngw = dn_fib_get_attr16(RTNH_DATA(nhp), attrlen, RTA_GATEWAY);\r\nif (gw && gw != nh->nh_gw)\r\nreturn 1;\r\n}\r\nnhp = RTNH_NEXT(nhp);\r\n} endfor_nexthops(fi);\r\nreturn 0;\r\n}\r\nstatic inline size_t dn_fib_nlmsg_size(struct dn_fib_info *fi)\r\n{\r\nsize_t payload = NLMSG_ALIGN(sizeof(struct rtmsg))\r\n+ nla_total_size(4)\r\n+ nla_total_size(2)\r\n+ nla_total_size(4);\r\npayload += nla_total_size((RTAX_MAX * nla_total_size(4)));\r\nif (fi->fib_nhs) {\r\nsize_t nhsize = nla_total_size(sizeof(struct rtnexthop));\r\nnhsize += nla_total_size(4);\r\npayload += nla_total_size(fi->fib_nhs * nhsize);\r\n}\r\nreturn payload;\r\n}\r\nstatic int dn_fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,\r\nu32 tb_id, u8 type, u8 scope, void *dst, int dst_len,\r\nstruct dn_fib_info *fi, unsigned int flags)\r\n{\r\nstruct rtmsg *rtm;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nrtm = nlmsg_data(nlh);\r\nrtm->rtm_family = AF_DECnet;\r\nrtm->rtm_dst_len = dst_len;\r\nrtm->rtm_src_len = 0;\r\nrtm->rtm_tos = 0;\r\nrtm->rtm_table = tb_id;\r\nrtm->rtm_flags = fi->fib_flags;\r\nrtm->rtm_scope = scope;\r\nrtm->rtm_type = type;\r\nrtm->rtm_protocol = fi->fib_protocol;\r\nif (nla_put_u32(skb, RTA_TABLE, tb_id) < 0)\r\ngoto errout;\r\nif (rtm->rtm_dst_len &&\r\nnla_put(skb, RTA_DST, 2, dst) < 0)\r\ngoto errout;\r\nif (fi->fib_priority &&\r\nnla_put_u32(skb, RTA_PRIORITY, fi->fib_priority) < 0)\r\ngoto errout;\r\nif (rtnetlink_put_metrics(skb, fi->fib_metrics) < 0)\r\ngoto errout;\r\nif (fi->fib_nhs == 1) {\r\nif (fi->fib_nh->nh_gw &&\r\nnla_put_le16(skb, RTA_GATEWAY, fi->fib_nh->nh_gw) < 0)\r\ngoto errout;\r\nif (fi->fib_nh->nh_oif &&\r\nnla_put_u32(skb, RTA_OIF, fi->fib_nh->nh_oif) < 0)\r\ngoto errout;\r\n}\r\nif (fi->fib_nhs > 1) {\r\nstruct rtnexthop *nhp;\r\nstruct nlattr *mp_head;\r\nif (!(mp_head = nla_nest_start(skb, RTA_MULTIPATH)))\r\ngoto errout;\r\nfor_nexthops(fi) {\r\nif (!(nhp = nla_reserve_nohdr(skb, sizeof(*nhp))))\r\ngoto errout;\r\nnhp->rtnh_flags = nh->nh_flags & 0xFF;\r\nnhp->rtnh_hops = nh->nh_weight - 1;\r\nnhp->rtnh_ifindex = nh->nh_oif;\r\nif (nh->nh_gw &&\r\nnla_put_le16(skb, RTA_GATEWAY, nh->nh_gw) < 0)\r\ngoto errout;\r\nnhp->rtnh_len = skb_tail_pointer(skb) - (unsigned char *)nhp;\r\n} endfor_nexthops(fi);\r\nnla_nest_end(skb, mp_head);\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\nerrout:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void dn_rtmsg_fib(int event, struct dn_fib_node *f, int z, u32 tb_id,\r\nstruct nlmsghdr *nlh, struct netlink_skb_parms *req)\r\n{\r\nstruct sk_buff *skb;\r\nu32 portid = req ? req->portid : 0;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(dn_fib_nlmsg_size(DN_FIB_INFO(f)), GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = dn_fib_dump_info(skb, portid, nlh->nlmsg_seq, event, tb_id,\r\nf->fn_type, f->fn_scope, &f->fn_key, z,\r\nDN_FIB_INFO(f), 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, &init_net, portid, RTNLGRP_DECnet_ROUTE, nlh, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(&init_net, RTNLGRP_DECnet_ROUTE, err);\r\n}\r\nstatic __inline__ int dn_hash_dump_bucket(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct dn_fib_table *tb,\r\nstruct dn_zone *dz,\r\nstruct dn_fib_node *f)\r\n{\r\nint i, s_i;\r\ns_i = cb->args[4];\r\nfor(i = 0; f; i++, f = f->fn_next) {\r\nif (i < s_i)\r\ncontinue;\r\nif (f->fn_state & DN_S_ZOMBIE)\r\ncontinue;\r\nif (dn_fib_dump_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWROUTE,\r\ntb->n,\r\n(f->fn_state & DN_S_ZOMBIE) ? 0 : f->fn_type,\r\nf->fn_scope, &f->fn_key, dz->dz_order,\r\nf->fn_info, NLM_F_MULTI) < 0) {\r\ncb->args[4] = i;\r\nreturn -1;\r\n}\r\n}\r\ncb->args[4] = i;\r\nreturn skb->len;\r\n}\r\nstatic __inline__ int dn_hash_dump_zone(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct dn_fib_table *tb,\r\nstruct dn_zone *dz)\r\n{\r\nint h, s_h;\r\ns_h = cb->args[3];\r\nfor(h = 0; h < dz->dz_divisor; h++) {\r\nif (h < s_h)\r\ncontinue;\r\nif (h > s_h)\r\nmemset(&cb->args[4], 0, sizeof(cb->args) - 4*sizeof(cb->args[0]));\r\nif (dz->dz_hash == NULL || dz->dz_hash[h] == NULL)\r\ncontinue;\r\nif (dn_hash_dump_bucket(skb, cb, tb, dz, dz->dz_hash[h]) < 0) {\r\ncb->args[3] = h;\r\nreturn -1;\r\n}\r\n}\r\ncb->args[3] = h;\r\nreturn skb->len;\r\n}\r\nstatic int dn_fib_table_dump(struct dn_fib_table *tb, struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nint m, s_m;\r\nstruct dn_zone *dz;\r\nstruct dn_hash *table = (struct dn_hash *)tb->data;\r\ns_m = cb->args[2];\r\nread_lock(&dn_fib_tables_lock);\r\nfor(dz = table->dh_zone_list, m = 0; dz; dz = dz->dz_next, m++) {\r\nif (m < s_m)\r\ncontinue;\r\nif (m > s_m)\r\nmemset(&cb->args[3], 0, sizeof(cb->args) - 3*sizeof(cb->args[0]));\r\nif (dn_hash_dump_zone(skb, cb, tb, dz) < 0) {\r\ncb->args[2] = m;\r\nread_unlock(&dn_fib_tables_lock);\r\nreturn -1;\r\n}\r\n}\r\nread_unlock(&dn_fib_tables_lock);\r\ncb->args[2] = m;\r\nreturn skb->len;\r\n}\r\nint dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nunsigned int h, s_h;\r\nunsigned int e = 0, s_e;\r\nstruct dn_fib_table *tb;\r\nstruct hlist_node *node;\r\nint dumped = 0;\r\nif (!net_eq(net, &init_net))\r\nreturn 0;\r\nif (NLMSG_PAYLOAD(cb->nlh, 0) >= sizeof(struct rtmsg) &&\r\n((struct rtmsg *)nlmsg_data(cb->nlh))->rtm_flags&RTM_F_CLONED)\r\nreturn dn_cache_dump(skb, cb);\r\ns_h = cb->args[0];\r\ns_e = cb->args[1];\r\nfor (h = s_h; h < DN_FIB_TABLE_HASHSZ; h++, s_h = 0) {\r\ne = 0;\r\nhlist_for_each_entry(tb, node, &dn_fib_table_hash[h], hlist) {\r\nif (e < s_e)\r\ngoto next;\r\nif (dumped)\r\nmemset(&cb->args[2], 0, sizeof(cb->args) -\r\n2 * sizeof(cb->args[0]));\r\nif (tb->dump(tb, skb, cb) < 0)\r\ngoto out;\r\ndumped = 1;\r\nnext:\r\ne++;\r\n}\r\n}\r\nout:\r\ncb->args[1] = e;\r\ncb->args[0] = h;\r\nreturn skb->len;\r\n}\r\nstatic int dn_fib_table_insert(struct dn_fib_table *tb, struct rtmsg *r, struct dn_kern_rta *rta, struct nlmsghdr *n, struct netlink_skb_parms *req)\r\n{\r\nstruct dn_hash *table = (struct dn_hash *)tb->data;\r\nstruct dn_fib_node *new_f, *f, **fp, **del_fp;\r\nstruct dn_zone *dz;\r\nstruct dn_fib_info *fi;\r\nint z = r->rtm_dst_len;\r\nint type = r->rtm_type;\r\ndn_fib_key_t key;\r\nint err;\r\nif (z > 16)\r\nreturn -EINVAL;\r\ndz = table->dh_zones[z];\r\nif (!dz && !(dz = dn_new_zone(table, z)))\r\nreturn -ENOBUFS;\r\ndz_key_0(key);\r\nif (rta->rta_dst) {\r\n__le16 dst;\r\nmemcpy(&dst, rta->rta_dst, 2);\r\nif (dst & ~DZ_MASK(dz))\r\nreturn -EINVAL;\r\nkey = dz_key(dst, dz);\r\n}\r\nif ((fi = dn_fib_create_info(r, rta, n, &err)) == NULL)\r\nreturn err;\r\nif (dz->dz_nent > (dz->dz_divisor << 2) &&\r\ndz->dz_divisor > DN_MAX_DIVISOR &&\r\n(z==16 || (1<<z) > dz->dz_divisor))\r\ndn_rehash_zone(dz);\r\nfp = dn_chain_p(key, dz);\r\nDN_FIB_SCAN(f, fp) {\r\nif (dn_key_leq(key, f->fn_key))\r\nbreak;\r\n}\r\ndel_fp = NULL;\r\nif (f && (f->fn_state & DN_S_ZOMBIE) &&\r\ndn_key_eq(f->fn_key, key)) {\r\ndel_fp = fp;\r\nfp = &f->fn_next;\r\nf = *fp;\r\ngoto create;\r\n}\r\nDN_FIB_SCAN_KEY(f, fp, key) {\r\nif (fi->fib_priority <= DN_FIB_INFO(f)->fib_priority)\r\nbreak;\r\n}\r\nif (f && dn_key_eq(f->fn_key, key) &&\r\nfi->fib_priority == DN_FIB_INFO(f)->fib_priority) {\r\nstruct dn_fib_node **ins_fp;\r\nerr = -EEXIST;\r\nif (n->nlmsg_flags & NLM_F_EXCL)\r\ngoto out;\r\nif (n->nlmsg_flags & NLM_F_REPLACE) {\r\ndel_fp = fp;\r\nfp = &f->fn_next;\r\nf = *fp;\r\ngoto replace;\r\n}\r\nins_fp = fp;\r\nerr = -EEXIST;\r\nDN_FIB_SCAN_KEY(f, fp, key) {\r\nif (fi->fib_priority != DN_FIB_INFO(f)->fib_priority)\r\nbreak;\r\nif (f->fn_type == type &&\r\nf->fn_scope == r->rtm_scope &&\r\nDN_FIB_INFO(f) == fi)\r\ngoto out;\r\n}\r\nif (!(n->nlmsg_flags & NLM_F_APPEND)) {\r\nfp = ins_fp;\r\nf = *fp;\r\n}\r\n}\r\ncreate:\r\nerr = -ENOENT;\r\nif (!(n->nlmsg_flags & NLM_F_CREATE))\r\ngoto out;\r\nreplace:\r\nerr = -ENOBUFS;\r\nnew_f = kmem_cache_zalloc(dn_hash_kmem, GFP_KERNEL);\r\nif (new_f == NULL)\r\ngoto out;\r\nnew_f->fn_key = key;\r\nnew_f->fn_type = type;\r\nnew_f->fn_scope = r->rtm_scope;\r\nDN_FIB_INFO(new_f) = fi;\r\nnew_f->fn_next = f;\r\nwrite_lock_bh(&dn_fib_tables_lock);\r\n*fp = new_f;\r\nwrite_unlock_bh(&dn_fib_tables_lock);\r\ndz->dz_nent++;\r\nif (del_fp) {\r\nf = *del_fp;\r\nwrite_lock_bh(&dn_fib_tables_lock);\r\n*del_fp = f->fn_next;\r\nwrite_unlock_bh(&dn_fib_tables_lock);\r\nif (!(f->fn_state & DN_S_ZOMBIE))\r\ndn_rtmsg_fib(RTM_DELROUTE, f, z, tb->n, n, req);\r\nif (f->fn_state & DN_S_ACCESSED)\r\ndn_rt_cache_flush(-1);\r\ndn_free_node(f);\r\ndz->dz_nent--;\r\n} else {\r\ndn_rt_cache_flush(-1);\r\n}\r\ndn_rtmsg_fib(RTM_NEWROUTE, new_f, z, tb->n, n, req);\r\nreturn 0;\r\nout:\r\ndn_fib_release_info(fi);\r\nreturn err;\r\n}\r\nstatic int dn_fib_table_delete(struct dn_fib_table *tb, struct rtmsg *r, struct dn_kern_rta *rta, struct nlmsghdr *n, struct netlink_skb_parms *req)\r\n{\r\nstruct dn_hash *table = (struct dn_hash*)tb->data;\r\nstruct dn_fib_node **fp, **del_fp, *f;\r\nint z = r->rtm_dst_len;\r\nstruct dn_zone *dz;\r\ndn_fib_key_t key;\r\nint matched;\r\nif (z > 16)\r\nreturn -EINVAL;\r\nif ((dz = table->dh_zones[z]) == NULL)\r\nreturn -ESRCH;\r\ndz_key_0(key);\r\nif (rta->rta_dst) {\r\n__le16 dst;\r\nmemcpy(&dst, rta->rta_dst, 2);\r\nif (dst & ~DZ_MASK(dz))\r\nreturn -EINVAL;\r\nkey = dz_key(dst, dz);\r\n}\r\nfp = dn_chain_p(key, dz);\r\nDN_FIB_SCAN(f, fp) {\r\nif (dn_key_eq(f->fn_key, key))\r\nbreak;\r\nif (dn_key_leq(key, f->fn_key))\r\nreturn -ESRCH;\r\n}\r\nmatched = 0;\r\ndel_fp = NULL;\r\nDN_FIB_SCAN_KEY(f, fp, key) {\r\nstruct dn_fib_info *fi = DN_FIB_INFO(f);\r\nif (f->fn_state & DN_S_ZOMBIE)\r\nreturn -ESRCH;\r\nmatched++;\r\nif (del_fp == NULL &&\r\n(!r->rtm_type || f->fn_type == r->rtm_type) &&\r\n(r->rtm_scope == RT_SCOPE_NOWHERE || f->fn_scope == r->rtm_scope) &&\r\n(!r->rtm_protocol ||\r\nfi->fib_protocol == r->rtm_protocol) &&\r\ndn_fib_nh_match(r, n, rta, fi) == 0)\r\ndel_fp = fp;\r\n}\r\nif (del_fp) {\r\nf = *del_fp;\r\ndn_rtmsg_fib(RTM_DELROUTE, f, z, tb->n, n, req);\r\nif (matched != 1) {\r\nwrite_lock_bh(&dn_fib_tables_lock);\r\n*del_fp = f->fn_next;\r\nwrite_unlock_bh(&dn_fib_tables_lock);\r\nif (f->fn_state & DN_S_ACCESSED)\r\ndn_rt_cache_flush(-1);\r\ndn_free_node(f);\r\ndz->dz_nent--;\r\n} else {\r\nf->fn_state |= DN_S_ZOMBIE;\r\nif (f->fn_state & DN_S_ACCESSED) {\r\nf->fn_state &= ~DN_S_ACCESSED;\r\ndn_rt_cache_flush(-1);\r\n}\r\nif (++dn_fib_hash_zombies > 128)\r\ndn_fib_flush();\r\n}\r\nreturn 0;\r\n}\r\nreturn -ESRCH;\r\n}\r\nstatic inline int dn_flush_list(struct dn_fib_node **fp, int z, struct dn_hash *table)\r\n{\r\nint found = 0;\r\nstruct dn_fib_node *f;\r\nwhile((f = *fp) != NULL) {\r\nstruct dn_fib_info *fi = DN_FIB_INFO(f);\r\nif (fi && ((f->fn_state & DN_S_ZOMBIE) || (fi->fib_flags & RTNH_F_DEAD))) {\r\nwrite_lock_bh(&dn_fib_tables_lock);\r\n*fp = f->fn_next;\r\nwrite_unlock_bh(&dn_fib_tables_lock);\r\ndn_free_node(f);\r\nfound++;\r\ncontinue;\r\n}\r\nfp = &f->fn_next;\r\n}\r\nreturn found;\r\n}\r\nstatic int dn_fib_table_flush(struct dn_fib_table *tb)\r\n{\r\nstruct dn_hash *table = (struct dn_hash *)tb->data;\r\nstruct dn_zone *dz;\r\nint found = 0;\r\ndn_fib_hash_zombies = 0;\r\nfor(dz = table->dh_zone_list; dz; dz = dz->dz_next) {\r\nint i;\r\nint tmp = 0;\r\nfor(i = dz->dz_divisor-1; i >= 0; i--)\r\ntmp += dn_flush_list(&dz->dz_hash[i], dz->dz_order, table);\r\ndz->dz_nent -= tmp;\r\nfound += tmp;\r\n}\r\nreturn found;\r\n}\r\nstatic int dn_fib_table_lookup(struct dn_fib_table *tb, const struct flowidn *flp, struct dn_fib_res *res)\r\n{\r\nint err;\r\nstruct dn_zone *dz;\r\nstruct dn_hash *t = (struct dn_hash *)tb->data;\r\nread_lock(&dn_fib_tables_lock);\r\nfor(dz = t->dh_zone_list; dz; dz = dz->dz_next) {\r\nstruct dn_fib_node *f;\r\ndn_fib_key_t k = dz_key(flp->daddr, dz);\r\nfor(f = dz_chain(k, dz); f; f = f->fn_next) {\r\nif (!dn_key_eq(k, f->fn_key)) {\r\nif (dn_key_leq(k, f->fn_key))\r\nbreak;\r\nelse\r\ncontinue;\r\n}\r\nf->fn_state |= DN_S_ACCESSED;\r\nif (f->fn_state&DN_S_ZOMBIE)\r\ncontinue;\r\nif (f->fn_scope < flp->flowidn_scope)\r\ncontinue;\r\nerr = dn_fib_semantic_match(f->fn_type, DN_FIB_INFO(f), flp, res);\r\nif (err == 0) {\r\nres->type = f->fn_type;\r\nres->scope = f->fn_scope;\r\nres->prefixlen = dz->dz_order;\r\ngoto out;\r\n}\r\nif (err < 0)\r\ngoto out;\r\n}\r\n}\r\nerr = 1;\r\nout:\r\nread_unlock(&dn_fib_tables_lock);\r\nreturn err;\r\n}\r\nstruct dn_fib_table *dn_fib_get_table(u32 n, int create)\r\n{\r\nstruct dn_fib_table *t;\r\nstruct hlist_node *node;\r\nunsigned int h;\r\nif (n < RT_TABLE_MIN)\r\nreturn NULL;\r\nif (n > RT_TABLE_MAX)\r\nreturn NULL;\r\nh = n & (DN_FIB_TABLE_HASHSZ - 1);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(t, node, &dn_fib_table_hash[h], hlist) {\r\nif (t->n == n) {\r\nrcu_read_unlock();\r\nreturn t;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!create)\r\nreturn NULL;\r\nif (in_interrupt()) {\r\nnet_dbg_ratelimited("DECnet: BUG! Attempt to create routing table from interrupt\n");\r\nreturn NULL;\r\n}\r\nt = kzalloc(sizeof(struct dn_fib_table) + sizeof(struct dn_hash),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\nreturn NULL;\r\nt->n = n;\r\nt->insert = dn_fib_table_insert;\r\nt->delete = dn_fib_table_delete;\r\nt->lookup = dn_fib_table_lookup;\r\nt->flush = dn_fib_table_flush;\r\nt->dump = dn_fib_table_dump;\r\nhlist_add_head_rcu(&t->hlist, &dn_fib_table_hash[h]);\r\nreturn t;\r\n}\r\nstruct dn_fib_table *dn_fib_empty_table(void)\r\n{\r\nu32 id;\r\nfor(id = RT_TABLE_MIN; id <= RT_TABLE_MAX; id++)\r\nif (dn_fib_get_table(id, 0) == NULL)\r\nreturn dn_fib_get_table(id, 1);\r\nreturn NULL;\r\n}\r\nvoid dn_fib_flush(void)\r\n{\r\nint flushed = 0;\r\nstruct dn_fib_table *tb;\r\nstruct hlist_node *node;\r\nunsigned int h;\r\nfor (h = 0; h < DN_FIB_TABLE_HASHSZ; h++) {\r\nhlist_for_each_entry(tb, node, &dn_fib_table_hash[h], hlist)\r\nflushed += tb->flush(tb);\r\n}\r\nif (flushed)\r\ndn_rt_cache_flush(-1);\r\n}\r\nvoid __init dn_fib_table_init(void)\r\n{\r\ndn_hash_kmem = kmem_cache_create("dn_fib_info_cache",\r\nsizeof(struct dn_fib_info),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\n}\r\nvoid __exit dn_fib_table_cleanup(void)\r\n{\r\nstruct dn_fib_table *t;\r\nstruct hlist_node *node, *next;\r\nunsigned int h;\r\nwrite_lock(&dn_fib_tables_lock);\r\nfor (h = 0; h < DN_FIB_TABLE_HASHSZ; h++) {\r\nhlist_for_each_entry_safe(t, node, next, &dn_fib_table_hash[h],\r\nhlist) {\r\nhlist_del(&t->hlist);\r\nkfree(t);\r\n}\r\n}\r\nwrite_unlock(&dn_fib_tables_lock);\r\n}
