static bool vmballoon_send_start(struct vmballoon *b)\r\n{\r\nunsigned long status, dummy;\r\nSTATS_INC(b->stats.start);\r\nstatus = VMWARE_BALLOON_CMD(START, VMW_BALLOON_PROTOCOL_VERSION, dummy);\r\nif (status == VMW_BALLOON_SUCCESS)\r\nreturn true;\r\npr_debug("%s - failed, hv returns %ld\n", __func__, status);\r\nSTATS_INC(b->stats.start_fail);\r\nreturn false;\r\n}\r\nstatic bool vmballoon_check_status(struct vmballoon *b, unsigned long status)\r\n{\r\nswitch (status) {\r\ncase VMW_BALLOON_SUCCESS:\r\nreturn true;\r\ncase VMW_BALLOON_ERROR_RESET:\r\nb->reset_required = true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool vmballoon_send_guest_id(struct vmballoon *b)\r\n{\r\nunsigned long status, dummy;\r\nstatus = VMWARE_BALLOON_CMD(GUEST_ID, VMW_BALLOON_GUEST_ID, dummy);\r\nSTATS_INC(b->stats.guest_type);\r\nif (vmballoon_check_status(b, status))\r\nreturn true;\r\npr_debug("%s - failed, hv returns %ld\n", __func__, status);\r\nSTATS_INC(b->stats.guest_type_fail);\r\nreturn false;\r\n}\r\nstatic bool vmballoon_send_get_target(struct vmballoon *b, u32 *new_target)\r\n{\r\nunsigned long status;\r\nunsigned long target;\r\nunsigned long limit;\r\nu32 limit32;\r\nsi_meminfo(&b->sysinfo);\r\nlimit = b->sysinfo.totalram;\r\nlimit32 = (u32)limit;\r\nif (limit != limit32)\r\nreturn false;\r\nSTATS_INC(b->stats.target);\r\nstatus = VMWARE_BALLOON_CMD(GET_TARGET, limit, target);\r\nif (vmballoon_check_status(b, status)) {\r\n*new_target = target;\r\nreturn true;\r\n}\r\npr_debug("%s - failed, hv returns %ld\n", __func__, status);\r\nSTATS_INC(b->stats.target_fail);\r\nreturn false;\r\n}\r\nstatic int vmballoon_send_lock_page(struct vmballoon *b, unsigned long pfn,\r\nunsigned int *hv_status)\r\n{\r\nunsigned long status, dummy;\r\nu32 pfn32;\r\npfn32 = (u32)pfn;\r\nif (pfn32 != pfn)\r\nreturn -1;\r\nSTATS_INC(b->stats.lock);\r\n*hv_status = status = VMWARE_BALLOON_CMD(LOCK, pfn, dummy);\r\nif (vmballoon_check_status(b, status))\r\nreturn 0;\r\npr_debug("%s - ppn %lx, hv returns %ld\n", __func__, pfn, status);\r\nSTATS_INC(b->stats.lock_fail);\r\nreturn 1;\r\n}\r\nstatic bool vmballoon_send_unlock_page(struct vmballoon *b, unsigned long pfn)\r\n{\r\nunsigned long status, dummy;\r\nu32 pfn32;\r\npfn32 = (u32)pfn;\r\nif (pfn32 != pfn)\r\nreturn false;\r\nSTATS_INC(b->stats.unlock);\r\nstatus = VMWARE_BALLOON_CMD(UNLOCK, pfn, dummy);\r\nif (vmballoon_check_status(b, status))\r\nreturn true;\r\npr_debug("%s - ppn %lx, hv returns %ld\n", __func__, pfn, status);\r\nSTATS_INC(b->stats.unlock_fail);\r\nreturn false;\r\n}\r\nstatic void vmballoon_pop(struct vmballoon *b)\r\n{\r\nstruct page *page, *next;\r\nunsigned int count = 0;\r\nlist_for_each_entry_safe(page, next, &b->pages, lru) {\r\nlist_del(&page->lru);\r\n__free_page(page);\r\nSTATS_INC(b->stats.free);\r\nb->size--;\r\nif (++count >= b->rate_free) {\r\ncount = 0;\r\ncond_resched();\r\n}\r\n}\r\n}\r\nstatic void vmballoon_reset(struct vmballoon *b)\r\n{\r\nvmballoon_pop(b);\r\nif (vmballoon_send_start(b)) {\r\nb->reset_required = false;\r\nif (!vmballoon_send_guest_id(b))\r\npr_err("failed to send guest ID to the host\n");\r\n}\r\n}\r\nstatic int vmballoon_reserve_page(struct vmballoon *b, bool can_sleep)\r\n{\r\nstruct page *page;\r\ngfp_t flags;\r\nunsigned int hv_status;\r\nint locked;\r\nflags = can_sleep ? VMW_PAGE_ALLOC_CANSLEEP : VMW_PAGE_ALLOC_NOSLEEP;\r\ndo {\r\nif (!can_sleep)\r\nSTATS_INC(b->stats.alloc);\r\nelse\r\nSTATS_INC(b->stats.sleep_alloc);\r\npage = alloc_page(flags);\r\nif (!page) {\r\nif (!can_sleep)\r\nSTATS_INC(b->stats.alloc_fail);\r\nelse\r\nSTATS_INC(b->stats.sleep_alloc_fail);\r\nreturn -ENOMEM;\r\n}\r\nlocked = vmballoon_send_lock_page(b, page_to_pfn(page), &hv_status);\r\nif (locked > 0) {\r\nSTATS_INC(b->stats.refused_alloc);\r\nif (hv_status == VMW_BALLOON_ERROR_RESET ||\r\nhv_status == VMW_BALLOON_ERROR_PPN_NOTNEEDED) {\r\n__free_page(page);\r\nreturn -EIO;\r\n}\r\nlist_add(&page->lru, &b->refused_pages);\r\nif (++b->n_refused_pages >= VMW_BALLOON_MAX_REFUSED)\r\nreturn -EIO;\r\n}\r\n} while (locked != 0);\r\nlist_add(&page->lru, &b->pages);\r\nb->size++;\r\nreturn 0;\r\n}\r\nstatic int vmballoon_release_page(struct vmballoon *b, struct page *page)\r\n{\r\nif (!vmballoon_send_unlock_page(b, page_to_pfn(page)))\r\nreturn -EIO;\r\nlist_del(&page->lru);\r\n__free_page(page);\r\nSTATS_INC(b->stats.free);\r\nb->size--;\r\nreturn 0;\r\n}\r\nstatic void vmballoon_release_refused_pages(struct vmballoon *b)\r\n{\r\nstruct page *page, *next;\r\nlist_for_each_entry_safe(page, next, &b->refused_pages, lru) {\r\nlist_del(&page->lru);\r\n__free_page(page);\r\nSTATS_INC(b->stats.refused_free);\r\n}\r\nb->n_refused_pages = 0;\r\n}\r\nstatic void vmballoon_inflate(struct vmballoon *b)\r\n{\r\nunsigned int goal;\r\nunsigned int rate;\r\nunsigned int i;\r\nunsigned int allocations = 0;\r\nint error = 0;\r\nbool alloc_can_sleep = false;\r\npr_debug("%s - size: %d, target %d\n", __func__, b->size, b->target);\r\ngoal = b->target - b->size;\r\nrate = b->slow_allocation_cycles ?\r\nb->rate_alloc : VMW_BALLOON_NOSLEEP_ALLOC_MAX;\r\npr_debug("%s - goal: %d, no-sleep rate: %d, sleep rate: %d\n",\r\n__func__, goal, rate, b->rate_alloc);\r\nfor (i = 0; i < goal; i++) {\r\nerror = vmballoon_reserve_page(b, alloc_can_sleep);\r\nif (error) {\r\nif (error != -ENOMEM) {\r\nbreak;\r\n}\r\nif (alloc_can_sleep) {\r\nb->rate_alloc = max(b->rate_alloc / 2,\r\nVMW_BALLOON_RATE_ALLOC_MIN);\r\nbreak;\r\n}\r\nb->slow_allocation_cycles = VMW_BALLOON_SLOW_CYCLES;\r\nif (i >= b->rate_alloc)\r\nbreak;\r\nalloc_can_sleep = true;\r\nrate = b->rate_alloc;\r\n}\r\nif (++allocations > VMW_BALLOON_YIELD_THRESHOLD) {\r\ncond_resched();\r\nallocations = 0;\r\n}\r\nif (i >= rate) {\r\nbreak;\r\n}\r\n}\r\nif (error == 0 && i >= b->rate_alloc) {\r\nunsigned int mult = i / b->rate_alloc;\r\nb->rate_alloc =\r\nmin(b->rate_alloc + mult * VMW_BALLOON_RATE_ALLOC_INC,\r\nVMW_BALLOON_RATE_ALLOC_MAX);\r\n}\r\nvmballoon_release_refused_pages(b);\r\n}\r\nstatic void vmballoon_deflate(struct vmballoon *b)\r\n{\r\nstruct page *page, *next;\r\nunsigned int i = 0;\r\nunsigned int goal;\r\nint error;\r\npr_debug("%s - size: %d, target %d\n", __func__, b->size, b->target);\r\ngoal = min(b->size - b->target, b->rate_free);\r\npr_debug("%s - goal: %d, rate: %d\n", __func__, goal, b->rate_free);\r\nlist_for_each_entry_safe(page, next, &b->pages, lru) {\r\nerror = vmballoon_release_page(b, page);\r\nif (error) {\r\nb->rate_free = max(b->rate_free / 2,\r\nVMW_BALLOON_RATE_FREE_MIN);\r\nreturn;\r\n}\r\nif (++i >= goal)\r\nbreak;\r\n}\r\nb->rate_free = min(b->rate_free + VMW_BALLOON_RATE_FREE_INC,\r\nVMW_BALLOON_RATE_FREE_MAX);\r\n}\r\nstatic void vmballoon_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct vmballoon *b = container_of(dwork, struct vmballoon, dwork);\r\nunsigned int target;\r\nSTATS_INC(b->stats.timer);\r\nif (b->reset_required)\r\nvmballoon_reset(b);\r\nif (b->slow_allocation_cycles > 0)\r\nb->slow_allocation_cycles--;\r\nif (vmballoon_send_get_target(b, &target)) {\r\nb->target = target;\r\nif (b->size < target)\r\nvmballoon_inflate(b);\r\nelse if (b->size > target)\r\nvmballoon_deflate(b);\r\n}\r\nqueue_delayed_work(system_freezable_wq,\r\ndwork, round_jiffies_relative(HZ));\r\n}\r\nstatic int vmballoon_debug_show(struct seq_file *f, void *offset)\r\n{\r\nstruct vmballoon *b = f->private;\r\nstruct vmballoon_stats *stats = &b->stats;\r\nseq_printf(f,\r\n"target: %8d pages\n"\r\n"current: %8d pages\n",\r\nb->target, b->size);\r\nseq_printf(f,\r\n"rateNoSleepAlloc: %8d pages/sec\n"\r\n"rateSleepAlloc: %8d pages/sec\n"\r\n"rateFree: %8d pages/sec\n",\r\nVMW_BALLOON_NOSLEEP_ALLOC_MAX,\r\nb->rate_alloc, b->rate_free);\r\nseq_printf(f,\r\n"\n"\r\n"timer: %8u\n"\r\n"start: %8u (%4u failed)\n"\r\n"guestType: %8u (%4u failed)\n"\r\n"lock: %8u (%4u failed)\n"\r\n"unlock: %8u (%4u failed)\n"\r\n"target: %8u (%4u failed)\n"\r\n"primNoSleepAlloc: %8u (%4u failed)\n"\r\n"primCanSleepAlloc: %8u (%4u failed)\n"\r\n"primFree: %8u\n"\r\n"errAlloc: %8u\n"\r\n"errFree: %8u\n",\r\nstats->timer,\r\nstats->start, stats->start_fail,\r\nstats->guest_type, stats->guest_type_fail,\r\nstats->lock, stats->lock_fail,\r\nstats->unlock, stats->unlock_fail,\r\nstats->target, stats->target_fail,\r\nstats->alloc, stats->alloc_fail,\r\nstats->sleep_alloc, stats->sleep_alloc_fail,\r\nstats->free,\r\nstats->refused_alloc, stats->refused_free);\r\nreturn 0;\r\n}\r\nstatic int vmballoon_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vmballoon_debug_show, inode->i_private);\r\n}\r\nstatic int __init vmballoon_debugfs_init(struct vmballoon *b)\r\n{\r\nint error;\r\nb->dbg_entry = debugfs_create_file("vmmemctl", S_IRUGO, NULL, b,\r\n&vmballoon_debug_fops);\r\nif (IS_ERR(b->dbg_entry)) {\r\nerror = PTR_ERR(b->dbg_entry);\r\npr_err("failed to create debugfs entry, error: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit vmballoon_debugfs_exit(struct vmballoon *b)\r\n{\r\ndebugfs_remove(b->dbg_entry);\r\n}\r\nstatic inline int vmballoon_debugfs_init(struct vmballoon *b)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void vmballoon_debugfs_exit(struct vmballoon *b)\r\n{\r\n}\r\nstatic int __init vmballoon_init(void)\r\n{\r\nint error;\r\nif (x86_hyper != &x86_hyper_vmware)\r\nreturn -ENODEV;\r\nINIT_LIST_HEAD(&balloon.pages);\r\nINIT_LIST_HEAD(&balloon.refused_pages);\r\nballoon.rate_alloc = VMW_BALLOON_RATE_ALLOC_MAX;\r\nballoon.rate_free = VMW_BALLOON_RATE_FREE_MAX;\r\nINIT_DELAYED_WORK(&balloon.dwork, vmballoon_work);\r\nif (!vmballoon_send_start(&balloon)) {\r\npr_err("failed to send start command to the host\n");\r\nreturn -EIO;\r\n}\r\nif (!vmballoon_send_guest_id(&balloon)) {\r\npr_err("failed to send guest ID to the host\n");\r\nreturn -EIO;\r\n}\r\nerror = vmballoon_debugfs_init(&balloon);\r\nif (error)\r\nreturn error;\r\nqueue_delayed_work(system_freezable_wq, &balloon.dwork, 0);\r\nreturn 0;\r\n}\r\nstatic void __exit vmballoon_exit(void)\r\n{\r\ncancel_delayed_work_sync(&balloon.dwork);\r\nvmballoon_debugfs_exit(&balloon);\r\nvmballoon_send_start(&balloon);\r\nvmballoon_pop(&balloon);\r\n}
