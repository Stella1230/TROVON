static void setup_packet_header(struct asus_oled_packet *packet, char flags,\r\nchar value3, char buffer1, char buffer2, char value6,\r\nchar value7, char value8)\r\n{\r\nmemset(packet, 0, sizeof(struct asus_oled_header));\r\npacket->header.magic1 = 0x55;\r\npacket->header.magic2 = 0xaa;\r\npacket->header.flags = flags;\r\npacket->header.value3 = value3;\r\npacket->header.buffer1 = buffer1;\r\npacket->header.buffer2 = buffer2;\r\npacket->header.value6 = value6;\r\npacket->header.value7 = value7;\r\npacket->header.value8 = value8;\r\n}\r\nstatic void enable_oled(struct asus_oled_dev *odev, uint8_t enabl)\r\n{\r\nint retval;\r\nint act_len;\r\nstruct asus_oled_packet *packet;\r\npacket = kzalloc(sizeof(struct asus_oled_packet), GFP_KERNEL);\r\nif (!packet) {\r\ndev_err(&odev->udev->dev, "out of memory\n");\r\nreturn;\r\n}\r\nsetup_packet_header(packet, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00);\r\nif (enabl)\r\npacket->bitmap[0] = 0xaf;\r\nelse\r\npacket->bitmap[0] = 0xae;\r\nretval = usb_bulk_msg(odev->udev,\r\nusb_sndbulkpipe(odev->udev, 2),\r\npacket,\r\nsizeof(struct asus_oled_header) + 1,\r\n&act_len,\r\n-1);\r\nif (retval)\r\ndev_dbg(&odev->udev->dev, "retval = %d\n", retval);\r\nodev->enabled = enabl;\r\nkfree(packet);\r\n}\r\nstatic ssize_t set_enabled(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct asus_oled_dev *odev = usb_get_intfdata(intf);\r\nunsigned long value;\r\nif (kstrtoul(buf, 10, &value))\r\nreturn -EINVAL;\r\nenable_oled(odev, value);\r\nreturn count;\r\n}\r\nstatic ssize_t class_set_enabled(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_oled_dev *odev =\r\n(struct asus_oled_dev *) dev_get_drvdata(device);\r\nunsigned long value;\r\nif (kstrtoul(buf, 10, &value))\r\nreturn -EINVAL;\r\nenable_oled(odev, value);\r\nreturn count;\r\n}\r\nstatic ssize_t get_enabled(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct asus_oled_dev *odev = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d\n", odev->enabled);\r\n}\r\nstatic ssize_t class_get_enabled(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct asus_oled_dev *odev =\r\n(struct asus_oled_dev *) dev_get_drvdata(device);\r\nreturn sprintf(buf, "%d\n", odev->enabled);\r\n}\r\nstatic void send_packets(struct usb_device *udev,\r\nstruct asus_oled_packet *packet,\r\nchar *buf, uint8_t p_type, size_t p_num)\r\n{\r\nsize_t i;\r\nint act_len;\r\nfor (i = 0; i < p_num; i++) {\r\nint retval;\r\nswitch (p_type) {\r\ncase ASUS_OLED_ROLL:\r\nsetup_packet_header(packet, 0x40, 0x80, p_num,\r\ni + 1, 0x00, 0x01, 0xff);\r\nbreak;\r\ncase ASUS_OLED_STATIC:\r\nsetup_packet_header(packet, 0x10 + i, 0x80, 0x01,\r\n0x01, 0x00, 0x01, 0x00);\r\nbreak;\r\ncase ASUS_OLED_FLASH:\r\nsetup_packet_header(packet, 0x10 + i, 0x80, 0x01,\r\n0x01, 0x00, 0x00, 0xff);\r\nbreak;\r\n}\r\nmemcpy(packet->bitmap, buf + (ASUS_OLED_PACKET_BUF_SIZE*i),\r\nASUS_OLED_PACKET_BUF_SIZE);\r\nretval = usb_bulk_msg(udev, usb_sndctrlpipe(udev, 2),\r\npacket, sizeof(struct asus_oled_packet),\r\n&act_len, -1);\r\nif (retval)\r\ndev_dbg(&udev->dev, "retval = %d\n", retval);\r\n}\r\n}\r\nstatic void send_packet(struct usb_device *udev,\r\nstruct asus_oled_packet *packet,\r\nsize_t offset, size_t len, char *buf, uint8_t b1,\r\nuint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5,\r\nuint8_t b6) {\r\nint retval;\r\nint act_len;\r\nsetup_packet_header(packet, b1, b2, b3, b4, b5, b6, 0x00);\r\nmemcpy(packet->bitmap, buf + offset, len);\r\nretval = usb_bulk_msg(udev,\r\nusb_sndctrlpipe(udev, 2),\r\npacket,\r\nsizeof(struct asus_oled_packet),\r\n&act_len,\r\n-1);\r\nif (retval)\r\ndev_dbg(&udev->dev, "retval = %d\n", retval);\r\n}\r\nstatic void send_packets_g50(struct usb_device *udev,\r\nstruct asus_oled_packet *packet, char *buf)\r\n{\r\nsend_packet(udev, packet, 0, 0x100, buf,\r\n0x10, 0x00, 0x02, 0x01, 0x00, 0x01);\r\nsend_packet(udev, packet, 0x100, 0x080, buf,\r\n0x10, 0x00, 0x02, 0x02, 0x80, 0x00);\r\nsend_packet(udev, packet, 0x180, 0x100, buf,\r\n0x11, 0x00, 0x03, 0x01, 0x00, 0x01);\r\nsend_packet(udev, packet, 0x280, 0x100, buf,\r\n0x11, 0x00, 0x03, 0x02, 0x00, 0x01);\r\nsend_packet(udev, packet, 0x380, 0x080, buf,\r\n0x11, 0x00, 0x03, 0x03, 0x80, 0x00);\r\n}\r\nstatic void send_data(struct asus_oled_dev *odev)\r\n{\r\nsize_t packet_num = odev->buf_size / ASUS_OLED_PACKET_BUF_SIZE;\r\nstruct asus_oled_packet *packet;\r\npacket = kzalloc(sizeof(struct asus_oled_packet), GFP_KERNEL);\r\nif (!packet) {\r\ndev_err(&odev->udev->dev, "out of memory\n");\r\nreturn;\r\n}\r\nif (odev->pack_mode == PACK_MODE_G1) {\r\nif (odev->pic_mode == ASUS_OLED_ROLL)\r\nsend_packets(odev->udev, packet, odev->buf,\r\nASUS_OLED_STATIC, 2);\r\nif (odev->pic_mode != ASUS_OLED_ROLL && packet_num > 2)\r\npacket_num = 2;\r\nsend_packets(odev->udev, packet, odev->buf,\r\nodev->pic_mode, packet_num);\r\n} else if (odev->pack_mode == PACK_MODE_G50) {\r\nsend_packets_g50(odev->udev, packet, odev->buf);\r\n}\r\nkfree(packet);\r\n}\r\nstatic int append_values(struct asus_oled_dev *odev, uint8_t val, size_t count)\r\n{\r\nodev->last_val = val;\r\nif (val == 0) {\r\nodev->buf_offs += count;\r\nreturn 0;\r\n}\r\nwhile (count-- > 0) {\r\nsize_t x = odev->buf_offs % odev->width;\r\nsize_t y = odev->buf_offs / odev->width;\r\nsize_t i;\r\nx += odev->x_shift;\r\ny += odev->y_shift;\r\nswitch (odev->pack_mode) {\r\ncase PACK_MODE_G1:\r\ni = (x/odev->dev_width)*640 +\r\nodev->dev_width - 1 - x +\r\n(y/8)*odev->dev_width;\r\nbreak;\r\ncase PACK_MODE_G50:\r\ni = (odev->dev_width - 1 - x)/8 + y*odev->dev_width/8;\r\nbreak;\r\ndefault:\r\ni = 0;\r\ndev_err(odev->dev, "Unknown OLED Pack Mode: %d!\n",\r\nodev->pack_mode);\r\nbreak;\r\n}\r\nif (i >= odev->buf_size) {\r\ndev_err(odev->dev, "Buffer overflow! Report a bug:"\r\n"offs: %d >= %d i: %d (x: %d y: %d)\n",\r\n(int) odev->buf_offs, (int) odev->buf_size,\r\n(int) i, (int) x, (int) y);\r\nreturn -EIO;\r\n}\r\nswitch (odev->pack_mode) {\r\ncase PACK_MODE_G1:\r\nodev->buf[i] &= ~(1<<(y%8));\r\nbreak;\r\ncase PACK_MODE_G50:\r\nodev->buf[i] &= ~(1<<(x%8));\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nodev->buf_offs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t odev_set_picture(struct asus_oled_dev *odev,\r\nconst char *buf, size_t count)\r\n{\r\nsize_t offs = 0, max_offs;\r\nif (count < 1)\r\nreturn 0;\r\nif (tolower(buf[0]) == 'b') {\r\nsize_t i;\r\nodev->buf_size = (odev->dev_width * ASUS_OLED_DISP_HEIGHT) / 8;\r\nkfree(odev->buf);\r\nodev->buf = kmalloc(odev->buf_size, GFP_KERNEL);\r\nif (odev->buf == NULL) {\r\nodev->buf_size = 0;\r\ndev_err(odev->dev, "Out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(odev->buf, 0xff, odev->buf_size);\r\nfor (i = 1; i < count && i <= 32 * 32; i++) {\r\nodev->buf[i-1] = buf[i];\r\nodev->buf_offs = i-1;\r\n}\r\nodev->width = odev->dev_width / 8;\r\nodev->height = ASUS_OLED_DISP_HEIGHT;\r\nodev->x_shift = 0;\r\nodev->y_shift = 0;\r\nodev->last_val = 0;\r\nsend_data(odev);\r\nreturn count;\r\n}\r\nif (buf[0] == '<') {\r\nsize_t i;\r\nsize_t w = 0, h = 0;\r\nsize_t w_mem, h_mem;\r\nif (count < 10 || buf[2] != ':')\r\ngoto error_header;\r\nswitch (tolower(buf[1])) {\r\ncase ASUS_OLED_STATIC:\r\ncase ASUS_OLED_ROLL:\r\ncase ASUS_OLED_FLASH:\r\nodev->pic_mode = buf[1];\r\nbreak;\r\ndefault:\r\ndev_err(odev->dev, "Wrong picture mode: '%c'.\n",\r\nbuf[1]);\r\nreturn -EIO;\r\nbreak;\r\n}\r\nfor (i = 3; i < count; ++i) {\r\nif (buf[i] >= '0' && buf[i] <= '9') {\r\nw = 10*w + (buf[i] - '0');\r\nif (w > ASUS_OLED_MAX_WIDTH)\r\ngoto error_width;\r\n} else if (tolower(buf[i]) == 'x') {\r\nbreak;\r\n} else {\r\ngoto error_width;\r\n}\r\n}\r\nfor (++i; i < count; ++i) {\r\nif (buf[i] >= '0' && buf[i] <= '9') {\r\nh = 10*h + (buf[i] - '0');\r\nif (h > ASUS_OLED_DISP_HEIGHT)\r\ngoto error_height;\r\n} else if (tolower(buf[i]) == '>') {\r\nbreak;\r\n} else {\r\ngoto error_height;\r\n}\r\n}\r\nif (w < 1 || w > ASUS_OLED_MAX_WIDTH)\r\ngoto error_width;\r\nif (h < 1 || h > ASUS_OLED_DISP_HEIGHT)\r\ngoto error_height;\r\nif (i >= count || buf[i] != '>')\r\ngoto error_header;\r\noffs = i+1;\r\nif (w % (odev->dev_width) != 0)\r\nw_mem = (w/(odev->dev_width) + 1)*(odev->dev_width);\r\nelse\r\nw_mem = w;\r\nif (h < ASUS_OLED_DISP_HEIGHT)\r\nh_mem = ASUS_OLED_DISP_HEIGHT;\r\nelse\r\nh_mem = h;\r\nodev->buf_size = w_mem * h_mem / 8;\r\nkfree(odev->buf);\r\nodev->buf = kmalloc(odev->buf_size, GFP_KERNEL);\r\nif (odev->buf == NULL) {\r\nodev->buf_size = 0;\r\ndev_err(odev->dev, "Out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(odev->buf, 0xff, odev->buf_size);\r\nodev->buf_offs = 0;\r\nodev->width = w;\r\nodev->height = h;\r\nodev->x_shift = 0;\r\nodev->y_shift = 0;\r\nodev->last_val = 0;\r\nif (odev->pic_mode == ASUS_OLED_FLASH) {\r\nif (h < ASUS_OLED_DISP_HEIGHT/2)\r\nodev->y_shift = (ASUS_OLED_DISP_HEIGHT/2 - h)/2;\r\n} else {\r\nif (h < ASUS_OLED_DISP_HEIGHT)\r\nodev->y_shift = (ASUS_OLED_DISP_HEIGHT - h)/2;\r\n}\r\nif (w < (odev->dev_width))\r\nodev->x_shift = ((odev->dev_width) - w)/2;\r\n}\r\nmax_offs = odev->width * odev->height;\r\nwhile (offs < count && odev->buf_offs < max_offs) {\r\nint ret = 0;\r\nif (buf[offs] == '1' || buf[offs] == '#') {\r\nret = append_values(odev, 1, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n} else if (buf[offs] == '0' || buf[offs] == ' ') {\r\nret = append_values(odev, 0, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n} else if (buf[offs] == '\n') {\r\nif (odev->buf_offs % odev->width != 0)\r\nret = append_values(odev, odev->last_val,\r\nodev->width -\r\n(odev->buf_offs %\r\nodev->width));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\noffs++;\r\n}\r\nif (odev->buf_offs >= max_offs)\r\nsend_data(odev);\r\nreturn count;\r\nerror_width:\r\ndev_err(odev->dev, "Wrong picture width specified.\n");\r\nreturn -EIO;\r\nerror_height:\r\ndev_err(odev->dev, "Wrong picture height specified.\n");\r\nreturn -EIO;\r\nerror_header:\r\ndev_err(odev->dev, "Wrong picture header.\n");\r\nreturn -EIO;\r\n}\r\nstatic ssize_t set_picture(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nreturn odev_set_picture(usb_get_intfdata(intf), buf, count);\r\n}\r\nstatic ssize_t class_set_picture(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn odev_set_picture((struct asus_oled_dev *)\r\ndev_get_drvdata(device), buf, count);\r\n}\r\nstatic int asus_oled_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct asus_oled_dev *odev = NULL;\r\nint retval = -ENOMEM;\r\nuint16_t dev_width = 0;\r\nenum oled_pack_mode pack_mode = PACK_MODE_LAST;\r\nconst struct oled_dev_desc_str *dev_desc = oled_dev_desc_table;\r\nconst char *desc = NULL;\r\nif (!id) {\r\ndev_err(&interface->dev, "No usb_device_id provided!\n");\r\nreturn -ENODEV;\r\n}\r\nfor (; dev_desc->idVendor; dev_desc++) {\r\nif (dev_desc->idVendor == id->idVendor\r\n&& dev_desc->idProduct == id->idProduct) {\r\ndev_width = dev_desc->devWidth;\r\ndesc = dev_desc->devDesc;\r\npack_mode = dev_desc->packMode;\r\nbreak;\r\n}\r\n}\r\nif (!desc || dev_width < 1 || pack_mode == PACK_MODE_LAST) {\r\ndev_err(&interface->dev,\r\n"Missing or incomplete device description!\n");\r\nreturn -ENODEV;\r\n}\r\nodev = kzalloc(sizeof(struct asus_oled_dev), GFP_KERNEL);\r\nif (odev == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nodev->udev = usb_get_dev(udev);\r\nodev->pic_mode = ASUS_OLED_STATIC;\r\nodev->dev_width = dev_width;\r\nodev->pack_mode = pack_mode;\r\nodev->height = 0;\r\nodev->width = 0;\r\nodev->x_shift = 0;\r\nodev->y_shift = 0;\r\nodev->buf_offs = 0;\r\nodev->buf_size = 0;\r\nodev->last_val = 0;\r\nodev->buf = NULL;\r\nodev->enabled = 1;\r\nodev->dev = NULL;\r\nusb_set_intfdata(interface, odev);\r\nretval = device_create_file(&interface->dev,\r\n&ASUS_OLED_DEVICE_ATTR(enabled));\r\nif (retval)\r\ngoto err_files;\r\nretval = device_create_file(&interface->dev,\r\n&ASUS_OLED_DEVICE_ATTR(picture));\r\nif (retval)\r\ngoto err_files;\r\nodev->dev = device_create(oled_class, &interface->dev, MKDEV(0, 0),\r\nNULL, "oled_%d", ++oled_num);\r\nif (IS_ERR(odev->dev)) {\r\nretval = PTR_ERR(odev->dev);\r\ngoto err_files;\r\n}\r\ndev_set_drvdata(odev->dev, odev);\r\nretval = device_create_file(odev->dev, &dev_attr_enabled);\r\nif (retval)\r\ngoto err_class_enabled;\r\nretval = device_create_file(odev->dev, &dev_attr_picture);\r\nif (retval)\r\ngoto err_class_picture;\r\ndev_info(&interface->dev,\r\n"Attached Asus OLED device: %s [width %u, pack_mode %d]\n",\r\ndesc, odev->dev_width, odev->pack_mode);\r\nif (start_off)\r\nenable_oled(odev, 0);\r\nreturn 0;\r\nerr_class_picture:\r\ndevice_remove_file(odev->dev, &dev_attr_picture);\r\nerr_class_enabled:\r\ndevice_remove_file(odev->dev, &dev_attr_enabled);\r\ndevice_unregister(odev->dev);\r\nerr_files:\r\ndevice_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(enabled));\r\ndevice_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(picture));\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_dev(odev->udev);\r\nkfree(odev);\r\nreturn retval;\r\n}\r\nstatic void asus_oled_disconnect(struct usb_interface *interface)\r\n{\r\nstruct asus_oled_dev *odev;\r\nodev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\ndevice_remove_file(odev->dev, &dev_attr_picture);\r\ndevice_remove_file(odev->dev, &dev_attr_enabled);\r\ndevice_unregister(odev->dev);\r\ndevice_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(picture));\r\ndevice_remove_file(&interface->dev, &ASUS_OLED_DEVICE_ATTR(enabled));\r\nusb_put_dev(odev->udev);\r\nkfree(odev->buf);\r\nkfree(odev);\r\ndev_info(&interface->dev, "Disconnected Asus OLED device\n");\r\n}\r\nstatic int asus_oled_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct asus_oled_dev *odev;\r\nodev = usb_get_intfdata(intf);\r\nif (!odev)\r\nreturn -ENODEV;\r\nodev->enabled_post_resume = odev->enabled;\r\nenable_oled(odev, 0);\r\nreturn 0;\r\n}\r\nstatic int asus_oled_resume(struct usb_interface *intf)\r\n{\r\nstruct asus_oled_dev *odev;\r\nodev = usb_get_intfdata(intf);\r\nif (!odev)\r\nreturn -ENODEV;\r\nenable_oled(odev, odev->enabled_post_resume);\r\nreturn 0;\r\n}\r\nstatic int __init asus_oled_init(void)\r\n{\r\nint retval = 0;\r\noled_class = class_create(THIS_MODULE, ASUS_OLED_UNDERSCORE_NAME);\r\nif (IS_ERR(oled_class)) {\r\npr_err("Error creating " ASUS_OLED_UNDERSCORE_NAME " class\n");\r\nreturn PTR_ERR(oled_class);\r\n}\r\nretval = class_create_file(oled_class, &class_attr_version.attr);\r\nif (retval) {\r\npr_err("Error creating class version file\n");\r\ngoto error;\r\n}\r\nretval = usb_register(&oled_driver);\r\nif (retval) {\r\npr_err("usb_register failed. Error number %d\n", retval);\r\ngoto error;\r\n}\r\nreturn retval;\r\nerror:\r\nclass_destroy(oled_class);\r\nreturn retval;\r\n}\r\nstatic void __exit asus_oled_exit(void)\r\n{\r\nusb_deregister(&oled_driver);\r\nclass_remove_file(oled_class, &class_attr_version.attr);\r\nclass_destroy(oled_class);\r\n}
