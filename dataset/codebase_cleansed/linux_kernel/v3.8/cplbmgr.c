static inline int faulting_cplb_index(int status)\r\n{\r\nint signbits = __builtin_bfin_norm_fr1x32(status & 0xFFFF);\r\nreturn 30 - signbits;\r\n}\r\nstatic inline int write_permitted(int status, unsigned long data)\r\n{\r\nif (status & FAULT_USERSUPV)\r\nreturn !!(data & CPLB_SUPV_WR);\r\nelse\r\nreturn !!(data & CPLB_USER_WR);\r\n}\r\nMGR_ATTR static int evict_one_icplb(unsigned int cpu)\r\n{\r\nint i;\r\nfor (i = first_switched_icplb; i < MAX_CPLBS; i++)\r\nif ((icplb_tbl[cpu][i].data & CPLB_VALID) == 0)\r\nreturn i;\r\ni = first_switched_icplb + icplb_rr_index[cpu];\r\nif (i >= MAX_CPLBS) {\r\ni -= MAX_CPLBS - first_switched_icplb;\r\nicplb_rr_index[cpu] -= MAX_CPLBS - first_switched_icplb;\r\n}\r\nicplb_rr_index[cpu]++;\r\nreturn i;\r\n}\r\nMGR_ATTR static int evict_one_dcplb(unsigned int cpu)\r\n{\r\nint i;\r\nfor (i = first_switched_dcplb; i < MAX_CPLBS; i++)\r\nif ((dcplb_tbl[cpu][i].data & CPLB_VALID) == 0)\r\nreturn i;\r\ni = first_switched_dcplb + dcplb_rr_index[cpu];\r\nif (i >= MAX_CPLBS) {\r\ni -= MAX_CPLBS - first_switched_dcplb;\r\ndcplb_rr_index[cpu] -= MAX_CPLBS - first_switched_dcplb;\r\n}\r\ndcplb_rr_index[cpu]++;\r\nreturn i;\r\n}\r\nMGR_ATTR static noinline int dcplb_miss(unsigned int cpu)\r\n{\r\nunsigned long addr = bfin_read_DCPLB_FAULT_ADDR();\r\nint status = bfin_read_DCPLB_STATUS();\r\nunsigned long *mask;\r\nint idx;\r\nunsigned long d_data;\r\nnr_dcplb_miss[cpu]++;\r\nd_data = CPLB_SUPV_WR | CPLB_VALID | CPLB_DIRTY | PAGE_SIZE_4KB;\r\n#ifdef CONFIG_BFIN_EXTMEM_DCACHEABLE\r\nif (bfin_addr_dcacheable(addr)) {\r\nd_data |= CPLB_L1_CHBL | ANOMALY_05000158_WORKAROUND;\r\n# ifdef CONFIG_BFIN_EXTMEM_WRITETHROUGH\r\nd_data |= CPLB_L1_AOW | CPLB_WT;\r\n# endif\r\n}\r\n#endif\r\nif (L2_LENGTH && addr >= L2_START && addr < L2_START + L2_LENGTH) {\r\naddr = L2_START;\r\nd_data = L2_DMEMORY;\r\n} else if (addr >= physical_mem_end) {\r\nif (addr >= ASYNC_BANK0_BASE && addr < ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE) {\r\n#if defined(CONFIG_ROMFS_ON_MTD) && defined(CONFIG_MTD_ROM)\r\nmask = current_rwx_mask[cpu];\r\nif (mask) {\r\nint page = (addr - (ASYNC_BANK0_BASE - _ramend)) >> PAGE_SHIFT;\r\nint idx = page >> 5;\r\nint bit = 1 << (page & 31);\r\nif (mask[idx] & bit)\r\nd_data |= CPLB_USER_RD;\r\n}\r\n#endif\r\n} else if (addr >= BOOT_ROM_START && addr < BOOT_ROM_START + BOOT_ROM_LENGTH\r\n&& (status & (FAULT_RW | FAULT_USERSUPV)) == FAULT_USERSUPV) {\r\naddr &= ~(1 * 1024 * 1024 - 1);\r\nd_data &= ~PAGE_SIZE_4KB;\r\nd_data |= PAGE_SIZE_1MB;\r\n} else\r\nreturn CPLB_PROT_VIOL;\r\n} else if (addr >= _ramend) {\r\nd_data |= CPLB_USER_RD | CPLB_USER_WR;\r\nif (reserved_mem_dcache_on)\r\nd_data |= CPLB_L1_CHBL;\r\n} else {\r\nmask = current_rwx_mask[cpu];\r\nif (mask) {\r\nint page = addr >> PAGE_SHIFT;\r\nint idx = page >> 5;\r\nint bit = 1 << (page & 31);\r\nif (mask[idx] & bit)\r\nd_data |= CPLB_USER_RD;\r\nmask += page_mask_nelts;\r\nif (mask[idx] & bit)\r\nd_data |= CPLB_USER_WR;\r\n}\r\n}\r\nidx = evict_one_dcplb(cpu);\r\naddr &= PAGE_MASK;\r\ndcplb_tbl[cpu][idx].addr = addr;\r\ndcplb_tbl[cpu][idx].data = d_data;\r\n_disable_dcplb();\r\nbfin_write32(DCPLB_DATA0 + idx * 4, d_data);\r\nbfin_write32(DCPLB_ADDR0 + idx * 4, addr);\r\n_enable_dcplb();\r\nreturn 0;\r\n}\r\nMGR_ATTR static noinline int icplb_miss(unsigned int cpu)\r\n{\r\nunsigned long addr = bfin_read_ICPLB_FAULT_ADDR();\r\nint status = bfin_read_ICPLB_STATUS();\r\nint idx;\r\nunsigned long i_data;\r\nnr_icplb_miss[cpu]++;\r\nif (addr >= _ramend - DMA_UNCACHED_REGION && addr < _ramend)\r\nreturn CPLB_PROT_VIOL;\r\nif (status & FAULT_USERSUPV)\r\nnr_icplb_supv_miss[cpu]++;\r\nfor (idx = first_switched_icplb; idx < MAX_CPLBS; idx++) {\r\nif (icplb_tbl[cpu][idx].data & CPLB_VALID) {\r\nunsigned long this_addr = icplb_tbl[cpu][idx].addr;\r\nif (this_addr <= addr && this_addr + PAGE_SIZE > addr) {\r\naddr += PAGE_SIZE;\r\nbreak;\r\n}\r\n}\r\n}\r\ni_data = CPLB_VALID | CPLB_PORTPRIO | PAGE_SIZE_4KB;\r\n#ifdef CONFIG_BFIN_EXTMEM_ICACHEABLE\r\nif (addr < _ramend ||\r\n(addr < physical_mem_end && reserved_mem_icache_on))\r\ni_data |= CPLB_L1_CHBL | ANOMALY_05000158_WORKAROUND;\r\n#endif\r\nif (L2_LENGTH && addr >= L2_START && addr < L2_START + L2_LENGTH) {\r\naddr = L2_START;\r\ni_data = L2_IMEMORY;\r\n} else if (addr >= physical_mem_end) {\r\nif (addr >= ASYNC_BANK0_BASE && addr < ASYNC_BANK3_BASE + ASYNC_BANK3_SIZE) {\r\nif (!(status & FAULT_USERSUPV)) {\r\nunsigned long *mask = current_rwx_mask[cpu];\r\nif (mask) {\r\nint page = (addr - (ASYNC_BANK0_BASE - _ramend)) >> PAGE_SHIFT;\r\nint idx = page >> 5;\r\nint bit = 1 << (page & 31);\r\nmask += 2 * page_mask_nelts;\r\nif (mask[idx] & bit)\r\ni_data |= CPLB_USER_RD;\r\n}\r\n}\r\n} else if (addr >= BOOT_ROM_START && addr < BOOT_ROM_START + BOOT_ROM_LENGTH\r\n&& (status & FAULT_USERSUPV)) {\r\naddr &= ~(1 * 1024 * 1024 - 1);\r\ni_data &= ~PAGE_SIZE_4KB;\r\ni_data |= PAGE_SIZE_1MB;\r\n} else\r\nreturn CPLB_PROT_VIOL;\r\n} else if (addr >= _ramend) {\r\ni_data |= CPLB_USER_RD;\r\nif (reserved_mem_icache_on)\r\ni_data |= CPLB_L1_CHBL;\r\n} else {\r\nif (!(status & FAULT_USERSUPV)) {\r\nunsigned long *mask = current_rwx_mask[cpu];\r\nif (mask) {\r\nint page = addr >> PAGE_SHIFT;\r\nint idx = page >> 5;\r\nint bit = 1 << (page & 31);\r\nmask += 2 * page_mask_nelts;\r\nif (mask[idx] & bit)\r\ni_data |= CPLB_USER_RD;\r\n}\r\n}\r\n}\r\nidx = evict_one_icplb(cpu);\r\naddr &= PAGE_MASK;\r\nicplb_tbl[cpu][idx].addr = addr;\r\nicplb_tbl[cpu][idx].data = i_data;\r\n_disable_icplb();\r\nbfin_write32(ICPLB_DATA0 + idx * 4, i_data);\r\nbfin_write32(ICPLB_ADDR0 + idx * 4, addr);\r\n_enable_icplb();\r\nreturn 0;\r\n}\r\nMGR_ATTR static noinline int dcplb_protection_fault(unsigned int cpu)\r\n{\r\nint status = bfin_read_DCPLB_STATUS();\r\nnr_dcplb_prot[cpu]++;\r\nif (status & FAULT_RW) {\r\nint idx = faulting_cplb_index(status);\r\nunsigned long data = dcplb_tbl[cpu][idx].data;\r\nif (!(data & CPLB_WT) && !(data & CPLB_DIRTY) &&\r\nwrite_permitted(status, data)) {\r\ndata |= CPLB_DIRTY;\r\ndcplb_tbl[cpu][idx].data = data;\r\nbfin_write32(DCPLB_DATA0 + idx * 4, data);\r\nreturn 0;\r\n}\r\n}\r\nreturn CPLB_PROT_VIOL;\r\n}\r\nMGR_ATTR int cplb_hdr(int seqstat, struct pt_regs *regs)\r\n{\r\nint cause = seqstat & 0x3f;\r\nunsigned int cpu = raw_smp_processor_id();\r\nswitch (cause) {\r\ncase 0x23:\r\nreturn dcplb_protection_fault(cpu);\r\ncase 0x2C:\r\nreturn icplb_miss(cpu);\r\ncase 0x26:\r\nreturn dcplb_miss(cpu);\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nvoid flush_switched_cplbs(unsigned int cpu)\r\n{\r\nint i;\r\nunsigned long flags;\r\nnr_cplb_flush[cpu]++;\r\nflags = hard_local_irq_save();\r\n_disable_icplb();\r\nfor (i = first_switched_icplb; i < MAX_CPLBS; i++) {\r\nicplb_tbl[cpu][i].data = 0;\r\nbfin_write32(ICPLB_DATA0 + i * 4, 0);\r\n}\r\n_enable_icplb();\r\n_disable_dcplb();\r\nfor (i = first_switched_dcplb; i < MAX_CPLBS; i++) {\r\ndcplb_tbl[cpu][i].data = 0;\r\nbfin_write32(DCPLB_DATA0 + i * 4, 0);\r\n}\r\n_enable_dcplb();\r\nhard_local_irq_restore(flags);\r\n}\r\nvoid set_mask_dcplbs(unsigned long *masks, unsigned int cpu)\r\n{\r\nint i;\r\nunsigned long addr = (unsigned long)masks;\r\nunsigned long d_data;\r\nunsigned long flags;\r\nif (!masks) {\r\ncurrent_rwx_mask[cpu] = masks;\r\nreturn;\r\n}\r\nflags = hard_local_irq_save();\r\ncurrent_rwx_mask[cpu] = masks;\r\nif (L2_LENGTH && addr >= L2_START && addr < L2_START + L2_LENGTH) {\r\naddr = L2_START;\r\nd_data = L2_DMEMORY;\r\n} else {\r\nd_data = CPLB_SUPV_WR | CPLB_VALID | CPLB_DIRTY | PAGE_SIZE_4KB;\r\n#ifdef CONFIG_BFIN_EXTMEM_DCACHEABLE\r\nd_data |= CPLB_L1_CHBL;\r\n# ifdef CONFIG_BFIN_EXTMEM_WRITETHROUGH\r\nd_data |= CPLB_L1_AOW | CPLB_WT;\r\n# endif\r\n#endif\r\n}\r\n_disable_dcplb();\r\nfor (i = first_mask_dcplb; i < first_switched_dcplb; i++) {\r\ndcplb_tbl[cpu][i].addr = addr;\r\ndcplb_tbl[cpu][i].data = d_data;\r\nbfin_write32(DCPLB_DATA0 + i * 4, d_data);\r\nbfin_write32(DCPLB_ADDR0 + i * 4, addr);\r\naddr += PAGE_SIZE;\r\n}\r\n_enable_dcplb();\r\nhard_local_irq_restore(flags);\r\n}
