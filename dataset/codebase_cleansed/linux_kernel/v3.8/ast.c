static void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\r\n{\r\nint i;\r\nlog_print("last_bast %x %llu flags %x mode %d sb %d %x",\r\nlkb->lkb_id,\r\n(unsigned long long)lkb->lkb_last_bast.seq,\r\nlkb->lkb_last_bast.flags,\r\nlkb->lkb_last_bast.mode,\r\nlkb->lkb_last_bast.sb_status,\r\nlkb->lkb_last_bast.sb_flags);\r\nlog_print("last_cast %x %llu flags %x mode %d sb %d %x",\r\nlkb->lkb_id,\r\n(unsigned long long)lkb->lkb_last_cast.seq,\r\nlkb->lkb_last_cast.flags,\r\nlkb->lkb_last_cast.mode,\r\nlkb->lkb_last_cast.sb_status,\r\nlkb->lkb_last_cast.sb_flags);\r\nfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\r\nlog_print("cb %x %llu flags %x mode %d sb %d %x",\r\nlkb->lkb_id,\r\n(unsigned long long)lkb->lkb_callbacks[i].seq,\r\nlkb->lkb_callbacks[i].flags,\r\nlkb->lkb_callbacks[i].mode,\r\nlkb->lkb_callbacks[i].sb_status,\r\nlkb->lkb_callbacks[i].sb_flags);\r\n}\r\n}\r\nint dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\r\nint status, uint32_t sbflags, uint64_t seq)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nuint64_t prev_seq;\r\nint prev_mode;\r\nint i, rv;\r\nfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\r\nif (lkb->lkb_callbacks[i].seq)\r\ncontinue;\r\nif ((i > 0) && (flags & DLM_CB_BAST) &&\r\n(lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\r\nprev_seq = lkb->lkb_callbacks[i-1].seq;\r\nprev_mode = lkb->lkb_callbacks[i-1].mode;\r\nif ((prev_mode == mode) ||\r\n(prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\r\nlog_debug(ls, "skip %x add bast %llu mode %d "\r\n"for bast %llu mode %d",\r\nlkb->lkb_id,\r\n(unsigned long long)seq,\r\nmode,\r\n(unsigned long long)prev_seq,\r\nprev_mode);\r\nrv = 0;\r\ngoto out;\r\n}\r\n}\r\nlkb->lkb_callbacks[i].seq = seq;\r\nlkb->lkb_callbacks[i].flags = flags;\r\nlkb->lkb_callbacks[i].mode = mode;\r\nlkb->lkb_callbacks[i].sb_status = status;\r\nlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\r\nrv = 0;\r\nbreak;\r\n}\r\nif (i == DLM_CALLBACKS_SIZE) {\r\nlog_error(ls, "no callbacks %x %llu flags %x mode %d sb %d %x",\r\nlkb->lkb_id, (unsigned long long)seq,\r\nflags, mode, status, sbflags);\r\ndlm_dump_lkb_callbacks(lkb);\r\nrv = -1;\r\ngoto out;\r\n}\r\nout:\r\nreturn rv;\r\n}\r\nint dlm_rem_lkb_callback(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_callback *cb, int *resid)\r\n{\r\nint i, rv;\r\n*resid = 0;\r\nif (!lkb->lkb_callbacks[0].seq) {\r\nrv = -ENOENT;\r\ngoto out;\r\n}\r\nmemcpy(cb, &lkb->lkb_callbacks[0], sizeof(struct dlm_callback));\r\nmemset(&lkb->lkb_callbacks[0], 0, sizeof(struct dlm_callback));\r\nfor (i = 1; i < DLM_CALLBACKS_SIZE; i++) {\r\nif (!lkb->lkb_callbacks[i].seq)\r\nbreak;\r\nmemcpy(&lkb->lkb_callbacks[i-1], &lkb->lkb_callbacks[i],\r\nsizeof(struct dlm_callback));\r\nmemset(&lkb->lkb_callbacks[i], 0, sizeof(struct dlm_callback));\r\n(*resid)++;\r\n}\r\nif ((cb->flags & DLM_CB_BAST) && lkb->lkb_last_cast.seq) {\r\nif (dlm_modes_compat(cb->mode, lkb->lkb_last_cast.mode)) {\r\ncb->flags |= DLM_CB_SKIP;\r\nlog_debug(ls, "skip %x bast %llu mode %d "\r\n"for cast %llu mode %d",\r\nlkb->lkb_id,\r\n(unsigned long long)cb->seq,\r\ncb->mode,\r\n(unsigned long long)lkb->lkb_last_cast.seq,\r\nlkb->lkb_last_cast.mode);\r\nrv = 0;\r\ngoto out;\r\n}\r\n}\r\nif (cb->flags & DLM_CB_CAST) {\r\nmemcpy(&lkb->lkb_last_cast, cb, sizeof(struct dlm_callback));\r\nlkb->lkb_last_cast_time = ktime_get();\r\n}\r\nif (cb->flags & DLM_CB_BAST) {\r\nmemcpy(&lkb->lkb_last_bast, cb, sizeof(struct dlm_callback));\r\nlkb->lkb_last_bast_time = ktime_get();\r\n}\r\nrv = 0;\r\nout:\r\nreturn rv;\r\n}\r\nvoid dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\r\nuint32_t sbflags)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nuint64_t new_seq, prev_seq;\r\nint rv;\r\nspin_lock(&dlm_cb_seq_spin);\r\nnew_seq = ++dlm_cb_seq;\r\nspin_unlock(&dlm_cb_seq_spin);\r\nif (lkb->lkb_flags & DLM_IFL_USER) {\r\ndlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\r\nreturn;\r\n}\r\nmutex_lock(&lkb->lkb_cb_mutex);\r\nprev_seq = lkb->lkb_callbacks[0].seq;\r\nrv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\r\nif (rv < 0)\r\ngoto out;\r\nif (!prev_seq) {\r\nkref_get(&lkb->lkb_ref);\r\nif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\r\nmutex_lock(&ls->ls_cb_mutex);\r\nlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\r\nmutex_unlock(&ls->ls_cb_mutex);\r\n} else {\r\nqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&lkb->lkb_cb_mutex);\r\n}\r\nvoid dlm_callback_work(struct work_struct *work)\r\n{\r\nstruct dlm_lkb *lkb = container_of(work, struct dlm_lkb, lkb_cb_work);\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nvoid (*castfn) (void *astparam);\r\nvoid (*bastfn) (void *astparam, int mode);\r\nstruct dlm_callback callbacks[DLM_CALLBACKS_SIZE];\r\nint i, rv, resid;\r\nmemset(&callbacks, 0, sizeof(callbacks));\r\nmutex_lock(&lkb->lkb_cb_mutex);\r\nif (!lkb->lkb_callbacks[0].seq) {\r\nlog_error(ls, "dlm_callback_work %x no work", lkb->lkb_id);\r\ndlm_print_lkb(lkb);\r\ndlm_dump_lkb_callbacks(lkb);\r\n}\r\nfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\r\nrv = dlm_rem_lkb_callback(ls, lkb, &callbacks[i], &resid);\r\nif (rv < 0)\r\nbreak;\r\n}\r\nif (resid) {\r\nlog_error(ls, "dlm_callback_work %x resid %d", lkb->lkb_id,\r\nresid);\r\ndlm_print_lkb(lkb);\r\ndlm_dump_lkb_callbacks(lkb);\r\n}\r\nmutex_unlock(&lkb->lkb_cb_mutex);\r\ncastfn = lkb->lkb_astfn;\r\nbastfn = lkb->lkb_bastfn;\r\nfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\r\nif (!callbacks[i].seq)\r\nbreak;\r\nif (callbacks[i].flags & DLM_CB_SKIP) {\r\ncontinue;\r\n} else if (callbacks[i].flags & DLM_CB_BAST) {\r\nbastfn(lkb->lkb_astparam, callbacks[i].mode);\r\n} else if (callbacks[i].flags & DLM_CB_CAST) {\r\nlkb->lkb_lksb->sb_status = callbacks[i].sb_status;\r\nlkb->lkb_lksb->sb_flags = callbacks[i].sb_flags;\r\ncastfn(lkb->lkb_astparam);\r\n}\r\n}\r\ndlm_put_lkb(lkb);\r\n}\r\nint dlm_callback_start(struct dlm_ls *ls)\r\n{\r\nls->ls_callback_wq = alloc_workqueue("dlm_callback",\r\nWQ_UNBOUND |\r\nWQ_MEM_RECLAIM |\r\nWQ_NON_REENTRANT,\r\n0);\r\nif (!ls->ls_callback_wq) {\r\nlog_print("can't start dlm_callback workqueue");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid dlm_callback_stop(struct dlm_ls *ls)\r\n{\r\nif (ls->ls_callback_wq)\r\ndestroy_workqueue(ls->ls_callback_wq);\r\n}\r\nvoid dlm_callback_suspend(struct dlm_ls *ls)\r\n{\r\nset_bit(LSFL_CB_DELAY, &ls->ls_flags);\r\nif (ls->ls_callback_wq)\r\nflush_workqueue(ls->ls_callback_wq);\r\n}\r\nvoid dlm_callback_resume(struct dlm_ls *ls)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nint count = 0;\r\nclear_bit(LSFL_CB_DELAY, &ls->ls_flags);\r\nif (!ls->ls_callback_wq)\r\nreturn;\r\nmutex_lock(&ls->ls_cb_mutex);\r\nlist_for_each_entry_safe(lkb, safe, &ls->ls_cb_delay, lkb_cb_list) {\r\nlist_del_init(&lkb->lkb_cb_list);\r\nqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\r\ncount++;\r\n}\r\nmutex_unlock(&ls->ls_cb_mutex);\r\nif (count)\r\nlog_debug(ls, "dlm_callback_resume %d", count);\r\n}
