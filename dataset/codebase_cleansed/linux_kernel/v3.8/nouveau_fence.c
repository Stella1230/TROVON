void\r\nnouveau_fence_context_del(struct nouveau_fence_chan *fctx)\r\n{\r\nstruct nouveau_fence *fence, *fnext;\r\nspin_lock(&fctx->lock);\r\nlist_for_each_entry_safe(fence, fnext, &fctx->pending, head) {\r\nif (fence->work)\r\nfence->work(fence->priv, false);\r\nfence->channel = NULL;\r\nlist_del(&fence->head);\r\nnouveau_fence_unref(&fence);\r\n}\r\nspin_unlock(&fctx->lock);\r\n}\r\nvoid\r\nnouveau_fence_context_new(struct nouveau_fence_chan *fctx)\r\n{\r\nINIT_LIST_HEAD(&fctx->flip);\r\nINIT_LIST_HEAD(&fctx->pending);\r\nspin_lock_init(&fctx->lock);\r\n}\r\nstatic void\r\nnouveau_fence_update(struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_priv *priv = chan->drm->fence;\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct nouveau_fence *fence, *fnext;\r\nspin_lock(&fctx->lock);\r\nlist_for_each_entry_safe(fence, fnext, &fctx->pending, head) {\r\nif (priv->read(chan) < fence->sequence)\r\nbreak;\r\nif (fence->work)\r\nfence->work(fence->priv, true);\r\nfence->channel = NULL;\r\nlist_del(&fence->head);\r\nnouveau_fence_unref(&fence);\r\n}\r\nspin_unlock(&fctx->lock);\r\n}\r\nint\r\nnouveau_fence_emit(struct nouveau_fence *fence, struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_priv *priv = chan->drm->fence;\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nint ret;\r\nfence->channel = chan;\r\nfence->timeout = jiffies + (3 * DRM_HZ);\r\nfence->sequence = ++fctx->sequence;\r\nret = priv->emit(fence);\r\nif (!ret) {\r\nkref_get(&fence->kref);\r\nspin_lock(&fctx->lock);\r\nlist_add_tail(&fence->head, &fctx->pending);\r\nspin_unlock(&fctx->lock);\r\n}\r\nreturn ret;\r\n}\r\nbool\r\nnouveau_fence_done(struct nouveau_fence *fence)\r\n{\r\nif (fence->channel)\r\nnouveau_fence_update(fence->channel);\r\nreturn !fence->channel;\r\n}\r\nint\r\nnouveau_fence_wait(struct nouveau_fence *fence, bool lazy, bool intr)\r\n{\r\nunsigned long sleep_time = NSEC_PER_MSEC / 1000;\r\nktime_t t;\r\nint ret = 0;\r\nwhile (!nouveau_fence_done(fence)) {\r\nif (fence->timeout && time_after_eq(jiffies, fence->timeout)) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n__set_current_state(intr ? TASK_INTERRUPTIBLE :\r\nTASK_UNINTERRUPTIBLE);\r\nif (lazy) {\r\nt = ktime_set(0, sleep_time);\r\nschedule_hrtimeout(&t, HRTIMER_MODE_REL);\r\nsleep_time *= 2;\r\nif (sleep_time > NSEC_PER_MSEC)\r\nsleep_time = NSEC_PER_MSEC;\r\n}\r\nif (intr && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_fence_sync(struct nouveau_fence *fence, struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_priv *priv = chan->drm->fence;\r\nstruct nouveau_channel *prev;\r\nint ret = 0;\r\nprev = fence ? fence->channel : NULL;\r\nif (prev) {\r\nif (unlikely(prev != chan && !nouveau_fence_done(fence))) {\r\nret = priv->sync(fence, prev, chan);\r\nif (unlikely(ret))\r\nret = nouveau_fence_wait(fence, true, false);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnouveau_fence_del(struct kref *kref)\r\n{\r\nstruct nouveau_fence *fence = container_of(kref, typeof(*fence), kref);\r\nkfree(fence);\r\n}\r\nvoid\r\nnouveau_fence_unref(struct nouveau_fence **pfence)\r\n{\r\nif (*pfence)\r\nkref_put(&(*pfence)->kref, nouveau_fence_del);\r\n*pfence = NULL;\r\n}\r\nstruct nouveau_fence *\r\nnouveau_fence_ref(struct nouveau_fence *fence)\r\n{\r\nkref_get(&fence->kref);\r\nreturn fence;\r\n}\r\nint\r\nnouveau_fence_new(struct nouveau_channel *chan, struct nouveau_fence **pfence)\r\n{\r\nstruct nouveau_fence *fence;\r\nint ret = 0;\r\nif (unlikely(!chan->fence))\r\nreturn -ENODEV;\r\nfence = kzalloc(sizeof(*fence), GFP_KERNEL);\r\nif (!fence)\r\nreturn -ENOMEM;\r\nkref_init(&fence->kref);\r\nif (chan) {\r\nret = nouveau_fence_emit(fence, chan);\r\nif (ret)\r\nnouveau_fence_unref(&fence);\r\n}\r\n*pfence = fence;\r\nreturn ret;\r\n}
