static inline struct mqueue_inode_info *MQUEUE_I(struct inode *inode)\r\n{\r\nreturn container_of(inode, struct mqueue_inode_info, vfs_inode);\r\n}\r\nstatic inline struct ipc_namespace *__get_ns_from_inode(struct inode *inode)\r\n{\r\nreturn get_ipc_ns(inode->i_sb->s_fs_info);\r\n}\r\nstatic struct ipc_namespace *get_ns_from_inode(struct inode *inode)\r\n{\r\nstruct ipc_namespace *ns;\r\nspin_lock(&mq_lock);\r\nns = __get_ns_from_inode(inode);\r\nspin_unlock(&mq_lock);\r\nreturn ns;\r\n}\r\nstatic int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)\r\n{\r\nstruct rb_node **p, *parent = NULL;\r\nstruct posix_msg_tree_node *leaf;\r\np = &info->msg_tree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\r\nif (likely(leaf->priority == msg->m_type))\r\ngoto insert_msg;\r\nelse if (msg->m_type < leaf->priority)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nif (info->node_cache) {\r\nleaf = info->node_cache;\r\ninfo->node_cache = NULL;\r\n} else {\r\nleaf = kmalloc(sizeof(*leaf), GFP_ATOMIC);\r\nif (!leaf)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&leaf->msg_list);\r\ninfo->qsize += sizeof(*leaf);\r\n}\r\nleaf->priority = msg->m_type;\r\nrb_link_node(&leaf->rb_node, parent, p);\r\nrb_insert_color(&leaf->rb_node, &info->msg_tree);\r\ninsert_msg:\r\ninfo->attr.mq_curmsgs++;\r\ninfo->qsize += msg->m_ts;\r\nlist_add_tail(&msg->m_list, &leaf->msg_list);\r\nreturn 0;\r\n}\r\nstatic inline struct msg_msg *msg_get(struct mqueue_inode_info *info)\r\n{\r\nstruct rb_node **p, *parent = NULL;\r\nstruct posix_msg_tree_node *leaf;\r\nstruct msg_msg *msg;\r\ntry_again:\r\np = &info->msg_tree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\np = &(*p)->rb_right;\r\n}\r\nif (!parent) {\r\nif (info->attr.mq_curmsgs) {\r\npr_warn_once("Inconsistency in POSIX message queue, "\r\n"no tree element, but supposedly messages "\r\n"should exist!\n");\r\ninfo->attr.mq_curmsgs = 0;\r\n}\r\nreturn NULL;\r\n}\r\nleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\r\nif (unlikely(list_empty(&leaf->msg_list))) {\r\npr_warn_once("Inconsistency in POSIX message queue, "\r\n"empty leaf node but we haven't implemented "\r\n"lazy leaf delete!\n");\r\nrb_erase(&leaf->rb_node, &info->msg_tree);\r\nif (info->node_cache) {\r\ninfo->qsize -= sizeof(*leaf);\r\nkfree(leaf);\r\n} else {\r\ninfo->node_cache = leaf;\r\n}\r\ngoto try_again;\r\n} else {\r\nmsg = list_first_entry(&leaf->msg_list,\r\nstruct msg_msg, m_list);\r\nlist_del(&msg->m_list);\r\nif (list_empty(&leaf->msg_list)) {\r\nrb_erase(&leaf->rb_node, &info->msg_tree);\r\nif (info->node_cache) {\r\ninfo->qsize -= sizeof(*leaf);\r\nkfree(leaf);\r\n} else {\r\ninfo->node_cache = leaf;\r\n}\r\n}\r\n}\r\ninfo->attr.mq_curmsgs--;\r\ninfo->qsize -= msg->m_ts;\r\nreturn msg;\r\n}\r\nstatic struct inode *mqueue_get_inode(struct super_block *sb,\r\nstruct ipc_namespace *ipc_ns, umode_t mode,\r\nstruct mq_attr *attr)\r\n{\r\nstruct user_struct *u = current_user();\r\nstruct inode *inode;\r\nint ret = -ENOMEM;\r\ninode = new_inode(sb);\r\nif (!inode)\r\ngoto err;\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = mode;\r\ninode->i_uid = current_fsuid();\r\ninode->i_gid = current_fsgid();\r\ninode->i_mtime = inode->i_ctime = inode->i_atime = CURRENT_TIME;\r\nif (S_ISREG(mode)) {\r\nstruct mqueue_inode_info *info;\r\nunsigned long mq_bytes, mq_treesize;\r\ninode->i_fop = &mqueue_file_operations;\r\ninode->i_size = FILENT_SIZE;\r\ninfo = MQUEUE_I(inode);\r\nspin_lock_init(&info->lock);\r\ninit_waitqueue_head(&info->wait_q);\r\nINIT_LIST_HEAD(&info->e_wait_q[0].list);\r\nINIT_LIST_HEAD(&info->e_wait_q[1].list);\r\ninfo->notify_owner = NULL;\r\ninfo->notify_user_ns = NULL;\r\ninfo->qsize = 0;\r\ninfo->user = NULL;\r\ninfo->msg_tree = RB_ROOT;\r\ninfo->node_cache = NULL;\r\nmemset(&info->attr, 0, sizeof(info->attr));\r\ninfo->attr.mq_maxmsg = min(ipc_ns->mq_msg_max,\r\nipc_ns->mq_msg_default);\r\ninfo->attr.mq_msgsize = min(ipc_ns->mq_msgsize_max,\r\nipc_ns->mq_msgsize_default);\r\nif (attr) {\r\ninfo->attr.mq_maxmsg = attr->mq_maxmsg;\r\ninfo->attr.mq_msgsize = attr->mq_msgsize;\r\n}\r\nmq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +\r\nmin_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *\r\nsizeof(struct posix_msg_tree_node);\r\nmq_bytes = mq_treesize + (info->attr.mq_maxmsg *\r\ninfo->attr.mq_msgsize);\r\nspin_lock(&mq_lock);\r\nif (u->mq_bytes + mq_bytes < u->mq_bytes ||\r\nu->mq_bytes + mq_bytes > rlimit(RLIMIT_MSGQUEUE)) {\r\nspin_unlock(&mq_lock);\r\nret = -EMFILE;\r\ngoto out_inode;\r\n}\r\nu->mq_bytes += mq_bytes;\r\nspin_unlock(&mq_lock);\r\ninfo->user = get_uid(u);\r\n} else if (S_ISDIR(mode)) {\r\ninc_nlink(inode);\r\ninode->i_size = 2 * DIRENT_SIZE;\r\ninode->i_op = &mqueue_dir_inode_operations;\r\ninode->i_fop = &simple_dir_operations;\r\n}\r\nreturn inode;\r\nout_inode:\r\niput(inode);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int mqueue_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct inode *inode;\r\nstruct ipc_namespace *ns = data;\r\nsb->s_blocksize = PAGE_CACHE_SIZE;\r\nsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\r\nsb->s_magic = MQUEUE_MAGIC;\r\nsb->s_op = &mqueue_super_ops;\r\ninode = mqueue_get_inode(sb, ns, S_IFDIR | S_ISVTX | S_IRWXUGO, NULL);\r\nif (IS_ERR(inode))\r\nreturn PTR_ERR(inode);\r\nsb->s_root = d_make_root(inode);\r\nif (!sb->s_root)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic struct dentry *mqueue_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name,\r\nvoid *data)\r\n{\r\nif (!(flags & MS_KERNMOUNT))\r\ndata = current->nsproxy->ipc_ns;\r\nreturn mount_ns(fs_type, flags, data, mqueue_fill_super);\r\n}\r\nstatic void init_once(void *foo)\r\n{\r\nstruct mqueue_inode_info *p = (struct mqueue_inode_info *) foo;\r\ninode_init_once(&p->vfs_inode);\r\n}\r\nstatic struct inode *mqueue_alloc_inode(struct super_block *sb)\r\n{\r\nstruct mqueue_inode_info *ei;\r\nei = kmem_cache_alloc(mqueue_inode_cachep, GFP_KERNEL);\r\nif (!ei)\r\nreturn NULL;\r\nreturn &ei->vfs_inode;\r\n}\r\nstatic void mqueue_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(mqueue_inode_cachep, MQUEUE_I(inode));\r\n}\r\nstatic void mqueue_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, mqueue_i_callback);\r\n}\r\nstatic void mqueue_evict_inode(struct inode *inode)\r\n{\r\nstruct mqueue_inode_info *info;\r\nstruct user_struct *user;\r\nunsigned long mq_bytes, mq_treesize;\r\nstruct ipc_namespace *ipc_ns;\r\nstruct msg_msg *msg;\r\nclear_inode(inode);\r\nif (S_ISDIR(inode->i_mode))\r\nreturn;\r\nipc_ns = get_ns_from_inode(inode);\r\ninfo = MQUEUE_I(inode);\r\nspin_lock(&info->lock);\r\nwhile ((msg = msg_get(info)) != NULL)\r\nfree_msg(msg);\r\nkfree(info->node_cache);\r\nspin_unlock(&info->lock);\r\nmq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +\r\nmin_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *\r\nsizeof(struct posix_msg_tree_node);\r\nmq_bytes = mq_treesize + (info->attr.mq_maxmsg *\r\ninfo->attr.mq_msgsize);\r\nuser = info->user;\r\nif (user) {\r\nspin_lock(&mq_lock);\r\nuser->mq_bytes -= mq_bytes;\r\nif (ipc_ns)\r\nipc_ns->mq_queues_count--;\r\nspin_unlock(&mq_lock);\r\nfree_uid(user);\r\n}\r\nif (ipc_ns)\r\nput_ipc_ns(ipc_ns);\r\n}\r\nstatic int mqueue_create(struct inode *dir, struct dentry *dentry,\r\numode_t mode, bool excl)\r\n{\r\nstruct inode *inode;\r\nstruct mq_attr *attr = dentry->d_fsdata;\r\nint error;\r\nstruct ipc_namespace *ipc_ns;\r\nspin_lock(&mq_lock);\r\nipc_ns = __get_ns_from_inode(dir);\r\nif (!ipc_ns) {\r\nerror = -EACCES;\r\ngoto out_unlock;\r\n}\r\nif (ipc_ns->mq_queues_count >= HARD_QUEUESMAX ||\r\n(ipc_ns->mq_queues_count >= ipc_ns->mq_queues_max &&\r\n!capable(CAP_SYS_RESOURCE))) {\r\nerror = -ENOSPC;\r\ngoto out_unlock;\r\n}\r\nipc_ns->mq_queues_count++;\r\nspin_unlock(&mq_lock);\r\ninode = mqueue_get_inode(dir->i_sb, ipc_ns, mode, attr);\r\nif (IS_ERR(inode)) {\r\nerror = PTR_ERR(inode);\r\nspin_lock(&mq_lock);\r\nipc_ns->mq_queues_count--;\r\ngoto out_unlock;\r\n}\r\nput_ipc_ns(ipc_ns);\r\ndir->i_size += DIRENT_SIZE;\r\ndir->i_ctime = dir->i_mtime = dir->i_atime = CURRENT_TIME;\r\nd_instantiate(dentry, inode);\r\ndget(dentry);\r\nreturn 0;\r\nout_unlock:\r\nspin_unlock(&mq_lock);\r\nif (ipc_ns)\r\nput_ipc_ns(ipc_ns);\r\nreturn error;\r\n}\r\nstatic int mqueue_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\ndir->i_ctime = dir->i_mtime = dir->i_atime = CURRENT_TIME;\r\ndir->i_size -= DIRENT_SIZE;\r\ndrop_nlink(inode);\r\ndput(dentry);\r\nreturn 0;\r\n}\r\nstatic ssize_t mqueue_read_file(struct file *filp, char __user *u_data,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct mqueue_inode_info *info = MQUEUE_I(filp->f_path.dentry->d_inode);\r\nchar buffer[FILENT_SIZE];\r\nssize_t ret;\r\nspin_lock(&info->lock);\r\nsnprintf(buffer, sizeof(buffer),\r\n"QSIZE:%-10lu NOTIFY:%-5d SIGNO:%-5d NOTIFY_PID:%-6d\n",\r\ninfo->qsize,\r\ninfo->notify_owner ? info->notify.sigev_notify : 0,\r\n(info->notify_owner &&\r\ninfo->notify.sigev_notify == SIGEV_SIGNAL) ?\r\ninfo->notify.sigev_signo : 0,\r\npid_vnr(info->notify_owner));\r\nspin_unlock(&info->lock);\r\nbuffer[sizeof(buffer)-1] = '\0';\r\nret = simple_read_from_buffer(u_data, count, off, buffer,\r\nstrlen(buffer));\r\nif (ret <= 0)\r\nreturn ret;\r\nfilp->f_path.dentry->d_inode->i_atime = filp->f_path.dentry->d_inode->i_ctime = CURRENT_TIME;\r\nreturn ret;\r\n}\r\nstatic int mqueue_flush_file(struct file *filp, fl_owner_t id)\r\n{\r\nstruct mqueue_inode_info *info = MQUEUE_I(filp->f_path.dentry->d_inode);\r\nspin_lock(&info->lock);\r\nif (task_tgid(current) == info->notify_owner)\r\nremove_notification(info);\r\nspin_unlock(&info->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int mqueue_poll_file(struct file *filp, struct poll_table_struct *poll_tab)\r\n{\r\nstruct mqueue_inode_info *info = MQUEUE_I(filp->f_path.dentry->d_inode);\r\nint retval = 0;\r\npoll_wait(filp, &info->wait_q, poll_tab);\r\nspin_lock(&info->lock);\r\nif (info->attr.mq_curmsgs)\r\nretval = POLLIN | POLLRDNORM;\r\nif (info->attr.mq_curmsgs < info->attr.mq_maxmsg)\r\nretval |= POLLOUT | POLLWRNORM;\r\nspin_unlock(&info->lock);\r\nreturn retval;\r\n}\r\nstatic void wq_add(struct mqueue_inode_info *info, int sr,\r\nstruct ext_wait_queue *ewp)\r\n{\r\nstruct ext_wait_queue *walk;\r\newp->task = current;\r\nlist_for_each_entry(walk, &info->e_wait_q[sr].list, list) {\r\nif (walk->task->static_prio <= current->static_prio) {\r\nlist_add_tail(&ewp->list, &walk->list);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&ewp->list, &info->e_wait_q[sr].list);\r\n}\r\nstatic int wq_sleep(struct mqueue_inode_info *info, int sr,\r\nktime_t *timeout, struct ext_wait_queue *ewp)\r\n{\r\nint retval;\r\nsigned long time;\r\nwq_add(info, sr, ewp);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock(&info->lock);\r\ntime = schedule_hrtimeout_range_clock(timeout, 0,\r\nHRTIMER_MODE_ABS, CLOCK_REALTIME);\r\nwhile (ewp->state == STATE_PENDING)\r\ncpu_relax();\r\nif (ewp->state == STATE_READY) {\r\nretval = 0;\r\ngoto out;\r\n}\r\nspin_lock(&info->lock);\r\nif (ewp->state == STATE_READY) {\r\nretval = 0;\r\ngoto out_unlock;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (time == 0) {\r\nretval = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nlist_del(&ewp->list);\r\nout_unlock:\r\nspin_unlock(&info->lock);\r\nout:\r\nreturn retval;\r\n}\r\nstatic struct ext_wait_queue *wq_get_first_waiter(\r\nstruct mqueue_inode_info *info, int sr)\r\n{\r\nstruct list_head *ptr;\r\nptr = info->e_wait_q[sr].list.prev;\r\nif (ptr == &info->e_wait_q[sr].list)\r\nreturn NULL;\r\nreturn list_entry(ptr, struct ext_wait_queue, list);\r\n}\r\nstatic inline void set_cookie(struct sk_buff *skb, char code)\r\n{\r\n((char*)skb->data)[NOTIFY_COOKIE_LEN-1] = code;\r\n}\r\nstatic void __do_notify(struct mqueue_inode_info *info)\r\n{\r\nif (info->notify_owner &&\r\ninfo->attr.mq_curmsgs == 1) {\r\nstruct siginfo sig_i;\r\nswitch (info->notify.sigev_notify) {\r\ncase SIGEV_NONE:\r\nbreak;\r\ncase SIGEV_SIGNAL:\r\nsig_i.si_signo = info->notify.sigev_signo;\r\nsig_i.si_errno = 0;\r\nsig_i.si_code = SI_MESGQ;\r\nsig_i.si_value = info->notify.sigev_value;\r\nrcu_read_lock();\r\nsig_i.si_pid = task_tgid_nr_ns(current,\r\nns_of_pid(info->notify_owner));\r\nsig_i.si_uid = from_kuid_munged(info->notify_user_ns, current_uid());\r\nrcu_read_unlock();\r\nkill_pid_info(info->notify.sigev_signo,\r\n&sig_i, info->notify_owner);\r\nbreak;\r\ncase SIGEV_THREAD:\r\nset_cookie(info->notify_cookie, NOTIFY_WOKENUP);\r\nnetlink_sendskb(info->notify_sock, info->notify_cookie);\r\nbreak;\r\n}\r\nput_pid(info->notify_owner);\r\nput_user_ns(info->notify_user_ns);\r\ninfo->notify_owner = NULL;\r\ninfo->notify_user_ns = NULL;\r\n}\r\nwake_up(&info->wait_q);\r\n}\r\nstatic int prepare_timeout(const struct timespec __user *u_abs_timeout,\r\nktime_t *expires, struct timespec *ts)\r\n{\r\nif (copy_from_user(ts, u_abs_timeout, sizeof(struct timespec)))\r\nreturn -EFAULT;\r\nif (!timespec_valid(ts))\r\nreturn -EINVAL;\r\n*expires = timespec_to_ktime(*ts);\r\nreturn 0;\r\n}\r\nstatic void remove_notification(struct mqueue_inode_info *info)\r\n{\r\nif (info->notify_owner != NULL &&\r\ninfo->notify.sigev_notify == SIGEV_THREAD) {\r\nset_cookie(info->notify_cookie, NOTIFY_REMOVED);\r\nnetlink_sendskb(info->notify_sock, info->notify_cookie);\r\n}\r\nput_pid(info->notify_owner);\r\nput_user_ns(info->notify_user_ns);\r\ninfo->notify_owner = NULL;\r\ninfo->notify_user_ns = NULL;\r\n}\r\nstatic int mq_attr_ok(struct ipc_namespace *ipc_ns, struct mq_attr *attr)\r\n{\r\nint mq_treesize;\r\nunsigned long total_size;\r\nif (attr->mq_maxmsg <= 0 || attr->mq_msgsize <= 0)\r\nreturn -EINVAL;\r\nif (capable(CAP_SYS_RESOURCE)) {\r\nif (attr->mq_maxmsg > HARD_MSGMAX ||\r\nattr->mq_msgsize > HARD_MSGSIZEMAX)\r\nreturn -EINVAL;\r\n} else {\r\nif (attr->mq_maxmsg > ipc_ns->mq_msg_max ||\r\nattr->mq_msgsize > ipc_ns->mq_msgsize_max)\r\nreturn -EINVAL;\r\n}\r\nif (attr->mq_msgsize > ULONG_MAX/attr->mq_maxmsg)\r\nreturn -EOVERFLOW;\r\nmq_treesize = attr->mq_maxmsg * sizeof(struct msg_msg) +\r\nmin_t(unsigned int, attr->mq_maxmsg, MQ_PRIO_MAX) *\r\nsizeof(struct posix_msg_tree_node);\r\ntotal_size = attr->mq_maxmsg * attr->mq_msgsize;\r\nif (total_size + mq_treesize < total_size)\r\nreturn -EOVERFLOW;\r\nreturn 0;\r\n}\r\nstatic struct file *do_create(struct ipc_namespace *ipc_ns, struct inode *dir,\r\nstruct path *path, int oflag, umode_t mode,\r\nstruct mq_attr *attr)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint ret;\r\nif (attr) {\r\nret = mq_attr_ok(ipc_ns, attr);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\npath->dentry->d_fsdata = attr;\r\n} else {\r\nstruct mq_attr def_attr;\r\ndef_attr.mq_maxmsg = min(ipc_ns->mq_msg_max,\r\nipc_ns->mq_msg_default);\r\ndef_attr.mq_msgsize = min(ipc_ns->mq_msgsize_max,\r\nipc_ns->mq_msgsize_default);\r\nret = mq_attr_ok(ipc_ns, &def_attr);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\n}\r\nmode &= ~current_umask();\r\nret = vfs_create(dir, path->dentry, mode, true);\r\npath->dentry->d_fsdata = NULL;\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn dentry_open(path, oflag, cred);\r\n}\r\nstatic struct file *do_open(struct path *path, int oflag)\r\n{\r\nstatic const int oflag2acc[O_ACCMODE] = { MAY_READ, MAY_WRITE,\r\nMAY_READ | MAY_WRITE };\r\nint acc;\r\nif ((oflag & O_ACCMODE) == (O_RDWR | O_WRONLY))\r\nreturn ERR_PTR(-EINVAL);\r\nacc = oflag2acc[oflag & O_ACCMODE];\r\nif (inode_permission(path->dentry->d_inode, acc))\r\nreturn ERR_PTR(-EACCES);\r\nreturn dentry_open(path, oflag, current_cred());\r\n}\r\nstatic inline void pipelined_send(struct mqueue_inode_info *info,\r\nstruct msg_msg *message,\r\nstruct ext_wait_queue *receiver)\r\n{\r\nreceiver->msg = message;\r\nlist_del(&receiver->list);\r\nreceiver->state = STATE_PENDING;\r\nwake_up_process(receiver->task);\r\nsmp_wmb();\r\nreceiver->state = STATE_READY;\r\n}\r\nstatic inline void pipelined_receive(struct mqueue_inode_info *info)\r\n{\r\nstruct ext_wait_queue *sender = wq_get_first_waiter(info, SEND);\r\nif (!sender) {\r\nwake_up_interruptible(&info->wait_q);\r\nreturn;\r\n}\r\nif (msg_insert(sender->msg, info))\r\nreturn;\r\nlist_del(&sender->list);\r\nsender->state = STATE_PENDING;\r\nwake_up_process(sender->task);\r\nsmp_wmb();\r\nsender->state = STATE_READY;\r\n}\r\nint mq_init_ns(struct ipc_namespace *ns)\r\n{\r\nns->mq_queues_count = 0;\r\nns->mq_queues_max = DFLT_QUEUESMAX;\r\nns->mq_msg_max = DFLT_MSGMAX;\r\nns->mq_msgsize_max = DFLT_MSGSIZEMAX;\r\nns->mq_msg_default = DFLT_MSG;\r\nns->mq_msgsize_default = DFLT_MSGSIZE;\r\nns->mq_mnt = kern_mount_data(&mqueue_fs_type, ns);\r\nif (IS_ERR(ns->mq_mnt)) {\r\nint err = PTR_ERR(ns->mq_mnt);\r\nns->mq_mnt = NULL;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid mq_clear_sbinfo(struct ipc_namespace *ns)\r\n{\r\nns->mq_mnt->mnt_sb->s_fs_info = NULL;\r\n}\r\nvoid mq_put_mnt(struct ipc_namespace *ns)\r\n{\r\nkern_unmount(ns->mq_mnt);\r\n}\r\nstatic int __init init_mqueue_fs(void)\r\n{\r\nint error;\r\nmqueue_inode_cachep = kmem_cache_create("mqueue_inode_cache",\r\nsizeof(struct mqueue_inode_info), 0,\r\nSLAB_HWCACHE_ALIGN, init_once);\r\nif (mqueue_inode_cachep == NULL)\r\nreturn -ENOMEM;\r\nmq_sysctl_table = mq_register_sysctl_table();\r\nerror = register_filesystem(&mqueue_fs_type);\r\nif (error)\r\ngoto out_sysctl;\r\nspin_lock_init(&mq_lock);\r\nerror = mq_init_ns(&init_ipc_ns);\r\nif (error)\r\ngoto out_filesystem;\r\nreturn 0;\r\nout_filesystem:\r\nunregister_filesystem(&mqueue_fs_type);\r\nout_sysctl:\r\nif (mq_sysctl_table)\r\nunregister_sysctl_table(mq_sysctl_table);\r\nkmem_cache_destroy(mqueue_inode_cachep);\r\nreturn error;\r\n}
