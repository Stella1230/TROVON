static u32\r\nread_vco(struct drm_device *dev, u32 dsrc)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ssrc = nv_rd32(device, dsrc);\r\nif (!(ssrc & 0x00000100))\r\nreturn read_pll(dev, 0x00e800);\r\nreturn read_pll(dev, 0x00e820);\r\n}\r\nstatic u32\r\nread_pll(struct drm_device *dev, u32 pll)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ctrl = nv_rd32(device, pll + 0);\r\nu32 coef = nv_rd32(device, pll + 4);\r\nu32 P = (coef & 0x003f0000) >> 16;\r\nu32 N = (coef & 0x0000ff00) >> 8;\r\nu32 M = (coef & 0x000000ff) >> 0;\r\nu32 sclk, doff;\r\nif (!(ctrl & 0x00000001))\r\nreturn 0;\r\nswitch (pll & 0xfff000) {\r\ncase 0x00e000:\r\nsclk = 27000;\r\nP = 1;\r\nbreak;\r\ncase 0x137000:\r\ndoff = (pll - 0x137000) / 0x20;\r\nsclk = read_div(dev, doff, 0x137120, 0x137140);\r\nbreak;\r\ncase 0x132000:\r\nswitch (pll) {\r\ncase 0x132000:\r\nsclk = read_pll(dev, 0x132020);\r\nbreak;\r\ncase 0x132020:\r\nsclk = read_div(dev, 0, 0x137320, 0x137330);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn sclk * N / M / P;\r\n}\r\nstatic u32\r\nread_div(struct drm_device *dev, int doff, u32 dsrc, u32 dctl)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ssrc = nv_rd32(device, dsrc + (doff * 4));\r\nu32 sctl = nv_rd32(device, dctl + (doff * 4));\r\nswitch (ssrc & 0x00000003) {\r\ncase 0:\r\nif ((ssrc & 0x00030000) != 0x00030000)\r\nreturn 27000;\r\nreturn 108000;\r\ncase 2:\r\nreturn 100000;\r\ncase 3:\r\nif (sctl & 0x80000000) {\r\nu32 sclk = read_vco(dev, dsrc + (doff * 4));\r\nu32 sdiv = (sctl & 0x0000003f) + 2;\r\nreturn (sclk * 2) / sdiv;\r\n}\r\nreturn read_vco(dev, dsrc + (doff * 4));\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u32\r\nread_mem(struct drm_device *dev)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 ssel = nv_rd32(device, 0x1373f0);\r\nif (ssel & 0x00000001)\r\nreturn read_div(dev, 0, 0x137300, 0x137310);\r\nreturn read_pll(dev, 0x132000);\r\n}\r\nstatic u32\r\nread_clk(struct drm_device *dev, int clk)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nu32 sctl = nv_rd32(device, 0x137250 + (clk * 4));\r\nu32 ssel = nv_rd32(device, 0x137100);\r\nu32 sclk, sdiv;\r\nif (ssel & (1 << clk)) {\r\nif (clk < 7)\r\nsclk = read_pll(dev, 0x137000 + (clk * 0x20));\r\nelse\r\nsclk = read_pll(dev, 0x1370e0);\r\nsdiv = ((sctl & 0x00003f00) >> 8) + 2;\r\n} else {\r\nsclk = read_div(dev, clk, 0x137160, 0x1371d0);\r\nsdiv = ((sctl & 0x0000003f) >> 0) + 2;\r\n}\r\nif (sctl & 0x80000000)\r\nreturn (sclk * 2) / sdiv;\r\nreturn sclk;\r\n}\r\nint\r\nnvc0_pm_clocks_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nperflvl->shader = read_clk(dev, 0x00);\r\nperflvl->core = perflvl->shader / 2;\r\nperflvl->memory = read_mem(dev);\r\nperflvl->rop = read_clk(dev, 0x01);\r\nperflvl->hub07 = read_clk(dev, 0x02);\r\nperflvl->hub06 = read_clk(dev, 0x07);\r\nperflvl->hub01 = read_clk(dev, 0x08);\r\nperflvl->copy = read_clk(dev, 0x09);\r\nperflvl->daemon = read_clk(dev, 0x0c);\r\nperflvl->vdec = read_clk(dev, 0x0e);\r\nreturn 0;\r\n}\r\nstatic u32\r\ncalc_div(struct drm_device *dev, int clk, u32 ref, u32 freq, u32 *ddiv)\r\n{\r\nu32 div = min((ref * 2) / freq, (u32)65);\r\nif (div < 2)\r\ndiv = 2;\r\n*ddiv = div - 2;\r\nreturn (ref * 2) / div;\r\n}\r\nstatic u32\r\ncalc_src(struct drm_device *dev, int clk, u32 freq, u32 *dsrc, u32 *ddiv)\r\n{\r\nu32 sclk;\r\n*ddiv = 0x00000000;\r\nswitch (freq) {\r\ncase 27000:\r\ncase 108000:\r\n*dsrc = 0x00000000;\r\nif (freq == 108000)\r\n*dsrc |= 0x00030000;\r\nreturn freq;\r\ncase 100000:\r\n*dsrc = 0x00000002;\r\nreturn freq;\r\ndefault:\r\n*dsrc = 0x00000003;\r\nbreak;\r\n}\r\nsclk = read_vco(dev, clk);\r\nif (clk < 7)\r\nsclk = calc_div(dev, clk, sclk, freq, ddiv);\r\nreturn sclk;\r\n}\r\nstatic u32\r\ncalc_pll(struct drm_device *dev, int clk, u32 freq, u32 *coef)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nstruct nvbios_pll limits;\r\nint N, M, P, ret;\r\nret = nvbios_pll_parse(bios, 0x137000 + (clk * 0x20), &limits);\r\nif (ret)\r\nreturn 0;\r\nlimits.refclk = read_div(dev, clk, 0x137120, 0x137140);\r\nif (!limits.refclk)\r\nreturn 0;\r\nret = nva3_calc_pll(dev, &limits, freq, &N, NULL, &M, &P);\r\nif (ret <= 0)\r\nreturn 0;\r\n*coef = (P << 16) | (N << 8) | M;\r\nreturn ret;\r\n}\r\nstatic int\r\ncalc_clk(struct drm_device *dev, int clk, struct nvc0_pm_clock *info, u32 freq)\r\n{\r\nu32 src0, div0, div1D, div1P = 0;\r\nu32 clk0, clk1 = 0;\r\nif (!freq)\r\nreturn 0;\r\nclk0 = calc_src(dev, clk, freq, &src0, &div0);\r\nclk0 = calc_div(dev, clk, clk0, freq, &div1D);\r\nif (clk0 != freq && (0x00004387 & (1 << clk))) {\r\nif (clk < 7)\r\nclk1 = calc_pll(dev, clk, freq, &info->coef);\r\nelse\r\nclk1 = read_pll(dev, 0x1370e0);\r\nclk1 = calc_div(dev, clk, clk1, freq, &div1P);\r\n}\r\nif (abs((int)freq - clk0) <= abs((int)freq - clk1)) {\r\ninfo->dsrc = src0;\r\nif (div0) {\r\ninfo->ddiv |= 0x80000000;\r\ninfo->ddiv |= div0 << 8;\r\ninfo->ddiv |= div0;\r\n}\r\nif (div1D) {\r\ninfo->mdiv |= 0x80000000;\r\ninfo->mdiv |= div1D;\r\n}\r\ninfo->ssel = 0;\r\ninfo->freq = clk0;\r\n} else {\r\nif (div1P) {\r\ninfo->mdiv |= 0x80000000;\r\ninfo->mdiv |= div1P << 8;\r\n}\r\ninfo->ssel = (1 << clk);\r\ninfo->freq = clk1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncalc_mem(struct drm_device *dev, struct nvc0_pm_clock *info, u32 freq)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nstruct nvbios_pll pll;\r\nint N, M, P, ret;\r\nu32 ctrl;\r\nctrl = nv_rd32(device, 0x132020);\r\nif (!(ctrl & 0x00000001)) {\r\nnv_wr32(device, 0x137320, 0x00000103);\r\nnv_wr32(device, 0x137330, 0x81200606);\r\nnv_wait(device, 0x132020, 0x00010000, 0x00010000);\r\nnv_wr32(device, 0x132024, 0x0001150f);\r\nnv_mask(device, 0x132020, 0x00000001, 0x00000001);\r\nnv_wait(device, 0x137390, 0x00020000, 0x00020000);\r\nnv_mask(device, 0x132020, 0x00000004, 0x00000004);\r\n}\r\nret = nvbios_pll_parse(bios, 0x132000, &pll);\r\nif (ret == 0) {\r\npll.refclk = read_pll(dev, 0x132020);\r\nif (pll.refclk) {\r\nret = nva3_calc_pll(dev, &pll, freq, &N, NULL, &M, &P);\r\nif (ret > 0) {\r\ninfo->coef = (P << 16) | (N << 8) | M;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid *\r\nnvc0_pm_clocks_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nvc0_pm_state *info;\r\nint ret;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (device->chipset == 0xd9)\r\nperflvl->rop = 0;\r\nif ((ret = calc_clk(dev, 0x00, &info->eng[0x00], perflvl->shader)) ||\r\n(ret = calc_clk(dev, 0x01, &info->eng[0x01], perflvl->rop)) ||\r\n(ret = calc_clk(dev, 0x02, &info->eng[0x02], perflvl->hub07)) ||\r\n(ret = calc_clk(dev, 0x07, &info->eng[0x07], perflvl->hub06)) ||\r\n(ret = calc_clk(dev, 0x08, &info->eng[0x08], perflvl->hub01)) ||\r\n(ret = calc_clk(dev, 0x09, &info->eng[0x09], perflvl->copy)) ||\r\n(ret = calc_clk(dev, 0x0c, &info->eng[0x0c], perflvl->daemon)) ||\r\n(ret = calc_clk(dev, 0x0e, &info->eng[0x0e], perflvl->vdec))) {\r\nkfree(info);\r\nreturn ERR_PTR(ret);\r\n}\r\nif (perflvl->memory) {\r\nret = calc_mem(dev, &info->mem, perflvl->memory);\r\nif (ret) {\r\nkfree(info);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\ninfo->perflvl = perflvl;\r\nreturn info;\r\n}\r\nstatic void\r\nprog_clk(struct drm_device *dev, int clk, struct nvc0_pm_clock *info)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nif (clk < 7 && !info->ssel) {\r\nnv_mask(device, 0x1371d0 + (clk * 0x04), 0x80003f3f, info->ddiv);\r\nnv_wr32(device, 0x137160 + (clk * 0x04), info->dsrc);\r\n}\r\nnv_mask(device, 0x137100, (1 << clk), 0x00000000);\r\nnv_wait(device, 0x137100, (1 << clk), 0x00000000);\r\nif (clk < 7) {\r\nu32 base = 0x137000 + (clk * 0x20);\r\nu32 ctrl = nv_rd32(device, base + 0x00);\r\nif (ctrl & 0x00000001) {\r\nnv_mask(device, base + 0x00, 0x00000004, 0x00000000);\r\nnv_mask(device, base + 0x00, 0x00000001, 0x00000000);\r\n}\r\nif (info->ssel) {\r\nnv_wr32(device, base + 0x04, info->coef);\r\nnv_mask(device, base + 0x00, 0x00000001, 0x00000001);\r\nnv_wait(device, base + 0x00, 0x00020000, 0x00020000);\r\nnv_mask(device, base + 0x00, 0x00020004, 0x00000004);\r\n}\r\n}\r\nnv_mask(device, 0x137100, (1 << clk), info->ssel);\r\nnv_wait(device, 0x137100, (1 << clk), info->ssel);\r\nnv_mask(device, 0x137250 + (clk * 0x04), 0x00003f3f, info->mdiv);\r\n}\r\nstatic void\r\nmclk_precharge(struct nouveau_mem_exec_func *exec)\r\n{\r\n}\r\nstatic void\r\nmclk_refresh(struct nouveau_mem_exec_func *exec)\r\n{\r\n}\r\nstatic void\r\nmclk_refresh_auto(struct nouveau_mem_exec_func *exec, bool enable)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nnv_wr32(device, 0x10f210, enable ? 0x80000000 : 0x00000000);\r\n}\r\nstatic void\r\nmclk_refresh_self(struct nouveau_mem_exec_func *exec, bool enable)\r\n{\r\n}\r\nstatic void\r\nmclk_wait(struct nouveau_mem_exec_func *exec, u32 nsec)\r\n{\r\nudelay((nsec + 500) / 1000);\r\n}\r\nstatic u32\r\nmclk_mrg(struct nouveau_mem_exec_func *exec, int mr)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nif (pfb->ram.type != NV_MEM_TYPE_GDDR5) {\r\nif (mr <= 1)\r\nreturn nv_rd32(device, 0x10f300 + ((mr - 0) * 4));\r\nreturn nv_rd32(device, 0x10f320 + ((mr - 2) * 4));\r\n} else {\r\nif (mr == 0)\r\nreturn nv_rd32(device, 0x10f300 + (mr * 4));\r\nelse\r\nif (mr <= 7)\r\nreturn nv_rd32(device, 0x10f32c + (mr * 4));\r\nreturn nv_rd32(device, 0x10f34c);\r\n}\r\n}\r\nstatic void\r\nmclk_mrs(struct nouveau_mem_exec_func *exec, int mr, u32 data)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nif (pfb->ram.type != NV_MEM_TYPE_GDDR5) {\r\nif (mr <= 1) {\r\nnv_wr32(device, 0x10f300 + ((mr - 0) * 4), data);\r\nif (pfb->ram.ranks > 1)\r\nnv_wr32(device, 0x10f308 + ((mr - 0) * 4), data);\r\n} else\r\nif (mr <= 3) {\r\nnv_wr32(device, 0x10f320 + ((mr - 2) * 4), data);\r\nif (pfb->ram.ranks > 1)\r\nnv_wr32(device, 0x10f328 + ((mr - 2) * 4), data);\r\n}\r\n} else {\r\nif (mr == 0) nv_wr32(device, 0x10f300 + (mr * 4), data);\r\nelse if (mr <= 7) nv_wr32(device, 0x10f32c + (mr * 4), data);\r\nelse if (mr == 15) nv_wr32(device, 0x10f34c, data);\r\n}\r\n}\r\nstatic void\r\nmclk_clock_set(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nvc0_pm_state *info = exec->priv;\r\nu32 ctrl = nv_rd32(device, 0x132000);\r\nnv_wr32(device, 0x137360, 0x00000001);\r\nnv_wr32(device, 0x137370, 0x00000000);\r\nnv_wr32(device, 0x137380, 0x00000000);\r\nif (ctrl & 0x00000001)\r\nnv_wr32(device, 0x132000, (ctrl &= ~0x00000001));\r\nnv_wr32(device, 0x132004, info->mem.coef);\r\nnv_wr32(device, 0x132000, (ctrl |= 0x00000001));\r\nnv_wait(device, 0x137390, 0x00000002, 0x00000002);\r\nnv_wr32(device, 0x132018, 0x00005000);\r\nnv_wr32(device, 0x137370, 0x00000001);\r\nnv_wr32(device, 0x137380, 0x00000001);\r\nnv_wr32(device, 0x137360, 0x00000000);\r\n}\r\nstatic void\r\nmclk_timing_set(struct nouveau_mem_exec_func *exec)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nvc0_pm_state *info = exec->priv;\r\nstruct nouveau_pm_level *perflvl = info->perflvl;\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\nnv_wr32(device, 0x10f290 + (i * 4), perflvl->timing.reg[i]);\r\n}\r\nstatic void\r\nprog_mem(struct drm_device *dev, struct nvc0_pm_state *info)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_mem_exec_func exec = {\r\n.dev = dev,\r\n.precharge = mclk_precharge,\r\n.refresh = mclk_refresh,\r\n.refresh_auto = mclk_refresh_auto,\r\n.refresh_self = mclk_refresh_self,\r\n.wait = mclk_wait,\r\n.mrg = mclk_mrg,\r\n.mrs = mclk_mrs,\r\n.clock_set = mclk_clock_set,\r\n.timing_set = mclk_timing_set,\r\n.priv = info\r\n};\r\nif (device->chipset < 0xd0)\r\nnv_wr32(device, 0x611200, 0x00003300);\r\nelse\r\nnv_wr32(device, 0x62c000, 0x03030000);\r\nnouveau_mem_exec(&exec, info->perflvl);\r\nif (device->chipset < 0xd0)\r\nnv_wr32(device, 0x611200, 0x00003330);\r\nelse\r\nnv_wr32(device, 0x62c000, 0x03030300);\r\n}\r\nint\r\nnvc0_pm_clocks_set(struct drm_device *dev, void *data)\r\n{\r\nstruct nvc0_pm_state *info = data;\r\nint i;\r\nif (info->mem.coef)\r\nprog_mem(dev, info);\r\nfor (i = 0; i < 16; i++) {\r\nif (!info->eng[i].freq)\r\ncontinue;\r\nprog_clk(dev, i, &info->eng[i]);\r\n}\r\nkfree(info);\r\nreturn 0;\r\n}
