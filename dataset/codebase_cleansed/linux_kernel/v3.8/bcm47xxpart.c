static void bcm47xxpart_add_part(struct mtd_partition *part, char *name,\r\nu64 offset, uint32_t mask_flags)\r\n{\r\npart->name = name;\r\npart->offset = offset;\r\npart->mask_flags = mask_flags;\r\n}\r\nstatic int bcm47xxpart_parse(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_partition *parts;\r\nuint8_t i, curr_part = 0;\r\nuint32_t *buf;\r\nsize_t bytes_read;\r\nuint32_t offset;\r\nuint32_t blocksize = 0x10000;\r\nstruct trx_header *trx;\r\nparts = kzalloc(sizeof(struct mtd_partition) * BCM47XXPART_MAX_PARTS,\r\nGFP_KERNEL);\r\nbuf = kzalloc(BCM47XXPART_BYTES_TO_READ, GFP_KERNEL);\r\nfor (offset = 0; offset <= master->size - blocksize;\r\noffset += blocksize) {\r\nif (offset >= 0x2000000)\r\nbreak;\r\nif (curr_part > BCM47XXPART_MAX_PARTS) {\r\npr_warn("Reached maximum number of partitions, scanning stopped!\n");\r\nbreak;\r\n}\r\nif (mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,\r\n&bytes_read, (uint8_t *)buf) < 0) {\r\npr_err("mtd_read error while parsing (offset: 0x%X)!\n",\r\noffset);\r\ncontinue;\r\n}\r\nif (buf[0x400 / 4] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "boot",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == NVRAM_HEADER) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "nvram",\r\noffset, 0);\r\ncontinue;\r\n}\r\nif (buf[0x100 / 4] == BOARD_DATA_MAGIC) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "board_data",\r\noffset, MTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == POT_MAGIC1 &&\r\n(buf[0x004 / 4] & 0xFFFF) == POT_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "POT", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x010 / 4] == ML_MAGIC1 &&\r\nbuf[0x014 / 4] == ML_MAGIC2) {\r\nbcm47xxpart_add_part(&parts[curr_part++], "ML", offset,\r\nMTD_WRITEABLE);\r\ncontinue;\r\n}\r\nif (buf[0x000 / 4] == TRX_MAGIC) {\r\ntrx = (struct trx_header *)buf;\r\ni = 0;\r\nif (trx->offset[2]) {\r\nbcm47xxpart_add_part(&parts[curr_part++],\r\n"loader",\r\noffset + trx->offset[i],\r\n0);\r\ni++;\r\n}\r\nbcm47xxpart_add_part(&parts[curr_part++], "linux",\r\noffset + trx->offset[i], 0);\r\ni++;\r\nbcm47xxpart_add_part(&parts[curr_part++], "rootfs",\r\noffset + trx->offset[i], 0);\r\ni++;\r\noffset = rounddown(offset + trx->length, blocksize);\r\ncontinue;\r\n}\r\n}\r\nkfree(buf);\r\nfor (i = 0; i < curr_part - 1; i++)\r\nparts[i].size = parts[i + 1].offset - parts[i].offset;\r\nif (curr_part > 0)\r\nparts[curr_part - 1].size =\r\nmaster->size - parts[curr_part - 1].offset;\r\n*pparts = parts;\r\nreturn curr_part;\r\n}\r\nstatic int __init bcm47xxpart_init(void)\r\n{\r\nreturn register_mtd_parser(&bcm47xxpart_mtd_parser);\r\n}\r\nstatic void __exit bcm47xxpart_exit(void)\r\n{\r\nderegister_mtd_parser(&bcm47xxpart_mtd_parser);\r\n}
