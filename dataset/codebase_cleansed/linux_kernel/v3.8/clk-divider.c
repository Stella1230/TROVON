static unsigned int _get_table_maxdiv(const struct clk_div_table *table)\r\n{\r\nunsigned int maxdiv = 0;\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->div > maxdiv)\r\nmaxdiv = clkt->div;\r\nreturn maxdiv;\r\n}\r\nstatic unsigned int _get_maxdiv(struct clk_divider *divider)\r\n{\r\nif (divider->flags & CLK_DIVIDER_ONE_BASED)\r\nreturn div_mask(divider);\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn 1 << div_mask(divider);\r\nif (divider->table)\r\nreturn _get_table_maxdiv(divider->table);\r\nreturn div_mask(divider) + 1;\r\n}\r\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\r\nunsigned int val)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->val == val)\r\nreturn clkt->div;\r\nreturn 0;\r\n}\r\nstatic unsigned int _get_div(struct clk_divider *divider, unsigned int val)\r\n{\r\nif (divider->flags & CLK_DIVIDER_ONE_BASED)\r\nreturn val;\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn 1 << val;\r\nif (divider->table)\r\nreturn _get_table_div(divider->table, val);\r\nreturn val + 1;\r\n}\r\nstatic unsigned int _get_table_val(const struct clk_div_table *table,\r\nunsigned int div)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->div == div)\r\nreturn clkt->val;\r\nreturn 0;\r\n}\r\nstatic unsigned int _get_val(struct clk_divider *divider, u8 div)\r\n{\r\nif (divider->flags & CLK_DIVIDER_ONE_BASED)\r\nreturn div;\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn __ffs(div);\r\nif (divider->table)\r\nreturn _get_table_val(divider->table, div);\r\nreturn div - 1;\r\n}\r\nstatic unsigned long clk_divider_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nunsigned int div, val;\r\nval = readl(divider->reg) >> divider->shift;\r\nval &= div_mask(divider);\r\ndiv = _get_div(divider, val);\r\nif (!div) {\r\nWARN(1, "%s: Invalid divisor for clock %s\n", __func__,\r\n__clk_get_name(hw->clk));\r\nreturn parent_rate;\r\n}\r\nreturn parent_rate / div;\r\n}\r\nstatic bool _is_valid_table_div(const struct clk_div_table *table,\r\nunsigned int div)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->div == div)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool _is_valid_div(struct clk_divider *divider, unsigned int div)\r\n{\r\nif (divider->flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn is_power_of_two(div);\r\nif (divider->table)\r\nreturn _is_valid_table_div(divider->table, div);\r\nreturn true;\r\n}\r\nstatic int clk_divider_bestdiv(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *best_parent_rate)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nint i, bestdiv = 0;\r\nunsigned long parent_rate, best = 0, now, maxdiv;\r\nif (!rate)\r\nrate = 1;\r\nmaxdiv = _get_maxdiv(divider);\r\nif (!(__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT)) {\r\nparent_rate = *best_parent_rate;\r\nbestdiv = DIV_ROUND_UP(parent_rate, rate);\r\nbestdiv = bestdiv == 0 ? 1 : bestdiv;\r\nbestdiv = bestdiv > maxdiv ? maxdiv : bestdiv;\r\nreturn bestdiv;\r\n}\r\nmaxdiv = min(ULONG_MAX / rate, maxdiv);\r\nfor (i = 1; i <= maxdiv; i++) {\r\nif (!_is_valid_div(divider, i))\r\ncontinue;\r\nparent_rate = __clk_round_rate(__clk_get_parent(hw->clk),\r\nMULT_ROUND_UP(rate, i));\r\nnow = parent_rate / i;\r\nif (now <= rate && now > best) {\r\nbestdiv = i;\r\nbest = now;\r\n*best_parent_rate = parent_rate;\r\n}\r\n}\r\nif (!bestdiv) {\r\nbestdiv = _get_maxdiv(divider);\r\n*best_parent_rate = __clk_round_rate(__clk_get_parent(hw->clk), 1);\r\n}\r\nreturn bestdiv;\r\n}\r\nstatic long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nint div;\r\ndiv = clk_divider_bestdiv(hw, rate, prate);\r\nreturn *prate / div;\r\n}\r\nstatic int clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nunsigned int div, value;\r\nunsigned long flags = 0;\r\nu32 val;\r\ndiv = parent_rate / rate;\r\nvalue = _get_val(divider, div);\r\nif (value > div_mask(divider))\r\nvalue = div_mask(divider);\r\nif (divider->lock)\r\nspin_lock_irqsave(divider->lock, flags);\r\nval = readl(divider->reg);\r\nval &= ~(div_mask(divider) << divider->shift);\r\nval |= value << divider->shift;\r\nwritel(val, divider->reg);\r\nif (divider->lock)\r\nspin_unlock_irqrestore(divider->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct clk *_register_divider(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nu8 clk_divider_flags, const struct clk_div_table *table,\r\nspinlock_t *lock)\r\n{\r\nstruct clk_divider *div;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\ndiv = kzalloc(sizeof(struct clk_divider), GFP_KERNEL);\r\nif (!div) {\r\npr_err("%s: could not allocate divider clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &clk_divider_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = (parent_name ? &parent_name: NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\ndiv->reg = reg;\r\ndiv->shift = shift;\r\ndiv->width = width;\r\ndiv->flags = clk_divider_flags;\r\ndiv->lock = lock;\r\ndiv->hw.init = &init;\r\ndiv->table = table;\r\nclk = clk_register(dev, &div->hw);\r\nif (IS_ERR(clk))\r\nkfree(div);\r\nreturn clk;\r\n}\r\nstruct clk *clk_register_divider(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nu8 clk_divider_flags, spinlock_t *lock)\r\n{\r\nreturn _register_divider(dev, name, parent_name, flags, reg, shift,\r\nwidth, clk_divider_flags, NULL, lock);\r\n}\r\nstruct clk *clk_register_divider_table(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nu8 clk_divider_flags, const struct clk_div_table *table,\r\nspinlock_t *lock)\r\n{\r\nreturn _register_divider(dev, name, parent_name, flags, reg, shift,\r\nwidth, clk_divider_flags, table, lock);\r\n}
