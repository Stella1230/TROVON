static void timing_setup(struct ata_port *ap, struct ata_device *adev, int offset, int speed, int clock)\r\n{\r\nstatic const unsigned char amd_cyc2udma[] = {\r\n6, 6, 5, 4, 0, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 7\r\n};\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct ata_device *peer = ata_dev_pair(adev);\r\nint dn = ap->port_no * 2 + adev->devno;\r\nstruct ata_timing at, apeer;\r\nint T, UT;\r\nconst int amd_clock = 33333;\r\nu8 t;\r\nT = 1000000000 / amd_clock;\r\nUT = T;\r\nif (clock >= 2)\r\nUT = T / 2;\r\nif (ata_timing_compute(adev, speed, &at, T, UT) < 0) {\r\ndev_err(&pdev->dev, "unknown mode %d\n", speed);\r\nreturn;\r\n}\r\nif (peer) {\r\nif (peer->dma_mode) {\r\nata_timing_compute(peer, peer->dma_mode, &apeer, T, UT);\r\nata_timing_merge(&apeer, &at, &at, ATA_TIMING_8BIT);\r\n}\r\nata_timing_compute(peer, peer->pio_mode, &apeer, T, UT);\r\nata_timing_merge(&apeer, &at, &at, ATA_TIMING_8BIT);\r\n}\r\nif (speed == XFER_UDMA_5 && amd_clock <= 33333) at.udma = 1;\r\nif (speed == XFER_UDMA_6 && amd_clock <= 33333) at.udma = 15;\r\npci_read_config_byte(pdev, offset + 0x0C, &t);\r\nt = (t & ~(3 << ((3 - dn) << 1))) | ((clamp_val(at.setup, 1, 4) - 1) << ((3 - dn) << 1));\r\npci_write_config_byte(pdev, offset + 0x0C , t);\r\npci_write_config_byte(pdev, offset + 0x0E + (1 - (dn >> 1)),\r\n((clamp_val(at.act8b, 1, 16) - 1) << 4) | (clamp_val(at.rec8b, 1, 16) - 1));\r\npci_write_config_byte(pdev, offset + 0x08 + (3 - dn),\r\n((clamp_val(at.active, 1, 16) - 1) << 4) | (clamp_val(at.recover, 1, 16) - 1));\r\nswitch (clock) {\r\ncase 1:\r\nt = at.udma ? (0xc0 | (clamp_val(at.udma, 2, 5) - 2)) : 0x03;\r\nbreak;\r\ncase 2:\r\nt = at.udma ? (0xc0 | amd_cyc2udma[clamp_val(at.udma, 2, 10)]) : 0x03;\r\nbreak;\r\ncase 3:\r\nt = at.udma ? (0xc0 | amd_cyc2udma[clamp_val(at.udma, 1, 10)]) : 0x03;\r\nbreak;\r\ncase 4:\r\nt = at.udma ? (0xc0 | amd_cyc2udma[clamp_val(at.udma, 1, 15)]) : 0x03;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (at.udma)\r\npci_write_config_byte(pdev, offset + 0x10 + (3 - dn), t);\r\n}\r\nstatic int amd_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstatic const struct pci_bits amd_enable_bits[] = {\r\n{ 0x40, 1, 0x02, 0x02 },\r\n{ 0x40, 1, 0x01, 0x01 }\r\n};\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (!pci_test_config_bits(pdev, &amd_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic int amd_cable_detect(struct ata_port *ap)\r\n{\r\nstatic const u32 bitmask[2] = {0x03, 0x0C};\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 ata66;\r\npci_read_config_byte(pdev, 0x42, &ata66);\r\nif (ata66 & bitmask[ap->port_no])\r\nreturn ATA_CBL_PATA80;\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic void amd_fifo_setup(struct ata_port *ap)\r\n{\r\nstruct ata_device *adev;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic const u8 fifobit[2] = { 0xC0, 0x30};\r\nu8 fifo = fifobit[ap->port_no];\r\nu8 r;\r\nata_for_each_dev(adev, &ap->link, ENABLED) {\r\nif (adev->class == ATA_DEV_ATAPI)\r\nfifo = 0;\r\n}\r\nif (pdev->device == PCI_DEVICE_ID_AMD_VIPER_7411)\r\nfifo = 0;\r\npci_read_config_byte(pdev, 0x41, &r);\r\nr &= ~fifobit[ap->port_no];\r\nr |= fifo;\r\npci_write_config_byte(pdev, 0x41, r);\r\n}\r\nstatic void amd33_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\namd_fifo_setup(ap);\r\ntiming_setup(ap, adev, 0x40, adev->pio_mode, 1);\r\n}\r\nstatic void amd66_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\namd_fifo_setup(ap);\r\ntiming_setup(ap, adev, 0x40, adev->pio_mode, 2);\r\n}\r\nstatic void amd100_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\namd_fifo_setup(ap);\r\ntiming_setup(ap, adev, 0x40, adev->pio_mode, 3);\r\n}\r\nstatic void amd133_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\namd_fifo_setup(ap);\r\ntiming_setup(ap, adev, 0x40, adev->pio_mode, 4);\r\n}\r\nstatic void amd33_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x40, adev->dma_mode, 1);\r\n}\r\nstatic void amd66_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x40, adev->dma_mode, 2);\r\n}\r\nstatic void amd100_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x40, adev->dma_mode, 3);\r\n}\r\nstatic void amd133_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x40, adev->dma_mode, 4);\r\n}\r\nstatic unsigned long nv_mode_filter(struct ata_device *dev,\r\nunsigned long xfer_mask)\r\n{\r\nstatic const unsigned int udma_mask_map[] =\r\n{ ATA_UDMA2, ATA_UDMA1, ATA_UDMA0, 0,\r\nATA_UDMA3, ATA_UDMA4, ATA_UDMA5, ATA_UDMA6 };\r\nstruct ata_port *ap = dev->link->ap;\r\nchar acpi_str[32] = "";\r\nu32 saved_udma, udma;\r\nconst struct ata_acpi_gtm *gtm;\r\nunsigned long bios_limit = 0, acpi_limit = 0, limit;\r\nudma = saved_udma = (unsigned long)ap->host->private_data;\r\nif (ap->port_no == 0)\r\nudma >>= 16;\r\nif (dev->devno == 0)\r\nudma >>= 8;\r\nif ((udma & 0xc0) == 0xc0)\r\nbios_limit = ata_pack_xfermask(0, 0, udma_mask_map[udma & 0x7]);\r\ngtm = ata_acpi_init_gtm(ap);\r\nif (gtm) {\r\nacpi_limit = ata_acpi_gtm_xfermask(dev, gtm);\r\nsnprintf(acpi_str, sizeof(acpi_str), " (%u:%u:0x%x)",\r\ngtm->drive[0].dma, gtm->drive[1].dma, gtm->flags);\r\n}\r\nlimit = bios_limit | acpi_limit;\r\nif (!(limit & ATA_MASK_PIO))\r\nlimit |= ATA_MASK_PIO;\r\nif (!(limit & (ATA_MASK_MWDMA | ATA_MASK_UDMA)))\r\nlimit |= ATA_MASK_MWDMA | ATA_MASK_UDMA;\r\nlimit |= ata_pack_xfermask(ATA_PIO4, ATA_MWDMA2, ATA_UDMA2);\r\nata_port_dbg(ap, "nv_mode_filter: 0x%lx&0x%lx->0x%lx, "\r\n"BIOS=0x%lx (0x%x) ACPI=0x%lx%s\n",\r\nxfer_mask, limit, xfer_mask & limit, bios_limit,\r\nsaved_udma, acpi_limit, acpi_str);\r\nreturn xfer_mask & limit;\r\n}\r\nstatic int nv_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstatic const struct pci_bits nv_enable_bits[] = {\r\n{ 0x50, 1, 0x02, 0x02 },\r\n{ 0x50, 1, 0x01, 0x01 }\r\n};\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (!pci_test_config_bits(pdev, &nv_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void nv100_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x50, adev->pio_mode, 3);\r\n}\r\nstatic void nv133_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x50, adev->pio_mode, 4);\r\n}\r\nstatic void nv100_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x50, adev->dma_mode, 3);\r\n}\r\nstatic void nv133_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ntiming_setup(ap, adev, 0x50, adev->dma_mode, 4);\r\n}\r\nstatic void nv_host_stop(struct ata_host *host)\r\n{\r\nu32 udma = (unsigned long)host->private_data;\r\npci_write_config_dword(to_pci_dev(host->dev), 0x60, udma);\r\n}\r\nstatic void amd_clear_fifo(struct pci_dev *pdev)\r\n{\r\nu8 fifo;\r\npci_read_config_byte(pdev, 0x41, &fifo);\r\nfifo &= 0x0F;\r\npci_write_config_byte(pdev, 0x41, fifo);\r\n}\r\nstatic int amd_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info[10] = {\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &amd33_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &amd66_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &amd66_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &amd100_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &amd100_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &amd133_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &amd133_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &nv100_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &nv133_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &amd100_port_ops\r\n}\r\n};\r\nconst struct ata_port_info *ppi[] = { NULL, NULL };\r\nint type = id->driver_data;\r\nvoid *hpriv = NULL;\r\nu8 fifo;\r\nint rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\npci_read_config_byte(pdev, 0x41, &fifo);\r\nif (type == 1 && pdev->revision > 0x7)\r\ntype = 2;\r\nif (type == 5 && pdev->subsystem_vendor == PCI_VENDOR_ID_AMD &&\r\npdev->subsystem_device == PCI_DEVICE_ID_AMD_SERENADE)\r\ntype = 6;\r\nppi[0] = &info[type];\r\nif (type < 3)\r\nata_pci_bmdma_clear_simplex(pdev);\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD)\r\namd_clear_fifo(pdev);\r\nif (type == 7 || type == 8) {\r\nu32 udma;\r\npci_read_config_dword(pdev, 0x60, &udma);\r\nhpriv = (void *)(unsigned long)udma;\r\n}\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &amd_sht, hpriv, 0);\r\n}\r\nstatic int amd_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD) {\r\namd_clear_fifo(pdev);\r\nif (pdev->device == PCI_DEVICE_ID_AMD_VIPER_7409 ||\r\npdev->device == PCI_DEVICE_ID_AMD_COBRA_7401)\r\nata_pci_bmdma_clear_simplex(pdev);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}
