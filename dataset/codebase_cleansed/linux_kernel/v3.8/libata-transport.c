static void ata_tport_release(struct device *dev)\r\n{\r\nput_device(dev->parent);\r\n}\r\nstatic int ata_is_port(const struct device *dev)\r\n{\r\nreturn dev->release == ata_tport_release;\r\n}\r\nstatic int ata_tport_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nif (!ata_is_port(dev))\r\nreturn 0;\r\nreturn &ata_scsi_transport_template->host_attrs.ac == cont;\r\n}\r\nvoid ata_tport_delete(struct ata_port *ap)\r\n{\r\nstruct device *dev = &ap->tdev;\r\nata_tlink_delete(&ap->link);\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\n}\r\nint ata_tport_add(struct device *parent,\r\nstruct ata_port *ap)\r\n{\r\nint error;\r\nstruct device *dev = &ap->tdev;\r\ndevice_initialize(dev);\r\ndev->type = &ata_port_type;\r\ndev->parent = get_device(parent);\r\ndev->release = ata_tport_release;\r\ndev_set_name(dev, "ata%d", ap->print_id);\r\ntransport_setup_device(dev);\r\nerror = device_add(dev);\r\nif (error) {\r\ngoto tport_err;\r\n}\r\ndevice_enable_async_suspend(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_forbid(dev);\r\ntransport_add_device(dev);\r\ntransport_configure_device(dev);\r\nerror = ata_tlink_add(&ap->link);\r\nif (error) {\r\ngoto tport_link_err;\r\n}\r\nreturn 0;\r\ntport_link_err:\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntport_err:\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\nreturn error;\r\n}\r\nstatic void ata_tlink_release(struct device *dev)\r\n{\r\nput_device(dev->parent);\r\n}\r\nstatic int ata_is_link(const struct device *dev)\r\n{\r\nreturn dev->release == ata_tlink_release;\r\n}\r\nstatic int ata_tlink_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct ata_internal* i = to_ata_internal(ata_scsi_transport_template);\r\nif (!ata_is_link(dev))\r\nreturn 0;\r\nreturn &i->link_attr_cont.ac == cont;\r\n}\r\nvoid ata_tlink_delete(struct ata_link *link)\r\n{\r\nstruct device *dev = &link->tdev;\r\nstruct ata_device *ata_dev;\r\nata_for_each_dev(ata_dev, link, ALL) {\r\nata_tdev_delete(ata_dev);\r\n}\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\n}\r\nint ata_tlink_add(struct ata_link *link)\r\n{\r\nstruct device *dev = &link->tdev;\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *ata_dev;\r\nint error;\r\ndevice_initialize(dev);\r\ndev->parent = get_device(&ap->tdev);\r\ndev->release = ata_tlink_release;\r\nif (ata_is_host_link(link))\r\ndev_set_name(dev, "link%d", ap->print_id);\r\nelse\r\ndev_set_name(dev, "link%d.%d", ap->print_id, link->pmp);\r\ntransport_setup_device(dev);\r\nerror = device_add(dev);\r\nif (error) {\r\ngoto tlink_err;\r\n}\r\ntransport_add_device(dev);\r\ntransport_configure_device(dev);\r\nata_for_each_dev(ata_dev, link, ALL) {\r\nerror = ata_tdev_add(ata_dev);\r\nif (error) {\r\ngoto tlink_dev_err;\r\n}\r\n}\r\nreturn 0;\r\ntlink_dev_err:\r\nwhile (--ata_dev >= link->device) {\r\nata_tdev_delete(ata_dev);\r\n}\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntlink_err:\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\nreturn error;\r\n}\r\nstatic int ata_show_ering(struct ata_ering_entry *ent, void *void_arg)\r\n{\r\nstruct ata_show_ering_arg* arg = void_arg;\r\nstruct timespec time;\r\njiffies_to_timespec(ent->timestamp,&time);\r\narg->written += sprintf(arg->buf + arg->written,\r\n"[%5lu.%06lu]",\r\ntime.tv_sec, time.tv_nsec);\r\narg->written += get_ata_err_names(ent->err_mask,\r\narg->buf + arg->written);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nshow_ata_dev_ering(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ata_device *ata_dev = transport_class_to_dev(dev);\r\nstruct ata_show_ering_arg arg = { buf, 0 };\r\nata_ering_map(&ata_dev->ering, ata_show_ering, &arg);\r\nreturn arg.written;\r\n}\r\nstatic ssize_t\r\nshow_ata_dev_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ata_device *ata_dev = transport_class_to_dev(dev);\r\nint written = 0, i = 0;\r\nif (ata_dev->class == ATA_DEV_PMP)\r\nreturn 0;\r\nfor(i=0;i<ATA_ID_WORDS;i++) {\r\nwritten += snprintf(buf+written, 20, "%04x%c",\r\nata_dev->id[i],\r\n((i+1) & 7) ? ' ' : '\n');\r\n}\r\nreturn written;\r\n}\r\nstatic ssize_t\r\nshow_ata_dev_gscr(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ata_device *ata_dev = transport_class_to_dev(dev);\r\nint written = 0, i = 0;\r\nif (ata_dev->class != ATA_DEV_PMP)\r\nreturn 0;\r\nfor(i=0;i<SATA_PMP_GSCR_DWORDS;i++) {\r\nwritten += snprintf(buf+written, 20, "%08x%c",\r\nata_dev->gscr[i],\r\n((i+1) & 3) ? ' ' : '\n');\r\n}\r\nif (SATA_PMP_GSCR_DWORDS & 3)\r\nbuf[written-1] = '\n';\r\nreturn written;\r\n}\r\nstatic void ata_tdev_release(struct device *dev)\r\n{\r\nput_device(dev->parent);\r\n}\r\nstatic int ata_is_ata_dev(const struct device *dev)\r\n{\r\nreturn dev->release == ata_tdev_release;\r\n}\r\nstatic int ata_tdev_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct ata_internal* i = to_ata_internal(ata_scsi_transport_template);\r\nif (!ata_is_ata_dev(dev))\r\nreturn 0;\r\nreturn &i->dev_attr_cont.ac == cont;\r\n}\r\nstatic void ata_tdev_free(struct ata_device *dev)\r\n{\r\ntransport_destroy_device(&dev->tdev);\r\nput_device(&dev->tdev);\r\n}\r\nstatic void ata_tdev_delete(struct ata_device *ata_dev)\r\n{\r\nstruct device *dev = &ata_dev->tdev;\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\nata_tdev_free(ata_dev);\r\n}\r\nstatic int ata_tdev_add(struct ata_device *ata_dev)\r\n{\r\nstruct device *dev = &ata_dev->tdev;\r\nstruct ata_link *link = ata_dev->link;\r\nstruct ata_port *ap = link->ap;\r\nint error;\r\ndevice_initialize(dev);\r\ndev->parent = get_device(&link->tdev);\r\ndev->release = ata_tdev_release;\r\nif (ata_is_host_link(link))\r\ndev_set_name(dev, "dev%d.%d", ap->print_id,ata_dev->devno);\r\nelse\r\ndev_set_name(dev, "dev%d.%d.0", ap->print_id, link->pmp);\r\ntransport_setup_device(dev);\r\nerror = device_add(dev);\r\nif (error) {\r\nata_tdev_free(ata_dev);\r\nreturn error;\r\n}\r\ntransport_add_device(dev);\r\ntransport_configure_device(dev);\r\nreturn 0;\r\n}\r\nstruct scsi_transport_template *ata_attach_transport(void)\r\n{\r\nstruct ata_internal *i;\r\nint count;\r\ni = kzalloc(sizeof(struct ata_internal), GFP_KERNEL);\r\nif (!i)\r\nreturn NULL;\r\ni->t.eh_strategy_handler = ata_scsi_error;\r\ni->t.eh_timed_out = ata_scsi_timed_out;\r\ni->t.user_scan = ata_scsi_user_scan;\r\ni->t.host_attrs.ac.attrs = &i->port_attrs[0];\r\ni->t.host_attrs.ac.class = &ata_port_class.class;\r\ni->t.host_attrs.ac.match = ata_tport_match;\r\ntransport_container_register(&i->t.host_attrs);\r\ni->link_attr_cont.ac.class = &ata_link_class.class;\r\ni->link_attr_cont.ac.attrs = &i->link_attrs[0];\r\ni->link_attr_cont.ac.match = ata_tlink_match;\r\ntransport_container_register(&i->link_attr_cont);\r\ni->dev_attr_cont.ac.class = &ata_dev_class.class;\r\ni->dev_attr_cont.ac.attrs = &i->dev_attrs[0];\r\ni->dev_attr_cont.ac.match = ata_tdev_match;\r\ntransport_container_register(&i->dev_attr_cont);\r\ncount = 0;\r\nSETUP_PORT_ATTRIBUTE(nr_pmp_links);\r\nSETUP_PORT_ATTRIBUTE(idle_irq);\r\nBUG_ON(count > ATA_PORT_ATTRS);\r\ni->port_attrs[count] = NULL;\r\ncount = 0;\r\nSETUP_LINK_ATTRIBUTE(hw_sata_spd_limit);\r\nSETUP_LINK_ATTRIBUTE(sata_spd_limit);\r\nSETUP_LINK_ATTRIBUTE(sata_spd);\r\nBUG_ON(count > ATA_LINK_ATTRS);\r\ni->link_attrs[count] = NULL;\r\ncount = 0;\r\nSETUP_DEV_ATTRIBUTE(class);\r\nSETUP_DEV_ATTRIBUTE(pio_mode);\r\nSETUP_DEV_ATTRIBUTE(dma_mode);\r\nSETUP_DEV_ATTRIBUTE(xfer_mode);\r\nSETUP_DEV_ATTRIBUTE(spdn_cnt);\r\nSETUP_DEV_ATTRIBUTE(ering);\r\nSETUP_DEV_ATTRIBUTE(id);\r\nSETUP_DEV_ATTRIBUTE(gscr);\r\nBUG_ON(count > ATA_DEV_ATTRS);\r\ni->dev_attrs[count] = NULL;\r\nreturn &i->t;\r\n}\r\nvoid ata_release_transport(struct scsi_transport_template *t)\r\n{\r\nstruct ata_internal *i = to_ata_internal(t);\r\ntransport_container_unregister(&i->t.host_attrs);\r\ntransport_container_unregister(&i->link_attr_cont);\r\ntransport_container_unregister(&i->dev_attr_cont);\r\nkfree(i);\r\n}\r\n__init int libata_transport_init(void)\r\n{\r\nint error;\r\nerror = transport_class_register(&ata_link_class);\r\nif (error)\r\ngoto out_unregister_transport;\r\nerror = transport_class_register(&ata_port_class);\r\nif (error)\r\ngoto out_unregister_link;\r\nerror = transport_class_register(&ata_dev_class);\r\nif (error)\r\ngoto out_unregister_port;\r\nreturn 0;\r\nout_unregister_port:\r\ntransport_class_unregister(&ata_port_class);\r\nout_unregister_link:\r\ntransport_class_unregister(&ata_link_class);\r\nout_unregister_transport:\r\nreturn error;\r\n}\r\nvoid __exit libata_transport_exit(void)\r\n{\r\ntransport_class_unregister(&ata_link_class);\r\ntransport_class_unregister(&ata_port_class);\r\ntransport_class_unregister(&ata_dev_class);\r\n}
