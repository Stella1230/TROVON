int x25_forward_call(struct x25_address *dest_addr, struct x25_neigh *from,\r\nstruct sk_buff *skb, int lci)\r\n{\r\nstruct x25_route *rt;\r\nstruct x25_neigh *neigh_new = NULL;\r\nstruct list_head *entry;\r\nstruct x25_forward *x25_frwd, *new_frwd;\r\nstruct sk_buff *skbn;\r\nshort same_lci = 0;\r\nint rc = 0;\r\nif ((rt = x25_get_route(dest_addr)) == NULL)\r\ngoto out_no_route;\r\nif ((neigh_new = x25_get_neigh(rt->dev)) == NULL) {\r\ngoto out_put_route;\r\n}\r\nif (rt->dev == from->dev) {\r\ngoto out_put_nb;\r\n}\r\nread_lock_bh(&x25_forward_list_lock);\r\nlist_for_each(entry, &x25_forward_list) {\r\nx25_frwd = list_entry(entry, struct x25_forward, node);\r\nif (x25_frwd->lci == lci) {\r\nprintk(KERN_WARNING "X.25: call request for lci which is already registered!, transmitting but not registering new pair\n");\r\nsame_lci = 1;\r\n}\r\n}\r\nread_unlock_bh(&x25_forward_list_lock);\r\nif (!same_lci){\r\nif ((new_frwd = kmalloc(sizeof(struct x25_forward),\r\nGFP_ATOMIC)) == NULL){\r\nrc = -ENOMEM;\r\ngoto out_put_nb;\r\n}\r\nnew_frwd->lci = lci;\r\nnew_frwd->dev1 = rt->dev;\r\nnew_frwd->dev2 = from->dev;\r\nwrite_lock_bh(&x25_forward_list_lock);\r\nlist_add(&new_frwd->node, &x25_forward_list);\r\nwrite_unlock_bh(&x25_forward_list_lock);\r\n}\r\nif ( (skbn = skb_clone(skb, GFP_ATOMIC)) == NULL){\r\ngoto out_put_nb;\r\n}\r\nx25_transmit_link(skbn, neigh_new);\r\nrc = 1;\r\nout_put_nb:\r\nx25_neigh_put(neigh_new);\r\nout_put_route:\r\nx25_route_put(rt);\r\nout_no_route:\r\nreturn rc;\r\n}\r\nint x25_forward_data(int lci, struct x25_neigh *from, struct sk_buff *skb) {\r\nstruct x25_forward *frwd;\r\nstruct list_head *entry;\r\nstruct net_device *peer = NULL;\r\nstruct x25_neigh *nb;\r\nstruct sk_buff *skbn;\r\nint rc = 0;\r\nread_lock_bh(&x25_forward_list_lock);\r\nlist_for_each(entry, &x25_forward_list) {\r\nfrwd = list_entry(entry, struct x25_forward, node);\r\nif (frwd->lci == lci) {\r\nif (from->dev == frwd->dev1) {\r\npeer = frwd->dev2;\r\n} else {\r\npeer = frwd->dev1;\r\n}\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&x25_forward_list_lock);\r\nif ( (nb = x25_get_neigh(peer)) == NULL)\r\ngoto out;\r\nif ( (skbn = pskb_copy(skb, GFP_ATOMIC)) == NULL){\r\ngoto output;\r\n}\r\nx25_transmit_link(skbn, nb);\r\nrc = 1;\r\noutput:\r\nx25_neigh_put(nb);\r\nout:\r\nreturn rc;\r\n}\r\nvoid x25_clear_forward_by_lci(unsigned int lci)\r\n{\r\nstruct x25_forward *fwd;\r\nstruct list_head *entry, *tmp;\r\nwrite_lock_bh(&x25_forward_list_lock);\r\nlist_for_each_safe(entry, tmp, &x25_forward_list) {\r\nfwd = list_entry(entry, struct x25_forward, node);\r\nif (fwd->lci == lci) {\r\nlist_del(&fwd->node);\r\nkfree(fwd);\r\n}\r\n}\r\nwrite_unlock_bh(&x25_forward_list_lock);\r\n}\r\nvoid x25_clear_forward_by_dev(struct net_device *dev)\r\n{\r\nstruct x25_forward *fwd;\r\nstruct list_head *entry, *tmp;\r\nwrite_lock_bh(&x25_forward_list_lock);\r\nlist_for_each_safe(entry, tmp, &x25_forward_list) {\r\nfwd = list_entry(entry, struct x25_forward, node);\r\nif ((fwd->dev1 == dev) || (fwd->dev2 == dev)){\r\nlist_del(&fwd->node);\r\nkfree(fwd);\r\n}\r\n}\r\nwrite_unlock_bh(&x25_forward_list_lock);\r\n}
