static struct mlx4_ib_sqp *to_msqp(struct mlx4_ib_qp *mqp)\r\n{\r\nreturn container_of(mqp, struct mlx4_ib_sqp, qp);\r\n}\r\nstatic int is_tunnel_qp(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\r\n{\r\nif (!mlx4_is_master(dev->dev))\r\nreturn 0;\r\nreturn qp->mqp.qpn >= dev->dev->phys_caps.base_tunnel_sqpn &&\r\nqp->mqp.qpn < dev->dev->phys_caps.base_tunnel_sqpn +\r\n8 * MLX4_MFUNC_MAX;\r\n}\r\nstatic int is_sqp(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\r\n{\r\nint proxy_sqp = 0;\r\nint real_sqp = 0;\r\nint i;\r\nreal_sqp = ((mlx4_is_master(dev->dev) || !mlx4_is_mfunc(dev->dev)) &&\r\nqp->mqp.qpn >= dev->dev->phys_caps.base_sqpn &&\r\nqp->mqp.qpn <= dev->dev->phys_caps.base_sqpn + 3);\r\nif (real_sqp)\r\nreturn 1;\r\nif (mlx4_is_mfunc(dev->dev)) {\r\nfor (i = 0; i < dev->dev->caps.num_ports; i++) {\r\nif (qp->mqp.qpn == dev->dev->caps.qp0_proxy[i] ||\r\nqp->mqp.qpn == dev->dev->caps.qp1_proxy[i]) {\r\nproxy_sqp = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn proxy_sqp;\r\n}\r\nstatic int is_qp0(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\r\n{\r\nint proxy_qp0 = 0;\r\nint real_qp0 = 0;\r\nint i;\r\nreal_qp0 = ((mlx4_is_master(dev->dev) || !mlx4_is_mfunc(dev->dev)) &&\r\nqp->mqp.qpn >= dev->dev->phys_caps.base_sqpn &&\r\nqp->mqp.qpn <= dev->dev->phys_caps.base_sqpn + 1);\r\nif (real_qp0)\r\nreturn 1;\r\nif (mlx4_is_mfunc(dev->dev)) {\r\nfor (i = 0; i < dev->dev->caps.num_ports; i++) {\r\nif (qp->mqp.qpn == dev->dev->caps.qp0_proxy[i]) {\r\nproxy_qp0 = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn proxy_qp0;\r\n}\r\nstatic void *get_wqe(struct mlx4_ib_qp *qp, int offset)\r\n{\r\nreturn mlx4_buf_offset(&qp->buf, offset);\r\n}\r\nstatic void *get_recv_wqe(struct mlx4_ib_qp *qp, int n)\r\n{\r\nreturn get_wqe(qp, qp->rq.offset + (n << qp->rq.wqe_shift));\r\n}\r\nstatic void *get_send_wqe(struct mlx4_ib_qp *qp, int n)\r\n{\r\nreturn get_wqe(qp, qp->sq.offset + (n << qp->sq.wqe_shift));\r\n}\r\nstatic void stamp_send_wqe(struct mlx4_ib_qp *qp, int n, int size)\r\n{\r\n__be32 *wqe;\r\nint i;\r\nint s;\r\nint ind;\r\nvoid *buf;\r\n__be32 stamp;\r\nstruct mlx4_wqe_ctrl_seg *ctrl;\r\nif (qp->sq_max_wqes_per_wr > 1) {\r\ns = roundup(size, 1U << qp->sq.wqe_shift);\r\nfor (i = 0; i < s; i += 64) {\r\nind = (i >> qp->sq.wqe_shift) + n;\r\nstamp = ind & qp->sq.wqe_cnt ? cpu_to_be32(0x7fffffff) :\r\ncpu_to_be32(0xffffffff);\r\nbuf = get_send_wqe(qp, ind & (qp->sq.wqe_cnt - 1));\r\nwqe = buf + (i & ((1 << qp->sq.wqe_shift) - 1));\r\n*wqe = stamp;\r\n}\r\n} else {\r\nctrl = buf = get_send_wqe(qp, n & (qp->sq.wqe_cnt - 1));\r\ns = (ctrl->fence_size & 0x3f) << 4;\r\nfor (i = 64; i < s; i += 64) {\r\nwqe = buf + i;\r\n*wqe = cpu_to_be32(0xffffffff);\r\n}\r\n}\r\n}\r\nstatic void post_nop_wqe(struct mlx4_ib_qp *qp, int n, int size)\r\n{\r\nstruct mlx4_wqe_ctrl_seg *ctrl;\r\nstruct mlx4_wqe_inline_seg *inl;\r\nvoid *wqe;\r\nint s;\r\nctrl = wqe = get_send_wqe(qp, n & (qp->sq.wqe_cnt - 1));\r\ns = sizeof(struct mlx4_wqe_ctrl_seg);\r\nif (qp->ibqp.qp_type == IB_QPT_UD) {\r\nstruct mlx4_wqe_datagram_seg *dgram = wqe + sizeof *ctrl;\r\nstruct mlx4_av *av = (struct mlx4_av *)dgram->av;\r\nmemset(dgram, 0, sizeof *dgram);\r\nav->port_pd = cpu_to_be32((qp->port << 24) | to_mpd(qp->ibqp.pd)->pdn);\r\ns += sizeof(struct mlx4_wqe_datagram_seg);\r\n}\r\nif (size > s) {\r\ninl = wqe + s;\r\ninl->byte_count = cpu_to_be32(1 << 31 | (size - s - sizeof *inl));\r\n}\r\nctrl->srcrb_flags = 0;\r\nctrl->fence_size = size / 16;\r\nwmb();\r\nctrl->owner_opcode = cpu_to_be32(MLX4_OPCODE_NOP | MLX4_WQE_CTRL_NEC) |\r\n(n & qp->sq.wqe_cnt ? cpu_to_be32(1 << 31) : 0);\r\nstamp_send_wqe(qp, n + qp->sq_spare_wqes, size);\r\n}\r\nstatic inline unsigned pad_wraparound(struct mlx4_ib_qp *qp, int ind)\r\n{\r\nunsigned s = qp->sq.wqe_cnt - (ind & (qp->sq.wqe_cnt - 1));\r\nif (unlikely(s < qp->sq_max_wqes_per_wr)) {\r\npost_nop_wqe(qp, ind, s << qp->sq.wqe_shift);\r\nind += s;\r\n}\r\nreturn ind;\r\n}\r\nstatic void mlx4_ib_qp_event(struct mlx4_qp *qp, enum mlx4_event type)\r\n{\r\nstruct ib_event event;\r\nstruct ib_qp *ibqp = &to_mibqp(qp)->ibqp;\r\nif (type == MLX4_EVENT_TYPE_PATH_MIG)\r\nto_mibqp(qp)->port = to_mibqp(qp)->alt_port;\r\nif (ibqp->event_handler) {\r\nevent.device = ibqp->device;\r\nevent.element.qp = ibqp;\r\nswitch (type) {\r\ncase MLX4_EVENT_TYPE_PATH_MIG:\r\nevent.event = IB_EVENT_PATH_MIG;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_COMM_EST:\r\nevent.event = IB_EVENT_COMM_EST;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_SQ_DRAINED:\r\nevent.event = IB_EVENT_SQ_DRAINED;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE:\r\nevent.event = IB_EVENT_QP_LAST_WQE_REACHED;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_WQ_CATAS_ERROR:\r\nevent.event = IB_EVENT_QP_FATAL;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_PATH_MIG_FAILED:\r\nevent.event = IB_EVENT_PATH_MIG_ERR;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\r\nevent.event = IB_EVENT_QP_REQ_ERR;\r\nbreak;\r\ncase MLX4_EVENT_TYPE_WQ_ACCESS_ERROR:\r\nevent.event = IB_EVENT_QP_ACCESS_ERR;\r\nbreak;\r\ndefault:\r\npr_warn("Unexpected event type %d "\r\n"on QP %06x\n", type, qp->qpn);\r\nreturn;\r\n}\r\nibqp->event_handler(&event, ibqp->qp_context);\r\n}\r\n}\r\nstatic int send_wqe_overhead(enum mlx4_ib_qp_type type, u32 flags)\r\n{\r\nswitch (type) {\r\ncase MLX4_IB_QPT_UD:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg) +\r\nsizeof (struct mlx4_wqe_datagram_seg) +\r\n((flags & MLX4_IB_QP_LSO) ? MLX4_IB_LSO_HEADER_SPARE : 0);\r\ncase MLX4_IB_QPT_PROXY_SMI_OWNER:\r\ncase MLX4_IB_QPT_PROXY_SMI:\r\ncase MLX4_IB_QPT_PROXY_GSI:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg) +\r\nsizeof (struct mlx4_wqe_datagram_seg) + 64;\r\ncase MLX4_IB_QPT_TUN_SMI_OWNER:\r\ncase MLX4_IB_QPT_TUN_GSI:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg) +\r\nsizeof (struct mlx4_wqe_datagram_seg);\r\ncase MLX4_IB_QPT_UC:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg) +\r\nsizeof (struct mlx4_wqe_raddr_seg);\r\ncase MLX4_IB_QPT_RC:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg) +\r\nsizeof (struct mlx4_wqe_atomic_seg) +\r\nsizeof (struct mlx4_wqe_raddr_seg);\r\ncase MLX4_IB_QPT_SMI:\r\ncase MLX4_IB_QPT_GSI:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg) +\r\nALIGN(MLX4_IB_UD_HEADER_SIZE +\r\nDIV_ROUND_UP(MLX4_IB_UD_HEADER_SIZE,\r\nMLX4_INLINE_ALIGN) *\r\nsizeof (struct mlx4_wqe_inline_seg),\r\nsizeof (struct mlx4_wqe_data_seg)) +\r\nALIGN(4 +\r\nsizeof (struct mlx4_wqe_inline_seg),\r\nsizeof (struct mlx4_wqe_data_seg));\r\ndefault:\r\nreturn sizeof (struct mlx4_wqe_ctrl_seg);\r\n}\r\n}\r\nstatic int set_rq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,\r\nint is_user, int has_rq, struct mlx4_ib_qp *qp)\r\n{\r\nif (cap->max_recv_wr > dev->dev->caps.max_wqes - MLX4_IB_SQ_MAX_SPARE ||\r\ncap->max_recv_sge > min(dev->dev->caps.max_sq_sg, dev->dev->caps.max_rq_sg))\r\nreturn -EINVAL;\r\nif (!has_rq) {\r\nif (cap->max_recv_wr)\r\nreturn -EINVAL;\r\nqp->rq.wqe_cnt = qp->rq.max_gs = 0;\r\n} else {\r\nif (is_user && (!cap->max_recv_wr || !cap->max_recv_sge))\r\nreturn -EINVAL;\r\nqp->rq.wqe_cnt = roundup_pow_of_two(max(1U, cap->max_recv_wr));\r\nqp->rq.max_gs = roundup_pow_of_two(max(1U, cap->max_recv_sge));\r\nqp->rq.wqe_shift = ilog2(qp->rq.max_gs * sizeof (struct mlx4_wqe_data_seg));\r\n}\r\nif (is_user) {\r\ncap->max_recv_wr = qp->rq.max_post = qp->rq.wqe_cnt;\r\ncap->max_recv_sge = qp->rq.max_gs;\r\n} else {\r\ncap->max_recv_wr = qp->rq.max_post =\r\nmin(dev->dev->caps.max_wqes - MLX4_IB_SQ_MAX_SPARE, qp->rq.wqe_cnt);\r\ncap->max_recv_sge = min(qp->rq.max_gs,\r\nmin(dev->dev->caps.max_sq_sg,\r\ndev->dev->caps.max_rq_sg));\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_kernel_sq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,\r\nenum mlx4_ib_qp_type type, struct mlx4_ib_qp *qp)\r\n{\r\nint s;\r\nif (cap->max_send_wr > (dev->dev->caps.max_wqes - MLX4_IB_SQ_MAX_SPARE) ||\r\ncap->max_send_sge > min(dev->dev->caps.max_sq_sg, dev->dev->caps.max_rq_sg) ||\r\ncap->max_inline_data + send_wqe_overhead(type, qp->flags) +\r\nsizeof (struct mlx4_wqe_inline_seg) > dev->dev->caps.max_sq_desc_sz)\r\nreturn -EINVAL;\r\nif ((type == MLX4_IB_QPT_SMI || type == MLX4_IB_QPT_GSI ||\r\ntype & (MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER)) &&\r\ncap->max_send_sge + 2 > dev->dev->caps.max_sq_sg)\r\nreturn -EINVAL;\r\ns = max(cap->max_send_sge * sizeof (struct mlx4_wqe_data_seg),\r\ncap->max_inline_data + sizeof (struct mlx4_wqe_inline_seg)) +\r\nsend_wqe_overhead(type, qp->flags);\r\nif (s > dev->dev->caps.max_sq_desc_sz)\r\nreturn -EINVAL;\r\nif (dev->dev->caps.fw_ver >= MLX4_FW_VER_WQE_CTRL_NEC &&\r\nqp->sq_signal_bits && BITS_PER_LONG == 64 &&\r\ntype != MLX4_IB_QPT_SMI && type != MLX4_IB_QPT_GSI &&\r\n!(type & (MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_PROXY_SMI |\r\nMLX4_IB_QPT_PROXY_GSI | MLX4_IB_QPT_TUN_SMI_OWNER)))\r\nqp->sq.wqe_shift = ilog2(64);\r\nelse\r\nqp->sq.wqe_shift = ilog2(roundup_pow_of_two(s));\r\nfor (;;) {\r\nqp->sq_max_wqes_per_wr = DIV_ROUND_UP(s, 1U << qp->sq.wqe_shift);\r\nqp->sq_spare_wqes = (2048 >> qp->sq.wqe_shift) + qp->sq_max_wqes_per_wr;\r\nqp->sq.wqe_cnt = roundup_pow_of_two(cap->max_send_wr *\r\nqp->sq_max_wqes_per_wr +\r\nqp->sq_spare_wqes);\r\nif (qp->sq.wqe_cnt <= dev->dev->caps.max_wqes)\r\nbreak;\r\nif (qp->sq_max_wqes_per_wr <= 1)\r\nreturn -EINVAL;\r\n++qp->sq.wqe_shift;\r\n}\r\nqp->sq.max_gs = (min(dev->dev->caps.max_sq_desc_sz,\r\n(qp->sq_max_wqes_per_wr << qp->sq.wqe_shift)) -\r\nsend_wqe_overhead(type, qp->flags)) /\r\nsizeof (struct mlx4_wqe_data_seg);\r\nqp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\r\n(qp->sq.wqe_cnt << qp->sq.wqe_shift);\r\nif (qp->rq.wqe_shift > qp->sq.wqe_shift) {\r\nqp->rq.offset = 0;\r\nqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\r\n} else {\r\nqp->rq.offset = qp->sq.wqe_cnt << qp->sq.wqe_shift;\r\nqp->sq.offset = 0;\r\n}\r\ncap->max_send_wr = qp->sq.max_post =\r\n(qp->sq.wqe_cnt - qp->sq_spare_wqes) / qp->sq_max_wqes_per_wr;\r\ncap->max_send_sge = min(qp->sq.max_gs,\r\nmin(dev->dev->caps.max_sq_sg,\r\ndev->dev->caps.max_rq_sg));\r\ncap->max_inline_data = 0;\r\nreturn 0;\r\n}\r\nstatic int set_user_sq_size(struct mlx4_ib_dev *dev,\r\nstruct mlx4_ib_qp *qp,\r\nstruct mlx4_ib_create_qp *ucmd)\r\n{\r\nif ((1 << ucmd->log_sq_bb_count) > dev->dev->caps.max_wqes ||\r\nucmd->log_sq_stride >\r\nilog2(roundup_pow_of_two(dev->dev->caps.max_sq_desc_sz)) ||\r\nucmd->log_sq_stride < MLX4_IB_MIN_SQ_STRIDE)\r\nreturn -EINVAL;\r\nqp->sq.wqe_cnt = 1 << ucmd->log_sq_bb_count;\r\nqp->sq.wqe_shift = ucmd->log_sq_stride;\r\nqp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\r\n(qp->sq.wqe_cnt << qp->sq.wqe_shift);\r\nreturn 0;\r\n}\r\nstatic int alloc_proxy_bufs(struct ib_device *dev, struct mlx4_ib_qp *qp)\r\n{\r\nint i;\r\nqp->sqp_proxy_rcv =\r\nkmalloc(sizeof (struct mlx4_ib_buf) * qp->rq.wqe_cnt,\r\nGFP_KERNEL);\r\nif (!qp->sqp_proxy_rcv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < qp->rq.wqe_cnt; i++) {\r\nqp->sqp_proxy_rcv[i].addr =\r\nkmalloc(sizeof (struct mlx4_ib_proxy_sqp_hdr),\r\nGFP_KERNEL);\r\nif (!qp->sqp_proxy_rcv[i].addr)\r\ngoto err;\r\nqp->sqp_proxy_rcv[i].map =\r\nib_dma_map_single(dev, qp->sqp_proxy_rcv[i].addr,\r\nsizeof (struct mlx4_ib_proxy_sqp_hdr),\r\nDMA_FROM_DEVICE);\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (i > 0) {\r\n--i;\r\nib_dma_unmap_single(dev, qp->sqp_proxy_rcv[i].map,\r\nsizeof (struct mlx4_ib_proxy_sqp_hdr),\r\nDMA_FROM_DEVICE);\r\nkfree(qp->sqp_proxy_rcv[i].addr);\r\n}\r\nkfree(qp->sqp_proxy_rcv);\r\nqp->sqp_proxy_rcv = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void free_proxy_bufs(struct ib_device *dev, struct mlx4_ib_qp *qp)\r\n{\r\nint i;\r\nfor (i = 0; i < qp->rq.wqe_cnt; i++) {\r\nib_dma_unmap_single(dev, qp->sqp_proxy_rcv[i].map,\r\nsizeof (struct mlx4_ib_proxy_sqp_hdr),\r\nDMA_FROM_DEVICE);\r\nkfree(qp->sqp_proxy_rcv[i].addr);\r\n}\r\nkfree(qp->sqp_proxy_rcv);\r\n}\r\nstatic int qp_has_rq(struct ib_qp_init_attr *attr)\r\n{\r\nif (attr->qp_type == IB_QPT_XRC_INI || attr->qp_type == IB_QPT_XRC_TGT)\r\nreturn 0;\r\nreturn !attr->srq;\r\n}\r\nstatic int create_qp_common(struct mlx4_ib_dev *dev, struct ib_pd *pd,\r\nstruct ib_qp_init_attr *init_attr,\r\nstruct ib_udata *udata, int sqpn, struct mlx4_ib_qp **caller_qp)\r\n{\r\nint qpn;\r\nint err;\r\nstruct mlx4_ib_sqp *sqp;\r\nstruct mlx4_ib_qp *qp;\r\nenum mlx4_ib_qp_type qp_type = (enum mlx4_ib_qp_type) init_attr->qp_type;\r\nif (sqpn) {\r\nif (mlx4_is_mfunc(dev->dev) &&\r\n(!mlx4_is_master(dev->dev) ||\r\n!(init_attr->create_flags & MLX4_IB_SRIOV_SQP))) {\r\nif (init_attr->qp_type == IB_QPT_GSI)\r\nqp_type = MLX4_IB_QPT_PROXY_GSI;\r\nelse if (mlx4_is_master(dev->dev))\r\nqp_type = MLX4_IB_QPT_PROXY_SMI_OWNER;\r\nelse\r\nqp_type = MLX4_IB_QPT_PROXY_SMI;\r\n}\r\nqpn = sqpn;\r\ninit_attr->cap.max_recv_sge++;\r\n} else if (init_attr->create_flags & MLX4_IB_SRIOV_TUNNEL_QP) {\r\nstruct mlx4_ib_qp_tunnel_init_attr *tnl_init =\r\ncontainer_of(init_attr,\r\nstruct mlx4_ib_qp_tunnel_init_attr, init_attr);\r\nif ((tnl_init->proxy_qp_type != IB_QPT_SMI &&\r\ntnl_init->proxy_qp_type != IB_QPT_GSI) ||\r\n!mlx4_is_master(dev->dev))\r\nreturn -EINVAL;\r\nif (tnl_init->proxy_qp_type == IB_QPT_GSI)\r\nqp_type = MLX4_IB_QPT_TUN_GSI;\r\nelse if (tnl_init->slave == mlx4_master_func_num(dev->dev))\r\nqp_type = MLX4_IB_QPT_TUN_SMI_OWNER;\r\nelse\r\nqp_type = MLX4_IB_QPT_TUN_SMI;\r\nqpn = dev->dev->phys_caps.base_tunnel_sqpn + 8 * tnl_init->slave\r\n+ tnl_init->proxy_qp_type * 2 + tnl_init->port - 1;\r\nsqpn = qpn;\r\n}\r\nif (!*caller_qp) {\r\nif (qp_type == MLX4_IB_QPT_SMI || qp_type == MLX4_IB_QPT_GSI ||\r\n(qp_type & (MLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_SMI_OWNER |\r\nMLX4_IB_QPT_PROXY_GSI | MLX4_IB_QPT_TUN_SMI_OWNER))) {\r\nsqp = kzalloc(sizeof (struct mlx4_ib_sqp), GFP_KERNEL);\r\nif (!sqp)\r\nreturn -ENOMEM;\r\nqp = &sqp->qp;\r\n} else {\r\nqp = kzalloc(sizeof (struct mlx4_ib_qp), GFP_KERNEL);\r\nif (!qp)\r\nreturn -ENOMEM;\r\n}\r\n} else\r\nqp = *caller_qp;\r\nqp->mlx4_ib_qp_type = qp_type;\r\nmutex_init(&qp->mutex);\r\nspin_lock_init(&qp->sq.lock);\r\nspin_lock_init(&qp->rq.lock);\r\nINIT_LIST_HEAD(&qp->gid_list);\r\nINIT_LIST_HEAD(&qp->steering_rules);\r\nqp->state = IB_QPS_RESET;\r\nif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\r\nqp->sq_signal_bits = cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE);\r\nerr = set_rq_size(dev, &init_attr->cap, !!pd->uobject, qp_has_rq(init_attr), qp);\r\nif (err)\r\ngoto err;\r\nif (pd->uobject) {\r\nstruct mlx4_ib_create_qp ucmd;\r\nif (ib_copy_from_udata(&ucmd, udata, sizeof ucmd)) {\r\nerr = -EFAULT;\r\ngoto err;\r\n}\r\nqp->sq_no_prefetch = ucmd.sq_no_prefetch;\r\nerr = set_user_sq_size(dev, qp, &ucmd);\r\nif (err)\r\ngoto err;\r\nqp->umem = ib_umem_get(pd->uobject->context, ucmd.buf_addr,\r\nqp->buf_size, 0, 0);\r\nif (IS_ERR(qp->umem)) {\r\nerr = PTR_ERR(qp->umem);\r\ngoto err;\r\n}\r\nerr = mlx4_mtt_init(dev->dev, ib_umem_page_count(qp->umem),\r\nilog2(qp->umem->page_size), &qp->mtt);\r\nif (err)\r\ngoto err_buf;\r\nerr = mlx4_ib_umem_write_mtt(dev, &qp->mtt, qp->umem);\r\nif (err)\r\ngoto err_mtt;\r\nif (qp_has_rq(init_attr)) {\r\nerr = mlx4_ib_db_map_user(to_mucontext(pd->uobject->context),\r\nucmd.db_addr, &qp->db);\r\nif (err)\r\ngoto err_mtt;\r\n}\r\n} else {\r\nqp->sq_no_prefetch = 0;\r\nif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK)\r\nqp->flags |= MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK;\r\nif (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)\r\nqp->flags |= MLX4_IB_QP_LSO;\r\nerr = set_kernel_sq_size(dev, &init_attr->cap, qp_type, qp);\r\nif (err)\r\ngoto err;\r\nif (qp_has_rq(init_attr)) {\r\nerr = mlx4_db_alloc(dev->dev, &qp->db, 0);\r\nif (err)\r\ngoto err;\r\n*qp->db.db = 0;\r\n}\r\nif (mlx4_buf_alloc(dev->dev, qp->buf_size, PAGE_SIZE * 2, &qp->buf)) {\r\nerr = -ENOMEM;\r\ngoto err_db;\r\n}\r\nerr = mlx4_mtt_init(dev->dev, qp->buf.npages, qp->buf.page_shift,\r\n&qp->mtt);\r\nif (err)\r\ngoto err_buf;\r\nerr = mlx4_buf_write_mtt(dev->dev, &qp->mtt, &qp->buf);\r\nif (err)\r\ngoto err_mtt;\r\nqp->sq.wrid = kmalloc(qp->sq.wqe_cnt * sizeof (u64), GFP_KERNEL);\r\nqp->rq.wrid = kmalloc(qp->rq.wqe_cnt * sizeof (u64), GFP_KERNEL);\r\nif (!qp->sq.wrid || !qp->rq.wrid) {\r\nerr = -ENOMEM;\r\ngoto err_wrid;\r\n}\r\n}\r\nif (sqpn) {\r\nif (qp->mlx4_ib_qp_type & (MLX4_IB_QPT_PROXY_SMI_OWNER |\r\nMLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_GSI)) {\r\nif (alloc_proxy_bufs(pd->device, qp)) {\r\nerr = -ENOMEM;\r\ngoto err_wrid;\r\n}\r\n}\r\n} else {\r\nif (init_attr->qp_type == IB_QPT_RAW_PACKET)\r\nerr = mlx4_qp_reserve_range(dev->dev, 1, 1 << 8, &qpn);\r\nelse\r\nerr = mlx4_qp_reserve_range(dev->dev, 1, 1, &qpn);\r\nif (err)\r\ngoto err_proxy;\r\n}\r\nerr = mlx4_qp_alloc(dev->dev, qpn, &qp->mqp);\r\nif (err)\r\ngoto err_qpn;\r\nif (init_attr->qp_type == IB_QPT_XRC_TGT)\r\nqp->mqp.qpn |= (1 << 23);\r\nqp->doorbell_qpn = swab32(qp->mqp.qpn << 8);\r\nqp->mqp.event = mlx4_ib_qp_event;\r\nif (!*caller_qp)\r\n*caller_qp = qp;\r\nreturn 0;\r\nerr_qpn:\r\nif (!sqpn)\r\nmlx4_qp_release_range(dev->dev, qpn, 1);\r\nerr_proxy:\r\nif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI)\r\nfree_proxy_bufs(pd->device, qp);\r\nerr_wrid:\r\nif (pd->uobject) {\r\nif (qp_has_rq(init_attr))\r\nmlx4_ib_db_unmap_user(to_mucontext(pd->uobject->context), &qp->db);\r\n} else {\r\nkfree(qp->sq.wrid);\r\nkfree(qp->rq.wrid);\r\n}\r\nerr_mtt:\r\nmlx4_mtt_cleanup(dev->dev, &qp->mtt);\r\nerr_buf:\r\nif (pd->uobject)\r\nib_umem_release(qp->umem);\r\nelse\r\nmlx4_buf_free(dev->dev, qp->buf_size, &qp->buf);\r\nerr_db:\r\nif (!pd->uobject && qp_has_rq(init_attr))\r\nmlx4_db_free(dev->dev, &qp->db);\r\nerr:\r\nif (!*caller_qp)\r\nkfree(qp);\r\nreturn err;\r\n}\r\nstatic enum mlx4_qp_state to_mlx4_state(enum ib_qp_state state)\r\n{\r\nswitch (state) {\r\ncase IB_QPS_RESET: return MLX4_QP_STATE_RST;\r\ncase IB_QPS_INIT: return MLX4_QP_STATE_INIT;\r\ncase IB_QPS_RTR: return MLX4_QP_STATE_RTR;\r\ncase IB_QPS_RTS: return MLX4_QP_STATE_RTS;\r\ncase IB_QPS_SQD: return MLX4_QP_STATE_SQD;\r\ncase IB_QPS_SQE: return MLX4_QP_STATE_SQER;\r\ncase IB_QPS_ERR: return MLX4_QP_STATE_ERR;\r\ndefault: return -1;\r\n}\r\n}\r\nstatic void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)\r\n__acquires(&send_cq->lock\r\nstatic void mlx4_ib_unlock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)\r\n__releases(&send_cq->lock\r\nstatic void del_gid_entries(struct mlx4_ib_qp *qp)\r\n{\r\nstruct mlx4_ib_gid_entry *ge, *tmp;\r\nlist_for_each_entry_safe(ge, tmp, &qp->gid_list, list) {\r\nlist_del(&ge->list);\r\nkfree(ge);\r\n}\r\n}\r\nstatic struct mlx4_ib_pd *get_pd(struct mlx4_ib_qp *qp)\r\n{\r\nif (qp->ibqp.qp_type == IB_QPT_XRC_TGT)\r\nreturn to_mpd(to_mxrcd(qp->ibqp.xrcd)->pd);\r\nelse\r\nreturn to_mpd(qp->ibqp.pd);\r\n}\r\nstatic void get_cqs(struct mlx4_ib_qp *qp,\r\nstruct mlx4_ib_cq **send_cq, struct mlx4_ib_cq **recv_cq)\r\n{\r\nswitch (qp->ibqp.qp_type) {\r\ncase IB_QPT_XRC_TGT:\r\n*send_cq = to_mcq(to_mxrcd(qp->ibqp.xrcd)->cq);\r\n*recv_cq = *send_cq;\r\nbreak;\r\ncase IB_QPT_XRC_INI:\r\n*send_cq = to_mcq(qp->ibqp.send_cq);\r\n*recv_cq = *send_cq;\r\nbreak;\r\ndefault:\r\n*send_cq = to_mcq(qp->ibqp.send_cq);\r\n*recv_cq = to_mcq(qp->ibqp.recv_cq);\r\nbreak;\r\n}\r\n}\r\nstatic void destroy_qp_common(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp,\r\nint is_user)\r\n{\r\nstruct mlx4_ib_cq *send_cq, *recv_cq;\r\nif (qp->state != IB_QPS_RESET)\r\nif (mlx4_qp_modify(dev->dev, NULL, to_mlx4_state(qp->state),\r\nMLX4_QP_STATE_RST, NULL, 0, 0, &qp->mqp))\r\npr_warn("modify QP %06x to RESET failed.\n",\r\nqp->mqp.qpn);\r\nget_cqs(qp, &send_cq, &recv_cq);\r\nmlx4_ib_lock_cqs(send_cq, recv_cq);\r\nif (!is_user) {\r\n__mlx4_ib_cq_clean(recv_cq, qp->mqp.qpn,\r\nqp->ibqp.srq ? to_msrq(qp->ibqp.srq): NULL);\r\nif (send_cq != recv_cq)\r\n__mlx4_ib_cq_clean(send_cq, qp->mqp.qpn, NULL);\r\n}\r\nmlx4_qp_remove(dev->dev, &qp->mqp);\r\nmlx4_ib_unlock_cqs(send_cq, recv_cq);\r\nmlx4_qp_free(dev->dev, &qp->mqp);\r\nif (!is_sqp(dev, qp) && !is_tunnel_qp(dev, qp))\r\nmlx4_qp_release_range(dev->dev, qp->mqp.qpn, 1);\r\nmlx4_mtt_cleanup(dev->dev, &qp->mtt);\r\nif (is_user) {\r\nif (qp->rq.wqe_cnt)\r\nmlx4_ib_db_unmap_user(to_mucontext(qp->ibqp.uobject->context),\r\n&qp->db);\r\nib_umem_release(qp->umem);\r\n} else {\r\nkfree(qp->sq.wrid);\r\nkfree(qp->rq.wrid);\r\nif (qp->mlx4_ib_qp_type & (MLX4_IB_QPT_PROXY_SMI_OWNER |\r\nMLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_GSI))\r\nfree_proxy_bufs(&dev->ib_dev, qp);\r\nmlx4_buf_free(dev->dev, qp->buf_size, &qp->buf);\r\nif (qp->rq.wqe_cnt)\r\nmlx4_db_free(dev->dev, &qp->db);\r\n}\r\ndel_gid_entries(qp);\r\n}\r\nstatic u32 get_sqp_num(struct mlx4_ib_dev *dev, struct ib_qp_init_attr *attr)\r\n{\r\nif (!mlx4_is_mfunc(dev->dev) ||\r\n(mlx4_is_master(dev->dev) &&\r\nattr->create_flags & MLX4_IB_SRIOV_SQP)) {\r\nreturn dev->dev->phys_caps.base_sqpn +\r\n(attr->qp_type == IB_QPT_SMI ? 0 : 2) +\r\nattr->port_num - 1;\r\n}\r\nif (attr->qp_type == IB_QPT_SMI)\r\nreturn dev->dev->caps.qp0_proxy[attr->port_num - 1];\r\nelse\r\nreturn dev->dev->caps.qp1_proxy[attr->port_num - 1];\r\n}\r\nstruct ib_qp *mlx4_ib_create_qp(struct ib_pd *pd,\r\nstruct ib_qp_init_attr *init_attr,\r\nstruct ib_udata *udata)\r\n{\r\nstruct mlx4_ib_qp *qp = NULL;\r\nint err;\r\nu16 xrcdn = 0;\r\nif (init_attr->create_flags & ~(MLX4_IB_QP_LSO |\r\nMLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK |\r\nMLX4_IB_SRIOV_TUNNEL_QP | MLX4_IB_SRIOV_SQP))\r\nreturn ERR_PTR(-EINVAL);\r\nif (init_attr->create_flags &&\r\n(udata ||\r\n((init_attr->create_flags & ~MLX4_IB_SRIOV_SQP) &&\r\ninit_attr->qp_type != IB_QPT_UD) ||\r\n((init_attr->create_flags & MLX4_IB_SRIOV_SQP) &&\r\ninit_attr->qp_type > IB_QPT_GSI)))\r\nreturn ERR_PTR(-EINVAL);\r\nswitch (init_attr->qp_type) {\r\ncase IB_QPT_XRC_TGT:\r\npd = to_mxrcd(init_attr->xrcd)->pd;\r\nxrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;\r\ninit_attr->send_cq = to_mxrcd(init_attr->xrcd)->cq;\r\ncase IB_QPT_XRC_INI:\r\nif (!(to_mdev(pd->device)->dev->caps.flags & MLX4_DEV_CAP_FLAG_XRC))\r\nreturn ERR_PTR(-ENOSYS);\r\ninit_attr->recv_cq = init_attr->send_cq;\r\ncase IB_QPT_RC:\r\ncase IB_QPT_UC:\r\ncase IB_QPT_RAW_PACKET:\r\nqp = kzalloc(sizeof *qp, GFP_KERNEL);\r\nif (!qp)\r\nreturn ERR_PTR(-ENOMEM);\r\ncase IB_QPT_UD:\r\n{\r\nerr = create_qp_common(to_mdev(pd->device), pd, init_attr,\r\nudata, 0, &qp);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nqp->ibqp.qp_num = qp->mqp.qpn;\r\nqp->xrcdn = xrcdn;\r\nbreak;\r\n}\r\ncase IB_QPT_SMI:\r\ncase IB_QPT_GSI:\r\n{\r\nif (udata)\r\nreturn ERR_PTR(-EINVAL);\r\nerr = create_qp_common(to_mdev(pd->device), pd, init_attr, udata,\r\nget_sqp_num(to_mdev(pd->device), init_attr),\r\n&qp);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nqp->port = init_attr->port_num;\r\nqp->ibqp.qp_num = init_attr->qp_type == IB_QPT_SMI ? 0 : 1;\r\nbreak;\r\n}\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn &qp->ibqp;\r\n}\r\nint mlx4_ib_destroy_qp(struct ib_qp *qp)\r\n{\r\nstruct mlx4_ib_dev *dev = to_mdev(qp->device);\r\nstruct mlx4_ib_qp *mqp = to_mqp(qp);\r\nstruct mlx4_ib_pd *pd;\r\nif (is_qp0(dev, mqp))\r\nmlx4_CLOSE_PORT(dev->dev, mqp->port);\r\npd = get_pd(mqp);\r\ndestroy_qp_common(dev, mqp, !!pd->ibpd.uobject);\r\nif (is_sqp(dev, mqp))\r\nkfree(to_msqp(mqp));\r\nelse\r\nkfree(mqp);\r\nreturn 0;\r\n}\r\nstatic int to_mlx4_st(struct mlx4_ib_dev *dev, enum mlx4_ib_qp_type type)\r\n{\r\nswitch (type) {\r\ncase MLX4_IB_QPT_RC: return MLX4_QP_ST_RC;\r\ncase MLX4_IB_QPT_UC: return MLX4_QP_ST_UC;\r\ncase MLX4_IB_QPT_UD: return MLX4_QP_ST_UD;\r\ncase MLX4_IB_QPT_XRC_INI:\r\ncase MLX4_IB_QPT_XRC_TGT: return MLX4_QP_ST_XRC;\r\ncase MLX4_IB_QPT_SMI:\r\ncase MLX4_IB_QPT_GSI:\r\ncase MLX4_IB_QPT_RAW_PACKET: return MLX4_QP_ST_MLX;\r\ncase MLX4_IB_QPT_PROXY_SMI_OWNER:\r\ncase MLX4_IB_QPT_TUN_SMI_OWNER: return (mlx4_is_mfunc(dev->dev) ?\r\nMLX4_QP_ST_MLX : -1);\r\ncase MLX4_IB_QPT_PROXY_SMI:\r\ncase MLX4_IB_QPT_TUN_SMI:\r\ncase MLX4_IB_QPT_PROXY_GSI:\r\ncase MLX4_IB_QPT_TUN_GSI: return (mlx4_is_mfunc(dev->dev) ?\r\nMLX4_QP_ST_UD : -1);\r\ndefault: return -1;\r\n}\r\n}\r\nstatic __be32 to_mlx4_access_flags(struct mlx4_ib_qp *qp, const struct ib_qp_attr *attr,\r\nint attr_mask)\r\n{\r\nu8 dest_rd_atomic;\r\nu32 access_flags;\r\nu32 hw_access_flags = 0;\r\nif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\r\ndest_rd_atomic = attr->max_dest_rd_atomic;\r\nelse\r\ndest_rd_atomic = qp->resp_depth;\r\nif (attr_mask & IB_QP_ACCESS_FLAGS)\r\naccess_flags = attr->qp_access_flags;\r\nelse\r\naccess_flags = qp->atomic_rd_en;\r\nif (!dest_rd_atomic)\r\naccess_flags &= IB_ACCESS_REMOTE_WRITE;\r\nif (access_flags & IB_ACCESS_REMOTE_READ)\r\nhw_access_flags |= MLX4_QP_BIT_RRE;\r\nif (access_flags & IB_ACCESS_REMOTE_ATOMIC)\r\nhw_access_flags |= MLX4_QP_BIT_RAE;\r\nif (access_flags & IB_ACCESS_REMOTE_WRITE)\r\nhw_access_flags |= MLX4_QP_BIT_RWE;\r\nreturn cpu_to_be32(hw_access_flags);\r\n}\r\nstatic void store_sqp_attrs(struct mlx4_ib_sqp *sqp, const struct ib_qp_attr *attr,\r\nint attr_mask)\r\n{\r\nif (attr_mask & IB_QP_PKEY_INDEX)\r\nsqp->pkey_index = attr->pkey_index;\r\nif (attr_mask & IB_QP_QKEY)\r\nsqp->qkey = attr->qkey;\r\nif (attr_mask & IB_QP_SQ_PSN)\r\nsqp->send_psn = attr->sq_psn;\r\n}\r\nstatic void mlx4_set_sched(struct mlx4_qp_path *path, u8 port)\r\n{\r\npath->sched_queue = (path->sched_queue & 0xbf) | ((port - 1) << 6);\r\n}\r\nstatic int mlx4_set_path(struct mlx4_ib_dev *dev, const struct ib_ah_attr *ah,\r\nstruct mlx4_qp_path *path, u8 port)\r\n{\r\nint err;\r\nint is_eth = rdma_port_get_link_layer(&dev->ib_dev, port) ==\r\nIB_LINK_LAYER_ETHERNET;\r\nu8 mac[6];\r\nint is_mcast;\r\nu16 vlan_tag;\r\nint vidx;\r\npath->grh_mylmc = ah->src_path_bits & 0x7f;\r\npath->rlid = cpu_to_be16(ah->dlid);\r\nif (ah->static_rate) {\r\npath->static_rate = ah->static_rate + MLX4_STAT_RATE_OFFSET;\r\nwhile (path->static_rate > IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &&\r\n!(1 << path->static_rate & dev->dev->caps.stat_rate_support))\r\n--path->static_rate;\r\n} else\r\npath->static_rate = 0;\r\nif (ah->ah_flags & IB_AH_GRH) {\r\nif (ah->grh.sgid_index >= dev->dev->caps.gid_table_len[port]) {\r\npr_err("sgid_index (%u) too large. max is %d\n",\r\nah->grh.sgid_index, dev->dev->caps.gid_table_len[port] - 1);\r\nreturn -1;\r\n}\r\npath->grh_mylmc |= 1 << 7;\r\npath->mgid_index = ah->grh.sgid_index;\r\npath->hop_limit = ah->grh.hop_limit;\r\npath->tclass_flowlabel =\r\ncpu_to_be32((ah->grh.traffic_class << 20) |\r\n(ah->grh.flow_label));\r\nmemcpy(path->rgid, ah->grh.dgid.raw, 16);\r\n}\r\nif (is_eth) {\r\npath->sched_queue = MLX4_IB_DEFAULT_SCHED_QUEUE |\r\n((port - 1) << 6) | ((ah->sl & 7) << 3);\r\nif (!(ah->ah_flags & IB_AH_GRH))\r\nreturn -1;\r\nerr = mlx4_ib_resolve_grh(dev, ah, mac, &is_mcast, port);\r\nif (err)\r\nreturn err;\r\nmemcpy(path->dmac, mac, 6);\r\npath->ackto = MLX4_IB_LINK_TYPE_ETH;\r\npath->grh_mylmc &= 0x80;\r\nvlan_tag = rdma_get_vlan_id(&dev->iboe.gid_table[port - 1][ah->grh.sgid_index]);\r\nif (vlan_tag < 0x1000) {\r\nif (mlx4_find_cached_vlan(dev->dev, port, vlan_tag, &vidx))\r\nreturn -ENOENT;\r\npath->vlan_index = vidx;\r\npath->fl = 1 << 6;\r\n}\r\n} else\r\npath->sched_queue = MLX4_IB_DEFAULT_SCHED_QUEUE |\r\n((port - 1) << 6) | ((ah->sl & 0xf) << 2);\r\nreturn 0;\r\n}\r\nstatic void update_mcg_macs(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\r\n{\r\nstruct mlx4_ib_gid_entry *ge, *tmp;\r\nlist_for_each_entry_safe(ge, tmp, &qp->gid_list, list) {\r\nif (!ge->added && mlx4_ib_add_mc(dev, qp, &ge->gid)) {\r\nge->added = 1;\r\nge->port = qp->port;\r\n}\r\n}\r\n}\r\nstatic int __mlx4_ib_modify_qp(struct ib_qp *ibqp,\r\nconst struct ib_qp_attr *attr, int attr_mask,\r\nenum ib_qp_state cur_state, enum ib_qp_state new_state)\r\n{\r\nstruct mlx4_ib_dev *dev = to_mdev(ibqp->device);\r\nstruct mlx4_ib_qp *qp = to_mqp(ibqp);\r\nstruct mlx4_ib_pd *pd;\r\nstruct mlx4_ib_cq *send_cq, *recv_cq;\r\nstruct mlx4_qp_context *context;\r\nenum mlx4_qp_optpar optpar = 0;\r\nint sqd_event;\r\nint err = -EINVAL;\r\ncontext = kzalloc(sizeof *context, GFP_KERNEL);\r\nif (!context)\r\nreturn -ENOMEM;\r\ncontext->flags = cpu_to_be32((to_mlx4_state(new_state) << 28) |\r\n(to_mlx4_st(dev, qp->mlx4_ib_qp_type) << 16));\r\nif (!(attr_mask & IB_QP_PATH_MIG_STATE))\r\ncontext->flags |= cpu_to_be32(MLX4_QP_PM_MIGRATED << 11);\r\nelse {\r\noptpar |= MLX4_QP_OPTPAR_PM_STATE;\r\nswitch (attr->path_mig_state) {\r\ncase IB_MIG_MIGRATED:\r\ncontext->flags |= cpu_to_be32(MLX4_QP_PM_MIGRATED << 11);\r\nbreak;\r\ncase IB_MIG_REARM:\r\ncontext->flags |= cpu_to_be32(MLX4_QP_PM_REARM << 11);\r\nbreak;\r\ncase IB_MIG_ARMED:\r\ncontext->flags |= cpu_to_be32(MLX4_QP_PM_ARMED << 11);\r\nbreak;\r\n}\r\n}\r\nif (ibqp->qp_type == IB_QPT_GSI || ibqp->qp_type == IB_QPT_SMI)\r\ncontext->mtu_msgmax = (IB_MTU_4096 << 5) | 11;\r\nelse if (ibqp->qp_type == IB_QPT_RAW_PACKET)\r\ncontext->mtu_msgmax = (MLX4_RAW_QP_MTU << 5) | MLX4_RAW_QP_MSGMAX;\r\nelse if (ibqp->qp_type == IB_QPT_UD) {\r\nif (qp->flags & MLX4_IB_QP_LSO)\r\ncontext->mtu_msgmax = (IB_MTU_4096 << 5) |\r\nilog2(dev->dev->caps.max_gso_sz);\r\nelse\r\ncontext->mtu_msgmax = (IB_MTU_4096 << 5) | 12;\r\n} else if (attr_mask & IB_QP_PATH_MTU) {\r\nif (attr->path_mtu < IB_MTU_256 || attr->path_mtu > IB_MTU_4096) {\r\npr_err("path MTU (%u) is invalid\n",\r\nattr->path_mtu);\r\ngoto out;\r\n}\r\ncontext->mtu_msgmax = (attr->path_mtu << 5) |\r\nilog2(dev->dev->caps.max_msg_sz);\r\n}\r\nif (qp->rq.wqe_cnt)\r\ncontext->rq_size_stride = ilog2(qp->rq.wqe_cnt) << 3;\r\ncontext->rq_size_stride |= qp->rq.wqe_shift - 4;\r\nif (qp->sq.wqe_cnt)\r\ncontext->sq_size_stride = ilog2(qp->sq.wqe_cnt) << 3;\r\ncontext->sq_size_stride |= qp->sq.wqe_shift - 4;\r\nif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\r\ncontext->sq_size_stride |= !!qp->sq_no_prefetch << 7;\r\ncontext->xrcd = cpu_to_be32((u32) qp->xrcdn);\r\n}\r\nif (qp->ibqp.uobject)\r\ncontext->usr_page = cpu_to_be32(to_mucontext(ibqp->uobject->context)->uar.index);\r\nelse\r\ncontext->usr_page = cpu_to_be32(dev->priv_uar.index);\r\nif (attr_mask & IB_QP_DEST_QPN)\r\ncontext->remote_qpn = cpu_to_be32(attr->dest_qp_num);\r\nif (attr_mask & IB_QP_PORT) {\r\nif (cur_state == IB_QPS_SQD && new_state == IB_QPS_SQD &&\r\n!(attr_mask & IB_QP_AV)) {\r\nmlx4_set_sched(&context->pri_path, attr->port_num);\r\noptpar |= MLX4_QP_OPTPAR_SCHED_QUEUE;\r\n}\r\n}\r\nif (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\r\nif (dev->counters[qp->port - 1] != -1) {\r\ncontext->pri_path.counter_index =\r\ndev->counters[qp->port - 1];\r\noptpar |= MLX4_QP_OPTPAR_COUNTER_INDEX;\r\n} else\r\ncontext->pri_path.counter_index = 0xff;\r\n}\r\nif (attr_mask & IB_QP_PKEY_INDEX) {\r\nif (qp->mlx4_ib_qp_type & MLX4_IB_QPT_ANY_SRIOV)\r\ncontext->pri_path.disable_pkey_check = 0x40;\r\ncontext->pri_path.pkey_index = attr->pkey_index;\r\noptpar |= MLX4_QP_OPTPAR_PKEY_INDEX;\r\n}\r\nif (attr_mask & IB_QP_AV) {\r\nif (mlx4_set_path(dev, &attr->ah_attr, &context->pri_path,\r\nattr_mask & IB_QP_PORT ?\r\nattr->port_num : qp->port))\r\ngoto out;\r\noptpar |= (MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH |\r\nMLX4_QP_OPTPAR_SCHED_QUEUE);\r\n}\r\nif (attr_mask & IB_QP_TIMEOUT) {\r\ncontext->pri_path.ackto |= attr->timeout << 3;\r\noptpar |= MLX4_QP_OPTPAR_ACK_TIMEOUT;\r\n}\r\nif (attr_mask & IB_QP_ALT_PATH) {\r\nif (attr->alt_port_num == 0 ||\r\nattr->alt_port_num > dev->dev->caps.num_ports)\r\ngoto out;\r\nif (attr->alt_pkey_index >=\r\ndev->dev->caps.pkey_table_len[attr->alt_port_num])\r\ngoto out;\r\nif (mlx4_set_path(dev, &attr->alt_ah_attr, &context->alt_path,\r\nattr->alt_port_num))\r\ngoto out;\r\ncontext->alt_path.pkey_index = attr->alt_pkey_index;\r\ncontext->alt_path.ackto = attr->alt_timeout << 3;\r\noptpar |= MLX4_QP_OPTPAR_ALT_ADDR_PATH;\r\n}\r\npd = get_pd(qp);\r\nget_cqs(qp, &send_cq, &recv_cq);\r\ncontext->pd = cpu_to_be32(pd->pdn);\r\ncontext->cqn_send = cpu_to_be32(send_cq->mcq.cqn);\r\ncontext->cqn_recv = cpu_to_be32(recv_cq->mcq.cqn);\r\ncontext->params1 = cpu_to_be32(MLX4_IB_ACK_REQ_FREQ << 28);\r\nif (!qp->ibqp.uobject)\r\ncontext->params1 |= cpu_to_be32(1 << 11);\r\nif (attr_mask & IB_QP_RNR_RETRY) {\r\ncontext->params1 |= cpu_to_be32(attr->rnr_retry << 13);\r\noptpar |= MLX4_QP_OPTPAR_RNR_RETRY;\r\n}\r\nif (attr_mask & IB_QP_RETRY_CNT) {\r\ncontext->params1 |= cpu_to_be32(attr->retry_cnt << 16);\r\noptpar |= MLX4_QP_OPTPAR_RETRY_COUNT;\r\n}\r\nif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\r\nif (attr->max_rd_atomic)\r\ncontext->params1 |=\r\ncpu_to_be32(fls(attr->max_rd_atomic - 1) << 21);\r\noptpar |= MLX4_QP_OPTPAR_SRA_MAX;\r\n}\r\nif (attr_mask & IB_QP_SQ_PSN)\r\ncontext->next_send_psn = cpu_to_be32(attr->sq_psn);\r\nif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\r\nif (attr->max_dest_rd_atomic)\r\ncontext->params2 |=\r\ncpu_to_be32(fls(attr->max_dest_rd_atomic - 1) << 21);\r\noptpar |= MLX4_QP_OPTPAR_RRA_MAX;\r\n}\r\nif (attr_mask & (IB_QP_ACCESS_FLAGS | IB_QP_MAX_DEST_RD_ATOMIC)) {\r\ncontext->params2 |= to_mlx4_access_flags(qp, attr, attr_mask);\r\noptpar |= MLX4_QP_OPTPAR_RWE | MLX4_QP_OPTPAR_RRE | MLX4_QP_OPTPAR_RAE;\r\n}\r\nif (ibqp->srq)\r\ncontext->params2 |= cpu_to_be32(MLX4_QP_BIT_RIC);\r\nif (attr_mask & IB_QP_MIN_RNR_TIMER) {\r\ncontext->rnr_nextrecvpsn |= cpu_to_be32(attr->min_rnr_timer << 24);\r\noptpar |= MLX4_QP_OPTPAR_RNR_TIMEOUT;\r\n}\r\nif (attr_mask & IB_QP_RQ_PSN)\r\ncontext->rnr_nextrecvpsn |= cpu_to_be32(attr->rq_psn);\r\nif (attr_mask & IB_QP_QKEY) {\r\nif (qp->mlx4_ib_qp_type &\r\n(MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER))\r\ncontext->qkey = cpu_to_be32(IB_QP_SET_QKEY);\r\nelse {\r\nif (mlx4_is_mfunc(dev->dev) &&\r\n!(qp->mlx4_ib_qp_type & MLX4_IB_QPT_ANY_SRIOV) &&\r\n(attr->qkey & MLX4_RESERVED_QKEY_MASK) ==\r\nMLX4_RESERVED_QKEY_BASE) {\r\npr_err("Cannot use reserved QKEY"\r\n" 0x%x (range 0xffff0000..0xffffffff"\r\n" is reserved)\n", attr->qkey);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ncontext->qkey = cpu_to_be32(attr->qkey);\r\n}\r\noptpar |= MLX4_QP_OPTPAR_Q_KEY;\r\n}\r\nif (ibqp->srq)\r\ncontext->srqn = cpu_to_be32(1 << 24 | to_msrq(ibqp->srq)->msrq.srqn);\r\nif (qp->rq.wqe_cnt && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\r\ncontext->db_rec_addr = cpu_to_be64(qp->db.dma);\r\nif (cur_state == IB_QPS_INIT &&\r\nnew_state == IB_QPS_RTR &&\r\n(ibqp->qp_type == IB_QPT_GSI || ibqp->qp_type == IB_QPT_SMI ||\r\nibqp->qp_type == IB_QPT_UD ||\r\nibqp->qp_type == IB_QPT_RAW_PACKET)) {\r\ncontext->pri_path.sched_queue = (qp->port - 1) << 6;\r\nif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_SMI ||\r\nqp->mlx4_ib_qp_type &\r\n(MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER)) {\r\ncontext->pri_path.sched_queue |= MLX4_IB_DEFAULT_QP0_SCHED_QUEUE;\r\nif (qp->mlx4_ib_qp_type != MLX4_IB_QPT_SMI)\r\ncontext->pri_path.fl = 0x80;\r\n} else {\r\nif (qp->mlx4_ib_qp_type & MLX4_IB_QPT_ANY_SRIOV)\r\ncontext->pri_path.fl = 0x80;\r\ncontext->pri_path.sched_queue |= MLX4_IB_DEFAULT_SCHED_QUEUE;\r\n}\r\n}\r\nif (cur_state == IB_QPS_RTS && new_state == IB_QPS_SQD &&\r\nattr_mask & IB_QP_EN_SQD_ASYNC_NOTIFY && attr->en_sqd_async_notify)\r\nsqd_event = 1;\r\nelse\r\nsqd_event = 0;\r\nif (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\r\ncontext->rlkey |= (1 << 4);\r\nif (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\r\nstruct mlx4_wqe_ctrl_seg *ctrl;\r\nint i;\r\nfor (i = 0; i < qp->sq.wqe_cnt; ++i) {\r\nctrl = get_send_wqe(qp, i);\r\nctrl->owner_opcode = cpu_to_be32(1 << 31);\r\nif (qp->sq_max_wqes_per_wr == 1)\r\nctrl->fence_size = 1 << (qp->sq.wqe_shift - 4);\r\nstamp_send_wqe(qp, i, 1 << qp->sq.wqe_shift);\r\n}\r\n}\r\nerr = mlx4_qp_modify(dev->dev, &qp->mtt, to_mlx4_state(cur_state),\r\nto_mlx4_state(new_state), context, optpar,\r\nsqd_event, &qp->mqp);\r\nif (err)\r\ngoto out;\r\nqp->state = new_state;\r\nif (attr_mask & IB_QP_ACCESS_FLAGS)\r\nqp->atomic_rd_en = attr->qp_access_flags;\r\nif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\r\nqp->resp_depth = attr->max_dest_rd_atomic;\r\nif (attr_mask & IB_QP_PORT) {\r\nqp->port = attr->port_num;\r\nupdate_mcg_macs(dev, qp);\r\n}\r\nif (attr_mask & IB_QP_ALT_PATH)\r\nqp->alt_port = attr->alt_port_num;\r\nif (is_sqp(dev, qp))\r\nstore_sqp_attrs(to_msqp(qp), attr, attr_mask);\r\nif (is_qp0(dev, qp)) {\r\nif (cur_state != IB_QPS_RTR && new_state == IB_QPS_RTR)\r\nif (mlx4_INIT_PORT(dev->dev, qp->port))\r\npr_warn("INIT_PORT failed for port %d\n",\r\nqp->port);\r\nif (cur_state != IB_QPS_RESET && cur_state != IB_QPS_ERR &&\r\n(new_state == IB_QPS_RESET || new_state == IB_QPS_ERR))\r\nmlx4_CLOSE_PORT(dev->dev, qp->port);\r\n}\r\nif (new_state == IB_QPS_RESET && !ibqp->uobject) {\r\nmlx4_ib_cq_clean(recv_cq, qp->mqp.qpn,\r\nibqp->srq ? to_msrq(ibqp->srq): NULL);\r\nif (send_cq != recv_cq)\r\nmlx4_ib_cq_clean(send_cq, qp->mqp.qpn, NULL);\r\nqp->rq.head = 0;\r\nqp->rq.tail = 0;\r\nqp->sq.head = 0;\r\nqp->sq.tail = 0;\r\nqp->sq_next_wqe = 0;\r\nif (qp->rq.wqe_cnt)\r\n*qp->db.db = 0;\r\n}\r\nout:\r\nkfree(context);\r\nreturn err;\r\n}\r\nint mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_udata *udata)\r\n{\r\nstruct mlx4_ib_dev *dev = to_mdev(ibqp->device);\r\nstruct mlx4_ib_qp *qp = to_mqp(ibqp);\r\nenum ib_qp_state cur_state, new_state;\r\nint err = -EINVAL;\r\nmutex_lock(&qp->mutex);\r\ncur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;\r\nnew_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;\r\nif (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type, attr_mask)) {\r\npr_debug("qpn 0x%x: invalid attribute mask specified "\r\n"for transition %d to %d. qp_type %d,"\r\n" attr_mask 0x%x\n",\r\nibqp->qp_num, cur_state, new_state,\r\nibqp->qp_type, attr_mask);\r\ngoto out;\r\n}\r\nif ((attr_mask & IB_QP_PORT) &&\r\n(attr->port_num == 0 || attr->port_num > dev->num_ports)) {\r\npr_debug("qpn 0x%x: invalid port number (%d) specified "\r\n"for transition %d to %d. qp_type %d\n",\r\nibqp->qp_num, attr->port_num, cur_state,\r\nnew_state, ibqp->qp_type);\r\ngoto out;\r\n}\r\nif ((attr_mask & IB_QP_PORT) && (ibqp->qp_type == IB_QPT_RAW_PACKET) &&\r\n(rdma_port_get_link_layer(&dev->ib_dev, attr->port_num) !=\r\nIB_LINK_LAYER_ETHERNET))\r\ngoto out;\r\nif (attr_mask & IB_QP_PKEY_INDEX) {\r\nint p = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\r\nif (attr->pkey_index >= dev->dev->caps.pkey_table_len[p]) {\r\npr_debug("qpn 0x%x: invalid pkey index (%d) specified "\r\n"for transition %d to %d. qp_type %d\n",\r\nibqp->qp_num, attr->pkey_index, cur_state,\r\nnew_state, ibqp->qp_type);\r\ngoto out;\r\n}\r\n}\r\nif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&\r\nattr->max_rd_atomic > dev->dev->caps.max_qp_init_rdma) {\r\npr_debug("qpn 0x%x: max_rd_atomic (%d) too large. "\r\n"Transition %d to %d. qp_type %d\n",\r\nibqp->qp_num, attr->max_rd_atomic, cur_state,\r\nnew_state, ibqp->qp_type);\r\ngoto out;\r\n}\r\nif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&\r\nattr->max_dest_rd_atomic > dev->dev->caps.max_qp_dest_rdma) {\r\npr_debug("qpn 0x%x: max_dest_rd_atomic (%d) too large. "\r\n"Transition %d to %d. qp_type %d\n",\r\nibqp->qp_num, attr->max_dest_rd_atomic, cur_state,\r\nnew_state, ibqp->qp_type);\r\ngoto out;\r\n}\r\nif (cur_state == new_state && cur_state == IB_QPS_RESET) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = __mlx4_ib_modify_qp(ibqp, attr, attr_mask, cur_state, new_state);\r\nout:\r\nmutex_unlock(&qp->mutex);\r\nreturn err;\r\n}\r\nstatic int build_sriov_qp0_header(struct mlx4_ib_sqp *sqp,\r\nstruct ib_send_wr *wr,\r\nvoid *wqe, unsigned *mlx_seg_len)\r\n{\r\nstruct mlx4_ib_dev *mdev = to_mdev(sqp->qp.ibqp.device);\r\nstruct ib_device *ib_dev = &mdev->ib_dev;\r\nstruct mlx4_wqe_mlx_seg *mlx = wqe;\r\nstruct mlx4_wqe_inline_seg *inl = wqe + sizeof *mlx;\r\nstruct mlx4_ib_ah *ah = to_mah(wr->wr.ud.ah);\r\nu16 pkey;\r\nu32 qkey;\r\nint send_size;\r\nint header_size;\r\nint spc;\r\nint i;\r\nif (wr->opcode != IB_WR_SEND)\r\nreturn -EINVAL;\r\nsend_size = 0;\r\nfor (i = 0; i < wr->num_sge; ++i)\r\nsend_size += wr->sg_list[i].length;\r\nif (sqp->qp.mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_SMI_OWNER)\r\nsend_size += sizeof (struct mlx4_ib_tunnel_header);\r\nib_ud_header_init(send_size, 1, 0, 0, 0, 0, &sqp->ud_header);\r\nif (sqp->qp.mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_SMI_OWNER) {\r\nsqp->ud_header.lrh.service_level =\r\nbe32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;\r\nsqp->ud_header.lrh.destination_lid =\r\ncpu_to_be16(ah->av.ib.g_slid & 0x7f);\r\nsqp->ud_header.lrh.source_lid =\r\ncpu_to_be16(ah->av.ib.g_slid & 0x7f);\r\n}\r\nmlx->flags &= cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE);\r\nmlx->flags |= cpu_to_be32(MLX4_WQE_MLX_VL15 | 0x1 | MLX4_WQE_MLX_SLR);\r\nmlx->rlid = sqp->ud_header.lrh.destination_lid;\r\nsqp->ud_header.lrh.virtual_lane = 0;\r\nsqp->ud_header.bth.solicited_event = !!(wr->send_flags & IB_SEND_SOLICITED);\r\nib_get_cached_pkey(ib_dev, sqp->qp.port, 0, &pkey);\r\nsqp->ud_header.bth.pkey = cpu_to_be16(pkey);\r\nif (sqp->qp.mlx4_ib_qp_type == MLX4_IB_QPT_TUN_SMI_OWNER)\r\nsqp->ud_header.bth.destination_qpn = cpu_to_be32(wr->wr.ud.remote_qpn);\r\nelse\r\nsqp->ud_header.bth.destination_qpn =\r\ncpu_to_be32(mdev->dev->caps.qp0_tunnel[sqp->qp.port - 1]);\r\nsqp->ud_header.bth.psn = cpu_to_be32((sqp->send_psn++) & ((1 << 24) - 1));\r\nif (mlx4_get_parav_qkey(mdev->dev, sqp->qp.mqp.qpn, &qkey))\r\nreturn -EINVAL;\r\nsqp->ud_header.deth.qkey = cpu_to_be32(qkey);\r\nsqp->ud_header.deth.source_qpn = cpu_to_be32(sqp->qp.mqp.qpn);\r\nsqp->ud_header.bth.opcode = IB_OPCODE_UD_SEND_ONLY;\r\nsqp->ud_header.immediate_present = 0;\r\nheader_size = ib_ud_header_pack(&sqp->ud_header, sqp->header_buf);\r\nspc = MLX4_INLINE_ALIGN -\r\n((unsigned long) (inl + 1) & (MLX4_INLINE_ALIGN - 1));\r\nif (header_size <= spc) {\r\ninl->byte_count = cpu_to_be32(1 << 31 | header_size);\r\nmemcpy(inl + 1, sqp->header_buf, header_size);\r\ni = 1;\r\n} else {\r\ninl->byte_count = cpu_to_be32(1 << 31 | spc);\r\nmemcpy(inl + 1, sqp->header_buf, spc);\r\ninl = (void *) (inl + 1) + spc;\r\nmemcpy(inl + 1, sqp->header_buf + spc, header_size - spc);\r\nwmb();\r\ninl->byte_count = cpu_to_be32(1 << 31 | (header_size - spc));\r\ni = 2;\r\n}\r\n*mlx_seg_len =\r\nALIGN(i * sizeof (struct mlx4_wqe_inline_seg) + header_size, 16);\r\nreturn 0;\r\n}\r\nstatic int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_send_wr *wr,\r\nvoid *wqe, unsigned *mlx_seg_len)\r\n{\r\nstruct ib_device *ib_dev = sqp->qp.ibqp.device;\r\nstruct mlx4_wqe_mlx_seg *mlx = wqe;\r\nstruct mlx4_wqe_inline_seg *inl = wqe + sizeof *mlx;\r\nstruct mlx4_ib_ah *ah = to_mah(wr->wr.ud.ah);\r\nstruct net_device *ndev;\r\nunion ib_gid sgid;\r\nu16 pkey;\r\nint send_size;\r\nint header_size;\r\nint spc;\r\nint i;\r\nint is_eth;\r\nint is_vlan = 0;\r\nint is_grh;\r\nu16 vlan;\r\nint err = 0;\r\nsend_size = 0;\r\nfor (i = 0; i < wr->num_sge; ++i)\r\nsend_size += wr->sg_list[i].length;\r\nis_eth = rdma_port_get_link_layer(sqp->qp.ibqp.device, sqp->qp.port) == IB_LINK_LAYER_ETHERNET;\r\nis_grh = mlx4_ib_ah_grh_present(ah);\r\nif (is_eth) {\r\nif (mlx4_is_mfunc(to_mdev(ib_dev)->dev)) {\r\nsgid.global.subnet_prefix =\r\nto_mdev(ib_dev)->sriov.demux[sqp->qp.port - 1].\r\nsubnet_prefix;\r\nsgid.global.interface_id =\r\nto_mdev(ib_dev)->sriov.demux[sqp->qp.port - 1].\r\nguid_cache[ah->av.ib.gid_index];\r\n} else {\r\nerr = ib_get_cached_gid(ib_dev,\r\nbe32_to_cpu(ah->av.ib.port_pd) >> 24,\r\nah->av.ib.gid_index, &sgid);\r\nif (err)\r\nreturn err;\r\n}\r\nvlan = rdma_get_vlan_id(&sgid);\r\nis_vlan = vlan < 0x1000;\r\n}\r\nib_ud_header_init(send_size, !is_eth, is_eth, is_vlan, is_grh, 0, &sqp->ud_header);\r\nif (!is_eth) {\r\nsqp->ud_header.lrh.service_level =\r\nbe32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;\r\nsqp->ud_header.lrh.destination_lid = ah->av.ib.dlid;\r\nsqp->ud_header.lrh.source_lid = cpu_to_be16(ah->av.ib.g_slid & 0x7f);\r\n}\r\nif (is_grh) {\r\nsqp->ud_header.grh.traffic_class =\r\n(be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 20) & 0xff;\r\nsqp->ud_header.grh.flow_label =\r\nah->av.ib.sl_tclass_flowlabel & cpu_to_be32(0xfffff);\r\nsqp->ud_header.grh.hop_limit = ah->av.ib.hop_limit;\r\nif (mlx4_is_mfunc(to_mdev(ib_dev)->dev)) {\r\nsqp->ud_header.grh.source_gid.global.subnet_prefix =\r\nto_mdev(ib_dev)->sriov.demux[sqp->qp.port - 1].\r\nsubnet_prefix;\r\nsqp->ud_header.grh.source_gid.global.interface_id =\r\nto_mdev(ib_dev)->sriov.demux[sqp->qp.port - 1].\r\nguid_cache[ah->av.ib.gid_index];\r\n} else\r\nib_get_cached_gid(ib_dev,\r\nbe32_to_cpu(ah->av.ib.port_pd) >> 24,\r\nah->av.ib.gid_index,\r\n&sqp->ud_header.grh.source_gid);\r\nmemcpy(sqp->ud_header.grh.destination_gid.raw,\r\nah->av.ib.dgid, 16);\r\n}\r\nmlx->flags &= cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE);\r\nif (!is_eth) {\r\nmlx->flags |= cpu_to_be32((!sqp->qp.ibqp.qp_num ? MLX4_WQE_MLX_VL15 : 0) |\r\n(sqp->ud_header.lrh.destination_lid ==\r\nIB_LID_PERMISSIVE ? MLX4_WQE_MLX_SLR : 0) |\r\n(sqp->ud_header.lrh.service_level << 8));\r\nif (ah->av.ib.port_pd & cpu_to_be32(0x80000000))\r\nmlx->flags |= cpu_to_be32(0x1);\r\nmlx->rlid = sqp->ud_header.lrh.destination_lid;\r\n}\r\nswitch (wr->opcode) {\r\ncase IB_WR_SEND:\r\nsqp->ud_header.bth.opcode = IB_OPCODE_UD_SEND_ONLY;\r\nsqp->ud_header.immediate_present = 0;\r\nbreak;\r\ncase IB_WR_SEND_WITH_IMM:\r\nsqp->ud_header.bth.opcode = IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE;\r\nsqp->ud_header.immediate_present = 1;\r\nsqp->ud_header.immediate_data = wr->ex.imm_data;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (is_eth) {\r\nu8 *smac;\r\nu16 pcp = (be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 29) << 13;\r\nmlx->sched_prio = cpu_to_be16(pcp);\r\nmemcpy(sqp->ud_header.eth.dmac_h, ah->av.eth.mac, 6);\r\nndev = to_mdev(sqp->qp.ibqp.device)->iboe.netdevs[sqp->qp.port - 1];\r\nif (!ndev)\r\nreturn -ENODEV;\r\nsmac = ndev->dev_addr;\r\nmemcpy(sqp->ud_header.eth.smac_h, smac, 6);\r\nif (!memcmp(sqp->ud_header.eth.smac_h, sqp->ud_header.eth.dmac_h, 6))\r\nmlx->flags |= cpu_to_be32(MLX4_WQE_CTRL_FORCE_LOOPBACK);\r\nif (!is_vlan) {\r\nsqp->ud_header.eth.type = cpu_to_be16(MLX4_IB_IBOE_ETHERTYPE);\r\n} else {\r\nsqp->ud_header.vlan.type = cpu_to_be16(MLX4_IB_IBOE_ETHERTYPE);\r\nsqp->ud_header.vlan.tag = cpu_to_be16(vlan | pcp);\r\n}\r\n} else {\r\nsqp->ud_header.lrh.virtual_lane = !sqp->qp.ibqp.qp_num ? 15 : 0;\r\nif (sqp->ud_header.lrh.destination_lid == IB_LID_PERMISSIVE)\r\nsqp->ud_header.lrh.source_lid = IB_LID_PERMISSIVE;\r\n}\r\nsqp->ud_header.bth.solicited_event = !!(wr->send_flags & IB_SEND_SOLICITED);\r\nif (!sqp->qp.ibqp.qp_num)\r\nib_get_cached_pkey(ib_dev, sqp->qp.port, sqp->pkey_index, &pkey);\r\nelse\r\nib_get_cached_pkey(ib_dev, sqp->qp.port, wr->wr.ud.pkey_index, &pkey);\r\nsqp->ud_header.bth.pkey = cpu_to_be16(pkey);\r\nsqp->ud_header.bth.destination_qpn = cpu_to_be32(wr->wr.ud.remote_qpn);\r\nsqp->ud_header.bth.psn = cpu_to_be32((sqp->send_psn++) & ((1 << 24) - 1));\r\nsqp->ud_header.deth.qkey = cpu_to_be32(wr->wr.ud.remote_qkey & 0x80000000 ?\r\nsqp->qkey : wr->wr.ud.remote_qkey);\r\nsqp->ud_header.deth.source_qpn = cpu_to_be32(sqp->qp.ibqp.qp_num);\r\nheader_size = ib_ud_header_pack(&sqp->ud_header, sqp->header_buf);\r\nif (0) {\r\npr_err("built UD header of size %d:\n", header_size);\r\nfor (i = 0; i < header_size / 4; ++i) {\r\nif (i % 8 == 0)\r\npr_err(" [%02x] ", i * 4);\r\npr_cont(" %08x",\r\nbe32_to_cpu(((__be32 *) sqp->header_buf)[i]));\r\nif ((i + 1) % 8 == 0)\r\npr_cont("\n");\r\n}\r\npr_err("\n");\r\n}\r\nspc = MLX4_INLINE_ALIGN -\r\n((unsigned long) (inl + 1) & (MLX4_INLINE_ALIGN - 1));\r\nif (header_size <= spc) {\r\ninl->byte_count = cpu_to_be32(1 << 31 | header_size);\r\nmemcpy(inl + 1, sqp->header_buf, header_size);\r\ni = 1;\r\n} else {\r\ninl->byte_count = cpu_to_be32(1 << 31 | spc);\r\nmemcpy(inl + 1, sqp->header_buf, spc);\r\ninl = (void *) (inl + 1) + spc;\r\nmemcpy(inl + 1, sqp->header_buf + spc, header_size - spc);\r\nwmb();\r\ninl->byte_count = cpu_to_be32(1 << 31 | (header_size - spc));\r\ni = 2;\r\n}\r\n*mlx_seg_len =\r\nALIGN(i * sizeof (struct mlx4_wqe_inline_seg) + header_size, 16);\r\nreturn 0;\r\n}\r\nstatic int mlx4_wq_overflow(struct mlx4_ib_wq *wq, int nreq, struct ib_cq *ib_cq)\r\n{\r\nunsigned cur;\r\nstruct mlx4_ib_cq *cq;\r\ncur = wq->head - wq->tail;\r\nif (likely(cur + nreq < wq->max_post))\r\nreturn 0;\r\ncq = to_mcq(ib_cq);\r\nspin_lock(&cq->lock);\r\ncur = wq->head - wq->tail;\r\nspin_unlock(&cq->lock);\r\nreturn cur + nreq >= wq->max_post;\r\n}\r\nstatic __be32 convert_access(int acc)\r\n{\r\nreturn (acc & IB_ACCESS_REMOTE_ATOMIC ? cpu_to_be32(MLX4_WQE_FMR_PERM_ATOMIC) : 0) |\r\n(acc & IB_ACCESS_REMOTE_WRITE ? cpu_to_be32(MLX4_WQE_FMR_PERM_REMOTE_WRITE) : 0) |\r\n(acc & IB_ACCESS_REMOTE_READ ? cpu_to_be32(MLX4_WQE_FMR_PERM_REMOTE_READ) : 0) |\r\n(acc & IB_ACCESS_LOCAL_WRITE ? cpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_WRITE) : 0) |\r\ncpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_READ);\r\n}\r\nstatic void set_fmr_seg(struct mlx4_wqe_fmr_seg *fseg, struct ib_send_wr *wr)\r\n{\r\nstruct mlx4_ib_fast_reg_page_list *mfrpl = to_mfrpl(wr->wr.fast_reg.page_list);\r\nint i;\r\nfor (i = 0; i < wr->wr.fast_reg.page_list_len; ++i)\r\nmfrpl->mapped_page_list[i] =\r\ncpu_to_be64(wr->wr.fast_reg.page_list->page_list[i] |\r\nMLX4_MTT_FLAG_PRESENT);\r\nfseg->flags = convert_access(wr->wr.fast_reg.access_flags);\r\nfseg->mem_key = cpu_to_be32(wr->wr.fast_reg.rkey);\r\nfseg->buf_list = cpu_to_be64(mfrpl->map);\r\nfseg->start_addr = cpu_to_be64(wr->wr.fast_reg.iova_start);\r\nfseg->reg_len = cpu_to_be64(wr->wr.fast_reg.length);\r\nfseg->offset = 0;\r\nfseg->page_size = cpu_to_be32(wr->wr.fast_reg.page_shift);\r\nfseg->reserved[0] = 0;\r\nfseg->reserved[1] = 0;\r\n}\r\nstatic void set_local_inv_seg(struct mlx4_wqe_local_inval_seg *iseg, u32 rkey)\r\n{\r\niseg->flags = 0;\r\niseg->mem_key = cpu_to_be32(rkey);\r\niseg->guest_id = 0;\r\niseg->pa = 0;\r\n}\r\nstatic __always_inline void set_raddr_seg(struct mlx4_wqe_raddr_seg *rseg,\r\nu64 remote_addr, u32 rkey)\r\n{\r\nrseg->raddr = cpu_to_be64(remote_addr);\r\nrseg->rkey = cpu_to_be32(rkey);\r\nrseg->reserved = 0;\r\n}\r\nstatic void set_atomic_seg(struct mlx4_wqe_atomic_seg *aseg, struct ib_send_wr *wr)\r\n{\r\nif (wr->opcode == IB_WR_ATOMIC_CMP_AND_SWP) {\r\naseg->swap_add = cpu_to_be64(wr->wr.atomic.swap);\r\naseg->compare = cpu_to_be64(wr->wr.atomic.compare_add);\r\n} else if (wr->opcode == IB_WR_MASKED_ATOMIC_FETCH_AND_ADD) {\r\naseg->swap_add = cpu_to_be64(wr->wr.atomic.compare_add);\r\naseg->compare = cpu_to_be64(wr->wr.atomic.compare_add_mask);\r\n} else {\r\naseg->swap_add = cpu_to_be64(wr->wr.atomic.compare_add);\r\naseg->compare = 0;\r\n}\r\n}\r\nstatic void set_masked_atomic_seg(struct mlx4_wqe_masked_atomic_seg *aseg,\r\nstruct ib_send_wr *wr)\r\n{\r\naseg->swap_add = cpu_to_be64(wr->wr.atomic.swap);\r\naseg->swap_add_mask = cpu_to_be64(wr->wr.atomic.swap_mask);\r\naseg->compare = cpu_to_be64(wr->wr.atomic.compare_add);\r\naseg->compare_mask = cpu_to_be64(wr->wr.atomic.compare_add_mask);\r\n}\r\nstatic void set_datagram_seg(struct mlx4_wqe_datagram_seg *dseg,\r\nstruct ib_send_wr *wr)\r\n{\r\nmemcpy(dseg->av, &to_mah(wr->wr.ud.ah)->av, sizeof (struct mlx4_av));\r\ndseg->dqpn = cpu_to_be32(wr->wr.ud.remote_qpn);\r\ndseg->qkey = cpu_to_be32(wr->wr.ud.remote_qkey);\r\ndseg->vlan = to_mah(wr->wr.ud.ah)->av.eth.vlan;\r\nmemcpy(dseg->mac, to_mah(wr->wr.ud.ah)->av.eth.mac, 6);\r\n}\r\nstatic void set_tunnel_datagram_seg(struct mlx4_ib_dev *dev,\r\nstruct mlx4_wqe_datagram_seg *dseg,\r\nstruct ib_send_wr *wr, enum ib_qp_type qpt)\r\n{\r\nunion mlx4_ext_av *av = &to_mah(wr->wr.ud.ah)->av;\r\nstruct mlx4_av sqp_av = {0};\r\nint port = *((u8 *) &av->ib.port_pd) & 0x3;\r\nsqp_av.port_pd = av->ib.port_pd | cpu_to_be32(0x80000000);\r\nsqp_av.g_slid = av->ib.g_slid & 0x7f;\r\nsqp_av.sl_tclass_flowlabel = av->ib.sl_tclass_flowlabel &\r\ncpu_to_be32(0xf0000000);\r\nmemcpy(dseg->av, &sqp_av, sizeof (struct mlx4_av));\r\ndseg->dqpn = cpu_to_be32(dev->dev->caps.qp1_tunnel[port - 1]);\r\ndseg->qkey = cpu_to_be32(IB_QP_SET_QKEY);\r\n}\r\nstatic void build_tunnel_header(struct ib_send_wr *wr, void *wqe, unsigned *mlx_seg_len)\r\n{\r\nstruct mlx4_wqe_inline_seg *inl = wqe;\r\nstruct mlx4_ib_tunnel_header hdr;\r\nstruct mlx4_ib_ah *ah = to_mah(wr->wr.ud.ah);\r\nint spc;\r\nint i;\r\nmemcpy(&hdr.av, &ah->av, sizeof hdr.av);\r\nhdr.remote_qpn = cpu_to_be32(wr->wr.ud.remote_qpn);\r\nhdr.pkey_index = cpu_to_be16(wr->wr.ud.pkey_index);\r\nhdr.qkey = cpu_to_be32(wr->wr.ud.remote_qkey);\r\nspc = MLX4_INLINE_ALIGN -\r\n((unsigned long) (inl + 1) & (MLX4_INLINE_ALIGN - 1));\r\nif (sizeof (hdr) <= spc) {\r\nmemcpy(inl + 1, &hdr, sizeof (hdr));\r\nwmb();\r\ninl->byte_count = cpu_to_be32(1 << 31 | sizeof (hdr));\r\ni = 1;\r\n} else {\r\nmemcpy(inl + 1, &hdr, spc);\r\nwmb();\r\ninl->byte_count = cpu_to_be32(1 << 31 | spc);\r\ninl = (void *) (inl + 1) + spc;\r\nmemcpy(inl + 1, (void *) &hdr + spc, sizeof (hdr) - spc);\r\nwmb();\r\ninl->byte_count = cpu_to_be32(1 << 31 | (sizeof (hdr) - spc));\r\ni = 2;\r\n}\r\n*mlx_seg_len =\r\nALIGN(i * sizeof (struct mlx4_wqe_inline_seg) + sizeof (hdr), 16);\r\n}\r\nstatic void set_mlx_icrc_seg(void *dseg)\r\n{\r\nu32 *t = dseg;\r\nstruct mlx4_wqe_inline_seg *iseg = dseg;\r\nt[1] = 0;\r\nwmb();\r\niseg->byte_count = cpu_to_be32((1 << 31) | 4);\r\n}\r\nstatic void set_data_seg(struct mlx4_wqe_data_seg *dseg, struct ib_sge *sg)\r\n{\r\ndseg->lkey = cpu_to_be32(sg->lkey);\r\ndseg->addr = cpu_to_be64(sg->addr);\r\nwmb();\r\ndseg->byte_count = cpu_to_be32(sg->length);\r\n}\r\nstatic void __set_data_seg(struct mlx4_wqe_data_seg *dseg, struct ib_sge *sg)\r\n{\r\ndseg->byte_count = cpu_to_be32(sg->length);\r\ndseg->lkey = cpu_to_be32(sg->lkey);\r\ndseg->addr = cpu_to_be64(sg->addr);\r\n}\r\nstatic int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,\r\nstruct mlx4_ib_qp *qp, unsigned *lso_seg_len,\r\n__be32 *lso_hdr_sz, __be32 *blh)\r\n{\r\nunsigned halign = ALIGN(sizeof *wqe + wr->wr.ud.hlen, 16);\r\nif (unlikely(halign > MLX4_IB_CACHE_LINE_SIZE))\r\n*blh = cpu_to_be32(1 << 6);\r\nif (unlikely(!(qp->flags & MLX4_IB_QP_LSO) &&\r\nwr->num_sge > qp->sq.max_gs - (halign >> 4)))\r\nreturn -EINVAL;\r\nmemcpy(wqe->header, wr->wr.ud.header, wr->wr.ud.hlen);\r\n*lso_hdr_sz = cpu_to_be32((wr->wr.ud.mss - wr->wr.ud.hlen) << 16 |\r\nwr->wr.ud.hlen);\r\n*lso_seg_len = halign;\r\nreturn 0;\r\n}\r\nstatic __be32 send_ieth(struct ib_send_wr *wr)\r\n{\r\nswitch (wr->opcode) {\r\ncase IB_WR_SEND_WITH_IMM:\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nreturn wr->ex.imm_data;\r\ncase IB_WR_SEND_WITH_INV:\r\nreturn cpu_to_be32(wr->ex.invalidate_rkey);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void add_zero_len_inline(void *wqe)\r\n{\r\nstruct mlx4_wqe_inline_seg *inl = wqe;\r\nmemset(wqe, 0, 16);\r\ninl->byte_count = cpu_to_be32(1 << 31);\r\n}\r\nint mlx4_ib_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,\r\nstruct ib_send_wr **bad_wr)\r\n{\r\nstruct mlx4_ib_qp *qp = to_mqp(ibqp);\r\nvoid *wqe;\r\nstruct mlx4_wqe_ctrl_seg *ctrl;\r\nstruct mlx4_wqe_data_seg *dseg;\r\nunsigned long flags;\r\nint nreq;\r\nint err = 0;\r\nunsigned ind;\r\nint uninitialized_var(stamp);\r\nint uninitialized_var(size);\r\nunsigned uninitialized_var(seglen);\r\n__be32 dummy;\r\n__be32 *lso_wqe;\r\n__be32 uninitialized_var(lso_hdr_sz);\r\n__be32 blh;\r\nint i;\r\nspin_lock_irqsave(&qp->sq.lock, flags);\r\nind = qp->sq_next_wqe;\r\nfor (nreq = 0; wr; ++nreq, wr = wr->next) {\r\nlso_wqe = &dummy;\r\nblh = 0;\r\nif (mlx4_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)) {\r\nerr = -ENOMEM;\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nif (unlikely(wr->num_sge > qp->sq.max_gs)) {\r\nerr = -EINVAL;\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nctrl = wqe = get_send_wqe(qp, ind & (qp->sq.wqe_cnt - 1));\r\nqp->sq.wrid[(qp->sq.head + nreq) & (qp->sq.wqe_cnt - 1)] = wr->wr_id;\r\nctrl->srcrb_flags =\r\n(wr->send_flags & IB_SEND_SIGNALED ?\r\ncpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE) : 0) |\r\n(wr->send_flags & IB_SEND_SOLICITED ?\r\ncpu_to_be32(MLX4_WQE_CTRL_SOLICITED) : 0) |\r\n((wr->send_flags & IB_SEND_IP_CSUM) ?\r\ncpu_to_be32(MLX4_WQE_CTRL_IP_CSUM |\r\nMLX4_WQE_CTRL_TCP_UDP_CSUM) : 0) |\r\nqp->sq_signal_bits;\r\nctrl->imm = send_ieth(wr);\r\nwqe += sizeof *ctrl;\r\nsize = sizeof *ctrl / 16;\r\nswitch (qp->mlx4_ib_qp_type) {\r\ncase MLX4_IB_QPT_RC:\r\ncase MLX4_IB_QPT_UC:\r\nswitch (wr->opcode) {\r\ncase IB_WR_ATOMIC_CMP_AND_SWP:\r\ncase IB_WR_ATOMIC_FETCH_AND_ADD:\r\ncase IB_WR_MASKED_ATOMIC_FETCH_AND_ADD:\r\nset_raddr_seg(wqe, wr->wr.atomic.remote_addr,\r\nwr->wr.atomic.rkey);\r\nwqe += sizeof (struct mlx4_wqe_raddr_seg);\r\nset_atomic_seg(wqe, wr);\r\nwqe += sizeof (struct mlx4_wqe_atomic_seg);\r\nsize += (sizeof (struct mlx4_wqe_raddr_seg) +\r\nsizeof (struct mlx4_wqe_atomic_seg)) / 16;\r\nbreak;\r\ncase IB_WR_MASKED_ATOMIC_CMP_AND_SWP:\r\nset_raddr_seg(wqe, wr->wr.atomic.remote_addr,\r\nwr->wr.atomic.rkey);\r\nwqe += sizeof (struct mlx4_wqe_raddr_seg);\r\nset_masked_atomic_seg(wqe, wr);\r\nwqe += sizeof (struct mlx4_wqe_masked_atomic_seg);\r\nsize += (sizeof (struct mlx4_wqe_raddr_seg) +\r\nsizeof (struct mlx4_wqe_masked_atomic_seg)) / 16;\r\nbreak;\r\ncase IB_WR_RDMA_READ:\r\ncase IB_WR_RDMA_WRITE:\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nset_raddr_seg(wqe, wr->wr.rdma.remote_addr,\r\nwr->wr.rdma.rkey);\r\nwqe += sizeof (struct mlx4_wqe_raddr_seg);\r\nsize += sizeof (struct mlx4_wqe_raddr_seg) / 16;\r\nbreak;\r\ncase IB_WR_LOCAL_INV:\r\nctrl->srcrb_flags |=\r\ncpu_to_be32(MLX4_WQE_CTRL_STRONG_ORDER);\r\nset_local_inv_seg(wqe, wr->ex.invalidate_rkey);\r\nwqe += sizeof (struct mlx4_wqe_local_inval_seg);\r\nsize += sizeof (struct mlx4_wqe_local_inval_seg) / 16;\r\nbreak;\r\ncase IB_WR_FAST_REG_MR:\r\nctrl->srcrb_flags |=\r\ncpu_to_be32(MLX4_WQE_CTRL_STRONG_ORDER);\r\nset_fmr_seg(wqe, wr);\r\nwqe += sizeof (struct mlx4_wqe_fmr_seg);\r\nsize += sizeof (struct mlx4_wqe_fmr_seg) / 16;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase MLX4_IB_QPT_TUN_SMI_OWNER:\r\nerr = build_sriov_qp0_header(to_msqp(qp), wr, ctrl, &seglen);\r\nif (unlikely(err)) {\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nwqe += seglen;\r\nsize += seglen / 16;\r\nbreak;\r\ncase MLX4_IB_QPT_TUN_SMI:\r\ncase MLX4_IB_QPT_TUN_GSI:\r\nset_datagram_seg(wqe, wr);\r\n*(__be32 *) wqe |= cpu_to_be32(0x80000000);\r\nwqe += sizeof (struct mlx4_wqe_datagram_seg);\r\nsize += sizeof (struct mlx4_wqe_datagram_seg) / 16;\r\nbreak;\r\ncase MLX4_IB_QPT_UD:\r\nset_datagram_seg(wqe, wr);\r\nwqe += sizeof (struct mlx4_wqe_datagram_seg);\r\nsize += sizeof (struct mlx4_wqe_datagram_seg) / 16;\r\nif (wr->opcode == IB_WR_LSO) {\r\nerr = build_lso_seg(wqe, wr, qp, &seglen, &lso_hdr_sz, &blh);\r\nif (unlikely(err)) {\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nlso_wqe = (__be32 *) wqe;\r\nwqe += seglen;\r\nsize += seglen / 16;\r\n}\r\nbreak;\r\ncase MLX4_IB_QPT_PROXY_SMI_OWNER:\r\nif (unlikely(!mlx4_is_master(to_mdev(ibqp->device)->dev))) {\r\nerr = -ENOSYS;\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nerr = build_sriov_qp0_header(to_msqp(qp), wr, ctrl, &seglen);\r\nif (unlikely(err)) {\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nwqe += seglen;\r\nsize += seglen / 16;\r\nadd_zero_len_inline(wqe);\r\nwqe += 16;\r\nsize++;\r\nbuild_tunnel_header(wr, wqe, &seglen);\r\nwqe += seglen;\r\nsize += seglen / 16;\r\nbreak;\r\ncase MLX4_IB_QPT_PROXY_SMI:\r\nerr = -ENOSYS;\r\n*bad_wr = wr;\r\ngoto out;\r\ncase MLX4_IB_QPT_PROXY_GSI:\r\nset_tunnel_datagram_seg(to_mdev(ibqp->device), wqe, wr, ibqp->qp_type);\r\nwqe += sizeof (struct mlx4_wqe_datagram_seg);\r\nsize += sizeof (struct mlx4_wqe_datagram_seg) / 16;\r\nbuild_tunnel_header(wr, wqe, &seglen);\r\nwqe += seglen;\r\nsize += seglen / 16;\r\nbreak;\r\ncase MLX4_IB_QPT_SMI:\r\ncase MLX4_IB_QPT_GSI:\r\nerr = build_mlx_header(to_msqp(qp), wr, ctrl, &seglen);\r\nif (unlikely(err)) {\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nwqe += seglen;\r\nsize += seglen / 16;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndseg = wqe;\r\ndseg += wr->num_sge - 1;\r\nsize += wr->num_sge * (sizeof (struct mlx4_wqe_data_seg) / 16);\r\nif (unlikely(qp->mlx4_ib_qp_type == MLX4_IB_QPT_SMI ||\r\nqp->mlx4_ib_qp_type == MLX4_IB_QPT_GSI ||\r\nqp->mlx4_ib_qp_type &\r\n(MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER))) {\r\nset_mlx_icrc_seg(dseg + 1);\r\nsize += sizeof (struct mlx4_wqe_data_seg) / 16;\r\n}\r\nfor (i = wr->num_sge - 1; i >= 0; --i, --dseg)\r\nset_data_seg(dseg, wr->sg_list + i);\r\nwmb();\r\n*lso_wqe = lso_hdr_sz;\r\nctrl->fence_size = (wr->send_flags & IB_SEND_FENCE ?\r\nMLX4_WQE_CTRL_FENCE : 0) | size;\r\nwmb();\r\nif (wr->opcode < 0 || wr->opcode >= ARRAY_SIZE(mlx4_ib_opcode)) {\r\n*bad_wr = wr;\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nctrl->owner_opcode = mlx4_ib_opcode[wr->opcode] |\r\n(ind & qp->sq.wqe_cnt ? cpu_to_be32(1 << 31) : 0) | blh;\r\nstamp = ind + qp->sq_spare_wqes;\r\nind += DIV_ROUND_UP(size * 16, 1U << qp->sq.wqe_shift);\r\nif (wr->next) {\r\nstamp_send_wqe(qp, stamp, size * 16);\r\nind = pad_wraparound(qp, ind);\r\n}\r\n}\r\nout:\r\nif (likely(nreq)) {\r\nqp->sq.head += nreq;\r\nwmb();\r\nwritel(qp->doorbell_qpn,\r\nto_mdev(ibqp->device)->uar_map + MLX4_SEND_DOORBELL);\r\nmmiowb();\r\nstamp_send_wqe(qp, stamp, size * 16);\r\nind = pad_wraparound(qp, ind);\r\nqp->sq_next_wqe = ind;\r\n}\r\nspin_unlock_irqrestore(&qp->sq.lock, flags);\r\nreturn err;\r\n}\r\nint mlx4_ib_post_recv(struct ib_qp *ibqp, struct ib_recv_wr *wr,\r\nstruct ib_recv_wr **bad_wr)\r\n{\r\nstruct mlx4_ib_qp *qp = to_mqp(ibqp);\r\nstruct mlx4_wqe_data_seg *scat;\r\nunsigned long flags;\r\nint err = 0;\r\nint nreq;\r\nint ind;\r\nint max_gs;\r\nint i;\r\nmax_gs = qp->rq.max_gs;\r\nspin_lock_irqsave(&qp->rq.lock, flags);\r\nind = qp->rq.head & (qp->rq.wqe_cnt - 1);\r\nfor (nreq = 0; wr; ++nreq, wr = wr->next) {\r\nif (mlx4_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {\r\nerr = -ENOMEM;\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nif (unlikely(wr->num_sge > qp->rq.max_gs)) {\r\nerr = -EINVAL;\r\n*bad_wr = wr;\r\ngoto out;\r\n}\r\nscat = get_recv_wqe(qp, ind);\r\nif (qp->mlx4_ib_qp_type & (MLX4_IB_QPT_PROXY_SMI_OWNER |\r\nMLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_GSI)) {\r\nib_dma_sync_single_for_device(ibqp->device,\r\nqp->sqp_proxy_rcv[ind].map,\r\nsizeof (struct mlx4_ib_proxy_sqp_hdr),\r\nDMA_FROM_DEVICE);\r\nscat->byte_count =\r\ncpu_to_be32(sizeof (struct mlx4_ib_proxy_sqp_hdr));\r\nscat->lkey = cpu_to_be32(wr->sg_list->lkey);\r\nscat->addr = cpu_to_be64(qp->sqp_proxy_rcv[ind].map);\r\nscat++;\r\nmax_gs--;\r\n}\r\nfor (i = 0; i < wr->num_sge; ++i)\r\n__set_data_seg(scat + i, wr->sg_list + i);\r\nif (i < max_gs) {\r\nscat[i].byte_count = 0;\r\nscat[i].lkey = cpu_to_be32(MLX4_INVALID_LKEY);\r\nscat[i].addr = 0;\r\n}\r\nqp->rq.wrid[ind] = wr->wr_id;\r\nind = (ind + 1) & (qp->rq.wqe_cnt - 1);\r\n}\r\nout:\r\nif (likely(nreq)) {\r\nqp->rq.head += nreq;\r\nwmb();\r\n*qp->db.db = cpu_to_be32(qp->rq.head & 0xffff);\r\n}\r\nspin_unlock_irqrestore(&qp->rq.lock, flags);\r\nreturn err;\r\n}\r\nstatic inline enum ib_qp_state to_ib_qp_state(enum mlx4_qp_state mlx4_state)\r\n{\r\nswitch (mlx4_state) {\r\ncase MLX4_QP_STATE_RST: return IB_QPS_RESET;\r\ncase MLX4_QP_STATE_INIT: return IB_QPS_INIT;\r\ncase MLX4_QP_STATE_RTR: return IB_QPS_RTR;\r\ncase MLX4_QP_STATE_RTS: return IB_QPS_RTS;\r\ncase MLX4_QP_STATE_SQ_DRAINING:\r\ncase MLX4_QP_STATE_SQD: return IB_QPS_SQD;\r\ncase MLX4_QP_STATE_SQER: return IB_QPS_SQE;\r\ncase MLX4_QP_STATE_ERR: return IB_QPS_ERR;\r\ndefault: return -1;\r\n}\r\n}\r\nstatic inline enum ib_mig_state to_ib_mig_state(int mlx4_mig_state)\r\n{\r\nswitch (mlx4_mig_state) {\r\ncase MLX4_QP_PM_ARMED: return IB_MIG_ARMED;\r\ncase MLX4_QP_PM_REARM: return IB_MIG_REARM;\r\ncase MLX4_QP_PM_MIGRATED: return IB_MIG_MIGRATED;\r\ndefault: return -1;\r\n}\r\n}\r\nstatic int to_ib_qp_access_flags(int mlx4_flags)\r\n{\r\nint ib_flags = 0;\r\nif (mlx4_flags & MLX4_QP_BIT_RRE)\r\nib_flags |= IB_ACCESS_REMOTE_READ;\r\nif (mlx4_flags & MLX4_QP_BIT_RWE)\r\nib_flags |= IB_ACCESS_REMOTE_WRITE;\r\nif (mlx4_flags & MLX4_QP_BIT_RAE)\r\nib_flags |= IB_ACCESS_REMOTE_ATOMIC;\r\nreturn ib_flags;\r\n}\r\nstatic void to_ib_ah_attr(struct mlx4_ib_dev *ibdev, struct ib_ah_attr *ib_ah_attr,\r\nstruct mlx4_qp_path *path)\r\n{\r\nstruct mlx4_dev *dev = ibdev->dev;\r\nint is_eth;\r\nmemset(ib_ah_attr, 0, sizeof *ib_ah_attr);\r\nib_ah_attr->port_num = path->sched_queue & 0x40 ? 2 : 1;\r\nif (ib_ah_attr->port_num == 0 || ib_ah_attr->port_num > dev->caps.num_ports)\r\nreturn;\r\nis_eth = rdma_port_get_link_layer(&ibdev->ib_dev, ib_ah_attr->port_num) ==\r\nIB_LINK_LAYER_ETHERNET;\r\nif (is_eth)\r\nib_ah_attr->sl = ((path->sched_queue >> 3) & 0x7) |\r\n((path->sched_queue & 4) << 1);\r\nelse\r\nib_ah_attr->sl = (path->sched_queue >> 2) & 0xf;\r\nib_ah_attr->dlid = be16_to_cpu(path->rlid);\r\nib_ah_attr->src_path_bits = path->grh_mylmc & 0x7f;\r\nib_ah_attr->static_rate = path->static_rate ? path->static_rate - 5 : 0;\r\nib_ah_attr->ah_flags = (path->grh_mylmc & (1 << 7)) ? IB_AH_GRH : 0;\r\nif (ib_ah_attr->ah_flags) {\r\nib_ah_attr->grh.sgid_index = path->mgid_index;\r\nib_ah_attr->grh.hop_limit = path->hop_limit;\r\nib_ah_attr->grh.traffic_class =\r\n(be32_to_cpu(path->tclass_flowlabel) >> 20) & 0xff;\r\nib_ah_attr->grh.flow_label =\r\nbe32_to_cpu(path->tclass_flowlabel) & 0xfffff;\r\nmemcpy(ib_ah_attr->grh.dgid.raw,\r\npath->rgid, sizeof ib_ah_attr->grh.dgid.raw);\r\n}\r\n}\r\nint mlx4_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr, int qp_attr_mask,\r\nstruct ib_qp_init_attr *qp_init_attr)\r\n{\r\nstruct mlx4_ib_dev *dev = to_mdev(ibqp->device);\r\nstruct mlx4_ib_qp *qp = to_mqp(ibqp);\r\nstruct mlx4_qp_context context;\r\nint mlx4_state;\r\nint err = 0;\r\nmutex_lock(&qp->mutex);\r\nif (qp->state == IB_QPS_RESET) {\r\nqp_attr->qp_state = IB_QPS_RESET;\r\ngoto done;\r\n}\r\nerr = mlx4_qp_query(dev->dev, &qp->mqp, &context);\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmlx4_state = be32_to_cpu(context.flags) >> 28;\r\nqp->state = to_ib_qp_state(mlx4_state);\r\nqp_attr->qp_state = qp->state;\r\nqp_attr->path_mtu = context.mtu_msgmax >> 5;\r\nqp_attr->path_mig_state =\r\nto_ib_mig_state((be32_to_cpu(context.flags) >> 11) & 0x3);\r\nqp_attr->qkey = be32_to_cpu(context.qkey);\r\nqp_attr->rq_psn = be32_to_cpu(context.rnr_nextrecvpsn) & 0xffffff;\r\nqp_attr->sq_psn = be32_to_cpu(context.next_send_psn) & 0xffffff;\r\nqp_attr->dest_qp_num = be32_to_cpu(context.remote_qpn) & 0xffffff;\r\nqp_attr->qp_access_flags =\r\nto_ib_qp_access_flags(be32_to_cpu(context.params2));\r\nif (qp->ibqp.qp_type == IB_QPT_RC || qp->ibqp.qp_type == IB_QPT_UC) {\r\nto_ib_ah_attr(dev, &qp_attr->ah_attr, &context.pri_path);\r\nto_ib_ah_attr(dev, &qp_attr->alt_ah_attr, &context.alt_path);\r\nqp_attr->alt_pkey_index = context.alt_path.pkey_index & 0x7f;\r\nqp_attr->alt_port_num = qp_attr->alt_ah_attr.port_num;\r\n}\r\nqp_attr->pkey_index = context.pri_path.pkey_index & 0x7f;\r\nif (qp_attr->qp_state == IB_QPS_INIT)\r\nqp_attr->port_num = qp->port;\r\nelse\r\nqp_attr->port_num = context.pri_path.sched_queue & 0x40 ? 2 : 1;\r\nqp_attr->sq_draining = mlx4_state == MLX4_QP_STATE_SQ_DRAINING;\r\nqp_attr->max_rd_atomic = 1 << ((be32_to_cpu(context.params1) >> 21) & 0x7);\r\nqp_attr->max_dest_rd_atomic =\r\n1 << ((be32_to_cpu(context.params2) >> 21) & 0x7);\r\nqp_attr->min_rnr_timer =\r\n(be32_to_cpu(context.rnr_nextrecvpsn) >> 24) & 0x1f;\r\nqp_attr->timeout = context.pri_path.ackto >> 3;\r\nqp_attr->retry_cnt = (be32_to_cpu(context.params1) >> 16) & 0x7;\r\nqp_attr->rnr_retry = (be32_to_cpu(context.params1) >> 13) & 0x7;\r\nqp_attr->alt_timeout = context.alt_path.ackto >> 3;\r\ndone:\r\nqp_attr->cur_qp_state = qp_attr->qp_state;\r\nqp_attr->cap.max_recv_wr = qp->rq.wqe_cnt;\r\nqp_attr->cap.max_recv_sge = qp->rq.max_gs;\r\nif (!ibqp->uobject) {\r\nqp_attr->cap.max_send_wr = qp->sq.wqe_cnt;\r\nqp_attr->cap.max_send_sge = qp->sq.max_gs;\r\n} else {\r\nqp_attr->cap.max_send_wr = 0;\r\nqp_attr->cap.max_send_sge = 0;\r\n}\r\nqp_attr->cap.max_inline_data = 0;\r\nqp_init_attr->cap = qp_attr->cap;\r\nqp_init_attr->create_flags = 0;\r\nif (qp->flags & MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK)\r\nqp_init_attr->create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\r\nif (qp->flags & MLX4_IB_QP_LSO)\r\nqp_init_attr->create_flags |= IB_QP_CREATE_IPOIB_UD_LSO;\r\nqp_init_attr->sq_sig_type =\r\nqp->sq_signal_bits == cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE) ?\r\nIB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\r\nout:\r\nmutex_unlock(&qp->mutex);\r\nreturn err;\r\n}
