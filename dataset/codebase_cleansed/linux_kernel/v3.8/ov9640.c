static int ov9640_reg_read(struct i2c_client *client, u8 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 data = reg;\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &data,\r\n};\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\nmsg.flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\n*val = data;\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "Failed reading register 0x%02x!\n", reg);\r\nreturn ret;\r\n}\r\nstatic int ov9640_reg_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret;\r\nu8 _val;\r\nunsigned char data[2] = { reg, val };\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = data,\r\n};\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed writing register 0x%02x!\n", reg);\r\nreturn ret;\r\n}\r\nret = ov9640_reg_read(client, reg, &_val);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"Failed reading back register 0x%02x!\n", reg);\r\nreturn 0;\r\n}\r\nstatic int ov9640_reg_rmw(struct i2c_client *client, u8 reg, u8 set, u8 unset)\r\n{\r\nu8 val;\r\nint ret;\r\nret = ov9640_reg_read(client, reg, &val);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"[Read]-Modify-Write of register %02x failed!\n", reg);\r\nreturn val;\r\n}\r\nval |= set;\r\nval &= ~unset;\r\nret = ov9640_reg_write(client, reg, val);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"Read-Modify-[Write] of register %02x failed!\n", reg);\r\nreturn ret;\r\n}\r\nstatic int ov9640_reset(struct i2c_client *client)\r\n{\r\nint ret;\r\nret = ov9640_reg_write(client, OV9640_COM7, OV9640_COM7_SCCB_RESET);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"An error occurred while entering soft reset!\n");\r\nreturn ret;\r\n}\r\nstatic int ov9640_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ov9640_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov9640_priv *priv = container_of(ctrl->handler, struct ov9640_priv, hdl);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\nreturn ov9640_reg_rmw(client, OV9640_MVFP,\r\nOV9640_MVFP_V, 0);\r\nreturn ov9640_reg_rmw(client, OV9640_MVFP, 0, OV9640_MVFP_V);\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\nreturn ov9640_reg_rmw(client, OV9640_MVFP,\r\nOV9640_MVFP_H, 0);\r\nreturn ov9640_reg_rmw(client, OV9640_MVFP, 0, OV9640_MVFP_H);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov9640_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct ov9640_priv *priv = to_ov9640_sensor(sd);\r\nid->ident = priv->model;\r\nid->revision = priv->revision;\r\nreturn 0;\r\n}\r\nstatic int ov9640_get_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nu8 val;\r\nif (reg->reg & ~0xff)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nret = ov9640_reg_read(client, reg->reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreg->val = (__u64)val;\r\nreturn 0;\r\n}\r\nstatic int ov9640_set_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg & ~0xff || reg->val & ~0xff)\r\nreturn -EINVAL;\r\nreturn ov9640_reg_write(client, reg->reg, reg->val);\r\n}\r\nstatic int ov9640_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nreturn soc_camera_set_power(&client->dev, icl, on);\r\n}\r\nstatic void ov9640_res_roundup(u32 *width, u32 *height)\r\n{\r\nint i;\r\nenum { QQCIF, QQVGA, QCIF, QVGA, CIF, VGA, SXGA };\r\nint res_x[] = { 88, 160, 176, 320, 352, 640, 1280 };\r\nint res_y[] = { 72, 120, 144, 240, 288, 480, 960 };\r\nfor (i = 0; i < ARRAY_SIZE(res_x); i++) {\r\nif (res_x[i] >= *width && res_y[i] >= *height) {\r\n*width = res_x[i];\r\n*height = res_y[i];\r\nreturn;\r\n}\r\n}\r\n*width = res_x[SXGA];\r\n*height = res_y[SXGA];\r\n}\r\nstatic void ov9640_alter_regs(enum v4l2_mbus_pixelcode code,\r\nstruct ov9640_reg_alt *alt)\r\n{\r\nswitch (code) {\r\ndefault:\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nalt->com12 = OV9640_COM12_YUV_AVG;\r\nalt->com13 = OV9640_COM13_Y_DELAY_EN |\r\nOV9640_COM13_YUV_DLY(0x01);\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE:\r\nalt->com7 = OV9640_COM7_RGB;\r\nalt->com13 = OV9640_COM13_RGB_AVG;\r\nalt->com15 = OV9640_COM15_RGB_555;\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nalt->com7 = OV9640_COM7_RGB;\r\nalt->com13 = OV9640_COM13_RGB_AVG;\r\nalt->com15 = OV9640_COM15_RGB_565;\r\nbreak;\r\n};\r\n}\r\nstatic int ov9640_write_regs(struct i2c_client *client, u32 width,\r\nenum v4l2_mbus_pixelcode code, struct ov9640_reg_alt *alts)\r\n{\r\nconst struct ov9640_reg *ov9640_regs, *matrix_regs;\r\nint ov9640_regs_len, matrix_regs_len;\r\nint i, ret;\r\nu8 val;\r\nswitch (width) {\r\ncase W_QQCIF:\r\nov9640_regs = ov9640_regs_qqcif;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_qqcif);\r\nbreak;\r\ncase W_QQVGA:\r\nov9640_regs = ov9640_regs_qqvga;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_qqvga);\r\nbreak;\r\ncase W_QCIF:\r\nov9640_regs = ov9640_regs_qcif;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_qcif);\r\nbreak;\r\ncase W_QVGA:\r\nov9640_regs = ov9640_regs_qvga;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_qvga);\r\nbreak;\r\ncase W_CIF:\r\nov9640_regs = ov9640_regs_cif;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_cif);\r\nbreak;\r\ncase W_VGA:\r\nov9640_regs = ov9640_regs_vga;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_vga);\r\nbreak;\r\ncase W_SXGA:\r\nov9640_regs = ov9640_regs_sxga;\r\nov9640_regs_len = ARRAY_SIZE(ov9640_regs_sxga);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Failed to select resolution!\n");\r\nreturn -EINVAL;\r\n}\r\nif (code == V4L2_MBUS_FMT_UYVY8_2X8) {\r\nmatrix_regs = ov9640_regs_yuv;\r\nmatrix_regs_len = ARRAY_SIZE(ov9640_regs_yuv);\r\n} else {\r\nmatrix_regs = ov9640_regs_rgb;\r\nmatrix_regs_len = ARRAY_SIZE(ov9640_regs_rgb);\r\n}\r\nfor (i = 0; i < ov9640_regs_len; i++) {\r\nval = ov9640_regs[i].val;\r\nswitch (ov9640_regs[i].reg) {\r\ncase OV9640_COM7:\r\nval |= alts->com7;\r\nbreak;\r\ncase OV9640_COM12:\r\nval |= alts->com12;\r\nbreak;\r\ncase OV9640_COM13:\r\nval |= alts->com13;\r\nbreak;\r\ncase OV9640_COM15:\r\nval |= alts->com15;\r\nbreak;\r\n}\r\nret = ov9640_reg_write(client, ov9640_regs[i].reg, val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < matrix_regs_len; i++) {\r\nret = ov9640_reg_write(client, matrix_regs[i].reg,\r\nmatrix_regs[i].val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9640_prog_dflt(struct i2c_client *client)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(ov9640_regs_dflt); i++) {\r\nret = ov9640_reg_write(client, ov9640_regs_dflt[i].reg,\r\nov9640_regs_dflt[i].val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmdelay(150);\r\nreturn 0;\r\n}\r\nstatic int ov9640_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov9640_reg_alt alts = {0};\r\nenum v4l2_colorspace cspace;\r\nenum v4l2_mbus_pixelcode code = mf->code;\r\nint ret;\r\nov9640_res_roundup(&mf->width, &mf->height);\r\nov9640_alter_regs(mf->code, &alts);\r\nov9640_reset(client);\r\nret = ov9640_prog_dflt(client);\r\nif (ret)\r\nreturn ret;\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE:\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\ncspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ndefault:\r\ncode = V4L2_MBUS_FMT_UYVY8_2X8;\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ncspace = V4L2_COLORSPACE_JPEG;\r\n}\r\nret = ov9640_write_regs(client, mf->width, code, &alts);\r\nif (!ret) {\r\nmf->code = code;\r\nmf->colorspace = cspace;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov9640_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nov9640_res_roundup(&mf->width, &mf->height);\r\nmf->field = V4L2_FIELD_NONE;\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE:\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ndefault:\r\nmf->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9640_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(ov9640_codes))\r\nreturn -EINVAL;\r\n*code = ov9640_codes[index];\r\nreturn 0;\r\n}\r\nstatic int ov9640_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\na->c.left = 0;\r\na->c.top = 0;\r\na->c.width = W_SXGA;\r\na->c.height = H_SXGA;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int ov9640_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = W_SXGA;\r\na->bounds.height = H_SXGA;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ov9640_video_probe(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ov9640_priv *priv = to_ov9640_sensor(sd);\r\nu8 pid, ver, midh, midl;\r\nconst char *devname;\r\nint ret;\r\nret = ov9640_s_power(&priv->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov9640_reg_read(client, OV9640_PID, &pid);\r\nif (!ret)\r\nret = ov9640_reg_read(client, OV9640_VER, &ver);\r\nif (!ret)\r\nret = ov9640_reg_read(client, OV9640_MIDH, &midh);\r\nif (!ret)\r\nret = ov9640_reg_read(client, OV9640_MIDL, &midl);\r\nif (ret)\r\ngoto done;\r\nswitch (VERSION(pid, ver)) {\r\ncase OV9640_V2:\r\ndevname = "ov9640";\r\npriv->model = V4L2_IDENT_OV9640;\r\npriv->revision = 2;\r\nbreak;\r\ncase OV9640_V3:\r\ndevname = "ov9640";\r\npriv->model = V4L2_IDENT_OV9640;\r\npriv->revision = 3;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Product ID error %x:%x\n", pid, ver);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\ndev_info(&client->dev, "%s Product ID %0x:%0x Manufacturer ID %x:%x\n",\r\ndevname, pid, ver, midh, midl);\r\nret = v4l2_ctrl_handler_setup(&priv->hdl);\r\ndone:\r\nov9640_s_power(&priv->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int ov9640_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int ov9640_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov9640_priv *priv;\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nint ret;\r\nif (!icl) {\r\ndev_err(&client->dev, "Missing platform_data for driver\n");\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(struct ov9640_priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&client->dev,\r\n"Failed to allocate memory for private data!\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov9640_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 2);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov9640_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov9640_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\npriv->subdev.ctrl_handler = &priv->hdl;\r\nif (priv->hdl.error) {\r\nint err = priv->hdl.error;\r\nkfree(priv);\r\nreturn err;\r\n}\r\nret = ov9640_video_probe(client);\r\nif (ret) {\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov9640_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ov9640_priv *priv = to_ov9640_sensor(sd);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\nreturn 0;\r\n}
