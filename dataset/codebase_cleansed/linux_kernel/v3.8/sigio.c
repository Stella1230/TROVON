static int write_sigio_thread(void *unused)\r\n{\r\nstruct pollfds *fds, tmp;\r\nstruct pollfd *p;\r\nint i, n, respond_fd;\r\nchar c;\r\nsignal(SIGWINCH, SIG_IGN);\r\nfds = &current_poll;\r\nwhile (1) {\r\nn = poll(fds->poll, fds->used, -1);\r\nif (n < 0) {\r\nif (errno == EINTR)\r\ncontinue;\r\nprintk(UM_KERN_ERR "write_sigio_thread : poll returned "\r\n"%d, errno = %d\n", n, errno);\r\n}\r\nfor (i = 0; i < fds->used; i++) {\r\np = &fds->poll[i];\r\nif (p->revents == 0)\r\ncontinue;\r\nif (p->fd == sigio_private[1]) {\r\nCATCH_EINTR(n = read(sigio_private[1], &c,\r\nsizeof(c)));\r\nif (n != sizeof(c))\r\nprintk(UM_KERN_ERR\r\n"write_sigio_thread : "\r\n"read on socket failed, "\r\n"err = %d\n", errno);\r\ntmp = current_poll;\r\ncurrent_poll = next_poll;\r\nnext_poll = tmp;\r\nrespond_fd = sigio_private[1];\r\n}\r\nelse {\r\nrespond_fd = write_sigio_fds[1];\r\nfds->used--;\r\nmemmove(&fds->poll[i], &fds->poll[i + 1],\r\n(fds->used - i) * sizeof(*fds->poll));\r\n}\r\nCATCH_EINTR(n = write(respond_fd, &c, sizeof(c)));\r\nif (n != sizeof(c))\r\nprintk(UM_KERN_ERR "write_sigio_thread : "\r\n"write on socket failed, err = %d\n",\r\nerrno);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int need_poll(struct pollfds *polls, int n)\r\n{\r\nstruct pollfd *new;\r\nif (n <= polls->size)\r\nreturn 0;\r\nnew = uml_kmalloc(n * sizeof(struct pollfd), UM_GFP_ATOMIC);\r\nif (new == NULL) {\r\nprintk(UM_KERN_ERR "need_poll : failed to allocate new "\r\n"pollfds\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new, polls->poll, polls->used * sizeof(struct pollfd));\r\nkfree(polls->poll);\r\npolls->poll = new;\r\npolls->size = n;\r\nreturn 0;\r\n}\r\nstatic void update_thread(void)\r\n{\r\nunsigned long flags;\r\nint n;\r\nchar c;\r\nflags = set_signals(0);\r\nCATCH_EINTR(n = write(sigio_private[0], &c, sizeof(c)));\r\nif (n != sizeof(c)) {\r\nprintk(UM_KERN_ERR "update_thread : write failed, err = %d\n",\r\nerrno);\r\ngoto fail;\r\n}\r\nCATCH_EINTR(n = read(sigio_private[0], &c, sizeof(c)));\r\nif (n != sizeof(c)) {\r\nprintk(UM_KERN_ERR "update_thread : read failed, err = %d\n",\r\nerrno);\r\ngoto fail;\r\n}\r\nset_signals(flags);\r\nreturn;\r\nfail:\r\nif (write_sigio_pid != -1) {\r\nos_kill_process(write_sigio_pid, 1);\r\nfree_stack(write_sigio_stack, 0);\r\n}\r\nwrite_sigio_pid = -1;\r\nclose(sigio_private[0]);\r\nclose(sigio_private[1]);\r\nclose(write_sigio_fds[0]);\r\nclose(write_sigio_fds[1]);\r\nset_signals(flags);\r\n}\r\nint add_sigio_fd(int fd)\r\n{\r\nstruct pollfd *p;\r\nint err = 0, i, n;\r\nsigio_lock();\r\nfor (i = 0; i < all_sigio_fds.used; i++) {\r\nif (all_sigio_fds.poll[i].fd == fd)\r\nbreak;\r\n}\r\nif (i == all_sigio_fds.used)\r\ngoto out;\r\np = &all_sigio_fds.poll[i];\r\nfor (i = 0; i < current_poll.used; i++) {\r\nif (current_poll.poll[i].fd == fd)\r\ngoto out;\r\n}\r\nn = current_poll.used;\r\nerr = need_poll(&next_poll, n + 1);\r\nif (err)\r\ngoto out;\r\nmemcpy(next_poll.poll, current_poll.poll,\r\ncurrent_poll.used * sizeof(struct pollfd));\r\nnext_poll.poll[n] = *p;\r\nnext_poll.used = n + 1;\r\nupdate_thread();\r\nout:\r\nsigio_unlock();\r\nreturn err;\r\n}\r\nint ignore_sigio_fd(int fd)\r\n{\r\nstruct pollfd *p;\r\nint err = 0, i, n = 0;\r\nif (write_sigio_pid == -1)\r\nreturn -EIO;\r\nsigio_lock();\r\nfor (i = 0; i < current_poll.used; i++) {\r\nif (current_poll.poll[i].fd == fd)\r\nbreak;\r\n}\r\nif (i == current_poll.used)\r\ngoto out;\r\nerr = need_poll(&next_poll, current_poll.used - 1);\r\nif (err)\r\ngoto out;\r\nfor (i = 0; i < current_poll.used; i++) {\r\np = &current_poll.poll[i];\r\nif (p->fd != fd)\r\nnext_poll.poll[n++] = *p;\r\n}\r\nnext_poll.used = current_poll.used - 1;\r\nupdate_thread();\r\nout:\r\nsigio_unlock();\r\nreturn err;\r\n}\r\nstatic struct pollfd *setup_initial_poll(int fd)\r\n{\r\nstruct pollfd *p;\r\np = uml_kmalloc(sizeof(struct pollfd), UM_GFP_KERNEL);\r\nif (p == NULL) {\r\nprintk(UM_KERN_ERR "setup_initial_poll : failed to allocate "\r\n"poll\n");\r\nreturn NULL;\r\n}\r\n*p = ((struct pollfd) { .fd = fd,\r\n.events = POLLIN,\r\n.revents = 0 });\r\nreturn p;\r\n}\r\nstatic void write_sigio_workaround(void)\r\n{\r\nstruct pollfd *p;\r\nint err;\r\nint l_write_sigio_fds[2];\r\nint l_sigio_private[2];\r\nint l_write_sigio_pid;\r\nsigio_lock();\r\nl_write_sigio_pid = write_sigio_pid;\r\nsigio_unlock();\r\nif (l_write_sigio_pid != -1)\r\nreturn;\r\nerr = os_pipe(l_write_sigio_fds, 1, 1);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "write_sigio_workaround - os_pipe 1 failed, "\r\n"err = %d\n", -err);\r\nreturn;\r\n}\r\nerr = os_pipe(l_sigio_private, 1, 1);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "write_sigio_workaround - os_pipe 2 failed, "\r\n"err = %d\n", -err);\r\ngoto out_close1;\r\n}\r\np = setup_initial_poll(l_sigio_private[1]);\r\nif (!p)\r\ngoto out_close2;\r\nsigio_lock();\r\nif (write_sigio_pid != -1)\r\ngoto out_free;\r\ncurrent_poll = ((struct pollfds) { .poll = p,\r\n.used = 1,\r\n.size = 1 });\r\nif (write_sigio_irq(l_write_sigio_fds[0]))\r\ngoto out_clear_poll;\r\nmemcpy(write_sigio_fds, l_write_sigio_fds, sizeof(l_write_sigio_fds));\r\nmemcpy(sigio_private, l_sigio_private, sizeof(l_sigio_private));\r\nwrite_sigio_pid = run_helper_thread(write_sigio_thread, NULL,\r\nCLONE_FILES | CLONE_VM,\r\n&write_sigio_stack);\r\nif (write_sigio_pid < 0)\r\ngoto out_clear;\r\nsigio_unlock();\r\nreturn;\r\nout_clear:\r\nwrite_sigio_pid = -1;\r\nwrite_sigio_fds[0] = -1;\r\nwrite_sigio_fds[1] = -1;\r\nsigio_private[0] = -1;\r\nsigio_private[1] = -1;\r\nout_clear_poll:\r\ncurrent_poll = ((struct pollfds) { .poll = NULL,\r\n.size = 0,\r\n.used = 0 });\r\nout_free:\r\nsigio_unlock();\r\nkfree(p);\r\nout_close2:\r\nclose(l_sigio_private[0]);\r\nclose(l_sigio_private[1]);\r\nout_close1:\r\nclose(l_write_sigio_fds[0]);\r\nclose(l_write_sigio_fds[1]);\r\n}\r\nvoid sigio_broken(int fd, int read)\r\n{\r\nint err;\r\nwrite_sigio_workaround();\r\nsigio_lock();\r\nerr = need_poll(&all_sigio_fds, all_sigio_fds.used + 1);\r\nif (err) {\r\nprintk(UM_KERN_ERR "maybe_sigio_broken - failed to add pollfd "\r\n"for descriptor %d\n", fd);\r\ngoto out;\r\n}\r\nall_sigio_fds.poll[all_sigio_fds.used++] =\r\n((struct pollfd) { .fd = fd,\r\n.events = read ? POLLIN : POLLOUT,\r\n.revents = 0 });\r\nout:\r\nsigio_unlock();\r\n}\r\nvoid maybe_sigio_broken(int fd, int read)\r\n{\r\nif (!isatty(fd))\r\nreturn;\r\nif ((read || pty_output_sigio) && (!read || pty_close_sigio))\r\nreturn;\r\nsigio_broken(fd, read);\r\n}\r\nstatic void sigio_cleanup(void)\r\n{\r\nif (write_sigio_pid == -1)\r\nreturn;\r\nos_kill_process(write_sigio_pid, 1);\r\nfree_stack(write_sigio_stack, 0);\r\nwrite_sigio_pid = -1;\r\n}\r\nstatic void __init handler(int sig)\r\n{\r\ngot_sigio = 1;\r\n}\r\nstatic void openpty_cb(void *arg)\r\n{\r\nstruct openpty_arg *info = arg;\r\ninfo->err = 0;\r\nif (openpty(&info->master, &info->slave, NULL, NULL, NULL))\r\ninfo->err = -errno;\r\n}\r\nstatic int async_pty(int master, int slave)\r\n{\r\nint flags;\r\nflags = fcntl(master, F_GETFL);\r\nif (flags < 0)\r\nreturn -errno;\r\nif ((fcntl(master, F_SETFL, flags | O_NONBLOCK | O_ASYNC) < 0) ||\r\n(fcntl(master, F_SETOWN, os_getpid()) < 0))\r\nreturn -errno;\r\nif ((fcntl(slave, F_SETFL, flags | O_NONBLOCK) < 0))\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nstatic void __init check_one_sigio(void (*proc)(int, int))\r\n{\r\nstruct sigaction old, new;\r\nstruct openpty_arg pty = { .master = -1, .slave = -1 };\r\nint master, slave, err;\r\ninitial_thread_cb(openpty_cb, &pty);\r\nif (pty.err) {\r\nprintk(UM_KERN_ERR "check_one_sigio failed, errno = %d\n",\r\n-pty.err);\r\nreturn;\r\n}\r\nmaster = pty.master;\r\nslave = pty.slave;\r\nif ((master == -1) || (slave == -1)) {\r\nprintk(UM_KERN_ERR "check_one_sigio failed to allocate a "\r\n"pty\n");\r\nreturn;\r\n}\r\nerr = raw(master);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "check_one_sigio : raw failed, errno = %d\n",\r\n-err);\r\nreturn;\r\n}\r\nerr = async_pty(master, slave);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "check_one_sigio : sigio_async failed, "\r\n"err = %d\n", -err);\r\nreturn;\r\n}\r\nif (sigaction(SIGIO, NULL, &old) < 0) {\r\nprintk(UM_KERN_ERR "check_one_sigio : sigaction 1 failed, "\r\n"errno = %d\n", errno);\r\nreturn;\r\n}\r\nnew = old;\r\nnew.sa_handler = handler;\r\nif (sigaction(SIGIO, &new, NULL) < 0) {\r\nprintk(UM_KERN_ERR "check_one_sigio : sigaction 2 failed, "\r\n"errno = %d\n", errno);\r\nreturn;\r\n}\r\ngot_sigio = 0;\r\n(*proc)(master, slave);\r\nclose(master);\r\nclose(slave);\r\nif (sigaction(SIGIO, &old, NULL) < 0)\r\nprintk(UM_KERN_ERR "check_one_sigio : sigaction 3 failed, "\r\n"errno = %d\n", errno);\r\n}\r\nstatic void tty_output(int master, int slave)\r\n{\r\nint n;\r\nchar buf[512];\r\nprintk(UM_KERN_INFO "Checking that host ptys support output SIGIO...");\r\nmemset(buf, 0, sizeof(buf));\r\nwhile (write(master, buf, sizeof(buf)) > 0) ;\r\nif (errno != EAGAIN)\r\nprintk(UM_KERN_ERR "tty_output : write failed, errno = %d\n",\r\nerrno);\r\nwhile (((n = read(slave, buf, sizeof(buf))) > 0) &&\r\n!({ barrier(); got_sigio; })\r\nvoid tty_close(int master, int slave)\r\n{\r\nprintk(UM_KERN_INFO "Checking that host ptys support SIGIO on "\r\n"close...");\r\nclose(slave);\r\nif (got_sigio) {\r\nprintk(UM_KERN_CONT "Yes\n");\r\npty_close_sigio = 1;\r\n} else\r\nprintk(UM_KERN_CONT "No, enabling workaround\n");\r\n}\r\nstatic void __init check_sigio(void)\r\n{\r\nif ((access("/dev/ptmx", R_OK) < 0) &&\r\n(access("/dev/ptyp0", R_OK) < 0)) {\r\nprintk(UM_KERN_WARNING "No pseudo-terminals available - "\r\n"skipping pty SIGIO check\n");\r\nreturn;\r\n}\r\ncheck_one_sigio(tty_output);\r\ncheck_one_sigio(tty_close);\r\n}\r\nvoid __init os_check_bugs(void)\r\n{\r\ncheck_sigio();\r\n}
