static int __init cycx_drv_init(void)\r\n{\r\npr_info("%s v%u.%u %s\n",\r\nfullname, MOD_VERSION, MOD_RELEASE, copyright);\r\nreturn 0;\r\n}\r\nstatic void cycx_drv_cleanup(void)\r\n{\r\n}\r\nint cycx_setup(struct cycx_hw *hw, void *cfm, u32 len, unsigned long dpmbase)\r\n{\r\nint err;\r\nif (!get_option_index(cycx_2x_irq_options, hw->irq)) {\r\npr_err("IRQ %d is invalid!\n", hw->irq);\r\nreturn -EINVAL;\r\n}\r\nif (!dpmbase) {\r\npr_err("you must specify the dpm address!\n");\r\nreturn -EINVAL;\r\n} else if (!get_option_index(cyc2x_dpmbase_options, dpmbase)) {\r\npr_err("memory address 0x%lX is invalid!\n", dpmbase);\r\nreturn -EINVAL;\r\n}\r\nhw->dpmbase = ioremap(dpmbase, CYCX_WINDOWSIZE);\r\nhw->dpmsize = CYCX_WINDOWSIZE;\r\nif (!detect_cyc2x(hw->dpmbase)) {\r\npr_err("adapter Cyclom 2X not found at address 0x%lX!\n",\r\ndpmbase);\r\nreturn -EINVAL;\r\n}\r\npr_info("found Cyclom 2X card at address 0x%lX\n", dpmbase);\r\nerr = load_cyc2x(hw, cfm, len);\r\nif (err)\r\ncycx_down(hw);\r\nreturn err;\r\n}\r\nint cycx_down(struct cycx_hw *hw)\r\n{\r\niounmap(hw->dpmbase);\r\nreturn 0;\r\n}\r\nstatic void cycx_inten(struct cycx_hw *hw)\r\n{\r\nwriteb(0, hw->dpmbase);\r\n}\r\nvoid cycx_intr(struct cycx_hw *hw)\r\n{\r\nwritew(0, hw->dpmbase + GEN_CYCX_INTR);\r\n}\r\nint cycx_exec(void __iomem *addr)\r\n{\r\nu16 i = 0;\r\nwhile (readw(addr)) {\r\nudelay(1000);\r\nif (++i > 50)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint cycx_peek(struct cycx_hw *hw, u32 addr, void *buf, u32 len)\r\n{\r\nif (len == 1)\r\n*(u8*)buf = readb(hw->dpmbase + addr);\r\nelse\r\nmemcpy_fromio(buf, hw->dpmbase + addr, len);\r\nreturn 0;\r\n}\r\nint cycx_poke(struct cycx_hw *hw, u32 addr, void *buf, u32 len)\r\n{\r\nif (len == 1)\r\nwriteb(*(u8*)buf, hw->dpmbase + addr);\r\nelse\r\nmemcpy_toio(hw->dpmbase + addr, buf, len);\r\nreturn 0;\r\n}\r\nstatic int memory_exists(void __iomem *addr)\r\n{\r\nint tries = 0;\r\nfor (; tries < 3 ; tries++) {\r\nwritew(TEST_PATTERN, addr + 0x10);\r\nif (readw(addr + 0x10) == TEST_PATTERN)\r\nif (readw(addr + 0x10) == TEST_PATTERN)\r\nreturn 1;\r\nmsleep_interruptible(1 * 1000);\r\n}\r\nreturn 0;\r\n}\r\nstatic void reset_load(void __iomem *addr, u8 *buffer, u32 cnt)\r\n{\r\nvoid __iomem *pt_code = addr + RESET_OFFSET;\r\nu16 i;\r\nfor (i = 0 ; i < cnt ; i++) {\r\nwriteb(*buffer++, pt_code++);\r\n}\r\n}\r\nstatic int buffer_load(void __iomem *addr, u8 *buffer, u32 cnt)\r\n{\r\nmemcpy_toio(addr + DATA_OFFSET, buffer, cnt);\r\nwritew(GEN_BOOT_DAT, addr + CMD_OFFSET);\r\nreturn wait_cyc(addr);\r\n}\r\nstatic void cycx_start(void __iomem *addr)\r\n{\r\nwriteb(0xea, addr + 0x30);\r\nwriteb(0x00, addr + 0x31);\r\nwriteb(0xc4, addr + 0x32);\r\nwriteb(0x00, addr + 0x33);\r\nwriteb(0x00, addr + 0x34);\r\nwritew(GEN_START, addr + CMD_OFFSET);\r\n}\r\nstatic void cycx_reset_boot(void __iomem *addr, u8 *code, u32 len)\r\n{\r\nvoid __iomem *pt_start = addr + START_OFFSET;\r\nwriteb(0xea, pt_start++);\r\nwriteb(0x00, pt_start++);\r\nwriteb(0xfc, pt_start++);\r\nwriteb(0x00, pt_start++);\r\nwriteb(0xf0, pt_start);\r\nreset_load(addr, code, len);\r\nwriteb(0, addr + START_CPU);\r\nmsleep_interruptible(1 * 1000);\r\n}\r\nstatic int cycx_data_boot(void __iomem *addr, u8 *code, u32 len)\r\n{\r\nvoid __iomem *pt_boot_cmd = addr + CMD_OFFSET;\r\nu32 i;\r\nwritew(CFM_LOAD_BUFSZ, pt_boot_cmd + sizeof(u16));\r\nwritew(GEN_DEFPAR, pt_boot_cmd);\r\nif (wait_cyc(addr) < 0)\r\nreturn -1;\r\nwritew(0, pt_boot_cmd + sizeof(u16));\r\nwritew(0x4000, pt_boot_cmd + 2 * sizeof(u16));\r\nwritew(GEN_SET_SEG, pt_boot_cmd);\r\nif (wait_cyc(addr) < 0)\r\nreturn -1;\r\nfor (i = 0 ; i < len ; i += CFM_LOAD_BUFSZ)\r\nif (buffer_load(addr, code + i,\r\nmin_t(u32, CFM_LOAD_BUFSZ, (len - i))) < 0) {\r\npr_err("Error !!\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cycx_code_boot(void __iomem *addr, u8 *code, u32 len)\r\n{\r\nvoid __iomem *pt_boot_cmd = addr + CMD_OFFSET;\r\nu32 i;\r\nwritew(CFM_LOAD_BUFSZ, pt_boot_cmd + sizeof(u16));\r\nwritew(GEN_DEFPAR, pt_boot_cmd);\r\nif (wait_cyc(addr) < 0)\r\nreturn -1;\r\nwritew(0x0000, pt_boot_cmd + sizeof(u16));\r\nwritew(0xc400, pt_boot_cmd + 2 * sizeof(u16));\r\nwritew(GEN_SET_SEG, pt_boot_cmd);\r\nif (wait_cyc(addr) < 0)\r\nreturn -1;\r\nfor (i = 0 ; i < len ; i += CFM_LOAD_BUFSZ)\r\nif (buffer_load(addr, code + i,\r\nmin_t(u32, CFM_LOAD_BUFSZ, (len - i)))) {\r\npr_err("Error !!\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int load_cyc2x(struct cycx_hw *hw, struct cycx_firmware *cfm, u32 len)\r\n{\r\nint i, j;\r\nstruct cycx_fw_header *img_hdr;\r\nu8 *reset_image,\r\n*data_image,\r\n*code_image;\r\nvoid __iomem *pt_cycld = hw->dpmbase + 0x400;\r\nu16 cksum;\r\npr_info("firmware signature=\"%s\"\n", cfm->signature);\r\nif (strcmp(cfm->signature, CFM_SIGNATURE)) {\r\npr_err("load_cyc2x: not Cyclom-2X firmware!\n");\r\nreturn -EINVAL;\r\n}\r\npr_info("firmware version=%u\n", cfm->version);\r\nif (cfm->version != CFM_VERSION) {\r\npr_err("%s: firmware format %u rejected! Expecting %u.\n",\r\n__func__, cfm->version, CFM_VERSION);\r\nreturn -EINVAL;\r\n}\r\ncksum = checksum((u8*)&cfm->info, sizeof(struct cycx_fw_info) +\r\ncfm->info.codesize);\r\nif (cksum != cfm->checksum) {\r\npr_err("%s: firmware corrupted!\n", __func__);\r\npr_err(" cdsize = 0x%x (expected 0x%lx)\n",\r\nlen - (int)sizeof(struct cycx_firmware) - 1,\r\ncfm->info.codesize);\r\npr_err(" chksum = 0x%x (expected 0x%x)\n",\r\ncksum, cfm->checksum);\r\nreturn -EINVAL;\r\n}\r\nimg_hdr = (struct cycx_fw_header *)&cfm->image;\r\n#ifdef FIRMWARE_DEBUG\r\npr_info("%s: image sizes\n", __func__);\r\npr_info(" reset=%lu\n", img_hdr->reset_size);\r\npr_info(" data=%lu\n", img_hdr->data_size);\r\npr_info(" code=%lu\n", img_hdr->code_size);\r\n#endif\r\nreset_image = ((u8 *)img_hdr) + sizeof(struct cycx_fw_header);\r\ndata_image = reset_image + img_hdr->reset_size;\r\ncode_image = data_image + img_hdr->data_size;\r\npr_info("loading firmware %s (ID=%u)...\n",\r\ncfm->descr[0] ? cfm->descr : "unknown firmware",\r\ncfm->info.codeid);\r\nfor (i = 0 ; i < 5 ; i++) {\r\nif (!reset_cyc2x(hw->dpmbase)) {\r\npr_err("dpm problem or board not found\n");\r\nreturn -EINVAL;\r\n}\r\ncycx_reset_boot(hw->dpmbase, reset_image, img_hdr->reset_size);\r\nwritew(GEN_POWER_ON, pt_cycld);\r\nmsleep_interruptible(1 * 1000);\r\nfor (j = 0 ; j < 3 ; j++)\r\nif (!readw(pt_cycld))\r\ngoto reset_loaded;\r\nelse\r\nmsleep_interruptible(1 * 1000);\r\n}\r\npr_err("reset not started\n");\r\nreturn -EINVAL;\r\nreset_loaded:\r\nif (cycx_data_boot(hw->dpmbase, data_image, img_hdr->data_size)) {\r\npr_err("cannot load data file\n");\r\nreturn -EINVAL;\r\n}\r\nif (cycx_code_boot(hw->dpmbase, code_image, img_hdr->code_size)) {\r\npr_err("cannot load code file\n");\r\nreturn -EINVAL;\r\n}\r\ncycx_bootcfg(hw);\r\ncycx_start(hw->dpmbase);\r\nmsleep_interruptible(7 * 1000);\r\npr_info("firmware loaded!\n");\r\ncycx_inten(hw);\r\nreturn 0;\r\n}\r\nstatic void cycx_bootcfg(struct cycx_hw *hw)\r\n{\r\nwriteb(FIXED_BUFFERS, hw->dpmbase + CONF_OFFSET);\r\n}\r\nstatic int detect_cyc2x(void __iomem *addr)\r\n{\r\nreset_cyc2x(addr);\r\nreturn memory_exists(addr);\r\n}\r\nstatic int get_option_index(const long *optlist, long optval)\r\n{\r\nint i = 1;\r\nfor (; i <= optlist[0]; ++i)\r\nif (optlist[i] == optval)\r\nreturn i;\r\nreturn 0;\r\n}\r\nstatic int reset_cyc2x(void __iomem *addr)\r\n{\r\nwriteb(0, addr + RST_ENABLE);\r\nmsleep_interruptible(2 * 1000);\r\nwriteb(0, addr + RST_DISABLE);\r\nmsleep_interruptible(2 * 1000);\r\nreturn memory_exists(addr);\r\n}\r\nstatic u16 checksum(u8 *buf, u32 len)\r\n{\r\nu16 crc = 0;\r\nu16 mask, flag;\r\nfor (; len; --len, ++buf)\r\nfor (mask = 0x80; mask; mask >>= 1) {\r\nflag = (crc & 0x8000);\r\ncrc <<= 1;\r\ncrc |= ((*buf & mask) ? 1 : 0);\r\nif (flag)\r\ncrc ^= 0x1021;\r\n}\r\nreturn crc;\r\n}
