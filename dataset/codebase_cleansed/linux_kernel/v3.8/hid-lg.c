static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\r\nif ((drv_data->quirks & LG_RDESC) && *rsize >= 90 && rdesc[83] == 0x26 &&\r\nrdesc[84] == 0x8c && rdesc[85] == 0x02) {\r\nhid_info(hdev,\r\n"fixing up Logitech keyboard report descriptor\n");\r\nrdesc[84] = rdesc[89] = 0x4d;\r\nrdesc[85] = rdesc[90] = 0x10;\r\n}\r\nif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 50 &&\r\nrdesc[32] == 0x81 && rdesc[33] == 0x06 &&\r\nrdesc[49] == 0x81 && rdesc[50] == 0x06) {\r\nhid_info(hdev,\r\n"fixing up rel/abs in Logitech report descriptor\n");\r\nrdesc[33] = rdesc[50] = 0x02;\r\n}\r\nif ((drv_data->quirks & LG_FF4) && *rsize >= 101 &&\r\nrdesc[41] == 0x95 && rdesc[42] == 0x0B &&\r\nrdesc[47] == 0x05 && rdesc[48] == 0x09) {\r\nhid_info(hdev, "fixing up Logitech Speed Force Wireless button descriptor\n");\r\nrdesc[41] = 0x05;\r\nrdesc[42] = 0x09;\r\nrdesc[47] = 0x95;\r\nrdesc[48] = 0x0B;\r\n}\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\r\nif (*rsize == DFP_RDESC_ORIG_SIZE) {\r\nhid_info(hdev,\r\n"fixing up Logitech Driving Force Pro report descriptor\n");\r\nrdesc = dfp_rdesc_fixed;\r\n*rsize = sizeof(dfp_rdesc_fixed);\r\n}\r\nbreak;\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int lg_ultrax_remote_mapping(struct hid_input *hi,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\r\nreturn 0;\r\nset_bit(EV_REP, hi->input->evbit);\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x004: lg_map_key_clear(KEY_AGAIN); break;\r\ncase 0x00d: lg_map_key_clear(KEY_HOME); break;\r\ncase 0x024: lg_map_key_clear(KEY_SHUFFLE); break;\r\ncase 0x025: lg_map_key_clear(KEY_TV); break;\r\ncase 0x026: lg_map_key_clear(KEY_MENU); break;\r\ncase 0x031: lg_map_key_clear(KEY_AUDIO); break;\r\ncase 0x032: lg_map_key_clear(KEY_TEXT); break;\r\ncase 0x033: lg_map_key_clear(KEY_LAST); break;\r\ncase 0x047: lg_map_key_clear(KEY_MP3); break;\r\ncase 0x048: lg_map_key_clear(KEY_DVD); break;\r\ncase 0x049: lg_map_key_clear(KEY_MEDIA); break;\r\ncase 0x04a: lg_map_key_clear(KEY_VIDEO); break;\r\ncase 0x04b: lg_map_key_clear(KEY_ANGLE); break;\r\ncase 0x04c: lg_map_key_clear(KEY_LANGUAGE); break;\r\ncase 0x04d: lg_map_key_clear(KEY_SUBTITLE); break;\r\ncase 0x051: lg_map_key_clear(KEY_RED); break;\r\ncase 0x052: lg_map_key_clear(KEY_CLOSE); break;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lg_dinovo_mapping(struct hid_input *hi, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\r\nreturn 0;\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x00d: lg_map_key_clear(KEY_MEDIA); break;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lg_wireless_mapping(struct hid_input *hi, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\r\nreturn 0;\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x1001: lg_map_key_clear(KEY_MESSENGER); break;\r\ncase 0x1003: lg_map_key_clear(KEY_SOUND); break;\r\ncase 0x1004: lg_map_key_clear(KEY_VIDEO); break;\r\ncase 0x1005: lg_map_key_clear(KEY_AUDIO); break;\r\ncase 0x100a: lg_map_key_clear(KEY_DOCUMENTS); break;\r\ncase 0x100f: lg_map_key_clear(KEY_FN_1); break;\r\ncase 0x1010: lg_map_key_clear(KEY_FN_2); break;\r\ncase 0x1011: lg_map_key_clear(KEY_PREVIOUSSONG); break;\r\ncase 0x1012: lg_map_key_clear(KEY_NEXTSONG); break;\r\ncase 0x1013: lg_map_key_clear(KEY_CAMERA); break;\r\ncase 0x1014: lg_map_key_clear(KEY_MESSENGER); break;\r\ncase 0x1015: lg_map_key_clear(KEY_RECORD); break;\r\ncase 0x1016: lg_map_key_clear(KEY_PLAYER); break;\r\ncase 0x1017: lg_map_key_clear(KEY_EJECTCD); break;\r\ncase 0x1018: lg_map_key_clear(KEY_MEDIA); break;\r\ncase 0x1019: lg_map_key_clear(KEY_PROG1); break;\r\ncase 0x101a: lg_map_key_clear(KEY_PROG2); break;\r\ncase 0x101b: lg_map_key_clear(KEY_PROG3); break;\r\ncase 0x101c: lg_map_key_clear(KEY_CYCLEWINDOWS); break;\r\ncase 0x101f: lg_map_key_clear(KEY_ZOOMIN); break;\r\ncase 0x1020: lg_map_key_clear(KEY_ZOOMOUT); break;\r\ncase 0x1021: lg_map_key_clear(KEY_ZOOMRESET); break;\r\ncase 0x1023: lg_map_key_clear(KEY_CLOSE); break;\r\ncase 0x1027: lg_map_key_clear(KEY_MENU); break;\r\ncase 0x1028: lg_map_key_clear(KEY_ANGLE); break;\r\ncase 0x1029: lg_map_key_clear(KEY_SHUFFLE); break;\r\ncase 0x102a: lg_map_key_clear(KEY_BACK); break;\r\ncase 0x102b: lg_map_key_clear(KEY_CYCLEWINDOWS); break;\r\ncase 0x102d: lg_map_key_clear(KEY_WWW); break;\r\ncase 0x1031: lg_map_key_clear(KEY_OK); break;\r\ncase 0x1032: lg_map_key_clear(KEY_CANCEL); break;\r\ncase 0x1041: lg_map_key_clear(KEY_BATTERY); break;\r\ncase 0x1042: lg_map_key_clear(KEY_WORDPROCESSOR); break;\r\ncase 0x1043: lg_map_key_clear(KEY_SPREADSHEET); break;\r\ncase 0x1044: lg_map_key_clear(KEY_PRESENTATION); break;\r\ncase 0x1045: lg_map_key_clear(KEY_UNDO); break;\r\ncase 0x1046: lg_map_key_clear(KEY_REDO); break;\r\ncase 0x1047: lg_map_key_clear(KEY_PRINT); break;\r\ncase 0x1048: lg_map_key_clear(KEY_SAVE); break;\r\ncase 0x1049: lg_map_key_clear(KEY_PROG1); break;\r\ncase 0x104a: lg_map_key_clear(KEY_PROG2); break;\r\ncase 0x104b: lg_map_key_clear(KEY_PROG3); break;\r\ncase 0x104c: lg_map_key_clear(KEY_PROG4); break;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lg_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstatic const u8 e_keymap[] = {\r\n0,216, 0,213,175,156, 0, 0, 0, 0,\r\n144, 0, 0, 0, 0, 0, 0, 0, 0,212,\r\n174,167,152,161,112, 0, 0, 0,154, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0,183,184,185,186,187,\r\n188,189,190,191,192,193,194, 0, 0, 0\r\n};\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\r\nunsigned int hid = usage->hid;\r\nif (hdev->product == USB_DEVICE_ID_LOGITECH_RECEIVER &&\r\nlg_ultrax_remote_mapping(hi, usage, bit, max))\r\nreturn 1;\r\nif (hdev->product == USB_DEVICE_ID_DINOVO_MINI &&\r\nlg_dinovo_mapping(hi, usage, bit, max))\r\nreturn 1;\r\nif ((drv_data->quirks & LG_WIRELESS) && lg_wireless_mapping(hi, usage, bit, max))\r\nreturn 1;\r\nif ((hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\r\nreturn 0;\r\nhid &= HID_USAGE;\r\nif (field->application == HID_GD_MOUSE) {\r\nif ((drv_data->quirks & LG_IGNORE_DOUBLED_WHEEL) &&\r\n(hid == 7 || hid == 8))\r\nreturn -1;\r\n} else {\r\nif ((drv_data->quirks & LG_EXPANDED_KEYMAP) &&\r\nhid < ARRAY_SIZE(e_keymap) &&\r\ne_keymap[hid] != 0) {\r\nhid_map_usage(hi, usage, bit, max, EV_KEY,\r\ne_keymap[hid]);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lg_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\r\nif ((drv_data->quirks & LG_BAD_RELATIVE_KEYS) && usage->type == EV_KEY &&\r\n(field->flags & HID_MAIN_ITEM_RELATIVE))\r\nfield->flags &= ~HID_MAIN_ITEM_RELATIVE;\r\nif ((drv_data->quirks & LG_DUPLICATE_USAGES) && (usage->type == EV_KEY ||\r\nusage->type == EV_REL || usage->type == EV_ABS))\r\nclear_bit(usage->code, *bit);\r\nreturn 0;\r\n}\r\nstatic int lg_event(struct hid_device *hdev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\r\nif ((drv_data->quirks & LG_INVERT_HWHEEL) && usage->code == REL_HWHEEL) {\r\ninput_event(field->hidinput->input, usage->type, usage->code,\r\n-value);\r\nreturn 1;\r\n}\r\nif (drv_data->quirks & LG_FF4) {\r\nreturn lg4ff_adjust_input_event(hdev, field, usage, value, drv_data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nunsigned int connect_mask = HID_CONNECT_DEFAULT;\r\nstruct lg_drv_data *drv_data;\r\nint ret;\r\ndrv_data = kzalloc(sizeof(struct lg_drv_data), GFP_KERNEL);\r\nif (!drv_data) {\r\nhid_err(hdev, "Insufficient memory, cannot allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ndrv_data->quirks = id->driver_data;\r\nhid_set_drvdata(hdev, (void *)drv_data);\r\nif (drv_data->quirks & LG_NOGET)\r\nhdev->quirks |= HID_QUIRK_NOGET;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nif (drv_data->quirks & (LG_FF | LG_FF2 | LG_FF3 | LG_FF4))\r\nconnect_mask &= ~HID_CONNECT_FF;\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nif (hdev->product == USB_DEVICE_ID_LOGITECH_WII_WHEEL) {\r\nunsigned char buf[] = { 0x00, 0xAF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nret = hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);\r\nif (ret >= 0) {\r\nwait_queue_head_t wait;\r\ninit_waitqueue_head (&wait);\r\nwait_event_interruptible_timeout(wait, 0, 10);\r\nbuf[1] = 0xB2;\r\nget_random_bytes(&buf[2], 2);\r\nret = hdev->hid_output_raw_report(hdev, buf, sizeof(buf), HID_FEATURE_REPORT);\r\n}\r\n}\r\nif (drv_data->quirks & LG_FF)\r\nlgff_init(hdev);\r\nif (drv_data->quirks & LG_FF2)\r\nlg2ff_init(hdev);\r\nif (drv_data->quirks & LG_FF3)\r\nlg3ff_init(hdev);\r\nif (drv_data->quirks & LG_FF4)\r\nlg4ff_init(hdev);\r\nreturn 0;\r\nerr_free:\r\nkfree(drv_data);\r\nreturn ret;\r\n}\r\nstatic void lg_remove(struct hid_device *hdev)\r\n{\r\nstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\r\nif (drv_data->quirks & LG_FF4)\r\nlg4ff_deinit(hdev);\r\nhid_hw_stop(hdev);\r\nkfree(drv_data);\r\n}\r\nstatic int __init lg_init(void)\r\n{\r\nreturn hid_register_driver(&lg_driver);\r\n}\r\nstatic void __exit lg_exit(void)\r\n{\r\nhid_unregister_driver(&lg_driver);\r\n}
