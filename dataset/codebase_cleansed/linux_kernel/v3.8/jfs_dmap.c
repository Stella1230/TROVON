int dbMount(struct inode *ipbmap)\r\n{\r\nstruct bmap *bmp;\r\nstruct dbmap_disk *dbmp_le;\r\nstruct metapage *mp;\r\nint i;\r\nbmp = kmalloc(sizeof(struct bmap), GFP_KERNEL);\r\nif (bmp == NULL)\r\nreturn -ENOMEM;\r\nmp = read_metapage(ipbmap,\r\nBMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\r\nPSIZE, 0);\r\nif (mp == NULL) {\r\nkfree(bmp);\r\nreturn -EIO;\r\n}\r\ndbmp_le = (struct dbmap_disk *) mp->data;\r\nbmp->db_mapsize = le64_to_cpu(dbmp_le->dn_mapsize);\r\nbmp->db_nfree = le64_to_cpu(dbmp_le->dn_nfree);\r\nbmp->db_l2nbperpage = le32_to_cpu(dbmp_le->dn_l2nbperpage);\r\nbmp->db_numag = le32_to_cpu(dbmp_le->dn_numag);\r\nbmp->db_maxlevel = le32_to_cpu(dbmp_le->dn_maxlevel);\r\nbmp->db_maxag = le32_to_cpu(dbmp_le->dn_maxag);\r\nbmp->db_agpref = le32_to_cpu(dbmp_le->dn_agpref);\r\nbmp->db_aglevel = le32_to_cpu(dbmp_le->dn_aglevel);\r\nbmp->db_agheight = le32_to_cpu(dbmp_le->dn_agheight);\r\nbmp->db_agwidth = le32_to_cpu(dbmp_le->dn_agwidth);\r\nbmp->db_agstart = le32_to_cpu(dbmp_le->dn_agstart);\r\nbmp->db_agl2size = le32_to_cpu(dbmp_le->dn_agl2size);\r\nfor (i = 0; i < MAXAG; i++)\r\nbmp->db_agfree[i] = le64_to_cpu(dbmp_le->dn_agfree[i]);\r\nbmp->db_agsize = le64_to_cpu(dbmp_le->dn_agsize);\r\nbmp->db_maxfreebud = dbmp_le->dn_maxfreebud;\r\nrelease_metapage(mp);\r\nbmp->db_ipbmap = ipbmap;\r\nJFS_SBI(ipbmap->i_sb)->bmap = bmp;\r\nmemset(bmp->db_active, 0, sizeof(bmp->db_active));\r\nBMAP_LOCK_INIT(bmp);\r\nreturn (0);\r\n}\r\nint dbUnmount(struct inode *ipbmap, int mounterror)\r\n{\r\nstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\r\nif (!(mounterror || isReadOnly(ipbmap)))\r\ndbSync(ipbmap);\r\ntruncate_inode_pages(ipbmap->i_mapping, 0);\r\nkfree(bmp);\r\nreturn (0);\r\n}\r\nint dbSync(struct inode *ipbmap)\r\n{\r\nstruct dbmap_disk *dbmp_le;\r\nstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\r\nstruct metapage *mp;\r\nint i;\r\nmp = read_metapage(ipbmap,\r\nBMAPBLKNO << JFS_SBI(ipbmap->i_sb)->l2nbperpage,\r\nPSIZE, 0);\r\nif (mp == NULL) {\r\njfs_err("dbSync: read_metapage failed!");\r\nreturn -EIO;\r\n}\r\ndbmp_le = (struct dbmap_disk *) mp->data;\r\ndbmp_le->dn_mapsize = cpu_to_le64(bmp->db_mapsize);\r\ndbmp_le->dn_nfree = cpu_to_le64(bmp->db_nfree);\r\ndbmp_le->dn_l2nbperpage = cpu_to_le32(bmp->db_l2nbperpage);\r\ndbmp_le->dn_numag = cpu_to_le32(bmp->db_numag);\r\ndbmp_le->dn_maxlevel = cpu_to_le32(bmp->db_maxlevel);\r\ndbmp_le->dn_maxag = cpu_to_le32(bmp->db_maxag);\r\ndbmp_le->dn_agpref = cpu_to_le32(bmp->db_agpref);\r\ndbmp_le->dn_aglevel = cpu_to_le32(bmp->db_aglevel);\r\ndbmp_le->dn_agheight = cpu_to_le32(bmp->db_agheight);\r\ndbmp_le->dn_agwidth = cpu_to_le32(bmp->db_agwidth);\r\ndbmp_le->dn_agstart = cpu_to_le32(bmp->db_agstart);\r\ndbmp_le->dn_agl2size = cpu_to_le32(bmp->db_agl2size);\r\nfor (i = 0; i < MAXAG; i++)\r\ndbmp_le->dn_agfree[i] = cpu_to_le64(bmp->db_agfree[i]);\r\ndbmp_le->dn_agsize = cpu_to_le64(bmp->db_agsize);\r\ndbmp_le->dn_maxfreebud = bmp->db_maxfreebud;\r\nwrite_metapage(mp);\r\nfilemap_write_and_wait(ipbmap->i_mapping);\r\ndiWriteSpecial(ipbmap, 0);\r\nreturn (0);\r\n}\r\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\r\n{\r\nstruct metapage *mp;\r\nstruct dmap *dp;\r\nint nb, rc;\r\ns64 lblkno, rem;\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\r\nstruct super_block *sb = ipbmap->i_sb;\r\nIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\r\nIREAD_UNLOCK(ipbmap);\r\nprintk(KERN_ERR "blkno = %Lx, nblocks = %Lx\n",\r\n(unsigned long long) blkno,\r\n(unsigned long long) nblocks);\r\njfs_error(ip->i_sb,\r\n"dbFree: block to be freed is outside the map");\r\nreturn -EIO;\r\n}\r\nif (JFS_SBI(sb)->flag & JFS_DISCARD)\r\nif (JFS_SBI(sb)->minblks_trim <= nblocks)\r\njfs_issue_discard(ipbmap, blkno, nblocks);\r\nmp = NULL;\r\nfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\r\nif (mp) {\r\nwrite_metapage(mp);\r\n}\r\nlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\r\nmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -EIO;\r\n}\r\ndp = (struct dmap *) mp->data;\r\nnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\r\nif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\r\njfs_error(ip->i_sb, "dbFree: error in block map\n");\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipbmap);\r\nreturn (rc);\r\n}\r\n}\r\nwrite_metapage(mp);\r\nIREAD_UNLOCK(ipbmap);\r\nreturn (0);\r\n}\r\nint\r\ndbUpdatePMap(struct inode *ipbmap,\r\nint free, s64 blkno, s64 nblocks, struct tblock * tblk)\r\n{\r\nint nblks, dbitno, wbitno, rbits;\r\nint word, nbits, nwords;\r\nstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\r\ns64 lblkno, rem, lastlblkno;\r\nu32 mask;\r\nstruct dmap *dp;\r\nstruct metapage *mp;\r\nstruct jfs_log *log;\r\nint lsn, difft, diffp;\r\nunsigned long flags;\r\nif (blkno + nblocks > bmp->db_mapsize) {\r\nprintk(KERN_ERR "blkno = %Lx, nblocks = %Lx\n",\r\n(unsigned long long) blkno,\r\n(unsigned long long) nblocks);\r\njfs_error(ipbmap->i_sb,\r\n"dbUpdatePMap: blocks are outside the map");\r\nreturn -EIO;\r\n}\r\nlsn = tblk->lsn;\r\nlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\r\nlogdiff(difft, lsn, log);\r\nmp = NULL;\r\nlastlblkno = 0;\r\nfor (rem = nblocks; rem > 0; rem -= nblks, blkno += nblks) {\r\nlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\r\nif (lblkno != lastlblkno) {\r\nif (mp) {\r\nwrite_metapage(mp);\r\n}\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE,\r\n0);\r\nif (mp == NULL)\r\nreturn -EIO;\r\nmetapage_wait_for_io(mp);\r\n}\r\ndp = (struct dmap *) mp->data;\r\ndbitno = blkno & (BPERDMAP - 1);\r\nword = dbitno >> L2DBWORD;\r\nnblks = min(rem, (s64)BPERDMAP - dbitno);\r\nfor (rbits = nblks; rbits > 0;\r\nrbits -= nbits, dbitno += nbits) {\r\nwbitno = dbitno & (DBWORD - 1);\r\nnbits = min(rbits, DBWORD - wbitno);\r\nif (nbits < DBWORD) {\r\nmask =\r\n(ONES << (DBWORD - nbits) >> wbitno);\r\nif (free)\r\ndp->pmap[word] &=\r\ncpu_to_le32(~mask);\r\nelse\r\ndp->pmap[word] |=\r\ncpu_to_le32(mask);\r\nword += 1;\r\n} else {\r\nnwords = rbits >> L2DBWORD;\r\nnbits = nwords << L2DBWORD;\r\nif (free)\r\nmemset(&dp->pmap[word], 0,\r\nnwords * 4);\r\nelse\r\nmemset(&dp->pmap[word], (int) ONES,\r\nnwords * 4);\r\nword += nwords;\r\n}\r\n}\r\nif (lblkno == lastlblkno)\r\ncontinue;\r\nlastlblkno = lblkno;\r\nLOGSYNC_LOCK(log, flags);\r\nif (mp->lsn != 0) {\r\nlogdiff(diffp, mp->lsn, log);\r\nif (difft < diffp) {\r\nmp->lsn = lsn;\r\nlist_move(&mp->synclist, &tblk->synclist);\r\n}\r\nlogdiff(difft, tblk->clsn, log);\r\nlogdiff(diffp, mp->clsn, log);\r\nif (difft > diffp)\r\nmp->clsn = tblk->clsn;\r\n} else {\r\nmp->log = log;\r\nmp->lsn = lsn;\r\nlog->count++;\r\nlist_add(&mp->synclist, &tblk->synclist);\r\nmp->clsn = tblk->clsn;\r\n}\r\nLOGSYNC_UNLOCK(log, flags);\r\n}\r\nif (mp) {\r\nwrite_metapage(mp);\r\n}\r\nreturn (0);\r\n}\r\nint dbNextAG(struct inode *ipbmap)\r\n{\r\ns64 avgfree;\r\nint agpref;\r\ns64 hwm = 0;\r\nint i;\r\nint next_best = -1;\r\nstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\r\nBMAP_LOCK(bmp);\r\navgfree = (u32)bmp->db_nfree / bmp->db_numag;\r\nagpref = bmp->db_agpref;\r\nif ((atomic_read(&bmp->db_active[agpref]) == 0) &&\r\n(bmp->db_agfree[agpref] >= avgfree))\r\ngoto unlock;\r\nfor (i = 0 ; i < bmp->db_numag; i++, agpref++) {\r\nif (agpref == bmp->db_numag)\r\nagpref = 0;\r\nif (atomic_read(&bmp->db_active[agpref]))\r\ncontinue;\r\nif (bmp->db_agfree[agpref] >= avgfree) {\r\nbmp->db_agpref = agpref;\r\ngoto unlock;\r\n} else if (bmp->db_agfree[agpref] > hwm) {\r\nhwm = bmp->db_agfree[agpref];\r\nnext_best = agpref;\r\n}\r\n}\r\nif (next_best != -1)\r\nbmp->db_agpref = next_best;\r\nunlock:\r\nBMAP_UNLOCK(bmp);\r\nreturn (bmp->db_agpref);\r\n}\r\nint dbAlloc(struct inode *ip, s64 hint, s64 nblocks, s64 * results)\r\n{\r\nint rc, agno;\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct bmap *bmp;\r\nstruct metapage *mp;\r\ns64 lblkno, blkno;\r\nstruct dmap *dp;\r\nint l2nb;\r\ns64 mapSize;\r\nint writers;\r\nassert(nblocks > 0);\r\nl2nb = BLKSTOL2(nblocks);\r\nbmp = JFS_SBI(ip->i_sb)->bmap;\r\nmapSize = bmp->db_mapsize;\r\nif (hint >= mapSize) {\r\njfs_error(ip->i_sb, "dbAlloc: the hint is outside the map");\r\nreturn -EIO;\r\n}\r\nif (l2nb > bmp->db_agl2size) {\r\nIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nrc = dbAllocAny(bmp, nblocks, l2nb, results);\r\ngoto write_unlock;\r\n}\r\nif (hint == 0)\r\ngoto pref_ag;\r\nblkno = hint + 1;\r\nif (blkno >= bmp->db_mapsize)\r\ngoto pref_ag;\r\nagno = blkno >> bmp->db_agl2size;\r\nif ((blkno & (bmp->db_agsize - 1)) == 0)\r\nif (atomic_read(&bmp->db_active[agno]))\r\ngoto pref_ag;\r\nif (nblocks <= BPERDMAP) {\r\nIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nrc = -EIO;\r\nlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\r\nmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL)\r\ngoto read_unlock;\r\ndp = (struct dmap *) mp->data;\r\nif ((rc = dbAllocNext(bmp, dp, blkno, (int) nblocks))\r\n!= -ENOSPC) {\r\nif (rc == 0) {\r\n*results = blkno;\r\nmark_metapage_dirty(mp);\r\n}\r\nrelease_metapage(mp);\r\ngoto read_unlock;\r\n}\r\nwriters = atomic_read(&bmp->db_active[agno]);\r\nif ((writers > 1) ||\r\n((writers == 1) && (JFS_IP(ip)->active_ag != agno))) {\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipbmap);\r\ngoto pref_ag;\r\n}\r\nif ((rc =\r\ndbAllocNear(bmp, dp, blkno, (int) nblocks, l2nb, results))\r\n!= -ENOSPC) {\r\nif (rc == 0)\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\ngoto read_unlock;\r\n}\r\nif ((rc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results))\r\n!= -ENOSPC) {\r\nif (rc == 0)\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\ngoto read_unlock;\r\n}\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipbmap);\r\n}\r\nIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) != -ENOSPC)\r\ngoto write_unlock;\r\nIWRITE_UNLOCK(ipbmap);\r\npref_ag:\r\nagno = dbNextAG(ipbmap);\r\nIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nif ((rc = dbAllocAG(bmp, agno, nblocks, l2nb, results)) == -ENOSPC)\r\nrc = dbAllocAny(bmp, nblocks, l2nb, results);\r\nwrite_unlock:\r\nIWRITE_UNLOCK(ipbmap);\r\nreturn (rc);\r\nread_unlock:\r\nIREAD_UNLOCK(ipbmap);\r\nreturn (rc);\r\n}\r\nint dbAllocExact(struct inode *ip, s64 blkno, int nblocks)\r\n{\r\nint rc;\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\r\nstruct dmap *dp;\r\ns64 lblkno;\r\nstruct metapage *mp;\r\nIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nif (nblocks <= 0 || nblocks > BPERDMAP || blkno >= bmp->db_mapsize) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -EINVAL;\r\n}\r\nif (nblocks > ((s64) 1 << bmp->db_maxfreebud)) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -ENOSPC;\r\n}\r\nlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\r\nmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -EIO;\r\n}\r\ndp = (struct dmap *) mp->data;\r\nrc = dbAllocNext(bmp, dp, blkno, nblocks);\r\nIREAD_UNLOCK(ipbmap);\r\nif (rc == 0)\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\nint\r\ndbReAlloc(struct inode *ip,\r\ns64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\r\n{\r\nint rc;\r\nif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\r\n*results = blkno;\r\nreturn (0);\r\n} else {\r\nif (rc != -ENOSPC)\r\nreturn (rc);\r\n}\r\nreturn (dbAlloc\r\n(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\r\n}\r\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\r\ns64 lblkno, lastblkno, extblkno;\r\nuint rel_block;\r\nstruct metapage *mp;\r\nstruct dmap *dp;\r\nint rc;\r\nstruct inode *ipbmap = sbi->ipbmap;\r\nstruct bmap *bmp;\r\nif (((rel_block = blkno & (sbi->nbperpage - 1))) &&\r\n(rel_block + nblocks + addnblocks > sbi->nbperpage))\r\nreturn -ENOSPC;\r\nlastblkno = blkno + nblocks - 1;\r\nextblkno = lastblkno + 1;\r\nIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nbmp = sbi->bmap;\r\nif (lastblkno < 0 || lastblkno >= bmp->db_mapsize) {\r\nIREAD_UNLOCK(ipbmap);\r\njfs_error(ip->i_sb,\r\n"dbExtend: the block is outside the filesystem");\r\nreturn -EIO;\r\n}\r\nif (addnblocks > BPERDMAP || extblkno >= bmp->db_mapsize ||\r\n(extblkno & (bmp->db_agsize - 1)) == 0) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -ENOSPC;\r\n}\r\nlblkno = BLKTODMAP(extblkno, bmp->db_l2nbperpage);\r\nmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -EIO;\r\n}\r\ndp = (struct dmap *) mp->data;\r\nrc = dbAllocNext(bmp, dp, extblkno, (int) addnblocks);\r\nIREAD_UNLOCK(ipbmap);\r\nif (rc == 0)\r\nwrite_metapage(mp);\r\nelse\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\r\nint nblocks)\r\n{\r\nint dbitno, word, rembits, nb, nwords, wbitno, nw;\r\nint l2size;\r\ns8 *leaf;\r\nu32 mask;\r\nif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocNext: Corrupt dmap page");\r\nreturn -EIO;\r\n}\r\nleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\r\ndbitno = blkno & (BPERDMAP - 1);\r\nword = dbitno >> L2DBWORD;\r\nif (dbitno + nblocks > BPERDMAP)\r\nreturn -ENOSPC;\r\nif (leaf[word] == NOFREE)\r\nreturn -ENOSPC;\r\nfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\r\nwbitno = dbitno & (DBWORD - 1);\r\nnb = min(rembits, DBWORD - wbitno);\r\nif (nb < DBWORD) {\r\nmask = (ONES << (DBWORD - nb) >> wbitno);\r\nif ((mask & ~le32_to_cpu(dp->wmap[word])) != mask)\r\nreturn -ENOSPC;\r\nword += 1;\r\n} else {\r\nnwords = rembits >> L2DBWORD;\r\nnb = nwords << L2DBWORD;\r\nwhile (nwords > 0) {\r\nif (leaf[word] < BUDMIN)\r\nreturn -ENOSPC;\r\nl2size =\r\nmin((int)leaf[word], NLSTOL2BSZ(nwords));\r\nnw = BUDSIZE(l2size, BUDMIN);\r\nnwords -= nw;\r\nword += nw;\r\n}\r\n}\r\n}\r\nreturn (dbAllocDmap(bmp, dp, blkno, nblocks));\r\n}\r\nstatic int\r\ndbAllocNear(struct bmap * bmp,\r\nstruct dmap * dp, s64 blkno, int nblocks, int l2nb, s64 * results)\r\n{\r\nint word, lword, rc;\r\ns8 *leaf;\r\nif (dp->tree.leafidx != cpu_to_le32(LEAFIND)) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocNear: Corrupt dmap page");\r\nreturn -EIO;\r\n}\r\nleaf = dp->tree.stree + le32_to_cpu(dp->tree.leafidx);\r\nword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\r\nlword = min(word + 4, LPERDMAP);\r\nfor (; word < lword; word++) {\r\nif (leaf[word] < l2nb)\r\ncontinue;\r\nblkno = le64_to_cpu(dp->start) + (word << L2DBWORD);\r\nif (leaf[word] < BUDMIN)\r\nblkno +=\r\ndbFindBits(le32_to_cpu(dp->wmap[word]), l2nb);\r\nif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\r\n*results = blkno;\r\nreturn (rc);\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int\r\ndbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb, s64 * results)\r\n{\r\nstruct metapage *mp;\r\nstruct dmapctl *dcp;\r\nint rc, ti, i, k, m, n, agperlev;\r\ns64 blkno, lblkno;\r\nint budmin;\r\nif (l2nb > bmp->db_agl2size) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAG: allocation request is larger than the "\r\n"allocation group size");\r\nreturn -EIO;\r\n}\r\nblkno = (s64) agno << bmp->db_agl2size;\r\nif (bmp->db_agsize == BPERDMAP\r\n|| bmp->db_agfree[agno] == bmp->db_agsize) {\r\nrc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\r\nif ((rc == -ENOSPC) &&\r\n(bmp->db_agfree[agno] == bmp->db_agsize)) {\r\nprintk(KERN_ERR "blkno = %Lx, blocks = %Lx\n",\r\n(unsigned long long) blkno,\r\n(unsigned long long) nblocks);\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAG: dbAllocCtl failed in free AG");\r\n}\r\nreturn (rc);\r\n}\r\nlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, bmp->db_aglevel);\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL)\r\nreturn -EIO;\r\ndcp = (struct dmapctl *) mp->data;\r\nbudmin = dcp->budmin;\r\nif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAG: Corrupt dmapctl page");\r\nrelease_metapage(mp);\r\nreturn -EIO;\r\n}\r\nagperlev =\r\n(1 << (L2LPERCTL - (bmp->db_agheight << 1))) / bmp->db_agwidth;\r\nti = bmp->db_agstart + bmp->db_agwidth * (agno & (agperlev - 1));\r\nfor (i = 0; i < bmp->db_agwidth; i++, ti++) {\r\nif (l2nb > dcp->stree[ti])\r\ncontinue;\r\nfor (k = bmp->db_agheight; k > 0; k--) {\r\nfor (n = 0, m = (ti << 2) + 1; n < 4; n++) {\r\nif (l2nb <= dcp->stree[m + n]) {\r\nti = m + n;\r\nbreak;\r\n}\r\n}\r\nif (n == 4) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAG: failed descending stree");\r\nrelease_metapage(mp);\r\nreturn -EIO;\r\n}\r\n}\r\nif (bmp->db_aglevel == 2)\r\nblkno = 0;\r\nelse if (bmp->db_aglevel == 1)\r\nblkno &= ~(MAXL1SIZE - 1);\r\nelse\r\nblkno &= ~(MAXL0SIZE - 1);\r\nblkno +=\r\n((s64) (ti - le32_to_cpu(dcp->leafidx))) << budmin;\r\nrelease_metapage(mp);\r\nif (l2nb < budmin) {\r\nif ((rc =\r\ndbFindCtl(bmp, l2nb, bmp->db_aglevel - 1,\r\n&blkno))) {\r\nif (rc == -ENOSPC) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAG: control page "\r\n"inconsistent");\r\nreturn -EIO;\r\n}\r\nreturn (rc);\r\n}\r\n}\r\nrc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\r\nif (rc == -ENOSPC) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAG: unable to allocate blocks");\r\nrc = -EIO;\r\n}\r\nreturn (rc);\r\n}\r\nrelease_metapage(mp);\r\nreturn -ENOSPC;\r\n}\r\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results)\r\n{\r\nint rc;\r\ns64 blkno = 0;\r\nif ((rc = dbFindCtl(bmp, l2nb, bmp->db_maxlevel, &blkno)))\r\nreturn (rc);\r\nrc = dbAllocCtl(bmp, nblocks, l2nb, blkno, results);\r\nif (rc == -ENOSPC) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocAny: unable to allocate blocks");\r\nreturn -EIO;\r\n}\r\nreturn (rc);\r\n}\r\ns64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\r\n{\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\r\ns64 nblocks, blkno;\r\nu64 trimmed = 0;\r\nint rc, l2nb;\r\nstruct super_block *sb = ipbmap->i_sb;\r\nstruct range2trim {\r\nu64 blkno;\r\nu64 nblocks;\r\n} *totrim, *tt;\r\nint count = 0, range_cnt;\r\nu64 max_ranges;\r\nIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nnblocks = bmp->db_agfree[agno];\r\nmax_ranges = nblocks;\r\ndo_div(max_ranges, minlen);\r\nrange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\r\ntotrim = kmalloc(sizeof(struct range2trim) * range_cnt, GFP_NOFS);\r\nif (totrim == NULL) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbDiscardAG: no memory for trim array");\r\nIWRITE_UNLOCK(ipbmap);\r\nreturn 0;\r\n}\r\ntt = totrim;\r\nwhile (nblocks >= minlen) {\r\nl2nb = BLKSTOL2(nblocks);\r\nrc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\r\nif (rc == 0) {\r\ntt->blkno = blkno;\r\ntt->nblocks = nblocks;\r\ntt++; count++;\r\nif (bmp->db_agfree[agno] == 0)\r\nbreak;\r\nnblocks = bmp->db_agfree[agno];\r\ncontinue;\r\n} else if (rc == -ENOSPC) {\r\nl2nb = BLKSTOL2(nblocks) - 1;\r\nnblocks = 1 << l2nb;\r\n} else {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbDiscardAG: -EIO");\r\nbreak;\r\n}\r\nif (unlikely(count >= range_cnt - 1))\r\nbreak;\r\n}\r\nIWRITE_UNLOCK(ipbmap);\r\ntt->nblocks = 0;\r\nfor (tt = totrim; tt->nblocks != 0; tt++) {\r\nif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\r\njfs_issue_discard(ip, tt->blkno, tt->nblocks);\r\ndbFree(ip, tt->blkno, tt->nblocks);\r\ntrimmed += tt->nblocks;\r\n}\r\nkfree(totrim);\r\nreturn trimmed;\r\n}\r\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)\r\n{\r\nint rc, leafidx, lev;\r\ns64 b, lblkno;\r\nstruct dmapctl *dcp;\r\nint budmin;\r\nstruct metapage *mp;\r\nfor (lev = level, b = *blkno; lev >= 0; lev--) {\r\nlblkno = BLKTOCTL(b, bmp->db_l2nbperpage, lev);\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL)\r\nreturn -EIO;\r\ndcp = (struct dmapctl *) mp->data;\r\nbudmin = dcp->budmin;\r\nif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbFindCtl: Corrupt dmapctl page");\r\nrelease_metapage(mp);\r\nreturn -EIO;\r\n}\r\nrc = dbFindLeaf((dmtree_t *) dcp, l2nb, &leafidx);\r\nrelease_metapage(mp);\r\nif (rc) {\r\nif (lev != level) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbFindCtl: dmap inconsistent");\r\nreturn -EIO;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nb += (((s64) leafidx) << budmin);\r\nif (l2nb >= budmin)\r\nbreak;\r\n}\r\n*blkno = b;\r\nreturn (0);\r\n}\r\nstatic int\r\ndbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno, s64 * results)\r\n{\r\nint rc, nb;\r\ns64 b, lblkno, n;\r\nstruct metapage *mp;\r\nstruct dmap *dp;\r\nif (l2nb <= L2BPERDMAP) {\r\nlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL)\r\nreturn -EIO;\r\ndp = (struct dmap *) mp->data;\r\nrc = dbAllocDmapLev(bmp, dp, (int) nblocks, l2nb, results);\r\nif (rc == 0)\r\nmark_metapage_dirty(mp);\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\nassert((blkno & (BPERDMAP - 1)) == 0);\r\nfor (n = nblocks, b = blkno; n > 0; n -= nb, b += nb) {\r\nlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL) {\r\nrc = -EIO;\r\ngoto backout;\r\n}\r\ndp = (struct dmap *) mp->data;\r\nif (dp->tree.stree[ROOT] != L2BPERDMAP) {\r\nrelease_metapage(mp);\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocCtl: the dmap is not all free");\r\nrc = -EIO;\r\ngoto backout;\r\n}\r\nnb = min(n, (s64)BPERDMAP);\r\nif ((rc = dbAllocDmap(bmp, dp, b, nb))) {\r\nrelease_metapage(mp);\r\ngoto backout;\r\n}\r\nwrite_metapage(mp);\r\n}\r\n*results = blkno;\r\nreturn (0);\r\nbackout:\r\nfor (n = nblocks - n, b = blkno; n > 0;\r\nn -= BPERDMAP, b += BPERDMAP) {\r\nlblkno = BLKTODMAP(b, bmp->db_l2nbperpage);\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocCtl: I/O Error: Block Leakage.");\r\ncontinue;\r\n}\r\ndp = (struct dmap *) mp->data;\r\nif (dbFreeDmap(bmp, dp, b, BPERDMAP)) {\r\nrelease_metapage(mp);\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocCtl: Block Leakage.");\r\ncontinue;\r\n}\r\nwrite_metapage(mp);\r\n}\r\nreturn (rc);\r\n}\r\nstatic int\r\ndbAllocDmapLev(struct bmap * bmp,\r\nstruct dmap * dp, int nblocks, int l2nb, s64 * results)\r\n{\r\ns64 blkno;\r\nint leafidx, rc;\r\nassert(l2nb <= L2BPERDMAP);\r\nif (dbFindLeaf((dmtree_t *) & dp->tree, l2nb, &leafidx))\r\nreturn -ENOSPC;\r\nblkno = le64_to_cpu(dp->start) + (leafidx << L2DBWORD);\r\nif (dp->tree.stree[leafidx + LEAFIND] < BUDMIN)\r\nblkno += dbFindBits(le32_to_cpu(dp->wmap[leafidx]), l2nb);\r\nif ((rc = dbAllocDmap(bmp, dp, blkno, nblocks)) == 0)\r\n*results = blkno;\r\nreturn (rc);\r\n}\r\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\r\nint nblocks)\r\n{\r\ns8 oldroot;\r\nint rc;\r\noldroot = dp->tree.stree[ROOT];\r\ndbAllocBits(bmp, dp, blkno, nblocks);\r\nif (dp->tree.stree[ROOT] == oldroot)\r\nreturn (0);\r\nif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 1, 0)))\r\ndbFreeBits(bmp, dp, blkno, nblocks);\r\nreturn (rc);\r\n}\r\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\r\nint nblocks)\r\n{\r\ns8 oldroot;\r\nint rc = 0, word;\r\noldroot = dp->tree.stree[ROOT];\r\nrc = dbFreeBits(bmp, dp, blkno, nblocks);\r\nif (rc || (dp->tree.stree[ROOT] == oldroot))\r\nreturn (rc);\r\nif ((rc = dbAdjCtl(bmp, blkno, dp->tree.stree[ROOT], 0, 0))) {\r\nword = (blkno & (BPERDMAP - 1)) >> L2DBWORD;\r\nif (dp->tree.stree[word] == NOFREE)\r\ndbBackSplit((dmtree_t *) & dp->tree, word);\r\ndbAllocBits(bmp, dp, blkno, nblocks);\r\n}\r\nreturn (rc);\r\n}\r\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\r\nint nblocks)\r\n{\r\nint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\r\ndmtree_t *tp = (dmtree_t *) & dp->tree;\r\nint size;\r\ns8 *leaf;\r\nleaf = dp->tree.stree + LEAFIND;\r\ndbitno = blkno & (BPERDMAP - 1);\r\nword = dbitno >> L2DBWORD;\r\nassert(dbitno + nblocks <= BPERDMAP);\r\nfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\r\nwbitno = dbitno & (DBWORD - 1);\r\nnb = min(rembits, DBWORD - wbitno);\r\nif (nb < DBWORD) {\r\ndp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\r\n>> wbitno);\r\ndbSplit(tp, word, BUDMIN,\r\ndbMaxBud((u8 *) & dp->wmap[word]));\r\nword += 1;\r\n} else {\r\nnwords = rembits >> L2DBWORD;\r\nmemset(&dp->wmap[word], (int) ONES, nwords * 4);\r\nnb = nwords << L2DBWORD;\r\nfor (; nwords > 0; nwords -= nw) {\r\nif (leaf[word] < BUDMIN) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAllocBits: leaf page "\r\n"corrupt");\r\nbreak;\r\n}\r\nsize = min((int)leaf[word], NLSTOL2BSZ(nwords));\r\ndbSplit(tp, word, size, NOFREE);\r\nnw = BUDSIZE(size, BUDMIN);\r\nword += nw;\r\n}\r\n}\r\n}\r\nle32_add_cpu(&dp->nfree, -nblocks);\r\nBMAP_LOCK(bmp);\r\nagno = blkno >> bmp->db_agl2size;\r\nif (agno > bmp->db_maxag)\r\nbmp->db_maxag = agno;\r\nbmp->db_agfree[agno] -= nblocks;\r\nbmp->db_nfree -= nblocks;\r\nBMAP_UNLOCK(bmp);\r\n}\r\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\r\nint nblocks)\r\n{\r\nint dbitno, word, rembits, nb, nwords, wbitno, nw, agno;\r\ndmtree_t *tp = (dmtree_t *) & dp->tree;\r\nint rc = 0;\r\nint size;\r\ndbitno = blkno & (BPERDMAP - 1);\r\nword = dbitno >> L2DBWORD;\r\nassert(dbitno + nblocks <= BPERDMAP);\r\nfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\r\nwbitno = dbitno & (DBWORD - 1);\r\nnb = min(rembits, DBWORD - wbitno);\r\nif (nb < DBWORD) {\r\ndp->wmap[word] &=\r\ncpu_to_le32(~(ONES << (DBWORD - nb)\r\n>> wbitno));\r\nrc = dbJoin(tp, word,\r\ndbMaxBud((u8 *) & dp->wmap[word]));\r\nif (rc)\r\nreturn rc;\r\nword += 1;\r\n} else {\r\nnwords = rembits >> L2DBWORD;\r\nmemset(&dp->wmap[word], 0, nwords * 4);\r\nnb = nwords << L2DBWORD;\r\nfor (; nwords > 0; nwords -= nw) {\r\nsize =\r\nmin(LITOL2BSZ\r\n(word, L2LPERDMAP, BUDMIN),\r\nNLSTOL2BSZ(nwords));\r\nrc = dbJoin(tp, word, size);\r\nif (rc)\r\nreturn rc;\r\nnw = BUDSIZE(size, BUDMIN);\r\nword += nw;\r\n}\r\n}\r\n}\r\nle32_add_cpu(&dp->nfree, nblocks);\r\nBMAP_LOCK(bmp);\r\nagno = blkno >> bmp->db_agl2size;\r\nbmp->db_nfree += nblocks;\r\nbmp->db_agfree[agno] += nblocks;\r\nif ((bmp->db_agfree[agno] == bmp->db_agsize && agno == bmp->db_maxag) ||\r\n(agno == bmp->db_numag - 1 &&\r\nbmp->db_agfree[agno] == (bmp-> db_mapsize & (BPERDMAP - 1)))) {\r\nwhile (bmp->db_maxag > 0) {\r\nbmp->db_maxag -= 1;\r\nif (bmp->db_agfree[bmp->db_maxag] !=\r\nbmp->db_agsize)\r\nbreak;\r\n}\r\nif (bmp->db_agpref > bmp->db_maxag)\r\nbmp->db_agpref = bmp->db_maxag;\r\n}\r\nBMAP_UNLOCK(bmp);\r\nreturn 0;\r\n}\r\nstatic int\r\ndbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc, int level)\r\n{\r\nstruct metapage *mp;\r\ns8 oldroot;\r\nint oldval;\r\ns64 lblkno;\r\nstruct dmapctl *dcp;\r\nint rc, leafno, ti;\r\nlblkno = BLKTOCTL(blkno, bmp->db_l2nbperpage, level);\r\nmp = read_metapage(bmp->db_ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL)\r\nreturn -EIO;\r\ndcp = (struct dmapctl *) mp->data;\r\nif (dcp->leafidx != cpu_to_le32(CTLLEAFIND)) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAdjCtl: Corrupt dmapctl page");\r\nrelease_metapage(mp);\r\nreturn -EIO;\r\n}\r\nleafno = BLKTOCTLLEAF(blkno, dcp->budmin);\r\nti = leafno + le32_to_cpu(dcp->leafidx);\r\noldval = dcp->stree[ti];\r\noldroot = dcp->stree[ROOT];\r\nif (alloc) {\r\nif (oldval == NOFREE) {\r\nrc = dbBackSplit((dmtree_t *) dcp, leafno);\r\nif (rc)\r\nreturn rc;\r\noldval = dcp->stree[ti];\r\n}\r\ndbSplit((dmtree_t *) dcp, leafno, dcp->budmin, newval);\r\n} else {\r\nrc = dbJoin((dmtree_t *) dcp, leafno, newval);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (dcp->stree[ROOT] != oldroot) {\r\nif (level < bmp->db_maxlevel) {\r\nif ((rc =\r\ndbAdjCtl(bmp, blkno, dcp->stree[ROOT], alloc,\r\nlevel + 1))) {\r\nif (alloc) {\r\ndbJoin((dmtree_t *) dcp, leafno,\r\noldval);\r\n} else {\r\nif (dcp->stree[ti] == NOFREE)\r\ndbBackSplit((dmtree_t *)\r\ndcp, leafno);\r\ndbSplit((dmtree_t *) dcp, leafno,\r\ndcp->budmin, oldval);\r\n}\r\nrelease_metapage(mp);\r\nreturn (rc);\r\n}\r\n} else {\r\nassert(level == bmp->db_maxlevel);\r\nif (bmp->db_maxfreebud != oldroot) {\r\njfs_error(bmp->db_ipbmap->i_sb,\r\n"dbAdjCtl: the maximum free buddy is "\r\n"not the old root");\r\n}\r\nbmp->db_maxfreebud = dcp->stree[ROOT];\r\n}\r\n}\r\nwrite_metapage(mp);\r\nreturn (0);\r\n}\r\nstatic void dbSplit(dmtree_t * tp, int leafno, int splitsz, int newval)\r\n{\r\nint budsz;\r\nint cursz;\r\ns8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\r\nif (leaf[leafno] > tp->dmt_budmin) {\r\ncursz = leaf[leafno] - 1;\r\nbudsz = BUDSIZE(cursz, tp->dmt_budmin);\r\nwhile (cursz >= splitsz) {\r\ndbAdjTree(tp, leafno ^ budsz, cursz);\r\ncursz -= 1;\r\nbudsz >>= 1;\r\n}\r\n}\r\ndbAdjTree(tp, leafno, newval);\r\n}\r\nstatic int dbBackSplit(dmtree_t * tp, int leafno)\r\n{\r\nint budsz, bud, w, bsz, size;\r\nint cursz;\r\ns8 *leaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\r\nassert(leaf[leafno] == NOFREE);\r\nsize =\r\nLITOL2BSZ(leafno, le32_to_cpu(tp->dmt_l2nleafs),\r\ntp->dmt_budmin);\r\nbudsz = BUDSIZE(size, tp->dmt_budmin);\r\nwhile (leaf[leafno] == NOFREE) {\r\nfor (w = leafno, bsz = budsz;; bsz <<= 1,\r\nw = (w < bud) ? w : bud) {\r\nif (bsz >= le32_to_cpu(tp->dmt_nleafs)) {\r\njfs_err("JFS: block map error in dbBackSplit");\r\nreturn -EIO;\r\n}\r\nbud = w ^ bsz;\r\nif (leaf[bud] != NOFREE) {\r\ncursz = leaf[bud] - 1;\r\ndbSplit(tp, bud, cursz, cursz);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (leaf[leafno] != size) {\r\njfs_err("JFS: wrong leaf value in dbBackSplit");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dbJoin(dmtree_t * tp, int leafno, int newval)\r\n{\r\nint budsz, buddy;\r\ns8 *leaf;\r\nif (newval >= tp->dmt_budmin) {\r\nleaf = tp->dmt_stree + le32_to_cpu(tp->dmt_leafidx);\r\nbudsz = BUDSIZE(newval, tp->dmt_budmin);\r\nwhile (budsz < le32_to_cpu(tp->dmt_nleafs)) {\r\nbuddy = leafno ^ budsz;\r\nif (newval > leaf[buddy])\r\nbreak;\r\nif (newval < leaf[buddy])\r\nreturn -EIO;\r\nif (leafno < buddy) {\r\ndbAdjTree(tp, buddy, NOFREE);\r\n} else {\r\ndbAdjTree(tp, leafno, NOFREE);\r\nleafno = buddy;\r\n}\r\nnewval += 1;\r\nbudsz <<= 1;\r\n}\r\n}\r\ndbAdjTree(tp, leafno, newval);\r\nreturn 0;\r\n}\r\nstatic void dbAdjTree(dmtree_t * tp, int leafno, int newval)\r\n{\r\nint lp, pp, k;\r\nint max;\r\nlp = leafno + le32_to_cpu(tp->dmt_leafidx);\r\nif (tp->dmt_stree[lp] == newval)\r\nreturn;\r\ntp->dmt_stree[lp] = newval;\r\nfor (k = 0; k < le32_to_cpu(tp->dmt_height); k++) {\r\nlp = ((lp - 1) & ~0x03) + 1;\r\npp = (lp - 1) >> 2;\r\nmax = TREEMAX(&tp->dmt_stree[lp]);\r\nif (tp->dmt_stree[pp] == max)\r\nbreak;\r\ntp->dmt_stree[pp] = max;\r\nlp = pp;\r\n}\r\n}\r\nstatic int dbFindLeaf(dmtree_t * tp, int l2nb, int *leafidx)\r\n{\r\nint ti, n = 0, k, x = 0;\r\nif (l2nb > tp->dmt_stree[ROOT])\r\nreturn -ENOSPC;\r\nfor (k = le32_to_cpu(tp->dmt_height), ti = 1;\r\nk > 0; k--, ti = ((ti + n) << 2) + 1) {\r\nfor (x = ti, n = 0; n < 4; n++) {\r\nif (l2nb <= tp->dmt_stree[x + n])\r\nbreak;\r\n}\r\nassert(n < 4);\r\n}\r\n*leafidx = x + n - le32_to_cpu(tp->dmt_leafidx);\r\nreturn (0);\r\n}\r\nstatic int dbFindBits(u32 word, int l2nb)\r\n{\r\nint bitno, nb;\r\nu32 mask;\r\nnb = 1 << l2nb;\r\nassert(nb <= DBWORD);\r\nword = ~word;\r\nmask = ONES << (DBWORD - nb);\r\nfor (bitno = 0; mask != 0; bitno += nb, mask >>= nb) {\r\nif ((mask & word) == mask)\r\nbreak;\r\n}\r\nASSERT(bitno < 32);\r\nreturn (bitno);\r\n}\r\nstatic int dbMaxBud(u8 * cp)\r\n{\r\nsigned char tmp1, tmp2;\r\nif (*((uint *) cp) == 0)\r\nreturn (BUDMIN);\r\nif (*((u16 *) cp) == 0 || *((u16 *) cp + 1) == 0)\r\nreturn (BUDMIN - 1);\r\ntmp1 = max(budtab[cp[2]], budtab[cp[3]]);\r\ntmp2 = max(budtab[cp[0]], budtab[cp[1]]);\r\nreturn (max(tmp1, tmp2));\r\n}\r\nstatic int cnttz(u32 word)\r\n{\r\nint n;\r\nfor (n = 0; n < 32; n++, word >>= 1) {\r\nif (word & 0x01)\r\nbreak;\r\n}\r\nreturn (n);\r\n}\r\nstatic int cntlz(u32 value)\r\n{\r\nint n;\r\nfor (n = 0; n < 32; n++, value <<= 1) {\r\nif (value & HIGHORDER)\r\nbreak;\r\n}\r\nreturn (n);\r\n}\r\nstatic int blkstol2(s64 nb)\r\n{\r\nint l2nb;\r\ns64 mask;\r\nmask = (s64) 1 << (64 - 1);\r\nfor (l2nb = 0; l2nb < 64; l2nb++, mask >>= 1) {\r\nif (nb & mask) {\r\nl2nb = (64 - 1) - l2nb;\r\nif (~mask & nb)\r\nl2nb++;\r\nreturn (l2nb);\r\n}\r\n}\r\nassert(0);\r\nreturn 0;\r\n}\r\nint dbAllocBottomUp(struct inode *ip, s64 blkno, s64 nblocks)\r\n{\r\nstruct metapage *mp;\r\nstruct dmap *dp;\r\nint nb, rc;\r\ns64 lblkno, rem;\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\r\nIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\r\nASSERT(nblocks <= bmp->db_mapsize - blkno);\r\nmp = NULL;\r\nfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\r\nif (mp) {\r\nwrite_metapage(mp);\r\n}\r\nlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\r\nmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\r\nif (mp == NULL) {\r\nIREAD_UNLOCK(ipbmap);\r\nreturn -EIO;\r\n}\r\ndp = (struct dmap *) mp->data;\r\nnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\r\nif ((rc = dbAllocDmapBU(bmp, dp, blkno, nb))) {\r\nrelease_metapage(mp);\r\nIREAD_UNLOCK(ipbmap);\r\nreturn (rc);\r\n}\r\n}\r\nwrite_metapage(mp);\r\nIREAD_UNLOCK(ipbmap);\r\nreturn (0);\r\n}\r\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\r\nint nblocks)\r\n{\r\nint rc;\r\nint dbitno, word, rembits, nb, nwords, wbitno, agno;\r\ns8 oldroot;\r\nstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\r\noldroot = tp->stree[ROOT];\r\ndbitno = blkno & (BPERDMAP - 1);\r\nword = dbitno >> L2DBWORD;\r\nassert(dbitno + nblocks <= BPERDMAP);\r\nfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\r\nwbitno = dbitno & (DBWORD - 1);\r\nnb = min(rembits, DBWORD - wbitno);\r\nif (nb < DBWORD) {\r\ndp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\r\n>> wbitno);\r\nword++;\r\n} else {\r\nnwords = rembits >> L2DBWORD;\r\nmemset(&dp->wmap[word], (int) ONES, nwords * 4);\r\nnb = nwords << L2DBWORD;\r\nword += nwords;\r\n}\r\n}\r\nle32_add_cpu(&dp->nfree, -nblocks);\r\ndbInitDmapTree(dp);\r\nBMAP_LOCK(bmp);\r\nagno = blkno >> bmp->db_agl2size;\r\nif (agno > bmp->db_maxag)\r\nbmp->db_maxag = agno;\r\nbmp->db_agfree[agno] -= nblocks;\r\nbmp->db_nfree -= nblocks;\r\nBMAP_UNLOCK(bmp);\r\nif (tp->stree[ROOT] == oldroot)\r\nreturn (0);\r\nif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\r\ndbFreeBits(bmp, dp, blkno, nblocks);\r\nreturn (rc);\r\n}\r\nint dbExtendFS(struct inode *ipbmap, s64 blkno, s64 nblocks)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(ipbmap->i_sb);\r\nint nbperpage = sbi->nbperpage;\r\nint i, i0 = true, j, j0 = true, k, n;\r\ns64 newsize;\r\ns64 p;\r\nstruct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;\r\nstruct dmapctl *l2dcp, *l1dcp, *l0dcp;\r\nstruct dmap *dp;\r\ns8 *l0leaf, *l1leaf, *l2leaf;\r\nstruct bmap *bmp = sbi->bmap;\r\nint agno, l2agsize, oldl2agsize;\r\ns64 ag_rem;\r\nnewsize = blkno + nblocks;\r\njfs_info("dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld",\r\n(long long) blkno, (long long) nblocks, (long long) newsize);\r\nbmp->db_mapsize = newsize;\r\nbmp->db_maxlevel = BMAPSZTOLEV(bmp->db_mapsize);\r\nl2agsize = dbGetL2AGSize(newsize);\r\noldl2agsize = bmp->db_agl2size;\r\nbmp->db_agl2size = l2agsize;\r\nbmp->db_agsize = 1 << l2agsize;\r\nagno = bmp->db_numag;\r\nbmp->db_numag = newsize >> l2agsize;\r\nbmp->db_numag += ((u32) newsize % (u32) bmp->db_agsize) ? 1 : 0;\r\nif (l2agsize == oldl2agsize)\r\ngoto extend;\r\nk = 1 << (l2agsize - oldl2agsize);\r\nag_rem = bmp->db_agfree[0];\r\nfor (i = 0, n = 0; i < agno; n++) {\r\nbmp->db_agfree[n] = 0;\r\nfor (j = 0; j < k && i < agno; j++, i++) {\r\nbmp->db_agfree[n] += bmp->db_agfree[i];\r\n}\r\n}\r\nbmp->db_agfree[0] += ag_rem;\r\nfor (; n < MAXAG; n++)\r\nbmp->db_agfree[n] = 0;\r\nbmp->db_maxag = bmp->db_maxag / k;\r\nextend:\r\np = BMAPBLKNO + nbperpage;\r\nl2mp = read_metapage(ipbmap, p, PSIZE, 0);\r\nif (!l2mp) {\r\njfs_error(ipbmap->i_sb, "dbExtendFS: L2 page could not be read");\r\nreturn -EIO;\r\n}\r\nl2dcp = (struct dmapctl *) l2mp->data;\r\nk = blkno >> L2MAXL1SIZE;\r\nl2leaf = l2dcp->stree + CTLLEAFIND + k;\r\np = BLKTOL1(blkno, sbi->l2nbperpage);\r\nfor (; k < LPERCTL; k++, p += nbperpage) {\r\nif (j0) {\r\nl1mp = read_metapage(ipbmap, p, PSIZE, 0);\r\nif (l1mp == NULL)\r\ngoto errout;\r\nl1dcp = (struct dmapctl *) l1mp->data;\r\nj = (blkno & (MAXL1SIZE - 1)) >> L2MAXL0SIZE;\r\nl1leaf = l1dcp->stree + CTLLEAFIND + j;\r\np = BLKTOL0(blkno, sbi->l2nbperpage);\r\nj0 = false;\r\n} else {\r\nl1mp = get_metapage(ipbmap, p, PSIZE, 0);\r\nif (l1mp == NULL)\r\ngoto errout;\r\nl1dcp = (struct dmapctl *) l1mp->data;\r\nj = 0;\r\nl1leaf = l1dcp->stree + CTLLEAFIND;\r\np += nbperpage;\r\n}\r\nfor (; j < LPERCTL; j++) {\r\nif (i0) {\r\nl0mp = read_metapage(ipbmap, p, PSIZE, 0);\r\nif (l0mp == NULL)\r\ngoto errout;\r\nl0dcp = (struct dmapctl *) l0mp->data;\r\ni = (blkno & (MAXL0SIZE - 1)) >>\r\nL2BPERDMAP;\r\nl0leaf = l0dcp->stree + CTLLEAFIND + i;\r\np = BLKTODMAP(blkno,\r\nsbi->l2nbperpage);\r\ni0 = false;\r\n} else {\r\nl0mp = get_metapage(ipbmap, p, PSIZE, 0);\r\nif (l0mp == NULL)\r\ngoto errout;\r\nl0dcp = (struct dmapctl *) l0mp->data;\r\ni = 0;\r\nl0leaf = l0dcp->stree + CTLLEAFIND;\r\np += nbperpage;\r\n}\r\nfor (; i < LPERCTL; i++) {\r\nif ((n = blkno & (BPERDMAP - 1))) {\r\nmp = read_metapage(ipbmap, p,\r\nPSIZE, 0);\r\nif (mp == NULL)\r\ngoto errout;\r\nn = min(nblocks, (s64)BPERDMAP - n);\r\n} else {\r\nmp = read_metapage(ipbmap, p,\r\nPSIZE, 0);\r\nif (mp == NULL)\r\ngoto errout;\r\nn = min(nblocks, (s64)BPERDMAP);\r\n}\r\ndp = (struct dmap *) mp->data;\r\n*l0leaf = dbInitDmap(dp, blkno, n);\r\nbmp->db_nfree += n;\r\nagno = le64_to_cpu(dp->start) >> l2agsize;\r\nbmp->db_agfree[agno] += n;\r\nwrite_metapage(mp);\r\nl0leaf++;\r\np += nbperpage;\r\nblkno += n;\r\nnblocks -= n;\r\nif (nblocks == 0)\r\nbreak;\r\n}\r\n*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);\r\nwrite_metapage(l0mp);\r\nl0mp = NULL;\r\nif (nblocks)\r\nl1leaf++;\r\nelse {\r\nif (j > 0)\r\nbreak;\r\nelse {\r\nbmp->db_maxfreebud = *l1leaf;\r\nrelease_metapage(l1mp);\r\nrelease_metapage(l2mp);\r\ngoto finalize;\r\n}\r\n}\r\n}\r\n*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);\r\nwrite_metapage(l1mp);\r\nl1mp = NULL;\r\nif (nblocks)\r\nl2leaf++;\r\nelse {\r\nif (k > 0)\r\nbreak;\r\nelse {\r\nbmp->db_maxfreebud = *l2leaf;\r\nrelease_metapage(l2mp);\r\ngoto finalize;\r\n}\r\n}\r\n}\r\njfs_error(ipbmap->i_sb,\r\n"dbExtendFS: function has not returned as expected");\r\nerrout:\r\nif (l0mp)\r\nrelease_metapage(l0mp);\r\nif (l1mp)\r\nrelease_metapage(l1mp);\r\nrelease_metapage(l2mp);\r\nreturn -EIO;\r\nfinalize:\r\nreturn 0;\r\n}\r\nvoid dbFinalizeBmap(struct inode *ipbmap)\r\n{\r\nstruct bmap *bmp = JFS_SBI(ipbmap->i_sb)->bmap;\r\nint actags, inactags, l2nl;\r\ns64 ag_rem, actfree, inactfree, avgfree;\r\nint i, n;\r\nactags = bmp->db_maxag + 1;\r\ninactags = bmp->db_numag - actags;\r\nag_rem = bmp->db_mapsize & (bmp->db_agsize - 1);\r\ninactfree = (inactags && ag_rem) ?\r\n((inactags - 1) << bmp->db_agl2size) + ag_rem\r\n: inactags << bmp->db_agl2size;\r\nactfree = bmp->db_nfree - inactfree;\r\navgfree = (u32) actfree / (u32) actags;\r\nif (bmp->db_agfree[bmp->db_agpref] < avgfree) {\r\nfor (bmp->db_agpref = 0; bmp->db_agpref < actags;\r\nbmp->db_agpref++) {\r\nif (bmp->db_agfree[bmp->db_agpref] >= avgfree)\r\nbreak;\r\n}\r\nif (bmp->db_agpref >= bmp->db_numag) {\r\njfs_error(ipbmap->i_sb,\r\n"cannot find ag with average freespace");\r\n}\r\n}\r\nbmp->db_aglevel = BMAPSZTOLEV(bmp->db_agsize);\r\nl2nl =\r\nbmp->db_agl2size - (L2BPERDMAP + bmp->db_aglevel * L2LPERCTL);\r\nbmp->db_agheight = l2nl >> 1;\r\nbmp->db_agwidth = 1 << (l2nl - (bmp->db_agheight << 1));\r\nfor (i = 5 - bmp->db_agheight, bmp->db_agstart = 0, n = 1; i > 0;\r\ni--) {\r\nbmp->db_agstart += n;\r\nn <<= 2;\r\n}\r\n}\r\nstatic int dbInitDmap(struct dmap * dp, s64 Blkno, int nblocks)\r\n{\r\nint blkno, w, b, r, nw, nb, i;\r\nblkno = Blkno & (BPERDMAP - 1);\r\nif (blkno == 0) {\r\ndp->nblocks = dp->nfree = cpu_to_le32(nblocks);\r\ndp->start = cpu_to_le64(Blkno);\r\nif (nblocks == BPERDMAP) {\r\nmemset(&dp->wmap[0], 0, LPERDMAP * 4);\r\nmemset(&dp->pmap[0], 0, LPERDMAP * 4);\r\ngoto initTree;\r\n}\r\n} else {\r\nle32_add_cpu(&dp->nblocks, nblocks);\r\nle32_add_cpu(&dp->nfree, nblocks);\r\n}\r\nw = blkno >> L2DBWORD;\r\nfor (r = nblocks; r > 0; r -= nb, blkno += nb) {\r\nb = blkno & (DBWORD - 1);\r\nnb = min(r, DBWORD - b);\r\nif (nb < DBWORD) {\r\ndp->wmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\r\n>> b));\r\ndp->pmap[w] &= cpu_to_le32(~(ONES << (DBWORD - nb)\r\n>> b));\r\nw++;\r\n} else {\r\nnw = r >> L2DBWORD;\r\nmemset(&dp->wmap[w], 0, nw * 4);\r\nmemset(&dp->pmap[w], 0, nw * 4);\r\nnb = nw << L2DBWORD;\r\nw += nw;\r\n}\r\n}\r\nif (blkno == BPERDMAP)\r\ngoto initTree;\r\nw = blkno >> L2DBWORD;\r\nb = blkno & (DBWORD - 1);\r\nif (b) {\r\ndp->wmap[w] = dp->pmap[w] = cpu_to_le32(ONES >> b);\r\nw++;\r\n}\r\nfor (i = w; i < LPERDMAP; i++)\r\ndp->pmap[i] = dp->wmap[i] = cpu_to_le32(ONES);\r\ninitTree:\r\nreturn (dbInitDmapTree(dp));\r\n}\r\nstatic int dbInitDmapTree(struct dmap * dp)\r\n{\r\nstruct dmaptree *tp;\r\ns8 *cp;\r\nint i;\r\ntp = &dp->tree;\r\ntp->nleafs = cpu_to_le32(LPERDMAP);\r\ntp->l2nleafs = cpu_to_le32(L2LPERDMAP);\r\ntp->leafidx = cpu_to_le32(LEAFIND);\r\ntp->height = cpu_to_le32(4);\r\ntp->budmin = BUDMIN;\r\ncp = tp->stree + le32_to_cpu(tp->leafidx);\r\nfor (i = 0; i < LPERDMAP; i++)\r\n*cp++ = dbMaxBud((u8 *) & dp->wmap[i]);\r\nreturn (dbInitTree(tp));\r\n}\r\nstatic int dbInitTree(struct dmaptree * dtp)\r\n{\r\nint l2max, l2free, bsize, nextb, i;\r\nint child, parent, nparent;\r\ns8 *tp, *cp, *cp1;\r\ntp = dtp->stree;\r\nl2max = le32_to_cpu(dtp->l2nleafs) + dtp->budmin;\r\nfor (l2free = dtp->budmin, bsize = 1; l2free < l2max;\r\nl2free++, bsize = nextb) {\r\nnextb = bsize << 1;\r\nfor (i = 0, cp = tp + le32_to_cpu(dtp->leafidx);\r\ni < le32_to_cpu(dtp->nleafs);\r\ni += nextb, cp += nextb) {\r\nif (*cp == l2free && *(cp + bsize) == l2free) {\r\n*cp = l2free + 1;\r\n*(cp + bsize) = -1;\r\n}\r\n}\r\n}\r\nfor (child = le32_to_cpu(dtp->leafidx),\r\nnparent = le32_to_cpu(dtp->nleafs) >> 2;\r\nnparent > 0; nparent >>= 2, child = parent) {\r\nparent = (child - 1) >> 2;\r\nfor (i = 0, cp = tp + child, cp1 = tp + parent;\r\ni < nparent; i++, cp += 4, cp1++)\r\n*cp1 = TREEMAX(cp);\r\n}\r\nreturn (*tp);\r\n}\r\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i)\r\n{\r\ns8 *cp;\r\ndcp->nleafs = cpu_to_le32(LPERCTL);\r\ndcp->l2nleafs = cpu_to_le32(L2LPERCTL);\r\ndcp->leafidx = cpu_to_le32(CTLLEAFIND);\r\ndcp->height = cpu_to_le32(5);\r\ndcp->budmin = L2BPERDMAP + L2LPERCTL * level;\r\ncp = &dcp->stree[CTLLEAFIND + i];\r\nfor (; i < LPERCTL; i++)\r\n*cp++ = NOFREE;\r\nreturn (dbInitTree((struct dmaptree *) dcp));\r\n}\r\nstatic int dbGetL2AGSize(s64 nblocks)\r\n{\r\ns64 sz;\r\ns64 m;\r\nint l2sz;\r\nif (nblocks < BPERDMAP * MAXAG)\r\nreturn (L2BPERDMAP);\r\nm = ((u64) 1 << (64 - 1));\r\nfor (l2sz = 64; l2sz >= 0; l2sz--, m >>= 1) {\r\nif (m & nblocks)\r\nbreak;\r\n}\r\nsz = (s64) 1 << l2sz;\r\nif (sz < nblocks)\r\nl2sz += 1;\r\nreturn (l2sz - L2MAXAG);\r\n}\r\ns64 dbMapFileSizeToMapSize(struct inode * ipbmap)\r\n{\r\nstruct super_block *sb = ipbmap->i_sb;\r\ns64 nblocks;\r\ns64 npages, ndmaps;\r\nint level, i;\r\nint complete, factor;\r\nnblocks = ipbmap->i_size >> JFS_SBI(sb)->l2bsize;\r\nnpages = nblocks >> JFS_SBI(sb)->l2nbperpage;\r\nlevel = BMAPPGTOLEV(npages);\r\nndmaps = 0;\r\nnpages--;\r\nnpages -= (2 - level);\r\nnpages--;\r\nfor (i = level; i >= 0; i--) {\r\nfactor =\r\n(i == 2) ? MAXL1PAGES : ((i == 1) ? MAXL0PAGES : 1);\r\ncomplete = (u32) npages / factor;\r\nndmaps += complete * ((i == 2) ? LPERCTL * LPERCTL :\r\n((i == 1) ? LPERCTL : 1));\r\nnpages = (u32) npages % factor;\r\nnpages--;\r\n}\r\nnblocks = ndmaps << L2BPERDMAP;\r\nreturn (nblocks);\r\n}
