static size_t eeh_gather_pci_data(struct eeh_dev *edev, char * buf, size_t len)\r\n{\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nu32 cfg;\r\nint cap, i;\r\nint n = 0;\r\nn += scnprintf(buf+n, len-n, "%s\n", dn->full_name);\r\nprintk(KERN_WARNING "EEH: of node=%s\n", dn->full_name);\r\neeh_ops->read_config(dn, PCI_VENDOR_ID, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "dev/vend:%08x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI device/vendor: %08x\n", cfg);\r\neeh_ops->read_config(dn, PCI_COMMAND, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "cmd/stat:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI cmd/status register: %08x\n", cfg);\r\nif (!dev) {\r\nprintk(KERN_WARNING "EEH: no PCI device for this of node\n");\r\nreturn n;\r\n}\r\nif (dev->class >> 16 == PCI_BASE_CLASS_BRIDGE) {\r\neeh_ops->read_config(dn, PCI_SEC_STATUS, 2, &cfg);\r\nn += scnprintf(buf+n, len-n, "sec stat:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: Bridge secondary status: %04x\n", cfg);\r\neeh_ops->read_config(dn, PCI_BRIDGE_CONTROL, 2, &cfg);\r\nn += scnprintf(buf+n, len-n, "brdg ctl:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: Bridge control: %04x\n", cfg);\r\n}\r\ncap = pci_find_capability(dev, PCI_CAP_ID_PCIX);\r\nif (cap) {\r\neeh_ops->read_config(dn, cap, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "pcix-cmd:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI-X cmd: %08x\n", cfg);\r\neeh_ops->read_config(dn, cap+4, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "pcix-stat:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI-X status: %08x\n", cfg);\r\n}\r\ncap = pci_find_capability(dev, PCI_CAP_ID_EXP);\r\nif (cap) {\r\nn += scnprintf(buf+n, len-n, "pci-e cap10:\n");\r\nprintk(KERN_WARNING\r\n"EEH: PCI-E capabilities and status follow:\n");\r\nfor (i=0; i<=8; i++) {\r\neeh_ops->read_config(dn, cap+4*i, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "%02x:%x\n", 4*i, cfg);\r\nprintk(KERN_WARNING "EEH: PCI-E %02x: %08x\n", i, cfg);\r\n}\r\ncap = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (cap) {\r\nn += scnprintf(buf+n, len-n, "pci-e AER:\n");\r\nprintk(KERN_WARNING\r\n"EEH: PCI-E AER capability register set follows:\n");\r\nfor (i=0; i<14; i++) {\r\neeh_ops->read_config(dn, cap+4*i, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "%02x:%x\n", 4*i, cfg);\r\nprintk(KERN_WARNING "EEH: PCI-E AER %02x: %08x\n", i, cfg);\r\n}\r\n}\r\n}\r\nreturn n;\r\n}\r\nvoid eeh_slot_error_detail(struct eeh_pe *pe, int severity)\r\n{\r\nsize_t loglen = 0;\r\nstruct eeh_dev *edev;\r\neeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\r\neeh_ops->configure_bridge(pe);\r\neeh_pe_restore_bars(pe);\r\npci_regs_buf[0] = 0;\r\neeh_pe_for_each_dev(pe, edev) {\r\nloglen += eeh_gather_pci_data(edev, pci_regs_buf,\r\nEEH_PCI_REGS_LOG_LEN);\r\n}\r\neeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\r\n}\r\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\r\n{\r\npte_t *ptep;\r\nunsigned long pa;\r\nptep = find_linux_pte(init_mm.pgd, token);\r\nif (!ptep)\r\nreturn token;\r\npa = pte_pfn(*ptep) << PAGE_SHIFT;\r\nreturn pa | (token & (PAGE_SIZE-1));\r\n}\r\nint eeh_dev_check_failure(struct eeh_dev *edev)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct device_node *dn;\r\nstruct pci_dev *dev;\r\nstruct eeh_pe *pe;\r\nint rc = 0;\r\nconst char *location;\r\neeh_stats.total_mmio_ffs++;\r\nif (!eeh_subsystem_enabled)\r\nreturn 0;\r\nif (!edev) {\r\neeh_stats.no_dn++;\r\nreturn 0;\r\n}\r\ndn = eeh_dev_to_of_node(edev);\r\ndev = eeh_dev_to_pci_dev(edev);\r\npe = edev->pe;\r\nif (!pe) {\r\neeh_stats.ignored_check++;\r\npr_debug("EEH: Ignored check for %s %s\n",\r\neeh_pci_name(dev), dn->full_name);\r\nreturn 0;\r\n}\r\nif (!pe->addr && !pe->config_addr) {\r\neeh_stats.no_cfg_addr++;\r\nreturn 0;\r\n}\r\nraw_spin_lock_irqsave(&confirm_error_lock, flags);\r\nrc = 1;\r\nif (pe->state & EEH_PE_ISOLATED) {\r\npe->check_count++;\r\nif (pe->check_count % EEH_MAX_FAILS == 0) {\r\nlocation = of_get_property(dn, "ibm,loc-code", NULL);\r\nprintk(KERN_ERR "EEH: %d reads ignored for recovering device at "\r\n"location=%s driver=%s pci addr=%s\n",\r\npe->check_count, location,\r\neeh_driver_name(dev), eeh_pci_name(dev));\r\nprintk(KERN_ERR "EEH: Might be infinite loop in %s driver\n",\r\neeh_driver_name(dev));\r\ndump_stack();\r\n}\r\ngoto dn_unlock;\r\n}\r\nret = eeh_ops->get_state(pe, NULL);\r\nif ((ret < 0) ||\r\n(ret == EEH_STATE_NOT_SUPPORT) ||\r\n(ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\r\n(EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\r\neeh_stats.false_positives++;\r\npe->false_positives++;\r\nrc = 0;\r\ngoto dn_unlock;\r\n}\r\neeh_stats.slot_resets++;\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\nraw_spin_unlock_irqrestore(&confirm_error_lock, flags);\r\neeh_send_failure_event(pe);\r\nWARN(1, "EEH: failure detected\n");\r\nreturn 1;\r\ndn_unlock:\r\nraw_spin_unlock_irqrestore(&confirm_error_lock, flags);\r\nreturn rc;\r\n}\r\nunsigned long eeh_check_failure(const volatile void __iomem *token, unsigned long val)\r\n{\r\nunsigned long addr;\r\nstruct eeh_dev *edev;\r\naddr = eeh_token_to_phys((unsigned long __force) token);\r\nedev = eeh_addr_cache_get_dev(addr);\r\nif (!edev) {\r\neeh_stats.no_device++;\r\nreturn val;\r\n}\r\neeh_dev_check_failure(edev);\r\npci_dev_put(eeh_dev_to_pci_dev(edev));\r\nreturn val;\r\n}\r\nint eeh_pci_enable(struct eeh_pe *pe, int function)\r\n{\r\nint rc;\r\nrc = eeh_ops->set_option(pe, function);\r\nif (rc)\r\npr_warning("%s: Unexpected state change %d on PHB#%d-PE#%x, err=%d\n",\r\n__func__, function, pe->phb->global_number, pe->addr, rc);\r\nrc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\r\nif (rc > 0 && (rc & EEH_STATE_MMIO_ENABLED) &&\r\n(function == EEH_OPT_THAW_MMIO))\r\nreturn 0;\r\nreturn rc;\r\n}\r\nint pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nstruct eeh_pe *pe = edev->pe;\r\nif (!pe) {\r\npr_err("%s: No PE found on PCI device %s\n",\r\n__func__, pci_name(dev));\r\nreturn -EINVAL;\r\n}\r\nswitch (state) {\r\ncase pcie_deassert_reset:\r\neeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\r\nbreak;\r\ncase pcie_hot_reset:\r\neeh_ops->reset(pe, EEH_RESET_HOT);\r\nbreak;\r\ncase pcie_warm_reset:\r\neeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nstatic void *eeh_set_dev_freset(void *data, void *flag)\r\n{\r\nstruct pci_dev *dev;\r\nunsigned int *freset = (unsigned int *)flag;\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\ndev = eeh_dev_to_pci_dev(edev);\r\nif (dev)\r\n*freset |= dev->needs_freset;\r\nreturn NULL;\r\n}\r\nstatic void eeh_reset_pe_once(struct eeh_pe *pe)\r\n{\r\nunsigned int freset = 0;\r\neeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\r\nif (freset)\r\neeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\r\nelse\r\neeh_ops->reset(pe, EEH_RESET_HOT);\r\n#define PCI_BUS_RST_HOLD_TIME_MSEC 250\r\nmsleep(PCI_BUS_RST_HOLD_TIME_MSEC);\r\neeh_pe_state_clear(pe, EEH_PE_ISOLATED);\r\neeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\r\n#define PCI_BUS_SETTLE_TIME_MSEC 1800\r\nmsleep(PCI_BUS_SETTLE_TIME_MSEC);\r\n}\r\nint eeh_reset_pe(struct eeh_pe *pe)\r\n{\r\nint i, rc;\r\nfor (i=0; i<3; i++) {\r\neeh_reset_pe_once(pe);\r\nrc = eeh_ops->wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\r\nif (rc == (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE))\r\nreturn 0;\r\nif (rc < 0) {\r\npr_err("%s: Unrecoverable slot failure on PHB#%d-PE#%x",\r\n__func__, pe->phb->global_number, pe->addr);\r\nreturn -1;\r\n}\r\npr_err("EEH: bus reset %d failed on PHB#%d-PE#%x, rc=%d\n",\r\ni+1, pe->phb->global_number, pe->addr, rc);\r\n}\r\nreturn -1;\r\n}\r\nvoid eeh_save_bars(struct eeh_dev *edev)\r\n{\r\nint i;\r\nstruct device_node *dn;\r\nif (!edev)\r\nreturn;\r\ndn = eeh_dev_to_of_node(edev);\r\nfor (i = 0; i < 16; i++)\r\neeh_ops->read_config(dn, i * 4, 4, &edev->config_space[i]);\r\n}\r\nint __init eeh_ops_register(struct eeh_ops *ops)\r\n{\r\nif (!ops->name) {\r\npr_warning("%s: Invalid EEH ops name for %p\n",\r\n__func__, ops);\r\nreturn -EINVAL;\r\n}\r\nif (eeh_ops && eeh_ops != ops) {\r\npr_warning("%s: EEH ops of platform %s already existing (%s)\n",\r\n__func__, eeh_ops->name, ops->name);\r\nreturn -EEXIST;\r\n}\r\neeh_ops = ops;\r\nreturn 0;\r\n}\r\nint __exit eeh_ops_unregister(const char *name)\r\n{\r\nif (!name || !strlen(name)) {\r\npr_warning("%s: Invalid EEH ops name\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (eeh_ops && !strcmp(eeh_ops->name, name)) {\r\neeh_ops = NULL;\r\nreturn 0;\r\n}\r\nreturn -EEXIST;\r\n}\r\nstatic int __init eeh_init(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nstruct device_node *phb;\r\nint ret;\r\nif (!eeh_ops) {\r\npr_warning("%s: Platform EEH operation not found\n",\r\n__func__);\r\nreturn -EEXIST;\r\n} else if ((ret = eeh_ops->init())) {\r\npr_warning("%s: Failed to call platform init function (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nraw_spin_lock_init(&confirm_error_lock);\r\nif (eeh_probe_mode_devtree()) {\r\nlist_for_each_entry_safe(hose, tmp,\r\n&hose_list, list_node) {\r\nphb = hose->dn;\r\ntraverse_pci_devices(phb, eeh_ops->of_probe, NULL);\r\n}\r\n}\r\nif (eeh_subsystem_enabled)\r\npr_info("EEH: PCI Enhanced I/O Error Handling Enabled\n");\r\nelse\r\npr_warning("EEH: No capable adapters found\n");\r\nreturn ret;\r\n}\r\nstatic void eeh_add_device_early(struct device_node *dn)\r\n{\r\nstruct pci_controller *phb;\r\nif (!of_node_to_eeh_dev(dn))\r\nreturn;\r\nphb = of_node_to_eeh_dev(dn)->phb;\r\nif (NULL == phb || 0 == phb->buid)\r\nreturn;\r\neeh_ops->of_probe(dn, NULL);\r\n}\r\nvoid eeh_add_device_tree_early(struct device_node *dn)\r\n{\r\nstruct device_node *sib;\r\nfor_each_child_of_node(dn, sib)\r\neeh_add_device_tree_early(sib);\r\neeh_add_device_early(dn);\r\n}\r\nstatic void eeh_add_device_late(struct pci_dev *dev)\r\n{\r\nstruct device_node *dn;\r\nstruct eeh_dev *edev;\r\nif (!dev || !eeh_subsystem_enabled)\r\nreturn;\r\npr_debug("EEH: Adding device %s\n", pci_name(dev));\r\ndn = pci_device_to_OF_node(dev);\r\nedev = of_node_to_eeh_dev(dn);\r\nif (edev->pdev == dev) {\r\npr_debug("EEH: Already referenced !\n");\r\nreturn;\r\n}\r\nWARN_ON(edev->pdev);\r\npci_dev_get(dev);\r\nedev->pdev = dev;\r\ndev->dev.archdata.edev = edev;\r\neeh_addr_cache_insert_dev(dev);\r\neeh_sysfs_add_device(dev);\r\n}\r\nvoid eeh_add_device_tree_late(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\neeh_add_device_late(dev);\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nstruct pci_bus *subbus = dev->subordinate;\r\nif (subbus)\r\neeh_add_device_tree_late(subbus);\r\n}\r\n}\r\n}\r\nstatic void eeh_remove_device(struct pci_dev *dev, int purge_pe)\r\n{\r\nstruct eeh_dev *edev;\r\nif (!dev || !eeh_subsystem_enabled)\r\nreturn;\r\nedev = pci_dev_to_eeh_dev(dev);\r\npr_debug("EEH: Removing device %s\n", pci_name(dev));\r\nif (!edev || !edev->pdev) {\r\npr_debug("EEH: Not referenced !\n");\r\nreturn;\r\n}\r\nedev->pdev = NULL;\r\ndev->dev.archdata.edev = NULL;\r\npci_dev_put(dev);\r\neeh_rmv_from_parent_pe(edev, purge_pe);\r\neeh_addr_cache_rmv_dev(dev);\r\neeh_sysfs_remove_device(dev);\r\n}\r\nvoid eeh_remove_bus_device(struct pci_dev *dev, int purge_pe)\r\n{\r\nstruct pci_bus *bus = dev->subordinate;\r\nstruct pci_dev *child, *tmp;\r\neeh_remove_device(dev, purge_pe);\r\nif (bus && dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nlist_for_each_entry_safe(child, tmp, &bus->devices, bus_list)\r\neeh_remove_bus_device(child, purge_pe);\r\n}\r\n}\r\nstatic int proc_eeh_show(struct seq_file *m, void *v)\r\n{\r\nif (0 == eeh_subsystem_enabled) {\r\nseq_printf(m, "EEH Subsystem is globally disabled\n");\r\nseq_printf(m, "eeh_total_mmio_ffs=%llu\n", eeh_stats.total_mmio_ffs);\r\n} else {\r\nseq_printf(m, "EEH Subsystem is enabled\n");\r\nseq_printf(m,\r\n"no device=%llu\n"\r\n"no device node=%llu\n"\r\n"no config address=%llu\n"\r\n"check not wanted=%llu\n"\r\n"eeh_total_mmio_ffs=%llu\n"\r\n"eeh_false_positives=%llu\n"\r\n"eeh_slot_resets=%llu\n",\r\neeh_stats.no_device,\r\neeh_stats.no_dn,\r\neeh_stats.no_cfg_addr,\r\neeh_stats.ignored_check,\r\neeh_stats.total_mmio_ffs,\r\neeh_stats.false_positives,\r\neeh_stats.slot_resets);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_eeh_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_eeh_show, NULL);\r\n}\r\nstatic int __init eeh_init_proc(void)\r\n{\r\nif (machine_is(pseries))\r\nproc_create("powerpc/eeh", 0, NULL, &proc_eeh_operations);\r\nreturn 0;\r\n}
