static unsigned int\r\necryptfs_miscdev_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct ecryptfs_daemon *daemon = file->private_data;\r\nunsigned int mask = 0;\r\nmutex_lock(&daemon->mux);\r\nif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\r\nprintk(KERN_WARNING "%s: Attempt to poll on zombified "\r\n"daemon\n", __func__);\r\ngoto out_unlock_daemon;\r\n}\r\nif (daemon->flags & ECRYPTFS_DAEMON_IN_READ)\r\ngoto out_unlock_daemon;\r\nif (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)\r\ngoto out_unlock_daemon;\r\ndaemon->flags |= ECRYPTFS_DAEMON_IN_POLL;\r\nmutex_unlock(&daemon->mux);\r\npoll_wait(file, &daemon->wait, pt);\r\nmutex_lock(&daemon->mux);\r\nif (!list_empty(&daemon->msg_ctx_out_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nout_unlock_daemon:\r\ndaemon->flags &= ~ECRYPTFS_DAEMON_IN_POLL;\r\nmutex_unlock(&daemon->mux);\r\nreturn mask;\r\n}\r\nstatic int\r\necryptfs_miscdev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ecryptfs_daemon *daemon = NULL;\r\nint rc;\r\nmutex_lock(&ecryptfs_daemon_hash_mux);\r\nrc = try_module_get(THIS_MODULE);\r\nif (rc == 0) {\r\nrc = -EIO;\r\nprintk(KERN_ERR "%s: Error attempting to increment module use "\r\n"count; rc = [%d]\n", __func__, rc);\r\ngoto out_unlock_daemon_list;\r\n}\r\nrc = ecryptfs_find_daemon_by_euid(&daemon);\r\nif (!rc) {\r\nrc = -EINVAL;\r\ngoto out_unlock_daemon_list;\r\n}\r\nrc = ecryptfs_spawn_daemon(&daemon, file);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to spawn daemon; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_module_put_unlock_daemon_list;\r\n}\r\nmutex_lock(&daemon->mux);\r\nif (daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN) {\r\nrc = -EBUSY;\r\ngoto out_unlock_daemon;\r\n}\r\ndaemon->flags |= ECRYPTFS_DAEMON_MISCDEV_OPEN;\r\nfile->private_data = daemon;\r\natomic_inc(&ecryptfs_num_miscdev_opens);\r\nout_unlock_daemon:\r\nmutex_unlock(&daemon->mux);\r\nout_module_put_unlock_daemon_list:\r\nif (rc)\r\nmodule_put(THIS_MODULE);\r\nout_unlock_daemon_list:\r\nmutex_unlock(&ecryptfs_daemon_hash_mux);\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_miscdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ecryptfs_daemon *daemon = file->private_data;\r\nint rc;\r\nmutex_lock(&daemon->mux);\r\nBUG_ON(!(daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN));\r\ndaemon->flags &= ~ECRYPTFS_DAEMON_MISCDEV_OPEN;\r\natomic_dec(&ecryptfs_num_miscdev_opens);\r\nmutex_unlock(&daemon->mux);\r\nmutex_lock(&ecryptfs_daemon_hash_mux);\r\nrc = ecryptfs_exorcise_daemon(daemon);\r\nmutex_unlock(&ecryptfs_daemon_hash_mux);\r\nif (rc) {\r\nprintk(KERN_CRIT "%s: Fatal error whilst attempting to "\r\n"shut down daemon; rc = [%d]. Please report this "\r\n"bug.\n", __func__, rc);\r\nBUG();\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn rc;\r\n}\r\nint ecryptfs_send_miscdev(char *data, size_t data_size,\r\nstruct ecryptfs_msg_ctx *msg_ctx, u8 msg_type,\r\nu16 msg_flags, struct ecryptfs_daemon *daemon)\r\n{\r\nstruct ecryptfs_message *msg;\r\nmsg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);\r\nif (!msg) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting "\r\n"to kmalloc(%zd, GFP_KERNEL)\n", __func__,\r\n(sizeof(*msg) + data_size));\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&msg_ctx->mux);\r\nmsg_ctx->msg = msg;\r\nmsg_ctx->msg->index = msg_ctx->index;\r\nmsg_ctx->msg->data_len = data_size;\r\nmsg_ctx->type = msg_type;\r\nmemcpy(msg_ctx->msg->data, data, data_size);\r\nmsg_ctx->msg_size = (sizeof(*msg_ctx->msg) + data_size);\r\nlist_add_tail(&msg_ctx->daemon_out_list, &daemon->msg_ctx_out_queue);\r\nmutex_unlock(&msg_ctx->mux);\r\nmutex_lock(&daemon->mux);\r\ndaemon->num_queued_msg_ctx++;\r\nwake_up_interruptible(&daemon->wait);\r\nmutex_unlock(&daemon->mux);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\necryptfs_miscdev_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct ecryptfs_daemon *daemon = file->private_data;\r\nstruct ecryptfs_msg_ctx *msg_ctx;\r\nsize_t packet_length_size;\r\nchar packet_length[ECRYPTFS_MAX_PKT_LEN_SIZE];\r\nsize_t i;\r\nsize_t total_length;\r\nint rc;\r\nmutex_lock(&daemon->mux);\r\nif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\r\nrc = 0;\r\nprintk(KERN_WARNING "%s: Attempt to read from zombified "\r\n"daemon\n", __func__);\r\ngoto out_unlock_daemon;\r\n}\r\nif (daemon->flags & ECRYPTFS_DAEMON_IN_READ) {\r\nrc = 0;\r\ngoto out_unlock_daemon;\r\n}\r\ndaemon->flags |= ECRYPTFS_DAEMON_IN_READ;\r\ncheck_list:\r\nif (list_empty(&daemon->msg_ctx_out_queue)) {\r\nmutex_unlock(&daemon->mux);\r\nrc = wait_event_interruptible(\r\ndaemon->wait, !list_empty(&daemon->msg_ctx_out_queue));\r\nmutex_lock(&daemon->mux);\r\nif (rc < 0) {\r\nrc = 0;\r\ngoto out_unlock_daemon;\r\n}\r\n}\r\nif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\r\nrc = 0;\r\ngoto out_unlock_daemon;\r\n}\r\nif (list_empty(&daemon->msg_ctx_out_queue)) {\r\ngoto check_list;\r\n}\r\nmsg_ctx = list_first_entry(&daemon->msg_ctx_out_queue,\r\nstruct ecryptfs_msg_ctx, daemon_out_list);\r\nBUG_ON(!msg_ctx);\r\nmutex_lock(&msg_ctx->mux);\r\nif (msg_ctx->msg) {\r\nrc = ecryptfs_write_packet_length(packet_length,\r\nmsg_ctx->msg_size,\r\n&packet_length_size);\r\nif (rc) {\r\nrc = 0;\r\nprintk(KERN_WARNING "%s: Error writing packet length; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_unlock_msg_ctx;\r\n}\r\n} else {\r\npacket_length_size = 0;\r\nmsg_ctx->msg_size = 0;\r\n}\r\ntotal_length = (PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_length_size\r\n+ msg_ctx->msg_size);\r\nif (count < total_length) {\r\nrc = 0;\r\nprintk(KERN_WARNING "%s: Only given user buffer of "\r\n"size [%zd], but we need [%zd] to read the "\r\n"pending message\n", __func__, count, total_length);\r\ngoto out_unlock_msg_ctx;\r\n}\r\nrc = -EFAULT;\r\nif (put_user(msg_ctx->type, buf))\r\ngoto out_unlock_msg_ctx;\r\nif (put_user(cpu_to_be32(msg_ctx->counter),\r\n(__be32 __user *)(&buf[PKT_CTR_OFFSET])))\r\ngoto out_unlock_msg_ctx;\r\ni = PKT_TYPE_SIZE + PKT_CTR_SIZE;\r\nif (msg_ctx->msg) {\r\nif (copy_to_user(&buf[i], packet_length, packet_length_size))\r\ngoto out_unlock_msg_ctx;\r\ni += packet_length_size;\r\nif (copy_to_user(&buf[i], msg_ctx->msg, msg_ctx->msg_size))\r\ngoto out_unlock_msg_ctx;\r\ni += msg_ctx->msg_size;\r\n}\r\nrc = i;\r\nlist_del(&msg_ctx->daemon_out_list);\r\nkfree(msg_ctx->msg);\r\nmsg_ctx->msg = NULL;\r\nif (msg_ctx->type != ECRYPTFS_MSG_REQUEST)\r\necryptfs_msg_ctx_alloc_to_free(msg_ctx);\r\nout_unlock_msg_ctx:\r\nmutex_unlock(&msg_ctx->mux);\r\nout_unlock_daemon:\r\ndaemon->flags &= ~ECRYPTFS_DAEMON_IN_READ;\r\nmutex_unlock(&daemon->mux);\r\nreturn rc;\r\n}\r\nstatic int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon, char *data,\r\nsize_t data_size, u32 seq)\r\n{\r\nstruct ecryptfs_message *msg = (struct ecryptfs_message *)data;\r\nint rc;\r\nif ((sizeof(*msg) + msg->data_len) != data_size) {\r\nprintk(KERN_WARNING "%s: (sizeof(*msg) + msg->data_len) = "\r\n"[%zd]; data_size = [%zd]. Invalid packet.\n", __func__,\r\n(sizeof(*msg) + msg->data_len), data_size);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = ecryptfs_process_response(daemon, msg, seq);\r\nif (rc)\r\nprintk(KERN_ERR\r\n"Error processing response message; rc = [%d]\n", rc);\r\nout:\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\necryptfs_miscdev_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\n__be32 counter_nbo;\r\nu32 seq;\r\nsize_t packet_size, packet_size_length;\r\nchar *data;\r\nunsigned char packet_size_peek[ECRYPTFS_MAX_PKT_LEN_SIZE];\r\nssize_t rc;\r\nif (count == 0) {\r\nreturn 0;\r\n} else if (count == MIN_NON_MSG_PKT_SIZE) {\r\ngoto memdup;\r\n} else if (count < MIN_MSG_PKT_SIZE || count > MAX_MSG_PKT_SIZE) {\r\nprintk(KERN_WARNING "%s: Acceptable packet size range is "\r\n"[%d-%zu], but amount of data written is [%zu].",\r\n__func__, MIN_MSG_PKT_SIZE, MAX_MSG_PKT_SIZE, count);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(packet_size_peek, &buf[PKT_LEN_OFFSET],\r\nsizeof(packet_size_peek))) {\r\nprintk(KERN_WARNING "%s: Error while inspecting packet size\n",\r\n__func__);\r\nreturn -EFAULT;\r\n}\r\nrc = ecryptfs_parse_packet_length(packet_size_peek, &packet_size,\r\n&packet_size_length);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s: Error parsing packet length; "\r\n"rc = [%zd]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nif ((PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_size_length + packet_size)\r\n!= count) {\r\nprintk(KERN_WARNING "%s: Invalid packet size [%zu]\n", __func__,\r\npacket_size);\r\nreturn -EINVAL;\r\n}\r\nmemdup:\r\ndata = memdup_user(buf, count);\r\nif (IS_ERR(data)) {\r\nprintk(KERN_ERR "%s: memdup_user returned error [%ld]\n",\r\n__func__, PTR_ERR(data));\r\nreturn PTR_ERR(data);\r\n}\r\nswitch (data[PKT_TYPE_OFFSET]) {\r\ncase ECRYPTFS_MSG_RESPONSE:\r\nif (count < (MIN_MSG_PKT_SIZE\r\n+ sizeof(struct ecryptfs_message))) {\r\nprintk(KERN_WARNING "%s: Minimum acceptable packet "\r\n"size is [%zd], but amount of data written is "\r\n"only [%zd]. Discarding response packet.\n",\r\n__func__,\r\n(MIN_MSG_PKT_SIZE\r\n+ sizeof(struct ecryptfs_message)), count);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nmemcpy(&counter_nbo, &data[PKT_CTR_OFFSET], PKT_CTR_SIZE);\r\nseq = be32_to_cpu(counter_nbo);\r\nrc = ecryptfs_miscdev_response(file->private_data,\r\n&data[PKT_LEN_OFFSET + packet_size_length],\r\npacket_size, seq);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s: Failed to deliver miscdev "\r\n"response to requesting operation; rc = [%zd]\n",\r\n__func__, rc);\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase ECRYPTFS_MSG_HELO:\r\ncase ECRYPTFS_MSG_QUIT:\r\nbreak;\r\ndefault:\r\necryptfs_printk(KERN_WARNING, "Dropping miscdev "\r\n"message of unrecognized type [%d]\n",\r\ndata[0]);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nrc = count;\r\nout_free:\r\nkfree(data);\r\nreturn rc;\r\n}\r\nint __init ecryptfs_init_ecryptfs_miscdev(void)\r\n{\r\nint rc;\r\natomic_set(&ecryptfs_num_miscdev_opens, 0);\r\nrc = misc_register(&ecryptfs_miscdev);\r\nif (rc)\r\nprintk(KERN_ERR "%s: Failed to register miscellaneous device "\r\n"for communications with userspace daemons; rc = [%d]\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nvoid ecryptfs_destroy_ecryptfs_miscdev(void)\r\n{\r\nBUG_ON(atomic_read(&ecryptfs_num_miscdev_opens) != 0);\r\nmisc_deregister(&ecryptfs_miscdev);\r\n}
