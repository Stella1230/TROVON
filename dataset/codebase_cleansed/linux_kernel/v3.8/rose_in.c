static int rose_state1_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nswitch (frametype) {\r\ncase ROSE_CALL_ACCEPTED:\r\nrose_stop_timer(sk);\r\nrose_start_idletimer(sk);\r\nrose->condition = 0x00;\r\nrose->vs = 0;\r\nrose->va = 0;\r\nrose->vr = 0;\r\nrose->vl = 0;\r\nrose->state = ROSE_STATE_3;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nbreak;\r\ncase ROSE_CLEAR_REQUEST:\r\nrose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\r\nrose_disconnect(sk, ECONNREFUSED, skb->data[3], skb->data[4]);\r\nrose->neighbour->use--;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_state2_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nswitch (frametype) {\r\ncase ROSE_CLEAR_REQUEST:\r\nrose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\r\nrose_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nrose->neighbour->use--;\r\nbreak;\r\ncase ROSE_CLEAR_CONFIRMATION:\r\nrose_disconnect(sk, 0, -1, -1);\r\nrose->neighbour->use--;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_state3_machine(struct sock *sk, struct sk_buff *skb, int frametype, int ns, int nr, int q, int d, int m)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nint queued = 0;\r\nswitch (frametype) {\r\ncase ROSE_RESET_REQUEST:\r\nrose_stop_timer(sk);\r\nrose_start_idletimer(sk);\r\nrose_write_internal(sk, ROSE_RESET_CONFIRMATION);\r\nrose->condition = 0x00;\r\nrose->vs = 0;\r\nrose->vr = 0;\r\nrose->va = 0;\r\nrose->vl = 0;\r\nrose_requeue_frames(sk);\r\nbreak;\r\ncase ROSE_CLEAR_REQUEST:\r\nrose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\r\nrose_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nrose->neighbour->use--;\r\nbreak;\r\ncase ROSE_RR:\r\ncase ROSE_RNR:\r\nif (!rose_validate_nr(sk, nr)) {\r\nrose_write_internal(sk, ROSE_RESET_REQUEST);\r\nrose->condition = 0x00;\r\nrose->vs = 0;\r\nrose->vr = 0;\r\nrose->va = 0;\r\nrose->vl = 0;\r\nrose->state = ROSE_STATE_4;\r\nrose_start_t2timer(sk);\r\nrose_stop_idletimer(sk);\r\n} else {\r\nrose_frames_acked(sk, nr);\r\nif (frametype == ROSE_RNR) {\r\nrose->condition |= ROSE_COND_PEER_RX_BUSY;\r\n} else {\r\nrose->condition &= ~ROSE_COND_PEER_RX_BUSY;\r\n}\r\n}\r\nbreak;\r\ncase ROSE_DATA:\r\nrose->condition &= ~ROSE_COND_PEER_RX_BUSY;\r\nif (!rose_validate_nr(sk, nr)) {\r\nrose_write_internal(sk, ROSE_RESET_REQUEST);\r\nrose->condition = 0x00;\r\nrose->vs = 0;\r\nrose->vr = 0;\r\nrose->va = 0;\r\nrose->vl = 0;\r\nrose->state = ROSE_STATE_4;\r\nrose_start_t2timer(sk);\r\nrose_stop_idletimer(sk);\r\nbreak;\r\n}\r\nrose_frames_acked(sk, nr);\r\nif (ns == rose->vr) {\r\nrose_start_idletimer(sk);\r\nif (sock_queue_rcv_skb(sk, skb) == 0) {\r\nrose->vr = (rose->vr + 1) % ROSE_MODULUS;\r\nqueued = 1;\r\n} else {\r\nrose_write_internal(sk, ROSE_RESET_REQUEST);\r\nrose->condition = 0x00;\r\nrose->vs = 0;\r\nrose->vr = 0;\r\nrose->va = 0;\r\nrose->vl = 0;\r\nrose->state = ROSE_STATE_4;\r\nrose_start_t2timer(sk);\r\nrose_stop_idletimer(sk);\r\nbreak;\r\n}\r\nif (atomic_read(&sk->sk_rmem_alloc) >\r\n(sk->sk_rcvbuf >> 1))\r\nrose->condition |= ROSE_COND_OWN_RX_BUSY;\r\n}\r\nif (((rose->vl + sysctl_rose_window_size) % ROSE_MODULUS) == rose->vr) {\r\nrose->condition &= ~ROSE_COND_ACK_PENDING;\r\nrose_stop_timer(sk);\r\nrose_enquiry_response(sk);\r\n} else {\r\nrose->condition |= ROSE_COND_ACK_PENDING;\r\nrose_start_hbtimer(sk);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ROSE: unknown %02X in state 3\n", frametype);\r\nbreak;\r\n}\r\nreturn queued;\r\n}\r\nstatic int rose_state4_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nswitch (frametype) {\r\ncase ROSE_RESET_REQUEST:\r\nrose_write_internal(sk, ROSE_RESET_CONFIRMATION);\r\ncase ROSE_RESET_CONFIRMATION:\r\nrose_stop_timer(sk);\r\nrose_start_idletimer(sk);\r\nrose->condition = 0x00;\r\nrose->va = 0;\r\nrose->vr = 0;\r\nrose->vs = 0;\r\nrose->vl = 0;\r\nrose->state = ROSE_STATE_3;\r\nrose_requeue_frames(sk);\r\nbreak;\r\ncase ROSE_CLEAR_REQUEST:\r\nrose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\r\nrose_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nrose->neighbour->use--;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_state5_machine(struct sock *sk, struct sk_buff *skb, int frametype)\r\n{\r\nif (frametype == ROSE_CLEAR_REQUEST) {\r\nrose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\r\nrose_disconnect(sk, 0, skb->data[3], skb->data[4]);\r\nrose_sk(sk)->neighbour->use--;\r\n}\r\nreturn 0;\r\n}\r\nint rose_process_rx_frame(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nint queued = 0, frametype, ns, nr, q, d, m;\r\nif (rose->state == ROSE_STATE_0)\r\nreturn 0;\r\nframetype = rose_decode(skb, &ns, &nr, &q, &d, &m);\r\nswitch (rose->state) {\r\ncase ROSE_STATE_1:\r\nqueued = rose_state1_machine(sk, skb, frametype);\r\nbreak;\r\ncase ROSE_STATE_2:\r\nqueued = rose_state2_machine(sk, skb, frametype);\r\nbreak;\r\ncase ROSE_STATE_3:\r\nqueued = rose_state3_machine(sk, skb, frametype, ns, nr, q, d, m);\r\nbreak;\r\ncase ROSE_STATE_4:\r\nqueued = rose_state4_machine(sk, skb, frametype);\r\nbreak;\r\ncase ROSE_STATE_5:\r\nqueued = rose_state5_machine(sk, skb, frametype);\r\nbreak;\r\n}\r\nrose_kick(sk);\r\nreturn queued;\r\n}
