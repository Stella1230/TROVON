static union acpi_object *radeon_atif_call(acpi_handle handle, int function,\r\nstruct acpi_buffer *params)\r\n{\r\nacpi_status status;\r\nunion acpi_object atif_arg_elements[2];\r\nstruct acpi_object_list atif_arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\natif_arg.count = 2;\r\natif_arg.pointer = &atif_arg_elements[0];\r\natif_arg_elements[0].type = ACPI_TYPE_INTEGER;\r\natif_arg_elements[0].integer.value = function;\r\nif (params) {\r\natif_arg_elements[1].type = ACPI_TYPE_BUFFER;\r\natif_arg_elements[1].buffer.length = params->length;\r\natif_arg_elements[1].buffer.pointer = params->pointer;\r\n} else {\r\natif_arg_elements[1].type = ACPI_TYPE_INTEGER;\r\natif_arg_elements[1].integer.value = 0;\r\n}\r\nstatus = acpi_evaluate_object(handle, "ATIF", &atif_arg, &buffer);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nDRM_DEBUG_DRIVER("failed to evaluate ATIF got %s\n",\r\nacpi_format_exception(status));\r\nkfree(buffer.pointer);\r\nreturn NULL;\r\n}\r\nreturn buffer.pointer;\r\n}\r\nstatic void radeon_atif_parse_notification(struct radeon_atif_notifications *n, u32 mask)\r\n{\r\nn->display_switch = mask & ATIF_DISPLAY_SWITCH_REQUEST_SUPPORTED;\r\nn->expansion_mode_change = mask & ATIF_EXPANSION_MODE_CHANGE_REQUEST_SUPPORTED;\r\nn->thermal_state = mask & ATIF_THERMAL_STATE_CHANGE_REQUEST_SUPPORTED;\r\nn->forced_power_state = mask & ATIF_FORCED_POWER_STATE_CHANGE_REQUEST_SUPPORTED;\r\nn->system_power_state = mask & ATIF_SYSTEM_POWER_SOURCE_CHANGE_REQUEST_SUPPORTED;\r\nn->display_conf_change = mask & ATIF_DISPLAY_CONF_CHANGE_REQUEST_SUPPORTED;\r\nn->px_gfx_switch = mask & ATIF_PX_GFX_SWITCH_REQUEST_SUPPORTED;\r\nn->brightness_change = mask & ATIF_PANEL_BRIGHTNESS_CHANGE_REQUEST_SUPPORTED;\r\nn->dgpu_display_event = mask & ATIF_DGPU_DISPLAY_EVENT_SUPPORTED;\r\n}\r\nstatic void radeon_atif_parse_functions(struct radeon_atif_functions *f, u32 mask)\r\n{\r\nf->system_params = mask & ATIF_GET_SYSTEM_PARAMETERS_SUPPORTED;\r\nf->sbios_requests = mask & ATIF_GET_SYSTEM_BIOS_REQUESTS_SUPPORTED;\r\nf->select_active_disp = mask & ATIF_SELECT_ACTIVE_DISPLAYS_SUPPORTED;\r\nf->lid_state = mask & ATIF_GET_LID_STATE_SUPPORTED;\r\nf->get_tv_standard = mask & ATIF_GET_TV_STANDARD_FROM_CMOS_SUPPORTED;\r\nf->set_tv_standard = mask & ATIF_SET_TV_STANDARD_IN_CMOS_SUPPORTED;\r\nf->get_panel_expansion_mode = mask & ATIF_GET_PANEL_EXPANSION_MODE_FROM_CMOS_SUPPORTED;\r\nf->set_panel_expansion_mode = mask & ATIF_SET_PANEL_EXPANSION_MODE_IN_CMOS_SUPPORTED;\r\nf->temperature_change = mask & ATIF_TEMPERATURE_CHANGE_NOTIFICATION_SUPPORTED;\r\nf->graphics_device_types = mask & ATIF_GET_GRAPHICS_DEVICE_TYPES_SUPPORTED;\r\n}\r\nstatic int radeon_atif_verify_interface(acpi_handle handle,\r\nstruct radeon_atif *atif)\r\n{\r\nunion acpi_object *info;\r\nstruct atif_verify_interface output;\r\nsize_t size;\r\nint err = 0;\r\ninfo = radeon_atif_call(handle, ATIF_FUNCTION_VERIFY_INTERFACE, NULL);\r\nif (!info)\r\nreturn -EIO;\r\nmemset(&output, 0, sizeof(output));\r\nsize = *(u16 *) info->buffer.pointer;\r\nif (size < 12) {\r\nDRM_INFO("ATIF buffer is too small: %zu\n", size);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsize = min(sizeof(output), size);\r\nmemcpy(&output, info->buffer.pointer, size);\r\nDRM_DEBUG_DRIVER("ATIF version %u\n", output.version);\r\nradeon_atif_parse_notification(&atif->notifications, output.notification_mask);\r\nradeon_atif_parse_functions(&atif->functions, output.function_bits);\r\nout:\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int radeon_atif_get_notification_params(acpi_handle handle,\r\nstruct radeon_atif_notification_cfg *n)\r\n{\r\nunion acpi_object *info;\r\nstruct atif_system_params params;\r\nsize_t size;\r\nint err = 0;\r\ninfo = radeon_atif_call(handle, ATIF_FUNCTION_GET_SYSTEM_PARAMETERS, NULL);\r\nif (!info) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nsize = *(u16 *) info->buffer.pointer;\r\nif (size < 10) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nsize = min(sizeof(params), size);\r\nmemcpy(&params, info->buffer.pointer, size);\r\nDRM_DEBUG_DRIVER("SYSTEM_PARAMS: mask = %#x, flags = %#x\n",\r\nparams.flags, params.valid_mask);\r\nparams.flags = params.flags & params.valid_mask;\r\nif ((params.flags & ATIF_NOTIFY_MASK) == ATIF_NOTIFY_NONE) {\r\nn->enabled = false;\r\nn->command_code = 0;\r\n} else if ((params.flags & ATIF_NOTIFY_MASK) == ATIF_NOTIFY_81) {\r\nn->enabled = true;\r\nn->command_code = 0x81;\r\n} else {\r\nif (size < 11) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nn->enabled = true;\r\nn->command_code = params.command_code;\r\n}\r\nout:\r\nDRM_DEBUG_DRIVER("Notification %s, command code = %#x\n",\r\n(n->enabled ? "enabled" : "disabled"),\r\nn->command_code);\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int radeon_atif_get_sbios_requests(acpi_handle handle,\r\nstruct atif_sbios_requests *req)\r\n{\r\nunion acpi_object *info;\r\nsize_t size;\r\nint count = 0;\r\ninfo = radeon_atif_call(handle, ATIF_FUNCTION_GET_SYSTEM_BIOS_REQUESTS, NULL);\r\nif (!info)\r\nreturn -EIO;\r\nsize = *(u16 *)info->buffer.pointer;\r\nif (size < 0xd) {\r\ncount = -EINVAL;\r\ngoto out;\r\n}\r\nmemset(req, 0, sizeof(*req));\r\nsize = min(sizeof(*req), size);\r\nmemcpy(req, info->buffer.pointer, size);\r\nDRM_DEBUG_DRIVER("SBIOS pending requests: %#x\n", req->pending);\r\ncount = hweight32(req->pending);\r\nout:\r\nkfree(info);\r\nreturn count;\r\n}\r\nint radeon_atif_handler(struct radeon_device *rdev,\r\nstruct acpi_bus_event *event)\r\n{\r\nstruct radeon_atif *atif = &rdev->atif;\r\nstruct atif_sbios_requests req;\r\nacpi_handle handle;\r\nint count;\r\nDRM_DEBUG_DRIVER("event, device_class = %s, type = %#x\n",\r\nevent->device_class, event->type);\r\nif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\r\nreturn NOTIFY_DONE;\r\nif (!atif->notification_cfg.enabled ||\r\nevent->type != atif->notification_cfg.command_code)\r\nreturn NOTIFY_DONE;\r\nhandle = DEVICE_ACPI_HANDLE(&rdev->pdev->dev);\r\ncount = radeon_atif_get_sbios_requests(handle, &req);\r\nif (count <= 0)\r\nreturn NOTIFY_DONE;\r\nDRM_DEBUG_DRIVER("ATIF: %d pending SBIOS requests\n", count);\r\nif (req.pending & ATIF_PANEL_BRIGHTNESS_CHANGE_REQUEST) {\r\nstruct radeon_encoder *enc = atif->encoder_for_bl;\r\nif (enc) {\r\nDRM_DEBUG_DRIVER("Changing brightness to %d\n",\r\nreq.backlight_level);\r\nradeon_set_backlight_level(rdev, enc, req.backlight_level);\r\n#if defined(CONFIG_BACKLIGHT_CLASS_DEVICE) || defined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE)\r\nif (rdev->is_atom_bios) {\r\nstruct radeon_encoder_atom_dig *dig = enc->enc_priv;\r\nbacklight_force_update(dig->bl_dev,\r\nBACKLIGHT_UPDATE_HOTKEY);\r\n} else {\r\nstruct radeon_encoder_lvds *dig = enc->enc_priv;\r\nbacklight_force_update(dig->bl_dev,\r\nBACKLIGHT_UPDATE_HOTKEY);\r\n}\r\n#endif\r\n}\r\n}\r\nreturn NOTIFY_BAD;\r\n}\r\nstatic union acpi_object *radeon_atcs_call(acpi_handle handle, int function,\r\nstruct acpi_buffer *params)\r\n{\r\nacpi_status status;\r\nunion acpi_object atcs_arg_elements[2];\r\nstruct acpi_object_list atcs_arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\natcs_arg.count = 2;\r\natcs_arg.pointer = &atcs_arg_elements[0];\r\natcs_arg_elements[0].type = ACPI_TYPE_INTEGER;\r\natcs_arg_elements[0].integer.value = function;\r\nif (params) {\r\natcs_arg_elements[1].type = ACPI_TYPE_BUFFER;\r\natcs_arg_elements[1].buffer.length = params->length;\r\natcs_arg_elements[1].buffer.pointer = params->pointer;\r\n} else {\r\natcs_arg_elements[1].type = ACPI_TYPE_INTEGER;\r\natcs_arg_elements[1].integer.value = 0;\r\n}\r\nstatus = acpi_evaluate_object(handle, "ATCS", &atcs_arg, &buffer);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nDRM_DEBUG_DRIVER("failed to evaluate ATCS got %s\n",\r\nacpi_format_exception(status));\r\nkfree(buffer.pointer);\r\nreturn NULL;\r\n}\r\nreturn buffer.pointer;\r\n}\r\nstatic void radeon_atcs_parse_functions(struct radeon_atcs_functions *f, u32 mask)\r\n{\r\nf->get_ext_state = mask & ATCS_GET_EXTERNAL_STATE_SUPPORTED;\r\nf->pcie_perf_req = mask & ATCS_PCIE_PERFORMANCE_REQUEST_SUPPORTED;\r\nf->pcie_dev_rdy = mask & ATCS_PCIE_DEVICE_READY_NOTIFICATION_SUPPORTED;\r\nf->pcie_bus_width = mask & ATCS_SET_PCIE_BUS_WIDTH_SUPPORTED;\r\n}\r\nstatic int radeon_atcs_verify_interface(acpi_handle handle,\r\nstruct radeon_atcs *atcs)\r\n{\r\nunion acpi_object *info;\r\nstruct atcs_verify_interface output;\r\nsize_t size;\r\nint err = 0;\r\ninfo = radeon_atcs_call(handle, ATCS_FUNCTION_VERIFY_INTERFACE, NULL);\r\nif (!info)\r\nreturn -EIO;\r\nmemset(&output, 0, sizeof(output));\r\nsize = *(u16 *) info->buffer.pointer;\r\nif (size < 8) {\r\nDRM_INFO("ATCS buffer is too small: %zu\n", size);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsize = min(sizeof(output), size);\r\nmemcpy(&output, info->buffer.pointer, size);\r\nDRM_DEBUG_DRIVER("ATCS version %u\n", output.version);\r\nradeon_atcs_parse_functions(&atcs->functions, output.function_bits);\r\nout:\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic int radeon_acpi_event(struct notifier_block *nb,\r\nunsigned long val,\r\nvoid *data)\r\n{\r\nstruct radeon_device *rdev = container_of(nb, struct radeon_device, acpi_nb);\r\nstruct acpi_bus_event *entry = (struct acpi_bus_event *)data;\r\nif (strcmp(entry->device_class, ACPI_AC_CLASS) == 0) {\r\nif (power_supply_is_system_supplied() > 0)\r\nDRM_DEBUG_DRIVER("pm: AC\n");\r\nelse\r\nDRM_DEBUG_DRIVER("pm: DC\n");\r\nradeon_pm_acpi_event_handler(rdev);\r\n}\r\nreturn radeon_atif_handler(rdev, entry);\r\n}\r\nint radeon_acpi_init(struct radeon_device *rdev)\r\n{\r\nacpi_handle handle;\r\nstruct radeon_atif *atif = &rdev->atif;\r\nstruct radeon_atcs *atcs = &rdev->atcs;\r\nint ret;\r\nhandle = DEVICE_ACPI_HANDLE(&rdev->pdev->dev);\r\nif (!ASIC_IS_AVIVO(rdev) || !rdev->bios || !handle)\r\nreturn 0;\r\nret = radeon_atcs_verify_interface(handle, atcs);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("Call to ATCS verify_interface failed: %d\n", ret);\r\n}\r\nret = radeon_atif_verify_interface(handle, atif);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("Call to ATIF verify_interface failed: %d\n", ret);\r\ngoto out;\r\n}\r\nif (atif->notifications.brightness_change) {\r\nstruct drm_encoder *tmp;\r\nstruct radeon_encoder *target = NULL;\r\nlist_for_each_entry(tmp, &rdev->ddev->mode_config.encoder_list,\r\nhead) {\r\nstruct radeon_encoder *enc = to_radeon_encoder(tmp);\r\nif ((enc->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\r\nenc->enc_priv) {\r\nif (rdev->is_atom_bios) {\r\nstruct radeon_encoder_atom_dig *dig = enc->enc_priv;\r\nif (dig->bl_dev) {\r\ntarget = enc;\r\nbreak;\r\n}\r\n} else {\r\nstruct radeon_encoder_lvds *dig = enc->enc_priv;\r\nif (dig->bl_dev) {\r\ntarget = enc;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\natif->encoder_for_bl = target;\r\nif (!target) {\r\nDRM_ERROR("Cannot find a backlight controller\n");\r\n}\r\n}\r\nif (atif->functions.sbios_requests && !atif->functions.system_params) {\r\natif->functions.system_params = true;\r\n}\r\nif (atif->functions.system_params) {\r\nret = radeon_atif_get_notification_params(handle,\r\n&atif->notification_cfg);\r\nif (ret) {\r\nDRM_DEBUG_DRIVER("Call to GET_SYSTEM_PARAMS failed: %d\n",\r\nret);\r\natif->notification_cfg.enabled = false;\r\n}\r\n}\r\nout:\r\nrdev->acpi_nb.notifier_call = radeon_acpi_event;\r\nregister_acpi_notifier(&rdev->acpi_nb);\r\nreturn ret;\r\n}\r\nvoid radeon_acpi_fini(struct radeon_device *rdev)\r\n{\r\nunregister_acpi_notifier(&rdev->acpi_nb);\r\n}
