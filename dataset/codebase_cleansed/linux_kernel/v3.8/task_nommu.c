void task_mem(struct seq_file *m, struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct vm_region *region;\r\nstruct rb_node *p;\r\nunsigned long bytes = 0, sbytes = 0, slack = 0, size;\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\r\nvma = rb_entry(p, struct vm_area_struct, vm_rb);\r\nbytes += kobjsize(vma);\r\nregion = vma->vm_region;\r\nif (region) {\r\nsize = kobjsize(region);\r\nsize += region->vm_end - region->vm_start;\r\n} else {\r\nsize = vma->vm_end - vma->vm_start;\r\n}\r\nif (atomic_read(&mm->mm_count) > 1 ||\r\nvma->vm_flags & VM_MAYSHARE) {\r\nsbytes += size;\r\n} else {\r\nbytes += size;\r\nif (region)\r\nslack = region->vm_end - vma->vm_end;\r\n}\r\n}\r\nif (atomic_read(&mm->mm_count) > 1)\r\nsbytes += kobjsize(mm);\r\nelse\r\nbytes += kobjsize(mm);\r\nif (current->fs && current->fs->users > 1)\r\nsbytes += kobjsize(current->fs);\r\nelse\r\nbytes += kobjsize(current->fs);\r\nif (current->files && atomic_read(&current->files->count) > 1)\r\nsbytes += kobjsize(current->files);\r\nelse\r\nbytes += kobjsize(current->files);\r\nif (current->sighand && atomic_read(&current->sighand->count) > 1)\r\nsbytes += kobjsize(current->sighand);\r\nelse\r\nbytes += kobjsize(current->sighand);\r\nbytes += kobjsize(current);\r\nseq_printf(m,\r\n"Mem:\t%8lu bytes\n"\r\n"Slack:\t%8lu bytes\n"\r\n"Shared:\t%8lu bytes\n",\r\nbytes, slack, sbytes);\r\nup_read(&mm->mmap_sem);\r\n}\r\nunsigned long task_vsize(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct rb_node *p;\r\nunsigned long vsize = 0;\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\r\nvma = rb_entry(p, struct vm_area_struct, vm_rb);\r\nvsize += vma->vm_end - vma->vm_start;\r\n}\r\nup_read(&mm->mmap_sem);\r\nreturn vsize;\r\n}\r\nunsigned long task_statm(struct mm_struct *mm,\r\nunsigned long *shared, unsigned long *text,\r\nunsigned long *data, unsigned long *resident)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct vm_region *region;\r\nstruct rb_node *p;\r\nunsigned long size = kobjsize(mm);\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\r\nvma = rb_entry(p, struct vm_area_struct, vm_rb);\r\nsize += kobjsize(vma);\r\nregion = vma->vm_region;\r\nif (region) {\r\nsize += kobjsize(region);\r\nsize += region->vm_end - region->vm_start;\r\n}\r\n}\r\n*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\r\n>> PAGE_SHIFT;\r\n*data = (PAGE_ALIGN(mm->start_stack) - (mm->start_data & PAGE_MASK))\r\n>> PAGE_SHIFT;\r\nup_read(&mm->mmap_sem);\r\nsize >>= PAGE_SHIFT;\r\nsize += *text + *data;\r\n*resident = size;\r\nreturn size;\r\n}\r\nstatic void pad_len_spaces(struct seq_file *m, int len)\r\n{\r\nlen = 25 + sizeof(void*) * 6 - len;\r\nif (len < 1)\r\nlen = 1;\r\nseq_printf(m, "%*c", len, ' ');\r\n}\r\nstatic int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,\r\nint is_pid)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nstruct proc_maps_private *priv = m->private;\r\nunsigned long ino = 0;\r\nstruct file *file;\r\ndev_t dev = 0;\r\nint flags, len;\r\nunsigned long long pgoff = 0;\r\nflags = vma->vm_flags;\r\nfile = vma->vm_file;\r\nif (file) {\r\nstruct inode *inode = vma->vm_file->f_path.dentry->d_inode;\r\ndev = inode->i_sb->s_dev;\r\nino = inode->i_ino;\r\npgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\r\n}\r\nseq_printf(m,\r\n"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",\r\nvma->vm_start,\r\nvma->vm_end,\r\nflags & VM_READ ? 'r' : '-',\r\nflags & VM_WRITE ? 'w' : '-',\r\nflags & VM_EXEC ? 'x' : '-',\r\nflags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\r\npgoff,\r\nMAJOR(dev), MINOR(dev), ino, &len);\r\nif (file) {\r\npad_len_spaces(m, len);\r\nseq_path(m, &file->f_path, "");\r\n} else if (mm) {\r\npid_t tid = vm_is_stack(priv->task, vma, is_pid);\r\nif (tid != 0) {\r\npad_len_spaces(m, len);\r\nif (!is_pid || (vma->vm_start <= mm->start_stack &&\r\nvma->vm_end >= mm->start_stack))\r\nseq_printf(m, "[stack]");\r\nelse\r\nseq_printf(m, "[stack:%d]", tid);\r\n}\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int show_map(struct seq_file *m, void *_p, int is_pid)\r\n{\r\nstruct rb_node *p = _p;\r\nreturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\r\nis_pid);\r\n}\r\nstatic int show_pid_map(struct seq_file *m, void *_p)\r\n{\r\nreturn show_map(m, _p, 1);\r\n}\r\nstatic int show_tid_map(struct seq_file *m, void *_p)\r\n{\r\nreturn show_map(m, _p, 0);\r\n}\r\nstatic void *m_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct proc_maps_private *priv = m->private;\r\nstruct mm_struct *mm;\r\nstruct rb_node *p;\r\nloff_t n = *pos;\r\npriv->task = get_pid_task(priv->pid, PIDTYPE_PID);\r\nif (!priv->task)\r\nreturn ERR_PTR(-ESRCH);\r\nmm = mm_access(priv->task, PTRACE_MODE_READ);\r\nif (!mm || IS_ERR(mm)) {\r\nput_task_struct(priv->task);\r\npriv->task = NULL;\r\nreturn mm;\r\n}\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p))\r\nif (n-- == 0)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic void m_stop(struct seq_file *m, void *_vml)\r\n{\r\nstruct proc_maps_private *priv = m->private;\r\nif (priv->task) {\r\nstruct mm_struct *mm = priv->task->mm;\r\nup_read(&mm->mmap_sem);\r\nmmput(mm);\r\nput_task_struct(priv->task);\r\n}\r\n}\r\nstatic void *m_next(struct seq_file *m, void *_p, loff_t *pos)\r\n{\r\nstruct rb_node *p = _p;\r\n(*pos)++;\r\nreturn p ? rb_next(p) : NULL;\r\n}\r\nstatic int maps_open(struct inode *inode, struct file *file,\r\nconst struct seq_operations *ops)\r\n{\r\nstruct proc_maps_private *priv;\r\nint ret = -ENOMEM;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv) {\r\npriv->pid = proc_pid(inode);\r\nret = seq_open(file, ops);\r\nif (!ret) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = priv;\r\n} else {\r\nkfree(priv);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int pid_maps_open(struct inode *inode, struct file *file)\r\n{\r\nreturn maps_open(inode, file, &proc_pid_maps_ops);\r\n}\r\nstatic int tid_maps_open(struct inode *inode, struct file *file)\r\n{\r\nreturn maps_open(inode, file, &proc_tid_maps_ops);\r\n}
