static void aha1542_stat(void)\r\n{\r\n}\r\nstatic int aha1542_out(unsigned int base, unchar * cmdp, int len)\r\n{\r\nunsigned long flags = 0;\r\nint got_lock;\r\nif (len == 1) {\r\ngot_lock = 0;\r\nwhile (1 == 1) {\r\nWAIT(STATUS(base), CDF, 0, CDF);\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nif (inb(STATUS(base)) & CDF) {\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\ncontinue;\r\n}\r\noutb(*cmdp, DATA(base));\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nreturn 0;\r\n}\r\n} else {\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\ngot_lock = 1;\r\nwhile (len--) {\r\nWAIT(STATUS(base), CDF, 0, CDF);\r\noutb(*cmdp++, DATA(base));\r\n}\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\n}\r\nreturn 0;\r\nfail:\r\nif (got_lock)\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nprintk(KERN_ERR "aha1542_out failed(%d): ", len + 1);\r\naha1542_stat();\r\nreturn 1;\r\n}\r\nstatic int __init aha1542_in(unsigned int base, unchar * cmdp, int len)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nwhile (len--) {\r\nWAIT(STATUS(base), DF, DF, 0);\r\n*cmdp++ = inb(DATA(base));\r\n}\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nreturn 0;\r\nfail:\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nprintk(KERN_ERR "aha1542_in failed(%d): ", len + 1);\r\naha1542_stat();\r\nreturn 1;\r\n}\r\nstatic int __init aha1542_in1(unsigned int base, unchar * cmdp, int len)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nwhile (len--) {\r\nWAITd(STATUS(base), DF, DF, 0, 100);\r\n*cmdp++ = inb(DATA(base));\r\n}\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nreturn 0;\r\nfail:\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nreturn 1;\r\n}\r\nstatic int makecode(unsigned hosterr, unsigned scsierr)\r\n{\r\nswitch (hosterr) {\r\ncase 0x0:\r\ncase 0xa:\r\ncase 0xb:\r\nhosterr = 0;\r\nbreak;\r\ncase 0x11:\r\nhosterr = DID_TIME_OUT;\r\nbreak;\r\ncase 0x12:\r\ncase 0x13:\r\ncase 0x15:\r\ncase 0x16:\r\ncase 0x17:\r\ncase 0x18:\r\ncase 0x19:\r\ncase 0x1a:\r\nDEB(printk("Aha1542: %x %x\n", hosterr, scsierr));\r\nhosterr = DID_ERROR;\r\nbreak;\r\ncase 0x14:\r\nhosterr = DID_RESET;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aha1542: makecode: unknown hoststatus %x\n", hosterr);\r\nbreak;\r\n}\r\nreturn scsierr | (hosterr << 16);\r\n}\r\nstatic int __init aha1542_test_port(int bse, struct Scsi_Host *shpnt)\r\n{\r\nunchar inquiry_cmd[] = {CMD_INQUIRY};\r\nunchar inquiry_result[4];\r\nunchar *cmdp;\r\nint len;\r\nvolatile int debug = 0;\r\nif (inb(STATUS(bse)) == 0xff)\r\nreturn 0;\r\naha1542_intr_reset(bse);\r\noutb(SRST | IRST , CONTROL(bse));\r\nmdelay(20);\r\ndebug = 1;\r\nWAIT(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);\r\ndebug = 2;\r\nif (inb(INTRFLAGS(bse)) & INTRMASK)\r\ngoto fail;\r\naha1542_out(bse, inquiry_cmd, 1);\r\ndebug = 3;\r\nlen = 4;\r\ncmdp = &inquiry_result[0];\r\nwhile (len--) {\r\nWAIT(STATUS(bse), DF, DF, 0);\r\n*cmdp++ = inb(DATA(bse));\r\n}\r\ndebug = 8;\r\nif (inb(STATUS(bse)) & DF)\r\ngoto fail;\r\ndebug = 9;\r\nWAIT(INTRFLAGS(bse), HACC, HACC, 0);\r\ndebug = 10;\r\noutb(IRST, CONTROL(bse));\r\ndebug = 11;\r\nreturn debug;\r\nfail:\r\nreturn 0;\r\n}\r\nstatic irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *shost = dev_id;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\naha1542_intr_handle(shost);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void aha1542_intr_handle(struct Scsi_Host *shost)\r\n{\r\nvoid (*my_done) (Scsi_Cmnd *) = NULL;\r\nint errstatus, mbi, mbo, mbistatus;\r\nint number_serviced;\r\nunsigned long flags;\r\nScsi_Cmnd *SCtmp;\r\nint flag;\r\nint needs_restart;\r\nstruct mailbox *mb;\r\nstruct ccb *ccb;\r\nmb = HOSTDATA(shost)->mb;\r\nccb = HOSTDATA(shost)->ccb;\r\n#ifdef DEBUG\r\n{\r\nflag = inb(INTRFLAGS(shost->io_port));\r\nprintk(KERN_DEBUG "aha1542_intr_handle: ");\r\nif (!(flag & ANYINTR))\r\nprintk("no interrupt?");\r\nif (flag & MBIF)\r\nprintk("MBIF ");\r\nif (flag & MBOA)\r\nprintk("MBOF ");\r\nif (flag & HACC)\r\nprintk("HACC ");\r\nif (flag & SCRD)\r\nprintk("SCRD ");\r\nprintk("status %02x\n", inb(STATUS(shost->io_port)));\r\n};\r\n#endif\r\nnumber_serviced = 0;\r\nneeds_restart = 0;\r\nwhile (1 == 1) {\r\nflag = inb(INTRFLAGS(shost->io_port));\r\nif (flag & ~MBIF) {\r\nif (flag & MBOA)\r\nprintk("MBOF ");\r\nif (flag & HACC)\r\nprintk("HACC ");\r\nif (flag & SCRD) {\r\nneeds_restart = 1;\r\nprintk("SCRD ");\r\n}\r\n}\r\naha1542_intr_reset(shost->io_port);\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nmbi = HOSTDATA(shost)->aha1542_last_mbi_used + 1;\r\nif (mbi >= 2 * AHA1542_MAILBOXES)\r\nmbi = AHA1542_MAILBOXES;\r\ndo {\r\nif (mb[mbi].status != 0)\r\nbreak;\r\nmbi++;\r\nif (mbi >= 2 * AHA1542_MAILBOXES)\r\nmbi = AHA1542_MAILBOXES;\r\n} while (mbi != HOSTDATA(shost)->aha1542_last_mbi_used);\r\nif (mb[mbi].status == 0) {\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nif (!number_serviced && !needs_restart)\r\nprintk(KERN_WARNING "aha1542.c: interrupt received, but no mail.\n");\r\nif (needs_restart)\r\naha1542_restart(shost);\r\nreturn;\r\n};\r\nmbo = (scsi2int(mb[mbi].ccbptr) - (SCSI_BUF_PA(&ccb[0]))) / sizeof(struct ccb);\r\nmbistatus = mb[mbi].status;\r\nmb[mbi].status = 0;\r\nHOSTDATA(shost)->aha1542_last_mbi_used = mbi;\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\n#ifdef DEBUG\r\n{\r\nif (ccb[mbo].tarstat | ccb[mbo].hastat)\r\nprintk(KERN_DEBUG "aha1542_command: returning %x (status %d)\n",\r\nccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);\r\n};\r\n#endif\r\nif (mbistatus == 3)\r\ncontinue;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "...done %d %d\n", mbo, mbi);\r\n#endif\r\nSCtmp = HOSTDATA(shost)->SCint[mbo];\r\nif (!SCtmp || !SCtmp->scsi_done) {\r\nprintk(KERN_WARNING "aha1542_intr_handle: Unexpected interrupt\n");\r\nprintk(KERN_WARNING "tarstat=%x, hastat=%x idlun=%x ccb#=%d \n", ccb[mbo].tarstat,\r\nccb[mbo].hastat, ccb[mbo].idlun, mbo);\r\nreturn;\r\n}\r\nmy_done = SCtmp->scsi_done;\r\nkfree(SCtmp->host_scribble);\r\nSCtmp->host_scribble = NULL;\r\nif (ccb[mbo].tarstat == 2)\r\nmemcpy(SCtmp->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],\r\nSCSI_SENSE_BUFFERSIZE);\r\nif (mbistatus != 1)\r\nerrstatus = makecode(ccb[mbo].hastat, ccb[mbo].tarstat);\r\nelse\r\nerrstatus = 0;\r\n#ifdef DEBUG\r\nif (errstatus)\r\nprintk(KERN_DEBUG "(aha1542 error:%x %x %x) ", errstatus,\r\nccb[mbo].hastat, ccb[mbo].tarstat);\r\n#endif\r\nif (ccb[mbo].tarstat == 2) {\r\n#ifdef DEBUG\r\nint i;\r\n#endif\r\nDEB(printk("aha1542_intr_handle: sense:"));\r\n#ifdef DEBUG\r\nfor (i = 0; i < 12; i++)\r\nprintk("%02x ", ccb[mbo].cdb[ccb[mbo].cdblen + i]);\r\nprintk("\n");\r\n#endif\r\n}\r\nDEB(if (errstatus) printk("aha1542_intr_handle: returning %6x\n", errstatus));\r\nSCtmp->result = errstatus;\r\nHOSTDATA(shost)->SCint[mbo] = NULL;\r\nmy_done(SCtmp);\r\nnumber_serviced++;\r\n};\r\n}\r\nstatic int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))\r\n{\r\nunchar ahacmd = CMD_START_SCSI;\r\nunchar direction;\r\nunchar *cmd = (unchar *) SCpnt->cmnd;\r\nunchar target = SCpnt->device->id;\r\nunchar lun = SCpnt->device->lun;\r\nunsigned long flags;\r\nint bufflen = scsi_bufflen(SCpnt);\r\nint mbo;\r\nstruct mailbox *mb;\r\nstruct ccb *ccb;\r\nDEB(int i);\r\nmb = HOSTDATA(SCpnt->device->host)->mb;\r\nccb = HOSTDATA(SCpnt->device->host)->ccb;\r\nDEB(if (target > 1) {\r\nSCpnt->result = DID_TIME_OUT << 16;\r\ndone(SCpnt); return 0;\r\n}\r\n);\r\nif (*cmd == REQUEST_SENSE) {\r\n#if 0\r\nif (bufflen != SCSI_SENSE_BUFFERSIZE)\r\nprintk(KERN_CRIT "aha1542: Wrong buffer length supplied "\r\n"for request sense (%d)\n", bufflen);\r\n#endif\r\nSCpnt->result = 0;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\n#ifdef DEBUG\r\nif (*cmd == READ_10 || *cmd == WRITE_10)\r\ni = xscsi2int(cmd + 2);\r\nelse if (*cmd == READ_6 || *cmd == WRITE_6)\r\ni = scsi2int(cmd + 2);\r\nelse\r\ni = -1;\r\nif (done)\r\nprintk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);\r\nelse\r\nprintk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);\r\naha1542_stat();\r\nprintk(KERN_DEBUG "aha1542_queuecommand: dumping scsi cmd:");\r\nfor (i = 0; i < SCpnt->cmd_len; i++)\r\nprintk("%02x ", cmd[i]);\r\nprintk("\n");\r\nif (*cmd == WRITE_10 || *cmd == WRITE_6)\r\nreturn 0;\r\n#endif\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nmbo = HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used + 1;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\ndo {\r\nif (mb[mbo].status == 0 && HOSTDATA(SCpnt->device->host)->SCint[mbo] == NULL)\r\nbreak;\r\nmbo++;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\n} while (mbo != HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used);\r\nif (mb[mbo].status || HOSTDATA(SCpnt->device->host)->SCint[mbo])\r\npanic("Unable to find empty mailbox for aha1542.\n");\r\nHOSTDATA(SCpnt->device->host)->SCint[mbo] = SCpnt;\r\nHOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "Sending command (%d %x)...", mbo, done);\r\n#endif\r\nany2scsi(mb[mbo].ccbptr, SCSI_BUF_PA(&ccb[mbo]));\r\nmemset(&ccb[mbo], 0, sizeof(struct ccb));\r\nccb[mbo].cdblen = SCpnt->cmd_len;\r\ndirection = 0;\r\nif (*cmd == READ_10 || *cmd == READ_6)\r\ndirection = 8;\r\nelse if (*cmd == WRITE_10 || *cmd == WRITE_6)\r\ndirection = 16;\r\nmemcpy(ccb[mbo].cdb, cmd, ccb[mbo].cdblen);\r\nif (bufflen) {\r\nstruct scatterlist *sg;\r\nstruct chain *cptr;\r\n#ifdef DEBUG\r\nunsigned char *ptr;\r\n#endif\r\nint i, sg_count = scsi_sg_count(SCpnt);\r\nccb[mbo].op = 2;\r\nSCpnt->host_scribble = kmalloc(sizeof(*cptr)*sg_count,\r\nGFP_KERNEL | GFP_DMA);\r\ncptr = (struct chain *) SCpnt->host_scribble;\r\nif (cptr == NULL) {\r\nHOSTDATA(SCpnt->device->host)->SCint[mbo] = NULL;\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nscsi_for_each_sg(SCpnt, sg, sg_count, i) {\r\nany2scsi(cptr[i].dataptr, SCSI_SG_PA(sg));\r\nany2scsi(cptr[i].datalen, sg->length);\r\n};\r\nany2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));\r\nany2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(cptr));\r\n#ifdef DEBUG\r\nprintk("cptr %x: ", cptr);\r\nptr = (unsigned char *) cptr;\r\nfor (i = 0; i < 18; i++)\r\nprintk("%02x ", ptr[i]);\r\n#endif\r\n} else {\r\nccb[mbo].op = 0;\r\nSCpnt->host_scribble = NULL;\r\nany2scsi(ccb[mbo].datalen, 0);\r\nany2scsi(ccb[mbo].dataptr, 0);\r\n};\r\nccb[mbo].idlun = (target & 7) << 5 | direction | (lun & 7);\r\nccb[mbo].rsalen = 16;\r\nccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;\r\nccb[mbo].commlinkid = 0;\r\n#ifdef DEBUG\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "aha1542_command: sending.. ");\r\nfor (i = 0; i < sizeof(ccb[mbo]) - 10; i++)\r\nprintk("%02x ", ((unchar *) & ccb[mbo])[i]);\r\n};\r\n#endif\r\nif (done) {\r\nDEB(printk("aha1542_queuecommand: now waiting for interrupt ");\r\naha1542_stat());\r\nSCpnt->scsi_done = done;\r\nmb[mbo].status = 1;\r\naha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);\r\nDEB(aha1542_stat());\r\n} else\r\nprintk("aha1542_queuecommand: done can't be NULL\n");\r\nreturn 0;\r\n}\r\nint __init aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)\r\n{\r\nunchar inquiry_cmd[] = {CMD_RETCONF};\r\nunchar inquiry_result[3];\r\nint i;\r\ni = inb(STATUS(base_io));\r\nif (i & DF) {\r\ni = inb(DATA(base_io));\r\n};\r\naha1542_out(base_io, inquiry_cmd, 1);\r\naha1542_in(base_io, inquiry_result, 3);\r\nWAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);\r\nwhile (0) {\r\nfail:\r\nprintk(KERN_ERR "aha1542_detect: query board settings\n");\r\n}\r\naha1542_intr_reset(base_io);\r\nswitch (inquiry_result[0]) {\r\ncase 0x80:\r\n*dma_chan = 7;\r\nbreak;\r\ncase 0x40:\r\n*dma_chan = 6;\r\nbreak;\r\ncase 0x20:\r\n*dma_chan = 5;\r\nbreak;\r\ncase 0x01:\r\n*dma_chan = 0;\r\nbreak;\r\ncase 0:\r\n*dma_chan = 0xFF;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unable to determine Adaptec DMA priority. Disabling board\n");\r\nreturn -1;\r\n};\r\nswitch (inquiry_result[1]) {\r\ncase 0x40:\r\n*irq_level = 15;\r\nbreak;\r\ncase 0x20:\r\n*irq_level = 14;\r\nbreak;\r\ncase 0x8:\r\n*irq_level = 12;\r\nbreak;\r\ncase 0x4:\r\n*irq_level = 11;\r\nbreak;\r\ncase 0x2:\r\n*irq_level = 10;\r\nbreak;\r\ncase 0x1:\r\n*irq_level = 9;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unable to determine Adaptec IRQ level. Disabling board\n");\r\nreturn -1;\r\n};\r\n*scsi_id = inquiry_result[2] & 7;\r\nreturn 0;\r\n}\r\nstatic int __init aha1542_mbenable(int base)\r\n{\r\nstatic unchar mbenable_cmd[3];\r\nstatic unchar mbenable_result[2];\r\nint retval;\r\nretval = BIOS_TRANSLATION_6432;\r\nmbenable_cmd[0] = CMD_EXTBIOS;\r\naha1542_out(base, mbenable_cmd, 1);\r\nif (aha1542_in1(base, mbenable_result, 2))\r\nreturn retval;\r\nWAITd(INTRFLAGS(base), INTRMASK, HACC, 0, 100);\r\naha1542_intr_reset(base);\r\nif ((mbenable_result[0] & 0x08) || mbenable_result[1]) {\r\nmbenable_cmd[0] = CMD_MBENABLE;\r\nmbenable_cmd[1] = 0;\r\nmbenable_cmd[2] = mbenable_result[1];\r\nif ((mbenable_result[0] & 0x08) && (mbenable_result[1] & 0x03))\r\nretval = BIOS_TRANSLATION_25563;\r\naha1542_out(base, mbenable_cmd, 3);\r\nWAIT(INTRFLAGS(base), INTRMASK, HACC, 0);\r\n};\r\nwhile (0) {\r\nfail:\r\nprintk(KERN_ERR "aha1542_mbenable: Mailbox init failed\n");\r\n}\r\naha1542_intr_reset(base);\r\nreturn retval;\r\n}\r\nstatic int __init aha1542_query(int base_io, int *transl)\r\n{\r\nunchar inquiry_cmd[] = {CMD_INQUIRY};\r\nunchar inquiry_result[4];\r\nint i;\r\ni = inb(STATUS(base_io));\r\nif (i & DF) {\r\ni = inb(DATA(base_io));\r\n};\r\naha1542_out(base_io, inquiry_cmd, 1);\r\naha1542_in(base_io, inquiry_result, 4);\r\nWAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);\r\nwhile (0) {\r\nfail:\r\nprintk(KERN_ERR "aha1542_detect: query card type\n");\r\n}\r\naha1542_intr_reset(base_io);\r\n*transl = BIOS_TRANSLATION_6432;\r\nif (inquiry_result[0] == 0x43) {\r\nprintk(KERN_INFO "aha1542.c: Emulation mode not supported for AHA 174N hardware.\n");\r\nreturn 1;\r\n};\r\n*transl = aha1542_mbenable(base_io);\r\nreturn 0;\r\n}\r\nstatic void __init aha1542_setup(char *str, int *ints)\r\n{\r\nconst char *ahausage = "aha1542: usage: aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]\n";\r\nint setup_portbase;\r\nif (setup_idx >= MAXBOARDS) {\r\nprintk(KERN_ERR "aha1542: aha1542_setup called too many times! Bad LILO params ?\n");\r\nprintk(KERN_ERR " Entryline 1: %s\n", setup_str[0]);\r\nprintk(KERN_ERR " Entryline 2: %s\n", setup_str[1]);\r\nprintk(KERN_ERR " This line: %s\n", str);\r\nreturn;\r\n}\r\nif (ints[0] < 1 || ints[0] > 4) {\r\nprintk(KERN_ERR "aha1542: %s\n", str);\r\nprintk(ahausage);\r\nprintk(KERN_ERR "aha1542: Wrong parameters may cause system malfunction.. We try anyway..\n");\r\n}\r\nsetup_called[setup_idx] = ints[0];\r\nsetup_str[setup_idx] = str;\r\nsetup_portbase = ints[0] >= 1 ? ints[1] : 0;\r\nsetup_buson[setup_idx] = ints[0] >= 2 ? ints[2] : 7;\r\nsetup_busoff[setup_idx] = ints[0] >= 3 ? ints[3] : 5;\r\nif (ints[0] >= 4)\r\n{\r\nint atbt = -1;\r\nswitch (ints[4]) {\r\ncase 5:\r\natbt = 0x00;\r\nbreak;\r\ncase 6:\r\natbt = 0x04;\r\nbreak;\r\ncase 7:\r\natbt = 0x01;\r\nbreak;\r\ncase 8:\r\natbt = 0x02;\r\nbreak;\r\ncase 10:\r\natbt = 0x03;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aha1542: %s\n", str);\r\nprintk(ahausage);\r\nprintk(KERN_ERR "aha1542: Valid values for DMASPEED are 5-8, 10 MB/s. Using jumper defaults.\n");\r\nbreak;\r\n}\r\nsetup_dmaspeed[setup_idx] = atbt;\r\n}\r\nif (setup_portbase != 0)\r\nbases[setup_idx] = setup_portbase;\r\n++setup_idx;\r\n}\r\nstatic int __init do_setup(char *str)\r\n{\r\nint ints[5];\r\nint count=setup_idx;\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\naha1542_setup(str,ints);\r\nreturn count<setup_idx;\r\n}\r\nstatic int __init aha1542_detect(struct scsi_host_template * tpnt)\r\n{\r\nunsigned char dma_chan;\r\nunsigned char irq_level;\r\nunsigned char scsi_id;\r\nunsigned long flags;\r\nunsigned int base_io;\r\nint trans;\r\nstruct Scsi_Host *shpnt = NULL;\r\nint count = 0;\r\nint indx;\r\nDEB(printk("aha1542_detect: \n"));\r\ntpnt->proc_name = "aha1542";\r\n#ifdef MODULE\r\nbases[0] = aha1542[0];\r\nsetup_buson[0] = aha1542[1];\r\nsetup_busoff[0] = aha1542[2];\r\n{\r\nint atbt = -1;\r\nswitch (aha1542[3]) {\r\ncase 5:\r\natbt = 0x00;\r\nbreak;\r\ncase 6:\r\natbt = 0x04;\r\nbreak;\r\ncase 7:\r\natbt = 0x01;\r\nbreak;\r\ncase 8:\r\natbt = 0x02;\r\nbreak;\r\ncase 10:\r\natbt = 0x03;\r\nbreak;\r\n};\r\nsetup_dmaspeed[0] = atbt;\r\n}\r\n#endif\r\nif(isapnp)\r\n{\r\nstruct pnp_dev *pdev = NULL;\r\nfor(indx = 0; indx < ARRAY_SIZE(bases); indx++) {\r\nif(bases[indx])\r\ncontinue;\r\npdev = pnp_find_dev(NULL, ISAPNP_VENDOR('A', 'D', 'P'),\r\nISAPNP_FUNCTION(0x1542), pdev);\r\nif(pdev==NULL)\r\nbreak;\r\nif(pnp_device_attach(pdev)<0)\r\ncontinue;\r\nif(pnp_activate_dev(pdev)<0) {\r\npnp_device_detach(pdev);\r\ncontinue;\r\n}\r\nif(!pnp_port_valid(pdev, 0)) {\r\npnp_device_detach(pdev);\r\ncontinue;\r\n}\r\nbases[indx] = pnp_port_start(pdev, 0);\r\nprintk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", bases[indx]);\r\n}\r\n}\r\nfor (indx = 0; indx < ARRAY_SIZE(bases); indx++)\r\nif (bases[indx] != 0 && request_region(bases[indx], 4, "aha1542")) {\r\nshpnt = scsi_register(tpnt,\r\nsizeof(struct aha1542_hostdata));\r\nif(shpnt==NULL) {\r\nrelease_region(bases[indx], 4);\r\ncontinue;\r\n}\r\nif (!aha1542_test_port(bases[indx], shpnt))\r\ngoto unregister;\r\nbase_io = bases[indx];\r\n{\r\nunchar oncmd[] = {CMD_BUSON_TIME, 7};\r\nunchar offcmd[] = {CMD_BUSOFF_TIME, 5};\r\nif (setup_called[indx]) {\r\noncmd[1] = setup_buson[indx];\r\noffcmd[1] = setup_busoff[indx];\r\n}\r\naha1542_intr_reset(base_io);\r\naha1542_out(base_io, oncmd, 2);\r\nWAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);\r\naha1542_intr_reset(base_io);\r\naha1542_out(base_io, offcmd, 2);\r\nWAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);\r\nif (setup_dmaspeed[indx] >= 0) {\r\nunchar dmacmd[] = {CMD_DMASPEED, 0};\r\ndmacmd[1] = setup_dmaspeed[indx];\r\naha1542_intr_reset(base_io);\r\naha1542_out(base_io, dmacmd, 2);\r\nWAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);\r\n}\r\nwhile (0) {\r\nfail:\r\nprintk(KERN_ERR "aha1542_detect: setting bus on/off-time failed\n");\r\n}\r\naha1542_intr_reset(base_io);\r\n}\r\nif (aha1542_query(base_io, &trans))\r\ngoto unregister;\r\nif (aha1542_getconfig(base_io, &irq_level, &dma_chan, &scsi_id) == -1)\r\ngoto unregister;\r\nprintk(KERN_INFO "Configuring Adaptec (SCSI-ID %d) at IO:%x, IRQ %d", scsi_id, base_io, irq_level);\r\nif (dma_chan != 0xFF)\r\nprintk(", DMA priority %d", dma_chan);\r\nprintk("\n");\r\nDEB(aha1542_stat());\r\nsetup_mailboxes(base_io, shpnt);\r\nDEB(aha1542_stat());\r\nDEB(printk("aha1542_detect: enable interrupt channel %d\n", irq_level));\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nif (request_irq(irq_level, do_aha1542_intr_handle, 0,\r\n"aha1542", shpnt)) {\r\nprintk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\ngoto unregister;\r\n}\r\nif (dma_chan != 0xFF) {\r\nif (request_dma(dma_chan, "aha1542")) {\r\nprintk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");\r\nfree_irq(irq_level, shpnt);\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\ngoto unregister;\r\n}\r\nif (dma_chan == 0 || dma_chan >= 5) {\r\nset_dma_mode(dma_chan, DMA_MODE_CASCADE);\r\nenable_dma(dma_chan);\r\n}\r\n}\r\nshpnt->this_id = scsi_id;\r\nshpnt->unique_id = base_io;\r\nshpnt->io_port = base_io;\r\nshpnt->n_io_port = 4;\r\nshpnt->dma_channel = dma_chan;\r\nshpnt->irq = irq_level;\r\nHOSTDATA(shpnt)->bios_translation = trans;\r\nif (trans == BIOS_TRANSLATION_25563)\r\nprintk(KERN_INFO "aha1542.c: Using extended bios translation\n");\r\nHOSTDATA(shpnt)->aha1542_last_mbi_used = (2 * AHA1542_MAILBOXES - 1);\r\nHOSTDATA(shpnt)->aha1542_last_mbo_used = (AHA1542_MAILBOXES - 1);\r\nmemset(HOSTDATA(shpnt)->SCint, 0, sizeof(HOSTDATA(shpnt)->SCint));\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\n#if 0\r\nDEB(printk(" *** READ CAPACITY ***\n"));\r\n{\r\nunchar buf[8];\r\nstatic unchar cmd[] = { READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nint i;\r\nfor (i = 0; i < sizeof(buf); ++i)\r\nbuf[i] = 0x87;\r\nfor (i = 0; i < 2; ++i)\r\nif (!aha1542_command(i, cmd, buf, sizeof(buf))) {\r\nprintk(KERN_DEBUG "aha_detect: LU %d sector_size %d device_size %d\n",\r\ni, xscsi2int(buf + 4), xscsi2int(buf));\r\n}\r\n}\r\nDEB(printk(" *** NOW RUNNING MY OWN TEST *** \n"));\r\nfor (i = 0; i < 4; ++i) {\r\nunsigned char cmd[10];\r\nstatic buffer[512];\r\ncmd[0] = READ_10;\r\ncmd[1] = 0;\r\nxany2scsi(cmd + 2, i);\r\ncmd[6] = 0;\r\ncmd[7] = 0;\r\ncmd[8] = 1;\r\ncmd[9] = 0;\r\naha1542_command(0, cmd, buffer, 512);\r\n}\r\n#endif\r\ncount++;\r\ncontinue;\r\nunregister:\r\nrelease_region(bases[indx], 4);\r\nscsi_unregister(shpnt);\r\ncontinue;\r\n};\r\nreturn count;\r\n}\r\nstatic int aha1542_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nif (shost->dma_channel != 0xff)\r\nfree_dma(shost->dma_channel);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\nreturn 0;\r\n}\r\nstatic int aha1542_restart(struct Scsi_Host *shost)\r\n{\r\nint i;\r\nint count = 0;\r\n#if 0\r\nunchar ahacmd = CMD_START_SCSI;\r\n#endif\r\nfor (i = 0; i < AHA1542_MAILBOXES; i++)\r\nif (HOSTDATA(shost)->SCint[i] &&\r\n!(HOSTDATA(shost)->SCint[i]->device->soft_reset)) {\r\n#if 0\r\nHOSTDATA(shost)->mb[i].status = 1;\r\n#endif\r\ncount++;\r\n}\r\nprintk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);\r\n#if 0\r\nif (count)\r\naha1542_out(shost->io_port, &ahacmd, 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aha1542_dev_reset(Scsi_Cmnd * SCpnt)\r\n{\r\nunsigned long flags;\r\nstruct mailbox *mb;\r\nunchar target = SCpnt->device->id;\r\nunchar lun = SCpnt->device->lun;\r\nint mbo;\r\nstruct ccb *ccb;\r\nunchar ahacmd = CMD_START_SCSI;\r\nccb = HOSTDATA(SCpnt->device->host)->ccb;\r\nmb = HOSTDATA(SCpnt->device->host)->mb;\r\nspin_lock_irqsave(&aha1542_lock, flags);\r\nmbo = HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used + 1;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\ndo {\r\nif (mb[mbo].status == 0 && HOSTDATA(SCpnt->device->host)->SCint[mbo] == NULL)\r\nbreak;\r\nmbo++;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\n} while (mbo != HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used);\r\nif (mb[mbo].status || HOSTDATA(SCpnt->device->host)->SCint[mbo])\r\npanic("Unable to find empty mailbox for aha1542.\n");\r\nHOSTDATA(SCpnt->device->host)->SCint[mbo] = SCpnt;\r\nHOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;\r\nspin_unlock_irqrestore(&aha1542_lock, flags);\r\nany2scsi(mb[mbo].ccbptr, SCSI_BUF_PA(&ccb[mbo]));\r\nmemset(&ccb[mbo], 0, sizeof(struct ccb));\r\nccb[mbo].op = 0x81;\r\nccb[mbo].idlun = (target & 7) << 5 | (lun & 7);\r\nccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;\r\nccb[mbo].commlinkid = 0;\r\naha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);\r\nscmd_printk(KERN_WARNING, SCpnt,\r\n"Trying device reset for target\n");\r\nreturn SUCCESS;\r\n#ifdef ERIC_neverdef\r\nprintk(KERN_WARNING "Sent BUS DEVICE RESET to target %d\n", SCpnt->target);\r\nfor (i = 0; i < AHA1542_MAILBOXES; i++) {\r\nif (HOSTDATA(SCpnt->host)->SCint[i] &&\r\nHOSTDATA(SCpnt->host)->SCint[i]->target == SCpnt->target) {\r\nScsi_Cmnd *SCtmp;\r\nSCtmp = HOSTDATA(SCpnt->host)->SCint[i];\r\nkfree(SCtmp->host_scribble);\r\nSCtmp->host_scribble = NULL;\r\nHOSTDATA(SCpnt->host)->SCint[i] = NULL;\r\nHOSTDATA(SCpnt->host)->mb[i].status = 0;\r\n}\r\n}\r\nreturn SUCCESS;\r\nreturn FAILED;\r\n#endif\r\n}\r\nstatic int aha1542_bus_reset(Scsi_Cmnd * SCpnt)\r\n{\r\nint i;\r\noutb(SCRST, CONTROL(SCpnt->device->host->io_port));\r\nssleep(4);\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nWAIT(STATUS(SCpnt->device->host->io_port),\r\nSTATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);\r\nprintk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);\r\nfor (i = 0; i < AHA1542_MAILBOXES; i++) {\r\nif (HOSTDATA(SCpnt->device->host)->SCint[i] != NULL) {\r\nScsi_Cmnd *SCtmp;\r\nSCtmp = HOSTDATA(SCpnt->device->host)->SCint[i];\r\nif (SCtmp->device->soft_reset) {\r\ncontinue;\r\n}\r\nkfree(SCtmp->host_scribble);\r\nSCtmp->host_scribble = NULL;\r\nHOSTDATA(SCpnt->device->host)->SCint[i] = NULL;\r\nHOSTDATA(SCpnt->device->host)->mb[i].status = 0;\r\n}\r\n}\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn SUCCESS;\r\nfail:\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn FAILED;\r\n}\r\nstatic int aha1542_host_reset(Scsi_Cmnd * SCpnt)\r\n{\r\nint i;\r\noutb(HRST | SCRST, CONTROL(SCpnt->device->host->io_port));\r\nssleep(4);\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nWAIT(STATUS(SCpnt->device->host->io_port),\r\nSTATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);\r\nsetup_mailboxes(SCpnt->device->host->io_port, SCpnt->device->host);\r\nprintk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);\r\nfor (i = 0; i < AHA1542_MAILBOXES; i++) {\r\nif (HOSTDATA(SCpnt->device->host)->SCint[i] != NULL) {\r\nScsi_Cmnd *SCtmp;\r\nSCtmp = HOSTDATA(SCpnt->device->host)->SCint[i];\r\nif (SCtmp->device->soft_reset) {\r\ncontinue;\r\n}\r\nkfree(SCtmp->host_scribble);\r\nSCtmp->host_scribble = NULL;\r\nHOSTDATA(SCpnt->device->host)->SCint[i] = NULL;\r\nHOSTDATA(SCpnt->device->host)->mb[i].status = 0;\r\n}\r\n}\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn SUCCESS;\r\nfail:\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn FAILED;\r\n}\r\nstatic int aha1542_biosparam(struct scsi_device *sdev,\r\nstruct block_device *bdev, sector_t capacity, int *ip)\r\n{\r\nint translation_algorithm;\r\nint size = capacity;\r\ntranslation_algorithm = HOSTDATA(sdev->host)->bios_translation;\r\nif ((size >> 11) > 1024 && translation_algorithm == BIOS_TRANSLATION_25563) {\r\nip[0] = 255;\r\nip[1] = 63;\r\nip[2] = size / 255 / 63;\r\n} else {\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = size >> 11;\r\n}\r\nreturn 0;\r\n}
