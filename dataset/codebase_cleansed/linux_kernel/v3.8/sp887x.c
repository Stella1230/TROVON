static int i2c_writebytes (struct sp887x_state* state, u8 *buf, u8 len)\r\n{\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = len };\r\nint err;\r\nif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\r\nprintk ("%s: i2c write error (addr %02x, err == %i)\n",\r\n__func__, state->config->demod_address, err);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sp887x_writereg (struct sp887x_state* state, u16 reg, u16 data)\r\n{\r\nu8 b0 [] = { reg >> 8 , reg & 0xff, data >> 8, data & 0xff };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 4 };\r\nint ret;\r\nif ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1) {\r\nif (!(reg == 0xf1a && data == 0x000 &&\r\n(ret == -EREMOTEIO || ret == -EFAULT)))\r\n{\r\nprintk("%s: writereg error "\r\n"(reg %03x, data %03x, ret == %i)\n",\r\n__func__, reg & 0xffff, data & 0xffff, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sp887x_readreg (struct sp887x_state* state, u16 reg)\r\n{\r\nu8 b0 [] = { reg >> 8 , reg & 0xff };\r\nu8 b1 [2];\r\nint ret;\r\nstruct i2c_msg msg[] = {{ .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 2 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 2 }};\r\nif ((ret = i2c_transfer(state->i2c, msg, 2)) != 2) {\r\nprintk("%s: readreg error (ret == %i)\n", __func__, ret);\r\nreturn -1;\r\n}\r\nreturn (((b1[0] << 8) | b1[1]) & 0xfff);\r\n}\r\nstatic void sp887x_microcontroller_stop (struct sp887x_state* state)\r\n{\r\ndprintk("%s\n", __func__);\r\nsp887x_writereg(state, 0xf08, 0x000);\r\nsp887x_writereg(state, 0xf09, 0x000);\r\nsp887x_writereg(state, 0xf00, 0x000);\r\n}\r\nstatic void sp887x_microcontroller_start (struct sp887x_state* state)\r\n{\r\ndprintk("%s\n", __func__);\r\nsp887x_writereg(state, 0xf08, 0x000);\r\nsp887x_writereg(state, 0xf09, 0x000);\r\nsp887x_writereg(state, 0xf00, 0x001);\r\n}\r\nstatic void sp887x_setup_agc (struct sp887x_state* state)\r\n{\r\ndprintk("%s\n", __func__);\r\nsp887x_writereg(state, 0x33c, 0x054);\r\nsp887x_writereg(state, 0x33b, 0x04c);\r\nsp887x_writereg(state, 0x328, 0x000);\r\nsp887x_writereg(state, 0x327, 0x005);\r\nsp887x_writereg(state, 0x326, 0x001);\r\nsp887x_writereg(state, 0x325, 0x001);\r\nsp887x_writereg(state, 0x324, 0x001);\r\nsp887x_writereg(state, 0x318, 0x050);\r\nsp887x_writereg(state, 0x317, 0x3fe);\r\nsp887x_writereg(state, 0x316, 0x001);\r\nsp887x_writereg(state, 0x313, 0x005);\r\nsp887x_writereg(state, 0x312, 0x002);\r\nsp887x_writereg(state, 0x306, 0x000);\r\nsp887x_writereg(state, 0x303, 0x000);\r\n}\r\nstatic int sp887x_initial_setup (struct dvb_frontend* fe, const struct firmware *fw)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nu8 buf [BLOCKSIZE+2];\r\nint i;\r\nint fw_size = fw->size;\r\nconst unsigned char *mem = fw->data;\r\ndprintk("%s\n", __func__);\r\nif (fw_size < FW_SIZE+10)\r\nreturn -ENODEV;\r\nmem = fw->data + 10;\r\nsp887x_writereg(state, 0xf1a, 0x000);\r\nsp887x_microcontroller_stop (state);\r\nprintk ("%s: firmware upload... ", __func__);\r\nsp887x_writereg(state, 0x8f08, 0x1fff);\r\nsp887x_writereg(state, 0x8f0a, 0x0000);\r\nfor (i = 0; i < FW_SIZE; i += BLOCKSIZE) {\r\nint c = BLOCKSIZE;\r\nint err;\r\nif (i+c > FW_SIZE)\r\nc = FW_SIZE - i;\r\nbuf[0] = 0xcf;\r\nbuf[1] = 0x0a;\r\nmemcpy(&buf[2], mem + i, c);\r\nif ((err = i2c_writebytes (state, buf, c+2)) < 0) {\r\nprintk ("failed.\n");\r\nprintk ("%s: i2c error (err == %i)\n", __func__, err);\r\nreturn err;\r\n}\r\n}\r\nsp887x_writereg(state, 0xc13, 0x001);\r\nsp887x_writereg(state, 0xc14, 0x000);\r\nsp887x_writereg(state, 0xc1a, 0x872);\r\nsp887x_writereg(state, 0xc1b, 0x001);\r\nsp887x_writereg(state, 0xc1c, 0x000);\r\nsp887x_writereg(state, 0xc1a, 0x871);\r\nsp887x_writereg(state, 0x301, 0x002);\r\nsp887x_setup_agc(state);\r\nsp887x_writereg(state, 0xd00, 0x010);\r\nsp887x_writereg(state, 0x0d1, 0x000);\r\nreturn 0;\r\n}\r\nstatic int configure_reg0xc05(struct dtv_frontend_properties *p, u16 *reg0xc05)\r\n{\r\nint known_parameters = 1;\r\n*reg0xc05 = 0x000;\r\nswitch (p->modulation) {\r\ncase QPSK:\r\nbreak;\r\ncase QAM_16:\r\n*reg0xc05 |= (1 << 10);\r\nbreak;\r\ncase QAM_64:\r\n*reg0xc05 |= (2 << 10);\r\nbreak;\r\ncase QAM_AUTO:\r\nknown_parameters = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (p->hierarchy) {\r\ncase HIERARCHY_NONE:\r\nbreak;\r\ncase HIERARCHY_1:\r\n*reg0xc05 |= (1 << 7);\r\nbreak;\r\ncase HIERARCHY_2:\r\n*reg0xc05 |= (2 << 7);\r\nbreak;\r\ncase HIERARCHY_4:\r\n*reg0xc05 |= (3 << 7);\r\nbreak;\r\ncase HIERARCHY_AUTO:\r\nknown_parameters = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (p->code_rate_HP) {\r\ncase FEC_1_2:\r\nbreak;\r\ncase FEC_2_3:\r\n*reg0xc05 |= (1 << 3);\r\nbreak;\r\ncase FEC_3_4:\r\n*reg0xc05 |= (2 << 3);\r\nbreak;\r\ncase FEC_5_6:\r\n*reg0xc05 |= (3 << 3);\r\nbreak;\r\ncase FEC_7_8:\r\n*reg0xc05 |= (4 << 3);\r\nbreak;\r\ncase FEC_AUTO:\r\nknown_parameters = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (known_parameters)\r\n*reg0xc05 |= (2 << 1);\r\nelse\r\n*reg0xc05 |= (1 << 1);\r\nreturn 0;\r\n}\r\nstatic void divide (int n, int d, int *quotient_i, int *quotient_f)\r\n{\r\nunsigned int q, r;\r\nr = (n % d) << 8;\r\nq = (r / d);\r\nif (quotient_i)\r\n*quotient_i = q;\r\nif (quotient_f) {\r\nr = (r % d) << 8;\r\nq = (q << 8) | (r / d);\r\nr = (r % d) << 8;\r\n*quotient_f = (q << 8) | (r / d);\r\n}\r\n}\r\nstatic void sp887x_correct_offsets (struct sp887x_state* state,\r\nstruct dtv_frontend_properties *p,\r\nint actual_freq)\r\n{\r\nstatic const u32 srate_correction [] = { 1879617, 4544878, 8098561 };\r\nint bw_index;\r\nint freq_offset = actual_freq - p->frequency;\r\nint sysclock = 61003;\r\nint ifreq = 36000000;\r\nint freq;\r\nint frequency_shift;\r\nswitch (p->bandwidth_hz) {\r\ndefault:\r\ncase 8000000:\r\nbw_index = 0;\r\nbreak;\r\ncase 7000000:\r\nbw_index = 1;\r\nbreak;\r\ncase 6000000:\r\nbw_index = 2;\r\nbreak;\r\n}\r\nif (p->inversion == INVERSION_ON)\r\nfreq = ifreq - freq_offset;\r\nelse\r\nfreq = ifreq + freq_offset;\r\ndivide(freq / 333, sysclock, NULL, &frequency_shift);\r\nif (p->inversion == INVERSION_ON)\r\nfrequency_shift = -frequency_shift;\r\nsp887x_writereg(state, 0x319, srate_correction[bw_index] >> 12);\r\nsp887x_writereg(state, 0x31a, srate_correction[bw_index] & 0xfff);\r\nsp887x_writereg(state, 0x309, frequency_shift >> 12);\r\nsp887x_writereg(state, 0x30a, frequency_shift & 0xfff);\r\n}\r\nstatic int sp887x_setup_frontend_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nunsigned actual_freq;\r\nint err;\r\nu16 val, reg0xc05;\r\nif (p->bandwidth_hz != 8000000 &&\r\np->bandwidth_hz != 7000000 &&\r\np->bandwidth_hz != 6000000)\r\nreturn -EINVAL;\r\nif ((err = configure_reg0xc05(p, &reg0xc05)))\r\nreturn err;\r\nsp887x_microcontroller_stop(state);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (fe->ops.tuner_ops.get_frequency) {\r\nfe->ops.tuner_ops.get_frequency(fe, &actual_freq);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n} else {\r\nactual_freq = p->frequency;\r\n}\r\nsp887x_readreg(state, 0x200);\r\nsp887x_correct_offsets(state, p, actual_freq);\r\nif (p->bandwidth_hz == 6000000)\r\nval = 2;\r\nelse if (p->bandwidth_hz == 7000000)\r\nval = 1;\r\nelse\r\nval = 0;\r\nsp887x_writereg(state, 0x311, val);\r\nif (p->transmission_mode == TRANSMISSION_MODE_2K)\r\nsp887x_writereg(state, 0x338, 0x000);\r\nelse\r\nsp887x_writereg(state, 0x338, 0x001);\r\nsp887x_writereg(state, 0xc05, reg0xc05);\r\nif (p->bandwidth_hz == 6000000)\r\nval = 2 << 3;\r\nelse if (p->bandwidth_hz == 7000000)\r\nval = 3 << 3;\r\nelse\r\nval = 0 << 3;\r\nsp887x_writereg(state, 0xf14, 0x160 | val);\r\nsp887x_writereg(state, 0xf15, 0x000);\r\nsp887x_microcontroller_start(state);\r\nreturn 0;\r\n}\r\nstatic int sp887x_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nu16 snr12 = sp887x_readreg(state, 0xf16);\r\nu16 sync0x200 = sp887x_readreg(state, 0x200);\r\nu16 sync0xf17 = sp887x_readreg(state, 0xf17);\r\n*status = 0;\r\nif (snr12 > 0x00f)\r\n*status |= FE_HAS_SIGNAL;\r\nif ((sync0xf17 & 0x00f) == 0x002) {\r\n*status |= FE_HAS_LOCK;\r\n*status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_CARRIER;\r\n}\r\nif (sync0x200 & 0x001) {\r\nint steps = (sync0x200 >> 4) & 0x00f;\r\nif (steps & 0x008)\r\nsteps = -steps;\r\ndprintk("sp887x: implement tuner adjustment (%+i steps)!!\n",\r\nsteps);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sp887x_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\n*ber = (sp887x_readreg(state, 0xc08) & 0x3f) |\r\n(sp887x_readreg(state, 0xc07) << 6);\r\nsp887x_writereg(state, 0xc08, 0x000);\r\nsp887x_writereg(state, 0xc07, 0x000);\r\nif (*ber >= 0x3fff0)\r\n*ber = ~0;\r\nreturn 0;\r\n}\r\nstatic int sp887x_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nu16 snr12 = sp887x_readreg(state, 0xf16);\r\nu32 signal = 3 * (snr12 << 4);\r\n*strength = (signal < 0xffff) ? signal : 0xffff;\r\nreturn 0;\r\n}\r\nstatic int sp887x_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nu16 snr12 = sp887x_readreg(state, 0xf16);\r\n*snr = (snr12 << 4) | (snr12 >> 8);\r\nreturn 0;\r\n}\r\nstatic int sp887x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\n*ucblocks = sp887x_readreg(state, 0xc0c);\r\nif (*ucblocks == 0xfff)\r\n*ucblocks = ~0;\r\nreturn 0;\r\n}\r\nstatic int sp887x_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nreturn sp887x_writereg(state, 0x206, 0x001);\r\n} else {\r\nreturn sp887x_writereg(state, 0x206, 0x000);\r\n}\r\n}\r\nstatic int sp887x_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nsp887x_writereg(state, 0xc18, 0x000);\r\nreturn 0;\r\n}\r\nstatic int sp887x_init(struct dvb_frontend* fe)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nconst struct firmware *fw = NULL;\r\nint ret;\r\nif (!state->initialised) {\r\nprintk("sp887x: waiting for firmware upload (%s)...\n", SP887X_DEFAULT_FIRMWARE);\r\nret = state->config->request_firmware(fe, &fw, SP887X_DEFAULT_FIRMWARE);\r\nif (ret) {\r\nprintk("sp887x: no firmware upload (timeout or file not found?)\n");\r\nreturn ret;\r\n}\r\nret = sp887x_initial_setup(fe, fw);\r\nrelease_firmware(fw);\r\nif (ret) {\r\nprintk("sp887x: writing firmware to device failed\n");\r\nreturn ret;\r\n}\r\nprintk("sp887x: firmware upload complete\n");\r\nstate->initialised = 1;\r\n}\r\nsp887x_writereg(state, 0xc18, 0x00d);\r\nreturn 0;\r\n}\r\nstatic int sp887x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nfesettings->min_delay_ms = 350;\r\nfesettings->step_size = 166666*2;\r\nfesettings->max_drift = (166666*2)+1;\r\nreturn 0;\r\n}\r\nstatic void sp887x_release(struct dvb_frontend* fe)\r\n{\r\nstruct sp887x_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* sp887x_attach(const struct sp887x_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct sp887x_state* state = NULL;\r\nstate = kzalloc(sizeof(struct sp887x_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->initialised = 0;\r\nif (sp887x_readreg(state, 0x0200) < 0) goto error;\r\nmemcpy(&state->frontend.ops, &sp887x_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
