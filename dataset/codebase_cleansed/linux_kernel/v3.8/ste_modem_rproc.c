static int sproc_load_segments(struct rproc *rproc, const struct firmware *fw)\r\n{\r\nstruct sproc *sproc = rproc->priv;\r\nmemcpy(sproc->fw_addr, fw->data, fw->size);\r\nreturn 0;\r\n}\r\nstatic struct ste_toc_entry *sproc_find_rsc_entry(const struct firmware *fw)\r\n{\r\nint i;\r\nstruct ste_toc *toc;\r\nif (!fw)\r\nreturn NULL;\r\ntoc = (void *)fw->data;\r\nfor (i = 0; i < SPROC_MAX_TOC_ENTRIES &&\r\ntoc->table[i].start != 0xffffffff; i++) {\r\nif (!strncmp(toc->table[i].name, SPROC_RESOURCE_NAME,\r\nsizeof(toc->table[i].name))) {\r\nif (toc->table[i].start > fw->size)\r\nreturn NULL;\r\nreturn &toc->table[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct resource_table *\r\nsproc_find_rsc_table(struct rproc *rproc, const struct firmware *fw,\r\nint *tablesz)\r\n{\r\nstruct sproc *sproc = rproc->priv;\r\nstruct resource_table *table;\r\nstruct ste_toc_entry *entry;\r\nentry = sproc_find_rsc_entry(fw);\r\nif (!entry) {\r\nsproc_err(sproc, "resource table not found in fw\n");\r\nreturn NULL;\r\n}\r\ntable = (void *)(fw->data + entry->start);\r\nif (entry->start > SPROC_FW_SIZE ||\r\nentry->size > SPROC_FW_SIZE ||\r\nfw->size > SPROC_FW_SIZE ||\r\nentry->start + entry->size > fw->size ||\r\nsizeof(struct resource_table) > entry->size) {\r\nsproc_err(sproc, "bad size of fw or resource table\n");\r\nreturn NULL;\r\n}\r\nif (table->ver != 1) {\r\nsproc_err(sproc, "unsupported fw ver: %d\n", table->ver);\r\nreturn NULL;\r\n}\r\nif (table->reserved[0] || table->reserved[1]) {\r\nsproc_err(sproc, "non zero reserved bytes\n");\r\nreturn NULL;\r\n}\r\nif (table->num > SPROC_MAX_TOC_ENTRIES ||\r\ntable->num * sizeof(table->offset[0]) +\r\nsizeof(struct resource_table) > entry->size) {\r\nsproc_err(sproc, "resource table incomplete\n");\r\nreturn NULL;\r\n}\r\nif (SPROC_FW_SIZE < fw->size) {\r\nsproc_err(sproc, "Insufficient space for fw (%d < %zd)\n",\r\nSPROC_FW_SIZE, fw->size);\r\nreturn NULL;\r\n}\r\nsproc->fw_size = fw->size;\r\n*tablesz = entry->size;\r\nreturn table;\r\n}\r\nstatic void sproc_kick(struct rproc *rproc, int vqid)\r\n{\r\nstruct sproc *sproc = rproc->priv;\r\nsproc_dbg(sproc, "kick vqid:%d\n", vqid);\r\nsproc->mdev->ops.kick(sproc->mdev, vqid + SPROC_MAX_NOTIFY_ID);\r\n}\r\nstatic void sproc_kick_callback(struct ste_modem_device *mdev, int vqid)\r\n{\r\nstruct sproc *sproc = mdev->drv_data;\r\nif (rproc_vq_interrupt(sproc->rproc, vqid) == IRQ_NONE)\r\nsproc_dbg(sproc, "no message was found in vqid %d\n", vqid);\r\n}\r\nstatic int sproc_start(struct rproc *rproc)\r\n{\r\nstruct sproc *sproc = rproc->priv;\r\nint i, err;\r\nsproc_dbg(sproc, "start ste-modem\n");\r\nif (rproc->max_notifyid > SPROC_MAX_NOTIFY_ID) {\r\nsproc_err(sproc, "Notification IDs too high:%d\n",\r\nrproc->max_notifyid);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < rproc->max_notifyid; i++) {\r\nerr = sproc->mdev->ops.kick_subscribe(sproc->mdev, i);\r\nif (err) {\r\nsproc_err(sproc,\r\n"subscription of kicks failed:%d\n", err);\r\nreturn err;\r\n}\r\n}\r\nreturn sproc->mdev->ops.power(sproc->mdev, true);\r\n}\r\nstatic int sproc_stop(struct rproc *rproc)\r\n{\r\nstruct sproc *sproc = rproc->priv;\r\nsproc_dbg(sproc, "stop ste-modem\n");\r\nreturn sproc->mdev->ops.power(sproc->mdev, false);\r\n}\r\nstatic int sproc_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct ste_modem_device *mdev =\r\ncontainer_of(pdev, struct ste_modem_device, pdev);\r\nstruct sproc *sproc = mdev->drv_data;\r\nsproc_dbg(sproc, "remove ste-modem\n");\r\nsproc->mdev->ops.setup(sproc->mdev, NULL);\r\nrproc_del(sproc->rproc);\r\nrproc_put(sproc->rproc);\r\nmdev->drv_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int sproc_probe(struct platform_device *pdev)\r\n{\r\nstruct ste_modem_device *mdev =\r\ncontainer_of(pdev, struct ste_modem_device, pdev);\r\nstruct sproc *sproc;\r\nstruct rproc *rproc;\r\nint err;\r\ndev_dbg(&mdev->pdev.dev, "probe ste-modem\n");\r\nif (!mdev->ops.setup || !mdev->ops.kick || !mdev->ops.kick_subscribe ||\r\n!mdev->ops.power) {\r\ndev_err(&mdev->pdev.dev, "invalid mdev ops\n");\r\nreturn -EINVAL;\r\n}\r\nrproc = rproc_alloc(&mdev->pdev.dev, mdev->pdev.name, &sproc_ops,\r\nSPROC_MODEM_FIRMWARE, sizeof(*sproc));\r\nif (!rproc)\r\nreturn -ENOMEM;\r\nsproc = rproc->priv;\r\nsproc->mdev = mdev;\r\nsproc->rproc = rproc;\r\nmdev->drv_data = sproc;\r\nsproc->mdev->ops.setup(sproc->mdev, &sproc_dev_cb);\r\nrproc->fw_ops = &sproc_fw_ops;\r\nsproc->fw_addr = dma_alloc_coherent(rproc->dev.parent, SPROC_FW_SIZE,\r\n&sproc->fw_dma_addr,\r\nGFP_KERNEL);\r\nif (!sproc->fw_addr) {\r\nsproc_err(sproc, "Cannot allocate memory for fw\n");\r\nerr = -ENOMEM;\r\ngoto free_rproc;\r\n}\r\nerr = rproc_add(rproc);\r\nif (err)\r\ngoto free_rproc;\r\nreturn 0;\r\nfree_rproc:\r\nmdev->drv_data = NULL;\r\nrproc_put(rproc);\r\nreturn err;\r\n}
