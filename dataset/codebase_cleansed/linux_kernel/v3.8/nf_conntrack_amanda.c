static int amanda_help(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nstruct ts_state ts;\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple *tuple;\r\nunsigned int dataoff, start, stop, off, i;\r\nchar pbuf[sizeof("65535")], *tmp;\r\nu_int16_t len;\r\n__be16 port;\r\nint ret = NF_ACCEPT;\r\ntypeof(nf_nat_amanda_hook) nf_nat_amanda;\r\nif (CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL)\r\nreturn NF_ACCEPT;\r\nnf_ct_refresh(ct, skb, master_timeout * HZ);\r\ndataoff = protoff + sizeof(struct udphdr);\r\nif (dataoff >= skb->len) {\r\nnet_err_ratelimited("amanda_help: skblen = %u\n", skb->len);\r\nreturn NF_ACCEPT;\r\n}\r\nmemset(&ts, 0, sizeof(ts));\r\nstart = skb_find_text(skb, dataoff, skb->len,\r\nsearch[SEARCH_CONNECT].ts, &ts);\r\nif (start == UINT_MAX)\r\ngoto out;\r\nstart += dataoff + search[SEARCH_CONNECT].len;\r\nmemset(&ts, 0, sizeof(ts));\r\nstop = skb_find_text(skb, start, skb->len,\r\nsearch[SEARCH_NEWLINE].ts, &ts);\r\nif (stop == UINT_MAX)\r\ngoto out;\r\nstop += start;\r\nfor (i = SEARCH_DATA; i <= SEARCH_INDEX; i++) {\r\nmemset(&ts, 0, sizeof(ts));\r\noff = skb_find_text(skb, start, stop, search[i].ts, &ts);\r\nif (off == UINT_MAX)\r\ncontinue;\r\noff += start + search[i].len;\r\nlen = min_t(unsigned int, sizeof(pbuf) - 1, stop - off);\r\nif (skb_copy_bits(skb, off, pbuf, len))\r\nbreak;\r\npbuf[len] = '\0';\r\nport = htons(simple_strtoul(pbuf, &tmp, 10));\r\nlen = tmp - pbuf;\r\nif (port == 0 || len > 5)\r\nbreak;\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL) {\r\nret = NF_DROP;\r\ngoto out;\r\n}\r\ntuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT,\r\nnf_ct_l3num(ct),\r\n&tuple->src.u3, &tuple->dst.u3,\r\nIPPROTO_TCP, NULL, &port);\r\nnf_nat_amanda = rcu_dereference(nf_nat_amanda_hook);\r\nif (nf_nat_amanda && ct->status & IPS_NAT_MASK)\r\nret = nf_nat_amanda(skb, ctinfo, protoff,\r\noff - dataoff, len, exp);\r\nelse if (nf_ct_expect_related(exp) != 0)\r\nret = NF_DROP;\r\nnf_ct_expect_put(exp);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_amanda_fini(void)\r\n{\r\nint i;\r\nnf_conntrack_helper_unregister(&amanda_helper[0]);\r\nnf_conntrack_helper_unregister(&amanda_helper[1]);\r\nfor (i = 0; i < ARRAY_SIZE(search); i++)\r\ntextsearch_destroy(search[i].ts);\r\n}\r\nstatic int __init nf_conntrack_amanda_init(void)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < ARRAY_SIZE(search); i++) {\r\nsearch[i].ts = textsearch_prepare(ts_algo, search[i].string,\r\nsearch[i].len,\r\nGFP_KERNEL, TS_AUTOLOAD);\r\nif (IS_ERR(search[i].ts)) {\r\nret = PTR_ERR(search[i].ts);\r\ngoto err1;\r\n}\r\n}\r\nret = nf_conntrack_helper_register(&amanda_helper[0]);\r\nif (ret < 0)\r\ngoto err1;\r\nret = nf_conntrack_helper_register(&amanda_helper[1]);\r\nif (ret < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nnf_conntrack_helper_unregister(&amanda_helper[0]);\r\nerr1:\r\nwhile (--i >= 0)\r\ntextsearch_destroy(search[i].ts);\r\nreturn ret;\r\n}
