static void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,\r\nconst struct pxa3xx_nand_timing *t)\r\n{\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nunsigned long nand_clk = clk_get_rate(info->clk);\r\nuint32_t ndtr0, ndtr1;\r\nndtr0 = NDTR0_tCH(ns2cycle(t->tCH, nand_clk)) |\r\nNDTR0_tCS(ns2cycle(t->tCS, nand_clk)) |\r\nNDTR0_tWH(ns2cycle(t->tWH, nand_clk)) |\r\nNDTR0_tWP(ns2cycle(t->tWP, nand_clk)) |\r\nNDTR0_tRH(ns2cycle(t->tRH, nand_clk)) |\r\nNDTR0_tRP(ns2cycle(t->tRP, nand_clk));\r\nndtr1 = NDTR1_tR(ns2cycle(t->tR, nand_clk)) |\r\nNDTR1_tWHR(ns2cycle(t->tWHR, nand_clk)) |\r\nNDTR1_tAR(ns2cycle(t->tAR, nand_clk));\r\nhost->ndtr0cs0 = ndtr0;\r\nhost->ndtr1cs0 = ndtr1;\r\nnand_writel(info, NDTR0CS0, ndtr0);\r\nnand_writel(info, NDTR1CS0, ndtr1);\r\n}\r\nstatic void pxa3xx_set_datasize(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nint oob_enable = host->reg_ndcr & NDCR_SPARE_EN;\r\ninfo->data_size = host->page_size;\r\nif (!oob_enable) {\r\ninfo->oob_size = 0;\r\nreturn;\r\n}\r\nswitch (host->page_size) {\r\ncase 2048:\r\ninfo->oob_size = (info->use_ecc) ? 40 : 64;\r\nbreak;\r\ncase 512:\r\ninfo->oob_size = (info->use_ecc) ? 8 : 16;\r\nbreak;\r\n}\r\n}\r\nstatic void pxa3xx_nand_start(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nuint32_t ndcr;\r\nndcr = host->reg_ndcr;\r\nndcr |= info->use_ecc ? NDCR_ECC_EN : 0;\r\nndcr |= info->use_dma ? NDCR_DMA_EN : 0;\r\nndcr |= NDCR_ND_RUN;\r\nnand_writel(info, NDCR, 0);\r\nnand_writel(info, NDSR, NDSR_MASK);\r\nnand_writel(info, NDCR, ndcr);\r\n}\r\nstatic void pxa3xx_nand_stop(struct pxa3xx_nand_info *info)\r\n{\r\nuint32_t ndcr;\r\nint timeout = NAND_STOP_DELAY;\r\nndcr = nand_readl(info, NDCR);\r\nwhile ((ndcr & NDCR_ND_RUN) && (timeout-- > 0)) {\r\nndcr = nand_readl(info, NDCR);\r\nudelay(1);\r\n}\r\nif (timeout <= 0) {\r\nndcr &= ~NDCR_ND_RUN;\r\nnand_writel(info, NDCR, ndcr);\r\n}\r\nnand_writel(info, NDSR, NDSR_MASK);\r\n}\r\nstatic void enable_int(struct pxa3xx_nand_info *info, uint32_t int_mask)\r\n{\r\nuint32_t ndcr;\r\nndcr = nand_readl(info, NDCR);\r\nnand_writel(info, NDCR, ndcr & ~int_mask);\r\n}\r\nstatic void disable_int(struct pxa3xx_nand_info *info, uint32_t int_mask)\r\n{\r\nuint32_t ndcr;\r\nndcr = nand_readl(info, NDCR);\r\nnand_writel(info, NDCR, ndcr | int_mask);\r\n}\r\nstatic void handle_data_pio(struct pxa3xx_nand_info *info)\r\n{\r\nswitch (info->state) {\r\ncase STATE_PIO_WRITING:\r\n__raw_writesl(info->mmio_base + NDDB, info->data_buff,\r\nDIV_ROUND_UP(info->data_size, 4));\r\nif (info->oob_size > 0)\r\n__raw_writesl(info->mmio_base + NDDB, info->oob_buff,\r\nDIV_ROUND_UP(info->oob_size, 4));\r\nbreak;\r\ncase STATE_PIO_READING:\r\n__raw_readsl(info->mmio_base + NDDB, info->data_buff,\r\nDIV_ROUND_UP(info->data_size, 4));\r\nif (info->oob_size > 0)\r\n__raw_readsl(info->mmio_base + NDDB, info->oob_buff,\r\nDIV_ROUND_UP(info->oob_size, 4));\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,\r\ninfo->state);\r\nBUG();\r\n}\r\n}\r\nstatic void start_data_dma(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa_dma_desc *desc = info->data_desc;\r\nint dma_len = ALIGN(info->data_size + info->oob_size, 32);\r\ndesc->ddadr = DDADR_STOP;\r\ndesc->dcmd = DCMD_ENDIRQEN | DCMD_WIDTH4 | DCMD_BURST32 | dma_len;\r\nswitch (info->state) {\r\ncase STATE_DMA_WRITING:\r\ndesc->dsadr = info->data_buff_phys;\r\ndesc->dtadr = info->mmio_phys + NDDB;\r\ndesc->dcmd |= DCMD_INCSRCADDR | DCMD_FLOWTRG;\r\nbreak;\r\ncase STATE_DMA_READING:\r\ndesc->dtadr = info->data_buff_phys;\r\ndesc->dsadr = info->mmio_phys + NDDB;\r\ndesc->dcmd |= DCMD_INCTRGADDR | DCMD_FLOWSRC;\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,\r\ninfo->state);\r\nBUG();\r\n}\r\nDRCMR(info->drcmr_dat) = DRCMR_MAPVLD | info->data_dma_ch;\r\nDDADR(info->data_dma_ch) = info->data_desc_addr;\r\nDCSR(info->data_dma_ch) |= DCSR_RUN;\r\n}\r\nstatic void pxa3xx_nand_data_dma_irq(int channel, void *data)\r\n{\r\nstruct pxa3xx_nand_info *info = data;\r\nuint32_t dcsr;\r\ndcsr = DCSR(channel);\r\nDCSR(channel) = dcsr;\r\nif (dcsr & DCSR_BUSERR) {\r\ninfo->retcode = ERR_DMABUSERR;\r\n}\r\ninfo->state = STATE_DMA_DONE;\r\nenable_int(info, NDCR_INT_MASK);\r\nnand_writel(info, NDSR, NDSR_WRDREQ | NDSR_RDDREQ);\r\n}\r\nstatic irqreturn_t pxa3xx_nand_irq(int irq, void *devid)\r\n{\r\nstruct pxa3xx_nand_info *info = devid;\r\nunsigned int status, is_completed = 0;\r\nunsigned int ready, cmd_done;\r\nif (info->cs == 0) {\r\nready = NDSR_FLASH_RDY;\r\ncmd_done = NDSR_CS0_CMDD;\r\n} else {\r\nready = NDSR_RDY;\r\ncmd_done = NDSR_CS1_CMDD;\r\n}\r\nstatus = nand_readl(info, NDSR);\r\nif (status & NDSR_DBERR)\r\ninfo->retcode = ERR_DBERR;\r\nif (status & NDSR_SBERR)\r\ninfo->retcode = ERR_SBERR;\r\nif (status & (NDSR_RDDREQ | NDSR_WRDREQ)) {\r\nif (info->use_dma) {\r\ndisable_int(info, NDCR_INT_MASK);\r\ninfo->state = (status & NDSR_RDDREQ) ?\r\nSTATE_DMA_READING : STATE_DMA_WRITING;\r\nstart_data_dma(info);\r\ngoto NORMAL_IRQ_EXIT;\r\n} else {\r\ninfo->state = (status & NDSR_RDDREQ) ?\r\nSTATE_PIO_READING : STATE_PIO_WRITING;\r\nhandle_data_pio(info);\r\n}\r\n}\r\nif (status & cmd_done) {\r\ninfo->state = STATE_CMD_DONE;\r\nis_completed = 1;\r\n}\r\nif (status & ready) {\r\ninfo->is_ready = 1;\r\ninfo->state = STATE_READY;\r\n}\r\nif (status & NDSR_WRCMDREQ) {\r\nnand_writel(info, NDSR, NDSR_WRCMDREQ);\r\nstatus &= ~NDSR_WRCMDREQ;\r\ninfo->state = STATE_CMD_HANDLE;\r\nnand_writel(info, NDCB0, info->ndcb0);\r\nnand_writel(info, NDCB0, info->ndcb1);\r\nnand_writel(info, NDCB0, info->ndcb2);\r\n}\r\nnand_writel(info, NDSR, status);\r\nif (is_completed)\r\ncomplete(&info->cmd_complete);\r\nNORMAL_IRQ_EXIT:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int is_buf_blank(uint8_t *buf, size_t len)\r\n{\r\nfor (; len > 0; len--)\r\nif (*buf++ != 0xff)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int prepare_command_pool(struct pxa3xx_nand_info *info, int command,\r\nuint16_t column, int page_addr)\r\n{\r\nuint16_t cmd;\r\nint addr_cycle, exec_cmd;\r\nstruct pxa3xx_nand_host *host;\r\nstruct mtd_info *mtd;\r\nhost = info->host[info->cs];\r\nmtd = host->mtd;\r\naddr_cycle = 0;\r\nexec_cmd = 1;\r\ninfo->buf_start = 0;\r\ninfo->buf_count = 0;\r\ninfo->oob_size = 0;\r\ninfo->use_ecc = 0;\r\ninfo->is_ready = 0;\r\ninfo->retcode = ERR_NONE;\r\nif (info->cs != 0)\r\ninfo->ndcb0 = NDCB0_CSEL;\r\nelse\r\ninfo->ndcb0 = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_PAGEPROG:\r\ninfo->use_ecc = 1;\r\ncase NAND_CMD_READOOB:\r\npxa3xx_set_datasize(info);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nexec_cmd = 0;\r\nbreak;\r\ndefault:\r\ninfo->ndcb1 = 0;\r\ninfo->ndcb2 = 0;\r\nbreak;\r\n}\r\naddr_cycle = NDCB0_ADDR_CYC(host->row_addr_cycles\r\n+ host->col_addr_cycles);\r\nswitch (command) {\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_READ0:\r\ncmd = host->cmdset->read1;\r\nif (command == NAND_CMD_READOOB)\r\ninfo->buf_start = mtd->writesize + column;\r\nelse\r\ninfo->buf_start = column;\r\nif (unlikely(host->page_size < PAGE_CHUNK_SIZE))\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0)\r\n| addr_cycle\r\n| (cmd & NDCB0_CMD1_MASK);\r\nelse\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0)\r\n| NDCB0_DBC\r\n| addr_cycle\r\n| cmd;\r\ncase NAND_CMD_SEQIN:\r\nif (unlikely(host->page_size < PAGE_CHUNK_SIZE)) {\r\ninfo->ndcb1 = ((page_addr & 0xFFFFFF) << 8)\r\n| (column & 0xFF);\r\ninfo->ndcb2 = 0;\r\n} else {\r\ninfo->ndcb1 = ((page_addr & 0xFFFF) << 16)\r\n| (column & 0xFFFF);\r\nif (page_addr & 0xFF0000)\r\ninfo->ndcb2 = (page_addr & 0xFF0000) >> 16;\r\nelse\r\ninfo->ndcb2 = 0;\r\n}\r\ninfo->buf_count = mtd->writesize + mtd->oobsize;\r\nmemset(info->data_buff, 0xFF, info->buf_count);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nif (is_buf_blank(info->data_buff,\r\n(mtd->writesize + mtd->oobsize))) {\r\nexec_cmd = 0;\r\nbreak;\r\n}\r\ncmd = host->cmdset->program;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_AUTO_RS\r\n| NDCB0_ST_ROW_EN\r\n| NDCB0_DBC\r\n| cmd\r\n| addr_cycle;\r\nbreak;\r\ncase NAND_CMD_READID:\r\ncmd = host->cmdset->read_id;\r\ninfo->buf_count = host->read_id_bytes;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(3)\r\n| NDCB0_ADDR_CYC(1)\r\n| cmd;\r\ninfo->data_size = 8;\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\ncmd = host->cmdset->read_status;\r\ninfo->buf_count = 1;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(4)\r\n| NDCB0_ADDR_CYC(1)\r\n| cmd;\r\ninfo->data_size = 8;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\ncmd = host->cmdset->erase;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(2)\r\n| NDCB0_AUTO_RS\r\n| NDCB0_ADDR_CYC(3)\r\n| NDCB0_DBC\r\n| cmd;\r\ninfo->ndcb1 = page_addr;\r\ninfo->ndcb2 = 0;\r\nbreak;\r\ncase NAND_CMD_RESET:\r\ncmd = host->cmdset->reset;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(5)\r\n| cmd;\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nexec_cmd = 0;\r\nbreak;\r\ndefault:\r\nexec_cmd = 0;\r\ndev_err(&info->pdev->dev, "non-supported command %x\n",\r\ncommand);\r\nbreak;\r\n}\r\nreturn exec_cmd;\r\n}\r\nstatic void pxa3xx_nand_cmdfunc(struct mtd_info *mtd, unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint ret, exec_cmd;\r\nif (host->reg_ndcr & NDCR_DWIDTH_M)\r\ncolumn /= 2;\r\nif (info->cs != host->cs) {\r\ninfo->cs = host->cs;\r\nnand_writel(info, NDTR0CS0, host->ndtr0cs0);\r\nnand_writel(info, NDTR1CS0, host->ndtr1cs0);\r\n}\r\ninfo->state = STATE_PREPARED;\r\nexec_cmd = prepare_command_pool(info, command, column, page_addr);\r\nif (exec_cmd) {\r\ninit_completion(&info->cmd_complete);\r\npxa3xx_nand_start(info);\r\nret = wait_for_completion_timeout(&info->cmd_complete,\r\nCHIP_DELAY_TIMEOUT);\r\nif (!ret) {\r\ndev_err(&info->pdev->dev, "Wait time out!!!\n");\r\npxa3xx_nand_stop(info);\r\n}\r\n}\r\ninfo->state = STATE_IDLE;\r\n}\r\nstatic int pxa3xx_nand_write_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_read_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (info->retcode == ERR_SBERR) {\r\nswitch (info->use_ecc) {\r\ncase 1:\r\nmtd->ecc_stats.corrected++;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\n} else if (info->retcode == ERR_DBERR) {\r\nif (is_buf_blank(buf, mtd->writesize))\r\ninfo->retcode = ERR_NONE;\r\nelse\r\nmtd->ecc_stats.failed++;\r\n}\r\nreturn 0;\r\n}\r\nstatic uint8_t pxa3xx_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nchar retval = 0xFF;\r\nif (info->buf_start < info->buf_count)\r\nretval = info->data_buff[info->buf_start++];\r\nreturn retval;\r\n}\r\nstatic u16 pxa3xx_nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nu16 retval = 0xFFFF;\r\nif (!(info->buf_start & 0x01) && info->buf_start < info->buf_count) {\r\nretval = *((u16 *)(info->data_buff+info->buf_start));\r\ninfo->buf_start += 2;\r\n}\r\nreturn retval;\r\n}\r\nstatic void pxa3xx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint real_len = min_t(size_t, len, info->buf_count - info->buf_start);\r\nmemcpy(buf, info->data_buff + info->buf_start, real_len);\r\ninfo->buf_start += real_len;\r\n}\r\nstatic void pxa3xx_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint real_len = min_t(size_t, len, info->buf_count - info->buf_start);\r\nmemcpy(info->data_buff + info->buf_start, buf, real_len);\r\ninfo->buf_start += real_len;\r\n}\r\nstatic void pxa3xx_nand_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nreturn;\r\n}\r\nstatic int pxa3xx_nand_waitfunc(struct mtd_info *mtd, struct nand_chip *this)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nif (this->state == FL_WRITING || this->state == FL_ERASING) {\r\nif (info->retcode == ERR_NONE)\r\nreturn 0;\r\nelse {\r\nreturn 0x01;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_config_flash(struct pxa3xx_nand_info *info,\r\nconst struct pxa3xx_nand_flash *f)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = pdev->dev.platform_data;\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nuint32_t ndcr = 0x0;\r\nif (f->page_size != 2048 && f->page_size != 512) {\r\ndev_err(&pdev->dev, "Current only support 2048 and 512 size\n");\r\nreturn -EINVAL;\r\n}\r\nif (f->flash_width != 16 && f->flash_width != 8) {\r\ndev_err(&pdev->dev, "Only support 8bit and 16 bit!\n");\r\nreturn -EINVAL;\r\n}\r\nhost->cmdset = &default_cmdset;\r\nhost->page_size = f->page_size;\r\nhost->read_id_bytes = (f->page_size == 2048) ? 4 : 2;\r\nhost->col_addr_cycles = (f->page_size == 2048) ? 2 : 1;\r\nif (f->num_blocks * f->page_per_block > 65536)\r\nhost->row_addr_cycles = 3;\r\nelse\r\nhost->row_addr_cycles = 2;\r\nndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;\r\nndcr |= (host->col_addr_cycles == 2) ? NDCR_RA_START : 0;\r\nndcr |= (f->page_per_block == 64) ? NDCR_PG_PER_BLK : 0;\r\nndcr |= (f->page_size == 2048) ? NDCR_PAGE_SZ : 0;\r\nndcr |= (f->flash_width == 16) ? NDCR_DWIDTH_M : 0;\r\nndcr |= (f->dfc_width == 16) ? NDCR_DWIDTH_C : 0;\r\nndcr |= NDCR_RD_ID_CNT(host->read_id_bytes);\r\nndcr |= NDCR_SPARE_EN;\r\nhost->reg_ndcr = ndcr;\r\npxa3xx_nand_set_timing(host, f->timing);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_detect_config(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[0];\r\nuint32_t ndcr = nand_readl(info, NDCR);\r\nif (ndcr & NDCR_PAGE_SZ) {\r\nhost->page_size = 2048;\r\nhost->read_id_bytes = 4;\r\n} else {\r\nhost->page_size = 512;\r\nhost->read_id_bytes = 2;\r\n}\r\nhost->reg_ndcr = ndcr & ~NDCR_INT_MASK;\r\nhost->cmdset = &default_cmdset;\r\nhost->ndtr0cs0 = nand_readl(info, NDTR0CS0);\r\nhost->ndtr1cs0 = nand_readl(info, NDTR1CS0);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_init_buff(struct pxa3xx_nand_info *info)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nint data_desc_offset = MAX_BUFF_SIZE - sizeof(struct pxa_dma_desc);\r\nif (use_dma == 0) {\r\ninfo->data_buff = kmalloc(MAX_BUFF_SIZE, GFP_KERNEL);\r\nif (info->data_buff == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\ninfo->data_buff = dma_alloc_coherent(&pdev->dev, MAX_BUFF_SIZE,\r\n&info->data_buff_phys, GFP_KERNEL);\r\nif (info->data_buff == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate dma buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->data_desc = (void *)info->data_buff + data_desc_offset;\r\ninfo->data_desc_addr = info->data_buff_phys + data_desc_offset;\r\ninfo->data_dma_ch = pxa_request_dma("nand-data", DMA_PRIO_LOW,\r\npxa3xx_nand_data_dma_irq, info);\r\nif (info->data_dma_ch < 0) {\r\ndev_err(&pdev->dev, "failed to request data dma\n");\r\ndma_free_coherent(&pdev->dev, MAX_BUFF_SIZE,\r\ninfo->data_buff, info->data_buff_phys);\r\nreturn info->data_dma_ch;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_sensing(struct pxa3xx_nand_info *info)\r\n{\r\nstruct mtd_info *mtd;\r\nint ret;\r\nmtd = info->host[info->cs]->mtd;\r\nret = pxa3xx_nand_config_flash(info, &builtin_flash_types[0]);\r\nif (ret)\r\nreturn ret;\r\npxa3xx_nand_cmdfunc(mtd, NAND_CMD_RESET, 0, 0);\r\nif (info->is_ready)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int pxa3xx_nand_scan(struct mtd_info *mtd)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = pdev->dev.platform_data;\r\nstruct nand_flash_dev pxa3xx_flash_ids[2], *def = NULL;\r\nconst struct pxa3xx_nand_flash *f = NULL;\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t id = -1;\r\nuint64_t chipsize;\r\nint i, ret, num;\r\nif (pdata->keep_config && !pxa3xx_nand_detect_config(info))\r\ngoto KEEP_CONFIG;\r\nret = pxa3xx_nand_sensing(info);\r\nif (ret) {\r\ndev_info(&info->pdev->dev, "There is no chip on cs %d!\n",\r\ninfo->cs);\r\nreturn ret;\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0, 0);\r\nid = *((uint16_t *)(info->data_buff));\r\nif (id != 0)\r\ndev_info(&info->pdev->dev, "Detect a flash id %x\n", id);\r\nelse {\r\ndev_warn(&info->pdev->dev,\r\n"Read out ID 0, potential timing set wrong!!\n");\r\nreturn -EINVAL;\r\n}\r\nnum = ARRAY_SIZE(builtin_flash_types) + pdata->num_flash - 1;\r\nfor (i = 0; i < num; i++) {\r\nif (i < pdata->num_flash)\r\nf = pdata->flash + i;\r\nelse\r\nf = &builtin_flash_types[i - pdata->num_flash + 1];\r\nif (f->chip_id == id)\r\nbreak;\r\n}\r\nif (i >= (ARRAY_SIZE(builtin_flash_types) + pdata->num_flash - 1)) {\r\ndev_err(&info->pdev->dev, "ERROR!! flash not defined!!!\n");\r\nreturn -EINVAL;\r\n}\r\nret = pxa3xx_nand_config_flash(info, f);\r\nif (ret) {\r\ndev_err(&info->pdev->dev, "ERROR! Configure failed\n");\r\nreturn ret;\r\n}\r\npxa3xx_flash_ids[0].name = f->name;\r\npxa3xx_flash_ids[0].id = (f->chip_id >> 8) & 0xffff;\r\npxa3xx_flash_ids[0].pagesize = f->page_size;\r\nchipsize = (uint64_t)f->num_blocks * f->page_per_block * f->page_size;\r\npxa3xx_flash_ids[0].chipsize = chipsize >> 20;\r\npxa3xx_flash_ids[0].erasesize = f->page_size * f->page_per_block;\r\nif (f->flash_width == 16)\r\npxa3xx_flash_ids[0].options = NAND_BUSWIDTH_16;\r\npxa3xx_flash_ids[1].name = NULL;\r\ndef = pxa3xx_flash_ids;\r\nKEEP_CONFIG:\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.size = host->page_size;\r\nchip->ecc.strength = 1;\r\nif (host->reg_ndcr & NDCR_DWIDTH_M)\r\nchip->options |= NAND_BUSWIDTH_16;\r\nif (nand_scan_ident(mtd, 1, def))\r\nreturn -ENODEV;\r\nif (mtd->writesize >= 2048)\r\nhost->col_addr_cycles = 2;\r\nelse\r\nhost->col_addr_cycles = 1;\r\ninfo->oob_buff = info->data_buff + mtd->writesize;\r\nif ((mtd->size >> chip->page_shift) > 65536)\r\nhost->row_addr_cycles = 3;\r\nelse\r\nhost->row_addr_cycles = 2;\r\nmtd->name = mtd_names[0];\r\nreturn nand_scan_tail(mtd);\r\n}\r\nstatic int alloc_nand_resource(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct pxa3xx_nand_info *info;\r\nstruct pxa3xx_nand_host *host;\r\nstruct nand_chip *chip = NULL;\r\nstruct mtd_info *mtd;\r\nstruct resource *r;\r\nint ret, irq, cs;\r\npdata = pdev->dev.platform_data;\r\ninfo = kzalloc(sizeof(*info) + (sizeof(*mtd) +\r\nsizeof(*host)) * pdata->num_cs, GFP_KERNEL);\r\nif (!info) {\r\ndev_err(&pdev->dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->pdev = pdev;\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nmtd = (struct mtd_info *)((unsigned int)&info[1] +\r\n(sizeof(*mtd) + sizeof(*host)) * cs);\r\nchip = (struct nand_chip *)(&mtd[1]);\r\nhost = (struct pxa3xx_nand_host *)chip;\r\ninfo->host[cs] = host;\r\nhost->mtd = mtd;\r\nhost->cs = cs;\r\nhost->info_data = info;\r\nmtd->priv = host;\r\nmtd->owner = THIS_MODULE;\r\nchip->ecc.read_page = pxa3xx_nand_read_page_hwecc;\r\nchip->ecc.write_page = pxa3xx_nand_write_page_hwecc;\r\nchip->controller = &info->controller;\r\nchip->waitfunc = pxa3xx_nand_waitfunc;\r\nchip->select_chip = pxa3xx_nand_select_chip;\r\nchip->cmdfunc = pxa3xx_nand_cmdfunc;\r\nchip->read_word = pxa3xx_nand_read_word;\r\nchip->read_byte = pxa3xx_nand_read_byte;\r\nchip->read_buf = pxa3xx_nand_read_buf;\r\nchip->write_buf = pxa3xx_nand_write_buf;\r\n}\r\nspin_lock_init(&chip->controller->lock);\r\ninit_waitqueue_head(&chip->controller->wq);\r\ninfo->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed to get nand clock\n");\r\nret = PTR_ERR(info->clk);\r\ngoto fail_free_mtd;\r\n}\r\nclk_enable(info->clk);\r\nif (pdev->dev.of_node && cpu_is_pxa3xx()) {\r\ninfo->drcmr_dat = 97;\r\ninfo->drcmr_cmd = 99;\r\n} else {\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no resource defined for data DMA\n");\r\nret = -ENXIO;\r\ngoto fail_put_clk;\r\n}\r\ninfo->drcmr_dat = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no resource defined for command DMA\n");\r\nret = -ENXIO;\r\ngoto fail_put_clk;\r\n}\r\ninfo->drcmr_cmd = r->start;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ resource defined\n");\r\nret = -ENXIO;\r\ngoto fail_put_clk;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no IO memory resource defined\n");\r\nret = -ENODEV;\r\ngoto fail_put_clk;\r\n}\r\nr = request_mem_region(r->start, resource_size(r), pdev->name);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "failed to request memory resource\n");\r\nret = -EBUSY;\r\ngoto fail_put_clk;\r\n}\r\ninfo->mmio_base = ioremap(r->start, resource_size(r));\r\nif (info->mmio_base == NULL) {\r\ndev_err(&pdev->dev, "ioremap() failed\n");\r\nret = -ENODEV;\r\ngoto fail_free_res;\r\n}\r\ninfo->mmio_phys = r->start;\r\nret = pxa3xx_nand_init_buff(info);\r\nif (ret)\r\ngoto fail_free_io;\r\ndisable_int(info, NDSR_MASK);\r\nret = request_irq(irq, pxa3xx_nand_irq, IRQF_DISABLED,\r\npdev->name, info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\ngoto fail_free_buf;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nreturn 0;\r\nfail_free_buf:\r\nfree_irq(irq, info);\r\nif (use_dma) {\r\npxa_free_dma(info->data_dma_ch);\r\ndma_free_coherent(&pdev->dev, MAX_BUFF_SIZE,\r\ninfo->data_buff, info->data_buff_phys);\r\n} else\r\nkfree(info->data_buff);\r\nfail_free_io:\r\niounmap(info->mmio_base);\r\nfail_free_res:\r\nrelease_mem_region(r->start, resource_size(r));\r\nfail_put_clk:\r\nclk_disable(info->clk);\r\nclk_put(info->clk);\r\nfail_free_mtd:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int pxa3xx_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct resource *r;\r\nint irq, cs;\r\nif (!info)\r\nreturn 0;\r\npdata = pdev->dev.platform_data;\r\nplatform_set_drvdata(pdev, NULL);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq >= 0)\r\nfree_irq(irq, info);\r\nif (use_dma) {\r\npxa_free_dma(info->data_dma_ch);\r\ndma_free_writecombine(&pdev->dev, MAX_BUFF_SIZE,\r\ninfo->data_buff, info->data_buff_phys);\r\n} else\r\nkfree(info->data_buff);\r\niounmap(info->mmio_base);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(r->start, resource_size(r));\r\nclk_disable(info->clk);\r\nclk_put(info->clk);\r\nfor (cs = 0; cs < pdata->num_cs; cs++)\r\nnand_release(info->host[cs]->mtd);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_probe_dt(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa3xx_nand_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (of_get_property(np, "marvell,nand-enable-arbiter", NULL))\r\npdata->enable_arbiter = 1;\r\nif (of_get_property(np, "marvell,nand-keep-config", NULL))\r\npdata->keep_config = 1;\r\nof_property_read_u32(np, "num-cs", &pdata->num_cs);\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic inline int pxa3xx_nand_probe_dt(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct mtd_part_parser_data ppdata = {};\r\nstruct pxa3xx_nand_info *info;\r\nint ret, cs, probe_success;\r\nret = pxa3xx_nand_probe_dt(pdev);\r\nif (ret)\r\nreturn ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -ENODEV;\r\n}\r\nret = alloc_nand_resource(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "alloc nand resource failed\n");\r\nreturn ret;\r\n}\r\ninfo = platform_get_drvdata(pdev);\r\nprobe_success = 0;\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\ninfo->cs = cs;\r\nret = pxa3xx_nand_scan(info->host[cs]->mtd);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "failed to scan nand at cs %d\n",\r\ncs);\r\ncontinue;\r\n}\r\nppdata.of_node = pdev->dev.of_node;\r\nret = mtd_device_parse_register(info->host[cs]->mtd, NULL,\r\n&ppdata, pdata->parts[cs],\r\npdata->nr_parts[cs]);\r\nif (!ret)\r\nprobe_success = 1;\r\n}\r\nif (!probe_success) {\r\npxa3xx_nand_remove(pdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct mtd_info *mtd;\r\nint cs;\r\npdata = pdev->dev.platform_data;\r\nif (info->state) {\r\ndev_err(&pdev->dev, "driver busy, state = %d\n", info->state);\r\nreturn -EAGAIN;\r\n}\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nmtd = info->host[cs]->mtd;\r\nmtd_suspend(mtd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_resume(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct mtd_info *mtd;\r\nint cs;\r\npdata = pdev->dev.platform_data;\r\ndisable_int(info, NDCR_INT_MASK);\r\ninfo->cs = 0xff;\r\nnand_writel(info, NDSR, NDSR_MASK);\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nmtd = info->host[cs]->mtd;\r\nmtd_resume(mtd);\r\n}\r\nreturn 0;\r\n}
