struct usb_request *alloc_ep_req(struct usb_ep *ep, int len)\r\n{\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (req) {\r\nif (len)\r\nreq->length = len;\r\nelse\r\nreq->length = buflen;\r\nreq->buf = kmalloc(req->length, GFP_ATOMIC);\r\nif (!req->buf) {\r\nusb_ep_free_request(ep, req);\r\nreq = NULL;\r\n}\r\n}\r\nreturn req;\r\n}\r\nvoid free_ep_req(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic void disable_ep(struct usb_composite_dev *cdev, struct usb_ep *ep)\r\n{\r\nint value;\r\nif (ep->driver_data) {\r\nvalue = usb_ep_disable(ep);\r\nif (value < 0)\r\nDBG(cdev, "disable %s --> %d\n",\r\nep->name, value);\r\nep->driver_data = NULL;\r\n}\r\n}\r\nvoid disable_endpoints(struct usb_composite_dev *cdev,\r\nstruct usb_ep *in, struct usb_ep *out,\r\nstruct usb_ep *iso_in, struct usb_ep *iso_out)\r\n{\r\ndisable_ep(cdev, in);\r\ndisable_ep(cdev, out);\r\nif (iso_in)\r\ndisable_ep(cdev, iso_in);\r\nif (iso_out)\r\ndisable_ep(cdev, iso_out);\r\n}\r\nstatic void zero_autoresume(unsigned long _c)\r\n{\r\nstruct usb_composite_dev *cdev = (void *)_c;\r\nstruct usb_gadget *g = cdev->gadget;\r\nif (!cdev->config)\r\nreturn;\r\nif (g->speed != USB_SPEED_UNKNOWN) {\r\nint status = usb_gadget_wakeup(g);\r\nINFO(cdev, "%s --> %d\n", __func__, status);\r\n}\r\n}\r\nstatic void zero_suspend(struct usb_composite_dev *cdev)\r\n{\r\nif (cdev->gadget->speed == USB_SPEED_UNKNOWN)\r\nreturn;\r\nif (autoresume) {\r\nmod_timer(&autoresume_timer, jiffies + (HZ * autoresume));\r\nDBG(cdev, "suspend, wakeup in %d seconds\n", autoresume);\r\n} else\r\nDBG(cdev, "%s\n", __func__);\r\n}\r\nstatic void zero_resume(struct usb_composite_dev *cdev)\r\n{\r\nDBG(cdev, "%s\n", __func__);\r\ndel_timer(&autoresume_timer);\r\n}\r\nstatic int __init zero_bind(struct usb_composite_dev *cdev)\r\n{\r\nint status;\r\nstatus = usb_string_ids_tab(cdev, strings_dev);\r\nif (status < 0)\r\nreturn status;\r\ndevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\r\ndevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\r\ndevice_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;\r\nsetup_timer(&autoresume_timer, zero_autoresume, (unsigned long) cdev);\r\nif (loopdefault) {\r\nloopback_add(cdev, autoresume != 0);\r\nsourcesink_add(cdev, autoresume != 0);\r\n} else {\r\nsourcesink_add(cdev, autoresume != 0);\r\nloopback_add(cdev, autoresume != 0);\r\n}\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nINFO(cdev, "%s, version: " DRIVER_VERSION "\n", longname);\r\nreturn 0;\r\n}\r\nstatic int zero_unbind(struct usb_composite_dev *cdev)\r\n{\r\ndel_timer_sync(&autoresume_timer);\r\nreturn 0;\r\n}\r\nstatic int __init init(void)\r\n{\r\nreturn usb_composite_probe(&zero_driver);\r\n}\r\nstatic void __exit cleanup(void)\r\n{\r\nusb_composite_unregister(&zero_driver);\r\n}
