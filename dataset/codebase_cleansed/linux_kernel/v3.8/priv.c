static int handle_set_prefix(struct kvm_vcpu *vcpu)\r\n{\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16);\r\nu64 operand2;\r\nu32 address = 0;\r\nu8 tmp;\r\nvcpu->stat.instruction_spx++;\r\noperand2 = disp2;\r\nif (base2)\r\noperand2 += vcpu->run->s.regs.gprs[base2];\r\nif (operand2 & 3) {\r\nkvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\ngoto out;\r\n}\r\nif (get_guest_u32(vcpu, operand2, &address)) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\ngoto out;\r\n}\r\naddress = address & 0x7fffe000u;\r\nif (copy_from_guest_absolute(vcpu, &tmp, address, 1) ||\r\n(copy_from_guest_absolute(vcpu, &tmp, address + PAGE_SIZE, 1))) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\ngoto out;\r\n}\r\nkvm_s390_set_prefix(vcpu, address);\r\nVCPU_EVENT(vcpu, 5, "setting prefix to %x", address);\r\ntrace_kvm_s390_handle_prefix(vcpu, 1, address);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int handle_store_prefix(struct kvm_vcpu *vcpu)\r\n{\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16);\r\nu64 operand2;\r\nu32 address;\r\nvcpu->stat.instruction_stpx++;\r\noperand2 = disp2;\r\nif (base2)\r\noperand2 += vcpu->run->s.regs.gprs[base2];\r\nif (operand2 & 3) {\r\nkvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\ngoto out;\r\n}\r\naddress = vcpu->arch.sie_block->prefix;\r\naddress = address & 0x7fffe000u;\r\nif (put_guest_u32(vcpu, operand2, address)) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\ngoto out;\r\n}\r\nVCPU_EVENT(vcpu, 5, "storing prefix to %x", address);\r\ntrace_kvm_s390_handle_prefix(vcpu, 0, address);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int handle_store_cpu_address(struct kvm_vcpu *vcpu)\r\n{\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16);\r\nu64 useraddr;\r\nint rc;\r\nvcpu->stat.instruction_stap++;\r\nuseraddr = disp2;\r\nif (base2)\r\nuseraddr += vcpu->run->s.regs.gprs[base2];\r\nif (useraddr & 1) {\r\nkvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\ngoto out;\r\n}\r\nrc = put_guest_u16(vcpu, useraddr, vcpu->vcpu_id);\r\nif (rc == -EFAULT) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\ngoto out;\r\n}\r\nVCPU_EVENT(vcpu, 5, "storing cpu address to %llx", useraddr);\r\ntrace_kvm_s390_handle_stap(vcpu, useraddr);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int handle_skey(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->stat.instruction_storage_key++;\r\nvcpu->arch.sie_block->gpsw.addr -= 4;\r\nVCPU_EVENT(vcpu, 4, "%s", "retrying storage key operation");\r\nreturn 0;\r\n}\r\nstatic int handle_stsch(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->stat.instruction_stsch++;\r\nVCPU_EVENT(vcpu, 4, "%s", "store subchannel - CC3");\r\nvcpu->arch.sie_block->gpsw.mask &= ~(3ul << 44);\r\nvcpu->arch.sie_block->gpsw.mask |= (3 & 3ul) << 44;\r\nreturn 0;\r\n}\r\nstatic int handle_chsc(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->stat.instruction_chsc++;\r\nVCPU_EVENT(vcpu, 4, "%s", "channel subsystem call - CC3");\r\nvcpu->arch.sie_block->gpsw.mask &= ~(3ul << 44);\r\nvcpu->arch.sie_block->gpsw.mask |= (3 & 3ul) << 44;\r\nreturn 0;\r\n}\r\nstatic int handle_stfl(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned int facility_list;\r\nint rc;\r\nvcpu->stat.instruction_stfl++;\r\nfacility_list = S390_lowcore.stfl_fac_list & 0xff00fff3;\r\nrc = copy_to_guest(vcpu, offsetof(struct _lowcore, stfl_fac_list),\r\n&facility_list, sizeof(facility_list));\r\nif (rc == -EFAULT)\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nelse {\r\nVCPU_EVENT(vcpu, 5, "store facility list value %x",\r\nfacility_list);\r\ntrace_kvm_s390_handle_stfl(vcpu, facility_list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_stidp(struct kvm_vcpu *vcpu)\r\n{\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16);\r\nu64 operand2;\r\nint rc;\r\nvcpu->stat.instruction_stidp++;\r\noperand2 = disp2;\r\nif (base2)\r\noperand2 += vcpu->run->s.regs.gprs[base2];\r\nif (operand2 & 7) {\r\nkvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\ngoto out;\r\n}\r\nrc = put_guest_u64(vcpu, operand2, vcpu->arch.stidp_data);\r\nif (rc == -EFAULT) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\ngoto out;\r\n}\r\nVCPU_EVENT(vcpu, 5, "%s", "store cpu id");\r\nout:\r\nreturn 0;\r\n}\r\nstatic void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nint cpus = 0;\r\nint n;\r\nspin_lock(&fi->lock);\r\nfor (n = 0; n < KVM_MAX_VCPUS; n++)\r\nif (fi->local_int[n])\r\ncpus++;\r\nspin_unlock(&fi->lock);\r\nif (stsi(mem, 3, 2, 2))\r\nmem->count = 0;\r\nif (mem->count < 8)\r\nmem->count++;\r\nfor (n = mem->count - 1; n > 0 ; n--)\r\nmemcpy(&mem->vm[n], &mem->vm[n - 1], sizeof(mem->vm[0]));\r\nmem->vm[0].cpus_total = cpus;\r\nmem->vm[0].cpus_configured = cpus;\r\nmem->vm[0].cpus_standby = 0;\r\nmem->vm[0].cpus_reserved = 0;\r\nmem->vm[0].caf = 1000;\r\nmemcpy(mem->vm[0].name, "KVMguest", 8);\r\nASCEBC(mem->vm[0].name, 8);\r\nmemcpy(mem->vm[0].cpi, "KVM/Linux ", 16);\r\nASCEBC(mem->vm[0].cpi, 16);\r\n}\r\nstatic int handle_stsi(struct kvm_vcpu *vcpu)\r\n{\r\nint fc = (vcpu->run->s.regs.gprs[0] & 0xf0000000) >> 28;\r\nint sel1 = vcpu->run->s.regs.gprs[0] & 0xff;\r\nint sel2 = vcpu->run->s.regs.gprs[1] & 0xffff;\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16);\r\nu64 operand2;\r\nunsigned long mem;\r\nvcpu->stat.instruction_stsi++;\r\nVCPU_EVENT(vcpu, 4, "stsi: fc: %x sel1: %x sel2: %x", fc, sel1, sel2);\r\noperand2 = disp2;\r\nif (base2)\r\noperand2 += vcpu->run->s.regs.gprs[base2];\r\nif (operand2 & 0xfff && fc > 0)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nswitch (fc) {\r\ncase 0:\r\nvcpu->run->s.regs.gprs[0] = 3 << 28;\r\nvcpu->arch.sie_block->gpsw.mask &= ~(3ul << 44);\r\nreturn 0;\r\ncase 1:\r\ncase 2:\r\nmem = get_zeroed_page(GFP_KERNEL);\r\nif (!mem)\r\ngoto out_fail;\r\nif (stsi((void *) mem, fc, sel1, sel2))\r\ngoto out_mem;\r\nbreak;\r\ncase 3:\r\nif (sel1 != 2 || sel2 != 2)\r\ngoto out_fail;\r\nmem = get_zeroed_page(GFP_KERNEL);\r\nif (!mem)\r\ngoto out_fail;\r\nhandle_stsi_3_2_2(vcpu, (void *) mem);\r\nbreak;\r\ndefault:\r\ngoto out_fail;\r\n}\r\nif (copy_to_guest_absolute(vcpu, operand2, (void *) mem, PAGE_SIZE)) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\ngoto out_mem;\r\n}\r\ntrace_kvm_s390_handle_stsi(vcpu, fc, sel1, sel2, operand2);\r\nfree_page(mem);\r\nvcpu->arch.sie_block->gpsw.mask &= ~(3ul << 44);\r\nvcpu->run->s.regs.gprs[0] = 0;\r\nreturn 0;\r\nout_mem:\r\nfree_page(mem);\r\nout_fail:\r\nvcpu->arch.sie_block->gpsw.mask |= 3ul << 44;\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_b2(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nhandler = priv_handlers[vcpu->arch.sie_block->ipa & 0x00ff];\r\nif (handler) {\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu,\r\nPGM_PRIVILEGED_OPERATION);\r\nelse\r\nreturn handler(vcpu);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_tprot(struct kvm_vcpu *vcpu)\r\n{\r\nint base1 = (vcpu->arch.sie_block->ipb & 0xf0000000) >> 28;\r\nint disp1 = (vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16;\r\nint base2 = (vcpu->arch.sie_block->ipb & 0xf000) >> 12;\r\nint disp2 = vcpu->arch.sie_block->ipb & 0x0fff;\r\nu64 address1 = disp1 + base1 ? vcpu->run->s.regs.gprs[base1] : 0;\r\nu64 address2 = disp2 + base2 ? vcpu->run->s.regs.gprs[base2] : 0;\r\nstruct vm_area_struct *vma;\r\nunsigned long user_address;\r\nvcpu->stat.instruction_tprot++;\r\nif (address2 & 0xf0)\r\nreturn -EOPNOTSUPP;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_DAT)\r\nreturn -EOPNOTSUPP;\r\nuser_address = (unsigned long) __guestaddr_to_user(vcpu, address1);\r\ndown_read(&current->mm->mmap_sem);\r\nvma = find_vma(current->mm, user_address);\r\nif (!vma) {\r\nup_read(&current->mm->mmap_sem);\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\n}\r\nvcpu->arch.sie_block->gpsw.mask &= ~(3ul << 44);\r\nif (!(vma->vm_flags & VM_WRITE) && (vma->vm_flags & VM_READ))\r\nvcpu->arch.sie_block->gpsw.mask |= (1ul << 44);\r\nif (!(vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_READ))\r\nvcpu->arch.sie_block->gpsw.mask |= (2ul << 44);\r\nup_read(&current->mm->mmap_sem);\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_e5(struct kvm_vcpu *vcpu)\r\n{\r\nif ((vcpu->arch.sie_block->ipa & 0x00ff) == 0x01)\r\nreturn handle_tprot(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_sckpf(struct kvm_vcpu *vcpu)\r\n{\r\nu32 value;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu,\r\nPGM_PRIVILEGED_OPERATION);\r\nif (vcpu->run->s.regs.gprs[0] & 0x00000000ffff0000)\r\nreturn kvm_s390_inject_program_int(vcpu,\r\nPGM_SPECIFICATION);\r\nvalue = vcpu->run->s.regs.gprs[0] & 0x000000000000ffff;\r\nvcpu->arch.sie_block->todpr = value;\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_01(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nhandler = x01_handlers[vcpu->arch.sie_block->ipa & 0x00ff];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}
