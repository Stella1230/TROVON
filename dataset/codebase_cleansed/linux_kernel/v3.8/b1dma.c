static inline void b1dma_writel(avmcard *card, u32 value, int off)\r\n{\r\nwritel(value, card->mbase + off);\r\n}\r\nstatic inline u32 b1dma_readl(avmcard *card, int off)\r\n{\r\nreturn readl(card->mbase + off);\r\n}\r\nstatic inline int b1dma_tx_empty(unsigned int port)\r\n{\r\nreturn inb(port + 0x03) & 0x1;\r\n}\r\nstatic inline int b1dma_rx_full(unsigned int port)\r\n{\r\nreturn inb(port + 0x02) & 0x1;\r\n}\r\nstatic int b1dma_tolink(avmcard *card, void *buf, unsigned int len)\r\n{\r\nunsigned long stop = jiffies + 1 * HZ;\r\nunsigned char *s = (unsigned char *)buf;\r\nwhile (len--) {\r\nwhile (!b1dma_tx_empty(card->port)\r\n&& time_before(jiffies, stop));\r\nif (!b1dma_tx_empty(card->port))\r\nreturn -1;\r\nt1outp(card->port, 0x01, *s++);\r\n}\r\nreturn 0;\r\n}\r\nstatic int b1dma_fromlink(avmcard *card, void *buf, unsigned int len)\r\n{\r\nunsigned long stop = jiffies + 1 * HZ;\r\nunsigned char *s = (unsigned char *)buf;\r\nwhile (len--) {\r\nwhile (!b1dma_rx_full(card->port)\r\n&& time_before(jiffies, stop));\r\nif (!b1dma_rx_full(card->port))\r\nreturn -1;\r\n*s++ = t1inp(card->port, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic int WriteReg(avmcard *card, u32 reg, u8 val)\r\n{\r\nu8 cmd = 0x00;\r\nif (b1dma_tolink(card, &cmd, 1) == 0\r\n&& b1dma_tolink(card, &reg, 4) == 0) {\r\nu32 tmp = val;\r\nreturn b1dma_tolink(card, &tmp, 4);\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 ReadReg(avmcard *card, u32 reg)\r\n{\r\nu8 cmd = 0x01;\r\nif (b1dma_tolink(card, &cmd, 1) == 0\r\n&& b1dma_tolink(card, &reg, 4) == 0) {\r\nu32 tmp;\r\nif (b1dma_fromlink(card, &tmp, 4) == 0)\r\nreturn (u8)tmp;\r\n}\r\nreturn 0xff;\r\n}\r\nstatic inline void _put_byte(void **pp, u8 val)\r\n{\r\nu8 *s = *pp;\r\n*s++ = val;\r\n*pp = s;\r\n}\r\nstatic inline void _put_word(void **pp, u32 val)\r\n{\r\nu8 *s = *pp;\r\n*s++ = val & 0xff;\r\n*s++ = (val >> 8) & 0xff;\r\n*s++ = (val >> 16) & 0xff;\r\n*s++ = (val >> 24) & 0xff;\r\n*pp = s;\r\n}\r\nstatic inline void _put_slice(void **pp, unsigned char *dp, unsigned int len)\r\n{\r\nunsigned i = len;\r\n_put_word(pp, i);\r\nwhile (i-- > 0)\r\n_put_byte(pp, *dp++);\r\n}\r\nstatic inline u8 _get_byte(void **pp)\r\n{\r\nu8 *s = *pp;\r\nu8 val;\r\nval = *s++;\r\n*pp = s;\r\nreturn val;\r\n}\r\nstatic inline u32 _get_word(void **pp)\r\n{\r\nu8 *s = *pp;\r\nu32 val;\r\nval = *s++;\r\nval |= (*s++ << 8);\r\nval |= (*s++ << 16);\r\nval |= (*s++ << 24);\r\n*pp = s;\r\nreturn val;\r\n}\r\nstatic inline u32 _get_slice(void **pp, unsigned char *dp)\r\n{\r\nunsigned int len, i;\r\nlen = i = _get_word(pp);\r\nwhile (i-- > 0) *dp++ = _get_byte(pp);\r\nreturn len;\r\n}\r\nvoid b1dma_reset(avmcard *card)\r\n{\r\ncard->csr = 0x0;\r\nb1dma_writel(card, card->csr, AMCC_INTCSR);\r\nb1dma_writel(card, 0, AMCC_MCSR);\r\nb1dma_writel(card, 0, AMCC_RXLEN);\r\nb1dma_writel(card, 0, AMCC_TXLEN);\r\nt1outp(card->port, 0x10, 0x00);\r\nt1outp(card->port, 0x07, 0x00);\r\nb1dma_writel(card, 0, AMCC_MCSR);\r\nmdelay(10);\r\nb1dma_writel(card, 0x0f000000, AMCC_MCSR);\r\nmdelay(10);\r\nb1dma_writel(card, 0, AMCC_MCSR);\r\nif (card->cardtype == avm_t1pci)\r\nmdelay(42);\r\nelse\r\nmdelay(10);\r\n}\r\nstatic int b1dma_detect(avmcard *card)\r\n{\r\nb1dma_writel(card, 0, AMCC_MCSR);\r\nmdelay(10);\r\nb1dma_writel(card, 0x0f000000, AMCC_MCSR);\r\nmdelay(10);\r\nb1dma_writel(card, 0, AMCC_MCSR);\r\nmdelay(42);\r\nb1dma_writel(card, 0, AMCC_RXLEN);\r\nb1dma_writel(card, 0, AMCC_TXLEN);\r\ncard->csr = 0x0;\r\nb1dma_writel(card, card->csr, AMCC_INTCSR);\r\nif (b1dma_readl(card, AMCC_MCSR) != 0x000000E6)\r\nreturn 1;\r\nb1dma_writel(card, 0xffffffff, AMCC_RXPTR);\r\nb1dma_writel(card, 0xffffffff, AMCC_TXPTR);\r\nif (b1dma_readl(card, AMCC_RXPTR) != 0xfffffffc\r\n|| b1dma_readl(card, AMCC_TXPTR) != 0xfffffffc)\r\nreturn 2;\r\nb1dma_writel(card, 0x0, AMCC_RXPTR);\r\nb1dma_writel(card, 0x0, AMCC_TXPTR);\r\nif (b1dma_readl(card, AMCC_RXPTR) != 0x0\r\n|| b1dma_readl(card, AMCC_TXPTR) != 0x0)\r\nreturn 3;\r\nt1outp(card->port, 0x10, 0x00);\r\nt1outp(card->port, 0x07, 0x00);\r\nt1outp(card->port, 0x02, 0x02);\r\nt1outp(card->port, 0x03, 0x02);\r\nif ((t1inp(card->port, 0x02) & 0xFE) != 0x02\r\n|| t1inp(card->port, 0x3) != 0x03)\r\nreturn 4;\r\nt1outp(card->port, 0x02, 0x00);\r\nt1outp(card->port, 0x03, 0x00);\r\nif ((t1inp(card->port, 0x02) & 0xFE) != 0x00\r\n|| t1inp(card->port, 0x3) != 0x01)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nint t1pci_detect(avmcard *card)\r\n{\r\nint ret;\r\nif ((ret = b1dma_detect(card)) != 0)\r\nreturn ret;\r\nif (WriteReg(card, 0x80001000, 0x11) != 0\r\n|| WriteReg(card, 0x80101000, 0x22) != 0\r\n|| WriteReg(card, 0x80201000, 0x33) != 0\r\n|| WriteReg(card, 0x80301000, 0x44) != 0)\r\nreturn 6;\r\nif (ReadReg(card, 0x80001000) != 0x11\r\n|| ReadReg(card, 0x80101000) != 0x22\r\n|| ReadReg(card, 0x80201000) != 0x33\r\n|| ReadReg(card, 0x80301000) != 0x44)\r\nreturn 7;\r\nif (WriteReg(card, 0x80001000, 0x55) != 0\r\n|| WriteReg(card, 0x80101000, 0x66) != 0\r\n|| WriteReg(card, 0x80201000, 0x77) != 0\r\n|| WriteReg(card, 0x80301000, 0x88) != 0)\r\nreturn 8;\r\nif (ReadReg(card, 0x80001000) != 0x55\r\n|| ReadReg(card, 0x80101000) != 0x66\r\n|| ReadReg(card, 0x80201000) != 0x77\r\n|| ReadReg(card, 0x80301000) != 0x88)\r\nreturn 9;\r\nreturn 0;\r\n}\r\nint b1pciv4_detect(avmcard *card)\r\n{\r\nint ret, i;\r\nif ((ret = b1dma_detect(card)) != 0)\r\nreturn ret;\r\nfor (i = 0; i < 5; i++) {\r\nif (WriteReg(card, 0x80A00000, 0x21) != 0)\r\nreturn 6;\r\nif ((ReadReg(card, 0x80A00000) & 0x01) != 0x01)\r\nreturn 7;\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nif (WriteReg(card, 0x80A00000, 0x20) != 0)\r\nreturn 8;\r\nif ((ReadReg(card, 0x80A00000) & 0x01) != 0x00)\r\nreturn 9;\r\n}\r\nreturn 0;\r\n}\r\nstatic void b1dma_queue_tx(avmcard *card, struct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nskb_queue_tail(&card->dma->send_queue, skb);\r\nif (!(card->csr & EN_TX_TC_INT)) {\r\nb1dma_dispatch_tx(card);\r\nb1dma_writel(card, card->csr, AMCC_INTCSR);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic void b1dma_dispatch_tx(avmcard *card)\r\n{\r\navmcard_dmainfo *dma = card->dma;\r\nstruct sk_buff *skb;\r\nu8 cmd, subcmd;\r\nu16 len;\r\nu32 txlen;\r\nvoid *p;\r\nskb = skb_dequeue(&dma->send_queue);\r\nlen = CAPIMSG_LEN(skb->data);\r\nif (len) {\r\ncmd = CAPIMSG_COMMAND(skb->data);\r\nsubcmd = CAPIMSG_SUBCOMMAND(skb->data);\r\np = dma->sendbuf.dmabuf;\r\nif (CAPICMD(cmd, subcmd) == CAPI_DATA_B3_REQ) {\r\nu16 dlen = CAPIMSG_DATALEN(skb->data);\r\n_put_byte(&p, SEND_DATA_B3_REQ);\r\n_put_slice(&p, skb->data, len);\r\n_put_slice(&p, skb->data + len, dlen);\r\n} else {\r\n_put_byte(&p, SEND_MESSAGE);\r\n_put_slice(&p, skb->data, len);\r\n}\r\ntxlen = (u8 *)p - (u8 *)dma->sendbuf.dmabuf;\r\n#ifdef AVM_B1DMA_DEBUG\r\nprintk(KERN_DEBUG "tx: put msg len=%d\n", txlen);\r\n#endif\r\n} else {\r\ntxlen = skb->len - 2;\r\n#ifdef AVM_B1DMA_POLLDEBUG\r\nif (skb->data[2] == SEND_POLLACK)\r\nprintk(KERN_INFO "%s: send ack\n", card->name);\r\n#endif\r\n#ifdef AVM_B1DMA_DEBUG\r\nprintk(KERN_DEBUG "tx: put 0x%x len=%d\n",\r\nskb->data[2], txlen);\r\n#endif\r\nskb_copy_from_linear_data_offset(skb, 2, dma->sendbuf.dmabuf,\r\nskb->len - 2);\r\n}\r\ntxlen = (txlen + 3) & ~3;\r\nb1dma_writel(card, dma->sendbuf.dmaaddr, AMCC_TXPTR);\r\nb1dma_writel(card, txlen, AMCC_TXLEN);\r\ncard->csr |= EN_TX_TC_INT;\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void queue_pollack(avmcard *card)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *p;\r\nskb = alloc_skb(3, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost poll ack\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_POLLACK);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nb1dma_queue_tx(card, skb);\r\n}\r\nstatic void b1dma_handle_rx(avmcard *card)\r\n{\r\navmctrl_info *cinfo = &card->ctrlinfo[0];\r\navmcard_dmainfo *dma = card->dma;\r\nstruct capi_ctr *ctrl = &cinfo->capi_ctrl;\r\nstruct sk_buff *skb;\r\nvoid *p = dma->recvbuf.dmabuf + 4;\r\nu32 ApplId, MsgLen, DataB3Len, NCCI, WindowSize;\r\nu8 b1cmd = _get_byte(&p);\r\n#ifdef AVM_B1DMA_DEBUG\r\nprintk(KERN_DEBUG "rx: 0x%x %lu\n", b1cmd, (unsigned long)dma->recvlen);\r\n#endif\r\nswitch (b1cmd) {\r\ncase RECEIVE_DATA_B3_IND:\r\nApplId = (unsigned) _get_word(&p);\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\nDataB3Len = _get_slice(&p, card->databuf);\r\nif (MsgLen < 30) {\r\nmemset(card->msgbuf + MsgLen, 0, 30 - MsgLen);\r\nMsgLen = 30;\r\nCAPIMSG_SETLEN(card->msgbuf, 30);\r\n}\r\nif (!(skb = alloc_skb(DataB3Len + MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nmemcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);\r\nmemcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_MESSAGE:\r\nApplId = (unsigned) _get_word(&p);\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\nif (!(skb = alloc_skb(MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nmemcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_CONF) {\r\nspin_lock(&card->lock);\r\ncapilib_data_b3_conf(&cinfo->ncci_head, ApplId,\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nspin_unlock(&card->lock);\r\n}\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_NEW_NCCI:\r\nApplId = _get_word(&p);\r\nNCCI = _get_word(&p);\r\nWindowSize = _get_word(&p);\r\nspin_lock(&card->lock);\r\ncapilib_new_ncci(&cinfo->ncci_head, ApplId, NCCI, WindowSize);\r\nspin_unlock(&card->lock);\r\nbreak;\r\ncase RECEIVE_FREE_NCCI:\r\nApplId = _get_word(&p);\r\nNCCI = _get_word(&p);\r\nif (NCCI != 0xffffffff) {\r\nspin_lock(&card->lock);\r\ncapilib_free_ncci(&cinfo->ncci_head, ApplId, NCCI);\r\nspin_unlock(&card->lock);\r\n}\r\nbreak;\r\ncase RECEIVE_START:\r\n#ifdef AVM_B1DMA_POLLDEBUG\r\nprintk(KERN_INFO "%s: receive poll\n", card->name);\r\n#endif\r\nif (!suppress_pollack)\r\nqueue_pollack(card);\r\ncapi_ctr_resume_output(ctrl);\r\nbreak;\r\ncase RECEIVE_STOP:\r\ncapi_ctr_suspend_output(ctrl);\r\nbreak;\r\ncase RECEIVE_INIT:\r\ncinfo->versionlen = _get_slice(&p, cinfo->versionbuf);\r\nb1_parse_version(cinfo);\r\nprintk(KERN_INFO "%s: %s-card (%s) now active\n",\r\ncard->name,\r\ncinfo->version[VER_CARDTYPE],\r\ncinfo->version[VER_DRIVER]);\r\ncapi_ctr_ready(ctrl);\r\nbreak;\r\ncase RECEIVE_TASK_READY:\r\nApplId = (unsigned) _get_word(&p);\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile (MsgLen > 0\r\n&& (card->msgbuf[MsgLen - 1] == '\n'\r\n|| card->msgbuf[MsgLen - 1] == '\r')) {\r\ncard->msgbuf[MsgLen - 1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: task %d \"%s\" ready.\n",\r\ncard->name, ApplId, card->msgbuf);\r\nbreak;\r\ncase RECEIVE_DEBUGMSG:\r\nMsgLen = _get_slice(&p, card->msgbuf);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile (MsgLen > 0\r\n&& (card->msgbuf[MsgLen - 1] == '\n'\r\n|| card->msgbuf[MsgLen - 1] == '\r')) {\r\ncard->msgbuf[MsgLen - 1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: b1dma_interrupt: 0x%x ???\n",\r\ncard->name, b1cmd);\r\nreturn;\r\n}\r\n}\r\nstatic void b1dma_handle_interrupt(avmcard *card)\r\n{\r\nu32 status;\r\nu32 newcsr;\r\nspin_lock(&card->lock);\r\nstatus = b1dma_readl(card, AMCC_INTCSR);\r\nif ((status & ANY_S5933_INT) == 0) {\r\nspin_unlock(&card->lock);\r\nreturn;\r\n}\r\nnewcsr = card->csr | (status & ALL_INT);\r\nif (status & TX_TC_INT) newcsr &= ~EN_TX_TC_INT;\r\nif (status & RX_TC_INT) newcsr &= ~EN_RX_TC_INT;\r\nb1dma_writel(card, newcsr, AMCC_INTCSR);\r\nif ((status & RX_TC_INT) != 0) {\r\nstruct avmcard_dmainfo *dma = card->dma;\r\nu32 rxlen;\r\nif (card->dma->recvlen == 0) {\r\nrxlen = b1dma_readl(card, AMCC_RXLEN);\r\nif (rxlen == 0) {\r\ndma->recvlen = *((u32 *)dma->recvbuf.dmabuf);\r\nrxlen = (dma->recvlen + 3) & ~3;\r\nb1dma_writel(card, dma->recvbuf.dmaaddr + 4, AMCC_RXPTR);\r\nb1dma_writel(card, rxlen, AMCC_RXLEN);\r\n#ifdef AVM_B1DMA_DEBUG\r\n} else {\r\nprintk(KERN_ERR "%s: rx not complete (%d).\n",\r\ncard->name, rxlen);\r\n#endif\r\n}\r\n} else {\r\nspin_unlock(&card->lock);\r\nb1dma_handle_rx(card);\r\ndma->recvlen = 0;\r\nspin_lock(&card->lock);\r\nb1dma_writel(card, dma->recvbuf.dmaaddr, AMCC_RXPTR);\r\nb1dma_writel(card, 4, AMCC_RXLEN);\r\n}\r\n}\r\nif ((status & TX_TC_INT) != 0) {\r\nif (skb_queue_empty(&card->dma->send_queue))\r\ncard->csr &= ~EN_TX_TC_INT;\r\nelse\r\nb1dma_dispatch_tx(card);\r\n}\r\nb1dma_writel(card, card->csr, AMCC_INTCSR);\r\nspin_unlock(&card->lock);\r\n}\r\nirqreturn_t b1dma_interrupt(int interrupt, void *devptr)\r\n{\r\navmcard *card = devptr;\r\nb1dma_handle_interrupt(card);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int b1dma_loaded(avmcard *card)\r\n{\r\nunsigned long stop;\r\nunsigned char ans;\r\nunsigned long tout = 2;\r\nunsigned int base = card->port;\r\nfor (stop = jiffies + tout * HZ; time_before(jiffies, stop);) {\r\nif (b1_tx_empty(base))\r\nbreak;\r\n}\r\nif (!b1_tx_empty(base)) {\r\nprintk(KERN_ERR "%s: b1dma_loaded: tx err, corrupted t4 file ?\n",\r\ncard->name);\r\nreturn 0;\r\n}\r\nb1_put_byte(base, SEND_POLLACK);\r\nfor (stop = jiffies + tout * HZ; time_before(jiffies, stop);) {\r\nif (b1_rx_full(base)) {\r\nif ((ans = b1_get_byte(base)) == RECEIVE_POLLDWORD) {\r\nreturn 1;\r\n}\r\nprintk(KERN_ERR "%s: b1dma_loaded: got 0x%x, firmware not running in dword mode\n", card->name, ans);\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_ERR "%s: b1dma_loaded: firmware not running\n", card->name);\r\nreturn 0;\r\n}\r\nstatic void b1dma_send_init(avmcard *card)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *p;\r\nskb = alloc_skb(15, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost register appl.\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_INIT);\r\n_put_word(&p, CAPI_MAXAPPL);\r\n_put_word(&p, AVM_NCCI_PER_CHANNEL * 30);\r\n_put_word(&p, card->cardnr - 1);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nb1dma_queue_tx(card, skb);\r\n}\r\nint b1dma_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nint retval;\r\nb1dma_reset(card);\r\nif ((retval = b1_load_t4file(card, &data->firmware))) {\r\nb1dma_reset(card);\r\nprintk(KERN_ERR "%s: failed to load t4file!!\n",\r\ncard->name);\r\nreturn retval;\r\n}\r\nif (data->configuration.len > 0 && data->configuration.data) {\r\nif ((retval = b1_load_config(card, &data->configuration))) {\r\nb1dma_reset(card);\r\nprintk(KERN_ERR "%s: failed to load config!!\n",\r\ncard->name);\r\nreturn retval;\r\n}\r\n}\r\nif (!b1dma_loaded(card)) {\r\nb1dma_reset(card);\r\nprintk(KERN_ERR "%s: failed to load t4file.\n", card->name);\r\nreturn -EIO;\r\n}\r\ncard->csr = AVM_FLAG;\r\nb1dma_writel(card, card->csr, AMCC_INTCSR);\r\nb1dma_writel(card, EN_A2P_TRANSFERS | EN_P2A_TRANSFERS | A2P_HI_PRIORITY |\r\nP2A_HI_PRIORITY | RESET_A2P_FLAGS | RESET_P2A_FLAGS,\r\nAMCC_MCSR);\r\nt1outp(card->port, 0x07, 0x30);\r\nt1outp(card->port, 0x10, 0xF0);\r\ncard->dma->recvlen = 0;\r\nb1dma_writel(card, card->dma->recvbuf.dmaaddr, AMCC_RXPTR);\r\nb1dma_writel(card, 4, AMCC_RXLEN);\r\ncard->csr |= EN_RX_TC_INT;\r\nb1dma_writel(card, card->csr, AMCC_INTCSR);\r\nb1dma_send_init(card);\r\nreturn 0;\r\n}\r\nvoid b1dma_reset_ctr(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nb1dma_reset(card);\r\nmemset(cinfo->version, 0, sizeof(cinfo->version));\r\ncapilib_release(&cinfo->ncci_head);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_down(ctrl);\r\n}\r\nvoid b1dma_register_appl(struct capi_ctr *ctrl,\r\nu16 appl,\r\ncapi_register_params *rp)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nstruct sk_buff *skb;\r\nint want = rp->level3cnt;\r\nint nconn;\r\nvoid *p;\r\nif (want > 0) nconn = want;\r\nelse nconn = ctrl->profile.nbchannel * -want;\r\nif (nconn == 0) nconn = ctrl->profile.nbchannel;\r\nskb = alloc_skb(23, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost register appl.\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_REGISTER);\r\n_put_word(&p, appl);\r\n_put_word(&p, 1024 * (nconn + 1));\r\n_put_word(&p, nconn);\r\n_put_word(&p, rp->datablkcnt);\r\n_put_word(&p, rp->datablklen);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nb1dma_queue_tx(card, skb);\r\n}\r\nvoid b1dma_release_appl(struct capi_ctr *ctrl, u16 appl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nstruct sk_buff *skb;\r\nvoid *p;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ncapilib_release_appl(&cinfo->ncci_head, appl);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nskb = alloc_skb(7, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_CRIT "%s: no memory, lost release appl.\n",\r\ncard->name);\r\nreturn;\r\n}\r\np = skb->data;\r\n_put_byte(&p, 0);\r\n_put_byte(&p, 0);\r\n_put_byte(&p, SEND_RELEASE);\r\n_put_word(&p, appl);\r\nskb_put(skb, (u8 *)p - (u8 *)skb->data);\r\nb1dma_queue_tx(card, skb);\r\n}\r\nu16 b1dma_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nu16 retval = CAPI_NOERROR;\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_REQ) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nretval = capilib_data_b3_req(&cinfo->ncci_head,\r\nCAPIMSG_APPID(skb->data),\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nif (retval == CAPI_NOERROR)\r\nb1dma_queue_tx(card, skb);\r\nreturn retval;\r\n}\r\nstatic int b1dmactl_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct capi_ctr *ctrl = m->private;\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nu8 flag;\r\nchar *s;\r\nu32 txoff, txlen, rxoff, rxlen, csr;\r\nunsigned long flags;\r\nseq_printf(m, "%-16s %s\n", "name", card->name);\r\nseq_printf(m, "%-16s 0x%x\n", "io", card->port);\r\nseq_printf(m, "%-16s %d\n", "irq", card->irq);\r\nseq_printf(m, "%-16s 0x%lx\n", "membase", card->membase);\r\nswitch (card->cardtype) {\r\ncase avm_b1isa: s = "B1 ISA"; break;\r\ncase avm_b1pci: s = "B1 PCI"; break;\r\ncase avm_b1pcmcia: s = "B1 PCMCIA"; break;\r\ncase avm_m1: s = "M1"; break;\r\ncase avm_m2: s = "M2"; break;\r\ncase avm_t1isa: s = "T1 ISA (HEMA)"; break;\r\ncase avm_t1pci: s = "T1 PCI"; break;\r\ncase avm_c4: s = "C4"; break;\r\ncase avm_c2: s = "C2"; break;\r\ndefault: s = "???"; break;\r\n}\r\nseq_printf(m, "%-16s %s\n", "type", s);\r\nif ((s = cinfo->version[VER_DRIVER]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_driver", s);\r\nif ((s = cinfo->version[VER_CARDTYPE]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_cardtype", s);\r\nif ((s = cinfo->version[VER_SERIAL]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_serial", s);\r\nif (card->cardtype != avm_m1) {\r\nflag = ((u8 *)(ctrl->profile.manu))[3];\r\nif (flag)\r\nseq_printf(m, "%-16s%s%s%s%s%s%s%s\n",\r\n"protocol",\r\n(flag & 0x01) ? " DSS1" : "",\r\n(flag & 0x02) ? " CT1" : "",\r\n(flag & 0x04) ? " VN3" : "",\r\n(flag & 0x08) ? " NI1" : "",\r\n(flag & 0x10) ? " AUSTEL" : "",\r\n(flag & 0x20) ? " ESS" : "",\r\n(flag & 0x40) ? " 1TR6" : ""\r\n);\r\n}\r\nif (card->cardtype != avm_m1) {\r\nflag = ((u8 *)(ctrl->profile.manu))[5];\r\nif (flag)\r\nseq_printf(m, "%-16s%s%s%s%s\n",\r\n"linetype",\r\n(flag & 0x01) ? " point to point" : "",\r\n(flag & 0x02) ? " point to multipoint" : "",\r\n(flag & 0x08) ? " leased line without D-channel" : "",\r\n(flag & 0x04) ? " leased line with D-channel" : ""\r\n);\r\n}\r\nseq_printf(m, "%-16s %s\n", "cardname", cinfo->cardname);\r\nspin_lock_irqsave(&card->lock, flags);\r\ntxoff = (dma_addr_t)b1dma_readl(card, AMCC_TXPTR)-card->dma->sendbuf.dmaaddr;\r\ntxlen = b1dma_readl(card, AMCC_TXLEN);\r\nrxoff = (dma_addr_t)b1dma_readl(card, AMCC_RXPTR)-card->dma->recvbuf.dmaaddr;\r\nrxlen = b1dma_readl(card, AMCC_RXLEN);\r\ncsr = b1dma_readl(card, AMCC_INTCSR);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nseq_printf(m, "%-16s 0x%lx\n", "csr (cached)", (unsigned long)card->csr);\r\nseq_printf(m, "%-16s 0x%lx\n", "csr", (unsigned long)csr);\r\nseq_printf(m, "%-16s %lu\n", "txoff", (unsigned long)txoff);\r\nseq_printf(m, "%-16s %lu\n", "txlen", (unsigned long)txlen);\r\nseq_printf(m, "%-16s %lu\n", "rxoff", (unsigned long)rxoff);\r\nseq_printf(m, "%-16s %lu\n", "rxlen", (unsigned long)rxlen);\r\nreturn 0;\r\n}\r\nstatic int b1dmactl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, b1dmactl_proc_show, PDE(inode)->data);\r\n}\r\nstatic int __init b1dma_init(void)\r\n{\r\nchar *p;\r\nchar rev[32];\r\nif ((p = strchr(revision, ':')) != NULL && p[1]) {\r\nstrlcpy(rev, p + 2, sizeof(rev));\r\nif ((p = strchr(rev, '$')) != NULL && p > rev)\r\n*(p - 1) = 0;\r\n} else\r\nstrcpy(rev, "1.0");\r\nprintk(KERN_INFO "b1dma: revision %s\n", rev);\r\nreturn 0;\r\n}\r\nstatic void __exit b1dma_exit(void)\r\n{\r\n}
