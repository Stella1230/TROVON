static void ccp2_print_status(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\ndev_dbg(isp->dev, "-------------CCP2 Register dump-------------\n");\r\nCCP2_PRINT_REGISTER(isp, SYSCONFIG);\r\nCCP2_PRINT_REGISTER(isp, SYSSTATUS);\r\nCCP2_PRINT_REGISTER(isp, LC01_IRQENABLE);\r\nCCP2_PRINT_REGISTER(isp, LC01_IRQSTATUS);\r\nCCP2_PRINT_REGISTER(isp, LC23_IRQENABLE);\r\nCCP2_PRINT_REGISTER(isp, LC23_IRQSTATUS);\r\nCCP2_PRINT_REGISTER(isp, LCM_IRQENABLE);\r\nCCP2_PRINT_REGISTER(isp, LCM_IRQSTATUS);\r\nCCP2_PRINT_REGISTER(isp, CTRL);\r\nCCP2_PRINT_REGISTER(isp, LCx_CTRL(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_CODE(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_STAT_START(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_STAT_SIZE(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_SOF_ADDR(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_EOF_ADDR(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_DAT_START(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_DAT_SIZE(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_DAT_PING_ADDR(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_DAT_PONG_ADDR(0));\r\nCCP2_PRINT_REGISTER(isp, LCx_DAT_OFST(0));\r\nCCP2_PRINT_REGISTER(isp, LCM_CTRL);\r\nCCP2_PRINT_REGISTER(isp, LCM_VSIZE);\r\nCCP2_PRINT_REGISTER(isp, LCM_HSIZE);\r\nCCP2_PRINT_REGISTER(isp, LCM_PREFETCH);\r\nCCP2_PRINT_REGISTER(isp, LCM_SRC_ADDR);\r\nCCP2_PRINT_REGISTER(isp, LCM_SRC_OFST);\r\nCCP2_PRINT_REGISTER(isp, LCM_DST_ADDR);\r\nCCP2_PRINT_REGISTER(isp, LCM_DST_OFST);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic void ccp2_reset(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nint i = 0;\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_SYSCONFIG,\r\nISPCCP2_SYSCONFIG_SOFT_RESET);\r\nwhile (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_SYSSTATUS) &\r\nISPCCP2_SYSSTATUS_RESET_DONE)) {\r\nudelay(10);\r\nif (i++ > 10) {\r\ndev_warn(isp->dev,\r\n"omap3_isp: timeout waiting for ccp2 reset\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ccp2_pwr_cfg(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nisp_reg_writel(isp, ISPCCP2_SYSCONFIG_MSTANDBY_MODE_SMART |\r\n((isp->revision == ISP_REVISION_15_0 && isp->autoidle) ?\r\nISPCCP2_SYSCONFIG_AUTO_IDLE : 0),\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_SYSCONFIG);\r\n}\r\nstatic void ccp2_if_enable(struct isp_ccp2_device *ccp2, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nint i;\r\nif (enable && ccp2->vdds_csib)\r\nregulator_enable(ccp2->vdds_csib);\r\nfor (i = 0; i < CCP2_LCx_CHANS_NUM; i++)\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_CTRL(i),\r\nISPCCP2_LCx_CTRL_CHAN_EN,\r\nenable ? ISPCCP2_LCx_CTRL_CHAN_EN : 0);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL,\r\nISPCCP2_CTRL_MODE | ISPCCP2_CTRL_IF_EN,\r\nenable ? (ISPCCP2_CTRL_MODE | ISPCCP2_CTRL_IF_EN) : 0);\r\nif (!enable && ccp2->vdds_csib)\r\nregulator_disable(ccp2->vdds_csib);\r\n}\r\nstatic void ccp2_mem_enable(struct isp_ccp2_device *ccp2, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nif (enable)\r\nccp2_if_enable(ccp2, 0);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL,\r\nISPCCP2_CTRL_MODE, enable ? ISPCCP2_CTRL_MODE : 0);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_CTRL,\r\nISPCCP2_LCM_CTRL_CHAN_EN,\r\nenable ? ISPCCP2_LCM_CTRL_CHAN_EN : 0);\r\n}\r\nstatic int ccp2_phyif_config(struct isp_ccp2_device *ccp2,\r\nconst struct isp_ccp2_platform_data *pdata)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nu32 val;\r\nval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL) |\r\nISPCCP2_CTRL_IO_OUT_SEL | ISPCCP2_CTRL_MODE;\r\nBIT_SET(val, ISPCCP2_CTRL_PHY_SEL_SHIFT, ISPCCP2_CTRL_PHY_SEL_MASK,\r\npdata->phy_layer);\r\nBIT_SET(val, ISPCCP2_CTRL_INV_SHIFT, ISPCCP2_CTRL_INV_MASK,\r\npdata->strobe_clk_pol);\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\r\nval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\r\nif (!(val & ISPCCP2_CTRL_MODE)) {\r\nif (pdata->ccp2_mode == ISP_CCP2_MODE_CCP2)\r\ndev_warn(isp->dev, "OMAP3 CCP2 bus not available\n");\r\nif (pdata->phy_layer == ISP_CCP2_PHY_DATA_STROBE)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ccp2_vp_config(struct isp_ccp2_device *ccp2,\r\nunsigned int vpclk_div)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nu32 val;\r\nval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\r\nval |= ISPCCP2_CTRL_VP_ONLY_EN;\r\nif (isp->revision == ISP_REVISION_15_0) {\r\nvpclk_div = clamp_t(unsigned int, vpclk_div, 1, 65536);\r\nvpclk_div = min(ISPCCP2_VPCLK_FRACDIV / vpclk_div, 65535U);\r\nBIT_SET(val, ISPCCP2_CTRL_VPCLK_DIV_SHIFT,\r\nISPCCP2_CTRL_VPCLK_DIV_MASK, vpclk_div);\r\n} else {\r\nvpclk_div = clamp_t(unsigned int, vpclk_div, 1, 4);\r\nBIT_SET(val, ISPCCP2_CTRL_VP_OUT_CTRL_SHIFT,\r\nISPCCP2_CTRL_VP_OUT_CTRL_MASK, vpclk_div - 1);\r\n}\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL);\r\n}\r\nstatic void ccp2_lcx_config(struct isp_ccp2_device *ccp2,\r\nstruct isp_interface_lcx_config *config)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nu32 val, format;\r\nswitch (config->format) {\r\ncase V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:\r\nformat = ISPCCP2_LCx_CTRL_FORMAT_RAW8_DPCM10_VP;\r\nbreak;\r\ncase V4L2_MBUS_FMT_SGRBG10_1X10:\r\ndefault:\r\nformat = ISPCCP2_LCx_CTRL_FORMAT_RAW10_VP;\r\nbreak;\r\n}\r\nval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_CTRL(0))\r\n| (ISPCCP2_LCx_CTRL_REGION_EN);\r\nif (isp->revision == ISP_REVISION_15_0) {\r\nBIT_SET(val, ISPCCP2_LCx_CTRL_CRC_SHIFT_15_0,\r\nISPCCP2_LCx_CTRL_CRC_MASK,\r\nconfig->crc);\r\nBIT_SET(val, ISPCCP2_LCx_CTRL_FORMAT_SHIFT_15_0,\r\nISPCCP2_LCx_CTRL_FORMAT_MASK_15_0, format);\r\n} else {\r\nBIT_SET(val, ISPCCP2_LCx_CTRL_CRC_SHIFT,\r\nISPCCP2_LCx_CTRL_CRC_MASK,\r\nconfig->crc);\r\nBIT_SET(val, ISPCCP2_LCx_CTRL_FORMAT_SHIFT,\r\nISPCCP2_LCx_CTRL_FORMAT_MASK, format);\r\n}\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_CTRL(0));\r\nisp_reg_writel(isp, config->data_start << ISPCCP2_LCx_DAT_SHIFT,\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_DAT_START(0));\r\nisp_reg_writel(isp, config->data_size << ISPCCP2_LCx_DAT_SHIFT,\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCx_DAT_SIZE(0));\r\nval = ISPCCP2_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_CRC_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_FSP_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_FW_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_FSC_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_SSC_IRQ;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LC01_IRQSTATUS);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LC01_IRQENABLE, val);\r\n}\r\nstatic int ccp2_if_configure(struct isp_ccp2_device *ccp2)\r\n{\r\nconst struct isp_v4l2_subdevs_group *pdata;\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *sensor;\r\nu32 lines = 0;\r\nint ret;\r\nccp2_pwr_cfg(ccp2);\r\npad = media_entity_remote_source(&ccp2->pads[CCP2_PAD_SINK]);\r\nsensor = media_entity_to_v4l2_subdev(pad->entity);\r\npdata = sensor->host_priv;\r\nret = ccp2_phyif_config(ccp2, &pdata->bus.ccp2);\r\nif (ret < 0)\r\nreturn ret;\r\nccp2_vp_config(ccp2, pdata->bus.ccp2.vpclk_div + 1);\r\nv4l2_subdev_call(sensor, sensor, g_skip_top_lines, &lines);\r\nformat = &ccp2->formats[CCP2_PAD_SINK];\r\nccp2->if_cfg.data_start = lines;\r\nccp2->if_cfg.crc = pdata->bus.ccp2.crc;\r\nccp2->if_cfg.format = format->code;\r\nccp2->if_cfg.data_size = format->height;\r\nccp2_lcx_config(ccp2, &ccp2->if_cfg);\r\nreturn 0;\r\n}\r\nstatic int ccp2_adjust_bandwidth(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nconst struct v4l2_mbus_framefmt *ofmt = &ccp2->formats[CCP2_PAD_SOURCE];\r\nunsigned long l3_ick = pipe->l3_ick;\r\nstruct v4l2_fract *timeperframe;\r\nunsigned int vpclk_div = 2;\r\nunsigned int value;\r\nu64 bound;\r\nu64 area;\r\nvpclk_div = max_t(unsigned int, DIV_ROUND_UP(l3_ick, pipe->max_rate),\r\nvpclk_div);\r\ntimeperframe = &pipe->max_timeperframe;\r\nif (timeperframe->numerator) {\r\narea = ofmt->width * ofmt->height;\r\nbound = div_u64(area * timeperframe->denominator,\r\ntimeperframe->numerator);\r\nvalue = min_t(u64, bound, l3_ick);\r\nvpclk_div = max_t(unsigned int, l3_ick / value, vpclk_div);\r\n}\r\ndev_dbg(isp->dev, "%s: minimum clock divisor = %u\n", __func__,\r\nvpclk_div);\r\nreturn vpclk_div;\r\n}\r\nstatic void ccp2_mem_configure(struct isp_ccp2_device *ccp2,\r\nstruct isp_interface_mem_config *config)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nu32 sink_pixcode = ccp2->formats[CCP2_PAD_SINK].code;\r\nu32 source_pixcode = ccp2->formats[CCP2_PAD_SOURCE].code;\r\nunsigned int dpcm_decompress = 0;\r\nu32 val, hwords;\r\nif (sink_pixcode != source_pixcode &&\r\nsink_pixcode == V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8)\r\ndpcm_decompress = 1;\r\nccp2_pwr_cfg(ccp2);\r\nisp_reg_writel(isp, ISPCCP2_LCM_HSIZE_SKIP_MIN |\r\n(config->hsize_count << ISPCCP2_LCM_HSIZE_SHIFT),\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_HSIZE);\r\nisp_reg_writel(isp, config->vsize_count << ISPCCP2_LCM_VSIZE_SHIFT,\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_VSIZE);\r\nif (ccp2->video_in.bpl_padding == 0)\r\nconfig->src_ofst = 0;\r\nelse\r\nconfig->src_ofst = ccp2->video_in.bpl_value;\r\nisp_reg_writel(isp, config->src_ofst, OMAP3_ISP_IOMEM_CCP2,\r\nISPCCP2_LCM_SRC_OFST);\r\nval = ISPCCP2_LCM_CTRL_DST_FORMAT_RAW10 <<\r\nISPCCP2_LCM_CTRL_DST_FORMAT_SHIFT;\r\nif (dpcm_decompress) {\r\nval |= ISPCCP2_LCM_CTRL_SRC_FORMAT_RAW8 <<\r\nISPCCP2_LCM_CTRL_SRC_FORMAT_SHIFT;\r\nval |= ISPCCP2_LCM_CTRL_SRC_DPCM_PRED;\r\nval |= ISPCCP2_LCM_CTRL_SRC_DECOMPR_DPCM10 <<\r\nISPCCP2_LCM_CTRL_SRC_DECOMPR_SHIFT;\r\n} else {\r\nval |= ISPCCP2_LCM_CTRL_SRC_FORMAT_RAW10 <<\r\nISPCCP2_LCM_CTRL_SRC_FORMAT_SHIFT;\r\n}\r\nval |= ISPCCP2_LCM_CTRL_BURST_SIZE_32X <<\r\nISPCCP2_LCM_CTRL_BURST_SIZE_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_CTRL);\r\nif (dpcm_decompress)\r\nhwords = (ISPCCP2_LCM_HSIZE_SKIP_MIN +\r\nconfig->hsize_count) >> 3;\r\nelse\r\nhwords = (ISPCCP2_LCM_HSIZE_SKIP_MIN +\r\nconfig->hsize_count) >> 2;\r\nisp_reg_writel(isp, hwords << ISPCCP2_LCM_PREFETCH_SHIFT,\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_PREFETCH);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_CTRL,\r\nISPCCP2_CTRL_IO_OUT_SEL | ISPCCP2_CTRL_MODE);\r\nccp2_vp_config(ccp2, ccp2_adjust_bandwidth(ccp2));\r\nisp_reg_writel(isp, ISPCCP2_LCM_IRQSTATUS_OCPERROR_IRQ |\r\nISPCCP2_LCM_IRQSTATUS_EOF_IRQ,\r\nOMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_IRQSTATUS);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_IRQENABLE,\r\nISPCCP2_LCM_IRQSTATUS_EOF_IRQ |\r\nISPCCP2_LCM_IRQSTATUS_OCPERROR_IRQ);\r\n}\r\nstatic void ccp2_set_inaddr(struct isp_ccp2_device *ccp2, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_CCP2, ISPCCP2_LCM_SRC_ADDR);\r\n}\r\nstatic void ccp2_isr_buffer(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\r\nstruct isp_buffer *buffer;\r\nbuffer = omap3isp_video_buffer_next(&ccp2->video_in);\r\nif (buffer != NULL)\r\nccp2_set_inaddr(ccp2, buffer->isp_addr);\r\npipe->state |= ISP_PIPELINE_IDLE_INPUT;\r\nif (ccp2->state == ISP_PIPELINE_STREAM_SINGLESHOT) {\r\nif (isp_pipeline_ready(pipe))\r\nomap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_SINGLESHOT);\r\n}\r\n}\r\nvoid omap3isp_ccp2_isr(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&ccp2->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nstatic const u32 ISPCCP2_LC01_ERROR =\r\nISPCCP2_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_CRC_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_FSP_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_FW_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_FSC_IRQ |\r\nISPCCP2_LC01_IRQSTATUS_LC0_SSC_IRQ;\r\nu32 lcx_irqstatus, lcm_irqstatus;\r\nlcx_irqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2,\r\nISPCCP2_LC01_IRQSTATUS);\r\nisp_reg_writel(isp, lcx_irqstatus, OMAP3_ISP_IOMEM_CCP2,\r\nISPCCP2_LC01_IRQSTATUS);\r\nlcm_irqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_CCP2,\r\nISPCCP2_LCM_IRQSTATUS);\r\nisp_reg_writel(isp, lcm_irqstatus, OMAP3_ISP_IOMEM_CCP2,\r\nISPCCP2_LCM_IRQSTATUS);\r\nif (lcx_irqstatus & ISPCCP2_LC01_ERROR) {\r\npipe->error = true;\r\ndev_dbg(isp->dev, "CCP2 err:%x\n", lcx_irqstatus);\r\nreturn;\r\n}\r\nif (lcm_irqstatus & ISPCCP2_LCM_IRQSTATUS_OCPERROR_IRQ) {\r\npipe->error = true;\r\ndev_dbg(isp->dev, "CCP2 OCP err:%x\n", lcm_irqstatus);\r\n}\r\nif (omap3isp_module_sync_is_stopping(&ccp2->wait, &ccp2->stopping))\r\nreturn;\r\nif (lcm_irqstatus & ISPCCP2_LCM_IRQSTATUS_EOF_IRQ)\r\nccp2_isr_buffer(ccp2);\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__ccp2_get_format(struct isp_ccp2_device *ccp2, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nelse\r\nreturn &ccp2->formats[pad];\r\n}\r\nstatic void ccp2_try_format(struct isp_ccp2_device *ccp2,\r\nstruct v4l2_subdev_fh *fh, unsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nswitch (pad) {\r\ncase CCP2_PAD_SINK:\r\nif (fmt->code != V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8)\r\nfmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nif (ccp2->input == CCP2_INPUT_SENSOR) {\r\nfmt->width = clamp_t(u32, fmt->width,\r\nISPCCP2_DAT_START_MIN,\r\nISPCCP2_DAT_START_MAX);\r\nfmt->height = clamp_t(u32, fmt->height,\r\nISPCCP2_DAT_SIZE_MIN,\r\nISPCCP2_DAT_SIZE_MAX);\r\n} else if (ccp2->input == CCP2_INPUT_MEMORY) {\r\nfmt->width = clamp_t(u32, fmt->width,\r\nISPCCP2_LCM_HSIZE_COUNT_MIN,\r\nISPCCP2_LCM_HSIZE_COUNT_MAX);\r\nfmt->height = clamp_t(u32, fmt->height,\r\nISPCCP2_LCM_VSIZE_MIN,\r\nISPCCP2_LCM_VSIZE_MAX);\r\n}\r\nbreak;\r\ncase CCP2_PAD_SOURCE:\r\nformat = __ccp2_get_format(ccp2, fh, CCP2_PAD_SINK, which);\r\nmemcpy(fmt, format, sizeof(*fmt));\r\nfmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nbreak;\r\n}\r\nfmt->field = V4L2_FIELD_NONE;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\n}\r\nstatic int ccp2_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (code->pad == CCP2_PAD_SINK) {\r\nif (code->index >= ARRAY_SIZE(ccp2_fmts))\r\nreturn -EINVAL;\r\ncode->code = ccp2_fmts[code->index];\r\n} else {\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\nformat = __ccp2_get_format(ccp2, fh, CCP2_PAD_SINK,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\ncode->code = format->code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccp2_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nccp2_try_format(ccp2, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nccp2_try_format(ccp2, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int ccp2_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ccp2_get_format(ccp2, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int ccp2_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ccp2_get_format(ccp2, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nccp2_try_format(ccp2, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == CCP2_PAD_SINK) {\r\nformat = __ccp2_get_format(ccp2, fh, CCP2_PAD_SOURCE,\r\nfmt->which);\r\n*format = fmt->format;\r\nccp2_try_format(ccp2, fh, CCP2_PAD_SOURCE, format, fmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccp2_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = CCP2_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\nccp2_set_format(sd, fh, &format);\r\nreturn 0;\r\n}\r\nstatic int ccp2_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\r\nstruct isp_device *isp = to_isp_device(ccp2);\r\nstruct device *dev = to_device(ccp2);\r\nint ret;\r\nif (ccp2->state == ISP_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\natomic_set(&ccp2->stopping, 0);\r\n}\r\nswitch (enable) {\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (ccp2->phy) {\r\nret = omap3isp_csiphy_acquire(ccp2->phy);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nccp2_if_configure(ccp2);\r\nccp2_print_status(ccp2);\r\nccp2_if_enable(ccp2, 1);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (ccp2->state != ISP_PIPELINE_STREAM_SINGLESHOT) {\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = &ccp2->formats[CCP2_PAD_SINK];\r\nccp2->mem_cfg.hsize_count = format->width;\r\nccp2->mem_cfg.vsize_count = format->height;\r\nccp2->mem_cfg.src_ofst = 0;\r\nccp2_mem_configure(ccp2, &ccp2->mem_cfg);\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_CSI1_READ);\r\nccp2_print_status(ccp2);\r\n}\r\nccp2_mem_enable(ccp2, 1);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nif (omap3isp_module_sync_idle(&sd->entity, &ccp2->wait,\r\n&ccp2->stopping))\r\ndev_dbg(dev, "%s: module stop timeout.\n", sd->name);\r\nif (ccp2->input == CCP2_INPUT_MEMORY) {\r\nccp2_mem_enable(ccp2, 0);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_CSI1_READ);\r\n} else if (ccp2->input == CCP2_INPUT_SENSOR) {\r\nccp2_if_enable(ccp2, 0);\r\nif (ccp2->phy)\r\nomap3isp_csiphy_release(ccp2->phy);\r\n}\r\nbreak;\r\n}\r\nccp2->state = enable;\r\nreturn 0;\r\n}\r\nstatic int ccp2_video_queue(struct isp_video *video, struct isp_buffer *buffer)\r\n{\r\nstruct isp_ccp2_device *ccp2 = &video->isp->isp_ccp2;\r\nccp2_set_inaddr(ccp2, buffer->isp_addr);\r\nreturn 0;\r\n}\r\nstatic int ccp2_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct isp_ccp2_device *ccp2 = v4l2_get_subdevdata(sd);\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase CCP2_PAD_SINK | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (ccp2->input == CCP2_INPUT_SENSOR)\r\nreturn -EBUSY;\r\nccp2->input = CCP2_INPUT_MEMORY;\r\n} else {\r\nif (ccp2->input == CCP2_INPUT_MEMORY)\r\nccp2->input = CCP2_INPUT_NONE;\r\n}\r\nbreak;\r\ncase CCP2_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (ccp2->input == CCP2_INPUT_MEMORY)\r\nreturn -EBUSY;\r\nccp2->input = CCP2_INPUT_SENSOR;\r\n} else {\r\nif (ccp2->input == CCP2_INPUT_SENSOR)\r\nccp2->input = CCP2_INPUT_NONE;\r\n} break;\r\ncase CCP2_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED)\r\nccp2->output = CCP2_OUTPUT_CCDC;\r\nelse\r\nccp2->output = CCP2_OUTPUT_NONE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_ccp2_unregister_entities(struct isp_ccp2_device *ccp2)\r\n{\r\nv4l2_device_unregister_subdev(&ccp2->subdev);\r\nomap3isp_video_unregister(&ccp2->video_in);\r\n}\r\nint omap3isp_ccp2_register_entities(struct isp_ccp2_device *ccp2,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &ccp2->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&ccp2->video_in, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap3isp_ccp2_unregister_entities(ccp2);\r\nreturn ret;\r\n}\r\nstatic int ccp2_init_entities(struct isp_ccp2_device *ccp2)\r\n{\r\nstruct v4l2_subdev *sd = &ccp2->subdev;\r\nstruct media_pad *pads = ccp2->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nccp2->input = CCP2_INPUT_NONE;\r\nccp2->output = CCP2_OUTPUT_NONE;\r\nv4l2_subdev_init(sd, &ccp2_sd_ops);\r\nsd->internal_ops = &ccp2_sd_internal_ops;\r\nstrlcpy(sd->name, "OMAP3 ISP CCP2", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, ccp2);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[CCP2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[CCP2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nme->ops = &ccp2_media_ops;\r\nret = media_entity_init(me, CCP2_PADS_NUM, pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nccp2_init_formats(sd, NULL);\r\nccp2->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nccp2->video_in.bpl_alignment = 32;\r\nccp2->video_in.bpl_max = 0xffffffe0;\r\nccp2->video_in.isp = to_isp_device(ccp2);\r\nccp2->video_in.ops = &ccp2_video_ops;\r\nccp2->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 3;\r\nret = omap3isp_video_init(&ccp2->video_in, "CCP2");\r\nif (ret < 0)\r\ngoto error_video;\r\nret = media_entity_create_link(&ccp2->video_in.video.entity, 0,\r\n&ccp2->subdev.entity, CCP2_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_video_cleanup(&ccp2->video_in);\r\nerror_video:\r\nmedia_entity_cleanup(&ccp2->subdev.entity);\r\nreturn ret;\r\n}\r\nint omap3isp_ccp2_init(struct isp_device *isp)\r\n{\r\nstruct isp_ccp2_device *ccp2 = &isp->isp_ccp2;\r\nint ret;\r\ninit_waitqueue_head(&ccp2->wait);\r\nif (isp->revision == ISP_REVISION_2_0) {\r\nccp2->vdds_csib = regulator_get(isp->dev, "vdds_csib");\r\nif (IS_ERR(ccp2->vdds_csib)) {\r\ndev_dbg(isp->dev,\r\n"Could not get regulator vdds_csib\n");\r\nccp2->vdds_csib = NULL;\r\n}\r\n} else if (isp->revision == ISP_REVISION_15_0) {\r\nccp2->phy = &isp->isp_csiphy1;\r\n}\r\nret = ccp2_init_entities(ccp2);\r\nif (ret < 0) {\r\nregulator_put(ccp2->vdds_csib);\r\nreturn ret;\r\n}\r\nccp2_reset(ccp2);\r\nreturn 0;\r\n}\r\nvoid omap3isp_ccp2_cleanup(struct isp_device *isp)\r\n{\r\nstruct isp_ccp2_device *ccp2 = &isp->isp_ccp2;\r\nomap3isp_video_cleanup(&ccp2->video_in);\r\nmedia_entity_cleanup(&ccp2->subdev.entity);\r\nregulator_put(ccp2->vdds_csib);\r\n}
