static struct dst_entry *__xfrm4_dst_lookup(struct net *net, struct flowi4 *fl4,\r\nint tos,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr)\r\n{\r\nstruct rtable *rt;\r\nmemset(fl4, 0, sizeof(*fl4));\r\nfl4->daddr = daddr->a4;\r\nfl4->flowi4_tos = tos;\r\nif (saddr)\r\nfl4->saddr = saddr->a4;\r\nrt = __ip_route_output_key(net, fl4);\r\nif (!IS_ERR(rt))\r\nreturn &rt->dst;\r\nreturn ERR_CAST(rt);\r\n}\r\nstatic struct dst_entry *xfrm4_dst_lookup(struct net *net, int tos,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr)\r\n{\r\nstruct flowi4 fl4;\r\nreturn __xfrm4_dst_lookup(net, &fl4, tos, saddr, daddr);\r\n}\r\nstatic int xfrm4_get_saddr(struct net *net,\r\nxfrm_address_t *saddr, xfrm_address_t *daddr)\r\n{\r\nstruct dst_entry *dst;\r\nstruct flowi4 fl4;\r\ndst = __xfrm4_dst_lookup(net, &fl4, 0, NULL, daddr);\r\nif (IS_ERR(dst))\r\nreturn -EHOSTUNREACH;\r\nsaddr->a4 = fl4.saddr;\r\ndst_release(dst);\r\nreturn 0;\r\n}\r\nstatic int xfrm4_get_tos(const struct flowi *fl)\r\n{\r\nreturn IPTOS_RT_MASK & fl->u.ip4.flowi4_tos;\r\n}\r\nstatic int xfrm4_init_path(struct xfrm_dst *path, struct dst_entry *dst,\r\nint nfheader_len)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xfrm4_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\r\nconst struct flowi *fl)\r\n{\r\nstruct rtable *rt = (struct rtable *)xdst->route;\r\nconst struct flowi4 *fl4 = &fl->u.ip4;\r\nxdst->u.rt.rt_iif = fl4->flowi4_iif;\r\nxdst->u.dst.dev = dev;\r\ndev_hold(dev);\r\nxdst->u.rt.rt_is_input = rt->rt_is_input;\r\nxdst->u.rt.rt_flags = rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST |\r\nRTCF_LOCAL);\r\nxdst->u.rt.rt_type = rt->rt_type;\r\nxdst->u.rt.rt_gateway = rt->rt_gateway;\r\nxdst->u.rt.rt_uses_gateway = rt->rt_uses_gateway;\r\nxdst->u.rt.rt_pmtu = rt->rt_pmtu;\r\nINIT_LIST_HEAD(&xdst->u.rt.rt_uncached);\r\nreturn 0;\r\n}\r\nstatic void\r\n_decode_session4(struct sk_buff *skb, struct flowi *fl, int reverse)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nu8 *xprth = skb_network_header(skb) + iph->ihl * 4;\r\nstruct flowi4 *fl4 = &fl->u.ip4;\r\nmemset(fl4, 0, sizeof(struct flowi4));\r\nfl4->flowi4_mark = skb->mark;\r\nif (!ip_is_fragment(iph)) {\r\nswitch (iph->protocol) {\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_SCTP:\r\ncase IPPROTO_DCCP:\r\nif (xprth + 4 < skb->data ||\r\npskb_may_pull(skb, xprth + 4 - skb->data)) {\r\n__be16 *ports = (__be16 *)xprth;\r\nfl4->fl4_sport = ports[!!reverse];\r\nfl4->fl4_dport = ports[!reverse];\r\n}\r\nbreak;\r\ncase IPPROTO_ICMP:\r\nif (pskb_may_pull(skb, xprth + 2 - skb->data)) {\r\nu8 *icmp = xprth;\r\nfl4->fl4_icmp_type = icmp[0];\r\nfl4->fl4_icmp_code = icmp[1];\r\n}\r\nbreak;\r\ncase IPPROTO_ESP:\r\nif (pskb_may_pull(skb, xprth + 4 - skb->data)) {\r\n__be32 *ehdr = (__be32 *)xprth;\r\nfl4->fl4_ipsec_spi = ehdr[0];\r\n}\r\nbreak;\r\ncase IPPROTO_AH:\r\nif (pskb_may_pull(skb, xprth + 8 - skb->data)) {\r\n__be32 *ah_hdr = (__be32 *)xprth;\r\nfl4->fl4_ipsec_spi = ah_hdr[1];\r\n}\r\nbreak;\r\ncase IPPROTO_COMP:\r\nif (pskb_may_pull(skb, xprth + 4 - skb->data)) {\r\n__be16 *ipcomp_hdr = (__be16 *)xprth;\r\nfl4->fl4_ipsec_spi = htonl(ntohs(ipcomp_hdr[1]));\r\n}\r\nbreak;\r\ncase IPPROTO_GRE:\r\nif (pskb_may_pull(skb, xprth + 12 - skb->data)) {\r\n__be16 *greflags = (__be16 *)xprth;\r\n__be32 *gre_hdr = (__be32 *)xprth;\r\nif (greflags[0] & GRE_KEY) {\r\nif (greflags[0] & GRE_CSUM)\r\ngre_hdr++;\r\nfl4->fl4_gre_key = gre_hdr[1];\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nfl4->fl4_ipsec_spi = 0;\r\nbreak;\r\n}\r\n}\r\nfl4->flowi4_proto = iph->protocol;\r\nfl4->daddr = reverse ? iph->saddr : iph->daddr;\r\nfl4->saddr = reverse ? iph->daddr : iph->saddr;\r\nfl4->flowi4_tos = iph->tos;\r\n}\r\nstatic inline int xfrm4_garbage_collect(struct dst_ops *ops)\r\n{\r\nstruct net *net = container_of(ops, struct net, xfrm.xfrm4_dst_ops);\r\nxfrm4_policy_afinfo.garbage_collect(net);\r\nreturn (dst_entries_get_slow(ops) > ops->gc_thresh * 2);\r\n}\r\nstatic void xfrm4_update_pmtu(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb, u32 mtu)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->update_pmtu(path, sk, skb, mtu);\r\n}\r\nstatic void xfrm4_redirect(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->redirect(path, sk, skb);\r\n}\r\nstatic void xfrm4_dst_destroy(struct dst_entry *dst)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\ndst_destroy_metrics_generic(dst);\r\nxfrm_dst_destroy(xdst);\r\n}\r\nstatic void xfrm4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\r\nint unregister)\r\n{\r\nif (!unregister)\r\nreturn;\r\nxfrm_dst_ifdown(dst, dev);\r\n}\r\nstatic void __init xfrm4_policy_init(void)\r\n{\r\nxfrm_policy_register_afinfo(&xfrm4_policy_afinfo);\r\n}\r\nstatic void __exit xfrm4_policy_fini(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (sysctl_hdr)\r\nunregister_net_sysctl_table(sysctl_hdr);\r\n#endif\r\nxfrm_policy_unregister_afinfo(&xfrm4_policy_afinfo);\r\n}\r\nvoid __init xfrm4_init(void)\r\n{\r\ndst_entries_init(&xfrm4_dst_ops);\r\nxfrm4_state_init();\r\nxfrm4_policy_init();\r\n#ifdef CONFIG_SYSCTL\r\nsysctl_hdr = register_net_sysctl(&init_net, "net/ipv4",\r\nxfrm4_policy_table);\r\n#endif\r\n}
