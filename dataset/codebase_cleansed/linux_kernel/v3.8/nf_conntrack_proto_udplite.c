static inline struct udplite_net *udplite_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, udplite_net_id);\r\n}\r\nstatic bool udplite_pkt_to_tuple(const struct sk_buff *skb,\r\nunsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct udphdr *hp;\r\nstruct udphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->src.u.udp.port = hp->source;\r\ntuple->dst.u.udp.port = hp->dest;\r\nreturn true;\r\n}\r\nstatic bool udplite_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.udp.port = orig->dst.u.udp.port;\r\ntuple->dst.u.udp.port = orig->src.u.udp.port;\r\nreturn true;\r\n}\r\nstatic int udplite_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.udp.port),\r\nntohs(tuple->dst.u.udp.port));\r\n}\r\nstatic unsigned int *udplite_get_timeouts(struct net *net)\r\n{\r\nreturn udplite_pernet(net)->timeouts;\r\n}\r\nstatic int udplite_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nunsigned int *timeouts)\r\n{\r\nif (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nnf_ct_refresh_acct(ct, ctinfo, skb,\r\ntimeouts[UDPLITE_CT_REPLIED]);\r\nif (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n} else {\r\nnf_ct_refresh_acct(ct, ctinfo, skb,\r\ntimeouts[UDPLITE_CT_UNREPLIED]);\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool udplite_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\nreturn true;\r\n}\r\nstatic int udplite_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nunsigned int udplen = skb->len - dataoff;\r\nconst struct udphdr *hdr;\r\nstruct udphdr _hdr;\r\nunsigned int cscov;\r\nhdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hdr == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\ncscov = ntohs(hdr->len);\r\nif (cscov == 0)\r\ncscov = udplen;\r\nelse if (cscov < sizeof(*hdr) || cscov > udplen) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: invalid checksum coverage ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (!hdr->check) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: checksum missing ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_UDP,\r\npf)) {\r\nif (LOG_INVALID(net, IPPROTO_UDPLITE))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_udplite: bad UDPLite checksum ");\r\nreturn -NF_ACCEPT;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int udplite_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nunsigned int *timeouts = data;\r\nstruct udplite_net *un = udplite_pernet(net);\r\ntimeouts[UDPLITE_CT_UNREPLIED] = un->timeouts[UDPLITE_CT_UNREPLIED];\r\ntimeouts[UDPLITE_CT_REPLIED] = un->timeouts[UDPLITE_CT_REPLIED];\r\nif (tb[CTA_TIMEOUT_UDPLITE_UNREPLIED]) {\r\ntimeouts[UDPLITE_CT_UNREPLIED] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_UDPLITE_UNREPLIED])) * HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_UDPLITE_REPLIED]) {\r\ntimeouts[UDPLITE_CT_REPLIED] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_UDPLITE_REPLIED])) * HZ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nudplite_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeouts = data;\r\nif (nla_put_be32(skb, CTA_TIMEOUT_UDPLITE_UNREPLIED,\r\nhtonl(timeouts[UDPLITE_CT_UNREPLIED] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_UDPLITE_REPLIED,\r\nhtonl(timeouts[UDPLITE_CT_REPLIED] / HZ)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int udplite_kmemdup_sysctl_table(struct nf_proto_net *pn,\r\nstruct udplite_net *un)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (pn->ctl_table)\r\nreturn 0;\r\npn->ctl_table = kmemdup(udplite_sysctl_table,\r\nsizeof(udplite_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_table)\r\nreturn -ENOMEM;\r\npn->ctl_table[0].data = &un->timeouts[UDPLITE_CT_UNREPLIED];\r\npn->ctl_table[1].data = &un->timeouts[UDPLITE_CT_REPLIED];\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int udplite_init_net(struct net *net, u_int16_t proto)\r\n{\r\nstruct udplite_net *un = udplite_pernet(net);\r\nstruct nf_proto_net *pn = &un->pn;\r\nif (!pn->users) {\r\nint i;\r\nfor (i = 0 ; i < UDPLITE_CT_MAX; i++)\r\nun->timeouts[i] = udplite_timeouts[i];\r\n}\r\nreturn udplite_kmemdup_sysctl_table(pn, un);\r\n}\r\nstatic int udplite_net_init(struct net *net)\r\n{\r\nint ret = 0;\r\nret = nf_conntrack_l4proto_register(net,\r\n&nf_conntrack_l4proto_udplite4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_l4proto_udplite4 :protocol register failed.\n");\r\ngoto out;\r\n}\r\nret = nf_conntrack_l4proto_register(net,\r\n&nf_conntrack_l4proto_udplite6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_l4proto_udplite4 :protocol register failed.\n");\r\ngoto cleanup_udplite4;\r\n}\r\nreturn 0;\r\ncleanup_udplite4:\r\nnf_conntrack_l4proto_unregister(net, &nf_conntrack_l4proto_udplite4);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void udplite_net_exit(struct net *net)\r\n{\r\nnf_conntrack_l4proto_unregister(net, &nf_conntrack_l4proto_udplite6);\r\nnf_conntrack_l4proto_unregister(net, &nf_conntrack_l4proto_udplite4);\r\n}\r\nstatic int __init nf_conntrack_proto_udplite_init(void)\r\n{\r\nreturn register_pernet_subsys(&udplite_net_ops);\r\n}\r\nstatic void __exit nf_conntrack_proto_udplite_exit(void)\r\n{\r\nunregister_pernet_subsys(&udplite_net_ops);\r\n}
