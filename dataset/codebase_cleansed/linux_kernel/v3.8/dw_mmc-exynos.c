static int dw_mci_exynos_priv_init(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv;\r\nint idx;\r\npriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(host->dev, "mem alloc failed for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(exynos_compat); idx++) {\r\nif (of_device_is_compatible(host->dev->of_node,\r\nexynos_compat[idx].compatible))\r\npriv->ctrl_type = exynos_compat[idx].ctrl_type;\r\n}\r\nhost->priv = priv;\r\nreturn 0;\r\n}\r\nstatic int dw_mci_exynos_setup_clock(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS5250)\r\nhost->bus_hz /= (priv->ciu_div + 1);\r\nelse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4412)\r\nhost->bus_hz /= EXYNOS4412_FIXED_CIU_CLK_DIV;\r\nelse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4210)\r\nhost->bus_hz /= EXYNOS4210_FIXED_CIU_CLK_DIV;\r\nreturn 0;\r\n}\r\nstatic void dw_mci_exynos_prepare_command(struct dw_mci *host, u32 *cmdr)\r\n{\r\nif (SDMMC_CLKSEL_GET_DRV_WD3(mci_readl(host, CLKSEL)))\r\n*cmdr |= SDMMC_CMD_USE_HOLD_REG;\r\n}\r\nstatic void dw_mci_exynos_set_ios(struct dw_mci *host, struct mmc_ios *ios)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (ios->timing == MMC_TIMING_UHS_DDR50)\r\nmci_writel(host, CLKSEL, priv->ddr_timing);\r\nelse\r\nmci_writel(host, CLKSEL, priv->sdr_timing);\r\n}\r\nstatic int dw_mci_exynos_parse_dt(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nstruct device_node *np = host->dev->of_node;\r\nu32 timing[2];\r\nu32 div = 0;\r\nint ret;\r\nof_property_read_u32(np, "samsung,dw-mshc-ciu-div", &div);\r\npriv->ciu_div = div;\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-sdr-timing", timing, 2);\r\nif (ret)\r\nreturn ret;\r\npriv->sdr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-ddr-timing", timing, 2);\r\nif (ret)\r\nreturn ret;\r\npriv->ddr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\r\nreturn 0;\r\n}\r\nstatic int dw_mci_exynos_setup_bus(struct dw_mci *host,\r\nstruct device_node *slot_np, u8 bus_width)\r\n{\r\nint idx, gpio, ret;\r\nif (!slot_np)\r\nreturn -EINVAL;\r\nfor (idx = 0; idx < NUM_PINS(bus_width); idx++) {\r\ngpio = of_get_gpio(slot_np, idx);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(host->dev, "invalid gpio: %d\n", gpio);\r\nreturn -EINVAL;\r\n}\r\nret = devm_gpio_request(host->dev, gpio, "dw-mci-bus");\r\nif (ret) {\r\ndev_err(host->dev, "gpio [%d] request failed\n", gpio);\r\nreturn -EBUSY;\r\n}\r\n}\r\ngpio = of_get_named_gpio(slot_np, "wp-gpios", 0);\r\nif (gpio_is_valid(gpio)) {\r\nif (devm_gpio_request(host->dev, gpio, "dw-mci-wp"))\r\ndev_info(host->dev, "gpio [%d] request failed\n",\r\ngpio);\r\n} else {\r\ndev_info(host->dev, "wp gpio not available");\r\nhost->pdata->quirks |= DW_MCI_QUIRK_NO_WRITE_PROTECT;\r\n}\r\nif (host->pdata->quirks & DW_MCI_QUIRK_BROKEN_CARD_DETECTION)\r\nreturn 0;\r\ngpio = of_get_named_gpio(slot_np, "samsung,cd-pinmux-gpio", 0);\r\nif (gpio_is_valid(gpio)) {\r\nif (devm_gpio_request(host->dev, gpio, "dw-mci-cd"))\r\ndev_err(host->dev, "gpio [%d] request failed\n", gpio);\r\n} else {\r\ndev_info(host->dev, "cd gpio not available");\r\n}\r\nreturn 0;\r\n}\r\nint dw_mci_exynos_probe(struct platform_device *pdev)\r\n{\r\nconst struct dw_mci_drv_data *drv_data;\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(dw_mci_exynos_match, pdev->dev.of_node);\r\ndrv_data = match->data;\r\nreturn dw_mci_pltfm_register(pdev, drv_data);\r\n}
