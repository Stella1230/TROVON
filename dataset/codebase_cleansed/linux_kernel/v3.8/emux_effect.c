static void\r\neffect_set_byte(unsigned char *valp, struct snd_midi_channel *chan, int type)\r\n{\r\nshort effect;\r\nstruct snd_emux_effect_table *fx = chan->private;\r\neffect = fx->val[type];\r\nif (fx->flag[type] == EMUX_FX_FLAG_ADD) {\r\nif (parm_defs[type].type & PARM_IS_SIGNED)\r\neffect += *(char*)valp;\r\nelse\r\neffect += *valp;\r\n}\r\nif (effect < parm_defs[type].low)\r\neffect = parm_defs[type].low;\r\nelse if (effect > parm_defs[type].high)\r\neffect = parm_defs[type].high;\r\n*valp = (unsigned char)effect;\r\n}\r\nstatic void\r\neffect_set_word(unsigned short *valp, struct snd_midi_channel *chan, int type)\r\n{\r\nint effect;\r\nstruct snd_emux_effect_table *fx = chan->private;\r\neffect = *(unsigned short*)&fx->val[type];\r\nif (fx->flag[type] == EMUX_FX_FLAG_ADD)\r\neffect += *valp;\r\nif (effect < parm_defs[type].low)\r\neffect = parm_defs[type].low;\r\nelse if (effect > parm_defs[type].high)\r\neffect = parm_defs[type].high;\r\n*valp = (unsigned short)effect;\r\n}\r\nstatic int\r\neffect_get_offset(struct snd_midi_channel *chan, int lo, int hi, int mode)\r\n{\r\nint addr = 0;\r\nstruct snd_emux_effect_table *fx = chan->private;\r\nif (fx->flag[hi])\r\naddr = (short)fx->val[hi];\r\naddr = addr << 15;\r\nif (fx->flag[lo])\r\naddr += (short)fx->val[lo];\r\nif (!(mode & SNDRV_SFNT_SAMPLE_8BITS))\r\naddr /= 2;\r\nreturn addr;\r\n}\r\nvoid\r\nsnd_emux_send_effect_oss(struct snd_emux_port *port,\r\nstruct snd_midi_channel *chan, int type, int val)\r\n{\r\nint mode;\r\nif (type & 0x40)\r\nmode = EMUX_FX_FLAG_OFF;\r\nelse if (type & 0x80)\r\nmode = EMUX_FX_FLAG_ADD;\r\nelse\r\nmode = EMUX_FX_FLAG_SET;\r\ntype &= 0x3f;\r\nsnd_emux_send_effect(port, chan, type, val, mode);\r\n}\r\nvoid\r\nsnd_emux_send_effect(struct snd_emux_port *port, struct snd_midi_channel *chan,\r\nint type, int val, int mode)\r\n{\r\nint i;\r\nint offset;\r\nunsigned char *srcp, *origp;\r\nstruct snd_emux *emu;\r\nstruct snd_emux_effect_table *fx;\r\nunsigned long flags;\r\nemu = port->emu;\r\nfx = chan->private;\r\nif (emu == NULL || fx == NULL)\r\nreturn;\r\nif (type < 0 || type >= EMUX_NUM_EFFECTS)\r\nreturn;\r\nfx->val[type] = val;\r\nfx->flag[type] = mode;\r\nif (! parm_defs[type].update || (offset = parm_defs[type].offset) < 0)\r\nreturn;\r\n#ifdef SNDRV_LITTLE_ENDIAN\r\nif (parm_defs[type].type & PARM_IS_ALIGN_HI)\r\noffset++;\r\n#else\r\nif (parm_defs[type].type & PARM_IS_ALIGN_LO)\r\noffset++;\r\n#endif\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nstruct snd_emux_voice *vp = &emu->voices[i];\r\nif (!STATE_IS_PLAYING(vp->state) || vp->chan != chan)\r\ncontinue;\r\nsrcp = (unsigned char*)&vp->reg.parm + offset;\r\norigp = (unsigned char*)&vp->zone->v.parm + offset;\r\nif (parm_defs[i].type & PARM_IS_BYTE) {\r\n*srcp = *origp;\r\neffect_set_byte(srcp, chan, type);\r\n} else {\r\n*(unsigned short*)srcp = *(unsigned short*)origp;\r\neffect_set_word((unsigned short*)srcp, chan, type);\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\nsnd_emux_update_channel(port, chan, parm_defs[type].update);\r\n}\r\nvoid\r\nsnd_emux_setup_effect(struct snd_emux_voice *vp)\r\n{\r\nstruct snd_midi_channel *chan = vp->chan;\r\nstruct snd_emux_effect_table *fx;\r\nunsigned char *srcp;\r\nint i;\r\nif (! (fx = chan->private))\r\nreturn;\r\nfor (i = 0; i < EMUX_FX_END; i++) {\r\nint offset;\r\nif (! fx->flag[i] || (offset = parm_defs[i].offset) < 0)\r\ncontinue;\r\n#ifdef SNDRV_LITTLE_ENDIAN\r\nif (parm_defs[i].type & PARM_IS_ALIGN_HI)\r\noffset++;\r\n#else\r\nif (parm_defs[i].type & PARM_IS_ALIGN_LO)\r\noffset++;\r\n#endif\r\nsrcp = (unsigned char*)&vp->reg.parm + offset;\r\nif (parm_defs[i].type & PARM_IS_BYTE)\r\neffect_set_byte(srcp, chan, i);\r\nelse\r\neffect_set_word((unsigned short*)srcp, chan, i);\r\n}\r\nvp->reg.start += effect_get_offset(chan, EMUX_FX_SAMPLE_START,\r\nEMUX_FX_COARSE_SAMPLE_START,\r\nvp->reg.sample_mode);\r\nvp->reg.loopstart += effect_get_offset(chan, EMUX_FX_LOOP_START,\r\nEMUX_FX_COARSE_LOOP_START,\r\nvp->reg.sample_mode);\r\nvp->reg.loopend += effect_get_offset(chan, EMUX_FX_LOOP_END,\r\nEMUX_FX_COARSE_LOOP_END,\r\nvp->reg.sample_mode);\r\n}\r\nvoid\r\nsnd_emux_create_effect(struct snd_emux_port *p)\r\n{\r\nint i;\r\np->effect = kcalloc(p->chset.max_channels,\r\nsizeof(struct snd_emux_effect_table), GFP_KERNEL);\r\nif (p->effect) {\r\nfor (i = 0; i < p->chset.max_channels; i++)\r\np->chset.channels[i].private = p->effect + i;\r\n} else {\r\nfor (i = 0; i < p->chset.max_channels; i++)\r\np->chset.channels[i].private = NULL;\r\n}\r\n}\r\nvoid\r\nsnd_emux_delete_effect(struct snd_emux_port *p)\r\n{\r\nkfree(p->effect);\r\np->effect = NULL;\r\n}\r\nvoid\r\nsnd_emux_clear_effect(struct snd_emux_port *p)\r\n{\r\nif (p->effect) {\r\nmemset(p->effect, 0, sizeof(struct snd_emux_effect_table) *\r\np->chset.max_channels);\r\n}\r\n}
