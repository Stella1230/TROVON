static inline int temp8_from_reg(struct lm63_data *data, int nr)\r\n{\r\nif (data->remote_unsigned)\r\nreturn TEMP8_FROM_REG((u8)data->temp8[nr]);\r\nreturn TEMP8_FROM_REG(data->temp8[nr]);\r\n}\r\nstatic inline int lut_temp_from_reg(struct lm63_data *data, int nr)\r\n{\r\nreturn data->temp8[nr] * (data->lut_temp_highres ? 500 : 1000);\r\n}\r\nstatic inline int lut_temp_to_reg(struct lm63_data *data, long val)\r\n{\r\nval -= data->temp2_offset;\r\nif (data->lut_temp_highres)\r\nreturn DIV_ROUND_CLOSEST(SENSORS_LIMIT(val, 0, 127500), 500);\r\nelse\r\nreturn DIV_ROUND_CLOSEST(SENSORS_LIMIT(val, 0, 127000), 1000);\r\n}\r\nstatic void lm63_update_lut(struct i2c_client *client)\r\n{\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nint i;\r\nif (time_after(jiffies, data->lut_last_updated + 5 * HZ) ||\r\n!data->lut_valid) {\r\nfor (i = 0; i < data->lut_size; i++) {\r\ndata->pwm1[1 + i] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LUT_PWM(i));\r\ndata->temp8[3 + i] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LUT_TEMP(i));\r\n}\r\ndata->lut_temp_hyst = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LUT_TEMP_HYST);\r\ndata->lut_last_updated = jiffies;\r\ndata->lut_valid = 1;\r\n}\r\n}\r\nstatic struct lm63_data *lm63_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long next_update;\r\nmutex_lock(&data->update_lock);\r\nnext_update = data->last_updated\r\n+ msecs_to_jiffies(data->update_interval) + 1;\r\nif (time_after(jiffies, next_update) || !data->valid) {\r\nif (data->config & 0x04) {\r\ndata->fan[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_COUNT_LSB) & 0xFC;\r\ndata->fan[0] |= i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_COUNT_MSB) << 8;\r\ndata->fan[1] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_LIMIT_LSB) & 0xFC)\r\n| (i2c_smbus_read_byte_data(client,\r\nLM63_REG_TACH_LIMIT_MSB) << 8);\r\n}\r\ndata->pwm1_freq = i2c_smbus_read_byte_data(client,\r\nLM63_REG_PWM_FREQ);\r\nif (data->pwm1_freq == 0)\r\ndata->pwm1_freq = 1;\r\ndata->pwm1[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_PWM_VALUE);\r\ndata->temp8[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LOCAL_TEMP);\r\ndata->temp8[1] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_LOCAL_HIGH);\r\ndata->temp11[0] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TEMP_MSB) << 8;\r\ndata->temp11[0] |= i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TEMP_LSB);\r\ndata->temp11[1] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_LOW_MSB) << 8)\r\n| i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_LOW_LSB);\r\ndata->temp11[2] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_HIGH_MSB) << 8)\r\n| i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_HIGH_LSB);\r\ndata->temp11[3] = (i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_OFFSET_MSB) << 8)\r\n| i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_OFFSET_LSB);\r\nif (data->kind == lm96163)\r\ndata->temp11u = (i2c_smbus_read_byte_data(client,\r\nLM96163_REG_REMOTE_TEMP_U_MSB) << 8)\r\n| i2c_smbus_read_byte_data(client,\r\nLM96163_REG_REMOTE_TEMP_U_LSB);\r\ndata->temp8[2] = i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TCRIT);\r\ndata->temp2_crit_hyst = i2c_smbus_read_byte_data(client,\r\nLM63_REG_REMOTE_TCRIT_HYST);\r\ndata->alarms = i2c_smbus_read_byte_data(client,\r\nLM63_REG_ALERT_STATUS) & 0x7F;\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nlm63_update_lut(client);\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int lm63_lut_looks_bad(struct i2c_client *client)\r\n{\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nlm63_update_lut(client);\r\nfor (i = 1; i < data->lut_size; i++) {\r\nif (data->pwm1[1 + i - 1] > data->pwm1[1 + i]\r\n|| data->temp8[3 + i - 1] > data->temp8[3 + i]) {\r\ndev_warn(&client->dev,\r\n"Lookup table doesn't look sane (check entries %d and %d)\n",\r\ni, i + 1);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn i == data->lut_size ? 0 : 1;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[attr->index]));\r\n}\r\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan[1] = FAN_TO_REG(val);\r\ni2c_smbus_write_byte_data(client, LM63_REG_TACH_LIMIT_LSB,\r\ndata->fan[1] & 0xFF);\r\ni2c_smbus_write_byte_data(client, LM63_REG_TACH_LIMIT_MSB,\r\ndata->fan[1] >> 8);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm1(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nint nr = attr->index;\r\nint pwm;\r\nif (data->pwm_highres)\r\npwm = data->pwm1[nr];\r\nelse\r\npwm = data->pwm1[nr] >= 2 * data->pwm1_freq ?\r\n255 : (data->pwm1[nr] * 255 + data->pwm1_freq) /\r\n(2 * data->pwm1_freq);\r\nreturn sprintf(buf, "%d\n", pwm);\r\n}\r\nstatic ssize_t set_pwm1(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nu8 reg;\r\nif (!(data->config_fan & 0x20))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nreg = nr ? LM63_REG_LUT_PWM(nr - 1) : LM63_REG_PWM_VALUE;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm1[nr] = data->pwm_highres ? val :\r\n(val * data->pwm1_freq * 2 + 127) / 255;\r\ni2c_smbus_write_byte_data(client, reg, data->pwm1[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm1_enable(struct device *dev,\r\nstruct device_attribute *dummy, char *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->config_fan & 0x20 ? 1 : 2);\r\n}\r\nstatic ssize_t set_pwm1_enable(struct device *dev,\r\nstruct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val < 1 || val > 2)\r\nreturn -EINVAL;\r\nif (val == 2 && lm63_lut_looks_bad(client))\r\nreturn -EPERM;\r\nmutex_lock(&data->update_lock);\r\ndata->config_fan = i2c_smbus_read_byte_data(client,\r\nLM63_REG_CONFIG_FAN);\r\nif (val == 1)\r\ndata->config_fan |= 0x20;\r\nelse\r\ndata->config_fan &= ~0x20;\r\ni2c_smbus_write_byte_data(client, LM63_REG_CONFIG_FAN,\r\ndata->config_fan);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_local_temp8(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP8_FROM_REG(data->temp8[attr->index]));\r\n}\r\nstatic ssize_t show_remote_temp8(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", temp8_from_reg(data, attr->index)\r\n+ data->temp2_offset);\r\n}\r\nstatic ssize_t show_lut_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", lut_temp_from_reg(data, attr->index)\r\n+ data->temp2_offset);\r\n}\r\nstatic ssize_t set_temp8(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nint temp;\r\nu8 reg;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nswitch (nr) {\r\ncase 2:\r\nreg = LM63_REG_REMOTE_TCRIT;\r\nif (data->remote_unsigned)\r\ntemp = TEMP8U_TO_REG(val - data->temp2_offset);\r\nelse\r\ntemp = TEMP8_TO_REG(val - data->temp2_offset);\r\nbreak;\r\ncase 1:\r\nreg = LM63_REG_LOCAL_HIGH;\r\ntemp = TEMP8_TO_REG(val);\r\nbreak;\r\ndefault:\r\nreg = LM63_REG_LUT_TEMP(nr - 3);\r\ntemp = lut_temp_to_reg(data, val);\r\n}\r\ndata->temp8[nr] = temp;\r\ni2c_smbus_write_byte_data(client, reg, temp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp11(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nint nr = attr->index;\r\nint temp;\r\nif (!nr) {\r\nif (data->temp11u)\r\ntemp = TEMP11_FROM_REG(data->temp11u);\r\nelse\r\ntemp = TEMP11_FROM_REG(data->temp11[nr]);\r\n} else {\r\nif (data->remote_unsigned && nr == 2)\r\ntemp = TEMP11_FROM_REG((u16)data->temp11[nr]);\r\nelse\r\ntemp = TEMP11_FROM_REG(data->temp11[nr]);\r\n}\r\nreturn sprintf(buf, "%d\n", temp + data->temp2_offset);\r\n}\r\nstatic ssize_t set_temp11(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstatic const u8 reg[6] = {\r\nLM63_REG_REMOTE_LOW_MSB,\r\nLM63_REG_REMOTE_LOW_LSB,\r\nLM63_REG_REMOTE_HIGH_MSB,\r\nLM63_REG_REMOTE_HIGH_LSB,\r\nLM63_REG_REMOTE_OFFSET_MSB,\r\nLM63_REG_REMOTE_OFFSET_LSB,\r\n};\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nint nr = attr->index;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (data->remote_unsigned && nr == 2)\r\ndata->temp11[nr] = TEMP11U_TO_REG(val - data->temp2_offset);\r\nelse\r\ndata->temp11[nr] = TEMP11_TO_REG(val - data->temp2_offset);\r\ni2c_smbus_write_byte_data(client, reg[(nr - 1) * 2],\r\ndata->temp11[nr] >> 8);\r\ni2c_smbus_write_byte_data(client, reg[(nr - 1) * 2 + 1],\r\ndata->temp11[nr] & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp2_crit_hyst(struct device *dev,\r\nstruct device_attribute *dummy, char *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", temp8_from_reg(data, 2)\r\n+ data->temp2_offset\r\n- TEMP8_FROM_REG(data->temp2_crit_hyst));\r\n}\r\nstatic ssize_t show_lut_temp_hyst(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%d\n", lut_temp_from_reg(data, attr->index)\r\n+ data->temp2_offset\r\n- TEMP8_FROM_REG(data->lut_temp_hyst));\r\n}\r\nstatic ssize_t set_temp2_crit_hyst(struct device *dev,\r\nstruct device_attribute *dummy,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nlong hyst;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nhyst = temp8_from_reg(data, 2) + data->temp2_offset - val;\r\ni2c_smbus_write_byte_data(client, LM63_REG_REMOTE_TCRIT_HYST,\r\nHYST_TO_REG(hyst));\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void lm63_set_convrate(struct i2c_client *client, struct lm63_data *data,\r\nunsigned int interval)\r\n{\r\nint i;\r\nunsigned int update_interval;\r\ninterval <<= 6;\r\nupdate_interval = (1 << (LM63_MAX_CONVRATE + 6)) * 1000\r\n/ data->max_convrate_hz;\r\nfor (i = 0; i < LM63_MAX_CONVRATE; i++, update_interval >>= 1)\r\nif (interval >= update_interval * 3 / 4)\r\nbreak;\r\ni2c_smbus_write_byte_data(client, LM63_REG_CONVRATE, i);\r\ndata->update_interval = UPDATE_INTERVAL(data->max_convrate_hz, i);\r\n}\r\nstatic ssize_t show_update_interval(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm63_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", data->update_interval);\r\n}\r\nstatic ssize_t set_update_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nlm63_set_convrate(client, data, SENSORS_LIMIT(val, 0, 100000));\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_type(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nreturn sprintf(buf, data->trutherm ? "1\n" : "2\n");\r\n}\r\nstatic ssize_t set_type(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint ret;\r\nu8 reg;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val != 1 && val != 2)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->trutherm = val == 1;\r\nreg = i2c_smbus_read_byte_data(client, LM96163_REG_TRUTHERM) & ~0x02;\r\ni2c_smbus_write_byte_data(client, LM96163_REG_TRUTHERM,\r\nreg | (data->trutherm ? 0x02 : 0x00));\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms(struct device *dev, struct device_attribute *dummy,\r\nchar *buf)\r\n{\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct lm63_data *data = lm63_update_device(dev);\r\nint bitnr = attr->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic umode_t lm63_attribute_mode(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nif (attr == &sensor_dev_attr_temp2_crit.dev_attr.attr\r\n&& (data->kind == lm64 ||\r\n(data->kind == lm96163 && (data->config & 0x02))))\r\nreturn attr->mode | S_IWUSR;\r\nreturn attr->mode;\r\n}\r\nstatic int lm63_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nu8 man_id, chip_id, reg_config1, reg_config2;\r\nu8 reg_alert_status, reg_alert_mask;\r\nint address = client->addr;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nman_id = i2c_smbus_read_byte_data(client, LM63_REG_MAN_ID);\r\nchip_id = i2c_smbus_read_byte_data(client, LM63_REG_CHIP_ID);\r\nreg_config1 = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG1);\r\nreg_config2 = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG2);\r\nreg_alert_status = i2c_smbus_read_byte_data(client,\r\nLM63_REG_ALERT_STATUS);\r\nreg_alert_mask = i2c_smbus_read_byte_data(client, LM63_REG_ALERT_MASK);\r\nif (man_id != 0x01\r\n|| (reg_config1 & 0x18) != 0x00\r\n|| (reg_config2 & 0xF8) != 0x00\r\n|| (reg_alert_status & 0x20) != 0x00\r\n|| (reg_alert_mask & 0xA4) != 0xA4) {\r\ndev_dbg(&adapter->dev,\r\n"Unsupported chip (man_id=0x%02X, chip_id=0x%02X)\n",\r\nman_id, chip_id);\r\nreturn -ENODEV;\r\n}\r\nif (chip_id == 0x41 && address == 0x4c)\r\nstrlcpy(info->type, "lm63", I2C_NAME_SIZE);\r\nelse if (chip_id == 0x51 && (address == 0x18 || address == 0x4e))\r\nstrlcpy(info->type, "lm64", I2C_NAME_SIZE);\r\nelse if (chip_id == 0x49 && address == 0x4c)\r\nstrlcpy(info->type, "lm96163", I2C_NAME_SIZE);\r\nelse\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void lm63_init_client(struct i2c_client *client)\r\n{\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nu8 convrate;\r\ndata->config = i2c_smbus_read_byte_data(client, LM63_REG_CONFIG1);\r\ndata->config_fan = i2c_smbus_read_byte_data(client,\r\nLM63_REG_CONFIG_FAN);\r\nif (data->config & 0x40) {\r\ndev_dbg(&client->dev, "Switching to operational mode\n");\r\ndata->config &= 0xA7;\r\ni2c_smbus_write_byte_data(client, LM63_REG_CONFIG1,\r\ndata->config);\r\n}\r\nif (data->kind == lm64)\r\ndata->config |= 0x04;\r\ndata->pwm1_freq = i2c_smbus_read_byte_data(client, LM63_REG_PWM_FREQ);\r\nif (data->pwm1_freq == 0)\r\ndata->pwm1_freq = 1;\r\nswitch (data->kind) {\r\ncase lm63:\r\ncase lm64:\r\ndata->max_convrate_hz = LM63_MAX_CONVRATE_HZ;\r\ndata->lut_size = 8;\r\nbreak;\r\ncase lm96163:\r\ndata->max_convrate_hz = LM96163_MAX_CONVRATE_HZ;\r\ndata->lut_size = 12;\r\ndata->trutherm\r\n= i2c_smbus_read_byte_data(client,\r\nLM96163_REG_TRUTHERM) & 0x02;\r\nbreak;\r\n}\r\nconvrate = i2c_smbus_read_byte_data(client, LM63_REG_CONVRATE);\r\nif (unlikely(convrate > LM63_MAX_CONVRATE))\r\nconvrate = LM63_MAX_CONVRATE;\r\ndata->update_interval = UPDATE_INTERVAL(data->max_convrate_hz,\r\nconvrate);\r\nif (data->kind == lm96163) {\r\nu8 config_enhanced\r\n= i2c_smbus_read_byte_data(client,\r\nLM96163_REG_CONFIG_ENHANCED);\r\nif (config_enhanced & 0x20)\r\ndata->lut_temp_highres = true;\r\nif ((config_enhanced & 0x10)\r\n&& !(data->config_fan & 0x08) && data->pwm1_freq == 8)\r\ndata->pwm_highres = true;\r\nif (config_enhanced & 0x08)\r\ndata->remote_unsigned = true;\r\n}\r\nif (data->kind == lm63)\r\ndev_dbg(&client->dev, "Alert/tach pin configured for %s\n",\r\n(data->config & 0x04) ? "tachometer input" :\r\n"alert output");\r\ndev_dbg(&client->dev, "PWM clock %s kHz, output frequency %u Hz\n",\r\n(data->config_fan & 0x08) ? "1.4" : "360",\r\n((data->config_fan & 0x08) ? 700 : 180000) / data->pwm1_freq);\r\ndev_dbg(&client->dev, "PWM output active %s, %s mode\n",\r\n(data->config_fan & 0x10) ? "low" : "high",\r\n(data->config_fan & 0x20) ? "manual" : "auto");\r\n}\r\nstatic int lm63_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm63_data *data;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct lm63_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->valid = 0;\r\nmutex_init(&data->update_lock);\r\ndata->kind = id->driver_data;\r\nif (data->kind == lm64)\r\ndata->temp2_offset = 16000;\r\nlm63_init_client(client);\r\nerr = sysfs_create_group(&client->dev.kobj, &lm63_group);\r\nif (err)\r\nreturn err;\r\nif (data->config & 0x04) {\r\nerr = sysfs_create_group(&client->dev.kobj, &lm63_group_fan1);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nif (data->kind == lm96163) {\r\nerr = device_create_file(&client->dev, &dev_attr_temp2_type);\r\nif (err)\r\ngoto exit_remove_files;\r\nerr = sysfs_create_group(&client->dev.kobj,\r\n&lm63_group_extra_lut);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group_fan1);\r\nif (data->kind == lm96163) {\r\ndevice_remove_file(&client->dev, &dev_attr_temp2_type);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group_extra_lut);\r\n}\r\nreturn err;\r\n}\r\nstatic int lm63_remove(struct i2c_client *client)\r\n{\r\nstruct lm63_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group_fan1);\r\nif (data->kind == lm96163) {\r\ndevice_remove_file(&client->dev, &dev_attr_temp2_type);\r\nsysfs_remove_group(&client->dev.kobj, &lm63_group_extra_lut);\r\n}\r\nreturn 0;\r\n}
