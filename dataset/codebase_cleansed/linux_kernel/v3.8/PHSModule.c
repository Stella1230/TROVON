int PHSTransmit(struct bcm_mini_adapter *Adapter,\r\nstruct sk_buff **pPacket,\r\nUSHORT Vcid,\r\nB_UINT16 uiClassifierRuleID,\r\nBOOLEAN bHeaderSuppressionEnabled,\r\nUINT *PacketLen,\r\nUCHAR bEthCSSupport)\r\n{\r\nUINT unPHSPktHdrBytesCopied = 0;\r\nUINT unPhsOldHdrSize = 0;\r\nUINT unPHSNewPktHeaderLen = 0;\r\nPUCHAR pucPHSPktHdrInBuf =\r\nAdapter->stPhsTxContextInfo.ucaHdrSuppressionInBuf;\r\nPUCHAR pucPHSPktHdrOutBuf =\r\nAdapter->stPhsTxContextInfo.ucaHdrSuppressionOutBuf;\r\nUINT usPacketType;\r\nUINT BytesToRemove=0;\r\nBOOLEAN bPHSI = 0;\r\nLONG ulPhsStatus = 0;\r\nUINT numBytesCompressed = 0;\r\nstruct sk_buff *newPacket = NULL;\r\nstruct sk_buff *Packet = *pPacket;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL, "In PHSTransmit");\r\nif(!bEthCSSupport)\r\nBytesToRemove=ETH_HLEN;\r\nusPacketType=((struct ethhdr *)(Packet->data))->h_proto;\r\npucPHSPktHdrInBuf = Packet->data + BytesToRemove;\r\nif((*PacketLen - BytesToRemove) < MAX_PHS_LENGTHS)\r\n{\r\nunPHSPktHdrBytesCopied = (*PacketLen - BytesToRemove);\r\n}\r\nelse\r\n{\r\nunPHSPktHdrBytesCopied = MAX_PHS_LENGTHS;\r\n}\r\nif( (unPHSPktHdrBytesCopied > 0 ) &&\r\n(unPHSPktHdrBytesCopied <= MAX_PHS_LENGTHS))\r\n{\r\nif(((usPacketType == ETHERNET_FRAMETYPE_IPV4) ||\r\n(usPacketType == ETHERNET_FRAMETYPE_IPV6)) &&\r\n(bHeaderSuppressionEnabled))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nTrying to PHS Compress Using Classifier rule 0x%X",uiClassifierRuleID);\r\nunPHSNewPktHeaderLen = unPHSPktHdrBytesCopied;\r\nulPhsStatus = PhsCompress(&Adapter->stBCMPhsContext,\r\nVcid,\r\nuiClassifierRuleID,\r\npucPHSPktHdrInBuf,\r\npucPHSPktHdrOutBuf,\r\n&unPhsOldHdrSize,\r\n&unPHSNewPktHeaderLen);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nPHS Old header Size : %d New Header Size %d\n",unPhsOldHdrSize,unPHSNewPktHeaderLen);\r\nif(unPHSNewPktHeaderLen == unPhsOldHdrSize)\r\n{\r\nif( ulPhsStatus == STATUS_PHS_COMPRESSED)\r\nbPHSI = *pucPHSPktHdrOutBuf;\r\nulPhsStatus = STATUS_PHS_NOCOMPRESSION;\r\n}\r\nif( ulPhsStatus == STATUS_PHS_COMPRESSED)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"PHS Sending packet Compressed");\r\nif(skb_cloned(Packet))\r\n{\r\nnewPacket = skb_copy(Packet, GFP_ATOMIC);\r\nif(newPacket == NULL)\r\nreturn STATUS_FAILURE;\r\ndev_kfree_skb(Packet);\r\n*pPacket = Packet = newPacket;\r\npucPHSPktHdrInBuf = Packet->data + BytesToRemove;\r\n}\r\nnumBytesCompressed = unPhsOldHdrSize - (unPHSNewPktHeaderLen+PHSI_LEN);\r\nmemcpy(pucPHSPktHdrInBuf + numBytesCompressed, pucPHSPktHdrOutBuf, unPHSNewPktHeaderLen + PHSI_LEN);\r\nmemcpy(Packet->data + numBytesCompressed, Packet->data, BytesToRemove);\r\nskb_pull(Packet, numBytesCompressed);\r\nreturn STATUS_SUCCESS;\r\n}\r\nelse\r\n{\r\nif(!(skb_headroom(Packet) > 0))\r\n{\r\nif(skb_cow(Packet, 1))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "SKB Cow Failed\n");\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nskb_push(Packet, 1);\r\n*(Packet->data + BytesToRemove) = bPHSI;\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nelse\r\n{\r\nif(!bHeaderSuppressionEnabled)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nHeader Suppression Disabled For SF: No PHS\n");\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PHSReceive(struct bcm_mini_adapter *Adapter,\r\nUSHORT usVcid,\r\nstruct sk_buff *packet,\r\nUINT *punPacketLen,\r\nUCHAR *pucEthernetHdr,\r\nUINT bHeaderSuppressionEnabled)\r\n{\r\nu32 nStandardPktHdrLen = 0;\r\nu32 nTotalsuppressedPktHdrBytes = 0;\r\nint ulPhsStatus = 0;\r\nPUCHAR pucInBuff = NULL ;\r\nUINT TotalBytesAdded = 0;\r\nif(!bHeaderSuppressionEnabled)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"\nPhs Disabled for incoming packet");\r\nreturn ulPhsStatus;\r\n}\r\npucInBuff = packet->data;\r\nnStandardPktHdrLen = packet->len;\r\nulPhsStatus = PhsDeCompress(&Adapter->stBCMPhsContext,\r\nusVcid,\r\npucInBuff,\r\nAdapter->ucaPHSPktRestoreBuf,\r\n&nTotalsuppressedPktHdrBytes,\r\n&nStandardPktHdrLen);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"\nSuppressed PktHdrLen : 0x%x Restored PktHdrLen : 0x%x",\r\nnTotalsuppressedPktHdrBytes,nStandardPktHdrLen);\r\nif(ulPhsStatus != STATUS_PHS_COMPRESSED)\r\n{\r\nskb_pull(packet, 1);\r\nreturn STATUS_SUCCESS;\r\n}\r\nelse\r\n{\r\nTotalBytesAdded = nStandardPktHdrLen - nTotalsuppressedPktHdrBytes - PHSI_LEN;\r\nif(TotalBytesAdded)\r\n{\r\nif(skb_headroom(packet) >= (SKB_RESERVE_ETHERNET_HEADER + TotalBytesAdded))\r\nskb_push(packet, TotalBytesAdded);\r\nelse\r\n{\r\nif(skb_cow(packet, skb_headroom(packet) + TotalBytesAdded))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "cow failed in receive\n");\r\nreturn STATUS_FAILURE;\r\n}\r\nskb_push(packet, TotalBytesAdded);\r\n}\r\n}\r\nmemcpy(packet->data, Adapter->ucaPHSPktRestoreBuf, nStandardPktHdrLen);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid DumpFullPacket(UCHAR *pBuf,UINT nPktLen)\r\n{\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL,"Dumping Data Packet");\r\nBCM_DEBUG_PRINT_BUFFER(Adapter,DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL,pBuf,nPktLen);\r\n}\r\nint phs_init(PPHS_DEVICE_EXTENSION pPhsdeviceExtension, struct bcm_mini_adapter *Adapter)\r\n{\r\nint i;\r\nS_SERVICEFLOW_TABLE *pstServiceFlowTable;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nPHS:phs_init function ");\r\nif(pPhsdeviceExtension->pstServiceFlowPhsRulesTable)\r\nreturn -EINVAL;\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable =\r\nkzalloc(sizeof(S_SERVICEFLOW_TABLE), GFP_KERNEL);\r\nif(!pPhsdeviceExtension->pstServiceFlowPhsRulesTable)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation ServiceFlowPhsRulesTable failed");\r\nreturn -ENOMEM;\r\n}\r\npstServiceFlowTable = pPhsdeviceExtension->pstServiceFlowPhsRulesTable;\r\nfor(i=0;i<MAX_SERVICEFLOWS;i++)\r\n{\r\nS_SERVICEFLOW_ENTRY sServiceFlow = pstServiceFlowTable->stSFList[i];\r\nsServiceFlow.pstClassifierTable = kzalloc(sizeof(S_CLASSIFIER_TABLE), GFP_KERNEL);\r\nif(!sServiceFlow.pstClassifierTable)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation failed");\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->\r\npstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\npPhsdeviceExtension->CompressedTxBuffer = kmalloc(PHS_BUFFER_SIZE, GFP_KERNEL);\r\nif(pPhsdeviceExtension->CompressedTxBuffer == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation failed");\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\npPhsdeviceExtension->UnCompressedRxBuffer = kmalloc(PHS_BUFFER_SIZE, GFP_KERNEL);\r\nif(pPhsdeviceExtension->UnCompressedRxBuffer == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAllocation failed");\r\nkfree(pPhsdeviceExtension->CompressedTxBuffer);\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\n phs_init Successful");\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PhsCleanup(IN PPHS_DEVICE_EXTENSION pPHSDeviceExt)\r\n{\r\nif(pPHSDeviceExt->pstServiceFlowPhsRulesTable)\r\n{\r\nfree_phs_serviceflow_rules(pPHSDeviceExt->pstServiceFlowPhsRulesTable);\r\npPHSDeviceExt->pstServiceFlowPhsRulesTable = NULL;\r\n}\r\nkfree(pPHSDeviceExt->CompressedTxBuffer);\r\npPHSDeviceExt->CompressedTxBuffer = NULL;\r\nkfree(pPHSDeviceExt->UnCompressedRxBuffer);\r\npPHSDeviceExt->UnCompressedRxBuffer = NULL;\r\nreturn 0;\r\n}\r\nULONG PhsUpdateClassifierRule(IN void* pvContext,\r\nIN B_UINT16 uiVcid ,\r\nIN B_UINT16 uiClsId ,\r\nIN S_PHS_RULE *psPhsRule,\r\nIN B_UINT8 u8AssociatedPHSI)\r\n{\r\nULONG lStatus =0;\r\nUINT nSFIndex =0 ;\r\nS_SERVICEFLOW_ENTRY *pstServiceFlowEntry = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPHS_DEVICE_EXTENSION pDeviceExtension= (PPHS_DEVICE_EXTENSION)pvContext;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,"PHS With Corr2 Changes \n");\r\nif(pDeviceExtension == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,"Invalid Device Extension\n");\r\nreturn ERR_PHS_INVALID_DEVICE_EXETENSION;\r\n}\r\nif(u8AssociatedPHSI == 0)\r\n{\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\n}\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid,&pstServiceFlowEntry);\r\nif(nSFIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nlStatus = CreateSFToClassifierRuleMapping(uiVcid, uiClsId,\r\npDeviceExtension->pstServiceFlowPhsRulesTable, psPhsRule, u8AssociatedPHSI);\r\nreturn lStatus;\r\n}\r\nlStatus = CreateClassiferToPHSRuleMapping(uiVcid, uiClsId,\r\npstServiceFlowEntry, psPhsRule, u8AssociatedPHSI);\r\nreturn lStatus;\r\n}\r\nULONG PhsDeletePHSRule(IN void* pvContext,IN B_UINT16 uiVcid,IN B_UINT8 u8PHSI)\r\n{\r\nULONG lStatus =0;\r\nUINT nSFIndex =0, nClsidIndex =0 ;\r\nS_SERVICEFLOW_ENTRY *pstServiceFlowEntry = NULL;\r\nS_CLASSIFIER_TABLE *pstClassifierRulesTable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPHS_DEVICE_EXTENSION pDeviceExtension= (PPHS_DEVICE_EXTENSION)pvContext;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "======>\n");\r\nif(pDeviceExtension)\r\n{\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension\r\n->pstServiceFlowPhsRulesTable,uiVcid,&pstServiceFlowEntry);\r\nif(nSFIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\npstClassifierRulesTable=pstServiceFlowEntry->pstClassifierTable;\r\nif(pstClassifierRulesTable)\r\n{\r\nfor(nClsidIndex=0;nClsidIndex<MAX_PHSRULE_PER_SF;nClsidIndex++)\r\n{\r\nif(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].bUsed && pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule)\r\n{\r\nif(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8PHSI == u8PHSI) {\r\nif(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt--;\r\nif(0 == pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule);\r\nmemset(&pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex], 0,\r\nsizeof(S_CLASSIFIER_ENTRY));\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn lStatus;\r\n}\r\nULONG PhsDeleteClassifierRule(IN void* pvContext,IN B_UINT16 uiVcid ,IN B_UINT16 uiClsId)\r\n{\r\nULONG lStatus =0;\r\nUINT nSFIndex =0, nClsidIndex =0 ;\r\nS_SERVICEFLOW_ENTRY *pstServiceFlowEntry = NULL;\r\nS_CLASSIFIER_ENTRY *pstClassifierEntry = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPHS_DEVICE_EXTENSION pDeviceExtension= (PPHS_DEVICE_EXTENSION)pvContext;\r\nif(pDeviceExtension)\r\n{\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension\r\n->pstServiceFlowPhsRulesTable, uiVcid, &pstServiceFlowEntry);\r\nif(nSFIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,"SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId, eActiveClassifierRuleContext, &pstClassifierEntry);\r\nif((nClsidIndex != PHS_INVALID_TABLE_INDEX) && (!pstClassifierEntry->bUnclassifiedPHSRule))\r\n{\r\nif(pstClassifierEntry->pstPhsRule)\r\n{\r\nif(pstClassifierEntry->pstPhsRule->u8RefCnt)\r\npstClassifierEntry->pstPhsRule->u8RefCnt--;\r\nif(0==pstClassifierEntry->pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierEntry->pstPhsRule);\r\n}\r\nmemset(pstClassifierEntry, 0, sizeof(S_CLASSIFIER_ENTRY));\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId,eOldClassifierRuleContext,&pstClassifierEntry);\r\nif((nClsidIndex != PHS_INVALID_TABLE_INDEX) && (!pstClassifierEntry->bUnclassifiedPHSRule))\r\n{\r\nkfree(pstClassifierEntry->pstPhsRule);\r\nmemset(pstClassifierEntry, 0, sizeof(S_CLASSIFIER_ENTRY));\r\n}\r\n}\r\nreturn lStatus;\r\n}\r\nULONG PhsDeleteSFRules(IN void* pvContext,IN B_UINT16 uiVcid)\r\n{\r\nULONG lStatus =0;\r\nUINT nSFIndex =0, nClsidIndex =0 ;\r\nS_SERVICEFLOW_ENTRY *pstServiceFlowEntry = NULL;\r\nS_CLASSIFIER_TABLE *pstClassifierRulesTable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPHS_DEVICE_EXTENSION pDeviceExtension= (PPHS_DEVICE_EXTENSION)pvContext;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,"====> \n");\r\nif(pDeviceExtension)\r\n{\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid,&pstServiceFlowEntry);\r\nif(nSFIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\npstClassifierRulesTable=pstServiceFlowEntry->pstClassifierTable;\r\nif(pstClassifierRulesTable)\r\n{\r\nfor(nClsidIndex=0;nClsidIndex<MAX_PHSRULE_PER_SF;nClsidIndex++)\r\n{\r\nif(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule)\r\n{\r\nif(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex]\r\n.pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stActivePhsRulesList[nClsidIndex]\r\n.pstPhsRule->u8RefCnt--;\r\nif(0==pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex]\r\n.pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex].pstPhsRule);\r\npstClassifierRulesTable->stActivePhsRulesList[nClsidIndex]\r\n.pstPhsRule = NULL;\r\n}\r\nmemset(&pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex], 0, sizeof(S_CLASSIFIER_ENTRY));\r\nif(pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex].pstPhsRule)\r\n{\r\nif(pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex]\r\n.pstPhsRule->u8RefCnt)\r\npstClassifierRulesTable->stOldPhsRulesList[nClsidIndex]\r\n.pstPhsRule->u8RefCnt--;\r\nif(0 == pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex]\r\n.pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierRulesTable\r\n->stOldPhsRulesList[nClsidIndex].pstPhsRule);\r\npstClassifierRulesTable->stOldPhsRulesList[nClsidIndex]\r\n.pstPhsRule = NULL;\r\n}\r\nmemset(&pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex], 0, sizeof(S_CLASSIFIER_ENTRY));\r\n}\r\n}\r\npstServiceFlowEntry->bUsed = FALSE;\r\npstServiceFlowEntry->uiVcid = 0;\r\n}\r\nreturn lStatus;\r\n}\r\nULONG PhsCompress(IN void* pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,\r\nIN void *pvInputBuffer,\r\nOUT void *pvOutputBuffer,\r\nOUT UINT *pOldHeaderSize,\r\nOUT UINT *pNewHeaderSize )\r\n{\r\nUINT nSFIndex =0, nClsidIndex =0 ;\r\nS_SERVICEFLOW_ENTRY *pstServiceFlowEntry = NULL;\r\nS_CLASSIFIER_ENTRY *pstClassifierEntry = NULL;\r\nS_PHS_RULE *pstPhsRule = NULL;\r\nULONG lStatus =0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPHS_DEVICE_EXTENSION pDeviceExtension= (PPHS_DEVICE_EXTENSION)pvContext;\r\nif(pDeviceExtension == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"Invalid Device Extension\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION ;\r\nreturn lStatus;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"Suppressing header \n");\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid,&pstServiceFlowEntry);\r\nif(nSFIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"SFID Match Failed\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION ;\r\nreturn lStatus;\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId,eActiveClassifierRuleContext,&pstClassifierEntry);\r\nif(nClsidIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"No PHS Rule Defined For Classifier\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION ;\r\nreturn lStatus;\r\n}\r\npstPhsRule = pstClassifierEntry->pstPhsRule;\r\nif(!ValidatePHSRuleComplete(pstPhsRule))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,"PHS Rule Defined For Classifier But Not Complete\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION ;\r\nreturn lStatus;\r\n}\r\nlStatus = phs_compress(pstPhsRule,(PUCHAR)pvInputBuffer,\r\n(PUCHAR)pvOutputBuffer, pOldHeaderSize,pNewHeaderSize);\r\nif(lStatus == STATUS_PHS_COMPRESSED)\r\n{\r\npstPhsRule->PHSModifiedBytes += *pOldHeaderSize - *pNewHeaderSize - 1;\r\npstPhsRule->PHSModifiedNumPackets++;\r\n}\r\nelse\r\npstPhsRule->PHSErrorNumPackets++;\r\nreturn lStatus;\r\n}\r\nULONG PhsDeCompress(IN void* pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN void *pvInputBuffer,\r\nOUT void *pvOutputBuffer,\r\nOUT UINT *pInHeaderSize,\r\nOUT UINT *pOutHeaderSize )\r\n{\r\nUINT nSFIndex =0, nPhsRuleIndex =0 ;\r\nS_SERVICEFLOW_ENTRY *pstServiceFlowEntry = NULL;\r\nS_PHS_RULE *pstPhsRule = NULL;\r\nUINT phsi;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPHS_DEVICE_EXTENSION pDeviceExtension=\r\n(PPHS_DEVICE_EXTENSION)pvContext;\r\n*pInHeaderSize = 0;\r\nif(pDeviceExtension == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"Invalid Device Extension\n");\r\nreturn ERR_PHS_INVALID_DEVICE_EXETENSION;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"Restoring header\n");\r\nphsi = *((unsigned char *)(pvInputBuffer));\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"PHSI To Be Used For restore : %x\n",phsi);\r\nif(phsi == UNCOMPRESSED_PACKET )\r\n{\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid,&pstServiceFlowEntry);\r\nif(nSFIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"SFID Match Failed During Lookup\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\nnPhsRuleIndex = GetPhsRuleEntry(pstServiceFlowEntry->pstClassifierTable,phsi,\r\neActiveClassifierRuleContext,&pstPhsRule);\r\nif(nPhsRuleIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nnPhsRuleIndex = GetPhsRuleEntry(pstServiceFlowEntry->pstClassifierTable,\r\nphsi,eOldClassifierRuleContext,&pstPhsRule);\r\nif(nPhsRuleIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nreturn ERR_PHSRULE_MATCH_FAIL;\r\n}\r\n}\r\n*pInHeaderSize = phs_decompress((PUCHAR)pvInputBuffer,\r\n(PUCHAR)pvOutputBuffer,pstPhsRule,pOutHeaderSize);\r\npstPhsRule->PHSModifiedBytes += *pOutHeaderSize - *pInHeaderSize - 1;\r\npstPhsRule->PHSModifiedNumPackets++;\r\nreturn STATUS_PHS_COMPRESSED;\r\n}\r\nstatic void free_phs_serviceflow_rules(S_SERVICEFLOW_TABLE *psServiceFlowRulesTable)\r\n{\r\nint i,j;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "=======>\n");\r\nif(psServiceFlowRulesTable)\r\n{\r\nfor(i=0;i<MAX_SERVICEFLOWS;i++)\r\n{\r\nS_SERVICEFLOW_ENTRY stServiceFlowEntry =\r\npsServiceFlowRulesTable->stSFList[i];\r\nS_CLASSIFIER_TABLE *pstClassifierRulesTable =\r\nstServiceFlowEntry.pstClassifierTable;\r\nif(pstClassifierRulesTable)\r\n{\r\nfor(j=0;j<MAX_PHSRULE_PER_SF;j++)\r\n{\r\nif(pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule)\r\n{\r\nif(pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule\r\n->u8RefCnt)\r\npstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule\r\n->u8RefCnt--;\r\nif(0==pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule\r\n->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule);\r\npstClassifierRulesTable->stActivePhsRulesList[j].pstPhsRule = NULL;\r\n}\r\nif(pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule)\r\n{\r\nif(pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule\r\n->u8RefCnt)\r\npstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule\r\n->u8RefCnt--;\r\nif(0==pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule\r\n->u8RefCnt)\r\nkfree(pstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule);\r\npstClassifierRulesTable->stOldPhsRulesList[j].pstPhsRule = NULL;\r\n}\r\n}\r\nkfree(pstClassifierRulesTable);\r\nstServiceFlowEntry.pstClassifierTable = pstClassifierRulesTable = NULL;\r\n}\r\n}\r\n}\r\nkfree(psServiceFlowRulesTable);\r\npsServiceFlowRulesTable = NULL;\r\n}\r\nstatic BOOLEAN ValidatePHSRuleComplete(IN S_PHS_RULE *psPhsRule)\r\n{\r\nif(psPhsRule)\r\n{\r\nif(!psPhsRule->u8PHSI)\r\n{\r\nreturn FALSE;\r\n}\r\nif(!psPhsRule->u8PHSS)\r\n{\r\nreturn FALSE;\r\n}\r\nif(!psPhsRule->u8PHSFLength)\r\n{\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nelse\r\n{\r\nreturn FALSE;\r\n}\r\n}\r\nUINT GetServiceFlowEntry(IN S_SERVICEFLOW_TABLE *psServiceFlowTable,\r\nIN B_UINT16 uiVcid,S_SERVICEFLOW_ENTRY **ppstServiceFlowEntry)\r\n{\r\nint i;\r\nfor(i=0;i<MAX_SERVICEFLOWS;i++)\r\n{\r\nif(psServiceFlowTable->stSFList[i].bUsed)\r\n{\r\nif(psServiceFlowTable->stSFList[i].uiVcid == uiVcid)\r\n{\r\n*ppstServiceFlowEntry = &psServiceFlowTable->stSFList[i];\r\nreturn i;\r\n}\r\n}\r\n}\r\n*ppstServiceFlowEntry = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nUINT GetClassifierEntry(IN S_CLASSIFIER_TABLE *pstClassifierTable,\r\nIN B_UINT32 uiClsid,E_CLASSIFIER_ENTRY_CONTEXT eClsContext,\r\nOUT S_CLASSIFIER_ENTRY **ppstClassifierEntry)\r\n{\r\nint i;\r\nS_CLASSIFIER_ENTRY *psClassifierRules = NULL;\r\nfor(i=0;i<MAX_PHSRULE_PER_SF;i++)\r\n{\r\nif(eClsContext == eActiveClassifierRuleContext)\r\n{\r\npsClassifierRules = &pstClassifierTable->stActivePhsRulesList[i];\r\n}\r\nelse\r\n{\r\npsClassifierRules = &pstClassifierTable->stOldPhsRulesList[i];\r\n}\r\nif(psClassifierRules->bUsed)\r\n{\r\nif(psClassifierRules->uiClassifierRuleId == uiClsid)\r\n{\r\n*ppstClassifierEntry = psClassifierRules;\r\nreturn i;\r\n}\r\n}\r\n}\r\n*ppstClassifierEntry = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nstatic UINT GetPhsRuleEntry(IN S_CLASSIFIER_TABLE *pstClassifierTable,\r\nIN B_UINT32 uiPHSI,E_CLASSIFIER_ENTRY_CONTEXT eClsContext,\r\nOUT S_PHS_RULE **ppstPhsRule)\r\n{\r\nint i;\r\nS_CLASSIFIER_ENTRY *pstClassifierRule = NULL;\r\nfor(i=0;i<MAX_PHSRULE_PER_SF;i++)\r\n{\r\nif(eClsContext == eActiveClassifierRuleContext)\r\n{\r\npstClassifierRule = &pstClassifierTable->stActivePhsRulesList[i];\r\n}\r\nelse\r\n{\r\npstClassifierRule = &pstClassifierTable->stOldPhsRulesList[i];\r\n}\r\nif(pstClassifierRule->bUsed)\r\n{\r\nif(pstClassifierRule->u8PHSI == uiPHSI)\r\n{\r\n*ppstPhsRule = pstClassifierRule->pstPhsRule;\r\nreturn i;\r\n}\r\n}\r\n}\r\n*ppstPhsRule = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nUINT CreateSFToClassifierRuleMapping(IN B_UINT16 uiVcid,IN B_UINT16 uiClsId,\r\nIN S_SERVICEFLOW_TABLE *psServiceFlowTable,S_PHS_RULE *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nS_CLASSIFIER_TABLE *psaClassifiertable = NULL;\r\nUINT uiStatus = 0;\r\nint iSfIndex;\r\nBOOLEAN bFreeEntryFound =FALSE;\r\nfor(iSfIndex=0;iSfIndex < MAX_SERVICEFLOWS;iSfIndex++)\r\n{\r\nif(!psServiceFlowTable->stSFList[iSfIndex].bUsed)\r\n{\r\nbFreeEntryFound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif(!bFreeEntryFound)\r\nreturn ERR_SFTABLE_FULL;\r\npsaClassifiertable = psServiceFlowTable->stSFList[iSfIndex].pstClassifierTable;\r\nuiStatus = CreateClassifierPHSRule(uiClsId,psaClassifiertable,psPhsRule,\r\neActiveClassifierRuleContext,u8AssociatedPHSI);\r\nif(uiStatus == PHS_SUCCESS)\r\n{\r\npsServiceFlowTable->stSFList[iSfIndex].bUsed = TRUE;\r\npsServiceFlowTable->stSFList[iSfIndex].uiVcid = uiVcid;\r\n}\r\nreturn uiStatus;\r\n}\r\nUINT CreateClassiferToPHSRuleMapping(IN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,IN S_SERVICEFLOW_ENTRY *pstServiceFlowEntry,\r\nS_PHS_RULE *psPhsRule,B_UINT8 u8AssociatedPHSI)\r\n{\r\nS_CLASSIFIER_ENTRY *pstClassifierEntry = NULL;\r\nUINT uiStatus =PHS_SUCCESS;\r\nUINT nClassifierIndex = 0;\r\nS_CLASSIFIER_TABLE *psaClassifiertable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npsaClassifiertable = pstServiceFlowEntry->pstClassifierTable;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "==>");\r\nnClassifierIndex =GetClassifierEntry(\r\npstServiceFlowEntry->pstClassifierTable,uiClsId,\r\neActiveClassifierRuleContext,&pstClassifierEntry);\r\nif(nClassifierIndex == PHS_INVALID_TABLE_INDEX)\r\n{\r\nuiStatus = CreateClassifierPHSRule(uiClsId,psaClassifiertable,\r\npsPhsRule,eActiveClassifierRuleContext,u8AssociatedPHSI);\r\nreturn uiStatus;\r\n}\r\nif(pstClassifierEntry->u8PHSI == psPhsRule->u8PHSI)\r\n{\r\nif(pstClassifierEntry->pstPhsRule == NULL)\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\nif(psPhsRule->u8PHSFLength)\r\n{\r\nmemcpy(pstClassifierEntry->pstPhsRule->u8PHSF,\r\npsPhsRule->u8PHSF , MAX_PHS_LENGTHS);\r\n}\r\nif(psPhsRule->u8PHSFLength)\r\n{\r\npstClassifierEntry->pstPhsRule->u8PHSFLength =\r\npsPhsRule->u8PHSFLength;\r\n}\r\nif(psPhsRule->u8PHSMLength)\r\n{\r\nmemcpy(pstClassifierEntry->pstPhsRule->u8PHSM,\r\npsPhsRule->u8PHSM, MAX_PHS_LENGTHS);\r\n}\r\nif(psPhsRule->u8PHSMLength)\r\n{\r\npstClassifierEntry->pstPhsRule->u8PHSMLength =\r\npsPhsRule->u8PHSMLength;\r\n}\r\nif(psPhsRule->u8PHSS)\r\n{\r\npstClassifierEntry->pstPhsRule->u8PHSS = psPhsRule->u8PHSS;\r\n}\r\npstClassifierEntry->pstPhsRule->u8PHSV = psPhsRule->u8PHSV;\r\n}\r\nelse\r\n{\r\nuiStatus=UpdateClassifierPHSRule( uiClsId, pstClassifierEntry,\r\npsaClassifiertable, psPhsRule, u8AssociatedPHSI);\r\n}\r\nreturn uiStatus;\r\n}\r\nstatic UINT CreateClassifierPHSRule(IN B_UINT16 uiClsId,\r\nS_CLASSIFIER_TABLE *psaClassifiertable ,S_PHS_RULE *psPhsRule,\r\nE_CLASSIFIER_ENTRY_CONTEXT eClsContext,B_UINT8 u8AssociatedPHSI)\r\n{\r\nUINT iClassifierIndex = 0;\r\nBOOLEAN bFreeEntryFound = FALSE;\r\nS_CLASSIFIER_ENTRY *psClassifierRules = NULL;\r\nUINT nStatus = PHS_SUCCESS;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,"Inside CreateClassifierPHSRule");\r\nif(psaClassifiertable == NULL)\r\n{\r\nreturn ERR_INVALID_CLASSIFIERTABLE_FOR_SF;\r\n}\r\nif(eClsContext == eOldClassifierRuleContext)\r\n{\r\niClassifierIndex =\r\nGetClassifierEntry(psaClassifiertable, uiClsId,\r\neClsContext,&psClassifierRules);\r\nif(iClassifierIndex != PHS_INVALID_TABLE_INDEX)\r\n{\r\nbFreeEntryFound = TRUE;\r\n}\r\n}\r\nif(!bFreeEntryFound)\r\n{\r\nfor(iClassifierIndex = 0; iClassifierIndex <\r\nMAX_PHSRULE_PER_SF; iClassifierIndex++)\r\n{\r\nif(eClsContext == eActiveClassifierRuleContext)\r\n{\r\npsClassifierRules =\r\n&psaClassifiertable->stActivePhsRulesList[iClassifierIndex];\r\n}\r\nelse\r\n{\r\npsClassifierRules =\r\n&psaClassifiertable->stOldPhsRulesList[iClassifierIndex];\r\n}\r\nif(!psClassifierRules->bUsed)\r\n{\r\nbFreeEntryFound = TRUE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(!bFreeEntryFound)\r\n{\r\nif(eClsContext == eActiveClassifierRuleContext)\r\n{\r\nreturn ERR_CLSASSIFIER_TABLE_FULL;\r\n}\r\nelse\r\n{\r\nif(psaClassifiertable->uiOldestPhsRuleIndex >=\r\nMAX_PHSRULE_PER_SF)\r\n{\r\npsaClassifiertable->uiOldestPhsRuleIndex =0;\r\n}\r\niClassifierIndex = psaClassifiertable->uiOldestPhsRuleIndex;\r\npsClassifierRules =\r\n&psaClassifiertable->stOldPhsRulesList[iClassifierIndex];\r\n(psaClassifiertable->uiOldestPhsRuleIndex)++;\r\n}\r\n}\r\nif(eClsContext == eOldClassifierRuleContext)\r\n{\r\nif(psClassifierRules->pstPhsRule == NULL)\r\n{\r\npsClassifierRules->pstPhsRule = kmalloc(sizeof(S_PHS_RULE),GFP_KERNEL);\r\nif(NULL == psClassifierRules->pstPhsRule)\r\nreturn ERR_PHSRULE_MEMALLOC_FAIL;\r\n}\r\npsClassifierRules->bUsed = TRUE;\r\npsClassifierRules->uiClassifierRuleId = uiClsId;\r\npsClassifierRules->u8PHSI = psPhsRule->u8PHSI;\r\npsClassifierRules->bUnclassifiedPHSRule = psPhsRule->bUnclassifiedPHSRule;\r\nmemcpy(psClassifierRules->pstPhsRule,\r\npsPhsRule, sizeof(S_PHS_RULE));\r\n}\r\nelse\r\n{\r\nnStatus = UpdateClassifierPHSRule(uiClsId,psClassifierRules,\r\npsaClassifiertable,psPhsRule,u8AssociatedPHSI);\r\n}\r\nreturn nStatus;\r\n}\r\nstatic UINT UpdateClassifierPHSRule(IN B_UINT16 uiClsId,\r\nIN S_CLASSIFIER_ENTRY *pstClassifierEntry,\r\nS_CLASSIFIER_TABLE *psaClassifiertable ,S_PHS_RULE *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nS_PHS_RULE *pstAddPhsRule = NULL;\r\nUINT nPhsRuleIndex = 0;\r\nBOOLEAN bPHSRuleOrphaned = FALSE;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npsPhsRule->u8RefCnt =0;\r\nbPHSRuleOrphaned = DerefPhsRule( uiClsId, psaClassifiertable,\r\npstClassifierEntry->pstPhsRule);\r\nnPhsRuleIndex =GetPhsRuleEntry(psaClassifiertable,u8AssociatedPHSI,\r\neActiveClassifierRuleContext, &pstAddPhsRule);\r\nif(PHS_INVALID_TABLE_INDEX == nPhsRuleIndex)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nAdding New PHSRuleEntry For Classifier");\r\nif(psPhsRule->u8PHSI == 0)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nError PHSI is Zero\n");\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\n}\r\nif(FALSE == bPHSRuleOrphaned)\r\n{\r\npstClassifierEntry->pstPhsRule = kmalloc(sizeof(S_PHS_RULE), GFP_KERNEL);\r\nif(NULL == pstClassifierEntry->pstPhsRule)\r\n{\r\nreturn ERR_PHSRULE_MEMALLOC_FAIL;\r\n}\r\n}\r\nmemcpy(pstClassifierEntry->pstPhsRule, psPhsRule, sizeof(S_PHS_RULE));\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL, "\nTying Classifier to Existing PHS Rule");\r\nif(bPHSRuleOrphaned)\r\n{\r\nkfree(pstClassifierEntry->pstPhsRule);\r\npstClassifierEntry->pstPhsRule = NULL;\r\n}\r\npstClassifierEntry->pstPhsRule = pstAddPhsRule;\r\n}\r\npstClassifierEntry->bUsed = TRUE;\r\npstClassifierEntry->u8PHSI = pstClassifierEntry->pstPhsRule->u8PHSI;\r\npstClassifierEntry->uiClassifierRuleId = uiClsId;\r\npstClassifierEntry->pstPhsRule->u8RefCnt++;\r\npstClassifierEntry->bUnclassifiedPHSRule = pstClassifierEntry->pstPhsRule->bUnclassifiedPHSRule;\r\nreturn PHS_SUCCESS;\r\n}\r\nstatic BOOLEAN DerefPhsRule(IN B_UINT16 uiClsId,S_CLASSIFIER_TABLE *psaClassifiertable,S_PHS_RULE *pstPhsRule)\r\n{\r\nif(pstPhsRule==NULL)\r\nreturn FALSE;\r\nif(pstPhsRule->u8RefCnt)\r\npstPhsRule->u8RefCnt--;\r\nif(0==pstPhsRule->u8RefCnt)\r\n{\r\nreturn TRUE;\r\n}\r\nelse\r\n{\r\nreturn FALSE;\r\n}\r\n}\r\nvoid DumpPhsRules(PPHS_DEVICE_EXTENSION pDeviceExtension)\r\n{\r\nint i,j,k,l;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n Dumping PHS Rules : \n");\r\nfor(i=0;i<MAX_SERVICEFLOWS;i++)\r\n{\r\nS_SERVICEFLOW_ENTRY stServFlowEntry =\r\npDeviceExtension->pstServiceFlowPhsRulesTable->stSFList[i];\r\nif(stServFlowEntry.bUsed)\r\n{\r\nfor(j=0;j<MAX_PHSRULE_PER_SF;j++)\r\n{\r\nfor(l=0;l<2;l++)\r\n{\r\nS_CLASSIFIER_ENTRY stClsEntry;\r\nif(l==0)\r\n{\r\nstClsEntry = stServFlowEntry.pstClassifierTable->stActivePhsRulesList[j];\r\nif(stClsEntry.bUsed)\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n Active PHS Rule : \n");\r\n}\r\nelse\r\n{\r\nstClsEntry = stServFlowEntry.pstClassifierTable->stOldPhsRulesList[j];\r\nif(stClsEntry.bUsed)\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n Old PHS Rule : \n");\r\n}\r\nif(stClsEntry.bUsed)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n VCID : %#X",stServFlowEntry.uiVcid);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n ClassifierID : %#X",stClsEntry.uiClassifierRuleId);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSRuleID : %#X",stClsEntry.u8PHSI);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n****************PHS Rule********************\n");\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSI : %#X",stClsEntry.pstPhsRule->u8PHSI);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSFLength : %#X ",stClsEntry.pstPhsRule->u8PHSFLength);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSF : ");\r\nfor(k=0;k<stClsEntry.pstPhsRule->u8PHSFLength;k++)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "%#X ",stClsEntry.pstPhsRule->u8PHSF[k]);\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSMLength : %#X",stClsEntry.pstPhsRule->u8PHSMLength);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSM :");\r\nfor(k=0;k<stClsEntry.pstPhsRule->u8PHSMLength;k++)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "%#X ",stClsEntry.pstPhsRule->u8PHSM[k]);\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSS : %#X ",stClsEntry.pstPhsRule->u8PHSS);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSV : %#X",stClsEntry.pstPhsRule->u8PHSV);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n********************************************\n");\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nint phs_decompress(unsigned char *in_buf,unsigned char *out_buf,\r\nS_PHS_RULE *decomp_phs_rules,UINT *header_size)\r\n{\r\nint phss,size=0;\r\nS_PHS_RULE *tmp_memb;\r\nint bit,i=0;\r\nunsigned char *phsf,*phsm;\r\nint in_buf_len = *header_size-1;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nin_buf++;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"====>\n");\r\n*header_size = 0;\r\nif((decomp_phs_rules == NULL ))\r\nreturn 0;\r\ntmp_memb = decomp_phs_rules;\r\nphss = tmp_memb->u8PHSS;\r\nphsf = tmp_memb->u8PHSF;\r\nphsm = tmp_memb->u8PHSM;\r\nif(phss > MAX_PHS_LENGTHS)\r\nphss = MAX_PHS_LENGTHS;\r\nwhile((phss > 0) && (size < in_buf_len))\r\n{\r\nbit = ((*phsm << i)& SUPPRESS);\r\nif(bit == SUPPRESS)\r\n{\r\n*out_buf = *phsf;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"\nDECOMP:In phss %d phsf %d ouput %d",\r\nphss,*phsf,*out_buf);\r\n}\r\nelse\r\n{\r\n*out_buf = *in_buf;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_RECEIVE,DBG_LVL_ALL,"\nDECOMP:In phss %d input %d ouput %d",\r\nphss,*in_buf,*out_buf);\r\nin_buf++;\r\nsize++;\r\n}\r\nout_buf++;\r\nphsf++;\r\nphss--;\r\ni++;\r\n*header_size=*header_size + 1;\r\nif(i > MAX_NO_BIT)\r\n{\r\ni=0;\r\nphsm++;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic int phs_compress(S_PHS_RULE *phs_rule,unsigned char *in_buf\r\n,unsigned char *out_buf,UINT *header_size,UINT *new_header_size)\r\n{\r\nunsigned char *old_addr = out_buf;\r\nint suppress = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif(phs_rule == NULL)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nphs_compress(): phs_rule null!");\r\n*out_buf = ZERO_PHSI;\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\nif(phs_rule->u8PHSS <= *new_header_size)\r\n{\r\n*header_size = phs_rule->u8PHSS;\r\n}\r\nelse\r\n{\r\n*header_size = *new_header_size;\r\n}\r\nout_buf++;\r\nsuppress = verify_suppress_phsf(in_buf,out_buf,phs_rule->u8PHSF,\r\nphs_rule->u8PHSM, phs_rule->u8PHSS, phs_rule->u8PHSV,new_header_size);\r\nif(suppress == STATUS_PHS_COMPRESSED)\r\n{\r\n*old_addr = (unsigned char)phs_rule->u8PHSI;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In phs_compress phsi %d",phs_rule->u8PHSI);\r\n}\r\nelse\r\n{\r\n*old_addr = ZERO_PHSI;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In phs_compress PHSV Verification failed");\r\n}\r\nreturn suppress;\r\n}\r\nstatic int verify_suppress_phsf(unsigned char *in_buffer,unsigned char *out_buffer,\r\nunsigned char *phsf,unsigned char *phsm,unsigned int phss,\r\nunsigned int phsv,UINT* new_header_size)\r\n{\r\nunsigned int size=0;\r\nint bit,i=0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In verify_phsf PHSM - 0x%X",*phsm);\r\nif(phss>(*new_header_size))\r\n{\r\nphss=*new_header_size;\r\n}\r\nwhile(phss > 0)\r\n{\r\nbit = ((*phsm << i)& SUPPRESS);\r\nif(bit == SUPPRESS)\r\n{\r\nif(*in_buffer != *phsf)\r\n{\r\nif(phsv == VERIFY)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In verify_phsf failed for field %d buf %d phsf %d",phss,*in_buffer,*phsf);\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\n}\r\nelse\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In verify_phsf success for field %d buf %d phsf %d",phss,*in_buffer,*phsf);\r\n}\r\nelse\r\n{\r\n*out_buffer = *in_buffer;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In copying_header input %d out %d",*in_buffer,*out_buffer);\r\nout_buffer++;\r\nsize++;\r\n}\r\nin_buffer++;\r\nphsf++;\r\nphss--;\r\ni++;\r\nif(i > MAX_NO_BIT)\r\n{\r\ni=0;\r\nphsm++;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,"\nCOMP:In verify_phsf success");\r\n*new_header_size = size;\r\nreturn STATUS_PHS_COMPRESSED;\r\n}
