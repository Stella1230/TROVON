static int e4000_wr_regs(struct e4000_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[1 + len];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_rd_regs(struct e4000_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[len];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_wr_reg(struct e4000_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn e4000_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int e4000_rd_reg(struct e4000_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn e4000_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int e4000_init(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_priv *priv = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = e4000_wr_reg(priv, 0x02, 0x40);\r\nret = e4000_wr_reg(priv, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x06, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x7a, 0x96);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_regs(priv, 0x7e, "\x01\xfe", 2);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x82, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x24, 0x05);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_regs(priv, 0x87, "\x20\x01", 2);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_regs(priv, 0x9f, "\x7f\x07", 2);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x2d, 0x0c);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x1a, 0x17);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x1f, 0x1a);\r\nif (ret < 0)\r\ngoto err;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_priv *priv = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = e4000_wr_reg(priv, 0x00, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, sigma_delta;\r\nunsigned int f_VCO;\r\nu8 buf[5];\r\ndev_dbg(&priv->i2c->dev, "%s: delivery_system=%d frequency=%d " \\r\n"bandwidth_hz=%d\n", __func__,\r\nc->delivery_system, c->frequency, c->bandwidth_hz);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = e4000_wr_reg(priv, 0x1a, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_pll_lut); i++) {\r\nif (c->frequency <= e4000_pll_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_pll_lut))\r\ngoto err;\r\nf_VCO = c->frequency * e4000_pll_lut[i].mul;\r\nsigma_delta = 0x10000UL * (f_VCO % priv->cfg->clock) / priv->cfg->clock;\r\nbuf[0] = f_VCO / priv->cfg->clock;\r\nbuf[1] = (sigma_delta >> 0) & 0xff;\r\nbuf[2] = (sigma_delta >> 8) & 0xff;\r\nbuf[3] = 0x00;\r\nbuf[4] = e4000_pll_lut[i].div;\r\ndev_dbg(&priv->i2c->dev, "%s: f_VCO=%u pll div=%d sigma_delta=%04x\n",\r\n__func__, f_VCO, buf[0], sigma_delta);\r\nret = e4000_wr_regs(priv, 0x09, buf, 5);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e400_lna_filter_lut); i++) {\r\nif (c->frequency <= e400_lna_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e400_lna_filter_lut))\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x10, e400_lna_filter_lut[i].val);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_if_filter_lut); i++) {\r\nif (c->bandwidth_hz <= e4000_if_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_if_filter_lut))\r\ngoto err;\r\nbuf[0] = e4000_if_filter_lut[i].reg11_val;\r\nbuf[1] = e4000_if_filter_lut[i].reg12_val;\r\nret = e4000_wr_regs(priv, 0x11, buf, 2);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_band_lut); i++) {\r\nif (c->frequency <= e4000_band_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_band_lut))\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x07, e4000_band_lut[i].reg07_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x78, e4000_band_lut[i].reg78_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x1a, 0x17);\r\nif (ret < 0)\r\ngoto err;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct e4000_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int e4000_release(struct dvb_frontend *fe)\r\n{\r\nstruct e4000_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nkfree(fe->tuner_priv);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *e4000_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, const struct e4000_config *cfg)\r\n{\r\nstruct e4000_priv *priv;\r\nint ret;\r\nu8 chip_id;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\npriv = kzalloc(sizeof(struct e4000_priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ndev_err(&i2c->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);\r\ngoto err;\r\n}\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nret = e4000_rd_reg(priv, 0x02, &chip_id);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: chip_id=%02x\n", __func__, chip_id);\r\nif (chip_id != 0x40)\r\ngoto err;\r\nret = e4000_wr_reg(priv, 0x00, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\ndev_info(&priv->i2c->dev,\r\n"%s: Elonics E4000 successfully identified\n",\r\nKBUILD_MODNAME);\r\nfe->tuner_priv = priv;\r\nmemcpy(&fe->ops.tuner_ops, &e4000_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn fe;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
