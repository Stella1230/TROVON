static struct usb_phy *__usb_find_phy(struct list_head *list,\r\nenum usb_phy_type type)\r\n{\r\nstruct usb_phy *phy = NULL;\r\nlist_for_each_entry(phy, list, head) {\r\nif (phy->type != type)\r\ncontinue;\r\nreturn phy;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic void devm_usb_phy_release(struct device *dev, void *res)\r\n{\r\nstruct usb_phy *phy = *(struct usb_phy **)res;\r\nusb_put_phy(phy);\r\n}\r\nstatic int devm_usb_phy_match(struct device *dev, void *res, void *match_data)\r\n{\r\nreturn res == match_data;\r\n}\r\nstruct usb_phy *devm_usb_get_phy(struct device *dev, enum usb_phy_type type)\r\n{\r\nstruct usb_phy **ptr, *phy;\r\nptr = devres_alloc(devm_usb_phy_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn NULL;\r\nphy = usb_get_phy(type);\r\nif (!IS_ERR(phy)) {\r\n*ptr = phy;\r\ndevres_add(dev, ptr);\r\n} else\r\ndevres_free(ptr);\r\nreturn phy;\r\n}\r\nstruct usb_phy *usb_get_phy(enum usb_phy_type type)\r\n{\r\nstruct usb_phy *phy = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&phy_lock, flags);\r\nphy = __usb_find_phy(&phy_list, type);\r\nif (IS_ERR(phy)) {\r\npr_err("unable to find transceiver of type %s\n",\r\nusb_phy_type_string(type));\r\ngoto err0;\r\n}\r\nget_device(phy->dev);\r\nerr0:\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\nreturn phy;\r\n}\r\nvoid devm_usb_put_phy(struct device *dev, struct usb_phy *phy)\r\n{\r\nint r;\r\nr = devres_destroy(dev, devm_usb_phy_release, devm_usb_phy_match, phy);\r\ndev_WARN_ONCE(dev, r, "couldn't find PHY resource\n");\r\n}\r\nvoid usb_put_phy(struct usb_phy *x)\r\n{\r\nif (x)\r\nput_device(x->dev);\r\n}\r\nint usb_add_phy(struct usb_phy *x, enum usb_phy_type type)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nstruct usb_phy *phy;\r\nif (x->type != USB_PHY_TYPE_UNDEFINED) {\r\ndev_err(x->dev, "not accepting initialized PHY %s\n", x->label);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&phy_lock, flags);\r\nlist_for_each_entry(phy, &phy_list, head) {\r\nif (phy->type == type) {\r\nret = -EBUSY;\r\ndev_err(x->dev, "transceiver type %s already exists\n",\r\nusb_phy_type_string(type));\r\ngoto out;\r\n}\r\n}\r\nx->type = type;\r\nlist_add_tail(&x->head, &phy_list);\r\nout:\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\nreturn ret;\r\n}\r\nvoid usb_remove_phy(struct usb_phy *x)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&phy_lock, flags);\r\nif (x)\r\nlist_del(&x->head);\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\n}\r\nconst char *otg_state_string(enum usb_otg_state state)\r\n{\r\nswitch (state) {\r\ncase OTG_STATE_A_IDLE:\r\nreturn "a_idle";\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nreturn "a_wait_vrise";\r\ncase OTG_STATE_A_WAIT_BCON:\r\nreturn "a_wait_bcon";\r\ncase OTG_STATE_A_HOST:\r\nreturn "a_host";\r\ncase OTG_STATE_A_SUSPEND:\r\nreturn "a_suspend";\r\ncase OTG_STATE_A_PERIPHERAL:\r\nreturn "a_peripheral";\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nreturn "a_wait_vfall";\r\ncase OTG_STATE_A_VBUS_ERR:\r\nreturn "a_vbus_err";\r\ncase OTG_STATE_B_IDLE:\r\nreturn "b_idle";\r\ncase OTG_STATE_B_SRP_INIT:\r\nreturn "b_srp_init";\r\ncase OTG_STATE_B_PERIPHERAL:\r\nreturn "b_peripheral";\r\ncase OTG_STATE_B_WAIT_ACON:\r\nreturn "b_wait_acon";\r\ncase OTG_STATE_B_HOST:\r\nreturn "b_host";\r\ndefault:\r\nreturn "UNDEFINED";\r\n}\r\n}
