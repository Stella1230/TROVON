static void mainstone_mask_irq(struct irq_data *d)\r\n{\r\nint mainstone_irq = (d->irq - MAINSTONE_IRQ(0));\r\nMST_INTMSKENA = (mainstone_irq_enabled &= ~(1 << mainstone_irq));\r\n}\r\nstatic void mainstone_unmask_irq(struct irq_data *d)\r\n{\r\nint mainstone_irq = (d->irq - MAINSTONE_IRQ(0));\r\nMST_INTSETCLR &= ~(1 << mainstone_irq);\r\nMST_INTMSKENA = (mainstone_irq_enabled |= (1 << mainstone_irq));\r\n}\r\nstatic void mainstone_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned long pending = MST_INTSETCLR & mainstone_irq_enabled;\r\ndo {\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nif (likely(pending)) {\r\nirq = MAINSTONE_IRQ(0) + __ffs(pending);\r\ngeneric_handle_irq(irq);\r\n}\r\npending = MST_INTSETCLR & mainstone_irq_enabled;\r\n} while (pending);\r\n}\r\nstatic void __init mainstone_init_irq(void)\r\n{\r\nint irq;\r\npxa27x_init_irq();\r\nfor(irq = MAINSTONE_IRQ(0); irq <= MAINSTONE_IRQ(15); irq++) {\r\nirq_set_chip_and_handler(irq, &mainstone_irq_chip,\r\nhandle_level_irq);\r\nif (irq == MAINSTONE_IRQ(10) || irq == MAINSTONE_IRQ(14))\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE | IRQF_NOAUTOEN);\r\nelse\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\n}\r\nset_irq_flags(MAINSTONE_IRQ(8), 0);\r\nset_irq_flags(MAINSTONE_IRQ(12), 0);\r\nMST_INTMSKENA = 0;\r\nMST_INTSETCLR = 0;\r\nirq_set_chained_handler(PXA_GPIO_TO_IRQ(0), mainstone_irq_handler);\r\nirq_set_irq_type(PXA_GPIO_TO_IRQ(0), IRQ_TYPE_EDGE_FALLING);\r\n}\r\nstatic void mainstone_irq_resume(void)\r\n{\r\nMST_INTMSKENA = mainstone_irq_enabled;\r\n}\r\nstatic int __init mainstone_irq_device_init(void)\r\n{\r\nif (machine_is_mainstone())\r\nregister_syscore_ops(&mainstone_irq_syscore_ops);\r\nreturn 0;\r\n}\r\nstatic int mst_audio_startup(struct snd_pcm_substream *substream, void *priv)\r\n{\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nMST_MSCWR2 &= ~MST_MSCWR2_AC97_SPKROFF;\r\nreturn 0;\r\n}\r\nstatic void mst_audio_shutdown(struct snd_pcm_substream *substream, void *priv)\r\n{\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nMST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;\r\n}\r\nstatic void mst_audio_suspend(void *priv)\r\n{\r\nmst_audio_suspend_mask = MST_MSCWR2;\r\nMST_MSCWR2 |= MST_MSCWR2_AC97_SPKROFF;\r\n}\r\nstatic void mst_audio_resume(void *priv)\r\n{\r\nMST_MSCWR2 &= mst_audio_suspend_mask | ~MST_MSCWR2_AC97_SPKROFF;\r\n}\r\nstatic void __init mainstone_backlight_register(void)\r\n{\r\nint ret = platform_device_register(&mainstone_backlight_device);\r\nif (ret)\r\nprintk(KERN_ERR "mainstone: failed to register backlight device: %d\n", ret);\r\n}\r\nstatic int mainstone_mci_init(struct device *dev, irq_handler_t mstone_detect_int, void *data)\r\n{\r\nint err;\r\nMST_MSCWR1 &= ~MST_MSCWR1_MS_SEL;\r\nerr = request_irq(MAINSTONE_MMC_IRQ, mstone_detect_int, IRQF_DISABLED,\r\n"MMC card detect", data);\r\nif (err)\r\nprintk(KERN_ERR "mainstone_mci_init: MMC/SD: can't request MMC card detect IRQ\n");\r\nreturn err;\r\n}\r\nstatic void mainstone_mci_setpower(struct device *dev, unsigned int vdd)\r\n{\r\nstruct pxamci_platform_data* p_d = dev->platform_data;\r\nif (( 1 << vdd) & p_d->ocr_mask) {\r\nprintk(KERN_DEBUG "%s: on\n", __func__);\r\nMST_MSCWR1 |= MST_MSCWR1_MMC_ON;\r\nMST_MSCWR1 &= ~MST_MSCWR1_MS_SEL;\r\n} else {\r\nprintk(KERN_DEBUG "%s: off\n", __func__);\r\nMST_MSCWR1 &= ~MST_MSCWR1_MMC_ON;\r\n}\r\n}\r\nstatic void mainstone_mci_exit(struct device *dev, void *data)\r\n{\r\nfree_irq(MAINSTONE_MMC_IRQ, data);\r\n}\r\nstatic void mainstone_irda_transceiver_mode(struct device *dev, int mode)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (mode & IR_SIRMODE) {\r\nMST_MSCWR1 &= ~MST_MSCWR1_IRDA_FIR;\r\n} else if (mode & IR_FIRMODE) {\r\nMST_MSCWR1 |= MST_MSCWR1_IRDA_FIR;\r\n}\r\npxa2xx_transceiver_mode(dev, mode);\r\nif (mode & IR_OFF) {\r\nMST_MSCWR1 = (MST_MSCWR1 & ~MST_MSCWR1_IRDA_MASK) | MST_MSCWR1_IRDA_OFF;\r\n} else {\r\nMST_MSCWR1 = (MST_MSCWR1 & ~MST_MSCWR1_IRDA_MASK) | MST_MSCWR1_IRDA_FULL;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void __init mainstone_init_keypad(void)\r\n{\r\npxa_set_keypad_info(&mainstone_keypad_info);\r\n}\r\nstatic inline void mainstone_init_keypad(void) {}\r\nstatic void __init mainstone_init(void)\r\n{\r\nint SW7 = 0;\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(mainstone_pin_config));\r\npxa_set_ffuart_info(NULL);\r\npxa_set_btuart_info(NULL);\r\npxa_set_stuart_info(NULL);\r\nmst_flash_data[0].width = (__raw_readl(BOOT_DEF) & 1) ? 2 : 4;\r\nmst_flash_data[1].width = 4;\r\nmst_flash_data[SW7].name = "processor-flash";\r\nmst_flash_data[SW7 ^ 1].name = "mainboard-flash";\r\nprintk(KERN_NOTICE "Mainstone configured to boot from %s\n",\r\nmst_flash_data[0].name);\r\nARB_CNTRL = ARB_CORE_PARK | 0x234;\r\nplatform_add_devices(platform_devices, ARRAY_SIZE(platform_devices));\r\nif (0)\r\nmainstone_pxafb_info.modes = &toshiba_ltm04c380k_mode;\r\nelse\r\nmainstone_pxafb_info.modes = &toshiba_ltm035a776c_mode;\r\npxa_set_fb_info(NULL, &mainstone_pxafb_info);\r\nmainstone_backlight_register();\r\npxa_set_mci_info(&mainstone_mci_platform_data);\r\npxa_set_ficp_info(&mainstone_ficp_platform_data);\r\npxa_set_ohci_info(&mainstone_ohci_platform_data);\r\npxa_set_i2c_info(NULL);\r\npxa_set_ac97_info(&mst_audio_ops);\r\nmainstone_init_keypad();\r\n}\r\nstatic void __init mainstone_map_io(void)\r\n{\r\npxa27x_map_io();\r\niotable_init(mainstone_io_desc, ARRAY_SIZE(mainstone_io_desc));\r\nPSLR |= 0xF04;\r\nPCFR = 0x66;\r\n}\r\nstatic void mainstone_led_set(struct led_classdev *cdev,\r\nenum led_brightness b)\r\n{\r\nstruct mainstone_led *led = container_of(cdev,\r\nstruct mainstone_led, cdev);\r\nu32 reg = MST_LEDCTRL;\r\nif (b != LED_OFF)\r\nreg |= led->mask;\r\nelse\r\nreg &= ~led->mask;\r\nMST_LEDCTRL = reg;\r\n}\r\nstatic enum led_brightness mainstone_led_get(struct led_classdev *cdev)\r\n{\r\nstruct mainstone_led *led = container_of(cdev,\r\nstruct mainstone_led, cdev);\r\nu32 reg = MST_LEDCTRL;\r\nreturn (reg & led->mask) ? LED_FULL : LED_OFF;\r\n}\r\nstatic int __init mainstone_leds_init(void)\r\n{\r\nint i;\r\nif (!machine_is_mainstone())\r\nreturn -ENODEV;\r\nMST_LEDCTRL |= 0xff;\r\nfor (i = 0; i < ARRAY_SIZE(mainstone_leds); i++) {\r\nstruct mainstone_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->cdev.name = mainstone_leds[i].name;\r\nled->cdev.brightness_set = mainstone_led_set;\r\nled->cdev.brightness_get = mainstone_led_get;\r\nled->cdev.default_trigger = mainstone_leds[i].trigger;\r\nled->mask = BIT(i);\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
