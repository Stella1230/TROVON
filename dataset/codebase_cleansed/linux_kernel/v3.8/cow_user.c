void cow_sizes(int version, __u64 size, int sectorsize, int align,\r\nint bitmap_offset, unsigned long *bitmap_len_out,\r\nint *data_offset_out)\r\n{\r\nif (version < 3) {\r\n*bitmap_len_out = (size + sectorsize - 1) / (8 * sectorsize);\r\n*data_offset_out = bitmap_offset + *bitmap_len_out;\r\n*data_offset_out = (*data_offset_out + sectorsize - 1) /\r\nsectorsize;\r\n*data_offset_out *= sectorsize;\r\n}\r\nelse {\r\n*bitmap_len_out = DIV_ROUND(size, sectorsize);\r\n*bitmap_len_out = DIV_ROUND(*bitmap_len_out, 8);\r\n*data_offset_out = bitmap_offset + *bitmap_len_out;\r\n*data_offset_out = ROUND_UP(*data_offset_out, align);\r\n}\r\n}\r\nstatic int absolutize(char *to, int size, char *from)\r\n{\r\nchar save_cwd[256], *slash;\r\nint remaining;\r\nif (getcwd(save_cwd, sizeof(save_cwd)) == NULL) {\r\ncow_printf("absolutize : unable to get cwd - errno = %d\n",\r\nerrno);\r\nreturn -1;\r\n}\r\nslash = strrchr(from, '/');\r\nif (slash != NULL) {\r\n*slash = '\0';\r\nif (chdir(from)) {\r\n*slash = '/';\r\ncow_printf("absolutize : Can't cd to '%s' - "\r\n"errno = %d\n", from, errno);\r\nreturn -1;\r\n}\r\n*slash = '/';\r\nif (getcwd(to, size) == NULL) {\r\ncow_printf("absolutize : unable to get cwd of '%s' - "\r\n"errno = %d\n", from, errno);\r\nreturn -1;\r\n}\r\nremaining = size - strlen(to);\r\nif (strlen(slash) + 1 > remaining) {\r\ncow_printf("absolutize : unable to fit '%s' into %d "\r\n"chars\n", from, size);\r\nreturn -1;\r\n}\r\nstrcat(to, slash);\r\n}\r\nelse {\r\nif (strlen(save_cwd) + 1 + strlen(from) + 1 > size) {\r\ncow_printf("absolutize : unable to fit '%s' into %d "\r\n"chars\n", from, size);\r\nreturn -1;\r\n}\r\nstrcpy(to, save_cwd);\r\nstrcat(to, "/");\r\nstrcat(to, from);\r\n}\r\nif (chdir(save_cwd)) {\r\ncow_printf("absolutize : Can't cd to '%s' - "\r\n"errno = %d\n", save_cwd, errno);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint write_cow_header(char *cow_file, int fd, char *backing_file,\r\nint sectorsize, int alignment, unsigned long long *size)\r\n{\r\nstruct cow_header_v3 *header;\r\nunsigned long modtime;\r\nint err;\r\nerr = cow_seek_file(fd, 0);\r\nif (err < 0) {\r\ncow_printf("write_cow_header - lseek failed, err = %d\n", -err);\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\nheader = cow_malloc(sizeof(*header));\r\nif (header == NULL) {\r\ncow_printf("write_cow_header - failed to allocate COW V3 "\r\n"header\n");\r\ngoto out;\r\n}\r\nheader->magic = htobe32(COW_MAGIC);\r\nheader->version = htobe32(COW_VERSION);\r\nerr = -EINVAL;\r\nif (strlen(backing_file) > sizeof(header->backing_file) - 1) {\r\ncow_printf("Backing file name \"%s\" is too long - names are "\r\n"limited to %zd characters\n", backing_file,\r\nsizeof(header->backing_file) - 1);\r\ngoto out_free;\r\n}\r\nif (absolutize(header->backing_file, sizeof(header->backing_file),\r\nbacking_file))\r\ngoto out_free;\r\nerr = os_file_modtime(header->backing_file, &modtime);\r\nif (err < 0) {\r\ncow_printf("write_cow_header - backing file '%s' mtime "\r\n"request failed, err = %d\n", header->backing_file,\r\n-err);\r\ngoto out_free;\r\n}\r\nerr = cow_file_size(header->backing_file, size);\r\nif (err < 0) {\r\ncow_printf("write_cow_header - couldn't get size of "\r\n"backing file '%s', err = %d\n",\r\nheader->backing_file, -err);\r\ngoto out_free;\r\n}\r\nheader->mtime = htobe32(modtime);\r\nheader->size = htobe64(*size);\r\nheader->sectorsize = htobe32(sectorsize);\r\nheader->alignment = htobe32(alignment);\r\nheader->cow_format = COW_BITMAP;\r\nerr = cow_write_file(fd, header, sizeof(*header));\r\nif (err != sizeof(*header)) {\r\ncow_printf("write_cow_header - write of header to "\r\n"new COW file '%s' failed, err = %d\n", cow_file,\r\n-err);\r\ngoto out_free;\r\n}\r\nerr = 0;\r\nout_free:\r\ncow_free(header);\r\nout:\r\nreturn err;\r\n}\r\nint file_reader(__u64 offset, char *buf, int len, void *arg)\r\n{\r\nint fd = *((int *) arg);\r\nreturn pread(fd, buf, len, offset);\r\n}\r\nint read_cow_header(int (*reader)(__u64, char *, int, void *), void *arg,\r\n__u32 *version_out, char **backing_file_out,\r\ntime_t *mtime_out, unsigned long long *size_out,\r\nint *sectorsize_out, __u32 *align_out,\r\nint *bitmap_offset_out)\r\n{\r\nunion cow_header *header;\r\nchar *file;\r\nint err, n;\r\nunsigned long version, magic;\r\nheader = cow_malloc(sizeof(*header));\r\nif (header == NULL) {\r\ncow_printf("read_cow_header - Failed to allocate header\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = -EINVAL;\r\nn = (*reader)(0, (char *) header, sizeof(*header), arg);\r\nif (n < offsetof(typeof(header->v1), backing_file)) {\r\ncow_printf("read_cow_header - short header\n");\r\ngoto out;\r\n}\r\nmagic = header->v1.magic;\r\nif (magic == COW_MAGIC)\r\nversion = header->v1.version;\r\nelse if (magic == be32toh(COW_MAGIC))\r\nversion = be32toh(header->v1.version);\r\nelse goto out;\r\n*version_out = version;\r\nif (version == 1) {\r\nif (n < sizeof(header->v1)) {\r\ncow_printf("read_cow_header - failed to read V1 "\r\n"header\n");\r\ngoto out;\r\n}\r\n*mtime_out = header->v1.mtime;\r\n*size_out = header->v1.size;\r\n*sectorsize_out = header->v1.sectorsize;\r\n*bitmap_offset_out = sizeof(header->v1);\r\n*align_out = *sectorsize_out;\r\nfile = header->v1.backing_file;\r\n}\r\nelse if (version == 2) {\r\nif (n < sizeof(header->v2)) {\r\ncow_printf("read_cow_header - failed to read V2 "\r\n"header\n");\r\ngoto out;\r\n}\r\n*mtime_out = be32toh(header->v2.mtime);\r\n*size_out = be64toh(header->v2.size);\r\n*sectorsize_out = be32toh(header->v2.sectorsize);\r\n*bitmap_offset_out = sizeof(header->v2);\r\n*align_out = *sectorsize_out;\r\nfile = header->v2.backing_file;\r\n}\r\nelse if (version == 3 && (*((int*)header->v3.backing_file) != 0)) {\r\nif (n < sizeof(header->v3)) {\r\ncow_printf("read_cow_header - failed to read V3 "\r\n"header\n");\r\ngoto out;\r\n}\r\n*mtime_out = be32toh(header->v3.mtime);\r\n*size_out = be64toh(header->v3.size);\r\n*sectorsize_out = be32toh(header->v3.sectorsize);\r\n*align_out = be32toh(header->v3.alignment);\r\nif (*align_out == 0) {\r\ncow_printf("read_cow_header - invalid COW header, "\r\n"align == 0\n");\r\n}\r\n*bitmap_offset_out = ROUND_UP(sizeof(header->v3), *align_out);\r\nfile = header->v3.backing_file;\r\n}\r\nelse if (version == 3) {\r\ncow_printf("read_cow_header - broken V3 file with"\r\n" 64-bit layout - recovering content.\n");\r\nif (n < sizeof(header->v3_b)) {\r\ncow_printf("read_cow_header - failed to read V3 "\r\n"header\n");\r\ngoto out;\r\n}\r\n*mtime_out = (time32_t) be32toh(header->v3_b.mtime);\r\n*size_out = be64toh(header->v3_b.size);\r\n*sectorsize_out = be32toh(header->v3_b.sectorsize);\r\n*align_out = be32toh(header->v3_b.alignment);\r\nif (*align_out == 0) {\r\ncow_printf("read_cow_header - invalid COW header, "\r\n"align == 0\n");\r\n}\r\n*bitmap_offset_out = ROUND_UP(sizeof(header->v3_b), *align_out);\r\nfile = header->v3_b.backing_file;\r\n}\r\nelse {\r\ncow_printf("read_cow_header - invalid COW version\n");\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\n*backing_file_out = cow_strdup(file);\r\nif (*backing_file_out == NULL) {\r\ncow_printf("read_cow_header - failed to allocate backing "\r\n"file\n");\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\ncow_free(header);\r\nreturn err;\r\n}\r\nint init_cow_file(int fd, char *cow_file, char *backing_file, int sectorsize,\r\nint alignment, int *bitmap_offset_out,\r\nunsigned long *bitmap_len_out, int *data_offset_out)\r\n{\r\nunsigned long long size, offset;\r\nchar zero = 0;\r\nint err;\r\nerr = write_cow_header(cow_file, fd, backing_file, sectorsize,\r\nalignment, &size);\r\nif (err)\r\ngoto out;\r\n*bitmap_offset_out = ROUND_UP(sizeof(struct cow_header_v3), alignment);\r\ncow_sizes(COW_VERSION, size, sectorsize, alignment, *bitmap_offset_out,\r\nbitmap_len_out, data_offset_out);\r\noffset = *data_offset_out + size - sizeof(zero);\r\nerr = cow_seek_file(fd, offset);\r\nif (err < 0) {\r\ncow_printf("cow bitmap lseek failed : err = %d\n", -err);\r\ngoto out;\r\n}\r\nerr = cow_write_file(fd, &zero, sizeof(zero));\r\nif (err != sizeof(zero)) {\r\ncow_printf("Write of bitmap to new COW file '%s' failed, "\r\n"err = %d\n", cow_file, -err);\r\nif (err >= 0)\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}
