static char *\r\nbitvector_process(char *p, u64 vector)\r\n{\r\nint i,j;\r\nconst char *units[]={ "", "K", "M", "G", "T" };\r\nfor (i=0, j=0; i < 64; i++ , j=i/10) {\r\nif (vector & 0x1) {\r\np += sprintf(p, "%d%s ", 1 << (i-j*10), units[j]);\r\n}\r\nvector >>= 1;\r\n}\r\nreturn p;\r\n}\r\nstatic char *\r\nbitregister_process(char *p, u64 *reg_info, int max)\r\n{\r\nint i, begin, skip = 0;\r\nu64 value = reg_info[0];\r\nvalue >>= i = begin = ffs(value) - 1;\r\nfor(; i < max; i++ ) {\r\nif (i != 0 && (i%64) == 0) value = *++reg_info;\r\nif ((value & 0x1) == 0 && skip == 0) {\r\nif (begin <= i - 2)\r\np += sprintf(p, "%d-%d ", begin, i-1);\r\nelse\r\np += sprintf(p, "%d ", i-1);\r\nskip = 1;\r\nbegin = -1;\r\n} else if ((value & 0x1) && skip == 1) {\r\nskip = 0;\r\nbegin = i;\r\n}\r\nvalue >>=1;\r\n}\r\nif (begin > -1) {\r\nif (begin < 127)\r\np += sprintf(p, "%d-127", begin);\r\nelse\r\np += sprintf(p, "127");\r\n}\r\nreturn p;\r\n}\r\nstatic int\r\npower_info(char *page)\r\n{\r\ns64 status;\r\nchar *p = page;\r\nu64 halt_info_buffer[8];\r\npal_power_mgmt_info_u_t *halt_info =(pal_power_mgmt_info_u_t *)halt_info_buffer;\r\nint i;\r\nstatus = ia64_pal_halt_info(halt_info);\r\nif (status != 0) return 0;\r\nfor (i=0; i < 8 ; i++ ) {\r\nif (halt_info[i].pal_power_mgmt_info_s.im == 1) {\r\np += sprintf(p, "Power level %d:\n"\r\n"\tentry_latency : %d cycles\n"\r\n"\texit_latency : %d cycles\n"\r\n"\tpower consumption : %d mW\n"\r\n"\tCache+TLB coherency : %s\n", i,\r\nhalt_info[i].pal_power_mgmt_info_s.entry_latency,\r\nhalt_info[i].pal_power_mgmt_info_s.exit_latency,\r\nhalt_info[i].pal_power_mgmt_info_s.power_consumption,\r\nhalt_info[i].pal_power_mgmt_info_s.co ? "Yes" : "No");\r\n} else {\r\np += sprintf(p,"Power level %d: not implemented\n",i);\r\n}\r\n}\r\nreturn p - page;\r\n}\r\nstatic int\r\ncache_info(char *page)\r\n{\r\nchar *p = page;\r\nunsigned long i, levels, unique_caches;\r\npal_cache_config_info_t cci;\r\nint j, k;\r\nlong status;\r\nif ((status = ia64_pal_cache_summary(&levels, &unique_caches)) != 0) {\r\nprintk(KERN_ERR "ia64_pal_cache_summary=%ld\n", status);\r\nreturn 0;\r\n}\r\np += sprintf(p, "Cache levels : %ld\nUnique caches : %ld\n\n", levels, unique_caches);\r\nfor (i=0; i < levels; i++) {\r\nfor (j=2; j >0 ; j--) {\r\nif ((status=ia64_pal_cache_config_info(i,j, &cci)) != 0) {\r\ncontinue;\r\n}\r\np += sprintf(p,\r\n"%s Cache level %lu:\n"\r\n"\tSize : %u bytes\n"\r\n"\tAttributes : ",\r\ncache_types[j+cci.pcci_unified], i+1,\r\ncci.pcci_cache_size);\r\nif (cci.pcci_unified) p += sprintf(p, "Unified ");\r\np += sprintf(p, "%s\n", cache_mattrib[cci.pcci_cache_attr]);\r\np += sprintf(p,\r\n"\tAssociativity : %d\n"\r\n"\tLine size : %d bytes\n"\r\n"\tStride : %d bytes\n",\r\ncci.pcci_assoc, 1<<cci.pcci_line_size, 1<<cci.pcci_stride);\r\nif (j == 1)\r\np += sprintf(p, "\tStore latency : N/A\n");\r\nelse\r\np += sprintf(p, "\tStore latency : %d cycle(s)\n",\r\ncci.pcci_st_latency);\r\np += sprintf(p,\r\n"\tLoad latency : %d cycle(s)\n"\r\n"\tStore hints : ", cci.pcci_ld_latency);\r\nfor(k=0; k < 8; k++ ) {\r\nif ( cci.pcci_st_hints & 0x1)\r\np += sprintf(p, "[%s]", cache_st_hints[k]);\r\ncci.pcci_st_hints >>=1;\r\n}\r\np += sprintf(p, "\n\tLoad hints : ");\r\nfor(k=0; k < 8; k++ ) {\r\nif (cci.pcci_ld_hints & 0x1)\r\np += sprintf(p, "[%s]", cache_ld_hints[k]);\r\ncci.pcci_ld_hints >>=1;\r\n}\r\np += sprintf(p,\r\n"\n\tAlias boundary : %d byte(s)\n"\r\n"\tTag LSB : %d\n"\r\n"\tTag MSB : %d\n",\r\n1<<cci.pcci_alias_boundary, cci.pcci_tag_lsb,\r\ncci.pcci_tag_msb);\r\nif (cci.pcci_unified) break;\r\n}\r\n}\r\nreturn p - page;\r\n}\r\nstatic int\r\nvm_info(char *page)\r\n{\r\nchar *p = page;\r\nu64 tr_pages =0, vw_pages=0, tc_pages;\r\nu64 attrib;\r\npal_vm_info_1_u_t vm_info_1;\r\npal_vm_info_2_u_t vm_info_2;\r\npal_tc_info_u_t tc_info;\r\nia64_ptce_info_t ptce;\r\nconst char *sep;\r\nint i, j;\r\nlong status;\r\nif ((status = ia64_pal_vm_summary(&vm_info_1, &vm_info_2)) !=0) {\r\nprintk(KERN_ERR "ia64_pal_vm_summary=%ld\n", status);\r\n} else {\r\np += sprintf(p,\r\n"Physical Address Space : %d bits\n"\r\n"Virtual Address Space : %d bits\n"\r\n"Protection Key Registers(PKR) : %d\n"\r\n"Implemented bits in PKR.key : %d\n"\r\n"Hash Tag ID : 0x%x\n"\r\n"Size of RR.rid : %d\n"\r\n"Max Purges : ",\r\nvm_info_1.pal_vm_info_1_s.phys_add_size,\r\nvm_info_2.pal_vm_info_2_s.impl_va_msb+1,\r\nvm_info_1.pal_vm_info_1_s.max_pkr+1,\r\nvm_info_1.pal_vm_info_1_s.key_size,\r\nvm_info_1.pal_vm_info_1_s.hash_tag_id,\r\nvm_info_2.pal_vm_info_2_s.rid_size);\r\nif (vm_info_2.pal_vm_info_2_s.max_purges == PAL_MAX_PURGES)\r\np += sprintf(p, "unlimited\n");\r\nelse\r\np += sprintf(p, "%d\n",\r\nvm_info_2.pal_vm_info_2_s.max_purges ?\r\nvm_info_2.pal_vm_info_2_s.max_purges : 1);\r\n}\r\nif (ia64_pal_mem_attrib(&attrib) == 0) {\r\np += sprintf(p, "Supported memory attributes : ");\r\nsep = "";\r\nfor (i = 0; i < 8; i++) {\r\nif (attrib & (1 << i)) {\r\np += sprintf(p, "%s%s", sep, mem_attrib[i]);\r\nsep = ", ";\r\n}\r\n}\r\np += sprintf(p, "\n");\r\n}\r\nif ((status = ia64_pal_vm_page_size(&tr_pages, &vw_pages)) !=0) {\r\nprintk(KERN_ERR "ia64_pal_vm_page_size=%ld\n", status);\r\n} else {\r\np += sprintf(p,\r\n"\nTLB walker : %simplemented\n"\r\n"Number of DTR : %d\n"\r\n"Number of ITR : %d\n"\r\n"TLB insertable page sizes : ",\r\nvm_info_1.pal_vm_info_1_s.vw ? "" : "not ",\r\nvm_info_1.pal_vm_info_1_s.max_dtr_entry+1,\r\nvm_info_1.pal_vm_info_1_s.max_itr_entry+1);\r\np = bitvector_process(p, tr_pages);\r\np += sprintf(p, "\nTLB purgeable page sizes : ");\r\np = bitvector_process(p, vw_pages);\r\n}\r\nif ((status=ia64_get_ptce(&ptce)) != 0) {\r\nprintk(KERN_ERR "ia64_get_ptce=%ld\n", status);\r\n} else {\r\np += sprintf(p,\r\n"\nPurge base address : 0x%016lx\n"\r\n"Purge outer loop count : %d\n"\r\n"Purge inner loop count : %d\n"\r\n"Purge outer loop stride : %d\n"\r\n"Purge inner loop stride : %d\n",\r\nptce.base, ptce.count[0], ptce.count[1],\r\nptce.stride[0], ptce.stride[1]);\r\np += sprintf(p,\r\n"TC Levels : %d\n"\r\n"Unique TC(s) : %d\n",\r\nvm_info_1.pal_vm_info_1_s.num_tc_levels,\r\nvm_info_1.pal_vm_info_1_s.max_unique_tcs);\r\nfor(i=0; i < vm_info_1.pal_vm_info_1_s.num_tc_levels; i++) {\r\nfor (j=2; j>0 ; j--) {\r\ntc_pages = 0;\r\nif ((status=ia64_pal_vm_info(i,j, &tc_info, &tc_pages)) != 0) {\r\ncontinue;\r\n}\r\np += sprintf(p,\r\n"\n%s Translation Cache Level %d:\n"\r\n"\tHash sets : %d\n"\r\n"\tAssociativity : %d\n"\r\n"\tNumber of entries : %d\n"\r\n"\tFlags : ",\r\ncache_types[j+tc_info.tc_unified], i+1,\r\ntc_info.tc_num_sets,\r\ntc_info.tc_associativity,\r\ntc_info.tc_num_entries);\r\nif (tc_info.tc_pf)\r\np += sprintf(p, "PreferredPageSizeOptimized ");\r\nif (tc_info.tc_unified)\r\np += sprintf(p, "Unified ");\r\nif (tc_info.tc_reduce_tr)\r\np += sprintf(p, "TCReduction");\r\np += sprintf(p, "\n\tSupported page sizes: ");\r\np = bitvector_process(p, tc_pages);\r\nif (tc_info.tc_unified)\r\nbreak;\r\n}\r\n}\r\n}\r\np += sprintf(p, "\n");\r\nreturn p - page;\r\n}\r\nstatic int\r\nregister_info(char *page)\r\n{\r\nchar *p = page;\r\nu64 reg_info[2];\r\nu64 info;\r\nunsigned long phys_stacked;\r\npal_hints_u_t hints;\r\nunsigned long iregs, dregs;\r\nstatic const char * const info_type[] = {\r\n"Implemented AR(s)",\r\n"AR(s) with read side-effects",\r\n"Implemented CR(s)",\r\n"CR(s) with read side-effects",\r\n};\r\nfor(info=0; info < 4; info++) {\r\nif (ia64_pal_register_info(info, &reg_info[0], &reg_info[1]) != 0) return 0;\r\np += sprintf(p, "%-32s : ", info_type[info]);\r\np = bitregister_process(p, reg_info, 128);\r\np += sprintf(p, "\n");\r\n}\r\nif (ia64_pal_rse_info(&phys_stacked, &hints) == 0) {\r\np += sprintf(p,\r\n"RSE stacked physical registers : %ld\n"\r\n"RSE load/store hints : %ld (%s)\n",\r\nphys_stacked, hints.ph_data,\r\nhints.ph_data < RSE_HINTS_COUNT ? rse_hints[hints.ph_data]: "(??)");\r\n}\r\nif (ia64_pal_debug_info(&iregs, &dregs))\r\nreturn 0;\r\np += sprintf(p,\r\n"Instruction debug register pairs : %ld\n"\r\n"Data debug register pairs : %ld\n", iregs, dregs);\r\nreturn p - page;\r\n}\r\nstatic char * feature_set_info(char *page, u64 avail, u64 status, u64 control,\r\nunsigned long set)\r\n{\r\nchar *p = page;\r\nchar **vf, **v;\r\nint i;\r\nvf = v = proc_features[set];\r\nfor(i=0; i < 64; i++, avail >>=1, status >>=1, control >>=1) {\r\nif (!(control))\r\nbreak;\r\nif (!(avail & 0x1))\r\ncontinue;\r\nif (vf)\r\nv = vf + i;\r\nif ( v && *v ) {\r\np += sprintf(p, "%-40s : %s %s\n", *v,\r\navail & 0x1 ? (status & 0x1 ?\r\n"On " : "Off"): "",\r\navail & 0x1 ? (control & 0x1 ?\r\n"Ctrl" : "NoCtrl"): "");\r\n} else {\r\np += sprintf(p, "Feature set %2ld bit %2d\t\t\t"\r\n" : %s %s\n",\r\nset, i,\r\navail & 0x1 ? (status & 0x1 ?\r\n"On " : "Off"): "",\r\navail & 0x1 ? (control & 0x1 ?\r\n"Ctrl" : "NoCtrl"): "");\r\n}\r\n}\r\nreturn p;\r\n}\r\nstatic int\r\nprocessor_info(char *page)\r\n{\r\nchar *p = page;\r\nu64 avail=1, status=1, control=1, feature_set=0;\r\ns64 ret;\r\ndo {\r\nret = ia64_pal_proc_get_features(&avail, &status, &control,\r\nfeature_set);\r\nif (ret < 0) {\r\nreturn p - page;\r\n}\r\nif (ret == 1) {\r\nfeature_set++;\r\ncontinue;\r\n}\r\np = feature_set_info(p, avail, status, control, feature_set);\r\nfeature_set++;\r\n} while(1);\r\nreturn p - page;\r\n}\r\nstatic int\r\nbus_info(char *page)\r\n{\r\nchar *p = page;\r\nconst char **v = bus_features;\r\npal_bus_features_u_t av, st, ct;\r\nu64 avail, status, control;\r\nint i;\r\ns64 ret;\r\nif ((ret=ia64_pal_bus_get_features(&av, &st, &ct)) != 0) return 0;\r\navail = av.pal_bus_features_val;\r\nstatus = st.pal_bus_features_val;\r\ncontrol = ct.pal_bus_features_val;\r\nfor(i=0; i < 64; i++, v++, avail >>=1, status >>=1, control >>=1) {\r\nif ( ! *v ) continue;\r\np += sprintf(p, "%-48s : %s%s %s\n", *v,\r\navail & 0x1 ? "" : "NotImpl",\r\navail & 0x1 ? (status & 0x1 ? "On" : "Off"): "",\r\navail & 0x1 ? (control & 0x1 ? "Ctrl" : "NoCtrl"): "");\r\n}\r\nreturn p - page;\r\n}\r\nstatic int\r\nversion_info(char *page)\r\n{\r\npal_version_u_t min_ver, cur_ver;\r\nchar *p = page;\r\nif (ia64_pal_version(&min_ver, &cur_ver) != 0)\r\nreturn 0;\r\np += sprintf(p,\r\n"PAL_vendor : 0x%02x (min=0x%02x)\n"\r\n"PAL_A : %02x.%02x (min=%02x.%02x)\n"\r\n"PAL_B : %02x.%02x (min=%02x.%02x)\n",\r\ncur_ver.pal_version_s.pv_pal_vendor,\r\nmin_ver.pal_version_s.pv_pal_vendor,\r\ncur_ver.pal_version_s.pv_pal_a_model,\r\ncur_ver.pal_version_s.pv_pal_a_rev,\r\nmin_ver.pal_version_s.pv_pal_a_model,\r\nmin_ver.pal_version_s.pv_pal_a_rev,\r\ncur_ver.pal_version_s.pv_pal_b_model,\r\ncur_ver.pal_version_s.pv_pal_b_rev,\r\nmin_ver.pal_version_s.pv_pal_b_model,\r\nmin_ver.pal_version_s.pv_pal_b_rev);\r\nreturn p - page;\r\n}\r\nstatic int\r\nperfmon_info(char *page)\r\n{\r\nchar *p = page;\r\nu64 pm_buffer[16];\r\npal_perf_mon_info_u_t pm_info;\r\nif (ia64_pal_perf_mon_info(pm_buffer, &pm_info) != 0) return 0;\r\np += sprintf(p,\r\n"PMC/PMD pairs : %d\n"\r\n"Counter width : %d bits\n"\r\n"Cycle event number : %d\n"\r\n"Retired event number : %d\n"\r\n"Implemented PMC : ",\r\npm_info.pal_perf_mon_info_s.generic, pm_info.pal_perf_mon_info_s.width,\r\npm_info.pal_perf_mon_info_s.cycles, pm_info.pal_perf_mon_info_s.retired);\r\np = bitregister_process(p, pm_buffer, 256);\r\np += sprintf(p, "\nImplemented PMD : ");\r\np = bitregister_process(p, pm_buffer+4, 256);\r\np += sprintf(p, "\nCycles count capable : ");\r\np = bitregister_process(p, pm_buffer+8, 256);\r\np += sprintf(p, "\nRetired bundles count capable : ");\r\n#ifdef CONFIG_ITANIUM\r\nif (pm_buffer[12] == 0x10) pm_buffer[12]=0x30;\r\n#endif\r\np = bitregister_process(p, pm_buffer+12, 256);\r\np += sprintf(p, "\n");\r\nreturn p - page;\r\n}\r\nstatic int\r\nfrequency_info(char *page)\r\n{\r\nchar *p = page;\r\nstruct pal_freq_ratio proc, itc, bus;\r\nunsigned long base;\r\nif (ia64_pal_freq_base(&base) == -1)\r\np += sprintf(p, "Output clock : not implemented\n");\r\nelse\r\np += sprintf(p, "Output clock : %ld ticks/s\n", base);\r\nif (ia64_pal_freq_ratios(&proc, &bus, &itc) != 0) return 0;\r\np += sprintf(p,\r\n"Processor/Clock ratio : %d/%d\n"\r\n"Bus/Clock ratio : %d/%d\n"\r\n"ITC/Clock ratio : %d/%d\n",\r\nproc.num, proc.den, bus.num, bus.den, itc.num, itc.den);\r\nreturn p - page;\r\n}\r\nstatic int\r\ntr_info(char *page)\r\n{\r\nchar *p = page;\r\nlong status;\r\npal_tr_valid_u_t tr_valid;\r\nu64 tr_buffer[4];\r\npal_vm_info_1_u_t vm_info_1;\r\npal_vm_info_2_u_t vm_info_2;\r\nunsigned long i, j;\r\nunsigned long max[3], pgm;\r\nstruct ifa_reg {\r\nunsigned long valid:1;\r\nunsigned long ig:11;\r\nunsigned long vpn:52;\r\n} *ifa_reg;\r\nstruct itir_reg {\r\nunsigned long rv1:2;\r\nunsigned long ps:6;\r\nunsigned long key:24;\r\nunsigned long rv2:32;\r\n} *itir_reg;\r\nstruct gr_reg {\r\nunsigned long p:1;\r\nunsigned long rv1:1;\r\nunsigned long ma:3;\r\nunsigned long a:1;\r\nunsigned long d:1;\r\nunsigned long pl:2;\r\nunsigned long ar:3;\r\nunsigned long ppn:38;\r\nunsigned long rv2:2;\r\nunsigned long ed:1;\r\nunsigned long ig:11;\r\n} *gr_reg;\r\nstruct rid_reg {\r\nunsigned long ig1:1;\r\nunsigned long rv1:1;\r\nunsigned long ig2:6;\r\nunsigned long rid:24;\r\nunsigned long rv2:32;\r\n} *rid_reg;\r\nif ((status = ia64_pal_vm_summary(&vm_info_1, &vm_info_2)) !=0) {\r\nprintk(KERN_ERR "ia64_pal_vm_summary=%ld\n", status);\r\nreturn 0;\r\n}\r\nmax[0] = vm_info_1.pal_vm_info_1_s.max_itr_entry+1;\r\nmax[1] = vm_info_1.pal_vm_info_1_s.max_dtr_entry+1;\r\nfor (i=0; i < 2; i++ ) {\r\nfor (j=0; j < max[i]; j++) {\r\nstatus = ia64_pal_tr_read(j, i, tr_buffer, &tr_valid);\r\nif (status != 0) {\r\nprintk(KERN_ERR "palinfo: pal call failed on tr[%lu:%lu]=%ld\n",\r\ni, j, status);\r\ncontinue;\r\n}\r\nifa_reg = (struct ifa_reg *)&tr_buffer[2];\r\nif (ifa_reg->valid == 0) continue;\r\ngr_reg = (struct gr_reg *)tr_buffer;\r\nitir_reg = (struct itir_reg *)&tr_buffer[1];\r\nrid_reg = (struct rid_reg *)&tr_buffer[3];\r\npgm = -1 << (itir_reg->ps - 12);\r\np += sprintf(p,\r\n"%cTR%lu: av=%d pv=%d dv=%d mv=%d\n"\r\n"\tppn : 0x%lx\n"\r\n"\tvpn : 0x%lx\n"\r\n"\tps : ",\r\n"ID"[i], j,\r\ntr_valid.pal_tr_valid_s.access_rights_valid,\r\ntr_valid.pal_tr_valid_s.priv_level_valid,\r\ntr_valid.pal_tr_valid_s.dirty_bit_valid,\r\ntr_valid.pal_tr_valid_s.mem_attr_valid,\r\n(gr_reg->ppn & pgm)<< 12, (ifa_reg->vpn & pgm)<< 12);\r\np = bitvector_process(p, 1<< itir_reg->ps);\r\np += sprintf(p,\r\n"\n\tpl : %d\n"\r\n"\tar : %d\n"\r\n"\trid : %x\n"\r\n"\tp : %d\n"\r\n"\tma : %d\n"\r\n"\td : %d\n",\r\ngr_reg->pl, gr_reg->ar, rid_reg->rid, gr_reg->p, gr_reg->ma,\r\ngr_reg->d);\r\n}\r\n}\r\nreturn p - page;\r\n}\r\nstatic void\r\npalinfo_smp_call(void *info)\r\n{\r\npalinfo_smp_data_t *data = (palinfo_smp_data_t *)info;\r\ndata->ret = (*data->func)(data->page);\r\n}\r\nstatic\r\nint palinfo_handle_smp(pal_func_cpu_u_t *f, char *page)\r\n{\r\npalinfo_smp_data_t ptr;\r\nint ret;\r\nptr.func = palinfo_entries[f->func_id].proc_read;\r\nptr.page = page;\r\nptr.ret = 0;\r\nif ((ret=smp_call_function_single(f->req_cpu, palinfo_smp_call, &ptr, 1))) {\r\nprintk(KERN_ERR "palinfo: remote CPU call from %d to %d on function %d: "\r\n"error %d\n", smp_processor_id(), f->req_cpu, f->func_id, ret);\r\nreturn 0;\r\n}\r\nreturn ptr.ret;\r\n}\r\nstatic\r\nint palinfo_handle_smp(pal_func_cpu_u_t *f, char *page)\r\n{\r\nprintk(KERN_ERR "palinfo: should not be called with non SMP kernel\n");\r\nreturn 0;\r\n}\r\nstatic int\r\npalinfo_read_entry(char *page, char **start, off_t off, int count, int *eof, void *data)\r\n{\r\nint len=0;\r\npal_func_cpu_u_t *f = (pal_func_cpu_u_t *)&data;\r\nif (f->req_cpu == get_cpu())\r\nlen = (*palinfo_entries[f->func_id].proc_read)(page);\r\nelse\r\nlen = palinfo_handle_smp(f, page);\r\nput_cpu();\r\nif (len <= off+count) *eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len>count) len = count;\r\nif (len<0) len = 0;\r\nreturn len;\r\n}\r\nstatic void __cpuinit\r\ncreate_palinfo_proc_entries(unsigned int cpu)\r\n{\r\n# define CPUSTR "cpu%d"\r\npal_func_cpu_u_t f;\r\nstruct proc_dir_entry **pdir;\r\nstruct proc_dir_entry *cpu_dir;\r\nint j;\r\nchar cpustr[sizeof(CPUSTR)];\r\nsprintf(cpustr,CPUSTR, cpu);\r\ncpu_dir = proc_mkdir(cpustr, palinfo_dir);\r\nf.req_cpu = cpu;\r\npdir = &palinfo_proc_entries[cpu*(NR_PALINFO_ENTRIES+1)];\r\n*pdir++ = cpu_dir;\r\nfor (j=0; j < NR_PALINFO_ENTRIES; j++) {\r\nf.func_id = j;\r\n*pdir = create_proc_read_entry(\r\npalinfo_entries[j].name, 0, cpu_dir,\r\npalinfo_read_entry, (void *)f.value);\r\npdir++;\r\n}\r\n}\r\nstatic void\r\nremove_palinfo_proc_entries(unsigned int hcpu)\r\n{\r\nint j;\r\nstruct proc_dir_entry *cpu_dir, **pdir;\r\npdir = &palinfo_proc_entries[hcpu*(NR_PALINFO_ENTRIES+1)];\r\ncpu_dir = *pdir;\r\n*pdir++=NULL;\r\nfor (j=0; j < (NR_PALINFO_ENTRIES); j++) {\r\nif ((*pdir)) {\r\nremove_proc_entry ((*pdir)->name, cpu_dir);\r\n*pdir ++= NULL;\r\n}\r\n}\r\nif (cpu_dir) {\r\nremove_proc_entry(cpu_dir->name, palinfo_dir);\r\n}\r\n}\r\nstatic int __cpuinit palinfo_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int hotcpu = (unsigned long)hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\ncreate_palinfo_proc_entries(hotcpu);\r\nbreak;\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nremove_palinfo_proc_entries(hotcpu);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init\r\npalinfo_init(void)\r\n{\r\nint i = 0;\r\nprintk(KERN_INFO "PAL Information Facility v%s\n", PALINFO_VERSION);\r\npalinfo_dir = proc_mkdir("pal", NULL);\r\nfor_each_online_cpu(i) {\r\ncreate_palinfo_proc_entries(i);\r\n}\r\nregister_hotcpu_notifier(&palinfo_cpu_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\npalinfo_exit(void)\r\n{\r\nint i = 0;\r\nfor_each_online_cpu(i) {\r\nremove_palinfo_proc_entries(i);\r\n}\r\nremove_proc_entry(palinfo_dir->name, NULL);\r\nunregister_hotcpu_notifier(&palinfo_cpu_notifier);\r\n}
