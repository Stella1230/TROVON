static inline const struct xc5000_fw_cfg *xc5000_assign_firmware(int chip_id)\r\n{\r\nswitch (chip_id) {\r\ndefault:\r\ncase XC5000A:\r\nreturn &xc5000a_1_6_114;\r\ncase XC5000C:\r\nreturn &xc5000c_41_024_5;\r\n}\r\n}\r\nstatic int xc_send_i2c_data(struct xc5000_priv *priv, u8 *buf, int len)\r\n{\r\nstruct i2c_msg msg = { .addr = priv->i2c_props.addr,\r\n.flags = 0, .buf = buf, .len = len };\r\nif (i2c_transfer(priv->i2c_props.adap, &msg, 1) != 1) {\r\nprintk(KERN_ERR "xc5000: I2C write failed (len=%i)\n", len);\r\nreturn XC_RESULT_I2C_WRITE_FAILURE;\r\n}\r\nreturn XC_RESULT_SUCCESS;\r\n}\r\nstatic int xc5000_readreg(struct xc5000_priv *priv, u16 reg, u16 *val)\r\n{\r\nu8 buf[2] = { reg >> 8, reg & 0xff };\r\nu8 bval[2] = { 0, 0 };\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = priv->i2c_props.addr,\r\n.flags = 0, .buf = &buf[0], .len = 2 },\r\n{ .addr = priv->i2c_props.addr,\r\n.flags = I2C_M_RD, .buf = &bval[0], .len = 2 },\r\n};\r\nif (i2c_transfer(priv->i2c_props.adap, msg, 2) != 2) {\r\nprintk(KERN_WARNING "xc5000: I2C read failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\n*val = (bval[0] << 8) | bval[1];\r\nreturn XC_RESULT_SUCCESS;\r\n}\r\nstatic void xc_wait(int wait_ms)\r\n{\r\nmsleep(wait_ms);\r\n}\r\nstatic int xc5000_TunerReset(struct dvb_frontend *fe)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint ret;\r\ndprintk(1, "%s()\n", __func__);\r\nif (fe->callback) {\r\nret = fe->callback(((fe->dvb) && (fe->dvb->priv)) ?\r\nfe->dvb->priv :\r\npriv->i2c_props.adap->algo_data,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nXC5000_TUNER_RESET, 0);\r\nif (ret) {\r\nprintk(KERN_ERR "xc5000: reset failed\n");\r\nreturn XC_RESULT_RESET_FAILURE;\r\n}\r\n} else {\r\nprintk(KERN_ERR "xc5000: no tuner reset callback function, fatal\n");\r\nreturn XC_RESULT_RESET_FAILURE;\r\n}\r\nreturn XC_RESULT_SUCCESS;\r\n}\r\nstatic int xc_write_reg(struct xc5000_priv *priv, u16 regAddr, u16 i2cData)\r\n{\r\nu8 buf[4];\r\nint WatchDogTimer = 100;\r\nint result;\r\nbuf[0] = (regAddr >> 8) & 0xFF;\r\nbuf[1] = regAddr & 0xFF;\r\nbuf[2] = (i2cData >> 8) & 0xFF;\r\nbuf[3] = i2cData & 0xFF;\r\nresult = xc_send_i2c_data(priv, buf, 4);\r\nif (result == XC_RESULT_SUCCESS) {\r\nwhile ((WatchDogTimer > 0) && (result == XC_RESULT_SUCCESS)) {\r\nresult = xc5000_readreg(priv, XREG_BUSY, (u16 *)buf);\r\nif (result == XC_RESULT_SUCCESS) {\r\nif ((buf[0] == 0) && (buf[1] == 0)) {\r\nbreak;\r\n} else {\r\nxc_wait(5);\r\nWatchDogTimer--;\r\n}\r\n}\r\n}\r\n}\r\nif (WatchDogTimer <= 0)\r\nresult = XC_RESULT_I2C_WRITE_FAILURE;\r\nreturn result;\r\n}\r\nstatic int xc_load_i2c_sequence(struct dvb_frontend *fe, const u8 *i2c_sequence)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint i, nbytes_to_send, result;\r\nunsigned int len, pos, index;\r\nu8 buf[XC_MAX_I2C_WRITE_LENGTH];\r\nindex = 0;\r\nwhile ((i2c_sequence[index] != 0xFF) ||\r\n(i2c_sequence[index + 1] != 0xFF)) {\r\nlen = i2c_sequence[index] * 256 + i2c_sequence[index+1];\r\nif (len == 0x0000) {\r\nresult = xc5000_TunerReset(fe);\r\nindex += 2;\r\nif (result != XC_RESULT_SUCCESS)\r\nreturn result;\r\n} else if (len & 0x8000) {\r\nxc_wait(len & 0x7FFF);\r\nindex += 2;\r\n} else {\r\nindex += 2;\r\nbuf[0] = i2c_sequence[index];\r\nbuf[1] = i2c_sequence[index + 1];\r\npos = 2;\r\nwhile (pos < len) {\r\nif ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)\r\nnbytes_to_send =\r\nXC_MAX_I2C_WRITE_LENGTH;\r\nelse\r\nnbytes_to_send = (len - pos + 2);\r\nfor (i = 2; i < nbytes_to_send; i++) {\r\nbuf[i] = i2c_sequence[index + pos +\r\ni - 2];\r\n}\r\nresult = xc_send_i2c_data(priv, buf,\r\nnbytes_to_send);\r\nif (result != XC_RESULT_SUCCESS)\r\nreturn result;\r\npos += nbytes_to_send - 2;\r\n}\r\nindex += len;\r\n}\r\n}\r\nreturn XC_RESULT_SUCCESS;\r\n}\r\nstatic int xc_initialize(struct xc5000_priv *priv)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nreturn xc_write_reg(priv, XREG_INIT, 0);\r\n}\r\nstatic int xc_SetTVStandard(struct xc5000_priv *priv,\r\nu16 VideoMode, u16 AudioMode)\r\n{\r\nint ret;\r\ndprintk(1, "%s(0x%04x,0x%04x)\n", __func__, VideoMode, AudioMode);\r\ndprintk(1, "%s() Standard = %s\n",\r\n__func__,\r\nXC5000_Standard[priv->video_standard].Name);\r\nret = xc_write_reg(priv, XREG_VIDEO_MODE, VideoMode);\r\nif (ret == XC_RESULT_SUCCESS)\r\nret = xc_write_reg(priv, XREG_AUDIO_MODE, AudioMode);\r\nreturn ret;\r\n}\r\nstatic int xc_SetSignalSource(struct xc5000_priv *priv, u16 rf_mode)\r\n{\r\ndprintk(1, "%s(%d) Source = %s\n", __func__, rf_mode,\r\nrf_mode == XC_RF_MODE_AIR ? "ANTENNA" : "CABLE");\r\nif ((rf_mode != XC_RF_MODE_AIR) && (rf_mode != XC_RF_MODE_CABLE)) {\r\nrf_mode = XC_RF_MODE_CABLE;\r\nprintk(KERN_ERR\r\n"%s(), Invalid mode, defaulting to CABLE",\r\n__func__);\r\n}\r\nreturn xc_write_reg(priv, XREG_SIGNALSOURCE, rf_mode);\r\n}\r\nstatic int xc_set_RF_frequency(struct xc5000_priv *priv, u32 freq_hz)\r\n{\r\nu16 freq_code;\r\ndprintk(1, "%s(%u)\n", __func__, freq_hz);\r\nif ((freq_hz > xc5000_tuner_ops.info.frequency_max) ||\r\n(freq_hz < xc5000_tuner_ops.info.frequency_min))\r\nreturn XC_RESULT_OUT_OF_RANGE;\r\nfreq_code = (u16)(freq_hz / 15625);\r\nreturn xc_write_reg(priv, XREG_FINERFREQ, freq_code);\r\n}\r\nstatic int xc_set_IF_frequency(struct xc5000_priv *priv, u32 freq_khz)\r\n{\r\nu32 freq_code = (freq_khz * 1024)/1000;\r\ndprintk(1, "%s(freq_khz = %d) freq_code = 0x%x\n",\r\n__func__, freq_khz, freq_code);\r\nreturn xc_write_reg(priv, XREG_IF_OUT, freq_code);\r\n}\r\nstatic int xc_get_ADC_Envelope(struct xc5000_priv *priv, u16 *adc_envelope)\r\n{\r\nreturn xc5000_readreg(priv, XREG_ADC_ENV, adc_envelope);\r\n}\r\nstatic int xc_get_frequency_error(struct xc5000_priv *priv, u32 *freq_error_hz)\r\n{\r\nint result;\r\nu16 regData;\r\nu32 tmp;\r\nresult = xc5000_readreg(priv, XREG_FREQ_ERROR, &regData);\r\nif (result != XC_RESULT_SUCCESS)\r\nreturn result;\r\ntmp = (u32)regData;\r\n(*freq_error_hz) = (tmp * 15625) / 1000;\r\nreturn result;\r\n}\r\nstatic int xc_get_lock_status(struct xc5000_priv *priv, u16 *lock_status)\r\n{\r\nreturn xc5000_readreg(priv, XREG_LOCK, lock_status);\r\n}\r\nstatic int xc_get_version(struct xc5000_priv *priv,\r\nu8 *hw_majorversion, u8 *hw_minorversion,\r\nu8 *fw_majorversion, u8 *fw_minorversion)\r\n{\r\nu16 data;\r\nint result;\r\nresult = xc5000_readreg(priv, XREG_VERSION, &data);\r\nif (result != XC_RESULT_SUCCESS)\r\nreturn result;\r\n(*hw_majorversion) = (data >> 12) & 0x0F;\r\n(*hw_minorversion) = (data >> 8) & 0x0F;\r\n(*fw_majorversion) = (data >> 4) & 0x0F;\r\n(*fw_minorversion) = data & 0x0F;\r\nreturn 0;\r\n}\r\nstatic int xc_get_buildversion(struct xc5000_priv *priv, u16 *buildrev)\r\n{\r\nreturn xc5000_readreg(priv, XREG_BUILD, buildrev);\r\n}\r\nstatic int xc_get_hsync_freq(struct xc5000_priv *priv, u32 *hsync_freq_hz)\r\n{\r\nu16 regData;\r\nint result;\r\nresult = xc5000_readreg(priv, XREG_HSYNC_FREQ, &regData);\r\nif (result != XC_RESULT_SUCCESS)\r\nreturn result;\r\n(*hsync_freq_hz) = ((regData & 0x0fff) * 763)/100;\r\nreturn result;\r\n}\r\nstatic int xc_get_frame_lines(struct xc5000_priv *priv, u16 *frame_lines)\r\n{\r\nreturn xc5000_readreg(priv, XREG_FRAME_LINES, frame_lines);\r\n}\r\nstatic int xc_get_quality(struct xc5000_priv *priv, u16 *quality)\r\n{\r\nreturn xc5000_readreg(priv, XREG_QUALITY, quality);\r\n}\r\nstatic int xc_get_analogsnr(struct xc5000_priv *priv, u16 *snr)\r\n{\r\nreturn xc5000_readreg(priv, XREG_SNR, snr);\r\n}\r\nstatic int xc_get_totalgain(struct xc5000_priv *priv, u16 *totalgain)\r\n{\r\nreturn xc5000_readreg(priv, XREG_TOTALGAIN, totalgain);\r\n}\r\nstatic u16 WaitForLock(struct xc5000_priv *priv)\r\n{\r\nu16 lockState = 0;\r\nint watchDogCount = 40;\r\nwhile ((lockState == 0) && (watchDogCount > 0)) {\r\nxc_get_lock_status(priv, &lockState);\r\nif (lockState != 1) {\r\nxc_wait(5);\r\nwatchDogCount--;\r\n}\r\n}\r\nreturn lockState;\r\n}\r\nstatic int xc_tune_channel(struct xc5000_priv *priv, u32 freq_hz, int mode)\r\n{\r\nint found = 0;\r\ndprintk(1, "%s(%u)\n", __func__, freq_hz);\r\nif (xc_set_RF_frequency(priv, freq_hz) != XC_RESULT_SUCCESS)\r\nreturn 0;\r\nif (mode == XC_TUNE_ANALOG) {\r\nif (WaitForLock(priv) == 1)\r\nfound = 1;\r\n}\r\nreturn found;\r\n}\r\nstatic int xc_set_xtal(struct dvb_frontend *fe)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint ret = XC_RESULT_SUCCESS;\r\nswitch (priv->chip_id) {\r\ndefault:\r\ncase XC5000A:\r\nbreak;\r\ncase XC5000C:\r\nswitch (priv->xtal_khz) {\r\ndefault:\r\ncase 32000:\r\nbreak;\r\ncase 31875:\r\nret = xc_write_reg(priv, 0x000f, 0x8081);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int xc5000_fwupload(struct dvb_frontend *fe)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nconst struct firmware *fw;\r\nint ret;\r\nconst struct xc5000_fw_cfg *desired_fw =\r\nxc5000_assign_firmware(priv->chip_id);\r\npriv->pll_register_no = desired_fw->pll_reg;\r\npriv->init_status_supported = desired_fw->init_status_supported;\r\npriv->fw_checksum_supported = desired_fw->fw_checksum_supported;\r\nprintk(KERN_INFO "xc5000: waiting for firmware upload (%s)...\n",\r\ndesired_fw->name);\r\nret = request_firmware(&fw, desired_fw->name,\r\npriv->i2c_props.adap->dev.parent);\r\nif (ret) {\r\nprintk(KERN_ERR "xc5000: Upload failed. (file not found?)\n");\r\nret = XC_RESULT_RESET_FAILURE;\r\ngoto out;\r\n} else {\r\nprintk(KERN_DEBUG "xc5000: firmware read %Zu bytes.\n",\r\nfw->size);\r\nret = XC_RESULT_SUCCESS;\r\n}\r\nif (fw->size != desired_fw->size) {\r\nprintk(KERN_ERR "xc5000: firmware incorrect size\n");\r\nret = XC_RESULT_RESET_FAILURE;\r\n} else {\r\nprintk(KERN_INFO "xc5000: firmware uploading...\n");\r\nret = xc_load_i2c_sequence(fe, fw->data);\r\nif (XC_RESULT_SUCCESS == ret)\r\nret = xc_set_xtal(fe);\r\nif (XC_RESULT_SUCCESS == ret)\r\nprintk(KERN_INFO "xc5000: firmware upload complete...\n");\r\nelse\r\nprintk(KERN_ERR "xc5000: firmware upload failed...\n");\r\n}\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic void xc_debug_dump(struct xc5000_priv *priv)\r\n{\r\nu16 adc_envelope;\r\nu32 freq_error_hz = 0;\r\nu16 lock_status;\r\nu32 hsync_freq_hz = 0;\r\nu16 frame_lines;\r\nu16 quality;\r\nu16 snr;\r\nu16 totalgain;\r\nu8 hw_majorversion = 0, hw_minorversion = 0;\r\nu8 fw_majorversion = 0, fw_minorversion = 0;\r\nu16 fw_buildversion = 0;\r\nu16 regval;\r\nxc_wait(100);\r\nxc_get_ADC_Envelope(priv, &adc_envelope);\r\ndprintk(1, "*** ADC envelope (0-1023) = %d\n", adc_envelope);\r\nxc_get_frequency_error(priv, &freq_error_hz);\r\ndprintk(1, "*** Frequency error = %d Hz\n", freq_error_hz);\r\nxc_get_lock_status(priv, &lock_status);\r\ndprintk(1, "*** Lock status (0-Wait, 1-Locked, 2-No-signal) = %d\n",\r\nlock_status);\r\nxc_get_version(priv, &hw_majorversion, &hw_minorversion,\r\n&fw_majorversion, &fw_minorversion);\r\nxc_get_buildversion(priv, &fw_buildversion);\r\ndprintk(1, "*** HW: V%d.%d, FW: V %d.%d.%d\n",\r\nhw_majorversion, hw_minorversion,\r\nfw_majorversion, fw_minorversion, fw_buildversion);\r\nxc_get_hsync_freq(priv, &hsync_freq_hz);\r\ndprintk(1, "*** Horizontal sync frequency = %d Hz\n", hsync_freq_hz);\r\nxc_get_frame_lines(priv, &frame_lines);\r\ndprintk(1, "*** Frame lines = %d\n", frame_lines);\r\nxc_get_quality(priv, &quality);\r\ndprintk(1, "*** Quality (0:<8dB, 7:>56dB) = %d\n", quality & 0x07);\r\nxc_get_analogsnr(priv, &snr);\r\ndprintk(1, "*** Unweighted analog SNR = %d dB\n", snr & 0x3f);\r\nxc_get_totalgain(priv, &totalgain);\r\ndprintk(1, "*** Total gain = %d.%d dB\n", totalgain / 256,\r\n(totalgain % 256) * 100 / 256);\r\nif (priv->pll_register_no) {\r\nxc5000_readreg(priv, priv->pll_register_no, &regval);\r\ndprintk(1, "*** PLL lock status = 0x%04x\n", regval);\r\n}\r\n}\r\nstatic int xc5000_set_params(struct dvb_frontend *fe)\r\n{\r\nint ret, b;\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nu32 freq = fe->dtv_property_cache.frequency;\r\nu32 delsys = fe->dtv_property_cache.delivery_system;\r\nif (xc_load_fw_and_init_tuner(fe, 0) != XC_RESULT_SUCCESS) {\r\ndprintk(1, "Unable to load firmware and init tuner\n");\r\nreturn -EINVAL;\r\n}\r\ndprintk(1, "%s() frequency=%d (Hz)\n", __func__, freq);\r\nswitch (delsys) {\r\ncase SYS_ATSC:\r\ndprintk(1, "%s() VSB modulation\n", __func__);\r\npriv->rf_mode = XC_RF_MODE_AIR;\r\npriv->freq_hz = freq - 1750000;\r\npriv->video_standard = DTV6;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_B:\r\ndprintk(1, "%s() QAM modulation\n", __func__);\r\npriv->rf_mode = XC_RF_MODE_CABLE;\r\npriv->freq_hz = freq - 1750000;\r\npriv->video_standard = DTV6;\r\nbreak;\r\ncase SYS_ISDBT:\r\nif (!bw)\r\nbw = 6000000;\r\ncase SYS_DMBTH:\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\ndprintk(1, "%s() OFDM\n", __func__);\r\nswitch (bw) {\r\ncase 6000000:\r\npriv->video_standard = DTV6;\r\npriv->freq_hz = freq - 1750000;\r\nbreak;\r\ncase 7000000:\r\npriv->video_standard = DTV7;\r\npriv->freq_hz = freq - 2250000;\r\nbreak;\r\ncase 8000000:\r\npriv->video_standard = DTV8;\r\npriv->freq_hz = freq - 2750000;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "xc5000 bandwidth not set!\n");\r\nreturn -EINVAL;\r\n}\r\npriv->rf_mode = XC_RF_MODE_AIR;\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\ndprintk(1, "%s() QAM modulation\n", __func__);\r\npriv->rf_mode = XC_RF_MODE_CABLE;\r\nif (bw <= 6000000) {\r\npriv->video_standard = DTV6;\r\npriv->freq_hz = freq - 1750000;\r\nb = 6;\r\n} else if (bw <= 7000000) {\r\npriv->video_standard = DTV7;\r\npriv->freq_hz = freq - 2250000;\r\nb = 7;\r\n} else {\r\npriv->video_standard = DTV7_8;\r\npriv->freq_hz = freq - 2750000;\r\nb = 8;\r\n}\r\ndprintk(1, "%s() Bandwidth %dMHz (%d)\n", __func__,\r\nb, bw);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "xc5000: delivery system is not supported!\n");\r\nreturn -EINVAL;\r\n}\r\ndprintk(1, "%s() frequency=%d (compensated to %d)\n",\r\n__func__, freq, priv->freq_hz);\r\nret = xc_SetSignalSource(priv, priv->rf_mode);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR\r\n"xc5000: xc_SetSignalSource(%d) failed\n",\r\npriv->rf_mode);\r\nreturn -EREMOTEIO;\r\n}\r\nret = xc_SetTVStandard(priv,\r\nXC5000_Standard[priv->video_standard].VideoMode,\r\nXC5000_Standard[priv->video_standard].AudioMode);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR "xc5000: xc_SetTVStandard failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nret = xc_set_IF_frequency(priv, priv->if_khz);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR "xc5000: xc_Set_IF_frequency(%d) failed\n",\r\npriv->if_khz);\r\nreturn -EIO;\r\n}\r\nxc_write_reg(priv, XREG_OUTPUT_AMP, 0x8a);\r\nxc_tune_channel(priv, priv->freq_hz, XC_TUNE_DIGITAL);\r\nif (debug)\r\nxc_debug_dump(priv);\r\npriv->bandwidth = bw;\r\nreturn 0;\r\n}\r\nstatic int xc5000_is_firmware_loaded(struct dvb_frontend *fe)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu16 id;\r\nret = xc5000_readreg(priv, XREG_PRODUCT_ID, &id);\r\nif (ret == XC_RESULT_SUCCESS) {\r\nif (id == XC_PRODUCT_ID_FW_NOT_LOADED)\r\nret = XC_RESULT_RESET_FAILURE;\r\nelse\r\nret = XC_RESULT_SUCCESS;\r\n}\r\ndprintk(1, "%s() returns %s id = 0x%x\n", __func__,\r\nret == XC_RESULT_SUCCESS ? "True" : "False", id);\r\nreturn ret;\r\n}\r\nstatic int xc5000_set_tv_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nu16 pll_lock_status;\r\nint ret;\r\ndprintk(1, "%s() frequency=%d (in units of 62.5khz)\n",\r\n__func__, params->frequency);\r\npriv->rf_mode = params->mode;\r\nif (params->mode > XC_RF_MODE_CABLE)\r\npriv->rf_mode = XC_RF_MODE_CABLE;\r\npriv->freq_hz = params->frequency * 62500;\r\nif (params->std & V4L2_STD_MN) {\r\npriv->video_standard = MN_NTSC_PAL_BTSC;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_PAL_BG) {\r\npriv->video_standard = BG_PAL_NICAM;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_PAL_I) {\r\npriv->video_standard = I_PAL_NICAM;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_PAL_DK) {\r\npriv->video_standard = DK_PAL_NICAM;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_SECAM_DK) {\r\npriv->video_standard = DK_SECAM_A2DK1;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_SECAM_L) {\r\npriv->video_standard = L_SECAM_NICAM;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_SECAM_LC) {\r\npriv->video_standard = LC_SECAM_NICAM;\r\ngoto tune_channel;\r\n}\r\ntune_channel:\r\nret = xc_SetSignalSource(priv, priv->rf_mode);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR\r\n"xc5000: xc_SetSignalSource(%d) failed\n",\r\npriv->rf_mode);\r\nreturn -EREMOTEIO;\r\n}\r\nret = xc_SetTVStandard(priv,\r\nXC5000_Standard[priv->video_standard].VideoMode,\r\nXC5000_Standard[priv->video_standard].AudioMode);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR "xc5000: xc_SetTVStandard failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nxc_write_reg(priv, XREG_OUTPUT_AMP, 0x09);\r\nxc_tune_channel(priv, priv->freq_hz, XC_TUNE_ANALOG);\r\nif (debug)\r\nxc_debug_dump(priv);\r\nif (priv->pll_register_no != 0) {\r\nmsleep(20);\r\nxc5000_readreg(priv, priv->pll_register_no, &pll_lock_status);\r\nif (pll_lock_status > 63) {\r\ndprintk(1, "xc5000: PLL not locked (0x%x). Reloading...\n",\r\npll_lock_status);\r\nif (xc_load_fw_and_init_tuner(fe, 1) != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR "xc5000: Unable to reload fw\n");\r\nreturn -EREMOTEIO;\r\n}\r\ngoto tune_channel;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xc5000_set_radio_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint ret = -EINVAL;\r\nu8 radio_input;\r\ndprintk(1, "%s() frequency=%d (in units of khz)\n",\r\n__func__, params->frequency);\r\nif (priv->radio_input == XC5000_RADIO_NOT_CONFIGURED) {\r\ndprintk(1, "%s() radio input not configured\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (priv->radio_input == XC5000_RADIO_FM1)\r\nradio_input = FM_Radio_INPUT1;\r\nelse if (priv->radio_input == XC5000_RADIO_FM2)\r\nradio_input = FM_Radio_INPUT2;\r\nelse if (priv->radio_input == XC5000_RADIO_FM1_MONO)\r\nradio_input = FM_Radio_INPUT1_MONO;\r\nelse {\r\ndprintk(1, "%s() unknown radio input %d\n", __func__,\r\npriv->radio_input);\r\nreturn -EINVAL;\r\n}\r\npriv->freq_hz = params->frequency * 125 / 2;\r\npriv->rf_mode = XC_RF_MODE_AIR;\r\nret = xc_SetTVStandard(priv, XC5000_Standard[radio_input].VideoMode,\r\nXC5000_Standard[radio_input].AudioMode);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR "xc5000: xc_SetTVStandard failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nret = xc_SetSignalSource(priv, priv->rf_mode);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR\r\n"xc5000: xc_SetSignalSource(%d) failed\n",\r\npriv->rf_mode);\r\nreturn -EREMOTEIO;\r\n}\r\nif ((priv->radio_input == XC5000_RADIO_FM1) ||\r\n(priv->radio_input == XC5000_RADIO_FM2))\r\nxc_write_reg(priv, XREG_OUTPUT_AMP, 0x09);\r\nelse if (priv->radio_input == XC5000_RADIO_FM1_MONO)\r\nxc_write_reg(priv, XREG_OUTPUT_AMP, 0x06);\r\nxc_tune_channel(priv, priv->freq_hz, XC_TUNE_ANALOG);\r\nreturn 0;\r\n}\r\nstatic int xc5000_set_analog_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint ret = -EINVAL;\r\nif (priv->i2c_props.adap == NULL)\r\nreturn -EINVAL;\r\nif (xc_load_fw_and_init_tuner(fe, 0) != XC_RESULT_SUCCESS) {\r\ndprintk(1, "Unable to load firmware and init tuner\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (params->mode) {\r\ncase V4L2_TUNER_RADIO:\r\nret = xc5000_set_radio_freq(fe, params);\r\nbreak;\r\ncase V4L2_TUNER_ANALOG_TV:\r\ncase V4L2_TUNER_DIGITAL_TV:\r\nret = xc5000_set_tv_freq(fe, params);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int xc5000_get_frequency(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\n*freq = priv->freq_hz;\r\nreturn 0;\r\n}\r\nstatic int xc5000_get_if_frequency(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\n*freq = priv->if_khz * 1000;\r\nreturn 0;\r\n}\r\nstatic int xc5000_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\n*bw = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int xc5000_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nu16 lock_status = 0;\r\nxc_get_lock_status(priv, &lock_status);\r\ndprintk(1, "%s() lock_status = 0x%08x\n", __func__, lock_status);\r\n*status = lock_status;\r\nreturn 0;\r\n}\r\nstatic int xc_load_fw_and_init_tuner(struct dvb_frontend *fe, int force)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nint ret = XC_RESULT_SUCCESS;\r\nu16 pll_lock_status;\r\nu16 fw_ck;\r\nif (force || xc5000_is_firmware_loaded(fe) != XC_RESULT_SUCCESS) {\r\nfw_retry:\r\nret = xc5000_fwupload(fe);\r\nif (ret != XC_RESULT_SUCCESS)\r\nreturn ret;\r\nmsleep(20);\r\nif (priv->fw_checksum_supported) {\r\nif (xc5000_readreg(priv, XREG_FW_CHECKSUM, &fw_ck)\r\n!= XC_RESULT_SUCCESS) {\r\ndprintk(1, "%s() FW checksum reading failed.\n",\r\n__func__);\r\ngoto fw_retry;\r\n}\r\nif (fw_ck == 0) {\r\ndprintk(1, "%s() FW checksum failed = 0x%04x\n",\r\n__func__, fw_ck);\r\ngoto fw_retry;\r\n}\r\n}\r\nret |= xc_initialize(priv);\r\nif (ret != XC_RESULT_SUCCESS)\r\ngoto fw_retry;\r\nxc_wait(100);\r\nif (priv->init_status_supported) {\r\nif (xc5000_readreg(priv, XREG_INIT_STATUS, &fw_ck) != XC_RESULT_SUCCESS) {\r\ndprintk(1, "%s() FW failed reading init status.\n",\r\n__func__);\r\ngoto fw_retry;\r\n}\r\nif (fw_ck == 0) {\r\ndprintk(1, "%s() FW init status failed = 0x%04x\n", __func__, fw_ck);\r\ngoto fw_retry;\r\n}\r\n}\r\nif (priv->pll_register_no) {\r\nxc5000_readreg(priv, priv->pll_register_no,\r\n&pll_lock_status);\r\nif (pll_lock_status > 63) {\r\nprintk(KERN_ERR "xc5000: PLL not running after fwload.\n");\r\ngoto fw_retry;\r\n}\r\n}\r\nret |= xc_write_reg(priv, XREG_SIGNALSOURCE, XC_RF_MODE_CABLE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int xc5000_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\ndprintk(1, "%s()\n", __func__);\r\nif (no_poweroff)\r\nreturn 0;\r\nret = xc5000_TunerReset(fe);\r\nif (ret != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR\r\n"xc5000: %s() unable to shutdown tuner\n",\r\n__func__);\r\nreturn -EREMOTEIO;\r\n} else\r\nreturn XC_RESULT_SUCCESS;\r\n}\r\nstatic int xc5000_init(struct dvb_frontend *fe)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\nif (xc_load_fw_and_init_tuner(fe, 0) != XC_RESULT_SUCCESS) {\r\nprintk(KERN_ERR "xc5000: Unable to initialise tuner\n");\r\nreturn -EREMOTEIO;\r\n}\r\nif (debug)\r\nxc_debug_dump(priv);\r\nreturn 0;\r\n}\r\nstatic int xc5000_release(struct dvb_frontend *fe)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\nmutex_lock(&xc5000_list_mutex);\r\nif (priv)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&xc5000_list_mutex);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int xc5000_set_config(struct dvb_frontend *fe, void *priv_cfg)\r\n{\r\nstruct xc5000_priv *priv = fe->tuner_priv;\r\nstruct xc5000_config *p = priv_cfg;\r\ndprintk(1, "%s()\n", __func__);\r\nif (p->if_khz)\r\npriv->if_khz = p->if_khz;\r\nif (p->radio_input)\r\npriv->radio_input = p->radio_input;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *xc5000_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c,\r\nconst struct xc5000_config *cfg)\r\n{\r\nstruct xc5000_priv *priv = NULL;\r\nint instance;\r\nu16 id = 0;\r\ndprintk(1, "%s(%d-%04x)\n", __func__,\r\ni2c ? i2c_adapter_id(i2c) : -1,\r\ncfg ? cfg->i2c_address : -1);\r\nmutex_lock(&xc5000_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct xc5000_priv, priv,\r\nhybrid_tuner_instance_list,\r\ni2c, cfg->i2c_address, "xc5000");\r\nswitch (instance) {\r\ncase 0:\r\ngoto fail;\r\nbreak;\r\ncase 1:\r\npriv->bandwidth = 6000000;\r\nfe->tuner_priv = priv;\r\nbreak;\r\ndefault:\r\nfe->tuner_priv = priv;\r\nbreak;\r\n}\r\nif (priv->if_khz == 0) {\r\npriv->if_khz = cfg->if_khz;\r\n}\r\nif (priv->xtal_khz == 0)\r\npriv->xtal_khz = cfg->xtal_khz;\r\nif (priv->radio_input == 0)\r\npriv->radio_input = cfg->radio_input;\r\nif ((priv->chip_id == 0) || (cfg->chip_id))\r\npriv->chip_id = (cfg->chip_id) ? cfg->chip_id : 0;\r\nif (xc5000_readreg(priv, XREG_PRODUCT_ID, &id) != XC_RESULT_SUCCESS)\r\ngoto fail;\r\nswitch (id) {\r\ncase XC_PRODUCT_ID_FW_LOADED:\r\nprintk(KERN_INFO\r\n"xc5000: Successfully identified at address 0x%02x\n",\r\ncfg->i2c_address);\r\nprintk(KERN_INFO\r\n"xc5000: Firmware has been loaded previously\n");\r\nbreak;\r\ncase XC_PRODUCT_ID_FW_NOT_LOADED:\r\nprintk(KERN_INFO\r\n"xc5000: Successfully identified at address 0x%02x\n",\r\ncfg->i2c_address);\r\nprintk(KERN_INFO\r\n"xc5000: Firmware has not been loaded previously\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"xc5000: Device not found at addr 0x%02x (0x%x)\n",\r\ncfg->i2c_address, id);\r\ngoto fail;\r\n}\r\nmutex_unlock(&xc5000_list_mutex);\r\nmemcpy(&fe->ops.tuner_ops, &xc5000_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\nfail:\r\nmutex_unlock(&xc5000_list_mutex);\r\nxc5000_release(fe);\r\nreturn NULL;\r\n}
