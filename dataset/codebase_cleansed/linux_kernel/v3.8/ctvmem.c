static struct ct_vm_block *\r\nget_vm_block(struct ct_vm *vm, unsigned int size)\r\n{\r\nstruct ct_vm_block *block = NULL, *entry;\r\nstruct list_head *pos;\r\nsize = CT_PAGE_ALIGN(size);\r\nif (size > vm->size) {\r\nprintk(KERN_ERR "ctxfi: Fail! No sufficient device virtual "\r\n"memory space available!\n");\r\nreturn NULL;\r\n}\r\nmutex_lock(&vm->lock);\r\nlist_for_each(pos, &vm->unused) {\r\nentry = list_entry(pos, struct ct_vm_block, list);\r\nif (entry->size >= size)\r\nbreak;\r\n}\r\nif (pos == &vm->unused)\r\ngoto out;\r\nif (entry->size == size) {\r\nlist_move(&entry->list, &vm->used);\r\nvm->size -= size;\r\nblock = entry;\r\ngoto out;\r\n}\r\nblock = kzalloc(sizeof(*block), GFP_KERNEL);\r\nif (!block)\r\ngoto out;\r\nblock->addr = entry->addr;\r\nblock->size = size;\r\nlist_add(&block->list, &vm->used);\r\nentry->addr += size;\r\nentry->size -= size;\r\nvm->size -= size;\r\nout:\r\nmutex_unlock(&vm->lock);\r\nreturn block;\r\n}\r\nstatic void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)\r\n{\r\nstruct ct_vm_block *entry, *pre_ent;\r\nstruct list_head *pos, *pre;\r\nblock->size = CT_PAGE_ALIGN(block->size);\r\nmutex_lock(&vm->lock);\r\nlist_del(&block->list);\r\nvm->size += block->size;\r\nlist_for_each(pos, &vm->unused) {\r\nentry = list_entry(pos, struct ct_vm_block, list);\r\nif (entry->addr >= (block->addr + block->size))\r\nbreak;\r\n}\r\nif (pos == &vm->unused) {\r\nlist_add_tail(&block->list, &vm->unused);\r\nentry = block;\r\n} else {\r\nif ((block->addr + block->size) == entry->addr) {\r\nentry->addr = block->addr;\r\nentry->size += block->size;\r\nkfree(block);\r\n} else {\r\n__list_add(&block->list, pos->prev, pos);\r\nentry = block;\r\n}\r\n}\r\npos = &entry->list;\r\npre = pos->prev;\r\nwhile (pre != &vm->unused) {\r\nentry = list_entry(pos, struct ct_vm_block, list);\r\npre_ent = list_entry(pre, struct ct_vm_block, list);\r\nif ((pre_ent->addr + pre_ent->size) > entry->addr)\r\nbreak;\r\npre_ent->size += entry->size;\r\nlist_del(pos);\r\nkfree(entry);\r\npos = pre;\r\npre = pos->prev;\r\n}\r\nmutex_unlock(&vm->lock);\r\n}\r\nstatic struct ct_vm_block *\r\nct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)\r\n{\r\nstruct ct_vm_block *block;\r\nunsigned int pte_start;\r\nunsigned i, pages;\r\nunsigned long *ptp;\r\nblock = get_vm_block(vm, size);\r\nif (block == NULL) {\r\nprintk(KERN_ERR "ctxfi: No virtual memory block that is big "\r\n"enough to allocate!\n");\r\nreturn NULL;\r\n}\r\nptp = (unsigned long *)vm->ptp[0].area;\r\npte_start = (block->addr >> CT_PAGE_SHIFT);\r\npages = block->size >> CT_PAGE_SHIFT;\r\nfor (i = 0; i < pages; i++) {\r\nunsigned long addr;\r\naddr = snd_pcm_sgbuf_get_addr(substream, i << CT_PAGE_SHIFT);\r\nptp[pte_start + i] = addr;\r\n}\r\nblock->size = size;\r\nreturn block;\r\n}\r\nstatic void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)\r\n{\r\nput_vm_block(vm, block);\r\n}\r\nstatic dma_addr_t\r\nct_get_ptp_phys(struct ct_vm *vm, int index)\r\n{\r\ndma_addr_t addr;\r\naddr = (index >= CT_PTP_NUM) ? ~0UL : vm->ptp[index].addr;\r\nreturn addr;\r\n}\r\nint ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci)\r\n{\r\nstruct ct_vm *vm;\r\nstruct ct_vm_block *block;\r\nint i, err = 0;\r\n*rvm = NULL;\r\nvm = kzalloc(sizeof(*vm), GFP_KERNEL);\r\nif (!vm)\r\nreturn -ENOMEM;\r\nmutex_init(&vm->lock);\r\nfor (i = 0; i < CT_PTP_NUM; i++) {\r\nerr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(pci),\r\nPAGE_SIZE, &vm->ptp[i]);\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (err < 0) {\r\nct_vm_destroy(vm);\r\nreturn -ENOMEM;\r\n}\r\nvm->size = CT_ADDRS_PER_PAGE * i;\r\nvm->map = ct_vm_map;\r\nvm->unmap = ct_vm_unmap;\r\nvm->get_ptp_phys = ct_get_ptp_phys;\r\nINIT_LIST_HEAD(&vm->unused);\r\nINIT_LIST_HEAD(&vm->used);\r\nblock = kzalloc(sizeof(*block), GFP_KERNEL);\r\nif (NULL != block) {\r\nblock->addr = 0;\r\nblock->size = vm->size;\r\nlist_add(&block->list, &vm->unused);\r\n}\r\n*rvm = vm;\r\nreturn 0;\r\n}\r\nvoid ct_vm_destroy(struct ct_vm *vm)\r\n{\r\nint i;\r\nstruct list_head *pos;\r\nstruct ct_vm_block *entry;\r\nwhile (!list_empty(&vm->used)) {\r\npos = vm->used.next;\r\nlist_del(pos);\r\nentry = list_entry(pos, struct ct_vm_block, list);\r\nkfree(entry);\r\n}\r\nwhile (!list_empty(&vm->unused)) {\r\npos = vm->unused.next;\r\nlist_del(pos);\r\nentry = list_entry(pos, struct ct_vm_block, list);\r\nkfree(entry);\r\n}\r\nfor (i = 0; i < CT_PTP_NUM; i++)\r\nsnd_dma_free_pages(&vm->ptp[i]);\r\nvm->size = 0;\r\nkfree(vm);\r\n}
