static unsigned int elanfreq_get_cpu_frequency(unsigned int cpu)\r\n{\r\nu8 clockspeed_reg;\r\nlocal_irq_disable();\r\noutb_p(0x80, REG_CSCIR);\r\nclockspeed_reg = inb_p(REG_CSCDR);\r\nlocal_irq_enable();\r\nif ((clockspeed_reg & 0xE0) == 0xE0)\r\nreturn 0;\r\nif ((clockspeed_reg & 0xE0) == 0xC0) {\r\nif ((clockspeed_reg & 0x01) == 0)\r\nreturn 66000;\r\nelse\r\nreturn 99000;\r\n}\r\nif ((clockspeed_reg & 0xE0) == 0xA0)\r\nreturn 33000;\r\nreturn (1<<((clockspeed_reg & 0xE0) >> 5)) * 1000;\r\n}\r\nstatic void elanfreq_set_cpu_state(unsigned int state)\r\n{\r\nstruct cpufreq_freqs freqs;\r\nfreqs.old = elanfreq_get_cpu_frequency(0);\r\nfreqs.new = elan_multiplier[state].clock;\r\nfreqs.cpu = 0;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\nprintk(KERN_INFO "elanfreq: attempting to set frequency to %i kHz\n",\r\nelan_multiplier[state].clock);\r\nlocal_irq_disable();\r\noutb_p(0x40, REG_CSCIR);\r\noutb_p(0x00, REG_CSCDR);\r\nlocal_irq_enable();\r\nudelay(1000);\r\nlocal_irq_disable();\r\noutb_p(0x80, REG_CSCIR);\r\noutb_p(elan_multiplier[state].val80h, REG_CSCDR);\r\noutb_p(0x40, REG_CSCIR);\r\noutb_p(elan_multiplier[state].val40h, REG_CSCDR);\r\nudelay(10000);\r\nlocal_irq_enable();\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nstatic int elanfreq_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy, &elanfreq_table[0]);\r\n}\r\nstatic int elanfreq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int newstate = 0;\r\nif (cpufreq_frequency_table_target(policy, &elanfreq_table[0],\r\ntarget_freq, relation, &newstate))\r\nreturn -EINVAL;\r\nelanfreq_set_cpu_state(newstate);\r\nreturn 0;\r\n}\r\nstatic int elanfreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nunsigned int i;\r\nint result;\r\nif ((c->x86_vendor != X86_VENDOR_AMD) ||\r\n(c->x86 != 4) || (c->x86_model != 10))\r\nreturn -ENODEV;\r\nif (!max_freq)\r\nmax_freq = elanfreq_get_cpu_frequency(0);\r\nfor (i = 0; (elanfreq_table[i].frequency != CPUFREQ_TABLE_END); i++) {\r\nif (elanfreq_table[i].frequency > max_freq)\r\nelanfreq_table[i].frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\npolicy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;\r\npolicy->cur = elanfreq_get_cpu_frequency(0);\r\nresult = cpufreq_frequency_table_cpuinfo(policy, elanfreq_table);\r\nif (result)\r\nreturn result;\r\ncpufreq_frequency_table_get_attr(elanfreq_table, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int elanfreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int __init elanfreq_setup(char *str)\r\n{\r\nmax_freq = simple_strtoul(str, &str, 0);\r\nprintk(KERN_WARNING "You're using the deprecated elanfreq command line option. Use elanfreq.max_freq instead, please!\n");\r\nreturn 1;\r\n}\r\nstatic int __init elanfreq_init(void)\r\n{\r\nif (!x86_match_cpu(elan_id))\r\nreturn -ENODEV;\r\nreturn cpufreq_register_driver(&elanfreq_driver);\r\n}\r\nstatic void __exit elanfreq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&elanfreq_driver);\r\n}
