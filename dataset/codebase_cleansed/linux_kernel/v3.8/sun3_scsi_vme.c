static inline unsigned char sun3scsi_read(int reg)\r\n{\r\nreturn( sun3_scsi_regp[reg] );\r\n}\r\nstatic inline void sun3scsi_write(int reg, int value)\r\n{\r\nsun3_scsi_regp[reg] = value;\r\n}\r\nstatic int __init sun3scsi_detect(struct scsi_host_template * tpnt)\r\n{\r\nunsigned long ioaddr, irq = 0;\r\nstatic int called = 0;\r\nstruct Scsi_Host *instance;\r\nint i;\r\nunsigned long addrs[3] = { IOBASE_SUN3_VMESCSI,\r\nIOBASE_SUN3_VMESCSI + 0x4000,\r\n0 };\r\nunsigned long vecs[3] = { SUN3_VEC_VMESCSI0,\r\nSUN3_VEC_VMESCSI1,\r\n0 };\r\nswitch(idprom->id_machtype) {\r\ncase SM_SUN3|SM_3_160:\r\ncase SM_SUN3|SM_3_260:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif(called)\r\nreturn 0;\r\ntpnt->proc_name = "Sun3 5380 VME SCSI";\r\ntpnt->can_queue =\r\n(setup_can_queue > 0) ? setup_can_queue : CAN_QUEUE;\r\ntpnt->cmd_per_lun =\r\n(setup_cmd_per_lun > 0) ? setup_cmd_per_lun : CMD_PER_LUN;\r\ntpnt->sg_tablesize =\r\n(setup_sg_tablesize >= 0) ? setup_sg_tablesize : SG_TABLESIZE;\r\nif (setup_hostid >= 0)\r\ntpnt->this_id = setup_hostid;\r\nelse {\r\ntpnt->this_id = 7;\r\n}\r\nioaddr = 0;\r\nfor(i = 0; addrs[i] != 0; i++) {\r\nunsigned char x;\r\nioaddr = (unsigned long)sun3_ioremap(addrs[i], PAGE_SIZE,\r\nSUN3_PAGE_TYPE_VME16);\r\nirq = vecs[i];\r\nsun3_scsi_regp = (unsigned char *)ioaddr;\r\ndregs = (struct sun3_dma_regs *)(((unsigned char *)ioaddr) + 8);\r\nif(sun3_map_test((unsigned long)dregs, &x)) {\r\nunsigned short oldcsr;\r\noldcsr = dregs->csr;\r\ndregs->csr = 0;\r\nudelay(SUN3_DMA_DELAY);\r\nif(dregs->csr == 0x1400)\r\nbreak;\r\ndregs->csr = oldcsr;\r\n}\r\niounmap((void *)ioaddr);\r\nioaddr = 0;\r\n}\r\nif(!ioaddr)\r\nreturn 0;\r\n#ifdef SUPPORT_TAGS\r\nif (setup_use_tagged_queuing < 0)\r\nsetup_use_tagged_queuing = USE_TAGGED_QUEUING;\r\n#endif\r\ninstance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));\r\nif(instance == NULL)\r\nreturn 0;\r\ndefault_instance = instance;\r\ninstance->io_port = (unsigned long) ioaddr;\r\ninstance->irq = irq;\r\nNCR5380_init(instance, 0);\r\ninstance->n_io_port = 32;\r\n((struct NCR5380_hostdata *)instance->hostdata)->ctrl = 0;\r\nif (request_irq(instance->irq, scsi_sun3_intr,\r\n0, "Sun3SCSI-5380VME", instance)) {\r\n#ifndef REAL_DMA\r\nprintk("scsi%d: IRQ%d not free, interrupts disabled\n",\r\ninstance->host_no, instance->irq);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n#else\r\nprintk("scsi%d: IRQ%d not free, bailing out\n",\r\ninstance->host_no, instance->irq);\r\nreturn 0;\r\n#endif\r\n}\r\nprintk("scsi%d: Sun3 5380 VME at port %lX irq", instance->host_no, instance->io_port);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nprintk ("s disabled");\r\nelse\r\nprintk (" %d", instance->irq);\r\nprintk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",\r\ninstance->can_queue, instance->cmd_per_lun,\r\nSUN3SCSI_PUBLIC_RELEASE);\r\nprintk("\nscsi%d:", instance->host_no);\r\nNCR5380_print_options(instance);\r\nprintk("\n");\r\ndregs->csr = 0;\r\nudelay(SUN3_DMA_DELAY);\r\ndregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;\r\nudelay(SUN3_DMA_DELAY);\r\ndregs->fifo_count = 0;\r\ndregs->fifo_count_hi = 0;\r\ndregs->dma_addr_hi = 0;\r\ndregs->dma_addr_lo = 0;\r\ndregs->dma_count_hi = 0;\r\ndregs->dma_count_lo = 0;\r\ndregs->ivect = VME_DATA24 | (instance->irq & 0xff);\r\ncalled = 1;\r\n#ifdef RESET_BOOT\r\nsun3_scsi_reset_boot(instance);\r\n#endif\r\nreturn 1;\r\n}\r\nint sun3scsi_release (struct Scsi_Host *shpnt)\r\n{\r\nif (shpnt->irq != SCSI_IRQ_NONE)\r\nfree_irq(shpnt->irq, shpnt);\r\niounmap((void *)sun3_scsi_regp);\r\nNCR5380_exit(shpnt);\r\nreturn 0;\r\n}\r\nstatic void sun3_scsi_reset_boot(struct Scsi_Host *instance)\r\n{\r\nunsigned long end;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nprintk( "Sun3 SCSI: resetting the SCSI bus..." );\r\nNCR5380_write( TARGET_COMMAND_REG,\r\nPHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));\r\nNCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );\r\nudelay( 50 );\r\nNCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );\r\nNCR5380_read( RESET_PARITY_INTERRUPT_REG );\r\nfor( end = jiffies + AFTER_RESET_DELAY; time_before(jiffies, end); )\r\nbarrier();\r\nprintk( " done\n" );\r\n}\r\nstatic const char * sun3scsi_info (struct Scsi_Host *spnt) {\r\nreturn "";\r\n}\r\nstatic irqreturn_t scsi_sun3_intr(int irq, void *dummy)\r\n{\r\nunsigned short csr = dregs->csr;\r\nint handled = 0;\r\ndregs->csr &= ~CSR_DMA_ENABLE;\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi_intr csr %x\n", csr);\r\n#endif\r\nif(csr & ~CSR_GOOD) {\r\nif(csr & CSR_DMA_BUSERR) {\r\nprintk("scsi%d: bus error in dma\n", default_instance->host_no);\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi: residual %x count %x addr %p dmaaddr %x\n",\r\ndregs->fifo_count,\r\ndregs->dma_count_lo | (dregs->dma_count_hi << 16),\r\nsun3_dma_orig_addr,\r\ndregs->dma_addr_lo | (dregs->dma_addr_hi << 16));\r\n#endif\r\n}\r\nif(csr & CSR_DMA_CONFLICT) {\r\nprintk("scsi%d: dma conflict\n", default_instance->host_no);\r\n}\r\nhandled = 1;\r\n}\r\nif(csr & (CSR_SDB_INT | CSR_DMA_INT)) {\r\nNCR5380_intr(irq, dummy);\r\nhandled = 1;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int write_flag)\r\n{\r\nvoid *addr;\r\nif(sun3_dma_orig_addr != NULL)\r\ndvma_unmap(sun3_dma_orig_addr);\r\naddr = (void *)dvma_map_vme((unsigned long) data, count);\r\nsun3_dma_orig_addr = addr;\r\nsun3_dma_orig_count = count;\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi: dma_setup addr %p count %x\n", addr, count);\r\n#endif\r\n#if 0\r\ndregs->csr &= ~CSR_FIFO;\r\ndregs->csr |= CSR_FIFO;\r\n#endif\r\nif(write_flag)\r\ndregs->csr |= CSR_SEND;\r\nelse\r\ndregs->csr &= ~CSR_SEND;\r\ndregs->csr |= CSR_PACK_ENABLE;\r\ndregs->dma_addr_hi = ((unsigned long)addr >> 16);\r\ndregs->dma_addr_lo = ((unsigned long)addr & 0xffff);\r\ndregs->dma_count_hi = 0;\r\ndregs->dma_count_lo = 0;\r\ndregs->fifo_count_hi = 0;\r\ndregs->fifo_count = 0;\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi: dma_setup done csr %x\n", dregs->csr);\r\n#endif\r\nreturn count;\r\n}\r\nstatic inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)\r\n{\r\nreturn last_residual;\r\n}\r\nstatic inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,\r\nstruct scsi_cmnd *cmd,\r\nint write_flag)\r\n{\r\nif (cmd->request->cmd_type == REQ_TYPE_FS)\r\nreturn wanted;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int sun3scsi_dma_start(unsigned long count, char *data)\r\n{\r\nunsigned short csr;\r\ncsr = dregs->csr;\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi: dma_start data %p count %x csr %x fifo %x\n", data, count, csr, dregs->fifo_count);\r\n#endif\r\ndregs->dma_count_hi = (sun3_dma_orig_count >> 16);\r\ndregs->dma_count_lo = (sun3_dma_orig_count & 0xffff);\r\ndregs->fifo_count_hi = (sun3_dma_orig_count >> 16);\r\ndregs->fifo_count = (sun3_dma_orig_count & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int sun3scsi_dma_finish(int write_flag)\r\n{\r\nunsigned short fifo;\r\nint ret = 0;\r\nsun3_dma_active = 0;\r\ndregs->csr &= ~CSR_DMA_ENABLE;\r\nfifo = dregs->fifo_count;\r\nif(write_flag) {\r\nif((fifo > 0) && (fifo < sun3_dma_orig_count))\r\nfifo++;\r\n}\r\nlast_residual = fifo;\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi: residual %x total %x\n", fifo, sun3_dma_orig_count);\r\n#endif\r\nif((!write_flag) && (dregs->csr & CSR_LEFT)) {\r\nunsigned char *vaddr;\r\n#ifdef SUN3_SCSI_DEBUG\r\nprintk("scsi: got left over bytes\n");\r\n#endif\r\nvaddr = (unsigned char *)dvma_vmetov(sun3_dma_orig_addr);\r\nvaddr += (sun3_dma_orig_count - fifo);\r\nvaddr--;\r\nswitch(dregs->csr & CSR_LEFT) {\r\ncase CSR_LEFT_3:\r\n*vaddr = (dregs->bpack_lo & 0xff00) >> 8;\r\nvaddr--;\r\ncase CSR_LEFT_2:\r\n*vaddr = (dregs->bpack_hi & 0x00ff);\r\nvaddr--;\r\ncase CSR_LEFT_1:\r\n*vaddr = (dregs->bpack_hi & 0xff00) >> 8;\r\nbreak;\r\n}\r\n}\r\ndvma_unmap(sun3_dma_orig_addr);\r\nsun3_dma_orig_addr = NULL;\r\ndregs->dma_addr_hi = 0;\r\ndregs->dma_addr_lo = 0;\r\ndregs->dma_count_hi = 0;\r\ndregs->dma_count_lo = 0;\r\ndregs->fifo_count = 0;\r\ndregs->fifo_count_hi = 0;\r\ndregs->csr &= ~CSR_SEND;\r\n#if 0\r\ndregs->csr &= ~CSR_FIFO;\r\ndregs->csr |= CSR_FIFO;\r\n#endif\r\nsun3_dma_setup_done = NULL;\r\nreturn ret;\r\n}
