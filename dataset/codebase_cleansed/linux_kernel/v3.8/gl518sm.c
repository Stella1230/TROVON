static inline u8 FAN_TO_REG(long rpm, int div)\r\n{\r\nlong rpmdiv;\r\nif (rpm == 0)\r\nreturn 0;\r\nrpmdiv = SENSORS_LIMIT(rpm, 1, 960000) * div;\r\nreturn SENSORS_LIMIT((480000 + rpmdiv / 2) / rpmdiv, 1, 255);\r\n}\r\nstatic ssize_t show_fan_input(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct gl518_data *data = gl518_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_in[nr],\r\nDIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct gl518_data *data = gl518_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct gl518_data *data = gl518_update_device(dev);\r\nreturn sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct gl518_data *data = i2c_get_clientdata(client);\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nint regvalue;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nregvalue = gl518_read_value(client, GL518_REG_FAN_LIMIT);\r\ndata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nregvalue = (regvalue & (0xff << (8 * nr)))\r\n| (data->fan_min[nr] << (8 * (1 - nr)));\r\ngl518_write_value(client, GL518_REG_FAN_LIMIT, regvalue);\r\ndata->beep_mask = gl518_read_value(client, GL518_REG_ALARM);\r\nif (data->fan_min[nr] == 0)\r\ndata->alarm_mask &= ~(0x20 << nr);\r\nelse\r\ndata->alarm_mask |= (0x20 << nr);\r\ndata->beep_mask &= data->alarm_mask;\r\ngl518_write_value(client, GL518_REG_ALARM, data->beep_mask);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct gl518_data *data = i2c_get_clientdata(client);\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nint regvalue;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nswitch (val) {\r\ncase 1:\r\nval = 0;\r\nbreak;\r\ncase 2:\r\nval = 1;\r\nbreak;\r\ncase 4:\r\nval = 2;\r\nbreak;\r\ncase 8:\r\nval = 3;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid fan clock divider %lu, choose one "\r\n"of 1, 2, 4 or 8\n", val);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nregvalue = gl518_read_value(client, GL518_REG_MISC);\r\ndata->fan_div[nr] = val;\r\nregvalue = (regvalue & ~(0xc0 >> (2 * nr)))\r\n| (data->fan_div[nr] << (6 - 2 * nr));\r\ngl518_write_value(client, GL518_REG_MISC, regvalue);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nstruct gl518_data *data = gl518_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nstruct gl518_data *data = gl518_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->beep_mask >> bitnr) & 1);\r\n}\r\nstatic ssize_t set_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct gl518_data *data = i2c_get_clientdata(client);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nunsigned long bit;\r\nint err;\r\nerr = kstrtoul(buf, 10, &bit);\r\nif (err)\r\nreturn err;\r\nif (bit & ~1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->beep_mask = gl518_read_value(client, GL518_REG_ALARM);\r\nif (bit)\r\ndata->beep_mask |= (1 << bitnr);\r\nelse\r\ndata->beep_mask &= ~(1 << bitnr);\r\ngl518_write_value(client, GL518_REG_ALARM, data->beep_mask);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int gl518_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint rev;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\nif ((gl518_read_value(client, GL518_REG_CHIP_ID) != 0x80)\r\n|| (gl518_read_value(client, GL518_REG_CONF) & 0x80))\r\nreturn -ENODEV;\r\nrev = gl518_read_value(client, GL518_REG_REVISION);\r\nif (rev != 0x00 && rev != 0x80)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "gl518sm", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int gl518_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct gl518_data *data;\r\nint err, revision;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct gl518_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nrevision = gl518_read_value(client, GL518_REG_REVISION);\r\ndata->type = revision == 0x80 ? gl518sm_r80 : gl518sm_r00;\r\nmutex_init(&data->update_lock);\r\ndata->alarm_mask = 0xff;\r\ngl518_init_client(client);\r\nerr = sysfs_create_group(&client->dev.kobj, &gl518_group);\r\nif (err)\r\nreturn err;\r\nif (data->type == gl518sm_r80) {\r\nerr = sysfs_create_group(&client->dev.kobj, &gl518_group_r80);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&client->dev.kobj, &gl518_group);\r\nif (data->type == gl518sm_r80)\r\nsysfs_remove_group(&client->dev.kobj, &gl518_group_r80);\r\nreturn err;\r\n}\r\nstatic void gl518_init_client(struct i2c_client *client)\r\n{\r\nu8 regvalue = gl518_read_value(client, GL518_REG_CONF) & 0x7f;\r\ngl518_write_value(client, GL518_REG_CONF, (regvalue &= 0x37));\r\ngl518_write_value(client, GL518_REG_MASK, 0x00);\r\ngl518_write_value(client, GL518_REG_CONF, 0x20 | regvalue);\r\ngl518_write_value(client, GL518_REG_CONF, 0x40 | regvalue);\r\n}\r\nstatic int gl518_remove(struct i2c_client *client)\r\n{\r\nstruct gl518_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &gl518_group);\r\nif (data->type == gl518sm_r80)\r\nsysfs_remove_group(&client->dev.kobj, &gl518_group_r80);\r\nreturn 0;\r\n}\r\nstatic int gl518_read_value(struct i2c_client *client, u8 reg)\r\n{\r\nif ((reg >= 0x07) && (reg <= 0x0c))\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\nelse\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int gl518_write_value(struct i2c_client *client, u8 reg, u16 value)\r\n{\r\nif ((reg >= 0x07) && (reg <= 0x0c))\r\nreturn i2c_smbus_write_word_swapped(client, reg, value);\r\nelse\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic struct gl518_data *gl518_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct gl518_data *data = i2c_get_clientdata(client);\r\nint val;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\ndev_dbg(&client->dev, "Starting gl518 update\n");\r\ndata->alarms = gl518_read_value(client, GL518_REG_INT);\r\ndata->beep_mask = gl518_read_value(client, GL518_REG_ALARM);\r\nval = gl518_read_value(client, GL518_REG_VDD_LIMIT);\r\ndata->voltage_min[0] = val & 0xff;\r\ndata->voltage_max[0] = (val >> 8) & 0xff;\r\nval = gl518_read_value(client, GL518_REG_VIN1_LIMIT);\r\ndata->voltage_min[1] = val & 0xff;\r\ndata->voltage_max[1] = (val >> 8) & 0xff;\r\nval = gl518_read_value(client, GL518_REG_VIN2_LIMIT);\r\ndata->voltage_min[2] = val & 0xff;\r\ndata->voltage_max[2] = (val >> 8) & 0xff;\r\nval = gl518_read_value(client, GL518_REG_VIN3_LIMIT);\r\ndata->voltage_min[3] = val & 0xff;\r\ndata->voltage_max[3] = (val >> 8) & 0xff;\r\nval = gl518_read_value(client, GL518_REG_FAN_COUNT);\r\ndata->fan_in[0] = (val >> 8) & 0xff;\r\ndata->fan_in[1] = val & 0xff;\r\nval = gl518_read_value(client, GL518_REG_FAN_LIMIT);\r\ndata->fan_min[0] = (val >> 8) & 0xff;\r\ndata->fan_min[1] = val & 0xff;\r\ndata->temp_in = gl518_read_value(client, GL518_REG_TEMP_IN);\r\ndata->temp_max =\r\ngl518_read_value(client, GL518_REG_TEMP_MAX);\r\ndata->temp_hyst =\r\ngl518_read_value(client, GL518_REG_TEMP_HYST);\r\nval = gl518_read_value(client, GL518_REG_MISC);\r\ndata->fan_div[0] = (val >> 6) & 0x03;\r\ndata->fan_div[1] = (val >> 4) & 0x03;\r\ndata->fan_auto1 = (val >> 3) & 0x01;\r\ndata->alarms &= data->alarm_mask;\r\nval = gl518_read_value(client, GL518_REG_CONF);\r\ndata->beep_enable = (val >> 2) & 1;\r\nif (data->type != gl518sm_r00) {\r\ndata->voltage_in[0] =\r\ngl518_read_value(client, GL518_REG_VDD);\r\ndata->voltage_in[1] =\r\ngl518_read_value(client, GL518_REG_VIN1);\r\ndata->voltage_in[2] =\r\ngl518_read_value(client, GL518_REG_VIN2);\r\n}\r\ndata->voltage_in[3] =\r\ngl518_read_value(client, GL518_REG_VIN3);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
