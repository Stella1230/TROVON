static inline const char *fc_exch_name_lookup(unsigned int op, char **table,\r\nunsigned int max_index)\r\n{\r\nconst char *name = NULL;\r\nif (op < max_index)\r\nname = table[op];\r\nif (!name)\r\nname = "unknown";\r\nreturn name;\r\n}\r\nstatic const char *fc_exch_rctl_name(unsigned int op)\r\n{\r\nreturn fc_exch_name_lookup(op, fc_exch_rctl_names,\r\nARRAY_SIZE(fc_exch_rctl_names));\r\n}\r\nstatic inline void fc_exch_hold(struct fc_exch *ep)\r\n{\r\natomic_inc(&ep->ex_refcnt);\r\n}\r\nstatic void fc_exch_setup_hdr(struct fc_exch *ep, struct fc_frame *fp,\r\nu32 f_ctl)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nu16 fill;\r\nfr_sof(fp) = ep->class;\r\nif (ep->seq.cnt)\r\nfr_sof(fp) = fc_sof_normal(ep->class);\r\nif (f_ctl & FC_FC_END_SEQ) {\r\nfr_eof(fp) = FC_EOF_T;\r\nif (fc_sof_needs_ack(ep->class))\r\nfr_eof(fp) = FC_EOF_N;\r\nfill = fr_len(fp) & 3;\r\nif (fill) {\r\nfill = 4 - fill;\r\nskb_put(fp_skb(fp), fill);\r\nhton24(fh->fh_f_ctl, f_ctl | fill);\r\n}\r\n} else {\r\nWARN_ON(fr_len(fp) % 4 != 0);\r\nfr_eof(fp) = FC_EOF_N;\r\n}\r\nfh->fh_ox_id = htons(ep->oxid);\r\nfh->fh_rx_id = htons(ep->rxid);\r\nfh->fh_seq_id = ep->seq.id;\r\nfh->fh_seq_cnt = htons(ep->seq.cnt);\r\n}\r\nstatic void fc_exch_release(struct fc_exch *ep)\r\n{\r\nstruct fc_exch_mgr *mp;\r\nif (atomic_dec_and_test(&ep->ex_refcnt)) {\r\nmp = ep->em;\r\nif (ep->destructor)\r\nep->destructor(&ep->seq, ep->arg);\r\nWARN_ON(!(ep->esb_stat & ESB_ST_COMPLETE));\r\nmempool_free(ep, mp->ep_pool);\r\n}\r\n}\r\nstatic inline void fc_exch_timer_cancel(struct fc_exch *ep)\r\n{\r\nif (cancel_delayed_work(&ep->timeout_work)) {\r\nFC_EXCH_DBG(ep, "Exchange timer canceled\n");\r\natomic_dec(&ep->ex_refcnt);\r\n}\r\n}\r\nstatic inline void fc_exch_timer_set_locked(struct fc_exch *ep,\r\nunsigned int timer_msec)\r\n{\r\nif (ep->state & (FC_EX_RST_CLEANUP | FC_EX_DONE))\r\nreturn;\r\nFC_EXCH_DBG(ep, "Exchange timer armed : %d msecs\n", timer_msec);\r\nif (queue_delayed_work(fc_exch_workqueue, &ep->timeout_work,\r\nmsecs_to_jiffies(timer_msec)))\r\nfc_exch_hold(ep);\r\n}\r\nstatic void fc_exch_timer_set(struct fc_exch *ep, unsigned int timer_msec)\r\n{\r\nspin_lock_bh(&ep->ex_lock);\r\nfc_exch_timer_set_locked(ep, timer_msec);\r\nspin_unlock_bh(&ep->ex_lock);\r\n}\r\nstatic int fc_exch_done_locked(struct fc_exch *ep)\r\n{\r\nint rc = 1;\r\nep->resp = NULL;\r\nif (ep->state & FC_EX_DONE)\r\nreturn rc;\r\nep->esb_stat |= ESB_ST_COMPLETE;\r\nif (!(ep->esb_stat & ESB_ST_REC_QUAL)) {\r\nep->state |= FC_EX_DONE;\r\nfc_exch_timer_cancel(ep);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline struct fc_exch *fc_exch_ptr_get(struct fc_exch_pool *pool,\r\nu16 index)\r\n{\r\nstruct fc_exch **exches = (struct fc_exch **)(pool + 1);\r\nreturn exches[index];\r\n}\r\nstatic inline void fc_exch_ptr_set(struct fc_exch_pool *pool, u16 index,\r\nstruct fc_exch *ep)\r\n{\r\n((struct fc_exch **)(pool + 1))[index] = ep;\r\n}\r\nstatic void fc_exch_delete(struct fc_exch *ep)\r\n{\r\nstruct fc_exch_pool *pool;\r\nu16 index;\r\npool = ep->pool;\r\nspin_lock_bh(&pool->lock);\r\nWARN_ON(pool->total_exches <= 0);\r\npool->total_exches--;\r\nindex = (ep->xid - ep->em->min_xid) >> fc_cpu_order;\r\nif (pool->left == FC_XID_UNKNOWN)\r\npool->left = index;\r\nelse if (pool->right == FC_XID_UNKNOWN)\r\npool->right = index;\r\nelse\r\npool->next_index = index;\r\nfc_exch_ptr_set(pool, index, NULL);\r\nlist_del(&ep->ex_list);\r\nspin_unlock_bh(&pool->lock);\r\nfc_exch_release(ep);\r\n}\r\nstatic int fc_seq_send(struct fc_lport *lport, struct fc_seq *sp,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_exch *ep;\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nint error;\r\nu32 f_ctl;\r\nu8 fh_type = fh->fh_type;\r\nep = fc_seq_exch(sp);\r\nWARN_ON((ep->esb_stat & ESB_ST_SEQ_INIT) != ESB_ST_SEQ_INIT);\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nfc_exch_setup_hdr(ep, fp, f_ctl);\r\nfr_encaps(fp) = ep->encaps;\r\nif (fr_max_payload(fp))\r\nsp->cnt += DIV_ROUND_UP((fr_len(fp) - sizeof(*fh)),\r\nfr_max_payload(fp));\r\nelse\r\nsp->cnt++;\r\nerror = lport->tt.frame_send(lport, fp);\r\nif (fh_type == FC_TYPE_BLS)\r\nreturn error;\r\nspin_lock_bh(&ep->ex_lock);\r\nep->f_ctl = f_ctl & ~FC_FC_FIRST_SEQ;\r\nif (f_ctl & FC_FC_SEQ_INIT)\r\nep->esb_stat &= ~ESB_ST_SEQ_INIT;\r\nspin_unlock_bh(&ep->ex_lock);\r\nreturn error;\r\n}\r\nstatic struct fc_seq *fc_seq_alloc(struct fc_exch *ep, u8 seq_id)\r\n{\r\nstruct fc_seq *sp;\r\nsp = &ep->seq;\r\nsp->ssb_stat = 0;\r\nsp->cnt = 0;\r\nsp->id = seq_id;\r\nreturn sp;\r\n}\r\nstatic struct fc_seq *fc_seq_start_next_locked(struct fc_seq *sp)\r\n{\r\nstruct fc_exch *ep = fc_seq_exch(sp);\r\nsp = fc_seq_alloc(ep, ep->seq_id++);\r\nFC_EXCH_DBG(ep, "f_ctl %6x seq %2x\n",\r\nep->f_ctl, sp->id);\r\nreturn sp;\r\n}\r\nstatic struct fc_seq *fc_seq_start_next(struct fc_seq *sp)\r\n{\r\nstruct fc_exch *ep = fc_seq_exch(sp);\r\nspin_lock_bh(&ep->ex_lock);\r\nsp = fc_seq_start_next_locked(sp);\r\nspin_unlock_bh(&ep->ex_lock);\r\nreturn sp;\r\n}\r\nstatic void fc_seq_set_resp(struct fc_seq *sp,\r\nvoid (*resp)(struct fc_seq *, struct fc_frame *,\r\nvoid *),\r\nvoid *arg)\r\n{\r\nstruct fc_exch *ep = fc_seq_exch(sp);\r\nspin_lock_bh(&ep->ex_lock);\r\nep->resp = resp;\r\nep->arg = arg;\r\nspin_unlock_bh(&ep->ex_lock);\r\n}\r\nstatic int fc_exch_abort_locked(struct fc_exch *ep,\r\nunsigned int timer_msec)\r\n{\r\nstruct fc_seq *sp;\r\nstruct fc_frame *fp;\r\nint error;\r\nif (ep->esb_stat & (ESB_ST_COMPLETE | ESB_ST_ABNORMAL) ||\r\nep->state & (FC_EX_DONE | FC_EX_RST_CLEANUP))\r\nreturn -ENXIO;\r\nsp = fc_seq_start_next_locked(&ep->seq);\r\nif (!sp)\r\nreturn -ENOMEM;\r\nep->esb_stat |= ESB_ST_SEQ_INIT | ESB_ST_ABNORMAL;\r\nif (timer_msec)\r\nfc_exch_timer_set_locked(ep, timer_msec);\r\nif (!ep->sid)\r\nreturn 0;\r\nfp = fc_frame_alloc(ep->lp, 0);\r\nif (fp) {\r\nfc_fill_fc_hdr(fp, FC_RCTL_BA_ABTS, ep->did, ep->sid,\r\nFC_TYPE_BLS, FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\r\nerror = fc_seq_send(ep->lp, sp, fp);\r\n} else\r\nerror = -ENOBUFS;\r\nreturn error;\r\n}\r\nstatic int fc_seq_exch_abort(const struct fc_seq *req_sp,\r\nunsigned int timer_msec)\r\n{\r\nstruct fc_exch *ep;\r\nint error;\r\nep = fc_seq_exch(req_sp);\r\nspin_lock_bh(&ep->ex_lock);\r\nerror = fc_exch_abort_locked(ep, timer_msec);\r\nspin_unlock_bh(&ep->ex_lock);\r\nreturn error;\r\n}\r\nstatic void fc_exch_timeout(struct work_struct *work)\r\n{\r\nstruct fc_exch *ep = container_of(work, struct fc_exch,\r\ntimeout_work.work);\r\nstruct fc_seq *sp = &ep->seq;\r\nvoid (*resp)(struct fc_seq *, struct fc_frame *fp, void *arg);\r\nvoid *arg;\r\nu32 e_stat;\r\nint rc = 1;\r\nFC_EXCH_DBG(ep, "Exchange timed out\n");\r\nspin_lock_bh(&ep->ex_lock);\r\nif (ep->state & (FC_EX_RST_CLEANUP | FC_EX_DONE))\r\ngoto unlock;\r\ne_stat = ep->esb_stat;\r\nif (e_stat & ESB_ST_COMPLETE) {\r\nep->esb_stat = e_stat & ~ESB_ST_REC_QUAL;\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (e_stat & ESB_ST_REC_QUAL)\r\nfc_exch_rrq(ep);\r\ngoto done;\r\n} else {\r\nresp = ep->resp;\r\narg = ep->arg;\r\nep->resp = NULL;\r\nif (e_stat & ESB_ST_ABNORMAL)\r\nrc = fc_exch_done_locked(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (!rc)\r\nfc_exch_delete(ep);\r\nif (resp)\r\nresp(sp, ERR_PTR(-FC_EX_TIMEOUT), arg);\r\nfc_seq_exch_abort(sp, 2 * ep->r_a_tov);\r\ngoto done;\r\n}\r\nunlock:\r\nspin_unlock_bh(&ep->ex_lock);\r\ndone:\r\nfc_exch_release(ep);\r\n}\r\nstatic struct fc_exch *fc_exch_em_alloc(struct fc_lport *lport,\r\nstruct fc_exch_mgr *mp)\r\n{\r\nstruct fc_exch *ep;\r\nunsigned int cpu;\r\nu16 index;\r\nstruct fc_exch_pool *pool;\r\nep = mempool_alloc(mp->ep_pool, GFP_ATOMIC);\r\nif (!ep) {\r\natomic_inc(&mp->stats.no_free_exch);\r\ngoto out;\r\n}\r\nmemset(ep, 0, sizeof(*ep));\r\ncpu = get_cpu();\r\npool = per_cpu_ptr(mp->pool, cpu);\r\nspin_lock_bh(&pool->lock);\r\nput_cpu();\r\nif (pool->left != FC_XID_UNKNOWN) {\r\nindex = pool->left;\r\npool->left = FC_XID_UNKNOWN;\r\ngoto hit;\r\n}\r\nif (pool->right != FC_XID_UNKNOWN) {\r\nindex = pool->right;\r\npool->right = FC_XID_UNKNOWN;\r\ngoto hit;\r\n}\r\nindex = pool->next_index;\r\nwhile (fc_exch_ptr_get(pool, index)) {\r\nindex = index == mp->pool_max_index ? 0 : index + 1;\r\nif (index == pool->next_index)\r\ngoto err;\r\n}\r\npool->next_index = index == mp->pool_max_index ? 0 : index + 1;\r\nhit:\r\nfc_exch_hold(ep);\r\nspin_lock_init(&ep->ex_lock);\r\nspin_lock_bh(&ep->ex_lock);\r\nfc_exch_ptr_set(pool, index, ep);\r\nlist_add_tail(&ep->ex_list, &pool->ex_list);\r\nfc_seq_alloc(ep, ep->seq_id++);\r\npool->total_exches++;\r\nspin_unlock_bh(&pool->lock);\r\nep->oxid = ep->xid = (index << fc_cpu_order | cpu) + mp->min_xid;\r\nep->em = mp;\r\nep->pool = pool;\r\nep->lp = lport;\r\nep->f_ctl = FC_FC_FIRST_SEQ;\r\nep->rxid = FC_XID_UNKNOWN;\r\nep->class = mp->class;\r\nINIT_DELAYED_WORK(&ep->timeout_work, fc_exch_timeout);\r\nout:\r\nreturn ep;\r\nerr:\r\nspin_unlock_bh(&pool->lock);\r\natomic_inc(&mp->stats.no_free_exch_xid);\r\nmempool_free(ep, mp->ep_pool);\r\nreturn NULL;\r\n}\r\nstatic inline struct fc_exch *fc_exch_alloc(struct fc_lport *lport,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_exch_mgr_anchor *ema;\r\nlist_for_each_entry(ema, &lport->ema_list, ema_list)\r\nif (!ema->match || ema->match(fp))\r\nreturn fc_exch_em_alloc(lport, ema->mp);\r\nreturn NULL;\r\n}\r\nstatic struct fc_exch *fc_exch_find(struct fc_exch_mgr *mp, u16 xid)\r\n{\r\nstruct fc_exch_pool *pool;\r\nstruct fc_exch *ep = NULL;\r\nif ((xid >= mp->min_xid) && (xid <= mp->max_xid)) {\r\npool = per_cpu_ptr(mp->pool, xid & fc_cpu_mask);\r\nspin_lock_bh(&pool->lock);\r\nep = fc_exch_ptr_get(pool, (xid - mp->min_xid) >> fc_cpu_order);\r\nif (ep && ep->xid == xid)\r\nfc_exch_hold(ep);\r\nspin_unlock_bh(&pool->lock);\r\n}\r\nreturn ep;\r\n}\r\nstatic void fc_exch_done(struct fc_seq *sp)\r\n{\r\nstruct fc_exch *ep = fc_seq_exch(sp);\r\nint rc;\r\nspin_lock_bh(&ep->ex_lock);\r\nrc = fc_exch_done_locked(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (!rc)\r\nfc_exch_delete(ep);\r\n}\r\nstatic struct fc_exch *fc_exch_resp(struct fc_lport *lport,\r\nstruct fc_exch_mgr *mp,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_exch *ep;\r\nstruct fc_frame_header *fh;\r\nep = fc_exch_alloc(lport, fp);\r\nif (ep) {\r\nep->class = fc_frame_class(fp);\r\nep->f_ctl |= FC_FC_EX_CTX;\r\nep->f_ctl &= ~FC_FC_FIRST_SEQ;\r\nfh = fc_frame_header_get(fp);\r\nep->sid = ntoh24(fh->fh_d_id);\r\nep->did = ntoh24(fh->fh_s_id);\r\nep->oid = ep->did;\r\nep->rxid = ep->xid;\r\nep->oxid = ntohs(fh->fh_ox_id);\r\nep->esb_stat |= ESB_ST_RESP | ESB_ST_SEQ_INIT;\r\nif ((ntoh24(fh->fh_f_ctl) & FC_FC_SEQ_INIT) == 0)\r\nep->esb_stat &= ~ESB_ST_SEQ_INIT;\r\nfc_exch_hold(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\n}\r\nreturn ep;\r\n}\r\nstatic enum fc_pf_rjt_reason fc_seq_lookup_recip(struct fc_lport *lport,\r\nstruct fc_exch_mgr *mp,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fc_exch *ep = NULL;\r\nstruct fc_seq *sp = NULL;\r\nenum fc_pf_rjt_reason reject = FC_RJT_NONE;\r\nu32 f_ctl;\r\nu16 xid;\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nWARN_ON((f_ctl & FC_FC_SEQ_CTX) != 0);\r\nif (f_ctl & FC_FC_EX_CTX) {\r\nxid = ntohs(fh->fh_ox_id);\r\nep = fc_exch_find(mp, xid);\r\nif (!ep) {\r\natomic_inc(&mp->stats.xid_not_found);\r\nreject = FC_RJT_OX_ID;\r\ngoto out;\r\n}\r\nif (ep->rxid == FC_XID_UNKNOWN)\r\nep->rxid = ntohs(fh->fh_rx_id);\r\nelse if (ep->rxid != ntohs(fh->fh_rx_id)) {\r\nreject = FC_RJT_OX_ID;\r\ngoto rel;\r\n}\r\n} else {\r\nxid = ntohs(fh->fh_rx_id);\r\nif (xid == 0 && fh->fh_r_ctl == FC_RCTL_ELS_REQ &&\r\nfc_frame_payload_op(fp) == ELS_TEST) {\r\nfh->fh_rx_id = htons(FC_XID_UNKNOWN);\r\nxid = FC_XID_UNKNOWN;\r\n}\r\nep = fc_exch_find(mp, xid);\r\nif ((f_ctl & FC_FC_FIRST_SEQ) && fc_sof_is_init(fr_sof(fp))) {\r\nif (ep) {\r\natomic_inc(&mp->stats.xid_busy);\r\nreject = FC_RJT_RX_ID;\r\ngoto rel;\r\n}\r\nep = fc_exch_resp(lport, mp, fp);\r\nif (!ep) {\r\nreject = FC_RJT_EXCH_EST;\r\ngoto out;\r\n}\r\nxid = ep->xid;\r\n} else if (!ep) {\r\natomic_inc(&mp->stats.xid_not_found);\r\nreject = FC_RJT_RX_ID;\r\ngoto out;\r\n}\r\n}\r\nif (fc_sof_is_init(fr_sof(fp))) {\r\nsp = &ep->seq;\r\nsp->ssb_stat |= SSB_ST_RESP;\r\nsp->id = fh->fh_seq_id;\r\n} else {\r\nsp = &ep->seq;\r\nif (sp->id != fh->fh_seq_id) {\r\natomic_inc(&mp->stats.seq_not_found);\r\nif (f_ctl & FC_FC_END_SEQ) {\r\nspin_lock_bh(&ep->ex_lock);\r\nsp->ssb_stat |= SSB_ST_RESP;\r\nsp->id = fh->fh_seq_id;\r\nspin_unlock_bh(&ep->ex_lock);\r\n} else {\r\nreject = FC_RJT_SEQ_ID;\r\ngoto rel;\r\n}\r\n}\r\n}\r\nWARN_ON(ep != fc_seq_exch(sp));\r\nif (f_ctl & FC_FC_SEQ_INIT)\r\nep->esb_stat |= ESB_ST_SEQ_INIT;\r\nfr_seq(fp) = sp;\r\nout:\r\nreturn reject;\r\nrel:\r\nfc_exch_done(&ep->seq);\r\nfc_exch_release(ep);\r\nreturn reject;\r\n}\r\nstatic struct fc_seq *fc_seq_lookup_orig(struct fc_exch_mgr *mp,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fc_exch *ep;\r\nstruct fc_seq *sp = NULL;\r\nu32 f_ctl;\r\nu16 xid;\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nWARN_ON((f_ctl & FC_FC_SEQ_CTX) != FC_FC_SEQ_CTX);\r\nxid = ntohs((f_ctl & FC_FC_EX_CTX) ? fh->fh_ox_id : fh->fh_rx_id);\r\nep = fc_exch_find(mp, xid);\r\nif (!ep)\r\nreturn NULL;\r\nif (ep->seq.id == fh->fh_seq_id) {\r\nsp = &ep->seq;\r\nif ((f_ctl & FC_FC_EX_CTX) != 0 &&\r\nep->rxid == FC_XID_UNKNOWN) {\r\nep->rxid = ntohs(fh->fh_rx_id);\r\n}\r\n}\r\nfc_exch_release(ep);\r\nreturn sp;\r\n}\r\nstatic void fc_exch_set_addr(struct fc_exch *ep,\r\nu32 orig_id, u32 resp_id)\r\n{\r\nep->oid = orig_id;\r\nif (ep->esb_stat & ESB_ST_RESP) {\r\nep->sid = resp_id;\r\nep->did = orig_id;\r\n} else {\r\nep->sid = orig_id;\r\nep->did = resp_id;\r\n}\r\n}\r\nstatic void fc_seq_els_rsp_send(struct fc_frame *fp, enum fc_els_cmd els_cmd,\r\nstruct fc_seq_els_data *els_data)\r\n{\r\nswitch (els_cmd) {\r\ncase ELS_LS_RJT:\r\nfc_seq_ls_rjt(fp, els_data->reason, els_data->explan);\r\nbreak;\r\ncase ELS_LS_ACC:\r\nfc_seq_ls_acc(fp);\r\nbreak;\r\ncase ELS_RRQ:\r\nfc_exch_els_rrq(fp);\r\nbreak;\r\ncase ELS_REC:\r\nfc_exch_els_rec(fp);\r\nbreak;\r\ndefault:\r\nFC_LPORT_DBG(fr_dev(fp), "Invalid ELS CMD:%x\n", els_cmd);\r\n}\r\n}\r\nstatic void fc_seq_send_last(struct fc_seq *sp, struct fc_frame *fp,\r\nenum fc_rctl rctl, enum fc_fh_type fh_type)\r\n{\r\nu32 f_ctl;\r\nstruct fc_exch *ep = fc_seq_exch(sp);\r\nf_ctl = FC_FC_LAST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT;\r\nf_ctl |= ep->f_ctl;\r\nfc_fill_fc_hdr(fp, rctl, ep->did, ep->sid, fh_type, f_ctl, 0);\r\nfc_seq_send(ep->lp, sp, fp);\r\n}\r\nstatic void fc_seq_send_ack(struct fc_seq *sp, const struct fc_frame *rx_fp)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *rx_fh;\r\nstruct fc_frame_header *fh;\r\nstruct fc_exch *ep = fc_seq_exch(sp);\r\nstruct fc_lport *lport = ep->lp;\r\nunsigned int f_ctl;\r\nif (fc_sof_needs_ack(fr_sof(rx_fp))) {\r\nfp = fc_frame_alloc(lport, 0);\r\nif (!fp)\r\nreturn;\r\nfh = fc_frame_header_get(fp);\r\nfh->fh_r_ctl = FC_RCTL_ACK_1;\r\nfh->fh_type = FC_TYPE_BLS;\r\nrx_fh = fc_frame_header_get(rx_fp);\r\nf_ctl = ntoh24(rx_fh->fh_f_ctl);\r\nf_ctl &= FC_FC_EX_CTX | FC_FC_SEQ_CTX |\r\nFC_FC_FIRST_SEQ | FC_FC_LAST_SEQ |\r\nFC_FC_END_SEQ | FC_FC_END_CONN | FC_FC_SEQ_INIT |\r\nFC_FC_RETX_SEQ | FC_FC_UNI_TX;\r\nf_ctl ^= FC_FC_EX_CTX | FC_FC_SEQ_CTX;\r\nhton24(fh->fh_f_ctl, f_ctl);\r\nfc_exch_setup_hdr(ep, fp, f_ctl);\r\nfh->fh_seq_id = rx_fh->fh_seq_id;\r\nfh->fh_seq_cnt = rx_fh->fh_seq_cnt;\r\nfh->fh_parm_offset = htonl(1);\r\nfr_sof(fp) = fr_sof(rx_fp);\r\nif (f_ctl & FC_FC_END_SEQ)\r\nfr_eof(fp) = FC_EOF_T;\r\nelse\r\nfr_eof(fp) = FC_EOF_N;\r\nlport->tt.frame_send(lport, fp);\r\n}\r\n}\r\nstatic void fc_exch_send_ba_rjt(struct fc_frame *rx_fp,\r\nenum fc_ba_rjt_reason reason,\r\nenum fc_ba_rjt_explan explan)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_frame_header *rx_fh;\r\nstruct fc_frame_header *fh;\r\nstruct fc_ba_rjt *rp;\r\nstruct fc_lport *lport;\r\nunsigned int f_ctl;\r\nlport = fr_dev(rx_fp);\r\nfp = fc_frame_alloc(lport, sizeof(*rp));\r\nif (!fp)\r\nreturn;\r\nfh = fc_frame_header_get(fp);\r\nrx_fh = fc_frame_header_get(rx_fp);\r\nmemset(fh, 0, sizeof(*fh) + sizeof(*rp));\r\nrp = fc_frame_payload_get(fp, sizeof(*rp));\r\nrp->br_reason = reason;\r\nrp->br_explan = explan;\r\nmemcpy(fh->fh_s_id, rx_fh->fh_d_id, 3);\r\nmemcpy(fh->fh_d_id, rx_fh->fh_s_id, 3);\r\nfh->fh_ox_id = rx_fh->fh_ox_id;\r\nfh->fh_rx_id = rx_fh->fh_rx_id;\r\nfh->fh_seq_cnt = rx_fh->fh_seq_cnt;\r\nfh->fh_r_ctl = FC_RCTL_BA_RJT;\r\nfh->fh_type = FC_TYPE_BLS;\r\nf_ctl = ntoh24(rx_fh->fh_f_ctl);\r\nf_ctl &= FC_FC_EX_CTX | FC_FC_SEQ_CTX |\r\nFC_FC_END_CONN | FC_FC_SEQ_INIT |\r\nFC_FC_RETX_SEQ | FC_FC_UNI_TX;\r\nf_ctl ^= FC_FC_EX_CTX | FC_FC_SEQ_CTX;\r\nf_ctl |= FC_FC_LAST_SEQ | FC_FC_END_SEQ;\r\nf_ctl &= ~FC_FC_FIRST_SEQ;\r\nhton24(fh->fh_f_ctl, f_ctl);\r\nfr_sof(fp) = fc_sof_class(fr_sof(rx_fp));\r\nfr_eof(fp) = FC_EOF_T;\r\nif (fc_sof_needs_ack(fr_sof(fp)))\r\nfr_eof(fp) = FC_EOF_N;\r\nlport->tt.frame_send(lport, fp);\r\n}\r\nstatic void fc_exch_recv_abts(struct fc_exch *ep, struct fc_frame *rx_fp)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_ba_acc *ap;\r\nstruct fc_frame_header *fh;\r\nstruct fc_seq *sp;\r\nif (!ep)\r\ngoto reject;\r\nspin_lock_bh(&ep->ex_lock);\r\nif (ep->esb_stat & ESB_ST_COMPLETE) {\r\nspin_unlock_bh(&ep->ex_lock);\r\ngoto reject;\r\n}\r\nif (!(ep->esb_stat & ESB_ST_REC_QUAL))\r\nfc_exch_hold(ep);\r\nep->esb_stat |= ESB_ST_ABNORMAL | ESB_ST_REC_QUAL;\r\nfc_exch_timer_set_locked(ep, ep->r_a_tov);\r\nfp = fc_frame_alloc(ep->lp, sizeof(*ap));\r\nif (!fp) {\r\nspin_unlock_bh(&ep->ex_lock);\r\ngoto free;\r\n}\r\nfh = fc_frame_header_get(fp);\r\nap = fc_frame_payload_get(fp, sizeof(*ap));\r\nmemset(ap, 0, sizeof(*ap));\r\nsp = &ep->seq;\r\nap->ba_high_seq_cnt = htons(0xffff);\r\nif (sp->ssb_stat & SSB_ST_RESP) {\r\nap->ba_seq_id = sp->id;\r\nap->ba_seq_id_val = FC_BA_SEQ_ID_VAL;\r\nap->ba_high_seq_cnt = fh->fh_seq_cnt;\r\nap->ba_low_seq_cnt = htons(sp->cnt);\r\n}\r\nsp = fc_seq_start_next_locked(sp);\r\nspin_unlock_bh(&ep->ex_lock);\r\nfc_seq_send_last(sp, fp, FC_RCTL_BA_ACC, FC_TYPE_BLS);\r\nfc_frame_free(rx_fp);\r\nreturn;\r\nreject:\r\nfc_exch_send_ba_rjt(rx_fp, FC_BA_RJT_UNABLE, FC_BA_RJT_INV_XID);\r\nfree:\r\nfc_frame_free(rx_fp);\r\n}\r\nstatic struct fc_seq *fc_seq_assign(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct fc_exch_mgr_anchor *ema;\r\nWARN_ON(lport != fr_dev(fp));\r\nWARN_ON(fr_seq(fp));\r\nfr_seq(fp) = NULL;\r\nlist_for_each_entry(ema, &lport->ema_list, ema_list)\r\nif ((!ema->match || ema->match(fp)) &&\r\nfc_seq_lookup_recip(lport, ema->mp, fp) == FC_RJT_NONE)\r\nbreak;\r\nreturn fr_seq(fp);\r\n}\r\nstatic void fc_seq_release(struct fc_seq *sp)\r\n{\r\nfc_exch_release(fc_seq_exch(sp));\r\n}\r\nstatic void fc_exch_recv_req(struct fc_lport *lport, struct fc_exch_mgr *mp,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fc_seq *sp = NULL;\r\nstruct fc_exch *ep = NULL;\r\nenum fc_pf_rjt_reason reject;\r\nlport = fc_vport_id_lookup(lport, ntoh24(fh->fh_d_id));\r\nif (!lport) {\r\nfc_frame_free(fp);\r\nreturn;\r\n}\r\nfr_dev(fp) = lport;\r\nBUG_ON(fr_seq(fp));\r\nif (fh->fh_rx_id == htons(FC_XID_UNKNOWN))\r\nreturn lport->tt.lport_recv(lport, fp);\r\nreject = fc_seq_lookup_recip(lport, mp, fp);\r\nif (reject == FC_RJT_NONE) {\r\nsp = fr_seq(fp);\r\nep = fc_seq_exch(sp);\r\nfc_seq_send_ack(sp, fp);\r\nep->encaps = fr_encaps(fp);\r\nif (ep->resp)\r\nep->resp(sp, fp, ep->arg);\r\nelse\r\nlport->tt.lport_recv(lport, fp);\r\nfc_exch_release(ep);\r\n} else {\r\nFC_LPORT_DBG(lport, "exch/seq lookup failed: reject %x\n",\r\nreject);\r\nfc_frame_free(fp);\r\n}\r\n}\r\nstatic void fc_exch_recv_seq_resp(struct fc_exch_mgr *mp, struct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fc_seq *sp;\r\nstruct fc_exch *ep;\r\nenum fc_sof sof;\r\nu32 f_ctl;\r\nvoid (*resp)(struct fc_seq *, struct fc_frame *fp, void *arg);\r\nvoid *ex_resp_arg;\r\nint rc;\r\nep = fc_exch_find(mp, ntohs(fh->fh_ox_id));\r\nif (!ep) {\r\natomic_inc(&mp->stats.xid_not_found);\r\ngoto out;\r\n}\r\nif (ep->esb_stat & ESB_ST_COMPLETE) {\r\natomic_inc(&mp->stats.xid_not_found);\r\ngoto rel;\r\n}\r\nif (ep->rxid == FC_XID_UNKNOWN)\r\nep->rxid = ntohs(fh->fh_rx_id);\r\nif (ep->sid != 0 && ep->sid != ntoh24(fh->fh_d_id)) {\r\natomic_inc(&mp->stats.xid_not_found);\r\ngoto rel;\r\n}\r\nif (ep->did != ntoh24(fh->fh_s_id) &&\r\nep->did != FC_FID_FLOGI) {\r\natomic_inc(&mp->stats.xid_not_found);\r\ngoto rel;\r\n}\r\nsof = fr_sof(fp);\r\nsp = &ep->seq;\r\nif (fc_sof_is_init(sof)) {\r\nsp->ssb_stat |= SSB_ST_RESP;\r\nsp->id = fh->fh_seq_id;\r\n} else if (sp->id != fh->fh_seq_id) {\r\natomic_inc(&mp->stats.seq_not_found);\r\ngoto rel;\r\n}\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nfr_seq(fp) = sp;\r\nif (f_ctl & FC_FC_SEQ_INIT)\r\nep->esb_stat |= ESB_ST_SEQ_INIT;\r\nif (fc_sof_needs_ack(sof))\r\nfc_seq_send_ack(sp, fp);\r\nresp = ep->resp;\r\nex_resp_arg = ep->arg;\r\nif (fh->fh_type != FC_TYPE_FCP && fr_eof(fp) == FC_EOF_T &&\r\n(f_ctl & (FC_FC_LAST_SEQ | FC_FC_END_SEQ)) ==\r\n(FC_FC_LAST_SEQ | FC_FC_END_SEQ)) {\r\nspin_lock_bh(&ep->ex_lock);\r\nresp = ep->resp;\r\nrc = fc_exch_done_locked(ep);\r\nWARN_ON(fc_seq_exch(sp) != ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (!rc)\r\nfc_exch_delete(ep);\r\n}\r\nif (resp)\r\nresp(sp, fp, ex_resp_arg);\r\nelse\r\nfc_frame_free(fp);\r\nfc_exch_release(ep);\r\nreturn;\r\nrel:\r\nfc_exch_release(ep);\r\nout:\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_exch_recv_resp(struct fc_exch_mgr *mp, struct fc_frame *fp)\r\n{\r\nstruct fc_seq *sp;\r\nsp = fc_seq_lookup_orig(mp, fp);\r\nif (!sp)\r\natomic_inc(&mp->stats.xid_not_found);\r\nelse\r\natomic_inc(&mp->stats.non_bls_resp);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_exch_abts_resp(struct fc_exch *ep, struct fc_frame *fp)\r\n{\r\nvoid (*resp)(struct fc_seq *, struct fc_frame *fp, void *arg);\r\nvoid *ex_resp_arg;\r\nstruct fc_frame_header *fh;\r\nstruct fc_ba_acc *ap;\r\nstruct fc_seq *sp;\r\nu16 low;\r\nu16 high;\r\nint rc = 1, has_rec = 0;\r\nfh = fc_frame_header_get(fp);\r\nFC_EXCH_DBG(ep, "exch: BLS rctl %x - %s\n", fh->fh_r_ctl,\r\nfc_exch_rctl_name(fh->fh_r_ctl));\r\nif (cancel_delayed_work_sync(&ep->timeout_work)) {\r\nFC_EXCH_DBG(ep, "Exchange timer canceled\n");\r\nfc_exch_release(ep);\r\n}\r\nspin_lock_bh(&ep->ex_lock);\r\nswitch (fh->fh_r_ctl) {\r\ncase FC_RCTL_BA_ACC:\r\nap = fc_frame_payload_get(fp, sizeof(*ap));\r\nif (!ap)\r\nbreak;\r\nlow = ntohs(ap->ba_low_seq_cnt);\r\nhigh = ntohs(ap->ba_high_seq_cnt);\r\nif ((ep->esb_stat & ESB_ST_REC_QUAL) == 0 &&\r\n(ap->ba_seq_id_val != FC_BA_SEQ_ID_VAL ||\r\nap->ba_seq_id == ep->seq_id) && low != high) {\r\nep->esb_stat |= ESB_ST_REC_QUAL;\r\nfc_exch_hold(ep);\r\nhas_rec = 1;\r\n}\r\nbreak;\r\ncase FC_RCTL_BA_RJT:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nresp = ep->resp;\r\nex_resp_arg = ep->arg;\r\nsp = &ep->seq;\r\nif (ep->fh_type != FC_TYPE_FCP &&\r\nntoh24(fh->fh_f_ctl) & FC_FC_LAST_SEQ)\r\nrc = fc_exch_done_locked(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (!rc)\r\nfc_exch_delete(ep);\r\nif (resp)\r\nresp(sp, fp, ex_resp_arg);\r\nelse\r\nfc_frame_free(fp);\r\nif (has_rec)\r\nfc_exch_timer_set(ep, ep->r_a_tov);\r\n}\r\nstatic void fc_exch_recv_bls(struct fc_exch_mgr *mp, struct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh;\r\nstruct fc_exch *ep;\r\nu32 f_ctl;\r\nfh = fc_frame_header_get(fp);\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nfr_seq(fp) = NULL;\r\nep = fc_exch_find(mp, (f_ctl & FC_FC_EX_CTX) ?\r\nntohs(fh->fh_ox_id) : ntohs(fh->fh_rx_id));\r\nif (ep && (f_ctl & FC_FC_SEQ_INIT)) {\r\nspin_lock_bh(&ep->ex_lock);\r\nep->esb_stat |= ESB_ST_SEQ_INIT;\r\nspin_unlock_bh(&ep->ex_lock);\r\n}\r\nif (f_ctl & FC_FC_SEQ_CTX) {\r\nswitch (fh->fh_r_ctl) {\r\ncase FC_RCTL_ACK_1:\r\ncase FC_RCTL_ACK_0:\r\nbreak;\r\ndefault:\r\nif (ep)\r\nFC_EXCH_DBG(ep, "BLS rctl %x - %s received",\r\nfh->fh_r_ctl,\r\nfc_exch_rctl_name(fh->fh_r_ctl));\r\nbreak;\r\n}\r\nfc_frame_free(fp);\r\n} else {\r\nswitch (fh->fh_r_ctl) {\r\ncase FC_RCTL_BA_RJT:\r\ncase FC_RCTL_BA_ACC:\r\nif (ep)\r\nfc_exch_abts_resp(ep, fp);\r\nelse\r\nfc_frame_free(fp);\r\nbreak;\r\ncase FC_RCTL_BA_ABTS:\r\nfc_exch_recv_abts(ep, fp);\r\nbreak;\r\ndefault:\r\nfc_frame_free(fp);\r\nbreak;\r\n}\r\n}\r\nif (ep)\r\nfc_exch_release(ep);\r\n}\r\nstatic void fc_seq_ls_acc(struct fc_frame *rx_fp)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_els_ls_acc *acc;\r\nstruct fc_frame *fp;\r\nlport = fr_dev(rx_fp);\r\nfp = fc_frame_alloc(lport, sizeof(*acc));\r\nif (!fp)\r\nreturn;\r\nacc = fc_frame_payload_get(fp, sizeof(*acc));\r\nmemset(acc, 0, sizeof(*acc));\r\nacc->la_cmd = ELS_LS_ACC;\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\n}\r\nstatic void fc_seq_ls_rjt(struct fc_frame *rx_fp, enum fc_els_rjt_reason reason,\r\nenum fc_els_rjt_explan explan)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_els_ls_rjt *rjt;\r\nstruct fc_frame *fp;\r\nlport = fr_dev(rx_fp);\r\nfp = fc_frame_alloc(lport, sizeof(*rjt));\r\nif (!fp)\r\nreturn;\r\nrjt = fc_frame_payload_get(fp, sizeof(*rjt));\r\nmemset(rjt, 0, sizeof(*rjt));\r\nrjt->er_cmd = ELS_LS_RJT;\r\nrjt->er_reason = reason;\r\nrjt->er_explan = explan;\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\n}\r\nstatic void fc_exch_reset(struct fc_exch *ep)\r\n{\r\nstruct fc_seq *sp;\r\nvoid (*resp)(struct fc_seq *, struct fc_frame *, void *);\r\nvoid *arg;\r\nint rc = 1;\r\nspin_lock_bh(&ep->ex_lock);\r\nfc_exch_abort_locked(ep, 0);\r\nep->state |= FC_EX_RST_CLEANUP;\r\nfc_exch_timer_cancel(ep);\r\nresp = ep->resp;\r\nep->resp = NULL;\r\nif (ep->esb_stat & ESB_ST_REC_QUAL)\r\natomic_dec(&ep->ex_refcnt);\r\nep->esb_stat &= ~ESB_ST_REC_QUAL;\r\narg = ep->arg;\r\nsp = &ep->seq;\r\nrc = fc_exch_done_locked(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (!rc)\r\nfc_exch_delete(ep);\r\nif (resp)\r\nresp(sp, ERR_PTR(-FC_EX_CLOSED), arg);\r\n}\r\nstatic void fc_exch_pool_reset(struct fc_lport *lport,\r\nstruct fc_exch_pool *pool,\r\nu32 sid, u32 did)\r\n{\r\nstruct fc_exch *ep;\r\nstruct fc_exch *next;\r\nspin_lock_bh(&pool->lock);\r\nrestart:\r\nlist_for_each_entry_safe(ep, next, &pool->ex_list, ex_list) {\r\nif ((lport == ep->lp) &&\r\n(sid == 0 || sid == ep->sid) &&\r\n(did == 0 || did == ep->did)) {\r\nfc_exch_hold(ep);\r\nspin_unlock_bh(&pool->lock);\r\nfc_exch_reset(ep);\r\nfc_exch_release(ep);\r\nspin_lock_bh(&pool->lock);\r\ngoto restart;\r\n}\r\n}\r\npool->next_index = 0;\r\npool->left = FC_XID_UNKNOWN;\r\npool->right = FC_XID_UNKNOWN;\r\nspin_unlock_bh(&pool->lock);\r\n}\r\nvoid fc_exch_mgr_reset(struct fc_lport *lport, u32 sid, u32 did)\r\n{\r\nstruct fc_exch_mgr_anchor *ema;\r\nunsigned int cpu;\r\nlist_for_each_entry(ema, &lport->ema_list, ema_list) {\r\nfor_each_possible_cpu(cpu)\r\nfc_exch_pool_reset(lport,\r\nper_cpu_ptr(ema->mp->pool, cpu),\r\nsid, did);\r\n}\r\n}\r\nstatic struct fc_exch *fc_exch_lookup(struct fc_lport *lport, u32 xid)\r\n{\r\nstruct fc_exch_mgr_anchor *ema;\r\nlist_for_each_entry(ema, &lport->ema_list, ema_list)\r\nif (ema->mp->min_xid <= xid && xid <= ema->mp->max_xid)\r\nreturn fc_exch_find(ema->mp, xid);\r\nreturn NULL;\r\n}\r\nstatic void fc_exch_els_rec(struct fc_frame *rfp)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_frame *fp;\r\nstruct fc_exch *ep;\r\nstruct fc_els_rec *rp;\r\nstruct fc_els_rec_acc *acc;\r\nenum fc_els_rjt_reason reason = ELS_RJT_LOGIC;\r\nenum fc_els_rjt_explan explan;\r\nu32 sid;\r\nu16 rxid;\r\nu16 oxid;\r\nlport = fr_dev(rfp);\r\nrp = fc_frame_payload_get(rfp, sizeof(*rp));\r\nexplan = ELS_EXPL_INV_LEN;\r\nif (!rp)\r\ngoto reject;\r\nsid = ntoh24(rp->rec_s_id);\r\nrxid = ntohs(rp->rec_rx_id);\r\noxid = ntohs(rp->rec_ox_id);\r\nep = fc_exch_lookup(lport,\r\nsid == fc_host_port_id(lport->host) ? oxid : rxid);\r\nexplan = ELS_EXPL_OXID_RXID;\r\nif (!ep)\r\ngoto reject;\r\nif (ep->oid != sid || oxid != ep->oxid)\r\ngoto rel;\r\nif (rxid != FC_XID_UNKNOWN && rxid != ep->rxid)\r\ngoto rel;\r\nfp = fc_frame_alloc(lport, sizeof(*acc));\r\nif (!fp)\r\ngoto out;\r\nacc = fc_frame_payload_get(fp, sizeof(*acc));\r\nmemset(acc, 0, sizeof(*acc));\r\nacc->reca_cmd = ELS_LS_ACC;\r\nacc->reca_ox_id = rp->rec_ox_id;\r\nmemcpy(acc->reca_ofid, rp->rec_s_id, 3);\r\nacc->reca_rx_id = htons(ep->rxid);\r\nif (ep->sid == ep->oid)\r\nhton24(acc->reca_rfid, ep->did);\r\nelse\r\nhton24(acc->reca_rfid, ep->sid);\r\nacc->reca_fc4value = htonl(ep->seq.rec_data);\r\nacc->reca_e_stat = htonl(ep->esb_stat & (ESB_ST_RESP |\r\nESB_ST_SEQ_INIT |\r\nESB_ST_COMPLETE));\r\nfc_fill_reply_hdr(fp, rfp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\nout:\r\nfc_exch_release(ep);\r\nreturn;\r\nrel:\r\nfc_exch_release(ep);\r\nreject:\r\nfc_seq_ls_rjt(rfp, reason, explan);\r\n}\r\nstatic void fc_exch_rrq_resp(struct fc_seq *sp, struct fc_frame *fp, void *arg)\r\n{\r\nstruct fc_exch *aborted_ep = arg;\r\nunsigned int op;\r\nif (IS_ERR(fp)) {\r\nint err = PTR_ERR(fp);\r\nif (err == -FC_EX_CLOSED || err == -FC_EX_TIMEOUT)\r\ngoto cleanup;\r\nFC_EXCH_DBG(aborted_ep, "Cannot process RRQ, "\r\n"frame error %d\n", err);\r\nreturn;\r\n}\r\nop = fc_frame_payload_op(fp);\r\nfc_frame_free(fp);\r\nswitch (op) {\r\ncase ELS_LS_RJT:\r\nFC_EXCH_DBG(aborted_ep, "LS_RJT for RRQ");\r\ncase ELS_LS_ACC:\r\ngoto cleanup;\r\ndefault:\r\nFC_EXCH_DBG(aborted_ep, "unexpected response op %x "\r\n"for RRQ", op);\r\nreturn;\r\n}\r\ncleanup:\r\nfc_exch_done(&aborted_ep->seq);\r\nfc_exch_release(aborted_ep);\r\n}\r\nstatic struct fc_seq *fc_exch_seq_send(struct fc_lport *lport,\r\nstruct fc_frame *fp,\r\nvoid (*resp)(struct fc_seq *,\r\nstruct fc_frame *fp,\r\nvoid *arg),\r\nvoid (*destructor)(struct fc_seq *,\r\nvoid *),\r\nvoid *arg, u32 timer_msec)\r\n{\r\nstruct fc_exch *ep;\r\nstruct fc_seq *sp = NULL;\r\nstruct fc_frame_header *fh;\r\nstruct fc_fcp_pkt *fsp = NULL;\r\nint rc = 1;\r\nep = fc_exch_alloc(lport, fp);\r\nif (!ep) {\r\nfc_frame_free(fp);\r\nreturn NULL;\r\n}\r\nep->esb_stat |= ESB_ST_SEQ_INIT;\r\nfh = fc_frame_header_get(fp);\r\nfc_exch_set_addr(ep, ntoh24(fh->fh_s_id), ntoh24(fh->fh_d_id));\r\nep->resp = resp;\r\nep->destructor = destructor;\r\nep->arg = arg;\r\nep->r_a_tov = FC_DEF_R_A_TOV;\r\nep->lp = lport;\r\nsp = &ep->seq;\r\nep->fh_type = fh->fh_type;\r\nep->f_ctl = ntoh24(fh->fh_f_ctl);\r\nfc_exch_setup_hdr(ep, fp, ep->f_ctl);\r\nsp->cnt++;\r\nif (ep->xid <= lport->lro_xid && fh->fh_r_ctl == FC_RCTL_DD_UNSOL_CMD) {\r\nfsp = fr_fsp(fp);\r\nfc_fcp_ddp_setup(fr_fsp(fp), ep->xid);\r\n}\r\nif (unlikely(lport->tt.frame_send(lport, fp)))\r\ngoto err;\r\nif (timer_msec)\r\nfc_exch_timer_set_locked(ep, timer_msec);\r\nep->f_ctl &= ~FC_FC_FIRST_SEQ;\r\nif (ep->f_ctl & FC_FC_SEQ_INIT)\r\nep->esb_stat &= ~ESB_ST_SEQ_INIT;\r\nspin_unlock_bh(&ep->ex_lock);\r\nreturn sp;\r\nerr:\r\nif (fsp)\r\nfc_fcp_ddp_done(fsp);\r\nrc = fc_exch_done_locked(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nif (!rc)\r\nfc_exch_delete(ep);\r\nreturn NULL;\r\n}\r\nstatic void fc_exch_rrq(struct fc_exch *ep)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_els_rrq *rrq;\r\nstruct fc_frame *fp;\r\nu32 did;\r\nlport = ep->lp;\r\nfp = fc_frame_alloc(lport, sizeof(*rrq));\r\nif (!fp)\r\ngoto retry;\r\nrrq = fc_frame_payload_get(fp, sizeof(*rrq));\r\nmemset(rrq, 0, sizeof(*rrq));\r\nrrq->rrq_cmd = ELS_RRQ;\r\nhton24(rrq->rrq_s_id, ep->sid);\r\nrrq->rrq_ox_id = htons(ep->oxid);\r\nrrq->rrq_rx_id = htons(ep->rxid);\r\ndid = ep->did;\r\nif (ep->esb_stat & ESB_ST_RESP)\r\ndid = ep->sid;\r\nfc_fill_fc_hdr(fp, FC_RCTL_ELS_REQ, did,\r\nlport->port_id, FC_TYPE_ELS,\r\nFC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\r\nif (fc_exch_seq_send(lport, fp, fc_exch_rrq_resp, NULL, ep,\r\nlport->e_d_tov))\r\nreturn;\r\nretry:\r\nspin_lock_bh(&ep->ex_lock);\r\nif (ep->state & (FC_EX_RST_CLEANUP | FC_EX_DONE)) {\r\nspin_unlock_bh(&ep->ex_lock);\r\nfc_exch_release(ep);\r\nreturn;\r\n}\r\nep->esb_stat |= ESB_ST_REC_QUAL;\r\nfc_exch_timer_set_locked(ep, ep->r_a_tov);\r\nspin_unlock_bh(&ep->ex_lock);\r\n}\r\nstatic void fc_exch_els_rrq(struct fc_frame *fp)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_exch *ep = NULL;\r\nstruct fc_els_rrq *rp;\r\nu32 sid;\r\nu16 xid;\r\nenum fc_els_rjt_explan explan;\r\nlport = fr_dev(fp);\r\nrp = fc_frame_payload_get(fp, sizeof(*rp));\r\nexplan = ELS_EXPL_INV_LEN;\r\nif (!rp)\r\ngoto reject;\r\nsid = ntoh24(rp->rrq_s_id);\r\nxid = fc_host_port_id(lport->host) == sid ?\r\nntohs(rp->rrq_ox_id) : ntohs(rp->rrq_rx_id);\r\nep = fc_exch_lookup(lport, xid);\r\nexplan = ELS_EXPL_OXID_RXID;\r\nif (!ep)\r\ngoto reject;\r\nspin_lock_bh(&ep->ex_lock);\r\nif (ep->oxid != ntohs(rp->rrq_ox_id))\r\ngoto unlock_reject;\r\nif (ep->rxid != ntohs(rp->rrq_rx_id) &&\r\nep->rxid != FC_XID_UNKNOWN)\r\ngoto unlock_reject;\r\nexplan = ELS_EXPL_SID;\r\nif (ep->sid != sid)\r\ngoto unlock_reject;\r\nif (ep->esb_stat & ESB_ST_REC_QUAL) {\r\nep->esb_stat &= ~ESB_ST_REC_QUAL;\r\natomic_dec(&ep->ex_refcnt);\r\n}\r\nif (ep->esb_stat & ESB_ST_COMPLETE)\r\nfc_exch_timer_cancel(ep);\r\nspin_unlock_bh(&ep->ex_lock);\r\nfc_seq_ls_acc(fp);\r\ngoto out;\r\nunlock_reject:\r\nspin_unlock_bh(&ep->ex_lock);\r\nreject:\r\nfc_seq_ls_rjt(fp, ELS_RJT_LOGIC, explan);\r\nout:\r\nif (ep)\r\nfc_exch_release(ep);\r\n}\r\nvoid fc_exch_update_stats(struct fc_lport *lport)\r\n{\r\nstruct fc_host_statistics *st;\r\nstruct fc_exch_mgr_anchor *ema;\r\nstruct fc_exch_mgr *mp;\r\nst = &lport->host_stats;\r\nlist_for_each_entry(ema, &lport->ema_list, ema_list) {\r\nmp = ema->mp;\r\nst->fc_no_free_exch += atomic_read(&mp->stats.no_free_exch);\r\nst->fc_no_free_exch_xid +=\r\natomic_read(&mp->stats.no_free_exch_xid);\r\nst->fc_xid_not_found += atomic_read(&mp->stats.xid_not_found);\r\nst->fc_xid_busy += atomic_read(&mp->stats.xid_busy);\r\nst->fc_seq_not_found += atomic_read(&mp->stats.seq_not_found);\r\nst->fc_non_bls_resp += atomic_read(&mp->stats.non_bls_resp);\r\n}\r\n}\r\nstruct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport,\r\nstruct fc_exch_mgr *mp,\r\nbool (*match)(struct fc_frame *))\r\n{\r\nstruct fc_exch_mgr_anchor *ema;\r\nema = kmalloc(sizeof(*ema), GFP_ATOMIC);\r\nif (!ema)\r\nreturn ema;\r\nema->mp = mp;\r\nema->match = match;\r\nlist_add_tail(&ema->ema_list, &lport->ema_list);\r\nkref_get(&mp->kref);\r\nreturn ema;\r\n}\r\nstatic void fc_exch_mgr_destroy(struct kref *kref)\r\n{\r\nstruct fc_exch_mgr *mp = container_of(kref, struct fc_exch_mgr, kref);\r\nmempool_destroy(mp->ep_pool);\r\nfree_percpu(mp->pool);\r\nkfree(mp);\r\n}\r\nvoid fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema)\r\n{\r\nlist_del(&ema->ema_list);\r\nkref_put(&ema->mp->kref, fc_exch_mgr_destroy);\r\nkfree(ema);\r\n}\r\nint fc_exch_mgr_list_clone(struct fc_lport *src, struct fc_lport *dst)\r\n{\r\nstruct fc_exch_mgr_anchor *ema, *tmp;\r\nlist_for_each_entry(ema, &src->ema_list, ema_list) {\r\nif (!fc_exch_mgr_add(dst, ema->mp, ema->match))\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_safe(ema, tmp, &dst->ema_list, ema_list)\r\nfc_exch_mgr_del(ema);\r\nreturn -ENOMEM;\r\n}\r\nstruct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lport,\r\nenum fc_class class,\r\nu16 min_xid, u16 max_xid,\r\nbool (*match)(struct fc_frame *))\r\n{\r\nstruct fc_exch_mgr *mp;\r\nu16 pool_exch_range;\r\nsize_t pool_size;\r\nunsigned int cpu;\r\nstruct fc_exch_pool *pool;\r\nif (max_xid <= min_xid || max_xid == FC_XID_UNKNOWN ||\r\n(min_xid & fc_cpu_mask) != 0) {\r\nFC_LPORT_DBG(lport, "Invalid min_xid 0x:%x and max_xid 0x:%x\n",\r\nmin_xid, max_xid);\r\nreturn NULL;\r\n}\r\nmp = kzalloc(sizeof(struct fc_exch_mgr), GFP_ATOMIC);\r\nif (!mp)\r\nreturn NULL;\r\nmp->class = class;\r\nmp->min_xid = min_xid;\r\npool_exch_range = (PCPU_MIN_UNIT_SIZE - sizeof(*pool)) /\r\nsizeof(struct fc_exch *);\r\nif ((max_xid - min_xid + 1) / (fc_cpu_mask + 1) > pool_exch_range) {\r\nmp->max_xid = pool_exch_range * (fc_cpu_mask + 1) +\r\nmin_xid - 1;\r\n} else {\r\nmp->max_xid = max_xid;\r\npool_exch_range = (mp->max_xid - mp->min_xid + 1) /\r\n(fc_cpu_mask + 1);\r\n}\r\nmp->ep_pool = mempool_create_slab_pool(2, fc_em_cachep);\r\nif (!mp->ep_pool)\r\ngoto free_mp;\r\nmp->pool_max_index = pool_exch_range - 1;\r\npool_size = sizeof(*pool) + pool_exch_range * sizeof(struct fc_exch *);\r\nmp->pool = __alloc_percpu(pool_size, __alignof__(struct fc_exch_pool));\r\nif (!mp->pool)\r\ngoto free_mempool;\r\nfor_each_possible_cpu(cpu) {\r\npool = per_cpu_ptr(mp->pool, cpu);\r\npool->next_index = 0;\r\npool->left = FC_XID_UNKNOWN;\r\npool->right = FC_XID_UNKNOWN;\r\nspin_lock_init(&pool->lock);\r\nINIT_LIST_HEAD(&pool->ex_list);\r\n}\r\nkref_init(&mp->kref);\r\nif (!fc_exch_mgr_add(lport, mp, match)) {\r\nfree_percpu(mp->pool);\r\ngoto free_mempool;\r\n}\r\nkref_put(&mp->kref, fc_exch_mgr_destroy);\r\nreturn mp;\r\nfree_mempool:\r\nmempool_destroy(mp->ep_pool);\r\nfree_mp:\r\nkfree(mp);\r\nreturn NULL;\r\n}\r\nvoid fc_exch_mgr_free(struct fc_lport *lport)\r\n{\r\nstruct fc_exch_mgr_anchor *ema, *next;\r\nflush_workqueue(fc_exch_workqueue);\r\nlist_for_each_entry_safe(ema, next, &lport->ema_list, ema_list)\r\nfc_exch_mgr_del(ema);\r\n}\r\nstatic struct fc_exch_mgr_anchor *fc_find_ema(u32 f_ctl,\r\nstruct fc_lport *lport,\r\nstruct fc_frame_header *fh)\r\n{\r\nstruct fc_exch_mgr_anchor *ema;\r\nu16 xid;\r\nif (f_ctl & FC_FC_EX_CTX)\r\nxid = ntohs(fh->fh_ox_id);\r\nelse {\r\nxid = ntohs(fh->fh_rx_id);\r\nif (xid == FC_XID_UNKNOWN)\r\nreturn list_entry(lport->ema_list.prev,\r\ntypeof(*ema), ema_list);\r\n}\r\nlist_for_each_entry(ema, &lport->ema_list, ema_list) {\r\nif ((xid >= ema->mp->min_xid) &&\r\n(xid <= ema->mp->max_xid))\r\nreturn ema;\r\n}\r\nreturn NULL;\r\n}\r\nvoid fc_exch_recv(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct fc_frame_header *fh = fc_frame_header_get(fp);\r\nstruct fc_exch_mgr_anchor *ema;\r\nu32 f_ctl;\r\nif (!lport || lport->state == LPORT_ST_DISABLED) {\r\nFC_LPORT_DBG(lport, "Receiving frames for an lport that "\r\n"has not been initialized correctly\n");\r\nfc_frame_free(fp);\r\nreturn;\r\n}\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nema = fc_find_ema(f_ctl, lport, fh);\r\nif (!ema) {\r\nFC_LPORT_DBG(lport, "Unable to find Exchange Manager Anchor,"\r\n"fc_ctl <0x%x>, xid <0x%x>\n",\r\nf_ctl,\r\n(f_ctl & FC_FC_EX_CTX) ?\r\nntohs(fh->fh_ox_id) :\r\nntohs(fh->fh_rx_id));\r\nfc_frame_free(fp);\r\nreturn;\r\n}\r\nswitch (fr_eof(fp)) {\r\ncase FC_EOF_T:\r\nif (f_ctl & FC_FC_END_SEQ)\r\nskb_trim(fp_skb(fp), fr_len(fp) - FC_FC_FILL(f_ctl));\r\ncase FC_EOF_N:\r\nif (fh->fh_type == FC_TYPE_BLS)\r\nfc_exch_recv_bls(ema->mp, fp);\r\nelse if ((f_ctl & (FC_FC_EX_CTX | FC_FC_SEQ_CTX)) ==\r\nFC_FC_EX_CTX)\r\nfc_exch_recv_seq_resp(ema->mp, fp);\r\nelse if (f_ctl & FC_FC_SEQ_CTX)\r\nfc_exch_recv_resp(ema->mp, fp);\r\nelse\r\nfc_exch_recv_req(lport, ema->mp, fp);\r\nbreak;\r\ndefault:\r\nFC_LPORT_DBG(lport, "dropping invalid frame (eof %x)",\r\nfr_eof(fp));\r\nfc_frame_free(fp);\r\n}\r\n}\r\nint fc_exch_init(struct fc_lport *lport)\r\n{\r\nif (!lport->tt.seq_start_next)\r\nlport->tt.seq_start_next = fc_seq_start_next;\r\nif (!lport->tt.seq_set_resp)\r\nlport->tt.seq_set_resp = fc_seq_set_resp;\r\nif (!lport->tt.exch_seq_send)\r\nlport->tt.exch_seq_send = fc_exch_seq_send;\r\nif (!lport->tt.seq_send)\r\nlport->tt.seq_send = fc_seq_send;\r\nif (!lport->tt.seq_els_rsp_send)\r\nlport->tt.seq_els_rsp_send = fc_seq_els_rsp_send;\r\nif (!lport->tt.exch_done)\r\nlport->tt.exch_done = fc_exch_done;\r\nif (!lport->tt.exch_mgr_reset)\r\nlport->tt.exch_mgr_reset = fc_exch_mgr_reset;\r\nif (!lport->tt.seq_exch_abort)\r\nlport->tt.seq_exch_abort = fc_seq_exch_abort;\r\nif (!lport->tt.seq_assign)\r\nlport->tt.seq_assign = fc_seq_assign;\r\nif (!lport->tt.seq_release)\r\nlport->tt.seq_release = fc_seq_release;\r\nreturn 0;\r\n}\r\nint fc_setup_exch_mgr(void)\r\n{\r\nfc_em_cachep = kmem_cache_create("libfc_em", sizeof(struct fc_exch),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (!fc_em_cachep)\r\nreturn -ENOMEM;\r\nfc_cpu_mask = 1;\r\nfc_cpu_order = 0;\r\nwhile (fc_cpu_mask < nr_cpu_ids) {\r\nfc_cpu_mask <<= 1;\r\nfc_cpu_order++;\r\n}\r\nfc_cpu_mask--;\r\nfc_exch_workqueue = create_singlethread_workqueue("fc_exch_workqueue");\r\nif (!fc_exch_workqueue)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkmem_cache_destroy(fc_em_cachep);\r\nreturn -ENOMEM;\r\n}\r\nvoid fc_destroy_exch_mgr(void)\r\n{\r\ndestroy_workqueue(fc_exch_workqueue);\r\nkmem_cache_destroy(fc_em_cachep);\r\n}
