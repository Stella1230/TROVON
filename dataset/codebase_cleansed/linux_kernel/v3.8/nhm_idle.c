static int nhm_get_count(enum intel_nhm_id id, unsigned long long *val,\r\nunsigned int cpu)\r\n{\r\nint msr;\r\nswitch (id) {\r\ncase C3:\r\nmsr = MSR_CORE_C3_RESIDENCY;\r\nbreak;\r\ncase C6:\r\nmsr = MSR_CORE_C6_RESIDENCY;\r\nbreak;\r\ncase PC3:\r\nmsr = MSR_PKG_C3_RESIDENCY;\r\nbreak;\r\ncase PC6:\r\nmsr = MSR_PKG_C6_RESIDENCY;\r\nbreak;\r\ncase TSC:\r\nmsr = MSR_TSC;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n};\r\nif (read_msr(cpu, msr, val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int nhm_get_count_percent(unsigned int id, double *percent,\r\nunsigned int cpu)\r\n{\r\n*percent = 0.0;\r\nif (!is_valid[cpu])\r\nreturn -1;\r\n*percent = (100.0 *\r\n(current_count[id][cpu] - previous_count[id][cpu])) /\r\n(tsc_at_measure_end - tsc_at_measure_start);\r\ndprint("%s: previous: %llu - current: %llu - (%u)\n",\r\nnhm_cstates[id].name, previous_count[id][cpu],\r\ncurrent_count[id][cpu], cpu);\r\ndprint("%s: tsc_diff: %llu - count_diff: %llu - percent: %2.f (%u)\n",\r\nnhm_cstates[id].name,\r\n(unsigned long long) tsc_at_measure_end - tsc_at_measure_start,\r\ncurrent_count[id][cpu] - previous_count[id][cpu],\r\n*percent, cpu);\r\nreturn 0;\r\n}\r\nstatic int nhm_start(void)\r\n{\r\nint num, cpu;\r\nunsigned long long dbg, val;\r\nnhm_get_count(TSC, &tsc_at_measure_start, 0);\r\nfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\r\nfor (cpu = 0; cpu < cpu_count; cpu++) {\r\nis_valid[cpu] = !nhm_get_count(num, &val, cpu);\r\nprevious_count[num][cpu] = val;\r\n}\r\n}\r\nnhm_get_count(TSC, &dbg, 0);\r\ndprint("TSC diff: %llu\n", dbg - tsc_at_measure_start);\r\nreturn 0;\r\n}\r\nstatic int nhm_stop(void)\r\n{\r\nunsigned long long val;\r\nunsigned long long dbg;\r\nint num, cpu;\r\nnhm_get_count(TSC, &tsc_at_measure_end, 0);\r\nfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\r\nfor (cpu = 0; cpu < cpu_count; cpu++) {\r\nis_valid[cpu] = !nhm_get_count(num, &val, cpu);\r\ncurrent_count[num][cpu] = val;\r\n}\r\n}\r\nnhm_get_count(TSC, &dbg, 0);\r\ndprint("TSC diff: %llu\n", dbg - tsc_at_measure_end);\r\nreturn 0;\r\n}\r\nstruct cpuidle_monitor *intel_nhm_register(void)\r\n{\r\nint num;\r\nif (cpupower_cpu_info.vendor != X86_VENDOR_INTEL)\r\nreturn NULL;\r\nif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_INV_TSC))\r\nreturn NULL;\r\nif (!(cpupower_cpu_info.caps & CPUPOWER_CAP_APERF))\r\nreturn NULL;\r\nis_valid = calloc(cpu_count, sizeof(int));\r\nfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\r\nprevious_count[num] = calloc(cpu_count,\r\nsizeof(unsigned long long));\r\ncurrent_count[num] = calloc(cpu_count,\r\nsizeof(unsigned long long));\r\n}\r\nintel_nhm_monitor.name_len = strlen(intel_nhm_monitor.name);\r\nreturn &intel_nhm_monitor;\r\n}\r\nvoid intel_nhm_unregister(void)\r\n{\r\nint num;\r\nfor (num = 0; num < NHM_CSTATE_COUNT; num++) {\r\nfree(previous_count[num]);\r\nfree(current_count[num]);\r\n}\r\nfree(is_valid);\r\n}
