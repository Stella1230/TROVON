static void\r\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\r\n{\r\niput(data->dir);\r\nput_rpccred(data->cred);\r\nkfree(data->args.name.name);\r\nkfree(data);\r\n}\r\nstatic int nfs_copy_dname(struct dentry *dentry, struct nfs_unlinkdata *data)\r\n{\r\nchar *str;\r\nint len = dentry->d_name.len;\r\nstr = kmemdup(dentry->d_name.name, NAME_ALLOC_LEN(len), GFP_KERNEL);\r\nif (!str)\r\nreturn -ENOMEM;\r\ndata->args.name.len = len;\r\ndata->args.name.name = str;\r\nreturn 0;\r\n}\r\nstatic void nfs_free_dname(struct nfs_unlinkdata *data)\r\n{\r\nkfree(data->args.name.name);\r\ndata->args.name.name = NULL;\r\ndata->args.name.len = 0;\r\n}\r\nstatic void nfs_dec_sillycount(struct inode *dir)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(dir);\r\nif (atomic_dec_return(&nfsi->silly_count) == 1)\r\nwake_up(&nfsi->waitqueue);\r\n}\r\nstatic void nfs_async_unlink_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_unlinkdata *data = calldata;\r\nstruct inode *dir = data->dir;\r\nif (!NFS_PROTO(dir)->unlink_done(task, dir))\r\nrpc_restart_call_prepare(task);\r\n}\r\nstatic void nfs_async_unlink_release(void *calldata)\r\n{\r\nstruct nfs_unlinkdata *data = calldata;\r\nstruct super_block *sb = data->dir->i_sb;\r\nnfs_dec_sillycount(data->dir);\r\nnfs_free_unlinkdata(data);\r\nnfs_sb_deactive_async(sb);\r\n}\r\nstatic void nfs_unlink_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_unlinkdata *data = calldata;\r\nNFS_PROTO(data->dir)->unlink_rpc_prepare(task, data);\r\n}\r\nstatic int nfs_do_call_unlink(struct dentry *parent, struct inode *dir, struct nfs_unlinkdata *data)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_argp = &data->args,\r\n.rpc_resp = &data->res,\r\n.rpc_cred = data->cred,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_message = &msg,\r\n.callback_ops = &nfs_unlink_ops,\r\n.callback_data = data,\r\n.workqueue = nfsiod_workqueue,\r\n.flags = RPC_TASK_ASYNC,\r\n};\r\nstruct rpc_task *task;\r\nstruct dentry *alias;\r\nalias = d_lookup(parent, &data->args.name);\r\nif (alias != NULL) {\r\nint ret;\r\nvoid *devname_garbage = NULL;\r\nnfs_free_dname(data);\r\nret = nfs_copy_dname(alias, data);\r\nspin_lock(&alias->d_lock);\r\nif (ret == 0 && alias->d_inode != NULL &&\r\n!(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\r\ndevname_garbage = alias->d_fsdata;\r\nalias->d_fsdata = data;\r\nalias->d_flags |= DCACHE_NFSFS_RENAMED;\r\nret = 1;\r\n} else\r\nret = 0;\r\nspin_unlock(&alias->d_lock);\r\nnfs_dec_sillycount(dir);\r\ndput(alias);\r\nkfree(devname_garbage);\r\nreturn ret;\r\n}\r\ndata->dir = igrab(dir);\r\nif (!data->dir) {\r\nnfs_dec_sillycount(dir);\r\nreturn 0;\r\n}\r\nnfs_sb_active(dir->i_sb);\r\ndata->args.fh = NFS_FH(dir);\r\nnfs_fattr_init(data->res.dir_attr);\r\nNFS_PROTO(dir)->unlink_setup(&msg, dir);\r\ntask_setup_data.rpc_client = NFS_CLIENT(dir);\r\ntask = rpc_run_task(&task_setup_data);\r\nif (!IS_ERR(task))\r\nrpc_put_task_async(task);\r\nreturn 1;\r\n}\r\nstatic int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)\r\n{\r\nstruct dentry *parent;\r\nstruct inode *dir;\r\nint ret = 0;\r\nparent = dget_parent(dentry);\r\nif (parent == NULL)\r\ngoto out_free;\r\ndir = parent->d_inode;\r\nspin_lock(&dir->i_lock);\r\nif (atomic_inc_not_zero(&NFS_I(dir)->silly_count) == 0) {\r\nhlist_add_head(&data->list, &NFS_I(dir)->silly_list);\r\nspin_unlock(&dir->i_lock);\r\nret = 1;\r\ngoto out_dput;\r\n}\r\nspin_unlock(&dir->i_lock);\r\nret = nfs_do_call_unlink(parent, dir, data);\r\nout_dput:\r\ndput(parent);\r\nout_free:\r\nreturn ret;\r\n}\r\nvoid nfs_block_sillyrename(struct dentry *dentry)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\r\nwait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\r\n}\r\nvoid nfs_unblock_sillyrename(struct dentry *dentry)\r\n{\r\nstruct inode *dir = dentry->d_inode;\r\nstruct nfs_inode *nfsi = NFS_I(dir);\r\nstruct nfs_unlinkdata *data;\r\natomic_inc(&nfsi->silly_count);\r\nspin_lock(&dir->i_lock);\r\nwhile (!hlist_empty(&nfsi->silly_list)) {\r\nif (!atomic_inc_not_zero(&nfsi->silly_count))\r\nbreak;\r\ndata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\r\nhlist_del(&data->list);\r\nspin_unlock(&dir->i_lock);\r\nif (nfs_do_call_unlink(dentry, dir, data) == 0)\r\nnfs_free_unlinkdata(data);\r\nspin_lock(&dir->i_lock);\r\n}\r\nspin_unlock(&dir->i_lock);\r\n}\r\nstatic int\r\nnfs_async_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct nfs_unlinkdata *data;\r\nint status = -ENOMEM;\r\nvoid *devname_garbage = NULL;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\ngoto out;\r\ndata->cred = rpc_lookup_cred();\r\nif (IS_ERR(data->cred)) {\r\nstatus = PTR_ERR(data->cred);\r\ngoto out_free;\r\n}\r\ndata->res.dir_attr = &data->dir_attr;\r\nstatus = -EBUSY;\r\nspin_lock(&dentry->d_lock);\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\r\ngoto out_unlock;\r\ndentry->d_flags |= DCACHE_NFSFS_RENAMED;\r\ndevname_garbage = dentry->d_fsdata;\r\ndentry->d_fsdata = data;\r\nspin_unlock(&dentry->d_lock);\r\nif (devname_garbage)\r\nkfree(devname_garbage);\r\nreturn 0;\r\nout_unlock:\r\nspin_unlock(&dentry->d_lock);\r\nput_rpccred(data->cred);\r\nout_free:\r\nkfree(data);\r\nout:\r\nreturn status;\r\n}\r\nvoid\r\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\r\n{\r\nstruct nfs_unlinkdata *data = NULL;\r\nspin_lock(&dentry->d_lock);\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\r\ndentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\r\ndata = dentry->d_fsdata;\r\ndentry->d_fsdata = NULL;\r\n}\r\nspin_unlock(&dentry->d_lock);\r\nif (data != NULL && (NFS_STALE(inode) || !nfs_call_unlink(dentry, data)))\r\nnfs_free_unlinkdata(data);\r\n}\r\nstatic void\r\nnfs_cancel_async_unlink(struct dentry *dentry)\r\n{\r\nspin_lock(&dentry->d_lock);\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\r\nstruct nfs_unlinkdata *data = dentry->d_fsdata;\r\ndentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\r\ndentry->d_fsdata = NULL;\r\nspin_unlock(&dentry->d_lock);\r\nnfs_free_unlinkdata(data);\r\nreturn;\r\n}\r\nspin_unlock(&dentry->d_lock);\r\n}\r\nstatic void nfs_async_rename_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_renamedata *data = calldata;\r\nstruct inode *old_dir = data->old_dir;\r\nstruct inode *new_dir = data->new_dir;\r\nstruct dentry *old_dentry = data->old_dentry;\r\nstruct dentry *new_dentry = data->new_dentry;\r\nif (!NFS_PROTO(old_dir)->rename_done(task, old_dir, new_dir)) {\r\nrpc_restart_call_prepare(task);\r\nreturn;\r\n}\r\nif (task->tk_status != 0) {\r\nnfs_cancel_async_unlink(old_dentry);\r\nreturn;\r\n}\r\nd_drop(old_dentry);\r\nd_drop(new_dentry);\r\n}\r\nstatic void nfs_async_rename_release(void *calldata)\r\n{\r\nstruct nfs_renamedata *data = calldata;\r\nstruct super_block *sb = data->old_dir->i_sb;\r\nif (data->old_dentry->d_inode)\r\nnfs_mark_for_revalidate(data->old_dentry->d_inode);\r\ndput(data->old_dentry);\r\ndput(data->new_dentry);\r\niput(data->old_dir);\r\niput(data->new_dir);\r\nnfs_sb_deactive(sb);\r\nput_rpccred(data->cred);\r\nkfree(data);\r\n}\r\nstatic void nfs_rename_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_renamedata *data = calldata;\r\nNFS_PROTO(data->old_dir)->rename_rpc_prepare(task, data);\r\n}\r\nstatic struct rpc_task *\r\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\r\nstruct dentry *old_dentry, struct dentry *new_dentry)\r\n{\r\nstruct nfs_renamedata *data;\r\nstruct rpc_message msg = { };\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_message = &msg,\r\n.callback_ops = &nfs_rename_ops,\r\n.workqueue = nfsiod_workqueue,\r\n.rpc_client = NFS_CLIENT(old_dir),\r\n.flags = RPC_TASK_ASYNC,\r\n};\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ntask_setup_data.callback_data = data;\r\ndata->cred = rpc_lookup_cred();\r\nif (IS_ERR(data->cred)) {\r\nstruct rpc_task *task = ERR_CAST(data->cred);\r\nkfree(data);\r\nreturn task;\r\n}\r\nmsg.rpc_argp = &data->args;\r\nmsg.rpc_resp = &data->res;\r\nmsg.rpc_cred = data->cred;\r\ndata->old_dir = old_dir;\r\nihold(old_dir);\r\ndata->new_dir = new_dir;\r\nihold(new_dir);\r\ndata->old_dentry = dget(old_dentry);\r\ndata->new_dentry = dget(new_dentry);\r\nnfs_fattr_init(&data->old_fattr);\r\nnfs_fattr_init(&data->new_fattr);\r\ndata->args.old_dir = NFS_FH(old_dir);\r\ndata->args.old_name = &old_dentry->d_name;\r\ndata->args.new_dir = NFS_FH(new_dir);\r\ndata->args.new_name = &new_dentry->d_name;\r\ndata->res.old_fattr = &data->old_fattr;\r\ndata->res.new_fattr = &data->new_fattr;\r\nnfs_sb_active(old_dir->i_sb);\r\nNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\r\nreturn rpc_run_task(&task_setup_data);\r\n}\r\nint\r\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\r\n{\r\nstatic unsigned int sillycounter;\r\nconst int fileidsize = sizeof(NFS_FILEID(dentry->d_inode))*2;\r\nconst int countersize = sizeof(sillycounter)*2;\r\nconst int slen = sizeof(".nfs")+fileidsize+countersize-1;\r\nchar silly[slen+1];\r\nstruct dentry *sdentry;\r\nstruct rpc_task *task;\r\nint error = -EIO;\r\ndfprintk(VFS, "NFS: silly-rename(%s/%s, ct=%d)\n",\r\ndentry->d_parent->d_name.name, dentry->d_name.name,\r\ndentry->d_count);\r\nnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\r\nerror = -EBUSY;\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\r\ngoto out;\r\nsprintf(silly, ".nfs%*.*Lx",\r\nfileidsize, fileidsize,\r\n(unsigned long long)NFS_FILEID(dentry->d_inode));\r\nNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\r\nsdentry = NULL;\r\ndo {\r\nchar *suffix = silly + slen - countersize;\r\ndput(sdentry);\r\nsillycounter++;\r\nsprintf(suffix, "%*.*x", countersize, countersize, sillycounter);\r\ndfprintk(VFS, "NFS: trying to rename %s to %s\n",\r\ndentry->d_name.name, silly);\r\nsdentry = lookup_one_len(silly, dentry->d_parent, slen);\r\nif (IS_ERR(sdentry))\r\ngoto out;\r\n} while (sdentry->d_inode != NULL);\r\nerror = nfs_async_unlink(dir, dentry);\r\nif (error)\r\ngoto out_dput;\r\nerror = nfs_copy_dname(sdentry,\r\n(struct nfs_unlinkdata *)dentry->d_fsdata);\r\nif (error) {\r\nnfs_cancel_async_unlink(dentry);\r\ngoto out_dput;\r\n}\r\ntask = nfs_async_rename(dir, dir, dentry, sdentry);\r\nif (IS_ERR(task)) {\r\nerror = -EBUSY;\r\nnfs_cancel_async_unlink(dentry);\r\ngoto out_dput;\r\n}\r\nerror = rpc_wait_for_completion_task(task);\r\nif (error == 0)\r\nerror = task->tk_status;\r\nrpc_put_task(task);\r\nout_dput:\r\ndput(sdentry);\r\nout:\r\nreturn error;\r\n}
