static inline unsigned int rpm_from_cnt(u8 val, u32 clk, u16 div)\r\n{\r\nreturn ((val == 0x00) ? 0 : ((clk*30)/(val*div)));\r\n}\r\nstatic int g760a_read_value(struct i2c_client *client, enum g760a_regs reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int g760a_write_value(struct i2c_client *client, enum g760a_regs reg,\r\nu16 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic struct g760a_data *g760a_update_client(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g760a_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + G760A_UPDATE_INTERVAL)\r\n|| !data->valid) {\r\ndev_dbg(&client->dev, "Starting g760a update\n");\r\ndata->set_cnt = g760a_read_value(client, G760A_REG_SET_CNT);\r\ndata->act_cnt = g760a_read_value(client, G760A_REG_ACT_CNT);\r\ndata->fan_sta = g760a_read_value(client, G760A_REG_FAN_STA);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nunsigned int rpm = 0;\r\nmutex_lock(&data->update_lock);\r\nif (!(data->fan_sta & G760A_REG_FAN_STA_RPM_LOW))\r\nrpm = rpm_from_cnt(data->act_cnt, data->clk, data->fan_div);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nint fan_alarm = (data->fan_sta & G760A_REG_FAN_STA_RPM_OFF) ? 1 : 0;\r\nreturn sprintf(buf, "%d\n", fan_alarm);\r\n}\r\nstatic ssize_t get_pwm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_CNT(data->set_cnt));\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g760a_data *data = g760a_update_client(dev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->set_cnt = PWM_TO_CNT(SENSORS_LIMIT(val, 0, 255));\r\ng760a_write_value(client, G760A_REG_SET_CNT, data->set_cnt);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int g760a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct g760a_data *data;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct g760a_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\ndata->fan_div = G760A_DEFAULT_FAN_DIV;\r\ndata->clk = G760A_DEFAULT_CLK;\r\nerr = sysfs_create_group(&client->dev.kobj, &g760a_group);\r\nif (err)\r\nreturn err;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto error_hwmon_device_register;\r\n}\r\nreturn 0;\r\nerror_hwmon_device_register:\r\nsysfs_remove_group(&client->dev.kobj, &g760a_group);\r\nreturn err;\r\n}\r\nstatic int g760a_remove(struct i2c_client *client)\r\n{\r\nstruct g760a_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &g760a_group);\r\nreturn 0;\r\n}
