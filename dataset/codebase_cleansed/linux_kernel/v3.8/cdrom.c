static int cdrom_dummy_generic_packet(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc)\r\n{\r\nif (cgc->sense) {\r\ncgc->sense->sense_key = 0x05;\r\ncgc->sense->asc = 0x20;\r\ncgc->sense->ascq = 0x00;\r\n}\r\ncgc->stat = -EIO;\r\nreturn -EIO;\r\n}\r\nint register_cdrom(struct cdrom_device_info *cdi)\r\n{\r\nstatic char banner_printed;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nint *change_capability = (int *)&cdo->capability;\r\ncdinfo(CD_OPEN, "entering register_cdrom\n");\r\nif (cdo->open == NULL || cdo->release == NULL)\r\nreturn -EINVAL;\r\nif (!banner_printed) {\r\npr_info("Uniform CD-ROM driver " REVISION "\n");\r\nbanner_printed = 1;\r\ncdrom_sysctl_register();\r\n}\r\nENSURE(drive_status, CDC_DRIVE_STATUS );\r\nif (cdo->check_events == NULL && cdo->media_changed == NULL)\r\n*change_capability = ~(CDC_MEDIA_CHANGED | CDC_SELECT_DISC);\r\nENSURE(tray_move, CDC_CLOSE_TRAY | CDC_OPEN_TRAY);\r\nENSURE(lock_door, CDC_LOCK);\r\nENSURE(select_speed, CDC_SELECT_SPEED);\r\nENSURE(get_last_session, CDC_MULTI_SESSION);\r\nENSURE(get_mcn, CDC_MCN);\r\nENSURE(reset, CDC_RESET);\r\nENSURE(generic_packet, CDC_GENERIC_PACKET);\r\ncdi->mc_flags = 0;\r\ncdo->n_minors = 0;\r\ncdi->options = CDO_USE_FFLAGS;\r\nif (autoclose==1 && CDROM_CAN(CDC_CLOSE_TRAY))\r\ncdi->options |= (int) CDO_AUTO_CLOSE;\r\nif (autoeject==1 && CDROM_CAN(CDC_OPEN_TRAY))\r\ncdi->options |= (int) CDO_AUTO_EJECT;\r\nif (lockdoor==1)\r\ncdi->options |= (int) CDO_LOCK;\r\nif (check_media_type==1)\r\ncdi->options |= (int) CDO_CHECK_TYPE;\r\nif (CDROM_CAN(CDC_MRW_W))\r\ncdi->exit = cdrom_mrw_exit;\r\nif (cdi->disk)\r\ncdi->cdda_method = CDDA_BPC_FULL;\r\nelse\r\ncdi->cdda_method = CDDA_OLD;\r\nif (!cdo->generic_packet)\r\ncdo->generic_packet = cdrom_dummy_generic_packet;\r\ncdinfo(CD_REG_UNREG, "drive \"/dev/%s\" registered\n", cdi->name);\r\nmutex_lock(&cdrom_mutex);\r\nlist_add(&cdi->list, &cdrom_list);\r\nmutex_unlock(&cdrom_mutex);\r\nreturn 0;\r\n}\r\nvoid unregister_cdrom(struct cdrom_device_info *cdi)\r\n{\r\ncdinfo(CD_OPEN, "entering unregister_cdrom\n");\r\nmutex_lock(&cdrom_mutex);\r\nlist_del(&cdi->list);\r\nmutex_unlock(&cdrom_mutex);\r\nif (cdi->exit)\r\ncdi->exit(cdi);\r\ncdi->ops->n_minors--;\r\ncdinfo(CD_REG_UNREG, "drive \"/dev/%s\" unregistered\n", cdi->name);\r\n}\r\nint cdrom_get_media_event(struct cdrom_device_info *cdi,\r\nstruct media_event_desc *med)\r\n{\r\nstruct packet_command cgc;\r\nunsigned char buffer[8];\r\nstruct event_header *eh = (struct event_header *) buffer;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_GET_EVENT_STATUS_NOTIFICATION;\r\ncgc.cmd[1] = 1;\r\ncgc.cmd[4] = 1 << 4;\r\ncgc.cmd[8] = sizeof(buffer);\r\ncgc.quiet = 1;\r\nif (cdi->ops->generic_packet(cdi, &cgc))\r\nreturn 1;\r\nif (be16_to_cpu(eh->data_len) < sizeof(*med))\r\nreturn 1;\r\nif (eh->nea || eh->notification_class != 0x4)\r\nreturn 1;\r\nmemcpy(med, &buffer[sizeof(*eh)], sizeof(*med));\r\nreturn 0;\r\n}\r\nstatic int cdrom_mrw_probe_pc(struct cdrom_device_info *cdi)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[16];\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.timeout = HZ;\r\ncgc.quiet = 1;\r\nif (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC, 0)) {\r\ncdi->mrw_mode_page = MRW_MODE_PC;\r\nreturn 0;\r\n} else if (!cdrom_mode_sense(cdi, &cgc, MRW_MODE_PC_PRE1, 0)) {\r\ncdi->mrw_mode_page = MRW_MODE_PC_PRE1;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\r\n{\r\nstruct packet_command cgc;\r\nstruct mrw_feature_desc *mfd;\r\nunsigned char buffer[16];\r\nint ret;\r\n*write = 0;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_GET_CONFIGURATION;\r\ncgc.cmd[3] = CDF_MRW;\r\ncgc.cmd[8] = sizeof(buffer);\r\ncgc.quiet = 1;\r\nif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\r\nif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\r\nreturn 1;\r\n*write = mfd->write;\r\nif ((ret = cdrom_mrw_probe_pc(cdi))) {\r\n*write = 0;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdrom_mrw_bgformat(struct cdrom_device_info *cdi, int cont)\r\n{\r\nstruct packet_command cgc;\r\nunsigned char buffer[12];\r\nint ret;\r\npr_info("%sstarting format\n", cont ? "Re" : "");\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_WRITE);\r\ncgc.cmd[0] = GPCMD_FORMAT_UNIT;\r\ncgc.cmd[1] = (1 << 4) | 1;\r\ncgc.timeout = 5 * 60 * HZ;\r\nbuffer[1] = 1 << 1;\r\nbuffer[3] = 8;\r\nbuffer[4] = 0xff;\r\nbuffer[5] = 0xff;\r\nbuffer[6] = 0xff;\r\nbuffer[7] = 0xff;\r\nbuffer[8] = 0x24 << 2;\r\nbuffer[11] = cont;\r\nret = cdi->ops->generic_packet(cdi, &cgc);\r\nif (ret)\r\npr_info("bgformat failed\n");\r\nreturn ret;\r\n}\r\nstatic int cdrom_mrw_bgformat_susp(struct cdrom_device_info *cdi, int immed)\r\n{\r\nstruct packet_command cgc;\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_CLOSE_TRACK;\r\ncgc.cmd[1] = !!immed;\r\ncgc.cmd[2] = 1 << 1;\r\ncgc.timeout = 5 * 60 * HZ;\r\nreturn cdi->ops->generic_packet(cdi, &cgc);\r\n}\r\nstatic int cdrom_flush_cache(struct cdrom_device_info *cdi)\r\n{\r\nstruct packet_command cgc;\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_FLUSH_CACHE;\r\ncgc.timeout = 5 * 60 * HZ;\r\nreturn cdi->ops->generic_packet(cdi, &cgc);\r\n}\r\nstatic int cdrom_mrw_exit(struct cdrom_device_info *cdi)\r\n{\r\ndisc_information di;\r\nint ret;\r\nret = cdrom_get_disc_info(cdi, &di);\r\nif (ret < 0 || ret < (int)offsetof(typeof(di),disc_type))\r\nreturn 1;\r\nret = 0;\r\nif (di.mrw_status == CDM_MRW_BGFORMAT_ACTIVE) {\r\npr_info("issuing MRW background format suspend\n");\r\nret = cdrom_mrw_bgformat_susp(cdi, 0);\r\n}\r\nif (!ret && cdi->media_written)\r\nret = cdrom_flush_cache(cdi);\r\nreturn ret;\r\n}\r\nstatic int cdrom_mrw_set_lba_space(struct cdrom_device_info *cdi, int space)\r\n{\r\nstruct packet_command cgc;\r\nstruct mode_page_header *mph;\r\nchar buffer[16];\r\nint ret, offset, size;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.buffer = buffer;\r\ncgc.buflen = sizeof(buffer);\r\nif ((ret = cdrom_mode_sense(cdi, &cgc, cdi->mrw_mode_page, 0)))\r\nreturn ret;\r\nmph = (struct mode_page_header *) buffer;\r\noffset = be16_to_cpu(mph->desc_length);\r\nsize = be16_to_cpu(mph->mode_data_length) + 2;\r\nbuffer[offset + 3] = space;\r\ncgc.buflen = size;\r\nif ((ret = cdrom_mode_select(cdi, &cgc)))\r\nreturn ret;\r\npr_info("%s: mrw address space %s selected\n",\r\ncdi->name, mrw_address_space[space]);\r\nreturn 0;\r\n}\r\nstatic int cdrom_get_random_writable(struct cdrom_device_info *cdi,\r\nstruct rwrt_feature_desc *rfd)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[24];\r\nint ret;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_GET_CONFIGURATION;\r\ncgc.cmd[3] = CDF_RWRT;\r\ncgc.cmd[8] = sizeof(buffer);\r\ncgc.quiet = 1;\r\nif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nmemcpy(rfd, &buffer[sizeof(struct feature_header)], sizeof (*rfd));\r\nreturn 0;\r\n}\r\nstatic int cdrom_has_defect_mgt(struct cdrom_device_info *cdi)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[16];\r\n__be16 *feature_code;\r\nint ret;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_GET_CONFIGURATION;\r\ncgc.cmd[3] = CDF_HWDM;\r\ncgc.cmd[8] = sizeof(buffer);\r\ncgc.quiet = 1;\r\nif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nfeature_code = (__be16 *) &buffer[sizeof(struct feature_header)];\r\nif (be16_to_cpu(*feature_code) == CDF_HWDM)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int cdrom_is_random_writable(struct cdrom_device_info *cdi, int *write)\r\n{\r\nstruct rwrt_feature_desc rfd;\r\nint ret;\r\n*write = 0;\r\nif ((ret = cdrom_get_random_writable(cdi, &rfd)))\r\nreturn ret;\r\nif (CDF_RWRT == be16_to_cpu(rfd.feature_code))\r\n*write = 1;\r\nreturn 0;\r\n}\r\nstatic int cdrom_media_erasable(struct cdrom_device_info *cdi)\r\n{\r\ndisc_information di;\r\nint ret;\r\nret = cdrom_get_disc_info(cdi, &di);\r\nif (ret < 0 || ret < offsetof(typeof(di), n_first_track))\r\nreturn -1;\r\nreturn di.erasable;\r\n}\r\nstatic int cdrom_dvdram_open_write(struct cdrom_device_info *cdi)\r\n{\r\nint ret = cdrom_media_erasable(cdi);\r\nif (!ret)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int cdrom_mrw_open_write(struct cdrom_device_info *cdi)\r\n{\r\ndisc_information di;\r\nint ret;\r\nif (cdrom_mrw_set_lba_space(cdi, MRW_LBA_DMA)) {\r\npr_err("failed setting lba address space\n");\r\nreturn 1;\r\n}\r\nret = cdrom_get_disc_info(cdi, &di);\r\nif (ret < 0 || ret < offsetof(typeof(di),disc_type))\r\nreturn 1;\r\nif (!di.erasable)\r\nreturn 1;\r\nret = 0;\r\npr_info("open: mrw_status '%s'\n", mrw_format_status[di.mrw_status]);\r\nif (!di.mrw_status)\r\nret = 1;\r\nelse if (di.mrw_status == CDM_MRW_BGFORMAT_INACTIVE &&\r\nmrw_format_restart)\r\nret = cdrom_mrw_bgformat(cdi, 1);\r\nreturn ret;\r\n}\r\nstatic int mo_open_write(struct cdrom_device_info *cdi)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[255];\r\nint ret;\r\ninit_cdrom_command(&cgc, &buffer, 4, CGC_DATA_READ);\r\ncgc.quiet = 1;\r\nret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\r\nif (ret)\r\nret = cdrom_mode_sense(cdi, &cgc, GPMODE_VENDOR_PAGE, 0);\r\nif (ret) {\r\ncgc.buflen = 255;\r\nret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);\r\n}\r\nif (ret)\r\nreturn 0;\r\nreturn buffer[3] & 0x80;\r\n}\r\nstatic int cdrom_ram_open_write(struct cdrom_device_info *cdi)\r\n{\r\nstruct rwrt_feature_desc rfd;\r\nint ret;\r\nif ((ret = cdrom_has_defect_mgt(cdi)))\r\nreturn ret;\r\nif ((ret = cdrom_get_random_writable(cdi, &rfd)))\r\nreturn ret;\r\nelse if (CDF_RWRT == be16_to_cpu(rfd.feature_code))\r\nret = !rfd.curr;\r\ncdinfo(CD_OPEN, "can open for random write\n");\r\nreturn ret;\r\n}\r\nstatic void cdrom_mmc3_profile(struct cdrom_device_info *cdi)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[32];\r\nint ret, mmc3_profile;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_GET_CONFIGURATION;\r\ncgc.cmd[1] = 0;\r\ncgc.cmd[2] = cgc.cmd[3] = 0;\r\ncgc.cmd[8] = sizeof(buffer);\r\ncgc.quiet = 1;\r\nif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\r\nmmc3_profile = 0xffff;\r\nelse\r\nmmc3_profile = (buffer[6] << 8) | buffer[7];\r\ncdi->mmc3_profile = mmc3_profile;\r\n}\r\nstatic int cdrom_is_dvd_rw(struct cdrom_device_info *cdi)\r\n{\r\nswitch (cdi->mmc3_profile) {\r\ncase 0x12:\r\ncase 0x1A:\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int cdrom_open_write(struct cdrom_device_info *cdi)\r\n{\r\nint mrw, mrw_write, ram_write;\r\nint ret = 1;\r\nmrw = 0;\r\nif (!cdrom_is_mrw(cdi, &mrw_write))\r\nmrw = 1;\r\nif (CDROM_CAN(CDC_MO_DRIVE))\r\nram_write = 1;\r\nelse\r\n(void) cdrom_is_random_writable(cdi, &ram_write);\r\nif (mrw)\r\ncdi->mask &= ~CDC_MRW;\r\nelse\r\ncdi->mask |= CDC_MRW;\r\nif (mrw_write)\r\ncdi->mask &= ~CDC_MRW_W;\r\nelse\r\ncdi->mask |= CDC_MRW_W;\r\nif (ram_write)\r\ncdi->mask &= ~CDC_RAM;\r\nelse\r\ncdi->mask |= CDC_RAM;\r\nif (CDROM_CAN(CDC_MRW_W))\r\nret = cdrom_mrw_open_write(cdi);\r\nelse if (CDROM_CAN(CDC_DVD_RAM))\r\nret = cdrom_dvdram_open_write(cdi);\r\nelse if (CDROM_CAN(CDC_RAM) &&\r\n!CDROM_CAN(CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_MRW|CDC_MO_DRIVE))\r\nret = cdrom_ram_open_write(cdi);\r\nelse if (CDROM_CAN(CDC_MO_DRIVE))\r\nret = mo_open_write(cdi);\r\nelse if (!cdrom_is_dvd_rw(cdi))\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void cdrom_dvd_rw_close_write(struct cdrom_device_info *cdi)\r\n{\r\nstruct packet_command cgc;\r\nif (cdi->mmc3_profile != 0x1a) {\r\ncdinfo(CD_CLOSE, "%s: No DVD+RW\n", cdi->name);\r\nreturn;\r\n}\r\nif (!cdi->media_written) {\r\ncdinfo(CD_CLOSE, "%s: DVD+RW media clean\n", cdi->name);\r\nreturn;\r\n}\r\npr_info("%s: dirty DVD+RW media, \"finalizing\"\n", cdi->name);\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_FLUSH_CACHE;\r\ncgc.timeout = 30*HZ;\r\ncdi->ops->generic_packet(cdi, &cgc);\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_CLOSE_TRACK;\r\ncgc.timeout = 3000*HZ;\r\ncgc.quiet = 1;\r\ncdi->ops->generic_packet(cdi, &cgc);\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_CLOSE_TRACK;\r\ncgc.cmd[2] = 2;\r\ncgc.quiet = 1;\r\ncgc.timeout = 3000*HZ;\r\ncdi->ops->generic_packet(cdi, &cgc);\r\ncdi->media_written = 0;\r\n}\r\nstatic int cdrom_close_write(struct cdrom_device_info *cdi)\r\n{\r\n#if 0\r\nreturn cdrom_flush_cache(cdi);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint cdrom_open(struct cdrom_device_info *cdi, struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\ncdinfo(CD_OPEN, "entering cdrom_open\n");\r\ncheck_disk_change(bdev);\r\ncdi->use_count++;\r\nif ((mode & FMODE_NDELAY) && (cdi->options & CDO_USE_FFLAGS)) {\r\nret = cdi->ops->open(cdi, 1);\r\n} else {\r\nret = open_for_data(cdi);\r\nif (ret)\r\ngoto err;\r\ncdrom_mmc3_profile(cdi);\r\nif (mode & FMODE_WRITE) {\r\nret = -EROFS;\r\nif (cdrom_open_write(cdi))\r\ngoto err_release;\r\nif (!CDROM_CAN(CDC_RAM))\r\ngoto err_release;\r\nret = 0;\r\ncdi->media_written = 0;\r\n}\r\n}\r\nif (ret)\r\ngoto err;\r\ncdinfo(CD_OPEN, "Use count for \"/dev/%s\" now %d\n",\r\ncdi->name, cdi->use_count);\r\nreturn 0;\r\nerr_release:\r\nif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\r\ncdi->ops->lock_door(cdi, 0);\r\ncdinfo(CD_OPEN, "door unlocked.\n");\r\n}\r\ncdi->ops->release(cdi);\r\nerr:\r\ncdi->use_count--;\r\nreturn ret;\r\n}\r\nstatic\r\nint open_for_data(struct cdrom_device_info * cdi)\r\n{\r\nint ret;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\ntracktype tracks;\r\ncdinfo(CD_OPEN, "entering open_for_data\n");\r\nif (cdo->drive_status != NULL) {\r\nret = cdo->drive_status(cdi, CDSL_CURRENT);\r\ncdinfo(CD_OPEN, "drive_status=%d\n", ret);\r\nif (ret == CDS_TRAY_OPEN) {\r\ncdinfo(CD_OPEN, "the tray is open...\n");\r\nif (CDROM_CAN(CDC_CLOSE_TRAY) &&\r\ncdi->options & CDO_AUTO_CLOSE) {\r\ncdinfo(CD_OPEN, "trying to close the tray.\n");\r\nret=cdo->tray_move(cdi,0);\r\nif (ret) {\r\ncdinfo(CD_OPEN, "bummer. tried to close the tray but failed.\n");\r\nret=-ENOMEDIUM;\r\ngoto clean_up_and_return;\r\n}\r\n} else {\r\ncdinfo(CD_OPEN, "bummer. this drive can't close the tray.\n");\r\nret=-ENOMEDIUM;\r\ngoto clean_up_and_return;\r\n}\r\nret = cdo->drive_status(cdi, CDSL_CURRENT);\r\nif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\r\ncdinfo(CD_OPEN, "bummer. the tray is still not closed.\n");\r\ncdinfo(CD_OPEN, "tray might not contain a medium.\n");\r\nret=-ENOMEDIUM;\r\ngoto clean_up_and_return;\r\n}\r\ncdinfo(CD_OPEN, "the tray is now closed.\n");\r\n}\r\nret = cdo->drive_status(cdi, CDSL_CURRENT);\r\nif (ret!=CDS_DISC_OK) {\r\nret = -ENOMEDIUM;\r\ngoto clean_up_and_return;\r\n}\r\n}\r\ncdrom_count_tracks(cdi, &tracks);\r\nif (tracks.error == CDS_NO_DISC) {\r\ncdinfo(CD_OPEN, "bummer. no disc.\n");\r\nret=-ENOMEDIUM;\r\ngoto clean_up_and_return;\r\n}\r\nif (tracks.data==0) {\r\nif (cdi->options & CDO_CHECK_TYPE) {\r\ncdinfo(CD_OPEN, "bummer. wrong media type.\n");\r\ncdinfo(CD_WARNING, "pid %d must open device O_NONBLOCK!\n",\r\n(unsigned int)task_pid_nr(current));\r\nret=-EMEDIUMTYPE;\r\ngoto clean_up_and_return;\r\n}\r\nelse {\r\ncdinfo(CD_OPEN, "wrong media type, but CDO_CHECK_TYPE not set.\n");\r\n}\r\n}\r\ncdinfo(CD_OPEN, "all seems well, opening the device.\n");\r\nret = cdo->open(cdi, 0);\r\ncdinfo(CD_OPEN, "opening the device gave me %d.\n", ret);\r\nif (ret) {\r\ncdinfo(CD_OPEN, "open device failed.\n");\r\ngoto clean_up_and_return;\r\n}\r\nif (CDROM_CAN(CDC_LOCK) && (cdi->options & CDO_LOCK)) {\r\ncdo->lock_door(cdi, 1);\r\ncdinfo(CD_OPEN, "door locked.\n");\r\n}\r\ncdinfo(CD_OPEN, "device opened successfully.\n");\r\nreturn ret;\r\nclean_up_and_return:\r\ncdinfo(CD_OPEN, "open failed.\n");\r\nif (CDROM_CAN(CDC_LOCK) && cdi->options & CDO_LOCK) {\r\ncdo->lock_door(cdi, 0);\r\ncdinfo(CD_OPEN, "door unlocked.\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int check_for_audio_disc(struct cdrom_device_info * cdi,\r\nstruct cdrom_device_ops * cdo)\r\n{\r\nint ret;\r\ntracktype tracks;\r\ncdinfo(CD_OPEN, "entering check_for_audio_disc\n");\r\nif (!(cdi->options & CDO_CHECK_TYPE))\r\nreturn 0;\r\nif (cdo->drive_status != NULL) {\r\nret = cdo->drive_status(cdi, CDSL_CURRENT);\r\ncdinfo(CD_OPEN, "drive_status=%d\n", ret);\r\nif (ret == CDS_TRAY_OPEN) {\r\ncdinfo(CD_OPEN, "the tray is open...\n");\r\nif (CDROM_CAN(CDC_CLOSE_TRAY) &&\r\ncdi->options & CDO_AUTO_CLOSE) {\r\ncdinfo(CD_OPEN, "trying to close the tray.\n");\r\nret=cdo->tray_move(cdi,0);\r\nif (ret) {\r\ncdinfo(CD_OPEN, "bummer. tried to close tray but failed.\n");\r\nreturn -ENOMEDIUM;\r\n}\r\n} else {\r\ncdinfo(CD_OPEN, "bummer. this driver can't close the tray.\n");\r\nreturn -ENOMEDIUM;\r\n}\r\nret = cdo->drive_status(cdi, CDSL_CURRENT);\r\nif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\r\ncdinfo(CD_OPEN, "bummer. the tray is still not closed.\n");\r\nreturn -ENOMEDIUM;\r\n}\r\nif (ret!=CDS_DISC_OK) {\r\ncdinfo(CD_OPEN, "bummer. disc isn't ready.\n");\r\nreturn -EIO;\r\n}\r\ncdinfo(CD_OPEN, "the tray is now closed.\n");\r\n}\r\n}\r\ncdrom_count_tracks(cdi, &tracks);\r\nif (tracks.error)\r\nreturn(tracks.error);\r\nif (tracks.audio==0)\r\nreturn -EMEDIUMTYPE;\r\nreturn 0;\r\n}\r\nvoid cdrom_release(struct cdrom_device_info *cdi, fmode_t mode)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nint opened_for_data;\r\ncdinfo(CD_CLOSE, "entering cdrom_release\n");\r\nif (cdi->use_count > 0)\r\ncdi->use_count--;\r\nif (cdi->use_count == 0) {\r\ncdinfo(CD_CLOSE, "Use count for \"/dev/%s\" now zero\n", cdi->name);\r\ncdrom_dvd_rw_close_write(cdi);\r\nif ((cdo->capability & CDC_LOCK) && !cdi->keeplocked) {\r\ncdinfo(CD_CLOSE, "Unlocking door!\n");\r\ncdo->lock_door(cdi, 0);\r\n}\r\n}\r\nopened_for_data = !(cdi->options & CDO_USE_FFLAGS) ||\r\n!(mode & FMODE_NDELAY);\r\nif (CDROM_CAN(CDC_RAM) && !cdi->use_count && cdi->for_data)\r\ncdrom_close_write(cdi);\r\ncdo->release(cdi);\r\nif (cdi->use_count == 0) {\r\nif (opened_for_data &&\r\ncdi->options & CDO_AUTO_EJECT && CDROM_CAN(CDC_OPEN_TRAY))\r\ncdo->tray_move(cdi, 1);\r\n}\r\n}\r\nstatic int cdrom_read_mech_status(struct cdrom_device_info *cdi,\r\nstruct cdrom_changer_info *buf)\r\n{\r\nstruct packet_command cgc;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nint length;\r\nif (cdi->sanyo_slot) {\r\nbuf->hdr.nslots = 3;\r\nbuf->hdr.curslot = cdi->sanyo_slot == 3 ? 0 : cdi->sanyo_slot;\r\nfor (length = 0; length < 3; length++) {\r\nbuf->slots[length].disc_present = 1;\r\nbuf->slots[length].change = 0;\r\n}\r\nreturn 0;\r\n}\r\nlength = sizeof(struct cdrom_mechstat_header) +\r\ncdi->capacity * sizeof(struct cdrom_slot);\r\ninit_cdrom_command(&cgc, buf, length, CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_MECHANISM_STATUS;\r\ncgc.cmd[8] = (length >> 8) & 0xff;\r\ncgc.cmd[9] = length & 0xff;\r\nreturn cdo->generic_packet(cdi, &cgc);\r\n}\r\nstatic int cdrom_slot_status(struct cdrom_device_info *cdi, int slot)\r\n{\r\nstruct cdrom_changer_info *info;\r\nint ret;\r\ncdinfo(CD_CHANGER, "entering cdrom_slot_status()\n");\r\nif (cdi->sanyo_slot)\r\nreturn CDS_NO_INFO;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nif ((ret = cdrom_read_mech_status(cdi, info)))\r\ngoto out_free;\r\nif (info->slots[slot].disc_present)\r\nret = CDS_DISC_OK;\r\nelse\r\nret = CDS_NO_DISC;\r\nout_free:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nint cdrom_number_of_slots(struct cdrom_device_info *cdi)\r\n{\r\nint status;\r\nint nslots = 1;\r\nstruct cdrom_changer_info *info;\r\ncdinfo(CD_CHANGER, "entering cdrom_number_of_slots()\n");\r\ncdi->capacity = 0;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nif ((status = cdrom_read_mech_status(cdi, info)) == 0)\r\nnslots = info->hdr.nslots;\r\nkfree(info);\r\nreturn nslots;\r\n}\r\nstatic int cdrom_load_unload(struct cdrom_device_info *cdi, int slot)\r\n{\r\nstruct packet_command cgc;\r\ncdinfo(CD_CHANGER, "entering cdrom_load_unload()\n");\r\nif (cdi->sanyo_slot && slot < 0)\r\nreturn 0;\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_LOAD_UNLOAD;\r\ncgc.cmd[4] = 2 + (slot >= 0);\r\ncgc.cmd[8] = slot;\r\ncgc.timeout = 60 * HZ;\r\nif (cdi->sanyo_slot && -1 < slot) {\r\ncgc.cmd[0] = GPCMD_TEST_UNIT_READY;\r\ncgc.cmd[7] = slot;\r\ncgc.cmd[4] = cgc.cmd[8] = 0;\r\ncdi->sanyo_slot = slot ? slot : 3;\r\n}\r\nreturn cdi->ops->generic_packet(cdi, &cgc);\r\n}\r\nstatic int cdrom_select_disc(struct cdrom_device_info *cdi, int slot)\r\n{\r\nstruct cdrom_changer_info *info;\r\nint curslot;\r\nint ret;\r\ncdinfo(CD_CHANGER, "entering cdrom_select_disc()\n");\r\nif (!CDROM_CAN(CDC_SELECT_DISC))\r\nreturn -EDRIVE_CANT_DO_THIS;\r\nif (cdi->ops->check_events)\r\ncdi->ops->check_events(cdi, 0, slot);\r\nelse\r\ncdi->ops->media_changed(cdi, slot);\r\nif (slot == CDSL_NONE) {\r\ncdi->mc_flags = 0x3;\r\nreturn cdrom_load_unload(cdi, -1);\r\n}\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nif ((ret = cdrom_read_mech_status(cdi, info))) {\r\nkfree(info);\r\nreturn ret;\r\n}\r\ncurslot = info->hdr.curslot;\r\nkfree(info);\r\nif (cdi->use_count > 1 || cdi->keeplocked) {\r\nif (slot == CDSL_CURRENT) {\r\nreturn curslot;\r\n} else {\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (slot == CDSL_CURRENT)\r\nslot = curslot;\r\ncdi->mc_flags = 0x3;\r\nif ((ret = cdrom_load_unload(cdi, slot)))\r\nreturn ret;\r\nreturn slot;\r\n}\r\nstatic void cdrom_update_events(struct cdrom_device_info *cdi,\r\nunsigned int clearing)\r\n{\r\nunsigned int events;\r\nevents = cdi->ops->check_events(cdi, clearing, CDSL_CURRENT);\r\ncdi->vfs_events |= events;\r\ncdi->ioctl_events |= events;\r\n}\r\nunsigned int cdrom_check_events(struct cdrom_device_info *cdi,\r\nunsigned int clearing)\r\n{\r\nunsigned int events;\r\ncdrom_update_events(cdi, clearing);\r\nevents = cdi->vfs_events;\r\ncdi->vfs_events = 0;\r\nreturn events;\r\n}\r\nstatic\r\nint media_changed(struct cdrom_device_info *cdi, int queue)\r\n{\r\nunsigned int mask = (1 << (queue & 1));\r\nint ret = !!(cdi->mc_flags & mask);\r\nbool changed;\r\nif (!CDROM_CAN(CDC_MEDIA_CHANGED))\r\nreturn ret;\r\nif (cdi->ops->check_events) {\r\nBUG_ON(!queue);\r\ncdrom_update_events(cdi, DISK_EVENT_MEDIA_CHANGE);\r\nchanged = cdi->ioctl_events & DISK_EVENT_MEDIA_CHANGE;\r\ncdi->ioctl_events = 0;\r\n} else\r\nchanged = cdi->ops->media_changed(cdi, CDSL_CURRENT);\r\nif (changed) {\r\ncdi->mc_flags = 0x3;\r\nret |= 1;\r\ncdi->media_written = 0;\r\n}\r\ncdi->mc_flags &= ~mask;\r\nreturn ret;\r\n}\r\nint cdrom_media_changed(struct cdrom_device_info *cdi)\r\n{\r\nif (cdi == NULL || cdi->ops->media_changed == NULL)\r\nreturn 0;\r\nif (!CDROM_CAN(CDC_MEDIA_CHANGED))\r\nreturn 0;\r\nreturn media_changed(cdi, 0);\r\n}\r\nstatic void cdrom_count_tracks(struct cdrom_device_info *cdi, tracktype* tracks)\r\n{\r\nstruct cdrom_tochdr header;\r\nstruct cdrom_tocentry entry;\r\nint ret, i;\r\ntracks->data=0;\r\ntracks->audio=0;\r\ntracks->cdi=0;\r\ntracks->xa=0;\r\ntracks->error=0;\r\ncdinfo(CD_COUNT_TRACKS, "entering cdrom_count_tracks\n");\r\nif ((ret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header))) {\r\nif (ret == -ENOMEDIUM)\r\ntracks->error = CDS_NO_DISC;\r\nelse\r\ntracks->error = CDS_NO_INFO;\r\nreturn;\r\n}\r\nentry.cdte_format = CDROM_MSF;\r\nfor (i = header.cdth_trk0; i <= header.cdth_trk1; i++) {\r\nentry.cdte_track = i;\r\nif (cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry)) {\r\ntracks->error=CDS_NO_INFO;\r\nreturn;\r\n}\r\nif (entry.cdte_ctrl & CDROM_DATA_TRACK) {\r\nif (entry.cdte_format == 0x10)\r\ntracks->cdi++;\r\nelse if (entry.cdte_format == 0x20)\r\ntracks->xa++;\r\nelse\r\ntracks->data++;\r\n} else\r\ntracks->audio++;\r\ncdinfo(CD_COUNT_TRACKS, "track %d: format=%d, ctrl=%d\n",\r\ni, entry.cdte_format, entry.cdte_ctrl);\r\n}\r\ncdinfo(CD_COUNT_TRACKS, "disc has %d tracks: %d=audio %d=data %d=Cd-I %d=XA\n",\r\nheader.cdth_trk1, tracks->audio, tracks->data,\r\ntracks->cdi, tracks->xa);\r\n}\r\nstatic\r\nvoid sanitize_format(union cdrom_addr *addr,\r\nu_char * curr, u_char requested)\r\n{\r\nif (*curr == requested)\r\nreturn;\r\nif (requested == CDROM_LBA) {\r\naddr->lba = (int) addr->msf.frame +\r\n75 * (addr->msf.second - 2 + 60 * addr->msf.minute);\r\n} else {\r\nint lba = addr->lba;\r\naddr->msf.frame = lba % 75;\r\nlba /= 75;\r\nlba += 2;\r\naddr->msf.second = lba % 60;\r\naddr->msf.minute = lba / 60;\r\n}\r\n*curr = requested;\r\n}\r\nvoid init_cdrom_command(struct packet_command *cgc, void *buf, int len,\r\nint type)\r\n{\r\nmemset(cgc, 0, sizeof(struct packet_command));\r\nif (buf)\r\nmemset(buf, 0, len);\r\ncgc->buffer = (char *) buf;\r\ncgc->buflen = len;\r\ncgc->data_direction = type;\r\ncgc->timeout = CDROM_DEF_TIMEOUT;\r\n}\r\nstatic void setup_report_key(struct packet_command *cgc, unsigned agid, unsigned type)\r\n{\r\ncgc->cmd[0] = GPCMD_REPORT_KEY;\r\ncgc->cmd[10] = type | (agid << 6);\r\nswitch (type) {\r\ncase 0: case 8: case 5: {\r\ncgc->buflen = 8;\r\nbreak;\r\n}\r\ncase 1: {\r\ncgc->buflen = 16;\r\nbreak;\r\n}\r\ncase 2: case 4: {\r\ncgc->buflen = 12;\r\nbreak;\r\n}\r\n}\r\ncgc->cmd[9] = cgc->buflen;\r\ncgc->data_direction = CGC_DATA_READ;\r\n}\r\nstatic void setup_send_key(struct packet_command *cgc, unsigned agid, unsigned type)\r\n{\r\ncgc->cmd[0] = GPCMD_SEND_KEY;\r\ncgc->cmd[10] = type | (agid << 6);\r\nswitch (type) {\r\ncase 1: {\r\ncgc->buflen = 16;\r\nbreak;\r\n}\r\ncase 3: {\r\ncgc->buflen = 12;\r\nbreak;\r\n}\r\ncase 6: {\r\ncgc->buflen = 8;\r\nbreak;\r\n}\r\n}\r\ncgc->cmd[9] = cgc->buflen;\r\ncgc->data_direction = CGC_DATA_WRITE;\r\n}\r\nstatic int dvd_do_auth(struct cdrom_device_info *cdi, dvd_authinfo *ai)\r\n{\r\nint ret;\r\nu_char buf[20];\r\nstruct packet_command cgc;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nrpc_state_t rpc_state;\r\nmemset(buf, 0, sizeof(buf));\r\ninit_cdrom_command(&cgc, buf, 0, CGC_DATA_READ);\r\nswitch (ai->type) {\r\ncase DVD_LU_SEND_AGID:\r\ncdinfo(CD_DVD, "entering DVD_LU_SEND_AGID\n");\r\ncgc.quiet = 1;\r\nsetup_report_key(&cgc, ai->lsa.agid, 0);\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nai->lsa.agid = buf[7] >> 6;\r\nbreak;\r\ncase DVD_LU_SEND_KEY1:\r\ncdinfo(CD_DVD, "entering DVD_LU_SEND_KEY1\n");\r\nsetup_report_key(&cgc, ai->lsk.agid, 2);\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\ncopy_key(ai->lsk.key, &buf[4]);\r\nbreak;\r\ncase DVD_LU_SEND_CHALLENGE:\r\ncdinfo(CD_DVD, "entering DVD_LU_SEND_CHALLENGE\n");\r\nsetup_report_key(&cgc, ai->lsc.agid, 1);\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\ncopy_chal(ai->lsc.chal, &buf[4]);\r\nbreak;\r\ncase DVD_LU_SEND_TITLE_KEY:\r\ncdinfo(CD_DVD, "entering DVD_LU_SEND_TITLE_KEY\n");\r\ncgc.quiet = 1;\r\nsetup_report_key(&cgc, ai->lstk.agid, 4);\r\ncgc.cmd[5] = ai->lstk.lba;\r\ncgc.cmd[4] = ai->lstk.lba >> 8;\r\ncgc.cmd[3] = ai->lstk.lba >> 16;\r\ncgc.cmd[2] = ai->lstk.lba >> 24;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nai->lstk.cpm = (buf[4] >> 7) & 1;\r\nai->lstk.cp_sec = (buf[4] >> 6) & 1;\r\nai->lstk.cgms = (buf[4] >> 4) & 3;\r\ncopy_key(ai->lstk.title_key, &buf[5]);\r\nbreak;\r\ncase DVD_LU_SEND_ASF:\r\ncdinfo(CD_DVD, "entering DVD_LU_SEND_ASF\n");\r\nsetup_report_key(&cgc, ai->lsasf.agid, 5);\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nai->lsasf.asf = buf[7] & 1;\r\nbreak;\r\ncase DVD_HOST_SEND_CHALLENGE:\r\ncdinfo(CD_DVD, "entering DVD_HOST_SEND_CHALLENGE\n");\r\nsetup_send_key(&cgc, ai->hsc.agid, 1);\r\nbuf[1] = 0xe;\r\ncopy_chal(&buf[4], ai->hsc.chal);\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nai->type = DVD_LU_SEND_KEY1;\r\nbreak;\r\ncase DVD_HOST_SEND_KEY2:\r\ncdinfo(CD_DVD, "entering DVD_HOST_SEND_KEY2\n");\r\nsetup_send_key(&cgc, ai->hsk.agid, 3);\r\nbuf[1] = 0xa;\r\ncopy_key(&buf[4], ai->hsk.key);\r\nif ((ret = cdo->generic_packet(cdi, &cgc))) {\r\nai->type = DVD_AUTH_FAILURE;\r\nreturn ret;\r\n}\r\nai->type = DVD_AUTH_ESTABLISHED;\r\nbreak;\r\ncase DVD_INVALIDATE_AGID:\r\ncgc.quiet = 1;\r\ncdinfo(CD_DVD, "entering DVD_INVALIDATE_AGID\n");\r\nsetup_report_key(&cgc, ai->lsa.agid, 0x3f);\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nbreak;\r\ncase DVD_LU_SEND_RPC_STATE:\r\ncdinfo(CD_DVD, "entering DVD_LU_SEND_RPC_STATE\n");\r\nsetup_report_key(&cgc, 0, 8);\r\nmemset(&rpc_state, 0, sizeof(rpc_state_t));\r\ncgc.buffer = (char *) &rpc_state;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nai->lrpcs.type = rpc_state.type_code;\r\nai->lrpcs.vra = rpc_state.vra;\r\nai->lrpcs.ucca = rpc_state.ucca;\r\nai->lrpcs.region_mask = rpc_state.region_mask;\r\nai->lrpcs.rpc_scheme = rpc_state.rpc_scheme;\r\nbreak;\r\ncase DVD_HOST_SEND_RPC_STATE:\r\ncdinfo(CD_DVD, "entering DVD_HOST_SEND_RPC_STATE\n");\r\nsetup_send_key(&cgc, 0, 6);\r\nbuf[1] = 6;\r\nbuf[4] = ai->hrpcs.pdrc;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nbreak;\r\ndefault:\r\ncdinfo(CD_WARNING, "Invalid DVD key ioctl (%d)\n", ai->type);\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvd_read_physical(struct cdrom_device_info *cdi, dvd_struct *s,\r\nstruct packet_command *cgc)\r\n{\r\nunsigned char buf[21], *base;\r\nstruct dvd_layer *layer;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nint ret, layer_num = s->physical.layer_num;\r\nif (layer_num >= DVD_LAYERS)\r\nreturn -EINVAL;\r\ninit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\r\ncgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\r\ncgc->cmd[6] = layer_num;\r\ncgc->cmd[7] = s->type;\r\ncgc->cmd[9] = cgc->buflen & 0xff;\r\ncgc->quiet = 1;\r\nret = cdo->generic_packet(cdi, cgc);\r\nif (ret)\r\nreturn ret;\r\nbase = &buf[4];\r\nlayer = &s->physical.layer[layer_num];\r\nmemset(layer, 0, sizeof(*layer));\r\nlayer->book_version = base[0] & 0xf;\r\nlayer->book_type = base[0] >> 4;\r\nlayer->min_rate = base[1] & 0xf;\r\nlayer->disc_size = base[1] >> 4;\r\nlayer->layer_type = base[2] & 0xf;\r\nlayer->track_path = (base[2] >> 4) & 1;\r\nlayer->nlayers = (base[2] >> 5) & 3;\r\nlayer->track_density = base[3] & 0xf;\r\nlayer->linear_density = base[3] >> 4;\r\nlayer->start_sector = base[5] << 16 | base[6] << 8 | base[7];\r\nlayer->end_sector = base[9] << 16 | base[10] << 8 | base[11];\r\nlayer->end_sector_l0 = base[13] << 16 | base[14] << 8 | base[15];\r\nlayer->bca = base[16] >> 7;\r\nreturn 0;\r\n}\r\nstatic int dvd_read_copyright(struct cdrom_device_info *cdi, dvd_struct *s,\r\nstruct packet_command *cgc)\r\n{\r\nint ret;\r\nu_char buf[8];\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\ninit_cdrom_command(cgc, buf, sizeof(buf), CGC_DATA_READ);\r\ncgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\r\ncgc->cmd[6] = s->copyright.layer_num;\r\ncgc->cmd[7] = s->type;\r\ncgc->cmd[8] = cgc->buflen >> 8;\r\ncgc->cmd[9] = cgc->buflen & 0xff;\r\nret = cdo->generic_packet(cdi, cgc);\r\nif (ret)\r\nreturn ret;\r\ns->copyright.cpst = buf[4];\r\ns->copyright.rmi = buf[5];\r\nreturn 0;\r\n}\r\nstatic int dvd_read_disckey(struct cdrom_device_info *cdi, dvd_struct *s,\r\nstruct packet_command *cgc)\r\n{\r\nint ret, size;\r\nu_char *buf;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nsize = sizeof(s->disckey.value) + 4;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ninit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\r\ncgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\r\ncgc->cmd[7] = s->type;\r\ncgc->cmd[8] = size >> 8;\r\ncgc->cmd[9] = size & 0xff;\r\ncgc->cmd[10] = s->disckey.agid << 6;\r\nret = cdo->generic_packet(cdi, cgc);\r\nif (!ret)\r\nmemcpy(s->disckey.value, &buf[4], sizeof(s->disckey.value));\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int dvd_read_bca(struct cdrom_device_info *cdi, dvd_struct *s,\r\nstruct packet_command *cgc)\r\n{\r\nint ret, size = 4 + 188;\r\nu_char *buf;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ninit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\r\ncgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\r\ncgc->cmd[7] = s->type;\r\ncgc->cmd[9] = cgc->buflen & 0xff;\r\nret = cdo->generic_packet(cdi, cgc);\r\nif (ret)\r\ngoto out;\r\ns->bca.len = buf[0] << 8 | buf[1];\r\nif (s->bca.len < 12 || s->bca.len > 188) {\r\ncdinfo(CD_WARNING, "Received invalid BCA length (%d)\n", s->bca.len);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(s->bca.value, &buf[4], s->bca.len);\r\nret = 0;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int dvd_read_manufact(struct cdrom_device_info *cdi, dvd_struct *s,\r\nstruct packet_command *cgc)\r\n{\r\nint ret = 0, size;\r\nu_char *buf;\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nsize = sizeof(s->manufact.value) + 4;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ninit_cdrom_command(cgc, buf, size, CGC_DATA_READ);\r\ncgc->cmd[0] = GPCMD_READ_DVD_STRUCTURE;\r\ncgc->cmd[7] = s->type;\r\ncgc->cmd[8] = size >> 8;\r\ncgc->cmd[9] = size & 0xff;\r\nret = cdo->generic_packet(cdi, cgc);\r\nif (ret)\r\ngoto out;\r\ns->manufact.len = buf[0] << 8 | buf[1];\r\nif (s->manufact.len < 0) {\r\ncdinfo(CD_WARNING, "Received invalid manufacture info length"\r\n" (%d)\n", s->manufact.len);\r\nret = -EIO;\r\n} else {\r\nif (s->manufact.len > 2048) {\r\ncdinfo(CD_WARNING, "Received invalid manufacture info "\r\n"length (%d): truncating to 2048\n",\r\ns->manufact.len);\r\ns->manufact.len = 2048;\r\n}\r\nmemcpy(s->manufact.value, &buf[4], s->manufact.len);\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int dvd_read_struct(struct cdrom_device_info *cdi, dvd_struct *s,\r\nstruct packet_command *cgc)\r\n{\r\nswitch (s->type) {\r\ncase DVD_STRUCT_PHYSICAL:\r\nreturn dvd_read_physical(cdi, s, cgc);\r\ncase DVD_STRUCT_COPYRIGHT:\r\nreturn dvd_read_copyright(cdi, s, cgc);\r\ncase DVD_STRUCT_DISCKEY:\r\nreturn dvd_read_disckey(cdi, s, cgc);\r\ncase DVD_STRUCT_BCA:\r\nreturn dvd_read_bca(cdi, s, cgc);\r\ncase DVD_STRUCT_MANUFACT:\r\nreturn dvd_read_manufact(cdi, s, cgc);\r\ndefault:\r\ncdinfo(CD_WARNING, ": Invalid DVD structure read requested (%d)\n",\r\ns->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nint cdrom_mode_sense(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc,\r\nint page_code, int page_control)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nmemset(cgc->cmd, 0, sizeof(cgc->cmd));\r\ncgc->cmd[0] = GPCMD_MODE_SENSE_10;\r\ncgc->cmd[2] = page_code | (page_control << 6);\r\ncgc->cmd[7] = cgc->buflen >> 8;\r\ncgc->cmd[8] = cgc->buflen & 0xff;\r\ncgc->data_direction = CGC_DATA_READ;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nint cdrom_mode_select(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nmemset(cgc->cmd, 0, sizeof(cgc->cmd));\r\nmemset(cgc->buffer, 0, 2);\r\ncgc->cmd[0] = GPCMD_MODE_SELECT_10;\r\ncgc->cmd[1] = 0x10;\r\ncgc->cmd[7] = cgc->buflen >> 8;\r\ncgc->cmd[8] = cgc->buflen & 0xff;\r\ncgc->data_direction = CGC_DATA_WRITE;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic int cdrom_read_subchannel(struct cdrom_device_info *cdi,\r\nstruct cdrom_subchnl *subchnl, int mcn)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nstruct packet_command cgc;\r\nchar buffer[32];\r\nint ret;\r\ninit_cdrom_command(&cgc, buffer, 16, CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_READ_SUBCHANNEL;\r\ncgc.cmd[1] = 2;\r\ncgc.cmd[2] = 0x40;\r\ncgc.cmd[3] = mcn ? 2 : 1;\r\ncgc.cmd[8] = 16;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nsubchnl->cdsc_audiostatus = cgc.buffer[1];\r\nsubchnl->cdsc_format = CDROM_MSF;\r\nsubchnl->cdsc_ctrl = cgc.buffer[5] & 0xf;\r\nsubchnl->cdsc_trk = cgc.buffer[6];\r\nsubchnl->cdsc_ind = cgc.buffer[7];\r\nsubchnl->cdsc_reladdr.msf.minute = cgc.buffer[13];\r\nsubchnl->cdsc_reladdr.msf.second = cgc.buffer[14];\r\nsubchnl->cdsc_reladdr.msf.frame = cgc.buffer[15];\r\nsubchnl->cdsc_absaddr.msf.minute = cgc.buffer[9];\r\nsubchnl->cdsc_absaddr.msf.second = cgc.buffer[10];\r\nsubchnl->cdsc_absaddr.msf.frame = cgc.buffer[11];\r\nreturn 0;\r\n}\r\nstatic int cdrom_read_cd(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc, int lba,\r\nint blocksize, int nblocks)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\r\ncgc->cmd[0] = GPCMD_READ_10;\r\ncgc->cmd[2] = (lba >> 24) & 0xff;\r\ncgc->cmd[3] = (lba >> 16) & 0xff;\r\ncgc->cmd[4] = (lba >> 8) & 0xff;\r\ncgc->cmd[5] = lba & 0xff;\r\ncgc->cmd[6] = (nblocks >> 16) & 0xff;\r\ncgc->cmd[7] = (nblocks >> 8) & 0xff;\r\ncgc->cmd[8] = nblocks & 0xff;\r\ncgc->buflen = blocksize * nblocks;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic int cdrom_read_block(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc,\r\nint lba, int nblocks, int format, int blksize)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nmemset(&cgc->cmd, 0, sizeof(cgc->cmd));\r\ncgc->cmd[0] = GPCMD_READ_CD;\r\ncgc->cmd[1] = format << 2;\r\ncgc->cmd[2] = (lba >> 24) & 0xff;\r\ncgc->cmd[3] = (lba >> 16) & 0xff;\r\ncgc->cmd[4] = (lba >> 8) & 0xff;\r\ncgc->cmd[5] = lba & 0xff;\r\ncgc->cmd[6] = (nblocks >> 16) & 0xff;\r\ncgc->cmd[7] = (nblocks >> 8) & 0xff;\r\ncgc->cmd[8] = nblocks & 0xff;\r\ncgc->buflen = blksize * nblocks;\r\nswitch (blksize) {\r\ncase CD_FRAMESIZE_RAW0 : cgc->cmd[9] = 0x58; break;\r\ncase CD_FRAMESIZE_RAW1 : cgc->cmd[9] = 0x78; break;\r\ncase CD_FRAMESIZE_RAW : cgc->cmd[9] = 0xf8; break;\r\ndefault : cgc->cmd[9] = 0x10;\r\n}\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic int cdrom_read_cdda_old(struct cdrom_device_info *cdi, __u8 __user *ubuf,\r\nint lba, int nframes)\r\n{\r\nstruct packet_command cgc;\r\nint ret = 0;\r\nint nr;\r\ncdi->last_sense = 0;\r\nmemset(&cgc, 0, sizeof(cgc));\r\nnr = nframes;\r\ndo {\r\ncgc.buffer = kmalloc(CD_FRAMESIZE_RAW * nr, GFP_KERNEL);\r\nif (cgc.buffer)\r\nbreak;\r\nnr >>= 1;\r\n} while (nr);\r\nif (!nr)\r\nreturn -ENOMEM;\r\ncgc.data_direction = CGC_DATA_READ;\r\nwhile (nframes > 0) {\r\nif (nr > nframes)\r\nnr = nframes;\r\nret = cdrom_read_block(cdi, &cgc, lba, nr, 1, CD_FRAMESIZE_RAW);\r\nif (ret)\r\nbreak;\r\nif (copy_to_user(ubuf, cgc.buffer, CD_FRAMESIZE_RAW * nr)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nubuf += CD_FRAMESIZE_RAW * nr;\r\nnframes -= nr;\r\nlba += nr;\r\n}\r\nkfree(cgc.buffer);\r\nreturn ret;\r\n}\r\nstatic int cdrom_read_cdda_bpc(struct cdrom_device_info *cdi, __u8 __user *ubuf,\r\nint lba, int nframes)\r\n{\r\nstruct request_queue *q = cdi->disk->queue;\r\nstruct request *rq;\r\nstruct bio *bio;\r\nunsigned int len;\r\nint nr, ret = 0;\r\nif (!q)\r\nreturn -ENXIO;\r\ncdi->last_sense = 0;\r\nwhile (nframes) {\r\nnr = nframes;\r\nif (cdi->cdda_method == CDDA_BPC_SINGLE)\r\nnr = 1;\r\nif (nr * CD_FRAMESIZE_RAW > (queue_max_sectors(q) << 9))\r\nnr = (queue_max_sectors(q) << 9) / CD_FRAMESIZE_RAW;\r\nlen = nr * CD_FRAMESIZE_RAW;\r\nrq = blk_get_request(q, READ, GFP_KERNEL);\r\nif (!rq) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = blk_rq_map_user(q, rq, NULL, ubuf, len, GFP_KERNEL);\r\nif (ret) {\r\nblk_put_request(rq);\r\nbreak;\r\n}\r\nrq->cmd[0] = GPCMD_READ_CD;\r\nrq->cmd[1] = 1 << 2;\r\nrq->cmd[2] = (lba >> 24) & 0xff;\r\nrq->cmd[3] = (lba >> 16) & 0xff;\r\nrq->cmd[4] = (lba >> 8) & 0xff;\r\nrq->cmd[5] = lba & 0xff;\r\nrq->cmd[6] = (nr >> 16) & 0xff;\r\nrq->cmd[7] = (nr >> 8) & 0xff;\r\nrq->cmd[8] = nr & 0xff;\r\nrq->cmd[9] = 0xf8;\r\nrq->cmd_len = 12;\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nrq->timeout = 60 * HZ;\r\nbio = rq->bio;\r\nif (blk_execute_rq(q, cdi->disk, rq, 0)) {\r\nstruct request_sense *s = rq->sense;\r\nret = -EIO;\r\ncdi->last_sense = s->sense_key;\r\n}\r\nif (blk_rq_unmap_user(bio))\r\nret = -EFAULT;\r\nblk_put_request(rq);\r\nif (ret)\r\nbreak;\r\nnframes -= nr;\r\nlba += nr;\r\nubuf += len;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cdrom_read_cdda(struct cdrom_device_info *cdi, __u8 __user *ubuf,\r\nint lba, int nframes)\r\n{\r\nint ret;\r\nif (cdi->cdda_method == CDDA_OLD)\r\nreturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\r\nretry:\r\nret = cdrom_read_cdda_bpc(cdi, ubuf, lba, nframes);\r\nif (!ret || ret != -EIO)\r\nreturn ret;\r\nif (cdi->cdda_method == CDDA_BPC_FULL && nframes > 1) {\r\npr_info("dropping to single frame dma\n");\r\ncdi->cdda_method = CDDA_BPC_SINGLE;\r\ngoto retry;\r\n}\r\nif (cdi->last_sense != 0x04 && cdi->last_sense != 0x0b)\r\nreturn ret;\r\npr_info("dropping to old style cdda (sense=%x)\n", cdi->last_sense);\r\ncdi->cdda_method = CDDA_OLD;\r\nreturn cdrom_read_cdda_old(cdi, ubuf, lba, nframes);\r\n}\r\nstatic int cdrom_ioctl_multisession(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_multisession ms_info;\r\nu8 requested_format;\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMMULTISESSION\n");\r\nif (!(cdi->ops->capability & CDC_MULTI_SESSION))\r\nreturn -ENOSYS;\r\nif (copy_from_user(&ms_info, argp, sizeof(ms_info)))\r\nreturn -EFAULT;\r\nrequested_format = ms_info.addr_format;\r\nif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\r\nreturn -EINVAL;\r\nms_info.addr_format = CDROM_LBA;\r\nret = cdi->ops->get_last_session(cdi, &ms_info);\r\nif (ret)\r\nreturn ret;\r\nsanitize_format(&ms_info.addr, &ms_info.addr_format, requested_format);\r\nif (copy_to_user(argp, &ms_info, sizeof(ms_info)))\r\nreturn -EFAULT;\r\ncdinfo(CD_DO_IOCTL, "CDROMMULTISESSION successful\n");\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_eject(struct cdrom_device_info *cdi)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROMEJECT\n");\r\nif (!CDROM_CAN(CDC_OPEN_TRAY))\r\nreturn -ENOSYS;\r\nif (cdi->use_count != 1 || cdi->keeplocked)\r\nreturn -EBUSY;\r\nif (CDROM_CAN(CDC_LOCK)) {\r\nint ret = cdi->ops->lock_door(cdi, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn cdi->ops->tray_move(cdi, 1);\r\n}\r\nstatic int cdrom_ioctl_closetray(struct cdrom_device_info *cdi)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROMCLOSETRAY\n");\r\nif (!CDROM_CAN(CDC_CLOSE_TRAY))\r\nreturn -ENOSYS;\r\nreturn cdi->ops->tray_move(cdi, 0);\r\n}\r\nstatic int cdrom_ioctl_eject_sw(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROMEJECT_SW\n");\r\nif (!CDROM_CAN(CDC_OPEN_TRAY))\r\nreturn -ENOSYS;\r\nif (cdi->keeplocked)\r\nreturn -EBUSY;\r\ncdi->options &= ~(CDO_AUTO_CLOSE | CDO_AUTO_EJECT);\r\nif (arg)\r\ncdi->options |= CDO_AUTO_CLOSE | CDO_AUTO_EJECT;\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\nstruct cdrom_changer_info *info;\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_MEDIA_CHANGED\n");\r\nif (!CDROM_CAN(CDC_MEDIA_CHANGED))\r\nreturn -ENOSYS;\r\nif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\r\nreturn media_changed(cdi, 1);\r\nif ((unsigned int)arg >= cdi->capacity)\r\nreturn -EINVAL;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nret = cdrom_read_mech_status(cdi, info);\r\nif (!ret)\r\nret = info->slots[arg].change;\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int cdrom_ioctl_set_options(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_SET_OPTIONS\n");\r\nswitch (arg) {\r\ncase CDO_USE_FFLAGS:\r\ncase CDO_CHECK_TYPE:\r\nbreak;\r\ncase CDO_LOCK:\r\nif (!CDROM_CAN(CDC_LOCK))\r\nreturn -ENOSYS;\r\nbreak;\r\ncase 0:\r\nreturn cdi->options;\r\ndefault:\r\nif (!CDROM_CAN(arg))\r\nreturn -ENOSYS;\r\n}\r\ncdi->options |= (int) arg;\r\nreturn cdi->options;\r\n}\r\nstatic int cdrom_ioctl_clear_options(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_CLEAR_OPTIONS\n");\r\ncdi->options &= ~(int) arg;\r\nreturn cdi->options;\r\n}\r\nstatic int cdrom_ioctl_select_speed(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_SELECT_SPEED\n");\r\nif (!CDROM_CAN(CDC_SELECT_SPEED))\r\nreturn -ENOSYS;\r\nreturn cdi->ops->select_speed(cdi, arg);\r\n}\r\nstatic int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_SELECT_DISC\n");\r\nif (!CDROM_CAN(CDC_SELECT_DISC))\r\nreturn -ENOSYS;\r\nif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\r\nif ((int)arg >= cdi->capacity)\r\nreturn -EINVAL;\r\n}\r\nif (cdi->ops->select_disc)\r\nreturn cdi->ops->select_disc(cdi, arg);\r\ncdinfo(CD_CHANGER, "Using generic cdrom_select_disc()\n");\r\nreturn cdrom_select_disc(cdi, arg);\r\n}\r\nstatic int cdrom_ioctl_reset(struct cdrom_device_info *cdi,\r\nstruct block_device *bdev)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_RESET\n");\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!CDROM_CAN(CDC_RESET))\r\nreturn -ENOSYS;\r\ninvalidate_bdev(bdev);\r\nreturn cdi->ops->reset(cdi);\r\n}\r\nstatic int cdrom_ioctl_lock_door(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "%socking door.\n", arg ? "L" : "Unl");\r\nif (!CDROM_CAN(CDC_LOCK))\r\nreturn -EDRIVE_CANT_DO_THIS;\r\ncdi->keeplocked = arg ? 1 : 0;\r\nif (cdi->use_count != 1 && !arg && !capable(CAP_SYS_ADMIN))\r\nreturn -EBUSY;\r\nreturn cdi->ops->lock_door(cdi, arg);\r\n}\r\nstatic int cdrom_ioctl_debug(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "%sabling debug.\n", arg ? "En" : "Dis");\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\ndebug = arg ? 1 : 0;\r\nreturn debug;\r\n}\r\nstatic int cdrom_ioctl_get_capability(struct cdrom_device_info *cdi)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_GET_CAPABILITY\n");\r\nreturn (cdi->ops->capability & ~cdi->mask);\r\n}\r\nstatic int cdrom_ioctl_get_mcn(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_mcn mcn;\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_GET_MCN\n");\r\nif (!(cdi->ops->capability & CDC_MCN))\r\nreturn -ENOSYS;\r\nret = cdi->ops->get_mcn(cdi, &mcn);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(argp, &mcn, sizeof(mcn)))\r\nreturn -EFAULT;\r\ncdinfo(CD_DO_IOCTL, "CDROM_GET_MCN successful\n");\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\r\nunsigned long arg)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_DRIVE_STATUS\n");\r\nif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\r\nreturn -ENOSYS;\r\nif (!CDROM_CAN(CDC_SELECT_DISC) ||\r\n(arg == CDSL_CURRENT || arg == CDSL_NONE))\r\nreturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\r\nif (((int)arg >= cdi->capacity))\r\nreturn -EINVAL;\r\nreturn cdrom_slot_status(cdi, arg);\r\n}\r\nstatic int cdrom_ioctl_disc_status(struct cdrom_device_info *cdi)\r\n{\r\ntracktype tracks;\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_DISC_STATUS\n");\r\ncdrom_count_tracks(cdi, &tracks);\r\nif (tracks.error)\r\nreturn tracks.error;\r\nif (tracks.audio > 0) {\r\nif (!tracks.data && !tracks.cdi && !tracks.xa)\r\nreturn CDS_AUDIO;\r\nelse\r\nreturn CDS_MIXED;\r\n}\r\nif (tracks.cdi > 0)\r\nreturn CDS_XA_2_2;\r\nif (tracks.xa > 0)\r\nreturn CDS_XA_2_1;\r\nif (tracks.data > 0)\r\nreturn CDS_DATA_1;\r\ncdinfo(CD_WARNING,"This disc doesn't have any tracks I recognize!\n");\r\nreturn CDS_NO_INFO;\r\n}\r\nstatic int cdrom_ioctl_changer_nslots(struct cdrom_device_info *cdi)\r\n{\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_CHANGER_NSLOTS\n");\r\nreturn cdi->capacity;\r\n}\r\nstatic int cdrom_ioctl_get_subchnl(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_subchnl q;\r\nu8 requested, back;\r\nint ret;\r\nif (copy_from_user(&q, argp, sizeof(q)))\r\nreturn -EFAULT;\r\nrequested = q.cdsc_format;\r\nif (requested != CDROM_MSF && requested != CDROM_LBA)\r\nreturn -EINVAL;\r\nq.cdsc_format = CDROM_MSF;\r\nret = cdi->ops->audio_ioctl(cdi, CDROMSUBCHNL, &q);\r\nif (ret)\r\nreturn ret;\r\nback = q.cdsc_format;\r\nsanitize_format(&q.cdsc_absaddr, &back, requested);\r\nsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\r\nif (copy_to_user(argp, &q, sizeof(q)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_read_tochdr(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_tochdr header;\r\nint ret;\r\nif (copy_from_user(&header, argp, sizeof(header)))\r\nreturn -EFAULT;\r\nret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(argp, &header, sizeof(header)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_read_tocentry(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_tocentry entry;\r\nu8 requested_format;\r\nint ret;\r\nif (copy_from_user(&entry, argp, sizeof(entry)))\r\nreturn -EFAULT;\r\nrequested_format = entry.cdte_format;\r\nif (requested_format != CDROM_MSF && requested_format != CDROM_LBA)\r\nreturn -EINVAL;\r\nentry.cdte_format = CDROM_MSF;\r\nret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &entry);\r\nif (ret)\r\nreturn ret;\r\nsanitize_format(&entry.cdte_addr, &entry.cdte_format, requested_format);\r\nif (copy_to_user(argp, &entry, sizeof(entry)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_play_msf(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_msf msf;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMPLAYMSF\n");\r\nif (!CDROM_CAN(CDC_PLAY_AUDIO))\r\nreturn -ENOSYS;\r\nif (copy_from_user(&msf, argp, sizeof(msf)))\r\nreturn -EFAULT;\r\nreturn cdi->ops->audio_ioctl(cdi, CDROMPLAYMSF, &msf);\r\n}\r\nstatic int cdrom_ioctl_play_trkind(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_ti ti;\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMPLAYTRKIND\n");\r\nif (!CDROM_CAN(CDC_PLAY_AUDIO))\r\nreturn -ENOSYS;\r\nif (copy_from_user(&ti, argp, sizeof(ti)))\r\nreturn -EFAULT;\r\nret = check_for_audio_disc(cdi, cdi->ops);\r\nif (ret)\r\nreturn ret;\r\nreturn cdi->ops->audio_ioctl(cdi, CDROMPLAYTRKIND, &ti);\r\n}\r\nstatic int cdrom_ioctl_volctrl(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_volctrl volume;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMVOLCTRL\n");\r\nif (!CDROM_CAN(CDC_PLAY_AUDIO))\r\nreturn -ENOSYS;\r\nif (copy_from_user(&volume, argp, sizeof(volume)))\r\nreturn -EFAULT;\r\nreturn cdi->ops->audio_ioctl(cdi, CDROMVOLCTRL, &volume);\r\n}\r\nstatic int cdrom_ioctl_volread(struct cdrom_device_info *cdi,\r\nvoid __user *argp)\r\n{\r\nstruct cdrom_volctrl volume;\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMVOLREAD\n");\r\nif (!CDROM_CAN(CDC_PLAY_AUDIO))\r\nreturn -ENOSYS;\r\nret = cdi->ops->audio_ioctl(cdi, CDROMVOLREAD, &volume);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(argp, &volume, sizeof(volume)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cdrom_ioctl_audioctl(struct cdrom_device_info *cdi,\r\nunsigned int cmd)\r\n{\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "doing audio ioctl (start/stop/pause/resume)\n");\r\nif (!CDROM_CAN(CDC_PLAY_AUDIO))\r\nreturn -ENOSYS;\r\nret = check_for_audio_disc(cdi, cdi->ops);\r\nif (ret)\r\nreturn ret;\r\nreturn cdi->ops->audio_ioctl(cdi, cmd, NULL);\r\n}\r\nint cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,\r\nfmode_t mode, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint ret;\r\nret = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);\r\nif (ret != -ENOTTY)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase CDROMMULTISESSION:\r\nreturn cdrom_ioctl_multisession(cdi, argp);\r\ncase CDROMEJECT:\r\nreturn cdrom_ioctl_eject(cdi);\r\ncase CDROMCLOSETRAY:\r\nreturn cdrom_ioctl_closetray(cdi);\r\ncase CDROMEJECT_SW:\r\nreturn cdrom_ioctl_eject_sw(cdi, arg);\r\ncase CDROM_MEDIA_CHANGED:\r\nreturn cdrom_ioctl_media_changed(cdi, arg);\r\ncase CDROM_SET_OPTIONS:\r\nreturn cdrom_ioctl_set_options(cdi, arg);\r\ncase CDROM_CLEAR_OPTIONS:\r\nreturn cdrom_ioctl_clear_options(cdi, arg);\r\ncase CDROM_SELECT_SPEED:\r\nreturn cdrom_ioctl_select_speed(cdi, arg);\r\ncase CDROM_SELECT_DISC:\r\nreturn cdrom_ioctl_select_disc(cdi, arg);\r\ncase CDROMRESET:\r\nreturn cdrom_ioctl_reset(cdi, bdev);\r\ncase CDROM_LOCKDOOR:\r\nreturn cdrom_ioctl_lock_door(cdi, arg);\r\ncase CDROM_DEBUG:\r\nreturn cdrom_ioctl_debug(cdi, arg);\r\ncase CDROM_GET_CAPABILITY:\r\nreturn cdrom_ioctl_get_capability(cdi);\r\ncase CDROM_GET_MCN:\r\nreturn cdrom_ioctl_get_mcn(cdi, argp);\r\ncase CDROM_DRIVE_STATUS:\r\nreturn cdrom_ioctl_drive_status(cdi, arg);\r\ncase CDROM_DISC_STATUS:\r\nreturn cdrom_ioctl_disc_status(cdi);\r\ncase CDROM_CHANGER_NSLOTS:\r\nreturn cdrom_ioctl_changer_nslots(cdi);\r\n}\r\nif (CDROM_CAN(CDC_GENERIC_PACKET)) {\r\nret = mmc_ioctl(cdi, cmd, arg);\r\nif (ret != -ENOTTY)\r\nreturn ret;\r\n}\r\nswitch (cmd) {\r\ncase CDROMSUBCHNL:\r\nreturn cdrom_ioctl_get_subchnl(cdi, argp);\r\ncase CDROMREADTOCHDR:\r\nreturn cdrom_ioctl_read_tochdr(cdi, argp);\r\ncase CDROMREADTOCENTRY:\r\nreturn cdrom_ioctl_read_tocentry(cdi, argp);\r\ncase CDROMPLAYMSF:\r\nreturn cdrom_ioctl_play_msf(cdi, argp);\r\ncase CDROMPLAYTRKIND:\r\nreturn cdrom_ioctl_play_trkind(cdi, argp);\r\ncase CDROMVOLCTRL:\r\nreturn cdrom_ioctl_volctrl(cdi, argp);\r\ncase CDROMVOLREAD:\r\nreturn cdrom_ioctl_volread(cdi, argp);\r\ncase CDROMSTART:\r\ncase CDROMSTOP:\r\ncase CDROMPAUSE:\r\ncase CDROMRESUME:\r\nreturn cdrom_ioctl_audioctl(cdi, cmd);\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic int cdrom_switch_blocksize(struct cdrom_device_info *cdi, int size)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nstruct packet_command cgc;\r\nstruct modesel_head mh;\r\nmemset(&mh, 0, sizeof(mh));\r\nmh.block_desc_length = 0x08;\r\nmh.block_length_med = (size >> 8) & 0xff;\r\nmh.block_length_lo = size & 0xff;\r\nmemset(&cgc, 0, sizeof(cgc));\r\ncgc.cmd[0] = 0x15;\r\ncgc.cmd[1] = 1 << 4;\r\ncgc.cmd[4] = 12;\r\ncgc.buflen = sizeof(mh);\r\ncgc.buffer = (char *) &mh;\r\ncgc.data_direction = CGC_DATA_WRITE;\r\nmh.block_desc_length = 0x08;\r\nmh.block_length_med = (size >> 8) & 0xff;\r\nmh.block_length_lo = size & 0xff;\r\nreturn cdo->generic_packet(cdi, &cgc);\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_read_data(struct cdrom_device_info *cdi,\r\nvoid __user *arg,\r\nstruct packet_command *cgc,\r\nint cmd)\r\n{\r\nstruct request_sense sense;\r\nstruct cdrom_msf msf;\r\nint blocksize = 0, format = 0, lba;\r\nint ret;\r\nswitch (cmd) {\r\ncase CDROMREADRAW:\r\nblocksize = CD_FRAMESIZE_RAW;\r\nbreak;\r\ncase CDROMREADMODE1:\r\nblocksize = CD_FRAMESIZE;\r\nformat = 2;\r\nbreak;\r\ncase CDROMREADMODE2:\r\nblocksize = CD_FRAMESIZE_RAW0;\r\nbreak;\r\n}\r\nIOCTL_IN(arg, struct cdrom_msf, msf);\r\nlba = msf_to_lba(msf.cdmsf_min0, msf.cdmsf_sec0, msf.cdmsf_frame0);\r\nif (lba < 0)\r\nreturn -EINVAL;\r\ncgc->buffer = kmalloc(blocksize, GFP_KERNEL);\r\nif (cgc->buffer == NULL)\r\nreturn -ENOMEM;\r\nmemset(&sense, 0, sizeof(sense));\r\ncgc->sense = &sense;\r\ncgc->data_direction = CGC_DATA_READ;\r\nret = cdrom_read_block(cdi, cgc, lba, 1, format, blocksize);\r\nif (ret && sense.sense_key == 0x05 &&\r\nsense.asc == 0x20 &&\r\nsense.ascq == 0x00) {\r\nret = cdrom_switch_blocksize(cdi, blocksize);\r\nif (ret)\r\ngoto out;\r\ncgc->sense = NULL;\r\nret = cdrom_read_cd(cdi, cgc, lba, blocksize, 1);\r\nret |= cdrom_switch_blocksize(cdi, blocksize);\r\n}\r\nif (!ret && copy_to_user(arg, cgc->buffer, blocksize))\r\nret = -EFAULT;\r\nout:\r\nkfree(cgc->buffer);\r\nreturn ret;\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_read_audio(struct cdrom_device_info *cdi,\r\nvoid __user *arg)\r\n{\r\nstruct cdrom_read_audio ra;\r\nint lba;\r\nIOCTL_IN(arg, struct cdrom_read_audio, ra);\r\nif (ra.addr_format == CDROM_MSF)\r\nlba = msf_to_lba(ra.addr.msf.minute,\r\nra.addr.msf.second,\r\nra.addr.msf.frame);\r\nelse if (ra.addr_format == CDROM_LBA)\r\nlba = ra.addr.lba;\r\nelse\r\nreturn -EINVAL;\r\nif (lba < 0 || ra.nframes <= 0 || ra.nframes > CD_FRAMES)\r\nreturn -EINVAL;\r\nreturn cdrom_read_cdda(cdi, ra.buf, lba, ra.nframes);\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_subchannel(struct cdrom_device_info *cdi,\r\nvoid __user *arg)\r\n{\r\nint ret;\r\nstruct cdrom_subchnl q;\r\nu_char requested, back;\r\nIOCTL_IN(arg, struct cdrom_subchnl, q);\r\nrequested = q.cdsc_format;\r\nif (!((requested == CDROM_MSF) ||\r\n(requested == CDROM_LBA)))\r\nreturn -EINVAL;\r\nq.cdsc_format = CDROM_MSF;\r\nret = cdrom_read_subchannel(cdi, &q, 0);\r\nif (ret)\r\nreturn ret;\r\nback = q.cdsc_format;\r\nsanitize_format(&q.cdsc_absaddr, &back, requested);\r\nsanitize_format(&q.cdsc_reladdr, &q.cdsc_format, requested);\r\nIOCTL_OUT(arg, struct cdrom_subchnl, q);\r\nreturn 0;\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_play_msf(struct cdrom_device_info *cdi,\r\nvoid __user *arg,\r\nstruct packet_command *cgc)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nstruct cdrom_msf msf;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMPLAYMSF\n");\r\nIOCTL_IN(arg, struct cdrom_msf, msf);\r\ncgc->cmd[0] = GPCMD_PLAY_AUDIO_MSF;\r\ncgc->cmd[3] = msf.cdmsf_min0;\r\ncgc->cmd[4] = msf.cdmsf_sec0;\r\ncgc->cmd[5] = msf.cdmsf_frame0;\r\ncgc->cmd[6] = msf.cdmsf_min1;\r\ncgc->cmd[7] = msf.cdmsf_sec1;\r\ncgc->cmd[8] = msf.cdmsf_frame1;\r\ncgc->data_direction = CGC_DATA_NONE;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_play_blk(struct cdrom_device_info *cdi,\r\nvoid __user *arg,\r\nstruct packet_command *cgc)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nstruct cdrom_blk blk;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMPLAYBLK\n");\r\nIOCTL_IN(arg, struct cdrom_blk, blk);\r\ncgc->cmd[0] = GPCMD_PLAY_AUDIO_10;\r\ncgc->cmd[2] = (blk.from >> 24) & 0xff;\r\ncgc->cmd[3] = (blk.from >> 16) & 0xff;\r\ncgc->cmd[4] = (blk.from >> 8) & 0xff;\r\ncgc->cmd[5] = blk.from & 0xff;\r\ncgc->cmd[7] = (blk.len >> 8) & 0xff;\r\ncgc->cmd[8] = blk.len & 0xff;\r\ncgc->data_direction = CGC_DATA_NONE;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_volume(struct cdrom_device_info *cdi,\r\nvoid __user *arg,\r\nstruct packet_command *cgc,\r\nunsigned int cmd)\r\n{\r\nstruct cdrom_volctrl volctrl;\r\nunsigned char buffer[32];\r\nchar mask[sizeof(buffer)];\r\nunsigned short offset;\r\nint ret;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMVOLUME\n");\r\nIOCTL_IN(arg, struct cdrom_volctrl, volctrl);\r\ncgc->buffer = buffer;\r\ncgc->buflen = 24;\r\nret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 0);\r\nif (ret)\r\nreturn ret;\r\noffset = 8 + be16_to_cpu(*(__be16 *)(buffer + 6));\r\nif (offset + 16 > sizeof(buffer))\r\nreturn -E2BIG;\r\nif (offset + 16 > cgc->buflen) {\r\ncgc->buflen = offset + 16;\r\nret = cdrom_mode_sense(cdi, cgc,\r\nGPMODE_AUDIO_CTL_PAGE, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((buffer[offset] & 0x3f) != GPMODE_AUDIO_CTL_PAGE ||\r\nbuffer[offset + 1] < 14)\r\nreturn -EINVAL;\r\nif (cmd == CDROMVOLREAD) {\r\nvolctrl.channel0 = buffer[offset+9];\r\nvolctrl.channel1 = buffer[offset+11];\r\nvolctrl.channel2 = buffer[offset+13];\r\nvolctrl.channel3 = buffer[offset+15];\r\nIOCTL_OUT(arg, struct cdrom_volctrl, volctrl);\r\nreturn 0;\r\n}\r\ncgc->buffer = mask;\r\nret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 1);\r\nif (ret)\r\nreturn ret;\r\nbuffer[offset + 9] = volctrl.channel0 & mask[offset + 9];\r\nbuffer[offset + 11] = volctrl.channel1 & mask[offset + 11];\r\nbuffer[offset + 13] = volctrl.channel2 & mask[offset + 13];\r\nbuffer[offset + 15] = volctrl.channel3 & mask[offset + 15];\r\ncgc->buffer = buffer + offset - 8;\r\nmemset(cgc->buffer, 0, 8);\r\nreturn cdrom_mode_select(cdi, cgc);\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_start_stop(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc,\r\nint cmd)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMSTART/CDROMSTOP\n");\r\ncgc->cmd[0] = GPCMD_START_STOP_UNIT;\r\ncgc->cmd[1] = 1;\r\ncgc->cmd[4] = (cmd == CDROMSTART) ? 1 : 0;\r\ncgc->data_direction = CGC_DATA_NONE;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_pause_resume(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc,\r\nint cmd)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\ncdinfo(CD_DO_IOCTL, "entering CDROMPAUSE/CDROMRESUME\n");\r\ncgc->cmd[0] = GPCMD_PAUSE_RESUME;\r\ncgc->cmd[8] = (cmd == CDROMRESUME) ? 1 : 0;\r\ncgc->data_direction = CGC_DATA_NONE;\r\nreturn cdo->generic_packet(cdi, cgc);\r\n}\r\nstatic noinline int mmc_ioctl_dvd_read_struct(struct cdrom_device_info *cdi,\r\nvoid __user *arg,\r\nstruct packet_command *cgc)\r\n{\r\nint ret;\r\ndvd_struct *s;\r\nint size = sizeof(dvd_struct);\r\nif (!CDROM_CAN(CDC_DVD))\r\nreturn -ENOSYS;\r\ns = kmalloc(size, GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ncdinfo(CD_DO_IOCTL, "entering DVD_READ_STRUCT\n");\r\nif (copy_from_user(s, arg, size)) {\r\nkfree(s);\r\nreturn -EFAULT;\r\n}\r\nret = dvd_read_struct(cdi, s, cgc);\r\nif (ret)\r\ngoto out;\r\nif (copy_to_user(arg, s, size))\r\nret = -EFAULT;\r\nout:\r\nkfree(s);\r\nreturn ret;\r\n}\r\nstatic noinline int mmc_ioctl_dvd_auth(struct cdrom_device_info *cdi,\r\nvoid __user *arg)\r\n{\r\nint ret;\r\ndvd_authinfo ai;\r\nif (!CDROM_CAN(CDC_DVD))\r\nreturn -ENOSYS;\r\ncdinfo(CD_DO_IOCTL, "entering DVD_AUTH\n");\r\nIOCTL_IN(arg, dvd_authinfo, ai);\r\nret = dvd_do_auth(cdi, &ai);\r\nif (ret)\r\nreturn ret;\r\nIOCTL_OUT(arg, dvd_authinfo, ai);\r\nreturn 0;\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_next_writable(struct cdrom_device_info *cdi,\r\nvoid __user *arg)\r\n{\r\nint ret;\r\nlong next = 0;\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_NEXT_WRITABLE\n");\r\nret = cdrom_get_next_writable(cdi, &next);\r\nif (ret)\r\nreturn ret;\r\nIOCTL_OUT(arg, long, next);\r\nreturn 0;\r\n}\r\nstatic noinline int mmc_ioctl_cdrom_last_written(struct cdrom_device_info *cdi,\r\nvoid __user *arg)\r\n{\r\nint ret;\r\nlong last = 0;\r\ncdinfo(CD_DO_IOCTL, "entering CDROM_LAST_WRITTEN\n");\r\nret = cdrom_get_last_written(cdi, &last);\r\nif (ret)\r\nreturn ret;\r\nIOCTL_OUT(arg, long, last);\r\nreturn 0;\r\n}\r\nstatic int mmc_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct packet_command cgc;\r\nvoid __user *userptr = (void __user *)arg;\r\nmemset(&cgc, 0, sizeof(cgc));\r\nswitch (cmd) {\r\ncase CDROMREADRAW:\r\ncase CDROMREADMODE1:\r\ncase CDROMREADMODE2:\r\nreturn mmc_ioctl_cdrom_read_data(cdi, userptr, &cgc, cmd);\r\ncase CDROMREADAUDIO:\r\nreturn mmc_ioctl_cdrom_read_audio(cdi, userptr);\r\ncase CDROMSUBCHNL:\r\nreturn mmc_ioctl_cdrom_subchannel(cdi, userptr);\r\ncase CDROMPLAYMSF:\r\nreturn mmc_ioctl_cdrom_play_msf(cdi, userptr, &cgc);\r\ncase CDROMPLAYBLK:\r\nreturn mmc_ioctl_cdrom_play_blk(cdi, userptr, &cgc);\r\ncase CDROMVOLCTRL:\r\ncase CDROMVOLREAD:\r\nreturn mmc_ioctl_cdrom_volume(cdi, userptr, &cgc, cmd);\r\ncase CDROMSTART:\r\ncase CDROMSTOP:\r\nreturn mmc_ioctl_cdrom_start_stop(cdi, &cgc, cmd);\r\ncase CDROMPAUSE:\r\ncase CDROMRESUME:\r\nreturn mmc_ioctl_cdrom_pause_resume(cdi, &cgc, cmd);\r\ncase DVD_READ_STRUCT:\r\nreturn mmc_ioctl_dvd_read_struct(cdi, userptr, &cgc);\r\ncase DVD_AUTH:\r\nreturn mmc_ioctl_dvd_auth(cdi, userptr);\r\ncase CDROM_NEXT_WRITABLE:\r\nreturn mmc_ioctl_cdrom_next_writable(cdi, userptr);\r\ncase CDROM_LAST_WRITTEN:\r\nreturn mmc_ioctl_cdrom_last_written(cdi, userptr);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int cdrom_get_track_info(struct cdrom_device_info *cdi, __u16 track, __u8 type,\r\ntrack_information *ti)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nstruct packet_command cgc;\r\nint ret, buflen;\r\ninit_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;\r\ncgc.cmd[1] = type & 3;\r\ncgc.cmd[4] = (track & 0xff00) >> 8;\r\ncgc.cmd[5] = track & 0xff;\r\ncgc.cmd[8] = 8;\r\ncgc.quiet = 1;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nbuflen = be16_to_cpu(ti->track_information_length) +\r\nsizeof(ti->track_information_length);\r\nif (buflen > sizeof(track_information))\r\nbuflen = sizeof(track_information);\r\ncgc.cmd[8] = cgc.buflen = buflen;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nreturn buflen;\r\n}\r\nstatic int cdrom_get_disc_info(struct cdrom_device_info *cdi, disc_information *di)\r\n{\r\nstruct cdrom_device_ops *cdo = cdi->ops;\r\nstruct packet_command cgc;\r\nint ret, buflen;\r\ninit_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_READ_DISC_INFO;\r\ncgc.cmd[8] = cgc.buflen = 2;\r\ncgc.quiet = 1;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nbuflen = be16_to_cpu(di->disc_information_length) +\r\nsizeof(di->disc_information_length);\r\nif (buflen > sizeof(disc_information))\r\nbuflen = sizeof(disc_information);\r\ncgc.cmd[8] = cgc.buflen = buflen;\r\nif ((ret = cdo->generic_packet(cdi, &cgc)))\r\nreturn ret;\r\nreturn buflen;\r\n}\r\nint cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written)\r\n{\r\nstruct cdrom_tocentry toc;\r\ndisc_information di;\r\ntrack_information ti;\r\n__u32 last_track;\r\nint ret = -1, ti_size;\r\nif (!CDROM_CAN(CDC_GENERIC_PACKET))\r\ngoto use_toc;\r\nret = cdrom_get_disc_info(cdi, &di);\r\nif (ret < (int)(offsetof(typeof(di), last_track_lsb)\r\n+ sizeof(di.last_track_lsb)))\r\ngoto use_toc;\r\nlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\r\nti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\r\nif (ti_size < (int)offsetof(typeof(ti), track_start))\r\ngoto use_toc;\r\nif (ti.blank) {\r\nif (last_track==1)\r\ngoto use_toc;\r\nlast_track--;\r\nti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\r\n}\r\nif (ti_size < (int)(offsetof(typeof(ti), track_size)\r\n+ sizeof(ti.track_size)))\r\ngoto use_toc;\r\nif (ti.lra_v && ti_size >= (int)(offsetof(typeof(ti), last_rec_address)\r\n+ sizeof(ti.last_rec_address))) {\r\n*last_written = be32_to_cpu(ti.last_rec_address);\r\n} else {\r\n*last_written = be32_to_cpu(ti.track_start) +\r\nbe32_to_cpu(ti.track_size);\r\nif (ti.free_blocks)\r\n*last_written -= (be32_to_cpu(ti.free_blocks) + 7);\r\n}\r\nreturn 0;\r\nuse_toc:\r\ntoc.cdte_format = CDROM_MSF;\r\ntoc.cdte_track = CDROM_LEADOUT;\r\nif ((ret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCENTRY, &toc)))\r\nreturn ret;\r\nsanitize_format(&toc.cdte_addr, &toc.cdte_format, CDROM_LBA);\r\n*last_written = toc.cdte_addr.lba;\r\nreturn 0;\r\n}\r\nstatic int cdrom_get_next_writable(struct cdrom_device_info *cdi, long *next_writable)\r\n{\r\ndisc_information di;\r\ntrack_information ti;\r\n__u16 last_track;\r\nint ret, ti_size;\r\nif (!CDROM_CAN(CDC_GENERIC_PACKET))\r\ngoto use_last_written;\r\nret = cdrom_get_disc_info(cdi, &di);\r\nif (ret < 0 || ret < offsetof(typeof(di), last_track_lsb)\r\n+ sizeof(di.last_track_lsb))\r\ngoto use_last_written;\r\nlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\r\nti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\r\nif (ti_size < 0 || ti_size < offsetof(typeof(ti), track_start))\r\ngoto use_last_written;\r\nif (ti.blank) {\r\nif (last_track == 1)\r\ngoto use_last_written;\r\nlast_track--;\r\nti_size = cdrom_get_track_info(cdi, last_track, 1, &ti);\r\nif (ti_size < 0)\r\ngoto use_last_written;\r\n}\r\nif (ti.nwa_v && ti_size >= offsetof(typeof(ti), next_writable)\r\n+ sizeof(ti.next_writable)) {\r\n*next_writable = be32_to_cpu(ti.next_writable);\r\nreturn 0;\r\n}\r\nuse_last_written:\r\nif ((ret = cdrom_get_last_written(cdi, next_writable))) {\r\n*next_writable = 0;\r\nreturn ret;\r\n} else {\r\n*next_writable += 7;\r\nreturn 0;\r\n}\r\n}\r\nstatic int cdrom_print_info(const char *header, int val, char *info,\r\nint *pos, enum cdrom_print_option option)\r\n{\r\nconst int max_size = sizeof(cdrom_sysctl_settings.info);\r\nstruct cdrom_device_info *cdi;\r\nint ret;\r\nret = scnprintf(info + *pos, max_size - *pos, header);\r\nif (!ret)\r\nreturn 1;\r\n*pos += ret;\r\nlist_for_each_entry(cdi, &cdrom_list, list) {\r\nswitch (option) {\r\ncase CTL_NAME:\r\nret = scnprintf(info + *pos, max_size - *pos,\r\n"\t%s", cdi->name);\r\nbreak;\r\ncase CTL_SPEED:\r\nret = scnprintf(info + *pos, max_size - *pos,\r\n"\t%d", cdi->speed);\r\nbreak;\r\ncase CTL_SLOTS:\r\nret = scnprintf(info + *pos, max_size - *pos,\r\n"\t%d", cdi->capacity);\r\nbreak;\r\ncase CTL_CAPABILITY:\r\nret = scnprintf(info + *pos, max_size - *pos,\r\n"\t%d", CDROM_CAN(val) != 0);\r\nbreak;\r\ndefault:\r\npr_info("invalid option%d\n", option);\r\nreturn 1;\r\n}\r\nif (!ret)\r\nreturn 1;\r\n*pos += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdrom_sysctl_info(ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint pos;\r\nchar *info = cdrom_sysctl_settings.info;\r\nconst int max_size = sizeof(cdrom_sysctl_settings.info);\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nmutex_lock(&cdrom_mutex);\r\npos = sprintf(info, "CD-ROM information, " VERSION "\n");\r\nif (cdrom_print_info("\ndrive name:\t", 0, info, &pos, CTL_NAME))\r\ngoto done;\r\nif (cdrom_print_info("\ndrive speed:\t", 0, info, &pos, CTL_SPEED))\r\ngoto done;\r\nif (cdrom_print_info("\ndrive # of slots:", 0, info, &pos, CTL_SLOTS))\r\ngoto done;\r\nif (cdrom_print_info("\nCan close tray:\t",\r\nCDC_CLOSE_TRAY, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan open tray:\t",\r\nCDC_OPEN_TRAY, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan lock tray:\t",\r\nCDC_LOCK, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan change speed:",\r\nCDC_SELECT_SPEED, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan select disk:",\r\nCDC_SELECT_DISC, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan read multisession:",\r\nCDC_MULTI_SESSION, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan read MCN:\t",\r\nCDC_MCN, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nReports media changed:",\r\nCDC_MEDIA_CHANGED, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan play audio:\t",\r\nCDC_PLAY_AUDIO, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan write CD-R:\t",\r\nCDC_CD_R, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan write CD-RW:",\r\nCDC_CD_RW, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan read DVD:\t",\r\nCDC_DVD, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan write DVD-R:",\r\nCDC_DVD_R, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan write DVD-RAM:",\r\nCDC_DVD_RAM, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan read MRW:\t",\r\nCDC_MRW, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan write MRW:\t",\r\nCDC_MRW_W, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (cdrom_print_info("\nCan write RAM:\t",\r\nCDC_RAM, info, &pos, CTL_CAPABILITY))\r\ngoto done;\r\nif (!scnprintf(info + pos, max_size - pos, "\n\n"))\r\ngoto done;\r\ndoit:\r\nmutex_unlock(&cdrom_mutex);\r\nreturn proc_dostring(ctl, write, buffer, lenp, ppos);\r\ndone:\r\npr_info("info buffer too small\n");\r\ngoto doit;\r\n}\r\nstatic void cdrom_update_settings(void)\r\n{\r\nstruct cdrom_device_info *cdi;\r\nmutex_lock(&cdrom_mutex);\r\nlist_for_each_entry(cdi, &cdrom_list, list) {\r\nif (autoclose && CDROM_CAN(CDC_CLOSE_TRAY))\r\ncdi->options |= CDO_AUTO_CLOSE;\r\nelse if (!autoclose)\r\ncdi->options &= ~CDO_AUTO_CLOSE;\r\nif (autoeject && CDROM_CAN(CDC_OPEN_TRAY))\r\ncdi->options |= CDO_AUTO_EJECT;\r\nelse if (!autoeject)\r\ncdi->options &= ~CDO_AUTO_EJECT;\r\nif (lockdoor && CDROM_CAN(CDC_LOCK))\r\ncdi->options |= CDO_LOCK;\r\nelse if (!lockdoor)\r\ncdi->options &= ~CDO_LOCK;\r\nif (check_media_type)\r\ncdi->options |= CDO_CHECK_TYPE;\r\nelse\r\ncdi->options &= ~CDO_CHECK_TYPE;\r\n}\r\nmutex_unlock(&cdrom_mutex);\r\n}\r\nstatic int cdrom_sysctl_handler(ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint ret;\r\nret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nif (write) {\r\nautoclose = !!cdrom_sysctl_settings.autoclose;\r\nautoeject = !!cdrom_sysctl_settings.autoeject;\r\ndebug = !!cdrom_sysctl_settings.debug;\r\nlockdoor = !!cdrom_sysctl_settings.lock;\r\ncheck_media_type = !!cdrom_sysctl_settings.check;\r\ncdrom_update_settings();\r\n}\r\nreturn ret;\r\n}\r\nstatic void cdrom_sysctl_register(void)\r\n{\r\nstatic int initialized;\r\nif (initialized == 1)\r\nreturn;\r\ncdrom_sysctl_header = register_sysctl_table(cdrom_root_table);\r\ncdrom_sysctl_settings.autoclose = autoclose;\r\ncdrom_sysctl_settings.autoeject = autoeject;\r\ncdrom_sysctl_settings.debug = debug;\r\ncdrom_sysctl_settings.lock = lockdoor;\r\ncdrom_sysctl_settings.check = check_media_type;\r\ninitialized = 1;\r\n}\r\nstatic void cdrom_sysctl_unregister(void)\r\n{\r\nif (cdrom_sysctl_header)\r\nunregister_sysctl_table(cdrom_sysctl_header);\r\n}\r\nstatic void cdrom_sysctl_register(void)\r\n{\r\n}\r\nstatic void cdrom_sysctl_unregister(void)\r\n{\r\n}\r\nstatic int __init cdrom_init(void)\r\n{\r\ncdrom_sysctl_register();\r\nreturn 0;\r\n}\r\nstatic void __exit cdrom_exit(void)\r\n{\r\npr_info("Uniform CD-ROM driver unloaded\n");\r\ncdrom_sysctl_unregister();\r\n}
