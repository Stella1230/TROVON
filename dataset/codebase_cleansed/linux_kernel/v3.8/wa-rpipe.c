static int __rpipe_get_descr(struct wahc *wa,\r\nstruct usb_rpipe_descriptor *descr, u16 index)\r\n{\r\nssize_t result;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nresult = usb_control_msg(\r\nwa->usb_dev, usb_rcvctrlpipe(wa->usb_dev, 0),\r\nUSB_REQ_GET_DESCRIPTOR,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_RPIPE,\r\nUSB_DT_RPIPE<<8, index, descr, sizeof(*descr),\r\n1000 );\r\nif (result < 0) {\r\ndev_err(dev, "rpipe %u: get descriptor failed: %d\n",\r\nindex, (int)result);\r\ngoto error;\r\n}\r\nif (result < sizeof(*descr)) {\r\ndev_err(dev, "rpipe %u: got short descriptor "\r\n"(%zd vs %zd bytes needed)\n",\r\nindex, result, sizeof(*descr));\r\nresult = -EINVAL;\r\ngoto error;\r\n}\r\nresult = 0;\r\nerror:\r\nreturn result;\r\n}\r\nstatic int __rpipe_set_descr(struct wahc *wa,\r\nstruct usb_rpipe_descriptor *descr, u16 index)\r\n{\r\nssize_t result;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nresult = usb_control_msg(\r\nwa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nUSB_REQ_SET_DESCRIPTOR,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_RPIPE,\r\nUSB_DT_RPIPE<<8, index, descr, sizeof(*descr),\r\nHZ / 10);\r\nif (result < 0) {\r\ndev_err(dev, "rpipe %u: set descriptor failed: %d\n",\r\nindex, (int)result);\r\ngoto error;\r\n}\r\nif (result < sizeof(*descr)) {\r\ndev_err(dev, "rpipe %u: sent short descriptor "\r\n"(%zd vs %zd bytes required)\n",\r\nindex, result, sizeof(*descr));\r\nresult = -EINVAL;\r\ngoto error;\r\n}\r\nresult = 0;\r\nerror:\r\nreturn result;\r\n}\r\nstatic void rpipe_init(struct wa_rpipe *rpipe)\r\n{\r\nkref_init(&rpipe->refcnt);\r\nspin_lock_init(&rpipe->seg_lock);\r\nINIT_LIST_HEAD(&rpipe->seg_list);\r\n}\r\nstatic unsigned rpipe_get_idx(struct wahc *wa, unsigned rpipe_idx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wa->rpipe_bm_lock, flags);\r\nrpipe_idx = find_next_zero_bit(wa->rpipe_bm, wa->rpipes, rpipe_idx);\r\nif (rpipe_idx < wa->rpipes)\r\nset_bit(rpipe_idx, wa->rpipe_bm);\r\nspin_unlock_irqrestore(&wa->rpipe_bm_lock, flags);\r\nreturn rpipe_idx;\r\n}\r\nstatic void rpipe_put_idx(struct wahc *wa, unsigned rpipe_idx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wa->rpipe_bm_lock, flags);\r\nclear_bit(rpipe_idx, wa->rpipe_bm);\r\nspin_unlock_irqrestore(&wa->rpipe_bm_lock, flags);\r\n}\r\nvoid rpipe_destroy(struct kref *_rpipe)\r\n{\r\nstruct wa_rpipe *rpipe = container_of(_rpipe, struct wa_rpipe, refcnt);\r\nu8 index = le16_to_cpu(rpipe->descr.wRPipeIndex);\r\nif (rpipe->ep)\r\nrpipe->ep->hcpriv = NULL;\r\nrpipe_put_idx(rpipe->wa, index);\r\nwa_put(rpipe->wa);\r\nkfree(rpipe);\r\n}\r\nstatic int rpipe_get_idle(struct wa_rpipe **prpipe, struct wahc *wa, u8 crs,\r\ngfp_t gfp)\r\n{\r\nint result;\r\nunsigned rpipe_idx;\r\nstruct wa_rpipe *rpipe;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nrpipe = kzalloc(sizeof(*rpipe), gfp);\r\nif (rpipe == NULL)\r\nreturn -ENOMEM;\r\nrpipe_init(rpipe);\r\nfor (rpipe_idx = 0; rpipe_idx < wa->rpipes; rpipe_idx++) {\r\nrpipe_idx = rpipe_get_idx(wa, rpipe_idx);\r\nif (rpipe_idx >= wa->rpipes)\r\nbreak;\r\nresult = __rpipe_get_descr(wa, &rpipe->descr, rpipe_idx);\r\nif (result < 0)\r\ndev_err(dev, "Can't get descriptor for rpipe %u: %d\n",\r\nrpipe_idx, result);\r\nelse if ((rpipe->descr.bmCharacteristics & crs) != 0)\r\ngoto found;\r\nrpipe_put_idx(wa, rpipe_idx);\r\n}\r\n*prpipe = NULL;\r\nkfree(rpipe);\r\nreturn -ENXIO;\r\nfound:\r\nset_bit(rpipe_idx, wa->rpipe_bm);\r\nrpipe->wa = wa_get(wa);\r\n*prpipe = rpipe;\r\nreturn 0;\r\n}\r\nstatic int __rpipe_reset(struct wahc *wa, unsigned index)\r\n{\r\nint result;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nresult = usb_control_msg(\r\nwa->usb_dev, usb_sndctrlpipe(wa->usb_dev, 0),\r\nUSB_REQ_RPIPE_RESET,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_RPIPE,\r\n0, index, NULL, 0, 1000 );\r\nif (result < 0)\r\ndev_err(dev, "rpipe %u: reset failed: %d\n",\r\nindex, result);\r\nreturn result;\r\n}\r\nstatic struct usb_wireless_ep_comp_descriptor *rpipe_epc_find(\r\nstruct device *dev, struct usb_host_endpoint *ep)\r\n{\r\nvoid *itr;\r\nsize_t itr_size;\r\nstruct usb_descriptor_header *hdr;\r\nstruct usb_wireless_ep_comp_descriptor *epcd;\r\nif (ep->desc.bEndpointAddress == 0) {\r\nepcd = &epc0;\r\ngoto out;\r\n}\r\nitr = ep->extra;\r\nitr_size = ep->extralen;\r\nepcd = NULL;\r\nwhile (itr_size > 0) {\r\nif (itr_size < sizeof(*hdr)) {\r\ndev_err(dev, "HW Bug? ep 0x%02x: extra descriptors "\r\n"at offset %zu: only %zu bytes left\n",\r\nep->desc.bEndpointAddress,\r\nitr - (void *) ep->extra, itr_size);\r\nbreak;\r\n}\r\nhdr = itr;\r\nif (hdr->bDescriptorType == USB_DT_WIRELESS_ENDPOINT_COMP) {\r\nepcd = itr;\r\nbreak;\r\n}\r\nif (hdr->bLength > itr_size) {\r\ndev_err(dev, "HW Bug? ep 0x%02x: extra descriptor "\r\n"at offset %zu (type 0x%02x) "\r\n"length %d but only %zu bytes left\n",\r\nep->desc.bEndpointAddress,\r\nitr - (void *) ep->extra, hdr->bDescriptorType,\r\nhdr->bLength, itr_size);\r\nbreak;\r\n}\r\nitr += hdr->bLength;\r\nitr_size -= hdr->bDescriptorType;\r\n}\r\nout:\r\nreturn epcd;\r\n}\r\nstatic int rpipe_aim(struct wa_rpipe *rpipe, struct wahc *wa,\r\nstruct usb_host_endpoint *ep, struct urb *urb, gfp_t gfp)\r\n{\r\nint result = -ENOMSG;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nstruct usb_device *usb_dev = urb->dev;\r\nstruct usb_wireless_ep_comp_descriptor *epcd;\r\nu8 unauth;\r\nepcd = rpipe_epc_find(dev, ep);\r\nif (epcd == NULL) {\r\ndev_err(dev, "ep 0x%02x: can't find companion descriptor\n",\r\nep->desc.bEndpointAddress);\r\ngoto error;\r\n}\r\nunauth = usb_dev->wusb && !usb_dev->authenticated ? 0x80 : 0;\r\n__rpipe_reset(wa, le16_to_cpu(rpipe->descr.wRPipeIndex));\r\natomic_set(&rpipe->segs_available, le16_to_cpu(rpipe->descr.wRequests));\r\nrpipe->descr.wBlocks = cpu_to_le16(16);\r\nrpipe->descr.wMaxPacketSize = cpu_to_le16(ep->desc.wMaxPacketSize);\r\nrpipe->descr.bHSHubAddress = 0;\r\nrpipe->descr.bHSHubPort = wusb_port_no_to_idx(urb->dev->portnum);\r\nrpipe->descr.bSpeed = usb_pipeendpoint(urb->pipe) == 0 ?\r\nUWB_PHY_RATE_53 : UWB_PHY_RATE_200;\r\ndev_dbg(dev, "addr %u (0x%02x) rpipe #%u ep# %u speed %d\n",\r\nurb->dev->devnum, urb->dev->devnum | unauth,\r\nle16_to_cpu(rpipe->descr.wRPipeIndex),\r\nusb_pipeendpoint(urb->pipe), rpipe->descr.bSpeed);\r\nif (unlikely(urb->dev->devnum == 0x80))\r\nrpipe->descr.bDeviceAddress = 0;\r\nelse\r\nrpipe->descr.bDeviceAddress = urb->dev->devnum | unauth;\r\nrpipe->descr.bEndpointAddress = ep->desc.bEndpointAddress;\r\nrpipe->descr.bDataSequence = 0;\r\nrpipe->descr.dwCurrentWindow = cpu_to_le32(1);\r\nrpipe->descr.bMaxDataSequence = epcd->bMaxSequence - 1;\r\nrpipe->descr.bInterval = ep->desc.bInterval;\r\nrpipe->descr.bOverTheAirInterval = 0;\r\nrpipe->descr.bmAttribute = ep->desc.bmAttributes & 0x03;\r\nrpipe->descr.bmRetryOptions = 15;\r\nrpipe->descr.wNumTransactionErrors = 0;\r\nresult = __rpipe_set_descr(wa, &rpipe->descr,\r\nle16_to_cpu(rpipe->descr.wRPipeIndex));\r\nif (result < 0) {\r\ndev_err(dev, "Cannot aim rpipe: %d\n", result);\r\ngoto error;\r\n}\r\nresult = 0;\r\nerror:\r\nreturn result;\r\n}\r\nstatic int rpipe_check_aim(const struct wa_rpipe *rpipe, const struct wahc *wa,\r\nconst struct usb_host_endpoint *ep,\r\nconst struct urb *urb, gfp_t gfp)\r\n{\r\nint result = 0;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nstruct usb_device *usb_dev = urb->dev;\r\nu8 unauth = (usb_dev->wusb && !usb_dev->authenticated) ? 0x80 : 0;\r\nu8 portnum = wusb_port_no_to_idx(urb->dev->portnum);\r\n#define AIM_CHECK(rdf, val, text) \\r\ndo { \\r\nif (rpipe->descr.rdf != (val)) { \\r\ndev_err(dev, \\r\n"rpipe aim discrepancy: " #rdf " " text "\n", \\r\nrpipe->descr.rdf, (val)); \\r\nresult = -EINVAL; \\r\nWARN_ON(1); \\r\n} \\r\n} while (0)\r\nAIM_CHECK(wMaxPacketSize, cpu_to_le16(ep->desc.wMaxPacketSize),\r\n"(%u vs %u)");\r\nAIM_CHECK(bHSHubPort, portnum, "(%u vs %u)");\r\nAIM_CHECK(bSpeed, usb_pipeendpoint(urb->pipe) == 0 ?\r\nUWB_PHY_RATE_53 : UWB_PHY_RATE_200,\r\n"(%u vs %u)");\r\nAIM_CHECK(bDeviceAddress, urb->dev->devnum | unauth, "(%u vs %u)");\r\nAIM_CHECK(bEndpointAddress, ep->desc.bEndpointAddress, "(%u vs %u)");\r\nAIM_CHECK(bInterval, ep->desc.bInterval, "(%u vs %u)");\r\nAIM_CHECK(bmAttribute, ep->desc.bmAttributes & 0x03, "(%u vs %u)");\r\n#undef AIM_CHECK\r\nreturn result;\r\n}\r\nint rpipe_get_by_ep(struct wahc *wa, struct usb_host_endpoint *ep,\r\nstruct urb *urb, gfp_t gfp)\r\n{\r\nint result = 0;\r\nstruct device *dev = &wa->usb_iface->dev;\r\nstruct wa_rpipe *rpipe;\r\nu8 eptype;\r\nmutex_lock(&wa->rpipe_mutex);\r\nrpipe = ep->hcpriv;\r\nif (rpipe != NULL) {\r\nif (CONFIG_BUG == 1) {\r\nresult = rpipe_check_aim(rpipe, wa, ep, urb, gfp);\r\nif (result < 0)\r\ngoto error;\r\n}\r\n__rpipe_get(rpipe);\r\ndev_dbg(dev, "ep 0x%02x: reusing rpipe %u\n",\r\nep->desc.bEndpointAddress,\r\nle16_to_cpu(rpipe->descr.wRPipeIndex));\r\n} else {\r\nresult = -ENOBUFS;\r\neptype = ep->desc.bmAttributes & 0x03;\r\nresult = rpipe_get_idle(&rpipe, wa, 1 << eptype, gfp);\r\nif (result < 0)\r\ngoto error;\r\nresult = rpipe_aim(rpipe, wa, ep, urb, gfp);\r\nif (result < 0) {\r\nrpipe_put(rpipe);\r\ngoto error;\r\n}\r\nep->hcpriv = rpipe;\r\nrpipe->ep = ep;\r\n__rpipe_get(rpipe);\r\ndev_dbg(dev, "ep 0x%02x: using rpipe %u\n",\r\nep->desc.bEndpointAddress,\r\nle16_to_cpu(rpipe->descr.wRPipeIndex));\r\n}\r\nerror:\r\nmutex_unlock(&wa->rpipe_mutex);\r\nreturn result;\r\n}\r\nint wa_rpipes_create(struct wahc *wa)\r\n{\r\nwa->rpipes = wa->wa_descr->wNumRPipes;\r\nwa->rpipe_bm = kzalloc(BITS_TO_LONGS(wa->rpipes)*sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (wa->rpipe_bm == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid wa_rpipes_destroy(struct wahc *wa)\r\n{\r\nstruct device *dev = &wa->usb_iface->dev;\r\nif (!bitmap_empty(wa->rpipe_bm, wa->rpipes)) {\r\nchar buf[256];\r\nWARN_ON(1);\r\nbitmap_scnprintf(buf, sizeof(buf), wa->rpipe_bm, wa->rpipes);\r\ndev_err(dev, "BUG: pipes not released on exit: %s\n", buf);\r\n}\r\nkfree(wa->rpipe_bm);\r\n}\r\nvoid rpipe_ep_disable(struct wahc *wa, struct usb_host_endpoint *ep)\r\n{\r\nstruct wa_rpipe *rpipe;\r\nmutex_lock(&wa->rpipe_mutex);\r\nrpipe = ep->hcpriv;\r\nif (rpipe != NULL) {\r\nu16 index = le16_to_cpu(rpipe->descr.wRPipeIndex);\r\nusb_control_msg(\r\nwa->usb_dev, usb_rcvctrlpipe(wa->usb_dev, 0),\r\nUSB_REQ_RPIPE_ABORT,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_RPIPE,\r\n0, index, NULL, 0, 1000 );\r\nrpipe_put(rpipe);\r\n}\r\nmutex_unlock(&wa->rpipe_mutex);\r\n}
