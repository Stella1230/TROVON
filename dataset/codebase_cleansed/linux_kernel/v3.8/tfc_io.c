int ft_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\r\nstruct fc_frame *fp = NULL;\r\nstruct fc_exch *ep;\r\nstruct fc_lport *lport;\r\nstruct scatterlist *sg = NULL;\r\nsize_t remaining;\r\nu32 f_ctl = FC_FC_EX_CTX | FC_FC_REL_OFF;\r\nu32 mem_off = 0;\r\nu32 fh_off = 0;\r\nu32 frame_off = 0;\r\nsize_t frame_len = 0;\r\nsize_t mem_len = 0;\r\nsize_t tlen;\r\nsize_t off_in_page;\r\nstruct page *page = NULL;\r\nint use_sg;\r\nint error;\r\nvoid *page_addr;\r\nvoid *from;\r\nvoid *to = NULL;\r\nif (cmd->aborted)\r\nreturn 0;\r\nep = fc_seq_exch(cmd->seq);\r\nlport = ep->lp;\r\ncmd->seq = lport->tt.seq_start_next(cmd->seq);\r\nremaining = se_cmd->data_length;\r\nBUG_ON(remaining && !se_cmd->t_data_sg);\r\nif (remaining) {\r\nsg = se_cmd->t_data_sg;\r\nmem_len = sg->length;\r\nmem_off = sg->offset;\r\npage = sg_page(sg);\r\n}\r\nuse_sg = !(remaining % 4);\r\nwhile (remaining) {\r\nif (!mem_len) {\r\nsg = sg_next(sg);\r\nmem_len = min((size_t)sg->length, remaining);\r\nmem_off = sg->offset;\r\npage = sg_page(sg);\r\n}\r\nif (!frame_len) {\r\nframe_len = (lport->seq_offload) ? lport->lso_max :\r\ncmd->sess->max_frame;\r\nframe_len = min(frame_len, remaining);\r\nfp = fc_frame_alloc(lport, use_sg ? 0 : frame_len);\r\nif (!fp)\r\nreturn -ENOMEM;\r\nto = fc_frame_payload_get(fp, 0);\r\nfh_off = frame_off;\r\nframe_off += frame_len;\r\nfr_max_payload(fp) = cmd->sess->max_frame;\r\n}\r\ntlen = min(mem_len, frame_len);\r\nif (use_sg) {\r\noff_in_page = mem_off;\r\nBUG_ON(!page);\r\nget_page(page);\r\nskb_fill_page_desc(fp_skb(fp),\r\nskb_shinfo(fp_skb(fp))->nr_frags,\r\npage, off_in_page, tlen);\r\nfr_len(fp) += tlen;\r\nfp_skb(fp)->data_len += tlen;\r\nfp_skb(fp)->truesize +=\r\nPAGE_SIZE << compound_order(page);\r\n} else {\r\nBUG_ON(!page);\r\nfrom = kmap_atomic(page + (mem_off >> PAGE_SHIFT));\r\npage_addr = from;\r\nfrom += mem_off & ~PAGE_MASK;\r\ntlen = min(tlen, (size_t)(PAGE_SIZE -\r\n(mem_off & ~PAGE_MASK)));\r\nmemcpy(to, from, tlen);\r\nkunmap_atomic(page_addr);\r\nto += tlen;\r\n}\r\nmem_off += tlen;\r\nmem_len -= tlen;\r\nframe_len -= tlen;\r\nremaining -= tlen;\r\nif (frame_len &&\r\n(skb_shinfo(fp_skb(fp))->nr_frags < FC_FRAME_SG_LEN))\r\ncontinue;\r\nif (!remaining)\r\nf_ctl |= FC_FC_END_SEQ;\r\nfc_fill_fc_hdr(fp, FC_RCTL_DD_SOL_DATA, ep->did, ep->sid,\r\nFC_TYPE_FCP, f_ctl, fh_off);\r\nerror = lport->tt.seq_send(lport, cmd->seq, fp);\r\nif (error) {\r\npr_err_ratelimited("%s: Failed to send frame %p, "\r\n"xid <0x%x>, remaining %zu, "\r\n"lso_max <0x%x>\n",\r\n__func__, fp, ep->xid,\r\nremaining, lport->lso_max);\r\n}\r\n}\r\nreturn ft_queue_status(se_cmd);\r\n}\r\nstatic void ft_execute_work(struct work_struct *work)\r\n{\r\nstruct ft_cmd *cmd = container_of(work, struct ft_cmd, work);\r\ntarget_execute_cmd(&cmd->se_cmd);\r\n}\r\nvoid ft_recv_write_data(struct ft_cmd *cmd, struct fc_frame *fp)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct fc_seq *seq = cmd->seq;\r\nstruct fc_exch *ep;\r\nstruct fc_lport *lport;\r\nstruct fc_frame_header *fh;\r\nstruct scatterlist *sg = NULL;\r\nu32 mem_off = 0;\r\nu32 rel_off;\r\nsize_t frame_len;\r\nsize_t mem_len = 0;\r\nsize_t tlen;\r\nstruct page *page = NULL;\r\nvoid *page_addr;\r\nvoid *from;\r\nvoid *to;\r\nu32 f_ctl;\r\nvoid *buf;\r\nfh = fc_frame_header_get(fp);\r\nif (!(ntoh24(fh->fh_f_ctl) & FC_FC_REL_OFF))\r\ngoto drop;\r\nf_ctl = ntoh24(fh->fh_f_ctl);\r\nep = fc_seq_exch(seq);\r\nlport = ep->lp;\r\nif (cmd->was_ddp_setup) {\r\nBUG_ON(!ep);\r\nBUG_ON(!lport);\r\nbuf = fc_frame_payload_get(fp, 1);\r\nif (buf)\r\npr_err("%s: xid 0x%x, f_ctl 0x%x, cmd->sg %p, "\r\n"cmd->sg_cnt 0x%x. DDP was setup"\r\n" hence not expected to receive frame with "\r\n"payload, Frame will be dropped if"\r\n"'Sequence Initiative' bit in f_ctl is"\r\n"not set\n", __func__, ep->xid, f_ctl,\r\nse_cmd->t_data_sg, se_cmd->t_data_nents);\r\nft_invl_hw_context(cmd);\r\nif (f_ctl & FC_FC_SEQ_INIT)\r\ngoto last_frame;\r\nelse\r\ngoto drop;\r\n}\r\nrel_off = ntohl(fh->fh_parm_offset);\r\nframe_len = fr_len(fp);\r\nif (frame_len <= sizeof(*fh))\r\ngoto drop;\r\nframe_len -= sizeof(*fh);\r\nfrom = fc_frame_payload_get(fp, 0);\r\nif (rel_off >= se_cmd->data_length)\r\ngoto drop;\r\nif (frame_len + rel_off > se_cmd->data_length)\r\nframe_len = se_cmd->data_length - rel_off;\r\nBUG_ON(frame_len && !se_cmd->t_data_sg);\r\nif (frame_len) {\r\nsg = se_cmd->t_data_sg;\r\nmem_len = sg->length;\r\nmem_off = sg->offset;\r\npage = sg_page(sg);\r\n}\r\nwhile (frame_len) {\r\nif (!mem_len) {\r\nsg = sg_next(sg);\r\nmem_len = sg->length;\r\nmem_off = sg->offset;\r\npage = sg_page(sg);\r\n}\r\nif (rel_off >= mem_len) {\r\nrel_off -= mem_len;\r\nmem_len = 0;\r\ncontinue;\r\n}\r\nmem_off += rel_off;\r\nmem_len -= rel_off;\r\nrel_off = 0;\r\ntlen = min(mem_len, frame_len);\r\nto = kmap_atomic(page + (mem_off >> PAGE_SHIFT));\r\npage_addr = to;\r\nto += mem_off & ~PAGE_MASK;\r\ntlen = min(tlen, (size_t)(PAGE_SIZE -\r\n(mem_off & ~PAGE_MASK)));\r\nmemcpy(to, from, tlen);\r\nkunmap_atomic(page_addr);\r\nfrom += tlen;\r\nframe_len -= tlen;\r\nmem_off += tlen;\r\nmem_len -= tlen;\r\ncmd->write_data_len += tlen;\r\n}\r\nlast_frame:\r\nif (cmd->write_data_len == se_cmd->data_length) {\r\nINIT_WORK(&cmd->work, ft_execute_work);\r\nqueue_work(cmd->sess->tport->tpg->workqueue, &cmd->work);\r\n}\r\ndrop:\r\nfc_frame_free(fp);\r\n}\r\nvoid ft_invl_hw_context(struct ft_cmd *cmd)\r\n{\r\nstruct fc_seq *seq;\r\nstruct fc_exch *ep = NULL;\r\nstruct fc_lport *lport = NULL;\r\nBUG_ON(!cmd);\r\nseq = cmd->seq;\r\nif (cmd->was_ddp_setup && seq) {\r\nep = fc_seq_exch(seq);\r\nif (ep) {\r\nlport = ep->lp;\r\nif (lport && (ep->xid <= lport->lro_xid))\r\ncmd->write_data_len = lport->tt.ddp_done(lport,\r\nep->xid);\r\ncmd->was_ddp_setup = 0;\r\n}\r\n}\r\n}
