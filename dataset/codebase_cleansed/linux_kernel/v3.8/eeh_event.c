static int eeh_event_handler(void * dummy)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event;\r\nstruct eeh_pe *pe;\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nevent = NULL;\r\nif (!list_empty(&eeh_eventlist)) {\r\nevent = list_entry(eeh_eventlist.next, struct eeh_event, list);\r\nlist_del(&event->list);\r\n}\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\nif (event == NULL)\r\nreturn 0;\r\nmutex_lock(&eeh_event_mutex);\r\npe = event->pe;\r\neeh_pe_state_mark(pe, EEH_PE_RECOVERING);\r\npr_info("EEH: Detected PCI bus error on PHB#%d-PE#%x\n",\r\npe->phb->global_number, pe->addr);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\neeh_handle_event(pe);\r\neeh_pe_state_clear(pe, EEH_PE_RECOVERING);\r\nkfree(event);\r\nmutex_unlock(&eeh_event_mutex);\r\nif (pe && pe->freeze_count > 0) {\r\nmsleep_interruptible(3600*1000);\r\nif (pe->freeze_count > 0)\r\npe->freeze_count--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void eeh_thread_launcher(struct work_struct *dummy)\r\n{\r\nif (IS_ERR(kthread_run(eeh_event_handler, NULL, "eehd")))\r\nprintk(KERN_ERR "Failed to start EEH daemon\n");\r\n}\r\nint eeh_send_failure_event(struct eeh_pe *pe)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event;\r\nevent = kzalloc(sizeof(*event), GFP_ATOMIC);\r\nif (!event) {\r\npr_err("EEH: out of memory, event not handled\n");\r\nreturn -ENOMEM;\r\n}\r\nevent->pe = pe;\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nlist_add(&event->list, &eeh_eventlist);\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\nschedule_work(&eeh_event_wq);\r\nreturn 0;\r\n}
