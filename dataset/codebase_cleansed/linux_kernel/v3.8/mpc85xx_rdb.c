void __init mpc85xx_rdb_pic_init(void)\r\n{\r\nstruct mpic *mpic;\r\nunsigned long root = of_get_flat_dt_root();\r\n#ifdef CONFIG_QUICC_ENGINE\r\nstruct device_node *np;\r\n#endif\r\nif (of_flat_dt_is_compatible(root, "fsl,MPC85XXRDB-CAMP")) {\r\nmpic = mpic_alloc(NULL, 0, MPIC_NO_RESET |\r\nMPIC_BIG_ENDIAN |\r\nMPIC_SINGLE_DEST_CPU,\r\n0, 256, " OpenPIC ");\r\n} else {\r\nmpic = mpic_alloc(NULL, 0,\r\nMPIC_BIG_ENDIAN |\r\nMPIC_SINGLE_DEST_CPU,\r\n0, 256, " OpenPIC ");\r\n}\r\nBUG_ON(mpic == NULL);\r\nmpic_init(mpic);\r\n#ifdef CONFIG_QUICC_ENGINE\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,qe-ic");\r\nif (np) {\r\nqe_ic_init(np, 0, qe_ic_cascade_low_mpic,\r\nqe_ic_cascade_high_mpic);\r\nof_node_put(np);\r\n} else\r\npr_err("%s: Could not find qe-ic node\n", __func__);\r\n#endif\r\n}\r\nstatic void __init mpc85xx_rdb_setup_arch(void)\r\n{\r\n#ifdef CONFIG_QUICC_ENGINE\r\nstruct device_node *np;\r\n#endif\r\nif (ppc_md.progress)\r\nppc_md.progress("mpc85xx_rdb_setup_arch()", 0);\r\nmpc85xx_smp_init();\r\nfsl_pci_assign_primary();\r\n#ifdef CONFIG_QUICC_ENGINE\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!np) {\r\npr_err("%s: Could not find Quicc Engine node\n", __func__);\r\ngoto qe_fail;\r\n}\r\nqe_reset();\r\nof_node_put(np);\r\nnp = of_find_node_by_name(NULL, "par_io");\r\nif (np) {\r\nstruct device_node *ucc;\r\npar_io_init(np);\r\nof_node_put(np);\r\nfor_each_node_by_name(ucc, "ucc")\r\npar_io_of_config(ucc);\r\n}\r\n#if defined(CONFIG_UCC_GETH) || defined(CONFIG_SERIAL_QE)\r\nif (machine_is(p1025_rdb)) {\r\nstruct ccsr_guts __iomem *guts;\r\nnp = of_find_node_by_name(NULL, "global-utilities");\r\nif (np) {\r\nguts = of_iomap(np, 0);\r\nif (!guts) {\r\npr_err("mpc85xx-rdb: could not map global utilities register\n");\r\n} else {\r\nsetbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |\r\nMPC85xx_PMUXCR_QE(3) |\r\nMPC85xx_PMUXCR_QE(9) |\r\nMPC85xx_PMUXCR_QE(12));\r\niounmap(guts);\r\n}\r\nof_node_put(np);\r\n}\r\n}\r\n#endif\r\nqe_fail:\r\n#endif\r\nprintk(KERN_INFO "MPC85xx RDB board from Freescale Semiconductor\n");\r\n}\r\nstatic int __init p2020_rdb_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "fsl,P2020RDB"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init p1020_rdb_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "fsl,P1020RDB"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init p1020_rdb_pc_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "fsl,P1020RDB-PC");\r\n}\r\nstatic int __init p1021_rdb_pc_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "fsl,P1021RDB-PC"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init p2020_rdb_pc_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "fsl,P2020RDB-PC"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init p1025_rdb_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "fsl,P1025RDB");\r\n}\r\nstatic int __init p1020_mbg_pc_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "fsl,P1020MBG-PC");\r\n}\r\nstatic int __init p1020_utm_pc_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "fsl,P1020UTM-PC");\r\n}\r\nstatic int __init p1024_rdb_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "fsl,P1024RDB");\r\n}
