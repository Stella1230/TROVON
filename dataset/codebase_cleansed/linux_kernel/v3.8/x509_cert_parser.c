void x509_free_certificate(struct x509_certificate *cert)\r\n{\r\nif (cert) {\r\npublic_key_destroy(cert->pub);\r\nkfree(cert->issuer);\r\nkfree(cert->subject);\r\nkfree(cert->fingerprint);\r\nkfree(cert->authority);\r\nkfree(cert);\r\n}\r\n}\r\nstruct x509_certificate *x509_cert_parse(const void *data, size_t datalen)\r\n{\r\nstruct x509_certificate *cert;\r\nstruct x509_parse_context *ctx;\r\nlong ret;\r\nret = -ENOMEM;\r\ncert = kzalloc(sizeof(struct x509_certificate), GFP_KERNEL);\r\nif (!cert)\r\ngoto error_no_cert;\r\ncert->pub = kzalloc(sizeof(struct public_key), GFP_KERNEL);\r\nif (!cert->pub)\r\ngoto error_no_ctx;\r\nctx = kzalloc(sizeof(struct x509_parse_context), GFP_KERNEL);\r\nif (!ctx)\r\ngoto error_no_ctx;\r\nctx->cert = cert;\r\nctx->data = (unsigned long)data;\r\nret = asn1_ber_decoder(&x509_decoder, ctx, data, datalen);\r\nif (ret < 0)\r\ngoto error_decode;\r\nret = asn1_ber_decoder(&x509_rsakey_decoder, ctx,\r\nctx->key, ctx->key_size);\r\nif (ret < 0)\r\ngoto error_decode;\r\nkfree(ctx);\r\nreturn cert;\r\nerror_decode:\r\nkfree(ctx);\r\nerror_no_ctx:\r\nx509_free_certificate(cert);\r\nerror_no_cert:\r\nreturn ERR_PTR(ret);\r\n}\r\nint x509_note_OID(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nctx->last_oid = look_up_OID(value, vlen);\r\nif (ctx->last_oid == OID__NR) {\r\nchar buffer[50];\r\nsprint_oid(value, vlen, buffer, sizeof(buffer));\r\npr_debug("Unknown OID: [%lu] %s\n",\r\n(unsigned long)value - ctx->data, buffer);\r\n}\r\nreturn 0;\r\n}\r\nint x509_note_tbs_certificate(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("x509_note_tbs_certificate(,%zu,%02x,%ld,%zu)!\n",\r\nhdrlen, tag, (unsigned long)value - ctx->data, vlen);\r\nctx->cert->tbs = value - hdrlen;\r\nctx->cert->tbs_size = vlen + hdrlen;\r\nreturn 0;\r\n}\r\nint x509_note_pkey_algo(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("PubKey Algo: %u\n", ctx->last_oid);\r\nswitch (ctx->last_oid) {\r\ncase OID_md2WithRSAEncryption:\r\ncase OID_md3WithRSAEncryption:\r\ndefault:\r\nreturn -ENOPKG;\r\ncase OID_md4WithRSAEncryption:\r\nctx->cert->sig_hash_algo = PKEY_HASH_MD5;\r\nctx->cert->sig_pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha1WithRSAEncryption:\r\nctx->cert->sig_hash_algo = PKEY_HASH_SHA1;\r\nctx->cert->sig_pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha256WithRSAEncryption:\r\nctx->cert->sig_hash_algo = PKEY_HASH_SHA256;\r\nctx->cert->sig_pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha384WithRSAEncryption:\r\nctx->cert->sig_hash_algo = PKEY_HASH_SHA384;\r\nctx->cert->sig_pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha512WithRSAEncryption:\r\nctx->cert->sig_hash_algo = PKEY_HASH_SHA512;\r\nctx->cert->sig_pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\ncase OID_sha224WithRSAEncryption:\r\nctx->cert->sig_hash_algo = PKEY_HASH_SHA224;\r\nctx->cert->sig_pkey_algo = PKEY_ALGO_RSA;\r\nbreak;\r\n}\r\nctx->algo_oid = ctx->last_oid;\r\nreturn 0;\r\n}\r\nint x509_note_signature(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\npr_debug("Signature type: %u size %zu\n", ctx->last_oid, vlen);\r\nif (ctx->last_oid != ctx->algo_oid) {\r\npr_warn("Got cert with pkey (%u) and sig (%u) algorithm OIDs\n",\r\nctx->algo_oid, ctx->last_oid);\r\nreturn -EINVAL;\r\n}\r\nctx->cert->sig = value;\r\nctx->cert->sig_size = vlen;\r\nreturn 0;\r\n}\r\nint x509_extract_name_segment(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nswitch (ctx->last_oid) {\r\ncase OID_commonName:\r\nctx->cn_size = vlen;\r\nctx->cn_offset = (unsigned long)value - ctx->data;\r\nbreak;\r\ncase OID_organizationName:\r\nctx->o_size = vlen;\r\nctx->o_offset = (unsigned long)value - ctx->data;\r\nbreak;\r\ncase OID_email_address:\r\nctx->email_size = vlen;\r\nctx->email_offset = (unsigned long)value - ctx->data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int x509_fabricate_name(struct x509_parse_context *ctx, size_t hdrlen,\r\nunsigned char tag,\r\nchar **_name, size_t vlen)\r\n{\r\nconst void *name, *data = (const void *)ctx->data;\r\nsize_t namesize;\r\nchar *buffer;\r\nif (*_name)\r\nreturn -EINVAL;\r\nif (!ctx->cn_size && !ctx->o_size && !ctx->email_size) {\r\nbuffer = kmalloc(1, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = 0;\r\ngoto done;\r\n}\r\nif (ctx->cn_size && ctx->o_size) {\r\nnamesize = ctx->cn_size;\r\nname = data + ctx->cn_offset;\r\nif (ctx->cn_size >= ctx->o_size &&\r\nmemcmp(data + ctx->cn_offset, data + ctx->o_offset,\r\nctx->o_size) == 0)\r\ngoto single_component;\r\nif (ctx->cn_size >= 7 &&\r\nctx->o_size >= 7 &&\r\nmemcmp(data + ctx->cn_offset, data + ctx->o_offset, 7) == 0)\r\ngoto single_component;\r\nbuffer = kmalloc(ctx->o_size + 2 + ctx->cn_size + 1,\r\nGFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemcpy(buffer,\r\ndata + ctx->o_offset, ctx->o_size);\r\nbuffer[ctx->o_size + 0] = ':';\r\nbuffer[ctx->o_size + 1] = ' ';\r\nmemcpy(buffer + ctx->o_size + 2,\r\ndata + ctx->cn_offset, ctx->cn_size);\r\nbuffer[ctx->o_size + 2 + ctx->cn_size] = 0;\r\ngoto done;\r\n} else if (ctx->cn_size) {\r\nnamesize = ctx->cn_size;\r\nname = data + ctx->cn_offset;\r\n} else if (ctx->o_size) {\r\nnamesize = ctx->o_size;\r\nname = data + ctx->o_offset;\r\n} else {\r\nnamesize = ctx->email_size;\r\nname = data + ctx->email_offset;\r\n}\r\nsingle_component:\r\nbuffer = kmalloc(namesize + 1, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemcpy(buffer, name, namesize);\r\nbuffer[namesize] = 0;\r\ndone:\r\n*_name = buffer;\r\nctx->cn_size = 0;\r\nctx->o_size = 0;\r\nctx->email_size = 0;\r\nreturn 0;\r\n}\r\nint x509_note_issuer(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nreturn x509_fabricate_name(ctx, hdrlen, tag, &ctx->cert->issuer, vlen);\r\n}\r\nint x509_note_subject(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nreturn x509_fabricate_name(ctx, hdrlen, tag, &ctx->cert->subject, vlen);\r\n}\r\nint x509_extract_key_data(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nif (ctx->last_oid != OID_rsaEncryption)\r\nreturn -ENOPKG;\r\nctx->cert->pkey_algo = PKEY_ALGO_RSA;\r\nctx->key = value + 1;\r\nctx->key_size = vlen - 1;\r\nreturn 0;\r\n}\r\nint rsa_extract_mpi(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nMPI mpi;\r\nif (ctx->nr_mpi >= ARRAY_SIZE(ctx->cert->pub->mpi)) {\r\npr_err("Too many public key MPIs in certificate\n");\r\nreturn -EBADMSG;\r\n}\r\nmpi = mpi_read_raw_data(value, vlen);\r\nif (!mpi)\r\nreturn -ENOMEM;\r\nctx->cert->pub->mpi[ctx->nr_mpi++] = mpi;\r\nreturn 0;\r\n}\r\nint x509_process_extension(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nconst unsigned char *v = value;\r\nchar *f;\r\nint i;\r\npr_debug("Extension: %u\n", ctx->last_oid);\r\nif (ctx->last_oid == OID_subjectKeyIdentifier) {\r\nif (vlen < 3)\r\nreturn -EBADMSG;\r\nif (v[0] != ASN1_OTS || v[1] != vlen - 2)\r\nreturn -EBADMSG;\r\nv += 2;\r\nvlen -= 2;\r\nf = kmalloc(vlen * 2 + 1, GFP_KERNEL);\r\nif (!f)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < vlen; i++)\r\nsprintf(f + i * 2, "%02x", v[i]);\r\npr_debug("fingerprint %s\n", f);\r\nctx->cert->fingerprint = f;\r\nreturn 0;\r\n}\r\nif (ctx->last_oid == OID_authorityKeyIdentifier) {\r\nif (vlen < 5)\r\nreturn -EBADMSG;\r\nif (v[0] != (ASN1_SEQ | (ASN1_CONS << 5)) ||\r\nv[1] != vlen - 2 ||\r\nv[2] != (ASN1_CONT << 6) ||\r\nv[3] != vlen - 4)\r\nreturn -EBADMSG;\r\nv += 4;\r\nvlen -= 4;\r\nf = kmalloc(vlen * 2 + 1, GFP_KERNEL);\r\nif (!f)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < vlen; i++)\r\nsprintf(f + i * 2, "%02x", v[i]);\r\npr_debug("authority %s\n", f);\r\nctx->cert->authority = f;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int x509_note_time(struct tm *tm, size_t hdrlen,\r\nunsigned char tag,\r\nconst unsigned char *value, size_t vlen)\r\n{\r\nconst unsigned char *p = value;\r\n#define dec2bin(X) ((X) - '0')\r\n#define DD2bin(P) ({ unsigned x = dec2bin(P[0]) * 10 + dec2bin(P[1]); P += 2; x; })\r\nif (tag == ASN1_UNITIM) {\r\nif (vlen != 13)\r\ngoto unsupported_time;\r\ntm->tm_year = DD2bin(p);\r\nif (tm->tm_year >= 50)\r\ntm->tm_year += 1900;\r\nelse\r\ntm->tm_year += 2000;\r\n} else if (tag == ASN1_GENTIM) {\r\nif (vlen != 15)\r\ngoto unsupported_time;\r\ntm->tm_year = DD2bin(p) * 100 + DD2bin(p);\r\n} else {\r\ngoto unsupported_time;\r\n}\r\ntm->tm_year -= 1900;\r\ntm->tm_mon = DD2bin(p) - 1;\r\ntm->tm_mday = DD2bin(p);\r\ntm->tm_hour = DD2bin(p);\r\ntm->tm_min = DD2bin(p);\r\ntm->tm_sec = DD2bin(p);\r\nif (*p != 'Z')\r\ngoto unsupported_time;\r\nreturn 0;\r\nunsupported_time:\r\npr_debug("Got unsupported time [tag %02x]: '%*.*s'\n",\r\ntag, (int)vlen, (int)vlen, value);\r\nreturn -EBADMSG;\r\n}\r\nint x509_note_not_before(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nreturn x509_note_time(&ctx->cert->valid_from, hdrlen, tag, value, vlen);\r\n}\r\nint x509_note_not_after(void *context, size_t hdrlen,\r\nunsigned char tag,\r\nconst void *value, size_t vlen)\r\n{\r\nstruct x509_parse_context *ctx = context;\r\nreturn x509_note_time(&ctx->cert->valid_to, hdrlen, tag, value, vlen);\r\n}
