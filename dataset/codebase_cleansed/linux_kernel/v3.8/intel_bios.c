static void *find_section(struct bdb_header *bdb, int section_id)\r\n{\r\nu8 *base = (u8 *)bdb;\r\nint index = 0;\r\nu16 total, current_size;\r\nu8 current_id;\r\nindex += bdb->header_size;\r\ntotal = bdb->bdb_size;\r\nwhile (index < total) {\r\ncurrent_id = *(base + index);\r\nindex++;\r\ncurrent_size = *((u16 *)(base + index));\r\nindex += 2;\r\nif (current_id == section_id)\r\nreturn base + index;\r\nindex += current_size;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nparse_edp(struct drm_psb_private *dev_priv, struct bdb_header *bdb)\r\n{\r\nstruct bdb_edp *edp;\r\nstruct edp_power_seq *edp_pps;\r\nstruct edp_link_params *edp_link_params;\r\nuint8_t panel_type;\r\nedp = find_section(bdb, BDB_EDP);\r\ndev_priv->edp.bpp = 18;\r\nif (!edp) {\r\nif (dev_priv->edp.support) {\r\nDRM_DEBUG_KMS("No eDP BDB found but eDP panel supported, assume %dbpp panel color depth.\n",\r\ndev_priv->edp.bpp);\r\n}\r\nreturn;\r\n}\r\npanel_type = dev_priv->panel_type;\r\nswitch ((edp->color_depth >> (panel_type * 2)) & 3) {\r\ncase EDP_18BPP:\r\ndev_priv->edp.bpp = 18;\r\nbreak;\r\ncase EDP_24BPP:\r\ndev_priv->edp.bpp = 24;\r\nbreak;\r\ncase EDP_30BPP:\r\ndev_priv->edp.bpp = 30;\r\nbreak;\r\n}\r\nedp_pps = &edp->power_seqs[panel_type];\r\nedp_link_params = &edp->link_params[panel_type];\r\ndev_priv->edp.pps = *edp_pps;\r\nDRM_DEBUG_KMS("EDP timing in vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",\r\ndev_priv->edp.pps.t1_t3, dev_priv->edp.pps.t8,\r\ndev_priv->edp.pps.t9, dev_priv->edp.pps.t10,\r\ndev_priv->edp.pps.t11_t12);\r\ndev_priv->edp.rate = edp_link_params->rate ? DP_LINK_BW_2_7 :\r\nDP_LINK_BW_1_62;\r\nswitch (edp_link_params->lanes) {\r\ncase 0:\r\ndev_priv->edp.lanes = 1;\r\nbreak;\r\ncase 1:\r\ndev_priv->edp.lanes = 2;\r\nbreak;\r\ncase 3:\r\ndefault:\r\ndev_priv->edp.lanes = 4;\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("VBT reports EDP: Lane_count %d, Lane_rate %d, Bpp %d\n",\r\ndev_priv->edp.lanes, dev_priv->edp.rate, dev_priv->edp.bpp);\r\nswitch (edp_link_params->preemphasis) {\r\ncase 0:\r\ndev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_0;\r\nbreak;\r\ncase 1:\r\ndev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_3_5;\r\nbreak;\r\ncase 2:\r\ndev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_6;\r\nbreak;\r\ncase 3:\r\ndev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_9_5;\r\nbreak;\r\n}\r\nswitch (edp_link_params->vswing) {\r\ncase 0:\r\ndev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_400;\r\nbreak;\r\ncase 1:\r\ndev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_600;\r\nbreak;\r\ncase 2:\r\ndev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_800;\r\nbreak;\r\ncase 3:\r\ndev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_1200;\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("VBT reports EDP: VSwing %d, Preemph %d\n",\r\ndev_priv->edp.vswing, dev_priv->edp.preemphasis);\r\n}\r\nstatic u16\r\nget_blocksize(void *p)\r\n{\r\nu16 *block_ptr, block_size;\r\nblock_ptr = (u16 *)((char *)p - 2);\r\nblock_size = *block_ptr;\r\nreturn block_size;\r\n}\r\nstatic void fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode,\r\nstruct lvds_dvo_timing *dvo_timing)\r\n{\r\npanel_fixed_mode->hdisplay = (dvo_timing->hactive_hi << 8) |\r\ndvo_timing->hactive_lo;\r\npanel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay +\r\n((dvo_timing->hsync_off_hi << 8) | dvo_timing->hsync_off_lo);\r\npanel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start +\r\ndvo_timing->hsync_pulse_width;\r\npanel_fixed_mode->htotal = panel_fixed_mode->hdisplay +\r\n((dvo_timing->hblank_hi << 8) | dvo_timing->hblank_lo);\r\npanel_fixed_mode->vdisplay = (dvo_timing->vactive_hi << 8) |\r\ndvo_timing->vactive_lo;\r\npanel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay +\r\ndvo_timing->vsync_off;\r\npanel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start +\r\ndvo_timing->vsync_pulse_width;\r\npanel_fixed_mode->vtotal = panel_fixed_mode->vdisplay +\r\n((dvo_timing->vblank_hi << 8) | dvo_timing->vblank_lo);\r\npanel_fixed_mode->clock = dvo_timing->clock * 10;\r\npanel_fixed_mode->type = DRM_MODE_TYPE_PREFERRED;\r\nif (dvo_timing->hsync_positive)\r\npanel_fixed_mode->flags |= DRM_MODE_FLAG_PHSYNC;\r\nelse\r\npanel_fixed_mode->flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (dvo_timing->vsync_positive)\r\npanel_fixed_mode->flags |= DRM_MODE_FLAG_PVSYNC;\r\nelse\r\npanel_fixed_mode->flags |= DRM_MODE_FLAG_NVSYNC;\r\nif (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal)\r\npanel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;\r\nif (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal)\r\npanel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;\r\ndrm_mode_set_name(panel_fixed_mode);\r\n}\r\nstatic void parse_backlight_data(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct bdb_lvds_backlight *vbt_lvds_bl = NULL;\r\nstruct bdb_lvds_backlight *lvds_bl;\r\nu8 p_type = 0;\r\nvoid *bl_start = NULL;\r\nstruct bdb_lvds_options *lvds_opts\r\n= find_section(bdb, BDB_LVDS_OPTIONS);\r\ndev_priv->lvds_bl = NULL;\r\nif (lvds_opts)\r\np_type = lvds_opts->panel_type;\r\nelse\r\nreturn;\r\nbl_start = find_section(bdb, BDB_LVDS_BACKLIGHT);\r\nvbt_lvds_bl = (struct bdb_lvds_backlight *)(bl_start + 1) + p_type;\r\nlvds_bl = kzalloc(sizeof(*vbt_lvds_bl), GFP_KERNEL);\r\nif (!lvds_bl) {\r\ndev_err(dev_priv->dev->dev, "out of memory for backlight data\n");\r\nreturn;\r\n}\r\nmemcpy(lvds_bl, vbt_lvds_bl, sizeof(*vbt_lvds_bl));\r\ndev_priv->lvds_bl = lvds_bl;\r\n}\r\nstatic void parse_lfp_panel_data(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct bdb_lvds_options *lvds_options;\r\nstruct bdb_lvds_lfp_data *lvds_lfp_data;\r\nstruct bdb_lvds_lfp_data_entry *entry;\r\nstruct lvds_dvo_timing *dvo_timing;\r\nstruct drm_display_mode *panel_fixed_mode;\r\ndev_priv->lvds_dither = 0;\r\ndev_priv->lvds_vbt = 0;\r\nlvds_options = find_section(bdb, BDB_LVDS_OPTIONS);\r\nif (!lvds_options)\r\nreturn;\r\ndev_priv->lvds_dither = lvds_options->pixel_dither;\r\ndev_priv->panel_type = lvds_options->panel_type;\r\nif (lvds_options->panel_type == 0xff)\r\nreturn;\r\nlvds_lfp_data = find_section(bdb, BDB_LVDS_LFP_DATA);\r\nif (!lvds_lfp_data)\r\nreturn;\r\nentry = &lvds_lfp_data->data[lvds_options->panel_type];\r\ndvo_timing = &entry->dvo_timing;\r\npanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode),\r\nGFP_KERNEL);\r\nif (panel_fixed_mode == NULL) {\r\ndev_err(dev_priv->dev->dev, "out of memory for fixed panel mode\n");\r\nreturn;\r\n}\r\ndev_priv->lvds_vbt = 1;\r\nfill_detail_timing_data(panel_fixed_mode, dvo_timing);\r\nif (panel_fixed_mode->htotal > 0 && panel_fixed_mode->vtotal > 0) {\r\ndev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;\r\ndrm_mode_debug_printmodeline(panel_fixed_mode);\r\n} else {\r\ndev_dbg(dev_priv->dev->dev, "ignoring invalid LVDS VBT\n");\r\ndev_priv->lvds_vbt = 0;\r\nkfree(panel_fixed_mode);\r\n}\r\nreturn;\r\n}\r\nstatic void parse_sdvo_panel_data(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct bdb_sdvo_lvds_options *sdvo_lvds_options;\r\nstruct lvds_dvo_timing *dvo_timing;\r\nstruct drm_display_mode *panel_fixed_mode;\r\ndev_priv->sdvo_lvds_vbt_mode = NULL;\r\nsdvo_lvds_options = find_section(bdb, BDB_SDVO_LVDS_OPTIONS);\r\nif (!sdvo_lvds_options)\r\nreturn;\r\ndvo_timing = find_section(bdb, BDB_SDVO_PANEL_DTDS);\r\nif (!dvo_timing)\r\nreturn;\r\npanel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);\r\nif (!panel_fixed_mode)\r\nreturn;\r\nfill_detail_timing_data(panel_fixed_mode,\r\ndvo_timing + sdvo_lvds_options->panel_type);\r\ndev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;\r\nreturn;\r\n}\r\nstatic void parse_general_features(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct bdb_general_features *general;\r\ndev_priv->int_tv_support = 1;\r\ndev_priv->int_crt_support = 1;\r\ngeneral = find_section(bdb, BDB_GENERAL_FEATURES);\r\nif (general) {\r\ndev_priv->int_tv_support = general->int_tv_support;\r\ndev_priv->int_crt_support = general->int_crt_support;\r\ndev_priv->lvds_use_ssc = general->enable_ssc;\r\nif (dev_priv->lvds_use_ssc) {\r\ndev_priv->lvds_ssc_freq\r\n= general->ssc_freq ? 100 : 96;\r\n}\r\n}\r\n}\r\nstatic void\r\nparse_sdvo_device_mapping(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct sdvo_device_mapping *p_mapping;\r\nstruct bdb_general_definitions *p_defs;\r\nstruct child_device_config *p_child;\r\nint i, child_device_num, count;\r\nu16 block_size;\r\np_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);\r\nif (!p_defs) {\r\nDRM_DEBUG_KMS("No general definition block is found, unable to construct sdvo mapping.\n");\r\nreturn;\r\n}\r\nif (p_defs->child_dev_size != sizeof(*p_child)) {\r\nDRM_DEBUG_KMS("different child size is found. Invalid.\n");\r\nreturn;\r\n}\r\nblock_size = get_blocksize(p_defs);\r\nchild_device_num = (block_size - sizeof(*p_defs)) /\r\nsizeof(*p_child);\r\ncount = 0;\r\nfor (i = 0; i < child_device_num; i++) {\r\np_child = &(p_defs->devices[i]);\r\nif (!p_child->device_type) {\r\ncontinue;\r\n}\r\nif (p_child->slave_addr != SLAVE_ADDR1 &&\r\np_child->slave_addr != SLAVE_ADDR2) {\r\ncontinue;\r\n}\r\nif (p_child->dvo_port != DEVICE_PORT_DVOB &&\r\np_child->dvo_port != DEVICE_PORT_DVOC) {\r\nDRM_DEBUG_KMS("Incorrect SDVO port. Skip it\n");\r\ncontinue;\r\n}\r\nDRM_DEBUG_KMS("the SDVO device with slave addr %2x is found on"\r\n" %s port\n",\r\np_child->slave_addr,\r\n(p_child->dvo_port == DEVICE_PORT_DVOB) ?\r\n"SDVOB" : "SDVOC");\r\np_mapping = &(dev_priv->sdvo_mappings[p_child->dvo_port - 1]);\r\nif (!p_mapping->initialized) {\r\np_mapping->dvo_port = p_child->dvo_port;\r\np_mapping->slave_addr = p_child->slave_addr;\r\np_mapping->dvo_wiring = p_child->dvo_wiring;\r\np_mapping->ddc_pin = p_child->ddc_pin;\r\np_mapping->i2c_pin = p_child->i2c_pin;\r\np_mapping->initialized = 1;\r\nDRM_DEBUG_KMS("SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n",\r\np_mapping->dvo_port,\r\np_mapping->slave_addr,\r\np_mapping->dvo_wiring,\r\np_mapping->ddc_pin,\r\np_mapping->i2c_pin);\r\n} else {\r\nDRM_DEBUG_KMS("Maybe one SDVO port is shared by "\r\n"two SDVO device.\n");\r\n}\r\nif (p_child->slave2_addr) {\r\nDRM_DEBUG_KMS("there exists the slave2_addr. Maybe this"\r\n" is a SDVO device with multiple inputs.\n");\r\n}\r\ncount++;\r\n}\r\nif (!count) {\r\nDRM_DEBUG_KMS("No SDVO device info is found in VBT\n");\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nparse_driver_features(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct bdb_driver_features *driver;\r\ndriver = find_section(bdb, BDB_DRIVER_FEATURES);\r\nif (!driver)\r\nreturn;\r\nif (driver->lvds_config == BDB_DRIVER_FEATURE_EDP)\r\ndev_priv->edp.support = 1;\r\nif (driver->primary_lfp_id)\r\ndev_priv->dplla_96mhz = true;\r\nelse\r\ndev_priv->dplla_96mhz = false;\r\n}\r\nstatic void\r\nparse_device_mapping(struct drm_psb_private *dev_priv,\r\nstruct bdb_header *bdb)\r\n{\r\nstruct bdb_general_definitions *p_defs;\r\nstruct child_device_config *p_child, *child_dev_ptr;\r\nint i, child_device_num, count;\r\nu16 block_size;\r\np_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);\r\nif (!p_defs) {\r\nDRM_DEBUG_KMS("No general definition block is found, no devices defined.\n");\r\nreturn;\r\n}\r\nif (p_defs->child_dev_size != sizeof(*p_child)) {\r\nDRM_DEBUG_KMS("different child size is found. Invalid.\n");\r\nreturn;\r\n}\r\nblock_size = get_blocksize(p_defs);\r\nchild_device_num = (block_size - sizeof(*p_defs)) /\r\nsizeof(*p_child);\r\ncount = 0;\r\nfor (i = 0; i < child_device_num; i++) {\r\np_child = &(p_defs->devices[i]);\r\nif (!p_child->device_type) {\r\ncontinue;\r\n}\r\ncount++;\r\n}\r\nif (!count) {\r\nDRM_DEBUG_KMS("no child dev is parsed from VBT\n");\r\nreturn;\r\n}\r\ndev_priv->child_dev = kcalloc(count, sizeof(*p_child), GFP_KERNEL);\r\nif (!dev_priv->child_dev) {\r\nDRM_DEBUG_KMS("No memory space for child devices\n");\r\nreturn;\r\n}\r\ndev_priv->child_dev_num = count;\r\ncount = 0;\r\nfor (i = 0; i < child_device_num; i++) {\r\np_child = &(p_defs->devices[i]);\r\nif (!p_child->device_type) {\r\ncontinue;\r\n}\r\nchild_dev_ptr = dev_priv->child_dev + count;\r\ncount++;\r\nmemcpy((void *)child_dev_ptr, (void *)p_child,\r\nsizeof(*p_child));\r\n}\r\nreturn;\r\n}\r\nint psb_intel_init_bios(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct pci_dev *pdev = dev->pdev;\r\nstruct vbt_header *vbt = NULL;\r\nstruct bdb_header *bdb = NULL;\r\nu8 __iomem *bios = NULL;\r\nsize_t size;\r\nint i;\r\ndev_priv->panel_type = 0xff;\r\nif (dev_priv->opregion.vbt) {\r\nstruct vbt_header *vbt = dev_priv->opregion.vbt;\r\nif (memcmp(vbt->signature, "$VBT", 4) == 0) {\r\nDRM_DEBUG_KMS("Using VBT from OpRegion: %20s\n",\r\nvbt->signature);\r\nbdb = (struct bdb_header *)((char *)vbt + vbt->bdb_offset);\r\n} else\r\ndev_priv->opregion.vbt = NULL;\r\n}\r\nif (bdb == NULL) {\r\nbios = pci_map_rom(pdev, &size);\r\nif (!bios)\r\nreturn -1;\r\nfor (i = 0; i + 4 < size; i++) {\r\nif (!memcmp(bios + i, "$VBT", 4)) {\r\nvbt = (struct vbt_header *)(bios + i);\r\nbreak;\r\n}\r\n}\r\nif (!vbt) {\r\ndev_err(dev->dev, "VBT signature missing\n");\r\npci_unmap_rom(pdev, bios);\r\nreturn -1;\r\n}\r\nbdb = (struct bdb_header *)(bios + i + vbt->bdb_offset);\r\n}\r\nparse_general_features(dev_priv, bdb);\r\nparse_driver_features(dev_priv, bdb);\r\nparse_lfp_panel_data(dev_priv, bdb);\r\nparse_sdvo_panel_data(dev_priv, bdb);\r\nparse_sdvo_device_mapping(dev_priv, bdb);\r\nparse_device_mapping(dev_priv, bdb);\r\nparse_backlight_data(dev_priv, bdb);\r\nparse_edp(dev_priv, bdb);\r\nif (bios)\r\npci_unmap_rom(pdev, bios);\r\nreturn 0;\r\n}\r\nvoid psb_intel_destroy_bios(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nkfree(dev_priv->sdvo_lvds_vbt_mode);\r\nkfree(dev_priv->lfp_lvds_vbt_mode);\r\nkfree(dev_priv->lvds_bl);\r\n}
