static int picolcd_fb_send_tile(struct picolcd_data *data, u8 *vbitmap,\r\nint chip, int tile)\r\n{\r\nstruct hid_report *report1, *report2;\r\nunsigned long flags;\r\nu8 *tdata;\r\nint i;\r\nreport1 = picolcd_out_report(REPORT_LCD_CMD_DATA, data->hdev);\r\nif (!report1 || report1->maxfield != 1)\r\nreturn -ENODEV;\r\nreport2 = picolcd_out_report(REPORT_LCD_DATA, data->hdev);\r\nif (!report2 || report2->maxfield != 1)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&data->lock, flags);\r\nif ((data->status & PICOLCD_FAILED)) {\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn -ENODEV;\r\n}\r\nhid_set_field(report1->field[0], 0, chip << 2);\r\nhid_set_field(report1->field[0], 1, 0x02);\r\nhid_set_field(report1->field[0], 2, 0x00);\r\nhid_set_field(report1->field[0], 3, 0x00);\r\nhid_set_field(report1->field[0], 4, 0xb8 | tile);\r\nhid_set_field(report1->field[0], 5, 0x00);\r\nhid_set_field(report1->field[0], 6, 0x00);\r\nhid_set_field(report1->field[0], 7, 0x40);\r\nhid_set_field(report1->field[0], 8, 0x00);\r\nhid_set_field(report1->field[0], 9, 0x00);\r\nhid_set_field(report1->field[0], 10, 32);\r\nhid_set_field(report2->field[0], 0, (chip << 2) | 0x01);\r\nhid_set_field(report2->field[0], 1, 0x00);\r\nhid_set_field(report2->field[0], 2, 0x00);\r\nhid_set_field(report2->field[0], 3, 32);\r\ntdata = vbitmap + (tile * 4 + chip) * 64;\r\nfor (i = 0; i < 64; i++)\r\nif (i < 32)\r\nhid_set_field(report1->field[0], 11 + i, tdata[i]);\r\nelse\r\nhid_set_field(report2->field[0], 4 + i - 32, tdata[i]);\r\nusbhid_submit_report(data->hdev, report1, USB_DIR_OUT);\r\nusbhid_submit_report(data->hdev, report2, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int picolcd_fb_update_tile(u8 *vbitmap, const u8 *bitmap, int bpp,\r\nint chip, int tile)\r\n{\r\nint i, b, changed = 0;\r\nu8 tdata[64];\r\nu8 *vdata = vbitmap + (tile * 4 + chip) * 64;\r\nif (bpp == 1) {\r\nfor (b = 7; b >= 0; b--) {\r\nconst u8 *bdata = bitmap + tile * 256 + chip * 8 + b * 32;\r\nfor (i = 0; i < 64; i++) {\r\ntdata[i] <<= 1;\r\ntdata[i] |= (bdata[i/8] >> (i % 8)) & 0x01;\r\n}\r\n}\r\n} else if (bpp == 8) {\r\nfor (b = 7; b >= 0; b--) {\r\nconst u8 *bdata = bitmap + (tile * 256 + chip * 8 + b * 32) * 8;\r\nfor (i = 0; i < 64; i++) {\r\ntdata[i] <<= 1;\r\ntdata[i] |= (bdata[i] & 0x80) ? 0x01 : 0x00;\r\n}\r\n}\r\n} else {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 64; i++)\r\nif (tdata[i] != vdata[i]) {\r\nchanged = 1;\r\nvdata[i] = tdata[i];\r\n}\r\nreturn changed;\r\n}\r\nvoid picolcd_fb_refresh(struct picolcd_data *data)\r\n{\r\nif (data->fb_info)\r\nschedule_delayed_work(&data->fb_info->deferred_work, 0);\r\n}\r\nint picolcd_fb_reset(struct picolcd_data *data, int clear)\r\n{\r\nstruct hid_report *report = picolcd_out_report(REPORT_LCD_CMD, data->hdev);\r\nstruct picolcd_fb_data *fbdata = data->fb_info->par;\r\nint i, j;\r\nunsigned long flags;\r\nstatic const u8 mapcmd[8] = { 0x00, 0x02, 0x00, 0x64, 0x3f, 0x00, 0x64, 0xc0 };\r\nif (!report || report->maxfield != 1)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&data->lock, flags);\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < report->field[0]->maxusage; j++)\r\nif (j == 0)\r\nhid_set_field(report->field[0], j, i << 2);\r\nelse if (j < sizeof(mapcmd))\r\nhid_set_field(report->field[0], j, mapcmd[j]);\r\nelse\r\nhid_set_field(report->field[0], j, 0);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nif (clear) {\r\nmemset(fbdata->vbitmap, 0, PICOLCDFB_SIZE);\r\nmemset(fbdata->bitmap, 0, PICOLCDFB_SIZE*fbdata->bpp);\r\n}\r\nfbdata->force = 1;\r\nif (fbdata->ready)\r\nschedule_delayed_work(&data->fb_info->deferred_work, 0);\r\nelse\r\nfbdata->ready = 1;\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_update(struct fb_info *info)\r\n{\r\nint chip, tile, n;\r\nunsigned long flags;\r\nstruct picolcd_fb_data *fbdata = info->par;\r\nstruct picolcd_data *data;\r\nmutex_lock(&info->lock);\r\nspin_lock_irqsave(&fbdata->lock, flags);\r\nif (!fbdata->ready && fbdata->picolcd)\r\npicolcd_fb_reset(fbdata->picolcd, 0);\r\nspin_unlock_irqrestore(&fbdata->lock, flags);\r\nn = 0;\r\nfor (chip = 0; chip < 4; chip++)\r\nfor (tile = 0; tile < 8; tile++) {\r\nif (!fbdata->force && !picolcd_fb_update_tile(\r\nfbdata->vbitmap, fbdata->bitmap,\r\nfbdata->bpp, chip, tile))\r\ncontinue;\r\nn += 2;\r\nif (n >= HID_OUTPUT_FIFO_SIZE / 2) {\r\nspin_lock_irqsave(&fbdata->lock, flags);\r\ndata = fbdata->picolcd;\r\nspin_unlock_irqrestore(&fbdata->lock, flags);\r\nmutex_unlock(&info->lock);\r\nif (!data)\r\nreturn;\r\nusbhid_wait_io(data->hdev);\r\nmutex_lock(&info->lock);\r\nn = 0;\r\n}\r\nspin_lock_irqsave(&fbdata->lock, flags);\r\ndata = fbdata->picolcd;\r\nspin_unlock_irqrestore(&fbdata->lock, flags);\r\nif (!data || picolcd_fb_send_tile(data,\r\nfbdata->vbitmap, chip, tile))\r\ngoto out;\r\n}\r\nfbdata->force = false;\r\nif (n) {\r\nspin_lock_irqsave(&fbdata->lock, flags);\r\ndata = fbdata->picolcd;\r\nspin_unlock_irqrestore(&fbdata->lock, flags);\r\nmutex_unlock(&info->lock);\r\nif (data)\r\nusbhid_wait_io(data->hdev);\r\nreturn;\r\n}\r\nout:\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic void picolcd_fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nif (!info->par)\r\nreturn;\r\nsys_fillrect(info, rect);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\n}\r\nstatic void picolcd_fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nif (!info->par)\r\nreturn;\r\nsys_copyarea(info, area);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\n}\r\nstatic void picolcd_fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nif (!info->par)\r\nreturn;\r\nsys_imageblit(info, image);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\n}\r\nstatic ssize_t picolcd_fb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nif (!info->par)\r\nreturn -ENODEV;\r\nret = fb_sys_write(info, buf, count, ppos);\r\nif (ret >= 0)\r\nschedule_delayed_work(&info->deferred_work, 0);\r\nreturn ret;\r\n}\r\nstatic int picolcd_fb_blank(int blank, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_destroy(struct fb_info *info)\r\n{\r\nstruct picolcd_fb_data *fbdata = info->par;\r\nfb_deferred_io_cleanup(info);\r\nWARN_ON(fbdata->picolcd != NULL);\r\nvfree((u8 *)info->fix.smem_start);\r\nframebuffer_release(info);\r\n}\r\nstatic int picolcd_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\n__u32 bpp = var->bits_per_pixel;\r\n__u32 activate = var->activate;\r\n*var = picolcdfb_var;\r\nvar->activate = activate;\r\nif (bpp >= 8) {\r\nvar->bits_per_pixel = 8;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\n} else {\r\nvar->bits_per_pixel = 1;\r\nvar->red.length = 1;\r\nvar->green.length = 1;\r\nvar->blue.length = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int picolcd_set_par(struct fb_info *info)\r\n{\r\nstruct picolcd_fb_data *fbdata = info->par;\r\nu8 *tmp_fb, *o_fb;\r\nif (info->var.bits_per_pixel == fbdata->bpp)\r\nreturn 0;\r\nif (info->var.bits_per_pixel != 1 && info->var.bits_per_pixel != 8)\r\nreturn -EINVAL;\r\no_fb = fbdata->bitmap;\r\ntmp_fb = kmalloc(PICOLCDFB_SIZE*info->var.bits_per_pixel, GFP_KERNEL);\r\nif (!tmp_fb)\r\nreturn -ENOMEM;\r\nif (info->var.bits_per_pixel == 1) {\r\nint i, b;\r\nfor (i = 0; i < PICOLCDFB_SIZE; i++) {\r\nu8 p = 0;\r\nfor (b = 0; b < 8; b++) {\r\np <<= 1;\r\np |= o_fb[i*8+b] ? 0x01 : 0x00;\r\n}\r\ntmp_fb[i] = p;\r\n}\r\nmemcpy(o_fb, tmp_fb, PICOLCDFB_SIZE);\r\ninfo->fix.visual = FB_VISUAL_MONO01;\r\ninfo->fix.line_length = PICOLCDFB_WIDTH / 8;\r\n} else {\r\nint i;\r\nmemcpy(tmp_fb, o_fb, PICOLCDFB_SIZE);\r\nfor (i = 0; i < PICOLCDFB_SIZE * 8; i++)\r\no_fb[i] = tmp_fb[i/8] & (0x01 << (7 - i % 8)) ? 0xff : 0x00;\r\ninfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\r\ninfo->fix.line_length = PICOLCDFB_WIDTH;\r\n}\r\nkfree(tmp_fb);\r\nfbdata->bpp = info->var.bits_per_pixel;\r\nreturn 0;\r\n}\r\nstatic void picolcd_fb_deferred_io(struct fb_info *info, struct list_head *pagelist)\r\n{\r\npicolcd_fb_update(info);\r\n}\r\nstatic ssize_t picolcd_fb_update_rate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nstruct picolcd_fb_data *fbdata = data->fb_info->par;\r\nunsigned i, fb_update_rate = fbdata->update_rate;\r\nsize_t ret = 0;\r\nfor (i = 1; i <= PICOLCDFB_UPDATE_RATE_LIMIT; i++)\r\nif (ret >= PAGE_SIZE)\r\nbreak;\r\nelse if (i == fb_update_rate)\r\nret += snprintf(buf+ret, PAGE_SIZE-ret, "[%u] ", i);\r\nelse\r\nret += snprintf(buf+ret, PAGE_SIZE-ret, "%u ", i);\r\nif (ret > 0)\r\nbuf[min(ret, (size_t)PAGE_SIZE)-1] = '\n';\r\nreturn ret;\r\n}\r\nstatic ssize_t picolcd_fb_update_rate_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nstruct picolcd_fb_data *fbdata = data->fb_info->par;\r\nint i;\r\nunsigned u;\r\nif (count < 1 || count > 10)\r\nreturn -EINVAL;\r\ni = sscanf(buf, "%u", &u);\r\nif (i != 1)\r\nreturn -EINVAL;\r\nif (u > PICOLCDFB_UPDATE_RATE_LIMIT)\r\nreturn -ERANGE;\r\nelse if (u == 0)\r\nu = PICOLCDFB_UPDATE_RATE_DEFAULT;\r\nfbdata->update_rate = u;\r\ndata->fb_info->fbdefio->delay = HZ / fbdata->update_rate;\r\nreturn count;\r\n}\r\nint picolcd_init_framebuffer(struct picolcd_data *data)\r\n{\r\nstruct device *dev = &data->hdev->dev;\r\nstruct fb_info *info = NULL;\r\nstruct picolcd_fb_data *fbdata = NULL;\r\nint i, error = -ENOMEM;\r\nu32 *palette;\r\ninfo = framebuffer_alloc(256 * sizeof(u32) +\r\nsizeof(struct fb_deferred_io) +\r\nsizeof(struct picolcd_fb_data) +\r\nPICOLCDFB_SIZE, dev);\r\nif (info == NULL) {\r\ndev_err(dev, "failed to allocate a framebuffer\n");\r\ngoto err_nomem;\r\n}\r\ninfo->fbdefio = info->par;\r\n*info->fbdefio = picolcd_fb_defio;\r\ninfo->par += sizeof(struct fb_deferred_io);\r\npalette = info->par;\r\ninfo->par += 256 * sizeof(u32);\r\nfor (i = 0; i < 256; i++)\r\npalette[i] = i > 0 && i < 16 ? 0xff : 0;\r\ninfo->pseudo_palette = palette;\r\ninfo->fbops = &picolcdfb_ops;\r\ninfo->var = picolcdfb_var;\r\ninfo->fix = picolcdfb_fix;\r\ninfo->fix.smem_len = PICOLCDFB_SIZE*8;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\nfbdata = info->par;\r\nspin_lock_init(&fbdata->lock);\r\nfbdata->picolcd = data;\r\nfbdata->update_rate = PICOLCDFB_UPDATE_RATE_DEFAULT;\r\nfbdata->bpp = picolcdfb_var.bits_per_pixel;\r\nfbdata->force = 1;\r\nfbdata->vbitmap = info->par + sizeof(struct picolcd_fb_data);\r\nfbdata->bitmap = vmalloc(PICOLCDFB_SIZE*8);\r\nif (fbdata->bitmap == NULL) {\r\ndev_err(dev, "can't get a free page for framebuffer\n");\r\ngoto err_nomem;\r\n}\r\ninfo->screen_base = (char __force __iomem *)fbdata->bitmap;\r\ninfo->fix.smem_start = (unsigned long)fbdata->bitmap;\r\nmemset(fbdata->vbitmap, 0xff, PICOLCDFB_SIZE);\r\ndata->fb_info = info;\r\nerror = picolcd_fb_reset(data, 1);\r\nif (error) {\r\ndev_err(dev, "failed to configure display\n");\r\ngoto err_cleanup;\r\n}\r\nerror = device_create_file(dev, &dev_attr_fb_update_rate);\r\nif (error) {\r\ndev_err(dev, "failed to create sysfs attributes\n");\r\ngoto err_cleanup;\r\n}\r\nfb_deferred_io_init(info);\r\nerror = register_framebuffer(info);\r\nif (error) {\r\ndev_err(dev, "failed to register framebuffer\n");\r\ngoto err_sysfs;\r\n}\r\nreturn 0;\r\nerr_sysfs:\r\ndevice_remove_file(dev, &dev_attr_fb_update_rate);\r\nfb_deferred_io_cleanup(info);\r\nerr_cleanup:\r\ndata->fb_info = NULL;\r\nerr_nomem:\r\nif (fbdata)\r\nvfree(fbdata->bitmap);\r\nframebuffer_release(info);\r\nreturn error;\r\n}\r\nvoid picolcd_exit_framebuffer(struct picolcd_data *data)\r\n{\r\nstruct fb_info *info = data->fb_info;\r\nstruct picolcd_fb_data *fbdata = info->par;\r\nunsigned long flags;\r\ndevice_remove_file(&data->hdev->dev, &dev_attr_fb_update_rate);\r\nspin_lock_irqsave(&fbdata->lock, flags);\r\nfbdata->picolcd = NULL;\r\nspin_unlock_irqrestore(&fbdata->lock, flags);\r\nflush_delayed_work(&info->deferred_work);\r\ndata->fb_info = NULL;\r\nunregister_framebuffer(info);\r\n}
