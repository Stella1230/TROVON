static int get_slot(struct macvlan_dev *vlan, struct macvtap_queue *q)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_MACVTAP_QUEUES; i++) {\r\nif (rcu_dereference_protected(vlan->taps[i],\r\nlockdep_is_held(&macvtap_lock)) == q)\r\nreturn i;\r\n}\r\nBUG_ON(1);\r\n}\r\nstatic int macvtap_set_queue(struct net_device *dev, struct file *file,\r\nstruct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint index;\r\nint err = -EBUSY;\r\nspin_lock(&macvtap_lock);\r\nif (vlan->numvtaps == MAX_MACVTAP_QUEUES)\r\ngoto out;\r\nerr = 0;\r\nindex = get_slot(vlan, NULL);\r\nrcu_assign_pointer(q->vlan, vlan);\r\nrcu_assign_pointer(vlan->taps[index], q);\r\nsock_hold(&q->sk);\r\nq->file = file;\r\nfile->private_data = q;\r\nvlan->numvtaps++;\r\nout:\r\nspin_unlock(&macvtap_lock);\r\nreturn err;\r\n}\r\nstatic void macvtap_put_queue(struct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan;\r\nspin_lock(&macvtap_lock);\r\nvlan = rcu_dereference_protected(q->vlan,\r\nlockdep_is_held(&macvtap_lock));\r\nif (vlan) {\r\nint index = get_slot(vlan, q);\r\nRCU_INIT_POINTER(vlan->taps[index], NULL);\r\nRCU_INIT_POINTER(q->vlan, NULL);\r\nsock_put(&q->sk);\r\n--vlan->numvtaps;\r\n}\r\nspin_unlock(&macvtap_lock);\r\nsynchronize_rcu();\r\nsock_put(&q->sk);\r\n}\r\nstatic struct macvtap_queue *macvtap_get_queue(struct net_device *dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvtap_queue *tap = NULL;\r\nint numvtaps = vlan->numvtaps;\r\n__u32 rxq;\r\nif (!numvtaps)\r\ngoto out;\r\nrxq = skb_get_rxhash(skb);\r\nif (rxq) {\r\ntap = rcu_dereference(vlan->taps[rxq % numvtaps]);\r\nif (tap)\r\ngoto out;\r\n}\r\nif (likely(skb_rx_queue_recorded(skb))) {\r\nrxq = skb_get_rx_queue(skb);\r\nwhile (unlikely(rxq >= numvtaps))\r\nrxq -= numvtaps;\r\ntap = rcu_dereference(vlan->taps[rxq]);\r\nif (tap)\r\ngoto out;\r\n}\r\nfor (rxq = 0; rxq < MAX_MACVTAP_QUEUES; rxq++) {\r\ntap = rcu_dereference(vlan->taps[rxq]);\r\nif (tap)\r\nbreak;\r\n}\r\nout:\r\nreturn tap;\r\n}\r\nstatic void macvtap_del_queues(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvtap_queue *q, *qlist[MAX_MACVTAP_QUEUES];\r\nint i, j = 0;\r\nspin_lock(&macvtap_lock);\r\nfor (i = 0; i < MAX_MACVTAP_QUEUES && vlan->numvtaps; i++) {\r\nq = rcu_dereference_protected(vlan->taps[i],\r\nlockdep_is_held(&macvtap_lock));\r\nif (q) {\r\nqlist[j++] = q;\r\nRCU_INIT_POINTER(vlan->taps[i], NULL);\r\nRCU_INIT_POINTER(q->vlan, NULL);\r\nvlan->numvtaps--;\r\n}\r\n}\r\nBUG_ON(vlan->numvtaps != 0);\r\nvlan->numvtaps = MAX_MACVTAP_QUEUES;\r\nspin_unlock(&macvtap_lock);\r\nsynchronize_rcu();\r\nfor (--j; j >= 0; j--)\r\nsock_put(&qlist[j]->sk);\r\n}\r\nstatic int macvtap_forward(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct macvtap_queue *q = macvtap_get_queue(dev, skb);\r\nif (!q)\r\ngoto drop;\r\nif (skb_queue_len(&q->sk.sk_receive_queue) >= dev->tx_queue_len)\r\ngoto drop;\r\nskb_queue_tail(&q->sk.sk_receive_queue, skb);\r\nwake_up_interruptible_poll(sk_sleep(&q->sk), POLLIN | POLLRDNORM | POLLRDBAND);\r\nreturn NET_RX_SUCCESS;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int macvtap_receive(struct sk_buff *skb)\r\n{\r\nskb_push(skb, ETH_HLEN);\r\nreturn macvtap_forward(skb->dev, skb);\r\n}\r\nstatic int macvtap_get_minor(struct macvlan_dev *vlan)\r\n{\r\nint retval = -ENOMEM;\r\nint id;\r\nmutex_lock(&minor_lock);\r\nif (idr_pre_get(&minor_idr, GFP_KERNEL) == 0)\r\ngoto exit;\r\nretval = idr_get_new_above(&minor_idr, vlan, 1, &id);\r\nif (retval < 0) {\r\nif (retval == -EAGAIN)\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nif (id < MACVTAP_NUM_DEVS) {\r\nvlan->minor = id;\r\n} else {\r\nprintk(KERN_ERR "too many macvtap devices\n");\r\nretval = -EINVAL;\r\nidr_remove(&minor_idr, id);\r\n}\r\nexit:\r\nmutex_unlock(&minor_lock);\r\nreturn retval;\r\n}\r\nstatic void macvtap_free_minor(struct macvlan_dev *vlan)\r\n{\r\nmutex_lock(&minor_lock);\r\nif (vlan->minor) {\r\nidr_remove(&minor_idr, vlan->minor);\r\nvlan->minor = 0;\r\n}\r\nmutex_unlock(&minor_lock);\r\n}\r\nstatic struct net_device *dev_get_by_macvtap_minor(int minor)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct macvlan_dev *vlan;\r\nmutex_lock(&minor_lock);\r\nvlan = idr_find(&minor_idr, minor);\r\nif (vlan) {\r\ndev = vlan->dev;\r\ndev_hold(dev);\r\n}\r\nmutex_unlock(&minor_lock);\r\nreturn dev;\r\n}\r\nstatic int macvtap_newlink(struct net *src_net,\r\nstruct net_device *dev,\r\nstruct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nreturn macvlan_common_newlink(src_net, dev, tb, data,\r\nmacvtap_receive, macvtap_forward);\r\n}\r\nstatic void macvtap_dellink(struct net_device *dev,\r\nstruct list_head *head)\r\n{\r\nmacvtap_del_queues(dev);\r\nmacvlan_dellink(dev, head);\r\n}\r\nstatic void macvtap_setup(struct net_device *dev)\r\n{\r\nmacvlan_common_setup(dev);\r\ndev->tx_queue_len = TUN_READQ_SIZE;\r\n}\r\nstatic void macvtap_sock_write_space(struct sock *sk)\r\n{\r\nwait_queue_head_t *wqueue;\r\nif (!sock_writeable(sk) ||\r\n!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags))\r\nreturn;\r\nwqueue = sk_sleep(sk);\r\nif (wqueue && waitqueue_active(wqueue))\r\nwake_up_interruptible_poll(wqueue, POLLOUT | POLLWRNORM | POLLWRBAND);\r\n}\r\nstatic void macvtap_sock_destruct(struct sock *sk)\r\n{\r\nskb_queue_purge(&sk->sk_receive_queue);\r\n}\r\nstatic int macvtap_open(struct inode *inode, struct file *file)\r\n{\r\nstruct net *net = current->nsproxy->net_ns;\r\nstruct net_device *dev = dev_get_by_macvtap_minor(iminor(inode));\r\nstruct macvtap_queue *q;\r\nint err;\r\nerr = -ENODEV;\r\nif (!dev)\r\ngoto out;\r\nerr = -ENOMEM;\r\nq = (struct macvtap_queue *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\r\n&macvtap_proto);\r\nif (!q)\r\ngoto out;\r\nq->sock.wq = &q->wq;\r\ninit_waitqueue_head(&q->wq.wait);\r\nq->sock.type = SOCK_RAW;\r\nq->sock.state = SS_CONNECTED;\r\nq->sock.file = file;\r\nq->sock.ops = &macvtap_socket_ops;\r\nsock_init_data(&q->sock, &q->sk);\r\nq->sk.sk_write_space = macvtap_sock_write_space;\r\nq->sk.sk_destruct = macvtap_sock_destruct;\r\nq->flags = IFF_VNET_HDR | IFF_NO_PI | IFF_TAP;\r\nq->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\r\nif ((dev->features & NETIF_F_HIGHDMA) && (dev->features & NETIF_F_SG))\r\nsock_set_flag(&q->sk, SOCK_ZEROCOPY);\r\nerr = macvtap_set_queue(dev, file, q);\r\nif (err)\r\nsock_put(&q->sk);\r\nout:\r\nif (dev)\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nstatic int macvtap_release(struct inode *inode, struct file *file)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nmacvtap_put_queue(q);\r\nreturn 0;\r\n}\r\nstatic unsigned int macvtap_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nunsigned int mask = POLLERR;\r\nif (!q)\r\ngoto out;\r\nmask = 0;\r\npoll_wait(file, &q->wq.wait, wait);\r\nif (!skb_queue_empty(&q->sk.sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (sock_writeable(&q->sk) ||\r\n(!test_and_set_bit(SOCK_ASYNC_NOSPACE, &q->sock.flags) &&\r\nsock_writeable(&q->sk)))\r\nmask |= POLLOUT | POLLWRNORM;\r\nout:\r\nreturn mask;\r\n}\r\nstatic inline struct sk_buff *macvtap_alloc_skb(struct sock *sk, size_t prepad,\r\nsize_t len, size_t linear,\r\nint noblock, int *err)\r\n{\r\nstruct sk_buff *skb;\r\nif (prepad + len < PAGE_SIZE || !linear)\r\nlinear = len;\r\nskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,\r\nerr);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, prepad);\r\nskb_put(skb, linear);\r\nskb->data_len = len - linear;\r\nskb->len += len - linear;\r\nreturn skb;\r\n}\r\nstatic int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\r\nint offset, size_t count)\r\n{\r\nint len = iov_length(from, count) - offset;\r\nint copy = skb_headlen(skb);\r\nint size, offset1 = 0;\r\nint i = 0;\r\nwhile (count && (offset >= from->iov_len)) {\r\noffset -= from->iov_len;\r\n++from;\r\n--count;\r\n}\r\nwhile (count && (copy > 0)) {\r\nsize = min_t(unsigned int, copy, from->iov_len - offset);\r\nif (copy_from_user(skb->data + offset1, from->iov_base + offset,\r\nsize))\r\nreturn -EFAULT;\r\nif (copy > size) {\r\n++from;\r\n--count;\r\noffset = 0;\r\n} else\r\noffset += size;\r\ncopy -= size;\r\noffset1 += size;\r\n}\r\nif (len == offset1)\r\nreturn 0;\r\nwhile (count--) {\r\nstruct page *page[MAX_SKB_FRAGS];\r\nint num_pages;\r\nunsigned long base;\r\nunsigned long truesize;\r\nlen = from->iov_len - offset;\r\nif (!len) {\r\noffset = 0;\r\n++from;\r\ncontinue;\r\n}\r\nbase = (unsigned long)from->iov_base + offset;\r\nsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\r\nif (i + size > MAX_SKB_FRAGS)\r\nreturn -EMSGSIZE;\r\nnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\r\nif (num_pages != size) {\r\nfor (i = 0; i < num_pages; i++)\r\nput_page(page[i]);\r\nreturn -EFAULT;\r\n}\r\ntruesize = size * PAGE_SIZE;\r\nskb->data_len += len;\r\nskb->len += len;\r\nskb->truesize += truesize;\r\natomic_add(truesize, &skb->sk->sk_wmem_alloc);\r\nwhile (len) {\r\nint off = base & ~PAGE_MASK;\r\nint size = min_t(int, len, PAGE_SIZE - off);\r\n__skb_fill_page_desc(skb, i, page[i], off, size);\r\nskb_shinfo(skb)->nr_frags++;\r\nbase += size;\r\nlen -= size;\r\ni++;\r\n}\r\noffset = 0;\r\n++from;\r\n}\r\nreturn 0;\r\n}\r\nstatic int macvtap_skb_from_vnet_hdr(struct sk_buff *skb,\r\nstruct virtio_net_hdr *vnet_hdr)\r\n{\r\nunsigned short gso_type = 0;\r\nif (vnet_hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\r\nswitch (vnet_hdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\r\ncase VIRTIO_NET_HDR_GSO_TCPV4:\r\ngso_type = SKB_GSO_TCPV4;\r\nbreak;\r\ncase VIRTIO_NET_HDR_GSO_TCPV6:\r\ngso_type = SKB_GSO_TCPV6;\r\nbreak;\r\ncase VIRTIO_NET_HDR_GSO_UDP:\r\ngso_type = SKB_GSO_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (vnet_hdr->gso_type & VIRTIO_NET_HDR_GSO_ECN)\r\ngso_type |= SKB_GSO_TCP_ECN;\r\nif (vnet_hdr->gso_size == 0)\r\nreturn -EINVAL;\r\n}\r\nif (vnet_hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\r\nif (!skb_partial_csum_set(skb, vnet_hdr->csum_start,\r\nvnet_hdr->csum_offset))\r\nreturn -EINVAL;\r\n}\r\nif (vnet_hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\r\nskb_shinfo(skb)->gso_size = vnet_hdr->gso_size;\r\nskb_shinfo(skb)->gso_type = gso_type;\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\r\nskb_shinfo(skb)->gso_segs = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int macvtap_skb_to_vnet_hdr(const struct sk_buff *skb,\r\nstruct virtio_net_hdr *vnet_hdr)\r\n{\r\nmemset(vnet_hdr, 0, sizeof(*vnet_hdr));\r\nif (skb_is_gso(skb)) {\r\nstruct skb_shared_info *sinfo = skb_shinfo(skb);\r\nvnet_hdr->hdr_len = skb_headlen(skb);\r\nvnet_hdr->gso_size = sinfo->gso_size;\r\nif (sinfo->gso_type & SKB_GSO_TCPV4)\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\r\nelse if (sinfo->gso_type & SKB_GSO_TCPV6)\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\r\nelse if (sinfo->gso_type & SKB_GSO_UDP)\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_UDP;\r\nelse\r\nBUG();\r\nif (sinfo->gso_type & SKB_GSO_TCP_ECN)\r\nvnet_hdr->gso_type |= VIRTIO_NET_HDR_GSO_ECN;\r\n} else\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nvnet_hdr->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\r\nvnet_hdr->csum_start = skb_checksum_start_offset(skb);\r\nvnet_hdr->csum_offset = skb->csum_offset;\r\n} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {\r\nvnet_hdr->flags = VIRTIO_NET_HDR_F_DATA_VALID;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\r\nconst struct iovec *iv, unsigned long total_len,\r\nsize_t count, int noblock)\r\n{\r\nstruct sk_buff *skb;\r\nstruct macvlan_dev *vlan;\r\nunsigned long len = total_len;\r\nint err;\r\nstruct virtio_net_hdr vnet_hdr = { 0 };\r\nint vnet_hdr_len = 0;\r\nint copylen = 0;\r\nbool zerocopy = false;\r\nif (q->flags & IFF_VNET_HDR) {\r\nvnet_hdr_len = q->vnet_hdr_sz;\r\nerr = -EINVAL;\r\nif (len < vnet_hdr_len)\r\ngoto err;\r\nlen -= vnet_hdr_len;\r\nerr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\r\nsizeof(vnet_hdr));\r\nif (err < 0)\r\ngoto err;\r\nif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\r\nvnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\r\nvnet_hdr.hdr_len)\r\nvnet_hdr.hdr_len = vnet_hdr.csum_start +\r\nvnet_hdr.csum_offset + 2;\r\nerr = -EINVAL;\r\nif (vnet_hdr.hdr_len > len)\r\ngoto err;\r\n}\r\nerr = -EINVAL;\r\nif (unlikely(len < ETH_HLEN))\r\ngoto err;\r\nerr = -EMSGSIZE;\r\nif (unlikely(count > UIO_MAXIOV))\r\ngoto err;\r\nif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\r\nzerocopy = true;\r\nif (zerocopy) {\r\nif (count > MAX_SKB_FRAGS) {\r\ncopylen = iov_length(iv, count - MAX_SKB_FRAGS);\r\nif (copylen < vnet_hdr_len)\r\ncopylen = 0;\r\nelse\r\ncopylen -= vnet_hdr_len;\r\n}\r\nif (copylen < vnet_hdr.hdr_len)\r\ncopylen = vnet_hdr.hdr_len;\r\nif (!copylen)\r\ncopylen = GOODCOPY_LEN;\r\n} else\r\ncopylen = len;\r\nskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\r\nvnet_hdr.hdr_len, noblock, &err);\r\nif (!skb)\r\ngoto err;\r\nif (zerocopy)\r\nerr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\r\nelse\r\nerr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\r\nlen);\r\nif (err)\r\ngoto err_kfree;\r\nskb_set_network_header(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = eth_hdr(skb)->h_proto;\r\nif (vnet_hdr_len) {\r\nerr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\r\nif (err)\r\ngoto err_kfree;\r\n}\r\nrcu_read_lock_bh();\r\nvlan = rcu_dereference_bh(q->vlan);\r\nif (zerocopy) {\r\nskb_shinfo(skb)->destructor_arg = m->msg_control;\r\nskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\r\n}\r\nif (vlan)\r\nmacvlan_start_xmit(skb, vlan->dev);\r\nelse\r\nkfree_skb(skb);\r\nrcu_read_unlock_bh();\r\nreturn total_len;\r\nerr_kfree:\r\nkfree_skb(skb);\r\nerr:\r\nrcu_read_lock_bh();\r\nvlan = rcu_dereference_bh(q->vlan);\r\nif (vlan)\r\nvlan->dev->stats.tx_dropped++;\r\nrcu_read_unlock_bh();\r\nreturn err;\r\n}\r\nstatic ssize_t macvtap_aio_write(struct kiocb *iocb, const struct iovec *iv,\r\nunsigned long count, loff_t pos)\r\n{\r\nstruct file *file = iocb->ki_filp;\r\nssize_t result = -ENOLINK;\r\nstruct macvtap_queue *q = file->private_data;\r\nresult = macvtap_get_user(q, NULL, iv, iov_length(iv, count), count,\r\nfile->f_flags & O_NONBLOCK);\r\nreturn result;\r\n}\r\nstatic ssize_t macvtap_put_user(struct macvtap_queue *q,\r\nconst struct sk_buff *skb,\r\nconst struct iovec *iv, int len)\r\n{\r\nstruct macvlan_dev *vlan;\r\nint ret;\r\nint vnet_hdr_len = 0;\r\nint vlan_offset = 0;\r\nint copied;\r\nif (q->flags & IFF_VNET_HDR) {\r\nstruct virtio_net_hdr vnet_hdr;\r\nvnet_hdr_len = q->vnet_hdr_sz;\r\nif ((len -= vnet_hdr_len) < 0)\r\nreturn -EINVAL;\r\nret = macvtap_skb_to_vnet_hdr(skb, &vnet_hdr);\r\nif (ret)\r\nreturn ret;\r\nif (memcpy_toiovecend(iv, (void *)&vnet_hdr, 0, sizeof(vnet_hdr)))\r\nreturn -EFAULT;\r\n}\r\ncopied = vnet_hdr_len;\r\nif (!vlan_tx_tag_present(skb))\r\nlen = min_t(int, skb->len, len);\r\nelse {\r\nint copy;\r\nstruct {\r\n__be16 h_vlan_proto;\r\n__be16 h_vlan_TCI;\r\n} veth;\r\nveth.h_vlan_proto = htons(ETH_P_8021Q);\r\nveth.h_vlan_TCI = htons(vlan_tx_tag_get(skb));\r\nvlan_offset = offsetof(struct vlan_ethhdr, h_vlan_proto);\r\nlen = min_t(int, skb->len + VLAN_HLEN, len);\r\ncopy = min_t(int, vlan_offset, len);\r\nret = skb_copy_datagram_const_iovec(skb, 0, iv, copied, copy);\r\nlen -= copy;\r\ncopied += copy;\r\nif (ret || !len)\r\ngoto done;\r\ncopy = min_t(int, sizeof(veth), len);\r\nret = memcpy_toiovecend(iv, (void *)&veth, copied, copy);\r\nlen -= copy;\r\ncopied += copy;\r\nif (ret || !len)\r\ngoto done;\r\n}\r\nret = skb_copy_datagram_const_iovec(skb, vlan_offset, iv, copied, len);\r\ncopied += len;\r\ndone:\r\nrcu_read_lock_bh();\r\nvlan = rcu_dereference_bh(q->vlan);\r\nif (vlan)\r\nmacvlan_count_rx(vlan, copied - vnet_hdr_len, ret == 0, 0);\r\nrcu_read_unlock_bh();\r\nreturn ret ? ret : copied;\r\n}\r\nstatic ssize_t macvtap_do_read(struct macvtap_queue *q, struct kiocb *iocb,\r\nconst struct iovec *iv, unsigned long len,\r\nint noblock)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct sk_buff *skb;\r\nssize_t ret = 0;\r\nwhile (len) {\r\nprepare_to_wait(sk_sleep(&q->sk), &wait, TASK_INTERRUPTIBLE);\r\nskb = skb_dequeue(&q->sk.sk_receive_queue);\r\nif (!skb) {\r\nif (noblock) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\ncontinue;\r\n}\r\nret = macvtap_put_user(q, skb, iv, len);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(&q->sk), &wait);\r\nreturn ret;\r\n}\r\nstatic ssize_t macvtap_aio_read(struct kiocb *iocb, const struct iovec *iv,\r\nunsigned long count, loff_t pos)\r\n{\r\nstruct file *file = iocb->ki_filp;\r\nstruct macvtap_queue *q = file->private_data;\r\nssize_t len, ret = 0;\r\nlen = iov_length(iv, count);\r\nif (len < 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = macvtap_do_read(q, iocb, iv, len, file->f_flags & O_NONBLOCK);\r\nret = min_t(ssize_t, ret, len);\r\nout:\r\nreturn ret;\r\n}\r\nstatic long macvtap_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nstruct macvlan_dev *vlan;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct ifreq __user *ifr = argp;\r\nunsigned int __user *up = argp;\r\nunsigned int u;\r\nint __user *sp = argp;\r\nint s;\r\nint ret;\r\nswitch (cmd) {\r\ncase TUNSETIFF:\r\nif (get_user(u, &ifr->ifr_flags))\r\nreturn -EFAULT;\r\nret = 0;\r\nif ((u & ~IFF_VNET_HDR) != (IFF_NO_PI | IFF_TAP))\r\nret = -EINVAL;\r\nelse\r\nq->flags = u;\r\nreturn ret;\r\ncase TUNGETIFF:\r\nrcu_read_lock_bh();\r\nvlan = rcu_dereference_bh(q->vlan);\r\nif (vlan)\r\ndev_hold(vlan->dev);\r\nrcu_read_unlock_bh();\r\nif (!vlan)\r\nreturn -ENOLINK;\r\nret = 0;\r\nif (copy_to_user(&ifr->ifr_name, vlan->dev->name, IFNAMSIZ) ||\r\nput_user(q->flags, &ifr->ifr_flags))\r\nret = -EFAULT;\r\ndev_put(vlan->dev);\r\nreturn ret;\r\ncase TUNGETFEATURES:\r\nif (put_user(IFF_TAP | IFF_NO_PI | IFF_VNET_HDR, up))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TUNSETSNDBUF:\r\nif (get_user(u, up))\r\nreturn -EFAULT;\r\nq->sk.sk_sndbuf = u;\r\nreturn 0;\r\ncase TUNGETVNETHDRSZ:\r\ns = q->vnet_hdr_sz;\r\nif (put_user(s, sp))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TUNSETVNETHDRSZ:\r\nif (get_user(s, sp))\r\nreturn -EFAULT;\r\nif (s < (int)sizeof(struct virtio_net_hdr))\r\nreturn -EINVAL;\r\nq->vnet_hdr_sz = s;\r\nreturn 0;\r\ncase TUNSETOFFLOAD:\r\nif (arg & ~(TUN_F_CSUM | TUN_F_TSO4 | TUN_F_TSO6 |\r\nTUN_F_TSO_ECN | TUN_F_UFO))\r\nreturn -EINVAL;\r\nif (!(q->flags & IFF_VNET_HDR))\r\nreturn -EINVAL;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic long macvtap_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn macvtap_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int macvtap_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *m, size_t total_len)\r\n{\r\nstruct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);\r\nreturn macvtap_get_user(q, m, m->msg_iov, total_len, m->msg_iovlen,\r\nm->msg_flags & MSG_DONTWAIT);\r\n}\r\nstatic int macvtap_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *m, size_t total_len,\r\nint flags)\r\n{\r\nstruct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);\r\nint ret;\r\nif (flags & ~(MSG_DONTWAIT|MSG_TRUNC))\r\nreturn -EINVAL;\r\nret = macvtap_do_read(q, iocb, m->msg_iov, total_len,\r\nflags & MSG_DONTWAIT);\r\nif (ret > total_len) {\r\nm->msg_flags |= MSG_TRUNC;\r\nret = flags & MSG_TRUNC ? ret : total_len;\r\n}\r\nreturn ret;\r\n}\r\nstruct socket *macvtap_get_socket(struct file *file)\r\n{\r\nstruct macvtap_queue *q;\r\nif (file->f_op != &macvtap_fops)\r\nreturn ERR_PTR(-EINVAL);\r\nq = file->private_data;\r\nif (!q)\r\nreturn ERR_PTR(-EBADFD);\r\nreturn &q->sock;\r\n}\r\nstatic int macvtap_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstruct macvlan_dev *vlan;\r\nstruct device *classdev;\r\ndev_t devt;\r\nint err;\r\nif (dev->rtnl_link_ops != &macvtap_link_ops)\r\nreturn NOTIFY_DONE;\r\nvlan = netdev_priv(dev);\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\nerr = macvtap_get_minor(vlan);\r\nif (err)\r\nreturn notifier_from_errno(err);\r\ndevt = MKDEV(MAJOR(macvtap_major), vlan->minor);\r\nclassdev = device_create(macvtap_class, &dev->dev, devt,\r\ndev, "tap%d", dev->ifindex);\r\nif (IS_ERR(classdev)) {\r\nmacvtap_free_minor(vlan);\r\nreturn notifier_from_errno(PTR_ERR(classdev));\r\n}\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\ndevt = MKDEV(MAJOR(macvtap_major), vlan->minor);\r\ndevice_destroy(macvtap_class, devt);\r\nmacvtap_free_minor(vlan);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int macvtap_init(void)\r\n{\r\nint err;\r\nerr = alloc_chrdev_region(&macvtap_major, 0,\r\nMACVTAP_NUM_DEVS, "macvtap");\r\nif (err)\r\ngoto out1;\r\ncdev_init(&macvtap_cdev, &macvtap_fops);\r\nerr = cdev_add(&macvtap_cdev, macvtap_major, MACVTAP_NUM_DEVS);\r\nif (err)\r\ngoto out2;\r\nmacvtap_class = class_create(THIS_MODULE, "macvtap");\r\nif (IS_ERR(macvtap_class)) {\r\nerr = PTR_ERR(macvtap_class);\r\ngoto out3;\r\n}\r\nerr = register_netdevice_notifier(&macvtap_notifier_block);\r\nif (err)\r\ngoto out4;\r\nerr = macvlan_link_register(&macvtap_link_ops);\r\nif (err)\r\ngoto out5;\r\nreturn 0;\r\nout5:\r\nunregister_netdevice_notifier(&macvtap_notifier_block);\r\nout4:\r\nclass_unregister(macvtap_class);\r\nout3:\r\ncdev_del(&macvtap_cdev);\r\nout2:\r\nunregister_chrdev_region(macvtap_major, MACVTAP_NUM_DEVS);\r\nout1:\r\nreturn err;\r\n}\r\nstatic void macvtap_exit(void)\r\n{\r\nrtnl_link_unregister(&macvtap_link_ops);\r\nunregister_netdevice_notifier(&macvtap_notifier_block);\r\nclass_unregister(macvtap_class);\r\ncdev_del(&macvtap_cdev);\r\nunregister_chrdev_region(macvtap_major, MACVTAP_NUM_DEVS);\r\n}
