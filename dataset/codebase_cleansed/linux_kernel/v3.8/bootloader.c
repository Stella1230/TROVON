static void\r\ncons_write (const char *buf)\r\n{\r\nunsigned long ch;\r\nwhile ((ch = *buf++) != '\0') {\r\nssc(ch, 0, 0, 0, SSC_PUTCHAR);\r\nif (ch == '\n')\r\nssc('\r', 0, 0, 0, SSC_PUTCHAR);\r\n}\r\n}\r\nvoid\r\nstart_bootloader (void)\r\n{\r\nstatic char mem[4096];\r\nstatic char buffer[1024];\r\nunsigned long off;\r\nint fd, i;\r\nstruct disk_req req;\r\nstruct disk_stat stat;\r\nstruct elfhdr *elf;\r\nstruct elf_phdr *elf_phdr;\r\nunsigned long e_entry, e_phoff, e_phnum;\r\nregister struct ia64_boot_param *bp;\r\nchar *kpath, *args;\r\nlong arglen = 0;\r\nssc(0, 0, 0, 0, SSC_CONSOLE_INIT);\r\narglen = ssc((long) buffer, 0, 0, 0, SSC_GET_ARGS);\r\nkpath = "vmlinux";\r\nargs = buffer;\r\nif (arglen > 0) {\r\nkpath = buffer;\r\nwhile (*args != ' ' && *args != '\0')\r\n++args, --arglen;\r\nif (*args == ' ')\r\n*args++ = '\0', --arglen;\r\n}\r\nif (arglen <= 0) {\r\nargs = "";\r\narglen = 1;\r\n}\r\nfd = ssc((long) kpath, 1, 0, 0, SSC_OPEN);\r\nif (fd < 0) {\r\ncons_write(kpath);\r\ncons_write(": file not found, reboot now\n");\r\nfor(;;);\r\n}\r\nstat.fd = fd;\r\noff = 0;\r\nreq.len = sizeof(mem);\r\nreq.addr = (long) mem;\r\nssc(fd, 1, (long) &req, off, SSC_READ);\r\nssc((long) &stat, 0, 0, 0, SSC_WAIT_COMPLETION);\r\nelf = (struct elfhdr *) mem;\r\nif (elf->e_ident[0] == 0x7f && strncmp(elf->e_ident + 1, "ELF", 3) != 0) {\r\ncons_write("not an ELF file\n");\r\nreturn;\r\n}\r\nif (elf->e_type != ET_EXEC) {\r\ncons_write("not an ELF executable\n");\r\nreturn;\r\n}\r\nif (!elf_check_arch(elf)) {\r\ncons_write("kernel not for this processor\n");\r\nreturn;\r\n}\r\ne_entry = elf->e_entry;\r\ne_phnum = elf->e_phnum;\r\ne_phoff = elf->e_phoff;\r\ncons_write("loading ");\r\ncons_write(kpath);\r\ncons_write("...\n");\r\nfor (i = 0; i < e_phnum; ++i) {\r\nreq.len = sizeof(*elf_phdr);\r\nreq.addr = (long) mem;\r\nssc(fd, 1, (long) &req, e_phoff, SSC_READ);\r\nssc((long) &stat, 0, 0, 0, SSC_WAIT_COMPLETION);\r\nif (stat.count != sizeof(*elf_phdr)) {\r\ncons_write("failed to read phdr\n");\r\nreturn;\r\n}\r\ne_phoff += sizeof(*elf_phdr);\r\nelf_phdr = (struct elf_phdr *) mem;\r\nif (elf_phdr->p_type != PT_LOAD)\r\ncontinue;\r\nreq.len = elf_phdr->p_filesz;\r\nreq.addr = __pa(elf_phdr->p_paddr);\r\nssc(fd, 1, (long) &req, elf_phdr->p_offset, SSC_READ);\r\nssc((long) &stat, 0, 0, 0, SSC_WAIT_COMPLETION);\r\nmemset((char *)__pa(elf_phdr->p_paddr) + elf_phdr->p_filesz, 0,\r\nelf_phdr->p_memsz - elf_phdr->p_filesz);\r\n}\r\nssc(fd, 0, 0, 0, SSC_CLOSE);\r\ncons_write("starting kernel...\n");\r\nia64_setreg(_IA64_REG_AR_KR0, 0xffffc000000UL);\r\nbp = sys_fw_init(args, arglen);\r\nssc(0, (long) kpath, 0, 0, SSC_LOAD_SYMBOLS);\r\ndebug_break();\r\njmp_to_kernel((unsigned long) bp, e_entry);\r\ncons_write("kernel returned!\n");\r\nssc(-1, 0, 0, 0, SSC_EXIT);\r\n}
