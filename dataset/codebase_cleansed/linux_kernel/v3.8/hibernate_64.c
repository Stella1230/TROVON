static int res_phys_pud_init(pud_t *pud, unsigned long address, unsigned long end)\r\n{\r\nlong i, j;\r\ni = pud_index(address);\r\npud = pud + i;\r\nfor (; i < PTRS_PER_PUD; pud++, i++) {\r\nunsigned long paddr;\r\npmd_t *pmd;\r\npaddr = address + i*PUD_SIZE;\r\nif (paddr >= end)\r\nbreak;\r\npmd = (pmd_t *)get_safe_page(GFP_ATOMIC);\r\nif (!pmd)\r\nreturn -ENOMEM;\r\nset_pud(pud, __pud(__pa(pmd) | _KERNPG_TABLE));\r\nfor (j = 0; j < PTRS_PER_PMD; pmd++, j++, paddr += PMD_SIZE) {\r\nunsigned long pe;\r\nif (paddr >= end)\r\nbreak;\r\npe = __PAGE_KERNEL_LARGE_EXEC | paddr;\r\npe &= __supported_pte_mask;\r\nset_pmd(pmd, __pmd(pe));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_up_temporary_mappings(void)\r\n{\r\nunsigned long start, end, next;\r\nint error;\r\ntemp_level4_pgt = (pgd_t *)get_safe_page(GFP_ATOMIC);\r\nif (!temp_level4_pgt)\r\nreturn -ENOMEM;\r\nset_pgd(temp_level4_pgt + pgd_index(__START_KERNEL_map),\r\ninit_level4_pgt[pgd_index(__START_KERNEL_map)]);\r\nstart = (unsigned long)pfn_to_kaddr(0);\r\nend = (unsigned long)pfn_to_kaddr(max_pfn);\r\nfor (; start < end; start = next) {\r\npud_t *pud = (pud_t *)get_safe_page(GFP_ATOMIC);\r\nif (!pud)\r\nreturn -ENOMEM;\r\nnext = start + PGDIR_SIZE;\r\nif (next > end)\r\nnext = end;\r\nif ((error = res_phys_pud_init(pud, __pa(start), __pa(next))))\r\nreturn error;\r\nset_pgd(temp_level4_pgt + pgd_index(start),\r\nmk_kernel_pgd(__pa(pud)));\r\n}\r\nreturn 0;\r\n}\r\nint swsusp_arch_resume(void)\r\n{\r\nint error;\r\nif ((error = set_up_temporary_mappings()))\r\nreturn error;\r\nrelocated_restore_code = (void *)get_safe_page(GFP_ATOMIC);\r\nif (!relocated_restore_code)\r\nreturn -ENOMEM;\r\nmemcpy(relocated_restore_code, &core_restore_code,\r\n&restore_registers - &core_restore_code);\r\nrestore_image();\r\nreturn 0;\r\n}\r\nint pfn_is_nosave(unsigned long pfn)\r\n{\r\nunsigned long nosave_begin_pfn = __pa_symbol(&__nosave_begin) >> PAGE_SHIFT;\r\nunsigned long nosave_end_pfn = PAGE_ALIGN(__pa_symbol(&__nosave_end)) >> PAGE_SHIFT;\r\nreturn (pfn >= nosave_begin_pfn) && (pfn < nosave_end_pfn);\r\n}\r\nint arch_hibernation_header_save(void *addr, unsigned int max_size)\r\n{\r\nstruct restore_data_record *rdr = addr;\r\nif (max_size < sizeof(struct restore_data_record))\r\nreturn -EOVERFLOW;\r\nrdr->jump_address = restore_jump_address;\r\nrdr->cr3 = restore_cr3;\r\nrdr->magic = RESTORE_MAGIC;\r\nreturn 0;\r\n}\r\nint arch_hibernation_header_restore(void *addr)\r\n{\r\nstruct restore_data_record *rdr = addr;\r\nrestore_jump_address = rdr->jump_address;\r\nrestore_cr3 = rdr->cr3;\r\nreturn (rdr->magic == RESTORE_MAGIC) ? 0 : -EINVAL;\r\n}
