void\r\nfcbuild_init(void)\r\n{\r\nfc_els_req_tmpl.routing = FC_RTG_EXT_LINK;\r\nfc_els_req_tmpl.cat_info = FC_CAT_LD_REQUEST;\r\nfc_els_req_tmpl.type = FC_TYPE_ELS;\r\nfc_els_req_tmpl.f_ctl =\r\nbfa_hton3b(FCTL_SEQ_INI | FCTL_FS_EXCH | FCTL_END_SEQ |\r\nFCTL_SI_XFER);\r\nfc_els_req_tmpl.rx_id = FC_RXID_ANY;\r\nfc_els_rsp_tmpl.routing = FC_RTG_EXT_LINK;\r\nfc_els_rsp_tmpl.cat_info = FC_CAT_LD_REPLY;\r\nfc_els_rsp_tmpl.type = FC_TYPE_ELS;\r\nfc_els_rsp_tmpl.f_ctl =\r\nbfa_hton3b(FCTL_EC_RESP | FCTL_SEQ_INI | FCTL_LS_EXCH |\r\nFCTL_END_SEQ | FCTL_SI_XFER);\r\nfc_els_rsp_tmpl.rx_id = FC_RXID_ANY;\r\nfc_bls_req_tmpl.routing = FC_RTG_BASIC_LINK;\r\nfc_bls_req_tmpl.type = FC_TYPE_BLS;\r\nfc_bls_req_tmpl.f_ctl = bfa_hton3b(FCTL_END_SEQ | FCTL_SI_XFER);\r\nfc_bls_req_tmpl.rx_id = FC_RXID_ANY;\r\nfc_bls_rsp_tmpl.routing = FC_RTG_BASIC_LINK;\r\nfc_bls_rsp_tmpl.cat_info = FC_CAT_BA_ACC;\r\nfc_bls_rsp_tmpl.type = FC_TYPE_BLS;\r\nfc_bls_rsp_tmpl.f_ctl =\r\nbfa_hton3b(FCTL_EC_RESP | FCTL_SEQ_INI | FCTL_LS_EXCH |\r\nFCTL_END_SEQ | FCTL_SI_XFER);\r\nfc_bls_rsp_tmpl.rx_id = FC_RXID_ANY;\r\nba_acc_tmpl.seq_id_valid = 0;\r\nba_acc_tmpl.low_seq_cnt = 0;\r\nba_acc_tmpl.high_seq_cnt = 0xFFFF;\r\nplogi_tmpl.csp.verhi = FC_PH_VER_PH_3;\r\nplogi_tmpl.csp.verlo = FC_PH_VER_4_3;\r\nplogi_tmpl.csp.ciro = 0x1;\r\nplogi_tmpl.csp.cisc = 0x0;\r\nplogi_tmpl.csp.altbbcred = 0x0;\r\nplogi_tmpl.csp.conseq = cpu_to_be16(0x00FF);\r\nplogi_tmpl.csp.ro_bitmap = cpu_to_be16(0x0002);\r\nplogi_tmpl.csp.e_d_tov = cpu_to_be32(2000);\r\nplogi_tmpl.class3.class_valid = 1;\r\nplogi_tmpl.class3.sequential = 1;\r\nplogi_tmpl.class3.conseq = 0xFF;\r\nplogi_tmpl.class3.ospx = 1;\r\nprli_tmpl.command = FC_ELS_PRLI;\r\nprli_tmpl.pglen = 0x10;\r\nprli_tmpl.pagebytes = cpu_to_be16(0x0014);\r\nprli_tmpl.parampage.type = FC_TYPE_FCP;\r\nprli_tmpl.parampage.imagepair = 1;\r\nprli_tmpl.parampage.servparams.rxrdisab = 1;\r\nrrq_tmpl.els_cmd.els_code = FC_ELS_RRQ;\r\nfcp_fchs_tmpl.routing = FC_RTG_FC4_DEV_DATA;\r\nfcp_fchs_tmpl.cat_info = FC_CAT_UNSOLICIT_CMD;\r\nfcp_fchs_tmpl.type = FC_TYPE_FCP;\r\nfcp_fchs_tmpl.f_ctl =\r\nbfa_hton3b(FCTL_FS_EXCH | FCTL_END_SEQ | FCTL_SI_XFER);\r\nfcp_fchs_tmpl.seq_id = 1;\r\nfcp_fchs_tmpl.rx_id = FC_RXID_ANY;\r\n}\r\nstatic void\r\nfc_gs_fchdr_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u32 ox_id)\r\n{\r\nmemset(fchs, 0, sizeof(struct fchs_s));\r\nfchs->routing = FC_RTG_FC4_DEV_DATA;\r\nfchs->cat_info = FC_CAT_UNSOLICIT_CTRL;\r\nfchs->type = FC_TYPE_SERVICES;\r\nfchs->f_ctl =\r\nbfa_hton3b(FCTL_SEQ_INI | FCTL_FS_EXCH | FCTL_END_SEQ |\r\nFCTL_SI_XFER);\r\nfchs->rx_id = FC_RXID_ANY;\r\nfchs->d_id = (d_id);\r\nfchs->s_id = (s_id);\r\nfchs->ox_id = cpu_to_be16(ox_id);\r\n}\r\nstatic void\r\nfc_gsresp_fchdr_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)\r\n{\r\nmemset(fchs, 0, sizeof(struct fchs_s));\r\nfchs->routing = FC_RTG_FC4_DEV_DATA;\r\nfchs->cat_info = FC_CAT_SOLICIT_CTRL;\r\nfchs->type = FC_TYPE_SERVICES;\r\nfchs->f_ctl =\r\nbfa_hton3b(FCTL_EC_RESP | FCTL_SEQ_INI | FCTL_LS_EXCH |\r\nFCTL_END_SEQ | FCTL_SI_XFER);\r\nfchs->d_id = d_id;\r\nfchs->s_id = s_id;\r\nfchs->ox_id = ox_id;\r\n}\r\nvoid\r\nfc_els_req_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id)\r\n{\r\nmemcpy(fchs, &fc_els_req_tmpl, sizeof(struct fchs_s));\r\nfchs->d_id = (d_id);\r\nfchs->s_id = (s_id);\r\nfchs->ox_id = cpu_to_be16(ox_id);\r\n}\r\nstatic void\r\nfc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id)\r\n{\r\nmemcpy(fchs, &fc_els_rsp_tmpl, sizeof(struct fchs_s));\r\nfchs->d_id = d_id;\r\nfchs->s_id = s_id;\r\nfchs->ox_id = ox_id;\r\n}\r\nenum fc_parse_status\r\nfc_els_rsp_parse(struct fchs_s *fchs, int len)\r\n{\r\nstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\r\nstruct fc_ls_rjt_s *ls_rjt = (struct fc_ls_rjt_s *) els_cmd;\r\nlen = len;\r\nswitch (els_cmd->els_code) {\r\ncase FC_ELS_LS_RJT:\r\nif (ls_rjt->reason_code == FC_LS_RJT_RSN_LOGICAL_BUSY)\r\nreturn FC_PARSE_BUSY;\r\nelse\r\nreturn FC_PARSE_FAILURE;\r\ncase FC_ELS_ACC:\r\nreturn FC_PARSE_OK;\r\n}\r\nreturn FC_PARSE_OK;\r\n}\r\nstatic void\r\nfc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id)\r\n{\r\nmemcpy(fchs, &fc_bls_rsp_tmpl, sizeof(struct fchs_s));\r\nfchs->d_id = d_id;\r\nfchs->s_id = s_id;\r\nfchs->ox_id = ox_id;\r\n}\r\nstatic u16\r\nfc_plogi_x_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\r\n__be16 ox_id, wwn_t port_name, wwn_t node_name,\r\nu16 pdu_size, u16 bb_cr, u8 els_code)\r\n{\r\nstruct fc_logi_s *plogi = (struct fc_logi_s *) (pld);\r\nmemcpy(plogi, &plogi_tmpl, sizeof(struct fc_logi_s));\r\nif (!bb_cr)\r\nplogi->csp.altbbcred = 1;\r\nplogi->els_cmd.els_code = els_code;\r\nif (els_code == FC_ELS_PLOGI)\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nelse\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nplogi->csp.rxsz = plogi->class3.rxsz = cpu_to_be16(pdu_size);\r\nplogi->csp.bbcred = cpu_to_be16(bb_cr);\r\nmemcpy(&plogi->port_name, &port_name, sizeof(wwn_t));\r\nmemcpy(&plogi->node_name, &node_name, sizeof(wwn_t));\r\nreturn sizeof(struct fc_logi_s);\r\n}\r\nu16\r\nfc_flogi_build(struct fchs_s *fchs, struct fc_logi_s *flogi, u32 s_id,\r\nu16 ox_id, wwn_t port_name, wwn_t node_name, u16 pdu_size,\r\nu8 set_npiv, u8 set_auth, u16 local_bb_credits)\r\n{\r\nu32 d_id = bfa_hton3b(FC_FABRIC_PORT);\r\n__be32 *vvl_info;\r\nmemcpy(flogi, &plogi_tmpl, sizeof(struct fc_logi_s));\r\nflogi->els_cmd.els_code = FC_ELS_FLOGI;\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nflogi->csp.rxsz = flogi->class3.rxsz = cpu_to_be16(pdu_size);\r\nflogi->port_name = port_name;\r\nflogi->node_name = node_name;\r\nflogi->csp.ciro = set_npiv;\r\nflogi->csp.security = set_auth;\r\nflogi->csp.bbcred = cpu_to_be16(local_bb_credits);\r\nvvl_info = (u32 *)&flogi->vvl[0];\r\nflogi->csp.npiv_supp = 1;\r\nvvl_info[0] = cpu_to_be32(FLOGI_VVL_BRCD);\r\nreturn sizeof(struct fc_logi_s);\r\n}\r\nu16\r\nfc_flogi_acc_build(struct fchs_s *fchs, struct fc_logi_s *flogi, u32 s_id,\r\n__be16 ox_id, wwn_t port_name, wwn_t node_name,\r\nu16 pdu_size, u16 local_bb_credits, u8 bb_scn)\r\n{\r\nu32 d_id = 0;\r\nu16 bbscn_rxsz = (bb_scn << 12) | pdu_size;\r\nmemcpy(flogi, &plogi_tmpl, sizeof(struct fc_logi_s));\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nflogi->els_cmd.els_code = FC_ELS_ACC;\r\nflogi->class3.rxsz = cpu_to_be16(pdu_size);\r\nflogi->csp.rxsz = cpu_to_be16(bbscn_rxsz);\r\nflogi->port_name = port_name;\r\nflogi->node_name = node_name;\r\nflogi->csp.bbcred = cpu_to_be16(local_bb_credits);\r\nreturn sizeof(struct fc_logi_s);\r\n}\r\nu16\r\nfc_fdisc_build(struct fchs_s *fchs, struct fc_logi_s *flogi, u32 s_id,\r\nu16 ox_id, wwn_t port_name, wwn_t node_name, u16 pdu_size)\r\n{\r\nu32 d_id = bfa_hton3b(FC_FABRIC_PORT);\r\nmemcpy(flogi, &plogi_tmpl, sizeof(struct fc_logi_s));\r\nflogi->els_cmd.els_code = FC_ELS_FDISC;\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nflogi->csp.rxsz = flogi->class3.rxsz = cpu_to_be16(pdu_size);\r\nflogi->port_name = port_name;\r\nflogi->node_name = node_name;\r\nreturn sizeof(struct fc_logi_s);\r\n}\r\nu16\r\nfc_plogi_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\r\nu16 ox_id, wwn_t port_name, wwn_t node_name,\r\nu16 pdu_size, u16 bb_cr)\r\n{\r\nreturn fc_plogi_x_build(fchs, pld, d_id, s_id, ox_id, port_name,\r\nnode_name, pdu_size, bb_cr, FC_ELS_PLOGI);\r\n}\r\nu16\r\nfc_plogi_acc_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\r\nu16 ox_id, wwn_t port_name, wwn_t node_name,\r\nu16 pdu_size, u16 bb_cr)\r\n{\r\nreturn fc_plogi_x_build(fchs, pld, d_id, s_id, ox_id, port_name,\r\nnode_name, pdu_size, bb_cr, FC_ELS_ACC);\r\n}\r\nenum fc_parse_status\r\nfc_plogi_rsp_parse(struct fchs_s *fchs, int len, wwn_t port_name)\r\n{\r\nstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\r\nstruct fc_logi_s *plogi;\r\nstruct fc_ls_rjt_s *ls_rjt;\r\nswitch (els_cmd->els_code) {\r\ncase FC_ELS_LS_RJT:\r\nls_rjt = (struct fc_ls_rjt_s *) (fchs + 1);\r\nif (ls_rjt->reason_code == FC_LS_RJT_RSN_LOGICAL_BUSY)\r\nreturn FC_PARSE_BUSY;\r\nelse\r\nreturn FC_PARSE_FAILURE;\r\ncase FC_ELS_ACC:\r\nplogi = (struct fc_logi_s *) (fchs + 1);\r\nif (len < sizeof(struct fc_logi_s))\r\nreturn FC_PARSE_FAILURE;\r\nif (!wwn_is_equal(plogi->port_name, port_name))\r\nreturn FC_PARSE_FAILURE;\r\nif (!plogi->class3.class_valid)\r\nreturn FC_PARSE_FAILURE;\r\nif (be16_to_cpu(plogi->class3.rxsz) < (FC_MIN_PDUSZ))\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\ndefault:\r\nreturn FC_PARSE_FAILURE;\r\n}\r\n}\r\nenum fc_parse_status\r\nfc_plogi_parse(struct fchs_s *fchs)\r\n{\r\nstruct fc_logi_s *plogi = (struct fc_logi_s *) (fchs + 1);\r\nif (plogi->class3.class_valid != 1)\r\nreturn FC_PARSE_FAILURE;\r\nif ((be16_to_cpu(plogi->class3.rxsz) < FC_MIN_PDUSZ)\r\n|| (be16_to_cpu(plogi->class3.rxsz) > FC_MAX_PDUSZ)\r\n|| (plogi->class3.rxsz == 0))\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_prli_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\r\nu16 ox_id)\r\n{\r\nstruct fc_prli_s *prli = (struct fc_prli_s *) (pld);\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemcpy(prli, &prli_tmpl, sizeof(struct fc_prli_s));\r\nprli->command = FC_ELS_PRLI;\r\nprli->parampage.servparams.initiator = 1;\r\nprli->parampage.servparams.retry = 1;\r\nprli->parampage.servparams.rec_support = 1;\r\nprli->parampage.servparams.task_retry_id = 0;\r\nprli->parampage.servparams.confirm = 1;\r\nreturn sizeof(struct fc_prli_s);\r\n}\r\nu16\r\nfc_prli_acc_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\r\n__be16 ox_id, enum bfa_lport_role role)\r\n{\r\nstruct fc_prli_s *prli = (struct fc_prli_s *) (pld);\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemcpy(prli, &prli_tmpl, sizeof(struct fc_prli_s));\r\nprli->command = FC_ELS_ACC;\r\nprli->parampage.servparams.initiator = 1;\r\nprli->parampage.rspcode = FC_PRLI_ACC_XQTD;\r\nreturn sizeof(struct fc_prli_s);\r\n}\r\nenum fc_parse_status\r\nfc_prli_rsp_parse(struct fc_prli_s *prli, int len)\r\n{\r\nif (len < sizeof(struct fc_prli_s))\r\nreturn FC_PARSE_FAILURE;\r\nif (prli->command != FC_ELS_ACC)\r\nreturn FC_PARSE_FAILURE;\r\nif ((prli->parampage.rspcode != FC_PRLI_ACC_XQTD)\r\n&& (prli->parampage.rspcode != FC_PRLI_ACC_PREDEF_IMG))\r\nreturn FC_PARSE_FAILURE;\r\nif (prli->parampage.servparams.target != 1)\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nenum fc_parse_status\r\nfc_prli_parse(struct fc_prli_s *prli)\r\n{\r\nif (prli->parampage.type != FC_TYPE_FCP)\r\nreturn FC_PARSE_FAILURE;\r\nif (!prli->parampage.imagepair)\r\nreturn FC_PARSE_FAILURE;\r\nif (!prli->parampage.servparams.initiator)\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_logo_build(struct fchs_s *fchs, struct fc_logo_s *logo, u32 d_id, u32 s_id,\r\nu16 ox_id, wwn_t port_name)\r\n{\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemset(logo, '\0', sizeof(struct fc_logo_s));\r\nlogo->els_cmd.els_code = FC_ELS_LOGO;\r\nlogo->nport_id = (s_id);\r\nlogo->orig_port_name = port_name;\r\nreturn sizeof(struct fc_logo_s);\r\n}\r\nstatic u16\r\nfc_adisc_x_build(struct fchs_s *fchs, struct fc_adisc_s *adisc, u32 d_id,\r\nu32 s_id, __be16 ox_id, wwn_t port_name,\r\nwwn_t node_name, u8 els_code)\r\n{\r\nmemset(adisc, '\0', sizeof(struct fc_adisc_s));\r\nadisc->els_cmd.els_code = els_code;\r\nif (els_code == FC_ELS_ADISC)\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nelse\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nadisc->orig_HA = 0;\r\nadisc->orig_port_name = port_name;\r\nadisc->orig_node_name = node_name;\r\nadisc->nport_id = (s_id);\r\nreturn sizeof(struct fc_adisc_s);\r\n}\r\nu16\r\nfc_adisc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc, u32 d_id,\r\nu32 s_id, __be16 ox_id, wwn_t port_name, wwn_t node_name)\r\n{\r\nreturn fc_adisc_x_build(fchs, adisc, d_id, s_id, ox_id, port_name,\r\nnode_name, FC_ELS_ADISC);\r\n}\r\nu16\r\nfc_adisc_acc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc, u32 d_id,\r\nu32 s_id, __be16 ox_id, wwn_t port_name,\r\nwwn_t node_name)\r\n{\r\nreturn fc_adisc_x_build(fchs, adisc, d_id, s_id, ox_id, port_name,\r\nnode_name, FC_ELS_ACC);\r\n}\r\nenum fc_parse_status\r\nfc_adisc_rsp_parse(struct fc_adisc_s *adisc, int len, wwn_t port_name,\r\nwwn_t node_name)\r\n{\r\nif (len < sizeof(struct fc_adisc_s))\r\nreturn FC_PARSE_FAILURE;\r\nif (adisc->els_cmd.els_code != FC_ELS_ACC)\r\nreturn FC_PARSE_FAILURE;\r\nif (!wwn_is_equal(adisc->orig_port_name, port_name))\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nenum fc_parse_status\r\nfc_adisc_parse(struct fchs_s *fchs, void *pld, u32 host_dap, wwn_t node_name,\r\nwwn_t port_name)\r\n{\r\nstruct fc_adisc_s *adisc = (struct fc_adisc_s *) pld;\r\nif (adisc->els_cmd.els_code != FC_ELS_ACC)\r\nreturn FC_PARSE_FAILURE;\r\nif ((adisc->nport_id == (host_dap))\r\n&& wwn_is_equal(adisc->orig_port_name, port_name)\r\n&& wwn_is_equal(adisc->orig_node_name, node_name))\r\nreturn FC_PARSE_OK;\r\nreturn FC_PARSE_FAILURE;\r\n}\r\nenum fc_parse_status\r\nfc_pdisc_parse(struct fchs_s *fchs, wwn_t node_name, wwn_t port_name)\r\n{\r\nstruct fc_logi_s *pdisc = (struct fc_logi_s *) (fchs + 1);\r\nif (pdisc->class3.class_valid != 1)\r\nreturn FC_PARSE_FAILURE;\r\nif ((be16_to_cpu(pdisc->class3.rxsz) <\r\n(FC_MIN_PDUSZ - sizeof(struct fchs_s)))\r\n|| (pdisc->class3.rxsz == 0))\r\nreturn FC_PARSE_FAILURE;\r\nif (!wwn_is_equal(pdisc->port_name, port_name))\r\nreturn FC_PARSE_FAILURE;\r\nif (!wwn_is_equal(pdisc->node_name, node_name))\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_abts_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)\r\n{\r\nmemcpy(fchs, &fc_bls_req_tmpl, sizeof(struct fchs_s));\r\nfchs->cat_info = FC_CAT_ABTS;\r\nfchs->d_id = (d_id);\r\nfchs->s_id = (s_id);\r\nfchs->ox_id = cpu_to_be16(ox_id);\r\nreturn sizeof(struct fchs_s);\r\n}\r\nenum fc_parse_status\r\nfc_abts_rsp_parse(struct fchs_s *fchs, int len)\r\n{\r\nif ((fchs->cat_info == FC_CAT_BA_ACC)\r\n|| (fchs->cat_info == FC_CAT_BA_RJT))\r\nreturn FC_PARSE_OK;\r\nreturn FC_PARSE_FAILURE;\r\n}\r\nu16\r\nfc_rrq_build(struct fchs_s *fchs, struct fc_rrq_s *rrq, u32 d_id, u32 s_id,\r\nu16 ox_id, u16 rrq_oxid)\r\n{\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemcpy(rrq, &rrq_tmpl, sizeof(struct fc_rrq_s));\r\nrrq->s_id = (s_id);\r\nrrq->ox_id = cpu_to_be16(rrq_oxid);\r\nrrq->rx_id = FC_RXID_ANY;\r\nreturn sizeof(struct fc_rrq_s);\r\n}\r\nu16\r\nfc_logo_acc_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\r\n__be16 ox_id)\r\n{\r\nstruct fc_els_cmd_s *acc = pld;\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemset(acc, 0, sizeof(struct fc_els_cmd_s));\r\nacc->els_code = FC_ELS_ACC;\r\nreturn sizeof(struct fc_els_cmd_s);\r\n}\r\nu16\r\nfc_ls_rjt_build(struct fchs_s *fchs, struct fc_ls_rjt_s *ls_rjt, u32 d_id,\r\nu32 s_id, __be16 ox_id, u8 reason_code,\r\nu8 reason_code_expl)\r\n{\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemset(ls_rjt, 0, sizeof(struct fc_ls_rjt_s));\r\nls_rjt->els_cmd.els_code = FC_ELS_LS_RJT;\r\nls_rjt->reason_code = reason_code;\r\nls_rjt->reason_code_expl = reason_code_expl;\r\nls_rjt->vendor_unique = 0x00;\r\nreturn sizeof(struct fc_ls_rjt_s);\r\n}\r\nu16\r\nfc_ba_acc_build(struct fchs_s *fchs, struct fc_ba_acc_s *ba_acc, u32 d_id,\r\nu32 s_id, __be16 ox_id, u16 rx_id)\r\n{\r\nfc_bls_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemcpy(ba_acc, &ba_acc_tmpl, sizeof(struct fc_ba_acc_s));\r\nfchs->rx_id = rx_id;\r\nba_acc->ox_id = fchs->ox_id;\r\nba_acc->rx_id = fchs->rx_id;\r\nreturn sizeof(struct fc_ba_acc_s);\r\n}\r\nu16\r\nfc_ls_acc_build(struct fchs_s *fchs, struct fc_els_cmd_s *els_cmd, u32 d_id,\r\nu32 s_id, __be16 ox_id)\r\n{\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemset(els_cmd, 0, sizeof(struct fc_els_cmd_s));\r\nels_cmd->els_code = FC_ELS_ACC;\r\nreturn sizeof(struct fc_els_cmd_s);\r\n}\r\nint\r\nfc_logout_params_pages(struct fchs_s *fc_frame, u8 els_code)\r\n{\r\nint num_pages = 0;\r\nstruct fc_prlo_s *prlo;\r\nstruct fc_tprlo_s *tprlo;\r\nif (els_code == FC_ELS_PRLO) {\r\nprlo = (struct fc_prlo_s *) (fc_frame + 1);\r\nnum_pages = (be16_to_cpu(prlo->payload_len) - 4) / 16;\r\n} else {\r\ntprlo = (struct fc_tprlo_s *) (fc_frame + 1);\r\nnum_pages = (be16_to_cpu(tprlo->payload_len) - 4) / 16;\r\n}\r\nreturn num_pages;\r\n}\r\nu16\r\nfc_tprlo_acc_build(struct fchs_s *fchs, struct fc_tprlo_acc_s *tprlo_acc,\r\nu32 d_id, u32 s_id, __be16 ox_id, int num_pages)\r\n{\r\nint page;\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemset(tprlo_acc, 0, (num_pages * 16) + 4);\r\ntprlo_acc->command = FC_ELS_ACC;\r\ntprlo_acc->page_len = 0x10;\r\ntprlo_acc->payload_len = cpu_to_be16((num_pages * 16) + 4);\r\nfor (page = 0; page < num_pages; page++) {\r\ntprlo_acc->tprlo_acc_params[page].opa_valid = 0;\r\ntprlo_acc->tprlo_acc_params[page].rpa_valid = 0;\r\ntprlo_acc->tprlo_acc_params[page].fc4type_csp = FC_TYPE_FCP;\r\ntprlo_acc->tprlo_acc_params[page].orig_process_assc = 0;\r\ntprlo_acc->tprlo_acc_params[page].resp_process_assc = 0;\r\n}\r\nreturn be16_to_cpu(tprlo_acc->payload_len);\r\n}\r\nu16\r\nfc_prlo_acc_build(struct fchs_s *fchs, struct fc_prlo_acc_s *prlo_acc, u32 d_id,\r\nu32 s_id, __be16 ox_id, int num_pages)\r\n{\r\nint page;\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nmemset(prlo_acc, 0, (num_pages * 16) + 4);\r\nprlo_acc->command = FC_ELS_ACC;\r\nprlo_acc->page_len = 0x10;\r\nprlo_acc->payload_len = cpu_to_be16((num_pages * 16) + 4);\r\nfor (page = 0; page < num_pages; page++) {\r\nprlo_acc->prlo_acc_params[page].opa_valid = 0;\r\nprlo_acc->prlo_acc_params[page].rpa_valid = 0;\r\nprlo_acc->prlo_acc_params[page].fc4type_csp = FC_TYPE_FCP;\r\nprlo_acc->prlo_acc_params[page].orig_process_assc = 0;\r\nprlo_acc->prlo_acc_params[page].resp_process_assc = 0;\r\n}\r\nreturn be16_to_cpu(prlo_acc->payload_len);\r\n}\r\nu16\r\nfc_rnid_build(struct fchs_s *fchs, struct fc_rnid_cmd_s *rnid, u32 d_id,\r\nu32 s_id, u16 ox_id, u32 data_format)\r\n{\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemset(rnid, 0, sizeof(struct fc_rnid_cmd_s));\r\nrnid->els_cmd.els_code = FC_ELS_RNID;\r\nrnid->node_id_data_format = data_format;\r\nreturn sizeof(struct fc_rnid_cmd_s);\r\n}\r\nu16\r\nfc_rnid_acc_build(struct fchs_s *fchs, struct fc_rnid_acc_s *rnid_acc, u32 d_id,\r\nu32 s_id, __be16 ox_id, u32 data_format,\r\nstruct fc_rnid_common_id_data_s *common_id_data,\r\nstruct fc_rnid_general_topology_data_s *gen_topo_data)\r\n{\r\nmemset(rnid_acc, 0, sizeof(struct fc_rnid_acc_s));\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nrnid_acc->els_cmd.els_code = FC_ELS_ACC;\r\nrnid_acc->node_id_data_format = data_format;\r\nrnid_acc->common_id_data_length =\r\nsizeof(struct fc_rnid_common_id_data_s);\r\nrnid_acc->common_id_data = *common_id_data;\r\nif (data_format == RNID_NODEID_DATA_FORMAT_DISCOVERY) {\r\nrnid_acc->specific_id_data_length =\r\nsizeof(struct fc_rnid_general_topology_data_s);\r\nrnid_acc->gen_topology_data = *gen_topo_data;\r\nreturn sizeof(struct fc_rnid_acc_s);\r\n} else {\r\nreturn sizeof(struct fc_rnid_acc_s) -\r\nsizeof(struct fc_rnid_general_topology_data_s);\r\n}\r\n}\r\nu16\r\nfc_rpsc_build(struct fchs_s *fchs, struct fc_rpsc_cmd_s *rpsc, u32 d_id,\r\nu32 s_id, u16 ox_id)\r\n{\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemset(rpsc, 0, sizeof(struct fc_rpsc_cmd_s));\r\nrpsc->els_cmd.els_code = FC_ELS_RPSC;\r\nreturn sizeof(struct fc_rpsc_cmd_s);\r\n}\r\nu16\r\nfc_rpsc2_build(struct fchs_s *fchs, struct fc_rpsc2_cmd_s *rpsc2, u32 d_id,\r\nu32 s_id, u32 *pid_list, u16 npids)\r\n{\r\nu32 dctlr_id = FC_DOMAIN_CTRLR(bfa_hton3b(d_id));\r\nint i = 0;\r\nfc_els_req_build(fchs, bfa_hton3b(dctlr_id), s_id, 0);\r\nmemset(rpsc2, 0, sizeof(struct fc_rpsc2_cmd_s));\r\nrpsc2->els_cmd.els_code = FC_ELS_RPSC;\r\nrpsc2->token = cpu_to_be32(FC_BRCD_TOKEN);\r\nrpsc2->num_pids = cpu_to_be16(npids);\r\nfor (i = 0; i < npids; i++)\r\nrpsc2->pid_list[i].pid = pid_list[i];\r\nreturn sizeof(struct fc_rpsc2_cmd_s) + ((npids - 1) * (sizeof(u32)));\r\n}\r\nu16\r\nfc_rpsc_acc_build(struct fchs_s *fchs, struct fc_rpsc_acc_s *rpsc_acc,\r\nu32 d_id, u32 s_id, __be16 ox_id,\r\nstruct fc_rpsc_speed_info_s *oper_speed)\r\n{\r\nmemset(rpsc_acc, 0, sizeof(struct fc_rpsc_acc_s));\r\nfc_els_rsp_build(fchs, d_id, s_id, ox_id);\r\nrpsc_acc->command = FC_ELS_ACC;\r\nrpsc_acc->num_entries = cpu_to_be16(1);\r\nrpsc_acc->speed_info[0].port_speed_cap =\r\ncpu_to_be16(oper_speed->port_speed_cap);\r\nrpsc_acc->speed_info[0].port_op_speed =\r\ncpu_to_be16(oper_speed->port_op_speed);\r\nreturn sizeof(struct fc_rpsc_acc_s);\r\n}\r\nu16\r\nfc_logo_rsp_parse(struct fchs_s *fchs, int len)\r\n{\r\nstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\r\nlen = len;\r\nif (els_cmd->els_code != FC_ELS_ACC)\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_pdisc_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id,\r\nwwn_t port_name, wwn_t node_name, u16 pdu_size)\r\n{\r\nstruct fc_logi_s *pdisc = (struct fc_logi_s *) (fchs + 1);\r\nmemcpy(pdisc, &plogi_tmpl, sizeof(struct fc_logi_s));\r\npdisc->els_cmd.els_code = FC_ELS_PDISC;\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\npdisc->csp.rxsz = pdisc->class3.rxsz = cpu_to_be16(pdu_size);\r\npdisc->port_name = port_name;\r\npdisc->node_name = node_name;\r\nreturn sizeof(struct fc_logi_s);\r\n}\r\nu16\r\nfc_pdisc_rsp_parse(struct fchs_s *fchs, int len, wwn_t port_name)\r\n{\r\nstruct fc_logi_s *pdisc = (struct fc_logi_s *) (fchs + 1);\r\nif (len < sizeof(struct fc_logi_s))\r\nreturn FC_PARSE_LEN_INVAL;\r\nif (pdisc->els_cmd.els_code != FC_ELS_ACC)\r\nreturn FC_PARSE_ACC_INVAL;\r\nif (!wwn_is_equal(pdisc->port_name, port_name))\r\nreturn FC_PARSE_PWWN_NOT_EQUAL;\r\nif (!pdisc->class3.class_valid)\r\nreturn FC_PARSE_NWWN_NOT_EQUAL;\r\nif (be16_to_cpu(pdisc->class3.rxsz) < (FC_MIN_PDUSZ))\r\nreturn FC_PARSE_RXSZ_INVAL;\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_prlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id,\r\nint num_pages)\r\n{\r\nstruct fc_prlo_s *prlo = (struct fc_prlo_s *) (fchs + 1);\r\nint page;\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemset(prlo, 0, (num_pages * 16) + 4);\r\nprlo->command = FC_ELS_PRLO;\r\nprlo->page_len = 0x10;\r\nprlo->payload_len = cpu_to_be16((num_pages * 16) + 4);\r\nfor (page = 0; page < num_pages; page++) {\r\nprlo->prlo_params[page].type = FC_TYPE_FCP;\r\nprlo->prlo_params[page].opa_valid = 0;\r\nprlo->prlo_params[page].rpa_valid = 0;\r\nprlo->prlo_params[page].orig_process_assc = 0;\r\nprlo->prlo_params[page].resp_process_assc = 0;\r\n}\r\nreturn be16_to_cpu(prlo->payload_len);\r\n}\r\nu16\r\nfc_prlo_rsp_parse(struct fchs_s *fchs, int len)\r\n{\r\nstruct fc_prlo_acc_s *prlo = (struct fc_prlo_acc_s *) (fchs + 1);\r\nint num_pages = 0;\r\nint page = 0;\r\nlen = len;\r\nif (prlo->command != FC_ELS_ACC)\r\nreturn FC_PARSE_FAILURE;\r\nnum_pages = ((be16_to_cpu(prlo->payload_len)) - 4) / 16;\r\nfor (page = 0; page < num_pages; page++) {\r\nif (prlo->prlo_acc_params[page].type != FC_TYPE_FCP)\r\nreturn FC_PARSE_FAILURE;\r\nif (prlo->prlo_acc_params[page].opa_valid != 0)\r\nreturn FC_PARSE_FAILURE;\r\nif (prlo->prlo_acc_params[page].rpa_valid != 0)\r\nreturn FC_PARSE_FAILURE;\r\nif (prlo->prlo_acc_params[page].orig_process_assc != 0)\r\nreturn FC_PARSE_FAILURE;\r\nif (prlo->prlo_acc_params[page].resp_process_assc != 0)\r\nreturn FC_PARSE_FAILURE;\r\n}\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_tprlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id,\r\nint num_pages, enum fc_tprlo_type tprlo_type, u32 tpr_id)\r\n{\r\nstruct fc_tprlo_s *tprlo = (struct fc_tprlo_s *) (fchs + 1);\r\nint page;\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemset(tprlo, 0, (num_pages * 16) + 4);\r\ntprlo->command = FC_ELS_TPRLO;\r\ntprlo->page_len = 0x10;\r\ntprlo->payload_len = cpu_to_be16((num_pages * 16) + 4);\r\nfor (page = 0; page < num_pages; page++) {\r\ntprlo->tprlo_params[page].type = FC_TYPE_FCP;\r\ntprlo->tprlo_params[page].opa_valid = 0;\r\ntprlo->tprlo_params[page].rpa_valid = 0;\r\ntprlo->tprlo_params[page].orig_process_assc = 0;\r\ntprlo->tprlo_params[page].resp_process_assc = 0;\r\nif (tprlo_type == FC_GLOBAL_LOGO) {\r\ntprlo->tprlo_params[page].global_process_logout = 1;\r\n} else if (tprlo_type == FC_TPR_LOGO) {\r\ntprlo->tprlo_params[page].tpo_nport_valid = 1;\r\ntprlo->tprlo_params[page].tpo_nport_id = (tpr_id);\r\n}\r\n}\r\nreturn be16_to_cpu(tprlo->payload_len);\r\n}\r\nu16\r\nfc_tprlo_rsp_parse(struct fchs_s *fchs, int len)\r\n{\r\nstruct fc_tprlo_acc_s *tprlo = (struct fc_tprlo_acc_s *) (fchs + 1);\r\nint num_pages = 0;\r\nint page = 0;\r\nlen = len;\r\nif (tprlo->command != FC_ELS_ACC)\r\nreturn FC_PARSE_ACC_INVAL;\r\nnum_pages = (be16_to_cpu(tprlo->payload_len) - 4) / 16;\r\nfor (page = 0; page < num_pages; page++) {\r\nif (tprlo->tprlo_acc_params[page].type != FC_TYPE_FCP)\r\nreturn FC_PARSE_NOT_FCP;\r\nif (tprlo->tprlo_acc_params[page].opa_valid != 0)\r\nreturn FC_PARSE_OPAFLAG_INVAL;\r\nif (tprlo->tprlo_acc_params[page].rpa_valid != 0)\r\nreturn FC_PARSE_RPAFLAG_INVAL;\r\nif (tprlo->tprlo_acc_params[page].orig_process_assc != 0)\r\nreturn FC_PARSE_OPA_INVAL;\r\nif (tprlo->tprlo_acc_params[page].resp_process_assc != 0)\r\nreturn FC_PARSE_RPA_INVAL;\r\n}\r\nreturn FC_PARSE_OK;\r\n}\r\nenum fc_parse_status\r\nfc_rrq_rsp_parse(struct fchs_s *fchs, int len)\r\n{\r\nstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\r\nlen = len;\r\nif (els_cmd->els_code != FC_ELS_ACC)\r\nreturn FC_PARSE_FAILURE;\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_ba_rjt_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id,\r\nu32 reason_code, u32 reason_expl)\r\n{\r\nstruct fc_ba_rjt_s *ba_rjt = (struct fc_ba_rjt_s *) (fchs + 1);\r\nfc_bls_rsp_build(fchs, d_id, s_id, ox_id);\r\nfchs->cat_info = FC_CAT_BA_RJT;\r\nba_rjt->reason_code = reason_code;\r\nba_rjt->reason_expl = reason_expl;\r\nreturn sizeof(struct fc_ba_rjt_s);\r\n}\r\nstatic void\r\nfc_gs_cthdr_build(struct ct_hdr_s *cthdr, u32 s_id, u16 cmd_code)\r\n{\r\nmemset(cthdr, 0, sizeof(struct ct_hdr_s));\r\ncthdr->rev_id = CT_GS3_REVISION;\r\ncthdr->gs_type = CT_GSTYPE_DIRSERVICE;\r\ncthdr->gs_sub_type = CT_GSSUBTYPE_NAMESERVER;\r\ncthdr->cmd_rsp_code = cpu_to_be16(cmd_code);\r\n}\r\nstatic void\r\nfc_gs_fdmi_cthdr_build(struct ct_hdr_s *cthdr, u32 s_id, u16 cmd_code)\r\n{\r\nmemset(cthdr, 0, sizeof(struct ct_hdr_s));\r\ncthdr->rev_id = CT_GS3_REVISION;\r\ncthdr->gs_type = CT_GSTYPE_MGMTSERVICE;\r\ncthdr->gs_sub_type = CT_GSSUBTYPE_HBA_MGMTSERVER;\r\ncthdr->cmd_rsp_code = cpu_to_be16(cmd_code);\r\n}\r\nstatic void\r\nfc_gs_ms_cthdr_build(struct ct_hdr_s *cthdr, u32 s_id, u16 cmd_code,\r\nu8 sub_type)\r\n{\r\nmemset(cthdr, 0, sizeof(struct ct_hdr_s));\r\ncthdr->rev_id = CT_GS3_REVISION;\r\ncthdr->gs_type = CT_GSTYPE_MGMTSERVICE;\r\ncthdr->gs_sub_type = sub_type;\r\ncthdr->cmd_rsp_code = cpu_to_be16(cmd_code);\r\n}\r\nu16\r\nfc_gidpn_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nwwn_t port_name)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_gidpn_req_s *gidpn = (struct fcgs_gidpn_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_GID_PN);\r\nmemset(gidpn, 0, sizeof(struct fcgs_gidpn_req_s));\r\ngidpn->port_name = port_name;\r\nreturn sizeof(struct fcgs_gidpn_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_gpnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nu32 port_id)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nfcgs_gpnid_req_t *gpnid = (fcgs_gpnid_req_t *) (cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_GPN_ID);\r\nmemset(gpnid, 0, sizeof(fcgs_gpnid_req_t));\r\ngpnid->dap = port_id;\r\nreturn sizeof(fcgs_gpnid_req_t) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_gnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nu32 port_id)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nfcgs_gnnid_req_t *gnnid = (fcgs_gnnid_req_t *) (cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_GNN_ID);\r\nmemset(gnnid, 0, sizeof(fcgs_gnnid_req_t));\r\ngnnid->dap = port_id;\r\nreturn sizeof(fcgs_gnnid_req_t) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_ct_rsp_parse(struct ct_hdr_s *cthdr)\r\n{\r\nif (be16_to_cpu(cthdr->cmd_rsp_code) != CT_RSP_ACCEPT) {\r\nif (cthdr->reason_code == CT_RSN_LOGICAL_BUSY)\r\nreturn FC_PARSE_BUSY;\r\nelse\r\nreturn FC_PARSE_FAILURE;\r\n}\r\nreturn FC_PARSE_OK;\r\n}\r\nu16\r\nfc_gs_rjt_build(struct fchs_s *fchs, struct ct_hdr_s *cthdr,\r\nu32 d_id, u32 s_id, u16 ox_id, u8 reason_code,\r\nu8 reason_code_expl)\r\n{\r\nfc_gsresp_fchdr_build(fchs, d_id, s_id, ox_id);\r\ncthdr->cmd_rsp_code = cpu_to_be16(CT_RSP_REJECT);\r\ncthdr->rev_id = CT_GS3_REVISION;\r\ncthdr->reason_code = reason_code;\r\ncthdr->exp_code = reason_code_expl;\r\nreturn sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_scr_build(struct fchs_s *fchs, struct fc_scr_s *scr,\r\nu8 set_br_reg, u32 s_id, u16 ox_id)\r\n{\r\nu32 d_id = bfa_hton3b(FC_FABRIC_CONTROLLER);\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nmemset(scr, 0, sizeof(struct fc_scr_s));\r\nscr->command = FC_ELS_SCR;\r\nscr->reg_func = FC_SCR_REG_FUNC_FULL;\r\nif (set_br_reg)\r\nscr->vu_reg_func = FC_VU_SCR_REG_FUNC_FABRIC_NAME_CHANGE;\r\nreturn sizeof(struct fc_scr_s);\r\n}\r\nu16\r\nfc_rscn_build(struct fchs_s *fchs, struct fc_rscn_pl_s *rscn,\r\nu32 s_id, u16 ox_id)\r\n{\r\nu32 d_id = bfa_hton3b(FC_FABRIC_CONTROLLER);\r\nu16 payldlen;\r\nfc_els_req_build(fchs, d_id, s_id, ox_id);\r\nrscn->command = FC_ELS_RSCN;\r\nrscn->pagelen = sizeof(rscn->event[0]);\r\npayldlen = sizeof(u32) + rscn->pagelen;\r\nrscn->payldlen = cpu_to_be16(payldlen);\r\nrscn->event[0].format = FC_RSCN_FORMAT_PORTID;\r\nrscn->event[0].portid = s_id;\r\nreturn sizeof(struct fc_rscn_pl_s);\r\n}\r\nu16\r\nfc_rftid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nenum bfa_lport_role roles)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rftid_req_s *rftid = (struct fcgs_rftid_req_s *)(cthdr + 1);\r\nu32 type_value, d_id = bfa_hton3b(FC_NAME_SERVER);\r\nu8 index;\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RFT_ID);\r\nmemset(rftid, 0, sizeof(struct fcgs_rftid_req_s));\r\nrftid->dap = s_id;\r\nindex = FC_TYPE_FCP >> 5;\r\ntype_value = 1 << (FC_TYPE_FCP % 32);\r\nrftid->fc4_type[index] = cpu_to_be32(type_value);\r\nreturn sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rftid_build_sol(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nu8 *fc4_bitmap, u32 bitmap_size)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rftid_req_s *rftid = (struct fcgs_rftid_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RFT_ID);\r\nmemset(rftid, 0, sizeof(struct fcgs_rftid_req_s));\r\nrftid->dap = s_id;\r\nmemcpy((void *)rftid->fc4_type, (void *)fc4_bitmap,\r\n(bitmap_size < 32 ? bitmap_size : 32));\r\nreturn sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rffid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nu8 fc4_type, u8 fc4_ftrs)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rffid_req_s *rffid = (struct fcgs_rffid_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RFF_ID);\r\nmemset(rffid, 0, sizeof(struct fcgs_rffid_req_s));\r\nrffid->dap = s_id;\r\nrffid->fc4ftr_bits = fc4_ftrs;\r\nrffid->fc4_type = fc4_type;\r\nreturn sizeof(struct fcgs_rffid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rspnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\r\nu8 *name)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rspnid_req_s *rspnid =\r\n(struct fcgs_rspnid_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RSPN_ID);\r\nmemset(rspnid, 0, sizeof(struct fcgs_rspnid_req_s));\r\nrspnid->dap = s_id;\r\nrspnid->spn_len = (u8) strlen((char *)name);\r\nstrncpy((char *)rspnid->spn, (char *)name, rspnid->spn_len);\r\nreturn sizeof(struct fcgs_rspnid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rsnn_nn_build(struct fchs_s *fchs, void *pyld, u32 s_id,\r\nwwn_t node_name, u8 *name)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rsnn_nn_req_s *rsnn_nn =\r\n(struct fcgs_rsnn_nn_req_s *) (cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RSNN_NN);\r\nmemset(rsnn_nn, 0, sizeof(struct fcgs_rsnn_nn_req_s));\r\nrsnn_nn->node_name = node_name;\r\nrsnn_nn->snn_len = (u8) strlen((char *)name);\r\nstrncpy((char *)rsnn_nn->snn, (char *)name, rsnn_nn->snn_len);\r\nreturn sizeof(struct fcgs_rsnn_nn_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_gid_ft_build(struct fchs_s *fchs, void *pyld, u32 s_id, u8 fc4_type)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_gidft_req_s *gidft = (struct fcgs_gidft_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_GID_FT);\r\nmemset(gidft, 0, sizeof(struct fcgs_gidft_req_s));\r\ngidft->fc4_type = fc4_type;\r\ngidft->domain_id = 0;\r\ngidft->area_id = 0;\r\nreturn sizeof(struct fcgs_gidft_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rpnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\r\nwwn_t port_name)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rpnid_req_s *rpnid = (struct fcgs_rpnid_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RPN_ID);\r\nmemset(rpnid, 0, sizeof(struct fcgs_rpnid_req_s));\r\nrpnid->port_id = port_id;\r\nrpnid->port_name = port_name;\r\nreturn sizeof(struct fcgs_rpnid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\r\nwwn_t node_name)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rnnid_req_s *rnnid = (struct fcgs_rnnid_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RNN_ID);\r\nmemset(rnnid, 0, sizeof(struct fcgs_rnnid_req_s));\r\nrnnid->port_id = port_id;\r\nrnnid->node_name = node_name;\r\nreturn sizeof(struct fcgs_rnnid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rcsid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\r\nu32 cos)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rcsid_req_s *rcsid =\r\n(struct fcgs_rcsid_req_s *) (cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RCS_ID);\r\nmemset(rcsid, 0, sizeof(struct fcgs_rcsid_req_s));\r\nrcsid->port_id = port_id;\r\nrcsid->cos = cos;\r\nreturn sizeof(struct fcgs_rcsid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_rptid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\r\nu8 port_type)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_rptid_req_s *rptid = (struct fcgs_rptid_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_RPT_ID);\r\nmemset(rptid, 0, sizeof(struct fcgs_rptid_req_s));\r\nrptid->port_id = port_id;\r\nrptid->port_type = port_type;\r\nreturn sizeof(struct fcgs_rptid_req_s) + sizeof(struct ct_hdr_s);\r\n}\r\nu16\r\nfc_ganxt_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nstruct fcgs_ganxt_req_s *ganxt = (struct fcgs_ganxt_req_s *)(cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_NAME_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_cthdr_build(cthdr, s_id, GS_GA_NXT);\r\nmemset(ganxt, 0, sizeof(struct fcgs_ganxt_req_s));\r\nganxt->port_id = port_id;\r\nreturn sizeof(struct ct_hdr_s) + sizeof(struct fcgs_ganxt_req_s);\r\n}\r\nu16\r\nfc_fdmi_reqhdr_build(struct fchs_s *fchs, void *pyld, u32 s_id,\r\nu16 cmd_code)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nu32 d_id = bfa_hton3b(FC_MGMT_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_fdmi_cthdr_build(cthdr, s_id, cmd_code);\r\nreturn sizeof(struct ct_hdr_s);\r\n}\r\nvoid\r\nfc_get_fc4type_bitmask(u8 fc4_type, u8 *bit_mask)\r\n{\r\nu8 index;\r\n__be32 *ptr = (__be32 *) bit_mask;\r\nu32 type_value;\r\nindex = fc4_type >> 5;\r\ntype_value = 1 << (fc4_type % 32);\r\nptr[index] = cpu_to_be32(type_value);\r\n}\r\nu16\r\nfc_gmal_req_build(struct fchs_s *fchs, void *pyld, u32 s_id, wwn_t wwn)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nfcgs_gmal_req_t *gmal = (fcgs_gmal_req_t *) (cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_MGMT_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_ms_cthdr_build(cthdr, s_id, GS_FC_GMAL_CMD,\r\nCT_GSSUBTYPE_CFGSERVER);\r\nmemset(gmal, 0, sizeof(fcgs_gmal_req_t));\r\ngmal->wwn = wwn;\r\nreturn sizeof(struct ct_hdr_s) + sizeof(fcgs_gmal_req_t);\r\n}\r\nu16\r\nfc_gfn_req_build(struct fchs_s *fchs, void *pyld, u32 s_id, wwn_t wwn)\r\n{\r\nstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\r\nfcgs_gfn_req_t *gfn = (fcgs_gfn_req_t *) (cthdr + 1);\r\nu32 d_id = bfa_hton3b(FC_MGMT_SERVER);\r\nfc_gs_fchdr_build(fchs, d_id, s_id, 0);\r\nfc_gs_ms_cthdr_build(cthdr, s_id, GS_FC_GFN_CMD,\r\nCT_GSSUBTYPE_CFGSERVER);\r\nmemset(gfn, 0, sizeof(fcgs_gfn_req_t));\r\ngfn->wwn = wwn;\r\nreturn sizeof(struct ct_hdr_s) + sizeof(fcgs_gfn_req_t);\r\n}
