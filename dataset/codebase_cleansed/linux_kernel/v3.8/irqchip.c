void ack_bad_irq(unsigned int irq)\r\n{\r\natomic_inc(&irq_err_count);\r\nprintk(KERN_ERR "IRQ: spurious interrupt %d\n", irq);\r\n}\r\nint show_interrupts(struct seq_file *p, void *v)\r\n{\r\nint i = *(loff_t *) v, j;\r\nstruct irqaction *action;\r\nunsigned long flags;\r\nif (i < NR_IRQS) {\r\nstruct irq_desc *desc = irq_to_desc(i);\r\nraw_spin_lock_irqsave(&desc->lock, flags);\r\naction = desc->action;\r\nif (!action)\r\ngoto skip;\r\nseq_printf(p, "%3d: ", i);\r\nfor_each_online_cpu(j)\r\nseq_printf(p, "%10u ", kstat_irqs_cpu(i, j));\r\nseq_printf(p, " %8s", irq_desc_get_chip(desc)->name);\r\nseq_printf(p, " %s", action->name);\r\nfor (action = action->next; action; action = action->next)\r\nseq_printf(p, " %s", action->name);\r\nseq_putc(p, '\n');\r\nskip:\r\nraw_spin_unlock_irqrestore(&desc->lock, flags);\r\n} else if (i == NR_IRQS) {\r\nseq_printf(p, "NMI: ");\r\nfor_each_online_cpu(j)\r\nseq_printf(p, "%10u ", cpu_pda[j].__nmi_count);\r\nseq_printf(p, " CORE Non Maskable Interrupt\n");\r\nseq_printf(p, "Err: %10u\n", atomic_read(&irq_err_count));\r\n}\r\nreturn 0;\r\n}\r\nstatic void check_stack_overflow(int irq)\r\n{\r\nlong sp = __get_SP() & (THREAD_SIZE - 1);\r\nif (unlikely(sp < (sizeof(struct thread_info) + STACK_WARN))) {\r\ndump_stack();\r\npr_emerg("irq%i: possible stack overflow only %ld bytes free\n",\r\nirq, sp - sizeof(struct thread_info));\r\n}\r\n}\r\nstatic inline void check_stack_overflow(int irq) { }\r\nstatic void maybe_lower_to_irq14(void)\r\n{\r\nunsigned short pending, other_ints;\r\nCSYNC();\r\npending = bfin_read_IPEND() & ~0x8000;\r\nother_ints = pending & (pending - 1);\r\nif (other_ints == 0)\r\nlower_to_irq14();\r\n}\r\nstatic inline void maybe_lower_to_irq14(void) { }\r\nasmlinkage void asm_do_IRQ(unsigned int irq, struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nirq_enter();\r\ncheck_stack_overflow(irq);\r\nif (irq >= NR_IRQS)\r\nhandle_bad_irq(irq, &bad_irq_desc);\r\nelse\r\ngeneric_handle_irq(irq);\r\nmaybe_lower_to_irq14();\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid __init init_IRQ(void)\r\n{\r\ninit_arch_irq();\r\n#ifdef CONFIG_DEBUG_BFIN_HWTRACE_EXPAND\r\ntrace_buff_offset = 0;\r\nbfin_write_TBUFCTL(BFIN_TRACE_ON);\r\nprintk(KERN_INFO "Hardware Trace expanded to %ik\n",\r\n1 << CONFIG_DEBUG_BFIN_HWTRACE_EXPAND_LEN);\r\n#endif\r\n}
