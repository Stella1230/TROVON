static inline void arch_timer_reg_write(const int access, const int reg, u32 val)\r\n{\r\nif (access == ARCH_TIMER_PHYS_ACCESS) {\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nasm volatile("mcr p15, 0, %0, c14, c2, 1" : : "r" (val));\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nasm volatile("mcr p15, 0, %0, c14, c2, 0" : : "r" (val));\r\nbreak;\r\n}\r\n}\r\nif (access == ARCH_TIMER_VIRT_ACCESS) {\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nasm volatile("mcr p15, 0, %0, c14, c3, 1" : : "r" (val));\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nasm volatile("mcr p15, 0, %0, c14, c3, 0" : : "r" (val));\r\nbreak;\r\n}\r\n}\r\nisb();\r\n}\r\nstatic inline u32 arch_timer_reg_read(const int access, const int reg)\r\n{\r\nu32 val = 0;\r\nif (access == ARCH_TIMER_PHYS_ACCESS) {\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nasm volatile("mrc p15, 0, %0, c14, c2, 1" : "=r" (val));\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nasm volatile("mrc p15, 0, %0, c14, c2, 0" : "=r" (val));\r\nbreak;\r\ncase ARCH_TIMER_REG_FREQ:\r\nasm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r" (val));\r\nbreak;\r\n}\r\n}\r\nif (access == ARCH_TIMER_VIRT_ACCESS) {\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nasm volatile("mrc p15, 0, %0, c14, c3, 1" : "=r" (val));\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nasm volatile("mrc p15, 0, %0, c14, c3, 0" : "=r" (val));\r\nbreak;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic inline cycle_t arch_timer_counter_read(const int access)\r\n{\r\ncycle_t cval = 0;\r\nif (access == ARCH_TIMER_PHYS_ACCESS)\r\nasm volatile("mrrc p15, 0, %Q0, %R0, c14" : "=r" (cval));\r\nif (access == ARCH_TIMER_VIRT_ACCESS)\r\nasm volatile("mrrc p15, 1, %Q0, %R0, c14" : "=r" (cval));\r\nreturn cval;\r\n}\r\nstatic inline cycle_t arch_counter_get_cntpct(void)\r\n{\r\nreturn arch_timer_counter_read(ARCH_TIMER_PHYS_ACCESS);\r\n}\r\nstatic inline cycle_t arch_counter_get_cntvct(void)\r\n{\r\nreturn arch_timer_counter_read(ARCH_TIMER_VIRT_ACCESS);\r\n}\r\nstatic irqreturn_t inline timer_handler(const int access,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl;\r\nctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL);\r\nif (ctrl & ARCH_TIMER_CTRL_IT_STAT) {\r\nctrl |= ARCH_TIMER_CTRL_IT_MASK;\r\narch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t arch_timer_handler_virt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = *(struct clock_event_device **)dev_id;\r\nreturn timer_handler(ARCH_TIMER_VIRT_ACCESS, evt);\r\n}\r\nstatic irqreturn_t arch_timer_handler_phys(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = *(struct clock_event_device **)dev_id;\r\nreturn timer_handler(ARCH_TIMER_PHYS_ACCESS, evt);\r\n}\r\nstatic inline void timer_set_mode(const int access, int mode)\r\n{\r\nunsigned long ctrl;\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL);\r\nctrl &= ~ARCH_TIMER_CTRL_ENABLE;\r\narch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void arch_timer_set_mode_virt(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\ntimer_set_mode(ARCH_TIMER_VIRT_ACCESS, mode);\r\n}\r\nstatic void arch_timer_set_mode_phys(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\ntimer_set_mode(ARCH_TIMER_PHYS_ACCESS, mode);\r\n}\r\nstatic inline void set_next_event(const int access, unsigned long evt)\r\n{\r\nunsigned long ctrl;\r\nctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL);\r\nctrl |= ARCH_TIMER_CTRL_ENABLE;\r\nctrl &= ~ARCH_TIMER_CTRL_IT_MASK;\r\narch_timer_reg_write(access, ARCH_TIMER_REG_TVAL, evt);\r\narch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl);\r\n}\r\nstatic int arch_timer_set_next_event_virt(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nset_next_event(ARCH_TIMER_VIRT_ACCESS, evt);\r\nreturn 0;\r\n}\r\nstatic int arch_timer_set_next_event_phys(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nset_next_event(ARCH_TIMER_PHYS_ACCESS, evt);\r\nreturn 0;\r\n}\r\nstatic int __cpuinit arch_timer_setup(struct clock_event_device *clk)\r\n{\r\nclk->features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_C3STOP;\r\nclk->name = "arch_sys_timer";\r\nclk->rating = 450;\r\nif (arch_timer_use_virtual) {\r\nclk->irq = arch_timer_ppi[VIRT_PPI];\r\nclk->set_mode = arch_timer_set_mode_virt;\r\nclk->set_next_event = arch_timer_set_next_event_virt;\r\n} else {\r\nclk->irq = arch_timer_ppi[PHYS_SECURE_PPI];\r\nclk->set_mode = arch_timer_set_mode_phys;\r\nclk->set_next_event = arch_timer_set_next_event_phys;\r\n}\r\nclk->set_mode(CLOCK_EVT_MODE_SHUTDOWN, NULL);\r\nclockevents_config_and_register(clk, arch_timer_rate,\r\n0xf, 0x7fffffff);\r\n*__this_cpu_ptr(arch_timer_evt) = clk;\r\nif (arch_timer_use_virtual)\r\nenable_percpu_irq(arch_timer_ppi[VIRT_PPI], 0);\r\nelse {\r\nenable_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI], 0);\r\nif (arch_timer_ppi[PHYS_NONSECURE_PPI])\r\nenable_percpu_irq(arch_timer_ppi[PHYS_NONSECURE_PPI], 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int local_timer_is_architected(void)\r\n{\r\nreturn (cpu_architecture() >= CPU_ARCH_ARMv7) &&\r\n((read_cpuid_ext(CPUID_EXT_PFR1) >> 16) & 0xf) == 1;\r\n}\r\nstatic int arch_timer_available(void)\r\n{\r\nunsigned long freq;\r\nif (!local_timer_is_architected())\r\nreturn -ENXIO;\r\nif (arch_timer_rate == 0) {\r\nfreq = arch_timer_reg_read(ARCH_TIMER_PHYS_ACCESS,\r\nARCH_TIMER_REG_FREQ);\r\nif (freq == 0) {\r\npr_warn("Architected timer frequency not available\n");\r\nreturn -EINVAL;\r\n}\r\narch_timer_rate = freq;\r\n}\r\npr_info_once("Architected local timer running at %lu.%02luMHz (%s).\n",\r\narch_timer_rate / 1000000, (arch_timer_rate / 10000) % 100,\r\narch_timer_use_virtual ? "virt" : "phys");\r\nreturn 0;\r\n}\r\nstatic u32 notrace arch_counter_get_cntpct32(void)\r\n{\r\ncycle_t cnt = arch_counter_get_cntpct();\r\nreturn (u32)cnt;\r\n}\r\nstatic u32 notrace arch_counter_get_cntvct32(void)\r\n{\r\ncycle_t cnt = arch_counter_get_cntvct();\r\nreturn (u32)cnt;\r\n}\r\nstatic cycle_t arch_counter_read(struct clocksource *cs)\r\n{\r\nreturn arch_counter_get_cntpct();\r\n}\r\nstatic unsigned long arch_timer_read_current_timer(void)\r\n{\r\nreturn arch_counter_get_cntpct();\r\n}\r\nstatic cycle_t arch_counter_read_cc(const struct cyclecounter *cc)\r\n{\r\nreturn arch_counter_get_cntpct();\r\n}\r\nstruct timecounter *arch_timer_get_timecounter(void)\r\n{\r\nreturn &timecounter;\r\n}\r\nstatic void __cpuinit arch_timer_stop(struct clock_event_device *clk)\r\n{\r\npr_debug("arch_timer_teardown disable IRQ%d cpu #%d\n",\r\nclk->irq, smp_processor_id());\r\nif (arch_timer_use_virtual)\r\ndisable_percpu_irq(arch_timer_ppi[VIRT_PPI]);\r\nelse {\r\ndisable_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI]);\r\nif (arch_timer_ppi[PHYS_NONSECURE_PPI])\r\ndisable_percpu_irq(arch_timer_ppi[PHYS_NONSECURE_PPI]);\r\n}\r\nclk->set_mode(CLOCK_EVT_MODE_UNUSED, clk);\r\n}\r\nstatic int __init arch_timer_register(void)\r\n{\r\nint err;\r\nint ppi;\r\nerr = arch_timer_available();\r\nif (err)\r\ngoto out;\r\narch_timer_evt = alloc_percpu(struct clock_event_device *);\r\nif (!arch_timer_evt) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nclocksource_register_hz(&clocksource_counter, arch_timer_rate);\r\ncyclecounter.mult = clocksource_counter.mult;\r\ncyclecounter.shift = clocksource_counter.shift;\r\ntimecounter_init(&timecounter, &cyclecounter,\r\narch_counter_get_cntpct());\r\nif (arch_timer_use_virtual) {\r\nppi = arch_timer_ppi[VIRT_PPI];\r\nerr = request_percpu_irq(ppi, arch_timer_handler_virt,\r\n"arch_timer", arch_timer_evt);\r\n} else {\r\nppi = arch_timer_ppi[PHYS_SECURE_PPI];\r\nerr = request_percpu_irq(ppi, arch_timer_handler_phys,\r\n"arch_timer", arch_timer_evt);\r\nif (!err && arch_timer_ppi[PHYS_NONSECURE_PPI]) {\r\nppi = arch_timer_ppi[PHYS_NONSECURE_PPI];\r\nerr = request_percpu_irq(ppi, arch_timer_handler_phys,\r\n"arch_timer", arch_timer_evt);\r\nif (err)\r\nfree_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI],\r\narch_timer_evt);\r\n}\r\n}\r\nif (err) {\r\npr_err("arch_timer: can't register interrupt %d (%d)\n",\r\nppi, err);\r\ngoto out_free;\r\n}\r\nerr = local_timer_register(&arch_timer_ops);\r\nif (err) {\r\narch_timer_global_evt.cpumask = cpumask_of(0);\r\nerr = arch_timer_setup(&arch_timer_global_evt);\r\n}\r\nif (err)\r\ngoto out_free_irq;\r\narch_delay_timer.read_current_timer = &arch_timer_read_current_timer;\r\narch_delay_timer.freq = arch_timer_rate;\r\nregister_current_timer_delay(&arch_delay_timer);\r\nreturn 0;\r\nout_free_irq:\r\nif (arch_timer_use_virtual)\r\nfree_percpu_irq(arch_timer_ppi[VIRT_PPI], arch_timer_evt);\r\nelse {\r\nfree_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI],\r\narch_timer_evt);\r\nif (arch_timer_ppi[PHYS_NONSECURE_PPI])\r\nfree_percpu_irq(arch_timer_ppi[PHYS_NONSECURE_PPI],\r\narch_timer_evt);\r\n}\r\nout_free:\r\nfree_percpu(arch_timer_evt);\r\nout:\r\nreturn err;\r\n}\r\nint __init arch_timer_of_register(void)\r\n{\r\nstruct device_node *np;\r\nu32 freq;\r\nint i;\r\nnp = of_find_matching_node(NULL, arch_timer_of_match);\r\nif (!np) {\r\npr_err("arch_timer: can't find DT node\n");\r\nreturn -ENODEV;\r\n}\r\nif (!of_property_read_u32(np, "clock-frequency", &freq))\r\narch_timer_rate = freq;\r\nfor (i = PHYS_SECURE_PPI; i < MAX_TIMER_PPI; i++)\r\narch_timer_ppi[i] = irq_of_parse_and_map(np, i);\r\nif (!arch_timer_ppi[VIRT_PPI]) {\r\narch_timer_use_virtual = false;\r\nif (!arch_timer_ppi[PHYS_SECURE_PPI] ||\r\n!arch_timer_ppi[PHYS_NONSECURE_PPI]) {\r\npr_warn("arch_timer: No interrupt available, giving up\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn arch_timer_register();\r\n}\r\nint __init arch_timer_sched_clock_init(void)\r\n{\r\nu32 (*cnt32)(void);\r\nint err;\r\nerr = arch_timer_available();\r\nif (err)\r\nreturn err;\r\nif (arch_timer_use_virtual)\r\ncnt32 = arch_counter_get_cntvct32;\r\nelse\r\ncnt32 = arch_counter_get_cntpct32;\r\nsetup_sched_clock(cnt32, 32, arch_timer_rate);\r\nreturn 0;\r\n}
