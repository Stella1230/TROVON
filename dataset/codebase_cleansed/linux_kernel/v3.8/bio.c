static struct kmem_cache *bio_find_or_create_slab(unsigned int extra_size)\r\n{\r\nunsigned int sz = sizeof(struct bio) + extra_size;\r\nstruct kmem_cache *slab = NULL;\r\nstruct bio_slab *bslab, *new_bio_slabs;\r\nunsigned int new_bio_slab_max;\r\nunsigned int i, entry = -1;\r\nmutex_lock(&bio_slab_lock);\r\ni = 0;\r\nwhile (i < bio_slab_nr) {\r\nbslab = &bio_slabs[i];\r\nif (!bslab->slab && entry == -1)\r\nentry = i;\r\nelse if (bslab->slab_size == sz) {\r\nslab = bslab->slab;\r\nbslab->slab_ref++;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (slab)\r\ngoto out_unlock;\r\nif (bio_slab_nr == bio_slab_max && entry == -1) {\r\nnew_bio_slab_max = bio_slab_max << 1;\r\nnew_bio_slabs = krealloc(bio_slabs,\r\nnew_bio_slab_max * sizeof(struct bio_slab),\r\nGFP_KERNEL);\r\nif (!new_bio_slabs)\r\ngoto out_unlock;\r\nbio_slab_max = new_bio_slab_max;\r\nbio_slabs = new_bio_slabs;\r\n}\r\nif (entry == -1)\r\nentry = bio_slab_nr++;\r\nbslab = &bio_slabs[entry];\r\nsnprintf(bslab->name, sizeof(bslab->name), "bio-%d", entry);\r\nslab = kmem_cache_create(bslab->name, sz, 0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (!slab)\r\ngoto out_unlock;\r\nprintk(KERN_INFO "bio: create slab <%s> at %d\n", bslab->name, entry);\r\nbslab->slab = slab;\r\nbslab->slab_ref = 1;\r\nbslab->slab_size = sz;\r\nout_unlock:\r\nmutex_unlock(&bio_slab_lock);\r\nreturn slab;\r\n}\r\nstatic void bio_put_slab(struct bio_set *bs)\r\n{\r\nstruct bio_slab *bslab = NULL;\r\nunsigned int i;\r\nmutex_lock(&bio_slab_lock);\r\nfor (i = 0; i < bio_slab_nr; i++) {\r\nif (bs->bio_slab == bio_slabs[i].slab) {\r\nbslab = &bio_slabs[i];\r\nbreak;\r\n}\r\n}\r\nif (WARN(!bslab, KERN_ERR "bio: unable to find slab!\n"))\r\ngoto out;\r\nWARN_ON(!bslab->slab_ref);\r\nif (--bslab->slab_ref)\r\ngoto out;\r\nkmem_cache_destroy(bslab->slab);\r\nbslab->slab = NULL;\r\nout:\r\nmutex_unlock(&bio_slab_lock);\r\n}\r\nunsigned int bvec_nr_vecs(unsigned short idx)\r\n{\r\nreturn bvec_slabs[idx].nr_vecs;\r\n}\r\nvoid bvec_free_bs(struct bio_set *bs, struct bio_vec *bv, unsigned int idx)\r\n{\r\nBIO_BUG_ON(idx >= BIOVEC_NR_POOLS);\r\nif (idx == BIOVEC_MAX_IDX)\r\nmempool_free(bv, bs->bvec_pool);\r\nelse {\r\nstruct biovec_slab *bvs = bvec_slabs + idx;\r\nkmem_cache_free(bvs->slab, bv);\r\n}\r\n}\r\nstruct bio_vec *bvec_alloc_bs(gfp_t gfp_mask, int nr, unsigned long *idx,\r\nstruct bio_set *bs)\r\n{\r\nstruct bio_vec *bvl;\r\nswitch (nr) {\r\ncase 1:\r\n*idx = 0;\r\nbreak;\r\ncase 2 ... 4:\r\n*idx = 1;\r\nbreak;\r\ncase 5 ... 16:\r\n*idx = 2;\r\nbreak;\r\ncase 17 ... 64:\r\n*idx = 3;\r\nbreak;\r\ncase 65 ... 128:\r\n*idx = 4;\r\nbreak;\r\ncase 129 ... BIO_MAX_PAGES:\r\n*idx = 5;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nif (*idx == BIOVEC_MAX_IDX) {\r\nfallback:\r\nbvl = mempool_alloc(bs->bvec_pool, gfp_mask);\r\n} else {\r\nstruct biovec_slab *bvs = bvec_slabs + *idx;\r\ngfp_t __gfp_mask = gfp_mask & ~(__GFP_WAIT | __GFP_IO);\r\n__gfp_mask |= __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN;\r\nbvl = kmem_cache_alloc(bvs->slab, __gfp_mask);\r\nif (unlikely(!bvl && (gfp_mask & __GFP_WAIT))) {\r\n*idx = BIOVEC_MAX_IDX;\r\ngoto fallback;\r\n}\r\n}\r\nreturn bvl;\r\n}\r\nstatic void __bio_free(struct bio *bio)\r\n{\r\nbio_disassociate_task(bio);\r\nif (bio_integrity(bio))\r\nbio_integrity_free(bio);\r\n}\r\nstatic void bio_free(struct bio *bio)\r\n{\r\nstruct bio_set *bs = bio->bi_pool;\r\nvoid *p;\r\n__bio_free(bio);\r\nif (bs) {\r\nif (bio_has_allocated_vec(bio))\r\nbvec_free_bs(bs, bio->bi_io_vec, BIO_POOL_IDX(bio));\r\np = bio;\r\np -= bs->front_pad;\r\nmempool_free(p, bs->bio_pool);\r\n} else {\r\nkfree(bio);\r\n}\r\n}\r\nvoid bio_init(struct bio *bio)\r\n{\r\nmemset(bio, 0, sizeof(*bio));\r\nbio->bi_flags = 1 << BIO_UPTODATE;\r\natomic_set(&bio->bi_cnt, 1);\r\n}\r\nvoid bio_reset(struct bio *bio)\r\n{\r\nunsigned long flags = bio->bi_flags & (~0UL << BIO_RESET_BITS);\r\n__bio_free(bio);\r\nmemset(bio, 0, BIO_RESET_BYTES);\r\nbio->bi_flags = flags|(1 << BIO_UPTODATE);\r\n}\r\nstruct bio *bio_alloc_bioset(gfp_t gfp_mask, int nr_iovecs, struct bio_set *bs)\r\n{\r\nunsigned front_pad;\r\nunsigned inline_vecs;\r\nunsigned long idx = BIO_POOL_NONE;\r\nstruct bio_vec *bvl = NULL;\r\nstruct bio *bio;\r\nvoid *p;\r\nif (!bs) {\r\nif (nr_iovecs > UIO_MAXIOV)\r\nreturn NULL;\r\np = kmalloc(sizeof(struct bio) +\r\nnr_iovecs * sizeof(struct bio_vec),\r\ngfp_mask);\r\nfront_pad = 0;\r\ninline_vecs = nr_iovecs;\r\n} else {\r\np = mempool_alloc(bs->bio_pool, gfp_mask);\r\nfront_pad = bs->front_pad;\r\ninline_vecs = BIO_INLINE_VECS;\r\n}\r\nif (unlikely(!p))\r\nreturn NULL;\r\nbio = p + front_pad;\r\nbio_init(bio);\r\nif (nr_iovecs > inline_vecs) {\r\nbvl = bvec_alloc_bs(gfp_mask, nr_iovecs, &idx, bs);\r\nif (unlikely(!bvl))\r\ngoto err_free;\r\n} else if (nr_iovecs) {\r\nbvl = bio->bi_inline_vecs;\r\n}\r\nbio->bi_pool = bs;\r\nbio->bi_flags |= idx << BIO_POOL_OFFSET;\r\nbio->bi_max_vecs = nr_iovecs;\r\nbio->bi_io_vec = bvl;\r\nreturn bio;\r\nerr_free:\r\nmempool_free(p, bs->bio_pool);\r\nreturn NULL;\r\n}\r\nvoid zero_fill_bio(struct bio *bio)\r\n{\r\nunsigned long flags;\r\nstruct bio_vec *bv;\r\nint i;\r\nbio_for_each_segment(bv, bio, i) {\r\nchar *data = bvec_kmap_irq(bv, &flags);\r\nmemset(data, 0, bv->bv_len);\r\nflush_dcache_page(bv->bv_page);\r\nbvec_kunmap_irq(data, &flags);\r\n}\r\n}\r\nvoid bio_put(struct bio *bio)\r\n{\r\nBIO_BUG_ON(!atomic_read(&bio->bi_cnt));\r\nif (atomic_dec_and_test(&bio->bi_cnt))\r\nbio_free(bio);\r\n}\r\ninline int bio_phys_segments(struct request_queue *q, struct bio *bio)\r\n{\r\nif (unlikely(!bio_flagged(bio, BIO_SEG_VALID)))\r\nblk_recount_segments(q, bio);\r\nreturn bio->bi_phys_segments;\r\n}\r\nvoid __bio_clone(struct bio *bio, struct bio *bio_src)\r\n{\r\nmemcpy(bio->bi_io_vec, bio_src->bi_io_vec,\r\nbio_src->bi_max_vecs * sizeof(struct bio_vec));\r\nbio->bi_sector = bio_src->bi_sector;\r\nbio->bi_bdev = bio_src->bi_bdev;\r\nbio->bi_flags |= 1 << BIO_CLONED;\r\nbio->bi_rw = bio_src->bi_rw;\r\nbio->bi_vcnt = bio_src->bi_vcnt;\r\nbio->bi_size = bio_src->bi_size;\r\nbio->bi_idx = bio_src->bi_idx;\r\n}\r\nstruct bio *bio_clone_bioset(struct bio *bio, gfp_t gfp_mask,\r\nstruct bio_set *bs)\r\n{\r\nstruct bio *b;\r\nb = bio_alloc_bioset(gfp_mask, bio->bi_max_vecs, bs);\r\nif (!b)\r\nreturn NULL;\r\n__bio_clone(b, bio);\r\nif (bio_integrity(bio)) {\r\nint ret;\r\nret = bio_integrity_clone(b, bio, gfp_mask);\r\nif (ret < 0) {\r\nbio_put(b);\r\nreturn NULL;\r\n}\r\n}\r\nreturn b;\r\n}\r\nint bio_get_nr_vecs(struct block_device *bdev)\r\n{\r\nstruct request_queue *q = bdev_get_queue(bdev);\r\nint nr_pages;\r\nnr_pages = min_t(unsigned,\r\nqueue_max_segments(q),\r\nqueue_max_sectors(q) / (PAGE_SIZE >> 9) + 1);\r\nreturn min_t(unsigned, nr_pages, BIO_MAX_PAGES);\r\n}\r\nstatic int __bio_add_page(struct request_queue *q, struct bio *bio, struct page\r\n*page, unsigned int len, unsigned int offset,\r\nunsigned short max_sectors)\r\n{\r\nint retried_segments = 0;\r\nstruct bio_vec *bvec;\r\nif (unlikely(bio_flagged(bio, BIO_CLONED)))\r\nreturn 0;\r\nif (((bio->bi_size + len) >> 9) > max_sectors)\r\nreturn 0;\r\nif (bio->bi_vcnt > 0) {\r\nstruct bio_vec *prev = &bio->bi_io_vec[bio->bi_vcnt - 1];\r\nif (page == prev->bv_page &&\r\noffset == prev->bv_offset + prev->bv_len) {\r\nunsigned int prev_bv_len = prev->bv_len;\r\nprev->bv_len += len;\r\nif (q->merge_bvec_fn) {\r\nstruct bvec_merge_data bvm = {\r\n.bi_bdev = bio->bi_bdev,\r\n.bi_sector = bio->bi_sector,\r\n.bi_size = bio->bi_size - prev_bv_len,\r\n.bi_rw = bio->bi_rw,\r\n};\r\nif (q->merge_bvec_fn(q, &bvm, prev) < prev->bv_len) {\r\nprev->bv_len -= len;\r\nreturn 0;\r\n}\r\n}\r\ngoto done;\r\n}\r\n}\r\nif (bio->bi_vcnt >= bio->bi_max_vecs)\r\nreturn 0;\r\nwhile (bio->bi_phys_segments >= queue_max_segments(q)) {\r\nif (retried_segments)\r\nreturn 0;\r\nretried_segments = 1;\r\nblk_recount_segments(q, bio);\r\n}\r\nbvec = &bio->bi_io_vec[bio->bi_vcnt];\r\nbvec->bv_page = page;\r\nbvec->bv_len = len;\r\nbvec->bv_offset = offset;\r\nif (q->merge_bvec_fn) {\r\nstruct bvec_merge_data bvm = {\r\n.bi_bdev = bio->bi_bdev,\r\n.bi_sector = bio->bi_sector,\r\n.bi_size = bio->bi_size,\r\n.bi_rw = bio->bi_rw,\r\n};\r\nif (q->merge_bvec_fn(q, &bvm, bvec) < bvec->bv_len) {\r\nbvec->bv_page = NULL;\r\nbvec->bv_len = 0;\r\nbvec->bv_offset = 0;\r\nreturn 0;\r\n}\r\n}\r\nif (bio->bi_vcnt && (BIOVEC_PHYS_MERGEABLE(bvec-1, bvec)))\r\nbio->bi_flags &= ~(1 << BIO_SEG_VALID);\r\nbio->bi_vcnt++;\r\nbio->bi_phys_segments++;\r\ndone:\r\nbio->bi_size += len;\r\nreturn len;\r\n}\r\nint bio_add_pc_page(struct request_queue *q, struct bio *bio, struct page *page,\r\nunsigned int len, unsigned int offset)\r\n{\r\nreturn __bio_add_page(q, bio, page, len, offset,\r\nqueue_max_hw_sectors(q));\r\n}\r\nint bio_add_page(struct bio *bio, struct page *page, unsigned int len,\r\nunsigned int offset)\r\n{\r\nstruct request_queue *q = bdev_get_queue(bio->bi_bdev);\r\nreturn __bio_add_page(q, bio, page, len, offset, queue_max_sectors(q));\r\n}\r\nstatic void bio_set_map_data(struct bio_map_data *bmd, struct bio *bio,\r\nstruct sg_iovec *iov, int iov_count,\r\nint is_our_pages)\r\n{\r\nmemcpy(bmd->iovecs, bio->bi_io_vec, sizeof(struct bio_vec) * bio->bi_vcnt);\r\nmemcpy(bmd->sgvecs, iov, sizeof(struct sg_iovec) * iov_count);\r\nbmd->nr_sgvecs = iov_count;\r\nbmd->is_our_pages = is_our_pages;\r\nbio->bi_private = bmd;\r\n}\r\nstatic void bio_free_map_data(struct bio_map_data *bmd)\r\n{\r\nkfree(bmd->iovecs);\r\nkfree(bmd->sgvecs);\r\nkfree(bmd);\r\n}\r\nstatic struct bio_map_data *bio_alloc_map_data(int nr_segs,\r\nunsigned int iov_count,\r\ngfp_t gfp_mask)\r\n{\r\nstruct bio_map_data *bmd;\r\nif (iov_count > UIO_MAXIOV)\r\nreturn NULL;\r\nbmd = kmalloc(sizeof(*bmd), gfp_mask);\r\nif (!bmd)\r\nreturn NULL;\r\nbmd->iovecs = kmalloc(sizeof(struct bio_vec) * nr_segs, gfp_mask);\r\nif (!bmd->iovecs) {\r\nkfree(bmd);\r\nreturn NULL;\r\n}\r\nbmd->sgvecs = kmalloc(sizeof(struct sg_iovec) * iov_count, gfp_mask);\r\nif (bmd->sgvecs)\r\nreturn bmd;\r\nkfree(bmd->iovecs);\r\nkfree(bmd);\r\nreturn NULL;\r\n}\r\nstatic int __bio_copy_iov(struct bio *bio, struct bio_vec *iovecs,\r\nstruct sg_iovec *iov, int iov_count,\r\nint to_user, int from_user, int do_free_page)\r\n{\r\nint ret = 0, i;\r\nstruct bio_vec *bvec;\r\nint iov_idx = 0;\r\nunsigned int iov_off = 0;\r\n__bio_for_each_segment(bvec, bio, i, 0) {\r\nchar *bv_addr = page_address(bvec->bv_page);\r\nunsigned int bv_len = iovecs[i].bv_len;\r\nwhile (bv_len && iov_idx < iov_count) {\r\nunsigned int bytes;\r\nchar __user *iov_addr;\r\nbytes = min_t(unsigned int,\r\niov[iov_idx].iov_len - iov_off, bv_len);\r\niov_addr = iov[iov_idx].iov_base + iov_off;\r\nif (!ret) {\r\nif (to_user)\r\nret = copy_to_user(iov_addr, bv_addr,\r\nbytes);\r\nif (from_user)\r\nret = copy_from_user(bv_addr, iov_addr,\r\nbytes);\r\nif (ret)\r\nret = -EFAULT;\r\n}\r\nbv_len -= bytes;\r\nbv_addr += bytes;\r\niov_addr += bytes;\r\niov_off += bytes;\r\nif (iov[iov_idx].iov_len == iov_off) {\r\niov_idx++;\r\niov_off = 0;\r\n}\r\n}\r\nif (do_free_page)\r\n__free_page(bvec->bv_page);\r\n}\r\nreturn ret;\r\n}\r\nint bio_uncopy_user(struct bio *bio)\r\n{\r\nstruct bio_map_data *bmd = bio->bi_private;\r\nint ret = 0;\r\nif (!bio_flagged(bio, BIO_NULL_MAPPED))\r\nret = __bio_copy_iov(bio, bmd->iovecs, bmd->sgvecs,\r\nbmd->nr_sgvecs, bio_data_dir(bio) == READ,\r\n0, bmd->is_our_pages);\r\nbio_free_map_data(bmd);\r\nbio_put(bio);\r\nreturn ret;\r\n}\r\nstruct bio *bio_copy_user_iov(struct request_queue *q,\r\nstruct rq_map_data *map_data,\r\nstruct sg_iovec *iov, int iov_count,\r\nint write_to_vm, gfp_t gfp_mask)\r\n{\r\nstruct bio_map_data *bmd;\r\nstruct bio_vec *bvec;\r\nstruct page *page;\r\nstruct bio *bio;\r\nint i, ret;\r\nint nr_pages = 0;\r\nunsigned int len = 0;\r\nunsigned int offset = map_data ? map_data->offset & ~PAGE_MASK : 0;\r\nfor (i = 0; i < iov_count; i++) {\r\nunsigned long uaddr;\r\nunsigned long end;\r\nunsigned long start;\r\nuaddr = (unsigned long)iov[i].iov_base;\r\nend = (uaddr + iov[i].iov_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nstart = uaddr >> PAGE_SHIFT;\r\nif (end < start)\r\nreturn ERR_PTR(-EINVAL);\r\nnr_pages += end - start;\r\nlen += iov[i].iov_len;\r\n}\r\nif (offset)\r\nnr_pages++;\r\nbmd = bio_alloc_map_data(nr_pages, iov_count, gfp_mask);\r\nif (!bmd)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = -ENOMEM;\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\ngoto out_bmd;\r\nif (!write_to_vm)\r\nbio->bi_rw |= REQ_WRITE;\r\nret = 0;\r\nif (map_data) {\r\nnr_pages = 1 << map_data->page_order;\r\ni = map_data->offset / PAGE_SIZE;\r\n}\r\nwhile (len) {\r\nunsigned int bytes = PAGE_SIZE;\r\nbytes -= offset;\r\nif (bytes > len)\r\nbytes = len;\r\nif (map_data) {\r\nif (i == map_data->nr_entries * nr_pages) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\npage = map_data->pages[i / nr_pages];\r\npage += (i % nr_pages);\r\ni++;\r\n} else {\r\npage = alloc_page(q->bounce_gfp | gfp_mask);\r\nif (!page) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nif (bio_add_pc_page(q, bio, page, bytes, offset) < bytes)\r\nbreak;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\nif (ret)\r\ngoto cleanup;\r\nif ((!write_to_vm && (!map_data || !map_data->null_mapped)) ||\r\n(map_data && map_data->from_user)) {\r\nret = __bio_copy_iov(bio, bio->bi_io_vec, iov, iov_count, 0, 1, 0);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nbio_set_map_data(bmd, bio, iov, iov_count, map_data ? 0 : 1);\r\nreturn bio;\r\ncleanup:\r\nif (!map_data)\r\nbio_for_each_segment(bvec, bio, i)\r\n__free_page(bvec->bv_page);\r\nbio_put(bio);\r\nout_bmd:\r\nbio_free_map_data(bmd);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct bio *bio_copy_user(struct request_queue *q, struct rq_map_data *map_data,\r\nunsigned long uaddr, unsigned int len,\r\nint write_to_vm, gfp_t gfp_mask)\r\n{\r\nstruct sg_iovec iov;\r\niov.iov_base = (void __user *)uaddr;\r\niov.iov_len = len;\r\nreturn bio_copy_user_iov(q, map_data, &iov, 1, write_to_vm, gfp_mask);\r\n}\r\nstatic struct bio *__bio_map_user_iov(struct request_queue *q,\r\nstruct block_device *bdev,\r\nstruct sg_iovec *iov, int iov_count,\r\nint write_to_vm, gfp_t gfp_mask)\r\n{\r\nint i, j;\r\nint nr_pages = 0;\r\nstruct page **pages;\r\nstruct bio *bio;\r\nint cur_page = 0;\r\nint ret, offset;\r\nfor (i = 0; i < iov_count; i++) {\r\nunsigned long uaddr = (unsigned long)iov[i].iov_base;\r\nunsigned long len = iov[i].iov_len;\r\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = uaddr >> PAGE_SHIFT;\r\nif (end < start)\r\nreturn ERR_PTR(-EINVAL);\r\nnr_pages += end - start;\r\nif (uaddr & queue_dma_alignment(q))\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!nr_pages)\r\nreturn ERR_PTR(-EINVAL);\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = -ENOMEM;\r\npages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\r\nif (!pages)\r\ngoto out;\r\nfor (i = 0; i < iov_count; i++) {\r\nunsigned long uaddr = (unsigned long)iov[i].iov_base;\r\nunsigned long len = iov[i].iov_len;\r\nunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = uaddr >> PAGE_SHIFT;\r\nconst int local_nr_pages = end - start;\r\nconst int page_limit = cur_page + local_nr_pages;\r\nret = get_user_pages_fast(uaddr, local_nr_pages,\r\nwrite_to_vm, &pages[cur_page]);\r\nif (ret < local_nr_pages) {\r\nret = -EFAULT;\r\ngoto out_unmap;\r\n}\r\noffset = uaddr & ~PAGE_MASK;\r\nfor (j = cur_page; j < page_limit; j++) {\r\nunsigned int bytes = PAGE_SIZE - offset;\r\nif (len <= 0)\r\nbreak;\r\nif (bytes > len)\r\nbytes = len;\r\nif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\r\nbytes)\r\nbreak;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\ncur_page = j;\r\nwhile (j < page_limit)\r\npage_cache_release(pages[j++]);\r\n}\r\nkfree(pages);\r\nif (!write_to_vm)\r\nbio->bi_rw |= REQ_WRITE;\r\nbio->bi_bdev = bdev;\r\nbio->bi_flags |= (1 << BIO_USER_MAPPED);\r\nreturn bio;\r\nout_unmap:\r\nfor (i = 0; i < nr_pages; i++) {\r\nif(!pages[i])\r\nbreak;\r\npage_cache_release(pages[i]);\r\n}\r\nout:\r\nkfree(pages);\r\nbio_put(bio);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct bio *bio_map_user(struct request_queue *q, struct block_device *bdev,\r\nunsigned long uaddr, unsigned int len, int write_to_vm,\r\ngfp_t gfp_mask)\r\n{\r\nstruct sg_iovec iov;\r\niov.iov_base = (void __user *)uaddr;\r\niov.iov_len = len;\r\nreturn bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, gfp_mask);\r\n}\r\nstruct bio *bio_map_user_iov(struct request_queue *q, struct block_device *bdev,\r\nstruct sg_iovec *iov, int iov_count,\r\nint write_to_vm, gfp_t gfp_mask)\r\n{\r\nstruct bio *bio;\r\nbio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm,\r\ngfp_mask);\r\nif (IS_ERR(bio))\r\nreturn bio;\r\nbio_get(bio);\r\nreturn bio;\r\n}\r\nstatic void __bio_unmap_user(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint i;\r\n__bio_for_each_segment(bvec, bio, i, 0) {\r\nif (bio_data_dir(bio) == READ)\r\nset_page_dirty_lock(bvec->bv_page);\r\npage_cache_release(bvec->bv_page);\r\n}\r\nbio_put(bio);\r\n}\r\nvoid bio_unmap_user(struct bio *bio)\r\n{\r\n__bio_unmap_user(bio);\r\nbio_put(bio);\r\n}\r\nstatic void bio_map_kern_endio(struct bio *bio, int err)\r\n{\r\nbio_put(bio);\r\n}\r\nstatic struct bio *__bio_map_kern(struct request_queue *q, void *data,\r\nunsigned int len, gfp_t gfp_mask)\r\n{\r\nunsigned long kaddr = (unsigned long)data;\r\nunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = kaddr >> PAGE_SHIFT;\r\nconst int nr_pages = end - start;\r\nint offset, i;\r\nstruct bio *bio;\r\nbio = bio_kmalloc(gfp_mask, nr_pages);\r\nif (!bio)\r\nreturn ERR_PTR(-ENOMEM);\r\noffset = offset_in_page(kaddr);\r\nfor (i = 0; i < nr_pages; i++) {\r\nunsigned int bytes = PAGE_SIZE - offset;\r\nif (len <= 0)\r\nbreak;\r\nif (bytes > len)\r\nbytes = len;\r\nif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\r\noffset) < bytes)\r\nbreak;\r\ndata += bytes;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\nbio->bi_end_io = bio_map_kern_endio;\r\nreturn bio;\r\n}\r\nstruct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\r\ngfp_t gfp_mask)\r\n{\r\nstruct bio *bio;\r\nbio = __bio_map_kern(q, data, len, gfp_mask);\r\nif (IS_ERR(bio))\r\nreturn bio;\r\nif (bio->bi_size == len)\r\nreturn bio;\r\nbio_put(bio);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void bio_copy_kern_endio(struct bio *bio, int err)\r\n{\r\nstruct bio_vec *bvec;\r\nconst int read = bio_data_dir(bio) == READ;\r\nstruct bio_map_data *bmd = bio->bi_private;\r\nint i;\r\nchar *p = bmd->sgvecs[0].iov_base;\r\n__bio_for_each_segment(bvec, bio, i, 0) {\r\nchar *addr = page_address(bvec->bv_page);\r\nint len = bmd->iovecs[i].bv_len;\r\nif (read)\r\nmemcpy(p, addr, len);\r\n__free_page(bvec->bv_page);\r\np += len;\r\n}\r\nbio_free_map_data(bmd);\r\nbio_put(bio);\r\n}\r\nstruct bio *bio_copy_kern(struct request_queue *q, void *data, unsigned int len,\r\ngfp_t gfp_mask, int reading)\r\n{\r\nstruct bio *bio;\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio = bio_copy_user(q, NULL, (unsigned long)data, len, 1, gfp_mask);\r\nif (IS_ERR(bio))\r\nreturn bio;\r\nif (!reading) {\r\nvoid *p = data;\r\nbio_for_each_segment(bvec, bio, i) {\r\nchar *addr = page_address(bvec->bv_page);\r\nmemcpy(addr, p, bvec->bv_len);\r\np += bvec->bv_len;\r\n}\r\n}\r\nbio->bi_end_io = bio_copy_kern_endio;\r\nreturn bio;\r\n}\r\nvoid bio_set_pages_dirty(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nint i;\r\nfor (i = 0; i < bio->bi_vcnt; i++) {\r\nstruct page *page = bvec[i].bv_page;\r\nif (page && !PageCompound(page))\r\nset_page_dirty_lock(page);\r\n}\r\n}\r\nstatic void bio_release_pages(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nint i;\r\nfor (i = 0; i < bio->bi_vcnt; i++) {\r\nstruct page *page = bvec[i].bv_page;\r\nif (page)\r\nput_page(page);\r\n}\r\n}\r\nstatic void bio_dirty_fn(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct bio *bio;\r\nspin_lock_irqsave(&bio_dirty_lock, flags);\r\nbio = bio_dirty_list;\r\nbio_dirty_list = NULL;\r\nspin_unlock_irqrestore(&bio_dirty_lock, flags);\r\nwhile (bio) {\r\nstruct bio *next = bio->bi_private;\r\nbio_set_pages_dirty(bio);\r\nbio_release_pages(bio);\r\nbio_put(bio);\r\nbio = next;\r\n}\r\n}\r\nvoid bio_check_pages_dirty(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nint nr_clean_pages = 0;\r\nint i;\r\nfor (i = 0; i < bio->bi_vcnt; i++) {\r\nstruct page *page = bvec[i].bv_page;\r\nif (PageDirty(page) || PageCompound(page)) {\r\npage_cache_release(page);\r\nbvec[i].bv_page = NULL;\r\n} else {\r\nnr_clean_pages++;\r\n}\r\n}\r\nif (nr_clean_pages) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&bio_dirty_lock, flags);\r\nbio->bi_private = bio_dirty_list;\r\nbio_dirty_list = bio;\r\nspin_unlock_irqrestore(&bio_dirty_lock, flags);\r\nschedule_work(&bio_dirty_work);\r\n} else {\r\nbio_put(bio);\r\n}\r\n}\r\nvoid bio_flush_dcache_pages(struct bio *bi)\r\n{\r\nint i;\r\nstruct bio_vec *bvec;\r\nbio_for_each_segment(bvec, bi, i)\r\nflush_dcache_page(bvec->bv_page);\r\n}\r\nvoid bio_endio(struct bio *bio, int error)\r\n{\r\nif (error)\r\nclear_bit(BIO_UPTODATE, &bio->bi_flags);\r\nelse if (!test_bit(BIO_UPTODATE, &bio->bi_flags))\r\nerror = -EIO;\r\nif (bio->bi_end_io)\r\nbio->bi_end_io(bio, error);\r\n}\r\nvoid bio_pair_release(struct bio_pair *bp)\r\n{\r\nif (atomic_dec_and_test(&bp->cnt)) {\r\nstruct bio *master = bp->bio1.bi_private;\r\nbio_endio(master, bp->error);\r\nmempool_free(bp, bp->bio2.bi_private);\r\n}\r\n}\r\nstatic void bio_pair_end_1(struct bio *bi, int err)\r\n{\r\nstruct bio_pair *bp = container_of(bi, struct bio_pair, bio1);\r\nif (err)\r\nbp->error = err;\r\nbio_pair_release(bp);\r\n}\r\nstatic void bio_pair_end_2(struct bio *bi, int err)\r\n{\r\nstruct bio_pair *bp = container_of(bi, struct bio_pair, bio2);\r\nif (err)\r\nbp->error = err;\r\nbio_pair_release(bp);\r\n}\r\nstruct bio_pair *bio_split(struct bio *bi, int first_sectors)\r\n{\r\nstruct bio_pair *bp = mempool_alloc(bio_split_pool, GFP_NOIO);\r\nif (!bp)\r\nreturn bp;\r\ntrace_block_split(bdev_get_queue(bi->bi_bdev), bi,\r\nbi->bi_sector + first_sectors);\r\nBUG_ON(bi->bi_vcnt != 1 && bi->bi_vcnt != 0);\r\nBUG_ON(bi->bi_idx != 0);\r\natomic_set(&bp->cnt, 3);\r\nbp->error = 0;\r\nbp->bio1 = *bi;\r\nbp->bio2 = *bi;\r\nbp->bio2.bi_sector += first_sectors;\r\nbp->bio2.bi_size -= first_sectors << 9;\r\nbp->bio1.bi_size = first_sectors << 9;\r\nif (bi->bi_vcnt != 0) {\r\nbp->bv1 = bi->bi_io_vec[0];\r\nbp->bv2 = bi->bi_io_vec[0];\r\nif (bio_is_rw(bi)) {\r\nbp->bv2.bv_offset += first_sectors << 9;\r\nbp->bv2.bv_len -= first_sectors << 9;\r\nbp->bv1.bv_len = first_sectors << 9;\r\n}\r\nbp->bio1.bi_io_vec = &bp->bv1;\r\nbp->bio2.bi_io_vec = &bp->bv2;\r\nbp->bio1.bi_max_vecs = 1;\r\nbp->bio2.bi_max_vecs = 1;\r\n}\r\nbp->bio1.bi_end_io = bio_pair_end_1;\r\nbp->bio2.bi_end_io = bio_pair_end_2;\r\nbp->bio1.bi_private = bi;\r\nbp->bio2.bi_private = bio_split_pool;\r\nif (bio_integrity(bi))\r\nbio_integrity_split(bi, bp, first_sectors);\r\nreturn bp;\r\n}\r\nsector_t bio_sector_offset(struct bio *bio, unsigned short index,\r\nunsigned int offset)\r\n{\r\nunsigned int sector_sz;\r\nstruct bio_vec *bv;\r\nsector_t sectors;\r\nint i;\r\nsector_sz = queue_logical_block_size(bio->bi_bdev->bd_disk->queue);\r\nsectors = 0;\r\nif (index >= bio->bi_idx)\r\nindex = bio->bi_vcnt - 1;\r\n__bio_for_each_segment(bv, bio, i, 0) {\r\nif (i == index) {\r\nif (offset > bv->bv_offset)\r\nsectors += (offset - bv->bv_offset) / sector_sz;\r\nbreak;\r\n}\r\nsectors += bv->bv_len / sector_sz;\r\n}\r\nreturn sectors;\r\n}\r\nstatic int biovec_create_pools(struct bio_set *bs, int pool_entries)\r\n{\r\nstruct biovec_slab *bp = bvec_slabs + BIOVEC_MAX_IDX;\r\nbs->bvec_pool = mempool_create_slab_pool(pool_entries, bp->slab);\r\nif (!bs->bvec_pool)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void biovec_free_pools(struct bio_set *bs)\r\n{\r\nmempool_destroy(bs->bvec_pool);\r\n}\r\nvoid bioset_free(struct bio_set *bs)\r\n{\r\nif (bs->bio_pool)\r\nmempool_destroy(bs->bio_pool);\r\nbioset_integrity_free(bs);\r\nbiovec_free_pools(bs);\r\nbio_put_slab(bs);\r\nkfree(bs);\r\n}\r\nstruct bio_set *bioset_create(unsigned int pool_size, unsigned int front_pad)\r\n{\r\nunsigned int back_pad = BIO_INLINE_VECS * sizeof(struct bio_vec);\r\nstruct bio_set *bs;\r\nbs = kzalloc(sizeof(*bs), GFP_KERNEL);\r\nif (!bs)\r\nreturn NULL;\r\nbs->front_pad = front_pad;\r\nbs->bio_slab = bio_find_or_create_slab(front_pad + back_pad);\r\nif (!bs->bio_slab) {\r\nkfree(bs);\r\nreturn NULL;\r\n}\r\nbs->bio_pool = mempool_create_slab_pool(pool_size, bs->bio_slab);\r\nif (!bs->bio_pool)\r\ngoto bad;\r\nif (!biovec_create_pools(bs, pool_size))\r\nreturn bs;\r\nbad:\r\nbioset_free(bs);\r\nreturn NULL;\r\n}\r\nint bio_associate_current(struct bio *bio)\r\n{\r\nstruct io_context *ioc;\r\nstruct cgroup_subsys_state *css;\r\nif (bio->bi_ioc)\r\nreturn -EBUSY;\r\nioc = current->io_context;\r\nif (!ioc)\r\nreturn -ENOENT;\r\nget_io_context_active(ioc);\r\nbio->bi_ioc = ioc;\r\nrcu_read_lock();\r\ncss = task_subsys_state(current, blkio_subsys_id);\r\nif (css && css_tryget(css))\r\nbio->bi_css = css;\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nvoid bio_disassociate_task(struct bio *bio)\r\n{\r\nif (bio->bi_ioc) {\r\nput_io_context(bio->bi_ioc);\r\nbio->bi_ioc = NULL;\r\n}\r\nif (bio->bi_css) {\r\ncss_put(bio->bi_css);\r\nbio->bi_css = NULL;\r\n}\r\n}\r\nstatic void __init biovec_init_slabs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < BIOVEC_NR_POOLS; i++) {\r\nint size;\r\nstruct biovec_slab *bvs = bvec_slabs + i;\r\nif (bvs->nr_vecs <= BIO_INLINE_VECS) {\r\nbvs->slab = NULL;\r\ncontinue;\r\n}\r\nsize = bvs->nr_vecs * sizeof(struct bio_vec);\r\nbvs->slab = kmem_cache_create(bvs->name, size, 0,\r\nSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\r\n}\r\n}\r\nstatic int __init init_bio(void)\r\n{\r\nbio_slab_max = 2;\r\nbio_slab_nr = 0;\r\nbio_slabs = kzalloc(bio_slab_max * sizeof(struct bio_slab), GFP_KERNEL);\r\nif (!bio_slabs)\r\npanic("bio: can't allocate bios\n");\r\nbio_integrity_init();\r\nbiovec_init_slabs();\r\nfs_bio_set = bioset_create(BIO_POOL_SIZE, 0);\r\nif (!fs_bio_set)\r\npanic("bio: can't allocate bios\n");\r\nif (bioset_integrity_create(fs_bio_set, BIO_POOL_SIZE))\r\npanic("bio: can't create integrity pool\n");\r\nbio_split_pool = mempool_create_kmalloc_pool(BIO_SPLIT_ENTRIES,\r\nsizeof(struct bio_pair));\r\nif (!bio_split_pool)\r\npanic("bio: can't create split pool\n");\r\nreturn 0;\r\n}
