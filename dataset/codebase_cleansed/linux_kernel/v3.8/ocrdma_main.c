static int ocrdma_get_instance(void)\r\n{\r\nint instance = 0;\r\nif (!idr_pre_get(&ocrdma_dev_id, GFP_KERNEL))\r\nreturn -1;\r\nif (idr_get_new(&ocrdma_dev_id, NULL, &instance))\r\nreturn -1;\r\nreturn instance;\r\n}\r\nvoid ocrdma_get_guid(struct ocrdma_dev *dev, u8 *guid)\r\n{\r\nu8 mac_addr[6];\r\nmemcpy(&mac_addr[0], &dev->nic_info.mac_addr[0], ETH_ALEN);\r\nguid[0] = mac_addr[0] ^ 2;\r\nguid[1] = mac_addr[1];\r\nguid[2] = mac_addr[2];\r\nguid[3] = 0xff;\r\nguid[4] = 0xfe;\r\nguid[5] = mac_addr[3];\r\nguid[6] = mac_addr[4];\r\nguid[7] = mac_addr[5];\r\n}\r\nstatic void ocrdma_build_sgid_mac(union ib_gid *sgid, unsigned char *mac_addr,\r\nbool is_vlan, u16 vlan_id)\r\n{\r\nsgid->global.subnet_prefix = cpu_to_be64(0xfe80000000000000LL);\r\nsgid->raw[8] = mac_addr[0] ^ 2;\r\nsgid->raw[9] = mac_addr[1];\r\nsgid->raw[10] = mac_addr[2];\r\nif (is_vlan) {\r\nsgid->raw[11] = vlan_id >> 8;\r\nsgid->raw[12] = vlan_id & 0xff;\r\n} else {\r\nsgid->raw[11] = 0xff;\r\nsgid->raw[12] = 0xfe;\r\n}\r\nsgid->raw[13] = mac_addr[3];\r\nsgid->raw[14] = mac_addr[4];\r\nsgid->raw[15] = mac_addr[5];\r\n}\r\nstatic bool ocrdma_add_sgid(struct ocrdma_dev *dev, unsigned char *mac_addr,\r\nbool is_vlan, u16 vlan_id)\r\n{\r\nint i;\r\nunion ib_gid new_sgid;\r\nunsigned long flags;\r\nmemset(&ocrdma_zero_sgid, 0, sizeof(union ib_gid));\r\nocrdma_build_sgid_mac(&new_sgid, mac_addr, is_vlan, vlan_id);\r\nspin_lock_irqsave(&dev->sgid_lock, flags);\r\nfor (i = 0; i < OCRDMA_MAX_SGID; i++) {\r\nif (!memcmp(&dev->sgid_tbl[i], &ocrdma_zero_sgid,\r\nsizeof(union ib_gid))) {\r\nmemcpy(&dev->sgid_tbl[i], &new_sgid,\r\nsizeof(union ib_gid));\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn true;\r\n} else if (!memcmp(&dev->sgid_tbl[i], &new_sgid,\r\nsizeof(union ib_gid))) {\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn false;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn false;\r\n}\r\nstatic bool ocrdma_del_sgid(struct ocrdma_dev *dev, unsigned char *mac_addr,\r\nbool is_vlan, u16 vlan_id)\r\n{\r\nint found = false;\r\nint i;\r\nunion ib_gid sgid;\r\nunsigned long flags;\r\nocrdma_build_sgid_mac(&sgid, mac_addr, is_vlan, vlan_id);\r\nspin_lock_irqsave(&dev->sgid_lock, flags);\r\nfor (i = 1; i < OCRDMA_MAX_SGID; i++) {\r\nif (!memcmp(&dev->sgid_tbl[i], &sgid, sizeof(union ib_gid))) {\r\nmemset(&dev->sgid_tbl[i], 0, sizeof(union ib_gid));\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn found;\r\n}\r\nstatic void ocrdma_add_default_sgid(struct ocrdma_dev *dev)\r\n{\r\nunion ib_gid *sgid = &dev->sgid_tbl[0];\r\nsgid->global.subnet_prefix = cpu_to_be64(0xfe80000000000000LL);\r\nocrdma_get_guid(dev, &sgid->raw[8]);\r\n}\r\nstatic void ocrdma_add_vlan_sgids(struct ocrdma_dev *dev)\r\n{\r\nstruct net_device *netdev, *tmp;\r\nu16 vlan_id;\r\nbool is_vlan;\r\nnetdev = dev->nic_info.netdev;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, tmp) {\r\nif (netdev == tmp || vlan_dev_real_dev(tmp) == netdev) {\r\nif (!netif_running(tmp) || !netif_oper_up(tmp))\r\ncontinue;\r\nif (netdev != tmp) {\r\nvlan_id = vlan_dev_vlan_id(tmp);\r\nis_vlan = true;\r\n} else {\r\nis_vlan = false;\r\nvlan_id = 0;\r\ntmp = netdev;\r\n}\r\nocrdma_add_sgid(dev, tmp->dev_addr, is_vlan, vlan_id);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void ocrdma_add_vlan_sgids(struct ocrdma_dev *dev)\r\n{\r\n}\r\nstatic int ocrdma_build_sgid_tbl(struct ocrdma_dev *dev)\r\n{\r\nocrdma_add_default_sgid(dev);\r\nocrdma_add_vlan_sgids(dev);\r\nreturn 0;\r\n}\r\nstatic int ocrdma_inet6addr_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\r\nstruct net_device *netdev = ifa->idev->dev;\r\nstruct ib_event gid_event;\r\nstruct ocrdma_dev *dev;\r\nbool found = false;\r\nbool updated = false;\r\nbool is_vlan = false;\r\nu16 vid = 0;\r\nis_vlan = netdev->priv_flags & IFF_802_1Q_VLAN;\r\nif (is_vlan) {\r\nvid = vlan_dev_vlan_id(netdev);\r\nnetdev = vlan_dev_real_dev(netdev);\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(dev, &ocrdma_dev_list, entry) {\r\nif (dev->nic_info.netdev == netdev) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!found)\r\nreturn NOTIFY_DONE;\r\nif (!rdma_link_local_addr((struct in6_addr *)&ifa->addr))\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&dev->dev_lock);\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nupdated = ocrdma_add_sgid(dev, netdev->dev_addr, is_vlan, vid);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nupdated = ocrdma_del_sgid(dev, netdev->dev_addr, is_vlan, vid);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (updated) {\r\ngid_event.device = &dev->ibdev;\r\ngid_event.element.port_num = 1;\r\ngid_event.event = IB_EVENT_GID_CHANGE;\r\nib_dispatch_event(&gid_event);\r\n}\r\nmutex_unlock(&dev->dev_lock);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic enum rdma_link_layer ocrdma_link_layer(struct ib_device *device,\r\nu8 port_num)\r\n{\r\nreturn IB_LINK_LAYER_ETHERNET;\r\n}\r\nstatic int ocrdma_register_device(struct ocrdma_dev *dev)\r\n{\r\nstrlcpy(dev->ibdev.name, "ocrdma%d", IB_DEVICE_NAME_MAX);\r\nocrdma_get_guid(dev, (u8 *)&dev->ibdev.node_guid);\r\nmemcpy(dev->ibdev.node_desc, OCRDMA_NODE_DESC,\r\nsizeof(OCRDMA_NODE_DESC));\r\ndev->ibdev.owner = THIS_MODULE;\r\ndev->ibdev.uverbs_cmd_mask =\r\nOCRDMA_UVERBS(GET_CONTEXT) |\r\nOCRDMA_UVERBS(QUERY_DEVICE) |\r\nOCRDMA_UVERBS(QUERY_PORT) |\r\nOCRDMA_UVERBS(ALLOC_PD) |\r\nOCRDMA_UVERBS(DEALLOC_PD) |\r\nOCRDMA_UVERBS(REG_MR) |\r\nOCRDMA_UVERBS(DEREG_MR) |\r\nOCRDMA_UVERBS(CREATE_COMP_CHANNEL) |\r\nOCRDMA_UVERBS(CREATE_CQ) |\r\nOCRDMA_UVERBS(RESIZE_CQ) |\r\nOCRDMA_UVERBS(DESTROY_CQ) |\r\nOCRDMA_UVERBS(REQ_NOTIFY_CQ) |\r\nOCRDMA_UVERBS(CREATE_QP) |\r\nOCRDMA_UVERBS(MODIFY_QP) |\r\nOCRDMA_UVERBS(QUERY_QP) |\r\nOCRDMA_UVERBS(DESTROY_QP) |\r\nOCRDMA_UVERBS(POLL_CQ) |\r\nOCRDMA_UVERBS(POST_SEND) |\r\nOCRDMA_UVERBS(POST_RECV);\r\ndev->ibdev.uverbs_cmd_mask |=\r\nOCRDMA_UVERBS(CREATE_AH) |\r\nOCRDMA_UVERBS(MODIFY_AH) |\r\nOCRDMA_UVERBS(QUERY_AH) |\r\nOCRDMA_UVERBS(DESTROY_AH);\r\ndev->ibdev.node_type = RDMA_NODE_IB_CA;\r\ndev->ibdev.phys_port_cnt = 1;\r\ndev->ibdev.num_comp_vectors = 1;\r\ndev->ibdev.query_device = ocrdma_query_device;\r\ndev->ibdev.query_port = ocrdma_query_port;\r\ndev->ibdev.modify_port = ocrdma_modify_port;\r\ndev->ibdev.query_gid = ocrdma_query_gid;\r\ndev->ibdev.get_link_layer = ocrdma_link_layer;\r\ndev->ibdev.alloc_pd = ocrdma_alloc_pd;\r\ndev->ibdev.dealloc_pd = ocrdma_dealloc_pd;\r\ndev->ibdev.create_cq = ocrdma_create_cq;\r\ndev->ibdev.destroy_cq = ocrdma_destroy_cq;\r\ndev->ibdev.resize_cq = ocrdma_resize_cq;\r\ndev->ibdev.create_qp = ocrdma_create_qp;\r\ndev->ibdev.modify_qp = ocrdma_modify_qp;\r\ndev->ibdev.query_qp = ocrdma_query_qp;\r\ndev->ibdev.destroy_qp = ocrdma_destroy_qp;\r\ndev->ibdev.query_pkey = ocrdma_query_pkey;\r\ndev->ibdev.create_ah = ocrdma_create_ah;\r\ndev->ibdev.destroy_ah = ocrdma_destroy_ah;\r\ndev->ibdev.query_ah = ocrdma_query_ah;\r\ndev->ibdev.modify_ah = ocrdma_modify_ah;\r\ndev->ibdev.poll_cq = ocrdma_poll_cq;\r\ndev->ibdev.post_send = ocrdma_post_send;\r\ndev->ibdev.post_recv = ocrdma_post_recv;\r\ndev->ibdev.req_notify_cq = ocrdma_arm_cq;\r\ndev->ibdev.get_dma_mr = ocrdma_get_dma_mr;\r\ndev->ibdev.dereg_mr = ocrdma_dereg_mr;\r\ndev->ibdev.reg_user_mr = ocrdma_reg_user_mr;\r\ndev->ibdev.alloc_ucontext = ocrdma_alloc_ucontext;\r\ndev->ibdev.dealloc_ucontext = ocrdma_dealloc_ucontext;\r\ndev->ibdev.mmap = ocrdma_mmap;\r\ndev->ibdev.dma_device = &dev->nic_info.pdev->dev;\r\ndev->ibdev.process_mad = ocrdma_process_mad;\r\nif (dev->nic_info.dev_family == OCRDMA_GEN2_FAMILY) {\r\ndev->ibdev.uverbs_cmd_mask |=\r\nOCRDMA_UVERBS(CREATE_SRQ) |\r\nOCRDMA_UVERBS(MODIFY_SRQ) |\r\nOCRDMA_UVERBS(QUERY_SRQ) |\r\nOCRDMA_UVERBS(DESTROY_SRQ) |\r\nOCRDMA_UVERBS(POST_SRQ_RECV);\r\ndev->ibdev.create_srq = ocrdma_create_srq;\r\ndev->ibdev.modify_srq = ocrdma_modify_srq;\r\ndev->ibdev.query_srq = ocrdma_query_srq;\r\ndev->ibdev.destroy_srq = ocrdma_destroy_srq;\r\ndev->ibdev.post_srq_recv = ocrdma_post_srq_recv;\r\n}\r\nreturn ib_register_device(&dev->ibdev, NULL);\r\n}\r\nstatic int ocrdma_alloc_resources(struct ocrdma_dev *dev)\r\n{\r\nmutex_init(&dev->dev_lock);\r\ndev->sgid_tbl = kzalloc(sizeof(union ib_gid) *\r\nOCRDMA_MAX_SGID, GFP_KERNEL);\r\nif (!dev->sgid_tbl)\r\ngoto alloc_err;\r\nspin_lock_init(&dev->sgid_lock);\r\ndev->cq_tbl = kzalloc(sizeof(struct ocrdma_cq *) *\r\nOCRDMA_MAX_CQ, GFP_KERNEL);\r\nif (!dev->cq_tbl)\r\ngoto alloc_err;\r\nif (dev->attr.max_qp) {\r\ndev->qp_tbl = kzalloc(sizeof(struct ocrdma_qp *) *\r\nOCRDMA_MAX_QP, GFP_KERNEL);\r\nif (!dev->qp_tbl)\r\ngoto alloc_err;\r\n}\r\nspin_lock_init(&dev->av_tbl.lock);\r\nspin_lock_init(&dev->flush_q_lock);\r\nreturn 0;\r\nalloc_err:\r\nocrdma_err("%s(%d) error.\n", __func__, dev->id);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ocrdma_free_resources(struct ocrdma_dev *dev)\r\n{\r\nkfree(dev->qp_tbl);\r\nkfree(dev->cq_tbl);\r\nkfree(dev->sgid_tbl);\r\n}\r\nstatic struct ocrdma_dev *ocrdma_add(struct be_dev_info *dev_info)\r\n{\r\nint status = 0;\r\nstruct ocrdma_dev *dev;\r\ndev = (struct ocrdma_dev *)ib_alloc_device(sizeof(struct ocrdma_dev));\r\nif (!dev) {\r\nocrdma_err("Unable to allocate ib device\n");\r\nreturn NULL;\r\n}\r\ndev->mbx_cmd = kzalloc(sizeof(struct ocrdma_mqe_emb_cmd), GFP_KERNEL);\r\nif (!dev->mbx_cmd)\r\ngoto idr_err;\r\nmemcpy(&dev->nic_info, dev_info, sizeof(*dev_info));\r\ndev->id = ocrdma_get_instance();\r\nif (dev->id < 0)\r\ngoto idr_err;\r\nstatus = ocrdma_init_hw(dev);\r\nif (status)\r\ngoto init_err;\r\nstatus = ocrdma_alloc_resources(dev);\r\nif (status)\r\ngoto alloc_err;\r\nstatus = ocrdma_build_sgid_tbl(dev);\r\nif (status)\r\ngoto alloc_err;\r\nstatus = ocrdma_register_device(dev);\r\nif (status)\r\ngoto alloc_err;\r\nspin_lock(&ocrdma_devlist_lock);\r\nlist_add_tail_rcu(&dev->entry, &ocrdma_dev_list);\r\nspin_unlock(&ocrdma_devlist_lock);\r\nreturn dev;\r\nalloc_err:\r\nocrdma_free_resources(dev);\r\nocrdma_cleanup_hw(dev);\r\ninit_err:\r\nidr_remove(&ocrdma_dev_id, dev->id);\r\nidr_err:\r\nkfree(dev->mbx_cmd);\r\nib_dealloc_device(&dev->ibdev);\r\nocrdma_err("%s() leaving. ret=%d\n", __func__, status);\r\nreturn NULL;\r\n}\r\nstatic void ocrdma_remove_free(struct rcu_head *rcu)\r\n{\r\nstruct ocrdma_dev *dev = container_of(rcu, struct ocrdma_dev, rcu);\r\nocrdma_free_resources(dev);\r\nocrdma_cleanup_hw(dev);\r\nidr_remove(&ocrdma_dev_id, dev->id);\r\nkfree(dev->mbx_cmd);\r\nib_dealloc_device(&dev->ibdev);\r\n}\r\nstatic void ocrdma_remove(struct ocrdma_dev *dev)\r\n{\r\nib_unregister_device(&dev->ibdev);\r\nspin_lock(&ocrdma_devlist_lock);\r\nlist_del_rcu(&dev->entry);\r\nspin_unlock(&ocrdma_devlist_lock);\r\ncall_rcu(&dev->rcu, ocrdma_remove_free);\r\n}\r\nstatic int ocrdma_open(struct ocrdma_dev *dev)\r\n{\r\nstruct ib_event port_event;\r\nport_event.event = IB_EVENT_PORT_ACTIVE;\r\nport_event.element.port_num = 1;\r\nport_event.device = &dev->ibdev;\r\nib_dispatch_event(&port_event);\r\nreturn 0;\r\n}\r\nstatic int ocrdma_close(struct ocrdma_dev *dev)\r\n{\r\nint i;\r\nstruct ocrdma_qp *qp, **cur_qp;\r\nstruct ib_event err_event;\r\nstruct ib_qp_attr attrs;\r\nint attr_mask = IB_QP_STATE;\r\nattrs.qp_state = IB_QPS_ERR;\r\nmutex_lock(&dev->dev_lock);\r\nif (dev->qp_tbl) {\r\ncur_qp = dev->qp_tbl;\r\nfor (i = 0; i < OCRDMA_MAX_QP; i++) {\r\nqp = cur_qp[i];\r\nif (qp) {\r\n_ocrdma_modify_qp(&qp->ibqp, &attrs, attr_mask);\r\nerr_event.event = IB_EVENT_QP_FATAL;\r\nerr_event.element.qp = &qp->ibqp;\r\nerr_event.device = &dev->ibdev;\r\nib_dispatch_event(&err_event);\r\n}\r\n}\r\n}\r\nmutex_unlock(&dev->dev_lock);\r\nerr_event.event = IB_EVENT_PORT_ERR;\r\nerr_event.element.port_num = 1;\r\nerr_event.device = &dev->ibdev;\r\nib_dispatch_event(&err_event);\r\nreturn 0;\r\n}\r\nstatic void ocrdma_event_handler(struct ocrdma_dev *dev, u32 event)\r\n{\r\nswitch (event) {\r\ncase BE_DEV_UP:\r\nocrdma_open(dev);\r\nbreak;\r\ncase BE_DEV_DOWN:\r\nocrdma_close(dev);\r\nbreak;\r\n};\r\n}\r\nstatic void ocrdma_unregister_inet6addr_notifier(void)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nunregister_inet6addr_notifier(&ocrdma_inet6addr_notifier);\r\n#endif\r\n}\r\nstatic int __init ocrdma_init_module(void)\r\n{\r\nint status;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstatus = register_inet6addr_notifier(&ocrdma_inet6addr_notifier);\r\nif (status)\r\nreturn status;\r\n#endif\r\nstatus = be_roce_register_driver(&ocrdma_drv);\r\nif (status)\r\nocrdma_unregister_inet6addr_notifier();\r\nreturn status;\r\n}\r\nstatic void __exit ocrdma_exit_module(void)\r\n{\r\nbe_roce_unregister_driver(&ocrdma_drv);\r\nocrdma_unregister_inet6addr_notifier();\r\n}
