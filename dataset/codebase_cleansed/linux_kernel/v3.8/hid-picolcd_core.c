struct hid_report *picolcd_report(int id, struct hid_device *hdev, int dir)\r\n{\r\nstruct list_head *feature_report_list = &hdev->report_enum[dir].report_list;\r\nstruct hid_report *report = NULL;\r\nlist_for_each_entry(report, feature_report_list, list) {\r\nif (report->id == id)\r\nreturn report;\r\n}\r\nhid_warn(hdev, "No report with id 0x%x found\n", id);\r\nreturn NULL;\r\n}\r\nstruct picolcd_pending *picolcd_send_and_wait(struct hid_device *hdev,\r\nint report_id, const u8 *raw_data, int size)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct picolcd_pending *work;\r\nstruct hid_report *report = picolcd_out_report(report_id, hdev);\r\nunsigned long flags;\r\nint i, j, k;\r\nif (!report || !data)\r\nreturn NULL;\r\nif (data->status & PICOLCD_FAILED)\r\nreturn NULL;\r\nwork = kzalloc(sizeof(*work), GFP_KERNEL);\r\nif (!work)\r\nreturn NULL;\r\ninit_completion(&work->ready);\r\nwork->out_report = report;\r\nwork->in_report = NULL;\r\nwork->raw_size = 0;\r\nmutex_lock(&data->mutex);\r\nspin_lock_irqsave(&data->lock, flags);\r\nfor (i = k = 0; i < report->maxfield; i++)\r\nfor (j = 0; j < report->field[i]->report_count; j++) {\r\nhid_set_field(report->field[i], j, k < size ? raw_data[k] : 0);\r\nk++;\r\n}\r\nif (data->status & PICOLCD_FAILED) {\r\nkfree(work);\r\nwork = NULL;\r\n} else {\r\ndata->pending = work;\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nwait_for_completion_interruptible_timeout(&work->ready, HZ*2);\r\nspin_lock_irqsave(&data->lock, flags);\r\ndata->pending = NULL;\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nmutex_unlock(&data->mutex);\r\nreturn work;\r\n}\r\nstatic int picolcd_raw_keypad(struct picolcd_data *data,\r\nstruct hid_report *report, u8 *raw_data, int size)\r\n{\r\nint i, j;\r\nfor (i = 0; i < size; i++) {\r\nunsigned int key_code;\r\nif (raw_data[i] == 0)\r\ncontinue;\r\nfor (j = 0; j < sizeof(data->pressed_keys); j++)\r\nif (data->pressed_keys[j] == raw_data[i])\r\ngoto key_already_down;\r\nfor (j = 0; j < sizeof(data->pressed_keys); j++)\r\nif (data->pressed_keys[j] == 0) {\r\ndata->pressed_keys[j] = raw_data[i];\r\nbreak;\r\n}\r\ninput_event(data->input_keys, EV_MSC, MSC_SCAN, raw_data[i]);\r\nif (raw_data[i] < PICOLCD_KEYS)\r\nkey_code = data->keycode[raw_data[i]];\r\nelse\r\nkey_code = KEY_UNKNOWN;\r\nif (key_code != KEY_UNKNOWN) {\r\ndbg_hid(PICOLCD_NAME " got key press for %u:%d",\r\nraw_data[i], key_code);\r\ninput_report_key(data->input_keys, key_code, 1);\r\n}\r\ninput_sync(data->input_keys);\r\nkey_already_down:\r\ncontinue;\r\n}\r\nfor (j = 0; j < sizeof(data->pressed_keys); j++) {\r\nunsigned int key_code;\r\nif (data->pressed_keys[j] == 0)\r\ncontinue;\r\nfor (i = 0; i < size; i++)\r\nif (data->pressed_keys[j] == raw_data[i])\r\ngoto key_still_down;\r\ninput_event(data->input_keys, EV_MSC, MSC_SCAN, data->pressed_keys[j]);\r\nif (data->pressed_keys[j] < PICOLCD_KEYS)\r\nkey_code = data->keycode[data->pressed_keys[j]];\r\nelse\r\nkey_code = KEY_UNKNOWN;\r\nif (key_code != KEY_UNKNOWN) {\r\ndbg_hid(PICOLCD_NAME " got key release for %u:%d",\r\ndata->pressed_keys[j], key_code);\r\ninput_report_key(data->input_keys, key_code, 0);\r\n}\r\ninput_sync(data->input_keys);\r\ndata->pressed_keys[j] = 0;\r\nkey_still_down:\r\ncontinue;\r\n}\r\nreturn 1;\r\n}\r\nstatic int picolcd_check_version(struct hid_device *hdev)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct picolcd_pending *verinfo;\r\nint ret = 0;\r\nif (!data)\r\nreturn -ENODEV;\r\nverinfo = picolcd_send_and_wait(hdev, REPORT_VERSION, NULL, 0);\r\nif (!verinfo) {\r\nhid_err(hdev, "no version response from PicoLCD\n");\r\nreturn -ENODEV;\r\n}\r\nif (verinfo->raw_size == 2) {\r\ndata->version[0] = verinfo->raw_data[1];\r\ndata->version[1] = verinfo->raw_data[0];\r\nif (data->status & PICOLCD_BOOTLOADER) {\r\nhid_info(hdev, "PicoLCD, bootloader version %d.%d\n",\r\nverinfo->raw_data[1], verinfo->raw_data[0]);\r\n} else {\r\nhid_info(hdev, "PicoLCD, firmware version %d.%d\n",\r\nverinfo->raw_data[1], verinfo->raw_data[0]);\r\n}\r\n} else {\r\nhid_err(hdev, "confused, got unexpected version response from PicoLCD\n");\r\nret = -EINVAL;\r\n}\r\nkfree(verinfo);\r\nreturn ret;\r\n}\r\nint picolcd_reset(struct hid_device *hdev)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nstruct hid_report *report = picolcd_out_report(REPORT_RESET, hdev);\r\nunsigned long flags;\r\nint error;\r\nif (!data || !report || report->maxfield != 1)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\r\ndata->status |= PICOLCD_BOOTLOADER;\r\nhid_set_field(report->field[0], 0, 1);\r\nif (data->status & PICOLCD_FAILED) {\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn -ENODEV;\r\n}\r\nusbhid_submit_report(hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nerror = picolcd_check_version(hdev);\r\nif (error)\r\nreturn error;\r\npicolcd_resume_lcd(data);\r\npicolcd_resume_backlight(data);\r\npicolcd_fb_refresh(data);\r\npicolcd_leds_set(data);\r\nreturn 0;\r\n}\r\nstatic ssize_t picolcd_operation_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nreturn snprintf(buf, PAGE_SIZE, "[bootloader] lcd\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "bootloader [lcd]\n");\r\n}\r\nstatic ssize_t picolcd_operation_mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nstruct hid_report *report = NULL;\r\nsize_t cnt = count;\r\nint timeout = data->opmode_delay;\r\nunsigned long flags;\r\nif (cnt >= 3 && strncmp("lcd", buf, 3) == 0) {\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nreport = picolcd_out_report(REPORT_EXIT_FLASHER, data->hdev);\r\nbuf += 3;\r\ncnt -= 3;\r\n} else if (cnt >= 10 && strncmp("bootloader", buf, 10) == 0) {\r\nif (!(data->status & PICOLCD_BOOTLOADER))\r\nreport = picolcd_out_report(REPORT_EXIT_KEYBOARD, data->hdev);\r\nbuf += 10;\r\ncnt -= 10;\r\n}\r\nif (!report)\r\nreturn -EINVAL;\r\nwhile (cnt > 0 && (buf[cnt-1] == '\n' || buf[cnt-1] == '\r'))\r\ncnt--;\r\nif (cnt != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report->field[0], 0, timeout & 0xff);\r\nhid_set_field(report->field[0], 1, (timeout >> 8) & 0xff);\r\nusbhid_submit_report(data->hdev, report, USB_DIR_OUT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t picolcd_operation_mode_delay_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%hu\n", data->opmode_delay);\r\n}\r\nstatic ssize_t picolcd_operation_mode_delay_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct picolcd_data *data = dev_get_drvdata(dev);\r\nunsigned u;\r\nif (sscanf(buf, "%u", &u) != 1)\r\nreturn -EINVAL;\r\nif (u > 30000)\r\nreturn -EINVAL;\r\nelse\r\ndata->opmode_delay = u;\r\nreturn count;\r\n}\r\nstatic int picolcd_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *raw_data, int size)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!data)\r\nreturn 1;\r\nif (report->id == REPORT_KEY_STATE) {\r\nif (data->input_keys)\r\nret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\r\n} else if (report->id == REPORT_IR_DATA) {\r\nret = picolcd_raw_cir(data, report, raw_data+1, size-1);\r\n} else {\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (data->pending) {\r\nmemcpy(data->pending->raw_data, raw_data+1, size-1);\r\ndata->pending->raw_size = size-1;\r\ndata->pending->in_report = report;\r\ncomplete(&data->pending->ready);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\npicolcd_debug_raw_event(data, hdev, report, raw_data, size);\r\nreturn 1;\r\n}\r\nstatic int picolcd_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\nif (PMSG_IS_AUTO(message))\r\nreturn 0;\r\npicolcd_suspend_backlight(hid_get_drvdata(hdev));\r\ndbg_hid(PICOLCD_NAME " device ready for suspend\n");\r\nreturn 0;\r\n}\r\nstatic int picolcd_resume(struct hid_device *hdev)\r\n{\r\nint ret;\r\nret = picolcd_resume_backlight(hid_get_drvdata(hdev));\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring backlight failed: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int picolcd_reset_resume(struct hid_device *hdev)\r\n{\r\nint ret;\r\nret = picolcd_reset(hdev);\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " resetting our device failed: %d\n", ret);\r\nret = picolcd_fb_reset(hid_get_drvdata(hdev), 0);\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring framebuffer content failed: %d\n", ret);\r\nret = picolcd_resume_lcd(hid_get_drvdata(hdev));\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring lcd failed: %d\n", ret);\r\nret = picolcd_resume_backlight(hid_get_drvdata(hdev));\r\nif (ret)\r\ndbg_hid(PICOLCD_NAME " restoring backlight failed: %d\n", ret);\r\npicolcd_leds_set(hid_get_drvdata(hdev));\r\nreturn 0;\r\n}\r\nstatic int picolcd_init_keys(struct picolcd_data *data,\r\nstruct hid_report *report)\r\n{\r\nstruct hid_device *hdev = data->hdev;\r\nstruct input_dev *idev;\r\nint error, i;\r\nif (!report)\r\nreturn -ENODEV;\r\nif (report->maxfield != 1 || report->field[0]->report_count != 2 ||\r\nreport->field[0]->report_size != 8) {\r\nhid_err(hdev, "unsupported KEY_STATE report\n");\r\nreturn -EINVAL;\r\n}\r\nidev = input_allocate_device();\r\nif (idev == NULL) {\r\nhid_err(hdev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_set_drvdata(idev, hdev);\r\nmemcpy(data->keycode, def_keymap, sizeof(def_keymap));\r\nidev->name = hdev->name;\r\nidev->phys = hdev->phys;\r\nidev->uniq = hdev->uniq;\r\nidev->id.bustype = hdev->bus;\r\nidev->id.vendor = hdev->vendor;\r\nidev->id.product = hdev->product;\r\nidev->id.version = hdev->version;\r\nidev->dev.parent = &hdev->dev;\r\nidev->keycode = &data->keycode;\r\nidev->keycodemax = PICOLCD_KEYS;\r\nidev->keycodesize = sizeof(data->keycode[0]);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\nset_bit(EV_REP, idev->evbit);\r\nfor (i = 0; i < PICOLCD_KEYS; i++)\r\ninput_set_capability(idev, EV_KEY, data->keycode[i]);\r\nerror = input_register_device(idev);\r\nif (error) {\r\nhid_err(hdev, "error registering the input device\n");\r\ninput_free_device(idev);\r\nreturn error;\r\n}\r\ndata->input_keys = idev;\r\nreturn 0;\r\n}\r\nstatic void picolcd_exit_keys(struct picolcd_data *data)\r\n{\r\nstruct input_dev *idev = data->input_keys;\r\ndata->input_keys = NULL;\r\nif (idev)\r\ninput_unregister_device(idev);\r\n}\r\nstatic int picolcd_probe_lcd(struct hid_device *hdev, struct picolcd_data *data)\r\n{\r\nint error;\r\nerror = picolcd_init_keys(data, picolcd_in_report(REPORT_KEY_STATE, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_cir(data, picolcd_in_report(REPORT_IR_DATA, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_framebuffer(data);\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_lcd(data, picolcd_out_report(REPORT_CONTRAST, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_backlight(data, picolcd_out_report(REPORT_BRIGHTNESS, hdev));\r\nif (error)\r\ngoto err;\r\nerror = picolcd_init_leds(data, picolcd_out_report(REPORT_LED_STATE, hdev));\r\nif (error)\r\ngoto err;\r\npicolcd_init_devfs(data, picolcd_out_report(REPORT_EE_READ, hdev),\r\npicolcd_out_report(REPORT_EE_WRITE, hdev),\r\npicolcd_out_report(REPORT_READ_MEMORY, hdev),\r\npicolcd_out_report(REPORT_WRITE_MEMORY, hdev),\r\npicolcd_out_report(REPORT_RESET, hdev));\r\nreturn 0;\r\nerr:\r\npicolcd_exit_leds(data);\r\npicolcd_exit_backlight(data);\r\npicolcd_exit_lcd(data);\r\npicolcd_exit_framebuffer(data);\r\npicolcd_exit_cir(data);\r\npicolcd_exit_keys(data);\r\nreturn error;\r\n}\r\nstatic int picolcd_probe_bootloader(struct hid_device *hdev, struct picolcd_data *data)\r\n{\r\npicolcd_init_devfs(data, NULL, NULL,\r\npicolcd_out_report(REPORT_BL_READ_MEMORY, hdev),\r\npicolcd_out_report(REPORT_BL_WRITE_MEMORY, hdev), NULL);\r\nreturn 0;\r\n}\r\nstatic int picolcd_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct picolcd_data *data;\r\nint error = -ENOMEM;\r\ndbg_hid(PICOLCD_NAME " hardware probe...\n");\r\ndata = kzalloc(sizeof(struct picolcd_data), GFP_KERNEL);\r\nif (data == NULL) {\r\nhid_err(hdev, "can't allocate space for Minibox PicoLCD device data\n");\r\nerror = -ENOMEM;\r\ngoto err_no_cleanup;\r\n}\r\nspin_lock_init(&data->lock);\r\nmutex_init(&data->mutex);\r\ndata->hdev = hdev;\r\ndata->opmode_delay = 5000;\r\nif (hdev->product == USB_DEVICE_ID_PICOLCD_BOOTLOADER)\r\ndata->status |= PICOLCD_BOOTLOADER;\r\nhid_set_drvdata(hdev, data);\r\nerror = hid_parse(hdev);\r\nif (error) {\r\nhid_err(hdev, "device report parse failed\n");\r\ngoto err_cleanup_data;\r\n}\r\nerror = hid_hw_start(hdev, 0);\r\nif (error) {\r\nhid_err(hdev, "hardware start failed\n");\r\ngoto err_cleanup_data;\r\n}\r\nerror = hid_hw_open(hdev);\r\nif (error) {\r\nhid_err(hdev, "failed to open input interrupt pipe for key and IR events\n");\r\ngoto err_cleanup_hid_hw;\r\n}\r\nerror = device_create_file(&hdev->dev, &dev_attr_operation_mode_delay);\r\nif (error) {\r\nhid_err(hdev, "failed to create sysfs attributes\n");\r\ngoto err_cleanup_hid_ll;\r\n}\r\nerror = device_create_file(&hdev->dev, &dev_attr_operation_mode);\r\nif (error) {\r\nhid_err(hdev, "failed to create sysfs attributes\n");\r\ngoto err_cleanup_sysfs1;\r\n}\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nerror = picolcd_probe_bootloader(hdev, data);\r\nelse\r\nerror = picolcd_probe_lcd(hdev, data);\r\nif (error)\r\ngoto err_cleanup_sysfs2;\r\ndbg_hid(PICOLCD_NAME " activated and initialized\n");\r\nreturn 0;\r\nerr_cleanup_sysfs2:\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\r\nerr_cleanup_sysfs1:\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\r\nerr_cleanup_hid_ll:\r\nhid_hw_close(hdev);\r\nerr_cleanup_hid_hw:\r\nhid_hw_stop(hdev);\r\nerr_cleanup_data:\r\nkfree(data);\r\nerr_no_cleanup:\r\nhid_set_drvdata(hdev, NULL);\r\nreturn error;\r\n}\r\nstatic void picolcd_remove(struct hid_device *hdev)\r\n{\r\nstruct picolcd_data *data = hid_get_drvdata(hdev);\r\nunsigned long flags;\r\ndbg_hid(PICOLCD_NAME " hardware remove...\n");\r\nspin_lock_irqsave(&data->lock, flags);\r\ndata->status |= PICOLCD_FAILED;\r\nspin_unlock_irqrestore(&data->lock, flags);\r\npicolcd_exit_devfs(data);\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\r\ndevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\nspin_lock_irqsave(&data->lock, flags);\r\nif (data->pending)\r\ncomplete(&data->pending->ready);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\npicolcd_exit_leds(data);\r\npicolcd_exit_backlight(data);\r\npicolcd_exit_lcd(data);\r\npicolcd_exit_framebuffer(data);\r\npicolcd_exit_cir(data);\r\npicolcd_exit_keys(data);\r\nhid_set_drvdata(hdev, NULL);\r\nmutex_destroy(&data->mutex);\r\nkfree(data);\r\n}\r\nstatic int __init picolcd_init(void)\r\n{\r\nreturn hid_register_driver(&picolcd_driver);\r\n}\r\nstatic void __exit picolcd_exit(void)\r\n{\r\nhid_unregister_driver(&picolcd_driver);\r\n}
