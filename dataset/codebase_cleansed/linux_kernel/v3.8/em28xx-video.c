static inline void buffer_filled(struct em28xx *dev,\r\nstruct em28xx_dmaqueue *dma_q,\r\nstruct em28xx_buffer *buf)\r\n{\r\nem28xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\ndo_gettimeofday(&buf->vb.ts);\r\ndev->isoc_ctl.vid_buf = NULL;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic inline void vbi_buffer_filled(struct em28xx *dev,\r\nstruct em28xx_dmaqueue *dma_q,\r\nstruct em28xx_buffer *buf)\r\n{\r\nem28xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\ndo_gettimeofday(&buf->vb.ts);\r\ndev->isoc_ctl.vbi_buf = NULL;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic void em28xx_copy_video(struct em28xx *dev,\r\nstruct em28xx_dmaqueue *dma_q,\r\nstruct em28xx_buffer *buf,\r\nunsigned char *p,\r\nunsigned char *outp, unsigned long len)\r\n{\r\nvoid *fieldstart, *startwrite, *startread;\r\nint linesdone, currlinedone, offset, lencopy, remain;\r\nint bytesperline = dev->width << 1;\r\nif (dma_q->pos + len > buf->vb.size)\r\nlen = buf->vb.size - dma_q->pos;\r\nstartread = p;\r\nremain = len;\r\nif (dev->progressive)\r\nfieldstart = outp;\r\nelse {\r\nif (buf->top_field)\r\nfieldstart = outp;\r\nelse\r\nfieldstart = outp + bytesperline;\r\n}\r\nlinesdone = dma_q->pos / bytesperline;\r\ncurrlinedone = dma_q->pos % bytesperline;\r\nif (dev->progressive)\r\noffset = linesdone * bytesperline + currlinedone;\r\nelse\r\noffset = linesdone * bytesperline * 2 + currlinedone;\r\nstartwrite = fieldstart + offset;\r\nlencopy = bytesperline - currlinedone;\r\nlencopy = lencopy > remain ? remain : lencopy;\r\nif ((char *)startwrite + lencopy > (char *)outp + buf->vb.size) {\r\nem28xx_isocdbg("Overflow of %zi bytes past buffer end (1)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)outp + buf->vb.size));\r\nremain = (char *)outp + buf->vb.size - (char *)startwrite;\r\nlencopy = remain;\r\n}\r\nif (lencopy <= 0)\r\nreturn;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\nwhile (remain > 0) {\r\nstartwrite += lencopy + bytesperline;\r\nstartread += lencopy;\r\nif (bytesperline > remain)\r\nlencopy = remain;\r\nelse\r\nlencopy = bytesperline;\r\nif ((char *)startwrite + lencopy > (char *)outp +\r\nbuf->vb.size) {\r\nem28xx_isocdbg("Overflow of %zi bytes past buffer end"\r\n"(2)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)outp + buf->vb.size));\r\nlencopy = remain = (char *)outp + buf->vb.size -\r\n(char *)startwrite;\r\n}\r\nif (lencopy <= 0)\r\nbreak;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\n}\r\ndma_q->pos += len;\r\n}\r\nstatic void em28xx_copy_vbi(struct em28xx *dev,\r\nstruct em28xx_dmaqueue *dma_q,\r\nstruct em28xx_buffer *buf,\r\nunsigned char *p,\r\nunsigned char *outp, unsigned long len)\r\n{\r\nvoid *startwrite, *startread;\r\nint offset;\r\nint bytesperline;\r\nif (dev == NULL) {\r\nem28xx_isocdbg("dev is null\n");\r\nreturn;\r\n}\r\nbytesperline = dev->vbi_width;\r\nif (dma_q == NULL) {\r\nem28xx_isocdbg("dma_q is null\n");\r\nreturn;\r\n}\r\nif (buf == NULL) {\r\nreturn;\r\n}\r\nif (p == NULL) {\r\nem28xx_isocdbg("p is null\n");\r\nreturn;\r\n}\r\nif (outp == NULL) {\r\nem28xx_isocdbg("outp is null\n");\r\nreturn;\r\n}\r\nif (dma_q->pos + len > buf->vb.size)\r\nlen = buf->vb.size - dma_q->pos;\r\nstartread = p;\r\nstartwrite = outp + dma_q->pos;\r\noffset = dma_q->pos;\r\nif (buf->top_field == 0) {\r\nstartwrite += bytesperline * dev->vbi_height;\r\noffset += bytesperline * dev->vbi_height;\r\n}\r\nmemcpy(startwrite, startread, len);\r\ndma_q->pos += len;\r\n}\r\nstatic inline void print_err_status(struct em28xx *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\nem28xx_isocdbg("URB status %d [%s].\n", status, errmsg);\r\n} else {\r\nem28xx_isocdbg("URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline void get_next_buf(struct em28xx_dmaqueue *dma_q,\r\nstruct em28xx_buffer **buf)\r\n{\r\nstruct em28xx *dev = container_of(dma_q, struct em28xx, vidq);\r\nchar *outp;\r\nif (list_empty(&dma_q->active)) {\r\nem28xx_isocdbg("No active queue to serve\n");\r\ndev->isoc_ctl.vid_buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct em28xx_buffer, vb.queue);\r\noutp = videobuf_to_vmalloc(&(*buf)->vb);\r\nmemset(outp, 0, (*buf)->vb.size);\r\ndev->isoc_ctl.vid_buf = *buf;\r\nreturn;\r\n}\r\nstatic inline void vbi_get_next_buf(struct em28xx_dmaqueue *dma_q,\r\nstruct em28xx_buffer **buf)\r\n{\r\nstruct em28xx *dev = container_of(dma_q, struct em28xx, vbiq);\r\nchar *outp;\r\nif (list_empty(&dma_q->active)) {\r\nem28xx_isocdbg("No active queue to serve\n");\r\ndev->isoc_ctl.vbi_buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct em28xx_buffer, vb.queue);\r\noutp = videobuf_to_vmalloc(&(*buf)->vb);\r\nmemset(outp, 0x00, (*buf)->vb.size);\r\ndev->isoc_ctl.vbi_buf = *buf;\r\nreturn;\r\n}\r\nstatic inline int em28xx_isoc_copy(struct em28xx *dev, struct urb *urb)\r\n{\r\nstruct em28xx_buffer *buf;\r\nstruct em28xx_dmaqueue *dma_q = &dev->vidq;\r\nunsigned char *outp = NULL;\r\nint i, len = 0, rc = 1;\r\nunsigned char *p;\r\nif (!dev)\r\nreturn 0;\r\nif ((dev->state & DEV_DISCONNECTED) || (dev->state & DEV_MISCONFIGURED))\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nbuf = dev->isoc_ctl.vid_buf;\r\nif (buf != NULL)\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nlen = urb->iso_frame_desc[i].actual_length - 4;\r\nif (urb->iso_frame_desc[i].actual_length <= 0) {\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length >\r\ndev->max_pkt_size) {\r\nem28xx_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\np = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (p[0] == 0x33 && p[1] == 0x95 && p[2] == 0x00) {\r\nem28xx_isocdbg("VBI HEADER!!!\n");\r\ncontinue;\r\n}\r\nif (p[0] == 0x22 && p[1] == 0x5a) {\r\nem28xx_isocdbg("Video frame %d, length=%i, %s\n", p[2],\r\nlen, (p[2] & 1) ? "odd" : "even");\r\nif (dev->progressive || !(p[2] & 1)) {\r\nif (buf != NULL)\r\nbuffer_filled(dev, dma_q, buf);\r\nget_next_buf(dma_q, &buf);\r\nif (buf == NULL)\r\noutp = NULL;\r\nelse\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\n}\r\nif (buf != NULL) {\r\nif (p[2] & 1)\r\nbuf->top_field = 0;\r\nelse\r\nbuf->top_field = 1;\r\n}\r\ndma_q->pos = 0;\r\n}\r\nif (buf != NULL) {\r\nif (p[0] != 0x88 && p[0] != 0x22) {\r\nem28xx_isocdbg("frame is not complete\n");\r\nlen += 4;\r\n} else {\r\np += 4;\r\n}\r\nem28xx_copy_video(dev, dma_q, buf, p, outp, len);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic inline int em28xx_isoc_copy_vbi(struct em28xx *dev, struct urb *urb)\r\n{\r\nstruct em28xx_buffer *buf, *vbi_buf;\r\nstruct em28xx_dmaqueue *dma_q = &dev->vidq;\r\nstruct em28xx_dmaqueue *vbi_dma_q = &dev->vbiq;\r\nunsigned char *outp = NULL;\r\nunsigned char *vbioutp = NULL;\r\nint i, len = 0, rc = 1;\r\nunsigned char *p;\r\nint vbi_size;\r\nif (!dev)\r\nreturn 0;\r\nif ((dev->state & DEV_DISCONNECTED) || (dev->state & DEV_MISCONFIGURED))\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nbuf = dev->isoc_ctl.vid_buf;\r\nif (buf != NULL)\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\nvbi_buf = dev->isoc_ctl.vbi_buf;\r\nif (vbi_buf != NULL)\r\nvbioutp = videobuf_to_vmalloc(&vbi_buf->vb);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nlen = urb->iso_frame_desc[i].actual_length;\r\nif (urb->iso_frame_desc[i].actual_length <= 0) {\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length >\r\ndev->max_pkt_size) {\r\nem28xx_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\np = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (p[0] == 0x33 && p[1] == 0x95) {\r\ndev->capture_type = 0;\r\ndev->vbi_read = 0;\r\nem28xx_isocdbg("VBI START HEADER!!!\n");\r\ndev->cur_field = p[2];\r\np += 4;\r\nlen -= 4;\r\n} else if (p[0] == 0x88 && p[1] == 0x88 &&\r\np[2] == 0x88 && p[3] == 0x88) {\r\np += 4;\r\nlen -= 4;\r\n} else if (p[0] == 0x22 && p[1] == 0x5a) {\r\np += 4;\r\nlen -= 4;\r\n}\r\nvbi_size = dev->vbi_width * dev->vbi_height;\r\nif (dev->capture_type == 0) {\r\nif (dev->vbi_read >= vbi_size) {\r\nem28xx_isocdbg("dev->vbi_read > vbi_size\n");\r\n} else if ((dev->vbi_read + len) < vbi_size) {\r\nif (dev->vbi_read == 0 &&\r\n(!(dev->cur_field & 1))) {\r\nif (vbi_buf != NULL)\r\nvbi_buffer_filled(dev,\r\nvbi_dma_q,\r\nvbi_buf);\r\nvbi_get_next_buf(vbi_dma_q, &vbi_buf);\r\nif (vbi_buf == NULL)\r\nvbioutp = NULL;\r\nelse\r\nvbioutp = videobuf_to_vmalloc(\r\n&vbi_buf->vb);\r\n}\r\nif (dev->vbi_read == 0) {\r\nvbi_dma_q->pos = 0;\r\nif (vbi_buf != NULL) {\r\nif (dev->cur_field & 1)\r\nvbi_buf->top_field = 0;\r\nelse\r\nvbi_buf->top_field = 1;\r\n}\r\n}\r\ndev->vbi_read += len;\r\nem28xx_copy_vbi(dev, vbi_dma_q, vbi_buf, p,\r\nvbioutp, len);\r\n} else {\r\nint vbi_data_len = vbi_size - dev->vbi_read;\r\ndev->vbi_read += vbi_data_len;\r\nem28xx_copy_vbi(dev, vbi_dma_q, vbi_buf, p,\r\nvbioutp, vbi_data_len);\r\ndev->capture_type = 1;\r\np += vbi_data_len;\r\nlen -= vbi_data_len;\r\n}\r\n}\r\nif (dev->capture_type == 1) {\r\ndev->capture_type = 2;\r\nif (dev->progressive || !(dev->cur_field & 1)) {\r\nif (buf != NULL)\r\nbuffer_filled(dev, dma_q, buf);\r\nget_next_buf(dma_q, &buf);\r\nif (buf == NULL)\r\noutp = NULL;\r\nelse\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\n}\r\nif (buf != NULL) {\r\nif (dev->cur_field & 1)\r\nbuf->top_field = 0;\r\nelse\r\nbuf->top_field = 1;\r\n}\r\ndma_q->pos = 0;\r\n}\r\nif (buf != NULL && dev->capture_type == 2) {\r\nif (len >= 4 && p[0] == 0x88 && p[1] == 0x88 &&\r\np[2] == 0x88 && p[3] == 0x88) {\r\np += 4;\r\nlen -= 4;\r\n}\r\nif (len >= 4 && p[0] == 0x22 && p[1] == 0x5a) {\r\nem28xx_isocdbg("Video frame %d, len=%i, %s\n",\r\np[2], len, (p[2] & 1) ?\r\n"odd" : "even");\r\np += 4;\r\nlen -= 4;\r\n}\r\nif (len > 0)\r\nem28xx_copy_video(dev, dma_q, buf, p, outp,\r\nlen);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)\r\n{\r\nstruct em28xx_fh *fh = vq->priv_data;\r\nstruct em28xx *dev = fh->dev;\r\nstruct v4l2_frequency f;\r\n*size = (fh->dev->width * fh->dev->height * dev->format->depth + 7)\r\n>> 3;\r\nif (0 == *count)\r\n*count = EM28XX_DEF_BUF;\r\nif (*count < EM28XX_MIN_BUF)\r\n*count = EM28XX_MIN_BUF;\r\nmemset(&f, 0, sizeof(f));\r\nf.frequency = dev->ctl_freq;\r\nf.type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, &f);\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct em28xx_buffer *buf)\r\n{\r\nstruct em28xx_fh *fh = vq->priv_data;\r\nstruct em28xx *dev = fh->dev;\r\nunsigned long flags = 0;\r\nif (in_interrupt())\r\nBUG();\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->isoc_ctl.vid_buf == buf)\r\ndev->isoc_ctl.vid_buf = NULL;\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct em28xx_fh *fh = vq->priv_data;\r\nstruct em28xx_buffer *buf = container_of(vb, struct em28xx_buffer, vb);\r\nstruct em28xx *dev = fh->dev;\r\nint rc = 0, urb_init = 0;\r\nbuf->vb.size = (fh->dev->width * fh->dev->height * dev->format->depth\r\n+ 7) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nbuf->vb.width = dev->width;\r\nbuf->vb.height = dev->height;\r\nbuf->vb.field = field;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nif (!dev->isoc_ctl.analog_bufs.num_bufs)\r\nurb_init = 1;\r\nif (urb_init) {\r\nif (em28xx_vbi_supported(dev) == 1)\r\nrc = em28xx_init_isoc(dev, EM28XX_ANALOG_MODE,\r\nEM28XX_NUM_PACKETS,\r\nEM28XX_NUM_BUFS,\r\ndev->max_pkt_size,\r\nem28xx_isoc_copy_vbi);\r\nelse\r\nrc = em28xx_init_isoc(dev, EM28XX_ANALOG_MODE,\r\nEM28XX_NUM_PACKETS,\r\nEM28XX_NUM_BUFS,\r\ndev->max_pkt_size,\r\nem28xx_isoc_copy);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void\r\nbuffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct em28xx_buffer *buf = container_of(vb,\r\nstruct em28xx_buffer,\r\nvb);\r\nstruct em28xx_fh *fh = vq->priv_data;\r\nstruct em28xx *dev = fh->dev;\r\nstruct em28xx_dmaqueue *vidq = &dev->vidq;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct em28xx_buffer *buf = container_of(vb,\r\nstruct em28xx_buffer,\r\nvb);\r\nstruct em28xx_fh *fh = vq->priv_data;\r\nstruct em28xx *dev = (struct em28xx *)fh->dev;\r\nem28xx_isocdbg("em28xx: called buffer_release\n");\r\nfree_buffer(vq, buf);\r\n}\r\nstatic void video_mux(struct em28xx *dev, int index)\r\n{\r\ndev->ctl_input = index;\r\ndev->ctl_ainput = INPUT(index)->amux;\r\ndev->ctl_aoutput = INPUT(index)->aout;\r\nif (!dev->ctl_aoutput)\r\ndev->ctl_aoutput = EM28XX_AOUT_MASTER;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_routing,\r\nINPUT(index)->vmux, 0, 0);\r\nif (dev->board.has_msp34xx) {\r\nif (dev->i2s_speed) {\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, audio,\r\ns_i2s_clock_freq, dev->i2s_speed);\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, audio, s_routing,\r\ndev->ctl_ainput, MSP_OUTPUT(MSP_SC_IN_DSP_SCART1), 0);\r\n}\r\nif (dev->board.adecoder != EM28XX_NOADECODER) {\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, audio, s_routing,\r\ndev->ctl_ainput, dev->ctl_aoutput, 0);\r\n}\r\nem28xx_audio_analog_set(dev);\r\n}\r\nstatic int res_get(struct em28xx_fh *fh, unsigned int bit)\r\n{\r\nstruct em28xx *dev = fh->dev;\r\nif (fh->resources & bit)\r\nreturn 1;\r\nif (dev->resources & bit) {\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\ndev->resources |= bit;\r\nem28xx_videodbg("res: get %d\n", bit);\r\nreturn 1;\r\n}\r\nstatic int res_check(struct em28xx_fh *fh, unsigned int bit)\r\n{\r\nreturn fh->resources & bit;\r\n}\r\nstatic int res_locked(struct em28xx *dev, unsigned int bit)\r\n{\r\nreturn dev->resources & bit;\r\n}\r\nstatic void res_free(struct em28xx_fh *fh, unsigned int bits)\r\n{\r\nstruct em28xx *dev = fh->dev;\r\nBUG_ON((fh->resources & bits) != bits);\r\nfh->resources &= ~bits;\r\ndev->resources &= ~bits;\r\nem28xx_videodbg("res: put %d\n", bits);\r\n}\r\nstatic int get_ressource(struct em28xx_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn EM28XX_RESOURCE_VIDEO;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn EM28XX_RESOURCE_VBI;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic int ac97_queryctrl(struct v4l2_queryctrl *qc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ac97_qctrl); i++) {\r\nif (qc->id && qc->id == ac97_qctrl[i].id) {\r\nmemcpy(qc, &(ac97_qctrl[i]), sizeof(*qc));\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int ac97_get_ctrl(struct em28xx *dev, struct v4l2_control *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nctrl->value = dev->mute;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctrl->value = dev->volume;\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int ac97_set_ctrl(struct em28xx *dev, const struct v4l2_control *ctrl)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ac97_qctrl); i++)\r\nif (ctrl->id == ac97_qctrl[i].id)\r\ngoto handle;\r\nreturn 1;\r\nhandle:\r\nif (ctrl->value < ac97_qctrl[i].minimum ||\r\nctrl->value > ac97_qctrl[i].maximum)\r\nreturn -ERANGE;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->mute = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->volume = ctrl->value;\r\nbreak;\r\n}\r\nreturn em28xx_audio_analog_set(dev);\r\n}\r\nstatic int check_dev(struct em28xx *dev)\r\n{\r\nif (dev->state & DEV_DISCONNECTED) {\r\nem28xx_errdev("v4l2 ioctl: device not present\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->state & DEV_MISCONFIGURED) {\r\nem28xx_errdev("v4l2 ioctl: device is misconfigured; "\r\n"close and open it again\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_scale(struct em28xx *dev,\r\nunsigned int width, unsigned int height,\r\nunsigned int *hscale, unsigned int *vscale)\r\n{\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\n*hscale = (((unsigned long)maxw) << 12) / width - 4096L;\r\nif (*hscale >= 0x4000)\r\n*hscale = 0x3fff;\r\n*vscale = (((unsigned long)maxh) << 12) / height - 4096L;\r\nif (*vscale >= 0x4000)\r\n*vscale = 0x3fff;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.pixelformat = dev->format->fourcc;\r\nf->fmt.pix.bytesperline = (dev->width * dev->format->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * dev->height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (dev->progressive)\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nelse\r\nf->fmt.pix.field = dev->interlaced ?\r\nV4L2_FIELD_INTERLACED : V4L2_FIELD_TOP;\r\nreturn 0;\r\n}\r\nstatic struct em28xx_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(format); i++)\r\nif (format[i].fourcc == fourcc)\r\nreturn &format[i];\r\nreturn NULL;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nunsigned int width = f->fmt.pix.width;\r\nunsigned int height = f->fmt.pix.height;\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\nunsigned int hscale, vscale;\r\nstruct em28xx_fmt *fmt;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt) {\r\nem28xx_videodbg("Fourcc format (%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (dev->board.is_em2800) {\r\nheight = height > (3 * maxh / 4) ? maxh : maxh / 2;\r\nwidth = width > (3 * maxw / 4) ? maxw : maxw / 2;\r\nif (width == maxw && height == maxh)\r\nwidth /= 2;\r\n} else {\r\nv4l_bound_align_image(&width, 48, maxw, 1, &height, 32, maxh,\r\n1, 0);\r\n}\r\nget_scale(dev, width, height, &hscale, &vscale);\r\nwidth = (((unsigned long)maxw) << 12) / (hscale + 4096L);\r\nheight = (((unsigned long)maxh) << 12) / (vscale + 4096L);\r\nf->fmt.pix.width = width;\r\nf->fmt.pix.height = height;\r\nf->fmt.pix.pixelformat = fmt->fourcc;\r\nf->fmt.pix.bytesperline = (dev->width * fmt->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (dev->progressive)\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nelse\r\nf->fmt.pix.field = dev->interlaced ?\r\nV4L2_FIELD_INTERLACED : V4L2_FIELD_TOP;\r\nreturn 0;\r\n}\r\nstatic int em28xx_set_video_format(struct em28xx *dev, unsigned int fourcc,\r\nunsigned width, unsigned height)\r\n{\r\nstruct em28xx_fmt *fmt;\r\nfmt = format_by_fourcc(fourcc);\r\nif (!fmt)\r\nreturn -EINVAL;\r\ndev->format = fmt;\r\ndev->width = width;\r\ndev->height = height;\r\nget_scale(dev, dev->width, dev->height, &dev->hscale, &dev->vscale);\r\nem28xx_set_alternate(dev);\r\nem28xx_resolution_set(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nvidioc_try_fmt_vid_cap(file, priv, f);\r\nif (videobuf_queue_is_busy(&fh->vb_vidq)) {\r\nem28xx_errdev("%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nreturn em28xx_set_video_format(dev, f->fmt.pix.pixelformat,\r\nf->fmt.pix.width, f->fmt.pix.height);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\n*norm = dev->norm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, querystd, norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nstruct v4l2_format f;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\ndev->norm = *norm;\r\nf.fmt.pix.width = dev->width;\r\nf.fmt.pix.height = dev->height;\r\nvidioc_try_fmt_vid_cap(file, priv, &f);\r\ndev->width = f.fmt.pix.width;\r\ndev->height = f.fmt.pix.height;\r\nget_scale(dev, dev->width, dev->height, &dev->hscale, &dev->vscale);\r\nem28xx_resolution_set(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std, dev->norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *p)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc = 0;\r\nif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (dev->board.is_webcam)\r\nrc = v4l2_device_call_until_err(&dev->v4l2_dev, 0,\r\nvideo, g_parm, p);\r\nelse\r\nv4l2_video_std_frame_period(dev->norm,\r\n&p->parm.capture.timeperframe);\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *p)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nif (!dev->board.is_webcam)\r\nreturn -EINVAL;\r\nif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn v4l2_device_call_until_err(&dev->v4l2_dev, 0, video, s_parm, p);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= MAX_EM28XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\nif ((EM28XX_VMUX_TELEVISION == INPUT(n)->type) ||\r\n(EM28XX_VMUX_CABLE == INPUT(n)->type))\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->std = dev->vdev->tvnorms;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\n*i = dev->ctl_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (i >= MAX_EM28XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i)->type)\r\nreturn -EINVAL;\r\nvideo_mux(dev, i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nif (!dev->audio_mode.has_audio)\r\nreturn -EINVAL;\r\nswitch (a->index) {\r\ncase EM28XX_AMUX_VIDEO:\r\nstrcpy(a->name, "Television");\r\nbreak;\r\ncase EM28XX_AMUX_LINE_IN:\r\nstrcpy(a->name, "Line In");\r\nbreak;\r\ncase EM28XX_AMUX_VIDEO2:\r\nstrcpy(a->name, "Television alt");\r\nbreak;\r\ncase EM28XX_AMUX_PHONE:\r\nstrcpy(a->name, "Phone");\r\nbreak;\r\ncase EM28XX_AMUX_MIC:\r\nstrcpy(a->name, "Mic");\r\nbreak;\r\ncase EM28XX_AMUX_CD:\r\nstrcpy(a->name, "CD");\r\nbreak;\r\ncase EM28XX_AMUX_AUX:\r\nstrcpy(a->name, "Aux");\r\nbreak;\r\ncase EM28XX_AMUX_PCM_OUT:\r\nstrcpy(a->name, "PCM");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\na->index = dev->ctl_ainput;\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, const struct v4l2_audio *a)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nif (!dev->audio_mode.has_audio)\r\nreturn -EINVAL;\r\nif (a->index >= MAX_EM28XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(a->index)->type)\r\nreturn -EINVAL;\r\ndev->ctl_ainput = INPUT(a->index)->amux;\r\ndev->ctl_aoutput = INPUT(a->index)->aout;\r\nif (!dev->ctl_aoutput)\r\ndev->ctl_aoutput = EM28XX_AOUT_MASTER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint id = qc->id;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nmemset(qc, 0, sizeof(*qc));\r\nqc->id = id;\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\r\nrc = ac97_queryctrl(qc);\r\nif (!rc)\r\nreturn 0;\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, queryctrl, qc);\r\nif (qc->type)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int check_subdev_ctrl(struct em28xx *dev, int id)\r\n{\r\nstruct v4l2_queryctrl qc;\r\nmemset(&qc, 0, sizeof(qc));\r\nqc.id = id;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, queryctrl, &qc);\r\nif (qc.type)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = 0;\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97)\r\nrc = ac97_get_ctrl(dev, ctrl);\r\nelse\r\nrc = 1;\r\nif (rc == 1) {\r\nif (check_subdev_ctrl(dev, ctrl->id))\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_ctrl, ctrl);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97)\r\nrc = ac97_set_ctrl(dev, ctrl);\r\nelse\r\nrc = 1;\r\nif (rc == 1) {\r\nrc = check_subdev_ctrl(dev, ctrl->id);\r\nif (!rc)\r\nv4l2_device_call_all(&dev->v4l2_dev, 0,\r\ncore, s_ctrl, ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->mute = ctrl->value;\r\nrc = em28xx_audio_analog_set(dev);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->volume = ctrl->value;\r\nrc = em28xx_audio_analog_set(dev);\r\n}\r\n}\r\nreturn (rc < 0) ? rc : 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Tuner");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nf->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->ctl_freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nif (unlikely(0 == fh->radio && f->type != V4L2_TUNER_ANALOG_TV))\r\nreturn -EINVAL;\r\nif (unlikely(1 == fh->radio && f->type != V4L2_TUNER_RADIO))\r\nreturn -EINVAL;\r\ndev->ctl_freq = f->frequency;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int em28xx_reg_len(int reg)\r\n{\r\nswitch (reg) {\r\ncase EM28XX_R40_AC97LSB:\r\ncase EM28XX_R30_HSCALELOW:\r\ncase EM28XX_R32_VSCALELOW:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int vidioc_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nchip->ident = V4L2_IDENT_NONE;\r\nchip->revision = 0;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_chip_ident, chip);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint ret;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_AC97:\r\nret = em28xx_read_ac97(dev, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = ret;\r\nreg->size = 1;\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_DRIVER:\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_register, reg);\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, g_register, reg);\r\nreturn 0;\r\ndefault:\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\n}\r\nreg->size = em28xx_reg_len(reg->reg);\r\nif (reg->size == 1) {\r\nret = em28xx_read_reg(dev, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = ret;\r\n} else {\r\n__le16 val = 0;\r\nret = em28xx_read_reg_req_len(dev, USB_REQ_GET_STATUS,\r\nreg->reg, (char *)&val, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = le16_to_cpu(val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\n__le16 buf;\r\nswitch (reg->match.type) {\r\ncase V4L2_CHIP_MATCH_AC97:\r\nreturn em28xx_write_ac97(dev, reg->reg, reg->val);\r\ncase V4L2_CHIP_MATCH_I2C_DRIVER:\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_register, reg);\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_I2C_ADDR:\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_register, reg);\r\nreturn 0;\r\ndefault:\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\n}\r\nbuf = cpu_to_le16(reg->val);\r\nreturn em28xx_write_regs(dev, reg->reg, (char *)&buf,\r\nem28xx_reg_len(reg->reg));\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cc)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nif (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncc->bounds.left = 0;\r\ncc->bounds.top = 0;\r\ncc->bounds.width = dev->width;\r\ncc->bounds.height = dev->height;\r\ncc->defrect = cc->bounds;\r\ncc->pixelaspect.numerator = 54;\r\ncc->pixelaspect.denominator = 59;\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc = -EINVAL;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (unlikely(type != fh->type))\r\nreturn -EINVAL;\r\nem28xx_videodbg("vidioc_streamon fh=%p t=%d fh->res=%d dev->res=%d\n",\r\nfh, type, fh->resources, dev->resources);\r\nif (unlikely(!res_get(fh, get_ressource(fh))))\r\nreturn -EBUSY;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_streamon(&fh->vb_vidq);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_streamon(&fh->vb_vbiq);\r\nreturn rc;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nfh->type != V4L2_BUF_TYPE_VBI_CAPTURE)\r\nreturn -EINVAL;\r\nif (type != fh->type)\r\nreturn -EINVAL;\r\nem28xx_videodbg("vidioc_streamoff fh=%p t=%d fh->res=%d dev->res=%d\n",\r\nfh, type, fh->resources, dev->resources);\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (res_check(fh, EM28XX_RESOURCE_VIDEO)) {\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(fh, EM28XX_RESOURCE_VIDEO);\r\n}\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (res_check(fh, EM28XX_RESOURCE_VBI)) {\r\nvideobuf_streamoff(&fh->vb_vbiq);\r\nres_free(fh, EM28XX_RESOURCE_VBI);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nstrlcpy(cap->driver, "em28xx", sizeof(cap->driver));\r\nstrlcpy(cap->card, em28xx_boards[dev->model].name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities =\r\nV4L2_CAP_SLICED_VBI_CAPTURE |\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nif (dev->vbi_dev)\r\ncap->capabilities |= V4L2_CAP_VBI_CAPTURE;\r\nif (dev->audio_mode.has_audio)\r\ncap->capabilities |= V4L2_CAP_AUDIO;\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(format)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, format[f->index].name, sizeof(f->description));\r\nf->pixelformat = format[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nstruct em28xx_fmt *fmt;\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\nfmt = format_by_fourcc(fsize->pixel_format);\r\nif (!fmt) {\r\nem28xx_videodbg("Fourcc format (%08x) invalid.\n",\r\nfsize->pixel_format);\r\nreturn -EINVAL;\r\n}\r\nif (dev->board.is_em2800) {\r\nif (fsize->index > 1)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = maxw / (1 + fsize->index);\r\nfsize->discrete.height = maxh / (1 + fsize->index);\r\nreturn 0;\r\n}\r\nif (fsize->index != 0)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfsize->stepwise.min_width = 48;\r\nfsize->stepwise.min_height = 32;\r\nfsize->stepwise.max_width = maxw;\r\nfsize->stepwise.max_height = maxh;\r\nfsize->stepwise.step_width = 1;\r\nfsize->stepwise.step_height = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_sliced_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nf->fmt.sliced.service_set = 0;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, vbi, g_sliced_fmt, &f->fmt.sliced);\r\nif (f->fmt.sliced.service_set == 0)\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nstatic int vidioc_try_set_sliced_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, vbi, g_sliced_fmt, &f->fmt.sliced);\r\nif (f->fmt.sliced.service_set == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nformat->fmt.vbi.samples_per_line = dev->vbi_width;\r\nformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nformat->fmt.vbi.offset = 0;\r\nformat->fmt.vbi.flags = 0;\r\nformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\r\nformat->fmt.vbi.count[0] = dev->vbi_height;\r\nformat->fmt.vbi.count[1] = dev->vbi_height;\r\nif (dev->norm & V4L2_STD_525_60) {\r\nformat->fmt.vbi.start[0] = 10;\r\nformat->fmt.vbi.start[1] = 273;\r\n} else if (dev->norm & V4L2_STD_625_50) {\r\nformat->fmt.vbi.start[0] = 6;\r\nformat->fmt.vbi.start[1] = 318;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nformat->fmt.vbi.samples_per_line = dev->vbi_width;\r\nformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nformat->fmt.vbi.offset = 0;\r\nformat->fmt.vbi.flags = 0;\r\nformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\r\nformat->fmt.vbi.count[0] = dev->vbi_height;\r\nformat->fmt.vbi.count[1] = dev->vbi_height;\r\nif (dev->norm & V4L2_STD_525_60) {\r\nformat->fmt.vbi.start[0] = 10;\r\nformat->fmt.vbi.start[1] = 273;\r\n} else if (dev->norm & V4L2_STD_625_50) {\r\nformat->fmt.vbi.start[0] = 6;\r\nformat->fmt.vbi.start[1] = 318;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_reqbufs(&fh->vb_vidq, rb);\r\nelse\r\nreturn videobuf_reqbufs(&fh->vb_vbiq, rb);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_querybuf(&fh->vb_vidq, b);\r\nelse {\r\nint result = videobuf_querybuf(&fh->vb_vbiq, b);\r\nb->length = dev->vbi_width * dev->vbi_height * 2;\r\nreturn result;\r\n}\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_qbuf(&fh->vb_vidq, b);\r\nelse\r\nreturn videobuf_qbuf(&fh->vb_vbiq, b);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct em28xx_fh *fh = priv;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn videobuf_dqbuf(&fh->vb_vidq, b, file->f_flags &\r\nO_NONBLOCK);\r\nelse\r\nreturn videobuf_dqbuf(&fh->vb_vbiq, b, file->f_flags &\r\nO_NONBLOCK);\r\n}\r\nstatic int radio_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct em28xx *dev = ((struct em28xx_fh *)priv)->dev;\r\nstrlcpy(cap->driver, "em28xx", sizeof(cap->driver));\r\nstrlcpy(cap->card, em28xx_boards[dev->model].name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct em28xx *dev = ((struct em28xx_fh *)priv)->dev;\r\nif (unlikely(t->index > 0))\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nt->type = V4L2_TUNER_RADIO;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, "Radio");\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nif (unlikely(a->index))\r\nreturn -EINVAL;\r\nstrcpy(a->name, "Radio");\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct em28xx *dev = ((struct em28xx_fh *)priv)->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_audio(struct file *file, void *fh,\r\nconst struct v4l2_audio *a)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_s_input(struct file *file, void *fh, unsigned int i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nint i;\r\nif (qc->id < V4L2_CID_BASE ||\r\nqc->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(ac97_qctrl); i++) {\r\nif (qc->id && qc->id == ac97_qctrl[i].id) {\r\nmemcpy(qc, &(ac97_qctrl[i]), sizeof(*qc));\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int em28xx_v4l2_open(struct file *filp)\r\n{\r\nint errCode = 0, radio = 0;\r\nstruct video_device *vdev = video_devdata(filp);\r\nstruct em28xx *dev = video_drvdata(filp);\r\nenum v4l2_buf_type fh_type = 0;\r\nstruct em28xx_fh *fh;\r\nenum v4l2_field field;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nfh_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nfh_type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nradio = 1;\r\nbreak;\r\n}\r\nem28xx_videodbg("open dev=%s type=%s users=%d\n",\r\nvideo_device_node_name(vdev), v4l2_type_names[fh_type],\r\ndev->users);\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nfh = kzalloc(sizeof(struct em28xx_fh), GFP_KERNEL);\r\nif (!fh) {\r\nem28xx_errdev("em28xx-video.c: Out of memory?!\n");\r\nmutex_unlock(&dev->lock);\r\nreturn -ENOMEM;\r\n}\r\nfh->dev = dev;\r\nfh->radio = radio;\r\nfh->type = fh_type;\r\nfilp->private_data = fh;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && dev->users == 0) {\r\nem28xx_set_mode(dev, EM28XX_ANALOG_MODE);\r\nem28xx_set_alternate(dev);\r\nem28xx_resolution_set(dev);\r\nem28xx_wake_i2c(dev);\r\n}\r\nif (fh->radio) {\r\nem28xx_videodbg("video_open: setting radio device\n");\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_radio);\r\n}\r\ndev->users++;\r\nif (dev->progressive)\r\nfield = V4L2_FIELD_NONE;\r\nelse\r\nfield = V4L2_FIELD_INTERLACED;\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &em28xx_video_qops,\r\nNULL, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, field,\r\nsizeof(struct em28xx_buffer), fh, &dev->lock);\r\nvideobuf_queue_vmalloc_init(&fh->vb_vbiq, &em28xx_vbi_qops,\r\nNULL, &dev->slock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_SEQ_TB,\r\nsizeof(struct em28xx_buffer), fh, &dev->lock);\r\nmutex_unlock(&dev->lock);\r\nreturn errCode;\r\n}\r\nvoid em28xx_release_analog_resources(struct em28xx *dev)\r\n{\r\nif (dev->radio_dev) {\r\nif (video_is_registered(dev->radio_dev))\r\nvideo_unregister_device(dev->radio_dev);\r\nelse\r\nvideo_device_release(dev->radio_dev);\r\ndev->radio_dev = NULL;\r\n}\r\nif (dev->vbi_dev) {\r\nem28xx_info("V4L2 device %s deregistered\n",\r\nvideo_device_node_name(dev->vbi_dev));\r\nif (video_is_registered(dev->vbi_dev))\r\nvideo_unregister_device(dev->vbi_dev);\r\nelse\r\nvideo_device_release(dev->vbi_dev);\r\ndev->vbi_dev = NULL;\r\n}\r\nif (dev->vdev) {\r\nem28xx_info("V4L2 device %s deregistered\n",\r\nvideo_device_node_name(dev->vdev));\r\nif (video_is_registered(dev->vdev))\r\nvideo_unregister_device(dev->vdev);\r\nelse\r\nvideo_device_release(dev->vdev);\r\ndev->vdev = NULL;\r\n}\r\n}\r\nstatic int em28xx_v4l2_close(struct file *filp)\r\n{\r\nstruct em28xx_fh *fh = filp->private_data;\r\nstruct em28xx *dev = fh->dev;\r\nint errCode;\r\nem28xx_videodbg("users=%d\n", dev->users);\r\nmutex_lock(&dev->lock);\r\nif (res_check(fh, EM28XX_RESOURCE_VIDEO)) {\r\nvideobuf_stop(&fh->vb_vidq);\r\nres_free(fh, EM28XX_RESOURCE_VIDEO);\r\n}\r\nif (res_check(fh, EM28XX_RESOURCE_VBI)) {\r\nvideobuf_stop(&fh->vb_vbiq);\r\nres_free(fh, EM28XX_RESOURCE_VBI);\r\n}\r\nif (dev->users == 1) {\r\nif (dev->state & DEV_DISCONNECTED) {\r\nem28xx_release_resources(dev);\r\nkfree(dev->alt_max_pkt_size);\r\nmutex_unlock(&dev->lock);\r\nkfree(dev);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_power, 0);\r\nem28xx_uninit_isoc(dev, EM28XX_ANALOG_MODE);\r\nem28xx_set_mode(dev, EM28XX_SUSPEND);\r\ndev->alt = 0;\r\nem28xx_videodbg("setting alternate 0\n");\r\nerrCode = usb_set_interface(dev->udev, 0, 0);\r\nif (errCode < 0) {\r\nem28xx_errdev("cannot change alternate number to "\r\n"0 (error=%i)\n", errCode);\r\n}\r\n}\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vbiq);\r\nkfree(fh);\r\ndev->users--;\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nem28xx_v4l2_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct em28xx_fh *fh = filp->private_data;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (res_locked(dev, EM28XX_RESOURCE_VIDEO))\r\nrc = -EBUSY;\r\nelse\r\nrc = videobuf_read_stream(&fh->vb_vidq, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (!res_get(fh, EM28XX_RESOURCE_VBI))\r\nrc = -EBUSY;\r\nelse\r\nrc = videobuf_read_stream(&fh->vb_vbiq, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nstatic unsigned int em28xx_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct em28xx_fh *fh = filp->private_data;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (!res_get(fh, EM28XX_RESOURCE_VIDEO))\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(filp, &fh->vb_vidq, wait);\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (!res_get(fh, EM28XX_RESOURCE_VBI))\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(filp, &fh->vb_vbiq, wait);\r\n} else {\r\nreturn POLLERR;\r\n}\r\n}\r\nstatic unsigned int em28xx_v4l2_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct em28xx_fh *fh = filp->private_data;\r\nstruct em28xx *dev = fh->dev;\r\nunsigned int res;\r\nmutex_lock(&dev->lock);\r\nres = em28xx_poll(filp, wait);\r\nmutex_unlock(&dev->lock);\r\nreturn res;\r\n}\r\nstatic int em28xx_v4l2_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct em28xx_fh *fh = filp->private_data;\r\nstruct em28xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nrc = videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\nelse if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\nrc = videobuf_mmap_mapper(&fh->vb_vbiq, vma);\r\nmutex_unlock(&dev->lock);\r\nem28xx_videodbg("vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,\r\nrc);\r\nreturn rc;\r\n}\r\nstatic struct video_device *em28xx_vdev_init(struct em28xx *dev,\r\nconst struct video_device *template,\r\nconst char *type_name)\r\n{\r\nstruct video_device *vfd;\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nvfd->debug = video_debug;\r\nvfd->lock = &dev->lock;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s",\r\ndev->name, type_name);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nint em28xx_register_analog_devices(struct em28xx *dev)\r\n{\r\nu8 val;\r\nint ret;\r\nunsigned int maxw;\r\nprintk(KERN_INFO "%s: v4l2 driver version %s\n",\r\ndev->name, EM28XX_VERSION);\r\ndev->norm = em28xx_video_template.current_norm;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std, dev->norm);\r\ndev->interlaced = EM28XX_INTERLACED_DEFAULT;\r\ndev->format = &format[0];\r\nmaxw = norm_maxw(dev);\r\nif (dev->board.is_em2800)\r\nmaxw /= 2;\r\nem28xx_set_video_format(dev, format[0].fourcc,\r\nmaxw, norm_maxh(dev));\r\nvideo_mux(dev, 0);\r\ndev->mute = 1;\r\ndev->volume = 0x1f;\r\nval = (u8)em28xx_read_reg(dev, EM28XX_R0F_XCLK);\r\nem28xx_write_reg(dev, EM28XX_R0F_XCLK,\r\n(EM28XX_XCLK_AUDIO_UNMUTE | val));\r\nem28xx_set_outfmt(dev);\r\nem28xx_colorlevels_set_default(dev);\r\nem28xx_compression_disable(dev);\r\ndev->vdev = em28xx_vdev_init(dev, &em28xx_video_template, "video");\r\nif (!dev->vdev) {\r\nem28xx_errdev("cannot allocate video_device.\n");\r\nreturn -ENODEV;\r\n}\r\nret = video_register_device(dev->vdev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->devno]);\r\nif (ret) {\r\nem28xx_errdev("unable to register video device (error=%i).\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (em28xx_vbi_supported(dev) == 1) {\r\ndev->vbi_dev = em28xx_vdev_init(dev, &em28xx_video_template,\r\n"vbi");\r\nret = video_register_device(dev->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[dev->devno]);\r\nif (ret < 0) {\r\nem28xx_errdev("unable to register vbi device\n");\r\nreturn ret;\r\n}\r\n}\r\nif (em28xx_boards[dev->model].radio.type == EM28XX_RADIO) {\r\ndev->radio_dev = em28xx_vdev_init(dev, &em28xx_radio_template,\r\n"radio");\r\nif (!dev->radio_dev) {\r\nem28xx_errdev("cannot allocate video_device.\n");\r\nreturn -ENODEV;\r\n}\r\nret = video_register_device(dev->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr[dev->devno]);\r\nif (ret < 0) {\r\nem28xx_errdev("can't register radio device\n");\r\nreturn ret;\r\n}\r\nem28xx_info("Registered radio device as %s\n",\r\nvideo_device_node_name(dev->radio_dev));\r\n}\r\nem28xx_info("V4L2 video device registered as %s\n",\r\nvideo_device_node_name(dev->vdev));\r\nif (dev->vbi_dev)\r\nem28xx_info("V4L2 VBI device registered as %s\n",\r\nvideo_device_node_name(dev->vbi_dev));\r\nreturn 0;\r\n}
