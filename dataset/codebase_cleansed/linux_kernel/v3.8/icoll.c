static void icoll_ack_irq(struct irq_data *d)\r\n{\r\n__raw_writel(BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0,\r\nicoll_base + HW_ICOLL_LEVELACK);\r\n}\r\nstatic void icoll_mask_irq(struct irq_data *d)\r\n{\r\n__raw_writel(BM_ICOLL_INTERRUPTn_ENABLE,\r\nicoll_base + HW_ICOLL_INTERRUPTn_CLR(d->hwirq));\r\n}\r\nstatic void icoll_unmask_irq(struct irq_data *d)\r\n{\r\n__raw_writel(BM_ICOLL_INTERRUPTn_ENABLE,\r\nicoll_base + HW_ICOLL_INTERRUPTn_SET(d->hwirq));\r\n}\r\nasmlinkage void __exception_irq_entry icoll_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 irqnr;\r\ndo {\r\nirqnr = __raw_readl(icoll_base + HW_ICOLL_STAT_OFFSET);\r\nif (irqnr != 0x7f) {\r\n__raw_writel(irqnr, icoll_base + HW_ICOLL_VECTOR);\r\nirqnr = irq_find_mapping(icoll_domain, irqnr);\r\nhandle_IRQ(irqnr, regs);\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\n}\r\nstatic int icoll_irq_domain_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(virq, &mxs_icoll_chip, handle_level_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nvoid __init icoll_of_init(struct device_node *np,\r\nstruct device_node *interrupt_parent)\r\n{\r\nmxs_reset_block(icoll_base + HW_ICOLL_CTRL);\r\nicoll_domain = irq_domain_add_linear(np, ICOLL_NUM_IRQS,\r\n&icoll_irq_domain_ops, NULL);\r\nWARN_ON(!icoll_domain);\r\n}\r\nvoid __init icoll_init_irq(void)\r\n{\r\nof_irq_init(icoll_of_match);\r\n}
