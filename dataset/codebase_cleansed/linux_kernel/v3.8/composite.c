static struct usb_descriptor_header**\r\nnext_ep_desc(struct usb_descriptor_header **t)\r\n{\r\nfor (; *t; t++) {\r\nif ((*t)->bDescriptorType == USB_DT_ENDPOINT)\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nint config_ep_by_speed(struct usb_gadget *g,\r\nstruct usb_function *f,\r\nstruct usb_ep *_ep)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(g);\r\nstruct usb_endpoint_descriptor *chosen_desc = NULL;\r\nstruct usb_descriptor_header **speed_desc = NULL;\r\nstruct usb_ss_ep_comp_descriptor *comp_desc = NULL;\r\nint want_comp_desc = 0;\r\nstruct usb_descriptor_header **d_spd;\r\nif (!g || !f || !_ep)\r\nreturn -EIO;\r\nswitch (g->speed) {\r\ncase USB_SPEED_SUPER:\r\nif (gadget_is_superspeed(g)) {\r\nspeed_desc = f->ss_descriptors;\r\nwant_comp_desc = 1;\r\nbreak;\r\n}\r\ncase USB_SPEED_HIGH:\r\nif (gadget_is_dualspeed(g)) {\r\nspeed_desc = f->hs_descriptors;\r\nbreak;\r\n}\r\ndefault:\r\nspeed_desc = f->descriptors;\r\n}\r\nfor_each_ep_desc(speed_desc, d_spd) {\r\nchosen_desc = (struct usb_endpoint_descriptor *)*d_spd;\r\nif (chosen_desc->bEndpointAddress == _ep->address)\r\ngoto ep_found;\r\n}\r\nreturn -EIO;\r\nep_found:\r\n_ep->maxpacket = usb_endpoint_maxp(chosen_desc);\r\n_ep->desc = chosen_desc;\r\n_ep->comp_desc = NULL;\r\n_ep->maxburst = 0;\r\n_ep->mult = 0;\r\nif (!want_comp_desc)\r\nreturn 0;\r\ncomp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);\r\nif (!comp_desc ||\r\n(comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))\r\nreturn -EIO;\r\n_ep->comp_desc = comp_desc;\r\nif (g->speed == USB_SPEED_SUPER) {\r\nswitch (usb_endpoint_type(_ep->desc)) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\n_ep->mult = comp_desc->bmAttributes & 0x3;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\n_ep->maxburst = comp_desc->bMaxBurst + 1;\r\nbreak;\r\ndefault:\r\nif (comp_desc->bMaxBurst != 0)\r\nERROR(cdev, "ep0 bMaxBurst must be 0\n");\r\n_ep->maxburst = 1;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint usb_add_function(struct usb_configuration *config,\r\nstruct usb_function *function)\r\n{\r\nint value = -EINVAL;\r\nDBG(config->cdev, "adding '%s'/%p to config '%s'/%p\n",\r\nfunction->name, function,\r\nconfig->label, config);\r\nif (!function->set_alt || !function->disable)\r\ngoto done;\r\nfunction->config = config;\r\nlist_add_tail(&function->list, &config->functions);\r\nif (function->bind) {\r\nvalue = function->bind(config, function);\r\nif (value < 0) {\r\nlist_del(&function->list);\r\nfunction->config = NULL;\r\n}\r\n} else\r\nvalue = 0;\r\nif (!config->fullspeed && function->descriptors)\r\nconfig->fullspeed = true;\r\nif (!config->highspeed && function->hs_descriptors)\r\nconfig->highspeed = true;\r\nif (!config->superspeed && function->ss_descriptors)\r\nconfig->superspeed = true;\r\ndone:\r\nif (value)\r\nDBG(config->cdev, "adding '%s'/%p --> %d\n",\r\nfunction->name, function, value);\r\nreturn value;\r\n}\r\nint usb_function_deactivate(struct usb_function *function)\r\n{\r\nstruct usb_composite_dev *cdev = function->config->cdev;\r\nunsigned long flags;\r\nint status = 0;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->deactivations == 0)\r\nstatus = usb_gadget_disconnect(cdev->gadget);\r\nif (status == 0)\r\ncdev->deactivations++;\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nreturn status;\r\n}\r\nint usb_function_activate(struct usb_function *function)\r\n{\r\nstruct usb_composite_dev *cdev = function->config->cdev;\r\nunsigned long flags;\r\nint status = 0;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (WARN_ON(cdev->deactivations == 0))\r\nstatus = -EINVAL;\r\nelse {\r\ncdev->deactivations--;\r\nif (cdev->deactivations == 0)\r\nstatus = usb_gadget_connect(cdev->gadget);\r\n}\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nreturn status;\r\n}\r\nint usb_interface_id(struct usb_configuration *config,\r\nstruct usb_function *function)\r\n{\r\nunsigned id = config->next_interface_id;\r\nif (id < MAX_CONFIG_INTERFACES) {\r\nconfig->interface[id] = function;\r\nconfig->next_interface_id = id + 1;\r\nreturn id;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int config_buf(struct usb_configuration *config,\r\nenum usb_device_speed speed, void *buf, u8 type)\r\n{\r\nstruct usb_config_descriptor *c = buf;\r\nvoid *next = buf + USB_DT_CONFIG_SIZE;\r\nint len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;\r\nstruct usb_function *f;\r\nint status;\r\nc = buf;\r\nc->bLength = USB_DT_CONFIG_SIZE;\r\nc->bDescriptorType = type;\r\nc->bNumInterfaces = config->next_interface_id;\r\nc->bConfigurationValue = config->bConfigurationValue;\r\nc->iConfiguration = config->iConfiguration;\r\nc->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;\r\nc->bMaxPower = config->bMaxPower ? : (CONFIG_USB_GADGET_VBUS_DRAW / 2);\r\nif (config->descriptors) {\r\nstatus = usb_descriptor_fillbuf(next, len,\r\nconfig->descriptors);\r\nif (status < 0)\r\nreturn status;\r\nlen -= status;\r\nnext += status;\r\n}\r\nlist_for_each_entry(f, &config->functions, list) {\r\nstruct usb_descriptor_header **descriptors;\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\ndescriptors = f->ss_descriptors;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ndescriptors = f->hs_descriptors;\r\nbreak;\r\ndefault:\r\ndescriptors = f->descriptors;\r\n}\r\nif (!descriptors)\r\ncontinue;\r\nstatus = usb_descriptor_fillbuf(next, len,\r\n(const struct usb_descriptor_header **) descriptors);\r\nif (status < 0)\r\nreturn status;\r\nlen -= status;\r\nnext += status;\r\n}\r\nlen = next - buf;\r\nc->wTotalLength = cpu_to_le16(len);\r\nreturn len;\r\n}\r\nstatic int config_desc(struct usb_composite_dev *cdev, unsigned w_value)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_configuration *c;\r\nu8 type = w_value >> 8;\r\nenum usb_device_speed speed = USB_SPEED_UNKNOWN;\r\nif (gadget->speed == USB_SPEED_SUPER)\r\nspeed = gadget->speed;\r\nelse if (gadget_is_dualspeed(gadget)) {\r\nint hs = 0;\r\nif (gadget->speed == USB_SPEED_HIGH)\r\nhs = 1;\r\nif (type == USB_DT_OTHER_SPEED_CONFIG)\r\nhs = !hs;\r\nif (hs)\r\nspeed = USB_SPEED_HIGH;\r\n}\r\nw_value &= 0xff;\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\nif (!c->superspeed)\r\ncontinue;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nif (!c->highspeed)\r\ncontinue;\r\nbreak;\r\ndefault:\r\nif (!c->fullspeed)\r\ncontinue;\r\n}\r\nif (w_value == 0)\r\nreturn config_buf(c, speed, cdev->req->buf, type);\r\nw_value--;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int count_configs(struct usb_composite_dev *cdev, unsigned type)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_configuration *c;\r\nunsigned count = 0;\r\nint hs = 0;\r\nint ss = 0;\r\nif (gadget_is_dualspeed(gadget)) {\r\nif (gadget->speed == USB_SPEED_HIGH)\r\nhs = 1;\r\nif (gadget->speed == USB_SPEED_SUPER)\r\nss = 1;\r\nif (type == USB_DT_DEVICE_QUALIFIER)\r\nhs = !hs;\r\n}\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (ss) {\r\nif (!c->superspeed)\r\ncontinue;\r\n} else if (hs) {\r\nif (!c->highspeed)\r\ncontinue;\r\n} else {\r\nif (!c->fullspeed)\r\ncontinue;\r\n}\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int bos_desc(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_ext_cap_descriptor *usb_ext;\r\nstruct usb_ss_cap_descriptor *ss_cap;\r\nstruct usb_dcd_config_params dcd_config_params;\r\nstruct usb_bos_descriptor *bos = cdev->req->buf;\r\nbos->bLength = USB_DT_BOS_SIZE;\r\nbos->bDescriptorType = USB_DT_BOS;\r\nbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);\r\nbos->bNumDeviceCaps = 0;\r\nusb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\r\nbos->bNumDeviceCaps++;\r\nle16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);\r\nusb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;\r\nusb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\r\nusb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;\r\nusb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);\r\nss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\r\nbos->bNumDeviceCaps++;\r\nle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);\r\nss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;\r\nss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\r\nss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;\r\nss_cap->bmAttributes = 0;\r\nss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |\r\nUSB_FULL_SPEED_OPERATION |\r\nUSB_HIGH_SPEED_OPERATION |\r\nUSB_5GBPS_OPERATION);\r\nss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;\r\nif (cdev->gadget->ops->get_config_params)\r\ncdev->gadget->ops->get_config_params(&dcd_config_params);\r\nelse {\r\ndcd_config_params.bU1devExitLat = USB_DEFAULT_U1_DEV_EXIT_LAT;\r\ndcd_config_params.bU2DevExitLat =\r\ncpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);\r\n}\r\nss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;\r\nss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;\r\nreturn le16_to_cpu(bos->wTotalLength);\r\n}\r\nstatic void device_qual(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_qualifier_descriptor *qual = cdev->req->buf;\r\nqual->bLength = sizeof(*qual);\r\nqual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;\r\nqual->bcdUSB = cdev->desc.bcdUSB;\r\nqual->bDeviceClass = cdev->desc.bDeviceClass;\r\nqual->bDeviceSubClass = cdev->desc.bDeviceSubClass;\r\nqual->bDeviceProtocol = cdev->desc.bDeviceProtocol;\r\nqual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;\r\nqual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);\r\nqual->bRESERVED = 0;\r\n}\r\nstatic void reset_config(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_function *f;\r\nDBG(cdev, "reset config\n");\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (f->disable)\r\nf->disable(f);\r\nbitmap_zero(f->endpoints, 32);\r\n}\r\ncdev->config = NULL;\r\n}\r\nstatic int set_config(struct usb_composite_dev *cdev,\r\nconst struct usb_ctrlrequest *ctrl, unsigned number)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_configuration *c = NULL;\r\nint result = -EINVAL;\r\nunsigned power = gadget_is_otg(gadget) ? 8 : 100;\r\nint tmp;\r\nif (number) {\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c->bConfigurationValue == number) {\r\nif (cdev->config)\r\nreset_config(cdev);\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\nif (result < 0)\r\ngoto done;\r\n} else {\r\nif (cdev->config)\r\nreset_config(cdev);\r\nresult = 0;\r\n}\r\nINFO(cdev, "%s config #%d: %s\n",\r\nusb_speed_string(gadget->speed),\r\nnumber, c ? c->label : "unconfigured");\r\nif (!c)\r\ngoto done;\r\ncdev->config = c;\r\nfor (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {\r\nstruct usb_function *f = c->interface[tmp];\r\nstruct usb_descriptor_header **descriptors;\r\nif (!f)\r\nbreak;\r\nswitch (gadget->speed) {\r\ncase USB_SPEED_SUPER:\r\ndescriptors = f->ss_descriptors;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ndescriptors = f->hs_descriptors;\r\nbreak;\r\ndefault:\r\ndescriptors = f->descriptors;\r\n}\r\nfor (; *descriptors; ++descriptors) {\r\nstruct usb_endpoint_descriptor *ep;\r\nint addr;\r\nif ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)\r\ncontinue;\r\nep = (struct usb_endpoint_descriptor *)*descriptors;\r\naddr = ((ep->bEndpointAddress & 0x80) >> 3)\r\n| (ep->bEndpointAddress & 0x0f);\r\nset_bit(addr, f->endpoints);\r\n}\r\nresult = f->set_alt(f, tmp, 0);\r\nif (result < 0) {\r\nDBG(cdev, "interface %d (%s/%p) alt 0 --> %d\n",\r\ntmp, f->name, f, result);\r\nreset_config(cdev);\r\ngoto done;\r\n}\r\nif (result == USB_GADGET_DELAYED_STATUS) {\r\nDBG(cdev,\r\n"%s: interface %d (%s) requested delayed status\n",\r\n__func__, tmp, f->name);\r\ncdev->delayed_status++;\r\nDBG(cdev, "delayed_status count %d\n",\r\ncdev->delayed_status);\r\n}\r\n}\r\npower = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;\r\ndone:\r\nusb_gadget_vbus_draw(gadget, power);\r\nif (result >= 0 && cdev->delayed_status)\r\nresult = USB_GADGET_DELAYED_STATUS;\r\nreturn result;\r\n}\r\nint usb_add_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config,\r\nint (*bind)(struct usb_configuration *))\r\n{\r\nint status = -EINVAL;\r\nstruct usb_configuration *c;\r\nDBG(cdev, "adding config #%u '%s'/%p\n",\r\nconfig->bConfigurationValue,\r\nconfig->label, config);\r\nif (!config->bConfigurationValue || !bind)\r\ngoto done;\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c->bConfigurationValue == config->bConfigurationValue) {\r\nstatus = -EBUSY;\r\ngoto done;\r\n}\r\n}\r\nconfig->cdev = cdev;\r\nlist_add_tail(&config->list, &cdev->configs);\r\nINIT_LIST_HEAD(&config->functions);\r\nconfig->next_interface_id = 0;\r\nmemset(config->interface, 0, sizeof(config->interface));\r\nstatus = bind(config);\r\nif (status < 0) {\r\nwhile (!list_empty(&config->functions)) {\r\nstruct usb_function *f;\r\nf = list_first_entry(&config->functions,\r\nstruct usb_function, list);\r\nlist_del(&f->list);\r\nif (f->unbind) {\r\nDBG(cdev, "unbind function '%s'/%p\n",\r\nf->name, f);\r\nf->unbind(config, f);\r\n}\r\n}\r\nlist_del(&config->list);\r\nconfig->cdev = NULL;\r\n} else {\r\nunsigned i;\r\nDBG(cdev, "cfg %d/%p speeds:%s%s%s\n",\r\nconfig->bConfigurationValue, config,\r\nconfig->superspeed ? " super" : "",\r\nconfig->highspeed ? " high" : "",\r\nconfig->fullspeed\r\n? (gadget_is_dualspeed(cdev->gadget)\r\n? " full"\r\n: " full/low")\r\n: "");\r\nfor (i = 0; i < MAX_CONFIG_INTERFACES; i++) {\r\nstruct usb_function *f = config->interface[i];\r\nif (!f)\r\ncontinue;\r\nDBG(cdev, " interface %d = %s/%p\n",\r\ni, f->name, f);\r\n}\r\n}\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\ndone:\r\nif (status)\r\nDBG(cdev, "added config '%s'/%u --> %d\n", config->label,\r\nconfig->bConfigurationValue, status);\r\nreturn status;\r\n}\r\nstatic void remove_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config)\r\n{\r\nwhile (!list_empty(&config->functions)) {\r\nstruct usb_function *f;\r\nf = list_first_entry(&config->functions,\r\nstruct usb_function, list);\r\nlist_del(&f->list);\r\nif (f->unbind) {\r\nDBG(cdev, "unbind function '%s'/%p\n", f->name, f);\r\nf->unbind(config, f);\r\n}\r\n}\r\nlist_del(&config->list);\r\nif (config->unbind) {\r\nDBG(cdev, "unbind config '%s'/%p\n", config->label, config);\r\nconfig->unbind(config);\r\n}\r\n}\r\nvoid usb_remove_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->config == config)\r\nreset_config(cdev);\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nremove_config(cdev, config);\r\n}\r\nstatic void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)\r\n{\r\nconst struct usb_gadget_strings *s;\r\n__le16 language;\r\n__le16 *tmp;\r\nwhile (*sp) {\r\ns = *sp;\r\nlanguage = cpu_to_le16(s->language);\r\nfor (tmp = buf; *tmp && tmp < &buf[126]; tmp++) {\r\nif (*tmp == language)\r\ngoto repeat;\r\n}\r\n*tmp++ = language;\r\nrepeat:\r\nsp++;\r\n}\r\n}\r\nstatic int lookup_string(\r\nstruct usb_gadget_strings **sp,\r\nvoid *buf,\r\nu16 language,\r\nint id\r\n)\r\n{\r\nstruct usb_gadget_strings *s;\r\nint value;\r\nwhile (*sp) {\r\ns = *sp++;\r\nif (s->language != language)\r\ncontinue;\r\nvalue = usb_gadget_get_string(s, id, buf);\r\nif (value > 0)\r\nreturn value;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int get_string(struct usb_composite_dev *cdev,\r\nvoid *buf, u16 language, int id)\r\n{\r\nstruct usb_configuration *c;\r\nstruct usb_function *f;\r\nint len;\r\nconst char *str;\r\nif (id == 0) {\r\nstruct usb_string_descriptor *s = buf;\r\nstruct usb_gadget_strings **sp;\r\nmemset(s, 0, 256);\r\ns->bDescriptorType = USB_DT_STRING;\r\nsp = composite->strings;\r\nif (sp)\r\ncollect_langs(sp, s->wData);\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nsp = c->strings;\r\nif (sp)\r\ncollect_langs(sp, s->wData);\r\nlist_for_each_entry(f, &c->functions, list) {\r\nsp = f->strings;\r\nif (sp)\r\ncollect_langs(sp, s->wData);\r\n}\r\n}\r\nfor (len = 0; len <= 126 && s->wData[len]; len++)\r\ncontinue;\r\nif (!len)\r\nreturn -EINVAL;\r\ns->bLength = 2 * (len + 1);\r\nreturn s->bLength;\r\n}\r\nif (cdev->manufacturer_override == id)\r\nstr = iManufacturer ?: composite->iManufacturer ?:\r\ncomposite_manufacturer;\r\nelse if (cdev->product_override == id)\r\nstr = iProduct ?: composite->iProduct;\r\nelse if (cdev->serial_override == id)\r\nstr = iSerialNumber ?: composite->iSerialNumber;\r\nelse\r\nstr = NULL;\r\nif (str) {\r\nstruct usb_gadget_strings strings = {\r\n.language = language,\r\n.strings = &(struct usb_string) { 0xff, str }\r\n};\r\nreturn usb_gadget_get_string(&strings, 0xff, buf);\r\n}\r\nif (composite->strings) {\r\nlen = lookup_string(composite->strings, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c->strings) {\r\nlen = lookup_string(c->strings, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\nlist_for_each_entry(f, &c->functions, list) {\r\nif (!f->strings)\r\ncontinue;\r\nlen = lookup_string(f->strings, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint usb_string_id(struct usb_composite_dev *cdev)\r\n{\r\nif (cdev->next_string_id < 254) {\r\ncdev->next_string_id++;\r\nreturn cdev->next_string_id;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)\r\n{\r\nint next = cdev->next_string_id;\r\nfor (; str->s; ++str) {\r\nif (unlikely(next >= 254))\r\nreturn -ENODEV;\r\nstr->id = ++next;\r\n}\r\ncdev->next_string_id = next;\r\nreturn 0;\r\n}\r\nint usb_string_ids_n(struct usb_composite_dev *c, unsigned n)\r\n{\r\nunsigned next = c->next_string_id;\r\nif (unlikely(n > 254 || (unsigned)next + n > 254))\r\nreturn -ENODEV;\r\nc->next_string_id += n;\r\nreturn next + 1;\r\n}\r\nstatic void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nif (req->status || req->actual != req->length)\r\nDBG((struct usb_composite_dev *) ep->driver_data,\r\n"setup complete --> %d, %d/%d\n",\r\nreq->status, req->actual, req->length);\r\n}\r\nstatic int\r\ncomposite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nint status = 0;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu8 intf = w_index & 0xFF;\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nstruct usb_function *f = NULL;\r\nu8 endp;\r\nreq->zero = 0;\r\nreq->complete = composite_setup_complete;\r\nreq->length = 0;\r\ngadget->ep0->driver_data = cdev;\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_DESCRIPTOR:\r\nif (ctrl->bRequestType != USB_DIR_IN)\r\ngoto unknown;\r\nswitch (w_value >> 8) {\r\ncase USB_DT_DEVICE:\r\ncdev->desc.bNumConfigurations =\r\ncount_configs(cdev, USB_DT_DEVICE);\r\ncdev->desc.bMaxPacketSize0 =\r\ncdev->gadget->ep0->maxpacket;\r\nif (gadget_is_superspeed(gadget)) {\r\nif (gadget->speed >= USB_SPEED_SUPER) {\r\ncdev->desc.bcdUSB = cpu_to_le16(0x0300);\r\ncdev->desc.bMaxPacketSize0 = 9;\r\n} else {\r\ncdev->desc.bcdUSB = cpu_to_le16(0x0210);\r\n}\r\n}\r\nvalue = min(w_length, (u16) sizeof cdev->desc);\r\nmemcpy(req->buf, &cdev->desc, value);\r\nbreak;\r\ncase USB_DT_DEVICE_QUALIFIER:\r\nif (!gadget_is_dualspeed(gadget) ||\r\ngadget->speed >= USB_SPEED_SUPER)\r\nbreak;\r\ndevice_qual(cdev);\r\nvalue = min_t(int, w_length,\r\nsizeof(struct usb_qualifier_descriptor));\r\nbreak;\r\ncase USB_DT_OTHER_SPEED_CONFIG:\r\nif (!gadget_is_dualspeed(gadget) ||\r\ngadget->speed >= USB_SPEED_SUPER)\r\nbreak;\r\ncase USB_DT_CONFIG:\r\nvalue = config_desc(cdev, w_value);\r\nif (value >= 0)\r\nvalue = min(w_length, (u16) value);\r\nbreak;\r\ncase USB_DT_STRING:\r\nvalue = get_string(cdev, req->buf,\r\nw_index, w_value & 0xff);\r\nif (value >= 0)\r\nvalue = min(w_length, (u16) value);\r\nbreak;\r\ncase USB_DT_BOS:\r\nif (gadget_is_superspeed(gadget)) {\r\nvalue = bos_desc(cdev);\r\nvalue = min(w_length, (u16) value);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (ctrl->bRequestType != 0)\r\ngoto unknown;\r\nif (gadget_is_otg(gadget)) {\r\nif (gadget->a_hnp_support)\r\nDBG(cdev, "HNP available\n");\r\nelse if (gadget->a_alt_hnp_support)\r\nDBG(cdev, "HNP on another port\n");\r\nelse\r\nVDBG(cdev, "HNP inactive\n");\r\n}\r\nspin_lock(&cdev->lock);\r\nvalue = set_config(cdev, ctrl, w_value);\r\nspin_unlock(&cdev->lock);\r\nbreak;\r\ncase USB_REQ_GET_CONFIGURATION:\r\nif (ctrl->bRequestType != USB_DIR_IN)\r\ngoto unknown;\r\nif (cdev->config)\r\n*(u8 *)req->buf = cdev->config->bConfigurationValue;\r\nelse\r\n*(u8 *)req->buf = 0;\r\nvalue = min(w_length, (u16) 1);\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\nif (ctrl->bRequestType != USB_RECIP_INTERFACE)\r\ngoto unknown;\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nif (w_value && !f->set_alt)\r\nbreak;\r\nvalue = f->set_alt(f, w_index, w_value);\r\nif (value == USB_GADGET_DELAYED_STATUS) {\r\nDBG(cdev,\r\n"%s: interface %d (%s) requested delayed status\n",\r\n__func__, intf, f->name);\r\ncdev->delayed_status++;\r\nDBG(cdev, "delayed_status count %d\n",\r\ncdev->delayed_status);\r\n}\r\nbreak;\r\ncase USB_REQ_GET_INTERFACE:\r\nif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\r\ngoto unknown;\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\r\nif (value < 0)\r\nbreak;\r\n*((u8 *)req->buf) = value;\r\nvalue = min(w_length, (u16) 1);\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif (!gadget_is_superspeed(gadget))\r\ngoto unknown;\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\r\ngoto unknown;\r\nvalue = 2;\r\nput_unaligned_le16(0, req->buf);\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nstatus = f->get_status ? f->get_status(f) : 0;\r\nif (status < 0)\r\nbreak;\r\nput_unaligned_le16(status & 0x0000ffff, req->buf);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nif (!gadget_is_superspeed(gadget))\r\ngoto unknown;\r\nif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\r\ngoto unknown;\r\nswitch (w_value) {\r\ncase USB_INTRF_FUNC_SUSPEND:\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nvalue = 0;\r\nif (f->func_suspend)\r\nvalue = f->func_suspend(f, w_index >> 8);\r\nif (value < 0) {\r\nERROR(cdev,\r\n"func_suspend() returned error %d\n",\r\nvalue);\r\nvalue = 0;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nunknown:\r\nVDBG(cdev,\r\n"non-core control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_INTERFACE:\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (test_bit(endp, f->endpoints))\r\nbreak;\r\n}\r\nif (&f->list == &cdev->config->functions)\r\nf = NULL;\r\nbreak;\r\n}\r\nif (f && f->setup)\r\nvalue = f->setup(f, ctrl);\r\nelse {\r\nstruct usb_configuration *c;\r\nc = cdev->config;\r\nif (c && c->setup)\r\nvalue = c->setup(c, ctrl);\r\n}\r\ngoto done;\r\n}\r\nif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\r\nreq->length = value;\r\nreq->zero = value < w_length;\r\nvalue = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\nDBG(cdev, "ep_queue --> %d\n", value);\r\nreq->status = 0;\r\ncomposite_setup_complete(gadget->ep0, req);\r\n}\r\n} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\r\nWARN(cdev,\r\n"%s: Delayed status not supported for w_length != 0",\r\n__func__);\r\n}\r\ndone:\r\nreturn value;\r\n}\r\nstatic void composite_disconnect(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->config)\r\nreset_config(cdev);\r\nif (composite->disconnect)\r\ncomposite->disconnect(cdev);\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\n}\r\nstatic ssize_t composite_show_suspended(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nreturn sprintf(buf, "%d\n", cdev->suspended);\r\n}\r\nstatic void\r\ncomposite_unbind(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nWARN_ON(cdev->config);\r\nwhile (!list_empty(&cdev->configs)) {\r\nstruct usb_configuration *c;\r\nc = list_first_entry(&cdev->configs,\r\nstruct usb_configuration, list);\r\nremove_config(cdev, c);\r\n}\r\nif (composite->unbind)\r\ncomposite->unbind(cdev);\r\nif (cdev->req) {\r\nkfree(cdev->req->buf);\r\nusb_ep_free_request(gadget->ep0, cdev->req);\r\n}\r\ndevice_remove_file(&gadget->dev, &dev_attr_suspended);\r\nkfree(cdev);\r\nset_gadget_data(gadget, NULL);\r\ncomposite = NULL;\r\n}\r\nstatic u8 override_id(struct usb_composite_dev *cdev, u8 *desc)\r\n{\r\nif (!*desc) {\r\nint ret = usb_string_id(cdev);\r\nif (unlikely(ret < 0))\r\nWARNING(cdev, "failed to override string ID\n");\r\nelse\r\n*desc = ret;\r\n}\r\nreturn *desc;\r\n}\r\nstatic int composite_bind(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct usb_composite_dev *cdev;\r\nint status = -ENOMEM;\r\ncdev = kzalloc(sizeof *cdev, GFP_KERNEL);\r\nif (!cdev)\r\nreturn status;\r\nspin_lock_init(&cdev->lock);\r\ncdev->gadget = gadget;\r\nset_gadget_data(gadget, cdev);\r\nINIT_LIST_HEAD(&cdev->configs);\r\ncdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\r\nif (!cdev->req)\r\ngoto fail;\r\ncdev->req->buf = kmalloc(USB_BUFSIZ, GFP_KERNEL);\r\nif (!cdev->req->buf)\r\ngoto fail;\r\ncdev->req->complete = composite_setup_complete;\r\ngadget->ep0->driver_data = cdev;\r\ncdev->bufsiz = USB_BUFSIZ;\r\ncdev->driver = composite;\r\nif (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)\r\nusb_gadget_set_selfpowered(gadget);\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\nstatus = composite->bind(cdev);\r\nif (status < 0)\r\ngoto fail;\r\ncdev->desc = *composite->dev;\r\nif (idVendor)\r\ncdev->desc.idVendor = cpu_to_le16(idVendor);\r\nelse\r\nidVendor = le16_to_cpu(cdev->desc.idVendor);\r\nif (idProduct)\r\ncdev->desc.idProduct = cpu_to_le16(idProduct);\r\nelse\r\nidProduct = le16_to_cpu(cdev->desc.idProduct);\r\nif (bcdDevice)\r\ncdev->desc.bcdDevice = cpu_to_le16(bcdDevice);\r\nelse\r\nbcdDevice = le16_to_cpu(cdev->desc.bcdDevice);\r\nif (iManufacturer || !cdev->desc.iManufacturer) {\r\nif (!iManufacturer && !composite->iManufacturer &&\r\n!*composite_manufacturer)\r\nsnprintf(composite_manufacturer,\r\nsizeof composite_manufacturer,\r\n"%s %s with %s",\r\ninit_utsname()->sysname,\r\ninit_utsname()->release,\r\ngadget->name);\r\ncdev->manufacturer_override =\r\noverride_id(cdev, &cdev->desc.iManufacturer);\r\n}\r\nif (iProduct || (!cdev->desc.iProduct && composite->iProduct))\r\ncdev->product_override =\r\noverride_id(cdev, &cdev->desc.iProduct);\r\nif (iSerialNumber ||\r\n(!cdev->desc.iSerialNumber && composite->iSerialNumber))\r\ncdev->serial_override =\r\noverride_id(cdev, &cdev->desc.iSerialNumber);\r\nif (composite->needs_serial && !cdev->desc.iSerialNumber)\r\nWARNING(cdev, "userspace failed to provide iSerialNumber\n");\r\nstatus = device_create_file(&gadget->dev, &dev_attr_suspended);\r\nif (status)\r\ngoto fail;\r\nINFO(cdev, "%s ready\n", composite->name);\r\nreturn 0;\r\nfail:\r\ncomposite_unbind(gadget);\r\nreturn status;\r\n}\r\nstatic void\r\ncomposite_suspend(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_function *f;\r\nDBG(cdev, "suspend\n");\r\nif (cdev->config) {\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (f->suspend)\r\nf->suspend(f);\r\n}\r\n}\r\nif (composite->suspend)\r\ncomposite->suspend(cdev);\r\ncdev->suspended = 1;\r\nusb_gadget_vbus_draw(gadget, 2);\r\n}\r\nstatic void\r\ncomposite_resume(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_function *f;\r\nu8 maxpower;\r\nDBG(cdev, "resume\n");\r\nif (composite->resume)\r\ncomposite->resume(cdev);\r\nif (cdev->config) {\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (f->resume)\r\nf->resume(f);\r\n}\r\nmaxpower = cdev->config->bMaxPower;\r\nusb_gadget_vbus_draw(gadget, maxpower ?\r\n(2 * maxpower) : CONFIG_USB_GADGET_VBUS_DRAW);\r\n}\r\ncdev->suspended = 0;\r\n}\r\nint usb_composite_probe(struct usb_composite_driver *driver)\r\n{\r\nif (!driver || !driver->dev || composite || !driver->bind)\r\nreturn -EINVAL;\r\nif (!driver->name)\r\ndriver->name = "composite";\r\nif (!driver->iProduct)\r\ndriver->iProduct = driver->name;\r\ncomposite_driver.function = (char *) driver->name;\r\ncomposite_driver.driver.name = driver->name;\r\ncomposite_driver.max_speed = driver->max_speed;\r\ncomposite = driver;\r\nreturn usb_gadget_probe_driver(&composite_driver);\r\n}\r\nvoid usb_composite_unregister(struct usb_composite_driver *driver)\r\n{\r\nif (composite != driver)\r\nreturn;\r\nusb_gadget_unregister_driver(&composite_driver);\r\n}\r\nvoid usb_composite_setup_continue(struct usb_composite_dev *cdev)\r\n{\r\nint value;\r\nstruct usb_request *req = cdev->req;\r\nunsigned long flags;\r\nDBG(cdev, "%s\n", __func__);\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->delayed_status == 0) {\r\nWARN(cdev, "%s: Unexpected call\n", __func__);\r\n} else if (--cdev->delayed_status == 0) {\r\nDBG(cdev, "%s: Completing delayed status\n", __func__);\r\nreq->length = 0;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\nDBG(cdev, "ep_queue --> %d\n", value);\r\nreq->status = 0;\r\ncomposite_setup_complete(cdev->gadget->ep0, req);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\n}
