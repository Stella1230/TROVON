static int enable_mdp_irq(struct mdp_info *mdp, uint32_t mask)\r\n{\r\nunsigned long irq_flags;\r\nint ret = 0;\r\nBUG_ON(!mask);\r\nspin_lock_irqsave(&mdp_lock, irq_flags);\r\nif (mdp_irq_mask & mask) {\r\nprintk(KERN_ERR "mdp irq already on already on %x %x\n",\r\nmdp_irq_mask, mask);\r\nret = -1;\r\n}\r\nif (!mdp_irq_mask) {\r\nif (clk)\r\nclk_enable(clk);\r\nenable_irq(mdp->irq);\r\n}\r\nmdp_irq_mask |= mask;\r\nspin_unlock_irqrestore(&mdp_lock, irq_flags);\r\nreturn ret;\r\n}\r\nstatic int locked_disable_mdp_irq(struct mdp_info *mdp, uint32_t mask)\r\n{\r\nif (!(mdp_irq_mask & mask)) {\r\nprintk(KERN_ERR "mdp irq already off %x %x\n",\r\nmdp_irq_mask, mask);\r\nreturn -1;\r\n}\r\nmdp_irq_mask &= ~(mask);\r\nif (!mdp_irq_mask) {\r\ndisable_irq_nosync(mdp->irq);\r\nif (clk)\r\nclk_disable(clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int disable_mdp_irq(struct mdp_info *mdp, uint32_t mask)\r\n{\r\nunsigned long irq_flags;\r\nint ret;\r\nspin_lock_irqsave(&mdp_lock, irq_flags);\r\nret = locked_disable_mdp_irq(mdp, mask);\r\nspin_unlock_irqrestore(&mdp_lock, irq_flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t mdp_isr(int irq, void *data)\r\n{\r\nuint32_t status;\r\nunsigned long irq_flags;\r\nstruct mdp_info *mdp = data;\r\nspin_lock_irqsave(&mdp_lock, irq_flags);\r\nstatus = mdp_readl(mdp, MDP_INTR_STATUS);\r\nmdp_writel(mdp, status, MDP_INTR_CLEAR);\r\nstatus &= mdp_irq_mask;\r\nif (status & DL0_DMA2_TERM_DONE) {\r\nif (dma_callback) {\r\ndma_callback->func(dma_callback);\r\ndma_callback = NULL;\r\n}\r\nwake_up(&mdp_dma2_waitqueue);\r\n}\r\nif (status & DL0_ROI_DONE)\r\nwake_up(&mdp_ppp_waitqueue);\r\nif (status)\r\nlocked_disable_mdp_irq(mdp, status);\r\nspin_unlock_irqrestore(&mdp_lock, irq_flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic uint32_t mdp_check_mask(uint32_t mask)\r\n{\r\nuint32_t ret;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&mdp_lock, irq_flags);\r\nret = mdp_irq_mask & mask;\r\nspin_unlock_irqrestore(&mdp_lock, irq_flags);\r\nreturn ret;\r\n}\r\nstatic int mdp_wait(struct mdp_info *mdp, uint32_t mask, wait_queue_head_t *wq)\r\n{\r\nint ret = 0;\r\nunsigned long irq_flags;\r\nwait_event_timeout(*wq, !mdp_check_mask(mask), HZ);\r\nspin_lock_irqsave(&mdp_lock, irq_flags);\r\nif (mdp_irq_mask & mask) {\r\nlocked_disable_mdp_irq(mdp, mask);\r\nprintk(KERN_WARNING "timeout waiting for mdp to complete %x\n",\r\nmask);\r\nret = -ETIMEDOUT;\r\n}\r\nspin_unlock_irqrestore(&mdp_lock, irq_flags);\r\nreturn ret;\r\n}\r\nvoid mdp_dma_wait(struct mdp_device *mdp_dev)\r\n{\r\n#define MDP_MAX_TIMEOUTS 20\r\nstatic int timeout_count;\r\nstruct mdp_info *mdp = container_of(mdp_dev, struct mdp_info, mdp_dev);\r\nif (mdp_wait(mdp, DL0_DMA2_TERM_DONE, &mdp_dma2_waitqueue) == -ETIMEDOUT)\r\ntimeout_count++;\r\nelse\r\ntimeout_count = 0;\r\nif (timeout_count > MDP_MAX_TIMEOUTS) {\r\nprintk(KERN_ERR "mdp: dma failed %d times, somethings wrong!\n",\r\nMDP_MAX_TIMEOUTS);\r\nBUG();\r\n}\r\n}\r\nstatic int mdp_ppp_wait(struct mdp_info *mdp)\r\n{\r\nreturn mdp_wait(mdp, DL0_ROI_DONE, &mdp_ppp_waitqueue);\r\n}\r\nvoid mdp_dma_to_mddi(struct mdp_info *mdp, uint32_t addr, uint32_t stride,\r\nuint32_t width, uint32_t height, uint32_t x, uint32_t y,\r\nstruct msmfb_callback *callback)\r\n{\r\nuint32_t dma2_cfg;\r\nuint16_t ld_param = 0;\r\nif (enable_mdp_irq(mdp, DL0_DMA2_TERM_DONE)) {\r\nprintk(KERN_ERR "mdp_dma_to_mddi: busy\n");\r\nreturn;\r\n}\r\ndma_callback = callback;\r\ndma2_cfg = DMA_PACK_TIGHT |\r\nDMA_PACK_ALIGN_LSB |\r\nDMA_PACK_PATTERN_RGB |\r\nDMA_OUT_SEL_AHB |\r\nDMA_IBUF_NONCONTIGUOUS;\r\ndma2_cfg |= DMA_IBUF_FORMAT_RGB565;\r\ndma2_cfg |= DMA_OUT_SEL_MDDI;\r\ndma2_cfg |= DMA_MDDI_DMAOUT_LCD_SEL_PRIMARY;\r\ndma2_cfg |= DMA_DITHER_EN;\r\nmdp_writel(mdp, (height << 16) | (width),\r\nMDP_CMD_DEBUG_ACCESS_BASE + 0x0184);\r\nmdp_writel(mdp, addr, MDP_CMD_DEBUG_ACCESS_BASE + 0x0188);\r\nmdp_writel(mdp, stride, MDP_CMD_DEBUG_ACCESS_BASE + 0x018C);\r\ndma2_cfg |= DMA_DSTC0G_6BITS | DMA_DSTC1B_6BITS | DMA_DSTC2R_6BITS;\r\nmdp_writel(mdp, (y << 16) | (x), MDP_CMD_DEBUG_ACCESS_BASE + 0x0194);\r\nmdp_writel(mdp, ld_param, MDP_CMD_DEBUG_ACCESS_BASE + 0x01a0);\r\nmdp_writel(mdp, (MDDI_VDO_PACKET_DESC << 16) | MDDI_VDO_PACKET_PRIM,\r\nMDP_CMD_DEBUG_ACCESS_BASE + 0x01a4);\r\nmdp_writel(mdp, dma2_cfg, MDP_CMD_DEBUG_ACCESS_BASE + 0x0180);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0044);\r\n}\r\nvoid mdp_dma(struct mdp_device *mdp_dev, uint32_t addr, uint32_t stride,\r\nuint32_t width, uint32_t height, uint32_t x, uint32_t y,\r\nstruct msmfb_callback *callback, int interface)\r\n{\r\nstruct mdp_info *mdp = container_of(mdp_dev, struct mdp_info, mdp_dev);\r\nif (interface == MSM_MDDI_PMDH_INTERFACE) {\r\nmdp_dma_to_mddi(mdp, addr, stride, width, height, x, y,\r\ncallback);\r\n}\r\n}\r\nint get_img(struct mdp_img *img, struct fb_info *info,\r\nunsigned long *start, unsigned long *len,\r\nstruct file **filep)\r\n{\r\nint ret = 0;\r\nstruct fd f = fdget(img->memory_id);\r\nif (f.file == NULL)\r\nreturn -1;\r\nif (MAJOR(f.file->f_dentry->d_inode->i_rdev) == FB_MAJOR) {\r\n*start = info->fix.smem_start;\r\n*len = info->fix.smem_len;\r\n} else\r\nret = -1;\r\nfdput(f);\r\nreturn ret;\r\n}\r\nvoid put_img(struct file *src_file, struct file *dst_file)\r\n{\r\n}\r\nint mdp_blit(struct mdp_device *mdp_dev, struct fb_info *fb,\r\nstruct mdp_blit_req *req)\r\n{\r\nint ret;\r\nunsigned long src_start = 0, src_len = 0, dst_start = 0, dst_len = 0;\r\nstruct mdp_info *mdp = container_of(mdp_dev, struct mdp_info, mdp_dev);\r\nstruct file *src_file = 0, *dst_file = 0;\r\nif (unlikely(req->src_rect.h == 0 ||\r\nreq->src_rect.w == 0)) {\r\nprintk(KERN_ERR "mpd_ppp: src img of zero size!\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(req->dst_rect.h == 0 ||\r\nreq->dst_rect.w == 0))\r\nreturn -EINVAL;\r\nif (unlikely(get_img(&req->src, fb, &src_start, &src_len, &src_file))) {\r\nprintk(KERN_ERR "mpd_ppp: could not retrieve src image from "\r\n"memory\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(get_img(&req->dst, fb, &dst_start, &dst_len, &dst_file))) {\r\nprintk(KERN_ERR "mpd_ppp: could not retrieve dst image from "\r\n"memory\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mdp_mutex);\r\nreq->transp_mask = MDP_TRANSP_NOP;\r\nif (unlikely((req->transp_mask != MDP_TRANSP_NOP ||\r\nreq->alpha != MDP_ALPHA_NOP ||\r\nHAS_ALPHA(req->src.format)) &&\r\n(req->flags & MDP_ROT_90 &&\r\nreq->dst_rect.w <= 16 && req->dst_rect.h >= 16))) {\r\nint i;\r\nunsigned int tiles = req->dst_rect.h / 16;\r\nunsigned int remainder = req->dst_rect.h % 16;\r\nreq->src_rect.w = 16*req->src_rect.w / req->dst_rect.h;\r\nreq->dst_rect.h = 16;\r\nfor (i = 0; i < tiles; i++) {\r\nenable_mdp_irq(mdp, DL0_ROI_DONE);\r\nret = mdp_ppp_blit(mdp, req, src_file, src_start,\r\nsrc_len, dst_file, dst_start,\r\ndst_len);\r\nif (ret)\r\ngoto err_bad_blit;\r\nret = mdp_ppp_wait(mdp);\r\nif (ret)\r\ngoto err_wait_failed;\r\nreq->dst_rect.y += 16;\r\nreq->src_rect.x += req->src_rect.w;\r\n}\r\nif (!remainder)\r\ngoto end;\r\nreq->src_rect.w = remainder*req->src_rect.w / req->dst_rect.h;\r\nreq->dst_rect.h = remainder;\r\n}\r\nenable_mdp_irq(mdp, DL0_ROI_DONE);\r\nret = mdp_ppp_blit(mdp, req, src_file, src_start, src_len, dst_file,\r\ndst_start,\r\ndst_len);\r\nif (ret)\r\ngoto err_bad_blit;\r\nret = mdp_ppp_wait(mdp);\r\nif (ret)\r\ngoto err_wait_failed;\r\nend:\r\nput_img(src_file, dst_file);\r\nmutex_unlock(&mdp_mutex);\r\nreturn 0;\r\nerr_bad_blit:\r\ndisable_mdp_irq(mdp, DL0_ROI_DONE);\r\nerr_wait_failed:\r\nput_img(src_file, dst_file);\r\nmutex_unlock(&mdp_mutex);\r\nreturn ret;\r\n}\r\nvoid mdp_set_grp_disp(struct mdp_device *mdp_dev, unsigned disp_id)\r\n{\r\nstruct mdp_info *mdp = container_of(mdp_dev, struct mdp_info, mdp_dev);\r\ndisp_id &= 0xf;\r\nmdp_writel(mdp, disp_id, MDP_FULL_BYPASS_WORD43);\r\n}\r\nint register_mdp_client(struct class_interface *cint)\r\n{\r\nif (!mdp_class) {\r\npr_err("mdp: no mdp_class when registering mdp client\n");\r\nreturn -ENODEV;\r\n}\r\ncint->class = mdp_class;\r\nreturn class_interface_register(cint);\r\n}\r\nint mdp_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *resource;\r\nint ret;\r\nint n;\r\nstruct mdp_info *mdp;\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!resource) {\r\npr_err("mdp: can not get mdp mem resource!\n");\r\nreturn -ENOMEM;\r\n}\r\nmdp = kzalloc(sizeof(struct mdp_info), GFP_KERNEL);\r\nif (!mdp)\r\nreturn -ENOMEM;\r\nmdp->irq = platform_get_irq(pdev, 0);\r\nif (mdp->irq < 0) {\r\npr_err("mdp: can not get mdp irq\n");\r\nret = mdp->irq;\r\ngoto error_get_irq;\r\n}\r\nmdp->base = ioremap(resource->start, resource_size(resource));\r\nif (mdp->base == 0) {\r\nprintk(KERN_ERR "msmfb: cannot allocate mdp regs!\n");\r\nret = -ENOMEM;\r\ngoto error_ioremap;\r\n}\r\nmdp->mdp_dev.dma = mdp_dma;\r\nmdp->mdp_dev.dma_wait = mdp_dma_wait;\r\nmdp->mdp_dev.blit = mdp_blit;\r\nmdp->mdp_dev.set_grp_disp = mdp_set_grp_disp;\r\nclk = clk_get(&pdev->dev, "mdp_clk");\r\nif (IS_ERR(clk)) {\r\nprintk(KERN_INFO "mdp: failed to get mdp clk");\r\nret = PTR_ERR(clk);\r\ngoto error_get_clk;\r\n}\r\nret = request_irq(mdp->irq, mdp_isr, 0, "msm_mdp", mdp);\r\nif (ret)\r\ngoto error_request_irq;\r\ndisable_irq(mdp->irq);\r\nmdp_irq_mask = 0;\r\nmdp_writel(mdp, 1, 0x60);\r\nmdp_writel(mdp, MDP_ANY_INTR_MASK, MDP_INTR_ENABLE);\r\nmdp_writel(mdp, 1, MDP_EBI2_PORTMAP_MODE);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01f8);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01fc);\r\nfor (n = 0; n < ARRAY_SIZE(csc_table); n++)\r\nmdp_writel(mdp, csc_table[n].val, csc_table[n].reg);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0120);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x012c);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0130);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0134);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0158);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x015c);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0160);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0170);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0174);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x017c);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0114);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x0118);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01c8);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01d0);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01dc);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01e0);\r\nmdp_writel(mdp, 0, MDP_CMD_DEBUG_ACCESS_BASE + 0x01e4);\r\nfor (n = 0; n < ARRAY_SIZE(mdp_upscale_table); n++)\r\nmdp_writel(mdp, mdp_upscale_table[n].val,\r\nmdp_upscale_table[n].reg);\r\nfor (n = 0; n < 9; n++)\r\nmdp_writel(mdp, mdp_default_ccs[n], 0x40440 + 4 * n);\r\nmdp_writel(mdp, mdp_default_ccs[9], 0x40500 + 4 * 0);\r\nmdp_writel(mdp, mdp_default_ccs[10], 0x40500 + 4 * 0);\r\nmdp_writel(mdp, mdp_default_ccs[11], 0x40500 + 4 * 0);\r\nmdp->mdp_dev.dev.parent = &pdev->dev;\r\nmdp->mdp_dev.dev.class = mdp_class;\r\ndev_set_name(&mdp->mdp_dev.dev, "mdp%d", pdev->id);\r\nret = device_register(&mdp->mdp_dev.dev);\r\nif (ret)\r\ngoto error_device_register;\r\nreturn 0;\r\nerror_device_register:\r\nfree_irq(mdp->irq, mdp);\r\nerror_request_irq:\r\nerror_get_clk:\r\niounmap(mdp->base);\r\nerror_get_irq:\r\nerror_ioremap:\r\nkfree(mdp);\r\nreturn ret;\r\n}\r\nstatic int __init mdp_init(void)\r\n{\r\nmdp_class = class_create(THIS_MODULE, "msm_mdp");\r\nif (IS_ERR(mdp_class)) {\r\nprintk(KERN_ERR "Error creating mdp class\n");\r\nreturn PTR_ERR(mdp_class);\r\n}\r\nreturn platform_driver_register(&msm_mdp_driver);\r\n}
