static u8 IN_TO_REG(unsigned val)\r\n{\r\nunsigned nval = SENSORS_LIMIT(val, ASB100_IN_MIN, ASB100_IN_MAX);\r\nreturn (nval + 8) / 16;\r\n}\r\nstatic unsigned IN_FROM_REG(u8 reg)\r\n{\r\nreturn reg * 16;\r\n}\r\nstatic u8 FAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm == -1)\r\nreturn 0;\r\nif (rpm == 0)\r\nreturn 255;\r\nrpm = SENSORS_LIMIT(rpm, 1, 1000000);\r\nreturn SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic int FAN_FROM_REG(u8 val, int div)\r\n{\r\nreturn val == 0 ? -1 : val == 255 ? 0 : 1350000 / (val * div);\r\n}\r\nstatic u8 TEMP_TO_REG(long temp)\r\n{\r\nint ntemp = SENSORS_LIMIT(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);\r\nntemp += (ntemp < 0 ? -500 : 500);\r\nreturn (u8)(ntemp / 1000);\r\n}\r\nstatic int TEMP_FROM_REG(u8 reg)\r\n{\r\nreturn (s8)reg * 1000;\r\n}\r\nstatic u8 ASB100_PWM_TO_REG(int pwm)\r\n{\r\npwm = SENSORS_LIMIT(pwm, 0, 255);\r\nreturn (u8)(pwm / 16);\r\n}\r\nstatic int ASB100_PWM_FROM_REG(u8 reg)\r\n{\r\nreturn reg * 16;\r\n}\r\nstatic u8 DIV_TO_REG(long val)\r\n{\r\nreturn val == 8 ? 3 : val == 4 ? 2 : val == 1 ? 0 : 1;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr],\r\nDIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nasb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nunsigned long min;\r\nint reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nmin = FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\ndata->fan_div[nr] = DIV_TO_REG(val);\r\nswitch (nr) {\r\ncase 0:\r\nreg = asb100_read_value(client, ASB100_REG_VID_FANDIV);\r\nreg = (reg & 0xcf) | (data->fan_div[0] << 4);\r\nasb100_write_value(client, ASB100_REG_VID_FANDIV, reg);\r\nbreak;\r\ncase 1:\r\nreg = asb100_read_value(client, ASB100_REG_VID_FANDIV);\r\nreg = (reg & 0x3f) | (data->fan_div[1] << 6);\r\nasb100_write_value(client, ASB100_REG_VID_FANDIV, reg);\r\nbreak;\r\ncase 2:\r\nreg = asb100_read_value(client, ASB100_REG_PIN);\r\nreg = (reg & 0x3f) | (data->fan_div[2] << 6);\r\nasb100_write_value(client, ASB100_REG_PIN, reg);\r\nbreak;\r\n}\r\ndata->fan_min[nr] =\r\nFAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nasb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int sprintf_temp_from_reg(u16 reg, char *buf, int nr)\r\n{\r\nint ret = 0;\r\nswitch (nr) {\r\ncase 1: case 2:\r\nret = sprintf(buf, "%d\n", LM75_TEMP_FROM_REG(reg));\r\nbreak;\r\ncase 0: case 3: default:\r\nret = sprintf(buf, "%d\n", TEMP_FROM_REG(reg));\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t show_vrm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asb100_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->vrm);\r\n}\r\nstatic ssize_t set_vrm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asb100_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t show_pwm1(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%d\n", ASB100_PWM_FROM_REG(data->pwm & 0x0f));\r\n}\r\nstatic ssize_t set_pwm1(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm &= 0x80;\r\ndata->pwm |= (0x0f & ASB100_PWM_TO_REG(val));\r\nasb100_write_value(client, ASB100_REG_PWM1, data->pwm);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable1(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct asb100_data *data = asb100_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->pwm & 0x80) ? 1 : 0);\r\n}\r\nstatic ssize_t set_pwm_enable1(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm &= 0x0f;\r\ndata->pwm |= (val ? 0x80 : 0x00);\r\nasb100_write_value(client, ASB100_REG_PWM1, data->pwm);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int asb100_detect_subclients(struct i2c_client *client)\r\n{\r\nint i, id, err;\r\nint address = client->addr;\r\nunsigned short sc_addr[2];\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nstruct i2c_adapter *adapter = client->adapter;\r\nid = i2c_adapter_id(adapter);\r\nif (force_subclients[0] == id && force_subclients[1] == address) {\r\nfor (i = 2; i <= 3; i++) {\r\nif (force_subclients[i] < 0x48 ||\r\nforce_subclients[i] > 0x4f) {\r\ndev_err(&client->dev, "invalid subclient "\r\n"address %d; must be 0x48-0x4f\n",\r\nforce_subclients[i]);\r\nerr = -ENODEV;\r\ngoto ERROR_SC_2;\r\n}\r\n}\r\nasb100_write_value(client, ASB100_REG_I2C_SUBADDR,\r\n(force_subclients[2] & 0x07) |\r\n((force_subclients[3] & 0x07) << 4));\r\nsc_addr[0] = force_subclients[2];\r\nsc_addr[1] = force_subclients[3];\r\n} else {\r\nint val = asb100_read_value(client, ASB100_REG_I2C_SUBADDR);\r\nsc_addr[0] = 0x48 + (val & 0x07);\r\nsc_addr[1] = 0x48 + ((val >> 4) & 0x07);\r\n}\r\nif (sc_addr[0] == sc_addr[1]) {\r\ndev_err(&client->dev, "duplicate addresses 0x%x "\r\n"for subclients\n", sc_addr[0]);\r\nerr = -ENODEV;\r\ngoto ERROR_SC_2;\r\n}\r\ndata->lm75[0] = i2c_new_dummy(adapter, sc_addr[0]);\r\nif (!data->lm75[0]) {\r\ndev_err(&client->dev, "subclient %d registration "\r\n"at address 0x%x failed.\n", 1, sc_addr[0]);\r\nerr = -ENOMEM;\r\ngoto ERROR_SC_2;\r\n}\r\ndata->lm75[1] = i2c_new_dummy(adapter, sc_addr[1]);\r\nif (!data->lm75[1]) {\r\ndev_err(&client->dev, "subclient %d registration "\r\n"at address 0x%x failed.\n", 2, sc_addr[1]);\r\nerr = -ENOMEM;\r\ngoto ERROR_SC_3;\r\n}\r\nreturn 0;\r\nERROR_SC_3:\r\ni2c_unregister_device(data->lm75[0]);\r\nERROR_SC_2:\r\nreturn err;\r\n}\r\nstatic int asb100_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint val1, val2;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\npr_debug("detect failed, smbus byte data not supported!\n");\r\nreturn -ENODEV;\r\n}\r\nval1 = i2c_smbus_read_byte_data(client, ASB100_REG_BANK);\r\nval2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);\r\nif ((!(val1 & 0x07)) &&\r\n(((!(val1 & 0x80)) && (val2 != 0x94)) ||\r\n((val1 & 0x80) && (val2 != 0x06)))) {\r\npr_debug("detect failed, bad chip id 0x%02x!\n", val2);\r\nreturn -ENODEV;\r\n}\r\ni2c_smbus_write_byte_data(client, ASB100_REG_BANK,\r\n(i2c_smbus_read_byte_data(client, ASB100_REG_BANK) & 0x78)\r\n| 0x80);\r\nval1 = i2c_smbus_read_byte_data(client, ASB100_REG_WCHIPID);\r\nval2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);\r\nif (val1 != 0x31 || val2 != 0x06)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "asb100", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int asb100_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err;\r\nstruct asb100_data *data;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct asb100_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\nmutex_init(&data->update_lock);\r\nerr = asb100_detect_subclients(client);\r\nif (err)\r\nreturn err;\r\nasb100_init_client(client);\r\ndata->fan_min[0] = asb100_read_value(client, ASB100_REG_FAN_MIN(0));\r\ndata->fan_min[1] = asb100_read_value(client, ASB100_REG_FAN_MIN(1));\r\ndata->fan_min[2] = asb100_read_value(client, ASB100_REG_FAN_MIN(2));\r\nerr = sysfs_create_group(&client->dev.kobj, &asb100_group);\r\nif (err)\r\ngoto ERROR3;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto ERROR4;\r\n}\r\nreturn 0;\r\nERROR4:\r\nsysfs_remove_group(&client->dev.kobj, &asb100_group);\r\nERROR3:\r\ni2c_unregister_device(data->lm75[1]);\r\ni2c_unregister_device(data->lm75[0]);\r\nreturn err;\r\n}\r\nstatic int asb100_remove(struct i2c_client *client)\r\n{\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &asb100_group);\r\ni2c_unregister_device(data->lm75[1]);\r\ni2c_unregister_device(data->lm75[0]);\r\nreturn 0;\r\n}\r\nstatic int asb100_read_value(struct i2c_client *client, u16 reg)\r\n{\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nstruct i2c_client *cl;\r\nint res, bank;\r\nmutex_lock(&data->lock);\r\nbank = (reg >> 8) & 0x0f;\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, ASB100_REG_BANK, bank);\r\nif (bank == 0 || bank > 2) {\r\nres = i2c_smbus_read_byte_data(client, reg & 0xff);\r\n} else {\r\ncl = data->lm75[bank - 1];\r\nswitch (reg & 0xff) {\r\ncase 0x50:\r\nres = i2c_smbus_read_word_swapped(cl, 0);\r\nbreak;\r\ncase 0x52:\r\nres = i2c_smbus_read_byte_data(cl, 1);\r\nbreak;\r\ncase 0x53:\r\nres = i2c_smbus_read_word_swapped(cl, 2);\r\nbreak;\r\ncase 0x55:\r\ndefault:\r\nres = i2c_smbus_read_word_swapped(cl, 3);\r\nbreak;\r\n}\r\n}\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);\r\nmutex_unlock(&data->lock);\r\nreturn res;\r\n}\r\nstatic void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)\r\n{\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nstruct i2c_client *cl;\r\nint bank;\r\nmutex_lock(&data->lock);\r\nbank = (reg >> 8) & 0x0f;\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, ASB100_REG_BANK, bank);\r\nif (bank == 0 || bank > 2) {\r\ni2c_smbus_write_byte_data(client, reg & 0xff, value & 0xff);\r\n} else {\r\ncl = data->lm75[bank - 1];\r\nswitch (reg & 0xff) {\r\ncase 0x52:\r\ni2c_smbus_write_byte_data(cl, 1, value & 0xff);\r\nbreak;\r\ncase 0x53:\r\ni2c_smbus_write_word_swapped(cl, 2, value);\r\nbreak;\r\ncase 0x55:\r\ni2c_smbus_write_word_swapped(cl, 3, value);\r\nbreak;\r\n}\r\n}\r\nif (bank > 2)\r\ni2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic void asb100_init_client(struct i2c_client *client)\r\n{\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\ndata->vrm = vid_which_vrm();\r\nasb100_write_value(client, ASB100_REG_CONFIG,\r\n(asb100_read_value(client, ASB100_REG_CONFIG) & 0xf7) | 0x01);\r\n}\r\nstatic struct asb100_data *asb100_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct asb100_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\ndev_dbg(&client->dev, "starting device update...\n");\r\nfor (i = 0; i < 7; i++) {\r\ndata->in[i] = asb100_read_value(client,\r\nASB100_REG_IN(i));\r\ndata->in_min[i] = asb100_read_value(client,\r\nASB100_REG_IN_MIN(i));\r\ndata->in_max[i] = asb100_read_value(client,\r\nASB100_REG_IN_MAX(i));\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ndata->fan[i] = asb100_read_value(client,\r\nASB100_REG_FAN(i));\r\ndata->fan_min[i] = asb100_read_value(client,\r\nASB100_REG_FAN_MIN(i));\r\n}\r\nfor (i = 1; i <= 4; i++) {\r\ndata->temp[i-1] = asb100_read_value(client,\r\nASB100_REG_TEMP(i));\r\ndata->temp_max[i-1] = asb100_read_value(client,\r\nASB100_REG_TEMP_MAX(i));\r\ndata->temp_hyst[i-1] = asb100_read_value(client,\r\nASB100_REG_TEMP_HYST(i));\r\n}\r\ni = asb100_read_value(client, ASB100_REG_VID_FANDIV);\r\ndata->vid = i & 0x0f;\r\ndata->vid |= (asb100_read_value(client,\r\nASB100_REG_CHIPID) & 0x01) << 4;\r\ndata->fan_div[0] = (i >> 4) & 0x03;\r\ndata->fan_div[1] = (i >> 6) & 0x03;\r\ndata->fan_div[2] = (asb100_read_value(client,\r\nASB100_REG_PIN) >> 6) & 0x03;\r\ndata->pwm = asb100_read_value(client, ASB100_REG_PWM1);\r\ndata->alarms = asb100_read_value(client, ASB100_REG_ALARM1) +\r\n(asb100_read_value(client, ASB100_REG_ALARM2) << 8);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\ndev_dbg(&client->dev, "... device update complete\n");\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
