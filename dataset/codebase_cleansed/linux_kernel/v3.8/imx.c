static inline unsigned uts_reg(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->uts_reg;\r\n}\r\nstatic inline int is_imx1_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX1_UART;\r\n}\r\nstatic inline int is_imx21_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX21_UART;\r\n}\r\nstatic void imx_port_ucrs_save(struct uart_port *port,\r\nstruct imx_port_ucrs *ucr)\r\n{\r\nucr->ucr1 = readl(port->membase + UCR1);\r\nucr->ucr2 = readl(port->membase + UCR2);\r\nucr->ucr3 = readl(port->membase + UCR3);\r\n}\r\nstatic void imx_port_ucrs_restore(struct uart_port *port,\r\nstruct imx_port_ucrs *ucr)\r\n{\r\nwritel(ucr->ucr1, port->membase + UCR1);\r\nwritel(ucr->ucr2, port->membase + UCR2);\r\nwritel(ucr->ucr3, port->membase + UCR3);\r\n}\r\nstatic void imx_mctrl_check(struct imx_port *sport)\r\n{\r\nunsigned int status, changed;\r\nstatus = sport->port.ops->get_mctrl(&sport->port);\r\nchanged = status ^ sport->old_status;\r\nif (changed == 0)\r\nreturn;\r\nsport->old_status = status;\r\nif (changed & TIOCM_RI)\r\nsport->port.icount.rng++;\r\nif (changed & TIOCM_DSR)\r\nsport->port.icount.dsr++;\r\nif (changed & TIOCM_CAR)\r\nuart_handle_dcd_change(&sport->port, status & TIOCM_CAR);\r\nif (changed & TIOCM_CTS)\r\nuart_handle_cts_change(&sport->port, status & TIOCM_CTS);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\n}\r\nstatic void imx_timeout(unsigned long data)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)data;\r\nunsigned long flags;\r\nif (sport->port.state) {\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_mctrl_check(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nmod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);\r\n}\r\n}\r\nstatic void imx_stop_tx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (USE_IRDA(sport)) {\r\nint n = 256;\r\nwhile ((--n > 0) &&\r\n!(readl(sport->port.membase + USR2) & USR2_TXDC)) {\r\nudelay(5);\r\nbarrier();\r\n}\r\nudelay(sport->trcv_delay);\r\nif (readl(sport->port.membase + USR2) & USR2_TXDC) {\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_TXMPTYEN | UCR1_TRDYEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp &= ~(UCR4_TCEN);\r\nwritel(temp, sport->port.membase + UCR4);\r\nwhile (readl(sport->port.membase + URXD0) &\r\nURXD_CHARRDY)\r\nbarrier();\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_DREN;\r\nwritel(temp, sport->port.membase + UCR4);\r\n}\r\nreturn;\r\n}\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp & ~UCR1_TXMPTYEN, sport->port.membase + UCR1);\r\n}\r\nstatic void imx_stop_rx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + UCR2);\r\nwritel(temp &~ UCR2_RXEN, sport->port.membase + UCR2);\r\n}\r\nstatic void imx_enable_ms(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nmod_timer(&sport->timer, jiffies);\r\n}\r\nstatic inline void imx_transmit_buffer(struct imx_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nwhile (!uart_circ_empty(xmit) &&\r\n!(readl(sport->port.membase + uts_reg(sport))\r\n& UTS_TXFULL)) {\r\nwritel(xmit->buf[xmit->tail], sport->port.membase + URTX0);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nimx_stop_tx(&sport->port);\r\n}\r\nstatic void imx_start_tx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (USE_IRDA(sport)) {\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp &= ~(UCR4_DREN);\r\nwritel(temp, sport->port.membase + UCR4);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_RRDYEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\n}\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp | UCR1_TXMPTYEN, sport->port.membase + UCR1);\r\nif (USE_IRDA(sport)) {\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_TRDYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_TCEN;\r\nwritel(temp, sport->port.membase + UCR4);\r\n}\r\nif (readl(sport->port.membase + uts_reg(sport)) & UTS_TXEMPTY)\r\nimx_transmit_buffer(sport);\r\n}\r\nstatic irqreturn_t imx_rtsint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwritel(USR1_RTSD, sport->port.membase + USR1);\r\nval = readl(sport->port.membase + USR1) & USR1_RTSS;\r\nuart_handle_cts_change(&sport->port, !!val);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_txint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock,flags);\r\nif (sport->port.x_char)\r\n{\r\nwritel(sport->port.x_char, sport->port.membase + URTX0);\r\ngoto out;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\r\nimx_stop_tx(&sport->port);\r\ngoto out;\r\n}\r\nimx_transmit_buffer(sport);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock,flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_rxint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int rx,flg,ignored = 0;\r\nstruct tty_struct *tty = sport->port.state->port.tty;\r\nunsigned long flags, temp;\r\nspin_lock_irqsave(&sport->port.lock,flags);\r\nwhile (readl(sport->port.membase + USR2) & USR2_RDR) {\r\nflg = TTY_NORMAL;\r\nsport->port.icount.rx++;\r\nrx = readl(sport->port.membase + URXD0);\r\ntemp = readl(sport->port.membase + USR2);\r\nif (temp & USR2_BRCD) {\r\nwritel(USR2_BRCD, sport->port.membase + USR2);\r\nif (uart_handle_break(&sport->port))\r\ncontinue;\r\n}\r\nif (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))\r\ncontinue;\r\nif (unlikely(rx & URXD_ERR)) {\r\nif (rx & URXD_BRK)\r\nsport->port.icount.brk++;\r\nelse if (rx & URXD_PRERR)\r\nsport->port.icount.parity++;\r\nelse if (rx & URXD_FRMERR)\r\nsport->port.icount.frame++;\r\nif (rx & URXD_OVRRUN)\r\nsport->port.icount.overrun++;\r\nif (rx & sport->port.ignore_status_mask) {\r\nif (++ignored > 100)\r\ngoto out;\r\ncontinue;\r\n}\r\nrx &= sport->port.read_status_mask;\r\nif (rx & URXD_BRK)\r\nflg = TTY_BREAK;\r\nelse if (rx & URXD_PRERR)\r\nflg = TTY_PARITY;\r\nelse if (rx & URXD_FRMERR)\r\nflg = TTY_FRAME;\r\nif (rx & URXD_OVRRUN)\r\nflg = TTY_OVERRUN;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\ntty_insert_flip_char(tty, rx, flg);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock,flags);\r\ntty_flip_buffer_push(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_int(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int sts;\r\nsts = readl(sport->port.membase + USR1);\r\nif (sts & USR1_RRDY)\r\nimx_rxint(irq, dev_id);\r\nif (sts & USR1_TRDY &&\r\nreadl(sport->port.membase + UCR1) & UCR1_TXMPTYEN)\r\nimx_txint(irq, dev_id);\r\nif (sts & USR1_RTSD)\r\nimx_rtsint(irq, dev_id);\r\nif (sts & USR1_AWAKE)\r\nwritel(USR1_AWAKE, sport->port.membase + USR1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int imx_tx_empty(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nreturn (readl(sport->port.membase + USR2) & USR2_TXDC) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int imx_get_mctrl(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned int tmp = TIOCM_DSR | TIOCM_CAR;\r\nif (readl(sport->port.membase + USR1) & USR1_RTSS)\r\ntmp |= TIOCM_CTS;\r\nif (readl(sport->port.membase + UCR2) & UCR2_CTS)\r\ntmp |= TIOCM_RTS;\r\nreturn tmp;\r\n}\r\nstatic void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + UCR2) & ~UCR2_CTS;\r\nif (mctrl & TIOCM_RTS)\r\ntemp |= UCR2_CTS;\r\nwritel(temp, sport->port.membase + UCR2);\r\n}\r\nstatic void imx_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags, temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1) & ~UCR1_SNDBRK;\r\nif ( break_state != 0 )\r\ntemp |= UCR1_SNDBRK;\r\nwritel(temp, sport->port.membase + UCR1);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic int imx_setup_ufcr(struct imx_port *sport, unsigned int mode)\r\n{\r\nunsigned int val;\r\nval = readl(sport->port.membase + UFCR) & (UFCR_RFDIV | UFCR_DCEDTE);\r\nval |= TXTL << UFCR_TXTL_SHF | RXTL;\r\nwritel(val, sport->port.membase + UFCR);\r\nreturn 0;\r\n}\r\nstatic int imx_startup(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nint retval;\r\nunsigned long flags, temp;\r\nimx_setup_ufcr(sport, 0);\r\ntemp = readl(sport->port.membase + UCR4);\r\nif (USE_IRDA(sport))\r\ntemp |= UCR4_IRSC;\r\ntemp &= ~(UCR4_CTSTL_MASK<< UCR4_CTSTL_SHF);\r\ntemp |= CTSTL<< UCR4_CTSTL_SHF;\r\nwritel(temp & ~UCR4_DREN, sport->port.membase + UCR4);\r\nif (USE_IRDA(sport)) {\r\nint i = 100;\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~UCR2_SRST;\r\nwritel(temp, sport->port.membase + UCR2);\r\nwhile (!(readl(sport->port.membase + UCR2) & UCR2_SRST) &&\r\n(--i > 0)) {\r\nudelay(1);\r\n}\r\n}\r\nif (sport->txirq > 0) {\r\nretval = request_irq(sport->rxirq, imx_rxint, 0,\r\nDRIVER_NAME, sport);\r\nif (retval)\r\ngoto error_out1;\r\nretval = request_irq(sport->txirq, imx_txint, 0,\r\nDRIVER_NAME, sport);\r\nif (retval)\r\ngoto error_out2;\r\nif (!USE_IRDA(sport)) {\r\nretval = request_irq(sport->rtsirq, imx_rtsint, 0,\r\nDRIVER_NAME, sport);\r\nif (retval)\r\ngoto error_out3;\r\n}\r\n} else {\r\nretval = request_irq(sport->port.irq, imx_int, 0,\r\nDRIVER_NAME, sport);\r\nif (retval) {\r\nfree_irq(sport->port.irq, sport);\r\ngoto error_out1;\r\n}\r\n}\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwritel(USR1_RTSD, sport->port.membase + USR1);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN;\r\nif (USE_IRDA(sport)) {\r\ntemp |= UCR1_IREN;\r\ntemp &= ~(UCR1_RTSDEN);\r\n}\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= (UCR2_RXEN | UCR2_TXEN);\r\nwritel(temp, sport->port.membase + UCR2);\r\nif (USE_IRDA(sport)) {\r\nint i = 64;\r\nwhile ((--i > 0) &&\r\n(readl(sport->port.membase + URXD0) & URXD_CHARRDY)) {\r\nbarrier();\r\n}\r\n}\r\nif (is_imx21_uart(sport)) {\r\ntemp = readl(sport->port.membase + UCR3);\r\ntemp |= IMX21_UCR3_RXDMUXSEL;\r\nwritel(temp, sport->port.membase + UCR3);\r\n}\r\nif (USE_IRDA(sport)) {\r\ntemp = readl(sport->port.membase + UCR4);\r\nif (sport->irda_inv_rx)\r\ntemp |= UCR4_INVR;\r\nelse\r\ntemp &= ~(UCR4_INVR);\r\nwritel(temp | UCR4_DREN, sport->port.membase + UCR4);\r\ntemp = readl(sport->port.membase + UCR3);\r\nif (sport->irda_inv_tx)\r\ntemp |= UCR3_INVT;\r\nelse\r\ntemp &= ~(UCR3_INVT);\r\nwritel(temp, sport->port.membase + UCR3);\r\n}\r\nimx_enable_ms(&sport->port);\r\nspin_unlock_irqrestore(&sport->port.lock,flags);\r\nif (USE_IRDA(sport)) {\r\nstruct imxuart_platform_data *pdata;\r\npdata = sport->port.dev->platform_data;\r\nsport->irda_inv_rx = pdata->irda_inv_rx;\r\nsport->irda_inv_tx = pdata->irda_inv_tx;\r\nsport->trcv_delay = pdata->transceiver_delay;\r\nif (pdata->irda_enable)\r\npdata->irda_enable(1);\r\n}\r\nreturn 0;\r\nerror_out3:\r\nif (sport->txirq)\r\nfree_irq(sport->txirq, sport);\r\nerror_out2:\r\nif (sport->rxirq)\r\nfree_irq(sport->rxirq, sport);\r\nerror_out1:\r\nreturn retval;\r\n}\r\nstatic void imx_shutdown(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_TXEN);\r\nwritel(temp, sport->port.membase + UCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nif (USE_IRDA(sport)) {\r\nstruct imxuart_platform_data *pdata;\r\npdata = sport->port.dev->platform_data;\r\nif (pdata->irda_enable)\r\npdata->irda_enable(0);\r\n}\r\ndel_timer_sync(&sport->timer);\r\nif (sport->txirq > 0) {\r\nif (!USE_IRDA(sport))\r\nfree_irq(sport->rtsirq, sport);\r\nfree_irq(sport->txirq, sport);\r\nfree_irq(sport->rxirq, sport);\r\n} else\r\nfree_irq(sport->port.irq, sport);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN);\r\nif (USE_IRDA(sport))\r\ntemp &= ~(UCR1_IREN);\r\nwritel(temp, sport->port.membase + UCR1);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void\r\nimx_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags;\r\nunsigned int ucr2, old_ucr1, old_txrxen, baud, quot;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nunsigned int div, ufcr;\r\nunsigned long num, denom;\r\nuint64_t tdiv64;\r\nif (0) {\r\ntermios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);\r\ntermios->c_cflag |= CLOCAL;\r\n}\r\nwhile ((termios->c_cflag & CSIZE) != CS7 &&\r\n(termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\nucr2 = UCR2_WS | UCR2_SRST | UCR2_IRTS;\r\nelse\r\nucr2 = UCR2_SRST | UCR2_IRTS;\r\nif (termios->c_cflag & CRTSCTS) {\r\nif( sport->have_rtscts ) {\r\nucr2 &= ~UCR2_IRTS;\r\nucr2 |= UCR2_CTSC;\r\n} else {\r\ntermios->c_cflag &= ~CRTSCTS;\r\n}\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nucr2 |= UCR2_STPB;\r\nif (termios->c_cflag & PARENB) {\r\nucr2 |= UCR2_PREN;\r\nif (termios->c_cflag & PARODD)\r\nucr2 |= UCR2_PROE;\r\n}\r\ndel_timer_sync(&sport->timer);\r\nbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\r\nquot = uart_get_divisor(port, baud);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |= (URXD_FRMERR | URXD_PRERR);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nsport->port.read_status_mask |= URXD_BRK;\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= URXD_PRERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |= URXD_BRK;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= URXD_OVRRUN;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nold_ucr1 = readl(sport->port.membase + UCR1);\r\nwritel(old_ucr1 & ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN),\r\nsport->port.membase + UCR1);\r\nwhile ( !(readl(sport->port.membase + USR2) & USR2_TXDC))\r\nbarrier();\r\nold_txrxen = readl(sport->port.membase + UCR2);\r\nwritel(old_txrxen & ~( UCR2_TXEN | UCR2_RXEN),\r\nsport->port.membase + UCR2);\r\nold_txrxen &= (UCR2_TXEN | UCR2_RXEN);\r\nif (USE_IRDA(sport)) {\r\ndiv = 1;\r\n} else {\r\ndiv = sport->port.uartclk / (baud * 16);\r\nif (div > 7)\r\ndiv = 7;\r\nif (!div)\r\ndiv = 1;\r\n}\r\nrational_best_approximation(16 * div * baud, sport->port.uartclk,\r\n1 << 16, 1 << 16, &num, &denom);\r\ntdiv64 = sport->port.uartclk;\r\ntdiv64 *= num;\r\ndo_div(tdiv64, denom * 16 * div);\r\ntty_termios_encode_baud_rate(termios,\r\n(speed_t)tdiv64, (speed_t)tdiv64);\r\nnum -= 1;\r\ndenom -= 1;\r\nufcr = readl(sport->port.membase + UFCR);\r\nufcr = (ufcr & (~UFCR_RFDIV)) | UFCR_RFDIV_REG(div);\r\nwritel(ufcr, sport->port.membase + UFCR);\r\nwritel(num, sport->port.membase + UBIR);\r\nwritel(denom, sport->port.membase + UBMR);\r\nif (is_imx21_uart(sport))\r\nwritel(sport->port.uartclk / div / 1000,\r\nsport->port.membase + IMX21_ONEMS);\r\nwritel(old_ucr1, sport->port.membase + UCR1);\r\nwritel(ucr2 | old_txrxen, sport->port.membase + UCR2);\r\nif (UART_ENABLE_MS(&sport->port, termios->c_cflag))\r\nimx_enable_ms(&sport->port);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic const char *imx_type(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nreturn sport->port.type == PORT_IMX ? "IMX" : NULL;\r\n}\r\nstatic void imx_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *mmres;\r\nmmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mmres->start, resource_size(mmres));\r\n}\r\nstatic int imx_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *mmres;\r\nvoid *ret;\r\nmmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mmres)\r\nreturn -ENODEV;\r\nret = request_mem_region(mmres->start, resource_size(mmres), "imx-uart");\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nstatic void imx_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nif (flags & UART_CONFIG_TYPE &&\r\nimx_request_port(&sport->port) == 0)\r\nsport->port.type = PORT_IMX;\r\n}\r\nstatic int\r\nimx_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_IMX)\r\nret = -EINVAL;\r\nif (sport->port.irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nret = -EINVAL;\r\nif (sport->port.uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif ((void *)sport->port.mapbase != ser->iomem_base)\r\nret = -EINVAL;\r\nif (sport->port.iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int imx_poll_get_char(struct uart_port *port)\r\n{\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int status;\r\nunsigned char c;\r\nimx_port_ucrs_save(port, &old_ucr);\r\nwritel(UCR1_UARTEN, port->membase + UCR1);\r\nwritel(old_ucr.ucr2 & ~(UCR2_ATEN | UCR2_RTSEN | UCR2_ESCI),\r\nport->membase + UCR2);\r\nwritel(old_ucr.ucr3 & ~(UCR3_DCD | UCR3_RI | UCR3_DTREN),\r\nport->membase + UCR3);\r\ndo {\r\nstatus = readl(port->membase + USR2);\r\n} while (~status & USR2_RDR);\r\nc = readl(port->membase + URXD0);\r\nimx_port_ucrs_restore(port, &old_ucr);\r\nreturn c;\r\n}\r\nstatic void imx_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int status;\r\nimx_port_ucrs_save(port, &old_ucr);\r\nwritel(UCR1_UARTEN, port->membase + UCR1);\r\nwritel(old_ucr.ucr2 & ~(UCR2_ATEN | UCR2_RTSEN | UCR2_ESCI),\r\nport->membase + UCR2);\r\nwritel(old_ucr.ucr3 & ~(UCR3_DCD | UCR3_RI | UCR3_DTREN),\r\nport->membase + UCR3);\r\ndo {\r\nstatus = readl(port->membase + USR1);\r\n} while (~status & USR1_TRDY);\r\nwritel(c, port->membase + URTX0);\r\ndo {\r\nstatus = readl(port->membase + USR2);\r\n} while (~status & USR2_TXDC);\r\nimx_port_ucrs_restore(port, &old_ucr);\r\n}\r\nstatic void imx_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nwhile (readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)\r\nbarrier();\r\nwritel(ch, sport->port.membase + URTX0);\r\n}\r\nstatic void\r\nimx_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct imx_port *sport = imx_ports[co->index];\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int ucr1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_port_ucrs_save(&sport->port, &old_ucr);\r\nucr1 = old_ucr.ucr1;\r\nif (is_imx1_uart(sport))\r\nucr1 |= IMX1_UCR1_UARTCLKEN;\r\nucr1 |= UCR1_UARTEN;\r\nucr1 &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN);\r\nwritel(ucr1, sport->port.membase + UCR1);\r\nwritel(old_ucr.ucr2 | UCR2_TXEN, sport->port.membase + UCR2);\r\nuart_console_write(&sport->port, s, count, imx_console_putchar);\r\nwhile (!(readl(sport->port.membase + USR2) & USR2_TXDC));\r\nimx_port_ucrs_restore(&sport->port, &old_ucr);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void __init\r\nimx_console_get_options(struct imx_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (readl(sport->port.membase + UCR1) & UCR1_UARTEN) {\r\nunsigned int ucr2, ubir,ubmr, uartclk;\r\nunsigned int baud_raw;\r\nunsigned int ucfr_rfdiv;\r\nucr2 = readl(sport->port.membase + UCR2);\r\n*parity = 'n';\r\nif (ucr2 & UCR2_PREN) {\r\nif (ucr2 & UCR2_PROE)\r\n*parity = 'o';\r\nelse\r\n*parity = 'e';\r\n}\r\nif (ucr2 & UCR2_WS)\r\n*bits = 8;\r\nelse\r\n*bits = 7;\r\nubir = readl(sport->port.membase + UBIR) & 0xffff;\r\nubmr = readl(sport->port.membase + UBMR) & 0xffff;\r\nucfr_rfdiv = (readl(sport->port.membase + UFCR) & UFCR_RFDIV) >> 7;\r\nif (ucfr_rfdiv == 6)\r\nucfr_rfdiv = 7;\r\nelse\r\nucfr_rfdiv = 6 - ucfr_rfdiv;\r\nuartclk = clk_get_rate(sport->clk_per);\r\nuartclk /= ucfr_rfdiv;\r\n{\r\nunsigned int mul = ubir + 1;\r\nunsigned int div = 16 * (ubmr + 1);\r\nunsigned int rem = uartclk % div;\r\nbaud_raw = (uartclk / div) * mul;\r\nbaud_raw += (rem * mul + div / 2) / div;\r\n*baud = (baud_raw + 50) / 100 * 100;\r\n}\r\nif(*baud != baud_raw)\r\nprintk(KERN_INFO "Serial: Console IMX rounded baud rate from %d to %d\n",\r\nbaud_raw, *baud);\r\n}\r\n}\r\nstatic int __init\r\nimx_console_setup(struct console *co, char *options)\r\n{\r\nstruct imx_port *sport;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(imx_ports))\r\nco->index = 0;\r\nsport = imx_ports[co->index];\r\nif(sport == NULL)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nimx_console_get_options(sport, &baud, &parity, &bits);\r\nimx_setup_ufcr(sport, 0);\r\nreturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int serial_imx_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct imx_port *sport = platform_get_drvdata(dev);\r\nunsigned int val;\r\nval = readl(sport->port.membase + UCR3);\r\nval |= UCR3_AWAKEN;\r\nwritel(val, sport->port.membase + UCR3);\r\nuart_suspend_port(&imx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_imx_resume(struct platform_device *dev)\r\n{\r\nstruct imx_port *sport = platform_get_drvdata(dev);\r\nunsigned int val;\r\nval = readl(sport->port.membase + UCR3);\r\nval &= ~UCR3_AWAKEN;\r\nwritel(val, sport->port.membase + UCR3);\r\nuart_resume_port(&imx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_imx_probe_dt(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_uart_dt_ids, &pdev->dev);\r\nint ret;\r\nif (!np)\r\nreturn 1;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.line = ret;\r\nif (of_get_property(np, "fsl,uart-has-rtscts", NULL))\r\nsport->have_rtscts = 1;\r\nif (of_get_property(np, "fsl,irda-mode", NULL))\r\nsport->use_irda = 1;\r\nsport->devdata = of_id->data;\r\nreturn 0;\r\n}\r\nstatic inline int serial_imx_probe_dt(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 1;\r\n}\r\nstatic void serial_imx_probe_pdata(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct imxuart_platform_data *pdata = pdev->dev.platform_data;\r\nsport->port.line = pdev->id;\r\nsport->devdata = (struct imx_uart_data *) pdev->id_entry->driver_data;\r\nif (!pdata)\r\nreturn;\r\nif (pdata->flags & IMXUART_HAVE_RTSCTS)\r\nsport->have_rtscts = 1;\r\nif (pdata->flags & IMXUART_IRDA)\r\nsport->use_irda = 1;\r\n}\r\nstatic int serial_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_port *sport;\r\nstruct imxuart_platform_data *pdata;\r\nvoid __iomem *base;\r\nint ret = 0;\r\nstruct resource *res;\r\nstruct pinctrl *pinctrl;\r\nsport = kzalloc(sizeof(*sport), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\nret = serial_imx_probe_dt(sport, pdev);\r\nif (ret > 0)\r\nserial_imx_probe_pdata(sport, pdev);\r\nelse if (ret < 0)\r\ngoto free;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto free;\r\n}\r\nbase = ioremap(res->start, PAGE_SIZE);\r\nif (!base) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nsport->port.dev = &pdev->dev;\r\nsport->port.mapbase = res->start;\r\nsport->port.membase = base;\r\nsport->port.type = PORT_IMX,\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.irq = platform_get_irq(pdev, 0);\r\nsport->rxirq = platform_get_irq(pdev, 0);\r\nsport->txirq = platform_get_irq(pdev, 1);\r\nsport->rtsirq = platform_get_irq(pdev, 2);\r\nsport->port.fifosize = 32;\r\nsport->port.ops = &imx_pops;\r\nsport->port.flags = UPF_BOOT_AUTOCONF;\r\ninit_timer(&sport->timer);\r\nsport->timer.function = imx_timeout;\r\nsport->timer.data = (unsigned long)sport;\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl)) {\r\nret = PTR_ERR(pinctrl);\r\ndev_err(&pdev->dev, "failed to get default pinctrl: %d\n", ret);\r\ngoto unmap;\r\n}\r\nsport->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(sport->clk_ipg)) {\r\nret = PTR_ERR(sport->clk_ipg);\r\ndev_err(&pdev->dev, "failed to get ipg clk: %d\n", ret);\r\ngoto unmap;\r\n}\r\nsport->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(sport->clk_per)) {\r\nret = PTR_ERR(sport->clk_per);\r\ndev_err(&pdev->dev, "failed to get per clk: %d\n", ret);\r\ngoto unmap;\r\n}\r\nclk_prepare_enable(sport->clk_per);\r\nclk_prepare_enable(sport->clk_ipg);\r\nsport->port.uartclk = clk_get_rate(sport->clk_per);\r\nimx_ports[sport->port.line] = sport;\r\npdata = pdev->dev.platform_data;\r\nif (pdata && pdata->init) {\r\nret = pdata->init(pdev);\r\nif (ret)\r\ngoto clkput;\r\n}\r\nret = uart_add_one_port(&imx_reg, &sport->port);\r\nif (ret)\r\ngoto deinit;\r\nplatform_set_drvdata(pdev, sport);\r\nreturn 0;\r\ndeinit:\r\nif (pdata && pdata->exit)\r\npdata->exit(pdev);\r\nclkput:\r\nclk_disable_unprepare(sport->clk_per);\r\nclk_disable_unprepare(sport->clk_ipg);\r\nunmap:\r\niounmap(sport->port.membase);\r\nfree:\r\nkfree(sport);\r\nreturn ret;\r\n}\r\nstatic int serial_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct imxuart_platform_data *pdata;\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\npdata = pdev->dev.platform_data;\r\nplatform_set_drvdata(pdev, NULL);\r\nuart_remove_one_port(&imx_reg, &sport->port);\r\nclk_disable_unprepare(sport->clk_per);\r\nclk_disable_unprepare(sport->clk_ipg);\r\nif (pdata && pdata->exit)\r\npdata->exit(pdev);\r\niounmap(sport->port.membase);\r\nkfree(sport);\r\nreturn 0;\r\n}\r\nstatic int __init imx_serial_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: IMX driver\n");\r\nret = uart_register_driver(&imx_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&serial_imx_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&imx_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit imx_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_imx_driver);\r\nuart_unregister_driver(&imx_reg);\r\n}
