static int handle_lctlg(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint reg3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16) +\r\n((vcpu->arch.sie_block->ipb & 0xff00) << 4);\r\nu64 useraddr;\r\nint reg, rc;\r\nvcpu->stat.instruction_lctlg++;\r\nif ((vcpu->arch.sie_block->ipb & 0xff) != 0x2f)\r\nreturn -EOPNOTSUPP;\r\nuseraddr = disp2;\r\nif (base2)\r\nuseraddr += vcpu->run->s.regs.gprs[base2];\r\nif (useraddr & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nreg = reg1;\r\nVCPU_EVENT(vcpu, 5, "lctlg r1:%x, r3:%x,b2:%x,d2:%x", reg1, reg3, base2,\r\ndisp2);\r\ntrace_kvm_s390_handle_lctl(vcpu, 1, reg1, reg3, useraddr);\r\ndo {\r\nrc = get_guest_u64(vcpu, useraddr,\r\n&vcpu->arch.sie_block->gcr[reg]);\r\nif (rc == -EFAULT) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nbreak;\r\n}\r\nuseraddr += 8;\r\nif (reg == reg3)\r\nbreak;\r\nreg = (reg + 1) % 16;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int handle_lctl(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint reg3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nint base2 = vcpu->arch.sie_block->ipb >> 28;\r\nint disp2 = ((vcpu->arch.sie_block->ipb & 0x0fff0000) >> 16);\r\nu64 useraddr;\r\nu32 val = 0;\r\nint reg, rc;\r\nvcpu->stat.instruction_lctl++;\r\nuseraddr = disp2;\r\nif (base2)\r\nuseraddr += vcpu->run->s.regs.gprs[base2];\r\nif (useraddr & 3)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nVCPU_EVENT(vcpu, 5, "lctl r1:%x, r3:%x,b2:%x,d2:%x", reg1, reg3, base2,\r\ndisp2);\r\ntrace_kvm_s390_handle_lctl(vcpu, 0, reg1, reg3, useraddr);\r\nreg = reg1;\r\ndo {\r\nrc = get_guest_u32(vcpu, useraddr, &val);\r\nif (rc == -EFAULT) {\r\nkvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nbreak;\r\n}\r\nvcpu->arch.sie_block->gcr[reg] &= 0xffffffff00000000ul;\r\nvcpu->arch.sie_block->gcr[reg] |= val;\r\nuseraddr += 4;\r\nif (reg == reg3)\r\nbreak;\r\nreg = (reg + 1) % 16;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int handle_noop(struct kvm_vcpu *vcpu)\r\n{\r\nswitch (vcpu->arch.sie_block->icptcode) {\r\ncase 0x0:\r\nvcpu->stat.exit_null++;\r\nbreak;\r\ncase 0x10:\r\nvcpu->stat.exit_external_request++;\r\nbreak;\r\ncase 0x14:\r\nvcpu->stat.exit_external_interrupt++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_stop(struct kvm_vcpu *vcpu)\r\n{\r\nint rc = 0;\r\nvcpu->stat.exit_stop_request++;\r\nspin_lock_bh(&vcpu->arch.local_int.lock);\r\ntrace_kvm_s390_stop_request(vcpu->arch.local_int.action_bits);\r\nif (vcpu->arch.local_int.action_bits & ACTION_RELOADVCPU_ON_STOP) {\r\nvcpu->arch.local_int.action_bits &= ~ACTION_RELOADVCPU_ON_STOP;\r\nrc = SIE_INTERCEPT_RERUNVCPU;\r\nvcpu->run->exit_reason = KVM_EXIT_INTR;\r\n}\r\nif (vcpu->arch.local_int.action_bits & ACTION_STOP_ON_STOP) {\r\natomic_set_mask(CPUSTAT_STOPPED,\r\n&vcpu->arch.sie_block->cpuflags);\r\nvcpu->arch.local_int.action_bits &= ~ACTION_STOP_ON_STOP;\r\nVCPU_EVENT(vcpu, 3, "%s", "cpu stopped");\r\nrc = -EOPNOTSUPP;\r\n}\r\nif (vcpu->arch.local_int.action_bits & ACTION_STORE_ON_STOP) {\r\nvcpu->arch.local_int.action_bits &= ~ACTION_STORE_ON_STOP;\r\nspin_unlock_bh(&vcpu->arch.local_int.lock);\r\nrc = kvm_s390_vcpu_store_status(vcpu,\r\nKVM_S390_STORE_STATUS_NOADDR);\r\nif (rc >= 0)\r\nrc = -EOPNOTSUPP;\r\n} else\r\nspin_unlock_bh(&vcpu->arch.local_int.lock);\r\nreturn rc;\r\n}\r\nstatic int handle_validity(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long vmaddr;\r\nint viwhy = vcpu->arch.sie_block->ipb >> 16;\r\nint rc;\r\nvcpu->stat.exit_validity++;\r\ntrace_kvm_s390_intercept_validity(vcpu, viwhy);\r\nif (viwhy == 0x37) {\r\nvmaddr = gmap_fault(vcpu->arch.sie_block->prefix,\r\nvcpu->arch.gmap);\r\nif (IS_ERR_VALUE(vmaddr)) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrc = fault_in_pages_writeable((char __user *) vmaddr,\r\nPAGE_SIZE);\r\nif (rc) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nvmaddr = gmap_fault(vcpu->arch.sie_block->prefix + PAGE_SIZE,\r\nvcpu->arch.gmap);\r\nif (IS_ERR_VALUE(vmaddr)) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrc = fault_in_pages_writeable((char __user *) vmaddr,\r\nPAGE_SIZE);\r\nif (rc) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\n} else\r\nrc = -EOPNOTSUPP;\r\nout:\r\nif (rc)\r\nVCPU_EVENT(vcpu, 2, "unhandled validity intercept code %d",\r\nviwhy);\r\nreturn rc;\r\n}\r\nstatic int handle_instruction(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nvcpu->stat.exit_instruction++;\r\ntrace_kvm_s390_intercept_instruction(vcpu,\r\nvcpu->arch.sie_block->ipa,\r\nvcpu->arch.sie_block->ipb);\r\nhandler = instruction_handlers[vcpu->arch.sie_block->ipa >> 8];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_prog(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->stat.exit_program_interruption++;\r\ntrace_kvm_s390_intercept_prog(vcpu, vcpu->arch.sie_block->iprcc);\r\nreturn kvm_s390_inject_program_int(vcpu, vcpu->arch.sie_block->iprcc);\r\n}\r\nstatic int handle_instruction_and_prog(struct kvm_vcpu *vcpu)\r\n{\r\nint rc, rc2;\r\nvcpu->stat.exit_instr_and_program++;\r\nrc = handle_instruction(vcpu);\r\nrc2 = handle_prog(vcpu);\r\nif (rc == -EOPNOTSUPP)\r\nvcpu->arch.sie_block->icptcode = 0x04;\r\nif (rc)\r\nreturn rc;\r\nreturn rc2;\r\n}\r\nint kvm_handle_sie_intercept(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t func;\r\nu8 code = vcpu->arch.sie_block->icptcode;\r\nif (code & 3 || (code >> 2) >= ARRAY_SIZE(intercept_funcs))\r\nreturn -EOPNOTSUPP;\r\nfunc = intercept_funcs[code >> 2];\r\nif (func)\r\nreturn func(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}
