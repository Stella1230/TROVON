struct page *_raid_page_alloc(void)\r\n{\r\nreturn alloc_page(GFP_KERNEL);\r\n}\r\nvoid _raid_page_free(struct page *p)\r\n{\r\n__free_page(p);\r\n}\r\nstatic int _sp2d_alloc(unsigned pages_in_unit, unsigned group_width,\r\nunsigned parity, struct __stripe_pages_2d **psp2d)\r\n{\r\nstruct __stripe_pages_2d *sp2d;\r\nunsigned data_devs = group_width - parity;\r\nstruct _alloc_all_bytes {\r\nstruct __alloc_stripe_pages_2d {\r\nstruct __stripe_pages_2d sp2d;\r\nstruct __1_page_stripe _1p_stripes[pages_in_unit];\r\n} __asp2d;\r\nstruct __alloc_1p_arrays {\r\nstruct page *pages[group_width];\r\nstruct page *scribble[group_width];\r\nchar page_is_read[data_devs];\r\n} __a1pa[pages_in_unit];\r\n} *_aab;\r\nstruct __alloc_1p_arrays *__a1pa;\r\nstruct __alloc_1p_arrays *__a1pa_end;\r\nconst unsigned sizeof__a1pa = sizeof(_aab->__a1pa[0]);\r\nunsigned num_a1pa, alloc_size, i;\r\nBUG_ON(sizeof(_aab->__asp2d) > PAGE_SIZE);\r\nBUG_ON(sizeof__a1pa > PAGE_SIZE);\r\nif (sizeof(*_aab) > PAGE_SIZE) {\r\nnum_a1pa = (PAGE_SIZE - sizeof(_aab->__asp2d)) / sizeof__a1pa;\r\nalloc_size = sizeof(_aab->__asp2d) + sizeof__a1pa * num_a1pa;\r\n} else {\r\nnum_a1pa = pages_in_unit;\r\nalloc_size = sizeof(*_aab);\r\n}\r\n_aab = kzalloc(alloc_size, GFP_KERNEL);\r\nif (unlikely(!_aab)) {\r\nORE_DBGMSG("!! Failed to alloc sp2d size=%d\n", alloc_size);\r\nreturn -ENOMEM;\r\n}\r\nsp2d = &_aab->__asp2d.sp2d;\r\n*psp2d = sp2d;\r\n__a1pa = _aab->__a1pa;\r\n__a1pa_end = __a1pa + num_a1pa;\r\nfor (i = 0; i < pages_in_unit; ++i) {\r\nif (unlikely(__a1pa >= __a1pa_end)) {\r\nnum_a1pa = min_t(unsigned, PAGE_SIZE / sizeof__a1pa,\r\npages_in_unit - i);\r\n__a1pa = kzalloc(num_a1pa * sizeof__a1pa, GFP_KERNEL);\r\nif (unlikely(!__a1pa)) {\r\nORE_DBGMSG("!! Failed to _alloc_1p_arrays=%d\n",\r\nnum_a1pa);\r\nreturn -ENOMEM;\r\n}\r\n__a1pa_end = __a1pa + num_a1pa;\r\nsp2d->_1p_stripes[i].alloc = true;\r\n}\r\nsp2d->_1p_stripes[i].pages = __a1pa->pages;\r\nsp2d->_1p_stripes[i].scribble = __a1pa->scribble ;\r\nsp2d->_1p_stripes[i].page_is_read = __a1pa->page_is_read;\r\n++__a1pa;\r\n}\r\nsp2d->parity = parity;\r\nsp2d->data_devs = data_devs;\r\nsp2d->pages_in_unit = pages_in_unit;\r\nreturn 0;\r\n}\r\nstatic void _sp2d_reset(struct __stripe_pages_2d *sp2d,\r\nconst struct _ore_r4w_op *r4w, void *priv)\r\n{\r\nunsigned data_devs = sp2d->data_devs;\r\nunsigned group_width = data_devs + sp2d->parity;\r\nint p, c;\r\nif (!sp2d->needed)\r\nreturn;\r\nfor (c = data_devs - 1; c >= 0; --c)\r\nfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nif (_1ps->page_is_read[c]) {\r\nstruct page *page = _1ps->pages[c];\r\nr4w->put_page(priv, page);\r\n_1ps->page_is_read[c] = false;\r\n}\r\n}\r\nfor (p = 0; p < sp2d->pages_in_unit; p++) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nmemset(_1ps->pages, 0, group_width * sizeof(*_1ps->pages));\r\n_1ps->write_count = 0;\r\n_1ps->tx = NULL;\r\n}\r\nsp2d->needed = false;\r\n}\r\nstatic void _sp2d_free(struct __stripe_pages_2d *sp2d)\r\n{\r\nunsigned i;\r\nif (!sp2d)\r\nreturn;\r\nfor (i = 0; i < sp2d->pages_in_unit; ++i) {\r\nif (sp2d->_1p_stripes[i].alloc)\r\nkfree(sp2d->_1p_stripes[i].pages);\r\n}\r\nkfree(sp2d);\r\n}\r\nstatic unsigned _sp2d_min_pg(struct __stripe_pages_2d *sp2d)\r\n{\r\nunsigned p;\r\nfor (p = 0; p < sp2d->pages_in_unit; p++) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nif (_1ps->write_count)\r\nreturn p;\r\n}\r\nreturn ~0;\r\n}\r\nstatic unsigned _sp2d_max_pg(struct __stripe_pages_2d *sp2d)\r\n{\r\nint p;\r\nfor (p = sp2d->pages_in_unit - 1; p >= 0; --p) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nif (_1ps->write_count)\r\nreturn p;\r\n}\r\nreturn ~0;\r\n}\r\nstatic void _gen_xor_unit(struct __stripe_pages_2d *sp2d)\r\n{\r\nunsigned p;\r\nfor (p = 0; p < sp2d->pages_in_unit; p++) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nif (!_1ps->write_count)\r\ncontinue;\r\ninit_async_submit(&_1ps->submit,\r\nASYNC_TX_XOR_ZERO_DST | ASYNC_TX_ACK,\r\nNULL,\r\nNULL, NULL,\r\n(addr_conv_t *)_1ps->scribble);\r\n_1ps->tx = async_xor(_1ps->pages[sp2d->data_devs], _1ps->pages,\r\n0, sp2d->data_devs, PAGE_SIZE,\r\n&_1ps->submit);\r\n}\r\nfor (p = 0; p < sp2d->pages_in_unit; p++) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nasync_tx_issue_pending(_1ps->tx);\r\n}\r\n}\r\nvoid _ore_add_stripe_page(struct __stripe_pages_2d *sp2d,\r\nstruct ore_striping_info *si, struct page *page)\r\n{\r\nstruct __1_page_stripe *_1ps;\r\nsp2d->needed = true;\r\n_1ps = &sp2d->_1p_stripes[si->cur_pg];\r\n_1ps->pages[si->cur_comp] = page;\r\n++_1ps->write_count;\r\nsi->cur_pg = (si->cur_pg + 1) % sp2d->pages_in_unit;\r\n}\r\nvoid _ore_add_sg_seg(struct ore_per_dev_state *per_dev, unsigned cur_len,\r\nbool not_last)\r\n{\r\nstruct osd_sg_entry *sge;\r\nORE_DBGMSG("dev=%d cur_len=0x%x not_last=%d cur_sg=%d "\r\n"offset=0x%llx length=0x%x last_sgs_total=0x%x\n",\r\nper_dev->dev, cur_len, not_last, per_dev->cur_sg,\r\n_LLU(per_dev->offset), per_dev->length,\r\nper_dev->last_sgs_total);\r\nif (!per_dev->cur_sg) {\r\nsge = per_dev->sglist;\r\nif (per_dev->length) {\r\n++per_dev->cur_sg;\r\nsge->offset = per_dev->offset;\r\nsge->len = per_dev->length;\r\n} else {\r\nper_dev->offset += cur_len;\r\nreturn;\r\n}\r\n} else {\r\nsge = &per_dev->sglist[per_dev->cur_sg - 1];\r\nsge->len = per_dev->length - per_dev->last_sgs_total;\r\n}\r\nif (not_last) {\r\nstruct osd_sg_entry *next_sge = sge + 1;\r\n++per_dev->cur_sg;\r\nnext_sge->offset = sge->offset + sge->len + cur_len;\r\nper_dev->last_sgs_total = per_dev->length;\r\nnext_sge->len = 0;\r\n} else if (!sge->len) {\r\n--per_dev->cur_sg;\r\n}\r\n}\r\nstatic int _alloc_read_4_write(struct ore_io_state *ios)\r\n{\r\nstruct ore_layout *layout = ios->layout;\r\nint ret;\r\nunsigned sgs_per_dev = ios->sp2d->pages_in_unit + 2;\r\nret = _ore_get_io_state(layout, ios->oc,\r\nlayout->group_width * layout->mirrors_p1,\r\nsgs_per_dev, 0, &ios->ios_read_4_write);\r\nreturn ret;\r\n}\r\nstatic int _add_to_r4w(struct ore_io_state *ios, struct ore_striping_info *si,\r\nstruct page *page, unsigned pg_len)\r\n{\r\nstruct request_queue *q;\r\nstruct ore_per_dev_state *per_dev;\r\nstruct ore_io_state *read_ios;\r\nunsigned first_dev = si->dev - (si->dev %\r\n(ios->layout->group_width * ios->layout->mirrors_p1));\r\nunsigned comp = si->dev - first_dev;\r\nunsigned added_len;\r\nif (!ios->ios_read_4_write) {\r\nint ret = _alloc_read_4_write(ios);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\nread_ios = ios->ios_read_4_write;\r\nread_ios->numdevs = ios->layout->group_width * ios->layout->mirrors_p1;\r\nper_dev = &read_ios->per_dev[comp];\r\nif (!per_dev->length) {\r\nper_dev->bio = bio_kmalloc(GFP_KERNEL,\r\nios->sp2d->pages_in_unit);\r\nif (unlikely(!per_dev->bio)) {\r\nORE_DBGMSG("Failed to allocate BIO size=%u\n",\r\nios->sp2d->pages_in_unit);\r\nreturn -ENOMEM;\r\n}\r\nper_dev->offset = si->obj_offset;\r\nper_dev->dev = si->dev;\r\n} else if (si->obj_offset != (per_dev->offset + per_dev->length)) {\r\nu64 gap = si->obj_offset - (per_dev->offset + per_dev->length);\r\n_ore_add_sg_seg(per_dev, gap, true);\r\n}\r\nq = osd_request_queue(ore_comp_dev(read_ios->oc, per_dev->dev));\r\nadded_len = bio_add_pc_page(q, per_dev->bio, page, pg_len,\r\nsi->obj_offset % PAGE_SIZE);\r\nif (unlikely(added_len != pg_len)) {\r\nORE_DBGMSG("Failed to bio_add_pc_page bi_vcnt=%d\n",\r\nper_dev->bio->bi_vcnt);\r\nreturn -ENOMEM;\r\n}\r\nper_dev->length += pg_len;\r\nreturn 0;\r\n}\r\nstatic int _add_to_r4w_first_page(struct ore_io_state *ios, struct page *page)\r\n{\r\nstruct ore_striping_info si;\r\nunsigned pg_len;\r\nore_calc_stripe_info(ios->layout, ios->offset, 0, &si);\r\npg_len = si.obj_offset % PAGE_SIZE;\r\nsi.obj_offset -= pg_len;\r\nORE_DBGMSG("offset=0x%llx len=0x%x index=0x%lx dev=%x\n",\r\n_LLU(si.obj_offset), pg_len, page->index, si.dev);\r\nreturn _add_to_r4w(ios, &si, page, pg_len);\r\n}\r\nstatic int _add_to_r4w_last_page(struct ore_io_state *ios, u64 *offset)\r\n{\r\nstruct ore_striping_info si;\r\nstruct page *page;\r\nunsigned pg_len, p, c;\r\nore_calc_stripe_info(ios->layout, *offset, 0, &si);\r\np = si.unit_off / PAGE_SIZE;\r\nc = _dev_order(ios->layout->group_width * ios->layout->mirrors_p1,\r\nios->layout->mirrors_p1, si.par_dev, si.dev);\r\npage = ios->sp2d->_1p_stripes[p].pages[c];\r\npg_len = PAGE_SIZE - (si.unit_off % PAGE_SIZE);\r\n*offset += pg_len;\r\nORE_DBGMSG("p=%d, c=%d next-offset=0x%llx len=0x%x dev=%x par_dev=%d\n",\r\np, c, _LLU(*offset), pg_len, si.dev, si.par_dev);\r\nBUG_ON(!page);\r\nreturn _add_to_r4w(ios, &si, page, pg_len);\r\n}\r\nstatic void _mark_read4write_pages_uptodate(struct ore_io_state *ios, int ret)\r\n{\r\nstruct bio_vec *bv;\r\nunsigned i, d;\r\nfor (d = 0; d < ios->numdevs; d++) {\r\nstruct bio *bio = ios->per_dev[d].bio;\r\nif (!bio)\r\ncontinue;\r\n__bio_for_each_segment(bv, bio, i, 0) {\r\nstruct page *page = bv->bv_page;\r\nSetPageUptodate(page);\r\nif (PageError(page))\r\nClearPageError(page);\r\n}\r\n}\r\n}\r\nstatic int _read_4_write_first_stripe(struct ore_io_state *ios)\r\n{\r\nstruct ore_striping_info read_si;\r\nstruct __stripe_pages_2d *sp2d = ios->sp2d;\r\nu64 offset = ios->si.first_stripe_start;\r\nunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\r\nif (offset == ios->offset)\r\ngoto read_last_stripe;\r\nmin_p = _sp2d_min_pg(sp2d);\r\nmax_p = _sp2d_max_pg(sp2d);\r\nORE_DBGMSG("stripe_start=0x%llx ios->offset=0x%llx min_p=%d max_p=%d\n",\r\noffset, ios->offset, min_p, max_p);\r\nfor (c = 0; ; c++) {\r\nore_calc_stripe_info(ios->layout, offset, 0, &read_si);\r\nread_si.obj_offset += min_p * PAGE_SIZE;\r\noffset += min_p * PAGE_SIZE;\r\nfor (p = min_p; p <= max_p; p++) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nstruct page **pp = &_1ps->pages[c];\r\nbool uptodate;\r\nif (*pp) {\r\nif (ios->offset % PAGE_SIZE)\r\n_add_to_r4w_first_page(ios, *pp);\r\ngoto read_last_stripe;\r\n}\r\n*pp = ios->r4w->get_page(ios->private, offset,\r\n&uptodate);\r\nif (unlikely(!*pp))\r\nreturn -ENOMEM;\r\nif (!uptodate)\r\n_add_to_r4w(ios, &read_si, *pp, PAGE_SIZE);\r\n_1ps->page_is_read[c] = true;\r\nread_si.obj_offset += PAGE_SIZE;\r\noffset += PAGE_SIZE;\r\n}\r\noffset += (sp2d->pages_in_unit - p) * PAGE_SIZE;\r\n}\r\nread_last_stripe:\r\nreturn 0;\r\n}\r\nstatic int _read_4_write_last_stripe(struct ore_io_state *ios)\r\n{\r\nstruct ore_striping_info read_si;\r\nstruct __stripe_pages_2d *sp2d = ios->sp2d;\r\nu64 offset;\r\nu64 last_stripe_end;\r\nunsigned bytes_in_stripe = ios->si.bytes_in_stripe;\r\nunsigned c, p, min_p = sp2d->pages_in_unit, max_p = -1;\r\noffset = ios->offset + ios->length;\r\nif (offset % PAGE_SIZE)\r\n_add_to_r4w_last_page(ios, &offset);\r\nlast_stripe_end = div_u64(offset + bytes_in_stripe - 1, bytes_in_stripe)\r\n* bytes_in_stripe;\r\nif (offset == last_stripe_end)\r\ngoto read_it;\r\nore_calc_stripe_info(ios->layout, offset, 0, &read_si);\r\np = read_si.unit_off / PAGE_SIZE;\r\nc = _dev_order(ios->layout->group_width * ios->layout->mirrors_p1,\r\nios->layout->mirrors_p1, read_si.par_dev, read_si.dev);\r\nif (min_p == sp2d->pages_in_unit) {\r\nmin_p = _sp2d_min_pg(sp2d);\r\nmax_p = _sp2d_max_pg(sp2d);\r\n}\r\nORE_DBGMSG("offset=0x%llx stripe_end=0x%llx min_p=%d max_p=%d\n",\r\noffset, last_stripe_end, min_p, max_p);\r\nwhile (offset < last_stripe_end) {\r\nstruct __1_page_stripe *_1ps = &sp2d->_1p_stripes[p];\r\nif ((min_p <= p) && (p <= max_p)) {\r\nstruct page *page;\r\nbool uptodate;\r\nBUG_ON(_1ps->pages[c]);\r\npage = ios->r4w->get_page(ios->private, offset,\r\n&uptodate);\r\nif (unlikely(!page))\r\nreturn -ENOMEM;\r\n_1ps->pages[c] = page;\r\n_1ps->page_is_read[c] = true;\r\nif (!uptodate)\r\n_add_to_r4w(ios, &read_si, page, PAGE_SIZE);\r\n}\r\noffset += PAGE_SIZE;\r\nif (p == (sp2d->pages_in_unit - 1)) {\r\n++c;\r\np = 0;\r\nore_calc_stripe_info(ios->layout, offset, 0, &read_si);\r\n} else {\r\nread_si.obj_offset += PAGE_SIZE;\r\n++p;\r\n}\r\n}\r\nread_it:\r\nreturn 0;\r\n}\r\nstatic int _read_4_write_execute(struct ore_io_state *ios)\r\n{\r\nstruct ore_io_state *ios_read;\r\nunsigned i;\r\nint ret;\r\nios_read = ios->ios_read_4_write;\r\nif (!ios_read)\r\nreturn 0;\r\nios_read->pages = ios->pages;\r\nfor (i = 0; i < ios_read->numdevs; i += ios_read->layout->mirrors_p1) {\r\nret = _ore_read_mirror(ios_read, i);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\nret = ore_io_execute(ios_read);\r\nif (unlikely(ret)) {\r\nORE_DBGMSG("!! ore_io_execute => %d\n", ret);\r\nreturn ret;\r\n}\r\n_mark_read4write_pages_uptodate(ios_read, ret);\r\nore_put_io_state(ios_read);\r\nios->ios_read_4_write = NULL;\r\nreturn 0;\r\n}\r\nint _ore_add_parity_unit(struct ore_io_state *ios,\r\nstruct ore_striping_info *si,\r\nstruct ore_per_dev_state *per_dev,\r\nunsigned cur_len)\r\n{\r\nif (ios->reading) {\r\nif (per_dev->cur_sg >= ios->sgs_per_dev) {\r\nORE_DBGMSG("cur_sg(%d) >= sgs_per_dev(%d)\n" ,\r\nper_dev->cur_sg, ios->sgs_per_dev);\r\nreturn -ENOMEM;\r\n}\r\n_ore_add_sg_seg(per_dev, cur_len, true);\r\n} else {\r\nstruct __stripe_pages_2d *sp2d = ios->sp2d;\r\nstruct page **pages = ios->parity_pages + ios->cur_par_page;\r\nunsigned num_pages;\r\nunsigned array_start = 0;\r\nunsigned i;\r\nint ret;\r\nsi->cur_pg = _sp2d_min_pg(sp2d);\r\nnum_pages = _sp2d_max_pg(sp2d) + 1 - si->cur_pg;\r\nif (!cur_len)\r\nsi->cur_comp = sp2d->data_devs;\r\nif (!per_dev->length) {\r\nper_dev->offset += si->cur_pg * PAGE_SIZE;\r\n_read_4_write_first_stripe(ios);\r\n}\r\nif (!cur_len)\r\n_read_4_write_last_stripe(ios);\r\n_read_4_write_execute(ios);\r\nfor (i = 0; i < num_pages; i++) {\r\npages[i] = _raid_page_alloc();\r\nif (unlikely(!pages[i]))\r\nreturn -ENOMEM;\r\n++(ios->cur_par_page);\r\n}\r\nBUG_ON(si->cur_comp != sp2d->data_devs);\r\nBUG_ON(si->cur_pg + num_pages > sp2d->pages_in_unit);\r\nret = _ore_add_stripe_unit(ios, &array_start, 0, pages,\r\nper_dev, num_pages * PAGE_SIZE);\r\nif (unlikely(ret))\r\nreturn ret;\r\n_gen_xor_unit(sp2d);\r\n_sp2d_reset(sp2d, ios->r4w, ios->private);\r\n}\r\nreturn 0;\r\n}\r\nint _ore_post_alloc_raid_stuff(struct ore_io_state *ios)\r\n{\r\nif (ios->parity_pages) {\r\nstruct ore_layout *layout = ios->layout;\r\nunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\r\nif (_sp2d_alloc(pages_in_unit, layout->group_width,\r\nlayout->parity, &ios->sp2d)) {\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid _ore_free_raid_stuff(struct ore_io_state *ios)\r\n{\r\nif (ios->sp2d) {\r\nunsigned i;\r\nfor (i = 0; i < ios->cur_par_page; i++) {\r\nstruct page *page = ios->parity_pages[i];\r\nif (page)\r\n_raid_page_free(page);\r\n}\r\nif (ios->extra_part_alloc)\r\nkfree(ios->parity_pages);\r\n_sp2d_reset(ios->sp2d, ios->r4w, ios->private);\r\n_sp2d_free(ios->sp2d);\r\n} else {\r\nif (ios->extra_part_alloc)\r\nkfree(ios->per_dev[0].sglist);\r\n}\r\nif (ios->ios_read_4_write)\r\nore_put_io_state(ios->ios_read_4_write);\r\n}
