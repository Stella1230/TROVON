int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)\r\n{\r\nint err;\r\nif (!access_ok (VERIFY_WRITE, to, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nerr = __put_user(from->si_signo, &to->si_signo);\r\nerr |= __put_user(from->si_errno, &to->si_errno);\r\nerr |= __put_user((short)from->si_code, &to->si_code);\r\nif (from->si_code < 0)\r\nerr |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);\r\nelse {\r\nswitch (from->si_code >> 16) {\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nerr |= __put_user(from->si_int, &to->si_int);\r\ncase __SI_KILL >> 16:\r\nerr |= __put_user(from->si_pid, &to->si_pid);\r\nerr |= __put_user(from->si_uid, &to->si_uid);\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nerr |= __put_user(from->si_pid, &to->si_pid);\r\nerr |= __put_user(from->si_uid, &to->si_uid);\r\nerr |= __put_user(from->si_utime, &to->si_utime);\r\nerr |= __put_user(from->si_stime, &to->si_stime);\r\nerr |= __put_user(from->si_status, &to->si_status);\r\nbreak;\r\ncase __SI_FAULT >> 16:\r\nerr |= __put_user((unsigned long) from->si_addr,\r\n&to->si_addr);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nerr |= __put_user(from->si_band, &to->si_band);\r\nerr |= __put_user(from->si_fd, &to->si_fd);\r\nbreak;\r\ncase __SI_TIMER >> 16:\r\nerr |= __put_user(from->si_tid, &to->si_tid);\r\nerr |= __put_user(from->si_overrun, &to->si_overrun);\r\nerr |= __put_user(from->si_int, &to->si_int);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)\r\n{\r\nint err;\r\nu32 tmp;\r\nif (!access_ok (VERIFY_READ, from, sizeof(compat_siginfo_t)))\r\nreturn -EFAULT;\r\nerr = __get_user(to->si_signo, &from->si_signo);\r\nerr |= __get_user(to->si_errno, &from->si_errno);\r\nerr |= __get_user(to->si_code, &from->si_code);\r\nif (to->si_code < 0)\r\nerr |= __copy_from_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);\r\nelse {\r\nswitch (to->si_code >> 16) {\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nerr |= __get_user(to->si_int, &from->si_int);\r\ncase __SI_KILL >> 16:\r\nerr |= __get_user(to->si_pid, &from->si_pid);\r\nerr |= __get_user(to->si_uid, &from->si_uid);\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nerr |= __get_user(to->si_pid, &from->si_pid);\r\nerr |= __get_user(to->si_uid, &from->si_uid);\r\nerr |= __get_user(to->si_utime, &from->si_utime);\r\nerr |= __get_user(to->si_stime, &from->si_stime);\r\nerr |= __get_user(to->si_status, &from->si_status);\r\nbreak;\r\ncase __SI_FAULT >> 16:\r\nerr |= __get_user(tmp, &from->si_addr);\r\nto->si_addr = (void __force __user *)\r\n(u64) (tmp & PSW32_ADDR_INSN);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nerr |= __get_user(to->si_band, &from->si_band);\r\nerr |= __get_user(to->si_fd, &from->si_fd);\r\nbreak;\r\ncase __SI_TIMER >> 16:\r\nerr |= __get_user(to->si_tid, &from->si_tid);\r\nerr |= __get_user(to->si_overrun, &from->si_overrun);\r\nerr |= __get_user(to->si_int, &from->si_int);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nasmlinkage long\r\nsys32_sigaction(int sig, const struct old_sigaction32 __user *act,\r\nstruct old_sigaction32 __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nunsigned long sa_handler, sa_restorer;\r\nint ret;\r\nif (act) {\r\ncompat_old_sigset_t mask;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(sa_handler, &act->sa_handler) ||\r\n__get_user(sa_restorer, &act->sa_restorer) ||\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\r\n__get_user(mask, &act->sa_mask))\r\nreturn -EFAULT;\r\nnew_ka.sa.sa_handler = (__sighandler_t) sa_handler;\r\nnew_ka.sa.sa_restorer = (void (*)(void)) sa_restorer;\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nsa_handler = (unsigned long) old_ka.sa.sa_handler;\r\nsa_restorer = (unsigned long) old_ka.sa.sa_restorer;\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(sa_handler, &oact->sa_handler) ||\r\n__put_user(sa_restorer, &oact->sa_restorer) ||\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\r\n__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long\r\nsys32_rt_sigaction(int sig, const struct sigaction32 __user *act,\r\nstruct sigaction32 __user *oact, size_t sigsetsize)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nunsigned long sa_handler;\r\nint ret;\r\ncompat_sigset_t set32;\r\nif (sigsetsize != sizeof(compat_sigset_t))\r\nreturn -EINVAL;\r\nif (act) {\r\nret = get_user(sa_handler, &act->sa_handler);\r\nret |= __copy_from_user(&set32, &act->sa_mask,\r\nsizeof(compat_sigset_t));\r\nnew_ka.sa.sa_mask.sig[0] =\r\nset32.sig[0] | (((long)set32.sig[1]) << 32);\r\nret |= __get_user(new_ka.sa.sa_flags, &act->sa_flags);\r\nif (ret)\r\nreturn -EFAULT;\r\nnew_ka.sa.sa_handler = (__sighandler_t) sa_handler;\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nset32.sig[1] = (old_ka.sa.sa_mask.sig[0] >> 32);\r\nset32.sig[0] = old_ka.sa.sa_mask.sig[0];\r\nret = put_user((unsigned long)old_ka.sa.sa_handler, &oact->sa_handler);\r\nret |= __copy_to_user(&oact->sa_mask, &set32,\r\nsizeof(compat_sigset_t));\r\nret |= __put_user(old_ka.sa.sa_flags, &oact->sa_flags);\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long\r\nsys32_sigaltstack(const stack_t32 __user *uss, stack_t32 __user *uoss)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nstack_t kss, koss;\r\nunsigned long ss_sp;\r\nint ret, err = 0;\r\nmm_segment_t old_fs = get_fs();\r\nif (uss) {\r\nif (!access_ok(VERIFY_READ, uss, sizeof(*uss)))\r\nreturn -EFAULT;\r\nerr |= __get_user(ss_sp, &uss->ss_sp);\r\nerr |= __get_user(kss.ss_size, &uss->ss_size);\r\nerr |= __get_user(kss.ss_flags, &uss->ss_flags);\r\nif (err)\r\nreturn -EFAULT;\r\nkss.ss_sp = (void __user *) ss_sp;\r\n}\r\nset_fs (KERNEL_DS);\r\nret = do_sigaltstack((stack_t __force __user *) (uss ? &kss : NULL),\r\n(stack_t __force __user *) (uoss ? &koss : NULL),\r\nregs->gprs[15]);\r\nset_fs (old_fs);\r\nif (!ret && uoss) {\r\nif (!access_ok(VERIFY_WRITE, uoss, sizeof(*uoss)))\r\nreturn -EFAULT;\r\nss_sp = (unsigned long) koss.ss_sp;\r\nerr |= __put_user(ss_sp, &uoss->ss_sp);\r\nerr |= __put_user(koss.ss_size, &uoss->ss_size);\r\nerr |= __put_user(koss.ss_flags, &uoss->ss_flags);\r\nif (err)\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int save_sigregs32(struct pt_regs *regs, _sigregs32 __user *sregs)\r\n{\r\n_s390_regs_common32 regs32;\r\nint err, i;\r\nregs32.psw.mask = psw32_user_bits |\r\n((__u32)(regs->psw.mask >> 32) & PSW32_MASK_USER);\r\nregs32.psw.addr = (__u32) regs->psw.addr |\r\n(__u32)(regs->psw.mask & PSW_MASK_BA);\r\nfor (i = 0; i < NUM_GPRS; i++)\r\nregs32.gprs[i] = (__u32) regs->gprs[i];\r\nsave_access_regs(current->thread.acrs);\r\nmemcpy(regs32.acrs, current->thread.acrs, sizeof(regs32.acrs));\r\nerr = __copy_to_user(&sregs->regs, &regs32, sizeof(regs32));\r\nif (err)\r\nreturn err;\r\nsave_fp_regs(&current->thread.fp_regs);\r\nreturn __copy_to_user(&sregs->fpregs, &current->thread.fp_regs,\r\nsizeof(_s390_fp_regs32));\r\n}\r\nstatic int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)\r\n{\r\n_s390_regs_common32 regs32;\r\nint err, i;\r\ncurrent_thread_info()->restart_block.fn = do_no_restart_syscall;\r\nerr = __copy_from_user(&regs32, &sregs->regs, sizeof(regs32));\r\nif (err)\r\nreturn err;\r\nregs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |\r\n(__u64)(regs32.psw.mask & PSW32_MASK_USER) << 32 |\r\n(__u64)(regs32.psw.addr & PSW32_ADDR_AMODE);\r\nif ((regs->psw.mask & PSW_MASK_ASC) >= (psw_kernel_bits & PSW_MASK_ASC))\r\nregs->psw.mask = (psw_user_bits & PSW_MASK_ASC) |\r\n(regs->psw.mask & ~PSW_MASK_ASC);\r\nregs->psw.addr = (__u64)(regs32.psw.addr & PSW32_ADDR_INSN);\r\nfor (i = 0; i < NUM_GPRS; i++)\r\nregs->gprs[i] = (__u64) regs32.gprs[i];\r\nmemcpy(current->thread.acrs, regs32.acrs, sizeof(current->thread.acrs));\r\nrestore_access_regs(current->thread.acrs);\r\nerr = __copy_from_user(&current->thread.fp_regs, &sregs->fpregs,\r\nsizeof(_s390_fp_regs32));\r\ncurrent->thread.fp_regs.fpc &= FPC_VALID_MASK;\r\nif (err)\r\nreturn err;\r\nrestore_fp_regs(&current->thread.fp_regs);\r\nclear_thread_flag(TIF_SYSCALL);\r\nreturn 0;\r\n}\r\nstatic int save_sigregs_gprs_high(struct pt_regs *regs, __u32 __user *uregs)\r\n{\r\n__u32 gprs_high[NUM_GPRS];\r\nint i;\r\nfor (i = 0; i < NUM_GPRS; i++)\r\ngprs_high[i] = regs->gprs[i] >> 32;\r\nreturn __copy_to_user(uregs, &gprs_high, sizeof(gprs_high));\r\n}\r\nstatic int restore_sigregs_gprs_high(struct pt_regs *regs, __u32 __user *uregs)\r\n{\r\n__u32 gprs_high[NUM_GPRS];\r\nint err, i;\r\nerr = __copy_from_user(&gprs_high, uregs, sizeof(gprs_high));\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < NUM_GPRS; i++)\r\n*(__u32 *)&regs->gprs[i] = gprs_high[i];\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nsigframe32 __user *frame = (sigframe32 __user *)regs->gprs[15];\r\nsigset_t set;\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set.sig, &frame->sc.oldmask, _SIGMASK_COPY_SIZE32))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (restore_sigregs32(regs, &frame->sregs))\r\ngoto badframe;\r\nif (restore_sigregs_gprs_high(regs, frame->gprs_high))\r\ngoto badframe;\r\nreturn regs->gprs[2];\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_rt_sigreturn(void)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nrt_sigframe32 __user *frame = (rt_sigframe32 __user *)regs->gprs[15];\r\nsigset_t set;\r\nstack_t st;\r\n__u32 ss_sp;\r\nint err;\r\nmm_segment_t old_fs = get_fs();\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nif (restore_sigregs32(regs, &frame->uc.uc_mcontext))\r\ngoto badframe;\r\nif (restore_sigregs_gprs_high(regs, frame->gprs_high))\r\ngoto badframe;\r\nerr = __get_user(ss_sp, &frame->uc.uc_stack.ss_sp);\r\nst.ss_sp = compat_ptr(ss_sp);\r\nerr |= __get_user(st.ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= __get_user(st.ss_flags, &frame->uc.uc_stack.ss_flags);\r\nif (err)\r\ngoto badframe;\r\nset_fs (KERNEL_DS);\r\ndo_sigaltstack((stack_t __force __user *)&st, NULL, regs->gprs[15]);\r\nset_fs (old_fs);\r\nreturn regs->gprs[2];\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\nreturn 0;\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, struct pt_regs * regs, size_t frame_size)\r\n{\r\nunsigned long sp;\r\nsp = (unsigned long) A(regs->gprs[15]);\r\nif (on_sig_stack(sp) && !on_sig_stack((sp - frame_size) & -8UL))\r\nreturn (void __user *) -1UL;\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (! sas_ss_flags(sp))\r\nsp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nreturn (void __user *)((sp - frame_size) & -8ul);\r\n}\r\nstatic inline int map_signal(int sig)\r\n{\r\nif (current_thread_info()->exec_domain\r\n&& current_thread_info()->exec_domain->signal_invmap\r\n&& sig < 32)\r\nreturn current_thread_info()->exec_domain->signal_invmap[sig];\r\nelse\r\nreturn sig;\r\n}\r\nstatic int setup_frame32(int sig, struct k_sigaction *ka,\r\nsigset_t *set, struct pt_regs * regs)\r\n{\r\nsigframe32 __user *frame = get_sigframe(ka, regs, sizeof(sigframe32));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(sigframe32)))\r\ngoto give_sigsegv;\r\nif (frame == (void __user *) -1UL)\r\ngoto give_sigsegv;\r\nif (__copy_to_user(&frame->sc.oldmask, &set->sig, _SIGMASK_COPY_SIZE32))\r\ngoto give_sigsegv;\r\nif (save_sigregs32(regs, &frame->sregs))\r\ngoto give_sigsegv;\r\nif (save_sigregs_gprs_high(regs, frame->gprs_high))\r\ngoto give_sigsegv;\r\nif (__put_user((unsigned long) &frame->sregs, &frame->sc.sregs))\r\ngoto give_sigsegv;\r\nif (ka->sa.sa_flags & SA_RESTORER) {\r\nregs->gprs[14] = (__u64) ka->sa.sa_restorer | PSW32_ADDR_AMODE;\r\n} else {\r\nregs->gprs[14] = (__u64) frame->retcode | PSW32_ADDR_AMODE;\r\nif (__put_user(S390_SYSCALL_OPCODE | __NR_sigreturn,\r\n(u16 __force __user *)(frame->retcode)))\r\ngoto give_sigsegv;\r\n}\r\nif (__put_user(regs->gprs[15], (unsigned int __user *) frame))\r\ngoto give_sigsegv;\r\nregs->gprs[15] = (__force __u64) frame;\r\nregs->psw.mask = PSW_MASK_BA |\r\n(psw_user_bits & PSW_MASK_ASC) |\r\n(regs->psw.mask & ~PSW_MASK_ASC);\r\nregs->psw.addr = (__force __u64) ka->sa.sa_handler;\r\nregs->gprs[2] = map_signal(sig);\r\nregs->gprs[3] = (__force __u64) &frame->sc;\r\nif (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\r\nsig == SIGTRAP || sig == SIGFPE) {\r\nregs->gprs[4] = regs->int_code & 127;\r\nregs->gprs[5] = regs->int_parm_long;\r\n}\r\nif (__put_user(regs->gprs[2], (int __force __user *) &frame->signo))\r\ngoto give_sigsegv;\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn -EFAULT;\r\n}\r\nstatic int setup_rt_frame32(int sig, struct k_sigaction *ka, siginfo_t *info,\r\nsigset_t *set, struct pt_regs * regs)\r\n{\r\nint err = 0;\r\nrt_sigframe32 __user *frame = get_sigframe(ka, regs, sizeof(rt_sigframe32));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof(rt_sigframe32)))\r\ngoto give_sigsegv;\r\nif (frame == (void __user *) -1UL)\r\ngoto give_sigsegv;\r\nif (copy_siginfo_to_user32(&frame->info, info))\r\ngoto give_sigsegv;\r\nerr |= __put_user(UC_EXTENDED, &frame->uc.uc_flags);\r\nerr |= __put_user(0, &frame->uc.uc_link);\r\nerr |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);\r\nerr |= __put_user(sas_ss_flags(regs->gprs[15]),\r\n&frame->uc.uc_stack.ss_flags);\r\nerr |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);\r\nerr |= save_sigregs32(regs, &frame->uc.uc_mcontext);\r\nerr |= save_sigregs_gprs_high(regs, frame->gprs_high);\r\nerr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\r\nif (err)\r\ngoto give_sigsegv;\r\nif (ka->sa.sa_flags & SA_RESTORER) {\r\nregs->gprs[14] = (__u64) ka->sa.sa_restorer | PSW32_ADDR_AMODE;\r\n} else {\r\nregs->gprs[14] = (__u64) frame->retcode | PSW32_ADDR_AMODE;\r\nerr |= __put_user(S390_SYSCALL_OPCODE | __NR_rt_sigreturn,\r\n(u16 __force __user *)(frame->retcode));\r\n}\r\nif (__put_user(regs->gprs[15], (unsigned int __force __user *) frame))\r\ngoto give_sigsegv;\r\nregs->gprs[15] = (__force __u64) frame;\r\nregs->psw.mask = PSW_MASK_BA |\r\n(psw_user_bits & PSW_MASK_ASC) |\r\n(regs->psw.mask & ~PSW_MASK_ASC);\r\nregs->psw.addr = (__u64) ka->sa.sa_handler;\r\nregs->gprs[2] = map_signal(sig);\r\nregs->gprs[3] = (__force __u64) &frame->info;\r\nregs->gprs[4] = (__force __u64) &frame->uc;\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(sig, current);\r\nreturn -EFAULT;\r\n}\r\nvoid handle_signal32(unsigned long sig, struct k_sigaction *ka,\r\nsiginfo_t *info, sigset_t *oldset, struct pt_regs *regs)\r\n{\r\nint ret;\r\nif (ka->sa.sa_flags & SA_SIGINFO)\r\nret = setup_rt_frame32(sig, ka, info, oldset, regs);\r\nelse\r\nret = setup_frame32(sig, ka, oldset, regs);\r\nif (ret)\r\nreturn;\r\nsignal_delivered(sig, info, ka, regs,\r\ntest_thread_flag(TIF_SINGLE_STEP));\r\n}
