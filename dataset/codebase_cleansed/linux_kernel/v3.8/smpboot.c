void __init smp_prepare_boot_cpu(void)\r\n{\r\nint cpu = smp_processor_id();\r\nset_cpu_online(cpu, 1);\r\nset_cpu_present(cpu, 1);\r\n__get_cpu_var(cpu_state) = CPU_ONLINE;\r\ninit_messaging();\r\n}\r\nvoid __init smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nlong rc;\r\nint cpu, cpu_count;\r\nint boot_cpu = smp_processor_id();\r\ncurrent_thread_info()->cpu = boot_cpu;\r\nrc = sched_setaffinity(current->pid, cpumask_of(boot_cpu));\r\nif (rc != 0)\r\npr_err("Couldn't set init affinity to boot cpu (%ld)\n", rc);\r\nprint_disabled_cpus();\r\nstart_cpu_function_addr = (unsigned long) &online_secondary;\r\ncpu_count = 1;\r\nfor (cpu = 0; cpu < NR_CPUS; ++cpu) {\r\nstruct task_struct *idle;\r\nif (cpu == boot_cpu)\r\ncontinue;\r\nif (!cpu_possible(cpu)) {\r\nper_cpu(boot_sp, cpu) = 0;\r\nper_cpu(boot_pc, cpu) = (unsigned long) smp_nap;\r\ncontinue;\r\n}\r\nidle = fork_idle(cpu);\r\nif (IS_ERR(idle))\r\npanic("failed fork for CPU %d", cpu);\r\nidle->thread.pc = (unsigned long) start_secondary;\r\nper_cpu(boot_sp, cpu) = task_ksp0(idle);\r\nper_cpu(boot_pc, cpu) = idle->thread.pc;\r\n++cpu_count;\r\n}\r\nBUG_ON(cpu_count > (max_cpus ? max_cpus : 1));\r\ninit_cpu_present(cpu_possible_mask);\r\nif (cpumask_weight(cpu_present_mask) > 1) {\r\nmb();\r\nhv_start_all_tiles();\r\n}\r\n}\r\nstatic __init int reset_init_affinity(void)\r\n{\r\nlong rc = sched_setaffinity(current->pid, &init_affinity);\r\nif (rc != 0)\r\npr_warning("couldn't reset init affinity (%ld)\n",\r\nrc);\r\nreturn 0;\r\n}\r\nstatic void __cpuinit start_secondary(void)\r\n{\r\nint cpuid = smp_processor_id();\r\nset_my_cpu_offset(__per_cpu_offset[cpuid]);\r\npreempt_disable();\r\n__get_cpu_var(current_asid) = min_asid;\r\natomic_inc(&init_mm.mm_count);\r\ncurrent->active_mm = &init_mm;\r\nif (current->mm)\r\nBUG();\r\nenter_lazy_tlb(&init_mm, current);\r\ninit_messaging();\r\nlocal_irq_enable();\r\nif (cpumask_test_and_set_cpu(cpuid, &cpu_started)) {\r\npr_warning("CPU#%d already started!\n", cpuid);\r\nfor (;;)\r\nlocal_irq_enable();\r\n}\r\nsmp_nap();\r\n}\r\nvoid __cpuinit online_secondary(void)\r\n{\r\nlocal_flush_tlb();\r\nBUG_ON(in_interrupt());\r\nwmb();\r\nnotify_cpu_starting(smp_processor_id());\r\nset_cpu_online(smp_processor_id(), 1);\r\n__get_cpu_var(cpu_state) = CPU_ONLINE;\r\nsetup_cpu(0);\r\nsetup_tile_timer();\r\npreempt_enable();\r\ncpu_idle();\r\n}\r\nint __cpuinit __cpu_up(unsigned int cpu, struct task_struct *tidle)\r\n{\r\nstatic int timeout;\r\nfor (; !cpumask_test_cpu(cpu, &cpu_started); timeout++) {\r\nif (timeout >= 50000) {\r\npr_info("skipping unresponsive cpu%d\n", cpu);\r\nlocal_irq_enable();\r\nreturn -EIO;\r\n}\r\nudelay(100);\r\n}\r\nlocal_irq_enable();\r\nper_cpu(cpu_state, cpu) = CPU_UP_PREPARE;\r\nsend_IPI_single(cpu, MSG_TAG_START_CPU);\r\nwhile (!cpumask_test_cpu(cpu, cpu_online_mask))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void panic_start_cpu(void)\r\n{\r\npanic("Received a MSG_START_CPU IPI after boot finished.");\r\n}\r\nvoid __init smp_cpus_done(unsigned int max_cpus)\r\n{\r\nint cpu, next, rc;\r\nstart_cpu_function_addr = (unsigned long) &panic_start_cpu;\r\ncpumask_copy(&init_affinity, cpu_online_mask);\r\nfor (cpu = cpumask_first(&init_affinity);\r\n(next = cpumask_next(cpu, &init_affinity)) < nr_cpu_ids;\r\ncpu = next)\r\n;\r\nrc = sched_setaffinity(current->pid, cpumask_of(cpu));\r\nif (rc != 0)\r\npr_err("Couldn't set init affinity to cpu %d (%d)\n", cpu, rc);\r\n}
