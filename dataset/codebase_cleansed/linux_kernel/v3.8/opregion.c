static u32 asle_set_backlight(struct drm_device *dev, u32 bclp)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle *asle = dev_priv->opregion.asle;\r\nstruct backlight_device *bd = dev_priv->backlight_device;\r\nDRM_DEBUG_DRIVER("asle set backlight %x\n", bclp);\r\nif (!(bclp & ASLE_BCLP_VALID))\r\nreturn ASLE_BACKLIGHT_FAILED;\r\nif (bd == NULL)\r\nreturn ASLE_BACKLIGHT_FAILED;\r\nbclp &= ASLE_BCLP_MSK;\r\nif (bclp > 255)\r\nreturn ASLE_BACKLIGHT_FAILED;\r\nif (config_enabled(CONFIG_BACKLIGHT_CLASS_DEVICE)) {\r\nint max = bd->props.max_brightness;\r\ngma_backlight_set(dev, bclp * max / 255);\r\n}\r\nasle->cblv = (bclp * 0x64) / 0xff | ASLE_CBLV_VALID;\r\nreturn 0;\r\n}\r\nvoid psb_intel_opregion_asle_intr(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle *asle = dev_priv->opregion.asle;\r\nu32 asle_stat = 0;\r\nu32 asle_req;\r\nif (!asle)\r\nreturn;\r\nasle_req = asle->aslc & ASLE_REQ_MSK;\r\nif (!asle_req) {\r\nDRM_DEBUG_DRIVER("non asle set request??\n");\r\nreturn;\r\n}\r\nif (asle_req & ASLE_SET_BACKLIGHT)\r\nasle_stat |= asle_set_backlight(dev, asle->bclp);\r\nasle->aslc = asle_stat;\r\n}\r\nvoid psb_intel_opregion_enable_asle(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct opregion_asle *asle = dev_priv->opregion.asle;\r\nif (asle && system_opregion ) {\r\npsb_enable_pipestat(dev_priv, 0, PIPE_LEGACY_BLC_EVENT_ENABLE);\r\npsb_enable_pipestat(dev_priv, 1, PIPE_LEGACY_BLC_EVENT_ENABLE);\r\nasle->tche = ASLE_ALS_EN | ASLE_BLC_EN | ASLE_PFIT_EN\r\n| ASLE_PFMB_EN;\r\nasle->ardy = 1;\r\n}\r\n}\r\nstatic int psb_intel_opregion_video_event(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct opregion_acpi *acpi;\r\nif (!system_opregion)\r\nreturn NOTIFY_DONE;\r\nacpi = system_opregion->acpi;\r\nacpi->csts = 0;\r\nreturn NOTIFY_OK;\r\n}\r\nvoid psb_intel_opregion_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->acpi) {\r\nopregion->acpi->csts = 0;\r\nopregion->acpi->drdy = 1;\r\nsystem_opregion = opregion;\r\nregister_acpi_notifier(&psb_intel_opregion_notifier);\r\n}\r\n}\r\nvoid psb_intel_opregion_fini(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->acpi) {\r\nopregion->acpi->drdy = 0;\r\nsystem_opregion = NULL;\r\nunregister_acpi_notifier(&psb_intel_opregion_notifier);\r\n}\r\niounmap(opregion->header);\r\nopregion->header = NULL;\r\nopregion->acpi = NULL;\r\nopregion->swsci = NULL;\r\nopregion->asle = NULL;\r\nopregion->vbt = NULL;\r\n}\r\nint psb_intel_opregion_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_opregion *opregion = &dev_priv->opregion;\r\nu32 opregion_phy, mboxes;\r\nvoid __iomem *base;\r\nint err = 0;\r\npci_read_config_dword(dev->pdev, PCI_ASLS, &opregion_phy);\r\nif (opregion_phy == 0) {\r\nDRM_DEBUG_DRIVER("ACPI Opregion not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nDRM_DEBUG("OpRegion detected at 0x%8x\n", opregion_phy);\r\nbase = acpi_os_ioremap(opregion_phy, 8*1024);\r\nif (!base)\r\nreturn -ENOMEM;\r\nif (memcmp(base, OPREGION_SIGNATURE, 16)) {\r\nDRM_DEBUG_DRIVER("opregion signature mismatch\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nopregion->header = base;\r\nopregion->vbt = base + OPREGION_VBT_OFFSET;\r\nopregion->lid_state = base + ACPI_CLID;\r\nmboxes = opregion->header->mboxes;\r\nif (mboxes & MBOX_ACPI) {\r\nDRM_DEBUG_DRIVER("Public ACPI methods supported\n");\r\nopregion->acpi = base + OPREGION_ACPI_OFFSET;\r\n}\r\nif (mboxes & MBOX_ASLE) {\r\nDRM_DEBUG_DRIVER("ASLE supported\n");\r\nopregion->asle = base + OPREGION_ASLE_OFFSET;\r\n}\r\nreturn 0;\r\nerr_out:\r\niounmap(base);\r\nreturn err;\r\n}
