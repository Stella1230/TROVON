static inline uint64_t\r\nbundle (const struct insn *insn)\r\n{\r\nreturn (uint64_t) insn & ~0xfUL;\r\n}\r\nstatic inline int\r\nslot (const struct insn *insn)\r\n{\r\nreturn (uint64_t) insn & 0x3;\r\n}\r\nstatic int\r\napply_imm64 (struct module *mod, struct insn *insn, uint64_t val)\r\n{\r\nif (slot(insn) != 2) {\r\nprintk(KERN_ERR "%s: invalid slot number %d for IMM64\n",\r\nmod->name, slot(insn));\r\nreturn 0;\r\n}\r\nia64_patch_imm64((u64) insn, val);\r\nreturn 1;\r\n}\r\nstatic int\r\napply_imm60 (struct module *mod, struct insn *insn, uint64_t val)\r\n{\r\nif (slot(insn) != 2) {\r\nprintk(KERN_ERR "%s: invalid slot number %d for IMM60\n",\r\nmod->name, slot(insn));\r\nreturn 0;\r\n}\r\nif (val + ((uint64_t) 1 << 59) >= (1UL << 60)) {\r\nprintk(KERN_ERR "%s: value %ld out of IMM60 range\n",\r\nmod->name, (long) val);\r\nreturn 0;\r\n}\r\nia64_patch_imm60((u64) insn, val);\r\nreturn 1;\r\n}\r\nstatic int\r\napply_imm22 (struct module *mod, struct insn *insn, uint64_t val)\r\n{\r\nif (val + (1 << 21) >= (1 << 22)) {\r\nprintk(KERN_ERR "%s: value %li out of IMM22 range\n",\r\nmod->name, (long)val);\r\nreturn 0;\r\n}\r\nia64_patch((u64) insn, 0x01fffcfe000UL, ( ((val & 0x200000UL) << 15)\r\n| ((val & 0x1f0000UL) << 6)\r\n| ((val & 0x00ff80UL) << 20)\r\n| ((val & 0x00007fUL) << 13) ));\r\nreturn 1;\r\n}\r\nstatic int\r\napply_imm21b (struct module *mod, struct insn *insn, uint64_t val)\r\n{\r\nif (val + (1 << 20) >= (1 << 21)) {\r\nprintk(KERN_ERR "%s: value %li out of IMM21b range\n",\r\nmod->name, (long)val);\r\nreturn 0;\r\n}\r\nia64_patch((u64) insn, 0x11ffffe000UL, ( ((val & 0x100000UL) << 16)\r\n| ((val & 0x0fffffUL) << 13) ));\r\nreturn 1;\r\n}\r\nstatic int\r\npatch_plt (struct module *mod, struct plt_entry *plt, long target_ip, unsigned long target_gp)\r\n{\r\nif (apply_imm64(mod, (struct insn *) (plt->bundle[0] + 2), target_gp)\r\n&& apply_imm60(mod, (struct insn *) (plt->bundle[1] + 2),\r\n(target_ip - (int64_t) plt->bundle[1]) / 16))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nunsigned long\r\nplt_target (struct plt_entry *plt)\r\n{\r\nuint64_t b0, b1, *b = (uint64_t *) plt->bundle[1];\r\nlong off;\r\nb0 = b[0]; b1 = b[1];\r\noff = ( ((b1 & 0x00fffff000000000UL) >> 36)\r\n| ((b0 >> 48) << 20) | ((b1 & 0x7fffffUL) << 36)\r\n| ((b1 & 0x0800000000000000UL) << 0));\r\nreturn (long) plt->bundle[1] + 16*off;\r\n}\r\nstatic int\r\npatch_plt (struct module *mod, struct plt_entry *plt, long target_ip, unsigned long target_gp)\r\n{\r\nif (apply_imm64(mod, (struct insn *) (plt->bundle[0] + 2), target_ip)\r\n&& apply_imm64(mod, (struct insn *) (plt->bundle[1] + 2), target_gp))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nunsigned long\r\nplt_target (struct plt_entry *plt)\r\n{\r\nuint64_t b0, b1, *b = (uint64_t *) plt->bundle[0];\r\nb0 = b[0]; b1 = b[1];\r\nreturn ( ((b1 & 0x000007f000000000) >> 36)\r\n| ((b1 & 0x07fc000000000000) >> 43)\r\n| ((b1 & 0x0003e00000000000) >> 29)\r\n| ((b1 & 0x0000100000000000) >> 23)\r\n| ((b0 >> 46) << 22) | ((b1 & 0x7fffff) << 40)\r\n| ((b1 & 0x0800000000000000) << 4));\r\n}\r\nvoid\r\nmodule_free (struct module *mod, void *module_region)\r\n{\r\nif (mod && mod->arch.init_unw_table &&\r\nmodule_region == mod->module_init) {\r\nunw_remove_unwind_table(mod->arch.init_unw_table);\r\nmod->arch.init_unw_table = NULL;\r\n}\r\nvfree(module_region);\r\n}\r\nstatic int\r\nduplicate_reloc (const Elf64_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++) {\r\nif (rela[i].r_info == rela[num].r_info && rela[i].r_addend == rela[num].r_addend)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\ncount_gots (const Elf64_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i, ret = 0;\r\nfor (i = 0; i < num; i++) {\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_IA64_LTOFF22:\r\ncase R_IA64_LTOFF22X:\r\ncase R_IA64_LTOFF64I:\r\ncase R_IA64_LTOFF_FPTR22:\r\ncase R_IA64_LTOFF_FPTR64I:\r\ncase R_IA64_LTOFF_FPTR32MSB:\r\ncase R_IA64_LTOFF_FPTR32LSB:\r\ncase R_IA64_LTOFF_FPTR64MSB:\r\ncase R_IA64_LTOFF_FPTR64LSB:\r\nif (!duplicate_reloc(rela, i))\r\nret++;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\ncount_plts (const Elf64_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i, ret = 0;\r\nfor (i = 0; i < num; i++) {\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_IA64_PCREL21B:\r\ncase R_IA64_PLTOFF22:\r\ncase R_IA64_PLTOFF64I:\r\ncase R_IA64_PLTOFF64MSB:\r\ncase R_IA64_PLTOFF64LSB:\r\ncase R_IA64_IPLTMSB:\r\ncase R_IA64_IPLTLSB:\r\nif (!duplicate_reloc(rela, i))\r\nret++;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\ncount_fdescs (const Elf64_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i, ret = 0;\r\nfor (i = 0; i < num; i++) {\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_IA64_FPTR64I:\r\ncase R_IA64_FPTR32LSB:\r\ncase R_IA64_FPTR32MSB:\r\ncase R_IA64_FPTR64LSB:\r\ncase R_IA64_FPTR64MSB:\r\ncase R_IA64_LTOFF_FPTR22:\r\ncase R_IA64_LTOFF_FPTR32LSB:\r\ncase R_IA64_LTOFF_FPTR32MSB:\r\ncase R_IA64_LTOFF_FPTR64I:\r\ncase R_IA64_LTOFF_FPTR64LSB:\r\ncase R_IA64_LTOFF_FPTR64MSB:\r\ncase R_IA64_IPLTMSB:\r\ncase R_IA64_IPLTLSB:\r\ncase R_IA64_PCREL21B:\r\nif (!duplicate_reloc(rela, i))\r\nret++;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint\r\nmodule_frob_arch_sections (Elf_Ehdr *ehdr, Elf_Shdr *sechdrs, char *secstrings,\r\nstruct module *mod)\r\n{\r\nunsigned long core_plts = 0, init_plts = 0, gots = 0, fdescs = 0;\r\nElf64_Shdr *s, *sechdrs_end = sechdrs + ehdr->e_shnum;\r\nfor (s = sechdrs; s < sechdrs_end; ++s)\r\nif (strcmp(".core.plt", secstrings + s->sh_name) == 0)\r\nmod->arch.core_plt = s;\r\nelse if (strcmp(".init.plt", secstrings + s->sh_name) == 0)\r\nmod->arch.init_plt = s;\r\nelse if (strcmp(".got", secstrings + s->sh_name) == 0)\r\nmod->arch.got = s;\r\nelse if (strcmp(".opd", secstrings + s->sh_name) == 0)\r\nmod->arch.opd = s;\r\nelse if (strcmp(".IA_64.unwind", secstrings + s->sh_name) == 0)\r\nmod->arch.unwind = s;\r\n#ifdef CONFIG_PARAVIRT\r\nelse if (strcmp(".paravirt_bundles",\r\nsecstrings + s->sh_name) == 0)\r\nmod->arch.paravirt_bundles = s;\r\nelse if (strcmp(".paravirt_insts",\r\nsecstrings + s->sh_name) == 0)\r\nmod->arch.paravirt_insts = s;\r\n#endif\r\nif (!mod->arch.core_plt || !mod->arch.init_plt || !mod->arch.got || !mod->arch.opd) {\r\nprintk(KERN_ERR "%s: sections missing\n", mod->name);\r\nreturn -ENOEXEC;\r\n}\r\nfor (s = sechdrs + 1; s < sechdrs_end; ++s) {\r\nconst Elf64_Rela *rels = (void *)ehdr + s->sh_offset;\r\nunsigned long numrels = s->sh_size/sizeof(Elf64_Rela);\r\nif (s->sh_type != SHT_RELA)\r\ncontinue;\r\ngots += count_gots(rels, numrels);\r\nfdescs += count_fdescs(rels, numrels);\r\nif (strstr(secstrings + s->sh_name, ".init"))\r\ninit_plts += count_plts(rels, numrels);\r\nelse\r\ncore_plts += count_plts(rels, numrels);\r\n}\r\nmod->arch.core_plt->sh_type = SHT_NOBITS;\r\nmod->arch.core_plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.core_plt->sh_addralign = 16;\r\nmod->arch.core_plt->sh_size = core_plts * sizeof(struct plt_entry);\r\nmod->arch.init_plt->sh_type = SHT_NOBITS;\r\nmod->arch.init_plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.init_plt->sh_addralign = 16;\r\nmod->arch.init_plt->sh_size = init_plts * sizeof(struct plt_entry);\r\nmod->arch.got->sh_type = SHT_NOBITS;\r\nmod->arch.got->sh_flags = ARCH_SHF_SMALL | SHF_ALLOC;\r\nmod->arch.got->sh_addralign = 8;\r\nmod->arch.got->sh_size = gots * sizeof(struct got_entry);\r\nmod->arch.opd->sh_type = SHT_NOBITS;\r\nmod->arch.opd->sh_flags = SHF_ALLOC;\r\nmod->arch.opd->sh_addralign = 8;\r\nmod->arch.opd->sh_size = fdescs * sizeof(struct fdesc);\r\nDEBUGP("%s: core.plt=%lx, init.plt=%lx, got=%lx, fdesc=%lx\n",\r\n__func__, mod->arch.core_plt->sh_size, mod->arch.init_plt->sh_size,\r\nmod->arch.got->sh_size, mod->arch.opd->sh_size);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nin_init (const struct module *mod, uint64_t addr)\r\n{\r\nreturn addr - (uint64_t) mod->module_init < mod->init_size;\r\n}\r\nstatic inline int\r\nin_core (const struct module *mod, uint64_t addr)\r\n{\r\nreturn addr - (uint64_t) mod->module_core < mod->core_size;\r\n}\r\nstatic inline int\r\nis_internal (const struct module *mod, uint64_t value)\r\n{\r\nreturn in_init(mod, value) || in_core(mod, value);\r\n}\r\nstatic uint64_t\r\nget_ltoff (struct module *mod, uint64_t value, int *okp)\r\n{\r\nstruct got_entry *got, *e;\r\nif (!*okp)\r\nreturn 0;\r\ngot = (void *) mod->arch.got->sh_addr;\r\nfor (e = got; e < got + mod->arch.next_got_entry; ++e)\r\nif (e->val == value)\r\ngoto found;\r\nBUG_ON(e >= (struct got_entry *) (mod->arch.got->sh_addr + mod->arch.got->sh_size));\r\ne->val = value;\r\n++mod->arch.next_got_entry;\r\nfound:\r\nreturn (uint64_t) e - mod->arch.gp;\r\n}\r\nstatic inline int\r\ngp_addressable (struct module *mod, uint64_t value)\r\n{\r\nreturn value - mod->arch.gp + MAX_LTOFF/2 < MAX_LTOFF;\r\n}\r\nstatic uint64_t\r\nget_plt (struct module *mod, const struct insn *insn, uint64_t value, int *okp)\r\n{\r\nstruct plt_entry *plt, *plt_end;\r\nuint64_t target_ip, target_gp;\r\nif (!*okp)\r\nreturn 0;\r\nif (in_init(mod, (uint64_t) insn)) {\r\nplt = (void *) mod->arch.init_plt->sh_addr;\r\nplt_end = (void *) plt + mod->arch.init_plt->sh_size;\r\n} else {\r\nplt = (void *) mod->arch.core_plt->sh_addr;\r\nplt_end = (void *) plt + mod->arch.core_plt->sh_size;\r\n}\r\ntarget_ip = ((uint64_t *) value)[0];\r\ntarget_gp = ((uint64_t *) value)[1];\r\nwhile (plt->bundle[0][0]) {\r\nif (plt_target(plt) == target_ip)\r\ngoto found;\r\nif (++plt >= plt_end)\r\nBUG();\r\n}\r\n*plt = ia64_plt_template;\r\nif (!patch_plt(mod, plt, target_ip, target_gp)) {\r\n*okp = 0;\r\nreturn 0;\r\n}\r\n#if ARCH_MODULE_DEBUG\r\nif (plt_target(plt) != target_ip) {\r\nprintk("%s: mistargeted PLT: wanted %lx, got %lx\n",\r\n__func__, target_ip, plt_target(plt));\r\n*okp = 0;\r\nreturn 0;\r\n}\r\n#endif\r\nfound:\r\nreturn (uint64_t) plt;\r\n}\r\nstatic uint64_t\r\nget_fdesc (struct module *mod, uint64_t value, int *okp)\r\n{\r\nstruct fdesc *fdesc = (void *) mod->arch.opd->sh_addr;\r\nif (!*okp)\r\nreturn 0;\r\nif (!value) {\r\nprintk(KERN_ERR "%s: fdesc for zero requested!\n", mod->name);\r\nreturn 0;\r\n}\r\nif (!is_internal(mod, value))\r\nreturn value;\r\nwhile (fdesc->ip) {\r\nif (fdesc->ip == value)\r\nreturn (uint64_t)fdesc;\r\nif ((uint64_t) ++fdesc >= mod->arch.opd->sh_addr + mod->arch.opd->sh_size)\r\nBUG();\r\n}\r\nfdesc->ip = value;\r\nfdesc->gp = mod->arch.gp;\r\nreturn (uint64_t) fdesc;\r\n}\r\nstatic inline int\r\ndo_reloc (struct module *mod, uint8_t r_type, Elf64_Sym *sym, uint64_t addend,\r\nElf64_Shdr *sec, void *location)\r\n{\r\nenum reloc_target_format format = (r_type >> FORMAT_SHIFT) & FORMAT_MASK;\r\nenum reloc_value_formula formula = (r_type >> VALUE_SHIFT) & VALUE_MASK;\r\nuint64_t val;\r\nint ok = 1;\r\nval = sym->st_value + addend;\r\nswitch (formula) {\r\ncase RV_SEGREL:\r\ncase RV_DIRECT:\r\nbreak;\r\ncase RV_GPREL: val -= mod->arch.gp; break;\r\ncase RV_LTREL: val = get_ltoff(mod, val, &ok); break;\r\ncase RV_PLTREL: val = get_plt(mod, location, val, &ok); break;\r\ncase RV_FPTR: val = get_fdesc(mod, val, &ok); break;\r\ncase RV_SECREL: val -= sec->sh_addr; break;\r\ncase RV_LTREL_FPTR: val = get_ltoff(mod, get_fdesc(mod, val, &ok), &ok); break;\r\ncase RV_PCREL:\r\nswitch (r_type) {\r\ncase R_IA64_PCREL21B:\r\nif ((in_init(mod, val) && in_core(mod, (uint64_t)location)) ||\r\n(in_core(mod, val) && in_init(mod, (uint64_t)location))) {\r\nuint64_t delta = ((int64_t)val - (int64_t)location) / 16;\r\nif (delta + (1 << 20) >= (1 << 21)) {\r\nval = get_fdesc(mod, val, &ok);\r\nval = get_plt(mod, location, val, &ok);\r\n}\r\n} else if (!is_internal(mod, val))\r\nval = get_plt(mod, location, val, &ok);\r\ndefault:\r\nval -= bundle(location);\r\nbreak;\r\ncase R_IA64_PCREL32MSB:\r\ncase R_IA64_PCREL32LSB:\r\ncase R_IA64_PCREL64MSB:\r\ncase R_IA64_PCREL64LSB:\r\nval -= (uint64_t) location;\r\nbreak;\r\n}\r\nswitch (r_type) {\r\ncase R_IA64_PCREL60B: format = RF_INSN60; break;\r\ncase R_IA64_PCREL21B: format = RF_INSN21B; break;\r\ncase R_IA64_PCREL21M: format = RF_INSN21M; break;\r\ncase R_IA64_PCREL21F: format = RF_INSN21F; break;\r\ndefault: break;\r\n}\r\nbreak;\r\ncase RV_BDREL:\r\nval -= (uint64_t) (in_init(mod, val) ? mod->module_init : mod->module_core);\r\nbreak;\r\ncase RV_LTV:\r\nBUG();\r\nbreak;\r\ncase RV_PCREL2:\r\nif (r_type == R_IA64_PCREL21BI) {\r\nif (!is_internal(mod, val)) {\r\nprintk(KERN_ERR "%s: %s reloc against "\r\n"non-local symbol (%lx)\n", __func__,\r\nreloc_name[r_type], (unsigned long)val);\r\nreturn -ENOEXEC;\r\n}\r\nformat = RF_INSN21B;\r\n}\r\nval -= bundle(location);\r\nbreak;\r\ncase RV_SPECIAL:\r\nswitch (r_type) {\r\ncase R_IA64_IPLTMSB:\r\ncase R_IA64_IPLTLSB:\r\nval = get_fdesc(mod, get_plt(mod, location, val, &ok), &ok);\r\nformat = RF_64LSB;\r\nif (r_type == R_IA64_IPLTMSB)\r\nformat = RF_64MSB;\r\nbreak;\r\ncase R_IA64_SUB:\r\nval = addend - sym->st_value;\r\nformat = RF_INSN64;\r\nbreak;\r\ncase R_IA64_LTOFF22X:\r\nif (gp_addressable(mod, val))\r\nval -= mod->arch.gp;\r\nelse\r\nval = get_ltoff(mod, val, &ok);\r\nformat = RF_INSN22;\r\nbreak;\r\ncase R_IA64_LDXMOV:\r\nif (gp_addressable(mod, val)) {\r\nDEBUGP("%s: patching ld8 at %p to mov\n", __func__, location);\r\nia64_patch((u64) location, 0x1fff80fe000UL, 0x10000000000UL);\r\n}\r\nreturn 0;\r\ndefault:\r\nif (reloc_name[r_type])\r\nprintk(KERN_ERR "%s: special reloc %s not supported",\r\nmod->name, reloc_name[r_type]);\r\nelse\r\nprintk(KERN_ERR "%s: unknown special reloc %x\n",\r\nmod->name, r_type);\r\nreturn -ENOEXEC;\r\n}\r\nbreak;\r\ncase RV_TPREL:\r\ncase RV_LTREL_TPREL:\r\ncase RV_DTPMOD:\r\ncase RV_LTREL_DTPMOD:\r\ncase RV_DTPREL:\r\ncase RV_LTREL_DTPREL:\r\nprintk(KERN_ERR "%s: %s reloc not supported\n",\r\nmod->name, reloc_name[r_type] ? reloc_name[r_type] : "?");\r\nreturn -ENOEXEC;\r\ndefault:\r\nprintk(KERN_ERR "%s: unknown reloc %x\n", mod->name, r_type);\r\nreturn -ENOEXEC;\r\n}\r\nif (!ok)\r\nreturn -ENOEXEC;\r\nDEBUGP("%s: [%p]<-%016lx = %s(%lx)\n", __func__, location, val,\r\nreloc_name[r_type] ? reloc_name[r_type] : "?", sym->st_value + addend);\r\nswitch (format) {\r\ncase RF_INSN21B: ok = apply_imm21b(mod, location, (int64_t) val / 16); break;\r\ncase RF_INSN22: ok = apply_imm22(mod, location, val); break;\r\ncase RF_INSN64: ok = apply_imm64(mod, location, val); break;\r\ncase RF_INSN60: ok = apply_imm60(mod, location, (int64_t) val / 16); break;\r\ncase RF_32LSB: put_unaligned(val, (uint32_t *) location); break;\r\ncase RF_64LSB: put_unaligned(val, (uint64_t *) location); break;\r\ncase RF_32MSB:\r\ncase RF_64MSB:\r\ncase RF_INSN14:\r\ncase RF_INSN21M:\r\ncase RF_INSN21F:\r\nprintk(KERN_ERR "%s: format %u needed by %s reloc is not supported\n",\r\nmod->name, format, reloc_name[r_type] ? reloc_name[r_type] : "?");\r\nreturn -ENOEXEC;\r\ndefault:\r\nprintk(KERN_ERR "%s: relocation %s resulted in unknown format %u\n",\r\nmod->name, reloc_name[r_type] ? reloc_name[r_type] : "?", format);\r\nreturn -ENOEXEC;\r\n}\r\nreturn ok ? 0 : -ENOEXEC;\r\n}\r\nint\r\napply_relocate_add (Elf64_Shdr *sechdrs, const char *strtab, unsigned int symindex,\r\nunsigned int relsec, struct module *mod)\r\n{\r\nunsigned int i, n = sechdrs[relsec].sh_size / sizeof(Elf64_Rela);\r\nElf64_Rela *rela = (void *) sechdrs[relsec].sh_addr;\r\nElf64_Shdr *target_sec;\r\nint ret;\r\nDEBUGP("%s: applying section %u (%u relocs) to %u\n", __func__,\r\nrelsec, n, sechdrs[relsec].sh_info);\r\ntarget_sec = sechdrs + sechdrs[relsec].sh_info;\r\nif (target_sec->sh_entsize == ~0UL)\r\nreturn 0;\r\nif (!mod->arch.gp) {\r\nuint64_t gp;\r\nif (mod->core_size > MAX_LTOFF)\r\ngp = mod->core_size - MAX_LTOFF / 2;\r\nelse\r\ngp = mod->core_size / 2;\r\ngp = (uint64_t) mod->module_core + ((gp + 7) & -8);\r\nmod->arch.gp = gp;\r\nDEBUGP("%s: placing gp at 0x%lx\n", __func__, gp);\r\n}\r\nfor (i = 0; i < n; i++) {\r\nret = do_reloc(mod, ELF64_R_TYPE(rela[i].r_info),\r\n((Elf64_Sym *) sechdrs[symindex].sh_addr\r\n+ ELF64_R_SYM(rela[i].r_info)),\r\nrela[i].r_addend, target_sec,\r\n(void *) target_sec->sh_addr + rela[i].r_offset);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nregister_unwind_table (struct module *mod)\r\n{\r\nstruct unw_table_entry *start = (void *) mod->arch.unwind->sh_addr;\r\nstruct unw_table_entry *end = start + mod->arch.unwind->sh_size / sizeof (*start);\r\nstruct unw_table_entry tmp, *e1, *e2, *core, *init;\r\nunsigned long num_init = 0, num_core = 0;\r\nfor (e1 = start; e1 < end; ++e1)\r\nif (in_init(mod, e1->start_offset))\r\n++num_init;\r\nelse\r\n++num_core;\r\nfor (e1 = start; e1 < end; ++e1) {\r\nfor (e2 = e1 + 1; e2 < end; ++e2) {\r\nif (e2->start_offset < e1->start_offset) {\r\ntmp = *e1;\r\n*e1 = *e2;\r\n*e2 = tmp;\r\n}\r\n}\r\n}\r\nif (in_init(mod, start->start_offset)) {\r\ninit = start;\r\ncore = start + num_init;\r\n} else {\r\ncore = start;\r\ninit = start + num_core;\r\n}\r\nDEBUGP("%s: name=%s, gp=%lx, num_init=%lu, num_core=%lu\n", __func__,\r\nmod->name, mod->arch.gp, num_init, num_core);\r\nif (num_core > 0) {\r\nmod->arch.core_unw_table = unw_add_unwind_table(mod->name, 0, mod->arch.gp,\r\ncore, core + num_core);\r\nDEBUGP("%s: core: handle=%p [%p-%p)\n", __func__,\r\nmod->arch.core_unw_table, core, core + num_core);\r\n}\r\nif (num_init > 0) {\r\nmod->arch.init_unw_table = unw_add_unwind_table(mod->name, 0, mod->arch.gp,\r\ninit, init + num_init);\r\nDEBUGP("%s: init: handle=%p [%p-%p)\n", __func__,\r\nmod->arch.init_unw_table, init, init + num_init);\r\n}\r\n}\r\nint\r\nmodule_finalize (const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs, struct module *mod)\r\n{\r\nDEBUGP("%s: init: entry=%p\n", __func__, mod->init);\r\nif (mod->arch.unwind)\r\nregister_unwind_table(mod);\r\n#ifdef CONFIG_PARAVIRT\r\nif (mod->arch.paravirt_bundles) {\r\nstruct paravirt_patch_site_bundle *start =\r\n(struct paravirt_patch_site_bundle *)\r\nmod->arch.paravirt_bundles->sh_addr;\r\nstruct paravirt_patch_site_bundle *end =\r\n(struct paravirt_patch_site_bundle *)\r\n(mod->arch.paravirt_bundles->sh_addr +\r\nmod->arch.paravirt_bundles->sh_size);\r\nparavirt_patch_apply_bundle(start, end);\r\n}\r\nif (mod->arch.paravirt_insts) {\r\nstruct paravirt_patch_site_inst *start =\r\n(struct paravirt_patch_site_inst *)\r\nmod->arch.paravirt_insts->sh_addr;\r\nstruct paravirt_patch_site_inst *end =\r\n(struct paravirt_patch_site_inst *)\r\n(mod->arch.paravirt_insts->sh_addr +\r\nmod->arch.paravirt_insts->sh_size);\r\nparavirt_patch_apply_inst(start, end);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid\r\nmodule_arch_cleanup (struct module *mod)\r\n{\r\nif (mod->arch.init_unw_table)\r\nunw_remove_unwind_table(mod->arch.init_unw_table);\r\nif (mod->arch.core_unw_table)\r\nunw_remove_unwind_table(mod->arch.core_unw_table);\r\n}
