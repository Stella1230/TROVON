static int xen_mce_chrdev_open(struct inode *inode, struct file *file)\r\n{\r\nspin_lock(&xen_mce_chrdev_state_lock);\r\nif (xen_mce_chrdev_open_exclu ||\r\n(xen_mce_chrdev_open_count && (file->f_flags & O_EXCL))) {\r\nspin_unlock(&xen_mce_chrdev_state_lock);\r\nreturn -EBUSY;\r\n}\r\nif (file->f_flags & O_EXCL)\r\nxen_mce_chrdev_open_exclu = 1;\r\nxen_mce_chrdev_open_count++;\r\nspin_unlock(&xen_mce_chrdev_state_lock);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int xen_mce_chrdev_release(struct inode *inode, struct file *file)\r\n{\r\nspin_lock(&xen_mce_chrdev_state_lock);\r\nxen_mce_chrdev_open_count--;\r\nxen_mce_chrdev_open_exclu = 0;\r\nspin_unlock(&xen_mce_chrdev_state_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t xen_mce_chrdev_read(struct file *filp, char __user *ubuf,\r\nsize_t usize, loff_t *off)\r\n{\r\nchar __user *buf = ubuf;\r\nunsigned num;\r\nint i, err;\r\nmutex_lock(&mcelog_lock);\r\nnum = xen_mcelog.next;\r\nerr = -EINVAL;\r\nif (*off != 0 || usize < XEN_MCE_LOG_LEN*sizeof(struct xen_mce))\r\ngoto out;\r\nerr = 0;\r\nfor (i = 0; i < num; i++) {\r\nstruct xen_mce *m = &xen_mcelog.entry[i];\r\nerr |= copy_to_user(buf, m, sizeof(*m));\r\nbuf += sizeof(*m);\r\n}\r\nmemset(xen_mcelog.entry, 0, num * sizeof(struct xen_mce));\r\nxen_mcelog.next = 0;\r\nif (err)\r\nerr = -EFAULT;\r\nout:\r\nmutex_unlock(&mcelog_lock);\r\nreturn err ? err : buf - ubuf;\r\n}\r\nstatic unsigned int xen_mce_chrdev_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &xen_mce_chrdev_wait, wait);\r\nif (xen_mcelog.next)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic long xen_mce_chrdev_ioctl(struct file *f, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint __user *p = (int __user *)arg;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase MCE_GET_RECORD_LEN:\r\nreturn put_user(sizeof(struct xen_mce), p);\r\ncase MCE_GET_LOG_LEN:\r\nreturn put_user(XEN_MCE_LOG_LEN, p);\r\ncase MCE_GETCLEAR_FLAGS: {\r\nunsigned flags;\r\ndo {\r\nflags = xen_mcelog.flags;\r\n} while (cmpxchg(&xen_mcelog.flags, flags, 0) != flags);\r\nreturn put_user(flags, p);\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic void xen_mce_log(struct xen_mce *mce)\r\n{\r\nunsigned entry;\r\nentry = xen_mcelog.next;\r\nif (entry >= XEN_MCE_LOG_LEN) {\r\nset_bit(XEN_MCE_OVERFLOW,\r\n(unsigned long *)&xen_mcelog.flags);\r\nreturn;\r\n}\r\nmemcpy(xen_mcelog.entry + entry, mce, sizeof(struct xen_mce));\r\nxen_mcelog.next++;\r\n}\r\nstatic int convert_log(struct mc_info *mi)\r\n{\r\nstruct mcinfo_common *mic;\r\nstruct mcinfo_global *mc_global;\r\nstruct mcinfo_bank *mc_bank;\r\nstruct xen_mce m;\r\nuint32_t i;\r\nmic = NULL;\r\nx86_mcinfo_lookup(&mic, mi, MC_TYPE_GLOBAL);\r\nif (unlikely(!mic)) {\r\npr_warning(XEN_MCELOG "Failed to find global error info\n");\r\nreturn -ENODEV;\r\n}\r\nmemset(&m, 0, sizeof(struct xen_mce));\r\nmc_global = (struct mcinfo_global *)mic;\r\nm.mcgstatus = mc_global->mc_gstatus;\r\nm.apicid = mc_global->mc_apicid;\r\nfor (i = 0; i < ncpus; i++)\r\nif (g_physinfo[i].mc_apicid == m.apicid)\r\nbreak;\r\nif (unlikely(i == ncpus)) {\r\npr_warning(XEN_MCELOG "Failed to match cpu with apicid %d\n",\r\nm.apicid);\r\nreturn -ENODEV;\r\n}\r\nm.socketid = g_physinfo[i].mc_chipid;\r\nm.cpu = m.extcpu = g_physinfo[i].mc_cpunr;\r\nm.cpuvendor = (__u8)g_physinfo[i].mc_vendor;\r\nm.mcgcap = g_physinfo[i].mc_msrvalues[__MC_MSR_MCGCAP].value;\r\nmic = NULL;\r\nx86_mcinfo_lookup(&mic, mi, MC_TYPE_BANK);\r\nif (unlikely(!mic)) {\r\npr_warning(XEN_MCELOG "Fail to find bank error info\n");\r\nreturn -ENODEV;\r\n}\r\ndo {\r\nif ((!mic) || (mic->size == 0) ||\r\n(mic->type != MC_TYPE_GLOBAL &&\r\nmic->type != MC_TYPE_BANK &&\r\nmic->type != MC_TYPE_EXTENDED &&\r\nmic->type != MC_TYPE_RECOVERY))\r\nbreak;\r\nif (mic->type == MC_TYPE_BANK) {\r\nmc_bank = (struct mcinfo_bank *)mic;\r\nm.misc = mc_bank->mc_misc;\r\nm.status = mc_bank->mc_status;\r\nm.addr = mc_bank->mc_addr;\r\nm.tsc = mc_bank->mc_tsc;\r\nm.bank = mc_bank->mc_bank;\r\nm.finished = 1;\r\nxen_mce_log(&m);\r\n}\r\nmic = x86_mcinfo_next(mic);\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int mc_queue_handle(uint32_t flags)\r\n{\r\nstruct xen_mc mc_op;\r\nint ret = 0;\r\nmc_op.cmd = XEN_MC_fetch;\r\nmc_op.interface_version = XEN_MCA_INTERFACE_VERSION;\r\nset_xen_guest_handle(mc_op.u.mc_fetch.data, &g_mi);\r\ndo {\r\nmc_op.u.mc_fetch.flags = flags;\r\nret = HYPERVISOR_mca(&mc_op);\r\nif (ret) {\r\npr_err(XEN_MCELOG "Failed to fetch %s error log\n",\r\n(flags == XEN_MC_URGENT) ?\r\n"urgnet" : "nonurgent");\r\nbreak;\r\n}\r\nif (mc_op.u.mc_fetch.flags & XEN_MC_NODATA ||\r\nmc_op.u.mc_fetch.flags & XEN_MC_FETCHFAILED)\r\nbreak;\r\nelse {\r\nret = convert_log(&g_mi);\r\nif (ret)\r\npr_warning(XEN_MCELOG\r\n"Failed to convert this error log, "\r\n"continue acking it anyway\n");\r\nmc_op.u.mc_fetch.flags = flags | XEN_MC_ACK;\r\nret = HYPERVISOR_mca(&mc_op);\r\nif (ret) {\r\npr_err(XEN_MCELOG\r\n"Failed to ack previous error log\n");\r\nbreak;\r\n}\r\n}\r\n} while (1);\r\nreturn ret;\r\n}\r\nstatic void xen_mce_work_fn(struct work_struct *work)\r\n{\r\nint err;\r\nmutex_lock(&mcelog_lock);\r\nerr = mc_queue_handle(XEN_MC_URGENT);\r\nif (err)\r\npr_err(XEN_MCELOG\r\n"Failed to handle urgent mc_info queue, "\r\n"continue handling nonurgent mc_info queue anyway.\n");\r\nerr = mc_queue_handle(XEN_MC_NONURGENT);\r\nif (err)\r\npr_err(XEN_MCELOG\r\n"Failed to handle nonurgent mc_info queue.\n");\r\nwake_up_interruptible(&xen_mce_chrdev_wait);\r\nmutex_unlock(&mcelog_lock);\r\n}\r\nstatic irqreturn_t xen_mce_interrupt(int irq, void *dev_id)\r\n{\r\nschedule_work(&xen_mce_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bind_virq_for_mce(void)\r\n{\r\nint ret;\r\nstruct xen_mc mc_op;\r\nmemset(&mc_op, 0, sizeof(struct xen_mc));\r\nmc_op.cmd = XEN_MC_physcpuinfo;\r\nmc_op.interface_version = XEN_MCA_INTERFACE_VERSION;\r\nset_xen_guest_handle(mc_op.u.mc_physcpuinfo.info, g_physinfo);\r\nret = HYPERVISOR_mca(&mc_op);\r\nif (ret) {\r\npr_err(XEN_MCELOG "Failed to get CPU numbers\n");\r\nreturn ret;\r\n}\r\nncpus = mc_op.u.mc_physcpuinfo.ncpus;\r\ng_physinfo = kcalloc(ncpus, sizeof(struct mcinfo_logical_cpu),\r\nGFP_KERNEL);\r\nif (!g_physinfo)\r\nreturn -ENOMEM;\r\nset_xen_guest_handle(mc_op.u.mc_physcpuinfo.info, g_physinfo);\r\nret = HYPERVISOR_mca(&mc_op);\r\nif (ret) {\r\npr_err(XEN_MCELOG "Failed to get CPU info\n");\r\nkfree(g_physinfo);\r\nreturn ret;\r\n}\r\nret = bind_virq_to_irqhandler(VIRQ_MCA, 0,\r\nxen_mce_interrupt, 0, "mce", NULL);\r\nif (ret < 0) {\r\npr_err(XEN_MCELOG "Failed to bind virq\n");\r\nkfree(g_physinfo);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xen_late_init_mcelog(void)\r\n{\r\nif (xen_initial_domain()) {\r\nif (misc_register(&xen_mce_chrdev_device))\r\nreturn -ENODEV;\r\nreturn bind_virq_for_mce();\r\n}\r\nreturn -ENODEV;\r\n}
