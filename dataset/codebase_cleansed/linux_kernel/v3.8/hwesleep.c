void acpi_hw_execute_sleep_method(char *method_pathname, u32 integer_argument)\r\n{\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(hw_execute_sleep_method);\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = (u64)integer_argument;\r\nstatus = acpi_evaluate_object(NULL, method_pathname, &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "While executing method %s",\r\nmethod_pathname));\r\n}\r\nreturn_VOID;\r\n}\r\nacpi_status acpi_hw_extended_sleep(u8 sleep_state)\r\n{\r\nacpi_status status;\r\nu8 sleep_type_value;\r\nu64 sleep_status;\r\nACPI_FUNCTION_TRACE(hw_extended_sleep);\r\nif (!acpi_gbl_FADT.sleep_control.address ||\r\n!acpi_gbl_FADT.sleep_status.address) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nstatus =\r\nacpi_write((u64)ACPI_X_WAKE_STATUS, &acpi_gbl_FADT.sleep_status);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_gbl_system_awake_and_running = FALSE;\r\nACPI_FLUSH_CPU_CACHE();\r\nACPI_DEBUG_PRINT((ACPI_DB_INIT,\r\n"Entering sleep state [S%u]\n", sleep_state));\r\nsleep_type_value =\r\n((acpi_gbl_sleep_type_a << ACPI_X_SLEEP_TYPE_POSITION) &\r\nACPI_X_SLEEP_TYPE_MASK);\r\nstatus = acpi_write((u64)(sleep_type_value | ACPI_X_SLEEP_ENABLE),\r\n&acpi_gbl_FADT.sleep_control);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\ndo {\r\nstatus = acpi_read(&sleep_status, &acpi_gbl_FADT.sleep_status);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} while (!(((u8)sleep_status) & ACPI_X_WAKE_STATUS));\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_hw_extended_wake_prep(u8 sleep_state)\r\n{\r\nacpi_status status;\r\nu8 sleep_type_value;\r\nACPI_FUNCTION_TRACE(hw_extended_wake_prep);\r\nstatus = acpi_get_sleep_type_data(ACPI_STATE_S0,\r\n&acpi_gbl_sleep_type_a,\r\n&acpi_gbl_sleep_type_b);\r\nif (ACPI_SUCCESS(status)) {\r\nsleep_type_value =\r\n((acpi_gbl_sleep_type_a << ACPI_X_SLEEP_TYPE_POSITION) &\r\nACPI_X_SLEEP_TYPE_MASK);\r\n(void)acpi_write((u64)(sleep_type_value | ACPI_X_SLEEP_ENABLE),\r\n&acpi_gbl_FADT.sleep_control);\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_hw_extended_wake(u8 sleep_state)\r\n{\r\nACPI_FUNCTION_TRACE(hw_extended_wake);\r\nacpi_gbl_sleep_type_a = ACPI_SLEEP_TYPE_INVALID;\r\nacpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, ACPI_SST_WAKING);\r\nacpi_hw_execute_sleep_method(METHOD_PATHNAME__WAK, sleep_state);\r\n(void)acpi_write((u64)ACPI_X_WAKE_STATUS, &acpi_gbl_FADT.sleep_status);\r\nacpi_gbl_system_awake_and_running = TRUE;\r\nacpi_hw_execute_sleep_method(METHOD_PATHNAME__SST, ACPI_SST_WORKING);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
