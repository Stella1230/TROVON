static long disk_size(DAC960_Controller_T *p, int drive_nr)\r\n{\r\nif (p->FirmwareType == DAC960_V1_Controller) {\r\nif (drive_nr >= p->LogicalDriveCount)\r\nreturn 0;\r\nreturn p->V1.LogicalDriveInformation[drive_nr].\r\nLogicalDriveSize;\r\n} else {\r\nDAC960_V2_LogicalDeviceInfo_T *i =\r\np->V2.LogicalDeviceInformation[drive_nr];\r\nif (i == NULL)\r\nreturn 0;\r\nreturn i->ConfigurableDeviceSize;\r\n}\r\n}\r\nstatic int DAC960_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nDAC960_Controller_T *p = disk->queue->queuedata;\r\nint drive_nr = (long)disk->private_data;\r\nint ret = -ENXIO;\r\nmutex_lock(&DAC960_mutex);\r\nif (p->FirmwareType == DAC960_V1_Controller) {\r\nif (p->V1.LogicalDriveInformation[drive_nr].\r\nLogicalDriveState == DAC960_V1_LogicalDrive_Offline)\r\ngoto out;\r\n} else {\r\nDAC960_V2_LogicalDeviceInfo_T *i =\r\np->V2.LogicalDeviceInformation[drive_nr];\r\nif (!i || i->LogicalDeviceState == DAC960_V2_LogicalDevice_Offline)\r\ngoto out;\r\n}\r\ncheck_disk_change(bdev);\r\nif (!get_capacity(p->disks[drive_nr]))\r\ngoto out;\r\nret = 0;\r\nout:\r\nmutex_unlock(&DAC960_mutex);\r\nreturn ret;\r\n}\r\nstatic int DAC960_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nDAC960_Controller_T *p = disk->queue->queuedata;\r\nint drive_nr = (long)disk->private_data;\r\nif (p->FirmwareType == DAC960_V1_Controller) {\r\ngeo->heads = p->V1.GeometryTranslationHeads;\r\ngeo->sectors = p->V1.GeometryTranslationSectors;\r\ngeo->cylinders = p->V1.LogicalDriveInformation[drive_nr].\r\nLogicalDriveSize / (geo->heads * geo->sectors);\r\n} else {\r\nDAC960_V2_LogicalDeviceInfo_T *i =\r\np->V2.LogicalDeviceInformation[drive_nr];\r\nswitch (i->DriveGeometry) {\r\ncase DAC960_V2_Geometry_128_32:\r\ngeo->heads = 128;\r\ngeo->sectors = 32;\r\nbreak;\r\ncase DAC960_V2_Geometry_255_63:\r\ngeo->heads = 255;\r\ngeo->sectors = 63;\r\nbreak;\r\ndefault:\r\nDAC960_Error("Illegal Logical Device Geometry %d\n",\r\np, i->DriveGeometry);\r\nreturn -EINVAL;\r\n}\r\ngeo->cylinders = i->ConfigurableDeviceSize /\r\n(geo->heads * geo->sectors);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int DAC960_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nDAC960_Controller_T *p = disk->queue->queuedata;\r\nint drive_nr = (long)disk->private_data;\r\nif (!p->LogicalDriveInitiallyAccessible[drive_nr])\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\nreturn 0;\r\n}\r\nstatic int DAC960_revalidate_disk(struct gendisk *disk)\r\n{\r\nDAC960_Controller_T *p = disk->queue->queuedata;\r\nint unit = (long)disk->private_data;\r\nset_capacity(disk, disk_size(p, unit));\r\nreturn 0;\r\n}\r\nstatic void DAC960_AnnounceDriver(DAC960_Controller_T *Controller)\r\n{\r\nDAC960_Announce("***** DAC960 RAID Driver Version "\r\nDAC960_DriverVersion " of "\r\nDAC960_DriverDate " *****\n", Controller);\r\nDAC960_Announce("Copyright 1998-2001 by Leonard N. Zubkoff "\r\n"<lnz@dandelion.com>\n", Controller);\r\n}\r\nstatic bool DAC960_Failure(DAC960_Controller_T *Controller,\r\nunsigned char *ErrorMessage)\r\n{\r\nDAC960_Error("While configuring DAC960 PCI RAID Controller at\n",\r\nController);\r\nif (Controller->IO_Address == 0)\r\nDAC960_Error("PCI Bus %d Device %d Function %d I/O Address N/A "\r\n"PCI Address 0x%X\n", Controller,\r\nController->Bus, Controller->Device,\r\nController->Function, Controller->PCI_Address);\r\nelse DAC960_Error("PCI Bus %d Device %d Function %d I/O Address "\r\n"0x%X PCI Address 0x%X\n", Controller,\r\nController->Bus, Controller->Device,\r\nController->Function, Controller->IO_Address,\r\nController->PCI_Address);\r\nDAC960_Error("%s FAILED - DETACHING\n", Controller, ErrorMessage);\r\nreturn false;\r\n}\r\nstatic bool init_dma_loaf(struct pci_dev *dev, struct dma_loaf *loaf,\r\nsize_t len)\r\n{\r\nvoid *cpu_addr;\r\ndma_addr_t dma_handle;\r\ncpu_addr = pci_alloc_consistent(dev, len, &dma_handle);\r\nif (cpu_addr == NULL)\r\nreturn false;\r\nloaf->cpu_free = loaf->cpu_base = cpu_addr;\r\nloaf->dma_free =loaf->dma_base = dma_handle;\r\nloaf->length = len;\r\nmemset(cpu_addr, 0, len);\r\nreturn true;\r\n}\r\nstatic void *slice_dma_loaf(struct dma_loaf *loaf, size_t len,\r\ndma_addr_t *dma_handle)\r\n{\r\nvoid *cpu_end = loaf->cpu_free + len;\r\nvoid *cpu_addr = loaf->cpu_free;\r\nBUG_ON(cpu_end > loaf->cpu_base + loaf->length);\r\n*dma_handle = loaf->dma_free;\r\nloaf->cpu_free = cpu_end;\r\nloaf->dma_free += len;\r\nreturn cpu_addr;\r\n}\r\nstatic void free_dma_loaf(struct pci_dev *dev, struct dma_loaf *loaf_handle)\r\n{\r\nif (loaf_handle->cpu_base != NULL)\r\npci_free_consistent(dev, loaf_handle->length,\r\nloaf_handle->cpu_base, loaf_handle->dma_base);\r\n}\r\nstatic bool DAC960_CreateAuxiliaryStructures(DAC960_Controller_T *Controller)\r\n{\r\nint CommandAllocationLength, CommandAllocationGroupSize;\r\nint CommandsRemaining = 0, CommandIdentifier, CommandGroupByteCount;\r\nvoid *AllocationPointer = NULL;\r\nvoid *ScatterGatherCPU = NULL;\r\ndma_addr_t ScatterGatherDMA;\r\nstruct pci_pool *ScatterGatherPool;\r\nvoid *RequestSenseCPU = NULL;\r\ndma_addr_t RequestSenseDMA;\r\nstruct pci_pool *RequestSensePool = NULL;\r\nif (Controller->FirmwareType == DAC960_V1_Controller)\r\n{\r\nCommandAllocationLength = offsetof(DAC960_Command_T, V1.EndMarker);\r\nCommandAllocationGroupSize = DAC960_V1_CommandAllocationGroupSize;\r\nScatterGatherPool = pci_pool_create("DAC960_V1_ScatterGather",\r\nController->PCIDevice,\r\nDAC960_V1_ScatterGatherLimit * sizeof(DAC960_V1_ScatterGatherSegment_T),\r\nsizeof(DAC960_V1_ScatterGatherSegment_T), 0);\r\nif (ScatterGatherPool == NULL)\r\nreturn DAC960_Failure(Controller,\r\n"AUXILIARY STRUCTURE CREATION (SG)");\r\nController->ScatterGatherPool = ScatterGatherPool;\r\n}\r\nelse\r\n{\r\nCommandAllocationLength = offsetof(DAC960_Command_T, V2.EndMarker);\r\nCommandAllocationGroupSize = DAC960_V2_CommandAllocationGroupSize;\r\nScatterGatherPool = pci_pool_create("DAC960_V2_ScatterGather",\r\nController->PCIDevice,\r\nDAC960_V2_ScatterGatherLimit * sizeof(DAC960_V2_ScatterGatherSegment_T),\r\nsizeof(DAC960_V2_ScatterGatherSegment_T), 0);\r\nif (ScatterGatherPool == NULL)\r\nreturn DAC960_Failure(Controller,\r\n"AUXILIARY STRUCTURE CREATION (SG)");\r\nRequestSensePool = pci_pool_create("DAC960_V2_RequestSense",\r\nController->PCIDevice, sizeof(DAC960_SCSI_RequestSense_T),\r\nsizeof(int), 0);\r\nif (RequestSensePool == NULL) {\r\npci_pool_destroy(ScatterGatherPool);\r\nreturn DAC960_Failure(Controller,\r\n"AUXILIARY STRUCTURE CREATION (SG)");\r\n}\r\nController->ScatterGatherPool = ScatterGatherPool;\r\nController->V2.RequestSensePool = RequestSensePool;\r\n}\r\nController->CommandAllocationGroupSize = CommandAllocationGroupSize;\r\nController->FreeCommands = NULL;\r\nfor (CommandIdentifier = 1;\r\nCommandIdentifier <= Controller->DriverQueueDepth;\r\nCommandIdentifier++)\r\n{\r\nDAC960_Command_T *Command;\r\nif (--CommandsRemaining <= 0)\r\n{\r\nCommandsRemaining =\r\nController->DriverQueueDepth - CommandIdentifier + 1;\r\nif (CommandsRemaining > CommandAllocationGroupSize)\r\nCommandsRemaining = CommandAllocationGroupSize;\r\nCommandGroupByteCount =\r\nCommandsRemaining * CommandAllocationLength;\r\nAllocationPointer = kzalloc(CommandGroupByteCount, GFP_ATOMIC);\r\nif (AllocationPointer == NULL)\r\nreturn DAC960_Failure(Controller,\r\n"AUXILIARY STRUCTURE CREATION");\r\n}\r\nCommand = (DAC960_Command_T *) AllocationPointer;\r\nAllocationPointer += CommandAllocationLength;\r\nCommand->CommandIdentifier = CommandIdentifier;\r\nCommand->Controller = Controller;\r\nCommand->Next = Controller->FreeCommands;\r\nController->FreeCommands = Command;\r\nController->Commands[CommandIdentifier-1] = Command;\r\nScatterGatherCPU = pci_pool_alloc(ScatterGatherPool, GFP_ATOMIC,\r\n&ScatterGatherDMA);\r\nif (ScatterGatherCPU == NULL)\r\nreturn DAC960_Failure(Controller, "AUXILIARY STRUCTURE CREATION");\r\nif (RequestSensePool != NULL) {\r\nRequestSenseCPU = pci_pool_alloc(RequestSensePool, GFP_ATOMIC,\r\n&RequestSenseDMA);\r\nif (RequestSenseCPU == NULL) {\r\npci_pool_free(ScatterGatherPool, ScatterGatherCPU,\r\nScatterGatherDMA);\r\nreturn DAC960_Failure(Controller,\r\n"AUXILIARY STRUCTURE CREATION");\r\n}\r\n}\r\nif (Controller->FirmwareType == DAC960_V1_Controller) {\r\nCommand->cmd_sglist = Command->V1.ScatterList;\r\nCommand->V1.ScatterGatherList =\r\n(DAC960_V1_ScatterGatherSegment_T *)ScatterGatherCPU;\r\nCommand->V1.ScatterGatherListDMA = ScatterGatherDMA;\r\nsg_init_table(Command->cmd_sglist, DAC960_V1_ScatterGatherLimit);\r\n} else {\r\nCommand->cmd_sglist = Command->V2.ScatterList;\r\nCommand->V2.ScatterGatherList =\r\n(DAC960_V2_ScatterGatherSegment_T *)ScatterGatherCPU;\r\nCommand->V2.ScatterGatherListDMA = ScatterGatherDMA;\r\nCommand->V2.RequestSense =\r\n(DAC960_SCSI_RequestSense_T *)RequestSenseCPU;\r\nCommand->V2.RequestSenseDMA = RequestSenseDMA;\r\nsg_init_table(Command->cmd_sglist, DAC960_V2_ScatterGatherLimit);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void DAC960_DestroyAuxiliaryStructures(DAC960_Controller_T *Controller)\r\n{\r\nint i;\r\nstruct pci_pool *ScatterGatherPool = Controller->ScatterGatherPool;\r\nstruct pci_pool *RequestSensePool = NULL;\r\nvoid *ScatterGatherCPU;\r\ndma_addr_t ScatterGatherDMA;\r\nvoid *RequestSenseCPU;\r\ndma_addr_t RequestSenseDMA;\r\nDAC960_Command_T *CommandGroup = NULL;\r\nif (Controller->FirmwareType == DAC960_V2_Controller)\r\nRequestSensePool = Controller->V2.RequestSensePool;\r\nController->FreeCommands = NULL;\r\nfor (i = 0; i < Controller->DriverQueueDepth; i++)\r\n{\r\nDAC960_Command_T *Command = Controller->Commands[i];\r\nif (Command == NULL)\r\ncontinue;\r\nif (Controller->FirmwareType == DAC960_V1_Controller) {\r\nScatterGatherCPU = (void *)Command->V1.ScatterGatherList;\r\nScatterGatherDMA = Command->V1.ScatterGatherListDMA;\r\nRequestSenseCPU = NULL;\r\nRequestSenseDMA = (dma_addr_t)0;\r\n} else {\r\nScatterGatherCPU = (void *)Command->V2.ScatterGatherList;\r\nScatterGatherDMA = Command->V2.ScatterGatherListDMA;\r\nRequestSenseCPU = (void *)Command->V2.RequestSense;\r\nRequestSenseDMA = Command->V2.RequestSenseDMA;\r\n}\r\nif (ScatterGatherCPU != NULL)\r\npci_pool_free(ScatterGatherPool, ScatterGatherCPU, ScatterGatherDMA);\r\nif (RequestSenseCPU != NULL)\r\npci_pool_free(RequestSensePool, RequestSenseCPU, RequestSenseDMA);\r\nif ((Command->CommandIdentifier\r\n% Controller->CommandAllocationGroupSize) == 1) {\r\nkfree(CommandGroup);\r\nCommandGroup = Command;\r\n}\r\nController->Commands[i] = NULL;\r\n}\r\nkfree(CommandGroup);\r\nif (Controller->CombinedStatusBuffer != NULL)\r\n{\r\nkfree(Controller->CombinedStatusBuffer);\r\nController->CombinedStatusBuffer = NULL;\r\nController->CurrentStatusBuffer = NULL;\r\n}\r\nif (ScatterGatherPool != NULL)\r\npci_pool_destroy(ScatterGatherPool);\r\nif (Controller->FirmwareType == DAC960_V1_Controller)\r\nreturn;\r\nif (RequestSensePool != NULL)\r\npci_pool_destroy(RequestSensePool);\r\nfor (i = 0; i < DAC960_MaxLogicalDrives; i++) {\r\nkfree(Controller->V2.LogicalDeviceInformation[i]);\r\nController->V2.LogicalDeviceInformation[i] = NULL;\r\n}\r\nfor (i = 0; i < DAC960_V2_MaxPhysicalDevices; i++)\r\n{\r\nkfree(Controller->V2.PhysicalDeviceInformation[i]);\r\nController->V2.PhysicalDeviceInformation[i] = NULL;\r\nkfree(Controller->V2.InquiryUnitSerialNumber[i]);\r\nController->V2.InquiryUnitSerialNumber[i] = NULL;\r\n}\r\n}\r\nstatic inline void DAC960_V1_ClearCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nmemset(CommandMailbox, 0, sizeof(DAC960_V1_CommandMailbox_T));\r\nCommand->V1.CommandStatus = 0;\r\n}\r\nstatic inline void DAC960_V2_ClearCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nmemset(CommandMailbox, 0, sizeof(DAC960_V2_CommandMailbox_T));\r\nCommand->V2.CommandStatus = 0;\r\n}\r\nstatic inline DAC960_Command_T *DAC960_AllocateCommand(DAC960_Controller_T\r\n*Controller)\r\n{\r\nDAC960_Command_T *Command = Controller->FreeCommands;\r\nif (Command == NULL) return NULL;\r\nController->FreeCommands = Command->Next;\r\nCommand->Next = NULL;\r\nreturn Command;\r\n}\r\nstatic inline void DAC960_DeallocateCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nCommand->Request = NULL;\r\nCommand->Next = Controller->FreeCommands;\r\nController->FreeCommands = Command;\r\n}\r\nstatic void DAC960_WaitForCommand(DAC960_Controller_T *Controller)\r\n{\r\nspin_unlock_irq(&Controller->queue_lock);\r\n__wait_event(Controller->CommandWaitQueue, Controller->FreeCommands);\r\nspin_lock_irq(&Controller->queue_lock);\r\n}\r\nstatic void DAC960_GEM_QueueCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandMailbox_T *NextCommandMailbox =\r\nController->V2.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_GEM_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V2.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V2.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_GEM_MemoryMailboxNewCommand(ControllerBaseAddress);\r\nController->V2.PreviousCommandMailbox2 =\r\nController->V2.PreviousCommandMailbox1;\r\nController->V2.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V2.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V2.FirstCommandMailbox;\r\nController->V2.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_BA_QueueCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandMailbox_T *NextCommandMailbox =\r\nController->V2.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_BA_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V2.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V2.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_BA_MemoryMailboxNewCommand(ControllerBaseAddress);\r\nController->V2.PreviousCommandMailbox2 =\r\nController->V2.PreviousCommandMailbox1;\r\nController->V2.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V2.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V2.FirstCommandMailbox;\r\nController->V2.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_LP_QueueCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandMailbox_T *NextCommandMailbox =\r\nController->V2.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_LP_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V2.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V2.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_LP_MemoryMailboxNewCommand(ControllerBaseAddress);\r\nController->V2.PreviousCommandMailbox2 =\r\nController->V2.PreviousCommandMailbox1;\r\nController->V2.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V2.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V2.FirstCommandMailbox;\r\nController->V2.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_LA_QueueCommandDualMode(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandMailbox_T *NextCommandMailbox =\r\nController->V1.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_LA_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V1.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V1.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_LA_MemoryMailboxNewCommand(ControllerBaseAddress);\r\nController->V1.PreviousCommandMailbox2 =\r\nController->V1.PreviousCommandMailbox1;\r\nController->V1.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V1.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V1.FirstCommandMailbox;\r\nController->V1.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_LA_QueueCommandSingleMode(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandMailbox_T *NextCommandMailbox =\r\nController->V1.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_LA_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V1.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V1.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_LA_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nController->V1.PreviousCommandMailbox2 =\r\nController->V1.PreviousCommandMailbox1;\r\nController->V1.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V1.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V1.FirstCommandMailbox;\r\nController->V1.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_PG_QueueCommandDualMode(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandMailbox_T *NextCommandMailbox =\r\nController->V1.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_PG_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V1.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V1.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_PG_MemoryMailboxNewCommand(ControllerBaseAddress);\r\nController->V1.PreviousCommandMailbox2 =\r\nController->V1.PreviousCommandMailbox1;\r\nController->V1.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V1.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V1.FirstCommandMailbox;\r\nController->V1.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_PG_QueueCommandSingleMode(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandMailbox_T *NextCommandMailbox =\r\nController->V1.NextCommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nDAC960_PG_WriteCommandMailbox(NextCommandMailbox, CommandMailbox);\r\nif (Controller->V1.PreviousCommandMailbox1->Words[0] == 0 ||\r\nController->V1.PreviousCommandMailbox2->Words[0] == 0)\r\nDAC960_PG_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nController->V1.PreviousCommandMailbox2 =\r\nController->V1.PreviousCommandMailbox1;\r\nController->V1.PreviousCommandMailbox1 = NextCommandMailbox;\r\nif (++NextCommandMailbox > Controller->V1.LastCommandMailbox)\r\nNextCommandMailbox = Controller->V1.FirstCommandMailbox;\r\nController->V1.NextCommandMailbox = NextCommandMailbox;\r\n}\r\nstatic void DAC960_PD_QueueCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nwhile (DAC960_PD_MailboxFullP(ControllerBaseAddress))\r\nudelay(1);\r\nDAC960_PD_WriteCommandMailbox(ControllerBaseAddress, CommandMailbox);\r\nDAC960_PD_NewCommand(ControllerBaseAddress);\r\n}\r\nstatic void DAC960_P_QueueCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nCommandMailbox->Common.CommandIdentifier = Command->CommandIdentifier;\r\nswitch (CommandMailbox->Common.CommandOpcode)\r\n{\r\ncase DAC960_V1_Enquiry:\r\nCommandMailbox->Common.CommandOpcode = DAC960_V1_Enquiry_Old;\r\nbreak;\r\ncase DAC960_V1_GetDeviceState:\r\nCommandMailbox->Common.CommandOpcode = DAC960_V1_GetDeviceState_Old;\r\nbreak;\r\ncase DAC960_V1_Read:\r\nCommandMailbox->Common.CommandOpcode = DAC960_V1_Read_Old;\r\nDAC960_PD_To_P_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ncase DAC960_V1_Write:\r\nCommandMailbox->Common.CommandOpcode = DAC960_V1_Write_Old;\r\nDAC960_PD_To_P_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ncase DAC960_V1_ReadWithScatterGather:\r\nCommandMailbox->Common.CommandOpcode =\r\nDAC960_V1_ReadWithScatterGather_Old;\r\nDAC960_PD_To_P_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ncase DAC960_V1_WriteWithScatterGather:\r\nCommandMailbox->Common.CommandOpcode =\r\nDAC960_V1_WriteWithScatterGather_Old;\r\nDAC960_PD_To_P_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwhile (DAC960_PD_MailboxFullP(ControllerBaseAddress))\r\nudelay(1);\r\nDAC960_PD_WriteCommandMailbox(ControllerBaseAddress, CommandMailbox);\r\nDAC960_PD_NewCommand(ControllerBaseAddress);\r\n}\r\nstatic void DAC960_ExecuteCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDECLARE_COMPLETION_ONSTACK(Completion);\r\nunsigned long flags;\r\nCommand->Completion = &Completion;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_QueueCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nif (in_interrupt())\r\nreturn;\r\nwait_for_completion(&Completion);\r\n}\r\nstatic bool DAC960_V1_ExecuteType3(DAC960_Controller_T *Controller,\r\nDAC960_V1_CommandOpcode_T CommandOpcode,\r\ndma_addr_t DataDMA)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandStatus_T CommandStatus;\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->Type3.CommandOpcode = CommandOpcode;\r\nCommandMailbox->Type3.BusAddress = DataDMA;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V1.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V1_NormalCompletion);\r\n}\r\nstatic bool DAC960_V1_ExecuteType3B(DAC960_Controller_T *Controller,\r\nDAC960_V1_CommandOpcode_T CommandOpcode,\r\nunsigned char CommandOpcode2,\r\ndma_addr_t DataDMA)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandStatus_T CommandStatus;\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->Type3B.CommandOpcode = CommandOpcode;\r\nCommandMailbox->Type3B.CommandOpcode2 = CommandOpcode2;\r\nCommandMailbox->Type3B.BusAddress = DataDMA;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V1.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V1_NormalCompletion);\r\n}\r\nstatic bool DAC960_V1_ExecuteType3D(DAC960_Controller_T *Controller,\r\nDAC960_V1_CommandOpcode_T CommandOpcode,\r\nunsigned char Channel,\r\nunsigned char TargetID,\r\ndma_addr_t DataDMA)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandStatus_T CommandStatus;\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->Type3D.CommandOpcode = CommandOpcode;\r\nCommandMailbox->Type3D.Channel = Channel;\r\nCommandMailbox->Type3D.TargetID = TargetID;\r\nCommandMailbox->Type3D.BusAddress = DataDMA;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V1.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V1_NormalCompletion);\r\n}\r\nstatic bool DAC960_V2_GeneralInfo(DAC960_Controller_T *Controller)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->Common.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->Common.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->Common.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->Common.DataTransferSize = sizeof(DAC960_V2_HealthStatusBuffer_T);\r\nCommandMailbox->Common.IOCTL_Opcode = DAC960_V2_GetHealthStatus;\r\nCommandMailbox->Common.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.HealthStatusBufferDMA;\r\nCommandMailbox->Common.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->Common.DataTransferSize;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V2_NewControllerInfo(DAC960_Controller_T *Controller)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->ControllerInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->ControllerInfo.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->ControllerInfo.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->ControllerInfo.DataTransferSize = sizeof(DAC960_V2_ControllerInfo_T);\r\nCommandMailbox->ControllerInfo.ControllerNumber = 0;\r\nCommandMailbox->ControllerInfo.IOCTL_Opcode = DAC960_V2_GetControllerInfo;\r\nCommandMailbox->ControllerInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewControllerInformationDMA;\r\nCommandMailbox->ControllerInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->ControllerInfo.DataTransferSize;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V2_NewLogicalDeviceInfo(DAC960_Controller_T *Controller,\r\nunsigned short LogicalDeviceNumber)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->LogicalDeviceInfo.CommandOpcode =\r\nDAC960_V2_IOCTL;\r\nCommandMailbox->LogicalDeviceInfo.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->LogicalDeviceInfo.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->LogicalDeviceInfo.DataTransferSize =\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T);\r\nCommandMailbox->LogicalDeviceInfo.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDeviceNumber;\r\nCommandMailbox->LogicalDeviceInfo.IOCTL_Opcode = DAC960_V2_GetLogicalDeviceInfoValid;\r\nCommandMailbox->LogicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewLogicalDeviceInformationDMA;\r\nCommandMailbox->LogicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->LogicalDeviceInfo.DataTransferSize;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V2_NewPhysicalDeviceInfo(DAC960_Controller_T *Controller,\r\nunsigned char Channel,\r\nunsigned char TargetID,\r\nunsigned char LogicalUnit)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->PhysicalDeviceInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->PhysicalDeviceInfo.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->PhysicalDeviceInfo.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferSize =\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T);\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.LogicalUnit = LogicalUnit;\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.TargetID = TargetID;\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.Channel = Channel;\r\nCommandMailbox->PhysicalDeviceInfo.IOCTL_Opcode =\r\nDAC960_V2_GetPhysicalDeviceInfoValid;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewPhysicalDeviceInformationDMA;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferSize;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic void DAC960_V2_ConstructNewUnitSerialNumber(\r\nDAC960_Controller_T *Controller,\r\nDAC960_V2_CommandMailbox_T *CommandMailbox, int Channel, int TargetID,\r\nint LogicalUnit)\r\n{\r\nCommandMailbox->SCSI_10.CommandOpcode = DAC960_V2_SCSI_10_Passthru;\r\nCommandMailbox->SCSI_10.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->SCSI_10.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->SCSI_10.DataTransferSize =\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nCommandMailbox->SCSI_10.PhysicalDevice.LogicalUnit = LogicalUnit;\r\nCommandMailbox->SCSI_10.PhysicalDevice.TargetID = TargetID;\r\nCommandMailbox->SCSI_10.PhysicalDevice.Channel = Channel;\r\nCommandMailbox->SCSI_10.CDBLength = 6;\r\nCommandMailbox->SCSI_10.SCSI_CDB[0] = 0x12;\r\nCommandMailbox->SCSI_10.SCSI_CDB[1] = 1;\r\nCommandMailbox->SCSI_10.SCSI_CDB[2] = 0x80;\r\nCommandMailbox->SCSI_10.SCSI_CDB[3] = 0;\r\nCommandMailbox->SCSI_10.SCSI_CDB[4] =\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nCommandMailbox->SCSI_10.SCSI_CDB[5] = 0;\r\nCommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewInquiryUnitSerialNumberDMA;\r\nCommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->SCSI_10.DataTransferSize;\r\n}\r\nstatic bool DAC960_V2_NewInquiryUnitSerialNumber(DAC960_Controller_T *Controller,\r\nint Channel, int TargetID, int LogicalUnit)\r\n{\r\nDAC960_Command_T *Command;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nCommand = DAC960_AllocateCommand(Controller);\r\nCommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nDAC960_V2_ConstructNewUnitSerialNumber(Controller, CommandMailbox,\r\nChannel, TargetID, LogicalUnit);\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V2_DeviceOperation(DAC960_Controller_T *Controller,\r\nDAC960_V2_IOCTL_Opcode_T IOCTL_Opcode,\r\nDAC960_V2_OperationDevice_T\r\nOperationDevice)\r\n{\r\nDAC960_Command_T *Command = DAC960_AllocateCommand(Controller);\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox->DeviceOperation.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->DeviceOperation.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->DeviceOperation.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->DeviceOperation.IOCTL_Opcode = IOCTL_Opcode;\r\nCommandMailbox->DeviceOperation.OperationDevice = OperationDevice;\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nDAC960_DeallocateCommand(Command);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V1_EnableMemoryMailboxInterface(DAC960_Controller_T\r\n*Controller)\r\n{\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_HardwareType_T hw_type = Controller->HardwareType;\r\nstruct pci_dev *PCI_Device = Controller->PCIDevice;\r\nstruct dma_loaf *DmaPages = &Controller->DmaPages;\r\nsize_t DmaPagesSize;\r\nsize_t CommandMailboxesSize;\r\nsize_t StatusMailboxesSize;\r\nDAC960_V1_CommandMailbox_T *CommandMailboxesMemory;\r\ndma_addr_t CommandMailboxesMemoryDMA;\r\nDAC960_V1_StatusMailbox_T *StatusMailboxesMemory;\r\ndma_addr_t StatusMailboxesMemoryDMA;\r\nDAC960_V1_CommandMailbox_T CommandMailbox;\r\nDAC960_V1_CommandStatus_T CommandStatus;\r\nint TimeoutCounter;\r\nint i;\r\nmemset(&CommandMailbox, 0, sizeof(DAC960_V1_CommandMailbox_T));\r\nif (pci_set_dma_mask(Controller->PCIDevice, DMA_BIT_MASK(32)))\r\nreturn DAC960_Failure(Controller, "DMA mask out of range");\r\nController->BounceBufferLimit = DMA_BIT_MASK(32);\r\nif ((hw_type == DAC960_PD_Controller) || (hw_type == DAC960_P_Controller)) {\r\nCommandMailboxesSize = 0;\r\nStatusMailboxesSize = 0;\r\n} else {\r\nCommandMailboxesSize = DAC960_V1_CommandMailboxCount * sizeof(DAC960_V1_CommandMailbox_T);\r\nStatusMailboxesSize = DAC960_V1_StatusMailboxCount * sizeof(DAC960_V1_StatusMailbox_T);\r\n}\r\nDmaPagesSize = CommandMailboxesSize + StatusMailboxesSize +\r\nsizeof(DAC960_V1_DCDB_T) + sizeof(DAC960_V1_Enquiry_T) +\r\nsizeof(DAC960_V1_ErrorTable_T) + sizeof(DAC960_V1_EventLogEntry_T) +\r\nsizeof(DAC960_V1_RebuildProgress_T) +\r\nsizeof(DAC960_V1_LogicalDriveInformationArray_T) +\r\nsizeof(DAC960_V1_BackgroundInitializationStatus_T) +\r\nsizeof(DAC960_V1_DeviceState_T) + sizeof(DAC960_SCSI_Inquiry_T) +\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nif (!init_dma_loaf(PCI_Device, DmaPages, DmaPagesSize))\r\nreturn false;\r\nif ((hw_type == DAC960_PD_Controller) || (hw_type == DAC960_P_Controller))\r\ngoto skip_mailboxes;\r\nCommandMailboxesMemory = slice_dma_loaf(DmaPages,\r\nCommandMailboxesSize, &CommandMailboxesMemoryDMA);\r\nController->V1.FirstCommandMailbox = CommandMailboxesMemory;\r\nController->V1.FirstCommandMailboxDMA = CommandMailboxesMemoryDMA;\r\nCommandMailboxesMemory += DAC960_V1_CommandMailboxCount - 1;\r\nController->V1.LastCommandMailbox = CommandMailboxesMemory;\r\nController->V1.NextCommandMailbox = Controller->V1.FirstCommandMailbox;\r\nController->V1.PreviousCommandMailbox1 = Controller->V1.LastCommandMailbox;\r\nController->V1.PreviousCommandMailbox2 =\r\nController->V1.LastCommandMailbox - 1;\r\nStatusMailboxesMemory = slice_dma_loaf(DmaPages,\r\nStatusMailboxesSize, &StatusMailboxesMemoryDMA);\r\nController->V1.FirstStatusMailbox = StatusMailboxesMemory;\r\nController->V1.FirstStatusMailboxDMA = StatusMailboxesMemoryDMA;\r\nStatusMailboxesMemory += DAC960_V1_StatusMailboxCount - 1;\r\nController->V1.LastStatusMailbox = StatusMailboxesMemory;\r\nController->V1.NextStatusMailbox = Controller->V1.FirstStatusMailbox;\r\nskip_mailboxes:\r\nController->V1.MonitoringDCDB = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_DCDB_T),\r\n&Controller->V1.MonitoringDCDB_DMA);\r\nController->V1.NewEnquiry = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_Enquiry_T),\r\n&Controller->V1.NewEnquiryDMA);\r\nController->V1.NewErrorTable = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_ErrorTable_T),\r\n&Controller->V1.NewErrorTableDMA);\r\nController->V1.EventLogEntry = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_EventLogEntry_T),\r\n&Controller->V1.EventLogEntryDMA);\r\nController->V1.RebuildProgress = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_RebuildProgress_T),\r\n&Controller->V1.RebuildProgressDMA);\r\nController->V1.NewLogicalDriveInformation = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_LogicalDriveInformationArray_T),\r\n&Controller->V1.NewLogicalDriveInformationDMA);\r\nController->V1.BackgroundInitializationStatus = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_BackgroundInitializationStatus_T),\r\n&Controller->V1.BackgroundInitializationStatusDMA);\r\nController->V1.NewDeviceState = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V1_DeviceState_T),\r\n&Controller->V1.NewDeviceStateDMA);\r\nController->V1.NewInquiryStandardData = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_SCSI_Inquiry_T),\r\n&Controller->V1.NewInquiryStandardDataDMA);\r\nController->V1.NewInquiryUnitSerialNumber = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T),\r\n&Controller->V1.NewInquiryUnitSerialNumberDMA);\r\nif ((hw_type == DAC960_PD_Controller) || (hw_type == DAC960_P_Controller))\r\nreturn true;\r\nController->V1.DualModeMemoryMailboxInterface = true;\r\nCommandMailbox.TypeX.CommandOpcode = 0x2B;\r\nCommandMailbox.TypeX.CommandIdentifier = 0;\r\nCommandMailbox.TypeX.CommandOpcode2 = 0x14;\r\nCommandMailbox.TypeX.CommandMailboxesBusAddress =\r\nController->V1.FirstCommandMailboxDMA;\r\nCommandMailbox.TypeX.StatusMailboxesBusAddress =\r\nController->V1.FirstStatusMailboxDMA;\r\n#define TIMEOUT_COUNT 1000000\r\nfor (i = 0; i < 2; i++)\r\nswitch (Controller->HardwareType)\r\n{\r\ncase DAC960_LA_Controller:\r\nTimeoutCounter = TIMEOUT_COUNT;\r\nwhile (--TimeoutCounter >= 0)\r\n{\r\nif (!DAC960_LA_HardwareMailboxFullP(ControllerBaseAddress))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (TimeoutCounter < 0) return false;\r\nDAC960_LA_WriteHardwareMailbox(ControllerBaseAddress, &CommandMailbox);\r\nDAC960_LA_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nTimeoutCounter = TIMEOUT_COUNT;\r\nwhile (--TimeoutCounter >= 0)\r\n{\r\nif (DAC960_LA_HardwareMailboxStatusAvailableP(\r\nControllerBaseAddress))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (TimeoutCounter < 0) return false;\r\nCommandStatus = DAC960_LA_ReadStatusRegister(ControllerBaseAddress);\r\nDAC960_LA_AcknowledgeHardwareMailboxInterrupt(ControllerBaseAddress);\r\nDAC960_LA_AcknowledgeHardwareMailboxStatus(ControllerBaseAddress);\r\nif (CommandStatus == DAC960_V1_NormalCompletion) return true;\r\nController->V1.DualModeMemoryMailboxInterface = false;\r\nCommandMailbox.TypeX.CommandOpcode2 = 0x10;\r\nbreak;\r\ncase DAC960_PG_Controller:\r\nTimeoutCounter = TIMEOUT_COUNT;\r\nwhile (--TimeoutCounter >= 0)\r\n{\r\nif (!DAC960_PG_HardwareMailboxFullP(ControllerBaseAddress))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (TimeoutCounter < 0) return false;\r\nDAC960_PG_WriteHardwareMailbox(ControllerBaseAddress, &CommandMailbox);\r\nDAC960_PG_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nTimeoutCounter = TIMEOUT_COUNT;\r\nwhile (--TimeoutCounter >= 0)\r\n{\r\nif (DAC960_PG_HardwareMailboxStatusAvailableP(\r\nControllerBaseAddress))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (TimeoutCounter < 0) return false;\r\nCommandStatus = DAC960_PG_ReadStatusRegister(ControllerBaseAddress);\r\nDAC960_PG_AcknowledgeHardwareMailboxInterrupt(ControllerBaseAddress);\r\nDAC960_PG_AcknowledgeHardwareMailboxStatus(ControllerBaseAddress);\r\nif (CommandStatus == DAC960_V1_NormalCompletion) return true;\r\nController->V1.DualModeMemoryMailboxInterface = false;\r\nCommandMailbox.TypeX.CommandOpcode2 = 0x10;\r\nbreak;\r\ndefault:\r\nDAC960_Failure(Controller, "Unknown Controller Type\n");\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic bool DAC960_V2_EnableMemoryMailboxInterface(DAC960_Controller_T\r\n*Controller)\r\n{\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nstruct pci_dev *PCI_Device = Controller->PCIDevice;\r\nstruct dma_loaf *DmaPages = &Controller->DmaPages;\r\nsize_t DmaPagesSize;\r\nsize_t CommandMailboxesSize;\r\nsize_t StatusMailboxesSize;\r\nDAC960_V2_CommandMailbox_T *CommandMailboxesMemory;\r\ndma_addr_t CommandMailboxesMemoryDMA;\r\nDAC960_V2_StatusMailbox_T *StatusMailboxesMemory;\r\ndma_addr_t StatusMailboxesMemoryDMA;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox;\r\ndma_addr_t CommandMailboxDMA;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nif (!pci_set_dma_mask(Controller->PCIDevice, DMA_BIT_MASK(64)))\r\nController->BounceBufferLimit = DMA_BIT_MASK(64);\r\nelse if (!pci_set_dma_mask(Controller->PCIDevice, DMA_BIT_MASK(32)))\r\nController->BounceBufferLimit = DMA_BIT_MASK(32);\r\nelse\r\nreturn DAC960_Failure(Controller, "DMA mask out of range");\r\nCommandMailbox = pci_alloc_consistent(PCI_Device,\r\nsizeof(DAC960_V2_CommandMailbox_T), &CommandMailboxDMA);\r\nif (CommandMailbox == NULL)\r\nreturn false;\r\nCommandMailboxesSize = DAC960_V2_CommandMailboxCount * sizeof(DAC960_V2_CommandMailbox_T);\r\nStatusMailboxesSize = DAC960_V2_StatusMailboxCount * sizeof(DAC960_V2_StatusMailbox_T);\r\nDmaPagesSize =\r\nCommandMailboxesSize + StatusMailboxesSize +\r\nsizeof(DAC960_V2_HealthStatusBuffer_T) +\r\nsizeof(DAC960_V2_ControllerInfo_T) +\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T) +\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T) +\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T) +\r\nsizeof(DAC960_V2_Event_T) +\r\nsizeof(DAC960_V2_PhysicalToLogicalDevice_T);\r\nif (!init_dma_loaf(PCI_Device, DmaPages, DmaPagesSize)) {\r\npci_free_consistent(PCI_Device, sizeof(DAC960_V2_CommandMailbox_T),\r\nCommandMailbox, CommandMailboxDMA);\r\nreturn false;\r\n}\r\nCommandMailboxesMemory = slice_dma_loaf(DmaPages,\r\nCommandMailboxesSize, &CommandMailboxesMemoryDMA);\r\nController->V2.FirstCommandMailbox = CommandMailboxesMemory;\r\nController->V2.FirstCommandMailboxDMA = CommandMailboxesMemoryDMA;\r\nCommandMailboxesMemory += DAC960_V2_CommandMailboxCount - 1;\r\nController->V2.LastCommandMailbox = CommandMailboxesMemory;\r\nController->V2.NextCommandMailbox = Controller->V2.FirstCommandMailbox;\r\nController->V2.PreviousCommandMailbox1 = Controller->V2.LastCommandMailbox;\r\nController->V2.PreviousCommandMailbox2 =\r\nController->V2.LastCommandMailbox - 1;\r\nStatusMailboxesMemory = slice_dma_loaf(DmaPages,\r\nStatusMailboxesSize, &StatusMailboxesMemoryDMA);\r\nController->V2.FirstStatusMailbox = StatusMailboxesMemory;\r\nController->V2.FirstStatusMailboxDMA = StatusMailboxesMemoryDMA;\r\nStatusMailboxesMemory += DAC960_V2_StatusMailboxCount - 1;\r\nController->V2.LastStatusMailbox = StatusMailboxesMemory;\r\nController->V2.NextStatusMailbox = Controller->V2.FirstStatusMailbox;\r\nController->V2.HealthStatusBuffer = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V2_HealthStatusBuffer_T),\r\n&Controller->V2.HealthStatusBufferDMA);\r\nController->V2.NewControllerInformation = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V2_ControllerInfo_T),\r\n&Controller->V2.NewControllerInformationDMA);\r\nController->V2.NewLogicalDeviceInformation = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T),\r\n&Controller->V2.NewLogicalDeviceInformationDMA);\r\nController->V2.NewPhysicalDeviceInformation = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T),\r\n&Controller->V2.NewPhysicalDeviceInformationDMA);\r\nController->V2.NewInquiryUnitSerialNumber = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T),\r\n&Controller->V2.NewInquiryUnitSerialNumberDMA);\r\nController->V2.Event = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V2_Event_T),\r\n&Controller->V2.EventDMA);\r\nController->V2.PhysicalToLogicalDevice = slice_dma_loaf(DmaPages,\r\nsizeof(DAC960_V2_PhysicalToLogicalDevice_T),\r\n&Controller->V2.PhysicalToLogicalDeviceDMA);\r\nmemset(CommandMailbox, 0, sizeof(DAC960_V2_CommandMailbox_T));\r\nCommandMailbox->SetMemoryMailbox.CommandIdentifier = 1;\r\nCommandMailbox->SetMemoryMailbox.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->SetMemoryMailbox.CommandControlBits.NoAutoRequestSense = true;\r\nCommandMailbox->SetMemoryMailbox.FirstCommandMailboxSizeKB =\r\n(DAC960_V2_CommandMailboxCount * sizeof(DAC960_V2_CommandMailbox_T)) >> 10;\r\nCommandMailbox->SetMemoryMailbox.FirstStatusMailboxSizeKB =\r\n(DAC960_V2_StatusMailboxCount * sizeof(DAC960_V2_StatusMailbox_T)) >> 10;\r\nCommandMailbox->SetMemoryMailbox.SecondCommandMailboxSizeKB = 0;\r\nCommandMailbox->SetMemoryMailbox.SecondStatusMailboxSizeKB = 0;\r\nCommandMailbox->SetMemoryMailbox.RequestSenseSize = 0;\r\nCommandMailbox->SetMemoryMailbox.IOCTL_Opcode = DAC960_V2_SetMemoryMailbox;\r\nCommandMailbox->SetMemoryMailbox.HealthStatusBufferSizeKB = 1;\r\nCommandMailbox->SetMemoryMailbox.HealthStatusBufferBusAddress =\r\nController->V2.HealthStatusBufferDMA;\r\nCommandMailbox->SetMemoryMailbox.FirstCommandMailboxBusAddress =\r\nController->V2.FirstCommandMailboxDMA;\r\nCommandMailbox->SetMemoryMailbox.FirstStatusMailboxBusAddress =\r\nController->V2.FirstStatusMailboxDMA;\r\nswitch (Controller->HardwareType)\r\n{\r\ncase DAC960_GEM_Controller:\r\nwhile (DAC960_GEM_HardwareMailboxFullP(ControllerBaseAddress))\r\nudelay(1);\r\nDAC960_GEM_WriteHardwareMailbox(ControllerBaseAddress, CommandMailboxDMA);\r\nDAC960_GEM_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nwhile (!DAC960_GEM_HardwareMailboxStatusAvailableP(ControllerBaseAddress))\r\nudelay(1);\r\nCommandStatus = DAC960_GEM_ReadCommandStatus(ControllerBaseAddress);\r\nDAC960_GEM_AcknowledgeHardwareMailboxInterrupt(ControllerBaseAddress);\r\nDAC960_GEM_AcknowledgeHardwareMailboxStatus(ControllerBaseAddress);\r\nbreak;\r\ncase DAC960_BA_Controller:\r\nwhile (DAC960_BA_HardwareMailboxFullP(ControllerBaseAddress))\r\nudelay(1);\r\nDAC960_BA_WriteHardwareMailbox(ControllerBaseAddress, CommandMailboxDMA);\r\nDAC960_BA_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nwhile (!DAC960_BA_HardwareMailboxStatusAvailableP(ControllerBaseAddress))\r\nudelay(1);\r\nCommandStatus = DAC960_BA_ReadCommandStatus(ControllerBaseAddress);\r\nDAC960_BA_AcknowledgeHardwareMailboxInterrupt(ControllerBaseAddress);\r\nDAC960_BA_AcknowledgeHardwareMailboxStatus(ControllerBaseAddress);\r\nbreak;\r\ncase DAC960_LP_Controller:\r\nwhile (DAC960_LP_HardwareMailboxFullP(ControllerBaseAddress))\r\nudelay(1);\r\nDAC960_LP_WriteHardwareMailbox(ControllerBaseAddress, CommandMailboxDMA);\r\nDAC960_LP_HardwareMailboxNewCommand(ControllerBaseAddress);\r\nwhile (!DAC960_LP_HardwareMailboxStatusAvailableP(ControllerBaseAddress))\r\nudelay(1);\r\nCommandStatus = DAC960_LP_ReadCommandStatus(ControllerBaseAddress);\r\nDAC960_LP_AcknowledgeHardwareMailboxInterrupt(ControllerBaseAddress);\r\nDAC960_LP_AcknowledgeHardwareMailboxStatus(ControllerBaseAddress);\r\nbreak;\r\ndefault:\r\nDAC960_Failure(Controller, "Unknown Controller Type\n");\r\nCommandStatus = DAC960_V2_AbormalCompletion;\r\nbreak;\r\n}\r\npci_free_consistent(PCI_Device, sizeof(DAC960_V2_CommandMailbox_T),\r\nCommandMailbox, CommandMailboxDMA);\r\nreturn (CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V1_ReadControllerConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nDAC960_V1_Enquiry2_T *Enquiry2;\r\ndma_addr_t Enquiry2DMA;\r\nDAC960_V1_Config2_T *Config2;\r\ndma_addr_t Config2DMA;\r\nint LogicalDriveNumber, Channel, TargetID;\r\nstruct dma_loaf local_dma;\r\nif (!init_dma_loaf(Controller->PCIDevice, &local_dma,\r\nsizeof(DAC960_V1_Enquiry2_T) + sizeof(DAC960_V1_Config2_T)))\r\nreturn DAC960_Failure(Controller, "LOGICAL DEVICE ALLOCATION");\r\nEnquiry2 = slice_dma_loaf(&local_dma, sizeof(DAC960_V1_Enquiry2_T), &Enquiry2DMA);\r\nConfig2 = slice_dma_loaf(&local_dma, sizeof(DAC960_V1_Config2_T), &Config2DMA);\r\nif (!DAC960_V1_ExecuteType3(Controller, DAC960_V1_Enquiry,\r\nController->V1.NewEnquiryDMA)) {\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "ENQUIRY");\r\n}\r\nmemcpy(&Controller->V1.Enquiry, Controller->V1.NewEnquiry,\r\nsizeof(DAC960_V1_Enquiry_T));\r\nif (!DAC960_V1_ExecuteType3(Controller, DAC960_V1_Enquiry2, Enquiry2DMA)) {\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "ENQUIRY2");\r\n}\r\nif (!DAC960_V1_ExecuteType3(Controller, DAC960_V1_ReadConfig2, Config2DMA)) {\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "READ CONFIG2");\r\n}\r\nif (!DAC960_V1_ExecuteType3(Controller, DAC960_V1_GetLogicalDriveInformation,\r\nController->V1.NewLogicalDriveInformationDMA)) {\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "GET LOGICAL DRIVE INFORMATION");\r\n}\r\nmemcpy(&Controller->V1.LogicalDriveInformation,\r\nController->V1.NewLogicalDriveInformation,\r\nsizeof(DAC960_V1_LogicalDriveInformationArray_T));\r\nfor (Channel = 0; Channel < Enquiry2->ActualChannels; Channel++)\r\nfor (TargetID = 0; TargetID < Enquiry2->MaxTargets; TargetID++) {\r\nif (!DAC960_V1_ExecuteType3D(Controller, DAC960_V1_GetDeviceState,\r\nChannel, TargetID,\r\nController->V1.NewDeviceStateDMA)) {\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "GET DEVICE STATE");\r\n}\r\nmemcpy(&Controller->V1.DeviceState[Channel][TargetID],\r\nController->V1.NewDeviceState, sizeof(DAC960_V1_DeviceState_T));\r\n}\r\nswitch (Enquiry2->HardwareID.SubModel)\r\n{\r\ncase DAC960_V1_P_PD_PU:\r\nif (Enquiry2->SCSICapability.BusSpeed == DAC960_V1_Ultra)\r\nstrcpy(Controller->ModelName, "DAC960PU");\r\nelse strcpy(Controller->ModelName, "DAC960PD");\r\nbreak;\r\ncase DAC960_V1_PL:\r\nstrcpy(Controller->ModelName, "DAC960PL");\r\nbreak;\r\ncase DAC960_V1_PG:\r\nstrcpy(Controller->ModelName, "DAC960PG");\r\nbreak;\r\ncase DAC960_V1_PJ:\r\nstrcpy(Controller->ModelName, "DAC960PJ");\r\nbreak;\r\ncase DAC960_V1_PR:\r\nstrcpy(Controller->ModelName, "DAC960PR");\r\nbreak;\r\ncase DAC960_V1_PT:\r\nstrcpy(Controller->ModelName, "DAC960PT");\r\nbreak;\r\ncase DAC960_V1_PTL0:\r\nstrcpy(Controller->ModelName, "DAC960PTL0");\r\nbreak;\r\ncase DAC960_V1_PRL:\r\nstrcpy(Controller->ModelName, "DAC960PRL");\r\nbreak;\r\ncase DAC960_V1_PTL1:\r\nstrcpy(Controller->ModelName, "DAC960PTL1");\r\nbreak;\r\ncase DAC960_V1_1164P:\r\nstrcpy(Controller->ModelName, "DAC1164P");\r\nbreak;\r\ndefault:\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "MODEL VERIFICATION");\r\n}\r\nstrcpy(Controller->FullModelName, "Mylex ");\r\nstrcat(Controller->FullModelName, Controller->ModelName);\r\n#if defined(CONFIG_ALPHA)\r\n# define FIRMWARE_27X "2.70"\r\n#else\r\n# define FIRMWARE_27X "2.73"\r\n#endif\r\nif (Enquiry2->FirmwareID.MajorVersion == 0)\r\n{\r\nEnquiry2->FirmwareID.MajorVersion =\r\nController->V1.Enquiry.MajorFirmwareVersion;\r\nEnquiry2->FirmwareID.MinorVersion =\r\nController->V1.Enquiry.MinorFirmwareVersion;\r\nEnquiry2->FirmwareID.FirmwareType = '0';\r\nEnquiry2->FirmwareID.TurnID = 0;\r\n}\r\nsprintf(Controller->FirmwareVersion, "%d.%02d-%c-%02d",\r\nEnquiry2->FirmwareID.MajorVersion, Enquiry2->FirmwareID.MinorVersion,\r\nEnquiry2->FirmwareID.FirmwareType, Enquiry2->FirmwareID.TurnID);\r\nif (!((Controller->FirmwareVersion[0] == '5' &&\r\nstrcmp(Controller->FirmwareVersion, "5.06") >= 0) ||\r\n(Controller->FirmwareVersion[0] == '4' &&\r\nstrcmp(Controller->FirmwareVersion, "4.06") >= 0) ||\r\n(Controller->FirmwareVersion[0] == '3' &&\r\nstrcmp(Controller->FirmwareVersion, "3.51") >= 0) ||\r\n(Controller->FirmwareVersion[0] == '2' &&\r\nstrcmp(Controller->FirmwareVersion, FIRMWARE_27X) >= 0)))\r\n{\r\nDAC960_Failure(Controller, "FIRMWARE VERSION VERIFICATION");\r\nDAC960_Error("Firmware Version = '%s'\n", Controller,\r\nController->FirmwareVersion);\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn false;\r\n}\r\nController->Channels = Enquiry2->ActualChannels;\r\nController->Targets = Enquiry2->MaxTargets;\r\nController->MemorySize = Enquiry2->MemorySize >> 20;\r\nController->V1.SAFTE_EnclosureManagementEnabled =\r\n(Enquiry2->FaultManagementType == DAC960_V1_SAFTE);\r\nController->ControllerQueueDepth = Controller->V1.Enquiry.MaxCommands;\r\nController->DriverQueueDepth = Controller->ControllerQueueDepth - 1;\r\nif (Controller->DriverQueueDepth > DAC960_MaxDriverQueueDepth)\r\nController->DriverQueueDepth = DAC960_MaxDriverQueueDepth;\r\nController->LogicalDriveCount =\r\nController->V1.Enquiry.NumberOfLogicalDrives;\r\nController->MaxBlocksPerCommand = Enquiry2->MaxBlocksPerCommand;\r\nController->ControllerScatterGatherLimit = Enquiry2->MaxScatterGatherEntries;\r\nController->DriverScatterGatherLimit =\r\nController->ControllerScatterGatherLimit;\r\nif (Controller->DriverScatterGatherLimit > DAC960_V1_ScatterGatherLimit)\r\nController->DriverScatterGatherLimit = DAC960_V1_ScatterGatherLimit;\r\nController->V1.StripeSize = Config2->BlocksPerStripe * Config2->BlockFactor\r\n>> (10 - DAC960_BlockSizeBits);\r\nController->V1.SegmentSize = Config2->BlocksPerCacheLine * Config2->BlockFactor\r\n>> (10 - DAC960_BlockSizeBits);\r\nswitch (Config2->DriveGeometry)\r\n{\r\ncase DAC960_V1_Geometry_128_32:\r\nController->V1.GeometryTranslationHeads = 128;\r\nController->V1.GeometryTranslationSectors = 32;\r\nbreak;\r\ncase DAC960_V1_Geometry_255_63:\r\nController->V1.GeometryTranslationHeads = 255;\r\nController->V1.GeometryTranslationSectors = 63;\r\nbreak;\r\ndefault:\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn DAC960_Failure(Controller, "CONFIG2 DRIVE GEOMETRY");\r\n}\r\nif ((Controller->FirmwareVersion[0] == '4' &&\r\nstrcmp(Controller->FirmwareVersion, "4.08") >= 0) ||\r\n(Controller->FirmwareVersion[0] == '5' &&\r\nstrcmp(Controller->FirmwareVersion, "5.08") >= 0))\r\n{\r\nController->V1.BackgroundInitializationStatusSupported = true;\r\nDAC960_V1_ExecuteType3B(Controller,\r\nDAC960_V1_BackgroundInitializationControl, 0x20,\r\nController->\r\nV1.BackgroundInitializationStatusDMA);\r\nmemcpy(&Controller->V1.LastBackgroundInitializationStatus,\r\nController->V1.BackgroundInitializationStatus,\r\nsizeof(DAC960_V1_BackgroundInitializationStatus_T));\r\n}\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < Controller->LogicalDriveCount;\r\nLogicalDriveNumber++)\r\nif (Controller->V1.LogicalDriveInformation\r\n[LogicalDriveNumber].LogicalDriveState !=\r\nDAC960_V1_LogicalDrive_Offline)\r\nController->LogicalDriveInitiallyAccessible[LogicalDriveNumber] = true;\r\nController->V1.LastRebuildStatus = DAC960_V1_NoRebuildOrCheckInProgress;\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn true;\r\n}\r\nstatic bool DAC960_V2_ReadControllerConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nDAC960_V2_ControllerInfo_T *ControllerInfo =\r\n&Controller->V2.ControllerInformation;\r\nunsigned short LogicalDeviceNumber = 0;\r\nint ModelNameLength;\r\nif (!DAC960_V2_NewControllerInfo(Controller))\r\nreturn DAC960_Failure(Controller, "GET CONTROLLER INFO");\r\nmemcpy(ControllerInfo, Controller->V2.NewControllerInformation,\r\nsizeof(DAC960_V2_ControllerInfo_T));\r\nif (!DAC960_V2_GeneralInfo(Controller))\r\nreturn DAC960_Failure(Controller, "GET HEALTH STATUS");\r\nModelNameLength = sizeof(ControllerInfo->ControllerName);\r\nif (ModelNameLength > sizeof(Controller->ModelName)-1)\r\nModelNameLength = sizeof(Controller->ModelName)-1;\r\nmemcpy(Controller->ModelName, ControllerInfo->ControllerName,\r\nModelNameLength);\r\nModelNameLength--;\r\nwhile (Controller->ModelName[ModelNameLength] == ' ' ||\r\nController->ModelName[ModelNameLength] == '\0')\r\nModelNameLength--;\r\nController->ModelName[++ModelNameLength] = '\0';\r\nstrcpy(Controller->FullModelName, "Mylex ");\r\nstrcat(Controller->FullModelName, Controller->ModelName);\r\nsprintf(Controller->FirmwareVersion, "%d.%02d-%02d",\r\nControllerInfo->FirmwareMajorVersion,\r\nControllerInfo->FirmwareMinorVersion,\r\nControllerInfo->FirmwareTurnNumber);\r\nif (ControllerInfo->FirmwareMajorVersion == 6 &&\r\nControllerInfo->FirmwareMinorVersion == 0 &&\r\nControllerInfo->FirmwareTurnNumber < 1)\r\n{\r\nDAC960_Info("FIRMWARE VERSION %s DOES NOT PROVIDE THE CONTROLLER\n",\r\nController, Controller->FirmwareVersion);\r\nDAC960_Info("STATUS MONITORING FUNCTIONALITY NEEDED BY THIS DRIVER.\n",\r\nController);\r\nDAC960_Info("PLEASE UPGRADE TO VERSION 6.00-01 OR ABOVE.\n",\r\nController);\r\n}\r\nController->Channels = ControllerInfo->NumberOfPhysicalChannelsPresent;\r\nController->Targets =\r\nControllerInfo->MaximumTargetsPerChannel\r\n[ControllerInfo->NumberOfPhysicalChannelsPresent-1];\r\nController->MemorySize = ControllerInfo->MemorySizeMB;\r\nController->ControllerQueueDepth = ControllerInfo->MaximumParallelCommands;\r\nController->DriverQueueDepth = Controller->ControllerQueueDepth - 1;\r\nif (Controller->DriverQueueDepth > DAC960_MaxDriverQueueDepth)\r\nController->DriverQueueDepth = DAC960_MaxDriverQueueDepth;\r\nController->LogicalDriveCount = ControllerInfo->LogicalDevicesPresent;\r\nController->MaxBlocksPerCommand =\r\nControllerInfo->MaximumDataTransferSizeInBlocks;\r\nController->ControllerScatterGatherLimit =\r\nControllerInfo->MaximumScatterGatherEntries;\r\nController->DriverScatterGatherLimit =\r\nController->ControllerScatterGatherLimit;\r\nif (Controller->DriverScatterGatherLimit > DAC960_V2_ScatterGatherLimit)\r\nController->DriverScatterGatherLimit = DAC960_V2_ScatterGatherLimit;\r\nwhile (true)\r\n{\r\nDAC960_V2_LogicalDeviceInfo_T *NewLogicalDeviceInfo =\r\nController->V2.NewLogicalDeviceInformation;\r\nDAC960_V2_LogicalDeviceInfo_T *LogicalDeviceInfo;\r\nDAC960_V2_PhysicalDevice_T PhysicalDevice;\r\nif (!DAC960_V2_NewLogicalDeviceInfo(Controller, LogicalDeviceNumber))\r\nbreak;\r\nLogicalDeviceNumber = NewLogicalDeviceInfo->LogicalDeviceNumber;\r\nif (LogicalDeviceNumber >= DAC960_MaxLogicalDrives) {\r\nDAC960_Error("DAC960: Logical Drive Number %d not supported\n",\r\nController, LogicalDeviceNumber);\r\nbreak;\r\n}\r\nif (NewLogicalDeviceInfo->DeviceBlockSizeInBytes != DAC960_BlockSize) {\r\nDAC960_Error("DAC960: Logical Drive Block Size %d not supported\n",\r\nController, NewLogicalDeviceInfo->DeviceBlockSizeInBytes);\r\nLogicalDeviceNumber++;\r\ncontinue;\r\n}\r\nPhysicalDevice.Controller = 0;\r\nPhysicalDevice.Channel = NewLogicalDeviceInfo->Channel;\r\nPhysicalDevice.TargetID = NewLogicalDeviceInfo->TargetID;\r\nPhysicalDevice.LogicalUnit = NewLogicalDeviceInfo->LogicalUnit;\r\nController->V2.LogicalDriveToVirtualDevice[LogicalDeviceNumber] =\r\nPhysicalDevice;\r\nif (NewLogicalDeviceInfo->LogicalDeviceState !=\r\nDAC960_V2_LogicalDevice_Offline)\r\nController->LogicalDriveInitiallyAccessible[LogicalDeviceNumber] = true;\r\nLogicalDeviceInfo = kmalloc(sizeof(DAC960_V2_LogicalDeviceInfo_T),\r\nGFP_ATOMIC);\r\nif (LogicalDeviceInfo == NULL)\r\nreturn DAC960_Failure(Controller, "LOGICAL DEVICE ALLOCATION");\r\nController->V2.LogicalDeviceInformation[LogicalDeviceNumber] =\r\nLogicalDeviceInfo;\r\nmemcpy(LogicalDeviceInfo, NewLogicalDeviceInfo,\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T));\r\nLogicalDeviceNumber++;\r\n}\r\nreturn true;\r\n}\r\nstatic bool DAC960_ReportControllerConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nDAC960_Info("Configuring Mylex %s PCI RAID Controller\n",\r\nController, Controller->ModelName);\r\nDAC960_Info(" Firmware Version: %s, Channels: %d, Memory Size: %dMB\n",\r\nController, Controller->FirmwareVersion,\r\nController->Channels, Controller->MemorySize);\r\nDAC960_Info(" PCI Bus: %d, Device: %d, Function: %d, I/O Address: ",\r\nController, Controller->Bus,\r\nController->Device, Controller->Function);\r\nif (Controller->IO_Address == 0)\r\nDAC960_Info("Unassigned\n", Controller);\r\nelse DAC960_Info("0x%X\n", Controller, Controller->IO_Address);\r\nDAC960_Info(" PCI Address: 0x%X mapped at 0x%lX, IRQ Channel: %d\n",\r\nController, Controller->PCI_Address,\r\n(unsigned long) Controller->BaseAddress,\r\nController->IRQ_Channel);\r\nDAC960_Info(" Controller Queue Depth: %d, "\r\n"Maximum Blocks per Command: %d\n",\r\nController, Controller->ControllerQueueDepth,\r\nController->MaxBlocksPerCommand);\r\nDAC960_Info(" Driver Queue Depth: %d, "\r\n"Scatter/Gather Limit: %d of %d Segments\n",\r\nController, Controller->DriverQueueDepth,\r\nController->DriverScatterGatherLimit,\r\nController->ControllerScatterGatherLimit);\r\nif (Controller->FirmwareType == DAC960_V1_Controller)\r\n{\r\nDAC960_Info(" Stripe Size: %dKB, Segment Size: %dKB, "\r\n"BIOS Geometry: %d/%d\n", Controller,\r\nController->V1.StripeSize,\r\nController->V1.SegmentSize,\r\nController->V1.GeometryTranslationHeads,\r\nController->V1.GeometryTranslationSectors);\r\nif (Controller->V1.SAFTE_EnclosureManagementEnabled)\r\nDAC960_Info(" SAF-TE Enclosure Management Enabled\n", Controller);\r\n}\r\nreturn true;\r\n}\r\nstatic bool DAC960_V1_ReadDeviceConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nstruct dma_loaf local_dma;\r\ndma_addr_t DCDBs_dma[DAC960_V1_MaxChannels];\r\nDAC960_V1_DCDB_T *DCDBs_cpu[DAC960_V1_MaxChannels];\r\ndma_addr_t SCSI_Inquiry_dma[DAC960_V1_MaxChannels];\r\nDAC960_SCSI_Inquiry_T *SCSI_Inquiry_cpu[DAC960_V1_MaxChannels];\r\ndma_addr_t SCSI_NewInquiryUnitSerialNumberDMA[DAC960_V1_MaxChannels];\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *SCSI_NewInquiryUnitSerialNumberCPU[DAC960_V1_MaxChannels];\r\nstruct completion Completions[DAC960_V1_MaxChannels];\r\nunsigned long flags;\r\nint Channel, TargetID;\r\nif (!init_dma_loaf(Controller->PCIDevice, &local_dma,\r\nDAC960_V1_MaxChannels*(sizeof(DAC960_V1_DCDB_T) +\r\nsizeof(DAC960_SCSI_Inquiry_T) +\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T))))\r\nreturn DAC960_Failure(Controller,\r\n"DMA ALLOCATION FAILED IN ReadDeviceConfiguration");\r\nfor (Channel = 0; Channel < Controller->Channels; Channel++) {\r\nDCDBs_cpu[Channel] = slice_dma_loaf(&local_dma,\r\nsizeof(DAC960_V1_DCDB_T), DCDBs_dma + Channel);\r\nSCSI_Inquiry_cpu[Channel] = slice_dma_loaf(&local_dma,\r\nsizeof(DAC960_SCSI_Inquiry_T),\r\nSCSI_Inquiry_dma + Channel);\r\nSCSI_NewInquiryUnitSerialNumberCPU[Channel] = slice_dma_loaf(&local_dma,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T),\r\nSCSI_NewInquiryUnitSerialNumberDMA + Channel);\r\n}\r\nfor (TargetID = 0; TargetID < Controller->Targets; TargetID++)\r\n{\r\nfor (Channel = 0; Channel < Controller->Channels; Channel++)\r\n{\r\ndma_addr_t NewInquiryStandardDataDMA = SCSI_Inquiry_dma[Channel];\r\nDAC960_V1_DCDB_T *DCDB = DCDBs_cpu[Channel];\r\ndma_addr_t DCDB_dma = DCDBs_dma[Channel];\r\nDAC960_Command_T *Command = Controller->Commands[Channel];\r\nstruct completion *Completion = &Completions[Channel];\r\ninit_completion(Completion);\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommand->Completion = Completion;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode = DAC960_V1_DCDB;\r\nCommand->V1.CommandMailbox.Type3.BusAddress = DCDB_dma;\r\nDCDB->Channel = Channel;\r\nDCDB->TargetID = TargetID;\r\nDCDB->Direction = DAC960_V1_DCDB_DataTransferDeviceToSystem;\r\nDCDB->EarlyStatus = false;\r\nDCDB->Timeout = DAC960_V1_DCDB_Timeout_10_seconds;\r\nDCDB->NoAutomaticRequestSense = false;\r\nDCDB->DisconnectPermitted = true;\r\nDCDB->TransferLength = sizeof(DAC960_SCSI_Inquiry_T);\r\nDCDB->BusAddress = NewInquiryStandardDataDMA;\r\nDCDB->CDBLength = 6;\r\nDCDB->TransferLengthHigh4 = 0;\r\nDCDB->SenseLength = sizeof(DCDB->SenseData);\r\nDCDB->CDB[0] = 0x12;\r\nDCDB->CDB[1] = 0;\r\nDCDB->CDB[2] = 0;\r\nDCDB->CDB[3] = 0;\r\nDCDB->CDB[4] = sizeof(DAC960_SCSI_Inquiry_T);\r\nDCDB->CDB[5] = 0;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_QueueCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\n}\r\nfor (Channel = 0; Channel < Controller->Channels; Channel++)\r\n{\r\nDAC960_SCSI_Inquiry_T *InquiryStandardData =\r\n&Controller->V1.InquiryStandardData[Channel][TargetID];\r\nDAC960_SCSI_Inquiry_T *NewInquiryStandardData = SCSI_Inquiry_cpu[Channel];\r\ndma_addr_t NewInquiryUnitSerialNumberDMA =\r\nSCSI_NewInquiryUnitSerialNumberDMA[Channel];\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *NewInquiryUnitSerialNumber =\r\nSCSI_NewInquiryUnitSerialNumberCPU[Channel];\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\n&Controller->V1.InquiryUnitSerialNumber[Channel][TargetID];\r\nDAC960_Command_T *Command = Controller->Commands[Channel];\r\nDAC960_V1_DCDB_T *DCDB = DCDBs_cpu[Channel];\r\nstruct completion *Completion = &Completions[Channel];\r\nwait_for_completion(Completion);\r\nif (Command->V1.CommandStatus != DAC960_V1_NormalCompletion) {\r\nmemset(InquiryStandardData, 0, sizeof(DAC960_SCSI_Inquiry_T));\r\nInquiryStandardData->PeripheralDeviceType = 0x1F;\r\ncontinue;\r\n} else\r\nmemcpy(InquiryStandardData, NewInquiryStandardData, sizeof(DAC960_SCSI_Inquiry_T));\r\nCommand->Completion = Completion;\r\nDCDB->TransferLength = sizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nDCDB->BusAddress = NewInquiryUnitSerialNumberDMA;\r\nDCDB->SenseLength = sizeof(DCDB->SenseData);\r\nDCDB->CDB[0] = 0x12;\r\nDCDB->CDB[1] = 1;\r\nDCDB->CDB[2] = 0x80;\r\nDCDB->CDB[3] = 0;\r\nDCDB->CDB[4] = sizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nDCDB->CDB[5] = 0;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_QueueCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nwait_for_completion(Completion);\r\nif (Command->V1.CommandStatus != DAC960_V1_NormalCompletion) {\r\nmemset(InquiryUnitSerialNumber, 0,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nInquiryUnitSerialNumber->PeripheralDeviceType = 0x1F;\r\n} else\r\nmemcpy(InquiryUnitSerialNumber, NewInquiryUnitSerialNumber,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\n}\r\n}\r\nfree_dma_loaf(Controller->PCIDevice, &local_dma);\r\nreturn true;\r\n}\r\nstatic bool DAC960_V2_ReadDeviceConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nunsigned char Channel = 0, TargetID = 0, LogicalUnit = 0;\r\nunsigned short PhysicalDeviceIndex = 0;\r\nwhile (true)\r\n{\r\nDAC960_V2_PhysicalDeviceInfo_T *NewPhysicalDeviceInfo =\r\nController->V2.NewPhysicalDeviceInformation;\r\nDAC960_V2_PhysicalDeviceInfo_T *PhysicalDeviceInfo;\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *NewInquiryUnitSerialNumber =\r\nController->V2.NewInquiryUnitSerialNumber;\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber;\r\nif (!DAC960_V2_NewPhysicalDeviceInfo(Controller, Channel, TargetID, LogicalUnit))\r\nbreak;\r\nPhysicalDeviceInfo = kmalloc(sizeof(DAC960_V2_PhysicalDeviceInfo_T),\r\nGFP_ATOMIC);\r\nif (PhysicalDeviceInfo == NULL)\r\nreturn DAC960_Failure(Controller, "PHYSICAL DEVICE ALLOCATION");\r\nController->V2.PhysicalDeviceInformation[PhysicalDeviceIndex] =\r\nPhysicalDeviceInfo;\r\nmemcpy(PhysicalDeviceInfo, NewPhysicalDeviceInfo,\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T));\r\nInquiryUnitSerialNumber = kmalloc(\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T), GFP_ATOMIC);\r\nif (InquiryUnitSerialNumber == NULL) {\r\nkfree(PhysicalDeviceInfo);\r\nreturn DAC960_Failure(Controller, "SERIAL NUMBER ALLOCATION");\r\n}\r\nController->V2.InquiryUnitSerialNumber[PhysicalDeviceIndex] =\r\nInquiryUnitSerialNumber;\r\nChannel = NewPhysicalDeviceInfo->Channel;\r\nTargetID = NewPhysicalDeviceInfo->TargetID;\r\nLogicalUnit = NewPhysicalDeviceInfo->LogicalUnit;\r\nif (!DAC960_V2_NewInquiryUnitSerialNumber(Controller, Channel, TargetID, LogicalUnit)) {\r\nmemset(InquiryUnitSerialNumber, 0,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nInquiryUnitSerialNumber->PeripheralDeviceType = 0x1F;\r\n} else\r\nmemcpy(InquiryUnitSerialNumber, NewInquiryUnitSerialNumber,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nPhysicalDeviceIndex++;\r\nLogicalUnit++;\r\n}\r\nreturn true;\r\n}\r\nstatic void DAC960_SanitizeInquiryData(DAC960_SCSI_Inquiry_T\r\n*InquiryStandardData,\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T\r\n*InquiryUnitSerialNumber,\r\nunsigned char *Vendor,\r\nunsigned char *Model,\r\nunsigned char *Revision,\r\nunsigned char *SerialNumber)\r\n{\r\nint SerialNumberLength, i;\r\nif (InquiryStandardData->PeripheralDeviceType == 0x1F) return;\r\nfor (i = 0; i < sizeof(InquiryStandardData->VendorIdentification); i++)\r\n{\r\nunsigned char VendorCharacter =\r\nInquiryStandardData->VendorIdentification[i];\r\nVendor[i] = (VendorCharacter >= ' ' && VendorCharacter <= '~'\r\n? VendorCharacter : ' ');\r\n}\r\nVendor[sizeof(InquiryStandardData->VendorIdentification)] = '\0';\r\nfor (i = 0; i < sizeof(InquiryStandardData->ProductIdentification); i++)\r\n{\r\nunsigned char ModelCharacter =\r\nInquiryStandardData->ProductIdentification[i];\r\nModel[i] = (ModelCharacter >= ' ' && ModelCharacter <= '~'\r\n? ModelCharacter : ' ');\r\n}\r\nModel[sizeof(InquiryStandardData->ProductIdentification)] = '\0';\r\nfor (i = 0; i < sizeof(InquiryStandardData->ProductRevisionLevel); i++)\r\n{\r\nunsigned char RevisionCharacter =\r\nInquiryStandardData->ProductRevisionLevel[i];\r\nRevision[i] = (RevisionCharacter >= ' ' && RevisionCharacter <= '~'\r\n? RevisionCharacter : ' ');\r\n}\r\nRevision[sizeof(InquiryStandardData->ProductRevisionLevel)] = '\0';\r\nif (InquiryUnitSerialNumber->PeripheralDeviceType == 0x1F) return;\r\nSerialNumberLength = InquiryUnitSerialNumber->PageLength;\r\nif (SerialNumberLength >\r\nsizeof(InquiryUnitSerialNumber->ProductSerialNumber))\r\nSerialNumberLength = sizeof(InquiryUnitSerialNumber->ProductSerialNumber);\r\nfor (i = 0; i < SerialNumberLength; i++)\r\n{\r\nunsigned char SerialNumberCharacter =\r\nInquiryUnitSerialNumber->ProductSerialNumber[i];\r\nSerialNumber[i] =\r\n(SerialNumberCharacter >= ' ' && SerialNumberCharacter <= '~'\r\n? SerialNumberCharacter : ' ');\r\n}\r\nSerialNumber[SerialNumberLength] = '\0';\r\n}\r\nstatic bool DAC960_V1_ReportDeviceConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nint LogicalDriveNumber, Channel, TargetID;\r\nDAC960_Info(" Physical Devices:\n", Controller);\r\nfor (Channel = 0; Channel < Controller->Channels; Channel++)\r\nfor (TargetID = 0; TargetID < Controller->Targets; TargetID++)\r\n{\r\nDAC960_SCSI_Inquiry_T *InquiryStandardData =\r\n&Controller->V1.InquiryStandardData[Channel][TargetID];\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\n&Controller->V1.InquiryUnitSerialNumber[Channel][TargetID];\r\nDAC960_V1_DeviceState_T *DeviceState =\r\n&Controller->V1.DeviceState[Channel][TargetID];\r\nDAC960_V1_ErrorTableEntry_T *ErrorEntry =\r\n&Controller->V1.ErrorTable.ErrorTableEntries[Channel][TargetID];\r\nchar Vendor[1+sizeof(InquiryStandardData->VendorIdentification)];\r\nchar Model[1+sizeof(InquiryStandardData->ProductIdentification)];\r\nchar Revision[1+sizeof(InquiryStandardData->ProductRevisionLevel)];\r\nchar SerialNumber[1+sizeof(InquiryUnitSerialNumber\r\n->ProductSerialNumber)];\r\nif (InquiryStandardData->PeripheralDeviceType == 0x1F) continue;\r\nDAC960_SanitizeInquiryData(InquiryStandardData, InquiryUnitSerialNumber,\r\nVendor, Model, Revision, SerialNumber);\r\nDAC960_Info(" %d:%d%s Vendor: %s Model: %s Revision: %s\n",\r\nController, Channel, TargetID, (TargetID < 10 ? " " : ""),\r\nVendor, Model, Revision);\r\nif (InquiryUnitSerialNumber->PeripheralDeviceType != 0x1F)\r\nDAC960_Info(" Serial Number: %s\n", Controller, SerialNumber);\r\nif (DeviceState->Present &&\r\nDeviceState->DeviceType == DAC960_V1_DiskType)\r\n{\r\nif (Controller->V1.DeviceResetCount[Channel][TargetID] > 0)\r\nDAC960_Info(" Disk Status: %s, %u blocks, %d resets\n",\r\nController,\r\n(DeviceState->DeviceState == DAC960_V1_Device_Dead\r\n? "Dead"\r\n: DeviceState->DeviceState\r\n== DAC960_V1_Device_WriteOnly\r\n? "Write-Only"\r\n: DeviceState->DeviceState\r\n== DAC960_V1_Device_Online\r\n? "Online" : "Standby"),\r\nDeviceState->DiskSize,\r\nController->V1.DeviceResetCount[Channel][TargetID]);\r\nelse\r\nDAC960_Info(" Disk Status: %s, %u blocks\n", Controller,\r\n(DeviceState->DeviceState == DAC960_V1_Device_Dead\r\n? "Dead"\r\n: DeviceState->DeviceState\r\n== DAC960_V1_Device_WriteOnly\r\n? "Write-Only"\r\n: DeviceState->DeviceState\r\n== DAC960_V1_Device_Online\r\n? "Online" : "Standby"),\r\nDeviceState->DiskSize);\r\n}\r\nif (ErrorEntry->ParityErrorCount > 0 ||\r\nErrorEntry->SoftErrorCount > 0 ||\r\nErrorEntry->HardErrorCount > 0 ||\r\nErrorEntry->MiscErrorCount > 0)\r\nDAC960_Info(" Errors - Parity: %d, Soft: %d, "\r\n"Hard: %d, Misc: %d\n", Controller,\r\nErrorEntry->ParityErrorCount,\r\nErrorEntry->SoftErrorCount,\r\nErrorEntry->HardErrorCount,\r\nErrorEntry->MiscErrorCount);\r\n}\r\nDAC960_Info(" Logical Drives:\n", Controller);\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < Controller->LogicalDriveCount;\r\nLogicalDriveNumber++)\r\n{\r\nDAC960_V1_LogicalDriveInformation_T *LogicalDriveInformation =\r\n&Controller->V1.LogicalDriveInformation[LogicalDriveNumber];\r\nDAC960_Info(" /dev/rd/c%dd%d: RAID-%d, %s, %u blocks, %s\n",\r\nController, Controller->ControllerNumber, LogicalDriveNumber,\r\nLogicalDriveInformation->RAIDLevel,\r\n(LogicalDriveInformation->LogicalDriveState\r\n== DAC960_V1_LogicalDrive_Online\r\n? "Online"\r\n: LogicalDriveInformation->LogicalDriveState\r\n== DAC960_V1_LogicalDrive_Critical\r\n? "Critical" : "Offline"),\r\nLogicalDriveInformation->LogicalDriveSize,\r\n(LogicalDriveInformation->WriteBack\r\n? "Write Back" : "Write Thru"));\r\n}\r\nreturn true;\r\n}\r\nstatic bool DAC960_V2_ReportDeviceConfiguration(DAC960_Controller_T\r\n*Controller)\r\n{\r\nint PhysicalDeviceIndex, LogicalDriveNumber;\r\nDAC960_Info(" Physical Devices:\n", Controller);\r\nfor (PhysicalDeviceIndex = 0;\r\nPhysicalDeviceIndex < DAC960_V2_MaxPhysicalDevices;\r\nPhysicalDeviceIndex++)\r\n{\r\nDAC960_V2_PhysicalDeviceInfo_T *PhysicalDeviceInfo =\r\nController->V2.PhysicalDeviceInformation[PhysicalDeviceIndex];\r\nDAC960_SCSI_Inquiry_T *InquiryStandardData =\r\n(DAC960_SCSI_Inquiry_T *) &PhysicalDeviceInfo->SCSI_InquiryData;\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\nController->V2.InquiryUnitSerialNumber[PhysicalDeviceIndex];\r\nchar Vendor[1+sizeof(InquiryStandardData->VendorIdentification)];\r\nchar Model[1+sizeof(InquiryStandardData->ProductIdentification)];\r\nchar Revision[1+sizeof(InquiryStandardData->ProductRevisionLevel)];\r\nchar SerialNumber[1+sizeof(InquiryUnitSerialNumber->ProductSerialNumber)];\r\nif (PhysicalDeviceInfo == NULL) break;\r\nDAC960_SanitizeInquiryData(InquiryStandardData, InquiryUnitSerialNumber,\r\nVendor, Model, Revision, SerialNumber);\r\nDAC960_Info(" %d:%d%s Vendor: %s Model: %s Revision: %s\n",\r\nController,\r\nPhysicalDeviceInfo->Channel,\r\nPhysicalDeviceInfo->TargetID,\r\n(PhysicalDeviceInfo->TargetID < 10 ? " " : ""),\r\nVendor, Model, Revision);\r\nif (PhysicalDeviceInfo->NegotiatedSynchronousMegaTransfers == 0)\r\nDAC960_Info(" %sAsynchronous\n", Controller,\r\n(PhysicalDeviceInfo->NegotiatedDataWidthBits == 16\r\n? "Wide " :""));\r\nelse\r\nDAC960_Info(" %sSynchronous at %d MB/sec\n", Controller,\r\n(PhysicalDeviceInfo->NegotiatedDataWidthBits == 16\r\n? "Wide " :""),\r\n(PhysicalDeviceInfo->NegotiatedSynchronousMegaTransfers\r\n* PhysicalDeviceInfo->NegotiatedDataWidthBits/8));\r\nif (InquiryUnitSerialNumber->PeripheralDeviceType != 0x1F)\r\nDAC960_Info(" Serial Number: %s\n", Controller, SerialNumber);\r\nif (PhysicalDeviceInfo->PhysicalDeviceState ==\r\nDAC960_V2_Device_Unconfigured)\r\ncontinue;\r\nDAC960_Info(" Disk Status: %s, %u blocks\n", Controller,\r\n(PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Online\r\n? "Online"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Rebuild\r\n? "Rebuild"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Missing\r\n? "Missing"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Critical\r\n? "Critical"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Dead\r\n? "Dead"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_SuspectedDead\r\n? "Suspected-Dead"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_CommandedOffline\r\n? "Commanded-Offline"\r\n: PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Standby\r\n? "Standby" : "Unknown"),\r\nPhysicalDeviceInfo->ConfigurableDeviceSize);\r\nif (PhysicalDeviceInfo->ParityErrors == 0 &&\r\nPhysicalDeviceInfo->SoftErrors == 0 &&\r\nPhysicalDeviceInfo->HardErrors == 0 &&\r\nPhysicalDeviceInfo->MiscellaneousErrors == 0 &&\r\nPhysicalDeviceInfo->CommandTimeouts == 0 &&\r\nPhysicalDeviceInfo->Retries == 0 &&\r\nPhysicalDeviceInfo->Aborts == 0 &&\r\nPhysicalDeviceInfo->PredictedFailuresDetected == 0)\r\ncontinue;\r\nDAC960_Info(" Errors - Parity: %d, Soft: %d, "\r\n"Hard: %d, Misc: %d\n", Controller,\r\nPhysicalDeviceInfo->ParityErrors,\r\nPhysicalDeviceInfo->SoftErrors,\r\nPhysicalDeviceInfo->HardErrors,\r\nPhysicalDeviceInfo->MiscellaneousErrors);\r\nDAC960_Info(" Timeouts: %d, Retries: %d, "\r\n"Aborts: %d, Predicted: %d\n", Controller,\r\nPhysicalDeviceInfo->CommandTimeouts,\r\nPhysicalDeviceInfo->Retries,\r\nPhysicalDeviceInfo->Aborts,\r\nPhysicalDeviceInfo->PredictedFailuresDetected);\r\n}\r\nDAC960_Info(" Logical Drives:\n", Controller);\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < DAC960_MaxLogicalDrives;\r\nLogicalDriveNumber++)\r\n{\r\nDAC960_V2_LogicalDeviceInfo_T *LogicalDeviceInfo =\r\nController->V2.LogicalDeviceInformation[LogicalDriveNumber];\r\nunsigned char *ReadCacheStatus[] = { "Read Cache Disabled",\r\n"Read Cache Enabled",\r\n"Read Ahead Enabled",\r\n"Intelligent Read Ahead Enabled",\r\n"-", "-", "-", "-" };\r\nunsigned char *WriteCacheStatus[] = { "Write Cache Disabled",\r\n"Logical Device Read Only",\r\n"Write Cache Enabled",\r\n"Intelligent Write Cache Enabled",\r\n"-", "-", "-", "-" };\r\nunsigned char *GeometryTranslation;\r\nif (LogicalDeviceInfo == NULL) continue;\r\nswitch (LogicalDeviceInfo->DriveGeometry)\r\n{\r\ncase DAC960_V2_Geometry_128_32:\r\nGeometryTranslation = "128/32";\r\nbreak;\r\ncase DAC960_V2_Geometry_255_63:\r\nGeometryTranslation = "255/63";\r\nbreak;\r\ndefault:\r\nGeometryTranslation = "Invalid";\r\nDAC960_Error("Illegal Logical Device Geometry %d\n",\r\nController, LogicalDeviceInfo->DriveGeometry);\r\nbreak;\r\n}\r\nDAC960_Info(" /dev/rd/c%dd%d: RAID-%d, %s, %u blocks\n",\r\nController, Controller->ControllerNumber, LogicalDriveNumber,\r\nLogicalDeviceInfo->RAIDLevel,\r\n(LogicalDeviceInfo->LogicalDeviceState\r\n== DAC960_V2_LogicalDevice_Online\r\n? "Online"\r\n: LogicalDeviceInfo->LogicalDeviceState\r\n== DAC960_V2_LogicalDevice_Critical\r\n? "Critical" : "Offline"),\r\nLogicalDeviceInfo->ConfigurableDeviceSize);\r\nDAC960_Info(" Logical Device %s, BIOS Geometry: %s\n",\r\nController,\r\n(LogicalDeviceInfo->LogicalDeviceControl\r\n.LogicalDeviceInitialized\r\n? "Initialized" : "Uninitialized"),\r\nGeometryTranslation);\r\nif (LogicalDeviceInfo->StripeSize == 0)\r\n{\r\nif (LogicalDeviceInfo->CacheLineSize == 0)\r\nDAC960_Info(" Stripe Size: N/A, "\r\n"Segment Size: N/A\n", Controller);\r\nelse\r\nDAC960_Info(" Stripe Size: N/A, "\r\n"Segment Size: %dKB\n", Controller,\r\n1 << (LogicalDeviceInfo->CacheLineSize - 2));\r\n}\r\nelse\r\n{\r\nif (LogicalDeviceInfo->CacheLineSize == 0)\r\nDAC960_Info(" Stripe Size: %dKB, "\r\n"Segment Size: N/A\n", Controller,\r\n1 << (LogicalDeviceInfo->StripeSize - 2));\r\nelse\r\nDAC960_Info(" Stripe Size: %dKB, "\r\n"Segment Size: %dKB\n", Controller,\r\n1 << (LogicalDeviceInfo->StripeSize - 2),\r\n1 << (LogicalDeviceInfo->CacheLineSize - 2));\r\n}\r\nDAC960_Info(" %s, %s\n", Controller,\r\nReadCacheStatus[\r\nLogicalDeviceInfo->LogicalDeviceControl.ReadCache],\r\nWriteCacheStatus[\r\nLogicalDeviceInfo->LogicalDeviceControl.WriteCache]);\r\nif (LogicalDeviceInfo->SoftErrors > 0 ||\r\nLogicalDeviceInfo->CommandsFailed > 0 ||\r\nLogicalDeviceInfo->DeferredWriteErrors)\r\nDAC960_Info(" Errors - Soft: %d, Failed: %d, "\r\n"Deferred Write: %d\n", Controller,\r\nLogicalDeviceInfo->SoftErrors,\r\nLogicalDeviceInfo->CommandsFailed,\r\nLogicalDeviceInfo->DeferredWriteErrors);\r\n}\r\nreturn true;\r\n}\r\nstatic bool DAC960_RegisterBlockDevice(DAC960_Controller_T *Controller)\r\n{\r\nint MajorNumber = DAC960_MAJOR + Controller->ControllerNumber;\r\nint n;\r\nif (register_blkdev(MajorNumber, "dac960") < 0)\r\nreturn false;\r\nfor (n = 0; n < DAC960_MaxLogicalDrives; n++) {\r\nstruct gendisk *disk = Controller->disks[n];\r\nstruct request_queue *RequestQueue;\r\nRequestQueue = blk_init_queue(DAC960_RequestFunction,&Controller->queue_lock);\r\nif (!RequestQueue) {\r\nprintk("DAC960: failure to allocate request queue\n");\r\ncontinue;\r\n}\r\nController->RequestQueue[n] = RequestQueue;\r\nblk_queue_bounce_limit(RequestQueue, Controller->BounceBufferLimit);\r\nRequestQueue->queuedata = Controller;\r\nblk_queue_max_segments(RequestQueue, Controller->DriverScatterGatherLimit);\r\nblk_queue_max_hw_sectors(RequestQueue, Controller->MaxBlocksPerCommand);\r\ndisk->queue = RequestQueue;\r\nsprintf(disk->disk_name, "rd/c%dd%d", Controller->ControllerNumber, n);\r\ndisk->major = MajorNumber;\r\ndisk->first_minor = n << DAC960_MaxPartitionsBits;\r\ndisk->fops = &DAC960_BlockDeviceOperations;\r\n}\r\nreturn true;\r\n}\r\nstatic void DAC960_UnregisterBlockDevice(DAC960_Controller_T *Controller)\r\n{\r\nint MajorNumber = DAC960_MAJOR + Controller->ControllerNumber;\r\nint disk;\r\nfor (disk = 0; disk < DAC960_MaxLogicalDrives; disk++) {\r\ndel_gendisk(Controller->disks[disk]);\r\nblk_cleanup_queue(Controller->RequestQueue[disk]);\r\nController->RequestQueue[disk] = NULL;\r\n}\r\nunregister_blkdev(MajorNumber, "dac960");\r\n}\r\nstatic void DAC960_ComputeGenericDiskInfo(DAC960_Controller_T *Controller)\r\n{\r\nint disk;\r\nfor (disk = 0; disk < DAC960_MaxLogicalDrives; disk++)\r\nset_capacity(Controller->disks[disk], disk_size(Controller, disk));\r\n}\r\nstatic bool DAC960_ReportErrorStatus(DAC960_Controller_T *Controller,\r\nunsigned char ErrorStatus,\r\nunsigned char Parameter0,\r\nunsigned char Parameter1)\r\n{\r\nswitch (ErrorStatus)\r\n{\r\ncase 0x00:\r\nDAC960_Notice("Physical Device %d:%d Not Responding\n",\r\nController, Parameter1, Parameter0);\r\nbreak;\r\ncase 0x08:\r\nif (Controller->DriveSpinUpMessageDisplayed) break;\r\nDAC960_Notice("Spinning Up Drives\n", Controller);\r\nController->DriveSpinUpMessageDisplayed = true;\r\nbreak;\r\ncase 0x30:\r\nDAC960_Notice("Configuration Checksum Error\n", Controller);\r\nbreak;\r\ncase 0x60:\r\nDAC960_Notice("Mirror Race Recovery Failed\n", Controller);\r\nbreak;\r\ncase 0x70:\r\nDAC960_Notice("Mirror Race Recovery In Progress\n", Controller);\r\nbreak;\r\ncase 0x90:\r\nDAC960_Notice("Physical Device %d:%d COD Mismatch\n",\r\nController, Parameter1, Parameter0);\r\nbreak;\r\ncase 0xA0:\r\nDAC960_Notice("Logical Drive Installation Aborted\n", Controller);\r\nbreak;\r\ncase 0xB0:\r\nDAC960_Notice("Mirror Race On A Critical Logical Drive\n", Controller);\r\nbreak;\r\ncase 0xD0:\r\nDAC960_Notice("New Controller Configuration Found\n", Controller);\r\nbreak;\r\ncase 0xF0:\r\nDAC960_Error("Fatal Memory Parity Error for Controller at\n", Controller);\r\nreturn true;\r\ndefault:\r\nDAC960_Error("Unknown Initialization Error %02X for Controller at\n",\r\nController, ErrorStatus);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void DAC960_DetectCleanup(DAC960_Controller_T *Controller)\r\n{\r\nint i;\r\nfree_dma_loaf(Controller->PCIDevice, &Controller->DmaPages);\r\nif (Controller->MemoryMappedAddress) {\r\nswitch(Controller->HardwareType)\r\n{\r\ncase DAC960_GEM_Controller:\r\nDAC960_GEM_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\ncase DAC960_BA_Controller:\r\nDAC960_BA_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\ncase DAC960_LP_Controller:\r\nDAC960_LP_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\ncase DAC960_LA_Controller:\r\nDAC960_LA_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\ncase DAC960_PG_Controller:\r\nDAC960_PG_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\ncase DAC960_PD_Controller:\r\nDAC960_PD_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\ncase DAC960_P_Controller:\r\nDAC960_PD_DisableInterrupts(Controller->BaseAddress);\r\nbreak;\r\n}\r\niounmap(Controller->MemoryMappedAddress);\r\n}\r\nif (Controller->IRQ_Channel)\r\nfree_irq(Controller->IRQ_Channel, Controller);\r\nif (Controller->IO_Address)\r\nrelease_region(Controller->IO_Address, 0x80);\r\npci_disable_device(Controller->PCIDevice);\r\nfor (i = 0; (i < DAC960_MaxLogicalDrives) && Controller->disks[i]; i++)\r\nput_disk(Controller->disks[i]);\r\nDAC960_Controllers[Controller->ControllerNumber] = NULL;\r\nkfree(Controller);\r\n}\r\nstatic DAC960_Controller_T *\r\nDAC960_DetectController(struct pci_dev *PCI_Device,\r\nconst struct pci_device_id *entry)\r\n{\r\nstruct DAC960_privdata *privdata =\r\n(struct DAC960_privdata *)entry->driver_data;\r\nirq_handler_t InterruptHandler = privdata->InterruptHandler;\r\nunsigned int MemoryWindowSize = privdata->MemoryWindowSize;\r\nDAC960_Controller_T *Controller = NULL;\r\nunsigned char DeviceFunction = PCI_Device->devfn;\r\nunsigned char ErrorStatus, Parameter0, Parameter1;\r\nunsigned int IRQ_Channel;\r\nvoid __iomem *BaseAddress;\r\nint i;\r\nController = kzalloc(sizeof(DAC960_Controller_T), GFP_ATOMIC);\r\nif (Controller == NULL) {\r\nDAC960_Error("Unable to allocate Controller structure for "\r\n"Controller at\n", NULL);\r\nreturn NULL;\r\n}\r\nController->ControllerNumber = DAC960_ControllerCount;\r\nDAC960_Controllers[DAC960_ControllerCount++] = Controller;\r\nController->Bus = PCI_Device->bus->number;\r\nController->FirmwareType = privdata->FirmwareType;\r\nController->HardwareType = privdata->HardwareType;\r\nController->Device = DeviceFunction >> 3;\r\nController->Function = DeviceFunction & 0x7;\r\nController->PCIDevice = PCI_Device;\r\nstrcpy(Controller->FullModelName, "DAC960");\r\nif (pci_enable_device(PCI_Device))\r\ngoto Failure;\r\nswitch (Controller->HardwareType)\r\n{\r\ncase DAC960_GEM_Controller:\r\nController->PCI_Address = pci_resource_start(PCI_Device, 0);\r\nbreak;\r\ncase DAC960_BA_Controller:\r\nController->PCI_Address = pci_resource_start(PCI_Device, 0);\r\nbreak;\r\ncase DAC960_LP_Controller:\r\nController->PCI_Address = pci_resource_start(PCI_Device, 0);\r\nbreak;\r\ncase DAC960_LA_Controller:\r\nController->PCI_Address = pci_resource_start(PCI_Device, 0);\r\nbreak;\r\ncase DAC960_PG_Controller:\r\nController->PCI_Address = pci_resource_start(PCI_Device, 0);\r\nbreak;\r\ncase DAC960_PD_Controller:\r\nController->IO_Address = pci_resource_start(PCI_Device, 0);\r\nController->PCI_Address = pci_resource_start(PCI_Device, 1);\r\nbreak;\r\ncase DAC960_P_Controller:\r\nController->IO_Address = pci_resource_start(PCI_Device, 0);\r\nController->PCI_Address = pci_resource_start(PCI_Device, 1);\r\nbreak;\r\n}\r\npci_set_drvdata(PCI_Device, (void *)((long)Controller->ControllerNumber));\r\nfor (i = 0; i < DAC960_MaxLogicalDrives; i++) {\r\nController->disks[i] = alloc_disk(1<<DAC960_MaxPartitionsBits);\r\nif (!Controller->disks[i])\r\ngoto Failure;\r\nController->disks[i]->private_data = (void *)((long)i);\r\n}\r\ninit_waitqueue_head(&Controller->CommandWaitQueue);\r\ninit_waitqueue_head(&Controller->HealthStatusWaitQueue);\r\nspin_lock_init(&Controller->queue_lock);\r\nDAC960_AnnounceDriver(Controller);\r\nif (MemoryWindowSize < PAGE_SIZE)\r\nMemoryWindowSize = PAGE_SIZE;\r\nController->MemoryMappedAddress =\r\nioremap_nocache(Controller->PCI_Address & PAGE_MASK, MemoryWindowSize);\r\nController->BaseAddress =\r\nController->MemoryMappedAddress + (Controller->PCI_Address & ~PAGE_MASK);\r\nif (Controller->MemoryMappedAddress == NULL)\r\n{\r\nDAC960_Error("Unable to map Controller Register Window for "\r\n"Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nBaseAddress = Controller->BaseAddress;\r\nswitch (Controller->HardwareType)\r\n{\r\ncase DAC960_GEM_Controller:\r\nDAC960_GEM_DisableInterrupts(BaseAddress);\r\nDAC960_GEM_AcknowledgeHardwareMailboxStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_GEM_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_GEM_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V2_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to Enable Memory Mailbox Interface "\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_GEM_EnableInterrupts(BaseAddress);\r\nController->QueueCommand = DAC960_GEM_QueueCommand;\r\nController->ReadControllerConfiguration =\r\nDAC960_V2_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V2_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V2_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V2_QueueReadWriteCommand;\r\nbreak;\r\ncase DAC960_BA_Controller:\r\nDAC960_BA_DisableInterrupts(BaseAddress);\r\nDAC960_BA_AcknowledgeHardwareMailboxStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_BA_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_BA_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V2_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to Enable Memory Mailbox Interface "\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_BA_EnableInterrupts(BaseAddress);\r\nController->QueueCommand = DAC960_BA_QueueCommand;\r\nController->ReadControllerConfiguration =\r\nDAC960_V2_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V2_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V2_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V2_QueueReadWriteCommand;\r\nbreak;\r\ncase DAC960_LP_Controller:\r\nDAC960_LP_DisableInterrupts(BaseAddress);\r\nDAC960_LP_AcknowledgeHardwareMailboxStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_LP_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_LP_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V2_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to Enable Memory Mailbox Interface "\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_LP_EnableInterrupts(BaseAddress);\r\nController->QueueCommand = DAC960_LP_QueueCommand;\r\nController->ReadControllerConfiguration =\r\nDAC960_V2_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V2_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V2_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V2_QueueReadWriteCommand;\r\nbreak;\r\ncase DAC960_LA_Controller:\r\nDAC960_LA_DisableInterrupts(BaseAddress);\r\nDAC960_LA_AcknowledgeHardwareMailboxStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_LA_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_LA_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V1_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to Enable Memory Mailbox Interface "\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_LA_EnableInterrupts(BaseAddress);\r\nif (Controller->V1.DualModeMemoryMailboxInterface)\r\nController->QueueCommand = DAC960_LA_QueueCommandDualMode;\r\nelse Controller->QueueCommand = DAC960_LA_QueueCommandSingleMode;\r\nController->ReadControllerConfiguration =\r\nDAC960_V1_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V1_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V1_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V1_QueueReadWriteCommand;\r\nbreak;\r\ncase DAC960_PG_Controller:\r\nDAC960_PG_DisableInterrupts(BaseAddress);\r\nDAC960_PG_AcknowledgeHardwareMailboxStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_PG_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_PG_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V1_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to Enable Memory Mailbox Interface "\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_PG_EnableInterrupts(BaseAddress);\r\nif (Controller->V1.DualModeMemoryMailboxInterface)\r\nController->QueueCommand = DAC960_PG_QueueCommandDualMode;\r\nelse Controller->QueueCommand = DAC960_PG_QueueCommandSingleMode;\r\nController->ReadControllerConfiguration =\r\nDAC960_V1_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V1_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V1_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V1_QueueReadWriteCommand;\r\nbreak;\r\ncase DAC960_PD_Controller:\r\nif (!request_region(Controller->IO_Address, 0x80,\r\nController->FullModelName)) {\r\nDAC960_Error("IO port 0x%d busy for Controller at\n",\r\nController, Controller->IO_Address);\r\ngoto Failure;\r\n}\r\nDAC960_PD_DisableInterrupts(BaseAddress);\r\nDAC960_PD_AcknowledgeStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_PD_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V1_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to allocate DMA mapped memory "\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_PD_EnableInterrupts(BaseAddress);\r\nController->QueueCommand = DAC960_PD_QueueCommand;\r\nController->ReadControllerConfiguration =\r\nDAC960_V1_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V1_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V1_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V1_QueueReadWriteCommand;\r\nbreak;\r\ncase DAC960_P_Controller:\r\nif (!request_region(Controller->IO_Address, 0x80,\r\nController->FullModelName)){\r\nDAC960_Error("IO port 0x%d busy for Controller at\n",\r\nController, Controller->IO_Address);\r\ngoto Failure;\r\n}\r\nDAC960_PD_DisableInterrupts(BaseAddress);\r\nDAC960_PD_AcknowledgeStatus(BaseAddress);\r\nudelay(1000);\r\nwhile (DAC960_PD_InitializationInProgressP(BaseAddress))\r\n{\r\nif (DAC960_PD_ReadErrorStatus(BaseAddress, &ErrorStatus,\r\n&Parameter0, &Parameter1) &&\r\nDAC960_ReportErrorStatus(Controller, ErrorStatus,\r\nParameter0, Parameter1))\r\ngoto Failure;\r\nudelay(10);\r\n}\r\nif (!DAC960_V1_EnableMemoryMailboxInterface(Controller))\r\n{\r\nDAC960_Error("Unable to allocate DMA mapped memory"\r\n"for Controller at\n", Controller);\r\ngoto Failure;\r\n}\r\nDAC960_PD_EnableInterrupts(BaseAddress);\r\nController->QueueCommand = DAC960_P_QueueCommand;\r\nController->ReadControllerConfiguration =\r\nDAC960_V1_ReadControllerConfiguration;\r\nController->ReadDeviceConfiguration =\r\nDAC960_V1_ReadDeviceConfiguration;\r\nController->ReportDeviceConfiguration =\r\nDAC960_V1_ReportDeviceConfiguration;\r\nController->QueueReadWriteCommand =\r\nDAC960_V1_QueueReadWriteCommand;\r\nbreak;\r\n}\r\nIRQ_Channel = PCI_Device->irq;\r\nif (request_irq(IRQ_Channel, InterruptHandler, IRQF_SHARED,\r\nController->FullModelName, Controller) < 0)\r\n{\r\nDAC960_Error("Unable to acquire IRQ Channel %d for Controller at\n",\r\nController, Controller->IRQ_Channel);\r\ngoto Failure;\r\n}\r\nController->IRQ_Channel = IRQ_Channel;\r\nController->InitialCommand.CommandIdentifier = 1;\r\nController->InitialCommand.Controller = Controller;\r\nController->Commands[0] = &Controller->InitialCommand;\r\nController->FreeCommands = &Controller->InitialCommand;\r\nreturn Controller;\r\nFailure:\r\nif (Controller->IO_Address == 0)\r\nDAC960_Error("PCI Bus %d Device %d Function %d I/O Address N/A "\r\n"PCI Address 0x%X\n", Controller,\r\nController->Bus, Controller->Device,\r\nController->Function, Controller->PCI_Address);\r\nelse\r\nDAC960_Error("PCI Bus %d Device %d Function %d I/O Address "\r\n"0x%X PCI Address 0x%X\n", Controller,\r\nController->Bus, Controller->Device,\r\nController->Function, Controller->IO_Address,\r\nController->PCI_Address);\r\nDAC960_DetectCleanup(Controller);\r\nDAC960_ControllerCount--;\r\nreturn NULL;\r\n}\r\nstatic bool\r\nDAC960_InitializeController(DAC960_Controller_T *Controller)\r\n{\r\nif (DAC960_ReadControllerConfiguration(Controller) &&\r\nDAC960_ReportControllerConfiguration(Controller) &&\r\nDAC960_CreateAuxiliaryStructures(Controller) &&\r\nDAC960_ReadDeviceConfiguration(Controller) &&\r\nDAC960_ReportDeviceConfiguration(Controller) &&\r\nDAC960_RegisterBlockDevice(Controller))\r\n{\r\ninit_timer(&Controller->MonitoringTimer);\r\nController->MonitoringTimer.expires =\r\njiffies + DAC960_MonitoringTimerInterval;\r\nController->MonitoringTimer.data = (unsigned long) Controller;\r\nController->MonitoringTimer.function = DAC960_MonitoringTimerFunction;\r\nadd_timer(&Controller->MonitoringTimer);\r\nController->ControllerInitialized = true;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void DAC960_FinalizeController(DAC960_Controller_T *Controller)\r\n{\r\nif (Controller->ControllerInitialized)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nController->ShutdownMonitoringTimer = 1;\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\ndel_timer_sync(&Controller->MonitoringTimer);\r\nif (Controller->FirmwareType == DAC960_V1_Controller)\r\n{\r\nDAC960_Notice("Flushing Cache...", Controller);\r\nDAC960_V1_ExecuteType3(Controller, DAC960_V1_Flush, 0);\r\nDAC960_Notice("done\n", Controller);\r\nif (Controller->HardwareType == DAC960_PD_Controller)\r\nrelease_region(Controller->IO_Address, 0x80);\r\n}\r\nelse\r\n{\r\nDAC960_Notice("Flushing Cache...", Controller);\r\nDAC960_V2_DeviceOperation(Controller, DAC960_V2_PauseDevice,\r\nDAC960_V2_RAID_Controller);\r\nDAC960_Notice("done\n", Controller);\r\n}\r\n}\r\nDAC960_UnregisterBlockDevice(Controller);\r\nDAC960_DestroyAuxiliaryStructures(Controller);\r\nDAC960_DestroyProcEntries(Controller);\r\nDAC960_DetectCleanup(Controller);\r\n}\r\nstatic int\r\nDAC960_Probe(struct pci_dev *dev, const struct pci_device_id *entry)\r\n{\r\nint disk;\r\nDAC960_Controller_T *Controller;\r\nif (DAC960_ControllerCount == DAC960_MaxControllers)\r\n{\r\nDAC960_Error("More than %d DAC960 Controllers detected - "\r\n"ignoring from Controller at\n",\r\nNULL, DAC960_MaxControllers);\r\nreturn -ENODEV;\r\n}\r\nController = DAC960_DetectController(dev, entry);\r\nif (!Controller)\r\nreturn -ENODEV;\r\nif (!DAC960_InitializeController(Controller)) {\r\nDAC960_FinalizeController(Controller);\r\nreturn -ENODEV;\r\n}\r\nfor (disk = 0; disk < DAC960_MaxLogicalDrives; disk++) {\r\nset_capacity(Controller->disks[disk], disk_size(Controller, disk));\r\nadd_disk(Controller->disks[disk]);\r\n}\r\nDAC960_CreateProcEntries(Controller);\r\nreturn 0;\r\n}\r\nstatic void DAC960_Remove(struct pci_dev *PCI_Device)\r\n{\r\nint Controller_Number = (long)pci_get_drvdata(PCI_Device);\r\nDAC960_Controller_T *Controller = DAC960_Controllers[Controller_Number];\r\nif (Controller != NULL)\r\nDAC960_FinalizeController(Controller);\r\n}\r\nstatic void DAC960_V1_QueueReadWriteCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_ScatterGatherSegment_T *ScatterGatherList =\r\nCommand->V1.ScatterGatherList;\r\nstruct scatterlist *ScatterList = Command->V1.ScatterList;\r\nDAC960_V1_ClearCommand(Command);\r\nif (Command->SegmentCount == 1)\r\n{\r\nif (Command->DmaDirection == PCI_DMA_FROMDEVICE)\r\nCommandMailbox->Type5.CommandOpcode = DAC960_V1_Read;\r\nelse\r\nCommandMailbox->Type5.CommandOpcode = DAC960_V1_Write;\r\nCommandMailbox->Type5.LD.TransferLength = Command->BlockCount;\r\nCommandMailbox->Type5.LD.LogicalDriveNumber = Command->LogicalDriveNumber;\r\nCommandMailbox->Type5.LogicalBlockAddress = Command->BlockNumber;\r\nCommandMailbox->Type5.BusAddress =\r\n(DAC960_BusAddress32_T)sg_dma_address(ScatterList);\r\n}\r\nelse\r\n{\r\nint i;\r\nif (Command->DmaDirection == PCI_DMA_FROMDEVICE)\r\nCommandMailbox->Type5.CommandOpcode = DAC960_V1_ReadWithScatterGather;\r\nelse\r\nCommandMailbox->Type5.CommandOpcode = DAC960_V1_WriteWithScatterGather;\r\nCommandMailbox->Type5.LD.TransferLength = Command->BlockCount;\r\nCommandMailbox->Type5.LD.LogicalDriveNumber = Command->LogicalDriveNumber;\r\nCommandMailbox->Type5.LogicalBlockAddress = Command->BlockNumber;\r\nCommandMailbox->Type5.BusAddress = Command->V1.ScatterGatherListDMA;\r\nCommandMailbox->Type5.ScatterGatherCount = Command->SegmentCount;\r\nfor (i = 0; i < Command->SegmentCount; i++, ScatterList++, ScatterGatherList++) {\r\nScatterGatherList->SegmentDataPointer =\r\n(DAC960_BusAddress32_T)sg_dma_address(ScatterList);\r\nScatterGatherList->SegmentByteCount =\r\n(DAC960_ByteCount32_T)sg_dma_len(ScatterList);\r\n}\r\n}\r\nDAC960_QueueCommand(Command);\r\n}\r\nstatic void DAC960_V2_QueueReadWriteCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nstruct scatterlist *ScatterList = Command->V2.ScatterList;\r\nDAC960_V2_ClearCommand(Command);\r\nCommandMailbox->SCSI_10.CommandOpcode = DAC960_V2_SCSI_10;\r\nCommandMailbox->SCSI_10.CommandControlBits.DataTransferControllerToHost =\r\n(Command->DmaDirection == PCI_DMA_FROMDEVICE);\r\nCommandMailbox->SCSI_10.DataTransferSize =\r\nCommand->BlockCount << DAC960_BlockSizeBits;\r\nCommandMailbox->SCSI_10.RequestSenseBusAddress = Command->V2.RequestSenseDMA;\r\nCommandMailbox->SCSI_10.PhysicalDevice =\r\nController->V2.LogicalDriveToVirtualDevice[Command->LogicalDriveNumber];\r\nCommandMailbox->SCSI_10.RequestSenseSize = sizeof(DAC960_SCSI_RequestSense_T);\r\nCommandMailbox->SCSI_10.CDBLength = 10;\r\nCommandMailbox->SCSI_10.SCSI_CDB[0] =\r\n(Command->DmaDirection == PCI_DMA_FROMDEVICE ? 0x28 : 0x2A);\r\nCommandMailbox->SCSI_10.SCSI_CDB[2] = Command->BlockNumber >> 24;\r\nCommandMailbox->SCSI_10.SCSI_CDB[3] = Command->BlockNumber >> 16;\r\nCommandMailbox->SCSI_10.SCSI_CDB[4] = Command->BlockNumber >> 8;\r\nCommandMailbox->SCSI_10.SCSI_CDB[5] = Command->BlockNumber;\r\nCommandMailbox->SCSI_10.SCSI_CDB[7] = Command->BlockCount >> 8;\r\nCommandMailbox->SCSI_10.SCSI_CDB[8] = Command->BlockCount;\r\nif (Command->SegmentCount == 1)\r\n{\r\nCommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\n(DAC960_BusAddress64_T)sg_dma_address(ScatterList);\r\nCommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->SCSI_10.DataTransferSize;\r\n}\r\nelse\r\n{\r\nDAC960_V2_ScatterGatherSegment_T *ScatterGatherList;\r\nint i;\r\nif (Command->SegmentCount > 2)\r\n{\r\nScatterGatherList = Command->V2.ScatterGatherList;\r\nCommandMailbox->SCSI_10.CommandControlBits\r\n.AdditionalScatterGatherListMemory = true;\r\nCommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ExtendedScatterGather.ScatterGatherList0Length = Command->SegmentCount;\r\nCommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ExtendedScatterGather.ScatterGatherList0Address =\r\nCommand->V2.ScatterGatherListDMA;\r\n}\r\nelse\r\nScatterGatherList = CommandMailbox->SCSI_10.DataTransferMemoryAddress\r\n.ScatterGatherSegments;\r\nfor (i = 0; i < Command->SegmentCount; i++, ScatterList++, ScatterGatherList++) {\r\nScatterGatherList->SegmentDataPointer =\r\n(DAC960_BusAddress64_T)sg_dma_address(ScatterList);\r\nScatterGatherList->SegmentByteCount =\r\n(DAC960_ByteCount64_T)sg_dma_len(ScatterList);\r\n}\r\n}\r\nDAC960_QueueCommand(Command);\r\n}\r\nstatic int DAC960_process_queue(DAC960_Controller_T *Controller, struct request_queue *req_q)\r\n{\r\nstruct request *Request;\r\nDAC960_Command_T *Command;\r\nwhile(1) {\r\nRequest = blk_peek_request(req_q);\r\nif (!Request)\r\nreturn 1;\r\nCommand = DAC960_AllocateCommand(Controller);\r\nif (Command == NULL)\r\nreturn 0;\r\nif (rq_data_dir(Request) == READ) {\r\nCommand->DmaDirection = PCI_DMA_FROMDEVICE;\r\nCommand->CommandType = DAC960_ReadCommand;\r\n} else {\r\nCommand->DmaDirection = PCI_DMA_TODEVICE;\r\nCommand->CommandType = DAC960_WriteCommand;\r\n}\r\nCommand->Completion = Request->end_io_data;\r\nCommand->LogicalDriveNumber = (long)Request->rq_disk->private_data;\r\nCommand->BlockNumber = blk_rq_pos(Request);\r\nCommand->BlockCount = blk_rq_sectors(Request);\r\nCommand->Request = Request;\r\nblk_start_request(Request);\r\nCommand->SegmentCount = blk_rq_map_sg(req_q,\r\nCommand->Request, Command->cmd_sglist);\r\nCommand->SegmentCount = pci_map_sg(Controller->PCIDevice, Command->cmd_sglist,\r\nCommand->SegmentCount, Command->DmaDirection);\r\nDAC960_QueueReadWriteCommand(Command);\r\n}\r\n}\r\nstatic void DAC960_ProcessRequest(DAC960_Controller_T *controller)\r\n{\r\nint i;\r\nif (!controller->ControllerInitialized)\r\nreturn;\r\nfor (i = controller->req_q_index; i < DAC960_MaxLogicalDrives; i++) {\r\nstruct request_queue *req_q = controller->RequestQueue[i];\r\nif (req_q == NULL)\r\ncontinue;\r\nif (!DAC960_process_queue(controller, req_q)) {\r\ncontroller->req_q_index = i;\r\nreturn;\r\n}\r\n}\r\nif (controller->req_q_index == 0)\r\nreturn;\r\nfor (i = 0; i < controller->req_q_index; i++) {\r\nstruct request_queue *req_q = controller->RequestQueue[i];\r\nif (req_q == NULL)\r\ncontinue;\r\nif (!DAC960_process_queue(controller, req_q)) {\r\ncontroller->req_q_index = i;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void DAC960_queue_partial_rw(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nstruct request *Request = Command->Request;\r\nstruct request_queue *req_q = Controller->RequestQueue[Command->LogicalDriveNumber];\r\nif (Command->DmaDirection == PCI_DMA_FROMDEVICE)\r\nCommand->CommandType = DAC960_ReadRetryCommand;\r\nelse\r\nCommand->CommandType = DAC960_WriteRetryCommand;\r\n(void)blk_rq_map_sg(req_q, Command->Request, Command->cmd_sglist);\r\n(void)pci_map_sg(Controller->PCIDevice, Command->cmd_sglist, 1, Command->DmaDirection);\r\nCommand->SegmentCount = 1;\r\nCommand->BlockNumber = blk_rq_pos(Request);\r\nCommand->BlockCount = 1;\r\nDAC960_QueueReadWriteCommand(Command);\r\nreturn;\r\n}\r\nstatic void DAC960_RequestFunction(struct request_queue *RequestQueue)\r\n{\r\nDAC960_ProcessRequest(RequestQueue->queuedata);\r\n}\r\nstatic inline bool DAC960_ProcessCompletedRequest(DAC960_Command_T *Command,\r\nbool SuccessfulIO)\r\n{\r\nstruct request *Request = Command->Request;\r\nint Error = SuccessfulIO ? 0 : -EIO;\r\npci_unmap_sg(Command->Controller->PCIDevice, Command->cmd_sglist,\r\nCommand->SegmentCount, Command->DmaDirection);\r\nif (!__blk_end_request(Request, Error, Command->BlockCount << 9)) {\r\nif (Command->Completion) {\r\ncomplete(Command->Completion);\r\nCommand->Completion = NULL;\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void DAC960_V1_ReadWriteError(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nunsigned char *CommandName = "UNKNOWN";\r\nswitch (Command->CommandType)\r\n{\r\ncase DAC960_ReadCommand:\r\ncase DAC960_ReadRetryCommand:\r\nCommandName = "READ";\r\nbreak;\r\ncase DAC960_WriteCommand:\r\ncase DAC960_WriteRetryCommand:\r\nCommandName = "WRITE";\r\nbreak;\r\ncase DAC960_MonitoringCommand:\r\ncase DAC960_ImmediateCommand:\r\ncase DAC960_QueuedCommand:\r\nbreak;\r\n}\r\nswitch (Command->V1.CommandStatus)\r\n{\r\ncase DAC960_V1_IrrecoverableDataError:\r\nDAC960_Error("Irrecoverable Data Error on %s:\n",\r\nController, CommandName);\r\nbreak;\r\ncase DAC960_V1_LogicalDriveNonexistentOrOffline:\r\nDAC960_Error("Logical Drive Nonexistent or Offline on %s:\n",\r\nController, CommandName);\r\nbreak;\r\ncase DAC960_V1_AccessBeyondEndOfLogicalDrive:\r\nDAC960_Error("Attempt to Access Beyond End of Logical Drive "\r\n"on %s:\n", Controller, CommandName);\r\nbreak;\r\ncase DAC960_V1_BadDataEncountered:\r\nDAC960_Error("Bad Data Encountered on %s:\n", Controller, CommandName);\r\nbreak;\r\ndefault:\r\nDAC960_Error("Unexpected Error Status %04X on %s:\n",\r\nController, Command->V1.CommandStatus, CommandName);\r\nbreak;\r\n}\r\nDAC960_Error(" /dev/rd/c%dd%d: absolute blocks %u..%u\n",\r\nController, Controller->ControllerNumber,\r\nCommand->LogicalDriveNumber, Command->BlockNumber,\r\nCommand->BlockNumber + Command->BlockCount - 1);\r\n}\r\nstatic void DAC960_V1_ProcessCompletedCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDAC960_CommandType_T CommandType = Command->CommandType;\r\nDAC960_V1_CommandOpcode_T CommandOpcode =\r\nCommand->V1.CommandMailbox.Common.CommandOpcode;\r\nDAC960_V1_CommandStatus_T CommandStatus = Command->V1.CommandStatus;\r\nif (CommandType == DAC960_ReadCommand ||\r\nCommandType == DAC960_WriteCommand)\r\n{\r\n#ifdef FORCE_RETRY_DEBUG\r\nCommandStatus = DAC960_V1_IrrecoverableDataError;\r\n#endif\r\nif (CommandStatus == DAC960_V1_NormalCompletion) {\r\nif (!DAC960_ProcessCompletedRequest(Command, true))\r\nBUG();\r\n} else if (CommandStatus == DAC960_V1_IrrecoverableDataError ||\r\nCommandStatus == DAC960_V1_BadDataEncountered)\r\n{\r\nDAC960_queue_partial_rw(Command);\r\nreturn;\r\n}\r\nelse\r\n{\r\nif (CommandStatus != DAC960_V1_LogicalDriveNonexistentOrOffline)\r\nDAC960_V1_ReadWriteError(Command);\r\nif (!DAC960_ProcessCompletedRequest(Command, false))\r\nBUG();\r\n}\r\n}\r\nelse if (CommandType == DAC960_ReadRetryCommand ||\r\nCommandType == DAC960_WriteRetryCommand)\r\n{\r\nbool normal_completion;\r\n#ifdef FORCE_RETRY_FAILURE_DEBUG\r\nstatic int retry_count = 1;\r\n#endif\r\nnormal_completion = true;\r\nif (CommandStatus != DAC960_V1_NormalCompletion) {\r\nnormal_completion = false;\r\nif (CommandStatus != DAC960_V1_LogicalDriveNonexistentOrOffline)\r\nDAC960_V1_ReadWriteError(Command);\r\n}\r\n#ifdef FORCE_RETRY_FAILURE_DEBUG\r\nif (!(++retry_count % 10000)) {\r\nprintk("V1 error retry failure test\n");\r\nnormal_completion = false;\r\nDAC960_V1_ReadWriteError(Command);\r\n}\r\n#endif\r\nif (!DAC960_ProcessCompletedRequest(Command, normal_completion)) {\r\nDAC960_queue_partial_rw(Command);\r\nreturn;\r\n}\r\n}\r\nelse if (CommandType == DAC960_MonitoringCommand)\r\n{\r\nif (Controller->ShutdownMonitoringTimer)\r\nreturn;\r\nif (CommandOpcode == DAC960_V1_Enquiry)\r\n{\r\nDAC960_V1_Enquiry_T *OldEnquiry = &Controller->V1.Enquiry;\r\nDAC960_V1_Enquiry_T *NewEnquiry = Controller->V1.NewEnquiry;\r\nunsigned int OldCriticalLogicalDriveCount =\r\nOldEnquiry->CriticalLogicalDriveCount;\r\nunsigned int NewCriticalLogicalDriveCount =\r\nNewEnquiry->CriticalLogicalDriveCount;\r\nif (NewEnquiry->NumberOfLogicalDrives > Controller->LogicalDriveCount)\r\n{\r\nint LogicalDriveNumber = Controller->LogicalDriveCount - 1;\r\nwhile (++LogicalDriveNumber < NewEnquiry->NumberOfLogicalDrives)\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"Now Exists\n", Controller,\r\nLogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nController->LogicalDriveCount = NewEnquiry->NumberOfLogicalDrives;\r\nDAC960_ComputeGenericDiskInfo(Controller);\r\n}\r\nif (NewEnquiry->NumberOfLogicalDrives < Controller->LogicalDriveCount)\r\n{\r\nint LogicalDriveNumber = NewEnquiry->NumberOfLogicalDrives - 1;\r\nwhile (++LogicalDriveNumber < Controller->LogicalDriveCount)\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"No Longer Exists\n", Controller,\r\nLogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nController->LogicalDriveCount = NewEnquiry->NumberOfLogicalDrives;\r\nDAC960_ComputeGenericDiskInfo(Controller);\r\n}\r\nif (NewEnquiry->StatusFlags.DeferredWriteError !=\r\nOldEnquiry->StatusFlags.DeferredWriteError)\r\nDAC960_Critical("Deferred Write Error Flag is now %s\n", Controller,\r\n(NewEnquiry->StatusFlags.DeferredWriteError\r\n? "TRUE" : "FALSE"));\r\nif ((NewCriticalLogicalDriveCount > 0 ||\r\nNewCriticalLogicalDriveCount != OldCriticalLogicalDriveCount) ||\r\n(NewEnquiry->OfflineLogicalDriveCount > 0 ||\r\nNewEnquiry->OfflineLogicalDriveCount !=\r\nOldEnquiry->OfflineLogicalDriveCount) ||\r\n(NewEnquiry->DeadDriveCount > 0 ||\r\nNewEnquiry->DeadDriveCount !=\r\nOldEnquiry->DeadDriveCount) ||\r\n(NewEnquiry->EventLogSequenceNumber !=\r\nOldEnquiry->EventLogSequenceNumber) ||\r\nController->MonitoringTimerCount == 0 ||\r\ntime_after_eq(jiffies, Controller->SecondaryMonitoringTime\r\n+ DAC960_SecondaryMonitoringInterval))\r\n{\r\nController->V1.NeedLogicalDriveInformation = true;\r\nController->V1.NewEventLogSequenceNumber =\r\nNewEnquiry->EventLogSequenceNumber;\r\nController->V1.NeedErrorTableInformation = true;\r\nController->V1.NeedDeviceStateInformation = true;\r\nController->V1.StartDeviceStateScan = true;\r\nController->V1.NeedBackgroundInitializationStatus =\r\nController->V1.BackgroundInitializationStatusSupported;\r\nController->SecondaryMonitoringTime = jiffies;\r\n}\r\nif (NewEnquiry->RebuildFlag == DAC960_V1_StandbyRebuildInProgress ||\r\nNewEnquiry->RebuildFlag\r\n== DAC960_V1_BackgroundRebuildInProgress ||\r\nOldEnquiry->RebuildFlag == DAC960_V1_StandbyRebuildInProgress ||\r\nOldEnquiry->RebuildFlag == DAC960_V1_BackgroundRebuildInProgress)\r\n{\r\nController->V1.NeedRebuildProgress = true;\r\nController->V1.RebuildProgressFirst =\r\n(NewEnquiry->CriticalLogicalDriveCount <\r\nOldEnquiry->CriticalLogicalDriveCount);\r\n}\r\nif (OldEnquiry->RebuildFlag == DAC960_V1_BackgroundCheckInProgress)\r\nswitch (NewEnquiry->RebuildFlag)\r\n{\r\ncase DAC960_V1_NoStandbyRebuildOrCheckInProgress:\r\nDAC960_Progress("Consistency Check Completed Successfully\n",\r\nController);\r\nbreak;\r\ncase DAC960_V1_StandbyRebuildInProgress:\r\ncase DAC960_V1_BackgroundRebuildInProgress:\r\nbreak;\r\ncase DAC960_V1_BackgroundCheckInProgress:\r\nController->V1.NeedConsistencyCheckProgress = true;\r\nbreak;\r\ncase DAC960_V1_StandbyRebuildCompletedWithError:\r\nDAC960_Progress("Consistency Check Completed with Error\n",\r\nController);\r\nbreak;\r\ncase DAC960_V1_BackgroundRebuildOrCheckFailed_DriveFailed:\r\nDAC960_Progress("Consistency Check Failed - "\r\n"Physical Device Failed\n", Controller);\r\nbreak;\r\ncase DAC960_V1_BackgroundRebuildOrCheckFailed_LogicalDriveFailed:\r\nDAC960_Progress("Consistency Check Failed - "\r\n"Logical Drive Failed\n", Controller);\r\nbreak;\r\ncase DAC960_V1_BackgroundRebuildOrCheckFailed_OtherCauses:\r\nDAC960_Progress("Consistency Check Failed - Other Causes\n",\r\nController);\r\nbreak;\r\ncase DAC960_V1_BackgroundRebuildOrCheckSuccessfullyTerminated:\r\nDAC960_Progress("Consistency Check Successfully Terminated\n",\r\nController);\r\nbreak;\r\n}\r\nelse if (NewEnquiry->RebuildFlag\r\n== DAC960_V1_BackgroundCheckInProgress)\r\nController->V1.NeedConsistencyCheckProgress = true;\r\nController->MonitoringAlertMode =\r\n(NewEnquiry->CriticalLogicalDriveCount > 0 ||\r\nNewEnquiry->OfflineLogicalDriveCount > 0 ||\r\nNewEnquiry->DeadDriveCount > 0);\r\nif (NewEnquiry->RebuildFlag > DAC960_V1_BackgroundCheckInProgress)\r\n{\r\nController->V1.PendingRebuildFlag = NewEnquiry->RebuildFlag;\r\nController->V1.RebuildFlagPending = true;\r\n}\r\nmemcpy(&Controller->V1.Enquiry, &Controller->V1.NewEnquiry,\r\nsizeof(DAC960_V1_Enquiry_T));\r\n}\r\nelse if (CommandOpcode == DAC960_V1_PerformEventLogOperation)\r\n{\r\nstatic char\r\n*DAC960_EventMessages[] =\r\n{ "killed because write recovery failed",\r\n"killed because of SCSI bus reset failure",\r\n"killed because of double check condition",\r\n"killed because it was removed",\r\n"killed because of gross error on SCSI chip",\r\n"killed because of bad tag returned from drive",\r\n"killed because of timeout on SCSI command",\r\n"killed because of reset SCSI command issued from system",\r\n"killed because busy or parity error count exceeded limit",\r\n"killed because of 'kill drive' command from system",\r\n"killed because of selection timeout",\r\n"killed due to SCSI phase sequence error",\r\n"killed due to unknown status" };\r\nDAC960_V1_EventLogEntry_T *EventLogEntry =\r\nController->V1.EventLogEntry;\r\nif (EventLogEntry->SequenceNumber ==\r\nController->V1.OldEventLogSequenceNumber)\r\n{\r\nunsigned char SenseKey = EventLogEntry->SenseKey;\r\nunsigned char AdditionalSenseCode =\r\nEventLogEntry->AdditionalSenseCode;\r\nunsigned char AdditionalSenseCodeQualifier =\r\nEventLogEntry->AdditionalSenseCodeQualifier;\r\nif (SenseKey == DAC960_SenseKey_VendorSpecific &&\r\nAdditionalSenseCode == 0x80 &&\r\nAdditionalSenseCodeQualifier <\r\nARRAY_SIZE(DAC960_EventMessages))\r\nDAC960_Critical("Physical Device %d:%d %s\n", Controller,\r\nEventLogEntry->Channel,\r\nEventLogEntry->TargetID,\r\nDAC960_EventMessages[\r\nAdditionalSenseCodeQualifier]);\r\nelse if (SenseKey == DAC960_SenseKey_UnitAttention &&\r\nAdditionalSenseCode == 0x29)\r\n{\r\nif (Controller->MonitoringTimerCount > 0)\r\nController->V1.DeviceResetCount[EventLogEntry->Channel]\r\n[EventLogEntry->TargetID]++;\r\n}\r\nelse if (!(SenseKey == DAC960_SenseKey_NoSense ||\r\n(SenseKey == DAC960_SenseKey_NotReady &&\r\nAdditionalSenseCode == 0x04 &&\r\n(AdditionalSenseCodeQualifier == 0x01 ||\r\nAdditionalSenseCodeQualifier == 0x02))))\r\n{\r\nDAC960_Critical("Physical Device %d:%d Error Log: "\r\n"Sense Key = %X, ASC = %02X, ASCQ = %02X\n",\r\nController,\r\nEventLogEntry->Channel,\r\nEventLogEntry->TargetID,\r\nSenseKey,\r\nAdditionalSenseCode,\r\nAdditionalSenseCodeQualifier);\r\nDAC960_Critical("Physical Device %d:%d Error Log: "\r\n"Information = %02X%02X%02X%02X "\r\n"%02X%02X%02X%02X\n",\r\nController,\r\nEventLogEntry->Channel,\r\nEventLogEntry->TargetID,\r\nEventLogEntry->Information[0],\r\nEventLogEntry->Information[1],\r\nEventLogEntry->Information[2],\r\nEventLogEntry->Information[3],\r\nEventLogEntry->CommandSpecificInformation[0],\r\nEventLogEntry->CommandSpecificInformation[1],\r\nEventLogEntry->CommandSpecificInformation[2],\r\nEventLogEntry->CommandSpecificInformation[3]);\r\n}\r\n}\r\nController->V1.OldEventLogSequenceNumber++;\r\n}\r\nelse if (CommandOpcode == DAC960_V1_GetErrorTable)\r\n{\r\nDAC960_V1_ErrorTable_T *OldErrorTable = &Controller->V1.ErrorTable;\r\nDAC960_V1_ErrorTable_T *NewErrorTable = Controller->V1.NewErrorTable;\r\nint Channel, TargetID;\r\nfor (Channel = 0; Channel < Controller->Channels; Channel++)\r\nfor (TargetID = 0; TargetID < Controller->Targets; TargetID++)\r\n{\r\nDAC960_V1_ErrorTableEntry_T *NewErrorEntry =\r\n&NewErrorTable->ErrorTableEntries[Channel][TargetID];\r\nDAC960_V1_ErrorTableEntry_T *OldErrorEntry =\r\n&OldErrorTable->ErrorTableEntries[Channel][TargetID];\r\nif ((NewErrorEntry->ParityErrorCount !=\r\nOldErrorEntry->ParityErrorCount) ||\r\n(NewErrorEntry->SoftErrorCount !=\r\nOldErrorEntry->SoftErrorCount) ||\r\n(NewErrorEntry->HardErrorCount !=\r\nOldErrorEntry->HardErrorCount) ||\r\n(NewErrorEntry->MiscErrorCount !=\r\nOldErrorEntry->MiscErrorCount))\r\nDAC960_Critical("Physical Device %d:%d Errors: "\r\n"Parity = %d, Soft = %d, "\r\n"Hard = %d, Misc = %d\n",\r\nController, Channel, TargetID,\r\nNewErrorEntry->ParityErrorCount,\r\nNewErrorEntry->SoftErrorCount,\r\nNewErrorEntry->HardErrorCount,\r\nNewErrorEntry->MiscErrorCount);\r\n}\r\nmemcpy(&Controller->V1.ErrorTable, Controller->V1.NewErrorTable,\r\nsizeof(DAC960_V1_ErrorTable_T));\r\n}\r\nelse if (CommandOpcode == DAC960_V1_GetDeviceState)\r\n{\r\nDAC960_V1_DeviceState_T *OldDeviceState =\r\n&Controller->V1.DeviceState[Controller->V1.DeviceStateChannel]\r\n[Controller->V1.DeviceStateTargetID];\r\nDAC960_V1_DeviceState_T *NewDeviceState =\r\nController->V1.NewDeviceState;\r\nif (NewDeviceState->DeviceState != OldDeviceState->DeviceState)\r\nDAC960_Critical("Physical Device %d:%d is now %s\n", Controller,\r\nController->V1.DeviceStateChannel,\r\nController->V1.DeviceStateTargetID,\r\n(NewDeviceState->DeviceState\r\n== DAC960_V1_Device_Dead\r\n? "DEAD"\r\n: NewDeviceState->DeviceState\r\n== DAC960_V1_Device_WriteOnly\r\n? "WRITE-ONLY"\r\n: NewDeviceState->DeviceState\r\n== DAC960_V1_Device_Online\r\n? "ONLINE" : "STANDBY"));\r\nif (OldDeviceState->DeviceState == DAC960_V1_Device_Dead &&\r\nNewDeviceState->DeviceState != DAC960_V1_Device_Dead)\r\n{\r\nController->V1.NeedDeviceInquiryInformation = true;\r\nController->V1.NeedDeviceSerialNumberInformation = true;\r\nController->V1.DeviceResetCount\r\n[Controller->V1.DeviceStateChannel]\r\n[Controller->V1.DeviceStateTargetID] = 0;\r\n}\r\nmemcpy(OldDeviceState, NewDeviceState,\r\nsizeof(DAC960_V1_DeviceState_T));\r\n}\r\nelse if (CommandOpcode == DAC960_V1_GetLogicalDriveInformation)\r\n{\r\nint LogicalDriveNumber;\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < Controller->LogicalDriveCount;\r\nLogicalDriveNumber++)\r\n{\r\nDAC960_V1_LogicalDriveInformation_T *OldLogicalDriveInformation =\r\n&Controller->V1.LogicalDriveInformation[LogicalDriveNumber];\r\nDAC960_V1_LogicalDriveInformation_T *NewLogicalDriveInformation =\r\n&(*Controller->V1.NewLogicalDriveInformation)[LogicalDriveNumber];\r\nif (NewLogicalDriveInformation->LogicalDriveState !=\r\nOldLogicalDriveInformation->LogicalDriveState)\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"is now %s\n", Controller,\r\nLogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(NewLogicalDriveInformation->LogicalDriveState\r\n== DAC960_V1_LogicalDrive_Online\r\n? "ONLINE"\r\n: NewLogicalDriveInformation->LogicalDriveState\r\n== DAC960_V1_LogicalDrive_Critical\r\n? "CRITICAL" : "OFFLINE"));\r\nif (NewLogicalDriveInformation->WriteBack !=\r\nOldLogicalDriveInformation->WriteBack)\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"is now %s\n", Controller,\r\nLogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(NewLogicalDriveInformation->WriteBack\r\n? "WRITE BACK" : "WRITE THRU"));\r\n}\r\nmemcpy(&Controller->V1.LogicalDriveInformation,\r\nController->V1.NewLogicalDriveInformation,\r\nsizeof(DAC960_V1_LogicalDriveInformationArray_T));\r\n}\r\nelse if (CommandOpcode == DAC960_V1_GetRebuildProgress)\r\n{\r\nunsigned int LogicalDriveNumber =\r\nController->V1.RebuildProgress->LogicalDriveNumber;\r\nunsigned int LogicalDriveSize =\r\nController->V1.RebuildProgress->LogicalDriveSize;\r\nunsigned int BlocksCompleted =\r\nLogicalDriveSize - Controller->V1.RebuildProgress->RemainingBlocks;\r\nif (CommandStatus == DAC960_V1_NoRebuildOrCheckInProgress &&\r\nController->V1.LastRebuildStatus == DAC960_V1_NormalCompletion)\r\nCommandStatus = DAC960_V1_RebuildSuccessful;\r\nswitch (CommandStatus)\r\n{\r\ncase DAC960_V1_NormalCompletion:\r\nController->EphemeralProgressMessage = true;\r\nDAC960_Progress("Rebuild in Progress: "\r\n"Logical Drive %d (/dev/rd/c%dd%d) "\r\n"%d%% completed\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(100 * (BlocksCompleted >> 7))\r\n/ (LogicalDriveSize >> 7));\r\nController->EphemeralProgressMessage = false;\r\nbreak;\r\ncase DAC960_V1_RebuildFailed_LogicalDriveFailure:\r\nDAC960_Progress("Rebuild Failed due to "\r\n"Logical Drive Failure\n", Controller);\r\nbreak;\r\ncase DAC960_V1_RebuildFailed_BadBlocksOnOther:\r\nDAC960_Progress("Rebuild Failed due to "\r\n"Bad Blocks on Other Drives\n", Controller);\r\nbreak;\r\ncase DAC960_V1_RebuildFailed_NewDriveFailed:\r\nDAC960_Progress("Rebuild Failed due to "\r\n"Failure of Drive Being Rebuilt\n", Controller);\r\nbreak;\r\ncase DAC960_V1_NoRebuildOrCheckInProgress:\r\nbreak;\r\ncase DAC960_V1_RebuildSuccessful:\r\nDAC960_Progress("Rebuild Completed Successfully\n", Controller);\r\nbreak;\r\ncase DAC960_V1_RebuildSuccessfullyTerminated:\r\nDAC960_Progress("Rebuild Successfully Terminated\n", Controller);\r\nbreak;\r\n}\r\nController->V1.LastRebuildStatus = CommandStatus;\r\nif (CommandType != DAC960_MonitoringCommand &&\r\nController->V1.RebuildStatusPending)\r\n{\r\nCommand->V1.CommandStatus = Controller->V1.PendingRebuildStatus;\r\nController->V1.RebuildStatusPending = false;\r\n}\r\nelse if (CommandType == DAC960_MonitoringCommand &&\r\nCommandStatus != DAC960_V1_NormalCompletion &&\r\nCommandStatus != DAC960_V1_NoRebuildOrCheckInProgress)\r\n{\r\nController->V1.PendingRebuildStatus = CommandStatus;\r\nController->V1.RebuildStatusPending = true;\r\n}\r\n}\r\nelse if (CommandOpcode == DAC960_V1_RebuildStat)\r\n{\r\nunsigned int LogicalDriveNumber =\r\nController->V1.RebuildProgress->LogicalDriveNumber;\r\nunsigned int LogicalDriveSize =\r\nController->V1.RebuildProgress->LogicalDriveSize;\r\nunsigned int BlocksCompleted =\r\nLogicalDriveSize - Controller->V1.RebuildProgress->RemainingBlocks;\r\nif (CommandStatus == DAC960_V1_NormalCompletion)\r\n{\r\nController->EphemeralProgressMessage = true;\r\nDAC960_Progress("Consistency Check in Progress: "\r\n"Logical Drive %d (/dev/rd/c%dd%d) "\r\n"%d%% completed\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(100 * (BlocksCompleted >> 7))\r\n/ (LogicalDriveSize >> 7));\r\nController->EphemeralProgressMessage = false;\r\n}\r\n}\r\nelse if (CommandOpcode == DAC960_V1_BackgroundInitializationControl)\r\n{\r\nunsigned int LogicalDriveNumber =\r\nController->V1.BackgroundInitializationStatus->LogicalDriveNumber;\r\nunsigned int LogicalDriveSize =\r\nController->V1.BackgroundInitializationStatus->LogicalDriveSize;\r\nunsigned int BlocksCompleted =\r\nController->V1.BackgroundInitializationStatus->BlocksCompleted;\r\nswitch (CommandStatus)\r\n{\r\ncase DAC960_V1_NormalCompletion:\r\nswitch (Controller->V1.BackgroundInitializationStatus->Status)\r\n{\r\ncase DAC960_V1_BackgroundInitializationInvalid:\r\nbreak;\r\ncase DAC960_V1_BackgroundInitializationStarted:\r\nDAC960_Progress("Background Initialization Started\n",\r\nController);\r\nbreak;\r\ncase DAC960_V1_BackgroundInitializationInProgress:\r\nif (BlocksCompleted ==\r\nController->V1.LastBackgroundInitializationStatus.\r\nBlocksCompleted &&\r\nLogicalDriveNumber ==\r\nController->V1.LastBackgroundInitializationStatus.\r\nLogicalDriveNumber)\r\nbreak;\r\nController->EphemeralProgressMessage = true;\r\nDAC960_Progress("Background Initialization in Progress: "\r\n"Logical Drive %d (/dev/rd/c%dd%d) "\r\n"%d%% completed\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(100 * (BlocksCompleted >> 7))\r\n/ (LogicalDriveSize >> 7));\r\nController->EphemeralProgressMessage = false;\r\nbreak;\r\ncase DAC960_V1_BackgroundInitializationSuspended:\r\nDAC960_Progress("Background Initialization Suspended\n",\r\nController);\r\nbreak;\r\ncase DAC960_V1_BackgroundInitializationCancelled:\r\nDAC960_Progress("Background Initialization Cancelled\n",\r\nController);\r\nbreak;\r\n}\r\nmemcpy(&Controller->V1.LastBackgroundInitializationStatus,\r\nController->V1.BackgroundInitializationStatus,\r\nsizeof(DAC960_V1_BackgroundInitializationStatus_T));\r\nbreak;\r\ncase DAC960_V1_BackgroundInitSuccessful:\r\nif (Controller->V1.BackgroundInitializationStatus->Status ==\r\nDAC960_V1_BackgroundInitializationInProgress)\r\nDAC960_Progress("Background Initialization "\r\n"Completed Successfully\n", Controller);\r\nController->V1.BackgroundInitializationStatus->Status =\r\nDAC960_V1_BackgroundInitializationInvalid;\r\nbreak;\r\ncase DAC960_V1_BackgroundInitAborted:\r\nif (Controller->V1.BackgroundInitializationStatus->Status ==\r\nDAC960_V1_BackgroundInitializationInProgress)\r\nDAC960_Progress("Background Initialization Aborted\n",\r\nController);\r\nController->V1.BackgroundInitializationStatus->Status =\r\nDAC960_V1_BackgroundInitializationInvalid;\r\nbreak;\r\ncase DAC960_V1_NoBackgroundInitInProgress:\r\nbreak;\r\n}\r\n}\r\nelse if (CommandOpcode == DAC960_V1_DCDB)\r\n{\r\nif (Controller->V1.NeedDeviceInquiryInformation)\r\n{\r\nDAC960_SCSI_Inquiry_T *InquiryStandardData =\r\n&Controller->V1.InquiryStandardData\r\n[Controller->V1.DeviceStateChannel]\r\n[Controller->V1.DeviceStateTargetID];\r\nif (CommandStatus != DAC960_V1_NormalCompletion)\r\n{\r\nmemset(InquiryStandardData, 0,\r\nsizeof(DAC960_SCSI_Inquiry_T));\r\nInquiryStandardData->PeripheralDeviceType = 0x1F;\r\n}\r\nelse\r\nmemcpy(InquiryStandardData,\r\nController->V1.NewInquiryStandardData,\r\nsizeof(DAC960_SCSI_Inquiry_T));\r\nController->V1.NeedDeviceInquiryInformation = false;\r\n}\r\nelse if (Controller->V1.NeedDeviceSerialNumberInformation)\r\n{\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\n&Controller->V1.InquiryUnitSerialNumber\r\n[Controller->V1.DeviceStateChannel]\r\n[Controller->V1.DeviceStateTargetID];\r\nif (CommandStatus != DAC960_V1_NormalCompletion)\r\n{\r\nmemset(InquiryUnitSerialNumber, 0,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nInquiryUnitSerialNumber->PeripheralDeviceType = 0x1F;\r\n}\r\nelse\r\nmemcpy(InquiryUnitSerialNumber,\r\nController->V1.NewInquiryUnitSerialNumber,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nController->V1.NeedDeviceSerialNumberInformation = false;\r\n}\r\n}\r\nif (Controller->V1.NewEventLogSequenceNumber\r\n- Controller->V1.OldEventLogSequenceNumber > 0)\r\n{\r\nCommand->V1.CommandMailbox.Type3E.CommandOpcode =\r\nDAC960_V1_PerformEventLogOperation;\r\nCommand->V1.CommandMailbox.Type3E.OperationType =\r\nDAC960_V1_GetEventLogEntry;\r\nCommand->V1.CommandMailbox.Type3E.OperationQualifier = 1;\r\nCommand->V1.CommandMailbox.Type3E.SequenceNumber =\r\nController->V1.OldEventLogSequenceNumber;\r\nCommand->V1.CommandMailbox.Type3E.BusAddress =\r\nController->V1.EventLogEntryDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedErrorTableInformation)\r\n{\r\nController->V1.NeedErrorTableInformation = false;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode =\r\nDAC960_V1_GetErrorTable;\r\nCommand->V1.CommandMailbox.Type3.BusAddress =\r\nController->V1.NewErrorTableDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedRebuildProgress &&\r\nController->V1.RebuildProgressFirst)\r\n{\r\nController->V1.NeedRebuildProgress = false;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode =\r\nDAC960_V1_GetRebuildProgress;\r\nCommand->V1.CommandMailbox.Type3.BusAddress =\r\nController->V1.RebuildProgressDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedDeviceStateInformation)\r\n{\r\nif (Controller->V1.NeedDeviceInquiryInformation)\r\n{\r\nDAC960_V1_DCDB_T *DCDB = Controller->V1.MonitoringDCDB;\r\ndma_addr_t DCDB_DMA = Controller->V1.MonitoringDCDB_DMA;\r\ndma_addr_t NewInquiryStandardDataDMA =\r\nController->V1.NewInquiryStandardDataDMA;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode = DAC960_V1_DCDB;\r\nCommand->V1.CommandMailbox.Type3.BusAddress = DCDB_DMA;\r\nDCDB->Channel = Controller->V1.DeviceStateChannel;\r\nDCDB->TargetID = Controller->V1.DeviceStateTargetID;\r\nDCDB->Direction = DAC960_V1_DCDB_DataTransferDeviceToSystem;\r\nDCDB->EarlyStatus = false;\r\nDCDB->Timeout = DAC960_V1_DCDB_Timeout_10_seconds;\r\nDCDB->NoAutomaticRequestSense = false;\r\nDCDB->DisconnectPermitted = true;\r\nDCDB->TransferLength = sizeof(DAC960_SCSI_Inquiry_T);\r\nDCDB->BusAddress = NewInquiryStandardDataDMA;\r\nDCDB->CDBLength = 6;\r\nDCDB->TransferLengthHigh4 = 0;\r\nDCDB->SenseLength = sizeof(DCDB->SenseData);\r\nDCDB->CDB[0] = 0x12;\r\nDCDB->CDB[1] = 0;\r\nDCDB->CDB[2] = 0;\r\nDCDB->CDB[3] = 0;\r\nDCDB->CDB[4] = sizeof(DAC960_SCSI_Inquiry_T);\r\nDCDB->CDB[5] = 0;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedDeviceSerialNumberInformation)\r\n{\r\nDAC960_V1_DCDB_T *DCDB = Controller->V1.MonitoringDCDB;\r\ndma_addr_t DCDB_DMA = Controller->V1.MonitoringDCDB_DMA;\r\ndma_addr_t NewInquiryUnitSerialNumberDMA =\r\nController->V1.NewInquiryUnitSerialNumberDMA;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode = DAC960_V1_DCDB;\r\nCommand->V1.CommandMailbox.Type3.BusAddress = DCDB_DMA;\r\nDCDB->Channel = Controller->V1.DeviceStateChannel;\r\nDCDB->TargetID = Controller->V1.DeviceStateTargetID;\r\nDCDB->Direction = DAC960_V1_DCDB_DataTransferDeviceToSystem;\r\nDCDB->EarlyStatus = false;\r\nDCDB->Timeout = DAC960_V1_DCDB_Timeout_10_seconds;\r\nDCDB->NoAutomaticRequestSense = false;\r\nDCDB->DisconnectPermitted = true;\r\nDCDB->TransferLength =\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nDCDB->BusAddress = NewInquiryUnitSerialNumberDMA;\r\nDCDB->CDBLength = 6;\r\nDCDB->TransferLengthHigh4 = 0;\r\nDCDB->SenseLength = sizeof(DCDB->SenseData);\r\nDCDB->CDB[0] = 0x12;\r\nDCDB->CDB[1] = 1;\r\nDCDB->CDB[2] = 0x80;\r\nDCDB->CDB[3] = 0;\r\nDCDB->CDB[4] = sizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T);\r\nDCDB->CDB[5] = 0;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.StartDeviceStateScan)\r\n{\r\nController->V1.DeviceStateChannel = 0;\r\nController->V1.DeviceStateTargetID = 0;\r\nController->V1.StartDeviceStateScan = false;\r\n}\r\nelse if (++Controller->V1.DeviceStateTargetID == Controller->Targets)\r\n{\r\nController->V1.DeviceStateChannel++;\r\nController->V1.DeviceStateTargetID = 0;\r\n}\r\nif (Controller->V1.DeviceStateChannel < Controller->Channels)\r\n{\r\nController->V1.NewDeviceState->DeviceState =\r\nDAC960_V1_Device_Dead;\r\nCommand->V1.CommandMailbox.Type3D.CommandOpcode =\r\nDAC960_V1_GetDeviceState;\r\nCommand->V1.CommandMailbox.Type3D.Channel =\r\nController->V1.DeviceStateChannel;\r\nCommand->V1.CommandMailbox.Type3D.TargetID =\r\nController->V1.DeviceStateTargetID;\r\nCommand->V1.CommandMailbox.Type3D.BusAddress =\r\nController->V1.NewDeviceStateDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nController->V1.NeedDeviceStateInformation = false;\r\n}\r\nif (Controller->V1.NeedLogicalDriveInformation)\r\n{\r\nController->V1.NeedLogicalDriveInformation = false;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode =\r\nDAC960_V1_GetLogicalDriveInformation;\r\nCommand->V1.CommandMailbox.Type3.BusAddress =\r\nController->V1.NewLogicalDriveInformationDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedRebuildProgress)\r\n{\r\nController->V1.NeedRebuildProgress = false;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode =\r\nDAC960_V1_GetRebuildProgress;\r\nCommand->V1.CommandMailbox.Type3.BusAddress =\r\nController->V1.RebuildProgressDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedConsistencyCheckProgress)\r\n{\r\nController->V1.NeedConsistencyCheckProgress = false;\r\nCommand->V1.CommandMailbox.Type3.CommandOpcode =\r\nDAC960_V1_RebuildStat;\r\nCommand->V1.CommandMailbox.Type3.BusAddress =\r\nController->V1.RebuildProgressDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V1.NeedBackgroundInitializationStatus)\r\n{\r\nController->V1.NeedBackgroundInitializationStatus = false;\r\nCommand->V1.CommandMailbox.Type3B.CommandOpcode =\r\nDAC960_V1_BackgroundInitializationControl;\r\nCommand->V1.CommandMailbox.Type3B.CommandOpcode2 = 0x20;\r\nCommand->V1.CommandMailbox.Type3B.BusAddress =\r\nController->V1.BackgroundInitializationStatusDMA;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nController->MonitoringTimerCount++;\r\nController->MonitoringTimer.expires =\r\njiffies + DAC960_MonitoringTimerInterval;\r\nadd_timer(&Controller->MonitoringTimer);\r\n}\r\nif (CommandType == DAC960_ImmediateCommand)\r\n{\r\ncomplete(Command->Completion);\r\nCommand->Completion = NULL;\r\nreturn;\r\n}\r\nif (CommandType == DAC960_QueuedCommand)\r\n{\r\nDAC960_V1_KernelCommand_T *KernelCommand = Command->V1.KernelCommand;\r\nKernelCommand->CommandStatus = Command->V1.CommandStatus;\r\nCommand->V1.KernelCommand = NULL;\r\nif (CommandOpcode == DAC960_V1_DCDB)\r\nController->V1.DirectCommandActive[KernelCommand->DCDB->Channel]\r\n[KernelCommand->DCDB->TargetID] =\r\nfalse;\r\nDAC960_DeallocateCommand(Command);\r\nKernelCommand->CompletionFunction(KernelCommand);\r\nreturn;\r\n}\r\nif (Controller->MonitoringCommandDeferred)\r\n{\r\nController->MonitoringCommandDeferred = false;\r\nDAC960_V1_QueueMonitoringCommand(Command);\r\nreturn;\r\n}\r\nDAC960_DeallocateCommand(Command);\r\nwake_up(&Controller->CommandWaitQueue);\r\n}\r\nstatic void DAC960_V2_ReadWriteError(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nunsigned char *SenseErrors[] = { "NO SENSE", "RECOVERED ERROR",\r\n"NOT READY", "MEDIUM ERROR",\r\n"HARDWARE ERROR", "ILLEGAL REQUEST",\r\n"UNIT ATTENTION", "DATA PROTECT",\r\n"BLANK CHECK", "VENDOR-SPECIFIC",\r\n"COPY ABORTED", "ABORTED COMMAND",\r\n"EQUAL", "VOLUME OVERFLOW",\r\n"MISCOMPARE", "RESERVED" };\r\nunsigned char *CommandName = "UNKNOWN";\r\nswitch (Command->CommandType)\r\n{\r\ncase DAC960_ReadCommand:\r\ncase DAC960_ReadRetryCommand:\r\nCommandName = "READ";\r\nbreak;\r\ncase DAC960_WriteCommand:\r\ncase DAC960_WriteRetryCommand:\r\nCommandName = "WRITE";\r\nbreak;\r\ncase DAC960_MonitoringCommand:\r\ncase DAC960_ImmediateCommand:\r\ncase DAC960_QueuedCommand:\r\nbreak;\r\n}\r\nDAC960_Error("Error Condition %s on %s:\n", Controller,\r\nSenseErrors[Command->V2.RequestSense->SenseKey], CommandName);\r\nDAC960_Error(" /dev/rd/c%dd%d: absolute blocks %u..%u\n",\r\nController, Controller->ControllerNumber,\r\nCommand->LogicalDriveNumber, Command->BlockNumber,\r\nCommand->BlockNumber + Command->BlockCount - 1);\r\n}\r\nstatic void DAC960_V2_ReportEvent(DAC960_Controller_T *Controller,\r\nDAC960_V2_Event_T *Event)\r\n{\r\nDAC960_SCSI_RequestSense_T *RequestSense =\r\n(DAC960_SCSI_RequestSense_T *) &Event->RequestSenseData;\r\nunsigned char MessageBuffer[DAC960_LineBufferSize];\r\nstatic struct { int EventCode; unsigned char *EventMessage; } EventList[] =\r\n{\r\n{ 0x0001, "P Online" },\r\n{ 0x0002, "P Standby" },\r\n{ 0x0005, "P Automatic Rebuild Started" },\r\n{ 0x0006, "P Manual Rebuild Started" },\r\n{ 0x0007, "P Rebuild Completed" },\r\n{ 0x0008, "P Rebuild Cancelled" },\r\n{ 0x0009, "P Rebuild Failed for Unknown Reasons" },\r\n{ 0x000A, "P Rebuild Failed due to New Physical Device" },\r\n{ 0x000B, "P Rebuild Failed due to Logical Drive Failure" },\r\n{ 0x000C, "S Offline" },\r\n{ 0x000D, "P Found" },\r\n{ 0x000E, "P Removed" },\r\n{ 0x000F, "P Unconfigured" },\r\n{ 0x0010, "P Expand Capacity Started" },\r\n{ 0x0011, "P Expand Capacity Completed" },\r\n{ 0x0012, "P Expand Capacity Failed" },\r\n{ 0x0013, "P Command Timed Out" },\r\n{ 0x0014, "P Command Aborted" },\r\n{ 0x0015, "P Command Retried" },\r\n{ 0x0016, "P Parity Error" },\r\n{ 0x0017, "P Soft Error" },\r\n{ 0x0018, "P Miscellaneous Error" },\r\n{ 0x0019, "P Reset" },\r\n{ 0x001A, "P Active Spare Found" },\r\n{ 0x001B, "P Warm Spare Found" },\r\n{ 0x001C, "S Sense Data Received" },\r\n{ 0x001D, "P Initialization Started" },\r\n{ 0x001E, "P Initialization Completed" },\r\n{ 0x001F, "P Initialization Failed" },\r\n{ 0x0020, "P Initialization Cancelled" },\r\n{ 0x0021, "P Failed because Write Recovery Failed" },\r\n{ 0x0022, "P Failed because SCSI Bus Reset Failed" },\r\n{ 0x0023, "P Failed because of Double Check Condition" },\r\n{ 0x0024, "P Failed because Device Cannot Be Accessed" },\r\n{ 0x0025, "P Failed because of Gross Error on SCSI Processor" },\r\n{ 0x0026, "P Failed because of Bad Tag from Device" },\r\n{ 0x0027, "P Failed because of Command Timeout" },\r\n{ 0x0028, "P Failed because of System Reset" },\r\n{ 0x0029, "P Failed because of Busy Status or Parity Error" },\r\n{ 0x002A, "P Failed because Host Set Device to Failed State" },\r\n{ 0x002B, "P Failed because of Selection Timeout" },\r\n{ 0x002C, "P Failed because of SCSI Bus Phase Error" },\r\n{ 0x002D, "P Failed because Device Returned Unknown Status" },\r\n{ 0x002E, "P Failed because Device Not Ready" },\r\n{ 0x002F, "P Failed because Device Not Found at Startup" },\r\n{ 0x0030, "P Failed because COD Write Operation Failed" },\r\n{ 0x0031, "P Failed because BDT Write Operation Failed" },\r\n{ 0x0039, "P Missing at Startup" },\r\n{ 0x003A, "P Start Rebuild Failed due to Physical Drive Too Small" },\r\n{ 0x003C, "P Temporarily Offline Device Automatically Made Online" },\r\n{ 0x003D, "P Standby Rebuild Started" },\r\n{ 0x0080, "M Consistency Check Started" },\r\n{ 0x0081, "M Consistency Check Completed" },\r\n{ 0x0082, "M Consistency Check Cancelled" },\r\n{ 0x0083, "M Consistency Check Completed With Errors" },\r\n{ 0x0084, "M Consistency Check Failed due to Logical Drive Failure" },\r\n{ 0x0085, "M Consistency Check Failed due to Physical Device Failure" },\r\n{ 0x0086, "L Offline" },\r\n{ 0x0087, "L Critical" },\r\n{ 0x0088, "L Online" },\r\n{ 0x0089, "M Automatic Rebuild Started" },\r\n{ 0x008A, "M Manual Rebuild Started" },\r\n{ 0x008B, "M Rebuild Completed" },\r\n{ 0x008C, "M Rebuild Cancelled" },\r\n{ 0x008D, "M Rebuild Failed for Unknown Reasons" },\r\n{ 0x008E, "M Rebuild Failed due to New Physical Device" },\r\n{ 0x008F, "M Rebuild Failed due to Logical Drive Failure" },\r\n{ 0x0090, "M Initialization Started" },\r\n{ 0x0091, "M Initialization Completed" },\r\n{ 0x0092, "M Initialization Cancelled" },\r\n{ 0x0093, "M Initialization Failed" },\r\n{ 0x0094, "L Found" },\r\n{ 0x0095, "L Deleted" },\r\n{ 0x0096, "M Expand Capacity Started" },\r\n{ 0x0097, "M Expand Capacity Completed" },\r\n{ 0x0098, "M Expand Capacity Failed" },\r\n{ 0x0099, "L Bad Block Found" },\r\n{ 0x009A, "L Size Changed" },\r\n{ 0x009B, "L Type Changed" },\r\n{ 0x009C, "L Bad Data Block Found" },\r\n{ 0x009E, "L Read of Data Block in BDT" },\r\n{ 0x009F, "L Write Back Data for Disk Block Lost" },\r\n{ 0x00A0, "L Temporarily Offline RAID-5/3 Drive Made Online" },\r\n{ 0x00A1, "L Temporarily Offline RAID-6/1/0/7 Drive Made Online" },\r\n{ 0x00A2, "L Standby Rebuild Started" },\r\n{ 0x0140, "E Fan %d Failed" },\r\n{ 0x0141, "E Fan %d OK" },\r\n{ 0x0142, "E Fan %d Not Present" },\r\n{ 0x0143, "E Power Supply %d Failed" },\r\n{ 0x0144, "E Power Supply %d OK" },\r\n{ 0x0145, "E Power Supply %d Not Present" },\r\n{ 0x0146, "E Temperature Sensor %d Temperature Exceeds Safe Limit" },\r\n{ 0x0147, "E Temperature Sensor %d Temperature Exceeds Working Limit" },\r\n{ 0x0148, "E Temperature Sensor %d Temperature Normal" },\r\n{ 0x0149, "E Temperature Sensor %d Not Present" },\r\n{ 0x014A, "E Enclosure Management Unit %d Access Critical" },\r\n{ 0x014B, "E Enclosure Management Unit %d Access OK" },\r\n{ 0x014C, "E Enclosure Management Unit %d Access Offline" },\r\n{ 0x0181, "C Cache Write Back Error" },\r\n{ 0x0188, "C Battery Backup Unit Found" },\r\n{ 0x0189, "C Battery Backup Unit Charge Level Low" },\r\n{ 0x018A, "C Battery Backup Unit Charge Level OK" },\r\n{ 0x0193, "C Installation Aborted" },\r\n{ 0x0195, "C Battery Backup Unit Physically Removed" },\r\n{ 0x0196, "C Memory Error During Warm Boot" },\r\n{ 0x019E, "C Memory Soft ECC Error Corrected" },\r\n{ 0x019F, "C Memory Hard ECC Error Corrected" },\r\n{ 0x01A2, "C Battery Backup Unit Failed" },\r\n{ 0x01AB, "C Mirror Race Recovery Failed" },\r\n{ 0x01AC, "C Mirror Race on Critical Drive" },\r\n{ 0x0380, "C Internal Controller Hung" },\r\n{ 0x0381, "C Internal Controller Firmware Breakpoint" },\r\n{ 0x0390, "C Internal Controller i960 Processor Specific Error" },\r\n{ 0x03A0, "C Internal Controller StrongARM Processor Specific Error" },\r\n{ 0, "" } };\r\nint EventListIndex = 0, EventCode;\r\nunsigned char EventType, *EventMessage;\r\nif (Event->EventCode == 0x1C &&\r\nRequestSense->SenseKey == DAC960_SenseKey_VendorSpecific &&\r\n(RequestSense->AdditionalSenseCode == 0x80 ||\r\nRequestSense->AdditionalSenseCode == 0x81))\r\nEvent->EventCode = ((RequestSense->AdditionalSenseCode - 0x80) << 8) |\r\nRequestSense->AdditionalSenseCodeQualifier;\r\nwhile (true)\r\n{\r\nEventCode = EventList[EventListIndex].EventCode;\r\nif (EventCode == Event->EventCode || EventCode == 0) break;\r\nEventListIndex++;\r\n}\r\nEventType = EventList[EventListIndex].EventMessage[0];\r\nEventMessage = &EventList[EventListIndex].EventMessage[2];\r\nif (EventCode == 0)\r\n{\r\nDAC960_Critical("Unknown Controller Event Code %04X\n",\r\nController, Event->EventCode);\r\nreturn;\r\n}\r\nswitch (EventType)\r\n{\r\ncase 'P':\r\nDAC960_Critical("Physical Device %d:%d %s\n", Controller,\r\nEvent->Channel, Event->TargetID, EventMessage);\r\nbreak;\r\ncase 'L':\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) %s\n", Controller,\r\nEvent->LogicalUnit, Controller->ControllerNumber,\r\nEvent->LogicalUnit, EventMessage);\r\nbreak;\r\ncase 'M':\r\nDAC960_Progress("Logical Drive %d (/dev/rd/c%dd%d) %s\n", Controller,\r\nEvent->LogicalUnit, Controller->ControllerNumber,\r\nEvent->LogicalUnit, EventMessage);\r\nbreak;\r\ncase 'S':\r\nif (RequestSense->SenseKey == DAC960_SenseKey_NoSense ||\r\n(RequestSense->SenseKey == DAC960_SenseKey_NotReady &&\r\nRequestSense->AdditionalSenseCode == 0x04 &&\r\n(RequestSense->AdditionalSenseCodeQualifier == 0x01 ||\r\nRequestSense->AdditionalSenseCodeQualifier == 0x02)))\r\nbreak;\r\nDAC960_Critical("Physical Device %d:%d %s\n", Controller,\r\nEvent->Channel, Event->TargetID, EventMessage);\r\nDAC960_Critical("Physical Device %d:%d Request Sense: "\r\n"Sense Key = %X, ASC = %02X, ASCQ = %02X\n",\r\nController,\r\nEvent->Channel,\r\nEvent->TargetID,\r\nRequestSense->SenseKey,\r\nRequestSense->AdditionalSenseCode,\r\nRequestSense->AdditionalSenseCodeQualifier);\r\nDAC960_Critical("Physical Device %d:%d Request Sense: "\r\n"Information = %02X%02X%02X%02X "\r\n"%02X%02X%02X%02X\n",\r\nController,\r\nEvent->Channel,\r\nEvent->TargetID,\r\nRequestSense->Information[0],\r\nRequestSense->Information[1],\r\nRequestSense->Information[2],\r\nRequestSense->Information[3],\r\nRequestSense->CommandSpecificInformation[0],\r\nRequestSense->CommandSpecificInformation[1],\r\nRequestSense->CommandSpecificInformation[2],\r\nRequestSense->CommandSpecificInformation[3]);\r\nbreak;\r\ncase 'E':\r\nif (Controller->SuppressEnclosureMessages) break;\r\nsprintf(MessageBuffer, EventMessage, Event->LogicalUnit);\r\nDAC960_Critical("Enclosure %d %s\n", Controller,\r\nEvent->TargetID, MessageBuffer);\r\nbreak;\r\ncase 'C':\r\nDAC960_Critical("Controller %s\n", Controller, EventMessage);\r\nbreak;\r\ndefault:\r\nDAC960_Critical("Unknown Controller Event Code %04X\n",\r\nController, Event->EventCode);\r\nbreak;\r\n}\r\n}\r\nstatic void DAC960_V2_ReportProgress(DAC960_Controller_T *Controller,\r\nunsigned char *MessageString,\r\nunsigned int LogicalDeviceNumber,\r\nunsigned long BlocksCompleted,\r\nunsigned long LogicalDeviceSize)\r\n{\r\nController->EphemeralProgressMessage = true;\r\nDAC960_Progress("%s in Progress: Logical Drive %d (/dev/rd/c%dd%d) "\r\n"%d%% completed\n", Controller,\r\nMessageString,\r\nLogicalDeviceNumber,\r\nController->ControllerNumber,\r\nLogicalDeviceNumber,\r\n(100 * (BlocksCompleted >> 7)) / (LogicalDeviceSize >> 7));\r\nController->EphemeralProgressMessage = false;\r\n}\r\nstatic void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDAC960_CommandType_T CommandType = Command->CommandType;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_IOCTL_Opcode_T IOCTLOpcode = CommandMailbox->Common.IOCTL_Opcode;\r\nDAC960_V2_CommandOpcode_T CommandOpcode = CommandMailbox->SCSI_10.CommandOpcode;\r\nDAC960_V2_CommandStatus_T CommandStatus = Command->V2.CommandStatus;\r\nif (CommandType == DAC960_ReadCommand ||\r\nCommandType == DAC960_WriteCommand)\r\n{\r\n#ifdef FORCE_RETRY_DEBUG\r\nCommandStatus = DAC960_V2_AbormalCompletion;\r\n#endif\r\nCommand->V2.RequestSense->SenseKey = DAC960_SenseKey_MediumError;\r\nif (CommandStatus == DAC960_V2_NormalCompletion) {\r\nif (!DAC960_ProcessCompletedRequest(Command, true))\r\nBUG();\r\n} else if (Command->V2.RequestSense->SenseKey == DAC960_SenseKey_MediumError)\r\n{\r\nDAC960_queue_partial_rw(Command);\r\nreturn;\r\n}\r\nelse\r\n{\r\nif (Command->V2.RequestSense->SenseKey != DAC960_SenseKey_NotReady)\r\nDAC960_V2_ReadWriteError(Command);\r\n(void)DAC960_ProcessCompletedRequest(Command, false);\r\n}\r\n}\r\nelse if (CommandType == DAC960_ReadRetryCommand ||\r\nCommandType == DAC960_WriteRetryCommand)\r\n{\r\nbool normal_completion;\r\n#ifdef FORCE_RETRY_FAILURE_DEBUG\r\nstatic int retry_count = 1;\r\n#endif\r\nnormal_completion = true;\r\nif (CommandStatus != DAC960_V2_NormalCompletion) {\r\nnormal_completion = false;\r\nif (Command->V2.RequestSense->SenseKey != DAC960_SenseKey_NotReady)\r\nDAC960_V2_ReadWriteError(Command);\r\n}\r\n#ifdef FORCE_RETRY_FAILURE_DEBUG\r\nif (!(++retry_count % 10000)) {\r\nprintk("V2 error retry failure test\n");\r\nnormal_completion = false;\r\nDAC960_V2_ReadWriteError(Command);\r\n}\r\n#endif\r\nif (!DAC960_ProcessCompletedRequest(Command, normal_completion)) {\r\nDAC960_queue_partial_rw(Command);\r\nreturn;\r\n}\r\n}\r\nelse if (CommandType == DAC960_MonitoringCommand)\r\n{\r\nif (Controller->ShutdownMonitoringTimer)\r\nreturn;\r\nif (IOCTLOpcode == DAC960_V2_GetControllerInfo)\r\n{\r\nDAC960_V2_ControllerInfo_T *NewControllerInfo =\r\nController->V2.NewControllerInformation;\r\nDAC960_V2_ControllerInfo_T *ControllerInfo =\r\n&Controller->V2.ControllerInformation;\r\nController->LogicalDriveCount =\r\nNewControllerInfo->LogicalDevicesPresent;\r\nController->V2.NeedLogicalDeviceInformation = true;\r\nController->V2.NeedPhysicalDeviceInformation = true;\r\nController->V2.StartLogicalDeviceInformationScan = true;\r\nController->V2.StartPhysicalDeviceInformationScan = true;\r\nController->MonitoringAlertMode =\r\n(NewControllerInfo->LogicalDevicesCritical > 0 ||\r\nNewControllerInfo->LogicalDevicesOffline > 0 ||\r\nNewControllerInfo->PhysicalDisksCritical > 0 ||\r\nNewControllerInfo->PhysicalDisksOffline > 0);\r\nmemcpy(ControllerInfo, NewControllerInfo,\r\nsizeof(DAC960_V2_ControllerInfo_T));\r\n}\r\nelse if (IOCTLOpcode == DAC960_V2_GetEvent)\r\n{\r\nif (CommandStatus == DAC960_V2_NormalCompletion) {\r\nDAC960_V2_ReportEvent(Controller, Controller->V2.Event);\r\n}\r\nController->V2.NextEventSequenceNumber++;\r\n}\r\nelse if (IOCTLOpcode == DAC960_V2_GetPhysicalDeviceInfoValid &&\r\nCommandStatus == DAC960_V2_NormalCompletion)\r\n{\r\nDAC960_V2_PhysicalDeviceInfo_T *NewPhysicalDeviceInfo =\r\nController->V2.NewPhysicalDeviceInformation;\r\nunsigned int PhysicalDeviceIndex = Controller->V2.PhysicalDeviceIndex;\r\nDAC960_V2_PhysicalDeviceInfo_T *PhysicalDeviceInfo =\r\nController->V2.PhysicalDeviceInformation[PhysicalDeviceIndex];\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\nController->V2.InquiryUnitSerialNumber[PhysicalDeviceIndex];\r\nunsigned int DeviceIndex;\r\nwhile (PhysicalDeviceInfo != NULL &&\r\n(NewPhysicalDeviceInfo->Channel >\r\nPhysicalDeviceInfo->Channel ||\r\n(NewPhysicalDeviceInfo->Channel ==\r\nPhysicalDeviceInfo->Channel &&\r\n(NewPhysicalDeviceInfo->TargetID >\r\nPhysicalDeviceInfo->TargetID ||\r\n(NewPhysicalDeviceInfo->TargetID ==\r\nPhysicalDeviceInfo->TargetID &&\r\nNewPhysicalDeviceInfo->LogicalUnit >\r\nPhysicalDeviceInfo->LogicalUnit)))))\r\n{\r\nDAC960_Critical("Physical Device %d:%d No Longer Exists\n",\r\nController,\r\nPhysicalDeviceInfo->Channel,\r\nPhysicalDeviceInfo->TargetID);\r\nController->V2.PhysicalDeviceInformation\r\n[PhysicalDeviceIndex] = NULL;\r\nController->V2.InquiryUnitSerialNumber\r\n[PhysicalDeviceIndex] = NULL;\r\nkfree(PhysicalDeviceInfo);\r\nkfree(InquiryUnitSerialNumber);\r\nfor (DeviceIndex = PhysicalDeviceIndex;\r\nDeviceIndex < DAC960_V2_MaxPhysicalDevices - 1;\r\nDeviceIndex++)\r\n{\r\nController->V2.PhysicalDeviceInformation[DeviceIndex] =\r\nController->V2.PhysicalDeviceInformation[DeviceIndex+1];\r\nController->V2.InquiryUnitSerialNumber[DeviceIndex] =\r\nController->V2.InquiryUnitSerialNumber[DeviceIndex+1];\r\n}\r\nController->V2.PhysicalDeviceInformation\r\n[DAC960_V2_MaxPhysicalDevices-1] = NULL;\r\nController->V2.InquiryUnitSerialNumber\r\n[DAC960_V2_MaxPhysicalDevices-1] = NULL;\r\nPhysicalDeviceInfo =\r\nController->V2.PhysicalDeviceInformation[PhysicalDeviceIndex];\r\nInquiryUnitSerialNumber =\r\nController->V2.InquiryUnitSerialNumber[PhysicalDeviceIndex];\r\n}\r\nif (PhysicalDeviceInfo == NULL ||\r\n(NewPhysicalDeviceInfo->Channel !=\r\nPhysicalDeviceInfo->Channel) ||\r\n(NewPhysicalDeviceInfo->TargetID !=\r\nPhysicalDeviceInfo->TargetID) ||\r\n(NewPhysicalDeviceInfo->LogicalUnit !=\r\nPhysicalDeviceInfo->LogicalUnit))\r\n{\r\nPhysicalDeviceInfo =\r\nkmalloc(sizeof(DAC960_V2_PhysicalDeviceInfo_T), GFP_ATOMIC);\r\nInquiryUnitSerialNumber =\r\nkmalloc(sizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T),\r\nGFP_ATOMIC);\r\nif (InquiryUnitSerialNumber == NULL ||\r\nPhysicalDeviceInfo == NULL)\r\n{\r\nkfree(InquiryUnitSerialNumber);\r\nInquiryUnitSerialNumber = NULL;\r\nkfree(PhysicalDeviceInfo);\r\nPhysicalDeviceInfo = NULL;\r\n}\r\nDAC960_Critical("Physical Device %d:%d Now Exists%s\n",\r\nController,\r\nNewPhysicalDeviceInfo->Channel,\r\nNewPhysicalDeviceInfo->TargetID,\r\n(PhysicalDeviceInfo != NULL\r\n? "" : " - Allocation Failed"));\r\nif (PhysicalDeviceInfo != NULL)\r\n{\r\nmemset(PhysicalDeviceInfo, 0,\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T));\r\nPhysicalDeviceInfo->PhysicalDeviceState =\r\nDAC960_V2_Device_InvalidState;\r\nmemset(InquiryUnitSerialNumber, 0,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nInquiryUnitSerialNumber->PeripheralDeviceType = 0x1F;\r\nfor (DeviceIndex = DAC960_V2_MaxPhysicalDevices - 1;\r\nDeviceIndex > PhysicalDeviceIndex;\r\nDeviceIndex--)\r\n{\r\nController->V2.PhysicalDeviceInformation[DeviceIndex] =\r\nController->V2.PhysicalDeviceInformation[DeviceIndex-1];\r\nController->V2.InquiryUnitSerialNumber[DeviceIndex] =\r\nController->V2.InquiryUnitSerialNumber[DeviceIndex-1];\r\n}\r\nController->V2.PhysicalDeviceInformation\r\n[PhysicalDeviceIndex] =\r\nPhysicalDeviceInfo;\r\nController->V2.InquiryUnitSerialNumber\r\n[PhysicalDeviceIndex] =\r\nInquiryUnitSerialNumber;\r\nController->V2.NeedDeviceSerialNumberInformation = true;\r\n}\r\n}\r\nif (PhysicalDeviceInfo != NULL)\r\n{\r\nif (NewPhysicalDeviceInfo->PhysicalDeviceState !=\r\nPhysicalDeviceInfo->PhysicalDeviceState)\r\nDAC960_Critical(\r\n"Physical Device %d:%d is now %s\n", Controller,\r\nNewPhysicalDeviceInfo->Channel,\r\nNewPhysicalDeviceInfo->TargetID,\r\n(NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Online\r\n? "ONLINE"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Rebuild\r\n? "REBUILD"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Missing\r\n? "MISSING"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Critical\r\n? "CRITICAL"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Dead\r\n? "DEAD"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_SuspectedDead\r\n? "SUSPECTED-DEAD"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_CommandedOffline\r\n? "COMMANDED-OFFLINE"\r\n: NewPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Standby\r\n? "STANDBY" : "UNKNOWN"));\r\nif ((NewPhysicalDeviceInfo->ParityErrors !=\r\nPhysicalDeviceInfo->ParityErrors) ||\r\n(NewPhysicalDeviceInfo->SoftErrors !=\r\nPhysicalDeviceInfo->SoftErrors) ||\r\n(NewPhysicalDeviceInfo->HardErrors !=\r\nPhysicalDeviceInfo->HardErrors) ||\r\n(NewPhysicalDeviceInfo->MiscellaneousErrors !=\r\nPhysicalDeviceInfo->MiscellaneousErrors) ||\r\n(NewPhysicalDeviceInfo->CommandTimeouts !=\r\nPhysicalDeviceInfo->CommandTimeouts) ||\r\n(NewPhysicalDeviceInfo->Retries !=\r\nPhysicalDeviceInfo->Retries) ||\r\n(NewPhysicalDeviceInfo->Aborts !=\r\nPhysicalDeviceInfo->Aborts) ||\r\n(NewPhysicalDeviceInfo->PredictedFailuresDetected !=\r\nPhysicalDeviceInfo->PredictedFailuresDetected))\r\n{\r\nDAC960_Critical("Physical Device %d:%d Errors: "\r\n"Parity = %d, Soft = %d, "\r\n"Hard = %d, Misc = %d\n",\r\nController,\r\nNewPhysicalDeviceInfo->Channel,\r\nNewPhysicalDeviceInfo->TargetID,\r\nNewPhysicalDeviceInfo->ParityErrors,\r\nNewPhysicalDeviceInfo->SoftErrors,\r\nNewPhysicalDeviceInfo->HardErrors,\r\nNewPhysicalDeviceInfo->MiscellaneousErrors);\r\nDAC960_Critical("Physical Device %d:%d Errors: "\r\n"Timeouts = %d, Retries = %d, "\r\n"Aborts = %d, Predicted = %d\n",\r\nController,\r\nNewPhysicalDeviceInfo->Channel,\r\nNewPhysicalDeviceInfo->TargetID,\r\nNewPhysicalDeviceInfo->CommandTimeouts,\r\nNewPhysicalDeviceInfo->Retries,\r\nNewPhysicalDeviceInfo->Aborts,\r\nNewPhysicalDeviceInfo\r\n->PredictedFailuresDetected);\r\n}\r\nif ((PhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_Dead ||\r\nPhysicalDeviceInfo->PhysicalDeviceState\r\n== DAC960_V2_Device_InvalidState) &&\r\nNewPhysicalDeviceInfo->PhysicalDeviceState\r\n!= DAC960_V2_Device_Dead)\r\nController->V2.NeedDeviceSerialNumberInformation = true;\r\nmemcpy(PhysicalDeviceInfo, NewPhysicalDeviceInfo,\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T));\r\n}\r\nNewPhysicalDeviceInfo->LogicalUnit++;\r\nController->V2.PhysicalDeviceIndex++;\r\n}\r\nelse if (IOCTLOpcode == DAC960_V2_GetPhysicalDeviceInfoValid)\r\n{\r\nunsigned int DeviceIndex;\r\nfor (DeviceIndex = Controller->V2.PhysicalDeviceIndex;\r\nDeviceIndex < DAC960_V2_MaxPhysicalDevices;\r\nDeviceIndex++)\r\n{\r\nDAC960_V2_PhysicalDeviceInfo_T *PhysicalDeviceInfo =\r\nController->V2.PhysicalDeviceInformation[DeviceIndex];\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\nController->V2.InquiryUnitSerialNumber[DeviceIndex];\r\nif (PhysicalDeviceInfo == NULL) break;\r\nDAC960_Critical("Physical Device %d:%d No Longer Exists\n",\r\nController,\r\nPhysicalDeviceInfo->Channel,\r\nPhysicalDeviceInfo->TargetID);\r\nController->V2.PhysicalDeviceInformation[DeviceIndex] = NULL;\r\nController->V2.InquiryUnitSerialNumber[DeviceIndex] = NULL;\r\nkfree(PhysicalDeviceInfo);\r\nkfree(InquiryUnitSerialNumber);\r\n}\r\nController->V2.NeedPhysicalDeviceInformation = false;\r\n}\r\nelse if (IOCTLOpcode == DAC960_V2_GetLogicalDeviceInfoValid &&\r\nCommandStatus == DAC960_V2_NormalCompletion)\r\n{\r\nDAC960_V2_LogicalDeviceInfo_T *NewLogicalDeviceInfo =\r\nController->V2.NewLogicalDeviceInformation;\r\nunsigned short LogicalDeviceNumber =\r\nNewLogicalDeviceInfo->LogicalDeviceNumber;\r\nDAC960_V2_LogicalDeviceInfo_T *LogicalDeviceInfo =\r\nController->V2.LogicalDeviceInformation[LogicalDeviceNumber];\r\nif (LogicalDeviceInfo == NULL)\r\n{\r\nDAC960_V2_PhysicalDevice_T PhysicalDevice;\r\nPhysicalDevice.Controller = 0;\r\nPhysicalDevice.Channel = NewLogicalDeviceInfo->Channel;\r\nPhysicalDevice.TargetID = NewLogicalDeviceInfo->TargetID;\r\nPhysicalDevice.LogicalUnit = NewLogicalDeviceInfo->LogicalUnit;\r\nController->V2.LogicalDriveToVirtualDevice[LogicalDeviceNumber] =\r\nPhysicalDevice;\r\nLogicalDeviceInfo = kmalloc(sizeof(DAC960_V2_LogicalDeviceInfo_T),\r\nGFP_ATOMIC);\r\nController->V2.LogicalDeviceInformation[LogicalDeviceNumber] =\r\nLogicalDeviceInfo;\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"Now Exists%s\n", Controller,\r\nLogicalDeviceNumber,\r\nController->ControllerNumber,\r\nLogicalDeviceNumber,\r\n(LogicalDeviceInfo != NULL\r\n? "" : " - Allocation Failed"));\r\nif (LogicalDeviceInfo != NULL)\r\n{\r\nmemset(LogicalDeviceInfo, 0,\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T));\r\nDAC960_ComputeGenericDiskInfo(Controller);\r\n}\r\n}\r\nif (LogicalDeviceInfo != NULL)\r\n{\r\nunsigned long LogicalDeviceSize =\r\nNewLogicalDeviceInfo->ConfigurableDeviceSize;\r\nif (NewLogicalDeviceInfo->LogicalDeviceState !=\r\nLogicalDeviceInfo->LogicalDeviceState)\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"is now %s\n", Controller,\r\nLogicalDeviceNumber,\r\nController->ControllerNumber,\r\nLogicalDeviceNumber,\r\n(NewLogicalDeviceInfo->LogicalDeviceState\r\n== DAC960_V2_LogicalDevice_Online\r\n? "ONLINE"\r\n: NewLogicalDeviceInfo->LogicalDeviceState\r\n== DAC960_V2_LogicalDevice_Critical\r\n? "CRITICAL" : "OFFLINE"));\r\nif ((NewLogicalDeviceInfo->SoftErrors !=\r\nLogicalDeviceInfo->SoftErrors) ||\r\n(NewLogicalDeviceInfo->CommandsFailed !=\r\nLogicalDeviceInfo->CommandsFailed) ||\r\n(NewLogicalDeviceInfo->DeferredWriteErrors !=\r\nLogicalDeviceInfo->DeferredWriteErrors))\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) Errors: "\r\n"Soft = %d, Failed = %d, Deferred Write = %d\n",\r\nController, LogicalDeviceNumber,\r\nController->ControllerNumber,\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo->SoftErrors,\r\nNewLogicalDeviceInfo->CommandsFailed,\r\nNewLogicalDeviceInfo->DeferredWriteErrors);\r\nif (NewLogicalDeviceInfo->ConsistencyCheckInProgress)\r\nDAC960_V2_ReportProgress(Controller,\r\n"Consistency Check",\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo\r\n->ConsistencyCheckBlockNumber,\r\nLogicalDeviceSize);\r\nelse if (NewLogicalDeviceInfo->RebuildInProgress)\r\nDAC960_V2_ReportProgress(Controller,\r\n"Rebuild",\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo\r\n->RebuildBlockNumber,\r\nLogicalDeviceSize);\r\nelse if (NewLogicalDeviceInfo->BackgroundInitializationInProgress)\r\nDAC960_V2_ReportProgress(Controller,\r\n"Background Initialization",\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo\r\n->BackgroundInitializationBlockNumber,\r\nLogicalDeviceSize);\r\nelse if (NewLogicalDeviceInfo->ForegroundInitializationInProgress)\r\nDAC960_V2_ReportProgress(Controller,\r\n"Foreground Initialization",\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo\r\n->ForegroundInitializationBlockNumber,\r\nLogicalDeviceSize);\r\nelse if (NewLogicalDeviceInfo->DataMigrationInProgress)\r\nDAC960_V2_ReportProgress(Controller,\r\n"Data Migration",\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo\r\n->DataMigrationBlockNumber,\r\nLogicalDeviceSize);\r\nelse if (NewLogicalDeviceInfo->PatrolOperationInProgress)\r\nDAC960_V2_ReportProgress(Controller,\r\n"Patrol Operation",\r\nLogicalDeviceNumber,\r\nNewLogicalDeviceInfo\r\n->PatrolOperationBlockNumber,\r\nLogicalDeviceSize);\r\nif (LogicalDeviceInfo->BackgroundInitializationInProgress &&\r\n!NewLogicalDeviceInfo->BackgroundInitializationInProgress)\r\nDAC960_Progress("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"Background Initialization %s\n",\r\nController,\r\nLogicalDeviceNumber,\r\nController->ControllerNumber,\r\nLogicalDeviceNumber,\r\n(NewLogicalDeviceInfo->LogicalDeviceControl\r\n.LogicalDeviceInitialized\r\n? "Completed" : "Failed"));\r\nmemcpy(LogicalDeviceInfo, NewLogicalDeviceInfo,\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T));\r\n}\r\nController->V2.LogicalDriveFoundDuringScan\r\n[LogicalDeviceNumber] = true;\r\nNewLogicalDeviceInfo->LogicalDeviceNumber++;\r\n}\r\nelse if (IOCTLOpcode == DAC960_V2_GetLogicalDeviceInfoValid)\r\n{\r\nint LogicalDriveNumber;\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < DAC960_MaxLogicalDrives;\r\nLogicalDriveNumber++)\r\n{\r\nDAC960_V2_LogicalDeviceInfo_T *LogicalDeviceInfo =\r\nController->V2.LogicalDeviceInformation[LogicalDriveNumber];\r\nif (LogicalDeviceInfo == NULL ||\r\nController->V2.LogicalDriveFoundDuringScan\r\n[LogicalDriveNumber])\r\ncontinue;\r\nDAC960_Critical("Logical Drive %d (/dev/rd/c%dd%d) "\r\n"No Longer Exists\n", Controller,\r\nLogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nController->V2.LogicalDeviceInformation\r\n[LogicalDriveNumber] = NULL;\r\nkfree(LogicalDeviceInfo);\r\nController->LogicalDriveInitiallyAccessible\r\n[LogicalDriveNumber] = false;\r\nDAC960_ComputeGenericDiskInfo(Controller);\r\n}\r\nController->V2.NeedLogicalDeviceInformation = false;\r\n}\r\nelse if (CommandOpcode == DAC960_V2_SCSI_10_Passthru)\r\n{\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\nController->V2.InquiryUnitSerialNumber[Controller->V2.PhysicalDeviceIndex - 1];\r\nif (CommandStatus != DAC960_V2_NormalCompletion) {\r\nmemset(InquiryUnitSerialNumber,\r\n0, sizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nInquiryUnitSerialNumber->PeripheralDeviceType = 0x1F;\r\n} else\r\nmemcpy(InquiryUnitSerialNumber,\r\nController->V2.NewInquiryUnitSerialNumber,\r\nsizeof(DAC960_SCSI_Inquiry_UnitSerialNumber_T));\r\nController->V2.NeedDeviceSerialNumberInformation = false;\r\n}\r\nif (Controller->V2.HealthStatusBuffer->NextEventSequenceNumber\r\n- Controller->V2.NextEventSequenceNumber > 0)\r\n{\r\nCommandMailbox->GetEvent.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->GetEvent.DataTransferSize = sizeof(DAC960_V2_Event_T);\r\nCommandMailbox->GetEvent.EventSequenceNumberHigh16 =\r\nController->V2.NextEventSequenceNumber >> 16;\r\nCommandMailbox->GetEvent.ControllerNumber = 0;\r\nCommandMailbox->GetEvent.IOCTL_Opcode =\r\nDAC960_V2_GetEvent;\r\nCommandMailbox->GetEvent.EventSequenceNumberLow16 =\r\nController->V2.NextEventSequenceNumber & 0xFFFF;\r\nCommandMailbox->GetEvent.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.EventDMA;\r\nCommandMailbox->GetEvent.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->GetEvent.DataTransferSize;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V2.NeedPhysicalDeviceInformation)\r\n{\r\nif (Controller->V2.NeedDeviceSerialNumberInformation)\r\n{\r\nDAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber =\r\nController->V2.NewInquiryUnitSerialNumber;\r\nInquiryUnitSerialNumber->PeripheralDeviceType = 0x1F;\r\nDAC960_V2_ConstructNewUnitSerialNumber(Controller, CommandMailbox,\r\nController->V2.NewPhysicalDeviceInformation->Channel,\r\nController->V2.NewPhysicalDeviceInformation->TargetID,\r\nController->V2.NewPhysicalDeviceInformation->LogicalUnit - 1);\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V2.StartPhysicalDeviceInformationScan)\r\n{\r\nController->V2.PhysicalDeviceIndex = 0;\r\nController->V2.NewPhysicalDeviceInformation->Channel = 0;\r\nController->V2.NewPhysicalDeviceInformation->TargetID = 0;\r\nController->V2.NewPhysicalDeviceInformation->LogicalUnit = 0;\r\nController->V2.StartPhysicalDeviceInformationScan = false;\r\n}\r\nCommandMailbox->PhysicalDeviceInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferSize =\r\nsizeof(DAC960_V2_PhysicalDeviceInfo_T);\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.LogicalUnit =\r\nController->V2.NewPhysicalDeviceInformation->LogicalUnit;\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.TargetID =\r\nController->V2.NewPhysicalDeviceInformation->TargetID;\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.Channel =\r\nController->V2.NewPhysicalDeviceInformation->Channel;\r\nCommandMailbox->PhysicalDeviceInfo.IOCTL_Opcode =\r\nDAC960_V2_GetPhysicalDeviceInfoValid;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewPhysicalDeviceInformationDMA;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferSize;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nif (Controller->V2.NeedLogicalDeviceInformation)\r\n{\r\nif (Controller->V2.StartLogicalDeviceInformationScan)\r\n{\r\nint LogicalDriveNumber;\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < DAC960_MaxLogicalDrives;\r\nLogicalDriveNumber++)\r\nController->V2.LogicalDriveFoundDuringScan\r\n[LogicalDriveNumber] = false;\r\nController->V2.NewLogicalDeviceInformation->LogicalDeviceNumber = 0;\r\nController->V2.StartLogicalDeviceInformationScan = false;\r\n}\r\nCommandMailbox->LogicalDeviceInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->LogicalDeviceInfo.DataTransferSize =\r\nsizeof(DAC960_V2_LogicalDeviceInfo_T);\r\nCommandMailbox->LogicalDeviceInfo.LogicalDevice.LogicalDeviceNumber =\r\nController->V2.NewLogicalDeviceInformation->LogicalDeviceNumber;\r\nCommandMailbox->LogicalDeviceInfo.IOCTL_Opcode =\r\nDAC960_V2_GetLogicalDeviceInfoValid;\r\nCommandMailbox->LogicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewLogicalDeviceInformationDMA;\r\nCommandMailbox->LogicalDeviceInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->LogicalDeviceInfo.DataTransferSize;\r\nDAC960_QueueCommand(Command);\r\nreturn;\r\n}\r\nController->MonitoringTimerCount++;\r\nController->MonitoringTimer.expires =\r\njiffies + DAC960_HealthStatusMonitoringInterval;\r\nadd_timer(&Controller->MonitoringTimer);\r\n}\r\nif (CommandType == DAC960_ImmediateCommand)\r\n{\r\ncomplete(Command->Completion);\r\nCommand->Completion = NULL;\r\nreturn;\r\n}\r\nif (CommandType == DAC960_QueuedCommand)\r\n{\r\nDAC960_V2_KernelCommand_T *KernelCommand = Command->V2.KernelCommand;\r\nKernelCommand->CommandStatus = CommandStatus;\r\nKernelCommand->RequestSenseLength = Command->V2.RequestSenseLength;\r\nKernelCommand->DataTransferLength = Command->V2.DataTransferResidue;\r\nCommand->V2.KernelCommand = NULL;\r\nDAC960_DeallocateCommand(Command);\r\nKernelCommand->CompletionFunction(KernelCommand);\r\nreturn;\r\n}\r\nif (Controller->MonitoringCommandDeferred)\r\n{\r\nController->MonitoringCommandDeferred = false;\r\nDAC960_V2_QueueMonitoringCommand(Command);\r\nreturn;\r\n}\r\nDAC960_DeallocateCommand(Command);\r\nwake_up(&Controller->CommandWaitQueue);\r\n}\r\nstatic irqreturn_t DAC960_GEM_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V2_StatusMailbox_T *NextStatusMailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_GEM_AcknowledgeInterrupt(ControllerBaseAddress);\r\nNextStatusMailbox = Controller->V2.NextStatusMailbox;\r\nwhile (NextStatusMailbox->Fields.CommandIdentifier > 0)\r\n{\r\nDAC960_V2_CommandIdentifier_T CommandIdentifier =\r\nNextStatusMailbox->Fields.CommandIdentifier;\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nCommand->V2.CommandStatus = NextStatusMailbox->Fields.CommandStatus;\r\nCommand->V2.RequestSenseLength =\r\nNextStatusMailbox->Fields.RequestSenseLength;\r\nCommand->V2.DataTransferResidue =\r\nNextStatusMailbox->Fields.DataTransferResidue;\r\nNextStatusMailbox->Words[0] = 0;\r\nif (++NextStatusMailbox > Controller->V2.LastStatusMailbox)\r\nNextStatusMailbox = Controller->V2.FirstStatusMailbox;\r\nDAC960_V2_ProcessCompletedCommand(Command);\r\n}\r\nController->V2.NextStatusMailbox = NextStatusMailbox;\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t DAC960_BA_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V2_StatusMailbox_T *NextStatusMailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_BA_AcknowledgeInterrupt(ControllerBaseAddress);\r\nNextStatusMailbox = Controller->V2.NextStatusMailbox;\r\nwhile (NextStatusMailbox->Fields.CommandIdentifier > 0)\r\n{\r\nDAC960_V2_CommandIdentifier_T CommandIdentifier =\r\nNextStatusMailbox->Fields.CommandIdentifier;\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nCommand->V2.CommandStatus = NextStatusMailbox->Fields.CommandStatus;\r\nCommand->V2.RequestSenseLength =\r\nNextStatusMailbox->Fields.RequestSenseLength;\r\nCommand->V2.DataTransferResidue =\r\nNextStatusMailbox->Fields.DataTransferResidue;\r\nNextStatusMailbox->Words[0] = 0;\r\nif (++NextStatusMailbox > Controller->V2.LastStatusMailbox)\r\nNextStatusMailbox = Controller->V2.FirstStatusMailbox;\r\nDAC960_V2_ProcessCompletedCommand(Command);\r\n}\r\nController->V2.NextStatusMailbox = NextStatusMailbox;\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t DAC960_LP_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V2_StatusMailbox_T *NextStatusMailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_LP_AcknowledgeInterrupt(ControllerBaseAddress);\r\nNextStatusMailbox = Controller->V2.NextStatusMailbox;\r\nwhile (NextStatusMailbox->Fields.CommandIdentifier > 0)\r\n{\r\nDAC960_V2_CommandIdentifier_T CommandIdentifier =\r\nNextStatusMailbox->Fields.CommandIdentifier;\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nCommand->V2.CommandStatus = NextStatusMailbox->Fields.CommandStatus;\r\nCommand->V2.RequestSenseLength =\r\nNextStatusMailbox->Fields.RequestSenseLength;\r\nCommand->V2.DataTransferResidue =\r\nNextStatusMailbox->Fields.DataTransferResidue;\r\nNextStatusMailbox->Words[0] = 0;\r\nif (++NextStatusMailbox > Controller->V2.LastStatusMailbox)\r\nNextStatusMailbox = Controller->V2.FirstStatusMailbox;\r\nDAC960_V2_ProcessCompletedCommand(Command);\r\n}\r\nController->V2.NextStatusMailbox = NextStatusMailbox;\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t DAC960_LA_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_StatusMailbox_T *NextStatusMailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_LA_AcknowledgeInterrupt(ControllerBaseAddress);\r\nNextStatusMailbox = Controller->V1.NextStatusMailbox;\r\nwhile (NextStatusMailbox->Fields.Valid)\r\n{\r\nDAC960_V1_CommandIdentifier_T CommandIdentifier =\r\nNextStatusMailbox->Fields.CommandIdentifier;\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nCommand->V1.CommandStatus = NextStatusMailbox->Fields.CommandStatus;\r\nNextStatusMailbox->Word = 0;\r\nif (++NextStatusMailbox > Controller->V1.LastStatusMailbox)\r\nNextStatusMailbox = Controller->V1.FirstStatusMailbox;\r\nDAC960_V1_ProcessCompletedCommand(Command);\r\n}\r\nController->V1.NextStatusMailbox = NextStatusMailbox;\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t DAC960_PG_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nDAC960_V1_StatusMailbox_T *NextStatusMailbox;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_PG_AcknowledgeInterrupt(ControllerBaseAddress);\r\nNextStatusMailbox = Controller->V1.NextStatusMailbox;\r\nwhile (NextStatusMailbox->Fields.Valid)\r\n{\r\nDAC960_V1_CommandIdentifier_T CommandIdentifier =\r\nNextStatusMailbox->Fields.CommandIdentifier;\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nCommand->V1.CommandStatus = NextStatusMailbox->Fields.CommandStatus;\r\nNextStatusMailbox->Word = 0;\r\nif (++NextStatusMailbox > Controller->V1.LastStatusMailbox)\r\nNextStatusMailbox = Controller->V1.FirstStatusMailbox;\r\nDAC960_V1_ProcessCompletedCommand(Command);\r\n}\r\nController->V1.NextStatusMailbox = NextStatusMailbox;\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t DAC960_PD_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile (DAC960_PD_StatusAvailableP(ControllerBaseAddress))\r\n{\r\nDAC960_V1_CommandIdentifier_T CommandIdentifier =\r\nDAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nCommand->V1.CommandStatus =\r\nDAC960_PD_ReadStatusRegister(ControllerBaseAddress);\r\nDAC960_PD_AcknowledgeInterrupt(ControllerBaseAddress);\r\nDAC960_PD_AcknowledgeStatus(ControllerBaseAddress);\r\nDAC960_V1_ProcessCompletedCommand(Command);\r\n}\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t DAC960_P_InterruptHandler(int IRQ_Channel,\r\nvoid *DeviceIdentifier)\r\n{\r\nDAC960_Controller_T *Controller = DeviceIdentifier;\r\nvoid __iomem *ControllerBaseAddress = Controller->BaseAddress;\r\nunsigned long flags;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile (DAC960_PD_StatusAvailableP(ControllerBaseAddress))\r\n{\r\nDAC960_V1_CommandIdentifier_T CommandIdentifier =\r\nDAC960_PD_ReadStatusCommandIdentifier(ControllerBaseAddress);\r\nDAC960_Command_T *Command = Controller->Commands[CommandIdentifier-1];\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_CommandOpcode_T CommandOpcode =\r\nCommandMailbox->Common.CommandOpcode;\r\nCommand->V1.CommandStatus =\r\nDAC960_PD_ReadStatusRegister(ControllerBaseAddress);\r\nDAC960_PD_AcknowledgeInterrupt(ControllerBaseAddress);\r\nDAC960_PD_AcknowledgeStatus(ControllerBaseAddress);\r\nswitch (CommandOpcode)\r\n{\r\ncase DAC960_V1_Enquiry_Old:\r\nCommand->V1.CommandMailbox.Common.CommandOpcode = DAC960_V1_Enquiry;\r\nDAC960_P_To_PD_TranslateEnquiry(Controller->V1.NewEnquiry);\r\nbreak;\r\ncase DAC960_V1_GetDeviceState_Old:\r\nCommand->V1.CommandMailbox.Common.CommandOpcode =\r\nDAC960_V1_GetDeviceState;\r\nDAC960_P_To_PD_TranslateDeviceState(Controller->V1.NewDeviceState);\r\nbreak;\r\ncase DAC960_V1_Read_Old:\r\nCommand->V1.CommandMailbox.Common.CommandOpcode = DAC960_V1_Read;\r\nDAC960_P_To_PD_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ncase DAC960_V1_Write_Old:\r\nCommand->V1.CommandMailbox.Common.CommandOpcode = DAC960_V1_Write;\r\nDAC960_P_To_PD_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ncase DAC960_V1_ReadWithScatterGather_Old:\r\nCommand->V1.CommandMailbox.Common.CommandOpcode =\r\nDAC960_V1_ReadWithScatterGather;\r\nDAC960_P_To_PD_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ncase DAC960_V1_WriteWithScatterGather_Old:\r\nCommand->V1.CommandMailbox.Common.CommandOpcode =\r\nDAC960_V1_WriteWithScatterGather;\r\nDAC960_P_To_PD_TranslateReadWriteCommand(CommandMailbox);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nDAC960_V1_ProcessCompletedCommand(Command);\r\n}\r\nDAC960_ProcessRequest(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void DAC960_V1_QueueMonitoringCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_MonitoringCommand;\r\nCommandMailbox->Type3.CommandOpcode = DAC960_V1_Enquiry;\r\nCommandMailbox->Type3.BusAddress = Controller->V1.NewEnquiryDMA;\r\nDAC960_QueueCommand(Command);\r\n}\r\nstatic void DAC960_V2_QueueMonitoringCommand(DAC960_Command_T *Command)\r\n{\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox = &Command->V2.CommandMailbox;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_MonitoringCommand;\r\nCommandMailbox->ControllerInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->ControllerInfo.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->ControllerInfo.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->ControllerInfo.DataTransferSize =\r\nsizeof(DAC960_V2_ControllerInfo_T);\r\nCommandMailbox->ControllerInfo.ControllerNumber = 0;\r\nCommandMailbox->ControllerInfo.IOCTL_Opcode = DAC960_V2_GetControllerInfo;\r\nCommandMailbox->ControllerInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewControllerInformationDMA;\r\nCommandMailbox->ControllerInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->ControllerInfo.DataTransferSize;\r\nDAC960_QueueCommand(Command);\r\n}\r\nstatic void DAC960_MonitoringTimerFunction(unsigned long TimerData)\r\n{\r\nDAC960_Controller_T *Controller = (DAC960_Controller_T *) TimerData;\r\nDAC960_Command_T *Command;\r\nunsigned long flags;\r\nif (Controller->FirmwareType == DAC960_V1_Controller)\r\n{\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nCommand = DAC960_AllocateCommand(Controller);\r\nif (Command != NULL)\r\nDAC960_V1_QueueMonitoringCommand(Command);\r\nelse Controller->MonitoringCommandDeferred = true;\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\n}\r\nelse\r\n{\r\nDAC960_V2_ControllerInfo_T *ControllerInfo =\r\n&Controller->V2.ControllerInformation;\r\nunsigned int StatusChangeCounter =\r\nController->V2.HealthStatusBuffer->StatusChangeCounter;\r\nbool ForceMonitoringCommand = false;\r\nif (time_after(jiffies, Controller->SecondaryMonitoringTime\r\n+ DAC960_SecondaryMonitoringInterval))\r\n{\r\nint LogicalDriveNumber;\r\nfor (LogicalDriveNumber = 0;\r\nLogicalDriveNumber < DAC960_MaxLogicalDrives;\r\nLogicalDriveNumber++)\r\n{\r\nDAC960_V2_LogicalDeviceInfo_T *LogicalDeviceInfo =\r\nController->V2.LogicalDeviceInformation[LogicalDriveNumber];\r\nif (LogicalDeviceInfo == NULL) continue;\r\nif (!LogicalDeviceInfo->LogicalDeviceControl\r\n.LogicalDeviceInitialized)\r\n{\r\nForceMonitoringCommand = true;\r\nbreak;\r\n}\r\n}\r\nController->SecondaryMonitoringTime = jiffies;\r\n}\r\nif (StatusChangeCounter == Controller->V2.StatusChangeCounter &&\r\nController->V2.HealthStatusBuffer->NextEventSequenceNumber\r\n== Controller->V2.NextEventSequenceNumber &&\r\n(ControllerInfo->BackgroundInitializationsActive +\r\nControllerInfo->LogicalDeviceInitializationsActive +\r\nControllerInfo->PhysicalDeviceInitializationsActive +\r\nControllerInfo->ConsistencyChecksActive +\r\nControllerInfo->RebuildsActive +\r\nControllerInfo->OnlineExpansionsActive == 0 ||\r\ntime_before(jiffies, Controller->PrimaryMonitoringTime\r\n+ DAC960_MonitoringTimerInterval)) &&\r\n!ForceMonitoringCommand)\r\n{\r\nController->MonitoringTimer.expires =\r\njiffies + DAC960_HealthStatusMonitoringInterval;\r\nadd_timer(&Controller->MonitoringTimer);\r\nreturn;\r\n}\r\nController->V2.StatusChangeCounter = StatusChangeCounter;\r\nController->PrimaryMonitoringTime = jiffies;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nCommand = DAC960_AllocateCommand(Controller);\r\nif (Command != NULL)\r\nDAC960_V2_QueueMonitoringCommand(Command);\r\nelse Controller->MonitoringCommandDeferred = true;\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nwake_up(&Controller->HealthStatusWaitQueue);\r\n}\r\n}\r\nstatic bool DAC960_CheckStatusBuffer(DAC960_Controller_T *Controller,\r\nunsigned int ByteCount)\r\n{\r\nunsigned char *NewStatusBuffer;\r\nif (Controller->InitialStatusLength + 1 +\r\nController->CurrentStatusLength + ByteCount + 1 <=\r\nController->CombinedStatusBufferLength)\r\nreturn true;\r\nif (Controller->CombinedStatusBufferLength == 0)\r\n{\r\nunsigned int NewStatusBufferLength = DAC960_InitialStatusBufferSize;\r\nwhile (NewStatusBufferLength < ByteCount)\r\nNewStatusBufferLength *= 2;\r\nController->CombinedStatusBuffer = kmalloc(NewStatusBufferLength,\r\nGFP_ATOMIC);\r\nif (Controller->CombinedStatusBuffer == NULL) return false;\r\nController->CombinedStatusBufferLength = NewStatusBufferLength;\r\nreturn true;\r\n}\r\nNewStatusBuffer = kmalloc(2 * Controller->CombinedStatusBufferLength,\r\nGFP_ATOMIC);\r\nif (NewStatusBuffer == NULL)\r\n{\r\nDAC960_Warning("Unable to expand Combined Status Buffer - Truncating\n",\r\nController);\r\nreturn false;\r\n}\r\nmemcpy(NewStatusBuffer, Controller->CombinedStatusBuffer,\r\nController->CombinedStatusBufferLength);\r\nkfree(Controller->CombinedStatusBuffer);\r\nController->CombinedStatusBuffer = NewStatusBuffer;\r\nController->CombinedStatusBufferLength *= 2;\r\nController->CurrentStatusBuffer =\r\n&NewStatusBuffer[Controller->InitialStatusLength + 1];\r\nreturn true;\r\n}\r\nstatic void DAC960_Message(DAC960_MessageLevel_T MessageLevel,\r\nunsigned char *Format,\r\nDAC960_Controller_T *Controller,\r\n...)\r\n{\r\nstatic unsigned char Buffer[DAC960_LineBufferSize];\r\nstatic bool BeginningOfLine = true;\r\nva_list Arguments;\r\nint Length = 0;\r\nva_start(Arguments, Controller);\r\nLength = vsprintf(Buffer, Format, Arguments);\r\nva_end(Arguments);\r\nif (Controller == NULL)\r\nprintk("%sDAC960#%d: %s", DAC960_MessageLevelMap[MessageLevel],\r\nDAC960_ControllerCount, Buffer);\r\nelse if (MessageLevel == DAC960_AnnounceLevel ||\r\nMessageLevel == DAC960_InfoLevel)\r\n{\r\nif (!Controller->ControllerInitialized)\r\n{\r\nif (DAC960_CheckStatusBuffer(Controller, Length))\r\n{\r\nstrcpy(&Controller->CombinedStatusBuffer\r\n[Controller->InitialStatusLength],\r\nBuffer);\r\nController->InitialStatusLength += Length;\r\nController->CurrentStatusBuffer =\r\n&Controller->CombinedStatusBuffer\r\n[Controller->InitialStatusLength + 1];\r\n}\r\nif (MessageLevel == DAC960_AnnounceLevel)\r\n{\r\nstatic int AnnouncementLines = 0;\r\nif (++AnnouncementLines <= 2)\r\nprintk("%sDAC960: %s", DAC960_MessageLevelMap[MessageLevel],\r\nBuffer);\r\n}\r\nelse\r\n{\r\nif (BeginningOfLine)\r\n{\r\nif (Buffer[0] != '\n' || Length > 1)\r\nprintk("%sDAC960#%d: %s",\r\nDAC960_MessageLevelMap[MessageLevel],\r\nController->ControllerNumber, Buffer);\r\n}\r\nelse printk("%s", Buffer);\r\n}\r\n}\r\nelse if (DAC960_CheckStatusBuffer(Controller, Length))\r\n{\r\nstrcpy(&Controller->CurrentStatusBuffer[\r\nController->CurrentStatusLength], Buffer);\r\nController->CurrentStatusLength += Length;\r\n}\r\n}\r\nelse if (MessageLevel == DAC960_ProgressLevel)\r\n{\r\nstrcpy(Controller->ProgressBuffer, Buffer);\r\nController->ProgressBufferLength = Length;\r\nif (Controller->EphemeralProgressMessage)\r\n{\r\nif (time_after_eq(jiffies, Controller->LastProgressReportTime\r\n+ DAC960_ProgressReportingInterval))\r\n{\r\nprintk("%sDAC960#%d: %s", DAC960_MessageLevelMap[MessageLevel],\r\nController->ControllerNumber, Buffer);\r\nController->LastProgressReportTime = jiffies;\r\n}\r\n}\r\nelse printk("%sDAC960#%d: %s", DAC960_MessageLevelMap[MessageLevel],\r\nController->ControllerNumber, Buffer);\r\n}\r\nelse if (MessageLevel == DAC960_UserCriticalLevel)\r\n{\r\nstrcpy(&Controller->UserStatusBuffer[Controller->UserStatusLength],\r\nBuffer);\r\nController->UserStatusLength += Length;\r\nif (Buffer[0] != '\n' || Length > 1)\r\nprintk("%sDAC960#%d: %s", DAC960_MessageLevelMap[MessageLevel],\r\nController->ControllerNumber, Buffer);\r\n}\r\nelse\r\n{\r\nif (BeginningOfLine)\r\nprintk("%sDAC960#%d: %s", DAC960_MessageLevelMap[MessageLevel],\r\nController->ControllerNumber, Buffer);\r\nelse printk("%s", Buffer);\r\n}\r\nBeginningOfLine = (Buffer[Length-1] == '\n');\r\n}\r\nstatic bool DAC960_ParsePhysicalDevice(DAC960_Controller_T *Controller,\r\nchar *UserCommandString,\r\nunsigned char *Channel,\r\nunsigned char *TargetID)\r\n{\r\nchar *NewUserCommandString = UserCommandString;\r\nunsigned long XChannel, XTargetID;\r\nwhile (*UserCommandString == ' ') UserCommandString++;\r\nif (UserCommandString == NewUserCommandString)\r\nreturn false;\r\nXChannel = simple_strtoul(UserCommandString, &NewUserCommandString, 10);\r\nif (NewUserCommandString == UserCommandString ||\r\n*NewUserCommandString != ':' ||\r\nXChannel >= Controller->Channels)\r\nreturn false;\r\nUserCommandString = ++NewUserCommandString;\r\nXTargetID = simple_strtoul(UserCommandString, &NewUserCommandString, 10);\r\nif (NewUserCommandString == UserCommandString ||\r\n*NewUserCommandString != '\0' ||\r\nXTargetID >= Controller->Targets)\r\nreturn false;\r\n*Channel = XChannel;\r\n*TargetID = XTargetID;\r\nreturn true;\r\n}\r\nstatic bool DAC960_ParseLogicalDrive(DAC960_Controller_T *Controller,\r\nchar *UserCommandString,\r\nunsigned char *LogicalDriveNumber)\r\n{\r\nchar *NewUserCommandString = UserCommandString;\r\nunsigned long XLogicalDriveNumber;\r\nwhile (*UserCommandString == ' ') UserCommandString++;\r\nif (UserCommandString == NewUserCommandString)\r\nreturn false;\r\nXLogicalDriveNumber =\r\nsimple_strtoul(UserCommandString, &NewUserCommandString, 10);\r\nif (NewUserCommandString == UserCommandString ||\r\n*NewUserCommandString != '\0' ||\r\nXLogicalDriveNumber > DAC960_MaxLogicalDrives - 1)\r\nreturn false;\r\n*LogicalDriveNumber = XLogicalDriveNumber;\r\nreturn true;\r\n}\r\nstatic void DAC960_V1_SetDeviceState(DAC960_Controller_T *Controller,\r\nDAC960_Command_T *Command,\r\nunsigned char Channel,\r\nunsigned char TargetID,\r\nDAC960_V1_PhysicalDeviceState_T\r\nDeviceState,\r\nconst unsigned char *DeviceStateString)\r\n{\r\nDAC960_V1_CommandMailbox_T *CommandMailbox = &Command->V1.CommandMailbox;\r\nCommandMailbox->Type3D.CommandOpcode = DAC960_V1_StartDevice;\r\nCommandMailbox->Type3D.Channel = Channel;\r\nCommandMailbox->Type3D.TargetID = TargetID;\r\nCommandMailbox->Type3D.DeviceState = DeviceState;\r\nCommandMailbox->Type3D.Modifier = 0;\r\nDAC960_ExecuteCommand(Command);\r\nswitch (Command->V1.CommandStatus)\r\n{\r\ncase DAC960_V1_NormalCompletion:\r\nDAC960_UserCritical("%s of Physical Device %d:%d Succeeded\n", Controller,\r\nDeviceStateString, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_UnableToStartDevice:\r\nDAC960_UserCritical("%s of Physical Device %d:%d Failed - "\r\n"Unable to Start Device\n", Controller,\r\nDeviceStateString, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_NoDeviceAtAddress:\r\nDAC960_UserCritical("%s of Physical Device %d:%d Failed - "\r\n"No Device at Address\n", Controller,\r\nDeviceStateString, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_InvalidChannelOrTargetOrModifier:\r\nDAC960_UserCritical("%s of Physical Device %d:%d Failed - "\r\n"Invalid Channel or Target or Modifier\n",\r\nController, DeviceStateString, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_ChannelBusy:\r\nDAC960_UserCritical("%s of Physical Device %d:%d Failed - "\r\n"Channel Busy\n", Controller,\r\nDeviceStateString, Channel, TargetID);\r\nbreak;\r\ndefault:\r\nDAC960_UserCritical("%s of Physical Device %d:%d Failed - "\r\n"Unexpected Status %04X\n", Controller,\r\nDeviceStateString, Channel, TargetID,\r\nCommand->V1.CommandStatus);\r\nbreak;\r\n}\r\n}\r\nstatic bool DAC960_V1_ExecuteUserCommand(DAC960_Controller_T *Controller,\r\nunsigned char *UserCommand)\r\n{\r\nDAC960_Command_T *Command;\r\nDAC960_V1_CommandMailbox_T *CommandMailbox;\r\nunsigned long flags;\r\nunsigned char Channel, TargetID, LogicalDriveNumber;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile ((Command = DAC960_AllocateCommand(Controller)) == NULL)\r\nDAC960_WaitForCommand(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nController->UserStatusLength = 0;\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox = &Command->V1.CommandMailbox;\r\nif (strcmp(UserCommand, "flush-cache") == 0)\r\n{\r\nCommandMailbox->Type3.CommandOpcode = DAC960_V1_Flush;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Cache Flush Completed\n", Controller);\r\n}\r\nelse if (strncmp(UserCommand, "kill", 4) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[4],\r\n&Channel, &TargetID))\r\n{\r\nDAC960_V1_DeviceState_T *DeviceState =\r\n&Controller->V1.DeviceState[Channel][TargetID];\r\nif (DeviceState->Present &&\r\nDeviceState->DeviceType == DAC960_V1_DiskType &&\r\nDeviceState->DeviceState != DAC960_V1_Device_Dead)\r\nDAC960_V1_SetDeviceState(Controller, Command, Channel, TargetID,\r\nDAC960_V1_Device_Dead, "Kill");\r\nelse DAC960_UserCritical("Kill of Physical Device %d:%d Illegal\n",\r\nController, Channel, TargetID);\r\n}\r\nelse if (strncmp(UserCommand, "make-online", 11) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[11],\r\n&Channel, &TargetID))\r\n{\r\nDAC960_V1_DeviceState_T *DeviceState =\r\n&Controller->V1.DeviceState[Channel][TargetID];\r\nif (DeviceState->Present &&\r\nDeviceState->DeviceType == DAC960_V1_DiskType &&\r\nDeviceState->DeviceState == DAC960_V1_Device_Dead)\r\nDAC960_V1_SetDeviceState(Controller, Command, Channel, TargetID,\r\nDAC960_V1_Device_Online, "Make Online");\r\nelse DAC960_UserCritical("Make Online of Physical Device %d:%d Illegal\n",\r\nController, Channel, TargetID);\r\n}\r\nelse if (strncmp(UserCommand, "make-standby", 12) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[12],\r\n&Channel, &TargetID))\r\n{\r\nDAC960_V1_DeviceState_T *DeviceState =\r\n&Controller->V1.DeviceState[Channel][TargetID];\r\nif (DeviceState->Present &&\r\nDeviceState->DeviceType == DAC960_V1_DiskType &&\r\nDeviceState->DeviceState == DAC960_V1_Device_Dead)\r\nDAC960_V1_SetDeviceState(Controller, Command, Channel, TargetID,\r\nDAC960_V1_Device_Standby, "Make Standby");\r\nelse DAC960_UserCritical("Make Standby of Physical "\r\n"Device %d:%d Illegal\n",\r\nController, Channel, TargetID);\r\n}\r\nelse if (strncmp(UserCommand, "rebuild", 7) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[7],\r\n&Channel, &TargetID))\r\n{\r\nCommandMailbox->Type3D.CommandOpcode = DAC960_V1_RebuildAsync;\r\nCommandMailbox->Type3D.Channel = Channel;\r\nCommandMailbox->Type3D.TargetID = TargetID;\r\nDAC960_ExecuteCommand(Command);\r\nswitch (Command->V1.CommandStatus)\r\n{\r\ncase DAC960_V1_NormalCompletion:\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d Initiated\n",\r\nController, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_AttemptToRebuildOnlineDrive:\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d Failed - "\r\n"Attempt to Rebuild Online or "\r\n"Unresponsive Drive\n",\r\nController, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_NewDiskFailedDuringRebuild:\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d Failed - "\r\n"New Disk Failed During Rebuild\n",\r\nController, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_InvalidDeviceAddress:\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d Failed - "\r\n"Invalid Device Address\n",\r\nController, Channel, TargetID);\r\nbreak;\r\ncase DAC960_V1_RebuildOrCheckAlreadyInProgress:\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d Failed - "\r\n"Rebuild or Consistency Check Already "\r\n"in Progress\n", Controller, Channel, TargetID);\r\nbreak;\r\ndefault:\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d Failed - "\r\n"Unexpected Status %04X\n", Controller,\r\nChannel, TargetID, Command->V1.CommandStatus);\r\nbreak;\r\n}\r\n}\r\nelse if (strncmp(UserCommand, "check-consistency", 17) == 0 &&\r\nDAC960_ParseLogicalDrive(Controller, &UserCommand[17],\r\n&LogicalDriveNumber))\r\n{\r\nCommandMailbox->Type3C.CommandOpcode = DAC960_V1_CheckConsistencyAsync;\r\nCommandMailbox->Type3C.LogicalDriveNumber = LogicalDriveNumber;\r\nCommandMailbox->Type3C.AutoRestore = true;\r\nDAC960_ExecuteCommand(Command);\r\nswitch (Command->V1.CommandStatus)\r\n{\r\ncase DAC960_V1_NormalCompletion:\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) Initiated\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nbreak;\r\ncase DAC960_V1_DependentDiskIsDead:\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) Failed - "\r\n"Dependent Physical Device is DEAD\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nbreak;\r\ncase DAC960_V1_InvalidOrNonredundantLogicalDrive:\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) Failed - "\r\n"Invalid or Nonredundant Logical Drive\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nbreak;\r\ncase DAC960_V1_RebuildOrCheckAlreadyInProgress:\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) Failed - Rebuild or "\r\n"Consistency Check Already in Progress\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber);\r\nbreak;\r\ndefault:\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) Failed - "\r\n"Unexpected Status %04X\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber, Command->V1.CommandStatus);\r\nbreak;\r\n}\r\n}\r\nelse if (strcmp(UserCommand, "cancel-rebuild") == 0 ||\r\nstrcmp(UserCommand, "cancel-consistency-check") == 0)\r\n{\r\nunsigned char *OldRebuildRateConstant;\r\ndma_addr_t OldRebuildRateConstantDMA;\r\nOldRebuildRateConstant = pci_alloc_consistent( Controller->PCIDevice,\r\nsizeof(char), &OldRebuildRateConstantDMA);\r\nif (OldRebuildRateConstant == NULL) {\r\nDAC960_UserCritical("Cancellation of Rebuild or "\r\n"Consistency Check Failed - "\r\n"Out of Memory",\r\nController);\r\ngoto failure;\r\n}\r\nCommandMailbox->Type3R.CommandOpcode = DAC960_V1_RebuildControl;\r\nCommandMailbox->Type3R.RebuildRateConstant = 0xFF;\r\nCommandMailbox->Type3R.BusAddress = OldRebuildRateConstantDMA;\r\nDAC960_ExecuteCommand(Command);\r\nswitch (Command->V1.CommandStatus)\r\n{\r\ncase DAC960_V1_NormalCompletion:\r\nDAC960_UserCritical("Rebuild or Consistency Check Cancelled\n",\r\nController);\r\nbreak;\r\ndefault:\r\nDAC960_UserCritical("Cancellation of Rebuild or "\r\n"Consistency Check Failed - "\r\n"Unexpected Status %04X\n",\r\nController, Command->V1.CommandStatus);\r\nbreak;\r\n}\r\nfailure:\r\npci_free_consistent(Controller->PCIDevice, sizeof(char),\r\nOldRebuildRateConstant, OldRebuildRateConstantDMA);\r\n}\r\nelse DAC960_UserCritical("Illegal User Command: '%s'\n",\r\nController, UserCommand);\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_DeallocateCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn true;\r\n}\r\nstatic bool DAC960_V2_TranslatePhysicalDevice(DAC960_Command_T *Command,\r\nunsigned char Channel,\r\nunsigned char TargetID,\r\nunsigned short\r\n*LogicalDeviceNumber)\r\n{\r\nDAC960_V2_CommandMailbox_T SavedCommandMailbox, *CommandMailbox;\r\nDAC960_Controller_T *Controller = Command->Controller;\r\nCommandMailbox = &Command->V2.CommandMailbox;\r\nmemcpy(&SavedCommandMailbox, CommandMailbox,\r\nsizeof(DAC960_V2_CommandMailbox_T));\r\nCommandMailbox->PhysicalDeviceInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->PhysicalDeviceInfo.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->PhysicalDeviceInfo.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->PhysicalDeviceInfo.DataTransferSize =\r\nsizeof(DAC960_V2_PhysicalToLogicalDevice_T);\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.TargetID = TargetID;\r\nCommandMailbox->PhysicalDeviceInfo.PhysicalDevice.Channel = Channel;\r\nCommandMailbox->PhysicalDeviceInfo.IOCTL_Opcode =\r\nDAC960_V2_TranslatePhysicalToLogicalDevice;\r\nCommandMailbox->Common.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.PhysicalToLogicalDeviceDMA;\r\nCommandMailbox->Common.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->Common.DataTransferSize;\r\nDAC960_ExecuteCommand(Command);\r\n*LogicalDeviceNumber = Controller->V2.PhysicalToLogicalDevice->LogicalDeviceNumber;\r\nmemcpy(CommandMailbox, &SavedCommandMailbox,\r\nsizeof(DAC960_V2_CommandMailbox_T));\r\nreturn (Command->V2.CommandStatus == DAC960_V2_NormalCompletion);\r\n}\r\nstatic bool DAC960_V2_ExecuteUserCommand(DAC960_Controller_T *Controller,\r\nunsigned char *UserCommand)\r\n{\r\nDAC960_Command_T *Command;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox;\r\nunsigned long flags;\r\nunsigned char Channel, TargetID, LogicalDriveNumber;\r\nunsigned short LogicalDeviceNumber;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile ((Command = DAC960_AllocateCommand(Controller)) == NULL)\r\nDAC960_WaitForCommand(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nController->UserStatusLength = 0;\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox = &Command->V2.CommandMailbox;\r\nCommandMailbox->Common.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->Common.CommandControlBits.DataTransferControllerToHost = true;\r\nCommandMailbox->Common.CommandControlBits.NoAutoRequestSense = true;\r\nif (strcmp(UserCommand, "flush-cache") == 0)\r\n{\r\nCommandMailbox->DeviceOperation.IOCTL_Opcode = DAC960_V2_PauseDevice;\r\nCommandMailbox->DeviceOperation.OperationDevice =\r\nDAC960_V2_RAID_Controller;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Cache Flush Completed\n", Controller);\r\n}\r\nelse if (strncmp(UserCommand, "kill", 4) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[4],\r\n&Channel, &TargetID) &&\r\nDAC960_V2_TranslatePhysicalDevice(Command, Channel, TargetID,\r\n&LogicalDeviceNumber))\r\n{\r\nCommandMailbox->SetDeviceState.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDeviceNumber;\r\nCommandMailbox->SetDeviceState.IOCTL_Opcode =\r\nDAC960_V2_SetDeviceState;\r\nCommandMailbox->SetDeviceState.DeviceState.PhysicalDeviceState =\r\nDAC960_V2_Device_Dead;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Kill of Physical Device %d:%d %s\n",\r\nController, Channel, TargetID,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Succeeded" : "Failed"));\r\n}\r\nelse if (strncmp(UserCommand, "make-online", 11) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[11],\r\n&Channel, &TargetID) &&\r\nDAC960_V2_TranslatePhysicalDevice(Command, Channel, TargetID,\r\n&LogicalDeviceNumber))\r\n{\r\nCommandMailbox->SetDeviceState.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDeviceNumber;\r\nCommandMailbox->SetDeviceState.IOCTL_Opcode =\r\nDAC960_V2_SetDeviceState;\r\nCommandMailbox->SetDeviceState.DeviceState.PhysicalDeviceState =\r\nDAC960_V2_Device_Online;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Make Online of Physical Device %d:%d %s\n",\r\nController, Channel, TargetID,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Succeeded" : "Failed"));\r\n}\r\nelse if (strncmp(UserCommand, "make-standby", 12) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[12],\r\n&Channel, &TargetID) &&\r\nDAC960_V2_TranslatePhysicalDevice(Command, Channel, TargetID,\r\n&LogicalDeviceNumber))\r\n{\r\nCommandMailbox->SetDeviceState.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDeviceNumber;\r\nCommandMailbox->SetDeviceState.IOCTL_Opcode =\r\nDAC960_V2_SetDeviceState;\r\nCommandMailbox->SetDeviceState.DeviceState.PhysicalDeviceState =\r\nDAC960_V2_Device_Standby;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Make Standby of Physical Device %d:%d %s\n",\r\nController, Channel, TargetID,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Succeeded" : "Failed"));\r\n}\r\nelse if (strncmp(UserCommand, "rebuild", 7) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[7],\r\n&Channel, &TargetID) &&\r\nDAC960_V2_TranslatePhysicalDevice(Command, Channel, TargetID,\r\n&LogicalDeviceNumber))\r\n{\r\nCommandMailbox->LogicalDeviceInfo.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDeviceNumber;\r\nCommandMailbox->LogicalDeviceInfo.IOCTL_Opcode =\r\nDAC960_V2_RebuildDeviceStart;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d %s\n",\r\nController, Channel, TargetID,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Initiated" : "Not Initiated"));\r\n}\r\nelse if (strncmp(UserCommand, "cancel-rebuild", 14) == 0 &&\r\nDAC960_ParsePhysicalDevice(Controller, &UserCommand[14],\r\n&Channel, &TargetID) &&\r\nDAC960_V2_TranslatePhysicalDevice(Command, Channel, TargetID,\r\n&LogicalDeviceNumber))\r\n{\r\nCommandMailbox->LogicalDeviceInfo.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDeviceNumber;\r\nCommandMailbox->LogicalDeviceInfo.IOCTL_Opcode =\r\nDAC960_V2_RebuildDeviceStop;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Rebuild of Physical Device %d:%d %s\n",\r\nController, Channel, TargetID,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Cancelled" : "Not Cancelled"));\r\n}\r\nelse if (strncmp(UserCommand, "check-consistency", 17) == 0 &&\r\nDAC960_ParseLogicalDrive(Controller, &UserCommand[17],\r\n&LogicalDriveNumber))\r\n{\r\nCommandMailbox->ConsistencyCheck.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDriveNumber;\r\nCommandMailbox->ConsistencyCheck.IOCTL_Opcode =\r\nDAC960_V2_ConsistencyCheckStart;\r\nCommandMailbox->ConsistencyCheck.RestoreConsistency = true;\r\nCommandMailbox->ConsistencyCheck.InitializedAreaOnly = false;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) %s\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Initiated" : "Not Initiated"));\r\n}\r\nelse if (strncmp(UserCommand, "cancel-consistency-check", 24) == 0 &&\r\nDAC960_ParseLogicalDrive(Controller, &UserCommand[24],\r\n&LogicalDriveNumber))\r\n{\r\nCommandMailbox->ConsistencyCheck.LogicalDevice.LogicalDeviceNumber =\r\nLogicalDriveNumber;\r\nCommandMailbox->ConsistencyCheck.IOCTL_Opcode =\r\nDAC960_V2_ConsistencyCheckStop;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Consistency Check of Logical Drive %d "\r\n"(/dev/rd/c%dd%d) %s\n",\r\nController, LogicalDriveNumber,\r\nController->ControllerNumber,\r\nLogicalDriveNumber,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Cancelled" : "Not Cancelled"));\r\n}\r\nelse if (strcmp(UserCommand, "perform-discovery") == 0)\r\n{\r\nCommandMailbox->Common.IOCTL_Opcode = DAC960_V2_StartDiscovery;\r\nDAC960_ExecuteCommand(Command);\r\nDAC960_UserCritical("Discovery %s\n", Controller,\r\n(Command->V2.CommandStatus\r\n== DAC960_V2_NormalCompletion\r\n? "Initiated" : "Not Initiated"));\r\nif (Command->V2.CommandStatus == DAC960_V2_NormalCompletion)\r\n{\r\nCommandMailbox->ControllerInfo.CommandOpcode = DAC960_V2_IOCTL;\r\nCommandMailbox->ControllerInfo.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->ControllerInfo.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->ControllerInfo.DataTransferSize =\r\nsizeof(DAC960_V2_ControllerInfo_T);\r\nCommandMailbox->ControllerInfo.ControllerNumber = 0;\r\nCommandMailbox->ControllerInfo.IOCTL_Opcode =\r\nDAC960_V2_GetControllerInfo;\r\nCommandMailbox->ControllerInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer =\r\nController->V2.NewControllerInformationDMA;\r\nCommandMailbox->ControllerInfo.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->ControllerInfo.DataTransferSize;\r\nDAC960_ExecuteCommand(Command);\r\nwhile (Controller->V2.NewControllerInformation->PhysicalScanActive)\r\n{\r\nDAC960_ExecuteCommand(Command);\r\nsleep_on_timeout(&Controller->CommandWaitQueue, HZ);\r\n}\r\nDAC960_UserCritical("Discovery Completed\n", Controller);\r\n}\r\n}\r\nelse if (strcmp(UserCommand, "suppress-enclosure-messages") == 0)\r\nController->SuppressEnclosureMessages = true;\r\nelse DAC960_UserCritical("Illegal User Command: '%s'\n",\r\nController, UserCommand);\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_DeallocateCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nreturn true;\r\n}\r\nstatic int dac960_proc_show(struct seq_file *m, void *v)\r\n{\r\nunsigned char *StatusMessage = "OK\n";\r\nint ControllerNumber;\r\nfor (ControllerNumber = 0;\r\nControllerNumber < DAC960_ControllerCount;\r\nControllerNumber++)\r\n{\r\nDAC960_Controller_T *Controller = DAC960_Controllers[ControllerNumber];\r\nif (Controller == NULL) continue;\r\nif (Controller->MonitoringAlertMode)\r\n{\r\nStatusMessage = "ALERT\n";\r\nbreak;\r\n}\r\n}\r\nseq_puts(m, StatusMessage);\r\nreturn 0;\r\n}\r\nstatic int dac960_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dac960_proc_show, NULL);\r\n}\r\nstatic int dac960_initial_status_proc_show(struct seq_file *m, void *v)\r\n{\r\nDAC960_Controller_T *Controller = (DAC960_Controller_T *)m->private;\r\nseq_printf(m, "%.*s", Controller->InitialStatusLength, Controller->CombinedStatusBuffer);\r\nreturn 0;\r\n}\r\nstatic int dac960_initial_status_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dac960_initial_status_proc_show, PDE(inode)->data);\r\n}\r\nstatic int dac960_current_status_proc_show(struct seq_file *m, void *v)\r\n{\r\nDAC960_Controller_T *Controller = (DAC960_Controller_T *) m->private;\r\nunsigned char *StatusMessage =\r\n"No Rebuild or Consistency Check in Progress\n";\r\nint ProgressMessageLength = strlen(StatusMessage);\r\nif (jiffies != Controller->LastCurrentStatusTime)\r\n{\r\nController->CurrentStatusLength = 0;\r\nDAC960_AnnounceDriver(Controller);\r\nDAC960_ReportControllerConfiguration(Controller);\r\nDAC960_ReportDeviceConfiguration(Controller);\r\nif (Controller->ProgressBufferLength > 0)\r\nProgressMessageLength = Controller->ProgressBufferLength;\r\nif (DAC960_CheckStatusBuffer(Controller, 2 + ProgressMessageLength))\r\n{\r\nunsigned char *CurrentStatusBuffer = Controller->CurrentStatusBuffer;\r\nCurrentStatusBuffer[Controller->CurrentStatusLength++] = ' ';\r\nCurrentStatusBuffer[Controller->CurrentStatusLength++] = ' ';\r\nif (Controller->ProgressBufferLength > 0)\r\nstrcpy(&CurrentStatusBuffer[Controller->CurrentStatusLength],\r\nController->ProgressBuffer);\r\nelse\r\nstrcpy(&CurrentStatusBuffer[Controller->CurrentStatusLength],\r\nStatusMessage);\r\nController->CurrentStatusLength += ProgressMessageLength;\r\n}\r\nController->LastCurrentStatusTime = jiffies;\r\n}\r\nseq_printf(m, "%.*s", Controller->CurrentStatusLength, Controller->CurrentStatusBuffer);\r\nreturn 0;\r\n}\r\nstatic int dac960_current_status_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dac960_current_status_proc_show, PDE(inode)->data);\r\n}\r\nstatic int dac960_user_command_proc_show(struct seq_file *m, void *v)\r\n{\r\nDAC960_Controller_T *Controller = (DAC960_Controller_T *)m->private;\r\nseq_printf(m, "%.*s", Controller->UserStatusLength, Controller->UserStatusBuffer);\r\nreturn 0;\r\n}\r\nstatic int dac960_user_command_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dac960_user_command_proc_show, PDE(inode)->data);\r\n}\r\nstatic ssize_t dac960_user_command_proc_write(struct file *file,\r\nconst char __user *Buffer,\r\nsize_t Count, loff_t *pos)\r\n{\r\nDAC960_Controller_T *Controller = (DAC960_Controller_T *) PDE(file->f_path.dentry->d_inode)->data;\r\nunsigned char CommandBuffer[80];\r\nint Length;\r\nif (Count > sizeof(CommandBuffer)-1) return -EINVAL;\r\nif (copy_from_user(CommandBuffer, Buffer, Count)) return -EFAULT;\r\nCommandBuffer[Count] = '\0';\r\nLength = strlen(CommandBuffer);\r\nif (Length > 0 && CommandBuffer[Length-1] == '\n')\r\nCommandBuffer[--Length] = '\0';\r\nif (Controller->FirmwareType == DAC960_V1_Controller)\r\nreturn (DAC960_V1_ExecuteUserCommand(Controller, CommandBuffer)\r\n? Count : -EBUSY);\r\nelse\r\nreturn (DAC960_V2_ExecuteUserCommand(Controller, CommandBuffer)\r\n? Count : -EBUSY);\r\n}\r\nstatic void DAC960_CreateProcEntries(DAC960_Controller_T *Controller)\r\n{\r\nstruct proc_dir_entry *ControllerProcEntry;\r\nif (DAC960_ProcDirectoryEntry == NULL) {\r\nDAC960_ProcDirectoryEntry = proc_mkdir("rd", NULL);\r\nproc_create("status", 0, DAC960_ProcDirectoryEntry,\r\n&dac960_proc_fops);\r\n}\r\nsprintf(Controller->ControllerName, "c%d", Controller->ControllerNumber);\r\nControllerProcEntry = proc_mkdir(Controller->ControllerName,\r\nDAC960_ProcDirectoryEntry);\r\nproc_create_data("initial_status", 0, ControllerProcEntry, &dac960_initial_status_proc_fops, Controller);\r\nproc_create_data("current_status", 0, ControllerProcEntry, &dac960_current_status_proc_fops, Controller);\r\nproc_create_data("user_command", S_IWUSR | S_IRUSR, ControllerProcEntry, &dac960_user_command_proc_fops, Controller);\r\nController->ControllerProcEntry = ControllerProcEntry;\r\n}\r\nstatic void DAC960_DestroyProcEntries(DAC960_Controller_T *Controller)\r\n{\r\nif (Controller->ControllerProcEntry == NULL)\r\nreturn;\r\nremove_proc_entry("initial_status", Controller->ControllerProcEntry);\r\nremove_proc_entry("current_status", Controller->ControllerProcEntry);\r\nremove_proc_entry("user_command", Controller->ControllerProcEntry);\r\nremove_proc_entry(Controller->ControllerName, DAC960_ProcDirectoryEntry);\r\nController->ControllerProcEntry = NULL;\r\n}\r\nstatic long DAC960_gam_ioctl(struct file *file, unsigned int Request,\r\nunsigned long Argument)\r\n{\r\nlong ErrorCode = 0;\r\nif (!capable(CAP_SYS_ADMIN)) return -EACCES;\r\nmutex_lock(&DAC960_mutex);\r\nswitch (Request)\r\n{\r\ncase DAC960_IOCTL_GET_CONTROLLER_COUNT:\r\nErrorCode = DAC960_ControllerCount;\r\nbreak;\r\ncase DAC960_IOCTL_GET_CONTROLLER_INFO:\r\n{\r\nDAC960_ControllerInfo_T __user *UserSpaceControllerInfo =\r\n(DAC960_ControllerInfo_T __user *) Argument;\r\nDAC960_ControllerInfo_T ControllerInfo;\r\nDAC960_Controller_T *Controller;\r\nint ControllerNumber;\r\nif (UserSpaceControllerInfo == NULL)\r\nErrorCode = -EINVAL;\r\nelse ErrorCode = get_user(ControllerNumber,\r\n&UserSpaceControllerInfo->ControllerNumber);\r\nif (ErrorCode != 0)\r\nbreak;\r\nErrorCode = -ENXIO;\r\nif (ControllerNumber < 0 ||\r\nControllerNumber > DAC960_ControllerCount - 1) {\r\nbreak;\r\n}\r\nController = DAC960_Controllers[ControllerNumber];\r\nif (Controller == NULL)\r\nbreak;\r\nmemset(&ControllerInfo, 0, sizeof(DAC960_ControllerInfo_T));\r\nControllerInfo.ControllerNumber = ControllerNumber;\r\nControllerInfo.FirmwareType = Controller->FirmwareType;\r\nControllerInfo.Channels = Controller->Channels;\r\nControllerInfo.Targets = Controller->Targets;\r\nControllerInfo.PCI_Bus = Controller->Bus;\r\nControllerInfo.PCI_Device = Controller->Device;\r\nControllerInfo.PCI_Function = Controller->Function;\r\nControllerInfo.IRQ_Channel = Controller->IRQ_Channel;\r\nControllerInfo.PCI_Address = Controller->PCI_Address;\r\nstrcpy(ControllerInfo.ModelName, Controller->ModelName);\r\nstrcpy(ControllerInfo.FirmwareVersion, Controller->FirmwareVersion);\r\nErrorCode = (copy_to_user(UserSpaceControllerInfo, &ControllerInfo,\r\nsizeof(DAC960_ControllerInfo_T)) ? -EFAULT : 0);\r\nbreak;\r\n}\r\ncase DAC960_IOCTL_V1_EXECUTE_COMMAND:\r\n{\r\nDAC960_V1_UserCommand_T __user *UserSpaceUserCommand =\r\n(DAC960_V1_UserCommand_T __user *) Argument;\r\nDAC960_V1_UserCommand_T UserCommand;\r\nDAC960_Controller_T *Controller;\r\nDAC960_Command_T *Command = NULL;\r\nDAC960_V1_CommandOpcode_T CommandOpcode;\r\nDAC960_V1_CommandStatus_T CommandStatus;\r\nDAC960_V1_DCDB_T DCDB;\r\nDAC960_V1_DCDB_T *DCDB_IOBUF = NULL;\r\ndma_addr_t DCDB_IOBUFDMA;\r\nunsigned long flags;\r\nint ControllerNumber, DataTransferLength;\r\nunsigned char *DataTransferBuffer = NULL;\r\ndma_addr_t DataTransferBufferDMA;\r\nif (UserSpaceUserCommand == NULL) {\r\nErrorCode = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(&UserCommand, UserSpaceUserCommand,\r\nsizeof(DAC960_V1_UserCommand_T))) {\r\nErrorCode = -EFAULT;\r\nbreak;\r\n}\r\nControllerNumber = UserCommand.ControllerNumber;\r\nErrorCode = -ENXIO;\r\nif (ControllerNumber < 0 ||\r\nControllerNumber > DAC960_ControllerCount - 1)\r\nbreak;\r\nController = DAC960_Controllers[ControllerNumber];\r\nif (Controller == NULL)\r\nbreak;\r\nErrorCode = -EINVAL;\r\nif (Controller->FirmwareType != DAC960_V1_Controller)\r\nbreak;\r\nCommandOpcode = UserCommand.CommandMailbox.Common.CommandOpcode;\r\nDataTransferLength = UserCommand.DataTransferLength;\r\nif (CommandOpcode & 0x80)\r\nbreak;\r\nif (CommandOpcode == DAC960_V1_DCDB)\r\n{\r\nif (copy_from_user(&DCDB, UserCommand.DCDB,\r\nsizeof(DAC960_V1_DCDB_T))) {\r\nErrorCode = -EFAULT;\r\nbreak;\r\n}\r\nif (DCDB.Channel >= DAC960_V1_MaxChannels)\r\nbreak;\r\nif (!((DataTransferLength == 0 &&\r\nDCDB.Direction\r\n== DAC960_V1_DCDB_NoDataTransfer) ||\r\n(DataTransferLength > 0 &&\r\nDCDB.Direction\r\n== DAC960_V1_DCDB_DataTransferDeviceToSystem) ||\r\n(DataTransferLength < 0 &&\r\nDCDB.Direction\r\n== DAC960_V1_DCDB_DataTransferSystemToDevice)))\r\nbreak;\r\nif (((DCDB.TransferLengthHigh4 << 16) | DCDB.TransferLength)\r\n!= abs(DataTransferLength))\r\nbreak;\r\nDCDB_IOBUF = pci_alloc_consistent(Controller->PCIDevice,\r\nsizeof(DAC960_V1_DCDB_T), &DCDB_IOBUFDMA);\r\nif (DCDB_IOBUF == NULL) {\r\nErrorCode = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nErrorCode = -ENOMEM;\r\nif (DataTransferLength > 0)\r\n{\r\nDataTransferBuffer = pci_alloc_consistent(Controller->PCIDevice,\r\nDataTransferLength, &DataTransferBufferDMA);\r\nif (DataTransferBuffer == NULL)\r\nbreak;\r\nmemset(DataTransferBuffer, 0, DataTransferLength);\r\n}\r\nelse if (DataTransferLength < 0)\r\n{\r\nDataTransferBuffer = pci_alloc_consistent(Controller->PCIDevice,\r\n-DataTransferLength, &DataTransferBufferDMA);\r\nif (DataTransferBuffer == NULL)\r\nbreak;\r\nif (copy_from_user(DataTransferBuffer,\r\nUserCommand.DataTransferBuffer,\r\n-DataTransferLength)) {\r\nErrorCode = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nif (CommandOpcode == DAC960_V1_DCDB)\r\n{\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile ((Command = DAC960_AllocateCommand(Controller)) == NULL)\r\nDAC960_WaitForCommand(Controller);\r\nwhile (Controller->V1.DirectCommandActive[DCDB.Channel]\r\n[DCDB.TargetID])\r\n{\r\nspin_unlock_irq(&Controller->queue_lock);\r\n__wait_event(Controller->CommandWaitQueue,\r\n!Controller->V1.DirectCommandActive\r\n[DCDB.Channel][DCDB.TargetID]);\r\nspin_lock_irq(&Controller->queue_lock);\r\n}\r\nController->V1.DirectCommandActive[DCDB.Channel]\r\n[DCDB.TargetID] = true;\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nmemcpy(&Command->V1.CommandMailbox, &UserCommand.CommandMailbox,\r\nsizeof(DAC960_V1_CommandMailbox_T));\r\nCommand->V1.CommandMailbox.Type3.BusAddress = DCDB_IOBUFDMA;\r\nDCDB.BusAddress = DataTransferBufferDMA;\r\nmemcpy(DCDB_IOBUF, &DCDB, sizeof(DAC960_V1_DCDB_T));\r\n}\r\nelse\r\n{\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile ((Command = DAC960_AllocateCommand(Controller)) == NULL)\r\nDAC960_WaitForCommand(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nDAC960_V1_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nmemcpy(&Command->V1.CommandMailbox, &UserCommand.CommandMailbox,\r\nsizeof(DAC960_V1_CommandMailbox_T));\r\nif (DataTransferBuffer != NULL)\r\nCommand->V1.CommandMailbox.Type3.BusAddress =\r\nDataTransferBufferDMA;\r\n}\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V1.CommandStatus;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_DeallocateCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nif (DataTransferLength > 0)\r\n{\r\nif (copy_to_user(UserCommand.DataTransferBuffer,\r\nDataTransferBuffer, DataTransferLength)) {\r\nErrorCode = -EFAULT;\r\ngoto Failure1;\r\n}\r\n}\r\nif (CommandOpcode == DAC960_V1_DCDB)\r\n{\r\nController->V1.DirectCommandActive[DCDB.Channel]\r\n[DCDB.TargetID] = false;\r\nif (copy_to_user(UserCommand.DCDB, DCDB_IOBUF,\r\nsizeof(DAC960_V1_DCDB_T))) {\r\nErrorCode = -EFAULT;\r\ngoto Failure1;\r\n}\r\n}\r\nErrorCode = CommandStatus;\r\nFailure1:\r\nif (DataTransferBuffer != NULL)\r\npci_free_consistent(Controller->PCIDevice, abs(DataTransferLength),\r\nDataTransferBuffer, DataTransferBufferDMA);\r\nif (DCDB_IOBUF != NULL)\r\npci_free_consistent(Controller->PCIDevice, sizeof(DAC960_V1_DCDB_T),\r\nDCDB_IOBUF, DCDB_IOBUFDMA);\r\nbreak;\r\n}\r\ncase DAC960_IOCTL_V2_EXECUTE_COMMAND:\r\n{\r\nDAC960_V2_UserCommand_T __user *UserSpaceUserCommand =\r\n(DAC960_V2_UserCommand_T __user *) Argument;\r\nDAC960_V2_UserCommand_T UserCommand;\r\nDAC960_Controller_T *Controller;\r\nDAC960_Command_T *Command = NULL;\r\nDAC960_V2_CommandMailbox_T *CommandMailbox;\r\nDAC960_V2_CommandStatus_T CommandStatus;\r\nunsigned long flags;\r\nint ControllerNumber, DataTransferLength;\r\nint DataTransferResidue, RequestSenseLength;\r\nunsigned char *DataTransferBuffer = NULL;\r\ndma_addr_t DataTransferBufferDMA;\r\nunsigned char *RequestSenseBuffer = NULL;\r\ndma_addr_t RequestSenseBufferDMA;\r\nErrorCode = -EINVAL;\r\nif (UserSpaceUserCommand == NULL)\r\nbreak;\r\nif (copy_from_user(&UserCommand, UserSpaceUserCommand,\r\nsizeof(DAC960_V2_UserCommand_T))) {\r\nErrorCode = -EFAULT;\r\nbreak;\r\n}\r\nErrorCode = -ENXIO;\r\nControllerNumber = UserCommand.ControllerNumber;\r\nif (ControllerNumber < 0 ||\r\nControllerNumber > DAC960_ControllerCount - 1)\r\nbreak;\r\nController = DAC960_Controllers[ControllerNumber];\r\nif (Controller == NULL)\r\nbreak;\r\nif (Controller->FirmwareType != DAC960_V2_Controller){\r\nErrorCode = -EINVAL;\r\nbreak;\r\n}\r\nDataTransferLength = UserCommand.DataTransferLength;\r\nErrorCode = -ENOMEM;\r\nif (DataTransferLength > 0)\r\n{\r\nDataTransferBuffer = pci_alloc_consistent(Controller->PCIDevice,\r\nDataTransferLength, &DataTransferBufferDMA);\r\nif (DataTransferBuffer == NULL)\r\nbreak;\r\nmemset(DataTransferBuffer, 0, DataTransferLength);\r\n}\r\nelse if (DataTransferLength < 0)\r\n{\r\nDataTransferBuffer = pci_alloc_consistent(Controller->PCIDevice,\r\n-DataTransferLength, &DataTransferBufferDMA);\r\nif (DataTransferBuffer == NULL)\r\nbreak;\r\nif (copy_from_user(DataTransferBuffer,\r\nUserCommand.DataTransferBuffer,\r\n-DataTransferLength)) {\r\nErrorCode = -EFAULT;\r\ngoto Failure2;\r\n}\r\n}\r\nRequestSenseLength = UserCommand.RequestSenseLength;\r\nif (RequestSenseLength > 0)\r\n{\r\nRequestSenseBuffer = pci_alloc_consistent(Controller->PCIDevice,\r\nRequestSenseLength, &RequestSenseBufferDMA);\r\nif (RequestSenseBuffer == NULL)\r\n{\r\nErrorCode = -ENOMEM;\r\ngoto Failure2;\r\n}\r\nmemset(RequestSenseBuffer, 0, RequestSenseLength);\r\n}\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nwhile ((Command = DAC960_AllocateCommand(Controller)) == NULL)\r\nDAC960_WaitForCommand(Controller);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nDAC960_V2_ClearCommand(Command);\r\nCommand->CommandType = DAC960_ImmediateCommand;\r\nCommandMailbox = &Command->V2.CommandMailbox;\r\nmemcpy(CommandMailbox, &UserCommand.CommandMailbox,\r\nsizeof(DAC960_V2_CommandMailbox_T));\r\nCommandMailbox->Common.CommandControlBits\r\n.AdditionalScatterGatherListMemory = false;\r\nCommandMailbox->Common.CommandControlBits\r\n.NoAutoRequestSense = true;\r\nCommandMailbox->Common.DataTransferSize = 0;\r\nCommandMailbox->Common.DataTransferPageNumber = 0;\r\nmemset(&CommandMailbox->Common.DataTransferMemoryAddress, 0,\r\nsizeof(DAC960_V2_DataTransferMemoryAddress_T));\r\nif (DataTransferLength != 0)\r\n{\r\nif (DataTransferLength > 0)\r\n{\r\nCommandMailbox->Common.CommandControlBits\r\n.DataTransferControllerToHost = true;\r\nCommandMailbox->Common.DataTransferSize = DataTransferLength;\r\n}\r\nelse\r\n{\r\nCommandMailbox->Common.CommandControlBits\r\n.DataTransferControllerToHost = false;\r\nCommandMailbox->Common.DataTransferSize = -DataTransferLength;\r\n}\r\nCommandMailbox->Common.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentDataPointer = DataTransferBufferDMA;\r\nCommandMailbox->Common.DataTransferMemoryAddress\r\n.ScatterGatherSegments[0]\r\n.SegmentByteCount =\r\nCommandMailbox->Common.DataTransferSize;\r\n}\r\nif (RequestSenseLength > 0)\r\n{\r\nCommandMailbox->Common.CommandControlBits\r\n.NoAutoRequestSense = false;\r\nCommandMailbox->Common.RequestSenseSize = RequestSenseLength;\r\nCommandMailbox->Common.RequestSenseBusAddress =\r\nRequestSenseBufferDMA;\r\n}\r\nDAC960_ExecuteCommand(Command);\r\nCommandStatus = Command->V2.CommandStatus;\r\nRequestSenseLength = Command->V2.RequestSenseLength;\r\nDataTransferResidue = Command->V2.DataTransferResidue;\r\nspin_lock_irqsave(&Controller->queue_lock, flags);\r\nDAC960_DeallocateCommand(Command);\r\nspin_unlock_irqrestore(&Controller->queue_lock, flags);\r\nif (RequestSenseLength > UserCommand.RequestSenseLength)\r\nRequestSenseLength = UserCommand.RequestSenseLength;\r\nif (copy_to_user(&UserSpaceUserCommand->DataTransferLength,\r\n&DataTransferResidue,\r\nsizeof(DataTransferResidue))) {\r\nErrorCode = -EFAULT;\r\ngoto Failure2;\r\n}\r\nif (copy_to_user(&UserSpaceUserCommand->RequestSenseLength,\r\n&RequestSenseLength, sizeof(RequestSenseLength))) {\r\nErrorCode = -EFAULT;\r\ngoto Failure2;\r\n}\r\nif (DataTransferLength > 0)\r\n{\r\nif (copy_to_user(UserCommand.DataTransferBuffer,\r\nDataTransferBuffer, DataTransferLength)) {\r\nErrorCode = -EFAULT;\r\ngoto Failure2;\r\n}\r\n}\r\nif (RequestSenseLength > 0)\r\n{\r\nif (copy_to_user(UserCommand.RequestSenseBuffer,\r\nRequestSenseBuffer, RequestSenseLength)) {\r\nErrorCode = -EFAULT;\r\ngoto Failure2;\r\n}\r\n}\r\nErrorCode = CommandStatus;\r\nFailure2:\r\npci_free_consistent(Controller->PCIDevice, abs(DataTransferLength),\r\nDataTransferBuffer, DataTransferBufferDMA);\r\nif (RequestSenseBuffer != NULL)\r\npci_free_consistent(Controller->PCIDevice, RequestSenseLength,\r\nRequestSenseBuffer, RequestSenseBufferDMA);\r\nbreak;\r\n}\r\ncase DAC960_IOCTL_V2_GET_HEALTH_STATUS:\r\n{\r\nDAC960_V2_GetHealthStatus_T __user *UserSpaceGetHealthStatus =\r\n(DAC960_V2_GetHealthStatus_T __user *) Argument;\r\nDAC960_V2_GetHealthStatus_T GetHealthStatus;\r\nDAC960_V2_HealthStatusBuffer_T HealthStatusBuffer;\r\nDAC960_Controller_T *Controller;\r\nint ControllerNumber;\r\nif (UserSpaceGetHealthStatus == NULL) {\r\nErrorCode = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(&GetHealthStatus, UserSpaceGetHealthStatus,\r\nsizeof(DAC960_V2_GetHealthStatus_T))) {\r\nErrorCode = -EFAULT;\r\nbreak;\r\n}\r\nErrorCode = -ENXIO;\r\nControllerNumber = GetHealthStatus.ControllerNumber;\r\nif (ControllerNumber < 0 ||\r\nControllerNumber > DAC960_ControllerCount - 1)\r\nbreak;\r\nController = DAC960_Controllers[ControllerNumber];\r\nif (Controller == NULL)\r\nbreak;\r\nif (Controller->FirmwareType != DAC960_V2_Controller) {\r\nErrorCode = -EINVAL;\r\nbreak;\r\n}\r\nif (copy_from_user(&HealthStatusBuffer,\r\nGetHealthStatus.HealthStatusBuffer,\r\nsizeof(DAC960_V2_HealthStatusBuffer_T))) {\r\nErrorCode = -EFAULT;\r\nbreak;\r\n}\r\nwhile (Controller->V2.HealthStatusBuffer->StatusChangeCounter\r\n== HealthStatusBuffer.StatusChangeCounter &&\r\nController->V2.HealthStatusBuffer->NextEventSequenceNumber\r\n== HealthStatusBuffer.NextEventSequenceNumber)\r\n{\r\ninterruptible_sleep_on_timeout(&Controller->HealthStatusWaitQueue,\r\nDAC960_MonitoringTimerInterval);\r\nif (signal_pending(current)) {\r\nErrorCode = -EINTR;\r\nbreak;\r\n}\r\n}\r\nif (copy_to_user(GetHealthStatus.HealthStatusBuffer,\r\nController->V2.HealthStatusBuffer,\r\nsizeof(DAC960_V2_HealthStatusBuffer_T)))\r\nErrorCode = -EFAULT;\r\nelse\r\nErrorCode = 0;\r\n}\r\ndefault:\r\nErrorCode = -ENOTTY;\r\n}\r\nmutex_unlock(&DAC960_mutex);\r\nreturn ErrorCode;\r\n}\r\nstatic int DAC960_gam_init(void)\r\n{\r\nint ret;\r\nret = misc_register(&DAC960_gam_dev);\r\nif (ret)\r\nprintk(KERN_ERR "DAC960_gam: can't misc_register on minor %d\n", DAC960_GAM_MINOR);\r\nreturn ret;\r\n}\r\nstatic void DAC960_gam_cleanup(void)\r\n{\r\nmisc_deregister(&DAC960_gam_dev);\r\n}\r\nstatic int __init DAC960_init_module(void)\r\n{\r\nint ret;\r\nret = pci_register_driver(&DAC960_pci_driver);\r\n#ifdef DAC960_GAM_MINOR\r\nif (!ret)\r\nDAC960_gam_init();\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit DAC960_cleanup_module(void)\r\n{\r\nint i;\r\n#ifdef DAC960_GAM_MINOR\r\nDAC960_gam_cleanup();\r\n#endif\r\nfor (i = 0; i < DAC960_ControllerCount; i++) {\r\nDAC960_Controller_T *Controller = DAC960_Controllers[i];\r\nif (Controller == NULL)\r\ncontinue;\r\nDAC960_FinalizeController(Controller);\r\n}\r\nif (DAC960_ProcDirectoryEntry != NULL) {\r\nremove_proc_entry("rd/status", NULL);\r\nremove_proc_entry("rd", NULL);\r\n}\r\nDAC960_ControllerCount = 0;\r\npci_unregister_driver(&DAC960_pci_driver);\r\n}
