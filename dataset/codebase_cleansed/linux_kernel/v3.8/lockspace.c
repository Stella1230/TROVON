static ssize_t dlm_control_store(struct dlm_ls *ls, const char *buf, size_t len)\r\n{\r\nssize_t ret = len;\r\nint n = simple_strtol(buf, NULL, 0);\r\nls = dlm_find_lockspace_local(ls->ls_local_handle);\r\nif (!ls)\r\nreturn -EINVAL;\r\nswitch (n) {\r\ncase 0:\r\ndlm_ls_stop(ls);\r\nbreak;\r\ncase 1:\r\ndlm_ls_start(ls);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\ndlm_put_lockspace(ls);\r\nreturn ret;\r\n}\r\nstatic ssize_t dlm_event_store(struct dlm_ls *ls, const char *buf, size_t len)\r\n{\r\nls->ls_uevent_result = simple_strtol(buf, NULL, 0);\r\nset_bit(LSFL_UEVENT_WAIT, &ls->ls_flags);\r\nwake_up(&ls->ls_uevent_wait);\r\nreturn len;\r\n}\r\nstatic ssize_t dlm_id_show(struct dlm_ls *ls, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", ls->ls_global_id);\r\n}\r\nstatic ssize_t dlm_id_store(struct dlm_ls *ls, const char *buf, size_t len)\r\n{\r\nls->ls_global_id = simple_strtoul(buf, NULL, 0);\r\nreturn len;\r\n}\r\nstatic ssize_t dlm_nodir_show(struct dlm_ls *ls, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", dlm_no_directory(ls));\r\n}\r\nstatic ssize_t dlm_nodir_store(struct dlm_ls *ls, const char *buf, size_t len)\r\n{\r\nint val = simple_strtoul(buf, NULL, 0);\r\nif (val == 1)\r\nset_bit(LSFL_NODIR, &ls->ls_flags);\r\nreturn len;\r\n}\r\nstatic ssize_t dlm_recover_status_show(struct dlm_ls *ls, char *buf)\r\n{\r\nuint32_t status = dlm_recover_status(ls);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", status);\r\n}\r\nstatic ssize_t dlm_recover_nodeid_show(struct dlm_ls *ls, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ls->ls_recover_nodeid);\r\n}\r\nstatic ssize_t dlm_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dlm_ls *ls = container_of(kobj, struct dlm_ls, ls_kobj);\r\nstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\r\nreturn a->show ? a->show(ls, buf) : 0;\r\n}\r\nstatic ssize_t dlm_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct dlm_ls *ls = container_of(kobj, struct dlm_ls, ls_kobj);\r\nstruct dlm_attr *a = container_of(attr, struct dlm_attr, attr);\r\nreturn a->store ? a->store(ls, buf, len) : len;\r\n}\r\nstatic void lockspace_kobj_release(struct kobject *k)\r\n{\r\nstruct dlm_ls *ls = container_of(k, struct dlm_ls, ls_kobj);\r\nkfree(ls);\r\n}\r\nstatic int do_uevent(struct dlm_ls *ls, int in)\r\n{\r\nint error;\r\nif (in)\r\nkobject_uevent(&ls->ls_kobj, KOBJ_ONLINE);\r\nelse\r\nkobject_uevent(&ls->ls_kobj, KOBJ_OFFLINE);\r\nlog_debug(ls, "%s the lockspace group...", in ? "joining" : "leaving");\r\nerror = wait_event_interruptible(ls->ls_uevent_wait,\r\ntest_and_clear_bit(LSFL_UEVENT_WAIT, &ls->ls_flags));\r\nlog_debug(ls, "group event done %d %d", error, ls->ls_uevent_result);\r\nif (error)\r\ngoto out;\r\nerror = ls->ls_uevent_result;\r\nout:\r\nif (error)\r\nlog_error(ls, "group %s failed %d %d", in ? "join" : "leave",\r\nerror, ls->ls_uevent_result);\r\nreturn error;\r\n}\r\nstatic int dlm_uevent(struct kset *kset, struct kobject *kobj,\r\nstruct kobj_uevent_env *env)\r\n{\r\nstruct dlm_ls *ls = container_of(kobj, struct dlm_ls, ls_kobj);\r\nadd_uevent_var(env, "LOCKSPACE=%s", ls->ls_name);\r\nreturn 0;\r\n}\r\nint __init dlm_lockspace_init(void)\r\n{\r\nls_count = 0;\r\nmutex_init(&ls_lock);\r\nINIT_LIST_HEAD(&lslist);\r\nspin_lock_init(&lslist_lock);\r\ndlm_kset = kset_create_and_add("dlm", &dlm_uevent_ops, kernel_kobj);\r\nif (!dlm_kset) {\r\nprintk(KERN_WARNING "%s: can not create kset\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid dlm_lockspace_exit(void)\r\n{\r\nkset_unregister(dlm_kset);\r\n}\r\nstatic struct dlm_ls *find_ls_to_scan(void)\r\n{\r\nstruct dlm_ls *ls;\r\nspin_lock(&lslist_lock);\r\nlist_for_each_entry(ls, &lslist, ls_list) {\r\nif (time_after_eq(jiffies, ls->ls_scan_time +\r\ndlm_config.ci_scan_secs * HZ)) {\r\nspin_unlock(&lslist_lock);\r\nreturn ls;\r\n}\r\n}\r\nspin_unlock(&lslist_lock);\r\nreturn NULL;\r\n}\r\nstatic int dlm_scand(void *data)\r\n{\r\nstruct dlm_ls *ls;\r\nwhile (!kthread_should_stop()) {\r\nls = find_ls_to_scan();\r\nif (ls) {\r\nif (dlm_lock_recovery_try(ls)) {\r\nls->ls_scan_time = jiffies;\r\ndlm_scan_rsbs(ls);\r\ndlm_scan_timeout(ls);\r\ndlm_scan_waiters(ls);\r\ndlm_unlock_recovery(ls);\r\n} else {\r\nls->ls_scan_time += HZ;\r\n}\r\ncontinue;\r\n}\r\nschedule_timeout_interruptible(dlm_config.ci_scan_secs * HZ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlm_scand_start(void)\r\n{\r\nstruct task_struct *p;\r\nint error = 0;\r\np = kthread_run(dlm_scand, NULL, "dlm_scand");\r\nif (IS_ERR(p))\r\nerror = PTR_ERR(p);\r\nelse\r\nscand_task = p;\r\nreturn error;\r\n}\r\nstatic void dlm_scand_stop(void)\r\n{\r\nkthread_stop(scand_task);\r\n}\r\nstruct dlm_ls *dlm_find_lockspace_global(uint32_t id)\r\n{\r\nstruct dlm_ls *ls;\r\nspin_lock(&lslist_lock);\r\nlist_for_each_entry(ls, &lslist, ls_list) {\r\nif (ls->ls_global_id == id) {\r\nls->ls_count++;\r\ngoto out;\r\n}\r\n}\r\nls = NULL;\r\nout:\r\nspin_unlock(&lslist_lock);\r\nreturn ls;\r\n}\r\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\r\n{\r\nstruct dlm_ls *ls;\r\nspin_lock(&lslist_lock);\r\nlist_for_each_entry(ls, &lslist, ls_list) {\r\nif (ls->ls_local_handle == lockspace) {\r\nls->ls_count++;\r\ngoto out;\r\n}\r\n}\r\nls = NULL;\r\nout:\r\nspin_unlock(&lslist_lock);\r\nreturn ls;\r\n}\r\nstruct dlm_ls *dlm_find_lockspace_device(int minor)\r\n{\r\nstruct dlm_ls *ls;\r\nspin_lock(&lslist_lock);\r\nlist_for_each_entry(ls, &lslist, ls_list) {\r\nif (ls->ls_device.minor == minor) {\r\nls->ls_count++;\r\ngoto out;\r\n}\r\n}\r\nls = NULL;\r\nout:\r\nspin_unlock(&lslist_lock);\r\nreturn ls;\r\n}\r\nvoid dlm_put_lockspace(struct dlm_ls *ls)\r\n{\r\nspin_lock(&lslist_lock);\r\nls->ls_count--;\r\nspin_unlock(&lslist_lock);\r\n}\r\nstatic void remove_lockspace(struct dlm_ls *ls)\r\n{\r\nfor (;;) {\r\nspin_lock(&lslist_lock);\r\nif (ls->ls_count == 0) {\r\nWARN_ON(ls->ls_create_count != 0);\r\nlist_del(&ls->ls_list);\r\nspin_unlock(&lslist_lock);\r\nreturn;\r\n}\r\nspin_unlock(&lslist_lock);\r\nssleep(1);\r\n}\r\n}\r\nstatic int threads_start(void)\r\n{\r\nint error;\r\nerror = dlm_scand_start();\r\nif (error) {\r\nlog_print("cannot start dlm_scand thread %d", error);\r\ngoto fail;\r\n}\r\nerror = dlm_lowcomms_start();\r\nif (error) {\r\nlog_print("cannot start dlm lowcomms %d", error);\r\ngoto scand_fail;\r\n}\r\nreturn 0;\r\nscand_fail:\r\ndlm_scand_stop();\r\nfail:\r\nreturn error;\r\n}\r\nstatic void threads_stop(void)\r\n{\r\ndlm_scand_stop();\r\ndlm_lowcomms_stop();\r\n}\r\nstatic int new_lockspace(const char *name, const char *cluster,\r\nuint32_t flags, int lvblen,\r\nconst struct dlm_lockspace_ops *ops, void *ops_arg,\r\nint *ops_result, dlm_lockspace_t **lockspace)\r\n{\r\nstruct dlm_ls *ls;\r\nint i, size, error;\r\nint do_unreg = 0;\r\nint namelen = strlen(name);\r\nif (namelen > DLM_LOCKSPACE_LEN)\r\nreturn -EINVAL;\r\nif (!lvblen || (lvblen % 8))\r\nreturn -EINVAL;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -EINVAL;\r\nif (!dlm_user_daemon_available()) {\r\nlog_print("dlm user daemon not available");\r\nerror = -EUNATCH;\r\ngoto out;\r\n}\r\nif (ops && ops_result) {\r\nif (!dlm_config.ci_recover_callbacks)\r\n*ops_result = -EOPNOTSUPP;\r\nelse\r\n*ops_result = 0;\r\n}\r\nif (dlm_config.ci_recover_callbacks && cluster &&\r\nstrncmp(cluster, dlm_config.ci_cluster_name, DLM_LOCKSPACE_LEN)) {\r\nlog_print("dlm cluster name %s mismatch %s",\r\ndlm_config.ci_cluster_name, cluster);\r\nerror = -EBADR;\r\ngoto out;\r\n}\r\nerror = 0;\r\nspin_lock(&lslist_lock);\r\nlist_for_each_entry(ls, &lslist, ls_list) {\r\nWARN_ON(ls->ls_create_count <= 0);\r\nif (ls->ls_namelen != namelen)\r\ncontinue;\r\nif (memcmp(ls->ls_name, name, namelen))\r\ncontinue;\r\nif (flags & DLM_LSFL_NEWEXCL) {\r\nerror = -EEXIST;\r\nbreak;\r\n}\r\nls->ls_create_count++;\r\n*lockspace = ls;\r\nerror = 1;\r\nbreak;\r\n}\r\nspin_unlock(&lslist_lock);\r\nif (error)\r\ngoto out;\r\nerror = -ENOMEM;\r\nls = kzalloc(sizeof(struct dlm_ls) + namelen, GFP_NOFS);\r\nif (!ls)\r\ngoto out;\r\nmemcpy(ls->ls_name, name, namelen);\r\nls->ls_namelen = namelen;\r\nls->ls_lvblen = lvblen;\r\nls->ls_count = 0;\r\nls->ls_flags = 0;\r\nls->ls_scan_time = jiffies;\r\nif (ops && dlm_config.ci_recover_callbacks) {\r\nls->ls_ops = ops;\r\nls->ls_ops_arg = ops_arg;\r\n}\r\nif (flags & DLM_LSFL_TIMEWARN)\r\nset_bit(LSFL_TIMEWARN, &ls->ls_flags);\r\nls->ls_exflags = (flags & ~(DLM_LSFL_TIMEWARN | DLM_LSFL_FS |\r\nDLM_LSFL_NEWEXCL));\r\nsize = dlm_config.ci_rsbtbl_size;\r\nls->ls_rsbtbl_size = size;\r\nls->ls_rsbtbl = vmalloc(sizeof(struct dlm_rsbtable) * size);\r\nif (!ls->ls_rsbtbl)\r\ngoto out_lsfree;\r\nfor (i = 0; i < size; i++) {\r\nls->ls_rsbtbl[i].keep.rb_node = NULL;\r\nls->ls_rsbtbl[i].toss.rb_node = NULL;\r\nspin_lock_init(&ls->ls_rsbtbl[i].lock);\r\n}\r\nspin_lock_init(&ls->ls_remove_spin);\r\nfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\r\nls->ls_remove_names[i] = kzalloc(DLM_RESNAME_MAXLEN+1,\r\nGFP_KERNEL);\r\nif (!ls->ls_remove_names[i])\r\ngoto out_rsbtbl;\r\n}\r\nidr_init(&ls->ls_lkbidr);\r\nspin_lock_init(&ls->ls_lkbidr_spin);\r\nINIT_LIST_HEAD(&ls->ls_waiters);\r\nmutex_init(&ls->ls_waiters_mutex);\r\nINIT_LIST_HEAD(&ls->ls_orphans);\r\nmutex_init(&ls->ls_orphans_mutex);\r\nINIT_LIST_HEAD(&ls->ls_timeout);\r\nmutex_init(&ls->ls_timeout_mutex);\r\nINIT_LIST_HEAD(&ls->ls_new_rsb);\r\nspin_lock_init(&ls->ls_new_rsb_spin);\r\nINIT_LIST_HEAD(&ls->ls_nodes);\r\nINIT_LIST_HEAD(&ls->ls_nodes_gone);\r\nls->ls_num_nodes = 0;\r\nls->ls_low_nodeid = 0;\r\nls->ls_total_weight = 0;\r\nls->ls_node_array = NULL;\r\nmemset(&ls->ls_stub_rsb, 0, sizeof(struct dlm_rsb));\r\nls->ls_stub_rsb.res_ls = ls;\r\nls->ls_debug_rsb_dentry = NULL;\r\nls->ls_debug_waiters_dentry = NULL;\r\ninit_waitqueue_head(&ls->ls_uevent_wait);\r\nls->ls_uevent_result = 0;\r\ninit_completion(&ls->ls_members_done);\r\nls->ls_members_result = -1;\r\nmutex_init(&ls->ls_cb_mutex);\r\nINIT_LIST_HEAD(&ls->ls_cb_delay);\r\nls->ls_recoverd_task = NULL;\r\nmutex_init(&ls->ls_recoverd_active);\r\nspin_lock_init(&ls->ls_recover_lock);\r\nspin_lock_init(&ls->ls_rcom_spin);\r\nget_random_bytes(&ls->ls_rcom_seq, sizeof(uint64_t));\r\nls->ls_recover_status = 0;\r\nls->ls_recover_seq = 0;\r\nls->ls_recover_args = NULL;\r\ninit_rwsem(&ls->ls_in_recovery);\r\ninit_rwsem(&ls->ls_recv_active);\r\nINIT_LIST_HEAD(&ls->ls_requestqueue);\r\nmutex_init(&ls->ls_requestqueue_mutex);\r\nmutex_init(&ls->ls_clear_proc_locks);\r\nls->ls_recover_buf = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\r\nif (!ls->ls_recover_buf)\r\ngoto out_lkbidr;\r\nls->ls_slot = 0;\r\nls->ls_num_slots = 0;\r\nls->ls_slots_size = 0;\r\nls->ls_slots = NULL;\r\nINIT_LIST_HEAD(&ls->ls_recover_list);\r\nspin_lock_init(&ls->ls_recover_list_lock);\r\nidr_init(&ls->ls_recover_idr);\r\nspin_lock_init(&ls->ls_recover_idr_lock);\r\nls->ls_recover_list_count = 0;\r\nls->ls_local_handle = ls;\r\ninit_waitqueue_head(&ls->ls_wait_general);\r\nINIT_LIST_HEAD(&ls->ls_root_list);\r\ninit_rwsem(&ls->ls_root_sem);\r\nspin_lock(&lslist_lock);\r\nls->ls_create_count = 1;\r\nlist_add(&ls->ls_list, &lslist);\r\nspin_unlock(&lslist_lock);\r\nif (flags & DLM_LSFL_FS) {\r\nerror = dlm_callback_start(ls);\r\nif (error) {\r\nlog_error(ls, "can't start dlm_callback %d", error);\r\ngoto out_delist;\r\n}\r\n}\r\ninit_waitqueue_head(&ls->ls_recover_lock_wait);\r\nerror = dlm_recoverd_start(ls);\r\nif (error) {\r\nlog_error(ls, "can't start dlm_recoverd %d", error);\r\ngoto out_callback;\r\n}\r\nwait_event(ls->ls_recover_lock_wait,\r\ntest_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\r\nls->ls_kobj.kset = dlm_kset;\r\nerror = kobject_init_and_add(&ls->ls_kobj, &dlm_ktype, NULL,\r\n"%s", ls->ls_name);\r\nif (error)\r\ngoto out_recoverd;\r\nkobject_uevent(&ls->ls_kobj, KOBJ_ADD);\r\ndo_unreg = 1;\r\nerror = do_uevent(ls, 1);\r\nif (error)\r\ngoto out_recoverd;\r\nwait_for_completion(&ls->ls_members_done);\r\nerror = ls->ls_members_result;\r\nif (error)\r\ngoto out_members;\r\ndlm_create_debug_file(ls);\r\nlog_debug(ls, "join complete");\r\n*lockspace = ls;\r\nreturn 0;\r\nout_members:\r\ndo_uevent(ls, 0);\r\ndlm_clear_members(ls);\r\nkfree(ls->ls_node_array);\r\nout_recoverd:\r\ndlm_recoverd_stop(ls);\r\nout_callback:\r\ndlm_callback_stop(ls);\r\nout_delist:\r\nspin_lock(&lslist_lock);\r\nlist_del(&ls->ls_list);\r\nspin_unlock(&lslist_lock);\r\nidr_destroy(&ls->ls_recover_idr);\r\nkfree(ls->ls_recover_buf);\r\nout_lkbidr:\r\nidr_destroy(&ls->ls_lkbidr);\r\nfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++) {\r\nif (ls->ls_remove_names[i])\r\nkfree(ls->ls_remove_names[i]);\r\n}\r\nout_rsbtbl:\r\nvfree(ls->ls_rsbtbl);\r\nout_lsfree:\r\nif (do_unreg)\r\nkobject_put(&ls->ls_kobj);\r\nelse\r\nkfree(ls);\r\nout:\r\nmodule_put(THIS_MODULE);\r\nreturn error;\r\n}\r\nint dlm_new_lockspace(const char *name, const char *cluster,\r\nuint32_t flags, int lvblen,\r\nconst struct dlm_lockspace_ops *ops, void *ops_arg,\r\nint *ops_result, dlm_lockspace_t **lockspace)\r\n{\r\nint error = 0;\r\nmutex_lock(&ls_lock);\r\nif (!ls_count)\r\nerror = threads_start();\r\nif (error)\r\ngoto out;\r\nerror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\r\nops_result, lockspace);\r\nif (!error)\r\nls_count++;\r\nif (error > 0)\r\nerror = 0;\r\nif (!ls_count)\r\nthreads_stop();\r\nout:\r\nmutex_unlock(&ls_lock);\r\nreturn error;\r\n}\r\nstatic int lkb_idr_is_local(int id, void *p, void *data)\r\n{\r\nstruct dlm_lkb *lkb = p;\r\nif (!lkb->lkb_nodeid)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int lkb_idr_is_any(int id, void *p, void *data)\r\n{\r\nreturn 1;\r\n}\r\nstatic int lkb_idr_free(int id, void *p, void *data)\r\n{\r\nstruct dlm_lkb *lkb = p;\r\nif (lkb->lkb_lvbptr && lkb->lkb_flags & DLM_IFL_MSTCPY)\r\ndlm_free_lvb(lkb->lkb_lvbptr);\r\ndlm_free_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic int lockspace_busy(struct dlm_ls *ls, int force)\r\n{\r\nint rv;\r\nspin_lock(&ls->ls_lkbidr_spin);\r\nif (force == 0) {\r\nrv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_any, ls);\r\n} else if (force == 1) {\r\nrv = idr_for_each(&ls->ls_lkbidr, lkb_idr_is_local, ls);\r\n} else {\r\nrv = 0;\r\n}\r\nspin_unlock(&ls->ls_lkbidr_spin);\r\nreturn rv;\r\n}\r\nstatic int release_lockspace(struct dlm_ls *ls, int force)\r\n{\r\nstruct dlm_rsb *rsb;\r\nstruct rb_node *n;\r\nint i, busy, rv;\r\nbusy = lockspace_busy(ls, force);\r\nspin_lock(&lslist_lock);\r\nif (ls->ls_create_count == 1) {\r\nif (busy) {\r\nrv = -EBUSY;\r\n} else {\r\nls->ls_create_count = 0;\r\nrv = 0;\r\n}\r\n} else if (ls->ls_create_count > 1) {\r\nrv = --ls->ls_create_count;\r\n} else {\r\nrv = -EINVAL;\r\n}\r\nspin_unlock(&lslist_lock);\r\nif (rv) {\r\nlog_debug(ls, "release_lockspace no remove %d", rv);\r\nreturn rv;\r\n}\r\ndlm_device_deregister(ls);\r\nif (force < 3 && dlm_user_daemon_available())\r\ndo_uevent(ls, 0);\r\ndlm_recoverd_stop(ls);\r\ndlm_callback_stop(ls);\r\nremove_lockspace(ls);\r\ndlm_delete_debug_file(ls);\r\nkfree(ls->ls_recover_buf);\r\nidr_for_each(&ls->ls_lkbidr, lkb_idr_free, ls);\r\nidr_remove_all(&ls->ls_lkbidr);\r\nidr_destroy(&ls->ls_lkbidr);\r\nfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\r\nwhile ((n = rb_first(&ls->ls_rsbtbl[i].keep))) {\r\nrsb = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nrb_erase(n, &ls->ls_rsbtbl[i].keep);\r\ndlm_free_rsb(rsb);\r\n}\r\nwhile ((n = rb_first(&ls->ls_rsbtbl[i].toss))) {\r\nrsb = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nrb_erase(n, &ls->ls_rsbtbl[i].toss);\r\ndlm_free_rsb(rsb);\r\n}\r\n}\r\nvfree(ls->ls_rsbtbl);\r\nfor (i = 0; i < DLM_REMOVE_NAMES_MAX; i++)\r\nkfree(ls->ls_remove_names[i]);\r\nwhile (!list_empty(&ls->ls_new_rsb)) {\r\nrsb = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb,\r\nres_hashchain);\r\nlist_del(&rsb->res_hashchain);\r\ndlm_free_rsb(rsb);\r\n}\r\ndlm_purge_requestqueue(ls);\r\nkfree(ls->ls_recover_args);\r\ndlm_clear_members(ls);\r\ndlm_clear_members_gone(ls);\r\nkfree(ls->ls_node_array);\r\nlog_debug(ls, "release_lockspace final free");\r\nkobject_put(&ls->ls_kobj);\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nint dlm_release_lockspace(void *lockspace, int force)\r\n{\r\nstruct dlm_ls *ls;\r\nint error;\r\nls = dlm_find_lockspace_local(lockspace);\r\nif (!ls)\r\nreturn -EINVAL;\r\ndlm_put_lockspace(ls);\r\nmutex_lock(&ls_lock);\r\nerror = release_lockspace(ls, force);\r\nif (!error)\r\nls_count--;\r\nif (!ls_count)\r\nthreads_stop();\r\nmutex_unlock(&ls_lock);\r\nreturn error;\r\n}\r\nvoid dlm_stop_lockspaces(void)\r\n{\r\nstruct dlm_ls *ls;\r\nrestart:\r\nspin_lock(&lslist_lock);\r\nlist_for_each_entry(ls, &lslist, ls_list) {\r\nif (!test_bit(LSFL_RUNNING, &ls->ls_flags))\r\ncontinue;\r\nspin_unlock(&lslist_lock);\r\nlog_error(ls, "no userland control daemon, stopping lockspace");\r\ndlm_ls_stop(ls);\r\ngoto restart;\r\n}\r\nspin_unlock(&lslist_lock);\r\n}
