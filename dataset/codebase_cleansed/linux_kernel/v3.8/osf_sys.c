static int\r\nosf_filldir(void *__buf, const char *name, int namlen, loff_t offset,\r\nu64 ino, unsigned int d_type)\r\n{\r\nstruct osf_dirent __user *dirent;\r\nstruct osf_dirent_callback *buf = (struct osf_dirent_callback *) __buf;\r\nunsigned int reclen = ALIGN(NAME_OFFSET + namlen + 1, sizeof(u32));\r\nunsigned int d_ino;\r\nbuf->error = -EINVAL;\r\nif (reclen > buf->count)\r\nreturn -EINVAL;\r\nd_ino = ino;\r\nif (sizeof(d_ino) < sizeof(ino) && d_ino != ino) {\r\nbuf->error = -EOVERFLOW;\r\nreturn -EOVERFLOW;\r\n}\r\nif (buf->basep) {\r\nif (put_user(offset, buf->basep))\r\ngoto Efault;\r\nbuf->basep = NULL;\r\n}\r\ndirent = buf->dirent;\r\nif (put_user(d_ino, &dirent->d_ino) ||\r\nput_user(namlen, &dirent->d_namlen) ||\r\nput_user(reclen, &dirent->d_reclen) ||\r\ncopy_to_user(dirent->d_name, name, namlen) ||\r\nput_user(0, dirent->d_name + namlen))\r\ngoto Efault;\r\ndirent = (void __user *)dirent + reclen;\r\nbuf->dirent = dirent;\r\nbuf->count -= reclen;\r\nreturn 0;\r\nEfault:\r\nbuf->error = -EFAULT;\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\nlinux_to_osf_stat(struct kstat *lstat, struct osf_stat __user *osf_stat)\r\n{\r\nstruct osf_stat tmp = { 0 };\r\ntmp.st_dev = lstat->dev;\r\ntmp.st_mode = lstat->mode;\r\ntmp.st_nlink = lstat->nlink;\r\ntmp.st_uid = from_kuid_munged(current_user_ns(), lstat->uid);\r\ntmp.st_gid = from_kgid_munged(current_user_ns(), lstat->gid);\r\ntmp.st_rdev = lstat->rdev;\r\ntmp.st_ldev = lstat->rdev;\r\ntmp.st_size = lstat->size;\r\ntmp.st_uatime = lstat->atime.tv_nsec / 1000;\r\ntmp.st_umtime = lstat->mtime.tv_nsec / 1000;\r\ntmp.st_uctime = lstat->ctime.tv_nsec / 1000;\r\ntmp.st_ino = lstat->ino;\r\ntmp.st_atime = lstat->atime.tv_sec;\r\ntmp.st_mtime = lstat->mtime.tv_sec;\r\ntmp.st_ctime = lstat->ctime.tv_sec;\r\ntmp.st_blksize = lstat->blksize;\r\ntmp.st_blocks = lstat->blocks;\r\nreturn copy_to_user(osf_stat, &tmp, sizeof(tmp)) ? -EFAULT : 0;\r\n}\r\nstatic int\r\nlinux_to_osf_statfs(struct kstatfs *linux_stat, struct osf_statfs __user *osf_stat,\r\nunsigned long bufsiz)\r\n{\r\nstruct osf_statfs tmp_stat;\r\ntmp_stat.f_type = linux_stat->f_type;\r\ntmp_stat.f_flags = 0;\r\ntmp_stat.f_fsize = linux_stat->f_frsize;\r\ntmp_stat.f_bsize = linux_stat->f_bsize;\r\ntmp_stat.f_blocks = linux_stat->f_blocks;\r\ntmp_stat.f_bfree = linux_stat->f_bfree;\r\ntmp_stat.f_bavail = linux_stat->f_bavail;\r\ntmp_stat.f_files = linux_stat->f_files;\r\ntmp_stat.f_ffree = linux_stat->f_ffree;\r\ntmp_stat.f_fsid = linux_stat->f_fsid;\r\nif (bufsiz > sizeof(tmp_stat))\r\nbufsiz = sizeof(tmp_stat);\r\nreturn copy_to_user(osf_stat, &tmp_stat, bufsiz) ? -EFAULT : 0;\r\n}\r\nstatic int\r\nlinux_to_osf_statfs64(struct kstatfs *linux_stat, struct osf_statfs64 __user *osf_stat,\r\nunsigned long bufsiz)\r\n{\r\nstruct osf_statfs64 tmp_stat = { 0 };\r\ntmp_stat.f_type = linux_stat->f_type;\r\ntmp_stat.f_fsize = linux_stat->f_frsize;\r\ntmp_stat.f_bsize = linux_stat->f_bsize;\r\ntmp_stat.f_blocks = linux_stat->f_blocks;\r\ntmp_stat.f_bfree = linux_stat->f_bfree;\r\ntmp_stat.f_bavail = linux_stat->f_bavail;\r\ntmp_stat.f_files = linux_stat->f_files;\r\ntmp_stat.f_ffree = linux_stat->f_ffree;\r\ntmp_stat.f_fsid = linux_stat->f_fsid;\r\nif (bufsiz > sizeof(tmp_stat))\r\nbufsiz = sizeof(tmp_stat);\r\nreturn copy_to_user(osf_stat, &tmp_stat, bufsiz) ? -EFAULT : 0;\r\n}\r\nstatic int\r\nosf_ufs_mount(const char *dirname, struct ufs_args __user *args, int flags)\r\n{\r\nint retval;\r\nstruct cdfs_args tmp;\r\nstruct filename *devname;\r\nretval = -EFAULT;\r\nif (copy_from_user(&tmp, args, sizeof(tmp)))\r\ngoto out;\r\ndevname = getname(tmp.devname);\r\nretval = PTR_ERR(devname);\r\nif (IS_ERR(devname))\r\ngoto out;\r\nretval = do_mount(devname->name, dirname, "ext2", flags, NULL);\r\nputname(devname);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int\r\nosf_cdfs_mount(const char *dirname, struct cdfs_args __user *args, int flags)\r\n{\r\nint retval;\r\nstruct cdfs_args tmp;\r\nstruct filename *devname;\r\nretval = -EFAULT;\r\nif (copy_from_user(&tmp, args, sizeof(tmp)))\r\ngoto out;\r\ndevname = getname(tmp.devname);\r\nretval = PTR_ERR(devname);\r\nif (IS_ERR(devname))\r\ngoto out;\r\nretval = do_mount(devname->name, dirname, "iso9660", flags, NULL);\r\nputname(devname);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int\r\nosf_procfs_mount(const char *dirname, struct procfs_args __user *args, int flags)\r\n{\r\nstruct procfs_args tmp;\r\nif (copy_from_user(&tmp, args, sizeof(tmp)))\r\nreturn -EFAULT;\r\nreturn do_mount("", dirname, "proc", flags, NULL);\r\n}\r\nstatic inline long\r\nget_tv32(struct timeval *o, struct timeval32 __user *i)\r\n{\r\nreturn (!access_ok(VERIFY_READ, i, sizeof(*i)) ||\r\n(__get_user(o->tv_sec, &i->tv_sec) |\r\n__get_user(o->tv_usec, &i->tv_usec)));\r\n}\r\nstatic inline long\r\nput_tv32(struct timeval32 __user *o, struct timeval *i)\r\n{\r\nreturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\r\n(__put_user(i->tv_sec, &o->tv_sec) |\r\n__put_user(i->tv_usec, &o->tv_usec)));\r\n}\r\nstatic inline long\r\nget_it32(struct itimerval *o, struct itimerval32 __user *i)\r\n{\r\nreturn (!access_ok(VERIFY_READ, i, sizeof(*i)) ||\r\n(__get_user(o->it_interval.tv_sec, &i->it_interval.tv_sec) |\r\n__get_user(o->it_interval.tv_usec, &i->it_interval.tv_usec) |\r\n__get_user(o->it_value.tv_sec, &i->it_value.tv_sec) |\r\n__get_user(o->it_value.tv_usec, &i->it_value.tv_usec)));\r\n}\r\nstatic inline long\r\nput_it32(struct itimerval32 __user *o, struct itimerval *i)\r\n{\r\nreturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\r\n(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\r\n__put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\r\n__put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\r\n__put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\r\n}\r\nstatic inline void\r\njiffies_to_timeval32(unsigned long jiffies, struct timeval32 *value)\r\n{\r\nvalue->tv_usec = (jiffies % HZ) * (1000000L / HZ);\r\nvalue->tv_sec = jiffies / HZ;\r\n}\r\nstatic unsigned long\r\narch_get_unmapped_area_1(unsigned long addr, unsigned long len,\r\nunsigned long limit)\r\n{\r\nstruct vm_area_struct *vma = find_vma(current->mm, addr);\r\nwhile (1) {\r\nif (limit - len < addr)\r\nreturn -ENOMEM;\r\nif (!vma || addr + len <= vma->vm_start)\r\nreturn addr;\r\naddr = vma->vm_end;\r\nvma = vma->vm_next;\r\n}\r\n}\r\nunsigned long\r\narch_get_unmapped_area(struct file *filp, unsigned long addr,\r\nunsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nunsigned long limit;\r\nif (current->personality & ADDR_LIMIT_32BIT)\r\nlimit = 0x80000000;\r\nelse\r\nlimit = TASK_SIZE;\r\nif (len > limit)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nif (addr) {\r\naddr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);\r\nif (addr != (unsigned long) -ENOMEM)\r\nreturn addr;\r\n}\r\naddr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),\r\nlen, limit);\r\nif (addr != (unsigned long) -ENOMEM)\r\nreturn addr;\r\naddr = arch_get_unmapped_area_1 (PAGE_SIZE, len, limit);\r\nreturn addr;\r\n}\r\nstatic int\r\nosf_fix_iov_len(const struct iovec __user *iov, unsigned long count)\r\n{\r\nunsigned long i;\r\nfor (i = 0 ; i < count ; i++) {\r\nint __user *iov_len_high = (int __user *)&iov[i].iov_len + 1;\r\nif (put_user(0, iov_len_high))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}
