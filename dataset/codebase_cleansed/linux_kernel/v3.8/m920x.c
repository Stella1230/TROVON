static inline int m920x_read(struct usb_device *udev, u8 request, u16 value,\r\nu16 index, void *data, int size)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nrequest, USB_TYPE_VENDOR | USB_DIR_IN,\r\nvalue, index, data, size, 2000);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "m920x_read = error: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ret != size) {\r\ndeb("m920x_read = no data\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int m920x_write(struct usb_device *udev, u8 request,\r\nu16 value, u16 index)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nrequest, USB_TYPE_VENDOR | USB_DIR_OUT,\r\nvalue, index, NULL, 0, 2000);\r\nreturn ret;\r\n}\r\nstatic int m920x_init(struct dvb_usb_device *d, struct m920x_inits *rc_seq)\r\n{\r\nint ret = 0, i, epi, flags = 0;\r\nint adap_enabled[M9206_MAX_ADAPTERS] = { 0 };\r\nif (d->props.rc.legacy.rc_query) {\r\ndeb("Initialising remote control\n");\r\nwhile (rc_seq->address) {\r\nif ((ret = m920x_write(d->udev, M9206_CORE,\r\nrc_seq->data,\r\nrc_seq->address)) != 0) {\r\ndeb("Initialising remote control failed\n");\r\nreturn ret;\r\n}\r\nrc_seq++;\r\n}\r\ndeb("Initialising remote control success\n");\r\n}\r\nfor (i = 0; i < d->props.num_adapters; i++)\r\nflags |= d->adapter[i].props.fe[0].caps;\r\nif (flags & DVB_USB_ADAP_HAS_PID_FILTER) {\r\nfor (i = 0; i < d->props.num_adapters; i++) {\r\nepi = d->adapter[i].props.fe[0].stream.endpoint - 0x81;\r\nif (epi < 0 || epi >= M9206_MAX_ADAPTERS) {\r\nprintk(KERN_INFO "m920x: Unexpected adapter endpoint!\n");\r\nreturn -EINVAL;\r\n}\r\nadap_enabled[epi] = 1;\r\n}\r\nfor (i = 0; i < M9206_MAX_ADAPTERS; i++) {\r\nif (adap_enabled[i])\r\ncontinue;\r\nif ((ret = m920x_set_filter(d, 0x81 + i, 0, 0x0)) != 0)\r\nreturn ret;\r\nif ((ret = m920x_set_filter(d, 0x81 + i, 0, 0x02f5)) != 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int m920x_init_ep(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *alt;\r\nif ((alt = usb_altnum_to_altsetting(intf, 1)) == NULL) {\r\ndeb("No alt found!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\r\nalt->desc.bAlternateSetting);\r\n}\r\nstatic int m920x_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nstruct m920x_state *m = d->priv;\r\nint i, ret = 0;\r\nu8 *rc_state;\r\nrc_state = kmalloc(2, GFP_KERNEL);\r\nif (!rc_state)\r\nreturn -ENOMEM;\r\nif ((ret = m920x_read(d->udev, M9206_CORE, 0x0, M9206_RC_STATE, rc_state, 1)) != 0)\r\ngoto out;\r\nif ((ret = m920x_read(d->udev, M9206_CORE, 0x0, M9206_RC_KEY, rc_state + 1, 1)) != 0)\r\ngoto out;\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++)\r\nif (rc5_data(&d->props.rc.legacy.rc_map_table[i]) == rc_state[1]) {\r\n*event = d->props.rc.legacy.rc_map_table[i].keycode;\r\nswitch(rc_state[0]) {\r\ncase 0x80:\r\n*state = REMOTE_NO_KEY_PRESSED;\r\ngoto out;\r\ncase 0x88:\r\ncase 0x99:\r\ncase 0xc0:\r\ncase 0xd8:\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nm->rep_count = 0;\r\ngoto out;\r\ncase 0x93:\r\ncase 0x92:\r\ncase 0x83:\r\ncase 0x82:\r\nm->rep_count = 0;\r\n*state = REMOTE_KEY_PRESSED;\r\ngoto out;\r\ncase 0x91:\r\ncase 0x81:\r\nif (++m->rep_count > 2)\r\n*state = REMOTE_KEY_REPEAT;\r\nelse\r\n*state = REMOTE_NO_KEY_PRESSED;\r\ngoto out;\r\ndefault:\r\ndeb("Unexpected rc state %02x\n", rc_state[0]);\r\n*state = REMOTE_NO_KEY_PRESSED;\r\ngoto out;\r\n}\r\n}\r\nif (rc_state[1] != 0)\r\ndeb("Unknown rc key %02x\n", rc_state[1]);\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nout:\r\nkfree(rc_state);\r\nreturn ret;\r\n}\r\nstatic int m920x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i, j;\r\nint ret = 0;\r\nif (!num)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif (msg[i].flags & (I2C_M_NO_RD_ACK | I2C_M_IGNORE_NAK | I2C_M_TEN) || msg[i].len == 0) {\r\nret = -ENOTSUPP;\r\ngoto unlock;\r\n}\r\nif (!(msg[i].flags & I2C_M_NOSTART)) {\r\nif ((ret = m920x_write(d->udev, M9206_I2C,\r\n(msg[i].addr << 1) |\r\n(msg[i].flags & I2C_M_RD ? 0x01 : 0), 0x80)) != 0)\r\ngoto unlock;\r\n}\r\nif (msg[i].flags & I2C_M_RD) {\r\nfor (j = 0; j < msg[i].len; j++) {\r\nint stop = (i+1 == num && j+1 == msg[i].len) ? 0x40 : 0x01;\r\nif ((ret = m920x_read(d->udev, M9206_I2C, 0x0,\r\n0x20 | stop,\r\n&msg[i].buf[j], 1)) != 0)\r\ngoto unlock;\r\n}\r\n} else {\r\nfor (j = 0; j < msg[i].len; j++) {\r\nint stop = (i+1 == num && j+1 == msg[i].len) ? 0x40 : 0x00;\r\nif ((ret = m920x_write(d->udev, M9206_I2C, msg[i].buf[j], stop)) != 0)\r\ngoto unlock;\r\n}\r\n}\r\n}\r\nret = num;\r\nunlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 m920x_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int m920x_set_filter(struct dvb_usb_device *d, int type, int idx, int pid)\r\n{\r\nint ret = 0;\r\nif (pid >= 0x8000)\r\nreturn -EINVAL;\r\npid |= 0x8000;\r\nif ((ret = m920x_write(d->udev, M9206_FILTER, pid, (type << 8) | (idx * 4) )) != 0)\r\nreturn ret;\r\nif ((ret = m920x_write(d->udev, M9206_FILTER, 0, (type << 8) | (idx * 4) )) != 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int m920x_update_filters(struct dvb_usb_adapter *adap)\r\n{\r\nstruct m920x_state *m = adap->dev->priv;\r\nint enabled = m->filtering_enabled[adap->id];\r\nint i, ret = 0, filter = 0;\r\nint ep = adap->props.fe[0].stream.endpoint;\r\nfor (i = 0; i < M9206_MAX_FILTERS; i++)\r\nif (m->filters[adap->id][i] == 8192)\r\nenabled = 0;\r\nif ((ret = m920x_set_filter(adap->dev, ep, 1, enabled)) != 0)\r\nreturn ret;\r\nfor (i = 0; i < M9206_MAX_FILTERS; i++)\r\nif ((ret = m920x_set_filter(adap->dev, ep, i + 2, 0)) != 0)\r\nreturn ret;\r\nif (enabled) {\r\nfor (i = 0; i < M9206_MAX_FILTERS; i++) {\r\nif (m->filters[adap->id][i] == 0)\r\ncontinue;\r\nif ((ret = m920x_set_filter(adap->dev, ep, filter + 2, m->filters[adap->id][i])) != 0)\r\nreturn ret;\r\nfilter++;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int m920x_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct m920x_state *m = adap->dev->priv;\r\nm->filtering_enabled[adap->id] = onoff ? 1 : 0;\r\nreturn m920x_update_filters(adap);\r\n}\r\nstatic int m920x_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid, int onoff)\r\n{\r\nstruct m920x_state *m = adap->dev->priv;\r\nm->filters[adap->id][index] = onoff ? pid : 0;\r\nreturn m920x_update_filters(adap);\r\n}\r\nstatic int m920x_firmware_download(struct usb_device *udev, const struct firmware *fw)\r\n{\r\nu16 value, index, size;\r\nu8 *read, *buff;\r\nint i, pass, ret = 0;\r\nbuff = kmalloc(65536, GFP_KERNEL);\r\nif (buff == NULL)\r\nreturn -ENOMEM;\r\nread = kmalloc(4, GFP_KERNEL);\r\nif (!read) {\r\nkfree(buff);\r\nreturn -ENOMEM;\r\n}\r\nif ((ret = m920x_read(udev, M9206_FILTER, 0x0, 0x8000, read, 4)) != 0)\r\ngoto done;\r\ndeb("%*ph\n", 4, read);\r\nif ((ret = m920x_read(udev, M9206_FW, 0x0, 0x0, read, 1)) != 0)\r\ngoto done;\r\ndeb("%x\n", read[0]);\r\nfor (pass = 0; pass < 2; pass++) {\r\nfor (i = 0; i + (sizeof(u16) * 3) < fw->size;) {\r\nvalue = get_unaligned_le16(fw->data + i);\r\ni += sizeof(u16);\r\nindex = get_unaligned_le16(fw->data + i);\r\ni += sizeof(u16);\r\nsize = get_unaligned_le16(fw->data + i);\r\ni += sizeof(u16);\r\nif (pass == 1) {\r\nmemcpy(buff, fw->data + i, size);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev,0),\r\nM9206_FW,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nvalue, index, buff, size, 20);\r\nif (ret != size) {\r\ndeb("error while uploading fw!\n");\r\nret = -EIO;\r\ngoto done;\r\n}\r\nmsleep(3);\r\n}\r\ni += size;\r\n}\r\nif (i != fw->size) {\r\ndeb("bad firmware file!\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n}\r\nmsleep(36);\r\n(void) m920x_write(udev, M9206_CORE, 0x01, M9206_FW_GO);\r\ndeb("firmware uploaded!\n");\r\ndone:\r\nkfree(read);\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nstatic int m920x_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nstruct usb_host_interface *alt;\r\nalt = usb_altnum_to_altsetting(usb_ifnum_to_if(udev, 0), 1);\r\n*cold = (alt == NULL) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int m920x_mt352_demod_init(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nu8 config[] = { CONFIG, 0x3d };\r\nu8 clock[] = { CLOCK_CTL, 0x30 };\r\nu8 reset[] = { RESET, 0x80 };\r\nu8 adc_ctl[] = { ADC_CTL_1, 0x40 };\r\nu8 agc[] = { AGC_TARGET, 0x1c, 0x20 };\r\nu8 sec_agc[] = { 0x69, 0x00, 0xff, 0xff, 0x40, 0xff, 0x00, 0x40, 0x40 };\r\nu8 unk1[] = { 0x93, 0x1a };\r\nu8 unk2[] = { 0xb5, 0x7a };\r\ndeb("Demod init!\n");\r\nif ((ret = mt352_write(fe, config, ARRAY_SIZE(config))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, clock, ARRAY_SIZE(clock))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, reset, ARRAY_SIZE(reset))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, adc_ctl, ARRAY_SIZE(adc_ctl))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, agc, ARRAY_SIZE(agc))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, sec_agc, ARRAY_SIZE(sec_agc))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, unk1, ARRAY_SIZE(unk1))) != 0)\r\nreturn ret;\r\nif ((ret = mt352_write(fe, unk2, ARRAY_SIZE(unk2))) != 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int m920x_mt352_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb("%s\n",__func__);\r\nadap->fe_adap[0].fe = dvb_attach(mt352_attach,\r\n&m920x_mt352_config,\r\n&adap->dev->i2c_adap);\r\nif ((adap->fe_adap[0].fe) == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int m920x_tda10046_08_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb("%s\n",__func__);\r\nadap->fe_adap[0].fe = dvb_attach(tda10046_attach,\r\n&m920x_tda10046_08_config,\r\n&adap->dev->i2c_adap);\r\nif ((adap->fe_adap[0].fe) == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int m920x_tda10046_0b_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb("%s\n",__func__);\r\nadap->fe_adap[0].fe = dvb_attach(tda10046_attach,\r\n&m920x_tda10046_0b_config,\r\n&adap->dev->i2c_adap);\r\nif ((adap->fe_adap[0].fe) == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int m920x_qt1010_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb("%s\n",__func__);\r\nif (dvb_attach(qt1010_attach, adap->fe_adap[0].fe, &adap->dev->i2c_adap, &m920x_qt1010_config) == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int m920x_tda8275_60_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb("%s\n",__func__);\r\nif (dvb_attach(tda827x_attach, adap->fe_adap[0].fe, 0x60, &adap->dev->i2c_adap, NULL) == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int m920x_tda8275_61_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndeb("%s\n",__func__);\r\nif (dvb_attach(tda827x_attach, adap->fe_adap[0].fe, 0x61, &adap->dev->i2c_adap, NULL) == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int m920x_fmd1216me_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\ndvb_attach(simple_tuner_attach, adap->fe_adap[0].fe,\r\n&adap->dev->i2c_adap, 0x61,\r\nTUNER_PHILIPS_FMD1216ME_MK3);\r\nreturn 0;\r\n}\r\nstatic int m920x_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dvb_usb_device *d = NULL;\r\nint ret;\r\nstruct m920x_inits *rc_init_seq = NULL;\r\nint bInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;\r\ndeb("Probing for m920x device at interface %d\n", bInterfaceNumber);\r\nif (bInterfaceNumber == 0) {\r\nret = dvb_usb_device_init(intf, &megasky_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == 0) {\r\nrc_init_seq = megasky_rc_init;\r\ngoto found;\r\n}\r\nret = dvb_usb_device_init(intf, &digivox_mini_ii_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == 0) {\r\ngoto found;\r\n}\r\nret = dvb_usb_device_init(intf, &tvwalkertwin_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == 0) {\r\nrc_init_seq = tvwalkertwin_rc_init;\r\ngoto found;\r\n}\r\nret = dvb_usb_device_init(intf, &dposh_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == 0) {\r\ngoto found;\r\n}\r\nret = dvb_usb_device_init(intf, &pinnacle_pctv310e_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == 0) {\r\nrc_init_seq = pinnacle310e_init;\r\ngoto found;\r\n}\r\nreturn ret;\r\n} else {\r\n}\r\nfound:\r\nif ((ret = m920x_init_ep(intf)) < 0)\r\nreturn ret;\r\nif (d && (ret = m920x_init(d, rc_init_seq)) != 0)\r\nreturn ret;\r\nreturn ret;\r\n}
