u_int32_t\r\npci_read_32 (u_int32_t *p)\r\n{\r\n#ifdef FLOW_DEBUG\r\nu_int32_t v;\r\nFLUSH_PCI_READ ();\r\nv = le32_to_cpu (*p);\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\npr_info("pci_read : %x = %x\n", (u_int32_t) p, v);\r\nreturn v;\r\n#else\r\nFLUSH_PCI_READ ();\r\nreturn le32_to_cpu (*p);\r\n#endif\r\n}\r\nvoid\r\npci_write_32 (u_int32_t *p, u_int32_t v)\r\n{\r\n#ifdef FLOW_DEBUG\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\npr_info("pci_write: %x = %x\n", (u_int32_t) p, v);\r\n#endif\r\n*p = cpu_to_le32 (v);\r\nFLUSH_PCI_WRITE ();\r\n}\r\nvoid\r\npci_flush_write (ci_t * ci)\r\n{\r\nvolatile u_int32_t v;\r\nv = *(u_int32_t *) &ci->reg->glcd;\r\n}\r\nSTATIC void\r\nwatchdog_func (unsigned long arg)\r\n{\r\nstruct watchdog *wd = (void *) arg;\r\nif (drvr_state != SBE_DRVR_AVAILABLE)\r\n{\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_warning("%s: drvr not available (%x)\n", __func__, drvr_state);\r\nreturn;\r\n}\r\nschedule_work (&wd->work);\r\nmod_timer (&wd->h, jiffies + wd->ticks);\r\n}\r\nint OS_init_watchdog(struct watchdog *wdp, void (*f) (void *), void *c, int usec)\r\n{\r\nwdp->func = f;\r\nwdp->softc = c;\r\nwdp->ticks = (HZ) * (usec / 1000) / 1000;\r\nINIT_WORK(&wdp->work, (void *)f);\r\ninit_timer (&wdp->h);\r\n{\r\nci_t *ci = (ci_t *) c;\r\nwdp->h.data = (unsigned long) &ci->wd;\r\n}\r\nwdp->h.function = watchdog_func;\r\nreturn 0;\r\n}\r\nvoid\r\nOS_uwait (int usec, char *description)\r\n{\r\nint tmp;\r\nif (usec >= 1000)\r\n{\r\nmdelay (usec / 1000);\r\ntmp = (usec / 1000) * 1000;\r\ntmp = usec - tmp;\r\nif (tmp)\r\n{\r\nudelay (tmp);\r\n}\r\n} else\r\n{\r\nudelay (usec);\r\n}\r\n}\r\nvoid\r\nOS_uwait_dummy (void)\r\n{\r\n#ifndef USE_MAX_INT_DELAY\r\ndummy++;\r\n#else\r\nudelay (1);\r\n#endif\r\n}\r\nvoid\r\nOS_sem_init (void *sem, int state)\r\n{\r\nswitch (state)\r\n{\r\ncase SEM_TAKEN:\r\nsema_init((struct semaphore *) sem, 0);\r\nbreak;\r\ncase SEM_AVAILABLE:\r\nsema_init((struct semaphore *) sem, 1);\r\nbreak;\r\ndefault:\r\nsema_init (sem, state);\r\nbreak;\r\n}\r\n}\r\nint\r\nsd_line_is_ok (void *user)\r\n{\r\nstruct net_device *ndev = (struct net_device *) user;\r\nreturn (netif_carrier_ok (ndev));\r\n}\r\nvoid\r\nsd_line_is_up (void *user)\r\n{\r\nstruct net_device *ndev = (struct net_device *) user;\r\nnetif_carrier_on (ndev);\r\nreturn;\r\n}\r\nvoid\r\nsd_line_is_down (void *user)\r\n{\r\nstruct net_device *ndev = (struct net_device *) user;\r\nnetif_carrier_off (ndev);\r\nreturn;\r\n}\r\nvoid\r\nsd_disable_xmit (void *user)\r\n{\r\nstruct net_device *dev = (struct net_device *) user;\r\nnetif_stop_queue (dev);\r\nreturn;\r\n}\r\nvoid\r\nsd_enable_xmit (void *user)\r\n{\r\nstruct net_device *dev = (struct net_device *) user;\r\nnetif_wake_queue (dev);\r\nreturn;\r\n}\r\nint\r\nsd_queue_stopped (void *user)\r\n{\r\nstruct net_device *ndev = (struct net_device *) user;\r\nreturn (netif_queue_stopped (ndev));\r\n}\r\nvoid sd_recv_consume(void *token, size_t len, void *user)\r\n{\r\nstruct net_device *ndev = user;\r\nstruct sk_buff *skb = token;\r\nskb->dev = ndev;\r\nskb_put (skb, len);\r\nskb->protocol = hdlc_type_trans(skb, ndev);\r\nnetif_rx(skb);\r\n}\r\nvoid\r\nVMETRO_TRACE (void *x)\r\n{\r\nu_int32_t y = (u_int32_t) x;\r\npci_write_32 ((u_int32_t *) &CI->cpldbase->leds, y);\r\n}\r\nvoid\r\nVMETRO_TRIGGER (ci_t * ci, int x)\r\n{\r\ncomet_t *comet;\r\nvolatile u_int32_t data;\r\ncomet = ci->port[0].cometbase;\r\nswitch (x)\r\n{\r\ndefault:\r\ncase 0:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res24);\r\nbreak;\r\ncase 1:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res25);\r\nbreak;\r\ncase 2:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res26);\r\nbreak;\r\ncase 3:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res27);\r\nbreak;\r\ncase 4:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res88);\r\nbreak;\r\ncase 5:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res89);\r\nbreak;\r\ncase 6:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res8A);\r\nbreak;\r\ncase 7:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res8B);\r\nbreak;\r\ncase 8:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA0);\r\nbreak;\r\ncase 9:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA1);\r\nbreak;\r\ncase 10:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA2);\r\nbreak;\r\ncase 11:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA3);\r\nbreak;\r\ncase 12:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA4);\r\nbreak;\r\ncase 13:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA5);\r\nbreak;\r\ncase 14:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA6);\r\nbreak;\r\ncase 15:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__resA7);\r\nbreak;\r\ncase 16:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res74);\r\nbreak;\r\ncase 17:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res75);\r\nbreak;\r\ncase 18:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res76);\r\nbreak;\r\ncase 19:\r\ndata = pci_read_32 ((u_int32_t *) &comet->__res77);\r\nbreak;\r\n}\r\n}
