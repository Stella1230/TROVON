static int set_param_ifnum(const char *val, struct kernel_param *kp)\r\n{\r\nint rv = param_set_int(val, kp);\r\nif (rv)\r\nreturn rv;\r\nif ((ifnum_to_use < 0) || (ifnum_to_use == ipmi_ifnum))\r\nreturn 0;\r\nipmi_po_smi_gone(ipmi_ifnum);\r\nipmi_po_new_smi(ifnum_to_use, NULL);\r\nreturn 0;\r\n}\r\nstatic void dummy_smi_free(struct ipmi_smi_msg *msg)\r\n{\r\natomic_dec(&dummy_count);\r\n}\r\nstatic void dummy_recv_free(struct ipmi_recv_msg *msg)\r\n{\r\natomic_dec(&dummy_count);\r\n}\r\nstatic void receive_handler(struct ipmi_recv_msg *recv_msg, void *handler_data)\r\n{\r\nstruct completion *comp = recv_msg->user_msg_data;\r\nif (comp)\r\ncomplete(comp);\r\n}\r\nstatic int ipmi_request_wait_for_response(ipmi_user_t user,\r\nstruct ipmi_addr *addr,\r\nstruct kernel_ipmi_msg *send_msg)\r\n{\r\nint rv;\r\nstruct completion comp;\r\ninit_completion(&comp);\r\nrv = ipmi_request_supply_msgs(user, addr, 0, send_msg, &comp,\r\n&halt_smi_msg, &halt_recv_msg, 0);\r\nif (rv)\r\nreturn rv;\r\nwait_for_completion(&comp);\r\nreturn halt_recv_msg.msg.data[0];\r\n}\r\nstatic int ipmi_request_in_rc_mode(ipmi_user_t user,\r\nstruct ipmi_addr *addr,\r\nstruct kernel_ipmi_msg *send_msg)\r\n{\r\nint rv;\r\natomic_set(&dummy_count, 2);\r\nrv = ipmi_request_supply_msgs(user, addr, 0, send_msg, NULL,\r\n&halt_smi_msg, &halt_recv_msg, 0);\r\nif (rv) {\r\natomic_set(&dummy_count, 0);\r\nreturn rv;\r\n}\r\nwhile (atomic_read(&dummy_count) > 0) {\r\nipmi_poll_interface(user);\r\ncpu_relax();\r\n}\r\nreturn halt_recv_msg.msg.data[0];\r\n}\r\nstatic void pps_poweroff_atca(ipmi_user_t user)\r\n{\r\nstruct ipmi_system_interface_addr smi_addr;\r\nstruct kernel_ipmi_msg send_msg;\r\nint rv;\r\nsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr.channel = IPMI_BMC_CHANNEL;\r\nsmi_addr.lun = 0;\r\nprintk(KERN_INFO PFX "PPS powerdown hook used");\r\nsend_msg.netfn = IPMI_NETFN_OEM;\r\nsend_msg.cmd = IPMI_ATCA_PPS_GRACEFUL_RESTART;\r\nsend_msg.data = IPMI_ATCA_PPS_IANA;\r\nsend_msg.data_len = 3;\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE) {\r\nprintk(KERN_ERR PFX "Unable to send ATCA ,"\r\n" IPMI error 0x%x\n", rv);\r\n}\r\nreturn;\r\n}\r\nstatic int ipmi_atca_detect(ipmi_user_t user)\r\n{\r\nstruct ipmi_system_interface_addr smi_addr;\r\nstruct kernel_ipmi_msg send_msg;\r\nint rv;\r\nunsigned char data[1];\r\nsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr.channel = IPMI_BMC_CHANNEL;\r\nsmi_addr.lun = 0;\r\nsend_msg.netfn = IPMI_NETFN_ATCA;\r\nsend_msg.cmd = IPMI_ATCA_GET_ADDR_INFO_CMD;\r\ndata[0] = IPMI_PICMG_ID;\r\nsend_msg.data = data;\r\nsend_msg.data_len = sizeof(data);\r\nrv = ipmi_request_wait_for_response(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nprintk(KERN_INFO PFX "ATCA Detect mfg 0x%X prod 0x%X\n",\r\nmfg_id, prod_id);\r\nif ((mfg_id == IPMI_MOTOROLA_MANUFACTURER_ID)\r\n&& (prod_id == IPMI_MOTOROLA_PPS_IPMC_PRODUCT_ID)) {\r\nprintk(KERN_INFO PFX\r\n"Installing Pigeon Point Systems Poweroff Hook\n");\r\natca_oem_poweroff_hook = pps_poweroff_atca;\r\n}\r\nreturn !rv;\r\n}\r\nstatic void ipmi_poweroff_atca(ipmi_user_t user)\r\n{\r\nstruct ipmi_system_interface_addr smi_addr;\r\nstruct kernel_ipmi_msg send_msg;\r\nint rv;\r\nunsigned char data[4];\r\nsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr.channel = IPMI_BMC_CHANNEL;\r\nsmi_addr.lun = 0;\r\nprintk(KERN_INFO PFX "Powering down via ATCA power command\n");\r\nsend_msg.netfn = IPMI_NETFN_ATCA;\r\nsend_msg.cmd = IPMI_ATCA_SET_POWER_CMD;\r\ndata[0] = IPMI_PICMG_ID;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\ndata[3] = 0;\r\nsend_msg.data = data;\r\nsend_msg.data_len = sizeof(data);\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE) {\r\nprintk(KERN_ERR PFX "Unable to send ATCA powerdown message,"\r\n" IPMI error 0x%x\n", rv);\r\ngoto out;\r\n}\r\nif (atca_oem_poweroff_hook)\r\natca_oem_poweroff_hook(user);\r\nout:\r\nreturn;\r\n}\r\nstatic int ipmi_cpi1_detect(ipmi_user_t user)\r\n{\r\nreturn ((mfg_id == IPMI_CPI1_MANUFACTURER_ID)\r\n&& (prod_id == IPMI_CPI1_PRODUCT_ID));\r\n}\r\nstatic void ipmi_poweroff_cpi1(ipmi_user_t user)\r\n{\r\nstruct ipmi_system_interface_addr smi_addr;\r\nstruct ipmi_ipmb_addr ipmb_addr;\r\nstruct kernel_ipmi_msg send_msg;\r\nint rv;\r\nunsigned char data[1];\r\nint slot;\r\nunsigned char hotswap_ipmb;\r\nunsigned char aer_addr;\r\nunsigned char aer_lun;\r\nsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr.channel = IPMI_BMC_CHANNEL;\r\nsmi_addr.lun = 0;\r\nprintk(KERN_INFO PFX "Powering down via CPI1 power command\n");\r\nsend_msg.netfn = IPMI_NETFN_OEM_8 >> 2;\r\nsend_msg.cmd = OEM_GRP_CMD_GET_SLOT_GA;\r\nsend_msg.data = NULL;\r\nsend_msg.data_len = 0;\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv)\r\ngoto out;\r\nslot = halt_recv_msg.msg.data[1];\r\nhotswap_ipmb = (slot > 9) ? (0xb0 + 2 * slot) : (0xae + 2 * slot);\r\nsend_msg.netfn = IPMI_NETFN_SENSOR_EVT >> 2;\r\nsend_msg.cmd = IPMI_CMD_GET_EVENT_RECEIVER;\r\nsend_msg.data = NULL;\r\nsend_msg.data_len = 0;\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv)\r\ngoto out;\r\naer_addr = halt_recv_msg.msg.data[1];\r\naer_lun = halt_recv_msg.msg.data[2];\r\nipmb_addr.addr_type = IPMI_IPMB_ADDR_TYPE;\r\nipmb_addr.channel = 0;\r\nipmb_addr.slave_addr = aer_addr;\r\nipmb_addr.lun = aer_lun;\r\nsend_msg.netfn = IPMI_NETFN_OEM_8 >> 2;\r\nsend_msg.cmd = OEM_GRP_CMD_REQUEST_HOTSWAP_CTRL;\r\nsend_msg.data = &hotswap_ipmb;\r\nsend_msg.data_len = 1;\r\nipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &ipmb_addr,\r\n&send_msg);\r\nsend_msg.netfn = IPMI_NETFN_OEM_1 >> 2;\r\nsend_msg.cmd = OEM_GRP_CMD_SET_RESET_STATE;\r\nsend_msg.data = data;\r\ndata[0] = 1;\r\nsend_msg.data_len = 1;\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv)\r\ngoto out;\r\nsend_msg.netfn = IPMI_NETFN_OEM_1 >> 2;\r\nsend_msg.cmd = OEM_GRP_CMD_SET_POWER_STATE;\r\nsend_msg.data = data;\r\ndata[0] = 1;\r\nsend_msg.data_len = 1;\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv)\r\ngoto out;\r\nout:\r\nreturn;\r\n}\r\nstatic int ipmi_dell_chassis_detect(ipmi_user_t user)\r\n{\r\nconst char ipmi_version_major = ipmi_version & 0xF;\r\nconst char ipmi_version_minor = (ipmi_version >> 4) & 0xF;\r\nconst char mfr[3] = DELL_IANA_MFR_ID;\r\nif (!memcmp(mfr, &mfg_id, sizeof(mfr)) &&\r\nipmi_version_major <= 1 &&\r\nipmi_version_minor < 5)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ipmi_chassis_detect(ipmi_user_t user)\r\n{\r\nreturn (capabilities & 0x80);\r\n}\r\nstatic void ipmi_poweroff_chassis(ipmi_user_t user)\r\n{\r\nstruct ipmi_system_interface_addr smi_addr;\r\nstruct kernel_ipmi_msg send_msg;\r\nint rv;\r\nunsigned char data[1];\r\nsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr.channel = IPMI_BMC_CHANNEL;\r\nsmi_addr.lun = 0;\r\npowercyclefailed:\r\nprintk(KERN_INFO PFX "Powering %s via IPMI chassis control command\n",\r\n(poweroff_powercycle ? "cycle" : "down"));\r\nsend_msg.netfn = IPMI_NETFN_CHASSIS_REQUEST;\r\nsend_msg.cmd = IPMI_CHASSIS_CONTROL_CMD;\r\nif (poweroff_powercycle)\r\ndata[0] = IPMI_CHASSIS_POWER_CYCLE;\r\nelse\r\ndata[0] = IPMI_CHASSIS_POWER_DOWN;\r\nsend_msg.data = data;\r\nsend_msg.data_len = sizeof(data);\r\nrv = ipmi_request_in_rc_mode(user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv) {\r\nif (poweroff_powercycle) {\r\nprintk(KERN_ERR PFX "Unable to send chassis power " \\r\n"cycle message, IPMI error 0x%x\n", rv);\r\npoweroff_powercycle = 0;\r\ngoto powercyclefailed;\r\n}\r\nprintk(KERN_ERR PFX "Unable to send chassis power " \\r\n"down message, IPMI error 0x%x\n", rv);\r\n}\r\n}\r\nstatic void ipmi_poweroff_function(void)\r\n{\r\nif (!ready)\r\nreturn;\r\nspecific_poweroff_func(ipmi_user);\r\n}\r\nstatic void ipmi_po_new_smi(int if_num, struct device *device)\r\n{\r\nstruct ipmi_system_interface_addr smi_addr;\r\nstruct kernel_ipmi_msg send_msg;\r\nint rv;\r\nint i;\r\nif (ready)\r\nreturn;\r\nif ((ifnum_to_use >= 0) && (ifnum_to_use != if_num))\r\nreturn;\r\nrv = ipmi_create_user(if_num, &ipmi_poweroff_handler, NULL,\r\n&ipmi_user);\r\nif (rv) {\r\nprintk(KERN_ERR PFX "could not create IPMI user, error %d\n",\r\nrv);\r\nreturn;\r\n}\r\nipmi_ifnum = if_num;\r\nsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr.channel = IPMI_BMC_CHANNEL;\r\nsmi_addr.lun = 0;\r\nsend_msg.netfn = IPMI_NETFN_APP_REQUEST;\r\nsend_msg.cmd = IPMI_GET_DEVICE_ID_CMD;\r\nsend_msg.data = NULL;\r\nsend_msg.data_len = 0;\r\nrv = ipmi_request_wait_for_response(ipmi_user,\r\n(struct ipmi_addr *) &smi_addr,\r\n&send_msg);\r\nif (rv) {\r\nprintk(KERN_ERR PFX "Unable to send IPMI get device id info,"\r\n" IPMI error 0x%x\n", rv);\r\ngoto out_err;\r\n}\r\nif (halt_recv_msg.msg.data_len < 12) {\r\nprintk(KERN_ERR PFX "(chassis) IPMI get device id info too,"\r\n" short, was %d bytes, needed %d bytes\n",\r\nhalt_recv_msg.msg.data_len, 12);\r\ngoto out_err;\r\n}\r\nmfg_id = (halt_recv_msg.msg.data[7]\r\n| (halt_recv_msg.msg.data[8] << 8)\r\n| (halt_recv_msg.msg.data[9] << 16));\r\nprod_id = (halt_recv_msg.msg.data[10]\r\n| (halt_recv_msg.msg.data[11] << 8));\r\ncapabilities = halt_recv_msg.msg.data[6];\r\nipmi_version = halt_recv_msg.msg.data[5];\r\nfor (i = 0; i < NUM_PO_FUNCS; i++) {\r\nif (poweroff_functions[i].detect(ipmi_user))\r\ngoto found;\r\n}\r\nout_err:\r\nprintk(KERN_ERR PFX "Unable to find a poweroff function that"\r\n" will work, giving up\n");\r\nipmi_destroy_user(ipmi_user);\r\nreturn;\r\nfound:\r\nprintk(KERN_INFO PFX "Found a %s style poweroff function\n",\r\npoweroff_functions[i].platform_type);\r\nspecific_poweroff_func = poweroff_functions[i].poweroff_func;\r\nold_poweroff_func = pm_power_off;\r\npm_power_off = ipmi_poweroff_function;\r\nready = 1;\r\n}\r\nstatic void ipmi_po_smi_gone(int if_num)\r\n{\r\nif (!ready)\r\nreturn;\r\nif (ipmi_ifnum != if_num)\r\nreturn;\r\nready = 0;\r\nipmi_destroy_user(ipmi_user);\r\npm_power_off = old_poweroff_func;\r\n}\r\nstatic int __init ipmi_poweroff_init(void)\r\n{\r\nint rv;\r\nprintk(KERN_INFO "Copyright (C) 2004 MontaVista Software -"\r\n" IPMI Powerdown via sys_reboot.\n");\r\nif (poweroff_powercycle)\r\nprintk(KERN_INFO PFX "Power cycle is enabled.\n");\r\n#ifdef CONFIG_PROC_FS\r\nipmi_table_header = register_sysctl_table(ipmi_root_table);\r\nif (!ipmi_table_header) {\r\nprintk(KERN_ERR PFX "Unable to register powercycle sysctl\n");\r\nrv = -ENOMEM;\r\ngoto out_err;\r\n}\r\n#endif\r\nrv = ipmi_smi_watcher_register(&smi_watcher);\r\n#ifdef CONFIG_PROC_FS\r\nif (rv) {\r\nunregister_sysctl_table(ipmi_table_header);\r\nprintk(KERN_ERR PFX "Unable to register SMI watcher: %d\n", rv);\r\ngoto out_err;\r\n}\r\nout_err:\r\n#endif\r\nreturn rv;\r\n}\r\nstatic void __exit ipmi_poweroff_cleanup(void)\r\n{\r\nint rv;\r\n#ifdef CONFIG_PROC_FS\r\nunregister_sysctl_table(ipmi_table_header);\r\n#endif\r\nipmi_smi_watcher_unregister(&smi_watcher);\r\nif (ready) {\r\nrv = ipmi_destroy_user(ipmi_user);\r\nif (rv)\r\nprintk(KERN_ERR PFX "could not cleanup the IPMI"\r\n" user: 0x%x\n", rv);\r\npm_power_off = old_poweroff_func;\r\n}\r\n}
