static void usb_tranzport_abort_transfers(struct usb_tranzport *dev)\r\n{\r\nif (dev->interrupt_in_running) {\r\ndev->interrupt_in_running = 0;\r\nif (dev->intf)\r\nusb_kill_urb(dev->interrupt_in_urb);\r\n}\r\nif (dev->interrupt_out_busy)\r\nif (dev->intf)\r\nusb_kill_urb(dev->interrupt_out_urb);\r\n}\r\nstatic void usb_tranzport_delete(struct usb_tranzport *dev)\r\n{\r\nusb_tranzport_abort_transfers(dev);\r\nif (dev->intf != NULL) {\r\ndevice_remove_file(&dev->intf->dev, &dev_attr_enable);\r\ndevice_remove_file(&dev->intf->dev, &dev_attr_offline);\r\ndevice_remove_file(&dev->intf->dev, &dev_attr_compress_wheel);\r\n}\r\nusb_free_urb(dev->interrupt_in_urb);\r\nusb_free_urb(dev->interrupt_out_urb);\r\nkfree(dev->ring_buffer);\r\nkfree(dev->interrupt_in_buffer);\r\nkfree(dev->interrupt_out_buffer);\r\nkfree(dev);\r\n}\r\nstatic void usb_tranzport_interrupt_in_callback(struct urb *urb)\r\n{\r\nstruct usb_tranzport *dev = urb->context;\r\nunsigned int next_ring_head;\r\nint retval = -1;\r\nif (urb->status) {\r\nif (urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN) {\r\ngoto exit;\r\n} else {\r\ndbg_info(&dev->intf->dev,\r\n"%s: nonzero status received: %d\n",\r\n__func__, urb->status);\r\ngoto resubmit;\r\n}\r\n}\r\nif (urb->actual_length != 8) {\r\ndev_warn(&dev->intf->dev,\r\n"Urb length was %d bytes!!"\r\n"Do something intelligent\n",\r\nurb->actual_length);\r\n} else {\r\ndbg_info(&dev->intf->dev,\r\n"%s: received: %02x%02x%02x%02x%02x%02x%02x%02x\n",\r\n__func__, dev->interrupt_in_buffer[0],\r\ndev->interrupt_in_buffer[1],\r\ndev->interrupt_in_buffer[2],\r\ndev->interrupt_in_buffer[3],\r\ndev->interrupt_in_buffer[4],\r\ndev->interrupt_in_buffer[5],\r\ndev->interrupt_in_buffer[6],\r\ndev->interrupt_in_buffer[7]);\r\n#if SUPPRESS_EXTRA_OFFLINE_EVENTS\r\nif (dev->offline == 2 && dev->interrupt_in_buffer[1] == 0xff)\r\ngoto resubmit;\r\nif (dev->offline == 1 && dev->interrupt_in_buffer[1] == 0xff) {\r\ndev->offline = 2;\r\ngoto resubmit;\r\n}\r\nif (dev->offline > 0 && dev->interrupt_in_buffer[1] != 0xff)\r\ndev->offline = 0;\r\nif (dev->offline == 0 && dev->interrupt_in_buffer[1] == 0xff)\r\ndev->offline = 1;\r\n#endif\r\ndbg_info(&dev->intf->dev, "%s: head, tail are %x, %x\n",\r\n__func__, dev->ring_head, dev->ring_tail);\r\nnext_ring_head = (dev->ring_head + 1) % ring_buffer_size;\r\nif (next_ring_head != dev->ring_tail) {\r\nmemcpy(&((*dev->ring_buffer)[dev->ring_head]),\r\ndev->interrupt_in_buffer, urb->actual_length);\r\ndev->ring_head = next_ring_head;\r\nretval = 0;\r\nmemset(dev->interrupt_in_buffer, 0, urb->actual_length);\r\n} else {\r\ndev_warn(&dev->intf->dev,\r\n"Ring buffer overflow, %d bytes dropped\n",\r\nurb->actual_length);\r\nmemset(dev->interrupt_in_buffer, 0, urb->actual_length);\r\n}\r\n}\r\nresubmit:\r\nif (dev->interrupt_in_running && dev->intf) {\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&dev->intf->dev,\r\n"usb_submit_urb failed (%d)\n", retval);\r\n}\r\nexit:\r\ndev->interrupt_in_done = 1;\r\nwake_up_interruptible(&dev->read_wait);\r\n}\r\nstatic void usb_tranzport_interrupt_out_callback(struct urb *urb)\r\n{\r\nstruct usb_tranzport *dev = urb->context;\r\nif (urb->status && !(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\ndbg_info(&dev->intf->dev,\r\n"%s - nonzero write interrupt status received: %d\n",\r\n__func__, urb->status);\r\ndev->interrupt_out_busy = 0;\r\nwake_up_interruptible(&dev->write_wait);\r\n}\r\nstatic int usb_tranzport_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_tranzport *dev;\r\nint subminor;\r\nint retval = 0;\r\nstruct usb_interface *interface;\r\nnonseekable_open(inode, file);\r\nsubminor = iminor(inode);\r\nmutex_lock(&disconnect_mutex);\r\ninterface = usb_find_interface(&usb_tranzport_driver, subminor);\r\nif (!interface) {\r\npr_err("%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto unlock_disconnect_exit;\r\n}\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nretval = -ENODEV;\r\ngoto unlock_disconnect_exit;\r\n}\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto unlock_disconnect_exit;\r\n}\r\nif (dev->open_count) {\r\nretval = -EBUSY;\r\ngoto unlock_exit;\r\n}\r\ndev->open_count = 1;\r\ndev->ring_head = 0;\r\ndev->ring_tail = 0;\r\nusb_fill_int_urb(dev->interrupt_in_urb,\r\ninterface_to_usbdev(interface),\r\nusb_rcvintpipe(interface_to_usbdev(interface),\r\ndev->interrupt_in_endpoint->\r\nbEndpointAddress),\r\ndev->interrupt_in_buffer,\r\ndev->interrupt_in_endpoint_size,\r\nusb_tranzport_interrupt_in_callback, dev,\r\ndev->interrupt_in_interval);\r\ndev->interrupt_in_running = 1;\r\ndev->interrupt_in_done = 0;\r\ndev->enable = 1;\r\ndev->offline = 0;\r\ndev->compress_wheel = 1;\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&interface->dev,\r\n"Couldn't submit interrupt_in_urb %d\n", retval);\r\ndev->interrupt_in_running = 0;\r\ndev->open_count = 0;\r\ngoto unlock_exit;\r\n}\r\nfile->private_data = dev;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nunlock_disconnect_exit:\r\nmutex_unlock(&disconnect_mutex);\r\nreturn retval;\r\n}\r\nstatic int usb_tranzport_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_tranzport *dev;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->open_count != 1) {\r\nretval = -ENODEV;\r\ngoto unlock_exit;\r\n}\r\nif (dev->intf == NULL) {\r\nmutex_unlock(&dev->mtx);\r\nusb_tranzport_delete(dev);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (dev->interrupt_out_busy)\r\nwait_event_interruptible_timeout(dev->write_wait,\r\n!dev->interrupt_out_busy,\r\n2 * HZ);\r\nusb_tranzport_abort_transfers(dev);\r\ndev->open_count = 0;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic unsigned int usb_tranzport_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct usb_tranzport *dev;\r\nunsigned int mask = 0;\r\ndev = file->private_data;\r\npoll_wait(file, &dev->read_wait, wait);\r\npoll_wait(file, &dev->write_wait, wait);\r\nif (dev->ring_head != dev->ring_tail)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (!dev->interrupt_out_busy)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic ssize_t usb_tranzport_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_tranzport *dev;\r\nint retval = 0;\r\n#if BUFFERED_READS\r\nint c = 0;\r\n#endif\r\n#if COMPRESS_WHEEL_EVENTS\r\nsigned char oldwheel;\r\nsigned char newwheel;\r\nint cancompress = 1;\r\nint next_tail;\r\n#endif\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->intf == NULL) {\r\nretval = -ENODEV;\r\npr_err("%s: No device or device unplugged %d\n",\r\n__func__, retval);\r\ngoto unlock_exit;\r\n}\r\nwhile (dev->ring_head == dev->ring_tail) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\ndev->interrupt_in_done = 0;\r\nretval = wait_event_interruptible(dev->read_wait,\r\ndev->interrupt_in_done);\r\nif (retval < 0)\r\ngoto unlock_exit;\r\n}\r\ndbg_info(&dev->intf->dev,\r\n"%s: copying to userspace: "\r\n"%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\n__func__,\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[0],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[1],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[2],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[3],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[4],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[5],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[6],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[7]);\r\n#if BUFFERED_READS\r\nc = 0;\r\nwhile ((c < count) && (dev->ring_tail != dev->ring_head)) {\r\n#if COMPRESS_WHEEL_EVENTS\r\nnext_tail = (dev->ring_tail+1) % ring_buffer_size;\r\nif (dev->compress_wheel)\r\ncancompress = 1;\r\nwhile (dev->ring_head != next_tail && cancompress == 1) {\r\nnewwheel = (*dev->ring_buffer)[next_tail].cmd[6];\r\noldwheel = (*dev->ring_buffer)[dev->ring_tail].cmd[6];\r\ndbg_info(&dev->intf->dev,\r\n"%s: trying to compress: "\r\n"%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\n__func__,\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[0],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[1],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[2],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[3],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[4],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[5],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[6],\r\n(*dev->ring_buffer)[dev->ring_tail].cmd[7]);\r\nif (((*dev->ring_buffer)[dev->ring_tail].cmd[6] != 0 &&\r\n(*dev->ring_buffer)[next_tail].cmd[6] != 0) &&\r\n((newwheel > 0 && oldwheel > 0) ||\r\n(newwheel < 0 && oldwheel < 0)) &&\r\n((*dev->ring_buffer)[dev->ring_tail].cmd[2] ==\r\n(*dev->ring_buffer)[next_tail].cmd[2]) &&\r\n((*dev->ring_buffer)[dev->ring_tail].cmd[3] ==\r\n(*dev->ring_buffer)[next_tail].cmd[3]) &&\r\n((*dev->ring_buffer)[dev->ring_tail].cmd[4] ==\r\n(*dev->ring_buffer)[next_tail].cmd[4]) &&\r\n((*dev->ring_buffer)[dev->ring_tail].cmd[5] ==\r\n(*dev->ring_buffer)[next_tail].cmd[5])) {\r\ndbg_info(&dev->intf->dev,\r\n"%s: should compress: "\r\n"%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\n__func__,\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[0],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[1],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[2],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[3],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[4],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[5],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[6],\r\n(*dev->ring_buffer)[dev->ring_tail].\r\ncmd[7]);\r\nnewwheel += oldwheel;\r\nif (oldwheel > 0 && !(newwheel > 0)) {\r\nnewwheel = 0x7f;\r\ncancompress = 0;\r\n}\r\nif (oldwheel < 0 && !(newwheel < 0)) {\r\nnewwheel = 0x80;\r\ncancompress = 0;\r\n}\r\n(*dev->ring_buffer)[next_tail].cmd[6] =\r\nnewwheel;\r\ndev->ring_tail = next_tail;\r\nnext_tail =\r\n(dev->ring_tail + 1) % ring_buffer_size;\r\n} else {\r\ncancompress = 0;\r\n}\r\n}\r\n#endif\r\nif (copy_to_user(\r\n&buffer[c],\r\n&(*dev->ring_buffer)[dev->ring_tail], 8)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\ndev->ring_tail = (dev->ring_tail + 1) % ring_buffer_size;\r\nc += 8;\r\ndbg_info(&dev->intf->dev,\r\n"%s: head, tail are %x, %x\n",\r\n__func__, dev->ring_head, dev->ring_tail);\r\n}\r\nretval = c;\r\n#else\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\nssize_t usb_tranzport_write(struct file *file,\r\nconst char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct usb_tranzport *dev;\r\nsize_t bytes_to_write;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (mutex_lock_interruptible(&dev->mtx)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->intf == NULL) {\r\nretval = -ENODEV;\r\npr_err("%s: No device or device unplugged %d\n",\r\n__func__, retval);\r\ngoto unlock_exit;\r\n}\r\nif (dev->interrupt_out_busy) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\nretval = wait_event_interruptible(dev->write_wait,\r\n!dev->interrupt_out_busy);\r\nif (retval < 0)\r\ngoto unlock_exit;\r\n}\r\nbytes_to_write = min(count,\r\nwrite_buffer_size *\r\ndev->interrupt_out_endpoint_size);\r\nif (bytes_to_write < count)\r\ndev_warn(&dev->intf->dev,\r\n"Write buffer overflow, %zd bytes dropped\n",\r\ncount - bytes_to_write);\r\ndbg_info(&dev->intf->dev,\r\n"%s: count = %zd, bytes_to_write = %zd\n", __func__,\r\ncount, bytes_to_write);\r\nif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL) {\r\ndev_err(&dev->intf->dev, "Endpoint should not be be null!\n");\r\ngoto unlock_exit;\r\n}\r\nusb_fill_int_urb(dev->interrupt_out_urb,\r\ninterface_to_usbdev(dev->intf),\r\nusb_sndintpipe(interface_to_usbdev(dev->intf),\r\ndev->interrupt_out_endpoint->\r\nbEndpointAddress),\r\ndev->interrupt_out_buffer, bytes_to_write,\r\nusb_tranzport_interrupt_out_callback, dev,\r\ndev->interrupt_out_interval);\r\ndev->interrupt_out_busy = 1;\r\nwmb();\r\nretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev->interrupt_out_busy = 0;\r\ndev_err(&dev->intf->dev,\r\n"Couldn't submit interrupt_out_urb %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nretval = bytes_to_write;\r\nunlock_exit:\r\nmutex_unlock(&dev->mtx);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int usb_tranzport_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id) {\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_tranzport *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nint true_size;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&intf->dev, "Out of memory\n");\r\ngoto exit;\r\n}\r\nmutex_init(&dev->mtx);\r\ndev->intf = intf;\r\ninit_waitqueue_head(&dev->read_wait);\r\ninit_waitqueue_head(&dev->write_wait);\r\niface_desc = intf->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint))\r\ndev->interrupt_in_endpoint = endpoint;\r\nif (usb_endpoint_is_int_out(endpoint))\r\ndev->interrupt_out_endpoint = endpoint;\r\n}\r\nif (dev->interrupt_in_endpoint == NULL) {\r\ndev_err(&intf->dev, "Interrupt in endpoint not found\n");\r\ngoto error;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL)\r\ndev_warn(&intf->dev,\r\n"Interrupt out endpoint not found"\r\n"(using control endpoint instead)\n");\r\ndev->interrupt_in_endpoint_size =\r\nle16_to_cpu(dev->interrupt_in_endpoint->wMaxPacketSize);\r\nif (dev->interrupt_in_endpoint_size != 8)\r\ndev_warn(&intf->dev, "Interrupt in endpoint size is not 8!\n");\r\nif (ring_buffer_size == 0)\r\nring_buffer_size = RING_BUFFER_SIZE;\r\ntrue_size = min(ring_buffer_size, RING_BUFFER_SIZE);\r\ndev->ring_buffer =\r\nkmalloc((true_size * sizeof(struct tranzport_cmd)) + 8, GFP_KERNEL);\r\nif (!dev->ring_buffer) {\r\ndev_err(&intf->dev,\r\n"Couldn't allocate ring_buffer size %d\n", true_size);\r\ngoto error;\r\n}\r\ndev->interrupt_in_buffer =\r\nkmalloc(dev->interrupt_in_endpoint_size, GFP_KERNEL);\r\nif (!dev->interrupt_in_buffer) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_in_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_in_urb) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_in_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_endpoint_size =\r\ndev->interrupt_out_endpoint ?\r\nle16_to_cpu(dev->interrupt_out_endpoint->wMaxPacketSize) :\r\nudev->descriptor.bMaxPacketSize0;\r\nif (dev->interrupt_out_endpoint_size != 8)\r\ndev_warn(&intf->dev,\r\n"Interrupt out endpoint size is not 8!)\n");\r\ndev->interrupt_out_buffer =\r\nkmalloc(write_buffer_size * dev->interrupt_out_endpoint_size,\r\nGFP_KERNEL);\r\nif (!dev->interrupt_out_buffer) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_out_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_out_urb) {\r\ndev_err(&intf->dev, "Couldn't allocate interrupt_out_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_interval =\r\nmin_interrupt_in_interval >\r\ndev->interrupt_in_endpoint->bInterval ? min_interrupt_in_interval\r\n: dev->interrupt_in_endpoint->bInterval;\r\nif (dev->interrupt_out_endpoint) {\r\ndev->interrupt_out_interval =\r\nmin_interrupt_out_interval >\r\ndev->interrupt_out_endpoint->bInterval ?\r\nmin_interrupt_out_interval :\r\ndev->interrupt_out_endpoint->bInterval;\r\n}\r\nusb_set_intfdata(intf, dev);\r\nretval = usb_register_dev(intf, &usb_tranzport_class);\r\nif (retval) {\r\ndev_err(&intf->dev,\r\n"Not able to get a minor for this device.\n");\r\nusb_set_intfdata(intf, NULL);\r\ngoto error;\r\n}\r\nretval = device_create_file(&intf->dev, &dev_attr_compress_wheel);\r\nif (retval)\r\ngoto error;\r\nretval = device_create_file(&intf->dev, &dev_attr_enable);\r\nif (retval)\r\ngoto error;\r\nretval = device_create_file(&intf->dev, &dev_attr_offline);\r\nif (retval)\r\ngoto error;\r\ndev_info(&intf->dev,\r\n"Tranzport Device #%d now attached to major %d minor %d\n",\r\n(intf->minor - USB_TRANZPORT_MINOR_BASE), USB_MAJOR,\r\nintf->minor);\r\nexit:\r\nreturn retval;\r\nerror:\r\nusb_tranzport_delete(dev);\r\nreturn retval;\r\n}\r\nstatic void usb_tranzport_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_tranzport *dev;\r\nint minor;\r\nmutex_lock(&disconnect_mutex);\r\ndev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nmutex_lock(&dev->mtx);\r\nminor = intf->minor;\r\nusb_deregister_dev(intf, &usb_tranzport_class);\r\nif (!dev->open_count) {\r\nmutex_unlock(&dev->mtx);\r\nusb_tranzport_delete(dev);\r\n} else {\r\ndev->intf = NULL;\r\nmutex_unlock(&dev->mtx);\r\n}\r\nmutex_unlock(&disconnect_mutex);\r\ndev_info(&intf->dev, "Tranzport Surface #%d now disconnected\n",\r\n(minor - USB_TRANZPORT_MINOR_BASE));\r\n}
