static int\r\nget_ipv6_addr(const char *src, size_t dlen, struct in6_addr *dst, u_int8_t term)\r\n{\r\nconst char *end;\r\nint ret = in6_pton(src, min_t(size_t, dlen, 0xffff), (u8 *)dst, term, &end);\r\nif (ret > 0)\r\nreturn (int)(end - src);\r\nreturn 0;\r\n}\r\nstatic int try_number(const char *data, size_t dlen, u_int32_t array[],\r\nint array_size, char sep, char term)\r\n{\r\nu_int32_t i, len;\r\nmemset(array, 0, sizeof(array[0])*array_size);\r\nfor (i = 0, len = 0; len < dlen && i < array_size; len++, data++) {\r\nif (*data >= '0' && *data <= '9') {\r\narray[i] = array[i]*10 + *data - '0';\r\n}\r\nelse if (*data == sep)\r\ni++;\r\nelse {\r\nif (*data == term && i == array_size - 1)\r\nreturn len;\r\npr_debug("Char %u (got %u nums) `%u' unexpected\n",\r\nlen, i, *data);\r\nreturn 0;\r\n}\r\n}\r\npr_debug("Failed to fill %u numbers separated by %c\n",\r\narray_size, sep);\r\nreturn 0;\r\n}\r\nstatic int try_rfc959(const char *data, size_t dlen,\r\nstruct nf_conntrack_man *cmd, char term)\r\n{\r\nint length;\r\nu_int32_t array[6];\r\nlength = try_number(data, dlen, array, 6, ',', term);\r\nif (length == 0)\r\nreturn 0;\r\ncmd->u3.ip = htonl((array[0] << 24) | (array[1] << 16) |\r\n(array[2] << 8) | array[3]);\r\ncmd->u.tcp.port = htons((array[4] << 8) | array[5]);\r\nreturn length;\r\n}\r\nstatic int get_port(const char *data, int start, size_t dlen, char delim,\r\n__be16 *port)\r\n{\r\nu_int16_t tmp_port = 0;\r\nint i;\r\nfor (i = start; i < dlen; i++) {\r\nif (data[i] == delim) {\r\nif (tmp_port == 0)\r\nbreak;\r\n*port = htons(tmp_port);\r\npr_debug("get_port: return %d\n", tmp_port);\r\nreturn i + 1;\r\n}\r\nelse if (data[i] >= '0' && data[i] <= '9')\r\ntmp_port = tmp_port*10 + data[i] - '0';\r\nelse {\r\npr_debug("get_port: invalid char.\n");\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int try_eprt(const char *data, size_t dlen, struct nf_conntrack_man *cmd,\r\nchar term)\r\n{\r\nchar delim;\r\nint length;\r\nif (dlen <= 3) {\r\npr_debug("EPRT: too short\n");\r\nreturn 0;\r\n}\r\ndelim = data[0];\r\nif (isdigit(delim) || delim < 33 || delim > 126 || data[2] != delim) {\r\npr_debug("try_eprt: invalid delimitter.\n");\r\nreturn 0;\r\n}\r\nif ((cmd->l3num == PF_INET && data[1] != '1') ||\r\n(cmd->l3num == PF_INET6 && data[1] != '2')) {\r\npr_debug("EPRT: invalid protocol number.\n");\r\nreturn 0;\r\n}\r\npr_debug("EPRT: Got %c%c%c\n", delim, data[1], delim);\r\nif (data[1] == '1') {\r\nu_int32_t array[4];\r\nlength = try_number(data + 3, dlen - 3, array, 4, '.', delim);\r\nif (length != 0)\r\ncmd->u3.ip = htonl((array[0] << 24) | (array[1] << 16)\r\n| (array[2] << 8) | array[3]);\r\n} else {\r\nlength = get_ipv6_addr(data + 3, dlen - 3,\r\n(struct in6_addr *)cmd->u3.ip6, delim);\r\n}\r\nif (length == 0)\r\nreturn 0;\r\npr_debug("EPRT: Got IP address!\n");\r\nreturn get_port(data, 3 + length + 1, dlen, delim, &cmd->u.tcp.port);\r\n}\r\nstatic int try_epsv_response(const char *data, size_t dlen,\r\nstruct nf_conntrack_man *cmd, char term)\r\n{\r\nchar delim;\r\nif (dlen <= 3) return 0;\r\ndelim = data[0];\r\nif (isdigit(delim) || delim < 33 || delim > 126 ||\r\ndata[1] != delim || data[2] != delim)\r\nreturn 0;\r\nreturn get_port(data, 3, dlen, delim, &cmd->u.tcp.port);\r\n}\r\nstatic int find_pattern(const char *data, size_t dlen,\r\nconst char *pattern, size_t plen,\r\nchar skip, char term,\r\nunsigned int *numoff,\r\nunsigned int *numlen,\r\nstruct nf_conntrack_man *cmd,\r\nint (*getnum)(const char *, size_t,\r\nstruct nf_conntrack_man *, char))\r\n{\r\nsize_t i;\r\npr_debug("find_pattern `%s': dlen = %Zu\n", pattern, dlen);\r\nif (dlen == 0)\r\nreturn 0;\r\nif (dlen <= plen) {\r\nif (strnicmp(data, pattern, dlen) == 0)\r\nreturn -1;\r\nelse return 0;\r\n}\r\nif (strnicmp(data, pattern, plen) != 0) {\r\n#if 0\r\nsize_t i;\r\npr_debug("ftp: string mismatch\n");\r\nfor (i = 0; i < plen; i++) {\r\npr_debug("ftp:char %u `%c'(%u) vs `%c'(%u)\n",\r\ni, data[i], data[i],\r\npattern[i], pattern[i]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\npr_debug("Pattern matches!\n");\r\nfor (i = plen; data[i] != skip; i++)\r\nif (i == dlen - 1) return -1;\r\ni++;\r\npr_debug("Skipped up to `%c'!\n", skip);\r\n*numoff = i;\r\n*numlen = getnum(data + i, dlen - i, cmd, term);\r\nif (!*numlen)\r\nreturn -1;\r\npr_debug("Match succeeded!\n");\r\nreturn 1;\r\n}\r\nstatic int find_nl_seq(u32 seq, const struct nf_ct_ftp_master *info, int dir)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < info->seq_aft_nl_num[dir]; i++)\r\nif (info->seq_aft_nl[dir][i] == seq)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void update_nl_seq(struct nf_conn *ct, u32 nl_seq,\r\nstruct nf_ct_ftp_master *info, int dir,\r\nstruct sk_buff *skb)\r\n{\r\nunsigned int i, oldest;\r\nfor (i = 0; i < info->seq_aft_nl_num[dir]; i++) {\r\nif (info->seq_aft_nl[dir][i] == nl_seq)\r\nreturn;\r\n}\r\nif (info->seq_aft_nl_num[dir] < NUM_SEQ_TO_REMEMBER) {\r\ninfo->seq_aft_nl[dir][info->seq_aft_nl_num[dir]++] = nl_seq;\r\n} else {\r\nif (before(info->seq_aft_nl[dir][0], info->seq_aft_nl[dir][1]))\r\noldest = 0;\r\nelse\r\noldest = 1;\r\nif (after(nl_seq, info->seq_aft_nl[dir][oldest]))\r\ninfo->seq_aft_nl[dir][oldest] = nl_seq;\r\n}\r\n}\r\nstatic int help(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo)\r\n{\r\nunsigned int dataoff, datalen;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nconst char *fb_ptr;\r\nint ret;\r\nu32 seq;\r\nint dir = CTINFO2DIR(ctinfo);\r\nunsigned int uninitialized_var(matchlen), uninitialized_var(matchoff);\r\nstruct nf_ct_ftp_master *ct_ftp_info = nfct_help_data(ct);\r\nstruct nf_conntrack_expect *exp;\r\nunion nf_inet_addr *daddr;\r\nstruct nf_conntrack_man cmd = {};\r\nunsigned int i;\r\nint found = 0, ends_in_nl;\r\ntypeof(nf_nat_ftp_hook) nf_nat_ftp;\r\nif (ctinfo != IP_CT_ESTABLISHED &&\r\nctinfo != IP_CT_ESTABLISHED_REPLY) {\r\npr_debug("ftp: Conntrackinfo = %u\n", ctinfo);\r\nreturn NF_ACCEPT;\r\n}\r\nth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn NF_ACCEPT;\r\ndataoff = protoff + th->doff * 4;\r\nif (dataoff >= skb->len) {\r\npr_debug("ftp: dataoff(%u) >= skblen(%u)\n", dataoff,\r\nskb->len);\r\nreturn NF_ACCEPT;\r\n}\r\ndatalen = skb->len - dataoff;\r\nspin_lock_bh(&nf_ftp_lock);\r\nfb_ptr = skb_header_pointer(skb, dataoff, datalen, ftp_buffer);\r\nBUG_ON(fb_ptr == NULL);\r\nends_in_nl = (fb_ptr[datalen - 1] == '\n');\r\nseq = ntohl(th->seq) + datalen;\r\nif (!find_nl_seq(ntohl(th->seq), ct_ftp_info, dir)) {\r\nif (unlikely(ct_ftp_info->flags[dir] & NF_CT_FTP_SEQ_PICKUP)) {\r\nct_ftp_info->flags[dir] ^= NF_CT_FTP_SEQ_PICKUP;\r\ngoto skip_nl_seq;\r\n}\r\npr_debug("nf_conntrack_ftp: wrong seq pos %s(%u) or %s(%u)\n",\r\nct_ftp_info->seq_aft_nl_num[dir] > 0 ? "" : "(UNSET)",\r\nct_ftp_info->seq_aft_nl[dir][0],\r\nct_ftp_info->seq_aft_nl_num[dir] > 1 ? "" : "(UNSET)",\r\nct_ftp_info->seq_aft_nl[dir][1]);\r\nret = NF_ACCEPT;\r\ngoto out_update_nl;\r\n}\r\nskip_nl_seq:\r\ncmd.l3num = nf_ct_l3num(ct);\r\nmemcpy(cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,\r\nsizeof(cmd.u3.all));\r\nfor (i = 0; i < ARRAY_SIZE(search[dir]); i++) {\r\nfound = find_pattern(fb_ptr, datalen,\r\nsearch[dir][i].pattern,\r\nsearch[dir][i].plen,\r\nsearch[dir][i].skip,\r\nsearch[dir][i].term,\r\n&matchoff, &matchlen,\r\n&cmd,\r\nsearch[dir][i].getnum);\r\nif (found) break;\r\n}\r\nif (found == -1) {\r\npr_debug("conntrack_ftp: partial %s %u+%u\n",\r\nsearch[dir][i].pattern, ntohl(th->seq), datalen);\r\nret = NF_DROP;\r\ngoto out;\r\n} else if (found == 0) {\r\nret = NF_ACCEPT;\r\ngoto out_update_nl;\r\n}\r\npr_debug("conntrack_ftp: match `%.*s' (%u bytes at %u)\n",\r\nmatchlen, fb_ptr + matchoff,\r\nmatchlen, ntohl(th->seq) + matchoff);\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL) {\r\nret = NF_DROP;\r\ngoto out;\r\n}\r\ndaddr = &ct->tuplehash[!dir].tuple.dst.u3;\r\nif ((cmd.l3num == nf_ct_l3num(ct)) &&\r\nmemcmp(&cmd.u3.all, &ct->tuplehash[dir].tuple.src.u3.all,\r\nsizeof(cmd.u3.all))) {\r\nif (cmd.l3num == PF_INET) {\r\npr_debug("conntrack_ftp: NOT RECORDING: %pI4 != %pI4\n",\r\n&cmd.u3.ip,\r\n&ct->tuplehash[dir].tuple.src.u3.ip);\r\n} else {\r\npr_debug("conntrack_ftp: NOT RECORDING: %pI6 != %pI6\n",\r\ncmd.u3.ip6,\r\nct->tuplehash[dir].tuple.src.u3.ip6);\r\n}\r\nif (!loose) {\r\nret = NF_ACCEPT;\r\ngoto out_put_expect;\r\n}\r\ndaddr = &cmd.u3;\r\n}\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, cmd.l3num,\r\n&ct->tuplehash[!dir].tuple.src.u3, daddr,\r\nIPPROTO_TCP, NULL, &cmd.u.tcp.port);\r\nnf_nat_ftp = rcu_dereference(nf_nat_ftp_hook);\r\nif (nf_nat_ftp && ct->status & IPS_NAT_MASK)\r\nret = nf_nat_ftp(skb, ctinfo, search[dir][i].ftptype,\r\nprotoff, matchoff, matchlen, exp);\r\nelse {\r\nif (nf_ct_expect_related(exp) != 0)\r\nret = NF_DROP;\r\nelse\r\nret = NF_ACCEPT;\r\n}\r\nout_put_expect:\r\nnf_ct_expect_put(exp);\r\nout_update_nl:\r\nif (ends_in_nl)\r\nupdate_nl_seq(ct, seq, ct_ftp_info, dir, skb);\r\nout:\r\nspin_unlock_bh(&nf_ftp_lock);\r\nreturn ret;\r\n}\r\nstatic int nf_ct_ftp_from_nlattr(struct nlattr *attr, struct nf_conn *ct)\r\n{\r\nstruct nf_ct_ftp_master *ftp = nfct_help_data(ct);\r\nftp->flags[IP_CT_DIR_ORIGINAL] |= NF_CT_FTP_SEQ_PICKUP;\r\nftp->flags[IP_CT_DIR_REPLY] |= NF_CT_FTP_SEQ_PICKUP;\r\nreturn 0;\r\n}\r\nstatic void nf_conntrack_ftp_fini(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ports_c; i++) {\r\nfor (j = 0; j < 2; j++) {\r\nif (ftp[i][j].me == NULL)\r\ncontinue;\r\npr_debug("nf_ct_ftp: unregistering helper for pf: %d "\r\n"port: %d\n",\r\nftp[i][j].tuple.src.l3num, ports[i]);\r\nnf_conntrack_helper_unregister(&ftp[i][j]);\r\n}\r\n}\r\nkfree(ftp_buffer);\r\n}\r\nstatic int __init nf_conntrack_ftp_init(void)\r\n{\r\nint i, j = -1, ret = 0;\r\nftp_buffer = kmalloc(65536, GFP_KERNEL);\r\nif (!ftp_buffer)\r\nreturn -ENOMEM;\r\nif (ports_c == 0)\r\nports[ports_c++] = FTP_PORT;\r\nfor (i = 0; i < ports_c; i++) {\r\nftp[i][0].tuple.src.l3num = PF_INET;\r\nftp[i][1].tuple.src.l3num = PF_INET6;\r\nfor (j = 0; j < 2; j++) {\r\nftp[i][j].data_len = sizeof(struct nf_ct_ftp_master);\r\nftp[i][j].tuple.src.u.tcp.port = htons(ports[i]);\r\nftp[i][j].tuple.dst.protonum = IPPROTO_TCP;\r\nftp[i][j].expect_policy = &ftp_exp_policy;\r\nftp[i][j].me = THIS_MODULE;\r\nftp[i][j].help = help;\r\nftp[i][j].from_nlattr = nf_ct_ftp_from_nlattr;\r\nif (ports[i] == FTP_PORT)\r\nsprintf(ftp[i][j].name, "ftp");\r\nelse\r\nsprintf(ftp[i][j].name, "ftp-%d", ports[i]);\r\npr_debug("nf_ct_ftp: registering helper for pf: %d "\r\n"port: %d\n",\r\nftp[i][j].tuple.src.l3num, ports[i]);\r\nret = nf_conntrack_helper_register(&ftp[i][j]);\r\nif (ret) {\r\nprintk(KERN_ERR "nf_ct_ftp: failed to register"\r\n" helper for pf: %d port: %d\n",\r\nftp[i][j].tuple.src.l3num, ports[i]);\r\nnf_conntrack_ftp_fini();\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
