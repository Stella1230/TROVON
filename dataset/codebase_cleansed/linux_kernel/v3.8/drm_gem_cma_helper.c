static unsigned int get_gem_mmap_offset(struct drm_gem_object *obj)\r\n{\r\nreturn (unsigned int)obj->map_list.hash.key << PAGE_SHIFT;\r\n}\r\nstatic void drm_gem_cma_buf_destroy(struct drm_device *drm,\r\nstruct drm_gem_cma_object *cma_obj)\r\n{\r\ndma_free_writecombine(drm->dev, cma_obj->base.size, cma_obj->vaddr,\r\ncma_obj->paddr);\r\n}\r\nstruct drm_gem_cma_object *drm_gem_cma_create(struct drm_device *drm,\r\nunsigned int size)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct drm_gem_object *gem_obj;\r\nint ret;\r\nsize = round_up(size, PAGE_SIZE);\r\ncma_obj = kzalloc(sizeof(*cma_obj), GFP_KERNEL);\r\nif (!cma_obj)\r\nreturn ERR_PTR(-ENOMEM);\r\ncma_obj->vaddr = dma_alloc_writecombine(drm->dev, size,\r\n&cma_obj->paddr, GFP_KERNEL | __GFP_NOWARN);\r\nif (!cma_obj->vaddr) {\r\ndev_err(drm->dev, "failed to allocate buffer with size %d\n", size);\r\nret = -ENOMEM;\r\ngoto err_dma_alloc;\r\n}\r\ngem_obj = &cma_obj->base;\r\nret = drm_gem_object_init(drm, gem_obj, size);\r\nif (ret)\r\ngoto err_obj_init;\r\nret = drm_gem_create_mmap_offset(gem_obj);\r\nif (ret)\r\ngoto err_create_mmap_offset;\r\nreturn cma_obj;\r\nerr_create_mmap_offset:\r\ndrm_gem_object_release(gem_obj);\r\nerr_obj_init:\r\ndrm_gem_cma_buf_destroy(drm, cma_obj);\r\nerr_dma_alloc:\r\nkfree(cma_obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct drm_gem_cma_object *drm_gem_cma_create_with_handle(\r\nstruct drm_file *file_priv,\r\nstruct drm_device *drm, unsigned int size,\r\nunsigned int *handle)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct drm_gem_object *gem_obj;\r\nint ret;\r\ncma_obj = drm_gem_cma_create(drm, size);\r\nif (IS_ERR(cma_obj))\r\nreturn cma_obj;\r\ngem_obj = &cma_obj->base;\r\nret = drm_gem_handle_create(file_priv, gem_obj, handle);\r\nif (ret)\r\ngoto err_handle_create;\r\ndrm_gem_object_unreference_unlocked(gem_obj);\r\nreturn cma_obj;\r\nerr_handle_create:\r\ndrm_gem_cma_free_object(gem_obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid drm_gem_cma_free_object(struct drm_gem_object *gem_obj)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nif (gem_obj->map_list.map)\r\ndrm_gem_free_mmap_offset(gem_obj);\r\ndrm_gem_object_release(gem_obj);\r\ncma_obj = to_drm_gem_cma_obj(gem_obj);\r\ndrm_gem_cma_buf_destroy(gem_obj->dev, cma_obj);\r\nkfree(cma_obj);\r\n}\r\nint drm_gem_cma_dumb_create(struct drm_file *file_priv,\r\nstruct drm_device *dev, struct drm_mode_create_dumb *args)\r\n{\r\nstruct drm_gem_cma_object *cma_obj;\r\nint min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\r\nif (args->pitch < min_pitch)\r\nargs->pitch = min_pitch;\r\nif (args->size < args->pitch * args->height)\r\nargs->size = args->pitch * args->height;\r\ncma_obj = drm_gem_cma_create_with_handle(file_priv, dev,\r\nargs->size, &args->handle);\r\nif (IS_ERR(cma_obj))\r\nreturn PTR_ERR(cma_obj);\r\nreturn 0;\r\n}\r\nint drm_gem_cma_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *drm, uint32_t handle, uint64_t *offset)\r\n{\r\nstruct drm_gem_object *gem_obj;\r\nmutex_lock(&drm->struct_mutex);\r\ngem_obj = drm_gem_object_lookup(drm, file_priv, handle);\r\nif (!gem_obj) {\r\ndev_err(drm->dev, "failed to lookup gem object\n");\r\nmutex_unlock(&drm->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\n*offset = get_gem_mmap_offset(gem_obj);\r\ndrm_gem_object_unreference(gem_obj);\r\nmutex_unlock(&drm->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_gem_cma_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *gem_obj;\r\nstruct drm_gem_cma_object *cma_obj;\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret)\r\nreturn ret;\r\ngem_obj = vma->vm_private_data;\r\ncma_obj = to_drm_gem_cma_obj(gem_obj);\r\nret = remap_pfn_range(vma, vma->vm_start, cma_obj->paddr >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot);\r\nif (ret)\r\ndrm_gem_vm_close(vma);\r\nreturn ret;\r\n}\r\nint drm_gem_cma_dumb_destroy(struct drm_file *file_priv,\r\nstruct drm_device *drm, unsigned int handle)\r\n{\r\nreturn drm_gem_handle_delete(file_priv, handle);\r\n}
