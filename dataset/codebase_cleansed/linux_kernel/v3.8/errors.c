void FPU_illegal(void)\r\n{\r\nmath_abort(FPU_info, SIGILL);\r\n}\r\nvoid FPU_printall(void)\r\n{\r\nint i;\r\nstatic const char *tag_desc[] = { "Valid", "Zero", "ERROR", "Empty",\r\n"DeNorm", "Inf", "NaN"\r\n};\r\nu_char byte1, FPU_modrm;\r\nunsigned long address = FPU_ORIG_EIP;\r\nRE_ENTRANT_CHECK_OFF;\r\nprintk("At %p:", (void *)address);\r\nif (FPU_CS == __USER_CS) {\r\n#define MAX_PRINTED_BYTES 20\r\nfor (i = 0; i < MAX_PRINTED_BYTES; i++) {\r\nFPU_get_user(byte1, (u_char __user *) address);\r\nif ((byte1 & 0xf8) == 0xd8) {\r\nprintk(" %02x", byte1);\r\nbreak;\r\n}\r\nprintk(" [%02x]", byte1);\r\naddress++;\r\n}\r\nif (i == MAX_PRINTED_BYTES)\r\nprintk(" [more..]\n");\r\nelse {\r\nFPU_get_user(FPU_modrm, 1 + (u_char __user *) address);\r\nif (FPU_modrm >= 0300)\r\nprintk(" %02x (%02x+%d)\n", FPU_modrm,\r\nFPU_modrm & 0xf8, FPU_modrm & 7);\r\nelse\r\nprintk(" /%d, mod=%d rm=%d\n",\r\n(FPU_modrm >> 3) & 7,\r\n(FPU_modrm >> 6) & 3, FPU_modrm & 7);\r\n}\r\n} else {\r\nprintk("%04x\n", FPU_CS);\r\n}\r\npartial_status = status_word();\r\n#ifdef DEBUGGING\r\nif (partial_status & SW_Backward)\r\nprintk("SW: backward compatibility\n");\r\nif (partial_status & SW_C3)\r\nprintk("SW: condition bit 3\n");\r\nif (partial_status & SW_C2)\r\nprintk("SW: condition bit 2\n");\r\nif (partial_status & SW_C1)\r\nprintk("SW: condition bit 1\n");\r\nif (partial_status & SW_C0)\r\nprintk("SW: condition bit 0\n");\r\nif (partial_status & SW_Summary)\r\nprintk("SW: exception summary\n");\r\nif (partial_status & SW_Stack_Fault)\r\nprintk("SW: stack fault\n");\r\nif (partial_status & SW_Precision)\r\nprintk("SW: loss of precision\n");\r\nif (partial_status & SW_Underflow)\r\nprintk("SW: underflow\n");\r\nif (partial_status & SW_Overflow)\r\nprintk("SW: overflow\n");\r\nif (partial_status & SW_Zero_Div)\r\nprintk("SW: divide by zero\n");\r\nif (partial_status & SW_Denorm_Op)\r\nprintk("SW: denormalized operand\n");\r\nif (partial_status & SW_Invalid)\r\nprintk("SW: invalid operation\n");\r\n#endif\r\nprintk(" SW: b=%d st=%d es=%d sf=%d cc=%d%d%d%d ef=%d%d%d%d%d%d\n", partial_status & 0x8000 ? 1 : 0,\r\n(partial_status & 0x3800) >> 11,\r\npartial_status & 0x80 ? 1 : 0,\r\npartial_status & 0x40 ? 1 : 0,\r\npartial_status & SW_C3 ? 1 : 0, partial_status & SW_C2 ? 1 : 0,\r\npartial_status & SW_C1 ? 1 : 0, partial_status & SW_C0 ? 1 : 0,\r\npartial_status & SW_Precision ? 1 : 0,\r\npartial_status & SW_Underflow ? 1 : 0,\r\npartial_status & SW_Overflow ? 1 : 0,\r\npartial_status & SW_Zero_Div ? 1 : 0,\r\npartial_status & SW_Denorm_Op ? 1 : 0,\r\npartial_status & SW_Invalid ? 1 : 0);\r\nprintk(" CW: ic=%d rc=%d%d pc=%d%d iem=%d ef=%d%d%d%d%d%d\n",\r\ncontrol_word & 0x1000 ? 1 : 0,\r\n(control_word & 0x800) >> 11, (control_word & 0x400) >> 10,\r\n(control_word & 0x200) >> 9, (control_word & 0x100) >> 8,\r\ncontrol_word & 0x80 ? 1 : 0,\r\ncontrol_word & SW_Precision ? 1 : 0,\r\ncontrol_word & SW_Underflow ? 1 : 0,\r\ncontrol_word & SW_Overflow ? 1 : 0,\r\ncontrol_word & SW_Zero_Div ? 1 : 0,\r\ncontrol_word & SW_Denorm_Op ? 1 : 0,\r\ncontrol_word & SW_Invalid ? 1 : 0);\r\nfor (i = 0; i < 8; i++) {\r\nFPU_REG *r = &st(i);\r\nu_char tagi = FPU_gettagi(i);\r\nswitch (tagi) {\r\ncase TAG_Empty:\r\ncontinue;\r\nbreak;\r\ncase TAG_Zero:\r\ncase TAG_Special:\r\ntagi = FPU_Special(r);\r\ncase TAG_Valid:\r\nprintk("st(%d) %c .%04lx %04lx %04lx %04lx e%+-6d ", i,\r\ngetsign(r) ? '-' : '+',\r\n(long)(r->sigh >> 16),\r\n(long)(r->sigh & 0xFFFF),\r\n(long)(r->sigl >> 16),\r\n(long)(r->sigl & 0xFFFF),\r\nexponent(r) - EXP_BIAS + 1);\r\nbreak;\r\ndefault:\r\nprintk("Whoops! Error in errors.c: tag%d is %d ", i,\r\ntagi);\r\ncontinue;\r\nbreak;\r\n}\r\nprintk("%s\n", tag_desc[(int)(unsigned)tagi]);\r\n}\r\nRE_ENTRANT_CHECK_ON;\r\n}\r\nasmlinkage void FPU_exception(int n)\r\n{\r\nint i, int_type;\r\nint_type = 0;\r\nif (n & EX_INTERNAL) {\r\nint_type = n - EX_INTERNAL;\r\nn = EX_INTERNAL;\r\npartial_status |= (SW_Exc_Mask | SW_Summary | SW_Backward);\r\n} else {\r\nn &= (SW_Exc_Mask);\r\npartial_status |= n;\r\nif (partial_status & ~control_word & CW_Exceptions)\r\npartial_status |= (SW_Summary | SW_Backward);\r\nif (n & (SW_Stack_Fault | EX_Precision)) {\r\nif (!(n & SW_C1))\r\npartial_status &= ~SW_C1;\r\n}\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nif ((~control_word & n & CW_Exceptions) || (n == EX_INTERNAL)) {\r\n#ifdef PRINT_MESSAGES\r\nprintk(FPU_VERSION " " __DATE__ " (C) W. Metzenthen.\n");\r\n#endif\r\nfor (i = 0; exception_names[i].type; i++)\r\nif ((exception_names[i].type & n) ==\r\nexception_names[i].type)\r\nbreak;\r\nif (exception_names[i].type) {\r\n#ifdef PRINT_MESSAGES\r\nprintk("FP Exception: %s!\n", exception_names[i].name);\r\n#endif\r\n} else\r\nprintk("FPU emulator: Unknown Exception: 0x%04x!\n", n);\r\nif (n == EX_INTERNAL) {\r\nprintk("FPU emulator: Internal error type 0x%04x\n",\r\nint_type);\r\nFPU_printall();\r\n}\r\n#ifdef PRINT_MESSAGES\r\nelse\r\nFPU_printall();\r\n#endif\r\n}\r\nRE_ENTRANT_CHECK_ON;\r\n#ifdef __DEBUG__\r\nmath_abort(FPU_info, SIGFPE);\r\n#endif\r\n}\r\nint real_1op_NaN(FPU_REG *a)\r\n{\r\nint signalling, isNaN;\r\nisNaN = (exponent(a) == EXP_OVER) && (a->sigh & 0x80000000);\r\nsignalling = isNaN && !(a->sigh & 0x40000000);\r\nif (!signalling) {\r\nif (!isNaN) {\r\nif (control_word & CW_Invalid) {\r\nreg_copy(&CONST_QNaN, a);\r\n}\r\nEXCEPTION(EX_Invalid);\r\nreturn (!(control_word & CW_Invalid) ? FPU_Exception :\r\n0) | TAG_Special;\r\n}\r\nreturn TAG_Special;\r\n}\r\nif (control_word & CW_Invalid) {\r\nif (!(a->sigh & 0x80000000)) {\r\nreg_copy(&CONST_QNaN, a);\r\n}\r\na->sigh |= 0x40000000;\r\n}\r\nEXCEPTION(EX_Invalid);\r\nreturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) | TAG_Special;\r\n}\r\nint real_2op_NaN(FPU_REG const *b, u_char tagb,\r\nint deststnr, FPU_REG const *defaultNaN)\r\n{\r\nFPU_REG *dest = &st(deststnr);\r\nFPU_REG const *a = dest;\r\nu_char taga = FPU_gettagi(deststnr);\r\nFPU_REG const *x;\r\nint signalling, unsupported;\r\nif (taga == TAG_Special)\r\ntaga = FPU_Special(a);\r\nif (tagb == TAG_Special)\r\ntagb = FPU_Special(b);\r\nunsupported = ((taga == TW_NaN)\r\n&& !((exponent(a) == EXP_OVER)\r\n&& (a->sigh & 0x80000000)))\r\n|| ((tagb == TW_NaN)\r\n&& !((exponent(b) == EXP_OVER) && (b->sigh & 0x80000000)));\r\nif (unsupported) {\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_regi(&CONST_QNaN, TAG_Special, deststnr);\r\n}\r\nEXCEPTION(EX_Invalid);\r\nreturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) |\r\nTAG_Special;\r\n}\r\nif (taga == TW_NaN) {\r\nx = a;\r\nif (tagb == TW_NaN) {\r\nsignalling = !(a->sigh & b->sigh & 0x40000000);\r\nif (significand(b) > significand(a))\r\nx = b;\r\nelse if (significand(b) == significand(a)) {\r\nx = defaultNaN;\r\n}\r\n} else {\r\nsignalling = !(a->sigh & 0x40000000);\r\n}\r\n} else\r\n#ifdef PARANOID\r\nif (tagb == TW_NaN)\r\n#endif\r\n{\r\nsignalling = !(b->sigh & 0x40000000);\r\nx = b;\r\n}\r\n#ifdef PARANOID\r\nelse {\r\nsignalling = 0;\r\nEXCEPTION(EX_INTERNAL | 0x113);\r\nx = &CONST_QNaN;\r\n}\r\n#endif\r\nif ((!signalling) || (control_word & CW_Invalid)) {\r\nif (!x)\r\nx = b;\r\nif (!(x->sigh & 0x80000000))\r\nx = &CONST_QNaN;\r\nFPU_copy_to_regi(x, TAG_Special, deststnr);\r\nif (!signalling)\r\nreturn TAG_Special;\r\ndest->sigh |= 0x40000000;\r\n}\r\nEXCEPTION(EX_Invalid);\r\nreturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) | TAG_Special;\r\n}\r\nasmlinkage int arith_invalid(int deststnr)\r\n{\r\nEXCEPTION(EX_Invalid);\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_regi(&CONST_QNaN, TAG_Special, deststnr);\r\n}\r\nreturn (!(control_word & CW_Invalid) ? FPU_Exception : 0) | TAG_Valid;\r\n}\r\nasmlinkage int FPU_divide_by_zero(int deststnr, u_char sign)\r\n{\r\nFPU_REG *dest = &st(deststnr);\r\nint tag = TAG_Valid;\r\nif (control_word & CW_ZeroDiv) {\r\nFPU_copy_to_regi(&CONST_INF, TAG_Special, deststnr);\r\nsetsign(dest, sign);\r\ntag = TAG_Special;\r\n}\r\nEXCEPTION(EX_ZeroDiv);\r\nreturn (!(control_word & CW_ZeroDiv) ? FPU_Exception : 0) | tag;\r\n}\r\nint set_precision_flag(int flags)\r\n{\r\nif (control_word & CW_Precision) {\r\npartial_status &= ~(SW_C1 & flags);\r\npartial_status |= flags;\r\nreturn 0;\r\n} else {\r\nEXCEPTION(flags);\r\nreturn 1;\r\n}\r\n}\r\nasmlinkage void set_precision_flag_up(void)\r\n{\r\nif (control_word & CW_Precision)\r\npartial_status |= (SW_Precision | SW_C1);\r\nelse\r\nEXCEPTION(EX_Precision | SW_C1);\r\n}\r\nasmlinkage void set_precision_flag_down(void)\r\n{\r\nif (control_word & CW_Precision) {\r\npartial_status &= ~SW_C1;\r\npartial_status |= SW_Precision;\r\n} else\r\nEXCEPTION(EX_Precision);\r\n}\r\nasmlinkage int denormal_operand(void)\r\n{\r\nif (control_word & CW_Denormal) {\r\npartial_status |= SW_Denorm_Op;\r\nreturn TAG_Special;\r\n} else {\r\nEXCEPTION(EX_Denormal);\r\nreturn TAG_Special | FPU_Exception;\r\n}\r\n}\r\nasmlinkage int arith_overflow(FPU_REG *dest)\r\n{\r\nint tag = TAG_Valid;\r\nif (control_word & CW_Overflow) {\r\nreg_copy(&CONST_INF, dest);\r\ntag = TAG_Special;\r\n} else {\r\naddexponent(dest, (-3 * (1 << 13)));\r\n}\r\nEXCEPTION(EX_Overflow);\r\nif (control_word & CW_Overflow) {\r\nEXCEPTION(EX_Precision | SW_C1);\r\nreturn tag;\r\n}\r\nreturn tag;\r\n}\r\nasmlinkage int arith_underflow(FPU_REG *dest)\r\n{\r\nint tag = TAG_Valid;\r\nif (control_word & CW_Underflow) {\r\nif (exponent16(dest) <= EXP_UNDER - 63) {\r\nreg_copy(&CONST_Z, dest);\r\npartial_status &= ~SW_C1;\r\ntag = TAG_Zero;\r\n} else {\r\nstdexp(dest);\r\n}\r\n} else {\r\naddexponent(dest, (3 * (1 << 13)) + EXTENDED_Ebias);\r\n}\r\nEXCEPTION(EX_Underflow);\r\nif (control_word & CW_Underflow) {\r\nEXCEPTION(EX_Precision);\r\nreturn tag;\r\n}\r\nreturn tag;\r\n}\r\nvoid FPU_stack_overflow(void)\r\n{\r\nif (control_word & CW_Invalid) {\r\ntop--;\r\nFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\r\n}\r\nEXCEPTION(EX_StackOver);\r\nreturn;\r\n}\r\nvoid FPU_stack_underflow(void)\r\n{\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_reg0(&CONST_QNaN, TAG_Special);\r\n}\r\nEXCEPTION(EX_StackUnder);\r\nreturn;\r\n}\r\nvoid FPU_stack_underflow_i(int i)\r\n{\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_regi(&CONST_QNaN, TAG_Special, i);\r\n}\r\nEXCEPTION(EX_StackUnder);\r\nreturn;\r\n}\r\nvoid FPU_stack_underflow_pop(int i)\r\n{\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_regi(&CONST_QNaN, TAG_Special, i);\r\nFPU_pop();\r\n}\r\nEXCEPTION(EX_StackUnder);\r\nreturn;\r\n}
