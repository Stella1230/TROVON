static unsigned int jp_do_irq(unsigned int irq)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic irqreturn_t jp_handle_irq_event(unsigned int irq,\r\nstruct irqaction *action)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic void jp_tasklet_action(struct softirq_action *a)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\n}\r\nstatic void jp_ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\n}\r\nstatic unsigned long jp_shrink_inactive_list(unsigned long max_scan,\r\nstruct zone *zone,\r\nstruct scan_control *sc)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_hrtimer_start(struct hrtimer *timer, ktime_t tim,\r\nconst enum hrtimer_mode mode)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_scsi_dispatch_cmd(struct scsi_cmnd *cmd)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nint jp_generic_ide_ioctl(ide_drive_t *drive, struct file *file,\r\nstruct block_device *bdev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic enum ctype parse_cp_type(const char *what, size_t count)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cp_type); i++) {\r\nif (!strcmp(what, cp_type[i]))\r\nreturn i + 1;\r\n}\r\nreturn CT_NONE;\r\n}\r\nstatic const char *cp_type_to_str(enum ctype type)\r\n{\r\nif (type == CT_NONE || type < 0 || type > ARRAY_SIZE(cp_type))\r\nreturn "None";\r\nreturn cp_type[type - 1];\r\n}\r\nstatic const char *cp_name_to_str(enum cname name)\r\n{\r\nif (name == CN_INVALID || name < 0 || name > ARRAY_SIZE(cp_name))\r\nreturn "INVALID";\r\nreturn cp_name[name - 1];\r\n}\r\nstatic int lkdtm_parse_commandline(void)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif (cpoint_count < 1 || recur_count < 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&count_lock, flags);\r\ncount = cpoint_count;\r\nspin_unlock_irqrestore(&count_lock, flags);\r\nif (!cpoint_type && !cpoint_name)\r\nreturn 0;\r\nif (!cpoint_type || !cpoint_name)\r\nreturn -EINVAL;\r\ncptype = parse_cp_type(cpoint_type, strlen(cpoint_type));\r\nif (cptype == CT_NONE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(cp_name); i++) {\r\nif (!strcmp(cpoint_name, cp_name[i])) {\r\ncpoint = i + 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int recursive_loop(int a)\r\n{\r\nchar buf[1024];\r\nmemset(buf,0xFF,1024);\r\nrecur_count--;\r\nif (!recur_count)\r\nreturn 0;\r\nelse\r\nreturn recursive_loop(a);\r\n}\r\nstatic void lkdtm_do_action(enum ctype which)\r\n{\r\nswitch (which) {\r\ncase CT_PANIC:\r\npanic("dumptest");\r\nbreak;\r\ncase CT_BUG:\r\nBUG();\r\nbreak;\r\ncase CT_EXCEPTION:\r\n*((int *) 0) = 0;\r\nbreak;\r\ncase CT_LOOP:\r\nfor (;;)\r\n;\r\nbreak;\r\ncase CT_OVERFLOW:\r\n(void) recursive_loop(0);\r\nbreak;\r\ncase CT_CORRUPT_STACK: {\r\nvolatile u32 data[8];\r\nvolatile u32 *p = data;\r\np[12] = 0x12345678;\r\nbreak;\r\n}\r\ncase CT_UNALIGNED_LOAD_STORE_WRITE: {\r\nstatic u8 data[5] __attribute__((aligned(4))) = {1, 2,\r\n3, 4, 5};\r\nu32 *p;\r\nu32 val = 0x12345678;\r\np = (u32 *)(data + 1);\r\nif (*p == 0)\r\nval = 0x87654321;\r\n*p = val;\r\nbreak;\r\n}\r\ncase CT_OVERWRITE_ALLOCATION: {\r\nsize_t len = 1020;\r\nu32 *data = kmalloc(len, GFP_KERNEL);\r\ndata[1024 / sizeof(u32)] = 0x12345678;\r\nkfree(data);\r\nbreak;\r\n}\r\ncase CT_WRITE_AFTER_FREE: {\r\nsize_t len = 1024;\r\nu32 *data = kmalloc(len, GFP_KERNEL);\r\nkfree(data);\r\nschedule();\r\nmemset(data, 0x78, len);\r\nbreak;\r\n}\r\ncase CT_SOFTLOCKUP:\r\npreempt_disable();\r\nfor (;;)\r\ncpu_relax();\r\nbreak;\r\ncase CT_HARDLOCKUP:\r\nlocal_irq_disable();\r\nfor (;;)\r\ncpu_relax();\r\nbreak;\r\ncase CT_HUNG_TASK:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\nbreak;\r\ncase CT_NONE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void lkdtm_handler(void)\r\n{\r\nunsigned long flags;\r\nbool do_it = false;\r\nspin_lock_irqsave(&count_lock, flags);\r\ncount--;\r\nprintk(KERN_INFO "lkdtm: Crash point %s of type %s hit, trigger in %d rounds\n",\r\ncp_name_to_str(cpoint), cp_type_to_str(cptype), count);\r\nif (count == 0) {\r\ndo_it = true;\r\ncount = cpoint_count;\r\n}\r\nspin_unlock_irqrestore(&count_lock, flags);\r\nif (do_it)\r\nlkdtm_do_action(cptype);\r\n}\r\nstatic int lkdtm_register_cpoint(enum cname which)\r\n{\r\nint ret;\r\ncpoint = CN_INVALID;\r\nif (lkdtm.entry != NULL)\r\nunregister_jprobe(&lkdtm);\r\nswitch (which) {\r\ncase CN_DIRECT:\r\nlkdtm_do_action(cptype);\r\nreturn 0;\r\ncase CN_INT_HARDWARE_ENTRY:\r\nlkdtm.kp.symbol_name = "do_IRQ";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_do_irq;\r\nbreak;\r\ncase CN_INT_HW_IRQ_EN:\r\nlkdtm.kp.symbol_name = "handle_IRQ_event";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_handle_irq_event;\r\nbreak;\r\ncase CN_INT_TASKLET_ENTRY:\r\nlkdtm.kp.symbol_name = "tasklet_action";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_tasklet_action;\r\nbreak;\r\ncase CN_FS_DEVRW:\r\nlkdtm.kp.symbol_name = "ll_rw_block";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_ll_rw_block;\r\nbreak;\r\ncase CN_MEM_SWAPOUT:\r\nlkdtm.kp.symbol_name = "shrink_inactive_list";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_shrink_inactive_list;\r\nbreak;\r\ncase CN_TIMERADD:\r\nlkdtm.kp.symbol_name = "hrtimer_start";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_hrtimer_start;\r\nbreak;\r\ncase CN_SCSI_DISPATCH_CMD:\r\nlkdtm.kp.symbol_name = "scsi_dispatch_cmd";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_scsi_dispatch_cmd;\r\nbreak;\r\ncase CN_IDE_CORE_CP:\r\n#ifdef CONFIG_IDE\r\nlkdtm.kp.symbol_name = "generic_ide_ioctl";\r\nlkdtm.entry = (kprobe_opcode_t*) jp_generic_ide_ioctl;\r\n#else\r\nprintk(KERN_INFO "lkdtm: Crash point not available\n");\r\nreturn -EINVAL;\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "lkdtm: Invalid Crash Point\n");\r\nreturn -EINVAL;\r\n}\r\ncpoint = which;\r\nif ((ret = register_jprobe(&lkdtm)) < 0) {\r\nprintk(KERN_INFO "lkdtm: Couldn't register jprobe\n");\r\ncpoint = CN_INVALID;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t do_register_entry(enum cname which, struct file *f,\r\nconst char __user *user_buf, size_t count, loff_t *off)\r\n{\r\nchar *buf;\r\nint err;\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, user_buf, count)) {\r\nfree_page((unsigned long) buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nstrim(buf);\r\ncptype = parse_cp_type(buf, count);\r\nfree_page((unsigned long) buf);\r\nif (cptype == CT_NONE)\r\nreturn -EINVAL;\r\nerr = lkdtm_register_cpoint(which);\r\nif (err < 0)\r\nreturn err;\r\n*off += count;\r\nreturn count;\r\n}\r\nstatic ssize_t lkdtm_debugfs_read(struct file *f, char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nchar *buf;\r\nint i, n, out;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nn = snprintf(buf, PAGE_SIZE, "Available crash types:\n");\r\nfor (i = 0; i < ARRAY_SIZE(cp_type); i++)\r\nn += snprintf(buf + n, PAGE_SIZE - n, "%s\n", cp_type[i]);\r\nbuf[n] = '\0';\r\nout = simple_read_from_buffer(user_buf, count, off,\r\nbuf, n);\r\nfree_page((unsigned long) buf);\r\nreturn out;\r\n}\r\nstatic int lkdtm_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t int_hardware_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_INT_HARDWARE_ENTRY, f, buf, count, off);\r\n}\r\nstatic ssize_t int_hw_irq_en(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_INT_HW_IRQ_EN, f, buf, count, off);\r\n}\r\nstatic ssize_t int_tasklet_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_INT_TASKLET_ENTRY, f, buf, count, off);\r\n}\r\nstatic ssize_t fs_devrw_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_FS_DEVRW, f, buf, count, off);\r\n}\r\nstatic ssize_t mem_swapout_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_MEM_SWAPOUT, f, buf, count, off);\r\n}\r\nstatic ssize_t timeradd_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_TIMERADD, f, buf, count, off);\r\n}\r\nstatic ssize_t scsi_dispatch_cmd_entry(struct file *f,\r\nconst char __user *buf, size_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_SCSI_DISPATCH_CMD, f, buf, count, off);\r\n}\r\nstatic ssize_t ide_core_cp_entry(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nreturn do_register_entry(CN_IDE_CORE_CP, f, buf, count, off);\r\n}\r\nstatic ssize_t direct_entry(struct file *f, const char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nenum ctype type;\r\nchar *buf;\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, user_buf, count)) {\r\nfree_page((unsigned long) buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nstrim(buf);\r\ntype = parse_cp_type(buf, count);\r\nfree_page((unsigned long) buf);\r\nif (type == CT_NONE)\r\nreturn -EINVAL;\r\nprintk(KERN_INFO "lkdtm: Performing direct entry %s\n",\r\ncp_type_to_str(type));\r\nlkdtm_do_action(type);\r\n*off += count;\r\nreturn count;\r\n}\r\nstatic int __init lkdtm_module_init(void)\r\n{\r\nint ret = -EINVAL;\r\nint n_debugfs_entries = 1;\r\nint i;\r\nlkdtm_debugfs_root = debugfs_create_dir("provoke-crash", NULL);\r\nif (!lkdtm_debugfs_root) {\r\nprintk(KERN_ERR "lkdtm: creating root dir failed\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_KPROBES\r\nn_debugfs_entries = ARRAY_SIZE(crash_entries);\r\n#endif\r\nfor (i = 0; i < n_debugfs_entries; i++) {\r\nconst struct crash_entry *cur = &crash_entries[i];\r\nstruct dentry *de;\r\nde = debugfs_create_file(cur->name, 0644, lkdtm_debugfs_root,\r\nNULL, &cur->fops);\r\nif (de == NULL) {\r\nprintk(KERN_ERR "lkdtm: could not create %s\n",\r\ncur->name);\r\ngoto out_err;\r\n}\r\n}\r\nif (lkdtm_parse_commandline() == -EINVAL) {\r\nprintk(KERN_INFO "lkdtm: Invalid command\n");\r\ngoto out_err;\r\n}\r\nif (cpoint != CN_INVALID && cptype != CT_NONE) {\r\nret = lkdtm_register_cpoint(cpoint);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "lkdtm: Invalid crash point %d\n",\r\ncpoint);\r\ngoto out_err;\r\n}\r\nprintk(KERN_INFO "lkdtm: Crash point %s of type %s registered\n",\r\ncpoint_name, cpoint_type);\r\n} else {\r\nprintk(KERN_INFO "lkdtm: No crash points registered, enable through debugfs\n");\r\n}\r\nreturn 0;\r\nout_err:\r\ndebugfs_remove_recursive(lkdtm_debugfs_root);\r\nreturn ret;\r\n}\r\nstatic void __exit lkdtm_module_exit(void)\r\n{\r\ndebugfs_remove_recursive(lkdtm_debugfs_root);\r\nunregister_jprobe(&lkdtm);\r\nprintk(KERN_INFO "lkdtm: Crash point unregistered\n");\r\n}
