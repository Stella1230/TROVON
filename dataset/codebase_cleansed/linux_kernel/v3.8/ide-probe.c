static void generic_id(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nid[ATA_ID_CUR_CYLS] = id[ATA_ID_CYLS] = drive->cyl;\r\nid[ATA_ID_CUR_HEADS] = id[ATA_ID_HEADS] = drive->head;\r\nid[ATA_ID_CUR_SECTORS] = id[ATA_ID_SECTORS] = drive->sect;\r\n}\r\nstatic void ide_disk_init_chs(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nif (!drive->cyl || !drive->head || !drive->sect) {\r\ndrive->cyl = drive->bios_cyl = id[ATA_ID_CYLS];\r\ndrive->head = drive->bios_head = id[ATA_ID_HEADS];\r\ndrive->sect = drive->bios_sect = id[ATA_ID_SECTORS];\r\n}\r\nif (ata_id_current_chs_valid(id)) {\r\ndrive->cyl = id[ATA_ID_CUR_CYLS];\r\ndrive->head = id[ATA_ID_CUR_HEADS];\r\ndrive->sect = id[ATA_ID_CUR_SECTORS];\r\n}\r\nif (drive->head > 16 && id[ATA_ID_HEADS] && id[ATA_ID_HEADS] <= 16) {\r\ndrive->cyl = id[ATA_ID_CYLS];\r\ndrive->head = id[ATA_ID_HEADS];\r\ndrive->sect = id[ATA_ID_SECTORS];\r\n}\r\n}\r\nstatic void ide_disk_init_mult_count(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nu8 max_multsect = id[ATA_ID_MAX_MULTSECT] & 0xff;\r\nif (max_multsect) {\r\nif ((max_multsect / 2) > 1)\r\nid[ATA_ID_MULTSECT] = max_multsect | 0x100;\r\nelse\r\nid[ATA_ID_MULTSECT] &= ~0x1ff;\r\ndrive->mult_req = id[ATA_ID_MULTSECT] & 0xff;\r\nif (drive->mult_req)\r\ndrive->special_flags |= IDE_SFLAG_SET_MULTMODE;\r\n}\r\n}\r\nstatic void ide_classify_ata_dev(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nchar *m = (char *)&id[ATA_ID_PROD];\r\nint is_cfa = ata_id_is_cfa(id);\r\nif (is_cfa == 0 && (id[ATA_ID_CONFIG] & (1 << 7)))\r\ndrive->dev_flags |= IDE_DFLAG_REMOVABLE;\r\ndrive->media = ide_disk;\r\nif (!ata_id_has_unload(drive->id))\r\ndrive->dev_flags |= IDE_DFLAG_NO_UNLOAD;\r\nprintk(KERN_INFO "%s: %s, %s DISK drive\n", drive->name, m,\r\nis_cfa ? "CFA" : "ATA");\r\n}\r\nstatic void ide_classify_atapi_dev(ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nchar *m = (char *)&id[ATA_ID_PROD];\r\nu8 type = (id[ATA_ID_CONFIG] >> 8) & 0x1f;\r\nprintk(KERN_INFO "%s: %s, ATAPI ", drive->name, m);\r\nswitch (type) {\r\ncase ide_floppy:\r\nif (!strstr(m, "CD-ROM")) {\r\nif (!strstr(m, "oppy") &&\r\n!strstr(m, "poyp") &&\r\n!strstr(m, "ZIP"))\r\nprintk(KERN_CONT "cdrom or floppy?, assuming ");\r\nif (drive->media != ide_cdrom) {\r\nprintk(KERN_CONT "FLOPPY");\r\ndrive->dev_flags |= IDE_DFLAG_REMOVABLE;\r\nbreak;\r\n}\r\n}\r\ntype = ide_cdrom;\r\ncase ide_cdrom:\r\ndrive->dev_flags |= IDE_DFLAG_REMOVABLE;\r\n#ifdef CONFIG_PPC\r\nif (!strstr(m, "CD-ROM") && strstr(m, "ZIP")) {\r\nprintk(KERN_CONT "FLOPPY");\r\ntype = ide_floppy;\r\nbreak;\r\n}\r\n#endif\r\nprintk(KERN_CONT "CD/DVD-ROM");\r\nbreak;\r\ncase ide_tape:\r\nprintk(KERN_CONT "TAPE");\r\nbreak;\r\ncase ide_optical:\r\nprintk(KERN_CONT "OPTICAL");\r\ndrive->dev_flags |= IDE_DFLAG_REMOVABLE;\r\nbreak;\r\ndefault:\r\nprintk(KERN_CONT "UNKNOWN (type %d)", type);\r\nbreak;\r\n}\r\nprintk(KERN_CONT " drive\n");\r\ndrive->media = type;\r\ndrive->ready_stat = 0;\r\nif (ata_id_cdb_intr(id))\r\ndrive->atapi_flags |= IDE_AFLAG_DRQ_INTERRUPT;\r\ndrive->dev_flags |= IDE_DFLAG_DOORLOCKING;\r\ndrive->dev_flags |= IDE_DFLAG_NO_UNLOAD;\r\n}\r\nstatic void do_identify(ide_drive_t *drive, u8 cmd, u16 *id)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nchar *m = (char *)&id[ATA_ID_PROD];\r\nunsigned long flags;\r\nint bswap = 1;\r\nlocal_irq_save(flags);\r\nhwif->tp_ops->input_data(drive, NULL, id, SECTOR_SIZE);\r\nlocal_irq_restore(flags);\r\ndrive->dev_flags |= IDE_DFLAG_ID_READ;\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "%s: dumping identify data\n", drive->name);\r\nide_dump_identify((u8 *)id);\r\n#endif\r\nide_fix_driveid(id);\r\nif (cmd == ATA_CMD_ID_ATAPI) {\r\nif ((m[0] == 'N' && m[1] == 'E') ||\r\n(m[0] == 'F' && m[1] == 'X') ||\r\n(m[0] == 'P' && m[1] == 'i'))\r\nbswap ^= 1;\r\n}\r\nide_fixstring(m, ATA_ID_PROD_LEN, bswap);\r\nide_fixstring((char *)&id[ATA_ID_FW_REV], ATA_ID_FW_REV_LEN, bswap);\r\nide_fixstring((char *)&id[ATA_ID_SERNO], ATA_ID_SERNO_LEN, bswap);\r\nm[ATA_ID_PROD_LEN - 1] = '\0';\r\nif (strstr(m, "E X A B Y T E N E S T"))\r\ndrive->dev_flags &= ~IDE_DFLAG_PRESENT;\r\nelse\r\ndrive->dev_flags |= IDE_DFLAG_PRESENT;\r\n}\r\nint ide_dev_read_id(ide_drive_t *drive, u8 cmd, u16 *id, int irq_ctx)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_io_ports *io_ports = &hwif->io_ports;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nint use_altstatus = 0, rc;\r\nunsigned long timeout;\r\nu8 s = 0, a = 0;\r\nif (io_ports->ctl_addr)\r\ntp_ops->write_devctl(hwif, ATA_NIEN | ATA_DEVCTL_OBS);\r\nif (irq_ctx)\r\nmdelay(50);\r\nelse\r\nmsleep(50);\r\nif (io_ports->ctl_addr &&\r\n(hwif->host_flags & IDE_HFLAG_BROKEN_ALTSTATUS) == 0) {\r\na = tp_ops->read_altstatus(hwif);\r\ns = tp_ops->read_status(hwif);\r\nif ((a ^ s) & ~ATA_IDX)\r\nprintk(KERN_INFO "%s: probing with STATUS(0x%02x) "\r\n"instead of ALTSTATUS(0x%02x)\n",\r\ndrive->name, s, a);\r\nelse\r\nuse_altstatus = 1;\r\n}\r\nif (cmd == ATA_CMD_ID_ATAPI) {\r\nstruct ide_taskfile tf;\r\nmemset(&tf, 0, sizeof(tf));\r\ntp_ops->tf_load(drive, &tf, IDE_VALID_FEATURE);\r\n}\r\ntp_ops->exec_command(hwif, cmd);\r\ntimeout = ((cmd == ATA_CMD_ID_ATA) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;\r\nif (irq_ctx) {\r\nrc = __ide_wait_stat(drive, ATA_DRQ, BAD_R_STAT, timeout, &s);\r\nif (rc)\r\nreturn 1;\r\n} else {\r\nrc = ide_busy_sleep(drive, timeout, use_altstatus);\r\nif (rc)\r\nreturn 1;\r\nmsleep(50);\r\ns = tp_ops->read_status(hwif);\r\n}\r\nif (OK_STAT(s, ATA_DRQ, BAD_R_STAT)) {\r\ndo_identify(drive, cmd, id);\r\nrc = 0;\r\n(void)tp_ops->read_status(hwif);\r\n} else {\r\nrc = 2;\r\n}\r\nreturn rc;\r\n}\r\nint ide_busy_sleep(ide_drive_t *drive, unsigned long timeout, int altstatus)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 stat;\r\ntimeout += jiffies;\r\ndo {\r\nmsleep(50);\r\nstat = altstatus ? hwif->tp_ops->read_altstatus(hwif)\r\n: hwif->tp_ops->read_status(hwif);\r\nif ((stat & ATA_BUSY) == 0)\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nprintk(KERN_ERR "%s: timeout in %s\n", drive->name, __func__);\r\nreturn 1;\r\n}\r\nstatic u8 ide_read_device(ide_drive_t *drive)\r\n{\r\nstruct ide_taskfile tf;\r\ndrive->hwif->tp_ops->tf_read(drive, &tf, IDE_VALID_DEVICE);\r\nreturn tf.device;\r\n}\r\nstatic int do_probe (ide_drive_t *drive, u8 cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nu16 *id = drive->id;\r\nint rc;\r\nu8 present = !!(drive->dev_flags & IDE_DFLAG_PRESENT), stat;\r\nif (present && drive->media != ide_disk && cmd == ATA_CMD_ID_ATA)\r\nreturn 4;\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "probing for %s: present=%d, media=%d, probetype=%s\n",\r\ndrive->name, present, drive->media,\r\n(cmd == ATA_CMD_ID_ATA) ? "ATA" : "ATAPI");\r\n#endif\r\nmsleep(50);\r\ntp_ops->dev_select(drive);\r\nmsleep(50);\r\nif (ide_read_device(drive) != drive->select && present == 0) {\r\nif (drive->dn & 1) {\r\ntp_ops->dev_select(hwif->devices[0]);\r\nmsleep(50);\r\n}\r\nreturn 3;\r\n}\r\nstat = tp_ops->read_status(hwif);\r\nif (OK_STAT(stat, ATA_DRDY, ATA_BUSY) ||\r\npresent || cmd == ATA_CMD_ID_ATAPI) {\r\nrc = ide_dev_read_id(drive, cmd, id, 0);\r\nif (rc)\r\nrc = ide_dev_read_id(drive, cmd, id, 0);\r\nstat = tp_ops->read_status(hwif);\r\nif (stat == (ATA_BUSY | ATA_DRDY))\r\nreturn 4;\r\nif (rc == 1 && cmd == ATA_CMD_ID_ATAPI) {\r\nprintk(KERN_ERR "%s: no response (status = 0x%02x), "\r\n"resetting drive\n", drive->name, stat);\r\nmsleep(50);\r\ntp_ops->dev_select(drive);\r\nmsleep(50);\r\ntp_ops->exec_command(hwif, ATA_CMD_DEV_RESET);\r\n(void)ide_busy_sleep(drive, WAIT_WORSTCASE, 0);\r\nrc = ide_dev_read_id(drive, cmd, id, 0);\r\n}\r\nstat = tp_ops->read_status(hwif);\r\nif (rc == 1)\r\nprintk(KERN_ERR "%s: no response (status = 0x%02x)\n",\r\ndrive->name, stat);\r\n} else {\r\nrc = 3;\r\n}\r\nif (drive->dn & 1) {\r\ntp_ops->dev_select(hwif->devices[0]);\r\nmsleep(50);\r\n(void)tp_ops->read_status(hwif);\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 probe_for_drive(ide_drive_t *drive)\r\n{\r\nchar *m;\r\nint rc;\r\nu8 cmd;\r\ndrive->dev_flags &= ~IDE_DFLAG_ID_READ;\r\nm = (char *)&drive->id[ATA_ID_PROD];\r\nstrcpy(m, "UNKNOWN");\r\nif ((drive->dev_flags & IDE_DFLAG_NOPROBE) == 0) {\r\ncmd = ATA_CMD_ID_ATA;\r\nrc = do_probe(drive, cmd);\r\nif (rc >= 2) {\r\ncmd = ATA_CMD_ID_ATAPI;\r\nrc = do_probe(drive, cmd);\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_PRESENT) == 0)\r\nreturn 0;\r\nif ((drive->dev_flags & IDE_DFLAG_ID_READ) == 0) {\r\nif (drive->media == ide_disk) {\r\nprintk(KERN_INFO "%s: non-IDE drive, CHS=%d/%d/%d\n",\r\ndrive->name, drive->cyl,\r\ndrive->head, drive->sect);\r\n} else if (drive->media == ide_cdrom) {\r\nprintk(KERN_INFO "%s: ATAPI cdrom (?)\n", drive->name);\r\n} else {\r\nprintk(KERN_WARNING "%s: Unknown device on bus refused identification. Ignoring.\n", drive->name);\r\ndrive->dev_flags &= ~IDE_DFLAG_PRESENT;\r\n}\r\n} else {\r\nif (cmd == ATA_CMD_ID_ATAPI)\r\nide_classify_atapi_dev(drive);\r\nelse\r\nide_classify_ata_dev(drive);\r\n}\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_PRESENT) == 0)\r\nreturn 0;\r\nif ((drive->dev_flags & IDE_DFLAG_ID_READ) == 0) {\r\ngeneric_id(drive);\r\nreturn 1;\r\n}\r\nif (drive->media == ide_disk) {\r\nide_disk_init_chs(drive);\r\nide_disk_init_mult_count(drive);\r\n}\r\nreturn 1;\r\n}\r\nstatic void hwif_release_dev(struct device *dev)\r\n{\r\nide_hwif_t *hwif = container_of(dev, ide_hwif_t, gendev);\r\ncomplete(&hwif->gendev_rel_comp);\r\n}\r\nstatic int ide_register_port(ide_hwif_t *hwif)\r\n{\r\nint ret;\r\ndev_set_name(&hwif->gendev, hwif->name);\r\ndev_set_drvdata(&hwif->gendev, hwif);\r\nif (hwif->gendev.parent == NULL)\r\nhwif->gendev.parent = hwif->dev;\r\nhwif->gendev.release = hwif_release_dev;\r\nret = device_register(&hwif->gendev);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "IDE: %s: device_register error: %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nhwif->portdev = device_create(ide_port_class, &hwif->gendev,\r\nMKDEV(0, 0), hwif, hwif->name);\r\nif (IS_ERR(hwif->portdev)) {\r\nret = PTR_ERR(hwif->portdev);\r\ndevice_unregister(&hwif->gendev);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ide_port_wait_ready(ide_hwif_t *hwif)\r\n{\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nide_drive_t *drive;\r\nint i, rc;\r\nprintk(KERN_DEBUG "Probing IDE interface %s...\n", hwif->name);\r\nmdelay(2);\r\nrc = ide_wait_not_busy(hwif, 35000);\r\nif (rc)\r\nreturn rc;\r\nide_port_for_each_dev(i, drive, hwif) {\r\nif ((drive->dev_flags & IDE_DFLAG_NOPROBE) == 0 ||\r\n(drive->dev_flags & IDE_DFLAG_PRESENT)) {\r\ntp_ops->dev_select(drive);\r\ntp_ops->write_devctl(hwif, ATA_DEVCTL_OBS);\r\nmdelay(2);\r\nrc = ide_wait_not_busy(hwif, 35000);\r\nif (rc)\r\ngoto out;\r\n} else\r\nprintk(KERN_DEBUG "%s: ide_wait_not_busy() skipped\n",\r\ndrive->name);\r\n}\r\nout:\r\nif (i)\r\ntp_ops->dev_select(hwif->devices[0]);\r\nreturn rc;\r\n}\r\nvoid ide_undecoded_slave(ide_drive_t *dev1)\r\n{\r\nide_drive_t *dev0 = dev1->hwif->devices[0];\r\nif ((dev1->dn & 1) == 0 || (dev0->dev_flags & IDE_DFLAG_PRESENT) == 0)\r\nreturn;\r\nif (strcmp((char *)&dev0->id[ATA_ID_PROD],\r\n(char *)&dev1->id[ATA_ID_PROD]))\r\nreturn;\r\nif (strncmp((char *)&dev0->id[ATA_ID_SERNO],\r\n(char *)&dev1->id[ATA_ID_SERNO], ATA_ID_SERNO_LEN))\r\nreturn;\r\nif (*(char *)&dev0->id[ATA_ID_SERNO] == 0)\r\nreturn;\r\nprintk(KERN_WARNING "ide-probe: ignoring undecoded slave\n");\r\ndev1->dev_flags &= ~IDE_DFLAG_PRESENT;\r\n}\r\nstatic int ide_probe_port(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nunsigned int irqd;\r\nint i, rc = -ENODEV;\r\nBUG_ON(hwif->present);\r\nif ((hwif->devices[0]->dev_flags & IDE_DFLAG_NOPROBE) &&\r\n(hwif->devices[1]->dev_flags & IDE_DFLAG_NOPROBE))\r\nreturn -EACCES;\r\nirqd = hwif->irq;\r\nif (irqd)\r\ndisable_irq(hwif->irq);\r\nif (ide_port_wait_ready(hwif) == -EBUSY)\r\nprintk(KERN_DEBUG "%s: Wait for ready failed before probe !\n", hwif->name);\r\nide_port_for_each_dev(i, drive, hwif) {\r\n(void) probe_for_drive(drive);\r\nif (drive->dev_flags & IDE_DFLAG_PRESENT)\r\nrc = 0;\r\n}\r\nif (irqd)\r\nenable_irq(irqd);\r\nreturn rc;\r\n}\r\nstatic void ide_port_tune_devices(ide_hwif_t *hwif)\r\n{\r\nconst struct ide_port_ops *port_ops = hwif->port_ops;\r\nide_drive_t *drive;\r\nint i;\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nide_check_nien_quirk_list(drive);\r\nif (port_ops && port_ops->quirkproc)\r\nport_ops->quirkproc(drive);\r\n}\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nide_set_max_pio(drive);\r\ndrive->dev_flags |= IDE_DFLAG_NICE1;\r\nif (hwif->dma_ops)\r\nide_set_dma(drive);\r\n}\r\n}\r\nstatic int ide_init_queue(ide_drive_t *drive)\r\n{\r\nstruct request_queue *q;\r\nide_hwif_t *hwif = drive->hwif;\r\nint max_sectors = 256;\r\nint max_sg_entries = PRD_ENTRIES;\r\nq = blk_init_queue_node(do_ide_request, NULL, hwif_to_node(hwif));\r\nif (!q)\r\nreturn 1;\r\nq->queuedata = drive;\r\nblk_queue_segment_boundary(q, 0xffff);\r\nif (hwif->rqsize < max_sectors)\r\nmax_sectors = hwif->rqsize;\r\nblk_queue_max_hw_sectors(q, max_sectors);\r\n#ifdef CONFIG_PCI\r\nif (!PCI_DMA_BUS_IS_PHYS)\r\nmax_sg_entries >>= 1;\r\n#endif\r\nblk_queue_max_segments(q, max_sg_entries);\r\ndrive->queue = q;\r\nide_toggle_bounce(drive, 1);\r\nreturn 0;\r\n}\r\nstatic int ide_port_setup_devices(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nint i, j = 0;\r\nmutex_lock(&ide_cfg_mtx);\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nif (ide_init_queue(drive)) {\r\nprintk(KERN_ERR "ide: failed to init %s\n",\r\ndrive->name);\r\ndrive->dev_flags &= ~IDE_DFLAG_PRESENT;\r\ncontinue;\r\n}\r\nj++;\r\n}\r\nmutex_unlock(&ide_cfg_mtx);\r\nreturn j;\r\n}\r\nstatic void ide_host_enable_irqs(struct ide_host *host)\r\n{\r\nide_hwif_t *hwif;\r\nint i;\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif == NULL)\r\ncontinue;\r\nhwif->tp_ops->read_status(hwif);\r\nif (hwif->io_ports.ctl_addr)\r\nhwif->tp_ops->write_devctl(hwif, ATA_DEVCTL_OBS);\r\n}\r\n}\r\nstatic int init_irq (ide_hwif_t *hwif)\r\n{\r\nstruct ide_io_ports *io_ports = &hwif->io_ports;\r\nstruct ide_host *host = hwif->host;\r\nirq_handler_t irq_handler = host->irq_handler;\r\nint sa = host->irq_flags;\r\nif (irq_handler == NULL)\r\nirq_handler = ide_intr;\r\nif (request_irq(hwif->irq, irq_handler, sa, hwif->name, hwif))\r\ngoto out_up;\r\n#if !defined(__mc68000__)\r\nprintk(KERN_INFO "%s at 0x%03lx-0x%03lx,0x%03lx on irq %d", hwif->name,\r\nio_ports->data_addr, io_ports->status_addr,\r\nio_ports->ctl_addr, hwif->irq);\r\n#else\r\nprintk(KERN_INFO "%s at 0x%08lx on irq %d", hwif->name,\r\nio_ports->data_addr, hwif->irq);\r\n#endif\r\nif (hwif->host->host_flags & IDE_HFLAG_SERIALIZE)\r\nprintk(KERN_CONT " (serialized)");\r\nprintk(KERN_CONT "\n");\r\nreturn 0;\r\nout_up:\r\nreturn 1;\r\n}\r\nstatic int ata_lock(dev_t dev, void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct kobject *ata_probe(dev_t dev, int *part, void *data)\r\n{\r\nide_hwif_t *hwif = data;\r\nint unit = *part >> PARTN_BITS;\r\nide_drive_t *drive = hwif->devices[unit];\r\nif ((drive->dev_flags & IDE_DFLAG_PRESENT) == 0)\r\nreturn NULL;\r\nif (drive->media == ide_disk)\r\nrequest_module("ide-disk");\r\nif (drive->media == ide_cdrom || drive->media == ide_optical)\r\nrequest_module("ide-cd");\r\nif (drive->media == ide_tape)\r\nrequest_module("ide-tape");\r\nif (drive->media == ide_floppy)\r\nrequest_module("ide-floppy");\r\nreturn NULL;\r\n}\r\nstatic struct kobject *exact_match(dev_t dev, int *part, void *data)\r\n{\r\nstruct gendisk *p = data;\r\n*part &= (1 << PARTN_BITS) - 1;\r\nreturn &disk_to_dev(p)->kobj;\r\n}\r\nstatic int exact_lock(dev_t dev, void *data)\r\n{\r\nstruct gendisk *p = data;\r\nif (!get_disk(p))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid ide_register_region(struct gendisk *disk)\r\n{\r\nblk_register_region(MKDEV(disk->major, disk->first_minor),\r\ndisk->minors, NULL, exact_match, exact_lock, disk);\r\n}\r\nvoid ide_unregister_region(struct gendisk *disk)\r\n{\r\nblk_unregister_region(MKDEV(disk->major, disk->first_minor),\r\ndisk->minors);\r\n}\r\nvoid ide_init_disk(struct gendisk *disk, ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned int unit = drive->dn & 1;\r\ndisk->major = hwif->major;\r\ndisk->first_minor = unit << PARTN_BITS;\r\nsprintf(disk->disk_name, "hd%c", 'a' + hwif->index * MAX_DRIVES + unit);\r\ndisk->queue = drive->queue;\r\n}\r\nstatic void drive_release_dev (struct device *dev)\r\n{\r\nide_drive_t *drive = container_of(dev, ide_drive_t, gendev);\r\nide_proc_unregister_device(drive);\r\nblk_cleanup_queue(drive->queue);\r\ndrive->queue = NULL;\r\ndrive->dev_flags &= ~IDE_DFLAG_PRESENT;\r\ncomplete(&drive->gendev_rel_comp);\r\n}\r\nstatic int hwif_init(ide_hwif_t *hwif)\r\n{\r\nif (!hwif->irq) {\r\nprintk(KERN_ERR "%s: disabled, no IRQ\n", hwif->name);\r\nreturn 0;\r\n}\r\nif (register_blkdev(hwif->major, hwif->name))\r\nreturn 0;\r\nif (!hwif->sg_max_nents)\r\nhwif->sg_max_nents = PRD_ENTRIES;\r\nhwif->sg_table = kmalloc(sizeof(struct scatterlist)*hwif->sg_max_nents,\r\nGFP_KERNEL);\r\nif (!hwif->sg_table) {\r\nprintk(KERN_ERR "%s: unable to allocate SG table.\n", hwif->name);\r\ngoto out;\r\n}\r\nsg_init_table(hwif->sg_table, hwif->sg_max_nents);\r\nif (init_irq(hwif)) {\r\nprintk(KERN_ERR "%s: disabled, unable to get IRQ %d\n",\r\nhwif->name, hwif->irq);\r\ngoto out;\r\n}\r\nblk_register_region(MKDEV(hwif->major, 0), MAX_DRIVES << PARTN_BITS,\r\nTHIS_MODULE, ata_probe, ata_lock, hwif);\r\nreturn 1;\r\nout:\r\nunregister_blkdev(hwif->major, hwif->name);\r\nreturn 0;\r\n}\r\nstatic void hwif_register_devices(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nunsigned int i;\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nstruct device *dev = &drive->gendev;\r\nint ret;\r\ndev_set_name(dev, "%u.%u", hwif->index, i);\r\ndev_set_drvdata(dev, drive);\r\ndev->parent = &hwif->gendev;\r\ndev->bus = &ide_bus_type;\r\ndev->release = drive_release_dev;\r\nret = device_register(dev);\r\nif (ret < 0)\r\nprintk(KERN_WARNING "IDE: %s: device_register error: "\r\n"%d\n", __func__, ret);\r\n}\r\n}\r\nstatic void ide_port_init_devices(ide_hwif_t *hwif)\r\n{\r\nconst struct ide_port_ops *port_ops = hwif->port_ops;\r\nide_drive_t *drive;\r\nint i;\r\nide_port_for_each_dev(i, drive, hwif) {\r\ndrive->dn = i + hwif->channel * 2;\r\nif (hwif->host_flags & IDE_HFLAG_IO_32BIT)\r\ndrive->io_32bit = 1;\r\nif (hwif->host_flags & IDE_HFLAG_NO_IO_32BIT)\r\ndrive->dev_flags |= IDE_DFLAG_NO_IO_32BIT;\r\nif (hwif->host_flags & IDE_HFLAG_UNMASK_IRQS)\r\ndrive->dev_flags |= IDE_DFLAG_UNMASK;\r\nif (hwif->host_flags & IDE_HFLAG_NO_UNMASK_IRQS)\r\ndrive->dev_flags |= IDE_DFLAG_NO_UNMASK;\r\ndrive->pio_mode = XFER_PIO_0;\r\nif (port_ops && port_ops->init_dev)\r\nport_ops->init_dev(drive);\r\n}\r\n}\r\nstatic void ide_init_port(ide_hwif_t *hwif, unsigned int port,\r\nconst struct ide_port_info *d)\r\n{\r\nhwif->channel = port;\r\nhwif->chipset = d->chipset ? d->chipset : ide_pci;\r\nif (d->init_iops)\r\nd->init_iops(hwif);\r\nhwif->host_flags |= d->host_flags;\r\nhwif->pio_mask = d->pio_mask;\r\nif (d->tp_ops)\r\nhwif->tp_ops = d->tp_ops;\r\nif ((hwif->host_flags & IDE_HFLAG_DTC2278) == 0 || hwif->channel == 0)\r\nhwif->port_ops = d->port_ops;\r\nhwif->swdma_mask = d->swdma_mask;\r\nhwif->mwdma_mask = d->mwdma_mask;\r\nhwif->ultra_mask = d->udma_mask;\r\nif ((d->host_flags & IDE_HFLAG_NO_DMA) == 0) {\r\nint rc;\r\nhwif->dma_ops = d->dma_ops;\r\nif (d->init_dma)\r\nrc = d->init_dma(hwif, d);\r\nelse\r\nrc = ide_hwif_setup_dma(hwif, d);\r\nif (rc < 0) {\r\nprintk(KERN_INFO "%s: DMA disabled\n", hwif->name);\r\nhwif->dma_ops = NULL;\r\nhwif->dma_base = 0;\r\nhwif->swdma_mask = 0;\r\nhwif->mwdma_mask = 0;\r\nhwif->ultra_mask = 0;\r\n}\r\n}\r\nif ((d->host_flags & IDE_HFLAG_SERIALIZE) ||\r\n((d->host_flags & IDE_HFLAG_SERIALIZE_DMA) && hwif->dma_base))\r\nhwif->host->host_flags |= IDE_HFLAG_SERIALIZE;\r\nif (d->max_sectors)\r\nhwif->rqsize = d->max_sectors;\r\nelse {\r\nif ((hwif->host_flags & IDE_HFLAG_NO_LBA48) ||\r\n(hwif->host_flags & IDE_HFLAG_NO_LBA48_DMA))\r\nhwif->rqsize = 256;\r\nelse\r\nhwif->rqsize = 65536;\r\n}\r\nif (d->init_hwif)\r\nd->init_hwif(hwif);\r\n}\r\nstatic void ide_port_cable_detect(ide_hwif_t *hwif)\r\n{\r\nconst struct ide_port_ops *port_ops = hwif->port_ops;\r\nif (port_ops && port_ops->cable_detect && (hwif->ultra_mask & 0x78)) {\r\nif (hwif->cbl != ATA_CBL_PATA40_SHORT)\r\nhwif->cbl = port_ops->cable_detect(hwif);\r\n}\r\n}\r\nstatic void ide_port_init_devices_data(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nint i;\r\nide_port_for_each_dev(i, drive, hwif) {\r\nu8 j = (hwif->index * MAX_DRIVES) + i;\r\nu16 *saved_id = drive->id;\r\nmemset(drive, 0, sizeof(*drive));\r\nmemset(saved_id, 0, SECTOR_SIZE);\r\ndrive->id = saved_id;\r\ndrive->media = ide_disk;\r\ndrive->select = (i << 4) | ATA_DEVICE_OBS;\r\ndrive->hwif = hwif;\r\ndrive->ready_stat = ATA_DRDY;\r\ndrive->bad_wstat = BAD_W_STAT;\r\ndrive->special_flags = IDE_SFLAG_RECALIBRATE |\r\nIDE_SFLAG_SET_GEOMETRY;\r\ndrive->name[0] = 'h';\r\ndrive->name[1] = 'd';\r\ndrive->name[2] = 'a' + j;\r\ndrive->max_failures = IDE_DEFAULT_MAX_FAILURES;\r\nINIT_LIST_HEAD(&drive->list);\r\ninit_completion(&drive->gendev_rel_comp);\r\n}\r\n}\r\nstatic void ide_init_port_data(ide_hwif_t *hwif, unsigned int index)\r\n{\r\nhwif->index = index;\r\nhwif->major = ide_hwif_to_major[index];\r\nhwif->name[0] = 'i';\r\nhwif->name[1] = 'd';\r\nhwif->name[2] = 'e';\r\nhwif->name[3] = '0' + index;\r\nspin_lock_init(&hwif->lock);\r\ninit_timer(&hwif->timer);\r\nhwif->timer.function = &ide_timer_expiry;\r\nhwif->timer.data = (unsigned long)hwif;\r\ninit_completion(&hwif->gendev_rel_comp);\r\nhwif->tp_ops = &default_tp_ops;\r\nide_port_init_devices_data(hwif);\r\n}\r\nstatic void ide_init_port_hw(ide_hwif_t *hwif, struct ide_hw *hw)\r\n{\r\nmemcpy(&hwif->io_ports, &hw->io_ports, sizeof(hwif->io_ports));\r\nhwif->irq = hw->irq;\r\nhwif->dev = hw->dev;\r\nhwif->gendev.parent = hw->parent ? hw->parent : hw->dev;\r\nhwif->config_data = hw->config;\r\n}\r\nstatic int ide_find_port_slot(const struct ide_port_info *d)\r\n{\r\nint idx = -ENOENT;\r\nu8 bootable = (d && (d->host_flags & IDE_HFLAG_NON_BOOTABLE)) ? 0 : 1;\r\nu8 i = (d && (d->host_flags & IDE_HFLAG_QD_2ND_PORT)) ? 1 : 0;\r\nmutex_lock(&ide_cfg_mtx);\r\nif (bootable) {\r\nif ((ide_indexes | i) != (1 << MAX_HWIFS) - 1)\r\nidx = ffz(ide_indexes | i);\r\n} else {\r\nif ((ide_indexes | 3) != (1 << MAX_HWIFS) - 1)\r\nidx = ffz(ide_indexes | 3);\r\nelse if ((ide_indexes & 3) != 3)\r\nidx = ffz(ide_indexes);\r\n}\r\nif (idx >= 0)\r\nide_indexes |= (1 << idx);\r\nmutex_unlock(&ide_cfg_mtx);\r\nreturn idx;\r\n}\r\nstatic void ide_free_port_slot(int idx)\r\n{\r\nmutex_lock(&ide_cfg_mtx);\r\nide_indexes &= ~(1 << idx);\r\nmutex_unlock(&ide_cfg_mtx);\r\n}\r\nstatic void ide_port_free_devices(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nint i;\r\nide_port_for_each_dev(i, drive, hwif) {\r\nkfree(drive->id);\r\nkfree(drive);\r\n}\r\n}\r\nstatic int ide_port_alloc_devices(ide_hwif_t *hwif, int node)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_DRIVES; i++) {\r\nide_drive_t *drive;\r\ndrive = kzalloc_node(sizeof(*drive), GFP_KERNEL, node);\r\nif (drive == NULL)\r\ngoto out_nomem;\r\ndrive->id = kzalloc_node(SECTOR_SIZE, GFP_KERNEL, node);\r\nif (drive->id == NULL)\r\ngoto out_nomem;\r\nhwif->devices[i] = drive;\r\n}\r\nreturn 0;\r\nout_nomem:\r\nide_port_free_devices(hwif);\r\nreturn -ENOMEM;\r\n}\r\nstruct ide_host *ide_host_alloc(const struct ide_port_info *d,\r\nstruct ide_hw **hws, unsigned int n_ports)\r\n{\r\nstruct ide_host *host;\r\nstruct device *dev = hws[0] ? hws[0]->dev : NULL;\r\nint node = dev ? dev_to_node(dev) : -1;\r\nint i;\r\nhost = kzalloc_node(sizeof(*host), GFP_KERNEL, node);\r\nif (host == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < n_ports; i++) {\r\nide_hwif_t *hwif;\r\nint idx;\r\nif (hws[i] == NULL)\r\ncontinue;\r\nhwif = kzalloc_node(sizeof(*hwif), GFP_KERNEL, node);\r\nif (hwif == NULL)\r\ncontinue;\r\nif (ide_port_alloc_devices(hwif, node) < 0) {\r\nkfree(hwif);\r\ncontinue;\r\n}\r\nidx = ide_find_port_slot(d);\r\nif (idx < 0) {\r\nprintk(KERN_ERR "%s: no free slot for interface\n",\r\nd ? d->name : "ide");\r\nide_port_free_devices(hwif);\r\nkfree(hwif);\r\ncontinue;\r\n}\r\nide_init_port_data(hwif, idx);\r\nhwif->host = host;\r\nhost->ports[i] = hwif;\r\nhost->n_ports++;\r\n}\r\nif (host->n_ports == 0) {\r\nkfree(host);\r\nreturn NULL;\r\n}\r\nhost->dev[0] = dev;\r\nif (d) {\r\nhost->init_chipset = d->init_chipset;\r\nhost->get_lock = d->get_lock;\r\nhost->release_lock = d->release_lock;\r\nhost->host_flags = d->host_flags;\r\nhost->irq_flags = d->irq_flags;\r\n}\r\nreturn host;\r\n}\r\nstatic void ide_port_free(ide_hwif_t *hwif)\r\n{\r\nide_port_free_devices(hwif);\r\nide_free_port_slot(hwif->index);\r\nkfree(hwif);\r\n}\r\nstatic void ide_disable_port(ide_hwif_t *hwif)\r\n{\r\nstruct ide_host *host = hwif->host;\r\nint i;\r\nprintk(KERN_INFO "%s: disabling port\n", hwif->name);\r\nfor (i = 0; i < MAX_HOST_PORTS; i++) {\r\nif (host->ports[i] == hwif) {\r\nhost->ports[i] = NULL;\r\nhost->n_ports--;\r\n}\r\n}\r\nide_port_free(hwif);\r\n}\r\nint ide_host_register(struct ide_host *host, const struct ide_port_info *d,\r\nstruct ide_hw **hws)\r\n{\r\nide_hwif_t *hwif, *mate = NULL;\r\nint i, j = 0;\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif == NULL) {\r\nmate = NULL;\r\ncontinue;\r\n}\r\nide_init_port_hw(hwif, hws[i]);\r\nide_port_apply_params(hwif);\r\nif ((i & 1) && mate) {\r\nhwif->mate = mate;\r\nmate->mate = hwif;\r\n}\r\nmate = (i & 1) ? NULL : hwif;\r\nide_init_port(hwif, i & 1, d);\r\nide_port_cable_detect(hwif);\r\nhwif->port_flags |= IDE_PFLAG_PROBING;\r\nide_port_init_devices(hwif);\r\n}\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif == NULL)\r\ncontinue;\r\nif (ide_probe_port(hwif) == 0)\r\nhwif->present = 1;\r\nhwif->port_flags &= ~IDE_PFLAG_PROBING;\r\nif ((hwif->host_flags & IDE_HFLAG_4DRIVES) == 0 ||\r\nhwif->mate == NULL || hwif->mate->present == 0) {\r\nif (ide_register_port(hwif)) {\r\nide_disable_port(hwif);\r\ncontinue;\r\n}\r\n}\r\nif (hwif->present)\r\nide_port_tune_devices(hwif);\r\n}\r\nide_host_enable_irqs(host);\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif == NULL)\r\ncontinue;\r\nif (hwif_init(hwif) == 0) {\r\nprintk(KERN_INFO "%s: failed to initialize IDE "\r\n"interface\n", hwif->name);\r\ndevice_unregister(&hwif->gendev);\r\nide_disable_port(hwif);\r\ncontinue;\r\n}\r\nif (hwif->present)\r\nif (ide_port_setup_devices(hwif) == 0) {\r\nhwif->present = 0;\r\ncontinue;\r\n}\r\nj++;\r\nide_acpi_init_port(hwif);\r\nif (hwif->present)\r\nide_acpi_port_init_devices(hwif);\r\n}\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif == NULL)\r\ncontinue;\r\nide_sysfs_register_port(hwif);\r\nide_proc_register_port(hwif);\r\nif (hwif->present) {\r\nide_proc_port_register_devices(hwif);\r\nhwif_register_devices(hwif);\r\n}\r\n}\r\nreturn j ? 0 : -1;\r\n}\r\nint ide_host_add(const struct ide_port_info *d, struct ide_hw **hws,\r\nunsigned int n_ports, struct ide_host **hostp)\r\n{\r\nstruct ide_host *host;\r\nint rc;\r\nhost = ide_host_alloc(d, hws, n_ports);\r\nif (host == NULL)\r\nreturn -ENOMEM;\r\nrc = ide_host_register(host, d, hws);\r\nif (rc) {\r\nide_host_free(host);\r\nreturn rc;\r\n}\r\nif (hostp)\r\n*hostp = host;\r\nreturn 0;\r\n}\r\nstatic void __ide_port_unregister_devices(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nint i;\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\ndevice_unregister(&drive->gendev);\r\nwait_for_completion(&drive->gendev_rel_comp);\r\n}\r\n}\r\nvoid ide_port_unregister_devices(ide_hwif_t *hwif)\r\n{\r\nmutex_lock(&ide_cfg_mtx);\r\n__ide_port_unregister_devices(hwif);\r\nhwif->present = 0;\r\nide_port_init_devices_data(hwif);\r\nmutex_unlock(&ide_cfg_mtx);\r\n}\r\nstatic void ide_unregister(ide_hwif_t *hwif)\r\n{\r\nBUG_ON(in_interrupt());\r\nBUG_ON(irqs_disabled());\r\nmutex_lock(&ide_cfg_mtx);\r\nif (hwif->present) {\r\n__ide_port_unregister_devices(hwif);\r\nhwif->present = 0;\r\n}\r\nide_proc_unregister_port(hwif);\r\nfree_irq(hwif->irq, hwif);\r\ndevice_unregister(hwif->portdev);\r\ndevice_unregister(&hwif->gendev);\r\nwait_for_completion(&hwif->gendev_rel_comp);\r\nblk_unregister_region(MKDEV(hwif->major, 0), MAX_DRIVES<<PARTN_BITS);\r\nkfree(hwif->sg_table);\r\nunregister_blkdev(hwif->major, hwif->name);\r\nide_release_dma_engine(hwif);\r\nmutex_unlock(&ide_cfg_mtx);\r\n}\r\nvoid ide_host_free(struct ide_host *host)\r\n{\r\nide_hwif_t *hwif;\r\nint i;\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif)\r\nide_port_free(hwif);\r\n}\r\nkfree(host);\r\n}\r\nvoid ide_host_remove(struct ide_host *host)\r\n{\r\nide_hwif_t *hwif;\r\nint i;\r\nide_host_for_each_port(i, hwif, host) {\r\nif (hwif)\r\nide_unregister(hwif);\r\n}\r\nide_host_free(host);\r\n}\r\nvoid ide_port_scan(ide_hwif_t *hwif)\r\n{\r\nint rc;\r\nide_port_apply_params(hwif);\r\nide_port_cable_detect(hwif);\r\nhwif->port_flags |= IDE_PFLAG_PROBING;\r\nide_port_init_devices(hwif);\r\nrc = ide_probe_port(hwif);\r\nhwif->port_flags &= ~IDE_PFLAG_PROBING;\r\nif (rc < 0)\r\nreturn;\r\nhwif->present = 1;\r\nide_port_tune_devices(hwif);\r\nide_port_setup_devices(hwif);\r\nide_acpi_port_init_devices(hwif);\r\nhwif_register_devices(hwif);\r\nide_proc_port_register_devices(hwif);\r\n}
