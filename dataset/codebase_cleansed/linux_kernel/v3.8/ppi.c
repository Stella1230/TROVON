static irqreturn_t ppi_irq_err(int irq, void *dev_id)\r\n{\r\nstruct ppi_if *ppi = dev_id;\r\nconst struct ppi_info *info = ppi->info;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nunsigned short status;\r\nstatus = bfin_read16(&reg->status);\r\nbfin_write16(&reg->status, 0xff00);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nbfin_write16(&reg->status, 0xffff);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ppi_attach_irq(struct ppi_if *ppi, irq_handler_t handler)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nint ret;\r\nret = request_dma(info->dma_ch, "PPI_DMA");\r\nif (ret) {\r\npr_err("Unable to allocate DMA channel for PPI\n");\r\nreturn ret;\r\n}\r\nset_dma_callback(info->dma_ch, handler, ppi);\r\nif (ppi->err_int) {\r\nret = request_irq(info->irq_err, ppi_irq_err, 0, "PPI ERROR", ppi);\r\nif (ret) {\r\npr_err("Unable to allocate IRQ for PPI\n");\r\nfree_dma(info->dma_ch);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ppi_detach_irq(struct ppi_if *ppi)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nif (ppi->err_int)\r\nfree_irq(info->irq_err, ppi);\r\nfree_dma(info->dma_ch);\r\n}\r\nstatic int ppi_start(struct ppi_if *ppi)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nenable_dma(info->dma_ch);\r\nppi->ppi_control |= PORT_EN;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nbfin_write16(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nbfin_write32(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic int ppi_stop(struct ppi_if *ppi)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nppi->ppi_control &= ~PORT_EN;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nbfin_write16(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nbfin_write32(&reg->control, ppi->ppi_control);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclear_dma_irqstat(info->dma_ch);\r\ndisable_dma(info->dma_ch);\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic int ppi_set_params(struct ppi_if *ppi, struct ppi_params *params)\r\n{\r\nconst struct ppi_info *info = ppi->info;\r\nint dma32 = 0;\r\nint dma_config, bytes_per_line, lines_per_frame;\r\nbytes_per_line = params->width * params->bpp / 8;\r\nlines_per_frame = params->height;\r\nif (params->int_mask == 0xFFFFFFFF)\r\nppi->err_int = false;\r\nelse\r\nppi->err_int = true;\r\ndma_config = (DMA_FLOW_STOP | WNR | RESTART | DMA2D | DI_EN);\r\nppi->ppi_control = params->ppi_control & ~PORT_EN;\r\nswitch (info->type) {\r\ncase PPI_TYPE_PPI:\r\n{\r\nstruct bfin_ppi_regs *reg = info->base;\r\nif (params->ppi_control & DMA32)\r\ndma32 = 1;\r\nbfin_write16(&reg->control, ppi->ppi_control);\r\nbfin_write16(&reg->count, bytes_per_line - 1);\r\nbfin_write16(&reg->frame, lines_per_frame);\r\nbreak;\r\n}\r\ncase PPI_TYPE_EPPI:\r\n{\r\nstruct bfin_eppi_regs *reg = info->base;\r\nif ((params->ppi_control & PACK_EN)\r\n|| (params->ppi_control & 0x38000) > DLEN_16)\r\ndma32 = 1;\r\nbfin_write32(&reg->control, ppi->ppi_control);\r\nbfin_write16(&reg->line, bytes_per_line + params->blank_clocks);\r\nbfin_write16(&reg->frame, lines_per_frame);\r\nbfin_write16(&reg->hdelay, 0);\r\nbfin_write16(&reg->vdelay, 0);\r\nbfin_write16(&reg->hcount, bytes_per_line);\r\nbfin_write16(&reg->vcount, lines_per_frame);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dma32) {\r\ndma_config |= WDSIZE_32;\r\nset_dma_x_count(info->dma_ch, bytes_per_line >> 2);\r\nset_dma_x_modify(info->dma_ch, 4);\r\nset_dma_y_modify(info->dma_ch, 4);\r\n} else {\r\ndma_config |= WDSIZE_16;\r\nset_dma_x_count(info->dma_ch, bytes_per_line >> 1);\r\nset_dma_x_modify(info->dma_ch, 2);\r\nset_dma_y_modify(info->dma_ch, 2);\r\n}\r\nset_dma_y_count(info->dma_ch, lines_per_frame);\r\nset_dma_config(info->dma_ch, dma_config);\r\nSSYNC();\r\nreturn 0;\r\n}\r\nstatic void ppi_update_addr(struct ppi_if *ppi, unsigned long addr)\r\n{\r\nset_dma_start_addr(ppi->info->dma_ch, addr);\r\n}\r\nstruct ppi_if *ppi_create_instance(const struct ppi_info *info)\r\n{\r\nstruct ppi_if *ppi;\r\nif (!info || !info->pin_req)\r\nreturn NULL;\r\nif (peripheral_request_list(info->pin_req, KBUILD_MODNAME)) {\r\npr_err("request peripheral failed\n");\r\nreturn NULL;\r\n}\r\nppi = kzalloc(sizeof(*ppi), GFP_KERNEL);\r\nif (!ppi) {\r\nperipheral_free_list(info->pin_req);\r\npr_err("unable to allocate memory for ppi handle\n");\r\nreturn NULL;\r\n}\r\nppi->ops = &ppi_ops;\r\nppi->info = info;\r\npr_info("ppi probe success\n");\r\nreturn ppi;\r\n}\r\nvoid ppi_delete_instance(struct ppi_if *ppi)\r\n{\r\nperipheral_free_list(ppi->info->pin_req);\r\nkfree(ppi);\r\n}
