static void mem_disp(u8 *addr, int size)\r\n{\r\nu8 *i;\r\nint size16Aling = (size >> 4) << 4;\r\nint size4Aling = (size >> 2) << 2;\r\nint notAlign = 0;\r\nif (size % 16)\r\nnotAlign = 1;\r\nfor (i = addr; (u32) i < (u32) addr + size16Aling; i += 16)\r\nprintk("0x%08x: %08x %08x %08x %08x\r\n",\r\n(u32) i,\r\n*((u32 *) (i)),\r\n*((u32 *) (i + 4)),\r\n*((u32 *) (i + 8)), *((u32 *) (i + 12)));\r\nif (notAlign == 1)\r\nprintk("0x%08x: ", (u32) i);\r\nfor (; (u32) i < (u32) addr + size4Aling; i += 4)\r\nprintk("%08x ", *((u32 *) (i)));\r\nfor (; (u32) i < (u32) addr + size; i++)\r\nprintk("%02x", *((i)));\r\nif (notAlign == 1)\r\nprintk("\r\n");\r\n}\r\nstatic struct list_head *dequeue(struct list_head *lh)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ugeth_lock, flags);\r\nif (!list_empty(lh)) {\r\nstruct list_head *node = lh->next;\r\nlist_del(node);\r\nspin_unlock_irqrestore(&ugeth_lock, flags);\r\nreturn node;\r\n} else {\r\nspin_unlock_irqrestore(&ugeth_lock, flags);\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct sk_buff *get_new_skb(struct ucc_geth_private *ugeth,\r\nu8 __iomem *bd)\r\n{\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(ugeth->ndev,\r\nugeth->ug_info->uf_info.max_rx_buf_length +\r\nUCC_GETH_RX_DATA_BUF_ALIGNMENT);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb,\r\nUCC_GETH_RX_DATA_BUF_ALIGNMENT -\r\n(((unsigned)skb->data) & (UCC_GETH_RX_DATA_BUF_ALIGNMENT -\r\n1)));\r\nout_be32(&((struct qe_bd __iomem *)bd)->buf,\r\ndma_map_single(ugeth->dev,\r\nskb->data,\r\nugeth->ug_info->uf_info.max_rx_buf_length +\r\nUCC_GETH_RX_DATA_BUF_ALIGNMENT,\r\nDMA_FROM_DEVICE));\r\nout_be32((u32 __iomem *)bd,\r\n(R_E | R_I | (in_be32((u32 __iomem*)bd) & R_W)));\r\nreturn skb;\r\n}\r\nstatic int rx_bd_buffer_set(struct ucc_geth_private *ugeth, u8 rxQ)\r\n{\r\nu8 __iomem *bd;\r\nu32 bd_status;\r\nstruct sk_buff *skb;\r\nint i;\r\nbd = ugeth->p_rx_bd_ring[rxQ];\r\ni = 0;\r\ndo {\r\nbd_status = in_be32((u32 __iomem *)bd);\r\nskb = get_new_skb(ugeth, bd);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nugeth->rx_skbuff[rxQ][i] = skb;\r\nbd += sizeof(struct qe_bd);\r\ni++;\r\n} while (!(bd_status & R_W));\r\nreturn 0;\r\n}\r\nstatic int fill_init_enet_entries(struct ucc_geth_private *ugeth,\r\nu32 *p_start,\r\nu8 num_entries,\r\nu32 thread_size,\r\nu32 thread_alignment,\r\nunsigned int risc,\r\nint skip_page_for_first_entry)\r\n{\r\nu32 init_enet_offset;\r\nu8 i;\r\nint snum;\r\nfor (i = 0; i < num_entries; i++) {\r\nif ((snum = qe_get_snum()) < 0) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("fill_init_enet_entries: Can not get SNUM.");\r\nreturn snum;\r\n}\r\nif ((i == 0) && skip_page_for_first_entry)\r\ninit_enet_offset = 0;\r\nelse {\r\ninit_enet_offset =\r\nqe_muram_alloc(thread_size, thread_alignment);\r\nif (IS_ERR_VALUE(init_enet_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("fill_init_enet_entries: Can not allocate DPRAM memory.");\r\nqe_put_snum((u8) snum);\r\nreturn -ENOMEM;\r\n}\r\n}\r\n*(p_start++) =\r\n((u8) snum << ENET_INIT_PARAM_SNUM_SHIFT) | init_enet_offset\r\n| risc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int return_init_enet_entries(struct ucc_geth_private *ugeth,\r\nu32 *p_start,\r\nu8 num_entries,\r\nunsigned int risc,\r\nint skip_page_for_first_entry)\r\n{\r\nu32 init_enet_offset;\r\nu8 i;\r\nint snum;\r\nfor (i = 0; i < num_entries; i++) {\r\nu32 val = *p_start;\r\nif ((val & ENET_INIT_PARAM_RISC_MASK) == risc) {\r\nsnum =\r\n(u32) (val & ENET_INIT_PARAM_SNUM_MASK) >>\r\nENET_INIT_PARAM_SNUM_SHIFT;\r\nqe_put_snum((u8) snum);\r\nif (!((i == 0) && skip_page_for_first_entry)) {\r\ninit_enet_offset =\r\n(val & ENET_INIT_PARAM_PTR_MASK);\r\nqe_muram_free(init_enet_offset);\r\n}\r\n*p_start++ = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dump_init_enet_entries(struct ucc_geth_private *ugeth,\r\nu32 __iomem *p_start,\r\nu8 num_entries,\r\nu32 thread_size,\r\nunsigned int risc,\r\nint skip_page_for_first_entry)\r\n{\r\nu32 init_enet_offset;\r\nu8 i;\r\nint snum;\r\nfor (i = 0; i < num_entries; i++) {\r\nu32 val = in_be32(p_start);\r\nif ((val & ENET_INIT_PARAM_RISC_MASK) == risc) {\r\nsnum =\r\n(u32) (val & ENET_INIT_PARAM_SNUM_MASK) >>\r\nENET_INIT_PARAM_SNUM_SHIFT;\r\nqe_put_snum((u8) snum);\r\nif (!((i == 0) && skip_page_for_first_entry)) {\r\ninit_enet_offset =\r\n(in_be32(p_start) &\r\nENET_INIT_PARAM_PTR_MASK);\r\nugeth_info("Init enet entry %d:", i);\r\nugeth_info("Base address: 0x%08x",\r\n(u32)\r\nqe_muram_addr(init_enet_offset));\r\nmem_disp(qe_muram_addr(init_enet_offset),\r\nthread_size);\r\n}\r\np_start++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void put_enet_addr_container(struct enet_addr_container *enet_addr_cont)\r\n{\r\nkfree(enet_addr_cont);\r\n}\r\nstatic void set_mac_addr(__be16 __iomem *reg, u8 *mac)\r\n{\r\nout_be16(&reg[0], ((u16)mac[5] << 8) | mac[4]);\r\nout_be16(&reg[1], ((u16)mac[3] << 8) | mac[2]);\r\nout_be16(&reg[2], ((u16)mac[1] << 8) | mac[0]);\r\n}\r\nstatic int hw_clear_addr_in_paddr(struct ucc_geth_private *ugeth, u8 paddr_num)\r\n{\r\nstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\r\nif (!(paddr_num < NUM_OF_PADDRS)) {\r\nugeth_warn("%s: Illagel paddr_num.", __func__);\r\nreturn -EINVAL;\r\n}\r\np_82xx_addr_filt =\r\n(struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->p_rx_glbl_pram->\r\naddressfiltering;\r\nout_be16(&p_82xx_addr_filt->paddr[paddr_num].h, 0xffff);\r\nout_be16(&p_82xx_addr_filt->paddr[paddr_num].m, 0xffff);\r\nout_be16(&p_82xx_addr_filt->paddr[paddr_num].l, 0xffff);\r\nreturn 0;\r\n}\r\nstatic void hw_add_addr_in_hash(struct ucc_geth_private *ugeth,\r\nu8 *p_enet_addr)\r\n{\r\nstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\r\nu32 cecr_subblock;\r\np_82xx_addr_filt =\r\n(struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->p_rx_glbl_pram->\r\naddressfiltering;\r\ncecr_subblock =\r\nucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\r\nset_mac_addr(&p_82xx_addr_filt->taddr.h, p_enet_addr);\r\nqe_issue_cmd(QE_SET_GROUP_ADDRESS, cecr_subblock,\r\nQE_CR_PROTOCOL_ETHERNET, 0);\r\n}\r\nstatic inline int compare_addr(u8 **addr1, u8 **addr2)\r\n{\r\nreturn memcmp(addr1, addr2, ETH_ALEN);\r\n}\r\nstatic void get_statistics(struct ucc_geth_private *ugeth,\r\nstruct ucc_geth_tx_firmware_statistics *\r\ntx_firmware_statistics,\r\nstruct ucc_geth_rx_firmware_statistics *\r\nrx_firmware_statistics,\r\nstruct ucc_geth_hardware_statistics *hardware_statistics)\r\n{\r\nstruct ucc_fast __iomem *uf_regs;\r\nstruct ucc_geth __iomem *ug_regs;\r\nstruct ucc_geth_tx_firmware_statistics_pram *p_tx_fw_statistics_pram;\r\nstruct ucc_geth_rx_firmware_statistics_pram *p_rx_fw_statistics_pram;\r\nug_regs = ugeth->ug_regs;\r\nuf_regs = (struct ucc_fast __iomem *) ug_regs;\r\np_tx_fw_statistics_pram = ugeth->p_tx_fw_statistics_pram;\r\np_rx_fw_statistics_pram = ugeth->p_rx_fw_statistics_pram;\r\nif (tx_firmware_statistics && p_tx_fw_statistics_pram) {\r\ntx_firmware_statistics->sicoltx =\r\nin_be32(&p_tx_fw_statistics_pram->sicoltx);\r\ntx_firmware_statistics->mulcoltx =\r\nin_be32(&p_tx_fw_statistics_pram->mulcoltx);\r\ntx_firmware_statistics->latecoltxfr =\r\nin_be32(&p_tx_fw_statistics_pram->latecoltxfr);\r\ntx_firmware_statistics->frabortduecol =\r\nin_be32(&p_tx_fw_statistics_pram->frabortduecol);\r\ntx_firmware_statistics->frlostinmactxer =\r\nin_be32(&p_tx_fw_statistics_pram->frlostinmactxer);\r\ntx_firmware_statistics->carriersenseertx =\r\nin_be32(&p_tx_fw_statistics_pram->carriersenseertx);\r\ntx_firmware_statistics->frtxok =\r\nin_be32(&p_tx_fw_statistics_pram->frtxok);\r\ntx_firmware_statistics->txfrexcessivedefer =\r\nin_be32(&p_tx_fw_statistics_pram->txfrexcessivedefer);\r\ntx_firmware_statistics->txpkts256 =\r\nin_be32(&p_tx_fw_statistics_pram->txpkts256);\r\ntx_firmware_statistics->txpkts512 =\r\nin_be32(&p_tx_fw_statistics_pram->txpkts512);\r\ntx_firmware_statistics->txpkts1024 =\r\nin_be32(&p_tx_fw_statistics_pram->txpkts1024);\r\ntx_firmware_statistics->txpktsjumbo =\r\nin_be32(&p_tx_fw_statistics_pram->txpktsjumbo);\r\n}\r\nif (rx_firmware_statistics && p_rx_fw_statistics_pram) {\r\nint i;\r\nrx_firmware_statistics->frrxfcser =\r\nin_be32(&p_rx_fw_statistics_pram->frrxfcser);\r\nrx_firmware_statistics->fraligner =\r\nin_be32(&p_rx_fw_statistics_pram->fraligner);\r\nrx_firmware_statistics->inrangelenrxer =\r\nin_be32(&p_rx_fw_statistics_pram->inrangelenrxer);\r\nrx_firmware_statistics->outrangelenrxer =\r\nin_be32(&p_rx_fw_statistics_pram->outrangelenrxer);\r\nrx_firmware_statistics->frtoolong =\r\nin_be32(&p_rx_fw_statistics_pram->frtoolong);\r\nrx_firmware_statistics->runt =\r\nin_be32(&p_rx_fw_statistics_pram->runt);\r\nrx_firmware_statistics->verylongevent =\r\nin_be32(&p_rx_fw_statistics_pram->verylongevent);\r\nrx_firmware_statistics->symbolerror =\r\nin_be32(&p_rx_fw_statistics_pram->symbolerror);\r\nrx_firmware_statistics->dropbsy =\r\nin_be32(&p_rx_fw_statistics_pram->dropbsy);\r\nfor (i = 0; i < 0x8; i++)\r\nrx_firmware_statistics->res0[i] =\r\np_rx_fw_statistics_pram->res0[i];\r\nrx_firmware_statistics->mismatchdrop =\r\nin_be32(&p_rx_fw_statistics_pram->mismatchdrop);\r\nrx_firmware_statistics->underpkts =\r\nin_be32(&p_rx_fw_statistics_pram->underpkts);\r\nrx_firmware_statistics->pkts256 =\r\nin_be32(&p_rx_fw_statistics_pram->pkts256);\r\nrx_firmware_statistics->pkts512 =\r\nin_be32(&p_rx_fw_statistics_pram->pkts512);\r\nrx_firmware_statistics->pkts1024 =\r\nin_be32(&p_rx_fw_statistics_pram->pkts1024);\r\nrx_firmware_statistics->pktsjumbo =\r\nin_be32(&p_rx_fw_statistics_pram->pktsjumbo);\r\nrx_firmware_statistics->frlossinmacer =\r\nin_be32(&p_rx_fw_statistics_pram->frlossinmacer);\r\nrx_firmware_statistics->pausefr =\r\nin_be32(&p_rx_fw_statistics_pram->pausefr);\r\nfor (i = 0; i < 0x4; i++)\r\nrx_firmware_statistics->res1[i] =\r\np_rx_fw_statistics_pram->res1[i];\r\nrx_firmware_statistics->removevlan =\r\nin_be32(&p_rx_fw_statistics_pram->removevlan);\r\nrx_firmware_statistics->replacevlan =\r\nin_be32(&p_rx_fw_statistics_pram->replacevlan);\r\nrx_firmware_statistics->insertvlan =\r\nin_be32(&p_rx_fw_statistics_pram->insertvlan);\r\n}\r\nif (hardware_statistics &&\r\n(in_be32(&uf_regs->upsmr) & UCC_GETH_UPSMR_HSE)) {\r\nhardware_statistics->tx64 = in_be32(&ug_regs->tx64);\r\nhardware_statistics->tx127 = in_be32(&ug_regs->tx127);\r\nhardware_statistics->tx255 = in_be32(&ug_regs->tx255);\r\nhardware_statistics->rx64 = in_be32(&ug_regs->rx64);\r\nhardware_statistics->rx127 = in_be32(&ug_regs->rx127);\r\nhardware_statistics->rx255 = in_be32(&ug_regs->rx255);\r\nhardware_statistics->txok = in_be32(&ug_regs->txok);\r\nhardware_statistics->txcf = in_be16(&ug_regs->txcf);\r\nhardware_statistics->tmca = in_be32(&ug_regs->tmca);\r\nhardware_statistics->tbca = in_be32(&ug_regs->tbca);\r\nhardware_statistics->rxfok = in_be32(&ug_regs->rxfok);\r\nhardware_statistics->rxbok = in_be32(&ug_regs->rxbok);\r\nhardware_statistics->rbyt = in_be32(&ug_regs->rbyt);\r\nhardware_statistics->rmca = in_be32(&ug_regs->rmca);\r\nhardware_statistics->rbca = in_be32(&ug_regs->rbca);\r\n}\r\n}\r\nstatic void dump_bds(struct ucc_geth_private *ugeth)\r\n{\r\nint i;\r\nint length;\r\nfor (i = 0; i < ugeth->ug_info->numQueuesTx; i++) {\r\nif (ugeth->p_tx_bd_ring[i]) {\r\nlength =\r\n(ugeth->ug_info->bdRingLenTx[i] *\r\nsizeof(struct qe_bd));\r\nugeth_info("TX BDs[%d]", i);\r\nmem_disp(ugeth->p_tx_bd_ring[i], length);\r\n}\r\n}\r\nfor (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {\r\nif (ugeth->p_rx_bd_ring[i]) {\r\nlength =\r\n(ugeth->ug_info->bdRingLenRx[i] *\r\nsizeof(struct qe_bd));\r\nugeth_info("RX BDs[%d]", i);\r\nmem_disp(ugeth->p_rx_bd_ring[i], length);\r\n}\r\n}\r\n}\r\nstatic void dump_regs(struct ucc_geth_private *ugeth)\r\n{\r\nint i;\r\nugeth_info("UCC%d Geth registers:", ugeth->ug_info->uf_info.ucc_num + 1);\r\nugeth_info("Base address: 0x%08x", (u32) ugeth->ug_regs);\r\nugeth_info("maccfg1 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->maccfg1,\r\nin_be32(&ugeth->ug_regs->maccfg1));\r\nugeth_info("maccfg2 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->maccfg2,\r\nin_be32(&ugeth->ug_regs->maccfg2));\r\nugeth_info("ipgifg : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->ipgifg,\r\nin_be32(&ugeth->ug_regs->ipgifg));\r\nugeth_info("hafdup : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->hafdup,\r\nin_be32(&ugeth->ug_regs->hafdup));\r\nugeth_info("ifctl : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->ifctl,\r\nin_be32(&ugeth->ug_regs->ifctl));\r\nugeth_info("ifstat : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->ifstat,\r\nin_be32(&ugeth->ug_regs->ifstat));\r\nugeth_info("macstnaddr1: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->macstnaddr1,\r\nin_be32(&ugeth->ug_regs->macstnaddr1));\r\nugeth_info("macstnaddr2: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->macstnaddr2,\r\nin_be32(&ugeth->ug_regs->macstnaddr2));\r\nugeth_info("uempr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->uempr,\r\nin_be32(&ugeth->ug_regs->uempr));\r\nugeth_info("utbipar : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->utbipar,\r\nin_be32(&ugeth->ug_regs->utbipar));\r\nugeth_info("uescr : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->ug_regs->uescr,\r\nin_be16(&ugeth->ug_regs->uescr));\r\nugeth_info("tx64 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->tx64,\r\nin_be32(&ugeth->ug_regs->tx64));\r\nugeth_info("tx127 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->tx127,\r\nin_be32(&ugeth->ug_regs->tx127));\r\nugeth_info("tx255 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->tx255,\r\nin_be32(&ugeth->ug_regs->tx255));\r\nugeth_info("rx64 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rx64,\r\nin_be32(&ugeth->ug_regs->rx64));\r\nugeth_info("rx127 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rx127,\r\nin_be32(&ugeth->ug_regs->rx127));\r\nugeth_info("rx255 : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rx255,\r\nin_be32(&ugeth->ug_regs->rx255));\r\nugeth_info("txok : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->txok,\r\nin_be32(&ugeth->ug_regs->txok));\r\nugeth_info("txcf : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->ug_regs->txcf,\r\nin_be16(&ugeth->ug_regs->txcf));\r\nugeth_info("tmca : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->tmca,\r\nin_be32(&ugeth->ug_regs->tmca));\r\nugeth_info("tbca : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->tbca,\r\nin_be32(&ugeth->ug_regs->tbca));\r\nugeth_info("rxfok : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rxfok,\r\nin_be32(&ugeth->ug_regs->rxfok));\r\nugeth_info("rxbok : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rxbok,\r\nin_be32(&ugeth->ug_regs->rxbok));\r\nugeth_info("rbyt : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rbyt,\r\nin_be32(&ugeth->ug_regs->rbyt));\r\nugeth_info("rmca : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rmca,\r\nin_be32(&ugeth->ug_regs->rmca));\r\nugeth_info("rbca : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->rbca,\r\nin_be32(&ugeth->ug_regs->rbca));\r\nugeth_info("scar : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->scar,\r\nin_be32(&ugeth->ug_regs->scar));\r\nugeth_info("scam : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->ug_regs->scam,\r\nin_be32(&ugeth->ug_regs->scam));\r\nif (ugeth->p_thread_data_tx) {\r\nint numThreadsTxNumerical;\r\nswitch (ugeth->ug_info->numThreadsTx) {\r\ncase UCC_GETH_NUM_OF_THREADS_1:\r\nnumThreadsTxNumerical = 1;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_2:\r\nnumThreadsTxNumerical = 2;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_4:\r\nnumThreadsTxNumerical = 4;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_6:\r\nnumThreadsTxNumerical = 6;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_8:\r\nnumThreadsTxNumerical = 8;\r\nbreak;\r\ndefault:\r\nnumThreadsTxNumerical = 0;\r\nbreak;\r\n}\r\nugeth_info("Thread data TXs:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_thread_data_tx);\r\nfor (i = 0; i < numThreadsTxNumerical; i++) {\r\nugeth_info("Thread data TX[%d]:", i);\r\nugeth_info("Base address: 0x%08x",\r\n(u32) & ugeth->p_thread_data_tx[i]);\r\nmem_disp((u8 *) & ugeth->p_thread_data_tx[i],\r\nsizeof(struct ucc_geth_thread_data_tx));\r\n}\r\n}\r\nif (ugeth->p_thread_data_rx) {\r\nint numThreadsRxNumerical;\r\nswitch (ugeth->ug_info->numThreadsRx) {\r\ncase UCC_GETH_NUM_OF_THREADS_1:\r\nnumThreadsRxNumerical = 1;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_2:\r\nnumThreadsRxNumerical = 2;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_4:\r\nnumThreadsRxNumerical = 4;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_6:\r\nnumThreadsRxNumerical = 6;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_8:\r\nnumThreadsRxNumerical = 8;\r\nbreak;\r\ndefault:\r\nnumThreadsRxNumerical = 0;\r\nbreak;\r\n}\r\nugeth_info("Thread data RX:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_thread_data_rx);\r\nfor (i = 0; i < numThreadsRxNumerical; i++) {\r\nugeth_info("Thread data RX[%d]:", i);\r\nugeth_info("Base address: 0x%08x",\r\n(u32) & ugeth->p_thread_data_rx[i]);\r\nmem_disp((u8 *) & ugeth->p_thread_data_rx[i],\r\nsizeof(struct ucc_geth_thread_data_rx));\r\n}\r\n}\r\nif (ugeth->p_exf_glbl_param) {\r\nugeth_info("EXF global param:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_exf_glbl_param);\r\nmem_disp((u8 *) ugeth->p_exf_glbl_param,\r\nsizeof(*ugeth->p_exf_glbl_param));\r\n}\r\nif (ugeth->p_tx_glbl_pram) {\r\nugeth_info("TX global param:");\r\nugeth_info("Base address: 0x%08x", (u32) ugeth->p_tx_glbl_pram);\r\nugeth_info("temoder : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_tx_glbl_pram->temoder,\r\nin_be16(&ugeth->p_tx_glbl_pram->temoder));\r\nugeth_info("sqptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->sqptr,\r\nin_be32(&ugeth->p_tx_glbl_pram->sqptr));\r\nugeth_info("schedulerbasepointer: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->schedulerbasepointer,\r\nin_be32(&ugeth->p_tx_glbl_pram->\r\nschedulerbasepointer));\r\nugeth_info("txrmonbaseptr: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->txrmonbaseptr,\r\nin_be32(&ugeth->p_tx_glbl_pram->txrmonbaseptr));\r\nugeth_info("tstate : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->tstate,\r\nin_be32(&ugeth->p_tx_glbl_pram->tstate));\r\nugeth_info("iphoffset[0] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[0],\r\nugeth->p_tx_glbl_pram->iphoffset[0]);\r\nugeth_info("iphoffset[1] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[1],\r\nugeth->p_tx_glbl_pram->iphoffset[1]);\r\nugeth_info("iphoffset[2] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[2],\r\nugeth->p_tx_glbl_pram->iphoffset[2]);\r\nugeth_info("iphoffset[3] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[3],\r\nugeth->p_tx_glbl_pram->iphoffset[3]);\r\nugeth_info("iphoffset[4] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[4],\r\nugeth->p_tx_glbl_pram->iphoffset[4]);\r\nugeth_info("iphoffset[5] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[5],\r\nugeth->p_tx_glbl_pram->iphoffset[5]);\r\nugeth_info("iphoffset[6] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[6],\r\nugeth->p_tx_glbl_pram->iphoffset[6]);\r\nugeth_info("iphoffset[7] : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_tx_glbl_pram->iphoffset[7],\r\nugeth->p_tx_glbl_pram->iphoffset[7]);\r\nugeth_info("vtagtable[0] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[0],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[0]));\r\nugeth_info("vtagtable[1] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[1],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[1]));\r\nugeth_info("vtagtable[2] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[2],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[2]));\r\nugeth_info("vtagtable[3] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[3],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[3]));\r\nugeth_info("vtagtable[4] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[4],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[4]));\r\nugeth_info("vtagtable[5] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[5],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[5]));\r\nugeth_info("vtagtable[6] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[6],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[6]));\r\nugeth_info("vtagtable[7] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->vtagtable[7],\r\nin_be32(&ugeth->p_tx_glbl_pram->vtagtable[7]));\r\nugeth_info("tqptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_tx_glbl_pram->tqptr,\r\nin_be32(&ugeth->p_tx_glbl_pram->tqptr));\r\n}\r\nif (ugeth->p_rx_glbl_pram) {\r\nugeth_info("RX global param:");\r\nugeth_info("Base address: 0x%08x", (u32) ugeth->p_rx_glbl_pram);\r\nugeth_info("remoder : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->remoder,\r\nin_be32(&ugeth->p_rx_glbl_pram->remoder));\r\nugeth_info("rqptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->rqptr,\r\nin_be32(&ugeth->p_rx_glbl_pram->rqptr));\r\nugeth_info("typeorlen : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->typeorlen,\r\nin_be16(&ugeth->p_rx_glbl_pram->typeorlen));\r\nugeth_info("rxgstpack : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_rx_glbl_pram->rxgstpack,\r\nugeth->p_rx_glbl_pram->rxgstpack);\r\nugeth_info("rxrmonbaseptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->rxrmonbaseptr,\r\nin_be32(&ugeth->p_rx_glbl_pram->rxrmonbaseptr));\r\nugeth_info("intcoalescingptr: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->intcoalescingptr,\r\nin_be32(&ugeth->p_rx_glbl_pram->intcoalescingptr));\r\nugeth_info("rstate : addr - 0x%08x, val - 0x%02x",\r\n(u32) & ugeth->p_rx_glbl_pram->rstate,\r\nugeth->p_rx_glbl_pram->rstate);\r\nugeth_info("mrblr : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->mrblr,\r\nin_be16(&ugeth->p_rx_glbl_pram->mrblr));\r\nugeth_info("rbdqptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->rbdqptr,\r\nin_be32(&ugeth->p_rx_glbl_pram->rbdqptr));\r\nugeth_info("mflr : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->mflr,\r\nin_be16(&ugeth->p_rx_glbl_pram->mflr));\r\nugeth_info("minflr : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->minflr,\r\nin_be16(&ugeth->p_rx_glbl_pram->minflr));\r\nugeth_info("maxd1 : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->maxd1,\r\nin_be16(&ugeth->p_rx_glbl_pram->maxd1));\r\nugeth_info("maxd2 : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->maxd2,\r\nin_be16(&ugeth->p_rx_glbl_pram->maxd2));\r\nugeth_info("ecamptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->ecamptr,\r\nin_be32(&ugeth->p_rx_glbl_pram->ecamptr));\r\nugeth_info("l2qt : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l2qt,\r\nin_be32(&ugeth->p_rx_glbl_pram->l2qt));\r\nugeth_info("l3qt[0] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[0],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[0]));\r\nugeth_info("l3qt[1] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[1],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[1]));\r\nugeth_info("l3qt[2] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[2],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[2]));\r\nugeth_info("l3qt[3] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[3],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[3]));\r\nugeth_info("l3qt[4] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[4],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[4]));\r\nugeth_info("l3qt[5] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[5],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[5]));\r\nugeth_info("l3qt[6] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[6],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[6]));\r\nugeth_info("l3qt[7] : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->l3qt[7],\r\nin_be32(&ugeth->p_rx_glbl_pram->l3qt[7]));\r\nugeth_info("vlantype : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->vlantype,\r\nin_be16(&ugeth->p_rx_glbl_pram->vlantype));\r\nugeth_info("vlantci : addr - 0x%08x, val - 0x%04x",\r\n(u32) & ugeth->p_rx_glbl_pram->vlantci,\r\nin_be16(&ugeth->p_rx_glbl_pram->vlantci));\r\nfor (i = 0; i < 64; i++)\r\nugeth_info\r\n("addressfiltering[%d]: addr - 0x%08x, val - 0x%02x",\r\ni,\r\n(u32) & ugeth->p_rx_glbl_pram->addressfiltering[i],\r\nugeth->p_rx_glbl_pram->addressfiltering[i]);\r\nugeth_info("exfGlobalParam : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_glbl_pram->exfGlobalParam,\r\nin_be32(&ugeth->p_rx_glbl_pram->exfGlobalParam));\r\n}\r\nif (ugeth->p_send_q_mem_reg) {\r\nugeth_info("Send Q memory registers:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_send_q_mem_reg);\r\nfor (i = 0; i < ugeth->ug_info->numQueuesTx; i++) {\r\nugeth_info("SQQD[%d]:", i);\r\nugeth_info("Base address: 0x%08x",\r\n(u32) & ugeth->p_send_q_mem_reg->sqqd[i]);\r\nmem_disp((u8 *) & ugeth->p_send_q_mem_reg->sqqd[i],\r\nsizeof(struct ucc_geth_send_queue_qd));\r\n}\r\n}\r\nif (ugeth->p_scheduler) {\r\nugeth_info("Scheduler:");\r\nugeth_info("Base address: 0x%08x", (u32) ugeth->p_scheduler);\r\nmem_disp((u8 *) ugeth->p_scheduler,\r\nsizeof(*ugeth->p_scheduler));\r\n}\r\nif (ugeth->p_tx_fw_statistics_pram) {\r\nugeth_info("TX FW statistics pram:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_tx_fw_statistics_pram);\r\nmem_disp((u8 *) ugeth->p_tx_fw_statistics_pram,\r\nsizeof(*ugeth->p_tx_fw_statistics_pram));\r\n}\r\nif (ugeth->p_rx_fw_statistics_pram) {\r\nugeth_info("RX FW statistics pram:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_rx_fw_statistics_pram);\r\nmem_disp((u8 *) ugeth->p_rx_fw_statistics_pram,\r\nsizeof(*ugeth->p_rx_fw_statistics_pram));\r\n}\r\nif (ugeth->p_rx_irq_coalescing_tbl) {\r\nugeth_info("RX IRQ coalescing tables:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_rx_irq_coalescing_tbl);\r\nfor (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {\r\nugeth_info("RX IRQ coalescing table entry[%d]:", i);\r\nugeth_info("Base address: 0x%08x",\r\n(u32) & ugeth->p_rx_irq_coalescing_tbl->\r\ncoalescingentry[i]);\r\nugeth_info\r\n("interruptcoalescingmaxvalue: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_irq_coalescing_tbl->\r\ncoalescingentry[i].interruptcoalescingmaxvalue,\r\nin_be32(&ugeth->p_rx_irq_coalescing_tbl->\r\ncoalescingentry[i].\r\ninterruptcoalescingmaxvalue));\r\nugeth_info\r\n("interruptcoalescingcounter : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_irq_coalescing_tbl->\r\ncoalescingentry[i].interruptcoalescingcounter,\r\nin_be32(&ugeth->p_rx_irq_coalescing_tbl->\r\ncoalescingentry[i].\r\ninterruptcoalescingcounter));\r\n}\r\n}\r\nif (ugeth->p_rx_bd_qs_tbl) {\r\nugeth_info("RX BD QS tables:");\r\nugeth_info("Base address: 0x%08x", (u32) ugeth->p_rx_bd_qs_tbl);\r\nfor (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {\r\nugeth_info("RX BD QS table[%d]:", i);\r\nugeth_info("Base address: 0x%08x",\r\n(u32) & ugeth->p_rx_bd_qs_tbl[i]);\r\nugeth_info\r\n("bdbaseptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_bd_qs_tbl[i].bdbaseptr,\r\nin_be32(&ugeth->p_rx_bd_qs_tbl[i].bdbaseptr));\r\nugeth_info\r\n("bdptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_bd_qs_tbl[i].bdptr,\r\nin_be32(&ugeth->p_rx_bd_qs_tbl[i].bdptr));\r\nugeth_info\r\n("externalbdbaseptr: addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,\r\nin_be32(&ugeth->p_rx_bd_qs_tbl[i].\r\nexternalbdbaseptr));\r\nugeth_info\r\n("externalbdptr : addr - 0x%08x, val - 0x%08x",\r\n(u32) & ugeth->p_rx_bd_qs_tbl[i].externalbdptr,\r\nin_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdptr));\r\nugeth_info("ucode RX Prefetched BDs:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32)\r\nqe_muram_addr(in_be32\r\n(&ugeth->p_rx_bd_qs_tbl[i].\r\nbdbaseptr)));\r\nmem_disp((u8 *)\r\nqe_muram_addr(in_be32\r\n(&ugeth->p_rx_bd_qs_tbl[i].\r\nbdbaseptr)),\r\nsizeof(struct ucc_geth_rx_prefetched_bds));\r\n}\r\n}\r\nif (ugeth->p_init_enet_param_shadow) {\r\nint size;\r\nugeth_info("Init enet param shadow:");\r\nugeth_info("Base address: 0x%08x",\r\n(u32) ugeth->p_init_enet_param_shadow);\r\nmem_disp((u8 *) ugeth->p_init_enet_param_shadow,\r\nsizeof(*ugeth->p_init_enet_param_shadow));\r\nsize = sizeof(struct ucc_geth_thread_rx_pram);\r\nif (ugeth->ug_info->rxExtendedFiltering) {\r\nsize +=\r\nTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING;\r\nif (ugeth->ug_info->largestexternallookupkeysize ==\r\nQE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES)\r\nsize +=\r\nTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8;\r\nif (ugeth->ug_info->largestexternallookupkeysize ==\r\nQE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES)\r\nsize +=\r\nTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16;\r\n}\r\ndump_init_enet_entries(ugeth,\r\n&(ugeth->p_init_enet_param_shadow->\r\ntxthread[0]),\r\nENET_INIT_PARAM_MAX_ENTRIES_TX,\r\nsizeof(struct ucc_geth_thread_tx_pram),\r\nugeth->ug_info->riscTx, 0);\r\ndump_init_enet_entries(ugeth,\r\n&(ugeth->p_init_enet_param_shadow->\r\nrxthread[0]),\r\nENET_INIT_PARAM_MAX_ENTRIES_RX, size,\r\nugeth->ug_info->riscRx, 1);\r\n}\r\n}\r\nstatic void init_default_reg_vals(u32 __iomem *upsmr_register,\r\nu32 __iomem *maccfg1_register,\r\nu32 __iomem *maccfg2_register)\r\n{\r\nout_be32(upsmr_register, UCC_GETH_UPSMR_INIT);\r\nout_be32(maccfg1_register, UCC_GETH_MACCFG1_INIT);\r\nout_be32(maccfg2_register, UCC_GETH_MACCFG2_INIT);\r\n}\r\nstatic int init_half_duplex_params(int alt_beb,\r\nint back_pressure_no_backoff,\r\nint no_backoff,\r\nint excess_defer,\r\nu8 alt_beb_truncation,\r\nu8 max_retransmissions,\r\nu8 collision_window,\r\nu32 __iomem *hafdup_register)\r\n{\r\nu32 value = 0;\r\nif ((alt_beb_truncation > HALFDUP_ALT_BEB_TRUNCATION_MAX) ||\r\n(max_retransmissions > HALFDUP_MAX_RETRANSMISSION_MAX) ||\r\n(collision_window > HALFDUP_COLLISION_WINDOW_MAX))\r\nreturn -EINVAL;\r\nvalue = (u32) (alt_beb_truncation << HALFDUP_ALT_BEB_TRUNCATION_SHIFT);\r\nif (alt_beb)\r\nvalue |= HALFDUP_ALT_BEB;\r\nif (back_pressure_no_backoff)\r\nvalue |= HALFDUP_BACK_PRESSURE_NO_BACKOFF;\r\nif (no_backoff)\r\nvalue |= HALFDUP_NO_BACKOFF;\r\nif (excess_defer)\r\nvalue |= HALFDUP_EXCESSIVE_DEFER;\r\nvalue |= (max_retransmissions << HALFDUP_MAX_RETRANSMISSION_SHIFT);\r\nvalue |= collision_window;\r\nout_be32(hafdup_register, value);\r\nreturn 0;\r\n}\r\nstatic int init_inter_frame_gap_params(u8 non_btb_cs_ipg,\r\nu8 non_btb_ipg,\r\nu8 min_ifg,\r\nu8 btb_ipg,\r\nu32 __iomem *ipgifg_register)\r\n{\r\nu32 value = 0;\r\nif (non_btb_cs_ipg > non_btb_ipg)\r\nreturn -EINVAL;\r\nif ((non_btb_cs_ipg > IPGIFG_NON_BACK_TO_BACK_IFG_PART1_MAX) ||\r\n(non_btb_ipg > IPGIFG_NON_BACK_TO_BACK_IFG_PART2_MAX) ||\r\n(btb_ipg > IPGIFG_BACK_TO_BACK_IFG_MAX))\r\nreturn -EINVAL;\r\nvalue |=\r\n((non_btb_cs_ipg << IPGIFG_NON_BACK_TO_BACK_IFG_PART1_SHIFT) &\r\nIPGIFG_NBTB_CS_IPG_MASK);\r\nvalue |=\r\n((non_btb_ipg << IPGIFG_NON_BACK_TO_BACK_IFG_PART2_SHIFT) &\r\nIPGIFG_NBTB_IPG_MASK);\r\nvalue |=\r\n((min_ifg << IPGIFG_MINIMUM_IFG_ENFORCEMENT_SHIFT) &\r\nIPGIFG_MIN_IFG_MASK);\r\nvalue |= (btb_ipg & IPGIFG_BTB_IPG_MASK);\r\nout_be32(ipgifg_register, value);\r\nreturn 0;\r\n}\r\nint init_flow_control_params(u32 automatic_flow_control_mode,\r\nint rx_flow_control_enable,\r\nint tx_flow_control_enable,\r\nu16 pause_period,\r\nu16 extension_field,\r\nu32 __iomem *upsmr_register,\r\nu32 __iomem *uempr_register,\r\nu32 __iomem *maccfg1_register)\r\n{\r\nu32 value = 0;\r\nvalue = (u32) pause_period << UEMPR_PAUSE_TIME_VALUE_SHIFT;\r\nvalue |= (u32) extension_field << UEMPR_EXTENDED_PAUSE_TIME_VALUE_SHIFT;\r\nout_be32(uempr_register, value);\r\nsetbits32(upsmr_register, automatic_flow_control_mode);\r\nvalue = in_be32(maccfg1_register);\r\nif (rx_flow_control_enable)\r\nvalue |= MACCFG1_FLOW_RX;\r\nif (tx_flow_control_enable)\r\nvalue |= MACCFG1_FLOW_TX;\r\nout_be32(maccfg1_register, value);\r\nreturn 0;\r\n}\r\nstatic int init_hw_statistics_gathering_mode(int enable_hardware_statistics,\r\nint auto_zero_hardware_statistics,\r\nu32 __iomem *upsmr_register,\r\nu16 __iomem *uescr_register)\r\n{\r\nu16 uescr_value = 0;\r\nif (enable_hardware_statistics)\r\nsetbits32(upsmr_register, UCC_GETH_UPSMR_HSE);\r\nuescr_value = in_be16(uescr_register);\r\nuescr_value |= UESCR_CLRCNT;\r\nif (auto_zero_hardware_statistics)\r\nuescr_value |= UESCR_AUTOZ;\r\nout_be16(uescr_register, uescr_value);\r\nreturn 0;\r\n}\r\nstatic int init_firmware_statistics_gathering_mode(int\r\nenable_tx_firmware_statistics,\r\nint enable_rx_firmware_statistics,\r\nu32 __iomem *tx_rmon_base_ptr,\r\nu32 tx_firmware_statistics_structure_address,\r\nu32 __iomem *rx_rmon_base_ptr,\r\nu32 rx_firmware_statistics_structure_address,\r\nu16 __iomem *temoder_register,\r\nu32 __iomem *remoder_register)\r\n{\r\nif (enable_tx_firmware_statistics) {\r\nout_be32(tx_rmon_base_ptr,\r\ntx_firmware_statistics_structure_address);\r\nsetbits16(temoder_register, TEMODER_TX_RMON_STATISTICS_ENABLE);\r\n}\r\nif (enable_rx_firmware_statistics) {\r\nout_be32(rx_rmon_base_ptr,\r\nrx_firmware_statistics_structure_address);\r\nsetbits32(remoder_register, REMODER_RX_RMON_STATISTICS_ENABLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_mac_station_addr_regs(u8 address_byte_0,\r\nu8 address_byte_1,\r\nu8 address_byte_2,\r\nu8 address_byte_3,\r\nu8 address_byte_4,\r\nu8 address_byte_5,\r\nu32 __iomem *macstnaddr1_register,\r\nu32 __iomem *macstnaddr2_register)\r\n{\r\nu32 value = 0;\r\nvalue |= (u32) ((address_byte_2 << 0) & 0x000000FF);\r\nvalue |= (u32) ((address_byte_3 << 8) & 0x0000FF00);\r\nvalue |= (u32) ((address_byte_4 << 16) & 0x00FF0000);\r\nvalue |= (u32) ((address_byte_5 << 24) & 0xFF000000);\r\nout_be32(macstnaddr1_register, value);\r\nvalue = 0;\r\nvalue |= (u32) ((address_byte_0 << 16) & 0x00FF0000);\r\nvalue |= (u32) ((address_byte_1 << 24) & 0xFF000000);\r\nout_be32(macstnaddr2_register, value);\r\nreturn 0;\r\n}\r\nstatic int init_check_frame_length_mode(int length_check,\r\nu32 __iomem *maccfg2_register)\r\n{\r\nu32 value = 0;\r\nvalue = in_be32(maccfg2_register);\r\nif (length_check)\r\nvalue |= MACCFG2_LC;\r\nelse\r\nvalue &= ~MACCFG2_LC;\r\nout_be32(maccfg2_register, value);\r\nreturn 0;\r\n}\r\nstatic int init_preamble_length(u8 preamble_length,\r\nu32 __iomem *maccfg2_register)\r\n{\r\nif ((preamble_length < 3) || (preamble_length > 7))\r\nreturn -EINVAL;\r\nclrsetbits_be32(maccfg2_register, MACCFG2_PREL_MASK,\r\npreamble_length << MACCFG2_PREL_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int init_rx_parameters(int reject_broadcast,\r\nint receive_short_frames,\r\nint promiscuous, u32 __iomem *upsmr_register)\r\n{\r\nu32 value = 0;\r\nvalue = in_be32(upsmr_register);\r\nif (reject_broadcast)\r\nvalue |= UCC_GETH_UPSMR_BRO;\r\nelse\r\nvalue &= ~UCC_GETH_UPSMR_BRO;\r\nif (receive_short_frames)\r\nvalue |= UCC_GETH_UPSMR_RSH;\r\nelse\r\nvalue &= ~UCC_GETH_UPSMR_RSH;\r\nif (promiscuous)\r\nvalue |= UCC_GETH_UPSMR_PRO;\r\nelse\r\nvalue &= ~UCC_GETH_UPSMR_PRO;\r\nout_be32(upsmr_register, value);\r\nreturn 0;\r\n}\r\nstatic int init_max_rx_buff_len(u16 max_rx_buf_len,\r\nu16 __iomem *mrblr_register)\r\n{\r\nif ((max_rx_buf_len == 0) ||\r\n(max_rx_buf_len % UCC_GETH_MRBLR_ALIGNMENT))\r\nreturn -EINVAL;\r\nout_be16(mrblr_register, max_rx_buf_len);\r\nreturn 0;\r\n}\r\nstatic int init_min_frame_len(u16 min_frame_length,\r\nu16 __iomem *minflr_register,\r\nu16 __iomem *mrblr_register)\r\n{\r\nu16 mrblr_value = 0;\r\nmrblr_value = in_be16(mrblr_register);\r\nif (min_frame_length >= (mrblr_value - 4))\r\nreturn -EINVAL;\r\nout_be16(minflr_register, min_frame_length);\r\nreturn 0;\r\n}\r\nstatic int adjust_enet_interface(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_geth __iomem *ug_regs;\r\nstruct ucc_fast __iomem *uf_regs;\r\nint ret_val;\r\nu32 upsmr, maccfg2;\r\nu16 value;\r\nugeth_vdbg("%s: IN", __func__);\r\nug_info = ugeth->ug_info;\r\nug_regs = ugeth->ug_regs;\r\nuf_regs = ugeth->uccf->uf_regs;\r\nmaccfg2 = in_be32(&ug_regs->maccfg2);\r\nmaccfg2 &= ~MACCFG2_INTERFACE_MODE_MASK;\r\nif ((ugeth->max_speed == SPEED_10) ||\r\n(ugeth->max_speed == SPEED_100))\r\nmaccfg2 |= MACCFG2_INTERFACE_MODE_NIBBLE;\r\nelse if (ugeth->max_speed == SPEED_1000)\r\nmaccfg2 |= MACCFG2_INTERFACE_MODE_BYTE;\r\nmaccfg2 |= ug_info->padAndCrc;\r\nout_be32(&ug_regs->maccfg2, maccfg2);\r\nupsmr = in_be32(&uf_regs->upsmr);\r\nupsmr &= ~(UCC_GETH_UPSMR_RPM | UCC_GETH_UPSMR_R10M |\r\nUCC_GETH_UPSMR_TBIM | UCC_GETH_UPSMR_RMM);\r\nif ((ugeth->phy_interface == PHY_INTERFACE_MODE_RMII) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_ID) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_RXID) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_TXID) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\r\nif (ugeth->phy_interface != PHY_INTERFACE_MODE_RMII)\r\nupsmr |= UCC_GETH_UPSMR_RPM;\r\nswitch (ugeth->max_speed) {\r\ncase SPEED_10:\r\nupsmr |= UCC_GETH_UPSMR_R10M;\r\ncase SPEED_100:\r\nif (ugeth->phy_interface != PHY_INTERFACE_MODE_RTBI)\r\nupsmr |= UCC_GETH_UPSMR_RMM;\r\n}\r\n}\r\nif ((ugeth->phy_interface == PHY_INTERFACE_MODE_TBI) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\r\nupsmr |= UCC_GETH_UPSMR_TBIM;\r\n}\r\nif ((ugeth->phy_interface == PHY_INTERFACE_MODE_SGMII))\r\nupsmr |= UCC_GETH_UPSMR_SGMM;\r\nout_be32(&uf_regs->upsmr, upsmr);\r\nif ((ugeth->phy_interface == PHY_INTERFACE_MODE_TBI) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\r\nstruct ucc_geth_info *ug_info = ugeth->ug_info;\r\nstruct phy_device *tbiphy;\r\nif (!ug_info->tbi_node)\r\nugeth_warn("TBI mode requires that the device "\r\n"tree specify a tbi-handle\n");\r\ntbiphy = of_phy_find_device(ug_info->tbi_node);\r\nif (!tbiphy)\r\nugeth_warn("Could not get TBI device\n");\r\nvalue = phy_read(tbiphy, ENET_TBI_MII_CR);\r\nvalue &= ~0x1000;\r\nphy_write(tbiphy, ENET_TBI_MII_CR, value);\r\n}\r\ninit_check_frame_length_mode(ug_info->lengthCheckRx, &ug_regs->maccfg2);\r\nret_val = init_preamble_length(ug_info->prel, &ug_regs->maccfg2);\r\nif (ret_val != 0) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: Preamble length must be between 3 and 7 inclusive.",\r\n__func__);\r\nreturn ret_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ugeth_graceful_stop_tx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nu32 cecr_subblock;\r\nu32 temp;\r\nint i = 10;\r\nuccf = ugeth->uccf;\r\nclrbits32(uccf->p_uccm, UCC_GETH_UCCE_GRA);\r\nout_be32(uccf->p_ucce, UCC_GETH_UCCE_GRA);\r\ncecr_subblock =\r\nucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\r\nqe_issue_cmd(QE_GRACEFUL_STOP_TX, cecr_subblock,\r\nQE_CR_PROTOCOL_ETHERNET, 0);\r\ndo {\r\nmsleep(10);\r\ntemp = in_be32(uccf->p_ucce);\r\n} while (!(temp & UCC_GETH_UCCE_GRA) && --i);\r\nuccf->stopped_tx = 1;\r\nreturn 0;\r\n}\r\nstatic int ugeth_graceful_stop_rx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nu32 cecr_subblock;\r\nu8 temp;\r\nint i = 10;\r\nuccf = ugeth->uccf;\r\ntemp = in_8(&ugeth->p_rx_glbl_pram->rxgstpack);\r\ntemp &= ~GRACEFUL_STOP_ACKNOWLEDGE_RX;\r\nout_8(&ugeth->p_rx_glbl_pram->rxgstpack, temp);\r\ndo {\r\ncecr_subblock =\r\nucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.\r\nucc_num);\r\nqe_issue_cmd(QE_GRACEFUL_STOP_RX, cecr_subblock,\r\nQE_CR_PROTOCOL_ETHERNET, 0);\r\nmsleep(10);\r\ntemp = in_8(&ugeth->p_rx_glbl_pram->rxgstpack);\r\n} while (!(temp & GRACEFUL_STOP_ACKNOWLEDGE_RX) && --i);\r\nuccf->stopped_rx = 1;\r\nreturn 0;\r\n}\r\nstatic int ugeth_restart_tx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nu32 cecr_subblock;\r\nuccf = ugeth->uccf;\r\ncecr_subblock =\r\nucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\r\nqe_issue_cmd(QE_RESTART_TX, cecr_subblock, QE_CR_PROTOCOL_ETHERNET, 0);\r\nuccf->stopped_tx = 0;\r\nreturn 0;\r\n}\r\nstatic int ugeth_restart_rx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nu32 cecr_subblock;\r\nuccf = ugeth->uccf;\r\ncecr_subblock =\r\nucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\r\nqe_issue_cmd(QE_RESTART_RX, cecr_subblock, QE_CR_PROTOCOL_ETHERNET,\r\n0);\r\nuccf->stopped_rx = 0;\r\nreturn 0;\r\n}\r\nstatic int ugeth_enable(struct ucc_geth_private *ugeth, enum comm_dir mode)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nint enabled_tx, enabled_rx;\r\nuccf = ugeth->uccf;\r\nif (ugeth->ug_info->uf_info.ucc_num >= UCC_MAX_NUM) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: ucc_num out of range.", __func__);\r\nreturn -EINVAL;\r\n}\r\nenabled_tx = uccf->enabled_tx;\r\nenabled_rx = uccf->enabled_rx;\r\nif ((mode & COMM_DIR_TX) && (!enabled_tx) && uccf->stopped_tx)\r\nugeth_restart_tx(ugeth);\r\nif ((mode & COMM_DIR_RX) && (!enabled_rx) && uccf->stopped_rx)\r\nugeth_restart_rx(ugeth);\r\nucc_fast_enable(uccf, mode);\r\nreturn 0;\r\n}\r\nstatic int ugeth_disable(struct ucc_geth_private *ugeth, enum comm_dir mode)\r\n{\r\nstruct ucc_fast_private *uccf;\r\nuccf = ugeth->uccf;\r\nif (ugeth->ug_info->uf_info.ucc_num >= UCC_MAX_NUM) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: ucc_num out of range.", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((mode & COMM_DIR_TX) && uccf->enabled_tx && !uccf->stopped_tx)\r\nugeth_graceful_stop_tx(ugeth);\r\nif ((mode & COMM_DIR_RX) && uccf->enabled_rx && !uccf->stopped_rx)\r\nugeth_graceful_stop_rx(ugeth);\r\nucc_fast_disable(ugeth->uccf, mode);\r\nreturn 0;\r\n}\r\nstatic void ugeth_quiesce(struct ucc_geth_private *ugeth)\r\n{\r\nnetif_device_detach(ugeth->ndev);\r\nnetif_tx_disable(ugeth->ndev);\r\ndisable_irq(ugeth->ug_info->uf_info.irq);\r\nnapi_disable(&ugeth->napi);\r\n}\r\nstatic void ugeth_activate(struct ucc_geth_private *ugeth)\r\n{\r\nnapi_enable(&ugeth->napi);\r\nenable_irq(ugeth->ug_info->uf_info.irq);\r\nnetif_device_attach(ugeth->ndev);\r\n}\r\nstatic void adjust_link(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nstruct ucc_geth __iomem *ug_regs;\r\nstruct ucc_fast __iomem *uf_regs;\r\nstruct phy_device *phydev = ugeth->phydev;\r\nint new_state = 0;\r\nug_regs = ugeth->ug_regs;\r\nuf_regs = ugeth->uccf->uf_regs;\r\nif (phydev->link) {\r\nu32 tempval = in_be32(&ug_regs->maccfg2);\r\nu32 upsmr = in_be32(&uf_regs->upsmr);\r\nif (phydev->duplex != ugeth->oldduplex) {\r\nnew_state = 1;\r\nif (!(phydev->duplex))\r\ntempval &= ~(MACCFG2_FDX);\r\nelse\r\ntempval |= MACCFG2_FDX;\r\nugeth->oldduplex = phydev->duplex;\r\n}\r\nif (phydev->speed != ugeth->oldspeed) {\r\nnew_state = 1;\r\nswitch (phydev->speed) {\r\ncase SPEED_1000:\r\ntempval = ((tempval &\r\n~(MACCFG2_INTERFACE_MODE_MASK)) |\r\nMACCFG2_INTERFACE_MODE_BYTE);\r\nbreak;\r\ncase SPEED_100:\r\ncase SPEED_10:\r\ntempval = ((tempval &\r\n~(MACCFG2_INTERFACE_MODE_MASK)) |\r\nMACCFG2_INTERFACE_MODE_NIBBLE);\r\nif ((ugeth->phy_interface == PHY_INTERFACE_MODE_RMII) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_ID) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_RXID) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_TXID) ||\r\n(ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\r\nif (phydev->speed == SPEED_10)\r\nupsmr |= UCC_GETH_UPSMR_R10M;\r\nelse\r\nupsmr &= ~UCC_GETH_UPSMR_R10M;\r\n}\r\nbreak;\r\ndefault:\r\nif (netif_msg_link(ugeth))\r\nugeth_warn(\r\n"%s: Ack! Speed (%d) is not 10/100/1000!",\r\ndev->name, phydev->speed);\r\nbreak;\r\n}\r\nugeth->oldspeed = phydev->speed;\r\n}\r\nif (!ugeth->oldlink) {\r\nnew_state = 1;\r\nugeth->oldlink = 1;\r\n}\r\nif (new_state) {\r\nugeth_quiesce(ugeth);\r\nugeth_disable(ugeth, COMM_DIR_RX_AND_TX);\r\nout_be32(&ug_regs->maccfg2, tempval);\r\nout_be32(&uf_regs->upsmr, upsmr);\r\nugeth_enable(ugeth, COMM_DIR_RX_AND_TX);\r\nugeth_activate(ugeth);\r\n}\r\n} else if (ugeth->oldlink) {\r\nnew_state = 1;\r\nugeth->oldlink = 0;\r\nugeth->oldspeed = 0;\r\nugeth->oldduplex = -1;\r\n}\r\nif (new_state && netif_msg_link(ugeth))\r\nphy_print_status(phydev);\r\n}\r\nstatic void uec_configure_serdes(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nstruct ucc_geth_info *ug_info = ugeth->ug_info;\r\nstruct phy_device *tbiphy;\r\nif (!ug_info->tbi_node) {\r\ndev_warn(&dev->dev, "SGMII mode requires that the device "\r\n"tree specify a tbi-handle\n");\r\nreturn;\r\n}\r\ntbiphy = of_phy_find_device(ug_info->tbi_node);\r\nif (!tbiphy) {\r\ndev_err(&dev->dev, "error: Could not get TBI device\n");\r\nreturn;\r\n}\r\nif (phy_read(tbiphy, ENET_TBI_MII_SR) & TBISR_LSTATUS)\r\nreturn;\r\nphy_write(tbiphy, ENET_TBI_MII_ANA, TBIANA_SETTINGS);\r\nphy_write(tbiphy, ENET_TBI_MII_TBICON, TBICON_CLK_SELECT);\r\nphy_write(tbiphy, ENET_TBI_MII_CR, TBICR_SETTINGS);\r\n}\r\nstatic int init_phy(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *priv = netdev_priv(dev);\r\nstruct ucc_geth_info *ug_info = priv->ug_info;\r\nstruct phy_device *phydev;\r\npriv->oldlink = 0;\r\npriv->oldspeed = 0;\r\npriv->oldduplex = -1;\r\nphydev = of_phy_connect(dev, ug_info->phy_node, &adjust_link, 0,\r\npriv->phy_interface);\r\nif (!phydev)\r\nphydev = of_phy_connect_fixed_link(dev, &adjust_link,\r\npriv->phy_interface);\r\nif (!phydev) {\r\ndev_err(&dev->dev, "Could not attach to PHY\n");\r\nreturn -ENODEV;\r\n}\r\nif (priv->phy_interface == PHY_INTERFACE_MODE_SGMII)\r\nuec_configure_serdes(dev);\r\nphydev->supported &= (SUPPORTED_MII |\r\nSUPPORTED_Autoneg |\r\nADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full);\r\nif (priv->max_speed == SPEED_1000)\r\nphydev->supported |= ADVERTISED_1000baseT_Full;\r\nphydev->advertising = phydev->supported;\r\npriv->phydev = phydev;\r\nreturn 0;\r\n}\r\nstatic void ugeth_dump_regs(struct ucc_geth_private *ugeth)\r\n{\r\n#ifdef DEBUG\r\nucc_fast_dump_regs(ugeth->uccf);\r\ndump_regs(ugeth);\r\ndump_bds(ugeth);\r\n#endif\r\n}\r\nstatic int ugeth_82xx_filtering_clear_all_addr_in_hash(struct ucc_geth_private *\r\nugeth,\r\nenum enet_addr_type\r\nenet_addr_type)\r\n{\r\nstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\r\nstruct ucc_fast_private *uccf;\r\nenum comm_dir comm_dir;\r\nstruct list_head *p_lh;\r\nu16 i, num;\r\nu32 __iomem *addr_h;\r\nu32 __iomem *addr_l;\r\nu8 *p_counter;\r\nuccf = ugeth->uccf;\r\np_82xx_addr_filt =\r\n(struct ucc_geth_82xx_address_filtering_pram __iomem *)\r\nugeth->p_rx_glbl_pram->addressfiltering;\r\nif (enet_addr_type == ENET_ADDR_TYPE_GROUP) {\r\naddr_h = &(p_82xx_addr_filt->gaddr_h);\r\naddr_l = &(p_82xx_addr_filt->gaddr_l);\r\np_lh = &ugeth->group_hash_q;\r\np_counter = &(ugeth->numGroupAddrInHash);\r\n} else if (enet_addr_type == ENET_ADDR_TYPE_INDIVIDUAL) {\r\naddr_h = &(p_82xx_addr_filt->iaddr_h);\r\naddr_l = &(p_82xx_addr_filt->iaddr_l);\r\np_lh = &ugeth->ind_hash_q;\r\np_counter = &(ugeth->numIndAddrInHash);\r\n} else\r\nreturn -EINVAL;\r\ncomm_dir = 0;\r\nif (uccf->enabled_tx)\r\ncomm_dir |= COMM_DIR_TX;\r\nif (uccf->enabled_rx)\r\ncomm_dir |= COMM_DIR_RX;\r\nif (comm_dir)\r\nugeth_disable(ugeth, comm_dir);\r\nout_be32(addr_h, 0x00000000);\r\nout_be32(addr_l, 0x00000000);\r\nif (!p_lh)\r\nreturn 0;\r\nnum = *p_counter;\r\nfor (i = 0; i < num; i++)\r\nput_enet_addr_container(ENET_ADDR_CONT_ENTRY(dequeue(p_lh)));\r\n*p_counter = 0;\r\nif (comm_dir)\r\nugeth_enable(ugeth, comm_dir);\r\nreturn 0;\r\n}\r\nstatic int ugeth_82xx_filtering_clear_addr_in_paddr(struct ucc_geth_private *ugeth,\r\nu8 paddr_num)\r\n{\r\nugeth->indAddrRegUsed[paddr_num] = 0;\r\nreturn hw_clear_addr_in_paddr(ugeth, paddr_num);\r\n}\r\nstatic void ucc_geth_free_rx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_fast_info *uf_info;\r\nu16 i, j;\r\nu8 __iomem *bd;\r\nug_info = ugeth->ug_info;\r\nuf_info = &ug_info->uf_info;\r\nfor (i = 0; i < ugeth->ug_info->numQueuesRx; i++) {\r\nif (ugeth->p_rx_bd_ring[i]) {\r\nbd = ugeth->p_rx_bd_ring[i];\r\nfor (j = 0; j < ugeth->ug_info->bdRingLenRx[i]; j++) {\r\nif (ugeth->rx_skbuff[i][j]) {\r\ndma_unmap_single(ugeth->dev,\r\nin_be32(&((struct qe_bd __iomem *)bd)->buf),\r\nugeth->ug_info->\r\nuf_info.max_rx_buf_length +\r\nUCC_GETH_RX_DATA_BUF_ALIGNMENT,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb_any(\r\nugeth->rx_skbuff[i][j]);\r\nugeth->rx_skbuff[i][j] = NULL;\r\n}\r\nbd += sizeof(struct qe_bd);\r\n}\r\nkfree(ugeth->rx_skbuff[i]);\r\nif (ugeth->ug_info->uf_info.bd_mem_part ==\r\nMEM_PART_SYSTEM)\r\nkfree((void *)ugeth->rx_bd_ring_offset[i]);\r\nelse if (ugeth->ug_info->uf_info.bd_mem_part ==\r\nMEM_PART_MURAM)\r\nqe_muram_free(ugeth->rx_bd_ring_offset[i]);\r\nugeth->p_rx_bd_ring[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void ucc_geth_free_tx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_fast_info *uf_info;\r\nu16 i, j;\r\nu8 __iomem *bd;\r\nug_info = ugeth->ug_info;\r\nuf_info = &ug_info->uf_info;\r\nfor (i = 0; i < ugeth->ug_info->numQueuesTx; i++) {\r\nbd = ugeth->p_tx_bd_ring[i];\r\nif (!bd)\r\ncontinue;\r\nfor (j = 0; j < ugeth->ug_info->bdRingLenTx[i]; j++) {\r\nif (ugeth->tx_skbuff[i][j]) {\r\ndma_unmap_single(ugeth->dev,\r\nin_be32(&((struct qe_bd __iomem *)bd)->buf),\r\n(in_be32((u32 __iomem *)bd) &\r\nBD_LENGTH_MASK),\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_any(ugeth->tx_skbuff[i][j]);\r\nugeth->tx_skbuff[i][j] = NULL;\r\n}\r\n}\r\nkfree(ugeth->tx_skbuff[i]);\r\nif (ugeth->p_tx_bd_ring[i]) {\r\nif (ugeth->ug_info->uf_info.bd_mem_part ==\r\nMEM_PART_SYSTEM)\r\nkfree((void *)ugeth->tx_bd_ring_offset[i]);\r\nelse if (ugeth->ug_info->uf_info.bd_mem_part ==\r\nMEM_PART_MURAM)\r\nqe_muram_free(ugeth->tx_bd_ring_offset[i]);\r\nugeth->p_tx_bd_ring[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void ucc_geth_memclean(struct ucc_geth_private *ugeth)\r\n{\r\nif (!ugeth)\r\nreturn;\r\nif (ugeth->uccf) {\r\nucc_fast_free(ugeth->uccf);\r\nugeth->uccf = NULL;\r\n}\r\nif (ugeth->p_thread_data_tx) {\r\nqe_muram_free(ugeth->thread_dat_tx_offset);\r\nugeth->p_thread_data_tx = NULL;\r\n}\r\nif (ugeth->p_thread_data_rx) {\r\nqe_muram_free(ugeth->thread_dat_rx_offset);\r\nugeth->p_thread_data_rx = NULL;\r\n}\r\nif (ugeth->p_exf_glbl_param) {\r\nqe_muram_free(ugeth->exf_glbl_param_offset);\r\nugeth->p_exf_glbl_param = NULL;\r\n}\r\nif (ugeth->p_rx_glbl_pram) {\r\nqe_muram_free(ugeth->rx_glbl_pram_offset);\r\nugeth->p_rx_glbl_pram = NULL;\r\n}\r\nif (ugeth->p_tx_glbl_pram) {\r\nqe_muram_free(ugeth->tx_glbl_pram_offset);\r\nugeth->p_tx_glbl_pram = NULL;\r\n}\r\nif (ugeth->p_send_q_mem_reg) {\r\nqe_muram_free(ugeth->send_q_mem_reg_offset);\r\nugeth->p_send_q_mem_reg = NULL;\r\n}\r\nif (ugeth->p_scheduler) {\r\nqe_muram_free(ugeth->scheduler_offset);\r\nugeth->p_scheduler = NULL;\r\n}\r\nif (ugeth->p_tx_fw_statistics_pram) {\r\nqe_muram_free(ugeth->tx_fw_statistics_pram_offset);\r\nugeth->p_tx_fw_statistics_pram = NULL;\r\n}\r\nif (ugeth->p_rx_fw_statistics_pram) {\r\nqe_muram_free(ugeth->rx_fw_statistics_pram_offset);\r\nugeth->p_rx_fw_statistics_pram = NULL;\r\n}\r\nif (ugeth->p_rx_irq_coalescing_tbl) {\r\nqe_muram_free(ugeth->rx_irq_coalescing_tbl_offset);\r\nugeth->p_rx_irq_coalescing_tbl = NULL;\r\n}\r\nif (ugeth->p_rx_bd_qs_tbl) {\r\nqe_muram_free(ugeth->rx_bd_qs_tbl_offset);\r\nugeth->p_rx_bd_qs_tbl = NULL;\r\n}\r\nif (ugeth->p_init_enet_param_shadow) {\r\nreturn_init_enet_entries(ugeth,\r\n&(ugeth->p_init_enet_param_shadow->\r\nrxthread[0]),\r\nENET_INIT_PARAM_MAX_ENTRIES_RX,\r\nugeth->ug_info->riscRx, 1);\r\nreturn_init_enet_entries(ugeth,\r\n&(ugeth->p_init_enet_param_shadow->\r\ntxthread[0]),\r\nENET_INIT_PARAM_MAX_ENTRIES_TX,\r\nugeth->ug_info->riscTx, 0);\r\nkfree(ugeth->p_init_enet_param_shadow);\r\nugeth->p_init_enet_param_shadow = NULL;\r\n}\r\nucc_geth_free_tx(ugeth);\r\nucc_geth_free_rx(ugeth);\r\nwhile (!list_empty(&ugeth->group_hash_q))\r\nput_enet_addr_container(ENET_ADDR_CONT_ENTRY\r\n(dequeue(&ugeth->group_hash_q)));\r\nwhile (!list_empty(&ugeth->ind_hash_q))\r\nput_enet_addr_container(ENET_ADDR_CONT_ENTRY\r\n(dequeue(&ugeth->ind_hash_q)));\r\nif (ugeth->ug_regs) {\r\niounmap(ugeth->ug_regs);\r\nugeth->ug_regs = NULL;\r\n}\r\n}\r\nstatic void ucc_geth_set_multi(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth;\r\nstruct netdev_hw_addr *ha;\r\nstruct ucc_fast __iomem *uf_regs;\r\nstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\r\nugeth = netdev_priv(dev);\r\nuf_regs = ugeth->uccf->uf_regs;\r\nif (dev->flags & IFF_PROMISC) {\r\nsetbits32(&uf_regs->upsmr, UCC_GETH_UPSMR_PRO);\r\n} else {\r\nclrbits32(&uf_regs->upsmr, UCC_GETH_UPSMR_PRO);\r\np_82xx_addr_filt =\r\n(struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->\r\np_rx_glbl_pram->addressfiltering;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nout_be32(&p_82xx_addr_filt->gaddr_h, 0xffffffff);\r\nout_be32(&p_82xx_addr_filt->gaddr_l, 0xffffffff);\r\n} else {\r\nout_be32(&p_82xx_addr_filt->gaddr_h, 0x0);\r\nout_be32(&p_82xx_addr_filt->gaddr_l, 0x0);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nhw_add_addr_in_hash(ugeth, ha->addr);\r\n}\r\n}\r\n}\r\n}\r\nstatic void ucc_geth_stop(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth __iomem *ug_regs = ugeth->ug_regs;\r\nstruct phy_device *phydev = ugeth->phydev;\r\nugeth_vdbg("%s: IN", __func__);\r\nphy_stop(phydev);\r\nugeth_disable(ugeth, COMM_DIR_RX_AND_TX);\r\nout_be32(ugeth->uccf->p_uccm, 0x00000000);\r\nout_be32(ugeth->uccf->p_ucce, 0xffffffff);\r\nclrbits32(&ug_regs->maccfg1, MACCFG1_ENABLE_RX | MACCFG1_ENABLE_TX);\r\nucc_geth_memclean(ugeth);\r\n}\r\nstatic int ucc_struct_init(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_fast_info *uf_info;\r\nint i;\r\nug_info = ugeth->ug_info;\r\nuf_info = &ug_info->uf_info;\r\nif (!((uf_info->bd_mem_part == MEM_PART_SYSTEM) ||\r\n(uf_info->bd_mem_part == MEM_PART_MURAM))) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: Bad memory partition value.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ug_info->numQueuesRx; i++) {\r\nif ((ug_info->bdRingLenRx[i] < UCC_GETH_RX_BD_RING_SIZE_MIN) ||\r\n(ug_info->bdRingLenRx[i] %\r\nUCC_GETH_RX_BD_RING_SIZE_ALIGNMENT)) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err\r\n("%s: Rx BD ring length must be multiple of 4, no smaller than 8.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < ug_info->numQueuesTx; i++) {\r\nif (ug_info->bdRingLenTx[i] < UCC_GETH_TX_BD_RING_SIZE_MIN) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err\r\n("%s: Tx BD ring length must be no smaller than 2.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((uf_info->max_rx_buf_length == 0) ||\r\n(uf_info->max_rx_buf_length % UCC_GETH_MRBLR_ALIGNMENT)) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err\r\n("%s: max_rx_buf_length must be non-zero multiple of 128.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (ug_info->numQueuesTx > NUM_TX_QUEUES) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: number of tx queues too large.", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (ug_info->numQueuesRx > NUM_RX_QUEUES) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: number of rx queues too large.", __func__);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < UCC_GETH_VLAN_PRIORITY_MAX; i++) {\r\nif (ug_info->l2qt[i] >= ug_info->numQueuesRx) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err\r\n("%s: VLAN priority table entry must not be"\r\n" larger than number of Rx queues.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < UCC_GETH_IP_PRIORITY_MAX; i++) {\r\nif (ug_info->l3qt[i] >= ug_info->numQueuesRx) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err\r\n("%s: IP priority table entry must not be"\r\n" larger than number of Rx queues.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (ug_info->cam && !ug_info->ecamptr) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: If cam mode is chosen, must supply cam ptr.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif ((ug_info->numStationAddresses !=\r\nUCC_GETH_NUM_OF_STATION_ADDRESSES_1) &&\r\nug_info->rxExtendedFiltering) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: Number of station addresses greater than 1 "\r\n"not allowed in extended parsing mode.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nuf_info->uccm_mask = ug_info->eventRegMask & UCCE_OTHER;\r\nfor (i = 0; i < ug_info->numQueuesRx; i++)\r\nuf_info->uccm_mask |= (UCC_GETH_UCCE_RXF0 << i);\r\nfor (i = 0; i < ug_info->numQueuesTx; i++)\r\nuf_info->uccm_mask |= (UCC_GETH_UCCE_TXB0 << i);\r\nif (ucc_fast_init(uf_info, &ugeth->uccf)) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: Failed to init uccf.", __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (qe_get_num_of_risc() == 4) {\r\nug_info->riscTx = QE_RISC_ALLOCATION_FOUR_RISCS;\r\nug_info->riscRx = QE_RISC_ALLOCATION_FOUR_RISCS;\r\n}\r\nugeth->ug_regs = ioremap(uf_info->regs, sizeof(*ugeth->ug_regs));\r\nif (!ugeth->ug_regs) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: Failed to ioremap regs.", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_alloc_tx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_fast_info *uf_info;\r\nint length;\r\nu16 i, j;\r\nu8 __iomem *bd;\r\nug_info = ugeth->ug_info;\r\nuf_info = &ug_info->uf_info;\r\nfor (j = 0; j < ug_info->numQueuesTx; j++) {\r\nlength = ((ug_info->bdRingLenTx[j] * sizeof(struct qe_bd))\r\n/ UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT)\r\n* UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT;\r\nif ((ug_info->bdRingLenTx[j] * sizeof(struct qe_bd)) %\r\nUCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT)\r\nlength += UCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT;\r\nif (uf_info->bd_mem_part == MEM_PART_SYSTEM) {\r\nu32 align = 4;\r\nif (UCC_GETH_TX_BD_RING_ALIGNMENT > 4)\r\nalign = UCC_GETH_TX_BD_RING_ALIGNMENT;\r\nugeth->tx_bd_ring_offset[j] =\r\n(u32) kmalloc((u32) (length + align), GFP_KERNEL);\r\nif (ugeth->tx_bd_ring_offset[j] != 0)\r\nugeth->p_tx_bd_ring[j] =\r\n(u8 __iomem *)((ugeth->tx_bd_ring_offset[j] +\r\nalign) & ~(align - 1));\r\n} else if (uf_info->bd_mem_part == MEM_PART_MURAM) {\r\nugeth->tx_bd_ring_offset[j] =\r\nqe_muram_alloc(length,\r\nUCC_GETH_TX_BD_RING_ALIGNMENT);\r\nif (!IS_ERR_VALUE(ugeth->tx_bd_ring_offset[j]))\r\nugeth->p_tx_bd_ring[j] =\r\n(u8 __iomem *) qe_muram_addr(ugeth->\r\ntx_bd_ring_offset[j]);\r\n}\r\nif (!ugeth->p_tx_bd_ring[j]) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate memory for Tx bd rings.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset_io((void __iomem *)(ugeth->p_tx_bd_ring[j] +\r\nug_info->bdRingLenTx[j] * sizeof(struct qe_bd)), 0,\r\nlength - ug_info->bdRingLenTx[j] * sizeof(struct qe_bd));\r\n}\r\nfor (j = 0; j < ug_info->numQueuesTx; j++) {\r\nugeth->tx_skbuff[j] = kmalloc(sizeof(struct sk_buff *) *\r\nugeth->ug_info->bdRingLenTx[j],\r\nGFP_KERNEL);\r\nif (ugeth->tx_skbuff[j] == NULL) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Could not allocate tx_skbuff",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ugeth->ug_info->bdRingLenTx[j]; i++)\r\nugeth->tx_skbuff[j][i] = NULL;\r\nugeth->skb_curtx[j] = ugeth->skb_dirtytx[j] = 0;\r\nbd = ugeth->confBd[j] = ugeth->txBd[j] = ugeth->p_tx_bd_ring[j];\r\nfor (i = 0; i < ug_info->bdRingLenTx[j]; i++) {\r\nout_be32(&((struct qe_bd __iomem *)bd)->buf, 0);\r\nout_be32((u32 __iomem *)bd, 0);\r\nbd += sizeof(struct qe_bd);\r\n}\r\nbd -= sizeof(struct qe_bd);\r\nout_be32((u32 __iomem *)bd, T_W);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_alloc_rx(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_fast_info *uf_info;\r\nint length;\r\nu16 i, j;\r\nu8 __iomem *bd;\r\nug_info = ugeth->ug_info;\r\nuf_info = &ug_info->uf_info;\r\nfor (j = 0; j < ug_info->numQueuesRx; j++) {\r\nlength = ug_info->bdRingLenRx[j] * sizeof(struct qe_bd);\r\nif (uf_info->bd_mem_part == MEM_PART_SYSTEM) {\r\nu32 align = 4;\r\nif (UCC_GETH_RX_BD_RING_ALIGNMENT > 4)\r\nalign = UCC_GETH_RX_BD_RING_ALIGNMENT;\r\nugeth->rx_bd_ring_offset[j] =\r\n(u32) kmalloc((u32) (length + align), GFP_KERNEL);\r\nif (ugeth->rx_bd_ring_offset[j] != 0)\r\nugeth->p_rx_bd_ring[j] =\r\n(u8 __iomem *)((ugeth->rx_bd_ring_offset[j] +\r\nalign) & ~(align - 1));\r\n} else if (uf_info->bd_mem_part == MEM_PART_MURAM) {\r\nugeth->rx_bd_ring_offset[j] =\r\nqe_muram_alloc(length,\r\nUCC_GETH_RX_BD_RING_ALIGNMENT);\r\nif (!IS_ERR_VALUE(ugeth->rx_bd_ring_offset[j]))\r\nugeth->p_rx_bd_ring[j] =\r\n(u8 __iomem *) qe_muram_addr(ugeth->\r\nrx_bd_ring_offset[j]);\r\n}\r\nif (!ugeth->p_rx_bd_ring[j]) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate memory for Rx bd rings.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (j = 0; j < ug_info->numQueuesRx; j++) {\r\nugeth->rx_skbuff[j] = kmalloc(sizeof(struct sk_buff *) *\r\nugeth->ug_info->bdRingLenRx[j],\r\nGFP_KERNEL);\r\nif (ugeth->rx_skbuff[j] == NULL) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Could not allocate rx_skbuff",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ugeth->ug_info->bdRingLenRx[j]; i++)\r\nugeth->rx_skbuff[j][i] = NULL;\r\nugeth->skb_currx[j] = 0;\r\nbd = ugeth->rxBd[j] = ugeth->p_rx_bd_ring[j];\r\nfor (i = 0; i < ug_info->bdRingLenRx[j]; i++) {\r\nout_be32((u32 __iomem *)bd, R_I);\r\nout_be32(&((struct qe_bd __iomem *)bd)->buf, 0);\r\nbd += sizeof(struct qe_bd);\r\n}\r\nbd -= sizeof(struct qe_bd);\r\nout_be32((u32 __iomem *)bd, R_W);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_startup(struct ucc_geth_private *ugeth)\r\n{\r\nstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\r\nstruct ucc_geth_init_pram __iomem *p_init_enet_pram;\r\nstruct ucc_fast_private *uccf;\r\nstruct ucc_geth_info *ug_info;\r\nstruct ucc_fast_info *uf_info;\r\nstruct ucc_fast __iomem *uf_regs;\r\nstruct ucc_geth __iomem *ug_regs;\r\nint ret_val = -EINVAL;\r\nu32 remoder = UCC_GETH_REMODER_INIT;\r\nu32 init_enet_pram_offset, cecr_subblock, command;\r\nu32 ifstat, i, j, size, l2qt, l3qt;\r\nu16 temoder = UCC_GETH_TEMODER_INIT;\r\nu16 test;\r\nu8 function_code = 0;\r\nu8 __iomem *endOfRing;\r\nu8 numThreadsRxNumerical, numThreadsTxNumerical;\r\nugeth_vdbg("%s: IN", __func__);\r\nuccf = ugeth->uccf;\r\nug_info = ugeth->ug_info;\r\nuf_info = &ug_info->uf_info;\r\nuf_regs = uccf->uf_regs;\r\nug_regs = ugeth->ug_regs;\r\nswitch (ug_info->numThreadsRx) {\r\ncase UCC_GETH_NUM_OF_THREADS_1:\r\nnumThreadsRxNumerical = 1;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_2:\r\nnumThreadsRxNumerical = 2;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_4:\r\nnumThreadsRxNumerical = 4;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_6:\r\nnumThreadsRxNumerical = 6;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_8:\r\nnumThreadsRxNumerical = 8;\r\nbreak;\r\ndefault:\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Bad number of Rx threads value.",\r\n__func__);\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nswitch (ug_info->numThreadsTx) {\r\ncase UCC_GETH_NUM_OF_THREADS_1:\r\nnumThreadsTxNumerical = 1;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_2:\r\nnumThreadsTxNumerical = 2;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_4:\r\nnumThreadsTxNumerical = 4;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_6:\r\nnumThreadsTxNumerical = 6;\r\nbreak;\r\ncase UCC_GETH_NUM_OF_THREADS_8:\r\nnumThreadsTxNumerical = 8;\r\nbreak;\r\ndefault:\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Bad number of Tx threads value.",\r\n__func__);\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nugeth->rx_non_dynamic_extended_features = ug_info->ipCheckSumCheck ||\r\nug_info->ipAddressAlignment ||\r\n(ug_info->numStationAddresses !=\r\nUCC_GETH_NUM_OF_STATION_ADDRESSES_1);\r\nugeth->rx_extended_features = ugeth->rx_non_dynamic_extended_features ||\r\n(ug_info->vlanOperationTagged != UCC_GETH_VLAN_OPERATION_TAGGED_NOP) ||\r\n(ug_info->vlanOperationNonTagged !=\r\nUCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP);\r\ninit_default_reg_vals(&uf_regs->upsmr,\r\n&ug_regs->maccfg1, &ug_regs->maccfg2);\r\ninit_rx_parameters(ug_info->bro,\r\nug_info->rsh, ug_info->pro, &uf_regs->upsmr);\r\ninit_flow_control_params(ug_info->aufc,\r\nug_info->receiveFlowControl,\r\nug_info->transmitFlowControl,\r\nug_info->pausePeriod,\r\nug_info->extensionField,\r\n&uf_regs->upsmr,\r\n&ug_regs->uempr, &ug_regs->maccfg1);\r\nsetbits32(&ug_regs->maccfg1, MACCFG1_ENABLE_RX | MACCFG1_ENABLE_TX);\r\nret_val = init_inter_frame_gap_params(ug_info->nonBackToBackIfgPart1,\r\nug_info->nonBackToBackIfgPart2,\r\nug_info->\r\nmiminumInterFrameGapEnforcement,\r\nug_info->backToBackInterFrameGap,\r\n&ug_regs->ipgifg);\r\nif (ret_val != 0) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: IPGIFG initialization parameter too large.",\r\n__func__);\r\nreturn ret_val;\r\n}\r\nret_val = init_half_duplex_params(ug_info->altBeb,\r\nug_info->backPressureNoBackoff,\r\nug_info->noBackoff,\r\nug_info->excessDefer,\r\nug_info->altBebTruncation,\r\nug_info->maxRetransmission,\r\nug_info->collisionWindow,\r\n&ug_regs->hafdup);\r\nif (ret_val != 0) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Half Duplex initialization parameter too large.",\r\n__func__);\r\nreturn ret_val;\r\n}\r\nifstat = in_be32(&ug_regs->ifstat);\r\nout_be32(&ug_regs->uempr, 0);\r\ninit_hw_statistics_gathering_mode((ug_info->statisticsMode &\r\nUCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE),\r\n0, &uf_regs->upsmr, &ug_regs->uescr);\r\nret_val = ucc_geth_alloc_tx(ugeth);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = ucc_geth_alloc_rx(ugeth);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nugeth->tx_glbl_pram_offset =\r\nqe_muram_alloc(sizeof(struct ucc_geth_tx_global_pram),\r\nUCC_GETH_TX_GLOBAL_PRAM_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->tx_glbl_pram_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_tx_glbl_pram.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_tx_glbl_pram =\r\n(struct ucc_geth_tx_global_pram __iomem *) qe_muram_addr(ugeth->\r\ntx_glbl_pram_offset);\r\nmemset_io((void __iomem *)ugeth->p_tx_glbl_pram, 0, sizeof(struct ucc_geth_tx_global_pram));\r\nugeth->thread_dat_tx_offset =\r\nqe_muram_alloc(numThreadsTxNumerical *\r\nsizeof(struct ucc_geth_thread_data_tx) +\r\n32 * (numThreadsTxNumerical == 1),\r\nUCC_GETH_THREAD_DATA_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->thread_dat_tx_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_thread_data_tx.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_thread_data_tx =\r\n(struct ucc_geth_thread_data_tx __iomem *) qe_muram_addr(ugeth->\r\nthread_dat_tx_offset);\r\nout_be32(&ugeth->p_tx_glbl_pram->tqptr, ugeth->thread_dat_tx_offset);\r\nfor (i = 0; i < UCC_GETH_TX_VTAG_TABLE_ENTRY_MAX; i++)\r\nout_be32(&ugeth->p_tx_glbl_pram->vtagtable[i],\r\nug_info->vtagtable[i]);\r\nfor (i = 0; i < TX_IP_OFFSET_ENTRY_MAX; i++)\r\nout_8(&ugeth->p_tx_glbl_pram->iphoffset[i],\r\nug_info->iphoffset[i]);\r\nugeth->send_q_mem_reg_offset =\r\nqe_muram_alloc(ug_info->numQueuesTx *\r\nsizeof(struct ucc_geth_send_queue_qd),\r\nUCC_GETH_SEND_QUEUE_QUEUE_DESCRIPTOR_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->send_q_mem_reg_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_send_q_mem_reg.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_send_q_mem_reg =\r\n(struct ucc_geth_send_queue_mem_region __iomem *) qe_muram_addr(ugeth->\r\nsend_q_mem_reg_offset);\r\nout_be32(&ugeth->p_tx_glbl_pram->sqptr, ugeth->send_q_mem_reg_offset);\r\nfor (i = 0; i < ug_info->numQueuesTx; i++) {\r\nendOfRing =\r\nugeth->p_tx_bd_ring[i] + (ug_info->bdRingLenTx[i] -\r\n1) * sizeof(struct qe_bd);\r\nif (ugeth->ug_info->uf_info.bd_mem_part == MEM_PART_SYSTEM) {\r\nout_be32(&ugeth->p_send_q_mem_reg->sqqd[i].bd_ring_base,\r\n(u32) virt_to_phys(ugeth->p_tx_bd_ring[i]));\r\nout_be32(&ugeth->p_send_q_mem_reg->sqqd[i].\r\nlast_bd_completed_address,\r\n(u32) virt_to_phys(endOfRing));\r\n} else if (ugeth->ug_info->uf_info.bd_mem_part ==\r\nMEM_PART_MURAM) {\r\nout_be32(&ugeth->p_send_q_mem_reg->sqqd[i].bd_ring_base,\r\n(u32) immrbar_virt_to_phys(ugeth->\r\np_tx_bd_ring[i]));\r\nout_be32(&ugeth->p_send_q_mem_reg->sqqd[i].\r\nlast_bd_completed_address,\r\n(u32) immrbar_virt_to_phys(endOfRing));\r\n}\r\n}\r\nif (ug_info->numQueuesTx > 1) {\r\nugeth->scheduler_offset =\r\nqe_muram_alloc(sizeof(struct ucc_geth_scheduler),\r\nUCC_GETH_SCHEDULER_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->scheduler_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_scheduler.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_scheduler =\r\n(struct ucc_geth_scheduler __iomem *) qe_muram_addr(ugeth->\r\nscheduler_offset);\r\nout_be32(&ugeth->p_tx_glbl_pram->schedulerbasepointer,\r\nugeth->scheduler_offset);\r\nmemset_io((void __iomem *)ugeth->p_scheduler, 0, sizeof(struct ucc_geth_scheduler));\r\nout_be32(&ugeth->p_scheduler->mblinterval,\r\nug_info->mblinterval);\r\nout_be16(&ugeth->p_scheduler->nortsrbytetime,\r\nug_info->nortsrbytetime);\r\nout_8(&ugeth->p_scheduler->fracsiz, ug_info->fracsiz);\r\nout_8(&ugeth->p_scheduler->strictpriorityq,\r\nug_info->strictpriorityq);\r\nout_8(&ugeth->p_scheduler->txasap, ug_info->txasap);\r\nout_8(&ugeth->p_scheduler->extrabw, ug_info->extrabw);\r\nfor (i = 0; i < NUM_TX_QUEUES; i++)\r\nout_8(&ugeth->p_scheduler->weightfactor[i],\r\nug_info->weightfactor[i]);\r\nugeth->p_cpucount[0] = &(ugeth->p_scheduler->cpucount0);\r\nugeth->p_cpucount[1] = &(ugeth->p_scheduler->cpucount1);\r\nugeth->p_cpucount[2] = &(ugeth->p_scheduler->cpucount2);\r\nugeth->p_cpucount[3] = &(ugeth->p_scheduler->cpucount3);\r\nugeth->p_cpucount[4] = &(ugeth->p_scheduler->cpucount4);\r\nugeth->p_cpucount[5] = &(ugeth->p_scheduler->cpucount5);\r\nugeth->p_cpucount[6] = &(ugeth->p_scheduler->cpucount6);\r\nugeth->p_cpucount[7] = &(ugeth->p_scheduler->cpucount7);\r\n}\r\nif (ug_info->\r\nstatisticsMode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {\r\nugeth->tx_fw_statistics_pram_offset =\r\nqe_muram_alloc(sizeof\r\n(struct ucc_geth_tx_firmware_statistics_pram),\r\nUCC_GETH_TX_STATISTICS_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->tx_fw_statistics_pram_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for"\r\n" p_tx_fw_statistics_pram.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_tx_fw_statistics_pram =\r\n(struct ucc_geth_tx_firmware_statistics_pram __iomem *)\r\nqe_muram_addr(ugeth->tx_fw_statistics_pram_offset);\r\nmemset_io((void __iomem *)ugeth->p_tx_fw_statistics_pram,\r\n0, sizeof(struct ucc_geth_tx_firmware_statistics_pram));\r\n}\r\nif (ug_info->numQueuesTx > 1)\r\ntemoder |= TEMODER_SCHEDULER_ENABLE;\r\nif (ug_info->ipCheckSumGenerate)\r\ntemoder |= TEMODER_IP_CHECKSUM_GENERATE;\r\ntemoder |= ((ug_info->numQueuesTx - 1) << TEMODER_NUM_OF_QUEUES_SHIFT);\r\nout_be16(&ugeth->p_tx_glbl_pram->temoder, temoder);\r\ntest = in_be16(&ugeth->p_tx_glbl_pram->temoder);\r\nfunction_code = UCC_BMR_BO_BE | UCC_BMR_GBL;\r\nout_be32(&ugeth->p_tx_glbl_pram->tstate, ((u32) function_code) << 24);\r\nugeth->rx_glbl_pram_offset =\r\nqe_muram_alloc(sizeof(struct ucc_geth_rx_global_pram),\r\nUCC_GETH_RX_GLOBAL_PRAM_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->rx_glbl_pram_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_rx_glbl_pram.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_rx_glbl_pram =\r\n(struct ucc_geth_rx_global_pram __iomem *) qe_muram_addr(ugeth->\r\nrx_glbl_pram_offset);\r\nmemset_io((void __iomem *)ugeth->p_rx_glbl_pram, 0, sizeof(struct ucc_geth_rx_global_pram));\r\nugeth->thread_dat_rx_offset =\r\nqe_muram_alloc(numThreadsRxNumerical *\r\nsizeof(struct ucc_geth_thread_data_rx),\r\nUCC_GETH_THREAD_DATA_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->thread_dat_rx_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_thread_data_rx.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_thread_data_rx =\r\n(struct ucc_geth_thread_data_rx __iomem *) qe_muram_addr(ugeth->\r\nthread_dat_rx_offset);\r\nout_be32(&ugeth->p_rx_glbl_pram->rqptr, ugeth->thread_dat_rx_offset);\r\nout_be16(&ugeth->p_rx_glbl_pram->typeorlen, ug_info->typeorlen);\r\nif (ug_info->\r\nstatisticsMode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX) {\r\nugeth->rx_fw_statistics_pram_offset =\r\nqe_muram_alloc(sizeof\r\n(struct ucc_geth_rx_firmware_statistics_pram),\r\nUCC_GETH_RX_STATISTICS_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->rx_fw_statistics_pram_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for"\r\n" p_rx_fw_statistics_pram.", __func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_rx_fw_statistics_pram =\r\n(struct ucc_geth_rx_firmware_statistics_pram __iomem *)\r\nqe_muram_addr(ugeth->rx_fw_statistics_pram_offset);\r\nmemset_io((void __iomem *)ugeth->p_rx_fw_statistics_pram, 0,\r\nsizeof(struct ucc_geth_rx_firmware_statistics_pram));\r\n}\r\nugeth->rx_irq_coalescing_tbl_offset =\r\nqe_muram_alloc(ug_info->numQueuesRx *\r\nsizeof(struct ucc_geth_rx_interrupt_coalescing_entry)\r\n+ 4, UCC_GETH_RX_INTERRUPT_COALESCING_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->rx_irq_coalescing_tbl_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for"\r\n" p_rx_irq_coalescing_tbl.", __func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_rx_irq_coalescing_tbl =\r\n(struct ucc_geth_rx_interrupt_coalescing_table __iomem *)\r\nqe_muram_addr(ugeth->rx_irq_coalescing_tbl_offset);\r\nout_be32(&ugeth->p_rx_glbl_pram->intcoalescingptr,\r\nugeth->rx_irq_coalescing_tbl_offset);\r\nfor (i = 0; i < ug_info->numQueuesRx; i++) {\r\nout_be32(&ugeth->p_rx_irq_coalescing_tbl->coalescingentry[i].\r\ninterruptcoalescingmaxvalue,\r\nug_info->interruptcoalescingmaxvalue[i]);\r\nout_be32(&ugeth->p_rx_irq_coalescing_tbl->coalescingentry[i].\r\ninterruptcoalescingcounter,\r\nug_info->interruptcoalescingmaxvalue[i]);\r\n}\r\ninit_max_rx_buff_len(uf_info->max_rx_buf_length,\r\n&ugeth->p_rx_glbl_pram->mrblr);\r\nout_be16(&ugeth->p_rx_glbl_pram->mflr, ug_info->maxFrameLength);\r\ninit_min_frame_len(ug_info->minFrameLength,\r\n&ugeth->p_rx_glbl_pram->minflr,\r\n&ugeth->p_rx_glbl_pram->mrblr);\r\nout_be16(&ugeth->p_rx_glbl_pram->maxd1, ug_info->maxD1Length);\r\nout_be16(&ugeth->p_rx_glbl_pram->maxd2, ug_info->maxD2Length);\r\nl2qt = 0;\r\nfor (i = 0; i < UCC_GETH_VLAN_PRIORITY_MAX; i++)\r\nl2qt |= (ug_info->l2qt[i] << (28 - 4 * i));\r\nout_be32(&ugeth->p_rx_glbl_pram->l2qt, l2qt);\r\nfor (j = 0; j < UCC_GETH_IP_PRIORITY_MAX; j += 8) {\r\nl3qt = 0;\r\nfor (i = 0; i < 8; i++)\r\nl3qt |= (ug_info->l3qt[j + i] << (28 - 4 * i));\r\nout_be32(&ugeth->p_rx_glbl_pram->l3qt[j/8], l3qt);\r\n}\r\nout_be16(&ugeth->p_rx_glbl_pram->vlantype, ug_info->vlantype);\r\nout_be16(&ugeth->p_rx_glbl_pram->vlantci, ug_info->vlantci);\r\nout_be32(&ugeth->p_rx_glbl_pram->ecamptr, ug_info->ecamptr);\r\nugeth->rx_bd_qs_tbl_offset =\r\nqe_muram_alloc(ug_info->numQueuesRx *\r\n(sizeof(struct ucc_geth_rx_bd_queues_entry) +\r\nsizeof(struct ucc_geth_rx_prefetched_bds)),\r\nUCC_GETH_RX_BD_QUEUES_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->rx_bd_qs_tbl_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_rx_bd_qs_tbl.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_rx_bd_qs_tbl =\r\n(struct ucc_geth_rx_bd_queues_entry __iomem *) qe_muram_addr(ugeth->\r\nrx_bd_qs_tbl_offset);\r\nout_be32(&ugeth->p_rx_glbl_pram->rbdqptr, ugeth->rx_bd_qs_tbl_offset);\r\nmemset_io((void __iomem *)ugeth->p_rx_bd_qs_tbl,\r\n0,\r\nug_info->numQueuesRx * (sizeof(struct ucc_geth_rx_bd_queues_entry) +\r\nsizeof(struct ucc_geth_rx_prefetched_bds)));\r\nfor (i = 0; i < ug_info->numQueuesRx; i++) {\r\nif (ugeth->ug_info->uf_info.bd_mem_part == MEM_PART_SYSTEM) {\r\nout_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,\r\n(u32) virt_to_phys(ugeth->p_rx_bd_ring[i]));\r\n} else if (ugeth->ug_info->uf_info.bd_mem_part ==\r\nMEM_PART_MURAM) {\r\nout_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,\r\n(u32) immrbar_virt_to_phys(ugeth->\r\np_rx_bd_ring[i]));\r\n}\r\n}\r\nif (ugeth->rx_extended_features)\r\nremoder |= REMODER_RX_EXTENDED_FEATURES;\r\nif (ug_info->rxExtendedFiltering)\r\nremoder |= REMODER_RX_EXTENDED_FILTERING;\r\nif (ug_info->dynamicMaxFrameLength)\r\nremoder |= REMODER_DYNAMIC_MAX_FRAME_LENGTH;\r\nif (ug_info->dynamicMinFrameLength)\r\nremoder |= REMODER_DYNAMIC_MIN_FRAME_LENGTH;\r\nremoder |=\r\nug_info->vlanOperationTagged << REMODER_VLAN_OPERATION_TAGGED_SHIFT;\r\nremoder |=\r\nug_info->\r\nvlanOperationNonTagged << REMODER_VLAN_OPERATION_NON_TAGGED_SHIFT;\r\nremoder |= ug_info->rxQoSMode << REMODER_RX_QOS_MODE_SHIFT;\r\nremoder |= ((ug_info->numQueuesRx - 1) << REMODER_NUM_OF_QUEUES_SHIFT);\r\nif (ug_info->ipCheckSumCheck)\r\nremoder |= REMODER_IP_CHECKSUM_CHECK;\r\nif (ug_info->ipAddressAlignment)\r\nremoder |= REMODER_IP_ADDRESS_ALIGNMENT;\r\nout_be32(&ugeth->p_rx_glbl_pram->remoder, remoder);\r\ninit_firmware_statistics_gathering_mode((ug_info->\r\nstatisticsMode &\r\nUCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX),\r\n(ug_info->statisticsMode &\r\nUCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX),\r\n&ugeth->p_tx_glbl_pram->txrmonbaseptr,\r\nugeth->tx_fw_statistics_pram_offset,\r\n&ugeth->p_rx_glbl_pram->rxrmonbaseptr,\r\nugeth->rx_fw_statistics_pram_offset,\r\n&ugeth->p_tx_glbl_pram->temoder,\r\n&ugeth->p_rx_glbl_pram->remoder);\r\nout_8(&ugeth->p_rx_glbl_pram->rstate, function_code);\r\nif (ug_info->rxExtendedFiltering) {\r\nif (!ug_info->extendedFilteringChainPointer) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Null Extended Filtering Chain Pointer.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nugeth->exf_glbl_param_offset =\r\nqe_muram_alloc(sizeof(struct ucc_geth_exf_global_pram),\r\nUCC_GETH_RX_EXTENDED_FILTERING_GLOBAL_PARAMETERS_ALIGNMENT);\r\nif (IS_ERR_VALUE(ugeth->exf_glbl_param_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for"\r\n" p_exf_glbl_param.", __func__);\r\nreturn -ENOMEM;\r\n}\r\nugeth->p_exf_glbl_param =\r\n(struct ucc_geth_exf_global_pram __iomem *) qe_muram_addr(ugeth->\r\nexf_glbl_param_offset);\r\nout_be32(&ugeth->p_rx_glbl_pram->exfGlobalParam,\r\nugeth->exf_glbl_param_offset);\r\nout_be32(&ugeth->p_exf_glbl_param->l2pcdptr,\r\n(u32) ug_info->extendedFilteringChainPointer);\r\n} else {\r\nfor (j = 0; j < NUM_OF_PADDRS; j++)\r\nugeth_82xx_filtering_clear_addr_in_paddr(ugeth, (u8) j);\r\np_82xx_addr_filt =\r\n(struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->\r\np_rx_glbl_pram->addressfiltering;\r\nugeth_82xx_filtering_clear_all_addr_in_hash(ugeth,\r\nENET_ADDR_TYPE_GROUP);\r\nugeth_82xx_filtering_clear_all_addr_in_hash(ugeth,\r\nENET_ADDR_TYPE_INDIVIDUAL);\r\n}\r\ncommand = QE_INIT_TX_RX;\r\nif (!(ugeth->p_init_enet_param_shadow =\r\nkmalloc(sizeof(struct ucc_geth_init_pram), GFP_KERNEL))) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate memory for"\r\n" p_UccInitEnetParamShadows.", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset((char *)ugeth->p_init_enet_param_shadow,\r\n0, sizeof(struct ucc_geth_init_pram));\r\nugeth->p_init_enet_param_shadow->resinit1 =\r\nENET_INIT_PARAM_MAGIC_RES_INIT1;\r\nugeth->p_init_enet_param_shadow->resinit2 =\r\nENET_INIT_PARAM_MAGIC_RES_INIT2;\r\nugeth->p_init_enet_param_shadow->resinit3 =\r\nENET_INIT_PARAM_MAGIC_RES_INIT3;\r\nugeth->p_init_enet_param_shadow->resinit4 =\r\nENET_INIT_PARAM_MAGIC_RES_INIT4;\r\nugeth->p_init_enet_param_shadow->resinit5 =\r\nENET_INIT_PARAM_MAGIC_RES_INIT5;\r\nugeth->p_init_enet_param_shadow->rgftgfrxglobal |=\r\n((u32) ug_info->numThreadsRx) << ENET_INIT_PARAM_RGF_SHIFT;\r\nugeth->p_init_enet_param_shadow->rgftgfrxglobal |=\r\n((u32) ug_info->numThreadsTx) << ENET_INIT_PARAM_TGF_SHIFT;\r\nugeth->p_init_enet_param_shadow->rgftgfrxglobal |=\r\nugeth->rx_glbl_pram_offset | ug_info->riscRx;\r\nif ((ug_info->largestexternallookupkeysize !=\r\nQE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_NONE) &&\r\n(ug_info->largestexternallookupkeysize !=\r\nQE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_8_BYTES) &&\r\n(ug_info->largestexternallookupkeysize !=\r\nQE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_16_BYTES)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Invalid largest External Lookup Key Size.",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nugeth->p_init_enet_param_shadow->largestexternallookupkeysize =\r\nug_info->largestexternallookupkeysize;\r\nsize = sizeof(struct ucc_geth_thread_rx_pram);\r\nif (ug_info->rxExtendedFiltering) {\r\nsize += THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING;\r\nif (ug_info->largestexternallookupkeysize ==\r\nQE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES)\r\nsize +=\r\nTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8;\r\nif (ug_info->largestexternallookupkeysize ==\r\nQE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES)\r\nsize +=\r\nTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16;\r\n}\r\nif ((ret_val = fill_init_enet_entries(ugeth, &(ugeth->\r\np_init_enet_param_shadow->rxthread[0]),\r\n(u8) (numThreadsRxNumerical + 1)\r\n, size, UCC_GETH_THREAD_RX_PRAM_ALIGNMENT,\r\nug_info->riscRx, 1)) != 0) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Can not fill p_init_enet_param_shadow.",\r\n__func__);\r\nreturn ret_val;\r\n}\r\nugeth->p_init_enet_param_shadow->txglobal =\r\nugeth->tx_glbl_pram_offset | ug_info->riscTx;\r\nif ((ret_val =\r\nfill_init_enet_entries(ugeth,\r\n&(ugeth->p_init_enet_param_shadow->\r\ntxthread[0]), numThreadsTxNumerical,\r\nsizeof(struct ucc_geth_thread_tx_pram),\r\nUCC_GETH_THREAD_TX_PRAM_ALIGNMENT,\r\nug_info->riscTx, 0)) != 0) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Can not fill p_init_enet_param_shadow.",\r\n__func__);\r\nreturn ret_val;\r\n}\r\nfor (i = 0; i < ug_info->numQueuesRx; i++) {\r\nif ((ret_val = rx_bd_buffer_set(ugeth, (u8) i)) != 0) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Can not fill Rx bds with buffers.",\r\n__func__);\r\nreturn ret_val;\r\n}\r\n}\r\ninit_enet_pram_offset = qe_muram_alloc(sizeof(struct ucc_geth_init_pram), 4);\r\nif (IS_ERR_VALUE(init_enet_pram_offset)) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err\r\n("%s: Can not allocate DPRAM memory for p_init_enet_pram.",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\np_init_enet_pram =\r\n(struct ucc_geth_init_pram __iomem *) qe_muram_addr(init_enet_pram_offset);\r\nout_8(&p_init_enet_pram->resinit1,\r\nugeth->p_init_enet_param_shadow->resinit1);\r\nout_8(&p_init_enet_pram->resinit2,\r\nugeth->p_init_enet_param_shadow->resinit2);\r\nout_8(&p_init_enet_pram->resinit3,\r\nugeth->p_init_enet_param_shadow->resinit3);\r\nout_8(&p_init_enet_pram->resinit4,\r\nugeth->p_init_enet_param_shadow->resinit4);\r\nout_be16(&p_init_enet_pram->resinit5,\r\nugeth->p_init_enet_param_shadow->resinit5);\r\nout_8(&p_init_enet_pram->largestexternallookupkeysize,\r\nugeth->p_init_enet_param_shadow->largestexternallookupkeysize);\r\nout_be32(&p_init_enet_pram->rgftgfrxglobal,\r\nugeth->p_init_enet_param_shadow->rgftgfrxglobal);\r\nfor (i = 0; i < ENET_INIT_PARAM_MAX_ENTRIES_RX; i++)\r\nout_be32(&p_init_enet_pram->rxthread[i],\r\nugeth->p_init_enet_param_shadow->rxthread[i]);\r\nout_be32(&p_init_enet_pram->txglobal,\r\nugeth->p_init_enet_param_shadow->txglobal);\r\nfor (i = 0; i < ENET_INIT_PARAM_MAX_ENTRIES_TX; i++)\r\nout_be32(&p_init_enet_pram->txthread[i],\r\nugeth->p_init_enet_param_shadow->txthread[i]);\r\ncecr_subblock =\r\nucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\r\nqe_issue_cmd(command, cecr_subblock, QE_CR_PROTOCOL_ETHERNET,\r\ninit_enet_pram_offset);\r\nqe_muram_free(init_enet_pram_offset);\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\n#ifdef CONFIG_UGETH_TX_ON_DEMAND\r\nstruct ucc_fast_private *uccf;\r\n#endif\r\nu8 __iomem *bd;\r\nu32 bd_status;\r\nu8 txQ = 0;\r\nunsigned long flags;\r\nugeth_vdbg("%s: IN", __func__);\r\nspin_lock_irqsave(&ugeth->lock, flags);\r\ndev->stats.tx_bytes += skb->len;\r\nbd = ugeth->txBd[txQ];\r\nbd_status = in_be32((u32 __iomem *)bd);\r\nugeth->tx_skbuff[txQ][ugeth->skb_curtx[txQ]] = skb;\r\nugeth->skb_curtx[txQ] =\r\n(ugeth->skb_curtx[txQ] +\r\n1) & TX_RING_MOD_MASK(ugeth->ug_info->bdRingLenTx[txQ]);\r\nout_be32(&((struct qe_bd __iomem *)bd)->buf,\r\ndma_map_single(ugeth->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE));\r\nbd_status = (bd_status & T_W) | T_R | T_I | T_L | skb->len;\r\nout_be32((u32 __iomem *)bd, bd_status);\r\nif (!(bd_status & T_W))\r\nbd += sizeof(struct qe_bd);\r\nelse\r\nbd = ugeth->p_tx_bd_ring[txQ];\r\nif (bd == ugeth->confBd[txQ]) {\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\n}\r\nugeth->txBd[txQ] = bd;\r\nskb_tx_timestamp(skb);\r\nif (ugeth->p_scheduler) {\r\nugeth->cpucount[txQ]++;\r\nout_be16(ugeth->p_cpucount[txQ], ugeth->cpucount[txQ]);\r\n}\r\n#ifdef CONFIG_UGETH_TX_ON_DEMAND\r\nuccf = ugeth->uccf;\r\nout_be16(uccf->p_utodr, UCC_FAST_TOD);\r\n#endif\r\nspin_unlock_irqrestore(&ugeth->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ucc_geth_rx(struct ucc_geth_private *ugeth, u8 rxQ, int rx_work_limit)\r\n{\r\nstruct sk_buff *skb;\r\nu8 __iomem *bd;\r\nu16 length, howmany = 0;\r\nu32 bd_status;\r\nu8 *bdBuffer;\r\nstruct net_device *dev;\r\nugeth_vdbg("%s: IN", __func__);\r\ndev = ugeth->ndev;\r\nbd = ugeth->rxBd[rxQ];\r\nbd_status = in_be32((u32 __iomem *)bd);\r\nwhile (!((bd_status & (R_E)) || (--rx_work_limit < 0))) {\r\nbdBuffer = (u8 *) in_be32(&((struct qe_bd __iomem *)bd)->buf);\r\nlength = (u16) ((bd_status & BD_LENGTH_MASK) - 4);\r\nskb = ugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]];\r\nif (!skb ||\r\n(!(bd_status & (R_F | R_L))) ||\r\n(bd_status & R_ERRORS_FATAL)) {\r\nif (netif_msg_rx_err(ugeth))\r\nugeth_err("%s, %d: ERROR!!! skb - 0x%08x",\r\n__func__, __LINE__, (u32) skb);\r\ndev_kfree_skb(skb);\r\nugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]] = NULL;\r\ndev->stats.rx_dropped++;\r\n} else {\r\ndev->stats.rx_packets++;\r\nhowmany++;\r\nskb_put(skb, length);\r\nskb->protocol = eth_type_trans(skb, ugeth->ndev);\r\ndev->stats.rx_bytes += length;\r\nnetif_receive_skb(skb);\r\n}\r\nskb = get_new_skb(ugeth, bd);\r\nif (!skb) {\r\nif (netif_msg_rx_err(ugeth))\r\nugeth_warn("%s: No Rx Data Buffer", __func__);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]] = skb;\r\nugeth->skb_currx[rxQ] =\r\n(ugeth->skb_currx[rxQ] +\r\n1) & RX_RING_MOD_MASK(ugeth->ug_info->bdRingLenRx[rxQ]);\r\nif (bd_status & R_W)\r\nbd = ugeth->p_rx_bd_ring[rxQ];\r\nelse\r\nbd += sizeof(struct qe_bd);\r\nbd_status = in_be32((u32 __iomem *)bd);\r\n}\r\nugeth->rxBd[rxQ] = bd;\r\nreturn howmany;\r\n}\r\nstatic int ucc_geth_tx(struct net_device *dev, u8 txQ)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nu8 __iomem *bd;\r\nu32 bd_status;\r\nbd = ugeth->confBd[txQ];\r\nbd_status = in_be32((u32 __iomem *)bd);\r\nwhile ((bd_status & T_R) == 0) {\r\nstruct sk_buff *skb;\r\nskb = ugeth->tx_skbuff[txQ][ugeth->skb_dirtytx[txQ]];\r\nif (!skb)\r\nbreak;\r\ndev->stats.tx_packets++;\r\ndev_kfree_skb(skb);\r\nugeth->tx_skbuff[txQ][ugeth->skb_dirtytx[txQ]] = NULL;\r\nugeth->skb_dirtytx[txQ] =\r\n(ugeth->skb_dirtytx[txQ] +\r\n1) & TX_RING_MOD_MASK(ugeth->ug_info->bdRingLenTx[txQ]);\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nif (!(bd_status & T_W))\r\nbd += sizeof(struct qe_bd);\r\nelse\r\nbd = ugeth->p_tx_bd_ring[txQ];\r\nbd_status = in_be32((u32 __iomem *)bd);\r\n}\r\nugeth->confBd[txQ] = bd;\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct ucc_geth_private *ugeth = container_of(napi, struct ucc_geth_private, napi);\r\nstruct ucc_geth_info *ug_info;\r\nint howmany, i;\r\nug_info = ugeth->ug_info;\r\nspin_lock(&ugeth->lock);\r\nfor (i = 0; i < ug_info->numQueuesTx; i++)\r\nucc_geth_tx(ugeth->ndev, i);\r\nspin_unlock(&ugeth->lock);\r\nhowmany = 0;\r\nfor (i = 0; i < ug_info->numQueuesRx; i++)\r\nhowmany += ucc_geth_rx(ugeth, i, budget - howmany);\r\nif (howmany < budget) {\r\nnapi_complete(napi);\r\nsetbits32(ugeth->uccf->p_uccm, UCCE_RX_EVENTS | UCCE_TX_EVENTS);\r\n}\r\nreturn howmany;\r\n}\r\nstatic irqreturn_t ucc_geth_irq_handler(int irq, void *info)\r\n{\r\nstruct net_device *dev = info;\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nstruct ucc_fast_private *uccf;\r\nstruct ucc_geth_info *ug_info;\r\nregister u32 ucce;\r\nregister u32 uccm;\r\nugeth_vdbg("%s: IN", __func__);\r\nuccf = ugeth->uccf;\r\nug_info = ugeth->ug_info;\r\nucce = (u32) in_be32(uccf->p_ucce);\r\nuccm = (u32) in_be32(uccf->p_uccm);\r\nucce &= uccm;\r\nout_be32(uccf->p_ucce, ucce);\r\nif (ucce & (UCCE_RX_EVENTS | UCCE_TX_EVENTS)) {\r\nif (napi_schedule_prep(&ugeth->napi)) {\r\nuccm &= ~(UCCE_RX_EVENTS | UCCE_TX_EVENTS);\r\nout_be32(uccf->p_uccm, uccm);\r\n__napi_schedule(&ugeth->napi);\r\n}\r\n}\r\nif (ucce & UCCE_OTHER) {\r\nif (ucce & UCC_GETH_UCCE_BSY)\r\ndev->stats.rx_errors++;\r\nif (ucce & UCC_GETH_UCCE_TXE)\r\ndev->stats.tx_errors++;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ucc_netpoll(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nint irq = ugeth->ug_info->uf_info.irq;\r\ndisable_irq(irq);\r\nucc_geth_irq_handler(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic int ucc_geth_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nspin_lock_irq(&ugeth->lock);\r\ninit_mac_station_addr_regs(dev->dev_addr[0],\r\ndev->dev_addr[1],\r\ndev->dev_addr[2],\r\ndev->dev_addr[3],\r\ndev->dev_addr[4],\r\ndev->dev_addr[5],\r\n&ugeth->ug_regs->macstnaddr1,\r\n&ugeth->ug_regs->macstnaddr2);\r\nspin_unlock_irq(&ugeth->lock);\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_init_mac(struct ucc_geth_private *ugeth)\r\n{\r\nstruct net_device *dev = ugeth->ndev;\r\nint err;\r\nerr = ucc_struct_init(ugeth);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot configure internal struct, "\r\n"aborting.", dev->name);\r\ngoto err;\r\n}\r\nerr = ucc_geth_startup(ugeth);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot configure net device, aborting.",\r\ndev->name);\r\ngoto err;\r\n}\r\nerr = adjust_enet_interface(ugeth);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot configure net device, aborting.",\r\ndev->name);\r\ngoto err;\r\n}\r\ninit_mac_station_addr_regs(dev->dev_addr[0],\r\ndev->dev_addr[1],\r\ndev->dev_addr[2],\r\ndev->dev_addr[3],\r\ndev->dev_addr[4],\r\ndev->dev_addr[5],\r\n&ugeth->ug_regs->macstnaddr1,\r\n&ugeth->ug_regs->macstnaddr2);\r\nerr = ugeth_enable(ugeth, COMM_DIR_RX_AND_TX);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot enable net device, aborting.", dev->name);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nucc_geth_stop(ugeth);\r\nreturn err;\r\n}\r\nstatic int ucc_geth_open(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nint err;\r\nugeth_vdbg("%s: IN", __func__);\r\nif (dev->dev_addr[0] & ENET_GROUP_ADDR) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Multicast address used for station "\r\n"address - is this what you wanted?",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nerr = init_phy(dev);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot initialize PHY, aborting.",\r\ndev->name);\r\nreturn err;\r\n}\r\nerr = ucc_geth_init_mac(ugeth);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot initialize MAC, aborting.",\r\ndev->name);\r\ngoto err;\r\n}\r\nerr = request_irq(ugeth->ug_info->uf_info.irq, ucc_geth_irq_handler,\r\n0, "UCC Geth", dev);\r\nif (err) {\r\nif (netif_msg_ifup(ugeth))\r\nugeth_err("%s: Cannot get IRQ for net device, aborting.",\r\ndev->name);\r\ngoto err;\r\n}\r\nphy_start(ugeth->phydev);\r\nnapi_enable(&ugeth->napi);\r\nnetif_start_queue(dev);\r\ndevice_set_wakeup_capable(&dev->dev,\r\nqe_alive_during_sleep() || ugeth->phydev->irq);\r\ndevice_set_wakeup_enable(&dev->dev, ugeth->wol_en);\r\nreturn err;\r\nerr:\r\nucc_geth_stop(ugeth);\r\nreturn err;\r\n}\r\nstatic int ucc_geth_close(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nugeth_vdbg("%s: IN", __func__);\r\nnapi_disable(&ugeth->napi);\r\ncancel_work_sync(&ugeth->timeout_work);\r\nucc_geth_stop(ugeth);\r\nphy_disconnect(ugeth->phydev);\r\nugeth->phydev = NULL;\r\nfree_irq(ugeth->ug_info->uf_info.irq, ugeth->ndev);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void ucc_geth_timeout_work(struct work_struct *work)\r\n{\r\nstruct ucc_geth_private *ugeth;\r\nstruct net_device *dev;\r\nugeth = container_of(work, struct ucc_geth_private, timeout_work);\r\ndev = ugeth->ndev;\r\nugeth_vdbg("%s: IN", __func__);\r\ndev->stats.tx_errors++;\r\nugeth_dump_regs(ugeth);\r\nif (dev->flags & IFF_UP) {\r\nnetif_tx_stop_all_queues(dev);\r\nucc_geth_stop(ugeth);\r\nucc_geth_init_mac(ugeth);\r\nphy_start(ugeth->phydev);\r\nnetif_tx_start_all_queues(dev);\r\n}\r\nnetif_tx_schedule_all(dev);\r\n}\r\nstatic void ucc_geth_timeout(struct net_device *dev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nschedule_work(&ugeth->timeout_work);\r\n}\r\nstatic int ucc_geth_suspend(struct platform_device *ofdev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(&ofdev->dev);\r\nstruct ucc_geth_private *ugeth = netdev_priv(ndev);\r\nif (!netif_running(ndev))\r\nreturn 0;\r\nnetif_device_detach(ndev);\r\nnapi_disable(&ugeth->napi);\r\nugeth_disable(ugeth, COMM_DIR_RX_AND_TX);\r\nif (ugeth->wol_en & WAKE_MAGIC) {\r\nsetbits32(ugeth->uccf->p_uccm, UCC_GETH_UCCE_MPD);\r\nsetbits32(&ugeth->ug_regs->maccfg2, MACCFG2_MPE);\r\nucc_fast_enable(ugeth->uccf, COMM_DIR_RX_AND_TX);\r\n} else if (!(ugeth->wol_en & WAKE_PHY)) {\r\nphy_stop(ugeth->phydev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_resume(struct platform_device *ofdev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(&ofdev->dev);\r\nstruct ucc_geth_private *ugeth = netdev_priv(ndev);\r\nint err;\r\nif (!netif_running(ndev))\r\nreturn 0;\r\nif (qe_alive_during_sleep()) {\r\nif (ugeth->wol_en & WAKE_MAGIC) {\r\nucc_fast_disable(ugeth->uccf, COMM_DIR_RX_AND_TX);\r\nclrbits32(&ugeth->ug_regs->maccfg2, MACCFG2_MPE);\r\nclrbits32(ugeth->uccf->p_uccm, UCC_GETH_UCCE_MPD);\r\n}\r\nugeth_enable(ugeth, COMM_DIR_RX_AND_TX);\r\n} else {\r\nucc_geth_memclean(ugeth);\r\nerr = ucc_geth_init_mac(ugeth);\r\nif (err) {\r\nugeth_err("%s: Cannot initialize MAC, aborting.",\r\nndev->name);\r\nreturn err;\r\n}\r\n}\r\nugeth->oldlink = 0;\r\nugeth->oldspeed = 0;\r\nugeth->oldduplex = -1;\r\nphy_stop(ugeth->phydev);\r\nphy_start(ugeth->phydev);\r\nnapi_enable(&ugeth->napi);\r\nnetif_device_attach(ndev);\r\nreturn 0;\r\n}\r\nstatic phy_interface_t to_phy_interface(const char *phy_connection_type)\r\n{\r\nif (strcasecmp(phy_connection_type, "mii") == 0)\r\nreturn PHY_INTERFACE_MODE_MII;\r\nif (strcasecmp(phy_connection_type, "gmii") == 0)\r\nreturn PHY_INTERFACE_MODE_GMII;\r\nif (strcasecmp(phy_connection_type, "tbi") == 0)\r\nreturn PHY_INTERFACE_MODE_TBI;\r\nif (strcasecmp(phy_connection_type, "rmii") == 0)\r\nreturn PHY_INTERFACE_MODE_RMII;\r\nif (strcasecmp(phy_connection_type, "rgmii") == 0)\r\nreturn PHY_INTERFACE_MODE_RGMII;\r\nif (strcasecmp(phy_connection_type, "rgmii-id") == 0)\r\nreturn PHY_INTERFACE_MODE_RGMII_ID;\r\nif (strcasecmp(phy_connection_type, "rgmii-txid") == 0)\r\nreturn PHY_INTERFACE_MODE_RGMII_TXID;\r\nif (strcasecmp(phy_connection_type, "rgmii-rxid") == 0)\r\nreturn PHY_INTERFACE_MODE_RGMII_RXID;\r\nif (strcasecmp(phy_connection_type, "rtbi") == 0)\r\nreturn PHY_INTERFACE_MODE_RTBI;\r\nif (strcasecmp(phy_connection_type, "sgmii") == 0)\r\nreturn PHY_INTERFACE_MODE_SGMII;\r\nreturn PHY_INTERFACE_MODE_MII;\r\n}\r\nstatic int ucc_geth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!ugeth->phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(ugeth->phydev, rq, cmd);\r\n}\r\nstatic int ucc_geth_probe(struct platform_device* ofdev)\r\n{\r\nstruct device *device = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct net_device *dev = NULL;\r\nstruct ucc_geth_private *ugeth = NULL;\r\nstruct ucc_geth_info *ug_info;\r\nstruct resource res;\r\nint err, ucc_num, max_speed = 0;\r\nconst unsigned int *prop;\r\nconst char *sprop;\r\nconst void *mac_addr;\r\nphy_interface_t phy_interface;\r\nstatic const int enet_to_speed[] = {\r\nSPEED_10, SPEED_10, SPEED_10,\r\nSPEED_100, SPEED_100, SPEED_100,\r\nSPEED_1000, SPEED_1000, SPEED_1000, SPEED_1000,\r\n};\r\nstatic const phy_interface_t enet_to_phy_interface[] = {\r\nPHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_RMII,\r\nPHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_MII,\r\nPHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII,\r\nPHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII,\r\nPHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_RTBI,\r\nPHY_INTERFACE_MODE_SGMII,\r\n};\r\nugeth_vdbg("%s: IN", __func__);\r\nprop = of_get_property(np, "cell-index", NULL);\r\nif (!prop) {\r\nprop = of_get_property(np, "device-id", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\n}\r\nucc_num = *prop - 1;\r\nif ((ucc_num < 0) || (ucc_num > 7))\r\nreturn -ENODEV;\r\nug_info = &ugeth_info[ucc_num];\r\nif (ug_info == NULL) {\r\nif (netif_msg_probe(&debug))\r\nugeth_err("%s: [%d] Missing additional data!",\r\n__func__, ucc_num);\r\nreturn -ENODEV;\r\n}\r\nug_info->uf_info.ucc_num = ucc_num;\r\nsprop = of_get_property(np, "rx-clock-name", NULL);\r\nif (sprop) {\r\nug_info->uf_info.rx_clock = qe_clock_source(sprop);\r\nif ((ug_info->uf_info.rx_clock < QE_CLK_NONE) ||\r\n(ug_info->uf_info.rx_clock > QE_CLK24)) {\r\nprintk(KERN_ERR\r\n"ucc_geth: invalid rx-clock-name property\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nprop = of_get_property(np, "rx-clock", NULL);\r\nif (!prop) {\r\nprintk(KERN_ERR\r\n"ucc_geth: missing rx-clock-name property\n");\r\nreturn -EINVAL;\r\n}\r\nif ((*prop < QE_CLK_NONE) || (*prop > QE_CLK24)) {\r\nprintk(KERN_ERR\r\n"ucc_geth: invalid rx-clock propperty\n");\r\nreturn -EINVAL;\r\n}\r\nug_info->uf_info.rx_clock = *prop;\r\n}\r\nsprop = of_get_property(np, "tx-clock-name", NULL);\r\nif (sprop) {\r\nug_info->uf_info.tx_clock = qe_clock_source(sprop);\r\nif ((ug_info->uf_info.tx_clock < QE_CLK_NONE) ||\r\n(ug_info->uf_info.tx_clock > QE_CLK24)) {\r\nprintk(KERN_ERR\r\n"ucc_geth: invalid tx-clock-name property\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nprop = of_get_property(np, "tx-clock", NULL);\r\nif (!prop) {\r\nprintk(KERN_ERR\r\n"ucc_geth: missing tx-clock-name property\n");\r\nreturn -EINVAL;\r\n}\r\nif ((*prop < QE_CLK_NONE) || (*prop > QE_CLK24)) {\r\nprintk(KERN_ERR\r\n"ucc_geth: invalid tx-clock property\n");\r\nreturn -EINVAL;\r\n}\r\nug_info->uf_info.tx_clock = *prop;\r\n}\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err)\r\nreturn -EINVAL;\r\nug_info->uf_info.regs = res.start;\r\nug_info->uf_info.irq = irq_of_parse_and_map(np, 0);\r\nug_info->phy_node = of_parse_phandle(np, "phy-handle", 0);\r\nug_info->tbi_node = of_parse_phandle(np, "tbi-handle", 0);\r\nprop = of_get_property(np, "phy-connection-type", NULL);\r\nif (!prop) {\r\nprop = of_get_property(ug_info->phy_node, "interface", NULL);\r\nif (prop != NULL) {\r\nphy_interface = enet_to_phy_interface[*prop];\r\nmax_speed = enet_to_speed[*prop];\r\n} else\r\nphy_interface = PHY_INTERFACE_MODE_MII;\r\n} else {\r\nphy_interface = to_phy_interface((const char *)prop);\r\n}\r\nif (max_speed == 0)\r\nswitch (phy_interface) {\r\ncase PHY_INTERFACE_MODE_GMII:\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ncase PHY_INTERFACE_MODE_RGMII_ID:\r\ncase PHY_INTERFACE_MODE_RGMII_RXID:\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\ncase PHY_INTERFACE_MODE_TBI:\r\ncase PHY_INTERFACE_MODE_RTBI:\r\ncase PHY_INTERFACE_MODE_SGMII:\r\nmax_speed = SPEED_1000;\r\nbreak;\r\ndefault:\r\nmax_speed = SPEED_100;\r\nbreak;\r\n}\r\nif (max_speed == SPEED_1000) {\r\nunsigned int snums = qe_get_num_of_snums();\r\nug_info->uf_info.urfs = UCC_GETH_URFS_GIGA_INIT;\r\nug_info->uf_info.urfet = UCC_GETH_URFET_GIGA_INIT;\r\nug_info->uf_info.urfset = UCC_GETH_URFSET_GIGA_INIT;\r\nug_info->uf_info.utfs = UCC_GETH_UTFS_GIGA_INIT;\r\nug_info->uf_info.utfet = UCC_GETH_UTFET_GIGA_INIT;\r\nug_info->uf_info.utftt = UCC_GETH_UTFTT_GIGA_INIT;\r\nug_info->numThreadsTx = UCC_GETH_NUM_OF_THREADS_4;\r\nif ((snums == 76) || (snums == 46))\r\nug_info->numThreadsRx = UCC_GETH_NUM_OF_THREADS_6;\r\nelse\r\nug_info->numThreadsRx = UCC_GETH_NUM_OF_THREADS_4;\r\n}\r\nif (netif_msg_probe(&debug))\r\nprintk(KERN_INFO "ucc_geth: UCC%1d at 0x%8x (irq = %d)\n",\r\nug_info->uf_info.ucc_num + 1, ug_info->uf_info.regs,\r\nug_info->uf_info.irq);\r\ndev = alloc_etherdev(sizeof(*ugeth));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nugeth = netdev_priv(dev);\r\nspin_lock_init(&ugeth->lock);\r\nINIT_LIST_HEAD(&ugeth->group_hash_q);\r\nINIT_LIST_HEAD(&ugeth->ind_hash_q);\r\ndev_set_drvdata(device, dev);\r\ndev->base_addr = (unsigned long)(ug_info->uf_info.regs);\r\nSET_NETDEV_DEV(dev, device);\r\nuec_set_ethtool_ops(dev);\r\ndev->netdev_ops = &ucc_geth_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nINIT_WORK(&ugeth->timeout_work, ucc_geth_timeout_work);\r\nnetif_napi_add(dev, &ugeth->napi, ucc_geth_poll, 64);\r\ndev->mtu = 1500;\r\nugeth->msg_enable = netif_msg_init(debug.msg_enable, UGETH_MSG_DEFAULT);\r\nugeth->phy_interface = phy_interface;\r\nugeth->max_speed = max_speed;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nif (netif_msg_probe(ugeth))\r\nugeth_err("%s: Cannot register net device, aborting.",\r\ndev->name);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr)\r\nmemcpy(dev->dev_addr, mac_addr, 6);\r\nugeth->ug_info = ug_info;\r\nugeth->dev = device;\r\nugeth->ndev = dev;\r\nugeth->node = np;\r\nreturn 0;\r\n}\r\nstatic int ucc_geth_remove(struct platform_device* ofdev)\r\n{\r\nstruct device *device = &ofdev->dev;\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nstruct ucc_geth_private *ugeth = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\nucc_geth_memclean(ugeth);\r\ndev_set_drvdata(device, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init ucc_geth_init(void)\r\n{\r\nint i, ret;\r\nif (netif_msg_drv(&debug))\r\nprintk(KERN_INFO "ucc_geth: " DRV_DESC "\n");\r\nfor (i = 0; i < 8; i++)\r\nmemcpy(&(ugeth_info[i]), &ugeth_primary_info,\r\nsizeof(ugeth_primary_info));\r\nret = platform_driver_register(&ucc_geth_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit ucc_geth_exit(void)\r\n{\r\nplatform_driver_unregister(&ucc_geth_driver);\r\n}
