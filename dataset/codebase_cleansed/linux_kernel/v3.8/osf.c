int osf_partition(struct parsed_partitions *state)\r\n{\r\nint i;\r\nint slot = 1;\r\nunsigned int npartitions;\r\nSector sect;\r\nunsigned char *data;\r\nstruct disklabel {\r\n__le32 d_magic;\r\n__le16 d_type,d_subtype;\r\nu8 d_typename[16];\r\nu8 d_packname[16];\r\n__le32 d_secsize;\r\n__le32 d_nsectors;\r\n__le32 d_ntracks;\r\n__le32 d_ncylinders;\r\n__le32 d_secpercyl;\r\n__le32 d_secprtunit;\r\n__le16 d_sparespertrack;\r\n__le16 d_sparespercyl;\r\n__le32 d_acylinders;\r\n__le16 d_rpm, d_interleave, d_trackskew, d_cylskew;\r\n__le32 d_headswitch, d_trkseek, d_flags;\r\n__le32 d_drivedata[5];\r\n__le32 d_spare[5];\r\n__le32 d_magic2;\r\n__le16 d_checksum;\r\n__le16 d_npartitions;\r\n__le32 d_bbsize, d_sbsize;\r\nstruct d_partition {\r\n__le32 p_size;\r\n__le32 p_offset;\r\n__le32 p_fsize;\r\nu8 p_fstype;\r\nu8 p_frag;\r\n__le16 p_cpg;\r\n} d_partitions[MAX_OSF_PARTITIONS];\r\n} * label;\r\nstruct d_partition * partition;\r\ndata = read_part_sector(state, 0, &sect);\r\nif (!data)\r\nreturn -1;\r\nlabel = (struct disklabel *) (data+64);\r\npartition = label->d_partitions;\r\nif (le32_to_cpu(label->d_magic) != DISKLABELMAGIC) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nif (le32_to_cpu(label->d_magic2) != DISKLABELMAGIC) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nnpartitions = le16_to_cpu(label->d_npartitions);\r\nif (npartitions > MAX_OSF_PARTITIONS) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nfor (i = 0 ; i < npartitions; i++, partition++) {\r\nif (slot == state->limit)\r\nbreak;\r\nif (le32_to_cpu(partition->p_size))\r\nput_partition(state, slot,\r\nle32_to_cpu(partition->p_offset),\r\nle32_to_cpu(partition->p_size));\r\nslot++;\r\n}\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nput_dev_sector(sect);\r\nreturn 1;\r\n}
