static ssize_t show_configuration_string(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_host_config *actconfig;\r\nudev = to_usb_device(dev);\r\nactconfig = udev->actconfig;\r\nif ((!actconfig) || (!actconfig->string))\r\nreturn 0;\r\nreturn sprintf(buf, "%s\n", actconfig->string);\r\n}\r\nstatic ssize_t\r\nset_bConfigurationValue(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint config, value;\r\nif (sscanf(buf, "%d", &config) != 1 || config < -1 || config > 255)\r\nreturn -EINVAL;\r\nusb_lock_device(udev);\r\nvalue = usb_set_configuration(udev, config);\r\nusb_unlock_device(udev);\r\nreturn (value < 0) ? value : count;\r\n}\r\nstatic ssize_t\r\nshow_speed(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nchar *speed;\r\nudev = to_usb_device(dev);\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "1.5";\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ncase USB_SPEED_FULL:\r\nspeed = "12";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "480";\r\nbreak;\r\ncase USB_SPEED_WIRELESS:\r\nspeed = "480";\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\nspeed = "5000";\r\nbreak;\r\ndefault:\r\nspeed = "unknown";\r\n}\r\nreturn sprintf(buf, "%s\n", speed);\r\n}\r\nstatic ssize_t\r\nshow_busnum(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->bus->busnum);\r\n}\r\nstatic ssize_t\r\nshow_devnum(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->devnum);\r\n}\r\nstatic ssize_t\r\nshow_devpath(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%s\n", udev->devpath);\r\n}\r\nstatic ssize_t\r\nshow_version(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nu16 bcdUSB;\r\nudev = to_usb_device(dev);\r\nbcdUSB = le16_to_cpu(udev->descriptor.bcdUSB);\r\nreturn sprintf(buf, "%2x.%02x\n", bcdUSB >> 8, bcdUSB & 0xff);\r\n}\r\nstatic ssize_t\r\nshow_maxchild(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->maxchild);\r\n}\r\nstatic ssize_t\r\nshow_quirks(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "0x%x\n", udev->quirks);\r\n}\r\nstatic ssize_t\r\nshow_avoid_reset_quirk(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", !!(udev->quirks & USB_QUIRK_RESET));\r\n}\r\nstatic ssize_t\r\nset_avoid_reset_quirk(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint val;\r\nif (sscanf(buf, "%d", &val) != 1 || val < 0 || val > 1)\r\nreturn -EINVAL;\r\nusb_lock_device(udev);\r\nif (val)\r\nudev->quirks |= USB_QUIRK_RESET;\r\nelse\r\nudev->quirks &= ~USB_QUIRK_RESET;\r\nusb_unlock_device(udev);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_urbnum(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", atomic_read(&udev->urbnum));\r\n}\r\nstatic ssize_t\r\nshow_removable(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nchar *state;\r\nudev = to_usb_device(dev);\r\nswitch (udev->removable) {\r\ncase USB_DEVICE_REMOVABLE:\r\nstate = "removable";\r\nbreak;\r\ncase USB_DEVICE_FIXED:\r\nstate = "fixed";\r\nbreak;\r\ndefault:\r\nstate = "unknown";\r\n}\r\nreturn sprintf(buf, "%s\n", state);\r\n}\r\nstatic ssize_t\r\nshow_ltm_capable(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nif (usb_device_supports_ltm(to_usb_device(dev)))\r\nreturn sprintf(buf, "%s\n", "yes");\r\nreturn sprintf(buf, "%s\n", "no");\r\n}\r\nstatic ssize_t\r\nshow_persist(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->persist_enabled);\r\n}\r\nstatic ssize_t\r\nset_persist(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint value;\r\nif (udev->descriptor.bDeviceClass == USB_CLASS_HUB)\r\nreturn -EPERM;\r\nif (sscanf(buf, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nusb_lock_device(udev);\r\nudev->persist_enabled = !!value;\r\nusb_unlock_device(udev);\r\nreturn count;\r\n}\r\nstatic int add_persist_attributes(struct device *dev)\r\n{\r\nint rc = 0;\r\nif (is_usb_device(dev)) {\r\nstruct usb_device *udev = to_usb_device(dev);\r\nif (udev->descriptor.bDeviceClass != USB_CLASS_HUB)\r\nrc = sysfs_add_file_to_group(&dev->kobj,\r\n&dev_attr_persist.attr,\r\npower_group_name);\r\n}\r\nreturn rc;\r\n}\r\nstatic void remove_persist_attributes(struct device *dev)\r\n{\r\nsysfs_remove_file_from_group(&dev->kobj,\r\n&dev_attr_persist.attr,\r\npower_group_name);\r\n}\r\nstatic ssize_t\r\nshow_connected_duration(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nreturn sprintf(buf, "%u\n",\r\njiffies_to_msecs(jiffies - udev->connect_time));\r\n}\r\nstatic ssize_t\r\nshow_active_duration(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint duration;\r\nif (udev->state != USB_STATE_SUSPENDED)\r\nduration = jiffies_to_msecs(jiffies + udev->active_duration);\r\nelse\r\nduration = jiffies_to_msecs(udev->active_duration);\r\nreturn sprintf(buf, "%u\n", duration);\r\n}\r\nstatic ssize_t\r\nshow_autosuspend(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", dev->power.autosuspend_delay / 1000);\r\n}\r\nstatic ssize_t\r\nset_autosuspend(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint value;\r\nif (sscanf(buf, "%d", &value) != 1 || value >= INT_MAX/1000 ||\r\nvalue <= -INT_MAX/1000)\r\nreturn -EINVAL;\r\npm_runtime_set_autosuspend_delay(dev, value * 1000);\r\nreturn count;\r\n}\r\nstatic void warn_level(void) {\r\nstatic int level_warned;\r\nif (!level_warned) {\r\nlevel_warned = 1;\r\nprintk(KERN_WARNING "WARNING! power/level is deprecated; "\r\n"use power/control instead\n");\r\n}\r\n}\r\nstatic ssize_t\r\nshow_level(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nconst char *p = auto_string;\r\nwarn_level();\r\nif (udev->state != USB_STATE_SUSPENDED && !udev->dev.power.runtime_auto)\r\np = on_string;\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic ssize_t\r\nset_level(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint len = count;\r\nchar *cp;\r\nint rc = count;\r\nwarn_level();\r\ncp = memchr(buf, '\n', count);\r\nif (cp)\r\nlen = cp - buf;\r\nusb_lock_device(udev);\r\nif (len == sizeof on_string - 1 &&\r\nstrncmp(buf, on_string, len) == 0)\r\nusb_disable_autosuspend(udev);\r\nelse if (len == sizeof auto_string - 1 &&\r\nstrncmp(buf, auto_string, len) == 0)\r\nusb_enable_autosuspend(udev);\r\nelse\r\nrc = -EINVAL;\r\nusb_unlock_device(udev);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nshow_usb2_hardware_lpm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nconst char *p;\r\nif (udev->usb2_hw_lpm_enabled == 1)\r\np = "enabled";\r\nelse\r\np = "disabled";\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic ssize_t\r\nset_usb2_hardware_lpm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nbool value;\r\nint ret;\r\nusb_lock_device(udev);\r\nret = strtobool(buf, &value);\r\nif (!ret)\r\nret = usb_set_usb2_hardware_lpm(udev, value);\r\nusb_unlock_device(udev);\r\nif (!ret)\r\nreturn count;\r\nreturn ret;\r\n}\r\nstatic int add_power_attributes(struct device *dev)\r\n{\r\nint rc = 0;\r\nif (is_usb_device(dev)) {\r\nstruct usb_device *udev = to_usb_device(dev);\r\nrc = sysfs_merge_group(&dev->kobj, &power_attr_group);\r\nif (udev->usb2_hw_lpm_capable == 1)\r\nrc = sysfs_merge_group(&dev->kobj,\r\n&usb2_hardware_lpm_attr_group);\r\n}\r\nreturn rc;\r\n}\r\nstatic void remove_power_attributes(struct device *dev)\r\n{\r\nsysfs_unmerge_group(&dev->kobj, &usb2_hardware_lpm_attr_group);\r\nsysfs_unmerge_group(&dev->kobj, &power_attr_group);\r\n}\r\nstatic ssize_t usb_dev_authorized_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *usb_dev = to_usb_device(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", usb_dev->authorized);\r\n}\r\nstatic ssize_t usb_dev_authorized_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nssize_t result;\r\nstruct usb_device *usb_dev = to_usb_device(dev);\r\nunsigned val;\r\nresult = sscanf(buf, "%u\n", &val);\r\nif (result != 1)\r\nresult = -EINVAL;\r\nelse if (val == 0)\r\nresult = usb_deauthorize_device(usb_dev);\r\nelse\r\nresult = usb_authorize_device(usb_dev);\r\nreturn result < 0? result : size;\r\n}\r\nstatic ssize_t usb_remove_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint rc = 0;\r\nusb_lock_device(udev);\r\nif (udev->state != USB_STATE_NOTATTACHED) {\r\nusb_set_configuration(udev, -1);\r\nrc = usb_remove_device(udev);\r\n}\r\nif (rc == 0)\r\nrc = count;\r\nusb_unlock_device(udev);\r\nreturn rc;\r\n}\r\nstatic umode_t dev_string_attrs_are_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_device *udev = to_usb_device(dev);\r\nif (a == &dev_attr_manufacturer.attr) {\r\nif (udev->manufacturer == NULL)\r\nreturn 0;\r\n} else if (a == &dev_attr_product.attr) {\r\nif (udev->product == NULL)\r\nreturn 0;\r\n} else if (a == &dev_attr_serial.attr) {\r\nif (udev->serial == NULL)\r\nreturn 0;\r\n}\r\nreturn a->mode;\r\n}\r\nstatic ssize_t\r\nread_descriptors(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_device *udev = to_usb_device(dev);\r\nsize_t nleft = count;\r\nsize_t srclen, n;\r\nint cfgno;\r\nvoid *src;\r\nfor (cfgno = -1; cfgno < udev->descriptor.bNumConfigurations &&\r\nnleft > 0; ++cfgno) {\r\nif (cfgno < 0) {\r\nsrc = &udev->descriptor;\r\nsrclen = sizeof(struct usb_device_descriptor);\r\n} else {\r\nsrc = udev->rawdescriptors[cfgno];\r\nsrclen = __le16_to_cpu(udev->config[cfgno].desc.\r\nwTotalLength);\r\n}\r\nif (off < srclen) {\r\nn = min(nleft, srclen - (size_t) off);\r\nmemcpy(buf, src + off, n);\r\nnleft -= n;\r\nbuf += n;\r\noff = 0;\r\n} else {\r\noff -= srclen;\r\n}\r\n}\r\nreturn count - nleft;\r\n}\r\nint usb_create_sysfs_dev_files(struct usb_device *udev)\r\n{\r\nstruct device *dev = &udev->dev;\r\nint retval;\r\nretval = device_create_bin_file(dev, &dev_bin_attr_descriptors);\r\nif (retval)\r\ngoto error;\r\nretval = add_persist_attributes(dev);\r\nif (retval)\r\ngoto error;\r\nretval = add_power_attributes(dev);\r\nif (retval)\r\ngoto error;\r\nreturn retval;\r\nerror:\r\nusb_remove_sysfs_dev_files(udev);\r\nreturn retval;\r\n}\r\nvoid usb_remove_sysfs_dev_files(struct usb_device *udev)\r\n{\r\nstruct device *dev = &udev->dev;\r\nremove_power_attributes(dev);\r\nremove_persist_attributes(dev);\r\ndevice_remove_bin_file(dev, &dev_bin_attr_descriptors);\r\n}\r\nstatic ssize_t show_interface_string(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf;\r\nchar *string;\r\nintf = to_usb_interface(dev);\r\nstring = intf->cur_altsetting->string;\r\nbarrier();\r\nif (!string)\r\nreturn 0;\r\nreturn sprintf(buf, "%s\n", string);\r\n}\r\nstatic ssize_t show_modalias(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usb_device *udev;\r\nstruct usb_host_interface *alt;\r\nintf = to_usb_interface(dev);\r\nudev = interface_to_usbdev(intf);\r\nalt = intf->cur_altsetting;\r\nreturn sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X"\r\n"ic%02Xisc%02Xip%02Xin%02X\n",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\nle16_to_cpu(udev->descriptor.bcdDevice),\r\nudev->descriptor.bDeviceClass,\r\nudev->descriptor.bDeviceSubClass,\r\nudev->descriptor.bDeviceProtocol,\r\nalt->desc.bInterfaceClass,\r\nalt->desc.bInterfaceSubClass,\r\nalt->desc.bInterfaceProtocol,\r\nalt->desc.bInterfaceNumber);\r\n}\r\nstatic ssize_t show_supports_autosuspend(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usb_device *udev;\r\nint ret;\r\nintf = to_usb_interface(dev);\r\nudev = interface_to_usbdev(intf);\r\nusb_lock_device(udev);\r\nif (!intf->dev.driver ||\r\nto_usb_driver(intf->dev.driver)->supports_autosuspend)\r\nret = sprintf(buf, "%u\n", 1);\r\nelse\r\nret = sprintf(buf, "%u\n", 0);\r\nusb_unlock_device(udev);\r\nreturn ret;\r\n}\r\nstatic umode_t intf_assoc_attrs_are_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nif (intf->intf_assoc == NULL)\r\nreturn 0;\r\nreturn a->mode;\r\n}\r\nvoid usb_create_sysfs_intf_files(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nif (intf->sysfs_files_created || intf->unregistering)\r\nreturn;\r\nif (!alt->string && !(udev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\r\nalt->string = usb_cache_string(udev, alt->desc.iInterface);\r\nif (alt->string && device_create_file(&intf->dev, &dev_attr_interface))\r\n;\r\nintf->sysfs_files_created = 1;\r\n}\r\nvoid usb_remove_sysfs_intf_files(struct usb_interface *intf)\r\n{\r\nif (!intf->sysfs_files_created)\r\nreturn;\r\ndevice_remove_file(&intf->dev, &dev_attr_interface);\r\nintf->sysfs_files_created = 0;\r\n}
