void register_switch_driver(struct dsa_switch_driver *drv)\r\n{\r\nmutex_lock(&dsa_switch_drivers_mutex);\r\nlist_add_tail(&drv->list, &dsa_switch_drivers);\r\nmutex_unlock(&dsa_switch_drivers_mutex);\r\n}\r\nvoid unregister_switch_driver(struct dsa_switch_driver *drv)\r\n{\r\nmutex_lock(&dsa_switch_drivers_mutex);\r\nlist_del_init(&drv->list);\r\nmutex_unlock(&dsa_switch_drivers_mutex);\r\n}\r\nstatic struct dsa_switch_driver *\r\ndsa_switch_probe(struct mii_bus *bus, int sw_addr, char **_name)\r\n{\r\nstruct dsa_switch_driver *ret;\r\nstruct list_head *list;\r\nchar *name;\r\nret = NULL;\r\nname = NULL;\r\nmutex_lock(&dsa_switch_drivers_mutex);\r\nlist_for_each(list, &dsa_switch_drivers) {\r\nstruct dsa_switch_driver *drv;\r\ndrv = list_entry(list, struct dsa_switch_driver, list);\r\nname = drv->probe(bus, sw_addr);\r\nif (name != NULL) {\r\nret = drv;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dsa_switch_drivers_mutex);\r\n*_name = name;\r\nreturn ret;\r\n}\r\nstatic struct dsa_switch *\r\ndsa_switch_setup(struct dsa_switch_tree *dst, int index,\r\nstruct device *parent, struct mii_bus *bus)\r\n{\r\nstruct dsa_chip_data *pd = dst->pd->chip + index;\r\nstruct dsa_switch_driver *drv;\r\nstruct dsa_switch *ds;\r\nint ret;\r\nchar *name;\r\nint i;\r\ndrv = dsa_switch_probe(bus, pd->sw_addr, &name);\r\nif (drv == NULL) {\r\nprintk(KERN_ERR "%s[%d]: could not detect attached switch\n",\r\ndst->master_netdev->name, index);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nprintk(KERN_INFO "%s[%d]: detected a %s switch\n",\r\ndst->master_netdev->name, index, name);\r\nds = kzalloc(sizeof(*ds) + drv->priv_size, GFP_KERNEL);\r\nif (ds == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nds->dst = dst;\r\nds->index = index;\r\nds->pd = dst->pd->chip + index;\r\nds->drv = drv;\r\nds->master_mii_bus = bus;\r\nfor (i = 0; i < DSA_MAX_PORTS; i++) {\r\nchar *name;\r\nname = pd->port_names[i];\r\nif (name == NULL)\r\ncontinue;\r\nif (!strcmp(name, "cpu")) {\r\nif (dst->cpu_switch != -1) {\r\nprintk(KERN_ERR "multiple cpu ports?!\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndst->cpu_switch = index;\r\ndst->cpu_port = i;\r\n} else if (!strcmp(name, "dsa")) {\r\nds->dsa_port_mask |= 1 << i;\r\n} else {\r\nds->phys_port_mask |= 1 << i;\r\n}\r\n}\r\nif (ds->dst->cpu_switch == index)\r\nds->dst->tag_protocol = drv->tag_protocol;\r\nret = drv->setup(ds);\r\nif (ret < 0)\r\ngoto out;\r\nret = drv->set_addr(ds, dst->master_netdev->dev_addr);\r\nif (ret < 0)\r\ngoto out;\r\nds->slave_mii_bus = mdiobus_alloc();\r\nif (ds->slave_mii_bus == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndsa_slave_mii_bus_init(ds);\r\nret = mdiobus_register(ds->slave_mii_bus);\r\nif (ret < 0)\r\ngoto out_free;\r\nfor (i = 0; i < DSA_MAX_PORTS; i++) {\r\nstruct net_device *slave_dev;\r\nif (!(ds->phys_port_mask & (1 << i)))\r\ncontinue;\r\nslave_dev = dsa_slave_create(ds, parent, i, pd->port_names[i]);\r\nif (slave_dev == NULL) {\r\nprintk(KERN_ERR "%s[%d]: can't create dsa "\r\n"slave device for port %d(%s)\n",\r\ndst->master_netdev->name,\r\nindex, i, pd->port_names[i]);\r\ncontinue;\r\n}\r\nds->ports[i] = slave_dev;\r\n}\r\nreturn ds;\r\nout_free:\r\nmdiobus_free(ds->slave_mii_bus);\r\nout:\r\nkfree(ds);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void dsa_switch_destroy(struct dsa_switch *ds)\r\n{\r\n}\r\nstatic void dsa_link_poll_work(struct work_struct *ugly)\r\n{\r\nstruct dsa_switch_tree *dst;\r\nint i;\r\ndst = container_of(ugly, struct dsa_switch_tree, link_poll_work);\r\nfor (i = 0; i < dst->pd->nr_chips; i++) {\r\nstruct dsa_switch *ds = dst->ds[i];\r\nif (ds != NULL && ds->drv->poll_link != NULL)\r\nds->drv->poll_link(ds);\r\n}\r\nmod_timer(&dst->link_poll_timer, round_jiffies(jiffies + HZ));\r\n}\r\nstatic void dsa_link_poll_timer(unsigned long _dst)\r\n{\r\nstruct dsa_switch_tree *dst = (void *)_dst;\r\nschedule_work(&dst->link_poll_work);\r\n}\r\nstatic int dev_is_class(struct device *dev, void *class)\r\n{\r\nif (dev->class != NULL && !strcmp(dev->class->name, class))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct device *dev_find_class(struct device *parent, char *class)\r\n{\r\nif (dev_is_class(parent, class)) {\r\nget_device(parent);\r\nreturn parent;\r\n}\r\nreturn device_find_child(parent, class, dev_is_class);\r\n}\r\nstatic struct mii_bus *dev_to_mii_bus(struct device *dev)\r\n{\r\nstruct device *d;\r\nd = dev_find_class(dev, "mdio_bus");\r\nif (d != NULL) {\r\nstruct mii_bus *bus;\r\nbus = to_mii_bus(d);\r\nput_device(d);\r\nreturn bus;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_device *dev_to_net_device(struct device *dev)\r\n{\r\nstruct device *d;\r\nd = dev_find_class(dev, "net");\r\nif (d != NULL) {\r\nstruct net_device *nd;\r\nnd = to_net_dev(d);\r\ndev_hold(nd);\r\nput_device(d);\r\nreturn nd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int dsa_probe(struct platform_device *pdev)\r\n{\r\nstatic int dsa_version_printed;\r\nstruct dsa_platform_data *pd = pdev->dev.platform_data;\r\nstruct net_device *dev;\r\nstruct dsa_switch_tree *dst;\r\nint i;\r\nif (!dsa_version_printed++)\r\nprintk(KERN_NOTICE "Distributed Switch Architecture "\r\n"driver version %s\n", dsa_driver_version);\r\nif (pd == NULL || pd->netdev == NULL)\r\nreturn -EINVAL;\r\ndev = dev_to_net_device(pd->netdev);\r\nif (dev == NULL)\r\nreturn -EINVAL;\r\nif (dev->dsa_ptr != NULL) {\r\ndev_put(dev);\r\nreturn -EEXIST;\r\n}\r\ndst = kzalloc(sizeof(*dst), GFP_KERNEL);\r\nif (dst == NULL) {\r\ndev_put(dev);\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, dst);\r\ndst->pd = pd;\r\ndst->master_netdev = dev;\r\ndst->cpu_switch = -1;\r\ndst->cpu_port = -1;\r\nfor (i = 0; i < pd->nr_chips; i++) {\r\nstruct mii_bus *bus;\r\nstruct dsa_switch *ds;\r\nbus = dev_to_mii_bus(pd->chip[i].mii_bus);\r\nif (bus == NULL) {\r\nprintk(KERN_ERR "%s[%d]: no mii bus found for "\r\n"dsa switch\n", dev->name, i);\r\ncontinue;\r\n}\r\nds = dsa_switch_setup(dst, i, &pdev->dev, bus);\r\nif (IS_ERR(ds)) {\r\nprintk(KERN_ERR "%s[%d]: couldn't create dsa switch "\r\n"instance (error %ld)\n", dev->name, i,\r\nPTR_ERR(ds));\r\ncontinue;\r\n}\r\ndst->ds[i] = ds;\r\nif (ds->drv->poll_link != NULL)\r\ndst->link_poll_needed = 1;\r\n}\r\nwmb();\r\ndev->dsa_ptr = (void *)dst;\r\nif (dst->link_poll_needed) {\r\nINIT_WORK(&dst->link_poll_work, dsa_link_poll_work);\r\ninit_timer(&dst->link_poll_timer);\r\ndst->link_poll_timer.data = (unsigned long)dst;\r\ndst->link_poll_timer.function = dsa_link_poll_timer;\r\ndst->link_poll_timer.expires = round_jiffies(jiffies + HZ);\r\nadd_timer(&dst->link_poll_timer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsa_remove(struct platform_device *pdev)\r\n{\r\nstruct dsa_switch_tree *dst = platform_get_drvdata(pdev);\r\nint i;\r\nif (dst->link_poll_needed)\r\ndel_timer_sync(&dst->link_poll_timer);\r\nflush_work(&dst->link_poll_work);\r\nfor (i = 0; i < dst->pd->nr_chips; i++) {\r\nstruct dsa_switch *ds = dst->ds[i];\r\nif (ds != NULL)\r\ndsa_switch_destroy(ds);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsa_shutdown(struct platform_device *pdev)\r\n{\r\n}\r\nstatic int __init dsa_init_module(void)\r\n{\r\nint rc;\r\nrc = platform_driver_register(&dsa_driver);\r\nif (rc)\r\nreturn rc;\r\n#ifdef CONFIG_NET_DSA_TAG_DSA\r\ndev_add_pack(&dsa_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_EDSA\r\ndev_add_pack(&edsa_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_TRAILER\r\ndev_add_pack(&trailer_packet_type);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit dsa_cleanup_module(void)\r\n{\r\n#ifdef CONFIG_NET_DSA_TAG_TRAILER\r\ndev_remove_pack(&trailer_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_EDSA\r\ndev_remove_pack(&edsa_packet_type);\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_DSA\r\ndev_remove_pack(&dsa_packet_type);\r\n#endif\r\nplatform_driver_unregister(&dsa_driver);\r\n}
