static inline gf\r\nmodnn(int x)\r\n{\r\nwhile (x >= NN) {\r\nx -= NN;\r\nx = (x >> MM) + (x & NN);\r\n}\r\nreturn x;\r\n}\r\nstatic void\r\ngenerate_gf(dtype Alpha_to[NN + 1], dtype Index_of[NN + 1])\r\n{\r\nregister int i, mask;\r\nmask = 1;\r\nAlpha_to[MM] = 0;\r\nfor (i = 0; i < MM; i++) {\r\nAlpha_to[i] = mask;\r\nIndex_of[Alpha_to[i]] = i;\r\nif (Pp[i] != 0)\r\nAlpha_to[MM] ^= mask;\r\nmask <<= 1;\r\n}\r\nIndex_of[Alpha_to[MM]] = MM;\r\nmask >>= 1;\r\nfor (i = MM + 1; i < NN; i++) {\r\nif (Alpha_to[i - 1] >= mask)\r\nAlpha_to[i] = Alpha_to[MM] ^ ((Alpha_to[i - 1] ^ mask) << 1);\r\nelse\r\nAlpha_to[i] = Alpha_to[i - 1] << 1;\r\nIndex_of[Alpha_to[i]] = i;\r\n}\r\nIndex_of[0] = A0;\r\nAlpha_to[NN] = 0;\r\n}\r\nstatic int\r\neras_dec_rs(dtype Alpha_to[NN + 1], dtype Index_of[NN + 1],\r\ngf bb[NN - KK + 1], gf eras_val[NN-KK], int eras_pos[NN-KK],\r\nint no_eras)\r\n{\r\nint deg_lambda, el, deg_omega;\r\nint i, j, r,k;\r\ngf u,q,tmp,num1,num2,den,discr_r;\r\ngf lambda[NN-KK + 1], s[NN-KK + 1];\r\ngf b[NN-KK + 1], t[NN-KK + 1], omega[NN-KK + 1];\r\ngf root[NN-KK], reg[NN-KK + 1], loc[NN-KK];\r\nint syn_error, count;\r\nsyn_error = 0;\r\nfor(i=0;i<NN-KK;i++)\r\nsyn_error |= bb[i];\r\nif (!syn_error) {\r\ncount = 0;\r\ngoto finish;\r\n}\r\nfor(i=1;i<=NN-KK;i++){\r\ns[i] = bb[0];\r\n}\r\nfor(j=1;j<NN-KK;j++){\r\nif(bb[j] == 0)\r\ncontinue;\r\ntmp = Index_of[bb[j]];\r\nfor(i=1;i<=NN-KK;i++)\r\ns[i] ^= Alpha_to[modnn(tmp + (B0+i-1)*PRIM*j)];\r\n}\r\nfor(i=1;i<=NN-KK;i++) {\r\ntmp = Index_of[s[i]];\r\nif (tmp != A0)\r\ntmp = modnn(tmp + 2 * KK * (B0+i-1)*PRIM);\r\ns[i] = tmp;\r\n}\r\nCLEAR(&lambda[1],NN-KK);\r\nlambda[0] = 1;\r\nif (no_eras > 0) {\r\nlambda[1] = Alpha_to[modnn(PRIM * eras_pos[0])];\r\nfor (i = 1; i < no_eras; i++) {\r\nu = modnn(PRIM*eras_pos[i]);\r\nfor (j = i+1; j > 0; j--) {\r\ntmp = Index_of[lambda[j - 1]];\r\nif(tmp != A0)\r\nlambda[j] ^= Alpha_to[modnn(u + tmp)];\r\n}\r\n}\r\n#if DEBUG_ECC >= 1\r\nfor(i=1;i<=no_eras;i++)\r\nreg[i] = Index_of[lambda[i]];\r\ncount = 0;\r\nfor (i = 1,k=NN-Ldec; i <= NN; i++,k = modnn(NN+k-Ldec)) {\r\nq = 1;\r\nfor (j = 1; j <= no_eras; j++)\r\nif (reg[j] != A0) {\r\nreg[j] = modnn(reg[j] + j);\r\nq ^= Alpha_to[reg[j]];\r\n}\r\nif (q != 0)\r\ncontinue;\r\nroot[count] = i;\r\nloc[count] = k;\r\ncount++;\r\n}\r\nif (count != no_eras) {\r\nprintf("\n lambda(x) is WRONG\n");\r\ncount = -1;\r\ngoto finish;\r\n}\r\n#if DEBUG_ECC >= 2\r\nprintf("\n Erasure positions as determined by roots of Eras Loc Poly:\n");\r\nfor (i = 0; i < count; i++)\r\nprintf("%d ", loc[i]);\r\nprintf("\n");\r\n#endif\r\n#endif\r\n}\r\nfor(i=0;i<NN-KK+1;i++)\r\nb[i] = Index_of[lambda[i]];\r\nr = no_eras;\r\nel = no_eras;\r\nwhile (++r <= NN-KK) {\r\ndiscr_r = 0;\r\nfor (i = 0; i < r; i++){\r\nif ((lambda[i] != 0) && (s[r - i] != A0)) {\r\ndiscr_r ^= Alpha_to[modnn(Index_of[lambda[i]] + s[r - i])];\r\n}\r\n}\r\ndiscr_r = Index_of[discr_r];\r\nif (discr_r == A0) {\r\nCOPYDOWN(&b[1],b,NN-KK);\r\nb[0] = A0;\r\n} else {\r\nt[0] = lambda[0];\r\nfor (i = 0 ; i < NN-KK; i++) {\r\nif(b[i] != A0)\r\nt[i+1] = lambda[i+1] ^ Alpha_to[modnn(discr_r + b[i])];\r\nelse\r\nt[i+1] = lambda[i+1];\r\n}\r\nif (2 * el <= r + no_eras - 1) {\r\nel = r + no_eras - el;\r\nfor (i = 0; i <= NN-KK; i++)\r\nb[i] = (lambda[i] == 0) ? A0 : modnn(Index_of[lambda[i]] - discr_r + NN);\r\n} else {\r\nCOPYDOWN(&b[1],b,NN-KK);\r\nb[0] = A0;\r\n}\r\nCOPY(lambda,t,NN-KK+1);\r\n}\r\n}\r\ndeg_lambda = 0;\r\nfor(i=0;i<NN-KK+1;i++){\r\nlambda[i] = Index_of[lambda[i]];\r\nif(lambda[i] != A0)\r\ndeg_lambda = i;\r\n}\r\nCOPY(&reg[1],&lambda[1],NN-KK);\r\ncount = 0;\r\nfor (i = 1,k=NN-Ldec; i <= NN; i++,k = modnn(NN+k-Ldec)) {\r\nq = 1;\r\nfor (j = deg_lambda; j > 0; j--){\r\nif (reg[j] != A0) {\r\nreg[j] = modnn(reg[j] + j);\r\nq ^= Alpha_to[reg[j]];\r\n}\r\n}\r\nif (q != 0)\r\ncontinue;\r\nroot[count] = i;\r\nloc[count] = k;\r\nif(++count == deg_lambda)\r\nbreak;\r\n}\r\nif (deg_lambda != count) {\r\ncount = -1;\r\ngoto finish;\r\n}\r\ndeg_omega = 0;\r\nfor (i = 0; i < NN-KK;i++){\r\ntmp = 0;\r\nj = (deg_lambda < i) ? deg_lambda : i;\r\nfor(;j >= 0; j--){\r\nif ((s[i + 1 - j] != A0) && (lambda[j] != A0))\r\ntmp ^= Alpha_to[modnn(s[i + 1 - j] + lambda[j])];\r\n}\r\nif(tmp != 0)\r\ndeg_omega = i;\r\nomega[i] = Index_of[tmp];\r\n}\r\nomega[NN-KK] = A0;\r\nfor (j = count-1; j >=0; j--) {\r\nnum1 = 0;\r\nfor (i = deg_omega; i >= 0; i--) {\r\nif (omega[i] != A0)\r\nnum1 ^= Alpha_to[modnn(omega[i] + i * root[j])];\r\n}\r\nnum2 = Alpha_to[modnn(root[j] * (B0 - 1) + NN)];\r\nden = 0;\r\nfor (i = min(deg_lambda,NN-KK-1) & ~1; i >= 0; i -=2) {\r\nif(lambda[i+1] != A0)\r\nden ^= Alpha_to[modnn(lambda[i+1] + i * root[j])];\r\n}\r\nif (den == 0) {\r\n#if DEBUG_ECC >= 1\r\nprintf("\n ERROR: denominator = 0\n");\r\n#endif\r\ncount = -1;\r\ngoto finish;\r\n}\r\nif (num1 != 0) {\r\neras_val[j] = Alpha_to[modnn(Index_of[num1] + Index_of[num2] + NN - Index_of[den])];\r\n} else {\r\neras_val[j] = 0;\r\n}\r\n}\r\nfinish:\r\nfor(i=0;i<count;i++)\r\neras_pos[i] = loc[i];\r\nreturn count;\r\n}\r\nint doc_decode_ecc(unsigned char sector[SECTOR_SIZE], unsigned char ecc1[6])\r\n{\r\nint parity, i, nb_errors;\r\ngf bb[NN - KK + 1];\r\ngf error_val[NN-KK];\r\nint error_pos[NN-KK], pos, bitpos, index, val;\r\ndtype *Alpha_to, *Index_of;\r\nAlpha_to = kmalloc((NN + 1) * sizeof(dtype), GFP_KERNEL);\r\nif (!Alpha_to)\r\nreturn -1;\r\nIndex_of = kmalloc((NN + 1) * sizeof(dtype), GFP_KERNEL);\r\nif (!Index_of) {\r\nkfree(Alpha_to);\r\nreturn -1;\r\n}\r\ngenerate_gf(Alpha_to, Index_of);\r\nparity = ecc1[1];\r\nbb[0] = (ecc1[4] & 0xff) | ((ecc1[5] & 0x03) << 8);\r\nbb[1] = ((ecc1[5] & 0xfc) >> 2) | ((ecc1[2] & 0x0f) << 6);\r\nbb[2] = ((ecc1[2] & 0xf0) >> 4) | ((ecc1[3] & 0x3f) << 4);\r\nbb[3] = ((ecc1[3] & 0xc0) >> 6) | ((ecc1[0] & 0xff) << 2);\r\nnb_errors = eras_dec_rs(Alpha_to, Index_of, bb,\r\nerror_val, error_pos, 0);\r\nif (nb_errors <= 0)\r\ngoto the_end;\r\nfor(i=0;i<nb_errors;i++) {\r\npos = error_pos[i];\r\nif (pos >= NB_DATA && pos < KK) {\r\nnb_errors = -1;\r\ngoto the_end;\r\n}\r\nif (pos < NB_DATA) {\r\npos = 10 * (NB_DATA - 1 - pos) - 6;\r\nindex = (pos >> 3) ^ 1;\r\nbitpos = pos & 7;\r\nif ((index >= 0 && index < SECTOR_SIZE) ||\r\nindex == (SECTOR_SIZE + 1)) {\r\nval = error_val[i] >> (2 + bitpos);\r\nparity ^= val;\r\nif (index < SECTOR_SIZE)\r\nsector[index] ^= val;\r\n}\r\nindex = ((pos >> 3) + 1) ^ 1;\r\nbitpos = (bitpos + 10) & 7;\r\nif (bitpos == 0)\r\nbitpos = 8;\r\nif ((index >= 0 && index < SECTOR_SIZE) ||\r\nindex == (SECTOR_SIZE + 1)) {\r\nval = error_val[i] << (8 - bitpos);\r\nparity ^= val;\r\nif (index < SECTOR_SIZE)\r\nsector[index] ^= val;\r\n}\r\n}\r\n}\r\nif ((parity & 0xff) != 0)\r\nnb_errors = -1;\r\nthe_end:\r\nkfree(Alpha_to);\r\nkfree(Index_of);\r\nreturn nb_errors;\r\n}
