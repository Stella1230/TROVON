static int fiq_def_op(void *ref, int relinquish)\r\n{\r\nif (!relinquish)\r\nset_fiq_handler(&no_fiq_insn, sizeof(no_fiq_insn));\r\nreturn 0;\r\n}\r\nint show_fiq_list(struct seq_file *p, int prec)\r\n{\r\nif (current_fiq != &default_owner)\r\nseq_printf(p, "%*s: %s\n", prec, "FIQ",\r\ncurrent_fiq->name);\r\nreturn 0;\r\n}\r\nvoid set_fiq_handler(void *start, unsigned int length)\r\n{\r\n#if defined(CONFIG_CPU_USE_DOMAINS)\r\nmemcpy((void *)0xffff001c, start, length);\r\n#else\r\nmemcpy(vectors_page + 0x1c, start, length);\r\n#endif\r\nflush_icache_range(0xffff001c, 0xffff001c + length);\r\nif (!vectors_high())\r\nflush_icache_range(0x1c, 0x1c + length);\r\n}\r\nint claim_fiq(struct fiq_handler *f)\r\n{\r\nint ret = 0;\r\nif (current_fiq) {\r\nret = -EBUSY;\r\nif (current_fiq->fiq_op != NULL)\r\nret = current_fiq->fiq_op(current_fiq->dev_id, 1);\r\n}\r\nif (!ret) {\r\nf->next = current_fiq;\r\ncurrent_fiq = f;\r\n}\r\nreturn ret;\r\n}\r\nvoid release_fiq(struct fiq_handler *f)\r\n{\r\nif (current_fiq != f) {\r\nprintk(KERN_ERR "%s FIQ trying to release %s FIQ\n",\r\nf->name, current_fiq->name);\r\ndump_stack();\r\nreturn;\r\n}\r\ndo\r\ncurrent_fiq = current_fiq->next;\r\nwhile (current_fiq->fiq_op(current_fiq->dev_id, 0));\r\n}\r\nvoid enable_fiq(int fiq)\r\n{\r\nenable_irq(fiq + fiq_start);\r\n}\r\nvoid disable_fiq(int fiq)\r\n{\r\ndisable_irq(fiq + fiq_start);\r\n}\r\nvoid __init init_FIQ(int start)\r\n{\r\nno_fiq_insn = *(unsigned long *)0xffff001c;\r\nfiq_start = start;\r\n}
