static int parse_probe_event(const char *str)\r\n{\r\nstruct perf_probe_event *pev = &params.events[params.nevents];\r\nint ret;\r\npr_debug("probe-definition(%d): %s\n", params.nevents, str);\r\nif (++params.nevents == MAX_PROBES) {\r\npr_err("Too many probes (> %d) were specified.", MAX_PROBES);\r\nreturn -1;\r\n}\r\npev->uprobes = params.uprobes;\r\nret = parse_perf_probe_command(str, pev);\r\npr_debug("%d arguments\n", pev->nargs);\r\nreturn ret;\r\n}\r\nstatic int set_target(const char *ptr)\r\n{\r\nint found = 0;\r\nconst char *buf;\r\nif (!params.target && ptr && *ptr == '/') {\r\nparams.target = ptr;\r\nfound = 1;\r\nbuf = ptr + (strlen(ptr) - 3);\r\nif (strcmp(buf, ".ko"))\r\nparams.uprobes = true;\r\n}\r\nreturn found;\r\n}\r\nstatic int parse_probe_event_argv(int argc, const char **argv)\r\n{\r\nint i, len, ret, found_target;\r\nchar *buf;\r\nfound_target = set_target(argv[0]);\r\nif (found_target && argc == 1)\r\nreturn 0;\r\nlen = 0;\r\nfor (i = 0; i < argc; i++) {\r\nif (i == 0 && found_target)\r\ncontinue;\r\nlen += strlen(argv[i]) + 1;\r\n}\r\nbuf = zalloc(len + 1);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nlen = 0;\r\nfor (i = 0; i < argc; i++) {\r\nif (i == 0 && found_target)\r\ncontinue;\r\nlen += sprintf(&buf[len], "%s ", argv[i]);\r\n}\r\nparams.mod_events = true;\r\nret = parse_probe_event(buf);\r\nfree(buf);\r\nreturn ret;\r\n}\r\nstatic int opt_add_probe_event(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nif (str) {\r\nparams.mod_events = true;\r\nreturn parse_probe_event(str);\r\n} else\r\nreturn 0;\r\n}\r\nstatic int opt_del_probe_event(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nif (str) {\r\nparams.mod_events = true;\r\nif (!params.dellist)\r\nparams.dellist = strlist__new(true, NULL);\r\nstrlist__add(params.dellist, str);\r\n}\r\nreturn 0;\r\n}\r\nstatic int opt_set_target(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nint ret = -ENOENT;\r\nif (str && !params.target) {\r\nif (!strcmp(opt->long_name, "exec"))\r\nparams.uprobes = true;\r\n#ifdef DWARF_SUPPORT\r\nelse if (!strcmp(opt->long_name, "module"))\r\nparams.uprobes = false;\r\n#endif\r\nelse\r\nreturn ret;\r\nparams.target = str;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int opt_show_lines(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nint ret = 0;\r\nif (!str)\r\nreturn 0;\r\nif (params.show_lines) {\r\npr_warning("Warning: more than one --line options are"\r\n" detected. Only the first one is valid.\n");\r\nreturn 0;\r\n}\r\nparams.show_lines = true;\r\nret = parse_line_range_desc(str, &params.line_range);\r\nINIT_LIST_HEAD(&params.line_range.line_list);\r\nreturn ret;\r\n}\r\nstatic int opt_show_vars(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nstruct perf_probe_event *pev = &params.events[params.nevents];\r\nint ret;\r\nif (!str)\r\nreturn 0;\r\nret = parse_probe_event(str);\r\nif (!ret && pev->nargs != 0) {\r\npr_err(" Error: '--vars' doesn't accept arguments.\n");\r\nreturn -EINVAL;\r\n}\r\nparams.show_vars = true;\r\nreturn ret;\r\n}\r\nstatic int opt_set_filter(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nconst char *err;\r\nif (str) {\r\npr_debug2("Set filter: %s\n", str);\r\nif (params.filter)\r\nstrfilter__delete(params.filter);\r\nparams.filter = strfilter__new(str, &err);\r\nif (!params.filter) {\r\npr_err("Filter parse error at %td.\n", err - str + 1);\r\npr_err("Source: \"%s\"\n", str);\r\npr_err(" %*c\n", (int)(err - str + 1), '^');\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cmd_probe(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nconst char * const probe_usage[] = {\r\n"perf probe [<options>] 'PROBEDEF' ['PROBEDEF' ...]",\r\n"perf probe [<options>] --add 'PROBEDEF' [--add 'PROBEDEF' ...]",\r\n"perf probe [<options>] --del '[GROUP:]EVENT' ...",\r\n"perf probe --list",\r\n#ifdef DWARF_SUPPORT\r\n"perf probe [<options>] --line 'LINEDESC'",\r\n"perf probe [<options>] --vars 'PROBEPOINT'",\r\n#endif\r\nNULL\r\n};\r\nconst struct option options[] = {\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show parsed arguments, etc)"),\r\nOPT_BOOLEAN('l', "list", &params.list_events,\r\n"list up current probe events"),\r\nOPT_CALLBACK('d', "del", NULL, "[GROUP:]EVENT", "delete a probe event.",\r\nopt_del_probe_event),\r\nOPT_CALLBACK('a', "add", NULL,\r\n#ifdef DWARF_SUPPORT\r\n"[EVENT=]FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT"\r\n" [[NAME=]ARG ...]",\r\n#else\r\n"[EVENT=]FUNC[+OFF|%return] [[NAME=]ARG ...]",\r\n#endif\r\n"probe point definition, where\n"\r\n"\t\tGROUP:\tGroup name (optional)\n"\r\n"\t\tEVENT:\tEvent name\n"\r\n"\t\tFUNC:\tFunction name\n"\r\n"\t\tOFF:\tOffset from function entry (in byte)\n"\r\n"\t\t%return:\tPut the probe at function return\n"\r\n#ifdef DWARF_SUPPORT\r\n"\t\tSRC:\tSource code path\n"\r\n"\t\tRL:\tRelative line number from function entry.\n"\r\n"\t\tAL:\tAbsolute line number in file.\n"\r\n"\t\tPT:\tLazy expression of line code.\n"\r\n"\t\tARG:\tProbe argument (local variable name or\n"\r\n"\t\t\tkprobe-tracer argument format.)\n",\r\n#else\r\n"\t\tARG:\tProbe argument (kprobe-tracer argument format.)\n",\r\n#endif\r\nopt_add_probe_event),\r\nOPT_BOOLEAN('f', "force", &params.force_add, "forcibly add events"\r\n" with existing name"),\r\n#ifdef DWARF_SUPPORT\r\nOPT_CALLBACK('L', "line", NULL,\r\n"FUNC[:RLN[+NUM|-RLN2]]|SRC:ALN[+NUM|-ALN2]",\r\n"Show source code lines.", opt_show_lines),\r\nOPT_CALLBACK('V', "vars", NULL,\r\n"FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT",\r\n"Show accessible variables on PROBEDEF", opt_show_vars),\r\nOPT_BOOLEAN('\0', "externs", &params.show_ext_vars,\r\n"Show external variables too (with --vars only)"),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_STRING('s', "source", &symbol_conf.source_prefix,\r\n"directory", "path to kernel source"),\r\nOPT_CALLBACK('m', "module", NULL, "modname|path",\r\n"target module name (for online) or path (for offline)",\r\nopt_set_target),\r\n#endif\r\nOPT__DRY_RUN(&probe_event_dry_run),\r\nOPT_INTEGER('\0', "max-probes", &params.max_probe_points,\r\n"Set how many probe points can be found for a probe."),\r\nOPT_BOOLEAN('F', "funcs", &params.show_funcs,\r\n"Show potential probe-able functions."),\r\nOPT_CALLBACK('\0', "filter", NULL,\r\n"[!]FILTER", "Set a filter (with --vars/funcs only)\n"\r\n"\t\t\t(default: \"" DEFAULT_VAR_FILTER "\" for --vars,\n"\r\n"\t\t\t \"" DEFAULT_FUNC_FILTER "\" for --funcs)",\r\nopt_set_filter),\r\nOPT_CALLBACK('x', "exec", NULL, "executable|path",\r\n"target executable name or path", opt_set_target),\r\nOPT_END()\r\n};\r\nint ret;\r\nargc = parse_options(argc, argv, options, probe_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (argc > 0) {\r\nif (strcmp(argv[0], "-") == 0) {\r\npr_warning(" Error: '-' is not supported.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nret = parse_probe_event_argv(argc, argv);\r\nif (ret < 0) {\r\npr_err(" Error: Parse Error. (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (params.max_probe_points == 0)\r\nparams.max_probe_points = MAX_PROBES;\r\nif ((!params.nevents && !params.dellist && !params.list_events &&\r\n!params.show_lines && !params.show_funcs))\r\nusage_with_options(probe_usage, options);\r\nsymbol_conf.try_vmlinux_path = (symbol_conf.vmlinux_name == NULL);\r\nif (params.list_events) {\r\nif (params.mod_events) {\r\npr_err(" Error: Don't use --list with --add/--del.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.show_lines) {\r\npr_err(" Error: Don't use --list with --line.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.show_vars) {\r\npr_err(" Error: Don't use --list with --vars.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.show_funcs) {\r\npr_err(" Error: Don't use --list with --funcs.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.uprobes) {\r\npr_warning(" Error: Don't use --list with --exec.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nret = show_perf_probe_events();\r\nif (ret < 0)\r\npr_err(" Error: Failed to show event list. (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (params.show_funcs) {\r\nif (params.nevents != 0 || params.dellist) {\r\npr_err(" Error: Don't use --funcs with"\r\n" --add/--del.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.show_lines) {\r\npr_err(" Error: Don't use --funcs with --line.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.show_vars) {\r\npr_err(" Error: Don't use --funcs with --vars.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (!params.filter)\r\nparams.filter = strfilter__new(DEFAULT_FUNC_FILTER,\r\nNULL);\r\nret = show_available_funcs(params.target, params.filter,\r\nparams.uprobes);\r\nstrfilter__delete(params.filter);\r\nif (ret < 0)\r\npr_err(" Error: Failed to show functions."\r\n" (%d)\n", ret);\r\nreturn ret;\r\n}\r\n#ifdef DWARF_SUPPORT\r\nif (params.show_lines && !params.uprobes) {\r\nif (params.mod_events) {\r\npr_err(" Error: Don't use --line with"\r\n" --add/--del.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (params.show_vars) {\r\npr_err(" Error: Don't use --line with --vars.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nret = show_line_range(&params.line_range, params.target);\r\nif (ret < 0)\r\npr_err(" Error: Failed to show lines. (%d)\n", ret);\r\nreturn ret;\r\n}\r\nif (params.show_vars) {\r\nif (params.mod_events) {\r\npr_err(" Error: Don't use --vars with"\r\n" --add/--del.\n");\r\nusage_with_options(probe_usage, options);\r\n}\r\nif (!params.filter)\r\nparams.filter = strfilter__new(DEFAULT_VAR_FILTER,\r\nNULL);\r\nret = show_available_vars(params.events, params.nevents,\r\nparams.max_probe_points,\r\nparams.target,\r\nparams.filter,\r\nparams.show_ext_vars);\r\nstrfilter__delete(params.filter);\r\nif (ret < 0)\r\npr_err(" Error: Failed to show vars. (%d)\n", ret);\r\nreturn ret;\r\n}\r\n#endif\r\nif (params.dellist) {\r\nret = del_perf_probe_events(params.dellist);\r\nstrlist__delete(params.dellist);\r\nif (ret < 0) {\r\npr_err(" Error: Failed to delete events. (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (params.nevents) {\r\nret = add_perf_probe_events(params.events, params.nevents,\r\nparams.max_probe_points,\r\nparams.target,\r\nparams.force_add);\r\nif (ret < 0) {\r\npr_err(" Error: Failed to add events. (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
