static irqreturn_t pc110pad_interrupt(int irq, void *ptr)\r\n{\r\nint value = inb_p(pc110pad_io);\r\nint handshake = inb_p(pc110pad_io + 2);\r\noutb(handshake | 1, pc110pad_io + 2);\r\nudelay(2);\r\noutb(handshake & ~1, pc110pad_io + 2);\r\nudelay(2);\r\ninb_p(0x64);\r\npc110pad_data[pc110pad_count++] = value;\r\nif (pc110pad_count < 3)\r\nreturn IRQ_HANDLED;\r\ninput_report_key(pc110pad_dev, BTN_TOUCH,\r\npc110pad_data[0] & 0x01);\r\ninput_report_abs(pc110pad_dev, ABS_X,\r\npc110pad_data[1] | ((pc110pad_data[0] << 3) & 0x80) | ((pc110pad_data[0] << 1) & 0x100));\r\ninput_report_abs(pc110pad_dev, ABS_Y,\r\npc110pad_data[2] | ((pc110pad_data[0] << 4) & 0x80));\r\ninput_sync(pc110pad_dev);\r\npc110pad_count = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pc110pad_close(struct input_dev *dev)\r\n{\r\noutb(PC110PAD_OFF, pc110pad_io + 2);\r\n}\r\nstatic int pc110pad_open(struct input_dev *dev)\r\n{\r\npc110pad_interrupt(0, NULL);\r\npc110pad_interrupt(0, NULL);\r\npc110pad_interrupt(0, NULL);\r\noutb(PC110PAD_ON, pc110pad_io + 2);\r\npc110pad_count = 0;\r\nreturn 0;\r\n}\r\nstatic int __init pc110pad_init(void)\r\n{\r\nint err;\r\nif (!no_pci_devices())\r\nreturn -ENODEV;\r\nif (!request_region(pc110pad_io, 4, "pc110pad")) {\r\nprintk(KERN_ERR "pc110pad: I/O area %#x-%#x in use.\n",\r\npc110pad_io, pc110pad_io + 4);\r\nreturn -EBUSY;\r\n}\r\noutb(PC110PAD_OFF, pc110pad_io + 2);\r\nif (request_irq(pc110pad_irq, pc110pad_interrupt, 0, "pc110pad", NULL)) {\r\nprintk(KERN_ERR "pc110pad: Unable to get irq %d.\n", pc110pad_irq);\r\nerr = -EBUSY;\r\ngoto err_release_region;\r\n}\r\npc110pad_dev = input_allocate_device();\r\nif (!pc110pad_dev) {\r\nprintk(KERN_ERR "pc110pad: Not enough memory.\n");\r\nerr = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\npc110pad_dev->name = "IBM PC110 TouchPad";\r\npc110pad_dev->phys = "isa15e0/input0";\r\npc110pad_dev->id.bustype = BUS_ISA;\r\npc110pad_dev->id.vendor = 0x0003;\r\npc110pad_dev->id.product = 0x0001;\r\npc110pad_dev->id.version = 0x0100;\r\npc110pad_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\npc110pad_dev->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y);\r\npc110pad_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_abs_set_max(pc110pad_dev, ABS_X, 0x1ff);\r\ninput_abs_set_max(pc110pad_dev, ABS_Y, 0x0ff);\r\npc110pad_dev->open = pc110pad_open;\r\npc110pad_dev->close = pc110pad_close;\r\nerr = input_register_device(pc110pad_dev);\r\nif (err)\r\ngoto err_free_dev;\r\nreturn 0;\r\nerr_free_dev:\r\ninput_free_device(pc110pad_dev);\r\nerr_free_irq:\r\nfree_irq(pc110pad_irq, NULL);\r\nerr_release_region:\r\nrelease_region(pc110pad_io, 4);\r\nreturn err;\r\n}\r\nstatic void __exit pc110pad_exit(void)\r\n{\r\noutb(PC110PAD_OFF, pc110pad_io + 2);\r\nfree_irq(pc110pad_irq, NULL);\r\ninput_unregister_device(pc110pad_dev);\r\nrelease_region(pc110pad_io, 4);\r\n}
