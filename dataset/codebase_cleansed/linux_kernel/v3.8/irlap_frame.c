static inline void irlap_insert_info(struct irlap_cb *self,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irda_skb_cb *cb = (struct irda_skb_cb *) skb->cb;\r\ncb->magic = LAP_MAGIC;\r\ncb->mtt = self->mtt_required;\r\ncb->next_speed = self->speed;\r\nself->mtt_required = 0;\r\ncb->xbofs = self->bofs_count;\r\ncb->next_xbofs = self->next_bofs;\r\ncb->xbofs_delay = self->xbofs_delay;\r\nself->xbofs_delay = 0;\r\nself->bofs_count = self->next_bofs;\r\n}\r\nvoid irlap_queue_xmit(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nskb->priority = TC_PRIO_BESTEFFORT;\r\nirlap_insert_info(self, skb);\r\nif (unlikely(self->mode & IRDA_MODE_MONITOR)) {\r\nIRDA_DEBUG(3, "%s(): %s is in monitor mode\n", __func__,\r\nself->netdev->name);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ndev_queue_xmit(skb);\r\n}\r\nvoid irlap_send_snrm_frame(struct irlap_cb *self, struct qos_info *qos)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct snrm_frame *frame;\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\ntx_skb = alloc_skb(sizeof(struct snrm_frame) +\r\nIRLAP_NEGOCIATION_PARAMS_LEN,\r\nGFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nframe = (struct snrm_frame *) skb_put(tx_skb, 2);\r\nif (qos)\r\nframe->caddr = CMD_FRAME | CBROADCAST;\r\nelse\r\nframe->caddr = CMD_FRAME | self->caddr;\r\nframe->control = SNRM_CMD | PF_BIT;\r\nif (qos) {\r\nskb_put(tx_skb, 9);\r\nframe->saddr = cpu_to_le32(self->saddr);\r\nframe->daddr = cpu_to_le32(self->daddr);\r\nframe->ncaddr = self->caddr;\r\nret = irlap_insert_qos_negotiation_params(self, tx_skb);\r\nif (ret < 0) {\r\ndev_kfree_skb(tx_skb);\r\nreturn;\r\n}\r\n}\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nstatic void irlap_recv_snrm_cmd(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\nstruct snrm_frame *frame;\r\nif (pskb_may_pull(skb,sizeof(struct snrm_frame))) {\r\nframe = (struct snrm_frame *) skb->data;\r\ninfo->caddr = frame->ncaddr & 0xFE;\r\nif ((info->caddr == 0x00) || (info->caddr == 0xfe)) {\r\nIRDA_DEBUG(3, "%s(), invalid connection address!\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo->daddr = le32_to_cpu(frame->saddr);\r\ninfo->saddr = le32_to_cpu(frame->daddr);\r\nif (info->saddr != self->saddr) {\r\nIRDA_DEBUG(2, "%s(), not addressed to us!\n",\r\n__func__);\r\nreturn;\r\n}\r\nirlap_do_event(self, RECV_SNRM_CMD, skb, info);\r\n} else {\r\nirlap_do_event(self, RECV_SNRM_CMD, skb, NULL);\r\n}\r\n}\r\nvoid irlap_send_ua_response_frame(struct irlap_cb *self, struct qos_info *qos)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct ua_frame *frame;\r\nint ret;\r\nIRDA_DEBUG(2, "%s() <%ld>\n", __func__, jiffies);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\ntx_skb = alloc_skb(sizeof(struct ua_frame) +\r\nIRLAP_NEGOCIATION_PARAMS_LEN,\r\nGFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nframe = (struct ua_frame *) skb_put(tx_skb, 10);\r\nframe->caddr = self->caddr;\r\nframe->control = UA_RSP | PF_BIT;\r\nframe->saddr = cpu_to_le32(self->saddr);\r\nframe->daddr = cpu_to_le32(self->daddr);\r\nif (qos) {\r\nret = irlap_insert_qos_negotiation_params(self, tx_skb);\r\nif (ret < 0) {\r\ndev_kfree_skb(tx_skb);\r\nreturn;\r\n}\r\n}\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nvoid irlap_send_dm_frame( struct irlap_cb *self)\r\n{\r\nstruct sk_buff *tx_skb = NULL;\r\nstruct dm_frame *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\ntx_skb = alloc_skb(sizeof(struct dm_frame), GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nframe = (struct dm_frame *)skb_put(tx_skb, 2);\r\nif (self->state == LAP_NDM)\r\nframe->caddr = CBROADCAST;\r\nelse\r\nframe->caddr = self->caddr;\r\nframe->control = DM_RSP | PF_BIT;\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nvoid irlap_send_disc_frame(struct irlap_cb *self)\r\n{\r\nstruct sk_buff *tx_skb = NULL;\r\nstruct disc_frame *frame;\r\nIRDA_DEBUG(3, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\ntx_skb = alloc_skb(sizeof(struct disc_frame), GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nframe = (struct disc_frame *)skb_put(tx_skb, 2);\r\nframe->caddr = self->caddr | CMD_FRAME;\r\nframe->control = DISC_CMD | PF_BIT;\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nvoid irlap_send_discovery_xid_frame(struct irlap_cb *self, int S, __u8 s,\r\n__u8 command, discovery_t *discovery)\r\n{\r\nstruct sk_buff *tx_skb = NULL;\r\nstruct xid_frame *frame;\r\n__u32 bcast = BROADCAST;\r\n__u8 *info;\r\nIRDA_DEBUG(4, "%s(), s=%d, S=%d, command=%d\n", __func__,\r\ns, S, command);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(discovery != NULL, return;);\r\ntx_skb = alloc_skb(sizeof(struct xid_frame) + IRLAP_DISCOVERY_INFO_LEN,\r\nGFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nskb_put(tx_skb, 14);\r\nframe = (struct xid_frame *) tx_skb->data;\r\nif (command) {\r\nframe->caddr = CBROADCAST | CMD_FRAME;\r\nframe->control = XID_CMD | PF_BIT;\r\n} else {\r\nframe->caddr = CBROADCAST;\r\nframe->control = XID_RSP | PF_BIT;\r\n}\r\nframe->ident = XID_FORMAT;\r\nframe->saddr = cpu_to_le32(self->saddr);\r\nif (command)\r\nframe->daddr = cpu_to_le32(bcast);\r\nelse\r\nframe->daddr = cpu_to_le32(discovery->data.daddr);\r\nswitch (S) {\r\ncase 1:\r\nframe->flags = 0x00;\r\nbreak;\r\ncase 6:\r\nframe->flags = 0x01;\r\nbreak;\r\ncase 8:\r\nframe->flags = 0x02;\r\nbreak;\r\ncase 16:\r\nframe->flags = 0x03;\r\nbreak;\r\ndefault:\r\nframe->flags = 0x02;\r\nbreak;\r\n}\r\nframe->slotnr = s;\r\nframe->version = 0x00;\r\nif (!command || (frame->slotnr == 0xff)) {\r\nint len;\r\nif (discovery->data.hints[0] & HINT_EXTENSION) {\r\ninfo = skb_put(tx_skb, 2);\r\ninfo[0] = discovery->data.hints[0];\r\ninfo[1] = discovery->data.hints[1];\r\n} else {\r\ninfo = skb_put(tx_skb, 1);\r\ninfo[0] = discovery->data.hints[0];\r\n}\r\ninfo = skb_put(tx_skb, 1);\r\ninfo[0] = discovery->data.charset;\r\nlen = IRDA_MIN(discovery->name_len, skb_tailroom(tx_skb));\r\ninfo = skb_put(tx_skb, len);\r\nmemcpy(info, discovery->data.info, len);\r\n}\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nstatic void irlap_recv_discovery_xid_rsp(struct irlap_cb *self,\r\nstruct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\nstruct xid_frame *xid;\r\ndiscovery_t *discovery = NULL;\r\n__u8 *discovery_info;\r\nchar *text;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nif (!pskb_may_pull(skb, sizeof(struct xid_frame))) {\r\nIRDA_ERROR("%s: frame too short!\n", __func__);\r\nreturn;\r\n}\r\nxid = (struct xid_frame *) skb->data;\r\ninfo->daddr = le32_to_cpu(xid->saddr);\r\ninfo->saddr = le32_to_cpu(xid->daddr);\r\nif ((info->saddr != self->saddr) && (info->saddr != BROADCAST)) {\r\nIRDA_DEBUG(0, "%s(), frame is not addressed to us!\n",\r\n__func__);\r\nreturn;\r\n}\r\nif ((discovery = kzalloc(sizeof(discovery_t), GFP_ATOMIC)) == NULL) {\r\nIRDA_WARNING("%s: kmalloc failed!\n", __func__);\r\nreturn;\r\n}\r\ndiscovery->data.daddr = info->daddr;\r\ndiscovery->data.saddr = self->saddr;\r\ndiscovery->timestamp = jiffies;\r\nIRDA_DEBUG(4, "%s(), daddr=%08x\n", __func__,\r\ndiscovery->data.daddr);\r\ndiscovery_info = skb_pull(skb, sizeof(struct xid_frame));\r\ndiscovery->data.hints[0] = discovery_info[0];\r\nif (discovery_info[0] & HINT_EXTENSION) {\r\nIRDA_DEBUG(4, "EXTENSION\n");\r\ndiscovery->data.hints[1] = discovery_info[1];\r\ndiscovery->data.charset = discovery_info[2];\r\ntext = (char *) &discovery_info[3];\r\n} else {\r\ndiscovery->data.hints[1] = 0;\r\ndiscovery->data.charset = discovery_info[1];\r\ntext = (char *) &discovery_info[2];\r\n}\r\nskb->data[skb->len] = '\0';\r\nstrncpy(discovery->data.info, text, NICKNAME_MAX_LEN);\r\ndiscovery->name_len = strlen(discovery->data.info);\r\ninfo->discovery = discovery;\r\nirlap_do_event(self, RECV_DISCOVERY_XID_RSP, skb, info);\r\n}\r\nstatic void irlap_recv_discovery_xid_cmd(struct irlap_cb *self,\r\nstruct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\nstruct xid_frame *xid;\r\ndiscovery_t *discovery = NULL;\r\n__u8 *discovery_info;\r\nchar *text;\r\nif (!pskb_may_pull(skb, sizeof(struct xid_frame))) {\r\nIRDA_ERROR("%s: frame too short!\n", __func__);\r\nreturn;\r\n}\r\nxid = (struct xid_frame *) skb->data;\r\ninfo->daddr = le32_to_cpu(xid->saddr);\r\ninfo->saddr = le32_to_cpu(xid->daddr);\r\nif ((info->saddr != self->saddr) && (info->saddr != BROADCAST)) {\r\nIRDA_DEBUG(0, "%s(), frame is not addressed to us!\n",\r\n__func__);\r\nreturn;\r\n}\r\nswitch (xid->flags & 0x03) {\r\ncase 0x00:\r\ninfo->S = 1;\r\nbreak;\r\ncase 0x01:\r\ninfo->S = 6;\r\nbreak;\r\ncase 0x02:\r\ninfo->S = 8;\r\nbreak;\r\ncase 0x03:\r\ninfo->S = 16;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ninfo->s = xid->slotnr;\r\ndiscovery_info = skb_pull(skb, sizeof(struct xid_frame));\r\nif (info->s == 0xff) {\r\nif((discovery_info == NULL) ||\r\n!pskb_may_pull(skb, 3)) {\r\nIRDA_ERROR("%s: discovery frame too short!\n",\r\n__func__);\r\nreturn;\r\n}\r\ndiscovery = kmalloc(sizeof(discovery_t), GFP_ATOMIC);\r\nif (!discovery) {\r\nIRDA_WARNING("%s: unable to malloc!\n", __func__);\r\nreturn;\r\n}\r\ndiscovery->data.daddr = info->daddr;\r\ndiscovery->data.saddr = self->saddr;\r\ndiscovery->timestamp = jiffies;\r\ndiscovery->data.hints[0] = discovery_info[0];\r\nif (discovery_info[0] & HINT_EXTENSION) {\r\ndiscovery->data.hints[1] = discovery_info[1];\r\ndiscovery->data.charset = discovery_info[2];\r\ntext = (char *) &discovery_info[3];\r\n} else {\r\ndiscovery->data.hints[1] = 0;\r\ndiscovery->data.charset = discovery_info[1];\r\ntext = (char *) &discovery_info[2];\r\n}\r\nskb->data[skb->len] = '\0';\r\nstrncpy(discovery->data.info, text, NICKNAME_MAX_LEN);\r\ndiscovery->name_len = strlen(discovery->data.info);\r\ninfo->discovery = discovery;\r\n} else\r\ninfo->discovery = NULL;\r\nirlap_do_event(self, RECV_DISCOVERY_XID_CMD, skb, info);\r\n}\r\nvoid irlap_send_rr_frame(struct irlap_cb *self, int command)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct rr_frame *frame;\r\ntx_skb = alloc_skb(sizeof(struct rr_frame), GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nframe = (struct rr_frame *)skb_put(tx_skb, 2);\r\nframe->caddr = self->caddr;\r\nframe->caddr |= (command) ? CMD_FRAME : 0;\r\nframe->control = RR | PF_BIT | (self->vr << 5);\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nvoid irlap_send_rd_frame(struct irlap_cb *self)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct rd_frame *frame;\r\ntx_skb = alloc_skb(sizeof(struct rd_frame), GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nframe = (struct rd_frame *)skb_put(tx_skb, 2);\r\nframe->caddr = self->caddr;\r\nframe->caddr = RD_RSP | PF_BIT;\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nstatic inline void irlap_recv_rr_frame(struct irlap_cb *self,\r\nstruct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\ninfo->nr = skb->data[1] >> 5;\r\nif (command)\r\nirlap_do_event(self, RECV_RR_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_RR_RSP, skb, info);\r\n}\r\nstatic void irlap_recv_rnr_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\ninfo->nr = skb->data[1] >> 5;\r\nIRDA_DEBUG(4, "%s(), nr=%d, %ld\n", __func__, info->nr, jiffies);\r\nif (command)\r\nirlap_do_event(self, RECV_RNR_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_RNR_RSP, skb, info);\r\n}\r\nstatic void irlap_recv_rej_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\nIRDA_DEBUG(0, "%s()\n", __func__);\r\ninfo->nr = skb->data[1] >> 5;\r\nif (command)\r\nirlap_do_event(self, RECV_REJ_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_REJ_RSP, skb, info);\r\n}\r\nstatic void irlap_recv_srej_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\nIRDA_DEBUG(0, "%s()\n", __func__);\r\ninfo->nr = skb->data[1] >> 5;\r\nif (command)\r\nirlap_do_event(self, RECV_SREJ_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_SREJ_RSP, skb, info);\r\n}\r\nstatic void irlap_recv_disc_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nif (command)\r\nirlap_do_event(self, RECV_DISC_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_RD_RSP, skb, info);\r\n}\r\nstatic inline void irlap_recv_ua_frame(struct irlap_cb *self,\r\nstruct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\nirlap_do_event(self, RECV_UA_RSP, skb, info);\r\n}\r\nvoid irlap_send_data_primary(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb;\r\nif (skb->data[1] == I_FRAME) {\r\nskb->data[1] = I_FRAME | (self->vs << 1);\r\nskb_get(skb);\r\nskb_queue_tail(&self->wx_list, skb);\r\ntx_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (tx_skb == NULL) {\r\nreturn;\r\n}\r\nself->vs = (self->vs + 1) % 8;\r\nself->ack_required = FALSE;\r\nself->window -= 1;\r\nirlap_send_i_frame( self, tx_skb, CMD_FRAME);\r\n} else {\r\nIRDA_DEBUG(4, "%s(), sending unreliable frame\n", __func__);\r\nirlap_send_ui_frame(self, skb_get(skb), self->caddr, CMD_FRAME);\r\nself->window -= 1;\r\n}\r\n}\r\nvoid irlap_send_data_primary_poll(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb;\r\nint transmission_time;\r\ndel_timer(&self->poll_timer);\r\nif (skb->data[1] == I_FRAME) {\r\nskb->data[1] = I_FRAME | (self->vs << 1);\r\nskb_get(skb);\r\nskb_queue_tail(&self->wx_list, skb);\r\ntx_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (tx_skb == NULL) {\r\nreturn;\r\n}\r\ntx_skb->data[1] |= PF_BIT;\r\nself->vs = (self->vs + 1) % 8;\r\nself->ack_required = FALSE;\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_send_i_frame(self, tx_skb, CMD_FRAME);\r\n} else {\r\nIRDA_DEBUG(4, "%s(), sending unreliable frame\n", __func__);\r\nif (self->ack_required) {\r\nirlap_send_ui_frame(self, skb_get(skb), self->caddr, CMD_FRAME);\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_send_rr_frame(self, CMD_FRAME);\r\nself->ack_required = FALSE;\r\n} else {\r\nskb->data[1] |= PF_BIT;\r\nirlap_next_state(self, LAP_NRM_P);\r\nirlap_send_ui_frame(self, skb_get(skb), self->caddr, CMD_FRAME);\r\n}\r\n}\r\ntransmission_time = self->final_timeout;\r\nself->window = self->window_size;\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\ntransmission_time -= (self->final_timeout * self->bytes_left\r\n/ self->line_capacity);\r\nIRDA_DEBUG(4, "%s() adjusting transmission_time : ft=%d, bl=%d, lc=%d -> tt=%d\n", __func__, self->final_timeout, self->bytes_left, self->line_capacity, transmission_time);\r\nself->bytes_left = self->line_capacity;\r\n#endif\r\nirlap_start_final_timer(self, self->final_timeout + transmission_time);\r\n}\r\nvoid irlap_send_data_secondary_final(struct irlap_cb *self,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb = NULL;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nif (skb->data[1] == I_FRAME) {\r\nskb->data[1] = I_FRAME | (self->vs << 1);\r\nskb_get(skb);\r\nskb_queue_tail(&self->wx_list, skb);\r\ntx_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (tx_skb == NULL) {\r\nreturn;\r\n}\r\ntx_skb->data[1] |= PF_BIT;\r\nself->vs = (self->vs + 1) % 8;\r\nself->ack_required = FALSE;\r\nirlap_send_i_frame(self, tx_skb, RSP_FRAME);\r\n} else {\r\nif (self->ack_required) {\r\nirlap_send_ui_frame(self, skb_get(skb), self->caddr, RSP_FRAME);\r\nirlap_send_rr_frame(self, RSP_FRAME);\r\nself->ack_required = FALSE;\r\n} else {\r\nskb->data[1] |= PF_BIT;\r\nirlap_send_ui_frame(self, skb_get(skb), self->caddr, RSP_FRAME);\r\n}\r\n}\r\nself->window = self->window_size;\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nself->bytes_left = self->line_capacity;\r\n#endif\r\nirlap_start_wd_timer(self, self->wd_timeout);\r\n}\r\nvoid irlap_send_data_secondary(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb = NULL;\r\nif (skb->data[1] == I_FRAME) {\r\nskb->data[1] = I_FRAME | (self->vs << 1);\r\nskb_get(skb);\r\nskb_queue_tail(&self->wx_list, skb);\r\ntx_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (tx_skb == NULL) {\r\nreturn;\r\n}\r\nself->vs = (self->vs + 1) % 8;\r\nself->ack_required = FALSE;\r\nself->window -= 1;\r\nirlap_send_i_frame(self, tx_skb, RSP_FRAME);\r\n} else {\r\nirlap_send_ui_frame(self, skb_get(skb), self->caddr, RSP_FRAME);\r\nself->window -= 1;\r\n}\r\n}\r\nvoid irlap_resend_rejected_frames(struct irlap_cb *self, int command)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct sk_buff *skb;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nskb_queue_walk(&self->wx_list, skb) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\ntx_skb = skb_copy(skb, GFP_ATOMIC);\r\nif (!tx_skb) {\r\nIRDA_DEBUG(0, "%s(), unable to copy\n", __func__);\r\nreturn;\r\n}\r\ntx_skb->data[1] &= 0x0f;\r\nif (skb_queue_is_last(&self->wx_list, skb))\r\ntx_skb->data[1] |= PF_BIT;\r\nelse\r\ntx_skb->data[1] &= ~PF_BIT;\r\nirlap_send_i_frame(self, tx_skb, command);\r\n}\r\n#if 0\r\nwhile (!skb_queue_empty(&self->txq)) {\r\nIRDA_DEBUG(0, "%s(), sending additional frames!\n", __func__);\r\nif (self->window > 0) {\r\nskb = skb_dequeue( &self->txq);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nif ((self->window > 1) &&\r\n!skb_queue_empty(&self->txq)) {\r\nirlap_send_data_primary(self, skb);\r\n} else {\r\nirlap_send_data_primary_poll(self, skb);\r\n}\r\nkfree_skb(skb);\r\n}\r\n}\r\n#endif\r\n}\r\nvoid irlap_resend_rejected_frame(struct irlap_cb *self, int command)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct sk_buff *skb;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nskb = skb_peek(&self->wx_list);\r\nif (skb != NULL) {\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\ntx_skb = skb_copy(skb, GFP_ATOMIC);\r\nif (!tx_skb) {\r\nIRDA_DEBUG(0, "%s(), unable to copy\n", __func__);\r\nreturn;\r\n}\r\ntx_skb->data[1] &= 0x0f;\r\ntx_skb->data[1] |= PF_BIT;\r\nirlap_send_i_frame(self, tx_skb, command);\r\n}\r\n}\r\nvoid irlap_send_ui_frame(struct irlap_cb *self, struct sk_buff *skb,\r\n__u8 caddr, int command)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nskb->data[0] = caddr | ((command) ? CMD_FRAME : 0);\r\nirlap_queue_xmit(self, skb);\r\n}\r\nstatic void irlap_send_i_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nint command)\r\n{\r\nskb->data[0] = self->caddr;\r\nskb->data[0] |= (command) ? CMD_FRAME : 0;\r\nskb->data[1] |= (self->vr << 5);\r\nirlap_queue_xmit(self, skb);\r\n}\r\nstatic inline void irlap_recv_i_frame(struct irlap_cb *self,\r\nstruct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\ninfo->nr = skb->data[1] >> 5;\r\ninfo->pf = skb->data[1] & PF_BIT;\r\ninfo->ns = (skb->data[1] >> 1) & 0x07;\r\nif (command)\r\nirlap_do_event(self, RECV_I_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_I_RSP, skb, info);\r\n}\r\nstatic void irlap_recv_ui_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\nIRDA_DEBUG( 4, "%s()\n", __func__);\r\ninfo->pf = skb->data[1] & PF_BIT;\r\nirlap_do_event(self, RECV_UI_FRAME, skb, info);\r\n}\r\nstatic void irlap_recv_frmr_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info)\r\n{\r\n__u8 *frame;\r\nint w, x, y, z;\r\nIRDA_DEBUG(0, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(info != NULL, return;);\r\nif (!pskb_may_pull(skb, 4)) {\r\nIRDA_ERROR("%s: frame too short!\n", __func__);\r\nreturn;\r\n}\r\nframe = skb->data;\r\ninfo->nr = frame[2] >> 5;\r\ninfo->pf = frame[2] & PF_BIT;\r\ninfo->ns = (frame[2] >> 1) & 0x07;\r\nw = frame[3] & 0x01;\r\nx = frame[3] & 0x02;\r\ny = frame[3] & 0x04;\r\nz = frame[3] & 0x08;\r\nif (w) {\r\nIRDA_DEBUG(0, "Rejected control field is undefined or not "\r\n"implemented.\n");\r\n}\r\nif (x) {\r\nIRDA_DEBUG(0, "Rejected control field was invalid because it "\r\n"contained a non permitted I field.\n");\r\n}\r\nif (y) {\r\nIRDA_DEBUG(0, "Received I field exceeded the maximum negotiated "\r\n"for the existing connection or exceeded the maximum "\r\n"this station supports if no connection exists.\n");\r\n}\r\nif (z) {\r\nIRDA_DEBUG(0, "Rejected control field control field contained an "\r\n"invalid Nr count.\n");\r\n}\r\nirlap_do_event(self, RECV_FRMR_RSP, skb, info);\r\n}\r\nvoid irlap_send_test_frame(struct irlap_cb *self, __u8 caddr, __u32 daddr,\r\nstruct sk_buff *cmd)\r\n{\r\nstruct sk_buff *tx_skb;\r\nstruct test_frame *frame;\r\n__u8 *info;\r\ntx_skb = alloc_skb(cmd->len + sizeof(struct test_frame), GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nif (caddr == CBROADCAST) {\r\nframe = (struct test_frame *)\r\nskb_put(tx_skb, sizeof(struct test_frame));\r\nframe->saddr = cpu_to_le32(self->saddr);\r\nframe->daddr = cpu_to_le32(daddr);\r\n} else\r\nframe = (struct test_frame *) skb_put(tx_skb, LAP_ADDR_HEADER + LAP_CTRL_HEADER);\r\nframe->caddr = caddr;\r\nframe->control = TEST_RSP | PF_BIT;\r\ninfo = skb_put(tx_skb, cmd->len);\r\nmemcpy(info, cmd->data, cmd->len);\r\nirlap_wait_min_turn_around(self, &self->qos_tx);\r\nirlap_queue_xmit(self, tx_skb);\r\n}\r\nstatic void irlap_recv_test_frame(struct irlap_cb *self, struct sk_buff *skb,\r\nstruct irlap_info *info, int command)\r\n{\r\nstruct test_frame *frame;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nif (!pskb_may_pull(skb, sizeof(*frame))) {\r\nIRDA_ERROR("%s: frame too short!\n", __func__);\r\nreturn;\r\n}\r\nframe = (struct test_frame *) skb->data;\r\nif (info->caddr == CBROADCAST) {\r\nif (skb->len < sizeof(struct test_frame)) {\r\nIRDA_DEBUG(0, "%s() test frame too short!\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo->daddr = le32_to_cpu(frame->saddr);\r\ninfo->saddr = le32_to_cpu(frame->daddr);\r\nif ((info->saddr != self->saddr) &&\r\n(info->saddr != BROADCAST)) {\r\nreturn;\r\n}\r\n}\r\nif (command)\r\nirlap_do_event(self, RECV_TEST_CMD, skb, info);\r\nelse\r\nirlap_do_event(self, RECV_TEST_RSP, skb, info);\r\n}\r\nint irlap_driver_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *ptype, struct net_device *orig_dev)\r\n{\r\nstruct irlap_info info;\r\nstruct irlap_cb *self;\r\nint command;\r\n__u8 control;\r\nint ret = -1;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto out;\r\nself = (struct irlap_cb *) dev->atalk_ptr;\r\nif (!self || self->magic != LAP_MAGIC)\r\ngoto err;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {\r\nIRDA_ERROR("%s: can't clone shared skb!\n", __func__);\r\ngoto err;\r\n}\r\nif (!pskb_may_pull(skb, 2)) {\r\nIRDA_ERROR("%s: frame too short!\n", __func__);\r\ngoto err;\r\n}\r\ncommand = skb->data[0] & CMD_FRAME;\r\ninfo.caddr = skb->data[0] & CBROADCAST;\r\ninfo.pf = skb->data[1] & PF_BIT;\r\ninfo.control = skb->data[1] & ~PF_BIT;\r\ncontrol = info.control;\r\nif ((info.caddr != self->caddr) && (info.caddr != CBROADCAST)) {\r\nIRDA_DEBUG(0, "%s(), wrong connection address!\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (~control & 0x01) {\r\nirlap_recv_i_frame(self, skb, &info, command);\r\ngoto out;\r\n}\r\nif (~control & 0x02) {\r\nswitch (control & 0x0f) {\r\ncase RR:\r\nirlap_recv_rr_frame(self, skb, &info, command);\r\nbreak;\r\ncase RNR:\r\nirlap_recv_rnr_frame(self, skb, &info, command);\r\nbreak;\r\ncase REJ:\r\nirlap_recv_rej_frame(self, skb, &info, command);\r\nbreak;\r\ncase SREJ:\r\nirlap_recv_srej_frame(self, skb, &info, command);\r\nbreak;\r\ndefault:\r\nIRDA_WARNING("%s: Unknown S-frame %02x received!\n",\r\n__func__, info.control);\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nswitch (control) {\r\ncase XID_RSP:\r\nirlap_recv_discovery_xid_rsp(self, skb, &info);\r\nbreak;\r\ncase XID_CMD:\r\nirlap_recv_discovery_xid_cmd(self, skb, &info);\r\nbreak;\r\ncase SNRM_CMD:\r\nirlap_recv_snrm_cmd(self, skb, &info);\r\nbreak;\r\ncase DM_RSP:\r\nirlap_do_event(self, RECV_DM_RSP, skb, &info);\r\nbreak;\r\ncase DISC_CMD:\r\nirlap_recv_disc_frame(self, skb, &info, command);\r\nbreak;\r\ncase TEST_CMD:\r\nirlap_recv_test_frame(self, skb, &info, command);\r\nbreak;\r\ncase UA_RSP:\r\nirlap_recv_ua_frame(self, skb, &info);\r\nbreak;\r\ncase FRMR_RSP:\r\nirlap_recv_frmr_frame(self, skb, &info);\r\nbreak;\r\ncase UI_FRAME:\r\nirlap_recv_ui_frame(self, skb, &info);\r\nbreak;\r\ndefault:\r\nIRDA_WARNING("%s: Unknown frame %02x received!\n",\r\n__func__, info.control);\r\nbreak;\r\n}\r\nout:\r\nret = 0;\r\nerr:\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}
