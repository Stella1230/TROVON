static void user_reader_timeout(unsigned long ptr)\r\n{\r\nstruct tpm_chip *chip = (struct tpm_chip *) ptr;\r\nschedule_work(&chip->work);\r\n}\r\nstatic void timeout_work(struct work_struct *work)\r\n{\r\nstruct tpm_chip *chip = container_of(work, struct tpm_chip, work);\r\nmutex_lock(&chip->buffer_mutex);\r\natomic_set(&chip->data_pending, 0);\r\nmemset(chip->data_buffer, 0, TPM_BUFSIZE);\r\nmutex_unlock(&chip->buffer_mutex);\r\n}\r\nunsigned long tpm_calc_ordinal_duration(struct tpm_chip *chip,\r\nu32 ordinal)\r\n{\r\nint duration_idx = TPM_UNDEFINED;\r\nint duration = 0;\r\nif (ordinal < TPM_MAX_ORDINAL)\r\nduration_idx = tpm_ordinal_duration[ordinal];\r\nelse if ((ordinal & TPM_PROTECTED_ORDINAL_MASK) <\r\nTPM_MAX_PROTECTED_ORDINAL)\r\nduration_idx =\r\ntpm_protected_ordinal_duration[ordinal &\r\nTPM_PROTECTED_ORDINAL_MASK];\r\nif (duration_idx != TPM_UNDEFINED)\r\nduration = chip->vendor.duration[duration_idx];\r\nif (duration <= 0)\r\nreturn 2 * 60 * HZ;\r\nelse\r\nreturn duration;\r\n}\r\nstatic ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,\r\nsize_t bufsiz)\r\n{\r\nssize_t rc;\r\nu32 count, ordinal;\r\nunsigned long stop;\r\nif (bufsiz > TPM_BUFSIZE)\r\nbufsiz = TPM_BUFSIZE;\r\ncount = be32_to_cpu(*((__be32 *) (buf + 2)));\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nif (count == 0)\r\nreturn -ENODATA;\r\nif (count > bufsiz) {\r\ndev_err(chip->dev,\r\n"invalid count value %x %zx \n", count, bufsiz);\r\nreturn -E2BIG;\r\n}\r\nmutex_lock(&chip->tpm_mutex);\r\nif ((rc = chip->vendor.send(chip, (u8 *) buf, count)) < 0) {\r\ndev_err(chip->dev,\r\n"tpm_transmit: tpm_send: error %zd\n", rc);\r\ngoto out;\r\n}\r\nif (chip->vendor.irq)\r\ngoto out_recv;\r\nstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\r\ndo {\r\nu8 status = chip->vendor.status(chip);\r\nif ((status & chip->vendor.req_complete_mask) ==\r\nchip->vendor.req_complete_val)\r\ngoto out_recv;\r\nif ((status == chip->vendor.req_canceled)) {\r\ndev_err(chip->dev, "Operation Canceled\n");\r\nrc = -ECANCELED;\r\ngoto out;\r\n}\r\nmsleep(TPM_TIMEOUT);\r\nrmb();\r\n} while (time_before(jiffies, stop));\r\nchip->vendor.cancel(chip);\r\ndev_err(chip->dev, "Operation Timed out\n");\r\nrc = -ETIME;\r\ngoto out;\r\nout_recv:\r\nrc = chip->vendor.recv(chip, (u8 *) buf, bufsiz);\r\nif (rc < 0)\r\ndev_err(chip->dev,\r\n"tpm_transmit: tpm_recv: error %zd\n", rc);\r\nout:\r\nmutex_unlock(&chip->tpm_mutex);\r\nreturn rc;\r\n}\r\nstatic ssize_t transmit_cmd(struct tpm_chip *chip, struct tpm_cmd_t *cmd,\r\nint len, const char *desc)\r\n{\r\nint err;\r\nlen = tpm_transmit(chip,(u8 *) cmd, len);\r\nif (len < 0)\r\nreturn len;\r\nelse if (len < TPM_HEADER_SIZE)\r\nreturn -EFAULT;\r\nerr = be32_to_cpu(cmd->header.out.return_code);\r\nif (err != 0)\r\ndev_err(chip->dev, "A TPM error (%d) occurred %s\n", err, desc);\r\nreturn err;\r\n}\r\nssize_t tpm_getcap(struct device *dev, __be32 subcap_id, cap_t *cap,\r\nconst char *desc)\r\n{\r\nstruct tpm_cmd_t tpm_cmd;\r\nint rc;\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\ntpm_cmd.header.in = tpm_getcap_header;\r\nif (subcap_id == CAP_VERSION_1_1 || subcap_id == CAP_VERSION_1_2) {\r\ntpm_cmd.params.getcap_in.cap = subcap_id;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(0);\r\ntpm_cmd.header.in.length -= cpu_to_be32(sizeof(__be32));\r\n} else {\r\nif (subcap_id == TPM_CAP_FLAG_PERM ||\r\nsubcap_id == TPM_CAP_FLAG_VOL)\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_FLAG;\r\nelse\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = subcap_id;\r\n}\r\nrc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);\r\nif (!rc)\r\n*cap = tpm_cmd.params.getcap_out.cap;\r\nreturn rc;\r\n}\r\nvoid tpm_gen_interrupt(struct tpm_chip *chip)\r\n{\r\nstruct tpm_cmd_t tpm_cmd;\r\nssize_t rc;\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\r\nrc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\r\n"attempting to determine the timeouts");\r\n}\r\nint tpm_get_timeouts(struct tpm_chip *chip)\r\n{\r\nstruct tpm_cmd_t tpm_cmd;\r\nstruct timeout_t *timeout_cap;\r\nstruct duration_t *duration_cap;\r\nssize_t rc;\r\nu32 timeout;\r\nunsigned int scale = 1;\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\r\nrc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\r\n"attempting to determine the timeouts");\r\nif (rc)\r\ngoto duration;\r\nif (be32_to_cpu(tpm_cmd.header.out.return_code) != 0 ||\r\nbe32_to_cpu(tpm_cmd.header.out.length)\r\n!= sizeof(tpm_cmd.header.out) + sizeof(u32) + 4 * sizeof(u32))\r\nreturn -EINVAL;\r\ntimeout_cap = &tpm_cmd.params.getcap_out.cap.timeout;\r\ntimeout = be32_to_cpu(timeout_cap->a);\r\nif (timeout && timeout < 1000) {\r\nscale = 1000;\r\nchip->vendor.timeout_adjusted = true;\r\n}\r\nif (timeout)\r\nchip->vendor.timeout_a = usecs_to_jiffies(timeout * scale);\r\ntimeout = be32_to_cpu(timeout_cap->b);\r\nif (timeout)\r\nchip->vendor.timeout_b = usecs_to_jiffies(timeout * scale);\r\ntimeout = be32_to_cpu(timeout_cap->c);\r\nif (timeout)\r\nchip->vendor.timeout_c = usecs_to_jiffies(timeout * scale);\r\ntimeout = be32_to_cpu(timeout_cap->d);\r\nif (timeout)\r\nchip->vendor.timeout_d = usecs_to_jiffies(timeout * scale);\r\nduration:\r\ntpm_cmd.header.in = tpm_getcap_header;\r\ntpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\r\ntpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\r\ntpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;\r\nrc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\r\n"attempting to determine the durations");\r\nif (rc)\r\nreturn rc;\r\nif (be32_to_cpu(tpm_cmd.header.out.return_code) != 0 ||\r\nbe32_to_cpu(tpm_cmd.header.out.length)\r\n!= sizeof(tpm_cmd.header.out) + sizeof(u32) + 3 * sizeof(u32))\r\nreturn -EINVAL;\r\nduration_cap = &tpm_cmd.params.getcap_out.cap.duration;\r\nchip->vendor.duration[TPM_SHORT] =\r\nusecs_to_jiffies(be32_to_cpu(duration_cap->tpm_short));\r\nchip->vendor.duration[TPM_MEDIUM] =\r\nusecs_to_jiffies(be32_to_cpu(duration_cap->tpm_medium));\r\nchip->vendor.duration[TPM_LONG] =\r\nusecs_to_jiffies(be32_to_cpu(duration_cap->tpm_long));\r\nif (chip->vendor.duration[TPM_SHORT] < (HZ / 100)) {\r\nchip->vendor.duration[TPM_SHORT] = HZ;\r\nchip->vendor.duration[TPM_MEDIUM] *= 1000;\r\nchip->vendor.duration[TPM_LONG] *= 1000;\r\nchip->vendor.duration_adjusted = true;\r\ndev_info(chip->dev, "Adjusting TPM timeout parameters.");\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpm_continue_selftest(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nstruct tpm_cmd_t cmd;\r\ncmd.header.in = continue_selftest_header;\r\nrc = transmit_cmd(chip, &cmd, CONTINUE_SELFTEST_RESULT_SIZE,\r\n"continue selftest");\r\nreturn rc;\r\n}\r\nssize_t tpm_show_enabled(struct device * dev, struct device_attribute * attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(dev, TPM_CAP_FLAG_PERM, &cap,\r\n"attempting to determine the permanent enabled state");\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", !cap.perm_flags.disable);\r\nreturn rc;\r\n}\r\nssize_t tpm_show_active(struct device * dev, struct device_attribute * attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(dev, TPM_CAP_FLAG_PERM, &cap,\r\n"attempting to determine the permanent active state");\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", !cap.perm_flags.deactivated);\r\nreturn rc;\r\n}\r\nssize_t tpm_show_owned(struct device * dev, struct device_attribute * attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(dev, TPM_CAP_PROP_OWNER, &cap,\r\n"attempting to determine the owner state");\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", cap.owned);\r\nreturn rc;\r\n}\r\nssize_t tpm_show_temp_deactivated(struct device * dev,\r\nstruct device_attribute * attr, char *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nrc = tpm_getcap(dev, TPM_CAP_FLAG_VOL, &cap,\r\n"attempting to determine the temporary state");\r\nif (rc)\r\nreturn 0;\r\nrc = sprintf(buf, "%d\n", cap.stclear_flags.deactivated);\r\nreturn rc;\r\n}\r\nstatic struct tpm_chip *tpm_chip_find_get(int chip_num)\r\n{\r\nstruct tpm_chip *pos, *chip = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\r\nif (chip_num != TPM_ANY_NUM && chip_num != pos->dev_num)\r\ncontinue;\r\nif (try_module_get(pos->dev->driver->owner)) {\r\nchip = pos;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn chip;\r\n}\r\nstatic int __tpm_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)\r\n{\r\nint rc;\r\nstruct tpm_cmd_t cmd;\r\ncmd.header.in = pcrread_header;\r\ncmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);\r\nrc = transmit_cmd(chip, &cmd, READ_PCR_RESULT_SIZE,\r\n"attempting to read a pcr value");\r\nif (rc == 0)\r\nmemcpy(res_buf, cmd.params.pcrread_out.pcr_result,\r\nTPM_DIGEST_SIZE);\r\nreturn rc;\r\n}\r\nint tpm_pcr_read(u32 chip_num, int pcr_idx, u8 *res_buf)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nrc = __tpm_pcr_read(chip, pcr_idx, res_buf);\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\nint tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)\r\n{\r\nstruct tpm_cmd_t cmd;\r\nint rc;\r\nstruct tpm_chip *chip;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\ncmd.header.in = pcrextend_header;\r\ncmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);\r\nmemcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);\r\nrc = transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\r\n"attempting extend a PCR value");\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\nint tpm_do_selftest(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nunsigned int loops;\r\nunsigned int delay_msec = 1000;\r\nunsigned long duration;\r\nstruct tpm_cmd_t cmd;\r\nduration = tpm_calc_ordinal_duration(chip,\r\nTPM_ORD_CONTINUE_SELFTEST);\r\nloops = jiffies_to_msecs(duration) / delay_msec;\r\nrc = tpm_continue_selftest(chip);\r\nif (rc)\r\nreturn rc;\r\ndo {\r\ncmd.header.in = pcrread_header;\r\ncmd.params.pcrread_in.pcr_idx = cpu_to_be32(0);\r\nrc = tpm_transmit(chip, (u8 *) &cmd, READ_PCR_RESULT_SIZE);\r\nif (rc < TPM_HEADER_SIZE)\r\nreturn -EFAULT;\r\nrc = be32_to_cpu(cmd.header.out.return_code);\r\nif (rc == TPM_ERR_DISABLED || rc == TPM_ERR_DEACTIVATED) {\r\ndev_info(chip->dev,\r\n"TPM is disabled/deactivated (0x%X)\n", rc);\r\nreturn 0;\r\n}\r\nif (rc != TPM_WARN_DOING_SELFTEST)\r\nreturn rc;\r\nmsleep(delay_msec);\r\n} while (--loops > 0);\r\nreturn rc;\r\n}\r\nint tpm_send(u32 chip_num, void *cmd, size_t buflen)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nrc = transmit_cmd(chip, cmd, buflen, "attempting tpm_cmd");\r\ntpm_chip_put(chip);\r\nreturn rc;\r\n}\r\nssize_t tpm_show_pcrs(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nu8 digest[TPM_DIGEST_SIZE];\r\nssize_t rc;\r\nint i, j, num_pcrs;\r\nchar *str = buf;\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nrc = tpm_getcap(dev, TPM_CAP_PROP_PCR, &cap,\r\n"attempting to determine the number of PCRS");\r\nif (rc)\r\nreturn 0;\r\nnum_pcrs = be32_to_cpu(cap.num_pcrs);\r\nfor (i = 0; i < num_pcrs; i++) {\r\nrc = __tpm_pcr_read(chip, i, digest);\r\nif (rc)\r\nbreak;\r\nstr += sprintf(str, "PCR-%02d: ", i);\r\nfor (j = 0; j < TPM_DIGEST_SIZE; j++)\r\nstr += sprintf(str, "%02X ", digest[j]);\r\nstr += sprintf(str, "\n");\r\n}\r\nreturn str - buf;\r\n}\r\nssize_t tpm_show_pubek(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 *data;\r\nstruct tpm_cmd_t tpm_cmd;\r\nssize_t err;\r\nint i, rc;\r\nchar *str = buf;\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\ntpm_cmd.header.in = tpm_readpubek_header;\r\nerr = transmit_cmd(chip, &tpm_cmd, READ_PUBEK_RESULT_SIZE,\r\n"attempting to read the PUBEK");\r\nif (err)\r\ngoto out;\r\ndata = tpm_cmd.params.readpubek_out_buffer;\r\nstr +=\r\nsprintf(str,\r\n"Algorithm: %02X %02X %02X %02X\n"\r\n"Encscheme: %02X %02X\n"\r\n"Sigscheme: %02X %02X\n"\r\n"Parameters: %02X %02X %02X %02X "\r\n"%02X %02X %02X %02X "\r\n"%02X %02X %02X %02X\n"\r\n"Modulus length: %d\n"\r\n"Modulus:\n",\r\ndata[0], data[1], data[2], data[3],\r\ndata[4], data[5],\r\ndata[6], data[7],\r\ndata[12], data[13], data[14], data[15],\r\ndata[16], data[17], data[18], data[19],\r\ndata[20], data[21], data[22], data[23],\r\nbe32_to_cpu(*((__be32 *) (data + 24))));\r\nfor (i = 0; i < 256; i++) {\r\nstr += sprintf(str, "%02X ", data[i + 28]);\r\nif ((i + 1) % 16 == 0)\r\nstr += sprintf(str, "\n");\r\n}\r\nout:\r\nrc = str - buf;\r\nreturn rc;\r\n}\r\nssize_t tpm_show_caps(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nchar *str = buf;\r\nrc = tpm_getcap(dev, TPM_CAP_PROP_MANUFACTURER, &cap,\r\n"attempting to determine the manufacturer");\r\nif (rc)\r\nreturn 0;\r\nstr += sprintf(str, "Manufacturer: 0x%x\n",\r\nbe32_to_cpu(cap.manufacturer_id));\r\nrc = tpm_getcap(dev, CAP_VERSION_1_1, &cap,\r\n"attempting to determine the 1.1 version");\r\nif (rc)\r\nreturn 0;\r\nstr += sprintf(str,\r\n"TCG version: %d.%d\nFirmware version: %d.%d\n",\r\ncap.tpm_version.Major, cap.tpm_version.Minor,\r\ncap.tpm_version.revMajor, cap.tpm_version.revMinor);\r\nreturn str - buf;\r\n}\r\nssize_t tpm_show_caps_1_2(struct device * dev,\r\nstruct device_attribute * attr, char *buf)\r\n{\r\ncap_t cap;\r\nssize_t rc;\r\nchar *str = buf;\r\nrc = tpm_getcap(dev, TPM_CAP_PROP_MANUFACTURER, &cap,\r\n"attempting to determine the manufacturer");\r\nif (rc)\r\nreturn 0;\r\nstr += sprintf(str, "Manufacturer: 0x%x\n",\r\nbe32_to_cpu(cap.manufacturer_id));\r\nrc = tpm_getcap(dev, CAP_VERSION_1_2, &cap,\r\n"attempting to determine the 1.2 version");\r\nif (rc)\r\nreturn 0;\r\nstr += sprintf(str,\r\n"TCG version: %d.%d\nFirmware version: %d.%d\n",\r\ncap.tpm_version_1_2.Major, cap.tpm_version_1_2.Minor,\r\ncap.tpm_version_1_2.revMajor,\r\ncap.tpm_version_1_2.revMinor);\r\nreturn str - buf;\r\n}\r\nssize_t tpm_show_durations(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip->vendor.duration[TPM_LONG] == 0)\r\nreturn 0;\r\nreturn sprintf(buf, "%d %d %d [%s]\n",\r\njiffies_to_usecs(chip->vendor.duration[TPM_SHORT]),\r\njiffies_to_usecs(chip->vendor.duration[TPM_MEDIUM]),\r\njiffies_to_usecs(chip->vendor.duration[TPM_LONG]),\r\nchip->vendor.duration_adjusted\r\n? "adjusted" : "original");\r\n}\r\nssize_t tpm_show_timeouts(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d %d %d %d [%s]\n",\r\njiffies_to_usecs(chip->vendor.timeout_a),\r\njiffies_to_usecs(chip->vendor.timeout_b),\r\njiffies_to_usecs(chip->vendor.timeout_c),\r\njiffies_to_usecs(chip->vendor.timeout_d),\r\nchip->vendor.timeout_adjusted\r\n? "adjusted" : "original");\r\n}\r\nssize_t tpm_store_cancel(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip == NULL)\r\nreturn 0;\r\nchip->vendor.cancel(chip);\r\nreturn count;\r\n}\r\nint wait_for_tpm_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\r\nwait_queue_head_t *queue)\r\n{\r\nunsigned long stop;\r\nlong rc;\r\nu8 status;\r\nstatus = chip->vendor.status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\nstop = jiffies + timeout;\r\nif (chip->vendor.irq) {\r\nagain:\r\ntimeout = stop - jiffies;\r\nif ((long)timeout <= 0)\r\nreturn -ETIME;\r\nrc = wait_event_interruptible_timeout(*queue,\r\n((chip->vendor.status(chip)\r\n& mask) == mask),\r\ntimeout);\r\nif (rc > 0)\r\nreturn 0;\r\nif (rc == -ERESTARTSYS && freezing(current)) {\r\nclear_thread_flag(TIF_SIGPENDING);\r\ngoto again;\r\n}\r\n} else {\r\ndo {\r\nmsleep(TPM_TIMEOUT);\r\nstatus = chip->vendor.status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, stop));\r\n}\r\nreturn -ETIME;\r\n}\r\nint tpm_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nstruct tpm_chip *chip = NULL, *pos;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\r\nif (pos->vendor.miscdev.minor == minor) {\r\nchip = pos;\r\nget_device(chip->dev);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!chip)\r\nreturn -ENODEV;\r\nif (test_and_set_bit(0, &chip->is_open)) {\r\ndev_dbg(chip->dev, "Another process owns this TPM\n");\r\nput_device(chip->dev);\r\nreturn -EBUSY;\r\n}\r\nchip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);\r\nif (chip->data_buffer == NULL) {\r\nclear_bit(0, &chip->is_open);\r\nput_device(chip->dev);\r\nreturn -ENOMEM;\r\n}\r\natomic_set(&chip->data_pending, 0);\r\nfile->private_data = chip;\r\nreturn 0;\r\n}\r\nint tpm_release(struct inode *inode, struct file *file)\r\n{\r\nstruct tpm_chip *chip = file->private_data;\r\ndel_singleshot_timer_sync(&chip->user_read_timer);\r\nflush_work(&chip->work);\r\nfile->private_data = NULL;\r\natomic_set(&chip->data_pending, 0);\r\nkzfree(chip->data_buffer);\r\nclear_bit(0, &chip->is_open);\r\nput_device(chip->dev);\r\nreturn 0;\r\n}\r\nssize_t tpm_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct tpm_chip *chip = file->private_data;\r\nsize_t in_size = size;\r\nssize_t out_size;\r\nif (atomic_read(&chip->data_pending) != 0)\r\nreturn -EBUSY;\r\nif (in_size > TPM_BUFSIZE)\r\nreturn -E2BIG;\r\nmutex_lock(&chip->buffer_mutex);\r\nif (copy_from_user\r\n(chip->data_buffer, (void __user *) buf, in_size)) {\r\nmutex_unlock(&chip->buffer_mutex);\r\nreturn -EFAULT;\r\n}\r\nout_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);\r\nif (out_size < 0) {\r\nmutex_unlock(&chip->buffer_mutex);\r\nreturn out_size;\r\n}\r\natomic_set(&chip->data_pending, out_size);\r\nmutex_unlock(&chip->buffer_mutex);\r\nmod_timer(&chip->user_read_timer, jiffies + (60 * HZ));\r\nreturn in_size;\r\n}\r\nssize_t tpm_read(struct file *file, char __user *buf,\r\nsize_t size, loff_t *off)\r\n{\r\nstruct tpm_chip *chip = file->private_data;\r\nssize_t ret_size;\r\nint rc;\r\ndel_singleshot_timer_sync(&chip->user_read_timer);\r\nflush_work(&chip->work);\r\nret_size = atomic_read(&chip->data_pending);\r\nif (ret_size > 0) {\r\nssize_t orig_ret_size = ret_size;\r\nif (size < ret_size)\r\nret_size = size;\r\nmutex_lock(&chip->buffer_mutex);\r\nrc = copy_to_user(buf, chip->data_buffer, ret_size);\r\nmemset(chip->data_buffer, 0, orig_ret_size);\r\nif (rc)\r\nret_size = -EFAULT;\r\nmutex_unlock(&chip->buffer_mutex);\r\n}\r\natomic_set(&chip->data_pending, 0);\r\nreturn ret_size;\r\n}\r\nvoid tpm_remove_hardware(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip == NULL) {\r\ndev_err(dev, "No device data found\n");\r\nreturn;\r\n}\r\nspin_lock(&driver_lock);\r\nlist_del_rcu(&chip->list);\r\nspin_unlock(&driver_lock);\r\nsynchronize_rcu();\r\nmisc_deregister(&chip->vendor.miscdev);\r\nsysfs_remove_group(&dev->kobj, chip->vendor.attr_group);\r\ntpm_remove_ppi(&dev->kobj);\r\ntpm_bios_log_teardown(chip->bios_dir);\r\nput_device(chip->dev);\r\n}\r\nint tpm_pm_suspend(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct tpm_cmd_t cmd;\r\nint rc;\r\nu8 dummy_hash[TPM_DIGEST_SIZE] = { 0 };\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (tpm_suspend_pcr) {\r\ncmd.header.in = pcrextend_header;\r\ncmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);\r\nmemcpy(cmd.params.pcrextend_in.hash, dummy_hash,\r\nTPM_DIGEST_SIZE);\r\nrc = transmit_cmd(chip, &cmd, EXTEND_PCR_RESULT_SIZE,\r\n"extending dummy pcr before suspend");\r\n}\r\ncmd.header.in = savestate_header;\r\nrc = transmit_cmd(chip, &cmd, SAVESTATE_RESULT_SIZE,\r\n"sending savestate before suspend");\r\nreturn rc;\r\n}\r\nint tpm_pm_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nint tpm_get_random(u32 chip_num, u8 *out, size_t max)\r\n{\r\nstruct tpm_chip *chip;\r\nstruct tpm_cmd_t tpm_cmd;\r\nu32 recd, num_bytes = min_t(u32, max, TPM_MAX_RNG_DATA);\r\nint err, total = 0, retries = 5;\r\nu8 *dest = out;\r\nchip = tpm_chip_find_get(chip_num);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nif (!out || !num_bytes || max > TPM_MAX_RNG_DATA)\r\nreturn -EINVAL;\r\ndo {\r\ntpm_cmd.header.in = tpm_getrandom_header;\r\ntpm_cmd.params.getrandom_in.num_bytes = cpu_to_be32(num_bytes);\r\nerr = transmit_cmd(chip, &tpm_cmd,\r\nTPM_GETRANDOM_RESULT_SIZE + num_bytes,\r\n"attempting get random");\r\nif (err)\r\nbreak;\r\nrecd = be32_to_cpu(tpm_cmd.params.getrandom_out.rng_data_len);\r\nmemcpy(dest, tpm_cmd.params.getrandom_out.rng_data, recd);\r\ndest += recd;\r\ntotal += recd;\r\nnum_bytes -= recd;\r\n} while (retries-- && total < max);\r\nreturn total ? total : -EIO;\r\n}\r\nvoid tpm_dev_vendor_release(struct tpm_chip *chip)\r\n{\r\nif (!chip)\r\nreturn;\r\nif (chip->vendor.release)\r\nchip->vendor.release(chip->dev);\r\nclear_bit(chip->dev_num, dev_mask);\r\nkfree(chip->vendor.miscdev.name);\r\n}\r\nstatic void tpm_dev_release(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif (!chip)\r\nreturn;\r\ntpm_dev_vendor_release(chip);\r\nchip->release(dev);\r\nkfree(chip);\r\n}\r\nstruct tpm_chip *tpm_register_hardware(struct device *dev,\r\nconst struct tpm_vendor_specific *entry)\r\n{\r\n#define DEVNAME_SIZE 7\r\nchar *devname;\r\nstruct tpm_chip *chip;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\ndevname = kmalloc(DEVNAME_SIZE, GFP_KERNEL);\r\nif (chip == NULL || devname == NULL)\r\ngoto out_free;\r\nmutex_init(&chip->buffer_mutex);\r\nmutex_init(&chip->tpm_mutex);\r\nINIT_LIST_HEAD(&chip->list);\r\nINIT_WORK(&chip->work, timeout_work);\r\nsetup_timer(&chip->user_read_timer, user_reader_timeout,\r\n(unsigned long)chip);\r\nmemcpy(&chip->vendor, entry, sizeof(struct tpm_vendor_specific));\r\nchip->dev_num = find_first_zero_bit(dev_mask, TPM_NUM_DEVICES);\r\nif (chip->dev_num >= TPM_NUM_DEVICES) {\r\ndev_err(dev, "No available tpm device numbers\n");\r\ngoto out_free;\r\n} else if (chip->dev_num == 0)\r\nchip->vendor.miscdev.minor = TPM_MINOR;\r\nelse\r\nchip->vendor.miscdev.minor = MISC_DYNAMIC_MINOR;\r\nset_bit(chip->dev_num, dev_mask);\r\nscnprintf(devname, DEVNAME_SIZE, "%s%d", "tpm", chip->dev_num);\r\nchip->vendor.miscdev.name = devname;\r\nchip->vendor.miscdev.parent = dev;\r\nchip->dev = get_device(dev);\r\nchip->release = dev->release;\r\ndev->release = tpm_dev_release;\r\ndev_set_drvdata(dev, chip);\r\nif (misc_register(&chip->vendor.miscdev)) {\r\ndev_err(chip->dev,\r\n"unable to misc_register %s, minor %d\n",\r\nchip->vendor.miscdev.name,\r\nchip->vendor.miscdev.minor);\r\ngoto put_device;\r\n}\r\nif (sysfs_create_group(&dev->kobj, chip->vendor.attr_group)) {\r\nmisc_deregister(&chip->vendor.miscdev);\r\ngoto put_device;\r\n}\r\nif (tpm_add_ppi(&dev->kobj)) {\r\nmisc_deregister(&chip->vendor.miscdev);\r\ngoto put_device;\r\n}\r\nchip->bios_dir = tpm_bios_log_setup(devname);\r\nspin_lock(&driver_lock);\r\nlist_add_rcu(&chip->list, &tpm_chip_list);\r\nspin_unlock(&driver_lock);\r\nreturn chip;\r\nput_device:\r\nput_device(chip->dev);\r\nout_free:\r\nkfree(chip);\r\nkfree(devname);\r\nreturn NULL;\r\n}
