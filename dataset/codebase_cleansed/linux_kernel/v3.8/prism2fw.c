int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)\r\n{\r\nconst struct firmware *fw_entry = NULL;\r\nprintk(KERN_INFO "prism2_usb: Checking for firmware %s\n",\r\nPRISM2_USB_FWFILE);\r\nif (request_ihex_firmware(&fw_entry,\r\nPRISM2_USB_FWFILE, &udev->dev) != 0) {\r\nprintk(KERN_INFO\r\n"prism2_usb: Firmware not available, but not essential\n");\r\nprintk(KERN_INFO\r\n"prism2_usb: can continue to use card anyway.\n");\r\nreturn 1;\r\n}\r\nprintk(KERN_INFO "prism2_usb: %s will be processed, size %zu\n",\r\nPRISM2_USB_FWFILE, fw_entry->size);\r\nprism2_fwapply((const struct ihex_binrec *)fw_entry->data, wlandev);\r\nrelease_firmware(fw_entry);\r\nreturn 0;\r\n}\r\nstatic int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)\r\n{\r\nsigned int result = 0;\r\nstruct p80211msg_dot11req_mibget getmsg;\r\np80211itemd_t *item;\r\nu32 *data;\r\nns3data = 0;\r\nmemset(s3data, 0, sizeof(s3data));\r\nns3plug = 0;\r\nmemset(s3plug, 0, sizeof(s3plug));\r\nns3crc = 0;\r\nmemset(s3crc, 0, sizeof(s3crc));\r\nns3info = 0;\r\nmemset(s3info, 0, sizeof(s3info));\r\nstartaddr = 0;\r\nnfchunks = 0;\r\nmemset(fchunk, 0, sizeof(fchunk));\r\nmemset(&nicid, 0, sizeof(nicid));\r\nmemset(&rfid, 0, sizeof(rfid));\r\nmemset(&macid, 0, sizeof(macid));\r\nmemset(&priid, 0, sizeof(priid));\r\nmemset(&pda, 0, sizeof(pda));\r\npda.rec[0] = (hfa384x_pdrec_t *) pda.buf;\r\npda.rec[0]->len = cpu_to_le16(2);\r\npda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);\r\npda.nrec = 1;\r\nprism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);\r\nif (read_cardpda(&pda, wlandev)) {\r\nprintk(KERN_ERR "load_cardpda failed, exiting.\n");\r\nreturn 1;\r\n}\r\nmemset(&getmsg, 0, sizeof(getmsg));\r\ngetmsg.msgcode = DIDmsg_dot11req_mibget;\r\ngetmsg.msglen = sizeof(getmsg);\r\nstrcpy(getmsg.devname, wlandev->name);\r\ngetmsg.mibattribute.did = DIDmsg_dot11req_mibget_mibattribute;\r\ngetmsg.mibattribute.status = P80211ENUM_msgitem_status_data_ok;\r\ngetmsg.resultcode.did = DIDmsg_dot11req_mibget_resultcode;\r\ngetmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;\r\nitem = (p80211itemd_t *) getmsg.mibattribute.data;\r\nitem->did = DIDmib_p2_p2NIC_p2PRISupRange;\r\nitem->status = P80211ENUM_msgitem_status_no_value;\r\ndata = (u32 *) item->data;\r\nprism2mgmt_mibset_mibget(wlandev, &getmsg);\r\nif (getmsg.resultcode.data != P80211ENUM_resultcode_success)\r\nprintk(KERN_ERR "Couldn't fetch PRI-SUP info\n");\r\npriid.role = *data++;\r\npriid.id = *data++;\r\npriid.variant = *data++;\r\npriid.bottom = *data++;\r\npriid.top = *data++;\r\nresult = read_fwfile(rfptr);\r\nif (result) {\r\nprintk(KERN_ERR "Failed to read the data exiting.\n");\r\nreturn 1;\r\n}\r\nresult = validate_identity();\r\nif (result) {\r\nprintk(KERN_ERR "Incompatible firmware image.\n");\r\nreturn 1;\r\n}\r\nif (startaddr == 0x00000000) {\r\nprintk(KERN_ERR "Can't RAM download a Flash image!\n");\r\nreturn 1;\r\n}\r\nresult = mkimage(fchunk, &nfchunks);\r\nresult = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);\r\nif (result) {\r\nprintk(KERN_ERR "Failed to plug data.\n");\r\nreturn 1;\r\n}\r\nif (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {\r\nprintk(KERN_ERR "Failed to insert all CRCs\n");\r\nreturn 1;\r\n}\r\nresult = writeimage(wlandev, fchunk, nfchunks);\r\nif (result) {\r\nprintk(KERN_ERR "Failed to ramwrite image data.\n");\r\nreturn 1;\r\n}\r\nfree_chunks(fchunk, &nfchunks);\r\nfree_srecs();\r\nprintk(KERN_INFO "prism2_usb: firmware loading finished.\n");\r\nreturn result;\r\n}\r\nstatic int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,\r\nstruct s3crcrec *s3crc, unsigned int ns3crc)\r\n{\r\nint result = 0;\r\nint i;\r\nint c;\r\nu32 crcstart;\r\nu32 crcend;\r\nu32 cstart = 0;\r\nu32 cend;\r\nu8 *dest;\r\nu32 chunkoff;\r\nfor (i = 0; i < ns3crc; i++) {\r\nif (!s3crc[i].dowrite)\r\ncontinue;\r\ncrcstart = s3crc[i].addr;\r\ncrcend = s3crc[i].addr + s3crc[i].len;\r\nfor (c = 0; c < nfchunks; c++) {\r\ncstart = fchunk[c].addr;\r\ncend = fchunk[c].addr + fchunk[c].len;\r\nif (crcstart - 2 >= cstart && crcstart < cend)\r\nbreak;\r\n}\r\nif (c >= nfchunks) {\r\nprintk(KERN_ERR\r\n"Failed to find chunk for "\r\n"crcrec[%d], addr=0x%06x len=%d , "\r\n"aborting crc.\n",\r\ni, s3crc[i].addr, s3crc[i].len);\r\nreturn 1;\r\n}\r\npr_debug("Adding crc @ 0x%06x\n", s3crc[i].addr - 2);\r\nchunkoff = crcstart - cstart - 2;\r\ndest = fchunk[c].data + chunkoff;\r\n*dest = 0xde;\r\n*(dest + 1) = 0xc0;\r\n}\r\nreturn result;\r\n}\r\nstatic void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)\r\n{\r\nint i;\r\nfor (i = 0; i < *nfchunks; i++)\r\nkfree(fchunk[i].data);\r\n*nfchunks = 0;\r\nmemset(fchunk, 0, sizeof(*fchunk));\r\n}\r\nstatic void free_srecs(void)\r\n{\r\nns3data = 0;\r\nmemset(s3data, 0, sizeof(s3data));\r\nns3plug = 0;\r\nmemset(s3plug, 0, sizeof(s3plug));\r\nns3crc = 0;\r\nmemset(s3crc, 0, sizeof(s3crc));\r\nns3info = 0;\r\nmemset(s3info, 0, sizeof(s3info));\r\nstartaddr = 0;\r\n}\r\nstatic int mkimage(struct imgchunk *clist, unsigned int *ccnt)\r\n{\r\nint result = 0;\r\nint i;\r\nint j;\r\nint currchunk = 0;\r\nu32 nextaddr = 0;\r\nu32 s3start;\r\nu32 s3end;\r\nu32 cstart = 0;\r\nu32 cend;\r\nu32 coffset;\r\n*ccnt = 0;\r\nfor (i = 0; i < ns3data; i++) {\r\nif (s3data[i].addr == nextaddr) {\r\nclist[currchunk].len += s3data[i].len;\r\nnextaddr += s3data[i].len;\r\n} else {\r\n(*ccnt)++;\r\ncurrchunk = *ccnt - 1;\r\nclist[currchunk].addr = s3data[i].addr;\r\nclist[currchunk].len = s3data[i].len;\r\nnextaddr = s3data[i].addr + s3data[i].len;\r\nfor (j = 0; j < ns3crc; j++) {\r\nif (s3crc[j].dowrite &&\r\ns3crc[j].addr == clist[currchunk].addr) {\r\nclist[currchunk].addr -= 2;\r\nclist[currchunk].len += 2;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i < *ccnt; i++) {\r\nclist[i].data = kzalloc(clist[i].len, GFP_KERNEL);\r\nif (clist[i].data == NULL) {\r\nprintk(KERN_ERR\r\n"failed to allocate image space, exitting.\n");\r\nreturn 1;\r\n}\r\npr_debug("chunk[%d]: addr=0x%06x len=%d\n",\r\ni, clist[i].addr, clist[i].len);\r\n}\r\nfor (i = 0; i < ns3data; i++) {\r\ns3start = s3data[i].addr;\r\ns3end = s3start + s3data[i].len - 1;\r\nfor (j = 0; j < *ccnt; j++) {\r\ncstart = clist[j].addr;\r\ncend = cstart + clist[j].len - 1;\r\nif (s3start >= cstart && s3end <= cend)\r\nbreak;\r\n}\r\nif (((unsigned int)j) >= (*ccnt)) {\r\nprintk(KERN_ERR\r\n"s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",\r\ns3start, s3data[i].len);\r\nreturn 1;\r\n}\r\ncoffset = s3start - cstart;\r\nmemcpy(clist[j].data + coffset, s3data[i].data, s3data[i].len);\r\n}\r\nreturn result;\r\n}\r\nstatic int mkpdrlist(struct pda *pda)\r\n{\r\nint result = 0;\r\nu16 *pda16 = (u16 *) pda->buf;\r\nint curroff;\r\npda->nrec = 0;\r\ncurroff = 0;\r\nwhile (curroff < (HFA384x_PDA_LEN_MAX / 2) &&\r\nle16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {\r\npda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);\r\nif (le16_to_cpu(pda->rec[pda->nrec]->code) ==\r\nHFA384x_PDR_NICID) {\r\nmemcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,\r\nsizeof(nicid));\r\nnicid.id = le16_to_cpu(nicid.id);\r\nnicid.variant = le16_to_cpu(nicid.variant);\r\nnicid.major = le16_to_cpu(nicid.major);\r\nnicid.minor = le16_to_cpu(nicid.minor);\r\n}\r\nif (le16_to_cpu(pda->rec[pda->nrec]->code) ==\r\nHFA384x_PDR_MFISUPRANGE) {\r\nmemcpy(&rfid, &pda->rec[pda->nrec]->data.mfisuprange,\r\nsizeof(rfid));\r\nrfid.id = le16_to_cpu(rfid.id);\r\nrfid.variant = le16_to_cpu(rfid.variant);\r\nrfid.bottom = le16_to_cpu(rfid.bottom);\r\nrfid.top = le16_to_cpu(rfid.top);\r\n}\r\nif (le16_to_cpu(pda->rec[pda->nrec]->code) ==\r\nHFA384x_PDR_CFISUPRANGE) {\r\nmemcpy(&macid, &pda->rec[pda->nrec]->data.cfisuprange,\r\nsizeof(macid));\r\nmacid.id = le16_to_cpu(macid.id);\r\nmacid.variant = le16_to_cpu(macid.variant);\r\nmacid.bottom = le16_to_cpu(macid.bottom);\r\nmacid.top = le16_to_cpu(macid.top);\r\n}\r\n(pda->nrec)++;\r\ncurroff += le16_to_cpu(pda16[curroff]) + 1;\r\n}\r\nif (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {\r\nprintk(KERN_ERR\r\n"no end record found or invalid lengths in "\r\n"PDR data, exiting. %x %d\n", curroff, pda->nrec);\r\nreturn 1;\r\n}\r\nif (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {\r\npda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);\r\n(pda->nrec)++;\r\n}\r\nreturn result;\r\n}\r\nstatic int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,\r\nstruct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda)\r\n{\r\nint result = 0;\r\nint i;\r\nint j;\r\nint c;\r\nu32 pstart;\r\nu32 pend;\r\nu32 cstart = 0;\r\nu32 cend;\r\nu32 chunkoff;\r\nu8 *dest;\r\nfor (i = 0; i < ns3plug; i++) {\r\npstart = s3plug[i].addr;\r\npend = s3plug[i].addr + s3plug[i].len;\r\nif (s3plug[i].itemcode != 0xffffffffUL) {\r\nfor (j = 0; j < pda->nrec; j++) {\r\nif (s3plug[i].itemcode ==\r\nle16_to_cpu(pda->rec[j]->code))\r\nbreak;\r\n}\r\n} else {\r\nj = -1;\r\n}\r\nif (j >= pda->nrec && j != -1) {\r\nprintk(KERN_WARNING\r\n"warning: Failed to find PDR for "\r\n"plugrec 0x%04x.\n", s3plug[i].itemcode);\r\ncontinue;\r\n#if 0\r\nresult = 1;\r\ncontinue;\r\n#endif\r\n}\r\nif (j != -1 && s3plug[i].len < le16_to_cpu(pda->rec[j]->len)) {\r\nprintk(KERN_ERR\r\n"error: Plug vs. PDR len mismatch for "\r\n"plugrec 0x%04x, abort plugging.\n",\r\ns3plug[i].itemcode);\r\nresult = 1;\r\ncontinue;\r\n}\r\nfor (c = 0; c < nfchunks; c++) {\r\ncstart = fchunk[c].addr;\r\ncend = fchunk[c].addr + fchunk[c].len;\r\nif (pstart >= cstart && pend <= cend)\r\nbreak;\r\n}\r\nif (c >= nfchunks) {\r\nprintk(KERN_ERR\r\n"error: Failed to find image chunk for "\r\n"plugrec 0x%04x.\n", s3plug[i].itemcode);\r\nresult = 1;\r\ncontinue;\r\n}\r\nchunkoff = pstart - cstart;\r\ndest = fchunk[c].data + chunkoff;\r\npr_debug("Plugging item 0x%04x @ 0x%06x, len=%d, "\r\n"cnum=%d coff=0x%06x\n",\r\ns3plug[i].itemcode, pstart, s3plug[i].len,\r\nc, chunkoff);\r\nif (j == -1) {\r\nmemset(dest, 0, s3plug[i].len);\r\nstrncpy(dest, PRISM2_USB_FWFILE, s3plug[i].len - 1);\r\n} else {\r\nmemcpy(dest, &(pda->rec[j]->data), s3plug[i].len);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int read_cardpda(struct pda *pda, wlandevice_t *wlandev)\r\n{\r\nint result = 0;\r\nstruct p80211msg_p2req_readpda msg;\r\nmsg.msgcode = DIDmsg_p2req_readpda;\r\nmsg.msglen = sizeof(msg);\r\nstrcpy(msg.devname, wlandev->name);\r\nmsg.pda.did = DIDmsg_p2req_readpda_pda;\r\nmsg.pda.len = HFA384x_PDA_LEN_MAX;\r\nmsg.pda.status = P80211ENUM_msgitem_status_no_value;\r\nmsg.resultcode.did = DIDmsg_p2req_readpda_resultcode;\r\nmsg.resultcode.len = sizeof(u32);\r\nmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;\r\nif (prism2mgmt_readpda(wlandev, &msg) != 0) {\r\nresult = -1;\r\n} else if (msg.resultcode.data == P80211ENUM_resultcode_success) {\r\nmemcpy(pda->buf, msg.pda.data, HFA384x_PDA_LEN_MAX);\r\nresult = mkpdrlist(pda);\r\n} else {\r\nresult = -1;\r\n}\r\nreturn result;\r\n}\r\nstatic int read_fwfile(const struct ihex_binrec *record)\r\n{\r\nint i;\r\nint rcnt = 0;\r\nu16 *tmpinfo;\r\nu16 *ptr16;\r\nu32 *ptr32, len, addr;\r\npr_debug("Reading fw file ...\n");\r\nwhile (record) {\r\nrcnt++;\r\nlen = be16_to_cpu(record->len);\r\naddr = be32_to_cpu(record->addr);\r\nptr32 = (u32 *) record->data;\r\nptr16 = (u16 *) record->data;\r\nswitch (addr) {\r\ncase S3ADDR_START:\r\nstartaddr = *ptr32;\r\npr_debug(" S7 start addr, record=%d "\r\n" addr=0x%08x\n",\r\nrcnt,\r\nstartaddr);\r\nbreak;\r\ncase S3ADDR_PLUG:\r\ns3plug[ns3plug].itemcode = *ptr32;\r\ns3plug[ns3plug].addr = *(ptr32 + 1);\r\ns3plug[ns3plug].len = *(ptr32 + 2);\r\npr_debug(" S3 plugrec, record=%d "\r\n"itemcode=0x%08x addr=0x%08x len=%d\n",\r\nrcnt,\r\ns3plug[ns3plug].itemcode,\r\ns3plug[ns3plug].addr,\r\ns3plug[ns3plug].len);\r\nns3plug++;\r\nif (ns3plug == S3PLUG_MAX) {\r\nprintk(KERN_ERR "S3 plugrec limit reached - aborting\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase S3ADDR_CRC:\r\ns3crc[ns3crc].addr = *ptr32;\r\ns3crc[ns3crc].len = *(ptr32 + 1);\r\ns3crc[ns3crc].dowrite = *(ptr32 + 2);\r\npr_debug(" S3 crcrec, record=%d "\r\n"addr=0x%08x len=%d write=0x%08x\n",\r\nrcnt,\r\ns3crc[ns3crc].addr,\r\ns3crc[ns3crc].len,\r\ns3crc[ns3crc].dowrite);\r\nns3crc++;\r\nif (ns3crc == S3CRC_MAX) {\r\nprintk(KERN_ERR "S3 crcrec limit reached - aborting\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase S3ADDR_INFO:\r\ns3info[ns3info].len = *ptr16;\r\ns3info[ns3info].type = *(ptr16 + 1);\r\npr_debug(" S3 inforec, record=%d "\r\n"len=0x%04x type=0x%04x\n",\r\nrcnt,\r\ns3info[ns3info].len,\r\ns3info[ns3info].type);\r\nif (((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info)) {\r\nprintk(KERN_ERR " S3 inforec length too long - aborting\n");\r\nreturn 1;\r\n}\r\ntmpinfo = (u16 *)&(s3info[ns3info].info.version);\r\npr_debug(" info=");\r\nfor (i = 0; i < s3info[ns3info].len - 1; i++) {\r\ntmpinfo[i] = *(ptr16 + 2 + i);\r\npr_debug("%04x ", tmpinfo[i]);\r\n}\r\npr_debug("\n");\r\nns3info++;\r\nif (ns3info == S3INFO_MAX) {\r\nprintk(KERN_ERR "S3 inforec limit reached - aborting\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\ns3data[ns3data].addr = addr;\r\ns3data[ns3data].len = len;\r\ns3data[ns3data].data = (uint8_t *) record->data;\r\nns3data++;\r\nif (ns3data == S3DATA_MAX) {\r\nprintk(KERN_ERR "S3 datarec limit reached - aborting\n");\r\nreturn 1;\r\n}\r\nbreak;\r\n}\r\nrecord = ihex_next_binrec(record);\r\n}\r\nreturn 0;\r\n}\r\nstatic int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,\r\nunsigned int nfchunks)\r\n{\r\nint result = 0;\r\nstruct p80211msg_p2req_ramdl_state *rstmsg;\r\nstruct p80211msg_p2req_ramdl_write *rwrmsg;\r\nu32 resultcode;\r\nint i;\r\nint j;\r\nunsigned int nwrites;\r\nu32 curroff;\r\nu32 currlen;\r\nu32 currdaddr;\r\nrstmsg = kmalloc(sizeof(*rstmsg), GFP_KERNEL);\r\nrwrmsg = kmalloc(sizeof(*rwrmsg), GFP_KERNEL);\r\nif (!rstmsg || !rwrmsg) {\r\nkfree(rstmsg);\r\nkfree(rwrmsg);\r\nprintk(KERN_ERR\r\n"writeimage: no memory for firmware download, "\r\n"aborting download\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(rstmsg, 0, sizeof(*rstmsg));\r\nstrcpy(rstmsg->devname, wlandev->name);\r\nrstmsg->msgcode = DIDmsg_p2req_ramdl_state;\r\nrstmsg->msglen = sizeof(*rstmsg);\r\nrstmsg->enable.did = DIDmsg_p2req_ramdl_state_enable;\r\nrstmsg->exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;\r\nrstmsg->resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;\r\nrstmsg->enable.status = P80211ENUM_msgitem_status_data_ok;\r\nrstmsg->exeaddr.status = P80211ENUM_msgitem_status_data_ok;\r\nrstmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;\r\nrstmsg->enable.len = sizeof(u32);\r\nrstmsg->exeaddr.len = sizeof(u32);\r\nrstmsg->resultcode.len = sizeof(u32);\r\nmemset(rwrmsg, 0, sizeof(*rwrmsg));\r\nstrcpy(rwrmsg->devname, wlandev->name);\r\nrwrmsg->msgcode = DIDmsg_p2req_ramdl_write;\r\nrwrmsg->msglen = sizeof(*rwrmsg);\r\nrwrmsg->addr.did = DIDmsg_p2req_ramdl_write_addr;\r\nrwrmsg->len.did = DIDmsg_p2req_ramdl_write_len;\r\nrwrmsg->data.did = DIDmsg_p2req_ramdl_write_data;\r\nrwrmsg->resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;\r\nrwrmsg->addr.status = P80211ENUM_msgitem_status_data_ok;\r\nrwrmsg->len.status = P80211ENUM_msgitem_status_data_ok;\r\nrwrmsg->data.status = P80211ENUM_msgitem_status_data_ok;\r\nrwrmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;\r\nrwrmsg->addr.len = sizeof(u32);\r\nrwrmsg->len.len = sizeof(u32);\r\nrwrmsg->data.len = WRITESIZE_MAX;\r\nrwrmsg->resultcode.len = sizeof(u32);\r\npr_debug("Sending dl_state(enable) message.\n");\r\nrstmsg->enable.data = P80211ENUM_truth_true;\r\nrstmsg->exeaddr.data = startaddr;\r\nresult = prism2mgmt_ramdl_state(wlandev, rstmsg);\r\nif (result) {\r\nprintk(KERN_ERR\r\n"writeimage state enable failed w/ result=%d, "\r\n"aborting download\n", result);\r\ngoto free_result;\r\n}\r\nresultcode = rstmsg->resultcode.data;\r\nif (resultcode != P80211ENUM_resultcode_success) {\r\nprintk(KERN_ERR\r\n"writeimage()->xxxdl_state msg indicates failure, "\r\n"w/ resultcode=%d, aborting download.\n", resultcode);\r\nresult = 1;\r\ngoto free_result;\r\n}\r\nfor (i = 0; i < nfchunks; i++) {\r\nnwrites = fchunk[i].len / WRITESIZE_MAX;\r\nnwrites += (fchunk[i].len % WRITESIZE_MAX) ? 1 : 0;\r\ncurroff = 0;\r\nfor (j = 0; j < nwrites; j++) {\r\nint lenleft = fchunk[i].len - (WRITESIZE_MAX * j);\r\nif (fchunk[i].len > WRITESIZE_MAX)\r\ncurrlen = WRITESIZE_MAX;\r\nelse\r\ncurrlen = lenleft;\r\ncurroff = j * WRITESIZE_MAX;\r\ncurrdaddr = fchunk[i].addr + curroff;\r\nrwrmsg->addr.data = currdaddr;\r\nrwrmsg->len.data = currlen;\r\nmemcpy(rwrmsg->data.data,\r\nfchunk[i].data + curroff, currlen);\r\npr_debug\r\n("Sending xxxdl_write message addr=%06x len=%d.\n",\r\ncurrdaddr, currlen);\r\nresult = prism2mgmt_ramdl_write(wlandev, rwrmsg);\r\nif (result) {\r\nprintk(KERN_ERR\r\n"writeimage chunk write failed w/ result=%d, "\r\n"aborting download\n", result);\r\ngoto free_result;\r\n}\r\nresultcode = rstmsg->resultcode.data;\r\nif (resultcode != P80211ENUM_resultcode_success) {\r\nprintk(KERN_ERR\r\n"writeimage()->xxxdl_write msg indicates failure, "\r\n"w/ resultcode=%d, aborting download.\n",\r\nresultcode);\r\nresult = 1;\r\ngoto free_result;\r\n}\r\n}\r\n}\r\npr_debug("Sending dl_state(disable) message.\n");\r\nrstmsg->enable.data = P80211ENUM_truth_false;\r\nrstmsg->exeaddr.data = 0;\r\nresult = prism2mgmt_ramdl_state(wlandev, rstmsg);\r\nif (result) {\r\nprintk(KERN_ERR\r\n"writeimage state disable failed w/ result=%d, "\r\n"aborting download\n", result);\r\ngoto free_result;\r\n}\r\nresultcode = rstmsg->resultcode.data;\r\nif (resultcode != P80211ENUM_resultcode_success) {\r\nprintk(KERN_ERR\r\n"writeimage()->xxxdl_state msg indicates failure, "\r\n"w/ resultcode=%d, aborting download.\n", resultcode);\r\nresult = 1;\r\ngoto free_result;\r\n}\r\nfree_result:\r\nkfree(rstmsg);\r\nkfree(rwrmsg);\r\nreturn result;\r\n}\r\nstatic int validate_identity(void)\r\n{\r\nint i;\r\nint result = 1;\r\nint trump = 0;\r\npr_debug("NIC ID: %#x v%d.%d.%d\n",\r\nnicid.id, nicid.major, nicid.minor, nicid.variant);\r\npr_debug("MFI ID: %#x v%d %d->%d\n",\r\nrfid.id, rfid.variant, rfid.bottom, rfid.top);\r\npr_debug("CFI ID: %#x v%d %d->%d\n",\r\nmacid.id, macid.variant, macid.bottom, macid.top);\r\npr_debug("PRI ID: %#x v%d %d->%d\n",\r\npriid.id, priid.variant, priid.bottom, priid.top);\r\nfor (i = 0; i < ns3info; i++) {\r\nswitch (s3info[i].type) {\r\ncase 1:\r\npr_debug("Version: ID %#x %d.%d.%d\n",\r\ns3info[i].info.version.id,\r\ns3info[i].info.version.major,\r\ns3info[i].info.version.minor,\r\ns3info[i].info.version.variant);\r\nbreak;\r\ncase 2:\r\npr_debug("Compat: Role %#x Id %#x v%d %d->%d\n",\r\ns3info[i].info.compat.role,\r\ns3info[i].info.compat.id,\r\ns3info[i].info.compat.variant,\r\ns3info[i].info.compat.bottom,\r\ns3info[i].info.compat.top);\r\nif ((s3info[i].info.compat.role == 1) &&\r\n(s3info[i].info.compat.id == 2)) {\r\nif (s3info[i].info.compat.variant !=\r\nmacid.variant) {\r\nresult = 2;\r\n}\r\n}\r\nif ((s3info[i].info.compat.role == 1) &&\r\n(s3info[i].info.compat.id == 3)) {\r\nif ((s3info[i].info.compat.bottom > priid.top)\r\n|| (s3info[i].info.compat.top <\r\npriid.bottom)) {\r\nresult = 3;\r\n}\r\n}\r\nif ((s3info[i].info.compat.role == 1) &&\r\n(s3info[i].info.compat.id == 4)) {\r\n}\r\nbreak;\r\ncase 3:\r\npr_debug("Seq: %#x\n", s3info[i].info.buildseq);\r\nbreak;\r\ncase 4:\r\npr_debug("Platform: ID %#x %d.%d.%d\n",\r\ns3info[i].info.version.id,\r\ns3info[i].info.version.major,\r\ns3info[i].info.version.minor,\r\ns3info[i].info.version.variant);\r\nif (nicid.id != s3info[i].info.version.id)\r\ncontinue;\r\nif (nicid.major != s3info[i].info.version.major)\r\ncontinue;\r\nif (nicid.minor != s3info[i].info.version.minor)\r\ncontinue;\r\nif ((nicid.variant != s3info[i].info.version.variant) &&\r\n(nicid.id != 0x8008))\r\ncontinue;\r\ntrump = 1;\r\nbreak;\r\ncase 0x8001:\r\npr_debug("name inforec len %d\n", s3info[i].len);\r\nbreak;\r\ndefault:\r\npr_debug("Unknown inforec type %d\n", s3info[i].type);\r\n}\r\n}\r\nif (trump && (result != 2))\r\nresult = 0;\r\nreturn result;\r\n}
