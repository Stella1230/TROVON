static int sq905_command(struct gspca_dev *gspca_dev, u16 index)\r\n{\r\nint ret;\r\ngspca_dev->usb_buf[0] = '\0';\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nUSB_REQ_SYNCH_FRAME,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nSQ905_COMMAND, index, gspca_dev->usb_buf, 1,\r\nSQ905_CMD_TIMEOUT);\r\nif (ret < 0) {\r\npr_err("%s: usb_control_msg failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nUSB_REQ_SYNCH_FRAME,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nSQ905_PING, 0, gspca_dev->usb_buf, 1,\r\nSQ905_CMD_TIMEOUT);\r\nif (ret < 0) {\r\npr_err("%s: usb_control_msg failed 2 (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sq905_ack_frame(struct gspca_dev *gspca_dev)\r\n{\r\nint ret;\r\ngspca_dev->usb_buf[0] = '\0';\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nUSB_REQ_SYNCH_FRAME,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nSQ905_READ_DONE, 0, gspca_dev->usb_buf, 1,\r\nSQ905_CMD_TIMEOUT);\r\nif (ret < 0) {\r\npr_err("%s: usb_control_msg failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsq905_read_data(struct gspca_dev *gspca_dev, u8 *data, int size, int need_lock)\r\n{\r\nint ret;\r\nint act_len;\r\ngspca_dev->usb_buf[0] = '\0';\r\nif (need_lock)\r\nmutex_lock(&gspca_dev->usb_lock);\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nUSB_REQ_SYNCH_FRAME,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nSQ905_BULK_READ, size, gspca_dev->usb_buf,\r\n1, SQ905_CMD_TIMEOUT);\r\nif (need_lock)\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (ret < 0) {\r\npr_err("%s: usb_control_msg failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x81),\r\ndata, size, &act_len, SQ905_DATA_TIMEOUT);\r\nif (ret < 0 || act_len != size) {\r\npr_err("bulk read fail (%d) len %d/%d\n", ret, act_len, size);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sq905_dostream(struct work_struct *work)\r\n{\r\nstruct sd *dev = container_of(work, struct sd, work_struct);\r\nstruct gspca_dev *gspca_dev = &dev->gspca_dev;\r\nint bytes_left;\r\nint data_len;\r\nint header_read;\r\nint packet_type;\r\nint frame_sz;\r\nint ret;\r\nu8 *data;\r\nu8 *buffer;\r\nbuffer = kmalloc(SQ905_MAX_TRANSFER, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\npr_err("Couldn't allocate USB buffer\n");\r\ngoto quit_stream;\r\n}\r\nframe_sz = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].sizeimage\r\n+ FRAME_HEADER_LEN;\r\nwhile (gspca_dev->present && gspca_dev->streaming) {\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nbreak;\r\n#endif\r\nbytes_left = frame_sz;\r\nheader_read = 0;\r\nwhile (bytes_left > 0 && gspca_dev->present) {\r\ndata_len = bytes_left > SQ905_MAX_TRANSFER ?\r\nSQ905_MAX_TRANSFER : bytes_left;\r\nret = sq905_read_data(gspca_dev, buffer, data_len, 1);\r\nif (ret < 0)\r\ngoto quit_stream;\r\nPDEBUG(D_PACK,\r\n"Got %d bytes out of %d for frame",\r\ndata_len, bytes_left);\r\nbytes_left -= data_len;\r\ndata = buffer;\r\nif (!header_read) {\r\npacket_type = FIRST_PACKET;\r\ndata += FRAME_HEADER_LEN;\r\ndata_len -= FRAME_HEADER_LEN;\r\nheader_read = 1;\r\n} else if (bytes_left == 0) {\r\npacket_type = LAST_PACKET;\r\n} else {\r\npacket_type = INTER_PACKET;\r\n}\r\ngspca_frame_add(gspca_dev, packet_type,\r\ndata, data_len);\r\nif (packet_type == FIRST_PACKET &&\r\nbytes_left == 0)\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\n}\r\nif (gspca_dev->present) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\nret = sq905_ack_frame(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (ret < 0)\r\ngoto quit_stream;\r\n}\r\n}\r\nquit_stream:\r\nif (gspca_dev->present) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\nsq905_command(gspca_dev, SQ905_CLEAR);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\n}\r\nkfree(buffer);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam = &gspca_dev->cam;\r\nstruct sd *dev = (struct sd *) gspca_dev;\r\ncam->bulk = 1;\r\ncam->bulk_size = 64;\r\nINIT_WORK(&dev->work_struct, sq905_dostream);\r\nreturn 0;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *dev = (struct sd *) gspca_dev;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\ndestroy_workqueue(dev->work_thread);\r\ndev->work_thread = NULL;\r\nmutex_lock(&gspca_dev->usb_lock);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nu32 ident;\r\nint ret;\r\nret = sq905_command(gspca_dev, SQ905_CLEAR);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sq905_command(gspca_dev, SQ905_ID);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sq905_read_data(gspca_dev, gspca_dev->usb_buf, 4, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nident = be32_to_cpup((__be32 *)gspca_dev->usb_buf);\r\nret = sq905_command(gspca_dev, SQ905_CLEAR);\r\nif (ret < 0)\r\nreturn ret;\r\nPDEBUG(D_CONF, "SQ905 camera ID %08x detected", ident);\r\ngspca_dev->cam.cam_mode = sq905_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(sq905_mode);\r\nif (!(ident & SQ905_HIRES_MASK))\r\ngspca_dev->cam.nmodes--;\r\nif (ident & SQ905_ORIENTATION_MASK)\r\ngspca_dev->cam.input_flags = V4L2_IN_ST_VFLIP;\r\nelse\r\ngspca_dev->cam.input_flags = V4L2_IN_ST_VFLIP |\r\nV4L2_IN_ST_HFLIP;\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *dev = (struct sd *) gspca_dev;\r\nint ret;\r\nswitch (gspca_dev->curr_mode) {\r\ndefault:\r\nPDEBUG(D_STREAM, "Start streaming at high resolution");\r\nret = sq905_command(&dev->gspca_dev, SQ905_CAPTURE_HIGH);\r\nbreak;\r\ncase 1:\r\nPDEBUG(D_STREAM, "Start streaming at medium resolution");\r\nret = sq905_command(&dev->gspca_dev, SQ905_CAPTURE_MED);\r\nbreak;\r\ncase 0:\r\nPDEBUG(D_STREAM, "Start streaming at low resolution");\r\nret = sq905_command(&dev->gspca_dev, SQ905_CAPTURE_LOW);\r\n}\r\nif (ret < 0) {\r\nPDEBUG(D_ERR, "Start streaming command failed");\r\nreturn ret;\r\n}\r\ndev->work_thread = create_singlethread_workqueue(MODULE_NAME);\r\nqueue_work(dev->work_thread, &dev->work_struct);\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id,\r\n&sd_desc,\r\nsizeof(struct sd),\r\nTHIS_MODULE);\r\n}
