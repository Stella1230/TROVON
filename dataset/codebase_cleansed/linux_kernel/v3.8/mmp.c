static __u32 ext4_mmp_csum(struct super_block *sb, struct mmp_struct *mmp)\r\n{\r\nstruct ext4_sb_info *sbi = EXT4_SB(sb);\r\nint offset = offsetof(struct mmp_struct, mmp_checksum);\r\n__u32 csum;\r\ncsum = ext4_chksum(sbi, sbi->s_csum_seed, (char *)mmp, offset);\r\nreturn cpu_to_le32(csum);\r\n}\r\nint ext4_mmp_csum_verify(struct super_block *sb, struct mmp_struct *mmp)\r\n{\r\nif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\r\nEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\r\nreturn 1;\r\nreturn mmp->mmp_checksum == ext4_mmp_csum(sb, mmp);\r\n}\r\nvoid ext4_mmp_csum_set(struct super_block *sb, struct mmp_struct *mmp)\r\n{\r\nif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\r\nEXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\r\nreturn;\r\nmmp->mmp_checksum = ext4_mmp_csum(sb, mmp);\r\n}\r\nstatic int write_mmp_block(struct super_block *sb, struct buffer_head *bh)\r\n{\r\nstruct mmp_struct *mmp = (struct mmp_struct *)(bh->b_data);\r\nsb_start_write(sb);\r\next4_mmp_csum_set(sb, mmp);\r\nmark_buffer_dirty(bh);\r\nlock_buffer(bh);\r\nbh->b_end_io = end_buffer_write_sync;\r\nget_bh(bh);\r\nsubmit_bh(WRITE_SYNC, bh);\r\nwait_on_buffer(bh);\r\nsb_end_write(sb);\r\nif (unlikely(!buffer_uptodate(bh)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int read_mmp_block(struct super_block *sb, struct buffer_head **bh,\r\next4_fsblk_t mmp_block)\r\n{\r\nstruct mmp_struct *mmp;\r\nif (*bh)\r\nclear_buffer_uptodate(*bh);\r\nif (!*bh)\r\n*bh = sb_getblk(sb, mmp_block);\r\nif (*bh) {\r\nget_bh(*bh);\r\nlock_buffer(*bh);\r\n(*bh)->b_end_io = end_buffer_read_sync;\r\nsubmit_bh(READ_SYNC, *bh);\r\nwait_on_buffer(*bh);\r\nif (!buffer_uptodate(*bh)) {\r\nbrelse(*bh);\r\n*bh = NULL;\r\n}\r\n}\r\nif (!*bh) {\r\next4_warning(sb, "Error while reading MMP block %llu",\r\nmmp_block);\r\nreturn -EIO;\r\n}\r\nmmp = (struct mmp_struct *)((*bh)->b_data);\r\nif (le32_to_cpu(mmp->mmp_magic) != EXT4_MMP_MAGIC ||\r\n!ext4_mmp_csum_verify(sb, mmp))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid __dump_mmp_msg(struct super_block *sb, struct mmp_struct *mmp,\r\nconst char *function, unsigned int line, const char *msg)\r\n{\r\n__ext4_warning(sb, function, line, msg);\r\n__ext4_warning(sb, function, line,\r\n"MMP failure info: last update time: %llu, last update "\r\n"node: %s, last update device: %s\n",\r\n(long long unsigned int) le64_to_cpu(mmp->mmp_time),\r\nmmp->mmp_nodename, mmp->mmp_bdevname);\r\n}\r\nstatic int kmmpd(void *data)\r\n{\r\nstruct super_block *sb = ((struct mmpd_data *) data)->sb;\r\nstruct buffer_head *bh = ((struct mmpd_data *) data)->bh;\r\nstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\r\nstruct mmp_struct *mmp;\r\next4_fsblk_t mmp_block;\r\nu32 seq = 0;\r\nunsigned long failed_writes = 0;\r\nint mmp_update_interval = le16_to_cpu(es->s_mmp_update_interval);\r\nunsigned mmp_check_interval;\r\nunsigned long last_update_time;\r\nunsigned long diff;\r\nint retval;\r\nmmp_block = le64_to_cpu(es->s_mmp_block);\r\nmmp = (struct mmp_struct *)(bh->b_data);\r\nmmp->mmp_time = cpu_to_le64(get_seconds());\r\nmmp_check_interval = max(EXT4_MMP_CHECK_MULT * mmp_update_interval,\r\nEXT4_MMP_MIN_CHECK_INTERVAL);\r\nmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\r\nbdevname(bh->b_bdev, mmp->mmp_bdevname);\r\nmemcpy(mmp->mmp_nodename, init_utsname()->nodename,\r\nsizeof(mmp->mmp_nodename));\r\nwhile (!kthread_should_stop()) {\r\nif (++seq > EXT4_MMP_SEQ_MAX)\r\nseq = 1;\r\nmmp->mmp_seq = cpu_to_le32(seq);\r\nmmp->mmp_time = cpu_to_le64(get_seconds());\r\nlast_update_time = jiffies;\r\nretval = write_mmp_block(sb, bh);\r\nif (retval) {\r\nif ((failed_writes % 60) == 0)\r\next4_error(sb, "Error writing to MMP block");\r\nfailed_writes++;\r\n}\r\nif (!(le32_to_cpu(es->s_feature_incompat) &\r\nEXT4_FEATURE_INCOMPAT_MMP)) {\r\next4_warning(sb, "kmmpd being stopped since MMP feature"\r\n" has been disabled.");\r\nEXT4_SB(sb)->s_mmp_tsk = NULL;\r\ngoto failed;\r\n}\r\nif (sb->s_flags & MS_RDONLY) {\r\next4_warning(sb, "kmmpd being stopped since filesystem "\r\n"has been remounted as readonly.");\r\nEXT4_SB(sb)->s_mmp_tsk = NULL;\r\ngoto failed;\r\n}\r\ndiff = jiffies - last_update_time;\r\nif (diff < mmp_update_interval * HZ)\r\nschedule_timeout_interruptible(mmp_update_interval *\r\nHZ - diff);\r\ndiff = jiffies - last_update_time;\r\nif (diff > mmp_check_interval * HZ) {\r\nstruct buffer_head *bh_check = NULL;\r\nstruct mmp_struct *mmp_check;\r\nretval = read_mmp_block(sb, &bh_check, mmp_block);\r\nif (retval) {\r\next4_error(sb, "error reading MMP data: %d",\r\nretval);\r\nEXT4_SB(sb)->s_mmp_tsk = NULL;\r\ngoto failed;\r\n}\r\nmmp_check = (struct mmp_struct *)(bh_check->b_data);\r\nif (mmp->mmp_seq != mmp_check->mmp_seq ||\r\nmemcmp(mmp->mmp_nodename, mmp_check->mmp_nodename,\r\nsizeof(mmp->mmp_nodename))) {\r\ndump_mmp_msg(sb, mmp_check,\r\n"Error while updating MMP info. "\r\n"The filesystem seems to have been"\r\n" multiply mounted.");\r\next4_error(sb, "abort");\r\ngoto failed;\r\n}\r\nput_bh(bh_check);\r\n}\r\nmmp_check_interval = max(min(EXT4_MMP_CHECK_MULT * diff / HZ,\r\nEXT4_MMP_MAX_CHECK_INTERVAL),\r\nEXT4_MMP_MIN_CHECK_INTERVAL);\r\nmmp->mmp_check_interval = cpu_to_le16(mmp_check_interval);\r\n}\r\nmmp->mmp_seq = cpu_to_le32(EXT4_MMP_SEQ_CLEAN);\r\nmmp->mmp_time = cpu_to_le64(get_seconds());\r\nretval = write_mmp_block(sb, bh);\r\nfailed:\r\nkfree(data);\r\nbrelse(bh);\r\nreturn retval;\r\n}\r\nstatic unsigned int mmp_new_seq(void)\r\n{\r\nu32 new_seq;\r\ndo {\r\nget_random_bytes(&new_seq, sizeof(u32));\r\n} while (new_seq > EXT4_MMP_SEQ_MAX);\r\nreturn new_seq;\r\n}\r\nint ext4_multi_mount_protect(struct super_block *sb,\r\next4_fsblk_t mmp_block)\r\n{\r\nstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\r\nstruct buffer_head *bh = NULL;\r\nstruct mmp_struct *mmp = NULL;\r\nstruct mmpd_data *mmpd_data;\r\nu32 seq;\r\nunsigned int mmp_check_interval = le16_to_cpu(es->s_mmp_update_interval);\r\nunsigned int wait_time = 0;\r\nint retval;\r\nif (mmp_block < le32_to_cpu(es->s_first_data_block) ||\r\nmmp_block >= ext4_blocks_count(es)) {\r\next4_warning(sb, "Invalid MMP block in superblock");\r\ngoto failed;\r\n}\r\nretval = read_mmp_block(sb, &bh, mmp_block);\r\nif (retval)\r\ngoto failed;\r\nmmp = (struct mmp_struct *)(bh->b_data);\r\nif (mmp_check_interval < EXT4_MMP_MIN_CHECK_INTERVAL)\r\nmmp_check_interval = EXT4_MMP_MIN_CHECK_INTERVAL;\r\nif (le16_to_cpu(mmp->mmp_check_interval) > mmp_check_interval)\r\nmmp_check_interval = le16_to_cpu(mmp->mmp_check_interval);\r\nseq = le32_to_cpu(mmp->mmp_seq);\r\nif (seq == EXT4_MMP_SEQ_CLEAN)\r\ngoto skip;\r\nif (seq == EXT4_MMP_SEQ_FSCK) {\r\ndump_mmp_msg(sb, mmp, "fsck is running on the filesystem");\r\ngoto failed;\r\n}\r\nwait_time = min(mmp_check_interval * 2 + 1,\r\nmmp_check_interval + 60);\r\nif (wait_time > EXT4_MMP_MIN_CHECK_INTERVAL * 4)\r\next4_warning(sb, "MMP interval %u higher than expected, please"\r\n" wait.\n", wait_time * 2);\r\nif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\r\next4_warning(sb, "MMP startup interrupted, failing mount\n");\r\ngoto failed;\r\n}\r\nretval = read_mmp_block(sb, &bh, mmp_block);\r\nif (retval)\r\ngoto failed;\r\nmmp = (struct mmp_struct *)(bh->b_data);\r\nif (seq != le32_to_cpu(mmp->mmp_seq)) {\r\ndump_mmp_msg(sb, mmp,\r\n"Device is already active on another node.");\r\ngoto failed;\r\n}\r\nskip:\r\nseq = mmp_new_seq();\r\nmmp->mmp_seq = cpu_to_le32(seq);\r\nretval = write_mmp_block(sb, bh);\r\nif (retval)\r\ngoto failed;\r\nif (schedule_timeout_interruptible(HZ * wait_time) != 0) {\r\next4_warning(sb, "MMP startup interrupted, failing mount\n");\r\ngoto failed;\r\n}\r\nretval = read_mmp_block(sb, &bh, mmp_block);\r\nif (retval)\r\ngoto failed;\r\nmmp = (struct mmp_struct *)(bh->b_data);\r\nif (seq != le32_to_cpu(mmp->mmp_seq)) {\r\ndump_mmp_msg(sb, mmp,\r\n"Device is already active on another node.");\r\ngoto failed;\r\n}\r\nmmpd_data = kmalloc(sizeof(struct mmpd_data), GFP_KERNEL);\r\nif (!mmpd_data) {\r\next4_warning(sb, "not enough memory for mmpd_data");\r\ngoto failed;\r\n}\r\nmmpd_data->sb = sb;\r\nmmpd_data->bh = bh;\r\nEXT4_SB(sb)->s_mmp_tsk = kthread_run(kmmpd, mmpd_data, "kmmpd-%s",\r\nbdevname(bh->b_bdev,\r\nmmp->mmp_bdevname));\r\nif (IS_ERR(EXT4_SB(sb)->s_mmp_tsk)) {\r\nEXT4_SB(sb)->s_mmp_tsk = NULL;\r\nkfree(mmpd_data);\r\next4_warning(sb, "Unable to create kmmpd thread for %s.",\r\nsb->s_id);\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nbrelse(bh);\r\nreturn 1;\r\n}
