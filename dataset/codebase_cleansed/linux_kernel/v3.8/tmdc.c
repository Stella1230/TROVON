static int tmdc_read_packet(struct gameport *gameport, unsigned char data[2][TMDC_MAX_LENGTH])\r\n{\r\nunsigned char u, v, w, x;\r\nunsigned long flags;\r\nint i[2], j[2], t[2], p, k;\r\np = gameport_time(gameport, TMDC_MAX_STROBE);\r\nfor (k = 0; k < 2; k++) {\r\nt[k] = gameport_time(gameport, TMDC_MAX_START);\r\ni[k] = j[k] = 0;\r\n}\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nw = gameport_read(gameport) >> 4;\r\ndo {\r\nx = w;\r\nw = gameport_read(gameport) >> 4;\r\nfor (k = 0, v = w, u = x; k < 2; k++, v >>= 2, u >>= 2) {\r\nif (~v & u & 2) {\r\nif (t[k] <= 0 || i[k] >= TMDC_MAX_LENGTH) continue;\r\nt[k] = p;\r\nif (j[k] == 0) {\r\nif (~v & 1) t[k] = 0;\r\ndata[k][i[k]] = 0; j[k]++; continue;\r\n}\r\nif (j[k] == 9) {\r\nif (v & 1) t[k] = 0;\r\nj[k] = 0; i[k]++; continue;\r\n}\r\ndata[k][i[k]] |= (~v & 1) << (j[k]++ - 1);\r\n}\r\nt[k]--;\r\n}\r\n} while (t[0] > 0 || t[1] > 0);\r\nlocal_irq_restore(flags);\r\nreturn (i[0] == TMDC_MAX_LENGTH) | ((i[1] == TMDC_MAX_LENGTH) << 1);\r\n}\r\nstatic int tmdc_parse_packet(struct tmdc_port *port, unsigned char *data)\r\n{\r\nint i, k, l;\r\nif (data[TMDC_BYTE_ID] != port->mode)\r\nreturn -1;\r\nfor (i = 0; i < port->absc; i++) {\r\nif (port->abs[i] < 0)\r\nreturn 0;\r\ninput_report_abs(port->dev, port->abs[i], data[tmdc_byte_a[i]]);\r\n}\r\nswitch (port->mode) {\r\ncase TMDC_MODE_M3DI:\r\ni = tmdc_byte_d[0];\r\ninput_report_abs(port->dev, ABS_HAT0X, ((data[i] >> 3) & 1) - ((data[i] >> 1) & 1));\r\ninput_report_abs(port->dev, ABS_HAT0Y, ((data[i] >> 2) & 1) - ( data[i] & 1));\r\nbreak;\r\ncase TMDC_MODE_AT:\r\ni = tmdc_byte_a[3];\r\ninput_report_abs(port->dev, ABS_HAT0X, tmdc_hat_to_axis[(data[i] - 141) / 25].x);\r\ninput_report_abs(port->dev, ABS_HAT0Y, tmdc_hat_to_axis[(data[i] - 141) / 25].y);\r\nbreak;\r\n}\r\nfor (k = l = 0; k < 4; k++) {\r\nfor (i = 0; i < port->btnc[k]; i++)\r\ninput_report_key(port->dev, port->btn[i + l],\r\n((data[tmdc_byte_d[k]] >> (i + port->btno[k])) & 1));\r\nl += port->btnc[k];\r\n}\r\ninput_sync(port->dev);\r\nreturn 0;\r\n}\r\nstatic void tmdc_poll(struct gameport *gameport)\r\n{\r\nunsigned char data[2][TMDC_MAX_LENGTH];\r\nstruct tmdc *tmdc = gameport_get_drvdata(gameport);\r\nunsigned char r, bad = 0;\r\nint i;\r\ntmdc->reads++;\r\nif ((r = tmdc_read_packet(tmdc->gameport, data)) != tmdc->exists)\r\nbad = 1;\r\nelse {\r\nfor (i = 0; i < 2; i++) {\r\nif (r & (1 << i) & tmdc->exists) {\r\nif (tmdc_parse_packet(tmdc->port[i], data[i]))\r\nbad = 1;\r\n}\r\n}\r\n}\r\ntmdc->bads += bad;\r\n}\r\nstatic int tmdc_open(struct input_dev *dev)\r\n{\r\nstruct tmdc *tmdc = input_get_drvdata(dev);\r\ngameport_start_polling(tmdc->gameport);\r\nreturn 0;\r\n}\r\nstatic void tmdc_close(struct input_dev *dev)\r\n{\r\nstruct tmdc *tmdc = input_get_drvdata(dev);\r\ngameport_stop_polling(tmdc->gameport);\r\n}\r\nstatic int tmdc_setup_port(struct tmdc *tmdc, int idx, unsigned char *data)\r\n{\r\nconst struct tmdc_model *model;\r\nstruct tmdc_port *port;\r\nstruct input_dev *input_dev;\r\nint i, j, b = 0;\r\nint err;\r\ntmdc->port[idx] = port = kzalloc(sizeof (struct tmdc_port), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!port || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nport->mode = data[TMDC_BYTE_ID];\r\nfor (model = tmdc_models; model->id && model->id != port->mode; model++)\r\n;\r\nport->abs = model->axes;\r\nport->btn = model->buttons;\r\nif (!model->id) {\r\nport->absc = data[TMDC_BYTE_DEF] >> 4;\r\nfor (i = 0; i < 4; i++)\r\nport->btnc[i] = i < (data[TMDC_BYTE_DEF] & 0xf) ? 8 : 0;\r\n} else {\r\nport->absc = model->abs;\r\nfor (i = 0; i < 4; i++)\r\nport->btnc[i] = model->btnc[i];\r\n}\r\nfor (i = 0; i < 4; i++)\r\nport->btno[i] = model->btno[i];\r\nsnprintf(port->name, sizeof(port->name), model->name,\r\nport->absc, (data[TMDC_BYTE_DEF] & 0xf) << 3, port->mode);\r\nsnprintf(port->phys, sizeof(port->phys), "%s/input%d", tmdc->gameport->phys, i);\r\nport->dev = input_dev;\r\ninput_dev->name = port->name;\r\ninput_dev->phys = port->phys;\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_THRUSTMASTER;\r\ninput_dev->id.product = model->id;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &tmdc->gameport->dev;\r\ninput_set_drvdata(input_dev, tmdc);\r\ninput_dev->open = tmdc_open;\r\ninput_dev->close = tmdc_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = 0; i < port->absc && i < TMDC_ABS; i++)\r\nif (port->abs[i] >= 0)\r\ninput_set_abs_params(input_dev, port->abs[i], 8, 248, 2, 4);\r\nfor (i = 0; i < model->hats && i < TMDC_ABS_HAT; i++)\r\ninput_set_abs_params(input_dev, tmdc_abs_hat[i], -1, 1, 0, 0);\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < port->btnc[i] && j < TMDC_BTN; j++)\r\nset_bit(port->btn[j + b], input_dev->keybit);\r\nb += port->btnc[i];\r\n}\r\nerr = input_register_device(port->dev);\r\nif (err)\r\ngoto fail;\r\nreturn 0;\r\nfail: input_free_device(input_dev);\r\nkfree(port);\r\nreturn err;\r\n}\r\nstatic int tmdc_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nunsigned char data[2][TMDC_MAX_LENGTH];\r\nstruct tmdc *tmdc;\r\nint i;\r\nint err;\r\nif (!(tmdc = kzalloc(sizeof(struct tmdc), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ntmdc->gameport = gameport;\r\ngameport_set_drvdata(gameport, tmdc);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\nif (!(tmdc->exists = tmdc_read_packet(gameport, data))) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\ngameport_set_poll_handler(gameport, tmdc_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nfor (i = 0; i < 2; i++) {\r\nif (tmdc->exists & (1 << i)) {\r\nerr = tmdc_setup_port(tmdc, i, data[i]);\r\nif (err)\r\ngoto fail3;\r\n}\r\n}\r\nreturn 0;\r\nfail3: while (--i >= 0) {\r\nif (tmdc->port[i]) {\r\ninput_unregister_device(tmdc->port[i]->dev);\r\nkfree(tmdc->port[i]);\r\n}\r\n}\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\nkfree(tmdc);\r\nreturn err;\r\n}\r\nstatic void tmdc_disconnect(struct gameport *gameport)\r\n{\r\nstruct tmdc *tmdc = gameport_get_drvdata(gameport);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (tmdc->port[i]) {\r\ninput_unregister_device(tmdc->port[i]->dev);\r\nkfree(tmdc->port[i]);\r\n}\r\n}\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(tmdc);\r\n}
