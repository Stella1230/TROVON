static struct buffer_head *\r\nread_inode_bitmap(struct super_block * sb, unsigned long block_group)\r\n{\r\nstruct ext3_group_desc *desc;\r\nstruct buffer_head *bh = NULL;\r\ndesc = ext3_get_group_desc(sb, block_group, NULL);\r\nif (!desc)\r\ngoto error_out;\r\nbh = sb_bread(sb, le32_to_cpu(desc->bg_inode_bitmap));\r\nif (!bh)\r\next3_error(sb, "read_inode_bitmap",\r\n"Cannot read inode bitmap - "\r\n"block_group = %lu, inode_bitmap = %u",\r\nblock_group, le32_to_cpu(desc->bg_inode_bitmap));\r\nerror_out:\r\nreturn bh;\r\n}\r\nvoid ext3_free_inode (handle_t *handle, struct inode * inode)\r\n{\r\nstruct super_block * sb = inode->i_sb;\r\nint is_directory;\r\nunsigned long ino;\r\nstruct buffer_head *bitmap_bh = NULL;\r\nstruct buffer_head *bh2;\r\nunsigned long block_group;\r\nunsigned long bit;\r\nstruct ext3_group_desc * gdp;\r\nstruct ext3_super_block * es;\r\nstruct ext3_sb_info *sbi;\r\nint fatal = 0, err;\r\nif (atomic_read(&inode->i_count) > 1) {\r\nprintk ("ext3_free_inode: inode has count=%d\n",\r\natomic_read(&inode->i_count));\r\nreturn;\r\n}\r\nif (inode->i_nlink) {\r\nprintk ("ext3_free_inode: inode has nlink=%d\n",\r\ninode->i_nlink);\r\nreturn;\r\n}\r\nif (!sb) {\r\nprintk("ext3_free_inode: inode on nonexistent device\n");\r\nreturn;\r\n}\r\nsbi = EXT3_SB(sb);\r\nino = inode->i_ino;\r\next3_debug ("freeing inode %lu\n", ino);\r\ntrace_ext3_free_inode(inode);\r\nis_directory = S_ISDIR(inode->i_mode);\r\nes = EXT3_SB(sb)->s_es;\r\nif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\r\next3_error (sb, "ext3_free_inode",\r\n"reserved or nonexistent inode %lu", ino);\r\ngoto error_return;\r\n}\r\nblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\r\nbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\r\nbitmap_bh = read_inode_bitmap(sb, block_group);\r\nif (!bitmap_bh)\r\ngoto error_return;\r\nBUFFER_TRACE(bitmap_bh, "get_write_access");\r\nfatal = ext3_journal_get_write_access(handle, bitmap_bh);\r\nif (fatal)\r\ngoto error_return;\r\nif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\r\nbit, bitmap_bh->b_data))\r\next3_error (sb, "ext3_free_inode",\r\n"bit already cleared for inode %lu", ino);\r\nelse {\r\ngdp = ext3_get_group_desc (sb, block_group, &bh2);\r\nBUFFER_TRACE(bh2, "get_write_access");\r\nfatal = ext3_journal_get_write_access(handle, bh2);\r\nif (fatal) goto error_return;\r\nif (gdp) {\r\nspin_lock(sb_bgl_lock(sbi, block_group));\r\nle16_add_cpu(&gdp->bg_free_inodes_count, 1);\r\nif (is_directory)\r\nle16_add_cpu(&gdp->bg_used_dirs_count, -1);\r\nspin_unlock(sb_bgl_lock(sbi, block_group));\r\npercpu_counter_inc(&sbi->s_freeinodes_counter);\r\nif (is_directory)\r\npercpu_counter_dec(&sbi->s_dirs_counter);\r\n}\r\nBUFFER_TRACE(bh2, "call ext3_journal_dirty_metadata");\r\nerr = ext3_journal_dirty_metadata(handle, bh2);\r\nif (!fatal) fatal = err;\r\n}\r\nBUFFER_TRACE(bitmap_bh, "call ext3_journal_dirty_metadata");\r\nerr = ext3_journal_dirty_metadata(handle, bitmap_bh);\r\nif (!fatal)\r\nfatal = err;\r\nerror_return:\r\nbrelse(bitmap_bh);\r\next3_std_error(sb, fatal);\r\n}\r\nstatic int find_group_orlov(struct super_block *sb, struct inode *parent)\r\n{\r\nint parent_group = EXT3_I(parent)->i_block_group;\r\nstruct ext3_sb_info *sbi = EXT3_SB(sb);\r\nint ngroups = sbi->s_groups_count;\r\nint inodes_per_group = EXT3_INODES_PER_GROUP(sb);\r\nunsigned int freei, avefreei;\r\next3_fsblk_t freeb, avefreeb;\r\nunsigned int ndirs;\r\nint max_dirs, min_inodes;\r\next3_grpblk_t min_blocks;\r\nint group = -1, i;\r\nstruct ext3_group_desc *desc;\r\nfreei = percpu_counter_read_positive(&sbi->s_freeinodes_counter);\r\navefreei = freei / ngroups;\r\nfreeb = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\r\navefreeb = freeb / ngroups;\r\nndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);\r\nif ((parent == sb->s_root->d_inode) ||\r\n(EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {\r\nint best_ndir = inodes_per_group;\r\nint best_group = -1;\r\nget_random_bytes(&group, sizeof(group));\r\nparent_group = (unsigned)group % ngroups;\r\nfor (i = 0; i < ngroups; i++) {\r\ngroup = (parent_group + i) % ngroups;\r\ndesc = ext3_get_group_desc (sb, group, NULL);\r\nif (!desc || !desc->bg_free_inodes_count)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_used_dirs_count) >= best_ndir)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_free_inodes_count) < avefreei)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_free_blocks_count) < avefreeb)\r\ncontinue;\r\nbest_group = group;\r\nbest_ndir = le16_to_cpu(desc->bg_used_dirs_count);\r\n}\r\nif (best_group >= 0)\r\nreturn best_group;\r\ngoto fallback;\r\n}\r\nmax_dirs = ndirs / ngroups + inodes_per_group / 16;\r\nmin_inodes = avefreei - inodes_per_group / 4;\r\nmin_blocks = avefreeb - EXT3_BLOCKS_PER_GROUP(sb) / 4;\r\nfor (i = 0; i < ngroups; i++) {\r\ngroup = (parent_group + i) % ngroups;\r\ndesc = ext3_get_group_desc (sb, group, NULL);\r\nif (!desc || !desc->bg_free_inodes_count)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_used_dirs_count) >= max_dirs)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_free_inodes_count) < min_inodes)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_free_blocks_count) < min_blocks)\r\ncontinue;\r\nreturn group;\r\n}\r\nfallback:\r\nfor (i = 0; i < ngroups; i++) {\r\ngroup = (parent_group + i) % ngroups;\r\ndesc = ext3_get_group_desc (sb, group, NULL);\r\nif (!desc || !desc->bg_free_inodes_count)\r\ncontinue;\r\nif (le16_to_cpu(desc->bg_free_inodes_count) >= avefreei)\r\nreturn group;\r\n}\r\nif (avefreei) {\r\navefreei = 0;\r\ngoto fallback;\r\n}\r\nreturn -1;\r\n}\r\nstatic int find_group_other(struct super_block *sb, struct inode *parent)\r\n{\r\nint parent_group = EXT3_I(parent)->i_block_group;\r\nint ngroups = EXT3_SB(sb)->s_groups_count;\r\nstruct ext3_group_desc *desc;\r\nint group, i;\r\ngroup = parent_group;\r\ndesc = ext3_get_group_desc (sb, group, NULL);\r\nif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\r\nle16_to_cpu(desc->bg_free_blocks_count))\r\nreturn group;\r\ngroup = (group + parent->i_ino) % ngroups;\r\nfor (i = 1; i < ngroups; i <<= 1) {\r\ngroup += i;\r\nif (group >= ngroups)\r\ngroup -= ngroups;\r\ndesc = ext3_get_group_desc (sb, group, NULL);\r\nif (desc && le16_to_cpu(desc->bg_free_inodes_count) &&\r\nle16_to_cpu(desc->bg_free_blocks_count))\r\nreturn group;\r\n}\r\ngroup = parent_group;\r\nfor (i = 0; i < ngroups; i++) {\r\nif (++group >= ngroups)\r\ngroup = 0;\r\ndesc = ext3_get_group_desc (sb, group, NULL);\r\nif (desc && le16_to_cpu(desc->bg_free_inodes_count))\r\nreturn group;\r\n}\r\nreturn -1;\r\n}\r\nstruct inode *ext3_new_inode(handle_t *handle, struct inode * dir,\r\nconst struct qstr *qstr, umode_t mode)\r\n{\r\nstruct super_block *sb;\r\nstruct buffer_head *bitmap_bh = NULL;\r\nstruct buffer_head *bh2;\r\nint group;\r\nunsigned long ino = 0;\r\nstruct inode * inode;\r\nstruct ext3_group_desc * gdp = NULL;\r\nstruct ext3_super_block * es;\r\nstruct ext3_inode_info *ei;\r\nstruct ext3_sb_info *sbi;\r\nint err = 0;\r\nstruct inode *ret;\r\nint i;\r\nif (!dir || !dir->i_nlink)\r\nreturn ERR_PTR(-EPERM);\r\nsb = dir->i_sb;\r\ntrace_ext3_request_inode(dir, mode);\r\ninode = new_inode(sb);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\nei = EXT3_I(inode);\r\nsbi = EXT3_SB(sb);\r\nes = sbi->s_es;\r\nif (S_ISDIR(mode))\r\ngroup = find_group_orlov(sb, dir);\r\nelse\r\ngroup = find_group_other(sb, dir);\r\nerr = -ENOSPC;\r\nif (group == -1)\r\ngoto out;\r\nfor (i = 0; i < sbi->s_groups_count; i++) {\r\nerr = -EIO;\r\ngdp = ext3_get_group_desc(sb, group, &bh2);\r\nif (!gdp)\r\ngoto fail;\r\nbrelse(bitmap_bh);\r\nbitmap_bh = read_inode_bitmap(sb, group);\r\nif (!bitmap_bh)\r\ngoto fail;\r\nino = 0;\r\nrepeat_in_this_group:\r\nino = ext3_find_next_zero_bit((unsigned long *)\r\nbitmap_bh->b_data, EXT3_INODES_PER_GROUP(sb), ino);\r\nif (ino < EXT3_INODES_PER_GROUP(sb)) {\r\nBUFFER_TRACE(bitmap_bh, "get_write_access");\r\nerr = ext3_journal_get_write_access(handle, bitmap_bh);\r\nif (err)\r\ngoto fail;\r\nif (!ext3_set_bit_atomic(sb_bgl_lock(sbi, group),\r\nino, bitmap_bh->b_data)) {\r\nBUFFER_TRACE(bitmap_bh,\r\n"call ext3_journal_dirty_metadata");\r\nerr = ext3_journal_dirty_metadata(handle,\r\nbitmap_bh);\r\nif (err)\r\ngoto fail;\r\ngoto got;\r\n}\r\njournal_release_buffer(handle, bitmap_bh);\r\nif (++ino < EXT3_INODES_PER_GROUP(sb))\r\ngoto repeat_in_this_group;\r\n}\r\nif (++group == sbi->s_groups_count)\r\ngroup = 0;\r\n}\r\nerr = -ENOSPC;\r\ngoto out;\r\ngot:\r\nino += group * EXT3_INODES_PER_GROUP(sb) + 1;\r\nif (ino < EXT3_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\r\next3_error (sb, "ext3_new_inode",\r\n"reserved inode or inode > inodes count - "\r\n"block_group = %d, inode=%lu", group, ino);\r\nerr = -EIO;\r\ngoto fail;\r\n}\r\nBUFFER_TRACE(bh2, "get_write_access");\r\nerr = ext3_journal_get_write_access(handle, bh2);\r\nif (err) goto fail;\r\nspin_lock(sb_bgl_lock(sbi, group));\r\nle16_add_cpu(&gdp->bg_free_inodes_count, -1);\r\nif (S_ISDIR(mode)) {\r\nle16_add_cpu(&gdp->bg_used_dirs_count, 1);\r\n}\r\nspin_unlock(sb_bgl_lock(sbi, group));\r\nBUFFER_TRACE(bh2, "call ext3_journal_dirty_metadata");\r\nerr = ext3_journal_dirty_metadata(handle, bh2);\r\nif (err) goto fail;\r\npercpu_counter_dec(&sbi->s_freeinodes_counter);\r\nif (S_ISDIR(mode))\r\npercpu_counter_inc(&sbi->s_dirs_counter);\r\nif (test_opt(sb, GRPID)) {\r\ninode->i_mode = mode;\r\ninode->i_uid = current_fsuid();\r\ninode->i_gid = dir->i_gid;\r\n} else\r\ninode_init_owner(inode, dir, mode);\r\ninode->i_ino = ino;\r\ninode->i_blocks = 0;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\r\nmemset(ei->i_data, 0, sizeof(ei->i_data));\r\nei->i_dir_start_lookup = 0;\r\nei->i_disksize = 0;\r\nei->i_flags =\r\next3_mask_flags(mode, EXT3_I(dir)->i_flags & EXT3_FL_INHERITED);\r\n#ifdef EXT3_FRAGMENTS\r\nei->i_faddr = 0;\r\nei->i_frag_no = 0;\r\nei->i_frag_size = 0;\r\n#endif\r\nei->i_file_acl = 0;\r\nei->i_dir_acl = 0;\r\nei->i_dtime = 0;\r\nei->i_block_alloc_info = NULL;\r\nei->i_block_group = group;\r\next3_set_inode_flags(inode);\r\nif (IS_DIRSYNC(inode))\r\nhandle->h_sync = 1;\r\nif (insert_inode_locked(inode) < 0) {\r\nerr = -EIO;\r\ngoto fail;\r\n}\r\nspin_lock(&sbi->s_next_gen_lock);\r\ninode->i_generation = sbi->s_next_generation++;\r\nspin_unlock(&sbi->s_next_gen_lock);\r\nei->i_state_flags = 0;\r\next3_set_inode_state(inode, EXT3_STATE_NEW);\r\nif (ino >= EXT3_FIRST_INO(sb) + 1 &&\r\nEXT3_INODE_SIZE(sb) > EXT3_GOOD_OLD_INODE_SIZE) {\r\nei->i_extra_isize =\r\nsizeof(struct ext3_inode) - EXT3_GOOD_OLD_INODE_SIZE;\r\n} else {\r\nei->i_extra_isize = 0;\r\n}\r\nret = inode;\r\ndquot_initialize(inode);\r\nerr = dquot_alloc_inode(inode);\r\nif (err)\r\ngoto fail_drop;\r\nerr = ext3_init_acl(handle, inode, dir);\r\nif (err)\r\ngoto fail_free_drop;\r\nerr = ext3_init_security(handle, inode, dir, qstr);\r\nif (err)\r\ngoto fail_free_drop;\r\nerr = ext3_mark_inode_dirty(handle, inode);\r\nif (err) {\r\next3_std_error(sb, err);\r\ngoto fail_free_drop;\r\n}\r\next3_debug("allocating inode %lu\n", inode->i_ino);\r\ntrace_ext3_allocate_inode(inode, dir, mode);\r\ngoto really_out;\r\nfail:\r\next3_std_error(sb, err);\r\nout:\r\niput(inode);\r\nret = ERR_PTR(err);\r\nreally_out:\r\nbrelse(bitmap_bh);\r\nreturn ret;\r\nfail_free_drop:\r\ndquot_free_inode(inode);\r\nfail_drop:\r\ndquot_drop(inode);\r\ninode->i_flags |= S_NOQUOTA;\r\nclear_nlink(inode);\r\nunlock_new_inode(inode);\r\niput(inode);\r\nbrelse(bitmap_bh);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct inode *ext3_orphan_get(struct super_block *sb, unsigned long ino)\r\n{\r\nunsigned long max_ino = le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count);\r\nunsigned long block_group;\r\nint bit;\r\nstruct buffer_head *bitmap_bh;\r\nstruct inode *inode = NULL;\r\nlong err = -EIO;\r\nif (ino > max_ino) {\r\next3_warning(sb, __func__,\r\n"bad orphan ino %lu! e2fsck was run?", ino);\r\ngoto error;\r\n}\r\nblock_group = (ino - 1) / EXT3_INODES_PER_GROUP(sb);\r\nbit = (ino - 1) % EXT3_INODES_PER_GROUP(sb);\r\nbitmap_bh = read_inode_bitmap(sb, block_group);\r\nif (!bitmap_bh) {\r\next3_warning(sb, __func__,\r\n"inode bitmap error for orphan %lu", ino);\r\ngoto error;\r\n}\r\nif (!ext3_test_bit(bit, bitmap_bh->b_data))\r\ngoto bad_orphan;\r\ninode = ext3_iget(sb, ino);\r\nif (IS_ERR(inode))\r\ngoto iget_failed;\r\nif (inode->i_nlink && !ext3_can_truncate(inode))\r\ngoto bad_orphan;\r\nif (NEXT_ORPHAN(inode) > max_ino)\r\ngoto bad_orphan;\r\nbrelse(bitmap_bh);\r\nreturn inode;\r\niget_failed:\r\nerr = PTR_ERR(inode);\r\ninode = NULL;\r\nbad_orphan:\r\next3_warning(sb, __func__,\r\n"bad orphan inode %lu! e2fsck was run?", ino);\r\nprintk(KERN_NOTICE "ext3_test_bit(bit=%d, block=%llu) = %d\n",\r\nbit, (unsigned long long)bitmap_bh->b_blocknr,\r\next3_test_bit(bit, bitmap_bh->b_data));\r\nprintk(KERN_NOTICE "inode=%p\n", inode);\r\nif (inode) {\r\nprintk(KERN_NOTICE "is_bad_inode(inode)=%d\n",\r\nis_bad_inode(inode));\r\nprintk(KERN_NOTICE "NEXT_ORPHAN(inode)=%u\n",\r\nNEXT_ORPHAN(inode));\r\nprintk(KERN_NOTICE "max_ino=%lu\n", max_ino);\r\nprintk(KERN_NOTICE "i_nlink=%u\n", inode->i_nlink);\r\nif (inode->i_nlink == 0)\r\ninode->i_blocks = 0;\r\niput(inode);\r\n}\r\nbrelse(bitmap_bh);\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nunsigned long ext3_count_free_inodes (struct super_block * sb)\r\n{\r\nunsigned long desc_count;\r\nstruct ext3_group_desc *gdp;\r\nint i;\r\n#ifdef EXT3FS_DEBUG\r\nstruct ext3_super_block *es;\r\nunsigned long bitmap_count, x;\r\nstruct buffer_head *bitmap_bh = NULL;\r\nes = EXT3_SB(sb)->s_es;\r\ndesc_count = 0;\r\nbitmap_count = 0;\r\ngdp = NULL;\r\nfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\r\ngdp = ext3_get_group_desc (sb, i, NULL);\r\nif (!gdp)\r\ncontinue;\r\ndesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\r\nbrelse(bitmap_bh);\r\nbitmap_bh = read_inode_bitmap(sb, i);\r\nif (!bitmap_bh)\r\ncontinue;\r\nx = ext3_count_free(bitmap_bh, EXT3_INODES_PER_GROUP(sb) / 8);\r\nprintk("group %d: stored = %d, counted = %lu\n",\r\ni, le16_to_cpu(gdp->bg_free_inodes_count), x);\r\nbitmap_count += x;\r\n}\r\nbrelse(bitmap_bh);\r\nprintk("ext3_count_free_inodes: stored = %u, computed = %lu, %lu\n",\r\nle32_to_cpu(es->s_free_inodes_count), desc_count, bitmap_count);\r\nreturn desc_count;\r\n#else\r\ndesc_count = 0;\r\nfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\r\ngdp = ext3_get_group_desc (sb, i, NULL);\r\nif (!gdp)\r\ncontinue;\r\ndesc_count += le16_to_cpu(gdp->bg_free_inodes_count);\r\ncond_resched();\r\n}\r\nreturn desc_count;\r\n#endif\r\n}\r\nunsigned long ext3_count_dirs (struct super_block * sb)\r\n{\r\nunsigned long count = 0;\r\nint i;\r\nfor (i = 0; i < EXT3_SB(sb)->s_groups_count; i++) {\r\nstruct ext3_group_desc *gdp = ext3_get_group_desc (sb, i, NULL);\r\nif (!gdp)\r\ncontinue;\r\ncount += le16_to_cpu(gdp->bg_used_dirs_count);\r\n}\r\nreturn count;\r\n}
