int nv04_tv_identify(struct drm_device *dev, int i2c_index)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_i2c *i2c = nouveau_i2c(drm->device);\r\nreturn i2c->identify(i2c, i2c_index, "TV encoder",\r\nnv04_tv_encoder_info, NULL);\r\n}\r\nstatic void nv04_tv_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\r\nuint8_t crtc1A;\r\nNV_DEBUG(drm, "Setting dpms mode %d on TV encoder (output %d)\n",\r\nmode, nv_encoder->dcb->index);\r\nstate->pllsel &= ~(PLLSEL_TV_CRTC1_MASK | PLLSEL_TV_CRTC2_MASK);\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\ncrtc1A = NVReadVgaCrtc(dev, head, NV_CIO_CRE_RPC1_INDEX);\r\nstate->pllsel |= head ? PLLSEL_TV_CRTC2_MASK :\r\nPLLSEL_TV_CRTC1_MASK;\r\ncrtc1A |= 0x80;\r\nNVWriteVgaCrtc(dev, head, NV_CIO_CRE_RPC1_INDEX, crtc1A);\r\n}\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT, state->pllsel);\r\nget_slave_funcs(encoder)->dpms(encoder, mode);\r\n}\r\nstatic void nv04_tv_bind(struct drm_device *dev, int head, bool bind)\r\n{\r\nstruct nv04_crtc_reg *state = &nv04_display(dev)->mode_reg.crtc_reg[head];\r\nstate->tv_setup = 0;\r\nif (bind)\r\nstate->CRTC[NV_CIO_CRE_49] |= 0x10;\r\nelse\r\nstate->CRTC[NV_CIO_CRE_49] &= ~0x10;\r\nNVWriteVgaCrtc(dev, head, NV_CIO_CRE_LCD__INDEX,\r\nstate->CRTC[NV_CIO_CRE_LCD__INDEX]);\r\nNVWriteVgaCrtc(dev, head, NV_CIO_CRE_49,\r\nstate->CRTC[NV_CIO_CRE_49]);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP,\r\nstate->tv_setup);\r\n}\r\nstatic void nv04_tv_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nhelper->dpms(encoder, DRM_MODE_DPMS_OFF);\r\nnv04_dfp_disable(dev, head);\r\nif (nv_two_heads(dev))\r\nnv04_tv_bind(dev, head ^ 1, false);\r\nnv04_tv_bind(dev, head, true);\r\n}\r\nstatic void nv04_tv_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nregp->tv_htotal = adjusted_mode->htotal;\r\nregp->tv_vtotal = adjusted_mode->vtotal;\r\nregp->tv_hskew = 1;\r\nregp->tv_hsync_delay = 1;\r\nregp->tv_hsync_delay2 = 64;\r\nregp->tv_vskew = 1;\r\nregp->tv_vsync_delay = 1;\r\nget_slave_funcs(encoder)->mode_set(encoder, mode, adjusted_mode);\r\n}\r\nstatic void nv04_tv_commit(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nhelper->dpms(encoder, DRM_MODE_DPMS_ON);\r\nNV_DEBUG(drm, "Output %s is running on CRTC %d using output %c\n",\r\ndrm_get_connector_name(&nouveau_encoder_connector_get(nv_encoder)->base), nv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\r\n}\r\nstatic void nv04_tv_destroy(struct drm_encoder *encoder)\r\n{\r\nget_slave_funcs(encoder)->destroy(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(encoder->helper_private);\r\nkfree(nouveau_encoder(encoder));\r\n}\r\nint\r\nnv04_tv_create(struct drm_connector *connector, struct dcb_output *entry)\r\n{\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *encoder;\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_encoder_helper_funcs *hfuncs;\r\nstruct drm_encoder_slave_funcs *sfuncs;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_i2c *i2c = nouveau_i2c(drm->device);\r\nstruct nouveau_i2c_port *port = i2c->find(i2c, entry->i2c_index);\r\nint type, ret;\r\ntype = nv04_tv_identify(dev, entry->i2c_index);\r\nif (type < 0)\r\nreturn type;\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nhfuncs = kzalloc(sizeof(*hfuncs), GFP_KERNEL);\r\nif (!hfuncs) {\r\nret = -ENOMEM;\r\ngoto fail_free;\r\n}\r\nencoder = to_drm_encoder(nv_encoder);\r\ndrm_encoder_init(dev, encoder, &nv04_tv_funcs, DRM_MODE_ENCODER_TVDAC);\r\ndrm_encoder_helper_add(encoder, hfuncs);\r\nencoder->possible_crtcs = entry->heads;\r\nencoder->possible_clones = 0;\r\nnv_encoder->dcb = entry;\r\nnv_encoder->or = ffs(entry->or) - 1;\r\nret = drm_i2c_encoder_init(dev, to_encoder_slave(encoder),\r\n&port->adapter, &nv04_tv_encoder_info[type]);\r\nif (ret < 0)\r\ngoto fail_cleanup;\r\nsfuncs = get_slave_funcs(encoder);\r\n*hfuncs = (struct drm_encoder_helper_funcs) {\r\n.dpms = nv04_tv_dpms,\r\n.save = sfuncs->save,\r\n.restore = sfuncs->restore,\r\n.mode_fixup = sfuncs->mode_fixup,\r\n.prepare = nv04_tv_prepare,\r\n.commit = nv04_tv_commit,\r\n.mode_set = nv04_tv_mode_set,\r\n.detect = sfuncs->detect,\r\n};\r\nsfuncs->create_resources(encoder, connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\nfail_cleanup:\r\ndrm_encoder_cleanup(encoder);\r\nkfree(hfuncs);\r\nfail_free:\r\nkfree(nv_encoder);\r\nreturn ret;\r\n}
