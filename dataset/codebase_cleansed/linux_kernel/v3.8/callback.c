void afs_init_callback_state(struct afs_server *server)\r\n{\r\nstruct afs_vnode *vnode;\r\n_enter("{%p}", server);\r\nspin_lock(&server->cb_lock);\r\nwhile (!RB_EMPTY_ROOT(&server->cb_promises)) {\r\nvnode = rb_entry(server->cb_promises.rb_node,\r\nstruct afs_vnode, cb_promise);\r\n_debug("UNPROMISE { vid=%x:%u uq=%u}",\r\nvnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\r\nrb_erase(&vnode->cb_promise, &server->cb_promises);\r\nvnode->cb_promised = false;\r\n}\r\nspin_unlock(&server->cb_lock);\r\n_leave("");\r\n}\r\nvoid afs_broken_callback_work(struct work_struct *work)\r\n{\r\nstruct afs_vnode *vnode =\r\ncontainer_of(work, struct afs_vnode, cb_broken_work);\r\n_enter("");\r\nif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\r\nreturn;\r\nif (!mutex_trylock(&vnode->validate_lock))\r\nreturn;\r\nif (test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\r\nif (S_ISDIR(vnode->vfs_inode.i_mode))\r\nafs_clear_permits(vnode);\r\nif (afs_vnode_fetch_status(vnode, NULL, NULL) < 0)\r\ngoto out;\r\nif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\r\ngoto out;\r\nif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\r\nafs_zap_data(vnode);\r\n}\r\nout:\r\nmutex_unlock(&vnode->validate_lock);\r\nif (test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\r\n_debug("requeue");\r\nqueue_work(afs_callback_update_worker, &vnode->cb_broken_work);\r\n}\r\n_leave("");\r\n}\r\nstatic void afs_break_callback(struct afs_server *server,\r\nstruct afs_vnode *vnode)\r\n{\r\n_enter("");\r\nset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\r\nif (vnode->cb_promised) {\r\nspin_lock(&vnode->lock);\r\n_debug("break callback");\r\nspin_lock(&server->cb_lock);\r\nif (vnode->cb_promised) {\r\nrb_erase(&vnode->cb_promise, &server->cb_promises);\r\nvnode->cb_promised = false;\r\n}\r\nspin_unlock(&server->cb_lock);\r\nqueue_work(afs_callback_update_worker, &vnode->cb_broken_work);\r\nif (list_empty(&vnode->granted_locks) &&\r\n!list_empty(&vnode->pending_locks))\r\nafs_lock_may_be_available(vnode);\r\nspin_unlock(&vnode->lock);\r\n}\r\n}\r\nstatic void afs_break_one_callback(struct afs_server *server,\r\nstruct afs_fid *fid)\r\n{\r\nstruct afs_vnode *vnode;\r\nstruct rb_node *p;\r\n_debug("find");\r\nspin_lock(&server->fs_lock);\r\np = server->fs_vnodes.rb_node;\r\nwhile (p) {\r\nvnode = rb_entry(p, struct afs_vnode, server_rb);\r\nif (fid->vid < vnode->fid.vid)\r\np = p->rb_left;\r\nelse if (fid->vid > vnode->fid.vid)\r\np = p->rb_right;\r\nelse if (fid->vnode < vnode->fid.vnode)\r\np = p->rb_left;\r\nelse if (fid->vnode > vnode->fid.vnode)\r\np = p->rb_right;\r\nelse if (fid->unique < vnode->fid.unique)\r\np = p->rb_left;\r\nelse if (fid->unique > vnode->fid.unique)\r\np = p->rb_right;\r\nelse\r\ngoto found;\r\n}\r\nnot_available:\r\n_debug("not avail");\r\nspin_unlock(&server->fs_lock);\r\n_leave("");\r\nreturn;\r\nfound:\r\n_debug("found");\r\nASSERTCMP(server, ==, vnode->server);\r\nif (!igrab(AFS_VNODE_TO_I(vnode)))\r\ngoto not_available;\r\nspin_unlock(&server->fs_lock);\r\nafs_break_callback(server, vnode);\r\niput(&vnode->vfs_inode);\r\n_leave("");\r\n}\r\nvoid afs_break_callbacks(struct afs_server *server, size_t count,\r\nstruct afs_callback callbacks[])\r\n{\r\n_enter("%p,%zu,", server, count);\r\nASSERT(server != NULL);\r\nASSERTCMP(count, <=, AFSCBMAX);\r\nfor (; count > 0; callbacks++, count--) {\r\n_debug("- Fid { vl=%08x n=%u u=%u } CB { v=%u x=%u t=%u }",\r\ncallbacks->fid.vid,\r\ncallbacks->fid.vnode,\r\ncallbacks->fid.unique,\r\ncallbacks->version,\r\ncallbacks->expiry,\r\ncallbacks->type\r\n);\r\nafs_break_one_callback(server, &callbacks->fid);\r\n}\r\n_leave("");\r\nreturn;\r\n}\r\nstatic void afs_do_give_up_callback(struct afs_server *server,\r\nstruct afs_vnode *vnode)\r\n{\r\nstruct afs_callback *cb;\r\n_enter("%p,%p", server, vnode);\r\ncb = &server->cb_break[server->cb_break_head];\r\ncb->fid = vnode->fid;\r\ncb->version = vnode->cb_version;\r\ncb->expiry = vnode->cb_expiry;\r\ncb->type = vnode->cb_type;\r\nsmp_wmb();\r\nserver->cb_break_head =\r\n(server->cb_break_head + 1) &\r\n(ARRAY_SIZE(server->cb_break) - 1);\r\nswitch (atomic_inc_return(&server->cb_break_n)) {\r\ncase 1 ... AFSCBMAX - 1:\r\nqueue_delayed_work(afs_callback_update_worker,\r\n&server->cb_break_work, HZ * 2);\r\nbreak;\r\ncase AFSCBMAX:\r\nafs_flush_callback_breaks(server);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nASSERT(server->cb_promises.rb_node != NULL);\r\nrb_erase(&vnode->cb_promise, &server->cb_promises);\r\nvnode->cb_promised = false;\r\n_leave("");\r\n}\r\nvoid afs_discard_callback_on_delete(struct afs_vnode *vnode)\r\n{\r\nstruct afs_server *server = vnode->server;\r\n_enter("%d", vnode->cb_promised);\r\nif (!vnode->cb_promised) {\r\n_leave(" [not promised]");\r\nreturn;\r\n}\r\nASSERT(server != NULL);\r\nspin_lock(&server->cb_lock);\r\nif (vnode->cb_promised) {\r\nASSERT(server->cb_promises.rb_node != NULL);\r\nrb_erase(&vnode->cb_promise, &server->cb_promises);\r\nvnode->cb_promised = false;\r\n}\r\nspin_unlock(&server->cb_lock);\r\n_leave("");\r\n}\r\nvoid afs_give_up_callback(struct afs_vnode *vnode)\r\n{\r\nstruct afs_server *server = vnode->server;\r\nDECLARE_WAITQUEUE(myself, current);\r\n_enter("%d", vnode->cb_promised);\r\n_debug("GIVE UP INODE %p", &vnode->vfs_inode);\r\nif (!vnode->cb_promised) {\r\n_leave(" [not promised]");\r\nreturn;\r\n}\r\nASSERT(server != NULL);\r\nspin_lock(&server->cb_lock);\r\nif (vnode->cb_promised && afs_breakring_space(server) == 0) {\r\nadd_wait_queue(&server->cb_break_waitq, &myself);\r\nfor (;;) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (!vnode->cb_promised ||\r\nafs_breakring_space(server) != 0)\r\nbreak;\r\nspin_unlock(&server->cb_lock);\r\nschedule();\r\nspin_lock(&server->cb_lock);\r\n}\r\nremove_wait_queue(&server->cb_break_waitq, &myself);\r\n__set_current_state(TASK_RUNNING);\r\n}\r\nif (vnode->cb_promised)\r\nafs_do_give_up_callback(server, vnode);\r\nspin_unlock(&server->cb_lock);\r\n_leave("");\r\n}\r\nvoid afs_dispatch_give_up_callbacks(struct work_struct *work)\r\n{\r\nstruct afs_server *server =\r\ncontainer_of(work, struct afs_server, cb_break_work.work);\r\n_enter("");\r\nafs_fs_give_up_callbacks(server, &afs_async_call);\r\n}\r\nvoid afs_flush_callback_breaks(struct afs_server *server)\r\n{\r\nmod_delayed_work(afs_callback_update_worker, &server->cb_break_work, 0);\r\n}\r\nint __init afs_callback_update_init(void)\r\n{\r\nafs_callback_update_worker =\r\ncreate_singlethread_workqueue("kafs_callbackd");\r\nreturn afs_callback_update_worker ? 0 : -ENOMEM;\r\n}\r\nvoid afs_callback_update_kill(void)\r\n{\r\ndestroy_workqueue(afs_callback_update_worker);\r\n}
