static inline u32 pch_udc_readl(struct pch_udc_dev *dev, unsigned long reg)\r\n{\r\nreturn ioread32(dev->base_addr + reg);\r\n}\r\nstatic inline void pch_udc_writel(struct pch_udc_dev *dev,\r\nunsigned long val, unsigned long reg)\r\n{\r\niowrite32(val, dev->base_addr + reg);\r\n}\r\nstatic inline void pch_udc_bit_set(struct pch_udc_dev *dev,\r\nunsigned long reg,\r\nunsigned long bitmask)\r\n{\r\npch_udc_writel(dev, pch_udc_readl(dev, reg) | bitmask, reg);\r\n}\r\nstatic inline void pch_udc_bit_clr(struct pch_udc_dev *dev,\r\nunsigned long reg,\r\nunsigned long bitmask)\r\n{\r\npch_udc_writel(dev, pch_udc_readl(dev, reg) & ~(bitmask), reg);\r\n}\r\nstatic inline u32 pch_udc_ep_readl(struct pch_udc_ep *ep, unsigned long reg)\r\n{\r\nreturn ioread32(ep->dev->base_addr + ep->offset_addr + reg);\r\n}\r\nstatic inline void pch_udc_ep_writel(struct pch_udc_ep *ep,\r\nunsigned long val, unsigned long reg)\r\n{\r\niowrite32(val, ep->dev->base_addr + ep->offset_addr + reg);\r\n}\r\nstatic inline void pch_udc_ep_bit_set(struct pch_udc_ep *ep,\r\nunsigned long reg,\r\nunsigned long bitmask)\r\n{\r\npch_udc_ep_writel(ep, pch_udc_ep_readl(ep, reg) | bitmask, reg);\r\n}\r\nstatic inline void pch_udc_ep_bit_clr(struct pch_udc_ep *ep,\r\nunsigned long reg,\r\nunsigned long bitmask)\r\n{\r\npch_udc_ep_writel(ep, pch_udc_ep_readl(ep, reg) & ~(bitmask), reg);\r\n}\r\nstatic void pch_udc_csr_busy(struct pch_udc_dev *dev)\r\n{\r\nunsigned int count = 200;\r\nwhile ((pch_udc_readl(dev, UDC_CSR_BUSY_ADDR) & UDC_CSR_BUSY)\r\n&& --count)\r\ncpu_relax();\r\nif (!count)\r\ndev_err(&dev->pdev->dev, "%s: wait error\n", __func__);\r\n}\r\nstatic void pch_udc_write_csr(struct pch_udc_dev *dev, unsigned long val,\r\nunsigned int ep)\r\n{\r\nunsigned long reg = PCH_UDC_CSR(ep);\r\npch_udc_csr_busy(dev);\r\npch_udc_writel(dev, val, reg);\r\npch_udc_csr_busy(dev);\r\n}\r\nstatic u32 pch_udc_read_csr(struct pch_udc_dev *dev, unsigned int ep)\r\n{\r\nunsigned long reg = PCH_UDC_CSR(ep);\r\npch_udc_csr_busy(dev);\r\npch_udc_readl(dev, reg);\r\npch_udc_csr_busy(dev);\r\nreturn pch_udc_readl(dev, reg);\r\n}\r\nstatic inline void pch_udc_rmt_wakeup(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\r\nmdelay(1);\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\r\n}\r\nstatic inline int pch_udc_get_frame(struct pch_udc_dev *dev)\r\n{\r\nu32 frame = pch_udc_readl(dev, UDC_DEVSTS_ADDR);\r\nreturn (frame & UDC_DEVSTS_TS_MASK) >> UDC_DEVSTS_TS_SHIFT;\r\n}\r\nstatic inline void pch_udc_clear_selfpowered(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_clr(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_SP);\r\n}\r\nstatic inline void pch_udc_set_selfpowered(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_SP);\r\n}\r\nstatic inline void pch_udc_set_disconnect(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_SD);\r\n}\r\nstatic void pch_udc_clear_disconnect(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_SD);\r\nmdelay(1);\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\r\n}\r\nstatic void pch_udc_reconnect(struct pch_udc_dev *dev)\r\n{\r\npch_udc_init(dev);\r\npch_udc_bit_clr(dev, UDC_DEVIRQMSK_ADDR,\r\nUDC_DEVINT_UR | UDC_DEVINT_ENUM);\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_SD);\r\nmdelay(1);\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\r\n}\r\nstatic inline void pch_udc_vbus_session(struct pch_udc_dev *dev,\r\nint is_active)\r\n{\r\nif (is_active) {\r\npch_udc_reconnect(dev);\r\ndev->vbus_session = 1;\r\n} else {\r\nif (dev->driver && dev->driver->disconnect) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\npch_udc_set_disconnect(dev);\r\ndev->vbus_session = 0;\r\n}\r\n}\r\nstatic void pch_udc_ep_set_stall(struct pch_udc_ep *ep)\r\n{\r\nif (ep->in) {\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_F);\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_S);\r\n} else {\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_S);\r\n}\r\n}\r\nstatic inline void pch_udc_ep_clear_stall(struct pch_udc_ep *ep)\r\n{\r\npch_udc_ep_bit_clr(ep, UDC_EPCTL_ADDR, UDC_EPCTL_S);\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_CNAK);\r\n}\r\nstatic inline void pch_udc_ep_set_trfr_type(struct pch_udc_ep *ep,\r\nu8 type)\r\n{\r\npch_udc_ep_writel(ep, ((type << UDC_EPCTL_ET_SHIFT) &\r\nUDC_EPCTL_ET_MASK), UDC_EPCTL_ADDR);\r\n}\r\nstatic void pch_udc_ep_set_bufsz(struct pch_udc_ep *ep,\r\nu32 buf_size, u32 ep_in)\r\n{\r\nu32 data;\r\nif (ep_in) {\r\ndata = pch_udc_ep_readl(ep, UDC_BUFIN_FRAMENUM_ADDR);\r\ndata = (data & 0xffff0000) | (buf_size & 0xffff);\r\npch_udc_ep_writel(ep, data, UDC_BUFIN_FRAMENUM_ADDR);\r\n} else {\r\ndata = pch_udc_ep_readl(ep, UDC_BUFOUT_MAXPKT_ADDR);\r\ndata = (buf_size << 16) | (data & 0xffff);\r\npch_udc_ep_writel(ep, data, UDC_BUFOUT_MAXPKT_ADDR);\r\n}\r\n}\r\nstatic void pch_udc_ep_set_maxpkt(struct pch_udc_ep *ep, u32 pkt_size)\r\n{\r\nu32 data = pch_udc_ep_readl(ep, UDC_BUFOUT_MAXPKT_ADDR);\r\ndata = (data & 0xffff0000) | (pkt_size & 0xffff);\r\npch_udc_ep_writel(ep, data, UDC_BUFOUT_MAXPKT_ADDR);\r\n}\r\nstatic inline void pch_udc_ep_set_subptr(struct pch_udc_ep *ep, u32 addr)\r\n{\r\npch_udc_ep_writel(ep, addr, UDC_SUBPTR_ADDR);\r\n}\r\nstatic inline void pch_udc_ep_set_ddptr(struct pch_udc_ep *ep, u32 addr)\r\n{\r\npch_udc_ep_writel(ep, addr, UDC_DESPTR_ADDR);\r\n}\r\nstatic inline void pch_udc_ep_set_pd(struct pch_udc_ep *ep)\r\n{\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_P);\r\n}\r\nstatic inline void pch_udc_ep_set_rrdy(struct pch_udc_ep *ep)\r\n{\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_RRDY);\r\n}\r\nstatic inline void pch_udc_ep_clear_rrdy(struct pch_udc_ep *ep)\r\n{\r\npch_udc_ep_bit_clr(ep, UDC_EPCTL_ADDR, UDC_EPCTL_RRDY);\r\n}\r\nstatic inline void pch_udc_set_dma(struct pch_udc_dev *dev, int dir)\r\n{\r\nif (dir == DMA_DIR_RX)\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RDE);\r\nelse if (dir == DMA_DIR_TX)\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_TDE);\r\n}\r\nstatic inline void pch_udc_clear_dma(struct pch_udc_dev *dev, int dir)\r\n{\r\nif (dir == DMA_DIR_RX)\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RDE);\r\nelse if (dir == DMA_DIR_TX)\r\npch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_TDE);\r\n}\r\nstatic inline void pch_udc_set_csr_done(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_CSR_DONE);\r\n}\r\nstatic inline void pch_udc_disable_interrupts(struct pch_udc_dev *dev,\r\nu32 mask)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVIRQMSK_ADDR, mask);\r\n}\r\nstatic inline void pch_udc_enable_interrupts(struct pch_udc_dev *dev,\r\nu32 mask)\r\n{\r\npch_udc_bit_clr(dev, UDC_DEVIRQMSK_ADDR, mask);\r\n}\r\nstatic inline void pch_udc_disable_ep_interrupts(struct pch_udc_dev *dev,\r\nu32 mask)\r\n{\r\npch_udc_bit_set(dev, UDC_EPIRQMSK_ADDR, mask);\r\n}\r\nstatic inline void pch_udc_enable_ep_interrupts(struct pch_udc_dev *dev,\r\nu32 mask)\r\n{\r\npch_udc_bit_clr(dev, UDC_EPIRQMSK_ADDR, mask);\r\n}\r\nstatic inline u32 pch_udc_read_device_interrupts(struct pch_udc_dev *dev)\r\n{\r\nreturn pch_udc_readl(dev, UDC_DEVIRQSTS_ADDR);\r\n}\r\nstatic inline void pch_udc_write_device_interrupts(struct pch_udc_dev *dev,\r\nu32 val)\r\n{\r\npch_udc_writel(dev, val, UDC_DEVIRQSTS_ADDR);\r\n}\r\nstatic inline u32 pch_udc_read_ep_interrupts(struct pch_udc_dev *dev)\r\n{\r\nreturn pch_udc_readl(dev, UDC_EPIRQSTS_ADDR);\r\n}\r\nstatic inline void pch_udc_write_ep_interrupts(struct pch_udc_dev *dev,\r\nu32 val)\r\n{\r\npch_udc_writel(dev, val, UDC_EPIRQSTS_ADDR);\r\n}\r\nstatic inline u32 pch_udc_read_device_status(struct pch_udc_dev *dev)\r\n{\r\nreturn pch_udc_readl(dev, UDC_DEVSTS_ADDR);\r\n}\r\nstatic inline u32 pch_udc_read_ep_control(struct pch_udc_ep *ep)\r\n{\r\nreturn pch_udc_ep_readl(ep, UDC_EPCTL_ADDR);\r\n}\r\nstatic inline void pch_udc_clear_ep_control(struct pch_udc_ep *ep)\r\n{\r\nreturn pch_udc_ep_writel(ep, 0, UDC_EPCTL_ADDR);\r\n}\r\nstatic inline u32 pch_udc_read_ep_status(struct pch_udc_ep *ep)\r\n{\r\nreturn pch_udc_ep_readl(ep, UDC_EPSTS_ADDR);\r\n}\r\nstatic inline void pch_udc_clear_ep_status(struct pch_udc_ep *ep,\r\nu32 stat)\r\n{\r\nreturn pch_udc_ep_writel(ep, stat, UDC_EPSTS_ADDR);\r\n}\r\nstatic inline void pch_udc_ep_set_nak(struct pch_udc_ep *ep)\r\n{\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_SNAK);\r\n}\r\nstatic void pch_udc_ep_clear_nak(struct pch_udc_ep *ep)\r\n{\r\nunsigned int loopcnt = 0;\r\nstruct pch_udc_dev *dev = ep->dev;\r\nif (!(pch_udc_ep_readl(ep, UDC_EPCTL_ADDR) & UDC_EPCTL_NAK))\r\nreturn;\r\nif (!ep->in) {\r\nloopcnt = 10000;\r\nwhile (!(pch_udc_read_ep_status(ep) & UDC_EPSTS_MRXFIFO_EMP) &&\r\n--loopcnt)\r\nudelay(5);\r\nif (!loopcnt)\r\ndev_err(&dev->pdev->dev, "%s: RxFIFO not Empty\n",\r\n__func__);\r\n}\r\nloopcnt = 10000;\r\nwhile ((pch_udc_read_ep_control(ep) & UDC_EPCTL_NAK) && --loopcnt) {\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_CNAK);\r\nudelay(5);\r\n}\r\nif (!loopcnt)\r\ndev_err(&dev->pdev->dev, "%s: Clear NAK not set for ep%d%s\n",\r\n__func__, ep->num, (ep->in ? "in" : "out"));\r\n}\r\nstatic void pch_udc_ep_fifo_flush(struct pch_udc_ep *ep, int dir)\r\n{\r\nif (dir) {\r\npch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_F);\r\nreturn;\r\n}\r\n}\r\nstatic void pch_udc_ep_enable(struct pch_udc_ep *ep,\r\nstruct pch_udc_cfg_data *cfg,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nu32 val = 0;\r\nu32 buff_size = 0;\r\npch_udc_ep_set_trfr_type(ep, desc->bmAttributes);\r\nif (ep->in)\r\nbuff_size = UDC_EPIN_BUFF_SIZE;\r\nelse\r\nbuff_size = UDC_EPOUT_BUFF_SIZE;\r\npch_udc_ep_set_bufsz(ep, buff_size, ep->in);\r\npch_udc_ep_set_maxpkt(ep, usb_endpoint_maxp(desc));\r\npch_udc_ep_set_nak(ep);\r\npch_udc_ep_fifo_flush(ep, ep->in);\r\nval = ep->num << UDC_CSR_NE_NUM_SHIFT | ep->in << UDC_CSR_NE_DIR_SHIFT |\r\n((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) <<\r\nUDC_CSR_NE_TYPE_SHIFT) |\r\n(cfg->cur_cfg << UDC_CSR_NE_CFG_SHIFT) |\r\n(cfg->cur_intf << UDC_CSR_NE_INTF_SHIFT) |\r\n(cfg->cur_alt << UDC_CSR_NE_ALT_SHIFT) |\r\nusb_endpoint_maxp(desc) << UDC_CSR_NE_MAX_PKT_SHIFT;\r\nif (ep->in)\r\npch_udc_write_csr(ep->dev, val, UDC_EPIN_IDX(ep->num));\r\nelse\r\npch_udc_write_csr(ep->dev, val, UDC_EPOUT_IDX(ep->num));\r\n}\r\nstatic void pch_udc_ep_disable(struct pch_udc_ep *ep)\r\n{\r\nif (ep->in) {\r\npch_udc_ep_writel(ep, UDC_EPCTL_F, UDC_EPCTL_ADDR);\r\npch_udc_ep_writel(ep, UDC_EPCTL_SNAK, UDC_EPCTL_ADDR);\r\npch_udc_ep_bit_set(ep, UDC_EPSTS_ADDR, UDC_EPSTS_IN);\r\n} else {\r\npch_udc_ep_writel(ep, UDC_EPCTL_SNAK, UDC_EPCTL_ADDR);\r\n}\r\npch_udc_ep_writel(ep, 0, UDC_DESPTR_ADDR);\r\n}\r\nstatic void pch_udc_wait_ep_stall(struct pch_udc_ep *ep)\r\n{\r\nunsigned int count = 10000;\r\nwhile ((pch_udc_read_ep_control(ep) & UDC_EPCTL_S) && --count)\r\nudelay(5);\r\nif (!count)\r\ndev_err(&ep->dev->pdev->dev, "%s: wait error\n", __func__);\r\n}\r\nstatic void pch_udc_init(struct pch_udc_dev *dev)\r\n{\r\nif (NULL == dev) {\r\npr_err("%s: Invalid address\n", __func__);\r\nreturn;\r\n}\r\npch_udc_writel(dev, UDC_SRST, UDC_SRST_ADDR);\r\npch_udc_writel(dev, UDC_SRST | UDC_PSRST, UDC_SRST_ADDR);\r\nmdelay(1);\r\npch_udc_writel(dev, UDC_SRST, UDC_SRST_ADDR);\r\npch_udc_writel(dev, 0x00, UDC_SRST_ADDR);\r\nmdelay(1);\r\npch_udc_bit_set(dev, UDC_DEVIRQMSK_ADDR, UDC_DEVINT_MSK);\r\npch_udc_bit_set(dev, UDC_DEVIRQSTS_ADDR, UDC_DEVINT_MSK);\r\npch_udc_bit_set(dev, UDC_EPIRQMSK_ADDR, UDC_EPINT_MSK_DISABLE_ALL);\r\npch_udc_bit_set(dev, UDC_EPIRQSTS_ADDR, UDC_EPINT_MSK_DISABLE_ALL);\r\nif (speed_fs)\r\npch_udc_bit_set(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_CSR_PRG |\r\nUDC_DEVCFG_SP | UDC_DEVCFG_SPD_FS);\r\nelse\r\npch_udc_bit_set(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_CSR_PRG |\r\nUDC_DEVCFG_SP | UDC_DEVCFG_SPD_HS);\r\npch_udc_bit_set(dev, UDC_DEVCTL_ADDR,\r\n(PCH_UDC_THLEN << UDC_DEVCTL_THLEN_SHIFT) |\r\n(PCH_UDC_BRLEN << UDC_DEVCTL_BRLEN_SHIFT) |\r\nUDC_DEVCTL_MODE | UDC_DEVCTL_BREN |\r\nUDC_DEVCTL_THE);\r\n}\r\nstatic void pch_udc_exit(struct pch_udc_dev *dev)\r\n{\r\npch_udc_bit_set(dev, UDC_DEVIRQMSK_ADDR, UDC_DEVINT_MSK);\r\npch_udc_bit_set(dev, UDC_EPIRQMSK_ADDR, UDC_EPINT_MSK_DISABLE_ALL);\r\npch_udc_set_disconnect(dev);\r\n}\r\nstatic int pch_udc_pcd_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct pch_udc_dev *dev;\r\nif (!gadget)\r\nreturn -EINVAL;\r\ndev = container_of(gadget, struct pch_udc_dev, gadget);\r\nreturn pch_udc_get_frame(dev);\r\n}\r\nstatic int pch_udc_pcd_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct pch_udc_dev *dev;\r\nunsigned long flags;\r\nif (!gadget)\r\nreturn -EINVAL;\r\ndev = container_of(gadget, struct pch_udc_dev, gadget);\r\nspin_lock_irqsave(&dev->lock, flags);\r\npch_udc_rmt_wakeup(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pch_udc_pcd_selfpowered(struct usb_gadget *gadget, int value)\r\n{\r\nstruct pch_udc_dev *dev;\r\nif (!gadget)\r\nreturn -EINVAL;\r\ndev = container_of(gadget, struct pch_udc_dev, gadget);\r\nif (value)\r\npch_udc_set_selfpowered(dev);\r\nelse\r\npch_udc_clear_selfpowered(dev);\r\nreturn 0;\r\n}\r\nstatic int pch_udc_pcd_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct pch_udc_dev *dev;\r\nif (!gadget)\r\nreturn -EINVAL;\r\ndev = container_of(gadget, struct pch_udc_dev, gadget);\r\nif (is_on) {\r\npch_udc_reconnect(dev);\r\n} else {\r\nif (dev->driver && dev->driver->disconnect) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\npch_udc_set_disconnect(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pch_udc_pcd_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct pch_udc_dev *dev;\r\nif (!gadget)\r\nreturn -EINVAL;\r\ndev = container_of(gadget, struct pch_udc_dev, gadget);\r\npch_udc_vbus_session(dev, is_active);\r\nreturn 0;\r\n}\r\nstatic int pch_udc_pcd_vbus_draw(struct usb_gadget *gadget, unsigned int mA)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int pch_vbus_gpio_get_value(struct pch_udc_dev *dev)\r\n{\r\nint vbus = 0;\r\nif (dev->vbus_gpio.port)\r\nvbus = gpio_get_value(dev->vbus_gpio.port) ? 1 : 0;\r\nelse\r\nvbus = -1;\r\nreturn vbus;\r\n}\r\nstatic void pch_vbus_gpio_work_fall(struct work_struct *irq_work)\r\n{\r\nstruct pch_vbus_gpio_data *vbus_gpio = container_of(irq_work,\r\nstruct pch_vbus_gpio_data, irq_work_fall);\r\nstruct pch_udc_dev *dev =\r\ncontainer_of(vbus_gpio, struct pch_udc_dev, vbus_gpio);\r\nint vbus_saved = -1;\r\nint vbus;\r\nint count;\r\nif (!dev->vbus_gpio.port)\r\nreturn;\r\nfor (count = 0; count < (PCH_VBUS_PERIOD / PCH_VBUS_INTERVAL);\r\ncount++) {\r\nvbus = pch_vbus_gpio_get_value(dev);\r\nif ((vbus_saved == vbus) && (vbus == 0)) {\r\ndev_dbg(&dev->pdev->dev, "VBUS fell");\r\nif (dev->driver\r\n&& dev->driver->disconnect) {\r\ndev->driver->disconnect(\r\n&dev->gadget);\r\n}\r\nif (dev->vbus_gpio.intr)\r\npch_udc_init(dev);\r\nelse\r\npch_udc_reconnect(dev);\r\nreturn;\r\n}\r\nvbus_saved = vbus;\r\nmdelay(PCH_VBUS_INTERVAL);\r\n}\r\n}\r\nstatic void pch_vbus_gpio_work_rise(struct work_struct *irq_work)\r\n{\r\nstruct pch_vbus_gpio_data *vbus_gpio = container_of(irq_work,\r\nstruct pch_vbus_gpio_data, irq_work_rise);\r\nstruct pch_udc_dev *dev =\r\ncontainer_of(vbus_gpio, struct pch_udc_dev, vbus_gpio);\r\nint vbus;\r\nif (!dev->vbus_gpio.port)\r\nreturn;\r\nmdelay(PCH_VBUS_INTERVAL);\r\nvbus = pch_vbus_gpio_get_value(dev);\r\nif (vbus == 1) {\r\ndev_dbg(&dev->pdev->dev, "VBUS rose");\r\npch_udc_reconnect(dev);\r\nreturn;\r\n}\r\n}\r\nstatic irqreturn_t pch_vbus_gpio_irq(int irq, void *data)\r\n{\r\nstruct pch_udc_dev *dev = (struct pch_udc_dev *)data;\r\nif (!dev->vbus_gpio.port || !dev->vbus_gpio.intr)\r\nreturn IRQ_NONE;\r\nif (pch_vbus_gpio_get_value(dev))\r\nschedule_work(&dev->vbus_gpio.irq_work_rise);\r\nelse\r\nschedule_work(&dev->vbus_gpio.irq_work_fall);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pch_vbus_gpio_init(struct pch_udc_dev *dev, int vbus_gpio_port)\r\n{\r\nint err;\r\nint irq_num = 0;\r\ndev->vbus_gpio.port = 0;\r\ndev->vbus_gpio.intr = 0;\r\nif (vbus_gpio_port <= -1)\r\nreturn -EINVAL;\r\nerr = gpio_is_valid(vbus_gpio_port);\r\nif (!err) {\r\npr_err("%s: gpio port %d is invalid\n",\r\n__func__, vbus_gpio_port);\r\nreturn -EINVAL;\r\n}\r\nerr = gpio_request(vbus_gpio_port, "pch_vbus");\r\nif (err) {\r\npr_err("%s: can't request gpio port %d, err: %d\n",\r\n__func__, vbus_gpio_port, err);\r\nreturn -EINVAL;\r\n}\r\ndev->vbus_gpio.port = vbus_gpio_port;\r\ngpio_direction_input(vbus_gpio_port);\r\nINIT_WORK(&dev->vbus_gpio.irq_work_fall, pch_vbus_gpio_work_fall);\r\nirq_num = gpio_to_irq(vbus_gpio_port);\r\nif (irq_num > 0) {\r\nirq_set_irq_type(irq_num, IRQ_TYPE_EDGE_BOTH);\r\nerr = request_irq(irq_num, pch_vbus_gpio_irq, 0,\r\n"vbus_detect", dev);\r\nif (!err) {\r\ndev->vbus_gpio.intr = irq_num;\r\nINIT_WORK(&dev->vbus_gpio.irq_work_rise,\r\npch_vbus_gpio_work_rise);\r\n} else {\r\npr_err("%s: can't request irq %d, err: %d\n",\r\n__func__, irq_num, err);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pch_vbus_gpio_free(struct pch_udc_dev *dev)\r\n{\r\nif (dev->vbus_gpio.intr)\r\nfree_irq(dev->vbus_gpio.intr, dev);\r\nif (dev->vbus_gpio.port)\r\ngpio_free(dev->vbus_gpio.port);\r\n}\r\nstatic void complete_req(struct pch_udc_ep *ep, struct pch_udc_request *req,\r\nint status)\r\n{\r\nstruct pch_udc_dev *dev;\r\nunsigned halted = ep->halted;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\ndev = ep->dev;\r\nif (req->dma_mapped) {\r\nif (req->dma == DMA_ADDR_INVALID) {\r\nif (ep->in)\r\ndma_unmap_single(&dev->pdev->dev, req->req.dma,\r\nreq->req.length,\r\nDMA_TO_DEVICE);\r\nelse\r\ndma_unmap_single(&dev->pdev->dev, req->req.dma,\r\nreq->req.length,\r\nDMA_FROM_DEVICE);\r\nreq->req.dma = DMA_ADDR_INVALID;\r\n} else {\r\nif (ep->in)\r\ndma_unmap_single(&dev->pdev->dev, req->dma,\r\nreq->req.length,\r\nDMA_TO_DEVICE);\r\nelse {\r\ndma_unmap_single(&dev->pdev->dev, req->dma,\r\nreq->req.length,\r\nDMA_FROM_DEVICE);\r\nmemcpy(req->req.buf, req->buf, req->req.length);\r\n}\r\nkfree(req->buf);\r\nreq->dma = DMA_ADDR_INVALID;\r\n}\r\nreq->dma_mapped = 0;\r\n}\r\nep->halted = 1;\r\nspin_unlock(&dev->lock);\r\nif (!ep->in)\r\npch_udc_ep_clear_rrdy(ep);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&dev->lock);\r\nep->halted = halted;\r\n}\r\nstatic void empty_req_queue(struct pch_udc_ep *ep)\r\n{\r\nstruct pch_udc_request *req;\r\nep->halted = 1;\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct pch_udc_request, queue);\r\ncomplete_req(ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic void pch_udc_free_dma_chain(struct pch_udc_dev *dev,\r\nstruct pch_udc_request *req)\r\n{\r\nstruct pch_udc_data_dma_desc *td = req->td_data;\r\nunsigned i = req->chain_len;\r\ndma_addr_t addr2;\r\ndma_addr_t addr = (dma_addr_t)td->next;\r\ntd->next = 0x00;\r\nfor (; i > 1; --i) {\r\ntd = phys_to_virt(addr);\r\naddr2 = (dma_addr_t)td->next;\r\npci_pool_free(dev->data_requests, td, addr);\r\ntd->next = 0x00;\r\naddr = addr2;\r\n}\r\nreq->chain_len = 1;\r\n}\r\nstatic int pch_udc_create_dma_chain(struct pch_udc_ep *ep,\r\nstruct pch_udc_request *req,\r\nunsigned long buf_len,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pch_udc_data_dma_desc *td = req->td_data, *last;\r\nunsigned long bytes = req->req.length, i = 0;\r\ndma_addr_t dma_addr;\r\nunsigned len = 1;\r\nif (req->chain_len > 1)\r\npch_udc_free_dma_chain(ep->dev, req);\r\nif (req->dma == DMA_ADDR_INVALID)\r\ntd->dataptr = req->req.dma;\r\nelse\r\ntd->dataptr = req->dma;\r\ntd->status = PCH_UDC_BS_HST_BSY;\r\nfor (; ; bytes -= buf_len, ++len) {\r\ntd->status = PCH_UDC_BS_HST_BSY | min(buf_len, bytes);\r\nif (bytes <= buf_len)\r\nbreak;\r\nlast = td;\r\ntd = pci_pool_alloc(ep->dev->data_requests, gfp_flags,\r\n&dma_addr);\r\nif (!td)\r\ngoto nomem;\r\ni += buf_len;\r\ntd->dataptr = req->td_data->dataptr + i;\r\nlast->next = dma_addr;\r\n}\r\nreq->td_data_last = td;\r\ntd->status |= PCH_UDC_DMA_LAST;\r\ntd->next = req->td_data_phys;\r\nreq->chain_len = len;\r\nreturn 0;\r\nnomem:\r\nif (len > 1) {\r\nreq->chain_len = len;\r\npch_udc_free_dma_chain(ep->dev, req);\r\n}\r\nreq->chain_len = 1;\r\nreturn -ENOMEM;\r\n}\r\nstatic int prepare_dma(struct pch_udc_ep *ep, struct pch_udc_request *req,\r\ngfp_t gfp)\r\n{\r\nint retval;\r\nretval = pch_udc_create_dma_chain(ep, req, ep->ep.maxpacket, gfp);\r\nif (retval) {\r\npr_err("%s: could not create DMA chain:%d\n", __func__, retval);\r\nreturn retval;\r\n}\r\nif (ep->in)\r\nreq->td_data->status = (req->td_data->status &\r\n~PCH_UDC_BUFF_STS) | PCH_UDC_BS_HST_RDY;\r\nreturn 0;\r\n}\r\nstatic void process_zlp(struct pch_udc_ep *ep, struct pch_udc_request *req)\r\n{\r\nstruct pch_udc_dev *dev = ep->dev;\r\ncomplete_req(ep, req, 0);\r\nif (dev->set_cfg_not_acked) {\r\npch_udc_set_csr_done(dev);\r\ndev->set_cfg_not_acked = 0;\r\n}\r\nif (!dev->stall && dev->waiting_zlp_ack) {\r\npch_udc_ep_clear_nak(&(dev->ep[UDC_EP0IN_IDX]));\r\ndev->waiting_zlp_ack = 0;\r\n}\r\n}\r\nstatic void pch_udc_start_rxrequest(struct pch_udc_ep *ep,\r\nstruct pch_udc_request *req)\r\n{\r\nstruct pch_udc_data_dma_desc *td_data;\r\npch_udc_clear_dma(ep->dev, DMA_DIR_RX);\r\ntd_data = req->td_data;\r\nwhile (1) {\r\ntd_data->status = (td_data->status & ~PCH_UDC_BUFF_STS) |\r\nPCH_UDC_BS_HST_RDY;\r\nif ((td_data->status & PCH_UDC_DMA_LAST) == PCH_UDC_DMA_LAST)\r\nbreak;\r\ntd_data = phys_to_virt(td_data->next);\r\n}\r\npch_udc_ep_set_ddptr(ep, req->td_data_phys);\r\nreq->dma_going = 1;\r\npch_udc_enable_ep_interrupts(ep->dev, UDC_EPINT_OUT_EP0 << ep->num);\r\npch_udc_set_dma(ep->dev, DMA_DIR_RX);\r\npch_udc_ep_clear_nak(ep);\r\npch_udc_ep_set_rrdy(ep);\r\n}\r\nstatic int pch_udc_pcd_ep_enable(struct usb_ep *usbep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_dev *dev;\r\nunsigned long iflags;\r\nif (!usbep || (usbep->name == ep0_string) || !desc ||\r\n(desc->bDescriptorType != USB_DT_ENDPOINT) || !desc->wMaxPacketSize)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nif (!dev->driver || (dev->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&dev->lock, iflags);\r\nep->ep.desc = desc;\r\nep->halted = 0;\r\npch_udc_ep_enable(ep, &ep->dev->cfg_data, desc);\r\nep->ep.maxpacket = usb_endpoint_maxp(desc);\r\npch_udc_enable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\r\nspin_unlock_irqrestore(&dev->lock, iflags);\r\nreturn 0;\r\n}\r\nstatic int pch_udc_pcd_ep_disable(struct usb_ep *usbep)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_dev *dev;\r\nunsigned long iflags;\r\nif (!usbep)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nif ((usbep->name == ep0_string) || !ep->ep.desc)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->dev->lock, iflags);\r\nempty_req_queue(ep);\r\nep->halted = 1;\r\npch_udc_ep_disable(ep);\r\npch_udc_disable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\r\nep->ep.desc = NULL;\r\nINIT_LIST_HEAD(&ep->queue);\r\nspin_unlock_irqrestore(&ep->dev->lock, iflags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *pch_udc_alloc_request(struct usb_ep *usbep,\r\ngfp_t gfp)\r\n{\r\nstruct pch_udc_request *req;\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_data_dma_desc *dma_desc;\r\nstruct pch_udc_dev *dev;\r\nif (!usbep)\r\nreturn NULL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nreq = kzalloc(sizeof *req, gfp);\r\nif (!req)\r\nreturn NULL;\r\nreq->req.dma = DMA_ADDR_INVALID;\r\nreq->dma = DMA_ADDR_INVALID;\r\nINIT_LIST_HEAD(&req->queue);\r\nif (!ep->dev->dma_addr)\r\nreturn &req->req;\r\ndma_desc = pci_pool_alloc(ep->dev->data_requests, gfp,\r\n&req->td_data_phys);\r\nif (NULL == dma_desc) {\r\nkfree(req);\r\nreturn NULL;\r\n}\r\ndma_desc->status |= PCH_UDC_BS_HST_BSY;\r\ndma_desc->dataptr = __constant_cpu_to_le32(DMA_ADDR_INVALID);\r\nreq->td_data = dma_desc;\r\nreq->td_data_last = dma_desc;\r\nreq->chain_len = 1;\r\nreturn &req->req;\r\n}\r\nstatic void pch_udc_free_request(struct usb_ep *usbep,\r\nstruct usb_request *usbreq)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_request *req;\r\nstruct pch_udc_dev *dev;\r\nif (!usbep || !usbreq)\r\nreturn;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\nreq = container_of(usbreq, struct pch_udc_request, req);\r\ndev = ep->dev;\r\nif (!list_empty(&req->queue))\r\ndev_err(&dev->pdev->dev, "%s: %s req=0x%p queue not empty\n",\r\n__func__, usbep->name, req);\r\nif (req->td_data != NULL) {\r\nif (req->chain_len > 1)\r\npch_udc_free_dma_chain(ep->dev, req);\r\npci_pool_free(ep->dev->data_requests, req->td_data,\r\nreq->td_data_phys);\r\n}\r\nkfree(req);\r\n}\r\nstatic int pch_udc_pcd_queue(struct usb_ep *usbep, struct usb_request *usbreq,\r\ngfp_t gfp)\r\n{\r\nint retval = 0;\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_dev *dev;\r\nstruct pch_udc_request *req;\r\nunsigned long iflags;\r\nif (!usbep || !usbreq || !usbreq->complete || !usbreq->buf)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nif (!ep->ep.desc && ep->num)\r\nreturn -EINVAL;\r\nreq = container_of(usbreq, struct pch_udc_request, req);\r\nif (!list_empty(&req->queue))\r\nreturn -EINVAL;\r\nif (!dev->driver || (dev->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&dev->lock, iflags);\r\nif (usbreq->length &&\r\n((usbreq->dma == DMA_ADDR_INVALID) || !usbreq->dma)) {\r\nif (!((unsigned long)(usbreq->buf) & 0x03)) {\r\nif (ep->in)\r\nusbreq->dma = dma_map_single(&dev->pdev->dev,\r\nusbreq->buf,\r\nusbreq->length,\r\nDMA_TO_DEVICE);\r\nelse\r\nusbreq->dma = dma_map_single(&dev->pdev->dev,\r\nusbreq->buf,\r\nusbreq->length,\r\nDMA_FROM_DEVICE);\r\n} else {\r\nreq->buf = kzalloc(usbreq->length, GFP_ATOMIC);\r\nif (!req->buf) {\r\nretval = -ENOMEM;\r\ngoto probe_end;\r\n}\r\nif (ep->in) {\r\nmemcpy(req->buf, usbreq->buf, usbreq->length);\r\nreq->dma = dma_map_single(&dev->pdev->dev,\r\nreq->buf,\r\nusbreq->length,\r\nDMA_TO_DEVICE);\r\n} else\r\nreq->dma = dma_map_single(&dev->pdev->dev,\r\nreq->buf,\r\nusbreq->length,\r\nDMA_FROM_DEVICE);\r\n}\r\nreq->dma_mapped = 1;\r\n}\r\nif (usbreq->length > 0) {\r\nretval = prepare_dma(ep, req, GFP_ATOMIC);\r\nif (retval)\r\ngoto probe_end;\r\n}\r\nusbreq->actual = 0;\r\nusbreq->status = -EINPROGRESS;\r\nreq->dma_done = 0;\r\nif (list_empty(&ep->queue) && !ep->halted) {\r\nif (!usbreq->length) {\r\nprocess_zlp(ep, req);\r\nretval = 0;\r\ngoto probe_end;\r\n}\r\nif (!ep->in) {\r\npch_udc_start_rxrequest(ep, req);\r\n} else {\r\npch_udc_wait_ep_stall(ep);\r\npch_udc_ep_clear_nak(ep);\r\npch_udc_enable_ep_interrupts(ep->dev, (1 << ep->num));\r\n}\r\n}\r\nif (req != NULL)\r\nlist_add_tail(&req->queue, &ep->queue);\r\nprobe_end:\r\nspin_unlock_irqrestore(&dev->lock, iflags);\r\nreturn retval;\r\n}\r\nstatic int pch_udc_pcd_dequeue(struct usb_ep *usbep,\r\nstruct usb_request *usbreq)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_request *req;\r\nstruct pch_udc_dev *dev;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nif (!usbep || !usbreq || (!ep->ep.desc && ep->num))\r\nreturn ret;\r\nreq = container_of(usbreq, struct pch_udc_request, req);\r\nspin_lock_irqsave(&ep->dev->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == usbreq) {\r\npch_udc_ep_set_nak(ep);\r\nif (!list_empty(&req->queue))\r\ncomplete_req(ep, req, -ECONNRESET);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ep->dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int pch_udc_pcd_set_halt(struct usb_ep *usbep, int halt)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_dev *dev;\r\nunsigned long iflags;\r\nint ret;\r\nif (!usbep)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nif (!ep->ep.desc && !ep->num)\r\nreturn -EINVAL;\r\nif (!ep->dev->driver || (ep->dev->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc_stall_spinlock, iflags);\r\nif (list_empty(&ep->queue)) {\r\nif (halt) {\r\nif (ep->num == PCH_UDC_EP0)\r\nep->dev->stall = 1;\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in,\r\nep->num));\r\n} else {\r\npch_udc_ep_clear_stall(ep);\r\n}\r\nret = 0;\r\n} else {\r\nret = -EAGAIN;\r\n}\r\nspin_unlock_irqrestore(&udc_stall_spinlock, iflags);\r\nreturn ret;\r\n}\r\nstatic int pch_udc_pcd_set_wedge(struct usb_ep *usbep)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_dev *dev;\r\nunsigned long iflags;\r\nint ret;\r\nif (!usbep)\r\nreturn -EINVAL;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\ndev = ep->dev;\r\nif (!ep->ep.desc && !ep->num)\r\nreturn -EINVAL;\r\nif (!ep->dev->driver || (ep->dev->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc_stall_spinlock, iflags);\r\nif (!list_empty(&ep->queue)) {\r\nret = -EAGAIN;\r\n} else {\r\nif (ep->num == PCH_UDC_EP0)\r\nep->dev->stall = 1;\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\nep->dev->prot_stall = 1;\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&udc_stall_spinlock, iflags);\r\nreturn ret;\r\n}\r\nstatic void pch_udc_pcd_fifo_flush(struct usb_ep *usbep)\r\n{\r\nstruct pch_udc_ep *ep;\r\nif (!usbep)\r\nreturn;\r\nep = container_of(usbep, struct pch_udc_ep, ep);\r\nif (ep->ep.desc || !ep->num)\r\npch_udc_ep_fifo_flush(ep, ep->in);\r\n}\r\nstatic void pch_udc_init_setup_buff(struct pch_udc_stp_dma_desc *td_stp)\r\n{\r\nstatic u32 pky_marker;\r\nif (!td_stp)\r\nreturn;\r\ntd_stp->reserved = ++pky_marker;\r\nmemset(&td_stp->request, 0xFF, sizeof td_stp->request);\r\ntd_stp->status = PCH_UDC_BS_HST_RDY;\r\n}\r\nstatic void pch_udc_start_next_txrequest(struct pch_udc_ep *ep)\r\n{\r\nstruct pch_udc_request *req;\r\nstruct pch_udc_data_dma_desc *td_data;\r\nif (pch_udc_read_ep_control(ep) & UDC_EPCTL_P)\r\nreturn;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct pch_udc_request, queue);\r\nif (req->dma_going)\r\nreturn;\r\nif (!req->td_data)\r\nreturn;\r\npch_udc_wait_ep_stall(ep);\r\nreq->dma_going = 1;\r\npch_udc_ep_set_ddptr(ep, 0);\r\ntd_data = req->td_data;\r\nwhile (1) {\r\ntd_data->status = (td_data->status & ~PCH_UDC_BUFF_STS) |\r\nPCH_UDC_BS_HST_RDY;\r\nif ((td_data->status & PCH_UDC_DMA_LAST) == PCH_UDC_DMA_LAST)\r\nbreak;\r\ntd_data = phys_to_virt(td_data->next);\r\n}\r\npch_udc_ep_set_ddptr(ep, req->td_data_phys);\r\npch_udc_set_dma(ep->dev, DMA_DIR_TX);\r\npch_udc_ep_set_pd(ep);\r\npch_udc_enable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\r\npch_udc_ep_clear_nak(ep);\r\n}\r\nstatic void pch_udc_complete_transfer(struct pch_udc_ep *ep)\r\n{\r\nstruct pch_udc_request *req;\r\nstruct pch_udc_dev *dev = ep->dev;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct pch_udc_request, queue);\r\nif ((req->td_data_last->status & PCH_UDC_BUFF_STS) !=\r\nPCH_UDC_BS_DMA_DONE)\r\nreturn;\r\nif ((req->td_data_last->status & PCH_UDC_RXTX_STS) !=\r\nPCH_UDC_RTS_SUCC) {\r\ndev_err(&dev->pdev->dev, "Invalid RXTX status (0x%08x) "\r\n"epstatus=0x%08x\n",\r\n(req->td_data_last->status & PCH_UDC_RXTX_STS),\r\n(int)(ep->epsts));\r\nreturn;\r\n}\r\nreq->req.actual = req->req.length;\r\nreq->td_data_last->status = PCH_UDC_BS_HST_BSY | PCH_UDC_DMA_LAST;\r\nreq->td_data->status = PCH_UDC_BS_HST_BSY | PCH_UDC_DMA_LAST;\r\ncomplete_req(ep, req, 0);\r\nreq->dma_going = 0;\r\nif (!list_empty(&ep->queue)) {\r\npch_udc_wait_ep_stall(ep);\r\npch_udc_ep_clear_nak(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n} else {\r\npch_udc_disable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n}\r\n}\r\nstatic void pch_udc_complete_receiver(struct pch_udc_ep *ep)\r\n{\r\nstruct pch_udc_request *req;\r\nstruct pch_udc_dev *dev = ep->dev;\r\nunsigned int count;\r\nstruct pch_udc_data_dma_desc *td;\r\ndma_addr_t addr;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct pch_udc_request, queue);\r\npch_udc_clear_dma(ep->dev, DMA_DIR_RX);\r\npch_udc_ep_set_ddptr(ep, 0);\r\nif ((req->td_data_last->status & PCH_UDC_BUFF_STS) ==\r\nPCH_UDC_BS_DMA_DONE)\r\ntd = req->td_data_last;\r\nelse\r\ntd = req->td_data;\r\nwhile (1) {\r\nif ((td->status & PCH_UDC_RXTX_STS) != PCH_UDC_RTS_SUCC) {\r\ndev_err(&dev->pdev->dev, "Invalid RXTX status=0x%08x "\r\n"epstatus=0x%08x\n",\r\n(req->td_data->status & PCH_UDC_RXTX_STS),\r\n(int)(ep->epsts));\r\nreturn;\r\n}\r\nif ((td->status & PCH_UDC_BUFF_STS) == PCH_UDC_BS_DMA_DONE)\r\nif (td->status & PCH_UDC_DMA_LAST) {\r\ncount = td->status & PCH_UDC_RXTX_BYTES;\r\nbreak;\r\n}\r\nif (td == req->td_data_last) {\r\ndev_err(&dev->pdev->dev, "Not complete RX descriptor");\r\nreturn;\r\n}\r\naddr = (dma_addr_t)td->next;\r\ntd = phys_to_virt(addr);\r\n}\r\nif (!count && (req->req.length == UDC_DMA_MAXPACKET))\r\ncount = UDC_DMA_MAXPACKET;\r\nreq->td_data->status |= PCH_UDC_DMA_LAST;\r\ntd->status |= PCH_UDC_BS_HST_BSY;\r\nreq->dma_going = 0;\r\nreq->req.actual = count;\r\ncomplete_req(ep, req, 0);\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct pch_udc_request, queue);\r\npch_udc_start_rxrequest(ep, req);\r\n}\r\n}\r\nstatic void pch_udc_svc_data_in(struct pch_udc_dev *dev, int ep_num)\r\n{\r\nu32 epsts;\r\nstruct pch_udc_ep *ep;\r\nep = &dev->ep[UDC_EPIN_IDX(ep_num)];\r\nepsts = ep->epsts;\r\nep->epsts = 0;\r\nif (!(epsts & (UDC_EPSTS_IN | UDC_EPSTS_BNA | UDC_EPSTS_HE |\r\nUDC_EPSTS_TDC | UDC_EPSTS_RCS | UDC_EPSTS_TXEMPTY |\r\nUDC_EPSTS_RSS | UDC_EPSTS_XFERDONE)))\r\nreturn;\r\nif ((epsts & UDC_EPSTS_BNA))\r\nreturn;\r\nif (epsts & UDC_EPSTS_HE)\r\nreturn;\r\nif (epsts & UDC_EPSTS_RSS) {\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n}\r\nif (epsts & UDC_EPSTS_RCS) {\r\nif (!dev->prot_stall) {\r\npch_udc_ep_clear_stall(ep);\r\n} else {\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n}\r\n}\r\nif (epsts & UDC_EPSTS_TDC)\r\npch_udc_complete_transfer(ep);\r\nif ((epsts & UDC_EPSTS_IN) && !(epsts & UDC_EPSTS_RSS) &&\r\n!(epsts & UDC_EPSTS_TDC) && !(epsts & UDC_EPSTS_TXEMPTY))\r\npch_udc_start_next_txrequest(ep);\r\n}\r\nstatic void pch_udc_svc_data_out(struct pch_udc_dev *dev, int ep_num)\r\n{\r\nu32 epsts;\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_request *req = NULL;\r\nep = &dev->ep[UDC_EPOUT_IDX(ep_num)];\r\nepsts = ep->epsts;\r\nep->epsts = 0;\r\nif ((epsts & UDC_EPSTS_BNA) && (!list_empty(&ep->queue))) {\r\nreq = list_entry(ep->queue.next, struct pch_udc_request,\r\nqueue);\r\nif ((req->td_data_last->status & PCH_UDC_BUFF_STS) !=\r\nPCH_UDC_BS_DMA_DONE) {\r\nif (!req->dma_going)\r\npch_udc_start_rxrequest(ep, req);\r\nreturn;\r\n}\r\n}\r\nif (epsts & UDC_EPSTS_HE)\r\nreturn;\r\nif (epsts & UDC_EPSTS_RSS) {\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n}\r\nif (epsts & UDC_EPSTS_RCS) {\r\nif (!dev->prot_stall) {\r\npch_udc_ep_clear_stall(ep);\r\n} else {\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n}\r\n}\r\nif (((epsts & UDC_EPSTS_OUT_MASK) >> UDC_EPSTS_OUT_SHIFT) ==\r\nUDC_EPSTS_OUT_DATA) {\r\nif (ep->dev->prot_stall == 1) {\r\npch_udc_ep_set_stall(ep);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\n} else {\r\npch_udc_complete_receiver(ep);\r\n}\r\n}\r\nif (list_empty(&ep->queue))\r\npch_udc_set_dma(dev, DMA_DIR_RX);\r\n}\r\nstatic void pch_udc_svc_control_in(struct pch_udc_dev *dev)\r\n{\r\nu32 epsts;\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_ep *ep_out;\r\nep = &dev->ep[UDC_EP0IN_IDX];\r\nep_out = &dev->ep[UDC_EP0OUT_IDX];\r\nepsts = ep->epsts;\r\nep->epsts = 0;\r\nif (!(epsts & (UDC_EPSTS_IN | UDC_EPSTS_BNA | UDC_EPSTS_HE |\r\nUDC_EPSTS_TDC | UDC_EPSTS_RCS | UDC_EPSTS_TXEMPTY |\r\nUDC_EPSTS_XFERDONE)))\r\nreturn;\r\nif ((epsts & UDC_EPSTS_BNA))\r\nreturn;\r\nif (epsts & UDC_EPSTS_HE)\r\nreturn;\r\nif ((epsts & UDC_EPSTS_TDC) && (!dev->stall)) {\r\npch_udc_complete_transfer(ep);\r\npch_udc_clear_dma(dev, DMA_DIR_RX);\r\nep_out->td_data->status = (ep_out->td_data->status &\r\n~PCH_UDC_BUFF_STS) |\r\nPCH_UDC_BS_HST_RDY;\r\npch_udc_ep_clear_nak(ep_out);\r\npch_udc_set_dma(dev, DMA_DIR_RX);\r\npch_udc_ep_set_rrdy(ep_out);\r\n}\r\nif ((epsts & UDC_EPSTS_IN) && !(epsts & UDC_EPSTS_TDC) &&\r\n!(epsts & UDC_EPSTS_TXEMPTY))\r\npch_udc_start_next_txrequest(ep);\r\n}\r\nstatic void pch_udc_svc_control_out(struct pch_udc_dev *dev)\r\n{\r\nu32 stat;\r\nint setup_supported;\r\nstruct pch_udc_ep *ep;\r\nep = &dev->ep[UDC_EP0OUT_IDX];\r\nstat = ep->epsts;\r\nep->epsts = 0;\r\nif (((stat & UDC_EPSTS_OUT_MASK) >> UDC_EPSTS_OUT_SHIFT) ==\r\nUDC_EPSTS_OUT_SETUP) {\r\ndev->stall = 0;\r\ndev->ep[UDC_EP0IN_IDX].halted = 0;\r\ndev->ep[UDC_EP0OUT_IDX].halted = 0;\r\ndev->setup_data = ep->td_stp->request;\r\npch_udc_init_setup_buff(ep->td_stp);\r\npch_udc_clear_dma(dev, DMA_DIR_RX);\r\npch_udc_ep_fifo_flush(&(dev->ep[UDC_EP0IN_IDX]),\r\ndev->ep[UDC_EP0IN_IDX].in);\r\nif ((dev->setup_data.bRequestType & USB_DIR_IN))\r\ndev->gadget.ep0 = &dev->ep[UDC_EP0IN_IDX].ep;\r\nelse\r\ndev->gadget.ep0 = &ep->ep;\r\nspin_unlock(&dev->lock);\r\nif ((dev->setup_data.bRequestType == 0x21) &&\r\n(dev->setup_data.bRequest == 0xFF))\r\ndev->prot_stall = 0;\r\nsetup_supported = dev->driver->setup(&dev->gadget,\r\n&dev->setup_data);\r\nspin_lock(&dev->lock);\r\nif (dev->setup_data.bRequestType & USB_DIR_IN) {\r\nep->td_data->status = (ep->td_data->status &\r\n~PCH_UDC_BUFF_STS) |\r\nPCH_UDC_BS_HST_RDY;\r\npch_udc_ep_set_ddptr(ep, ep->td_data_phys);\r\n}\r\nif (setup_supported >= 0 && setup_supported <\r\nUDC_EP0IN_MAX_PKT_SIZE) {\r\npch_udc_ep_clear_nak(&(dev->ep[UDC_EP0IN_IDX]));\r\nif (!(dev->setup_data.bRequestType & USB_DIR_IN)) {\r\npch_udc_set_dma(dev, DMA_DIR_RX);\r\npch_udc_ep_clear_nak(ep);\r\n}\r\n} else if (setup_supported < 0) {\r\npch_udc_ep_set_stall(&(dev->ep[UDC_EP0IN_IDX]));\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\ndev->stall = 0;\r\npch_udc_set_dma(dev, DMA_DIR_RX);\r\n} else {\r\ndev->waiting_zlp_ack = 1;\r\n}\r\n} else if ((((stat & UDC_EPSTS_OUT_MASK) >> UDC_EPSTS_OUT_SHIFT) ==\r\nUDC_EPSTS_OUT_DATA) && !dev->stall) {\r\npch_udc_clear_dma(dev, DMA_DIR_RX);\r\npch_udc_ep_set_ddptr(ep, 0);\r\nif (!list_empty(&ep->queue)) {\r\nep->epsts = stat;\r\npch_udc_svc_data_out(dev, PCH_UDC_EP0);\r\n}\r\npch_udc_set_dma(dev, DMA_DIR_RX);\r\n}\r\npch_udc_ep_set_rrdy(ep);\r\n}\r\nstatic void pch_udc_postsvc_epinters(struct pch_udc_dev *dev, int ep_num)\r\n{\r\nstruct pch_udc_ep *ep;\r\nstruct pch_udc_request *req;\r\nep = &dev->ep[UDC_EPIN_IDX(ep_num)];\r\nif (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct pch_udc_request, queue);\r\npch_udc_enable_ep_interrupts(ep->dev,\r\nPCH_UDC_EPINT(ep->in, ep->num));\r\npch_udc_ep_clear_nak(ep);\r\n}\r\n}\r\nstatic void pch_udc_read_all_epstatus(struct pch_udc_dev *dev, u32 ep_intr)\r\n{\r\nint i;\r\nstruct pch_udc_ep *ep;\r\nfor (i = 0; i < PCH_UDC_USED_EP_NUM; i++) {\r\nif (ep_intr & (0x1 << i)) {\r\nep = &dev->ep[UDC_EPIN_IDX(i)];\r\nep->epsts = pch_udc_read_ep_status(ep);\r\npch_udc_clear_ep_status(ep, ep->epsts);\r\n}\r\nif (ep_intr & (0x10000 << i)) {\r\nep = &dev->ep[UDC_EPOUT_IDX(i)];\r\nep->epsts = pch_udc_read_ep_status(ep);\r\npch_udc_clear_ep_status(ep, ep->epsts);\r\n}\r\n}\r\n}\r\nstatic void pch_udc_activate_control_ep(struct pch_udc_dev *dev)\r\n{\r\nstruct pch_udc_ep *ep;\r\nu32 val;\r\nep = &dev->ep[UDC_EP0IN_IDX];\r\npch_udc_clear_ep_control(ep);\r\npch_udc_ep_fifo_flush(ep, ep->in);\r\npch_udc_ep_set_bufsz(ep, UDC_EP0IN_BUFF_SIZE, ep->in);\r\npch_udc_ep_set_maxpkt(ep, UDC_EP0IN_MAX_PKT_SIZE);\r\nep->td_data = NULL;\r\nep->td_stp = NULL;\r\nep->td_data_phys = 0;\r\nep->td_stp_phys = 0;\r\nep = &dev->ep[UDC_EP0OUT_IDX];\r\npch_udc_clear_ep_control(ep);\r\npch_udc_ep_fifo_flush(ep, ep->in);\r\npch_udc_ep_set_bufsz(ep, UDC_EP0OUT_BUFF_SIZE, ep->in);\r\npch_udc_ep_set_maxpkt(ep, UDC_EP0OUT_MAX_PKT_SIZE);\r\nval = UDC_EP0OUT_MAX_PKT_SIZE << UDC_CSR_NE_MAX_PKT_SHIFT;\r\npch_udc_write_csr(ep->dev, val, UDC_EP0OUT_IDX);\r\npch_udc_init_setup_buff(ep->td_stp);\r\npch_udc_ep_set_subptr(ep, ep->td_stp_phys);\r\npch_udc_ep_set_ddptr(ep, ep->td_data_phys);\r\nep->td_data->status = PCH_UDC_DMA_LAST;\r\nep->td_data->dataptr = dev->dma_addr;\r\nep->td_data->next = ep->td_data_phys;\r\npch_udc_ep_clear_nak(ep);\r\n}\r\nstatic void pch_udc_svc_ur_interrupt(struct pch_udc_dev *dev)\r\n{\r\nstruct pch_udc_ep *ep;\r\nint i;\r\npch_udc_clear_dma(dev, DMA_DIR_TX);\r\npch_udc_clear_dma(dev, DMA_DIR_RX);\r\npch_udc_disable_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\r\npch_udc_write_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\r\nfor (i = 0; i < PCH_UDC_EP_NUM; i++) {\r\nep = &dev->ep[i];\r\npch_udc_clear_ep_status(ep, UDC_EPSTS_ALL_CLR_MASK);\r\npch_udc_clear_ep_control(ep);\r\npch_udc_ep_set_ddptr(ep, 0);\r\npch_udc_write_csr(ep->dev, 0x00, i);\r\n}\r\ndev->stall = 0;\r\ndev->prot_stall = 0;\r\ndev->waiting_zlp_ack = 0;\r\ndev->set_cfg_not_acked = 0;\r\nfor (i = 0; i < (PCH_UDC_USED_EP_NUM*2); i++) {\r\nep = &dev->ep[i];\r\npch_udc_ep_set_nak(ep);\r\npch_udc_ep_fifo_flush(ep, ep->in);\r\nempty_req_queue(ep);\r\n}\r\nif (dev->driver && dev->driver->disconnect) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\n}\r\nstatic void pch_udc_svc_enum_interrupt(struct pch_udc_dev *dev)\r\n{\r\nu32 dev_stat, dev_speed;\r\nu32 speed = USB_SPEED_FULL;\r\ndev_stat = pch_udc_read_device_status(dev);\r\ndev_speed = (dev_stat & UDC_DEVSTS_ENUM_SPEED_MASK) >>\r\nUDC_DEVSTS_ENUM_SPEED_SHIFT;\r\nswitch (dev_speed) {\r\ncase UDC_DEVSTS_ENUM_SPEED_HIGH:\r\nspeed = USB_SPEED_HIGH;\r\nbreak;\r\ncase UDC_DEVSTS_ENUM_SPEED_FULL:\r\nspeed = USB_SPEED_FULL;\r\nbreak;\r\ncase UDC_DEVSTS_ENUM_SPEED_LOW:\r\nspeed = USB_SPEED_LOW;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndev->gadget.speed = speed;\r\npch_udc_activate_control_ep(dev);\r\npch_udc_enable_ep_interrupts(dev, UDC_EPINT_IN_EP0 | UDC_EPINT_OUT_EP0);\r\npch_udc_set_dma(dev, DMA_DIR_TX);\r\npch_udc_set_dma(dev, DMA_DIR_RX);\r\npch_udc_ep_set_rrdy(&(dev->ep[UDC_EP0OUT_IDX]));\r\npch_udc_enable_interrupts(dev, UDC_DEVINT_UR | UDC_DEVINT_US |\r\nUDC_DEVINT_ES | UDC_DEVINT_ENUM |\r\nUDC_DEVINT_SI | UDC_DEVINT_SC);\r\n}\r\nstatic void pch_udc_svc_intf_interrupt(struct pch_udc_dev *dev)\r\n{\r\nu32 reg, dev_stat = 0;\r\nint i, ret;\r\ndev_stat = pch_udc_read_device_status(dev);\r\ndev->cfg_data.cur_intf = (dev_stat & UDC_DEVSTS_INTF_MASK) >>\r\nUDC_DEVSTS_INTF_SHIFT;\r\ndev->cfg_data.cur_alt = (dev_stat & UDC_DEVSTS_ALT_MASK) >>\r\nUDC_DEVSTS_ALT_SHIFT;\r\ndev->set_cfg_not_acked = 1;\r\nmemset(&dev->setup_data, 0 , sizeof dev->setup_data);\r\ndev->setup_data.bRequest = USB_REQ_SET_INTERFACE;\r\ndev->setup_data.bRequestType = USB_RECIP_INTERFACE;\r\ndev->setup_data.wValue = cpu_to_le16(dev->cfg_data.cur_alt);\r\ndev->setup_data.wIndex = cpu_to_le16(dev->cfg_data.cur_intf);\r\nreg = pch_udc_read_csr(dev, UDC_EP0OUT_IDX);\r\nreg = (reg & ~UDC_CSR_NE_INTF_MASK) |\r\n(dev->cfg_data.cur_intf << UDC_CSR_NE_INTF_SHIFT);\r\nreg = (reg & ~UDC_CSR_NE_ALT_MASK) |\r\n(dev->cfg_data.cur_alt << UDC_CSR_NE_ALT_SHIFT);\r\npch_udc_write_csr(dev, reg, UDC_EP0OUT_IDX);\r\nfor (i = 0; i < PCH_UDC_USED_EP_NUM * 2; i++) {\r\npch_udc_ep_clear_stall(&(dev->ep[i]));\r\ndev->ep[i].halted = 0;\r\n}\r\ndev->stall = 0;\r\nspin_unlock(&dev->lock);\r\nret = dev->driver->setup(&dev->gadget, &dev->setup_data);\r\nspin_lock(&dev->lock);\r\n}\r\nstatic void pch_udc_svc_cfg_interrupt(struct pch_udc_dev *dev)\r\n{\r\nint i, ret;\r\nu32 reg, dev_stat = 0;\r\ndev_stat = pch_udc_read_device_status(dev);\r\ndev->set_cfg_not_acked = 1;\r\ndev->cfg_data.cur_cfg = (dev_stat & UDC_DEVSTS_CFG_MASK) >>\r\nUDC_DEVSTS_CFG_SHIFT;\r\nmemset(&dev->setup_data, 0 , sizeof dev->setup_data);\r\ndev->setup_data.bRequest = USB_REQ_SET_CONFIGURATION;\r\ndev->setup_data.wValue = cpu_to_le16(dev->cfg_data.cur_cfg);\r\nreg = pch_udc_read_csr(dev, UDC_EP0OUT_IDX);\r\nreg = (reg & ~UDC_CSR_NE_CFG_MASK) |\r\n(dev->cfg_data.cur_cfg << UDC_CSR_NE_CFG_SHIFT);\r\npch_udc_write_csr(dev, reg, UDC_EP0OUT_IDX);\r\nfor (i = 0; i < PCH_UDC_USED_EP_NUM * 2; i++) {\r\npch_udc_ep_clear_stall(&(dev->ep[i]));\r\ndev->ep[i].halted = 0;\r\n}\r\ndev->stall = 0;\r\nspin_unlock(&dev->lock);\r\nret = dev->driver->setup(&dev->gadget, &dev->setup_data);\r\nspin_lock(&dev->lock);\r\n}\r\nstatic void pch_udc_dev_isr(struct pch_udc_dev *dev, u32 dev_intr)\r\n{\r\nint vbus;\r\nif (dev_intr & UDC_DEVINT_UR) {\r\npch_udc_svc_ur_interrupt(dev);\r\ndev_dbg(&dev->pdev->dev, "USB_RESET\n");\r\n}\r\nif (dev_intr & UDC_DEVINT_ENUM) {\r\npch_udc_svc_enum_interrupt(dev);\r\ndev_dbg(&dev->pdev->dev, "USB_ENUM\n");\r\n}\r\nif (dev_intr & UDC_DEVINT_SI)\r\npch_udc_svc_intf_interrupt(dev);\r\nif (dev_intr & UDC_DEVINT_SC)\r\npch_udc_svc_cfg_interrupt(dev);\r\nif (dev_intr & UDC_DEVINT_US) {\r\nif (dev->driver\r\n&& dev->driver->suspend) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->suspend(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\nvbus = pch_vbus_gpio_get_value(dev);\r\nif ((dev->vbus_session == 0)\r\n&& (vbus != 1)) {\r\nif (dev->driver && dev->driver->disconnect) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\npch_udc_reconnect(dev);\r\n} else if ((dev->vbus_session == 0)\r\n&& (vbus == 1)\r\n&& !dev->vbus_gpio.intr)\r\nschedule_work(&dev->vbus_gpio.irq_work_fall);\r\ndev_dbg(&dev->pdev->dev, "USB_SUSPEND\n");\r\n}\r\nif (dev_intr & UDC_DEVINT_SOF)\r\ndev_dbg(&dev->pdev->dev, "SOF\n");\r\nif (dev_intr & UDC_DEVINT_ES)\r\ndev_dbg(&dev->pdev->dev, "ES\n");\r\nif (dev_intr & UDC_DEVINT_RWKP)\r\ndev_dbg(&dev->pdev->dev, "RWKP\n");\r\n}\r\nstatic irqreturn_t pch_udc_isr(int irq, void *pdev)\r\n{\r\nstruct pch_udc_dev *dev = (struct pch_udc_dev *) pdev;\r\nu32 dev_intr, ep_intr;\r\nint i;\r\ndev_intr = pch_udc_read_device_interrupts(dev);\r\nep_intr = pch_udc_read_ep_interrupts(dev);\r\nif (dev_intr == ep_intr)\r\nif (dev_intr == pch_udc_readl(dev, UDC_DEVCFG_ADDR)) {\r\ndev_dbg(&dev->pdev->dev, "UDC: Hung up\n");\r\npch_udc_writel(dev, UDC_SRST, UDC_SRST_ADDR);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (dev_intr)\r\npch_udc_write_device_interrupts(dev, dev_intr);\r\nif (ep_intr)\r\npch_udc_write_ep_interrupts(dev, ep_intr);\r\nif (!dev_intr && !ep_intr)\r\nreturn IRQ_NONE;\r\nspin_lock(&dev->lock);\r\nif (dev_intr)\r\npch_udc_dev_isr(dev, dev_intr);\r\nif (ep_intr) {\r\npch_udc_read_all_epstatus(dev, ep_intr);\r\nif (ep_intr & UDC_EPINT_IN_EP0) {\r\npch_udc_svc_control_in(dev);\r\npch_udc_postsvc_epinters(dev, 0);\r\n}\r\nif (ep_intr & UDC_EPINT_OUT_EP0)\r\npch_udc_svc_control_out(dev);\r\nfor (i = 1; i < PCH_UDC_USED_EP_NUM; i++) {\r\nif (ep_intr & (1 << i)) {\r\npch_udc_svc_data_in(dev, i);\r\npch_udc_postsvc_epinters(dev, i);\r\n}\r\n}\r\nfor (i = UDC_EPINT_OUT_SHIFT + 1; i < (UDC_EPINT_OUT_SHIFT +\r\nPCH_UDC_USED_EP_NUM); i++)\r\nif (ep_intr & (1 << i))\r\npch_udc_svc_data_out(dev, i -\r\nUDC_EPINT_OUT_SHIFT);\r\n}\r\nspin_unlock(&dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pch_udc_setup_ep0(struct pch_udc_dev *dev)\r\n{\r\npch_udc_enable_ep_interrupts(dev, UDC_EPINT_IN_EP0 |\r\nUDC_EPINT_OUT_EP0);\r\npch_udc_enable_interrupts(dev, UDC_DEVINT_UR | UDC_DEVINT_US |\r\nUDC_DEVINT_ES | UDC_DEVINT_ENUM |\r\nUDC_DEVINT_SI | UDC_DEVINT_SC);\r\n}\r\nstatic void gadget_release(struct device *pdev)\r\n{\r\nstruct pch_udc_dev *dev = dev_get_drvdata(pdev);\r\nkfree(dev);\r\n}\r\nstatic void pch_udc_pcd_reinit(struct pch_udc_dev *dev)\r\n{\r\nconst char *const ep_string[] = {\r\nep0_string, "ep0out", "ep1in", "ep1out", "ep2in", "ep2out",\r\n"ep3in", "ep3out", "ep4in", "ep4out", "ep5in", "ep5out",\r\n"ep6in", "ep6out", "ep7in", "ep7out", "ep8in", "ep8out",\r\n"ep9in", "ep9out", "ep10in", "ep10out", "ep11in", "ep11out",\r\n"ep12in", "ep12out", "ep13in", "ep13out", "ep14in", "ep14out",\r\n"ep15in", "ep15out",\r\n};\r\nint i;\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nmemset(dev->ep, 0, sizeof dev->ep);\r\nfor (i = 0; i < PCH_UDC_EP_NUM; i++) {\r\nstruct pch_udc_ep *ep = &dev->ep[i];\r\nep->dev = dev;\r\nep->halted = 1;\r\nep->num = i / 2;\r\nep->in = ~i & 1;\r\nep->ep.name = ep_string[i];\r\nep->ep.ops = &pch_udc_ep_ops;\r\nif (ep->in)\r\nep->offset_addr = ep->num * UDC_EP_REG_SHIFT;\r\nelse\r\nep->offset_addr = (UDC_EPINT_OUT_SHIFT + ep->num) *\r\nUDC_EP_REG_SHIFT;\r\nep->ep.maxpacket = UDC_BULK_MAX_PKT_SIZE;\r\nlist_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\ndev->ep[UDC_EP0IN_IDX].ep.maxpacket = UDC_EP0IN_MAX_PKT_SIZE;\r\ndev->ep[UDC_EP0OUT_IDX].ep.maxpacket = UDC_EP0OUT_MAX_PKT_SIZE;\r\nlist_del_init(&dev->ep[UDC_EP0IN_IDX].ep.ep_list);\r\nlist_del_init(&dev->ep[UDC_EP0OUT_IDX].ep.ep_list);\r\ndev->gadget.ep0 = &dev->ep[UDC_EP0IN_IDX].ep;\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\n}\r\nstatic int pch_udc_pcd_init(struct pch_udc_dev *dev)\r\n{\r\npch_udc_init(dev);\r\npch_udc_pcd_reinit(dev);\r\npch_vbus_gpio_init(dev, vbus_gpio_port);\r\nreturn 0;\r\n}\r\nstatic int init_dma_pools(struct pch_udc_dev *dev)\r\n{\r\nstruct pch_udc_stp_dma_desc *td_stp;\r\nstruct pch_udc_data_dma_desc *td_data;\r\ndev->data_requests = pci_pool_create("data_requests", dev->pdev,\r\nsizeof(struct pch_udc_data_dma_desc), 0, 0);\r\nif (!dev->data_requests) {\r\ndev_err(&dev->pdev->dev, "%s: can't get request data pool\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\ndev->stp_requests = pci_pool_create("setup requests", dev->pdev,\r\nsizeof(struct pch_udc_stp_dma_desc), 0, 0);\r\nif (!dev->stp_requests) {\r\ndev_err(&dev->pdev->dev, "%s: can't get setup request pool\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\ntd_stp = pci_pool_alloc(dev->stp_requests, GFP_KERNEL,\r\n&dev->ep[UDC_EP0OUT_IDX].td_stp_phys);\r\nif (!td_stp) {\r\ndev_err(&dev->pdev->dev,\r\n"%s: can't allocate setup dma descriptor\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndev->ep[UDC_EP0OUT_IDX].td_stp = td_stp;\r\ntd_data = pci_pool_alloc(dev->data_requests, GFP_KERNEL,\r\n&dev->ep[UDC_EP0OUT_IDX].td_data_phys);\r\nif (!td_data) {\r\ndev_err(&dev->pdev->dev,\r\n"%s: can't allocate data dma descriptor\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndev->ep[UDC_EP0OUT_IDX].td_data = td_data;\r\ndev->ep[UDC_EP0IN_IDX].td_stp = NULL;\r\ndev->ep[UDC_EP0IN_IDX].td_stp_phys = 0;\r\ndev->ep[UDC_EP0IN_IDX].td_data = NULL;\r\ndev->ep[UDC_EP0IN_IDX].td_data_phys = 0;\r\ndev->ep0out_buf = kzalloc(UDC_EP0OUT_BUFF_SIZE * 4, GFP_KERNEL);\r\nif (!dev->ep0out_buf)\r\nreturn -ENOMEM;\r\ndev->dma_addr = dma_map_single(&dev->pdev->dev, dev->ep0out_buf,\r\nUDC_EP0OUT_BUFF_SIZE * 4,\r\nDMA_FROM_DEVICE);\r\nreturn 0;\r\n}\r\nstatic int pch_udc_start(struct usb_gadget_driver *driver,\r\nint (*bind)(struct usb_gadget *, struct usb_gadget_driver *))\r\n{\r\nstruct pch_udc_dev *dev = pch_udc;\r\nint retval;\r\nif (!driver || (driver->max_speed == USB_SPEED_UNKNOWN) || !bind ||\r\n!driver->setup || !driver->unbind || !driver->disconnect) {\r\ndev_err(&dev->pdev->dev,\r\n"%s: invalid driver parameter\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (dev->driver) {\r\ndev_err(&dev->pdev->dev, "%s: already bound\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\ndev->gadget.dev.driver = &driver->driver;\r\nretval = bind(&dev->gadget, driver);\r\nif (retval) {\r\ndev_err(&dev->pdev->dev, "%s: binding to %s returning %d\n",\r\n__func__, driver->driver.name, retval);\r\ndev->driver = NULL;\r\ndev->gadget.dev.driver = NULL;\r\nreturn retval;\r\n}\r\npch_udc_setup_ep0(dev);\r\nif ((pch_vbus_gpio_get_value(dev) != 0) || !dev->vbus_gpio.intr)\r\npch_udc_clear_disconnect(dev);\r\ndev->connected = 1;\r\nreturn 0;\r\n}\r\nstatic int pch_udc_stop(struct usb_gadget_driver *driver)\r\n{\r\nstruct pch_udc_dev *dev = pch_udc;\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (!driver || (driver != dev->driver)) {\r\ndev_err(&dev->pdev->dev,\r\n"%s: invalid driver parameter\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npch_udc_disable_interrupts(dev, UDC_DEVINT_MSK);\r\ndriver->disconnect(&dev->gadget);\r\ndriver->unbind(&dev->gadget);\r\ndev->gadget.dev.driver = NULL;\r\ndev->driver = NULL;\r\ndev->connected = 0;\r\npch_udc_set_disconnect(dev);\r\nreturn 0;\r\n}\r\nstatic void pch_udc_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct pch_udc_dev *dev = pci_get_drvdata(pdev);\r\npch_udc_disable_interrupts(dev, UDC_DEVINT_MSK);\r\npch_udc_disable_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\r\npch_udc_set_disconnect(dev);\r\n}\r\nstatic void pch_udc_remove(struct pci_dev *pdev)\r\n{\r\nstruct pch_udc_dev *dev = pci_get_drvdata(pdev);\r\nusb_del_gadget_udc(&dev->gadget);\r\nif (dev->driver)\r\ndev_err(&pdev->dev,\r\n"%s: gadget driver still bound!!!\n", __func__);\r\nif (dev->data_requests)\r\npci_pool_destroy(dev->data_requests);\r\nif (dev->stp_requests) {\r\nif (dev->ep[UDC_EP0OUT_IDX].td_stp) {\r\npci_pool_free(dev->stp_requests,\r\ndev->ep[UDC_EP0OUT_IDX].td_stp,\r\ndev->ep[UDC_EP0OUT_IDX].td_stp_phys);\r\n}\r\nif (dev->ep[UDC_EP0OUT_IDX].td_data) {\r\npci_pool_free(dev->stp_requests,\r\ndev->ep[UDC_EP0OUT_IDX].td_data,\r\ndev->ep[UDC_EP0OUT_IDX].td_data_phys);\r\n}\r\npci_pool_destroy(dev->stp_requests);\r\n}\r\nif (dev->dma_addr)\r\ndma_unmap_single(&dev->pdev->dev, dev->dma_addr,\r\nUDC_EP0OUT_BUFF_SIZE * 4, DMA_FROM_DEVICE);\r\nkfree(dev->ep0out_buf);\r\npch_vbus_gpio_free(dev);\r\npch_udc_exit(dev);\r\nif (dev->irq_registered)\r\nfree_irq(pdev->irq, dev);\r\nif (dev->base_addr)\r\niounmap(dev->base_addr);\r\nif (dev->mem_region)\r\nrelease_mem_region(dev->phys_addr,\r\npci_resource_len(pdev, PCH_UDC_PCI_BAR));\r\nif (dev->active)\r\npci_disable_device(pdev);\r\nif (dev->registered)\r\ndevice_unregister(&dev->gadget.dev);\r\nkfree(dev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int pch_udc_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct pch_udc_dev *dev = pci_get_drvdata(pdev);\r\npch_udc_disable_interrupts(dev, UDC_DEVINT_MSK);\r\npch_udc_disable_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\r\npci_disable_device(pdev);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\nif (pci_save_state(pdev)) {\r\ndev_err(&pdev->dev,\r\n"%s: could not save PCI config state\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pch_udc_resume(struct pci_dev *pdev)\r\n{\r\nint ret;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: pci_enable_device failed\n", __func__);\r\nreturn ret;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\nreturn 0;\r\n}\r\nstatic int pch_udc_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned long resource;\r\nunsigned long len;\r\nint retval;\r\nstruct pch_udc_dev *dev;\r\nif (pch_udc) {\r\npr_err("%s: already probed\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ndev = kzalloc(sizeof *dev, GFP_KERNEL);\r\nif (!dev) {\r\npr_err("%s: no memory for device structure\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (pci_enable_device(pdev) < 0) {\r\nkfree(dev);\r\npr_err("%s: pci_enable_device failed\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ndev->active = 1;\r\npci_set_drvdata(pdev, dev);\r\nresource = pci_resource_start(pdev, 1);\r\nlen = pci_resource_len(pdev, 1);\r\nif (!request_mem_region(resource, len, KBUILD_MODNAME)) {\r\ndev_err(&pdev->dev, "%s: pci device used already\n", __func__);\r\nretval = -EBUSY;\r\ngoto finished;\r\n}\r\ndev->phys_addr = resource;\r\ndev->mem_region = 1;\r\ndev->base_addr = ioremap_nocache(resource, len);\r\nif (!dev->base_addr) {\r\npr_err("%s: device memory cannot be mapped\n", __func__);\r\nretval = -ENOMEM;\r\ngoto finished;\r\n}\r\nif (!pdev->irq) {\r\ndev_err(&pdev->dev, "%s: irq not set\n", __func__);\r\nretval = -ENODEV;\r\ngoto finished;\r\n}\r\npch_udc = dev;\r\nif (pch_udc_pcd_init(dev)) {\r\nretval = -ENODEV;\r\ngoto finished;\r\n}\r\nif (request_irq(pdev->irq, pch_udc_isr, IRQF_SHARED, KBUILD_MODNAME,\r\ndev)) {\r\ndev_err(&pdev->dev, "%s: request_irq(%d) fail\n", __func__,\r\npdev->irq);\r\nretval = -ENODEV;\r\ngoto finished;\r\n}\r\ndev->irq = pdev->irq;\r\ndev->irq_registered = 1;\r\npci_set_master(pdev);\r\npci_try_set_mwi(pdev);\r\nspin_lock_init(&dev->lock);\r\ndev->pdev = pdev;\r\ndev->gadget.ops = &pch_udc_ops;\r\nretval = init_dma_pools(dev);\r\nif (retval)\r\ngoto finished;\r\ndev_set_name(&dev->gadget.dev, "gadget");\r\ndev->gadget.dev.parent = &pdev->dev;\r\ndev->gadget.dev.dma_mask = pdev->dev.dma_mask;\r\ndev->gadget.dev.release = gadget_release;\r\ndev->gadget.name = KBUILD_MODNAME;\r\ndev->gadget.max_speed = USB_SPEED_HIGH;\r\nretval = device_register(&dev->gadget.dev);\r\nif (retval)\r\ngoto finished;\r\ndev->registered = 1;\r\npch_udc_set_disconnect(dev);\r\nretval = usb_add_gadget_udc(&pdev->dev, &dev->gadget);\r\nif (retval)\r\ngoto finished;\r\nreturn 0;\r\nfinished:\r\npch_udc_remove(pdev);\r\nreturn retval;\r\n}
