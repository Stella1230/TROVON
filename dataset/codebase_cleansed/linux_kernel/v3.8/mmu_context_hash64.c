int __init_new_context(void)\r\n{\r\nint index;\r\nint err;\r\nagain:\r\nif (!ida_pre_get(&mmu_context_ida, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nspin_lock(&mmu_context_lock);\r\nerr = ida_get_new_above(&mmu_context_ida, 1, &index);\r\nspin_unlock(&mmu_context_lock);\r\nif (err == -EAGAIN)\r\ngoto again;\r\nelse if (err)\r\nreturn err;\r\nif (index > MAX_CONTEXT) {\r\nspin_lock(&mmu_context_lock);\r\nida_remove(&mmu_context_ida, index);\r\nspin_unlock(&mmu_context_lock);\r\nreturn -ENOMEM;\r\n}\r\nreturn index;\r\n}\r\nint init_new_context(struct task_struct *tsk, struct mm_struct *mm)\r\n{\r\nint index;\r\nindex = __init_new_context();\r\nif (index < 0)\r\nreturn index;\r\nif (slice_mm_new_context(mm))\r\nslice_set_user_psize(mm, mmu_virtual_psize);\r\nsubpage_prot_init_new_context(mm);\r\nmm->context.id = index;\r\n#ifdef CONFIG_PPC_ICSWX\r\nmm->context.cop_lockp = kmalloc(sizeof(spinlock_t), GFP_KERNEL);\r\nif (!mm->context.cop_lockp) {\r\n__destroy_context(index);\r\nsubpage_prot_free(mm);\r\nmm->context.id = MMU_NO_CONTEXT;\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(mm->context.cop_lockp);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid __destroy_context(int context_id)\r\n{\r\nspin_lock(&mmu_context_lock);\r\nida_remove(&mmu_context_ida, context_id);\r\nspin_unlock(&mmu_context_lock);\r\n}\r\nvoid destroy_context(struct mm_struct *mm)\r\n{\r\n#ifdef CONFIG_PPC_ICSWX\r\ndrop_cop(mm->context.acop, mm);\r\nkfree(mm->context.cop_lockp);\r\nmm->context.cop_lockp = NULL;\r\n#endif\r\n__destroy_context(mm->context.id);\r\nsubpage_prot_free(mm);\r\nmm->context.id = MMU_NO_CONTEXT;\r\n}
