int efx_mcdi_set_mac(struct efx_nic *efx)\r\n{\r\nu32 reject, fcntl;\r\nu8 cmdbytes[MC_CMD_SET_MAC_IN_LEN];\r\nmemcpy(cmdbytes + MC_CMD_SET_MAC_IN_ADDR_OFST,\r\nefx->net_dev->dev_addr, ETH_ALEN);\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_MTU,\r\nEFX_MAX_FRAME_LEN(efx->net_dev->mtu));\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_DRAIN, 0);\r\nreject = (efx->promiscuous) ? 0 :\r\n(1 << MC_CMD_SET_MAC_IN_REJECT_UNCST_LBN);\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_REJECT, reject);\r\nswitch (efx->wanted_fc) {\r\ncase EFX_FC_RX | EFX_FC_TX:\r\nfcntl = MC_CMD_FCNTL_BIDIR;\r\nbreak;\r\ncase EFX_FC_RX:\r\nfcntl = MC_CMD_FCNTL_RESPOND;\r\nbreak;\r\ndefault:\r\nfcntl = MC_CMD_FCNTL_OFF;\r\nbreak;\r\n}\r\nif (efx->wanted_fc & EFX_FC_AUTO)\r\nfcntl = MC_CMD_FCNTL_AUTO;\r\nif (efx->fc_disable)\r\nfcntl = MC_CMD_FCNTL_OFF;\r\nMCDI_SET_DWORD(cmdbytes, SET_MAC_IN_FCNTL, fcntl);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_SET_MAC, cmdbytes, sizeof(cmdbytes),\r\nNULL, 0, NULL);\r\n}\r\nbool efx_mcdi_mac_check_fault(struct efx_nic *efx)\r\n{\r\nu8 outbuf[MC_CMD_GET_LINK_OUT_LEN];\r\nsize_t outlength;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlength);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\nreturn true;\r\n}\r\nreturn MCDI_DWORD(outbuf, GET_LINK_OUT_MAC_FAULT) != 0;\r\n}\r\nint efx_mcdi_mac_stats(struct efx_nic *efx, dma_addr_t dma_addr,\r\nu32 dma_len, int enable, int clear)\r\n{\r\nu8 inbuf[MC_CMD_MAC_STATS_IN_LEN];\r\nint rc;\r\nefx_dword_t *cmd_ptr;\r\nint period = enable ? 1000 : 0;\r\nu32 addr_hi;\r\nu32 addr_lo;\r\nBUILD_BUG_ON(MC_CMD_MAC_STATS_OUT_DMA_LEN != 0);\r\naddr_lo = ((u64)dma_addr) >> 0;\r\naddr_hi = ((u64)dma_addr) >> 32;\r\nMCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_ADDR_LO, addr_lo);\r\nMCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_ADDR_HI, addr_hi);\r\ncmd_ptr = (efx_dword_t *)MCDI_PTR(inbuf, MAC_STATS_IN_CMD);\r\nEFX_POPULATE_DWORD_7(*cmd_ptr,\r\nMC_CMD_MAC_STATS_IN_DMA, !!enable,\r\nMC_CMD_MAC_STATS_IN_CLEAR, clear,\r\nMC_CMD_MAC_STATS_IN_PERIODIC_CHANGE, 1,\r\nMC_CMD_MAC_STATS_IN_PERIODIC_ENABLE, !!enable,\r\nMC_CMD_MAC_STATS_IN_PERIODIC_CLEAR, 0,\r\nMC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT, 1,\r\nMC_CMD_MAC_STATS_IN_PERIOD_MS, period);\r\nMCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_LEN, dma_len);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_MAC_STATS, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: %s failed rc=%d\n",\r\n__func__, enable ? "enable" : "disable", rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_mac_reconfigure(struct efx_nic *efx)\r\n{\r\nint rc;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nrc = efx_mcdi_set_mac(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn efx_mcdi_rpc(efx, MC_CMD_SET_MCAST_HASH,\r\nefx->multicast_hash.byte,\r\nsizeof(efx->multicast_hash),\r\nNULL, 0, NULL);\r\n}
