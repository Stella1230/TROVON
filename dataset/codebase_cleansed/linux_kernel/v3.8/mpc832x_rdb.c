static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,\r\nstruct spi_board_info *board_infos,\r\nunsigned int num_board_infos,\r\nvoid (*cs_control)(struct spi_device *dev,\r\nbool on))\r\n{\r\nstruct device_node *np;\r\nunsigned int i = 0;\r\nfor_each_compatible_node(np, type, compatible) {\r\nint ret;\r\nunsigned int j;\r\nconst void *prop;\r\nstruct resource res[2];\r\nstruct platform_device *pdev;\r\nstruct fsl_spi_platform_data pdata = {\r\n.cs_control = cs_control,\r\n};\r\nmemset(res, 0, sizeof(res));\r\npdata.sysclk = sysclk;\r\nprop = of_get_property(np, "reg", NULL);\r\nif (!prop)\r\ngoto err;\r\npdata.bus_num = *(u32 *)prop;\r\nprop = of_get_property(np, "cell-index", NULL);\r\nif (prop)\r\ni = *(u32 *)prop;\r\nprop = of_get_property(np, "mode", NULL);\r\nif (prop && !strcmp(prop, "cpu-qe"))\r\npdata.flags = SPI_QE_CPU_MODE;\r\nfor (j = 0; j < num_board_infos; j++) {\r\nif (board_infos[j].bus_num == pdata.bus_num)\r\npdata.max_chipselect++;\r\n}\r\nif (!pdata.max_chipselect)\r\ncontinue;\r\nret = of_address_to_resource(np, 0, &res[0]);\r\nif (ret)\r\ngoto err;\r\nret = of_irq_to_resource(np, 0, &res[1]);\r\nif (ret == NO_IRQ)\r\ngoto err;\r\npdev = platform_device_alloc("mpc83xx_spi", i);\r\nif (!pdev)\r\ngoto err;\r\nret = platform_device_add_data(pdev, &pdata, sizeof(pdata));\r\nif (ret)\r\ngoto unreg;\r\nret = platform_device_add_resources(pdev, res,\r\nARRAY_SIZE(res));\r\nif (ret)\r\ngoto unreg;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto unreg;\r\ngoto next;\r\nunreg:\r\nplatform_device_del(pdev);\r\nerr:\r\npr_err("%s: registration failed\n", np->full_name);\r\nnext:\r\ni++;\r\n}\r\nreturn i;\r\n}\r\nstatic int __init fsl_spi_init(struct spi_board_info *board_infos,\r\nunsigned int num_board_infos,\r\nvoid (*cs_control)(struct spi_device *spi,\r\nbool on))\r\n{\r\nu32 sysclk = -1;\r\nint ret;\r\nsysclk = get_brgfreq();\r\nif (sysclk == -1) {\r\nsysclk = fsl_get_sys_freq();\r\nif (sysclk == -1)\r\nreturn -ENODEV;\r\n}\r\nret = of_fsl_spi_probe(NULL, "fsl,spi", sysclk, board_infos,\r\nnum_board_infos, cs_control);\r\nif (!ret)\r\nof_fsl_spi_probe("spi", "fsl_spi", sysclk, board_infos,\r\nnum_board_infos, cs_control);\r\nreturn spi_register_board_info(board_infos, num_board_infos);\r\n}\r\nstatic void mpc83xx_spi_cs_control(struct spi_device *spi, bool on)\r\n{\r\npr_debug("%s %d %d\n", __func__, spi->chip_select, on);\r\npar_io_data_set(3, 13, on);\r\n}\r\nstatic int __init mpc832x_spi_init(void)\r\n{\r\npar_io_config_pin(3, 0, 3, 0, 1, 0);\r\npar_io_config_pin(3, 1, 3, 0, 1, 0);\r\npar_io_config_pin(3, 2, 3, 0, 1, 0);\r\npar_io_config_pin(3, 3, 2, 0, 1, 0);\r\npar_io_config_pin(3, 13, 1, 0, 0, 0);\r\npar_io_config_pin(3, 14, 2, 0, 0, 0);\r\npar_io_config_pin(3, 15, 2, 0, 0, 0);\r\nif (of_find_compatible_node(NULL, NULL, "mmc-spi-slot"))\r\nreturn 0;\r\nreturn fsl_spi_init(&mpc832x_spi_boardinfo, 1, mpc83xx_spi_cs_control);\r\n}\r\nstatic void __init mpc832x_rdb_setup_arch(void)\r\n{\r\n#if defined(CONFIG_QUICC_ENGINE)\r\nstruct device_node *np;\r\n#endif\r\nif (ppc_md.progress)\r\nppc_md.progress("mpc832x_rdb_setup_arch()", 0);\r\nmpc83xx_setup_pci();\r\n#ifdef CONFIG_QUICC_ENGINE\r\nqe_reset();\r\nif ((np = of_find_node_by_name(NULL, "par_io")) != NULL) {\r\npar_io_init(np);\r\nof_node_put(np);\r\nfor (np = NULL; (np = of_find_node_by_name(np, "ucc")) != NULL;)\r\npar_io_of_config(np);\r\n}\r\n#endif\r\n}\r\nstatic int __init mpc832x_rdb_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nreturn of_flat_dt_is_compatible(root, "MPC832xRDB");\r\n}
