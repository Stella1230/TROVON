static int opterror(const struct option *opt, const char *reason, int flags)\r\n{\r\nif (flags & OPT_SHORT)\r\nreturn error("switch `%c' %s", opt->short_name, reason);\r\nif (flags & OPT_UNSET)\r\nreturn error("option `no-%s' %s", opt->long_name, reason);\r\nreturn error("option `%s' %s", opt->long_name, reason);\r\n}\r\nstatic int get_arg(struct parse_opt_ctx_t *p, const struct option *opt,\r\nint flags, const char **arg)\r\n{\r\nif (p->opt) {\r\n*arg = p->opt;\r\np->opt = NULL;\r\n} else if ((opt->flags & PARSE_OPT_LASTARG_DEFAULT) && (p->argc == 1 ||\r\n**(p->argv + 1) == '-')) {\r\n*arg = (const char *)opt->defval;\r\n} else if (p->argc > 1) {\r\np->argc--;\r\n*arg = *++p->argv;\r\n} else\r\nreturn opterror(opt, "requires a value", flags);\r\nreturn 0;\r\n}\r\nstatic int get_value(struct parse_opt_ctx_t *p,\r\nconst struct option *opt, int flags)\r\n{\r\nconst char *s, *arg = NULL;\r\nconst int unset = flags & OPT_UNSET;\r\nif (unset && p->opt)\r\nreturn opterror(opt, "takes no value", flags);\r\nif (unset && (opt->flags & PARSE_OPT_NONEG))\r\nreturn opterror(opt, "isn't available", flags);\r\nif (!(flags & OPT_SHORT) && p->opt) {\r\nswitch (opt->type) {\r\ncase OPTION_CALLBACK:\r\nif (!(opt->flags & PARSE_OPT_NOARG))\r\nbreak;\r\ncase OPTION_BOOLEAN:\r\ncase OPTION_INCR:\r\ncase OPTION_BIT:\r\ncase OPTION_SET_UINT:\r\ncase OPTION_SET_PTR:\r\nreturn opterror(opt, "takes no value", flags);\r\ncase OPTION_END:\r\ncase OPTION_ARGUMENT:\r\ncase OPTION_GROUP:\r\ncase OPTION_STRING:\r\ncase OPTION_INTEGER:\r\ncase OPTION_UINTEGER:\r\ncase OPTION_LONG:\r\ncase OPTION_U64:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (opt->type) {\r\ncase OPTION_BIT:\r\nif (unset)\r\n*(int *)opt->value &= ~opt->defval;\r\nelse\r\n*(int *)opt->value |= opt->defval;\r\nreturn 0;\r\ncase OPTION_BOOLEAN:\r\n*(bool *)opt->value = unset ? false : true;\r\nreturn 0;\r\ncase OPTION_INCR:\r\n*(int *)opt->value = unset ? 0 : *(int *)opt->value + 1;\r\nreturn 0;\r\ncase OPTION_SET_UINT:\r\n*(unsigned int *)opt->value = unset ? 0 : opt->defval;\r\nreturn 0;\r\ncase OPTION_SET_PTR:\r\n*(void **)opt->value = unset ? NULL : (void *)opt->defval;\r\nreturn 0;\r\ncase OPTION_STRING:\r\nif (unset)\r\n*(const char **)opt->value = NULL;\r\nelse if (opt->flags & PARSE_OPT_OPTARG && !p->opt)\r\n*(const char **)opt->value = (const char *)opt->defval;\r\nelse\r\nreturn get_arg(p, opt, flags, (const char **)opt->value);\r\nreturn 0;\r\ncase OPTION_CALLBACK:\r\nif (unset)\r\nreturn (*opt->callback)(opt, NULL, 1) ? (-1) : 0;\r\nif (opt->flags & PARSE_OPT_NOARG)\r\nreturn (*opt->callback)(opt, NULL, 0) ? (-1) : 0;\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt)\r\nreturn (*opt->callback)(opt, NULL, 0) ? (-1) : 0;\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\nreturn (*opt->callback)(opt, arg, 0) ? (-1) : 0;\r\ncase OPTION_INTEGER:\r\nif (unset) {\r\n*(int *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(int *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(int *)opt->value = strtol(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_UINTEGER:\r\nif (unset) {\r\n*(unsigned int *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(unsigned int *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(unsigned int *)opt->value = strtol(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_LONG:\r\nif (unset) {\r\n*(long *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(long *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(long *)opt->value = strtol(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_U64:\r\nif (unset) {\r\n*(u64 *)opt->value = 0;\r\nreturn 0;\r\n}\r\nif (opt->flags & PARSE_OPT_OPTARG && !p->opt) {\r\n*(u64 *)opt->value = opt->defval;\r\nreturn 0;\r\n}\r\nif (get_arg(p, opt, flags, &arg))\r\nreturn -1;\r\n*(u64 *)opt->value = strtoull(arg, (char **)&s, 10);\r\nif (*s)\r\nreturn opterror(opt, "expects a numerical value", flags);\r\nreturn 0;\r\ncase OPTION_END:\r\ncase OPTION_ARGUMENT:\r\ncase OPTION_GROUP:\r\ndefault:\r\ndie("should not happen, someone must be hit on the forehead");\r\n}\r\n}\r\nstatic int parse_short_opt(struct parse_opt_ctx_t *p, const struct option *options)\r\n{\r\nfor (; options->type != OPTION_END; options++) {\r\nif (options->short_name == *p->opt) {\r\np->opt = p->opt[1] ? p->opt + 1 : NULL;\r\nreturn get_value(p, options, OPT_SHORT);\r\n}\r\n}\r\nreturn -2;\r\n}\r\nstatic int parse_long_opt(struct parse_opt_ctx_t *p, const char *arg,\r\nconst struct option *options)\r\n{\r\nconst char *arg_end = strchr(arg, '=');\r\nconst struct option *abbrev_option = NULL, *ambiguous_option = NULL;\r\nint abbrev_flags = 0, ambiguous_flags = 0;\r\nif (!arg_end)\r\narg_end = arg + strlen(arg);\r\nfor (; options->type != OPTION_END; options++) {\r\nconst char *rest;\r\nint flags = 0;\r\nif (!options->long_name)\r\ncontinue;\r\nrest = skip_prefix(arg, options->long_name);\r\nif (options->type == OPTION_ARGUMENT) {\r\nif (!rest)\r\ncontinue;\r\nif (*rest == '=')\r\nreturn opterror(options, "takes no value", flags);\r\nif (*rest)\r\ncontinue;\r\np->out[p->cpidx++] = arg - 2;\r\nreturn 0;\r\n}\r\nif (!rest) {\r\nif (!strncmp(options->long_name, arg, arg_end - arg)) {\r\nis_abbreviated:\r\nif (abbrev_option) {\r\nambiguous_option = abbrev_option;\r\nambiguous_flags = abbrev_flags;\r\n}\r\nif (!(flags & OPT_UNSET) && *arg_end)\r\np->opt = arg_end + 1;\r\nabbrev_option = options;\r\nabbrev_flags = flags;\r\ncontinue;\r\n}\r\nif (!prefixcmp("no-", arg)) {\r\nflags |= OPT_UNSET;\r\ngoto is_abbreviated;\r\n}\r\nif (strncmp(arg, "no-", 3))\r\ncontinue;\r\nflags |= OPT_UNSET;\r\nrest = skip_prefix(arg + 3, options->long_name);\r\nif (!rest && !prefixcmp(options->long_name, arg + 3))\r\ngoto is_abbreviated;\r\nif (!rest)\r\ncontinue;\r\n}\r\nif (*rest) {\r\nif (*rest != '=')\r\ncontinue;\r\np->opt = rest + 1;\r\n}\r\nreturn get_value(p, options, flags);\r\n}\r\nif (ambiguous_option)\r\nreturn error("Ambiguous option: %s "\r\n"(could be --%s%s or --%s%s)",\r\narg,\r\n(ambiguous_flags & OPT_UNSET) ? "no-" : "",\r\nambiguous_option->long_name,\r\n(abbrev_flags & OPT_UNSET) ? "no-" : "",\r\nabbrev_option->long_name);\r\nif (abbrev_option)\r\nreturn get_value(p, abbrev_option, abbrev_flags);\r\nreturn -2;\r\n}\r\nstatic void check_typos(const char *arg, const struct option *options)\r\n{\r\nif (strlen(arg) < 3)\r\nreturn;\r\nif (!prefixcmp(arg, "no-")) {\r\nerror ("did you mean `--%s` (with two dashes ?)", arg);\r\nexit(129);\r\n}\r\nfor (; options->type != OPTION_END; options++) {\r\nif (!options->long_name)\r\ncontinue;\r\nif (!prefixcmp(options->long_name, arg)) {\r\nerror ("did you mean `--%s` (with two dashes ?)", arg);\r\nexit(129);\r\n}\r\n}\r\n}\r\nvoid parse_options_start(struct parse_opt_ctx_t *ctx,\r\nint argc, const char **argv, int flags)\r\n{\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->argc = argc - 1;\r\nctx->argv = argv + 1;\r\nctx->out = argv;\r\nctx->cpidx = ((flags & PARSE_OPT_KEEP_ARGV0) != 0);\r\nctx->flags = flags;\r\nif ((flags & PARSE_OPT_KEEP_UNKNOWN) &&\r\n(flags & PARSE_OPT_STOP_AT_NON_OPTION))\r\ndie("STOP_AT_NON_OPTION and KEEP_UNKNOWN don't go together");\r\n}\r\nint parse_options_step(struct parse_opt_ctx_t *ctx,\r\nconst struct option *options,\r\nconst char * const usagestr[])\r\n{\r\nint internal_help = !(ctx->flags & PARSE_OPT_NO_INTERNAL_HELP);\r\nctx->opt = NULL;\r\nfor (; ctx->argc; ctx->argc--, ctx->argv++) {\r\nconst char *arg = ctx->argv[0];\r\nif (*arg != '-' || !arg[1]) {\r\nif (ctx->flags & PARSE_OPT_STOP_AT_NON_OPTION)\r\nbreak;\r\nctx->out[ctx->cpidx++] = ctx->argv[0];\r\ncontinue;\r\n}\r\nif (arg[1] != '-') {\r\nctx->opt = arg + 1;\r\nif (internal_help && *ctx->opt == 'h')\r\nreturn parse_options_usage(usagestr, options);\r\nswitch (parse_short_opt(ctx, options)) {\r\ncase -1:\r\nreturn parse_options_usage(usagestr, options);\r\ncase -2:\r\ngoto unknown;\r\ndefault:\r\nbreak;\r\n}\r\nif (ctx->opt)\r\ncheck_typos(arg + 1, options);\r\nwhile (ctx->opt) {\r\nif (internal_help && *ctx->opt == 'h')\r\nreturn parse_options_usage(usagestr, options);\r\nswitch (parse_short_opt(ctx, options)) {\r\ncase -1:\r\nreturn parse_options_usage(usagestr, options);\r\ncase -2:\r\nctx->argv[0] = strdup(ctx->opt - 1);\r\n*(char *)ctx->argv[0] = '-';\r\ngoto unknown;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ncontinue;\r\n}\r\nif (!arg[2]) {\r\nif (!(ctx->flags & PARSE_OPT_KEEP_DASHDASH)) {\r\nctx->argc--;\r\nctx->argv++;\r\n}\r\nbreak;\r\n}\r\nif (internal_help && !strcmp(arg + 2, "help-all"))\r\nreturn usage_with_options_internal(usagestr, options, 1);\r\nif (internal_help && !strcmp(arg + 2, "help"))\r\nreturn parse_options_usage(usagestr, options);\r\nif (!strcmp(arg + 2, "list-opts"))\r\nreturn PARSE_OPT_LIST;\r\nswitch (parse_long_opt(ctx, arg + 2, options)) {\r\ncase -1:\r\nreturn parse_options_usage(usagestr, options);\r\ncase -2:\r\ngoto unknown;\r\ndefault:\r\nbreak;\r\n}\r\ncontinue;\r\nunknown:\r\nif (!(ctx->flags & PARSE_OPT_KEEP_UNKNOWN))\r\nreturn PARSE_OPT_UNKNOWN;\r\nctx->out[ctx->cpidx++] = ctx->argv[0];\r\nctx->opt = NULL;\r\n}\r\nreturn PARSE_OPT_DONE;\r\n}\r\nint parse_options_end(struct parse_opt_ctx_t *ctx)\r\n{\r\nmemmove(ctx->out + ctx->cpidx, ctx->argv, ctx->argc * sizeof(*ctx->out));\r\nctx->out[ctx->cpidx + ctx->argc] = NULL;\r\nreturn ctx->cpidx + ctx->argc;\r\n}\r\nint parse_options(int argc, const char **argv, const struct option *options,\r\nconst char * const usagestr[], int flags)\r\n{\r\nstruct parse_opt_ctx_t ctx;\r\nperf_header__set_cmdline(argc, argv);\r\nparse_options_start(&ctx, argc, argv, flags);\r\nswitch (parse_options_step(&ctx, options, usagestr)) {\r\ncase PARSE_OPT_HELP:\r\nexit(129);\r\ncase PARSE_OPT_DONE:\r\nbreak;\r\ncase PARSE_OPT_LIST:\r\nwhile (options->type != OPTION_END) {\r\nprintf("--%s ", options->long_name);\r\noptions++;\r\n}\r\nexit(130);\r\ndefault:\r\nif (ctx.argv[0][1] == '-') {\r\nerror("unknown option `%s'", ctx.argv[0] + 2);\r\n} else {\r\nerror("unknown switch `%c'", *ctx.opt);\r\n}\r\nusage_with_options(usagestr, options);\r\n}\r\nreturn parse_options_end(&ctx);\r\n}\r\nint usage_with_options_internal(const char * const *usagestr,\r\nconst struct option *opts, int full)\r\n{\r\nif (!usagestr)\r\nreturn PARSE_OPT_HELP;\r\nfprintf(stderr, "\n usage: %s\n", *usagestr++);\r\nwhile (*usagestr && **usagestr)\r\nfprintf(stderr, " or: %s\n", *usagestr++);\r\nwhile (*usagestr) {\r\nfprintf(stderr, "%s%s\n",\r\n**usagestr ? " " : "",\r\n*usagestr);\r\nusagestr++;\r\n}\r\nif (opts->type != OPTION_GROUP)\r\nfputc('\n', stderr);\r\nfor (; opts->type != OPTION_END; opts++) {\r\nsize_t pos;\r\nint pad;\r\nif (opts->type == OPTION_GROUP) {\r\nfputc('\n', stderr);\r\nif (*opts->help)\r\nfprintf(stderr, "%s\n", opts->help);\r\ncontinue;\r\n}\r\nif (!full && (opts->flags & PARSE_OPT_HIDDEN))\r\ncontinue;\r\npos = fprintf(stderr, " ");\r\nif (opts->short_name)\r\npos += fprintf(stderr, "-%c", opts->short_name);\r\nelse\r\npos += fprintf(stderr, " ");\r\nif (opts->long_name && opts->short_name)\r\npos += fprintf(stderr, ", ");\r\nif (opts->long_name)\r\npos += fprintf(stderr, "--%s", opts->long_name);\r\nswitch (opts->type) {\r\ncase OPTION_ARGUMENT:\r\nbreak;\r\ncase OPTION_LONG:\r\ncase OPTION_U64:\r\ncase OPTION_INTEGER:\r\ncase OPTION_UINTEGER:\r\nif (opts->flags & PARSE_OPT_OPTARG)\r\nif (opts->long_name)\r\npos += fprintf(stderr, "[=<n>]");\r\nelse\r\npos += fprintf(stderr, "[<n>]");\r\nelse\r\npos += fprintf(stderr, " <n>");\r\nbreak;\r\ncase OPTION_CALLBACK:\r\nif (opts->flags & PARSE_OPT_NOARG)\r\nbreak;\r\ncase OPTION_STRING:\r\nif (opts->argh) {\r\nif (opts->flags & PARSE_OPT_OPTARG)\r\nif (opts->long_name)\r\npos += fprintf(stderr, "[=<%s>]", opts->argh);\r\nelse\r\npos += fprintf(stderr, "[<%s>]", opts->argh);\r\nelse\r\npos += fprintf(stderr, " <%s>", opts->argh);\r\n} else {\r\nif (opts->flags & PARSE_OPT_OPTARG)\r\nif (opts->long_name)\r\npos += fprintf(stderr, "[=...]");\r\nelse\r\npos += fprintf(stderr, "[...]");\r\nelse\r\npos += fprintf(stderr, " ...");\r\n}\r\nbreak;\r\ndefault:\r\ncase OPTION_END:\r\ncase OPTION_GROUP:\r\ncase OPTION_BIT:\r\ncase OPTION_BOOLEAN:\r\ncase OPTION_INCR:\r\ncase OPTION_SET_UINT:\r\ncase OPTION_SET_PTR:\r\nbreak;\r\n}\r\nif (pos <= USAGE_OPTS_WIDTH)\r\npad = USAGE_OPTS_WIDTH - pos;\r\nelse {\r\nfputc('\n', stderr);\r\npad = USAGE_OPTS_WIDTH;\r\n}\r\nfprintf(stderr, "%*s%s\n", pad + USAGE_GAP, "", opts->help);\r\n}\r\nfputc('\n', stderr);\r\nreturn PARSE_OPT_HELP;\r\n}\r\nvoid usage_with_options(const char * const *usagestr,\r\nconst struct option *opts)\r\n{\r\nexit_browser(false);\r\nusage_with_options_internal(usagestr, opts, 0);\r\nexit(129);\r\n}\r\nint parse_options_usage(const char * const *usagestr,\r\nconst struct option *opts)\r\n{\r\nreturn usage_with_options_internal(usagestr, opts, 0);\r\n}\r\nint parse_opt_verbosity_cb(const struct option *opt,\r\nconst char *arg __maybe_unused,\r\nint unset)\r\n{\r\nint *target = opt->value;\r\nif (unset)\r\n*target = 0;\r\nelse if (opt->short_name == 'v') {\r\nif (*target >= 0)\r\n(*target)++;\r\nelse\r\n*target = 1;\r\n} else {\r\nif (*target <= 0)\r\n(*target)--;\r\nelse\r\n*target = -1;\r\n}\r\nreturn 0;\r\n}
