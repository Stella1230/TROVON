static u_char tcic_getb(u_char reg)\r\n{\r\nu_char val = inb(tcic_base+reg);\r\nprintk(KERN_DEBUG "tcic_getb(%#lx) = %#x\n", tcic_base+reg, val);\r\nreturn val;\r\n}\r\nstatic u_short tcic_getw(u_char reg)\r\n{\r\nu_short val = inw(tcic_base+reg);\r\nprintk(KERN_DEBUG "tcic_getw(%#lx) = %#x\n", tcic_base+reg, val);\r\nreturn val;\r\n}\r\nstatic void tcic_setb(u_char reg, u_char data)\r\n{\r\nprintk(KERN_DEBUG "tcic_setb(%#lx, %#x)\n", tcic_base+reg, data);\r\noutb(data, tcic_base+reg);\r\n}\r\nstatic void tcic_setw(u_char reg, u_short data)\r\n{\r\nprintk(KERN_DEBUG "tcic_setw(%#lx, %#x)\n", tcic_base+reg, data);\r\noutw(data, tcic_base+reg);\r\n}\r\nstatic void tcic_setl(u_char reg, u_int data)\r\n{\r\n#ifdef DEBUG_X\r\nprintk(KERN_DEBUG "tcic_setl(%#x, %#lx)\n", tcic_base+reg, data);\r\n#endif\r\noutw(data & 0xffff, tcic_base+reg);\r\noutw(data >> 16, tcic_base+reg+2);\r\n}\r\nstatic void tcic_aux_setb(u_short reg, u_char data)\r\n{\r\nu_char mode = (tcic_getb(TCIC_MODE) & TCIC_MODE_PGMMASK) | reg;\r\ntcic_setb(TCIC_MODE, mode);\r\ntcic_setb(TCIC_AUX, data);\r\n}\r\nstatic u_short tcic_aux_getw(u_short reg)\r\n{\r\nu_char mode = (tcic_getb(TCIC_MODE) & TCIC_MODE_PGMMASK) | reg;\r\ntcic_setb(TCIC_MODE, mode);\r\nreturn tcic_getw(TCIC_AUX);\r\n}\r\nstatic void tcic_aux_setw(u_short reg, u_short data)\r\n{\r\nu_char mode = (tcic_getb(TCIC_MODE) & TCIC_MODE_PGMMASK) | reg;\r\ntcic_setb(TCIC_MODE, mode);\r\ntcic_setw(TCIC_AUX, data);\r\n}\r\nstatic int to_cycles(int ns)\r\n{\r\nif (ns < 14)\r\nreturn 0;\r\nelse\r\nreturn 2*(ns-14)/cycle_time;\r\n}\r\nstatic irqreturn_t __init tcic_irq_count(int irq, void *dev)\r\n{\r\nirq_hits++;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u_int __init try_irq(int irq)\r\n{\r\nu_short cfg;\r\nirq_hits = 0;\r\nif (request_irq(irq, tcic_irq_count, 0, "irq scan", tcic_irq_count) != 0)\r\nreturn -1;\r\nmdelay(10);\r\nif (irq_hits) {\r\nfree_irq(irq, tcic_irq_count);\r\nreturn -1;\r\n}\r\ncfg = TCIC_SYSCFG_AUTOBUSY | 0x0a00;\r\ntcic_aux_setw(TCIC_AUX_SYSCFG, cfg | TCIC_IRQ(irq));\r\ntcic_setb(TCIC_IENA, TCIC_IENA_ERR | TCIC_IENA_CFG_HIGH);\r\ntcic_setb(TCIC_ICSR, TCIC_ICSR_ERR | TCIC_ICSR_JAM);\r\nudelay(1000);\r\nfree_irq(irq, tcic_irq_count);\r\ntcic_setb(TCIC_IENA, TCIC_IENA_CFG_OFF);\r\nwhile (tcic_getb(TCIC_ICSR))\r\ntcic_setb(TCIC_ICSR, TCIC_ICSR_JAM);\r\ntcic_aux_setw(TCIC_AUX_SYSCFG, cfg);\r\nreturn (irq_hits != 1);\r\n}\r\nstatic u_int __init irq_scan(u_int mask0)\r\n{\r\nu_int mask1;\r\nint i;\r\n#ifdef __alpha__\r\n#define PIC 0x4d0\r\nint level_mask = inb_p(PIC) | (inb_p(PIC+1) << 8);\r\nif (level_mask)\r\nmask0 &= ~level_mask;\r\n#endif\r\nmask1 = 0;\r\nif (do_scan) {\r\nfor (i = 0; i < 16; i++)\r\nif ((mask0 & (1 << i)) && (try_irq(i) == 0))\r\nmask1 |= (1 << i);\r\nfor (i = 0; i < 16; i++)\r\nif ((mask1 & (1 << i)) && (try_irq(i) != 0)) {\r\nmask1 ^= (1 << i);\r\n}\r\n}\r\nif (mask1) {\r\nprintk("scanned");\r\n} else {\r\nfor (i = 0; i < 16; i++)\r\nif ((mask0 & (1 << i)) &&\r\n(request_irq(i, tcic_irq_count, 0, "x", tcic_irq_count) == 0)) {\r\nmask1 |= (1 << i);\r\nfree_irq(i, tcic_irq_count);\r\n}\r\nprintk("default");\r\n}\r\nprintk(") = ");\r\nfor (i = 0; i < 16; i++)\r\nif (mask1 & (1<<i))\r\nprintk("%s%d", ((mask1 & ((1<<i)-1)) ? "," : ""), i);\r\nprintk(" ");\r\nreturn mask1;\r\n}\r\nstatic int __init is_active(int s)\r\n{\r\nu_short scf1, ioctl, base, num;\r\nu_char pwr, sstat;\r\nu_int addr;\r\ntcic_setl(TCIC_ADDR, (s << TCIC_ADDR_SS_SHFT)\r\n| TCIC_ADDR_INDREG | TCIC_SCF1(s));\r\nscf1 = tcic_getw(TCIC_DATA);\r\npwr = tcic_getb(TCIC_PWR);\r\nsstat = tcic_getb(TCIC_SSTAT);\r\naddr = TCIC_IWIN(s, 0);\r\ntcic_setw(TCIC_ADDR, addr + TCIC_IBASE_X);\r\nbase = tcic_getw(TCIC_DATA);\r\ntcic_setw(TCIC_ADDR, addr + TCIC_ICTL_X);\r\nioctl = tcic_getw(TCIC_DATA);\r\nif (ioctl & TCIC_ICTL_TINY)\r\nnum = 1;\r\nelse {\r\nnum = (base ^ (base-1));\r\nbase = base & (base-1);\r\n}\r\nif ((sstat & TCIC_SSTAT_CD) && (pwr & TCIC_PWR_VCC(s)) &&\r\n(scf1 & TCIC_SCF1_IOSTS) && (ioctl & TCIC_ICTL_ENA) &&\r\n((base & 0xfeef) != 0x02e8)) {\r\nstruct resource *res = request_region(base, num, "tcic-2");\r\nif (!res)\r\nreturn 1;\r\nrelease_region(base, num);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init get_tcic_id(void)\r\n{\r\nu_short id;\r\ntcic_aux_setw(TCIC_AUX_TEST, TCIC_TEST_DIAG);\r\nid = tcic_aux_getw(TCIC_AUX_ILOCK);\r\nid = (id & TCIC_ILOCKTEST_ID_MASK) >> TCIC_ILOCKTEST_ID_SH;\r\ntcic_aux_setw(TCIC_AUX_TEST, 0);\r\nreturn id;\r\n}\r\nstatic int __init init_tcic(void)\r\n{\r\nint i, sock, ret = 0;\r\nu_int mask, scan;\r\nif (platform_driver_register(&tcic_driver))\r\nreturn -1;\r\nprintk(KERN_INFO "Databook TCIC-2 PCMCIA probe: ");\r\nsock = 0;\r\nif (!request_region(tcic_base, 16, "tcic-2")) {\r\nprintk("could not allocate ports,\n ");\r\nplatform_driver_unregister(&tcic_driver);\r\nreturn -ENODEV;\r\n}\r\nelse {\r\ntcic_setw(TCIC_ADDR, 0);\r\nif (tcic_getw(TCIC_ADDR) == 0) {\r\ntcic_setw(TCIC_ADDR, 0xc3a5);\r\nif (tcic_getw(TCIC_ADDR) == 0xc3a5) sock = 2;\r\n}\r\nif (sock == 0) {\r\ntcic_setb(TCIC_SCTRL, TCIC_SCTRL_RESET);\r\ntcic_setb(TCIC_SCTRL, 0);\r\ntcic_setw(TCIC_ADDR, 0);\r\nif (tcic_getw(TCIC_ADDR) == 0) {\r\ntcic_setw(TCIC_ADDR, 0xc3a5);\r\nif (tcic_getw(TCIC_ADDR) == 0xc3a5) sock = 2;\r\n}\r\n}\r\n}\r\nif (sock == 0) {\r\nprintk("not found.\n");\r\nrelease_region(tcic_base, 16);\r\nplatform_driver_unregister(&tcic_driver);\r\nreturn -ENODEV;\r\n}\r\nsockets = 0;\r\nfor (i = 0; i < sock; i++) {\r\nif ((i == ignore) || is_active(i)) continue;\r\nsocket_table[sockets].psock = i;\r\nsocket_table[sockets].id = get_tcic_id();\r\nsocket_table[sockets].socket.owner = THIS_MODULE;\r\nsocket_table[sockets].socket.features = SS_CAP_PCCARD | SS_CAP_MEM_ALIGN;\r\nsocket_table[sockets].socket.irq_mask = 0x4cf8;\r\nsocket_table[sockets].socket.map_size = 0x1000;\r\nsockets++;\r\n}\r\nswitch (socket_table[0].id) {\r\ncase TCIC_ID_DB86082:\r\nprintk("DB86082"); break;\r\ncase TCIC_ID_DB86082A:\r\nprintk("DB86082A"); break;\r\ncase TCIC_ID_DB86084:\r\nprintk("DB86084"); break;\r\ncase TCIC_ID_DB86084A:\r\nprintk("DB86084A"); break;\r\ncase TCIC_ID_DB86072:\r\nprintk("DB86072"); break;\r\ncase TCIC_ID_DB86184:\r\nprintk("DB86184"); break;\r\ncase TCIC_ID_DB86082B:\r\nprintk("DB86082B"); break;\r\ndefault:\r\nprintk("Unknown ID 0x%02x", socket_table[0].id);\r\n}\r\npoll_timer.function = &tcic_timer;\r\npoll_timer.data = 0;\r\ninit_timer(&poll_timer);\r\nprintk(KERN_CONT ", %d sockets\n", sockets);\r\nprintk(KERN_INFO " irq list (");\r\nif (irq_list_count == 0)\r\nmask = irq_mask;\r\nelse\r\nfor (i = mask = 0; i < irq_list_count; i++)\r\nmask |= (1<<irq_list[i]);\r\nmask &= 0x4cf8;\r\nmask = irq_scan(mask);\r\nfor (i=0;i<sockets;i++)\r\nsocket_table[i].socket.irq_mask = mask;\r\nscan = (mask & (mask-1));\r\nif (((scan & (scan-1)) == 0) && (poll_interval == 0))\r\npoll_interval = HZ;\r\nif (poll_interval == 0) {\r\nu_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));\r\nfor (i = 15; i > 0; i--)\r\nif ((cs_mask & (1 << i)) &&\r\n(request_irq(i, tcic_interrupt, 0, "tcic",\r\ntcic_interrupt) == 0))\r\nbreak;\r\ncs_irq = i;\r\nif (cs_irq == 0) poll_interval = HZ;\r\n}\r\nif (socket_table[0].socket.irq_mask & (1 << 11))\r\nprintk("sktirq is irq 11, ");\r\nif (cs_irq != 0)\r\nprintk("status change on irq %d\n", cs_irq);\r\nelse\r\nprintk("polled status, interval = %d ms\n",\r\npoll_interval * 1000 / HZ);\r\nfor (i = 0; i < sockets; i++) {\r\ntcic_setw(TCIC_ADDR+2, socket_table[i].psock << TCIC_SS_SHFT);\r\nsocket_table[i].last_sstat = tcic_getb(TCIC_SSTAT);\r\n}\r\ntcic_interrupt(0, NULL);\r\nplatform_device_register(&tcic_device);\r\nfor (i = 0; i < sockets; i++) {\r\nsocket_table[i].socket.ops = &tcic_operations;\r\nsocket_table[i].socket.resource_ops = &pccard_nonstatic_ops;\r\nsocket_table[i].socket.dev.parent = &tcic_device.dev;\r\nret = pcmcia_register_socket(&socket_table[i].socket);\r\nif (ret && i)\r\npcmcia_unregister_socket(&socket_table[0].socket);\r\n}\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void __exit exit_tcic(void)\r\n{\r\nint i;\r\ndel_timer_sync(&poll_timer);\r\nif (cs_irq != 0) {\r\ntcic_aux_setw(TCIC_AUX_SYSCFG, TCIC_SYSCFG_AUTOBUSY|0x0a00);\r\nfree_irq(cs_irq, tcic_interrupt);\r\n}\r\nrelease_region(tcic_base, 16);\r\nfor (i = 0; i < sockets; i++) {\r\npcmcia_unregister_socket(&socket_table[i].socket);\r\n}\r\nplatform_device_unregister(&tcic_device);\r\nplatform_driver_unregister(&tcic_driver);\r\n}\r\nstatic irqreturn_t tcic_interrupt(int irq, void *dev)\r\n{\r\nint i, quick = 0;\r\nu_char latch, sstat;\r\nu_short psock;\r\nu_int events;\r\nstatic volatile int active = 0;\r\nif (active) {\r\nprintk(KERN_NOTICE "tcic: reentered interrupt handler!\n");\r\nreturn IRQ_NONE;\r\n} else\r\nactive = 1;\r\npr_debug("tcic_interrupt()\n");\r\nfor (i = 0; i < sockets; i++) {\r\npsock = socket_table[i].psock;\r\ntcic_setl(TCIC_ADDR, (psock << TCIC_ADDR_SS_SHFT)\r\n| TCIC_ADDR_INDREG | TCIC_SCF1(psock));\r\nsstat = tcic_getb(TCIC_SSTAT);\r\nlatch = sstat ^ socket_table[psock].last_sstat;\r\nsocket_table[i].last_sstat = sstat;\r\nif (tcic_getb(TCIC_ICSR) & TCIC_ICSR_CDCHG) {\r\ntcic_setb(TCIC_ICSR, TCIC_ICSR_CLEAR);\r\nquick = 1;\r\n}\r\nif (latch == 0)\r\ncontinue;\r\nevents = (latch & TCIC_SSTAT_CD) ? SS_DETECT : 0;\r\nevents |= (latch & TCIC_SSTAT_WP) ? SS_WRPROT : 0;\r\nif (tcic_getw(TCIC_DATA) & TCIC_SCF1_IOSTS) {\r\nevents |= (latch & TCIC_SSTAT_LBAT1) ? SS_STSCHG : 0;\r\n} else {\r\nevents |= (latch & TCIC_SSTAT_RDY) ? SS_READY : 0;\r\nevents |= (latch & TCIC_SSTAT_LBAT1) ? SS_BATDEAD : 0;\r\nevents |= (latch & TCIC_SSTAT_LBAT2) ? SS_BATWARN : 0;\r\n}\r\nif (events) {\r\npcmcia_parse_events(&socket_table[i].socket, events);\r\n}\r\n}\r\nif (((cs_irq == 0) || quick) && (!tcic_timer_pending)) {\r\npoll_timer.expires = jiffies + (quick ? poll_quick : poll_interval);\r\nadd_timer(&poll_timer);\r\ntcic_timer_pending = 1;\r\n}\r\nactive = 0;\r\npr_debug("interrupt done\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tcic_timer(u_long data)\r\n{\r\npr_debug("tcic_timer()\n");\r\ntcic_timer_pending = 0;\r\ntcic_interrupt(0, NULL);\r\n}\r\nstatic int tcic_get_status(struct pcmcia_socket *sock, u_int *value)\r\n{\r\nu_short psock = container_of(sock, struct tcic_socket, socket)->psock;\r\nu_char reg;\r\ntcic_setl(TCIC_ADDR, (psock << TCIC_ADDR_SS_SHFT)\r\n| TCIC_ADDR_INDREG | TCIC_SCF1(psock));\r\nreg = tcic_getb(TCIC_SSTAT);\r\n*value = (reg & TCIC_SSTAT_CD) ? SS_DETECT : 0;\r\n*value |= (reg & TCIC_SSTAT_WP) ? SS_WRPROT : 0;\r\nif (tcic_getw(TCIC_DATA) & TCIC_SCF1_IOSTS) {\r\n*value |= (reg & TCIC_SSTAT_LBAT1) ? SS_STSCHG : 0;\r\n} else {\r\n*value |= (reg & TCIC_SSTAT_RDY) ? SS_READY : 0;\r\n*value |= (reg & TCIC_SSTAT_LBAT1) ? SS_BATDEAD : 0;\r\n*value |= (reg & TCIC_SSTAT_LBAT2) ? SS_BATWARN : 0;\r\n}\r\nreg = tcic_getb(TCIC_PWR);\r\nif (reg & (TCIC_PWR_VCC(psock)|TCIC_PWR_VPP(psock)))\r\n*value |= SS_POWERON;\r\ndev_dbg(&sock->dev, "GetStatus(%d) = %#2.2x\n", psock, *value);\r\nreturn 0;\r\n}\r\nstatic int tcic_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\r\n{\r\nu_short psock = container_of(sock, struct tcic_socket, socket)->psock;\r\nu_char reg;\r\nu_short scf1, scf2;\r\ndev_dbg(&sock->dev, "SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "\r\n"io_irq %d, csc_mask %#2.2x)\n", psock, state->flags,\r\nstate->Vcc, state->Vpp, state->io_irq, state->csc_mask);\r\ntcic_setw(TCIC_ADDR+2, (psock << TCIC_SS_SHFT) | TCIC_ADR2_INDREG);\r\nreg = tcic_getb(TCIC_PWR);\r\nreg &= ~(TCIC_PWR_VCC(psock) | TCIC_PWR_VPP(psock));\r\nif (state->Vcc == 50) {\r\nswitch (state->Vpp) {\r\ncase 0: reg |= TCIC_PWR_VCC(psock) | TCIC_PWR_VPP(psock); break;\r\ncase 50: reg |= TCIC_PWR_VCC(psock); break;\r\ncase 120: reg |= TCIC_PWR_VPP(psock); break;\r\ndefault: return -EINVAL;\r\n}\r\n} else if (state->Vcc != 0)\r\nreturn -EINVAL;\r\nif (reg != tcic_getb(TCIC_PWR))\r\ntcic_setb(TCIC_PWR, reg);\r\nreg = TCIC_ILOCK_HOLD_CCLK | TCIC_ILOCK_CWAIT;\r\nif (state->flags & SS_OUTPUT_ENA) {\r\ntcic_setb(TCIC_SCTRL, TCIC_SCTRL_ENA);\r\nreg |= TCIC_ILOCK_CRESENA;\r\n} else\r\ntcic_setb(TCIC_SCTRL, 0);\r\nif (state->flags & SS_RESET)\r\nreg |= TCIC_ILOCK_CRESET;\r\ntcic_aux_setb(TCIC_AUX_ILOCK, reg);\r\ntcic_setw(TCIC_ADDR, TCIC_SCF1(psock));\r\nscf1 = TCIC_SCF1_FINPACK;\r\nscf1 |= TCIC_IRQ(state->io_irq);\r\nif (state->flags & SS_IOCARD) {\r\nscf1 |= TCIC_SCF1_IOSTS;\r\nif (state->flags & SS_SPKR_ENA)\r\nscf1 |= TCIC_SCF1_SPKR;\r\nif (state->flags & SS_DMA_MODE)\r\nscf1 |= TCIC_SCF1_DREQ2 << TCIC_SCF1_DMA_SHIFT;\r\n}\r\ntcic_setw(TCIC_DATA, scf1);\r\nreg = TCIC_WAIT_ASYNC | TCIC_WAIT_SENSE | to_cycles(250);\r\ntcic_aux_setb(TCIC_AUX_WCTL, reg);\r\ntcic_aux_setw(TCIC_AUX_SYSCFG, TCIC_SYSCFG_AUTOBUSY|0x0a00|\r\nTCIC_IRQ(cs_irq));\r\ntcic_setw(TCIC_ADDR, TCIC_SCF2(psock));\r\nscf2 = TCIC_SCF2_MALL;\r\nif (state->csc_mask & SS_DETECT) scf2 &= ~TCIC_SCF2_MCD;\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG) reg &= ~TCIC_SCF2_MLBAT1;\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD) reg &= ~TCIC_SCF2_MLBAT1;\r\nif (state->csc_mask & SS_BATWARN) reg &= ~TCIC_SCF2_MLBAT2;\r\nif (state->csc_mask & SS_READY) reg &= ~TCIC_SCF2_MRDY;\r\n}\r\ntcic_setw(TCIC_DATA, scf2);\r\ntcic_setb(TCIC_IENA, TCIC_IENA_CDCHG | TCIC_IENA_CFG_HIGH);\r\nreturn 0;\r\n}\r\nstatic int tcic_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)\r\n{\r\nu_short psock = container_of(sock, struct tcic_socket, socket)->psock;\r\nu_int addr;\r\nu_short base, len, ioctl;\r\ndev_dbg(&sock->dev, "SetIOMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx-%#llx)\n", psock, io->map, io->flags, io->speed,\r\n(unsigned long long)io->start, (unsigned long long)io->stop);\r\nif ((io->map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||\r\n(io->stop < io->start)) return -EINVAL;\r\ntcic_setw(TCIC_ADDR+2, TCIC_ADR2_INDREG | (psock << TCIC_SS_SHFT));\r\naddr = TCIC_IWIN(psock, io->map);\r\nbase = io->start; len = io->stop - io->start;\r\nif ((len & (len+1)) || (base & len)) return -EINVAL;\r\nbase |= (len+1)>>1;\r\ntcic_setw(TCIC_ADDR, addr + TCIC_IBASE_X);\r\ntcic_setw(TCIC_DATA, base);\r\nioctl = (psock << TCIC_ICTL_SS_SHFT);\r\nioctl |= (len == 0) ? TCIC_ICTL_TINY : 0;\r\nioctl |= (io->flags & MAP_ACTIVE) ? TCIC_ICTL_ENA : 0;\r\nioctl |= to_cycles(io->speed) & TCIC_ICTL_WSCNT_MASK;\r\nif (!(io->flags & MAP_AUTOSZ)) {\r\nioctl |= TCIC_ICTL_QUIET;\r\nioctl |= (io->flags & MAP_16BIT) ? TCIC_ICTL_BW_16 : TCIC_ICTL_BW_8;\r\n}\r\ntcic_setw(TCIC_ADDR, addr + TCIC_ICTL_X);\r\ntcic_setw(TCIC_DATA, ioctl);\r\nreturn 0;\r\n}\r\nstatic int tcic_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *mem)\r\n{\r\nu_short psock = container_of(sock, struct tcic_socket, socket)->psock;\r\nu_short addr, ctl;\r\nu_long base, len, mmap;\r\ndev_dbg(&sock->dev, "SetMemMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx-%#llx, %#x)\n", psock, mem->map, mem->flags,\r\nmem->speed, (unsigned long long)mem->res->start,\r\n(unsigned long long)mem->res->end, mem->card_start);\r\nif ((mem->map > 3) || (mem->card_start > 0x3ffffff) ||\r\n(mem->res->start > 0xffffff) || (mem->res->end > 0xffffff) ||\r\n(mem->res->start > mem->res->end) || (mem->speed > 1000))\r\nreturn -EINVAL;\r\ntcic_setw(TCIC_ADDR+2, TCIC_ADR2_INDREG | (psock << TCIC_SS_SHFT));\r\naddr = TCIC_MWIN(psock, mem->map);\r\nbase = mem->res->start; len = mem->res->end - mem->res->start;\r\nif ((len & (len+1)) || (base & len)) return -EINVAL;\r\nif (len == 0x0fff)\r\nbase = (base >> TCIC_MBASE_HA_SHFT) | TCIC_MBASE_4K_BIT;\r\nelse\r\nbase = (base | (len+1)>>1) >> TCIC_MBASE_HA_SHFT;\r\ntcic_setw(TCIC_ADDR, addr + TCIC_MBASE_X);\r\ntcic_setw(TCIC_DATA, base);\r\nmmap = mem->card_start - mem->res->start;\r\nmmap = (mmap >> TCIC_MMAP_CA_SHFT) & TCIC_MMAP_CA_MASK;\r\nif (mem->flags & MAP_ATTRIB) mmap |= TCIC_MMAP_REG;\r\ntcic_setw(TCIC_ADDR, addr + TCIC_MMAP_X);\r\ntcic_setw(TCIC_DATA, mmap);\r\nctl = TCIC_MCTL_QUIET | (psock << TCIC_MCTL_SS_SHFT);\r\nctl |= to_cycles(mem->speed) & TCIC_MCTL_WSCNT_MASK;\r\nctl |= (mem->flags & MAP_16BIT) ? 0 : TCIC_MCTL_B8;\r\nctl |= (mem->flags & MAP_WRPROT) ? TCIC_MCTL_WP : 0;\r\nctl |= (mem->flags & MAP_ACTIVE) ? TCIC_MCTL_ENA : 0;\r\ntcic_setw(TCIC_ADDR, addr + TCIC_MCTL_X);\r\ntcic_setw(TCIC_DATA, ctl);\r\nreturn 0;\r\n}\r\nstatic int tcic_init(struct pcmcia_socket *s)\r\n{\r\nint i;\r\nstruct resource res = { .start = 0, .end = 0x1000 };\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\npccard_mem_map mem = { .res = &res, };\r\nfor (i = 0; i < 2; i++) {\r\nio.map = i;\r\ntcic_set_io_map(s, &io);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nmem.map = i;\r\ntcic_set_mem_map(s, &mem);\r\n}\r\nreturn 0;\r\n}
