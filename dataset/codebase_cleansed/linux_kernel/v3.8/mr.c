static u32 mlx4_buddy_alloc(struct mlx4_buddy *buddy, int order)\r\n{\r\nint o;\r\nint m;\r\nu32 seg;\r\nspin_lock(&buddy->lock);\r\nfor (o = order; o <= buddy->max_order; ++o)\r\nif (buddy->num_free[o]) {\r\nm = 1 << (buddy->max_order - o);\r\nseg = find_first_bit(buddy->bits[o], m);\r\nif (seg < m)\r\ngoto found;\r\n}\r\nspin_unlock(&buddy->lock);\r\nreturn -1;\r\nfound:\r\nclear_bit(seg, buddy->bits[o]);\r\n--buddy->num_free[o];\r\nwhile (o > order) {\r\n--o;\r\nseg <<= 1;\r\nset_bit(seg ^ 1, buddy->bits[o]);\r\n++buddy->num_free[o];\r\n}\r\nspin_unlock(&buddy->lock);\r\nseg <<= order;\r\nreturn seg;\r\n}\r\nstatic void mlx4_buddy_free(struct mlx4_buddy *buddy, u32 seg, int order)\r\n{\r\nseg >>= order;\r\nspin_lock(&buddy->lock);\r\nwhile (test_bit(seg ^ 1, buddy->bits[order])) {\r\nclear_bit(seg ^ 1, buddy->bits[order]);\r\n--buddy->num_free[order];\r\nseg >>= 1;\r\n++order;\r\n}\r\nset_bit(seg, buddy->bits[order]);\r\n++buddy->num_free[order];\r\nspin_unlock(&buddy->lock);\r\n}\r\nstatic int mlx4_buddy_init(struct mlx4_buddy *buddy, int max_order)\r\n{\r\nint i, s;\r\nbuddy->max_order = max_order;\r\nspin_lock_init(&buddy->lock);\r\nbuddy->bits = kcalloc(buddy->max_order + 1, sizeof (long *),\r\nGFP_KERNEL);\r\nbuddy->num_free = kcalloc((buddy->max_order + 1), sizeof *buddy->num_free,\r\nGFP_KERNEL);\r\nif (!buddy->bits || !buddy->num_free)\r\ngoto err_out;\r\nfor (i = 0; i <= buddy->max_order; ++i) {\r\ns = BITS_TO_LONGS(1 << (buddy->max_order - i));\r\nbuddy->bits[i] = kcalloc(s, sizeof (long), GFP_KERNEL | __GFP_NOWARN);\r\nif (!buddy->bits[i]) {\r\nbuddy->bits[i] = vzalloc(s * sizeof(long));\r\nif (!buddy->bits[i])\r\ngoto err_out_free;\r\n}\r\n}\r\nset_bit(0, buddy->bits[buddy->max_order]);\r\nbuddy->num_free[buddy->max_order] = 1;\r\nreturn 0;\r\nerr_out_free:\r\nfor (i = 0; i <= buddy->max_order; ++i)\r\nif (buddy->bits[i] && is_vmalloc_addr(buddy->bits[i]))\r\nvfree(buddy->bits[i]);\r\nelse\r\nkfree(buddy->bits[i]);\r\nerr_out:\r\nkfree(buddy->bits);\r\nkfree(buddy->num_free);\r\nreturn -ENOMEM;\r\n}\r\nstatic void mlx4_buddy_cleanup(struct mlx4_buddy *buddy)\r\n{\r\nint i;\r\nfor (i = 0; i <= buddy->max_order; ++i)\r\nif (is_vmalloc_addr(buddy->bits[i]))\r\nvfree(buddy->bits[i]);\r\nelse\r\nkfree(buddy->bits[i]);\r\nkfree(buddy->bits);\r\nkfree(buddy->num_free);\r\n}\r\nu32 __mlx4_alloc_mtt_range(struct mlx4_dev *dev, int order)\r\n{\r\nstruct mlx4_mr_table *mr_table = &mlx4_priv(dev)->mr_table;\r\nu32 seg;\r\nint seg_order;\r\nu32 offset;\r\nseg_order = max_t(int, order - log_mtts_per_seg, 0);\r\nseg = mlx4_buddy_alloc(&mr_table->mtt_buddy, seg_order);\r\nif (seg == -1)\r\nreturn -1;\r\noffset = seg * (1 << log_mtts_per_seg);\r\nif (mlx4_table_get_range(dev, &mr_table->mtt_table, offset,\r\noffset + (1 << order) - 1)) {\r\nmlx4_buddy_free(&mr_table->mtt_buddy, seg, seg_order);\r\nreturn -1;\r\n}\r\nreturn offset;\r\n}\r\nstatic u32 mlx4_alloc_mtt_range(struct mlx4_dev *dev, int order)\r\n{\r\nu64 in_param;\r\nu64 out_param;\r\nint err;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&in_param, order);\r\nerr = mlx4_cmd_imm(dev, in_param, &out_param, RES_MTT,\r\nRES_OP_RESERVE_AND_MAP,\r\nMLX4_CMD_ALLOC_RES,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_WRAPPED);\r\nif (err)\r\nreturn -1;\r\nreturn get_param_l(&out_param);\r\n}\r\nreturn __mlx4_alloc_mtt_range(dev, order);\r\n}\r\nint mlx4_mtt_init(struct mlx4_dev *dev, int npages, int page_shift,\r\nstruct mlx4_mtt *mtt)\r\n{\r\nint i;\r\nif (!npages) {\r\nmtt->order = -1;\r\nmtt->page_shift = MLX4_ICM_PAGE_SHIFT;\r\nreturn 0;\r\n} else\r\nmtt->page_shift = page_shift;\r\nfor (mtt->order = 0, i = 1; i < npages; i <<= 1)\r\n++mtt->order;\r\nmtt->offset = mlx4_alloc_mtt_range(dev, mtt->order);\r\nif (mtt->offset == -1)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid __mlx4_free_mtt_range(struct mlx4_dev *dev, u32 offset, int order)\r\n{\r\nu32 first_seg;\r\nint seg_order;\r\nstruct mlx4_mr_table *mr_table = &mlx4_priv(dev)->mr_table;\r\nseg_order = max_t(int, order - log_mtts_per_seg, 0);\r\nfirst_seg = offset / (1 << log_mtts_per_seg);\r\nmlx4_buddy_free(&mr_table->mtt_buddy, first_seg, seg_order);\r\nmlx4_table_put_range(dev, &mr_table->mtt_table, offset,\r\noffset + (1 << order) - 1);\r\n}\r\nstatic void mlx4_free_mtt_range(struct mlx4_dev *dev, u32 offset, int order)\r\n{\r\nu64 in_param;\r\nint err;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&in_param, offset);\r\nset_param_h(&in_param, order);\r\nerr = mlx4_cmd(dev, in_param, RES_MTT, RES_OP_RESERVE_AND_MAP,\r\nMLX4_CMD_FREE_RES,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_WRAPPED);\r\nif (err)\r\nmlx4_warn(dev, "Failed to free mtt range at:"\r\n"%d order:%d\n", offset, order);\r\nreturn;\r\n}\r\n__mlx4_free_mtt_range(dev, offset, order);\r\n}\r\nvoid mlx4_mtt_cleanup(struct mlx4_dev *dev, struct mlx4_mtt *mtt)\r\n{\r\nif (mtt->order < 0)\r\nreturn;\r\nmlx4_free_mtt_range(dev, mtt->offset, mtt->order);\r\n}\r\nu64 mlx4_mtt_addr(struct mlx4_dev *dev, struct mlx4_mtt *mtt)\r\n{\r\nreturn (u64) mtt->offset * dev->caps.mtt_entry_sz;\r\n}\r\nstatic u32 hw_index_to_key(u32 ind)\r\n{\r\nreturn (ind >> 24) | (ind << 8);\r\n}\r\nstatic u32 key_to_hw_index(u32 key)\r\n{\r\nreturn (key << 24) | (key >> 8);\r\n}\r\nstatic int mlx4_SW2HW_MPT(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\r\nint mpt_index)\r\n{\r\nreturn mlx4_cmd(dev, mailbox->dma, mpt_index,\r\n0, MLX4_CMD_SW2HW_MPT, MLX4_CMD_TIME_CLASS_B,\r\nMLX4_CMD_WRAPPED);\r\n}\r\nstatic int mlx4_HW2SW_MPT(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\r\nint mpt_index)\r\n{\r\nreturn mlx4_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, mpt_index,\r\n!mailbox, MLX4_CMD_HW2SW_MPT,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);\r\n}\r\nstatic int mlx4_mr_alloc_reserved(struct mlx4_dev *dev, u32 mridx, u32 pd,\r\nu64 iova, u64 size, u32 access, int npages,\r\nint page_shift, struct mlx4_mr *mr)\r\n{\r\nmr->iova = iova;\r\nmr->size = size;\r\nmr->pd = pd;\r\nmr->access = access;\r\nmr->enabled = MLX4_MR_DISABLED;\r\nmr->key = hw_index_to_key(mridx);\r\nreturn mlx4_mtt_init(dev, npages, page_shift, &mr->mtt);\r\n}\r\nstatic int mlx4_WRITE_MTT(struct mlx4_dev *dev,\r\nstruct mlx4_cmd_mailbox *mailbox,\r\nint num_entries)\r\n{\r\nreturn mlx4_cmd(dev, mailbox->dma, num_entries, 0, MLX4_CMD_WRITE_MTT,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\r\n}\r\nint __mlx4_mr_reserve(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nreturn mlx4_bitmap_alloc(&priv->mr_table.mpt_bitmap);\r\n}\r\nstatic int mlx4_mr_reserve(struct mlx4_dev *dev)\r\n{\r\nu64 out_param;\r\nif (mlx4_is_mfunc(dev)) {\r\nif (mlx4_cmd_imm(dev, 0, &out_param, RES_MPT, RES_OP_RESERVE,\r\nMLX4_CMD_ALLOC_RES,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED))\r\nreturn -1;\r\nreturn get_param_l(&out_param);\r\n}\r\nreturn __mlx4_mr_reserve(dev);\r\n}\r\nvoid __mlx4_mr_release(struct mlx4_dev *dev, u32 index)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nmlx4_bitmap_free(&priv->mr_table.mpt_bitmap, index);\r\n}\r\nstatic void mlx4_mr_release(struct mlx4_dev *dev, u32 index)\r\n{\r\nu64 in_param;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&in_param, index);\r\nif (mlx4_cmd(dev, in_param, RES_MPT, RES_OP_RESERVE,\r\nMLX4_CMD_FREE_RES,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED))\r\nmlx4_warn(dev, "Failed to release mr index:%d\n",\r\nindex);\r\nreturn;\r\n}\r\n__mlx4_mr_release(dev, index);\r\n}\r\nint __mlx4_mr_alloc_icm(struct mlx4_dev *dev, u32 index)\r\n{\r\nstruct mlx4_mr_table *mr_table = &mlx4_priv(dev)->mr_table;\r\nreturn mlx4_table_get(dev, &mr_table->dmpt_table, index);\r\n}\r\nstatic int mlx4_mr_alloc_icm(struct mlx4_dev *dev, u32 index)\r\n{\r\nu64 param;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&param, index);\r\nreturn mlx4_cmd_imm(dev, param, &param, RES_MPT, RES_OP_MAP_ICM,\r\nMLX4_CMD_ALLOC_RES,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_WRAPPED);\r\n}\r\nreturn __mlx4_mr_alloc_icm(dev, index);\r\n}\r\nvoid __mlx4_mr_free_icm(struct mlx4_dev *dev, u32 index)\r\n{\r\nstruct mlx4_mr_table *mr_table = &mlx4_priv(dev)->mr_table;\r\nmlx4_table_put(dev, &mr_table->dmpt_table, index);\r\n}\r\nstatic void mlx4_mr_free_icm(struct mlx4_dev *dev, u32 index)\r\n{\r\nu64 in_param;\r\nif (mlx4_is_mfunc(dev)) {\r\nset_param_l(&in_param, index);\r\nif (mlx4_cmd(dev, in_param, RES_MPT, RES_OP_MAP_ICM,\r\nMLX4_CMD_FREE_RES, MLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_WRAPPED))\r\nmlx4_warn(dev, "Failed to free icm of mr index:%d\n",\r\nindex);\r\nreturn;\r\n}\r\nreturn __mlx4_mr_free_icm(dev, index);\r\n}\r\nint mlx4_mr_alloc(struct mlx4_dev *dev, u32 pd, u64 iova, u64 size, u32 access,\r\nint npages, int page_shift, struct mlx4_mr *mr)\r\n{\r\nu32 index;\r\nint err;\r\nindex = mlx4_mr_reserve(dev);\r\nif (index == -1)\r\nreturn -ENOMEM;\r\nerr = mlx4_mr_alloc_reserved(dev, index, pd, iova, size,\r\naccess, npages, page_shift, mr);\r\nif (err)\r\nmlx4_mr_release(dev, index);\r\nreturn err;\r\n}\r\nstatic void mlx4_mr_free_reserved(struct mlx4_dev *dev, struct mlx4_mr *mr)\r\n{\r\nint err;\r\nif (mr->enabled == MLX4_MR_EN_HW) {\r\nerr = mlx4_HW2SW_MPT(dev, NULL,\r\nkey_to_hw_index(mr->key) &\r\n(dev->caps.num_mpts - 1));\r\nif (err)\r\nmlx4_warn(dev, "xxx HW2SW_MPT failed (%d)\n", err);\r\nmr->enabled = MLX4_MR_EN_SW;\r\n}\r\nmlx4_mtt_cleanup(dev, &mr->mtt);\r\n}\r\nvoid mlx4_mr_free(struct mlx4_dev *dev, struct mlx4_mr *mr)\r\n{\r\nmlx4_mr_free_reserved(dev, mr);\r\nif (mr->enabled)\r\nmlx4_mr_free_icm(dev, key_to_hw_index(mr->key));\r\nmlx4_mr_release(dev, key_to_hw_index(mr->key));\r\n}\r\nint mlx4_mr_enable(struct mlx4_dev *dev, struct mlx4_mr *mr)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nstruct mlx4_mpt_entry *mpt_entry;\r\nint err;\r\nerr = mlx4_mr_alloc_icm(dev, key_to_hw_index(mr->key));\r\nif (err)\r\nreturn err;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox)) {\r\nerr = PTR_ERR(mailbox);\r\ngoto err_table;\r\n}\r\nmpt_entry = mailbox->buf;\r\nmemset(mpt_entry, 0, sizeof *mpt_entry);\r\nmpt_entry->flags = cpu_to_be32(MLX4_MPT_FLAG_MIO |\r\nMLX4_MPT_FLAG_REGION |\r\nmr->access);\r\nmpt_entry->key = cpu_to_be32(key_to_hw_index(mr->key));\r\nmpt_entry->pd_flags = cpu_to_be32(mr->pd | MLX4_MPT_PD_FLAG_EN_INV);\r\nmpt_entry->start = cpu_to_be64(mr->iova);\r\nmpt_entry->length = cpu_to_be64(mr->size);\r\nmpt_entry->entity_size = cpu_to_be32(mr->mtt.page_shift);\r\nif (mr->mtt.order < 0) {\r\nmpt_entry->flags |= cpu_to_be32(MLX4_MPT_FLAG_PHYSICAL);\r\nmpt_entry->mtt_addr = 0;\r\n} else {\r\nmpt_entry->mtt_addr = cpu_to_be64(mlx4_mtt_addr(dev,\r\n&mr->mtt));\r\n}\r\nif (mr->mtt.order >= 0 && mr->mtt.page_shift == 0) {\r\nmpt_entry->flags |= cpu_to_be32(MLX4_MPT_FLAG_FREE);\r\nmpt_entry->pd_flags |= cpu_to_be32(MLX4_MPT_PD_FLAG_FAST_REG |\r\nMLX4_MPT_PD_FLAG_RAE);\r\nmpt_entry->mtt_sz = cpu_to_be32(1 << mr->mtt.order);\r\n} else {\r\nmpt_entry->flags |= cpu_to_be32(MLX4_MPT_FLAG_SW_OWNS);\r\n}\r\nerr = mlx4_SW2HW_MPT(dev, mailbox,\r\nkey_to_hw_index(mr->key) & (dev->caps.num_mpts - 1));\r\nif (err) {\r\nmlx4_warn(dev, "SW2HW_MPT failed (%d)\n", err);\r\ngoto err_cmd;\r\n}\r\nmr->enabled = MLX4_MR_EN_HW;\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn 0;\r\nerr_cmd:\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nerr_table:\r\nmlx4_mr_free_icm(dev, key_to_hw_index(mr->key));\r\nreturn err;\r\n}\r\nstatic int mlx4_write_mtt_chunk(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\r\nint start_index, int npages, u64 *page_list)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\n__be64 *mtts;\r\ndma_addr_t dma_handle;\r\nint i;\r\nmtts = mlx4_table_find(&priv->mr_table.mtt_table, mtt->offset +\r\nstart_index, &dma_handle);\r\nif (!mtts)\r\nreturn -ENOMEM;\r\ndma_sync_single_for_cpu(&dev->pdev->dev, dma_handle,\r\nnpages * sizeof (u64), DMA_TO_DEVICE);\r\nfor (i = 0; i < npages; ++i)\r\nmtts[i] = cpu_to_be64(page_list[i] | MLX4_MTT_FLAG_PRESENT);\r\ndma_sync_single_for_device(&dev->pdev->dev, dma_handle,\r\nnpages * sizeof (u64), DMA_TO_DEVICE);\r\nreturn 0;\r\n}\r\nint __mlx4_write_mtt(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\r\nint start_index, int npages, u64 *page_list)\r\n{\r\nint err = 0;\r\nint chunk;\r\nint mtts_per_page;\r\nint max_mtts_first_page;\r\nmtts_per_page = PAGE_SIZE / sizeof(u64);\r\nmax_mtts_first_page = mtts_per_page - (mtt->offset + start_index)\r\n% mtts_per_page;\r\nchunk = min_t(int, max_mtts_first_page, npages);\r\nwhile (npages > 0) {\r\nerr = mlx4_write_mtt_chunk(dev, mtt, start_index, chunk, page_list);\r\nif (err)\r\nreturn err;\r\nnpages -= chunk;\r\nstart_index += chunk;\r\npage_list += chunk;\r\nchunk = min_t(int, mtts_per_page, npages);\r\n}\r\nreturn err;\r\n}\r\nint mlx4_write_mtt(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\r\nint start_index, int npages, u64 *page_list)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox = NULL;\r\n__be64 *inbox = NULL;\r\nint chunk;\r\nint err = 0;\r\nint i;\r\nif (mtt->order < 0)\r\nreturn -EINVAL;\r\nif (mlx4_is_mfunc(dev)) {\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ninbox = mailbox->buf;\r\nwhile (npages > 0) {\r\nchunk = min_t(int, MLX4_MAILBOX_SIZE / sizeof(u64) - 2,\r\nnpages);\r\ninbox[0] = cpu_to_be64(mtt->offset + start_index);\r\ninbox[1] = 0;\r\nfor (i = 0; i < chunk; ++i)\r\ninbox[i + 2] = cpu_to_be64(page_list[i] |\r\nMLX4_MTT_FLAG_PRESENT);\r\nerr = mlx4_WRITE_MTT(dev, mailbox, chunk);\r\nif (err) {\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nnpages -= chunk;\r\nstart_index += chunk;\r\npage_list += chunk;\r\n}\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nreturn __mlx4_write_mtt(dev, mtt, start_index, npages, page_list);\r\n}\r\nint mlx4_buf_write_mtt(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\r\nstruct mlx4_buf *buf)\r\n{\r\nu64 *page_list;\r\nint err;\r\nint i;\r\npage_list = kmalloc(buf->npages * sizeof *page_list, GFP_KERNEL);\r\nif (!page_list)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < buf->npages; ++i)\r\nif (buf->nbufs == 1)\r\npage_list[i] = buf->direct.map + (i << buf->page_shift);\r\nelse\r\npage_list[i] = buf->page_list[i].map;\r\nerr = mlx4_write_mtt(dev, mtt, 0, buf->npages, page_list);\r\nkfree(page_list);\r\nreturn err;\r\n}\r\nint mlx4_init_mr_table(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_mr_table *mr_table = &priv->mr_table;\r\nint err;\r\nif (!is_power_of_2(dev->caps.num_mpts))\r\nreturn -EINVAL;\r\nif (mlx4_is_slave(dev))\r\nreturn 0;\r\nerr = mlx4_bitmap_init(&mr_table->mpt_bitmap, dev->caps.num_mpts,\r\n~0, dev->caps.reserved_mrws, 0);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_buddy_init(&mr_table->mtt_buddy,\r\nilog2((u32)dev->caps.num_mtts /\r\n(1 << log_mtts_per_seg)));\r\nif (err)\r\ngoto err_buddy;\r\nif (dev->caps.reserved_mtts) {\r\npriv->reserved_mtts =\r\nmlx4_alloc_mtt_range(dev,\r\nfls(dev->caps.reserved_mtts - 1));\r\nif (priv->reserved_mtts < 0) {\r\nmlx4_warn(dev, "MTT table of order %u is too small.\n",\r\nmr_table->mtt_buddy.max_order);\r\nerr = -ENOMEM;\r\ngoto err_reserve_mtts;\r\n}\r\n}\r\nreturn 0;\r\nerr_reserve_mtts:\r\nmlx4_buddy_cleanup(&mr_table->mtt_buddy);\r\nerr_buddy:\r\nmlx4_bitmap_cleanup(&mr_table->mpt_bitmap);\r\nreturn err;\r\n}\r\nvoid mlx4_cleanup_mr_table(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_mr_table *mr_table = &priv->mr_table;\r\nif (mlx4_is_slave(dev))\r\nreturn;\r\nif (priv->reserved_mtts >= 0)\r\nmlx4_free_mtt_range(dev, priv->reserved_mtts,\r\nfls(dev->caps.reserved_mtts - 1));\r\nmlx4_buddy_cleanup(&mr_table->mtt_buddy);\r\nmlx4_bitmap_cleanup(&mr_table->mpt_bitmap);\r\n}\r\nstatic inline int mlx4_check_fmr(struct mlx4_fmr *fmr, u64 *page_list,\r\nint npages, u64 iova)\r\n{\r\nint i, page_mask;\r\nif (npages > fmr->max_pages)\r\nreturn -EINVAL;\r\npage_mask = (1 << fmr->page_shift) - 1;\r\nif (iova & page_mask)\r\nreturn -EINVAL;\r\nif (0)\r\nfor (i = 0; i < npages; ++i) {\r\nif (page_list[i] & ~page_mask)\r\nreturn -EINVAL;\r\n}\r\nif (fmr->maps >= fmr->max_maps)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint mlx4_map_phys_fmr(struct mlx4_dev *dev, struct mlx4_fmr *fmr, u64 *page_list,\r\nint npages, u64 iova, u32 *lkey, u32 *rkey)\r\n{\r\nu32 key;\r\nint i, err;\r\nerr = mlx4_check_fmr(fmr, page_list, npages, iova);\r\nif (err)\r\nreturn err;\r\n++fmr->maps;\r\nkey = key_to_hw_index(fmr->mr.key);\r\nkey += dev->caps.num_mpts;\r\n*lkey = *rkey = fmr->mr.key = hw_index_to_key(key);\r\n*(u8 *) fmr->mpt = MLX4_MPT_STATUS_SW;\r\nwmb();\r\ndma_sync_single_for_cpu(&dev->pdev->dev, fmr->dma_handle,\r\nnpages * sizeof(u64), DMA_TO_DEVICE);\r\nfor (i = 0; i < npages; ++i)\r\nfmr->mtts[i] = cpu_to_be64(page_list[i] | MLX4_MTT_FLAG_PRESENT);\r\ndma_sync_single_for_device(&dev->pdev->dev, fmr->dma_handle,\r\nnpages * sizeof(u64), DMA_TO_DEVICE);\r\nfmr->mpt->key = cpu_to_be32(key);\r\nfmr->mpt->lkey = cpu_to_be32(key);\r\nfmr->mpt->length = cpu_to_be64(npages * (1ull << fmr->page_shift));\r\nfmr->mpt->start = cpu_to_be64(iova);\r\nwmb();\r\n*(u8 *) fmr->mpt = MLX4_MPT_STATUS_HW;\r\nwmb();\r\nreturn 0;\r\n}\r\nint mlx4_fmr_alloc(struct mlx4_dev *dev, u32 pd, u32 access, int max_pages,\r\nint max_maps, u8 page_shift, struct mlx4_fmr *fmr)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint err = -ENOMEM;\r\nif (max_maps > dev->caps.max_fmr_maps)\r\nreturn -EINVAL;\r\nif (page_shift < (ffs(dev->caps.page_size_cap) - 1) || page_shift >= 32)\r\nreturn -EINVAL;\r\nif (max_pages * sizeof *fmr->mtts > PAGE_SIZE)\r\nreturn -EINVAL;\r\nfmr->page_shift = page_shift;\r\nfmr->max_pages = max_pages;\r\nfmr->max_maps = max_maps;\r\nfmr->maps = 0;\r\nerr = mlx4_mr_alloc(dev, pd, 0, 0, access, max_pages,\r\npage_shift, &fmr->mr);\r\nif (err)\r\nreturn err;\r\nfmr->mtts = mlx4_table_find(&priv->mr_table.mtt_table,\r\nfmr->mr.mtt.offset,\r\n&fmr->dma_handle);\r\nif (!fmr->mtts) {\r\nerr = -ENOMEM;\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nmlx4_mr_free(dev, &fmr->mr);\r\nreturn err;\r\n}\r\nint mlx4_fmr_enable(struct mlx4_dev *dev, struct mlx4_fmr *fmr)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint err;\r\nerr = mlx4_mr_enable(dev, &fmr->mr);\r\nif (err)\r\nreturn err;\r\nfmr->mpt = mlx4_table_find(&priv->mr_table.dmpt_table,\r\nkey_to_hw_index(fmr->mr.key), NULL);\r\nif (!fmr->mpt)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mlx4_fmr_unmap(struct mlx4_dev *dev, struct mlx4_fmr *fmr,\r\nu32 *lkey, u32 *rkey)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nint err;\r\nif (!fmr->maps)\r\nreturn;\r\nfmr->maps = 0;\r\nmailbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(mailbox)) {\r\nerr = PTR_ERR(mailbox);\r\nprintk(KERN_WARNING "mlx4_ib: mlx4_alloc_cmd_mailbox"\r\n" failed (%d)\n", err);\r\nreturn;\r\n}\r\nerr = mlx4_HW2SW_MPT(dev, NULL,\r\nkey_to_hw_index(fmr->mr.key) &\r\n(dev->caps.num_mpts - 1));\r\nmlx4_free_cmd_mailbox(dev, mailbox);\r\nif (err) {\r\nprintk(KERN_WARNING "mlx4_ib: mlx4_HW2SW_MPT failed (%d)\n",\r\nerr);\r\nreturn;\r\n}\r\nfmr->mr.enabled = MLX4_MR_EN_SW;\r\n}\r\nint mlx4_fmr_free(struct mlx4_dev *dev, struct mlx4_fmr *fmr)\r\n{\r\nif (fmr->maps)\r\nreturn -EBUSY;\r\nmlx4_mr_free(dev, &fmr->mr);\r\nfmr->mr.enabled = MLX4_MR_DISABLED;\r\nreturn 0;\r\n}\r\nint mlx4_SYNC_TPT(struct mlx4_dev *dev)\r\n{\r\nreturn mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_SYNC_TPT, 1000,\r\nMLX4_CMD_NATIVE);\r\n}
