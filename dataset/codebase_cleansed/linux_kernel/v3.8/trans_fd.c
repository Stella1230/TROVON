static void p9_mux_poll_stop(struct p9_conn *m)\r\n{\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(m->poll_wait); i++) {\r\nstruct p9_poll_wait *pwait = &m->poll_wait[i];\r\nif (pwait->wait_addr) {\r\nremove_wait_queue(pwait->wait_addr, &pwait->wait);\r\npwait->wait_addr = NULL;\r\n}\r\n}\r\nspin_lock_irqsave(&p9_poll_lock, flags);\r\nlist_del_init(&m->poll_pending_link);\r\nspin_unlock_irqrestore(&p9_poll_lock, flags);\r\n}\r\nstatic void p9_conn_cancel(struct p9_conn *m, int err)\r\n{\r\nstruct p9_req_t *req, *rtmp;\r\nunsigned long flags;\r\nLIST_HEAD(cancel_list);\r\np9_debug(P9_DEBUG_ERROR, "mux %p err %d\n", m, err);\r\nspin_lock_irqsave(&m->client->lock, flags);\r\nif (m->err) {\r\nspin_unlock_irqrestore(&m->client->lock, flags);\r\nreturn;\r\n}\r\nm->err = err;\r\nlist_for_each_entry_safe(req, rtmp, &m->req_list, req_list) {\r\nreq->status = REQ_STATUS_ERROR;\r\nif (!req->t_err)\r\nreq->t_err = err;\r\nlist_move(&req->req_list, &cancel_list);\r\n}\r\nlist_for_each_entry_safe(req, rtmp, &m->unsent_req_list, req_list) {\r\nreq->status = REQ_STATUS_ERROR;\r\nif (!req->t_err)\r\nreq->t_err = err;\r\nlist_move(&req->req_list, &cancel_list);\r\n}\r\nspin_unlock_irqrestore(&m->client->lock, flags);\r\nlist_for_each_entry_safe(req, rtmp, &cancel_list, req_list) {\r\np9_debug(P9_DEBUG_ERROR, "call back req %p\n", req);\r\nlist_del(&req->req_list);\r\np9_client_cb(m->client, req);\r\n}\r\n}\r\nstatic int\r\np9_fd_poll(struct p9_client *client, struct poll_table_struct *pt)\r\n{\r\nint ret, n;\r\nstruct p9_trans_fd *ts = NULL;\r\nif (client && client->status == Connected)\r\nts = client->trans;\r\nif (!ts)\r\nreturn -EREMOTEIO;\r\nif (!ts->rd->f_op || !ts->rd->f_op->poll)\r\nreturn -EIO;\r\nif (!ts->wr->f_op || !ts->wr->f_op->poll)\r\nreturn -EIO;\r\nret = ts->rd->f_op->poll(ts->rd, pt);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ts->rd != ts->wr) {\r\nn = ts->wr->f_op->poll(ts->wr, pt);\r\nif (n < 0)\r\nreturn n;\r\nret = (ret & ~POLLOUT) | (n & ~POLLIN);\r\n}\r\nreturn ret;\r\n}\r\nstatic int p9_fd_read(struct p9_client *client, void *v, int len)\r\n{\r\nint ret;\r\nstruct p9_trans_fd *ts = NULL;\r\nif (client && client->status != Disconnected)\r\nts = client->trans;\r\nif (!ts)\r\nreturn -EREMOTEIO;\r\nif (!(ts->rd->f_flags & O_NONBLOCK))\r\np9_debug(P9_DEBUG_ERROR, "blocking read ...\n");\r\nret = kernel_read(ts->rd, ts->rd->f_pos, v, len);\r\nif (ret <= 0 && ret != -ERESTARTSYS && ret != -EAGAIN)\r\nclient->status = Disconnected;\r\nreturn ret;\r\n}\r\nstatic void p9_read_work(struct work_struct *work)\r\n{\r\nint n, err;\r\nstruct p9_conn *m;\r\nm = container_of(work, struct p9_conn, rq);\r\nif (m->err < 0)\r\nreturn;\r\np9_debug(P9_DEBUG_TRANS, "start mux %p pos %d\n", m, m->rpos);\r\nif (!m->rbuf) {\r\nm->rbuf = m->tmp_buf;\r\nm->rpos = 0;\r\nm->rsize = 7;\r\n}\r\nclear_bit(Rpending, &m->wsched);\r\np9_debug(P9_DEBUG_TRANS, "read mux %p pos %d size: %d = %d\n",\r\nm, m->rpos, m->rsize, m->rsize-m->rpos);\r\nerr = p9_fd_read(m->client, m->rbuf + m->rpos,\r\nm->rsize - m->rpos);\r\np9_debug(P9_DEBUG_TRANS, "mux %p got %d bytes\n", m, err);\r\nif (err == -EAGAIN) {\r\ngoto end_clear;\r\n}\r\nif (err <= 0)\r\ngoto error;\r\nm->rpos += err;\r\nif ((!m->req) && (m->rpos == m->rsize)) {\r\nu16 tag;\r\np9_debug(P9_DEBUG_TRANS, "got new header\n");\r\nn = le32_to_cpu(*(__le32 *) m->rbuf);\r\nif (n >= m->client->msize) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"requested packet size too big: %d\n", n);\r\nerr = -EIO;\r\ngoto error;\r\n}\r\ntag = le16_to_cpu(*(__le16 *) (m->rbuf+5));\r\np9_debug(P9_DEBUG_TRANS,\r\n"mux %p pkt: size: %d bytes tag: %d\n", m, n, tag);\r\nm->req = p9_tag_lookup(m->client, tag);\r\nif (!m->req || (m->req->status != REQ_STATUS_SENT &&\r\nm->req->status != REQ_STATUS_FLSH)) {\r\np9_debug(P9_DEBUG_ERROR, "Unexpected packet tag %d\n",\r\ntag);\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (m->req->rc == NULL) {\r\nm->req->rc = kmalloc(sizeof(struct p9_fcall) +\r\nm->client->msize, GFP_NOFS);\r\nif (!m->req->rc) {\r\nm->req = NULL;\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nm->rbuf = (char *)m->req->rc + sizeof(struct p9_fcall);\r\nmemcpy(m->rbuf, m->tmp_buf, m->rsize);\r\nm->rsize = n;\r\n}\r\nif ((m->req) && (m->rpos == m->rsize)) {\r\np9_debug(P9_DEBUG_TRANS, "got new packet\n");\r\nspin_lock(&m->client->lock);\r\nif (m->req->status != REQ_STATUS_ERROR)\r\nm->req->status = REQ_STATUS_RCVD;\r\nlist_del(&m->req->req_list);\r\nspin_unlock(&m->client->lock);\r\np9_client_cb(m->client, m->req);\r\nm->rbuf = NULL;\r\nm->rpos = 0;\r\nm->rsize = 0;\r\nm->req = NULL;\r\n}\r\nend_clear:\r\nclear_bit(Rworksched, &m->wsched);\r\nif (!list_empty(&m->req_list)) {\r\nif (test_and_clear_bit(Rpending, &m->wsched))\r\nn = POLLIN;\r\nelse\r\nn = p9_fd_poll(m->client, NULL);\r\nif ((n & POLLIN) && !test_and_set_bit(Rworksched, &m->wsched)) {\r\np9_debug(P9_DEBUG_TRANS, "sched read work %p\n", m);\r\nschedule_work(&m->rq);\r\n}\r\n}\r\nreturn;\r\nerror:\r\np9_conn_cancel(m, err);\r\nclear_bit(Rworksched, &m->wsched);\r\n}\r\nstatic int p9_fd_write(struct p9_client *client, void *v, int len)\r\n{\r\nint ret;\r\nmm_segment_t oldfs;\r\nstruct p9_trans_fd *ts = NULL;\r\nif (client && client->status != Disconnected)\r\nts = client->trans;\r\nif (!ts)\r\nreturn -EREMOTEIO;\r\nif (!(ts->wr->f_flags & O_NONBLOCK))\r\np9_debug(P9_DEBUG_ERROR, "blocking write ...\n");\r\noldfs = get_fs();\r\nset_fs(get_ds());\r\nret = vfs_write(ts->wr, (__force void __user *)v, len, &ts->wr->f_pos);\r\nset_fs(oldfs);\r\nif (ret <= 0 && ret != -ERESTARTSYS && ret != -EAGAIN)\r\nclient->status = Disconnected;\r\nreturn ret;\r\n}\r\nstatic void p9_write_work(struct work_struct *work)\r\n{\r\nint n, err;\r\nstruct p9_conn *m;\r\nstruct p9_req_t *req;\r\nm = container_of(work, struct p9_conn, wq);\r\nif (m->err < 0) {\r\nclear_bit(Wworksched, &m->wsched);\r\nreturn;\r\n}\r\nif (!m->wsize) {\r\nspin_lock(&m->client->lock);\r\nif (list_empty(&m->unsent_req_list)) {\r\nclear_bit(Wworksched, &m->wsched);\r\nspin_unlock(&m->client->lock);\r\nreturn;\r\n}\r\nreq = list_entry(m->unsent_req_list.next, struct p9_req_t,\r\nreq_list);\r\nreq->status = REQ_STATUS_SENT;\r\np9_debug(P9_DEBUG_TRANS, "move req %p\n", req);\r\nlist_move_tail(&req->req_list, &m->req_list);\r\nm->wbuf = req->tc->sdata;\r\nm->wsize = req->tc->size;\r\nm->wpos = 0;\r\nspin_unlock(&m->client->lock);\r\n}\r\np9_debug(P9_DEBUG_TRANS, "mux %p pos %d size %d\n",\r\nm, m->wpos, m->wsize);\r\nclear_bit(Wpending, &m->wsched);\r\nerr = p9_fd_write(m->client, m->wbuf + m->wpos, m->wsize - m->wpos);\r\np9_debug(P9_DEBUG_TRANS, "mux %p sent %d bytes\n", m, err);\r\nif (err == -EAGAIN)\r\ngoto end_clear;\r\nif (err < 0)\r\ngoto error;\r\nelse if (err == 0) {\r\nerr = -EREMOTEIO;\r\ngoto error;\r\n}\r\nm->wpos += err;\r\nif (m->wpos == m->wsize)\r\nm->wpos = m->wsize = 0;\r\nend_clear:\r\nclear_bit(Wworksched, &m->wsched);\r\nif (m->wsize || !list_empty(&m->unsent_req_list)) {\r\nif (test_and_clear_bit(Wpending, &m->wsched))\r\nn = POLLOUT;\r\nelse\r\nn = p9_fd_poll(m->client, NULL);\r\nif ((n & POLLOUT) &&\r\n!test_and_set_bit(Wworksched, &m->wsched)) {\r\np9_debug(P9_DEBUG_TRANS, "sched write work %p\n", m);\r\nschedule_work(&m->wq);\r\n}\r\n}\r\nreturn;\r\nerror:\r\np9_conn_cancel(m, err);\r\nclear_bit(Wworksched, &m->wsched);\r\n}\r\nstatic int p9_pollwake(wait_queue_t *wait, unsigned int mode, int sync, void *key)\r\n{\r\nstruct p9_poll_wait *pwait =\r\ncontainer_of(wait, struct p9_poll_wait, wait);\r\nstruct p9_conn *m = pwait->conn;\r\nunsigned long flags;\r\nspin_lock_irqsave(&p9_poll_lock, flags);\r\nif (list_empty(&m->poll_pending_link))\r\nlist_add_tail(&m->poll_pending_link, &p9_poll_pending_list);\r\nspin_unlock_irqrestore(&p9_poll_lock, flags);\r\nschedule_work(&p9_poll_work);\r\nreturn 1;\r\n}\r\nstatic void\r\np9_pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p)\r\n{\r\nstruct p9_conn *m = container_of(p, struct p9_conn, pt);\r\nstruct p9_poll_wait *pwait = NULL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(m->poll_wait); i++) {\r\nif (m->poll_wait[i].wait_addr == NULL) {\r\npwait = &m->poll_wait[i];\r\nbreak;\r\n}\r\n}\r\nif (!pwait) {\r\np9_debug(P9_DEBUG_ERROR, "not enough wait_address slots\n");\r\nreturn;\r\n}\r\npwait->conn = m;\r\npwait->wait_addr = wait_address;\r\ninit_waitqueue_func_entry(&pwait->wait, p9_pollwake);\r\nadd_wait_queue(wait_address, &pwait->wait);\r\n}\r\nstatic struct p9_conn *p9_conn_create(struct p9_client *client)\r\n{\r\nint n;\r\nstruct p9_conn *m;\r\np9_debug(P9_DEBUG_TRANS, "client %p msize %d\n", client, client->msize);\r\nm = kzalloc(sizeof(struct p9_conn), GFP_KERNEL);\r\nif (!m)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&m->mux_list);\r\nm->client = client;\r\nINIT_LIST_HEAD(&m->req_list);\r\nINIT_LIST_HEAD(&m->unsent_req_list);\r\nINIT_WORK(&m->rq, p9_read_work);\r\nINIT_WORK(&m->wq, p9_write_work);\r\nINIT_LIST_HEAD(&m->poll_pending_link);\r\ninit_poll_funcptr(&m->pt, p9_pollwait);\r\nn = p9_fd_poll(client, &m->pt);\r\nif (n & POLLIN) {\r\np9_debug(P9_DEBUG_TRANS, "mux %p can read\n", m);\r\nset_bit(Rpending, &m->wsched);\r\n}\r\nif (n & POLLOUT) {\r\np9_debug(P9_DEBUG_TRANS, "mux %p can write\n", m);\r\nset_bit(Wpending, &m->wsched);\r\n}\r\nreturn m;\r\n}\r\nstatic void p9_poll_mux(struct p9_conn *m)\r\n{\r\nint n;\r\nif (m->err < 0)\r\nreturn;\r\nn = p9_fd_poll(m->client, NULL);\r\nif (n < 0 || n & (POLLERR | POLLHUP | POLLNVAL)) {\r\np9_debug(P9_DEBUG_TRANS, "error mux %p err %d\n", m, n);\r\nif (n >= 0)\r\nn = -ECONNRESET;\r\np9_conn_cancel(m, n);\r\n}\r\nif (n & POLLIN) {\r\nset_bit(Rpending, &m->wsched);\r\np9_debug(P9_DEBUG_TRANS, "mux %p can read\n", m);\r\nif (!test_and_set_bit(Rworksched, &m->wsched)) {\r\np9_debug(P9_DEBUG_TRANS, "sched read work %p\n", m);\r\nschedule_work(&m->rq);\r\n}\r\n}\r\nif (n & POLLOUT) {\r\nset_bit(Wpending, &m->wsched);\r\np9_debug(P9_DEBUG_TRANS, "mux %p can write\n", m);\r\nif ((m->wsize || !list_empty(&m->unsent_req_list)) &&\r\n!test_and_set_bit(Wworksched, &m->wsched)) {\r\np9_debug(P9_DEBUG_TRANS, "sched write work %p\n", m);\r\nschedule_work(&m->wq);\r\n}\r\n}\r\n}\r\nstatic int p9_fd_request(struct p9_client *client, struct p9_req_t *req)\r\n{\r\nint n;\r\nstruct p9_trans_fd *ts = client->trans;\r\nstruct p9_conn *m = ts->conn;\r\np9_debug(P9_DEBUG_TRANS, "mux %p task %p tcall %p id %d\n",\r\nm, current, req->tc, req->tc->id);\r\nif (m->err < 0)\r\nreturn m->err;\r\nspin_lock(&client->lock);\r\nreq->status = REQ_STATUS_UNSENT;\r\nlist_add_tail(&req->req_list, &m->unsent_req_list);\r\nspin_unlock(&client->lock);\r\nif (test_and_clear_bit(Wpending, &m->wsched))\r\nn = POLLOUT;\r\nelse\r\nn = p9_fd_poll(m->client, NULL);\r\nif (n & POLLOUT && !test_and_set_bit(Wworksched, &m->wsched))\r\nschedule_work(&m->wq);\r\nreturn 0;\r\n}\r\nstatic int p9_fd_cancel(struct p9_client *client, struct p9_req_t *req)\r\n{\r\nint ret = 1;\r\np9_debug(P9_DEBUG_TRANS, "client %p req %p\n", client, req);\r\nspin_lock(&client->lock);\r\nif (req->status == REQ_STATUS_UNSENT) {\r\nlist_del(&req->req_list);\r\nreq->status = REQ_STATUS_FLSHD;\r\nret = 0;\r\n} else if (req->status == REQ_STATUS_SENT)\r\nreq->status = REQ_STATUS_FLSH;\r\nspin_unlock(&client->lock);\r\nreturn ret;\r\n}\r\nstatic int parse_opts(char *params, struct p9_fd_opts *opts)\r\n{\r\nchar *p;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint option;\r\nchar *options, *tmp_options;\r\nopts->port = P9_PORT;\r\nopts->rfd = ~0;\r\nopts->wfd = ~0;\r\nif (!params)\r\nreturn 0;\r\ntmp_options = kstrdup(params, GFP_KERNEL);\r\nif (!tmp_options) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"failed to allocate copy of option string\n");\r\nreturn -ENOMEM;\r\n}\r\noptions = tmp_options;\r\nwhile ((p = strsep(&options, ",")) != NULL) {\r\nint token;\r\nint r;\r\nif (!*p)\r\ncontinue;\r\ntoken = match_token(p, tokens, args);\r\nif (token != Opt_err) {\r\nr = match_int(&args[0], &option);\r\nif (r < 0) {\r\np9_debug(P9_DEBUG_ERROR,\r\n"integer field, but no integer?\n");\r\ncontinue;\r\n}\r\n}\r\nswitch (token) {\r\ncase Opt_port:\r\nopts->port = option;\r\nbreak;\r\ncase Opt_rfdno:\r\nopts->rfd = option;\r\nbreak;\r\ncase Opt_wfdno:\r\nopts->wfd = option;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nkfree(tmp_options);\r\nreturn 0;\r\n}\r\nstatic int p9_fd_open(struct p9_client *client, int rfd, int wfd)\r\n{\r\nstruct p9_trans_fd *ts = kmalloc(sizeof(struct p9_trans_fd),\r\nGFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nts->rd = fget(rfd);\r\nts->wr = fget(wfd);\r\nif (!ts->rd || !ts->wr) {\r\nif (ts->rd)\r\nfput(ts->rd);\r\nif (ts->wr)\r\nfput(ts->wr);\r\nkfree(ts);\r\nreturn -EIO;\r\n}\r\nclient->trans = ts;\r\nclient->status = Connected;\r\nreturn 0;\r\n}\r\nstatic int p9_socket_open(struct p9_client *client, struct socket *csocket)\r\n{\r\nstruct p9_trans_fd *p;\r\nstruct file *file;\r\nint ret;\r\np = kmalloc(sizeof(struct p9_trans_fd), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\ncsocket->sk->sk_allocation = GFP_NOIO;\r\nfile = sock_alloc_file(csocket, 0, NULL);\r\nif (IS_ERR(file)) {\r\npr_err("%s (%d): failed to map fd\n",\r\n__func__, task_pid_nr(current));\r\nsock_release(csocket);\r\nkfree(p);\r\nreturn PTR_ERR(file);\r\n}\r\nget_file(file);\r\np->wr = p->rd = file;\r\nclient->trans = p;\r\nclient->status = Connected;\r\np->rd->f_flags |= O_NONBLOCK;\r\np->conn = p9_conn_create(client);\r\nif (IS_ERR(p->conn)) {\r\nret = PTR_ERR(p->conn);\r\np->conn = NULL;\r\nkfree(p);\r\nsockfd_put(csocket);\r\nsockfd_put(csocket);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void p9_conn_destroy(struct p9_conn *m)\r\n{\r\np9_debug(P9_DEBUG_TRANS, "mux %p prev %p next %p\n",\r\nm, m->mux_list.prev, m->mux_list.next);\r\np9_mux_poll_stop(m);\r\ncancel_work_sync(&m->rq);\r\ncancel_work_sync(&m->wq);\r\np9_conn_cancel(m, -ECONNRESET);\r\nm->client = NULL;\r\nkfree(m);\r\n}\r\nstatic void p9_fd_close(struct p9_client *client)\r\n{\r\nstruct p9_trans_fd *ts;\r\nif (!client)\r\nreturn;\r\nts = client->trans;\r\nif (!ts)\r\nreturn;\r\nclient->status = Disconnected;\r\np9_conn_destroy(ts->conn);\r\nif (ts->rd)\r\nfput(ts->rd);\r\nif (ts->wr)\r\nfput(ts->wr);\r\nkfree(ts);\r\n}\r\nstatic inline int valid_ipaddr4(const char *buf)\r\n{\r\nint rc, count, in[4];\r\nrc = sscanf(buf, "%d.%d.%d.%d", &in[0], &in[1], &in[2], &in[3]);\r\nif (rc != 4)\r\nreturn -EINVAL;\r\nfor (count = 0; count < 4; count++) {\r\nif (in[count] > 255)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\np9_fd_create_tcp(struct p9_client *client, const char *addr, char *args)\r\n{\r\nint err;\r\nstruct socket *csocket;\r\nstruct sockaddr_in sin_server;\r\nstruct p9_fd_opts opts;\r\nerr = parse_opts(args, &opts);\r\nif (err < 0)\r\nreturn err;\r\nif (valid_ipaddr4(addr) < 0)\r\nreturn -EINVAL;\r\ncsocket = NULL;\r\nsin_server.sin_family = AF_INET;\r\nsin_server.sin_addr.s_addr = in_aton(addr);\r\nsin_server.sin_port = htons(opts.port);\r\nerr = __sock_create(read_pnet(&current->nsproxy->net_ns), PF_INET,\r\nSOCK_STREAM, IPPROTO_TCP, &csocket, 1);\r\nif (err) {\r\npr_err("%s (%d): problem creating socket\n",\r\n__func__, task_pid_nr(current));\r\nreturn err;\r\n}\r\nerr = csocket->ops->connect(csocket,\r\n(struct sockaddr *)&sin_server,\r\nsizeof(struct sockaddr_in), 0);\r\nif (err < 0) {\r\npr_err("%s (%d): problem connecting socket to %s\n",\r\n__func__, task_pid_nr(current), addr);\r\nsock_release(csocket);\r\nreturn err;\r\n}\r\nreturn p9_socket_open(client, csocket);\r\n}\r\nstatic int\r\np9_fd_create_unix(struct p9_client *client, const char *addr, char *args)\r\n{\r\nint err;\r\nstruct socket *csocket;\r\nstruct sockaddr_un sun_server;\r\ncsocket = NULL;\r\nif (strlen(addr) >= UNIX_PATH_MAX) {\r\npr_err("%s (%d): address too long: %s\n",\r\n__func__, task_pid_nr(current), addr);\r\nreturn -ENAMETOOLONG;\r\n}\r\nsun_server.sun_family = PF_UNIX;\r\nstrcpy(sun_server.sun_path, addr);\r\nerr = __sock_create(read_pnet(&current->nsproxy->net_ns), PF_UNIX,\r\nSOCK_STREAM, 0, &csocket, 1);\r\nif (err < 0) {\r\npr_err("%s (%d): problem creating socket\n",\r\n__func__, task_pid_nr(current));\r\nreturn err;\r\n}\r\nerr = csocket->ops->connect(csocket, (struct sockaddr *)&sun_server,\r\nsizeof(struct sockaddr_un) - 1, 0);\r\nif (err < 0) {\r\npr_err("%s (%d): problem connecting socket: %s: %d\n",\r\n__func__, task_pid_nr(current), addr, err);\r\nsock_release(csocket);\r\nreturn err;\r\n}\r\nreturn p9_socket_open(client, csocket);\r\n}\r\nstatic int\r\np9_fd_create(struct p9_client *client, const char *addr, char *args)\r\n{\r\nint err;\r\nstruct p9_fd_opts opts;\r\nstruct p9_trans_fd *p;\r\nparse_opts(args, &opts);\r\nif (opts.rfd == ~0 || opts.wfd == ~0) {\r\npr_err("Insufficient options for proto=fd\n");\r\nreturn -ENOPROTOOPT;\r\n}\r\nerr = p9_fd_open(client, opts.rfd, opts.wfd);\r\nif (err < 0)\r\nreturn err;\r\np = (struct p9_trans_fd *) client->trans;\r\np->conn = p9_conn_create(client);\r\nif (IS_ERR(p->conn)) {\r\nerr = PTR_ERR(p->conn);\r\np->conn = NULL;\r\nfput(p->rd);\r\nfput(p->wr);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void p9_poll_workfn(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\np9_debug(P9_DEBUG_TRANS, "start %p\n", current);\r\nspin_lock_irqsave(&p9_poll_lock, flags);\r\nwhile (!list_empty(&p9_poll_pending_list)) {\r\nstruct p9_conn *conn = list_first_entry(&p9_poll_pending_list,\r\nstruct p9_conn,\r\npoll_pending_link);\r\nlist_del_init(&conn->poll_pending_link);\r\nspin_unlock_irqrestore(&p9_poll_lock, flags);\r\np9_poll_mux(conn);\r\nspin_lock_irqsave(&p9_poll_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&p9_poll_lock, flags);\r\np9_debug(P9_DEBUG_TRANS, "finish\n");\r\n}\r\nint p9_trans_fd_init(void)\r\n{\r\nv9fs_register_trans(&p9_tcp_trans);\r\nv9fs_register_trans(&p9_unix_trans);\r\nv9fs_register_trans(&p9_fd_trans);\r\nreturn 0;\r\n}\r\nvoid p9_trans_fd_exit(void)\r\n{\r\nflush_work(&p9_poll_work);\r\nv9fs_unregister_trans(&p9_tcp_trans);\r\nv9fs_unregister_trans(&p9_unix_trans);\r\nv9fs_unregister_trans(&p9_fd_trans);\r\n}
