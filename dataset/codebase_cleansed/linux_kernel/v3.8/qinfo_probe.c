static long lpddr_get_qinforec_pos(struct map_info *map, char *id_str)\r\n{\r\nint qinfo_lines = ARRAY_SIZE(qinfo_array);\r\nint i;\r\nint bankwidth = map_bankwidth(map) * 8;\r\nint major, minor;\r\nfor (i = 0; i < qinfo_lines; i++) {\r\nif (strcmp(id_str, qinfo_array[i].id_str) == 0) {\r\nmajor = qinfo_array[i].major & ((1 << bankwidth) - 1);\r\nminor = qinfo_array[i].minor & ((1 << bankwidth) - 1);\r\nreturn minor | (major << bankwidth);\r\n}\r\n}\r\nprintk(KERN_ERR"%s qinfo id string is wrong! \n", map->name);\r\nBUG();\r\nreturn -1;\r\n}\r\nstatic uint16_t lpddr_info_query(struct map_info *map, char *id_str)\r\n{\r\nunsigned int dsr, val;\r\nint bits_per_chip = map_bankwidth(map) * 8;\r\nunsigned long adr = lpddr_get_qinforec_pos(map, id_str);\r\nint attempts = 20;\r\nmap_write(map, CMD(LPDDR_INFO_QUERY),\r\nmap->pfow_base + PFOW_COMMAND_CODE);\r\nmap_write(map, CMD(adr & ((1 << bits_per_chip) - 1)),\r\nmap->pfow_base + PFOW_COMMAND_ADDRESS_L);\r\nmap_write(map, CMD(adr >> bits_per_chip),\r\nmap->pfow_base + PFOW_COMMAND_ADDRESS_H);\r\nmap_write(map, CMD(LPDDR_START_EXECUTION),\r\nmap->pfow_base + PFOW_COMMAND_EXECUTE);\r\nwhile ((attempts--) > 0) {\r\ndsr = CMDVAL(map_read(map, map->pfow_base + PFOW_DSR));\r\nif (dsr & DSR_READY_STATUS)\r\nbreak;\r\nudelay(10);\r\n}\r\nval = CMDVAL(map_read(map, map->pfow_base + PFOW_COMMAND_DATA));\r\nreturn val;\r\n}\r\nstatic int lpddr_pfow_present(struct map_info *map, struct lpddr_private *lpddr)\r\n{\r\nmap_word pfow_val[4];\r\npfow_val[0] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_P);\r\npfow_val[1] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_F);\r\npfow_val[2] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_O);\r\npfow_val[3] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_W);\r\nif (!map_word_equal(map, CMD('P'), pfow_val[0]))\r\ngoto out;\r\nif (!map_word_equal(map, CMD('F'), pfow_val[1]))\r\ngoto out;\r\nif (!map_word_equal(map, CMD('O'), pfow_val[2]))\r\ngoto out;\r\nif (!map_word_equal(map, CMD('W'), pfow_val[3]))\r\ngoto out;\r\nreturn 1;\r\nout:\r\nprintk(KERN_WARNING"%s: PFOW string at 0x%lx is not found \n",\r\nmap->name, map->pfow_base);\r\nreturn 0;\r\n}\r\nstatic int lpddr_chip_setup(struct map_info *map, struct lpddr_private *lpddr)\r\n{\r\nlpddr->qinfo = kzalloc(sizeof(struct qinfo_chip), GFP_KERNEL);\r\nif (!lpddr->qinfo) {\r\nprintk(KERN_WARNING "%s: no memory for LPDDR qinfo structure\n",\r\nmap->name);\r\nreturn 0;\r\n}\r\nlpddr->ManufactId = CMDVAL(map_read(map, map->pfow_base + PFOW_MANUFACTURER_ID));\r\nlpddr->DevId = CMDVAL(map_read(map, map->pfow_base + PFOW_DEVICE_ID));\r\nlpddr->qinfo->DevSizeShift = lpddr_info_query(map, "DevSizeShift");\r\nlpddr->qinfo->TotalBlocksNum = lpddr_info_query(map, "TotalBlocksNum");\r\nlpddr->qinfo->BufSizeShift = lpddr_info_query(map, "BufSizeShift");\r\nlpddr->qinfo->HWPartsNum = lpddr_info_query(map, "HWPartsNum");\r\nlpddr->qinfo->UniformBlockSizeShift =\r\nlpddr_info_query(map, "UniformBlockSizeShift");\r\nlpddr->qinfo->SuspEraseSupp = lpddr_info_query(map, "SuspEraseSupp");\r\nlpddr->qinfo->SingleWordProgTime =\r\nlpddr_info_query(map, "SingleWordProgTime");\r\nlpddr->qinfo->ProgBufferTime = lpddr_info_query(map, "ProgBufferTime");\r\nlpddr->qinfo->BlockEraseTime = lpddr_info_query(map, "BlockEraseTime");\r\nreturn 1;\r\n}\r\nstatic struct lpddr_private *lpddr_probe_chip(struct map_info *map)\r\n{\r\nstruct lpddr_private lpddr;\r\nstruct lpddr_private *retlpddr;\r\nint numvirtchips;\r\nif ((map->pfow_base + 0x1000) >= map->size) {\r\nprintk(KERN_NOTICE"%s Probe at base (0x%08lx) past the end of"\r\n"the map(0x%08lx)\n", map->name,\r\n(unsigned long)map->pfow_base, map->size - 1);\r\nreturn NULL;\r\n}\r\nmemset(&lpddr, 0, sizeof(struct lpddr_private));\r\nif (!lpddr_pfow_present(map, &lpddr))\r\nreturn NULL;\r\nif (!lpddr_chip_setup(map, &lpddr))\r\nreturn NULL;\r\nlpddr.chipshift = lpddr.qinfo->DevSizeShift;\r\nlpddr.numchips = 1;\r\nnumvirtchips = lpddr.numchips * lpddr.qinfo->HWPartsNum;\r\nretlpddr = kzalloc(sizeof(struct lpddr_private) +\r\nnumvirtchips * sizeof(struct flchip), GFP_KERNEL);\r\nif (!retlpddr)\r\nreturn NULL;\r\nmemcpy(retlpddr, &lpddr, sizeof(struct lpddr_private));\r\nretlpddr->numchips = numvirtchips;\r\nretlpddr->chipshift = retlpddr->qinfo->DevSizeShift -\r\n__ffs(retlpddr->qinfo->HWPartsNum);\r\nreturn retlpddr;\r\n}\r\nstruct mtd_info *lpddr_probe(struct map_info *map)\r\n{\r\nstruct mtd_info *mtd = NULL;\r\nstruct lpddr_private *lpddr;\r\nlpddr = lpddr_probe_chip(map);\r\nif (!lpddr)\r\nreturn NULL;\r\nmap->fldrv_priv = lpddr;\r\nmtd = lpddr_cmdset(map);\r\nif (mtd) {\r\nif (mtd->size > map->size) {\r\nprintk(KERN_WARNING "Reducing visibility of %ldKiB chip"\r\n"to %ldKiB\n", (unsigned long)mtd->size >> 10,\r\n(unsigned long)map->size >> 10);\r\nmtd->size = map->size;\r\n}\r\nreturn mtd;\r\n}\r\nkfree(lpddr->qinfo);\r\nkfree(lpddr);\r\nmap->fldrv_priv = NULL;\r\nreturn NULL;\r\n}\r\nstatic int __init lpddr_probe_init(void)\r\n{\r\nregister_mtd_chip_driver(&lpddr_chipdrv);\r\nreturn 0;\r\n}\r\nstatic void __exit lpddr_probe_exit(void)\r\n{\r\nunregister_mtd_chip_driver(&lpddr_chipdrv);\r\n}
