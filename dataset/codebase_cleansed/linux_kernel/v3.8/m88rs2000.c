static int m88rs2000_writereg(struct m88rs2000_state *state, u8 tuner,\r\nu8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 addr = (tuner == 0) ? state->config->tuner_addr :\r\nstate->config->demod_addr;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = addr,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndeb_info("%s: writereg error (reg == 0x%02x, val == 0x%02x, "\r\n"ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic int m88rs2000_demod_write(struct m88rs2000_state *state, u8 reg, u8 data)\r\n{\r\nreturn m88rs2000_writereg(state, 1, reg, data);\r\n}\r\nstatic int m88rs2000_tuner_write(struct m88rs2000_state *state, u8 reg, u8 data)\r\n{\r\nm88rs2000_demod_write(state, 0x81, 0x84);\r\nudelay(10);\r\nreturn m88rs2000_writereg(state, 0, reg, data);\r\n}\r\nstatic int m88rs2000_write(struct dvb_frontend *fe, const u8 buf[], int len)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nif (len != 2)\r\nreturn -EINVAL;\r\nreturn m88rs2000_writereg(state, 1, buf[0], buf[1]);\r\n}\r\nstatic u8 m88rs2000_readreg(struct m88rs2000_state *state, u8 tuner, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nu8 addr = (tuner == 0) ? state->config->tuner_addr :\r\nstate->config->demod_addr;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = addr,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n}, {\r\n.addr = addr,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\ndeb_info("%s: readreg error (reg == 0x%02x, ret == %i)\n",\r\n__func__, reg, ret);\r\nreturn b1[0];\r\n}\r\nstatic u8 m88rs2000_demod_read(struct m88rs2000_state *state, u8 reg)\r\n{\r\nreturn m88rs2000_readreg(state, 1, reg);\r\n}\r\nstatic u8 m88rs2000_tuner_read(struct m88rs2000_state *state, u8 reg)\r\n{\r\nm88rs2000_demod_write(state, 0x81, 0x85);\r\nudelay(10);\r\nreturn m88rs2000_readreg(state, 0, reg);\r\n}\r\nstatic int m88rs2000_set_symbolrate(struct dvb_frontend *fe, u32 srate)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\nu32 temp;\r\nu8 b[3];\r\nif ((srate < 1000000) || (srate > 45000000))\r\nreturn -EINVAL;\r\ntemp = srate / 1000;\r\ntemp *= 11831;\r\ntemp /= 68;\r\ntemp -= 3;\r\nb[0] = (u8) (temp >> 16) & 0xff;\r\nb[1] = (u8) (temp >> 8) & 0xff;\r\nb[2] = (u8) temp & 0xff;\r\nret = m88rs2000_demod_write(state, 0x93, b[2]);\r\nret |= m88rs2000_demod_write(state, 0x94, b[1]);\r\nret |= m88rs2000_demod_write(state, 0x95, b[0]);\r\ndeb_info("m88rs2000: m88rs2000_set_symbolrate\n");\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *m)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 reg;\r\ndeb_info("%s\n", __func__);\r\nm88rs2000_demod_write(state, 0x9a, 0x30);\r\nreg = m88rs2000_demod_read(state, 0xb2);\r\nreg &= 0x3f;\r\nm88rs2000_demod_write(state, 0xb2, reg);\r\nfor (i = 0; i < m->msg_len; i++)\r\nm88rs2000_demod_write(state, 0xb3 + i, m->msg[i]);\r\nreg = m88rs2000_demod_read(state, 0xb1);\r\nreg &= 0x87;\r\nreg |= ((m->msg_len - 1) << 3) | 0x07;\r\nreg &= 0x7f;\r\nm88rs2000_demod_write(state, 0xb1, reg);\r\nfor (i = 0; i < 15; i++) {\r\nif ((m88rs2000_demod_read(state, 0xb1) & 0x40) == 0x0)\r\nbreak;\r\nmsleep(20);\r\n}\r\nreg = m88rs2000_demod_read(state, 0xb1);\r\nif ((reg & 0x40) > 0x0) {\r\nreg &= 0x7f;\r\nreg |= 0x40;\r\nm88rs2000_demod_write(state, 0xb1, reg);\r\n}\r\nreg = m88rs2000_demod_read(state, 0xb2);\r\nreg &= 0x3f;\r\nreg |= 0x80;\r\nm88rs2000_demod_write(state, 0xb2, reg);\r\nm88rs2000_demod_write(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_send_diseqc_burst(struct dvb_frontend *fe,\r\nfe_sec_mini_cmd_t burst)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 reg0, reg1;\r\ndeb_info("%s\n", __func__);\r\nm88rs2000_demod_write(state, 0x9a, 0x30);\r\nmsleep(50);\r\nreg0 = m88rs2000_demod_read(state, 0xb1);\r\nreg1 = m88rs2000_demod_read(state, 0xb2);\r\nm88rs2000_demod_write(state, 0xb2, reg1);\r\nm88rs2000_demod_write(state, 0xb1, reg0);\r\nm88rs2000_demod_write(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 reg0, reg1;\r\nm88rs2000_demod_write(state, 0x9a, 0x30);\r\nreg0 = m88rs2000_demod_read(state, 0xb1);\r\nreg1 = m88rs2000_demod_read(state, 0xb2);\r\nreg1 &= 0x3f;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nreg0 |= 0x4;\r\nreg0 &= 0xbc;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nreg1 |= 0x80;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nm88rs2000_demod_write(state, 0xb2, reg1);\r\nm88rs2000_demod_write(state, 0xb1, reg0);\r\nm88rs2000_demod_write(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_tab_set(struct m88rs2000_state *state,\r\nstruct inittab *tab)\r\n{\r\nint ret = 0;\r\nu8 i;\r\nif (tab == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 255; i++) {\r\nswitch (tab[i].cmd) {\r\ncase 0x01:\r\nret = m88rs2000_demod_write(state, tab[i].reg,\r\ntab[i].val);\r\nbreak;\r\ncase 0x02:\r\nret = m88rs2000_tuner_write(state, tab[i].reg,\r\ntab[i].val);\r\nbreak;\r\ncase 0x10:\r\nif (tab[i].reg > 0)\r\nmdelay(tab[i].reg);\r\nbreak;\r\ncase 0xff:\r\nif (tab[i].reg == 0xaa && tab[i].val == 0xff)\r\nreturn 0;\r\ncase 0x00:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t volt)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 data;\r\ndata = m88rs2000_demod_read(state, 0xb2);\r\ndata |= 0x03;\r\nswitch (volt) {\r\ncase SEC_VOLTAGE_18:\r\ndata &= ~0x03;\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\ndata &= ~0x03;\r\ndata |= 0x01;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nbreak;\r\n}\r\nm88rs2000_demod_write(state, 0xb2, data);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_startup(struct m88rs2000_state *state)\r\n{\r\nint ret = 0;\r\nu8 reg;\r\nreg = m88rs2000_tuner_read(state, 0x00);\r\nif ((reg & 0x40) == 0)\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\ndeb_info("m88rs2000: init chip\n");\r\nret = m88rs2000_tab_set(state, m88rs2000_setup);\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = m88rs2000_tab_set(state, m88rs2000_shutdown);\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 reg = m88rs2000_demod_read(state, 0x8c);\r\n*status = 0;\r\nif ((reg & 0x7) == 0x7) {\r\n*status = FE_HAS_CARRIER | FE_HAS_SIGNAL | FE_HAS_VITERBI\r\n| FE_HAS_SYNC | FE_HAS_LOCK;\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, CALL_IS_READ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\ndeb_info("m88rs2000_read_ber %d\n", *ber);\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\n*strength = 0;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\ndeb_info("m88rs2000_read_snr %d\n", *snr);\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\ndeb_info("m88rs2000_read_ber %d\n", *ucblocks);\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_tuner_gate_ctrl(struct m88rs2000_state *state, u8 offset)\r\n{\r\nint ret;\r\nret = m88rs2000_tuner_write(state, 0x51, 0x1f - offset);\r\nret |= m88rs2000_tuner_write(state, 0x51, 0x1f);\r\nret |= m88rs2000_tuner_write(state, 0x50, offset);\r\nret |= m88rs2000_tuner_write(state, 0x50, 0x00);\r\nmsleep(20);\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_set_tuner_rf(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint reg;\r\nreg = m88rs2000_tuner_read(state, 0x3d);\r\nreg &= 0x7f;\r\nif (reg < 0x16)\r\nreg = 0xa1;\r\nelse if (reg == 0x16)\r\nreg = 0x99;\r\nelse\r\nreg = 0xf9;\r\nm88rs2000_tuner_write(state, 0x60, reg);\r\nreg = m88rs2000_tuner_gate_ctrl(state, 0x08);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn reg;\r\n}\r\nstatic int m88rs2000_set_tuner(struct dvb_frontend *fe, u16 *offset)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\nu32 frequency = c->frequency;\r\ns32 offset_khz;\r\ns32 tmp;\r\nu32 symbol_rate = (c->symbol_rate / 1000);\r\nu32 f3db, gdiv28;\r\nu16 value, ndiv, lpf_coeff;\r\nu8 lpf_mxdiv, mlpf_max, mlpf_min, nlpf;\r\nu8 lo = 0x01, div4 = 0x0;\r\nret = m88rs2000_tab_set(state, tuner_reset);\r\nif (frequency < 1060000) {\r\nlo |= 0x10;\r\ndiv4 = 0x1;\r\nndiv = (frequency * 14 * 4) / FE_CRYSTAL_KHZ;\r\n} else\r\nndiv = (frequency * 14 * 2) / FE_CRYSTAL_KHZ;\r\nndiv = ndiv + ndiv % 2;\r\nndiv = ndiv - 1024;\r\nret = m88rs2000_tuner_write(state, 0x10, 0x80 | lo);\r\nret |= m88rs2000_tuner_write(state, 0x01, (ndiv >> 8) & 0xf);\r\nret |= m88rs2000_tuner_write(state, 0x02, ndiv & 0xff);\r\nret |= m88rs2000_tuner_write(state, 0x03, 0x06);\r\nret |= m88rs2000_tuner_gate_ctrl(state, 0x10);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_tuner_write(state, 0x10, lo);\r\nret |= m88rs2000_tuner_gate_ctrl(state, 0x08);\r\nret |= m88rs2000_set_tuner_rf(fe);\r\ngdiv28 = (FE_CRYSTAL_KHZ / 1000 * 1694 + 500) / 1000;\r\nret |= m88rs2000_tuner_write(state, 0x04, gdiv28 & 0xff);\r\nret |= m88rs2000_tuner_gate_ctrl(state, 0x04);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nvalue = m88rs2000_tuner_read(state, 0x26);\r\nf3db = (symbol_rate * 135) / 200 + 2000;\r\nf3db += FREQ_OFFSET_LOW_SYM_RATE;\r\nif (f3db < 7000)\r\nf3db = 7000;\r\nif (f3db > 40000)\r\nf3db = 40000;\r\ngdiv28 = gdiv28 * 207 / (value * 2 + 151);\r\nmlpf_max = gdiv28 * 135 / 100;\r\nmlpf_min = gdiv28 * 78 / 100;\r\nif (mlpf_max > 63)\r\nmlpf_max = 63;\r\nlpf_coeff = 2766;\r\nnlpf = (f3db * gdiv28 * 2 / lpf_coeff /\r\n(FE_CRYSTAL_KHZ / 1000) + 1) / 2;\r\nif (nlpf > 23)\r\nnlpf = 23;\r\nif (nlpf < 1)\r\nnlpf = 1;\r\nlpf_mxdiv = (nlpf * (FE_CRYSTAL_KHZ / 1000)\r\n* lpf_coeff * 2 / f3db + 1) / 2;\r\nif (lpf_mxdiv < mlpf_min) {\r\nnlpf++;\r\nlpf_mxdiv = (nlpf * (FE_CRYSTAL_KHZ / 1000)\r\n* lpf_coeff * 2 / f3db + 1) / 2;\r\n}\r\nif (lpf_mxdiv > mlpf_max)\r\nlpf_mxdiv = mlpf_max;\r\nret = m88rs2000_tuner_write(state, 0x04, lpf_mxdiv);\r\nret |= m88rs2000_tuner_write(state, 0x06, nlpf);\r\nret |= m88rs2000_tuner_gate_ctrl(state, 0x04);\r\nret |= m88rs2000_tuner_gate_ctrl(state, 0x01);\r\nmsleep(80);\r\noffset_khz = (ndiv - ndiv % 2 + 1024) * FE_CRYSTAL_KHZ\r\n/ 14 / (div4 + 1) / 2;\r\noffset_khz -= frequency;\r\ntmp = offset_khz;\r\ntmp *= 65536;\r\ntmp = (2 * tmp + 96000) / (2 * 96000);\r\nif (tmp < 0)\r\ntmp += 65536;\r\n*offset = tmp & 0xffff;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn (ret < 0) ? -EINVAL : 0;\r\n}\r\nstatic int m88rs2000_set_fec(struct m88rs2000_state *state,\r\nfe_code_rate_t fec)\r\n{\r\nu16 fec_set;\r\nswitch (fec) {\r\ncase FEC_AUTO:\r\ndefault:\r\nfec_set = 0x08;\r\n}\r\nm88rs2000_demod_write(state, 0x76, fec_set);\r\nreturn 0;\r\n}\r\nstatic fe_code_rate_t m88rs2000_get_fec(struct m88rs2000_state *state)\r\n{\r\nu8 reg;\r\nm88rs2000_demod_write(state, 0x9a, 0x30);\r\nreg = m88rs2000_demod_read(state, 0x76);\r\nm88rs2000_demod_write(state, 0x9a, 0xb0);\r\nswitch (reg) {\r\ncase 0x88:\r\nreturn FEC_1_2;\r\ncase 0x68:\r\nreturn FEC_2_3;\r\ncase 0x48:\r\nreturn FEC_3_4;\r\ncase 0x28:\r\nreturn FEC_5_6;\r\ncase 0x18:\r\nreturn FEC_7_8;\r\ncase 0x08:\r\ndefault:\r\nbreak;\r\n}\r\nreturn FEC_AUTO;\r\n}\r\nstatic int m88rs2000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nfe_status_t status;\r\nint i, ret;\r\nu16 offset = 0;\r\nu8 reg;\r\nstate->no_lock_count = 0;\r\nif (c->delivery_system != SYS_DVBS) {\r\ndeb_info("%s: unsupported delivery "\r\n"system selected (%d)\n",\r\n__func__, c->delivery_system);\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = m88rs2000_set_tuner(fe, &offset);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_demod_write(state, 0x9a, 0x30);\r\nreg = m88rs2000_demod_read(state, 0x86);\r\nret |= m88rs2000_demod_write(state, 0x86, reg);\r\nret |= m88rs2000_demod_write(state, 0x9c, (offset >> 8));\r\nret |= m88rs2000_demod_write(state, 0x9d, offset & 0xf0);\r\nret = m88rs2000_tab_set(state, fe_reset);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nreg = m88rs2000_demod_read(state, 0x70);\r\nret = m88rs2000_demod_write(state, 0x70, reg);\r\nret |= m88rs2000_set_fec(state, c->fec_inner);\r\nret |= m88rs2000_demod_write(state, 0x85, 0x1);\r\nret |= m88rs2000_demod_write(state, 0x8a, 0xbf);\r\nret |= m88rs2000_demod_write(state, 0x8d, 0x1e);\r\nret |= m88rs2000_demod_write(state, 0x90, 0xf1);\r\nret |= m88rs2000_demod_write(state, 0x91, 0x08);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_set_symbolrate(fe, c->symbol_rate);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_tab_set(state, fe_trigger);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 25; i++) {\r\nreg = m88rs2000_demod_read(state, 0x8c);\r\nif ((reg & 0x7) == 0x7) {\r\nstatus = FE_HAS_LOCK;\r\nbreak;\r\n}\r\nstate->no_lock_count++;\r\nif (state->no_lock_count == 15) {\r\nreg = m88rs2000_demod_read(state, 0x70);\r\nreg ^= 0x4;\r\nm88rs2000_demod_write(state, 0x70, reg);\r\nstate->no_lock_count = 0;\r\n}\r\nif (state->no_lock_count == 20)\r\nm88rs2000_set_tuner_rf(fe);\r\nmsleep(20);\r\n}\r\nif (status & FE_HAS_LOCK) {\r\nstate->fec_inner = m88rs2000_get_fec(state);\r\nreg = m88rs2000_demod_read(state, 0x65);\r\n}\r\nstate->tuner_frequency = c->frequency;\r\nstate->symbol_rate = c->symbol_rate;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nc->fec_inner = state->fec_inner;\r\nc->frequency = state->tuner_frequency;\r\nc->symbol_rate = state->symbol_rate;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nif (enable)\r\nm88rs2000_demod_write(state, 0x81, 0x84);\r\nelse\r\nm88rs2000_demod_write(state, 0x81, 0x81);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic void m88rs2000_release(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *m88rs2000_attach(const struct m88rs2000_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct m88rs2000_state *state = NULL;\r\nstate = kzalloc(sizeof(struct m88rs2000_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->tuner_frequency = 0;\r\nstate->symbol_rate = 0;\r\nstate->fec_inner = 0;\r\nif (m88rs2000_startup(state) < 0)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &m88rs2000_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
