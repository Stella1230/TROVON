void gsc_hw_set_sw_reset(struct gsc_dev *dev)\r\n{\r\nwritel(GSC_SW_RESET_SRESET, dev->regs + GSC_SW_RESET);\r\n}\r\nint gsc_wait_reset(struct gsc_dev *dev)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(50);\r\nu32 cfg;\r\nwhile (time_before(jiffies, end)) {\r\ncfg = readl(dev->regs + GSC_SW_RESET);\r\nif (!cfg)\r\nreturn 0;\r\nusleep_range(10, 20);\r\n}\r\nreturn -EBUSY;\r\n}\r\nvoid gsc_hw_set_frm_done_irq_mask(struct gsc_dev *dev, bool mask)\r\n{\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_IRQ);\r\nif (mask)\r\ncfg |= GSC_IRQ_FRMDONE_MASK;\r\nelse\r\ncfg &= ~GSC_IRQ_FRMDONE_MASK;\r\nwritel(cfg, dev->regs + GSC_IRQ);\r\n}\r\nvoid gsc_hw_set_gsc_irq_enable(struct gsc_dev *dev, bool mask)\r\n{\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_IRQ);\r\nif (mask)\r\ncfg |= GSC_IRQ_ENABLE;\r\nelse\r\ncfg &= ~GSC_IRQ_ENABLE;\r\nwritel(cfg, dev->regs + GSC_IRQ);\r\n}\r\nvoid gsc_hw_set_input_buf_masking(struct gsc_dev *dev, u32 shift,\r\nbool enable)\r\n{\r\nu32 cfg = readl(dev->regs + GSC_IN_BASE_ADDR_Y_MASK);\r\nu32 mask = 1 << shift;\r\ncfg &= ~mask;\r\ncfg |= enable << shift;\r\nwritel(cfg, dev->regs + GSC_IN_BASE_ADDR_Y_MASK);\r\nwritel(cfg, dev->regs + GSC_IN_BASE_ADDR_CB_MASK);\r\nwritel(cfg, dev->regs + GSC_IN_BASE_ADDR_CR_MASK);\r\n}\r\nvoid gsc_hw_set_output_buf_masking(struct gsc_dev *dev, u32 shift,\r\nbool enable)\r\n{\r\nu32 cfg = readl(dev->regs + GSC_OUT_BASE_ADDR_Y_MASK);\r\nu32 mask = 1 << shift;\r\ncfg &= ~mask;\r\ncfg |= enable << shift;\r\nwritel(cfg, dev->regs + GSC_OUT_BASE_ADDR_Y_MASK);\r\nwritel(cfg, dev->regs + GSC_OUT_BASE_ADDR_CB_MASK);\r\nwritel(cfg, dev->regs + GSC_OUT_BASE_ADDR_CR_MASK);\r\n}\r\nvoid gsc_hw_set_input_addr(struct gsc_dev *dev, struct gsc_addr *addr,\r\nint index)\r\n{\r\npr_debug("src_buf[%d]: 0x%X, cb: 0x%X, cr: 0x%X", index,\r\naddr->y, addr->cb, addr->cr);\r\nwritel(addr->y, dev->regs + GSC_IN_BASE_ADDR_Y(index));\r\nwritel(addr->cb, dev->regs + GSC_IN_BASE_ADDR_CB(index));\r\nwritel(addr->cr, dev->regs + GSC_IN_BASE_ADDR_CR(index));\r\n}\r\nvoid gsc_hw_set_output_addr(struct gsc_dev *dev,\r\nstruct gsc_addr *addr, int index)\r\n{\r\npr_debug("dst_buf[%d]: 0x%X, cb: 0x%X, cr: 0x%X",\r\nindex, addr->y, addr->cb, addr->cr);\r\nwritel(addr->y, dev->regs + GSC_OUT_BASE_ADDR_Y(index));\r\nwritel(addr->cb, dev->regs + GSC_OUT_BASE_ADDR_CB(index));\r\nwritel(addr->cr, dev->regs + GSC_OUT_BASE_ADDR_CR(index));\r\n}\r\nvoid gsc_hw_set_input_path(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nu32 cfg = readl(dev->regs + GSC_IN_CON);\r\ncfg &= ~(GSC_IN_PATH_MASK | GSC_IN_LOCAL_SEL_MASK);\r\nif (ctx->in_path == GSC_DMA)\r\ncfg |= GSC_IN_PATH_MEMORY;\r\nwritel(cfg, dev->regs + GSC_IN_CON);\r\n}\r\nvoid gsc_hw_set_in_size(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->s_frame;\r\nu32 cfg;\r\ncfg = GSC_SRCIMG_OFFSET_X(frame->crop.left);\r\ncfg |= GSC_SRCIMG_OFFSET_Y(frame->crop.top);\r\nwritel(cfg, dev->regs + GSC_SRCIMG_OFFSET);\r\ncfg = GSC_SRCIMG_WIDTH(frame->f_width);\r\ncfg |= GSC_SRCIMG_HEIGHT(frame->f_height);\r\nwritel(cfg, dev->regs + GSC_SRCIMG_SIZE);\r\ncfg = GSC_CROPPED_WIDTH(frame->crop.width);\r\ncfg |= GSC_CROPPED_HEIGHT(frame->crop.height);\r\nwritel(cfg, dev->regs + GSC_CROPPED_SIZE);\r\n}\r\nvoid gsc_hw_set_in_image_rgb(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->s_frame;\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_IN_CON);\r\nif (frame->colorspace == V4L2_COLORSPACE_REC709)\r\ncfg |= GSC_IN_RGB_HD_WIDE;\r\nelse\r\ncfg |= GSC_IN_RGB_SD_WIDE;\r\nif (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB565X)\r\ncfg |= GSC_IN_RGB565;\r\nelse if (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB32)\r\ncfg |= GSC_IN_XRGB8888;\r\nwritel(cfg, dev->regs + GSC_IN_CON);\r\n}\r\nvoid gsc_hw_set_in_image_format(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->s_frame;\r\nu32 i, depth = 0;\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_IN_CON);\r\ncfg &= ~(GSC_IN_RGB_TYPE_MASK | GSC_IN_YUV422_1P_ORDER_MASK |\r\nGSC_IN_CHROMA_ORDER_MASK | GSC_IN_FORMAT_MASK |\r\nGSC_IN_TILE_TYPE_MASK | GSC_IN_TILE_MODE);\r\nwritel(cfg, dev->regs + GSC_IN_CON);\r\nif (is_rgb(frame->fmt->color)) {\r\ngsc_hw_set_in_image_rgb(ctx);\r\nreturn;\r\n}\r\nfor (i = 0; i < frame->fmt->num_planes; i++)\r\ndepth += frame->fmt->depth[i];\r\nswitch (frame->fmt->num_comp) {\r\ncase 1:\r\ncfg |= GSC_IN_YUV422_1P;\r\nif (frame->fmt->yorder == GSC_LSB_Y)\r\ncfg |= GSC_IN_YUV422_1P_ORDER_LSB_Y;\r\nelse\r\ncfg |= GSC_IN_YUV422_1P_OEDER_LSB_C;\r\nif (frame->fmt->corder == GSC_CBCR)\r\ncfg |= GSC_IN_CHROMA_ORDER_CBCR;\r\nelse\r\ncfg |= GSC_IN_CHROMA_ORDER_CRCB;\r\nbreak;\r\ncase 2:\r\nif (depth == 12)\r\ncfg |= GSC_IN_YUV420_2P;\r\nelse\r\ncfg |= GSC_IN_YUV422_2P;\r\nif (frame->fmt->corder == GSC_CBCR)\r\ncfg |= GSC_IN_CHROMA_ORDER_CBCR;\r\nelse\r\ncfg |= GSC_IN_CHROMA_ORDER_CRCB;\r\nbreak;\r\ncase 3:\r\nif (depth == 12)\r\ncfg |= GSC_IN_YUV420_3P;\r\nelse\r\ncfg |= GSC_IN_YUV422_3P;\r\nbreak;\r\n}\r\nwritel(cfg, dev->regs + GSC_IN_CON);\r\n}\r\nvoid gsc_hw_set_output_path(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nu32 cfg = readl(dev->regs + GSC_OUT_CON);\r\ncfg &= ~GSC_OUT_PATH_MASK;\r\nif (ctx->out_path == GSC_DMA)\r\ncfg |= GSC_OUT_PATH_MEMORY;\r\nelse\r\ncfg |= GSC_OUT_PATH_LOCAL;\r\nwritel(cfg, dev->regs + GSC_OUT_CON);\r\n}\r\nvoid gsc_hw_set_out_size(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->d_frame;\r\nu32 cfg;\r\nif (ctx->out_path == GSC_DMA) {\r\ncfg = GSC_DSTIMG_OFFSET_X(frame->crop.left);\r\ncfg |= GSC_DSTIMG_OFFSET_Y(frame->crop.top);\r\nwritel(cfg, dev->regs + GSC_DSTIMG_OFFSET);\r\ncfg = GSC_DSTIMG_WIDTH(frame->f_width);\r\ncfg |= GSC_DSTIMG_HEIGHT(frame->f_height);\r\nwritel(cfg, dev->regs + GSC_DSTIMG_SIZE);\r\n}\r\nif (ctx->gsc_ctrls.rotate->val == 90 ||\r\nctx->gsc_ctrls.rotate->val == 270) {\r\ncfg = GSC_SCALED_WIDTH(frame->crop.height);\r\ncfg |= GSC_SCALED_HEIGHT(frame->crop.width);\r\n} else {\r\ncfg = GSC_SCALED_WIDTH(frame->crop.width);\r\ncfg |= GSC_SCALED_HEIGHT(frame->crop.height);\r\n}\r\nwritel(cfg, dev->regs + GSC_SCALED_SIZE);\r\n}\r\nvoid gsc_hw_set_out_image_rgb(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->d_frame;\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_OUT_CON);\r\nif (frame->colorspace == V4L2_COLORSPACE_REC709)\r\ncfg |= GSC_OUT_RGB_HD_WIDE;\r\nelse\r\ncfg |= GSC_OUT_RGB_SD_WIDE;\r\nif (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB565X)\r\ncfg |= GSC_OUT_RGB565;\r\nelse if (frame->fmt->pixelformat == V4L2_PIX_FMT_RGB32)\r\ncfg |= GSC_OUT_XRGB8888;\r\nwritel(cfg, dev->regs + GSC_OUT_CON);\r\n}\r\nvoid gsc_hw_set_out_image_format(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->d_frame;\r\nu32 i, depth = 0;\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_OUT_CON);\r\ncfg &= ~(GSC_OUT_RGB_TYPE_MASK | GSC_OUT_YUV422_1P_ORDER_MASK |\r\nGSC_OUT_CHROMA_ORDER_MASK | GSC_OUT_FORMAT_MASK |\r\nGSC_OUT_TILE_TYPE_MASK | GSC_OUT_TILE_MODE);\r\nwritel(cfg, dev->regs + GSC_OUT_CON);\r\nif (is_rgb(frame->fmt->color)) {\r\ngsc_hw_set_out_image_rgb(ctx);\r\nreturn;\r\n}\r\nif (ctx->out_path != GSC_DMA) {\r\ncfg |= GSC_OUT_YUV444;\r\ngoto end_set;\r\n}\r\nfor (i = 0; i < frame->fmt->num_planes; i++)\r\ndepth += frame->fmt->depth[i];\r\nswitch (frame->fmt->num_comp) {\r\ncase 1:\r\ncfg |= GSC_OUT_YUV422_1P;\r\nif (frame->fmt->yorder == GSC_LSB_Y)\r\ncfg |= GSC_OUT_YUV422_1P_ORDER_LSB_Y;\r\nelse\r\ncfg |= GSC_OUT_YUV422_1P_OEDER_LSB_C;\r\nif (frame->fmt->corder == GSC_CBCR)\r\ncfg |= GSC_OUT_CHROMA_ORDER_CBCR;\r\nelse\r\ncfg |= GSC_OUT_CHROMA_ORDER_CRCB;\r\nbreak;\r\ncase 2:\r\nif (depth == 12)\r\ncfg |= GSC_OUT_YUV420_2P;\r\nelse\r\ncfg |= GSC_OUT_YUV422_2P;\r\nif (frame->fmt->corder == GSC_CBCR)\r\ncfg |= GSC_OUT_CHROMA_ORDER_CBCR;\r\nelse\r\ncfg |= GSC_OUT_CHROMA_ORDER_CRCB;\r\nbreak;\r\ncase 3:\r\ncfg |= GSC_OUT_YUV420_3P;\r\nbreak;\r\n}\r\nend_set:\r\nwritel(cfg, dev->regs + GSC_OUT_CON);\r\n}\r\nvoid gsc_hw_set_prescaler(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_scaler *sc = &ctx->scaler;\r\nu32 cfg;\r\ncfg = GSC_PRESC_SHFACTOR(sc->pre_shfactor);\r\ncfg |= GSC_PRESC_H_RATIO(sc->pre_hratio);\r\ncfg |= GSC_PRESC_V_RATIO(sc->pre_vratio);\r\nwritel(cfg, dev->regs + GSC_PRE_SCALE_RATIO);\r\n}\r\nvoid gsc_hw_set_mainscaler(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_scaler *sc = &ctx->scaler;\r\nu32 cfg;\r\ncfg = GSC_MAIN_H_RATIO_VALUE(sc->main_hratio);\r\nwritel(cfg, dev->regs + GSC_MAIN_H_RATIO);\r\ncfg = GSC_MAIN_V_RATIO_VALUE(sc->main_vratio);\r\nwritel(cfg, dev->regs + GSC_MAIN_V_RATIO);\r\n}\r\nvoid gsc_hw_set_rotation(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_IN_CON);\r\ncfg &= ~GSC_IN_ROT_MASK;\r\nswitch (ctx->gsc_ctrls.rotate->val) {\r\ncase 270:\r\ncfg |= GSC_IN_ROT_270;\r\nbreak;\r\ncase 180:\r\ncfg |= GSC_IN_ROT_180;\r\nbreak;\r\ncase 90:\r\nif (ctx->gsc_ctrls.hflip->val)\r\ncfg |= GSC_IN_ROT_90_XFLIP;\r\nelse if (ctx->gsc_ctrls.vflip->val)\r\ncfg |= GSC_IN_ROT_90_YFLIP;\r\nelse\r\ncfg |= GSC_IN_ROT_90;\r\nbreak;\r\ncase 0:\r\nif (ctx->gsc_ctrls.hflip->val)\r\ncfg |= GSC_IN_ROT_XFLIP;\r\nelse if (ctx->gsc_ctrls.vflip->val)\r\ncfg |= GSC_IN_ROT_YFLIP;\r\n}\r\nwritel(cfg, dev->regs + GSC_IN_CON);\r\n}\r\nvoid gsc_hw_set_global_alpha(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nstruct gsc_frame *frame = &ctx->d_frame;\r\nu32 cfg;\r\nif (!is_rgb(frame->fmt->color)) {\r\npr_debug("Not a RGB format");\r\nreturn;\r\n}\r\ncfg = readl(dev->regs + GSC_OUT_CON);\r\ncfg &= ~GSC_OUT_GLOBAL_ALPHA_MASK;\r\ncfg |= GSC_OUT_GLOBAL_ALPHA(ctx->gsc_ctrls.global_alpha->val);\r\nwritel(cfg, dev->regs + GSC_OUT_CON);\r\n}\r\nvoid gsc_hw_set_sfr_update(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_dev *dev = ctx->gsc_dev;\r\nu32 cfg;\r\ncfg = readl(dev->regs + GSC_ENABLE);\r\ncfg |= GSC_ENABLE_SFR_UPDATE;\r\nwritel(cfg, dev->regs + GSC_ENABLE);\r\n}
