void\r\nmegasas_enable_intr_fusion(struct megasas_register_set __iomem *regs)\r\n{\r\nwritel(~0, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nwritel(~MFI_FUSION_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nvoid\r\nmegasas_disable_intr_fusion(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 mask = 0xFFFFFFFF;\r\nu32 status;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nstatus = readl(&regs->outbound_intr_mask);\r\n}\r\nint\r\nmegasas_clear_intr_fusion(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 status;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & 1) {\r\nwritel(status, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nreturn 1;\r\n}\r\nif (!(status & MFI_FUSION_ENABLE_INTERRUPT_MASK))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstruct megasas_cmd_fusion *megasas_get_cmd_fusion(struct megasas_instance\r\n*instance)\r\n{\r\nunsigned long flags;\r\nstruct fusion_context *fusion =\r\n(struct fusion_context *)instance->ctrl_context;\r\nstruct megasas_cmd_fusion *cmd = NULL;\r\nspin_lock_irqsave(&fusion->cmd_pool_lock, flags);\r\nif (!list_empty(&fusion->cmd_pool)) {\r\ncmd = list_entry((&fusion->cmd_pool)->next,\r\nstruct megasas_cmd_fusion, list);\r\nlist_del_init(&cmd->list);\r\n} else {\r\nprintk(KERN_ERR "megasas: Command pool (fusion) empty!\n");\r\n}\r\nspin_unlock_irqrestore(&fusion->cmd_pool_lock, flags);\r\nreturn cmd;\r\n}\r\nstatic inline void\r\nmegasas_return_cmd_fusion(struct megasas_instance *instance,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nunsigned long flags;\r\nstruct fusion_context *fusion =\r\n(struct fusion_context *)instance->ctrl_context;\r\nspin_lock_irqsave(&fusion->cmd_pool_lock, flags);\r\ncmd->scmd = NULL;\r\ncmd->sync_cmd_idx = (u32)ULONG_MAX;\r\nlist_add_tail(&cmd->list, &fusion->cmd_pool);\r\nspin_unlock_irqrestore(&fusion->cmd_pool_lock, flags);\r\n}\r\nstatic void megasas_teardown_frame_pool_fusion(\r\nstruct megasas_instance *instance)\r\n{\r\nint i;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nu16 max_cmd = instance->max_fw_cmds;\r\nstruct megasas_cmd_fusion *cmd;\r\nif (!fusion->sg_dma_pool || !fusion->sense_dma_pool) {\r\nprintk(KERN_ERR "megasas: dma pool is null. SG Pool %p, "\r\n"sense pool : %p\n", fusion->sg_dma_pool,\r\nfusion->sense_dma_pool);\r\nreturn;\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = fusion->cmd_list[i];\r\nif (cmd->sg_frame)\r\npci_pool_free(fusion->sg_dma_pool, cmd->sg_frame,\r\ncmd->sg_frame_phys_addr);\r\nif (cmd->sense)\r\npci_pool_free(fusion->sense_dma_pool, cmd->sense,\r\ncmd->sense_phys_addr);\r\n}\r\npci_pool_destroy(fusion->sg_dma_pool);\r\npci_pool_destroy(fusion->sense_dma_pool);\r\nfusion->sg_dma_pool = NULL;\r\nfusion->sense_dma_pool = NULL;\r\n}\r\nvoid\r\nmegasas_free_cmds_fusion(struct megasas_instance *instance)\r\n{\r\nint i;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nu32 max_cmds, req_sz, reply_sz, io_frames_sz;\r\nreq_sz = fusion->request_alloc_sz;\r\nreply_sz = fusion->reply_alloc_sz;\r\nio_frames_sz = fusion->io_frames_alloc_sz;\r\nmax_cmds = instance->max_fw_cmds;\r\nif (fusion->req_frames_desc)\r\ndma_free_coherent(&instance->pdev->dev, req_sz,\r\nfusion->req_frames_desc,\r\nfusion->req_frames_desc_phys);\r\nif (fusion->reply_frames_desc) {\r\npci_pool_free(fusion->reply_frames_desc_pool,\r\nfusion->reply_frames_desc,\r\nfusion->reply_frames_desc_phys);\r\npci_pool_destroy(fusion->reply_frames_desc_pool);\r\n}\r\nif (fusion->io_request_frames) {\r\npci_pool_free(fusion->io_request_frames_pool,\r\nfusion->io_request_frames,\r\nfusion->io_request_frames_phys);\r\npci_pool_destroy(fusion->io_request_frames_pool);\r\n}\r\nmegasas_teardown_frame_pool_fusion(instance);\r\nfor (i = 0; i < max_cmds; i++)\r\nkfree(fusion->cmd_list[i]);\r\nkfree(fusion->cmd_list);\r\nfusion->cmd_list = NULL;\r\nINIT_LIST_HEAD(&fusion->cmd_pool);\r\n}\r\nstatic int megasas_create_frame_pool_fusion(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 max_cmd;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd_fusion *cmd;\r\nu32 total_sz_chain_frame;\r\nfusion = instance->ctrl_context;\r\nmax_cmd = instance->max_fw_cmds;\r\ntotal_sz_chain_frame = MEGASAS_MAX_SZ_CHAIN_FRAME;\r\nfusion->sg_dma_pool = pci_pool_create("megasas sg pool fusion",\r\ninstance->pdev,\r\ntotal_sz_chain_frame, 4,\r\n0);\r\nif (!fusion->sg_dma_pool) {\r\nprintk(KERN_DEBUG "megasas: failed to setup request pool "\r\n"fusion\n");\r\nreturn -ENOMEM;\r\n}\r\nfusion->sense_dma_pool = pci_pool_create("megasas sense pool fusion",\r\ninstance->pdev,\r\nSCSI_SENSE_BUFFERSIZE, 64, 0);\r\nif (!fusion->sense_dma_pool) {\r\nprintk(KERN_DEBUG "megasas: failed to setup sense pool "\r\n"fusion\n");\r\npci_pool_destroy(fusion->sg_dma_pool);\r\nfusion->sg_dma_pool = NULL;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = fusion->cmd_list[i];\r\ncmd->sg_frame = pci_pool_alloc(fusion->sg_dma_pool,\r\nGFP_KERNEL,\r\n&cmd->sg_frame_phys_addr);\r\ncmd->sense = pci_pool_alloc(fusion->sense_dma_pool,\r\nGFP_KERNEL, &cmd->sense_phys_addr);\r\nif (!cmd->sg_frame || !cmd->sense) {\r\nprintk(KERN_DEBUG "megasas: pci_pool_alloc failed\n");\r\nmegasas_teardown_frame_pool_fusion(instance);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmegasas_alloc_cmds_fusion(struct megasas_instance *instance)\r\n{\r\nint i, j, count;\r\nu32 max_cmd, io_frames_sz;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd_fusion *cmd;\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\r\nu32 offset;\r\ndma_addr_t io_req_base_phys;\r\nu8 *io_req_base;\r\nfusion = instance->ctrl_context;\r\nmax_cmd = instance->max_fw_cmds;\r\nfusion->req_frames_desc =\r\ndma_alloc_coherent(&instance->pdev->dev,\r\nfusion->request_alloc_sz,\r\n&fusion->req_frames_desc_phys, GFP_KERNEL);\r\nif (!fusion->req_frames_desc) {\r\nprintk(KERN_ERR "megasas; Could not allocate memory for "\r\n"request_frames\n");\r\ngoto fail_req_desc;\r\n}\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfusion->reply_frames_desc_pool =\r\npci_pool_create("reply_frames pool", instance->pdev,\r\nfusion->reply_alloc_sz * count, 16, 0);\r\nif (!fusion->reply_frames_desc_pool) {\r\nprintk(KERN_ERR "megasas; Could not allocate memory for "\r\n"reply_frame pool\n");\r\ngoto fail_reply_desc;\r\n}\r\nfusion->reply_frames_desc =\r\npci_pool_alloc(fusion->reply_frames_desc_pool, GFP_KERNEL,\r\n&fusion->reply_frames_desc_phys);\r\nif (!fusion->reply_frames_desc) {\r\nprintk(KERN_ERR "megasas; Could not allocate memory for "\r\n"reply_frame pool\n");\r\npci_pool_destroy(fusion->reply_frames_desc_pool);\r\ngoto fail_reply_desc;\r\n}\r\nreply_desc = fusion->reply_frames_desc;\r\nfor (i = 0; i < fusion->reply_q_depth * count; i++, reply_desc++)\r\nreply_desc->Words = ULLONG_MAX;\r\nio_frames_sz = fusion->io_frames_alloc_sz;\r\nfusion->io_request_frames_pool =\r\npci_pool_create("io_request_frames pool", instance->pdev,\r\nfusion->io_frames_alloc_sz, 16, 0);\r\nif (!fusion->io_request_frames_pool) {\r\nprintk(KERN_ERR "megasas: Could not allocate memory for "\r\n"io_request_frame pool\n");\r\ngoto fail_io_frames;\r\n}\r\nfusion->io_request_frames =\r\npci_pool_alloc(fusion->io_request_frames_pool, GFP_KERNEL,\r\n&fusion->io_request_frames_phys);\r\nif (!fusion->io_request_frames) {\r\nprintk(KERN_ERR "megasas: Could not allocate memory for "\r\n"io_request_frames frames\n");\r\npci_pool_destroy(fusion->io_request_frames_pool);\r\ngoto fail_io_frames;\r\n}\r\nfusion->cmd_list = kzalloc(sizeof(struct megasas_cmd_fusion *)\r\n* max_cmd, GFP_KERNEL);\r\nif (!fusion->cmd_list) {\r\nprintk(KERN_DEBUG "megasas: out of memory. Could not alloc "\r\n"memory for cmd_list_fusion\n");\r\ngoto fail_cmd_list;\r\n}\r\nmax_cmd = instance->max_fw_cmds;\r\nfor (i = 0; i < max_cmd; i++) {\r\nfusion->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd_fusion),\r\nGFP_KERNEL);\r\nif (!fusion->cmd_list[i]) {\r\nprintk(KERN_ERR "Could not alloc cmd list fusion\n");\r\nfor (j = 0; j < i; j++)\r\nkfree(fusion->cmd_list[j]);\r\nkfree(fusion->cmd_list);\r\nfusion->cmd_list = NULL;\r\ngoto fail_cmd_list;\r\n}\r\n}\r\nio_req_base = fusion->io_request_frames +\r\nMEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;\r\nio_req_base_phys = fusion->io_request_frames_phys +\r\nMEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE;\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = fusion->cmd_list[i];\r\noffset = MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE * i;\r\nmemset(cmd, 0, sizeof(struct megasas_cmd_fusion));\r\ncmd->index = i + 1;\r\ncmd->scmd = NULL;\r\ncmd->sync_cmd_idx = (u32)ULONG_MAX;\r\ncmd->instance = instance;\r\ncmd->io_request =\r\n(struct MPI2_RAID_SCSI_IO_REQUEST *)\r\n(io_req_base + offset);\r\nmemset(cmd->io_request, 0,\r\nsizeof(struct MPI2_RAID_SCSI_IO_REQUEST));\r\ncmd->io_request_phys_addr = io_req_base_phys + offset;\r\nlist_add_tail(&cmd->list, &fusion->cmd_pool);\r\n}\r\nif (megasas_create_frame_pool_fusion(instance)) {\r\nprintk(KERN_DEBUG "megasas: Error creating frame DMA pool\n");\r\nmegasas_free_cmds_fusion(instance);\r\ngoto fail_req_desc;\r\n}\r\nreturn 0;\r\nfail_cmd_list:\r\npci_pool_free(fusion->io_request_frames_pool, fusion->io_request_frames,\r\nfusion->io_request_frames_phys);\r\npci_pool_destroy(fusion->io_request_frames_pool);\r\nfail_io_frames:\r\ndma_free_coherent(&instance->pdev->dev, fusion->request_alloc_sz,\r\nfusion->reply_frames_desc,\r\nfusion->reply_frames_desc_phys);\r\npci_pool_free(fusion->reply_frames_desc_pool,\r\nfusion->reply_frames_desc,\r\nfusion->reply_frames_desc_phys);\r\npci_pool_destroy(fusion->reply_frames_desc_pool);\r\nfail_reply_desc:\r\ndma_free_coherent(&instance->pdev->dev, fusion->request_alloc_sz,\r\nfusion->req_frames_desc,\r\nfusion->req_frames_desc_phys);\r\nfail_req_desc:\r\nreturn -ENOMEM;\r\n}\r\nint\r\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nint i;\r\nstruct megasas_header *frame_hdr = &cmd->frame->hdr;\r\nu32 msecs = MFI_POLL_TIMEOUT_SECS * 1000;\r\nfor (i = 0; (i < msecs) && (frame_hdr->cmd_status == 0xff); i += 20) {\r\nrmb();\r\nmsleep(20);\r\n}\r\nif (frame_hdr->cmd_status == 0xff)\r\nreturn -ETIME;\r\nreturn 0;\r\n}\r\nint\r\nmegasas_ioc_init_fusion(struct megasas_instance *instance)\r\n{\r\nstruct megasas_init_frame *init_frame;\r\nstruct MPI2_IOC_INIT_REQUEST *IOCInitMessage;\r\ndma_addr_t ioc_init_handle;\r\nstruct megasas_cmd *cmd;\r\nu8 ret;\r\nstruct fusion_context *fusion;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nint i;\r\nstruct megasas_header *frame_hdr;\r\nfusion = instance->ctrl_context;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_ERR "Could not allocate cmd for INIT Frame\n");\r\nret = 1;\r\ngoto fail_get_cmd;\r\n}\r\nIOCInitMessage =\r\ndma_alloc_coherent(&instance->pdev->dev,\r\nsizeof(struct MPI2_IOC_INIT_REQUEST),\r\n&ioc_init_handle, GFP_KERNEL);\r\nif (!IOCInitMessage) {\r\nprintk(KERN_ERR "Could not allocate memory for "\r\n"IOCInitMessage\n");\r\nret = 1;\r\ngoto fail_fw_init;\r\n}\r\nmemset(IOCInitMessage, 0, sizeof(struct MPI2_IOC_INIT_REQUEST));\r\nIOCInitMessage->Function = MPI2_FUNCTION_IOC_INIT;\r\nIOCInitMessage->WhoInit = MPI2_WHOINIT_HOST_DRIVER;\r\nIOCInitMessage->MsgVersion = MPI2_VERSION;\r\nIOCInitMessage->HeaderVersion = MPI2_HEADER_VERSION;\r\nIOCInitMessage->SystemRequestFrameSize =\r\nMEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE / 4;\r\nIOCInitMessage->ReplyDescriptorPostQueueDepth = fusion->reply_q_depth;\r\nIOCInitMessage->ReplyDescriptorPostQueueAddress =\r\nfusion->reply_frames_desc_phys;\r\nIOCInitMessage->SystemRequestFrameBaseAddress =\r\nfusion->io_request_frames_phys;\r\nIOCInitMessage->HostMSIxVectors = instance->msix_vectors;\r\ninit_frame = (struct megasas_init_frame *)cmd->frame;\r\nmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\r\nframe_hdr = &cmd->frame->hdr;\r\nframe_hdr->cmd_status = 0xFF;\r\nframe_hdr->flags |= MFI_FRAME_DONT_POST_IN_REPLY_QUEUE;\r\ninit_frame->cmd = MFI_CMD_INIT;\r\ninit_frame->cmd_status = 0xFF;\r\ninit_frame->queue_info_new_phys_addr_lo = ioc_init_handle;\r\ninit_frame->data_xfer_len = sizeof(struct MPI2_IOC_INIT_REQUEST);\r\nreq_desc =\r\n(union MEGASAS_REQUEST_DESCRIPTOR_UNION *)fusion->req_frames_desc;\r\nreq_desc->Words = cmd->frame_phys_addr;\r\nreq_desc->MFAIo.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_MFA <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nfor (i = 0; i < (10 * 1000); i += 20) {\r\nif (readl(&instance->reg_set->doorbell) & 1)\r\nmsleep(20);\r\nelse\r\nbreak;\r\n}\r\ninstance->instancet->fire_cmd(instance, req_desc->u.low,\r\nreq_desc->u.high, instance->reg_set);\r\nwait_and_poll(instance, cmd);\r\nframe_hdr = &cmd->frame->hdr;\r\nif (frame_hdr->cmd_status != 0) {\r\nret = 1;\r\ngoto fail_fw_init;\r\n}\r\nprintk(KERN_ERR "megasas:IOC Init cmd success\n");\r\nret = 0;\r\nfail_fw_init:\r\nmegasas_return_cmd(instance, cmd);\r\nif (IOCInitMessage)\r\ndma_free_coherent(&instance->pdev->dev,\r\nsizeof(struct MPI2_IOC_INIT_REQUEST),\r\nIOCInitMessage, ioc_init_handle);\r\nfail_get_cmd:\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_get_ld_map_info(struct megasas_instance *instance)\r\n{\r\nint ret = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_FW_RAID_MAP_ALL *ci;\r\ndma_addr_t ci_h = 0;\r\nu32 size_map_info;\r\nstruct fusion_context *fusion;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: Failed to get cmd for map info.\n");\r\nreturn -ENOMEM;\r\n}\r\nfusion = instance->ctrl_context;\r\nif (!fusion) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 1;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nsize_map_info = sizeof(struct MR_FW_RAID_MAP) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *(MAX_LOGICAL_DRIVES - 1));\r\nci = fusion->ld_map[(instance->map_id & 1)];\r\nci_h = fusion->ld_map_phys[(instance->map_id & 1)];\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem for ld_map_info\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_READ;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = size_map_info;\r\ndcmd->opcode = MR_DCMD_LD_MAP_GET_INFO;\r\ndcmd->sgl.sge32[0].phys_addr = ci_h;\r\ndcmd->sgl.sge32[0].length = size_map_info;\r\nif (!megasas_issue_polled(instance, cmd))\r\nret = 0;\r\nelse {\r\nprintk(KERN_ERR "megasas: Get LD Map Info Failed\n");\r\nret = -1;\r\n}\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nu8\r\nmegasas_get_map_info(struct megasas_instance *instance)\r\n{\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nfusion->fast_path_io = 0;\r\nif (!megasas_get_ld_map_info(instance)) {\r\nif (MR_ValidateMapInfo(fusion->ld_map[(instance->map_id & 1)],\r\nfusion->load_balance_info)) {\r\nfusion->fast_path_io = 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint\r\nmegasas_sync_map_info(struct megasas_instance *instance)\r\n{\r\nint ret = 0, i;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nu32 size_sync_info, num_lds;\r\nstruct fusion_context *fusion;\r\nstruct MR_LD_TARGET_SYNC *ci = NULL;\r\nstruct MR_FW_RAID_MAP_ALL *map;\r\nstruct MR_LD_RAID *raid;\r\nstruct MR_LD_TARGET_SYNC *ld_sync;\r\ndma_addr_t ci_h = 0;\r\nu32 size_map_info;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: Failed to get cmd for sync"\r\n"info.\n");\r\nreturn -ENOMEM;\r\n}\r\nfusion = instance->ctrl_context;\r\nif (!fusion) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 1;\r\n}\r\nmap = fusion->ld_map[instance->map_id & 1];\r\nnum_lds = map->raidMap.ldCount;\r\ndcmd = &cmd->frame->dcmd;\r\nsize_sync_info = sizeof(struct MR_LD_TARGET_SYNC) *num_lds;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\nci = (struct MR_LD_TARGET_SYNC *)\r\nfusion->ld_map[(instance->map_id - 1) & 1];\r\nmemset(ci, 0, sizeof(struct MR_FW_RAID_MAP_ALL));\r\nci_h = fusion->ld_map_phys[(instance->map_id - 1) & 1];\r\nld_sync = (struct MR_LD_TARGET_SYNC *)ci;\r\nfor (i = 0; i < num_lds; i++, ld_sync++) {\r\nraid = MR_LdRaidGet(i, map);\r\nld_sync->targetId = MR_GetLDTgtId(i, map);\r\nld_sync->seqNum = raid->seqNum;\r\n}\r\nsize_map_info = sizeof(struct MR_FW_RAID_MAP) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *(MAX_LOGICAL_DRIVES - 1));\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_WRITE;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = size_map_info;\r\ndcmd->mbox.b[0] = num_lds;\r\ndcmd->mbox.b[1] = MEGASAS_DCMD_MBOX_PEND_FLAG;\r\ndcmd->opcode = MR_DCMD_LD_MAP_GET_INFO;\r\ndcmd->sgl.sge32[0].phys_addr = ci_h;\r\ndcmd->sgl.sge32[0].length = size_map_info;\r\ninstance->map_update_cmd = cmd;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nreturn ret;\r\n}\r\nu32\r\nmegasas_init_adapter_fusion(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *reg_set;\r\nstruct fusion_context *fusion;\r\nu32 max_cmd;\r\nint i = 0, count;\r\nfusion = instance->ctrl_context;\r\nreg_set = instance->reg_set;\r\ninstance->max_fw_cmds =\r\ninstance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;\r\ninstance->max_fw_cmds = min(instance->max_fw_cmds, (u16)1008);\r\ninstance->max_fw_cmds = instance->max_fw_cmds-1;\r\ninstance->max_mfi_cmds = MEGASAS_INT_CMDS;\r\nmax_cmd = instance->max_fw_cmds;\r\nfusion->reply_q_depth = ((max_cmd + 1 + 15)/16)*16;\r\nfusion->request_alloc_sz =\r\nsizeof(union MEGASAS_REQUEST_DESCRIPTOR_UNION) *max_cmd;\r\nfusion->reply_alloc_sz = sizeof(union MPI2_REPLY_DESCRIPTORS_UNION)\r\n*(fusion->reply_q_depth);\r\nfusion->io_frames_alloc_sz = MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE +\r\n(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE *\r\n(max_cmd + 1));\r\nfusion->max_sge_in_main_msg =\r\n(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE -\r\noffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL))/16;\r\nfusion->max_sge_in_chain =\r\nMEGASAS_MAX_SZ_CHAIN_FRAME / sizeof(union MPI2_SGE_IO_UNION);\r\ninstance->max_num_sge = fusion->max_sge_in_main_msg +\r\nfusion->max_sge_in_chain - 2;\r\nfusion->chain_offset_mfi_pthru =\r\noffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL)/16;\r\nfusion->chain_offset_io_request =\r\n(MEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE -\r\nsizeof(union MPI2_SGE_IO_UNION))/16;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfor (i = 0 ; i < count; i++)\r\nfusion->last_reply_idx[i] = 0;\r\nif (megasas_alloc_cmds(instance))\r\ngoto fail_alloc_mfi_cmds;\r\nif (megasas_alloc_cmds_fusion(instance))\r\ngoto fail_alloc_cmds;\r\nif (megasas_ioc_init_fusion(instance))\r\ngoto fail_ioc_init;\r\ninstance->flag_ieee = 1;\r\nfusion->map_sz = sizeof(struct MR_FW_RAID_MAP) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *(MAX_LOGICAL_DRIVES - 1));\r\nfusion->fast_path_io = 0;\r\nfor (i = 0; i < 2; i++) {\r\nfusion->ld_map[i] = dma_alloc_coherent(&instance->pdev->dev,\r\nfusion->map_sz,\r\n&fusion->ld_map_phys[i],\r\nGFP_KERNEL);\r\nif (!fusion->ld_map[i]) {\r\nprintk(KERN_ERR "megasas: Could not allocate memory "\r\n"for map info\n");\r\ngoto fail_map_info;\r\n}\r\n}\r\nif (!megasas_get_map_info(instance))\r\nmegasas_sync_map_info(instance);\r\nreturn 0;\r\nfail_map_info:\r\nif (i == 1)\r\ndma_free_coherent(&instance->pdev->dev, fusion->map_sz,\r\nfusion->ld_map[0], fusion->ld_map_phys[0]);\r\nfail_ioc_init:\r\nmegasas_free_cmds_fusion(instance);\r\nfail_alloc_cmds:\r\nmegasas_free_cmds(instance);\r\nfail_alloc_mfi_cmds:\r\nreturn 1;\r\n}\r\nvoid\r\nmegasas_fire_cmd_fusion(struct megasas_instance *instance,\r\ndma_addr_t req_desc_lo,\r\nu32 req_desc_hi,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel(req_desc_lo,\r\n&(regs)->inbound_low_queue_port);\r\nwritel(req_desc_hi, &(regs)->inbound_high_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nvoid\r\nmap_cmd_status(struct megasas_cmd_fusion *cmd, u8 status, u8 ext_status)\r\n{\r\nswitch (status) {\r\ncase MFI_STAT_OK:\r\ncmd->scmd->result = DID_OK << 16;\r\nbreak;\r\ncase MFI_STAT_SCSI_IO_FAILED:\r\ncase MFI_STAT_LD_INIT_IN_PROGRESS:\r\ncmd->scmd->result = (DID_ERROR << 16) | ext_status;\r\nbreak;\r\ncase MFI_STAT_SCSI_DONE_WITH_ERROR:\r\ncmd->scmd->result = (DID_OK << 16) | ext_status;\r\nif (ext_status == SAM_STAT_CHECK_CONDITION) {\r\nmemset(cmd->scmd->sense_buffer, 0,\r\nSCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->scmd->sense_buffer, cmd->sense,\r\nSCSI_SENSE_BUFFERSIZE);\r\ncmd->scmd->result |= DRIVER_SENSE << 24;\r\n}\r\nbreak;\r\ncase MFI_STAT_LD_OFFLINE:\r\ncase MFI_STAT_DEVICE_NOT_FOUND:\r\ncmd->scmd->result = DID_BAD_TARGET << 16;\r\nbreak;\r\ncase MFI_STAT_CONFIG_SEQ_MISMATCH:\r\ncmd->scmd->result = DID_IMM_RETRY << 16;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "megasas: FW status %#x\n", status);\r\ncmd->scmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nmegasas_make_sgl_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp,\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nint i, sg_processed, sge_count;\r\nstruct scatterlist *os_sgl;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nif (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr_end = sgl_ptr;\r\nsgl_ptr_end += fusion->max_sge_in_main_msg - 1;\r\nsgl_ptr_end->Flags = 0;\r\n}\r\nsge_count = scsi_dma_map(scp);\r\nBUG_ON(sge_count < 0);\r\nif (sge_count > instance->max_num_sge || !sge_count)\r\nreturn sge_count;\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nsgl_ptr->Length = sg_dma_len(os_sgl);\r\nsgl_ptr->Address = sg_dma_address(os_sgl);\r\nsgl_ptr->Flags = 0;\r\nif (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {\r\nif (i == sge_count - 1)\r\nsgl_ptr->Flags = IEEE_SGE_FLAGS_END_OF_LIST;\r\n}\r\nsgl_ptr++;\r\nsg_processed = i + 1;\r\nif ((sg_processed == (fusion->max_sge_in_main_msg - 1)) &&\r\n(sge_count > fusion->max_sge_in_main_msg)) {\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sg_chain;\r\nif (instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER) {\r\nif ((cmd->io_request->IoFlags &\r\nMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH) !=\r\nMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH)\r\ncmd->io_request->ChainOffset =\r\nfusion->\r\nchain_offset_io_request;\r\nelse\r\ncmd->io_request->ChainOffset = 0;\r\n} else\r\ncmd->io_request->ChainOffset =\r\nfusion->chain_offset_io_request;\r\nsg_chain = sgl_ptr;\r\nsg_chain->NextChainOffset = 0;\r\nif (instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER)\r\nsg_chain->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT;\r\nelse\r\nsg_chain->Flags =\r\n(IEEE_SGE_FLAGS_CHAIN_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR);\r\nsg_chain->Length = (sizeof(union MPI2_SGE_IO_UNION)\r\n*(sge_count - sg_processed));\r\nsg_chain->Address = cmd->sg_frame_phys_addr;\r\nsgl_ptr =\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)cmd->sg_frame;\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nvoid\r\nmegasas_set_pd_lba(struct MPI2_RAID_SCSI_IO_REQUEST *io_request, u8 cdb_len,\r\nstruct IO_REQUEST_INFO *io_info, struct scsi_cmnd *scp,\r\nstruct MR_FW_RAID_MAP_ALL *local_map_ptr, u32 ref_tag)\r\n{\r\nstruct MR_LD_RAID *raid;\r\nu32 ld;\r\nu64 start_blk = io_info->pdBlock;\r\nu8 *cdb = io_request->CDB.CDB32;\r\nu32 num_blocks = io_info->numBlocks;\r\nu8 opcode = 0, flagvals = 0, groupnum = 0, control = 0;\r\nld = MR_TargetIdToLdGet(io_info->ldTgtId, local_map_ptr);\r\nraid = MR_LdRaidGet(ld, local_map_ptr);\r\nif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER) {\r\nmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\r\ncdb[0] = MEGASAS_SCSI_VARIABLE_LENGTH_CMD;\r\ncdb[7] = MEGASAS_SCSI_ADDL_CDB_LEN;\r\nif (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\ncdb[9] = MEGASAS_SCSI_SERVICE_ACTION_READ32;\r\nelse\r\ncdb[9] = MEGASAS_SCSI_SERVICE_ACTION_WRITE32;\r\ncdb[10] = MEGASAS_RD_WR_PROTECT_CHECK_ALL;\r\ncdb[12] = (u8)((start_blk >> 56) & 0xff);\r\ncdb[13] = (u8)((start_blk >> 48) & 0xff);\r\ncdb[14] = (u8)((start_blk >> 40) & 0xff);\r\ncdb[15] = (u8)((start_blk >> 32) & 0xff);\r\ncdb[16] = (u8)((start_blk >> 24) & 0xff);\r\ncdb[17] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[18] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[19] = (u8)(start_blk & 0xff);\r\nio_request->CDB.EEDP32.PrimaryReferenceTag =\r\ncpu_to_be32(ref_tag);\r\nio_request->CDB.EEDP32.PrimaryApplicationTagMask = 0xffff;\r\nio_request->IoFlags = 32;\r\ncdb[28] = (u8)((num_blocks >> 24) & 0xff);\r\ncdb[29] = (u8)((num_blocks >> 16) & 0xff);\r\ncdb[30] = (u8)((num_blocks >> 8) & 0xff);\r\ncdb[31] = (u8)(num_blocks & 0xff);\r\nif (scp->sc_data_direction == PCI_DMA_FROMDEVICE) {\r\nio_request->EEDPFlags =\r\nMPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_APPTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;\r\n} else {\r\nio_request->EEDPFlags =\r\nMPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_INSERT_OP;\r\n}\r\nio_request->Control |= (0x4 << 26);\r\nio_request->EEDPBlockSize = MEGASAS_EEDPBLOCKSIZE;\r\n} else {\r\nif (((cdb_len == 12) || (cdb_len == 16)) &&\r\n(start_blk <= 0xffffffff)) {\r\nif (cdb_len == 16) {\r\nopcode = cdb[0] == READ_16 ? READ_10 : WRITE_10;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[14];\r\ncontrol = cdb[15];\r\n} else {\r\nopcode = cdb[0] == READ_12 ? READ_10 : WRITE_10;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[10];\r\ncontrol = cdb[11];\r\n}\r\nmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\r\ncdb[0] = opcode;\r\ncdb[1] = flagvals;\r\ncdb[6] = groupnum;\r\ncdb[9] = control;\r\ncdb[8] = (u8)(num_blocks & 0xff);\r\ncdb[7] = (u8)((num_blocks >> 8) & 0xff);\r\nio_request->IoFlags = 10;\r\ncdb_len = 10;\r\n} else if ((cdb_len < 16) && (start_blk > 0xffffffff)) {\r\nswitch (cdb_len) {\r\ncase 6:\r\nopcode = cdb[0] == READ_6 ? READ_16 : WRITE_16;\r\ncontrol = cdb[5];\r\nbreak;\r\ncase 10:\r\nopcode =\r\ncdb[0] == READ_10 ? READ_16 : WRITE_16;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[6];\r\ncontrol = cdb[9];\r\nbreak;\r\ncase 12:\r\nopcode =\r\ncdb[0] == READ_12 ? READ_16 : WRITE_16;\r\nflagvals = cdb[1];\r\ngroupnum = cdb[10];\r\ncontrol = cdb[11];\r\nbreak;\r\n}\r\nmemset(cdb, 0, sizeof(io_request->CDB.CDB32));\r\ncdb[0] = opcode;\r\ncdb[1] = flagvals;\r\ncdb[14] = groupnum;\r\ncdb[15] = control;\r\ncdb[13] = (u8)(num_blocks & 0xff);\r\ncdb[12] = (u8)((num_blocks >> 8) & 0xff);\r\ncdb[11] = (u8)((num_blocks >> 16) & 0xff);\r\ncdb[10] = (u8)((num_blocks >> 24) & 0xff);\r\nio_request->IoFlags = 16;\r\ncdb_len = 16;\r\n}\r\nswitch (cdb_len) {\r\ncase 6:\r\n{\r\nu8 val = cdb[1] & 0xE0;\r\ncdb[3] = (u8)(start_blk & 0xff);\r\ncdb[2] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[1] = val | ((u8)(start_blk >> 16) & 0x1f);\r\nbreak;\r\n}\r\ncase 10:\r\ncdb[5] = (u8)(start_blk & 0xff);\r\ncdb[4] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[3] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[2] = (u8)((start_blk >> 24) & 0xff);\r\nbreak;\r\ncase 12:\r\ncdb[5] = (u8)(start_blk & 0xff);\r\ncdb[4] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[3] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[2] = (u8)((start_blk >> 24) & 0xff);\r\nbreak;\r\ncase 16:\r\ncdb[9] = (u8)(start_blk & 0xff);\r\ncdb[8] = (u8)((start_blk >> 8) & 0xff);\r\ncdb[7] = (u8)((start_blk >> 16) & 0xff);\r\ncdb[6] = (u8)((start_blk >> 24) & 0xff);\r\ncdb[5] = (u8)((start_blk >> 32) & 0xff);\r\ncdb[4] = (u8)((start_blk >> 40) & 0xff);\r\ncdb[3] = (u8)((start_blk >> 48) & 0xff);\r\ncdb[2] = (u8)((start_blk >> 56) & 0xff);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid\r\nmegasas_build_ldio_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nu8 fp_possible;\r\nu32 start_lba_lo, start_lba_hi, device_id, datalength = 0;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nstruct IO_REQUEST_INFO io_info;\r\nstruct fusion_context *fusion;\r\nstruct MR_FW_RAID_MAP_ALL *local_map_ptr;\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scp);\r\nfusion = instance->ctrl_context;\r\nio_request = cmd->io_request;\r\nio_request->RaidContext.VirtualDiskTgtId = device_id;\r\nio_request->RaidContext.status = 0;\r\nio_request->RaidContext.exStatus = 0;\r\nreq_desc = (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)cmd->request_desc;\r\nstart_lba_lo = 0;\r\nstart_lba_hi = 0;\r\nfp_possible = 0;\r\nif (scp->cmd_len == 6) {\r\ndatalength = (u32) scp->cmnd[4];\r\nstart_lba_lo = ((u32) scp->cmnd[1] << 16) |\r\n((u32) scp->cmnd[2] << 8) | (u32) scp->cmnd[3];\r\nstart_lba_lo &= 0x1FFFFF;\r\n}\r\nelse if (scp->cmd_len == 10) {\r\ndatalength = (u32) scp->cmnd[8] |\r\n((u32) scp->cmnd[7] << 8);\r\nstart_lba_lo = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nelse if (scp->cmd_len == 12) {\r\ndatalength = ((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\r\nstart_lba_lo = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nelse if (scp->cmd_len == 16) {\r\ndatalength = ((u32) scp->cmnd[10] << 24) |\r\n((u32) scp->cmnd[11] << 16) |\r\n((u32) scp->cmnd[12] << 8) | (u32) scp->cmnd[13];\r\nstart_lba_lo = ((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\r\nstart_lba_hi = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nmemset(&io_info, 0, sizeof(struct IO_REQUEST_INFO));\r\nio_info.ldStartBlock = ((u64)start_lba_hi << 32) | start_lba_lo;\r\nio_info.numBlocks = datalength;\r\nio_info.ldTgtId = device_id;\r\nio_request->DataLength = scsi_bufflen(scp);\r\nif (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nio_info.isRead = 1;\r\nlocal_map_ptr = fusion->ld_map[(instance->map_id & 1)];\r\nif ((MR_TargetIdToLdGet(device_id, local_map_ptr) >=\r\nMAX_LOGICAL_DRIVES) || (!fusion->fast_path_io)) {\r\nio_request->RaidContext.regLockFlags = 0;\r\nfp_possible = 0;\r\n} else {\r\nif (MR_BuildRaidContext(instance, &io_info,\r\n&io_request->RaidContext,\r\nlocal_map_ptr))\r\nfp_possible = io_info.fpOkForIo;\r\n}\r\ncmd->request_desc->SCSIIO.MSIxIndex = instance->msix_vectors ?\r\nsmp_processor_id() % instance->msix_vectors : 0;\r\nif (fp_possible) {\r\nmegasas_set_pd_lba(io_request, scp->cmd_len, &io_info, scp,\r\nlocal_map_ptr, start_lba_lo);\r\nio_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY\r\n<< MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nif (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {\r\nif (io_request->RaidContext.regLockFlags ==\r\nREGION_TYPE_UNUSED)\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nio_request->RaidContext.Type = MPI2_TYPE_CUDA;\r\nio_request->RaidContext.nseg = 0x1;\r\nio_request->IoFlags |=\r\nMPI25_SAS_DEVICE0_FLAGS_ENABLED_FAST_PATH;\r\nio_request->RaidContext.regLockFlags |=\r\n(MR_RL_FLAGS_GRANT_DESTINATION_CUDA |\r\nMR_RL_FLAGS_SEQ_NUM_ENABLE);\r\n}\r\nif ((fusion->load_balance_info[device_id].loadBalanceFlag) &&\r\n(io_info.isRead)) {\r\nio_info.devHandle =\r\nget_updated_dev_handle(\r\n&fusion->load_balance_info[device_id],\r\n&io_info);\r\nscp->SCp.Status |= MEGASAS_LOAD_BALANCE_FLAG;\r\n} else\r\nscp->SCp.Status &= ~MEGASAS_LOAD_BALANCE_FLAG;\r\ncmd->request_desc->SCSIIO.DevHandle = io_info.devHandle;\r\nio_request->DevHandle = io_info.devHandle;\r\n} else {\r\nio_request->RaidContext.timeoutValue =\r\nlocal_map_ptr->raidMap.fpPdIoTimeoutSec;\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_LD_IO\r\n<< MEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nif (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {\r\nif (io_request->RaidContext.regLockFlags ==\r\nREGION_TYPE_UNUSED)\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MEGASAS_REQ_DESCRIPT_FLAGS_NO_LOCK <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nio_request->RaidContext.Type = MPI2_TYPE_CUDA;\r\nio_request->RaidContext.regLockFlags |=\r\n(MR_RL_FLAGS_GRANT_DESTINATION_CPU0 |\r\nMR_RL_FLAGS_SEQ_NUM_ENABLE);\r\nio_request->RaidContext.nseg = 0x1;\r\n}\r\nio_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\r\nio_request->DevHandle = device_id;\r\n}\r\n}\r\nstatic void\r\nmegasas_build_dcdb_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nu32 device_id;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request;\r\nu16 pd_index = 0;\r\nstruct MR_FW_RAID_MAP_ALL *local_map_ptr;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nio_request = cmd->io_request;\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scmd);\r\npd_index = (scmd->device->channel * MEGASAS_MAX_DEV_PER_CHANNEL)\r\n+scmd->device->id;\r\nlocal_map_ptr = fusion->ld_map[(instance->map_id & 1)];\r\nif (scmd->device->channel < MEGASAS_MAX_PD_CHANNELS &&\r\ninstance->pd_list[pd_index].driveState == MR_PD_STATE_SYSTEM) {\r\nio_request->Function = 0;\r\nio_request->DevHandle =\r\nlocal_map_ptr->raidMap.devHndlInfo[device_id].curDevHdl;\r\nio_request->RaidContext.timeoutValue =\r\nlocal_map_ptr->raidMap.fpPdIoTimeoutSec;\r\nio_request->RaidContext.regLockFlags = 0;\r\nio_request->RaidContext.regLockRowLBA = 0;\r\nio_request->RaidContext.regLockLength = 0;\r\nio_request->RaidContext.RAIDFlags =\r\nMR_RAID_FLAGS_IO_SUB_TYPE_SYSTEM_PD <<\r\nMR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT;\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\ncmd->request_desc->SCSIIO.DevHandle =\r\nlocal_map_ptr->raidMap.devHndlInfo[device_id].curDevHdl;\r\n} else {\r\nio_request->Function = MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST;\r\nio_request->DevHandle = device_id;\r\ncmd->request_desc->SCSIIO.RequestFlags =\r\n(MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\n}\r\nio_request->RaidContext.VirtualDiskTgtId = device_id;\r\nio_request->LUN[1] = scmd->device->lun;\r\nio_request->DataLength = scsi_bufflen(scmd);\r\n}\r\nint\r\nmegasas_build_io_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp,\r\nstruct megasas_cmd_fusion *cmd)\r\n{\r\nu32 device_id, sge_count;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_request = cmd->io_request;\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scp);\r\nio_request->LUN[1] = 0;\r\nio_request->CDB.EEDP32.PrimaryReferenceTag = 0;\r\nio_request->CDB.EEDP32.PrimaryApplicationTagMask = 0;\r\nio_request->EEDPFlags = 0;\r\nio_request->Control = 0;\r\nio_request->EEDPBlockSize = 0;\r\nio_request->ChainOffset = 0;\r\nio_request->RaidContext.RAIDFlags = 0;\r\nio_request->RaidContext.Type = 0;\r\nio_request->RaidContext.nseg = 0;\r\nmemcpy(io_request->CDB.CDB32, scp->cmnd, scp->cmd_len);\r\nio_request->IoFlags = scp->cmd_len;\r\nif (megasas_is_ldio(scp))\r\nmegasas_build_ldio_fusion(instance, scp, cmd);\r\nelse\r\nmegasas_build_dcdb_fusion(instance, scp, cmd);\r\nsge_count =\r\nmegasas_make_sgl_fusion(instance, scp,\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)\r\n&io_request->SGL, cmd);\r\nif (sge_count > instance->max_num_sge) {\r\nprintk(KERN_ERR "megasas: Error. sge_count (0x%x) exceeds "\r\n"max (0x%x) allowed\n", sge_count,\r\ninstance->max_num_sge);\r\nreturn 1;\r\n}\r\nio_request->RaidContext.numSGE = sge_count;\r\nio_request->SGLFlags = MPI2_SGE_FLAGS_64_BIT_ADDRESSING;\r\nif (scp->sc_data_direction == PCI_DMA_TODEVICE)\r\nio_request->Control |= MPI2_SCSIIO_CONTROL_WRITE;\r\nelse if (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nio_request->Control |= MPI2_SCSIIO_CONTROL_READ;\r\nio_request->SGLOffset0 =\r\noffsetof(struct MPI2_RAID_SCSI_IO_REQUEST, SGL) / 4;\r\nio_request->SenseBufferLowAddress = cmd->sense_phys_addr;\r\nio_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\r\ncmd->scmd = scp;\r\nscp->SCp.ptr = (char *)cmd;\r\nreturn 0;\r\n}\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *\r\nmegasas_get_request_descriptor(struct megasas_instance *instance, u16 index)\r\n{\r\nu8 *p;\r\nstruct fusion_context *fusion;\r\nif (index >= instance->max_fw_cmds) {\r\nprintk(KERN_ERR "megasas: Invalid SMID (0x%x)request for "\r\n"descriptor\n", index);\r\nreturn NULL;\r\n}\r\nfusion = instance->ctrl_context;\r\np = fusion->req_frames_desc\r\n+sizeof(union MEGASAS_REQUEST_DESCRIPTOR_UNION) *index;\r\nreturn (union MEGASAS_REQUEST_DESCRIPTOR_UNION *)p;\r\n}\r\nstatic u32\r\nmegasas_build_and_issue_cmd_fusion(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_cmd_fusion *cmd;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nu32 index;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\ncmd = megasas_get_cmd_fusion(instance);\r\nif (!cmd)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nindex = cmd->index;\r\nreq_desc = megasas_get_request_descriptor(instance, index-1);\r\nif (!req_desc)\r\nreturn 1;\r\nreq_desc->Words = 0;\r\ncmd->request_desc = req_desc;\r\nif (megasas_build_io_fusion(instance, scmd, cmd)) {\r\nmegasas_return_cmd_fusion(instance, cmd);\r\nprintk(KERN_ERR "megasas: Error building command.\n");\r\ncmd->request_desc = NULL;\r\nreturn 1;\r\n}\r\nreq_desc = cmd->request_desc;\r\nreq_desc->SCSIIO.SMID = index;\r\nif (cmd->io_request->ChainOffset != 0 &&\r\ncmd->io_request->ChainOffset != 0xF)\r\nprintk(KERN_ERR "megasas: The chain offset value is not "\r\n"correct : %x\n", cmd->io_request->ChainOffset);\r\natomic_inc(&instance->fw_outstanding);\r\ninstance->instancet->fire_cmd(instance,\r\nreq_desc->u.low, req_desc->u.high,\r\ninstance->reg_set);\r\nreturn 0;\r\n}\r\nint\r\ncomplete_cmd_fusion(struct megasas_instance *instance, u32 MSIxIndex)\r\n{\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *desc;\r\nstruct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *reply_desc;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *scsi_io_req;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd *cmd_mfi;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nu16 smid, num_completed;\r\nu8 reply_descript_type, arm;\r\nu32 status, extStatus, device_id;\r\nunion desc_value d_val;\r\nstruct LD_LOAD_BALANCE_INFO *lbinfo;\r\nfusion = instance->ctrl_context;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR)\r\nreturn IRQ_HANDLED;\r\ndesc = fusion->reply_frames_desc;\r\ndesc += ((MSIxIndex * fusion->reply_alloc_sz)/\r\nsizeof(union MPI2_REPLY_DESCRIPTORS_UNION)) +\r\nfusion->last_reply_idx[MSIxIndex];\r\nreply_desc = (struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;\r\nd_val.word = desc->Words;\r\nreply_descript_type = reply_desc->ReplyFlags &\r\nMPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\r\nif (reply_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\r\nreturn IRQ_NONE;\r\nnum_completed = 0;\r\nwhile ((d_val.u.low != UINT_MAX) && (d_val.u.high != UINT_MAX)) {\r\nsmid = reply_desc->SMID;\r\ncmd_fusion = fusion->cmd_list[smid - 1];\r\nscsi_io_req =\r\n(struct MPI2_RAID_SCSI_IO_REQUEST *)\r\ncmd_fusion->io_request;\r\nif (cmd_fusion->scmd)\r\ncmd_fusion->scmd->SCp.ptr = NULL;\r\nstatus = scsi_io_req->RaidContext.status;\r\nextStatus = scsi_io_req->RaidContext.exStatus;\r\nswitch (scsi_io_req->Function) {\r\ncase MPI2_FUNCTION_SCSI_IO_REQUEST:\r\ndevice_id = MEGASAS_DEV_INDEX(instance,\r\ncmd_fusion->scmd);\r\nlbinfo = &fusion->load_balance_info[device_id];\r\nif (cmd_fusion->scmd->SCp.Status &\r\nMEGASAS_LOAD_BALANCE_FLAG) {\r\narm = lbinfo->raid1DevHandle[0] ==\r\ncmd_fusion->io_request->DevHandle ? 0 :\r\n1;\r\natomic_dec(&lbinfo->scsi_pending_cmds[arm]);\r\ncmd_fusion->scmd->SCp.Status &=\r\n~MEGASAS_LOAD_BALANCE_FLAG;\r\n}\r\nif (reply_descript_type ==\r\nMPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS) {\r\nif (megasas_dbg_lvl == 5)\r\nprintk(KERN_ERR "\nmegasas: FAST Path "\r\n"IO Success\n");\r\n}\r\ncase MEGASAS_MPI2_FUNCTION_LD_IO_REQUEST:\r\nmap_cmd_status(cmd_fusion, status, extStatus);\r\nscsi_dma_unmap(cmd_fusion->scmd);\r\ncmd_fusion->scmd->scsi_done(cmd_fusion->scmd);\r\nscsi_io_req->RaidContext.status = 0;\r\nscsi_io_req->RaidContext.exStatus = 0;\r\nmegasas_return_cmd_fusion(instance, cmd_fusion);\r\natomic_dec(&instance->fw_outstanding);\r\nbreak;\r\ncase MEGASAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST:\r\ncmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\r\nmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\r\ncmd_fusion->flags = 0;\r\nmegasas_return_cmd_fusion(instance, cmd_fusion);\r\nbreak;\r\n}\r\nfusion->last_reply_idx[MSIxIndex]++;\r\nif (fusion->last_reply_idx[MSIxIndex] >=\r\nfusion->reply_q_depth)\r\nfusion->last_reply_idx[MSIxIndex] = 0;\r\ndesc->Words = ULLONG_MAX;\r\nnum_completed++;\r\nif (!fusion->last_reply_idx[MSIxIndex])\r\ndesc = fusion->reply_frames_desc +\r\n((MSIxIndex * fusion->reply_alloc_sz)/\r\nsizeof(union MPI2_REPLY_DESCRIPTORS_UNION));\r\nelse\r\ndesc++;\r\nreply_desc =\r\n(struct MPI2_SCSI_IO_SUCCESS_REPLY_DESCRIPTOR *)desc;\r\nd_val.word = desc->Words;\r\nreply_descript_type = reply_desc->ReplyFlags &\r\nMPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\r\nif (reply_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\r\nbreak;\r\n}\r\nif (!num_completed)\r\nreturn IRQ_NONE;\r\nwmb();\r\nwritel((MSIxIndex << 24) | fusion->last_reply_idx[MSIxIndex],\r\n&instance->reg_set->reply_post_host_index);\r\nmegasas_check_and_restore_queue_depth(instance);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid\r\nmegasas_complete_cmd_dpc_fusion(unsigned long instance_addr)\r\n{\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *)instance_addr;\r\nunsigned long flags;\r\nu32 count, MSIxIndex;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nfor (MSIxIndex = 0 ; MSIxIndex < count; MSIxIndex++)\r\ncomplete_cmd_fusion(instance, MSIxIndex);\r\n}\r\nirqreturn_t megasas_isr_fusion(int irq, void *devp)\r\n{\r\nstruct megasas_irq_context *irq_context = devp;\r\nstruct megasas_instance *instance = irq_context->instance;\r\nu32 mfiStatus, fw_state;\r\nif (!instance->msix_vectors) {\r\nmfiStatus = instance->instancet->clear_intr(instance->reg_set);\r\nif (!mfiStatus)\r\nreturn IRQ_NONE;\r\n}\r\nif (test_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags)) {\r\ninstance->instancet->clear_intr(instance->reg_set);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!complete_cmd_fusion(instance, irq_context->MSIxIndex)) {\r\ninstance->instancet->clear_intr(instance->reg_set);\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif (fw_state == MFI_STATE_FAULT)\r\nschedule_work(&instance->work_init);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nu8\r\nbuild_mpt_mfi_pass_thru(struct megasas_instance *instance,\r\nstruct megasas_cmd *mfi_cmd)\r\n{\r\nstruct MPI25_IEEE_SGE_CHAIN64 *mpi25_ieee_chain;\r\nstruct MPI2_RAID_SCSI_IO_REQUEST *io_req;\r\nstruct megasas_cmd_fusion *cmd;\r\nstruct fusion_context *fusion;\r\nstruct megasas_header *frame_hdr = &mfi_cmd->frame->hdr;\r\ncmd = megasas_get_cmd_fusion(instance);\r\nif (!cmd)\r\nreturn 1;\r\nmfi_cmd->context.smid = cmd->index;\r\ncmd->sync_cmd_idx = mfi_cmd->index;\r\nif (frame_hdr->flags & MFI_FRAME_DONT_POST_IN_REPLY_QUEUE)\r\ncmd->flags = MFI_FRAME_DONT_POST_IN_REPLY_QUEUE;\r\nfusion = instance->ctrl_context;\r\nio_req = cmd->io_request;\r\nif (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) {\r\nstruct MPI25_IEEE_SGE_CHAIN64 *sgl_ptr_end =\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)&io_req->SGL;\r\nsgl_ptr_end += fusion->max_sge_in_main_msg - 1;\r\nsgl_ptr_end->Flags = 0;\r\n}\r\nmpi25_ieee_chain =\r\n(struct MPI25_IEEE_SGE_CHAIN64 *)&io_req->SGL.IeeeChain;\r\nio_req->Function = MEGASAS_MPI2_FUNCTION_PASSTHRU_IO_REQUEST;\r\nio_req->SGLOffset0 = offsetof(struct MPI2_RAID_SCSI_IO_REQUEST,\r\nSGL) / 4;\r\nio_req->ChainOffset = fusion->chain_offset_mfi_pthru;\r\nmpi25_ieee_chain->Address = mfi_cmd->frame_phys_addr;\r\nmpi25_ieee_chain->Flags = IEEE_SGE_FLAGS_CHAIN_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_IOCPLBNTA_ADDR;\r\nmpi25_ieee_chain->Length = MEGASAS_MAX_SZ_CHAIN_FRAME;\r\nreturn 0;\r\n}\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *\r\nbuild_mpt_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nu16 index;\r\nif (build_mpt_mfi_pass_thru(instance, cmd)) {\r\nprintk(KERN_ERR "Couldn't build MFI pass thru cmd\n");\r\nreturn NULL;\r\n}\r\nindex = cmd->context.smid;\r\nreq_desc = megasas_get_request_descriptor(instance, index - 1);\r\nif (!req_desc)\r\nreturn NULL;\r\nreq_desc->Words = 0;\r\nreq_desc->SCSIIO.RequestFlags = (MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO <<\r\nMEGASAS_REQ_DESCRIPT_FLAGS_TYPE_SHIFT);\r\nreq_desc->SCSIIO.SMID = index;\r\nreturn req_desc;\r\n}\r\nvoid\r\nmegasas_issue_dcmd_fusion(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nreq_desc = build_mpt_cmd(instance, cmd);\r\nif (!req_desc) {\r\nprintk(KERN_ERR "Couldn't issue MFI pass thru cmd\n");\r\nreturn;\r\n}\r\ninstance->instancet->fire_cmd(instance, req_desc->u.low,\r\nreq_desc->u.high, instance->reg_set);\r\n}\r\nvoid\r\nmegasas_release_fusion(struct megasas_instance *instance)\r\n{\r\nmegasas_free_cmds(instance);\r\nmegasas_free_cmds_fusion(instance);\r\niounmap(instance->reg_set);\r\npci_release_selected_regions(instance->pdev, instance->bar);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_fusion(struct megasas_register_set __iomem *regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_adp_reset_fusion(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_check_reset_fusion(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nreturn 0;\r\n}\r\nint megasas_wait_for_outstanding_fusion(struct megasas_instance *instance)\r\n{\r\nint i, outstanding, retval = 0;\r\nu32 fw_state;\r\nfor (i = 0; i < resetwaittime; i++) {\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif (fw_state == MFI_STATE_FAULT) {\r\nprintk(KERN_WARNING "megasas: Found FW in FAULT state,"\r\n" will reset adapter.\n");\r\nretval = 1;\r\ngoto out;\r\n}\r\noutstanding = atomic_read(&instance->fw_outstanding);\r\nif (!outstanding)\r\ngoto out;\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: [%2d]waiting for %d "\r\n"commands to complete\n", i, outstanding);\r\nmegasas_complete_cmd_dpc_fusion(\r\n(unsigned long)instance);\r\n}\r\nmsleep(1000);\r\n}\r\nif (atomic_read(&instance->fw_outstanding)) {\r\nprintk("megaraid_sas: pending commands remain after waiting, "\r\n"will reset adapter.\n");\r\nretval = 1;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nvoid megasas_reset_reply_desc(struct megasas_instance *instance)\r\n{\r\nint i, count;\r\nstruct fusion_context *fusion;\r\nunion MPI2_REPLY_DESCRIPTORS_UNION *reply_desc;\r\nfusion = instance->ctrl_context;\r\ncount = instance->msix_vectors > 0 ? instance->msix_vectors : 1;\r\nfor (i = 0 ; i < count ; i++)\r\nfusion->last_reply_idx[i] = 0;\r\nreply_desc = fusion->reply_frames_desc;\r\nfor (i = 0 ; i < fusion->reply_q_depth * count; i++, reply_desc++)\r\nreply_desc->Words = ULLONG_MAX;\r\n}\r\nint megasas_reset_fusion(struct Scsi_Host *shost)\r\n{\r\nint retval = SUCCESS, i, j, retry = 0;\r\nstruct megasas_instance *instance;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct fusion_context *fusion;\r\nstruct megasas_cmd *cmd_mfi;\r\nunion MEGASAS_REQUEST_DESCRIPTOR_UNION *req_desc;\r\nu32 host_diag, abs_state, status_reg, reset_adapter;\r\ninstance = (struct megasas_instance *)shost->hostdata;\r\nfusion = instance->ctrl_context;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nprintk(KERN_WARNING "megaraid_sas: Hardware critical error, "\r\n"returning FAILED.\n");\r\nreturn FAILED;\r\n}\r\nmutex_lock(&instance->reset_mutex);\r\nset_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\r\ninstance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nmsleep(1000);\r\nif (megasas_wait_for_outstanding_fusion(instance)) {\r\nprintk(KERN_WARNING "megaraid_sas: resetting fusion "\r\n"adapter.\n");\r\nfor (i = 0 ; i < instance->max_fw_cmds; i++) {\r\ncmd_fusion = fusion->cmd_list[i];\r\nif (cmd_fusion->scmd) {\r\nscsi_dma_unmap(cmd_fusion->scmd);\r\ncmd_fusion->scmd->result = (DID_RESET << 16);\r\ncmd_fusion->scmd->scsi_done(cmd_fusion->scmd);\r\nmegasas_return_cmd_fusion(instance, cmd_fusion);\r\natomic_dec(&instance->fw_outstanding);\r\n}\r\n}\r\nstatus_reg = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set);\r\nabs_state = status_reg & MFI_STATE_MASK;\r\nreset_adapter = status_reg & MFI_RESET_ADAPTER;\r\nif (instance->disableOnlineCtrlReset ||\r\n(abs_state == MFI_STATE_FAULT && !reset_adapter)) {\r\nprintk(KERN_WARNING "megaraid_sas: Reset not supported"\r\n", killing adapter.\n");\r\nmegaraid_sas_kill_hba(instance);\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nfor (i = 0; i < MEGASAS_FUSION_MAX_RESET_TRIES; i++) {\r\nwritel(MPI2_WRSEQ_FLUSH_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_1ST_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_2ND_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_3RD_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_4TH_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_5TH_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nwritel(MPI2_WRSEQ_6TH_KEY_VALUE,\r\n&instance->reg_set->fusion_seq_offset);\r\nhost_diag = readl(&instance->reg_set->fusion_host_diag);\r\nretry = 0;\r\nwhile (!(host_diag & HOST_DIAG_WRITE_ENABLE)) {\r\nmsleep(100);\r\nhost_diag =\r\nreadl(&instance->reg_set->fusion_host_diag);\r\nif (retry++ == 100) {\r\nprintk(KERN_WARNING "megaraid_sas: "\r\n"Host diag unlock failed!\n");\r\nbreak;\r\n}\r\n}\r\nif (!(host_diag & HOST_DIAG_WRITE_ENABLE))\r\ncontinue;\r\nwritel(host_diag | HOST_DIAG_RESET_ADAPTER,\r\n&instance->reg_set->fusion_host_diag);\r\nmsleep(3000);\r\nhost_diag = readl(&instance->reg_set->fusion_host_diag);\r\nretry = 0;\r\nwhile (host_diag & HOST_DIAG_RESET_ADAPTER) {\r\nmsleep(100);\r\nhost_diag =\r\nreadl(&instance->reg_set->fusion_host_diag);\r\nif (retry++ == 1000) {\r\nprintk(KERN_WARNING "megaraid_sas: "\r\n"Diag reset adapter never "\r\n"cleared!\n");\r\nbreak;\r\n}\r\n}\r\nif (host_diag & HOST_DIAG_RESET_ADAPTER)\r\ncontinue;\r\nabs_state =\r\ninstance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nretry = 0;\r\nwhile ((abs_state <= MFI_STATE_FW_INIT) &&\r\n(retry++ < 1000)) {\r\nmsleep(100);\r\nabs_state =\r\ninstance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\n}\r\nif (abs_state <= MFI_STATE_FW_INIT) {\r\nprintk(KERN_WARNING "megaraid_sas: firmware "\r\n"state < MFI_STATE_FW_INIT, state = "\r\n"0x%x\n", abs_state);\r\ncontinue;\r\n}\r\nif (megasas_transition_to_ready(instance, 1)) {\r\nprintk(KERN_WARNING "megaraid_sas: Failed to "\r\n"transition controller to ready.\n");\r\ncontinue;\r\n}\r\nmegasas_reset_reply_desc(instance);\r\nif (megasas_ioc_init_fusion(instance)) {\r\nprintk(KERN_WARNING "megaraid_sas: "\r\n"megasas_ioc_init_fusion() failed!\n");\r\ncontinue;\r\n}\r\nclear_bit(MEGASAS_FUSION_IN_RESET,\r\n&instance->reset_flags);\r\ninstance->instancet->enable_intr(instance->reg_set);\r\ninstance->adprecovery = MEGASAS_HBA_OPERATIONAL;\r\nfor (j = 0 ; j < instance->max_fw_cmds; j++) {\r\ncmd_fusion = fusion->cmd_list[j];\r\nif (cmd_fusion->sync_cmd_idx !=\r\n(u32)ULONG_MAX) {\r\ncmd_mfi =\r\ninstance->\r\ncmd_list[cmd_fusion->sync_cmd_idx];\r\nif (cmd_mfi->frame->dcmd.opcode ==\r\nMR_DCMD_LD_MAP_GET_INFO) {\r\nmegasas_return_cmd(instance,\r\ncmd_mfi);\r\nmegasas_return_cmd_fusion(\r\ninstance, cmd_fusion);\r\n} else {\r\nreq_desc =\r\nmegasas_get_request_descriptor(\r\ninstance,\r\ncmd_mfi->context.smid\r\n-1);\r\nif (!req_desc)\r\nprintk(KERN_WARNING\r\n"req_desc NULL"\r\n"\n");\r\nelse {\r\ninstance->instancet->\r\nfire_cmd(instance,\r\nreq_desc->\r\nu.low,\r\nreq_desc->\r\nu.high,\r\ninstance->\r\nreg_set);\r\n}\r\n}\r\n}\r\n}\r\nmemset(fusion->load_balance_info, 0,\r\nsizeof(struct LD_LOAD_BALANCE_INFO)\r\n*MAX_LOGICAL_DRIVES);\r\nif (!megasas_get_map_info(instance))\r\nmegasas_sync_map_info(instance);\r\nprintk(KERN_WARNING "megaraid_sas: Reset "\r\n"successful.\n");\r\nretval = SUCCESS;\r\ngoto out;\r\n}\r\nprintk(KERN_WARNING "megaraid_sas: Reset failed, killing "\r\n"adapter.\n");\r\nmegaraid_sas_kill_hba(instance);\r\nretval = FAILED;\r\n} else {\r\nclear_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\r\ninstance->instancet->enable_intr(instance->reg_set);\r\ninstance->adprecovery = MEGASAS_HBA_OPERATIONAL;\r\n}\r\nout:\r\nclear_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags);\r\nmutex_unlock(&instance->reset_mutex);\r\nreturn retval;\r\n}\r\nvoid megasas_fusion_ocr_wq(struct work_struct *work)\r\n{\r\nstruct megasas_instance *instance =\r\ncontainer_of(work, struct megasas_instance, work_init);\r\nmegasas_reset_fusion(instance->host);\r\n}
