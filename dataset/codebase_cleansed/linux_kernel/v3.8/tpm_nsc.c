static int wait_for_stat(struct tpm_chip *chip, u8 mask, u8 val, u8 * data)\r\n{\r\nunsigned long stop;\r\n*data = inb(chip->vendor.base + NSC_STATUS);\r\nif ((*data & mask) == val)\r\nreturn 0;\r\nstop = jiffies + 10 * HZ;\r\ndo {\r\nmsleep(TPM_TIMEOUT);\r\n*data = inb(chip->vendor.base + 1);\r\nif ((*data & mask) == val)\r\nreturn 0;\r\n}\r\nwhile (time_before(jiffies, stop));\r\nreturn -EBUSY;\r\n}\r\nstatic int nsc_wait_for_ready(struct tpm_chip *chip)\r\n{\r\nint status;\r\nunsigned long stop;\r\nstatus = inb(chip->vendor.base + NSC_STATUS);\r\nif (status & NSC_STATUS_OBF)\r\nstatus = inb(chip->vendor.base + NSC_DATA);\r\nif (status & NSC_STATUS_RDY)\r\nreturn 0;\r\nstop = jiffies + 100;\r\ndo {\r\nmsleep(TPM_TIMEOUT);\r\nstatus = inb(chip->vendor.base + NSC_STATUS);\r\nif (status & NSC_STATUS_OBF)\r\nstatus = inb(chip->vendor.base + NSC_DATA);\r\nif (status & NSC_STATUS_RDY)\r\nreturn 0;\r\n}\r\nwhile (time_before(jiffies, stop));\r\ndev_info(chip->dev, "wait for ready failed\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int tpm_nsc_recv(struct tpm_chip *chip, u8 * buf, size_t count)\r\n{\r\nu8 *buffer = buf;\r\nu8 data, *p;\r\nu32 size;\r\n__be32 *native_size;\r\nif (count < 6)\r\nreturn -EIO;\r\nif (wait_for_stat(chip, NSC_STATUS_F0, NSC_STATUS_F0, &data) < 0) {\r\ndev_err(chip->dev, "F0 timeout\n");\r\nreturn -EIO;\r\n}\r\nif ((data =\r\ninb(chip->vendor.base + NSC_DATA)) != NSC_COMMAND_NORMAL) {\r\ndev_err(chip->dev, "not in normal mode (0x%x)\n",\r\ndata);\r\nreturn -EIO;\r\n}\r\nfor (p = buffer; p < &buffer[count]; p++) {\r\nif (wait_for_stat\r\n(chip, NSC_STATUS_OBF, NSC_STATUS_OBF, &data) < 0) {\r\ndev_err(chip->dev,\r\n"OBF timeout (while reading data)\n");\r\nreturn -EIO;\r\n}\r\nif (data & NSC_STATUS_F0)\r\nbreak;\r\n*p = inb(chip->vendor.base + NSC_DATA);\r\n}\r\nif ((data & NSC_STATUS_F0) == 0 &&\r\n(wait_for_stat(chip, NSC_STATUS_F0, NSC_STATUS_F0, &data) < 0)) {\r\ndev_err(chip->dev, "F0 not set\n");\r\nreturn -EIO;\r\n}\r\nif ((data = inb(chip->vendor.base + NSC_DATA)) != NSC_COMMAND_EOC) {\r\ndev_err(chip->dev,\r\n"expected end of command(0x%x)\n", data);\r\nreturn -EIO;\r\n}\r\nnative_size = (__force __be32 *) (buf + 2);\r\nsize = be32_to_cpu(*native_size);\r\nif (count < size)\r\nreturn -EIO;\r\nreturn size;\r\n}\r\nstatic int tpm_nsc_send(struct tpm_chip *chip, u8 * buf, size_t count)\r\n{\r\nu8 data;\r\nint i;\r\noutb(NSC_COMMAND_CANCEL, chip->vendor.base + NSC_COMMAND);\r\nif (nsc_wait_for_ready(chip) != 0)\r\nreturn -EIO;\r\nif (wait_for_stat(chip, NSC_STATUS_IBF, 0, &data) < 0) {\r\ndev_err(chip->dev, "IBF timeout\n");\r\nreturn -EIO;\r\n}\r\noutb(NSC_COMMAND_NORMAL, chip->vendor.base + NSC_COMMAND);\r\nif (wait_for_stat(chip, NSC_STATUS_IBR, NSC_STATUS_IBR, &data) < 0) {\r\ndev_err(chip->dev, "IBR timeout\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (wait_for_stat(chip, NSC_STATUS_IBF, 0, &data) < 0) {\r\ndev_err(chip->dev,\r\n"IBF timeout (while writing data)\n");\r\nreturn -EIO;\r\n}\r\noutb(buf[i], chip->vendor.base + NSC_DATA);\r\n}\r\nif (wait_for_stat(chip, NSC_STATUS_IBF, 0, &data) < 0) {\r\ndev_err(chip->dev, "IBF timeout\n");\r\nreturn -EIO;\r\n}\r\noutb(NSC_COMMAND_EOC, chip->vendor.base + NSC_COMMAND);\r\nreturn count;\r\n}\r\nstatic void tpm_nsc_cancel(struct tpm_chip *chip)\r\n{\r\noutb(NSC_COMMAND_CANCEL, chip->vendor.base + NSC_COMMAND);\r\n}\r\nstatic u8 tpm_nsc_status(struct tpm_chip *chip)\r\n{\r\nreturn inb(chip->vendor.base + NSC_STATUS);\r\n}\r\nstatic void tpm_nsc_remove(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nif ( chip ) {\r\nrelease_region(chip->vendor.base, 2);\r\ntpm_remove_hardware(chip->dev);\r\n}\r\n}\r\nstatic int __init init_nsc(void)\r\n{\r\nint rc = 0;\r\nint lo, hi, err;\r\nint nscAddrBase = TPM_ADDR;\r\nstruct tpm_chip *chip;\r\nunsigned long base;\r\nif (tpm_read_index(TPM_ADDR, NSC_SID_INDEX) != 0xEF) {\r\nnscAddrBase = (tpm_read_index(TPM_SUPERIO_ADDR, 0x2C)<<8)|\r\n(tpm_read_index(TPM_SUPERIO_ADDR, 0x2B)&0xFE);\r\nif (tpm_read_index(nscAddrBase, NSC_SID_INDEX) != 0xF6)\r\nreturn -ENODEV;\r\n}\r\nerr = platform_driver_register(&nsc_drv);\r\nif (err)\r\nreturn err;\r\nhi = tpm_read_index(nscAddrBase, TPM_NSC_BASE0_HI);\r\nlo = tpm_read_index(nscAddrBase, TPM_NSC_BASE0_LO);\r\nbase = (hi<<8) | lo;\r\ntpm_write_index(nscAddrBase, NSC_LDC_INDEX, 0x01);\r\npdev = platform_device_alloc("tpm_nscl0", -1);\r\nif (!pdev) {\r\nrc = -ENOMEM;\r\ngoto err_unreg_drv;\r\n}\r\npdev->num_resources = 0;\r\npdev->dev.driver = &nsc_drv.driver;\r\npdev->dev.release = tpm_nsc_remove;\r\nif ((rc = platform_device_add(pdev)) < 0)\r\ngoto err_put_dev;\r\nif (request_region(base, 2, "tpm_nsc0") == NULL ) {\r\nrc = -EBUSY;\r\ngoto err_del_dev;\r\n}\r\nif (!(chip = tpm_register_hardware(&pdev->dev, &tpm_nsc))) {\r\nrc = -ENODEV;\r\ngoto err_rel_reg;\r\n}\r\ndev_dbg(&pdev->dev, "NSC TPM detected\n");\r\ndev_dbg(&pdev->dev,\r\n"NSC LDN 0x%x, SID 0x%x, SRID 0x%x\n",\r\ntpm_read_index(nscAddrBase,0x07), tpm_read_index(nscAddrBase,0x20),\r\ntpm_read_index(nscAddrBase,0x27));\r\ndev_dbg(&pdev->dev,\r\n"NSC SIOCF1 0x%x SIOCF5 0x%x SIOCF6 0x%x SIOCF8 0x%x\n",\r\ntpm_read_index(nscAddrBase,0x21), tpm_read_index(nscAddrBase,0x25),\r\ntpm_read_index(nscAddrBase,0x26), tpm_read_index(nscAddrBase,0x28));\r\ndev_dbg(&pdev->dev, "NSC IO Base0 0x%x\n",\r\n(tpm_read_index(nscAddrBase,0x60) << 8) | tpm_read_index(nscAddrBase,0x61));\r\ndev_dbg(&pdev->dev, "NSC IO Base1 0x%x\n",\r\n(tpm_read_index(nscAddrBase,0x62) << 8) | tpm_read_index(nscAddrBase,0x63));\r\ndev_dbg(&pdev->dev, "NSC Interrupt number and wakeup 0x%x\n",\r\ntpm_read_index(nscAddrBase,0x70));\r\ndev_dbg(&pdev->dev, "NSC IRQ type select 0x%x\n",\r\ntpm_read_index(nscAddrBase,0x71));\r\ndev_dbg(&pdev->dev,\r\n"NSC DMA channel select0 0x%x, select1 0x%x\n",\r\ntpm_read_index(nscAddrBase,0x74), tpm_read_index(nscAddrBase,0x75));\r\ndev_dbg(&pdev->dev,\r\n"NSC Config "\r\n"0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",\r\ntpm_read_index(nscAddrBase,0xF0), tpm_read_index(nscAddrBase,0xF1),\r\ntpm_read_index(nscAddrBase,0xF2), tpm_read_index(nscAddrBase,0xF3),\r\ntpm_read_index(nscAddrBase,0xF4), tpm_read_index(nscAddrBase,0xF5),\r\ntpm_read_index(nscAddrBase,0xF6), tpm_read_index(nscAddrBase,0xF7),\r\ntpm_read_index(nscAddrBase,0xF8), tpm_read_index(nscAddrBase,0xF9));\r\ndev_info(&pdev->dev,\r\n"NSC TPM revision %d\n",\r\ntpm_read_index(nscAddrBase, 0x27) & 0x1F);\r\nchip->vendor.base = base;\r\nreturn 0;\r\nerr_rel_reg:\r\nrelease_region(base, 2);\r\nerr_del_dev:\r\nplatform_device_del(pdev);\r\nerr_put_dev:\r\nplatform_device_put(pdev);\r\nerr_unreg_drv:\r\nplatform_driver_unregister(&nsc_drv);\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_nsc(void)\r\n{\r\nif (pdev) {\r\ntpm_nsc_remove(&pdev->dev);\r\nplatform_device_unregister(pdev);\r\n}\r\nplatform_driver_unregister(&nsc_drv);\r\n}
