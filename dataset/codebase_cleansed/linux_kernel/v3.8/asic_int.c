static inline int get_int(void)\r\n{\r\nunsigned long flags;\r\nint irq;\r\nraw_spin_lock_irqsave(&asic_irq_lock, flags);\r\nirq = (asic_read(int_int_scan) >> 4) - 1;\r\nif (irq == 0 || irq >= NR_IRQS)\r\nirq = -1;\r\nraw_spin_unlock_irqrestore(&asic_irq_lock, flags);\r\nreturn irq;\r\n}\r\nstatic void asic_irqdispatch(void)\r\n{\r\nint irq;\r\nirq = get_int();\r\nif (irq < 0)\r\nreturn;\r\ndo_IRQ(irq);\r\n}\r\nstatic inline int clz(unsigned long x)\r\n{\r\n__asm__(\r\n" .set push \n"\r\n" .set mips32 \n"\r\n" clz %0, %1 \n"\r\n" .set pop \n"\r\n: "=r" (x)\r\n: "r" (x));\r\nreturn x;\r\n}\r\nstatic inline unsigned int irq_ffs(unsigned int pending)\r\n{\r\nreturn fls(pending) - 1 + CAUSEB_IP;\r\n}\r\nasmlinkage void plat_irq_dispatch(void)\r\n{\r\nunsigned int pending = read_c0_cause() & read_c0_status() & ST0_IM;\r\nint irq;\r\nirq = irq_ffs(pending);\r\nif (irq == CAUSEF_IP3)\r\nasic_irqdispatch();\r\nelse if (irq >= 0)\r\ndo_IRQ(irq);\r\nelse\r\nspurious_interrupt();\r\n}\r\nvoid __init arch_init_irq(void)\r\n{\r\nint i;\r\nasic_irq_init();\r\nif (cpu_has_veic || cpu_has_vint) {\r\nint nvec = cpu_has_veic ? 64 : 8;\r\nfor (i = 0; i < nvec; i++)\r\nset_vi_handler(i, asic_irqdispatch);\r\n}\r\n}
