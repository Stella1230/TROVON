static int get_tpkt_data(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo,\r\nunsigned char **data, int *datalen, int *dataoff)\r\n{\r\nstruct nf_ct_h323_master *info = nfct_help_data(ct);\r\nint dir = CTINFO2DIR(ctinfo);\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nint tcpdatalen;\r\nint tcpdataoff;\r\nunsigned char *tpkt;\r\nint tpktlen;\r\nint tpktoff;\r\nth = skb_header_pointer(skb, protoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn 0;\r\ntcpdataoff = protoff + th->doff * 4;\r\ntcpdatalen = skb->len - tcpdataoff;\r\nif (tcpdatalen <= 0)\r\ngoto clear_out;\r\nif (*data == NULL) {\r\ntpkt = skb_header_pointer(skb, tcpdataoff, tcpdatalen,\r\nh323_buffer);\r\nBUG_ON(tpkt == NULL);\r\nif (tcpdatalen < 4 || tpkt[0] != 0x03 || tpkt[1] != 0) {\r\nif (info->tpkt_len[dir] > 0) {\r\npr_debug("nf_ct_h323: previous packet "\r\n"indicated separate TPKT data of %hu "\r\n"bytes\n", info->tpkt_len[dir]);\r\nif (info->tpkt_len[dir] <= tcpdatalen) {\r\n*data = tpkt;\r\n*datalen = info->tpkt_len[dir];\r\n*dataoff = 0;\r\ngoto out;\r\n}\r\npr_debug("nf_ct_h323: fragmented TPKT\n");\r\ngoto clear_out;\r\n}\r\nreturn 0;\r\n}\r\ntpktoff = 0;\r\n} else {\r\ntpktoff = *dataoff + *datalen;\r\ntcpdatalen -= tpktoff;\r\nif (tcpdatalen <= 4)\r\ngoto clear_out;\r\ntpkt = *data + *datalen;\r\nif (tpkt[0] != 0x03 || tpkt[1] != 0)\r\ngoto clear_out;\r\n}\r\ntpktlen = tpkt[2] * 256 + tpkt[3];\r\nif (tpktlen < 4)\r\ngoto clear_out;\r\nif (tpktlen > tcpdatalen) {\r\nif (tcpdatalen == 4) {\r\npr_debug("nf_ct_h323: separate TPKT header indicates "\r\n"there will be TPKT data of %hu bytes\n",\r\ntpktlen - 4);\r\ninfo->tpkt_len[dir] = tpktlen - 4;\r\nreturn 0;\r\n}\r\npr_debug("nf_ct_h323: incomplete TPKT (fragmented?)\n");\r\ngoto clear_out;\r\n}\r\n*data = tpkt + 4;\r\n*datalen = tpktlen - 4;\r\n*dataoff = tpktoff + 4;\r\nout:\r\ninfo->tpkt_len[dir] = 0;\r\nreturn 1;\r\nclear_out:\r\ninfo->tpkt_len[dir] = 0;\r\nreturn 0;\r\n}\r\nstatic int get_h245_addr(struct nf_conn *ct, const unsigned char *data,\r\nH245_TransportAddress *taddr,\r\nunion nf_inet_addr *addr, __be16 *port)\r\n{\r\nconst unsigned char *p;\r\nint len;\r\nif (taddr->choice != eH245_TransportAddress_unicastAddress)\r\nreturn 0;\r\nswitch (taddr->unicastAddress.choice) {\r\ncase eUnicastAddress_iPAddress:\r\nif (nf_ct_l3num(ct) != AF_INET)\r\nreturn 0;\r\np = data + taddr->unicastAddress.iPAddress.network;\r\nlen = 4;\r\nbreak;\r\ncase eUnicastAddress_iP6Address:\r\nif (nf_ct_l3num(ct) != AF_INET6)\r\nreturn 0;\r\np = data + taddr->unicastAddress.iP6Address.network;\r\nlen = 16;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmemcpy(addr, p, len);\r\nmemset((void *)addr + len, 0, sizeof(*addr) - len);\r\nmemcpy(port, p + len, sizeof(__be16));\r\nreturn 1;\r\n}\r\nstatic int expect_rtp_rtcp(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nH245_TransportAddress *taddr)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\n__be16 rtp_port, rtcp_port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *rtp_exp;\r\nstruct nf_conntrack_expect *rtcp_exp;\r\ntypeof(nat_rtp_rtcp_hook) nat_rtp_rtcp;\r\nif (!get_h245_addr(ct, *data, taddr, &addr, &port) ||\r\nmemcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) ||\r\nport == 0)\r\nreturn 0;\r\nrtp_port = port & ~htons(1);\r\nrtcp_port = port | htons(1);\r\nif ((rtp_exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(rtp_exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nIPPROTO_UDP, NULL, &rtp_port);\r\nif ((rtcp_exp = nf_ct_expect_alloc(ct)) == NULL) {\r\nnf_ct_expect_put(rtp_exp);\r\nreturn -1;\r\n}\r\nnf_ct_expect_init(rtcp_exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nIPPROTO_UDP, NULL, &rtcp_port);\r\nif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nsizeof(ct->tuplehash[dir].tuple.src.u3)) &&\r\n(nat_rtp_rtcp = rcu_dereference(nat_rtp_rtcp_hook)) &&\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = nat_rtp_rtcp(skb, ct, ctinfo, protoff, data, dataoff,\r\ntaddr, port, rtp_port, rtp_exp, rtcp_exp);\r\n} else {\r\nif (nf_ct_expect_related(rtp_exp) == 0) {\r\nif (nf_ct_expect_related(rtcp_exp) == 0) {\r\npr_debug("nf_ct_h323: expect RTP ");\r\nnf_ct_dump_tuple(&rtp_exp->tuple);\r\npr_debug("nf_ct_h323: expect RTCP ");\r\nnf_ct_dump_tuple(&rtcp_exp->tuple);\r\n} else {\r\nnf_ct_unexpect_related(rtp_exp);\r\nret = -1;\r\n}\r\n} else\r\nret = -1;\r\n}\r\nnf_ct_expect_put(rtp_exp);\r\nnf_ct_expect_put(rtcp_exp);\r\nreturn ret;\r\n}\r\nstatic int expect_t120(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nH245_TransportAddress *taddr)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\ntypeof(nat_t120_hook) nat_t120;\r\nif (!get_h245_addr(ct, *data, taddr, &addr, &port) ||\r\nmemcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) ||\r\nport == 0)\r\nreturn 0;\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nIPPROTO_TCP, NULL, &port);\r\nexp->flags = NF_CT_EXPECT_PERMANENT;\r\nif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nsizeof(ct->tuplehash[dir].tuple.src.u3)) &&\r\n(nat_t120 = rcu_dereference(nat_t120_hook)) &&\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = nat_t120(skb, ct, ctinfo, protoff, data, dataoff, taddr,\r\nport, exp);\r\n} else {\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_h323: expect T.120 ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\n} else\r\nret = -1;\r\n}\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int process_h245_channel(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nH2250LogicalChannelParameters *channel)\r\n{\r\nint ret;\r\nif (channel->options & eH2250LogicalChannelParameters_mediaChannel) {\r\nret = expect_rtp_rtcp(skb, ct, ctinfo, protoff, data, dataoff,\r\n&channel->mediaChannel);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (channel->\r\noptions & eH2250LogicalChannelParameters_mediaControlChannel) {\r\nret = expect_rtp_rtcp(skb, ct, ctinfo, protoff, data, dataoff,\r\n&channel->mediaControlChannel);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_olc(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nOpenLogicalChannel *olc)\r\n{\r\nint ret;\r\npr_debug("nf_ct_h323: OpenLogicalChannel\n");\r\nif (olc->forwardLogicalChannelParameters.multiplexParameters.choice ==\r\neOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters)\r\n{\r\nret = process_h245_channel(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&olc->\r\nforwardLogicalChannelParameters.\r\nmultiplexParameters.\r\nh2250LogicalChannelParameters);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif ((olc->options &\r\neOpenLogicalChannel_reverseLogicalChannelParameters) &&\r\n(olc->reverseLogicalChannelParameters.options &\r\neOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters)\r\n&& (olc->reverseLogicalChannelParameters.multiplexParameters.\r\nchoice ==\r\neOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters))\r\n{\r\nret =\r\nprocess_h245_channel(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&olc->\r\nreverseLogicalChannelParameters.\r\nmultiplexParameters.\r\nh2250LogicalChannelParameters);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif ((olc->options & eOpenLogicalChannel_separateStack) &&\r\nolc->forwardLogicalChannelParameters.dataType.choice ==\r\neDataType_data &&\r\nolc->forwardLogicalChannelParameters.dataType.data.application.\r\nchoice == eDataApplicationCapability_application_t120 &&\r\nolc->forwardLogicalChannelParameters.dataType.data.application.\r\nt120.choice == eDataProtocolCapability_separateLANStack &&\r\nolc->separateStack.networkAddress.choice ==\r\neNetworkAccessParameters_networkAddress_localAreaAddress) {\r\nret = expect_t120(skb, ct, ctinfo, protoff, data, dataoff,\r\n&olc->separateStack.networkAddress.\r\nlocalAreaAddress);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_olca(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff, unsigned char **data, int dataoff,\r\nOpenLogicalChannelAck *olca)\r\n{\r\nH2250LogicalChannelAckParameters *ack;\r\nint ret;\r\npr_debug("nf_ct_h323: OpenLogicalChannelAck\n");\r\nif ((olca->options &\r\neOpenLogicalChannelAck_reverseLogicalChannelParameters) &&\r\n(olca->reverseLogicalChannelParameters.options &\r\neOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters)\r\n&& (olca->reverseLogicalChannelParameters.multiplexParameters.\r\nchoice ==\r\neOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters))\r\n{\r\nret = process_h245_channel(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&olca->\r\nreverseLogicalChannelParameters.\r\nmultiplexParameters.\r\nh2250LogicalChannelParameters);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif ((olca->options &\r\neOpenLogicalChannelAck_forwardMultiplexAckParameters) &&\r\n(olca->forwardMultiplexAckParameters.choice ==\r\neOpenLogicalChannelAck_forwardMultiplexAckParameters_h2250LogicalChannelAckParameters))\r\n{\r\nack = &olca->forwardMultiplexAckParameters.\r\nh2250LogicalChannelAckParameters;\r\nif (ack->options &\r\neH2250LogicalChannelAckParameters_mediaChannel) {\r\nret = expect_rtp_rtcp(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&ack->mediaChannel);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (ack->options &\r\neH2250LogicalChannelAckParameters_mediaControlChannel) {\r\nret = expect_rtp_rtcp(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&ack->mediaControlChannel);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nif ((olca->options & eOpenLogicalChannelAck_separateStack) &&\r\nolca->separateStack.networkAddress.choice ==\r\neNetworkAccessParameters_networkAddress_localAreaAddress) {\r\nret = expect_t120(skb, ct, ctinfo, protoff, data, dataoff,\r\n&olca->separateStack.networkAddress.\r\nlocalAreaAddress);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_h245(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff, unsigned char **data, int dataoff,\r\nMultimediaSystemControlMessage *mscm)\r\n{\r\nswitch (mscm->choice) {\r\ncase eMultimediaSystemControlMessage_request:\r\nif (mscm->request.choice ==\r\neRequestMessage_openLogicalChannel) {\r\nreturn process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&mscm->request.openLogicalChannel);\r\n}\r\npr_debug("nf_ct_h323: H.245 Request %d\n",\r\nmscm->request.choice);\r\nbreak;\r\ncase eMultimediaSystemControlMessage_response:\r\nif (mscm->response.choice ==\r\neResponseMessage_openLogicalChannelAck) {\r\nreturn process_olca(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&mscm->response.\r\nopenLogicalChannelAck);\r\n}\r\npr_debug("nf_ct_h323: H.245 Response %d\n",\r\nmscm->response.choice);\r\nbreak;\r\ndefault:\r\npr_debug("nf_ct_h323: H.245 signal %d\n", mscm->choice);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int h245_help(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nstatic MultimediaSystemControlMessage mscm;\r\nunsigned char *data = NULL;\r\nint datalen;\r\nint dataoff;\r\nint ret;\r\nif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\npr_debug("nf_ct_h245: skblen = %u\n", skb->len);\r\nspin_lock_bh(&nf_h323_lock);\r\nwhile (get_tpkt_data(skb, protoff, ct, ctinfo,\r\n&data, &datalen, &dataoff)) {\r\npr_debug("nf_ct_h245: TPKT len=%d ", datalen);\r\nnf_ct_dump_tuple(&ct->tuplehash[CTINFO2DIR(ctinfo)].tuple);\r\nret = DecodeMultimediaSystemControlMessage(data, datalen,\r\n&mscm);\r\nif (ret < 0) {\r\npr_debug("nf_ct_h245: decoding error: %s\n",\r\nret == H323_ERROR_BOUND ?\r\n"out of bound" : "out of range");\r\nbreak;\r\n}\r\nif (process_h245(skb, ct, ctinfo, protoff,\r\n&data, dataoff, &mscm) < 0)\r\ngoto drop;\r\n}\r\nspin_unlock_bh(&nf_h323_lock);\r\nreturn NF_ACCEPT;\r\ndrop:\r\nspin_unlock_bh(&nf_h323_lock);\r\nnet_info_ratelimited("nf_ct_h245: packet dropped\n");\r\nreturn NF_DROP;\r\n}\r\nint get_h225_addr(struct nf_conn *ct, unsigned char *data,\r\nTransportAddress *taddr,\r\nunion nf_inet_addr *addr, __be16 *port)\r\n{\r\nconst unsigned char *p;\r\nint len;\r\nswitch (taddr->choice) {\r\ncase eTransportAddress_ipAddress:\r\nif (nf_ct_l3num(ct) != AF_INET)\r\nreturn 0;\r\np = data + taddr->ipAddress.ip;\r\nlen = 4;\r\nbreak;\r\ncase eTransportAddress_ip6Address:\r\nif (nf_ct_l3num(ct) != AF_INET6)\r\nreturn 0;\r\np = data + taddr->ip6Address.ip;\r\nlen = 16;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmemcpy(addr, p, len);\r\nmemset((void *)addr + len, 0, sizeof(*addr) - len);\r\nmemcpy(port, p + len, sizeof(__be16));\r\nreturn 1;\r\n}\r\nstatic int expect_h245(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff, unsigned char **data, int dataoff,\r\nTransportAddress *taddr)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\ntypeof(nat_h245_hook) nat_h245;\r\nif (!get_h225_addr(ct, *data, taddr, &addr, &port) ||\r\nmemcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) ||\r\nport == 0)\r\nreturn 0;\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nIPPROTO_TCP, NULL, &port);\r\nexp->helper = &nf_conntrack_helper_h245;\r\nif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nsizeof(ct->tuplehash[dir].tuple.src.u3)) &&\r\n(nat_h245 = rcu_dereference(nat_h245_hook)) &&\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = nat_h245(skb, ct, ctinfo, protoff, data, dataoff, taddr,\r\nport, exp);\r\n} else {\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_q931: expect H.245 ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\n} else\r\nret = -1;\r\n}\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int callforward_do_filter(const union nf_inet_addr *src,\r\nconst union nf_inet_addr *dst,\r\nu_int8_t family)\r\n{\r\nconst struct nf_afinfo *afinfo;\r\nint ret = 0;\r\nafinfo = nf_get_afinfo(family);\r\nif (!afinfo)\r\nreturn 0;\r\nswitch (family) {\r\ncase AF_INET: {\r\nstruct flowi4 fl1, fl2;\r\nstruct rtable *rt1, *rt2;\r\nmemset(&fl1, 0, sizeof(fl1));\r\nfl1.daddr = src->ip;\r\nmemset(&fl2, 0, sizeof(fl2));\r\nfl2.daddr = dst->ip;\r\nif (!afinfo->route(&init_net, (struct dst_entry **)&rt1,\r\nflowi4_to_flowi(&fl1), false)) {\r\nif (!afinfo->route(&init_net, (struct dst_entry **)&rt2,\r\nflowi4_to_flowi(&fl2), false)) {\r\nif (rt_nexthop(rt1, fl1.daddr) ==\r\nrt_nexthop(rt2, fl2.daddr) &&\r\nrt1->dst.dev == rt2->dst.dev)\r\nret = 1;\r\ndst_release(&rt2->dst);\r\n}\r\ndst_release(&rt1->dst);\r\n}\r\nbreak;\r\n}\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)\r\ncase AF_INET6: {\r\nstruct flowi6 fl1, fl2;\r\nstruct rt6_info *rt1, *rt2;\r\nmemset(&fl1, 0, sizeof(fl1));\r\nfl1.daddr = src->in6;\r\nmemset(&fl2, 0, sizeof(fl2));\r\nfl2.daddr = dst->in6;\r\nif (!afinfo->route(&init_net, (struct dst_entry **)&rt1,\r\nflowi6_to_flowi(&fl1), false)) {\r\nif (!afinfo->route(&init_net, (struct dst_entry **)&rt2,\r\nflowi6_to_flowi(&fl2), false)) {\r\nif (!memcmp(&rt1->rt6i_gateway, &rt2->rt6i_gateway,\r\nsizeof(rt1->rt6i_gateway)) &&\r\nrt1->dst.dev == rt2->dst.dev)\r\nret = 1;\r\ndst_release(&rt2->dst);\r\n}\r\ndst_release(&rt1->dst);\r\n}\r\nbreak;\r\n}\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int expect_callforwarding(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nTransportAddress *taddr)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\ntypeof(nat_callforwarding_hook) nat_callforwarding;\r\nif (!get_h225_addr(ct, *data, taddr, &addr, &port) || port == 0)\r\nreturn 0;\r\nif (callforward_filter &&\r\ncallforward_do_filter(&addr, &ct->tuplehash[!dir].tuple.src.u3,\r\nnf_ct_l3num(ct))) {\r\npr_debug("nf_ct_q931: Call Forwarding not tracked\n");\r\nreturn 0;\r\n}\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3, &addr,\r\nIPPROTO_TCP, NULL, &port);\r\nexp->helper = nf_conntrack_helper_q931;\r\nif (memcmp(&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nsizeof(ct->tuplehash[dir].tuple.src.u3)) &&\r\n(nat_callforwarding = rcu_dereference(nat_callforwarding_hook)) &&\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = nat_callforwarding(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\ntaddr, port, exp);\r\n} else {\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_q931: expect Call Forwarding ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\n} else\r\nret = -1;\r\n}\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int process_setup(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nSetup_UUIE *setup)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret;\r\nint i;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\ntypeof(set_h225_addr_hook) set_h225_addr;\r\npr_debug("nf_ct_q931: Setup\n");\r\nif (setup->options & eSetup_UUIE_h245Address) {\r\nret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\r\n&setup->h245Address);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nset_h225_addr = rcu_dereference(set_h225_addr_hook);\r\nif ((setup->options & eSetup_UUIE_destCallSignalAddress) &&\r\n(set_h225_addr) && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK &&\r\nget_h225_addr(ct, *data, &setup->destCallSignalAddress,\r\n&addr, &port) &&\r\nmemcmp(&addr, &ct->tuplehash[!dir].tuple.src.u3, sizeof(addr))) {\r\npr_debug("nf_ct_q931: set destCallSignalAddress %pI6:%hu->%pI6:%hu\n",\r\n&addr, ntohs(port), &ct->tuplehash[!dir].tuple.src.u3,\r\nntohs(ct->tuplehash[!dir].tuple.src.u.tcp.port));\r\nret = set_h225_addr(skb, protoff, data, dataoff,\r\n&setup->destCallSignalAddress,\r\n&ct->tuplehash[!dir].tuple.src.u3,\r\nct->tuplehash[!dir].tuple.src.u.tcp.port);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif ((setup->options & eSetup_UUIE_sourceCallSignalAddress) &&\r\n(set_h225_addr) && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK &&\r\nget_h225_addr(ct, *data, &setup->sourceCallSignalAddress,\r\n&addr, &port) &&\r\nmemcmp(&addr, &ct->tuplehash[!dir].tuple.dst.u3, sizeof(addr))) {\r\npr_debug("nf_ct_q931: set sourceCallSignalAddress %pI6:%hu->%pI6:%hu\n",\r\n&addr, ntohs(port), &ct->tuplehash[!dir].tuple.dst.u3,\r\nntohs(ct->tuplehash[!dir].tuple.dst.u.tcp.port));\r\nret = set_h225_addr(skb, protoff, data, dataoff,\r\n&setup->sourceCallSignalAddress,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nct->tuplehash[!dir].tuple.dst.u.tcp.port);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (setup->options & eSetup_UUIE_fastStart) {\r\nfor (i = 0; i < setup->fastStart.count; i++) {\r\nret = process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&setup->fastStart.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_callproceeding(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nCallProceeding_UUIE *callproc)\r\n{\r\nint ret;\r\nint i;\r\npr_debug("nf_ct_q931: CallProceeding\n");\r\nif (callproc->options & eCallProceeding_UUIE_h245Address) {\r\nret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\r\n&callproc->h245Address);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (callproc->options & eCallProceeding_UUIE_fastStart) {\r\nfor (i = 0; i < callproc->fastStart.count; i++) {\r\nret = process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&callproc->fastStart.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_connect(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nConnect_UUIE *connect)\r\n{\r\nint ret;\r\nint i;\r\npr_debug("nf_ct_q931: Connect\n");\r\nif (connect->options & eConnect_UUIE_h245Address) {\r\nret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\r\n&connect->h245Address);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (connect->options & eConnect_UUIE_fastStart) {\r\nfor (i = 0; i < connect->fastStart.count; i++) {\r\nret = process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&connect->fastStart.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_alerting(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nAlerting_UUIE *alert)\r\n{\r\nint ret;\r\nint i;\r\npr_debug("nf_ct_q931: Alerting\n");\r\nif (alert->options & eAlerting_UUIE_h245Address) {\r\nret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\r\n&alert->h245Address);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (alert->options & eAlerting_UUIE_fastStart) {\r\nfor (i = 0; i < alert->fastStart.count; i++) {\r\nret = process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&alert->fastStart.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_facility(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nFacility_UUIE *facility)\r\n{\r\nint ret;\r\nint i;\r\npr_debug("nf_ct_q931: Facility\n");\r\nif (facility->reason.choice == eFacilityReason_callForwarded) {\r\nif (facility->options & eFacility_UUIE_alternativeAddress)\r\nreturn expect_callforwarding(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&facility->\r\nalternativeAddress);\r\nreturn 0;\r\n}\r\nif (facility->options & eFacility_UUIE_h245Address) {\r\nret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\r\n&facility->h245Address);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (facility->options & eFacility_UUIE_fastStart) {\r\nfor (i = 0; i < facility->fastStart.count; i++) {\r\nret = process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&facility->fastStart.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_progress(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, int dataoff,\r\nProgress_UUIE *progress)\r\n{\r\nint ret;\r\nint i;\r\npr_debug("nf_ct_q931: Progress\n");\r\nif (progress->options & eProgress_UUIE_h245Address) {\r\nret = expect_h245(skb, ct, ctinfo, protoff, data, dataoff,\r\n&progress->h245Address);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (progress->options & eProgress_UUIE_fastStart) {\r\nfor (i = 0; i < progress->fastStart.count; i++) {\r\nret = process_olc(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&progress->fastStart.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_q931(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff, unsigned char **data, int dataoff,\r\nQ931 *q931)\r\n{\r\nH323_UU_PDU *pdu = &q931->UUIE.h323_uu_pdu;\r\nint i;\r\nint ret = 0;\r\nswitch (pdu->h323_message_body.choice) {\r\ncase eH323_UU_PDU_h323_message_body_setup:\r\nret = process_setup(skb, ct, ctinfo, protoff, data, dataoff,\r\n&pdu->h323_message_body.setup);\r\nbreak;\r\ncase eH323_UU_PDU_h323_message_body_callProceeding:\r\nret = process_callproceeding(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&pdu->h323_message_body.\r\ncallProceeding);\r\nbreak;\r\ncase eH323_UU_PDU_h323_message_body_connect:\r\nret = process_connect(skb, ct, ctinfo, protoff, data, dataoff,\r\n&pdu->h323_message_body.connect);\r\nbreak;\r\ncase eH323_UU_PDU_h323_message_body_alerting:\r\nret = process_alerting(skb, ct, ctinfo, protoff, data, dataoff,\r\n&pdu->h323_message_body.alerting);\r\nbreak;\r\ncase eH323_UU_PDU_h323_message_body_facility:\r\nret = process_facility(skb, ct, ctinfo, protoff, data, dataoff,\r\n&pdu->h323_message_body.facility);\r\nbreak;\r\ncase eH323_UU_PDU_h323_message_body_progress:\r\nret = process_progress(skb, ct, ctinfo, protoff, data, dataoff,\r\n&pdu->h323_message_body.progress);\r\nbreak;\r\ndefault:\r\npr_debug("nf_ct_q931: Q.931 signal %d\n",\r\npdu->h323_message_body.choice);\r\nbreak;\r\n}\r\nif (ret < 0)\r\nreturn -1;\r\nif (pdu->options & eH323_UU_PDU_h245Control) {\r\nfor (i = 0; i < pdu->h245Control.count; i++) {\r\nret = process_h245(skb, ct, ctinfo,\r\nprotoff, data, dataoff,\r\n&pdu->h245Control.item[i]);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int q931_help(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nstatic Q931 q931;\r\nunsigned char *data = NULL;\r\nint datalen;\r\nint dataoff;\r\nint ret;\r\nif (ctinfo != IP_CT_ESTABLISHED && ctinfo != IP_CT_ESTABLISHED_REPLY)\r\nreturn NF_ACCEPT;\r\npr_debug("nf_ct_q931: skblen = %u\n", skb->len);\r\nspin_lock_bh(&nf_h323_lock);\r\nwhile (get_tpkt_data(skb, protoff, ct, ctinfo,\r\n&data, &datalen, &dataoff)) {\r\npr_debug("nf_ct_q931: TPKT len=%d ", datalen);\r\nnf_ct_dump_tuple(&ct->tuplehash[CTINFO2DIR(ctinfo)].tuple);\r\nret = DecodeQ931(data, datalen, &q931);\r\nif (ret < 0) {\r\npr_debug("nf_ct_q931: decoding error: %s\n",\r\nret == H323_ERROR_BOUND ?\r\n"out of bound" : "out of range");\r\nbreak;\r\n}\r\nif (process_q931(skb, ct, ctinfo, protoff,\r\n&data, dataoff, &q931) < 0)\r\ngoto drop;\r\n}\r\nspin_unlock_bh(&nf_h323_lock);\r\nreturn NF_ACCEPT;\r\ndrop:\r\nspin_unlock_bh(&nf_h323_lock);\r\nnet_info_ratelimited("nf_ct_q931: packet dropped\n");\r\nreturn NF_DROP;\r\n}\r\nstatic unsigned char *get_udp_data(struct sk_buff *skb, unsigned int protoff,\r\nint *datalen)\r\n{\r\nconst struct udphdr *uh;\r\nstruct udphdr _uh;\r\nint dataoff;\r\nuh = skb_header_pointer(skb, protoff, sizeof(_uh), &_uh);\r\nif (uh == NULL)\r\nreturn NULL;\r\ndataoff = protoff + sizeof(_uh);\r\nif (dataoff >= skb->len)\r\nreturn NULL;\r\n*datalen = skb->len - dataoff;\r\nreturn skb_header_pointer(skb, dataoff, *datalen, h323_buffer);\r\n}\r\nstatic struct nf_conntrack_expect *find_expect(struct nf_conn *ct,\r\nunion nf_inet_addr *addr,\r\n__be16 port)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct nf_conntrack_expect *exp;\r\nstruct nf_conntrack_tuple tuple;\r\nmemset(&tuple.src.u3, 0, sizeof(tuple.src.u3));\r\ntuple.src.u.tcp.port = 0;\r\nmemcpy(&tuple.dst.u3, addr, sizeof(tuple.dst.u3));\r\ntuple.dst.u.tcp.port = port;\r\ntuple.dst.protonum = IPPROTO_TCP;\r\nexp = __nf_ct_expect_find(net, nf_ct_zone(ct), &tuple);\r\nif (exp && exp->master == ct)\r\nreturn exp;\r\nreturn NULL;\r\n}\r\nstatic int set_expect_timeout(struct nf_conntrack_expect *exp,\r\nunsigned int timeout)\r\n{\r\nif (!exp || !del_timer(&exp->timeout))\r\nreturn 0;\r\nexp->timeout.expires = jiffies + timeout * HZ;\r\nadd_timer(&exp->timeout);\r\nreturn 1;\r\n}\r\nstatic int expect_q931(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff, unsigned char **data,\r\nTransportAddress *taddr, int count)\r\n{\r\nstruct nf_ct_h323_master *info = nfct_help_data(ct);\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\nint i;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\ntypeof(nat_q931_hook) nat_q931;\r\nfor (i = 0; i < count; i++) {\r\nif (get_h225_addr(ct, *data, &taddr[i], &addr, &port) &&\r\nmemcmp(&addr, &ct->tuplehash[dir].tuple.src.u3,\r\nsizeof(addr)) == 0 && port != 0)\r\nbreak;\r\n}\r\nif (i >= count)\r\nreturn 0;\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\ngkrouted_only ?\r\n&ct->tuplehash[!dir].tuple.src.u3 : NULL,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nIPPROTO_TCP, NULL, &port);\r\nexp->helper = nf_conntrack_helper_q931;\r\nexp->flags = NF_CT_EXPECT_PERMANENT;\r\nnat_q931 = rcu_dereference(nat_q931_hook);\r\nif (nat_q931 && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = nat_q931(skb, ct, ctinfo, protoff, data,\r\ntaddr, i, port, exp);\r\n} else {\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_ras: expect Q.931 ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\ninfo->sig_port[dir] = port;\r\n} else\r\nret = -1;\r\n}\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int process_grq(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, GatekeeperRequest *grq)\r\n{\r\ntypeof(set_ras_addr_hook) set_ras_addr;\r\npr_debug("nf_ct_ras: GRQ\n");\r\nset_ras_addr = rcu_dereference(set_ras_addr_hook);\r\nif (set_ras_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK)\r\nreturn set_ras_addr(skb, ct, ctinfo, protoff, data,\r\n&grq->rasAddress, 1);\r\nreturn 0;\r\n}\r\nstatic int process_gcf(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, GatekeeperConfirm *gcf)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\npr_debug("nf_ct_ras: GCF\n");\r\nif (!get_h225_addr(ct, *data, &gcf->rasAddress, &addr, &port))\r\nreturn 0;\r\nif (!memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) &&\r\nport == ct->tuplehash[dir].tuple.src.u.udp.port)\r\nreturn 0;\r\nif (test_bit(IPS_EXPECTED_BIT, &ct->status))\r\nreturn 0;\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3, &addr,\r\nIPPROTO_UDP, NULL, &port);\r\nexp->helper = nf_conntrack_helper_ras;\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_ras: expect RAS ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\n} else\r\nret = -1;\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int process_rrq(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, RegistrationRequest *rrq)\r\n{\r\nstruct nf_ct_h323_master *info = nfct_help_data(ct);\r\nint ret;\r\ntypeof(set_ras_addr_hook) set_ras_addr;\r\npr_debug("nf_ct_ras: RRQ\n");\r\nret = expect_q931(skb, ct, ctinfo, protoff, data,\r\nrrq->callSignalAddress.item,\r\nrrq->callSignalAddress.count);\r\nif (ret < 0)\r\nreturn -1;\r\nset_ras_addr = rcu_dereference(set_ras_addr_hook);\r\nif (set_ras_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = set_ras_addr(skb, ct, ctinfo, protoff, data,\r\nrrq->rasAddress.item,\r\nrrq->rasAddress.count);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (rrq->options & eRegistrationRequest_timeToLive) {\r\npr_debug("nf_ct_ras: RRQ TTL = %u seconds\n", rrq->timeToLive);\r\ninfo->timeout = rrq->timeToLive;\r\n} else\r\ninfo->timeout = default_rrq_ttl;\r\nreturn 0;\r\n}\r\nstatic int process_rcf(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, RegistrationConfirm *rcf)\r\n{\r\nstruct nf_ct_h323_master *info = nfct_help_data(ct);\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret;\r\nstruct nf_conntrack_expect *exp;\r\ntypeof(set_sig_addr_hook) set_sig_addr;\r\npr_debug("nf_ct_ras: RCF\n");\r\nset_sig_addr = rcu_dereference(set_sig_addr_hook);\r\nif (set_sig_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = set_sig_addr(skb, ct, ctinfo, protoff, data,\r\nrcf->callSignalAddress.item,\r\nrcf->callSignalAddress.count);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nif (rcf->options & eRegistrationConfirm_timeToLive) {\r\npr_debug("nf_ct_ras: RCF TTL = %u seconds\n", rcf->timeToLive);\r\ninfo->timeout = rcf->timeToLive;\r\n}\r\nif (info->timeout > 0) {\r\npr_debug("nf_ct_ras: set RAS connection timeout to "\r\n"%u seconds\n", info->timeout);\r\nnf_ct_refresh(ct, skb, info->timeout * HZ);\r\nspin_lock_bh(&nf_conntrack_lock);\r\nexp = find_expect(ct, &ct->tuplehash[dir].tuple.dst.u3,\r\ninfo->sig_port[!dir]);\r\nif (exp) {\r\npr_debug("nf_ct_ras: set Q.931 expect "\r\n"timeout to %u seconds for",\r\ninfo->timeout);\r\nnf_ct_dump_tuple(&exp->tuple);\r\nset_expect_timeout(exp, info->timeout);\r\n}\r\nspin_unlock_bh(&nf_conntrack_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_urq(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, UnregistrationRequest *urq)\r\n{\r\nstruct nf_ct_h323_master *info = nfct_help_data(ct);\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret;\r\ntypeof(set_sig_addr_hook) set_sig_addr;\r\npr_debug("nf_ct_ras: URQ\n");\r\nset_sig_addr = rcu_dereference(set_sig_addr_hook);\r\nif (set_sig_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = set_sig_addr(skb, ct, ctinfo, protoff, data,\r\nurq->callSignalAddress.item,\r\nurq->callSignalAddress.count);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nnf_ct_remove_expectations(ct);\r\ninfo->sig_port[dir] = 0;\r\ninfo->sig_port[!dir] = 0;\r\nnf_ct_refresh(ct, skb, 30 * HZ);\r\nreturn 0;\r\n}\r\nstatic int process_arq(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, AdmissionRequest *arq)\r\n{\r\nconst struct nf_ct_h323_master *info = nfct_help_data(ct);\r\nint dir = CTINFO2DIR(ctinfo);\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\ntypeof(set_h225_addr_hook) set_h225_addr;\r\npr_debug("nf_ct_ras: ARQ\n");\r\nset_h225_addr = rcu_dereference(set_h225_addr_hook);\r\nif ((arq->options & eAdmissionRequest_destCallSignalAddress) &&\r\nget_h225_addr(ct, *data, &arq->destCallSignalAddress,\r\n&addr, &port) &&\r\n!memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) &&\r\nport == info->sig_port[dir] &&\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nset_h225_addr && ct->status & IPS_NAT_MASK) {\r\nreturn set_h225_addr(skb, protoff, data, 0,\r\n&arq->destCallSignalAddress,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\ninfo->sig_port[!dir]);\r\n}\r\nif ((arq->options & eAdmissionRequest_srcCallSignalAddress) &&\r\nget_h225_addr(ct, *data, &arq->srcCallSignalAddress,\r\n&addr, &port) &&\r\n!memcmp(&addr, &ct->tuplehash[dir].tuple.src.u3, sizeof(addr)) &&\r\nset_h225_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nreturn set_h225_addr(skb, protoff, data, 0,\r\n&arq->srcCallSignalAddress,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\nport);\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_acf(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, AdmissionConfirm *acf)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\ntypeof(set_sig_addr_hook) set_sig_addr;\r\npr_debug("nf_ct_ras: ACF\n");\r\nif (!get_h225_addr(ct, *data, &acf->destCallSignalAddress,\r\n&addr, &port))\r\nreturn 0;\r\nif (!memcmp(&addr, &ct->tuplehash[dir].tuple.dst.u3, sizeof(addr))) {\r\nset_sig_addr = rcu_dereference(set_sig_addr_hook);\r\nif (set_sig_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK)\r\nreturn set_sig_addr(skb, ct, ctinfo, protoff, data,\r\n&acf->destCallSignalAddress, 1);\r\nreturn 0;\r\n}\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3, &addr,\r\nIPPROTO_TCP, NULL, &port);\r\nexp->flags = NF_CT_EXPECT_PERMANENT;\r\nexp->helper = nf_conntrack_helper_q931;\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_ras: expect Q.931 ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\n} else\r\nret = -1;\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int process_lrq(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, LocationRequest *lrq)\r\n{\r\ntypeof(set_ras_addr_hook) set_ras_addr;\r\npr_debug("nf_ct_ras: LRQ\n");\r\nset_ras_addr = rcu_dereference(set_ras_addr_hook);\r\nif (set_ras_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK)\r\nreturn set_ras_addr(skb, ct, ctinfo, protoff, data,\r\n&lrq->replyAddress, 1);\r\nreturn 0;\r\n}\r\nstatic int process_lcf(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, LocationConfirm *lcf)\r\n{\r\nint dir = CTINFO2DIR(ctinfo);\r\nint ret = 0;\r\n__be16 port;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_expect *exp;\r\npr_debug("nf_ct_ras: LCF\n");\r\nif (!get_h225_addr(ct, *data, &lcf->callSignalAddress,\r\n&addr, &port))\r\nreturn 0;\r\nif ((exp = nf_ct_expect_alloc(ct)) == NULL)\r\nreturn -1;\r\nnf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, nf_ct_l3num(ct),\r\n&ct->tuplehash[!dir].tuple.src.u3, &addr,\r\nIPPROTO_TCP, NULL, &port);\r\nexp->flags = NF_CT_EXPECT_PERMANENT;\r\nexp->helper = nf_conntrack_helper_q931;\r\nif (nf_ct_expect_related(exp) == 0) {\r\npr_debug("nf_ct_ras: expect Q.931 ");\r\nnf_ct_dump_tuple(&exp->tuple);\r\n} else\r\nret = -1;\r\nnf_ct_expect_put(exp);\r\nreturn ret;\r\n}\r\nstatic int process_irr(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, InfoRequestResponse *irr)\r\n{\r\nint ret;\r\ntypeof(set_ras_addr_hook) set_ras_addr;\r\ntypeof(set_sig_addr_hook) set_sig_addr;\r\npr_debug("nf_ct_ras: IRR\n");\r\nset_ras_addr = rcu_dereference(set_ras_addr_hook);\r\nif (set_ras_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = set_ras_addr(skb, ct, ctinfo, protoff, data,\r\n&irr->rasAddress, 1);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nset_sig_addr = rcu_dereference(set_sig_addr_hook);\r\nif (set_sig_addr && nf_ct_l3num(ct) == NFPROTO_IPV4 &&\r\nct->status & IPS_NAT_MASK) {\r\nret = set_sig_addr(skb, ct, ctinfo, protoff, data,\r\nirr->callSignalAddress.item,\r\nirr->callSignalAddress.count);\r\nif (ret < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_ras(struct sk_buff *skb, struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int protoff,\r\nunsigned char **data, RasMessage *ras)\r\n{\r\nswitch (ras->choice) {\r\ncase eRasMessage_gatekeeperRequest:\r\nreturn process_grq(skb, ct, ctinfo, protoff, data,\r\n&ras->gatekeeperRequest);\r\ncase eRasMessage_gatekeeperConfirm:\r\nreturn process_gcf(skb, ct, ctinfo, protoff, data,\r\n&ras->gatekeeperConfirm);\r\ncase eRasMessage_registrationRequest:\r\nreturn process_rrq(skb, ct, ctinfo, protoff, data,\r\n&ras->registrationRequest);\r\ncase eRasMessage_registrationConfirm:\r\nreturn process_rcf(skb, ct, ctinfo, protoff, data,\r\n&ras->registrationConfirm);\r\ncase eRasMessage_unregistrationRequest:\r\nreturn process_urq(skb, ct, ctinfo, protoff, data,\r\n&ras->unregistrationRequest);\r\ncase eRasMessage_admissionRequest:\r\nreturn process_arq(skb, ct, ctinfo, protoff, data,\r\n&ras->admissionRequest);\r\ncase eRasMessage_admissionConfirm:\r\nreturn process_acf(skb, ct, ctinfo, protoff, data,\r\n&ras->admissionConfirm);\r\ncase eRasMessage_locationRequest:\r\nreturn process_lrq(skb, ct, ctinfo, protoff, data,\r\n&ras->locationRequest);\r\ncase eRasMessage_locationConfirm:\r\nreturn process_lcf(skb, ct, ctinfo, protoff, data,\r\n&ras->locationConfirm);\r\ncase eRasMessage_infoRequestResponse:\r\nreturn process_irr(skb, ct, ctinfo, protoff, data,\r\n&ras->infoRequestResponse);\r\ndefault:\r\npr_debug("nf_ct_ras: RAS message %d\n", ras->choice);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ras_help(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nstatic RasMessage ras;\r\nunsigned char *data;\r\nint datalen = 0;\r\nint ret;\r\npr_debug("nf_ct_ras: skblen = %u\n", skb->len);\r\nspin_lock_bh(&nf_h323_lock);\r\ndata = get_udp_data(skb, protoff, &datalen);\r\nif (data == NULL)\r\ngoto accept;\r\npr_debug("nf_ct_ras: RAS message len=%d ", datalen);\r\nnf_ct_dump_tuple(&ct->tuplehash[CTINFO2DIR(ctinfo)].tuple);\r\nret = DecodeRasMessage(data, datalen, &ras);\r\nif (ret < 0) {\r\npr_debug("nf_ct_ras: decoding error: %s\n",\r\nret == H323_ERROR_BOUND ?\r\n"out of bound" : "out of range");\r\ngoto accept;\r\n}\r\nif (process_ras(skb, ct, ctinfo, protoff, &data, &ras) < 0)\r\ngoto drop;\r\naccept:\r\nspin_unlock_bh(&nf_h323_lock);\r\nreturn NF_ACCEPT;\r\ndrop:\r\nspin_unlock_bh(&nf_h323_lock);\r\nnet_info_ratelimited("nf_ct_ras: packet dropped\n");\r\nreturn NF_DROP;\r\n}\r\nstatic void __exit nf_conntrack_h323_fini(void)\r\n{\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_ras[1]);\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_ras[0]);\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_q931[1]);\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_q931[0]);\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_h245);\r\nkfree(h323_buffer);\r\npr_debug("nf_ct_h323: fini\n");\r\n}\r\nstatic int __init nf_conntrack_h323_init(void)\r\n{\r\nint ret;\r\nh323_buffer = kmalloc(65536, GFP_KERNEL);\r\nif (!h323_buffer)\r\nreturn -ENOMEM;\r\nret = nf_conntrack_helper_register(&nf_conntrack_helper_h245);\r\nif (ret < 0)\r\ngoto err1;\r\nret = nf_conntrack_helper_register(&nf_conntrack_helper_q931[0]);\r\nif (ret < 0)\r\ngoto err2;\r\nret = nf_conntrack_helper_register(&nf_conntrack_helper_q931[1]);\r\nif (ret < 0)\r\ngoto err3;\r\nret = nf_conntrack_helper_register(&nf_conntrack_helper_ras[0]);\r\nif (ret < 0)\r\ngoto err4;\r\nret = nf_conntrack_helper_register(&nf_conntrack_helper_ras[1]);\r\nif (ret < 0)\r\ngoto err5;\r\npr_debug("nf_ct_h323: init success\n");\r\nreturn 0;\r\nerr5:\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_ras[0]);\r\nerr4:\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_q931[1]);\r\nerr3:\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_q931[0]);\r\nerr2:\r\nnf_conntrack_helper_unregister(&nf_conntrack_helper_h245);\r\nerr1:\r\nkfree(h323_buffer);\r\nreturn ret;\r\n}
