static acpi_status ppi_callback(acpi_handle handle, u32 level, void *context,\r\nvoid **return_value)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstatus = acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\nif (strstr(buffer.pointer, context) != NULL) {\r\n*return_value = handle;\r\nkfree(buffer.pointer);\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic inline void ppi_assign_params(union acpi_object params[4],\r\nu64 function_num)\r\n{\r\nparams[0].type = ACPI_TYPE_BUFFER;\r\nparams[0].buffer.length = sizeof(tpm_ppi_uuid);\r\nparams[0].buffer.pointer = (char *)tpm_ppi_uuid;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = TPM_PPI_REVISION_ID;\r\nparams[2].type = ACPI_TYPE_INTEGER;\r\nparams[2].integer.value = function_num;\r\nparams[3].type = ACPI_TYPE_PACKAGE;\r\nparams[3].package.count = 0;\r\nparams[3].package.elements = NULL;\r\n}\r\nstatic ssize_t tpm_show_ppi_version(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object params[4];\r\nunion acpi_object *obj;\r\ninput.count = 4;\r\nppi_assign_params(params, TPM_PPI_FN_VERSION);\r\ninput.pointer = params;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ppi_callback, NULL,\r\ntpm_device_name, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENXIO;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_STRING);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nobj = (union acpi_object *)output.pointer;\r\nstatus = scnprintf(buf, PAGE_SIZE, "%s\n", obj->string.pointer);\r\nkfree(output.pointer);\r\nreturn status;\r\n}\r\nstatic ssize_t tpm_show_ppi_request(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object params[4];\r\nunion acpi_object *ret_obj;\r\ninput.count = 4;\r\nppi_assign_params(params, TPM_PPI_FN_GETREQ);\r\ninput.pointer = params;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ppi_callback, NULL,\r\ntpm_device_name, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENXIO;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nret_obj = ((union acpi_object *)output.pointer)->package.elements;\r\nif (ret_obj->type == ACPI_TYPE_INTEGER) {\r\nif (ret_obj->integer.value) {\r\nstatus = -EFAULT;\r\ngoto cleanup;\r\n}\r\nret_obj++;\r\nif (ret_obj->type == ACPI_TYPE_INTEGER)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu\n",\r\nret_obj->integer.value);\r\nelse\r\nstatus = -EINVAL;\r\n} else {\r\nstatus = -EINVAL;\r\n}\r\ncleanup:\r\nkfree(output.pointer);\r\nreturn status;\r\n}\r\nstatic ssize_t tpm_store_ppi_request(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nchar version[PPI_VERSION_LEN + 1];\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object params[4];\r\nunion acpi_object obj;\r\nu32 req;\r\nu64 ret;\r\ninput.count = 4;\r\nppi_assign_params(params, TPM_PPI_FN_VERSION);\r\ninput.pointer = params;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ppi_callback, NULL,\r\ntpm_device_name, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENXIO;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_STRING);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nstrncpy(version,\r\n((union acpi_object *)output.pointer)->string.pointer,\r\nPPI_VERSION_LEN);\r\nkfree(output.pointer);\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nif (strcmp(version, "1.1") == -1)\r\nparams[2].integer.value = TPM_PPI_FN_SUBREQ;\r\nelse\r\nparams[2].integer.value = TPM_PPI_FN_SUBREQ2;\r\nif (strcmp(version, "1.2") == -1) {\r\nparams[3].type = ACPI_TYPE_BUFFER;\r\nparams[3].buffer.length = sizeof(req);\r\nsscanf(buf, "%d", &req);\r\nparams[3].buffer.pointer = (char *)&req;\r\n} else {\r\nparams[3].package.count = 1;\r\nobj.type = ACPI_TYPE_INTEGER;\r\nsscanf(buf, "%llu", &obj.integer.value);\r\nparams[3].package.elements = &obj;\r\n}\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_INTEGER);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nret = ((union acpi_object *)output.pointer)->integer.value;\r\nif (ret == 0)\r\nstatus = (acpi_status)count;\r\nelse if (ret == 1)\r\nstatus = -EPERM;\r\nelse\r\nstatus = -EFAULT;\r\nkfree(output.pointer);\r\nreturn status;\r\n}\r\nstatic ssize_t tpm_show_ppi_transition_action(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nchar version[PPI_VERSION_LEN + 1];\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object params[4];\r\nu32 ret;\r\nchar *info[] = {\r\n"None",\r\n"Shutdown",\r\n"Reboot",\r\n"OS Vendor-specific",\r\n"Error",\r\n};\r\ninput.count = 4;\r\nppi_assign_params(params, TPM_PPI_FN_VERSION);\r\ninput.pointer = params;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ppi_callback, NULL,\r\ntpm_device_name, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENXIO;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_STRING);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nstrncpy(version,\r\n((union acpi_object *)output.pointer)->string.pointer,\r\nPPI_VERSION_LEN);\r\nif (strcmp(version, "1.2") == -1) {\r\nparams[3].type = ACPI_TYPE_BUFFER;\r\nparams[3].buffer.length = 0;\r\nparams[3].buffer.pointer = NULL;\r\n}\r\nparams[2].integer.value = TPM_PPI_FN_GETACT;\r\nkfree(output.pointer);\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_INTEGER);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nret = ((union acpi_object *)output.pointer)->integer.value;\r\nif (ret < ARRAY_SIZE(info) - 1)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%d: %s\n", ret, info[ret]);\r\nelse\r\nstatus = scnprintf(buf, PAGE_SIZE, "%d: %s\n", ret,\r\ninfo[ARRAY_SIZE(info)-1]);\r\nkfree(output.pointer);\r\nreturn status;\r\n}\r\nstatic ssize_t tpm_show_ppi_response(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object params[4];\r\nunion acpi_object *ret_obj;\r\nu64 req;\r\ninput.count = 4;\r\nppi_assign_params(params, TPM_PPI_FN_GETRSP);\r\ninput.pointer = params;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ppi_callback, NULL,\r\ntpm_device_name, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENXIO;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nret_obj = ((union acpi_object *)output.pointer)->package.elements;\r\nif (ret_obj->type != ACPI_TYPE_INTEGER) {\r\nstatus = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (ret_obj->integer.value) {\r\nstatus = -EFAULT;\r\ngoto cleanup;\r\n}\r\nret_obj++;\r\nif (ret_obj->type != ACPI_TYPE_INTEGER) {\r\nstatus = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (ret_obj->integer.value) {\r\nreq = ret_obj->integer.value;\r\nret_obj++;\r\nif (ret_obj->type != ACPI_TYPE_INTEGER) {\r\nstatus = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (ret_obj->integer.value == 0)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %s\n", req,\r\n"0: Success");\r\nelse if (ret_obj->integer.value == 0xFFFFFFF0)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %s\n", req,\r\n"0xFFFFFFF0: User Abort");\r\nelse if (ret_obj->integer.value == 0xFFFFFFF1)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %s\n", req,\r\n"0xFFFFFFF1: BIOS Failure");\r\nelse if (ret_obj->integer.value >= 1 &&\r\nret_obj->integer.value <= 0x00000FFF)\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %llu: %s\n",\r\nreq, ret_obj->integer.value,\r\n"Corresponding TPM error");\r\nelse\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu %llu: %s\n",\r\nreq, ret_obj->integer.value,\r\n"Error");\r\n} else {\r\nstatus = scnprintf(buf, PAGE_SIZE, "%llu: %s\n",\r\nret_obj->integer.value, "No Recent Request");\r\n}\r\ncleanup:\r\nkfree(output.pointer);\r\nreturn status;\r\n}\r\nstatic ssize_t show_ppi_operations(char *buf, u32 start, u32 end)\r\n{\r\nchar *str = buf;\r\nchar version[PPI_VERSION_LEN];\r\nacpi_handle handle;\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object params[4];\r\nunion acpi_object obj;\r\nint i;\r\nu32 ret;\r\nchar *info[] = {\r\n"Not implemented",\r\n"BIOS only",\r\n"Blocked for OS by BIOS",\r\n"User required",\r\n"User not required",\r\n};\r\ninput.count = 4;\r\nppi_assign_params(params, TPM_PPI_FN_VERSION);\r\ninput.pointer = params;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ppi_callback, NULL,\r\ntpm_device_name, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENXIO;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM", &input, &output,\r\nACPI_TYPE_STRING);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nstrncpy(version,\r\n((union acpi_object *)output.pointer)->string.pointer,\r\nPPI_VERSION_LEN);\r\nkfree(output.pointer);\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nif (strcmp(version, "1.2") == -1)\r\nreturn -EPERM;\r\nparams[2].integer.value = TPM_PPI_FN_GETOPR;\r\nparams[3].package.count = 1;\r\nobj.type = ACPI_TYPE_INTEGER;\r\nparams[3].package.elements = &obj;\r\nfor (i = start; i <= end; i++) {\r\nobj.integer.value = i;\r\nstatus = acpi_evaluate_object_typed(handle, "_DSM",\r\n&input, &output, ACPI_TYPE_INTEGER);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENOMEM;\r\nret = ((union acpi_object *)output.pointer)->integer.value;\r\nif (ret > 0 && ret < ARRAY_SIZE(info))\r\nstr += scnprintf(str, PAGE_SIZE, "%d %d: %s\n",\r\ni, ret, info[ret]);\r\nkfree(output.pointer);\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t tpm_show_ppi_tcg_operations(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_ppi_operations(buf, 0, PPI_TPM_REQ_MAX);\r\n}\r\nstatic ssize_t tpm_show_ppi_vs_operations(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_ppi_operations(buf, PPI_VS_REQ_START, PPI_VS_REQ_END);\r\n}\r\nint tpm_add_ppi(struct kobject *parent)\r\n{\r\nreturn sysfs_create_group(parent, &ppi_attr_grp);\r\n}\r\nvoid tpm_remove_ppi(struct kobject *parent)\r\n{\r\nsysfs_remove_group(parent, &ppi_attr_grp);\r\n}
