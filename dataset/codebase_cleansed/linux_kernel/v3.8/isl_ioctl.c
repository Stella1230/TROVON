static int\r\nprism54_mib_mode_helper(islpci_private *priv, u32 iw_mode)\r\n{\r\nu32 config = INL_CONFIG_MANUALRUN;\r\nu32 mode, bsstype;\r\nif (iw_mode == IW_MODE_REPEAT || iw_mode == IW_MODE_SECOND) {\r\nprintk(KERN_DEBUG\r\n"%s(): Sorry, Repeater mode and Secondary mode "\r\n"are not yet supported by this driver.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npriv->iw_mode = iw_mode;\r\nswitch (iw_mode) {\r\ncase IW_MODE_AUTO:\r\nmode = INL_MODE_CLIENT;\r\nbsstype = DOT11_BSSTYPE_ANY;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nmode = INL_MODE_CLIENT;\r\nbsstype = DOT11_BSSTYPE_IBSS;\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nmode = INL_MODE_CLIENT;\r\nbsstype = DOT11_BSSTYPE_INFRA;\r\nbreak;\r\ncase IW_MODE_MASTER:\r\nmode = INL_MODE_AP;\r\nbsstype = DOT11_BSSTYPE_INFRA;\r\nbreak;\r\ncase IW_MODE_MONITOR:\r\nmode = INL_MODE_PROMISCUOUS;\r\nbsstype = DOT11_BSSTYPE_ANY;\r\nconfig |= INL_CONFIG_RXANNEX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (init_wds)\r\nconfig |= INL_CONFIG_WDS;\r\nmgt_set(priv, DOT11_OID_BSSTYPE, &bsstype);\r\nmgt_set(priv, OID_INL_CONFIG, &config);\r\nmgt_set(priv, OID_INL_MODE, &mode);\r\nreturn 0;\r\n}\r\nvoid\r\nprism54_mib_init(islpci_private *priv)\r\n{\r\nu32 channel, authen, wep, filter, dot1x, mlme, conformance, power, mode;\r\nstruct obj_buffer psm_buffer = {\r\n.size = PSM_BUFFER_SIZE,\r\n.addr = priv->device_psm_buffer\r\n};\r\nchannel = CARD_DEFAULT_CHANNEL;\r\nauthen = CARD_DEFAULT_AUTHEN;\r\nwep = CARD_DEFAULT_WEP;\r\nfilter = CARD_DEFAULT_FILTER;\r\ndot1x = CARD_DEFAULT_DOT1X;\r\nmlme = CARD_DEFAULT_MLME_MODE;\r\nconformance = CARD_DEFAULT_CONFORMANCE;\r\npower = 127;\r\nmode = CARD_DEFAULT_IW_MODE;\r\nmgt_set(priv, DOT11_OID_CHANNEL, &channel);\r\nmgt_set(priv, DOT11_OID_AUTHENABLE, &authen);\r\nmgt_set(priv, DOT11_OID_PRIVACYINVOKED, &wep);\r\nmgt_set(priv, DOT11_OID_PSMBUFFER, &psm_buffer);\r\nmgt_set(priv, DOT11_OID_EXUNENCRYPTED, &filter);\r\nmgt_set(priv, DOT11_OID_DOT1XENABLE, &dot1x);\r\nmgt_set(priv, DOT11_OID_MLMEAUTOLEVEL, &mlme);\r\nmgt_set(priv, OID_INL_DOT11D_CONFORMANCE, &conformance);\r\nmgt_set(priv, OID_INL_OUTPUTPOWER, &power);\r\nprism54_mib_mode_helper(priv, mode);\r\n}\r\nvoid\r\nprism54_update_stats(struct work_struct *work)\r\n{\r\nislpci_private *priv = container_of(work, islpci_private, stats_work);\r\nchar *data;\r\nint j;\r\nstruct obj_bss bss, *bss2;\r\nunion oid_res_t r;\r\nmutex_lock(&priv->stats_lock);\r\nmgt_get_request(priv, DOT11_OID_NOISEFLOOR, 0, NULL, &r);\r\npriv->local_iwstatistics.qual.noise = r.u;\r\nmgt_get_request(priv, DOT11_OID_BSSID, 0, NULL, &r);\r\ndata = r.ptr;\r\nmemcpy(bss.address, data, 6);\r\nkfree(data);\r\nj = mgt_get_request(priv, DOT11_OID_BSSFIND, 0, (void *) &bss, &r);\r\nbss2 = r.ptr;\r\npriv->local_iwstatistics.qual.level = bss2->rssi;\r\npriv->local_iwstatistics.qual.qual =\r\nbss2->rssi - priv->iwstatistics.qual.noise;\r\nkfree(bss2);\r\npriv->local_iwstatistics.qual.updated = 0x7;\r\nmgt_get_request(priv, DOT11_OID_PRIVRXFAILED, 0, NULL, &r);\r\npriv->local_iwstatistics.discard.code = r.u;\r\nmgt_get_request(priv, DOT11_OID_MPDUTXFAILED, 0, NULL, &r);\r\npriv->local_iwstatistics.discard.retries = r.u;\r\nmutex_unlock(&priv->stats_lock);\r\n}\r\nstruct iw_statistics *\r\nprism54_get_wireless_stats(struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nif (mutex_trylock(&priv->stats_lock)) {\r\nmemcpy(&priv->iwstatistics, &priv->local_iwstatistics,\r\nsizeof (struct iw_statistics));\r\npriv->local_iwstatistics.qual.updated = 0;\r\nmutex_unlock(&priv->stats_lock);\r\n} else\r\npriv->iwstatistics.qual.updated = 0;\r\nif ((priv->stats_timestamp == 0) ||\r\ntime_after(jiffies, priv->stats_timestamp + 1 * HZ)) {\r\nschedule_work(&priv->stats_work);\r\npriv->stats_timestamp = jiffies;\r\n}\r\nreturn &priv->iwstatistics;\r\n}\r\nstatic int\r\nprism54_commit(struct net_device *ndev, struct iw_request_info *info,\r\nchar *cwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nif (priv->iw_mode != IW_MODE_MONITOR)\r\nreturn mgt_set_request(priv, DOT11_OID_SSID, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_name(struct net_device *ndev, struct iw_request_info *info,\r\nchar *cwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nchar *capabilities;\r\nunion oid_res_t r;\r\nint rvalue;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT) {\r\nstrncpy(cwrq, "NOT READY!", IFNAMSIZ);\r\nreturn 0;\r\n}\r\nrvalue = mgt_get_request(priv, OID_INL_PHYCAPABILITIES, 0, NULL, &r);\r\nswitch (r.u) {\r\ncase INL_PHYCAP_5000MHZ:\r\ncapabilities = "IEEE 802.11a/b/g";\r\nbreak;\r\ncase INL_PHYCAP_FAA:\r\ncapabilities = "IEEE 802.11b/g - FAA Support";\r\nbreak;\r\ncase INL_PHYCAP_2400MHZ:\r\ndefault:\r\ncapabilities = "IEEE 802.11b/g";\r\nbreak;\r\n}\r\nstrncpy(cwrq, capabilities, IFNAMSIZ);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_freq(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_freq *fwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint rvalue;\r\nu32 c;\r\nif (fwrq->m < 1000)\r\nc = fwrq->m;\r\nelse\r\nc = (fwrq->e == 1) ? channel_of_freq(fwrq->m / 100000) : 0;\r\nrvalue = c ? mgt_set_request(priv, DOT11_OID_CHANNEL, 0, &c) : -EINVAL;\r\nreturn (rvalue ? rvalue : -EINPROGRESS);\r\n}\r\nstatic int\r\nprism54_get_freq(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_freq *fwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, DOT11_OID_CHANNEL, 0, NULL, &r);\r\nfwrq->i = r.u;\r\nrvalue |= mgt_get_request(priv, DOT11_OID_FREQUENCY, 0, NULL, &r);\r\nfwrq->m = r.u;\r\nfwrq->e = 3;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_mode(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nu32 mlmeautolevel = CARD_DEFAULT_MLME_MODE;\r\nif (*uwrq > IW_MODE_MONITOR || *uwrq < IW_MODE_AUTO) {\r\nprintk(KERN_DEBUG\r\n"%s: %s() You passed a non-valid init_mode.\n",\r\npriv->ndev->name, __func__);\r\nreturn -EINVAL;\r\n}\r\ndown_write(&priv->mib_sem);\r\nif (prism54_mib_mode_helper(priv, *uwrq)) {\r\nup_write(&priv->mib_sem);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif ((*uwrq == IW_MODE_MASTER) && (priv->acl.policy != MAC_POLICY_OPEN))\r\nmlmeautolevel = DOT11_MLME_INTERMEDIATE;\r\nif (priv->wpa)\r\nmlmeautolevel = DOT11_MLME_EXTENDED;\r\nmgt_set(priv, DOT11_OID_MLMEAUTOLEVEL, &mlmeautolevel);\r\nif (mgt_commit(priv)) {\r\nup_write(&priv->mib_sem);\r\nreturn -EIO;\r\n}\r\npriv->ndev->type = (priv->iw_mode == IW_MODE_MONITOR)\r\n? priv->monitor_type : ARPHRD_ETHER;\r\nup_write(&priv->mib_sem);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_mode(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nBUG_ON((priv->iw_mode < IW_MODE_AUTO) || (priv->iw_mode >\r\nIW_MODE_MONITOR));\r\n*uwrq = priv->iw_mode;\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_set_sens(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nu32 sens;\r\nsens = vwrq->disabled ? 20 : vwrq->value;\r\nreturn mgt_set_request(priv, DOT11_OID_EDTHRESHOLD, 0, &sens);\r\n}\r\nstatic int\r\nprism54_get_sens(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, DOT11_OID_EDTHRESHOLD, 0, NULL, &r);\r\nvwrq->value = r.u;\r\nvwrq->disabled = (vwrq->value == 0);\r\nvwrq->fixed = 1;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_get_range(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nislpci_private *priv = netdev_priv(ndev);\r\nu8 *data;\r\nint i, m, rvalue;\r\nstruct obj_frequencies *freq;\r\nunion oid_res_t r;\r\nmemset(range, 0, sizeof (struct iw_range));\r\ndwrq->length = sizeof (struct iw_range);\r\nrange->we_version_source = SUPPORTED_WIRELESS_EXT;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->num_encoding_sizes = 3;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->encoding_size[2] = 32;\r\nrange->max_encoding_tokens = 4;\r\nrange->max_qual.level = 0;\r\nrange->max_qual.noise = 0;\r\nrange->max_qual.qual = 0;\r\nrange->avg_qual.level = -80;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.qual = 0;\r\nrange->sensitivity = 200;\r\nrange->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;\r\nrange->retry_flags = IW_RETRY_LIMIT;\r\nrange->r_time_flags = IW_RETRY_LIFETIME;\r\nrange->min_retry = 1;\r\nrange->max_retry = 65535;\r\nrange->min_r_time = 1024;\r\nrange->max_r_time = 65535 * 1024;\r\nrange->txpower_capa = IW_TXPOW_DBM;\r\nrange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\r\nIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWAP));\r\nrange->event_capa[1] = IW_EVENT_CAPA_K_1;\r\nrange->event_capa[4] = IW_EVENT_CAPA_MASK(IWEVCUSTOM);\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\nrvalue =\r\nmgt_get_request(priv, DOT11_OID_SUPPORTEDFREQUENCIES, 0, NULL, &r);\r\nfreq = r.ptr;\r\nrange->num_channels = freq->nr;\r\nrange->num_frequency = freq->nr;\r\nm = min(IW_MAX_FREQUENCIES, (int) freq->nr);\r\nfor (i = 0; i < m; i++) {\r\nrange->freq[i].m = freq->mhz[i];\r\nrange->freq[i].e = 6;\r\nrange->freq[i].i = channel_of_freq(freq->mhz[i]);\r\n}\r\nkfree(freq);\r\nrvalue |= mgt_get_request(priv, DOT11_OID_SUPPORTEDRATES, 0, NULL, &r);\r\ndata = r.ptr;\r\ni = 0;\r\nwhile ((i < IW_MAX_BITRATES) && (*data != 0)) {\r\nrange->bitrate[i] = *data * 500000;\r\ni++;\r\ndata++;\r\n}\r\nrange->num_bitrates = i;\r\nkfree(r.ptr);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_wap(struct net_device *ndev, struct iw_request_info *info,\r\nstruct sockaddr *awrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nchar bssid[6];\r\nint rvalue;\r\nif (awrq->sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nmemcpy(&bssid[0], awrq->sa_data, 6);\r\nrvalue = mgt_set_request(priv, DOT11_OID_BSSID, 0, &bssid);\r\nreturn (rvalue ? rvalue : -EINPROGRESS);\r\n}\r\nstatic int\r\nprism54_get_wap(struct net_device *ndev, struct iw_request_info *info,\r\nstruct sockaddr *awrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, DOT11_OID_BSSID, 0, NULL, &r);\r\nmemcpy(awrq->sa_data, r.ptr, 6);\r\nawrq->sa_family = ARPHRD_ETHER;\r\nkfree(r.ptr);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_scan(struct net_device *dev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic char *\r\nprism54_translate_bss(struct net_device *ndev, struct iw_request_info *info,\r\nchar *current_ev, char *end_buf, struct obj_bss *bss,\r\nchar noise)\r\n{\r\nstruct iw_event iwe;\r\nshort cap;\r\nislpci_private *priv = netdev_priv(ndev);\r\nu8 wpa_ie[MAX_WPA_IE_LEN];\r\nsize_t wpa_ie_len;\r\nmemcpy(iwe.u.ap_addr.sa_data, bss->address, 6);\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\niwe.cmd = SIOCGIWAP;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_ADDR_LEN);\r\niwe.u.data.length = bss->ssid.length;\r\niwe.u.data.flags = 1;\r\niwe.cmd = SIOCGIWESSID;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, bss->ssid.octets);\r\n#define CAP_ESS 0x01\r\n#define CAP_IBSS 0x02\r\n#define CAP_CRYPT 0x10\r\ncap = bss->capinfo;\r\niwe.u.mode = 0;\r\nif (cap & CAP_ESS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse if (cap & CAP_IBSS)\r\niwe.u.mode = IW_MODE_ADHOC;\r\niwe.cmd = SIOCGIWMODE;\r\nif (iwe.u.mode)\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_UINT_LEN);\r\nif (cap & CAP_CRYPT)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\niwe.cmd = SIOCGIWENCODE;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, NULL);\r\niwe.u.freq.m = bss->channel;\r\niwe.u.freq.e = 6;\r\niwe.cmd = SIOCGIWFREQ;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_FREQ_LEN);\r\niwe.u.qual.level = bss->rssi;\r\niwe.u.qual.noise = noise;\r\niwe.u.qual.qual = bss->rssi - noise;\r\niwe.cmd = IWEVQUAL;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_QUAL_LEN);\r\nwpa_ie_len = prism54_wpa_bss_ie_get(priv, bss->address, wpa_ie);\r\nif (wpa_ie_len > 0) {\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = min(wpa_ie_len, (size_t)MAX_WPA_IE_LEN);\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, wpa_ie);\r\n}\r\n{\r\nchar *current_val = current_ev + iwe_stream_lcp_len(info);\r\nint i;\r\nint mask;\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\nmask = 0x1;\r\nfor(i = 0; i < sizeof(scan_rate_list); i++) {\r\nif(bss->rates & mask) {\r\niwe.u.bitrate.value = (scan_rate_list[i] * 500000);\r\ncurrent_val = iwe_stream_add_value(\r\ninfo, current_ev, current_val,\r\nend_buf, &iwe, IW_EV_PARAM_LEN);\r\n}\r\nmask <<= 1;\r\n}\r\nif ((current_val - current_ev) > iwe_stream_lcp_len(info))\r\ncurrent_ev = current_val;\r\n}\r\nreturn current_ev;\r\n}\r\nstatic int\r\nprism54_get_scan(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint i, rvalue;\r\nstruct obj_bsslist *bsslist;\r\nu32 noise = 0;\r\nchar *current_ev = extra;\r\nunion oid_res_t r;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT) {\r\ndwrq->length = 0;\r\nreturn 0;\r\n}\r\nrvalue = mgt_get_request(priv, DOT11_OID_NOISEFLOOR, 0, NULL, &r);\r\nnoise = r.u;\r\nrvalue |= mgt_get_request(priv, DOT11_OID_BSSLIST, 0, NULL, &r);\r\nbsslist = r.ptr;\r\nfor (i = 0; i < (int) bsslist->nr; i++) {\r\ncurrent_ev = prism54_translate_bss(ndev, info, current_ev,\r\nextra + dwrq->length,\r\n&(bsslist->bsslist[i]),\r\nnoise);\r\nif((extra + dwrq->length - current_ev) <= IW_EV_ADDR_LEN) {\r\nrvalue = -E2BIG;\r\nbreak;\r\n}\r\n}\r\nkfree(bsslist);\r\ndwrq->length = (current_ev - extra);\r\ndwrq->flags = 0;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_essid(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct obj_ssid essid;\r\nmemset(essid.octets, 0, 33);\r\nif (dwrq->flags && dwrq->length) {\r\nif (dwrq->length > 32)\r\nreturn -E2BIG;\r\nessid.length = dwrq->length;\r\nmemcpy(essid.octets, extra, dwrq->length);\r\n} else\r\nessid.length = 0;\r\nif (priv->iw_mode != IW_MODE_MONITOR)\r\nreturn mgt_set_request(priv, DOT11_OID_SSID, 0, &essid);\r\nmgt_set(priv, DOT11_OID_SSID, &essid);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_essid(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct obj_ssid *essid;\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, DOT11_OID_SSID, 0, NULL, &r);\r\nessid = r.ptr;\r\nif (essid->length) {\r\ndwrq->flags = 1;\r\ndwrq->length = min((u8)IW_ESSID_MAX_SIZE, essid->length);\r\n} else {\r\ndwrq->flags = 0;\r\ndwrq->length = 0;\r\n}\r\nessid->octets[dwrq->length] = '\0';\r\nmemcpy(extra, essid->octets, dwrq->length);\r\nkfree(essid);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_nick(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nif (dwrq->length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\ndown_write(&priv->mib_sem);\r\nmemset(priv->nickname, 0, sizeof (priv->nickname));\r\nmemcpy(priv->nickname, extra, dwrq->length);\r\nup_write(&priv->mib_sem);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_nick(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\ndwrq->length = 0;\r\ndown_read(&priv->mib_sem);\r\ndwrq->length = strlen(priv->nickname);\r\nmemcpy(extra, priv->nickname, dwrq->length);\r\nup_read(&priv->mib_sem);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_set_rate(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nu32 rate, profile;\r\nchar *data;\r\nint ret, i;\r\nunion oid_res_t r;\r\nif (vwrq->value == -1) {\r\nprofile = 1;\r\nreturn mgt_set_request(priv, DOT11_OID_PROFILES, 0, &profile);\r\n}\r\nret = mgt_get_request(priv, DOT11_OID_SUPPORTEDRATES, 0, NULL, &r);\r\nif (ret) {\r\nkfree(r.ptr);\r\nreturn ret;\r\n}\r\nrate = (u32) (vwrq->value / 500000);\r\ndata = r.ptr;\r\ni = 0;\r\nwhile (data[i]) {\r\nif (rate && (data[i] == rate)) {\r\nbreak;\r\n}\r\nif (vwrq->value == i) {\r\nbreak;\r\n}\r\ndata[i] |= 0x80;\r\ni++;\r\n}\r\nif (!data[i]) {\r\nkfree(r.ptr);\r\nreturn -EINVAL;\r\n}\r\ndata[i] |= 0x80;\r\ndata[i + 1] = 0;\r\nif (vwrq->fixed) {\r\ndata[0] = data[i];\r\ndata[1] = 0;\r\n}\r\nprofile = -1;\r\nret = mgt_set_request(priv, DOT11_OID_PROFILES, 0, &profile);\r\nret |= mgt_set_request(priv, DOT11_OID_EXTENDEDRATES, 0, data);\r\nret |= mgt_set_request(priv, DOT11_OID_RATES, 0, data);\r\nkfree(r.ptr);\r\nreturn ret;\r\n}\r\nstatic int\r\nprism54_get_rate(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint rvalue;\r\nchar *data;\r\nunion oid_res_t r;\r\nif ((rvalue = mgt_get_request(priv, GEN_OID_LINKSTATE, 0, NULL, &r)))\r\nreturn rvalue;\r\nvwrq->value = r.u * 500000;\r\nrvalue = mgt_get_request(priv, DOT11_OID_RATES, 0, NULL, &r);\r\nif (rvalue) {\r\nkfree(r.ptr);\r\nreturn rvalue;\r\n}\r\ndata = r.ptr;\r\nvwrq->fixed = (data[0] != 0) && (data[1] == 0);\r\nkfree(r.ptr);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_set_rts(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nreturn mgt_set_request(priv, DOT11_OID_RTSTHRESH, 0, &vwrq->value);\r\n}\r\nstatic int\r\nprism54_get_rts(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, DOT11_OID_RTSTHRESH, 0, NULL, &r);\r\nvwrq->value = r.u;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_frag(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nreturn mgt_set_request(priv, DOT11_OID_FRAGTHRESH, 0, &vwrq->value);\r\n}\r\nstatic int\r\nprism54_get_frag(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, DOT11_OID_FRAGTHRESH, 0, NULL, &r);\r\nvwrq->value = r.u;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_retry(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nu32 slimit = 0, llimit = 0;\r\nu32 lifetime = 0;\r\nint rvalue = 0;\r\nif (vwrq->disabled)\r\nreturn -EINVAL;\r\nif (vwrq->flags & IW_RETRY_LIMIT) {\r\nif (vwrq->flags & IW_RETRY_SHORT)\r\nslimit = vwrq->value;\r\nelse if (vwrq->flags & IW_RETRY_LONG)\r\nllimit = vwrq->value;\r\nelse {\r\nslimit = vwrq->value;\r\nllimit = vwrq->value;\r\n}\r\n}\r\nif (vwrq->flags & IW_RETRY_LIFETIME)\r\nlifetime = vwrq->value / 1024;\r\nif (slimit)\r\nrvalue =\r\nmgt_set_request(priv, DOT11_OID_SHORTRETRIES, 0, &slimit);\r\nif (llimit)\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_LONGRETRIES, 0, &llimit);\r\nif (lifetime)\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_MAXTXLIFETIME, 0,\r\n&lifetime);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_get_retry(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue = 0;\r\nvwrq->disabled = 0;\r\nif ((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\r\nrvalue =\r\nmgt_get_request(priv, DOT11_OID_MAXTXLIFETIME, 0, NULL, &r);\r\nvwrq->value = r.u * 1024;\r\nvwrq->flags = IW_RETRY_LIFETIME;\r\n} else if ((vwrq->flags & IW_RETRY_LONG)) {\r\nrvalue |=\r\nmgt_get_request(priv, DOT11_OID_LONGRETRIES, 0, NULL, &r);\r\nvwrq->value = r.u;\r\nvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\n} else {\r\nrvalue |=\r\nmgt_get_request(priv, DOT11_OID_SHORTRETRIES, 0, NULL, &r);\r\nvwrq->value = r.u;\r\nvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;\r\n}\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_encode(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint rvalue = 0, force = 0;\r\nint authen = DOT11_AUTH_OS, invoke = 0, exunencrypt = 0;\r\nunion oid_res_t r;\r\nif (dwrq->length > 0) {\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nint current_index;\r\nstruct obj_key key = { DOT11_PRIV_WEP, 0, "" };\r\nrvalue = mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);\r\ncurrent_index = r.u;\r\nif (!(dwrq->flags & IW_ENCODE_NOKEY)) {\r\nif (dwrq->length > KEY_SIZE_TKIP) {\r\nreturn -EINVAL;\r\n}\r\nif (dwrq->length > KEY_SIZE_WEP104) {\r\nkey.type = DOT11_PRIV_TKIP;\r\nkey.length = KEY_SIZE_TKIP;\r\n} else if (dwrq->length > KEY_SIZE_WEP40) {\r\nkey.length = KEY_SIZE_WEP104;\r\n} else {\r\nkey.length = KEY_SIZE_WEP40;\r\n}\r\nmemset(key.key, 0, sizeof (key.key));\r\nmemcpy(key.key, extra, dwrq->length);\r\nif ((index < 0) || (index > 3))\r\nindex = current_index;\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_DEFKEYX, index,\r\n&key);\r\n}\r\nif ((index == current_index) && (key.length > 0))\r\nforce = 1;\r\n} else {\r\nint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nif ((index >= 0) && (index <= 3)) {\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_DEFKEYID, 0,\r\n&index);\r\n} else {\r\nif (!(dwrq->flags & IW_ENCODE_MODE)) {\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (dwrq->flags & IW_ENCODE_DISABLED) {\r\n}\r\nif (dwrq->flags & IW_ENCODE_OPEN)\r\ninvoke = 1;\r\nif ((dwrq->flags & IW_ENCODE_RESTRICTED) || force) {\r\nauthen = DOT11_AUTH_BOTH;\r\ninvoke = 1;\r\nexunencrypt = 1;\r\n}\r\nif ((dwrq->flags & IW_ENCODE_MODE) || force) {\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_AUTHENABLE, 0, &authen);\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_PRIVACYINVOKED, 0, &invoke);\r\nrvalue |=\r\nmgt_set_request(priv, DOT11_OID_EXUNENCRYPTED, 0,\r\n&exunencrypt);\r\n}\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_get_encode(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct obj_key *key;\r\nu32 devindex, index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\r\nu32 authen = 0, invoke = 0, exunencrypt = 0;\r\nint rvalue;\r\nunion oid_res_t r;\r\nrvalue = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);\r\nauthen = r.u;\r\nrvalue |= mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);\r\ninvoke = r.u;\r\nrvalue |= mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);\r\nexunencrypt = r.u;\r\nif (invoke && (authen == DOT11_AUTH_BOTH) && exunencrypt)\r\ndwrq->flags = IW_ENCODE_RESTRICTED;\r\nelse if ((authen == DOT11_AUTH_OS) && !exunencrypt) {\r\nif (invoke)\r\ndwrq->flags = IW_ENCODE_OPEN;\r\nelse\r\ndwrq->flags = IW_ENCODE_DISABLED;\r\n} else\r\ndwrq->flags = 0;\r\nrvalue |= mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);\r\ndevindex = r.u;\r\nif (index == -1 || index > 3)\r\nindex = devindex;\r\nrvalue |= mgt_get_request(priv, DOT11_OID_DEFKEYX, index, NULL, &r);\r\nkey = r.ptr;\r\ndwrq->length = key->length;\r\nmemcpy(extra, key->key, dwrq->length);\r\nkfree(key);\r\ndwrq->flags |= devindex + 1;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_get_txpower(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nunion oid_res_t r;\r\nint rvalue;\r\nrvalue = mgt_get_request(priv, OID_INL_OUTPUTPOWER, 0, NULL, &r);\r\nvwrq->value = (s32) r.u / 4;\r\nvwrq->fixed = 1;\r\nvwrq->disabled = 0;\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_txpower(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_param *vwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\ns32 u = vwrq->value;\r\nu *= 4;\r\nif (vwrq->disabled) {\r\nprintk(KERN_DEBUG\r\n"%s: %s() disabling radio is not yet supported.\n",\r\npriv->ndev->name, __func__);\r\nreturn -ENOTSUPP;\r\n} else if (vwrq->fixed)\r\nreturn mgt_set_request(priv, OID_INL_OUTPUTPOWER, 0, &u);\r\nelse {\r\nprintk(KERN_DEBUG\r\n"%s: %s() auto power will be implemented later.\n",\r\npriv->ndev->name, __func__);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nstatic int prism54_set_genie(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint alen, ret = 0;\r\nstruct obj_attachment *attach;\r\nif (data->length > MAX_WPA_IE_LEN ||\r\n(data->length && extra == NULL))\r\nreturn -EINVAL;\r\nmemcpy(priv->wpa_ie, extra, data->length);\r\npriv->wpa_ie_len = data->length;\r\nalen = sizeof(*attach) + priv->wpa_ie_len;\r\nattach = kzalloc(alen, GFP_KERNEL);\r\nif (attach == NULL)\r\nreturn -ENOMEM;\r\n#define WLAN_FC_TYPE_MGMT 0\r\n#define WLAN_FC_STYPE_ASSOC_REQ 0\r\n#define WLAN_FC_STYPE_REASSOC_REQ 2\r\nattach->type = (WLAN_FC_TYPE_MGMT << 2) |\r\n(WLAN_FC_STYPE_ASSOC_REQ << 4);\r\nattach->id = -1;\r\nattach->size = priv->wpa_ie_len;\r\nmemcpy(attach->data, extra, priv->wpa_ie_len);\r\nret = mgt_set_varlen(priv, DOT11_OID_ATTACHMENT, attach,\r\npriv->wpa_ie_len);\r\nif (ret == 0) {\r\nattach->type = (WLAN_FC_TYPE_MGMT << 2) |\r\n(WLAN_FC_STYPE_REASSOC_REQ << 4);\r\nret = mgt_set_varlen(priv, DOT11_OID_ATTACHMENT, attach,\r\npriv->wpa_ie_len);\r\nif (ret == 0)\r\nprintk(KERN_DEBUG "%s: WPA IE Attachment was set\n",\r\nndev->name);\r\n}\r\nkfree(attach);\r\nreturn ret;\r\n}\r\nstatic int prism54_get_genie(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint len = priv->wpa_ie_len;\r\nif (len <= 0) {\r\ndata->length = 0;\r\nreturn 0;\r\n}\r\nif (data->length < len)\r\nreturn -E2BIG;\r\ndata->length = len;\r\nmemcpy(extra, priv->wpa_ie, len);\r\nreturn 0;\r\n}\r\nstatic int prism54_set_auth(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct iw_param *param = &wrqu->param;\r\nu32 mlmelevel = 0, authen = 0, dot1x = 0;\r\nu32 exunencrypt = 0, privinvoked = 0, wpa = 0;\r\nu32 old_wpa;\r\nint ret = 0;\r\nunion oid_res_t r;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\ndown_write(&priv->mib_sem);\r\nwpa = old_wpa = priv->wpa;\r\nup_write(&priv->mib_sem);\r\nret = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);\r\nauthen = r.u;\r\nret = mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);\r\nprivinvoked = r.u;\r\nret = mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);\r\nexunencrypt = r.u;\r\nret = mgt_get_request(priv, DOT11_OID_DOT1XENABLE, 0, NULL, &r);\r\ndot1x = r.u;\r\nret = mgt_get_request(priv, DOT11_OID_MLMEAUTOLEVEL, 0, NULL, &r);\r\nmlmelevel = r.u;\r\nif (ret < 0)\r\ngoto out;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nif (param->value) {\r\nwpa = 1;\r\nprivinvoked = 1;\r\nexunencrypt = 1;\r\ndot1x = 0x01;\r\nmlmelevel = DOT11_MLME_EXTENDED;\r\nauthen = DOT11_AUTH_OS;\r\n} else {\r\nwpa = 0;\r\nprivinvoked = 0;\r\nexunencrypt = 0;\r\ndot1x = 0;\r\nmlmelevel = DOT11_MLME_AUTO;\r\n}\r\nbreak;\r\ncase IW_AUTH_WPA_VERSION:\r\nif (param->value & IW_AUTH_WPA_VERSION_DISABLED) {\r\nwpa = 0;\r\nprivinvoked = 0;\r\nexunencrypt = 0;\r\ndot1x = 0;\r\nmlmelevel = DOT11_MLME_AUTO;\r\n} else {\r\nif (param->value & IW_AUTH_WPA_VERSION_WPA)\r\nwpa = 1;\r\nelse if (param->value & IW_AUTH_WPA_VERSION_WPA2)\r\nwpa = 2;\r\nprivinvoked = 1;\r\nexunencrypt = 1;\r\ndot1x = 0x01;\r\nmlmelevel = DOT11_MLME_EXTENDED;\r\nauthen = DOT11_AUTH_OS;\r\n}\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\ndot1x = param->value ? 0 : 0x01;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nprivinvoked = param->value ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nexunencrypt = param->value ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (param->value & IW_AUTH_ALG_SHARED_KEY) {\r\nif (wpa > 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nauthen = DOT11_AUTH_SK;\r\n} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\nauthen = DOT11_AUTH_OS;\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\ndown_write(&priv->mib_sem);\r\npriv->wpa = wpa;\r\nup_write(&priv->mib_sem);\r\nmgt_set_request(priv, DOT11_OID_AUTHENABLE, 0, &authen);\r\nmgt_set_request(priv, DOT11_OID_PRIVACYINVOKED, 0, &privinvoked);\r\nmgt_set_request(priv, DOT11_OID_EXUNENCRYPTED, 0, &exunencrypt);\r\nmgt_set_request(priv, DOT11_OID_DOT1XENABLE, 0, &dot1x);\r\nmgt_set_request(priv, DOT11_OID_MLMEAUTOLEVEL, 0, &mlmelevel);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int prism54_get_auth(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct iw_param *param = &wrqu->param;\r\nu32 wpa = 0;\r\nint ret = 0;\r\nunion oid_res_t r;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\ndown_write(&priv->mib_sem);\r\nwpa = priv->wpa;\r\nup_write(&priv->mib_sem);\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase IW_AUTH_WPA_VERSION:\r\nswitch (wpa) {\r\ncase 1:\r\nparam->value = IW_AUTH_WPA_VERSION_WPA;\r\nbreak;\r\ncase 2:\r\nparam->value = IW_AUTH_WPA_VERSION_WPA2;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nparam->value = IW_AUTH_WPA_VERSION_DISABLED;\r\nbreak;\r\n}\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nret = mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);\r\nif (ret >= 0)\r\nparam->value = r.u > 0 ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nret = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);\r\nif (ret >= 0) {\r\nswitch (r.u) {\r\ncase DOT11_AUTH_OS:\r\nparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\r\nbreak;\r\ncase DOT11_AUTH_BOTH:\r\ncase DOT11_AUTH_SK:\r\nparam->value = IW_AUTH_ALG_SHARED_KEY;\r\ncase DOT11_AUTH_NONE:\r\ndefault:\r\nparam->value = 0;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nparam->value = wpa > 0 ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nret = mgt_get_request(priv, DOT11_OID_DOT1XENABLE, 0, NULL, &r);\r\nif (ret >= 0)\r\nparam->value = r.u > 0 ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nret = mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);\r\nif (ret >= 0)\r\nparam->value = r.u > 0 ? 1 : 0;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism54_set_encodeext(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, alg = ext->alg, set_key = 1;\r\nunion oid_res_t r;\r\nint authen = DOT11_AUTH_OS, invoke = 0, exunencrypt = 0;\r\nint ret = 0;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\nidx = (encoding->flags & IW_ENCODE_INDEX) - 1;\r\nif (idx) {\r\nif (idx < 0 || idx > 3)\r\nreturn -EINVAL;\r\n} else {\r\nret = mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);\r\nif (ret < 0)\r\ngoto out;\r\nidx = r.u;\r\n}\r\nif (encoding->flags & IW_ENCODE_DISABLED)\r\nalg = IW_ENCODE_ALG_NONE;\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\nret = mgt_set_request(priv, DOT11_OID_DEFKEYID, 0, &idx);\r\nset_key = ext->key_len > 0 ? 1 : 0;\r\n}\r\nif (set_key) {\r\nstruct obj_key key = { DOT11_PRIV_WEP, 0, "" };\r\nswitch (alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nif (ext->key_len > KEY_SIZE_WEP104) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ext->key_len > KEY_SIZE_WEP40)\r\nkey.length = KEY_SIZE_WEP104;\r\nelse\r\nkey.length = KEY_SIZE_WEP40;\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nif (ext->key_len > KEY_SIZE_TKIP) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nkey.type = DOT11_PRIV_TKIP;\r\nkey.length = KEY_SIZE_TKIP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (key.length) {\r\nmemset(key.key, 0, sizeof(key.key));\r\nmemcpy(key.key, ext->key, ext->key_len);\r\nret = mgt_set_request(priv, DOT11_OID_DEFKEYX, idx,\r\n&key);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n}\r\nif (encoding->flags & IW_ENCODE_DISABLED) {\r\n}\r\nif (encoding->flags & IW_ENCODE_OPEN) {\r\ninvoke = 1;\r\n}\r\nif (encoding->flags & IW_ENCODE_RESTRICTED) {\r\nauthen = DOT11_AUTH_BOTH;\r\ninvoke = 1;\r\nexunencrypt = 1;\r\n}\r\nif (encoding->flags & IW_ENCODE_MODE) {\r\nret = mgt_set_request(priv, DOT11_OID_AUTHENABLE, 0,\r\n&authen);\r\nret = mgt_set_request(priv, DOT11_OID_PRIVACYINVOKED, 0,\r\n&invoke);\r\nret = mgt_set_request(priv, DOT11_OID_EXUNENCRYPTED, 0,\r\n&exunencrypt);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int prism54_get_encodeext(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, max_key_len;\r\nunion oid_res_t r;\r\nint authen = DOT11_AUTH_OS, invoke = 0, exunencrypt = 0, wpa = 0;\r\nint ret = 0;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\nret = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);\r\nauthen = r.u;\r\nret = mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);\r\ninvoke = r.u;\r\nret = mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);\r\nexunencrypt = r.u;\r\nif (ret < 0)\r\ngoto out;\r\nmax_key_len = encoding->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nidx = (encoding->flags & IW_ENCODE_INDEX) - 1;\r\nif (idx) {\r\nif (idx < 0 || idx > 3)\r\nreturn -EINVAL;\r\n} else {\r\nret = mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);\r\nif (ret < 0)\r\ngoto out;\r\nidx = r.u;\r\n}\r\nencoding->flags = idx + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nswitch (authen) {\r\ncase DOT11_AUTH_BOTH:\r\ncase DOT11_AUTH_SK:\r\nwrqu->encoding.flags |= IW_ENCODE_RESTRICTED;\r\ncase DOT11_AUTH_OS:\r\ndefault:\r\nwrqu->encoding.flags |= IW_ENCODE_OPEN;\r\nbreak;\r\n}\r\ndown_write(&priv->mib_sem);\r\nwpa = priv->wpa;\r\nup_write(&priv->mib_sem);\r\nif (authen == DOT11_AUTH_OS && !exunencrypt && !invoke && !wpa) {\r\next->alg = IW_ENCODE_ALG_NONE;\r\next->key_len = 0;\r\nwrqu->encoding.flags |= IW_ENCODE_DISABLED;\r\n} else {\r\nstruct obj_key *key;\r\nret = mgt_get_request(priv, DOT11_OID_DEFKEYX, idx, NULL, &r);\r\nif (ret < 0)\r\ngoto out;\r\nkey = r.ptr;\r\nif (max_key_len < key->length) {\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nmemcpy(ext->key, key->key, key->length);\r\next->key_len = key->length;\r\nswitch (key->type) {\r\ncase DOT11_PRIV_TKIP:\r\next->alg = IW_ENCODE_ALG_TKIP;\r\nbreak;\r\ndefault:\r\ncase DOT11_PRIV_WEP:\r\next->alg = IW_ENCODE_ALG_WEP;\r\nbreak;\r\n}\r\nwrqu->encoding.flags |= IW_ENCODE_ENABLED;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nprism54_reset(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_reset(netdev_priv(ndev), 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_oid(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nunion oid_res_t r;\r\nint rvalue;\r\nenum oid_num_t n = dwrq->flags;\r\nrvalue = mgt_get_request(netdev_priv(ndev), n, 0, NULL, &r);\r\ndwrq->length = mgt_response_to_str(n, &r, extra);\r\nif ((isl_oid[n].flags & OID_FLAG_TYPE) != OID_TYPE_U32)\r\nkfree(r.ptr);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_set_u32(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nu32 oid = uwrq[0], u = uwrq[1];\r\nreturn mgt_set_request(netdev_priv(ndev), oid, 0, &u);\r\n}\r\nstatic int\r\nprism54_set_raw(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nu32 oid = dwrq->flags;\r\nreturn mgt_set_request(netdev_priv(ndev), oid, 0, extra);\r\n}\r\nvoid\r\nprism54_acl_init(struct islpci_acl *acl)\r\n{\r\nmutex_init(&acl->lock);\r\nINIT_LIST_HEAD(&acl->mac_list);\r\nacl->size = 0;\r\nacl->policy = MAC_POLICY_OPEN;\r\n}\r\nstatic void\r\nprism54_clear_mac(struct islpci_acl *acl)\r\n{\r\nstruct list_head *ptr, *next;\r\nstruct mac_entry *entry;\r\nmutex_lock(&acl->lock);\r\nif (acl->size == 0) {\r\nmutex_unlock(&acl->lock);\r\nreturn;\r\n}\r\nfor (ptr = acl->mac_list.next, next = ptr->next;\r\nptr != &acl->mac_list; ptr = next, next = ptr->next) {\r\nentry = list_entry(ptr, struct mac_entry, _list);\r\nlist_del(ptr);\r\nkfree(entry);\r\n}\r\nacl->size = 0;\r\nmutex_unlock(&acl->lock);\r\n}\r\nvoid\r\nprism54_acl_clean(struct islpci_acl *acl)\r\n{\r\nprism54_clear_mac(acl);\r\n}\r\nstatic int\r\nprism54_add_mac(struct net_device *ndev, struct iw_request_info *info,\r\nstruct sockaddr *awrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_acl *acl = &priv->acl;\r\nstruct mac_entry *entry;\r\nstruct sockaddr *addr = (struct sockaddr *) extra;\r\nif (addr->sa_family != ARPHRD_ETHER)\r\nreturn -EOPNOTSUPP;\r\nentry = kmalloc(sizeof (struct mac_entry), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(entry->addr, addr->sa_data, ETH_ALEN);\r\nif (mutex_lock_interruptible(&acl->lock)) {\r\nkfree(entry);\r\nreturn -ERESTARTSYS;\r\n}\r\nlist_add_tail(&entry->_list, &acl->mac_list);\r\nacl->size++;\r\nmutex_unlock(&acl->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_del_mac(struct net_device *ndev, struct iw_request_info *info,\r\nstruct sockaddr *awrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_acl *acl = &priv->acl;\r\nstruct mac_entry *entry;\r\nstruct sockaddr *addr = (struct sockaddr *) extra;\r\nif (addr->sa_family != ARPHRD_ETHER)\r\nreturn -EOPNOTSUPP;\r\nif (mutex_lock_interruptible(&acl->lock))\r\nreturn -ERESTARTSYS;\r\nlist_for_each_entry(entry, &acl->mac_list, _list) {\r\nif (memcmp(entry->addr, addr->sa_data, ETH_ALEN) == 0) {\r\nlist_del(&entry->_list);\r\nacl->size--;\r\nkfree(entry);\r\nmutex_unlock(&acl->lock);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&acl->lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nprism54_get_mac(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_acl *acl = &priv->acl;\r\nstruct mac_entry *entry;\r\nstruct sockaddr *dst = (struct sockaddr *) extra;\r\ndwrq->length = 0;\r\nif (mutex_lock_interruptible(&acl->lock))\r\nreturn -ERESTARTSYS;\r\nlist_for_each_entry(entry, &acl->mac_list, _list) {\r\nmemcpy(dst->sa_data, entry->addr, ETH_ALEN);\r\ndst->sa_family = ARPHRD_ETHER;\r\ndwrq->length++;\r\ndst++;\r\n}\r\nmutex_unlock(&acl->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_set_policy(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_acl *acl = &priv->acl;\r\nu32 mlmeautolevel;\r\nprism54_clear_mac(acl);\r\nif ((*uwrq < MAC_POLICY_OPEN) || (*uwrq > MAC_POLICY_REJECT))\r\nreturn -EINVAL;\r\ndown_write(&priv->mib_sem);\r\nacl->policy = *uwrq;\r\nif ((priv->iw_mode == IW_MODE_MASTER) &&\r\n(acl->policy != MAC_POLICY_OPEN))\r\nmlmeautolevel = DOT11_MLME_INTERMEDIATE;\r\nelse\r\nmlmeautolevel = CARD_DEFAULT_MLME_MODE;\r\nif (priv->wpa)\r\nmlmeautolevel = DOT11_MLME_EXTENDED;\r\nmgt_set(priv, DOT11_OID_MLMEAUTOLEVEL, &mlmeautolevel);\r\nif (mgt_commit(priv)) {\r\nup_write(&priv->mib_sem);\r\nreturn -EIO;\r\n}\r\nup_write(&priv->mib_sem);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_policy(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_acl *acl = &priv->acl;\r\n*uwrq = acl->policy;\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_mac_accept(struct islpci_acl *acl, char *mac)\r\n{\r\nstruct mac_entry *entry;\r\nint res = 0;\r\nif (mutex_lock_interruptible(&acl->lock))\r\nreturn -ERESTARTSYS;\r\nif (acl->policy == MAC_POLICY_OPEN) {\r\nmutex_unlock(&acl->lock);\r\nreturn 1;\r\n}\r\nlist_for_each_entry(entry, &acl->mac_list, _list) {\r\nif (memcmp(entry->addr, mac, ETH_ALEN) == 0) {\r\nres = 1;\r\nbreak;\r\n}\r\n}\r\nres = (acl->policy == MAC_POLICY_ACCEPT) ? !res : res;\r\nmutex_unlock(&acl->lock);\r\nreturn res;\r\n}\r\nstatic int\r\nprism54_kick_all(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *dwrq, char *extra)\r\n{\r\nstruct obj_mlme *mlme;\r\nint rvalue;\r\nmlme = kmalloc(sizeof (struct obj_mlme), GFP_KERNEL);\r\nif (mlme == NULL)\r\nreturn -ENOMEM;\r\nmlme->id = 0;\r\nrvalue =\r\nmgt_set_request(netdev_priv(ndev), DOT11_OID_DISASSOCIATE, 0, mlme);\r\nkfree(mlme);\r\nreturn rvalue;\r\n}\r\nstatic int\r\nprism54_kick_mac(struct net_device *ndev, struct iw_request_info *info,\r\nstruct sockaddr *awrq, char *extra)\r\n{\r\nstruct obj_mlme *mlme;\r\nstruct sockaddr *addr = (struct sockaddr *) extra;\r\nint rvalue;\r\nif (addr->sa_family != ARPHRD_ETHER)\r\nreturn -EOPNOTSUPP;\r\nmlme = kmalloc(sizeof (struct obj_mlme), GFP_KERNEL);\r\nif (mlme == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(mlme->address, addr->sa_data, ETH_ALEN);\r\nmlme->id = -1;\r\nrvalue =\r\nmgt_set_request(netdev_priv(ndev), DOT11_OID_DISASSOCIATE, 0, mlme);\r\nkfree(mlme);\r\nreturn rvalue;\r\n}\r\nstatic void\r\nformat_event(islpci_private *priv, char *dest, const char *str,\r\nconst struct obj_mlme *mlme, u16 *length, int error)\r\n{\r\nint n = snprintf(dest, IW_CUSTOM_MAX,\r\n"%s %s %pM %s (%2.2X)",\r\nstr,\r\n((priv->iw_mode == IW_MODE_MASTER) ? "from" : "to"),\r\nmlme->address,\r\n(error ? (mlme->code ? " : REJECTED " : " : ACCEPTED ")\r\n: ""), mlme->code);\r\nBUG_ON(n > IW_CUSTOM_MAX);\r\n*length = n;\r\n}\r\nstatic void\r\nsend_formatted_event(islpci_private *priv, const char *str,\r\nconst struct obj_mlme *mlme, int error)\r\n{\r\nunion iwreq_data wrqu;\r\nchar *memptr;\r\nmemptr = kmalloc(IW_CUSTOM_MAX, GFP_KERNEL);\r\nif (!memptr)\r\nreturn;\r\nwrqu.data.pointer = memptr;\r\nwrqu.data.length = 0;\r\nformat_event(priv, memptr, str, mlme, &wrqu.data.length,\r\nerror);\r\nwireless_send_event(priv->ndev, IWEVCUSTOM, &wrqu, memptr);\r\nkfree(memptr);\r\n}\r\nstatic void\r\nsend_simple_event(islpci_private *priv, const char *str)\r\n{\r\nunion iwreq_data wrqu;\r\nchar *memptr;\r\nint n = strlen(str);\r\nmemptr = kmalloc(IW_CUSTOM_MAX, GFP_KERNEL);\r\nif (!memptr)\r\nreturn;\r\nBUG_ON(n >= IW_CUSTOM_MAX);\r\nwrqu.data.pointer = memptr;\r\nwrqu.data.length = n;\r\nstrcpy(memptr, str);\r\nwireless_send_event(priv->ndev, IWEVCUSTOM, &wrqu, memptr);\r\nkfree(memptr);\r\n}\r\nstatic void\r\nlink_changed(struct net_device *ndev, u32 bitrate)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nif (bitrate) {\r\nnetif_carrier_on(ndev);\r\nif (priv->iw_mode == IW_MODE_INFRA) {\r\nunion iwreq_data uwrq;\r\nprism54_get_wap(ndev, NULL, (struct sockaddr *) &uwrq,\r\nNULL);\r\nwireless_send_event(ndev, SIOCGIWAP, &uwrq, NULL);\r\n} else\r\nsend_simple_event(netdev_priv(ndev),\r\n"Link established");\r\n} else {\r\nnetif_carrier_off(ndev);\r\nsend_simple_event(netdev_priv(ndev), "Link lost");\r\n}\r\n}\r\nstatic void\r\nprism54_wpa_bss_ie_add(islpci_private *priv, u8 *bssid,\r\nu8 *wpa_ie, size_t wpa_ie_len)\r\n{\r\nstruct list_head *ptr;\r\nstruct islpci_bss_wpa_ie *bss = NULL;\r\nif (wpa_ie_len > MAX_WPA_IE_LEN)\r\nwpa_ie_len = MAX_WPA_IE_LEN;\r\nmutex_lock(&priv->wpa_lock);\r\nlist_for_each(ptr, &priv->bss_wpa_list) {\r\nbss = list_entry(ptr, struct islpci_bss_wpa_ie, list);\r\nif (memcmp(bss->bssid, bssid, ETH_ALEN) == 0) {\r\nlist_move(&bss->list, &priv->bss_wpa_list);\r\nbreak;\r\n}\r\nbss = NULL;\r\n}\r\nif (bss == NULL) {\r\nif (priv->num_bss_wpa >= MAX_BSS_WPA_IE_COUNT) {\r\nbss = list_entry(priv->bss_wpa_list.prev,\r\nstruct islpci_bss_wpa_ie, list);\r\nlist_del(&bss->list);\r\n} else {\r\nbss = kzalloc(sizeof (*bss), GFP_ATOMIC);\r\nif (bss != NULL)\r\npriv->num_bss_wpa++;\r\n}\r\nif (bss != NULL) {\r\nmemcpy(bss->bssid, bssid, ETH_ALEN);\r\nlist_add(&bss->list, &priv->bss_wpa_list);\r\n}\r\n}\r\nif (bss != NULL) {\r\nmemcpy(bss->wpa_ie, wpa_ie, wpa_ie_len);\r\nbss->wpa_ie_len = wpa_ie_len;\r\nbss->last_update = jiffies;\r\n} else {\r\nprintk(KERN_DEBUG "Failed to add BSS WPA entry for "\r\n"%pM\n", bssid);\r\n}\r\nwhile (priv->num_bss_wpa > 0) {\r\nbss = list_entry(priv->bss_wpa_list.prev,\r\nstruct islpci_bss_wpa_ie, list);\r\nif (!time_after(jiffies, bss->last_update + 60 * HZ))\r\nbreak;\r\nlist_del(&bss->list);\r\npriv->num_bss_wpa--;\r\nkfree(bss);\r\n}\r\nmutex_unlock(&priv->wpa_lock);\r\n}\r\nstatic size_t\r\nprism54_wpa_bss_ie_get(islpci_private *priv, u8 *bssid, u8 *wpa_ie)\r\n{\r\nstruct list_head *ptr;\r\nstruct islpci_bss_wpa_ie *bss = NULL;\r\nsize_t len = 0;\r\nmutex_lock(&priv->wpa_lock);\r\nlist_for_each(ptr, &priv->bss_wpa_list) {\r\nbss = list_entry(ptr, struct islpci_bss_wpa_ie, list);\r\nif (memcmp(bss->bssid, bssid, ETH_ALEN) == 0)\r\nbreak;\r\nbss = NULL;\r\n}\r\nif (bss) {\r\nlen = bss->wpa_ie_len;\r\nmemcpy(wpa_ie, bss->wpa_ie, len);\r\n}\r\nmutex_unlock(&priv->wpa_lock);\r\nreturn len;\r\n}\r\nvoid\r\nprism54_wpa_bss_ie_init(islpci_private *priv)\r\n{\r\nINIT_LIST_HEAD(&priv->bss_wpa_list);\r\nmutex_init(&priv->wpa_lock);\r\n}\r\nvoid\r\nprism54_wpa_bss_ie_clean(islpci_private *priv)\r\n{\r\nstruct islpci_bss_wpa_ie *bss, *n;\r\nlist_for_each_entry_safe(bss, n, &priv->bss_wpa_list, list) {\r\nkfree(bss);\r\n}\r\n}\r\nstatic void\r\nprism54_process_bss_data(islpci_private *priv, u32 oid, u8 *addr,\r\nu8 *payload, size_t len)\r\n{\r\nstruct ieee80211_beacon_phdr *hdr;\r\nu8 *pos, *end;\r\nif (!priv->wpa)\r\nreturn;\r\nhdr = (struct ieee80211_beacon_phdr *) payload;\r\npos = (u8 *) (hdr + 1);\r\nend = payload + len;\r\nwhile (pos < end) {\r\nif (pos + 2 + pos[1] > end) {\r\nprintk(KERN_DEBUG "Parsing Beacon/ProbeResp failed "\r\n"for %pM\n", addr);\r\nreturn;\r\n}\r\nif (pos[0] == WLAN_EID_GENERIC && pos[1] >= 4 &&\r\nmemcmp(pos + 2, wpa_oid, 4) == 0) {\r\nprism54_wpa_bss_ie_add(priv, addr, pos, pos[1] + 2);\r\nreturn;\r\n}\r\npos += 2 + pos[1];\r\n}\r\n}\r\nstatic void\r\nhandle_request(islpci_private *priv, struct obj_mlme *mlme, enum oid_num_t oid)\r\n{\r\nif (((mlme->state == DOT11_STATE_AUTHING) ||\r\n(mlme->state == DOT11_STATE_ASSOCING))\r\n&& mgt_mlme_answer(priv)) {\r\nmlme->code = prism54_mac_accept(&priv->acl,\r\nmlme->address) ? 0 : 1;\r\nmgt_set_request(priv, oid, 0, mlme);\r\n}\r\n}\r\nstatic int\r\nprism54_process_trap_helper(islpci_private *priv, enum oid_num_t oid,\r\nchar *data)\r\n{\r\nstruct obj_mlme *mlme = (struct obj_mlme *) data;\r\nstruct obj_mlmeex *mlmeex = (struct obj_mlmeex *) data;\r\nstruct obj_mlmeex *confirm;\r\nu8 wpa_ie[MAX_WPA_IE_LEN];\r\nint wpa_ie_len;\r\nsize_t len = 0;\r\nu8 *payload = NULL, *pos = NULL;\r\nint ret;\r\nif (oid >= DOT11_OID_BEACON) {\r\nlen = mlmeex->size;\r\npayload = pos = mlmeex->data;\r\n}\r\nif ((oid == DOT11_OID_BEACON) || (oid == DOT11_OID_PROBE))\r\nprism54_process_bss_data(priv, oid, mlmeex->address,\r\npayload, len);\r\nmgt_le_to_cpu(isl_oid[oid].flags & OID_FLAG_TYPE, (void *) mlme);\r\nswitch (oid) {\r\ncase GEN_OID_LINKSTATE:\r\nlink_changed(priv->ndev, (u32) *data);\r\nbreak;\r\ncase DOT11_OID_MICFAILURE:\r\nsend_simple_event(priv, "Mic failure");\r\nbreak;\r\ncase DOT11_OID_DEAUTHENTICATE:\r\nsend_formatted_event(priv, "DeAuthenticate request", mlme, 0);\r\nbreak;\r\ncase DOT11_OID_AUTHENTICATE:\r\nhandle_request(priv, mlme, oid);\r\nsend_formatted_event(priv, "Authenticate request", mlme, 1);\r\nbreak;\r\ncase DOT11_OID_DISASSOCIATE:\r\nsend_formatted_event(priv, "Disassociate request", mlme, 0);\r\nbreak;\r\ncase DOT11_OID_ASSOCIATE:\r\nhandle_request(priv, mlme, oid);\r\nsend_formatted_event(priv, "Associate request", mlme, 1);\r\nbreak;\r\ncase DOT11_OID_REASSOCIATE:\r\nhandle_request(priv, mlme, oid);\r\nsend_formatted_event(priv, "ReAssociate request", mlme, 1);\r\nbreak;\r\ncase DOT11_OID_BEACON:\r\nsend_formatted_event(priv,\r\n"Received a beacon from an unknown AP",\r\nmlme, 0);\r\nbreak;\r\ncase DOT11_OID_PROBE:\r\nsend_formatted_event(priv, "Received a probe from client", mlme,\r\n0);\r\nbreak;\r\ncase DOT11_OID_DEAUTHENTICATEEX:\r\nsend_formatted_event(priv, "DeAuthenticate request", mlme, 0);\r\nbreak;\r\ncase DOT11_OID_AUTHENTICATEEX:\r\nhandle_request(priv, mlme, oid);\r\nsend_formatted_event(priv, "Authenticate request (ex)", mlme, 1);\r\nif (priv->iw_mode != IW_MODE_MASTER\r\n&& mlmeex->state != DOT11_STATE_AUTHING)\r\nbreak;\r\nconfirm = kmalloc(sizeof(struct obj_mlmeex) + 6, GFP_ATOMIC);\r\nif (!confirm)\r\nbreak;\r\nmemcpy(&confirm->address, mlmeex->address, ETH_ALEN);\r\nprintk(KERN_DEBUG "Authenticate from: address:\t%pM\n",\r\nmlmeex->address);\r\nconfirm->id = -1;\r\nconfirm->state = 0;\r\nconfirm->code = 0;\r\nconfirm->size = 6;\r\nconfirm->data[0] = 0x00;\r\nconfirm->data[1] = 0x00;\r\nconfirm->data[2] = 0x02;\r\nconfirm->data[3] = 0x00;\r\nconfirm->data[4] = 0x00;\r\nconfirm->data[5] = 0x00;\r\nret = mgt_set_varlen(priv, DOT11_OID_ASSOCIATEEX, confirm, 6);\r\nkfree(confirm);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase DOT11_OID_DISASSOCIATEEX:\r\nsend_formatted_event(priv, "Disassociate request (ex)", mlme, 0);\r\nbreak;\r\ncase DOT11_OID_ASSOCIATEEX:\r\nhandle_request(priv, mlme, oid);\r\nsend_formatted_event(priv, "Associate request (ex)", mlme, 1);\r\nif (priv->iw_mode != IW_MODE_MASTER\r\n&& mlmeex->state != DOT11_STATE_ASSOCING)\r\nbreak;\r\nconfirm = kmalloc(sizeof(struct obj_mlmeex), GFP_ATOMIC);\r\nif (!confirm)\r\nbreak;\r\nmemcpy(&confirm->address, mlmeex->address, ETH_ALEN);\r\nconfirm->id = ((struct obj_mlmeex *)mlme)->id;\r\nconfirm->state = 0;\r\nconfirm->code = 0;\r\nwpa_ie_len = prism54_wpa_bss_ie_get(priv, mlmeex->address, wpa_ie);\r\nif (!wpa_ie_len) {\r\nprintk(KERN_DEBUG "No WPA IE found from address:\t%pM\n",\r\nmlmeex->address);\r\nkfree(confirm);\r\nbreak;\r\n}\r\nconfirm->size = wpa_ie_len;\r\nmemcpy(&confirm->data, wpa_ie, wpa_ie_len);\r\nmgt_set_varlen(priv, oid, confirm, wpa_ie_len);\r\nkfree(confirm);\r\nbreak;\r\ncase DOT11_OID_REASSOCIATEEX:\r\nhandle_request(priv, mlme, oid);\r\nsend_formatted_event(priv, "Reassociate request (ex)", mlme, 1);\r\nif (priv->iw_mode != IW_MODE_MASTER\r\n&& mlmeex->state != DOT11_STATE_ASSOCING)\r\nbreak;\r\nconfirm = kmalloc(sizeof(struct obj_mlmeex), GFP_ATOMIC);\r\nif (!confirm)\r\nbreak;\r\nmemcpy(&confirm->address, mlmeex->address, ETH_ALEN);\r\nconfirm->id = mlmeex->id;\r\nconfirm->state = 0;\r\nconfirm->code = 0;\r\nwpa_ie_len = prism54_wpa_bss_ie_get(priv, mlmeex->address, wpa_ie);\r\nif (!wpa_ie_len) {\r\nprintk(KERN_DEBUG "No WPA IE found from address:\t%pM\n",\r\nmlmeex->address);\r\nkfree(confirm);\r\nbreak;\r\n}\r\nconfirm->size = wpa_ie_len;\r\nmemcpy(&confirm->data, wpa_ie, wpa_ie_len);\r\nmgt_set_varlen(priv, oid, confirm, wpa_ie_len);\r\nkfree(confirm);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nprism54_process_trap(struct work_struct *work)\r\n{\r\nstruct islpci_mgmtframe *frame =\r\ncontainer_of(work, struct islpci_mgmtframe, ws);\r\nstruct net_device *ndev = frame->ndev;\r\nenum oid_num_t n = mgt_oidtonum(frame->header->oid);\r\nif (n != OID_NUM_LAST)\r\nprism54_process_trap_helper(netdev_priv(ndev), n, frame->data);\r\nislpci_mgt_release(frame);\r\n}\r\nint\r\nprism54_set_mac_address(struct net_device *ndev, void *addr)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nint ret;\r\nif (ndev->addr_len != 6)\r\nreturn -EINVAL;\r\nret = mgt_set_request(priv, GEN_OID_MACADDRESS, 0,\r\n&((struct sockaddr *) addr)->sa_data);\r\nif (!ret)\r\nmemcpy(priv->ndev->dev_addr,\r\n&((struct sockaddr *) addr)->sa_data, 6);\r\nreturn ret;\r\n}\r\nstatic int\r\nprism54_set_wpa(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nu32 mlme, authen, dot1x, filter, wep;\r\nif (islpci_get_state(priv) < PRV_STATE_INIT)\r\nreturn 0;\r\nwep = 1;\r\nfilter = 1;\r\ndot1x = 0x01;\r\nmlme = DOT11_MLME_EXTENDED;\r\nauthen = DOT11_AUTH_OS;\r\ndown_write(&priv->mib_sem);\r\npriv->wpa = *uwrq;\r\nswitch (priv->wpa) {\r\ndefault:\r\ncase 0:\r\nwep = 0;\r\nfilter = 0;\r\ndot1x = 0;\r\nmlme = DOT11_MLME_AUTO;\r\nprintk("%s: Disabling WPA\n", ndev->name);\r\nbreak;\r\ncase 2:\r\ncase 1:\r\nprintk("%s: Enabling WPA\n", ndev->name);\r\nbreak;\r\n}\r\nup_write(&priv->mib_sem);\r\nmgt_set_request(priv, DOT11_OID_AUTHENABLE, 0, &authen);\r\nmgt_set_request(priv, DOT11_OID_PRIVACYINVOKED, 0, &wep);\r\nmgt_set_request(priv, DOT11_OID_EXUNENCRYPTED, 0, &filter);\r\nmgt_set_request(priv, DOT11_OID_DOT1XENABLE, 0, &dot1x);\r\nmgt_set_request(priv, DOT11_OID_MLMEAUTOLEVEL, 0, &mlme);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_wpa(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\n*uwrq = priv->wpa;\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_set_prismhdr(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\npriv->monitor_type =\r\n(*uwrq ? ARPHRD_IEEE80211_PRISM : ARPHRD_IEEE80211);\r\nif (priv->iw_mode == IW_MODE_MONITOR)\r\npriv->ndev->type = priv->monitor_type;\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_get_prismhdr(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\n*uwrq = (priv->monitor_type == ARPHRD_IEEE80211_PRISM);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_debug_oid(struct net_device *ndev, struct iw_request_info *info,\r\n__u32 * uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\npriv->priv_oid = *uwrq;\r\nprintk("%s: oid 0x%08X\n", ndev->name, *uwrq);\r\nreturn 0;\r\n}\r\nstatic int\r\nprism54_debug_get_oid(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_mgmtframe *response;\r\nint ret = -EIO;\r\nprintk("%s: get_oid 0x%08X\n", ndev->name, priv->priv_oid);\r\ndata->length = 0;\r\nif (islpci_get_state(priv) >= PRV_STATE_INIT) {\r\nret =\r\nislpci_mgt_transaction(priv->ndev, PIMFOR_OP_GET,\r\npriv->priv_oid, extra, 256,\r\n&response);\r\nprintk("%s: ret: %i\n", ndev->name, ret);\r\nif (ret || !response\r\n|| response->header->operation == PIMFOR_OP_ERROR) {\r\nif (response) {\r\nislpci_mgt_release(response);\r\n}\r\nprintk("%s: EIO\n", ndev->name);\r\nret = -EIO;\r\n}\r\nif (!ret) {\r\ndata->length = response->header->length;\r\nmemcpy(extra, response->data, data->length);\r\nislpci_mgt_release(response);\r\nprintk("%s: len: %i\n", ndev->name, data->length);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nprism54_debug_set_oid(struct net_device *ndev, struct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nstruct islpci_mgmtframe *response;\r\nint ret = 0, response_op = PIMFOR_OP_ERROR;\r\nprintk("%s: set_oid 0x%08X\tlen: %d\n", ndev->name, priv->priv_oid,\r\ndata->length);\r\nif (islpci_get_state(priv) >= PRV_STATE_INIT) {\r\nret =\r\nislpci_mgt_transaction(priv->ndev, PIMFOR_OP_SET,\r\npriv->priv_oid, extra, data->length,\r\n&response);\r\nprintk("%s: ret: %i\n", ndev->name, ret);\r\nif (ret || !response\r\n|| response->header->operation == PIMFOR_OP_ERROR) {\r\nif (response) {\r\nislpci_mgt_release(response);\r\n}\r\nprintk("%s: EIO\n", ndev->name);\r\nret = -EIO;\r\n}\r\nif (!ret) {\r\nresponse_op = response->header->operation;\r\nprintk("%s: response_op: %i\n", ndev->name,\r\nresponse_op);\r\nislpci_mgt_release(response);\r\n}\r\n}\r\nreturn (ret ? ret : -EINPROGRESS);\r\n}\r\nstatic int\r\nprism54_set_spy(struct net_device *ndev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *uwrq, char *extra)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nu32 u;\r\nenum oid_num_t oid = OID_INL_CONFIG;\r\ndown_write(&priv->mib_sem);\r\nmgt_get(priv, OID_INL_CONFIG, &u);\r\nif ((uwrq->data.length == 0) && (priv->spy_data.spy_number > 0))\r\nu &= ~INL_CONFIG_RXANNEX;\r\nelse if ((uwrq->data.length > 0) && (priv->spy_data.spy_number == 0))\r\nu |= INL_CONFIG_RXANNEX;\r\nmgt_set(priv, OID_INL_CONFIG, &u);\r\nmgt_commit_list(priv, &oid, 1);\r\nup_write(&priv->mib_sem);\r\nreturn iw_handler_set_spy(ndev, info, uwrq, extra);\r\n}
