static int asd_get_ddb(struct asd_ha_struct *asd_ha)\r\n{\r\nint ddb, i;\r\nddb = FIND_FREE_DDB(asd_ha);\r\nif (ddb >= asd_ha->hw_prof.max_ddbs) {\r\nddb = -ENOMEM;\r\ngoto out;\r\n}\r\nSET_DDB(ddb, asd_ha);\r\nfor (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4)\r\nasd_ddbsite_write_dword(asd_ha, ddb, i, 0);\r\nout:\r\nreturn ddb;\r\n}\r\nstatic void asd_free_ddb(struct asd_ha_struct *asd_ha, int ddb)\r\n{\r\nif (!ddb || ddb >= 0xFFFF)\r\nreturn;\r\nasd_ddbsite_write_byte(asd_ha, ddb, DDB_TYPE, DDB_TYPE_UNUSED);\r\nCLEAR_DDB(ddb, asd_ha);\r\n}\r\nstatic void asd_set_ddb_type(struct domain_device *dev)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nint ddb = (int) (unsigned long) dev->lldd_dev;\r\nif (dev->dev_type == SATA_PM_PORT)\r\nasd_ddbsite_write_byte(asd_ha,ddb, DDB_TYPE, DDB_TYPE_PM_PORT);\r\nelse if (dev->tproto)\r\nasd_ddbsite_write_byte(asd_ha,ddb, DDB_TYPE, DDB_TYPE_TARGET);\r\nelse\r\nasd_ddbsite_write_byte(asd_ha,ddb,DDB_TYPE,DDB_TYPE_INITIATOR);\r\n}\r\nstatic int asd_init_sata_tag_ddb(struct domain_device *dev)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nint ddb, i;\r\nddb = asd_get_ddb(asd_ha);\r\nif (ddb < 0)\r\nreturn ddb;\r\nfor (i = 0; i < sizeof(struct asd_ddb_sata_tag); i += 2)\r\nasd_ddbsite_write_word(asd_ha, ddb, i, 0xFFFF);\r\nasd_ddbsite_write_word(asd_ha, (int) (unsigned long) dev->lldd_dev,\r\nSISTER_DDB, ddb);\r\nreturn 0;\r\n}\r\nvoid asd_set_dmamode(struct domain_device *dev)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nstruct ata_device *ata_dev = sas_to_ata_dev(dev);\r\nint ddb = (int) (unsigned long) dev->lldd_dev;\r\nu32 qdepth = 0;\r\nif (dev->dev_type == SATA_DEV || dev->dev_type == SATA_PM_PORT) {\r\nif (ata_id_has_ncq(ata_dev->id))\r\nqdepth = ata_id_queue_depth(ata_dev->id);\r\nasd_ddbsite_write_dword(asd_ha, ddb, SATA_TAG_ALLOC_MASK,\r\n(1ULL<<qdepth)-1);\r\nasd_ddbsite_write_byte(asd_ha, ddb, NUM_SATA_TAGS, qdepth);\r\n}\r\nif (qdepth > 0)\r\nif (asd_init_sata_tag_ddb(dev) != 0) {\r\nunsigned long flags;\r\nspin_lock_irqsave(dev->sata_dev.ap->lock, flags);\r\nata_dev->flags |= ATA_DFLAG_NCQ_OFF;\r\nspin_unlock_irqrestore(dev->sata_dev.ap->lock, flags);\r\n}\r\n}\r\nstatic int asd_init_sata(struct domain_device *dev)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nint ddb = (int) (unsigned long) dev->lldd_dev;\r\nasd_ddbsite_write_word(asd_ha, ddb, ATA_CMD_SCBPTR, 0xFFFF);\r\nif (dev->dev_type == SATA_DEV || dev->dev_type == SATA_PM ||\r\ndev->dev_type == SATA_PM_PORT) {\r\nstruct dev_to_host_fis *fis = (struct dev_to_host_fis *)\r\ndev->frame_rcvd;\r\nasd_ddbsite_write_byte(asd_ha, ddb, SATA_STATUS, fis->status);\r\n}\r\nasd_ddbsite_write_word(asd_ha, ddb, NCQ_DATA_SCB_PTR, 0xFFFF);\r\nreturn 0;\r\n}\r\nstatic int asd_init_target_ddb(struct domain_device *dev)\r\n{\r\nint ddb, i;\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nu8 flags = 0;\r\nddb = asd_get_ddb(asd_ha);\r\nif (ddb < 0)\r\nreturn ddb;\r\ndev->lldd_dev = (void *) (unsigned long) ddb;\r\nasd_ddbsite_write_byte(asd_ha, ddb, 0, DDB_TP_CONN_TYPE);\r\nasd_ddbsite_write_byte(asd_ha, ddb, 1, 0);\r\nasd_ddbsite_write_word(asd_ha, ddb, INIT_CONN_TAG, 0xFFFF);\r\nfor (i = 0; i < SAS_ADDR_SIZE; i++)\r\nasd_ddbsite_write_byte(asd_ha, ddb, DEST_SAS_ADDR+i,\r\ndev->sas_addr[i]);\r\nasd_ddbsite_write_word(asd_ha, ddb, SEND_QUEUE_HEAD, 0xFFFF);\r\nasd_set_ddb_type(dev);\r\nasd_ddbsite_write_byte(asd_ha, ddb, CONN_MASK, dev->port->phy_mask);\r\nif (dev->port->oob_mode != SATA_OOB_MODE) {\r\nflags |= OPEN_REQUIRED;\r\nif ((dev->dev_type == SATA_DEV) ||\r\n(dev->tproto & SAS_PROTOCOL_STP)) {\r\nstruct smp_resp *rps_resp = &dev->sata_dev.rps_resp;\r\nif (rps_resp->frame_type == SMP_RESPONSE &&\r\nrps_resp->function == SMP_REPORT_PHY_SATA &&\r\nrps_resp->result == SMP_RESP_FUNC_ACC) {\r\nif (rps_resp->rps.affil_valid)\r\nflags |= STP_AFFIL_POL;\r\nif (rps_resp->rps.affil_supp)\r\nflags |= SUPPORTS_AFFIL;\r\n}\r\n} else {\r\nflags |= CONCURRENT_CONN_SUPP;\r\nif (!dev->parent &&\r\n(dev->dev_type == EDGE_DEV ||\r\ndev->dev_type == FANOUT_DEV))\r\nasd_ddbsite_write_byte(asd_ha, ddb, MAX_CCONN,\r\n4);\r\nelse\r\nasd_ddbsite_write_byte(asd_ha, ddb, MAX_CCONN,\r\ndev->pathways);\r\nasd_ddbsite_write_byte(asd_ha, ddb, NUM_CTX, 1);\r\n}\r\n}\r\nif (dev->dev_type == SATA_PM)\r\nflags |= SATA_MULTIPORT;\r\nasd_ddbsite_write_byte(asd_ha, ddb, DDB_TARG_FLAGS, flags);\r\nflags = 0;\r\nif (dev->tproto & SAS_PROTOCOL_STP)\r\nflags |= STP_CL_POL_NO_TX;\r\nasd_ddbsite_write_byte(asd_ha, ddb, DDB_TARG_FLAGS2, flags);\r\nasd_ddbsite_write_word(asd_ha, ddb, EXEC_QUEUE_TAIL, 0xFFFF);\r\nasd_ddbsite_write_word(asd_ha, ddb, SEND_QUEUE_TAIL, 0xFFFF);\r\nasd_ddbsite_write_word(asd_ha, ddb, SISTER_DDB, 0xFFFF);\r\nif (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {\r\ni = asd_init_sata(dev);\r\nif (i < 0) {\r\nasd_free_ddb(asd_ha, ddb);\r\nreturn i;\r\n}\r\n}\r\nif (dev->dev_type == SAS_END_DEV) {\r\nstruct sas_end_device *rdev = rphy_to_end_device(dev->rphy);\r\nif (rdev->I_T_nexus_loss_timeout > 0)\r\nasd_ddbsite_write_word(asd_ha, ddb, ITNL_TIMEOUT,\r\nmin(rdev->I_T_nexus_loss_timeout,\r\n(u16)ITNL_TIMEOUT_CONST));\r\nelse\r\nasd_ddbsite_write_word(asd_ha, ddb, ITNL_TIMEOUT,\r\n(u16)ITNL_TIMEOUT_CONST);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_init_sata_pm_table_ddb(struct domain_device *dev)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nint ddb, i;\r\nddb = asd_get_ddb(asd_ha);\r\nif (ddb < 0)\r\nreturn ddb;\r\nfor (i = 0; i < 32; i += 2)\r\nasd_ddbsite_write_word(asd_ha, ddb, i, 0xFFFF);\r\nasd_ddbsite_write_word(asd_ha, (int) (unsigned long) dev->lldd_dev,\r\nSISTER_DDB, ddb);\r\nreturn 0;\r\n}\r\nstatic int asd_init_sata_pm_port_ddb(struct domain_device *dev)\r\n{\r\nint ddb, i, parent_ddb, pmtable_ddb;\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nu8 flags;\r\nddb = asd_get_ddb(asd_ha);\r\nif (ddb < 0)\r\nreturn ddb;\r\nasd_set_ddb_type(dev);\r\nflags = (dev->sata_dev.port_no << 4) | PM_PORT_SET;\r\nasd_ddbsite_write_byte(asd_ha, ddb, PM_PORT_FLAGS, flags);\r\nasd_ddbsite_write_word(asd_ha, ddb, SISTER_DDB, 0xFFFF);\r\nasd_ddbsite_write_word(asd_ha, ddb, ATA_CMD_SCBPTR, 0xFFFF);\r\nasd_init_sata(dev);\r\nparent_ddb = (int) (unsigned long) dev->parent->lldd_dev;\r\nasd_ddbsite_write_word(asd_ha, ddb, PARENT_DDB, parent_ddb);\r\npmtable_ddb = asd_ddbsite_read_word(asd_ha, parent_ddb, SISTER_DDB);\r\nasd_ddbsite_write_word(asd_ha, pmtable_ddb, dev->sata_dev.port_no,ddb);\r\nif (asd_ddbsite_read_byte(asd_ha, ddb, NUM_SATA_TAGS) > 0) {\r\ni = asd_init_sata_tag_ddb(dev);\r\nif (i < 0) {\r\nasd_free_ddb(asd_ha, ddb);\r\nreturn i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_init_initiator_ddb(struct domain_device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int asd_init_sata_pm_ddb(struct domain_device *dev)\r\n{\r\nint res = 0;\r\nres = asd_init_target_ddb(dev);\r\nif (res)\r\ngoto out;\r\nres = asd_init_sata_pm_table_ddb(dev);\r\nif (res)\r\nasd_free_ddb(dev->port->ha->lldd_ha,\r\n(int) (unsigned long) dev->lldd_dev);\r\nout:\r\nreturn res;\r\n}\r\nint asd_dev_found(struct domain_device *dev)\r\n{\r\nunsigned long flags;\r\nint res = 0;\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nspin_lock_irqsave(&asd_ha->hw_prof.ddb_lock, flags);\r\nswitch (dev->dev_type) {\r\ncase SATA_PM:\r\nres = asd_init_sata_pm_ddb(dev);\r\nbreak;\r\ncase SATA_PM_PORT:\r\nres = asd_init_sata_pm_port_ddb(dev);\r\nbreak;\r\ndefault:\r\nif (dev->tproto)\r\nres = asd_init_target_ddb(dev);\r\nelse\r\nres = asd_init_initiator_ddb(dev);\r\n}\r\nspin_unlock_irqrestore(&asd_ha->hw_prof.ddb_lock, flags);\r\nreturn res;\r\n}\r\nvoid asd_dev_gone(struct domain_device *dev)\r\n{\r\nint ddb, sister_ddb;\r\nunsigned long flags;\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nspin_lock_irqsave(&asd_ha->hw_prof.ddb_lock, flags);\r\nddb = (int) (unsigned long) dev->lldd_dev;\r\nsister_ddb = asd_ddbsite_read_word(asd_ha, ddb, SISTER_DDB);\r\nif (sister_ddb != 0xFFFF)\r\nasd_free_ddb(asd_ha, sister_ddb);\r\nasd_free_ddb(asd_ha, ddb);\r\ndev->lldd_dev = NULL;\r\nspin_unlock_irqrestore(&asd_ha->hw_prof.ddb_lock, flags);\r\n}
