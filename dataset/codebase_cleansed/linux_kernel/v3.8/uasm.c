static inline __uasminit u32 build_rs(u32 arg)\r\n{\r\nWARN(arg & ~RS_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg & RS_MASK) << RS_SH;\r\n}\r\nstatic inline __uasminit u32 build_rt(u32 arg)\r\n{\r\nWARN(arg & ~RT_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg & RT_MASK) << RT_SH;\r\n}\r\nstatic inline __uasminit u32 build_rd(u32 arg)\r\n{\r\nWARN(arg & ~RD_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg & RD_MASK) << RD_SH;\r\n}\r\nstatic inline __uasminit u32 build_re(u32 arg)\r\n{\r\nWARN(arg & ~RE_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg & RE_MASK) << RE_SH;\r\n}\r\nstatic inline __uasminit u32 build_simm(s32 arg)\r\n{\r\nWARN(arg > 0x7fff || arg < -0x8000,\r\nKERN_WARNING "Micro-assembler field overflow\n");\r\nreturn arg & 0xffff;\r\n}\r\nstatic inline __uasminit u32 build_uimm(u32 arg)\r\n{\r\nWARN(arg & ~IMM_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn arg & IMM_MASK;\r\n}\r\nstatic inline __uasminit u32 build_bimm(s32 arg)\r\n{\r\nWARN(arg > 0x1ffff || arg < -0x20000,\r\nKERN_WARNING "Micro-assembler field overflow\n");\r\nWARN(arg & 0x3, KERN_WARNING "Invalid micro-assembler branch target\n");\r\nreturn ((arg < 0) ? (1 << 15) : 0) | ((arg >> 2) & 0x7fff);\r\n}\r\nstatic inline __uasminit u32 build_jimm(u32 arg)\r\n{\r\nWARN(arg & ~(JIMM_MASK << 2),\r\nKERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg >> 2) & JIMM_MASK;\r\n}\r\nstatic inline __uasminit u32 build_scimm(u32 arg)\r\n{\r\nWARN(arg & ~SCIMM_MASK,\r\nKERN_WARNING "Micro-assembler field overflow\n");\r\nreturn (arg & SCIMM_MASK) << SCIMM_SH;\r\n}\r\nstatic inline __uasminit u32 build_func(u32 arg)\r\n{\r\nWARN(arg & ~FUNC_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn arg & FUNC_MASK;\r\n}\r\nstatic inline __uasminit u32 build_set(u32 arg)\r\n{\r\nWARN(arg & ~SET_MASK, KERN_WARNING "Micro-assembler field overflow\n");\r\nreturn arg & SET_MASK;\r\n}\r\nstatic void __uasminit build_insn(u32 **buf, enum opcode opc, ...)\r\n{\r\nstruct insn *ip = NULL;\r\nunsigned int i;\r\nva_list ap;\r\nu32 op;\r\nfor (i = 0; insn_table[i].opcode != insn_invalid; i++)\r\nif (insn_table[i].opcode == opc) {\r\nip = &insn_table[i];\r\nbreak;\r\n}\r\nif (!ip || (opc == insn_daddiu && r4k_daddiu_bug()))\r\npanic("Unsupported Micro-assembler instruction %d", opc);\r\nop = ip->match;\r\nva_start(ap, opc);\r\nif (ip->fields & RS)\r\nop |= build_rs(va_arg(ap, u32));\r\nif (ip->fields & RT)\r\nop |= build_rt(va_arg(ap, u32));\r\nif (ip->fields & RD)\r\nop |= build_rd(va_arg(ap, u32));\r\nif (ip->fields & RE)\r\nop |= build_re(va_arg(ap, u32));\r\nif (ip->fields & SIMM)\r\nop |= build_simm(va_arg(ap, s32));\r\nif (ip->fields & UIMM)\r\nop |= build_uimm(va_arg(ap, u32));\r\nif (ip->fields & BIMM)\r\nop |= build_bimm(va_arg(ap, s32));\r\nif (ip->fields & JIMM)\r\nop |= build_jimm(va_arg(ap, u32));\r\nif (ip->fields & FUNC)\r\nop |= build_func(va_arg(ap, u32));\r\nif (ip->fields & SET)\r\nop |= build_set(va_arg(ap, u32));\r\nif (ip->fields & SCIMM)\r\nop |= build_scimm(va_arg(ap, u32));\r\nva_end(ap);\r\n**buf = op;\r\n(*buf)++;\r\n}\r\nvoid __uasminit uasm_i_pref(u32 **buf, unsigned int a, signed int b,\r\nunsigned int c)\r\n{\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) && a <= 24 && a != 5)\r\nbuild_insn(buf, insn_pref, c, 28, b);\r\nelse\r\nbuild_insn(buf, insn_pref, c, a, b);\r\n}\r\nvoid __uasminit uasm_build_label(struct uasm_label **lab, u32 *addr, int lid)\r\n{\r\n(*lab)->addr = addr;\r\n(*lab)->lab = lid;\r\n(*lab)++;\r\n}\r\nint __uasminit uasm_in_compat_space_p(long addr)\r\n{\r\n#ifdef CONFIG_64BIT\r\nreturn (((addr) & 0xffffffff00000000L) == 0xffffffff00000000L);\r\n#else\r\nreturn 1;\r\n#endif\r\n}\r\nstatic int __uasminit uasm_rel_highest(long val)\r\n{\r\n#ifdef CONFIG_64BIT\r\nreturn ((((val + 0x800080008000L) >> 48) & 0xffff) ^ 0x8000) - 0x8000;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int __uasminit uasm_rel_higher(long val)\r\n{\r\n#ifdef CONFIG_64BIT\r\nreturn ((((val + 0x80008000L) >> 32) & 0xffff) ^ 0x8000) - 0x8000;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint __uasminit uasm_rel_hi(long val)\r\n{\r\nreturn ((((val + 0x8000L) >> 16) & 0xffff) ^ 0x8000) - 0x8000;\r\n}\r\nint __uasminit uasm_rel_lo(long val)\r\n{\r\nreturn ((val & 0xffff) ^ 0x8000) - 0x8000;\r\n}\r\nvoid __uasminit UASM_i_LA_mostly(u32 **buf, unsigned int rs, long addr)\r\n{\r\nif (!uasm_in_compat_space_p(addr)) {\r\nuasm_i_lui(buf, rs, uasm_rel_highest(addr));\r\nif (uasm_rel_higher(addr))\r\nuasm_i_daddiu(buf, rs, rs, uasm_rel_higher(addr));\r\nif (uasm_rel_hi(addr)) {\r\nuasm_i_dsll(buf, rs, rs, 16);\r\nuasm_i_daddiu(buf, rs, rs, uasm_rel_hi(addr));\r\nuasm_i_dsll(buf, rs, rs, 16);\r\n} else\r\nuasm_i_dsll32(buf, rs, rs, 0);\r\n} else\r\nuasm_i_lui(buf, rs, uasm_rel_hi(addr));\r\n}\r\nvoid __uasminit UASM_i_LA(u32 **buf, unsigned int rs, long addr)\r\n{\r\nUASM_i_LA_mostly(buf, rs, addr);\r\nif (uasm_rel_lo(addr)) {\r\nif (!uasm_in_compat_space_p(addr))\r\nuasm_i_daddiu(buf, rs, rs, uasm_rel_lo(addr));\r\nelse\r\nuasm_i_addiu(buf, rs, rs, uasm_rel_lo(addr));\r\n}\r\n}\r\nvoid __uasminit\r\nuasm_r_mips_pc16(struct uasm_reloc **rel, u32 *addr, int lid)\r\n{\r\n(*rel)->addr = addr;\r\n(*rel)->type = R_MIPS_PC16;\r\n(*rel)->lab = lid;\r\n(*rel)++;\r\n}\r\nstatic inline void __uasminit\r\n__resolve_relocs(struct uasm_reloc *rel, struct uasm_label *lab)\r\n{\r\nlong laddr = (long)lab->addr;\r\nlong raddr = (long)rel->addr;\r\nswitch (rel->type) {\r\ncase R_MIPS_PC16:\r\n*rel->addr |= build_bimm(laddr - (raddr + 4));\r\nbreak;\r\ndefault:\r\npanic("Unsupported Micro-assembler relocation %d",\r\nrel->type);\r\n}\r\n}\r\nvoid __uasminit\r\nuasm_resolve_relocs(struct uasm_reloc *rel, struct uasm_label *lab)\r\n{\r\nstruct uasm_label *l;\r\nfor (; rel->lab != UASM_LABEL_INVALID; rel++)\r\nfor (l = lab; l->lab != UASM_LABEL_INVALID; l++)\r\nif (rel->lab == l->lab)\r\n__resolve_relocs(rel, l);\r\n}\r\nvoid __uasminit\r\nuasm_move_relocs(struct uasm_reloc *rel, u32 *first, u32 *end, long off)\r\n{\r\nfor (; rel->lab != UASM_LABEL_INVALID; rel++)\r\nif (rel->addr >= first && rel->addr < end)\r\nrel->addr += off;\r\n}\r\nvoid __uasminit\r\nuasm_move_labels(struct uasm_label *lab, u32 *first, u32 *end, long off)\r\n{\r\nfor (; lab->lab != UASM_LABEL_INVALID; lab++)\r\nif (lab->addr >= first && lab->addr < end)\r\nlab->addr += off;\r\n}\r\nvoid __uasminit\r\nuasm_copy_handler(struct uasm_reloc *rel, struct uasm_label *lab, u32 *first,\r\nu32 *end, u32 *target)\r\n{\r\nlong off = (long)(target - first);\r\nmemcpy(target, first, (end - first) * sizeof(u32));\r\nuasm_move_relocs(rel, first, end, off);\r\nuasm_move_labels(lab, first, end, off);\r\n}\r\nint __uasminit uasm_insn_has_bdelay(struct uasm_reloc *rel, u32 *addr)\r\n{\r\nfor (; rel->lab != UASM_LABEL_INVALID; rel++) {\r\nif (rel->addr == addr\r\n&& (rel->type == R_MIPS_PC16\r\n|| rel->type == R_MIPS_26))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid __uasminit\r\nuasm_il_bltz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bltz(p, reg, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_b(u32 **p, struct uasm_reloc **r, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_b(p, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_beqz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_beqz(p, reg, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_beqzl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_beqzl(p, reg, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_bne(u32 **p, struct uasm_reloc **r, unsigned int reg1,\r\nunsigned int reg2, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bne(p, reg1, reg2, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_bnez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bnez(p, reg, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_bgezl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bgezl(p, reg, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_bgez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bgez(p, reg, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_bbit0(u32 **p, struct uasm_reloc **r, unsigned int reg,\r\nunsigned int bit, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bbit0(p, reg, bit, 0);\r\n}\r\nvoid __uasminit\r\nuasm_il_bbit1(u32 **p, struct uasm_reloc **r, unsigned int reg,\r\nunsigned int bit, int lid)\r\n{\r\nuasm_r_mips_pc16(r, *p, lid);\r\nuasm_i_bbit1(p, reg, bit, 0);\r\n}
