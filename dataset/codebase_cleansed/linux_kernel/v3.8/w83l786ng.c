static inline u8\r\nFAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm == 0)\r\nreturn 255;\r\nrpm = SENSORS_LIMIT(rpm, 1, 1000000);\r\nreturn SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic inline u8\r\nDIV_TO_REG(long val)\r\n{\r\nint i;\r\nval = SENSORS_LIMIT(val, 1, 128) >> 1;\r\nfor (i = 0; i < 7; i++) {\r\nif (val == 0)\r\nbreak;\r\nval >>= 1;\r\n}\r\nreturn (u8)i;\r\n}\r\nstatic u8\r\nw83l786ng_read_value(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int\r\nw83l786ng_write_value(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nw83l786ng_write_value(client, W83L786NG_REG_FAN_MIN(nr),\r\ndata->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct w83l786ng_data *data = w83l786ng_update_device(dev);\r\nreturn sprintf(buf, "%u\n", DIV_FROM_REG(data->fan_div[nr]));\r\n}\r\nstatic ssize_t\r\nstore_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nunsigned long min;\r\nu8 tmp_fan_div;\r\nu8 fan_div_reg;\r\nu8 keep_mask = 0;\r\nu8 new_shift = 0;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nmin = FAN_FROM_REG(data->fan_min[nr], DIV_FROM_REG(data->fan_div[nr]));\r\ndata->fan_div[nr] = DIV_TO_REG(val);\r\nswitch (nr) {\r\ncase 0:\r\nkeep_mask = 0xf8;\r\nnew_shift = 0;\r\nbreak;\r\ncase 1:\r\nkeep_mask = 0x8f;\r\nnew_shift = 4;\r\nbreak;\r\n}\r\nfan_div_reg = w83l786ng_read_value(client, W83L786NG_REG_FAN_DIV)\r\n& keep_mask;\r\ntmp_fan_div = (data->fan_div[nr] << new_shift) & ~keep_mask;\r\nw83l786ng_write_value(client, W83L786NG_REG_FAN_DIV,\r\nfan_div_reg | tmp_fan_div);\r\ndata->fan_min[nr] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nw83l786ng_write_value(client, W83L786NG_REG_FAN_MIN(nr),\r\ndata->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83l786ng_data *data = w83l786ng_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[nr][index]));\r\n}\r\nstatic ssize_t\r\nstore_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp[nr][index] = TEMP_TO_REG(val);\r\nw83l786ng_write_value(client, W83L786NG_REG_TEMP[nr][index],\r\ndata->temp[nr][index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nu8 reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_mode[nr] = val;\r\nreg = w83l786ng_read_value(client, W83L786NG_REG_FAN_CFG);\r\nreg &= ~(1 << W83L786NG_PWM_MODE_SHIFT[nr]);\r\nif (!val)\r\nreg |= 1 << W83L786NG_PWM_MODE_SHIFT[nr];\r\nw83l786ng_write_value(client, W83L786NG_REG_FAN_CFG, reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = val;\r\nw83l786ng_write_value(client, W83L786NG_REG_PWM[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nu8 reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (!val || val > 2)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nreg = w83l786ng_read_value(client, W83L786NG_REG_FAN_CFG);\r\ndata->pwm_enable[nr] = val;\r\nreg &= ~(0x02 << W83L786NG_PWM_ENABLE_SHIFT[nr]);\r\nreg |= (val - 1) << W83L786NG_PWM_ENABLE_SHIFT[nr];\r\nw83l786ng_write_value(client, W83L786NG_REG_FAN_CFG, reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_tolerance(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct w83l786ng_data *data = w83l786ng_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", (long)data->tolerance[nr]);\r\n}\r\nstatic ssize_t\r\nstore_tolerance(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nu8 tol_tmp, tol_mask;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ntol_mask = w83l786ng_read_value(client,\r\nW83L786NG_REG_TOLERANCE) & ((nr == 1) ? 0x0f : 0xf0);\r\ntol_tmp = SENSORS_LIMIT(val, 0, 15);\r\ntol_tmp &= 0x0f;\r\ndata->tolerance[nr] = tol_tmp;\r\nif (nr == 1)\r\ntol_tmp <<= 4;\r\nw83l786ng_write_value(client, W83L786NG_REG_TOLERANCE,\r\ntol_mask | tol_tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int\r\nw83l786ng_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nu16 man_id;\r\nu8 chip_id;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nif ((w83l786ng_read_value(client, W83L786NG_REG_CONFIG) & 0x80)) {\r\ndev_dbg(&adapter->dev, "W83L786NG detection failed at 0x%02x\n",\r\nclient->addr);\r\nreturn -ENODEV;\r\n}\r\nman_id = (w83l786ng_read_value(client, W83L786NG_REG_MAN_ID1) << 8) +\r\nw83l786ng_read_value(client, W83L786NG_REG_MAN_ID2);\r\nchip_id = w83l786ng_read_value(client, W83L786NG_REG_CHIP_ID);\r\nif (man_id != 0x5CA3 ||\r\nchip_id != 0x80) {\r\ndev_dbg(&adapter->dev,\r\n"Unsupported chip (man_id=0x%04X, chip_id=0x%02X)\n",\r\nman_id, chip_id);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, "w83l786ng", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int\r\nw83l786ng_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct w83l786ng_data *data;\r\nint i, err = 0;\r\nu8 reg_tmp;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct w83l786ng_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nw83l786ng_init_client(client);\r\nfor (i = 0; i < 2; i++) {\r\ndata->fan_min[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_FAN_MIN(i));\r\n}\r\nreg_tmp = w83l786ng_read_value(client, W83L786NG_REG_FAN_DIV);\r\ndata->fan_div[0] = reg_tmp & 0x07;\r\ndata->fan_div[1] = (reg_tmp >> 4) & 0x07;\r\nerr = sysfs_create_group(&client->dev.kobj, &w83l786ng_group);\r\nif (err)\r\ngoto exit_remove;\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &w83l786ng_group);\r\nreturn err;\r\n}\r\nstatic int\r\nw83l786ng_remove(struct i2c_client *client)\r\n{\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &w83l786ng_group);\r\nreturn 0;\r\n}\r\nstatic void\r\nw83l786ng_init_client(struct i2c_client *client)\r\n{\r\nu8 tmp;\r\nif (reset)\r\nw83l786ng_write_value(client, W83L786NG_REG_CONFIG, 0x80);\r\ntmp = w83l786ng_read_value(client, W83L786NG_REG_CONFIG);\r\nif (!(tmp & 0x01))\r\nw83l786ng_write_value(client, W83L786NG_REG_CONFIG, tmp | 0x01);\r\n}\r\nstatic struct w83l786ng_data *w83l786ng_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83l786ng_data *data = i2c_get_clientdata(client);\r\nint i, j;\r\nu8 reg_tmp, pwmcfg;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\ndev_dbg(&client->dev, "Updating w83l786ng data.\n");\r\nfor (i = 0; i < 3; i++) {\r\ndata->in[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_IN(i));\r\ndata->in_min[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_IN_MIN(i));\r\ndata->in_max[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_IN_MAX(i));\r\n}\r\nfor (i = 0; i < 2; i++) {\r\ndata->fan[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_FAN(i));\r\ndata->fan_min[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_FAN_MIN(i));\r\n}\r\nreg_tmp = w83l786ng_read_value(client, W83L786NG_REG_FAN_DIV);\r\ndata->fan_div[0] = reg_tmp & 0x07;\r\ndata->fan_div[1] = (reg_tmp >> 4) & 0x07;\r\npwmcfg = w83l786ng_read_value(client, W83L786NG_REG_FAN_CFG);\r\nfor (i = 0; i < 2; i++) {\r\ndata->pwm_mode[i] =\r\n((pwmcfg >> W83L786NG_PWM_MODE_SHIFT[i]) & 1)\r\n? 0 : 1;\r\ndata->pwm_enable[i] =\r\n((pwmcfg >> W83L786NG_PWM_ENABLE_SHIFT[i]) & 2) + 1;\r\ndata->pwm[i] = w83l786ng_read_value(client,\r\nW83L786NG_REG_PWM[i]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nfor (j = 0; j < 3; j++) {\r\ndata->temp[i][j] = w83l786ng_read_value(client,\r\nW83L786NG_REG_TEMP[i][j]);\r\n}\r\n}\r\nreg_tmp = w83l786ng_read_value(client, W83L786NG_REG_TOLERANCE);\r\ndata->tolerance[0] = reg_tmp & 0x0f;\r\ndata->tolerance[1] = (reg_tmp >> 4) & 0x0f;\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
