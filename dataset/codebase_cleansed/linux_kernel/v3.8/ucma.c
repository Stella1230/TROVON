static inline struct ucma_context *_ucma_find_context(int id,\r\nstruct ucma_file *file)\r\n{\r\nstruct ucma_context *ctx;\r\nctx = idr_find(&ctx_idr, id);\r\nif (!ctx)\r\nctx = ERR_PTR(-ENOENT);\r\nelse if (ctx->file != file)\r\nctx = ERR_PTR(-EINVAL);\r\nreturn ctx;\r\n}\r\nstatic struct ucma_context *ucma_get_ctx(struct ucma_file *file, int id)\r\n{\r\nstruct ucma_context *ctx;\r\nmutex_lock(&mut);\r\nctx = _ucma_find_context(id, file);\r\nif (!IS_ERR(ctx))\r\natomic_inc(&ctx->ref);\r\nmutex_unlock(&mut);\r\nreturn ctx;\r\n}\r\nstatic void ucma_put_ctx(struct ucma_context *ctx)\r\n{\r\nif (atomic_dec_and_test(&ctx->ref))\r\ncomplete(&ctx->comp);\r\n}\r\nstatic struct ucma_context *ucma_alloc_ctx(struct ucma_file *file)\r\n{\r\nstruct ucma_context *ctx;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn NULL;\r\natomic_set(&ctx->ref, 1);\r\ninit_completion(&ctx->comp);\r\nINIT_LIST_HEAD(&ctx->mc_list);\r\nctx->file = file;\r\ndo {\r\nret = idr_pre_get(&ctx_idr, GFP_KERNEL);\r\nif (!ret)\r\ngoto error;\r\nmutex_lock(&mut);\r\nret = idr_get_new(&ctx_idr, ctx, &ctx->id);\r\nmutex_unlock(&mut);\r\n} while (ret == -EAGAIN);\r\nif (ret)\r\ngoto error;\r\nlist_add_tail(&ctx->list, &file->ctx_list);\r\nreturn ctx;\r\nerror:\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nstatic struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\r\n{\r\nstruct ucma_multicast *mc;\r\nint ret;\r\nmc = kzalloc(sizeof(*mc), GFP_KERNEL);\r\nif (!mc)\r\nreturn NULL;\r\ndo {\r\nret = idr_pre_get(&multicast_idr, GFP_KERNEL);\r\nif (!ret)\r\ngoto error;\r\nmutex_lock(&mut);\r\nret = idr_get_new(&multicast_idr, mc, &mc->id);\r\nmutex_unlock(&mut);\r\n} while (ret == -EAGAIN);\r\nif (ret)\r\ngoto error;\r\nmc->ctx = ctx;\r\nlist_add_tail(&mc->list, &ctx->mc_list);\r\nreturn mc;\r\nerror:\r\nkfree(mc);\r\nreturn NULL;\r\n}\r\nstatic void ucma_copy_conn_event(struct rdma_ucm_conn_param *dst,\r\nstruct rdma_conn_param *src)\r\n{\r\nif (src->private_data_len)\r\nmemcpy(dst->private_data, src->private_data,\r\nsrc->private_data_len);\r\ndst->private_data_len = src->private_data_len;\r\ndst->responder_resources =src->responder_resources;\r\ndst->initiator_depth = src->initiator_depth;\r\ndst->flow_control = src->flow_control;\r\ndst->retry_count = src->retry_count;\r\ndst->rnr_retry_count = src->rnr_retry_count;\r\ndst->srq = src->srq;\r\ndst->qp_num = src->qp_num;\r\n}\r\nstatic void ucma_copy_ud_event(struct rdma_ucm_ud_param *dst,\r\nstruct rdma_ud_param *src)\r\n{\r\nif (src->private_data_len)\r\nmemcpy(dst->private_data, src->private_data,\r\nsrc->private_data_len);\r\ndst->private_data_len = src->private_data_len;\r\nib_copy_ah_attr_to_user(&dst->ah_attr, &src->ah_attr);\r\ndst->qp_num = src->qp_num;\r\ndst->qkey = src->qkey;\r\n}\r\nstatic void ucma_set_event_context(struct ucma_context *ctx,\r\nstruct rdma_cm_event *event,\r\nstruct ucma_event *uevent)\r\n{\r\nuevent->ctx = ctx;\r\nswitch (event->event) {\r\ncase RDMA_CM_EVENT_MULTICAST_JOIN:\r\ncase RDMA_CM_EVENT_MULTICAST_ERROR:\r\nuevent->mc = (struct ucma_multicast *)\r\nevent->param.ud.private_data;\r\nuevent->resp.uid = uevent->mc->uid;\r\nuevent->resp.id = uevent->mc->id;\r\nbreak;\r\ndefault:\r\nuevent->resp.uid = ctx->uid;\r\nuevent->resp.id = ctx->id;\r\nbreak;\r\n}\r\n}\r\nstatic int ucma_event_handler(struct rdma_cm_id *cm_id,\r\nstruct rdma_cm_event *event)\r\n{\r\nstruct ucma_event *uevent;\r\nstruct ucma_context *ctx = cm_id->context;\r\nint ret = 0;\r\nuevent = kzalloc(sizeof(*uevent), GFP_KERNEL);\r\nif (!uevent)\r\nreturn event->event == RDMA_CM_EVENT_CONNECT_REQUEST;\r\nmutex_lock(&ctx->file->mut);\r\nuevent->cm_id = cm_id;\r\nucma_set_event_context(ctx, event, uevent);\r\nuevent->resp.event = event->event;\r\nuevent->resp.status = event->status;\r\nif (cm_id->qp_type == IB_QPT_UD)\r\nucma_copy_ud_event(&uevent->resp.param.ud, &event->param.ud);\r\nelse\r\nucma_copy_conn_event(&uevent->resp.param.conn,\r\n&event->param.conn);\r\nif (event->event == RDMA_CM_EVENT_CONNECT_REQUEST) {\r\nif (!ctx->backlog) {\r\nret = -ENOMEM;\r\nkfree(uevent);\r\ngoto out;\r\n}\r\nctx->backlog--;\r\n} else if (!ctx->uid) {\r\nkfree(uevent);\r\ngoto out;\r\n}\r\nlist_add_tail(&uevent->list, &ctx->file->event_list);\r\nwake_up_interruptible(&ctx->file->poll_wait);\r\nout:\r\nmutex_unlock(&ctx->file->mut);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_get_event(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ucma_context *ctx;\r\nstruct rdma_ucm_get_event cmd;\r\nstruct ucma_event *uevent;\r\nint ret = 0;\r\nif (out_len < sizeof uevent->resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmutex_lock(&file->mut);\r\nwhile (list_empty(&file->event_list)) {\r\nmutex_unlock(&file->mut);\r\nif (file->filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(file->poll_wait,\r\n!list_empty(&file->event_list)))\r\nreturn -ERESTARTSYS;\r\nmutex_lock(&file->mut);\r\n}\r\nuevent = list_entry(file->event_list.next, struct ucma_event, list);\r\nif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST) {\r\nctx = ucma_alloc_ctx(file);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nuevent->ctx->backlog++;\r\nctx->cm_id = uevent->cm_id;\r\nctx->cm_id->context = ctx;\r\nuevent->resp.id = ctx->id;\r\n}\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&uevent->resp, sizeof uevent->resp)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nlist_del(&uevent->list);\r\nuevent->ctx->events_reported++;\r\nif (uevent->mc)\r\nuevent->mc->events_reported++;\r\nkfree(uevent);\r\ndone:\r\nmutex_unlock(&file->mut);\r\nreturn ret;\r\n}\r\nstatic int ucma_get_qp_type(struct rdma_ucm_create_id *cmd, enum ib_qp_type *qp_type)\r\n{\r\nswitch (cmd->ps) {\r\ncase RDMA_PS_TCP:\r\n*qp_type = IB_QPT_RC;\r\nreturn 0;\r\ncase RDMA_PS_UDP:\r\ncase RDMA_PS_IPOIB:\r\n*qp_type = IB_QPT_UD;\r\nreturn 0;\r\ncase RDMA_PS_IB:\r\n*qp_type = cmd->qp_type;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic ssize_t ucma_create_id(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_create_id cmd;\r\nstruct rdma_ucm_create_id_resp resp;\r\nstruct ucma_context *ctx;\r\nenum ib_qp_type qp_type;\r\nint ret;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nret = ucma_get_qp_type(&cmd, &qp_type);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&file->mut);\r\nctx = ucma_alloc_ctx(file);\r\nmutex_unlock(&file->mut);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->uid = cmd.uid;\r\nctx->cm_id = rdma_create_id(ucma_event_handler, ctx, cmd.ps, qp_type);\r\nif (IS_ERR(ctx->cm_id)) {\r\nret = PTR_ERR(ctx->cm_id);\r\ngoto err1;\r\n}\r\nresp.id = ctx->id;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp))) {\r\nret = -EFAULT;\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nrdma_destroy_id(ctx->cm_id);\r\nerr1:\r\nmutex_lock(&mut);\r\nidr_remove(&ctx_idr, ctx->id);\r\nmutex_unlock(&mut);\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic void ucma_cleanup_multicast(struct ucma_context *ctx)\r\n{\r\nstruct ucma_multicast *mc, *tmp;\r\nmutex_lock(&mut);\r\nlist_for_each_entry_safe(mc, tmp, &ctx->mc_list, list) {\r\nlist_del(&mc->list);\r\nidr_remove(&multicast_idr, mc->id);\r\nkfree(mc);\r\n}\r\nmutex_unlock(&mut);\r\n}\r\nstatic void ucma_cleanup_mc_events(struct ucma_multicast *mc)\r\n{\r\nstruct ucma_event *uevent, *tmp;\r\nlist_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {\r\nif (uevent->mc != mc)\r\ncontinue;\r\nlist_del(&uevent->list);\r\nkfree(uevent);\r\n}\r\n}\r\nstatic int ucma_free_ctx(struct ucma_context *ctx)\r\n{\r\nint events_reported;\r\nstruct ucma_event *uevent, *tmp;\r\nLIST_HEAD(list);\r\nrdma_destroy_id(ctx->cm_id);\r\nucma_cleanup_multicast(ctx);\r\nmutex_lock(&ctx->file->mut);\r\nlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list) {\r\nif (uevent->ctx == ctx)\r\nlist_move_tail(&uevent->list, &list);\r\n}\r\nlist_del(&ctx->list);\r\nmutex_unlock(&ctx->file->mut);\r\nlist_for_each_entry_safe(uevent, tmp, &list, list) {\r\nlist_del(&uevent->list);\r\nif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST)\r\nrdma_destroy_id(uevent->cm_id);\r\nkfree(uevent);\r\n}\r\nevents_reported = ctx->events_reported;\r\nkfree(ctx);\r\nreturn events_reported;\r\n}\r\nstatic ssize_t ucma_destroy_id(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_destroy_id cmd;\r\nstruct rdma_ucm_destroy_id_resp resp;\r\nstruct ucma_context *ctx;\r\nint ret = 0;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmutex_lock(&mut);\r\nctx = _ucma_find_context(cmd.id, file);\r\nif (!IS_ERR(ctx))\r\nidr_remove(&ctx_idr, ctx->id);\r\nmutex_unlock(&mut);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nucma_put_ctx(ctx);\r\nwait_for_completion(&ctx->comp);\r\nresp.events_reported = ucma_free_ctx(ctx);\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_bind_addr(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_bind_addr cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_resolve_addr(struct ucma_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_resolve_addr cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\r\n(struct sockaddr *) &cmd.dst_addr,\r\ncmd.timeout_ms);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_resolve_route(struct ucma_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_resolve_route cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nret = rdma_resolve_route(ctx->cm_id, cmd.timeout_ms);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic void ucma_copy_ib_route(struct rdma_ucm_query_route_resp *resp,\r\nstruct rdma_route *route)\r\n{\r\nstruct rdma_dev_addr *dev_addr;\r\nresp->num_paths = route->num_paths;\r\nswitch (route->num_paths) {\r\ncase 0:\r\ndev_addr = &route->addr.dev_addr;\r\nrdma_addr_get_dgid(dev_addr,\r\n(union ib_gid *) &resp->ib_route[0].dgid);\r\nrdma_addr_get_sgid(dev_addr,\r\n(union ib_gid *) &resp->ib_route[0].sgid);\r\nresp->ib_route[0].pkey = cpu_to_be16(ib_addr_get_pkey(dev_addr));\r\nbreak;\r\ncase 2:\r\nib_copy_path_rec_to_user(&resp->ib_route[1],\r\n&route->path_rec[1]);\r\ncase 1:\r\nib_copy_path_rec_to_user(&resp->ib_route[0],\r\n&route->path_rec[0]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ucma_copy_iboe_route(struct rdma_ucm_query_route_resp *resp,\r\nstruct rdma_route *route)\r\n{\r\nstruct rdma_dev_addr *dev_addr;\r\nstruct net_device *dev;\r\nu16 vid = 0;\r\nresp->num_paths = route->num_paths;\r\nswitch (route->num_paths) {\r\ncase 0:\r\ndev_addr = &route->addr.dev_addr;\r\ndev = dev_get_by_index(&init_net, dev_addr->bound_dev_if);\r\nif (dev) {\r\nvid = rdma_vlan_dev_vlan_id(dev);\r\ndev_put(dev);\r\n}\r\niboe_mac_vlan_to_ll((union ib_gid *) &resp->ib_route[0].dgid,\r\ndev_addr->dst_dev_addr, vid);\r\niboe_addr_get_sgid(dev_addr,\r\n(union ib_gid *) &resp->ib_route[0].sgid);\r\nresp->ib_route[0].pkey = cpu_to_be16(0xffff);\r\nbreak;\r\ncase 2:\r\nib_copy_path_rec_to_user(&resp->ib_route[1],\r\n&route->path_rec[1]);\r\ncase 1:\r\nib_copy_path_rec_to_user(&resp->ib_route[0],\r\n&route->path_rec[0]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ucma_copy_iw_route(struct rdma_ucm_query_route_resp *resp,\r\nstruct rdma_route *route)\r\n{\r\nstruct rdma_dev_addr *dev_addr;\r\ndev_addr = &route->addr.dev_addr;\r\nrdma_addr_get_dgid(dev_addr, (union ib_gid *) &resp->ib_route[0].dgid);\r\nrdma_addr_get_sgid(dev_addr, (union ib_gid *) &resp->ib_route[0].sgid);\r\n}\r\nstatic ssize_t ucma_query_route(struct ucma_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_query_route cmd;\r\nstruct rdma_ucm_query_route_resp resp;\r\nstruct ucma_context *ctx;\r\nstruct sockaddr *addr;\r\nint ret = 0;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nmemset(&resp, 0, sizeof resp);\r\naddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\r\nmemcpy(&resp.src_addr, addr, addr->sa_family == AF_INET ?\r\nsizeof(struct sockaddr_in) :\r\nsizeof(struct sockaddr_in6));\r\naddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\r\nmemcpy(&resp.dst_addr, addr, addr->sa_family == AF_INET ?\r\nsizeof(struct sockaddr_in) :\r\nsizeof(struct sockaddr_in6));\r\nif (!ctx->cm_id->device)\r\ngoto out;\r\nresp.node_guid = (__force __u64) ctx->cm_id->device->node_guid;\r\nresp.port_num = ctx->cm_id->port_num;\r\nswitch (rdma_node_get_transport(ctx->cm_id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nswitch (rdma_port_get_link_layer(ctx->cm_id->device,\r\nctx->cm_id->port_num)) {\r\ncase IB_LINK_LAYER_INFINIBAND:\r\nucma_copy_ib_route(&resp, &ctx->cm_id->route);\r\nbreak;\r\ncase IB_LINK_LAYER_ETHERNET:\r\nucma_copy_iboe_route(&resp, &ctx->cm_id->route);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nucma_copy_iw_route(&resp, &ctx->cm_id->route);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nret = -EFAULT;\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic void ucma_copy_conn_param(struct rdma_conn_param *dst,\r\nstruct rdma_ucm_conn_param *src)\r\n{\r\ndst->private_data = src->private_data;\r\ndst->private_data_len = src->private_data_len;\r\ndst->responder_resources =src->responder_resources;\r\ndst->initiator_depth = src->initiator_depth;\r\ndst->flow_control = src->flow_control;\r\ndst->retry_count = src->retry_count;\r\ndst->rnr_retry_count = src->rnr_retry_count;\r\ndst->srq = src->srq;\r\ndst->qp_num = src->qp_num;\r\n}\r\nstatic ssize_t ucma_connect(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_connect cmd;\r\nstruct rdma_conn_param conn_param;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nif (!cmd.conn_param.valid)\r\nreturn -EINVAL;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nucma_copy_conn_param(&conn_param, &cmd.conn_param);\r\nret = rdma_connect(ctx->cm_id, &conn_param);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_listen(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_listen cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nctx->backlog = cmd.backlog > 0 && cmd.backlog < max_backlog ?\r\ncmd.backlog : max_backlog;\r\nret = rdma_listen(ctx->cm_id, ctx->backlog);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_accept(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_accept cmd;\r\nstruct rdma_conn_param conn_param;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nif (cmd.conn_param.valid) {\r\nucma_copy_conn_param(&conn_param, &cmd.conn_param);\r\nmutex_lock(&file->mut);\r\nret = rdma_accept(ctx->cm_id, &conn_param);\r\nif (!ret)\r\nctx->uid = cmd.uid;\r\nmutex_unlock(&file->mut);\r\n} else\r\nret = rdma_accept(ctx->cm_id, NULL);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_reject(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_reject cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nret = rdma_reject(ctx->cm_id, cmd.private_data, cmd.private_data_len);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_disconnect(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_disconnect cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nret = rdma_disconnect(ctx->cm_id);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_init_qp_attr(struct ucma_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_init_qp_attr cmd;\r\nstruct ib_uverbs_qp_attr resp;\r\nstruct ucma_context *ctx;\r\nstruct ib_qp_attr qp_attr;\r\nint ret;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nresp.qp_attr_mask = 0;\r\nmemset(&qp_attr, 0, sizeof qp_attr);\r\nqp_attr.qp_state = cmd.qp_state;\r\nret = rdma_init_qp_attr(ctx->cm_id, &qp_attr, &resp.qp_attr_mask);\r\nif (ret)\r\ngoto out;\r\nib_copy_qp_attr_to_user(&resp, &qp_attr);\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nret = -EFAULT;\r\nout:\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic int ucma_set_option_id(struct ucma_context *ctx, int optname,\r\nvoid *optval, size_t optlen)\r\n{\r\nint ret = 0;\r\nswitch (optname) {\r\ncase RDMA_OPTION_ID_TOS:\r\nif (optlen != sizeof(u8)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nrdma_set_service_type(ctx->cm_id, *((u8 *) optval));\r\nbreak;\r\ncase RDMA_OPTION_ID_REUSEADDR:\r\nif (optlen != sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = rdma_set_reuseaddr(ctx->cm_id, *((int *) optval) ? 1 : 0);\r\nbreak;\r\ncase RDMA_OPTION_ID_AFONLY:\r\nif (optlen != sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = rdma_set_afonly(ctx->cm_id, *((int *) optval) ? 1 : 0);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ucma_set_ib_path(struct ucma_context *ctx,\r\nstruct ib_path_rec_data *path_data, size_t optlen)\r\n{\r\nstruct ib_sa_path_rec sa_path;\r\nstruct rdma_cm_event event;\r\nint ret;\r\nif (optlen % sizeof(*path_data))\r\nreturn -EINVAL;\r\nfor (; optlen; optlen -= sizeof(*path_data), path_data++) {\r\nif (path_data->flags == (IB_PATH_GMP | IB_PATH_PRIMARY |\r\nIB_PATH_BIDIRECTIONAL))\r\nbreak;\r\n}\r\nif (!optlen)\r\nreturn -EINVAL;\r\nib_sa_unpack_path(path_data->path_rec, &sa_path);\r\nret = rdma_set_ib_paths(ctx->cm_id, &sa_path, 1);\r\nif (ret)\r\nreturn ret;\r\nmemset(&event, 0, sizeof event);\r\nevent.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\r\nreturn ucma_event_handler(ctx->cm_id, &event);\r\n}\r\nstatic int ucma_set_option_ib(struct ucma_context *ctx, int optname,\r\nvoid *optval, size_t optlen)\r\n{\r\nint ret;\r\nswitch (optname) {\r\ncase RDMA_OPTION_IB_PATH:\r\nret = ucma_set_ib_path(ctx, optval, optlen);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ucma_set_option_level(struct ucma_context *ctx, int level,\r\nint optname, void *optval, size_t optlen)\r\n{\r\nint ret;\r\nswitch (level) {\r\ncase RDMA_OPTION_ID:\r\nret = ucma_set_option_id(ctx, optname, optval, optlen);\r\nbreak;\r\ncase RDMA_OPTION_IB:\r\nret = ucma_set_option_ib(ctx, optname, optval, optlen);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_set_option(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_set_option cmd;\r\nstruct ucma_context *ctx;\r\nvoid *optval;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\noptval = memdup_user((void __user *) (unsigned long) cmd.optval,\r\ncmd.optlen);\r\nif (IS_ERR(optval)) {\r\nret = PTR_ERR(optval);\r\ngoto out;\r\n}\r\nret = ucma_set_option_level(ctx, cmd.level, cmd.optname, optval,\r\ncmd.optlen);\r\nkfree(optval);\r\nout:\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_notify(struct ucma_file *file, const char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_notify cmd;\r\nstruct ucma_context *ctx;\r\nint ret;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nret = rdma_notify(ctx->cm_id, (enum ib_event_type) cmd.event);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_join_multicast(struct ucma_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_join_mcast cmd;\r\nstruct rdma_ucm_create_id_resp resp;\r\nstruct ucma_context *ctx;\r\nstruct ucma_multicast *mc;\r\nint ret;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ucma_get_ctx(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nmutex_lock(&file->mut);\r\nmc = ucma_alloc_multicast(ctx);\r\nif (!mc) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nmc->uid = cmd.uid;\r\nmemcpy(&mc->addr, &cmd.addr, sizeof cmd.addr);\r\nret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr, mc);\r\nif (ret)\r\ngoto err2;\r\nresp.id = mc->id;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp))) {\r\nret = -EFAULT;\r\ngoto err3;\r\n}\r\nmutex_unlock(&file->mut);\r\nucma_put_ctx(ctx);\r\nreturn 0;\r\nerr3:\r\nrdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\r\nucma_cleanup_mc_events(mc);\r\nerr2:\r\nmutex_lock(&mut);\r\nidr_remove(&multicast_idr, mc->id);\r\nmutex_unlock(&mut);\r\nlist_del(&mc->list);\r\nkfree(mc);\r\nerr1:\r\nmutex_unlock(&file->mut);\r\nucma_put_ctx(ctx);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_leave_multicast(struct ucma_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_destroy_id cmd;\r\nstruct rdma_ucm_destroy_id_resp resp;\r\nstruct ucma_multicast *mc;\r\nint ret = 0;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmutex_lock(&mut);\r\nmc = idr_find(&multicast_idr, cmd.id);\r\nif (!mc)\r\nmc = ERR_PTR(-ENOENT);\r\nelse if (mc->ctx->file != file)\r\nmc = ERR_PTR(-EINVAL);\r\nelse {\r\nidr_remove(&multicast_idr, mc->id);\r\natomic_inc(&mc->ctx->ref);\r\n}\r\nmutex_unlock(&mut);\r\nif (IS_ERR(mc)) {\r\nret = PTR_ERR(mc);\r\ngoto out;\r\n}\r\nrdma_leave_multicast(mc->ctx->cm_id, (struct sockaddr *) &mc->addr);\r\nmutex_lock(&mc->ctx->file->mut);\r\nucma_cleanup_mc_events(mc);\r\nlist_del(&mc->list);\r\nmutex_unlock(&mc->ctx->file->mut);\r\nucma_put_ctx(mc->ctx);\r\nresp.events_reported = mc->events_reported;\r\nkfree(mc);\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nret = -EFAULT;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ucma_lock_files(struct ucma_file *file1, struct ucma_file *file2)\r\n{\r\nif (file1 < file2) {\r\nmutex_lock(&file1->mut);\r\nmutex_lock(&file2->mut);\r\n} else {\r\nmutex_lock(&file2->mut);\r\nmutex_lock(&file1->mut);\r\n}\r\n}\r\nstatic void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)\r\n{\r\nif (file1 < file2) {\r\nmutex_unlock(&file2->mut);\r\nmutex_unlock(&file1->mut);\r\n} else {\r\nmutex_unlock(&file1->mut);\r\nmutex_unlock(&file2->mut);\r\n}\r\n}\r\nstatic void ucma_move_events(struct ucma_context *ctx, struct ucma_file *file)\r\n{\r\nstruct ucma_event *uevent, *tmp;\r\nlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list)\r\nif (uevent->ctx == ctx)\r\nlist_move_tail(&uevent->list, &file->event_list);\r\n}\r\nstatic ssize_t ucma_migrate_id(struct ucma_file *new_file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct rdma_ucm_migrate_id cmd;\r\nstruct rdma_ucm_migrate_resp resp;\r\nstruct ucma_context *ctx;\r\nstruct fd f;\r\nstruct ucma_file *cur_file;\r\nint ret = 0;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nf = fdget(cmd.fd);\r\nif (!f.file)\r\nreturn -ENOENT;\r\nctx = ucma_get_ctx(f.file->private_data, cmd.id);\r\nif (IS_ERR(ctx)) {\r\nret = PTR_ERR(ctx);\r\ngoto file_put;\r\n}\r\ncur_file = ctx->file;\r\nif (cur_file == new_file) {\r\nresp.events_reported = ctx->events_reported;\r\ngoto response;\r\n}\r\nucma_lock_files(cur_file, new_file);\r\nmutex_lock(&mut);\r\nlist_move_tail(&ctx->list, &new_file->ctx_list);\r\nucma_move_events(ctx, new_file);\r\nctx->file = new_file;\r\nresp.events_reported = ctx->events_reported;\r\nmutex_unlock(&mut);\r\nucma_unlock_files(cur_file, new_file);\r\nresponse:\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nret = -EFAULT;\r\nucma_put_ctx(ctx);\r\nfile_put:\r\nfdput(f);\r\nreturn ret;\r\n}\r\nstatic ssize_t ucma_write(struct file *filp, const char __user *buf,\r\nsize_t len, loff_t *pos)\r\n{\r\nstruct ucma_file *file = filp->private_data;\r\nstruct rdma_ucm_cmd_hdr hdr;\r\nssize_t ret;\r\nif (len < sizeof(hdr))\r\nreturn -EINVAL;\r\nif (copy_from_user(&hdr, buf, sizeof(hdr)))\r\nreturn -EFAULT;\r\nif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\r\nreturn -EINVAL;\r\nif (hdr.in + sizeof(hdr) > len)\r\nreturn -EINVAL;\r\nif (!ucma_cmd_table[hdr.cmd])\r\nreturn -ENOSYS;\r\nret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\r\nif (!ret)\r\nret = len;\r\nreturn ret;\r\n}\r\nstatic unsigned int ucma_poll(struct file *filp, struct poll_table_struct *wait)\r\n{\r\nstruct ucma_file *file = filp->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(filp, &file->poll_wait, wait);\r\nif (!list_empty(&file->event_list))\r\nmask = POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int ucma_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct ucma_file *file;\r\nfile = kmalloc(sizeof *file, GFP_KERNEL);\r\nif (!file)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&file->event_list);\r\nINIT_LIST_HEAD(&file->ctx_list);\r\ninit_waitqueue_head(&file->poll_wait);\r\nmutex_init(&file->mut);\r\nfilp->private_data = file;\r\nfile->filp = filp;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int ucma_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct ucma_file *file = filp->private_data;\r\nstruct ucma_context *ctx, *tmp;\r\nmutex_lock(&file->mut);\r\nlist_for_each_entry_safe(ctx, tmp, &file->ctx_list, list) {\r\nmutex_unlock(&file->mut);\r\nmutex_lock(&mut);\r\nidr_remove(&ctx_idr, ctx->id);\r\nmutex_unlock(&mut);\r\nucma_free_ctx(ctx);\r\nmutex_lock(&file->mut);\r\n}\r\nmutex_unlock(&file->mut);\r\nkfree(file);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_abi_version(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", RDMA_USER_CM_ABI_VERSION);\r\n}\r\nstatic int __init ucma_init(void)\r\n{\r\nint ret;\r\nret = misc_register(&ucma_misc);\r\nif (ret)\r\nreturn ret;\r\nret = device_create_file(ucma_misc.this_device, &dev_attr_abi_version);\r\nif (ret) {\r\nprintk(KERN_ERR "rdma_ucm: couldn't create abi_version attr\n");\r\ngoto err1;\r\n}\r\nucma_ctl_table_hdr = register_net_sysctl(&init_net, "net/rdma_ucm", ucma_ctl_table);\r\nif (!ucma_ctl_table_hdr) {\r\nprintk(KERN_ERR "rdma_ucm: couldn't register sysctl paths\n");\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\ndevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\r\nerr1:\r\nmisc_deregister(&ucma_misc);\r\nreturn ret;\r\n}\r\nstatic void __exit ucma_cleanup(void)\r\n{\r\nunregister_net_sysctl_table(ucma_ctl_table_hdr);\r\ndevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\r\nmisc_deregister(&ucma_misc);\r\nidr_destroy(&ctx_idr);\r\n}
