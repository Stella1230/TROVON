static void collect_cpu_info_local(void *arg)\r\n{\r\nstruct cpu_info_ctx *ctx = arg;\r\nctx->err = microcode_ops->collect_cpu_info(smp_processor_id(),\r\nctx->cpu_sig);\r\n}\r\nstatic int collect_cpu_info_on_target(int cpu, struct cpu_signature *cpu_sig)\r\n{\r\nstruct cpu_info_ctx ctx = { .cpu_sig = cpu_sig, .err = 0 };\r\nint ret;\r\nret = smp_call_function_single(cpu, collect_cpu_info_local, &ctx, 1);\r\nif (!ret)\r\nret = ctx.err;\r\nreturn ret;\r\n}\r\nstatic int collect_cpu_info(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nint ret;\r\nmemset(uci, 0, sizeof(*uci));\r\nret = collect_cpu_info_on_target(cpu, &uci->cpu_sig);\r\nif (!ret)\r\nuci->valid = 1;\r\nreturn ret;\r\n}\r\nstatic void apply_microcode_local(void *arg)\r\n{\r\nstruct apply_microcode_ctx *ctx = arg;\r\nctx->err = microcode_ops->apply_microcode(smp_processor_id());\r\n}\r\nstatic int apply_microcode_on_target(int cpu)\r\n{\r\nstruct apply_microcode_ctx ctx = { .err = 0 };\r\nint ret;\r\nret = smp_call_function_single(cpu, apply_microcode_local, &ctx, 1);\r\nif (!ret)\r\nret = ctx.err;\r\nreturn ret;\r\n}\r\nstatic int do_microcode_update(const void __user *buf, size_t size)\r\n{\r\nint error = 0;\r\nint cpu;\r\nfor_each_online_cpu(cpu) {\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nenum ucode_state ustate;\r\nif (!uci->valid)\r\ncontinue;\r\nustate = microcode_ops->request_microcode_user(cpu, buf, size);\r\nif (ustate == UCODE_ERROR) {\r\nerror = -1;\r\nbreak;\r\n} else if (ustate == UCODE_OK)\r\napply_microcode_on_target(cpu);\r\n}\r\nreturn error;\r\n}\r\nstatic int microcode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn capable(CAP_SYS_RAWIO) ? nonseekable_open(inode, file) : -EPERM;\r\n}\r\nstatic ssize_t microcode_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nssize_t ret = -EINVAL;\r\nif ((len >> PAGE_SHIFT) > totalram_pages) {\r\npr_err("too much data (max %ld pages)\n", totalram_pages);\r\nreturn ret;\r\n}\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nif (do_microcode_update(buf, len) == 0)\r\nret = (ssize_t)len;\r\nif (ret > 0)\r\nperf_check_microcode();\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int __init microcode_dev_init(void)\r\n{\r\nint error;\r\nerror = misc_register(&microcode_dev);\r\nif (error) {\r\npr_err("can't misc_register on minor=%d\n", MICROCODE_MINOR);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit microcode_dev_exit(void)\r\n{\r\nmisc_deregister(&microcode_dev);\r\n}\r\nstatic int reload_for_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nenum ucode_state ustate;\r\nint err = 0;\r\nif (!uci->valid)\r\nreturn err;\r\nustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev, true);\r\nif (ustate == UCODE_OK)\r\napply_microcode_on_target(cpu);\r\nelse\r\nif (ustate == UCODE_ERROR)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic ssize_t reload_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned long val;\r\nint cpu;\r\nssize_t ret = 0, tmp_ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != 1)\r\nreturn size;\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nfor_each_online_cpu(cpu) {\r\ntmp_ret = reload_for_cpu(cpu);\r\nif (tmp_ret != 0)\r\npr_warn("Error reloading microcode on CPU %d\n", cpu);\r\nif (!ret)\r\nret = tmp_ret;\r\n}\r\nif (!ret)\r\nperf_check_microcode();\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nif (!ret)\r\nret = size;\r\nreturn ret;\r\n}\r\nstatic ssize_t version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + dev->id;\r\nreturn sprintf(buf, "0x%x\n", uci->cpu_sig.rev);\r\n}\r\nstatic ssize_t pf_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + dev->id;\r\nreturn sprintf(buf, "0x%x\n", uci->cpu_sig.pf);\r\n}\r\nstatic void microcode_fini_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nmicrocode_ops->microcode_fini_cpu(cpu);\r\nuci->valid = 0;\r\n}\r\nstatic enum ucode_state microcode_resume_cpu(int cpu)\r\n{\r\npr_debug("CPU%d updated upon resume\n", cpu);\r\nif (apply_microcode_on_target(cpu))\r\nreturn UCODE_ERROR;\r\nreturn UCODE_OK;\r\n}\r\nstatic enum ucode_state microcode_init_cpu(int cpu, bool refresh_fw)\r\n{\r\nenum ucode_state ustate;\r\nif (collect_cpu_info(cpu))\r\nreturn UCODE_ERROR;\r\nif (system_state != SYSTEM_RUNNING)\r\nreturn UCODE_NFOUND;\r\nustate = microcode_ops->request_microcode_fw(cpu, &microcode_pdev->dev,\r\nrefresh_fw);\r\nif (ustate == UCODE_OK) {\r\npr_debug("CPU%d updated upon init\n", cpu);\r\napply_microcode_on_target(cpu);\r\n}\r\nreturn ustate;\r\n}\r\nstatic enum ucode_state microcode_update_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nif (uci->valid)\r\nreturn microcode_resume_cpu(cpu);\r\nreturn microcode_init_cpu(cpu, false);\r\n}\r\nstatic int mc_device_add(struct device *dev, struct subsys_interface *sif)\r\n{\r\nint err, cpu = dev->id;\r\nif (!cpu_online(cpu))\r\nreturn 0;\r\npr_debug("CPU%d added\n", cpu);\r\nerr = sysfs_create_group(&dev->kobj, &mc_attr_group);\r\nif (err)\r\nreturn err;\r\nif (microcode_init_cpu(cpu, true) == UCODE_ERROR)\r\nreturn -EINVAL;\r\nreturn err;\r\n}\r\nstatic int mc_device_remove(struct device *dev, struct subsys_interface *sif)\r\n{\r\nint cpu = dev->id;\r\nif (!cpu_online(cpu))\r\nreturn 0;\r\npr_debug("CPU%d removed\n", cpu);\r\nmicrocode_fini_cpu(cpu);\r\nsysfs_remove_group(&dev->kobj, &mc_attr_group);\r\nreturn 0;\r\n}\r\nstatic void mc_bp_resume(void)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nif (uci->valid && uci->mc)\r\nmicrocode_ops->apply_microcode(cpu);\r\n}\r\nstatic __cpuinit int\r\nmc_cpu_callback(struct notifier_block *nb, unsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nstruct device *dev;\r\ndev = get_cpu_device(cpu);\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_ONLINE:\r\nmicrocode_update_cpu(cpu);\r\npr_debug("CPU%d added\n", cpu);\r\ncase CPU_DOWN_FAILED:\r\nif (sysfs_create_group(&dev->kobj, &mc_attr_group))\r\npr_err("Failed to create group for CPU%d\n", cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nsysfs_remove_group(&dev->kobj, &mc_attr_group);\r\npr_debug("CPU%d removed\n", cpu);\r\nbreak;\r\n}\r\nif (action == CPU_UP_CANCELED_FROZEN)\r\nmicrocode_fini_cpu(cpu);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init microcode_init(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nint error;\r\nif (c->x86_vendor == X86_VENDOR_INTEL)\r\nmicrocode_ops = init_intel_microcode();\r\nelse if (c->x86_vendor == X86_VENDOR_AMD)\r\nmicrocode_ops = init_amd_microcode();\r\nelse\r\npr_err("no support for this CPU vendor\n");\r\nif (!microcode_ops)\r\nreturn -ENODEV;\r\nmicrocode_pdev = platform_device_register_simple("microcode", -1,\r\nNULL, 0);\r\nif (IS_ERR(microcode_pdev))\r\nreturn PTR_ERR(microcode_pdev);\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nerror = subsys_interface_register(&mc_cpu_interface);\r\nif (!error)\r\nperf_check_microcode();\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nif (error)\r\ngoto out_pdev;\r\nerror = sysfs_create_group(&cpu_subsys.dev_root->kobj,\r\n&cpu_root_microcode_group);\r\nif (error) {\r\npr_err("Error creating microcode group!\n");\r\ngoto out_driver;\r\n}\r\nerror = microcode_dev_init();\r\nif (error)\r\ngoto out_ucode_group;\r\nregister_syscore_ops(&mc_syscore_ops);\r\nregister_hotcpu_notifier(&mc_cpu_notifier);\r\npr_info("Microcode Update Driver: v" MICROCODE_VERSION\r\n" <tigran@aivazian.fsnet.co.uk>, Peter Oruba\n");\r\nreturn 0;\r\nout_ucode_group:\r\nsysfs_remove_group(&cpu_subsys.dev_root->kobj,\r\n&cpu_root_microcode_group);\r\nout_driver:\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nsubsys_interface_unregister(&mc_cpu_interface);\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nout_pdev:\r\nplatform_device_unregister(microcode_pdev);\r\nreturn error;\r\n}\r\nstatic void __exit microcode_exit(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nmicrocode_dev_exit();\r\nunregister_hotcpu_notifier(&mc_cpu_notifier);\r\nunregister_syscore_ops(&mc_syscore_ops);\r\nsysfs_remove_group(&cpu_subsys.dev_root->kobj,\r\n&cpu_root_microcode_group);\r\nget_online_cpus();\r\nmutex_lock(&microcode_mutex);\r\nsubsys_interface_unregister(&mc_cpu_interface);\r\nmutex_unlock(&microcode_mutex);\r\nput_online_cpus();\r\nplatform_device_unregister(microcode_pdev);\r\nmicrocode_ops = NULL;\r\nif (c->x86_vendor == X86_VENDOR_AMD)\r\nexit_amd_microcode();\r\npr_info("Microcode Update Driver: v" MICROCODE_VERSION " removed.\n");\r\n}
