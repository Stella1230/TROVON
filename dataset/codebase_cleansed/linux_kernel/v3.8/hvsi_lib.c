static int hvsi_send_packet(struct hvsi_priv *pv, struct hvsi_header *packet)\r\n{\r\npacket->seqno = atomic_inc_return(&pv->seqno);\r\nreturn pv->put_chars(pv->termno, (char *)packet, packet->len);\r\n}\r\nstatic void hvsi_start_handshake(struct hvsi_priv *pv)\r\n{\r\nstruct hvsi_query q;\r\npv->established = 0;\r\natomic_set(&pv->seqno, 0);\r\npr_devel("HVSI@%x: Handshaking started\n", pv->termno);\r\nq.hdr.type = VS_QUERY_PACKET_HEADER;\r\nq.hdr.len = sizeof(struct hvsi_query);\r\nq.verb = VSV_SEND_VERSION_NUMBER;\r\nhvsi_send_packet(pv, &q.hdr);\r\n}\r\nstatic int hvsi_send_close(struct hvsi_priv *pv)\r\n{\r\nstruct hvsi_control ctrl;\r\npv->established = 0;\r\nctrl.hdr.type = VS_CONTROL_PACKET_HEADER;\r\nctrl.hdr.len = sizeof(struct hvsi_control);\r\nctrl.verb = VSV_CLOSE_PROTOCOL;\r\nreturn hvsi_send_packet(pv, &ctrl.hdr);\r\n}\r\nstatic void hvsi_cd_change(struct hvsi_priv *pv, int cd)\r\n{\r\nif (cd)\r\npv->mctrl |= TIOCM_CD;\r\nelse {\r\npv->mctrl &= ~TIOCM_CD;\r\nif (!pv->is_console && pv->opened) {\r\npr_devel("HVSI@%x Carrier lost, hanging up !\n",\r\npv->termno);\r\nhvsi_send_close(pv);\r\n}\r\n}\r\n}\r\nstatic void hvsi_got_control(struct hvsi_priv *pv)\r\n{\r\nstruct hvsi_control *pkt = (struct hvsi_control *)pv->inbuf;\r\nswitch (pkt->verb) {\r\ncase VSV_CLOSE_PROTOCOL:\r\nhvsi_start_handshake(pv);\r\nbreak;\r\ncase VSV_MODEM_CTL_UPDATE:\r\nhvsi_cd_change(pv, pkt->word & HVSI_TSCD);\r\nbreak;\r\n}\r\n}\r\nstatic void hvsi_got_query(struct hvsi_priv *pv)\r\n{\r\nstruct hvsi_query *pkt = (struct hvsi_query *)pv->inbuf;\r\nstruct hvsi_query_response r;\r\nif (pkt->verb != VSV_SEND_VERSION_NUMBER)\r\nreturn;\r\npr_devel("HVSI@%x: Got version query, sending response...\n",\r\npv->termno);\r\nr.hdr.type = VS_QUERY_RESPONSE_PACKET_HEADER;\r\nr.hdr.len = sizeof(struct hvsi_query_response);\r\nr.verb = VSV_SEND_VERSION_NUMBER;\r\nr.u.version = HVSI_VERSION;\r\nr.query_seqno = pkt->hdr.seqno;\r\nhvsi_send_packet(pv, &r.hdr);\r\npv->established = 1;\r\n}\r\nstatic void hvsi_got_response(struct hvsi_priv *pv)\r\n{\r\nstruct hvsi_query_response *r =\r\n(struct hvsi_query_response *)pv->inbuf;\r\nswitch(r->verb) {\r\ncase VSV_SEND_MODEM_CTL_STATUS:\r\nhvsi_cd_change(pv, r->u.mctrl_word & HVSI_TSCD);\r\npv->mctrl_update = 1;\r\nbreak;\r\n}\r\n}\r\nstatic int hvsi_check_packet(struct hvsi_priv *pv)\r\n{\r\nu8 len, type;\r\nif (pv->inbuf[0] < 0xfc) {\r\npv->inbuf_len = pv->inbuf_pktlen = 0;\r\nreturn 0;\r\n}\r\ntype = pv->inbuf[0];\r\nlen = pv->inbuf[1];\r\nif (pv->inbuf_len < len)\r\nreturn 0;\r\npr_devel("HVSI@%x: Got packet type %x len %d bytes:\n",\r\npv->termno, type, len);\r\nswitch(type) {\r\ncase VS_DATA_PACKET_HEADER:\r\npv->inbuf_pktlen = len - 4;\r\npv->inbuf_cur = 4;\r\nreturn 1;\r\ncase VS_CONTROL_PACKET_HEADER:\r\nhvsi_got_control(pv);\r\nbreak;\r\ncase VS_QUERY_PACKET_HEADER:\r\nhvsi_got_query(pv);\r\nbreak;\r\ncase VS_QUERY_RESPONSE_PACKET_HEADER:\r\nhvsi_got_response(pv);\r\nbreak;\r\n}\r\npv->inbuf_len -= len;\r\nmemmove(pv->inbuf, &pv->inbuf[len], pv->inbuf_len);\r\nreturn 1;\r\n}\r\nstatic int hvsi_get_packet(struct hvsi_priv *pv)\r\n{\r\nif (pv->inbuf_len < HVSI_INBUF_SIZE)\r\npv->inbuf_len += pv->get_chars(pv->termno,\r\n&pv->inbuf[pv->inbuf_len],\r\nHVSI_INBUF_SIZE - pv->inbuf_len);\r\nif (pv->inbuf_len >= 4)\r\nreturn hvsi_check_packet(pv);\r\nreturn 0;\r\n}\r\nint hvsilib_get_chars(struct hvsi_priv *pv, char *buf, int count)\r\n{\r\nunsigned int tries, read = 0;\r\nif (WARN_ON(!pv))\r\nreturn -ENXIO;\r\nif (!pv->opened)\r\nreturn 0;\r\nfor (tries = 1; count && tries < 2; tries++) {\r\nif (pv->inbuf_pktlen) {\r\nunsigned int l = min(count, (int)pv->inbuf_pktlen);\r\nmemcpy(&buf[read], &pv->inbuf[pv->inbuf_cur], l);\r\npv->inbuf_cur += l;\r\npv->inbuf_pktlen -= l;\r\ncount -= l;\r\nread += l;\r\n}\r\nif (count == 0)\r\nbreak;\r\nif (pv->inbuf_cur) {\r\npv->inbuf_len -= pv->inbuf_cur;\r\nmemmove(pv->inbuf, &pv->inbuf[pv->inbuf_cur],\r\npv->inbuf_len);\r\npv->inbuf_cur = 0;\r\n}\r\nif (hvsi_get_packet(pv))\r\ntries--;\r\n}\r\nif (!pv->established) {\r\npr_devel("HVSI@%x: returning -EPIPE\n", pv->termno);\r\nreturn -EPIPE;\r\n}\r\nreturn read;\r\n}\r\nint hvsilib_put_chars(struct hvsi_priv *pv, const char *buf, int count)\r\n{\r\nstruct hvsi_data dp;\r\nint rc, adjcount = min(count, HVSI_MAX_OUTGOING_DATA);\r\nif (WARN_ON(!pv))\r\nreturn -ENODEV;\r\ndp.hdr.type = VS_DATA_PACKET_HEADER;\r\ndp.hdr.len = adjcount + sizeof(struct hvsi_header);\r\nmemcpy(dp.data, buf, adjcount);\r\nrc = hvsi_send_packet(pv, &dp.hdr);\r\nif (rc <= 0)\r\nreturn rc;\r\nreturn adjcount;\r\n}\r\nstatic void maybe_msleep(unsigned long ms)\r\n{\r\nif (irqs_disabled())\r\nmdelay(ms);\r\nelse\r\nmsleep(ms);\r\n}\r\nint hvsilib_read_mctrl(struct hvsi_priv *pv)\r\n{\r\nstruct hvsi_query q;\r\nint rc, timeout;\r\npr_devel("HVSI@%x: Querying modem control status...\n",\r\npv->termno);\r\npv->mctrl_update = 0;\r\nq.hdr.type = VS_QUERY_PACKET_HEADER;\r\nq.hdr.len = sizeof(struct hvsi_query);\r\nq.hdr.seqno = atomic_inc_return(&pv->seqno);\r\nq.verb = VSV_SEND_MODEM_CTL_STATUS;\r\nrc = hvsi_send_packet(pv, &q.hdr);\r\nif (rc <= 0) {\r\npr_devel("HVSI@%x: Error %d...\n", pv->termno, rc);\r\nreturn rc;\r\n}\r\nfor (timeout = 0; timeout < 20; timeout++) {\r\nif (!pv->established)\r\nreturn -ENXIO;\r\nif (pv->mctrl_update)\r\nreturn 0;\r\nif (!hvsi_get_packet(pv))\r\nmaybe_msleep(10);\r\n}\r\nreturn -EIO;\r\n}\r\nint hvsilib_write_mctrl(struct hvsi_priv *pv, int dtr)\r\n{\r\nstruct hvsi_control ctrl;\r\nunsigned short mctrl;\r\nmctrl = pv->mctrl;\r\nif (dtr)\r\nmctrl |= TIOCM_DTR;\r\nelse\r\nmctrl &= ~TIOCM_DTR;\r\nif (mctrl == pv->mctrl)\r\nreturn 0;\r\npv->mctrl = mctrl;\r\npr_devel("HVSI@%x: %s DTR...\n", pv->termno,\r\ndtr ? "Setting" : "Clearing");\r\nctrl.hdr.type = VS_CONTROL_PACKET_HEADER,\r\nctrl.hdr.len = sizeof(struct hvsi_control);\r\nctrl.verb = VSV_SET_MODEM_CTL;\r\nctrl.mask = HVSI_TSDTR;\r\nctrl.word = dtr ? HVSI_TSDTR : 0;\r\nreturn hvsi_send_packet(pv, &ctrl.hdr);\r\n}\r\nvoid hvsilib_establish(struct hvsi_priv *pv)\r\n{\r\nint timeout;\r\npr_devel("HVSI@%x: Establishing...\n", pv->termno);\r\nfor (timeout = 0; timeout < 20; timeout++) {\r\nif (pv->established)\r\ngoto established;\r\nif (!hvsi_get_packet(pv))\r\nmaybe_msleep(10);\r\n}\r\npr_devel("HVSI@%x: ... sending close\n", pv->termno);\r\nhvsi_send_close(pv);\r\npr_devel("HVSI@%x: ... restarting handshake\n", pv->termno);\r\nhvsi_start_handshake(pv);\r\npr_devel("HVSI@%x: ... waiting handshake\n", pv->termno);\r\nfor (timeout = 0; timeout < 20; timeout++) {\r\nif (pv->established)\r\ngoto established;\r\nif (!hvsi_get_packet(pv))\r\nmaybe_msleep(10);\r\n}\r\nif (!pv->established) {\r\npr_devel("HVSI@%x: Timeout handshaking, giving up !\n",\r\npv->termno);\r\nreturn;\r\n}\r\nestablished:\r\npr_devel("HVSI@%x: ... established, reading mctrl\n", pv->termno);\r\nhvsilib_read_mctrl(pv);\r\npr_devel("HVSI@%x: ... setting mctrl\n", pv->termno);\r\nhvsilib_write_mctrl(pv, 1);\r\nwmb();\r\npv->opened = 1;\r\n}\r\nint hvsilib_open(struct hvsi_priv *pv, struct hvc_struct *hp)\r\n{\r\npr_devel("HVSI@%x: open !\n", pv->termno);\r\npv->tty = tty_port_tty_get(&hp->port);\r\nhvsilib_establish(pv);\r\nreturn 0;\r\n}\r\nvoid hvsilib_close(struct hvsi_priv *pv, struct hvc_struct *hp)\r\n{\r\nunsigned long flags;\r\npr_devel("HVSI@%x: close !\n", pv->termno);\r\nif (!pv->is_console) {\r\npr_devel("HVSI@%x: Not a console, tearing down\n",\r\npv->termno);\r\nspin_lock_irqsave(&hp->lock, flags);\r\npv->opened = 0;\r\nspin_unlock_irqrestore(&hp->lock, flags);\r\nif (!pv->tty || (pv->tty->termios.c_cflag & HUPCL))\r\nhvsilib_write_mctrl(pv, 0);\r\nhvsi_send_close(pv);\r\n}\r\nif (pv->tty)\r\ntty_kref_put(pv->tty);\r\npv->tty = NULL;\r\n}\r\nvoid hvsilib_init(struct hvsi_priv *pv,\r\nint (*get_chars)(uint32_t termno, char *buf, int count),\r\nint (*put_chars)(uint32_t termno, const char *buf,\r\nint count),\r\nint termno, int is_console)\r\n{\r\nmemset(pv, 0, sizeof(*pv));\r\npv->get_chars = get_chars;\r\npv->put_chars = put_chars;\r\npv->termno = termno;\r\npv->is_console = is_console;\r\n}
