ax25_uid_assoc *ax25_findbyuid(kuid_t uid)\r\n{\r\nax25_uid_assoc *ax25_uid, *res = NULL;\r\nstruct hlist_node *node;\r\nread_lock(&ax25_uid_lock);\r\nax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {\r\nif (uid_eq(ax25_uid->uid, uid)) {\r\nax25_uid_hold(ax25_uid);\r\nres = ax25_uid;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&ax25_uid_lock);\r\nreturn res;\r\n}\r\nint ax25_uid_ioctl(int cmd, struct sockaddr_ax25 *sax)\r\n{\r\nax25_uid_assoc *ax25_uid;\r\nstruct hlist_node *node;\r\nax25_uid_assoc *user;\r\nunsigned long res;\r\nswitch (cmd) {\r\ncase SIOCAX25GETUID:\r\nres = -ENOENT;\r\nread_lock(&ax25_uid_lock);\r\nax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {\r\nif (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0) {\r\nres = from_kuid_munged(current_user_ns(), ax25_uid->uid);\r\nbreak;\r\n}\r\n}\r\nread_unlock(&ax25_uid_lock);\r\nreturn res;\r\ncase SIOCAX25ADDUID:\r\n{\r\nkuid_t sax25_kuid;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nsax25_kuid = make_kuid(current_user_ns(), sax->sax25_uid);\r\nif (!uid_valid(sax25_kuid))\r\nreturn -EINVAL;\r\nuser = ax25_findbyuid(sax25_kuid);\r\nif (user) {\r\nax25_uid_put(user);\r\nreturn -EEXIST;\r\n}\r\nif (sax->sax25_uid == 0)\r\nreturn -EINVAL;\r\nif ((ax25_uid = kmalloc(sizeof(*ax25_uid), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\natomic_set(&ax25_uid->refcount, 1);\r\nax25_uid->uid = sax25_kuid;\r\nax25_uid->call = sax->sax25_call;\r\nwrite_lock(&ax25_uid_lock);\r\nhlist_add_head(&ax25_uid->uid_node, &ax25_uid_list);\r\nwrite_unlock(&ax25_uid_lock);\r\nreturn 0;\r\n}\r\ncase SIOCAX25DELUID:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nax25_uid = NULL;\r\nwrite_lock(&ax25_uid_lock);\r\nax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {\r\nif (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0)\r\nbreak;\r\n}\r\nif (ax25_uid == NULL) {\r\nwrite_unlock(&ax25_uid_lock);\r\nreturn -ENOENT;\r\n}\r\nhlist_del_init(&ax25_uid->uid_node);\r\nax25_uid_put(ax25_uid);\r\nwrite_unlock(&ax25_uid_lock);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void *ax25_uid_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(ax25_uid_lock)\r\n{\r\nread_lock(&ax25_uid_lock);\r\nreturn seq_hlist_start_head(&ax25_uid_list, *pos);\r\n}\r\nstatic void *ax25_uid_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_hlist_next(v, &ax25_uid_list, pos);\r\n}\r\nstatic void ax25_uid_seq_stop(struct seq_file *seq, void *v)\r\n__releases(ax25_uid_lock)\r\n{\r\nread_unlock(&ax25_uid_lock);\r\n}\r\nstatic int ax25_uid_seq_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11];\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "Policy: %d\n", ax25_uid_policy);\r\nelse {\r\nstruct ax25_uid_assoc *pt;\r\npt = hlist_entry(v, struct ax25_uid_assoc, uid_node);\r\nseq_printf(seq, "%6d %s\n",\r\nfrom_kuid_munged(seq_user_ns(seq), pt->uid),\r\nax2asc(buf, &pt->call));\r\n}\r\nreturn 0;\r\n}\r\nstatic int ax25_uid_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ax25_uid_seqops);\r\n}\r\nvoid __exit ax25_uid_free(void)\r\n{\r\nax25_uid_assoc *ax25_uid;\r\nstruct hlist_node *node;\r\nwrite_lock(&ax25_uid_lock);\r\nagain:\r\nax25_uid_for_each(ax25_uid, node, &ax25_uid_list) {\r\nhlist_del_init(&ax25_uid->uid_node);\r\nax25_uid_put(ax25_uid);\r\ngoto again;\r\n}\r\nwrite_unlock(&ax25_uid_lock);\r\n}
