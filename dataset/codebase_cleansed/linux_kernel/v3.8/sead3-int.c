asmlinkage void plat_irq_dispatch(void)\r\n{\r\nunsigned int pending = read_c0_cause() & read_c0_status() & ST0_IM;\r\nint irq;\r\nirq = (fls(pending) - CAUSEB_IP - 1);\r\nif (irq >= 0)\r\ndo_IRQ(MIPS_CPU_IRQ_BASE + irq);\r\nelse\r\nspurious_interrupt();\r\n}\r\nvoid __init arch_init_irq(void)\r\n{\r\nint i;\r\nif (!cpu_has_veic) {\r\nmips_cpu_irq_init();\r\nif (cpu_has_vint) {\r\nfor (i = 0; i < 8; i++)\r\nset_vi_handler(i, plat_irq_dispatch);\r\n}\r\n}\r\nsead3_config_reg = (unsigned long)ioremap_nocache(SEAD_CONFIG_BASE,\r\nSEAD_CONFIG_SIZE);\r\ngic_present = (REG32(sead3_config_reg) & SEAD_CONFIG_GIC_PRESENT_MSK) >>\r\nSEAD_CONFIG_GIC_PRESENT_SHF;\r\npr_info("GIC: %spresent\n", (gic_present) ? "" : "not ");\r\npr_info("EIC: %s\n",\r\n(current_cpu_data.options & MIPS_CPU_VEIC) ? "on" : "off");\r\nif (gic_present)\r\ngic_init(GIC_BASE_ADDR, GIC_ADDRSPACE_SZ, gic_intr_map,\r\nARRAY_SIZE(gic_intr_map), MIPS_GIC_IRQ_BASE);\r\n}\r\nvoid gic_enable_interrupt(int irq_vec)\r\n{\r\nunsigned int i, irq_source;\r\nfor (i = 0; i < gic_shared_intr_map[irq_vec].num_shared_intr; i++) {\r\nirq_source = gic_shared_intr_map[irq_vec].intr_list[i];\r\nGIC_SET_INTR_MASK(irq_source);\r\n}\r\nif (gic_shared_intr_map[irq_vec].local_intr_mask) {\r\nGICWRITE(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), 0);\r\nGICWRITE(GIC_REG(VPE_OTHER, GIC_VPE_SMASK),\r\ngic_shared_intr_map[irq_vec].local_intr_mask);\r\n}\r\n}\r\nvoid gic_disable_interrupt(int irq_vec)\r\n{\r\nunsigned int i, irq_source;\r\nfor (i = 0; i < gic_shared_intr_map[irq_vec].num_shared_intr; i++) {\r\nirq_source = gic_shared_intr_map[irq_vec].intr_list[i];\r\nGIC_CLR_INTR_MASK(irq_source);\r\n}\r\nif (gic_shared_intr_map[irq_vec].local_intr_mask) {\r\nGICWRITE(GIC_REG(VPE_LOCAL, GIC_VPE_OTHER_ADDR), 0);\r\nGICWRITE(GIC_REG(VPE_OTHER, GIC_VPE_RMASK),\r\ngic_shared_intr_map[irq_vec].local_intr_mask);\r\n}\r\n}\r\nvoid gic_irq_ack(struct irq_data *d)\r\n{\r\nGIC_CLR_INTR_MASK(d->irq - gic_irq_base);\r\n}\r\nvoid gic_finish_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = (d->irq - gic_irq_base);\r\nunsigned int i, irq_source;\r\nfor (i = 0; i < gic_shared_intr_map[irq].num_shared_intr; i++) {\r\nirq_source = gic_shared_intr_map[irq].intr_list[i];\r\nif (gic_irq_flags[irq_source] & GIC_TRIG_EDGE)\r\nGICWRITE(GIC_REG(SHARED, GIC_SH_WEDGE), irq_source);\r\n}\r\nGIC_SET_INTR_MASK(irq);\r\n}\r\nvoid __init gic_platform_init(int irqs, struct irq_chip *irq_controller)\r\n{\r\nint i;\r\nif (!cpu_has_veic)\r\nreturn;\r\nfor (i = gic_irq_base; i < (gic_irq_base + irqs); i++)\r\nirq_set_chip_and_handler(i, irq_controller, handle_percpu_irq);\r\n}
