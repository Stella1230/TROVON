static inline int ADC_TO_MV(int adc, int range)\r\n{\r\nreturn (adc * range) / 1024;\r\n}\r\nstatic inline int LIMIT_TO_MV(int limit, int range)\r\n{\r\nreturn limit * range / 256;\r\n}\r\nstatic inline int MV_TO_LIMIT(int mv, int range)\r\n{\r\nreturn SENSORS_LIMIT(DIV_ROUND_CLOSEST(mv * 256, range), 0, 255);\r\n}\r\nstatic inline int ADC_TO_CURR(int adc, int gain)\r\n{\r\nreturn adc * 1400000 / (gain * 255);\r\n}\r\nstatic int max16065_read_adc(struct i2c_client *client, int reg)\r\n{\r\nint rv;\r\nrv = i2c_smbus_read_word_swapped(client, reg);\r\nif (unlikely(rv < 0))\r\nreturn rv;\r\nreturn rv >> 6;\r\n}\r\nstatic struct max16065_data *max16065_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max16065_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nint i;\r\nfor (i = 0; i < data->num_adc; i++)\r\ndata->adc[i]\r\n= max16065_read_adc(client, MAX16065_ADC(i));\r\nif (data->have_current) {\r\ndata->adc[MAX16065_NUM_ADC]\r\n= max16065_read_adc(client, MAX16065_CSP_ADC);\r\ndata->curr_sense\r\n= i2c_smbus_read_byte_data(client,\r\nMAX16065_CURR_SENSE);\r\n}\r\nfor (i = 0; i < DIV_ROUND_UP(data->num_adc, 8); i++)\r\ndata->fault[i]\r\n= i2c_smbus_read_byte_data(client, MAX16065_FAULT(i));\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t max16065_show_alarm(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(da);\r\nstruct max16065_data *data = max16065_update_device(dev);\r\nint val = data->fault[attr2->nr];\r\nif (val < 0)\r\nreturn val;\r\nval &= (1 << attr2->index);\r\nif (val)\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nMAX16065_FAULT(attr2->nr), val);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!val);\r\n}\r\nstatic ssize_t max16065_show_input(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct max16065_data *data = max16065_update_device(dev);\r\nint adc = data->adc[attr->index];\r\nif (unlikely(adc < 0))\r\nreturn adc;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nADC_TO_MV(adc, data->range[attr->index]));\r\n}\r\nstatic ssize_t max16065_show_current(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct max16065_data *data = max16065_update_device(dev);\r\nif (unlikely(data->curr_sense < 0))\r\nreturn data->curr_sense;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nADC_TO_CURR(data->curr_sense, data->curr_gain));\r\n}\r\nstatic ssize_t max16065_set_limit(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max16065_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nint limit;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nlimit = MV_TO_LIMIT(val, data->range[attr2->index]);\r\nmutex_lock(&data->update_lock);\r\ndata->limit[attr2->nr][attr2->index]\r\n= LIMIT_TO_MV(limit, data->range[attr2->index]);\r\ni2c_smbus_write_byte_data(client,\r\nMAX16065_LIMIT(attr2->nr, attr2->index),\r\nlimit);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t max16065_show_limit(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max16065_data *data = i2c_get_clientdata(client);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ndata->limit[attr2->nr][attr2->index]);\r\n}\r\nstatic void max16065_cleanup(struct i2c_client *client)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &max16065_max_group);\r\nsysfs_remove_group(&client->dev.kobj, &max16065_min_group);\r\nsysfs_remove_group(&client->dev.kobj, &max16065_current_group);\r\nsysfs_remove_group(&client->dev.kobj, &max16065_basic_group);\r\n}\r\nstatic int max16065_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct max16065_data *data;\r\nint i, j, val, ret;\r\nbool have_secondary;\r\nbool secondary_is_max = false;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->num_adc = max16065_num_adc[id->driver_data];\r\ndata->have_current = max16065_have_current[id->driver_data];\r\nhave_secondary = max16065_have_secondary[id->driver_data];\r\nif (have_secondary) {\r\nval = i2c_smbus_read_byte_data(client, MAX16065_SW_ENABLE);\r\nif (unlikely(val < 0))\r\nreturn val;\r\nsecondary_is_max = val & MAX16065_WARNING_OV;\r\n}\r\nfor (i = 0; i < DIV_ROUND_UP(data->num_adc, 4); i++) {\r\nval = i2c_smbus_read_byte_data(client, MAX16065_SCALE(i));\r\nif (unlikely(val < 0))\r\nreturn val;\r\nfor (j = 0; j < 4 && i * 4 + j < data->num_adc; j++) {\r\ndata->range[i * 4 + j] =\r\nmax16065_adc_range[(val >> (j * 2)) & 0x3];\r\n}\r\n}\r\nfor (i = 0; i < MAX16065_NUM_LIMIT; i++) {\r\nif (i == 0 && !have_secondary)\r\ncontinue;\r\nfor (j = 0; j < data->num_adc; j++) {\r\nval = i2c_smbus_read_byte_data(client,\r\nMAX16065_LIMIT(i, j));\r\nif (unlikely(val < 0))\r\nreturn val;\r\ndata->limit[i][j] = LIMIT_TO_MV(val, data->range[j]);\r\n}\r\n}\r\nfor (i = 0; i < data->num_adc * 4; i++) {\r\nif (!data->range[i / 4])\r\ncontinue;\r\nret = sysfs_create_file(&client->dev.kobj,\r\nmax16065_basic_attributes[i]);\r\nif (unlikely(ret))\r\ngoto out;\r\n}\r\nif (have_secondary) {\r\nstruct attribute **attr = secondary_is_max ?\r\nmax16065_max_attributes : max16065_min_attributes;\r\nfor (i = 0; i < data->num_adc; i++) {\r\nif (!data->range[i])\r\ncontinue;\r\nret = sysfs_create_file(&client->dev.kobj, attr[i]);\r\nif (unlikely(ret))\r\ngoto out;\r\n}\r\n}\r\nif (data->have_current) {\r\nval = i2c_smbus_read_byte_data(client, MAX16065_CURR_CONTROL);\r\nif (unlikely(val < 0)) {\r\nret = val;\r\ngoto out;\r\n}\r\nif (val & MAX16065_CURR_ENABLE) {\r\ndata->curr_gain = 6 << ((val >> 2) & 0x03);\r\ndata->range[MAX16065_NUM_ADC]\r\n= max16065_csp_adc_range[(val >> 1) & 0x01];\r\nret = sysfs_create_group(&client->dev.kobj,\r\n&max16065_current_group);\r\nif (unlikely(ret))\r\ngoto out;\r\n} else {\r\ndata->have_current = false;\r\n}\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (unlikely(IS_ERR(data->hwmon_dev))) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nmax16065_cleanup(client);\r\nreturn ret;\r\n}\r\nstatic int max16065_remove(struct i2c_client *client)\r\n{\r\nstruct max16065_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nmax16065_cleanup(client);\r\nreturn 0;\r\n}
