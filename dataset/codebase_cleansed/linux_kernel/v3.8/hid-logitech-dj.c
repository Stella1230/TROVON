static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct dj_device *dj_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\ndj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\r\ndjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nif (dj_dev != NULL) {\r\nhid_destroy_device(dj_dev->hdev);\r\nkfree(dj_dev);\r\n} else {\r\ndev_err(&djrcv_dev->hdev->dev, "%s: can't destroy a NULL device\n",\r\n__func__);\r\n}\r\n}\r\nstatic void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\r\nstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nstruct hid_device *dj_hiddev;\r\nstruct dj_device *dj_dev;\r\nunsigned char tmpstr[3];\r\nif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\r\nSPFUNCTION_DEVICE_LIST_EMPTY) {\r\ndbg_hid("%s: device list is empty\n", __func__);\r\ndjrcv_dev->querying_devices = false;\r\nreturn;\r\n}\r\nif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\r\n(dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\r\ndev_err(&djrcv_hdev->dev, "%s: invalid device index:%d\n",\r\n__func__, dj_report->device_index);\r\nreturn;\r\n}\r\nif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\r\ndbg_hid("%s: device is already known\n", __func__);\r\nreturn;\r\n}\r\ndj_hiddev = hid_allocate_device();\r\nif (IS_ERR(dj_hiddev)) {\r\ndev_err(&djrcv_hdev->dev, "%s: hid_allocate_device failed\n",\r\n__func__);\r\nreturn;\r\n}\r\ndj_hiddev->ll_driver = &logi_dj_ll_driver;\r\ndj_hiddev->hid_output_raw_report = logi_dj_output_hidraw_report;\r\ndj_hiddev->dev.parent = &djrcv_hdev->dev;\r\ndj_hiddev->bus = BUS_USB;\r\ndj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\r\ndj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\r\nsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\r\n"Logitech Unifying Device. Wireless PID:%02x%02x",\r\ndj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\r\ndj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\r\nusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\r\nsnprintf(tmpstr, sizeof(tmpstr), ":%d", dj_report->device_index);\r\nstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\r\ndj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\r\nif (!dj_dev) {\r\ndev_err(&djrcv_hdev->dev, "%s: failed allocating dj_device\n",\r\n__func__);\r\ngoto dj_device_allocate_fail;\r\n}\r\ndj_dev->reports_supported = get_unaligned_le32(\r\ndj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\r\ndj_dev->hdev = dj_hiddev;\r\ndj_dev->dj_receiver_dev = djrcv_dev;\r\ndj_dev->device_index = dj_report->device_index;\r\ndj_hiddev->driver_data = dj_dev;\r\ndjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\r\nif (hid_add_device(dj_hiddev)) {\r\ndev_err(&djrcv_hdev->dev, "%s: failed adding dj_device\n",\r\n__func__);\r\ngoto hid_add_device_fail;\r\n}\r\nreturn;\r\nhid_add_device_fail:\r\ndjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\r\nkfree(dj_dev);\r\ndj_device_allocate_fail:\r\nhid_destroy_device(dj_hiddev);\r\n}\r\nstatic void delayedwork_callback(struct work_struct *work)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev =\r\ncontainer_of(work, struct dj_receiver_dev, work);\r\nstruct dj_report dj_report;\r\nunsigned long flags;\r\nint count;\r\nint retval;\r\ndbg_hid("%s\n", __func__);\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\ncount = kfifo_out(&djrcv_dev->notif_fifo, &dj_report,\r\nsizeof(struct dj_report));\r\nif (count != sizeof(struct dj_report)) {\r\ndev_err(&djrcv_dev->hdev->dev, "%s: workitem triggered without "\r\n"notifications available\n", __func__);\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nreturn;\r\n}\r\nif (!kfifo_is_empty(&djrcv_dev->notif_fifo)) {\r\nif (schedule_work(&djrcv_dev->work) == 0) {\r\ndbg_hid("%s: did not schedule the work item, was "\r\n"already queued\n", __func__);\r\n}\r\n}\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nswitch (dj_report.report_type) {\r\ncase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\r\nlogi_dj_recv_add_djhid_device(djrcv_dev, &dj_report);\r\nbreak;\r\ncase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\r\nlogi_dj_recv_destroy_djhid_device(djrcv_dev, &dj_report);\r\nbreak;\r\ndefault:\r\nif (!djrcv_dev->paired_dj_devices[dj_report.device_index]) {\r\nretval = logi_dj_recv_query_paired_devices(djrcv_dev);\r\nif (!retval) {\r\nbreak;\r\n}\r\ndev_err(&djrcv_dev->hdev->dev,\r\n"%s:logi_dj_recv_query_paired_devices "\r\n"error:%d\n", __func__, retval);\r\n}\r\ndbg_hid("%s: unexpected report type\n", __func__);\r\n}\r\n}\r\nstatic void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\r\nif (schedule_work(&djrcv_dev->work) == 0) {\r\ndbg_hid("%s: did not schedule the work item, was already "\r\n"queued\n", __func__);\r\n}\r\n}\r\nstatic void logi_dj_recv_forward_null_report(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nunsigned int i;\r\nu8 reportbuffer[MAX_REPORT_SIZE];\r\nstruct dj_device *djdev;\r\ndjdev = djrcv_dev->paired_dj_devices[dj_report->device_index];\r\nif (!djdev) {\r\ndbg_hid("djrcv_dev->paired_dj_devices[dj_report->device_index]"\r\n" is NULL, index %d\n", dj_report->device_index);\r\nkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\r\nif (schedule_work(&djrcv_dev->work) == 0) {\r\ndbg_hid("%s: did not schedule the work item, was already "\r\n"queued\n", __func__);\r\n}\r\nreturn;\r\n}\r\nmemset(reportbuffer, 0, sizeof(reportbuffer));\r\nfor (i = 0; i < NUMBER_OF_HID_REPORTS; i++) {\r\nif (djdev->reports_supported & (1 << i)) {\r\nreportbuffer[0] = i;\r\nif (hid_input_report(djdev->hdev,\r\nHID_INPUT_REPORT,\r\nreportbuffer,\r\nhid_reportid_size_map[i], 1)) {\r\ndbg_hid("hid_input_report error sending null "\r\n"report\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic void logi_dj_recv_forward_report(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct dj_device *dj_device;\r\ndj_device = djrcv_dev->paired_dj_devices[dj_report->device_index];\r\nif (dj_device == NULL) {\r\ndbg_hid("djrcv_dev->paired_dj_devices[dj_report->device_index]"\r\n" is NULL, index %d\n", dj_report->device_index);\r\nkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\r\nif (schedule_work(&djrcv_dev->work) == 0) {\r\ndbg_hid("%s: did not schedule the work item, was already "\r\n"queued\n", __func__);\r\n}\r\nreturn;\r\n}\r\nif ((dj_report->report_type > ARRAY_SIZE(hid_reportid_size_map) - 1) ||\r\n(hid_reportid_size_map[dj_report->report_type] == 0)) {\r\ndbg_hid("invalid report type:%x\n", dj_report->report_type);\r\nreturn;\r\n}\r\nif (hid_input_report(dj_device->hdev,\r\nHID_INPUT_REPORT, &dj_report->report_type,\r\nhid_reportid_size_map[dj_report->report_type], 1)) {\r\ndbg_hid("hid_input_report error\n");\r\n}\r\n}\r\nstatic int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct hid_device *hdev = djrcv_dev->hdev;\r\nint sent_bytes;\r\nif (!hdev->hid_output_raw_report) {\r\ndev_err(&hdev->dev, "%s:"\r\n"hid_output_raw_report is null\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nsent_bytes = hdev->hid_output_raw_report(hdev, (u8 *) dj_report,\r\nsizeof(struct dj_report),\r\nHID_OUTPUT_REPORT);\r\nreturn (sent_bytes < 0) ? sent_bytes : 0;\r\n}\r\nstatic int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev)\r\n{\r\nstruct dj_report *dj_report;\r\nint retval;\r\nif (djrcv_dev->querying_devices)\r\nreturn 0;\r\ndj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\r\nif (!dj_report)\r\nreturn -ENOMEM;\r\ndj_report->report_id = REPORT_ID_DJ_SHORT;\r\ndj_report->device_index = 0xFF;\r\ndj_report->report_type = REPORT_TYPE_CMD_GET_PAIRED_DEVICES;\r\nretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\r\nkfree(dj_report);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\r\nunsigned timeout)\r\n{\r\nstruct dj_report *dj_report;\r\nint retval;\r\ndj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\r\nif (!dj_report)\r\nreturn -ENOMEM;\r\ndj_report->report_id = REPORT_ID_DJ_SHORT;\r\ndj_report->device_index = 0xFF;\r\ndj_report->report_type = REPORT_TYPE_CMD_SWITCH;\r\ndj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\r\ndj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;\r\nretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\r\nkfree(dj_report);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_ll_open(struct hid_device *hid)\r\n{\r\ndbg_hid("%s:%s\n", __func__, hid->phys);\r\nreturn 0;\r\n}\r\nstatic void logi_dj_ll_close(struct hid_device *hid)\r\n{\r\ndbg_hid("%s:%s\n", __func__, hid->phys);\r\n}\r\nstatic int logi_dj_output_hidraw_report(struct hid_device *hid, u8 * buf,\r\nsize_t count,\r\nunsigned char report_type)\r\n{\r\ndbg_hid("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void rdcat(char **rdesc, unsigned int *rsize, const char *data, unsigned int size)\r\n{\r\nmemcpy(*rdesc + *rsize, data, size);\r\n*rsize += size;\r\n}\r\nstatic int logi_dj_ll_parse(struct hid_device *hid)\r\n{\r\nstruct dj_device *djdev = hid->driver_data;\r\nunsigned int rsize = 0;\r\nchar *rdesc;\r\nint retval;\r\ndbg_hid("%s\n", __func__);\r\ndjdev->hdev->version = 0x0111;\r\ndjdev->hdev->country = 0x00;\r\nrdesc = kmalloc(MAX_RDESC_SIZE, GFP_KERNEL);\r\nif (!rdesc)\r\nreturn -ENOMEM;\r\nif (djdev->reports_supported & STD_KEYBOARD) {\r\ndbg_hid("%s: sending a kbd descriptor, reports_supported: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(&rdesc, &rsize, kbd_descriptor, sizeof(kbd_descriptor));\r\n}\r\nif (djdev->reports_supported & STD_MOUSE) {\r\ndbg_hid("%s: sending a mouse descriptor, reports_supported: "\r\n"%x\n", __func__, djdev->reports_supported);\r\nrdcat(&rdesc, &rsize, mse_descriptor, sizeof(mse_descriptor));\r\n}\r\nif (djdev->reports_supported & MULTIMEDIA) {\r\ndbg_hid("%s: sending a multimedia report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(&rdesc, &rsize, consumer_descriptor, sizeof(consumer_descriptor));\r\n}\r\nif (djdev->reports_supported & POWER_KEYS) {\r\ndbg_hid("%s: sending a power keys report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(&rdesc, &rsize, syscontrol_descriptor, sizeof(syscontrol_descriptor));\r\n}\r\nif (djdev->reports_supported & MEDIA_CENTER) {\r\ndbg_hid("%s: sending a media center report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(&rdesc, &rsize, media_descriptor, sizeof(media_descriptor));\r\n}\r\nif (djdev->reports_supported & KBD_LEDS) {\r\ndbg_hid("%s: need to send kbd leds report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\n}\r\nretval = hid_parse_report(hid, rdesc, rsize);\r\nkfree(rdesc);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_ll_input_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct hid_device *dj_hiddev = input_get_drvdata(dev);\r\nstruct dj_device *dj_dev = dj_hiddev->driver_data;\r\nstruct dj_receiver_dev *djrcv_dev =\r\ndev_get_drvdata(dj_hiddev->dev.parent);\r\nstruct hid_device *dj_rcv_hiddev = djrcv_dev->hdev;\r\nstruct hid_report_enum *output_report_enum;\r\nstruct hid_field *field;\r\nstruct hid_report *report;\r\nunsigned char data[8];\r\nint offset;\r\ndbg_hid("%s: %s, type:%d | code:%d | value:%d\n",\r\n__func__, dev->phys, type, code, value);\r\nif (type != EV_LED)\r\nreturn -1;\r\noffset = hidinput_find_field(dj_hiddev, type, code, &field);\r\nif (offset == -1) {\r\ndev_warn(&dev->dev, "event field not found\n");\r\nreturn -1;\r\n}\r\nhid_set_field(field, offset, value);\r\nhid_output_report(field->report, &data[0]);\r\noutput_report_enum = &dj_rcv_hiddev->report_enum[HID_OUTPUT_REPORT];\r\nreport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\r\nhid_set_field(report->field[0], 0, dj_dev->device_index);\r\nhid_set_field(report->field[0], 1, REPORT_TYPE_LEDS);\r\nhid_set_field(report->field[0], 2, data[1]);\r\nusbhid_submit_report(dj_rcv_hiddev, report, USB_DIR_OUT);\r\nreturn 0;\r\n}\r\nstatic int logi_dj_ll_start(struct hid_device *hid)\r\n{\r\ndbg_hid("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void logi_dj_ll_stop(struct hid_device *hid)\r\n{\r\ndbg_hid("%s\n", __func__);\r\n}\r\nstatic int logi_dj_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data,\r\nint size)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nstruct dj_report *dj_report = (struct dj_report *) data;\r\nunsigned long flags;\r\nbool report_processed = false;\r\ndbg_hid("%s, size:%d\n", __func__, size);\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\nif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\r\nswitch (dj_report->report_type) {\r\ncase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\r\ncase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\r\nlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\r\nbreak;\r\ncase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\r\nif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\r\nSTATUS_LINKLOSS) {\r\nlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\r\n}\r\nbreak;\r\ndefault:\r\nlogi_dj_recv_forward_report(djrcv_dev, dj_report);\r\n}\r\nreport_processed = true;\r\n}\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nreturn report_processed;\r\n}\r\nstatic int logi_dj_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct dj_receiver_dev *djrcv_dev;\r\nint retval;\r\nif (is_dj_device((struct dj_device *)hdev->driver_data))\r\nreturn -ENODEV;\r\ndbg_hid("%s called for ifnum %d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber !=\r\nLOGITECH_DJ_INTERFACE_NUMBER) {\r\ndbg_hid("%s: ignoring ifnum %d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nreturn -ENODEV;\r\n}\r\ndjrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);\r\nif (!djrcv_dev) {\r\ndev_err(&hdev->dev,\r\n"%s:failed allocating dj_receiver_dev\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndjrcv_dev->hdev = hdev;\r\nINIT_WORK(&djrcv_dev->work, delayedwork_callback);\r\nspin_lock_init(&djrcv_dev->lock);\r\nif (kfifo_alloc(&djrcv_dev->notif_fifo,\r\nDJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),\r\nGFP_KERNEL)) {\r\ndev_err(&hdev->dev,\r\n"%s:failed allocating notif_fifo\n", __func__);\r\nkfree(djrcv_dev);\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, djrcv_dev);\r\nretval = hid_parse(hdev);\r\nif (retval) {\r\ndev_err(&hdev->dev,\r\n"%s:parse of interface 2 failed\n", __func__);\r\ngoto hid_parse_fail;\r\n}\r\nretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (retval) {\r\ndev_err(&hdev->dev,\r\n"%s:hid_hw_start returned error\n", __func__);\r\ngoto hid_hw_start_fail;\r\n}\r\nretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev,\r\n"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\n",\r\n__func__, retval);\r\ngoto switch_to_dj_mode_fail;\r\n}\r\nretval = hdev->ll_driver->open(hdev);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev, "%s:hdev->ll_driver->open returned "\r\n"error:%d\n", __func__, retval);\r\ngoto llopen_failed;\r\n}\r\nretval = logi_dj_recv_query_paired_devices(djrcv_dev);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev, "%s:logi_dj_recv_query_paired_devices "\r\n"error:%d\n", __func__, retval);\r\ngoto logi_dj_recv_query_paired_devices_failed;\r\n}\r\nreturn retval;\r\nlogi_dj_recv_query_paired_devices_failed:\r\nhdev->ll_driver->close(hdev);\r\nllopen_failed:\r\nswitch_to_dj_mode_fail:\r\nhid_hw_stop(hdev);\r\nhid_hw_start_fail:\r\nhid_parse_fail:\r\nkfifo_free(&djrcv_dev->notif_fifo);\r\nkfree(djrcv_dev);\r\nhid_set_drvdata(hdev, NULL);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_reset_resume(struct hid_device *hdev)\r\n{\r\nint retval;\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev,\r\n"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\n",\r\n__func__, retval);\r\n}\r\nreturn 0;\r\n}\r\nstatic void logi_dj_remove(struct hid_device *hdev)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nstruct dj_device *dj_dev;\r\nint i;\r\ndbg_hid("%s\n", __func__);\r\ncancel_work_sync(&djrcv_dev->work);\r\nhdev->ll_driver->close(hdev);\r\nhid_hw_stop(hdev);\r\nfor (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {\r\ndj_dev = djrcv_dev->paired_dj_devices[i];\r\nif (dj_dev != NULL) {\r\nhid_destroy_device(dj_dev->hdev);\r\nkfree(dj_dev);\r\ndjrcv_dev->paired_dj_devices[i] = NULL;\r\n}\r\n}\r\nkfifo_free(&djrcv_dev->notif_fifo);\r\nkfree(djrcv_dev);\r\nhid_set_drvdata(hdev, NULL);\r\n}\r\nstatic int logi_djdevice_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct dj_device *dj_dev = hdev->driver_data;\r\nif (!is_dj_device(dj_dev))\r\nreturn -ENODEV;\r\nret = hid_parse(hdev);\r\nif (!ret)\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nreturn ret;\r\n}\r\nstatic int __init logi_dj_init(void)\r\n{\r\nint retval;\r\ndbg_hid("Logitech-DJ:%s\n", __func__);\r\nretval = hid_register_driver(&logi_djreceiver_driver);\r\nif (retval)\r\nreturn retval;\r\nretval = hid_register_driver(&logi_djdevice_driver);\r\nif (retval)\r\nhid_unregister_driver(&logi_djreceiver_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit logi_dj_exit(void)\r\n{\r\ndbg_hid("Logitech-DJ:%s\n", __func__);\r\nhid_unregister_driver(&logi_djdevice_driver);\r\nhid_unregister_driver(&logi_djreceiver_driver);\r\n}
