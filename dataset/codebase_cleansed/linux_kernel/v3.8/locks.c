static bool lease_breaking(struct file_lock *fl)\r\n{\r\nreturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\r\n}\r\nstatic int target_leasetype(struct file_lock *fl)\r\n{\r\nif (fl->fl_flags & FL_UNLOCK_PENDING)\r\nreturn F_UNLCK;\r\nif (fl->fl_flags & FL_DOWNGRADE_PENDING)\r\nreturn F_RDLCK;\r\nreturn fl->fl_type;\r\n}\r\nvoid lock_flocks(void)\r\n{\r\nspin_lock(&file_lock_lock);\r\n}\r\nvoid unlock_flocks(void)\r\n{\r\nspin_unlock(&file_lock_lock);\r\n}\r\nstatic void locks_init_lock_heads(struct file_lock *fl)\r\n{\r\nINIT_LIST_HEAD(&fl->fl_link);\r\nINIT_LIST_HEAD(&fl->fl_block);\r\ninit_waitqueue_head(&fl->fl_wait);\r\n}\r\nstruct file_lock *locks_alloc_lock(void)\r\n{\r\nstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\r\nif (fl)\r\nlocks_init_lock_heads(fl);\r\nreturn fl;\r\n}\r\nvoid locks_release_private(struct file_lock *fl)\r\n{\r\nif (fl->fl_ops) {\r\nif (fl->fl_ops->fl_release_private)\r\nfl->fl_ops->fl_release_private(fl);\r\nfl->fl_ops = NULL;\r\n}\r\nfl->fl_lmops = NULL;\r\n}\r\nvoid locks_free_lock(struct file_lock *fl)\r\n{\r\nBUG_ON(waitqueue_active(&fl->fl_wait));\r\nBUG_ON(!list_empty(&fl->fl_block));\r\nBUG_ON(!list_empty(&fl->fl_link));\r\nlocks_release_private(fl);\r\nkmem_cache_free(filelock_cache, fl);\r\n}\r\nvoid locks_init_lock(struct file_lock *fl)\r\n{\r\nmemset(fl, 0, sizeof(struct file_lock));\r\nlocks_init_lock_heads(fl);\r\n}\r\nstatic void locks_copy_private(struct file_lock *new, struct file_lock *fl)\r\n{\r\nif (fl->fl_ops) {\r\nif (fl->fl_ops->fl_copy_lock)\r\nfl->fl_ops->fl_copy_lock(new, fl);\r\nnew->fl_ops = fl->fl_ops;\r\n}\r\nif (fl->fl_lmops)\r\nnew->fl_lmops = fl->fl_lmops;\r\n}\r\nvoid __locks_copy_lock(struct file_lock *new, const struct file_lock *fl)\r\n{\r\nnew->fl_owner = fl->fl_owner;\r\nnew->fl_pid = fl->fl_pid;\r\nnew->fl_file = NULL;\r\nnew->fl_flags = fl->fl_flags;\r\nnew->fl_type = fl->fl_type;\r\nnew->fl_start = fl->fl_start;\r\nnew->fl_end = fl->fl_end;\r\nnew->fl_ops = NULL;\r\nnew->fl_lmops = NULL;\r\n}\r\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\r\n{\r\nlocks_release_private(new);\r\n__locks_copy_lock(new, fl);\r\nnew->fl_file = fl->fl_file;\r\nnew->fl_ops = fl->fl_ops;\r\nnew->fl_lmops = fl->fl_lmops;\r\nlocks_copy_private(new, fl);\r\n}\r\nstatic inline int flock_translate_cmd(int cmd) {\r\nif (cmd & LOCK_MAND)\r\nreturn cmd & (LOCK_MAND | LOCK_RW);\r\nswitch (cmd) {\r\ncase LOCK_SH:\r\nreturn F_RDLCK;\r\ncase LOCK_EX:\r\nreturn F_WRLCK;\r\ncase LOCK_UN:\r\nreturn F_UNLCK;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int flock_make_lock(struct file *filp, struct file_lock **lock,\r\nunsigned int cmd)\r\n{\r\nstruct file_lock *fl;\r\nint type = flock_translate_cmd(cmd);\r\nif (type < 0)\r\nreturn type;\r\nfl = locks_alloc_lock();\r\nif (fl == NULL)\r\nreturn -ENOMEM;\r\nfl->fl_file = filp;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_flags = FL_FLOCK;\r\nfl->fl_type = type;\r\nfl->fl_end = OFFSET_MAX;\r\n*lock = fl;\r\nreturn 0;\r\n}\r\nstatic int assign_type(struct file_lock *fl, long type)\r\n{\r\nswitch (type) {\r\ncase F_RDLCK:\r\ncase F_WRLCK:\r\ncase F_UNLCK:\r\nfl->fl_type = type;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\r\nstruct flock *l)\r\n{\r\noff_t start, end;\r\nswitch (l->l_whence) {\r\ncase SEEK_SET:\r\nstart = 0;\r\nbreak;\r\ncase SEEK_CUR:\r\nstart = filp->f_pos;\r\nbreak;\r\ncase SEEK_END:\r\nstart = i_size_read(filp->f_path.dentry->d_inode);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstart += l->l_start;\r\nif (start < 0)\r\nreturn -EINVAL;\r\nfl->fl_end = OFFSET_MAX;\r\nif (l->l_len > 0) {\r\nend = start + l->l_len - 1;\r\nfl->fl_end = end;\r\n} else if (l->l_len < 0) {\r\nend = start - 1;\r\nfl->fl_end = end;\r\nstart += l->l_len;\r\nif (start < 0)\r\nreturn -EINVAL;\r\n}\r\nfl->fl_start = start;\r\nif (fl->fl_end < fl->fl_start)\r\nreturn -EOVERFLOW;\r\nfl->fl_owner = current->files;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_file = filp;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_ops = NULL;\r\nfl->fl_lmops = NULL;\r\nreturn assign_type(fl, l->l_type);\r\n}\r\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\r\nstruct flock64 *l)\r\n{\r\nloff_t start;\r\nswitch (l->l_whence) {\r\ncase SEEK_SET:\r\nstart = 0;\r\nbreak;\r\ncase SEEK_CUR:\r\nstart = filp->f_pos;\r\nbreak;\r\ncase SEEK_END:\r\nstart = i_size_read(filp->f_path.dentry->d_inode);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstart += l->l_start;\r\nif (start < 0)\r\nreturn -EINVAL;\r\nfl->fl_end = OFFSET_MAX;\r\nif (l->l_len > 0) {\r\nfl->fl_end = start + l->l_len - 1;\r\n} else if (l->l_len < 0) {\r\nfl->fl_end = start - 1;\r\nstart += l->l_len;\r\nif (start < 0)\r\nreturn -EINVAL;\r\n}\r\nfl->fl_start = start;\r\nif (fl->fl_end < fl->fl_start)\r\nreturn -EOVERFLOW;\r\nfl->fl_owner = current->files;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_file = filp;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_ops = NULL;\r\nfl->fl_lmops = NULL;\r\nreturn assign_type(fl, l->l_type);\r\n}\r\nstatic void lease_break_callback(struct file_lock *fl)\r\n{\r\nkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\r\n}\r\nstatic int lease_init(struct file *filp, long type, struct file_lock *fl)\r\n{\r\nif (assign_type(fl, type) != 0)\r\nreturn -EINVAL;\r\nfl->fl_owner = current->files;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_file = filp;\r\nfl->fl_flags = FL_LEASE;\r\nfl->fl_start = 0;\r\nfl->fl_end = OFFSET_MAX;\r\nfl->fl_ops = NULL;\r\nfl->fl_lmops = &lease_manager_ops;\r\nreturn 0;\r\n}\r\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\r\n{\r\nstruct file_lock *fl = locks_alloc_lock();\r\nint error = -ENOMEM;\r\nif (fl == NULL)\r\nreturn ERR_PTR(error);\r\nerror = lease_init(filp, type, fl);\r\nif (error) {\r\nlocks_free_lock(fl);\r\nreturn ERR_PTR(error);\r\n}\r\nreturn fl;\r\n}\r\nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\r\n{\r\nreturn ((fl1->fl_end >= fl2->fl_start) &&\r\n(fl2->fl_end >= fl1->fl_start));\r\n}\r\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\r\n{\r\nif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\r\nreturn fl2->fl_lmops == fl1->fl_lmops &&\r\nfl1->fl_lmops->lm_compare_owner(fl1, fl2);\r\nreturn fl1->fl_owner == fl2->fl_owner;\r\n}\r\nstatic void __locks_delete_block(struct file_lock *waiter)\r\n{\r\nlist_del_init(&waiter->fl_block);\r\nlist_del_init(&waiter->fl_link);\r\nwaiter->fl_next = NULL;\r\n}\r\nvoid locks_delete_block(struct file_lock *waiter)\r\n{\r\nlock_flocks();\r\n__locks_delete_block(waiter);\r\nunlock_flocks();\r\n}\r\nstatic void locks_insert_block(struct file_lock *blocker,\r\nstruct file_lock *waiter)\r\n{\r\nBUG_ON(!list_empty(&waiter->fl_block));\r\nlist_add_tail(&waiter->fl_block, &blocker->fl_block);\r\nwaiter->fl_next = blocker;\r\nif (IS_POSIX(blocker))\r\nlist_add(&waiter->fl_link, &blocked_list);\r\n}\r\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\r\n{\r\nwhile (!list_empty(&blocker->fl_block)) {\r\nstruct file_lock *waiter;\r\nwaiter = list_first_entry(&blocker->fl_block,\r\nstruct file_lock, fl_block);\r\n__locks_delete_block(waiter);\r\nif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\r\nwaiter->fl_lmops->lm_notify(waiter);\r\nelse\r\nwake_up(&waiter->fl_wait);\r\n}\r\n}\r\nstatic void locks_insert_lock(struct file_lock **pos, struct file_lock *fl)\r\n{\r\nlist_add(&fl->fl_link, &file_lock_list);\r\nfl->fl_nspid = get_pid(task_tgid(current));\r\nfl->fl_next = *pos;\r\n*pos = fl;\r\n}\r\nstatic void locks_delete_lock(struct file_lock **thisfl_p)\r\n{\r\nstruct file_lock *fl = *thisfl_p;\r\n*thisfl_p = fl->fl_next;\r\nfl->fl_next = NULL;\r\nlist_del_init(&fl->fl_link);\r\nif (fl->fl_nspid) {\r\nput_pid(fl->fl_nspid);\r\nfl->fl_nspid = NULL;\r\n}\r\nlocks_wake_up_blocks(fl);\r\nlocks_free_lock(fl);\r\n}\r\nstatic int locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\r\n{\r\nif (sys_fl->fl_type == F_WRLCK)\r\nreturn 1;\r\nif (caller_fl->fl_type == F_WRLCK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\r\n{\r\nif (!IS_POSIX(sys_fl) || posix_same_owner(caller_fl, sys_fl))\r\nreturn (0);\r\nif (!locks_overlap(caller_fl, sys_fl))\r\nreturn 0;\r\nreturn (locks_conflict(caller_fl, sys_fl));\r\n}\r\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\r\n{\r\nif (!IS_FLOCK(sys_fl) || (caller_fl->fl_file == sys_fl->fl_file))\r\nreturn (0);\r\nif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\r\nreturn 0;\r\nreturn (locks_conflict(caller_fl, sys_fl));\r\n}\r\nvoid\r\nposix_test_lock(struct file *filp, struct file_lock *fl)\r\n{\r\nstruct file_lock *cfl;\r\nlock_flocks();\r\nfor (cfl = filp->f_path.dentry->d_inode->i_flock; cfl; cfl = cfl->fl_next) {\r\nif (!IS_POSIX(cfl))\r\ncontinue;\r\nif (posix_locks_conflict(fl, cfl))\r\nbreak;\r\n}\r\nif (cfl) {\r\n__locks_copy_lock(fl, cfl);\r\nif (cfl->fl_nspid)\r\nfl->fl_pid = pid_vnr(cfl->fl_nspid);\r\n} else\r\nfl->fl_type = F_UNLCK;\r\nunlock_flocks();\r\nreturn;\r\n}\r\nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\r\n{\r\nstruct file_lock *fl;\r\nlist_for_each_entry(fl, &blocked_list, fl_link) {\r\nif (posix_same_owner(fl, block_fl))\r\nreturn fl->fl_next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\r\nstruct file_lock *block_fl)\r\n{\r\nint i = 0;\r\nwhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\r\nif (i++ > MAX_DEADLK_ITERATIONS)\r\nreturn 0;\r\nif (posix_same_owner(caller_fl, block_fl))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flock_lock_file(struct file *filp, struct file_lock *request)\r\n{\r\nstruct file_lock *new_fl = NULL;\r\nstruct file_lock **before;\r\nstruct inode * inode = filp->f_path.dentry->d_inode;\r\nint error = 0;\r\nint found = 0;\r\nif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\r\nnew_fl = locks_alloc_lock();\r\nif (!new_fl)\r\nreturn -ENOMEM;\r\n}\r\nlock_flocks();\r\nif (request->fl_flags & FL_ACCESS)\r\ngoto find_conflict;\r\nfor_each_lock(inode, before) {\r\nstruct file_lock *fl = *before;\r\nif (IS_POSIX(fl))\r\nbreak;\r\nif (IS_LEASE(fl))\r\ncontinue;\r\nif (filp != fl->fl_file)\r\ncontinue;\r\nif (request->fl_type == fl->fl_type)\r\ngoto out;\r\nfound = 1;\r\nlocks_delete_lock(before);\r\nbreak;\r\n}\r\nif (request->fl_type == F_UNLCK) {\r\nif ((request->fl_flags & FL_EXISTS) && !found)\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nif (found) {\r\nunlock_flocks();\r\ncond_resched();\r\nlock_flocks();\r\n}\r\nfind_conflict:\r\nfor_each_lock(inode, before) {\r\nstruct file_lock *fl = *before;\r\nif (IS_POSIX(fl))\r\nbreak;\r\nif (IS_LEASE(fl))\r\ncontinue;\r\nif (!flock_locks_conflict(request, fl))\r\ncontinue;\r\nerror = -EAGAIN;\r\nif (!(request->fl_flags & FL_SLEEP))\r\ngoto out;\r\nerror = FILE_LOCK_DEFERRED;\r\nlocks_insert_block(fl, request);\r\ngoto out;\r\n}\r\nif (request->fl_flags & FL_ACCESS)\r\ngoto out;\r\nlocks_copy_lock(new_fl, request);\r\nlocks_insert_lock(before, new_fl);\r\nnew_fl = NULL;\r\nerror = 0;\r\nout:\r\nunlock_flocks();\r\nif (new_fl)\r\nlocks_free_lock(new_fl);\r\nreturn error;\r\n}\r\nstatic int __posix_lock_file(struct inode *inode, struct file_lock *request, struct file_lock *conflock)\r\n{\r\nstruct file_lock *fl;\r\nstruct file_lock *new_fl = NULL;\r\nstruct file_lock *new_fl2 = NULL;\r\nstruct file_lock *left = NULL;\r\nstruct file_lock *right = NULL;\r\nstruct file_lock **before;\r\nint error, added = 0;\r\nif (!(request->fl_flags & FL_ACCESS) &&\r\n(request->fl_type != F_UNLCK ||\r\nrequest->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\r\nnew_fl = locks_alloc_lock();\r\nnew_fl2 = locks_alloc_lock();\r\n}\r\nlock_flocks();\r\nif (request->fl_type != F_UNLCK) {\r\nfor_each_lock(inode, before) {\r\nfl = *before;\r\nif (!IS_POSIX(fl))\r\ncontinue;\r\nif (!posix_locks_conflict(request, fl))\r\ncontinue;\r\nif (conflock)\r\n__locks_copy_lock(conflock, fl);\r\nerror = -EAGAIN;\r\nif (!(request->fl_flags & FL_SLEEP))\r\ngoto out;\r\nerror = -EDEADLK;\r\nif (posix_locks_deadlock(request, fl))\r\ngoto out;\r\nerror = FILE_LOCK_DEFERRED;\r\nlocks_insert_block(fl, request);\r\ngoto out;\r\n}\r\n}\r\nerror = 0;\r\nif (request->fl_flags & FL_ACCESS)\r\ngoto out;\r\nbefore = &inode->i_flock;\r\nwhile ((fl = *before) && (!IS_POSIX(fl) ||\r\n!posix_same_owner(request, fl))) {\r\nbefore = &fl->fl_next;\r\n}\r\nwhile ((fl = *before) && posix_same_owner(request, fl)) {\r\nif (request->fl_type == fl->fl_type) {\r\nif (fl->fl_end < request->fl_start - 1)\r\ngoto next_lock;\r\nif (fl->fl_start - 1 > request->fl_end)\r\nbreak;\r\nif (fl->fl_start > request->fl_start)\r\nfl->fl_start = request->fl_start;\r\nelse\r\nrequest->fl_start = fl->fl_start;\r\nif (fl->fl_end < request->fl_end)\r\nfl->fl_end = request->fl_end;\r\nelse\r\nrequest->fl_end = fl->fl_end;\r\nif (added) {\r\nlocks_delete_lock(before);\r\ncontinue;\r\n}\r\nrequest = fl;\r\nadded = 1;\r\n}\r\nelse {\r\nif (fl->fl_end < request->fl_start)\r\ngoto next_lock;\r\nif (fl->fl_start > request->fl_end)\r\nbreak;\r\nif (request->fl_type == F_UNLCK)\r\nadded = 1;\r\nif (fl->fl_start < request->fl_start)\r\nleft = fl;\r\nif (fl->fl_end > request->fl_end) {\r\nright = fl;\r\nbreak;\r\n}\r\nif (fl->fl_start >= request->fl_start) {\r\nif (added) {\r\nlocks_delete_lock(before);\r\ncontinue;\r\n}\r\nlocks_wake_up_blocks(fl);\r\nfl->fl_start = request->fl_start;\r\nfl->fl_end = request->fl_end;\r\nfl->fl_type = request->fl_type;\r\nlocks_release_private(fl);\r\nlocks_copy_private(fl, request);\r\nrequest = fl;\r\nadded = 1;\r\n}\r\n}\r\nnext_lock:\r\nbefore = &fl->fl_next;\r\n}\r\nerror = -ENOLCK;\r\nif (right && left == right && !new_fl2)\r\ngoto out;\r\nerror = 0;\r\nif (!added) {\r\nif (request->fl_type == F_UNLCK) {\r\nif (request->fl_flags & FL_EXISTS)\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nif (!new_fl) {\r\nerror = -ENOLCK;\r\ngoto out;\r\n}\r\nlocks_copy_lock(new_fl, request);\r\nlocks_insert_lock(before, new_fl);\r\nnew_fl = NULL;\r\n}\r\nif (right) {\r\nif (left == right) {\r\nleft = new_fl2;\r\nnew_fl2 = NULL;\r\nlocks_copy_lock(left, right);\r\nlocks_insert_lock(before, left);\r\n}\r\nright->fl_start = request->fl_end + 1;\r\nlocks_wake_up_blocks(right);\r\n}\r\nif (left) {\r\nleft->fl_end = request->fl_start - 1;\r\nlocks_wake_up_blocks(left);\r\n}\r\nout:\r\nunlock_flocks();\r\nif (new_fl)\r\nlocks_free_lock(new_fl);\r\nif (new_fl2)\r\nlocks_free_lock(new_fl2);\r\nreturn error;\r\n}\r\nint posix_lock_file(struct file *filp, struct file_lock *fl,\r\nstruct file_lock *conflock)\r\n{\r\nreturn __posix_lock_file(filp->f_path.dentry->d_inode, fl, conflock);\r\n}\r\nint posix_lock_file_wait(struct file *filp, struct file_lock *fl)\r\n{\r\nint error;\r\nmight_sleep ();\r\nfor (;;) {\r\nerror = posix_lock_file(filp, fl, NULL);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\r\nif (!error)\r\ncontinue;\r\nlocks_delete_block(fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nint locks_mandatory_locked(struct inode *inode)\r\n{\r\nfl_owner_t owner = current->files;\r\nstruct file_lock *fl;\r\nlock_flocks();\r\nfor (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {\r\nif (!IS_POSIX(fl))\r\ncontinue;\r\nif (fl->fl_owner != owner)\r\nbreak;\r\n}\r\nunlock_flocks();\r\nreturn fl ? -EAGAIN : 0;\r\n}\r\nint locks_mandatory_area(int read_write, struct inode *inode,\r\nstruct file *filp, loff_t offset,\r\nsize_t count)\r\n{\r\nstruct file_lock fl;\r\nint error;\r\nlocks_init_lock(&fl);\r\nfl.fl_owner = current->files;\r\nfl.fl_pid = current->tgid;\r\nfl.fl_file = filp;\r\nfl.fl_flags = FL_POSIX | FL_ACCESS;\r\nif (filp && !(filp->f_flags & O_NONBLOCK))\r\nfl.fl_flags |= FL_SLEEP;\r\nfl.fl_type = (read_write == FLOCK_VERIFY_WRITE) ? F_WRLCK : F_RDLCK;\r\nfl.fl_start = offset;\r\nfl.fl_end = offset + count - 1;\r\nfor (;;) {\r\nerror = __posix_lock_file(inode, &fl, NULL);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\r\nif (!error) {\r\nif (__mandatory_lock(inode))\r\ncontinue;\r\n}\r\nlocks_delete_block(&fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\r\n{\r\nswitch (arg) {\r\ncase F_UNLCK:\r\nfl->fl_flags &= ~FL_UNLOCK_PENDING;\r\ncase F_RDLCK:\r\nfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\r\n}\r\n}\r\nint lease_modify(struct file_lock **before, int arg)\r\n{\r\nstruct file_lock *fl = *before;\r\nint error = assign_type(fl, arg);\r\nif (error)\r\nreturn error;\r\nlease_clear_pending(fl, arg);\r\nlocks_wake_up_blocks(fl);\r\nif (arg == F_UNLCK) {\r\nstruct file *filp = fl->fl_file;\r\nf_delown(filp);\r\nfilp->f_owner.signum = 0;\r\nfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\r\nif (fl->fl_fasync != NULL) {\r\nprintk(KERN_ERR "locks_delete_lock: fasync == %p\n", fl->fl_fasync);\r\nfl->fl_fasync = NULL;\r\n}\r\nlocks_delete_lock(before);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool past_time(unsigned long then)\r\n{\r\nif (!then)\r\nreturn false;\r\nreturn time_after(jiffies, then);\r\n}\r\nstatic void time_out_leases(struct inode *inode)\r\n{\r\nstruct file_lock **before;\r\nstruct file_lock *fl;\r\nbefore = &inode->i_flock;\r\nwhile ((fl = *before) && IS_LEASE(fl) && lease_breaking(fl)) {\r\nif (past_time(fl->fl_downgrade_time))\r\nlease_modify(before, F_RDLCK);\r\nif (past_time(fl->fl_break_time))\r\nlease_modify(before, F_UNLCK);\r\nif (fl == *before)\r\nbefore = &fl->fl_next;\r\n}\r\n}\r\nint __break_lease(struct inode *inode, unsigned int mode)\r\n{\r\nint error = 0;\r\nstruct file_lock *new_fl, *flock;\r\nstruct file_lock *fl;\r\nunsigned long break_time;\r\nint i_have_this_lease = 0;\r\nint want_write = (mode & O_ACCMODE) != O_RDONLY;\r\nnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\r\nif (IS_ERR(new_fl))\r\nreturn PTR_ERR(new_fl);\r\nlock_flocks();\r\ntime_out_leases(inode);\r\nflock = inode->i_flock;\r\nif ((flock == NULL) || !IS_LEASE(flock))\r\ngoto out;\r\nif (!locks_conflict(flock, new_fl))\r\ngoto out;\r\nfor (fl = flock; fl && IS_LEASE(fl); fl = fl->fl_next)\r\nif (fl->fl_owner == current->files)\r\ni_have_this_lease = 1;\r\nbreak_time = 0;\r\nif (lease_break_time > 0) {\r\nbreak_time = jiffies + lease_break_time * HZ;\r\nif (break_time == 0)\r\nbreak_time++;\r\n}\r\nfor (fl = flock; fl && IS_LEASE(fl); fl = fl->fl_next) {\r\nif (want_write) {\r\nif (fl->fl_flags & FL_UNLOCK_PENDING)\r\ncontinue;\r\nfl->fl_flags |= FL_UNLOCK_PENDING;\r\nfl->fl_break_time = break_time;\r\n} else {\r\nif (lease_breaking(flock))\r\ncontinue;\r\nfl->fl_flags |= FL_DOWNGRADE_PENDING;\r\nfl->fl_downgrade_time = break_time;\r\n}\r\nfl->fl_lmops->lm_break(fl);\r\n}\r\nif (i_have_this_lease || (mode & O_NONBLOCK)) {\r\nerror = -EWOULDBLOCK;\r\ngoto out;\r\n}\r\nrestart:\r\nbreak_time = flock->fl_break_time;\r\nif (break_time != 0) {\r\nbreak_time -= jiffies;\r\nif (break_time == 0)\r\nbreak_time++;\r\n}\r\nlocks_insert_block(flock, new_fl);\r\nunlock_flocks();\r\nerror = wait_event_interruptible_timeout(new_fl->fl_wait,\r\n!new_fl->fl_next, break_time);\r\nlock_flocks();\r\n__locks_delete_block(new_fl);\r\nif (error >= 0) {\r\nif (error == 0)\r\ntime_out_leases(inode);\r\nfor (flock = inode->i_flock; flock && IS_LEASE(flock);\r\nflock = flock->fl_next) {\r\nif (locks_conflict(new_fl, flock))\r\ngoto restart;\r\n}\r\nerror = 0;\r\n}\r\nout:\r\nunlock_flocks();\r\nlocks_free_lock(new_fl);\r\nreturn error;\r\n}\r\nvoid lease_get_mtime(struct inode *inode, struct timespec *time)\r\n{\r\nstruct file_lock *flock = inode->i_flock;\r\nif (flock && IS_LEASE(flock) && (flock->fl_type == F_WRLCK))\r\n*time = current_fs_time(inode->i_sb);\r\nelse\r\n*time = inode->i_mtime;\r\n}\r\nint fcntl_getlease(struct file *filp)\r\n{\r\nstruct file_lock *fl;\r\nint type = F_UNLCK;\r\nlock_flocks();\r\ntime_out_leases(filp->f_path.dentry->d_inode);\r\nfor (fl = filp->f_path.dentry->d_inode->i_flock; fl && IS_LEASE(fl);\r\nfl = fl->fl_next) {\r\nif (fl->fl_file == filp) {\r\ntype = target_leasetype(fl);\r\nbreak;\r\n}\r\n}\r\nunlock_flocks();\r\nreturn type;\r\n}\r\nint generic_add_lease(struct file *filp, long arg, struct file_lock **flp)\r\n{\r\nstruct file_lock *fl, **before, **my_before = NULL, *lease;\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nlease = *flp;\r\nerror = -EAGAIN;\r\nif ((arg == F_RDLCK) && (atomic_read(&inode->i_writecount) > 0))\r\ngoto out;\r\nif ((arg == F_WRLCK)\r\n&& ((dentry->d_count > 1)\r\n|| (atomic_read(&inode->i_count) > 1)))\r\ngoto out;\r\nerror = -EAGAIN;\r\nfor (before = &inode->i_flock;\r\n((fl = *before) != NULL) && IS_LEASE(fl);\r\nbefore = &fl->fl_next) {\r\nif (fl->fl_file == filp) {\r\nmy_before = before;\r\ncontinue;\r\n}\r\nif (arg == F_WRLCK)\r\ngoto out;\r\nif (fl->fl_flags & FL_UNLOCK_PENDING)\r\ngoto out;\r\n}\r\nif (my_before != NULL) {\r\nerror = lease->fl_lmops->lm_change(my_before, arg);\r\nif (!error)\r\n*flp = *my_before;\r\ngoto out;\r\n}\r\nerror = -EINVAL;\r\nif (!leases_enable)\r\ngoto out;\r\nlocks_insert_lock(before, lease);\r\nreturn 0;\r\nout:\r\nreturn error;\r\n}\r\nint generic_delete_lease(struct file *filp, struct file_lock **flp)\r\n{\r\nstruct file_lock *fl, **before;\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nfor (before = &inode->i_flock;\r\n((fl = *before) != NULL) && IS_LEASE(fl);\r\nbefore = &fl->fl_next) {\r\nif (fl->fl_file != filp)\r\ncontinue;\r\nreturn (*flp)->fl_lmops->lm_change(before, F_UNLCK);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp)\r\n{\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\r\nreturn -EACCES;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EINVAL;\r\nerror = security_file_lock(filp, arg);\r\nif (error)\r\nreturn error;\r\ntime_out_leases(inode);\r\nBUG_ON(!(*flp)->fl_lmops->lm_break);\r\nswitch (arg) {\r\ncase F_UNLCK:\r\nreturn generic_delete_lease(filp, flp);\r\ncase F_RDLCK:\r\ncase F_WRLCK:\r\nreturn generic_add_lease(filp, arg, flp);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int __vfs_setlease(struct file *filp, long arg, struct file_lock **lease)\r\n{\r\nif (filp->f_op && filp->f_op->setlease)\r\nreturn filp->f_op->setlease(filp, arg, lease);\r\nelse\r\nreturn generic_setlease(filp, arg, lease);\r\n}\r\nint vfs_setlease(struct file *filp, long arg, struct file_lock **lease)\r\n{\r\nint error;\r\nlock_flocks();\r\nerror = __vfs_setlease(filp, arg, lease);\r\nunlock_flocks();\r\nreturn error;\r\n}\r\nstatic int do_fcntl_delete_lease(struct file *filp)\r\n{\r\nstruct file_lock fl, *flp = &fl;\r\nlease_init(filp, F_UNLCK, flp);\r\nreturn vfs_setlease(filp, F_UNLCK, &flp);\r\n}\r\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\r\n{\r\nstruct file_lock *fl, *ret;\r\nstruct fasync_struct *new;\r\nint error;\r\nfl = lease_alloc(filp, arg);\r\nif (IS_ERR(fl))\r\nreturn PTR_ERR(fl);\r\nnew = fasync_alloc();\r\nif (!new) {\r\nlocks_free_lock(fl);\r\nreturn -ENOMEM;\r\n}\r\nret = fl;\r\nlock_flocks();\r\nerror = __vfs_setlease(filp, arg, &ret);\r\nif (error) {\r\nunlock_flocks();\r\nlocks_free_lock(fl);\r\ngoto out_free_fasync;\r\n}\r\nif (ret != fl)\r\nlocks_free_lock(fl);\r\nif (!fasync_insert_entry(fd, filp, &ret->fl_fasync, new))\r\nnew = NULL;\r\nerror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\r\nunlock_flocks();\r\nout_free_fasync:\r\nif (new)\r\nfasync_free(new);\r\nreturn error;\r\n}\r\nint fcntl_setlease(unsigned int fd, struct file *filp, long arg)\r\n{\r\nif (arg == F_UNLCK)\r\nreturn do_fcntl_delete_lease(filp);\r\nreturn do_fcntl_add_lease(fd, filp, arg);\r\n}\r\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\r\n{\r\nint error;\r\nmight_sleep();\r\nfor (;;) {\r\nerror = flock_lock_file(filp, fl);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\r\nif (!error)\r\ncontinue;\r\nlocks_delete_block(fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\r\n{\r\nif (filp->f_op && filp->f_op->lock)\r\nreturn filp->f_op->lock(filp, F_GETLK, fl);\r\nposix_test_lock(filp, fl);\r\nreturn 0;\r\n}\r\nstatic int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\r\n{\r\nflock->l_pid = fl->fl_pid;\r\n#if BITS_PER_LONG == 32\r\nif (fl->fl_start > OFFT_OFFSET_MAX)\r\nreturn -EOVERFLOW;\r\nif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\r\nreturn -EOVERFLOW;\r\n#endif\r\nflock->l_start = fl->fl_start;\r\nflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\r\nfl->fl_end - fl->fl_start + 1;\r\nflock->l_whence = 0;\r\nflock->l_type = fl->fl_type;\r\nreturn 0;\r\n}\r\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\r\n{\r\nflock->l_pid = fl->fl_pid;\r\nflock->l_start = fl->fl_start;\r\nflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\r\nfl->fl_end - fl->fl_start + 1;\r\nflock->l_whence = 0;\r\nflock->l_type = fl->fl_type;\r\n}\r\nint fcntl_getlk(struct file *filp, struct flock __user *l)\r\n{\r\nstruct file_lock file_lock;\r\nstruct flock flock;\r\nint error;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\nerror = -EINVAL;\r\nif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\r\ngoto out;\r\nerror = flock_to_posix_lock(filp, &file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nerror = vfs_test_lock(filp, &file_lock);\r\nif (error)\r\ngoto out;\r\nflock.l_type = file_lock.fl_type;\r\nif (file_lock.fl_type != F_UNLCK) {\r\nerror = posix_lock_to_flock(&flock, &file_lock);\r\nif (error)\r\ngoto out;\r\n}\r\nerror = -EFAULT;\r\nif (!copy_to_user(l, &flock, sizeof(flock)))\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\r\n{\r\nif (filp->f_op && filp->f_op->lock)\r\nreturn filp->f_op->lock(filp, cmd, fl);\r\nelse\r\nreturn posix_lock_file(filp, fl, conf);\r\n}\r\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\r\nstruct file_lock *fl)\r\n{\r\nint error;\r\nerror = security_file_lock(filp, fl->fl_type);\r\nif (error)\r\nreturn error;\r\nfor (;;) {\r\nerror = vfs_lock_file(filp, cmd, fl, NULL);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\r\nif (!error)\r\ncontinue;\r\nlocks_delete_block(fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nint fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\r\nstruct flock __user *l)\r\n{\r\nstruct file_lock *file_lock = locks_alloc_lock();\r\nstruct flock flock;\r\nstruct inode *inode;\r\nstruct file *f;\r\nint error;\r\nif (file_lock == NULL)\r\nreturn -ENOLCK;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\ninode = filp->f_path.dentry->d_inode;\r\nif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\r\nerror = -EAGAIN;\r\ngoto out;\r\n}\r\nagain:\r\nerror = flock_to_posix_lock(filp, file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nif (cmd == F_SETLKW) {\r\nfile_lock->fl_flags |= FL_SLEEP;\r\n}\r\nerror = -EBADF;\r\nswitch (flock.l_type) {\r\ncase F_RDLCK:\r\nif (!(filp->f_mode & FMODE_READ))\r\ngoto out;\r\nbreak;\r\ncase F_WRLCK:\r\nif (!(filp->f_mode & FMODE_WRITE))\r\ngoto out;\r\nbreak;\r\ncase F_UNLCK:\r\nbreak;\r\ndefault:\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nerror = do_lock_file_wait(filp, cmd, file_lock);\r\nspin_lock(&current->files->file_lock);\r\nf = fcheck(fd);\r\nspin_unlock(&current->files->file_lock);\r\nif (!error && f != filp && flock.l_type != F_UNLCK) {\r\nflock.l_type = F_UNLCK;\r\ngoto again;\r\n}\r\nout:\r\nlocks_free_lock(file_lock);\r\nreturn error;\r\n}\r\nint fcntl_getlk64(struct file *filp, struct flock64 __user *l)\r\n{\r\nstruct file_lock file_lock;\r\nstruct flock64 flock;\r\nint error;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\nerror = -EINVAL;\r\nif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\r\ngoto out;\r\nerror = flock64_to_posix_lock(filp, &file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nerror = vfs_test_lock(filp, &file_lock);\r\nif (error)\r\ngoto out;\r\nflock.l_type = file_lock.fl_type;\r\nif (file_lock.fl_type != F_UNLCK)\r\nposix_lock_to_flock64(&flock, &file_lock);\r\nerror = -EFAULT;\r\nif (!copy_to_user(l, &flock, sizeof(flock)))\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nint fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\r\nstruct flock64 __user *l)\r\n{\r\nstruct file_lock *file_lock = locks_alloc_lock();\r\nstruct flock64 flock;\r\nstruct inode *inode;\r\nstruct file *f;\r\nint error;\r\nif (file_lock == NULL)\r\nreturn -ENOLCK;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\ninode = filp->f_path.dentry->d_inode;\r\nif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\r\nerror = -EAGAIN;\r\ngoto out;\r\n}\r\nagain:\r\nerror = flock64_to_posix_lock(filp, file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nif (cmd == F_SETLKW64) {\r\nfile_lock->fl_flags |= FL_SLEEP;\r\n}\r\nerror = -EBADF;\r\nswitch (flock.l_type) {\r\ncase F_RDLCK:\r\nif (!(filp->f_mode & FMODE_READ))\r\ngoto out;\r\nbreak;\r\ncase F_WRLCK:\r\nif (!(filp->f_mode & FMODE_WRITE))\r\ngoto out;\r\nbreak;\r\ncase F_UNLCK:\r\nbreak;\r\ndefault:\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nerror = do_lock_file_wait(filp, cmd, file_lock);\r\nspin_lock(&current->files->file_lock);\r\nf = fcheck(fd);\r\nspin_unlock(&current->files->file_lock);\r\nif (!error && f != filp && flock.l_type != F_UNLCK) {\r\nflock.l_type = F_UNLCK;\r\ngoto again;\r\n}\r\nout:\r\nlocks_free_lock(file_lock);\r\nreturn error;\r\n}\r\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\r\n{\r\nstruct file_lock lock;\r\nif (!filp->f_path.dentry->d_inode->i_flock)\r\nreturn;\r\nlock.fl_type = F_UNLCK;\r\nlock.fl_flags = FL_POSIX | FL_CLOSE;\r\nlock.fl_start = 0;\r\nlock.fl_end = OFFSET_MAX;\r\nlock.fl_owner = owner;\r\nlock.fl_pid = current->tgid;\r\nlock.fl_file = filp;\r\nlock.fl_ops = NULL;\r\nlock.fl_lmops = NULL;\r\nvfs_lock_file(filp, F_SETLK, &lock, NULL);\r\nif (lock.fl_ops && lock.fl_ops->fl_release_private)\r\nlock.fl_ops->fl_release_private(&lock);\r\n}\r\nvoid locks_remove_flock(struct file *filp)\r\n{\r\nstruct inode * inode = filp->f_path.dentry->d_inode;\r\nstruct file_lock *fl;\r\nstruct file_lock **before;\r\nif (!inode->i_flock)\r\nreturn;\r\nif (filp->f_op && filp->f_op->flock) {\r\nstruct file_lock fl = {\r\n.fl_pid = current->tgid,\r\n.fl_file = filp,\r\n.fl_flags = FL_FLOCK,\r\n.fl_type = F_UNLCK,\r\n.fl_end = OFFSET_MAX,\r\n};\r\nfilp->f_op->flock(filp, F_SETLKW, &fl);\r\nif (fl.fl_ops && fl.fl_ops->fl_release_private)\r\nfl.fl_ops->fl_release_private(&fl);\r\n}\r\nlock_flocks();\r\nbefore = &inode->i_flock;\r\nwhile ((fl = *before) != NULL) {\r\nif (fl->fl_file == filp) {\r\nif (IS_FLOCK(fl)) {\r\nlocks_delete_lock(before);\r\ncontinue;\r\n}\r\nif (IS_LEASE(fl)) {\r\nlease_modify(before, F_UNLCK);\r\ncontinue;\r\n}\r\nBUG();\r\n}\r\nbefore = &fl->fl_next;\r\n}\r\nunlock_flocks();\r\n}\r\nint\r\nposix_unblock_lock(struct file *filp, struct file_lock *waiter)\r\n{\r\nint status = 0;\r\nlock_flocks();\r\nif (waiter->fl_next)\r\n__locks_delete_block(waiter);\r\nelse\r\nstatus = -ENOENT;\r\nunlock_flocks();\r\nreturn status;\r\n}\r\nint vfs_cancel_lock(struct file *filp, struct file_lock *fl)\r\n{\r\nif (filp->f_op && filp->f_op->lock)\r\nreturn filp->f_op->lock(filp, F_CANCELLK, fl);\r\nreturn 0;\r\n}\r\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\r\nloff_t id, char *pfx)\r\n{\r\nstruct inode *inode = NULL;\r\nunsigned int fl_pid;\r\nif (fl->fl_nspid)\r\nfl_pid = pid_vnr(fl->fl_nspid);\r\nelse\r\nfl_pid = fl->fl_pid;\r\nif (fl->fl_file != NULL)\r\ninode = fl->fl_file->f_path.dentry->d_inode;\r\nseq_printf(f, "%lld:%s ", id, pfx);\r\nif (IS_POSIX(fl)) {\r\nseq_printf(f, "%6s %s ",\r\n(fl->fl_flags & FL_ACCESS) ? "ACCESS" : "POSIX ",\r\n(inode == NULL) ? "*NOINODE*" :\r\nmandatory_lock(inode) ? "MANDATORY" : "ADVISORY ");\r\n} else if (IS_FLOCK(fl)) {\r\nif (fl->fl_type & LOCK_MAND) {\r\nseq_printf(f, "FLOCK MSNFS ");\r\n} else {\r\nseq_printf(f, "FLOCK ADVISORY ");\r\n}\r\n} else if (IS_LEASE(fl)) {\r\nseq_printf(f, "LEASE ");\r\nif (lease_breaking(fl))\r\nseq_printf(f, "BREAKING ");\r\nelse if (fl->fl_file)\r\nseq_printf(f, "ACTIVE ");\r\nelse\r\nseq_printf(f, "BREAKER ");\r\n} else {\r\nseq_printf(f, "UNKNOWN UNKNOWN ");\r\n}\r\nif (fl->fl_type & LOCK_MAND) {\r\nseq_printf(f, "%s ",\r\n(fl->fl_type & LOCK_READ)\r\n? (fl->fl_type & LOCK_WRITE) ? "RW " : "READ "\r\n: (fl->fl_type & LOCK_WRITE) ? "WRITE" : "NONE ");\r\n} else {\r\nseq_printf(f, "%s ",\r\n(lease_breaking(fl))\r\n? (fl->fl_type == F_UNLCK) ? "UNLCK" : "READ "\r\n: (fl->fl_type == F_WRLCK) ? "WRITE" : "READ ");\r\n}\r\nif (inode) {\r\n#ifdef WE_CAN_BREAK_LSLK_NOW\r\nseq_printf(f, "%d %s:%ld ", fl_pid,\r\ninode->i_sb->s_id, inode->i_ino);\r\n#else\r\nseq_printf(f, "%d %02x:%02x:%ld ", fl_pid,\r\nMAJOR(inode->i_sb->s_dev),\r\nMINOR(inode->i_sb->s_dev), inode->i_ino);\r\n#endif\r\n} else {\r\nseq_printf(f, "%d <none>:0 ", fl_pid);\r\n}\r\nif (IS_POSIX(fl)) {\r\nif (fl->fl_end == OFFSET_MAX)\r\nseq_printf(f, "%Ld EOF\n", fl->fl_start);\r\nelse\r\nseq_printf(f, "%Ld %Ld\n", fl->fl_start, fl->fl_end);\r\n} else {\r\nseq_printf(f, "0 EOF\n");\r\n}\r\n}\r\nstatic int locks_show(struct seq_file *f, void *v)\r\n{\r\nstruct file_lock *fl, *bfl;\r\nfl = list_entry(v, struct file_lock, fl_link);\r\nlock_get_status(f, fl, *((loff_t *)f->private), "");\r\nlist_for_each_entry(bfl, &fl->fl_block, fl_block)\r\nlock_get_status(f, bfl, *((loff_t *)f->private), " ->");\r\nreturn 0;\r\n}\r\nstatic void *locks_start(struct seq_file *f, loff_t *pos)\r\n{\r\nloff_t *p = f->private;\r\nlock_flocks();\r\n*p = (*pos + 1);\r\nreturn seq_list_start(&file_lock_list, *pos);\r\n}\r\nstatic void *locks_next(struct seq_file *f, void *v, loff_t *pos)\r\n{\r\nloff_t *p = f->private;\r\n++*p;\r\nreturn seq_list_next(v, &file_lock_list, pos);\r\n}\r\nstatic void locks_stop(struct seq_file *f, void *v)\r\n{\r\nunlock_flocks();\r\n}\r\nstatic int locks_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn seq_open_private(filp, &locks_seq_operations, sizeof(loff_t));\r\n}\r\nstatic int __init proc_locks_init(void)\r\n{\r\nproc_create("locks", 0, NULL, &proc_locks_operations);\r\nreturn 0;\r\n}\r\nint lock_may_read(struct inode *inode, loff_t start, unsigned long len)\r\n{\r\nstruct file_lock *fl;\r\nint result = 1;\r\nlock_flocks();\r\nfor (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {\r\nif (IS_POSIX(fl)) {\r\nif (fl->fl_type == F_RDLCK)\r\ncontinue;\r\nif ((fl->fl_end < start) || (fl->fl_start > (start + len)))\r\ncontinue;\r\n} else if (IS_FLOCK(fl)) {\r\nif (!(fl->fl_type & LOCK_MAND))\r\ncontinue;\r\nif (fl->fl_type & LOCK_READ)\r\ncontinue;\r\n} else\r\ncontinue;\r\nresult = 0;\r\nbreak;\r\n}\r\nunlock_flocks();\r\nreturn result;\r\n}\r\nint lock_may_write(struct inode *inode, loff_t start, unsigned long len)\r\n{\r\nstruct file_lock *fl;\r\nint result = 1;\r\nlock_flocks();\r\nfor (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {\r\nif (IS_POSIX(fl)) {\r\nif ((fl->fl_end < start) || (fl->fl_start > (start + len)))\r\ncontinue;\r\n} else if (IS_FLOCK(fl)) {\r\nif (!(fl->fl_type & LOCK_MAND))\r\ncontinue;\r\nif (fl->fl_type & LOCK_WRITE)\r\ncontinue;\r\n} else\r\ncontinue;\r\nresult = 0;\r\nbreak;\r\n}\r\nunlock_flocks();\r\nreturn result;\r\n}\r\nstatic int __init filelock_init(void)\r\n{\r\nfilelock_cache = kmem_cache_create("file_lock_cache",\r\nsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\r\nreturn 0;\r\n}
