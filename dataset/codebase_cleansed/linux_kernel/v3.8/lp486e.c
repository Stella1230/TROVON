static inline phys_addr\r\nva_to_pa(void *x) {\r\nreturn x ? virt_to_bus(x) : I596_NULL;\r\n}\r\nstatic inline void *\r\npa_to_va(phys_addr x) {\r\nreturn (x == I596_NULL) ? NULL : bus_to_virt(x);\r\n}\r\nstatic int\r\ni596_timeout(struct net_device *dev, char *msg, int ct) {\r\nstruct i596_private *lp;\r\nint boguscnt = ct;\r\nlp = netdev_priv(dev);\r\nwhile (lp->scb.command) {\r\nif (--boguscnt == 0) {\r\nprintk("%s: %s timed out - stat %4.4x, cmd %4.4x\n",\r\ndev->name, msg,\r\nlp->scb.status, lp->scb.command);\r\nreturn 1;\r\n}\r\nudelay(5);\r\nbarrier();\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\ninit_rx_bufs(struct net_device *dev, int num) {\r\nstruct i596_private *lp;\r\nstruct i596_rfd *rfd;\r\nint i;\r\nlp = netdev_priv(dev);\r\nlp->scb.pa_rfd = I596_NULL;\r\nfor (i = 0; i < num; i++) {\r\nrfd = kmalloc(sizeof(struct i596_rfd), GFP_KERNEL);\r\nif (rfd == NULL)\r\nbreak;\r\nrfd->stat = 0;\r\nrfd->pa_rbd = I596_NULL;\r\nrfd->count = 0;\r\nrfd->size = 1532;\r\nif (i == 0) {\r\nrfd->cmd = CMD_EOL;\r\nlp->rx_tail = rfd;\r\n} else {\r\nrfd->cmd = 0;\r\n}\r\nrfd->pa_next = lp->scb.pa_rfd;\r\nlp->scb.pa_rfd = va_to_pa(rfd);\r\nlp->rx_tail->pa_next = lp->scb.pa_rfd;\r\n}\r\n#if 0\r\nfor (i = 0; i<RX_RBD_SIZE; i++) {\r\nrbd = kmalloc(sizeof(struct i596_rbd), GFP_KERNEL);\r\nif (rbd) {\r\nrbd->pad = 0;\r\nrbd->count = 0;\r\nrbd->skb = dev_alloc_skb(RX_SKBSIZE);\r\nif (!rbd->skb) {\r\nprintk("dev_alloc_skb failed");\r\n}\r\nrbd->next = rfd->rbd;\r\nif (i) {\r\nrfd->rbd->prev = rbd;\r\nrbd->size = RX_SKBSIZE;\r\n} else {\r\nrbd->size = (RX_SKBSIZE | RBD_EL);\r\nlp->rbd_tail = rbd;\r\n}\r\nrfd->rbd = rbd;\r\n}\r\n}\r\nlp->rbd_tail->next = rfd->rbd;\r\n#endif\r\nreturn i;\r\n}\r\nstatic inline void\r\nremove_rx_bufs(struct net_device *dev) {\r\nstruct i596_private *lp;\r\nstruct i596_rfd *rfd;\r\nlp = netdev_priv(dev);\r\nlp->rx_tail->pa_next = I596_NULL;\r\ndo {\r\nrfd = pa_to_va(lp->scb.pa_rfd);\r\nlp->scb.pa_rfd = rfd->pa_next;\r\nkfree(rfd);\r\n} while (rfd != lp->rx_tail);\r\nlp->rx_tail = NULL;\r\n#if 0\r\nfor (lp->rbd_list) {\r\n}\r\n#endif\r\n}\r\nstatic inline void\r\nPORT(phys_addr a, unsigned int cmd) {\r\nif (a & 0xf)\r\nprintk("lp486e.c: PORT: address not aligned\n");\r\noutw(((a & 0xffff) | cmd), IOADDR);\r\noutw(((a>>16) & 0xffff), IOADDR+2);\r\n}\r\nstatic inline void\r\nCA(void) {\r\noutb(0, IOADDR+4);\r\nudelay(8);\r\n}\r\nstatic inline void\r\nCLEAR_INT(void) {\r\noutb(0, IOADDR+8);\r\n}\r\nstatic int\r\ni596_scp_setup(struct net_device *dev) {\r\nstruct i596_private *lp = netdev_priv(dev);\r\nint boguscnt;\r\nlp->scp.sysbus = 0x00440000;\r\nlp->scp.pad = 0;\r\nlp->scp.pa_iscp = va_to_pa(&(lp->iscp));\r\nlp->iscp.busy = 0x0001;\r\nlp->iscp.pa_scb = va_to_pa(&(lp->scb));\r\nlp->scb.command = 0;\r\nlp->scb.status = 0;\r\nlp->scb.pa_cmd = I596_NULL;\r\nlp->last_cmd = jiffies;\r\nlp->cmd_backlog = 0;\r\nlp->cmd_head = NULL;\r\nPORT(0, PORT_RESET);\r\nudelay(100);\r\nPORT(va_to_pa(&lp->scp), PORT_ALTSCP);\r\nCA();\r\nboguscnt = 100;\r\nwhile (lp->iscp.busy) {\r\nif (--boguscnt == 0) {\r\nprintk("%s: i82596 initialization timed out\n",\r\ndev->name);\r\nreturn 1;\r\n}\r\nudelay(5);\r\nbarrier();\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ninit_i596(struct net_device *dev) {\r\nstruct i596_private *lp;\r\nif (i596_scp_setup(dev))\r\nreturn 1;\r\nlp = netdev_priv(dev);\r\nlp->scb.command = 0;\r\nmemcpy ((void *)lp->i596_config, init_setup, 14);\r\nlp->set_conf.command = CmdConfigure;\r\ni596_add_cmd(dev, (void *)&lp->set_conf);\r\nmemcpy ((void *)lp->eth_addr, dev->dev_addr, 6);\r\nlp->set_add.command = CmdIASetup;\r\ni596_add_cmd(dev, &lp->set_add);\r\nlp->tdr.command = CmdTDR;\r\ni596_add_cmd(dev, &lp->tdr);\r\nif (lp->scb.command && i596_timeout(dev, "i82596 init", 200))\r\nreturn 1;\r\nlp->scb.command = RX_START;\r\nCA();\r\nbarrier();\r\nif (lp->scb.command && i596_timeout(dev, "Receive Unit start", 100))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\ni596_rx_one(struct net_device *dev, struct i596_private *lp,\r\nstruct i596_rfd *rfd, int *frames) {\r\nif (rfd->stat & RFD_STAT_OK) {\r\nint pkt_len = (rfd->count & 0x3fff);\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, pkt_len);\r\n(*frames)++;\r\nif (rfd->cmd & CMD_EOL)\r\nprintk("Received on EOL\n");\r\nif (skb == NULL) {\r\nprintk ("%s: i596_rx Memory squeeze, "\r\n"dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn 1;\r\n}\r\nmemcpy(skb_put(skb,pkt_len), rfd->data, pkt_len);\r\nskb->protocol = eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n} else {\r\n#if 0\r\nprintk("Frame reception error status %04x\n",\r\nrfd->stat);\r\n#endif\r\ndev->stats.rx_errors++;\r\nif (rfd->stat & RFD_COLLISION)\r\ndev->stats.collisions++;\r\nif (rfd->stat & RFD_SHORT_FRAME_ERR)\r\ndev->stats.rx_length_errors++;\r\nif (rfd->stat & RFD_DMA_ERR)\r\ndev->stats.rx_over_errors++;\r\nif (rfd->stat & RFD_NOBUFS_ERR)\r\ndev->stats.rx_fifo_errors++;\r\nif (rfd->stat & RFD_ALIGN_ERR)\r\ndev->stats.rx_frame_errors++;\r\nif (rfd->stat & RFD_CRC_ERR)\r\ndev->stats.rx_crc_errors++;\r\nif (rfd->stat & RFD_LENGTH_ERR)\r\ndev->stats.rx_length_errors++;\r\n}\r\nrfd->stat = rfd->count = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ni596_rx(struct net_device *dev) {\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_rfd *rfd;\r\nint frames = 0;\r\nwhile (1) {\r\nrfd = pa_to_va(lp->scb.pa_rfd);\r\nif (!rfd) {\r\nprintk(KERN_ERR "i596_rx: NULL rfd?\n");\r\nreturn 0;\r\n}\r\n#if 1\r\nif (rfd->stat && !(rfd->stat & (RFD_STAT_C | RFD_STAT_B)))\r\nprintk("SF:%p-%04x\n", rfd, rfd->stat);\r\n#endif\r\nif (!(rfd->stat & RFD_STAT_C))\r\nbreak;\r\nif (i596_rx_one(dev, lp, rfd, &frames))\r\nbreak;\r\nrfd->cmd = CMD_EOL;\r\nlp->rx_tail->cmd = 0;\r\nlp->rx_tail = rfd;\r\nlp->scb.pa_rfd = rfd->pa_next;\r\nbarrier();\r\n}\r\nreturn frames;\r\n}\r\nstatic void\r\ni596_cleanup_cmd(struct net_device *dev) {\r\nstruct i596_private *lp;\r\nstruct i596_cmd *cmd;\r\nlp = netdev_priv(dev);\r\nwhile (lp->cmd_head) {\r\ncmd = lp->cmd_head;\r\nlp->cmd_head = pa_to_va(lp->cmd_head->pa_next);\r\nlp->cmd_backlog--;\r\nswitch ((cmd->command) & 0x7) {\r\ncase CmdTx: {\r\nstruct tx_cmd *tx_cmd = (struct tx_cmd *) cmd;\r\nstruct i596_tbd * tx_cmd_tbd;\r\ntx_cmd_tbd = pa_to_va(tx_cmd->pa_tbd);\r\ndev_kfree_skb_any(tx_cmd_tbd->skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\ncmd->pa_next = I596_NULL;\r\nkfree((unsigned char *)tx_cmd);\r\nnetif_wake_queue(dev);\r\nbreak;\r\n}\r\ncase CmdMulticastList: {\r\ncmd->pa_next = I596_NULL;\r\nkfree((unsigned char *)cmd);\r\nbreak;\r\n}\r\ndefault: {\r\ncmd->pa_next = I596_NULL;\r\nbreak;\r\n}\r\n}\r\nbarrier();\r\n}\r\nif (lp->scb.command && i596_timeout(dev, "i596_cleanup_cmd", 100))\r\n;\r\nlp->scb.pa_cmd = va_to_pa(lp->cmd_head);\r\n}\r\nstatic void i596_reset(struct net_device *dev, struct i596_private *lp, int ioaddr) {\r\nif (lp->scb.command && i596_timeout(dev, "i596_reset", 100))\r\n;\r\nnetif_stop_queue(dev);\r\nlp->scb.command = CUC_ABORT | RX_ABORT;\r\nCA();\r\nbarrier();\r\nif (lp->scb.command && i596_timeout(dev, "i596_reset(2)", 400))\r\n;\r\ni596_cleanup_cmd(dev);\r\ni596_rx(dev);\r\nnetif_start_queue(dev);\r\ninit_i596(dev);\r\n}\r\nstatic void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd) {\r\nstruct i596_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\ncmd->status = 0;\r\ncmd->command |= (CMD_EOL | CMD_INTR);\r\ncmd->pa_next = I596_NULL;\r\nspin_lock_irqsave(&lp->cmd_lock, flags);\r\nif (lp->cmd_head) {\r\nlp->cmd_tail->pa_next = va_to_pa(cmd);\r\n} else {\r\nlp->cmd_head = cmd;\r\nif (lp->scb.command && i596_timeout(dev, "i596_add_cmd", 100))\r\n;\r\nlp->scb.pa_cmd = va_to_pa(cmd);\r\nlp->scb.command = CUC_START;\r\nCA();\r\n}\r\nlp->cmd_tail = cmd;\r\nlp->cmd_backlog++;\r\nlp->cmd_head = pa_to_va(lp->scb.pa_cmd);\r\nspin_unlock_irqrestore(&lp->cmd_lock, flags);\r\nif (lp->cmd_backlog > 16) {\r\nint tickssofar = jiffies - lp->last_cmd;\r\nif (tickssofar < HZ/4)\r\nreturn;\r\nprintk(KERN_WARNING "%s: command unit timed out, status resetting.\n", dev->name);\r\ni596_reset(dev, lp, ioaddr);\r\n}\r\n}\r\nstatic int i596_open(struct net_device *dev)\r\n{\r\nint i;\r\ni = request_irq(dev->irq, i596_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (i) {\r\nprintk(KERN_ERR "%s: IRQ %d not free\n", dev->name, dev->irq);\r\nreturn i;\r\n}\r\nif ((i = init_rx_bufs(dev, RX_RING_SIZE)) < RX_RING_SIZE)\r\nprintk(KERN_ERR "%s: only able to allocate %d receive buffers\n", dev->name, i);\r\nif (i < 4) {\r\nfree_irq(dev->irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nnetif_start_queue(dev);\r\ninit_i596(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t i596_start_xmit (struct sk_buff *skb, struct net_device *dev) {\r\nstruct tx_cmd *tx_cmd;\r\nshort length;\r\nlength = skb->len;\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\ntx_cmd = kmalloc((sizeof (struct tx_cmd) + sizeof (struct i596_tbd)), GFP_ATOMIC);\r\nif (tx_cmd == NULL) {\r\nprintk(KERN_WARNING "%s: i596_xmit Memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb (skb);\r\n} else {\r\nstruct i596_tbd *tx_cmd_tbd;\r\ntx_cmd_tbd = (struct i596_tbd *) (tx_cmd + 1);\r\ntx_cmd->pa_tbd = va_to_pa (tx_cmd_tbd);\r\ntx_cmd_tbd->pa_next = I596_NULL;\r\ntx_cmd->cmd.command = (CMD_FLEX | CmdTx);\r\ntx_cmd->pad = 0;\r\ntx_cmd->size = 0;\r\ntx_cmd_tbd->pad = 0;\r\ntx_cmd_tbd->size = (EOF | length);\r\ntx_cmd_tbd->pa_data = va_to_pa (skb->data);\r\ntx_cmd_tbd->skb = skb;\r\nif (i596_debug & LOG_SRCDST)\r\nprint_eth (skb->data);\r\ni596_add_cmd (dev, (struct i596_cmd *) tx_cmd);\r\ndev->stats.tx_packets++;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\ni596_tx_timeout (struct net_device *dev) {\r\nstruct i596_private *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nprintk(KERN_WARNING "%s: transmit timed out, status resetting.\n", dev->name);\r\ndev->stats.tx_errors++;\r\nif (lp->last_restart == dev->stats.tx_packets) {\r\nprintk ("Resetting board.\n");\r\ni596_reset (dev, lp, ioaddr);\r\n} else {\r\nprintk ("Kicking board.\n");\r\nlp->scb.command = (CUC_START | RX_START);\r\nCA();\r\nlp->last_restart = dev->stats.tx_packets;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void print_eth(char *add)\r\n{\r\nint i;\r\nprintk ("Dest ");\r\nfor (i = 0; i < 6; i++)\r\nprintk(" %2.2X", (unsigned char) add[i]);\r\nprintk ("\n");\r\nprintk ("Source");\r\nfor (i = 0; i < 6; i++)\r\nprintk(" %2.2X", (unsigned char) add[i+6]);\r\nprintk ("\n");\r\nprintk ("type %2.2X%2.2X\n",\r\n(unsigned char) add[12], (unsigned char) add[13]);\r\n}\r\nstatic int __init lp486e_probe(struct net_device *dev) {\r\nstruct i596_private *lp;\r\nunsigned char eth_addr[6] = { 0, 0xaa, 0, 0, 0, 0 };\r\nunsigned char *bios;\r\nint i, j;\r\nint ret = -ENOMEM;\r\nstatic int probed;\r\nif (probed)\r\nreturn -ENODEV;\r\nprobed++;\r\nif (!request_region(IOADDR, LP486E_TOTAL_SIZE, DRV_NAME)) {\r\nprintk(KERN_ERR "lp486e: IO address 0x%x in use\n", IOADDR);\r\nreturn -EBUSY;\r\n}\r\nlp = netdev_priv(dev);\r\nspin_lock_init(&lp->cmd_lock);\r\nif (i596_scp_setup(dev)) {\r\nret = -ENODEV;\r\ngoto err_out_kfree;\r\n}\r\ndev->base_addr = IOADDR;\r\ndev->irq = IRQ;\r\nbios = bus_to_virt(0xe8000);\r\nfor (j = 0; j < 0x2000; j++) {\r\nif (bios[j] == 0 && bios[j+1] == 0xaa && bios[j+2] == 0) {\r\nprintk("%s: maybe address at BIOS 0x%x:",\r\ndev->name, 0xe8000+j);\r\nfor (i = 0; i < 6; i++) {\r\neth_addr[i] = bios[i+j];\r\nprintk(" %2.2X", eth_addr[i]);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nprintk("%s: lp486e 82596 at %#3lx, IRQ %d,",\r\ndev->name, dev->base_addr, dev->irq);\r\nfor (i = 0; i < 6; i++)\r\nprintk(" %2.2X", dev->dev_addr[i] = eth_addr[i]);\r\nprintk("\n");\r\ndev->netdev_ops = &i596_netdev_ops;\r\ndev->watchdog_timeo = 5*HZ;\r\n#if 0\r\ni596_port_do(dev, PORT_SELFTEST, "selftest");\r\ni596_port_do(dev, PORT_DUMP, "dump");\r\n#endif\r\nreturn 0;\r\nerr_out_kfree:\r\nrelease_region(IOADDR, LP486E_TOTAL_SIZE);\r\nreturn ret;\r\n}\r\nstatic inline void\r\ni596_handle_CU_completion(struct net_device *dev,\r\nstruct i596_private *lp,\r\nunsigned short status,\r\nunsigned short *ack_cmdp) {\r\nstruct i596_cmd *cmd;\r\nint frames_out = 0;\r\nint commands_done = 0;\r\nint cmd_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->cmd_lock, flags);\r\ncmd = lp->cmd_head;\r\nwhile (lp->cmd_head && (lp->cmd_head->status & CMD_STAT_C)) {\r\ncmd = lp->cmd_head;\r\nlp->cmd_head = pa_to_va(lp->cmd_head->pa_next);\r\nlp->cmd_backlog--;\r\ncommands_done++;\r\ncmd_val = cmd->command & 0x7;\r\n#if 0\r\nprintk("finished CU %s command (%d)\n",\r\nCUcmdnames[cmd_val], cmd_val);\r\n#endif\r\nswitch (cmd_val) {\r\ncase CmdTx:\r\n{\r\nstruct tx_cmd *tx_cmd;\r\nstruct i596_tbd *tx_cmd_tbd;\r\ntx_cmd = (struct tx_cmd *) cmd;\r\ntx_cmd_tbd = pa_to_va(tx_cmd->pa_tbd);\r\nframes_out++;\r\nif (cmd->status & CMD_STAT_OK) {\r\nif (i596_debug)\r\nprint_eth(pa_to_va(tx_cmd_tbd->pa_data));\r\n} else {\r\ndev->stats.tx_errors++;\r\nif (i596_debug)\r\nprintk("transmission failure:%04x\n",\r\ncmd->status);\r\nif (cmd->status & 0x0020)\r\ndev->stats.collisions++;\r\nif (!(cmd->status & 0x0040))\r\ndev->stats.tx_heartbeat_errors++;\r\nif (cmd->status & 0x0400)\r\ndev->stats.tx_carrier_errors++;\r\nif (cmd->status & 0x0800)\r\ndev->stats.collisions++;\r\nif (cmd->status & 0x1000)\r\ndev->stats.tx_aborted_errors++;\r\n}\r\ndev_kfree_skb_irq(tx_cmd_tbd->skb);\r\ncmd->pa_next = I596_NULL;\r\nkfree((unsigned char *)tx_cmd);\r\nnetif_wake_queue(dev);\r\nbreak;\r\n}\r\ncase CmdMulticastList:\r\ncmd->pa_next = I596_NULL;\r\nkfree((unsigned char *)cmd);\r\nbreak;\r\ncase CmdTDR:\r\n{\r\nunsigned long status = *((unsigned long *) (cmd + 1));\r\nif (status & 0x8000) {\r\nif (i596_debug)\r\nprintk("%s: link ok.\n", dev->name);\r\n} else {\r\nif (status & 0x4000)\r\nprintk("%s: Transceiver problem.\n",\r\ndev->name);\r\nif (status & 0x2000)\r\nprintk("%s: Termination problem.\n",\r\ndev->name);\r\nif (status & 0x1000)\r\nprintk("%s: Short circuit.\n",\r\ndev->name);\r\nprintk("%s: Time %ld.\n",\r\ndev->name, status & 0x07ff);\r\n}\r\n}\r\ndefault:\r\ncmd->pa_next = I596_NULL;\r\nlp->last_cmd = jiffies;\r\n}\r\nbarrier();\r\n}\r\ncmd = lp->cmd_head;\r\nwhile (cmd && (cmd != lp->cmd_tail)) {\r\ncmd->command &= 0x1fff;\r\ncmd = pa_to_va(cmd->pa_next);\r\nbarrier();\r\n}\r\nif (lp->cmd_head)\r\n*ack_cmdp |= CUC_START;\r\nlp->scb.pa_cmd = va_to_pa(lp->cmd_head);\r\nspin_unlock_irqrestore(&lp->cmd_lock, flags);\r\n}\r\nstatic irqreturn_t\r\ni596_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct i596_private *lp = netdev_priv(dev);\r\nunsigned short status, ack_cmd = 0;\r\nint frames_in = 0;\r\nif (lp->scb.command && i596_timeout(dev, "interrupt", 40))\r\n;\r\nstatus = lp->scb.status;\r\n#if 0\r\nif (i596_debug) {\r\nprintk("%s: i596 interrupt, ", dev->name);\r\ni596_out_status(status);\r\n}\r\n#endif\r\nif (status == 0xffff) {\r\nprintk("%s: i596_interrupt: got status 0xffff\n", dev->name);\r\ngoto out;\r\n}\r\nack_cmd = (status & STAT_ACK);\r\nif (status & (STAT_CX | STAT_CNA))\r\ni596_handle_CU_completion(dev, lp, status, &ack_cmd);\r\nif (status & (STAT_FR | STAT_RNR)) {\r\nif ((status & STAT_RNR) && netif_running(dev))\r\nack_cmd |= RX_START;\r\nif (status & STAT_FR) {\r\nframes_in = i596_rx(dev);\r\nif (!frames_in)\r\nprintk("receive frame reported, but no frames\n");\r\n}\r\n}\r\nif (lp->scb.command && i596_timeout(dev, "i596 interrupt", 100))\r\n;\r\nlp->scb.command = ack_cmd;\r\nCLEAR_INT();\r\nCA();\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i596_close(struct net_device *dev) {\r\nstruct i596_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nif (i596_debug)\r\nprintk("%s: Shutting down ethercard, status was %4.4x.\n",\r\ndev->name, lp->scb.status);\r\nlp->scb.command = (CUC_ABORT | RX_ABORT);\r\nCA();\r\ni596_cleanup_cmd(dev);\r\nif (lp->scb.command && i596_timeout(dev, "i596_close", 200))\r\n;\r\nfree_irq(dev->irq, dev);\r\nremove_rx_bufs(dev);\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev) {\r\nstruct i596_private *lp = netdev_priv(dev);\r\nstruct i596_cmd *cmd;\r\nif (i596_debug > 1)\r\nprintk ("%s: set multicast list %d\n",\r\ndev->name, netdev_mc_count(dev));\r\nif (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nchar *cp;\r\ncmd = kmalloc(sizeof(struct i596_cmd) + 2 +\r\nnetdev_mc_count(dev) * 6, GFP_ATOMIC);\r\nif (cmd == NULL) {\r\nprintk (KERN_ERR "%s: set_multicast Memory squeeze.\n", dev->name);\r\nreturn;\r\n}\r\ncmd->command = CmdMulticastList;\r\n*((unsigned short *) (cmd + 1)) = netdev_mc_count(dev) * 6;\r\ncp = ((char *)(cmd + 1))+2;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nmemcpy(cp, ha->addr, 6);\r\ncp += 6;\r\n}\r\nif (i596_debug & LOG_SRCDST)\r\nprint_eth (((char *)(cmd + 1)) + 2);\r\ni596_add_cmd(dev, cmd);\r\n} else {\r\nif (lp->set_conf.pa_next != I596_NULL) {\r\nreturn;\r\n}\r\nif (netdev_mc_empty(dev) &&\r\n!(dev->flags & (IFF_PROMISC | IFF_ALLMULTI))) {\r\nlp->i596_config[8] &= ~0x01;\r\n} else {\r\nlp->i596_config[8] |= 0x01;\r\n}\r\ni596_add_cmd(dev, &lp->set_conf);\r\n}\r\n}\r\nstatic int __init lp486e_init_module(void) {\r\nint err;\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct i596_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->irq = irq;\r\ndev->base_addr = io;\r\nerr = lp486e_probe(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\nrelease_region(dev->base_addr, LP486E_TOTAL_SIZE);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\ndev_lp486e = dev;\r\nfull_duplex = 0;\r\noptions = 0;\r\nreturn 0;\r\n}\r\nstatic void __exit lp486e_cleanup_module(void) {\r\nunregister_netdev(dev_lp486e);\r\nrelease_region(dev_lp486e->base_addr, LP486E_TOTAL_SIZE);\r\nfree_netdev(dev_lp486e);\r\n}
