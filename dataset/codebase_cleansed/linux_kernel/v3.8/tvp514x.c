static inline struct tvp514x_decoder *to_decoder(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tvp514x_decoder, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct tvp514x_decoder, hdl)->sd;\r\n}\r\nstatic int tvp514x_read_reg(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nint err, retry = 0;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nread_again:\r\nerr = i2c_smbus_read_byte_data(client, reg);\r\nif (err < 0) {\r\nif (retry <= I2C_RETRY_COUNT) {\r\nv4l2_warn(sd, "Read: retry ... %d\n", retry);\r\nretry++;\r\nmsleep_interruptible(10);\r\ngoto read_again;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void dump_reg(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nu32 val;\r\nval = tvp514x_read_reg(sd, reg);\r\nv4l2_info(sd, "Reg(0x%.2X): 0x%.2X\n", reg, val);\r\n}\r\nstatic int tvp514x_write_reg(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nint err, retry = 0;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nwrite_again:\r\nerr = i2c_smbus_write_byte_data(client, reg, val);\r\nif (err) {\r\nif (retry <= I2C_RETRY_COUNT) {\r\nv4l2_warn(sd, "Write: retry ... %d\n", retry);\r\nretry++;\r\nmsleep_interruptible(10);\r\ngoto write_again;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int tvp514x_write_regs(struct v4l2_subdev *sd,\r\nconst struct tvp514x_reg reglist[])\r\n{\r\nint err;\r\nconst struct tvp514x_reg *next = reglist;\r\nfor (; next->token != TOK_TERM; next++) {\r\nif (next->token == TOK_DELAY) {\r\nmsleep(next->val);\r\ncontinue;\r\n}\r\nif (next->token == TOK_SKIP)\r\ncontinue;\r\nerr = tvp514x_write_reg(sd, next->reg, (u8) next->val);\r\nif (err) {\r\nv4l2_err(sd, "Write failed. Err[%d]\n", err);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic enum tvp514x_std tvp514x_query_current_std(struct v4l2_subdev *sd)\r\n{\r\nu8 std, std_status;\r\nstd = tvp514x_read_reg(sd, REG_VIDEO_STD);\r\nif ((std & VIDEO_STD_MASK) == VIDEO_STD_AUTO_SWITCH_BIT)\r\nstd_status = tvp514x_read_reg(sd, REG_VIDEO_STD_STATUS);\r\nelse\r\nstd_status = std;\r\nswitch (std_status & VIDEO_STD_MASK) {\r\ncase VIDEO_STD_NTSC_MJ_BIT:\r\nreturn STD_NTSC_MJ;\r\ncase VIDEO_STD_PAL_BDGHIN_BIT:\r\nreturn STD_PAL_BDGHIN;\r\ndefault:\r\nreturn STD_INVALID;\r\n}\r\nreturn STD_INVALID;\r\n}\r\nstatic void tvp514x_reg_dump(struct v4l2_subdev *sd)\r\n{\r\ndump_reg(sd, REG_INPUT_SEL);\r\ndump_reg(sd, REG_AFE_GAIN_CTRL);\r\ndump_reg(sd, REG_VIDEO_STD);\r\ndump_reg(sd, REG_OPERATION_MODE);\r\ndump_reg(sd, REG_COLOR_KILLER);\r\ndump_reg(sd, REG_LUMA_CONTROL1);\r\ndump_reg(sd, REG_LUMA_CONTROL2);\r\ndump_reg(sd, REG_LUMA_CONTROL3);\r\ndump_reg(sd, REG_BRIGHTNESS);\r\ndump_reg(sd, REG_CONTRAST);\r\ndump_reg(sd, REG_SATURATION);\r\ndump_reg(sd, REG_HUE);\r\ndump_reg(sd, REG_CHROMA_CONTROL1);\r\ndump_reg(sd, REG_CHROMA_CONTROL2);\r\ndump_reg(sd, REG_COMP_PR_SATURATION);\r\ndump_reg(sd, REG_COMP_Y_CONTRAST);\r\ndump_reg(sd, REG_COMP_PB_SATURATION);\r\ndump_reg(sd, REG_COMP_Y_BRIGHTNESS);\r\ndump_reg(sd, REG_AVID_START_PIXEL_LSB);\r\ndump_reg(sd, REG_AVID_START_PIXEL_MSB);\r\ndump_reg(sd, REG_AVID_STOP_PIXEL_LSB);\r\ndump_reg(sd, REG_AVID_STOP_PIXEL_MSB);\r\ndump_reg(sd, REG_HSYNC_START_PIXEL_LSB);\r\ndump_reg(sd, REG_HSYNC_START_PIXEL_MSB);\r\ndump_reg(sd, REG_HSYNC_STOP_PIXEL_LSB);\r\ndump_reg(sd, REG_HSYNC_STOP_PIXEL_MSB);\r\ndump_reg(sd, REG_VSYNC_START_LINE_LSB);\r\ndump_reg(sd, REG_VSYNC_START_LINE_MSB);\r\ndump_reg(sd, REG_VSYNC_STOP_LINE_LSB);\r\ndump_reg(sd, REG_VSYNC_STOP_LINE_MSB);\r\ndump_reg(sd, REG_VBLK_START_LINE_LSB);\r\ndump_reg(sd, REG_VBLK_START_LINE_MSB);\r\ndump_reg(sd, REG_VBLK_STOP_LINE_LSB);\r\ndump_reg(sd, REG_VBLK_STOP_LINE_MSB);\r\ndump_reg(sd, REG_SYNC_CONTROL);\r\ndump_reg(sd, REG_OUTPUT_FORMATTER1);\r\ndump_reg(sd, REG_OUTPUT_FORMATTER2);\r\ndump_reg(sd, REG_OUTPUT_FORMATTER3);\r\ndump_reg(sd, REG_OUTPUT_FORMATTER4);\r\ndump_reg(sd, REG_OUTPUT_FORMATTER5);\r\ndump_reg(sd, REG_OUTPUT_FORMATTER6);\r\ndump_reg(sd, REG_CLEAR_LOST_LOCK);\r\n}\r\nstatic int tvp514x_configure(struct v4l2_subdev *sd,\r\nstruct tvp514x_decoder *decoder)\r\n{\r\nint err;\r\nerr =\r\ntvp514x_write_regs(sd, decoder->tvp514x_regs);\r\nif (err)\r\nreturn err;\r\nif (debug)\r\ntvp514x_reg_dump(sd);\r\nreturn 0;\r\n}\r\nstatic int tvp514x_detect(struct v4l2_subdev *sd,\r\nstruct tvp514x_decoder *decoder)\r\n{\r\nu8 chip_id_msb, chip_id_lsb, rom_ver;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nchip_id_msb = tvp514x_read_reg(sd, REG_CHIP_ID_MSB);\r\nchip_id_lsb = tvp514x_read_reg(sd, REG_CHIP_ID_LSB);\r\nrom_ver = tvp514x_read_reg(sd, REG_ROM_VERSION);\r\nv4l2_dbg(1, debug, sd,\r\n"chip id detected msb:0x%x lsb:0x%x rom version:0x%x\n",\r\nchip_id_msb, chip_id_lsb, rom_ver);\r\nif ((chip_id_msb != TVP514X_CHIP_ID_MSB)\r\n|| ((chip_id_lsb != TVP5146_CHIP_ID_LSB)\r\n&& (chip_id_lsb != TVP5147_CHIP_ID_LSB))) {\r\nv4l2_err(sd, "chip id mismatch msb:0x%x lsb:0x%x\n",\r\nchip_id_msb, chip_id_lsb);\r\nreturn -ENODEV;\r\n}\r\ndecoder->ver = rom_ver;\r\nv4l2_info(sd, "%s (Version - 0x%.2x) found at 0x%x (%s)\n",\r\nclient->name, decoder->ver,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\n}\r\nstatic int tvp514x_querystd(struct v4l2_subdev *sd, v4l2_std_id *std_id)\r\n{\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nenum tvp514x_std current_std;\r\nenum tvp514x_input input_sel;\r\nu8 sync_lock_status, lock_mask;\r\nif (std_id == NULL)\r\nreturn -EINVAL;\r\n*std_id = V4L2_STD_UNKNOWN;\r\nif (!decoder->streaming) {\r\ntvp514x_s_stream(sd, 1);\r\nmsleep(LOCK_RETRY_DELAY);\r\n}\r\ncurrent_std = tvp514x_query_current_std(sd);\r\nif (current_std == STD_INVALID)\r\nreturn 0;\r\ninput_sel = decoder->input;\r\nswitch (input_sel) {\r\ncase INPUT_CVBS_VI1A:\r\ncase INPUT_CVBS_VI1B:\r\ncase INPUT_CVBS_VI1C:\r\ncase INPUT_CVBS_VI2A:\r\ncase INPUT_CVBS_VI2B:\r\ncase INPUT_CVBS_VI2C:\r\ncase INPUT_CVBS_VI3A:\r\ncase INPUT_CVBS_VI3B:\r\ncase INPUT_CVBS_VI3C:\r\ncase INPUT_CVBS_VI4A:\r\nlock_mask = STATUS_CLR_SUBCAR_LOCK_BIT |\r\nSTATUS_HORZ_SYNC_LOCK_BIT |\r\nSTATUS_VIRT_SYNC_LOCK_BIT;\r\nbreak;\r\ncase INPUT_SVIDEO_VI2A_VI1A:\r\ncase INPUT_SVIDEO_VI2B_VI1B:\r\ncase INPUT_SVIDEO_VI2C_VI1C:\r\ncase INPUT_SVIDEO_VI2A_VI3A:\r\ncase INPUT_SVIDEO_VI2B_VI3B:\r\ncase INPUT_SVIDEO_VI2C_VI3C:\r\ncase INPUT_SVIDEO_VI4A_VI1A:\r\ncase INPUT_SVIDEO_VI4A_VI1B:\r\ncase INPUT_SVIDEO_VI4A_VI1C:\r\ncase INPUT_SVIDEO_VI4A_VI3A:\r\ncase INPUT_SVIDEO_VI4A_VI3B:\r\ncase INPUT_SVIDEO_VI4A_VI3C:\r\nlock_mask = STATUS_HORZ_SYNC_LOCK_BIT |\r\nSTATUS_VIRT_SYNC_LOCK_BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsync_lock_status = tvp514x_read_reg(sd, REG_STATUS1);\r\nif (lock_mask != (sync_lock_status & lock_mask))\r\nreturn 0;\r\n*std_id = decoder->std_list[current_std].standard.id;\r\nv4l2_dbg(1, debug, sd, "Current STD: %s\n",\r\ndecoder->std_list[current_std].standard.name);\r\nreturn 0;\r\n}\r\nstatic int tvp514x_s_std(struct v4l2_subdev *sd, v4l2_std_id std_id)\r\n{\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nint err, i;\r\nfor (i = 0; i < decoder->num_stds; i++)\r\nif (std_id & decoder->std_list[i].standard.id)\r\nbreak;\r\nif ((i == decoder->num_stds) || (i == STD_INVALID))\r\nreturn -EINVAL;\r\nerr = tvp514x_write_reg(sd, REG_VIDEO_STD,\r\ndecoder->std_list[i].video_std);\r\nif (err)\r\nreturn err;\r\ndecoder->current_std = i;\r\ndecoder->tvp514x_regs[REG_VIDEO_STD].val =\r\ndecoder->std_list[i].video_std;\r\nv4l2_dbg(1, debug, sd, "Standard set to: %s\n",\r\ndecoder->std_list[i].standard.name);\r\nreturn 0;\r\n}\r\nstatic int tvp514x_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nint err;\r\nenum tvp514x_input input_sel;\r\nenum tvp514x_output output_sel;\r\nif ((input >= INPUT_INVALID) ||\r\n(output >= OUTPUT_INVALID))\r\nreturn -EINVAL;\r\ninput_sel = input;\r\noutput_sel = output;\r\nerr = tvp514x_write_reg(sd, REG_INPUT_SEL, input_sel);\r\nif (err)\r\nreturn err;\r\noutput_sel |= tvp514x_read_reg(sd,\r\nREG_OUTPUT_FORMATTER1) & 0x7;\r\nerr = tvp514x_write_reg(sd, REG_OUTPUT_FORMATTER1,\r\noutput_sel);\r\nif (err)\r\nreturn err;\r\ndecoder->tvp514x_regs[REG_INPUT_SEL].val = input_sel;\r\ndecoder->tvp514x_regs[REG_OUTPUT_FORMATTER1].val = output_sel;\r\ndecoder->input = input;\r\ndecoder->output = output;\r\nv4l2_dbg(1, debug, sd, "Input set to: %d\n", input_sel);\r\nreturn 0;\r\n}\r\nstatic int tvp514x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nint err = -EINVAL, value;\r\nvalue = ctrl->val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nerr = tvp514x_write_reg(sd, REG_BRIGHTNESS, value);\r\nif (!err)\r\ndecoder->tvp514x_regs[REG_BRIGHTNESS].val = value;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nerr = tvp514x_write_reg(sd, REG_CONTRAST, value);\r\nif (!err)\r\ndecoder->tvp514x_regs[REG_CONTRAST].val = value;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nerr = tvp514x_write_reg(sd, REG_SATURATION, value);\r\nif (!err)\r\ndecoder->tvp514x_regs[REG_SATURATION].val = value;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nif (value == 180)\r\nvalue = 0x7F;\r\nelse if (value == -180)\r\nvalue = 0x80;\r\nerr = tvp514x_write_reg(sd, REG_HUE, value);\r\nif (!err)\r\ndecoder->tvp514x_regs[REG_HUE].val = value;\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nerr = tvp514x_write_reg(sd, REG_AFE_GAIN_CTRL, value ? 0x0f : 0x0c);\r\nif (!err)\r\ndecoder->tvp514x_regs[REG_AFE_GAIN_CTRL].val = value;\r\nbreak;\r\n}\r\nv4l2_dbg(1, debug, sd, "Set Control: ID - %d - %d\n",\r\nctrl->id, ctrl->val);\r\nreturn err;\r\n}\r\nstatic int\r\ntvp514x_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_YUYV10_2X10;\r\nreturn 0;\r\n}\r\nstatic int\r\ntvp514x_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nenum tvp514x_std current_std;\r\nif (f == NULL)\r\nreturn -EINVAL;\r\ncurrent_std = decoder->current_std;\r\nf->code = V4L2_MBUS_FMT_YUYV10_2X10;\r\nf->width = decoder->std_list[current_std].width;\r\nf->height = decoder->std_list[current_std].height;\r\nf->field = V4L2_FIELD_INTERLACED;\r\nf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nv4l2_dbg(1, debug, sd, "MBUS_FMT: Width - %d, Height - %d\n",\r\nf->width, f->height);\r\nreturn 0;\r\n}\r\nstatic int\r\ntvp514x_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)\r\n{\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nstruct v4l2_captureparm *cparm;\r\nenum tvp514x_std current_std;\r\nif (a == NULL)\r\nreturn -EINVAL;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncurrent_std = decoder->current_std;\r\ncparm = &a->parm.capture;\r\ncparm->capability = V4L2_CAP_TIMEPERFRAME;\r\ncparm->timeperframe =\r\ndecoder->std_list[current_std].standard.frameperiod;\r\nreturn 0;\r\n}\r\nstatic int\r\ntvp514x_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)\r\n{\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nstruct v4l2_fract *timeperframe;\r\nenum tvp514x_std current_std;\r\nif (a == NULL)\r\nreturn -EINVAL;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ntimeperframe = &a->parm.capture.timeperframe;\r\ncurrent_std = decoder->current_std;\r\n*timeperframe =\r\ndecoder->std_list[current_std].standard.frameperiod;\r\nreturn 0;\r\n}\r\nstatic int tvp514x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nint err = 0;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nif (decoder->streaming == enable)\r\nreturn 0;\r\nswitch (enable) {\r\ncase 0:\r\n{\r\nerr = tvp514x_write_reg(sd, REG_OPERATION_MODE, 0x01);\r\nif (err) {\r\nv4l2_err(sd, "Unable to turn off decoder\n");\r\nreturn err;\r\n}\r\ndecoder->streaming = enable;\r\nbreak;\r\n}\r\ncase 1:\r\n{\r\nstruct tvp514x_reg *int_seq = (struct tvp514x_reg *)\r\nclient->driver->id_table->driver_data;\r\nerr = tvp514x_write_regs(sd, int_seq);\r\nif (err) {\r\nv4l2_err(sd, "Unable to turn on decoder\n");\r\nreturn err;\r\n}\r\nerr = tvp514x_detect(sd, decoder);\r\nif (err) {\r\nv4l2_err(sd, "Unable to detect decoder\n");\r\nreturn err;\r\n}\r\nerr = tvp514x_configure(sd, decoder);\r\nif (err) {\r\nv4l2_err(sd, "Unable to configure decoder\n");\r\nreturn err;\r\n}\r\ndecoder->streaming = enable;\r\nbreak;\r\n}\r\ndefault:\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\ntvp514x_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct tvp514x_decoder *decoder;\r\nstruct v4l2_subdev *sd;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nif (!client->dev.platform_data) {\r\nv4l2_err(client, "No platform data!!\n");\r\nreturn -ENODEV;\r\n}\r\ndecoder = kzalloc(sizeof(*decoder), GFP_KERNEL);\r\nif (!decoder)\r\nreturn -ENOMEM;\r\n*decoder = tvp514x_dev;\r\nmemcpy(decoder->tvp514x_regs, tvp514x_reg_list_default,\r\nsizeof(tvp514x_reg_list_default));\r\ndecoder->pdata = client->dev.platform_data;\r\ndecoder->tvp514x_regs[REG_OUTPUT_FORMATTER2].val |=\r\n(decoder->pdata->clk_polarity << 1);\r\ndecoder->tvp514x_regs[REG_SYNC_CONTROL].val |=\r\n((decoder->pdata->hs_polarity << 2) |\r\n(decoder->pdata->vs_polarity << 3));\r\ndecoder->tvp514x_regs[REG_VIDEO_STD].val =\r\nVIDEO_STD_AUTO_SWITCH_BIT;\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &tvp514x_ops);\r\nv4l2_ctrl_handler_init(&decoder->hdl, 5);\r\nv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\r\nV4L2_CID_HUE, -180, 180, 180, 0);\r\nv4l2_ctrl_new_std(&decoder->hdl, &tvp514x_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nsd->ctrl_handler = &decoder->hdl;\r\nif (decoder->hdl.error) {\r\nint err = decoder->hdl.error;\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nkfree(decoder);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&decoder->hdl);\r\nv4l2_info(sd, "%s decoder driver registered !!\n", sd->name);\r\nreturn 0;\r\n}\r\nstatic int tvp514x_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct tvp514x_decoder *decoder = to_decoder(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nkfree(decoder);\r\nreturn 0;\r\n}
