static inline int read_lpstatus(struct qcam *q)\r\n{\r\nreturn parport_read_status(q->pport);\r\n}\r\nstatic inline int read_lpdata(struct qcam *q)\r\n{\r\nreturn parport_read_data(q->pport);\r\n}\r\nstatic inline void write_lpdata(struct qcam *q, int d)\r\n{\r\nparport_write_data(q->pport, d);\r\n}\r\nstatic void write_lpcontrol(struct qcam *q, int d)\r\n{\r\nif (d & 0x20) {\r\nparport_data_reverse(q->pport);\r\n} else {\r\nparport_data_forward(q->pport);\r\n}\r\nd &= ~0x20;\r\nparport_write_control(q->pport, d);\r\n}\r\nstatic int qc_waithand(struct qcam *q, int val)\r\n{\r\nint status;\r\nint runs = 0;\r\nif (val) {\r\nwhile (!((status = read_lpstatus(q)) & 8)) {\r\nif (runs++ > maxpoll)\r\nmsleep_interruptible(5);\r\nif (runs > (maxpoll + 1000))\r\nreturn -1;\r\n}\r\n} else {\r\nwhile (((status = read_lpstatus(q)) & 8)) {\r\nif (runs++ > maxpoll)\r\nmsleep_interruptible(5);\r\nif (runs++ > (maxpoll + 1000))\r\nreturn -1;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic unsigned int qc_waithand2(struct qcam *q, int val)\r\n{\r\nunsigned int status;\r\nint runs = 0;\r\ndo {\r\nstatus = read_lpdata(q);\r\nif (runs++ > maxpoll)\r\nmsleep_interruptible(5);\r\nif (runs++ > (maxpoll + 1000))\r\nreturn 0;\r\n} while ((status & 1) != val);\r\nreturn status;\r\n}\r\nstatic int qc_command(struct qcam *q, int command)\r\n{\r\nint n1, n2;\r\nint cmd;\r\nwrite_lpdata(q, command);\r\nwrite_lpcontrol(q, 6);\r\nn1 = qc_waithand(q, 1);\r\nwrite_lpcontrol(q, 0xe);\r\nn2 = qc_waithand(q, 0);\r\ncmd = (n1 & 0xf0) | ((n2 & 0xf0) >> 4);\r\nreturn cmd;\r\n}\r\nstatic int qc_readparam(struct qcam *q)\r\n{\r\nint n1, n2;\r\nint cmd;\r\nwrite_lpcontrol(q, 6);\r\nn1 = qc_waithand(q, 1);\r\nwrite_lpcontrol(q, 0xe);\r\nn2 = qc_waithand(q, 0);\r\ncmd = (n1 & 0xf0) | ((n2 & 0xf0) >> 4);\r\nreturn cmd;\r\n}\r\nstatic int qc_detect(struct qcam *q)\r\n{\r\nint reg, lastreg;\r\nint count = 0;\r\nint i;\r\nif (force_init)\r\nreturn 1;\r\nlastreg = reg = read_lpstatus(q) & 0xf0;\r\nfor (i = 0; i < 500; i++) {\r\nreg = read_lpstatus(q) & 0xf0;\r\nif (reg != lastreg)\r\ncount++;\r\nlastreg = reg;\r\nmdelay(2);\r\n}\r\n#if 0\r\nprintk(KERN_DEBUG "Debugging: QCam detection counter <30-200 counts as detected>: %d\n", count);\r\nreturn 1;\r\n#endif\r\nif (count > 20 && count < 400) {\r\nreturn 1;\r\n} else {\r\nprintk(KERN_ERR "No Quickcam found on port %s\n",\r\nq->pport->name);\r\nprintk(KERN_DEBUG "Quickcam detection counter: %u\n", count);\r\nreturn 0;\r\n}\r\n}\r\nstatic int qc_setscanmode(struct qcam *q)\r\n{\r\nint old_mode = q->mode;\r\nswitch (q->transfer_scale) {\r\ncase 1:\r\nq->mode = 0;\r\nbreak;\r\ncase 2:\r\nq->mode = 4;\r\nbreak;\r\ncase 4:\r\nq->mode = 8;\r\nbreak;\r\n}\r\nswitch (q->bpp) {\r\ncase 4:\r\nbreak;\r\ncase 6:\r\nq->mode += 2;\r\nbreak;\r\n}\r\nswitch (q->port_mode & QC_MODE_MASK) {\r\ncase QC_BIDIR:\r\nq->mode += 1;\r\nbreak;\r\ncase QC_NOTSET:\r\ncase QC_UNIDIR:\r\nbreak;\r\n}\r\nif (q->mode != old_mode)\r\nq->status |= QC_PARAM_CHANGE;\r\nreturn 0;\r\n}\r\nstatic void qc_reset(struct qcam *q)\r\n{\r\nswitch (q->port_mode & QC_FORCE_MASK) {\r\ncase QC_FORCE_UNIDIR:\r\nq->port_mode = (q->port_mode & ~QC_MODE_MASK) | QC_UNIDIR;\r\nbreak;\r\ncase QC_FORCE_BIDIR:\r\nq->port_mode = (q->port_mode & ~QC_MODE_MASK) | QC_BIDIR;\r\nbreak;\r\ncase QC_ANY:\r\nwrite_lpcontrol(q, 0x20);\r\nwrite_lpdata(q, 0x75);\r\nif (read_lpdata(q) != 0x75)\r\nq->port_mode = (q->port_mode & ~QC_MODE_MASK) | QC_BIDIR;\r\nelse\r\nq->port_mode = (q->port_mode & ~QC_MODE_MASK) | QC_UNIDIR;\r\nbreak;\r\n}\r\nwrite_lpcontrol(q, 0xb);\r\nudelay(250);\r\nwrite_lpcontrol(q, 0xe);\r\nqc_setscanmode(q);\r\n}\r\nstatic void qc_set(struct qcam *q)\r\n{\r\nint val;\r\nint val2;\r\nqc_reset(q);\r\nqc_command(q, 0xb);\r\nqc_command(q, q->brightness);\r\nval = q->height / q->transfer_scale;\r\nqc_command(q, 0x11);\r\nqc_command(q, val);\r\nif ((q->port_mode & QC_MODE_MASK) == QC_UNIDIR && q->bpp == 6) {\r\nval = q->width;\r\nval2 = q->transfer_scale * 4;\r\n} else {\r\nval = q->width * q->bpp;\r\nval2 = (((q->port_mode & QC_MODE_MASK) == QC_BIDIR) ? 24 : 8) *\r\nq->transfer_scale;\r\n}\r\nval = DIV_ROUND_UP(val, val2);\r\nqc_command(q, 0x13);\r\nqc_command(q, val);\r\nqc_command(q, 0xd);\r\nqc_command(q, q->top);\r\nqc_command(q, 0xf);\r\nqc_command(q, q->left / 2);\r\nqc_command(q, 0x19);\r\nqc_command(q, q->contrast);\r\nqc_command(q, 0x1f);\r\nqc_command(q, q->whitebal);\r\nq->status &= (~QC_PARAM_CHANGE);\r\n}\r\nstatic inline int qc_readbytes(struct qcam *q, char buffer[])\r\n{\r\nint ret = 1;\r\nunsigned int hi, lo;\r\nunsigned int hi2, lo2;\r\nstatic int state;\r\nif (buffer == NULL) {\r\nstate = 0;\r\nreturn 0;\r\n}\r\nswitch (q->port_mode & QC_MODE_MASK) {\r\ncase QC_BIDIR:\r\nwrite_lpcontrol(q, 0x26);\r\nlo = (qc_waithand2(q, 1) >> 1);\r\nhi = (read_lpstatus(q) >> 3) & 0x1f;\r\nwrite_lpcontrol(q, 0x2e);\r\nlo2 = (qc_waithand2(q, 0) >> 1);\r\nhi2 = (read_lpstatus(q) >> 3) & 0x1f;\r\nswitch (q->bpp) {\r\ncase 4:\r\nbuffer[0] = lo & 0xf;\r\nbuffer[1] = ((lo & 0x70) >> 4) | ((hi & 1) << 3);\r\nbuffer[2] = (hi & 0x1e) >> 1;\r\nbuffer[3] = lo2 & 0xf;\r\nbuffer[4] = ((lo2 & 0x70) >> 4) | ((hi2 & 1) << 3);\r\nbuffer[5] = (hi2 & 0x1e) >> 1;\r\nret = 6;\r\nbreak;\r\ncase 6:\r\nbuffer[0] = lo & 0x3f;\r\nbuffer[1] = ((lo & 0x40) >> 6) | (hi << 1);\r\nbuffer[2] = lo2 & 0x3f;\r\nbuffer[3] = ((lo2 & 0x40) >> 6) | (hi2 << 1);\r\nret = 4;\r\nbreak;\r\n}\r\nbreak;\r\ncase QC_UNIDIR:\r\nwrite_lpcontrol(q, 6);\r\nlo = (qc_waithand(q, 1) & 0xf0) >> 4;\r\nwrite_lpcontrol(q, 0xe);\r\nhi = (qc_waithand(q, 0) & 0xf0) >> 4;\r\nswitch (q->bpp) {\r\ncase 4:\r\nbuffer[0] = lo;\r\nbuffer[1] = hi;\r\nret = 2;\r\nbreak;\r\ncase 6:\r\nswitch (state) {\r\ncase 0:\r\nbuffer[0] = (lo << 2) | ((hi & 0xc) >> 2);\r\nq->saved_bits = (hi & 3) << 4;\r\nstate = 1;\r\nret = 1;\r\nbreak;\r\ncase 1:\r\nbuffer[0] = lo | q->saved_bits;\r\nq->saved_bits = hi << 2;\r\nstate = 2;\r\nret = 1;\r\nbreak;\r\ncase 2:\r\nbuffer[0] = ((lo & 0xc) >> 2) | q->saved_bits;\r\nbuffer[1] = ((lo & 3) << 4) | hi;\r\nstate = 0;\r\nret = 2;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic long qc_capture(struct qcam *q, char __user *buf, unsigned long len)\r\n{\r\nint i, j, k, yield;\r\nint bytes;\r\nint linestotrans, transperline;\r\nint divisor;\r\nint pixels_per_line;\r\nint pixels_read = 0;\r\nint got = 0;\r\nchar buffer[6];\r\nint shift = 8 - q->bpp;\r\nchar invert;\r\nif (q->mode == -1)\r\nreturn -ENXIO;\r\nqc_command(q, 0x7);\r\nqc_command(q, q->mode);\r\nif ((q->port_mode & QC_MODE_MASK) == QC_BIDIR) {\r\nwrite_lpcontrol(q, 0x2e);\r\nwrite_lpcontrol(q, 0x26);\r\nqc_waithand(q, 1);\r\nwrite_lpcontrol(q, 0x2e);\r\nqc_waithand(q, 0);\r\n}\r\ninvert = (q->bpp == 4) ? 16 : 63;\r\nlinestotrans = q->height / q->transfer_scale;\r\npixels_per_line = q->width / q->transfer_scale;\r\ntransperline = q->width * q->bpp;\r\ndivisor = (((q->port_mode & QC_MODE_MASK) == QC_BIDIR) ? 24 : 8) *\r\nq->transfer_scale;\r\ntransperline = DIV_ROUND_UP(transperline, divisor);\r\nfor (i = 0, yield = yieldlines; i < linestotrans; i++) {\r\nfor (pixels_read = j = 0; j < transperline; j++) {\r\nbytes = qc_readbytes(q, buffer);\r\nfor (k = 0; k < bytes && (pixels_read + k) < pixels_per_line; k++) {\r\nint o;\r\nif (buffer[k] == 0 && invert == 16) {\r\nbuffer[k] = 16;\r\n}\r\no = i * pixels_per_line + pixels_read + k;\r\nif (o < len) {\r\nu8 ch = invert - buffer[k];\r\ngot++;\r\nput_user(ch << shift, buf + o);\r\n}\r\n}\r\npixels_read += bytes;\r\n}\r\nqc_readbytes(q, NULL);\r\nif (i >= yield) {\r\nmsleep_interruptible(5);\r\nyield = i + yieldlines;\r\n}\r\n}\r\nif ((q->port_mode & QC_MODE_MASK) == QC_BIDIR) {\r\nwrite_lpcontrol(q, 2);\r\nwrite_lpcontrol(q, 6);\r\nudelay(3);\r\nwrite_lpcontrol(q, 0xe);\r\n}\r\nif (got < len)\r\nreturn got;\r\nreturn len;\r\n}\r\nstatic int qcam_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nstrlcpy(vcap->driver, qcam->v4l2_dev.name, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, "Connectix B&W Quickcam", sizeof(vcap->card));\r\nstrlcpy(vcap->bus_info, qcam->pport->name, sizeof(vcap->bus_info));\r\nvcap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE;\r\nvcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int qcam_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nif (vin->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(vin->name, "Camera", sizeof(vin->name));\r\nvin->type = V4L2_INPUT_TYPE_CAMERA;\r\nvin->audioset = 0;\r\nvin->tuner = 0;\r\nvin->std = 0;\r\nvin->status = 0;\r\nreturn 0;\r\n}\r\nstatic int qcam_g_input(struct file *file, void *fh, unsigned int *inp)\r\n{\r\n*inp = 0;\r\nreturn 0;\r\n}\r\nstatic int qcam_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nreturn (inp > 0) ? -EINVAL : 0;\r\n}\r\nstatic int qcam_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\npix->width = qcam->width / qcam->transfer_scale;\r\npix->height = qcam->height / qcam->transfer_scale;\r\npix->pixelformat = (qcam->bpp == 4) ? V4L2_PIX_FMT_Y4 : V4L2_PIX_FMT_Y6;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = pix->width;\r\npix->sizeimage = pix->width * pix->height;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int qcam_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nif (pix->height <= 60 || pix->width <= 80) {\r\npix->height = 60;\r\npix->width = 80;\r\n} else if (pix->height <= 120 || pix->width <= 160) {\r\npix->height = 120;\r\npix->width = 160;\r\n} else {\r\npix->height = 240;\r\npix->width = 320;\r\n}\r\nif (pix->pixelformat != V4L2_PIX_FMT_Y4 &&\r\npix->pixelformat != V4L2_PIX_FMT_Y6)\r\npix->pixelformat = V4L2_PIX_FMT_Y4;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = pix->width;\r\npix->sizeimage = pix->width * pix->height;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int qcam_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nint ret = qcam_try_fmt_vid_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nqcam->width = 320;\r\nqcam->height = 240;\r\nif (pix->height == 60)\r\nqcam->transfer_scale = 4;\r\nelse if (pix->height == 120)\r\nqcam->transfer_scale = 2;\r\nelse\r\nqcam->transfer_scale = 1;\r\nif (pix->pixelformat == V4L2_PIX_FMT_Y6)\r\nqcam->bpp = 6;\r\nelse\r\nqcam->bpp = 4;\r\nmutex_lock(&qcam->lock);\r\nqc_setscanmode(qcam);\r\nqcam->status |= QC_PARAM_CHANGE;\r\nmutex_unlock(&qcam->lock);\r\nreturn 0;\r\n}\r\nstatic int qcam_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic struct v4l2_fmtdesc formats[] = {\r\n{ 0, 0, 0,\r\n"4-Bit Monochrome", V4L2_PIX_FMT_Y4,\r\n{ 0, 0, 0, 0 }\r\n},\r\n{ 1, 0, 0,\r\n"6-Bit Monochrome", V4L2_PIX_FMT_Y6,\r\n{ 0, 0, 0, 0 }\r\n},\r\n};\r\nenum v4l2_buf_type type = fmt->type;\r\nif (fmt->index > 1)\r\nreturn -EINVAL;\r\n*fmt = formats[fmt->index];\r\nfmt->type = type;\r\nreturn 0;\r\n}\r\nstatic int qcam_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstatic const struct v4l2_frmsize_discrete sizes[] = {\r\n{ 80, 60 },\r\n{ 160, 120 },\r\n{ 320, 240 },\r\n};\r\nif (fsize->index > 2)\r\nreturn -EINVAL;\r\nif (fsize->pixel_format != V4L2_PIX_FMT_Y4 &&\r\nfsize->pixel_format != V4L2_PIX_FMT_Y6)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete = sizes[fsize->index];\r\nreturn 0;\r\n}\r\nstatic ssize_t qcam_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct qcam *qcam = video_drvdata(file);\r\nint len;\r\nparport_claim_or_block(qcam->pdev);\r\nmutex_lock(&qcam->lock);\r\nqc_reset(qcam);\r\nif (qcam->status & QC_PARAM_CHANGE)\r\nqc_set(qcam);\r\nlen = qc_capture(qcam, buf, count);\r\nmutex_unlock(&qcam->lock);\r\nparport_release(qcam->pdev);\r\nreturn len;\r\n}\r\nstatic unsigned int qcam_poll(struct file *filp, poll_table *wait)\r\n{\r\nreturn v4l2_ctrl_poll(filp, wait) | POLLIN | POLLRDNORM;\r\n}\r\nstatic int qcam_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct qcam *qcam =\r\ncontainer_of(ctrl->handler, struct qcam, hdl);\r\nint ret = 0;\r\nmutex_lock(&qcam->lock);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nqcam->brightness = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nqcam->contrast = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_GAMMA:\r\nqcam->whitebal = ctrl->val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0) {\r\nqc_setscanmode(qcam);\r\nqcam->status |= QC_PARAM_CHANGE;\r\n}\r\nmutex_unlock(&qcam->lock);\r\nreturn ret;\r\n}\r\nstatic struct qcam *qcam_init(struct parport *port)\r\n{\r\nstruct qcam *qcam;\r\nstruct v4l2_device *v4l2_dev;\r\nqcam = kzalloc(sizeof(struct qcam), GFP_KERNEL);\r\nif (qcam == NULL)\r\nreturn NULL;\r\nv4l2_dev = &qcam->v4l2_dev;\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name), "bw-qcam%d", num_cams);\r\nif (v4l2_device_register(port->dev, v4l2_dev) < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nkfree(qcam);\r\nreturn NULL;\r\n}\r\nv4l2_ctrl_handler_init(&qcam->hdl, 3);\r\nv4l2_ctrl_new_std(&qcam->hdl, &qcam_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 180);\r\nv4l2_ctrl_new_std(&qcam->hdl, &qcam_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 192);\r\nv4l2_ctrl_new_std(&qcam->hdl, &qcam_ctrl_ops,\r\nV4L2_CID_GAMMA, 0, 255, 1, 105);\r\nif (qcam->hdl.error) {\r\nv4l2_err(v4l2_dev, "couldn't register controls\n");\r\nv4l2_ctrl_handler_free(&qcam->hdl);\r\nkfree(qcam);\r\nreturn NULL;\r\n}\r\nqcam->pport = port;\r\nqcam->pdev = parport_register_device(port, v4l2_dev->name, NULL, NULL,\r\nNULL, 0, NULL);\r\nif (qcam->pdev == NULL) {\r\nv4l2_err(v4l2_dev, "couldn't register for %s.\n", port->name);\r\nv4l2_ctrl_handler_free(&qcam->hdl);\r\nkfree(qcam);\r\nreturn NULL;\r\n}\r\nstrlcpy(qcam->vdev.name, "Connectix QuickCam", sizeof(qcam->vdev.name));\r\nqcam->vdev.v4l2_dev = v4l2_dev;\r\nqcam->vdev.ctrl_handler = &qcam->hdl;\r\nqcam->vdev.fops = &qcam_fops;\r\nqcam->vdev.ioctl_ops = &qcam_ioctl_ops;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &qcam->vdev.flags);\r\nqcam->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&qcam->vdev, qcam);\r\nmutex_init(&qcam->lock);\r\nqcam->port_mode = (QC_ANY | QC_NOTSET);\r\nqcam->width = 320;\r\nqcam->height = 240;\r\nqcam->bpp = 4;\r\nqcam->transfer_scale = 2;\r\nqcam->contrast = 192;\r\nqcam->brightness = 180;\r\nqcam->whitebal = 105;\r\nqcam->top = 1;\r\nqcam->left = 14;\r\nqcam->mode = -1;\r\nqcam->status = QC_PARAM_CHANGE;\r\nreturn qcam;\r\n}\r\nstatic int qc_calibrate(struct qcam *q)\r\n{\r\nint value;\r\nint count = 0;\r\nqc_command(q, 27);\r\nqc_command(q, 0);\r\ndo {\r\nqc_command(q, 33);\r\nvalue = qc_readparam(q);\r\nmdelay(1);\r\nschedule();\r\ncount++;\r\n} while (value == 0xff && count < 2048);\r\nq->whitebal = value;\r\nreturn value;\r\n}\r\nstatic int init_bwqcam(struct parport *port)\r\n{\r\nstruct qcam *qcam;\r\nif (num_cams == MAX_CAMS) {\r\nprintk(KERN_ERR "Too many Quickcams (max %d)\n", MAX_CAMS);\r\nreturn -ENOSPC;\r\n}\r\nqcam = qcam_init(port);\r\nif (qcam == NULL)\r\nreturn -ENODEV;\r\nparport_claim_or_block(qcam->pdev);\r\nqc_reset(qcam);\r\nif (qc_detect(qcam) == 0) {\r\nparport_release(qcam->pdev);\r\nparport_unregister_device(qcam->pdev);\r\nkfree(qcam);\r\nreturn -ENODEV;\r\n}\r\nqc_calibrate(qcam);\r\nv4l2_ctrl_handler_setup(&qcam->hdl);\r\nparport_release(qcam->pdev);\r\nv4l2_info(&qcam->v4l2_dev, "Connectix Quickcam on %s\n", qcam->pport->name);\r\nif (video_register_device(&qcam->vdev, VFL_TYPE_GRABBER, video_nr) < 0) {\r\nparport_unregister_device(qcam->pdev);\r\nkfree(qcam);\r\nreturn -ENODEV;\r\n}\r\nqcams[num_cams++] = qcam;\r\nreturn 0;\r\n}\r\nstatic void close_bwqcam(struct qcam *qcam)\r\n{\r\nvideo_unregister_device(&qcam->vdev);\r\nv4l2_ctrl_handler_free(&qcam->hdl);\r\nparport_unregister_device(qcam->pdev);\r\nkfree(qcam);\r\n}\r\nstatic int accept_bwqcam(struct parport *port)\r\n{\r\n#ifdef MODULE\r\nint n;\r\nif (parport[0] && strncmp(parport[0], "auto", 4) != 0) {\r\nfor (n = 0; n < MAX_CAMS && parport[n]; n++) {\r\nchar *ep;\r\nunsigned long r;\r\nr = simple_strtoul(parport[n], &ep, 0);\r\nif (ep == parport[n]) {\r\nprintk(KERN_ERR\r\n"bw-qcam: bad port specifier \"%s\"\n",\r\nparport[n]);\r\ncontinue;\r\n}\r\nif (r == port->number)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void bwqcam_attach(struct parport *port)\r\n{\r\nif (accept_bwqcam(port))\r\ninit_bwqcam(port);\r\n}\r\nstatic void bwqcam_detach(struct parport *port)\r\n{\r\nint i;\r\nfor (i = 0; i < num_cams; i++) {\r\nstruct qcam *qcam = qcams[i];\r\nif (qcam && qcam->pdev->port == port) {\r\nqcams[i] = NULL;\r\nclose_bwqcam(qcam);\r\n}\r\n}\r\n}\r\nstatic void __exit exit_bw_qcams(void)\r\n{\r\nparport_unregister_driver(&bwqcam_driver);\r\n}\r\nstatic int __init init_bw_qcams(void)\r\n{\r\n#ifdef MODULE\r\nif (maxpoll > 5000) {\r\nprintk(KERN_INFO "Connectix Quickcam max-poll was above 5000. Using 5000.\n");\r\nmaxpoll = 5000;\r\n}\r\nif (yieldlines < 1) {\r\nprintk(KERN_INFO "Connectix Quickcam yieldlines was less than 1. Using 1.\n");\r\nyieldlines = 1;\r\n}\r\n#endif\r\nreturn parport_register_driver(&bwqcam_driver);\r\n}
