static inline void bt3c_address(unsigned int iobase, unsigned short addr)\r\n{\r\noutb(addr & 0xff, iobase + ADDR_L);\r\noutb((addr >> 8) & 0xff, iobase + ADDR_H);\r\n}\r\nstatic inline void bt3c_put(unsigned int iobase, unsigned short value)\r\n{\r\noutb(value & 0xff, iobase + DATA_L);\r\noutb((value >> 8) & 0xff, iobase + DATA_H);\r\n}\r\nstatic inline void bt3c_io_write(unsigned int iobase, unsigned short addr, unsigned short value)\r\n{\r\nbt3c_address(iobase, addr);\r\nbt3c_put(iobase, value);\r\n}\r\nstatic inline unsigned short bt3c_get(unsigned int iobase)\r\n{\r\nunsigned short value = inb(iobase + DATA_L);\r\nvalue |= inb(iobase + DATA_H) << 8;\r\nreturn value;\r\n}\r\nstatic inline unsigned short bt3c_read(unsigned int iobase, unsigned short addr)\r\n{\r\nbt3c_address(iobase, addr);\r\nreturn bt3c_get(iobase);\r\n}\r\nstatic int bt3c_write(unsigned int iobase, int fifo_size, __u8 *buf, int len)\r\n{\r\nint actual = 0;\r\nbt3c_address(iobase, 0x7080);\r\nwhile (actual < len) {\r\nbt3c_put(iobase, buf[actual]);\r\nactual++;\r\n}\r\nbt3c_io_write(iobase, 0x7005, actual);\r\nreturn actual;\r\n}\r\nstatic void bt3c_write_wakeup(bt3c_info_t *info)\r\n{\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\nif (test_and_set_bit(XMIT_SENDING, &(info->tx_state)))\r\nreturn;\r\ndo {\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nregister struct sk_buff *skb;\r\nint len;\r\nif (!pcmcia_dev_present(info->p_dev))\r\nbreak;\r\nif (!(skb = skb_dequeue(&(info->txq)))) {\r\nclear_bit(XMIT_SENDING, &(info->tx_state));\r\nbreak;\r\n}\r\nlen = bt3c_write(iobase, 256, skb->data, skb->len);\r\nif (len != skb->len) {\r\nBT_ERR("Very strange");\r\n}\r\nkfree_skb(skb);\r\ninfo->hdev->stat.byte_tx += len;\r\n} while (0);\r\n}\r\nstatic void bt3c_receive(bt3c_info_t *info)\r\n{\r\nunsigned int iobase;\r\nint size = 0, avail;\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\niobase = info->p_dev->resource[0]->start;\r\navail = bt3c_read(iobase, 0x7006);\r\nbt3c_address(iobase, 0x7480);\r\nwhile (size < avail) {\r\nsize++;\r\ninfo->hdev->stat.byte_rx++;\r\nif (info->rx_skb == NULL) {\r\ninfo->rx_state = RECV_WAIT_PACKET_TYPE;\r\ninfo->rx_count = 0;\r\nif (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nreturn;\r\n}\r\n}\r\nif (info->rx_state == RECV_WAIT_PACKET_TYPE) {\r\ninfo->rx_skb->dev = (void *) info->hdev;\r\nbt_cb(info->rx_skb)->pkt_type = inb(iobase + DATA_L);\r\ninb(iobase + DATA_H);\r\nswitch (bt_cb(info->rx_skb)->pkt_type) {\r\ncase HCI_EVENT_PKT:\r\ninfo->rx_state = RECV_WAIT_EVENT_HEADER;\r\ninfo->rx_count = HCI_EVENT_HDR_SIZE;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\ninfo->rx_state = RECV_WAIT_ACL_HEADER;\r\ninfo->rx_count = HCI_ACL_HDR_SIZE;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\ninfo->rx_state = RECV_WAIT_SCO_HEADER;\r\ninfo->rx_count = HCI_SCO_HDR_SIZE;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown HCI packet with type 0x%02x received", bt_cb(info->rx_skb)->pkt_type);\r\ninfo->hdev->stat.err_rx++;\r\nclear_bit(HCI_RUNNING, &(info->hdev->flags));\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n} else {\r\n__u8 x = inb(iobase + DATA_L);\r\n*skb_put(info->rx_skb, 1) = x;\r\ninb(iobase + DATA_H);\r\ninfo->rx_count--;\r\nif (info->rx_count == 0) {\r\nint dlen;\r\nstruct hci_event_hdr *eh;\r\nstruct hci_acl_hdr *ah;\r\nstruct hci_sco_hdr *sh;\r\nswitch (info->rx_state) {\r\ncase RECV_WAIT_EVENT_HEADER:\r\neh = hci_event_hdr(info->rx_skb);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = eh->plen;\r\nbreak;\r\ncase RECV_WAIT_ACL_HEADER:\r\nah = hci_acl_hdr(info->rx_skb);\r\ndlen = __le16_to_cpu(ah->dlen);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = dlen;\r\nbreak;\r\ncase RECV_WAIT_SCO_HEADER:\r\nsh = hci_sco_hdr(info->rx_skb);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = sh->dlen;\r\nbreak;\r\ncase RECV_WAIT_DATA:\r\nhci_recv_frame(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nbt3c_io_write(iobase, 0x7006, 0x0000);\r\n}\r\nstatic irqreturn_t bt3c_interrupt(int irq, void *dev_inst)\r\n{\r\nbt3c_info_t *info = dev_inst;\r\nunsigned int iobase;\r\nint iir;\r\nirqreturn_t r = IRQ_NONE;\r\nif (!info || !info->hdev)\r\nreturn IRQ_NONE;\r\niobase = info->p_dev->resource[0]->start;\r\nspin_lock(&(info->lock));\r\niir = inb(iobase + CONTROL);\r\nif (iir & 0x80) {\r\nint stat = bt3c_read(iobase, 0x7001);\r\nif ((stat & 0xff) == 0x7f) {\r\nBT_ERR("Very strange (stat=0x%04x)", stat);\r\n} else if ((stat & 0xff) != 0xff) {\r\nif (stat & 0x0020) {\r\nint status = bt3c_read(iobase, 0x7002) & 0x10;\r\nBT_INFO("%s: Antenna %s", info->hdev->name,\r\nstatus ? "out" : "in");\r\n}\r\nif (stat & 0x0001)\r\nbt3c_receive(info);\r\nif (stat & 0x0002) {\r\nclear_bit(XMIT_SENDING, &(info->tx_state));\r\nbt3c_write_wakeup(info);\r\n}\r\nbt3c_io_write(iobase, 0x7001, 0x0000);\r\noutb(iir, iobase + CONTROL);\r\n}\r\nr = IRQ_HANDLED;\r\n}\r\nspin_unlock(&(info->lock));\r\nreturn r;\r\n}\r\nstatic int bt3c_hci_flush(struct hci_dev *hdev)\r\n{\r\nbt3c_info_t *info = hci_get_drvdata(hdev);\r\nskb_queue_purge(&(info->txq));\r\nreturn 0;\r\n}\r\nstatic int bt3c_hci_open(struct hci_dev *hdev)\r\n{\r\nset_bit(HCI_RUNNING, &(hdev->flags));\r\nreturn 0;\r\n}\r\nstatic int bt3c_hci_close(struct hci_dev *hdev)\r\n{\r\nif (!test_and_clear_bit(HCI_RUNNING, &(hdev->flags)))\r\nreturn 0;\r\nbt3c_hci_flush(hdev);\r\nreturn 0;\r\n}\r\nstatic int bt3c_hci_send_frame(struct sk_buff *skb)\r\n{\r\nbt3c_info_t *info;\r\nstruct hci_dev *hdev = (struct hci_dev *)(skb->dev);\r\nunsigned long flags;\r\nif (!hdev) {\r\nBT_ERR("Frame for unknown HCI device (hdev=NULL)");\r\nreturn -ENODEV;\r\n}\r\ninfo = hci_get_drvdata(hdev);\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n};\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&(info->txq), skb);\r\nspin_lock_irqsave(&(info->lock), flags);\r\nbt3c_write_wakeup(info);\r\nspin_unlock_irqrestore(&(info->lock), flags);\r\nreturn 0;\r\n}\r\nstatic int bt3c_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int bt3c_load_firmware(bt3c_info_t *info, const unsigned char *firmware,\r\nint count)\r\n{\r\nchar *ptr = (char *) firmware;\r\nchar b[9];\r\nunsigned int iobase, size, addr, fcs, tmp;\r\nint i, err = 0;\r\niobase = info->p_dev->resource[0]->start;\r\nbt3c_io_write(iobase, 0x8040, 0x0404);\r\nbt3c_io_write(iobase, 0x8040, 0x0400);\r\nudelay(1);\r\nbt3c_io_write(iobase, 0x8040, 0x0404);\r\nudelay(17);\r\nwhile (count) {\r\nif (ptr[0] != 'S') {\r\nBT_ERR("Bad address in firmware");\r\nerr = -EFAULT;\r\ngoto error;\r\n}\r\nmemset(b, 0, sizeof(b));\r\nmemcpy(b, ptr + 2, 2);\r\nsize = simple_strtoul(b, NULL, 16);\r\nmemset(b, 0, sizeof(b));\r\nmemcpy(b, ptr + 4, 8);\r\naddr = simple_strtoul(b, NULL, 16);\r\nmemset(b, 0, sizeof(b));\r\nmemcpy(b, ptr + (size * 2) + 2, 2);\r\nfcs = simple_strtoul(b, NULL, 16);\r\nmemset(b, 0, sizeof(b));\r\nfor (tmp = 0, i = 0; i < size; i++) {\r\nmemcpy(b, ptr + (i * 2) + 2, 2);\r\ntmp += simple_strtol(b, NULL, 16);\r\n}\r\nif (((tmp + fcs) & 0xff) != 0xff) {\r\nBT_ERR("Checksum error in firmware");\r\nerr = -EILSEQ;\r\ngoto error;\r\n}\r\nif (ptr[1] == '3') {\r\nbt3c_address(iobase, addr);\r\nmemset(b, 0, sizeof(b));\r\nfor (i = 0; i < (size - 4) / 2; i++) {\r\nmemcpy(b, ptr + (i * 4) + 12, 4);\r\ntmp = simple_strtoul(b, NULL, 16);\r\nbt3c_put(iobase, tmp);\r\n}\r\n}\r\nptr += (size * 2) + 6;\r\ncount -= (size * 2) + 6;\r\n}\r\nudelay(17);\r\nbt3c_address(iobase, 0x3000);\r\noutb(inb(iobase + CONTROL) | 0x40, iobase + CONTROL);\r\nerror:\r\nudelay(17);\r\nbt3c_io_write(iobase, 0x7006, 0x0000);\r\nbt3c_io_write(iobase, 0x7005, 0x0000);\r\nbt3c_io_write(iobase, 0x7001, 0x0000);\r\nreturn err;\r\n}\r\nstatic int bt3c_open(bt3c_info_t *info)\r\n{\r\nconst struct firmware *firmware;\r\nstruct hci_dev *hdev;\r\nint err;\r\nspin_lock_init(&(info->lock));\r\nskb_queue_head_init(&(info->txq));\r\ninfo->rx_state = RECV_WAIT_PACKET_TYPE;\r\ninfo->rx_count = 0;\r\ninfo->rx_skb = NULL;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\nreturn -ENOMEM;\r\n}\r\ninfo->hdev = hdev;\r\nhdev->bus = HCI_PCCARD;\r\nhci_set_drvdata(hdev, info);\r\nSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\r\nhdev->open = bt3c_hci_open;\r\nhdev->close = bt3c_hci_close;\r\nhdev->flush = bt3c_hci_flush;\r\nhdev->send = bt3c_hci_send_frame;\r\nhdev->ioctl = bt3c_hci_ioctl;\r\nerr = request_firmware(&firmware, "BT3CPCC.bin", &info->p_dev->dev);\r\nif (err < 0) {\r\nBT_ERR("Firmware request failed");\r\ngoto error;\r\n}\r\nerr = bt3c_load_firmware(info, firmware->data, firmware->size);\r\nrelease_firmware(firmware);\r\nif (err < 0) {\r\nBT_ERR("Firmware loading failed");\r\ngoto error;\r\n}\r\nmsleep(1000);\r\nerr = hci_register_dev(hdev);\r\nif (err < 0) {\r\nBT_ERR("Can't register HCI device");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ninfo->hdev = NULL;\r\nhci_free_dev(hdev);\r\nreturn err;\r\n}\r\nstatic int bt3c_close(bt3c_info_t *info)\r\n{\r\nstruct hci_dev *hdev = info->hdev;\r\nif (!hdev)\r\nreturn -ENODEV;\r\nbt3c_hci_close(hdev);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nreturn 0;\r\n}\r\nstatic int bt3c_probe(struct pcmcia_device *link)\r\n{\r\nbt3c_info_t *info;\r\ninfo = devm_kzalloc(&link->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_VPP |\r\nCONF_AUTO_SET_IO;\r\nreturn bt3c_config(link);\r\n}\r\nstatic void bt3c_detach(struct pcmcia_device *link)\r\n{\r\nbt3c_release(link);\r\n}\r\nstatic int bt3c_check_config(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint *try = priv_data;\r\nif (!try)\r\np_dev->io_lines = 16;\r\nif ((p_dev->resource[0]->end != 8) || (p_dev->resource[0]->start == 0))\r\nreturn -EINVAL;\r\np_dev->resource[0]->end = 8;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int bt3c_check_config_notpicky(struct pcmcia_device *p_dev,\r\nvoid *priv_data)\r\n{\r\nstatic unsigned int base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };\r\nint j;\r\nif (p_dev->io_lines > 3)\r\nreturn -ENODEV;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->resource[0]->end = 8;\r\nfor (j = 0; j < 5; j++) {\r\np_dev->resource[0]->start = base[j];\r\np_dev->io_lines = base[j] ? 16 : 3;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int bt3c_config(struct pcmcia_device *link)\r\n{\r\nbt3c_info_t *info = link->priv;\r\nint i;\r\nunsigned long try;\r\nfor (try = 0; try < 2; try++)\r\nif (!pcmcia_loop_config(link, bt3c_check_config, (void *) try))\r\ngoto found_port;\r\nif (!pcmcia_loop_config(link, bt3c_check_config_notpicky, NULL))\r\ngoto found_port;\r\nBT_ERR("No usable port range found");\r\ngoto failed;\r\nfound_port:\r\ni = pcmcia_request_irq(link, &bt3c_interrupt);\r\nif (i != 0)\r\ngoto failed;\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\ngoto failed;\r\nif (bt3c_open(info) != 0)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\nbt3c_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void bt3c_release(struct pcmcia_device *link)\r\n{\r\nbt3c_info_t *info = link->priv;\r\nbt3c_close(info);\r\npcmcia_disable_device(link);\r\n}\r\nstatic int __init init_bt3c_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&bt3c_driver);\r\n}\r\nstatic void __exit exit_bt3c_cs(void)\r\n{\r\npcmcia_unregister_driver(&bt3c_driver);\r\n}
