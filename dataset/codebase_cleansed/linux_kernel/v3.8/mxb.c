static void mxb_update_audmode(struct mxb *mxb)\r\n{\r\nstruct v4l2_tuner t = {\r\n.audmode = mxb->cur_mode,\r\n};\r\ntda9840_call(mxb, tuner, s_tuner, &t);\r\n}\r\nstatic inline void tea6420_route(struct mxb *mxb, int idx)\r\n{\r\nv4l2_subdev_call(mxb->tea6420_1, audio, s_routing,\r\nTEA6420_cd[idx][0].input, TEA6420_cd[idx][0].output, 0);\r\nv4l2_subdev_call(mxb->tea6420_2, audio, s_routing,\r\nTEA6420_cd[idx][1].input, TEA6420_cd[idx][1].output, 0);\r\nv4l2_subdev_call(mxb->tea6420_1, audio, s_routing,\r\nTEA6420_line[idx][0].input, TEA6420_line[idx][0].output, 0);\r\nv4l2_subdev_call(mxb->tea6420_2, audio, s_routing,\r\nTEA6420_line[idx][1].input, TEA6420_line[idx][1].output, 0);\r\n}\r\nstatic int mxb_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct saa7146_dev *dev = container_of(ctrl->handler,\r\nstruct saa7146_dev, ctrl_handler);\r\nstruct mxb *mxb = dev->ext_priv;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nmxb->cur_mute = ctrl->val;\r\ntea6420_route(mxb, ctrl->val ? 6 :\r\nvideo_audio_connect[mxb->cur_input]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxb_probe(struct saa7146_dev *dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->ctrl_handler;\r\nstruct mxb *mxb = NULL;\r\nv4l2_ctrl_new_std(hdl, &mxb_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nif (hdl->error)\r\nreturn hdl->error;\r\nmxb = kzalloc(sizeof(struct mxb), GFP_KERNEL);\r\nif (mxb == NULL) {\r\nDEB_D("not enough kernel memory\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(mxb->i2c_adapter.name, sizeof(mxb->i2c_adapter.name), "mxb%d", mxb_num);\r\nsaa7146_i2c_adapter_prepare(dev, &mxb->i2c_adapter, SAA7146_I2C_BUS_BIT_RATE_480);\r\nif (i2c_add_adapter(&mxb->i2c_adapter) < 0) {\r\nDEB_S("cannot register i2c-device. skipping.\n");\r\nkfree(mxb);\r\nreturn -EFAULT;\r\n}\r\nmxb->saa7111a = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\r\n"saa7111", I2C_SAA7111A, NULL);\r\nmxb->tea6420_1 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\r\n"tea6420", I2C_TEA6420_1, NULL);\r\nmxb->tea6420_2 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\r\n"tea6420", I2C_TEA6420_2, NULL);\r\nmxb->tea6415c = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\r\n"tea6415c", I2C_TEA6415C, NULL);\r\nmxb->tda9840 = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\r\n"tda9840", I2C_TDA9840, NULL);\r\nmxb->tuner = v4l2_i2c_new_subdev(&dev->v4l2_dev, &mxb->i2c_adapter,\r\n"tuner", I2C_TUNER, NULL);\r\nif (!mxb->tea6420_1 || !mxb->tea6420_2 || !mxb->tea6415c ||\r\n!mxb->tda9840 || !mxb->saa7111a || !mxb->tuner) {\r\npr_err("did not find all i2c devices. aborting\n");\r\ni2c_del_adapter(&mxb->i2c_adapter);\r\nkfree(mxb);\r\nreturn -ENODEV;\r\n}\r\ndev->ext_priv = mxb;\r\nv4l2_ctrl_handler_setup(hdl);\r\nreturn 0;\r\n}\r\nstatic int mxb_init_done(struct saa7146_dev* dev)\r\n{\r\nstruct mxb* mxb = (struct mxb*)dev->ext_priv;\r\nstruct i2c_msg msg;\r\nstruct tuner_setup tun_setup;\r\nv4l2_std_id std = V4L2_STD_PAL_BG;\r\nint i = 0, err = 0;\r\ntea6420_route(mxb, 6);\r\nsaa7111a_call(mxb, core, s_std, std);\r\ni = 0;\r\nsaa7111a_call(mxb, video, s_routing, SAA7115_COMPOSITE0,\r\nSAA7111_FMT_CCIR, 0);\r\ntun_setup.mode_mask = T_ANALOG_TV;\r\ntun_setup.addr = ADDR_UNSET;\r\ntun_setup.type = TUNER_PHILIPS_PAL;\r\ntuner_call(mxb, tuner, s_type_addr, &tun_setup);\r\nmxb->cur_freq.tuner = 0;\r\nmxb->cur_freq.type = V4L2_TUNER_ANALOG_TV;\r\nmxb->cur_freq.frequency = freq;\r\ntuner_call(mxb, tuner, s_frequency, &mxb->cur_freq);\r\nsaa7146_write(dev, GPIO_CTRL, 0x00404050);\r\nsaa7111a_call(mxb, core, s_gpio, 1);\r\nsaa7111a_call(mxb, core, s_std, std);\r\ntuner_call(mxb, core, s_std, std);\r\ntea6415c_call(mxb, video, s_routing, 3, 17, 0);\r\ntea6415c_call(mxb, video, s_routing, 3, 13, 0);\r\nmxb->cur_input = 0;\r\nmxb->cur_audinput = video_audio_connect[mxb->cur_input];\r\nmxb->cur_mute = 1;\r\nmxb->cur_mode = V4L2_TUNER_MODE_STEREO;\r\nmxb_update_audmode(mxb);\r\nmsg.addr = 0x1b;\r\nmsg.flags = 0;\r\nmsg.len = mxb_saa7740_init[0].length;\r\nmsg.buf = &mxb_saa7740_init[0].data[0];\r\nerr = i2c_transfer(&mxb->i2c_adapter, &msg, 1);\r\nif (err == 1) {\r\nextension.flags &= ~SAA7146_USE_I2C_IRQ;\r\nfor (i = 1; ; i++) {\r\nif (-1 == mxb_saa7740_init[i].length)\r\nbreak;\r\nmsg.len = mxb_saa7740_init[i].length;\r\nmsg.buf = &mxb_saa7740_init[i].data[0];\r\nerr = i2c_transfer(&mxb->i2c_adapter, &msg, 1);\r\nif (err != 1) {\r\nDEB_D("failed to initialize 'sound arena module'\n");\r\ngoto err;\r\n}\r\n}\r\npr_info("'sound arena module' detected\n");\r\n}\r\nerr:\r\nsaa7146_set_hps_source_and_sync(dev, input_port_selection[mxb->cur_input].hps_source,\r\ninput_port_selection[mxb->cur_input].hps_sync);\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, DD1_INIT, 0x02000200);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\nDEB_EE("VIDIOC_ENUMINPUT %d\n", i->index);\r\nif (i->index >= MXB_INPUTS)\r\nreturn -EINVAL;\r\nmemcpy(i, &mxb_inputs[i->index], sizeof(struct v4l2_input));\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\n*i = mxb->cur_input;\r\nDEB_EE("VIDIOC_G_INPUT %d\n", *i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nint err = 0;\r\nint i = 0;\r\nDEB_EE("VIDIOC_S_INPUT %d\n", input);\r\nif (input >= MXB_INPUTS)\r\nreturn -EINVAL;\r\nmxb->cur_input = input;\r\nsaa7146_set_hps_source_and_sync(dev, input_port_selection[input].hps_source,\r\ninput_port_selection[input].hps_sync);\r\nswitch (input) {\r\ncase TUNER:\r\ni = SAA7115_COMPOSITE0;\r\nerr = tea6415c_call(mxb, video, s_routing, 3, 17, 0);\r\nif (!err)\r\nerr = tea6415c_call(mxb, video, s_routing, 3, 13, 0);\r\nbreak;\r\ncase AUX3_YC:\r\ni = SAA7115_SVIDEO1;\r\nbreak;\r\ncase AUX3:\r\ni = SAA7115_COMPOSITE1;\r\nbreak;\r\ncase AUX1:\r\ni = SAA7115_COMPOSITE0;\r\nerr = tea6415c_call(mxb, video, s_routing, 1, 17, 0);\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nif (saa7111a_call(mxb, video, s_routing, i, SAA7111_FMT_CCIR, 0))\r\npr_err("VIDIOC_S_INPUT: could not address saa7111a\n");\r\nmxb->cur_audinput = video_audio_connect[input];\r\nif (0 == mxb->cur_mute)\r\ntea6420_route(mxb, mxb->cur_audinput);\r\nif (mxb->cur_audinput == 0)\r\nmxb_update_audmode(mxb);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *t)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nif (t->index) {\r\nDEB_D("VIDIOC_G_TUNER: channel %d does not have a tuner attached\n",\r\nt->index);\r\nreturn -EINVAL;\r\n}\r\nDEB_EE("VIDIOC_G_TUNER: %d\n", t->index);\r\nmemset(t, 0, sizeof(*t));\r\nstrlcpy(t->name, "TV Tuner", sizeof(t->name));\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\r\nt->audmode = mxb->cur_mode;\r\nreturn call_all(dev, tuner, g_tuner, t);\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *fh, struct v4l2_tuner *t)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nif (t->index) {\r\nDEB_D("VIDIOC_S_TUNER: channel %d does not have a tuner attached\n",\r\nt->index);\r\nreturn -EINVAL;\r\n}\r\nmxb->cur_mode = t->audmode;\r\nreturn call_all(dev, tuner, s_tuner, t);\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nreturn call_all(dev, video, querystd, norm);\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *fh, struct v4l2_frequency *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\n*f = mxb->cur_freq;\r\nDEB_EE("VIDIOC_G_FREQ: freq:0x%08x\n", mxb->cur_freq.frequency);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *fh, struct v4l2_frequency *f)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nstruct saa7146_vv *vv = dev->vv_data;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nif (V4L2_TUNER_ANALOG_TV != f->type)\r\nreturn -EINVAL;\r\nDEB_EE("VIDIOC_S_FREQUENCY: freq:0x%08x\n", mxb->cur_freq.frequency);\r\ntuner_call(mxb, tuner, s_frequency, f);\r\ntuner_call(mxb, tuner, g_frequency, f);\r\nmxb->cur_freq = *f;\r\nif (mxb->cur_audinput == 0)\r\nmxb_update_audmode(mxb);\r\nif (mxb->cur_input)\r\nreturn 0;\r\nspin_lock(&dev->slock);\r\nvv->vbi_fieldcount = 0;\r\nspin_unlock(&dev->slock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enumaudio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\nif (a->index >= MXB_AUDIOS)\r\nreturn -EINVAL;\r\n*a = mxb_audios[a->index];\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nDEB_EE("VIDIOC_G_AUDIO\n");\r\n*a = mxb_audios[mxb->cur_audinput];\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *fh, const struct v4l2_audio *a)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nDEB_D("VIDIOC_S_AUDIO %d\n", a->index);\r\nif (mxb_inputs[mxb->cur_input].audioset & (1 << a->index)) {\r\nif (mxb->cur_audinput != a->index) {\r\nmxb->cur_audinput = a->index;\r\ntea6420_route(mxb, a->index);\r\nif (mxb->cur_audinput == 0)\r\nmxb_update_audmode(mxb);\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *fh, struct v4l2_dbg_register *reg)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (v4l2_chip_match_host(&reg->match)) {\r\nreg->val = saa7146_read(dev, reg->reg);\r\nreg->size = 4;\r\nreturn 0;\r\n}\r\ncall_all(dev, core, g_register, reg);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *fh, struct v4l2_dbg_register *reg)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (v4l2_chip_match_host(&reg->match)) {\r\nsaa7146_write(dev, reg->reg, reg->val);\r\nreg->size = 4;\r\nreturn 0;\r\n}\r\nreturn call_all(dev, core, s_register, reg);\r\n}\r\nstatic int mxb_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\r\n{\r\nstruct mxb *mxb;\r\nDEB_EE("dev:%p\n", dev);\r\nsaa7146_vv_init(dev, &vv_data);\r\nif (mxb_probe(dev)) {\r\nsaa7146_vv_release(dev);\r\nreturn -1;\r\n}\r\nmxb = (struct mxb *)dev->ext_priv;\r\nvv_data.vid_ops.vidioc_enum_input = vidioc_enum_input;\r\nvv_data.vid_ops.vidioc_g_input = vidioc_g_input;\r\nvv_data.vid_ops.vidioc_s_input = vidioc_s_input;\r\nvv_data.vid_ops.vidioc_querystd = vidioc_querystd;\r\nvv_data.vid_ops.vidioc_g_tuner = vidioc_g_tuner;\r\nvv_data.vid_ops.vidioc_s_tuner = vidioc_s_tuner;\r\nvv_data.vid_ops.vidioc_g_frequency = vidioc_g_frequency;\r\nvv_data.vid_ops.vidioc_s_frequency = vidioc_s_frequency;\r\nvv_data.vid_ops.vidioc_enumaudio = vidioc_enumaudio;\r\nvv_data.vid_ops.vidioc_g_audio = vidioc_g_audio;\r\nvv_data.vid_ops.vidioc_s_audio = vidioc_s_audio;\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nvv_data.vid_ops.vidioc_g_register = vidioc_g_register;\r\nvv_data.vid_ops.vidioc_s_register = vidioc_s_register;\r\n#endif\r\nif (saa7146_register_device(&mxb->video_dev, dev, "mxb", VFL_TYPE_GRABBER)) {\r\nERR("cannot register capture v4l2 device. skipping.\n");\r\nsaa7146_vv_release(dev);\r\nreturn -1;\r\n}\r\nif (MXB_BOARD_CAN_DO_VBI(dev)) {\r\nif (saa7146_register_device(&mxb->vbi_dev, dev, "mxb", VFL_TYPE_VBI)) {\r\nERR("cannot register vbi v4l2 device. skipping.\n");\r\n}\r\n}\r\npr_info("found Multimedia eXtension Board #%d\n", mxb_num);\r\nmxb_num++;\r\nmxb_init_done(dev);\r\nreturn 0;\r\n}\r\nstatic int mxb_detach(struct saa7146_dev *dev)\r\n{\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nDEB_EE("dev:%p\n", dev);\r\ntea6420_route(mxb, 6);\r\nsaa7146_unregister_device(&mxb->video_dev,dev);\r\nif (MXB_BOARD_CAN_DO_VBI(dev))\r\nsaa7146_unregister_device(&mxb->vbi_dev, dev);\r\nsaa7146_vv_release(dev);\r\nmxb_num--;\r\ni2c_del_adapter(&mxb->i2c_adapter);\r\nkfree(mxb);\r\nreturn 0;\r\n}\r\nstatic int std_callback(struct saa7146_dev *dev, struct saa7146_standard *standard)\r\n{\r\nstruct mxb *mxb = (struct mxb *)dev->ext_priv;\r\nif (V4L2_STD_PAL_I == standard->id) {\r\nv4l2_std_id std = V4L2_STD_PAL_I;\r\nDEB_D("VIDIOC_S_STD: setting mxb for PAL_I\n");\r\nsaa7146_write(dev, GPIO_CTRL, 0x00404050);\r\nsaa7111a_call(mxb, core, s_gpio, 0);\r\nsaa7111a_call(mxb, core, s_std, std);\r\nif (mxb->cur_input == 0)\r\ntuner_call(mxb, core, s_std, std);\r\n} else {\r\nv4l2_std_id std = V4L2_STD_PAL_BG;\r\nif (mxb->cur_input)\r\nstd = standard->id;\r\nDEB_D("VIDIOC_S_STD: setting mxb for PAL/NTSC/SECAM\n");\r\nsaa7146_write(dev, GPIO_CTRL, 0x00404050);\r\nsaa7111a_call(mxb, core, s_gpio, 1);\r\nsaa7111a_call(mxb, core, s_std, std);\r\nif (mxb->cur_input == 0)\r\ntuner_call(mxb, core, s_std, std);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mxb_init_module(void)\r\n{\r\nif (saa7146_register_extension(&extension)) {\r\nDEB_S("failed to register extension\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit mxb_cleanup_module(void)\r\n{\r\nsaa7146_unregister_extension(&extension);\r\n}
