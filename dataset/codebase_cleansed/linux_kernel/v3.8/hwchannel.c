static void\r\ndchannel_bh(struct work_struct *ws)\r\n{\r\nstruct dchannel *dch = container_of(ws, struct dchannel, workq);\r\nstruct sk_buff *skb;\r\nint err;\r\nif (test_and_clear_bit(FLG_RECVQUEUE, &dch->Flags)) {\r\nwhile ((skb = skb_dequeue(&dch->rqueue))) {\r\nif (likely(dch->dev.D.peer)) {\r\nerr = dch->dev.D.recv(dch->dev.D.peer, skb);\r\nif (err)\r\ndev_kfree_skb(skb);\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nif (test_and_clear_bit(FLG_PHCHANGE, &dch->Flags)) {\r\nif (dch->phfunc)\r\ndch->phfunc(dch);\r\n}\r\n}\r\nstatic void\r\nbchannel_bh(struct work_struct *ws)\r\n{\r\nstruct bchannel *bch = container_of(ws, struct bchannel, workq);\r\nstruct sk_buff *skb;\r\nint err;\r\nif (test_and_clear_bit(FLG_RECVQUEUE, &bch->Flags)) {\r\nwhile ((skb = skb_dequeue(&bch->rqueue))) {\r\nbch->rcount--;\r\nif (likely(bch->ch.peer)) {\r\nerr = bch->ch.recv(bch->ch.peer, skb);\r\nif (err)\r\ndev_kfree_skb(skb);\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\n}\r\nint\r\nmISDN_initdchannel(struct dchannel *ch, int maxlen, void *phf)\r\n{\r\ntest_and_set_bit(FLG_HDLC, &ch->Flags);\r\nch->maxlen = maxlen;\r\nch->hw = NULL;\r\nch->rx_skb = NULL;\r\nch->tx_skb = NULL;\r\nch->tx_idx = 0;\r\nch->phfunc = phf;\r\nskb_queue_head_init(&ch->squeue);\r\nskb_queue_head_init(&ch->rqueue);\r\nINIT_LIST_HEAD(&ch->dev.bchannels);\r\nINIT_WORK(&ch->workq, dchannel_bh);\r\nreturn 0;\r\n}\r\nint\r\nmISDN_initbchannel(struct bchannel *ch, unsigned short maxlen,\r\nunsigned short minlen)\r\n{\r\nch->Flags = 0;\r\nch->minlen = minlen;\r\nch->next_minlen = minlen;\r\nch->init_minlen = minlen;\r\nch->maxlen = maxlen;\r\nch->next_maxlen = maxlen;\r\nch->init_maxlen = maxlen;\r\nch->hw = NULL;\r\nch->rx_skb = NULL;\r\nch->tx_skb = NULL;\r\nch->tx_idx = 0;\r\nskb_queue_head_init(&ch->rqueue);\r\nch->rcount = 0;\r\nch->next_skb = NULL;\r\nINIT_WORK(&ch->workq, bchannel_bh);\r\nreturn 0;\r\n}\r\nint\r\nmISDN_freedchannel(struct dchannel *ch)\r\n{\r\nif (ch->tx_skb) {\r\ndev_kfree_skb(ch->tx_skb);\r\nch->tx_skb = NULL;\r\n}\r\nif (ch->rx_skb) {\r\ndev_kfree_skb(ch->rx_skb);\r\nch->rx_skb = NULL;\r\n}\r\nskb_queue_purge(&ch->squeue);\r\nskb_queue_purge(&ch->rqueue);\r\nflush_work(&ch->workq);\r\nreturn 0;\r\n}\r\nvoid\r\nmISDN_clear_bchannel(struct bchannel *ch)\r\n{\r\nif (ch->tx_skb) {\r\ndev_kfree_skb(ch->tx_skb);\r\nch->tx_skb = NULL;\r\n}\r\nch->tx_idx = 0;\r\nif (ch->rx_skb) {\r\ndev_kfree_skb(ch->rx_skb);\r\nch->rx_skb = NULL;\r\n}\r\nif (ch->next_skb) {\r\ndev_kfree_skb(ch->next_skb);\r\nch->next_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &ch->Flags);\r\ntest_and_clear_bit(FLG_TX_NEXT, &ch->Flags);\r\ntest_and_clear_bit(FLG_ACTIVE, &ch->Flags);\r\ntest_and_clear_bit(FLG_FILLEMPTY, &ch->Flags);\r\ntest_and_clear_bit(FLG_TX_EMPTY, &ch->Flags);\r\ntest_and_clear_bit(FLG_RX_OFF, &ch->Flags);\r\nch->dropcnt = 0;\r\nch->minlen = ch->init_minlen;\r\nch->next_minlen = ch->init_minlen;\r\nch->maxlen = ch->init_maxlen;\r\nch->next_maxlen = ch->init_maxlen;\r\nskb_queue_purge(&ch->rqueue);\r\nch->rcount = 0;\r\n}\r\nvoid\r\nmISDN_freebchannel(struct bchannel *ch)\r\n{\r\ncancel_work_sync(&ch->workq);\r\nmISDN_clear_bchannel(ch);\r\n}\r\nint\r\nmISDN_ctrl_bchannel(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_RX_BUFFER | MISDN_CTRL_FILL_EMPTY |\r\nMISDN_CTRL_RX_OFF;\r\nbreak;\r\ncase MISDN_CTRL_FILL_EMPTY:\r\nif (cq->p1) {\r\nmemset(bch->fill, cq->p2 & 0xff, MISDN_BCH_FILL_SIZE);\r\ntest_and_set_bit(FLG_FILLEMPTY, &bch->Flags);\r\n} else {\r\ntest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\r\n}\r\nbreak;\r\ncase MISDN_CTRL_RX_OFF:\r\ncq->p2 = bch->dropcnt;\r\nif (cq->p1)\r\ntest_and_set_bit(FLG_RX_OFF, &bch->Flags);\r\nelse\r\ntest_and_clear_bit(FLG_RX_OFF, &bch->Flags);\r\nbch->dropcnt = 0;\r\nbreak;\r\ncase MISDN_CTRL_RX_BUFFER:\r\nif (cq->p2 > MISDN_CTRL_RX_SIZE_IGNORE)\r\nbch->next_maxlen = cq->p2;\r\nif (cq->p1 > MISDN_CTRL_RX_SIZE_IGNORE)\r\nbch->next_minlen = cq->p1;\r\ncq->p1 = bch->minlen;\r\ncq->p2 = bch->maxlen;\r\nbreak;\r\ndefault:\r\npr_info("mISDN unhandled control %x operation\n", cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline u_int\r\nget_sapi_tei(u_char *p)\r\n{\r\nu_int sapi, tei;\r\nsapi = *p >> 2;\r\ntei = p[1] >> 1;\r\nreturn sapi | (tei << 8);\r\n}\r\nvoid\r\nrecv_Dchannel(struct dchannel *dch)\r\n{\r\nstruct mISDNhead *hh;\r\nif (dch->rx_skb->len < 2) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\nreturn;\r\n}\r\nhh = mISDN_HEAD_P(dch->rx_skb);\r\nhh->prim = PH_DATA_IND;\r\nhh->id = get_sapi_tei(dch->rx_skb->data);\r\nskb_queue_tail(&dch->rqueue, dch->rx_skb);\r\ndch->rx_skb = NULL;\r\nschedule_event(dch, FLG_RECVQUEUE);\r\n}\r\nvoid\r\nrecv_Echannel(struct dchannel *ech, struct dchannel *dch)\r\n{\r\nstruct mISDNhead *hh;\r\nif (ech->rx_skb->len < 2) {\r\ndev_kfree_skb(ech->rx_skb);\r\nech->rx_skb = NULL;\r\nreturn;\r\n}\r\nhh = mISDN_HEAD_P(ech->rx_skb);\r\nhh->prim = PH_DATA_E_IND;\r\nhh->id = get_sapi_tei(ech->rx_skb->data);\r\nskb_queue_tail(&dch->rqueue, ech->rx_skb);\r\nech->rx_skb = NULL;\r\nschedule_event(dch, FLG_RECVQUEUE);\r\n}\r\nvoid\r\nrecv_Bchannel(struct bchannel *bch, unsigned int id, bool force)\r\n{\r\nstruct mISDNhead *hh;\r\nif (unlikely(!bch->rx_skb))\r\nreturn;\r\nif (unlikely(!bch->rx_skb->len)) {\r\ndev_kfree_skb(bch->rx_skb);\r\nbch->rx_skb = NULL;\r\n} else {\r\nif (test_bit(FLG_TRANSPARENT, &bch->Flags) &&\r\n(bch->rx_skb->len < bch->minlen) && !force)\r\nreturn;\r\nhh = mISDN_HEAD_P(bch->rx_skb);\r\nhh->prim = PH_DATA_IND;\r\nhh->id = id;\r\nif (bch->rcount >= 64) {\r\nprintk(KERN_WARNING\r\n"B%d receive queue overflow - flushing!\n",\r\nbch->nr);\r\nskb_queue_purge(&bch->rqueue);\r\n}\r\nbch->rcount++;\r\nskb_queue_tail(&bch->rqueue, bch->rx_skb);\r\nbch->rx_skb = NULL;\r\nschedule_event(bch, FLG_RECVQUEUE);\r\n}\r\n}\r\nvoid\r\nrecv_Dchannel_skb(struct dchannel *dch, struct sk_buff *skb)\r\n{\r\nskb_queue_tail(&dch->rqueue, skb);\r\nschedule_event(dch, FLG_RECVQUEUE);\r\n}\r\nvoid\r\nrecv_Bchannel_skb(struct bchannel *bch, struct sk_buff *skb)\r\n{\r\nif (bch->rcount >= 64) {\r\nprintk(KERN_WARNING "B-channel %p receive queue overflow, "\r\n"flushing!\n", bch);\r\nskb_queue_purge(&bch->rqueue);\r\nbch->rcount = 0;\r\n}\r\nbch->rcount++;\r\nskb_queue_tail(&bch->rqueue, skb);\r\nschedule_event(bch, FLG_RECVQUEUE);\r\n}\r\nstatic void\r\nconfirm_Dsend(struct dchannel *dch)\r\n{\r\nstruct sk_buff *skb;\r\nskb = _alloc_mISDN_skb(PH_DATA_CNF, mISDN_HEAD_ID(dch->tx_skb),\r\n0, NULL, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "%s: no skb id %x\n", __func__,\r\nmISDN_HEAD_ID(dch->tx_skb));\r\nreturn;\r\n}\r\nskb_queue_tail(&dch->rqueue, skb);\r\nschedule_event(dch, FLG_RECVQUEUE);\r\n}\r\nint\r\nget_next_dframe(struct dchannel *dch)\r\n{\r\ndch->tx_idx = 0;\r\ndch->tx_skb = skb_dequeue(&dch->squeue);\r\nif (dch->tx_skb) {\r\nconfirm_Dsend(dch);\r\nreturn 1;\r\n}\r\ndch->tx_skb = NULL;\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nconfirm_Bsend(struct bchannel *bch)\r\n{\r\nstruct sk_buff *skb;\r\nif (bch->rcount >= 64) {\r\nprintk(KERN_WARNING "B-channel %p receive queue overflow, "\r\n"flushing!\n", bch);\r\nskb_queue_purge(&bch->rqueue);\r\nbch->rcount = 0;\r\n}\r\nskb = _alloc_mISDN_skb(PH_DATA_CNF, mISDN_HEAD_ID(bch->tx_skb),\r\n0, NULL, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "%s: no skb id %x\n", __func__,\r\nmISDN_HEAD_ID(bch->tx_skb));\r\nreturn;\r\n}\r\nbch->rcount++;\r\nskb_queue_tail(&bch->rqueue, skb);\r\nschedule_event(bch, FLG_RECVQUEUE);\r\n}\r\nint\r\nget_next_bframe(struct bchannel *bch)\r\n{\r\nbch->tx_idx = 0;\r\nif (test_bit(FLG_TX_NEXT, &bch->Flags)) {\r\nbch->tx_skb = bch->next_skb;\r\nif (bch->tx_skb) {\r\nbch->next_skb = NULL;\r\ntest_and_clear_bit(FLG_TX_NEXT, &bch->Flags);\r\nconfirm_Bsend(bch);\r\nreturn 1;\r\n} else {\r\ntest_and_clear_bit(FLG_TX_NEXT, &bch->Flags);\r\nprintk(KERN_WARNING "B TX_NEXT without skb\n");\r\n}\r\n}\r\nbch->tx_skb = NULL;\r\ntest_and_clear_bit(FLG_TX_BUSY, &bch->Flags);\r\nreturn 0;\r\n}\r\nvoid\r\nqueue_ch_frame(struct mISDNchannel *ch, u_int pr, int id, struct sk_buff *skb)\r\n{\r\nstruct mISDNhead *hh;\r\nif (!skb) {\r\n_queue_data(ch, pr, id, 0, NULL, GFP_ATOMIC);\r\n} else {\r\nif (ch->peer) {\r\nhh = mISDN_HEAD_P(skb);\r\nhh->prim = pr;\r\nhh->id = id;\r\nif (!ch->recv(ch->peer, skb))\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nint\r\ndchannel_senddata(struct dchannel *ch, struct sk_buff *skb)\r\n{\r\nif (skb->len <= 0) {\r\nprintk(KERN_WARNING "%s: skb too small\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (skb->len > ch->maxlen) {\r\nprintk(KERN_WARNING "%s: skb too large(%d/%d)\n",\r\n__func__, skb->len, ch->maxlen);\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(FLG_TX_BUSY, &ch->Flags)) {\r\nskb_queue_tail(&ch->squeue, skb);\r\nreturn 0;\r\n} else {\r\nch->tx_skb = skb;\r\nch->tx_idx = 0;\r\nreturn 1;\r\n}\r\n}\r\nint\r\nbchannel_senddata(struct bchannel *ch, struct sk_buff *skb)\r\n{\r\nif (skb->len <= 0) {\r\nprintk(KERN_WARNING "%s: skb too small\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (skb->len > ch->maxlen) {\r\nprintk(KERN_WARNING "%s: skb too large(%d/%d)\n",\r\n__func__, skb->len, ch->maxlen);\r\nreturn -EINVAL;\r\n}\r\nif (ch->next_skb) {\r\nprintk(KERN_WARNING\r\n"%s: next_skb exist ERROR (skb->len=%d next_skb->len=%d)\n",\r\n__func__, skb->len, ch->next_skb->len);\r\nreturn -EBUSY;\r\n}\r\nif (test_and_set_bit(FLG_TX_BUSY, &ch->Flags)) {\r\ntest_and_set_bit(FLG_TX_NEXT, &ch->Flags);\r\nch->next_skb = skb;\r\nreturn 0;\r\n} else {\r\nch->tx_skb = skb;\r\nch->tx_idx = 0;\r\nconfirm_Bsend(ch);\r\nreturn 1;\r\n}\r\n}\r\nint\r\nbchannel_get_rxbuf(struct bchannel *bch, int reqlen)\r\n{\r\nint len;\r\nif (bch->rx_skb) {\r\nlen = skb_tailroom(bch->rx_skb);\r\nif (len < reqlen) {\r\npr_warning("B%d no space for %d (only %d) bytes\n",\r\nbch->nr, reqlen, len);\r\nif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\r\nrecv_Bchannel(bch, 0, true);\r\n} else {\r\nreturn -EMSGSIZE;\r\n}\r\n} else {\r\nreturn len;\r\n}\r\n}\r\nif (unlikely(bch->maxlen != bch->next_maxlen))\r\nbch->maxlen = bch->next_maxlen;\r\nif (unlikely(bch->minlen != bch->next_minlen))\r\nbch->minlen = bch->next_minlen;\r\nif (unlikely(reqlen > bch->maxlen))\r\nreturn -EMSGSIZE;\r\nif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\r\nif (reqlen >= bch->minlen) {\r\nlen = reqlen;\r\n} else {\r\nlen = 2 * bch->minlen;\r\nif (len > bch->maxlen)\r\nlen = bch->maxlen;\r\n}\r\n} else {\r\nlen = bch->maxlen;\r\n}\r\nbch->rx_skb = mI_alloc_skb(len, GFP_ATOMIC);\r\nif (!bch->rx_skb) {\r\npr_warning("B%d receive no memory for %d bytes\n",\r\nbch->nr, len);\r\nlen = -ENOMEM;\r\n}\r\nreturn len;\r\n}
