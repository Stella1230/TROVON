void __quota_error(struct super_block *sb, const char *func,\r\nconst char *fmt, ...)\r\n{\r\nif (printk_ratelimit()) {\r\nva_list args;\r\nstruct va_format vaf;\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\nprintk(KERN_ERR "Quota error (device %s): %s: %pV\n",\r\nsb->s_id, func, &vaf);\r\nva_end(args);\r\n}\r\n}\r\nint register_quota_format(struct quota_format_type *fmt)\r\n{\r\nspin_lock(&dq_list_lock);\r\nfmt->qf_next = quota_formats;\r\nquota_formats = fmt;\r\nspin_unlock(&dq_list_lock);\r\nreturn 0;\r\n}\r\nvoid unregister_quota_format(struct quota_format_type *fmt)\r\n{\r\nstruct quota_format_type **actqf;\r\nspin_lock(&dq_list_lock);\r\nfor (actqf = &quota_formats; *actqf && *actqf != fmt;\r\nactqf = &(*actqf)->qf_next)\r\n;\r\nif (*actqf)\r\n*actqf = (*actqf)->qf_next;\r\nspin_unlock(&dq_list_lock);\r\n}\r\nstatic struct quota_format_type *find_quota_format(int id)\r\n{\r\nstruct quota_format_type *actqf;\r\nspin_lock(&dq_list_lock);\r\nfor (actqf = quota_formats; actqf && actqf->qf_fmt_id != id;\r\nactqf = actqf->qf_next)\r\n;\r\nif (!actqf || !try_module_get(actqf->qf_owner)) {\r\nint qm;\r\nspin_unlock(&dq_list_lock);\r\nfor (qm = 0; module_names[qm].qm_fmt_id &&\r\nmodule_names[qm].qm_fmt_id != id; qm++)\r\n;\r\nif (!module_names[qm].qm_fmt_id ||\r\nrequest_module(module_names[qm].qm_mod_name))\r\nreturn NULL;\r\nspin_lock(&dq_list_lock);\r\nfor (actqf = quota_formats; actqf && actqf->qf_fmt_id != id;\r\nactqf = actqf->qf_next)\r\n;\r\nif (actqf && !try_module_get(actqf->qf_owner))\r\nactqf = NULL;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nreturn actqf;\r\n}\r\nstatic void put_quota_format(struct quota_format_type *fmt)\r\n{\r\nmodule_put(fmt->qf_owner);\r\n}\r\nstatic inline unsigned int\r\nhashfn(const struct super_block *sb, struct kqid qid)\r\n{\r\nunsigned int id = from_kqid(&init_user_ns, qid);\r\nint type = qid.type;\r\nunsigned long tmp;\r\ntmp = (((unsigned long)sb>>L1_CACHE_SHIFT) ^ id) * (MAXQUOTAS - type);\r\nreturn (tmp + (tmp >> dq_hash_bits)) & dq_hash_mask;\r\n}\r\nstatic inline void insert_dquot_hash(struct dquot *dquot)\r\n{\r\nstruct hlist_head *head;\r\nhead = dquot_hash + hashfn(dquot->dq_sb, dquot->dq_id);\r\nhlist_add_head(&dquot->dq_hash, head);\r\n}\r\nstatic inline void remove_dquot_hash(struct dquot *dquot)\r\n{\r\nhlist_del_init(&dquot->dq_hash);\r\n}\r\nstatic struct dquot *find_dquot(unsigned int hashent, struct super_block *sb,\r\nstruct kqid qid)\r\n{\r\nstruct hlist_node *node;\r\nstruct dquot *dquot;\r\nhlist_for_each (node, dquot_hash+hashent) {\r\ndquot = hlist_entry(node, struct dquot, dq_hash);\r\nif (dquot->dq_sb == sb && qid_eq(dquot->dq_id, qid))\r\nreturn dquot;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void put_dquot_last(struct dquot *dquot)\r\n{\r\nlist_add_tail(&dquot->dq_free, &free_dquots);\r\ndqstats_inc(DQST_FREE_DQUOTS);\r\n}\r\nstatic inline void remove_free_dquot(struct dquot *dquot)\r\n{\r\nif (list_empty(&dquot->dq_free))\r\nreturn;\r\nlist_del_init(&dquot->dq_free);\r\ndqstats_dec(DQST_FREE_DQUOTS);\r\n}\r\nstatic inline void put_inuse(struct dquot *dquot)\r\n{\r\nlist_add_tail(&dquot->dq_inuse, &inuse_list);\r\ndqstats_inc(DQST_ALLOC_DQUOTS);\r\n}\r\nstatic inline void remove_inuse(struct dquot *dquot)\r\n{\r\ndqstats_dec(DQST_ALLOC_DQUOTS);\r\nlist_del(&dquot->dq_inuse);\r\n}\r\nstatic void wait_on_dquot(struct dquot *dquot)\r\n{\r\nmutex_lock(&dquot->dq_lock);\r\nmutex_unlock(&dquot->dq_lock);\r\n}\r\nstatic inline int dquot_dirty(struct dquot *dquot)\r\n{\r\nreturn test_bit(DQ_MOD_B, &dquot->dq_flags);\r\n}\r\nstatic inline int mark_dquot_dirty(struct dquot *dquot)\r\n{\r\nreturn dquot->dq_sb->dq_op->mark_dirty(dquot);\r\n}\r\nint dquot_mark_dquot_dirty(struct dquot *dquot)\r\n{\r\nint ret = 1;\r\nif (test_bit(DQ_MOD_B, &dquot->dq_flags))\r\nreturn 1;\r\nspin_lock(&dq_list_lock);\r\nif (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)) {\r\nlist_add(&dquot->dq_dirty, &sb_dqopt(dquot->dq_sb)->\r\ninfo[dquot->dq_id.type].dqi_dirty_list);\r\nret = 0;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nreturn ret;\r\n}\r\nstatic inline int mark_all_dquot_dirty(struct dquot * const *dquot)\r\n{\r\nint ret, err, cnt;\r\nret = err = 0;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (dquot[cnt])\r\nret = mark_dquot_dirty(dquot[cnt]);\r\nif (!err)\r\nerr = ret;\r\n}\r\nreturn err;\r\n}\r\nstatic inline void dqput_all(struct dquot **dquot)\r\n{\r\nunsigned int cnt;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\ndqput(dquot[cnt]);\r\n}\r\nstatic inline int clear_dquot_dirty(struct dquot *dquot)\r\n{\r\nif (!test_and_clear_bit(DQ_MOD_B, &dquot->dq_flags))\r\nreturn 0;\r\nlist_del_init(&dquot->dq_dirty);\r\nreturn 1;\r\n}\r\nvoid mark_info_dirty(struct super_block *sb, int type)\r\n{\r\nset_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);\r\n}\r\nint dquot_acquire(struct dquot *dquot)\r\n{\r\nint ret = 0, ret2 = 0;\r\nstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\r\nmutex_lock(&dquot->dq_lock);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nif (!test_bit(DQ_READ_B, &dquot->dq_flags))\r\nret = dqopt->ops[dquot->dq_id.type]->read_dqblk(dquot);\r\nif (ret < 0)\r\ngoto out_iolock;\r\nset_bit(DQ_READ_B, &dquot->dq_flags);\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && !dquot->dq_off) {\r\nret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\r\nif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\r\nret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\r\ndquot->dq_sb, dquot->dq_id.type);\r\n}\r\nif (ret < 0)\r\ngoto out_iolock;\r\nif (ret2 < 0) {\r\nret = ret2;\r\ngoto out_iolock;\r\n}\r\n}\r\nset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\r\nout_iolock:\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nmutex_unlock(&dquot->dq_lock);\r\nreturn ret;\r\n}\r\nint dquot_commit(struct dquot *dquot)\r\n{\r\nint ret = 0;\r\nstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nspin_lock(&dq_list_lock);\r\nif (!clear_dquot_dirty(dquot)) {\r\nspin_unlock(&dq_list_lock);\r\ngoto out_sem;\r\n}\r\nspin_unlock(&dq_list_lock);\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\r\nret = dqopt->ops[dquot->dq_id.type]->commit_dqblk(dquot);\r\nelse\r\nret = -EIO;\r\nout_sem:\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nreturn ret;\r\n}\r\nint dquot_release(struct dquot *dquot)\r\n{\r\nint ret = 0, ret2 = 0;\r\nstruct quota_info *dqopt = sb_dqopt(dquot->dq_sb);\r\nmutex_lock(&dquot->dq_lock);\r\nif (atomic_read(&dquot->dq_count) > 1)\r\ngoto out_dqlock;\r\nmutex_lock(&dqopt->dqio_mutex);\r\nif (dqopt->ops[dquot->dq_id.type]->release_dqblk) {\r\nret = dqopt->ops[dquot->dq_id.type]->release_dqblk(dquot);\r\nif (info_dirty(&dqopt->info[dquot->dq_id.type])) {\r\nret2 = dqopt->ops[dquot->dq_id.type]->write_file_info(\r\ndquot->dq_sb, dquot->dq_id.type);\r\n}\r\nif (ret >= 0)\r\nret = ret2;\r\n}\r\nclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nout_dqlock:\r\nmutex_unlock(&dquot->dq_lock);\r\nreturn ret;\r\n}\r\nvoid dquot_destroy(struct dquot *dquot)\r\n{\r\nkmem_cache_free(dquot_cachep, dquot);\r\n}\r\nstatic inline void do_destroy_dquot(struct dquot *dquot)\r\n{\r\ndquot->dq_sb->dq_op->destroy_dquot(dquot);\r\n}\r\nstatic void invalidate_dquots(struct super_block *sb, int type)\r\n{\r\nstruct dquot *dquot, *tmp;\r\nrestart:\r\nspin_lock(&dq_list_lock);\r\nlist_for_each_entry_safe(dquot, tmp, &inuse_list, dq_inuse) {\r\nif (dquot->dq_sb != sb)\r\ncontinue;\r\nif (dquot->dq_id.type != type)\r\ncontinue;\r\nif (atomic_read(&dquot->dq_count)) {\r\nDEFINE_WAIT(wait);\r\natomic_inc(&dquot->dq_count);\r\nprepare_to_wait(&dquot->dq_wait_unused, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nspin_unlock(&dq_list_lock);\r\nif (atomic_read(&dquot->dq_count) > 1)\r\nschedule();\r\nfinish_wait(&dquot->dq_wait_unused, &wait);\r\ndqput(dquot);\r\ngoto restart;\r\n}\r\nremove_dquot_hash(dquot);\r\nremove_free_dquot(dquot);\r\nremove_inuse(dquot);\r\ndo_destroy_dquot(dquot);\r\n}\r\nspin_unlock(&dq_list_lock);\r\n}\r\nint dquot_scan_active(struct super_block *sb,\r\nint (*fn)(struct dquot *dquot, unsigned long priv),\r\nunsigned long priv)\r\n{\r\nstruct dquot *dquot, *old_dquot = NULL;\r\nint ret = 0;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nspin_lock(&dq_list_lock);\r\nlist_for_each_entry(dquot, &inuse_list, dq_inuse) {\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags))\r\ncontinue;\r\nif (dquot->dq_sb != sb)\r\ncontinue;\r\natomic_inc(&dquot->dq_count);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_LOOKUPS);\r\ndqput(old_dquot);\r\nold_dquot = dquot;\r\nret = fn(dquot, priv);\r\nif (ret < 0)\r\ngoto out;\r\nspin_lock(&dq_list_lock);\r\n}\r\nspin_unlock(&dq_list_lock);\r\nout:\r\ndqput(old_dquot);\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn ret;\r\n}\r\nint dquot_writeback_dquots(struct super_block *sb, int type)\r\n{\r\nstruct list_head *dirty;\r\nstruct dquot *dquot;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint cnt;\r\nint err, ret = 0;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\nspin_lock(&dq_list_lock);\r\ndirty = &dqopt->info[cnt].dqi_dirty_list;\r\nwhile (!list_empty(dirty)) {\r\ndquot = list_first_entry(dirty, struct dquot,\r\ndq_dirty);\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\r\nclear_dquot_dirty(dquot);\r\ncontinue;\r\n}\r\natomic_inc(&dquot->dq_count);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_LOOKUPS);\r\nerr = sb->dq_op->write_dquot(dquot);\r\nif (!ret && err)\r\nerr = ret;\r\ndqput(dquot);\r\nspin_lock(&dq_list_lock);\r\n}\r\nspin_unlock(&dq_list_lock);\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\r\n&& info_dirty(&dqopt->info[cnt]))\r\nsb->dq_op->write_info(sb, cnt);\r\ndqstats_inc(DQST_SYNCS);\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn ret;\r\n}\r\nint dquot_quota_sync(struct super_block *sb, int type)\r\n{\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint cnt;\r\nint ret;\r\nret = dquot_writeback_dquots(sb, type);\r\nif (ret)\r\nreturn ret;\r\nif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\r\nreturn 0;\r\nif (sb->s_op->sync_fs)\r\nsb->s_op->sync_fs(sb, 1);\r\nsync_blockdev(sb->s_bdev);\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\nmutex_lock(&dqopt->files[cnt]->i_mutex);\r\ntruncate_inode_pages(&dqopt->files[cnt]->i_data, 0);\r\nmutex_unlock(&dqopt->files[cnt]->i_mutex);\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn 0;\r\n}\r\nstatic void prune_dqcache(int count)\r\n{\r\nstruct list_head *head;\r\nstruct dquot *dquot;\r\nhead = free_dquots.prev;\r\nwhile (head != &free_dquots && count) {\r\ndquot = list_entry(head, struct dquot, dq_free);\r\nremove_dquot_hash(dquot);\r\nremove_free_dquot(dquot);\r\nremove_inuse(dquot);\r\ndo_destroy_dquot(dquot);\r\ncount--;\r\nhead = free_dquots.prev;\r\n}\r\n}\r\nstatic int shrink_dqcache_memory(struct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nint nr = sc->nr_to_scan;\r\nif (nr) {\r\nspin_lock(&dq_list_lock);\r\nprune_dqcache(nr);\r\nspin_unlock(&dq_list_lock);\r\n}\r\nreturn ((unsigned)\r\npercpu_counter_read_positive(&dqstats.counter[DQST_FREE_DQUOTS])\r\n/100) * sysctl_vfs_cache_pressure;\r\n}\r\nvoid dqput(struct dquot *dquot)\r\n{\r\nint ret;\r\nif (!dquot)\r\nreturn;\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (!atomic_read(&dquot->dq_count)) {\r\nquota_error(dquot->dq_sb, "trying to free free dquot of %s %d",\r\nquotatypes[dquot->dq_id.type],\r\nfrom_kqid(&init_user_ns, dquot->dq_id));\r\nBUG();\r\n}\r\n#endif\r\ndqstats_inc(DQST_DROPS);\r\nwe_slept:\r\nspin_lock(&dq_list_lock);\r\nif (atomic_read(&dquot->dq_count) > 1) {\r\natomic_dec(&dquot->dq_count);\r\nif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\r\natomic_read(&dquot->dq_count) == 1)\r\nwake_up(&dquot->dq_wait_unused);\r\nspin_unlock(&dq_list_lock);\r\nreturn;\r\n}\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\r\nspin_unlock(&dq_list_lock);\r\nret = dquot->dq_sb->dq_op->write_dquot(dquot);\r\nif (ret < 0) {\r\nquota_error(dquot->dq_sb, "Can't write quota structure"\r\n" (error %d). Quota may get out of sync!",\r\nret);\r\nspin_lock(&dq_list_lock);\r\nclear_dquot_dirty(dquot);\r\nspin_unlock(&dq_list_lock);\r\n}\r\ngoto we_slept;\r\n}\r\nclear_dquot_dirty(dquot);\r\nif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\r\nspin_unlock(&dq_list_lock);\r\ndquot->dq_sb->dq_op->release_dquot(dquot);\r\ngoto we_slept;\r\n}\r\natomic_dec(&dquot->dq_count);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nBUG_ON(!list_empty(&dquot->dq_free));\r\n#endif\r\nput_dquot_last(dquot);\r\nspin_unlock(&dq_list_lock);\r\n}\r\nstruct dquot *dquot_alloc(struct super_block *sb, int type)\r\n{\r\nreturn kmem_cache_zalloc(dquot_cachep, GFP_NOFS);\r\n}\r\nstatic struct dquot *get_empty_dquot(struct super_block *sb, int type)\r\n{\r\nstruct dquot *dquot;\r\ndquot = sb->dq_op->alloc_dquot(sb, type);\r\nif(!dquot)\r\nreturn NULL;\r\nmutex_init(&dquot->dq_lock);\r\nINIT_LIST_HEAD(&dquot->dq_free);\r\nINIT_LIST_HEAD(&dquot->dq_inuse);\r\nINIT_HLIST_NODE(&dquot->dq_hash);\r\nINIT_LIST_HEAD(&dquot->dq_dirty);\r\ninit_waitqueue_head(&dquot->dq_wait_unused);\r\ndquot->dq_sb = sb;\r\ndquot->dq_id = make_kqid_invalid(type);\r\natomic_set(&dquot->dq_count, 1);\r\nreturn dquot;\r\n}\r\nstruct dquot *dqget(struct super_block *sb, struct kqid qid)\r\n{\r\nunsigned int hashent = hashfn(sb, qid);\r\nstruct dquot *dquot = NULL, *empty = NULL;\r\nif (!sb_has_quota_active(sb, qid.type))\r\nreturn NULL;\r\nwe_slept:\r\nspin_lock(&dq_list_lock);\r\nspin_lock(&dq_state_lock);\r\nif (!sb_has_quota_active(sb, qid.type)) {\r\nspin_unlock(&dq_state_lock);\r\nspin_unlock(&dq_list_lock);\r\ngoto out;\r\n}\r\nspin_unlock(&dq_state_lock);\r\ndquot = find_dquot(hashent, sb, qid);\r\nif (!dquot) {\r\nif (!empty) {\r\nspin_unlock(&dq_list_lock);\r\nempty = get_empty_dquot(sb, qid.type);\r\nif (!empty)\r\nschedule();\r\ngoto we_slept;\r\n}\r\ndquot = empty;\r\nempty = NULL;\r\ndquot->dq_id = qid;\r\nput_inuse(dquot);\r\ninsert_dquot_hash(dquot);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_LOOKUPS);\r\n} else {\r\nif (!atomic_read(&dquot->dq_count))\r\nremove_free_dquot(dquot);\r\natomic_inc(&dquot->dq_count);\r\nspin_unlock(&dq_list_lock);\r\ndqstats_inc(DQST_CACHE_HITS);\r\ndqstats_inc(DQST_LOOKUPS);\r\n}\r\nwait_on_dquot(dquot);\r\nif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) &&\r\nsb->dq_op->acquire_dquot(dquot) < 0) {\r\ndqput(dquot);\r\ndquot = NULL;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nBUG_ON(!dquot->dq_sb);\r\n#endif\r\nout:\r\nif (empty)\r\ndo_destroy_dquot(empty);\r\nreturn dquot;\r\n}\r\nstatic int dqinit_needed(struct inode *inode, int type)\r\n{\r\nint cnt;\r\nif (IS_NOQUOTA(inode))\r\nreturn 0;\r\nif (type != -1)\r\nreturn !inode->i_dquot[type];\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (!inode->i_dquot[cnt])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void add_dquot_ref(struct super_block *sb, int type)\r\n{\r\nstruct inode *inode, *old_inode = NULL;\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nint reserved = 0;\r\n#endif\r\nspin_lock(&inode_sb_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nspin_lock(&inode->i_lock);\r\nif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\r\n!atomic_read(&inode->i_writecount) ||\r\n!dqinit_needed(inode, type)) {\r\nspin_unlock(&inode->i_lock);\r\ncontinue;\r\n}\r\n__iget(inode);\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&inode_sb_list_lock);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (unlikely(inode_get_rsv_space(inode) > 0))\r\nreserved = 1;\r\n#endif\r\niput(old_inode);\r\n__dquot_initialize(inode, type);\r\nold_inode = inode;\r\nspin_lock(&inode_sb_list_lock);\r\n}\r\nspin_unlock(&inode_sb_list_lock);\r\niput(old_inode);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (reserved) {\r\nquota_error(sb, "Writes happened before quota was turned on "\r\n"thus quota information is probably inconsistent. "\r\n"Please run quotacheck(8)");\r\n}\r\n#endif\r\n}\r\nstatic inline int dqput_blocks(struct dquot *dquot)\r\n{\r\nif (atomic_read(&dquot->dq_count) <= 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int remove_inode_dquot_ref(struct inode *inode, int type,\r\nstruct list_head *tofree_head)\r\n{\r\nstruct dquot *dquot = inode->i_dquot[type];\r\ninode->i_dquot[type] = NULL;\r\nif (dquot) {\r\nif (dqput_blocks(dquot)) {\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (atomic_read(&dquot->dq_count) != 1)\r\nquota_error(inode->i_sb, "Adding dquot with "\r\n"dq_count %d to dispose list",\r\natomic_read(&dquot->dq_count));\r\n#endif\r\nspin_lock(&dq_list_lock);\r\nlist_add(&dquot->dq_free, tofree_head);\r\nspin_unlock(&dq_list_lock);\r\nreturn 1;\r\n}\r\nelse\r\ndqput(dquot);\r\n}\r\nreturn 0;\r\n}\r\nstatic void put_dquot_list(struct list_head *tofree_head)\r\n{\r\nstruct list_head *act_head;\r\nstruct dquot *dquot;\r\nact_head = tofree_head->next;\r\nwhile (act_head != tofree_head) {\r\ndquot = list_entry(act_head, struct dquot, dq_free);\r\nact_head = act_head->next;\r\nlist_del_init(&dquot->dq_free);\r\ndqput(dquot);\r\n}\r\n}\r\nstatic void remove_dquot_ref(struct super_block *sb, int type,\r\nstruct list_head *tofree_head)\r\n{\r\nstruct inode *inode;\r\nint reserved = 0;\r\nspin_lock(&inode_sb_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nif (!IS_NOQUOTA(inode)) {\r\nif (unlikely(inode_get_rsv_space(inode) > 0))\r\nreserved = 1;\r\nremove_inode_dquot_ref(inode, type, tofree_head);\r\n}\r\n}\r\nspin_unlock(&inode_sb_list_lock);\r\n#ifdef CONFIG_QUOTA_DEBUG\r\nif (reserved) {\r\nprintk(KERN_WARNING "VFS (%s): Writes happened after quota"\r\n" was disabled thus quota information is probably "\r\n"inconsistent. Please run quotacheck(8).\n", sb->s_id);\r\n}\r\n#endif\r\n}\r\nstatic void drop_dquot_ref(struct super_block *sb, int type)\r\n{\r\nLIST_HEAD(tofree_head);\r\nif (sb->dq_op) {\r\ndown_write(&sb_dqopt(sb)->dqptr_sem);\r\nremove_dquot_ref(sb, type, &tofree_head);\r\nup_write(&sb_dqopt(sb)->dqptr_sem);\r\nput_dquot_list(&tofree_head);\r\n}\r\n}\r\nstatic inline void dquot_incr_inodes(struct dquot *dquot, qsize_t number)\r\n{\r\ndquot->dq_dqb.dqb_curinodes += number;\r\n}\r\nstatic inline void dquot_incr_space(struct dquot *dquot, qsize_t number)\r\n{\r\ndquot->dq_dqb.dqb_curspace += number;\r\n}\r\nstatic inline void dquot_resv_space(struct dquot *dquot, qsize_t number)\r\n{\r\ndquot->dq_dqb.dqb_rsvspace += number;\r\n}\r\nstatic void dquot_claim_reserved_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (dquot->dq_dqb.dqb_rsvspace < number) {\r\nWARN_ON_ONCE(1);\r\nnumber = dquot->dq_dqb.dqb_rsvspace;\r\n}\r\ndquot->dq_dqb.dqb_curspace += number;\r\ndquot->dq_dqb.dqb_rsvspace -= number;\r\n}\r\nstatic inline\r\nvoid dquot_free_reserved_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (dquot->dq_dqb.dqb_rsvspace >= number)\r\ndquot->dq_dqb.dqb_rsvspace -= number;\r\nelse {\r\nWARN_ON_ONCE(1);\r\ndquot->dq_dqb.dqb_rsvspace = 0;\r\n}\r\n}\r\nstatic void dquot_decr_inodes(struct dquot *dquot, qsize_t number)\r\n{\r\nif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NEGATIVE_USAGE ||\r\ndquot->dq_dqb.dqb_curinodes >= number)\r\ndquot->dq_dqb.dqb_curinodes -= number;\r\nelse\r\ndquot->dq_dqb.dqb_curinodes = 0;\r\nif (dquot->dq_dqb.dqb_curinodes <= dquot->dq_dqb.dqb_isoftlimit)\r\ndquot->dq_dqb.dqb_itime = (time_t) 0;\r\nclear_bit(DQ_INODES_B, &dquot->dq_flags);\r\n}\r\nstatic void dquot_decr_space(struct dquot *dquot, qsize_t number)\r\n{\r\nif (sb_dqopt(dquot->dq_sb)->flags & DQUOT_NEGATIVE_USAGE ||\r\ndquot->dq_dqb.dqb_curspace >= number)\r\ndquot->dq_dqb.dqb_curspace -= number;\r\nelse\r\ndquot->dq_dqb.dqb_curspace = 0;\r\nif (dquot->dq_dqb.dqb_curspace <= dquot->dq_dqb.dqb_bsoftlimit)\r\ndquot->dq_dqb.dqb_btime = (time_t) 0;\r\nclear_bit(DQ_BLKS_B, &dquot->dq_flags);\r\n}\r\nstatic int warning_issued(struct dquot *dquot, const int warntype)\r\n{\r\nint flag = (warntype == QUOTA_NL_BHARDWARN ||\r\nwarntype == QUOTA_NL_BSOFTLONGWARN) ? DQ_BLKS_B :\r\n((warntype == QUOTA_NL_IHARDWARN ||\r\nwarntype == QUOTA_NL_ISOFTLONGWARN) ? DQ_INODES_B : 0);\r\nif (!flag)\r\nreturn 0;\r\nreturn test_and_set_bit(flag, &dquot->dq_flags);\r\n}\r\nstatic int need_print_warning(struct dquot_warn *warn)\r\n{\r\nif (!flag_print_warnings)\r\nreturn 0;\r\nswitch (warn->w_dq_id.type) {\r\ncase USRQUOTA:\r\nreturn uid_eq(current_fsuid(), warn->w_dq_id.uid);\r\ncase GRPQUOTA:\r\nreturn in_group_p(warn->w_dq_id.gid);\r\ncase PRJQUOTA:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_warning(struct dquot_warn *warn)\r\n{\r\nchar *msg = NULL;\r\nstruct tty_struct *tty;\r\nint warntype = warn->w_type;\r\nif (warntype == QUOTA_NL_IHARDBELOW ||\r\nwarntype == QUOTA_NL_ISOFTBELOW ||\r\nwarntype == QUOTA_NL_BHARDBELOW ||\r\nwarntype == QUOTA_NL_BSOFTBELOW || !need_print_warning(warn))\r\nreturn;\r\ntty = get_current_tty();\r\nif (!tty)\r\nreturn;\r\ntty_write_message(tty, warn->w_sb->s_id);\r\nif (warntype == QUOTA_NL_ISOFTWARN || warntype == QUOTA_NL_BSOFTWARN)\r\ntty_write_message(tty, ": warning, ");\r\nelse\r\ntty_write_message(tty, ": write failed, ");\r\ntty_write_message(tty, quotatypes[warn->w_dq_id.type]);\r\nswitch (warntype) {\r\ncase QUOTA_NL_IHARDWARN:\r\nmsg = " file limit reached.\r\n";\r\nbreak;\r\ncase QUOTA_NL_ISOFTLONGWARN:\r\nmsg = " file quota exceeded too long.\r\n";\r\nbreak;\r\ncase QUOTA_NL_ISOFTWARN:\r\nmsg = " file quota exceeded.\r\n";\r\nbreak;\r\ncase QUOTA_NL_BHARDWARN:\r\nmsg = " block limit reached.\r\n";\r\nbreak;\r\ncase QUOTA_NL_BSOFTLONGWARN:\r\nmsg = " block quota exceeded too long.\r\n";\r\nbreak;\r\ncase QUOTA_NL_BSOFTWARN:\r\nmsg = " block quota exceeded.\r\n";\r\nbreak;\r\n}\r\ntty_write_message(tty, msg);\r\ntty_kref_put(tty);\r\n}\r\nstatic void prepare_warning(struct dquot_warn *warn, struct dquot *dquot,\r\nint warntype)\r\n{\r\nif (warning_issued(dquot, warntype))\r\nreturn;\r\nwarn->w_type = warntype;\r\nwarn->w_sb = dquot->dq_sb;\r\nwarn->w_dq_id = dquot->dq_id;\r\n}\r\nstatic void flush_warnings(struct dquot_warn *warn)\r\n{\r\nint i;\r\nfor (i = 0; i < MAXQUOTAS; i++) {\r\nif (warn[i].w_type == QUOTA_NL_NOWARN)\r\ncontinue;\r\n#ifdef CONFIG_PRINT_QUOTA_WARNING\r\nprint_warning(&warn[i]);\r\n#endif\r\nquota_send_warning(warn[i].w_dq_id,\r\nwarn[i].w_sb->s_dev, warn[i].w_type);\r\n}\r\n}\r\nstatic int ignore_hardlimit(struct dquot *dquot)\r\n{\r\nstruct mem_dqinfo *info = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type];\r\nreturn capable(CAP_SYS_RESOURCE) &&\r\n(info->dqi_format->qf_fmt_id != QFMT_VFS_OLD ||\r\n!(info->dqi_flags & V1_DQF_RSQUASH));\r\n}\r\nstatic int check_idq(struct dquot *dquot, qsize_t inodes,\r\nstruct dquot_warn *warn)\r\n{\r\nqsize_t newinodes = dquot->dq_dqb.dqb_curinodes + inodes;\r\nif (!sb_has_quota_limits_enabled(dquot->dq_sb, dquot->dq_id.type) ||\r\ntest_bit(DQ_FAKE_B, &dquot->dq_flags))\r\nreturn 0;\r\nif (dquot->dq_dqb.dqb_ihardlimit &&\r\nnewinodes > dquot->dq_dqb.dqb_ihardlimit &&\r\n!ignore_hardlimit(dquot)) {\r\nprepare_warning(warn, dquot, QUOTA_NL_IHARDWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_isoftlimit &&\r\nnewinodes > dquot->dq_dqb.dqb_isoftlimit &&\r\ndquot->dq_dqb.dqb_itime &&\r\nget_seconds() >= dquot->dq_dqb.dqb_itime &&\r\n!ignore_hardlimit(dquot)) {\r\nprepare_warning(warn, dquot, QUOTA_NL_ISOFTLONGWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_isoftlimit &&\r\nnewinodes > dquot->dq_dqb.dqb_isoftlimit &&\r\ndquot->dq_dqb.dqb_itime == 0) {\r\nprepare_warning(warn, dquot, QUOTA_NL_ISOFTWARN);\r\ndquot->dq_dqb.dqb_itime = get_seconds() +\r\nsb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type].dqi_igrace;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_bdq(struct dquot *dquot, qsize_t space, int prealloc,\r\nstruct dquot_warn *warn)\r\n{\r\nqsize_t tspace;\r\nstruct super_block *sb = dquot->dq_sb;\r\nif (!sb_has_quota_limits_enabled(sb, dquot->dq_id.type) ||\r\ntest_bit(DQ_FAKE_B, &dquot->dq_flags))\r\nreturn 0;\r\ntspace = dquot->dq_dqb.dqb_curspace + dquot->dq_dqb.dqb_rsvspace\r\n+ space;\r\nif (dquot->dq_dqb.dqb_bhardlimit &&\r\ntspace > dquot->dq_dqb.dqb_bhardlimit &&\r\n!ignore_hardlimit(dquot)) {\r\nif (!prealloc)\r\nprepare_warning(warn, dquot, QUOTA_NL_BHARDWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_bsoftlimit &&\r\ntspace > dquot->dq_dqb.dqb_bsoftlimit &&\r\ndquot->dq_dqb.dqb_btime &&\r\nget_seconds() >= dquot->dq_dqb.dqb_btime &&\r\n!ignore_hardlimit(dquot)) {\r\nif (!prealloc)\r\nprepare_warning(warn, dquot, QUOTA_NL_BSOFTLONGWARN);\r\nreturn -EDQUOT;\r\n}\r\nif (dquot->dq_dqb.dqb_bsoftlimit &&\r\ntspace > dquot->dq_dqb.dqb_bsoftlimit &&\r\ndquot->dq_dqb.dqb_btime == 0) {\r\nif (!prealloc) {\r\nprepare_warning(warn, dquot, QUOTA_NL_BSOFTWARN);\r\ndquot->dq_dqb.dqb_btime = get_seconds() +\r\nsb_dqopt(sb)->info[dquot->dq_id.type].dqi_bgrace;\r\n}\r\nelse\r\nreturn -EDQUOT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int info_idq_free(struct dquot *dquot, qsize_t inodes)\r\n{\r\nqsize_t newinodes;\r\nif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\r\ndquot->dq_dqb.dqb_curinodes <= dquot->dq_dqb.dqb_isoftlimit ||\r\n!sb_has_quota_limits_enabled(dquot->dq_sb, dquot->dq_id.type))\r\nreturn QUOTA_NL_NOWARN;\r\nnewinodes = dquot->dq_dqb.dqb_curinodes - inodes;\r\nif (newinodes <= dquot->dq_dqb.dqb_isoftlimit)\r\nreturn QUOTA_NL_ISOFTBELOW;\r\nif (dquot->dq_dqb.dqb_curinodes >= dquot->dq_dqb.dqb_ihardlimit &&\r\nnewinodes < dquot->dq_dqb.dqb_ihardlimit)\r\nreturn QUOTA_NL_IHARDBELOW;\r\nreturn QUOTA_NL_NOWARN;\r\n}\r\nstatic int info_bdq_free(struct dquot *dquot, qsize_t space)\r\n{\r\nif (test_bit(DQ_FAKE_B, &dquot->dq_flags) ||\r\ndquot->dq_dqb.dqb_curspace <= dquot->dq_dqb.dqb_bsoftlimit)\r\nreturn QUOTA_NL_NOWARN;\r\nif (dquot->dq_dqb.dqb_curspace - space <= dquot->dq_dqb.dqb_bsoftlimit)\r\nreturn QUOTA_NL_BSOFTBELOW;\r\nif (dquot->dq_dqb.dqb_curspace >= dquot->dq_dqb.dqb_bhardlimit &&\r\ndquot->dq_dqb.dqb_curspace - space < dquot->dq_dqb.dqb_bhardlimit)\r\nreturn QUOTA_NL_BHARDBELOW;\r\nreturn QUOTA_NL_NOWARN;\r\n}\r\nstatic int dquot_active(const struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nif (IS_NOQUOTA(inode))\r\nreturn 0;\r\nreturn sb_any_quota_loaded(sb) & ~sb_any_quota_suspended(sb);\r\n}\r\nstatic void __dquot_initialize(struct inode *inode, int type)\r\n{\r\nint cnt;\r\nstruct dquot *got[MAXQUOTAS];\r\nstruct super_block *sb = inode->i_sb;\r\nqsize_t rsv;\r\nif (!dquot_active(inode))\r\nreturn;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nstruct kqid qid;\r\ngot[cnt] = NULL;\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nswitch (cnt) {\r\ncase USRQUOTA:\r\nqid = make_kqid_uid(inode->i_uid);\r\nbreak;\r\ncase GRPQUOTA:\r\nqid = make_kqid_gid(inode->i_gid);\r\nbreak;\r\n}\r\ngot[cnt] = dqget(sb, qid);\r\n}\r\ndown_write(&sb_dqopt(sb)->dqptr_sem);\r\nif (IS_NOQUOTA(inode))\r\ngoto out_err;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_active(sb, cnt))\r\ncontinue;\r\nif (!got[cnt])\r\ncontinue;\r\nif (!inode->i_dquot[cnt]) {\r\ninode->i_dquot[cnt] = got[cnt];\r\ngot[cnt] = NULL;\r\nrsv = inode_get_rsv_space(inode);\r\nif (unlikely(rsv))\r\ndquot_resv_space(inode->i_dquot[cnt], rsv);\r\n}\r\n}\r\nout_err:\r\nup_write(&sb_dqopt(sb)->dqptr_sem);\r\ndqput_all(got);\r\n}\r\nvoid dquot_initialize(struct inode *inode)\r\n{\r\n__dquot_initialize(inode, -1);\r\n}\r\nstatic void __dquot_drop(struct inode *inode)\r\n{\r\nint cnt;\r\nstruct dquot *put[MAXQUOTAS];\r\ndown_write(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nput[cnt] = inode->i_dquot[cnt];\r\ninode->i_dquot[cnt] = NULL;\r\n}\r\nup_write(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\ndqput_all(put);\r\n}\r\nvoid dquot_drop(struct inode *inode)\r\n{\r\nint cnt;\r\nif (IS_NOQUOTA(inode))\r\nreturn;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (inode->i_dquot[cnt])\r\nbreak;\r\n}\r\nif (cnt < MAXQUOTAS)\r\n__dquot_drop(inode);\r\n}\r\nstatic qsize_t *inode_reserved_space(struct inode * inode)\r\n{\r\nBUG_ON(!inode->i_sb->dq_op->get_reserved_space);\r\nreturn inode->i_sb->dq_op->get_reserved_space(inode);\r\n}\r\nvoid inode_add_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) += number;\r\nspin_unlock(&inode->i_lock);\r\n}\r\nvoid inode_claim_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) -= number;\r\n__inode_add_bytes(inode, number);\r\nspin_unlock(&inode->i_lock);\r\n}\r\nvoid inode_sub_rsv_space(struct inode *inode, qsize_t number)\r\n{\r\nspin_lock(&inode->i_lock);\r\n*inode_reserved_space(inode) -= number;\r\nspin_unlock(&inode->i_lock);\r\n}\r\nstatic qsize_t inode_get_rsv_space(struct inode *inode)\r\n{\r\nqsize_t ret;\r\nif (!inode->i_sb->dq_op->get_reserved_space)\r\nreturn 0;\r\nspin_lock(&inode->i_lock);\r\nret = *inode_reserved_space(inode);\r\nspin_unlock(&inode->i_lock);\r\nreturn ret;\r\n}\r\nstatic void inode_incr_space(struct inode *inode, qsize_t number,\r\nint reserve)\r\n{\r\nif (reserve)\r\ninode_add_rsv_space(inode, number);\r\nelse\r\ninode_add_bytes(inode, number);\r\n}\r\nstatic void inode_decr_space(struct inode *inode, qsize_t number, int reserve)\r\n{\r\nif (reserve)\r\ninode_sub_rsv_space(inode, number);\r\nelse\r\ninode_sub_bytes(inode, number);\r\n}\r\nint __dquot_alloc_space(struct inode *inode, qsize_t number, int flags)\r\n{\r\nint cnt, ret = 0;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot **dquots = inode->i_dquot;\r\nint reserve = flags & DQUOT_SPACE_RESERVE;\r\nif (!dquot_active(inode)) {\r\ninode_incr_space(inode, number, reserve);\r\ngoto out;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\ndown_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\nret = check_bdq(dquots[cnt], number,\r\n!(flags & DQUOT_SPACE_WARN), &warn[cnt]);\r\nif (ret && !(flags & DQUOT_SPACE_NOFAIL)) {\r\nspin_unlock(&dq_data_lock);\r\ngoto out_flush_warn;\r\n}\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\nif (reserve)\r\ndquot_resv_space(dquots[cnt], number);\r\nelse\r\ndquot_incr_space(dquots[cnt], number);\r\n}\r\ninode_incr_space(inode, number, reserve);\r\nspin_unlock(&dq_data_lock);\r\nif (reserve)\r\ngoto out_flush_warn;\r\nmark_all_dquot_dirty(dquots);\r\nout_flush_warn:\r\nup_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nflush_warnings(warn);\r\nout:\r\nreturn ret;\r\n}\r\nint dquot_alloc_inode(const struct inode *inode)\r\n{\r\nint cnt, ret = 0;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot * const *dquots = inode->i_dquot;\r\nif (!dquot_active(inode))\r\nreturn 0;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\ndown_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\nret = check_idq(dquots[cnt], 1, &warn[cnt]);\r\nif (ret)\r\ngoto warn_put_all;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!dquots[cnt])\r\ncontinue;\r\ndquot_incr_inodes(dquots[cnt], 1);\r\n}\r\nwarn_put_all:\r\nspin_unlock(&dq_data_lock);\r\nif (ret == 0)\r\nmark_all_dquot_dirty(dquots);\r\nup_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nflush_warnings(warn);\r\nreturn ret;\r\n}\r\nint dquot_claim_space_nodirty(struct inode *inode, qsize_t number)\r\n{\r\nint cnt;\r\nif (!dquot_active(inode)) {\r\ninode_claim_rsv_space(inode, number);\r\nreturn 0;\r\n}\r\ndown_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (inode->i_dquot[cnt])\r\ndquot_claim_reserved_space(inode->i_dquot[cnt],\r\nnumber);\r\n}\r\ninode_claim_rsv_space(inode, number);\r\nspin_unlock(&dq_data_lock);\r\nmark_all_dquot_dirty(inode->i_dquot);\r\nup_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nreturn 0;\r\n}\r\nvoid __dquot_free_space(struct inode *inode, qsize_t number, int flags)\r\n{\r\nunsigned int cnt;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot **dquots = inode->i_dquot;\r\nint reserve = flags & DQUOT_SPACE_RESERVE;\r\nif (!dquot_active(inode)) {\r\ninode_decr_space(inode, number, reserve);\r\nreturn;\r\n}\r\ndown_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nint wtype;\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\nif (!dquots[cnt])\r\ncontinue;\r\nwtype = info_bdq_free(dquots[cnt], number);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn[cnt], dquots[cnt], wtype);\r\nif (reserve)\r\ndquot_free_reserved_space(dquots[cnt], number);\r\nelse\r\ndquot_decr_space(dquots[cnt], number);\r\n}\r\ninode_decr_space(inode, number, reserve);\r\nspin_unlock(&dq_data_lock);\r\nif (reserve)\r\ngoto out_unlock;\r\nmark_all_dquot_dirty(dquots);\r\nout_unlock:\r\nup_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nflush_warnings(warn);\r\n}\r\nvoid dquot_free_inode(const struct inode *inode)\r\n{\r\nunsigned int cnt;\r\nstruct dquot_warn warn[MAXQUOTAS];\r\nstruct dquot * const *dquots = inode->i_dquot;\r\nif (!dquot_active(inode))\r\nreturn;\r\ndown_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nspin_lock(&dq_data_lock);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nint wtype;\r\nwarn[cnt].w_type = QUOTA_NL_NOWARN;\r\nif (!dquots[cnt])\r\ncontinue;\r\nwtype = info_idq_free(dquots[cnt], 1);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn[cnt], dquots[cnt], wtype);\r\ndquot_decr_inodes(dquots[cnt], 1);\r\n}\r\nspin_unlock(&dq_data_lock);\r\nmark_all_dquot_dirty(dquots);\r\nup_read(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nflush_warnings(warn);\r\n}\r\nint __dquot_transfer(struct inode *inode, struct dquot **transfer_to)\r\n{\r\nqsize_t space, cur_space;\r\nqsize_t rsv_space = 0;\r\nstruct dquot *transfer_from[MAXQUOTAS] = {};\r\nint cnt, ret = 0;\r\nchar is_valid[MAXQUOTAS] = {};\r\nstruct dquot_warn warn_to[MAXQUOTAS];\r\nstruct dquot_warn warn_from_inodes[MAXQUOTAS];\r\nstruct dquot_warn warn_from_space[MAXQUOTAS];\r\nif (IS_NOQUOTA(inode))\r\nreturn 0;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nwarn_to[cnt].w_type = QUOTA_NL_NOWARN;\r\nwarn_from_inodes[cnt].w_type = QUOTA_NL_NOWARN;\r\nwarn_from_space[cnt].w_type = QUOTA_NL_NOWARN;\r\n}\r\ndown_write(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nif (IS_NOQUOTA(inode)) {\r\nup_write(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nreturn 0;\r\n}\r\nspin_lock(&dq_data_lock);\r\ncur_space = inode_get_bytes(inode);\r\nrsv_space = inode_get_rsv_space(inode);\r\nspace = cur_space + rsv_space;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!transfer_to[cnt])\r\ncontinue;\r\nif (!sb_has_quota_active(inode->i_sb, cnt))\r\ncontinue;\r\nis_valid[cnt] = 1;\r\ntransfer_from[cnt] = inode->i_dquot[cnt];\r\nret = check_idq(transfer_to[cnt], 1, &warn_to[cnt]);\r\nif (ret)\r\ngoto over_quota;\r\nret = check_bdq(transfer_to[cnt], space, 0, &warn_to[cnt]);\r\nif (ret)\r\ngoto over_quota;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (!is_valid[cnt])\r\ncontinue;\r\nif (transfer_from[cnt]) {\r\nint wtype;\r\nwtype = info_idq_free(transfer_from[cnt], 1);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn_from_inodes[cnt],\r\ntransfer_from[cnt], wtype);\r\nwtype = info_bdq_free(transfer_from[cnt], space);\r\nif (wtype != QUOTA_NL_NOWARN)\r\nprepare_warning(&warn_from_space[cnt],\r\ntransfer_from[cnt], wtype);\r\ndquot_decr_inodes(transfer_from[cnt], 1);\r\ndquot_decr_space(transfer_from[cnt], cur_space);\r\ndquot_free_reserved_space(transfer_from[cnt],\r\nrsv_space);\r\n}\r\ndquot_incr_inodes(transfer_to[cnt], 1);\r\ndquot_incr_space(transfer_to[cnt], cur_space);\r\ndquot_resv_space(transfer_to[cnt], rsv_space);\r\ninode->i_dquot[cnt] = transfer_to[cnt];\r\n}\r\nspin_unlock(&dq_data_lock);\r\nup_write(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nmark_all_dquot_dirty(transfer_from);\r\nmark_all_dquot_dirty(transfer_to);\r\nflush_warnings(warn_to);\r\nflush_warnings(warn_from_inodes);\r\nflush_warnings(warn_from_space);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (is_valid[cnt])\r\ntransfer_to[cnt] = transfer_from[cnt];\r\nreturn 0;\r\nover_quota:\r\nspin_unlock(&dq_data_lock);\r\nup_write(&sb_dqopt(inode->i_sb)->dqptr_sem);\r\nflush_warnings(warn_to);\r\nreturn ret;\r\n}\r\nint dquot_transfer(struct inode *inode, struct iattr *iattr)\r\n{\r\nstruct dquot *transfer_to[MAXQUOTAS] = {};\r\nstruct super_block *sb = inode->i_sb;\r\nint ret;\r\nif (!dquot_active(inode))\r\nreturn 0;\r\nif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\r\ntransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\r\nif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\r\ntransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\r\nret = __dquot_transfer(inode, transfer_to);\r\ndqput_all(transfer_to);\r\nreturn ret;\r\n}\r\nint dquot_commit_info(struct super_block *sb, int type)\r\n{\r\nint ret;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nret = dqopt->ops[type]->write_file_info(sb, type);\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nreturn ret;\r\n}\r\nint dquot_file_open(struct inode *inode, struct file *file)\r\n{\r\nint error;\r\nerror = generic_file_open(inode, file);\r\nif (!error && (file->f_mode & FMODE_WRITE))\r\ndquot_initialize(inode);\r\nreturn error;\r\n}\r\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\r\n{\r\nint cnt, ret = 0;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nstruct inode *toputinode[MAXQUOTAS];\r\nif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\r\n|| (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\r\nDQUOT_USAGE_ENABLED)))\r\nreturn -EINVAL;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_any_quota_loaded(sb)) {\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn 0;\r\n}\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\ntoputinode[cnt] = NULL;\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nif (!sb_has_quota_loaded(sb, cnt))\r\ncontinue;\r\nif (flags & DQUOT_SUSPENDED) {\r\nspin_lock(&dq_state_lock);\r\ndqopt->flags |=\r\ndquot_state_flag(DQUOT_SUSPENDED, cnt);\r\nspin_unlock(&dq_state_lock);\r\n} else {\r\nspin_lock(&dq_state_lock);\r\ndqopt->flags &= ~dquot_state_flag(flags, cnt);\r\nif (!sb_has_quota_loaded(sb, cnt) &&\r\nsb_has_quota_suspended(sb, cnt)) {\r\ndqopt->flags &= ~dquot_state_flag(\r\nDQUOT_SUSPENDED, cnt);\r\nspin_unlock(&dq_state_lock);\r\niput(dqopt->files[cnt]);\r\ndqopt->files[cnt] = NULL;\r\ncontinue;\r\n}\r\nspin_unlock(&dq_state_lock);\r\n}\r\nif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\r\ncontinue;\r\ndrop_dquot_ref(sb, cnt);\r\ninvalidate_dquots(sb, cnt);\r\nif (info_dirty(&dqopt->info[cnt]))\r\nsb->dq_op->write_info(sb, cnt);\r\nif (dqopt->ops[cnt]->free_file_info)\r\ndqopt->ops[cnt]->free_file_info(sb, cnt);\r\nput_quota_format(dqopt->info[cnt].dqi_format);\r\ntoputinode[cnt] = dqopt->files[cnt];\r\nif (!sb_has_quota_loaded(sb, cnt))\r\ndqopt->files[cnt] = NULL;\r\ndqopt->info[cnt].dqi_flags = 0;\r\ndqopt->info[cnt].dqi_igrace = 0;\r\ndqopt->info[cnt].dqi_bgrace = 0;\r\ndqopt->ops[cnt] = NULL;\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\r\ngoto put_inodes;\r\nif (sb->s_op->sync_fs)\r\nsb->s_op->sync_fs(sb, 1);\r\nsync_blockdev(sb->s_bdev);\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (toputinode[cnt]) {\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_loaded(sb, cnt)) {\r\nmutex_lock(&toputinode[cnt]->i_mutex);\r\ntoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\r\nS_NOATIME | S_NOQUOTA);\r\ntruncate_inode_pages(&toputinode[cnt]->i_data,\r\n0);\r\nmutex_unlock(&toputinode[cnt]->i_mutex);\r\nmark_inode_dirty_sync(toputinode[cnt]);\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\n}\r\nif (sb->s_bdev)\r\ninvalidate_bdev(sb->s_bdev);\r\nput_inodes:\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\r\nif (toputinode[cnt]) {\r\nif (!(flags & DQUOT_SUSPENDED))\r\niput(toputinode[cnt]);\r\nelse if (!toputinode[cnt]->i_nlink)\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nint dquot_quota_off(struct super_block *sb, int type)\r\n{\r\nreturn dquot_disable(sb, type,\r\nDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\r\n}\r\nstatic int vfs_load_quota_inode(struct inode *inode, int type, int format_id,\r\nunsigned int flags)\r\n{\r\nstruct quota_format_type *fmt = find_quota_format(format_id);\r\nstruct super_block *sb = inode->i_sb;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nint error;\r\nint oldflags = -1;\r\nif (!fmt)\r\nreturn -ESRCH;\r\nif (!S_ISREG(inode->i_mode)) {\r\nerror = -EACCES;\r\ngoto out_fmt;\r\n}\r\nif (IS_RDONLY(inode)) {\r\nerror = -EROFS;\r\ngoto out_fmt;\r\n}\r\nif (!sb->s_op->quota_write || !sb->s_op->quota_read) {\r\nerror = -EINVAL;\r\ngoto out_fmt;\r\n}\r\nif (!(flags & DQUOT_USAGE_ENABLED)) {\r\nerror = -EINVAL;\r\ngoto out_fmt;\r\n}\r\nif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\r\nsync_filesystem(sb);\r\ninvalidate_bdev(sb->s_bdev);\r\n}\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (sb_has_quota_loaded(sb, type)) {\r\nerror = -EBUSY;\r\ngoto out_lock;\r\n}\r\nif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {\r\nmutex_lock(&inode->i_mutex);\r\noldflags = inode->i_flags & (S_NOATIME | S_IMMUTABLE |\r\nS_NOQUOTA);\r\ninode->i_flags |= S_NOQUOTA | S_NOATIME | S_IMMUTABLE;\r\nmutex_unlock(&inode->i_mutex);\r\n__dquot_drop(inode);\r\n}\r\nerror = -EIO;\r\ndqopt->files[type] = igrab(inode);\r\nif (!dqopt->files[type])\r\ngoto out_lock;\r\nerror = -EINVAL;\r\nif (!fmt->qf_ops->check_quota_file(sb, type))\r\ngoto out_file_init;\r\ndqopt->ops[type] = fmt->qf_ops;\r\ndqopt->info[type].dqi_format = fmt;\r\ndqopt->info[type].dqi_fmt_id = format_id;\r\nINIT_LIST_HEAD(&dqopt->info[type].dqi_dirty_list);\r\nmutex_lock(&dqopt->dqio_mutex);\r\nerror = dqopt->ops[type]->read_file_info(sb, type);\r\nif (error < 0) {\r\nmutex_unlock(&dqopt->dqio_mutex);\r\ngoto out_file_init;\r\n}\r\nif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\r\ndqopt->info[type].dqi_flags |= DQF_SYS_FILE;\r\nmutex_unlock(&dqopt->dqio_mutex);\r\nspin_lock(&dq_state_lock);\r\ndqopt->flags |= dquot_state_flag(flags, type);\r\nspin_unlock(&dq_state_lock);\r\nadd_dquot_ref(sb, type);\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn 0;\r\nout_file_init:\r\ndqopt->files[type] = NULL;\r\niput(inode);\r\nout_lock:\r\nif (oldflags != -1) {\r\nmutex_lock(&inode->i_mutex);\r\ninode->i_flags &= ~(S_NOATIME | S_NOQUOTA | S_IMMUTABLE);\r\ninode->i_flags |= oldflags;\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nout_fmt:\r\nput_quota_format(fmt);\r\nreturn error;\r\n}\r\nint dquot_resume(struct super_block *sb, int type)\r\n{\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nstruct inode *inode;\r\nint ret = 0, cnt;\r\nunsigned int flags;\r\nfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\r\nif (type != -1 && cnt != type)\r\ncontinue;\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_suspended(sb, cnt)) {\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\ncontinue;\r\n}\r\ninode = dqopt->files[cnt];\r\ndqopt->files[cnt] = NULL;\r\nspin_lock(&dq_state_lock);\r\nflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\r\nDQUOT_LIMITS_ENABLED,\r\ncnt);\r\ndqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\r\nspin_unlock(&dq_state_lock);\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nflags = dquot_generic_flag(flags, cnt);\r\nret = vfs_load_quota_inode(inode, cnt,\r\ndqopt->info[cnt].dqi_fmt_id, flags);\r\niput(inode);\r\n}\r\nreturn ret;\r\n}\r\nint dquot_quota_on(struct super_block *sb, int type, int format_id,\r\nstruct path *path)\r\n{\r\nint error = security_quota_on(path->dentry);\r\nif (error)\r\nreturn error;\r\nif (path->dentry->d_sb != sb)\r\nerror = -EXDEV;\r\nelse\r\nerror = vfs_load_quota_inode(path->dentry->d_inode, type,\r\nformat_id, DQUOT_USAGE_ENABLED |\r\nDQUOT_LIMITS_ENABLED);\r\nreturn error;\r\n}\r\nint dquot_enable(struct inode *inode, int type, int format_id,\r\nunsigned int flags)\r\n{\r\nint ret = 0;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct quota_info *dqopt = sb_dqopt(sb);\r\nBUG_ON(flags & DQUOT_SUSPENDED);\r\nif (!flags)\r\nreturn 0;\r\nif (sb_has_quota_loaded(sb, type)) {\r\nmutex_lock(&dqopt->dqonoff_mutex);\r\nif (!sb_has_quota_loaded(sb, type)) {\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\ngoto load_quota;\r\n}\r\nif (flags & DQUOT_USAGE_ENABLED &&\r\nsb_has_quota_usage_enabled(sb, type)) {\r\nret = -EBUSY;\r\ngoto out_lock;\r\n}\r\nif (flags & DQUOT_LIMITS_ENABLED &&\r\nsb_has_quota_limits_enabled(sb, type)) {\r\nret = -EBUSY;\r\ngoto out_lock;\r\n}\r\nspin_lock(&dq_state_lock);\r\nsb_dqopt(sb)->flags |= dquot_state_flag(flags, type);\r\nspin_unlock(&dq_state_lock);\r\nout_lock:\r\nmutex_unlock(&dqopt->dqonoff_mutex);\r\nreturn ret;\r\n}\r\nload_quota:\r\nreturn vfs_load_quota_inode(inode, type, format_id, flags);\r\n}\r\nint dquot_quota_on_mount(struct super_block *sb, char *qf_name,\r\nint format_id, int type)\r\n{\r\nstruct dentry *dentry;\r\nint error;\r\nmutex_lock(&sb->s_root->d_inode->i_mutex);\r\ndentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));\r\nmutex_unlock(&sb->s_root->d_inode->i_mutex);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nif (!dentry->d_inode) {\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nerror = security_quota_on(dentry);\r\nif (!error)\r\nerror = vfs_load_quota_inode(dentry->d_inode, type, format_id,\r\nDQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\r\nout:\r\ndput(dentry);\r\nreturn error;\r\n}\r\nstatic inline qsize_t qbtos(qsize_t blocks)\r\n{\r\nreturn blocks << QIF_DQBLKSIZE_BITS;\r\n}\r\nstatic inline qsize_t stoqb(qsize_t space)\r\n{\r\nreturn (space + QIF_DQBLKSIZE - 1) >> QIF_DQBLKSIZE_BITS;\r\n}\r\nstatic void do_get_dqblk(struct dquot *dquot, struct fs_disk_quota *di)\r\n{\r\nstruct mem_dqblk *dm = &dquot->dq_dqb;\r\nmemset(di, 0, sizeof(*di));\r\ndi->d_version = FS_DQUOT_VERSION;\r\ndi->d_flags = dquot->dq_id.type == USRQUOTA ?\r\nFS_USER_QUOTA : FS_GROUP_QUOTA;\r\ndi->d_id = from_kqid_munged(current_user_ns(), dquot->dq_id);\r\nspin_lock(&dq_data_lock);\r\ndi->d_blk_hardlimit = stoqb(dm->dqb_bhardlimit);\r\ndi->d_blk_softlimit = stoqb(dm->dqb_bsoftlimit);\r\ndi->d_ino_hardlimit = dm->dqb_ihardlimit;\r\ndi->d_ino_softlimit = dm->dqb_isoftlimit;\r\ndi->d_bcount = dm->dqb_curspace + dm->dqb_rsvspace;\r\ndi->d_icount = dm->dqb_curinodes;\r\ndi->d_btimer = dm->dqb_btime;\r\ndi->d_itimer = dm->dqb_itime;\r\nspin_unlock(&dq_data_lock);\r\n}\r\nint dquot_get_dqblk(struct super_block *sb, struct kqid qid,\r\nstruct fs_disk_quota *di)\r\n{\r\nstruct dquot *dquot;\r\ndquot = dqget(sb, qid);\r\nif (!dquot)\r\nreturn -ESRCH;\r\ndo_get_dqblk(dquot, di);\r\ndqput(dquot);\r\nreturn 0;\r\n}\r\nstatic int do_set_dqblk(struct dquot *dquot, struct fs_disk_quota *di)\r\n{\r\nstruct mem_dqblk *dm = &dquot->dq_dqb;\r\nint check_blim = 0, check_ilim = 0;\r\nstruct mem_dqinfo *dqi = &sb_dqopt(dquot->dq_sb)->info[dquot->dq_id.type];\r\nif (di->d_fieldmask & ~VFS_FS_DQ_MASK)\r\nreturn -EINVAL;\r\nif (((di->d_fieldmask & FS_DQ_BSOFT) &&\r\n(di->d_blk_softlimit > dqi->dqi_maxblimit)) ||\r\n((di->d_fieldmask & FS_DQ_BHARD) &&\r\n(di->d_blk_hardlimit > dqi->dqi_maxblimit)) ||\r\n((di->d_fieldmask & FS_DQ_ISOFT) &&\r\n(di->d_ino_softlimit > dqi->dqi_maxilimit)) ||\r\n((di->d_fieldmask & FS_DQ_IHARD) &&\r\n(di->d_ino_hardlimit > dqi->dqi_maxilimit)))\r\nreturn -ERANGE;\r\nspin_lock(&dq_data_lock);\r\nif (di->d_fieldmask & FS_DQ_BCOUNT) {\r\ndm->dqb_curspace = di->d_bcount - dm->dqb_rsvspace;\r\ncheck_blim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & FS_DQ_BSOFT)\r\ndm->dqb_bsoftlimit = qbtos(di->d_blk_softlimit);\r\nif (di->d_fieldmask & FS_DQ_BHARD)\r\ndm->dqb_bhardlimit = qbtos(di->d_blk_hardlimit);\r\nif (di->d_fieldmask & (FS_DQ_BSOFT | FS_DQ_BHARD)) {\r\ncheck_blim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & FS_DQ_ICOUNT) {\r\ndm->dqb_curinodes = di->d_icount;\r\ncheck_ilim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & FS_DQ_ISOFT)\r\ndm->dqb_isoftlimit = di->d_ino_softlimit;\r\nif (di->d_fieldmask & FS_DQ_IHARD)\r\ndm->dqb_ihardlimit = di->d_ino_hardlimit;\r\nif (di->d_fieldmask & (FS_DQ_ISOFT | FS_DQ_IHARD)) {\r\ncheck_ilim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & FS_DQ_BTIMER) {\r\ndm->dqb_btime = di->d_btimer;\r\ncheck_blim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\r\n}\r\nif (di->d_fieldmask & FS_DQ_ITIMER) {\r\ndm->dqb_itime = di->d_itimer;\r\ncheck_ilim = 1;\r\nset_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\r\n}\r\nif (check_blim) {\r\nif (!dm->dqb_bsoftlimit ||\r\ndm->dqb_curspace < dm->dqb_bsoftlimit) {\r\ndm->dqb_btime = 0;\r\nclear_bit(DQ_BLKS_B, &dquot->dq_flags);\r\n} else if (!(di->d_fieldmask & FS_DQ_BTIMER))\r\ndm->dqb_btime = get_seconds() + dqi->dqi_bgrace;\r\n}\r\nif (check_ilim) {\r\nif (!dm->dqb_isoftlimit ||\r\ndm->dqb_curinodes < dm->dqb_isoftlimit) {\r\ndm->dqb_itime = 0;\r\nclear_bit(DQ_INODES_B, &dquot->dq_flags);\r\n} else if (!(di->d_fieldmask & FS_DQ_ITIMER))\r\ndm->dqb_itime = get_seconds() + dqi->dqi_igrace;\r\n}\r\nif (dm->dqb_bhardlimit || dm->dqb_bsoftlimit || dm->dqb_ihardlimit ||\r\ndm->dqb_isoftlimit)\r\nclear_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nelse\r\nset_bit(DQ_FAKE_B, &dquot->dq_flags);\r\nspin_unlock(&dq_data_lock);\r\nmark_dquot_dirty(dquot);\r\nreturn 0;\r\n}\r\nint dquot_set_dqblk(struct super_block *sb, struct kqid qid,\r\nstruct fs_disk_quota *di)\r\n{\r\nstruct dquot *dquot;\r\nint rc;\r\ndquot = dqget(sb, qid);\r\nif (!dquot) {\r\nrc = -ESRCH;\r\ngoto out;\r\n}\r\nrc = do_set_dqblk(dquot, di);\r\ndqput(dquot);\r\nout:\r\nreturn rc;\r\n}\r\nint dquot_get_dqinfo(struct super_block *sb, int type, struct if_dqinfo *ii)\r\n{\r\nstruct mem_dqinfo *mi;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nif (!sb_has_quota_active(sb, type)) {\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn -ESRCH;\r\n}\r\nmi = sb_dqopt(sb)->info + type;\r\nspin_lock(&dq_data_lock);\r\nii->dqi_bgrace = mi->dqi_bgrace;\r\nii->dqi_igrace = mi->dqi_igrace;\r\nii->dqi_flags = mi->dqi_flags & DQF_GETINFO_MASK;\r\nii->dqi_valid = IIF_ALL;\r\nspin_unlock(&dq_data_lock);\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn 0;\r\n}\r\nint dquot_set_dqinfo(struct super_block *sb, int type, struct if_dqinfo *ii)\r\n{\r\nstruct mem_dqinfo *mi;\r\nint err = 0;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nif (!sb_has_quota_active(sb, type)) {\r\nerr = -ESRCH;\r\ngoto out;\r\n}\r\nmi = sb_dqopt(sb)->info + type;\r\nspin_lock(&dq_data_lock);\r\nif (ii->dqi_valid & IIF_BGRACE)\r\nmi->dqi_bgrace = ii->dqi_bgrace;\r\nif (ii->dqi_valid & IIF_IGRACE)\r\nmi->dqi_igrace = ii->dqi_igrace;\r\nif (ii->dqi_valid & IIF_FLAGS)\r\nmi->dqi_flags = (mi->dqi_flags & ~DQF_SETINFO_MASK) |\r\n(ii->dqi_flags & DQF_SETINFO_MASK);\r\nspin_unlock(&dq_data_lock);\r\nmark_info_dirty(sb, type);\r\nsb->dq_op->write_info(sb, type);\r\nout:\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn err;\r\n}\r\nstatic int do_proc_dqstats(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nunsigned int type = (int *)table->data - dqstats.stat;\r\ndqstats.stat[type] =\r\npercpu_counter_sum_positive(&dqstats.counter[type]);\r\nreturn proc_dointvec(table, write, buffer, lenp, ppos);\r\n}\r\nstatic int __init dquot_init(void)\r\n{\r\nint i, ret;\r\nunsigned long nr_hash, order;\r\nprintk(KERN_NOTICE "VFS: Disk quotas %s\n", __DQUOT_VERSION__);\r\nregister_sysctl_table(sys_table);\r\ndquot_cachep = kmem_cache_create("dquot",\r\nsizeof(struct dquot), sizeof(unsigned long) * 4,\r\n(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD|SLAB_PANIC),\r\nNULL);\r\norder = 0;\r\ndquot_hash = (struct hlist_head *)__get_free_pages(GFP_ATOMIC, order);\r\nif (!dquot_hash)\r\npanic("Cannot create dquot hash table");\r\nfor (i = 0; i < _DQST_DQSTAT_LAST; i++) {\r\nret = percpu_counter_init(&dqstats.counter[i], 0);\r\nif (ret)\r\npanic("Cannot create dquot stat counters");\r\n}\r\nnr_hash = (1UL << order) * PAGE_SIZE / sizeof(struct hlist_head);\r\ndq_hash_bits = 0;\r\ndo {\r\ndq_hash_bits++;\r\n} while (nr_hash >> dq_hash_bits);\r\ndq_hash_bits--;\r\nnr_hash = 1UL << dq_hash_bits;\r\ndq_hash_mask = nr_hash - 1;\r\nfor (i = 0; i < nr_hash; i++)\r\nINIT_HLIST_HEAD(dquot_hash + i);\r\nprintk("Dquot-cache hash table entries: %ld (order %ld, %ld bytes)\n",\r\nnr_hash, order, (PAGE_SIZE << order));\r\nregister_shrinker(&dqcache_shrinker);\r\nreturn 0;\r\n}
