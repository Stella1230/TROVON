static u16 find_equiv_id(unsigned int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nint i = 0;\r\nif (!equiv_cpu_table)\r\nreturn 0;\r\nwhile (equiv_cpu_table[i].installed_cpu != 0) {\r\nif (uci->cpu_sig.sig == equiv_cpu_table[i].installed_cpu)\r\nreturn equiv_cpu_table[i].equiv_cpu;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 find_cpu_family_by_equiv_cpu(u16 equiv_cpu)\r\n{\r\nint i = 0;\r\nBUG_ON(!equiv_cpu_table);\r\nwhile (equiv_cpu_table[i].equiv_cpu != 0) {\r\nif (equiv_cpu == equiv_cpu_table[i].equiv_cpu)\r\nreturn equiv_cpu_table[i].installed_cpu;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ucode_patch *cache_find_patch(u16 equiv_cpu)\r\n{\r\nstruct ucode_patch *p;\r\nlist_for_each_entry(p, &pcache, plist)\r\nif (p->equiv_cpu == equiv_cpu)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic void update_cache(struct ucode_patch *new_patch)\r\n{\r\nstruct ucode_patch *p;\r\nlist_for_each_entry(p, &pcache, plist) {\r\nif (p->equiv_cpu == new_patch->equiv_cpu) {\r\nif (p->patch_id >= new_patch->patch_id)\r\nreturn;\r\nlist_replace(&p->plist, &new_patch->plist);\r\nkfree(p->data);\r\nkfree(p);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&new_patch->plist, &pcache);\r\n}\r\nstatic void free_cache(void)\r\n{\r\nstruct ucode_patch *p, *tmp;\r\nlist_for_each_entry_safe(p, tmp, &pcache, plist) {\r\n__list_del(p->plist.prev, p->plist.next);\r\nkfree(p->data);\r\nkfree(p);\r\n}\r\n}\r\nstatic struct ucode_patch *find_patch(unsigned int cpu)\r\n{\r\nu16 equiv_id;\r\nequiv_id = find_equiv_id(cpu);\r\nif (!equiv_id)\r\nreturn NULL;\r\nreturn cache_find_patch(equiv_id);\r\n}\r\nstatic int collect_cpu_info_amd(int cpu, struct cpu_signature *csig)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\ncsig->sig = cpuid_eax(0x00000001);\r\ncsig->rev = c->microcode;\r\npr_info("CPU%d: patch_level=0x%08x\n", cpu, csig->rev);\r\nreturn 0;\r\n}\r\nstatic unsigned int verify_patch_size(int cpu, u32 patch_size,\r\nunsigned int size)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nu32 max_size;\r\n#define F1XH_MPB_MAX_SIZE 2048\r\n#define F14H_MPB_MAX_SIZE 1824\r\n#define F15H_MPB_MAX_SIZE 4096\r\n#define F16H_MPB_MAX_SIZE 3458\r\nswitch (c->x86) {\r\ncase 0x14:\r\nmax_size = F14H_MPB_MAX_SIZE;\r\nbreak;\r\ncase 0x15:\r\nmax_size = F15H_MPB_MAX_SIZE;\r\nbreak;\r\ncase 0x16:\r\nmax_size = F16H_MPB_MAX_SIZE;\r\nbreak;\r\ndefault:\r\nmax_size = F1XH_MPB_MAX_SIZE;\r\nbreak;\r\n}\r\nif (patch_size > min_t(u32, size, max_size)) {\r\npr_err("patch size mismatch\n");\r\nreturn 0;\r\n}\r\nreturn patch_size;\r\n}\r\nstatic int apply_microcode_amd(int cpu)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nstruct microcode_amd *mc_amd;\r\nstruct ucode_cpu_info *uci;\r\nstruct ucode_patch *p;\r\nu32 rev, dummy;\r\nBUG_ON(raw_smp_processor_id() != cpu);\r\nuci = ucode_cpu_info + cpu;\r\np = find_patch(cpu);\r\nif (!p)\r\nreturn 0;\r\nmc_amd = p->data;\r\nuci->mc = p->data;\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\r\nif (rev >= mc_amd->hdr.patch_id) {\r\nc->microcode = rev;\r\nreturn 0;\r\n}\r\nwrmsrl(MSR_AMD64_PATCH_LOADER, (u64)(long)&mc_amd->hdr.data_code);\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\r\nif (rev != mc_amd->hdr.patch_id) {\r\npr_err("CPU%d: update failed for patch_level=0x%08x\n",\r\ncpu, mc_amd->hdr.patch_id);\r\nreturn -1;\r\n}\r\npr_info("CPU%d: new patch_level=0x%08x\n", cpu, rev);\r\nuci->cpu_sig.rev = rev;\r\nc->microcode = rev;\r\nreturn 0;\r\n}\r\nstatic int install_equiv_cpu_table(const u8 *buf)\r\n{\r\nunsigned int *ibuf = (unsigned int *)buf;\r\nunsigned int type = ibuf[1];\r\nunsigned int size = ibuf[2];\r\nif (type != UCODE_EQUIV_CPU_TABLE_TYPE || !size) {\r\npr_err("empty section/"\r\n"invalid type field in container file section header\n");\r\nreturn -EINVAL;\r\n}\r\nequiv_cpu_table = vmalloc(size);\r\nif (!equiv_cpu_table) {\r\npr_err("failed to allocate equivalent CPU table\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(equiv_cpu_table, buf + CONTAINER_HDR_SZ, size);\r\nreturn size + CONTAINER_HDR_SZ;\r\n}\r\nstatic void free_equiv_cpu_table(void)\r\n{\r\nvfree(equiv_cpu_table);\r\nequiv_cpu_table = NULL;\r\n}\r\nstatic void cleanup(void)\r\n{\r\nfree_equiv_cpu_table();\r\nfree_cache();\r\n}\r\nstatic int verify_and_add_patch(unsigned int cpu, u8 *fw, unsigned int leftover)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nstruct microcode_header_amd *mc_hdr;\r\nstruct ucode_patch *patch;\r\nunsigned int patch_size, crnt_size, ret;\r\nu32 proc_fam;\r\nu16 proc_id;\r\npatch_size = *(u32 *)(fw + 4);\r\ncrnt_size = patch_size + SECTION_HDR_SIZE;\r\nmc_hdr = (struct microcode_header_amd *)(fw + SECTION_HDR_SIZE);\r\nproc_id = mc_hdr->processor_rev_id;\r\nproc_fam = find_cpu_family_by_equiv_cpu(proc_id);\r\nif (!proc_fam) {\r\npr_err("No patch family for equiv ID: 0x%04x\n", proc_id);\r\nreturn crnt_size;\r\n}\r\nproc_fam = ((proc_fam >> 8) & 0xf) + ((proc_fam >> 20) & 0xff);\r\nif (proc_fam != c->x86)\r\nreturn crnt_size;\r\nif (mc_hdr->nb_dev_id || mc_hdr->sb_dev_id) {\r\npr_err("Patch-ID 0x%08x: chipset-specific code unsupported.\n",\r\nmc_hdr->patch_id);\r\nreturn crnt_size;\r\n}\r\nret = verify_patch_size(cpu, patch_size, leftover);\r\nif (!ret) {\r\npr_err("Patch-ID 0x%08x: size mismatch.\n", mc_hdr->patch_id);\r\nreturn crnt_size;\r\n}\r\npatch = kzalloc(sizeof(*patch), GFP_KERNEL);\r\nif (!patch) {\r\npr_err("Patch allocation failure.\n");\r\nreturn -EINVAL;\r\n}\r\npatch->data = kzalloc(patch_size, GFP_KERNEL);\r\nif (!patch->data) {\r\npr_err("Patch data allocation failure.\n");\r\nkfree(patch);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(patch->data, fw + SECTION_HDR_SIZE, patch_size);\r\nINIT_LIST_HEAD(&patch->plist);\r\npatch->patch_id = mc_hdr->patch_id;\r\npatch->equiv_cpu = proc_id;\r\nupdate_cache(patch);\r\nreturn crnt_size;\r\n}\r\nstatic enum ucode_state load_microcode_amd(int cpu, const u8 *data, size_t size)\r\n{\r\nenum ucode_state ret = UCODE_ERROR;\r\nunsigned int leftover;\r\nu8 *fw = (u8 *)data;\r\nint crnt_size = 0;\r\nint offset;\r\noffset = install_equiv_cpu_table(data);\r\nif (offset < 0) {\r\npr_err("failed to create equivalent cpu table\n");\r\nreturn ret;\r\n}\r\nfw += offset;\r\nleftover = size - offset;\r\nif (*(u32 *)fw != UCODE_UCODE_TYPE) {\r\npr_err("invalid type field in container file section header\n");\r\nfree_equiv_cpu_table();\r\nreturn ret;\r\n}\r\nwhile (leftover) {\r\ncrnt_size = verify_and_add_patch(cpu, fw, leftover);\r\nif (crnt_size < 0)\r\nreturn ret;\r\nfw += crnt_size;\r\nleftover -= crnt_size;\r\n}\r\nreturn UCODE_OK;\r\n}\r\nstatic enum ucode_state request_microcode_amd(int cpu, struct device *device,\r\nbool refresh_fw)\r\n{\r\nchar fw_name[36] = "amd-ucode/microcode_amd.bin";\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nenum ucode_state ret = UCODE_NFOUND;\r\nconst struct firmware *fw;\r\nif (!refresh_fw || c->cpu_index != boot_cpu_data.cpu_index)\r\nreturn UCODE_OK;\r\nif (c->x86 >= 0x15)\r\nsnprintf(fw_name, sizeof(fw_name), "amd-ucode/microcode_amd_fam%.2xh.bin", c->x86);\r\nif (request_firmware(&fw, (const char *)fw_name, device)) {\r\npr_err("failed to load file %s\n", fw_name);\r\ngoto out;\r\n}\r\nret = UCODE_ERROR;\r\nif (*(u32 *)fw->data != UCODE_MAGIC) {\r\npr_err("invalid magic value (0x%08x)\n", *(u32 *)fw->data);\r\ngoto fw_release;\r\n}\r\nfree_equiv_cpu_table();\r\nret = load_microcode_amd(cpu, fw->data, fw->size);\r\nif (ret != UCODE_OK)\r\ncleanup();\r\nfw_release:\r\nrelease_firmware(fw);\r\nout:\r\nreturn ret;\r\n}\r\nstatic enum ucode_state\r\nrequest_microcode_user(int cpu, const void __user *buf, size_t size)\r\n{\r\nreturn UCODE_ERROR;\r\n}\r\nstatic void microcode_fini_cpu_amd(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nuci->mc = NULL;\r\n}\r\nstruct microcode_ops * __init init_amd_microcode(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nif (c->x86_vendor != X86_VENDOR_AMD || c->x86 < 0x10) {\r\npr_warning("AMD CPU family 0x%x not supported\n", c->x86);\r\nreturn NULL;\r\n}\r\nreturn &microcode_amd_ops;\r\n}\r\nvoid __exit exit_amd_microcode(void)\r\n{\r\ncleanup();\r\n}
