static size_t jffs2_acl_size(int count)\r\n{\r\nif (count <= 4) {\r\nreturn sizeof(struct jffs2_acl_header)\r\n+ count * sizeof(struct jffs2_acl_entry_short);\r\n} else {\r\nreturn sizeof(struct jffs2_acl_header)\r\n+ 4 * sizeof(struct jffs2_acl_entry_short)\r\n+ (count - 4) * sizeof(struct jffs2_acl_entry);\r\n}\r\n}\r\nstatic int jffs2_acl_count(size_t size)\r\n{\r\nsize_t s;\r\nsize -= sizeof(struct jffs2_acl_header);\r\nif (size < 4 * sizeof(struct jffs2_acl_entry_short)) {\r\nif (size % sizeof(struct jffs2_acl_entry_short))\r\nreturn -1;\r\nreturn size / sizeof(struct jffs2_acl_entry_short);\r\n} else {\r\ns = size - 4 * sizeof(struct jffs2_acl_entry_short);\r\nif (s % sizeof(struct jffs2_acl_entry))\r\nreturn -1;\r\nreturn s / sizeof(struct jffs2_acl_entry) + 4;\r\n}\r\n}\r\nstatic struct posix_acl *jffs2_acl_from_medium(void *value, size_t size)\r\n{\r\nvoid *end = value + size;\r\nstruct jffs2_acl_header *header = value;\r\nstruct jffs2_acl_entry *entry;\r\nstruct posix_acl *acl;\r\nuint32_t ver;\r\nint i, count;\r\nif (!value)\r\nreturn NULL;\r\nif (size < sizeof(struct jffs2_acl_header))\r\nreturn ERR_PTR(-EINVAL);\r\nver = je32_to_cpu(header->a_version);\r\nif (ver != JFFS2_ACL_VERSION) {\r\nJFFS2_WARNING("Invalid ACL version. (=%u)\n", ver);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvalue += sizeof(struct jffs2_acl_header);\r\ncount = jffs2_acl_count(size);\r\nif (count < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (count == 0)\r\nreturn NULL;\r\nacl = posix_acl_alloc(count, GFP_KERNEL);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i=0; i < count; i++) {\r\nentry = value;\r\nif (value + sizeof(struct jffs2_acl_entry_short) > end)\r\ngoto fail;\r\nacl->a_entries[i].e_tag = je16_to_cpu(entry->e_tag);\r\nacl->a_entries[i].e_perm = je16_to_cpu(entry->e_perm);\r\nswitch (acl->a_entries[i].e_tag) {\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\nvalue += sizeof(struct jffs2_acl_entry_short);\r\nbreak;\r\ncase ACL_USER:\r\nvalue += sizeof(struct jffs2_acl_entry);\r\nif (value > end)\r\ngoto fail;\r\nacl->a_entries[i].e_uid =\r\nmake_kuid(&init_user_ns,\r\nje32_to_cpu(entry->e_id));\r\nbreak;\r\ncase ACL_GROUP:\r\nvalue += sizeof(struct jffs2_acl_entry);\r\nif (value > end)\r\ngoto fail;\r\nacl->a_entries[i].e_gid =\r\nmake_kgid(&init_user_ns,\r\nje32_to_cpu(entry->e_id));\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nif (value != end)\r\ngoto fail;\r\nreturn acl;\r\nfail:\r\nposix_acl_release(acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void *jffs2_acl_to_medium(const struct posix_acl *acl, size_t *size)\r\n{\r\nstruct jffs2_acl_header *header;\r\nstruct jffs2_acl_entry *entry;\r\nvoid *e;\r\nsize_t i;\r\n*size = jffs2_acl_size(acl->a_count);\r\nheader = kmalloc(sizeof(*header) + acl->a_count * sizeof(*entry), GFP_KERNEL);\r\nif (!header)\r\nreturn ERR_PTR(-ENOMEM);\r\nheader->a_version = cpu_to_je32(JFFS2_ACL_VERSION);\r\ne = header + 1;\r\nfor (i=0; i < acl->a_count; i++) {\r\nconst struct posix_acl_entry *acl_e = &acl->a_entries[i];\r\nentry = e;\r\nentry->e_tag = cpu_to_je16(acl_e->e_tag);\r\nentry->e_perm = cpu_to_je16(acl_e->e_perm);\r\nswitch(acl_e->e_tag) {\r\ncase ACL_USER:\r\nentry->e_id = cpu_to_je32(\r\nfrom_kuid(&init_user_ns, acl_e->e_uid));\r\ne += sizeof(struct jffs2_acl_entry);\r\nbreak;\r\ncase ACL_GROUP:\r\nentry->e_id = cpu_to_je32(\r\nfrom_kgid(&init_user_ns, acl_e->e_gid));\r\ne += sizeof(struct jffs2_acl_entry);\r\nbreak;\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\ne += sizeof(struct jffs2_acl_entry_short);\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nreturn header;\r\nfail:\r\nkfree(header);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstruct posix_acl *jffs2_get_acl(struct inode *inode, int type)\r\n{\r\nstruct posix_acl *acl;\r\nchar *value = NULL;\r\nint rc, xprefix;\r\nacl = get_cached_acl(inode, type);\r\nif (acl != ACL_NOT_CACHED)\r\nreturn acl;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nxprefix = JFFS2_XPREFIX_ACL_ACCESS;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nxprefix = JFFS2_XPREFIX_ACL_DEFAULT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nrc = do_jffs2_getxattr(inode, xprefix, "", NULL, 0);\r\nif (rc > 0) {\r\nvalue = kmalloc(rc, GFP_KERNEL);\r\nif (!value)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = do_jffs2_getxattr(inode, xprefix, "", value, rc);\r\n}\r\nif (rc > 0) {\r\nacl = jffs2_acl_from_medium(value, rc);\r\n} else if (rc == -ENODATA || rc == -ENOSYS) {\r\nacl = NULL;\r\n} else {\r\nacl = ERR_PTR(rc);\r\n}\r\nif (value)\r\nkfree(value);\r\nif (!IS_ERR(acl))\r\nset_cached_acl(inode, type, acl);\r\nreturn acl;\r\n}\r\nstatic int __jffs2_set_acl(struct inode *inode, int xprefix, struct posix_acl *acl)\r\n{\r\nchar *value = NULL;\r\nsize_t size = 0;\r\nint rc;\r\nif (acl) {\r\nvalue = jffs2_acl_to_medium(acl, &size);\r\nif (IS_ERR(value))\r\nreturn PTR_ERR(value);\r\n}\r\nrc = do_jffs2_setxattr(inode, xprefix, "", value, size, 0);\r\nif (!value && rc == -ENODATA)\r\nrc = 0;\r\nkfree(value);\r\nreturn rc;\r\n}\r\nstatic int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)\r\n{\r\nint rc, xprefix;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nxprefix = JFFS2_XPREFIX_ACL_ACCESS;\r\nif (acl) {\r\numode_t mode = inode->i_mode;\r\nrc = posix_acl_equiv_mode(acl, &mode);\r\nif (rc < 0)\r\nreturn rc;\r\nif (inode->i_mode != mode) {\r\nstruct iattr attr;\r\nattr.ia_valid = ATTR_MODE | ATTR_CTIME;\r\nattr.ia_mode = mode;\r\nattr.ia_ctime = CURRENT_TIME_SEC;\r\nrc = jffs2_do_setattr(inode, &attr);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (rc == 0)\r\nacl = NULL;\r\n}\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nxprefix = JFFS2_XPREFIX_ACL_DEFAULT;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn acl ? -EACCES : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrc = __jffs2_set_acl(inode, xprefix, acl);\r\nif (!rc)\r\nset_cached_acl(inode, type, acl);\r\nreturn rc;\r\n}\r\nint jffs2_init_acl_pre(struct inode *dir_i, struct inode *inode, umode_t *i_mode)\r\n{\r\nstruct posix_acl *acl;\r\nint rc;\r\ncache_no_acl(inode);\r\nif (S_ISLNK(*i_mode))\r\nreturn 0;\r\nacl = jffs2_get_acl(dir_i, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (!acl) {\r\n*i_mode &= ~current_umask();\r\n} else {\r\nif (S_ISDIR(*i_mode))\r\nset_cached_acl(inode, ACL_TYPE_DEFAULT, acl);\r\nrc = posix_acl_create(&acl, GFP_KERNEL, i_mode);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc > 0)\r\nset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\r\nposix_acl_release(acl);\r\n}\r\nreturn 0;\r\n}\r\nint jffs2_init_acl_post(struct inode *inode)\r\n{\r\nint rc;\r\nif (inode->i_default_acl) {\r\nrc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (inode->i_acl) {\r\nrc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint jffs2_acl_chmod(struct inode *inode)\r\n{\r\nstruct posix_acl *acl;\r\nint rc;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nacl = jffs2_get_acl(inode, ACL_TYPE_ACCESS);\r\nif (IS_ERR(acl) || !acl)\r\nreturn PTR_ERR(acl);\r\nrc = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\r\nif (rc)\r\nreturn rc;\r\nrc = jffs2_set_acl(inode, ACL_TYPE_ACCESS, acl);\r\nposix_acl_release(acl);\r\nreturn rc;\r\n}\r\nstatic size_t jffs2_acl_access_listxattr(struct dentry *dentry, char *list,\r\nsize_t list_size, const char *name, size_t name_len, int type)\r\n{\r\nconst int retlen = sizeof(POSIX_ACL_XATTR_ACCESS);\r\nif (list && retlen <= list_size)\r\nstrcpy(list, POSIX_ACL_XATTR_ACCESS);\r\nreturn retlen;\r\n}\r\nstatic size_t jffs2_acl_default_listxattr(struct dentry *dentry, char *list,\r\nsize_t list_size, const char *name, size_t name_len, int type)\r\n{\r\nconst int retlen = sizeof(POSIX_ACL_XATTR_DEFAULT);\r\nif (list && retlen <= list_size)\r\nstrcpy(list, POSIX_ACL_XATTR_DEFAULT);\r\nreturn retlen;\r\n}\r\nstatic int jffs2_acl_getxattr(struct dentry *dentry, const char *name,\r\nvoid *buffer, size_t size, int type)\r\n{\r\nstruct posix_acl *acl;\r\nint rc;\r\nif (name[0] != '\0')\r\nreturn -EINVAL;\r\nacl = jffs2_get_acl(dentry->d_inode, type);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (!acl)\r\nreturn -ENODATA;\r\nrc = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\r\nposix_acl_release(acl);\r\nreturn rc;\r\n}\r\nstatic int jffs2_acl_setxattr(struct dentry *dentry, const char *name,\r\nconst void *value, size_t size, int flags, int type)\r\n{\r\nstruct posix_acl *acl;\r\nint rc;\r\nif (name[0] != '\0')\r\nreturn -EINVAL;\r\nif (!inode_owner_or_capable(dentry->d_inode))\r\nreturn -EPERM;\r\nif (value) {\r\nacl = posix_acl_from_xattr(&init_user_ns, value, size);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (acl) {\r\nrc = posix_acl_valid(acl);\r\nif (rc)\r\ngoto out;\r\n}\r\n} else {\r\nacl = NULL;\r\n}\r\nrc = jffs2_set_acl(dentry->d_inode, type, acl);\r\nout:\r\nposix_acl_release(acl);\r\nreturn rc;\r\n}
