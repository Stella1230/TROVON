static struct i2c_client *attach_i2c_chip(int id, const char *name)\r\n{\r\nstruct i2c_client *clt;\r\nstruct i2c_adapter *adap;\r\nstruct i2c_board_info info;\r\nif (id & 0x200)\r\nadap = k2;\r\nelse if (id & 0x100)\r\nadap = u3_1;\r\nelse\r\nadap = u3_0;\r\nif (adap == NULL)\r\nreturn NULL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = (id >> 1) & 0x7f;\r\nstrlcpy(info.type, "therm_pm72", I2C_NAME_SIZE);\r\nclt = i2c_new_device(adap, &info);\r\nif (!clt) {\r\nprintk(KERN_ERR "therm_pm72: Failed to attach to i2c ID 0x%x\n", id);\r\nreturn NULL;\r\n}\r\nlist_add_tail(&clt->detected, &therm_pm72_driver.clients);\r\nreturn clt;\r\n}\r\nstatic void initialize_adc(struct cpu_pid_state *state)\r\n{\r\nint rc;\r\nu8 buf[2];\r\nbuf[0] = 5;\r\nbuf[1] = 0;\r\ni2c_master_send(state->monitor, buf, 2);\r\nbuf[0] = 1;\r\nrc = i2c_master_send(state->monitor, buf, 1);\r\nif (rc > 0) {\r\nrc = i2c_master_recv(state->monitor, buf, 1);\r\nif (rc > 0) {\r\nstate->adc_config = buf[0];\r\nDBG("ADC config reg: %02x\n", state->adc_config);\r\nstate->adc_config &= 0xfe;\r\nbuf[0] = 1;\r\nbuf[1] = state->adc_config;\r\nrc = i2c_master_send(state->monitor, buf, 2);\r\n}\r\n}\r\nif (rc <= 0)\r\nprintk(KERN_ERR "therm_pm72: Error reading ADC config"\r\n" register !\n");\r\n}\r\nstatic int read_smon_adc(struct cpu_pid_state *state, int chan)\r\n{\r\nint rc, data, tries = 0;\r\nu8 buf[2];\r\nfor (;;) {\r\nbuf[0] = 1;\r\nbuf[1] = (state->adc_config & 0x1f) | (chan << 5);\r\nrc = i2c_master_send(state->monitor, buf, 2);\r\nif (rc <= 0)\r\ngoto error;\r\nmsleep(1);\r\nbuf[0] = 4;\r\nrc = i2c_master_send(state->monitor, buf, 1);\r\nif (rc <= 0)\r\ngoto error;\r\nrc = i2c_master_recv(state->monitor, buf, 2);\r\nif (rc < 0)\r\ngoto error;\r\ndata = ((u16)buf[0]) << 8 | (u16)buf[1];\r\nreturn data >> 6;\r\nerror:\r\nDBG("Error reading ADC, retrying...\n");\r\nif (++tries > 10) {\r\nprintk(KERN_ERR "therm_pm72: Error reading ADC !\n");\r\nreturn -1;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nstatic int read_lm87_reg(struct i2c_client * chip, int reg)\r\n{\r\nint rc, tries = 0;\r\nu8 buf;\r\nfor (;;) {\r\nbuf = (u8)reg;\r\nrc = i2c_master_send(chip, &buf, 1);\r\nif (rc <= 0)\r\ngoto error;\r\nrc = i2c_master_recv(chip, &buf, 1);\r\nif (rc <= 0)\r\ngoto error;\r\nreturn (int)buf;\r\nerror:\r\nDBG("Error reading LM87, retrying...\n");\r\nif (++tries > 10) {\r\nprintk(KERN_ERR "therm_pm72: Error reading LM87 !\n");\r\nreturn -1;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nstatic int fan_read_reg(int reg, unsigned char *buf, int nb)\r\n{\r\nint tries, nr, nw;\r\nbuf[0] = reg;\r\ntries = 0;\r\nfor (;;) {\r\nnw = i2c_master_send(fcu, buf, 1);\r\nif (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)\r\nbreak;\r\nmsleep(10);\r\n++tries;\r\n}\r\nif (nw <= 0) {\r\nprintk(KERN_ERR "Failure writing address to FCU: %d", nw);\r\nreturn -EIO;\r\n}\r\ntries = 0;\r\nfor (;;) {\r\nnr = i2c_master_recv(fcu, buf, nb);\r\nif (nr > 0 || (nr < 0 && nr != -ENODEV) || tries >= 100)\r\nbreak;\r\nmsleep(10);\r\n++tries;\r\n}\r\nif (nr <= 0)\r\nprintk(KERN_ERR "Failure reading data from FCU: %d", nw);\r\nreturn nr;\r\n}\r\nstatic int fan_write_reg(int reg, const unsigned char *ptr, int nb)\r\n{\r\nint tries, nw;\r\nunsigned char buf[16];\r\nbuf[0] = reg;\r\nmemcpy(buf+1, ptr, nb);\r\n++nb;\r\ntries = 0;\r\nfor (;;) {\r\nnw = i2c_master_send(fcu, buf, nb);\r\nif (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)\r\nbreak;\r\nmsleep(10);\r\n++tries;\r\n}\r\nif (nw < 0)\r\nprintk(KERN_ERR "Failure writing to FCU: %d", nw);\r\nreturn nw;\r\n}\r\nstatic int start_fcu(void)\r\n{\r\nunsigned char buf = 0xff;\r\nint rc;\r\nrc = fan_write_reg(0xe, &buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\nrc = fan_write_reg(0x2e, &buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\nrc = fan_read_reg(0, &buf, 1);\r\nif (rc < 0)\r\nreturn -EIO;\r\nfcu_rpm_shift = (buf == 1) ? 2 : 3;\r\nprintk(KERN_DEBUG "FCU Initialized, RPM fan shift is %d\n",\r\nfcu_rpm_shift);\r\nreturn 0;\r\n}\r\nstatic int set_rpm_fan(int fan_index, int rpm)\r\n{\r\nunsigned char buf[2];\r\nint rc, id, min, max;\r\nif (fcu_fans[fan_index].type != FCU_FAN_RPM)\r\nreturn -EINVAL;\r\nid = fcu_fans[fan_index].id;\r\nif (id == FCU_FAN_ABSENT_ID)\r\nreturn -EINVAL;\r\nmin = 2400 >> fcu_rpm_shift;\r\nmax = 56000 >> fcu_rpm_shift;\r\nif (rpm < min)\r\nrpm = min;\r\nelse if (rpm > max)\r\nrpm = max;\r\nbuf[0] = rpm >> (8 - fcu_rpm_shift);\r\nbuf[1] = rpm << fcu_rpm_shift;\r\nrc = fan_write_reg(0x10 + (id * 2), buf, 2);\r\nif (rc < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int get_rpm_fan(int fan_index, int programmed)\r\n{\r\nunsigned char failure;\r\nunsigned char active;\r\nunsigned char buf[2];\r\nint rc, id, reg_base;\r\nif (fcu_fans[fan_index].type != FCU_FAN_RPM)\r\nreturn -EINVAL;\r\nid = fcu_fans[fan_index].id;\r\nif (id == FCU_FAN_ABSENT_ID)\r\nreturn -EINVAL;\r\nrc = fan_read_reg(0xb, &failure, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((failure & (1 << id)) != 0)\r\nreturn -EFAULT;\r\nrc = fan_read_reg(0xd, &active, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((active & (1 << id)) == 0)\r\nreturn -ENXIO;\r\nreg_base = programmed ? 0x10 : 0x11;\r\nrc = fan_read_reg(reg_base + (id * 2), buf, 2);\r\nif (rc != 2)\r\nreturn -EIO;\r\nreturn (buf[0] << (8 - fcu_rpm_shift)) | buf[1] >> fcu_rpm_shift;\r\n}\r\nstatic int set_pwm_fan(int fan_index, int pwm)\r\n{\r\nunsigned char buf[2];\r\nint rc, id;\r\nif (fcu_fans[fan_index].type != FCU_FAN_PWM)\r\nreturn -EINVAL;\r\nid = fcu_fans[fan_index].id;\r\nif (id == FCU_FAN_ABSENT_ID)\r\nreturn -EINVAL;\r\nif (pwm < 10)\r\npwm = 10;\r\nelse if (pwm > 100)\r\npwm = 100;\r\npwm = (pwm * 2559) / 1000;\r\nbuf[0] = pwm;\r\nrc = fan_write_reg(0x30 + (id * 2), buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int get_pwm_fan(int fan_index)\r\n{\r\nunsigned char failure;\r\nunsigned char active;\r\nunsigned char buf[2];\r\nint rc, id;\r\nif (fcu_fans[fan_index].type != FCU_FAN_PWM)\r\nreturn -EINVAL;\r\nid = fcu_fans[fan_index].id;\r\nif (id == FCU_FAN_ABSENT_ID)\r\nreturn -EINVAL;\r\nrc = fan_read_reg(0x2b, &failure, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((failure & (1 << id)) != 0)\r\nreturn -EFAULT;\r\nrc = fan_read_reg(0x2d, &active, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nif ((active & (1 << id)) == 0)\r\nreturn -ENXIO;\r\nrc = fan_read_reg(0x30 + (id * 2), buf, 1);\r\nif (rc != 1)\r\nreturn -EIO;\r\nreturn (buf[0] * 1000) / 2559;\r\n}\r\nstatic void tickle_fcu(void)\r\n{\r\nint pwm;\r\npwm = get_pwm_fan(SLOTS_FAN_PWM_INDEX);\r\nDBG("FCU Tickle, slots fan is: %d\n", pwm);\r\nif (pwm < 0)\r\npwm = 100;\r\nif (!rackmac) {\r\npwm = SLOTS_FAN_DEFAULT_PWM;\r\n} else if (pwm < SLOTS_PID_OUTPUT_MIN)\r\npwm = SLOTS_PID_OUTPUT_MIN;\r\nset_pwm_fan(SLOTS_FAN_PWM_INDEX, pwm);\r\n}\r\nstatic int read_eeprom(int cpu, struct mpu_data *out)\r\n{\r\nstruct device_node *np;\r\nchar nodename[64];\r\nconst u8 *data;\r\nint len;\r\nsprintf(nodename, "/u3@0,f8000000/i2c@f8001000/cpuid@a%d", cpu ? 2 : 0);\r\nnp = of_find_node_by_path(nodename);\r\nif (np == NULL) {\r\nprintk(KERN_ERR "therm_pm72: Failed to retrieve cpuid node from device-tree\n");\r\nreturn -ENODEV;\r\n}\r\ndata = of_get_property(np, "cpuid", &len);\r\nif (data == NULL) {\r\nprintk(KERN_ERR "therm_pm72: Failed to retrieve cpuid property from device-tree\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nmemcpy(out, data, sizeof(struct mpu_data));\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic void fetch_cpu_pumps_minmax(void)\r\n{\r\nstruct cpu_pid_state *state0 = &processor_state[0];\r\nstruct cpu_pid_state *state1 = &processor_state[1];\r\nu16 pump_min = 0, pump_max = 0xffff;\r\nu16 tmp[4];\r\nmemcpy(&tmp, &state0->mpu.processor_part_num, 8);\r\nif (tmp[0] != 0xffff && tmp[1] != 0xffff) {\r\npump_min = max(pump_min, tmp[0]);\r\npump_max = min(pump_max, tmp[1]);\r\n}\r\nif (tmp[2] != 0xffff && tmp[3] != 0xffff) {\r\npump_min = max(pump_min, tmp[2]);\r\npump_max = min(pump_max, tmp[3]);\r\n}\r\nif (pump_min == pump_max || pump_min == 0 || pump_max == 0xffff) {\r\npump_min = CPU_PUMP_OUTPUT_MIN;\r\npump_max = CPU_PUMP_OUTPUT_MAX;\r\n}\r\nstate0->pump_min = state1->pump_min = pump_min;\r\nstate0->pump_max = state1->pump_max = pump_max;\r\n}\r\nstatic int do_read_one_cpu_values(struct cpu_pid_state *state, s32 *temp, s32 *power)\r\n{\r\ns32 ltemp, volts, amps;\r\nint index, rc = 0;\r\n*temp = state->cur_temp;\r\n*power = state->cur_power;\r\nif (cpu_pid_type == CPU_PID_TYPE_RACKMAC)\r\nindex = (state->index == 0) ?\r\nCPU_A1_FAN_RPM_INDEX : CPU_B1_FAN_RPM_INDEX;\r\nelse\r\nindex = (state->index == 0) ?\r\nCPUA_EXHAUST_FAN_RPM_INDEX : CPUB_EXHAUST_FAN_RPM_INDEX;\r\nrc = get_rpm_fan(index, !RPM_PID_USE_ACTUAL_SPEED);\r\nif (rc < 0) {\r\nDBG(" cpu %d, fan reading error !\n", state->index);\r\n} else {\r\nstate->rpm = rc;\r\nDBG(" cpu %d, exhaust RPM: %d\n", state->index, state->rpm);\r\n}\r\nltemp = read_smon_adc(state, 1);\r\nif (ltemp == -1) {\r\nstate->overtemp++;\r\nif (rc == 0)\r\nrc = -EIO;\r\nDBG(" cpu %d, temp reading error !\n", state->index);\r\n} else {\r\nDBG(" cpu %d, temp raw: %04x, m_diode: %04x, b_diode: %04x\n",\r\nstate->index,\r\nltemp, state->mpu.mdiode, state->mpu.bdiode);\r\n*temp = ((s32)ltemp * (s32)state->mpu.mdiode + ((s32)state->mpu.bdiode << 12)) >> 2;\r\nstate->last_temp = *temp;\r\nDBG(" temp: %d.%03d\n", FIX32TOPRINT((*temp)));\r\n}\r\nvolts = read_smon_adc(state, 3);\r\namps = read_smon_adc(state, 4);\r\nvolts *= ADC_CPU_VOLTAGE_SCALE;\r\namps *= ADC_CPU_CURRENT_SCALE;\r\n*power = (((u64)volts) * ((u64)amps)) >> 16;\r\nstate->voltage = volts;\r\nstate->current_a = amps;\r\nstate->last_power = *power;\r\nDBG(" cpu %d, current: %d.%03d, voltage: %d.%03d, power: %d.%03d W\n",\r\nstate->index, FIX32TOPRINT(state->current_a),\r\nFIX32TOPRINT(state->voltage), FIX32TOPRINT(*power));\r\nreturn 0;\r\n}\r\nstatic void do_cpu_pid(struct cpu_pid_state *state, s32 temp, s32 power)\r\n{\r\ns32 power_target, integral, derivative, proportional, adj_in_target, sval;\r\ns64 integ_p, deriv_p, prop_p, sum;\r\nint i;\r\npower_target = ((u32)(state->mpu.pmaxh - state->mpu.padjmax)) << 16;\r\nDBG(" power target: %d.%03d, error: %d.%03d\n",\r\nFIX32TOPRINT(power_target), FIX32TOPRINT(power_target - power));\r\nstate->cur_temp = (state->cur_temp + 1) % CPU_TEMP_HISTORY_SIZE;\r\nstate->temp_history[state->cur_temp] = temp;\r\nstate->cur_power = (state->cur_power + 1) % state->count_power;\r\nstate->power_history[state->cur_power] = power;\r\nstate->error_history[state->cur_power] = power_target - power;\r\nif (state->first) {\r\nfor (i = 0; i < (state->count_power - 1); i++) {\r\nstate->cur_power = (state->cur_power + 1) % state->count_power;\r\nstate->power_history[state->cur_power] = power;\r\nstate->error_history[state->cur_power] = power_target - power;\r\n}\r\nfor (i = 0; i < (CPU_TEMP_HISTORY_SIZE - 1); i++) {\r\nstate->cur_temp = (state->cur_temp + 1) % CPU_TEMP_HISTORY_SIZE;\r\nstate->temp_history[state->cur_temp] = temp;\r\n}\r\nstate->first = 0;\r\n}\r\nsum = 0;\r\nintegral = 0;\r\nfor (i = 0; i < state->count_power; i++)\r\nintegral += state->error_history[i];\r\nintegral *= CPU_PID_INTERVAL;\r\nDBG(" integral: %08x\n", integral);\r\ninteg_p = ((s64)state->mpu.pid_gr) * (s64)integral;\r\nDBG(" integ_p: %d\n", (int)(integ_p >> 36));\r\nsval = (state->mpu.tmax << 16) - ((integ_p >> 20) & 0xffffffff);\r\nadj_in_target = (state->mpu.ttarget << 16);\r\nif (adj_in_target > sval)\r\nadj_in_target = sval;\r\nDBG(" adj_in_target: %d.%03d, ttarget: %d\n", FIX32TOPRINT(adj_in_target),\r\nstate->mpu.ttarget);\r\nderivative = state->temp_history[state->cur_temp] -\r\nstate->temp_history[(state->cur_temp + CPU_TEMP_HISTORY_SIZE - 1)\r\n% CPU_TEMP_HISTORY_SIZE];\r\nderivative /= CPU_PID_INTERVAL;\r\nderiv_p = ((s64)state->mpu.pid_gd) * (s64)derivative;\r\nDBG(" deriv_p: %d\n", (int)(deriv_p >> 36));\r\nsum += deriv_p;\r\nproportional = temp - adj_in_target;\r\nprop_p = ((s64)state->mpu.pid_gp) * (s64)proportional;\r\nDBG(" prop_p: %d\n", (int)(prop_p >> 36));\r\nsum += prop_p;\r\nsum >>= 36;\r\nDBG(" sum: %d\n", (int)sum);\r\nstate->rpm += (s32)sum;\r\n}\r\nstatic void do_monitor_cpu_combined(void)\r\n{\r\nstruct cpu_pid_state *state0 = &processor_state[0];\r\nstruct cpu_pid_state *state1 = &processor_state[1];\r\ns32 temp0, power0, temp1, power1;\r\ns32 temp_combi, power_combi;\r\nint rc, intake, pump;\r\nrc = do_read_one_cpu_values(state0, &temp0, &power0);\r\nif (rc < 0) {\r\n}\r\nstate1->overtemp = 0;\r\nrc = do_read_one_cpu_values(state1, &temp1, &power1);\r\nif (rc < 0) {\r\n}\r\nif (state1->overtemp)\r\nstate0->overtemp++;\r\ntemp_combi = max(temp0, temp1);\r\npower_combi = max(power0, power1);\r\nif (temp_combi >= ((state0->mpu.tmax + 8) << 16)) {\r\nprintk(KERN_WARNING "Warning ! Temperature way above maximum (%d) !\n",\r\ntemp_combi >> 16);\r\nstate0->overtemp += CPU_MAX_OVERTEMP / 4;\r\n} else if (temp_combi > (state0->mpu.tmax << 16)) {\r\nstate0->overtemp++;\r\nprintk(KERN_WARNING "Temperature %d above max %d. overtemp %d\n",\r\ntemp_combi >> 16, state0->mpu.tmax, state0->overtemp);\r\n} else {\r\nif (state0->overtemp)\r\nprintk(KERN_WARNING "Temperature back down to %d\n",\r\ntemp_combi >> 16);\r\nstate0->overtemp = 0;\r\n}\r\nif (state0->overtemp >= CPU_MAX_OVERTEMP)\r\ncritical_state = 1;\r\nif (state0->overtemp > 0) {\r\nstate0->rpm = state0->mpu.rmaxn_exhaust_fan;\r\nstate0->intake_rpm = intake = state0->mpu.rmaxn_intake_fan;\r\npump = state0->pump_max;\r\ngoto do_set_fans;\r\n}\r\ndo_cpu_pid(state0, temp_combi, power_combi);\r\nstate0->rpm = max(state0->rpm, (int)state0->mpu.rminn_exhaust_fan);\r\nstate0->rpm = min(state0->rpm, (int)state0->mpu.rmaxn_exhaust_fan);\r\nintake = (state0->rpm * CPU_INTAKE_SCALE) >> 16;\r\nintake = max(intake, (int)state0->mpu.rminn_intake_fan);\r\nintake = min(intake, (int)state0->mpu.rmaxn_intake_fan);\r\nstate0->intake_rpm = intake;\r\npump = (state0->rpm * state0->pump_max) /\r\nstate0->mpu.rmaxn_exhaust_fan;\r\npump = min(pump, state0->pump_max);\r\npump = max(pump, state0->pump_min);\r\ndo_set_fans:\r\nstate1->rpm = state0->rpm;\r\nstate1->intake_rpm = state0->intake_rpm;\r\nDBG("** CPU %d RPM: %d Ex, %d, Pump: %d, In, overtemp: %d\n",\r\nstate1->index, (int)state1->rpm, intake, pump, state1->overtemp);\r\nset_rpm_fan(CPUA_INTAKE_FAN_RPM_INDEX, intake);\r\nset_rpm_fan(CPUA_EXHAUST_FAN_RPM_INDEX, state0->rpm);\r\nset_rpm_fan(CPUB_INTAKE_FAN_RPM_INDEX, intake);\r\nset_rpm_fan(CPUB_EXHAUST_FAN_RPM_INDEX, state0->rpm);\r\nif (fcu_fans[CPUA_PUMP_RPM_INDEX].id != FCU_FAN_ABSENT_ID)\r\nset_rpm_fan(CPUA_PUMP_RPM_INDEX, pump);\r\nif (fcu_fans[CPUB_PUMP_RPM_INDEX].id != FCU_FAN_ABSENT_ID)\r\nset_rpm_fan(CPUB_PUMP_RPM_INDEX, pump);\r\n}\r\nstatic void do_monitor_cpu_split(struct cpu_pid_state *state)\r\n{\r\ns32 temp, power;\r\nint rc, intake;\r\nrc = do_read_one_cpu_values(state, &temp, &power);\r\nif (rc < 0) {\r\n}\r\nif (temp >= ((state->mpu.tmax + 8) << 16)) {\r\nprintk(KERN_WARNING "Warning ! CPU %d temperature way above maximum"\r\n" (%d) !\n",\r\nstate->index, temp >> 16);\r\nstate->overtemp += CPU_MAX_OVERTEMP / 4;\r\n} else if (temp > (state->mpu.tmax << 16)) {\r\nstate->overtemp++;\r\nprintk(KERN_WARNING "CPU %d temperature %d above max %d. overtemp %d\n",\r\nstate->index, temp >> 16, state->mpu.tmax, state->overtemp);\r\n} else {\r\nif (state->overtemp)\r\nprintk(KERN_WARNING "CPU %d temperature back down to %d\n",\r\nstate->index, temp >> 16);\r\nstate->overtemp = 0;\r\n}\r\nif (state->overtemp >= CPU_MAX_OVERTEMP)\r\ncritical_state = 1;\r\nif (state->overtemp > 0) {\r\nstate->rpm = state->mpu.rmaxn_exhaust_fan;\r\nstate->intake_rpm = intake = state->mpu.rmaxn_intake_fan;\r\ngoto do_set_fans;\r\n}\r\ndo_cpu_pid(state, temp, power);\r\nstate->rpm = max(state->rpm, (int)state->mpu.rminn_exhaust_fan);\r\nstate->rpm = min(state->rpm, (int)state->mpu.rmaxn_exhaust_fan);\r\nintake = (state->rpm * CPU_INTAKE_SCALE) >> 16;\r\nintake = max(intake, (int)state->mpu.rminn_intake_fan);\r\nintake = min(intake, (int)state->mpu.rmaxn_intake_fan);\r\nstate->intake_rpm = intake;\r\ndo_set_fans:\r\nDBG("** CPU %d RPM: %d Ex, %d In, overtemp: %d\n",\r\nstate->index, (int)state->rpm, intake, state->overtemp);\r\nif (state->index == 0) {\r\nset_rpm_fan(CPUA_INTAKE_FAN_RPM_INDEX, intake);\r\nset_rpm_fan(CPUA_EXHAUST_FAN_RPM_INDEX, state->rpm);\r\n} else {\r\nset_rpm_fan(CPUB_INTAKE_FAN_RPM_INDEX, intake);\r\nset_rpm_fan(CPUB_EXHAUST_FAN_RPM_INDEX, state->rpm);\r\n}\r\n}\r\nstatic void do_monitor_cpu_rack(struct cpu_pid_state *state)\r\n{\r\ns32 temp, power, fan_min;\r\nint rc;\r\nrc = do_read_one_cpu_values(state, &temp, &power);\r\nif (rc < 0) {\r\n}\r\nif (temp >= ((state->mpu.tmax + 8) << 16)) {\r\nprintk(KERN_WARNING "Warning ! CPU %d temperature way above maximum"\r\n" (%d) !\n",\r\nstate->index, temp >> 16);\r\nstate->overtemp = CPU_MAX_OVERTEMP / 4;\r\n} else if (temp > (state->mpu.tmax << 16)) {\r\nstate->overtemp++;\r\nprintk(KERN_WARNING "CPU %d temperature %d above max %d. overtemp %d\n",\r\nstate->index, temp >> 16, state->mpu.tmax, state->overtemp);\r\n} else {\r\nif (state->overtemp)\r\nprintk(KERN_WARNING "CPU %d temperature back down to %d\n",\r\nstate->index, temp >> 16);\r\nstate->overtemp = 0;\r\n}\r\nif (state->overtemp >= CPU_MAX_OVERTEMP)\r\ncritical_state = 1;\r\nif (state->overtemp > 0) {\r\nstate->rpm = state->intake_rpm = state->mpu.rmaxn_intake_fan;\r\ngoto do_set_fans;\r\n}\r\ndo_cpu_pid(state, temp, power);\r\nfan_min = dimm_output_clamp;\r\nfan_min = max(fan_min, (int)state->mpu.rminn_intake_fan);\r\nDBG(" CPU min mpu = %d, min dimm = %d\n",\r\nstate->mpu.rminn_intake_fan, dimm_output_clamp);\r\nstate->rpm = max(state->rpm, (int)fan_min);\r\nstate->rpm = min(state->rpm, (int)state->mpu.rmaxn_intake_fan);\r\nstate->intake_rpm = state->rpm;\r\ndo_set_fans:\r\nDBG("** CPU %d RPM: %d overtemp: %d\n",\r\nstate->index, (int)state->rpm, state->overtemp);\r\nif (state->index == 0) {\r\nset_rpm_fan(CPU_A1_FAN_RPM_INDEX, state->rpm);\r\nset_rpm_fan(CPU_A2_FAN_RPM_INDEX, state->rpm);\r\nset_rpm_fan(CPU_A3_FAN_RPM_INDEX, state->rpm);\r\n} else {\r\nset_rpm_fan(CPU_B1_FAN_RPM_INDEX, state->rpm);\r\nset_rpm_fan(CPU_B2_FAN_RPM_INDEX, state->rpm);\r\nset_rpm_fan(CPU_B3_FAN_RPM_INDEX, state->rpm);\r\n}\r\n}\r\nstatic int init_processor_state(struct cpu_pid_state *state, int index)\r\n{\r\nint err;\r\nstate->index = index;\r\nstate->first = 1;\r\nstate->rpm = (cpu_pid_type == CPU_PID_TYPE_RACKMAC) ? 4000 : 1000;\r\nstate->overtemp = 0;\r\nstate->adc_config = 0x00;\r\nif (index == 0)\r\nstate->monitor = attach_i2c_chip(SUPPLY_MONITOR_ID, "CPU0_monitor");\r\nelse if (index == 1)\r\nstate->monitor = attach_i2c_chip(SUPPLY_MONITORB_ID, "CPU1_monitor");\r\nif (state->monitor == NULL)\r\ngoto fail;\r\nif (read_eeprom(index, &state->mpu))\r\ngoto fail;\r\nstate->count_power = state->mpu.tguardband;\r\nif (state->count_power > CPU_POWER_HISTORY_SIZE) {\r\nprintk(KERN_WARNING "Warning ! too many power history slots\n");\r\nstate->count_power = CPU_POWER_HISTORY_SIZE;\r\n}\r\nDBG("CPU %d Using %d power history entries\n", index, state->count_power);\r\nif (index == 0) {\r\nerr = device_create_file(&of_dev->dev, &dev_attr_cpu0_temperature);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu0_voltage);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu0_current);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu0_exhaust_fan_rpm);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu0_intake_fan_rpm);\r\n} else {\r\nerr = device_create_file(&of_dev->dev, &dev_attr_cpu1_temperature);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu1_voltage);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu1_current);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu1_exhaust_fan_rpm);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_cpu1_intake_fan_rpm);\r\n}\r\nif (err)\r\nprintk(KERN_WARNING "Failed to create some of the attribute"\r\n"files for CPU %d\n", index);\r\nreturn 0;\r\nfail:\r\nstate->monitor = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic void dispose_processor_state(struct cpu_pid_state *state)\r\n{\r\nif (state->monitor == NULL)\r\nreturn;\r\nif (state->index == 0) {\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu0_temperature);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu0_voltage);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu0_current);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu0_exhaust_fan_rpm);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu0_intake_fan_rpm);\r\n} else {\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu1_temperature);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu1_voltage);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu1_current);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu1_exhaust_fan_rpm);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_cpu1_intake_fan_rpm);\r\n}\r\nstate->monitor = NULL;\r\n}\r\nstatic void do_monitor_backside(struct backside_pid_state *state)\r\n{\r\ns32 temp, integral, derivative, fan_min;\r\ns64 integ_p, deriv_p, prop_p, sum;\r\nint i, rc;\r\nif (--state->ticks != 0)\r\nreturn;\r\nstate->ticks = backside_params.interval;\r\nDBG("backside:\n");\r\nrc = get_pwm_fan(BACKSIDE_FAN_PWM_INDEX);\r\nif (rc < 0) {\r\nprintk(KERN_WARNING "Error %d reading backside fan !\n", rc);\r\n} else\r\nstate->pwm = rc;\r\nDBG(" current pwm: %d\n", state->pwm);\r\ntemp = i2c_smbus_read_byte_data(state->monitor, MAX6690_EXT_TEMP) << 16;\r\nstate->last_temp = temp;\r\nDBG(" temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),\r\nFIX32TOPRINT(backside_params.input_target));\r\nstate->cur_sample = (state->cur_sample + 1) % BACKSIDE_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] = temp - backside_params.input_target;\r\nif (state->first) {\r\nfor (i = 0; i < (BACKSIDE_PID_HISTORY_SIZE - 1); i++) {\r\nstate->cur_sample = (state->cur_sample + 1) %\r\nBACKSIDE_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] =\r\ntemp - backside_params.input_target;\r\n}\r\nstate->first = 0;\r\n}\r\nsum = 0;\r\nintegral = 0;\r\nfor (i = 0; i < BACKSIDE_PID_HISTORY_SIZE; i++)\r\nintegral += state->error_history[i];\r\nintegral *= backside_params.interval;\r\nDBG(" integral: %08x\n", integral);\r\ninteg_p = ((s64)backside_params.G_r) * (s64)integral;\r\nDBG(" integ_p: %d\n", (int)(integ_p >> 36));\r\nsum += integ_p;\r\nderivative = state->error_history[state->cur_sample] -\r\nstate->error_history[(state->cur_sample + BACKSIDE_PID_HISTORY_SIZE - 1)\r\n% BACKSIDE_PID_HISTORY_SIZE];\r\nderivative /= backside_params.interval;\r\nderiv_p = ((s64)backside_params.G_d) * (s64)derivative;\r\nDBG(" deriv_p: %d\n", (int)(deriv_p >> 36));\r\nsum += deriv_p;\r\nprop_p = ((s64)backside_params.G_p) * (s64)(state->error_history[state->cur_sample]);\r\nDBG(" prop_p: %d\n", (int)(prop_p >> 36));\r\nsum += prop_p;\r\nsum >>= 36;\r\nDBG(" sum: %d\n", (int)sum);\r\nif (backside_params.additive)\r\nstate->pwm += (s32)sum;\r\nelse\r\nstate->pwm = sum;\r\nfan_min = (dimm_output_clamp * 100) / 14000;\r\nfan_min = max(fan_min, backside_params.output_min);\r\nstate->pwm = max(state->pwm, fan_min);\r\nstate->pwm = min(state->pwm, backside_params.output_max);\r\nDBG("** BACKSIDE PWM: %d\n", (int)state->pwm);\r\nset_pwm_fan(BACKSIDE_FAN_PWM_INDEX, state->pwm);\r\n}\r\nstatic int init_backside_state(struct backside_pid_state *state)\r\n{\r\nstruct device_node *u3;\r\nint u3h = 1;\r\nint err;\r\nu3 = of_find_node_by_path("/u3@0,f8000000");\r\nif (u3 != NULL) {\r\nconst u32 *vers = of_get_property(u3, "device-rev", NULL);\r\nif (vers)\r\nif (((*vers) & 0x3f) < 0x34)\r\nu3h = 0;\r\nof_node_put(u3);\r\n}\r\nif (rackmac) {\r\nbackside_params.G_d = BACKSIDE_PID_RACK_G_d;\r\nbackside_params.input_target = BACKSIDE_PID_RACK_INPUT_TARGET;\r\nbackside_params.output_min = BACKSIDE_PID_U3H_OUTPUT_MIN;\r\nbackside_params.interval = BACKSIDE_PID_RACK_INTERVAL;\r\nbackside_params.G_p = BACKSIDE_PID_RACK_G_p;\r\nbackside_params.G_r = BACKSIDE_PID_G_r;\r\nbackside_params.output_max = BACKSIDE_PID_OUTPUT_MAX;\r\nbackside_params.additive = 0;\r\n} else if (u3h) {\r\nbackside_params.G_d = BACKSIDE_PID_U3H_G_d;\r\nbackside_params.input_target = BACKSIDE_PID_U3H_INPUT_TARGET;\r\nbackside_params.output_min = BACKSIDE_PID_U3H_OUTPUT_MIN;\r\nbackside_params.interval = BACKSIDE_PID_INTERVAL;\r\nbackside_params.G_p = BACKSIDE_PID_G_p;\r\nbackside_params.G_r = BACKSIDE_PID_G_r;\r\nbackside_params.output_max = BACKSIDE_PID_OUTPUT_MAX;\r\nbackside_params.additive = 1;\r\n} else {\r\nbackside_params.G_d = BACKSIDE_PID_U3_G_d;\r\nbackside_params.input_target = BACKSIDE_PID_U3_INPUT_TARGET;\r\nbackside_params.output_min = BACKSIDE_PID_U3_OUTPUT_MIN;\r\nbackside_params.interval = BACKSIDE_PID_INTERVAL;\r\nbackside_params.G_p = BACKSIDE_PID_G_p;\r\nbackside_params.G_r = BACKSIDE_PID_G_r;\r\nbackside_params.output_max = BACKSIDE_PID_OUTPUT_MAX;\r\nbackside_params.additive = 1;\r\n}\r\nstate->ticks = 1;\r\nstate->first = 1;\r\nstate->pwm = 50;\r\nstate->monitor = attach_i2c_chip(BACKSIDE_MAX_ID, "backside_temp");\r\nif (state->monitor == NULL)\r\nreturn -ENODEV;\r\nerr = device_create_file(&of_dev->dev, &dev_attr_backside_temperature);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_backside_fan_pwm);\r\nif (err)\r\nprintk(KERN_WARNING "Failed to create attribute file(s)"\r\n" for backside fan\n");\r\nreturn 0;\r\n}\r\nstatic void dispose_backside_state(struct backside_pid_state *state)\r\n{\r\nif (state->monitor == NULL)\r\nreturn;\r\ndevice_remove_file(&of_dev->dev, &dev_attr_backside_temperature);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_backside_fan_pwm);\r\nstate->monitor = NULL;\r\n}\r\nstatic void do_monitor_drives(struct drives_pid_state *state)\r\n{\r\ns32 temp, integral, derivative;\r\ns64 integ_p, deriv_p, prop_p, sum;\r\nint i, rc;\r\nif (--state->ticks != 0)\r\nreturn;\r\nstate->ticks = DRIVES_PID_INTERVAL;\r\nDBG("drives:\n");\r\nrc = get_rpm_fan(DRIVES_FAN_RPM_INDEX, !RPM_PID_USE_ACTUAL_SPEED);\r\nif (rc < 0) {\r\nprintk(KERN_WARNING "Error %d reading drives fan !\n", rc);\r\n} else\r\nstate->rpm = rc;\r\nDBG(" current rpm: %d\n", state->rpm);\r\ntemp = le16_to_cpu(i2c_smbus_read_word_data(state->monitor,\r\nDS1775_TEMP)) << 8;\r\nstate->last_temp = temp;\r\nDBG(" temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),\r\nFIX32TOPRINT(DRIVES_PID_INPUT_TARGET));\r\nstate->cur_sample = (state->cur_sample + 1) % DRIVES_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] = temp - DRIVES_PID_INPUT_TARGET;\r\nif (state->first) {\r\nfor (i = 0; i < (DRIVES_PID_HISTORY_SIZE - 1); i++) {\r\nstate->cur_sample = (state->cur_sample + 1) %\r\nDRIVES_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] =\r\ntemp - DRIVES_PID_INPUT_TARGET;\r\n}\r\nstate->first = 0;\r\n}\r\nsum = 0;\r\nintegral = 0;\r\nfor (i = 0; i < DRIVES_PID_HISTORY_SIZE; i++)\r\nintegral += state->error_history[i];\r\nintegral *= DRIVES_PID_INTERVAL;\r\nDBG(" integral: %08x\n", integral);\r\ninteg_p = ((s64)DRIVES_PID_G_r) * (s64)integral;\r\nDBG(" integ_p: %d\n", (int)(integ_p >> 36));\r\nsum += integ_p;\r\nderivative = state->error_history[state->cur_sample] -\r\nstate->error_history[(state->cur_sample + DRIVES_PID_HISTORY_SIZE - 1)\r\n% DRIVES_PID_HISTORY_SIZE];\r\nderivative /= DRIVES_PID_INTERVAL;\r\nderiv_p = ((s64)DRIVES_PID_G_d) * (s64)derivative;\r\nDBG(" deriv_p: %d\n", (int)(deriv_p >> 36));\r\nsum += deriv_p;\r\nprop_p = ((s64)DRIVES_PID_G_p) * (s64)(state->error_history[state->cur_sample]);\r\nDBG(" prop_p: %d\n", (int)(prop_p >> 36));\r\nsum += prop_p;\r\nsum >>= 36;\r\nDBG(" sum: %d\n", (int)sum);\r\nstate->rpm += (s32)sum;\r\nstate->rpm = max(state->rpm, DRIVES_PID_OUTPUT_MIN);\r\nstate->rpm = min(state->rpm, DRIVES_PID_OUTPUT_MAX);\r\nDBG("** DRIVES RPM: %d\n", (int)state->rpm);\r\nset_rpm_fan(DRIVES_FAN_RPM_INDEX, state->rpm);\r\n}\r\nstatic int init_drives_state(struct drives_pid_state *state)\r\n{\r\nint err;\r\nstate->ticks = 1;\r\nstate->first = 1;\r\nstate->rpm = 1000;\r\nstate->monitor = attach_i2c_chip(DRIVES_DALLAS_ID, "drives_temp");\r\nif (state->monitor == NULL)\r\nreturn -ENODEV;\r\nerr = device_create_file(&of_dev->dev, &dev_attr_drives_temperature);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_drives_fan_rpm);\r\nif (err)\r\nprintk(KERN_WARNING "Failed to create attribute file(s)"\r\n" for drives bay fan\n");\r\nreturn 0;\r\n}\r\nstatic void dispose_drives_state(struct drives_pid_state *state)\r\n{\r\nif (state->monitor == NULL)\r\nreturn;\r\ndevice_remove_file(&of_dev->dev, &dev_attr_drives_temperature);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_drives_fan_rpm);\r\nstate->monitor = NULL;\r\n}\r\nstatic void do_monitor_dimms(struct dimm_pid_state *state)\r\n{\r\ns32 temp, integral, derivative, fan_min;\r\ns64 integ_p, deriv_p, prop_p, sum;\r\nint i;\r\nif (--state->ticks != 0)\r\nreturn;\r\nstate->ticks = DIMM_PID_INTERVAL;\r\nDBG("DIMM:\n");\r\nDBG(" current value: %d\n", state->output);\r\ntemp = read_lm87_reg(state->monitor, LM87_INT_TEMP);\r\nif (temp < 0)\r\nreturn;\r\ntemp <<= 16;\r\nstate->last_temp = temp;\r\nDBG(" temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),\r\nFIX32TOPRINT(DIMM_PID_INPUT_TARGET));\r\nstate->cur_sample = (state->cur_sample + 1) % DIMM_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] = temp - DIMM_PID_INPUT_TARGET;\r\nif (state->first) {\r\nfor (i = 0; i < (DIMM_PID_HISTORY_SIZE - 1); i++) {\r\nstate->cur_sample = (state->cur_sample + 1) %\r\nDIMM_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] =\r\ntemp - DIMM_PID_INPUT_TARGET;\r\n}\r\nstate->first = 0;\r\n}\r\nsum = 0;\r\nintegral = 0;\r\nfor (i = 0; i < DIMM_PID_HISTORY_SIZE; i++)\r\nintegral += state->error_history[i];\r\nintegral *= DIMM_PID_INTERVAL;\r\nDBG(" integral: %08x\n", integral);\r\ninteg_p = ((s64)DIMM_PID_G_r) * (s64)integral;\r\nDBG(" integ_p: %d\n", (int)(integ_p >> 36));\r\nsum += integ_p;\r\nderivative = state->error_history[state->cur_sample] -\r\nstate->error_history[(state->cur_sample + DIMM_PID_HISTORY_SIZE - 1)\r\n% DIMM_PID_HISTORY_SIZE];\r\nderivative /= DIMM_PID_INTERVAL;\r\nderiv_p = ((s64)DIMM_PID_G_d) * (s64)derivative;\r\nDBG(" deriv_p: %d\n", (int)(deriv_p >> 36));\r\nsum += deriv_p;\r\nprop_p = ((s64)DIMM_PID_G_p) * (s64)(state->error_history[state->cur_sample]);\r\nDBG(" prop_p: %d\n", (int)(prop_p >> 36));\r\nsum += prop_p;\r\nsum >>= 36;\r\nDBG(" sum: %d\n", (int)sum);\r\nstate->output = (s32)sum;\r\nstate->output = max(state->output, DIMM_PID_OUTPUT_MIN);\r\nstate->output = min(state->output, DIMM_PID_OUTPUT_MAX);\r\ndimm_output_clamp = state->output;\r\nDBG("** DIMM clamp value: %d\n", (int)state->output);\r\nfan_min = (dimm_output_clamp * 100) / 14000;\r\nfan_min = max(fan_min, backside_params.output_min);\r\nif (backside_state.pwm < fan_min) {\r\nbackside_state.pwm = fan_min;\r\nDBG(" -> applying clamp to backside fan now: %d !\n", fan_min);\r\nset_pwm_fan(BACKSIDE_FAN_PWM_INDEX, fan_min);\r\n}\r\n}\r\nstatic int init_dimms_state(struct dimm_pid_state *state)\r\n{\r\nstate->ticks = 1;\r\nstate->first = 1;\r\nstate->output = 4000;\r\nstate->monitor = attach_i2c_chip(XSERVE_DIMMS_LM87, "dimms_temp");\r\nif (state->monitor == NULL)\r\nreturn -ENODEV;\r\nif (device_create_file(&of_dev->dev, &dev_attr_dimms_temperature))\r\nprintk(KERN_WARNING "Failed to create attribute file"\r\n" for DIMM temperature\n");\r\nreturn 0;\r\n}\r\nstatic void dispose_dimms_state(struct dimm_pid_state *state)\r\n{\r\nif (state->monitor == NULL)\r\nreturn;\r\ndevice_remove_file(&of_dev->dev, &dev_attr_dimms_temperature);\r\nstate->monitor = NULL;\r\n}\r\nstatic void do_monitor_slots(struct slots_pid_state *state)\r\n{\r\ns32 temp, integral, derivative;\r\ns64 integ_p, deriv_p, prop_p, sum;\r\nint i, rc;\r\nif (--state->ticks != 0)\r\nreturn;\r\nstate->ticks = SLOTS_PID_INTERVAL;\r\nDBG("slots:\n");\r\nrc = get_pwm_fan(SLOTS_FAN_PWM_INDEX);\r\nif (rc < 0) {\r\nprintk(KERN_WARNING "Error %d reading slots fan !\n", rc);\r\n} else\r\nstate->pwm = rc;\r\nDBG(" current pwm: %d\n", state->pwm);\r\ntemp = le16_to_cpu(i2c_smbus_read_word_data(state->monitor,\r\nDS1775_TEMP)) << 8;\r\nstate->last_temp = temp;\r\nDBG(" temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),\r\nFIX32TOPRINT(SLOTS_PID_INPUT_TARGET));\r\nstate->cur_sample = (state->cur_sample + 1) % SLOTS_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] = temp - SLOTS_PID_INPUT_TARGET;\r\nif (state->first) {\r\nfor (i = 0; i < (SLOTS_PID_HISTORY_SIZE - 1); i++) {\r\nstate->cur_sample = (state->cur_sample + 1) %\r\nSLOTS_PID_HISTORY_SIZE;\r\nstate->sample_history[state->cur_sample] = temp;\r\nstate->error_history[state->cur_sample] =\r\ntemp - SLOTS_PID_INPUT_TARGET;\r\n}\r\nstate->first = 0;\r\n}\r\nsum = 0;\r\nintegral = 0;\r\nfor (i = 0; i < SLOTS_PID_HISTORY_SIZE; i++)\r\nintegral += state->error_history[i];\r\nintegral *= SLOTS_PID_INTERVAL;\r\nDBG(" integral: %08x\n", integral);\r\ninteg_p = ((s64)SLOTS_PID_G_r) * (s64)integral;\r\nDBG(" integ_p: %d\n", (int)(integ_p >> 36));\r\nsum += integ_p;\r\nderivative = state->error_history[state->cur_sample] -\r\nstate->error_history[(state->cur_sample + SLOTS_PID_HISTORY_SIZE - 1)\r\n% SLOTS_PID_HISTORY_SIZE];\r\nderivative /= SLOTS_PID_INTERVAL;\r\nderiv_p = ((s64)SLOTS_PID_G_d) * (s64)derivative;\r\nDBG(" deriv_p: %d\n", (int)(deriv_p >> 36));\r\nsum += deriv_p;\r\nprop_p = ((s64)SLOTS_PID_G_p) * (s64)(state->error_history[state->cur_sample]);\r\nDBG(" prop_p: %d\n", (int)(prop_p >> 36));\r\nsum += prop_p;\r\nsum >>= 36;\r\nDBG(" sum: %d\n", (int)sum);\r\nstate->pwm = (s32)sum;\r\nstate->pwm = max(state->pwm, SLOTS_PID_OUTPUT_MIN);\r\nstate->pwm = min(state->pwm, SLOTS_PID_OUTPUT_MAX);\r\nDBG("** DRIVES PWM: %d\n", (int)state->pwm);\r\nset_pwm_fan(SLOTS_FAN_PWM_INDEX, state->pwm);\r\n}\r\nstatic int init_slots_state(struct slots_pid_state *state)\r\n{\r\nint err;\r\nstate->ticks = 1;\r\nstate->first = 1;\r\nstate->pwm = 50;\r\nstate->monitor = attach_i2c_chip(XSERVE_SLOTS_LM75, "slots_temp");\r\nif (state->monitor == NULL)\r\nreturn -ENODEV;\r\nerr = device_create_file(&of_dev->dev, &dev_attr_slots_temperature);\r\nerr |= device_create_file(&of_dev->dev, &dev_attr_slots_fan_pwm);\r\nif (err)\r\nprintk(KERN_WARNING "Failed to create attribute file(s)"\r\n" for slots bay fan\n");\r\nreturn 0;\r\n}\r\nstatic void dispose_slots_state(struct slots_pid_state *state)\r\n{\r\nif (state->monitor == NULL)\r\nreturn;\r\ndevice_remove_file(&of_dev->dev, &dev_attr_slots_temperature);\r\ndevice_remove_file(&of_dev->dev, &dev_attr_slots_fan_pwm);\r\nstate->monitor = NULL;\r\n}\r\nstatic int call_critical_overtemp(void)\r\n{\r\nchar *argv[] = { critical_overtemp_path, NULL };\r\nstatic char *envp[] = { "HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\nNULL };\r\nreturn call_usermodehelper(critical_overtemp_path,\r\nargv, envp, UMH_WAIT_EXEC);\r\n}\r\nstatic int main_control_loop(void *x)\r\n{\r\nDBG("main_control_loop started\n");\r\nmutex_lock(&driver_lock);\r\nif (start_fcu() < 0) {\r\nprintk(KERN_ERR "kfand: failed to start FCU\n");\r\nmutex_unlock(&driver_lock);\r\ngoto out;\r\n}\r\nif (!rackmac)\r\nset_pwm_fan(SLOTS_FAN_PWM_INDEX, SLOTS_FAN_DEFAULT_PWM);\r\ninitialize_adc(&processor_state[0]);\r\nif (processor_state[1].monitor != NULL)\r\ninitialize_adc(&processor_state[1]);\r\nfcu_tickle_ticks = FCU_TICKLE_TICKS;\r\nmutex_unlock(&driver_lock);\r\nwhile (state == state_attached) {\r\nunsigned long elapsed, start;\r\nstart = jiffies;\r\nmutex_lock(&driver_lock);\r\nif (--fcu_tickle_ticks < 0) {\r\nfcu_tickle_ticks = FCU_TICKLE_TICKS;\r\ntickle_fcu();\r\n}\r\nif (rackmac)\r\ndo_monitor_dimms(&dimms_state);\r\nif (cpu_pid_type == CPU_PID_TYPE_COMBINED)\r\ndo_monitor_cpu_combined();\r\nelse if (cpu_pid_type == CPU_PID_TYPE_RACKMAC) {\r\ndo_monitor_cpu_rack(&processor_state[0]);\r\nif (processor_state[1].monitor != NULL)\r\ndo_monitor_cpu_rack(&processor_state[1]);\r\n} else {\r\ndo_monitor_cpu_split(&processor_state[0]);\r\nif (processor_state[1].monitor != NULL)\r\ndo_monitor_cpu_split(&processor_state[1]);\r\n}\r\ndo_monitor_backside(&backside_state);\r\nif (rackmac)\r\ndo_monitor_slots(&slots_state);\r\nelse\r\ndo_monitor_drives(&drives_state);\r\nmutex_unlock(&driver_lock);\r\nif (critical_state == 1) {\r\nprintk(KERN_WARNING "Temperature control detected a critical condition\n");\r\nprintk(KERN_WARNING "Attempting to shut down...\n");\r\nif (call_critical_overtemp()) {\r\nprintk(KERN_WARNING "Can't call %s, power off now!\n",\r\ncritical_overtemp_path);\r\nmachine_power_off();\r\n}\r\n}\r\nif (critical_state > 0)\r\ncritical_state++;\r\nif (critical_state > MAX_CRITICAL_STATE) {\r\nprintk(KERN_WARNING "Shutdown timed out, power off now !\n");\r\nmachine_power_off();\r\n}\r\nelapsed = jiffies - start;\r\nif (elapsed < HZ)\r\nschedule_timeout_interruptible(HZ - elapsed);\r\n}\r\nout:\r\nDBG("main_control_loop ended\n");\r\nctrl_task = 0;\r\ncomplete_and_exit(&ctrl_complete, 0);\r\n}\r\nstatic void dispose_control_loops(void)\r\n{\r\ndispose_processor_state(&processor_state[0]);\r\ndispose_processor_state(&processor_state[1]);\r\ndispose_backside_state(&backside_state);\r\ndispose_drives_state(&drives_state);\r\ndispose_slots_state(&slots_state);\r\ndispose_dimms_state(&dimms_state);\r\n}\r\nstatic int create_control_loops(void)\r\n{\r\nstruct device_node *np;\r\ncpu_count = 0;\r\nfor (np = NULL; NULL != (np = of_find_node_by_type(np, "cpu"));)\r\ncpu_count++;\r\nDBG("counted %d CPUs in the device-tree\n", cpu_count);\r\nif (rackmac)\r\ncpu_pid_type = CPU_PID_TYPE_RACKMAC;\r\nelse if (of_machine_is_compatible("PowerMac7,3")\r\n&& (cpu_count > 1)\r\n&& fcu_fans[CPUA_PUMP_RPM_INDEX].id != FCU_FAN_ABSENT_ID\r\n&& fcu_fans[CPUB_PUMP_RPM_INDEX].id != FCU_FAN_ABSENT_ID) {\r\nprintk(KERN_INFO "Liquid cooling pumps detected, using new algorithm !\n");\r\ncpu_pid_type = CPU_PID_TYPE_COMBINED;\r\n} else\r\ncpu_pid_type = CPU_PID_TYPE_SPLIT;\r\nif (init_processor_state(&processor_state[0], 0))\r\ngoto fail;\r\nif (cpu_pid_type == CPU_PID_TYPE_COMBINED)\r\nfetch_cpu_pumps_minmax();\r\nif (cpu_count > 1 && init_processor_state(&processor_state[1], 1))\r\ngoto fail;\r\nif (init_backside_state(&backside_state))\r\ngoto fail;\r\nif (rackmac && init_dimms_state(&dimms_state))\r\ngoto fail;\r\nif (rackmac && init_slots_state(&slots_state))\r\ngoto fail;\r\nif (!rackmac && init_drives_state(&drives_state))\r\ngoto fail;\r\nDBG("all control loops up !\n");\r\nreturn 0;\r\nfail:\r\nDBG("failure creating control loops, disposing\n");\r\ndispose_control_loops();\r\nreturn -ENODEV;\r\n}\r\nstatic void start_control_loops(void)\r\n{\r\ninit_completion(&ctrl_complete);\r\nctrl_task = kthread_run(main_control_loop, NULL, "kfand");\r\n}\r\nstatic void stop_control_loops(void)\r\n{\r\nif (ctrl_task)\r\nwait_for_completion(&ctrl_complete);\r\n}\r\nstatic int attach_fcu(void)\r\n{\r\nfcu = attach_i2c_chip(FAN_CTRLER_ID, "fcu");\r\nif (fcu == NULL)\r\nreturn -ENODEV;\r\nDBG("FCU attached\n");\r\nreturn 0;\r\n}\r\nstatic void detach_fcu(void)\r\n{\r\nfcu = NULL;\r\n}\r\nstatic int therm_pm72_attach(struct i2c_adapter *adapter)\r\n{\r\nmutex_lock(&driver_lock);\r\nif (state == state_detached)\r\nstate = state_attaching;\r\nif (state != state_attaching) {\r\nmutex_unlock(&driver_lock);\r\nreturn 0;\r\n}\r\nif (u3_0 == NULL && !strcmp(adapter->name, "u3 0")) {\r\nu3_0 = adapter;\r\nDBG("found U3-0\n");\r\nif (k2 || !rackmac)\r\nif (create_control_loops())\r\nu3_0 = NULL;\r\n} else if (u3_1 == NULL && !strcmp(adapter->name, "u3 1")) {\r\nu3_1 = adapter;\r\nDBG("found U3-1, attaching FCU\n");\r\nif (attach_fcu())\r\nu3_1 = NULL;\r\n} else if (k2 == NULL && !strcmp(adapter->name, "mac-io 0")) {\r\nk2 = adapter;\r\nDBG("Found K2\n");\r\nif (u3_0 && rackmac)\r\nif (create_control_loops())\r\nk2 = NULL;\r\n}\r\nif (u3_0 != NULL && u3_1 != NULL && (k2 || !rackmac)) {\r\nDBG("everything up, starting control loops\n");\r\nstate = state_attached;\r\nstart_control_loops();\r\n}\r\nmutex_unlock(&driver_lock);\r\nreturn 0;\r\n}\r\nstatic int therm_pm72_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nreturn 0;\r\n}\r\nstatic int therm_pm72_remove(struct i2c_client *client)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nmutex_lock(&driver_lock);\r\nif (state != state_detached)\r\nstate = state_detaching;\r\nDBG("stopping control loops\n");\r\nmutex_unlock(&driver_lock);\r\nstop_control_loops();\r\nmutex_lock(&driver_lock);\r\nif (u3_0 != NULL && !strcmp(adapter->name, "u3 0")) {\r\nDBG("lost U3-0, disposing control loops\n");\r\ndispose_control_loops();\r\nu3_0 = NULL;\r\n}\r\nif (u3_1 != NULL && !strcmp(adapter->name, "u3 1")) {\r\nDBG("lost U3-1, detaching FCU\n");\r\ndetach_fcu();\r\nu3_1 = NULL;\r\n}\r\nif (u3_0 == NULL && u3_1 == NULL)\r\nstate = state_detached;\r\nmutex_unlock(&driver_lock);\r\nreturn 0;\r\n}\r\nstatic int fan_check_loc_match(const char *loc, int fan)\r\n{\r\nchar tmp[64];\r\nchar *c, *e;\r\nstrlcpy(tmp, fcu_fans[fan].loc, 64);\r\nc = tmp;\r\nfor (;;) {\r\ne = strchr(c, ',');\r\nif (e)\r\n*e = 0;\r\nif (strcmp(loc, c) == 0)\r\nreturn 1;\r\nif (e == NULL)\r\nbreak;\r\nc = e + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fcu_lookup_fans(struct device_node *fcu_node)\r\n{\r\nstruct device_node *np = NULL;\r\nint i;\r\nDBG("Looking up FCU controls in device-tree...\n");\r\nwhile ((np = of_get_next_child(fcu_node, np)) != NULL) {\r\nint type = -1;\r\nconst char *loc;\r\nconst u32 *reg;\r\nDBG(" control: %s, type: %s\n", np->name, np->type);\r\nif (!strcmp(np->type, "fan-rpm-control") ||\r\n!strcmp(np->type, "fan-rpm"))\r\ntype = FCU_FAN_RPM;\r\nif (!strcmp(np->type, "fan-pwm-control") ||\r\n!strcmp(np->type, "fan-pwm"))\r\ntype = FCU_FAN_PWM;\r\nif (type == -1)\r\ncontinue;\r\nloc = of_get_property(np, "location", NULL);\r\nreg = of_get_property(np, "reg", NULL);\r\nif (loc == NULL || reg == NULL)\r\ncontinue;\r\nDBG(" matching location: %s, reg: 0x%08x\n", loc, *reg);\r\nfor (i = 0; i < FCU_FAN_COUNT; i++) {\r\nint fan_id;\r\nif (!fan_check_loc_match(loc, i))\r\ncontinue;\r\nDBG(" location match, index: %d\n", i);\r\nfcu_fans[i].id = FCU_FAN_ABSENT_ID;\r\nif (type != fcu_fans[i].type) {\r\nprintk(KERN_WARNING "therm_pm72: Fan type mismatch "\r\n"in device-tree for %s\n", np->full_name);\r\nbreak;\r\n}\r\nif (type == FCU_FAN_RPM)\r\nfan_id = ((*reg) - 0x10) / 2;\r\nelse\r\nfan_id = ((*reg) - 0x30) / 2;\r\nif (fan_id > 7) {\r\nprintk(KERN_WARNING "therm_pm72: Can't parse "\r\n"fan ID in device-tree for %s\n", np->full_name);\r\nbreak;\r\n}\r\nDBG(" fan id -> %d, type -> %d\n", fan_id, type);\r\nfcu_fans[i].id = fan_id;\r\n}\r\n}\r\nprintk(KERN_INFO "Detected fan controls:\n");\r\nfor (i = 0; i < FCU_FAN_COUNT; i++) {\r\nif (fcu_fans[i].id == FCU_FAN_ABSENT_ID)\r\ncontinue;\r\nprintk(KERN_INFO " %d: %s fan, id %d, location: %s\n", i,\r\nfcu_fans[i].type == FCU_FAN_RPM ? "RPM" : "PWM",\r\nfcu_fans[i].id, fcu_fans[i].loc);\r\n}\r\n}\r\nstatic int fcu_of_probe(struct platform_device* dev)\r\n{\r\nstate = state_detached;\r\nof_dev = dev;\r\ndev_info(&dev->dev, "PowerMac G5 Thermal control driver %s\n", VERSION);\r\nfcu_lookup_fans(dev->dev.of_node);\r\nreturn i2c_add_driver(&therm_pm72_driver);\r\n}\r\nstatic int fcu_of_remove(struct platform_device* dev)\r\n{\r\ni2c_del_driver(&therm_pm72_driver);\r\nreturn 0;\r\n}\r\nstatic int __init therm_pm72_init(void)\r\n{\r\nrackmac = of_machine_is_compatible("RackMac3,1");\r\nif (!of_machine_is_compatible("PowerMac7,2") &&\r\n!of_machine_is_compatible("PowerMac7,3") &&\r\n!rackmac)\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&fcu_of_platform_driver);\r\n}\r\nstatic void __exit therm_pm72_exit(void)\r\n{\r\nplatform_driver_unregister(&fcu_of_platform_driver);\r\n}
