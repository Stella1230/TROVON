void scsi_eh_wakeup(struct Scsi_Host *shost)\r\n{\r\nif (shost->host_busy == shost->host_failed) {\r\ntrace_scsi_eh_wakeup(shost);\r\nwake_up_process(shost->ehandler);\r\nSCSI_LOG_ERROR_RECOVERY(5,\r\nprintk("Waking error handler thread\n"));\r\n}\r\n}\r\nvoid scsi_schedule_eh(struct Scsi_Host *shost)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_RECOVERY) == 0 ||\r\nscsi_host_set_state(shost, SHOST_CANCEL_RECOVERY) == 0) {\r\nshost->host_eh_scheduled++;\r\nscsi_eh_wakeup(shost);\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nint scsi_eh_scmd_add(struct scsi_cmnd *scmd, int eh_flag)\r\n{\r\nstruct Scsi_Host *shost = scmd->device->host;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!shost->ehandler)\r\nreturn 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_RECOVERY))\r\nif (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY))\r\ngoto out_unlock;\r\nret = 1;\r\nscmd->eh_eflags |= eh_flag;\r\nlist_add_tail(&scmd->eh_entry, &shost->eh_cmd_q);\r\nshost->host_failed++;\r\nscsi_eh_wakeup(shost);\r\nout_unlock:\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn ret;\r\n}\r\nenum blk_eh_timer_return scsi_times_out(struct request *req)\r\n{\r\nstruct scsi_cmnd *scmd = req->special;\r\nenum blk_eh_timer_return rtn = BLK_EH_NOT_HANDLED;\r\nstruct Scsi_Host *host = scmd->device->host;\r\ntrace_scsi_dispatch_cmd_timeout(scmd);\r\nscsi_log_completion(scmd, TIMEOUT_ERROR);\r\nif (host->transportt->eh_timed_out)\r\nrtn = host->transportt->eh_timed_out(scmd);\r\nelse if (host->hostt->eh_timed_out)\r\nrtn = host->hostt->eh_timed_out(scmd);\r\nscmd->result |= DID_TIME_OUT << 16;\r\nif (unlikely(rtn == BLK_EH_NOT_HANDLED &&\r\n!scsi_eh_scmd_add(scmd, SCSI_EH_CANCEL_CMD)))\r\nrtn = BLK_EH_HANDLED;\r\nreturn rtn;\r\n}\r\nint scsi_block_when_processing_errors(struct scsi_device *sdev)\r\n{\r\nint online;\r\nwait_event(sdev->host->host_wait, !scsi_host_in_recovery(sdev->host));\r\nonline = scsi_device_online(sdev);\r\nSCSI_LOG_ERROR_RECOVERY(5, printk("%s: rtn: %d\n", __func__,\r\nonline));\r\nreturn online;\r\n}\r\nstatic inline void scsi_eh_prt_fail_stats(struct Scsi_Host *shost,\r\nstruct list_head *work_q)\r\n{\r\nstruct scsi_cmnd *scmd;\r\nstruct scsi_device *sdev;\r\nint total_failures = 0;\r\nint cmd_failed = 0;\r\nint cmd_cancel = 0;\r\nint devices_failed = 0;\r\nshost_for_each_device(sdev, shost) {\r\nlist_for_each_entry(scmd, work_q, eh_entry) {\r\nif (scmd->device == sdev) {\r\n++total_failures;\r\nif (scmd->eh_eflags & SCSI_EH_CANCEL_CMD)\r\n++cmd_cancel;\r\nelse\r\n++cmd_failed;\r\n}\r\n}\r\nif (cmd_cancel || cmd_failed) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: cmds failed: %d, cancel: %d\n",\r\n__func__, cmd_failed,\r\ncmd_cancel));\r\ncmd_cancel = 0;\r\ncmd_failed = 0;\r\n++devices_failed;\r\n}\r\n}\r\nSCSI_LOG_ERROR_RECOVERY(2, printk("Total of %d commands on %d"\r\n" devices require eh work\n",\r\ntotal_failures, devices_failed));\r\n}\r\nstatic int scsi_check_sense(struct scsi_cmnd *scmd)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nstruct scsi_sense_hdr sshdr;\r\nif (! scsi_command_normalize_sense(scmd, &sshdr))\r\nreturn FAILED;\r\nif (scmd->cmnd[0] == TEST_UNIT_READY && scmd->scsi_done != scsi_eh_done)\r\nreturn SUCCESS;\r\nif (scsi_sense_is_deferred(&sshdr))\r\nreturn NEEDS_RETRY;\r\nif (sdev->scsi_dh_data && sdev->scsi_dh_data->scsi_dh &&\r\nsdev->scsi_dh_data->scsi_dh->check_sense) {\r\nint rc;\r\nrc = sdev->scsi_dh_data->scsi_dh->check_sense(sdev, &sshdr);\r\nif (rc != SCSI_RETURN_NOT_HANDLED)\r\nreturn rc;\r\n}\r\nif (sshdr.response_code == 0x70) {\r\nif (scmd->sense_buffer[2] & 0xe0)\r\nreturn SUCCESS;\r\n} else {\r\nif ((sshdr.additional_length > 3) &&\r\n(scmd->sense_buffer[8] == 0x4) &&\r\n(scmd->sense_buffer[11] & 0xe0))\r\nreturn SUCCESS;\r\n}\r\nswitch (sshdr.sense_key) {\r\ncase NO_SENSE:\r\nreturn SUCCESS;\r\ncase RECOVERED_ERROR:\r\nreturn SUCCESS;\r\ncase ABORTED_COMMAND:\r\nif (sshdr.asc == 0x10)\r\nreturn SUCCESS;\r\nreturn NEEDS_RETRY;\r\ncase NOT_READY:\r\ncase UNIT_ATTENTION:\r\nif (scmd->device->expecting_cc_ua) {\r\nif (sshdr.asc != 0x28 || sshdr.ascq != 0x00) {\r\nscmd->device->expecting_cc_ua = 0;\r\nreturn NEEDS_RETRY;\r\n}\r\n}\r\nif ((sshdr.asc == 0x04) && (sshdr.ascq == 0x01))\r\nreturn NEEDS_RETRY;\r\nif (scmd->device->allow_restart &&\r\n(sshdr.asc == 0x04) && (sshdr.ascq == 0x02))\r\nreturn FAILED;\r\nif (sshdr.asc == 0x3f && sshdr.ascq == 0x0e)\r\nscmd_printk(KERN_WARNING, scmd,\r\n"Warning! Received an indication that the "\r\n"LUN assignments on this target have "\r\n"changed. The Linux SCSI layer does not "\r\n"automatically remap LUN assignments.\n");\r\nelse if (sshdr.asc == 0x3f)\r\nscmd_printk(KERN_WARNING, scmd,\r\n"Warning! Received an indication that the "\r\n"operating parameters on this target have "\r\n"changed. The Linux SCSI layer does not "\r\n"automatically adjust these parameters.\n");\r\nif (sshdr.asc == 0x38 && sshdr.ascq == 0x07)\r\nscmd_printk(KERN_WARNING, scmd,\r\n"Warning! Received an indication that the "\r\n"LUN reached a thin provisioning soft "\r\n"threshold.\n");\r\nreturn SUCCESS;\r\ncase COPY_ABORTED:\r\ncase VOLUME_OVERFLOW:\r\ncase MISCOMPARE:\r\ncase BLANK_CHECK:\r\ncase DATA_PROTECT:\r\nreturn TARGET_ERROR;\r\ncase MEDIUM_ERROR:\r\nif (sshdr.asc == 0x11 ||\r\nsshdr.asc == 0x13 ||\r\nsshdr.asc == 0x14) {\r\nreturn TARGET_ERROR;\r\n}\r\nreturn NEEDS_RETRY;\r\ncase HARDWARE_ERROR:\r\nif (scmd->device->retry_hwerror)\r\nreturn ADD_TO_MLQUEUE;\r\nelse\r\nreturn TARGET_ERROR;\r\ncase ILLEGAL_REQUEST:\r\nif (sshdr.asc == 0x20 ||\r\nsshdr.asc == 0x21 ||\r\nsshdr.asc == 0x24 ||\r\nsshdr.asc == 0x26) {\r\nreturn TARGET_ERROR;\r\n}\r\nreturn SUCCESS;\r\ndefault:\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic void scsi_handle_queue_ramp_up(struct scsi_device *sdev)\r\n{\r\nstruct scsi_host_template *sht = sdev->host->hostt;\r\nstruct scsi_device *tmp_sdev;\r\nif (!sht->change_queue_depth ||\r\nsdev->queue_depth >= sdev->max_queue_depth)\r\nreturn;\r\nif (time_before(jiffies,\r\nsdev->last_queue_ramp_up + sdev->queue_ramp_up_period))\r\nreturn;\r\nif (time_before(jiffies,\r\nsdev->last_queue_full_time + sdev->queue_ramp_up_period))\r\nreturn;\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (tmp_sdev->channel != sdev->channel ||\r\ntmp_sdev->id != sdev->id ||\r\ntmp_sdev->queue_depth == sdev->max_queue_depth)\r\ncontinue;\r\nsht->change_queue_depth(tmp_sdev, tmp_sdev->queue_depth + 1,\r\nSCSI_QDEPTH_RAMP_UP);\r\nsdev->last_queue_ramp_up = jiffies;\r\n}\r\n}\r\nstatic void scsi_handle_queue_full(struct scsi_device *sdev)\r\n{\r\nstruct scsi_host_template *sht = sdev->host->hostt;\r\nstruct scsi_device *tmp_sdev;\r\nif (!sht->change_queue_depth)\r\nreturn;\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (tmp_sdev->channel != sdev->channel ||\r\ntmp_sdev->id != sdev->id)\r\ncontinue;\r\nsht->change_queue_depth(tmp_sdev, tmp_sdev->queue_depth - 1,\r\nSCSI_QDEPTH_QFULL);\r\n}\r\n}\r\nstatic int scsi_eh_completed_normally(struct scsi_cmnd *scmd)\r\n{\r\nif (host_byte(scmd->result) == DID_RESET) {\r\nreturn scsi_check_sense(scmd);\r\n}\r\nif (host_byte(scmd->result) != DID_OK)\r\nreturn FAILED;\r\nif (msg_byte(scmd->result) != COMMAND_COMPLETE)\r\nreturn FAILED;\r\nswitch (status_byte(scmd->result)) {\r\ncase GOOD:\r\nscsi_handle_queue_ramp_up(scmd->device);\r\ncase COMMAND_TERMINATED:\r\nreturn SUCCESS;\r\ncase CHECK_CONDITION:\r\nreturn scsi_check_sense(scmd);\r\ncase CONDITION_GOOD:\r\ncase INTERMEDIATE_GOOD:\r\ncase INTERMEDIATE_C_GOOD:\r\nreturn SUCCESS;\r\ncase RESERVATION_CONFLICT:\r\nif (scmd->cmnd[0] == TEST_UNIT_READY)\r\nreturn SUCCESS;\r\nreturn FAILED;\r\ncase QUEUE_FULL:\r\nscsi_handle_queue_full(scmd->device);\r\ncase BUSY:\r\nreturn NEEDS_RETRY;\r\ndefault:\r\nreturn FAILED;\r\n}\r\nreturn FAILED;\r\n}\r\nstatic void scsi_eh_done(struct scsi_cmnd *scmd)\r\n{\r\nstruct completion *eh_action;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nprintk("%s scmd: %p result: %x\n",\r\n__func__, scmd, scmd->result));\r\neh_action = scmd->device->host->eh_action;\r\nif (eh_action)\r\ncomplete(eh_action);\r\n}\r\nstatic int scsi_try_host_reset(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nint rtn;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct scsi_host_template *hostt = host->hostt;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Snd Host RST\n",\r\n__func__));\r\nif (!hostt->eh_host_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_host_reset_handler(scmd);\r\nif (rtn == SUCCESS) {\r\nif (!hostt->skip_settle_delay)\r\nssleep(HOST_RESET_SETTLE_TIME);\r\nspin_lock_irqsave(host->host_lock, flags);\r\nscsi_report_bus_reset(host, scmd_channel(scmd));\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int scsi_try_bus_reset(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nint rtn;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct scsi_host_template *hostt = host->hostt;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Snd Bus RST\n",\r\n__func__));\r\nif (!hostt->eh_bus_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_bus_reset_handler(scmd);\r\nif (rtn == SUCCESS) {\r\nif (!hostt->skip_settle_delay)\r\nssleep(BUS_RESET_SETTLE_TIME);\r\nspin_lock_irqsave(host->host_lock, flags);\r\nscsi_report_bus_reset(host, scmd_channel(scmd));\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn rtn;\r\n}\r\nstatic void __scsi_report_device_reset(struct scsi_device *sdev, void *data)\r\n{\r\nsdev->was_reset = 1;\r\nsdev->expecting_cc_ua = 1;\r\n}\r\nstatic int scsi_try_target_reset(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nint rtn;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct scsi_host_template *hostt = host->hostt;\r\nif (!hostt->eh_target_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_target_reset_handler(scmd);\r\nif (rtn == SUCCESS) {\r\nspin_lock_irqsave(host->host_lock, flags);\r\n__starget_for_each_device(scsi_target(scmd->device), NULL,\r\n__scsi_report_device_reset);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int scsi_try_bus_device_reset(struct scsi_cmnd *scmd)\r\n{\r\nint rtn;\r\nstruct scsi_host_template *hostt = scmd->device->host->hostt;\r\nif (!hostt->eh_device_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_device_reset_handler(scmd);\r\nif (rtn == SUCCESS)\r\n__scsi_report_device_reset(scmd->device, NULL);\r\nreturn rtn;\r\n}\r\nstatic int scsi_try_to_abort_cmd(struct scsi_host_template *hostt, struct scsi_cmnd *scmd)\r\n{\r\nif (!hostt->eh_abort_handler)\r\nreturn FAILED;\r\nreturn hostt->eh_abort_handler(scmd);\r\n}\r\nstatic void scsi_abort_eh_cmnd(struct scsi_cmnd *scmd)\r\n{\r\nif (scsi_try_to_abort_cmd(scmd->device->host->hostt, scmd) != SUCCESS)\r\nif (scsi_try_bus_device_reset(scmd) != SUCCESS)\r\nif (scsi_try_target_reset(scmd) != SUCCESS)\r\nif (scsi_try_bus_reset(scmd) != SUCCESS)\r\nscsi_try_host_reset(scmd);\r\n}\r\nvoid scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,\r\nunsigned char *cmnd, int cmnd_size, unsigned sense_bytes)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nses->cmd_len = scmd->cmd_len;\r\nses->cmnd = scmd->cmnd;\r\nses->data_direction = scmd->sc_data_direction;\r\nses->sdb = scmd->sdb;\r\nses->next_rq = scmd->request->next_rq;\r\nses->result = scmd->result;\r\nses->underflow = scmd->underflow;\r\nses->prot_op = scmd->prot_op;\r\nscmd->prot_op = SCSI_PROT_NORMAL;\r\nscmd->cmnd = ses->eh_cmnd;\r\nmemset(scmd->cmnd, 0, BLK_MAX_CDB);\r\nmemset(&scmd->sdb, 0, sizeof(scmd->sdb));\r\nscmd->request->next_rq = NULL;\r\nif (sense_bytes) {\r\nscmd->sdb.length = min_t(unsigned, SCSI_SENSE_BUFFERSIZE,\r\nsense_bytes);\r\nsg_init_one(&ses->sense_sgl, scmd->sense_buffer,\r\nscmd->sdb.length);\r\nscmd->sdb.table.sgl = &ses->sense_sgl;\r\nscmd->sc_data_direction = DMA_FROM_DEVICE;\r\nscmd->sdb.table.nents = 1;\r\nscmd->cmnd[0] = REQUEST_SENSE;\r\nscmd->cmnd[4] = scmd->sdb.length;\r\nscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\r\n} else {\r\nscmd->sc_data_direction = DMA_NONE;\r\nif (cmnd) {\r\nBUG_ON(cmnd_size > BLK_MAX_CDB);\r\nmemcpy(scmd->cmnd, cmnd, cmnd_size);\r\nscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\r\n}\r\n}\r\nscmd->underflow = 0;\r\nif (sdev->scsi_level <= SCSI_2 && sdev->scsi_level != SCSI_UNKNOWN)\r\nscmd->cmnd[1] = (scmd->cmnd[1] & 0x1f) |\r\n(sdev->lun << 5 & 0xe0);\r\nmemset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\n}\r\nvoid scsi_eh_restore_cmnd(struct scsi_cmnd* scmd, struct scsi_eh_save *ses)\r\n{\r\nscmd->cmd_len = ses->cmd_len;\r\nscmd->cmnd = ses->cmnd;\r\nscmd->sc_data_direction = ses->data_direction;\r\nscmd->sdb = ses->sdb;\r\nscmd->request->next_rq = ses->next_rq;\r\nscmd->result = ses->result;\r\nscmd->underflow = ses->underflow;\r\nscmd->prot_op = ses->prot_op;\r\n}\r\nstatic int scsi_send_eh_cmnd(struct scsi_cmnd *scmd, unsigned char *cmnd,\r\nint cmnd_size, int timeout, unsigned sense_bytes)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nstruct Scsi_Host *shost = sdev->host;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nunsigned long timeleft;\r\nstruct scsi_eh_save ses;\r\nint rtn;\r\nscsi_eh_prep_cmnd(scmd, &ses, cmnd, cmnd_size, sense_bytes);\r\nshost->eh_action = &done;\r\nscsi_log_send(scmd);\r\nscmd->scsi_done = scsi_eh_done;\r\nshost->hostt->queuecommand(shost, scmd);\r\ntimeleft = wait_for_completion_timeout(&done, timeout);\r\nshost->eh_action = NULL;\r\nscsi_log_completion(scmd, SUCCESS);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nprintk("%s: scmd: %p, timeleft: %ld\n",\r\n__func__, scmd, timeleft));\r\nif (timeleft) {\r\nrtn = scsi_eh_completed_normally(scmd);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nprintk("%s: scsi_eh_completed_normally %x\n",\r\n__func__, rtn));\r\nswitch (rtn) {\r\ncase SUCCESS:\r\ncase NEEDS_RETRY:\r\ncase FAILED:\r\ncase TARGET_ERROR:\r\nbreak;\r\ncase ADD_TO_MLQUEUE:\r\nrtn = NEEDS_RETRY;\r\nbreak;\r\ndefault:\r\nrtn = FAILED;\r\nbreak;\r\n}\r\n} else {\r\nscsi_abort_eh_cmnd(scmd);\r\nrtn = FAILED;\r\n}\r\nscsi_eh_restore_cmnd(scmd, &ses);\r\nif (scmd->request->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nstruct scsi_driver *sdrv = scsi_cmd_to_driver(scmd);\r\nif (sdrv->eh_action)\r\nrtn = sdrv->eh_action(scmd, cmnd, cmnd_size, rtn);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int scsi_request_sense(struct scsi_cmnd *scmd)\r\n{\r\nreturn scsi_send_eh_cmnd(scmd, NULL, 0, SENSE_TIMEOUT, ~0);\r\n}\r\nvoid scsi_eh_finish_cmd(struct scsi_cmnd *scmd, struct list_head *done_q)\r\n{\r\nscmd->device->host->host_failed--;\r\nscmd->eh_eflags = 0;\r\nlist_move_tail(&scmd->eh_entry, done_q);\r\n}\r\nint scsi_eh_get_sense(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nint rtn;\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nif ((scmd->eh_eflags & SCSI_EH_CANCEL_CMD) ||\r\nSCSI_SENSE_VALID(scmd))\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(2, scmd_printk(KERN_INFO, scmd,\r\n"%s: requesting sense\n",\r\ncurrent->comm));\r\nrtn = scsi_request_sense(scmd);\r\nif (rtn != SUCCESS)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("sense requested for %p"\r\n" result %x\n", scmd,\r\nscmd->result));\r\nSCSI_LOG_ERROR_RECOVERY(3, scsi_print_sense("bh", scmd));\r\nrtn = scsi_decide_disposition(scmd);\r\nif (rtn == SUCCESS)\r\nscmd->retries = scmd->allowed;\r\nelse if (rtn != NEEDS_RETRY)\r\ncontinue;\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_tur(struct scsi_cmnd *scmd)\r\n{\r\nstatic unsigned char tur_command[6] = {TEST_UNIT_READY, 0, 0, 0, 0, 0};\r\nint retry_cnt = 1, rtn;\r\nretry_tur:\r\nrtn = scsi_send_eh_cmnd(scmd, tur_command, 6, SENSE_TIMEOUT, 0);\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: scmd %p rtn %x\n",\r\n__func__, scmd, rtn));\r\nswitch (rtn) {\r\ncase NEEDS_RETRY:\r\nif (retry_cnt--)\r\ngoto retry_tur;\r\ncase SUCCESS:\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int scsi_eh_test_devices(struct list_head *cmd_list,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q, int try_stu)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nstruct scsi_device *sdev;\r\nint finish_cmds;\r\nwhile (!list_empty(cmd_list)) {\r\nscmd = list_entry(cmd_list->next, struct scsi_cmnd, eh_entry);\r\nsdev = scmd->device;\r\nfinish_cmds = !scsi_device_online(scmd->device) ||\r\n(try_stu && !scsi_eh_try_stu(scmd) &&\r\n!scsi_eh_tur(scmd)) ||\r\n!scsi_eh_tur(scmd);\r\nlist_for_each_entry_safe(scmd, next, cmd_list, eh_entry)\r\nif (scmd->device == sdev) {\r\nif (finish_cmds)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\nelse\r\nlist_move_tail(&scmd->eh_entry, work_q);\r\n}\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_abort_cmds(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nLIST_HEAD(check_list);\r\nint rtn;\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nif (!(scmd->eh_eflags & SCSI_EH_CANCEL_CMD))\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: aborting cmd:"\r\n"0x%p\n", current->comm,\r\nscmd));\r\nrtn = scsi_try_to_abort_cmd(scmd->device->host->hostt, scmd);\r\nif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\r\nscmd->eh_eflags &= ~SCSI_EH_CANCEL_CMD;\r\nif (rtn == FAST_IO_FAIL)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\nelse\r\nlist_move_tail(&scmd->eh_entry, &check_list);\r\n} else\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: aborting"\r\n" cmd failed:"\r\n"0x%p\n",\r\ncurrent->comm,\r\nscmd));\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\r\n}\r\nstatic int scsi_eh_try_stu(struct scsi_cmnd *scmd)\r\n{\r\nstatic unsigned char stu_command[6] = {START_STOP, 0, 0, 0, 1, 0};\r\nif (scmd->device->allow_restart) {\r\nint i, rtn = NEEDS_RETRY;\r\nfor (i = 0; rtn == NEEDS_RETRY && i < 2; i++)\r\nrtn = scsi_send_eh_cmnd(scmd, stu_command, 6, scmd->device->request_queue->rq_timeout, 0);\r\nif (rtn == SUCCESS)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int scsi_eh_stu(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *stu_scmd, *next;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, shost) {\r\nstu_scmd = NULL;\r\nlist_for_each_entry(scmd, work_q, eh_entry)\r\nif (scmd->device == sdev && SCSI_SENSE_VALID(scmd) &&\r\nscsi_check_sense(scmd) == FAILED ) {\r\nstu_scmd = scmd;\r\nbreak;\r\n}\r\nif (!stu_scmd)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Sending START_UNIT to sdev:"\r\n" 0x%p\n", current->comm, sdev));\r\nif (!scsi_eh_try_stu(stu_scmd)) {\r\nif (!scsi_device_online(sdev) ||\r\n!scsi_eh_tur(stu_scmd)) {\r\nlist_for_each_entry_safe(scmd, next,\r\nwork_q, eh_entry) {\r\nif (scmd->device == sdev)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nprintk("%s: START_UNIT failed to sdev:"\r\n" 0x%p\n", current->comm, sdev));\r\n}\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_bus_device_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *bdr_scmd, *next;\r\nstruct scsi_device *sdev;\r\nint rtn;\r\nshost_for_each_device(sdev, shost) {\r\nbdr_scmd = NULL;\r\nlist_for_each_entry(scmd, work_q, eh_entry)\r\nif (scmd->device == sdev) {\r\nbdr_scmd = scmd;\r\nbreak;\r\n}\r\nif (!bdr_scmd)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Sending BDR sdev:"\r\n" 0x%p\n", current->comm,\r\nsdev));\r\nrtn = scsi_try_bus_device_reset(bdr_scmd);\r\nif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\r\nif (!scsi_device_online(sdev) ||\r\nrtn == FAST_IO_FAIL ||\r\n!scsi_eh_tur(bdr_scmd)) {\r\nlist_for_each_entry_safe(scmd, next,\r\nwork_q, eh_entry) {\r\nif (scmd->device == sdev)\r\nscsi_eh_finish_cmd(scmd,\r\ndone_q);\r\n}\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: BDR"\r\n" failed sdev:"\r\n"0x%p\n",\r\ncurrent->comm,\r\nsdev));\r\n}\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_target_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nLIST_HEAD(tmp_list);\r\nLIST_HEAD(check_list);\r\nlist_splice_init(work_q, &tmp_list);\r\nwhile (!list_empty(&tmp_list)) {\r\nstruct scsi_cmnd *next, *scmd;\r\nint rtn;\r\nunsigned int id;\r\nscmd = list_entry(tmp_list.next, struct scsi_cmnd, eh_entry);\r\nid = scmd_id(scmd);\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Sending target reset "\r\n"to target %d\n",\r\ncurrent->comm, id));\r\nrtn = scsi_try_target_reset(scmd);\r\nif (rtn != SUCCESS && rtn != FAST_IO_FAIL)\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Target reset"\r\n" failed target: "\r\n"%d\n",\r\ncurrent->comm, id));\r\nlist_for_each_entry_safe(scmd, next, &tmp_list, eh_entry) {\r\nif (scmd_id(scmd) != id)\r\ncontinue;\r\nif (rtn == SUCCESS)\r\nlist_move_tail(&scmd->eh_entry, &check_list);\r\nelse if (rtn == FAST_IO_FAIL)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\nelse\r\nlist_move(&scmd->eh_entry, work_q);\r\n}\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\r\n}\r\nstatic int scsi_eh_bus_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *chan_scmd, *next;\r\nLIST_HEAD(check_list);\r\nunsigned int channel;\r\nint rtn;\r\nfor (channel = 0; channel <= shost->max_channel; channel++) {\r\nchan_scmd = NULL;\r\nlist_for_each_entry(scmd, work_q, eh_entry) {\r\nif (channel == scmd_channel(scmd)) {\r\nchan_scmd = scmd;\r\nbreak;\r\n}\r\n}\r\nif (!chan_scmd)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Sending BRST chan:"\r\n" %d\n", current->comm,\r\nchannel));\r\nrtn = scsi_try_bus_reset(chan_scmd);\r\nif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nif (channel == scmd_channel(scmd)) {\r\nif (rtn == FAST_IO_FAIL)\r\nscsi_eh_finish_cmd(scmd,\r\ndone_q);\r\nelse\r\nlist_move_tail(&scmd->eh_entry,\r\n&check_list);\r\n}\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: BRST"\r\n" failed chan: %d\n",\r\ncurrent->comm,\r\nchannel));\r\n}\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\r\n}\r\nstatic int scsi_eh_host_reset(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nLIST_HEAD(check_list);\r\nint rtn;\r\nif (!list_empty(work_q)) {\r\nscmd = list_entry(work_q->next,\r\nstruct scsi_cmnd, eh_entry);\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: Sending HRST\n"\r\n, current->comm));\r\nrtn = scsi_try_host_reset(scmd);\r\nif (rtn == SUCCESS) {\r\nlist_splice_init(work_q, &check_list);\r\n} else if (rtn == FAST_IO_FAIL) {\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: HRST"\r\n" failed\n",\r\ncurrent->comm));\r\n}\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 1);\r\n}\r\nstatic void scsi_eh_offline_sdevs(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nsdev_printk(KERN_INFO, scmd->device, "Device offlined - "\r\n"not ready after error recovery\n");\r\nscsi_device_set_state(scmd->device, SDEV_OFFLINE);\r\nif (scmd->eh_eflags & SCSI_EH_CANCEL_CMD) {\r\n}\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\nreturn;\r\n}\r\nint scsi_noretry_cmd(struct scsi_cmnd *scmd)\r\n{\r\nswitch (host_byte(scmd->result)) {\r\ncase DID_OK:\r\nbreak;\r\ncase DID_BUS_BUSY:\r\nreturn (scmd->request->cmd_flags & REQ_FAILFAST_TRANSPORT);\r\ncase DID_PARITY:\r\nreturn (scmd->request->cmd_flags & REQ_FAILFAST_DEV);\r\ncase DID_ERROR:\r\nif (msg_byte(scmd->result) == COMMAND_COMPLETE &&\r\nstatus_byte(scmd->result) == RESERVATION_CONFLICT)\r\nreturn 0;\r\ncase DID_SOFT_ERROR:\r\nreturn (scmd->request->cmd_flags & REQ_FAILFAST_DRIVER);\r\n}\r\nswitch (status_byte(scmd->result)) {\r\ncase CHECK_CONDITION:\r\nif (scmd->request->cmd_flags & REQ_FAILFAST_DEV ||\r\nscmd->request->cmd_type == REQ_TYPE_BLOCK_PC)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint scsi_decide_disposition(struct scsi_cmnd *scmd)\r\n{\r\nint rtn;\r\nif (!scsi_device_online(scmd->device)) {\r\nSCSI_LOG_ERROR_RECOVERY(5, printk("%s: device offline - report"\r\n" as SUCCESS\n",\r\n__func__));\r\nreturn SUCCESS;\r\n}\r\nswitch (host_byte(scmd->result)) {\r\ncase DID_PASSTHROUGH:\r\nscmd->result &= 0xff00ffff;\r\nreturn SUCCESS;\r\ncase DID_OK:\r\nbreak;\r\ncase DID_NO_CONNECT:\r\ncase DID_BAD_TARGET:\r\ncase DID_ABORT:\r\nreturn SUCCESS;\r\ncase DID_SOFT_ERROR:\r\ngoto maybe_retry;\r\ncase DID_IMM_RETRY:\r\nreturn NEEDS_RETRY;\r\ncase DID_REQUEUE:\r\nreturn ADD_TO_MLQUEUE;\r\ncase DID_TRANSPORT_DISRUPTED:\r\ngoto maybe_retry;\r\ncase DID_TRANSPORT_FAILFAST:\r\nreturn SUCCESS;\r\ncase DID_ERROR:\r\nif (msg_byte(scmd->result) == COMMAND_COMPLETE &&\r\nstatus_byte(scmd->result) == RESERVATION_CONFLICT)\r\nbreak;\r\ncase DID_BUS_BUSY:\r\ncase DID_PARITY:\r\ngoto maybe_retry;\r\ncase DID_TIME_OUT:\r\nif ((scmd->cmnd[0] == TEST_UNIT_READY ||\r\nscmd->cmnd[0] == INQUIRY)) {\r\nreturn SUCCESS;\r\n} else {\r\nreturn FAILED;\r\n}\r\ncase DID_RESET:\r\nreturn SUCCESS;\r\ndefault:\r\nreturn FAILED;\r\n}\r\nif (msg_byte(scmd->result) != COMMAND_COMPLETE)\r\nreturn FAILED;\r\nswitch (status_byte(scmd->result)) {\r\ncase QUEUE_FULL:\r\nscsi_handle_queue_full(scmd->device);\r\ncase BUSY:\r\nreturn ADD_TO_MLQUEUE;\r\ncase GOOD:\r\nscsi_handle_queue_ramp_up(scmd->device);\r\ncase COMMAND_TERMINATED:\r\nreturn SUCCESS;\r\ncase TASK_ABORTED:\r\ngoto maybe_retry;\r\ncase CHECK_CONDITION:\r\nrtn = scsi_check_sense(scmd);\r\nif (rtn == NEEDS_RETRY)\r\ngoto maybe_retry;\r\nelse if (rtn == TARGET_ERROR) {\r\nset_host_byte(scmd, DID_TARGET_FAILURE);\r\nrtn = SUCCESS;\r\n}\r\nreturn rtn;\r\ncase CONDITION_GOOD:\r\ncase INTERMEDIATE_GOOD:\r\ncase INTERMEDIATE_C_GOOD:\r\ncase ACA_ACTIVE:\r\nreturn SUCCESS;\r\ncase RESERVATION_CONFLICT:\r\nsdev_printk(KERN_INFO, scmd->device,\r\n"reservation conflict\n");\r\nset_host_byte(scmd, DID_NEXUS_FAILURE);\r\nreturn SUCCESS;\r\ndefault:\r\nreturn FAILED;\r\n}\r\nreturn FAILED;\r\nmaybe_retry:\r\nif ((++scmd->retries) <= scmd->allowed\r\n&& !scsi_noretry_cmd(scmd)) {\r\nreturn NEEDS_RETRY;\r\n} else {\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic void eh_lock_door_done(struct request *req, int uptodate)\r\n{\r\n__blk_put_request(req->q, req);\r\n}\r\nstatic void scsi_eh_lock_door(struct scsi_device *sdev)\r\n{\r\nstruct request *req;\r\nreq = blk_get_request(sdev->request_queue, READ, GFP_KERNEL);\r\nreq->cmd[0] = ALLOW_MEDIUM_REMOVAL;\r\nreq->cmd[1] = 0;\r\nreq->cmd[2] = 0;\r\nreq->cmd[3] = 0;\r\nreq->cmd[4] = SCSI_REMOVAL_PREVENT;\r\nreq->cmd[5] = 0;\r\nreq->cmd_len = COMMAND_SIZE(req->cmd[0]);\r\nreq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nreq->cmd_flags |= REQ_QUIET;\r\nreq->timeout = 10 * HZ;\r\nreq->retries = 5;\r\nblk_execute_rq_nowait(req->q, NULL, req, 1, eh_lock_door_done);\r\n}\r\nstatic void scsi_restart_operations(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nshost_for_each_device(sdev, shost) {\r\nif (scsi_device_online(sdev) && sdev->locked)\r\nscsi_eh_lock_door(sdev);\r\n}\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: waking up host to restart\n",\r\n__func__));\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_RUNNING))\r\nif (scsi_host_set_state(shost, SHOST_CANCEL))\r\nBUG_ON(scsi_host_set_state(shost, SHOST_DEL));\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nwake_up(&shost->host_wait);\r\nscsi_run_host_queues(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (shost->host_eh_scheduled)\r\nif (scsi_host_set_state(shost, SHOST_RECOVERY))\r\nWARN_ON(scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY));\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nvoid scsi_eh_ready_devs(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nif (!scsi_eh_stu(shost, work_q, done_q))\r\nif (!scsi_eh_bus_device_reset(shost, work_q, done_q))\r\nif (!scsi_eh_target_reset(shost, work_q, done_q))\r\nif (!scsi_eh_bus_reset(shost, work_q, done_q))\r\nif (!scsi_eh_host_reset(work_q, done_q))\r\nscsi_eh_offline_sdevs(work_q,\r\ndone_q);\r\n}\r\nvoid scsi_eh_flush_done_q(struct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nlist_for_each_entry_safe(scmd, next, done_q, eh_entry) {\r\nlist_del_init(&scmd->eh_entry);\r\nif (scsi_device_online(scmd->device) &&\r\n!scsi_noretry_cmd(scmd) &&\r\n(++scmd->retries <= scmd->allowed)) {\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: flush"\r\n" retry cmd: %p\n",\r\ncurrent->comm,\r\nscmd));\r\nscsi_queue_insert(scmd, SCSI_MLQUEUE_EH_RETRY);\r\n} else {\r\nif (!scmd->result)\r\nscmd->result |= (DRIVER_TIMEOUT << 24);\r\nSCSI_LOG_ERROR_RECOVERY(3, printk("%s: flush finish"\r\n" cmd: %p\n",\r\ncurrent->comm, scmd));\r\nscsi_finish_command(scmd);\r\n}\r\n}\r\n}\r\nstatic void scsi_unjam_host(struct Scsi_Host *shost)\r\n{\r\nunsigned long flags;\r\nLIST_HEAD(eh_work_q);\r\nLIST_HEAD(eh_done_q);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_splice_init(&shost->eh_cmd_q, &eh_work_q);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nSCSI_LOG_ERROR_RECOVERY(1, scsi_eh_prt_fail_stats(shost, &eh_work_q));\r\nif (!scsi_eh_get_sense(&eh_work_q, &eh_done_q))\r\nif (!scsi_eh_abort_cmds(&eh_work_q, &eh_done_q))\r\nscsi_eh_ready_devs(shost, &eh_work_q, &eh_done_q);\r\nscsi_eh_flush_done_q(&eh_done_q);\r\n}\r\nint scsi_error_handler(void *data)\r\n{\r\nstruct Scsi_Host *shost = data;\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||\r\nshost->host_failed != shost->host_busy) {\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nprintk("Error handler scsi_eh_%d sleeping\n",\r\nshost->host_no));\r\nschedule();\r\ncontinue;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nprintk("Error handler scsi_eh_%d waking up\n",\r\nshost->host_no));\r\nif (!shost->eh_noresume && scsi_autopm_get_host(shost) != 0) {\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nprintk(KERN_ERR "Error handler scsi_eh_%d "\r\n"unable to autoresume\n",\r\nshost->host_no));\r\ncontinue;\r\n}\r\nif (shost->transportt->eh_strategy_handler)\r\nshost->transportt->eh_strategy_handler(shost);\r\nelse\r\nscsi_unjam_host(shost);\r\nscsi_restart_operations(shost);\r\nif (!shost->eh_noresume)\r\nscsi_autopm_put_host(shost);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nprintk("Error handler scsi_eh_%d exiting\n", shost->host_no));\r\nshost->ehandler = NULL;\r\nreturn 0;\r\n}\r\nvoid scsi_report_bus_reset(struct Scsi_Host *shost, int channel)\r\n{\r\nstruct scsi_device *sdev;\r\n__shost_for_each_device(sdev, shost) {\r\nif (channel == sdev_channel(sdev))\r\n__scsi_report_device_reset(sdev, NULL);\r\n}\r\n}\r\nvoid scsi_report_device_reset(struct Scsi_Host *shost, int channel, int target)\r\n{\r\nstruct scsi_device *sdev;\r\n__shost_for_each_device(sdev, shost) {\r\nif (channel == sdev_channel(sdev) &&\r\ntarget == sdev_id(sdev))\r\n__scsi_report_device_reset(sdev, NULL);\r\n}\r\n}\r\nstatic void\r\nscsi_reset_provider_done_command(struct scsi_cmnd *scmd)\r\n{\r\n}\r\nint\r\nscsi_reset_provider(struct scsi_device *dev, int flag)\r\n{\r\nstruct scsi_cmnd *scmd;\r\nstruct Scsi_Host *shost = dev->host;\r\nstruct request req;\r\nunsigned long flags;\r\nint rtn;\r\nif (scsi_autopm_get_host(shost) < 0)\r\nreturn FAILED;\r\nscmd = scsi_get_command(dev, GFP_KERNEL);\r\nblk_rq_init(NULL, &req);\r\nscmd->request = &req;\r\nscmd->cmnd = req.cmd;\r\nscmd->scsi_done = scsi_reset_provider_done_command;\r\nmemset(&scmd->sdb, 0, sizeof(scmd->sdb));\r\nscmd->cmd_len = 0;\r\nscmd->sc_data_direction = DMA_BIDIRECTIONAL;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nshost->tmf_in_progress = 1;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nswitch (flag) {\r\ncase SCSI_TRY_RESET_DEVICE:\r\nrtn = scsi_try_bus_device_reset(scmd);\r\nif (rtn == SUCCESS)\r\nbreak;\r\ncase SCSI_TRY_RESET_TARGET:\r\nrtn = scsi_try_target_reset(scmd);\r\nif (rtn == SUCCESS)\r\nbreak;\r\ncase SCSI_TRY_RESET_BUS:\r\nrtn = scsi_try_bus_reset(scmd);\r\nif (rtn == SUCCESS)\r\nbreak;\r\ncase SCSI_TRY_RESET_HOST:\r\nrtn = scsi_try_host_reset(scmd);\r\nbreak;\r\ndefault:\r\nrtn = FAILED;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nshost->tmf_in_progress = 0;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nprintk("%s: waking up host to restart after TMF\n",\r\n__func__));\r\nwake_up(&shost->host_wait);\r\nscsi_run_host_queues(shost);\r\nscsi_next_command(scmd);\r\nscsi_autopm_put_host(shost);\r\nreturn rtn;\r\n}\r\nint scsi_normalize_sense(const u8 *sense_buffer, int sb_len,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nif (!sense_buffer || !sb_len)\r\nreturn 0;\r\nmemset(sshdr, 0, sizeof(struct scsi_sense_hdr));\r\nsshdr->response_code = (sense_buffer[0] & 0x7f);\r\nif (!scsi_sense_valid(sshdr))\r\nreturn 0;\r\nif (sshdr->response_code >= 0x72) {\r\nif (sb_len > 1)\r\nsshdr->sense_key = (sense_buffer[1] & 0xf);\r\nif (sb_len > 2)\r\nsshdr->asc = sense_buffer[2];\r\nif (sb_len > 3)\r\nsshdr->ascq = sense_buffer[3];\r\nif (sb_len > 7)\r\nsshdr->additional_length = sense_buffer[7];\r\n} else {\r\nif (sb_len > 2)\r\nsshdr->sense_key = (sense_buffer[2] & 0xf);\r\nif (sb_len > 7) {\r\nsb_len = (sb_len < (sense_buffer[7] + 8)) ?\r\nsb_len : (sense_buffer[7] + 8);\r\nif (sb_len > 12)\r\nsshdr->asc = sense_buffer[12];\r\nif (sb_len > 13)\r\nsshdr->ascq = sense_buffer[13];\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint scsi_command_normalize_sense(struct scsi_cmnd *cmd,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nreturn scsi_normalize_sense(cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, sshdr);\r\n}\r\nconst u8 * scsi_sense_desc_find(const u8 * sense_buffer, int sb_len,\r\nint desc_type)\r\n{\r\nint add_sen_len, add_len, desc_len, k;\r\nconst u8 * descp;\r\nif ((sb_len < 8) || (0 == (add_sen_len = sense_buffer[7])))\r\nreturn NULL;\r\nif ((sense_buffer[0] < 0x72) || (sense_buffer[0] > 0x73))\r\nreturn NULL;\r\nadd_sen_len = (add_sen_len < (sb_len - 8)) ?\r\nadd_sen_len : (sb_len - 8);\r\ndescp = &sense_buffer[8];\r\nfor (desc_len = 0, k = 0; k < add_sen_len; k += desc_len) {\r\ndescp += desc_len;\r\nadd_len = (k < (add_sen_len - 1)) ? descp[1]: -1;\r\ndesc_len = add_len + 2;\r\nif (descp[0] == desc_type)\r\nreturn descp;\r\nif (add_len < 0)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nint scsi_get_sense_info_fld(const u8 * sense_buffer, int sb_len,\r\nu64 * info_out)\r\n{\r\nint j;\r\nconst u8 * ucp;\r\nu64 ull;\r\nif (sb_len < 7)\r\nreturn 0;\r\nswitch (sense_buffer[0] & 0x7f) {\r\ncase 0x70:\r\ncase 0x71:\r\nif (sense_buffer[0] & 0x80) {\r\n*info_out = (sense_buffer[3] << 24) +\r\n(sense_buffer[4] << 16) +\r\n(sense_buffer[5] << 8) + sense_buffer[6];\r\nreturn 1;\r\n} else\r\nreturn 0;\r\ncase 0x72:\r\ncase 0x73:\r\nucp = scsi_sense_desc_find(sense_buffer, sb_len,\r\n0 );\r\nif (ucp && (0xa == ucp[1])) {\r\null = 0;\r\nfor (j = 0; j < 8; ++j) {\r\nif (j > 0)\r\null <<= 8;\r\null |= ucp[4 + j];\r\n}\r\n*info_out = ull;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid scsi_build_sense_buffer(int desc, u8 *buf, u8 key, u8 asc, u8 ascq)\r\n{\r\nif (desc) {\r\nbuf[0] = 0x72;\r\nbuf[1] = key;\r\nbuf[2] = asc;\r\nbuf[3] = ascq;\r\nbuf[7] = 0;\r\n} else {\r\nbuf[0] = 0x70;\r\nbuf[2] = key;\r\nbuf[7] = 0xa;\r\nbuf[12] = asc;\r\nbuf[13] = ascq;\r\n}\r\n}
