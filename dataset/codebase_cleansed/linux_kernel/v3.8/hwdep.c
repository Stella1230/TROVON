static struct snd_hwdep *snd_hwdep_search(struct snd_card *card, int device)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nlist_for_each_entry(hwdep, &snd_hwdep_devices, list)\r\nif (hwdep->card == card && hwdep->device == device)\r\nreturn hwdep;\r\nreturn NULL;\r\n}\r\nstatic loff_t snd_hwdep_llseek(struct file * file, loff_t offset, int orig)\r\n{\r\nstruct snd_hwdep *hw = file->private_data;\r\nif (hw->ops.llseek)\r\nreturn hw->ops.llseek(hw, file, offset, orig);\r\nreturn -ENXIO;\r\n}\r\nstatic ssize_t snd_hwdep_read(struct file * file, char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct snd_hwdep *hw = file->private_data;\r\nif (hw->ops.read)\r\nreturn hw->ops.read(hw, buf, count, offset);\r\nreturn -ENXIO;\r\n}\r\nstatic ssize_t snd_hwdep_write(struct file * file, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct snd_hwdep *hw = file->private_data;\r\nif (hw->ops.write)\r\nreturn hw->ops.write(hw, buf, count, offset);\r\nreturn -ENXIO;\r\n}\r\nstatic int snd_hwdep_open(struct inode *inode, struct file * file)\r\n{\r\nint major = imajor(inode);\r\nstruct snd_hwdep *hw;\r\nint err;\r\nwait_queue_t wait;\r\nif (major == snd_major) {\r\nhw = snd_lookup_minor_data(iminor(inode),\r\nSNDRV_DEVICE_TYPE_HWDEP);\r\n#ifdef CONFIG_SND_OSSEMUL\r\n} else if (major == SOUND_MAJOR) {\r\nhw = snd_lookup_oss_minor_data(iminor(inode),\r\nSNDRV_OSS_DEVICE_TYPE_DMFM);\r\n#endif\r\n} else\r\nreturn -ENXIO;\r\nif (hw == NULL)\r\nreturn -ENODEV;\r\nif (!try_module_get(hw->card->module)) {\r\nsnd_card_unref(hw->card);\r\nreturn -EFAULT;\r\n}\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&hw->open_wait, &wait);\r\nmutex_lock(&hw->open_mutex);\r\nwhile (1) {\r\nif (hw->exclusive && hw->used > 0) {\r\nerr = -EBUSY;\r\nbreak;\r\n}\r\nif (!hw->ops.open) {\r\nerr = 0;\r\nbreak;\r\n}\r\nerr = hw->ops.open(hw, file);\r\nif (err >= 0)\r\nbreak;\r\nif (err == -EAGAIN) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nerr = -EBUSY;\r\nbreak;\r\n}\r\n} else\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nmutex_unlock(&hw->open_mutex);\r\nschedule();\r\nmutex_lock(&hw->open_mutex);\r\nif (hw->card->shutdown) {\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&hw->open_wait, &wait);\r\nif (err >= 0) {\r\nerr = snd_card_file_add(hw->card, file);\r\nif (err >= 0) {\r\nfile->private_data = hw;\r\nhw->used++;\r\n} else {\r\nif (hw->ops.release)\r\nhw->ops.release(hw, file);\r\n}\r\n}\r\nmutex_unlock(&hw->open_mutex);\r\nif (err < 0)\r\nmodule_put(hw->card->module);\r\nsnd_card_unref(hw->card);\r\nreturn err;\r\n}\r\nstatic int snd_hwdep_release(struct inode *inode, struct file * file)\r\n{\r\nint err = 0;\r\nstruct snd_hwdep *hw = file->private_data;\r\nstruct module *mod = hw->card->module;\r\nmutex_lock(&hw->open_mutex);\r\nif (hw->ops.release)\r\nerr = hw->ops.release(hw, file);\r\nif (hw->used > 0)\r\nhw->used--;\r\nmutex_unlock(&hw->open_mutex);\r\nwake_up(&hw->open_wait);\r\nsnd_card_file_remove(hw->card, file);\r\nmodule_put(mod);\r\nreturn err;\r\n}\r\nstatic unsigned int snd_hwdep_poll(struct file * file, poll_table * wait)\r\n{\r\nstruct snd_hwdep *hw = file->private_data;\r\nif (hw->ops.poll)\r\nreturn hw->ops.poll(hw, file, wait);\r\nreturn 0;\r\n}\r\nstatic int snd_hwdep_info(struct snd_hwdep *hw,\r\nstruct snd_hwdep_info __user *_info)\r\n{\r\nstruct snd_hwdep_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.card = hw->card->number;\r\nstrlcpy(info.id, hw->id, sizeof(info.id));\r\nstrlcpy(info.name, hw->name, sizeof(info.name));\r\ninfo.iface = hw->iface;\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_hwdep_dsp_status(struct snd_hwdep *hw,\r\nstruct snd_hwdep_dsp_status __user *_info)\r\n{\r\nstruct snd_hwdep_dsp_status info;\r\nint err;\r\nif (! hw->ops.dsp_status)\r\nreturn -ENXIO;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.dsp_loaded = hw->dsp_loaded;\r\nif ((err = hw->ops.dsp_status(hw, &info)) < 0)\r\nreturn err;\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_hwdep_dsp_load(struct snd_hwdep *hw,\r\nstruct snd_hwdep_dsp_image __user *_info)\r\n{\r\nstruct snd_hwdep_dsp_image info;\r\nint err;\r\nif (! hw->ops.dsp_load)\r\nreturn -ENXIO;\r\nmemset(&info, 0, sizeof(info));\r\nif (copy_from_user(&info, _info, sizeof(info)))\r\nreturn -EFAULT;\r\nif (hw->dsp_loaded & (1 << info.index))\r\nreturn -EBUSY;\r\nif (!access_ok(VERIFY_READ, info.image, info.length))\r\nreturn -EFAULT;\r\nerr = hw->ops.dsp_load(hw, &info);\r\nif (err < 0)\r\nreturn err;\r\nhw->dsp_loaded |= (1 << info.index);\r\nreturn 0;\r\n}\r\nstatic long snd_hwdep_ioctl(struct file * file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct snd_hwdep *hw = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase SNDRV_HWDEP_IOCTL_PVERSION:\r\nreturn put_user(SNDRV_HWDEP_VERSION, (int __user *)argp);\r\ncase SNDRV_HWDEP_IOCTL_INFO:\r\nreturn snd_hwdep_info(hw, argp);\r\ncase SNDRV_HWDEP_IOCTL_DSP_STATUS:\r\nreturn snd_hwdep_dsp_status(hw, argp);\r\ncase SNDRV_HWDEP_IOCTL_DSP_LOAD:\r\nreturn snd_hwdep_dsp_load(hw, argp);\r\n}\r\nif (hw->ops.ioctl)\r\nreturn hw->ops.ioctl(hw, file, cmd, arg);\r\nreturn -ENOTTY;\r\n}\r\nstatic int snd_hwdep_mmap(struct file * file, struct vm_area_struct * vma)\r\n{\r\nstruct snd_hwdep *hw = file->private_data;\r\nif (hw->ops.mmap)\r\nreturn hw->ops.mmap(hw, file, vma);\r\nreturn -ENXIO;\r\n}\r\nstatic int snd_hwdep_control_ioctl(struct snd_card *card,\r\nstruct snd_ctl_file * control,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE:\r\n{\r\nint device;\r\nif (get_user(device, (int __user *)arg))\r\nreturn -EFAULT;\r\nmutex_lock(&register_mutex);\r\nif (device < 0)\r\ndevice = 0;\r\nelse if (device < SNDRV_MINOR_HWDEPS)\r\ndevice++;\r\nelse\r\ndevice = SNDRV_MINOR_HWDEPS;\r\nwhile (device < SNDRV_MINOR_HWDEPS) {\r\nif (snd_hwdep_search(card, device))\r\nbreak;\r\ndevice++;\r\n}\r\nif (device >= SNDRV_MINOR_HWDEPS)\r\ndevice = -1;\r\nmutex_unlock(&register_mutex);\r\nif (put_user(device, (int __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SNDRV_CTL_IOCTL_HWDEP_INFO:\r\n{\r\nstruct snd_hwdep_info __user *info = (struct snd_hwdep_info __user *)arg;\r\nint device, err;\r\nstruct snd_hwdep *hwdep;\r\nif (get_user(device, &info->device))\r\nreturn -EFAULT;\r\nmutex_lock(&register_mutex);\r\nhwdep = snd_hwdep_search(card, device);\r\nif (hwdep)\r\nerr = snd_hwdep_info(hwdep, info);\r\nelse\r\nerr = -ENXIO;\r\nmutex_unlock(&register_mutex);\r\nreturn err;\r\n}\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint snd_hwdep_new(struct snd_card *card, char *id, int device,\r\nstruct snd_hwdep **rhwdep)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_hwdep_dev_free,\r\n.dev_register = snd_hwdep_dev_register,\r\n.dev_disconnect = snd_hwdep_dev_disconnect,\r\n};\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nif (rhwdep)\r\n*rhwdep = NULL;\r\nhwdep = kzalloc(sizeof(*hwdep), GFP_KERNEL);\r\nif (hwdep == NULL) {\r\nsnd_printk(KERN_ERR "hwdep: cannot allocate\n");\r\nreturn -ENOMEM;\r\n}\r\nhwdep->card = card;\r\nhwdep->device = device;\r\nif (id)\r\nstrlcpy(hwdep->id, id, sizeof(hwdep->id));\r\n#ifdef CONFIG_SND_OSSEMUL\r\nhwdep->oss_type = -1;\r\n#endif\r\nif ((err = snd_device_new(card, SNDRV_DEV_HWDEP, hwdep, &ops)) < 0) {\r\nsnd_hwdep_free(hwdep);\r\nreturn err;\r\n}\r\ninit_waitqueue_head(&hwdep->open_wait);\r\nmutex_init(&hwdep->open_mutex);\r\nif (rhwdep)\r\n*rhwdep = hwdep;\r\nreturn 0;\r\n}\r\nstatic int snd_hwdep_free(struct snd_hwdep *hwdep)\r\n{\r\nif (!hwdep)\r\nreturn 0;\r\nif (hwdep->private_free)\r\nhwdep->private_free(hwdep);\r\nkfree(hwdep);\r\nreturn 0;\r\n}\r\nstatic int snd_hwdep_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_hwdep *hwdep = device->device_data;\r\nreturn snd_hwdep_free(hwdep);\r\n}\r\nstatic int snd_hwdep_dev_register(struct snd_device *device)\r\n{\r\nstruct snd_hwdep *hwdep = device->device_data;\r\nint err;\r\nchar name[32];\r\nmutex_lock(&register_mutex);\r\nif (snd_hwdep_search(hwdep->card, hwdep->device)) {\r\nmutex_unlock(&register_mutex);\r\nreturn -EBUSY;\r\n}\r\nlist_add_tail(&hwdep->list, &snd_hwdep_devices);\r\nsprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);\r\nif ((err = snd_register_device(SNDRV_DEVICE_TYPE_HWDEP,\r\nhwdep->card, hwdep->device,\r\n&snd_hwdep_f_ops, hwdep, name)) < 0) {\r\nsnd_printk(KERN_ERR "unable to register hardware dependent device %i:%i\n",\r\nhwdep->card->number, hwdep->device);\r\nlist_del(&hwdep->list);\r\nmutex_unlock(&register_mutex);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_OSSEMUL\r\nhwdep->ossreg = 0;\r\nif (hwdep->oss_type >= 0) {\r\nif ((hwdep->oss_type == SNDRV_OSS_DEVICE_TYPE_DMFM) && (hwdep->device != 0)) {\r\nsnd_printk (KERN_WARNING "only hwdep device 0 can be registered as OSS direct FM device!\n");\r\n} else {\r\nif (snd_register_oss_device(hwdep->oss_type,\r\nhwdep->card, hwdep->device,\r\n&snd_hwdep_f_ops, hwdep,\r\nhwdep->oss_dev) < 0) {\r\nsnd_printk(KERN_ERR "unable to register OSS compatibility device %i:%i\n",\r\nhwdep->card->number, hwdep->device);\r\n} else\r\nhwdep->ossreg = 1;\r\n}\r\n}\r\n#endif\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_hwdep_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_hwdep *hwdep = device->device_data;\r\nif (snd_BUG_ON(!hwdep))\r\nreturn -ENXIO;\r\nmutex_lock(&register_mutex);\r\nif (snd_hwdep_search(hwdep->card, hwdep->device) != hwdep) {\r\nmutex_unlock(&register_mutex);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&hwdep->open_mutex);\r\nwake_up(&hwdep->open_wait);\r\n#ifdef CONFIG_SND_OSSEMUL\r\nif (hwdep->ossreg)\r\nsnd_unregister_oss_device(hwdep->oss_type, hwdep->card, hwdep->device);\r\n#endif\r\nsnd_unregister_device(SNDRV_DEVICE_TYPE_HWDEP, hwdep->card, hwdep->device);\r\nlist_del_init(&hwdep->list);\r\nmutex_unlock(&hwdep->open_mutex);\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nstatic void snd_hwdep_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nmutex_lock(&register_mutex);\r\nlist_for_each_entry(hwdep, &snd_hwdep_devices, list)\r\nsnd_iprintf(buffer, "%02i-%02i: %s\n",\r\nhwdep->card->number, hwdep->device, hwdep->name);\r\nmutex_unlock(&register_mutex);\r\n}\r\nstatic void __init snd_hwdep_proc_init(void)\r\n{\r\nstruct snd_info_entry *entry;\r\nif ((entry = snd_info_create_module_entry(THIS_MODULE, "hwdep", NULL)) != NULL) {\r\nentry->c.text.read = snd_hwdep_proc_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\nsnd_hwdep_proc_entry = entry;\r\n}\r\nstatic void __exit snd_hwdep_proc_done(void)\r\n{\r\nsnd_info_free_entry(snd_hwdep_proc_entry);\r\n}\r\nstatic int __init alsa_hwdep_init(void)\r\n{\r\nsnd_hwdep_proc_init();\r\nsnd_ctl_register_ioctl(snd_hwdep_control_ioctl);\r\nsnd_ctl_register_ioctl_compat(snd_hwdep_control_ioctl);\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_hwdep_exit(void)\r\n{\r\nsnd_ctl_unregister_ioctl(snd_hwdep_control_ioctl);\r\nsnd_ctl_unregister_ioctl_compat(snd_hwdep_control_ioctl);\r\nsnd_hwdep_proc_done();\r\n}
