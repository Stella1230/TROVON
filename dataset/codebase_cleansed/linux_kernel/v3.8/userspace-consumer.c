static ssize_t reg_show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct userspace_consumer_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic ssize_t reg_show_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct userspace_consumer_data *data = dev_get_drvdata(dev);\r\nif (data->enabled)\r\nreturn sprintf(buf, "enabled\n");\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\nstatic ssize_t reg_set_state(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct userspace_consumer_data *data = dev_get_drvdata(dev);\r\nbool enabled;\r\nint ret;\r\nif (sysfs_streq(buf, "enabled\n") || sysfs_streq(buf, "1"))\r\nenabled = true;\r\nelse if (sysfs_streq(buf, "disabled\n") || sysfs_streq(buf, "0"))\r\nenabled = false;\r\nelse {\r\ndev_err(dev, "Configuring invalid mode\n");\r\nreturn count;\r\n}\r\nmutex_lock(&data->lock);\r\nif (enabled != data->enabled) {\r\nif (enabled)\r\nret = regulator_bulk_enable(data->num_supplies,\r\ndata->supplies);\r\nelse\r\nret = regulator_bulk_disable(data->num_supplies,\r\ndata->supplies);\r\nif (ret == 0)\r\ndata->enabled = enabled;\r\nelse\r\ndev_err(dev, "Failed to configure state: %d\n", ret);\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic int regulator_userspace_consumer_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_userspace_consumer_data *pdata;\r\nstruct userspace_consumer_data *drvdata;\r\nint ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\ndrvdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct userspace_consumer_data),\r\nGFP_KERNEL);\r\nif (drvdata == NULL)\r\nreturn -ENOMEM;\r\ndrvdata->name = pdata->name;\r\ndrvdata->num_supplies = pdata->num_supplies;\r\ndrvdata->supplies = pdata->supplies;\r\nmutex_init(&drvdata->lock);\r\nret = devm_regulator_bulk_get(&pdev->dev, drvdata->num_supplies,\r\ndrvdata->supplies);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &attr_group);\r\nif (ret != 0)\r\nreturn ret;\r\nif (pdata->init_on) {\r\nret = regulator_bulk_enable(drvdata->num_supplies,\r\ndrvdata->supplies);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to set initial state: %d\n", ret);\r\ngoto err_enable;\r\n}\r\n}\r\ndrvdata->enabled = pdata->init_on;\r\nplatform_set_drvdata(pdev, drvdata);\r\nreturn 0;\r\nerr_enable:\r\nsysfs_remove_group(&pdev->dev.kobj, &attr_group);\r\nreturn ret;\r\n}\r\nstatic int regulator_userspace_consumer_remove(struct platform_device *pdev)\r\n{\r\nstruct userspace_consumer_data *data = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&pdev->dev.kobj, &attr_group);\r\nif (data->enabled)\r\nregulator_bulk_disable(data->num_supplies, data->supplies);\r\nreturn 0;\r\n}
