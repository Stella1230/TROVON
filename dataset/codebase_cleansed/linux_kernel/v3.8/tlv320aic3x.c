static int snd_soc_dapm_put_volsw_aic3x(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nunsigned int invert = mc->invert;\r\nunsigned short val, val_mask;\r\nint ret;\r\nstruct snd_soc_dapm_path *path;\r\nint found = 0;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nmask = 0xf;\r\nif (val)\r\nval = mask;\r\nif (invert)\r\nval = mask - val;\r\nval_mask = mask << shift;\r\nval = val << shift;\r\nmutex_lock(&widget->codec->mutex);\r\nif (snd_soc_test_bits(widget->codec, reg, val_mask, val)) {\r\nlist_for_each_entry(path, &widget->dapm->card->paths, list) {\r\nif (path->kcontrol != kcontrol)\r\ncontinue;\r\nfound = 1;\r\nif (val)\r\npath->connect = invert ? 0 : 1;\r\nelse\r\npath->connect = invert ? 1 : 0;\r\ndapm_mark_dirty(path->source, "tlv320aic3x source");\r\ndapm_mark_dirty(path->sink, "tlv320aic3x sink");\r\nbreak;\r\n}\r\nif (found)\r\nsnd_soc_dapm_sync(widget->dapm);\r\n}\r\nret = snd_soc_update_bits(widget->codec, reg, val_mask, val);\r\nmutex_unlock(&widget->codec->mutex);\r\nreturn ret;\r\n}\r\nstatic int aic3x_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nsnd_soc_dapm_new_controls(dapm, aic3x_dapm_widgets,\r\nARRAY_SIZE(aic3x_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));\r\nif (aic3x->model == AIC3X_MODEL_3007) {\r\nsnd_soc_dapm_new_controls(dapm, aic3007_dapm_widgets,\r\nARRAY_SIZE(aic3007_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_3007,\r\nARRAY_SIZE(intercon_3007));\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint codec_clk = 0, bypass_pll = 0, fsref, last_clk = 0;\r\nu8 data, j, r, p, pll_q, pll_p = 1, pll_r = 1, pll_j = 1;\r\nu16 d, pll_d = 1;\r\nint clk;\r\ndata = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & (~(0x3 << 4));\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ndata |= (0x01 << 4);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndata |= (0x02 << 4);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndata |= (0x03 << 4);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLB, data);\r\nfsref = (params_rate(params) % 11025 == 0) ? 44100 : 48000;\r\nfor (pll_q = 2; pll_q < 18; pll_q++)\r\nif (aic3x->sysclk / (128 * pll_q) == fsref) {\r\nbypass_pll = 1;\r\nbreak;\r\n}\r\nif (bypass_pll) {\r\npll_q &= 0xf;\r\nsnd_soc_write(codec, AIC3X_PLL_PROGA_REG, pll_q << PLLQ_SHIFT);\r\nsnd_soc_write(codec, AIC3X_GPIOB_REG, CODEC_CLKIN_CLKDIV);\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG, PLL_ENABLE, 0);\r\n} else {\r\nsnd_soc_write(codec, AIC3X_GPIOB_REG, CODEC_CLKIN_PLLDIV);\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG,\r\nPLL_ENABLE, PLL_ENABLE);\r\n}\r\ndata = (LDAC2LCH | RDAC2RCH);\r\ndata |= (fsref == 44100) ? FSREF_44100 : FSREF_48000;\r\nif (params_rate(params) >= 64000)\r\ndata |= DUAL_RATE_MODE;\r\nsnd_soc_write(codec, AIC3X_CODEC_DATAPATH_REG, data);\r\ndata = (fsref * 20) / params_rate(params);\r\nif (params_rate(params) < 64000)\r\ndata /= 2;\r\ndata /= 5;\r\ndata -= 2;\r\ndata |= (data << 4);\r\nsnd_soc_write(codec, AIC3X_SAMPLE_RATE_SEL_REG, data);\r\nif (bypass_pll)\r\nreturn 0;\r\ncodec_clk = (2048 * fsref) / (aic3x->sysclk / 1000);\r\nfor (r = 1; r <= 16; r++)\r\nfor (p = 1; p <= 8; p++) {\r\nfor (j = 4; j <= 55; j++) {\r\nint tmp_clk = (1000 * j * r) / p;\r\nif (abs(codec_clk - tmp_clk) <\r\nabs(codec_clk - last_clk)) {\r\npll_j = j; pll_d = 0;\r\npll_r = r; pll_p = p;\r\nlast_clk = tmp_clk;\r\n}\r\nif (tmp_clk == codec_clk)\r\ngoto found;\r\n}\r\n}\r\nfor (p = 1; p <= 8; p++) {\r\nj = codec_clk * p / 1000;\r\nif (j < 4 || j > 11)\r\ncontinue;\r\nd = ((2048 * p * fsref) - j * aic3x->sysclk)\r\n* 100 / (aic3x->sysclk/100);\r\nclk = (10000 * j + d) / (10 * p);\r\nif (abs(codec_clk - clk) < abs(codec_clk - last_clk)) {\r\npll_j = j; pll_d = d; pll_r = 1; pll_p = p;\r\nlast_clk = clk;\r\n}\r\nif (clk == codec_clk)\r\ngoto found;\r\n}\r\nif (last_clk == 0) {\r\nprintk(KERN_ERR "%s(): unable to setup PLL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nfound:\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG, PLLP_MASK, pll_p);\r\nsnd_soc_write(codec, AIC3X_OVRF_STATUS_AND_PLLR_REG,\r\npll_r << PLLR_SHIFT);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGB_REG, pll_j << PLLJ_SHIFT);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGC_REG,\r\n(pll_d >> 6) << PLLD_MSB_SHIFT);\r\nsnd_soc_write(codec, AIC3X_PLL_PROGD_REG,\r\n(pll_d & 0x3F) << PLLD_LSB_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int aic3x_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 ldac_reg = snd_soc_read(codec, LDAC_VOL) & ~MUTE_ON;\r\nu8 rdac_reg = snd_soc_read(codec, RDAC_VOL) & ~MUTE_ON;\r\nif (mute) {\r\nsnd_soc_write(codec, LDAC_VOL, ldac_reg | MUTE_ON);\r\nsnd_soc_write(codec, RDAC_VOL, rdac_reg | MUTE_ON);\r\n} else {\r\nsnd_soc_write(codec, LDAC_VOL, ldac_reg);\r\nsnd_soc_write(codec, RDAC_VOL, rdac_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_update_bits(codec, AIC3X_CLKGEN_CTRL_REG, PLLCLK_IN_MASK,\r\nclk_id << PLLCLK_IN_SHIFT);\r\nsnd_soc_update_bits(codec, AIC3X_CLKGEN_CTRL_REG, CLKDIV_IN_MASK,\r\nclk_id << CLKDIV_IN_SHIFT);\r\naic3x->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nu8 iface_areg, iface_breg;\r\nint delay = 0;\r\niface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;\r\niface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naic3x->master = 1;\r\niface_areg |= BIT_CLK_MASTER | WORD_CLK_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\naic3x->master = 0;\r\niface_areg &= ~(BIT_CLK_MASTER | WORD_CLK_MASTER);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\r\nSND_SOC_DAIFMT_INV_MASK)) {\r\ncase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\r\nbreak;\r\ncase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):\r\ndelay = 1;\r\ncase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):\r\niface_breg |= (0x01 << 6);\r\nbreak;\r\ncase (SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF):\r\niface_breg |= (0x02 << 6);\r\nbreak;\r\ncase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\r\niface_breg |= (0x03 << 6);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLA, iface_areg);\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLB, iface_breg);\r\nsnd_soc_write(codec, AIC3X_ASD_INTF_CTRLC, delay);\r\nreturn 0;\r\n}\r\nstatic int aic3x_init_3007(struct snd_soc_codec *codec)\r\n{\r\nu8 tmp1, tmp2, *cache = codec->reg_cache;\r\ntmp1 = cache[0xD];\r\ntmp2 = cache[0x8];\r\nsnd_soc_write(codec, AIC3X_PAGE_SELECT, 0x0D);\r\nsnd_soc_write(codec, 0xD, 0x0D);\r\nsnd_soc_write(codec, 0x8, 0x5C);\r\nsnd_soc_write(codec, 0x8, 0x5D);\r\nsnd_soc_write(codec, 0x8, 0x5C);\r\nsnd_soc_write(codec, AIC3X_PAGE_SELECT, 0x00);\r\ncache[0xD] = tmp1;\r\ncache[0x8] = tmp2;\r\nreturn 0;\r\n}\r\nstatic int aic3x_regulator_event(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct aic3x_disable_nb *disable_nb =\r\ncontainer_of(nb, struct aic3x_disable_nb, nb);\r\nstruct aic3x_priv *aic3x = disable_nb->aic3x;\r\nif (event & REGULATOR_EVENT_DISABLE) {\r\nif (gpio_is_valid(aic3x->gpio_reset))\r\ngpio_set_value(aic3x->gpio_reset, 0);\r\naic3x->codec->cache_sync = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic3x_set_power(struct snd_soc_codec *codec, int power)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint i, ret;\r\nu8 *cache = codec->reg_cache;\r\nif (power) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(aic3x->supplies),\r\naic3x->supplies);\r\nif (ret)\r\ngoto out;\r\naic3x->power = 1;\r\nif (!codec->cache_sync)\r\ngoto out;\r\nif (gpio_is_valid(aic3x->gpio_reset)) {\r\nudelay(1);\r\ngpio_set_value(aic3x->gpio_reset, 1);\r\n}\r\ncodec->cache_only = 0;\r\nfor (i = AIC3X_SAMPLE_RATE_SEL_REG; i < ARRAY_SIZE(aic3x_reg); i++)\r\nsnd_soc_write(codec, i, cache[i]);\r\nif (aic3x->model == AIC3X_MODEL_3007)\r\naic3x_init_3007(codec);\r\ncodec->cache_sync = 0;\r\n} else {\r\nsnd_soc_write(codec, AIC3X_RESET, SOFT_RESET);\r\ncodec->cache_sync = 1;\r\naic3x->power = 0;\r\ncodec->cache_only = 1;\r\nret = regulator_bulk_disable(ARRAY_SIZE(aic3x->supplies),\r\naic3x->supplies);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int aic3x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY &&\r\naic3x->master) {\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG,\r\nPLL_ENABLE, PLL_ENABLE);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (!aic3x->power)\r\naic3x_set_power(codec, 1);\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE &&\r\naic3x->master) {\r\nsnd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG,\r\nPLL_ENABLE, 0);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (aic3x->power)\r\naic3x_set_power(codec, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int aic3x_suspend(struct snd_soc_codec *codec)\r\n{\r\naic3x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int aic3x_resume(struct snd_soc_codec *codec)\r\n{\r\naic3x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int aic3x_init(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_write(codec, AIC3X_PAGE_SELECT, PAGE0_SELECT);\r\nsnd_soc_write(codec, AIC3X_RESET, SOFT_RESET);\r\nsnd_soc_write(codec, LDAC_VOL, DEFAULT_VOL | MUTE_ON);\r\nsnd_soc_write(codec, RDAC_VOL, DEFAULT_VOL | MUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_HPLOUT_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_HPROUT_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_HPLCOM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_HPRCOM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_LLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_RLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACL1_2_MONOLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_write(codec, DACR1_2_MONOLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\r\nsnd_soc_update_bits(codec, LLOPM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, RLOPM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, MONOLOPM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPLOUT_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPROUT_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPLCOM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_update_bits(codec, HPRCOM_CTRL, UNMUTE, UNMUTE);\r\nsnd_soc_write(codec, LADC_VOL, DEFAULT_GAIN);\r\nsnd_soc_write(codec, RADC_VOL, DEFAULT_GAIN);\r\nsnd_soc_write(codec, LINE1L_2_LADC_CTRL, 0x0);\r\nsnd_soc_write(codec, LINE1R_2_RADC_CTRL, 0x0);\r\nsnd_soc_write(codec, PGAL_2_HPLOUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_HPROUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAL_2_HPLCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_HPRCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAL_2_LLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_RLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAL_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, PGAR_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_HPLOUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_HPROUT_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_HPLCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_HPRCOM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_LLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_RLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2L_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nsnd_soc_write(codec, LINE2R_2_MONOLOPM_VOL, DEFAULT_VOL);\r\nif (aic3x->model == AIC3X_MODEL_3007) {\r\naic3x_init_3007(codec);\r\nsnd_soc_write(codec, CLASSD_CTRL, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool aic3x_is_shared_reset(struct aic3x_priv *aic3x)\r\n{\r\nstruct aic3x_priv *a;\r\nlist_for_each_entry(a, &reset_list, list) {\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\naic3x->gpio_reset == a->gpio_reset)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int aic3x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint ret, i;\r\nINIT_LIST_HEAD(&aic3x->list);\r\naic3x->codec = codec;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, aic3x->control_type);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\n!aic3x_is_shared_reset(aic3x)) {\r\nret = gpio_request(aic3x->gpio_reset, "tlv320aic3x reset");\r\nif (ret != 0)\r\ngoto err_gpio;\r\ngpio_direction_output(aic3x->gpio_reset, 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++)\r\naic3x->supplies[i].supply = aic3x_supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(aic3x->supplies),\r\naic3x->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request supplies: %d\n", ret);\r\ngoto err_get;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++) {\r\naic3x->disable_nb[i].nb.notifier_call = aic3x_regulator_event;\r\naic3x->disable_nb[i].aic3x = aic3x;\r\nret = regulator_register_notifier(aic3x->supplies[i].consumer,\r\n&aic3x->disable_nb[i].nb);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to request regulator notifier: %d\n",\r\nret);\r\ngoto err_notif;\r\n}\r\n}\r\ncodec->cache_only = 1;\r\naic3x_init(codec);\r\nif (aic3x->setup) {\r\nsnd_soc_write(codec, AIC3X_GPIO1_REG,\r\n(aic3x->setup->gpio_func[0] & 0xf) << 4);\r\nsnd_soc_write(codec, AIC3X_GPIO2_REG,\r\n(aic3x->setup->gpio_func[1] & 0xf) << 4);\r\n}\r\nsnd_soc_add_codec_controls(codec, aic3x_snd_controls,\r\nARRAY_SIZE(aic3x_snd_controls));\r\nif (aic3x->model == AIC3X_MODEL_3007)\r\nsnd_soc_add_codec_controls(codec, &aic3x_classd_amp_gain_ctrl, 1);\r\naic3x_add_widgets(codec);\r\nlist_add(&aic3x->list, &reset_list);\r\nreturn 0;\r\nerr_notif:\r\nwhile (i--)\r\nregulator_unregister_notifier(aic3x->supplies[i].consumer,\r\n&aic3x->disable_nb[i].nb);\r\nregulator_bulk_free(ARRAY_SIZE(aic3x->supplies), aic3x->supplies);\r\nerr_get:\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\n!aic3x_is_shared_reset(aic3x))\r\ngpio_free(aic3x->gpio_reset);\r\nerr_gpio:\r\nreturn ret;\r\n}\r\nstatic int aic3x_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\naic3x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nlist_del(&aic3x->list);\r\nif (gpio_is_valid(aic3x->gpio_reset) &&\r\n!aic3x_is_shared_reset(aic3x)) {\r\ngpio_set_value(aic3x->gpio_reset, 0);\r\ngpio_free(aic3x->gpio_reset);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++)\r\nregulator_unregister_notifier(aic3x->supplies[i].consumer,\r\n&aic3x->disable_nb[i].nb);\r\nregulator_bulk_free(ARRAY_SIZE(aic3x->supplies), aic3x->supplies);\r\nreturn 0;\r\n}\r\nstatic int aic3x_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct aic3x_pdata *pdata = i2c->dev.platform_data;\r\nstruct aic3x_priv *aic3x;\r\nstruct aic3x_setup_data *ai3x_setup;\r\nstruct device_node *np = i2c->dev.of_node;\r\nint ret;\r\naic3x = devm_kzalloc(&i2c->dev, sizeof(struct aic3x_priv), GFP_KERNEL);\r\nif (aic3x == NULL) {\r\ndev_err(&i2c->dev, "failed to create private data\n");\r\nreturn -ENOMEM;\r\n}\r\naic3x->control_type = SND_SOC_I2C;\r\ni2c_set_clientdata(i2c, aic3x);\r\nif (pdata) {\r\naic3x->gpio_reset = pdata->gpio_reset;\r\naic3x->setup = pdata->setup;\r\n} else if (np) {\r\nai3x_setup = devm_kzalloc(&i2c->dev, sizeof(*ai3x_setup),\r\nGFP_KERNEL);\r\nif (ai3x_setup == NULL) {\r\ndev_err(&i2c->dev, "failed to create private data\n");\r\nreturn -ENOMEM;\r\n}\r\nret = of_get_named_gpio(np, "gpio-reset", 0);\r\nif (ret >= 0)\r\naic3x->gpio_reset = ret;\r\nelse\r\naic3x->gpio_reset = -1;\r\nif (of_property_read_u32_array(np, "ai3x-gpio-func",\r\nai3x_setup->gpio_func, 2) >= 0) {\r\naic3x->setup = ai3x_setup;\r\n}\r\n} else {\r\naic3x->gpio_reset = -1;\r\n}\r\naic3x->model = id->driver_data;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_aic3x, &aic3x_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int aic3x_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
