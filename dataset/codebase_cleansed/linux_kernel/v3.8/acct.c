static int check_free_space(struct bsd_acct_struct *acct, struct file *file)\r\n{\r\nstruct kstatfs sbuf;\r\nint res;\r\nint act;\r\nu64 resume;\r\nu64 suspend;\r\nspin_lock(&acct_lock);\r\nres = acct->active;\r\nif (!file || time_is_before_jiffies(acct->needcheck))\r\ngoto out;\r\nspin_unlock(&acct_lock);\r\nif (vfs_statfs(&file->f_path, &sbuf))\r\nreturn res;\r\nsuspend = sbuf.f_blocks * SUSPEND;\r\nresume = sbuf.f_blocks * RESUME;\r\ndo_div(suspend, 100);\r\ndo_div(resume, 100);\r\nif (sbuf.f_bavail <= suspend)\r\nact = -1;\r\nelse if (sbuf.f_bavail >= resume)\r\nact = 1;\r\nelse\r\nact = 0;\r\nspin_lock(&acct_lock);\r\nif (file != acct->file) {\r\nif (act)\r\nres = act>0;\r\ngoto out;\r\n}\r\nif (acct->active) {\r\nif (act < 0) {\r\nacct->active = 0;\r\nprintk(KERN_INFO "Process accounting paused\n");\r\n}\r\n} else {\r\nif (act > 0) {\r\nacct->active = 1;\r\nprintk(KERN_INFO "Process accounting resumed\n");\r\n}\r\n}\r\nacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\r\nres = acct->active;\r\nout:\r\nspin_unlock(&acct_lock);\r\nreturn res;\r\n}\r\nstatic void acct_file_reopen(struct bsd_acct_struct *acct, struct file *file,\r\nstruct pid_namespace *ns)\r\n{\r\nstruct file *old_acct = NULL;\r\nstruct pid_namespace *old_ns = NULL;\r\nif (acct->file) {\r\nold_acct = acct->file;\r\nold_ns = acct->ns;\r\nacct->active = 0;\r\nacct->file = NULL;\r\nacct->ns = NULL;\r\nlist_del(&acct->list);\r\n}\r\nif (file) {\r\nacct->file = file;\r\nacct->ns = ns;\r\nacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\r\nacct->active = 1;\r\nlist_add(&acct->list, &acct_list);\r\n}\r\nif (old_acct) {\r\nmnt_unpin(old_acct->f_path.mnt);\r\nspin_unlock(&acct_lock);\r\ndo_acct_process(acct, old_ns, old_acct);\r\nfilp_close(old_acct, NULL);\r\nspin_lock(&acct_lock);\r\n}\r\n}\r\nstatic int acct_on(struct filename *pathname)\r\n{\r\nstruct file *file;\r\nstruct vfsmount *mnt;\r\nstruct pid_namespace *ns;\r\nstruct bsd_acct_struct *acct = NULL;\r\nfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);\r\nif (IS_ERR(file))\r\nreturn PTR_ERR(file);\r\nif (!S_ISREG(file->f_path.dentry->d_inode->i_mode)) {\r\nfilp_close(file, NULL);\r\nreturn -EACCES;\r\n}\r\nif (!file->f_op->write) {\r\nfilp_close(file, NULL);\r\nreturn -EIO;\r\n}\r\nns = task_active_pid_ns(current);\r\nif (ns->bacct == NULL) {\r\nacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);\r\nif (acct == NULL) {\r\nfilp_close(file, NULL);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock(&acct_lock);\r\nif (ns->bacct == NULL) {\r\nns->bacct = acct;\r\nacct = NULL;\r\n}\r\nmnt = file->f_path.mnt;\r\nmnt_pin(mnt);\r\nacct_file_reopen(ns->bacct, file, ns);\r\nspin_unlock(&acct_lock);\r\nmntput(mnt);\r\nkfree(acct);\r\nreturn 0;\r\n}\r\nvoid acct_auto_close_mnt(struct vfsmount *m)\r\n{\r\nstruct bsd_acct_struct *acct;\r\nspin_lock(&acct_lock);\r\nrestart:\r\nlist_for_each_entry(acct, &acct_list, list)\r\nif (acct->file && acct->file->f_path.mnt == m) {\r\nacct_file_reopen(acct, NULL, NULL);\r\ngoto restart;\r\n}\r\nspin_unlock(&acct_lock);\r\n}\r\nvoid acct_auto_close(struct super_block *sb)\r\n{\r\nstruct bsd_acct_struct *acct;\r\nspin_lock(&acct_lock);\r\nrestart:\r\nlist_for_each_entry(acct, &acct_list, list)\r\nif (acct->file && acct->file->f_path.dentry->d_sb == sb) {\r\nacct_file_reopen(acct, NULL, NULL);\r\ngoto restart;\r\n}\r\nspin_unlock(&acct_lock);\r\n}\r\nvoid acct_exit_ns(struct pid_namespace *ns)\r\n{\r\nstruct bsd_acct_struct *acct = ns->bacct;\r\nif (acct == NULL)\r\nreturn;\r\nspin_lock(&acct_lock);\r\nif (acct->file != NULL)\r\nacct_file_reopen(acct, NULL, NULL);\r\nspin_unlock(&acct_lock);\r\nkfree(acct);\r\n}\r\nstatic comp_t encode_comp_t(unsigned long value)\r\n{\r\nint exp, rnd;\r\nexp = rnd = 0;\r\nwhile (value > MAXFRACT) {\r\nrnd = value & (1 << (EXPSIZE - 1));\r\nvalue >>= EXPSIZE;\r\nexp++;\r\n}\r\nif (rnd && (++value > MAXFRACT)) {\r\nvalue >>= EXPSIZE;\r\nexp++;\r\n}\r\nexp <<= MANTSIZE;\r\nexp += value;\r\nreturn exp;\r\n}\r\nstatic comp2_t encode_comp2_t(u64 value)\r\n{\r\nint exp, rnd;\r\nexp = (value > (MAXFRACT2>>1));\r\nrnd = 0;\r\nwhile (value > MAXFRACT2) {\r\nrnd = value & 1;\r\nvalue >>= 1;\r\nexp++;\r\n}\r\nif (rnd && (++value > MAXFRACT2)) {\r\nvalue >>= 1;\r\nexp++;\r\n}\r\nif (exp > MAXEXP2) {\r\nreturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\r\n} else {\r\nreturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\r\n}\r\n}\r\nstatic u32 encode_float(u64 value)\r\n{\r\nunsigned exp = 190;\r\nunsigned u;\r\nif (value==0) return 0;\r\nwhile ((s64)value > 0){\r\nvalue <<= 1;\r\nexp--;\r\n}\r\nu = (u32)(value >> 40) & 0x7fffffu;\r\nreturn u | (exp << 23);\r\n}\r\nstatic void do_acct_process(struct bsd_acct_struct *acct,\r\nstruct pid_namespace *ns, struct file *file)\r\n{\r\nstruct pacct_struct *pacct = &current->signal->pacct;\r\nacct_t ac;\r\nmm_segment_t fs;\r\nunsigned long flim;\r\nu64 elapsed;\r\nu64 run_time;\r\nstruct timespec uptime;\r\nstruct tty_struct *tty;\r\nconst struct cred *orig_cred;\r\norig_cred = override_creds(file->f_cred);\r\nif (!check_free_space(acct, file))\r\ngoto out;\r\nmemset(&ac, 0, sizeof(acct_t));\r\nac.ac_version = ACCT_VERSION | ACCT_BYTEORDER;\r\nstrlcpy(ac.ac_comm, current->comm, sizeof(ac.ac_comm));\r\ndo_posix_clock_monotonic_gettime(&uptime);\r\nrun_time = (u64)uptime.tv_sec*NSEC_PER_SEC + uptime.tv_nsec;\r\nrun_time -= (u64)current->group_leader->start_time.tv_sec * NSEC_PER_SEC\r\n+ current->group_leader->start_time.tv_nsec;\r\nelapsed = nsec_to_AHZ(run_time);\r\n#if ACCT_VERSION==3\r\nac.ac_etime = encode_float(elapsed);\r\n#else\r\nac.ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\r\n(unsigned long) elapsed : (unsigned long) -1l);\r\n#endif\r\n#if ACCT_VERSION==1 || ACCT_VERSION==2\r\n{\r\ncomp2_t etime = encode_comp2_t(elapsed);\r\nac.ac_etime_hi = etime >> 16;\r\nac.ac_etime_lo = (u16) etime;\r\n}\r\n#endif\r\ndo_div(elapsed, AHZ);\r\nac.ac_btime = get_seconds() - elapsed;\r\nac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\r\nac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\r\n#if ACCT_VERSION==2\r\nac.ac_ahz = AHZ;\r\n#endif\r\n#if ACCT_VERSION==1 || ACCT_VERSION==2\r\nac.ac_uid16 = ac.ac_uid;\r\nac.ac_gid16 = ac.ac_gid;\r\n#endif\r\n#if ACCT_VERSION==3\r\nac.ac_pid = task_tgid_nr_ns(current, ns);\r\nrcu_read_lock();\r\nac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent), ns);\r\nrcu_read_unlock();\r\n#endif\r\nspin_lock_irq(&current->sighand->siglock);\r\ntty = current->signal->tty;\r\nac.ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\r\nac.ac_utime = encode_comp_t(jiffies_to_AHZ(cputime_to_jiffies(pacct->ac_utime)));\r\nac.ac_stime = encode_comp_t(jiffies_to_AHZ(cputime_to_jiffies(pacct->ac_stime)));\r\nac.ac_flag = pacct->ac_flag;\r\nac.ac_mem = encode_comp_t(pacct->ac_mem);\r\nac.ac_minflt = encode_comp_t(pacct->ac_minflt);\r\nac.ac_majflt = encode_comp_t(pacct->ac_majflt);\r\nac.ac_exitcode = pacct->ac_exitcode;\r\nspin_unlock_irq(&current->sighand->siglock);\r\nac.ac_io = encode_comp_t(0 );\r\nac.ac_rw = encode_comp_t(ac.ac_io / 1024);\r\nac.ac_swaps = encode_comp_t(0);\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\r\ncurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\r\nfile->f_op->write(file, (char *)&ac,\r\nsizeof(acct_t), &file->f_pos);\r\ncurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\r\nset_fs(fs);\r\nout:\r\nrevert_creds(orig_cred);\r\n}\r\nvoid acct_collect(long exitcode, int group_dead)\r\n{\r\nstruct pacct_struct *pacct = &current->signal->pacct;\r\nunsigned long vsize = 0;\r\nif (group_dead && current->mm) {\r\nstruct vm_area_struct *vma;\r\ndown_read(&current->mm->mmap_sem);\r\nvma = current->mm->mmap;\r\nwhile (vma) {\r\nvsize += vma->vm_end - vma->vm_start;\r\nvma = vma->vm_next;\r\n}\r\nup_read(&current->mm->mmap_sem);\r\n}\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (group_dead)\r\npacct->ac_mem = vsize / 1024;\r\nif (thread_group_leader(current)) {\r\npacct->ac_exitcode = exitcode;\r\nif (current->flags & PF_FORKNOEXEC)\r\npacct->ac_flag |= AFORK;\r\n}\r\nif (current->flags & PF_SUPERPRIV)\r\npacct->ac_flag |= ASU;\r\nif (current->flags & PF_DUMPCORE)\r\npacct->ac_flag |= ACORE;\r\nif (current->flags & PF_SIGNALED)\r\npacct->ac_flag |= AXSIG;\r\npacct->ac_utime += current->utime;\r\npacct->ac_stime += current->stime;\r\npacct->ac_minflt += current->min_flt;\r\npacct->ac_majflt += current->maj_flt;\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nstatic void acct_process_in_ns(struct pid_namespace *ns)\r\n{\r\nstruct file *file = NULL;\r\nstruct bsd_acct_struct *acct;\r\nacct = ns->bacct;\r\nif (!acct || !acct->file)\r\nreturn;\r\nspin_lock(&acct_lock);\r\nfile = acct->file;\r\nif (unlikely(!file)) {\r\nspin_unlock(&acct_lock);\r\nreturn;\r\n}\r\nget_file(file);\r\nspin_unlock(&acct_lock);\r\ndo_acct_process(acct, ns, file);\r\nfput(file);\r\n}\r\nvoid acct_process(void)\r\n{\r\nstruct pid_namespace *ns;\r\nfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent)\r\nacct_process_in_ns(ns);\r\n}
