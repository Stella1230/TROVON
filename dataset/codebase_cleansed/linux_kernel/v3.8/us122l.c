static int us122l_create_usbmidi(struct snd_card *card)\r\n{\r\nstatic struct snd_usb_midi_endpoint_info quirk_data = {\r\n.out_ep = 4,\r\n.in_ep = 3,\r\n.out_cables = 0x001,\r\n.in_cables = 0x001\r\n};\r\nstatic struct snd_usb_audio_quirk quirk = {\r\n.vendor_name = "US122L",\r\n.product_name = NAME_ALLCAPS,\r\n.ifnum = 1,\r\n.type = QUIRK_MIDI_US122L,\r\n.data = &quirk_data\r\n};\r\nstruct usb_device *dev = US122L(card)->dev;\r\nstruct usb_interface *iface = usb_ifnum_to_if(dev, 1);\r\nreturn snd_usbmidi_create(card, iface,\r\n&US122L(card)->midi_list, &quirk);\r\n}\r\nstatic int us144_create_usbmidi(struct snd_card *card)\r\n{\r\nstatic struct snd_usb_midi_endpoint_info quirk_data = {\r\n.out_ep = 4,\r\n.in_ep = 3,\r\n.out_cables = 0x001,\r\n.in_cables = 0x001\r\n};\r\nstatic struct snd_usb_audio_quirk quirk = {\r\n.vendor_name = "US144",\r\n.product_name = NAME_ALLCAPS,\r\n.ifnum = 0,\r\n.type = QUIRK_MIDI_US122L,\r\n.data = &quirk_data\r\n};\r\nstruct usb_device *dev = US122L(card)->dev;\r\nstruct usb_interface *iface = usb_ifnum_to_if(dev, 0);\r\nreturn snd_usbmidi_create(card, iface,\r\n&US122L(card)->midi_list, &quirk);\r\n}\r\nstatic int us122l_ctl_msg(struct usb_device *dev, unsigned int pipe,\r\n__u8 request, __u8 requesttype,\r\n__u16 value, __u16 index, void *data,\r\n__u16 size, int timeout)\r\n{\r\nint err;\r\nvoid *buf = NULL;\r\nif (size > 0) {\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\n}\r\nerr = usb_control_msg(dev, pipe, request, requesttype,\r\nvalue, index, buf, size, timeout);\r\nif (size > 0) {\r\nmemcpy(data, buf, size);\r\nkfree(buf);\r\n}\r\nreturn err;\r\n}\r\nstatic void pt_info_set(struct usb_device *dev, u8 v)\r\n{\r\nint ret;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n'I',\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nv, 0, NULL, 0, 1000);\r\nsnd_printdd(KERN_DEBUG "%i\n", ret);\r\n}\r\nstatic void usb_stream_hwdep_vm_open(struct vm_area_struct *area)\r\n{\r\nstruct us122l *us122l = area->vm_private_data;\r\natomic_inc(&us122l->mmap_count);\r\nsnd_printdd(KERN_DEBUG "%i\n", atomic_read(&us122l->mmap_count));\r\n}\r\nstatic int usb_stream_hwdep_vm_fault(struct vm_area_struct *area,\r\nstruct vm_fault *vmf)\r\n{\r\nunsigned long offset;\r\nstruct page *page;\r\nvoid *vaddr;\r\nstruct us122l *us122l = area->vm_private_data;\r\nstruct usb_stream *s;\r\nmutex_lock(&us122l->mutex);\r\ns = us122l->sk.s;\r\nif (!s)\r\ngoto unlock;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nif (offset < PAGE_ALIGN(s->read_size))\r\nvaddr = (char *)s + offset;\r\nelse {\r\noffset -= PAGE_ALIGN(s->read_size);\r\nif (offset >= PAGE_ALIGN(s->write_size))\r\ngoto unlock;\r\nvaddr = us122l->sk.write_page + offset;\r\n}\r\npage = virt_to_page(vaddr);\r\nget_page(page);\r\nmutex_unlock(&us122l->mutex);\r\nvmf->page = page;\r\nreturn 0;\r\nunlock:\r\nmutex_unlock(&us122l->mutex);\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nstatic void usb_stream_hwdep_vm_close(struct vm_area_struct *area)\r\n{\r\nstruct us122l *us122l = area->vm_private_data;\r\natomic_dec(&us122l->mmap_count);\r\nsnd_printdd(KERN_DEBUG "%i\n", atomic_read(&us122l->mmap_count));\r\n}\r\nstatic int usb_stream_hwdep_open(struct snd_hwdep *hw, struct file *file)\r\n{\r\nstruct us122l *us122l = hw->private_data;\r\nstruct usb_interface *iface;\r\nsnd_printdd(KERN_DEBUG "%p %p\n", hw, file);\r\nif (hw->used >= 2)\r\nreturn -EBUSY;\r\nif (!us122l->first)\r\nus122l->first = file;\r\nif (us122l->dev->descriptor.idProduct == USB_ID_US144 ||\r\nus122l->dev->descriptor.idProduct == USB_ID_US144MKII) {\r\niface = usb_ifnum_to_if(us122l->dev, 0);\r\nusb_autopm_get_interface(iface);\r\n}\r\niface = usb_ifnum_to_if(us122l->dev, 1);\r\nusb_autopm_get_interface(iface);\r\nreturn 0;\r\n}\r\nstatic int usb_stream_hwdep_release(struct snd_hwdep *hw, struct file *file)\r\n{\r\nstruct us122l *us122l = hw->private_data;\r\nstruct usb_interface *iface;\r\nsnd_printdd(KERN_DEBUG "%p %p\n", hw, file);\r\nif (us122l->dev->descriptor.idProduct == USB_ID_US144 ||\r\nus122l->dev->descriptor.idProduct == USB_ID_US144MKII) {\r\niface = usb_ifnum_to_if(us122l->dev, 0);\r\nusb_autopm_put_interface(iface);\r\n}\r\niface = usb_ifnum_to_if(us122l->dev, 1);\r\nusb_autopm_put_interface(iface);\r\nif (us122l->first == file)\r\nus122l->first = NULL;\r\nmutex_lock(&us122l->mutex);\r\nif (us122l->master == file)\r\nus122l->master = us122l->slave;\r\nus122l->slave = NULL;\r\nmutex_unlock(&us122l->mutex);\r\nreturn 0;\r\n}\r\nstatic int usb_stream_hwdep_mmap(struct snd_hwdep *hw,\r\nstruct file *filp, struct vm_area_struct *area)\r\n{\r\nunsigned long size = area->vm_end - area->vm_start;\r\nstruct us122l *us122l = hw->private_data;\r\nunsigned long offset;\r\nstruct usb_stream *s;\r\nint err = 0;\r\nbool read;\r\noffset = area->vm_pgoff << PAGE_SHIFT;\r\nmutex_lock(&us122l->mutex);\r\ns = us122l->sk.s;\r\nread = offset < s->read_size;\r\nif (read && area->vm_flags & VM_WRITE) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nsnd_printdd(KERN_DEBUG "%lu %u\n", size,\r\nread ? s->read_size : s->write_size);\r\nif (size > PAGE_ALIGN(read ? s->read_size : s->write_size)) {\r\nsnd_printk(KERN_WARNING "%lu > %u\n", size,\r\nread ? s->read_size : s->write_size);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\narea->vm_ops = &usb_stream_hwdep_vm_ops;\r\narea->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\narea->vm_private_data = us122l;\r\natomic_inc(&us122l->mmap_count);\r\nout:\r\nmutex_unlock(&us122l->mutex);\r\nreturn err;\r\n}\r\nstatic unsigned int usb_stream_hwdep_poll(struct snd_hwdep *hw,\r\nstruct file *file, poll_table *wait)\r\n{\r\nstruct us122l *us122l = hw->private_data;\r\nunsigned *polled;\r\nunsigned int mask;\r\npoll_wait(file, &us122l->sk.sleep, wait);\r\nmask = POLLIN | POLLOUT | POLLWRNORM | POLLERR;\r\nif (mutex_trylock(&us122l->mutex)) {\r\nstruct usb_stream *s = us122l->sk.s;\r\nif (s && s->state == usb_stream_ready) {\r\nif (us122l->first == file)\r\npolled = &s->periods_polled;\r\nelse\r\npolled = &us122l->second_periods_polled;\r\nif (*polled != s->periods_done) {\r\n*polled = s->periods_done;\r\nmask = POLLIN | POLLOUT | POLLWRNORM;\r\n} else\r\nmask = 0;\r\n}\r\nmutex_unlock(&us122l->mutex);\r\n}\r\nreturn mask;\r\n}\r\nstatic void us122l_stop(struct us122l *us122l)\r\n{\r\nstruct list_head *p;\r\nlist_for_each(p, &us122l->midi_list)\r\nsnd_usbmidi_input_stop(p);\r\nusb_stream_stop(&us122l->sk);\r\nusb_stream_free(&us122l->sk);\r\n}\r\nstatic int us122l_set_sample_rate(struct usb_device *dev, int rate)\r\n{\r\nunsigned int ep = 0x81;\r\nunsigned char data[3];\r\nint err;\r\ndata[0] = rate;\r\ndata[1] = rate >> 8;\r\ndata[2] = rate >> 16;\r\nerr = us122l_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,\r\nUSB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_OUT,\r\nUAC_EP_CS_ATTR_SAMPLE_RATE << 8, ep, data, 3, 1000);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "%d: cannot set freq %d to ep 0x%x\n",\r\ndev->devnum, rate, ep);\r\nreturn err;\r\n}\r\nstatic bool us122l_start(struct us122l *us122l,\r\nunsigned rate, unsigned period_frames)\r\n{\r\nstruct list_head *p;\r\nint err;\r\nunsigned use_packsize = 0;\r\nbool success = false;\r\nif (us122l->dev->speed == USB_SPEED_HIGH) {\r\nswitch (rate) {\r\ncase 44100:\r\nuse_packsize = 36;\r\nbreak;\r\ncase 48000:\r\nuse_packsize = 42;\r\nbreak;\r\ncase 88200:\r\nuse_packsize = 72;\r\nbreak;\r\n}\r\n}\r\nif (!usb_stream_new(&us122l->sk, us122l->dev, 1, 2,\r\nrate, use_packsize, period_frames, 6))\r\ngoto out;\r\nerr = us122l_set_sample_rate(us122l->dev, rate);\r\nif (err < 0) {\r\nus122l_stop(us122l);\r\nsnd_printk(KERN_ERR "us122l_set_sample_rate error \n");\r\ngoto out;\r\n}\r\nerr = usb_stream_start(&us122l->sk);\r\nif (err < 0) {\r\nus122l_stop(us122l);\r\nsnd_printk(KERN_ERR "us122l_start error %i \n", err);\r\ngoto out;\r\n}\r\nlist_for_each(p, &us122l->midi_list)\r\nsnd_usbmidi_input_start(p);\r\nsuccess = true;\r\nout:\r\nreturn success;\r\n}\r\nstatic int usb_stream_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nstruct usb_stream_config *cfg;\r\nstruct us122l *us122l = hw->private_data;\r\nstruct usb_stream *s;\r\nunsigned min_period_frames;\r\nint err = 0;\r\nbool high_speed;\r\nif (cmd != SNDRV_USB_STREAM_IOCTL_SET_PARAMS)\r\nreturn -ENOTTY;\r\ncfg = memdup_user((void *)arg, sizeof(*cfg));\r\nif (IS_ERR(cfg))\r\nreturn PTR_ERR(cfg);\r\nif (cfg->version != USB_STREAM_INTERFACE_VERSION) {\r\nerr = -ENXIO;\r\ngoto free;\r\n}\r\nhigh_speed = us122l->dev->speed == USB_SPEED_HIGH;\r\nif ((cfg->sample_rate != 44100 && cfg->sample_rate != 48000 &&\r\n(!high_speed ||\r\n(cfg->sample_rate != 88200 && cfg->sample_rate != 96000))) ||\r\ncfg->frame_size != 6 ||\r\ncfg->period_frames > 0x3000) {\r\nerr = -EINVAL;\r\ngoto free;\r\n}\r\nswitch (cfg->sample_rate) {\r\ncase 44100:\r\nmin_period_frames = 48;\r\nbreak;\r\ncase 48000:\r\nmin_period_frames = 52;\r\nbreak;\r\ndefault:\r\nmin_period_frames = 104;\r\nbreak;\r\n}\r\nif (!high_speed)\r\nmin_period_frames <<= 1;\r\nif (cfg->period_frames < min_period_frames) {\r\nerr = -EINVAL;\r\ngoto free;\r\n}\r\nsnd_power_wait(hw->card, SNDRV_CTL_POWER_D0);\r\nmutex_lock(&us122l->mutex);\r\ns = us122l->sk.s;\r\nif (!us122l->master)\r\nus122l->master = file;\r\nelse if (us122l->master != file) {\r\nif (!s || memcmp(cfg, &s->cfg, sizeof(*cfg))) {\r\nerr = -EIO;\r\ngoto unlock;\r\n}\r\nus122l->slave = file;\r\n}\r\nif (!s || memcmp(cfg, &s->cfg, sizeof(*cfg)) ||\r\ns->state == usb_stream_xrun) {\r\nus122l_stop(us122l);\r\nif (!us122l_start(us122l, cfg->sample_rate, cfg->period_frames))\r\nerr = -EIO;\r\nelse\r\nerr = 1;\r\n}\r\nunlock:\r\nmutex_unlock(&us122l->mutex);\r\nfree:\r\nkfree(cfg);\r\nwake_up_all(&us122l->sk.sleep);\r\nreturn err;\r\n}\r\nstatic int usb_stream_hwdep_new(struct snd_card *card)\r\n{\r\nint err;\r\nstruct snd_hwdep *hw;\r\nstruct usb_device *dev = US122L(card)->dev;\r\nerr = snd_hwdep_new(card, SND_USB_STREAM_ID, 0, &hw);\r\nif (err < 0)\r\nreturn err;\r\nhw->iface = SNDRV_HWDEP_IFACE_USB_STREAM;\r\nhw->private_data = US122L(card);\r\nhw->ops.open = usb_stream_hwdep_open;\r\nhw->ops.release = usb_stream_hwdep_release;\r\nhw->ops.ioctl = usb_stream_hwdep_ioctl;\r\nhw->ops.ioctl_compat = usb_stream_hwdep_ioctl;\r\nhw->ops.mmap = usb_stream_hwdep_mmap;\r\nhw->ops.poll = usb_stream_hwdep_poll;\r\nsprintf(hw->name, "/proc/bus/usb/%03d/%03d/hwdeppcm",\r\ndev->bus->busnum, dev->devnum);\r\nreturn 0;\r\n}\r\nstatic bool us122l_create_card(struct snd_card *card)\r\n{\r\nint err;\r\nstruct us122l *us122l = US122L(card);\r\nif (us122l->dev->descriptor.idProduct == USB_ID_US144 ||\r\nus122l->dev->descriptor.idProduct == USB_ID_US144MKII) {\r\nerr = usb_set_interface(us122l->dev, 0, 1);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usb_set_interface error \n");\r\nreturn false;\r\n}\r\n}\r\nerr = usb_set_interface(us122l->dev, 1, 1);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usb_set_interface error \n");\r\nreturn false;\r\n}\r\npt_info_set(us122l->dev, 0x11);\r\npt_info_set(us122l->dev, 0x10);\r\nif (!us122l_start(us122l, 44100, 256))\r\nreturn false;\r\nif (us122l->dev->descriptor.idProduct == USB_ID_US144 ||\r\nus122l->dev->descriptor.idProduct == USB_ID_US144MKII)\r\nerr = us144_create_usbmidi(card);\r\nelse\r\nerr = us122l_create_usbmidi(card);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "us122l_create_usbmidi error %i \n", err);\r\nus122l_stop(us122l);\r\nreturn false;\r\n}\r\nerr = usb_stream_hwdep_new(card);\r\nif (err < 0) {\r\nstruct list_head *p;\r\nlist_for_each(p, &us122l->midi_list)\r\nsnd_usbmidi_disconnect(p);\r\nus122l_stop(us122l);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void snd_us122l_free(struct snd_card *card)\r\n{\r\nstruct us122l *us122l = US122L(card);\r\nint index = us122l->card_index;\r\nif (index >= 0 && index < SNDRV_CARDS)\r\nsnd_us122l_card_used[index] = 0;\r\n}\r\nstatic int usx2y_create_card(struct usb_device *device, struct snd_card **cardp)\r\n{\r\nint dev;\r\nstruct snd_card *card;\r\nint err;\r\nfor (dev = 0; dev < SNDRV_CARDS; ++dev)\r\nif (enable[dev] && !snd_us122l_card_used[dev])\r\nbreak;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct us122l), &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_us122l_card_used[US122L(card)->card_index = dev] = 1;\r\ncard->private_free = snd_us122l_free;\r\nUS122L(card)->dev = device;\r\nmutex_init(&US122L(card)->mutex);\r\ninit_waitqueue_head(&US122L(card)->sk.sleep);\r\nINIT_LIST_HEAD(&US122L(card)->midi_list);\r\nstrcpy(card->driver, "USB "NAME_ALLCAPS"");\r\nsprintf(card->shortname, "TASCAM "NAME_ALLCAPS"");\r\nsprintf(card->longname, "%s (%x:%x if %d at %03d/%03d)",\r\ncard->shortname,\r\nle16_to_cpu(device->descriptor.idVendor),\r\nle16_to_cpu(device->descriptor.idProduct),\r\n0,\r\nUS122L(card)->dev->bus->busnum,\r\nUS122L(card)->dev->devnum\r\n);\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int us122l_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *device_id,\r\nstruct snd_card **cardp)\r\n{\r\nstruct usb_device *device = interface_to_usbdev(intf);\r\nstruct snd_card *card;\r\nint err;\r\nerr = usx2y_create_card(device, &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, &intf->dev);\r\nif (!us122l_create_card(card)) {\r\nsnd_card_free(card);\r\nreturn -EINVAL;\r\n}\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nusb_get_intf(usb_ifnum_to_if(device, 0));\r\nusb_get_dev(device);\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int snd_us122l_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *device = interface_to_usbdev(intf);\r\nstruct snd_card *card;\r\nint err;\r\nif ((device->descriptor.idProduct == USB_ID_US144 ||\r\ndevice->descriptor.idProduct == USB_ID_US144MKII)\r\n&& device->speed == USB_SPEED_HIGH) {\r\nsnd_printk(KERN_ERR "disable ehci-hcd to run US-144 \n");\r\nreturn -ENODEV;\r\n}\r\nsnd_printdd(KERN_DEBUG"%p:%i\n",\r\nintf, intf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 1)\r\nreturn 0;\r\nerr = us122l_usb_probe(usb_get_intf(intf), id, &card);\r\nif (err < 0) {\r\nusb_put_intf(intf);\r\nreturn err;\r\n}\r\nusb_set_intfdata(intf, card);\r\nreturn 0;\r\n}\r\nstatic void snd_us122l_disconnect(struct usb_interface *intf)\r\n{\r\nstruct snd_card *card;\r\nstruct us122l *us122l;\r\nstruct list_head *p;\r\ncard = usb_get_intfdata(intf);\r\nif (!card)\r\nreturn;\r\nsnd_card_disconnect(card);\r\nus122l = US122L(card);\r\nmutex_lock(&us122l->mutex);\r\nus122l_stop(us122l);\r\nmutex_unlock(&us122l->mutex);\r\nlist_for_each(p, &us122l->midi_list) {\r\nsnd_usbmidi_disconnect(p);\r\n}\r\nusb_put_intf(usb_ifnum_to_if(us122l->dev, 0));\r\nusb_put_intf(usb_ifnum_to_if(us122l->dev, 1));\r\nusb_put_dev(us122l->dev);\r\nwhile (atomic_read(&us122l->mmap_count))\r\nmsleep(500);\r\nsnd_card_free(card);\r\n}\r\nstatic int snd_us122l_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct snd_card *card;\r\nstruct us122l *us122l;\r\nstruct list_head *p;\r\ncard = usb_get_intfdata(intf);\r\nif (!card)\r\nreturn 0;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nus122l = US122L(card);\r\nif (!us122l)\r\nreturn 0;\r\nlist_for_each(p, &us122l->midi_list)\r\nsnd_usbmidi_input_stop(p);\r\nmutex_lock(&us122l->mutex);\r\nusb_stream_stop(&us122l->sk);\r\nmutex_unlock(&us122l->mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_us122l_resume(struct usb_interface *intf)\r\n{\r\nstruct snd_card *card;\r\nstruct us122l *us122l;\r\nstruct list_head *p;\r\nint err;\r\ncard = usb_get_intfdata(intf);\r\nif (!card)\r\nreturn 0;\r\nus122l = US122L(card);\r\nif (!us122l)\r\nreturn 0;\r\nmutex_lock(&us122l->mutex);\r\nif (us122l->dev->descriptor.idProduct == USB_ID_US144 ||\r\nus122l->dev->descriptor.idProduct == USB_ID_US144MKII) {\r\nerr = usb_set_interface(us122l->dev, 0, 1);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usb_set_interface error \n");\r\ngoto unlock;\r\n}\r\n}\r\nerr = usb_set_interface(us122l->dev, 1, 1);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usb_set_interface error \n");\r\ngoto unlock;\r\n}\r\npt_info_set(us122l->dev, 0x11);\r\npt_info_set(us122l->dev, 0x10);\r\nerr = us122l_set_sample_rate(us122l->dev,\r\nus122l->sk.s->cfg.sample_rate);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "us122l_set_sample_rate error \n");\r\ngoto unlock;\r\n}\r\nerr = usb_stream_start(&us122l->sk);\r\nif (err)\r\ngoto unlock;\r\nlist_for_each(p, &us122l->midi_list)\r\nsnd_usbmidi_input_start(p);\r\nunlock:\r\nmutex_unlock(&us122l->mutex);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn err;\r\n}
