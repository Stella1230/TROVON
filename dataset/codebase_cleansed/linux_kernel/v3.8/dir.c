static int\r\nadfs_readdir(struct file *filp, void *dirent, filldir_t filldir)\r\n{\r\nstruct inode *inode = filp->f_path.dentry->d_inode;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\r\nstruct object_info obj;\r\nstruct adfs_dir dir;\r\nint ret = 0;\r\nif (filp->f_pos >> 32)\r\ngoto out;\r\nret = ops->read(sb, inode->i_ino, inode->i_size, &dir);\r\nif (ret)\r\ngoto out;\r\nswitch ((unsigned long)filp->f_pos) {\r\ncase 0:\r\nif (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR) < 0)\r\ngoto free_out;\r\nfilp->f_pos += 1;\r\ncase 1:\r\nif (filldir(dirent, "..", 2, 1, dir.parent_id, DT_DIR) < 0)\r\ngoto free_out;\r\nfilp->f_pos += 1;\r\ndefault:\r\nbreak;\r\n}\r\nread_lock(&adfs_dir_lock);\r\nret = ops->setpos(&dir, filp->f_pos - 2);\r\nif (ret)\r\ngoto unlock_out;\r\nwhile (ops->getnext(&dir, &obj) == 0) {\r\nif (filldir(dirent, obj.name, obj.name_len,\r\nfilp->f_pos, obj.file_id, DT_UNKNOWN) < 0)\r\ngoto unlock_out;\r\nfilp->f_pos += 1;\r\n}\r\nunlock_out:\r\nread_unlock(&adfs_dir_lock);\r\nfree_out:\r\nops->free(&dir);\r\nout:\r\nreturn ret;\r\n}\r\nint\r\nadfs_dir_update(struct super_block *sb, struct object_info *obj, int wait)\r\n{\r\nint ret = -EINVAL;\r\n#ifdef CONFIG_ADFS_FS_RW\r\nstruct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\r\nstruct adfs_dir dir;\r\nprintk(KERN_INFO "adfs_dir_update: object %06X in dir %06X\n",\r\nobj->file_id, obj->parent_id);\r\nif (!ops->update) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = ops->read(sb, obj->parent_id, 0, &dir);\r\nif (ret)\r\ngoto out;\r\nwrite_lock(&adfs_dir_lock);\r\nret = ops->update(&dir, obj);\r\nwrite_unlock(&adfs_dir_lock);\r\nif (wait) {\r\nint err = ops->sync(&dir);\r\nif (!ret)\r\nret = err;\r\n}\r\nops->free(&dir);\r\nout:\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_match(struct qstr *name, struct object_info *obj)\r\n{\r\nint i;\r\nif (name->len != obj->name_len)\r\nreturn 0;\r\nfor (i = 0; i < name->len; i++) {\r\nchar c1, c2;\r\nc1 = name->name[i];\r\nc2 = obj->name[i];\r\nif (c1 >= 'A' && c1 <= 'Z')\r\nc1 += 'a' - 'A';\r\nif (c2 >= 'A' && c2 <= 'Z')\r\nc2 += 'a' - 'A';\r\nif (c1 != c2)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nadfs_dir_lookup_byname(struct inode *inode, struct qstr *name, struct object_info *obj)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;\r\nstruct adfs_dir dir;\r\nint ret;\r\nret = ops->read(sb, inode->i_ino, inode->i_size, &dir);\r\nif (ret)\r\ngoto out;\r\nif (ADFS_I(inode)->parent_id != dir.parent_id) {\r\nadfs_error(sb, "parent directory changed under me! (%lx but got %lx)\n",\r\nADFS_I(inode)->parent_id, dir.parent_id);\r\nret = -EIO;\r\ngoto free_out;\r\n}\r\nobj->parent_id = inode->i_ino;\r\nif (name->len == 2 && name->name[0] == '.' && name->name[1] == '.') {\r\nobj->name_len = 0;\r\nobj->file_id = obj->parent_id;\r\ngoto free_out;\r\n}\r\nread_lock(&adfs_dir_lock);\r\nret = ops->setpos(&dir, 0);\r\nif (ret)\r\ngoto unlock_out;\r\nret = -ENOENT;\r\nwhile (ops->getnext(&dir, obj) == 0) {\r\nif (adfs_match(name, obj)) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nunlock_out:\r\nread_unlock(&adfs_dir_lock);\r\nfree_out:\r\nops->free(&dir);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_hash(const struct dentry *parent, const struct inode *inode,\r\nstruct qstr *qstr)\r\n{\r\nconst unsigned int name_len = ADFS_SB(parent->d_sb)->s_namelen;\r\nconst unsigned char *name;\r\nunsigned long hash;\r\nint i;\r\nif (qstr->len < name_len)\r\nreturn 0;\r\nqstr->len = i = name_len;\r\nname = qstr->name;\r\nhash = init_name_hash();\r\nwhile (i--) {\r\nchar c;\r\nc = *name++;\r\nif (c >= 'A' && c <= 'Z')\r\nc += 'a' - 'A';\r\nhash = partial_name_hash(c, hash);\r\n}\r\nqstr->hash = end_name_hash(hash);\r\nreturn 0;\r\n}\r\nstatic int\r\nadfs_compare(const struct dentry *parent, const struct inode *pinode,\r\nconst struct dentry *dentry, const struct inode *inode,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nint i;\r\nif (len != name->len)\r\nreturn 1;\r\nfor (i = 0; i < name->len; i++) {\r\nchar a, b;\r\na = str[i];\r\nb = name->name[i];\r\nif (a >= 'A' && a <= 'Z')\r\na += 'a' - 'A';\r\nif (b >= 'A' && b <= 'Z')\r\nb += 'a' - 'A';\r\nif (a != b)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dentry *\r\nadfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct inode *inode = NULL;\r\nstruct object_info obj;\r\nint error;\r\nerror = adfs_dir_lookup_byname(dir, &dentry->d_name, &obj);\r\nif (error == 0) {\r\nerror = -EACCES;\r\ninode = adfs_iget(dir->i_sb, &obj);\r\nif (inode)\r\nerror = 0;\r\n}\r\nd_add(dentry, inode);\r\nreturn ERR_PTR(error);\r\n}
