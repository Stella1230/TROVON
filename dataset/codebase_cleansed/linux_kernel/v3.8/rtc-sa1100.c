static irqreturn_t sa1100_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev_id);\r\nstruct rtc_device *rtc = info->rtc;\r\nunsigned int rtsr;\r\nunsigned long events = 0;\r\nspin_lock(&info->lock);\r\nrtsr = RTSR;\r\nRTSR = 0;\r\nif (rtsr & (RTSR_ALE | RTSR_HZE)) {\r\nRTSR = (RTSR_AL | RTSR_HZ) & (rtsr >> 2);\r\n} else {\r\nRTSR = RTSR_AL | RTSR_HZ;\r\n}\r\nif (rtsr & RTSR_AL)\r\nrtsr &= ~RTSR_ALE;\r\nRTSR = rtsr & (RTSR_ALE | RTSR_HZE);\r\nif (rtsr & RTSR_AL)\r\nevents |= RTC_AF | RTC_IRQF;\r\nif (rtsr & RTSR_HZ)\r\nevents |= RTC_UF | RTC_IRQF;\r\nrtc_update_irq(rtc, 1, events);\r\nspin_unlock(&info->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sa1100_rtc_open(struct device *dev)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev);\r\nstruct rtc_device *rtc = info->rtc;\r\nint ret;\r\nret = clk_prepare_enable(info->clk);\r\nif (ret)\r\ngoto fail_clk;\r\nret = request_irq(info->irq_1hz, sa1100_rtc_interrupt, 0, "rtc 1Hz", dev);\r\nif (ret) {\r\ndev_err(dev, "IRQ %d already in use.\n", info->irq_1hz);\r\ngoto fail_ui;\r\n}\r\nret = request_irq(info->irq_alarm, sa1100_rtc_interrupt, 0, "rtc Alrm", dev);\r\nif (ret) {\r\ndev_err(dev, "IRQ %d already in use.\n", info->irq_alarm);\r\ngoto fail_ai;\r\n}\r\nrtc->max_user_freq = RTC_FREQ;\r\nrtc_irq_set_freq(rtc, NULL, RTC_FREQ);\r\nreturn 0;\r\nfail_ai:\r\nfree_irq(info->irq_1hz, dev);\r\nfail_ui:\r\nclk_disable_unprepare(info->clk);\r\nfail_clk:\r\nreturn ret;\r\n}\r\nstatic void sa1100_rtc_release(struct device *dev)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev);\r\nspin_lock_irq(&info->lock);\r\nRTSR = 0;\r\nspin_unlock_irq(&info->lock);\r\nfree_irq(info->irq_alarm, dev);\r\nfree_irq(info->irq_1hz, dev);\r\nclk_disable_unprepare(info->clk);\r\n}\r\nstatic int sa1100_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev);\r\nspin_lock_irq(&info->lock);\r\nif (enabled)\r\nRTSR |= RTSR_ALE;\r\nelse\r\nRTSR &= ~RTSR_ALE;\r\nspin_unlock_irq(&info->lock);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nrtc_time_to_tm(RCNR, tm);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long time;\r\nint ret;\r\nret = rtc_tm_to_time(tm, &time);\r\nif (ret == 0)\r\nRCNR = time;\r\nreturn ret;\r\n}\r\nstatic int sa1100_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nu32 rtsr;\r\nrtsr = RTSR;\r\nalrm->enabled = (rtsr & RTSR_ALE) ? 1 : 0;\r\nalrm->pending = (rtsr & RTSR_AL) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev);\r\nunsigned long time;\r\nint ret;\r\nspin_lock_irq(&info->lock);\r\nret = rtc_tm_to_time(&alrm->time, &time);\r\nif (ret != 0)\r\ngoto out;\r\nRTSR = RTSR & (RTSR_HZE|RTSR_ALE|RTSR_AL);\r\nRTAR = time;\r\nif (alrm->enabled)\r\nRTSR |= RTSR_ALE;\r\nelse\r\nRTSR &= ~RTSR_ALE;\r\nout:\r\nspin_unlock_irq(&info->lock);\r\nreturn ret;\r\n}\r\nstatic int sa1100_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nseq_printf(seq, "trim/divider\t\t: 0x%08x\n", (u32) RTTR);\r\nseq_printf(seq, "RTSR\t\t\t: 0x%08x\n", (u32)RTSR);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc;\r\nstruct sa1100_rtc *info;\r\nint irq_1hz, irq_alarm, ret = 0;\r\nirq_1hz = platform_get_irq_byname(pdev, "rtc 1Hz");\r\nirq_alarm = platform_get_irq_byname(pdev, "rtc alarm");\r\nif (irq_1hz < 0 || irq_alarm < 0)\r\nreturn -ENODEV;\r\ninfo = kzalloc(sizeof(struct sa1100_rtc), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed to find rtc clock source\n");\r\nret = PTR_ERR(info->clk);\r\ngoto err_clk;\r\n}\r\ninfo->irq_1hz = irq_1hz;\r\ninfo->irq_alarm = irq_alarm;\r\nspin_lock_init(&info->lock);\r\nplatform_set_drvdata(pdev, info);\r\nif (RTTR == 0) {\r\nRTTR = RTC_DEF_DIVIDER + (RTC_DEF_TRIM << 16);\r\ndev_warn(&pdev->dev, "warning: "\r\n"initializing default clock divider/trim value\n");\r\nRCNR = 0;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc = rtc_device_register(pdev->name, &pdev->dev, &sa1100_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\nret = PTR_ERR(rtc);\r\ngoto err_dev;\r\n}\r\ninfo->rtc = rtc;\r\nRTSR = RTSR_AL | RTSR_HZ;\r\nreturn 0;\r\nerr_dev:\r\nplatform_set_drvdata(pdev, NULL);\r\nclk_put(info->clk);\r\nerr_clk:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int sa1100_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct sa1100_rtc *info = platform_get_drvdata(pdev);\r\nif (info) {\r\nrtc_device_unregister(info->rtc);\r\nclk_put(info->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_suspend(struct device *dev)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(info->irq_alarm);\r\nreturn 0;\r\n}\r\nstatic int sa1100_rtc_resume(struct device *dev)\r\n{\r\nstruct sa1100_rtc *info = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(info->irq_alarm);\r\nreturn 0;\r\n}
