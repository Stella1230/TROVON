static struct iw_statistics *hostap_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct iw_statistics *wstats;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (iface->type != HOSTAP_INTERFACE_MAIN)\r\nreturn NULL;\r\nwstats = &local->wstats;\r\nwstats->status = 0;\r\nwstats->discard.code =\r\nlocal->comm_tallies.rx_discards_wep_undecryptable;\r\nwstats->discard.misc =\r\nlocal->comm_tallies.rx_fcs_errors +\r\nlocal->comm_tallies.rx_discards_no_buffer +\r\nlocal->comm_tallies.tx_discards_wrong_sa;\r\nwstats->discard.retries =\r\nlocal->comm_tallies.tx_retry_limit_exceeded;\r\nwstats->discard.fragment =\r\nlocal->comm_tallies.rx_message_in_bad_msg_fragments;\r\nif (local->iw_mode != IW_MODE_MASTER &&\r\nlocal->iw_mode != IW_MODE_REPEAT) {\r\nint update = 1;\r\n#ifdef in_atomic\r\nif (in_atomic())\r\nupdate = 0;\r\n#endif\r\nif (update && prism2_update_comms_qual(dev) == 0)\r\nwstats->qual.updated = IW_QUAL_ALL_UPDATED |\r\nIW_QUAL_DBM;\r\nwstats->qual.qual = local->comms_qual;\r\nwstats->qual.level = local->avg_signal;\r\nwstats->qual.noise = local->avg_noise;\r\n} else {\r\nwstats->qual.qual = 0;\r\nwstats->qual.level = 0;\r\nwstats->qual.noise = 0;\r\nwstats->qual.updated = IW_QUAL_ALL_INVALID;\r\n}\r\nreturn wstats;\r\n}\r\nstatic int prism2_get_datarates(struct net_device *dev, u8 *rates)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu8 buf[12];\r\nint len;\r\nu16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nlen = local->func->get_rid(dev, HFA384X_RID_SUPPORTEDDATARATES, buf,\r\nsizeof(buf), 0);\r\nif (len < 2)\r\nreturn 0;\r\nval = le16_to_cpu(*(__le16 *) buf);\r\nif (len - 2 < val || val > 10)\r\nreturn 0;\r\nmemcpy(rates, buf + 2, val);\r\nreturn val;\r\n}\r\nstatic int prism2_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nchar *name, char *extra)\r\n{\r\nu8 rates[10];\r\nint len, i, over2 = 0;\r\nlen = prism2_get_datarates(dev, rates);\r\nfor (i = 0; i < len; i++) {\r\nif (rates[i] == 0x0b || rates[i] == 0x16) {\r\nover2 = 1;\r\nbreak;\r\n}\r\n}\r\nstrcpy(name, over2 ? "IEEE 802.11b" : "IEEE 802.11-DS");\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *keybuf)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint i;\r\nstruct lib80211_crypt_data **crypt;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\ni = erq->flags & IW_ENCODE_INDEX;\r\nif (i < 1 || i > 4)\r\ni = local->crypt_info.tx_keyidx;\r\nelse\r\ni--;\r\nif (i < 0 || i >= WEP_KEYS)\r\nreturn -EINVAL;\r\ncrypt = &local->crypt_info.crypt[i];\r\nif (erq->flags & IW_ENCODE_DISABLED) {\r\nif (*crypt)\r\nlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\r\ngoto done;\r\n}\r\nif (*crypt != NULL && (*crypt)->ops != NULL &&\r\nstrcmp((*crypt)->ops->name, "WEP") != 0) {\r\nlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\r\n}\r\nif (*crypt == NULL) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\r\nGFP_KERNEL);\r\nif (new_crypt == NULL)\r\nreturn -ENOMEM;\r\nnew_crypt->ops = lib80211_get_crypto_ops("WEP");\r\nif (!new_crypt->ops) {\r\nrequest_module("lib80211_crypt_wep");\r\nnew_crypt->ops = lib80211_get_crypto_ops("WEP");\r\n}\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(i);\r\nif (!new_crypt->ops || !new_crypt->priv) {\r\nkfree(new_crypt);\r\nnew_crypt = NULL;\r\nprintk(KERN_WARNING "%s: could not initialize WEP: "\r\n"load module hostap_crypt_wep.o\n",\r\ndev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (erq->length > 0) {\r\nint len = erq->length <= 5 ? 5 : 13;\r\nint first = 1, j;\r\nif (len > erq->length)\r\nmemset(keybuf + erq->length, 0, len - erq->length);\r\n(*crypt)->ops->set_key(keybuf, len, NULL, (*crypt)->priv);\r\nfor (j = 0; j < WEP_KEYS; j++) {\r\nif (j != i && local->crypt_info.crypt[j]) {\r\nfirst = 0;\r\nbreak;\r\n}\r\n}\r\nif (first)\r\nlocal->crypt_info.tx_keyidx = i;\r\n} else {\r\nlocal->crypt_info.tx_keyidx = i;\r\n}\r\ndone:\r\nlocal->open_wep = erq->flags & IW_ENCODE_OPEN;\r\nif (hostap_set_encryption(local)) {\r\nprintk(KERN_DEBUG "%s: set_encryption failed\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nif (local->iw_mode != IW_MODE_INFRA && local->func->reset_port(dev)) {\r\nprintk(KERN_DEBUG "%s: reset_port failed\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *key)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint i, len;\r\nu16 val;\r\nstruct lib80211_crypt_data *crypt;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\ni = erq->flags & IW_ENCODE_INDEX;\r\nif (i < 1 || i > 4)\r\ni = local->crypt_info.tx_keyidx;\r\nelse\r\ni--;\r\nif (i < 0 || i >= WEP_KEYS)\r\nreturn -EINVAL;\r\ncrypt = local->crypt_info.crypt[i];\r\nerq->flags = i + 1;\r\nif (crypt == NULL || crypt->ops == NULL) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nreturn 0;\r\n}\r\nif (strcmp(crypt->ops->name, "WEP") != 0) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nreturn 0;\r\n}\r\nlen = crypt->ops->get_key(key, WEP_KEY_LEN, NULL, crypt->priv);\r\nerq->length = (len >= 0 ? len : 0);\r\nif (local->func->get_rid(dev, HFA384X_RID_CNFWEPFLAGS, &val, 2, 1) < 0)\r\n{\r\nprintk("CNFWEPFLAGS reading failed\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nle16_to_cpus(&val);\r\nif (val & HFA384X_WEPFLAGS_PRIVACYINVOKED)\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nelse\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nif (val & HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED)\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\nelse\r\nerq->flags |= IW_ENCODE_OPEN;\r\nreturn 0;\r\n}\r\nstatic int hostap_set_rate(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret, basic_rates;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nbasic_rates = local->basic_rates & local->tx_rate_control;\r\nif (!basic_rates || basic_rates != local->basic_rates) {\r\nprintk(KERN_INFO "%s: updating basic rate set automatically "\r\n"to match with the new supported rate set\n",\r\ndev->name);\r\nif (!basic_rates)\r\nbasic_rates = local->tx_rate_control;\r\nlocal->basic_rates = basic_rates;\r\nif (hostap_set_word(dev, HFA384X_RID_CNFBASICRATES,\r\nbasic_rates))\r\nprintk(KERN_WARNING "%s: failed to set "\r\n"cnfBasicRates\n", dev->name);\r\n}\r\nret = (hostap_set_word(dev, HFA384X_RID_TXRATECONTROL,\r\nlocal->tx_rate_control) ||\r\nhostap_set_word(dev, HFA384X_RID_CNFSUPPORTEDRATES,\r\nlocal->tx_rate_control) ||\r\nlocal->func->reset_port(dev));\r\nif (ret) {\r\nprintk(KERN_WARNING "%s: TXRateControl/cnfSupportedRates "\r\n"setting to 0x%x failed\n",\r\ndev->name, local->tx_rate_control);\r\n}\r\nhostap_update_rates(local);\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_siwrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (rrq->fixed) {\r\nswitch (rrq->value) {\r\ncase 11000000:\r\nlocal->tx_rate_control = HFA384X_RATES_11MBPS;\r\nbreak;\r\ncase 5500000:\r\nlocal->tx_rate_control = HFA384X_RATES_5MBPS;\r\nbreak;\r\ncase 2000000:\r\nlocal->tx_rate_control = HFA384X_RATES_2MBPS;\r\nbreak;\r\ncase 1000000:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS;\r\nbreak;\r\ndefault:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS |\r\nHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS |\r\nHFA384X_RATES_11MBPS;\r\nbreak;\r\n}\r\n} else {\r\nswitch (rrq->value) {\r\ncase 11000000:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS |\r\nHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS |\r\nHFA384X_RATES_11MBPS;\r\nbreak;\r\ncase 5500000:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS |\r\nHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS;\r\nbreak;\r\ncase 2000000:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS |\r\nHFA384X_RATES_2MBPS;\r\nbreak;\r\ncase 1000000:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS;\r\nbreak;\r\ndefault:\r\nlocal->tx_rate_control = HFA384X_RATES_1MBPS |\r\nHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS |\r\nHFA384X_RATES_11MBPS;\r\nbreak;\r\n}\r\n}\r\nreturn hostap_set_rate(dev);\r\n}\r\nstatic int prism2_ioctl_giwrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\nu16 val;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_TXRATECONTROL, &val, 2, 1) <\r\n0)\r\nreturn -EINVAL;\r\nif ((val & 0x1) && (val > 1))\r\nrrq->fixed = 0;\r\nelse\r\nrrq->fixed = 1;\r\nif (local->iw_mode == IW_MODE_MASTER && local->ap != NULL &&\r\n!local->fw_tx_rate_control) {\r\nrrq->value = local->ap->last_tx_rate > 0 ?\r\nlocal->ap->last_tx_rate * 100000 : 11000000;\r\nreturn 0;\r\n}\r\nif (local->func->get_rid(dev, HFA384X_RID_CURRENTTXRATE, &val, 2, 1) <\r\n0)\r\nreturn -EINVAL;\r\nswitch (val) {\r\ncase HFA384X_RATES_1MBPS:\r\nrrq->value = 1000000;\r\nbreak;\r\ncase HFA384X_RATES_2MBPS:\r\nrrq->value = 2000000;\r\nbreak;\r\ncase HFA384X_RATES_5MBPS:\r\nrrq->value = 5500000;\r\nbreak;\r\ncase HFA384X_RATES_11MBPS:\r\nrrq->value = 11000000;\r\nbreak;\r\ndefault:\r\nrrq->value = 11000000;\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_siwsens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *sens, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (sens->value < 1 || sens->value > 3)\r\nreturn -EINVAL;\r\nif (hostap_set_word(dev, HFA384X_RID_CNFSYSTEMSCALE, sens->value) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwsens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *sens, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_CNFSYSTEMSCALE, &val, 2, 1) <\r\n0)\r\nreturn -EINVAL;\r\nsens->value = le16_to_cpu(val);\r\nsens->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwaplist(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct sockaddr *addr;\r\nstruct iw_quality *qual;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->iw_mode != IW_MODE_MASTER) {\r\nprintk(KERN_DEBUG "SIOCGIWAPLIST is currently only supported "\r\n"in Host AP mode\n");\r\ndata->length = 0;\r\nreturn -EOPNOTSUPP;\r\n}\r\naddr = kmalloc(sizeof(struct sockaddr) * IW_MAX_AP, GFP_KERNEL);\r\nqual = kmalloc(sizeof(struct iw_quality) * IW_MAX_AP, GFP_KERNEL);\r\nif (addr == NULL || qual == NULL) {\r\nkfree(addr);\r\nkfree(qual);\r\ndata->length = 0;\r\nreturn -ENOMEM;\r\n}\r\ndata->length = prism2_ap_get_sta_qual(local, addr, qual, IW_MAX_AP, 1);\r\nmemcpy(extra, &addr, sizeof(struct sockaddr) * data->length);\r\ndata->flags = 1;\r\nmemcpy(extra + sizeof(struct sockaddr) * data->length, &qual,\r\nsizeof(struct iw_quality) * data->length);\r\nkfree(addr);\r\nkfree(qual);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwrts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (rts->disabled)\r\nval = cpu_to_le16(2347);\r\nelse if (rts->value < 0 || rts->value > 2347)\r\nreturn -EINVAL;\r\nelse\r\nval = cpu_to_le16(rts->value);\r\nif (local->func->set_rid(dev, HFA384X_RID_RTSTHRESHOLD, &val, 2) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nlocal->rts_threshold = rts->value;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwrts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_RTSTHRESHOLD, &val, 2, 1) <\r\n0)\r\nreturn -EINVAL;\r\nrts->value = le16_to_cpu(val);\r\nrts->disabled = (rts->value == 2347);\r\nrts->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwfrag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (rts->disabled)\r\nval = cpu_to_le16(2346);\r\nelse if (rts->value < 256 || rts->value > 2346)\r\nreturn -EINVAL;\r\nelse\r\nval = cpu_to_le16(rts->value & ~0x1);\r\nlocal->fragm_threshold = rts->value & ~0x1;\r\nif (local->func->set_rid(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD, &val,\r\n2)\r\n|| local->func->reset_port(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwfrag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD,\r\n&val, 2, 1) < 0)\r\nreturn -EINVAL;\r\nrts->value = le16_to_cpu(val);\r\nrts->disabled = (rts->value == 2346);\r\nrts->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int hostap_join_ap(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hfa384x_join_request req;\r\nunsigned long flags;\r\nint i;\r\nstruct hfa384x_hostscan_result *entry;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmemcpy(req.bssid, local->preferred_ap, ETH_ALEN);\r\nreq.channel = 0;\r\nspin_lock_irqsave(&local->lock, flags);\r\nfor (i = 0; i < local->last_scan_results_count; i++) {\r\nif (!local->last_scan_results)\r\nbreak;\r\nentry = &local->last_scan_results[i];\r\nif (memcmp(local->preferred_ap, entry->bssid, ETH_ALEN) == 0) {\r\nreq.channel = entry->chid;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nif (local->func->set_rid(dev, HFA384X_RID_JOINREQUEST, &req,\r\nsizeof(req))) {\r\nprintk(KERN_DEBUG "%s: JoinRequest %pM failed\n",\r\ndev->name, local->preferred_ap);\r\nreturn -1;\r\n}\r\nprintk(KERN_DEBUG "%s: Trying to join BSSID %pM\n",\r\ndev->name, local->preferred_ap);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr, char *extra)\r\n{\r\n#ifdef PRISM2_NO_STATION_MODES\r\nreturn -EOPNOTSUPP;\r\n#else\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmemcpy(local->preferred_ap, &ap_addr->sa_data, ETH_ALEN);\r\nif (local->host_roaming == 1 && local->iw_mode == IW_MODE_INFRA) {\r\nstruct hfa384x_scan_request scan_req;\r\nmemset(&scan_req, 0, sizeof(scan_req));\r\nscan_req.channel_list = cpu_to_le16(0x3fff);\r\nscan_req.txrate = cpu_to_le16(HFA384X_RATES_1MBPS);\r\nif (local->func->set_rid(dev, HFA384X_RID_SCANREQUEST,\r\n&scan_req, sizeof(scan_req))) {\r\nprintk(KERN_DEBUG "%s: ScanResults request failed - "\r\n"preferred AP delayed to next unsolicited "\r\n"scan\n", dev->name);\r\n}\r\n} else if (local->host_roaming == 2 &&\r\nlocal->iw_mode == IW_MODE_INFRA) {\r\nif (hostap_join_ap(dev))\r\nreturn -EINVAL;\r\n} else {\r\nprintk(KERN_DEBUG "%s: Preferred AP (SIOCSIWAP) is used only "\r\n"in Managed mode when host_roaming is enabled\n",\r\ndev->name);\r\n}\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int prism2_ioctl_giwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nap_addr->sa_family = ARPHRD_ETHER;\r\nswitch (iface->type) {\r\ncase HOSTAP_INTERFACE_AP:\r\nmemcpy(&ap_addr->sa_data, dev->dev_addr, ETH_ALEN);\r\nbreak;\r\ncase HOSTAP_INTERFACE_STA:\r\nmemcpy(&ap_addr->sa_data, local->assoc_ap_addr, ETH_ALEN);\r\nbreak;\r\ncase HOSTAP_INTERFACE_WDS:\r\nmemcpy(&ap_addr->sa_data, iface->u.wds.remote_addr, ETH_ALEN);\r\nbreak;\r\ndefault:\r\nif (local->func->get_rid(dev, HFA384X_RID_CURRENTBSSID,\r\n&ap_addr->sa_data, ETH_ALEN, 1) < 0)\r\nreturn -EOPNOTSUPP;\r\nmemcpy(local->bssid, &ap_addr->sa_data, ETH_ALEN);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwnickn(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *nickname)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmemset(local->name, 0, sizeof(local->name));\r\nmemcpy(local->name, nickname, data->length);\r\nlocal->name_set = 1;\r\nif (hostap_set_string(dev, HFA384X_RID_CNFOWNNAME, local->name) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwnickn(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *nickname)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint len;\r\nchar name[MAX_NAME_LEN + 3];\r\nu16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nlen = local->func->get_rid(dev, HFA384X_RID_CNFOWNNAME,\r\n&name, MAX_NAME_LEN + 2, 0);\r\nval = le16_to_cpu(*(__le16 *) name);\r\nif (len > MAX_NAME_LEN + 2 || len < 0 || val > MAX_NAME_LEN)\r\nreturn -EOPNOTSUPP;\r\nname[val + 2] = '\0';\r\ndata->length = val + 1;\r\nmemcpy(nickname, name + 2, val + 1);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *freq, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (freq->e == 1 &&\r\nfreq->m / 100000 >= freq_list[0] &&\r\nfreq->m / 100000 <= freq_list[FREQ_COUNT - 1]) {\r\nint ch;\r\nint fr = freq->m / 100000;\r\nfor (ch = 0; ch < FREQ_COUNT; ch++) {\r\nif (fr == freq_list[ch]) {\r\nfreq->e = 0;\r\nfreq->m = ch + 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (freq->e != 0 || freq->m < 1 || freq->m > FREQ_COUNT ||\r\n!(local->channel_mask & (1 << (freq->m - 1))))\r\nreturn -EINVAL;\r\nlocal->channel = freq->m;\r\nif (hostap_set_word(dev, HFA384X_RID_CNFOWNCHANNEL, local->channel) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *freq, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_CURRENTCHANNEL, &val, 2, 1) <\r\n0)\r\nreturn -EINVAL;\r\nle16_to_cpus(&val);\r\nif (val < 1 || val > FREQ_COUNT)\r\nreturn -EINVAL;\r\nfreq->m = freq_list[val - 1] * 100000;\r\nfreq->e = 1;\r\nreturn 0;\r\n}\r\nstatic void hostap_monitor_set_type(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->ddev;\r\nif (dev == NULL)\r\nreturn;\r\nif (local->monitor_type == PRISM2_MONITOR_PRISM ||\r\nlocal->monitor_type == PRISM2_MONITOR_CAPHDR) {\r\ndev->type = ARPHRD_IEEE80211_PRISM;\r\n} else if (local->monitor_type == PRISM2_MONITOR_RADIOTAP) {\r\ndev->type = ARPHRD_IEEE80211_RADIOTAP;\r\n} else {\r\ndev->type = ARPHRD_IEEE80211;\r\n}\r\n}\r\nstatic int prism2_ioctl_siwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *ssid)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (iface->type == HOSTAP_INTERFACE_WDS)\r\nreturn -EOPNOTSUPP;\r\nif (data->flags == 0)\r\nssid[0] = '\0';\r\nif (local->iw_mode == IW_MODE_MASTER && ssid[0] == '\0') {\r\nprintk(KERN_DEBUG "%s: Host AP mode does not support "\r\n"'Any' essid\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(local->essid, ssid, data->length);\r\nlocal->essid[data->length] = '\0';\r\nif ((!local->fw_ap &&\r\nhostap_set_string(dev, HFA384X_RID_CNFDESIREDSSID, local->essid))\r\n|| hostap_set_string(dev, HFA384X_RID_CNFOWNSSID, local->essid) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *essid)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (iface->type == HOSTAP_INTERFACE_WDS)\r\nreturn -EOPNOTSUPP;\r\ndata->flags = 1;\r\nif (local->iw_mode == IW_MODE_MASTER) {\r\ndata->length = strlen(local->essid);\r\nmemcpy(essid, local->essid, IW_ESSID_MAX_SIZE);\r\n} else {\r\nint len;\r\nchar ssid[MAX_SSID_LEN + 2];\r\nmemset(ssid, 0, sizeof(ssid));\r\nlen = local->func->get_rid(dev, HFA384X_RID_CURRENTSSID,\r\n&ssid, MAX_SSID_LEN + 2, 0);\r\nval = le16_to_cpu(*(__le16 *) ssid);\r\nif (len > MAX_SSID_LEN + 2 || len < 0 || val > MAX_SSID_LEN) {\r\nreturn -EOPNOTSUPP;\r\n}\r\ndata->length = val;\r\nmemcpy(essid, ssid + 2, IW_ESSID_MAX_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwrange(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nu8 rates[10];\r\nu16 val;\r\nint i, len, over2;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\ndata->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nrange->txpower_capa = IW_TXPOW_DBM;\r\nif (local->iw_mode == IW_MODE_INFRA || local->iw_mode == IW_MODE_ADHOC)\r\n{\r\nrange->min_pmp = 1 * 1024;\r\nrange->max_pmp = 65535 * 1024;\r\nrange->min_pmt = 1 * 1024;\r\nrange->max_pmt = 1000 * 1024;\r\nrange->pmp_flags = IW_POWER_PERIOD;\r\nrange->pmt_flags = IW_POWER_TIMEOUT;\r\nrange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT |\r\nIW_POWER_UNICAST_R | IW_POWER_ALL_R;\r\n}\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 18;\r\nrange->retry_capa = IW_RETRY_LIMIT;\r\nrange->retry_flags = IW_RETRY_LIMIT;\r\nrange->min_retry = 0;\r\nrange->max_retry = 255;\r\nrange->num_channels = FREQ_COUNT;\r\nval = 0;\r\nfor (i = 0; i < FREQ_COUNT; i++) {\r\nif (local->channel_mask & (1 << i)) {\r\nrange->freq[val].i = i + 1;\r\nrange->freq[val].m = freq_list[i] * 100000;\r\nrange->freq[val].e = 1;\r\nval++;\r\n}\r\nif (val == IW_MAX_FREQUENCIES)\r\nbreak;\r\n}\r\nrange->num_frequency = val;\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\r\nrange->max_qual.qual = 70;\r\nrange->max_qual.level = 0;\r\nrange->max_qual.noise = 0;\r\nrange->avg_qual.qual = 20;\r\nrange->avg_qual.level = -60;\r\nrange->avg_qual.noise = -95;\r\n} else {\r\nrange->max_qual.qual = 92;\r\nrange->max_qual.level = 154;\r\nrange->max_qual.noise = 154;\r\n}\r\nrange->sensitivity = 3;\r\nrange->max_encoding_tokens = WEP_KEYS;\r\nrange->num_encoding_sizes = 2;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nover2 = 0;\r\nlen = prism2_get_datarates(dev, rates);\r\nrange->num_bitrates = 0;\r\nfor (i = 0; i < len; i++) {\r\nif (range->num_bitrates < IW_MAX_BITRATES) {\r\nrange->bitrate[range->num_bitrates] =\r\nrates[i] * 500000;\r\nrange->num_bitrates++;\r\n}\r\nif (rates[i] == 0x0b || rates[i] == 0x16)\r\nover2 = 1;\r\n}\r\nrange->throughput = over2 ? 5500000 : 1500000;\r\nrange->min_rts = 0;\r\nrange->max_rts = 2347;\r\nrange->min_frag = 256;\r\nrange->max_frag = 2346;\r\nrange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\r\nIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWAP) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\r\nrange->event_capa[1] = IW_EVENT_CAPA_K_1;\r\nrange->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVTXDROP) |\r\nIW_EVENT_CAPA_MASK(IWEVCUSTOM) |\r\nIW_EVENT_CAPA_MASK(IWEVREGISTERED) |\r\nIW_EVENT_CAPA_MASK(IWEVEXPIRED));\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1))\r\nrange->scan_capa = IW_SCAN_CAPA_ESSID;\r\nreturn 0;\r\n}\r\nstatic int hostap_monitor_mode_enable(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->dev;\r\nprintk(KERN_DEBUG "Enabling monitor mode\n");\r\nhostap_monitor_set_type(local);\r\nif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\r\nHFA384X_PORTTYPE_PSEUDO_IBSS)) {\r\nprintk(KERN_DEBUG "Port type setting for monitor mode "\r\n"failed\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (hostap_set_word(dev, HFA384X_RID_CNFWEPFLAGS,\r\nHFA384X_WEPFLAGS_HOSTENCRYPT |\r\nHFA384X_WEPFLAGS_HOSTDECRYPT)) {\r\nprintk(KERN_DEBUG "WEP flags setting failed\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (local->func->reset_port(dev) ||\r\nlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\r\n(HFA384X_TEST_MONITOR << 8),\r\n0, NULL, NULL)) {\r\nprintk(KERN_DEBUG "Setting monitor mode failed\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hostap_monitor_mode_disable(local_info_t *local)\r\n{\r\nstruct net_device *dev = local->ddev;\r\nif (dev == NULL)\r\nreturn -1;\r\nprintk(KERN_DEBUG "%s: Disabling monitor mode\n", dev->name);\r\ndev->type = ARPHRD_ETHER;\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_TEST |\r\n(HFA384X_TEST_STOP << 8),\r\n0, NULL, NULL))\r\nreturn -1;\r\nreturn hostap_set_encryption(local);\r\n}\r\nstatic int prism2_ioctl_siwmode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *mode, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint double_reset = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (*mode != IW_MODE_ADHOC && *mode != IW_MODE_INFRA &&\r\n*mode != IW_MODE_MASTER && *mode != IW_MODE_REPEAT &&\r\n*mode != IW_MODE_MONITOR)\r\nreturn -EOPNOTSUPP;\r\n#ifdef PRISM2_NO_STATION_MODES\r\nif (*mode == IW_MODE_ADHOC || *mode == IW_MODE_INFRA)\r\nreturn -EOPNOTSUPP;\r\n#endif\r\nif (*mode == local->iw_mode)\r\nreturn 0;\r\nif (*mode == IW_MODE_MASTER && local->essid[0] == '\0') {\r\nprintk(KERN_WARNING "%s: empty SSID not allowed in Master "\r\n"mode\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nif (local->iw_mode == IW_MODE_MONITOR)\r\nhostap_monitor_mode_disable(local);\r\nif ((local->iw_mode == IW_MODE_ADHOC ||\r\nlocal->iw_mode == IW_MODE_MONITOR) && *mode == IW_MODE_MASTER) {\r\ndouble_reset = 1;\r\n}\r\nprintk(KERN_DEBUG "prism2: %s: operating mode changed "\r\n"%d -> %d\n", dev->name, local->iw_mode, *mode);\r\nlocal->iw_mode = *mode;\r\nif (local->iw_mode == IW_MODE_MONITOR)\r\nhostap_monitor_mode_enable(local);\r\nelse if (local->iw_mode == IW_MODE_MASTER && !local->host_encrypt &&\r\n!local->fw_encrypt_ok) {\r\nprintk(KERN_DEBUG "%s: defaulting to host-based encryption as "\r\n"a workaround for firmware bug in Host AP mode WEP\n",\r\ndev->name);\r\nlocal->host_encrypt = 1;\r\n}\r\nif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\r\nhostap_get_porttype(local)))\r\nreturn -EOPNOTSUPP;\r\nif (local->func->reset_port(dev))\r\nreturn -EINVAL;\r\nif (double_reset && local->func->reset_port(dev))\r\nreturn -EINVAL;\r\nif (local->iw_mode != IW_MODE_INFRA && local->iw_mode != IW_MODE_ADHOC)\r\n{\r\nnetif_carrier_on(local->dev);\r\nnetif_carrier_on(local->ddev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwmode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *mode, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nswitch (iface->type) {\r\ncase HOSTAP_INTERFACE_STA:\r\n*mode = IW_MODE_INFRA;\r\nbreak;\r\ncase HOSTAP_INTERFACE_WDS:\r\n*mode = IW_MODE_REPEAT;\r\nbreak;\r\ndefault:\r\n*mode = local->iw_mode;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq, char *extra)\r\n{\r\n#ifdef PRISM2_NO_STATION_MODES\r\nreturn -EOPNOTSUPP;\r\n#else\r\nint ret = 0;\r\nif (wrq->disabled)\r\nreturn hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 0);\r\nswitch (wrq->flags & IW_POWER_MODE) {\r\ncase IW_POWER_UNICAST_R:\r\nret = hostap_set_word(dev, HFA384X_RID_CNFMULTICASTRECEIVE, 0);\r\nif (ret)\r\nreturn ret;\r\nret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase IW_POWER_ALL_R:\r\nret = hostap_set_word(dev, HFA384X_RID_CNFMULTICASTRECEIVE, 1);\r\nif (ret)\r\nreturn ret;\r\nret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase IW_POWER_ON:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (wrq->flags & IW_POWER_TIMEOUT) {\r\nret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\r\nif (ret)\r\nreturn ret;\r\nret = hostap_set_word(dev, HFA384X_RID_CNFPMHOLDOVERDURATION,\r\nwrq->value / 1024);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (wrq->flags & IW_POWER_PERIOD) {\r\nret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\r\nif (ret)\r\nreturn ret;\r\nret = hostap_set_word(dev, HFA384X_RID_CNFMAXSLEEPDURATION,\r\nwrq->value / 1024);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n#endif\r\n}\r\nstatic int prism2_ioctl_giwpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\n#ifdef PRISM2_NO_STATION_MODES\r\nreturn -EOPNOTSUPP;\r\n#else\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 enable, mcast;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_CNFPMENABLED, &enable, 2, 1)\r\n< 0)\r\nreturn -EINVAL;\r\nif (!le16_to_cpu(enable)) {\r\nrrq->disabled = 1;\r\nreturn 0;\r\n}\r\nrrq->disabled = 0;\r\nif ((rrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\n__le16 timeout;\r\nif (local->func->get_rid(dev,\r\nHFA384X_RID_CNFPMHOLDOVERDURATION,\r\n&timeout, 2, 1) < 0)\r\nreturn -EINVAL;\r\nrrq->flags = IW_POWER_TIMEOUT;\r\nrrq->value = le16_to_cpu(timeout) * 1024;\r\n} else {\r\n__le16 period;\r\nif (local->func->get_rid(dev, HFA384X_RID_CNFMAXSLEEPDURATION,\r\n&period, 2, 1) < 0)\r\nreturn -EINVAL;\r\nrrq->flags = IW_POWER_PERIOD;\r\nrrq->value = le16_to_cpu(period) * 1024;\r\n}\r\nif (local->func->get_rid(dev, HFA384X_RID_CNFMULTICASTRECEIVE, &mcast,\r\n2, 1) < 0)\r\nreturn -EINVAL;\r\nif (le16_to_cpu(mcast))\r\nrrq->flags |= IW_POWER_ALL_R;\r\nelse\r\nrrq->flags |= IW_POWER_UNICAST_R;\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int prism2_ioctl_siwretry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (rrq->disabled)\r\nreturn -EINVAL;\r\nif (rrq->flags == IW_RETRY_LIMIT) {\r\nif (rrq->value < 0) {\r\nlocal->manual_retry_count = -1;\r\nlocal->tx_control &= ~HFA384X_TX_CTRL_ALT_RTRY;\r\n} else {\r\nif (hostap_set_word(dev, HFA384X_RID_CNFALTRETRYCOUNT,\r\nrrq->value)) {\r\nprintk(KERN_DEBUG "%s: Alternate retry count "\r\n"setting to %d failed\n",\r\ndev->name, rrq->value);\r\nreturn -EOPNOTSUPP;\r\n}\r\nlocal->manual_retry_count = rrq->value;\r\nlocal->tx_control |= HFA384X_TX_CTRL_ALT_RTRY;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n#if 0\r\nif (rrq->flags & IW_RETRY_LIMIT) {\r\nif (rrq->flags & IW_RETRY_LONG)\r\nHFA384X_RID_LONGRETRYLIMIT = rrq->value;\r\nelse if (rrq->flags & IW_RETRY_SHORT)\r\nHFA384X_RID_SHORTRETRYLIMIT = rrq->value;\r\nelse {\r\nHFA384X_RID_LONGRETRYLIMIT = rrq->value;\r\nHFA384X_RID_SHORTRETRYLIMIT = rrq->value;\r\n}\r\n}\r\nif (rrq->flags & IW_RETRY_LIFETIME) {\r\nHFA384X_RID_MAXTRANSMITLIFETIME = rrq->value / 1024;\r\n}\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int prism2_ioctl_giwretry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n__le16 shortretry, longretry, lifetime, altretry;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->get_rid(dev, HFA384X_RID_SHORTRETRYLIMIT, &shortretry,\r\n2, 1) < 0 ||\r\nlocal->func->get_rid(dev, HFA384X_RID_LONGRETRYLIMIT, &longretry,\r\n2, 1) < 0 ||\r\nlocal->func->get_rid(dev, HFA384X_RID_MAXTRANSMITLIFETIME,\r\n&lifetime, 2, 1) < 0)\r\nreturn -EINVAL;\r\nrrq->disabled = 0;\r\nif ((rrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\r\nrrq->flags = IW_RETRY_LIFETIME;\r\nrrq->value = le16_to_cpu(lifetime) * 1024;\r\n} else {\r\nif (local->manual_retry_count >= 0) {\r\nrrq->flags = IW_RETRY_LIMIT;\r\nif (local->func->get_rid(dev,\r\nHFA384X_RID_CNFALTRETRYCOUNT,\r\n&altretry, 2, 1) >= 0)\r\nrrq->value = le16_to_cpu(altretry);\r\nelse\r\nrrq->value = local->manual_retry_count;\r\n} else if ((rrq->flags & IW_RETRY_LONG)) {\r\nrrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\nrrq->value = le16_to_cpu(longretry);\r\n} else {\r\nrrq->flags = IW_RETRY_LIMIT;\r\nrrq->value = le16_to_cpu(shortretry);\r\nif (shortretry != longretry)\r\nrrq->flags |= IW_RETRY_SHORT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_txpower_hfa386x_to_dBm(u16 val)\r\n{\r\nsigned char tmp;\r\nif (val > 255)\r\nval = 255;\r\ntmp = val;\r\ntmp >>= 2;\r\nreturn -12 - tmp;\r\n}\r\nstatic u16 prism2_txpower_dBm_to_hfa386x(int val)\r\n{\r\nsigned char tmp;\r\nif (val > 20)\r\nreturn 128;\r\nelse if (val < -43)\r\nreturn 127;\r\ntmp = val;\r\ntmp = -12 - tmp;\r\ntmp <<= 2;\r\nreturn (unsigned char) tmp;\r\n}\r\nstatic int prism2_ioctl_siwtxpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\n#ifdef RAW_TXPOWER_SETTING\r\nchar *tmp;\r\n#endif\r\nu16 val;\r\nint ret = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (rrq->disabled) {\r\nif (local->txpower_type != PRISM2_TXPOWER_OFF) {\r\nval = 0xff;\r\nret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,\r\nHFA386X_CR_A_D_TEST_MODES2,\r\n&val, NULL);\r\nprintk(KERN_DEBUG "%s: Turning radio off: %s\n",\r\ndev->name, ret ? "failed" : "OK");\r\nlocal->txpower_type = PRISM2_TXPOWER_OFF;\r\n}\r\nreturn (ret ? -EOPNOTSUPP : 0);\r\n}\r\nif (local->txpower_type == PRISM2_TXPOWER_OFF) {\r\nval = 0;\r\nret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,\r\nHFA386X_CR_A_D_TEST_MODES2, &val, NULL);\r\nprintk(KERN_DEBUG "%s: Turning radio on: %s\n",\r\ndev->name, ret ? "failed" : "OK");\r\nlocal->txpower_type = PRISM2_TXPOWER_UNKNOWN;\r\n}\r\n#ifdef RAW_TXPOWER_SETTING\r\nif (!rrq->fixed && local->txpower_type != PRISM2_TXPOWER_AUTO) {\r\nprintk(KERN_DEBUG "Setting ALC on\n");\r\nval = HFA384X_TEST_CFG_BIT_ALC;\r\nlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\r\n(HFA384X_TEST_CFG_BITS << 8), 1, &val, NULL);\r\nlocal->txpower_type = PRISM2_TXPOWER_AUTO;\r\nreturn 0;\r\n}\r\nif (local->txpower_type != PRISM2_TXPOWER_FIXED) {\r\nprintk(KERN_DEBUG "Setting ALC off\n");\r\nval = HFA384X_TEST_CFG_BIT_ALC;\r\nlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\r\n(HFA384X_TEST_CFG_BITS << 8), 0, &val, NULL);\r\nlocal->txpower_type = PRISM2_TXPOWER_FIXED;\r\n}\r\nif (rrq->flags == IW_TXPOW_DBM)\r\ntmp = "dBm";\r\nelse if (rrq->flags == IW_TXPOW_MWATT)\r\ntmp = "mW";\r\nelse\r\ntmp = "UNKNOWN";\r\nprintk(KERN_DEBUG "Setting TX power to %d %s\n", rrq->value, tmp);\r\nif (rrq->flags != IW_TXPOW_DBM) {\r\nprintk("SIOCSIWTXPOW with mW is not supported; use dBm\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nlocal->txpower = rrq->value;\r\nval = prism2_txpower_dBm_to_hfa386x(local->txpower);\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,\r\nHFA386X_CR_MANUAL_TX_POWER, &val, NULL))\r\nret = -EOPNOTSUPP;\r\n#else\r\nif (rrq->fixed)\r\nret = -EOPNOTSUPP;\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_giwtxpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq, char *extra)\r\n{\r\n#ifdef RAW_TXPOWER_SETTING\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu16 resp0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nrrq->flags = IW_TXPOW_DBM;\r\nrrq->disabled = 0;\r\nrrq->fixed = 0;\r\nif (local->txpower_type == PRISM2_TXPOWER_AUTO) {\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_READMIF,\r\nHFA386X_CR_MANUAL_TX_POWER,\r\nNULL, &resp0) == 0) {\r\nrrq->value = prism2_txpower_hfa386x_to_dBm(resp0);\r\n} else {\r\nrrq->value = 15;\r\n}\r\n} else if (local->txpower_type == PRISM2_TXPOWER_OFF) {\r\nrrq->value = 0;\r\nrrq->disabled = 1;\r\n} else if (local->txpower_type == PRISM2_TXPOWER_FIXED) {\r\nrrq->value = local->txpower;\r\nrrq->fixed = 1;\r\n} else {\r\nprintk("SIOCGIWTXPOW - unknown txpower_type=%d\n",\r\nlocal->txpower_type);\r\n}\r\nreturn 0;\r\n#else\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}\r\nstatic int prism2_request_hostscan(struct net_device *dev,\r\nu8 *ssid, u8 ssid_len)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hfa384x_hostscan_request scan_req;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmemset(&scan_req, 0, sizeof(scan_req));\r\nscan_req.channel_list = cpu_to_le16(local->channel_mask &\r\nlocal->scan_channel_mask);\r\nscan_req.txrate = cpu_to_le16(HFA384X_RATES_1MBPS);\r\nif (ssid) {\r\nif (ssid_len > 32)\r\nreturn -EINVAL;\r\nscan_req.target_ssid_len = cpu_to_le16(ssid_len);\r\nmemcpy(scan_req.target_ssid, ssid, ssid_len);\r\n}\r\nif (local->func->set_rid(dev, HFA384X_RID_HOSTSCAN, &scan_req,\r\nsizeof(scan_req))) {\r\nprintk(KERN_DEBUG "%s: HOSTSCAN failed\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_request_scan(struct net_device *dev)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct hfa384x_scan_request scan_req;\r\nint ret = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nmemset(&scan_req, 0, sizeof(scan_req));\r\nscan_req.channel_list = cpu_to_le16(local->channel_mask &\r\nlocal->scan_channel_mask);\r\nscan_req.txrate = cpu_to_le16(HFA384X_RATES_1MBPS);\r\nif (!local->host_roaming)\r\nhostap_set_word(dev, HFA384X_RID_CNFROAMINGMODE,\r\nHFA384X_ROAMING_HOST);\r\nif (local->func->set_rid(dev, HFA384X_RID_SCANREQUEST, &scan_req,\r\nsizeof(scan_req))) {\r\nprintk(KERN_DEBUG "SCANREQUEST failed\n");\r\nret = -EINVAL;\r\n}\r\nif (!local->host_roaming)\r\nhostap_set_word(dev, HFA384X_RID_CNFROAMINGMODE,\r\nHFA384X_ROAMING_FIRMWARE);\r\nreturn ret;\r\n}\r\nstatic inline int prism2_request_hostscan(struct net_device *dev,\r\nu8 *ssid, u8 ssid_len)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic inline int prism2_request_scan(struct net_device *dev)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int prism2_ioctl_siwscan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret;\r\nu8 *ssid = NULL, ssid_len = 0;\r\nstruct iw_scan_req *req = (struct iw_scan_req *) extra;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (data->length < sizeof(struct iw_scan_req))\r\nreq = NULL;\r\nif (local->iw_mode == IW_MODE_MASTER) {\r\ndata->length = 0;\r\nreturn 0;\r\n}\r\nif (!local->dev_enabled)\r\nreturn -ENETDOWN;\r\nif (req && data->flags & IW_SCAN_THIS_ESSID) {\r\nssid = req->essid;\r\nssid_len = req->essid_len;\r\nif (ssid_len &&\r\n((local->iw_mode != IW_MODE_INFRA &&\r\nlocal->iw_mode != IW_MODE_ADHOC) ||\r\n(local->sta_fw_ver < PRISM2_FW_VER(1,3,1))))\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1))\r\nret = prism2_request_hostscan(dev, ssid, ssid_len);\r\nelse\r\nret = prism2_request_scan(dev);\r\nif (ret == 0)\r\nlocal->scan_timestamp = jiffies;\r\nreturn ret;\r\n}\r\nstatic char * __prism2_translate_scan(local_info_t *local,\r\nstruct iw_request_info *info,\r\nstruct hfa384x_hostscan_result *scan,\r\nstruct hostap_bss_info *bss,\r\nchar *current_ev, char *end_buf)\r\n{\r\nint i, chan;\r\nstruct iw_event iwe;\r\nchar *current_val;\r\nu16 capabilities;\r\nu8 *pos;\r\nu8 *ssid, *bssid;\r\nsize_t ssid_len;\r\nchar *buf;\r\nif (bss) {\r\nssid = bss->ssid;\r\nssid_len = bss->ssid_len;\r\nbssid = bss->bssid;\r\n} else {\r\nssid = scan->ssid;\r\nssid_len = le16_to_cpu(scan->ssid_len);\r\nbssid = scan->bssid;\r\n}\r\nif (ssid_len > 32)\r\nssid_len = 32;\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, bssid, ETH_ALEN);\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe,\r\nIW_EV_ADDR_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.length = ssid_len;\r\niwe.u.data.flags = 1;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, ssid);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWMODE;\r\nif (bss) {\r\ncapabilities = bss->capab_info;\r\n} else {\r\ncapabilities = le16_to_cpu(scan->capability);\r\n}\r\nif (capabilities & (WLAN_CAPABILITY_ESS |\r\nWLAN_CAPABILITY_IBSS)) {\r\nif (capabilities & WLAN_CAPABILITY_ESS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_UINT_LEN);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWFREQ;\r\nif (scan) {\r\nchan = le16_to_cpu(scan->chid);\r\n} else if (bss) {\r\nchan = bss->chan;\r\n} else {\r\nchan = 0;\r\n}\r\nif (chan > 0) {\r\niwe.u.freq.m = freq_list[chan - 1] * 100000;\r\niwe.u.freq.e = 1;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_FREQ_LEN);\r\n}\r\nif (scan) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVQUAL;\r\nif (local->last_scan_type == PRISM2_HOSTSCAN) {\r\niwe.u.qual.level = le16_to_cpu(scan->sl);\r\niwe.u.qual.noise = le16_to_cpu(scan->anl);\r\n} else {\r\niwe.u.qual.level =\r\nHFA384X_LEVEL_TO_dBm(le16_to_cpu(scan->sl));\r\niwe.u.qual.noise =\r\nHFA384X_LEVEL_TO_dBm(le16_to_cpu(scan->anl));\r\n}\r\niwe.u.qual.updated = IW_QUAL_LEVEL_UPDATED\r\n| IW_QUAL_NOISE_UPDATED\r\n| IW_QUAL_QUAL_INVALID\r\n| IW_QUAL_DBM;\r\ncurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\r\n&iwe, IW_EV_QUAL_LEN);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWENCODE;\r\nif (capabilities & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, "");\r\nif (scan) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWRATE;\r\ncurrent_val = current_ev + iwe_stream_lcp_len(info);\r\npos = scan->sup_rates;\r\nfor (i = 0; i < sizeof(scan->sup_rates); i++) {\r\nif (pos[i] == 0)\r\nbreak;\r\niwe.u.bitrate.value = ((pos[i] & 0x7f) * 500000);\r\ncurrent_val = iwe_stream_add_value(\r\ninfo, current_ev, current_val, end_buf, &iwe,\r\nIW_EV_PARAM_LEN);\r\n}\r\nif ((current_val - current_ev) > iwe_stream_lcp_len(info))\r\ncurrent_ev = current_val;\r\n}\r\nbuf = kmalloc(MAX_WPA_IE_LEN * 2 + 30, GFP_ATOMIC);\r\nif (buf && scan) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf(buf, "bcn_int=%d", le16_to_cpu(scan->beacon_interval));\r\niwe.u.data.length = strlen(buf);\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, buf);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf(buf, "resp_rate=%d", le16_to_cpu(scan->rate));\r\niwe.u.data.length = strlen(buf);\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, buf);\r\nif (local->last_scan_type == PRISM2_HOSTSCAN &&\r\n(capabilities & WLAN_CAPABILITY_IBSS)) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf(buf, "atim=%d", le16_to_cpu(scan->atim));\r\niwe.u.data.length = strlen(buf);\r\ncurrent_ev = iwe_stream_add_point(info, current_ev,\r\nend_buf, &iwe, buf);\r\n}\r\n}\r\nkfree(buf);\r\nif (bss && bss->wpa_ie_len > 0 && bss->wpa_ie_len <= MAX_WPA_IE_LEN) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = bss->wpa_ie_len;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, bss->wpa_ie);\r\n}\r\nif (bss && bss->rsn_ie_len > 0 && bss->rsn_ie_len <= MAX_WPA_IE_LEN) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = bss->rsn_ie_len;\r\ncurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\r\n&iwe, bss->rsn_ie);\r\n}\r\nreturn current_ev;\r\n}\r\nstatic inline int prism2_translate_scan(local_info_t *local,\r\nstruct iw_request_info *info,\r\nchar *buffer, int buflen)\r\n{\r\nstruct hfa384x_hostscan_result *scan;\r\nint entry, hostscan;\r\nchar *current_ev = buffer;\r\nchar *end_buf = buffer + buflen;\r\nstruct list_head *ptr;\r\nspin_lock_bh(&local->lock);\r\nlist_for_each(ptr, &local->bss_list) {\r\nstruct hostap_bss_info *bss;\r\nbss = list_entry(ptr, struct hostap_bss_info, list);\r\nbss->included = 0;\r\n}\r\nhostscan = local->last_scan_type == PRISM2_HOSTSCAN;\r\nfor (entry = 0; entry < local->last_scan_results_count; entry++) {\r\nint found = 0;\r\nscan = &local->last_scan_results[entry];\r\nlist_for_each(ptr, &local->bss_list) {\r\nstruct hostap_bss_info *bss;\r\nbss = list_entry(ptr, struct hostap_bss_info, list);\r\nif (memcmp(bss->bssid, scan->bssid, ETH_ALEN) == 0) {\r\nbss->included = 1;\r\ncurrent_ev = __prism2_translate_scan(\r\nlocal, info, scan, bss, current_ev,\r\nend_buf);\r\nfound++;\r\n}\r\n}\r\nif (!found) {\r\ncurrent_ev = __prism2_translate_scan(\r\nlocal, info, scan, NULL, current_ev, end_buf);\r\n}\r\nif ((end_buf - current_ev) <= IW_EV_ADDR_LEN) {\r\nspin_unlock_bh(&local->lock);\r\nreturn -E2BIG;\r\n}\r\n}\r\nlist_for_each(ptr, &local->bss_list) {\r\nstruct hostap_bss_info *bss;\r\nbss = list_entry(ptr, struct hostap_bss_info, list);\r\nif (bss->included)\r\ncontinue;\r\ncurrent_ev = __prism2_translate_scan(local, info, NULL, bss,\r\ncurrent_ev, end_buf);\r\nif ((end_buf - current_ev) <= IW_EV_ADDR_LEN) {\r\nspin_unlock_bh(&local->lock);\r\nreturn -E2BIG;\r\n}\r\n}\r\nspin_unlock_bh(&local->lock);\r\nreturn current_ev - buffer;\r\n}\r\nstatic inline int prism2_ioctl_giwscan_sta(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\n#ifdef PRISM2_NO_STATION_MODES\r\nreturn -EOPNOTSUPP;\r\n#else\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint res;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->scan_timestamp &&\r\ntime_before(jiffies, local->scan_timestamp + 3 * HZ)) {\r\nreturn -EAGAIN;\r\n}\r\nlocal->scan_timestamp = 0;\r\nres = prism2_translate_scan(local, info, extra, data->length);\r\nif (res >= 0) {\r\ndata->length = res;\r\nreturn 0;\r\n} else {\r\ndata->length = 0;\r\nreturn res;\r\n}\r\n#endif\r\n}\r\nstatic int prism2_ioctl_giwscan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint res;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->iw_mode == IW_MODE_MASTER) {\r\nres = prism2_ap_translate_scan(dev, info, extra);\r\nif (res >= 0) {\r\nprintk(KERN_DEBUG "Scan result translation succeeded "\r\n"(length=%d)\n", res);\r\ndata->length = res;\r\nreturn 0;\r\n} else {\r\nprintk(KERN_DEBUG\r\n"Scan result translation failed (res=%d)\n",\r\nres);\r\ndata->length = 0;\r\nreturn res;\r\n}\r\n} else {\r\nreturn prism2_ioctl_giwscan_sta(dev, info, data, extra);\r\n}\r\n}\r\nstatic int prism2_ioctl_priv_inquire(struct net_device *dev, int *i)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_INQUIRE, *i, NULL, NULL))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_priv_prism2_param(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint *i = (int *) extra;\r\nint param = *i;\r\nint value = *(i + 1);\r\nint ret = 0;\r\nu16 val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nswitch (param) {\r\ncase PRISM2_PARAM_TXRATECTRL:\r\nlocal->fw_tx_rate_control = value;\r\nbreak;\r\ncase PRISM2_PARAM_BEACON_INT:\r\nif (hostap_set_word(dev, HFA384X_RID_CNFBEACONINT, value) ||\r\nlocal->func->reset_port(dev))\r\nret = -EINVAL;\r\nelse\r\nlocal->beacon_int = value;\r\nbreak;\r\n#ifndef PRISM2_NO_STATION_MODES\r\ncase PRISM2_PARAM_PSEUDO_IBSS:\r\nif (value == local->pseudo_adhoc)\r\nbreak;\r\nif (value != 0 && value != 1) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nprintk(KERN_DEBUG "prism2: %s: pseudo IBSS change %d -> %d\n",\r\ndev->name, local->pseudo_adhoc, value);\r\nlocal->pseudo_adhoc = value;\r\nif (local->iw_mode != IW_MODE_ADHOC)\r\nbreak;\r\nif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\r\nhostap_get_porttype(local))) {\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (local->func->reset_port(dev))\r\nret = -EINVAL;\r\nbreak;\r\n#endif\r\ncase PRISM2_PARAM_ALC:\r\nprintk(KERN_DEBUG "%s: %s ALC\n", dev->name,\r\nvalue == 0 ? "Disabling" : "Enabling");\r\nval = HFA384X_TEST_CFG_BIT_ALC;\r\nlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\r\n(HFA384X_TEST_CFG_BITS << 8),\r\nvalue == 0 ? 0 : 1, &val, NULL);\r\nbreak;\r\ncase PRISM2_PARAM_DUMP:\r\nlocal->frame_dump = value;\r\nbreak;\r\ncase PRISM2_PARAM_OTHER_AP_POLICY:\r\nif (value < 0 || value > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (local->ap != NULL)\r\nlocal->ap->ap_policy = value;\r\nbreak;\r\ncase PRISM2_PARAM_AP_MAX_INACTIVITY:\r\nif (value < 0 || value > 7 * 24 * 60 * 60) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (local->ap != NULL)\r\nlocal->ap->max_inactivity = value * HZ;\r\nbreak;\r\ncase PRISM2_PARAM_AP_BRIDGE_PACKETS:\r\nif (local->ap != NULL)\r\nlocal->ap->bridge_packets = value;\r\nbreak;\r\ncase PRISM2_PARAM_DTIM_PERIOD:\r\nif (value < 0 || value > 65535) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (hostap_set_word(dev, HFA384X_RID_CNFOWNDTIMPERIOD, value)\r\n|| local->func->reset_port(dev))\r\nret = -EINVAL;\r\nelse\r\nlocal->dtim_period = value;\r\nbreak;\r\ncase PRISM2_PARAM_AP_NULLFUNC_ACK:\r\nif (local->ap != NULL)\r\nlocal->ap->nullfunc_ack = value;\r\nbreak;\r\ncase PRISM2_PARAM_MAX_WDS:\r\nlocal->wds_max_connections = value;\r\nbreak;\r\ncase PRISM2_PARAM_AP_AUTOM_AP_WDS:\r\nif (local->ap != NULL) {\r\nif (!local->ap->autom_ap_wds && value) {\r\nhostap_add_wds_links(local);\r\n}\r\nlocal->ap->autom_ap_wds = value;\r\n}\r\nbreak;\r\ncase PRISM2_PARAM_AP_AUTH_ALGS:\r\nlocal->auth_algs = value;\r\nif (hostap_set_auth_algs(local))\r\nret = -EINVAL;\r\nbreak;\r\ncase PRISM2_PARAM_MONITOR_ALLOW_FCSERR:\r\nlocal->monitor_allow_fcserr = value;\r\nbreak;\r\ncase PRISM2_PARAM_HOST_ENCRYPT:\r\nlocal->host_encrypt = value;\r\nif (hostap_set_encryption(local) ||\r\nlocal->func->reset_port(dev))\r\nret = -EINVAL;\r\nbreak;\r\ncase PRISM2_PARAM_HOST_DECRYPT:\r\nlocal->host_decrypt = value;\r\nif (hostap_set_encryption(local) ||\r\nlocal->func->reset_port(dev))\r\nret = -EINVAL;\r\nbreak;\r\n#ifndef PRISM2_NO_STATION_MODES\r\ncase PRISM2_PARAM_HOST_ROAMING:\r\nif (value < 0 || value > 2) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal->host_roaming = value;\r\nif (hostap_set_roaming(local) || local->func->reset_port(dev))\r\nret = -EINVAL;\r\nbreak;\r\n#endif\r\ncase PRISM2_PARAM_BCRX_STA_KEY:\r\nlocal->bcrx_sta_key = value;\r\nbreak;\r\ncase PRISM2_PARAM_IEEE_802_1X:\r\nlocal->ieee_802_1x = value;\r\nbreak;\r\ncase PRISM2_PARAM_ANTSEL_TX:\r\nif (value < 0 || value > HOSTAP_ANTSEL_HIGH) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal->antsel_tx = value;\r\nhostap_set_antsel(local);\r\nbreak;\r\ncase PRISM2_PARAM_ANTSEL_RX:\r\nif (value < 0 || value > HOSTAP_ANTSEL_HIGH) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal->antsel_rx = value;\r\nhostap_set_antsel(local);\r\nbreak;\r\ncase PRISM2_PARAM_MONITOR_TYPE:\r\nif (value != PRISM2_MONITOR_80211 &&\r\nvalue != PRISM2_MONITOR_CAPHDR &&\r\nvalue != PRISM2_MONITOR_PRISM &&\r\nvalue != PRISM2_MONITOR_RADIOTAP) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal->monitor_type = value;\r\nif (local->iw_mode == IW_MODE_MONITOR)\r\nhostap_monitor_set_type(local);\r\nbreak;\r\ncase PRISM2_PARAM_WDS_TYPE:\r\nlocal->wds_type = value;\r\nbreak;\r\ncase PRISM2_PARAM_HOSTSCAN:\r\n{\r\nstruct hfa384x_hostscan_request scan_req;\r\nu16 rate;\r\nmemset(&scan_req, 0, sizeof(scan_req));\r\nscan_req.channel_list = cpu_to_le16(0x3fff);\r\nswitch (value) {\r\ncase 1: rate = HFA384X_RATES_1MBPS; break;\r\ncase 2: rate = HFA384X_RATES_2MBPS; break;\r\ncase 3: rate = HFA384X_RATES_5MBPS; break;\r\ncase 4: rate = HFA384X_RATES_11MBPS; break;\r\ndefault: rate = HFA384X_RATES_1MBPS; break;\r\n}\r\nscan_req.txrate = cpu_to_le16(rate);\r\nif (local->iw_mode == IW_MODE_MASTER) {\r\nif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\r\nHFA384X_PORTTYPE_BSS) ||\r\nlocal->func->reset_port(dev))\r\nprintk(KERN_DEBUG "Leaving Host AP mode "\r\n"for HostScan failed\n");\r\n}\r\nif (local->func->set_rid(dev, HFA384X_RID_HOSTSCAN, &scan_req,\r\nsizeof(scan_req))) {\r\nprintk(KERN_DEBUG "HOSTSCAN failed\n");\r\nret = -EINVAL;\r\n}\r\nif (local->iw_mode == IW_MODE_MASTER) {\r\nwait_queue_t __wait;\r\ninit_waitqueue_entry(&__wait, current);\r\nadd_wait_queue(&local->hostscan_wq, &__wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\nif (signal_pending(current))\r\nret = -EINTR;\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&local->hostscan_wq, &__wait);\r\nif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\r\nHFA384X_PORTTYPE_HOSTAP) ||\r\nlocal->func->reset_port(dev))\r\nprintk(KERN_DEBUG "Returning to Host AP mode "\r\n"after HostScan failed\n");\r\n}\r\nbreak;\r\n}\r\ncase PRISM2_PARAM_AP_SCAN:\r\nlocal->passive_scan_interval = value;\r\nif (timer_pending(&local->passive_scan_timer))\r\ndel_timer(&local->passive_scan_timer);\r\nif (value > 0) {\r\nlocal->passive_scan_timer.expires = jiffies +\r\nlocal->passive_scan_interval * HZ;\r\nadd_timer(&local->passive_scan_timer);\r\n}\r\nbreak;\r\ncase PRISM2_PARAM_ENH_SEC:\r\nif (value < 0 || value > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal->enh_sec = value;\r\nif (hostap_set_word(dev, HFA384X_RID_CNFENHSECURITY,\r\nlocal->enh_sec) ||\r\nlocal->func->reset_port(dev)) {\r\nprintk(KERN_INFO "%s: cnfEnhSecurity requires STA f/w "\r\n"1.6.3 or newer\n", dev->name);\r\nret = -EOPNOTSUPP;\r\n}\r\nbreak;\r\n#ifdef PRISM2_IO_DEBUG\r\ncase PRISM2_PARAM_IO_DEBUG:\r\nlocal->io_debug_enabled = value;\r\nbreak;\r\n#endif\r\ncase PRISM2_PARAM_BASIC_RATES:\r\nif ((value & local->tx_rate_control) != value || value == 0) {\r\nprintk(KERN_INFO "%s: invalid basic rate set - basic "\r\n"rates must be in supported rate set\n",\r\ndev->name);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlocal->basic_rates = value;\r\nif (hostap_set_word(dev, HFA384X_RID_CNFBASICRATES,\r\nlocal->basic_rates) ||\r\nlocal->func->reset_port(dev))\r\nret = -EINVAL;\r\nbreak;\r\ncase PRISM2_PARAM_OPER_RATES:\r\nlocal->tx_rate_control = value;\r\nif (hostap_set_rate(dev))\r\nret = -EINVAL;\r\nbreak;\r\ncase PRISM2_PARAM_HOSTAPD:\r\nret = hostap_set_hostapd(local, value, 1);\r\nbreak;\r\ncase PRISM2_PARAM_HOSTAPD_STA:\r\nret = hostap_set_hostapd_sta(local, value, 1);\r\nbreak;\r\ncase PRISM2_PARAM_WPA:\r\nlocal->wpa = value;\r\nif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\r\nret = -EOPNOTSUPP;\r\nelse if (hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE,\r\nvalue ? 1 : 0))\r\nret = -EINVAL;\r\nbreak;\r\ncase PRISM2_PARAM_PRIVACY_INVOKED:\r\nlocal->privacy_invoked = value;\r\nif (hostap_set_encryption(local) ||\r\nlocal->func->reset_port(dev))\r\nret = -EINVAL;\r\nbreak;\r\ncase PRISM2_PARAM_TKIP_COUNTERMEASURES:\r\nlocal->tkip_countermeasures = value;\r\nbreak;\r\ncase PRISM2_PARAM_DROP_UNENCRYPTED:\r\nlocal->drop_unencrypted = value;\r\nbreak;\r\ncase PRISM2_PARAM_SCAN_CHANNEL_MASK:\r\nlocal->scan_channel_mask = value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "%s: prism2_param: unknown param %d\n",\r\ndev->name, param);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_priv_get_prism2_param(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint *param = (int *) extra;\r\nint ret = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nswitch (*param) {\r\ncase PRISM2_PARAM_TXRATECTRL:\r\n*param = local->fw_tx_rate_control;\r\nbreak;\r\ncase PRISM2_PARAM_BEACON_INT:\r\n*param = local->beacon_int;\r\nbreak;\r\ncase PRISM2_PARAM_PSEUDO_IBSS:\r\n*param = local->pseudo_adhoc;\r\nbreak;\r\ncase PRISM2_PARAM_ALC:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_DUMP:\r\n*param = local->frame_dump;\r\nbreak;\r\ncase PRISM2_PARAM_OTHER_AP_POLICY:\r\nif (local->ap != NULL)\r\n*param = local->ap->ap_policy;\r\nelse\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_AP_MAX_INACTIVITY:\r\nif (local->ap != NULL)\r\n*param = local->ap->max_inactivity / HZ;\r\nelse\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_AP_BRIDGE_PACKETS:\r\nif (local->ap != NULL)\r\n*param = local->ap->bridge_packets;\r\nelse\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_DTIM_PERIOD:\r\n*param = local->dtim_period;\r\nbreak;\r\ncase PRISM2_PARAM_AP_NULLFUNC_ACK:\r\nif (local->ap != NULL)\r\n*param = local->ap->nullfunc_ack;\r\nelse\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_MAX_WDS:\r\n*param = local->wds_max_connections;\r\nbreak;\r\ncase PRISM2_PARAM_AP_AUTOM_AP_WDS:\r\nif (local->ap != NULL)\r\n*param = local->ap->autom_ap_wds;\r\nelse\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_AP_AUTH_ALGS:\r\n*param = local->auth_algs;\r\nbreak;\r\ncase PRISM2_PARAM_MONITOR_ALLOW_FCSERR:\r\n*param = local->monitor_allow_fcserr;\r\nbreak;\r\ncase PRISM2_PARAM_HOST_ENCRYPT:\r\n*param = local->host_encrypt;\r\nbreak;\r\ncase PRISM2_PARAM_HOST_DECRYPT:\r\n*param = local->host_decrypt;\r\nbreak;\r\ncase PRISM2_PARAM_HOST_ROAMING:\r\n*param = local->host_roaming;\r\nbreak;\r\ncase PRISM2_PARAM_BCRX_STA_KEY:\r\n*param = local->bcrx_sta_key;\r\nbreak;\r\ncase PRISM2_PARAM_IEEE_802_1X:\r\n*param = local->ieee_802_1x;\r\nbreak;\r\ncase PRISM2_PARAM_ANTSEL_TX:\r\n*param = local->antsel_tx;\r\nbreak;\r\ncase PRISM2_PARAM_ANTSEL_RX:\r\n*param = local->antsel_rx;\r\nbreak;\r\ncase PRISM2_PARAM_MONITOR_TYPE:\r\n*param = local->monitor_type;\r\nbreak;\r\ncase PRISM2_PARAM_WDS_TYPE:\r\n*param = local->wds_type;\r\nbreak;\r\ncase PRISM2_PARAM_HOSTSCAN:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase PRISM2_PARAM_AP_SCAN:\r\n*param = local->passive_scan_interval;\r\nbreak;\r\ncase PRISM2_PARAM_ENH_SEC:\r\n*param = local->enh_sec;\r\nbreak;\r\n#ifdef PRISM2_IO_DEBUG\r\ncase PRISM2_PARAM_IO_DEBUG:\r\n*param = local->io_debug_enabled;\r\nbreak;\r\n#endif\r\ncase PRISM2_PARAM_BASIC_RATES:\r\n*param = local->basic_rates;\r\nbreak;\r\ncase PRISM2_PARAM_OPER_RATES:\r\n*param = local->tx_rate_control;\r\nbreak;\r\ncase PRISM2_PARAM_HOSTAPD:\r\n*param = local->hostapd;\r\nbreak;\r\ncase PRISM2_PARAM_HOSTAPD_STA:\r\n*param = local->hostapd_sta;\r\nbreak;\r\ncase PRISM2_PARAM_WPA:\r\nif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\r\nret = -EOPNOTSUPP;\r\n*param = local->wpa;\r\nbreak;\r\ncase PRISM2_PARAM_PRIVACY_INVOKED:\r\n*param = local->privacy_invoked;\r\nbreak;\r\ncase PRISM2_PARAM_TKIP_COUNTERMEASURES:\r\n*param = local->tkip_countermeasures;\r\nbreak;\r\ncase PRISM2_PARAM_DROP_UNENCRYPTED:\r\n*param = local->drop_unencrypted;\r\nbreak;\r\ncase PRISM2_PARAM_SCAN_CHANNEL_MASK:\r\n*param = local->scan_channel_mask;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "%s: get_prism2_param: unknown param %d\n",\r\ndev->name, *param);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_priv_readmif(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu16 resp0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_READMIF, *extra, NULL,\r\n&resp0))\r\nreturn -EOPNOTSUPP;\r\nelse\r\n*extra = resp0;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_priv_writemif(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu, char *extra)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nu16 cr, val;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\ncr = *extra;\r\nval = *(extra + 1);\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF, cr, &val, NULL))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_priv_monitor(struct net_device *dev, int *i)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret = 0;\r\nu32 mode;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nprintk(KERN_DEBUG "%s: process %d (%s) used deprecated iwpriv monitor "\r\n"- update software to use iwconfig mode monitor\n",\r\ndev->name, task_pid_nr(current), current->comm);\r\nif (*i == 0) {\r\nmode = IW_MODE_MASTER;\r\nret = prism2_ioctl_siwmode(dev, NULL, &mode, NULL);\r\n} else if (*i == 1) {\r\nret = -EOPNOTSUPP;\r\n} else if (*i == 2 || *i == 3) {\r\nswitch (*i) {\r\ncase 2:\r\nlocal->monitor_type = PRISM2_MONITOR_80211;\r\nbreak;\r\ncase 3:\r\nlocal->monitor_type = PRISM2_MONITOR_PRISM;\r\nbreak;\r\n}\r\nmode = IW_MODE_MONITOR;\r\nret = prism2_ioctl_siwmode(dev, NULL, &mode, NULL);\r\nhostap_monitor_mode_enable(local);\r\n} else\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_priv_reset(struct net_device *dev, int *i)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nprintk(KERN_DEBUG "%s: manual reset request(%d)\n", dev->name, *i);\r\nswitch (*i) {\r\ncase 0:\r\nlocal->func->hw_shutdown(dev, 1);\r\nlocal->func->hw_config(dev, 0);\r\nbreak;\r\ncase 1:\r\nlocal->func->hw_reset(dev);\r\nbreak;\r\ncase 2:\r\nlocal->func->reset_port(dev);\r\nbreak;\r\ncase 3:\r\nprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_DISABLE, 0, NULL,\r\nNULL))\r\nreturn -EINVAL;\r\nbreak;\r\ncase 4:\r\nif (local->func->cmd(dev, HFA384X_CMDCODE_ENABLE, 0, NULL,\r\nNULL))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "Unknown reset request %d\n", *i);\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_priv_set_rid_word(struct net_device *dev, int *i)\r\n{\r\nint rid = *i;\r\nint value = *(i + 1);\r\nprintk(KERN_DEBUG "%s: Set RID[0x%X] = %d\n", dev->name, rid, value);\r\nif (hostap_set_word(dev, rid, value))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ap_mac_cmd_ioctl(local_info_t *local, int *cmd)\r\n{\r\nint ret = 0;\r\nswitch (*cmd) {\r\ncase AP_MAC_CMD_POLICY_OPEN:\r\nlocal->ap->mac_restrictions.policy = MAC_POLICY_OPEN;\r\nbreak;\r\ncase AP_MAC_CMD_POLICY_ALLOW:\r\nlocal->ap->mac_restrictions.policy = MAC_POLICY_ALLOW;\r\nbreak;\r\ncase AP_MAC_CMD_POLICY_DENY:\r\nlocal->ap->mac_restrictions.policy = MAC_POLICY_DENY;\r\nbreak;\r\ncase AP_MAC_CMD_FLUSH:\r\nap_control_flush_macs(&local->ap->mac_restrictions);\r\nbreak;\r\ncase AP_MAC_CMD_KICKALL:\r\nap_control_kickall(local->ap);\r\nhostap_deauth_all_stas(local->dev, local->ap, 0);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_priv_download(local_info_t *local, struct iw_point *p)\r\n{\r\nstruct prism2_download_param *param;\r\nint ret = 0;\r\nif (p->length < sizeof(struct prism2_download_param) ||\r\np->length > 1024 || !p->pointer)\r\nreturn -EINVAL;\r\nparam = kmalloc(p->length, GFP_KERNEL);\r\nif (param == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(param, p->pointer, p->length)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (p->length < sizeof(struct prism2_download_param) +\r\nparam->num_areas * sizeof(struct prism2_download_area)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = local->func->download(local, param);\r\nout:\r\nkfree(param);\r\nreturn ret;\r\n}\r\nstatic int prism2_set_genericelement(struct net_device *dev, u8 *elem,\r\nsize_t len)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nu8 *buf;\r\nbuf = kmalloc(len + 2, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\n*((__le16 *) buf) = cpu_to_le16(len);\r\nmemcpy(buf + 2, elem, len);\r\nkfree(local->generic_elem);\r\nlocal->generic_elem = buf;\r\nlocal->generic_elem_len = len + 2;\r\nreturn local->func->set_rid(local->dev, HFA384X_RID_GENERICELEMENT,\r\nbuf, len + 2);\r\n}\r\nstatic int prism2_ioctl_siwauth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nswitch (data->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nlocal->tkip_countermeasures = data->value;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nlocal->drop_unencrypted = data->value;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nlocal->auth_algs = data->value;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nif (data->value == 0) {\r\nlocal->wpa = 0;\r\nif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\r\nbreak;\r\nprism2_set_genericelement(dev, "", 0);\r\nlocal->host_roaming = 0;\r\nlocal->privacy_invoked = 0;\r\nif (hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE,\r\n0) ||\r\nhostap_set_roaming(local) ||\r\nhostap_set_encryption(local) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\r\nreturn -EOPNOTSUPP;\r\nlocal->host_roaming = 2;\r\nlocal->privacy_invoked = 1;\r\nlocal->wpa = 1;\r\nif (hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE, 1) ||\r\nhostap_set_roaming(local) ||\r\nhostap_set_encryption(local) ||\r\nlocal->func->reset_port(dev))\r\nreturn -EINVAL;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nlocal->ieee_802_1x = data->value;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nlocal->privacy_invoked = data->value;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_giwauth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nswitch (data->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nreturn -EOPNOTSUPP;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\ndata->value = local->tkip_countermeasures;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\ndata->value = local->drop_unencrypted;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\ndata->value = local->auth_algs;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\ndata->value = local->wpa;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\ndata->value = local->ieee_802_1x;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwencodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *extra)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\r\nint i, ret = 0;\r\nstruct lib80211_crypto_ops *ops;\r\nstruct lib80211_crypt_data **crypt;\r\nvoid *sta_ptr;\r\nu8 *addr;\r\nconst char *alg, *module;\r\ni = erq->flags & IW_ENCODE_INDEX;\r\nif (i > WEP_KEYS)\r\nreturn -EINVAL;\r\nif (i < 1 || i > WEP_KEYS)\r\ni = local->crypt_info.tx_keyidx;\r\nelse\r\ni--;\r\nif (i < 0 || i >= WEP_KEYS)\r\nreturn -EINVAL;\r\naddr = ext->addr.sa_data;\r\nif (is_broadcast_ether_addr(addr)) {\r\nsta_ptr = NULL;\r\ncrypt = &local->crypt_info.crypt[i];\r\n} else {\r\nif (i != 0)\r\nreturn -EINVAL;\r\nsta_ptr = ap_crypt_get_ptrs(local->ap, addr, 0, &crypt);\r\nif (sta_ptr == NULL) {\r\nif (local->iw_mode == IW_MODE_INFRA) {\r\ni = 0;\r\ncrypt = &local->crypt_info.crypt[i];\r\n} else\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((erq->flags & IW_ENCODE_DISABLED) ||\r\next->alg == IW_ENCODE_ALG_NONE) {\r\nif (*crypt)\r\nlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\r\ngoto done;\r\n}\r\nswitch (ext->alg) {\r\ncase IW_ENCODE_ALG_WEP:\r\nalg = "WEP";\r\nmodule = "lib80211_crypt_wep";\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg = "TKIP";\r\nmodule = "lib80211_crypt_tkip";\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg = "CCMP";\r\nmodule = "lib80211_crypt_ccmp";\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "%s: unsupported algorithm %d\n",\r\nlocal->dev->name, ext->alg);\r\nret = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nops = lib80211_get_crypto_ops(alg);\r\nif (ops == NULL) {\r\nrequest_module(module);\r\nops = lib80211_get_crypto_ops(alg);\r\n}\r\nif (ops == NULL) {\r\nprintk(KERN_DEBUG "%s: unknown crypto alg '%s'\n",\r\nlocal->dev->name, alg);\r\nret = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nif (sta_ptr || ext->alg != IW_ENCODE_ALG_WEP) {\r\nlocal->host_decrypt = local->host_encrypt = 1;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\r\nnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\r\nGFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(i);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif ((!(ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) || ext->key_len > 0)\r\n&& (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\r\n(*crypt)->priv) < 0) {\r\nprintk(KERN_DEBUG "%s: key setting failed\n",\r\nlocal->dev->name);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\nif (!sta_ptr)\r\nlocal->crypt_info.tx_keyidx = i;\r\n}\r\nif (sta_ptr == NULL && ext->key_len > 0) {\r\nint first = 1, j;\r\nfor (j = 0; j < WEP_KEYS; j++) {\r\nif (j != i && local->crypt_info.crypt[j]) {\r\nfirst = 0;\r\nbreak;\r\n}\r\n}\r\nif (first)\r\nlocal->crypt_info.tx_keyidx = i;\r\n}\r\ndone:\r\nif (sta_ptr)\r\nhostap_handle_sta_release(sta_ptr);\r\nlocal->open_wep = erq->flags & IW_ENCODE_OPEN;\r\nif (ret == 0 &&\r\n(hostap_set_encryption(local) ||\r\n(local->iw_mode != IW_MODE_INFRA &&\r\nlocal->func->reset_port(local->dev))))\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_giwencodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq, char *extra)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nstruct lib80211_crypt_data **crypt;\r\nvoid *sta_ptr;\r\nint max_key_len, i;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\r\nu8 *addr;\r\nmax_key_len = erq->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\ni = erq->flags & IW_ENCODE_INDEX;\r\nif (i < 1 || i > WEP_KEYS)\r\ni = local->crypt_info.tx_keyidx;\r\nelse\r\ni--;\r\naddr = ext->addr.sa_data;\r\nif (is_broadcast_ether_addr(addr)) {\r\nsta_ptr = NULL;\r\ncrypt = &local->crypt_info.crypt[i];\r\n} else {\r\ni = 0;\r\nsta_ptr = ap_crypt_get_ptrs(local->ap, addr, 0, &crypt);\r\nif (sta_ptr == NULL)\r\nreturn -EINVAL;\r\n}\r\nerq->flags = i + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nif (*crypt == NULL || (*crypt)->ops == NULL) {\r\next->alg = IW_ENCODE_ALG_NONE;\r\next->key_len = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\n} else {\r\nif (strcmp((*crypt)->ops->name, "WEP") == 0)\r\next->alg = IW_ENCODE_ALG_WEP;\r\nelse if (strcmp((*crypt)->ops->name, "TKIP") == 0)\r\next->alg = IW_ENCODE_ALG_TKIP;\r\nelse if (strcmp((*crypt)->ops->name, "CCMP") == 0)\r\next->alg = IW_ENCODE_ALG_CCMP;\r\nelse\r\nreturn -EINVAL;\r\nif ((*crypt)->ops->get_key) {\r\next->key_len =\r\n(*crypt)->ops->get_key(ext->key,\r\nmax_key_len,\r\next->tx_seq,\r\n(*crypt)->priv);\r\nif (ext->key_len &&\r\n(ext->alg == IW_ENCODE_ALG_TKIP ||\r\next->alg == IW_ENCODE_ALG_CCMP))\r\next->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;\r\n}\r\n}\r\nif (sta_ptr)\r\nhostap_handle_sta_release(sta_ptr);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_set_encryption(local_info_t *local,\r\nstruct prism2_hostapd_param *param,\r\nint param_len)\r\n{\r\nint ret = 0;\r\nstruct lib80211_crypto_ops *ops;\r\nstruct lib80211_crypt_data **crypt;\r\nvoid *sta_ptr;\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[HOSTAP_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len !=\r\n(int) ((char *) param->u.crypt.key - (char *) param) +\r\nparam->u.crypt.key_len)\r\nreturn -EINVAL;\r\nif (is_broadcast_ether_addr(param->sta_addr)) {\r\nif (param->u.crypt.idx >= WEP_KEYS)\r\nreturn -EINVAL;\r\nsta_ptr = NULL;\r\ncrypt = &local->crypt_info.crypt[param->u.crypt.idx];\r\n} else {\r\nif (param->u.crypt.idx)\r\nreturn -EINVAL;\r\nsta_ptr = ap_crypt_get_ptrs(\r\nlocal->ap, param->sta_addr,\r\n(param->u.crypt.flags & HOSTAP_CRYPT_FLAG_PERMANENT),\r\n&crypt);\r\nif (sta_ptr == NULL) {\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ADDR;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strcmp(param->u.crypt.alg, "none") == 0) {\r\nif (crypt)\r\nlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\r\ngoto done;\r\n}\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\nif (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nrequest_module("lib80211_crypt_wep");\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\n} else if (ops == NULL && strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nrequest_module("lib80211_crypt_tkip");\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\n} else if (ops == NULL && strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\nrequest_module("lib80211_crypt_ccmp");\r\nops = lib80211_get_crypto_ops(param->u.crypt.alg);\r\n}\r\nif (ops == NULL) {\r\nprintk(KERN_DEBUG "%s: unknown crypto alg '%s'\n",\r\nlocal->dev->name, param->u.crypt.alg);\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ALG;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nlocal->host_decrypt = local->host_encrypt = 1;\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\r\nnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\r\nGFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nnew_crypt->ops = ops;\r\nnew_crypt->priv = new_crypt->ops->init(param->u.crypt.idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nparam->u.crypt.err =\r\nHOSTAP_CRYPT_ERR_CRYPT_INIT_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif ((!(param->u.crypt.flags & HOSTAP_CRYPT_FLAG_SET_TX_KEY) ||\r\nparam->u.crypt.key_len > 0) && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(param->u.crypt.key,\r\nparam->u.crypt.key_len, param->u.crypt.seq,\r\n(*crypt)->priv) < 0) {\r\nprintk(KERN_DEBUG "%s: key setting failed\n",\r\nlocal->dev->name);\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_KEY_SET_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (param->u.crypt.flags & HOSTAP_CRYPT_FLAG_SET_TX_KEY) {\r\nif (!sta_ptr)\r\nlocal->crypt_info.tx_keyidx = param->u.crypt.idx;\r\nelse if (param->u.crypt.idx) {\r\nprintk(KERN_DEBUG "%s: TX key idx setting failed\n",\r\nlocal->dev->name);\r\nparam->u.crypt.err =\r\nHOSTAP_CRYPT_ERR_TX_KEY_SET_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nif (sta_ptr)\r\nhostap_handle_sta_release(sta_ptr);\r\nif (ret == 0 &&\r\n(hostap_set_encryption(local) ||\r\n(local->iw_mode != IW_MODE_INFRA &&\r\nlocal->func->reset_port(local->dev)))) {\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_CARD_CONF_FAILED;\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_ioctl_get_encryption(local_info_t *local,\r\nstruct prism2_hostapd_param *param,\r\nint param_len)\r\n{\r\nstruct lib80211_crypt_data **crypt;\r\nvoid *sta_ptr;\r\nint max_key_len;\r\nparam->u.crypt.err = 0;\r\nmax_key_len = param_len -\r\n(int) ((char *) param->u.crypt.key - (char *) param);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nif (is_broadcast_ether_addr(param->sta_addr)) {\r\nsta_ptr = NULL;\r\nif (param->u.crypt.idx >= WEP_KEYS)\r\nparam->u.crypt.idx = local->crypt_info.tx_keyidx;\r\ncrypt = &local->crypt_info.crypt[param->u.crypt.idx];\r\n} else {\r\nparam->u.crypt.idx = 0;\r\nsta_ptr = ap_crypt_get_ptrs(local->ap, param->sta_addr, 0,\r\n&crypt);\r\nif (sta_ptr == NULL) {\r\nparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ADDR;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (*crypt == NULL || (*crypt)->ops == NULL) {\r\nmemcpy(param->u.crypt.alg, "none", 5);\r\nparam->u.crypt.key_len = 0;\r\nparam->u.crypt.idx = 0xff;\r\n} else {\r\nstrncpy(param->u.crypt.alg, (*crypt)->ops->name,\r\nHOSTAP_CRYPT_ALG_NAME_LEN);\r\nparam->u.crypt.key_len = 0;\r\nmemset(param->u.crypt.seq, 0, 8);\r\nif ((*crypt)->ops->get_key) {\r\nparam->u.crypt.key_len =\r\n(*crypt)->ops->get_key(param->u.crypt.key,\r\nmax_key_len,\r\nparam->u.crypt.seq,\r\n(*crypt)->priv);\r\n}\r\n}\r\nif (sta_ptr)\r\nhostap_handle_sta_release(sta_ptr);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_get_rid(local_info_t *local,\r\nstruct prism2_hostapd_param *param,\r\nint param_len)\r\n{\r\nint max_len, res;\r\nmax_len = param_len - PRISM2_HOSTAPD_RID_HDR_LEN;\r\nif (max_len < 0)\r\nreturn -EINVAL;\r\nres = local->func->get_rid(local->dev, param->u.rid.rid,\r\nparam->u.rid.data, param->u.rid.len, 0);\r\nif (res >= 0) {\r\nparam->u.rid.len = res;\r\nreturn 0;\r\n}\r\nreturn res;\r\n}\r\nstatic int prism2_ioctl_set_rid(local_info_t *local,\r\nstruct prism2_hostapd_param *param,\r\nint param_len)\r\n{\r\nint max_len;\r\nmax_len = param_len - PRISM2_HOSTAPD_RID_HDR_LEN;\r\nif (max_len < 0 || max_len < param->u.rid.len)\r\nreturn -EINVAL;\r\nreturn local->func->set_rid(local->dev, param->u.rid.rid,\r\nparam->u.rid.data, param->u.rid.len);\r\n}\r\nstatic int prism2_ioctl_set_assoc_ap_addr(local_info_t *local,\r\nstruct prism2_hostapd_param *param,\r\nint param_len)\r\n{\r\nprintk(KERN_DEBUG "%ssta: associated as client with AP %pM\n",\r\nlocal->dev->name, param->sta_addr);\r\nmemcpy(local->assoc_ap_addr, param->sta_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_siwgenie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nreturn prism2_set_genericelement(dev, extra, data->length);\r\n}\r\nstatic int prism2_ioctl_giwgenie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nint len = local->generic_elem_len - 2;\r\nif (len <= 0 || local->generic_elem == NULL) {\r\ndata->length = 0;\r\nreturn 0;\r\n}\r\nif (data->length < len)\r\nreturn -E2BIG;\r\ndata->length = len;\r\nmemcpy(extra, local->generic_elem + 2, len);\r\nreturn 0;\r\n}\r\nstatic int prism2_ioctl_set_generic_element(local_info_t *local,\r\nstruct prism2_hostapd_param *param,\r\nint param_len)\r\n{\r\nint max_len, len;\r\nlen = param->u.generic_elem.len;\r\nmax_len = param_len - PRISM2_HOSTAPD_GENERIC_ELEMENT_HDR_LEN;\r\nif (max_len < 0 || max_len < len)\r\nreturn -EINVAL;\r\nreturn prism2_set_genericelement(local->dev,\r\nparam->u.generic_elem.data, len);\r\n}\r\nstatic int prism2_ioctl_siwmlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data, char *extra)\r\n{\r\nstruct hostap_interface *iface = netdev_priv(dev);\r\nlocal_info_t *local = iface->local;\r\nstruct iw_mlme *mlme = (struct iw_mlme *) extra;\r\n__le16 reason;\r\nreason = cpu_to_le16(mlme->reason_code);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\nreturn prism2_sta_send_mgmt(local, mlme->addr.sa_data,\r\nIEEE80211_STYPE_DEAUTH,\r\n(u8 *) &reason, 2);\r\ncase IW_MLME_DISASSOC:\r\nreturn prism2_sta_send_mgmt(local, mlme->addr.sa_data,\r\nIEEE80211_STYPE_DISASSOC,\r\n(u8 *) &reason, 2);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int prism2_ioctl_mlme(local_info_t *local,\r\nstruct prism2_hostapd_param *param)\r\n{\r\n__le16 reason;\r\nreason = cpu_to_le16(param->u.mlme.reason_code);\r\nswitch (param->u.mlme.cmd) {\r\ncase MLME_STA_DEAUTH:\r\nreturn prism2_sta_send_mgmt(local, param->sta_addr,\r\nIEEE80211_STYPE_DEAUTH,\r\n(u8 *) &reason, 2);\r\ncase MLME_STA_DISASSOC:\r\nreturn prism2_sta_send_mgmt(local, param->sta_addr,\r\nIEEE80211_STYPE_DISASSOC,\r\n(u8 *) &reason, 2);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int prism2_ioctl_scan_req(local_info_t *local,\r\nstruct prism2_hostapd_param *param)\r\n{\r\n#ifndef PRISM2_NO_STATION_MODES\r\nif ((local->iw_mode != IW_MODE_INFRA &&\r\nlocal->iw_mode != IW_MODE_ADHOC) ||\r\n(local->sta_fw_ver < PRISM2_FW_VER(1,3,1)))\r\nreturn -EOPNOTSUPP;\r\nif (!local->dev_enabled)\r\nreturn -ENETDOWN;\r\nreturn prism2_request_hostscan(local->dev, param->u.scan_req.ssid,\r\nparam->u.scan_req.ssid_len);\r\n#else\r\nreturn -EOPNOTSUPP;\r\n#endif\r\n}\r\nstatic int prism2_ioctl_priv_hostapd(local_info_t *local, struct iw_point *p)\r\n{\r\nstruct prism2_hostapd_param *param;\r\nint ret = 0;\r\nint ap_ioctl = 0;\r\nif (p->length < sizeof(struct prism2_hostapd_param) ||\r\np->length > PRISM2_HOSTAPD_MAX_BUF_SIZE || !p->pointer)\r\nreturn -EINVAL;\r\nparam = kmalloc(p->length, GFP_KERNEL);\r\nif (param == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(param, p->pointer, p->length)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase PRISM2_SET_ENCRYPTION:\r\nret = prism2_ioctl_set_encryption(local, param, p->length);\r\nbreak;\r\ncase PRISM2_GET_ENCRYPTION:\r\nret = prism2_ioctl_get_encryption(local, param, p->length);\r\nbreak;\r\ncase PRISM2_HOSTAPD_GET_RID:\r\nret = prism2_ioctl_get_rid(local, param, p->length);\r\nbreak;\r\ncase PRISM2_HOSTAPD_SET_RID:\r\nret = prism2_ioctl_set_rid(local, param, p->length);\r\nbreak;\r\ncase PRISM2_HOSTAPD_SET_ASSOC_AP_ADDR:\r\nret = prism2_ioctl_set_assoc_ap_addr(local, param, p->length);\r\nbreak;\r\ncase PRISM2_HOSTAPD_SET_GENERIC_ELEMENT:\r\nret = prism2_ioctl_set_generic_element(local, param,\r\np->length);\r\nbreak;\r\ncase PRISM2_HOSTAPD_MLME:\r\nret = prism2_ioctl_mlme(local, param);\r\nbreak;\r\ncase PRISM2_HOSTAPD_SCAN_REQ:\r\nret = prism2_ioctl_scan_req(local, param);\r\nbreak;\r\ndefault:\r\nret = prism2_hostapd(local->ap, param);\r\nap_ioctl = 1;\r\nbreak;\r\n}\r\nif (ret == 1 || !ap_ioctl) {\r\nif (copy_to_user(p->pointer, param, p->length)) {\r\nret = -EFAULT;\r\ngoto out;\r\n} else if (ap_ioctl)\r\nret = 0;\r\n}\r\nout:\r\nkfree(param);\r\nreturn ret;\r\n}\r\nstatic void prism2_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nstrlcpy(info->driver, "hostap", sizeof(info->driver));\r\nsnprintf(info->fw_version, sizeof(info->fw_version),\r\n"%d.%d.%d", (local->sta_fw_ver >> 16) & 0xff,\r\n(local->sta_fw_ver >> 8) & 0xff,\r\nlocal->sta_fw_ver & 0xff);\r\n}\r\nint hostap_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct iwreq *wrq = (struct iwreq *) ifr;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint ret = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nswitch (cmd) {\r\ncase PRISM2_IOCTL_INQUIRE:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_ioctl_priv_inquire(dev, (int *) wrq->u.name);\r\nbreak;\r\ncase PRISM2_IOCTL_MONITOR:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_ioctl_priv_monitor(dev, (int *) wrq->u.name);\r\nbreak;\r\ncase PRISM2_IOCTL_RESET:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_ioctl_priv_reset(dev, (int *) wrq->u.name);\r\nbreak;\r\ncase PRISM2_IOCTL_WDS_ADD:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_wds_add(local, wrq->u.ap_addr.sa_data, 1);\r\nbreak;\r\ncase PRISM2_IOCTL_WDS_DEL:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_wds_del(local, wrq->u.ap_addr.sa_data, 1, 0);\r\nbreak;\r\ncase PRISM2_IOCTL_SET_RID_WORD:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_ioctl_priv_set_rid_word(dev,\r\n(int *) wrq->u.name);\r\nbreak;\r\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\r\ncase PRISM2_IOCTL_MACCMD:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = ap_mac_cmd_ioctl(local, (int *) wrq->u.name);\r\nbreak;\r\ncase PRISM2_IOCTL_ADDMAC:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = ap_control_add_mac(&local->ap->mac_restrictions,\r\nwrq->u.ap_addr.sa_data);\r\nbreak;\r\ncase PRISM2_IOCTL_DELMAC:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = ap_control_del_mac(&local->ap->mac_restrictions,\r\nwrq->u.ap_addr.sa_data);\r\nbreak;\r\ncase PRISM2_IOCTL_KICKMAC:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = ap_control_kick_mac(local->ap, local->dev,\r\nwrq->u.ap_addr.sa_data);\r\nbreak;\r\n#endif\r\n#ifdef PRISM2_DOWNLOAD_SUPPORT\r\ncase PRISM2_IOCTL_DOWNLOAD:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_ioctl_priv_download(local, &wrq->u.data);\r\nbreak;\r\n#endif\r\ncase PRISM2_IOCTL_HOSTAPD:\r\nif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\r\nelse ret = prism2_ioctl_priv_hostapd(local, &wrq->u.data);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}
