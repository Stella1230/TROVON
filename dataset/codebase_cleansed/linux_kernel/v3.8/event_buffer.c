void add_event_entry(unsigned long value)\r\n{\r\nif (!event_buffer) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nif (buffer_pos == buffer_size) {\r\natomic_inc(&oprofile_stats.event_lost_overflow);\r\nreturn;\r\n}\r\nevent_buffer[buffer_pos] = value;\r\nif (++buffer_pos == buffer_size - buffer_watershed) {\r\natomic_set(&buffer_ready, 1);\r\nwake_up(&buffer_wait);\r\n}\r\n}\r\nvoid wake_up_buffer_waiter(void)\r\n{\r\nmutex_lock(&buffer_mutex);\r\natomic_set(&buffer_ready, 1);\r\nwake_up(&buffer_wait);\r\nmutex_unlock(&buffer_mutex);\r\n}\r\nint alloc_event_buffer(void)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&oprofilefs_lock, flags);\r\nbuffer_size = oprofile_buffer_size;\r\nbuffer_watershed = oprofile_buffer_watershed;\r\nraw_spin_unlock_irqrestore(&oprofilefs_lock, flags);\r\nif (buffer_watershed >= buffer_size)\r\nreturn -EINVAL;\r\nbuffer_pos = 0;\r\nevent_buffer = vmalloc(sizeof(unsigned long) * buffer_size);\r\nif (!event_buffer)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid free_event_buffer(void)\r\n{\r\nmutex_lock(&buffer_mutex);\r\nvfree(event_buffer);\r\nbuffer_pos = 0;\r\nevent_buffer = NULL;\r\nmutex_unlock(&buffer_mutex);\r\n}\r\nstatic int event_buffer_open(struct inode *inode, struct file *file)\r\n{\r\nint err = -EPERM;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (test_and_set_bit_lock(0, &buffer_opened))\r\nreturn -EBUSY;\r\nerr = -EINVAL;\r\nfile->private_data = dcookie_register();\r\nif (!file->private_data)\r\ngoto out;\r\nif ((err = oprofile_setup()))\r\ngoto fail;\r\nreturn nonseekable_open(inode, file);\r\nfail:\r\ndcookie_unregister(file->private_data);\r\nout:\r\n__clear_bit_unlock(0, &buffer_opened);\r\nreturn err;\r\n}\r\nstatic int event_buffer_release(struct inode *inode, struct file *file)\r\n{\r\noprofile_stop();\r\noprofile_shutdown();\r\ndcookie_unregister(file->private_data);\r\nbuffer_pos = 0;\r\natomic_set(&buffer_ready, 0);\r\n__clear_bit_unlock(0, &buffer_opened);\r\nreturn 0;\r\n}\r\nstatic ssize_t event_buffer_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nint retval = -EINVAL;\r\nsize_t const max = buffer_size * sizeof(unsigned long);\r\nif (count != max || *offset)\r\nreturn -EINVAL;\r\nwait_event_interruptible(buffer_wait, atomic_read(&buffer_ready));\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (!atomic_read(&buffer_ready))\r\nreturn -EAGAIN;\r\nmutex_lock(&buffer_mutex);\r\nif (!event_buffer) {\r\nretval = -EINTR;\r\ngoto out;\r\n}\r\natomic_set(&buffer_ready, 0);\r\nretval = -EFAULT;\r\ncount = buffer_pos * sizeof(unsigned long);\r\nif (copy_to_user(buf, event_buffer, count))\r\ngoto out;\r\nretval = count;\r\nbuffer_pos = 0;\r\nout:\r\nmutex_unlock(&buffer_mutex);\r\nreturn retval;\r\n}
