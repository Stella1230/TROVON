static inline int __iio_allocate_sw_ring_buffer(struct iio_sw_ring_buffer *ring,\r\nint bytes_per_datum, int length)\r\n{\r\nif ((length == 0) || (bytes_per_datum == 0))\r\nreturn -EINVAL;\r\n__iio_update_buffer(&ring->buf, bytes_per_datum, length);\r\nring->data = kmalloc(length*ring->buf.bytes_per_datum, GFP_ATOMIC);\r\nring->read_p = NULL;\r\nring->write_p = NULL;\r\nring->half_p = NULL;\r\nreturn ring->data ? 0 : -ENOMEM;\r\n}\r\nstatic inline void __iio_free_sw_ring_buffer(struct iio_sw_ring_buffer *ring)\r\n{\r\nkfree(ring->data);\r\n}\r\nstatic int iio_store_to_sw_ring(struct iio_sw_ring_buffer *ring,\r\nunsigned char *data)\r\n{\r\nint ret = 0;\r\nunsigned char *temp_ptr, *change_test_ptr;\r\nif (unlikely(ring->write_p == NULL)) {\r\nring->write_p = ring->data;\r\nring->half_p = ring->data - ring->buf.length*ring->buf.bytes_per_datum/2;\r\n}\r\nmemcpy(ring->write_p, data, ring->buf.bytes_per_datum);\r\nbarrier();\r\nbarrier();\r\ntemp_ptr = ring->write_p + ring->buf.bytes_per_datum;\r\nif (temp_ptr == ring->data + ring->buf.length*ring->buf.bytes_per_datum)\r\ntemp_ptr = ring->data;\r\nring->write_p = temp_ptr;\r\nif (ring->read_p == NULL)\r\nring->read_p = ring->data;\r\nelse if (ring->write_p == ring->read_p) {\r\nchange_test_ptr = ring->read_p;\r\ntemp_ptr = change_test_ptr + ring->buf.bytes_per_datum;\r\nif (temp_ptr\r\n== ring->data + ring->buf.length*ring->buf.bytes_per_datum) {\r\ntemp_ptr = ring->data;\r\n}\r\nif (change_test_ptr == ring->read_p)\r\nring->read_p = temp_ptr;\r\n}\r\nring->half_p += ring->buf.bytes_per_datum;\r\nif (ring->half_p == ring->data + ring->buf.length*ring->buf.bytes_per_datum)\r\nring->half_p = ring->data;\r\nif (ring->half_p == ring->read_p) {\r\nring->buf.stufftoread = true;\r\nwake_up_interruptible(&ring->buf.pollq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iio_read_first_n_sw_rb(struct iio_buffer *r,\r\nsize_t n, char __user *buf)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nu8 *initial_read_p, *initial_write_p, *current_read_p, *end_read_p;\r\nu8 *data;\r\nint ret, max_copied, bytes_to_rip, dead_offset;\r\nsize_t data_available, buffer_size;\r\nif (n % ring->buf.bytes_per_datum) {\r\nret = -EINVAL;\r\nprintk(KERN_INFO "Ring buffer read request not whole number of"\r\n"samples: Request bytes %zd, Current bytes per datum %d\n",\r\nn, ring->buf.bytes_per_datum);\r\ngoto error_ret;\r\n}\r\nbuffer_size = ring->buf.bytes_per_datum*ring->buf.length;\r\nbytes_to_rip = min_t(size_t, buffer_size, n);\r\ndata = kmalloc(bytes_to_rip, GFP_KERNEL);\r\nif (data == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ninitial_read_p = ring->read_p;\r\nif (unlikely(initial_read_p == NULL)) {\r\nret = 0;\r\ngoto error_free_data_cpy;\r\n}\r\ninitial_write_p = ring->write_p;\r\nwhile ((initial_read_p != ring->read_p)\r\n|| (initial_write_p != ring->write_p)) {\r\ninitial_read_p = ring->read_p;\r\ninitial_write_p = ring->write_p;\r\n}\r\nif (initial_write_p == initial_read_p) {\r\nret = 0;\r\ngoto error_free_data_cpy;\r\n}\r\nif (initial_write_p >= initial_read_p)\r\ndata_available = initial_write_p - initial_read_p;\r\nelse\r\ndata_available = buffer_size - (initial_read_p - initial_write_p);\r\nif (data_available < bytes_to_rip)\r\nbytes_to_rip = data_available;\r\nif (initial_read_p + bytes_to_rip >= ring->data + buffer_size) {\r\nmax_copied = ring->data + buffer_size - initial_read_p;\r\nmemcpy(data, initial_read_p, max_copied);\r\nmemcpy(data + max_copied, ring->data, bytes_to_rip - max_copied);\r\nend_read_p = ring->data + bytes_to_rip - max_copied;\r\n} else {\r\nmemcpy(data, initial_read_p, bytes_to_rip);\r\nend_read_p = initial_read_p + bytes_to_rip;\r\n}\r\ncurrent_read_p = ring->read_p;\r\nif (initial_read_p <= current_read_p)\r\ndead_offset = current_read_p - initial_read_p;\r\nelse\r\ndead_offset = buffer_size - (initial_read_p - current_read_p);\r\nif (bytes_to_rip - dead_offset < 0) {\r\nret = 0;\r\ngoto error_free_data_cpy;\r\n}\r\nwhile (ring->read_p != end_read_p)\r\nring->read_p = end_read_p;\r\nret = bytes_to_rip - dead_offset;\r\nif (copy_to_user(buf, data + dead_offset, ret)) {\r\nret = -EFAULT;\r\ngoto error_free_data_cpy;\r\n}\r\nif (bytes_to_rip >= ring->buf.length*ring->buf.bytes_per_datum/2)\r\nring->buf.stufftoread = 0;\r\nerror_free_data_cpy:\r\nkfree(data);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int iio_store_to_sw_rb(struct iio_buffer *r,\r\nu8 *data)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nreturn iio_store_to_sw_ring(ring, data);\r\n}\r\nstatic int iio_request_update_sw_rb(struct iio_buffer *r)\r\n{\r\nint ret = 0;\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nr->stufftoread = false;\r\nif (!ring->update_needed)\r\ngoto error_ret;\r\n__iio_free_sw_ring_buffer(ring);\r\nret = __iio_allocate_sw_ring_buffer(ring, ring->buf.bytes_per_datum,\r\nring->buf.length);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int iio_get_bytes_per_datum_sw_rb(struct iio_buffer *r)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nreturn ring->buf.bytes_per_datum;\r\n}\r\nstatic int iio_mark_update_needed_sw_rb(struct iio_buffer *r)\r\n{\r\nstruct iio_sw_ring_buffer *ring = iio_to_sw_ring(r);\r\nring->update_needed = true;\r\nreturn 0;\r\n}\r\nstatic int iio_set_bytes_per_datum_sw_rb(struct iio_buffer *r, size_t bpd)\r\n{\r\nif (r->bytes_per_datum != bpd) {\r\nr->bytes_per_datum = bpd;\r\niio_mark_update_needed_sw_rb(r);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_get_length_sw_rb(struct iio_buffer *r)\r\n{\r\nreturn r->length;\r\n}\r\nstatic int iio_set_length_sw_rb(struct iio_buffer *r, int length)\r\n{\r\nif (r->length != length) {\r\nr->length = length;\r\niio_mark_update_needed_sw_rb(r);\r\n}\r\nreturn 0;\r\n}\r\nstruct iio_buffer *iio_sw_rb_allocate(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_buffer *buf;\r\nstruct iio_sw_ring_buffer *ring;\r\nring = kzalloc(sizeof *ring, GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nring->update_needed = true;\r\nbuf = &ring->buf;\r\niio_buffer_init(buf);\r\nbuf->attrs = &iio_ring_attribute_group;\r\nbuf->access = &ring_sw_access_funcs;\r\nreturn buf;\r\n}\r\nvoid iio_sw_rb_free(struct iio_buffer *r)\r\n{\r\nkfree(iio_to_sw_ring(r));\r\n}
