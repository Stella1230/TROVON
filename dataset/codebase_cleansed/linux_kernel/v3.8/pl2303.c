static int pl2303_vendor_read(__u16 value, __u16 index,\r\nstruct usb_serial *serial, unsigned char *buf)\r\n{\r\nint res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nVENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,\r\nvalue, index, buf, 1, 100);\r\ndev_dbg(&serial->dev->dev, "0x%x:0x%x:0x%x:0x%x %d - %x\n",\r\nVENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, value, index,\r\nres, buf[0]);\r\nreturn res;\r\n}\r\nstatic int pl2303_vendor_write(__u16 value, __u16 index,\r\nstruct usb_serial *serial)\r\n{\r\nint res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nVENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,\r\nvalue, index, NULL, 0, 100);\r\ndev_dbg(&serial->dev->dev, "0x%x:0x%x:0x%x:0x%x %d\n",\r\nVENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, value, index,\r\nres);\r\nreturn res;\r\n}\r\nstatic int pl2303_startup(struct usb_serial *serial)\r\n{\r\nstruct pl2303_serial_private *spriv;\r\nenum pl2303_type type = type_0;\r\nunsigned char *buf;\r\nspriv = kzalloc(sizeof(*spriv), GFP_KERNEL);\r\nif (!spriv)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(10, GFP_KERNEL);\r\nif (!buf) {\r\nkfree(spriv);\r\nreturn -ENOMEM;\r\n}\r\nif (serial->dev->descriptor.bDeviceClass == 0x02)\r\ntype = type_0;\r\nelse if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)\r\ntype = HX;\r\nelse if (serial->dev->descriptor.bDeviceClass == 0x00)\r\ntype = type_1;\r\nelse if (serial->dev->descriptor.bDeviceClass == 0xFF)\r\ntype = type_1;\r\ndev_dbg(&serial->interface->dev, "device type: %d\n", type);\r\nspriv->type = type;\r\nusb_set_serial_data(serial, spriv);\r\npl2303_vendor_read(0x8484, 0, serial, buf);\r\npl2303_vendor_write(0x0404, 0, serial);\r\npl2303_vendor_read(0x8484, 0, serial, buf);\r\npl2303_vendor_read(0x8383, 0, serial, buf);\r\npl2303_vendor_read(0x8484, 0, serial, buf);\r\npl2303_vendor_write(0x0404, 1, serial);\r\npl2303_vendor_read(0x8484, 0, serial, buf);\r\npl2303_vendor_read(0x8383, 0, serial, buf);\r\npl2303_vendor_write(0, 1, serial);\r\npl2303_vendor_write(1, 0, serial);\r\nif (type == HX)\r\npl2303_vendor_write(2, 0x44, serial);\r\nelse\r\npl2303_vendor_write(2, 0x24, serial);\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic void pl2303_release(struct usb_serial *serial)\r\n{\r\nstruct pl2303_serial_private *spriv;\r\nspriv = usb_get_serial_data(serial);\r\nkfree(spriv);\r\n}\r\nstatic int pl2303_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct pl2303_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int pl2303_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct pl2303_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int set_control_lines(struct usb_device *dev, u8 value)\r\n{\r\nint retval;\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nSET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,\r\nvalue, 0, NULL, 0, 100);\r\ndev_dbg(&dev->dev, "%s - value = %d, retval = %d\n", __func__,\r\nvalue, retval);\r\nreturn retval;\r\n}\r\nstatic void pl2303_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int cflag;\r\nunsigned char *buf;\r\nint baud;\r\nint i;\r\nu8 control;\r\nconst int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,\r\n4800, 7200, 9600, 14400, 19200, 28800, 38400,\r\n57600, 115200, 230400, 460800, 614400,\r\n921600, 1228800, 2457600, 3000000, 6000000 };\r\nint baud_floor, baud_ceil;\r\nint k;\r\nif (!tty_termios_hw_change(&tty->termios, old_termios))\r\nreturn;\r\ncflag = tty->termios.c_cflag;\r\nbuf = kzalloc(7, GFP_KERNEL);\r\nif (!buf) {\r\ndev_err(&port->dev, "%s - out of memory.\n", __func__);\r\ntty->termios = *old_termios;\r\nreturn;\r\n}\r\ni = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nGET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,\r\n0, 0, buf, 7, 100);\r\ndev_dbg(&port->dev, "0xa1:0x21:0:0 %d - %x %x %x %x %x %x %x\n", i,\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);\r\nif (cflag & CSIZE) {\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nbuf[6] = 5;\r\nbreak;\r\ncase CS6:\r\nbuf[6] = 6;\r\nbreak;\r\ncase CS7:\r\nbuf[6] = 7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nbuf[6] = 8;\r\nbreak;\r\n}\r\ndev_dbg(&port->dev, "data bits = %d\n", buf[6]);\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\ndev_dbg(&port->dev, "baud requested = %d\n", baud);\r\nif (baud) {\r\nfor (k=0; k<ARRAY_SIZE(baud_sup); k++) {\r\nif (baud_sup[k] / baud) {\r\nbaud_ceil = baud_sup[k];\r\nif (k==0) {\r\nbaud = baud_ceil;\r\n} else {\r\nbaud_floor = baud_sup[k-1];\r\nif ((baud_ceil % baud)\r\n> (baud % baud_floor))\r\nbaud = baud_floor;\r\nelse\r\nbaud = baud_ceil;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (baud > 1228800) {\r\nif (spriv->type != HX)\r\nbaud = 1228800;\r\nelse if (baud > 6000000)\r\nbaud = 6000000;\r\n}\r\ndev_dbg(&port->dev, "baud set = %d\n", baud);\r\nif (baud <= 115200) {\r\nbuf[0] = baud & 0xff;\r\nbuf[1] = (baud >> 8) & 0xff;\r\nbuf[2] = (baud >> 16) & 0xff;\r\nbuf[3] = (baud >> 24) & 0xff;\r\n} else {\r\nunsigned tmp = 12*1000*1000*32 / baud;\r\nbuf[3] = 0x80;\r\nbuf[2] = 0;\r\nbuf[1] = (tmp >= 256);\r\nwhile (tmp >= 256) {\r\ntmp >>= 2;\r\nbuf[1] <<= 1;\r\n}\r\nbuf[0] = tmp;\r\n}\r\n}\r\nif (cflag & CSTOPB) {\r\nif ((cflag & CSIZE) == CS5) {\r\nbuf[4] = 1;\r\ndev_dbg(&port->dev, "stop bits = 1.5\n");\r\n} else {\r\nbuf[4] = 2;\r\ndev_dbg(&port->dev, "stop bits = 2\n");\r\n}\r\n} else {\r\nbuf[4] = 0;\r\ndev_dbg(&port->dev, "stop bits = 1\n");\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nif (cflag & CMSPAR) {\r\nbuf[5] = 3;\r\ndev_dbg(&port->dev, "parity = mark\n");\r\n} else {\r\nbuf[5] = 1;\r\ndev_dbg(&port->dev, "parity = odd\n");\r\n}\r\n} else {\r\nif (cflag & CMSPAR) {\r\nbuf[5] = 4;\r\ndev_dbg(&port->dev, "parity = space\n");\r\n} else {\r\nbuf[5] = 2;\r\ndev_dbg(&port->dev, "parity = even\n");\r\n}\r\n}\r\n} else {\r\nbuf[5] = 0;\r\ndev_dbg(&port->dev, "parity = none\n");\r\n}\r\ni = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nSET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,\r\n0, 0, buf, 7, 100);\r\ndev_dbg(&port->dev, "0x21:0x20:0:0 %d\n", i);\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol = priv->line_control;\r\nif ((cflag & CBAUD) == B0)\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\nelse if ((old_termios->c_cflag & CBAUD) == B0)\r\npriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\r\nif (control != priv->line_control) {\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nset_control_lines(serial->dev, control);\r\n} else {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nbuf[0] = buf[1] = buf[2] = buf[3] = buf[4] = buf[5] = buf[6] = 0;\r\ni = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nGET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,\r\n0, 0, buf, 7, 100);\r\ndev_dbg(&port->dev, "0xa1:0x21:0:0 %d - %x %x %x %x %x %x %x\n", i,\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);\r\nif (cflag & CRTSCTS) {\r\nif (spriv->type == HX)\r\npl2303_vendor_write(0x0, 0x61, serial);\r\nelse\r\npl2303_vendor_write(0x0, 0x41, serial);\r\n} else {\r\npl2303_vendor_write(0x0, 0x0, serial);\r\n}\r\nif (baud)\r\ntty_encode_baud_rate(tty, baud, baud);\r\nkfree(buf);\r\n}\r\nstatic void pl2303_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (on)\r\npriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\r\nelse\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nset_control_lines(port->serial->dev, control);\r\n}\r\nstatic void pl2303_close(struct usb_serial_port *port)\r\n{\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct ktermios tmp_termios;\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\r\nint result;\r\nif (spriv->type != HX) {\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\n} else {\r\npl2303_vendor_write(8, 0, serial);\r\npl2303_vendor_write(9, 0, serial);\r\n}\r\nif (tty)\r\npl2303_set_termios(tty, port, &tmp_termios);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "%s - failed submitting interrupt urb,"\r\n" error %d\n", __func__, result);\r\nreturn result;\r\n}\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result) {\r\nusb_kill_urb(port->interrupt_in_urb);\r\nreturn result;\r\n}\r\nport->port.drain_delay = 256;\r\nreturn 0;\r\n}\r\nstatic int pl2303_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nint ret;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (set & TIOCM_RTS)\r\npriv->line_control |= CONTROL_RTS;\r\nif (set & TIOCM_DTR)\r\npriv->line_control |= CONTROL_DTR;\r\nif (clear & TIOCM_RTS)\r\npriv->line_control &= ~CONTROL_RTS;\r\nif (clear & TIOCM_DTR)\r\npriv->line_control &= ~CONTROL_DTR;\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nmutex_lock(&serial->disc_mutex);\r\nif (!serial->disconnected)\r\nret = set_control_lines(serial->dev, control);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&serial->disc_mutex);\r\nreturn ret;\r\n}\r\nstatic int pl2303_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int mcr;\r\nunsigned int status;\r\nunsigned int result;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmcr = priv->line_control;\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = ((mcr & CONTROL_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & CONTROL_RTS) ? TIOCM_RTS : 0)\r\n| ((status & UART_CTS) ? TIOCM_CTS : 0)\r\n| ((status & UART_DSR) ? TIOCM_DSR : 0)\r\n| ((status & UART_RING) ? TIOCM_RI : 0)\r\n| ((status & UART_DCD) ? TIOCM_CD : 0);\r\ndev_dbg(&port->dev, "%s - result = %x\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int pl2303_carrier_raised(struct usb_serial_port *port)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nif (priv->line_status & UART_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int wait_modem_info(struct usb_serial_port *port, unsigned int arg)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int prevstatus;\r\nunsigned int status;\r\nunsigned int changed;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nprevstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwhile (1) {\r\ninterruptible_sleep_on(&priv->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nchanged = prevstatus ^ status;\r\nif (((arg & TIOCM_RNG) && (changed & UART_RING)) ||\r\n((arg & TIOCM_DSR) && (changed & UART_DSR)) ||\r\n((arg & TIOCM_CD) && (changed & UART_DCD)) ||\r\n((arg & TIOCM_CTS) && (changed & UART_CTS))) {\r\nreturn 0;\r\n}\r\nprevstatus = status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl2303_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct serial_struct ser;\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(&port->dev, "%s cmd = 0x%04x\n", __func__, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&ser, 0, sizeof ser);\r\nser.type = PORT_16654;\r\nser.line = port->serial->minor;\r\nser.port = port->number;\r\nser.baud_base = 460800;\r\nif (copy_to_user((void __user *)arg, &ser, sizeof ser))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\ndev_dbg(&port->dev, "%s TIOCMIWAIT\n", __func__);\r\nreturn wait_modem_info(port, arg);\r\ndefault:\r\ndev_dbg(&port->dev, "%s not supported = 0x%04x\n", __func__, cmd);\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void pl2303_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nu16 state;\r\nint result;\r\nif (break_state == 0)\r\nstate = BREAK_OFF;\r\nelse\r\nstate = BREAK_ON;\r\ndev_dbg(&port->dev, "%s - turning break %s\n", __func__,\r\nstate == BREAK_OFF ? "off" : "on");\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nBREAK_REQUEST, BREAK_REQUEST_TYPE, state,\r\n0, NULL, 0, 100);\r\nif (result)\r\ndev_err(&port->dev, "error sending break = %d\n", result);\r\n}\r\nstatic void pl2303_update_line_status(struct usb_serial_port *port,\r\nunsigned char *data,\r\nunsigned int actual_length)\r\n{\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nu8 status_idx = UART_STATE;\r\nu8 length = UART_STATE + 1;\r\nu8 prev_line_status;\r\nu16 idv, idp;\r\nidv = le16_to_cpu(port->serial->dev->descriptor.idVendor);\r\nidp = le16_to_cpu(port->serial->dev->descriptor.idProduct);\r\nif (idv == SIEMENS_VENDOR_ID) {\r\nif (idp == SIEMENS_PRODUCT_ID_X65 ||\r\nidp == SIEMENS_PRODUCT_ID_SX1 ||\r\nidp == SIEMENS_PRODUCT_ID_X75) {\r\nlength = 1;\r\nstatus_idx = 0;\r\n}\r\n}\r\nif (actual_length < length)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nprev_line_status = priv->line_status;\r\npriv->line_status = data[status_idx];\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (priv->line_status & UART_BREAK_ERROR)\r\nusb_serial_handle_break(port);\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nif ((priv->line_status ^ prev_line_status) & UART_DCD)\r\nusb_serial_handle_dcd_change(port, tty,\r\npriv->line_status & UART_DCD);\r\ntty_kref_put(tty);\r\n}\r\nstatic void pl2303_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int actual_length = urb->actual_length;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\npl2303_update_line_status(port, data, actual_length);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void pl2303_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct pl2303_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nchar tty_flag = TTY_NORMAL;\r\nunsigned long flags;\r\nu8 line_status;\r\nint i;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nline_status = priv->line_status;\r\npriv->line_status &= ~UART_STATE_TRANSIENT_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\nif (!urb->actual_length)\r\nreturn;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nif (line_status & UART_BREAK_ERROR)\r\ntty_flag = TTY_BREAK;\r\nelse if (line_status & UART_PARITY_ERROR)\r\ntty_flag = TTY_PARITY;\r\nelse if (line_status & UART_FRAME_ERROR)\r\ntty_flag = TTY_FRAME;\r\ndev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__, tty_flag);\r\nif (line_status & UART_OVERRUN_ERROR)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < urb->actual_length; ++i)\r\nif (!usb_serial_handle_sysrq_char(port, data[i]))\r\ntty_insert_flip_char(tty, data[i], tty_flag);\r\n} else {\r\ntty_insert_flip_string_fixed_flag(tty, data, tty_flag,\r\nurb->actual_length);\r\n}\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}
