static void irlan_client_kick_timer_expired(void *data)\r\n{\r\nstruct irlan_cb *self = (struct irlan_cb *) data;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif ((self->provider.access_type == ACCESS_PEER) &&\r\n(self->client.state == IRLAN_IDLE) &&\r\n(self->provider.state != IRLAN_IDLE)) {\r\nirlan_client_wakeup(self, self->saddr, self->daddr);\r\n}\r\n}\r\nstatic void irlan_client_start_kick_timer(struct irlan_cb *self, int timeout)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nirda_start_timer(&self->client.kick_timer, timeout, (void *) self,\r\nirlan_client_kick_timer_expired);\r\n}\r\nvoid irlan_client_wakeup(struct irlan_cb *self, __u32 saddr, __u32 daddr)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif ((self->client.state != IRLAN_IDLE) ||\r\n(self->provider.access_type == ACCESS_DIRECT))\r\n{\r\nIRDA_DEBUG(0, "%s(), already awake!\n", __func__ );\r\nreturn;\r\n}\r\nself->saddr = saddr;\r\nself->daddr = daddr;\r\nif (self->disconnect_reason == LM_USER_REQUEST) {\r\nIRDA_DEBUG(0, "%s(), still stopped by user\n", __func__ );\r\nreturn;\r\n}\r\nirlan_client_open_ctrl_tsap(self);\r\nirlan_open_data_tsap(self);\r\nirlan_do_client_event(self, IRLAN_DISCOVERY_INDICATION, NULL);\r\nirlan_client_start_kick_timer(self, 2*HZ);\r\n}\r\nvoid irlan_client_discovery_indication(discinfo_t *discovery,\r\nDISCOVERY_MODE mode,\r\nvoid *priv)\r\n{\r\nstruct irlan_cb *self;\r\n__u32 saddr, daddr;\r\nIRDA_DEBUG(1, "%s()\n", __func__ );\r\nIRDA_ASSERT(discovery != NULL, return;);\r\nif(mode == DISCOVERY_PASSIVE)\r\nreturn;\r\nsaddr = discovery->saddr;\r\ndaddr = discovery->daddr;\r\nrcu_read_lock();\r\nself = irlan_get_any();\r\nif (self) {\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, goto out;);\r\nIRDA_DEBUG(1, "%s(), Found instance (%08x)!\n", __func__ ,\r\ndaddr);\r\nirlan_client_wakeup(self, saddr, daddr);\r\n}\r\nIRDA_ASSERT_LABEL(out:)\r\nrcu_read_unlock();\r\n}\r\nstatic int irlan_client_ctrl_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nirlan_do_client_event(self, IRLAN_DATA_INDICATION, skb);\r\nIRDA_DEBUG(2, "%s(), clearing tx_busy\n", __func__ );\r\nself->client.tx_busy = FALSE;\r\nirlan_run_ctrl_tx_queue(self);\r\nreturn 0;\r\n}\r\nstatic void irlan_client_ctrl_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason,\r\nstruct sk_buff *userdata)\r\n{\r\nstruct irlan_cb *self;\r\nstruct tsap_cb *tsap;\r\nstruct sk_buff *skb;\r\nIRDA_DEBUG(4, "%s(), reason=%d\n", __func__ , reason);\r\nself = instance;\r\ntsap = sap;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nIRDA_ASSERT(tsap != NULL, return;);\r\nIRDA_ASSERT(tsap->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_ASSERT(tsap == self->client.tsap_ctrl, return;);\r\nwhile ((skb = skb_dequeue(&self->client.txq)) != NULL) {\r\ndev_kfree_skb(skb);\r\n}\r\nself->client.tx_busy = FALSE;\r\nirlan_do_client_event(self, IRLAN_LMP_DISCONNECT, NULL);\r\n}\r\nstatic void irlan_client_open_ctrl_tsap(struct irlan_cb *self)\r\n{\r\nstruct tsap_cb *tsap;\r\nnotify_t notify;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (self->client.tsap_ctrl)\r\nreturn;\r\nirda_notify_init(&notify);\r\nnotify.data_indication = irlan_client_ctrl_data_indication;\r\nnotify.connect_confirm = irlan_client_ctrl_connect_confirm;\r\nnotify.disconnect_indication = irlan_client_ctrl_disconnect_indication;\r\nnotify.instance = self;\r\nstrlcpy(notify.name, "IrLAN ctrl (c)", sizeof(notify.name));\r\ntsap = irttp_open_tsap(LSAP_ANY, DEFAULT_INITIAL_CREDIT, &notify);\r\nif (!tsap) {\r\nIRDA_DEBUG(2, "%s(), Got no tsap!\n", __func__ );\r\nreturn;\r\n}\r\nself->client.tsap_ctrl = tsap;\r\n}\r\nstatic void irlan_client_ctrl_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nself->client.max_sdu_size = max_sdu_size;\r\nself->client.max_header_size = max_header_size;\r\nirlan_do_client_event(self, IRLAN_CONNECT_COMPLETE, NULL);\r\n}\r\nstatic void print_ret_code(__u8 code)\r\n{\r\nswitch(code) {\r\ncase 0:\r\nprintk(KERN_INFO "Success\n");\r\nbreak;\r\ncase 1:\r\nIRDA_WARNING("IrLAN: Insufficient resources\n");\r\nbreak;\r\ncase 2:\r\nIRDA_WARNING("IrLAN: Invalid command format\n");\r\nbreak;\r\ncase 3:\r\nIRDA_WARNING("IrLAN: Command not supported\n");\r\nbreak;\r\ncase 4:\r\nIRDA_WARNING("IrLAN: Parameter not supported\n");\r\nbreak;\r\ncase 5:\r\nIRDA_WARNING("IrLAN: Value not supported\n");\r\nbreak;\r\ncase 6:\r\nIRDA_WARNING("IrLAN: Not open\n");\r\nbreak;\r\ncase 7:\r\nIRDA_WARNING("IrLAN: Authentication required\n");\r\nbreak;\r\ncase 8:\r\nIRDA_WARNING("IrLAN: Invalid password\n");\r\nbreak;\r\ncase 9:\r\nIRDA_WARNING("IrLAN: Protocol error\n");\r\nbreak;\r\ncase 255:\r\nIRDA_WARNING("IrLAN: Asynchronous status\n");\r\nbreak;\r\n}\r\n}\r\nvoid irlan_client_parse_response(struct irlan_cb *self, struct sk_buff *skb)\r\n{\r\n__u8 *frame;\r\n__u8 *ptr;\r\nint count;\r\nint ret;\r\n__u16 val_len;\r\nint i;\r\nchar *name;\r\nchar *value;\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_DEBUG(4, "%s() skb->len=%d\n", __func__ , (int) skb->len);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (!skb) {\r\nIRDA_ERROR("%s(), Got NULL skb!\n", __func__);\r\nreturn;\r\n}\r\nframe = skb->data;\r\nif (frame[0]) {\r\nprint_ret_code(frame[0]);\r\nreturn;\r\n}\r\nname = kmalloc(255, GFP_ATOMIC);\r\nif (!name)\r\nreturn;\r\nvalue = kmalloc(1016, GFP_ATOMIC);\r\nif (!value) {\r\nkfree(name);\r\nreturn;\r\n}\r\ncount = frame[1];\r\nIRDA_DEBUG(4, "%s(), got %d parameters\n", __func__ , count);\r\nptr = frame+2;\r\nfor (i=0; i<count;i++) {\r\nret = irlan_extract_param(ptr, name, value, &val_len);\r\nif (ret < 0) {\r\nIRDA_DEBUG(2, "%s(), IrLAN, Error!\n", __func__ );\r\nbreak;\r\n}\r\nptr += ret;\r\nirlan_check_response_param(self, name, value, val_len);\r\n}\r\nkfree(name);\r\nkfree(value);\r\n}\r\nstatic void irlan_check_response_param(struct irlan_cb *self, char *param,\r\nchar *value, int val_len)\r\n{\r\n__u16 tmp_cpu;\r\n__u8 *bytes;\r\nint i;\r\nIRDA_DEBUG(4, "%s(), parm=%s\n", __func__ , param);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (strcmp(param, "MEDIA") == 0) {\r\nif (strcmp(value, "802.3") == 0)\r\nself->media = MEDIA_802_3;\r\nelse\r\nself->media = MEDIA_802_5;\r\nreturn;\r\n}\r\nif (strcmp(param, "FILTER_TYPE") == 0) {\r\nif (strcmp(value, "DIRECTED") == 0)\r\nself->client.filter_type |= IRLAN_DIRECTED;\r\nelse if (strcmp(value, "FUNCTIONAL") == 0)\r\nself->client.filter_type |= IRLAN_FUNCTIONAL;\r\nelse if (strcmp(value, "GROUP") == 0)\r\nself->client.filter_type |= IRLAN_GROUP;\r\nelse if (strcmp(value, "MAC_FRAME") == 0)\r\nself->client.filter_type |= IRLAN_MAC_FRAME;\r\nelse if (strcmp(value, "MULTICAST") == 0)\r\nself->client.filter_type |= IRLAN_MULTICAST;\r\nelse if (strcmp(value, "BROADCAST") == 0)\r\nself->client.filter_type |= IRLAN_BROADCAST;\r\nelse if (strcmp(value, "IPX_SOCKET") == 0)\r\nself->client.filter_type |= IRLAN_IPX_SOCKET;\r\n}\r\nif (strcmp(param, "ACCESS_TYPE") == 0) {\r\nif (strcmp(value, "DIRECT") == 0)\r\nself->client.access_type = ACCESS_DIRECT;\r\nelse if (strcmp(value, "PEER") == 0)\r\nself->client.access_type = ACCESS_PEER;\r\nelse if (strcmp(value, "HOSTED") == 0)\r\nself->client.access_type = ACCESS_HOSTED;\r\nelse {\r\nIRDA_DEBUG(2, "%s(), unknown access type!\n", __func__ );\r\n}\r\n}\r\nif (strcmp(param, "IRLAN_VER") == 0) {\r\nIRDA_DEBUG(4, "IrLAN version %d.%d\n", (__u8) value[0],\r\n(__u8) value[1]);\r\nself->version[0] = value[0];\r\nself->version[1] = value[1];\r\nreturn;\r\n}\r\nif (strcmp(param, "DATA_CHAN") == 0) {\r\nself->dtsap_sel_data = value[0];\r\nIRDA_DEBUG(4, "Data TSAP = %02x\n", self->dtsap_sel_data);\r\nreturn;\r\n}\r\nif (strcmp(param, "CON_ARB") == 0) {\r\nmemcpy(&tmp_cpu, value, 2);\r\nle16_to_cpus(&tmp_cpu);\r\nself->client.recv_arb_val = tmp_cpu;\r\nIRDA_DEBUG(2, "%s(), receive arb val=%d\n", __func__ ,\r\nself->client.recv_arb_val);\r\n}\r\nif (strcmp(param, "MAX_FRAME") == 0) {\r\nmemcpy(&tmp_cpu, value, 2);\r\nle16_to_cpus(&tmp_cpu);\r\nself->client.max_frame = tmp_cpu;\r\nIRDA_DEBUG(4, "%s(), max frame=%d\n", __func__ ,\r\nself->client.max_frame);\r\n}\r\nif (strcmp(param, "RECONNECT_KEY") == 0) {\r\nIRDA_DEBUG(4, "Got reconnect key: ");\r\nmemcpy(self->client.reconnect_key, value, val_len);\r\nself->client.key_len = val_len;\r\nIRDA_DEBUG(4, "\n");\r\n}\r\nif (strcmp(param, "FILTER_ENTRY") == 0) {\r\nbytes = value;\r\nIRDA_DEBUG(4, "Ethernet address = %pM\n", bytes);\r\nfor (i = 0; i < 6; i++)\r\nself->dev->dev_addr[i] = bytes[i];\r\n}\r\n}\r\nvoid irlan_client_get_value_confirm(int result, __u16 obj_id,\r\nstruct ias_value *value, void *priv)\r\n{\r\nstruct irlan_cb *self;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(priv != NULL, return;);\r\nself = priv;\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\niriap_close(self->client.iriap);\r\nself->client.iriap = NULL;\r\nif (result != IAS_SUCCESS) {\r\nIRDA_DEBUG(2, "%s(), got NULL value!\n", __func__ );\r\nirlan_do_client_event(self, IRLAN_IAS_PROVIDER_NOT_AVAIL,\r\nNULL);\r\nreturn;\r\n}\r\nswitch (value->type) {\r\ncase IAS_INTEGER:\r\nself->dtsap_sel_ctrl = value->t.integer;\r\nif (value->t.integer != -1) {\r\nirlan_do_client_event(self, IRLAN_IAS_PROVIDER_AVAIL,\r\nNULL);\r\nreturn;\r\n}\r\nirias_delete_value(value);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), unknown type!\n", __func__ );\r\nbreak;\r\n}\r\nirlan_do_client_event(self, IRLAN_IAS_PROVIDER_NOT_AVAIL, NULL);\r\n}
