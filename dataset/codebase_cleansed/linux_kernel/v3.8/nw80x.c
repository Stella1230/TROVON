static void reg_w(struct gspca_dev *gspca_dev,\r\nu16 index,\r\nconst u8 *data,\r\nint len)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (len == 1)\r\nPDEBUG(D_USBO, "SET 00 0000 %04x %02x", index, *data);\r\nelse\r\nPDEBUG(D_USBO, "SET 00 0000 %04x %02x %02x ...",\r\nindex, *data, data[1]);\r\nmemcpy(gspca_dev->usb_buf, data, len);\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x00,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00,\r\nindex,\r\ngspca_dev->usb_buf,\r\nlen,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_r(struct gspca_dev *gspca_dev,\r\nu16 index,\r\nint len)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00, index,\r\ngspca_dev->usb_buf, len, 500);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\nreturn;\r\n}\r\nif (len == 1)\r\nPDEBUG(D_USBI, "GET 00 0000 %04x %02x",\r\nindex, gspca_dev->usb_buf[0]);\r\nelse\r\nPDEBUG(D_USBI, "GET 00 0000 %04x %02x %02x ..",\r\nindex, gspca_dev->usb_buf[0],\r\ngspca_dev->usb_buf[1]);\r\n}\r\nstatic void i2c_w(struct gspca_dev *gspca_dev,\r\nu8 i2c_addr,\r\nconst u8 *data,\r\nint len)\r\n{\r\nu8 val[2];\r\nint i;\r\nreg_w(gspca_dev, 0x0600, data + 1, len - 1);\r\nreg_w(gspca_dev, 0x0600, data, len);\r\nval[0] = len;\r\nval[1] = i2c_addr;\r\nreg_w(gspca_dev, 0x0502, val, 2);\r\nval[0] = 0x01;\r\nreg_w(gspca_dev, 0x0501, val, 1);\r\nfor (i = 5; --i >= 0; ) {\r\nmsleep(4);\r\nreg_r(gspca_dev, 0x0505, 1);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (gspca_dev->usb_buf[0] == 0)\r\nreturn;\r\n}\r\ngspca_dev->usb_err = -ETIME;\r\n}\r\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\r\nconst u8 *cmd)\r\n{\r\nu16 reg;\r\nint len;\r\nfor (;;) {\r\nreg = *cmd++ << 8;\r\nreg += *cmd++;\r\nlen = *cmd++;\r\nif (len == 0)\r\nbreak;\r\nif (cmd[-3] != I2C0)\r\nreg_w(gspca_dev, reg, cmd, len);\r\nelse\r\ni2c_w(gspca_dev, reg, cmd, len);\r\ncmd += len;\r\n}\r\n}\r\nstatic int swap_bits(int v)\r\n{\r\nint r, i;\r\nr = 0;\r\nfor (i = 0; i < 8; i++) {\r\nr <<= 1;\r\nif (v & 1)\r\nr++;\r\nv >>= 1;\r\n}\r\nreturn r;\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev, u8 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 v[2];\r\nswitch (sd->webcam) {\r\ncase P35u:\r\nreg_w(gspca_dev, 0x1026, &val, 1);\r\nbreak;\r\ncase Kr651us:\r\nval = swap_bits(val);\r\nv[0] = val << 3;\r\nv[1] = val >> 5;\r\nreg_w(gspca_dev, 0x101d, v, 2);\r\nbreak;\r\n}\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 v[2];\r\nswitch (sd->webcam) {\r\ncase P35u:\r\nv[0] = ((9 - val) << 3) | 0x01;\r\nreg_w(gspca_dev, 0x1019, v, 1);\r\nbreak;\r\ncase Cvideopro:\r\ncase DvcV6:\r\ncase Kritter:\r\ncase Kr651us:\r\nv[0] = val;\r\nv[1] = val >> 8;\r\nreg_w(gspca_dev, 0x101b, v, 2);\r\nbreak;\r\n}\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint w, h;\r\nif (!val) {\r\nsd->ag_cnt = -1;\r\nreturn;\r\n}\r\nsd->ag_cnt = AG_CNT_START;\r\nreg_r(gspca_dev, 0x1004, 1);\r\nif (gspca_dev->usb_buf[0] & 0x04) {\r\nsd->ae_res = gspca_dev->width * gspca_dev->height;\r\n} else {\r\nreg_r(gspca_dev, 0x1011, 8);\r\nw = (gspca_dev->usb_buf[1] << 8) + gspca_dev->usb_buf[0]\r\n- (gspca_dev->usb_buf[3] << 8) - gspca_dev->usb_buf[2];\r\nh = (gspca_dev->usb_buf[5] << 8) + gspca_dev->usb_buf[4]\r\n- (gspca_dev->usb_buf[7] << 8) - gspca_dev->usb_buf[6];\r\nsd->ae_res = h * w;\r\nif (sd->ae_res == 0)\r\nsd->ae_res = gspca_dev->width * gspca_dev->height;\r\n}\r\n}\r\nstatic int nw802_test_reg(struct gspca_dev *gspca_dev,\r\nu16 index,\r\nu8 value)\r\n{\r\nreg_w(gspca_dev, index, &value, 1);\r\nreg_r(gspca_dev, index, 1);\r\nreturn gspca_dev->usb_buf[0] == value;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif ((unsigned) webcam >= NWEBCAMS)\r\nwebcam = 0;\r\nsd->webcam = webcam;\r\ngspca_dev->cam.needs_full_bandwidth = 1;\r\nsd->ag_cnt = -1;\r\nif (!nw802_test_reg(gspca_dev, 0x0500, 0x55)) {\r\nsd->bridge = BRIDGE_NW802;\r\nif (sd->webcam == Generic800)\r\nsd->webcam = Generic802;\r\n} else if (!nw802_test_reg(gspca_dev, 0x109b, 0xaa)) {\r\nsd->bridge = BRIDGE_NW801;\r\nif (sd->webcam == Generic800)\r\nsd->webcam = P35u;\r\n} else if (id->idVendor == 0x06a5 && id->idProduct == 0xd800) {\r\nreg_r(gspca_dev, 0x0403, 1);\r\nPDEBUG(D_PROBE, "et31x110 sensor type %02x",\r\ngspca_dev->usb_buf[0]);\r\nswitch (gspca_dev->usb_buf[0] >> 1) {\r\ncase 0x00:\r\nif (sd->webcam == Generic800)\r\nsd->webcam = SpaceCam;\r\nbreak;\r\ncase 0x01:\r\nif (sd->webcam == Generic800)\r\nsd->webcam = Twinkle;\r\nbreak;\r\ncase 0x0a:\r\nif (sd->webcam == Generic800)\r\nsd->webcam = SpaceCam2;\r\nbreak;\r\n}\r\n}\r\nif (webcam_chip[sd->webcam] != sd->bridge) {\r\npr_err("Bad webcam type %d for NW80%d\n",\r\nsd->webcam, sd->bridge);\r\ngspca_dev->usb_err = -ENODEV;\r\nreturn gspca_dev->usb_err;\r\n}\r\nPDEBUG(D_PROBE, "Bridge nw80%d - type: %d", sd->bridge, sd->webcam);\r\nif (sd->bridge == BRIDGE_NW800) {\r\nswitch (sd->webcam) {\r\ncase DS3303u:\r\ngspca_dev->cam.cam_mode = cif_mode;\r\nbreak;\r\ndefault:\r\ngspca_dev->cam.cam_mode = &cif_mode[1];\r\nbreak;\r\n}\r\ngspca_dev->cam.nmodes = 1;\r\n} else {\r\ngspca_dev->cam.cam_mode = vga_mode;\r\nswitch (sd->webcam) {\r\ncase Kr651us:\r\ncase Proscope:\r\ncase P35u:\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\r\nbreak;\r\ndefault:\r\ngspca_dev->cam.nmodes = 1;\r\nbreak;\r\n}\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_NW800:\r\nswitch (sd->webcam) {\r\ncase SpaceCam:\r\nreg_w_buf(gspca_dev, spacecam_init);\r\nbreak;\r\ndefault:\r\nreg_w_buf(gspca_dev, nw800_init);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nswitch (sd->webcam) {\r\ncase Mustek300:\r\ncase P35u:\r\ncase Proscope:\r\nreg_w_buf(gspca_dev, proscope_init);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst u8 *cmd;\r\ncmd = webcam_start[sd->webcam];\r\nreg_w_buf(gspca_dev, cmd);\r\nswitch (sd->webcam) {\r\ncase P35u:\r\nif (gspca_dev->width == 320)\r\nreg_w_buf(gspca_dev, nw801_start_qvga);\r\nelse\r\nreg_w_buf(gspca_dev, nw801_start_vga);\r\nreg_w_buf(gspca_dev, nw801_start_2);\r\nbreak;\r\ncase Kr651us:\r\nif (gspca_dev->width == 320)\r\nreg_w_buf(gspca_dev, kr651_start_qvga);\r\nelse\r\nreg_w_buf(gspca_dev, kr651_start_vga);\r\nreg_w_buf(gspca_dev, kr651_start_2);\r\nbreak;\r\ncase Proscope:\r\nif (gspca_dev->width == 320)\r\nreg_w_buf(gspca_dev, proscope_start_qvga);\r\nelse\r\nreg_w_buf(gspca_dev, proscope_start_vga);\r\nreg_w_buf(gspca_dev, proscope_start_2);\r\nbreak;\r\n}\r\nsd->exp_too_high_cnt = 0;\r\nsd->exp_too_low_cnt = 0;\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 value;\r\nif (sd->bridge != BRIDGE_NW801) {\r\nvalue = 0x02;\r\nreg_w(gspca_dev, 0x0406, &value, 1);\r\n}\r\nswitch (sd->webcam) {\r\ncase Cvideopro:\r\ncase Kr651us:\r\ncase DvcV6:\r\ncase Kritter:\r\nvalue = 0xff;\r\nbreak;\r\ncase Dlink350c:\r\nvalue = 0x21;\r\nbreak;\r\ncase SpaceCam:\r\ncase SpaceCam2:\r\ncase Proscope:\r\ncase Twinkle:\r\nvalue = 0x01;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nreg_w(gspca_dev, 0x0404, &value, 1);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nif (data[0] == 0x00 && data[1] == 0x00\r\n&& data[6] == 0xff && data[7] == 0xff) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data + 8, len - 8);\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint luma;\r\nif (sd->ag_cnt < 0)\r\nreturn;\r\nif (--sd->ag_cnt >= 0)\r\nreturn;\r\nsd->ag_cnt = AG_CNT_START;\r\nreg_r(gspca_dev, sd->bridge == BRIDGE_NW801 ? 0x080d : 0x080c, 4);\r\nluma = (gspca_dev->usb_buf[3] << 24) + (gspca_dev->usb_buf[2] << 16)\r\n+ (gspca_dev->usb_buf[1] << 8) + gspca_dev->usb_buf[0];\r\nluma /= sd->ae_res;\r\nswitch (sd->webcam) {\r\ncase P35u:\r\ngspca_coarse_grained_expo_autogain(gspca_dev, luma, 100, 5);\r\nbreak;\r\ndefault:\r\ngspca_expo_autogain(gspca_dev, luma, 100, 5, 230, 0);\r\nbreak;\r\n}\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nif (ctrl->is_new)\r\nsetautogain(gspca_dev, ctrl->val);\r\nif (!ctrl->val) {\r\nif (gspca_dev->gain->is_new)\r\nsetgain(gspca_dev, gspca_dev->gain->val);\r\nif (gspca_dev->exposure->is_new)\r\nsetexposure(gspca_dev,\r\ngspca_dev->exposure->val);\r\n}\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nsetexposure(gspca_dev, gspca_dev->exposure->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 3);\r\nswitch (sd->webcam) {\r\ncase P35u:\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 127 / 5 * 2);\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 9, 1, 9);\r\nbreak;\r\ncase Kr651us:\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 253, 1, 128);\r\ncase Cvideopro:\r\ncase DvcV6:\r\ncase Kritter:\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 315, 1, 150);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nif (gspca_dev->autogain)\r\nv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
