static int wl1271_boot_set_ecpu_ctrl(struct wl1271 *wl, u32 flag)\r\n{\r\nu32 cpu_ctrl;\r\nint ret;\r\nret = wlcore_read_reg(wl, REG_ECPU_CONTROL, &cpu_ctrl);\r\nif (ret < 0)\r\ngoto out;\r\ncpu_ctrl |= flag;\r\nret = wlcore_write_reg(wl, REG_ECPU_CONTROL, cpu_ctrl);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int wlcore_boot_parse_fw_ver(struct wl1271 *wl,\r\nstruct wl1271_static_data *static_data)\r\n{\r\nint ret;\r\nstrncpy(wl->chip.fw_ver_str, static_data->fw_version,\r\nsizeof(wl->chip.fw_ver_str));\r\nwl->chip.fw_ver_str[sizeof(wl->chip.fw_ver_str) - 1] = '\0';\r\nret = sscanf(wl->chip.fw_ver_str + 4, "%u.%u.%u.%u.%u",\r\n&wl->chip.fw_ver[0], &wl->chip.fw_ver[1],\r\n&wl->chip.fw_ver[2], &wl->chip.fw_ver[3],\r\n&wl->chip.fw_ver[4]);\r\nif (ret != 5) {\r\nwl1271_warning("fw version incorrect value");\r\nmemset(wl->chip.fw_ver, 0, sizeof(wl->chip.fw_ver));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = wlcore_identify_fw(wl);\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int wlcore_validate_fw_ver(struct wl1271 *wl)\r\n{\r\nunsigned int *fw_ver = wl->chip.fw_ver;\r\nunsigned int *min_ver = wl->min_fw_ver;\r\nif (min_ver[FW_VER_CHIP] != fw_ver[FW_VER_CHIP])\r\ngoto fail;\r\nif (min_ver[FW_VER_IF_TYPE] < fw_ver[FW_VER_IF_TYPE])\r\ngoto out;\r\nelse if (min_ver[FW_VER_IF_TYPE] > fw_ver[FW_VER_IF_TYPE])\r\ngoto fail;\r\nif (min_ver[FW_VER_MAJOR] < fw_ver[FW_VER_MAJOR])\r\ngoto out;\r\nelse if (min_ver[FW_VER_MAJOR] > fw_ver[FW_VER_MAJOR])\r\ngoto fail;\r\nif (min_ver[FW_VER_SUBTYPE] < fw_ver[FW_VER_SUBTYPE])\r\ngoto out;\r\nelse if (min_ver[FW_VER_SUBTYPE] > fw_ver[FW_VER_SUBTYPE])\r\ngoto fail;\r\nif (min_ver[FW_VER_MINOR] < fw_ver[FW_VER_MINOR])\r\ngoto out;\r\nelse if (min_ver[FW_VER_MINOR] > fw_ver[FW_VER_MINOR])\r\ngoto fail;\r\nout:\r\nreturn 0;\r\nfail:\r\nwl1271_error("Your WiFi FW version (%u.%u.%u.%u.%u) is outdated.\n"\r\n"Please use at least FW %u.%u.%u.%u.%u.\n"\r\n"You can get more information at:\n"\r\n"http://wireless.kernel.org/en/users/Drivers/wl12xx",\r\nfw_ver[FW_VER_CHIP], fw_ver[FW_VER_IF_TYPE],\r\nfw_ver[FW_VER_MAJOR], fw_ver[FW_VER_SUBTYPE],\r\nfw_ver[FW_VER_MINOR], min_ver[FW_VER_CHIP],\r\nmin_ver[FW_VER_IF_TYPE], min_ver[FW_VER_MAJOR],\r\nmin_ver[FW_VER_SUBTYPE], min_ver[FW_VER_MINOR]);\r\nreturn -EINVAL;\r\n}\r\nstatic int wlcore_boot_static_data(struct wl1271 *wl)\r\n{\r\nstruct wl1271_static_data *static_data;\r\nsize_t len = sizeof(*static_data) + wl->static_data_priv_len;\r\nint ret;\r\nstatic_data = kmalloc(len, GFP_KERNEL);\r\nif (!static_data) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = wlcore_read(wl, wl->cmd_box_addr, static_data, len, false);\r\nif (ret < 0)\r\ngoto out_free;\r\nret = wlcore_boot_parse_fw_ver(wl, static_data);\r\nif (ret < 0)\r\ngoto out_free;\r\nret = wlcore_validate_fw_ver(wl);\r\nif (ret < 0)\r\ngoto out_free;\r\nret = wlcore_handle_static_data(wl, static_data);\r\nif (ret < 0)\r\ngoto out_free;\r\nout_free:\r\nkfree(static_data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,\r\nsize_t fw_data_len, u32 dest)\r\n{\r\nstruct wlcore_partition_set partition;\r\nint addr, chunk_num, partition_limit;\r\nu8 *p, *chunk;\r\nint ret;\r\nwl1271_debug(DEBUG_BOOT, "starting firmware upload");\r\nwl1271_debug(DEBUG_BOOT, "fw_data_len %zd chunk_size %d",\r\nfw_data_len, CHUNK_SIZE);\r\nif ((fw_data_len % 4) != 0) {\r\nwl1271_error("firmware length not multiple of four");\r\nreturn -EIO;\r\n}\r\nchunk = kmalloc(CHUNK_SIZE, GFP_KERNEL);\r\nif (!chunk) {\r\nwl1271_error("allocation for firmware upload chunk failed");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&partition, &wl->ptable[PART_DOWN], sizeof(partition));\r\npartition.mem.start = dest;\r\nret = wlcore_set_partition(wl, &partition);\r\nif (ret < 0)\r\ngoto out;\r\nchunk_num = 0;\r\npartition_limit = wl->ptable[PART_DOWN].mem.size;\r\nwhile (chunk_num < fw_data_len / CHUNK_SIZE) {\r\naddr = dest + (chunk_num + 2) * CHUNK_SIZE;\r\nif (addr > partition_limit) {\r\naddr = dest + chunk_num * CHUNK_SIZE;\r\npartition_limit = chunk_num * CHUNK_SIZE +\r\nwl->ptable[PART_DOWN].mem.size;\r\npartition.mem.start = addr;\r\nret = wlcore_set_partition(wl, &partition);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\naddr = dest + chunk_num * CHUNK_SIZE;\r\np = buf + chunk_num * CHUNK_SIZE;\r\nmemcpy(chunk, p, CHUNK_SIZE);\r\nwl1271_debug(DEBUG_BOOT, "uploading fw chunk 0x%p to 0x%x",\r\np, addr);\r\nret = wlcore_write(wl, addr, chunk, CHUNK_SIZE, false);\r\nif (ret < 0)\r\ngoto out;\r\nchunk_num++;\r\n}\r\naddr = dest + chunk_num * CHUNK_SIZE;\r\np = buf + chunk_num * CHUNK_SIZE;\r\nmemcpy(chunk, p, fw_data_len % CHUNK_SIZE);\r\nwl1271_debug(DEBUG_BOOT, "uploading fw last chunk (%zd B) 0x%p to 0x%x",\r\nfw_data_len % CHUNK_SIZE, p, addr);\r\nret = wlcore_write(wl, addr, chunk, fw_data_len % CHUNK_SIZE, false);\r\nout:\r\nkfree(chunk);\r\nreturn ret;\r\n}\r\nint wlcore_boot_upload_firmware(struct wl1271 *wl)\r\n{\r\nu32 chunks, addr, len;\r\nint ret = 0;\r\nu8 *fw;\r\nfw = wl->fw;\r\nchunks = be32_to_cpup((__be32 *) fw);\r\nfw += sizeof(u32);\r\nwl1271_debug(DEBUG_BOOT, "firmware chunks to be uploaded: %u", chunks);\r\nwhile (chunks--) {\r\naddr = be32_to_cpup((__be32 *) fw);\r\nfw += sizeof(u32);\r\nlen = be32_to_cpup((__be32 *) fw);\r\nfw += sizeof(u32);\r\nif (len > 300000) {\r\nwl1271_info("firmware chunk too long: %u", len);\r\nreturn -EINVAL;\r\n}\r\nwl1271_debug(DEBUG_BOOT, "chunk %d addr 0x%x len %u",\r\nchunks, addr, len);\r\nret = wl1271_boot_upload_firmware_chunk(wl, fw, len, addr);\r\nif (ret != 0)\r\nbreak;\r\nfw += len;\r\n}\r\nreturn ret;\r\n}\r\nint wlcore_boot_upload_nvs(struct wl1271 *wl)\r\n{\r\nsize_t nvs_len, burst_len;\r\nint i;\r\nu32 dest_addr, val;\r\nu8 *nvs_ptr, *nvs_aligned;\r\nint ret;\r\nif (wl->nvs == NULL) {\r\nwl1271_error("NVS file is needed during boot");\r\nreturn -ENODEV;\r\n}\r\nif (wl->quirks & WLCORE_QUIRK_LEGACY_NVS) {\r\nstruct wl1271_nvs_file *nvs =\r\n(struct wl1271_nvs_file *)wl->nvs;\r\nif (wl->nvs_len == sizeof(struct wl1271_nvs_file) ||\r\nwl->nvs_len == WL1271_INI_LEGACY_NVS_FILE_SIZE) {\r\nif (nvs->general_params.dual_mode_select)\r\nwl->enable_11a = true;\r\n}\r\nif (wl->nvs_len != sizeof(struct wl1271_nvs_file) &&\r\n(wl->nvs_len != WL1271_INI_LEGACY_NVS_FILE_SIZE ||\r\nwl->enable_11a)) {\r\nwl1271_error("nvs size is not as expected: %zu != %zu",\r\nwl->nvs_len, sizeof(struct wl1271_nvs_file));\r\nkfree(wl->nvs);\r\nwl->nvs = NULL;\r\nwl->nvs_len = 0;\r\nreturn -EILSEQ;\r\n}\r\nnvs_len = sizeof(nvs->nvs);\r\nnvs_ptr = (u8 *) nvs->nvs;\r\n} else {\r\nstruct wl128x_nvs_file *nvs = (struct wl128x_nvs_file *)wl->nvs;\r\nif (wl->nvs_len == sizeof(struct wl128x_nvs_file)) {\r\nif (nvs->general_params.dual_mode_select)\r\nwl->enable_11a = true;\r\n} else {\r\nwl1271_error("nvs size is not as expected: %zu != %zu",\r\nwl->nvs_len,\r\nsizeof(struct wl128x_nvs_file));\r\nkfree(wl->nvs);\r\nwl->nvs = NULL;\r\nwl->nvs_len = 0;\r\nreturn -EILSEQ;\r\n}\r\nnvs_len = sizeof(nvs->nvs);\r\nnvs_ptr = (u8 *)nvs->nvs;\r\n}\r\nnvs_ptr[11] = wl->addresses[0].addr[0];\r\nnvs_ptr[10] = wl->addresses[0].addr[1];\r\nnvs_ptr[6] = wl->addresses[0].addr[2];\r\nnvs_ptr[5] = wl->addresses[0].addr[3];\r\nnvs_ptr[4] = wl->addresses[0].addr[4];\r\nnvs_ptr[3] = wl->addresses[0].addr[5];\r\nwhile (nvs_ptr[0]) {\r\nburst_len = nvs_ptr[0];\r\ndest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));\r\ndest_addr += wl->curr_part.reg.start;\r\nnvs_ptr += 3;\r\nfor (i = 0; i < burst_len; i++) {\r\nif (nvs_ptr + 3 >= (u8 *) wl->nvs + nvs_len)\r\ngoto out_badnvs;\r\nval = (nvs_ptr[0] | (nvs_ptr[1] << 8)\r\n| (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));\r\nwl1271_debug(DEBUG_BOOT,\r\n"nvs burst write 0x%x: 0x%x",\r\ndest_addr, val);\r\nret = wlcore_write32(wl, dest_addr, val);\r\nif (ret < 0)\r\nreturn ret;\r\nnvs_ptr += 4;\r\ndest_addr += 4;\r\n}\r\nif (nvs_ptr >= (u8 *) wl->nvs + nvs_len)\r\ngoto out_badnvs;\r\n}\r\nnvs_ptr = (u8 *)wl->nvs +\r\nALIGN(nvs_ptr - (u8 *)wl->nvs + 7, 4);\r\nif (nvs_ptr >= (u8 *) wl->nvs + nvs_len)\r\ngoto out_badnvs;\r\nnvs_len -= nvs_ptr - (u8 *)wl->nvs;\r\nret = wlcore_set_partition(wl, &wl->ptable[PART_WORK]);\r\nif (ret < 0)\r\nreturn ret;\r\nnvs_aligned = kmemdup(nvs_ptr, nvs_len, GFP_KERNEL);\r\nif (!nvs_aligned)\r\nreturn -ENOMEM;\r\nret = wlcore_write_data(wl, REG_CMD_MBOX_ADDRESS, nvs_aligned, nvs_len,\r\nfalse);\r\nkfree(nvs_aligned);\r\nreturn ret;\r\nout_badnvs:\r\nwl1271_error("nvs data is malformed");\r\nreturn -EILSEQ;\r\n}\r\nint wlcore_boot_run_firmware(struct wl1271 *wl)\r\n{\r\nint loop, ret;\r\nu32 chip_id, intr;\r\nret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wl1271_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wlcore_read_reg(wl, REG_CHIP_ID_B, &chip_id);\r\nif (ret < 0)\r\nreturn ret;\r\nwl1271_debug(DEBUG_BOOT, "chip id after firmware boot: 0x%x", chip_id);\r\nif (chip_id != wl->chip.id) {\r\nwl1271_error("chip id doesn't match after firmware boot");\r\nreturn -EIO;\r\n}\r\nloop = 0;\r\nwhile (loop++ < INIT_LOOP) {\r\nudelay(INIT_LOOP_DELAY);\r\nret = wlcore_read_reg(wl, REG_INTERRUPT_NO_CLEAR, &intr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (intr == 0xffffffff) {\r\nwl1271_error("error reading hardware complete "\r\n"init indication");\r\nreturn -EIO;\r\n}\r\nelse if (intr & WL1271_ACX_INTR_INIT_COMPLETE) {\r\nret = wlcore_write_reg(wl, REG_INTERRUPT_ACK,\r\nWL1271_ACX_INTR_INIT_COMPLETE);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\n}\r\nif (loop > INIT_LOOP) {\r\nwl1271_error("timeout waiting for the hardware to "\r\n"complete initialization");\r\nreturn -EIO;\r\n}\r\nret = wlcore_read_reg(wl, REG_COMMAND_MAILBOX_PTR, &wl->cmd_box_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nwl1271_debug(DEBUG_MAILBOX, "cmd_box_addr 0x%x", wl->cmd_box_addr);\r\nret = wlcore_read_reg(wl, REG_EVENT_MAILBOX_PTR, &wl->mbox_ptr[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nwl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);\r\nwl1271_debug(DEBUG_MAILBOX, "MBOX ptrs: 0x%x 0x%x",\r\nwl->mbox_ptr[0], wl->mbox_ptr[1]);\r\nret = wlcore_boot_static_data(wl);\r\nif (ret < 0) {\r\nwl1271_error("error getting static data");\r\nreturn ret;\r\n}\r\nwl->event_mask = BSS_LOSE_EVENT_ID |\r\nREGAINED_BSS_EVENT_ID |\r\nSCAN_COMPLETE_EVENT_ID |\r\nROLE_STOP_COMPLETE_EVENT_ID |\r\nRSSI_SNR_TRIGGER_0_EVENT_ID |\r\nPSPOLL_DELIVERY_FAILURE_EVENT_ID |\r\nSOFT_GEMINI_SENSE_EVENT_ID |\r\nPERIODIC_SCAN_REPORT_EVENT_ID |\r\nPERIODIC_SCAN_COMPLETE_EVENT_ID |\r\nDUMMY_PACKET_EVENT_ID |\r\nPEER_REMOVE_COMPLETE_EVENT_ID |\r\nBA_SESSION_RX_CONSTRAINT_EVENT_ID |\r\nREMAIN_ON_CHANNEL_COMPLETE_EVENT_ID |\r\nINACTIVE_STA_EVENT_ID |\r\nMAX_TX_RETRY_EVENT_ID |\r\nCHANNEL_SWITCH_COMPLETE_EVENT_ID;\r\nret = wl1271_event_unmask(wl);\r\nif (ret < 0) {\r\nwl1271_error("EVENT mask setting failed");\r\nreturn ret;\r\n}\r\nret = wlcore_set_partition(wl, &wl->ptable[PART_WORK]);\r\nreturn ret;\r\n}
