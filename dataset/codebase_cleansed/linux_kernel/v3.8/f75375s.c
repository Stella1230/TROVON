static inline int f75375_read8(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline u16 f75375_read16(struct i2c_client *client, u8 reg)\r\n{\r\nreturn (i2c_smbus_read_byte_data(client, reg) << 8)\r\n| i2c_smbus_read_byte_data(client, reg + 1);\r\n}\r\nstatic inline void f75375_write8(struct i2c_client *client, u8 reg,\r\nu8 value)\r\n{\r\ni2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic inline void f75375_write16(struct i2c_client *client, u8 reg,\r\nu16 value)\r\n{\r\nint err = i2c_smbus_write_byte_data(client, reg, (value >> 8));\r\nif (err)\r\nreturn;\r\ni2c_smbus_write_byte_data(client, reg + 1, (value & 0xFF));\r\n}\r\nstatic void f75375_write_pwm(struct i2c_client *client, int nr)\r\n{\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nif (data->kind == f75387)\r\nf75375_write16(client, F75375_REG_FAN_EXP(nr), data->pwm[nr]);\r\nelse\r\nf75375_write8(client, F75375_REG_FAN_PWM_DUTY(nr),\r\ndata->pwm[nr]);\r\n}\r\nstatic struct f75375_data *f75375_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nint nr;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_limits + 60 * HZ)\r\n|| !data->valid) {\r\nfor (nr = 0; nr < 2; nr++) {\r\ndata->temp_high[nr] =\r\nf75375_read8(client, F75375_REG_TEMP_HIGH(nr));\r\ndata->temp_max_hyst[nr] =\r\nf75375_read8(client, F75375_REG_TEMP_HYST(nr));\r\ndata->fan_max[nr] =\r\nf75375_read16(client, F75375_REG_FAN_FULL(nr));\r\ndata->fan_min[nr] =\r\nf75375_read16(client, F75375_REG_FAN_MIN(nr));\r\ndata->fan_target[nr] =\r\nf75375_read16(client, F75375_REG_FAN_EXP(nr));\r\n}\r\nfor (nr = 0; nr < 4; nr++) {\r\ndata->in_max[nr] =\r\nf75375_read8(client, F75375_REG_VOLT_HIGH(nr));\r\ndata->in_min[nr] =\r\nf75375_read8(client, F75375_REG_VOLT_LOW(nr));\r\n}\r\ndata->fan_timer = f75375_read8(client, F75375_REG_FAN_TIMER);\r\ndata->last_limits = jiffies;\r\n}\r\nif (time_after(jiffies, data->last_updated + 2 * HZ)\r\n|| !data->valid) {\r\nfor (nr = 0; nr < 2; nr++) {\r\ndata->pwm[nr] = f75375_read8(client,\r\nF75375_REG_FAN_PWM_DUTY(nr));\r\ndata->temp11[nr] =\r\nf75375_read8(client, F75375_REG_TEMP(nr)) << 8;\r\nif (data->kind == f75387)\r\ndata->temp11[nr] |=\r\nf75375_read8(client,\r\nF75387_REG_TEMP11_LSB(nr));\r\ndata->fan[nr] =\r\nf75375_read16(client, F75375_REG_FAN(nr));\r\n}\r\nfor (nr = 0; nr < 4; nr++)\r\ndata->in[nr] =\r\nf75375_read8(client, F75375_REG_VOLT(nr));\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic inline u16 rpm_from_reg(u16 reg)\r\n{\r\nif (reg == 0 || reg == 0xffff)\r\nreturn 0;\r\nreturn 1500000 / reg;\r\n}\r\nstatic inline u16 rpm_to_reg(int rpm)\r\n{\r\nif (rpm < 367 || rpm > 0xffff)\r\nreturn 0xffff;\r\nreturn 1500000 / rpm;\r\n}\r\nstatic bool duty_mode_enabled(u8 pwm_enable)\r\n{\r\nswitch (pwm_enable) {\r\ncase 0:\r\ncase 1:\r\ncase 4:\r\nreturn true;\r\ncase 2:\r\ncase 3:\r\nreturn false;\r\ndefault:\r\nBUG();\r\nreturn true;\r\n}\r\n}\r\nstatic bool auto_mode_enabled(u8 pwm_enable)\r\n{\r\nswitch (pwm_enable) {\r\ncase 0:\r\ncase 1:\r\ncase 3:\r\nreturn false;\r\ncase 2:\r\ncase 4:\r\nreturn true;\r\ndefault:\r\nBUG();\r\nreturn false;\r\n}\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = rpm_to_reg(val);\r\nf75375_write16(client, F75375_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_target(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (auto_mode_enabled(data->pwm_enable[nr]))\r\nreturn -EINVAL;\r\nif (data->kind == f75387 && duty_mode_enabled(data->pwm_enable[nr]))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_target[nr] = rpm_to_reg(val);\r\nf75375_write16(client, F75375_REG_FAN_EXP(nr), data->fan_target[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (auto_mode_enabled(data->pwm_enable[nr]) ||\r\n!duty_mode_enabled(data->pwm_enable[nr]))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = SENSORS_LIMIT(val, 0, 255);\r\nf75375_write_pwm(client, nr);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_enable[nr]);\r\n}\r\nstatic int set_pwm_enable_direct(struct i2c_client *client, int nr, int val)\r\n{\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nu8 fanmode;\r\nif (val < 0 || val > 4)\r\nreturn -EINVAL;\r\nfanmode = f75375_read8(client, F75375_REG_FAN_TIMER);\r\nif (data->kind == f75387) {\r\nif (duty_mode_enabled(data->pwm_enable[nr]) !=\r\nduty_mode_enabled(val))\r\nreturn -EOPNOTSUPP;\r\nfanmode &= ~(1 << F75387_FAN_DUTY_MODE(nr));\r\nfanmode &= ~(1 << F75387_FAN_MANU_MODE(nr));\r\nswitch (val) {\r\ncase 0:\r\nfanmode |= (1 << F75387_FAN_MANU_MODE(nr));\r\nfanmode |= (1 << F75387_FAN_DUTY_MODE(nr));\r\ndata->pwm[nr] = 255;\r\nbreak;\r\ncase 1:\r\nfanmode |= (1 << F75387_FAN_MANU_MODE(nr));\r\nfanmode |= (1 << F75387_FAN_DUTY_MODE(nr));\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 3:\r\nfanmode |= (1 << F75387_FAN_MANU_MODE(nr));\r\nbreak;\r\ncase 4:\r\nfanmode |= (1 << F75387_FAN_DUTY_MODE(nr));\r\nbreak;\r\n}\r\n} else {\r\nfanmode &= ~(3 << FAN_CTRL_MODE(nr));\r\nswitch (val) {\r\ncase 0:\r\nfanmode |= (3 << FAN_CTRL_MODE(nr));\r\ndata->pwm[nr] = 255;\r\nbreak;\r\ncase 1:\r\nfanmode |= (3 << FAN_CTRL_MODE(nr));\r\nbreak;\r\ncase 2:\r\nfanmode |= (1 << FAN_CTRL_MODE(nr));\r\nbreak;\r\ncase 3:\r\nbreak;\r\ncase 4:\r\nreturn -EINVAL;\r\n}\r\n}\r\nf75375_write8(client, F75375_REG_FAN_TIMER, fanmode);\r\ndata->pwm_enable[nr] = val;\r\nif (val == 0)\r\nf75375_write_pwm(client, nr);\r\nreturn 0;\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nerr = set_pwm_enable_direct(client, nr, val);\r\nmutex_unlock(&data->update_lock);\r\nreturn err ? err : count;\r\n}\r\nstatic ssize_t set_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nu8 conf;\r\nchar reg, ctrl;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (!(val == 0 || val == 1))\r\nreturn -EINVAL;\r\nif (data->kind == f75373 && val == 0)\r\nreturn -EINVAL;\r\nif (data->kind == f75387) {\r\nreg = F75375_REG_FAN_TIMER;\r\nctrl = F75387_FAN_CTRL_LINEAR(nr);\r\n} else {\r\nreg = F75375_REG_CONFIG1;\r\nctrl = F75375_FAN_CTRL_LINEAR(nr);\r\n}\r\nmutex_lock(&data->update_lock);\r\nconf = f75375_read8(client, reg);\r\nconf &= ~(1 << ctrl);\r\nif (val == 0)\r\nconf |= (1 << ctrl);\r\nf75375_write8(client, reg, conf);\r\ndata->pwm_mode[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm[nr]);\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_mode[nr]);\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", VOLT_FROM_REG(data->in[nr]));\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", VOLT_FROM_REG(data->in_max[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", VOLT_FROM_REG(data->in_min[nr]));\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = SENSORS_LIMIT(VOLT_TO_REG(val), 0, 0xff);\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[nr] = val;\r\nf75375_write8(client, F75375_REG_VOLT_HIGH(nr), data->in_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = SENSORS_LIMIT(VOLT_TO_REG(val), 0, 0xff);\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[nr] = val;\r\nf75375_write8(client, F75375_REG_VOLT_LOW(nr), data->in_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp11(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP11_FROM_REG(data->temp11[nr]));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_high[nr]));\r\n}\r\nstatic ssize_t show_temp_max_hyst(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct f75375_data *data = f75375_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max_hyst[nr]));\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = SENSORS_LIMIT(TEMP_TO_REG(val), 0, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_high[nr] = val;\r\nf75375_write8(client, F75375_REG_TEMP_HIGH(nr), data->temp_high[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_max_hyst(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = SENSORS_LIMIT(TEMP_TO_REG(val), 0, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max_hyst[nr] = val;\r\nf75375_write8(client, F75375_REG_TEMP_HYST(nr),\r\ndata->temp_max_hyst[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void f75375_init(struct i2c_client *client, struct f75375_data *data,\r\nstruct f75375s_platform_data *f75375s_pdata)\r\n{\r\nint nr;\r\nif (!f75375s_pdata) {\r\nu8 conf, mode;\r\nint nr;\r\nconf = f75375_read8(client, F75375_REG_CONFIG1);\r\nmode = f75375_read8(client, F75375_REG_FAN_TIMER);\r\nfor (nr = 0; nr < 2; nr++) {\r\nif (data->kind == f75387) {\r\nbool manu, duty;\r\nif (!(mode & (1 << F75387_FAN_CTRL_LINEAR(nr))))\r\ndata->pwm_mode[nr] = 1;\r\nmanu = ((mode >> F75387_FAN_MANU_MODE(nr)) & 1);\r\nduty = ((mode >> F75387_FAN_DUTY_MODE(nr)) & 1);\r\nif (!manu && duty)\r\ndata->pwm_enable[nr] = 4;\r\nelse if (manu && !duty)\r\ndata->pwm_enable[nr] = 3;\r\nelse if (!manu && !duty)\r\ndata->pwm_enable[nr] = 2;\r\nelse\r\ndata->pwm_enable[nr] = 1;\r\n} else {\r\nif (!(conf & (1 << F75375_FAN_CTRL_LINEAR(nr))))\r\ndata->pwm_mode[nr] = 1;\r\nswitch ((mode >> FAN_CTRL_MODE(nr)) & 3) {\r\ncase 0:\r\ndata->pwm_enable[nr] = 3;\r\nbreak;\r\ncase 1:\r\ndata->pwm_enable[nr] = 2;\r\nbreak;\r\ndefault:\r\ndata->pwm_enable[nr] = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nset_pwm_enable_direct(client, 0, f75375s_pdata->pwm_enable[0]);\r\nset_pwm_enable_direct(client, 1, f75375s_pdata->pwm_enable[1]);\r\nfor (nr = 0; nr < 2; nr++) {\r\nif (auto_mode_enabled(f75375s_pdata->pwm_enable[nr]) ||\r\n!duty_mode_enabled(f75375s_pdata->pwm_enable[nr]))\r\ncontinue;\r\ndata->pwm[nr] = SENSORS_LIMIT(f75375s_pdata->pwm[nr], 0, 255);\r\nf75375_write_pwm(client, nr);\r\n}\r\n}\r\nstatic int f75375_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct f75375_data *data;\r\nstruct f75375s_platform_data *f75375s_pdata = client->dev.platform_data;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct f75375_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->kind = id->driver_data;\r\nerr = sysfs_create_group(&client->dev.kobj, &f75375_group);\r\nif (err)\r\nreturn err;\r\nif (data->kind != f75373) {\r\nerr = sysfs_chmod_file(&client->dev.kobj,\r\n&sensor_dev_attr_pwm1_mode.dev_attr.attr,\r\nS_IRUGO | S_IWUSR);\r\nif (err)\r\ngoto exit_remove;\r\nerr = sysfs_chmod_file(&client->dev.kobj,\r\n&sensor_dev_attr_pwm2_mode.dev_attr.attr,\r\nS_IRUGO | S_IWUSR);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nf75375_init(client, data, f75375s_pdata);\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &f75375_group);\r\nreturn err;\r\n}\r\nstatic int f75375_remove(struct i2c_client *client)\r\n{\r\nstruct f75375_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &f75375_group);\r\nreturn 0;\r\n}\r\nstatic int f75375_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nu16 vendid, chipid;\r\nu8 version;\r\nconst char *name;\r\nvendid = f75375_read16(client, F75375_REG_VENDOR);\r\nchipid = f75375_read16(client, F75375_CHIP_ID);\r\nif (vendid != 0x1934)\r\nreturn -ENODEV;\r\nif (chipid == 0x0306)\r\nname = "f75375";\r\nelse if (chipid == 0x0204)\r\nname = "f75373";\r\nelse if (chipid == 0x0410)\r\nname = "f75387";\r\nelse\r\nreturn -ENODEV;\r\nversion = f75375_read8(client, F75375_REG_VERSION);\r\ndev_info(&adapter->dev, "found %s version: %02X\n", name, version);\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}
