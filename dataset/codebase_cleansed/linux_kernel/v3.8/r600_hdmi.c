static void r600_hdmi_calc_cts(uint32_t clock, int *CTS, int N, int freq)\r\n{\r\nif (*CTS == 0)\r\n*CTS = clock * N / (128 * freq) * 1000;\r\nDRM_DEBUG("Using ACR timing N=%d CTS=%d for frequency %d\n",\r\nN, *CTS, freq);\r\n}\r\nstruct radeon_hdmi_acr r600_hdmi_acr(uint32_t clock)\r\n{\r\nstruct radeon_hdmi_acr res;\r\nu8 i;\r\nfor (i = 0; r600_hdmi_predefined_acr[i].clock != clock &&\r\nr600_hdmi_predefined_acr[i].clock != 0; i++)\r\n;\r\nres = r600_hdmi_predefined_acr[i];\r\nr600_hdmi_calc_cts(clock, &res.cts_32khz, res.n_32khz, 32000);\r\nr600_hdmi_calc_cts(clock, &res.cts_44_1khz, res.n_44_1khz, 44100);\r\nr600_hdmi_calc_cts(clock, &res.cts_48khz, res.n_48khz, 48000);\r\nreturn res;\r\n}\r\nstatic void r600_hdmi_update_ACR(struct drm_encoder *encoder, uint32_t clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_hdmi_acr acr = r600_hdmi_acr(clock);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nWREG32(HDMI0_ACR_32_0 + offset, HDMI0_ACR_CTS_32(acr.cts_32khz));\r\nWREG32(HDMI0_ACR_32_1 + offset, acr.n_32khz);\r\nWREG32(HDMI0_ACR_44_0 + offset, HDMI0_ACR_CTS_44(acr.cts_44_1khz));\r\nWREG32(HDMI0_ACR_44_1 + offset, acr.n_44_1khz);\r\nWREG32(HDMI0_ACR_48_0 + offset, HDMI0_ACR_CTS_48(acr.cts_48khz));\r\nWREG32(HDMI0_ACR_48_1 + offset, acr.n_48khz);\r\n}\r\nstatic void r600_hdmi_infoframe_checksum(uint8_t packetType,\r\nuint8_t versionNumber,\r\nuint8_t length,\r\nuint8_t *frame)\r\n{\r\nint i;\r\nframe[0] = packetType + versionNumber + length;\r\nfor (i = 1; i <= length; i++)\r\nframe[0] += frame[i];\r\nframe[0] = 0x100 - frame[0];\r\n}\r\nstatic void r600_hdmi_videoinfoframe(\r\nstruct drm_encoder *encoder,\r\nenum r600_hdmi_color_format color_format,\r\nint active_information_present,\r\nuint8_t active_format_aspect_ratio,\r\nuint8_t scan_information,\r\nuint8_t colorimetry,\r\nuint8_t ex_colorimetry,\r\nuint8_t quantization,\r\nint ITC,\r\nuint8_t picture_aspect_ratio,\r\nuint8_t video_format_identification,\r\nuint8_t pixel_repetition,\r\nuint8_t non_uniform_picture_scaling,\r\nuint8_t bar_info_data_valid,\r\nuint16_t top_bar,\r\nuint16_t bottom_bar,\r\nuint16_t left_bar,\r\nuint16_t right_bar\r\n)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nuint8_t frame[14];\r\nframe[0x0] = 0;\r\nframe[0x1] =\r\n(scan_information & 0x3) |\r\n((bar_info_data_valid & 0x3) << 2) |\r\n((active_information_present & 0x1) << 4) |\r\n((color_format & 0x3) << 5);\r\nframe[0x2] =\r\n(active_format_aspect_ratio & 0xF) |\r\n((picture_aspect_ratio & 0x3) << 4) |\r\n((colorimetry & 0x3) << 6);\r\nframe[0x3] =\r\n(non_uniform_picture_scaling & 0x3) |\r\n((quantization & 0x3) << 2) |\r\n((ex_colorimetry & 0x7) << 4) |\r\n((ITC & 0x1) << 7);\r\nframe[0x4] = (video_format_identification & 0x7F);\r\nframe[0x5] = (pixel_repetition & 0xF);\r\nframe[0x6] = (top_bar & 0xFF);\r\nframe[0x7] = (top_bar >> 8);\r\nframe[0x8] = (bottom_bar & 0xFF);\r\nframe[0x9] = (bottom_bar >> 8);\r\nframe[0xA] = (left_bar & 0xFF);\r\nframe[0xB] = (left_bar >> 8);\r\nframe[0xC] = (right_bar & 0xFF);\r\nframe[0xD] = (right_bar >> 8);\r\nr600_hdmi_infoframe_checksum(0x82, 0x02, 0x0D, frame);\r\nframe[0x0] += 2;\r\nWREG32(HDMI0_AVI_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AVI_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(HDMI0_AVI_INFO2 + offset,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(HDMI0_AVI_INFO3 + offset,\r\nframe[0xC] | (frame[0xD] << 8));\r\n}\r\nstatic void r600_hdmi_audioinfoframe(\r\nstruct drm_encoder *encoder,\r\nuint8_t channel_count,\r\nuint8_t coding_type,\r\nuint8_t sample_size,\r\nuint8_t sample_frequency,\r\nuint8_t format,\r\nuint8_t channel_allocation,\r\nuint8_t level_shift,\r\nint downmix_inhibit\r\n)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nuint8_t frame[11];\r\nframe[0x0] = 0;\r\nframe[0x1] = (channel_count & 0x7) | ((coding_type & 0xF) << 4);\r\nframe[0x2] = (sample_size & 0x3) | ((sample_frequency & 0x7) << 2);\r\nframe[0x3] = format;\r\nframe[0x4] = channel_allocation;\r\nframe[0x5] = ((level_shift & 0xF) << 3) | ((downmix_inhibit & 0x1) << 7);\r\nframe[0x6] = 0;\r\nframe[0x7] = 0;\r\nframe[0x8] = 0;\r\nframe[0x9] = 0;\r\nframe[0xA] = 0;\r\nr600_hdmi_infoframe_checksum(0x84, 0x01, 0x0A, frame);\r\nWREG32(HDMI0_AUDIO_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AUDIO_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));\r\n}\r\nstatic bool r600_hdmi_is_audio_buffer_filled(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nreturn (RREG32(HDMI0_STATUS + offset) & 0x10) != 0;\r\n}\r\nint r600_hdmi_buffer_status_changed(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nint status, result;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn 0;\r\nstatus = r600_hdmi_is_audio_buffer_filled(encoder);\r\nresult = dig->afmt->last_buffer_filled_status != status;\r\ndig->afmt->last_buffer_filled_status = status;\r\nreturn result;\r\n}\r\nstatic void r600_hdmi_audio_workaround(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nbool hdmi_audio_workaround = false;\r\nu32 value;\r\nif (!hdmi_audio_workaround ||\r\nr600_hdmi_is_audio_buffer_filled(encoder))\r\nvalue = 0;\r\nelse\r\nvalue = HDMI0_AUDIO_TEST_EN;\r\nWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nvalue, ~HDMI0_AUDIO_TEST_EN);\r\n}\r\nvoid r600_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset;\r\nif (!dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nr600_audio_set_clock(encoder, mode->clock);\r\nWREG32(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND);\r\nWREG32(HDMI0_AUDIO_CRC_CONTROL + offset, 0x1000);\r\nif (ASIC_IS_DCE32(rdev)) {\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3));\r\nWREG32(AFMT_AUDIO_PACKET_CONTROL + offset,\r\nAFMT_AUDIO_SAMPLE_SEND |\r\nAFMT_60958_CS_UPDATE);\r\n} else {\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3) |\r\nHDMI0_60958_CS_UPDATE);\r\n}\r\nWREG32(HDMI0_ACR_PACKET_CONTROL + offset,\r\nHDMI0_ACR_AUTO_SEND |\r\nHDMI0_ACR_SOURCE);\r\nWREG32(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND |\r\nHDMI0_GC_SEND |\r\nHDMI0_GC_CONT);\r\nWREG32(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AVI_INFO_SEND |\r\nHDMI0_AVI_INFO_CONT |\r\nHDMI0_AUDIO_INFO_SEND |\r\nHDMI0_AUDIO_INFO_CONT);\r\nWREG32(HDMI0_INFOFRAME_CONTROL1 + offset,\r\nHDMI0_AVI_INFO_LINE(2) |\r\nHDMI0_AUDIO_INFO_LINE(2));\r\nWREG32(HDMI0_GC + offset, 0);\r\nr600_hdmi_videoinfoframe(encoder, RGB, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\nr600_hdmi_update_ACR(encoder, mode->clock);\r\nWREG32(HDMI0_RAMP_CONTROL0 + offset, 0x00FFFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL1 + offset, 0x007FFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL2 + offset, 0x00000001);\r\nWREG32(HDMI0_RAMP_CONTROL3 + offset, 0x00000001);\r\nr600_hdmi_audio_workaround(encoder);\r\n}\r\nvoid r600_hdmi_update_audio_settings(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct r600_audio audio = r600_audio_status(rdev);\r\nuint32_t offset;\r\nuint32_t iec;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nDRM_DEBUG("%s with %d channels, %d Hz sampling rate, %d bits per sample,\n",\r\nr600_hdmi_is_audio_buffer_filled(encoder) ? "playing" : "stopped",\r\naudio.channels, audio.rate, audio.bits_per_sample);\r\nDRM_DEBUG("0x%02X IEC60958 status bits and 0x%02X category code\n",\r\n(int)audio.status_bits, (int)audio.category_code);\r\niec = 0;\r\nif (audio.status_bits & AUDIO_STATUS_PROFESSIONAL)\r\niec |= 1 << 0;\r\nif (audio.status_bits & AUDIO_STATUS_NONAUDIO)\r\niec |= 1 << 1;\r\nif (audio.status_bits & AUDIO_STATUS_COPYRIGHT)\r\niec |= 1 << 2;\r\nif (audio.status_bits & AUDIO_STATUS_EMPHASIS)\r\niec |= 1 << 3;\r\niec |= HDMI0_60958_CS_CATEGORY_CODE(audio.category_code);\r\nswitch (audio.rate) {\r\ncase 32000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x3);\r\nbreak;\r\ncase 44100:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x0);\r\nbreak;\r\ncase 48000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x2);\r\nbreak;\r\ncase 88200:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x8);\r\nbreak;\r\ncase 96000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0xa);\r\nbreak;\r\ncase 176400:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0xc);\r\nbreak;\r\ncase 192000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0xe);\r\nbreak;\r\n}\r\nWREG32(HDMI0_60958_0 + offset, iec);\r\niec = 0;\r\nswitch (audio.bits_per_sample) {\r\ncase 16:\r\niec |= HDMI0_60958_CS_WORD_LENGTH(0x2);\r\nbreak;\r\ncase 20:\r\niec |= HDMI0_60958_CS_WORD_LENGTH(0x3);\r\nbreak;\r\ncase 24:\r\niec |= HDMI0_60958_CS_WORD_LENGTH(0xb);\r\nbreak;\r\n}\r\nif (audio.status_bits & AUDIO_STATUS_V)\r\niec |= 0x5 << 16;\r\nWREG32_P(HDMI0_60958_1 + offset, iec, ~0x5000f);\r\nr600_hdmi_audioinfoframe(encoder, audio.channels - 1, 0, 0, 0, 0, 0, 0,\r\n0);\r\nr600_hdmi_audio_workaround(encoder);\r\n}\r\nvoid r600_hdmi_enable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset;\r\nu32 hdmi;\r\nif (ASIC_IS_DCE6(rdev))\r\nreturn;\r\nif (dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nif (rdev->family >= CHIP_R600 && !ASIC_IS_DCE3(rdev)) {\r\nhdmi = HDMI0_ERROR_ACK | HDMI0_ENABLE;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nWREG32_P(AVIVO_TMDSA_CNTL, AVIVO_TMDSA_CNTL_HDMI_EN,\r\n~AVIVO_TMDSA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_TMDSA);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32_P(AVIVO_LVTMA_CNTL, AVIVO_LVTMA_CNTL_HDMI_EN,\r\n~AVIVO_LVTMA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_LVTMA);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\nWREG32_P(DDIA_CNTL, DDIA_HDMI_EN, ~DDIA_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DDIA);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DVOA);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Invalid encoder for HDMI: 0x%X\n",\r\nradeon_encoder->encoder_id);\r\nbreak;\r\n}\r\nWREG32(HDMI0_CONTROL + offset, hdmi);\r\n}\r\nif (rdev->irq.installed) {\r\nradeon_irq_kms_enable_afmt(rdev, dig->afmt->id);\r\n}\r\ndig->afmt->enabled = true;\r\nDRM_DEBUG("Enabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\noffset, radeon_encoder->encoder_id);\r\n}\r\nvoid r600_hdmi_disable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset;\r\nif (ASIC_IS_DCE6(rdev))\r\nreturn;\r\nif (!dig || !dig->afmt) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nif (!dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nDRM_DEBUG("Disabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\noffset, radeon_encoder->encoder_id);\r\nradeon_irq_kms_disable_afmt(rdev, dig->afmt->id);\r\nif (rdev->family >= CHIP_R600 && !ASIC_IS_DCE3(rdev)) {\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nWREG32_P(AVIVO_TMDSA_CNTL, 0,\r\n~AVIVO_TMDSA_CNTL_HDMI_EN);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32_P(AVIVO_LVTMA_CNTL, 0,\r\n~AVIVO_LVTMA_CNTL_HDMI_EN);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\nWREG32_P(DDIA_CNTL, 0, ~DDIA_HDMI_EN);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Invalid encoder for HDMI: 0x%X\n",\r\nradeon_encoder->encoder_id);\r\nbreak;\r\n}\r\nWREG32(HDMI0_CONTROL + offset, HDMI0_ERROR_ACK);\r\n}\r\ndig->afmt->enabled = false;\r\n}
