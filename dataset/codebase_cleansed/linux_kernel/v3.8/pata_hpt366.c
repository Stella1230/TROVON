static u32 hpt36x_find_mode(struct ata_port *ap, int speed)\r\n{\r\nstruct hpt_clock *clocks = ap->host->private_data;\r\nwhile (clocks->xfer_mode) {\r\nif (clocks->xfer_mode == speed)\r\nreturn clocks->timing;\r\nclocks++;\r\n}\r\nBUG();\r\nreturn 0xffffffffU;\r\n}\r\nstatic int hpt_dma_blacklisted(const struct ata_device *dev, char *modestr,\r\nconst char * const list[])\r\n{\r\nunsigned char model_num[ATA_ID_PROD_LEN + 1];\r\nint i = 0;\r\nata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nwhile (list[i] != NULL) {\r\nif (!strcmp(list[i], model_num)) {\r\npr_warn("%s is not supported for %s\n",\r\nmodestr, list[i]);\r\nreturn 1;\r\n}\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long hpt366_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (adev->class == ATA_DEV_ATA) {\r\nif (hpt_dma_blacklisted(adev, "UDMA", bad_ata33))\r\nmask &= ~ATA_MASK_UDMA;\r\nif (hpt_dma_blacklisted(adev, "UDMA3", bad_ata66_3))\r\nmask &= ~(0xF8 << ATA_SHIFT_UDMA);\r\nif (hpt_dma_blacklisted(adev, "UDMA4", bad_ata66_4))\r\nmask &= ~(0xF0 << ATA_SHIFT_UDMA);\r\n} else if (adev->class == ATA_DEV_ATAPI)\r\nmask &= ~(ATA_MASK_MWDMA | ATA_MASK_UDMA);\r\nreturn mask;\r\n}\r\nstatic int hpt36x_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 ata66;\r\npci_read_config_byte(pdev, 0x5A, &ata66);\r\nif (ata66 & 2)\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void hpt366_set_mode(struct ata_port *ap, struct ata_device *adev,\r\nu8 mode)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu32 addr = 0x40 + 4 * adev->devno;\r\nu32 mask, reg, t;\r\nif (mode < XFER_MW_DMA_0)\r\nmask = 0xc1f8ffff;\r\nelse if (mode < XFER_UDMA_0)\r\nmask = 0x303800ff;\r\nelse\r\nmask = 0x30070000;\r\nt = hpt36x_find_mode(ap, mode);\r\npci_read_config_dword(pdev, addr, &reg);\r\nreg = ((reg & ~mask) | (t & mask)) & ~0xc0000000;\r\npci_write_config_dword(pdev, addr, reg);\r\n}\r\nstatic void hpt366_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt366_set_mode(ap, adev, adev->pio_mode);\r\n}\r\nstatic void hpt366_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt366_set_mode(ap, adev, adev->dma_mode);\r\n}\r\nstatic void hpt36x_init_chipset(struct pci_dev *dev)\r\n{\r\nu8 drive_fast;\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\r\npci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\r\npci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\r\npci_read_config_byte(dev, 0x51, &drive_fast);\r\nif (drive_fast & 0x80)\r\npci_write_config_byte(dev, 0x51, drive_fast & ~0x80);\r\n}\r\nstatic int hpt36x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_hpt366 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &hpt366_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { &info_hpt366, NULL };\r\nvoid *hpriv = NULL;\r\nu32 reg1;\r\nint rc;\r\nrc = pcim_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\nif (dev->revision > 2)\r\nreturn -ENODEV;\r\nhpt36x_init_chipset(dev);\r\npci_read_config_dword(dev, 0x40, &reg1);\r\nswitch ((reg1 & 0x700) >> 8) {\r\ncase 9:\r\nhpriv = &hpt366_40;\r\nbreak;\r\ncase 5:\r\nhpriv = &hpt366_25;\r\nbreak;\r\ndefault:\r\nhpriv = &hpt366_33;\r\nbreak;\r\n}\r\nreturn ata_pci_bmdma_init_one(dev, ppi, &hpt36x_sht, hpriv, 0);\r\n}\r\nstatic int hpt36x_reinit_one(struct pci_dev *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&dev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(dev);\r\nif (rc)\r\nreturn rc;\r\nhpt36x_init_chipset(dev);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
