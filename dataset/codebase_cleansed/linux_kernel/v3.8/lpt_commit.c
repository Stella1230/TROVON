static struct ubifs_cnode *first_dirty_cnode(struct ubifs_nnode *nnode)\r\n{\r\nubifs_assert(nnode);\r\nwhile (1) {\r\nint i, cont = 0;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nstruct ubifs_cnode *cnode;\r\ncnode = nnode->nbranch[i].cnode;\r\nif (cnode &&\r\ntest_bit(DIRTY_CNODE, &cnode->flags)) {\r\nif (cnode->level == 0)\r\nreturn cnode;\r\nnnode = (struct ubifs_nnode *)cnode;\r\ncont = 1;\r\nbreak;\r\n}\r\n}\r\nif (!cont)\r\nreturn (struct ubifs_cnode *)nnode;\r\n}\r\n}\r\nstatic struct ubifs_cnode *next_dirty_cnode(struct ubifs_cnode *cnode)\r\n{\r\nstruct ubifs_nnode *nnode;\r\nint i;\r\nubifs_assert(cnode);\r\nnnode = cnode->parent;\r\nif (!nnode)\r\nreturn NULL;\r\nfor (i = cnode->iip + 1; i < UBIFS_LPT_FANOUT; i++) {\r\ncnode = nnode->nbranch[i].cnode;\r\nif (cnode && test_bit(DIRTY_CNODE, &cnode->flags)) {\r\nif (cnode->level == 0)\r\nreturn cnode;\r\nreturn first_dirty_cnode((struct ubifs_nnode *)cnode);\r\n}\r\n}\r\nreturn (struct ubifs_cnode *)nnode;\r\n}\r\nstatic int get_cnodes_to_commit(struct ubifs_info *c)\r\n{\r\nstruct ubifs_cnode *cnode, *cnext;\r\nint cnt = 0;\r\nif (!c->nroot)\r\nreturn 0;\r\nif (!test_bit(DIRTY_CNODE, &c->nroot->flags))\r\nreturn 0;\r\nc->lpt_cnext = first_dirty_cnode(c->nroot);\r\ncnode = c->lpt_cnext;\r\nif (!cnode)\r\nreturn 0;\r\ncnt += 1;\r\nwhile (1) {\r\nubifs_assert(!test_bit(COW_CNODE, &cnode->flags));\r\n__set_bit(COW_CNODE, &cnode->flags);\r\ncnext = next_dirty_cnode(cnode);\r\nif (!cnext) {\r\ncnode->cnext = c->lpt_cnext;\r\nbreak;\r\n}\r\ncnode->cnext = cnext;\r\ncnode = cnext;\r\ncnt += 1;\r\n}\r\ndbg_cmt("committing %d cnodes", cnt);\r\ndbg_lp("committing %d cnodes", cnt);\r\nubifs_assert(cnt == c->dirty_nn_cnt + c->dirty_pn_cnt);\r\nreturn cnt;\r\n}\r\nstatic void upd_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\r\n{\r\ndbg_lp("LEB %d free %d dirty %d to %d +%d",\r\nlnum, c->ltab[lnum - c->lpt_first].free,\r\nc->ltab[lnum - c->lpt_first].dirty, free, dirty);\r\nubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\r\nc->ltab[lnum - c->lpt_first].free = free;\r\nc->ltab[lnum - c->lpt_first].dirty += dirty;\r\n}\r\nstatic int alloc_lpt_leb(struct ubifs_info *c, int *lnum)\r\n{\r\nint i, n;\r\nn = *lnum - c->lpt_first + 1;\r\nfor (i = n; i < c->lpt_lebs; i++) {\r\nif (c->ltab[i].tgc || c->ltab[i].cmt)\r\ncontinue;\r\nif (c->ltab[i].free == c->leb_size) {\r\nc->ltab[i].cmt = 1;\r\n*lnum = i + c->lpt_first;\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 0; i < n; i++) {\r\nif (c->ltab[i].tgc || c->ltab[i].cmt)\r\ncontinue;\r\nif (c->ltab[i].free == c->leb_size) {\r\nc->ltab[i].cmt = 1;\r\n*lnum = i + c->lpt_first;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int layout_cnodes(struct ubifs_info *c)\r\n{\r\nint lnum, offs, len, alen, done_lsave, done_ltab, err;\r\nstruct ubifs_cnode *cnode;\r\nerr = dbg_chk_lpt_sz(c, 0, 0);\r\nif (err)\r\nreturn err;\r\ncnode = c->lpt_cnext;\r\nif (!cnode)\r\nreturn 0;\r\nlnum = c->nhead_lnum;\r\noffs = c->nhead_offs;\r\ndone_lsave = !c->big_lpt;\r\ndone_ltab = 0;\r\nif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\r\ndone_lsave = 1;\r\nc->lsave_lnum = lnum;\r\nc->lsave_offs = offs;\r\noffs += c->lsave_sz;\r\ndbg_chk_lpt_sz(c, 1, c->lsave_sz);\r\n}\r\nif (offs + c->ltab_sz <= c->leb_size) {\r\ndone_ltab = 1;\r\nc->ltab_lnum = lnum;\r\nc->ltab_offs = offs;\r\noffs += c->ltab_sz;\r\ndbg_chk_lpt_sz(c, 1, c->ltab_sz);\r\n}\r\ndo {\r\nif (cnode->level) {\r\nlen = c->nnode_sz;\r\nc->dirty_nn_cnt -= 1;\r\n} else {\r\nlen = c->pnode_sz;\r\nc->dirty_pn_cnt -= 1;\r\n}\r\nwhile (offs + len > c->leb_size) {\r\nalen = ALIGN(offs, c->min_io_size);\r\nupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\r\ndbg_chk_lpt_sz(c, 2, c->leb_size - offs);\r\nerr = alloc_lpt_leb(c, &lnum);\r\nif (err)\r\ngoto no_space;\r\noffs = 0;\r\nubifs_assert(lnum >= c->lpt_first &&\r\nlnum <= c->lpt_last);\r\nif (!done_lsave) {\r\ndone_lsave = 1;\r\nc->lsave_lnum = lnum;\r\nc->lsave_offs = offs;\r\noffs += c->lsave_sz;\r\ndbg_chk_lpt_sz(c, 1, c->lsave_sz);\r\ncontinue;\r\n}\r\nif (!done_ltab) {\r\ndone_ltab = 1;\r\nc->ltab_lnum = lnum;\r\nc->ltab_offs = offs;\r\noffs += c->ltab_sz;\r\ndbg_chk_lpt_sz(c, 1, c->ltab_sz);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (cnode->parent) {\r\ncnode->parent->nbranch[cnode->iip].lnum = lnum;\r\ncnode->parent->nbranch[cnode->iip].offs = offs;\r\n} else {\r\nc->lpt_lnum = lnum;\r\nc->lpt_offs = offs;\r\n}\r\noffs += len;\r\ndbg_chk_lpt_sz(c, 1, len);\r\ncnode = cnode->cnext;\r\n} while (cnode && cnode != c->lpt_cnext);\r\nif (!done_lsave) {\r\nif (offs + c->lsave_sz > c->leb_size) {\r\nalen = ALIGN(offs, c->min_io_size);\r\nupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\r\ndbg_chk_lpt_sz(c, 2, c->leb_size - offs);\r\nerr = alloc_lpt_leb(c, &lnum);\r\nif (err)\r\ngoto no_space;\r\noffs = 0;\r\nubifs_assert(lnum >= c->lpt_first &&\r\nlnum <= c->lpt_last);\r\n}\r\ndone_lsave = 1;\r\nc->lsave_lnum = lnum;\r\nc->lsave_offs = offs;\r\noffs += c->lsave_sz;\r\ndbg_chk_lpt_sz(c, 1, c->lsave_sz);\r\n}\r\nif (!done_ltab) {\r\nif (offs + c->ltab_sz > c->leb_size) {\r\nalen = ALIGN(offs, c->min_io_size);\r\nupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\r\ndbg_chk_lpt_sz(c, 2, c->leb_size - offs);\r\nerr = alloc_lpt_leb(c, &lnum);\r\nif (err)\r\ngoto no_space;\r\noffs = 0;\r\nubifs_assert(lnum >= c->lpt_first &&\r\nlnum <= c->lpt_last);\r\n}\r\ndone_ltab = 1;\r\nc->ltab_lnum = lnum;\r\nc->ltab_offs = offs;\r\noffs += c->ltab_sz;\r\ndbg_chk_lpt_sz(c, 1, c->ltab_sz);\r\n}\r\nalen = ALIGN(offs, c->min_io_size);\r\nupd_ltab(c, lnum, c->leb_size - alen, alen - offs);\r\ndbg_chk_lpt_sz(c, 4, alen - offs);\r\nerr = dbg_chk_lpt_sz(c, 3, alen);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\nno_space:\r\nubifs_err("LPT out of space at LEB %d:%d needing %d, done_ltab %d, done_lsave %d",\r\nlnum, offs, len, done_ltab, done_lsave);\r\nubifs_dump_lpt_info(c);\r\nubifs_dump_lpt_lebs(c);\r\ndump_stack();\r\nreturn err;\r\n}\r\nstatic int realloc_lpt_leb(struct ubifs_info *c, int *lnum)\r\n{\r\nint i, n;\r\nn = *lnum - c->lpt_first + 1;\r\nfor (i = n; i < c->lpt_lebs; i++)\r\nif (c->ltab[i].cmt) {\r\nc->ltab[i].cmt = 0;\r\n*lnum = i + c->lpt_first;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < n; i++)\r\nif (c->ltab[i].cmt) {\r\nc->ltab[i].cmt = 0;\r\n*lnum = i + c->lpt_first;\r\nreturn 0;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int write_cnodes(struct ubifs_info *c)\r\n{\r\nint lnum, offs, len, from, err, wlen, alen, done_ltab, done_lsave;\r\nstruct ubifs_cnode *cnode;\r\nvoid *buf = c->lpt_buf;\r\ncnode = c->lpt_cnext;\r\nif (!cnode)\r\nreturn 0;\r\nlnum = c->nhead_lnum;\r\noffs = c->nhead_offs;\r\nfrom = offs;\r\nif (offs == 0) {\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\n}\r\ndone_lsave = !c->big_lpt;\r\ndone_ltab = 0;\r\nif (!done_lsave && offs + c->lsave_sz <= c->leb_size) {\r\ndone_lsave = 1;\r\nubifs_pack_lsave(c, buf + offs, c->lsave);\r\noffs += c->lsave_sz;\r\ndbg_chk_lpt_sz(c, 1, c->lsave_sz);\r\n}\r\nif (offs + c->ltab_sz <= c->leb_size) {\r\ndone_ltab = 1;\r\nubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\r\noffs += c->ltab_sz;\r\ndbg_chk_lpt_sz(c, 1, c->ltab_sz);\r\n}\r\ndo {\r\nif (cnode->level)\r\nlen = c->nnode_sz;\r\nelse\r\nlen = c->pnode_sz;\r\nwhile (offs + len > c->leb_size) {\r\nwlen = offs - from;\r\nif (wlen) {\r\nalen = ALIGN(wlen, c->min_io_size);\r\nmemset(buf + offs, 0xff, alen - wlen);\r\nerr = ubifs_leb_write(c, lnum, buf + from, from,\r\nalen);\r\nif (err)\r\nreturn err;\r\n}\r\ndbg_chk_lpt_sz(c, 2, c->leb_size - offs);\r\nerr = realloc_lpt_leb(c, &lnum);\r\nif (err)\r\ngoto no_space;\r\noffs = from = 0;\r\nubifs_assert(lnum >= c->lpt_first &&\r\nlnum <= c->lpt_last);\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\nif (!done_lsave) {\r\ndone_lsave = 1;\r\nubifs_pack_lsave(c, buf + offs, c->lsave);\r\noffs += c->lsave_sz;\r\ndbg_chk_lpt_sz(c, 1, c->lsave_sz);\r\ncontinue;\r\n}\r\nif (!done_ltab) {\r\ndone_ltab = 1;\r\nubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\r\noffs += c->ltab_sz;\r\ndbg_chk_lpt_sz(c, 1, c->ltab_sz);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (cnode->level)\r\nubifs_pack_nnode(c, buf + offs,\r\n(struct ubifs_nnode *)cnode);\r\nelse\r\nubifs_pack_pnode(c, buf + offs,\r\n(struct ubifs_pnode *)cnode);\r\nclear_bit(DIRTY_CNODE, &cnode->flags);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(COW_CNODE, &cnode->flags);\r\nsmp_mb__after_clear_bit();\r\noffs += len;\r\ndbg_chk_lpt_sz(c, 1, len);\r\ncnode = cnode->cnext;\r\n} while (cnode && cnode != c->lpt_cnext);\r\nif (!done_lsave) {\r\nif (offs + c->lsave_sz > c->leb_size) {\r\nwlen = offs - from;\r\nalen = ALIGN(wlen, c->min_io_size);\r\nmemset(buf + offs, 0xff, alen - wlen);\r\nerr = ubifs_leb_write(c, lnum, buf + from, from, alen);\r\nif (err)\r\nreturn err;\r\ndbg_chk_lpt_sz(c, 2, c->leb_size - offs);\r\nerr = realloc_lpt_leb(c, &lnum);\r\nif (err)\r\ngoto no_space;\r\noffs = from = 0;\r\nubifs_assert(lnum >= c->lpt_first &&\r\nlnum <= c->lpt_last);\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\n}\r\ndone_lsave = 1;\r\nubifs_pack_lsave(c, buf + offs, c->lsave);\r\noffs += c->lsave_sz;\r\ndbg_chk_lpt_sz(c, 1, c->lsave_sz);\r\n}\r\nif (!done_ltab) {\r\nif (offs + c->ltab_sz > c->leb_size) {\r\nwlen = offs - from;\r\nalen = ALIGN(wlen, c->min_io_size);\r\nmemset(buf + offs, 0xff, alen - wlen);\r\nerr = ubifs_leb_write(c, lnum, buf + from, from, alen);\r\nif (err)\r\nreturn err;\r\ndbg_chk_lpt_sz(c, 2, c->leb_size - offs);\r\nerr = realloc_lpt_leb(c, &lnum);\r\nif (err)\r\ngoto no_space;\r\noffs = from = 0;\r\nubifs_assert(lnum >= c->lpt_first &&\r\nlnum <= c->lpt_last);\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\n}\r\ndone_ltab = 1;\r\nubifs_pack_ltab(c, buf + offs, c->ltab_cmt);\r\noffs += c->ltab_sz;\r\ndbg_chk_lpt_sz(c, 1, c->ltab_sz);\r\n}\r\nwlen = offs - from;\r\nalen = ALIGN(wlen, c->min_io_size);\r\nmemset(buf + offs, 0xff, alen - wlen);\r\nerr = ubifs_leb_write(c, lnum, buf + from, from, alen);\r\nif (err)\r\nreturn err;\r\ndbg_chk_lpt_sz(c, 4, alen - wlen);\r\nerr = dbg_chk_lpt_sz(c, 3, ALIGN(offs, c->min_io_size));\r\nif (err)\r\nreturn err;\r\nc->nhead_lnum = lnum;\r\nc->nhead_offs = ALIGN(offs, c->min_io_size);\r\ndbg_lp("LPT root is at %d:%d", c->lpt_lnum, c->lpt_offs);\r\ndbg_lp("LPT head is at %d:%d", c->nhead_lnum, c->nhead_offs);\r\ndbg_lp("LPT ltab is at %d:%d", c->ltab_lnum, c->ltab_offs);\r\nif (c->big_lpt)\r\ndbg_lp("LPT lsave is at %d:%d", c->lsave_lnum, c->lsave_offs);\r\nreturn 0;\r\nno_space:\r\nubifs_err("LPT out of space mismatch at LEB %d:%d needing %d, done_ltab %d, done_lsave %d",\r\nlnum, offs, len, done_ltab, done_lsave);\r\nubifs_dump_lpt_info(c);\r\nubifs_dump_lpt_lebs(c);\r\ndump_stack();\r\nreturn err;\r\n}\r\nstatic struct ubifs_pnode *next_pnode_to_dirty(struct ubifs_info *c,\r\nstruct ubifs_pnode *pnode)\r\n{\r\nstruct ubifs_nnode *nnode;\r\nint iip;\r\nnnode = pnode->parent;\r\nfor (iip = pnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\r\nif (nnode->nbranch[iip].lnum)\r\nreturn ubifs_get_pnode(c, nnode, iip);\r\n}\r\ndo {\r\niip = nnode->iip + 1;\r\nnnode = nnode->parent;\r\nif (!nnode)\r\nreturn NULL;\r\nfor (; iip < UBIFS_LPT_FANOUT; iip++) {\r\nif (nnode->nbranch[iip].lnum)\r\nbreak;\r\n}\r\n} while (iip >= UBIFS_LPT_FANOUT);\r\nnnode = ubifs_get_nnode(c, nnode, iip);\r\nif (IS_ERR(nnode))\r\nreturn (void *)nnode;\r\nwhile (nnode->level > 1) {\r\nfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++) {\r\nif (nnode->nbranch[iip].lnum)\r\nbreak;\r\n}\r\nif (iip >= UBIFS_LPT_FANOUT) {\r\niip = 0;\r\n}\r\nnnode = ubifs_get_nnode(c, nnode, iip);\r\nif (IS_ERR(nnode))\r\nreturn (void *)nnode;\r\n}\r\nfor (iip = 0; iip < UBIFS_LPT_FANOUT; iip++)\r\nif (nnode->nbranch[iip].lnum)\r\nbreak;\r\nif (iip >= UBIFS_LPT_FANOUT)\r\niip = 0;\r\nreturn ubifs_get_pnode(c, nnode, iip);\r\n}\r\nstatic struct ubifs_pnode *pnode_lookup(struct ubifs_info *c, int i)\r\n{\r\nint err, h, iip, shft;\r\nstruct ubifs_nnode *nnode;\r\nif (!c->nroot) {\r\nerr = ubifs_read_nnode(c, NULL, 0);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\ni <<= UBIFS_LPT_FANOUT_SHIFT;\r\nnnode = c->nroot;\r\nshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\r\nfor (h = 1; h < c->lpt_hght; h++) {\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\nnnode = ubifs_get_nnode(c, nnode, iip);\r\nif (IS_ERR(nnode))\r\nreturn ERR_CAST(nnode);\r\n}\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nreturn ubifs_get_pnode(c, nnode, iip);\r\n}\r\nstatic void add_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\r\n{\r\nubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\r\nc->pnode_sz);\r\n}\r\nstatic void do_make_pnode_dirty(struct ubifs_info *c, struct ubifs_pnode *pnode)\r\n{\r\nif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\r\nstruct ubifs_nnode *nnode;\r\nc->dirty_pn_cnt += 1;\r\nadd_pnode_dirt(c, pnode);\r\nnnode = pnode->parent;\r\nwhile (nnode) {\r\nif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\r\nc->dirty_nn_cnt += 1;\r\nubifs_add_nnode_dirt(c, nnode);\r\nnnode = nnode->parent;\r\n} else\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int make_tree_dirty(struct ubifs_info *c)\r\n{\r\nstruct ubifs_pnode *pnode;\r\npnode = pnode_lookup(c, 0);\r\nif (IS_ERR(pnode))\r\nreturn PTR_ERR(pnode);\r\nwhile (pnode) {\r\ndo_make_pnode_dirty(c, pnode);\r\npnode = next_pnode_to_dirty(c, pnode);\r\nif (IS_ERR(pnode))\r\nreturn PTR_ERR(pnode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int need_write_all(struct ubifs_info *c)\r\n{\r\nlong long free = 0;\r\nint i;\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\nif (i + c->lpt_first == c->nhead_lnum)\r\nfree += c->leb_size - c->nhead_offs;\r\nelse if (c->ltab[i].free == c->leb_size)\r\nfree += c->leb_size;\r\nelse if (c->ltab[i].free + c->ltab[i].dirty == c->leb_size)\r\nfree += c->leb_size;\r\n}\r\nif (free <= c->lpt_sz * 2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void lpt_tgc_start(struct ubifs_info *c)\r\n{\r\nint i;\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\nif (i + c->lpt_first == c->nhead_lnum)\r\ncontinue;\r\nif (c->ltab[i].dirty > 0 &&\r\nc->ltab[i].free + c->ltab[i].dirty == c->leb_size) {\r\nc->ltab[i].tgc = 1;\r\nc->ltab[i].free = c->leb_size;\r\nc->ltab[i].dirty = 0;\r\ndbg_lp("LEB %d", i + c->lpt_first);\r\n}\r\n}\r\n}\r\nstatic int lpt_tgc_end(struct ubifs_info *c)\r\n{\r\nint i, err;\r\nfor (i = 0; i < c->lpt_lebs; i++)\r\nif (c->ltab[i].tgc) {\r\nerr = ubifs_leb_unmap(c, i + c->lpt_first);\r\nif (err)\r\nreturn err;\r\nc->ltab[i].tgc = 0;\r\ndbg_lp("LEB %d", i + c->lpt_first);\r\n}\r\nreturn 0;\r\n}\r\nstatic void populate_lsave(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nstruct ubifs_lpt_heap *heap;\r\nint i, cnt = 0;\r\nubifs_assert(c->big_lpt);\r\nif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\r\nc->lpt_drty_flgs |= LSAVE_DIRTY;\r\nubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\r\n}\r\nif (dbg_populate_lsave(c))\r\nreturn;\r\nlist_for_each_entry(lprops, &c->empty_list, list) {\r\nc->lsave[cnt++] = lprops->lnum;\r\nif (cnt >= c->lsave_cnt)\r\nreturn;\r\n}\r\nlist_for_each_entry(lprops, &c->freeable_list, list) {\r\nc->lsave[cnt++] = lprops->lnum;\r\nif (cnt >= c->lsave_cnt)\r\nreturn;\r\n}\r\nlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\r\nc->lsave[cnt++] = lprops->lnum;\r\nif (cnt >= c->lsave_cnt)\r\nreturn;\r\n}\r\nheap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nc->lsave[cnt++] = heap->arr[i]->lnum;\r\nif (cnt >= c->lsave_cnt)\r\nreturn;\r\n}\r\nheap = &c->lpt_heap[LPROPS_DIRTY - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nc->lsave[cnt++] = heap->arr[i]->lnum;\r\nif (cnt >= c->lsave_cnt)\r\nreturn;\r\n}\r\nheap = &c->lpt_heap[LPROPS_FREE - 1];\r\nfor (i = 0; i < heap->cnt; i++) {\r\nc->lsave[cnt++] = heap->arr[i]->lnum;\r\nif (cnt >= c->lsave_cnt)\r\nreturn;\r\n}\r\nwhile (cnt < c->lsave_cnt)\r\nc->lsave[cnt++] = c->main_first;\r\n}\r\nstatic struct ubifs_nnode *nnode_lookup(struct ubifs_info *c, int i)\r\n{\r\nint err, iip;\r\nstruct ubifs_nnode *nnode;\r\nif (!c->nroot) {\r\nerr = ubifs_read_nnode(c, NULL, 0);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nnnode = c->nroot;\r\nwhile (1) {\r\niip = i & (UBIFS_LPT_FANOUT - 1);\r\ni >>= UBIFS_LPT_FANOUT_SHIFT;\r\nif (!i)\r\nbreak;\r\nnnode = ubifs_get_nnode(c, nnode, iip);\r\nif (IS_ERR(nnode))\r\nreturn nnode;\r\n}\r\nreturn nnode;\r\n}\r\nstatic int make_nnode_dirty(struct ubifs_info *c, int node_num, int lnum,\r\nint offs)\r\n{\r\nstruct ubifs_nnode *nnode;\r\nnnode = nnode_lookup(c, node_num);\r\nif (IS_ERR(nnode))\r\nreturn PTR_ERR(nnode);\r\nif (nnode->parent) {\r\nstruct ubifs_nbranch *branch;\r\nbranch = &nnode->parent->nbranch[nnode->iip];\r\nif (branch->lnum != lnum || branch->offs != offs)\r\nreturn 0;\r\n} else if (c->lpt_lnum != lnum || c->lpt_offs != offs)\r\nreturn 0;\r\nif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\r\nc->dirty_nn_cnt += 1;\r\nubifs_add_nnode_dirt(c, nnode);\r\nnnode = nnode->parent;\r\nwhile (nnode) {\r\nif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\r\nc->dirty_nn_cnt += 1;\r\nubifs_add_nnode_dirt(c, nnode);\r\nnnode = nnode->parent;\r\n} else\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int make_pnode_dirty(struct ubifs_info *c, int node_num, int lnum,\r\nint offs)\r\n{\r\nstruct ubifs_pnode *pnode;\r\nstruct ubifs_nbranch *branch;\r\npnode = pnode_lookup(c, node_num);\r\nif (IS_ERR(pnode))\r\nreturn PTR_ERR(pnode);\r\nbranch = &pnode->parent->nbranch[pnode->iip];\r\nif (branch->lnum != lnum || branch->offs != offs)\r\nreturn 0;\r\ndo_make_pnode_dirty(c, pnode);\r\nreturn 0;\r\n}\r\nstatic int make_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nif (lnum != c->ltab_lnum || offs != c->ltab_offs)\r\nreturn 0;\r\nif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\r\nc->lpt_drty_flgs |= LTAB_DIRTY;\r\nubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\r\n}\r\nreturn 0;\r\n}\r\nstatic int make_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nif (lnum != c->lsave_lnum || offs != c->lsave_offs)\r\nreturn 0;\r\nif (!(c->lpt_drty_flgs & LSAVE_DIRTY)) {\r\nc->lpt_drty_flgs |= LSAVE_DIRTY;\r\nubifs_add_lpt_dirt(c, c->lsave_lnum, c->lsave_sz);\r\n}\r\nreturn 0;\r\n}\r\nstatic int make_node_dirty(struct ubifs_info *c, int node_type, int node_num,\r\nint lnum, int offs)\r\n{\r\nswitch (node_type) {\r\ncase UBIFS_LPT_NNODE:\r\nreturn make_nnode_dirty(c, node_num, lnum, offs);\r\ncase UBIFS_LPT_PNODE:\r\nreturn make_pnode_dirty(c, node_num, lnum, offs);\r\ncase UBIFS_LPT_LTAB:\r\nreturn make_ltab_dirty(c, lnum, offs);\r\ncase UBIFS_LPT_LSAVE:\r\nreturn make_lsave_dirty(c, lnum, offs);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int get_lpt_node_len(const struct ubifs_info *c, int node_type)\r\n{\r\nswitch (node_type) {\r\ncase UBIFS_LPT_NNODE:\r\nreturn c->nnode_sz;\r\ncase UBIFS_LPT_PNODE:\r\nreturn c->pnode_sz;\r\ncase UBIFS_LPT_LTAB:\r\nreturn c->ltab_sz;\r\ncase UBIFS_LPT_LSAVE:\r\nreturn c->lsave_sz;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_pad_len(const struct ubifs_info *c, uint8_t *buf, int len)\r\n{\r\nint offs, pad_len;\r\nif (c->min_io_size == 1)\r\nreturn 0;\r\noffs = c->leb_size - len;\r\npad_len = ALIGN(offs, c->min_io_size) - offs;\r\nreturn pad_len;\r\n}\r\nstatic int get_lpt_node_type(const struct ubifs_info *c, uint8_t *buf,\r\nint *node_num)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint pos = 0, node_type;\r\nnode_type = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_TYPE_BITS);\r\n*node_num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\r\nreturn node_type;\r\n}\r\nstatic int is_a_node(const struct ubifs_info *c, uint8_t *buf, int len)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint pos = 0, node_type, node_len;\r\nuint16_t crc, calc_crc;\r\nif (len < UBIFS_LPT_CRC_BYTES + (UBIFS_LPT_TYPE_BITS + 7) / 8)\r\nreturn 0;\r\nnode_type = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_TYPE_BITS);\r\nif (node_type == UBIFS_LPT_NOT_A_NODE)\r\nreturn 0;\r\nnode_len = get_lpt_node_len(c, node_type);\r\nif (!node_len || node_len > len)\r\nreturn 0;\r\npos = 0;\r\naddr = buf;\r\ncrc = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_CRC_BITS);\r\ncalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\r\nnode_len - UBIFS_LPT_CRC_BYTES);\r\nif (crc != calc_crc)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int lpt_gc_lnum(struct ubifs_info *c, int lnum)\r\n{\r\nint err, len = c->leb_size, node_type, node_num, node_len, offs;\r\nvoid *buf = c->lpt_buf;\r\ndbg_lp("LEB %d", lnum);\r\nerr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\r\nif (err)\r\nreturn err;\r\nwhile (1) {\r\nif (!is_a_node(c, buf, len)) {\r\nint pad_len;\r\npad_len = get_pad_len(c, buf, len);\r\nif (pad_len) {\r\nbuf += pad_len;\r\nlen -= pad_len;\r\ncontinue;\r\n}\r\nreturn 0;\r\n}\r\nnode_type = get_lpt_node_type(c, buf, &node_num);\r\nnode_len = get_lpt_node_len(c, node_type);\r\noffs = c->leb_size - len;\r\nubifs_assert(node_len != 0);\r\nmutex_lock(&c->lp_mutex);\r\nerr = make_node_dirty(c, node_type, node_num, lnum, offs);\r\nmutex_unlock(&c->lp_mutex);\r\nif (err)\r\nreturn err;\r\nbuf += node_len;\r\nlen -= node_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpt_gc(struct ubifs_info *c)\r\n{\r\nint i, lnum = -1, dirty = 0;\r\nmutex_lock(&c->lp_mutex);\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\nubifs_assert(!c->ltab[i].tgc);\r\nif (i + c->lpt_first == c->nhead_lnum ||\r\nc->ltab[i].free + c->ltab[i].dirty == c->leb_size)\r\ncontinue;\r\nif (c->ltab[i].dirty > dirty) {\r\ndirty = c->ltab[i].dirty;\r\nlnum = i + c->lpt_first;\r\n}\r\n}\r\nmutex_unlock(&c->lp_mutex);\r\nif (lnum == -1)\r\nreturn -ENOSPC;\r\nreturn lpt_gc_lnum(c, lnum);\r\n}\r\nint ubifs_lpt_start_commit(struct ubifs_info *c)\r\n{\r\nint err, cnt;\r\ndbg_lp("");\r\nmutex_lock(&c->lp_mutex);\r\nerr = dbg_chk_lpt_free_spc(c);\r\nif (err)\r\ngoto out;\r\nerr = dbg_check_ltab(c);\r\nif (err)\r\ngoto out;\r\nif (c->check_lpt_free) {\r\nc->check_lpt_free = 0;\r\nwhile (need_write_all(c)) {\r\nmutex_unlock(&c->lp_mutex);\r\nerr = lpt_gc(c);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&c->lp_mutex);\r\n}\r\n}\r\nlpt_tgc_start(c);\r\nif (!c->dirty_pn_cnt) {\r\ndbg_cmt("no cnodes to commit");\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (!c->big_lpt && need_write_all(c)) {\r\nerr = make_tree_dirty(c);\r\nif (err)\r\ngoto out;\r\nlpt_tgc_start(c);\r\n}\r\nif (c->big_lpt)\r\npopulate_lsave(c);\r\ncnt = get_cnodes_to_commit(c);\r\nubifs_assert(cnt != 0);\r\nerr = layout_cnodes(c);\r\nif (err)\r\ngoto out;\r\nmemcpy(c->ltab_cmt, c->ltab,\r\nsizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\r\nc->lpt_drty_flgs &= ~(LTAB_DIRTY | LSAVE_DIRTY);\r\nout:\r\nmutex_unlock(&c->lp_mutex);\r\nreturn err;\r\n}\r\nstatic void free_obsolete_cnodes(struct ubifs_info *c)\r\n{\r\nstruct ubifs_cnode *cnode, *cnext;\r\ncnext = c->lpt_cnext;\r\nif (!cnext)\r\nreturn;\r\ndo {\r\ncnode = cnext;\r\ncnext = cnode->cnext;\r\nif (test_bit(OBSOLETE_CNODE, &cnode->flags))\r\nkfree(cnode);\r\nelse\r\ncnode->cnext = NULL;\r\n} while (cnext != c->lpt_cnext);\r\nc->lpt_cnext = NULL;\r\n}\r\nint ubifs_lpt_end_commit(struct ubifs_info *c)\r\n{\r\nint err;\r\ndbg_lp("");\r\nif (!c->lpt_cnext)\r\nreturn 0;\r\nerr = write_cnodes(c);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&c->lp_mutex);\r\nfree_obsolete_cnodes(c);\r\nmutex_unlock(&c->lp_mutex);\r\nreturn 0;\r\n}\r\nint ubifs_lpt_post_commit(struct ubifs_info *c)\r\n{\r\nint err;\r\nmutex_lock(&c->lp_mutex);\r\nerr = lpt_tgc_end(c);\r\nif (err)\r\ngoto out;\r\nif (c->big_lpt)\r\nwhile (need_write_all(c)) {\r\nmutex_unlock(&c->lp_mutex);\r\nerr = lpt_gc(c);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&c->lp_mutex);\r\n}\r\nout:\r\nmutex_unlock(&c->lp_mutex);\r\nreturn err;\r\n}\r\nstatic struct ubifs_nnode *first_nnode(struct ubifs_info *c, int *hght)\r\n{\r\nstruct ubifs_nnode *nnode;\r\nint h, i, found;\r\nnnode = c->nroot;\r\n*hght = 0;\r\nif (!nnode)\r\nreturn NULL;\r\nfor (h = 1; h < c->lpt_hght; h++) {\r\nfound = 0;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nif (nnode->nbranch[i].nnode) {\r\nfound = 1;\r\nnnode = nnode->nbranch[i].nnode;\r\n*hght = h;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nbreak;\r\n}\r\nreturn nnode;\r\n}\r\nstatic struct ubifs_nnode *next_nnode(struct ubifs_info *c,\r\nstruct ubifs_nnode *nnode, int *hght)\r\n{\r\nstruct ubifs_nnode *parent;\r\nint iip, h, i, found;\r\nparent = nnode->parent;\r\nif (!parent)\r\nreturn NULL;\r\nif (nnode->iip == UBIFS_LPT_FANOUT - 1) {\r\n*hght -= 1;\r\nreturn parent;\r\n}\r\nfor (iip = nnode->iip + 1; iip < UBIFS_LPT_FANOUT; iip++) {\r\nnnode = parent->nbranch[iip].nnode;\r\nif (nnode)\r\nbreak;\r\n}\r\nif (!nnode) {\r\n*hght -= 1;\r\nreturn parent;\r\n}\r\nfor (h = *hght + 1; h < c->lpt_hght; h++) {\r\nfound = 0;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nif (nnode->nbranch[i].nnode) {\r\nfound = 1;\r\nnnode = nnode->nbranch[i].nnode;\r\n*hght = h;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nbreak;\r\n}\r\nreturn nnode;\r\n}\r\nvoid ubifs_lpt_free(struct ubifs_info *c, int wr_only)\r\n{\r\nstruct ubifs_nnode *nnode;\r\nint i, hght;\r\nfree_obsolete_cnodes(c);\r\nvfree(c->ltab_cmt);\r\nc->ltab_cmt = NULL;\r\nvfree(c->lpt_buf);\r\nc->lpt_buf = NULL;\r\nkfree(c->lsave);\r\nc->lsave = NULL;\r\nif (wr_only)\r\nreturn;\r\nnnode = first_nnode(c, &hght);\r\nwhile (nnode) {\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++)\r\nkfree(nnode->nbranch[i].nnode);\r\nnnode = next_nnode(c, nnode, &hght);\r\n}\r\nfor (i = 0; i < LPROPS_HEAP_CNT; i++)\r\nkfree(c->lpt_heap[i].arr);\r\nkfree(c->dirty_idx.arr);\r\nkfree(c->nroot);\r\nvfree(c->ltab);\r\nkfree(c->lpt_nod_buf);\r\n}\r\nstatic int dbg_is_all_ff(uint8_t *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (buf[i] != 0xff)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int dbg_is_nnode_dirty(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nstruct ubifs_nnode *nnode;\r\nint hght;\r\nnnode = first_nnode(c, &hght);\r\nfor (; nnode; nnode = next_nnode(c, nnode, &hght)) {\r\nstruct ubifs_nbranch *branch;\r\ncond_resched();\r\nif (nnode->parent) {\r\nbranch = &nnode->parent->nbranch[nnode->iip];\r\nif (branch->lnum != lnum || branch->offs != offs)\r\ncontinue;\r\nif (test_bit(DIRTY_CNODE, &nnode->flags))\r\nreturn 1;\r\nreturn 0;\r\n} else {\r\nif (c->lpt_lnum != lnum || c->lpt_offs != offs)\r\ncontinue;\r\nif (test_bit(DIRTY_CNODE, &nnode->flags))\r\nreturn 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int dbg_is_pnode_dirty(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nint i, cnt;\r\ncnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\r\nfor (i = 0; i < cnt; i++) {\r\nstruct ubifs_pnode *pnode;\r\nstruct ubifs_nbranch *branch;\r\ncond_resched();\r\npnode = pnode_lookup(c, i);\r\nif (IS_ERR(pnode))\r\nreturn PTR_ERR(pnode);\r\nbranch = &pnode->parent->nbranch[pnode->iip];\r\nif (branch->lnum != lnum || branch->offs != offs)\r\ncontinue;\r\nif (test_bit(DIRTY_CNODE, &pnode->flags))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int dbg_is_ltab_dirty(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nif (lnum != c->ltab_lnum || offs != c->ltab_offs)\r\nreturn 1;\r\nreturn (c->lpt_drty_flgs & LTAB_DIRTY) != 0;\r\n}\r\nstatic int dbg_is_lsave_dirty(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nif (lnum != c->lsave_lnum || offs != c->lsave_offs)\r\nreturn 1;\r\nreturn (c->lpt_drty_flgs & LSAVE_DIRTY) != 0;\r\n}\r\nstatic int dbg_is_node_dirty(struct ubifs_info *c, int node_type, int lnum,\r\nint offs)\r\n{\r\nswitch (node_type) {\r\ncase UBIFS_LPT_NNODE:\r\nreturn dbg_is_nnode_dirty(c, lnum, offs);\r\ncase UBIFS_LPT_PNODE:\r\nreturn dbg_is_pnode_dirty(c, lnum, offs);\r\ncase UBIFS_LPT_LTAB:\r\nreturn dbg_is_ltab_dirty(c, lnum, offs);\r\ncase UBIFS_LPT_LSAVE:\r\nreturn dbg_is_lsave_dirty(c, lnum, offs);\r\n}\r\nreturn 1;\r\n}\r\nstatic int dbg_check_ltab_lnum(struct ubifs_info *c, int lnum)\r\n{\r\nint err, len = c->leb_size, dirty = 0, node_type, node_num, node_len;\r\nint ret;\r\nvoid *buf, *p;\r\nif (!dbg_is_chk_lprops(c))\r\nreturn 0;\r\nbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\r\nif (!buf) {\r\nubifs_err("cannot allocate memory for ltab checking");\r\nreturn 0;\r\n}\r\ndbg_lp("LEB %d", lnum);\r\nerr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\r\nif (err)\r\ngoto out;\r\nwhile (1) {\r\nif (!is_a_node(c, p, len)) {\r\nint i, pad_len;\r\npad_len = get_pad_len(c, p, len);\r\nif (pad_len) {\r\np += pad_len;\r\nlen -= pad_len;\r\ndirty += pad_len;\r\ncontinue;\r\n}\r\nif (!dbg_is_all_ff(p, len)) {\r\nubifs_err("invalid empty space in LEB %d at %d",\r\nlnum, c->leb_size - len);\r\nerr = -EINVAL;\r\n}\r\ni = lnum - c->lpt_first;\r\nif (len != c->ltab[i].free) {\r\nubifs_err("invalid free space in LEB %d (free %d, expected %d)",\r\nlnum, len, c->ltab[i].free);\r\nerr = -EINVAL;\r\n}\r\nif (dirty != c->ltab[i].dirty) {\r\nubifs_err("invalid dirty space in LEB %d (dirty %d, expected %d)",\r\nlnum, dirty, c->ltab[i].dirty);\r\nerr = -EINVAL;\r\n}\r\ngoto out;\r\n}\r\nnode_type = get_lpt_node_type(c, p, &node_num);\r\nnode_len = get_lpt_node_len(c, node_type);\r\nret = dbg_is_node_dirty(c, node_type, lnum, c->leb_size - len);\r\nif (ret == 1)\r\ndirty += node_len;\r\np += node_len;\r\nlen -= node_len;\r\n}\r\nerr = 0;\r\nout:\r\nvfree(buf);\r\nreturn err;\r\n}\r\nint dbg_check_ltab(struct ubifs_info *c)\r\n{\r\nint lnum, err, i, cnt;\r\nif (!dbg_is_chk_lprops(c))\r\nreturn 0;\r\ncnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\r\nfor (i = 0; i < cnt; i++) {\r\nstruct ubifs_pnode *pnode;\r\npnode = pnode_lookup(c, i);\r\nif (IS_ERR(pnode))\r\nreturn PTR_ERR(pnode);\r\ncond_resched();\r\n}\r\nerr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)c->nroot, 0, 0);\r\nif (err)\r\nreturn err;\r\nfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\r\nerr = dbg_check_ltab_lnum(c, lnum);\r\nif (err) {\r\nubifs_err("failed at LEB %d", lnum);\r\nreturn err;\r\n}\r\n}\r\ndbg_lp("succeeded");\r\nreturn 0;\r\n}\r\nint dbg_chk_lpt_free_spc(struct ubifs_info *c)\r\n{\r\nlong long free = 0;\r\nint i;\r\nif (!dbg_is_chk_lprops(c))\r\nreturn 0;\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\nif (c->ltab[i].tgc || c->ltab[i].cmt)\r\ncontinue;\r\nif (i + c->lpt_first == c->nhead_lnum)\r\nfree += c->leb_size - c->nhead_offs;\r\nelse if (c->ltab[i].free == c->leb_size)\r\nfree += c->leb_size;\r\n}\r\nif (free < c->lpt_sz) {\r\nubifs_err("LPT space error: free %lld lpt_sz %lld",\r\nfree, c->lpt_sz);\r\nubifs_dump_lpt_info(c);\r\nubifs_dump_lpt_lebs(c);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint dbg_chk_lpt_sz(struct ubifs_info *c, int action, int len)\r\n{\r\nstruct ubifs_debug_info *d = c->dbg;\r\nlong long chk_lpt_sz, lpt_sz;\r\nint err = 0;\r\nif (!dbg_is_chk_lprops(c))\r\nreturn 0;\r\nswitch (action) {\r\ncase 0:\r\nd->chk_lpt_sz = 0;\r\nd->chk_lpt_sz2 = 0;\r\nd->chk_lpt_lebs = 0;\r\nd->chk_lpt_wastage = 0;\r\nif (c->dirty_pn_cnt > c->pnode_cnt) {\r\nubifs_err("dirty pnodes %d exceed max %d",\r\nc->dirty_pn_cnt, c->pnode_cnt);\r\nerr = -EINVAL;\r\n}\r\nif (c->dirty_nn_cnt > c->nnode_cnt) {\r\nubifs_err("dirty nnodes %d exceed max %d",\r\nc->dirty_nn_cnt, c->nnode_cnt);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\ncase 1:\r\nd->chk_lpt_sz += len;\r\nreturn 0;\r\ncase 2:\r\nd->chk_lpt_sz += len;\r\nd->chk_lpt_wastage += len;\r\nd->chk_lpt_lebs += 1;\r\nreturn 0;\r\ncase 3:\r\nchk_lpt_sz = c->leb_size;\r\nchk_lpt_sz *= d->chk_lpt_lebs;\r\nchk_lpt_sz += len - c->nhead_offs;\r\nif (d->chk_lpt_sz != chk_lpt_sz) {\r\nubifs_err("LPT wrote %lld but space used was %lld",\r\nd->chk_lpt_sz, chk_lpt_sz);\r\nerr = -EINVAL;\r\n}\r\nif (d->chk_lpt_sz > c->lpt_sz) {\r\nubifs_err("LPT wrote %lld but lpt_sz is %lld",\r\nd->chk_lpt_sz, c->lpt_sz);\r\nerr = -EINVAL;\r\n}\r\nif (d->chk_lpt_sz2 && d->chk_lpt_sz != d->chk_lpt_sz2) {\r\nubifs_err("LPT layout size %lld but wrote %lld",\r\nd->chk_lpt_sz, d->chk_lpt_sz2);\r\nerr = -EINVAL;\r\n}\r\nif (d->chk_lpt_sz2 && d->new_nhead_offs != len) {\r\nubifs_err("LPT new nhead offs: expected %d was %d",\r\nd->new_nhead_offs, len);\r\nerr = -EINVAL;\r\n}\r\nlpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\r\nlpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\r\nlpt_sz += c->ltab_sz;\r\nif (c->big_lpt)\r\nlpt_sz += c->lsave_sz;\r\nif (d->chk_lpt_sz - d->chk_lpt_wastage > lpt_sz) {\r\nubifs_err("LPT chk_lpt_sz %lld + waste %lld exceeds %lld",\r\nd->chk_lpt_sz, d->chk_lpt_wastage, lpt_sz);\r\nerr = -EINVAL;\r\n}\r\nif (err) {\r\nubifs_dump_lpt_info(c);\r\nubifs_dump_lpt_lebs(c);\r\ndump_stack();\r\n}\r\nd->chk_lpt_sz2 = d->chk_lpt_sz;\r\nd->chk_lpt_sz = 0;\r\nd->chk_lpt_wastage = 0;\r\nd->chk_lpt_lebs = 0;\r\nd->new_nhead_offs = len;\r\nreturn err;\r\ncase 4:\r\nd->chk_lpt_sz += len;\r\nd->chk_lpt_wastage += len;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void dump_lpt_leb(const struct ubifs_info *c, int lnum)\r\n{\r\nint err, len = c->leb_size, node_type, node_num, node_len, offs;\r\nvoid *buf, *p;\r\npr_err("(pid %d) start dumping LEB %d\n", current->pid, lnum);\r\nbuf = p = __vmalloc(c->leb_size, GFP_NOFS, PAGE_KERNEL);\r\nif (!buf) {\r\nubifs_err("cannot allocate memory to dump LPT");\r\nreturn;\r\n}\r\nerr = ubifs_leb_read(c, lnum, buf, 0, c->leb_size, 1);\r\nif (err)\r\ngoto out;\r\nwhile (1) {\r\noffs = c->leb_size - len;\r\nif (!is_a_node(c, p, len)) {\r\nint pad_len;\r\npad_len = get_pad_len(c, p, len);\r\nif (pad_len) {\r\npr_err("LEB %d:%d, pad %d bytes\n",\r\nlnum, offs, pad_len);\r\np += pad_len;\r\nlen -= pad_len;\r\ncontinue;\r\n}\r\nif (len)\r\npr_err("LEB %d:%d, free %d bytes\n",\r\nlnum, offs, len);\r\nbreak;\r\n}\r\nnode_type = get_lpt_node_type(c, p, &node_num);\r\nswitch (node_type) {\r\ncase UBIFS_LPT_PNODE:\r\n{\r\nnode_len = c->pnode_sz;\r\nif (c->big_lpt)\r\npr_err("LEB %d:%d, pnode num %d\n",\r\nlnum, offs, node_num);\r\nelse\r\npr_err("LEB %d:%d, pnode\n", lnum, offs);\r\nbreak;\r\n}\r\ncase UBIFS_LPT_NNODE:\r\n{\r\nint i;\r\nstruct ubifs_nnode nnode;\r\nnode_len = c->nnode_sz;\r\nif (c->big_lpt)\r\npr_err("LEB %d:%d, nnode num %d, ",\r\nlnum, offs, node_num);\r\nelse\r\npr_err("LEB %d:%d, nnode, ",\r\nlnum, offs);\r\nerr = ubifs_unpack_nnode(c, p, &nnode);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\npr_cont("%d:%d", nnode.nbranch[i].lnum,\r\nnnode.nbranch[i].offs);\r\nif (i != UBIFS_LPT_FANOUT - 1)\r\npr_cont(", ");\r\n}\r\npr_cont("\n");\r\nbreak;\r\n}\r\ncase UBIFS_LPT_LTAB:\r\nnode_len = c->ltab_sz;\r\npr_err("LEB %d:%d, ltab\n", lnum, offs);\r\nbreak;\r\ncase UBIFS_LPT_LSAVE:\r\nnode_len = c->lsave_sz;\r\npr_err("LEB %d:%d, lsave len\n", lnum, offs);\r\nbreak;\r\ndefault:\r\nubifs_err("LPT node type %d not recognized", node_type);\r\ngoto out;\r\n}\r\np += node_len;\r\nlen -= node_len;\r\n}\r\npr_err("(pid %d) finish dumping LEB %d\n", current->pid, lnum);\r\nout:\r\nvfree(buf);\r\nreturn;\r\n}\r\nvoid ubifs_dump_lpt_lebs(const struct ubifs_info *c)\r\n{\r\nint i;\r\npr_err("(pid %d) start dumping all LPT LEBs\n", current->pid);\r\nfor (i = 0; i < c->lpt_lebs; i++)\r\ndump_lpt_leb(c, i + c->lpt_first);\r\npr_err("(pid %d) finish dumping all LPT LEBs\n", current->pid);\r\n}\r\nstatic int dbg_populate_lsave(struct ubifs_info *c)\r\n{\r\nstruct ubifs_lprops *lprops;\r\nstruct ubifs_lpt_heap *heap;\r\nint i;\r\nif (!dbg_is_chk_gen(c))\r\nreturn 0;\r\nif (random32() & 3)\r\nreturn 0;\r\nfor (i = 0; i < c->lsave_cnt; i++)\r\nc->lsave[i] = c->main_first;\r\nlist_for_each_entry(lprops, &c->empty_list, list)\r\nc->lsave[random32() % c->lsave_cnt] = lprops->lnum;\r\nlist_for_each_entry(lprops, &c->freeable_list, list)\r\nc->lsave[random32() % c->lsave_cnt] = lprops->lnum;\r\nlist_for_each_entry(lprops, &c->frdi_idx_list, list)\r\nc->lsave[random32() % c->lsave_cnt] = lprops->lnum;\r\nheap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\r\nfor (i = 0; i < heap->cnt; i++)\r\nc->lsave[random32() % c->lsave_cnt] = heap->arr[i]->lnum;\r\nheap = &c->lpt_heap[LPROPS_DIRTY - 1];\r\nfor (i = 0; i < heap->cnt; i++)\r\nc->lsave[random32() % c->lsave_cnt] = heap->arr[i]->lnum;\r\nheap = &c->lpt_heap[LPROPS_FREE - 1];\r\nfor (i = 0; i < heap->cnt; i++)\r\nc->lsave[random32() % c->lsave_cnt] = heap->arr[i]->lnum;\r\nreturn 1;\r\n}
