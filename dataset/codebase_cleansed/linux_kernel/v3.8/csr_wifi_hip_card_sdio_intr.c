static void append_char(char c)\r\n{\r\n*unifi_dbgbuf_ptr++ = c;\r\nif ((unifi_dbgbuf_ptr - unifi_debug_output) >= UNIFI_DEBUG_GBUFFER_SIZE)\r\n{\r\nunifi_dbgbuf_ptr = unifi_debug_output;\r\n}\r\n}\r\nvoid unifi_debug_string_to_buf(const char *str)\r\n{\r\nconst char *p = str;\r\nwhile (*p)\r\n{\r\nappend_char(*p);\r\np++;\r\n}\r\nunifi_dbgbuf_start = unifi_dbgbuf_ptr + 1;\r\nif ((unifi_dbgbuf_start - unifi_debug_output) >= UNIFI_DEBUG_GBUFFER_SIZE)\r\n{\r\nunifi_dbgbuf_start = unifi_debug_output;\r\n}\r\n}\r\nvoid unifi_debug_log_to_buf(const char *fmt, ...)\r\n{\r\n#define DEBUG_BUFFER_SIZE 80\r\nstatic char s[DEBUG_BUFFER_SIZE];\r\nva_list args;\r\nva_start(args, fmt);\r\nvsnprintf(s, DEBUG_BUFFER_SIZE, fmt, args);\r\nva_end(args);\r\nunifi_debug_string_to_buf(s);\r\n}\r\nstatic void CsrUInt16ToHex(u16 number, char *str)\r\n{\r\nu16 index;\r\nu16 currentValue;\r\nfor (index = 0; index < 4; index++)\r\n{\r\ncurrentValue = (u16) (number & 0x000F);\r\nnumber >>= 4;\r\nstr[3 - index] = (char) (currentValue > 9 ? currentValue + 55 : currentValue + '0');\r\n}\r\nstr[4] = '\0';\r\n}\r\nvoid unifi_debug_hex_to_buf(const char *buff, u16 length)\r\n{\r\nchar s[5];\r\nu16 i;\r\nfor (i = 0; i < length; i = i + 2)\r\n{\r\nCsrUInt16ToHex(*((u16 *)(buff + i)), s);\r\nunifi_debug_string_to_buf(s);\r\n}\r\n}\r\nvoid unifi_debug_buf_dump(void)\r\n{\r\ns32 offset = unifi_dbgbuf_ptr - unifi_debug_output;\r\nunifi_error(NULL, "HIP debug buffer offset=%d\n", offset);\r\ndump_str(unifi_debug_output + offset, UNIFI_DEBUG_GBUFFER_SIZE - offset);\r\ndump_str(unifi_debug_output, offset);\r\n}\r\nvoid prealloc_netdata_free(card_t *card)\r\n{\r\nunifi_warning(card->ospriv, "prealloc_netdata_free: IN: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);\r\nwhile (card->bulk_data_desc_list[card->prealloc_netdata_r].data_length != 0)\r\n{\r\nunifi_warning(card->ospriv, "prealloc_netdata_free: r=%d\n", card->prealloc_netdata_r);\r\nunifi_net_data_free(card->ospriv, &card->bulk_data_desc_list[card->prealloc_netdata_r]);\r\ncard->prealloc_netdata_r++;\r\ncard->prealloc_netdata_r %= BULK_DATA_PRE_ALLOC_NUM;\r\n}\r\ncard->prealloc_netdata_r = card->prealloc_netdata_w = 0;\r\nunifi_warning(card->ospriv, "prealloc_netdata_free: OUT: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);\r\n}\r\nCsrResult prealloc_netdata_alloc(card_t *card)\r\n{\r\nCsrResult r;\r\nunifi_trace(card->ospriv, UDBG5, "prealloc_netdata_alloc: IN: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);\r\nwhile (card->bulk_data_desc_list[card->prealloc_netdata_w].data_length == 0)\r\n{\r\nr = unifi_net_data_malloc(card->ospriv, &card->bulk_data_desc_list[card->prealloc_netdata_w], NETDATA_PRE_ALLOC_BUF_SIZE);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "prealloc_netdata_alloc: Failed to allocate t-h bulk data\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\ncard->prealloc_netdata_w++;\r\ncard->prealloc_netdata_w %= BULK_DATA_PRE_ALLOC_NUM;\r\n}\r\nunifi_trace(card->ospriv, UDBG5, "prealloc_netdata_alloc: OUT: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult prealloc_netdata_get(card_t *card, bulk_data_desc_t *bulk_data_slot, u32 size)\r\n{\r\nCsrResult r;\r\nunifi_trace(card->ospriv, UDBG5, "prealloc_netdata_get: IN: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);\r\nif (card->bulk_data_desc_list[card->prealloc_netdata_r].data_length == 0)\r\n{\r\nunifi_error(card->ospriv, "prealloc_netdata_get: data_length = 0\n");\r\n}\r\nif ((size > NETDATA_PRE_ALLOC_BUF_SIZE) || (card->bulk_data_desc_list[card->prealloc_netdata_r].data_length == 0))\r\n{\r\nunifi_warning(card->ospriv, "prealloc_netdata_get: Calling net_data_malloc\n");\r\nr = unifi_net_data_malloc(card->ospriv, bulk_data_slot, size);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "prealloc_netdata_get: Failed to allocate t-h bulk data\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\n*bulk_data_slot = card->bulk_data_desc_list[card->prealloc_netdata_r];\r\ncard->bulk_data_desc_list[card->prealloc_netdata_r].os_data_ptr = NULL;\r\ncard->bulk_data_desc_list[card->prealloc_netdata_r].os_net_buf_ptr = NULL;\r\ncard->bulk_data_desc_list[card->prealloc_netdata_r].net_buf_length = 0;\r\ncard->bulk_data_desc_list[card->prealloc_netdata_r].data_length = 0;\r\ncard->prealloc_netdata_r++;\r\ncard->prealloc_netdata_r %= BULK_DATA_PRE_ALLOC_NUM;\r\nunifi_trace(card->ospriv, UDBG5, "prealloc_netdata_get: OUT: w=%d r=%d\n", card->prealloc_netdata_w, card->prealloc_netdata_r);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nvoid unifi_sdio_interrupt_handler(card_t *card)\r\n{\r\ncard->bh_reason_unifi = 1;\r\n(void)unifi_run_bh(card->ospriv);\r\n}\r\nCsrResult unifi_configure_low_power_mode(card_t *card,\r\nenum unifi_low_power_mode low_power_mode,\r\nenum unifi_periodic_wake_mode periodic_wake_mode)\r\n{\r\ncard->low_power_mode = low_power_mode;\r\ncard->periodic_wake_mode = periodic_wake_mode;\r\nunifi_trace(card->ospriv, UDBG1,\r\n"unifi_configure_low_power_mode: new mode = %s, wake_host = %s\n",\r\n(low_power_mode == UNIFI_LOW_POWER_DISABLED)?"disabled" : "enabled",\r\n(periodic_wake_mode == UNIFI_PERIODIC_WAKE_HOST_DISABLED)?"FALSE" : "TRUE");\r\n(void)unifi_run_bh(card->ospriv);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult unifi_force_low_power_mode(card_t *card)\r\n{\r\nif (card->low_power_mode == UNIFI_LOW_POWER_DISABLED)\r\n{\r\nunifi_error(card->ospriv, "Attempt to set mode to TORPID when lower power mode is disabled\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nreturn unifi_set_host_state(card, UNIFI_HOST_STATE_TORPID);\r\n}\r\nCsrResult unifi_bh(card_t *card, u32 *remaining)\r\n{\r\nCsrResult r;\r\nCsrResult csrResult;\r\nu8 pending;\r\ns32 iostate, j;\r\nconst enum unifi_low_power_mode low_power_mode = card->low_power_mode;\r\nu16 data_slots_used = 0;\r\nr = process_clock_request(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Error setting maximum SDIO clock\n");\r\ngoto exit;\r\n}\r\ndo\r\n{\r\nif (card->host_state == UNIFI_HOST_STATE_DROWSY || card->host_state == UNIFI_HOST_STATE_TORPID)\r\n{\r\nu8 reason_unifi;\r\nreason_unifi = card->bh_reason_unifi;\r\nr = CardPendingInt(card, &pending);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\ngoto exit;\r\n}\r\nif (pending)\r\n{\r\nunifi_trace(card->ospriv, UDBG5,\r\n"UNIFI_HOST_STATE_%s: Set state to AWAKE.\n",\r\n(card->host_state == UNIFI_HOST_STATE_TORPID)?"TORPID" : "DROWSY");\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);\r\nif (r == CSR_RESULT_SUCCESS)\r\n{\r\n(*remaining) = 0;\r\nbreak;\r\n}\r\n}\r\nelse if (reason_unifi)\r\n{\r\nCsrSdioInterruptAcknowledge(card->sdio_if);\r\n}\r\nif ((card->host_state == UNIFI_HOST_STATE_TORPID) && card->bh_reason_host)\r\n{\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_DROWSY);\r\nif (r == CSR_RESULT_SUCCESS)\r\n{\r\ncard->bh_reason_host = 0;\r\n(*remaining) = UNIFI_DEFAULT_WAKE_TIMEOUT;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\ngoto exit;\r\n}\r\nif ((card->host_state == UNIFI_HOST_STATE_DROWSY) && ((*remaining) == 0))\r\n{\r\nunifi_error(card->ospriv, "UniFi did not wake up on time...\n");\r\nr = unifi_check_io_status(card, &iostate);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\ngoto exit;\r\n}\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n}\r\nelse\r\n{\r\nif (card->bh_reason_unifi || card->bh_reason_host)\r\n{\r\nbreak;\r\n}\r\nif (((*remaining) == 0) && (low_power_mode == UNIFI_LOW_POWER_ENABLED))\r\n{\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_TORPID);\r\nif (r == CSR_RESULT_SUCCESS)\r\n{\r\n(*remaining) = 0;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\ngoto exit;\r\n}\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n} while (0);\r\ncsrResult = CsrSdioInterruptDisable(card->sdio_if);\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nr = CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\ngoto exit;\r\n}\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nunifi_error(card->ospriv, "Failed to disable SDIO interrupts. unifi_bh queues error.\n");\r\ngoto exit;\r\n}\r\nCsrSdioInterruptAcknowledge(card->sdio_if);\r\nr = process_bh(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\ngoto exit;\r\n}\r\nfor (j = 0; j < UNIFI_NO_OF_TX_QS; j++)\r\n{\r\ndata_slots_used += CSR_WIFI_HIP_Q_SLOTS_USED(&card->fh_traffic_queue[j]);\r\n}\r\nif ((low_power_mode == UNIFI_LOW_POWER_ENABLED) && (data_slots_used == 0))\r\n{\r\n#ifndef CSR_WIFI_HIP_TA_DISABLE\r\nif (card->ta_sampling.traffic_type != CSR_WIFI_ROUTER_CTRL_TRAFFIC_TYPE_PERIODIC)\r\n{\r\n#endif\r\nunifi_trace(card->ospriv, UDBG5,\r\n"Traffic is not periodic, set timer for TORPID.\n");\r\n(*remaining) = UNIFI_DEFAULT_HOST_IDLE_TIMEOUT;\r\n#ifndef CSR_WIFI_HIP_TA_DISABLE\r\n}\r\nelse\r\n{\r\nunifi_trace(card->ospriv, UDBG5,\r\n"Traffic is periodic, set unifi to TORPID immediately.\n");\r\nif (CardAreAllFromHostDataSlotsEmpty(card) == 1)\r\n{\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_TORPID);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\ngoto exit;\r\n}\r\n}\r\n}\r\n#endif\r\n}\r\ncsrResult = CsrSdioInterruptEnable(card->sdio_if);\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nr = CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nunifi_error(card->ospriv, "Failed to enable SDIO interrupt\n");\r\n}\r\nexit:\r\nunifi_trace(card->ospriv, UDBG4, "New state=%d\n", card->host_state);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)\r\nunifi_debug_buf_dump();\r\n#endif\r\nif (card->bh_reason_unifi)\r\n{\r\nCsrSdioInterruptAcknowledge(card->sdio_if);\r\n}\r\nunifi_error(card->ospriv,\r\n"unifi_bh: state=%d %c, clock=%dkHz, interrupt=%d host=%d, power_save=%s\n",\r\ncard->host_state,\r\n(card->host_state == UNIFI_HOST_STATE_AWAKE)?'A' : (card->host_state == UNIFI_HOST_STATE_DROWSY)?'D' : 'T',\r\ncard->sdio_clock_speed / 1000,\r\ncard->bh_reason_unifi, card->bh_reason_host,\r\n(low_power_mode == UNIFI_LOW_POWER_DISABLED)?"disabled" : "enabled");\r\n(void)unifi_capture_panic(card);\r\n(void)unifi_coredump_request_at_next_reset(card, 1);\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult process_clock_request(card_t *card)\r\n{\r\nCsrResult r = CSR_RESULT_SUCCESS;\r\nCsrResult csrResult;\r\nif (!card->request_max_clock)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nif (card->host_state == UNIFI_HOST_STATE_AWAKE)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Set SDIO max clock\n");\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_MAX_HZ);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\n}\r\nelse\r\n{\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_MAX_HZ;\r\n}\r\n}\r\nelse\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Will set SDIO max clock after wakeup\n");\r\n}\r\ncard->request_max_clock = 0;\r\nreturn r;\r\n}\r\nstatic CsrResult process_bh(card_t *card)\r\n{\r\nCsrResult r;\r\nu8 more;\r\nmore = FALSE;\r\ndo\r\n{\r\ndo\r\n{\r\nif (card->intmode & CSR_WIFI_INTMODE_RUN_BH_ONCE)\r\n{\r\nbreak;\r\n}\r\nr = handle_host_protocol(card, &more);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\nunifi_debug_log_to_buf("c52=%d c53=%d tx=%d txc=%d rx=%d s=%d t=%d fc=%d\n",\r\ncard->cmd_prof.cmd52_count,\r\ncard->cmd_prof.cmd53_count,\r\ncard->cmd_prof.tx_count,\r\ncard->cmd_prof.tx_cfm_count,\r\ncard->cmd_prof.rx_count,\r\ncard->cmd_prof.sdio_cmd_signal,\r\ncard->cmd_prof.sdio_cmd_to_host,\r\ncard->cmd_prof.sdio_cmd_from_host_and_clear\r\n);\r\ncard->cmd_prof.cmd52_count = card->cmd_prof.cmd53_count = 0;\r\ncard->cmd_prof.tx_count = card->cmd_prof.tx_cfm_count = card->cmd_prof.rx_count = 0;\r\ncard->cmd_prof.cmd52_f0_r_count = 0;\r\ncard->cmd_prof.cmd52_f0_w_count = 0;\r\ncard->cmd_prof.cmd52_r8or16_count = 0;\r\ncard->cmd_prof.cmd52_w8or16_count = 0;\r\ncard->cmd_prof.cmd52_r16_count = 0;\r\ncard->cmd_prof.cmd52_w16_count = 0;\r\ncard->cmd_prof.cmd52_r32_count = 0;\r\ncard->cmd_prof.sdio_cmd_signal = 0;\r\ncard->cmd_prof.sdio_cmd_clear_slot = 0;\r\ncard->cmd_prof.sdio_cmd_to_host = 0;\r\ncard->cmd_prof.sdio_cmd_from_host = 0;\r\ncard->cmd_prof.sdio_cmd_from_host_and_clear = 0;\r\n#endif\r\n} while (more || card->bh_reason_unifi || card->bh_reason_host);\r\nr = CardClearInt(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to acknowledge interrupt.\n");\r\nreturn r;\r\n}\r\nr = handle_host_protocol(card, &more);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\nunifi_debug_log_to_buf("c52=%d c53=%d tx=%d txc=%d rx=%d s=%d t=%d fc=%d\n",\r\ncard->cmd_prof.cmd52_count,\r\ncard->cmd_prof.cmd53_count,\r\ncard->cmd_prof.tx_count,\r\ncard->cmd_prof.tx_cfm_count,\r\ncard->cmd_prof.rx_count,\r\ncard->cmd_prof.sdio_cmd_signal,\r\ncard->cmd_prof.sdio_cmd_to_host,\r\ncard->cmd_prof.sdio_cmd_from_host_and_clear\r\n);\r\ncard->cmd_prof.cmd52_count = card->cmd_prof.cmd53_count = 0;\r\ncard->cmd_prof.tx_count = card->cmd_prof.tx_cfm_count = card->cmd_prof.rx_count = 0;\r\ncard->cmd_prof.cmd52_f0_r_count = 0;\r\ncard->cmd_prof.cmd52_f0_w_count = 0;\r\ncard->cmd_prof.cmd52_r8or16_count = 0;\r\ncard->cmd_prof.cmd52_w8or16_count = 0;\r\ncard->cmd_prof.cmd52_r16_count = 0;\r\ncard->cmd_prof.cmd52_w16_count = 0;\r\ncard->cmd_prof.cmd52_r32_count = 0;\r\ncard->cmd_prof.sdio_cmd_signal = 0;\r\ncard->cmd_prof.sdio_cmd_clear_slot = 0;\r\ncard->cmd_prof.sdio_cmd_to_host = 0;\r\ncard->cmd_prof.sdio_cmd_from_host = 0;\r\ncard->cmd_prof.sdio_cmd_from_host_and_clear = 0;\r\n#endif\r\nif (card->intmode & CSR_WIFI_INTMODE_RUN_BH_ONCE)\r\n{\r\nbreak;\r\n}\r\n} while (more || card->bh_reason_unifi || card->bh_reason_host);\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\nif ((card->intmode & CSR_WIFI_INTMODE_RUN_BH_ONCE) == 0)\r\n{\r\nunifi_debug_log_to_buf("proc=%d\n",\r\ncard->cmd_prof.process_count);\r\n}\r\n#endif\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult handle_host_protocol(card_t *card, u8 *processed_something)\r\n{\r\nCsrResult r;\r\ns32 done;\r\n*processed_something = FALSE;\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, " ======================== \n");\r\n#endif\r\n#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE\r\ncard->cmd_prof.process_count++;\r\n#endif\r\ncard->bh_reason_unifi = card->bh_reason_host = 0;\r\ncard->generate_interrupt = 0;\r\nr = read_to_host_signals(card, &done);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Error occured reading to-host signals\n");\r\nreturn r;\r\n}\r\nif (done > 0)\r\n{\r\n*processed_something = TRUE;\r\n}\r\nr = process_to_host_signals(card, &done);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Error occured processing to-host signals\n");\r\nreturn r;\r\n}\r\nr = process_fh_cmd_queue(card, &done);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Error occured processing from-host signals\n");\r\nreturn r;\r\n}\r\nif (done > 0)\r\n{\r\n*processed_something = TRUE;\r\n}\r\nr = process_fh_traffic_queue(card, &done);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Error occured processing from-host data signals\n");\r\nreturn r;\r\n}\r\nif (done > 0)\r\n{\r\n*processed_something = TRUE;\r\n}\r\nr = flush_fh_buffer(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to copy from-host signals to UniFi\n");\r\nreturn r;\r\n}\r\nif (card->generate_interrupt)\r\n{\r\nr = CardGenInt(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to notify UniFi that queues have been modified.\n");\r\nreturn r;\r\n}\r\n}\r\n#ifdef CSR_WIFI_RX_PATH_SPLIT\r\n#ifdef CSR_WIFI_RX_PATH_SPLIT_DONT_USE_WQ\r\nunifi_rx_queue_flush(card->ospriv);\r\n#endif\r\n#endif\r\nrestart_packet_flow(card);\r\n#ifdef CSR_PRE_ALLOC_NET_DATA\r\nr = prealloc_netdata_alloc(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "prealloc_netdata failed\n");\r\nreturn r;\r\n}\r\n#endif\r\nreturn r;\r\n}\r\nstatic CsrResult read_to_host_signals(card_t *card, s32 *processed)\r\n{\r\ns32 count_thw, count_thr;\r\ns32 unread_chunks, unread_bytes;\r\nCsrResult r;\r\n*processed = 0;\r\ncount_thw = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);\r\nif (count_thw < 0)\r\n{\r\nunifi_error(card->ospriv, "Failed to read to-host sig written count\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\ncard->to_host_signals_w = count_thw;\r\ncount_thr = card->to_host_signals_r;\r\nif (count_thw == count_thr)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nunread_chunks =\r\n(((count_thw - count_thr) + 128) % 128) - card->th_buffer.count;\r\nif (unread_chunks == 0)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nunread_bytes = card->config_data.sig_frag_size * unread_chunks;\r\nr = unifi_bulk_rw(card,\r\ncard->config_data.tohost_sigbuf_handle,\r\ncard->th_buffer.ptr,\r\nunread_bytes,\r\nUNIFI_SDIO_READ);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read ToHost signal\n");\r\nreturn r;\r\n}\r\ncard->th_buffer.ptr += unread_bytes;\r\ncard->th_buffer.count += (u16)unread_chunks;\r\n*processed = 1;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult update_to_host_signals_r(card_t *card, s16 pending)\r\n{\r\nCsrResult r;\r\ncard->to_host_signals_r =\r\n(card->to_host_signals_r + (card->th_buffer.count - pending)) % 128;\r\ncard->th_buffer.count = pending;\r\nr = unifi_write_8_or_16(card, card->sdio_ctrl_addr + 6,\r\n(u8)card->to_host_signals_r);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to update to-host signals read\n");\r\nreturn r;\r\n}\r\nr = CardGenInt(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to notify UniFi that we processed to-host signals.\n");\r\nreturn r;\r\n}\r\ncard->generate_interrupt = 0;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic void read_unpack_cmd(const u8 *ptr, bulk_data_cmd_t *bulk_data_cmd)\r\n{\r\ns16 index = 0;\r\nbulk_data_cmd->cmd_and_len = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);\r\nindex += SIZEOF_UINT16;\r\nbulk_data_cmd->data_slot = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);\r\nindex += SIZEOF_UINT16;\r\nbulk_data_cmd->offset = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);\r\nindex += SIZEOF_UINT16;\r\nbulk_data_cmd->buffer_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(ptr + index);\r\nindex += SIZEOF_UINT16;\r\n}\r\nstatic CsrResult process_to_host_signals(card_t *card, s32 *processed)\r\n{\r\ns16 pending;\r\ns16 remaining;\r\nu8 *bufptr;\r\nbulk_data_param_t data_ptrs;\r\ns16 cmd;\r\nu16 sig_len;\r\ns16 i;\r\nu16 chunks_in_buf;\r\nu16 bytes_transferred = 0;\r\nCsrResult r = CSR_RESULT_SUCCESS;\r\n*processed = 0;\r\npending = card->th_buffer.count;\r\nunifi_trace(card->ospriv, UDBG4, "handling %d to-host chunks\n", pending);\r\nif (!pending)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nbufptr = card->th_buffer.buf;\r\nwhile (pending > 0)\r\n{\r\ns16 f_flush_count = 0;\r\ncmd = bufptr[1] >> 4;\r\nsig_len = bufptr[0] + ((bufptr[1] & 0x0F) << 8);\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "Received UniFi msg cmd=%d, len=%d\n",\r\ncmd, sig_len);\r\n#endif\r\nif ((sig_len == 0) &&\r\n((cmd != SDIO_CMD_CLEAR_SLOT) && (cmd != SDIO_CMD_PADDING)))\r\n{\r\nunifi_error(card->ospriv, "incomplete signal or command: has size zero\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (cmd == SDIO_CMD_SIGNAL)\r\n{\r\nchunks_in_buf = GET_CHUNKS_FOR(card->config_data.sig_frag_size, (u16)(sig_len + 2));\r\n}\r\nelse\r\n{\r\nchunks_in_buf = 1;\r\n}\r\nif (chunks_in_buf > (u16)pending)\r\n{\r\nunifi_error(card->ospriv, "incomplete signal (0x%x?): need %d chunks, got %d\n",\r\nGET_SIGNAL_ID(bufptr + 2),\r\nchunks_in_buf, pending);\r\nunifi_error(card->ospriv, " thsw=%d, thsr=%d\n",\r\ncard->to_host_signals_w,\r\ncard->to_host_signals_r);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nswitch (cmd)\r\n{\r\ncase SDIO_CMD_SIGNAL:\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\ncard->cmd_prof.sdio_cmd_signal++;\r\n#endif\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)\r\n{\r\nu16 data_len = GET_PACKED_DATAREF_LEN(bufptr + 2, i);\r\nif (data_len > card->config_data.data_slot_size)\r\n{\r\nunifi_error(card->ospriv,\r\n"Bulk Data length (%d) exceeds Maximum Bulk Data length (%d)\n",\r\ndata_len, card->config_data.data_slot_size);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (data_len != 0)\r\n{\r\ns16 slot = GET_PACKED_DATAREF_SLOT(bufptr + 2, i);\r\nif (slot >= card->config_data.num_tohost_data_slots)\r\n{\r\nunifi_error(card->ospriv, "!!!bad slot number in to-host signal: %d, sig 0x%X\n",\r\nslot, cmd);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\ndata_ptrs.d[i].os_data_ptr = card->to_host_data[slot].os_data_ptr;\r\ndata_ptrs.d[i].os_net_buf_ptr = card->to_host_data[slot].os_net_buf_ptr;\r\ndata_ptrs.d[i].net_buf_length = card->to_host_data[slot].net_buf_length;\r\ndata_ptrs.d[i].data_length = data_len;\r\n}\r\nelse\r\n{\r\nUNIFI_INIT_BULK_DATA(&data_ptrs.d[i]);\r\n}\r\n}\r\nif (card->udi_hook)\r\n{\r\n(*card->udi_hook)(card->ospriv, bufptr + 2, sig_len,\r\n&data_ptrs, UDI_LOG_TO_HOST);\r\n}\r\n#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE\r\nif (GET_SIGNAL_ID(bufptr + 2) == CSR_MA_PACKET_CONFIRM_ID)\r\n{\r\ncard->cmd_prof.tx_cfm_count++;\r\n}\r\nelse if (GET_SIGNAL_ID(bufptr + 2) == CSR_MA_PACKET_INDICATION_ID)\r\n{\r\nif (data_ptrs.d[0].os_data_ptr)\r\n{\r\nif ((*data_ptrs.d[0].os_data_ptr) & 0x08)\r\n{\r\ncard->cmd_prof.rx_count++;\r\n}\r\n}\r\n}\r\n#endif\r\nif (GET_SIGNAL_ID(bufptr + 2) == CSR_MA_PACKET_CONFIRM_ID)\r\n{\r\nu32 host_tag = GET_PACKED_MA_PACKET_CONFIRM_HOST_TAG(bufptr + 2);\r\nu16 status = GET_PACKED_MA_PACKET_CONFIRM_TRANSMISSION_STATUS(bufptr + 2);\r\nunifi_trace(card->ospriv, UDBG4, "process_to_host_signals signal ID=%x host Tag=%x status=%x\n",\r\nGET_SIGNAL_ID(bufptr + 2), host_tag, status);\r\nif (status && (card->fh_slot_host_tag_record))\r\n{\r\nu16 num_fh_slots = card->config_data.num_fromhost_data_slots;\r\nfor (i = 0; i < num_fh_slots; i++)\r\n{\r\nif (card->fh_slot_host_tag_record[i] == host_tag)\r\n{\r\n#ifdef CSR_WIFI_REQUEUE_PACKET_TO_HAL\r\nr = unifi_reque_ma_packet_request(card->ospriv, host_tag, status, &card->from_host_data[i].bd);\r\ncard->fh_slot_host_tag_record[i] = CSR_WIFI_HIP_RESERVED_HOST_TAG;\r\nif (CSR_RESULT_SUCCESS != r)\r\n{\r\nunifi_trace(card->ospriv, UDBG5, "process_to_host_signals: Failed to requeue Packet(hTag:%x) back to HAL \n", host_tag);\r\nCardClearFromHostDataSlot(card, i);\r\n}\r\nelse\r\n{\r\nCardClearFromHostDataSlotWithoutFreeingBulkData(card, i);\r\n}\r\n#else\r\nunifi_trace(card->ospriv, UDBG4, "process_to_host_signals Clear slot=%x host tag=%x\n", i, host_tag);\r\ncard->fh_slot_host_tag_record[i] = CSR_WIFI_HIP_RESERVED_HOST_TAG;\r\nCardClearFromHostDataSlot(card, i);\r\n#endif\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nunifi_receive_event(card->ospriv, bufptr + 2, sig_len, &data_ptrs);\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)\r\n{\r\nif (GET_PACKED_DATAREF_LEN(bufptr + 2, i) != 0)\r\n{\r\ns16 slot = GET_PACKED_DATAREF_SLOT(bufptr + 2, i);\r\nif (slot < card->config_data.num_tohost_data_slots)\r\n{\r\nUNIFI_INIT_BULK_DATA(&card->to_host_data[slot]);\r\n}\r\n}\r\n}\r\n#ifndef CSR_WIFI_DEFER_TH_FLUSH\r\nif (bytes_transferred >= TO_HOST_FLUSH_THRESHOLD)\r\n{\r\nf_flush_count = 1;\r\n}\r\n#endif\r\nbreak;\r\ncase SDIO_CMD_CLEAR_SLOT:\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\ncard->cmd_prof.sdio_cmd_clear_slot++;\r\n#endif\r\nif (sig_len != 0)\r\n{\r\nunifi_error(card->ospriv, "process_to_host_signals: clear slot, bad data len: 0x%X at offset %d\n",\r\nsig_len, bufptr - card->th_buffer.buf);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = process_clear_slot_command(card, bufptr);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to process clear slot\n");\r\nreturn r;\r\n}\r\nbreak;\r\ncase SDIO_CMD_TO_HOST_TRANSFER:\r\ncase SDIO_CMD_FROM_HOST_TRANSFER:\r\ncase SDIO_CMD_FROM_HOST_AND_CLEAR:\r\ncase SDIO_CMD_OVERLAY_TRANSFER:\r\nif (sig_len & 1)\r\n{\r\nunifi_error(card->ospriv, "process_to_host_signals: bulk data, bad data len: 0x%X at offset %d\n",\r\nsig_len, bufptr - card->th_buffer.buf);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = process_bulk_data_command(card, bufptr, cmd, sig_len);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to process bulk cmd\n");\r\nreturn r;\r\n}\r\nbytes_transferred += sig_len;\r\nif (cmd == SDIO_CMD_FROM_HOST_AND_CLEAR)\r\n{\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\ncard->cmd_prof.sdio_cmd_from_host_and_clear++;\r\n#endif\r\n#ifndef CSR_WIFI_DEFER_TH_FLUSH\r\nf_flush_count = 1;\r\n#endif\r\n}\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\nelse if (cmd == SDIO_CMD_FROM_HOST_TRANSFER)\r\n{\r\ncard->cmd_prof.sdio_cmd_from_host++;\r\n}\r\nelse if (cmd == SDIO_CMD_TO_HOST_TRANSFER)\r\n{\r\ncard->cmd_prof.sdio_cmd_to_host++;\r\n}\r\n#endif\r\nbreak;\r\ncase SDIO_CMD_PADDING:\r\nbreak;\r\ndefault:\r\nunifi_error(card->ospriv, "Unrecognised to-host command: %d\n", cmd);\r\nbreak;\r\n}\r\nbufptr += chunks_in_buf * card->config_data.sig_frag_size;\r\npending -= chunks_in_buf;\r\nif (f_flush_count)\r\n{\r\nr = update_to_host_signals_r(card, pending);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nbytes_transferred = 0;\r\n}\r\n}\r\nif (pending)\r\n{\r\nunifi_warning(card->ospriv, "proc_th_sigs: %d unprocessed\n", pending);\r\n}\r\nif (card->th_buffer.count != pending)\r\n{\r\nr = update_to_host_signals_r(card, pending);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\n}\r\nremaining = card->th_buffer.ptr - bufptr;\r\nif (remaining < 0)\r\n{\r\nunifi_error(card->ospriv, "Processing TH signals overran the buffer\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (remaining > 0)\r\n{\r\nu8 *d = card->th_buffer.buf;\r\nu8 *s = bufptr;\r\ns32 n = remaining;\r\nwhile (n--)\r\n{\r\n*d++ = *s++;\r\n}\r\n}\r\ncard->th_buffer.ptr = card->th_buffer.buf + remaining;\r\n*processed = 1;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult process_clear_slot_command(card_t *card, const u8 *cmdptr)\r\n{\r\nu16 data_slot;\r\ns16 slot;\r\ndata_slot = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cmdptr + SIZEOF_UINT16);\r\nunifi_trace(card->ospriv, UDBG4, "Processing clear slot cmd, slot=0x%X\n",\r\ndata_slot);\r\nslot = data_slot & 0x7FFF;\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "CMD clear data slot 0x%04x\n", data_slot);\r\n#endif\r\nif (data_slot & SLOT_DIR_TO_HOST)\r\n{\r\nif (slot >= card->config_data.num_tohost_data_slots)\r\n{\r\nunifi_error(card->ospriv,\r\n"Invalid to-host data slot in SDIO_CMD_CLEAR_SLOT: %d\n",\r\nslot);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nunifi_warning(card->ospriv, "Unexpected clear to-host data slot cmd: 0x%04x\n",\r\ndata_slot);\r\n}\r\nelse\r\n{\r\nif (slot >= card->config_data.num_fromhost_data_slots)\r\n{\r\nunifi_error(card->ospriv,\r\n"Invalid from-host data slot in SDIO_CMD_CLEAR_SLOT: %d\n",\r\nslot);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult process_bulk_data_command(card_t *card, const u8 *cmdptr,\r\ns16 cmd, u16 len)\r\n{\r\nbulk_data_desc_t *bdslot;\r\n#ifdef CSR_WIFI_ALIGNMENT_WORKAROUND\r\nu8 *host_bulk_data_slot;\r\n#endif\r\nbulk_data_cmd_t bdcmd;\r\ns16 offset;\r\ns16 slot;\r\ns16 dir;\r\nCsrResult r;\r\nread_unpack_cmd(cmdptr, &bdcmd);\r\nunifi_trace(card->ospriv, UDBG4, "Processing bulk data cmd %d %s, len=%d, slot=0x%X\n",\r\ncmd, lookup_bulkcmd_name(cmd), len, bdcmd.data_slot);\r\nif (card->sdio_io_block_pad)\r\n{\r\nlen = (len + card->sdio_io_block_size - 1) & ~(card->sdio_io_block_size - 1);\r\nunifi_trace(card->ospriv, UDBG4, "Rounded bulk data length up to %d\n", len);\r\n}\r\nslot = bdcmd.data_slot & 0x7FFF;\r\nif (cmd == SDIO_CMD_OVERLAY_TRANSFER)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nelse\r\n{\r\nif (bdcmd.data_slot & SLOT_DIR_TO_HOST)\r\n{\r\nif (slot >= card->config_data.num_tohost_data_slots)\r\n{\r\nunifi_error(card->ospriv,\r\n"Invalid to-host data slot in SDIO bulk xfr req: %d\n",\r\nslot);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n#ifdef CSR_PRE_ALLOC_NET_DATA\r\nr = prealloc_netdata_get(card, &card->to_host_data[slot], len);\r\n#else\r\nr = unifi_net_data_malloc(card->ospriv, &card->to_host_data[slot], len);\r\n#endif\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate t-h bulk data\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nbdslot = &card->to_host_data[slot];\r\nr = unifi_net_dma_align(card->ospriv, bdslot);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to align t-h bulk data buffer for DMA\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n}\r\nelse\r\n{\r\nif (slot >= card->config_data.num_fromhost_data_slots)\r\n{\r\nunifi_error(card->ospriv,\r\n"Invalid from-host data slot in SDIO bulk xfr req: %d\n",\r\nslot);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nbdslot = &card->from_host_data[slot].bd;\r\n}\r\noffset = bdcmd.offset;\r\n}\r\ndir = (cmd == SDIO_CMD_TO_HOST_TRANSFER)?\r\nUNIFI_SDIO_READ : UNIFI_SDIO_WRITE;\r\nunifi_trace(card->ospriv, UDBG4,\r\n"Bulk %c %s len=%d, handle %d - slot=%d %p+(%d)\n",\r\n(dir == UNIFI_SDIO_READ)?'R' : 'W',\r\nlookup_bulkcmd_name(cmd),\r\nlen,\r\nbdcmd.buffer_handle,\r\nslot, bdslot->os_data_ptr, offset);\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "Bulk %s len=%d, handle %d - slot=%d %p+(%d)\n",\r\nlookup_bulkcmd_name(cmd),\r\nlen,\r\nbdcmd.buffer_handle,\r\nslot, bdslot->os_data_ptr, offset);\r\n#endif\r\nif (bdslot->os_data_ptr == NULL)\r\n{\r\nunifi_error(card->ospriv, "Null os_data_ptr - Bulk %s handle %d - slot=%d o=(%d)\n",\r\nlookup_bulkcmd_name(cmd),\r\nbdcmd.buffer_handle,\r\nslot,\r\noffset);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\n#ifdef CSR_WIFI_ALIGNMENT_WORKAROUND\r\nif (len != 0 && (dir == UNIFI_SDIO_WRITE) && (((ptrdiff_t)bdslot->os_data_ptr + offset) & 3))\r\n{\r\nhost_bulk_data_slot = kmalloc(len, GFP_KERNEL);\r\nif (!host_bulk_data_slot)\r\n{\r\nunifi_error(card->ospriv, " failed to allocate request_data before unifi_bulk_rw\n");\r\nreturn -1;\r\n}\r\nmemcpy((void *)host_bulk_data_slot,\r\n(void *)(bdslot->os_data_ptr + offset), len);\r\nr = unifi_bulk_rw(card,\r\nbdcmd.buffer_handle,\r\n(void *)host_bulk_data_slot,\r\nlen,\r\ndir);\r\n}\r\nelse\r\n#endif\r\n{\r\nr = unifi_bulk_rw(card,\r\nbdcmd.buffer_handle,\r\n(void *)(bdslot->os_data_ptr + offset),\r\nlen,\r\ndir);\r\n}\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv,\r\n"Failed: %s hlen=%d, slen=%d, handle %d - slot=%d %p+0x%X\n",\r\nlookup_bulkcmd_name(cmd),\r\nlen,\r\nbdslot->data_length,\r\nbdcmd.buffer_handle,\r\nslot, bdslot->os_data_ptr, offset);\r\nreturn r;\r\n}\r\nbdslot->data_length = len;\r\nif (cmd == SDIO_CMD_FROM_HOST_AND_CLEAR)\r\n{\r\nif (slot >= card->config_data.num_fromhost_data_slots)\r\n{\r\nunifi_error(card->ospriv,\r\n"Invalid from-host data slot in SDIO_CMD_FROM_HOST_AND_CLEAR: %d\n",\r\nslot);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n#ifdef CSR_WIFI_ALIGNMENT_WORKAROUND\r\nif ((len != 0) && (dir == UNIFI_SDIO_WRITE) && (((ptrdiff_t)bdslot->os_data_ptr + offset) & 3))\r\n{\r\nkfree(host_bulk_data_slot);\r\n}\r\n#endif\r\nif (card->fh_slot_host_tag_record)\r\n{\r\nunifi_trace(card->ospriv, UDBG5, "CopyFromHostAndClearSlot Reset entry for slot=%d\n", slot);\r\ncard->fh_slot_host_tag_record[slot] = CSR_WIFI_HIP_RESERVED_HOST_TAG;\r\n}\r\nCardClearFromHostDataSlot(card, slot);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult check_fh_sig_slots(card_t *card, u16 needed, s32 *space_fh)\r\n{\r\nu32 count_fhw;\r\nu32 occupied_fh, slots_fh;\r\ns32 count_fhr;\r\ncount_fhw = card->from_host_signals_w;\r\ncount_fhr = card->from_host_signals_r;\r\nslots_fh = card->config_data.num_fromhost_sig_frags;\r\noccupied_fh = (count_fhw - count_fhr) % 128;\r\nif (slots_fh < occupied_fh)\r\n{\r\n*space_fh = 0;\r\n}\r\nelse\r\n{\r\n*space_fh = slots_fh - occupied_fh;\r\n}\r\nif ((occupied_fh != 0) && (*space_fh < needed))\r\n{\r\ncount_fhr = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);\r\nif (count_fhr < 0)\r\n{\r\nunifi_error(card->ospriv, "Failed to read from-host sig read count\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\ncard->from_host_signals_r = count_fhr;\r\noccupied_fh = (count_fhw - count_fhr) % 128;\r\n*space_fh = slots_fh - occupied_fh;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult process_fh_cmd_queue(card_t *card, s32 *processed)\r\n{\r\nq_t *sigq = &card->fh_command_queue;\r\nCsrResult r;\r\nu16 pending_sigs;\r\nu16 pending_chunks;\r\nu16 needed_chunks;\r\ns32 space_chunks;\r\nu16 q_index;\r\n*processed = 0;\r\npending_sigs = CSR_WIFI_HIP_Q_SLOTS_USED(sigq);\r\nunifi_trace(card->ospriv, UDBG5, "proc_fh: %d pending\n", pending_sigs);\r\nif (pending_sigs == 0)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nfor (pending_chunks = 0, q_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(sigq);\r\nq_index != CSR_WIFI_HIP_Q_NEXT_W_SLOT(sigq);\r\nq_index = CSR_WIFI_HIP_Q_WRAP(sigq, q_index + 1))\r\n{\r\ncard_signal_t *csptr = CSR_WIFI_HIP_Q_SLOT_DATA(sigq, q_index);\r\npending_chunks += GET_CHUNKS_FOR(card->config_data.sig_frag_size, (u16)(csptr->signal_length + 2));\r\n}\r\nneeded_chunks = pending_chunks + card->fh_buffer.count;\r\nROUND_UP_NEEDED_CHUNKS(card, needed_chunks);\r\nr = check_fh_sig_slots(card, needed_chunks, &space_chunks);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read fh sig count\n");\r\nreturn r;\r\n}\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "proc_fh: %d chunks free, need %d\n",\r\nspace_chunks, needed_chunks);\r\n#endif\r\nif (needed_chunks > (u16)space_chunks)\r\n{\r\nROUND_UP_SPACE_CHUNKS(card, space_chunks);\r\nif ((u16)space_chunks <= card->fh_buffer.count)\r\n{\r\nunifi_error(card->ospriv, "not enough room to send signals, need %d chunks, %d free\n",\r\ncard->fh_buffer.count, space_chunks);\r\ncard->generate_interrupt = 1;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\npending_chunks = (u16)(space_chunks - card->fh_buffer.count);\r\n}\r\nwhile (pending_sigs-- && pending_chunks > 0)\r\n{\r\ncard_signal_t *csptr;\r\ns16 i;\r\nu16 sig_chunks, total_length, free_chunks_in_fh_buffer;\r\nbulk_data_param_t bulkdata;\r\nu8 *packed_sigptr;\r\nu16 signal_length = 0;\r\nq_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(sigq);\r\ncsptr = CSR_WIFI_HIP_Q_SLOT_DATA(sigq, q_index);\r\nsignal_length = csptr->signal_length;\r\nif ((signal_length & 1) || (signal_length > UNIFI_PACKED_SIGBUF_SIZE))\r\n{\r\nunifi_error(card->ospriv, "process_fh_queue: Bad len: %d\n", signal_length);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nsig_chunks = GET_CHUNKS_FOR(card->config_data.sig_frag_size, (u16)(signal_length + 2));\r\nfree_chunks_in_fh_buffer = GET_CHUNKS_FOR(card->config_data.sig_frag_size,\r\n(u16)((card->fh_buffer.buf + UNIFI_FH_BUF_SIZE) - card->fh_buffer.ptr));\r\nif (free_chunks_in_fh_buffer < sig_chunks)\r\n{\r\nunifi_notice(card->ospriv, "proc_fh_cmd_q: no room in fh buffer for 0x%.4X, deferring\n",\r\n(u16)(GET_SIGNAL_ID(csptr->sigbuf)));\r\nbreak;\r\n}\r\npacked_sigptr = csptr->sigbuf;\r\nif (CSR_RESULT_FAILURE == CardWriteBulkData(card, csptr, UNIFI_TRAFFIC_Q_MLME))\r\n{\r\nunifi_notice(card->ospriv, "proc_fh_cmd_q: no fh data slots for 0x%.4X, deferring\n",\r\n(u16)(GET_SIGNAL_ID(csptr->sigbuf)));\r\nbreak;\r\n}\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)\r\n{\r\nif (csptr->bulkdata[i].data_length == 0)\r\n{\r\nUNIFI_INIT_BULK_DATA(&bulkdata.d[i]);\r\n}\r\nelse\r\n{\r\nbulkdata.d[i].os_data_ptr = csptr->bulkdata[i].os_data_ptr;\r\nbulkdata.d[i].data_length = csptr->bulkdata[i].data_length;\r\n}\r\nUNIFI_INIT_BULK_DATA(&csptr->bulkdata[i]);\r\n}\r\nunifi_trace(card->ospriv, UDBG2, "Sending signal 0x%.4X\n",\r\nGET_SIGNAL_ID(packed_sigptr));\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "Sending signal 0x%.4X\n",\r\nGET_SIGNAL_ID(packed_sigptr));\r\n#endif\r\ntotal_length = sig_chunks * card->config_data.sig_frag_size;\r\ncard->fh_buffer.ptr[0] = (u8)(signal_length & 0xff);\r\ncard->fh_buffer.ptr[1] =\r\n(u8)(((signal_length >> 8) & 0xf) | (SDIO_CMD_SIGNAL << 4));\r\nmemcpy(card->fh_buffer.ptr + 2, packed_sigptr, signal_length);\r\nmemset(card->fh_buffer.ptr + 2 + signal_length, 0,\r\ntotal_length - (2 + signal_length));\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "proc_fh: fh_buffer %d bytes \n",\r\nsignal_length + 2);\r\ndump(card->fh_buffer.ptr, signal_length + 2);\r\nunifi_trace(card->ospriv, UDBG1, " \n");\r\n#endif\r\ncard->fh_buffer.ptr += total_length;\r\ncard->fh_buffer.count += sig_chunks;\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "Added %d to fh buf, len now %d, count %d\n",\r\nsignal_length,\r\ncard->fh_buffer.ptr - card->fh_buffer.buf,\r\ncard->fh_buffer.count);\r\n#endif\r\n(*processed)++;\r\npending_chunks -= sig_chunks;\r\nif (card->udi_hook)\r\n{\r\n(*card->udi_hook)(card->ospriv, packed_sigptr, signal_length,\r\n&bulkdata, UDI_LOG_FROM_HOST);\r\n}\r\ncsptr->signal_length = 0;\r\nCSR_WIFI_HIP_Q_INC_R(sigq);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult process_fh_traffic_queue(card_t *card, s32 *processed)\r\n{\r\nq_t *sigq = card->fh_traffic_queue;\r\nCsrResult r;\r\ns16 n = 0;\r\ns32 q_no;\r\nu16 pending_sigs = 0;\r\nu16 pending_chunks = 0;\r\nu16 needed_chunks;\r\ns32 space_chunks;\r\nu16 q_index;\r\nu32 host_tag = 0;\r\nu16 slot_num = 0;\r\n*processed = 0;\r\nfor (n = UNIFI_NO_OF_TX_QS - 1; n >= 0; n--)\r\n{\r\npending_sigs += CSR_WIFI_HIP_Q_SLOTS_USED(&sigq[n]);\r\nunifi_trace(card->ospriv, UDBG5, "proc_fh%d: %d pending\n", n, pending_sigs);\r\nfor (q_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(&sigq[n]);\r\nq_index != CSR_WIFI_HIP_Q_NEXT_W_SLOT(&sigq[n]);\r\nq_index = CSR_WIFI_HIP_Q_WRAP(&sigq[n], q_index + 1))\r\n{\r\ncard_signal_t *csptr = CSR_WIFI_HIP_Q_SLOT_DATA(&sigq[n], q_index);\r\npending_chunks += GET_CHUNKS_FOR(card->config_data.sig_frag_size, (u16)(csptr->signal_length + 2));\r\n}\r\n}\r\nif (pending_sigs == 0)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nneeded_chunks = pending_chunks + card->fh_buffer.count;\r\nROUND_UP_NEEDED_CHUNKS(card, needed_chunks);\r\nr = check_fh_sig_slots(card, needed_chunks, &space_chunks);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read fh sig count\n");\r\nreturn r;\r\n}\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv,\r\n"process_fh_traffic_queue: %d chunks free, need %d\n",\r\nspace_chunks, needed_chunks);\r\nread_fhsr(card);\r\n#endif\r\nif (needed_chunks > (u16)space_chunks)\r\n{\r\nROUND_UP_SPACE_CHUNKS(card, space_chunks);\r\nif ((u16)space_chunks <= card->fh_buffer.count)\r\n{\r\nunifi_error(card->ospriv, "not enough room to send signals, need %d chunks, %d free\n",\r\ncard->fh_buffer.count, space_chunks);\r\ncard->generate_interrupt = 1;\r\nreturn 0;\r\n}\r\npending_chunks = (u16)space_chunks - card->fh_buffer.count;\r\n}\r\nq_no = UNIFI_NO_OF_TX_QS - 1;\r\ndo\r\n{\r\ncard_signal_t *csptr;\r\nu16 sig_chunks, total_length, free_chunks_in_fh_buffer;\r\nbulk_data_param_t bulkdata;\r\nu8 *packed_sigptr;\r\nu16 signal_length = 0;\r\nif (CSR_WIFI_HIP_Q_SLOTS_USED(&sigq[q_no]) == 0)\r\n{\r\nq_no--;\r\ncontinue;\r\n}\r\nq_index = CSR_WIFI_HIP_Q_NEXT_R_SLOT(&sigq[q_no]);\r\ncsptr = CSR_WIFI_HIP_Q_SLOT_DATA(&sigq[q_no], q_index);\r\nsignal_length = csptr->signal_length;\r\nif ((signal_length & 1) || (signal_length > UNIFI_PACKED_SIGBUF_SIZE))\r\n{\r\nunifi_error(card->ospriv, "process_fh_traffic_queue: Bad len: %d\n", signal_length);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nsig_chunks = GET_CHUNKS_FOR(card->config_data.sig_frag_size, (u16)(signal_length + 2));\r\nfree_chunks_in_fh_buffer = GET_CHUNKS_FOR(card->config_data.sig_frag_size,\r\n(u16)((card->fh_buffer.buf + UNIFI_FH_BUF_SIZE) - card->fh_buffer.ptr));\r\nif (free_chunks_in_fh_buffer < sig_chunks)\r\n{\r\nunifi_notice(card->ospriv, "process_fh_traffic_queue: no more chunks.\n");\r\nbreak;\r\n}\r\npacked_sigptr = csptr->sigbuf;\r\nif (CSR_RESULT_FAILURE == CardWriteBulkData(card, csptr, (unifi_TrafficQueue)q_no))\r\n{\r\nq_no--;\r\ncontinue;\r\n}\r\nif ((csptr->bulkdata[0].data_length == 0) || (csptr->bulkdata[0].os_data_ptr == NULL))\r\n{\r\nunifi_error(card->ospriv, "MA-PACKET.req with empty bulk data (%d bytes in %p)\n",\r\ncsptr->bulkdata[0].data_length, csptr->bulkdata[0].os_data_ptr);\r\ndump(packed_sigptr, signal_length);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nbulkdata.d[0].os_data_ptr = csptr->bulkdata[0].os_data_ptr;\r\nbulkdata.d[0].data_length = csptr->bulkdata[0].data_length;\r\nbulkdata.d[0].os_net_buf_ptr = csptr->bulkdata[0].os_net_buf_ptr;\r\nbulkdata.d[0].net_buf_length = csptr->bulkdata[0].net_buf_length;\r\nif (card->fh_slot_host_tag_record)\r\n{\r\nhost_tag = GET_PACKED_MA_PACKET_REQUEST_HOST_TAG(packed_sigptr);\r\nslot_num = GET_PACKED_DATAREF_SLOT(packed_sigptr, 0) & 0x00FF;\r\nunifi_trace(card->ospriv, UDBG5,\r\n"process_fh_traffic_queue signal ID =%x fh slot=%x Host tag =%x\n",\r\nGET_SIGNAL_ID(packed_sigptr), slot_num, host_tag);\r\ncard->fh_slot_host_tag_record[slot_num] = host_tag;\r\n}\r\nUNIFI_INIT_BULK_DATA(&bulkdata.d[1]);\r\nUNIFI_INIT_BULK_DATA(&csptr->bulkdata[0]);\r\nUNIFI_INIT_BULK_DATA(&csptr->bulkdata[1]);\r\n#ifdef CSR_WIFI_HIP_DATA_PLANE_PROFILE\r\nif (bulkdata.d[0].os_data_ptr)\r\n{\r\nif ((*bulkdata.d[0].os_data_ptr) & 0x08)\r\n{\r\ncard->cmd_prof.tx_count++;\r\n}\r\n}\r\n#endif\r\nunifi_trace(card->ospriv, UDBG3, "Sending signal 0x%.4X\n",\r\nGET_SIGNAL_ID(packed_sigptr));\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "Sending signal 0x%.4X\n",\r\nGET_SIGNAL_ID(packed_sigptr));\r\n#endif\r\ntotal_length = sig_chunks * card->config_data.sig_frag_size;\r\ncard->fh_buffer.ptr[0] = (u8)(signal_length & 0xff);\r\ncard->fh_buffer.ptr[1] =\r\n(u8)(((signal_length >> 8) & 0xf) | (SDIO_CMD_SIGNAL << 4));\r\nmemcpy(card->fh_buffer.ptr + 2, packed_sigptr, signal_length);\r\nmemset(card->fh_buffer.ptr + 2 + signal_length, 0,\r\ntotal_length - (2 + signal_length));\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "proc_fh: fh_buffer %d bytes \n",\r\nsignal_length + 2);\r\ndump(card->fh_buffer.ptr, signal_length + 2);\r\nunifi_trace(card->ospriv, UDBG1, " \n");\r\n#endif\r\ncard->fh_buffer.ptr += total_length;\r\ncard->fh_buffer.count += sig_chunks;\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "Added %d to fh buf, len now %d, count %d\n",\r\nsignal_length,\r\ncard->fh_buffer.ptr - card->fh_buffer.buf,\r\ncard->fh_buffer.count);\r\n#endif\r\n(*processed)++;\r\npending_sigs--;\r\npending_chunks -= sig_chunks;\r\nif (card->udi_hook)\r\n{\r\n(*card->udi_hook)(card->ospriv, packed_sigptr, signal_length,\r\n&bulkdata, UDI_LOG_FROM_HOST);\r\n}\r\ncsptr->signal_length = 0;\r\ncsptr->bulkdata[0].data_length = 0;\r\nCSR_WIFI_HIP_Q_INC_R(&sigq[q_no]);\r\n} while ((pending_sigs > 0) && (pending_chunks > 0) && (q_no >= 0));\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult flush_fh_buffer(card_t *card)\r\n{\r\nCsrResult r;\r\nu16 len;\r\nu16 sig_units;\r\nu16 data_round;\r\nu16 chunks_in_last_block;\r\nu16 padding_chunks;\r\nu16 i;\r\nlen = card->fh_buffer.ptr - card->fh_buffer.buf;\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "fh_buffer is at %p, ptr= %p\n",\r\ncard->fh_buffer.buf, card->fh_buffer.ptr);\r\n#endif\r\nif (len == 0)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nif (dump_fh_buf)\r\n{\r\ndump(card->fh_buffer.buf, len);\r\ndump_fh_buf = 0;\r\n}\r\n#endif\r\nif (card->sdio_io_block_pad)\r\n{\r\nsig_units = card->config_data.sig_frag_size;\r\ndata_round = card->sdio_io_block_size;\r\nif (data_round > sig_units)\r\n{\r\nchunks_in_last_block = (len % data_round) / sig_units;\r\nif (chunks_in_last_block != 0)\r\n{\r\npadding_chunks = (data_round / sig_units) - chunks_in_last_block;\r\nmemset(card->fh_buffer.ptr, 0, padding_chunks * sig_units);\r\nfor (i = 0; i < padding_chunks; i++)\r\n{\r\ncard->fh_buffer.ptr[1] = SDIO_CMD_PADDING << 4;\r\ncard->fh_buffer.ptr += sig_units;\r\n}\r\ncard->fh_buffer.count += padding_chunks;\r\nlen += padding_chunks * sig_units;\r\n}\r\n}\r\n}\r\nr = unifi_bulk_rw(card,\r\ncard->config_data.fromhost_sigbuf_handle,\r\ncard->fh_buffer.buf,\r\nlen, UNIFI_SDIO_WRITE);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write fh signals: %u bytes, error %d\n", len, r);\r\nreturn r;\r\n}\r\ncard->from_host_signals_w =\r\n(card->from_host_signals_w + card->fh_buffer.count) % 128u;\r\nr = unifi_write_8_or_16(card, card->sdio_ctrl_addr + 0,\r\n(u8)card->from_host_signals_w);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write fh signal count %u with error %d\n",\r\ncard->from_host_signals_w, r);\r\nreturn r;\r\n}\r\ncard->generate_interrupt = 1;\r\ncard->fh_buffer.ptr = card->fh_buffer.buf;\r\ncard->fh_buffer.count = 0;\r\n#ifdef CSR_WIFI_HIP_NOISY\r\nunifi_error(card->ospriv, "END flush: fh len %d, count %d\n",\r\ncard->fh_buffer.ptr - card->fh_buffer.buf,\r\ncard->fh_buffer.count);\r\n#endif\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic void restart_packet_flow(card_t *card)\r\n{\r\nu8 q;\r\nfor (q = 0; q <= UNIFI_TRAFFIC_Q_VO; q++)\r\n{\r\nif (card_is_tx_q_paused(card, q) &&\r\nCSR_WIFI_HIP_Q_SLOTS_FREE(&card->fh_traffic_queue[q]) >= RESUME_XMIT_THRESHOLD)\r\n{\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_DATA_PLANE_PROFILE)\r\nunifi_debug_log_to_buf("U");\r\n#endif\r\ncard_tx_q_unpause(card, q);\r\nunifi_restart_xmit(card->ospriv, (unifi_TrafficQueue)q);\r\n}\r\n}\r\n}
