unsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\r\n{\r\nunsigned int la_mb;\r\nunsigned int gd_mb;\r\nunsigned int la_max_mb;\r\nunsigned int megs_per_slot;\r\nstruct super_block *sb = osb->sb;\r\ngd_mb = ocfs2_clusters_to_megabytes(osb->sb,\r\n8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\r\nif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\r\n|| (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\r\nreturn OCFS2_LA_OLD_DEFAULT;\r\ngd_mb -= 16;\r\ngd_mb &= 0xFFFFFFFB;\r\nla_mb = gd_mb;\r\nif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\r\nif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\r\nla_mb = 256;\r\nelse {\r\nunsigned int gd_mult = gd_mb;\r\nwhile (gd_mult > 256)\r\ngd_mult = gd_mult >> 1;\r\nla_mb = gd_mult;\r\n}\r\n}\r\nmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\r\nmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\r\nif (megs_per_slot < la_mb)\r\nla_mb = megs_per_slot;\r\nla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\r\nocfs2_local_alloc_size(sb) * 8);\r\nif (la_mb > la_max_mb)\r\nla_mb = la_max_mb;\r\nreturn la_mb;\r\n}\r\nvoid ocfs2_la_set_sizes(struct ocfs2_super *osb, int requested_mb)\r\n{\r\nstruct super_block *sb = osb->sb;\r\nunsigned int la_default_mb = ocfs2_la_default_mb(osb);\r\nunsigned int la_max_mb;\r\nla_max_mb = ocfs2_clusters_to_megabytes(sb,\r\nocfs2_local_alloc_size(sb) * 8);\r\ntrace_ocfs2_la_set_sizes(requested_mb, la_max_mb, la_default_mb);\r\nif (requested_mb == -1) {\r\nosb->local_alloc_default_bits =\r\nocfs2_megabytes_to_clusters(sb, la_default_mb);\r\n} else if (requested_mb > la_max_mb) {\r\nosb->local_alloc_default_bits =\r\nocfs2_megabytes_to_clusters(sb, la_max_mb);\r\n} else {\r\nosb->local_alloc_default_bits =\r\nocfs2_megabytes_to_clusters(sb, requested_mb);\r\n}\r\nosb->local_alloc_bits = osb->local_alloc_default_bits;\r\n}\r\nstatic inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\r\n{\r\nreturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\r\nosb->local_alloc_state == OCFS2_LA_ENABLED);\r\n}\r\nvoid ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\r\nunsigned int num_clusters)\r\n{\r\nspin_lock(&osb->osb_lock);\r\nif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\r\nosb->local_alloc_state == OCFS2_LA_THROTTLED)\r\nif (num_clusters >= osb->local_alloc_default_bits) {\r\ncancel_delayed_work(&osb->la_enable_wq);\r\nosb->local_alloc_state = OCFS2_LA_ENABLED;\r\n}\r\nspin_unlock(&osb->osb_lock);\r\n}\r\nvoid ocfs2_la_enable_worker(struct work_struct *work)\r\n{\r\nstruct ocfs2_super *osb =\r\ncontainer_of(work, struct ocfs2_super,\r\nla_enable_wq.work);\r\nspin_lock(&osb->osb_lock);\r\nosb->local_alloc_state = OCFS2_LA_ENABLED;\r\nspin_unlock(&osb->osb_lock);\r\n}\r\nint ocfs2_alloc_should_use_local(struct ocfs2_super *osb, u64 bits)\r\n{\r\nint ret = 0;\r\nint la_bits;\r\nspin_lock(&osb->osb_lock);\r\nla_bits = osb->local_alloc_bits;\r\nif (!ocfs2_la_state_enabled(osb))\r\ngoto bail;\r\nif (bits > (la_bits / 2))\r\ngoto bail;\r\nret = 1;\r\nbail:\r\ntrace_ocfs2_alloc_should_use_local(\r\n(unsigned long long)bits, osb->local_alloc_state, la_bits, ret);\r\nspin_unlock(&osb->osb_lock);\r\nreturn ret;\r\n}\r\nint ocfs2_load_local_alloc(struct ocfs2_super *osb)\r\n{\r\nint status = 0;\r\nstruct ocfs2_dinode *alloc = NULL;\r\nstruct buffer_head *alloc_bh = NULL;\r\nu32 num_used;\r\nstruct inode *inode = NULL;\r\nstruct ocfs2_local_alloc *la;\r\nif (osb->local_alloc_bits == 0)\r\ngoto bail;\r\nif (osb->local_alloc_bits >= osb->bitmap_cpg) {\r\nmlog(ML_NOTICE, "Requested local alloc window %d is larger "\r\n"than max possible %u. Using defaults.\n",\r\nosb->local_alloc_bits, (osb->bitmap_cpg - 1));\r\nosb->local_alloc_bits =\r\nocfs2_megabytes_to_clusters(osb->sb,\r\nocfs2_la_default_mb(osb));\r\n}\r\ninode = ocfs2_get_system_file_inode(osb, LOCAL_ALLOC_SYSTEM_INODE,\r\nosb->slot_num);\r\nif (!inode) {\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\r\nOCFS2_BH_IGNORE_CACHE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nalloc = (struct ocfs2_dinode *) alloc_bh->b_data;\r\nla = OCFS2_LOCAL_ALLOC(alloc);\r\nif (!(le32_to_cpu(alloc->i_flags) &\r\n(OCFS2_LOCAL_ALLOC_FL|OCFS2_BITMAP_FL))) {\r\nmlog(ML_ERROR, "Invalid local alloc inode, %llu\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\nstatus = -EINVAL;\r\ngoto bail;\r\n}\r\nif ((la->la_size == 0) ||\r\n(le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {\r\nmlog(ML_ERROR, "Local alloc size is invalid (la_size = %u)\n",\r\nle16_to_cpu(la->la_size));\r\nstatus = -EINVAL;\r\ngoto bail;\r\n}\r\nnum_used = ocfs2_local_alloc_count_bits(alloc);\r\nif (num_used\r\n|| alloc->id1.bitmap1.i_used\r\n|| alloc->id1.bitmap1.i_total\r\n|| la->la_bm_off)\r\nmlog(ML_ERROR, "Local alloc hasn't been recovered!\n"\r\n"found = %u, set = %u, taken = %u, off = %u\n",\r\nnum_used, le32_to_cpu(alloc->id1.bitmap1.i_used),\r\nle32_to_cpu(alloc->id1.bitmap1.i_total),\r\nOCFS2_LOCAL_ALLOC(alloc)->la_bm_off);\r\nosb->local_alloc_bh = alloc_bh;\r\nosb->local_alloc_state = OCFS2_LA_ENABLED;\r\nbail:\r\nif (status < 0)\r\nbrelse(alloc_bh);\r\nif (inode)\r\niput(inode);\r\ntrace_ocfs2_load_local_alloc(osb->local_alloc_bits);\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nvoid ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)\r\n{\r\nint status;\r\nhandle_t *handle;\r\nstruct inode *local_alloc_inode = NULL;\r\nstruct buffer_head *bh = NULL;\r\nstruct buffer_head *main_bm_bh = NULL;\r\nstruct inode *main_bm_inode = NULL;\r\nstruct ocfs2_dinode *alloc_copy = NULL;\r\nstruct ocfs2_dinode *alloc = NULL;\r\ncancel_delayed_work(&osb->la_enable_wq);\r\nflush_workqueue(ocfs2_wq);\r\nif (osb->local_alloc_state == OCFS2_LA_UNUSED)\r\ngoto out;\r\nlocal_alloc_inode =\r\nocfs2_get_system_file_inode(osb,\r\nLOCAL_ALLOC_SYSTEM_INODE,\r\nosb->slot_num);\r\nif (!local_alloc_inode) {\r\nstatus = -ENOENT;\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nosb->local_alloc_state = OCFS2_LA_DISABLED;\r\nocfs2_resmap_uninit(&osb->osb_la_resmap);\r\nmain_bm_inode = ocfs2_get_system_file_inode(osb,\r\nGLOBAL_BITMAP_SYSTEM_INODE,\r\nOCFS2_INVALID_SLOT);\r\nif (!main_bm_inode) {\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nmutex_lock(&main_bm_inode->i_mutex);\r\nstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_mutex;\r\n}\r\nhandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nmlog_errno(PTR_ERR(handle));\r\nhandle = NULL;\r\ngoto out_unlock;\r\n}\r\nbh = osb->local_alloc_bh;\r\nalloc = (struct ocfs2_dinode *) bh->b_data;\r\nalloc_copy = kmalloc(bh->b_size, GFP_NOFS);\r\nif (!alloc_copy) {\r\nstatus = -ENOMEM;\r\ngoto out_commit;\r\n}\r\nmemcpy(alloc_copy, alloc, bh->b_size);\r\nstatus = ocfs2_journal_access_di(handle, INODE_CACHE(local_alloc_inode),\r\nbh, OCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_commit;\r\n}\r\nocfs2_clear_local_alloc(alloc);\r\nocfs2_journal_dirty(handle, bh);\r\nbrelse(bh);\r\nosb->local_alloc_bh = NULL;\r\nosb->local_alloc_state = OCFS2_LA_UNUSED;\r\nstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\r\nmain_bm_inode, main_bm_bh);\r\nif (status < 0)\r\nmlog_errno(status);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout_unlock:\r\nbrelse(main_bm_bh);\r\nocfs2_inode_unlock(main_bm_inode, 1);\r\nout_mutex:\r\nmutex_unlock(&main_bm_inode->i_mutex);\r\niput(main_bm_inode);\r\nout:\r\nif (local_alloc_inode)\r\niput(local_alloc_inode);\r\nif (alloc_copy)\r\nkfree(alloc_copy);\r\n}\r\nint ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\r\nint slot_num,\r\nstruct ocfs2_dinode **alloc_copy)\r\n{\r\nint status = 0;\r\nstruct buffer_head *alloc_bh = NULL;\r\nstruct inode *inode = NULL;\r\nstruct ocfs2_dinode *alloc;\r\ntrace_ocfs2_begin_local_alloc_recovery(slot_num);\r\n*alloc_copy = NULL;\r\ninode = ocfs2_get_system_file_inode(osb,\r\nLOCAL_ALLOC_SYSTEM_INODE,\r\nslot_num);\r\nif (!inode) {\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nmutex_lock(&inode->i_mutex);\r\nstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\r\nOCFS2_BH_IGNORE_CACHE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\r\nif (!(*alloc_copy)) {\r\nstatus = -ENOMEM;\r\ngoto bail;\r\n}\r\nmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\r\nalloc = (struct ocfs2_dinode *) alloc_bh->b_data;\r\nocfs2_clear_local_alloc(alloc);\r\nocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\r\nstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\r\nif (status < 0)\r\nmlog_errno(status);\r\nbail:\r\nif ((status < 0) && (*alloc_copy)) {\r\nkfree(*alloc_copy);\r\n*alloc_copy = NULL;\r\n}\r\nbrelse(alloc_bh);\r\nif (inode) {\r\nmutex_unlock(&inode->i_mutex);\r\niput(inode);\r\n}\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nint ocfs2_complete_local_alloc_recovery(struct ocfs2_super *osb,\r\nstruct ocfs2_dinode *alloc)\r\n{\r\nint status;\r\nhandle_t *handle;\r\nstruct buffer_head *main_bm_bh = NULL;\r\nstruct inode *main_bm_inode;\r\nmain_bm_inode = ocfs2_get_system_file_inode(osb,\r\nGLOBAL_BITMAP_SYSTEM_INODE,\r\nOCFS2_INVALID_SLOT);\r\nif (!main_bm_inode) {\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nmutex_lock(&main_bm_inode->i_mutex);\r\nstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_mutex;\r\n}\r\nhandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nhandle = NULL;\r\nmlog_errno(status);\r\ngoto out_unlock;\r\n}\r\nhandle->h_sync = 1;\r\nstatus = ocfs2_sync_local_to_main(osb, handle, alloc,\r\nmain_bm_inode, main_bm_bh);\r\nif (status < 0)\r\nmlog_errno(status);\r\nocfs2_commit_trans(osb, handle);\r\nout_unlock:\r\nocfs2_inode_unlock(main_bm_inode, 1);\r\nout_mutex:\r\nmutex_unlock(&main_bm_inode->i_mutex);\r\nbrelse(main_bm_bh);\r\niput(main_bm_inode);\r\nout:\r\nif (!status)\r\nocfs2_init_steal_slots(osb);\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nint ocfs2_reserve_local_alloc_bits(struct ocfs2_super *osb,\r\nu32 bits_wanted,\r\nstruct ocfs2_alloc_context *ac)\r\n{\r\nint status;\r\nstruct ocfs2_dinode *alloc;\r\nstruct inode *local_alloc_inode;\r\nunsigned int free_bits;\r\nBUG_ON(!ac);\r\nlocal_alloc_inode =\r\nocfs2_get_system_file_inode(osb,\r\nLOCAL_ALLOC_SYSTEM_INODE,\r\nosb->slot_num);\r\nif (!local_alloc_inode) {\r\nstatus = -ENOENT;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nmutex_lock(&local_alloc_inode->i_mutex);\r\nspin_lock(&osb->osb_lock);\r\nif (!ocfs2_la_state_enabled(osb) ||\r\n(bits_wanted > osb->local_alloc_bits)) {\r\nspin_unlock(&osb->osb_lock);\r\nstatus = -ENOSPC;\r\ngoto bail;\r\n}\r\nspin_unlock(&osb->osb_lock);\r\nalloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\r\n#ifdef CONFIG_OCFS2_DEBUG_FS\r\nif (le32_to_cpu(alloc->id1.bitmap1.i_used) !=\r\nocfs2_local_alloc_count_bits(alloc)) {\r\nocfs2_error(osb->sb, "local alloc inode %llu says it has "\r\n"%u free bits, but a count shows %u",\r\n(unsigned long long)le64_to_cpu(alloc->i_blkno),\r\nle32_to_cpu(alloc->id1.bitmap1.i_used),\r\nocfs2_local_alloc_count_bits(alloc));\r\nstatus = -EIO;\r\ngoto bail;\r\n}\r\n#endif\r\nfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\r\nle32_to_cpu(alloc->id1.bitmap1.i_used);\r\nif (bits_wanted > free_bits) {\r\nstatus =\r\nocfs2_local_alloc_slide_window(osb, local_alloc_inode);\r\nif (status < 0) {\r\nif (status != -ENOSPC)\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = -ENOSPC;\r\nif (!ocfs2_la_state_enabled(osb))\r\ngoto bail;\r\nfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\r\nle32_to_cpu(alloc->id1.bitmap1.i_used);\r\nif (bits_wanted > free_bits)\r\ngoto bail;\r\n}\r\nac->ac_inode = local_alloc_inode;\r\nac->ac_alloc_slot = osb->slot_num;\r\nac->ac_which = OCFS2_AC_USE_LOCAL;\r\nget_bh(osb->local_alloc_bh);\r\nac->ac_bh = osb->local_alloc_bh;\r\nstatus = 0;\r\nbail:\r\nif (status < 0 && local_alloc_inode) {\r\nmutex_unlock(&local_alloc_inode->i_mutex);\r\niput(local_alloc_inode);\r\n}\r\ntrace_ocfs2_reserve_local_alloc_bits(\r\n(unsigned long long)ac->ac_max_block,\r\nbits_wanted, osb->slot_num, status);\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nint ocfs2_claim_local_alloc_bits(struct ocfs2_super *osb,\r\nhandle_t *handle,\r\nstruct ocfs2_alloc_context *ac,\r\nu32 bits_wanted,\r\nu32 *bit_off,\r\nu32 *num_bits)\r\n{\r\nint status, start;\r\nstruct inode *local_alloc_inode;\r\nvoid *bitmap;\r\nstruct ocfs2_dinode *alloc;\r\nstruct ocfs2_local_alloc *la;\r\nBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\r\nlocal_alloc_inode = ac->ac_inode;\r\nalloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\r\nla = OCFS2_LOCAL_ALLOC(alloc);\r\nstart = ocfs2_local_alloc_find_clear_bits(osb, alloc, &bits_wanted,\r\nac->ac_resv);\r\nif (start == -1) {\r\nstatus = -ENOSPC;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nbitmap = la->la_bitmap;\r\n*bit_off = le32_to_cpu(la->la_bm_off) + start;\r\n*num_bits = bits_wanted;\r\nstatus = ocfs2_journal_access_di(handle,\r\nINODE_CACHE(local_alloc_inode),\r\nosb->local_alloc_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nocfs2_resmap_claimed_bits(&osb->osb_la_resmap, ac->ac_resv, start,\r\nbits_wanted);\r\nwhile(bits_wanted--)\r\nocfs2_set_bit(start++, bitmap);\r\nle32_add_cpu(&alloc->id1.bitmap1.i_used, *num_bits);\r\nocfs2_journal_dirty(handle, osb->local_alloc_bh);\r\nbail:\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\r\n{\r\nu32 count;\r\nstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\r\ncount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\r\ntrace_ocfs2_local_alloc_count_bits(count);\r\nreturn count;\r\n}\r\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\r\nstruct ocfs2_dinode *alloc,\r\nu32 *numbits,\r\nstruct ocfs2_alloc_reservation *resv)\r\n{\r\nint numfound, bitoff, left, startoff, lastzero;\r\nint local_resv = 0;\r\nstruct ocfs2_alloc_reservation r;\r\nvoid *bitmap = NULL;\r\nstruct ocfs2_reservation_map *resmap = &osb->osb_la_resmap;\r\nif (!alloc->id1.bitmap1.i_total) {\r\nbitoff = -1;\r\ngoto bail;\r\n}\r\nif (!resv) {\r\nlocal_resv = 1;\r\nocfs2_resv_init_once(&r);\r\nocfs2_resv_set_type(&r, OCFS2_RESV_FLAG_TMP);\r\nresv = &r;\r\n}\r\nnumfound = *numbits;\r\nif (ocfs2_resmap_resv_bits(resmap, resv, &bitoff, &numfound) == 0) {\r\nif (numfound < *numbits)\r\n*numbits = numfound;\r\ngoto bail;\r\n}\r\nBUG_ON(osb->osb_resv_level != 0);\r\nbitmap = OCFS2_LOCAL_ALLOC(alloc)->la_bitmap;\r\nnumfound = bitoff = startoff = 0;\r\nlastzero = -1;\r\nleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\r\nwhile ((bitoff = ocfs2_find_next_zero_bit(bitmap, left, startoff)) != -1) {\r\nif (bitoff == left) {\r\nbreak;\r\n}\r\nif (bitoff == startoff) {\r\nnumfound++;\r\nstartoff++;\r\n} else {\r\nnumfound = 1;\r\nstartoff = bitoff+1;\r\n}\r\nif (numfound == *numbits) {\r\nbreak;\r\n}\r\n}\r\ntrace_ocfs2_local_alloc_find_clear_bits_search_bitmap(bitoff, numfound);\r\nif (numfound == *numbits)\r\nbitoff = startoff - numfound;\r\nelse\r\nbitoff = -1;\r\nbail:\r\nif (local_resv)\r\nocfs2_resv_discard(resmap, resv);\r\ntrace_ocfs2_local_alloc_find_clear_bits(*numbits,\r\nle32_to_cpu(alloc->id1.bitmap1.i_total),\r\nbitoff, numfound);\r\nreturn bitoff;\r\n}\r\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\r\n{\r\nstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\r\nint i;\r\nalloc->id1.bitmap1.i_total = 0;\r\nalloc->id1.bitmap1.i_used = 0;\r\nla->la_bm_off = 0;\r\nfor(i = 0; i < le16_to_cpu(la->la_size); i++)\r\nla->la_bitmap[i] = 0;\r\n}\r\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\r\nhandle_t *handle,\r\nstruct ocfs2_dinode *alloc,\r\nstruct inode *main_bm_inode,\r\nstruct buffer_head *main_bm_bh)\r\n{\r\nint status = 0;\r\nint bit_off, left, count, start;\r\nu64 la_start_blk;\r\nu64 blkno;\r\nvoid *bitmap;\r\nstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\r\ntrace_ocfs2_sync_local_to_main(\r\nle32_to_cpu(alloc->id1.bitmap1.i_total),\r\nle32_to_cpu(alloc->id1.bitmap1.i_used));\r\nif (!alloc->id1.bitmap1.i_total) {\r\ngoto bail;\r\n}\r\nif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\r\nle32_to_cpu(alloc->id1.bitmap1.i_total)) {\r\ngoto bail;\r\n}\r\nla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\r\nle32_to_cpu(la->la_bm_off));\r\nbitmap = la->la_bitmap;\r\nstart = count = bit_off = 0;\r\nleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\r\nwhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\r\n!= -1) {\r\nif ((bit_off < left) && (bit_off == start)) {\r\ncount++;\r\nstart++;\r\ncontinue;\r\n}\r\nif (count) {\r\nblkno = la_start_blk +\r\nocfs2_clusters_to_blocks(osb->sb,\r\nstart - count);\r\ntrace_ocfs2_sync_local_to_main_free(\r\ncount, start - count,\r\n(unsigned long long)la_start_blk,\r\n(unsigned long long)blkno);\r\nstatus = ocfs2_release_clusters(handle,\r\nmain_bm_inode,\r\nmain_bm_bh, blkno,\r\ncount);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n}\r\nif (bit_off >= left)\r\nbreak;\r\ncount = 1;\r\nstart = bit_off + 1;\r\n}\r\nbail:\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_recalc_la_window(struct ocfs2_super *osb,\r\nenum ocfs2_la_event event)\r\n{\r\nunsigned int bits;\r\nint state;\r\nspin_lock(&osb->osb_lock);\r\nif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\r\nWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\r\ngoto out_unlock;\r\n}\r\nif (event == OCFS2_LA_EVENT_ENOSPC ||\r\nevent == OCFS2_LA_EVENT_FRAGMENTED) {\r\nbits = osb->local_alloc_bits >> 1;\r\nif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\r\nosb->local_alloc_state = OCFS2_LA_THROTTLED;\r\nosb->local_alloc_bits = bits;\r\n} else {\r\nosb->local_alloc_state = OCFS2_LA_DISABLED;\r\n}\r\nqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\r\nOCFS2_LA_ENABLE_INTERVAL);\r\ngoto out_unlock;\r\n}\r\nif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\r\nosb->local_alloc_bits = osb->local_alloc_default_bits;\r\nout_unlock:\r\nstate = osb->local_alloc_state;\r\nspin_unlock(&osb->osb_lock);\r\nreturn state;\r\n}\r\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\r\nstruct ocfs2_alloc_context **ac,\r\nstruct inode **bitmap_inode,\r\nstruct buffer_head **bitmap_bh)\r\n{\r\nint status;\r\n*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\r\nif (!(*ac)) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nretry_enospc:\r\n(*ac)->ac_bits_wanted = osb->local_alloc_default_bits;\r\nstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\r\nif (status == -ENOSPC) {\r\nif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_ENOSPC) ==\r\nOCFS2_LA_DISABLED)\r\ngoto bail;\r\nocfs2_free_ac_resource(*ac);\r\nmemset(*ac, 0, sizeof(struct ocfs2_alloc_context));\r\ngoto retry_enospc;\r\n}\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n*bitmap_inode = (*ac)->ac_inode;\r\nigrab(*bitmap_inode);\r\n*bitmap_bh = (*ac)->ac_bh;\r\nget_bh(*bitmap_bh);\r\nstatus = 0;\r\nbail:\r\nif ((status < 0) && *ac) {\r\nocfs2_free_alloc_context(*ac);\r\n*ac = NULL;\r\n}\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\r\nhandle_t *handle,\r\nstruct ocfs2_alloc_context *ac)\r\n{\r\nint status = 0;\r\nu32 cluster_off, cluster_count;\r\nstruct ocfs2_dinode *alloc = NULL;\r\nstruct ocfs2_local_alloc *la;\r\nalloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\r\nla = OCFS2_LOCAL_ALLOC(alloc);\r\ntrace_ocfs2_local_alloc_new_window(\r\nle32_to_cpu(alloc->id1.bitmap1.i_total),\r\nosb->local_alloc_bits);\r\nac->ac_last_group = osb->la_last_gd;\r\nstatus = ocfs2_claim_clusters(handle, ac, osb->local_alloc_bits,\r\n&cluster_off, &cluster_count);\r\nif (status == -ENOSPC) {\r\nretry_enospc:\r\nif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_FRAGMENTED) ==\r\nOCFS2_LA_DISABLED)\r\ngoto bail;\r\nac->ac_bits_wanted = osb->local_alloc_default_bits;\r\nstatus = ocfs2_claim_clusters(handle, ac,\r\nosb->local_alloc_bits,\r\n&cluster_off,\r\n&cluster_count);\r\nif (status == -ENOSPC)\r\ngoto retry_enospc;\r\nif (status == 0) {\r\nspin_lock(&osb->osb_lock);\r\nosb->local_alloc_bits = cluster_count;\r\nspin_unlock(&osb->osb_lock);\r\n}\r\n}\r\nif (status < 0) {\r\nif (status != -ENOSPC)\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nosb->la_last_gd = ac->ac_last_group;\r\nla->la_bm_off = cpu_to_le32(cluster_off);\r\nalloc->id1.bitmap1.i_total = cpu_to_le32(cluster_count);\r\nalloc->id1.bitmap1.i_used = 0;\r\nmemset(OCFS2_LOCAL_ALLOC(alloc)->la_bitmap, 0,\r\nle16_to_cpu(la->la_size));\r\nocfs2_resmap_restart(&osb->osb_la_resmap, cluster_count,\r\nOCFS2_LOCAL_ALLOC(alloc)->la_bitmap);\r\ntrace_ocfs2_local_alloc_new_window_result(\r\nOCFS2_LOCAL_ALLOC(alloc)->la_bm_off,\r\nle32_to_cpu(alloc->id1.bitmap1.i_total));\r\nbail:\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\r\nstruct inode *local_alloc_inode)\r\n{\r\nint status = 0;\r\nstruct buffer_head *main_bm_bh = NULL;\r\nstruct inode *main_bm_inode = NULL;\r\nhandle_t *handle = NULL;\r\nstruct ocfs2_dinode *alloc;\r\nstruct ocfs2_dinode *alloc_copy = NULL;\r\nstruct ocfs2_alloc_context *ac = NULL;\r\nocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_SLIDE);\r\nstatus = ocfs2_local_alloc_reserve_for_window(osb,\r\n&ac,\r\n&main_bm_inode,\r\n&main_bm_bh);\r\nif (status < 0) {\r\nif (status != -ENOSPC)\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nhandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nhandle = NULL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nalloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\r\nalloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_NOFS);\r\nif (!alloc_copy) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nmemcpy(alloc_copy, alloc, osb->local_alloc_bh->b_size);\r\nstatus = ocfs2_journal_access_di(handle,\r\nINODE_CACHE(local_alloc_inode),\r\nosb->local_alloc_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nocfs2_clear_local_alloc(alloc);\r\nocfs2_journal_dirty(handle, osb->local_alloc_bh);\r\nstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\r\nmain_bm_inode, main_bm_bh);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = ocfs2_local_alloc_new_window(osb, handle, ac);\r\nif (status < 0) {\r\nif (status != -ENOSPC)\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\natomic_inc(&osb->alloc_stats.moves);\r\nbail:\r\nif (handle)\r\nocfs2_commit_trans(osb, handle);\r\nbrelse(main_bm_bh);\r\nif (main_bm_inode)\r\niput(main_bm_inode);\r\nif (alloc_copy)\r\nkfree(alloc_copy);\r\nif (ac)\r\nocfs2_free_alloc_context(ac);\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}
