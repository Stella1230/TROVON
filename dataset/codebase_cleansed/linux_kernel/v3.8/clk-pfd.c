static int clk_pfd_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_pfd *pfd = to_clk_pfd(hw);\r\nwritel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + CLR);\r\nreturn 0;\r\n}\r\nstatic void clk_pfd_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_pfd *pfd = to_clk_pfd(hw);\r\nwritel_relaxed(1 << ((pfd->idx + 1) * 8 - 1), pfd->reg + SET);\r\n}\r\nstatic unsigned long clk_pfd_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pfd *pfd = to_clk_pfd(hw);\r\nu64 tmp = parent_rate;\r\nu8 frac = (readl_relaxed(pfd->reg) >> (pfd->idx * 8)) & 0x3f;\r\ntmp *= 18;\r\ndo_div(tmp, frac);\r\nreturn tmp;\r\n}\r\nstatic long clk_pfd_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nu64 tmp = *prate;\r\nu8 frac;\r\ntmp = tmp * 18 + rate / 2;\r\ndo_div(tmp, rate);\r\nfrac = tmp;\r\nif (frac < 12)\r\nfrac = 12;\r\nelse if (frac > 35)\r\nfrac = 35;\r\ntmp = *prate;\r\ntmp *= 18;\r\ndo_div(tmp, frac);\r\nreturn tmp;\r\n}\r\nstatic int clk_pfd_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pfd *pfd = to_clk_pfd(hw);\r\nu64 tmp = parent_rate;\r\nu8 frac;\r\ntmp = tmp * 18 + rate / 2;\r\ndo_div(tmp, rate);\r\nfrac = tmp;\r\nif (frac < 12)\r\nfrac = 12;\r\nelse if (frac > 35)\r\nfrac = 35;\r\nwritel_relaxed(0x3f << (pfd->idx * 8), pfd->reg + CLR);\r\nwritel_relaxed(frac << (pfd->idx * 8), pfd->reg + SET);\r\nreturn 0;\r\n}\r\nstruct clk *imx_clk_pfd(const char *name, const char *parent_name,\r\nvoid __iomem *reg, u8 idx)\r\n{\r\nstruct clk_pfd *pfd;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npfd = kzalloc(sizeof(*pfd), GFP_KERNEL);\r\nif (!pfd)\r\nreturn ERR_PTR(-ENOMEM);\r\npfd->reg = reg;\r\npfd->idx = idx;\r\ninit.name = name;\r\ninit.ops = &clk_pfd_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npfd->hw.init = &init;\r\nclk = clk_register(NULL, &pfd->hw);\r\nif (IS_ERR(clk))\r\nkfree(pfd);\r\nreturn clk;\r\n}
