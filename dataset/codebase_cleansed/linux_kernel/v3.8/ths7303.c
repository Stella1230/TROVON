int ths7303_setval(struct v4l2_subdev *sd, enum ths7303_filter_mode mode)\r\n{\r\nu8 input_bias_chroma = 3;\r\nu8 input_bias_luma = 3;\r\nint disable = 0;\r\nint err = 0;\r\nu8 val = 0;\r\nu8 temp;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!client)\r\nreturn -EINVAL;\r\nswitch (mode) {\r\ncase THS7303_FILTER_MODE_1080P:\r\nval = (3 << 6);\r\nval |= (3 << 3);\r\nbreak;\r\ncase THS7303_FILTER_MODE_720P_1080I:\r\nval = (2 << 6);\r\nval |= (2 << 3);\r\nbreak;\r\ncase THS7303_FILTER_MODE_480P_576P:\r\nval = (1 << 6);\r\nval |= (1 << 3);\r\nbreak;\r\ncase THS7303_FILTER_MODE_480I_576I:\r\nbreak;\r\ncase THS7303_FILTER_MODE_DISABLE:\r\npr_info("mode disabled\n");\r\ndisable = 1;\r\ndefault:\r\ndisable = 1;\r\n}\r\ntemp = val;\r\nif (!disable)\r\nval |= input_bias_luma;\r\nerr = i2c_smbus_write_byte_data(client, THS7303_CHANNEL_2, val);\r\nif (err)\r\ngoto out;\r\nif (!disable)\r\ntemp |= input_bias_chroma;\r\nerr = i2c_smbus_write_byte_data(client, THS7303_CHANNEL_1, temp);\r\nif (err)\r\ngoto out;\r\nerr = i2c_smbus_write_byte_data(client, THS7303_CHANNEL_3, temp);\r\nif (err)\r\ngoto out;\r\nreturn err;\r\nout:\r\npr_info("write byte data failed\n");\r\nreturn err;\r\n}\r\nstatic int ths7303_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nif (norm & (V4L2_STD_ALL & ~V4L2_STD_SECAM))\r\nreturn ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I);\r\nelse\r\nreturn ths7303_setval(sd, THS7303_FILTER_MODE_DISABLE);\r\n}\r\nstatic int ths7303_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nu32 height = dv_timings->bt.height;\r\nint interlaced = dv_timings->bt.interlaced;\r\nint res = 0;\r\nif (height == 1080 && !interlaced)\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_1080P);\r\nelse if ((height == 720 && !interlaced) ||\r\n(height == 1080 && interlaced))\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_720P_1080I);\r\nelse if ((height == 480 || height == 576) && !interlaced)\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_480P_576P);\r\nelse\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_DISABLE);\r\nreturn res;\r\n}\r\nstatic int ths7303_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_THS7303, 0);\r\n}\r\nstatic int ths7303_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nv4l2_std_id std_id = V4L2_STD_NTSC;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nsd = kzalloc(sizeof(struct v4l2_subdev), GFP_KERNEL);\r\nif (sd == NULL)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(sd, client, &ths7303_ops);\r\nreturn ths7303_s_std_output(sd, std_id);\r\n}\r\nstatic int ths7303_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(sd);\r\nreturn 0;\r\n}
