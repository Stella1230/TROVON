static int\r\ncheck_slot(acpi_handle handle, unsigned long long *sun)\r\n{\r\nint device = -1;\r\nunsigned long long adr, sta;\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\ndbg("Checking slot on path: %s\n", (char *)buffer.pointer);\r\nif (check_sta_before_sun) {\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && !(sta & ACPI_STA_DEVICE_PRESENT))\r\ngoto out;\r\n}\r\nstatus = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status)) {\r\ndbg("_ADR returned %d on %s\n", status, (char *)buffer.pointer);\r\ngoto out;\r\n}\r\nstatus = acpi_evaluate_integer(handle, "_SUN", NULL, sun);\r\nif (ACPI_FAILURE(status)) {\r\ndbg("_SUN returned %d on %s\n", status, (char *)buffer.pointer);\r\ngoto out;\r\n}\r\ndevice = (adr >> 16) & 0xffff;\r\nout:\r\nkfree(buffer.pointer);\r\nreturn device;\r\n}\r\nstatic acpi_status\r\nregister_slot(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint device;\r\nunsigned long long sun;\r\nchar name[SLOT_NAME_SIZE];\r\nstruct acpi_pci_slot *slot;\r\nstruct pci_slot *pci_slot;\r\nstruct callback_args *parent_context = context;\r\nstruct pci_bus *pci_bus = parent_context->pci_bus;\r\ndevice = check_slot(handle, &sun);\r\nif (device < 0)\r\nreturn AE_OK;\r\nslot = kmalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot) {\r\nerr("%s: cannot allocate memory\n", __func__);\r\nreturn AE_OK;\r\n}\r\nsnprintf(name, sizeof(name), "%llu", sun);\r\npci_slot = pci_create_slot(pci_bus, device, name, NULL);\r\nif (IS_ERR(pci_slot)) {\r\nerr("pci_create_slot returned %ld\n", PTR_ERR(pci_slot));\r\nkfree(slot);\r\nreturn AE_OK;\r\n}\r\nslot->root_handle = parent_context->root_handle;\r\nslot->pci_slot = pci_slot;\r\nINIT_LIST_HEAD(&slot->list);\r\nmutex_lock(&slot_list_lock);\r\nlist_add(&slot->list, &slot_list);\r\nmutex_unlock(&slot_list_lock);\r\nget_device(&pci_bus->dev);\r\ndbg("pci_slot: %p, pci_bus: %x, device: %d, name: %s\n",\r\npci_slot, pci_bus->number, device, name);\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nwalk_p2p_bridge(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint device, function;\r\nunsigned long long adr;\r\nacpi_status status;\r\nacpi_handle dummy_handle;\r\nacpi_walk_callback user_function;\r\nstruct pci_dev *dev;\r\nstruct pci_bus *pci_bus;\r\nstruct callback_args child_context;\r\nstruct callback_args *parent_context = context;\r\npci_bus = parent_context->pci_bus;\r\nuser_function = parent_context->user_function;\r\nstatus = acpi_get_handle(handle, "_ADR", &dummy_handle);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nstatus = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\ndevice = (adr >> 16) & 0xffff;\r\nfunction = adr & 0xffff;\r\ndev = pci_get_slot(pci_bus, PCI_DEVFN(device, function));\r\nif (!dev || !dev->subordinate)\r\ngoto out;\r\nchild_context.pci_bus = dev->subordinate;\r\nchild_context.user_function = user_function;\r\nchild_context.root_handle = parent_context->root_handle;\r\ndbg("p2p bridge walk, pci_bus = %x\n", dev->subordinate->number);\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nuser_function, NULL, &child_context, NULL);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nwalk_p2p_bridge, NULL, &child_context, NULL);\r\nout:\r\npci_dev_put(dev);\r\nreturn AE_OK;\r\n}\r\nstatic int\r\nwalk_root_bridge(struct acpi_pci_root *root, acpi_walk_callback user_function)\r\n{\r\nacpi_status status;\r\nacpi_handle handle = root->device->handle;\r\nstruct pci_bus *pci_bus = root->bus;\r\nstruct callback_args context;\r\ncontext.pci_bus = pci_bus;\r\ncontext.user_function = user_function;\r\ncontext.root_handle = handle;\r\ndbg("root bridge walk, pci_bus = %x\n", pci_bus->number);\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nuser_function, NULL, &context, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nwalk_p2p_bridge, NULL, &context, NULL);\r\nif (ACPI_FAILURE(status))\r\nerr("%s: walk_p2p_bridge failure - %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic int\r\nacpi_pci_slot_add(struct acpi_pci_root *root)\r\n{\r\nacpi_status status;\r\nstatus = walk_root_bridge(root, register_slot);\r\nif (ACPI_FAILURE(status))\r\nerr("%s: register_slot failure - %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic void\r\nacpi_pci_slot_remove(struct acpi_pci_root *root)\r\n{\r\nstruct acpi_pci_slot *slot, *tmp;\r\nstruct pci_bus *pbus;\r\nacpi_handle handle = root->device->handle;\r\nmutex_lock(&slot_list_lock);\r\nlist_for_each_entry_safe(slot, tmp, &slot_list, list) {\r\nif (slot->root_handle == handle) {\r\nlist_del(&slot->list);\r\npbus = slot->pci_slot->bus;\r\npci_destroy_slot(slot->pci_slot);\r\nput_device(&pbus->dev);\r\nkfree(slot);\r\n}\r\n}\r\nmutex_unlock(&slot_list_lock);\r\n}\r\nstatic int do_sta_before_sun(const struct dmi_system_id *d)\r\n{\r\ninfo("%s detected: will evaluate _STA before calling _SUN\n", d->ident);\r\ncheck_sta_before_sun = 1;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nacpi_pci_slot_init(void)\r\n{\r\ndmi_check_system(acpi_pci_slot_dmi_table);\r\nacpi_pci_register_driver(&acpi_pci_slot_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nacpi_pci_slot_exit(void)\r\n{\r\nacpi_pci_unregister_driver(&acpi_pci_slot_driver);\r\n}
