static ssize_t debug_read_ver(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu32 ver = omap_iommu_arch_version();\r\nchar buf[MAXCOLUMN], *p = buf;\r\np += sprintf(p, "H/W version: %d.%d\n", (ver >> 4) & 0xf , ver & 0xf);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t debug_read_regs(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nchar *p, *buf;\r\nssize_t bytes;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\nmutex_lock(&iommu_debug_lock);\r\nbytes = omap_iommu_dump_ctx(obj, p, count);\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, bytes);\r\nmutex_unlock(&iommu_debug_lock);\r\nkfree(buf);\r\nreturn bytes;\r\n}\r\nstatic ssize_t debug_read_tlb(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nchar *p, *buf;\r\nssize_t bytes, rest;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\nmutex_lock(&iommu_debug_lock);\r\np += sprintf(p, "%8s %8s\n", "cam:", "ram:");\r\np += sprintf(p, "-----------------------------------------\n");\r\nrest = count - (p - buf);\r\np += omap_dump_tlb_entries(obj, p, rest);\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\nmutex_unlock(&iommu_debug_lock);\r\nkfree(buf);\r\nreturn bytes;\r\n}\r\nstatic ssize_t debug_write_pagetable(struct file *file,\r\nconst char __user *userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct iotlb_entry e;\r\nstruct cr_regs cr;\r\nint err;\r\nstruct device *dev = file->private_data;\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nchar buf[MAXCOLUMN], *p = buf;\r\ncount = min(count, sizeof(buf));\r\nmutex_lock(&iommu_debug_lock);\r\nif (copy_from_user(p, userbuf, count)) {\r\nmutex_unlock(&iommu_debug_lock);\r\nreturn -EFAULT;\r\n}\r\nsscanf(p, "%x %x", &cr.cam, &cr.ram);\r\nif (!cr.cam || !cr.ram) {\r\nmutex_unlock(&iommu_debug_lock);\r\nreturn -EINVAL;\r\n}\r\nomap_iotlb_cr_to_e(&cr, &e);\r\nerr = omap_iopgtable_store_entry(obj, &e);\r\nif (err)\r\ndev_err(obj->dev, "%s: fail to store cr\n", __func__);\r\nmutex_unlock(&iommu_debug_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t dump_ioptable(struct omap_iommu *obj, char *buf, ssize_t len)\r\n{\r\nint i;\r\nu32 *iopgd;\r\nchar *p = buf;\r\nspin_lock(&obj->page_table_lock);\r\niopgd = iopgd_offset(obj, 0);\r\nfor (i = 0; i < PTRS_PER_IOPGD; i++, iopgd++) {\r\nint j, err;\r\nu32 *iopte;\r\nu32 da;\r\nif (!*iopgd)\r\ncontinue;\r\nif (!(*iopgd & IOPGD_TABLE)) {\r\nda = i << IOPGD_SHIFT;\r\nerr = dump_ioptable_entry_one(1, da, *iopgd);\r\nif (err)\r\ngoto out;\r\ncontinue;\r\n}\r\niopte = iopte_offset(iopgd, 0);\r\nfor (j = 0; j < PTRS_PER_IOPTE; j++, iopte++) {\r\nif (!*iopte)\r\ncontinue;\r\nda = (i << IOPGD_SHIFT) + (j << IOPTE_SHIFT);\r\nerr = dump_ioptable_entry_one(2, da, *iopgd);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock(&obj->page_table_lock);\r\nreturn p - buf;\r\n}\r\nstatic ssize_t debug_read_pagetable(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nchar *p, *buf;\r\nsize_t bytes;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\np += sprintf(p, "L: %8s %8s\n", "da:", "pa:");\r\np += sprintf(p, "-----------------------------------------\n");\r\nmutex_lock(&iommu_debug_lock);\r\nbytes = PAGE_SIZE - (p - buf);\r\np += dump_ioptable(obj, p, bytes);\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\nmutex_unlock(&iommu_debug_lock);\r\nfree_page((unsigned long)buf);\r\nreturn bytes;\r\n}\r\nstatic ssize_t debug_read_mmap(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\nchar *p, *buf;\r\nstruct iovm_struct *tmp;\r\nint uninitialized_var(i);\r\nssize_t bytes;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\np += sprintf(p, "%-3s %-8s %-8s %6s %8s\n",\r\n"No", "start", "end", "size", "flags");\r\np += sprintf(p, "-------------------------------------------------\n");\r\nmutex_lock(&iommu_debug_lock);\r\nlist_for_each_entry(tmp, &obj->mmap, list) {\r\nsize_t len;\r\nconst char *str = "%3d %08x-%08x %6x %8x\n";\r\nconst int maxcol = 39;\r\nlen = tmp->da_end - tmp->da_start;\r\np += snprintf(p, maxcol, str,\r\ni, tmp->da_start, tmp->da_end, len, tmp->flags);\r\nif (PAGE_SIZE - (p - buf) < maxcol)\r\nbreak;\r\ni++;\r\n}\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\nmutex_unlock(&iommu_debug_lock);\r\nfree_page((unsigned long)buf);\r\nreturn bytes;\r\n}\r\nstatic ssize_t debug_read_mem(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nchar *p, *buf;\r\nstruct iovm_struct *area;\r\nssize_t bytes;\r\ncount = min_t(ssize_t, count, PAGE_SIZE);\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\nmutex_lock(&iommu_debug_lock);\r\narea = omap_find_iovm_area(dev, (u32)ppos);\r\nif (!area) {\r\nbytes = -EINVAL;\r\ngoto err_out;\r\n}\r\nmemcpy(p, area->va, count);\r\np += count;\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\nerr_out:\r\nmutex_unlock(&iommu_debug_lock);\r\nfree_page((unsigned long)buf);\r\nreturn bytes;\r\n}\r\nstatic ssize_t debug_write_mem(struct file *file, const char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct iovm_struct *area;\r\nchar *p, *buf;\r\ncount = min_t(size_t, count, PAGE_SIZE);\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\nmutex_lock(&iommu_debug_lock);\r\nif (copy_from_user(p, userbuf, count)) {\r\ncount = -EFAULT;\r\ngoto err_out;\r\n}\r\narea = omap_find_iovm_area(dev, (u32)ppos);\r\nif (!area) {\r\ncount = -EINVAL;\r\ngoto err_out;\r\n}\r\nmemcpy(area->va, p, count);\r\nerr_out:\r\nmutex_unlock(&iommu_debug_lock);\r\nfree_page((unsigned long)buf);\r\nreturn count;\r\n}\r\nstatic int iommu_debug_register(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_iommu *obj = platform_get_drvdata(pdev);\r\nstruct omap_iommu_arch_data *arch_data;\r\nstruct dentry *d, *parent;\r\nif (!obj || !obj->dev)\r\nreturn -EINVAL;\r\narch_data = kzalloc(sizeof(*arch_data), GFP_KERNEL);\r\nif (!arch_data)\r\nreturn -ENOMEM;\r\narch_data->iommu_dev = obj;\r\ndev->archdata.iommu = arch_data;\r\nd = debugfs_create_dir(obj->name, iommu_debug_root);\r\nif (!d)\r\ngoto nomem;\r\nparent = d;\r\nd = debugfs_create_u8("nr_tlb_entries", 400, parent,\r\n(u8 *)&obj->nr_tlb_entries);\r\nif (!d)\r\ngoto nomem;\r\nDEBUG_ADD_FILE_RO(ver);\r\nDEBUG_ADD_FILE_RO(regs);\r\nDEBUG_ADD_FILE_RO(tlb);\r\nDEBUG_ADD_FILE(pagetable);\r\nDEBUG_ADD_FILE_RO(mmap);\r\nDEBUG_ADD_FILE(mem);\r\nreturn 0;\r\nnomem:\r\nkfree(arch_data);\r\nreturn -ENOMEM;\r\n}\r\nstatic int iommu_debug_unregister(struct device *dev, void *data)\r\n{\r\nif (!dev->archdata.iommu)\r\nreturn 0;\r\nkfree(dev->archdata.iommu);\r\ndev->archdata.iommu = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init iommu_debug_init(void)\r\n{\r\nstruct dentry *d;\r\nint err;\r\nd = debugfs_create_dir("iommu", NULL);\r\nif (!d)\r\nreturn -ENOMEM;\r\niommu_debug_root = d;\r\nerr = omap_foreach_iommu_device(d, iommu_debug_register);\r\nif (err)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ndebugfs_remove_recursive(iommu_debug_root);\r\nreturn err;\r\n}\r\nstatic void __exit iommu_debugfs_exit(void)\r\n{\r\ndebugfs_remove_recursive(iommu_debug_root);\r\nomap_foreach_iommu_device(NULL, iommu_debug_unregister);\r\n}
