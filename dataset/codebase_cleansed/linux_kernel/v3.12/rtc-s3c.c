static void s3c_rtc_alarm_clk_enable(bool enable)\r\n{\r\nstatic DEFINE_SPINLOCK(s3c_rtc_alarm_clk_lock);\r\nstatic bool alarm_clk_enabled;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&s3c_rtc_alarm_clk_lock, irq_flags);\r\nif (enable) {\r\nif (!alarm_clk_enabled) {\r\nclk_enable(rtc_clk);\r\nalarm_clk_enabled = true;\r\n}\r\n} else {\r\nif (alarm_clk_enabled) {\r\nclk_disable(rtc_clk);\r\nalarm_clk_enabled = false;\r\n}\r\n}\r\nspin_unlock_irqrestore(&s3c_rtc_alarm_clk_lock, irq_flags);\r\n}\r\nstatic irqreturn_t s3c_rtc_alarmirq(int irq, void *id)\r\n{\r\nstruct rtc_device *rdev = id;\r\nclk_enable(rtc_clk);\r\nrtc_update_irq(rdev, 1, RTC_AF | RTC_IRQF);\r\nif (s3c_rtc_cpu_type == TYPE_S3C64XX)\r\nwriteb(S3C2410_INTP_ALM, s3c_rtc_base + S3C2410_INTP);\r\nclk_disable(rtc_clk);\r\ns3c_rtc_alarm_clk_enable(false);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t s3c_rtc_tickirq(int irq, void *id)\r\n{\r\nstruct rtc_device *rdev = id;\r\nclk_enable(rtc_clk);\r\nrtc_update_irq(rdev, 1, RTC_PF | RTC_IRQF);\r\nif (s3c_rtc_cpu_type == TYPE_S3C64XX)\r\nwriteb(S3C2410_INTP_TIC, s3c_rtc_base + S3C2410_INTP);\r\nclk_disable(rtc_clk);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_rtc_setaie(struct device *dev, unsigned int enabled)\r\n{\r\nunsigned int tmp;\r\ndev_dbg(dev, "%s: aie=%d\n", __func__, enabled);\r\nclk_enable(rtc_clk);\r\ntmp = readb(s3c_rtc_base + S3C2410_RTCALM) & ~S3C2410_RTCALM_ALMEN;\r\nif (enabled)\r\ntmp |= S3C2410_RTCALM_ALMEN;\r\nwriteb(tmp, s3c_rtc_base + S3C2410_RTCALM);\r\nclk_disable(rtc_clk);\r\ns3c_rtc_alarm_clk_enable(enabled);\r\nreturn 0;\r\n}\r\nstatic int s3c_rtc_setfreq(struct device *dev, int freq)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_device *rtc_dev = platform_get_drvdata(pdev);\r\nunsigned int tmp = 0;\r\nint val;\r\nif (!is_power_of_2(freq))\r\nreturn -EINVAL;\r\nclk_enable(rtc_clk);\r\nspin_lock_irq(&s3c_rtc_pie_lock);\r\nif (s3c_rtc_cpu_type != TYPE_S3C64XX) {\r\ntmp = readb(s3c_rtc_base + S3C2410_TICNT);\r\ntmp &= S3C2410_TICNT_ENABLE;\r\n}\r\nval = (rtc_dev->max_user_freq / freq) - 1;\r\nif (s3c_rtc_cpu_type == TYPE_S3C2416 || s3c_rtc_cpu_type == TYPE_S3C2443) {\r\ntmp |= S3C2443_TICNT_PART(val);\r\nwritel(S3C2443_TICNT1_PART(val), s3c_rtc_base + S3C2443_TICNT1);\r\nif (s3c_rtc_cpu_type == TYPE_S3C2416)\r\nwritel(S3C2416_TICNT2_PART(val), s3c_rtc_base + S3C2416_TICNT2);\r\n} else {\r\ntmp |= val;\r\n}\r\nwritel(tmp, s3c_rtc_base + S3C2410_TICNT);\r\nspin_unlock_irq(&s3c_rtc_pie_lock);\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nunsigned int have_retried = 0;\r\nvoid __iomem *base = s3c_rtc_base;\r\nclk_enable(rtc_clk);\r\nretry_get_time:\r\nrtc_tm->tm_min = readb(base + S3C2410_RTCMIN);\r\nrtc_tm->tm_hour = readb(base + S3C2410_RTCHOUR);\r\nrtc_tm->tm_mday = readb(base + S3C2410_RTCDATE);\r\nrtc_tm->tm_mon = readb(base + S3C2410_RTCMON);\r\nrtc_tm->tm_year = readb(base + S3C2410_RTCYEAR);\r\nrtc_tm->tm_sec = readb(base + S3C2410_RTCSEC);\r\nif (rtc_tm->tm_sec == 0 && !have_retried) {\r\nhave_retried = 1;\r\ngoto retry_get_time;\r\n}\r\nrtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);\r\nrtc_tm->tm_min = bcd2bin(rtc_tm->tm_min);\r\nrtc_tm->tm_hour = bcd2bin(rtc_tm->tm_hour);\r\nrtc_tm->tm_mday = bcd2bin(rtc_tm->tm_mday);\r\nrtc_tm->tm_mon = bcd2bin(rtc_tm->tm_mon);\r\nrtc_tm->tm_year = bcd2bin(rtc_tm->tm_year);\r\nrtc_tm->tm_year += 100;\r\ndev_dbg(dev, "read time %04d.%02d.%02d %02d:%02d:%02d\n",\r\n1900 + rtc_tm->tm_year, rtc_tm->tm_mon, rtc_tm->tm_mday,\r\nrtc_tm->tm_hour, rtc_tm->tm_min, rtc_tm->tm_sec);\r\nrtc_tm->tm_mon -= 1;\r\nclk_disable(rtc_clk);\r\nreturn rtc_valid_tm(rtc_tm);\r\n}\r\nstatic int s3c_rtc_settime(struct device *dev, struct rtc_time *tm)\r\n{\r\nvoid __iomem *base = s3c_rtc_base;\r\nint year = tm->tm_year - 100;\r\ndev_dbg(dev, "set time %04d.%02d.%02d %02d:%02d:%02d\n",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nif (year < 0 || year >= 100) {\r\ndev_err(dev, "rtc only supports 100 years\n");\r\nreturn -EINVAL;\r\n}\r\nclk_enable(rtc_clk);\r\nwriteb(bin2bcd(tm->tm_sec), base + S3C2410_RTCSEC);\r\nwriteb(bin2bcd(tm->tm_min), base + S3C2410_RTCMIN);\r\nwriteb(bin2bcd(tm->tm_hour), base + S3C2410_RTCHOUR);\r\nwriteb(bin2bcd(tm->tm_mday), base + S3C2410_RTCDATE);\r\nwriteb(bin2bcd(tm->tm_mon + 1), base + S3C2410_RTCMON);\r\nwriteb(bin2bcd(year), base + S3C2410_RTCYEAR);\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_rtc_getalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct rtc_time *alm_tm = &alrm->time;\r\nvoid __iomem *base = s3c_rtc_base;\r\nunsigned int alm_en;\r\nclk_enable(rtc_clk);\r\nalm_tm->tm_sec = readb(base + S3C2410_ALMSEC);\r\nalm_tm->tm_min = readb(base + S3C2410_ALMMIN);\r\nalm_tm->tm_hour = readb(base + S3C2410_ALMHOUR);\r\nalm_tm->tm_mon = readb(base + S3C2410_ALMMON);\r\nalm_tm->tm_mday = readb(base + S3C2410_ALMDATE);\r\nalm_tm->tm_year = readb(base + S3C2410_ALMYEAR);\r\nalm_en = readb(base + S3C2410_RTCALM);\r\nalrm->enabled = (alm_en & S3C2410_RTCALM_ALMEN) ? 1 : 0;\r\ndev_dbg(dev, "read alarm %d, %04d.%02d.%02d %02d:%02d:%02d\n",\r\nalm_en,\r\n1900 + alm_tm->tm_year, alm_tm->tm_mon, alm_tm->tm_mday,\r\nalm_tm->tm_hour, alm_tm->tm_min, alm_tm->tm_sec);\r\nif (alm_en & S3C2410_RTCALM_SECEN)\r\nalm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);\r\nelse\r\nalm_tm->tm_sec = -1;\r\nif (alm_en & S3C2410_RTCALM_MINEN)\r\nalm_tm->tm_min = bcd2bin(alm_tm->tm_min);\r\nelse\r\nalm_tm->tm_min = -1;\r\nif (alm_en & S3C2410_RTCALM_HOUREN)\r\nalm_tm->tm_hour = bcd2bin(alm_tm->tm_hour);\r\nelse\r\nalm_tm->tm_hour = -1;\r\nif (alm_en & S3C2410_RTCALM_DAYEN)\r\nalm_tm->tm_mday = bcd2bin(alm_tm->tm_mday);\r\nelse\r\nalm_tm->tm_mday = -1;\r\nif (alm_en & S3C2410_RTCALM_MONEN) {\r\nalm_tm->tm_mon = bcd2bin(alm_tm->tm_mon);\r\nalm_tm->tm_mon -= 1;\r\n} else {\r\nalm_tm->tm_mon = -1;\r\n}\r\nif (alm_en & S3C2410_RTCALM_YEAREN)\r\nalm_tm->tm_year = bcd2bin(alm_tm->tm_year);\r\nelse\r\nalm_tm->tm_year = -1;\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct rtc_time *tm = &alrm->time;\r\nvoid __iomem *base = s3c_rtc_base;\r\nunsigned int alrm_en;\r\nclk_enable(rtc_clk);\r\ndev_dbg(dev, "s3c_rtc_setalarm: %d, %04d.%02d.%02d %02d:%02d:%02d\n",\r\nalrm->enabled,\r\n1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nalrm_en = readb(base + S3C2410_RTCALM) & S3C2410_RTCALM_ALMEN;\r\nwriteb(0x00, base + S3C2410_RTCALM);\r\nif (tm->tm_sec < 60 && tm->tm_sec >= 0) {\r\nalrm_en |= S3C2410_RTCALM_SECEN;\r\nwriteb(bin2bcd(tm->tm_sec), base + S3C2410_ALMSEC);\r\n}\r\nif (tm->tm_min < 60 && tm->tm_min >= 0) {\r\nalrm_en |= S3C2410_RTCALM_MINEN;\r\nwriteb(bin2bcd(tm->tm_min), base + S3C2410_ALMMIN);\r\n}\r\nif (tm->tm_hour < 24 && tm->tm_hour >= 0) {\r\nalrm_en |= S3C2410_RTCALM_HOUREN;\r\nwriteb(bin2bcd(tm->tm_hour), base + S3C2410_ALMHOUR);\r\n}\r\ndev_dbg(dev, "setting S3C2410_RTCALM to %08x\n", alrm_en);\r\nwriteb(alrm_en, base + S3C2410_RTCALM);\r\ns3c_rtc_setaie(dev, alrm->enabled);\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nunsigned int ticnt;\r\nclk_enable(rtc_clk);\r\nif (s3c_rtc_cpu_type == TYPE_S3C64XX) {\r\nticnt = readw(s3c_rtc_base + S3C2410_RTCCON);\r\nticnt &= S3C64XX_RTCCON_TICEN;\r\n} else {\r\nticnt = readb(s3c_rtc_base + S3C2410_TICNT);\r\nticnt &= S3C2410_TICNT_ENABLE;\r\n}\r\nseq_printf(seq, "periodic_IRQ\t: %s\n", ticnt ? "yes" : "no");\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}\r\nstatic void s3c_rtc_enable(struct platform_device *pdev, int en)\r\n{\r\nvoid __iomem *base = s3c_rtc_base;\r\nunsigned int tmp;\r\nif (s3c_rtc_base == NULL)\r\nreturn;\r\nclk_enable(rtc_clk);\r\nif (!en) {\r\ntmp = readw(base + S3C2410_RTCCON);\r\nif (s3c_rtc_cpu_type == TYPE_S3C64XX)\r\ntmp &= ~S3C64XX_RTCCON_TICEN;\r\ntmp &= ~S3C2410_RTCCON_RTCEN;\r\nwritew(tmp, base + S3C2410_RTCCON);\r\nif (s3c_rtc_cpu_type != TYPE_S3C64XX) {\r\ntmp = readb(base + S3C2410_TICNT);\r\ntmp &= ~S3C2410_TICNT_ENABLE;\r\nwriteb(tmp, base + S3C2410_TICNT);\r\n}\r\n} else {\r\nif ((readw(base+S3C2410_RTCCON) & S3C2410_RTCCON_RTCEN) == 0) {\r\ndev_info(&pdev->dev, "rtc disabled, re-enabling\n");\r\ntmp = readw(base + S3C2410_RTCCON);\r\nwritew(tmp | S3C2410_RTCCON_RTCEN,\r\nbase + S3C2410_RTCCON);\r\n}\r\nif ((readw(base + S3C2410_RTCCON) & S3C2410_RTCCON_CNTSEL)) {\r\ndev_info(&pdev->dev, "removing RTCCON_CNTSEL\n");\r\ntmp = readw(base + S3C2410_RTCCON);\r\nwritew(tmp & ~S3C2410_RTCCON_CNTSEL,\r\nbase + S3C2410_RTCCON);\r\n}\r\nif ((readw(base + S3C2410_RTCCON) & S3C2410_RTCCON_CLKRST)) {\r\ndev_info(&pdev->dev, "removing RTCCON_CLKRST\n");\r\ntmp = readw(base + S3C2410_RTCCON);\r\nwritew(tmp & ~S3C2410_RTCCON_CLKRST,\r\nbase + S3C2410_RTCCON);\r\n}\r\n}\r\nclk_disable(rtc_clk);\r\n}\r\nstatic int s3c_rtc_remove(struct platform_device *dev)\r\n{\r\ns3c_rtc_setaie(&dev->dev, 0);\r\nclk_unprepare(rtc_clk);\r\nrtc_clk = NULL;\r\nreturn 0;\r\n}\r\nstatic inline int s3c_rtc_get_driver_data(struct platform_device *pdev)\r\n{\r\n#ifdef CONFIG_OF\r\nstruct s3c_rtc_drv_data *data;\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(s3c_rtc_dt_match, pdev->dev.of_node);\r\ndata = (struct s3c_rtc_drv_data *) match->data;\r\nreturn data->cpu_type;\r\n}\r\n#endif\r\nreturn platform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int s3c_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc;\r\nstruct rtc_time rtc_tm;\r\nstruct resource *res;\r\nint ret;\r\nint tmp;\r\ndev_dbg(&pdev->dev, "%s: probe=%p\n", __func__, pdev);\r\ns3c_rtc_tickno = platform_get_irq(pdev, 1);\r\nif (s3c_rtc_tickno < 0) {\r\ndev_err(&pdev->dev, "no irq for rtc tick\n");\r\nreturn s3c_rtc_tickno;\r\n}\r\ns3c_rtc_alarmno = platform_get_irq(pdev, 0);\r\nif (s3c_rtc_alarmno < 0) {\r\ndev_err(&pdev->dev, "no irq for alarm\n");\r\nreturn s3c_rtc_alarmno;\r\n}\r\ndev_dbg(&pdev->dev, "s3c2410_rtc: tick irq %d, alarm irq %d\n",\r\ns3c_rtc_tickno, s3c_rtc_alarmno);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ns3c_rtc_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(s3c_rtc_base))\r\nreturn PTR_ERR(s3c_rtc_base);\r\nrtc_clk = devm_clk_get(&pdev->dev, "rtc");\r\nif (IS_ERR(rtc_clk)) {\r\ndev_err(&pdev->dev, "failed to find rtc clock source\n");\r\nret = PTR_ERR(rtc_clk);\r\nrtc_clk = NULL;\r\nreturn ret;\r\n}\r\nclk_prepare_enable(rtc_clk);\r\ns3c_rtc_enable(pdev, 1);\r\ndev_dbg(&pdev->dev, "s3c2410_rtc: RTCCON=%02x\n",\r\nreadw(s3c_rtc_base + S3C2410_RTCCON));\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc = devm_rtc_device_register(&pdev->dev, "s3c", &s3c_rtcops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\ndev_err(&pdev->dev, "cannot attach rtc\n");\r\nret = PTR_ERR(rtc);\r\ngoto err_nortc;\r\n}\r\ns3c_rtc_cpu_type = s3c_rtc_get_driver_data(pdev);\r\ns3c_rtc_gettime(NULL, &rtc_tm);\r\nif (rtc_valid_tm(&rtc_tm)) {\r\nrtc_tm.tm_year = 100;\r\nrtc_tm.tm_mon = 0;\r\nrtc_tm.tm_mday = 1;\r\nrtc_tm.tm_hour = 0;\r\nrtc_tm.tm_min = 0;\r\nrtc_tm.tm_sec = 0;\r\ns3c_rtc_settime(NULL, &rtc_tm);\r\ndev_warn(&pdev->dev, "warning: invalid RTC value so initializing it\n");\r\n}\r\nif (s3c_rtc_cpu_type != TYPE_S3C2410)\r\nrtc->max_user_freq = 32768;\r\nelse\r\nrtc->max_user_freq = 128;\r\nif (s3c_rtc_cpu_type == TYPE_S3C2416 || s3c_rtc_cpu_type == TYPE_S3C2443) {\r\ntmp = readw(s3c_rtc_base + S3C2410_RTCCON);\r\ntmp |= S3C2443_RTCCON_TICSEL;\r\nwritew(tmp, s3c_rtc_base + S3C2410_RTCCON);\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\ns3c_rtc_setfreq(&pdev->dev, 1);\r\nret = devm_request_irq(&pdev->dev, s3c_rtc_alarmno, s3c_rtc_alarmirq,\r\n0, "s3c2410-rtc alarm", rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "IRQ%d error %d\n", s3c_rtc_alarmno, ret);\r\ngoto err_nortc;\r\n}\r\nret = devm_request_irq(&pdev->dev, s3c_rtc_tickno, s3c_rtc_tickirq,\r\n0, "s3c2410-rtc tick", rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "IRQ%d error %d\n", s3c_rtc_tickno, ret);\r\ngoto err_nortc;\r\n}\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\nerr_nortc:\r\ns3c_rtc_enable(pdev, 0);\r\nclk_disable_unprepare(rtc_clk);\r\nreturn ret;\r\n}\r\nstatic int s3c_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nclk_enable(rtc_clk);\r\nticnt_save = readb(s3c_rtc_base + S3C2410_TICNT);\r\nif (s3c_rtc_cpu_type == TYPE_S3C64XX) {\r\nticnt_en_save = readw(s3c_rtc_base + S3C2410_RTCCON);\r\nticnt_en_save &= S3C64XX_RTCCON_TICEN;\r\n}\r\ns3c_rtc_enable(pdev, 0);\r\nif (device_may_wakeup(dev) && !wake_en) {\r\nif (enable_irq_wake(s3c_rtc_alarmno) == 0)\r\nwake_en = true;\r\nelse\r\ndev_err(dev, "enable_irq_wake failed\n");\r\n}\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nunsigned int tmp;\r\nclk_enable(rtc_clk);\r\ns3c_rtc_enable(pdev, 1);\r\nwriteb(ticnt_save, s3c_rtc_base + S3C2410_TICNT);\r\nif (s3c_rtc_cpu_type == TYPE_S3C64XX && ticnt_en_save) {\r\ntmp = readw(s3c_rtc_base + S3C2410_RTCCON);\r\nwritew(tmp | ticnt_en_save, s3c_rtc_base + S3C2410_RTCCON);\r\n}\r\nif (device_may_wakeup(dev) && wake_en) {\r\ndisable_irq_wake(s3c_rtc_alarmno);\r\nwake_en = false;\r\n}\r\nclk_disable(rtc_clk);\r\nreturn 0;\r\n}
