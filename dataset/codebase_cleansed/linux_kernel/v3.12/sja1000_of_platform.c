static u8 sja1000_ofp_read_reg(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg);\r\n}\r\nstatic void sja1000_ofp_write_reg(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg);\r\n}\r\nstatic int sja1000_ofp_remove(struct platform_device *ofdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct resource res;\r\nunregister_sja1000dev(dev);\r\nfree_sja1000dev(dev);\r\niounmap(priv->reg_base);\r\nirq_dispose_mapping(dev->irq);\r\nof_address_to_resource(np, 0, &res);\r\nrelease_mem_region(res.start, resource_size(&res));\r\nreturn 0;\r\n}\r\nstatic int sja1000_ofp_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\nstruct resource res;\r\nu32 prop;\r\nint err, irq, res_size;\r\nvoid __iomem *base;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err) {\r\ndev_err(&ofdev->dev, "invalid address\n");\r\nreturn err;\r\n}\r\nres_size = resource_size(&res);\r\nif (!request_mem_region(res.start, res_size, DRV_NAME)) {\r\ndev_err(&ofdev->dev, "couldn't request %pR\n", &res);\r\nreturn -EBUSY;\r\n}\r\nbase = ioremap_nocache(res.start, res_size);\r\nif (!base) {\r\ndev_err(&ofdev->dev, "couldn't ioremap %pR\n", &res);\r\nerr = -ENOMEM;\r\ngoto exit_release_mem;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq == 0) {\r\ndev_err(&ofdev->dev, "no irq found\n");\r\nerr = -ENODEV;\r\ngoto exit_unmap_mem;\r\n}\r\ndev = alloc_sja1000dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_dispose_irq;\r\n}\r\npriv = netdev_priv(dev);\r\npriv->read_reg = sja1000_ofp_read_reg;\r\npriv->write_reg = sja1000_ofp_write_reg;\r\nerr = of_property_read_u32(np, "nxp,external-clock-frequency", &prop);\r\nif (!err)\r\npriv->can.clock.freq = prop / 2;\r\nelse\r\npriv->can.clock.freq = SJA1000_OFP_CAN_CLOCK;\r\nerr = of_property_read_u32(np, "nxp,tx-output-mode", &prop);\r\nif (!err)\r\npriv->ocr |= prop & OCR_MODE_MASK;\r\nelse\r\npriv->ocr |= OCR_MODE_NORMAL;\r\nerr = of_property_read_u32(np, "nxp,tx-output-config", &prop);\r\nif (!err)\r\npriv->ocr |= (prop << OCR_TX_SHIFT) & OCR_TX_MASK;\r\nelse\r\npriv->ocr |= OCR_TX0_PULLDOWN;\r\nerr = of_property_read_u32(np, "nxp,clock-out-frequency", &prop);\r\nif (!err && prop) {\r\nu32 divider = priv->can.clock.freq * 2 / prop;\r\nif (divider > 1)\r\npriv->cdr |= divider / 2 - 1;\r\nelse\r\npriv->cdr |= CDR_CLKOUT_MASK;\r\n} else {\r\npriv->cdr |= CDR_CLK_OFF;\r\n}\r\nif (!of_property_read_bool(np, "nxp,no-comparator-bypass"))\r\npriv->cdr |= CDR_CBP;\r\npriv->irq_flags = IRQF_SHARED;\r\npriv->reg_base = base;\r\ndev->irq = irq;\r\ndev_info(&ofdev->dev,\r\n"reg_base=0x%p irq=%d clock=%d ocr=0x%02x cdr=0x%02x\n",\r\npriv->reg_base, dev->irq, priv->can.clock.freq,\r\npriv->ocr, priv->cdr);\r\nplatform_set_drvdata(ofdev, dev);\r\nSET_NETDEV_DEV(dev, &ofdev->dev);\r\nerr = register_sja1000dev(dev);\r\nif (err) {\r\ndev_err(&ofdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free_sja1000;\r\n}\r\nreturn 0;\r\nexit_free_sja1000:\r\nfree_sja1000dev(dev);\r\nexit_dispose_irq:\r\nirq_dispose_mapping(irq);\r\nexit_unmap_mem:\r\niounmap(base);\r\nexit_release_mem:\r\nrelease_mem_region(res.start, res_size);\r\nreturn err;\r\n}
