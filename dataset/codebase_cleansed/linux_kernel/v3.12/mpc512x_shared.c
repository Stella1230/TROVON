static void __init mpc512x_restart_init(void)\r\n{\r\nstruct device_node *np;\r\nconst char *reset_compat;\r\nreset_compat = mpc512x_select_reset_compat();\r\nnp = of_find_compatible_node(NULL, NULL, reset_compat);\r\nif (!np)\r\nreturn;\r\nreset_module_base = of_iomap(np, 0);\r\nof_node_put(np);\r\n}\r\nvoid mpc512x_restart(char *cmd)\r\n{\r\nif (reset_module_base) {\r\nout_be32(&reset_module_base->rpr, 0x52535445);\r\nout_be32(&reset_module_base->rcr, 0x2);\r\n} else {\r\npr_err("Restart module not mapped.\n");\r\n}\r\nfor (;;)\r\n;\r\n}\r\nvoid mpc512x_set_pixel_clock(unsigned int pixclock)\r\n{\r\nunsigned long bestval, bestfreq, speed, busfreq;\r\nunsigned long minpixclock, maxpixclock, pixval;\r\nstruct mpc512x_ccm __iomem *ccm;\r\nstruct device_node *np;\r\nu32 temp;\r\nlong err;\r\nint i;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-clock");\r\nif (!np) {\r\npr_err("Can't find clock control module.\n");\r\nreturn;\r\n}\r\nccm = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!ccm) {\r\npr_err("Can't map clock control module reg.\n");\r\nreturn;\r\n}\r\nnp = of_find_node_by_type(NULL, "cpu");\r\nif (np) {\r\nconst unsigned int *prop =\r\nof_get_property(np, "bus-frequency", NULL);\r\nof_node_put(np);\r\nif (prop) {\r\nbusfreq = *prop;\r\n} else {\r\npr_err("Can't get bus-frequency property\n");\r\nreturn;\r\n}\r\n} else {\r\npr_err("Can't find 'cpu' node.\n");\r\nreturn;\r\n}\r\npr_debug("DIU: Bus Frequency = %lu\n", busfreq);\r\nspeed = busfreq * 4;\r\npr_debug("DIU pixclock in ps - %d\n", pixclock);\r\ntemp = (1000000000 / pixclock) * 1000;\r\npixclock = temp;\r\npr_debug("DIU pixclock freq - %u\n", pixclock);\r\ntemp = temp / 20;\r\npr_debug("deviation = %d\n", temp);\r\nminpixclock = pixclock - temp;\r\nmaxpixclock = pixclock + temp;\r\npr_debug("DIU minpixclock - %lu\n", minpixclock);\r\npr_debug("DIU maxpixclock - %lu\n", maxpixclock);\r\npixval = speed/pixclock;\r\npr_debug("DIU pixval = %lu\n", pixval);\r\nerr = LONG_MAX;\r\nbestval = pixval;\r\npr_debug("DIU bestval = %lu\n", bestval);\r\nbestfreq = 0;\r\nfor (i = -1; i <= 1; i++) {\r\ntemp = speed / (pixval+i);\r\npr_debug("DIU test pixval i=%d, pixval=%lu, temp freq. = %u\n",\r\ni, pixval, temp);\r\nif ((temp < minpixclock) || (temp > maxpixclock))\r\npr_debug("DIU exceeds monitor range (%lu to %lu)\n",\r\nminpixclock, maxpixclock);\r\nelse if (abs(temp - pixclock) < err) {\r\npr_debug("Entered the else if block %d\n", i);\r\nerr = abs(temp - pixclock);\r\nbestval = pixval + i;\r\nbestfreq = temp;\r\n}\r\n}\r\npr_debug("DIU chose = %lx\n", bestval);\r\npr_debug("DIU error = %ld\n NomPixClk ", err);\r\npr_debug("DIU: Best Freq = %lx\n", bestfreq);\r\ntemp = in_be32(&ccm->scfr1);\r\npr_debug("DIU: Current value of SCFR1: 0x%08x\n", temp);\r\ntemp &= ~DIU_DIV_MASK;\r\ntemp |= (bestval & DIU_DIV_MASK);\r\nout_be32(&ccm->scfr1, temp);\r\npr_debug("DIU: Modified value of SCFR1: 0x%08x\n", temp);\r\niounmap(ccm);\r\n}\r\nenum fsl_diu_monitor_port\r\nmpc512x_valid_monitor_port(enum fsl_diu_monitor_port port)\r\n{\r\nreturn FSL_DIU_PORT_DVI;\r\n}\r\nstatic inline void mpc512x_free_bootmem(struct page *page)\r\n{\r\nBUG_ON(PageTail(page));\r\nBUG_ON(atomic_read(&page->_count) > 1);\r\nfree_reserved_page(page);\r\n}\r\nvoid mpc512x_release_bootmem(void)\r\n{\r\nunsigned long addr = diu_shared_fb.fb_phys & PAGE_MASK;\r\nunsigned long size = diu_shared_fb.fb_len;\r\nunsigned long start, end;\r\nif (diu_shared_fb.in_use) {\r\nstart = PFN_UP(addr);\r\nend = PFN_DOWN(addr + size);\r\nfor (; start < end; start++)\r\nmpc512x_free_bootmem(pfn_to_page(start));\r\ndiu_shared_fb.in_use = false;\r\n}\r\ndiu_ops.release_bootmem = NULL;\r\n}\r\nvoid __init mpc512x_init_diu(void)\r\n{\r\nstruct device_node *np;\r\nstruct diu __iomem *diu_reg;\r\nphys_addr_t desc;\r\nvoid __iomem *vaddr;\r\nunsigned long mode, pix_fmt, res, bpp;\r\nunsigned long dst;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-diu");\r\nif (!np) {\r\npr_err("No DIU node\n");\r\nreturn;\r\n}\r\ndiu_reg = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!diu_reg) {\r\npr_err("Can't map DIU\n");\r\nreturn;\r\n}\r\nmode = in_be32(&diu_reg->diu_mode);\r\nif (mode == MFB_MODE0) {\r\npr_info("%s: DIU OFF\n", __func__);\r\ngoto out;\r\n}\r\ndesc = in_be32(&diu_reg->desc[0]);\r\nvaddr = ioremap(desc, sizeof(struct diu_ad));\r\nif (!vaddr) {\r\npr_err("Can't map DIU area desc.\n");\r\ngoto out;\r\n}\r\nmemcpy(&diu_shared_fb.ad0, vaddr, sizeof(struct diu_ad));\r\ndst = (unsigned long)&diu_shared_fb.ad0;\r\nflush_dcache_range(dst, dst + sizeof(struct diu_ad) - 1);\r\nres = in_be32(&diu_reg->disp_size);\r\npix_fmt = in_le32(vaddr);\r\nbpp = ((pix_fmt >> 16) & 0x3) + 1;\r\ndiu_shared_fb.fb_phys = in_le32(vaddr + 4);\r\ndiu_shared_fb.fb_len = ((res & 0xfff0000) >> 16) * (res & 0xfff) * bpp;\r\ndiu_shared_fb.in_use = true;\r\niounmap(vaddr);\r\ndesc = in_be32(&diu_reg->gamma);\r\nvaddr = ioremap(desc, sizeof(diu_shared_fb.gamma));\r\nif (!vaddr) {\r\npr_err("Can't map DIU area desc.\n");\r\ndiu_shared_fb.in_use = false;\r\ngoto out;\r\n}\r\nmemcpy(&diu_shared_fb.gamma, vaddr, sizeof(diu_shared_fb.gamma));\r\ndst = (unsigned long)&diu_shared_fb.gamma;\r\nflush_dcache_range(dst, dst + sizeof(diu_shared_fb.gamma) - 1);\r\niounmap(vaddr);\r\nout_be32(&diu_reg->gamma, virt_to_phys(&diu_shared_fb.gamma));\r\nout_be32(&diu_reg->desc[1], 0);\r\nout_be32(&diu_reg->desc[2], 0);\r\nout_be32(&diu_reg->desc[0], virt_to_phys(&diu_shared_fb.ad0));\r\nout:\r\niounmap(diu_reg);\r\n}\r\nvoid __init mpc512x_setup_diu(void)\r\n{\r\nint ret;\r\nif (diu_shared_fb.in_use) {\r\nret = reserve_bootmem(diu_shared_fb.fb_phys,\r\ndiu_shared_fb.fb_len,\r\nBOOTMEM_EXCLUSIVE);\r\nif (ret) {\r\npr_err("%s: reserve bootmem failed\n", __func__);\r\ndiu_shared_fb.in_use = false;\r\n}\r\n}\r\ndiu_ops.set_pixel_clock = mpc512x_set_pixel_clock;\r\ndiu_ops.valid_monitor_port = mpc512x_valid_monitor_port;\r\ndiu_ops.release_bootmem = mpc512x_release_bootmem;\r\n}\r\nvoid __init mpc512x_init_IRQ(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-ipic");\r\nif (!np)\r\nreturn;\r\nipic_init(np, 0);\r\nof_node_put(np);\r\nipic_set_default_priority();\r\n}\r\nvoid __init mpc512x_declare_of_platform_devices(void)\r\n{\r\nif (of_platform_bus_probe(NULL, of_bus_ids, NULL))\r\nprintk(KERN_ERR __FILE__ ": "\r\n"Error while probing of_platform bus\n");\r\n}\r\nconst char *mpc512x_select_psc_compat(void)\r\n{\r\nif (of_machine_is_compatible("fsl,mpc5121"))\r\nreturn "fsl,mpc5121-psc";\r\nif (of_machine_is_compatible("fsl,mpc5125"))\r\nreturn "fsl,mpc5125-psc";\r\nreturn NULL;\r\n}\r\nconst char *mpc512x_select_reset_compat(void)\r\n{\r\nif (of_machine_is_compatible("fsl,mpc5121"))\r\nreturn "fsl,mpc5121-reset";\r\nif (of_machine_is_compatible("fsl,mpc5125"))\r\nreturn "fsl,mpc5125-reset";\r\nreturn NULL;\r\n}\r\nstatic unsigned int __init get_fifo_size(struct device_node *np,\r\nchar *prop_name)\r\n{\r\nconst unsigned int *fp;\r\nfp = of_get_property(np, prop_name, NULL);\r\nif (fp)\r\nreturn *fp;\r\npr_warning("no %s property in %s node, defaulting to %d\n",\r\nprop_name, np->full_name, DEFAULT_FIFO_SIZE);\r\nreturn DEFAULT_FIFO_SIZE;\r\n}\r\nvoid __init mpc512x_psc_fifo_init(void)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *psc;\r\nunsigned int tx_fifo_size;\r\nunsigned int rx_fifo_size;\r\nconst char *psc_compat;\r\nint fifobase = 0;\r\npsc_compat = mpc512x_select_psc_compat();\r\nif (!psc_compat) {\r\npr_err("%s: no compatible devices found\n", __func__);\r\nreturn;\r\n}\r\nfor_each_compatible_node(np, NULL, psc_compat) {\r\ntx_fifo_size = get_fifo_size(np, "fsl,tx-fifo-size");\r\nrx_fifo_size = get_fifo_size(np, "fsl,rx-fifo-size");\r\ntx_fifo_size /= 4;\r\nrx_fifo_size /= 4;\r\nif (!tx_fifo_size)\r\ntx_fifo_size = 1;\r\nif (!rx_fifo_size)\r\nrx_fifo_size = 1;\r\npsc = of_iomap(np, 0);\r\nif (!psc) {\r\npr_err("%s: Can't map %s device\n",\r\n__func__, np->full_name);\r\ncontinue;\r\n}\r\nif ((fifobase + tx_fifo_size + rx_fifo_size) > 0x1000) {\r\npr_err("%s: no fifo space available for %s\n",\r\n__func__, np->full_name);\r\niounmap(psc);\r\ncontinue;\r\n}\r\nout_be32(&FIFOC(psc)->txsz, (fifobase << 16) | tx_fifo_size);\r\nfifobase += tx_fifo_size;\r\nout_be32(&FIFOC(psc)->rxsz, (fifobase << 16) | rx_fifo_size);\r\nfifobase += rx_fifo_size;\r\nout_be32(&FIFOC(psc)->txcmd, 0x80);\r\nout_be32(&FIFOC(psc)->txcmd, 0x01);\r\nout_be32(&FIFOC(psc)->rxcmd, 0x80);\r\nout_be32(&FIFOC(psc)->rxcmd, 0x01);\r\niounmap(psc);\r\n}\r\n}\r\nvoid __init mpc512x_init_early(void)\r\n{\r\nmpc512x_restart_init();\r\nif (IS_ENABLED(CONFIG_FB_FSL_DIU))\r\nmpc512x_init_diu();\r\n}\r\nvoid __init mpc512x_init(void)\r\n{\r\nmpc5121_clk_init();\r\nmpc512x_declare_of_platform_devices();\r\nmpc512x_psc_fifo_init();\r\n}\r\nvoid __init mpc512x_setup_arch(void)\r\n{\r\nif (IS_ENABLED(CONFIG_FB_FSL_DIU))\r\nmpc512x_setup_diu();\r\n}\r\nint mpc512x_cs_config(unsigned int cs, u32 val)\r\n{\r\nstatic struct mpc512x_lpc __iomem *lpc;\r\nstruct device_node *np;\r\nif (cs > 7)\r\nreturn -EINVAL;\r\nif (!lpc) {\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-lpc");\r\nlpc = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!lpc)\r\nreturn -ENOMEM;\r\n}\r\nout_be32(&lpc->cs_cfg[cs], val);\r\nreturn 0;\r\n}
