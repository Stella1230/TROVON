static inline u32 u32_field_get(const u8 *preq_elem, int offset, bool ae)\r\n{\r\nif (ae)\r\noffset += 6;\r\nreturn get_unaligned_le32(preq_elem + offset);\r\n}\r\nstatic inline u32 u16_field_get(const u8 *preq_elem, int offset, bool ae)\r\n{\r\nif (ae)\r\noffset += 6;\r\nreturn get_unaligned_le16(preq_elem + offset);\r\n}\r\nstatic int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,\r\nconst u8 *orig_addr, __le32 orig_sn,\r\nu8 target_flags, const u8 *target,\r\n__le32 target_sn, const u8 *da,\r\nu8 hop_count, u8 ttl,\r\n__le32 lifetime, __le32 metric,\r\n__le32 preq_id,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_mgmt *mgmt;\r\nu8 *pos, ie_len;\r\nint hdr_len = offsetof(struct ieee80211_mgmt, u.action.u.mesh_action) +\r\nsizeof(mgmt->u.action.u.mesh_action);\r\nskb = dev_alloc_skb(local->tx_headroom +\r\nhdr_len +\r\n2 + 37);\r\nif (!skb)\r\nreturn -1;\r\nskb_reserve(skb, local->tx_headroom);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);\r\nmemset(mgmt, 0, hdr_len);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nmemcpy(mgmt->da, da, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nmgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;\r\nmgmt->u.action.u.mesh_action.action_code =\r\nWLAN_MESH_ACTION_HWMP_PATH_SELECTION;\r\nswitch (action) {\r\ncase MPATH_PREQ:\r\nmhwmp_dbg(sdata, "sending PREQ to %pM\n", target);\r\nie_len = 37;\r\npos = skb_put(skb, 2 + ie_len);\r\n*pos++ = WLAN_EID_PREQ;\r\nbreak;\r\ncase MPATH_PREP:\r\nmhwmp_dbg(sdata, "sending PREP to %pM\n", orig_addr);\r\nie_len = 31;\r\npos = skb_put(skb, 2 + ie_len);\r\n*pos++ = WLAN_EID_PREP;\r\nbreak;\r\ncase MPATH_RANN:\r\nmhwmp_dbg(sdata, "sending RANN from %pM\n", orig_addr);\r\nie_len = sizeof(struct ieee80211_rann_ie);\r\npos = skb_put(skb, 2 + ie_len);\r\n*pos++ = WLAN_EID_RANN;\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\nreturn -ENOTSUPP;\r\nbreak;\r\n}\r\n*pos++ = ie_len;\r\n*pos++ = flags;\r\n*pos++ = hop_count;\r\n*pos++ = ttl;\r\nif (action == MPATH_PREP) {\r\nmemcpy(pos, target, ETH_ALEN);\r\npos += ETH_ALEN;\r\nmemcpy(pos, &target_sn, 4);\r\npos += 4;\r\n} else {\r\nif (action == MPATH_PREQ) {\r\nmemcpy(pos, &preq_id, 4);\r\npos += 4;\r\n}\r\nmemcpy(pos, orig_addr, ETH_ALEN);\r\npos += ETH_ALEN;\r\nmemcpy(pos, &orig_sn, 4);\r\npos += 4;\r\n}\r\nmemcpy(pos, &lifetime, 4);\r\npos += 4;\r\nmemcpy(pos, &metric, 4);\r\npos += 4;\r\nif (action == MPATH_PREQ) {\r\n*pos++ = 1;\r\n*pos++ = target_flags;\r\nmemcpy(pos, target, ETH_ALEN);\r\npos += ETH_ALEN;\r\nmemcpy(pos, &target_sn, 4);\r\npos += 4;\r\n} else if (action == MPATH_PREP) {\r\nmemcpy(pos, orig_addr, ETH_ALEN);\r\npos += ETH_ALEN;\r\nmemcpy(pos, &orig_sn, 4);\r\npos += 4;\r\n}\r\nieee80211_tx_skb(sdata, skb);\r\nreturn 0;\r\n}\r\nstatic void prepare_frame_for_deferred_tx(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nskb_set_mac_header(skb, 0);\r\nskb_set_network_header(skb, 0);\r\nskb_set_transport_header(skb, 0);\r\nskb_set_queue_mapping(skb, IEEE80211_AC_VO);\r\nskb->priority = 7;\r\ninfo->control.vif = &sdata->vif;\r\ninfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\r\nieee80211_set_qos_hdr(sdata, skb);\r\nieee80211_mps_set_frame_flags(sdata, NULL, hdr);\r\n}\r\nint mesh_path_error_tx(struct ieee80211_sub_if_data *sdata,\r\nu8 ttl, const u8 *target, __le32 target_sn,\r\n__le16 target_rcode, const u8 *ra)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_mgmt *mgmt;\r\nu8 *pos, ie_len;\r\nint hdr_len = offsetof(struct ieee80211_mgmt, u.action.u.mesh_action) +\r\nsizeof(mgmt->u.action.u.mesh_action);\r\nif (time_before(jiffies, ifmsh->next_perr))\r\nreturn -EAGAIN;\r\nskb = dev_alloc_skb(local->tx_headroom +\r\nIEEE80211_ENCRYPT_HEADROOM +\r\nIEEE80211_ENCRYPT_TAILROOM +\r\nhdr_len +\r\n2 + 15 );\r\nif (!skb)\r\nreturn -1;\r\nskb_reserve(skb, local->tx_headroom + IEEE80211_ENCRYPT_HEADROOM);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);\r\nmemset(mgmt, 0, hdr_len);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nmemcpy(mgmt->da, ra, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nmgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;\r\nmgmt->u.action.u.mesh_action.action_code =\r\nWLAN_MESH_ACTION_HWMP_PATH_SELECTION;\r\nie_len = 15;\r\npos = skb_put(skb, 2 + ie_len);\r\n*pos++ = WLAN_EID_PERR;\r\n*pos++ = ie_len;\r\n*pos++ = ttl;\r\n*pos++ = 1;\r\n*pos = 0;\r\nif (!target_sn)\r\n*pos |= MP_F_USN;\r\nif (target_rcode)\r\n*pos |= MP_F_RCODE;\r\npos++;\r\nmemcpy(pos, target, ETH_ALEN);\r\npos += ETH_ALEN;\r\nmemcpy(pos, &target_sn, 4);\r\npos += 4;\r\nmemcpy(pos, &target_rcode, 2);\r\nprepare_frame_for_deferred_tx(sdata, skb);\r\nifmsh->next_perr = TU_TO_EXP_TIME(\r\nifmsh->mshcfg.dot11MeshHWMPperrMinInterval);\r\nieee80211_add_pending_skb(local, skb);\r\nreturn 0;\r\n}\r\nvoid ieee80211s_update_metric(struct ieee80211_local *local,\r\nstruct sta_info *sta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *txinfo = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nint failed;\r\nif (!ieee80211_is_data(hdr->frame_control))\r\nreturn;\r\nfailed = !(txinfo->flags & IEEE80211_TX_STAT_ACK);\r\nsta->fail_avg = ((80 * sta->fail_avg + 5) / 100 + 20 * failed);\r\nif (sta->fail_avg > 95)\r\nmesh_plink_broken(sta);\r\n}\r\nstatic u32 airtime_link_metric_get(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nstruct rate_info rinfo;\r\nint device_constant = 1 << ARITH_SHIFT;\r\nint test_frame_len = TEST_FRAME_LEN << ARITH_SHIFT;\r\nint s_unit = 1 << ARITH_SHIFT;\r\nint rate, err;\r\nu32 tx_time, estimated_retx;\r\nu64 result;\r\nif (sta->fail_avg >= 100)\r\nreturn MAX_METRIC;\r\nsta_set_rate_info_tx(sta, &sta->last_tx_rate, &rinfo);\r\nrate = cfg80211_calculate_bitrate(&rinfo);\r\nif (WARN_ON(!rate))\r\nreturn MAX_METRIC;\r\nerr = (sta->fail_avg << ARITH_SHIFT) / 100;\r\ntx_time = (device_constant + 10 * test_frame_len / rate);\r\nestimated_retx = ((1 << (2 * ARITH_SHIFT)) / (s_unit - err));\r\nresult = (tx_time * estimated_retx) >> (2 * ARITH_SHIFT) ;\r\nreturn (u32)result;\r\n}\r\nstatic u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nconst u8 *hwmp_ie, enum mpath_frame_type action)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct mesh_path *mpath;\r\nstruct sta_info *sta;\r\nbool fresh_info;\r\nconst u8 *orig_addr, *ta;\r\nu32 orig_sn, orig_metric;\r\nunsigned long orig_lifetime, exp_time;\r\nu32 last_hop_metric, new_metric;\r\nbool process = true;\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, mgmt->sa);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nlast_hop_metric = airtime_link_metric_get(local, sta);\r\nfresh_info = true;\r\nswitch (action) {\r\ncase MPATH_PREQ:\r\norig_addr = PREQ_IE_ORIG_ADDR(hwmp_ie);\r\norig_sn = PREQ_IE_ORIG_SN(hwmp_ie);\r\norig_lifetime = PREQ_IE_LIFETIME(hwmp_ie);\r\norig_metric = PREQ_IE_METRIC(hwmp_ie);\r\nbreak;\r\ncase MPATH_PREP:\r\norig_addr = PREP_IE_TARGET_ADDR(hwmp_ie);\r\norig_sn = PREP_IE_TARGET_SN(hwmp_ie);\r\norig_lifetime = PREP_IE_LIFETIME(hwmp_ie);\r\norig_metric = PREP_IE_METRIC(hwmp_ie);\r\nbreak;\r\ndefault:\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nnew_metric = orig_metric + last_hop_metric;\r\nif (new_metric < orig_metric)\r\nnew_metric = MAX_METRIC;\r\nexp_time = TU_TO_EXP_TIME(orig_lifetime);\r\nif (ether_addr_equal(orig_addr, sdata->vif.addr)) {\r\nprocess = false;\r\nfresh_info = false;\r\n} else {\r\nmpath = mesh_path_lookup(sdata, orig_addr);\r\nif (mpath) {\r\nspin_lock_bh(&mpath->state_lock);\r\nif (mpath->flags & MESH_PATH_FIXED)\r\nfresh_info = false;\r\nelse if ((mpath->flags & MESH_PATH_ACTIVE) &&\r\n(mpath->flags & MESH_PATH_SN_VALID)) {\r\nif (SN_GT(mpath->sn, orig_sn) ||\r\n(mpath->sn == orig_sn &&\r\nnew_metric >= mpath->metric)) {\r\nprocess = false;\r\nfresh_info = false;\r\n}\r\n}\r\n} else {\r\nmpath = mesh_path_add(sdata, orig_addr);\r\nif (IS_ERR(mpath)) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nspin_lock_bh(&mpath->state_lock);\r\n}\r\nif (fresh_info) {\r\nmesh_path_assign_nexthop(mpath, sta);\r\nmpath->flags |= MESH_PATH_SN_VALID;\r\nmpath->metric = new_metric;\r\nmpath->sn = orig_sn;\r\nmpath->exp_time = time_after(mpath->exp_time, exp_time)\r\n? mpath->exp_time : exp_time;\r\nmesh_path_activate(mpath);\r\nspin_unlock_bh(&mpath->state_lock);\r\nmesh_path_tx_pending(mpath);\r\n} else\r\nspin_unlock_bh(&mpath->state_lock);\r\n}\r\nta = mgmt->sa;\r\nif (ether_addr_equal(orig_addr, ta))\r\nfresh_info = false;\r\nelse {\r\nfresh_info = true;\r\nmpath = mesh_path_lookup(sdata, ta);\r\nif (mpath) {\r\nspin_lock_bh(&mpath->state_lock);\r\nif ((mpath->flags & MESH_PATH_FIXED) ||\r\n((mpath->flags & MESH_PATH_ACTIVE) &&\r\n(last_hop_metric > mpath->metric)))\r\nfresh_info = false;\r\n} else {\r\nmpath = mesh_path_add(sdata, ta);\r\nif (IS_ERR(mpath)) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nspin_lock_bh(&mpath->state_lock);\r\n}\r\nif (fresh_info) {\r\nmesh_path_assign_nexthop(mpath, sta);\r\nmpath->metric = last_hop_metric;\r\nmpath->exp_time = time_after(mpath->exp_time, exp_time)\r\n? mpath->exp_time : exp_time;\r\nmesh_path_activate(mpath);\r\nspin_unlock_bh(&mpath->state_lock);\r\nmesh_path_tx_pending(mpath);\r\n} else\r\nspin_unlock_bh(&mpath->state_lock);\r\n}\r\nrcu_read_unlock();\r\nreturn process ? new_metric : 0;\r\n}\r\nstatic void hwmp_preq_frame_process(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nconst u8 *preq_elem, u32 metric)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_path *mpath = NULL;\r\nconst u8 *target_addr, *orig_addr;\r\nconst u8 *da;\r\nu8 target_flags, ttl, flags;\r\nu32 orig_sn, target_sn, lifetime, orig_metric;\r\nbool reply = false;\r\nbool forward = true;\r\nbool root_is_gate;\r\ntarget_addr = PREQ_IE_TARGET_ADDR(preq_elem);\r\norig_addr = PREQ_IE_ORIG_ADDR(preq_elem);\r\ntarget_sn = PREQ_IE_TARGET_SN(preq_elem);\r\norig_sn = PREQ_IE_ORIG_SN(preq_elem);\r\ntarget_flags = PREQ_IE_TARGET_F(preq_elem);\r\norig_metric = metric;\r\nflags = PREQ_IE_FLAGS(preq_elem);\r\nroot_is_gate = !!(flags & RANN_FLAG_IS_GATE);\r\nmhwmp_dbg(sdata, "received PREQ from %pM\n", orig_addr);\r\nif (ether_addr_equal(target_addr, sdata->vif.addr)) {\r\nmhwmp_dbg(sdata, "PREQ is for us\n");\r\nforward = false;\r\nreply = true;\r\nmetric = 0;\r\nif (time_after(jiffies, ifmsh->last_sn_update +\r\nnet_traversal_jiffies(sdata)) ||\r\ntime_before(jiffies, ifmsh->last_sn_update)) {\r\ntarget_sn = ++ifmsh->sn;\r\nifmsh->last_sn_update = jiffies;\r\n}\r\n} else if (is_broadcast_ether_addr(target_addr) &&\r\n(target_flags & IEEE80211_PREQ_TO_FLAG)) {\r\nrcu_read_lock();\r\nmpath = mesh_path_lookup(sdata, orig_addr);\r\nif (mpath) {\r\nif (flags & IEEE80211_PREQ_PROACTIVE_PREP_FLAG) {\r\nreply = true;\r\ntarget_addr = sdata->vif.addr;\r\ntarget_sn = ++ifmsh->sn;\r\nmetric = 0;\r\nifmsh->last_sn_update = jiffies;\r\n}\r\nif (root_is_gate)\r\nmesh_path_add_gate(mpath);\r\n}\r\nrcu_read_unlock();\r\n} else {\r\nrcu_read_lock();\r\nmpath = mesh_path_lookup(sdata, target_addr);\r\nif (mpath) {\r\nif ((!(mpath->flags & MESH_PATH_SN_VALID)) ||\r\nSN_LT(mpath->sn, target_sn)) {\r\nmpath->sn = target_sn;\r\nmpath->flags |= MESH_PATH_SN_VALID;\r\n} else if ((!(target_flags & MP_F_DO)) &&\r\n(mpath->flags & MESH_PATH_ACTIVE)) {\r\nreply = true;\r\nmetric = mpath->metric;\r\ntarget_sn = mpath->sn;\r\nif (target_flags & MP_F_RF)\r\ntarget_flags |= MP_F_DO;\r\nelse\r\nforward = false;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (reply) {\r\nlifetime = PREQ_IE_LIFETIME(preq_elem);\r\nttl = ifmsh->mshcfg.element_ttl;\r\nif (ttl != 0) {\r\nmhwmp_dbg(sdata, "replying to the PREQ\n");\r\nmesh_path_sel_frame_tx(MPATH_PREP, 0, orig_addr,\r\ncpu_to_le32(orig_sn), 0, target_addr,\r\ncpu_to_le32(target_sn), mgmt->sa, 0, ttl,\r\ncpu_to_le32(lifetime), cpu_to_le32(metric),\r\n0, sdata);\r\n} else {\r\nifmsh->mshstats.dropped_frames_ttl++;\r\n}\r\n}\r\nif (forward && ifmsh->mshcfg.dot11MeshForwarding) {\r\nu32 preq_id;\r\nu8 hopcount;\r\nttl = PREQ_IE_TTL(preq_elem);\r\nlifetime = PREQ_IE_LIFETIME(preq_elem);\r\nif (ttl <= 1) {\r\nifmsh->mshstats.dropped_frames_ttl++;\r\nreturn;\r\n}\r\nmhwmp_dbg(sdata, "forwarding the PREQ from %pM\n", orig_addr);\r\n--ttl;\r\npreq_id = PREQ_IE_PREQ_ID(preq_elem);\r\nhopcount = PREQ_IE_HOPCOUNT(preq_elem) + 1;\r\nda = (mpath && mpath->is_root) ?\r\nmpath->rann_snd_addr : broadcast_addr;\r\nif (flags & IEEE80211_PREQ_PROACTIVE_PREP_FLAG) {\r\ntarget_addr = PREQ_IE_TARGET_ADDR(preq_elem);\r\ntarget_sn = PREQ_IE_TARGET_SN(preq_elem);\r\nmetric = orig_metric;\r\n}\r\nmesh_path_sel_frame_tx(MPATH_PREQ, flags, orig_addr,\r\ncpu_to_le32(orig_sn), target_flags, target_addr,\r\ncpu_to_le32(target_sn), da,\r\nhopcount, ttl, cpu_to_le32(lifetime),\r\ncpu_to_le32(metric), cpu_to_le32(preq_id),\r\nsdata);\r\nif (!is_multicast_ether_addr(da))\r\nifmsh->mshstats.fwded_unicast++;\r\nelse\r\nifmsh->mshstats.fwded_mcast++;\r\nifmsh->mshstats.fwded_frames++;\r\n}\r\n}\r\nstatic inline struct sta_info *\r\nnext_hop_deref_protected(struct mesh_path *mpath)\r\n{\r\nreturn rcu_dereference_protected(mpath->next_hop,\r\nlockdep_is_held(&mpath->state_lock));\r\n}\r\nstatic void hwmp_prep_frame_process(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nconst u8 *prep_elem, u32 metric)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_path *mpath;\r\nconst u8 *target_addr, *orig_addr;\r\nu8 ttl, hopcount, flags;\r\nu8 next_hop[ETH_ALEN];\r\nu32 target_sn, orig_sn, lifetime;\r\nmhwmp_dbg(sdata, "received PREP from %pM\n",\r\nPREP_IE_TARGET_ADDR(prep_elem));\r\norig_addr = PREP_IE_ORIG_ADDR(prep_elem);\r\nif (ether_addr_equal(orig_addr, sdata->vif.addr))\r\nreturn;\r\nif (!ifmsh->mshcfg.dot11MeshForwarding)\r\nreturn;\r\nttl = PREP_IE_TTL(prep_elem);\r\nif (ttl <= 1) {\r\nsdata->u.mesh.mshstats.dropped_frames_ttl++;\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nmpath = mesh_path_lookup(sdata, orig_addr);\r\nif (mpath)\r\nspin_lock_bh(&mpath->state_lock);\r\nelse\r\ngoto fail;\r\nif (!(mpath->flags & MESH_PATH_ACTIVE)) {\r\nspin_unlock_bh(&mpath->state_lock);\r\ngoto fail;\r\n}\r\nmemcpy(next_hop, next_hop_deref_protected(mpath)->sta.addr, ETH_ALEN);\r\nspin_unlock_bh(&mpath->state_lock);\r\n--ttl;\r\nflags = PREP_IE_FLAGS(prep_elem);\r\nlifetime = PREP_IE_LIFETIME(prep_elem);\r\nhopcount = PREP_IE_HOPCOUNT(prep_elem) + 1;\r\ntarget_addr = PREP_IE_TARGET_ADDR(prep_elem);\r\ntarget_sn = PREP_IE_TARGET_SN(prep_elem);\r\norig_sn = PREP_IE_ORIG_SN(prep_elem);\r\nmesh_path_sel_frame_tx(MPATH_PREP, flags, orig_addr,\r\ncpu_to_le32(orig_sn), 0, target_addr,\r\ncpu_to_le32(target_sn), next_hop, hopcount,\r\nttl, cpu_to_le32(lifetime), cpu_to_le32(metric),\r\n0, sdata);\r\nrcu_read_unlock();\r\nsdata->u.mesh.mshstats.fwded_unicast++;\r\nsdata->u.mesh.mshstats.fwded_frames++;\r\nreturn;\r\nfail:\r\nrcu_read_unlock();\r\nsdata->u.mesh.mshstats.dropped_frames_no_route++;\r\n}\r\nstatic void hwmp_perr_frame_process(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nconst u8 *perr_elem)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_path *mpath;\r\nu8 ttl;\r\nconst u8 *ta, *target_addr;\r\nu32 target_sn;\r\nu16 target_rcode;\r\nta = mgmt->sa;\r\nttl = PERR_IE_TTL(perr_elem);\r\nif (ttl <= 1) {\r\nifmsh->mshstats.dropped_frames_ttl++;\r\nreturn;\r\n}\r\nttl--;\r\ntarget_addr = PERR_IE_TARGET_ADDR(perr_elem);\r\ntarget_sn = PERR_IE_TARGET_SN(perr_elem);\r\ntarget_rcode = PERR_IE_TARGET_RCODE(perr_elem);\r\nrcu_read_lock();\r\nmpath = mesh_path_lookup(sdata, target_addr);\r\nif (mpath) {\r\nstruct sta_info *sta;\r\nspin_lock_bh(&mpath->state_lock);\r\nsta = next_hop_deref_protected(mpath);\r\nif (mpath->flags & MESH_PATH_ACTIVE &&\r\nether_addr_equal(ta, sta->sta.addr) &&\r\n(!(mpath->flags & MESH_PATH_SN_VALID) ||\r\nSN_GT(target_sn, mpath->sn))) {\r\nmpath->flags &= ~MESH_PATH_ACTIVE;\r\nmpath->sn = target_sn;\r\nspin_unlock_bh(&mpath->state_lock);\r\nif (!ifmsh->mshcfg.dot11MeshForwarding)\r\ngoto endperr;\r\nmesh_path_error_tx(sdata, ttl, target_addr,\r\ncpu_to_le32(target_sn),\r\ncpu_to_le16(target_rcode),\r\nbroadcast_addr);\r\n} else\r\nspin_unlock_bh(&mpath->state_lock);\r\n}\r\nendperr:\r\nrcu_read_unlock();\r\n}\r\nstatic void hwmp_rann_frame_process(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nconst struct ieee80211_rann_ie *rann)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nstruct mesh_path *mpath;\r\nu8 ttl, flags, hopcount;\r\nconst u8 *orig_addr;\r\nu32 orig_sn, metric, metric_txsta, interval;\r\nbool root_is_gate;\r\nttl = rann->rann_ttl;\r\nflags = rann->rann_flags;\r\nroot_is_gate = !!(flags & RANN_FLAG_IS_GATE);\r\norig_addr = rann->rann_addr;\r\norig_sn = le32_to_cpu(rann->rann_seq);\r\ninterval = le32_to_cpu(rann->rann_interval);\r\nhopcount = rann->rann_hopcount;\r\nhopcount++;\r\nmetric = le32_to_cpu(rann->rann_metric);\r\nif (ether_addr_equal(orig_addr, sdata->vif.addr))\r\nreturn;\r\nmhwmp_dbg(sdata,\r\n"received RANN from %pM via neighbour %pM (is_gate=%d)\n",\r\norig_addr, mgmt->sa, root_is_gate);\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, mgmt->sa);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nmetric_txsta = airtime_link_metric_get(local, sta);\r\nmpath = mesh_path_lookup(sdata, orig_addr);\r\nif (!mpath) {\r\nmpath = mesh_path_add(sdata, orig_addr);\r\nif (IS_ERR(mpath)) {\r\nrcu_read_unlock();\r\nsdata->u.mesh.mshstats.dropped_frames_no_route++;\r\nreturn;\r\n}\r\n}\r\nif (!(SN_LT(mpath->sn, orig_sn)) &&\r\n!(mpath->sn == orig_sn && metric < mpath->rann_metric)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif ((!(mpath->flags & (MESH_PATH_ACTIVE | MESH_PATH_RESOLVING)) ||\r\n(time_after(jiffies, mpath->last_preq_to_root +\r\nroot_path_confirmation_jiffies(sdata)) ||\r\ntime_before(jiffies, mpath->last_preq_to_root))) &&\r\n!(mpath->flags & MESH_PATH_FIXED) && (ttl != 0)) {\r\nmhwmp_dbg(sdata,\r\n"time to refresh root mpath %pM\n",\r\norig_addr);\r\nmesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);\r\nmpath->last_preq_to_root = jiffies;\r\n}\r\nmpath->sn = orig_sn;\r\nmpath->rann_metric = metric + metric_txsta;\r\nmpath->is_root = true;\r\nmemcpy(mpath->rann_snd_addr, mgmt->sa, ETH_ALEN);\r\nif (root_is_gate)\r\nmesh_path_add_gate(mpath);\r\nif (ttl <= 1) {\r\nifmsh->mshstats.dropped_frames_ttl++;\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nttl--;\r\nif (ifmsh->mshcfg.dot11MeshForwarding) {\r\nmesh_path_sel_frame_tx(MPATH_RANN, flags, orig_addr,\r\ncpu_to_le32(orig_sn),\r\n0, NULL, 0, broadcast_addr,\r\nhopcount, ttl, cpu_to_le32(interval),\r\ncpu_to_le32(metric + metric_txsta),\r\n0, sdata);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid mesh_rx_path_sel_frame(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt, size_t len)\r\n{\r\nstruct ieee802_11_elems elems;\r\nsize_t baselen;\r\nu32 last_hop_metric;\r\nstruct sta_info *sta;\r\nif (len < IEEE80211_MIN_ACTION_SIZE + 1)\r\nreturn;\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, mgmt->sa);\r\nif (!sta || sta->plink_state != NL80211_PLINK_ESTAB) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\nbaselen = (u8 *) mgmt->u.action.u.mesh_action.variable - (u8 *) mgmt;\r\nieee802_11_parse_elems(mgmt->u.action.u.mesh_action.variable,\r\nlen - baselen, false, &elems);\r\nif (elems.preq) {\r\nif (elems.preq_len != 37)\r\nreturn;\r\nlast_hop_metric = hwmp_route_info_get(sdata, mgmt, elems.preq,\r\nMPATH_PREQ);\r\nif (last_hop_metric)\r\nhwmp_preq_frame_process(sdata, mgmt, elems.preq,\r\nlast_hop_metric);\r\n}\r\nif (elems.prep) {\r\nif (elems.prep_len != 31)\r\nreturn;\r\nlast_hop_metric = hwmp_route_info_get(sdata, mgmt, elems.prep,\r\nMPATH_PREP);\r\nif (last_hop_metric)\r\nhwmp_prep_frame_process(sdata, mgmt, elems.prep,\r\nlast_hop_metric);\r\n}\r\nif (elems.perr) {\r\nif (elems.perr_len != 15)\r\nreturn;\r\nhwmp_perr_frame_process(sdata, mgmt, elems.perr);\r\n}\r\nif (elems.rann)\r\nhwmp_rann_frame_process(sdata, mgmt, elems.rann);\r\n}\r\nstatic void mesh_queue_preq(struct mesh_path *mpath, u8 flags)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = mpath->sdata;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_preq_queue *preq_node;\r\npreq_node = kmalloc(sizeof(struct mesh_preq_queue), GFP_ATOMIC);\r\nif (!preq_node) {\r\nmhwmp_dbg(sdata, "could not allocate PREQ node\n");\r\nreturn;\r\n}\r\nspin_lock_bh(&ifmsh->mesh_preq_queue_lock);\r\nif (ifmsh->preq_queue_len == MAX_PREQ_QUEUE_LEN) {\r\nspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\r\nkfree(preq_node);\r\nif (printk_ratelimit())\r\nmhwmp_dbg(sdata, "PREQ node queue full\n");\r\nreturn;\r\n}\r\nspin_lock(&mpath->state_lock);\r\nif (mpath->flags & MESH_PATH_REQ_QUEUED) {\r\nspin_unlock(&mpath->state_lock);\r\nspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\r\nkfree(preq_node);\r\nreturn;\r\n}\r\nmemcpy(preq_node->dst, mpath->dst, ETH_ALEN);\r\npreq_node->flags = flags;\r\nmpath->flags |= MESH_PATH_REQ_QUEUED;\r\nspin_unlock(&mpath->state_lock);\r\nlist_add_tail(&preq_node->list, &ifmsh->preq_queue.list);\r\n++ifmsh->preq_queue_len;\r\nspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\r\nif (time_after(jiffies, ifmsh->last_preq + min_preq_int_jiff(sdata)))\r\nieee80211_queue_work(&sdata->local->hw, &sdata->work);\r\nelse if (time_before(jiffies, ifmsh->last_preq)) {\r\nifmsh->last_preq = jiffies - min_preq_int_jiff(sdata) - 1;\r\nieee80211_queue_work(&sdata->local->hw, &sdata->work);\r\n} else\r\nmod_timer(&ifmsh->mesh_path_timer, ifmsh->last_preq +\r\nmin_preq_int_jiff(sdata));\r\n}\r\nvoid mesh_path_start_discovery(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_preq_queue *preq_node;\r\nstruct mesh_path *mpath;\r\nu8 ttl, target_flags;\r\nconst u8 *da;\r\nu32 lifetime;\r\nspin_lock_bh(&ifmsh->mesh_preq_queue_lock);\r\nif (!ifmsh->preq_queue_len ||\r\ntime_before(jiffies, ifmsh->last_preq +\r\nmin_preq_int_jiff(sdata))) {\r\nspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\r\nreturn;\r\n}\r\npreq_node = list_first_entry(&ifmsh->preq_queue.list,\r\nstruct mesh_preq_queue, list);\r\nlist_del(&preq_node->list);\r\n--ifmsh->preq_queue_len;\r\nspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\r\nrcu_read_lock();\r\nmpath = mesh_path_lookup(sdata, preq_node->dst);\r\nif (!mpath)\r\ngoto enddiscovery;\r\nspin_lock_bh(&mpath->state_lock);\r\nmpath->flags &= ~MESH_PATH_REQ_QUEUED;\r\nif (preq_node->flags & PREQ_Q_F_START) {\r\nif (mpath->flags & MESH_PATH_RESOLVING) {\r\nspin_unlock_bh(&mpath->state_lock);\r\ngoto enddiscovery;\r\n} else {\r\nmpath->flags &= ~MESH_PATH_RESOLVED;\r\nmpath->flags |= MESH_PATH_RESOLVING;\r\nmpath->discovery_retries = 0;\r\nmpath->discovery_timeout = disc_timeout_jiff(sdata);\r\n}\r\n} else if (!(mpath->flags & MESH_PATH_RESOLVING) ||\r\nmpath->flags & MESH_PATH_RESOLVED) {\r\nmpath->flags &= ~MESH_PATH_RESOLVING;\r\nspin_unlock_bh(&mpath->state_lock);\r\ngoto enddiscovery;\r\n}\r\nifmsh->last_preq = jiffies;\r\nif (time_after(jiffies, ifmsh->last_sn_update +\r\nnet_traversal_jiffies(sdata)) ||\r\ntime_before(jiffies, ifmsh->last_sn_update)) {\r\n++ifmsh->sn;\r\nsdata->u.mesh.last_sn_update = jiffies;\r\n}\r\nlifetime = default_lifetime(sdata);\r\nttl = sdata->u.mesh.mshcfg.element_ttl;\r\nif (ttl == 0) {\r\nsdata->u.mesh.mshstats.dropped_frames_ttl++;\r\nspin_unlock_bh(&mpath->state_lock);\r\ngoto enddiscovery;\r\n}\r\nif (preq_node->flags & PREQ_Q_F_REFRESH)\r\ntarget_flags = MP_F_DO;\r\nelse\r\ntarget_flags = MP_F_RF;\r\nspin_unlock_bh(&mpath->state_lock);\r\nda = (mpath->is_root) ? mpath->rann_snd_addr : broadcast_addr;\r\nmesh_path_sel_frame_tx(MPATH_PREQ, 0, sdata->vif.addr,\r\ncpu_to_le32(ifmsh->sn), target_flags, mpath->dst,\r\ncpu_to_le32(mpath->sn), da, 0,\r\nttl, cpu_to_le32(lifetime), 0,\r\ncpu_to_le32(ifmsh->preq_id++), sdata);\r\nmod_timer(&mpath->timer, jiffies + mpath->discovery_timeout);\r\nenddiscovery:\r\nrcu_read_unlock();\r\nkfree(preq_node);\r\n}\r\nint mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct mesh_path *mpath;\r\nstruct sk_buff *skb_to_free = NULL;\r\nu8 *target_addr = hdr->addr3;\r\nint err = 0;\r\nif (ieee80211_is_qos_nullfunc(hdr->frame_control))\r\nreturn 0;\r\nrcu_read_lock();\r\nerr = mesh_nexthop_lookup(sdata, skb);\r\nif (!err)\r\ngoto endlookup;\r\nmpath = mesh_path_lookup(sdata, target_addr);\r\nif (!mpath) {\r\nmpath = mesh_path_add(sdata, target_addr);\r\nif (IS_ERR(mpath)) {\r\nmesh_path_discard_frame(sdata, skb);\r\nerr = PTR_ERR(mpath);\r\ngoto endlookup;\r\n}\r\n}\r\nif (!(mpath->flags & MESH_PATH_RESOLVING))\r\nmesh_queue_preq(mpath, PREQ_Q_F_START);\r\nif (skb_queue_len(&mpath->frame_queue) >= MESH_FRAME_QUEUE_LEN)\r\nskb_to_free = skb_dequeue(&mpath->frame_queue);\r\ninfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\r\nieee80211_set_qos_hdr(sdata, skb);\r\nskb_queue_tail(&mpath->frame_queue, skb);\r\nerr = -ENOENT;\r\nif (skb_to_free)\r\nmesh_path_discard_frame(sdata, skb_to_free);\r\nendlookup:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mesh_path *mpath;\r\nstruct sta_info *next_hop;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nu8 *target_addr = hdr->addr3;\r\nint err = -ENOENT;\r\nrcu_read_lock();\r\nmpath = mesh_path_lookup(sdata, target_addr);\r\nif (!mpath || !(mpath->flags & MESH_PATH_ACTIVE))\r\ngoto endlookup;\r\nif (time_after(jiffies,\r\nmpath->exp_time -\r\nmsecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time)) &&\r\nether_addr_equal(sdata->vif.addr, hdr->addr4) &&\r\n!(mpath->flags & MESH_PATH_RESOLVING) &&\r\n!(mpath->flags & MESH_PATH_FIXED))\r\nmesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);\r\nnext_hop = rcu_dereference(mpath->next_hop);\r\nif (next_hop) {\r\nmemcpy(hdr->addr1, next_hop->sta.addr, ETH_ALEN);\r\nmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\r\nieee80211_mps_set_frame_flags(sdata, next_hop, hdr);\r\nerr = 0;\r\n}\r\nendlookup:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nvoid mesh_path_timer(unsigned long data)\r\n{\r\nstruct mesh_path *mpath = (void *) data;\r\nstruct ieee80211_sub_if_data *sdata = mpath->sdata;\r\nint ret;\r\nif (sdata->local->quiescing)\r\nreturn;\r\nspin_lock_bh(&mpath->state_lock);\r\nif (mpath->flags & MESH_PATH_RESOLVED ||\r\n(!(mpath->flags & MESH_PATH_RESOLVING))) {\r\nmpath->flags &= ~(MESH_PATH_RESOLVING | MESH_PATH_RESOLVED);\r\nspin_unlock_bh(&mpath->state_lock);\r\n} else if (mpath->discovery_retries < max_preq_retries(sdata)) {\r\n++mpath->discovery_retries;\r\nmpath->discovery_timeout *= 2;\r\nmpath->flags &= ~MESH_PATH_REQ_QUEUED;\r\nspin_unlock_bh(&mpath->state_lock);\r\nmesh_queue_preq(mpath, 0);\r\n} else {\r\nmpath->flags = 0;\r\nmpath->exp_time = jiffies;\r\nspin_unlock_bh(&mpath->state_lock);\r\nif (!mpath->is_gate && mesh_gate_num(sdata) > 0) {\r\nret = mesh_path_send_to_gates(mpath);\r\nif (ret)\r\nmhwmp_dbg(sdata, "no gate was reachable\n");\r\n} else\r\nmesh_path_flush_pending(mpath);\r\n}\r\n}\r\nvoid mesh_path_tx_root_frame(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu32 interval = ifmsh->mshcfg.dot11MeshHWMPRannInterval;\r\nu8 flags, target_flags = 0;\r\nflags = (ifmsh->mshcfg.dot11MeshGateAnnouncementProtocol)\r\n? RANN_FLAG_IS_GATE : 0;\r\nswitch (ifmsh->mshcfg.dot11MeshHWMPRootMode) {\r\ncase IEEE80211_PROACTIVE_RANN:\r\nmesh_path_sel_frame_tx(MPATH_RANN, flags, sdata->vif.addr,\r\ncpu_to_le32(++ifmsh->sn),\r\n0, NULL, 0, broadcast_addr,\r\n0, ifmsh->mshcfg.element_ttl,\r\ncpu_to_le32(interval), 0, 0, sdata);\r\nbreak;\r\ncase IEEE80211_PROACTIVE_PREQ_WITH_PREP:\r\nflags |= IEEE80211_PREQ_PROACTIVE_PREP_FLAG;\r\ncase IEEE80211_PROACTIVE_PREQ_NO_PREP:\r\ninterval = ifmsh->mshcfg.dot11MeshHWMPactivePathToRootTimeout;\r\ntarget_flags |= IEEE80211_PREQ_TO_FLAG |\r\nIEEE80211_PREQ_USN_FLAG;\r\nmesh_path_sel_frame_tx(MPATH_PREQ, flags, sdata->vif.addr,\r\ncpu_to_le32(++ifmsh->sn), target_flags,\r\n(u8 *) broadcast_addr, 0, broadcast_addr,\r\n0, ifmsh->mshcfg.element_ttl,\r\ncpu_to_le32(interval),\r\n0, cpu_to_le32(ifmsh->preq_id++), sdata);\r\nbreak;\r\ndefault:\r\nmhwmp_dbg(sdata, "Proactive mechanism not supported\n");\r\nreturn;\r\n}\r\n}
