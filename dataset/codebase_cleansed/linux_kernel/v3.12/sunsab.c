static __inline__ void sunsab_tec_wait(struct uart_sunsab_port *up)\r\n{\r\nint timeout = up->tec_timeout;\r\nwhile ((readb(&up->regs->r.star) & SAB82532_STAR_TEC) && --timeout)\r\nudelay(1);\r\n}\r\nstatic __inline__ void sunsab_cec_wait(struct uart_sunsab_port *up)\r\n{\r\nint timeout = up->cec_timeout;\r\nwhile ((readb(&up->regs->r.star) & SAB82532_STAR_CEC) && --timeout)\r\nudelay(1);\r\n}\r\nstatic struct tty_port *\r\nreceive_chars(struct uart_sunsab_port *up,\r\nunion sab82532_irq_status *stat)\r\n{\r\nstruct tty_port *port = NULL;\r\nunsigned char buf[32];\r\nint saw_console_brk = 0;\r\nint free_fifo = 0;\r\nint count = 0;\r\nint i;\r\nif (up->port.state != NULL)\r\nport = &up->port.state->port;\r\nif (stat->sreg.isr0 & SAB82532_ISR0_RPF) {\r\ncount = SAB82532_RECV_FIFO_SIZE;\r\nfree_fifo++;\r\n}\r\nif (stat->sreg.isr0 & SAB82532_ISR0_TCD) {\r\ncount = readb(&up->regs->r.rbcl) & (SAB82532_RECV_FIFO_SIZE - 1);\r\nfree_fifo++;\r\n}\r\nif (stat->sreg.isr0 & SAB82532_ISR0_TIME) {\r\nsunsab_cec_wait(up);\r\nwriteb(SAB82532_CMDR_RFRD, &up->regs->w.cmdr);\r\nreturn port;\r\n}\r\nif (stat->sreg.isr0 & SAB82532_ISR0_RFO)\r\nfree_fifo++;\r\nfor (i = 0; i < count; i++)\r\nbuf[i] = readb(&up->regs->r.rfifo[i]);\r\nif (free_fifo) {\r\nsunsab_cec_wait(up);\r\nwriteb(SAB82532_CMDR_RMC, &up->regs->w.cmdr);\r\n}\r\nif ((stat->sreg.isr1 & SAB82532_ISR1_BRK) &&\r\n(up->port.line == up->port.cons->index))\r\nsaw_console_brk = 1;\r\nfor (i = 0; i < count; i++) {\r\nunsigned char ch = buf[i], flag;\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (unlikely(stat->sreg.isr0 & (SAB82532_ISR0_PERR |\r\nSAB82532_ISR0_FERR |\r\nSAB82532_ISR0_RFO)) ||\r\nunlikely(stat->sreg.isr1 & SAB82532_ISR1_BRK)) {\r\nif (stat->sreg.isr1 & SAB82532_ISR1_BRK) {\r\nstat->sreg.isr0 &= ~(SAB82532_ISR0_PERR |\r\nSAB82532_ISR0_FERR);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\ncontinue;\r\n} else if (stat->sreg.isr0 & SAB82532_ISR0_PERR)\r\nup->port.icount.parity++;\r\nelse if (stat->sreg.isr0 & SAB82532_ISR0_FERR)\r\nup->port.icount.frame++;\r\nif (stat->sreg.isr0 & SAB82532_ISR0_RFO)\r\nup->port.icount.overrun++;\r\nstat->sreg.isr0 &= (up->port.read_status_mask & 0xff);\r\nstat->sreg.isr1 &= ((up->port.read_status_mask >> 8) & 0xff);\r\nif (stat->sreg.isr1 & SAB82532_ISR1_BRK) {\r\nflag = TTY_BREAK;\r\n} else if (stat->sreg.isr0 & SAB82532_ISR0_PERR)\r\nflag = TTY_PARITY;\r\nelse if (stat->sreg.isr0 & SAB82532_ISR0_FERR)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch) || !port)\r\ncontinue;\r\nif ((stat->sreg.isr0 & (up->port.ignore_status_mask & 0xff)) == 0 &&\r\n(stat->sreg.isr1 & ((up->port.ignore_status_mask >> 8) & 0xff)) == 0)\r\ntty_insert_flip_char(port, ch, flag);\r\nif (stat->sreg.isr0 & SAB82532_ISR0_RFO)\r\ntty_insert_flip_char(port, 0, TTY_OVERRUN);\r\n}\r\nif (saw_console_brk)\r\nsun_do_break();\r\nreturn port;\r\n}\r\nstatic void transmit_chars(struct uart_sunsab_port *up,\r\nunion sab82532_irq_status *stat)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint i;\r\nif (stat->sreg.isr1 & SAB82532_ISR1_ALLS) {\r\nup->interrupt_mask1 |= SAB82532_IMR1_ALLS;\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nset_bit(SAB82532_ALLS, &up->irqflags);\r\n}\r\n#if 0\r\nif (!(stat->sreg.isr1 & SAB82532_ISR1_XPR))\r\nreturn;\r\n#endif\r\nif (!(readb(&up->regs->r.star) & SAB82532_STAR_XFW))\r\nreturn;\r\nset_bit(SAB82532_XPR, &up->irqflags);\r\nsunsab_tx_idle(up);\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nup->interrupt_mask1 |= SAB82532_IMR1_XPR;\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nreturn;\r\n}\r\nup->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nclear_bit(SAB82532_ALLS, &up->irqflags);\r\nclear_bit(SAB82532_XPR, &up->irqflags);\r\nfor (i = 0; i < up->port.fifosize; i++) {\r\nwriteb(xmit->buf[xmit->tail],\r\n&up->regs->w.xfifo[i]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nsunsab_cec_wait(up);\r\nwriteb(SAB82532_CMDR_XF, &up->regs->w.cmdr);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\nsunsab_stop_tx(&up->port);\r\n}\r\nstatic void check_status(struct uart_sunsab_port *up,\r\nunion sab82532_irq_status *stat)\r\n{\r\nif (stat->sreg.isr0 & SAB82532_ISR0_CDSC)\r\nuart_handle_dcd_change(&up->port,\r\n!(readb(&up->regs->r.vstr) & SAB82532_VSTR_CD));\r\nif (stat->sreg.isr1 & SAB82532_ISR1_CSC)\r\nuart_handle_cts_change(&up->port,\r\n(readb(&up->regs->r.star) & SAB82532_STAR_CTS));\r\nif ((readb(&up->regs->r.pvr) & up->pvr_dsr_bit) ^ up->dsr) {\r\nup->dsr = (readb(&up->regs->r.pvr) & up->pvr_dsr_bit) ? 0 : 1;\r\nup->port.icount.dsr++;\r\n}\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t sunsab_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_sunsab_port *up = dev_id;\r\nstruct tty_port *port = NULL;\r\nunion sab82532_irq_status status;\r\nunsigned long flags;\r\nunsigned char gis;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nstatus.stat = 0;\r\ngis = readb(&up->regs->r.gis) >> up->gis_shift;\r\nif (gis & 1)\r\nstatus.sreg.isr0 = readb(&up->regs->r.isr0);\r\nif (gis & 2)\r\nstatus.sreg.isr1 = readb(&up->regs->r.isr1);\r\nif (status.stat) {\r\nif ((status.sreg.isr0 & (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |\r\nSAB82532_ISR0_RFO | SAB82532_ISR0_RPF)) ||\r\n(status.sreg.isr1 & SAB82532_ISR1_BRK))\r\nport = receive_chars(up, &status);\r\nif ((status.sreg.isr0 & SAB82532_ISR0_CDSC) ||\r\n(status.sreg.isr1 & SAB82532_ISR1_CSC))\r\ncheck_status(up, &status);\r\nif (status.sreg.isr1 & (SAB82532_ISR1_ALLS | SAB82532_ISR1_XPR))\r\ntransmit_chars(up, &status);\r\n}\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nif (port)\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sunsab_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nint ret;\r\nif (test_bit(SAB82532_ALLS, &up->irqflags))\r\nret = TIOCSER_TEMT;\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void sunsab_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nif (mctrl & TIOCM_RTS) {\r\nup->cached_mode &= ~SAB82532_MODE_FRTS;\r\nup->cached_mode |= SAB82532_MODE_RTS;\r\n} else {\r\nup->cached_mode |= (SAB82532_MODE_FRTS |\r\nSAB82532_MODE_RTS);\r\n}\r\nif (mctrl & TIOCM_DTR) {\r\nup->cached_pvr &= ~(up->pvr_dtr_bit);\r\n} else {\r\nup->cached_pvr |= up->pvr_dtr_bit;\r\n}\r\nset_bit(SAB82532_REGS_PENDING, &up->irqflags);\r\nif (test_bit(SAB82532_XPR, &up->irqflags))\r\nsunsab_tx_idle(up);\r\n}\r\nstatic unsigned int sunsab_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nunsigned char val;\r\nunsigned int result;\r\nresult = 0;\r\nval = readb(&up->regs->r.pvr);\r\nresult |= (val & up->pvr_dsr_bit) ? 0 : TIOCM_DSR;\r\nval = readb(&up->regs->r.vstr);\r\nresult |= (val & SAB82532_VSTR_CD) ? 0 : TIOCM_CAR;\r\nval = readb(&up->regs->r.star);\r\nresult |= (val & SAB82532_STAR_CTS) ? TIOCM_CTS : 0;\r\nreturn result;\r\n}\r\nstatic void sunsab_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nup->interrupt_mask1 |= SAB82532_IMR1_XPR;\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\n}\r\nstatic void sunsab_tx_idle(struct uart_sunsab_port *up)\r\n{\r\nif (test_bit(SAB82532_REGS_PENDING, &up->irqflags)) {\r\nu8 tmp;\r\nclear_bit(SAB82532_REGS_PENDING, &up->irqflags);\r\nwriteb(up->cached_mode, &up->regs->rw.mode);\r\nwriteb(up->cached_pvr, &up->regs->rw.pvr);\r\nwriteb(up->cached_dafo, &up->regs->w.dafo);\r\nwriteb(up->cached_ebrg & 0xff, &up->regs->w.bgr);\r\ntmp = readb(&up->regs->rw.ccr2);\r\ntmp &= ~0xc0;\r\ntmp |= (up->cached_ebrg >> 2) & 0xc0;\r\nwriteb(tmp, &up->regs->rw.ccr2);\r\n}\r\n}\r\nstatic void sunsab_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint i;\r\nup->interrupt_mask1 &= ~(SAB82532_IMR1_ALLS|SAB82532_IMR1_XPR);\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nif (!test_bit(SAB82532_XPR, &up->irqflags))\r\nreturn;\r\nclear_bit(SAB82532_ALLS, &up->irqflags);\r\nclear_bit(SAB82532_XPR, &up->irqflags);\r\nfor (i = 0; i < up->port.fifosize; i++) {\r\nwriteb(xmit->buf[xmit->tail],\r\n&up->regs->w.xfifo[i]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nsunsab_cec_wait(up);\r\nwriteb(SAB82532_CMDR_XF, &up->regs->w.cmdr);\r\n}\r\nstatic void sunsab_send_xchar(struct uart_port *port, char ch)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nsunsab_tec_wait(up);\r\nwriteb(ch, &up->regs->w.tic);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void sunsab_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nup->interrupt_mask0 |= SAB82532_IMR0_TCD;\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr0);\r\n}\r\nstatic void sunsab_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void sunsab_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nunsigned long flags;\r\nunsigned char val;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nval = up->cached_dafo;\r\nif (break_state)\r\nval |= SAB82532_DAFO_XBRK;\r\nelse\r\nval &= ~SAB82532_DAFO_XBRK;\r\nup->cached_dafo = val;\r\nset_bit(SAB82532_REGS_PENDING, &up->irqflags);\r\nif (test_bit(SAB82532_XPR, &up->irqflags))\r\nsunsab_tx_idle(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int sunsab_startup(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nunsigned long flags;\r\nunsigned char tmp;\r\nint err = request_irq(up->port.irq, sunsab_interrupt,\r\nIRQF_SHARED, "sab", up);\r\nif (err)\r\nreturn err;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nsunsab_cec_wait(up);\r\nsunsab_tec_wait(up);\r\nwriteb(SAB82532_CMDR_RRES, &up->regs->w.cmdr);\r\nsunsab_cec_wait(up);\r\nwriteb(SAB82532_CMDR_XRES, &up->regs->w.cmdr);\r\n(void) readb(&up->regs->r.isr0);\r\n(void) readb(&up->regs->r.isr1);\r\nwriteb(0, &up->regs->w.ccr0);\r\nwriteb(SAB82532_CCR0_MCE | SAB82532_CCR0_SC_NRZ |\r\nSAB82532_CCR0_SM_ASYNC, &up->regs->w.ccr0);\r\nwriteb(SAB82532_CCR1_ODS | SAB82532_CCR1_BCR | 7, &up->regs->w.ccr1);\r\nwriteb(SAB82532_CCR2_BDF | SAB82532_CCR2_SSEL |\r\nSAB82532_CCR2_TOE, &up->regs->w.ccr2);\r\nwriteb(0, &up->regs->w.ccr3);\r\nwriteb(SAB82532_CCR4_MCK4 | SAB82532_CCR4_EBRG, &up->regs->w.ccr4);\r\nup->cached_mode = (SAB82532_MODE_RTS | SAB82532_MODE_FCTS |\r\nSAB82532_MODE_RAC);\r\nwriteb(up->cached_mode, &up->regs->w.mode);\r\nwriteb(SAB82532_RFC_DPS|SAB82532_RFC_RFTH_32, &up->regs->w.rfc);\r\ntmp = readb(&up->regs->rw.ccr0);\r\ntmp |= SAB82532_CCR0_PU;\r\nwriteb(tmp, &up->regs->rw.ccr0);\r\nup->interrupt_mask0 = (SAB82532_IMR0_PERR | SAB82532_IMR0_FERR |\r\nSAB82532_IMR0_PLLA);\r\nwriteb(up->interrupt_mask0, &up->regs->w.imr0);\r\nup->interrupt_mask1 = (SAB82532_IMR1_BRKT | SAB82532_IMR1_ALLS |\r\nSAB82532_IMR1_XOFF | SAB82532_IMR1_TIN |\r\nSAB82532_IMR1_CSC | SAB82532_IMR1_XON |\r\nSAB82532_IMR1_XPR);\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nset_bit(SAB82532_ALLS, &up->irqflags);\r\nset_bit(SAB82532_XPR, &up->irqflags);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sunsab_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->interrupt_mask0 = 0xff;\r\nwriteb(up->interrupt_mask0, &up->regs->w.imr0);\r\nup->interrupt_mask1 = 0xff;\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nup->cached_dafo = readb(&up->regs->rw.dafo);\r\nup->cached_dafo &= ~SAB82532_DAFO_XBRK;\r\nwriteb(up->cached_dafo, &up->regs->rw.dafo);\r\nup->cached_mode &= ~SAB82532_MODE_RAC;\r\nwriteb(up->cached_mode, &up->regs->rw.mode);\r\n#if 0\r\ntmp = readb(&up->regs->rw.ccr0);\r\ntmp &= ~SAB82532_CCR0_PU;\r\nwriteb(tmp, &up->regs->rw.ccr0);\r\n#endif\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nfree_irq(up->port.irq, up);\r\n}\r\nstatic void calc_ebrg(int baud, int *n_ret, int *m_ret)\r\n{\r\nint n, m;\r\nif (baud == 0) {\r\n*n_ret = 0;\r\n*m_ret = 0;\r\nreturn;\r\n}\r\nn = (SAB_BASE_BAUD * 10) / baud;\r\nm = 0;\r\nwhile (n >= 640) {\r\nn = n / 2;\r\nm++;\r\n}\r\nn = (n+5) / 10;\r\nif ((m == 0) && ((n & 1) == 0)) {\r\nn = n / 2;\r\nm++;\r\n}\r\n*n_ret = n - 1;\r\n*m_ret = m;\r\n}\r\nstatic void sunsab_convert_to_sab(struct uart_sunsab_port *up, unsigned int cflag,\r\nunsigned int iflag, unsigned int baud,\r\nunsigned int quot)\r\n{\r\nunsigned char dafo;\r\nint bits, n, m;\r\nswitch (cflag & CSIZE) {\r\ncase CS5: dafo = SAB82532_DAFO_CHL5; bits = 7; break;\r\ncase CS6: dafo = SAB82532_DAFO_CHL6; bits = 8; break;\r\ncase CS7: dafo = SAB82532_DAFO_CHL7; bits = 9; break;\r\ncase CS8: dafo = SAB82532_DAFO_CHL8; bits = 10; break;\r\ndefault: dafo = SAB82532_DAFO_CHL5; bits = 7; break;\r\n}\r\nif (cflag & CSTOPB) {\r\ndafo |= SAB82532_DAFO_STOP;\r\nbits++;\r\n}\r\nif (cflag & PARENB) {\r\ndafo |= SAB82532_DAFO_PARE;\r\nbits++;\r\n}\r\nif (cflag & PARODD) {\r\ndafo |= SAB82532_DAFO_PAR_ODD;\r\n} else {\r\ndafo |= SAB82532_DAFO_PAR_EVEN;\r\n}\r\nup->cached_dafo = dafo;\r\ncalc_ebrg(baud, &n, &m);\r\nup->cached_ebrg = n | (m << 6);\r\nup->tec_timeout = (10 * 1000000) / baud;\r\nup->cec_timeout = up->tec_timeout >> 2;\r\nup->port.read_status_mask = (SAB82532_ISR0_TCD | SAB82532_ISR0_TIME |\r\nSAB82532_ISR0_RFO | SAB82532_ISR0_RPF |\r\nSAB82532_ISR0_CDSC);\r\nup->port.read_status_mask |= (SAB82532_ISR1_CSC |\r\nSAB82532_ISR1_ALLS |\r\nSAB82532_ISR1_XPR) << 8;\r\nif (iflag & INPCK)\r\nup->port.read_status_mask |= (SAB82532_ISR0_PERR |\r\nSAB82532_ISR0_FERR);\r\nif (iflag & (BRKINT | PARMRK))\r\nup->port.read_status_mask |= (SAB82532_ISR1_BRK << 8);\r\nup->port.ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= (SAB82532_ISR0_PERR |\r\nSAB82532_ISR0_FERR);\r\nif (iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= (SAB82532_ISR1_BRK << 8);\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= SAB82532_ISR0_RFO;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= (SAB82532_ISR0_RPF |\r\nSAB82532_ISR0_TCD);\r\nuart_update_timeout(&up->port, cflag,\r\n(up->port.uartclk / (16 * quot)));\r\nup->cached_mode |= SAB82532_MODE_RAC;\r\nset_bit(SAB82532_REGS_PENDING, &up->irqflags);\r\nif (test_bit(SAB82532_XPR, &up->irqflags))\r\nsunsab_tx_idle(up);\r\n}\r\nstatic void sunsab_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *) port;\r\nunsigned long flags;\r\nunsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nunsigned int quot = uart_get_divisor(port, baud);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nsunsab_convert_to_sab(up, termios->c_cflag, termios->c_iflag, baud, quot);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic const char *sunsab_type(struct uart_port *port)\r\n{\r\nstruct uart_sunsab_port *up = (void *)port;\r\nstatic char buf[36];\r\nsprintf(buf, "SAB82532 %s", sab82532_version[up->type]);\r\nreturn buf;\r\n}\r\nstatic void sunsab_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sunsab_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sunsab_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int sunsab_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void sunsab_console_putchar(struct uart_port *port, int c)\r\n{\r\nstruct uart_sunsab_port *up = (struct uart_sunsab_port *)port;\r\nsunsab_tec_wait(up);\r\nwriteb(c, &up->regs->w.tic);\r\n}\r\nstatic void sunsab_console_write(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct uart_sunsab_port *up = &sunsab_ports[con->index];\r\nunsigned long flags;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&up->port.lock);\r\n} else\r\nspin_lock(&up->port.lock);\r\nuart_console_write(&up->port, s, n, sunsab_console_putchar);\r\nsunsab_tec_wait(up);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int sunsab_console_setup(struct console *con, char *options)\r\n{\r\nstruct uart_sunsab_port *up = &sunsab_ports[con->index];\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nif (up->port.type != PORT_SUNSAB)\r\nreturn -1;\r\nprintk("Console: ttyS%d (SAB82532)\n",\r\n(sunsab_reg.minor - 64) + con->index);\r\nsunserial_console_termios(con, up->port.dev->of_node);\r\nswitch (con->cflag & CBAUD) {\r\ncase B150: baud = 150; break;\r\ncase B300: baud = 300; break;\r\ncase B600: baud = 600; break;\r\ncase B1200: baud = 1200; break;\r\ncase B2400: baud = 2400; break;\r\ncase B4800: baud = 4800; break;\r\ndefault: case B9600: baud = 9600; break;\r\ncase B19200: baud = 19200; break;\r\ncase B38400: baud = 38400; break;\r\ncase B57600: baud = 57600; break;\r\ncase B115200: baud = 115200; break;\r\ncase B230400: baud = 230400; break;\r\ncase B460800: baud = 460800; break;\r\n};\r\nspin_lock_init(&up->port.lock);\r\nsunsab_startup(&up->port);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->interrupt_mask0 = SAB82532_IMR0_PERR | SAB82532_IMR0_FERR |\r\nSAB82532_IMR0_PLLA | SAB82532_IMR0_CDSC;\r\nwriteb(up->interrupt_mask0, &up->regs->w.imr0);\r\nup->interrupt_mask1 = SAB82532_IMR1_BRKT | SAB82532_IMR1_ALLS |\r\nSAB82532_IMR1_XOFF | SAB82532_IMR1_TIN |\r\nSAB82532_IMR1_CSC | SAB82532_IMR1_XON |\r\nSAB82532_IMR1_XPR;\r\nwriteb(up->interrupt_mask1, &up->regs->w.imr1);\r\nquot = uart_get_divisor(&up->port, baud);\r\nsunsab_convert_to_sab(up, con->cflag, 0, baud, quot);\r\nsunsab_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline struct console *SUNSAB_CONSOLE(void)\r\n{\r\nreturn &sunsab_console;\r\n}\r\nstatic int sunsab_init_one(struct uart_sunsab_port *up,\r\nstruct platform_device *op,\r\nunsigned long offset,\r\nint line)\r\n{\r\nup->port.line = line;\r\nup->port.dev = &op->dev;\r\nup->port.mapbase = op->resource[0].start + offset;\r\nup->port.membase = of_ioremap(&op->resource[0], offset,\r\nsizeof(union sab82532_async_regs),\r\n"sab");\r\nif (!up->port.membase)\r\nreturn -ENOMEM;\r\nup->regs = (union sab82532_async_regs __iomem *) up->port.membase;\r\nup->port.irq = op->archdata.irqs[0];\r\nup->port.fifosize = SAB82532_XMIT_FIFO_SIZE;\r\nup->port.iotype = UPIO_MEM;\r\nwriteb(SAB82532_IPC_IC_ACT_LOW, &up->regs->w.ipc);\r\nup->port.ops = &sunsab_pops;\r\nup->port.type = PORT_SUNSAB;\r\nup->port.uartclk = SAB_BASE_BAUD;\r\nup->type = readb(&up->regs->r.vstr) & 0x0f;\r\nwriteb(~((1 << 1) | (1 << 2) | (1 << 4)), &up->regs->w.pcr);\r\nwriteb(0xff, &up->regs->w.pim);\r\nif ((up->port.line & 0x1) == 0) {\r\nup->pvr_dsr_bit = (1 << 0);\r\nup->pvr_dtr_bit = (1 << 1);\r\nup->gis_shift = 2;\r\n} else {\r\nup->pvr_dsr_bit = (1 << 3);\r\nup->pvr_dtr_bit = (1 << 2);\r\nup->gis_shift = 0;\r\n}\r\nup->cached_pvr = (1 << 1) | (1 << 2) | (1 << 4);\r\nwriteb(up->cached_pvr, &up->regs->w.pvr);\r\nup->cached_mode = readb(&up->regs->rw.mode);\r\nup->cached_mode |= SAB82532_MODE_FRTS;\r\nwriteb(up->cached_mode, &up->regs->rw.mode);\r\nup->cached_mode |= SAB82532_MODE_RTS;\r\nwriteb(up->cached_mode, &up->regs->rw.mode);\r\nup->tec_timeout = SAB82532_MAX_TEC_TIMEOUT;\r\nup->cec_timeout = SAB82532_MAX_CEC_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int sab_probe(struct platform_device *op)\r\n{\r\nstatic int inst;\r\nstruct uart_sunsab_port *up;\r\nint err;\r\nup = &sunsab_ports[inst * 2];\r\nerr = sunsab_init_one(&up[0], op,\r\n0,\r\n(inst * 2) + 0);\r\nif (err)\r\ngoto out;\r\nerr = sunsab_init_one(&up[1], op,\r\nsizeof(union sab82532_async_regs),\r\n(inst * 2) + 1);\r\nif (err)\r\ngoto out1;\r\nsunserial_console_match(SUNSAB_CONSOLE(), op->dev.of_node,\r\n&sunsab_reg, up[0].port.line,\r\nfalse);\r\nsunserial_console_match(SUNSAB_CONSOLE(), op->dev.of_node,\r\n&sunsab_reg, up[1].port.line,\r\nfalse);\r\nerr = uart_add_one_port(&sunsab_reg, &up[0].port);\r\nif (err)\r\ngoto out2;\r\nerr = uart_add_one_port(&sunsab_reg, &up[1].port);\r\nif (err)\r\ngoto out3;\r\nplatform_set_drvdata(op, &up[0]);\r\ninst++;\r\nreturn 0;\r\nout3:\r\nuart_remove_one_port(&sunsab_reg, &up[0].port);\r\nout2:\r\nof_iounmap(&op->resource[0],\r\nup[1].port.membase,\r\nsizeof(union sab82532_async_regs));\r\nout1:\r\nof_iounmap(&op->resource[0],\r\nup[0].port.membase,\r\nsizeof(union sab82532_async_regs));\r\nout:\r\nreturn err;\r\n}\r\nstatic int sab_remove(struct platform_device *op)\r\n{\r\nstruct uart_sunsab_port *up = platform_get_drvdata(op);\r\nuart_remove_one_port(&sunsab_reg, &up[1].port);\r\nuart_remove_one_port(&sunsab_reg, &up[0].port);\r\nof_iounmap(&op->resource[0],\r\nup[1].port.membase,\r\nsizeof(union sab82532_async_regs));\r\nof_iounmap(&op->resource[0],\r\nup[0].port.membase,\r\nsizeof(union sab82532_async_regs));\r\nreturn 0;\r\n}\r\nstatic int __init sunsab_init(void)\r\n{\r\nstruct device_node *dp;\r\nint err;\r\nint num_channels = 0;\r\nfor_each_node_by_name(dp, "se")\r\nnum_channels += 2;\r\nfor_each_node_by_name(dp, "serial") {\r\nif (of_device_is_compatible(dp, "sab82532"))\r\nnum_channels += 2;\r\n}\r\nif (num_channels) {\r\nsunsab_ports = kzalloc(sizeof(struct uart_sunsab_port) *\r\nnum_channels, GFP_KERNEL);\r\nif (!sunsab_ports)\r\nreturn -ENOMEM;\r\nerr = sunserial_register_minors(&sunsab_reg, num_channels);\r\nif (err) {\r\nkfree(sunsab_ports);\r\nsunsab_ports = NULL;\r\nreturn err;\r\n}\r\n}\r\nreturn platform_driver_register(&sab_driver);\r\n}\r\nstatic void __exit sunsab_exit(void)\r\n{\r\nplatform_driver_unregister(&sab_driver);\r\nif (sunsab_reg.nr) {\r\nsunserial_unregister_minors(&sunsab_reg, sunsab_reg.nr);\r\n}\r\nkfree(sunsab_ports);\r\nsunsab_ports = NULL;\r\n}
