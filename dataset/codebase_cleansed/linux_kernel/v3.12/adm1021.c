static ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct adm1021_data *data = adm1021_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp[index]);\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct adm1021_data *data = adm1021_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp_max[index]);\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct adm1021_data *data = adm1021_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp_min[index]);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint index = to_sensor_dev_attr(attr)->index;\r\nstruct adm1021_data *data = adm1021_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->alarms >> index) & 1);\r\n}\r\nstatic ssize_t show_alarms(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1021_data *data = adm1021_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1021_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nint err;\r\nerr = kstrtol(buf, 10, &temp);\r\nif (err)\r\nreturn err;\r\ntemp /= 1000;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[index] = clamp_val(temp, -128, 127);\r\nif (!read_only)\r\ni2c_smbus_write_byte_data(client, ADM1021_REG_TOS_W(index),\r\ndata->temp_max[index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1021_data *data = i2c_get_clientdata(client);\r\nlong temp;\r\nint err;\r\nerr = kstrtol(buf, 10, &temp);\r\nif (err)\r\nreturn err;\r\ntemp /= 1000;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_min[index] = clamp_val(temp, -128, 127);\r\nif (!read_only)\r\ni2c_smbus_write_byte_data(client, ADM1021_REG_THYST_W(index),\r\ndata->temp_min[index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_low_power(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct adm1021_data *data = adm1021_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->low_power);\r\n}\r\nstatic ssize_t set_low_power(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1021_data *data = i2c_get_clientdata(client);\r\nchar low_power;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nlow_power = val != 0;\r\nmutex_lock(&data->update_lock);\r\nif (low_power != data->low_power) {\r\nint config = i2c_smbus_read_byte_data(\r\nclient, ADM1021_REG_CONFIG_R);\r\ndata->low_power = low_power;\r\ni2c_smbus_write_byte_data(client, ADM1021_REG_CONFIG_W,\r\n(config & 0xBF) | (low_power << 6));\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int adm1021_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nconst char *type_name;\r\nint conv_rate, status, config, man_id, dev_id;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\npr_debug("detect failed, smbus byte data not supported!\n");\r\nreturn -ENODEV;\r\n}\r\nstatus = i2c_smbus_read_byte_data(client, ADM1021_REG_STATUS);\r\nconv_rate = i2c_smbus_read_byte_data(client,\r\nADM1021_REG_CONV_RATE_R);\r\nconfig = i2c_smbus_read_byte_data(client, ADM1021_REG_CONFIG_R);\r\nif ((status & 0x03) || (config & 0x3F) || (conv_rate & 0xF8)) {\r\npr_debug("detect failed, chip not detected!\n");\r\nreturn -ENODEV;\r\n}\r\nman_id = i2c_smbus_read_byte_data(client, ADM1021_REG_MAN_ID);\r\ndev_id = i2c_smbus_read_byte_data(client, ADM1021_REG_DEV_ID);\r\nif (man_id < 0 || dev_id < 0)\r\nreturn -ENODEV;\r\nif (man_id == 0x4d && dev_id == 0x01)\r\ntype_name = "max1617a";\r\nelse if (man_id == 0x41) {\r\nif ((dev_id & 0xF0) == 0x30)\r\ntype_name = "adm1023";\r\nelse if ((dev_id & 0xF0) == 0x00)\r\ntype_name = "adm1021";\r\nelse\r\nreturn -ENODEV;\r\n} else if (man_id == 0x49)\r\ntype_name = "thmc10";\r\nelse if (man_id == 0x23)\r\ntype_name = "gl523sm";\r\nelse if (man_id == 0x54)\r\ntype_name = "mc1066";\r\nelse {\r\nint lte, rte, lhi, rhi, llo, rlo;\r\nllo = i2c_smbus_read_byte_data(client, ADM1021_REG_THYST_R(0));\r\nrlo = i2c_smbus_read_byte_data(client, ADM1021_REG_THYST_R(1));\r\nif (llo < 0 || rlo < 0)\r\nreturn -ENODEV;\r\nlte = i2c_smbus_read_byte_data(client, ADM1021_REG_TEMP(0));\r\nrte = i2c_smbus_read_byte_data(client, ADM1021_REG_TEMP(1));\r\nlhi = i2c_smbus_read_byte_data(client, ADM1021_REG_TOS_R(0));\r\nrhi = i2c_smbus_read_byte_data(client, ADM1021_REG_TOS_R(1));\r\nif ((s8)lte < 0 || (s8)rte < 0 || (s8)lhi < 0 || (s8)rhi < 0)\r\nreturn -ENODEV;\r\nif (lte == rte && lte == lhi && lte == rhi && lte == llo\r\n&& lte == rlo)\r\nreturn -ENODEV;\r\nif (conv_rate == 0x00\r\n&& (config & 0x7F) == 0x00\r\n&& (status & 0xAB) == 0x00) {\r\ntype_name = "lm84";\r\n} else {\r\nif ((s8)llo > lhi || (s8)rlo > rhi)\r\nreturn -ENODEV;\r\ntype_name = "max1617";\r\n}\r\n}\r\npr_debug("Detected chip %s at adapter %d, address 0x%02x.\n",\r\ntype_name, i2c_adapter_id(adapter), client->addr);\r\nstrlcpy(info->type, type_name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int adm1021_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adm1021_data *data;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct adm1021_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->type = id->driver_data;\r\nmutex_init(&data->update_lock);\r\nif (data->type != lm84 && !read_only)\r\nadm1021_init_client(client);\r\nerr = sysfs_create_group(&client->dev.kobj, &adm1021_group);\r\nif (err)\r\nreturn err;\r\nif (data->type != lm84) {\r\nerr = sysfs_create_group(&client->dev.kobj, &adm1021_min_group);\r\nif (err)\r\ngoto error;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nsysfs_remove_group(&client->dev.kobj, &adm1021_min_group);\r\nsysfs_remove_group(&client->dev.kobj, &adm1021_group);\r\nreturn err;\r\n}\r\nstatic void adm1021_init_client(struct i2c_client *client)\r\n{\r\ni2c_smbus_write_byte_data(client, ADM1021_REG_CONFIG_W,\r\ni2c_smbus_read_byte_data(client, ADM1021_REG_CONFIG_R) & 0xBF);\r\ni2c_smbus_write_byte_data(client, ADM1021_REG_CONV_RATE_W, 0x04);\r\n}\r\nstatic int adm1021_remove(struct i2c_client *client)\r\n{\r\nstruct adm1021_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &adm1021_min_group);\r\nsysfs_remove_group(&client->dev.kobj, &adm1021_group);\r\nreturn 0;\r\n}\r\nstatic struct adm1021_data *adm1021_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1021_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\nint i;\r\ndev_dbg(&client->dev, "Starting adm1021 update\n");\r\nfor (i = 0; i < 2; i++) {\r\ndata->temp[i] = 1000 *\r\n(s8) i2c_smbus_read_byte_data(\r\nclient, ADM1021_REG_TEMP(i));\r\ndata->temp_max[i] = 1000 *\r\n(s8) i2c_smbus_read_byte_data(\r\nclient, ADM1021_REG_TOS_R(i));\r\nif (data->type != lm84) {\r\ndata->temp_min[i] = 1000 *\r\n(s8) i2c_smbus_read_byte_data(client,\r\nADM1021_REG_THYST_R(i));\r\n}\r\n}\r\ndata->alarms = i2c_smbus_read_byte_data(client,\r\nADM1021_REG_STATUS) & 0x7c;\r\nif (data->type == adm1023) {\r\ndata->temp[1] += 125 * (i2c_smbus_read_byte_data(\r\nclient, ADM1023_REG_REM_TEMP_PREC) >> 5);\r\ndata->temp_max[1] += 125 * (i2c_smbus_read_byte_data(\r\nclient, ADM1023_REG_REM_TOS_PREC) >> 5);\r\ndata->temp_min[1] += 125 * (i2c_smbus_read_byte_data(\r\nclient, ADM1023_REG_REM_THYST_PREC) >> 5);\r\ndata->remote_temp_offset =\r\ni2c_smbus_read_byte_data(client,\r\nADM1023_REG_REM_OFFSET);\r\ndata->remote_temp_offset_prec =\r\ni2c_smbus_read_byte_data(client,\r\nADM1023_REG_REM_OFFSET_PREC);\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
