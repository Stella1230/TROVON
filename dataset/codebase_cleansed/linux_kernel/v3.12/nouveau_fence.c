static void\r\nnouveau_fence_signal(struct nouveau_fence *fence)\r\n{\r\nstruct fence_work *work, *temp;\r\nlist_for_each_entry_safe(work, temp, &fence->work, head) {\r\nschedule_work(&work->base);\r\nlist_del(&work->head);\r\n}\r\nfence->channel = NULL;\r\nlist_del(&fence->head);\r\n}\r\nvoid\r\nnouveau_fence_context_del(struct nouveau_fence_chan *fctx)\r\n{\r\nstruct nouveau_fence *fence, *fnext;\r\nspin_lock(&fctx->lock);\r\nlist_for_each_entry_safe(fence, fnext, &fctx->pending, head) {\r\nnouveau_fence_signal(fence);\r\n}\r\nspin_unlock(&fctx->lock);\r\n}\r\nvoid\r\nnouveau_fence_context_new(struct nouveau_fence_chan *fctx)\r\n{\r\nINIT_LIST_HEAD(&fctx->flip);\r\nINIT_LIST_HEAD(&fctx->pending);\r\nspin_lock_init(&fctx->lock);\r\n}\r\nstatic void\r\nnouveau_fence_work_handler(struct work_struct *kwork)\r\n{\r\nstruct fence_work *work = container_of(kwork, typeof(*work), base);\r\nwork->func(work->data);\r\nkfree(work);\r\n}\r\nvoid\r\nnouveau_fence_work(struct nouveau_fence *fence,\r\nvoid (*func)(void *), void *data)\r\n{\r\nstruct nouveau_channel *chan = fence->channel;\r\nstruct nouveau_fence_chan *fctx;\r\nstruct fence_work *work = NULL;\r\nif (nouveau_fence_done(fence)) {\r\nfunc(data);\r\nreturn;\r\n}\r\nfctx = chan->fence;\r\nwork = kmalloc(sizeof(*work), GFP_KERNEL);\r\nif (!work) {\r\nWARN_ON(nouveau_fence_wait(fence, false, false));\r\nfunc(data);\r\nreturn;\r\n}\r\nspin_lock(&fctx->lock);\r\nif (!fence->channel) {\r\nspin_unlock(&fctx->lock);\r\nkfree(work);\r\nfunc(data);\r\nreturn;\r\n}\r\nINIT_WORK(&work->base, nouveau_fence_work_handler);\r\nwork->func = func;\r\nwork->data = data;\r\nlist_add(&work->head, &fence->work);\r\nspin_unlock(&fctx->lock);\r\n}\r\nstatic void\r\nnouveau_fence_update(struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct nouveau_fence *fence, *fnext;\r\nspin_lock(&fctx->lock);\r\nlist_for_each_entry_safe(fence, fnext, &fctx->pending, head) {\r\nif (fctx->read(chan) < fence->sequence)\r\nbreak;\r\nnouveau_fence_signal(fence);\r\nnouveau_fence_unref(&fence);\r\n}\r\nspin_unlock(&fctx->lock);\r\n}\r\nint\r\nnouveau_fence_emit(struct nouveau_fence *fence, struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nint ret;\r\nfence->channel = chan;\r\nfence->timeout = jiffies + (15 * DRM_HZ);\r\nfence->sequence = ++fctx->sequence;\r\nret = fctx->emit(fence);\r\nif (!ret) {\r\nkref_get(&fence->kref);\r\nspin_lock(&fctx->lock);\r\nlist_add_tail(&fence->head, &fctx->pending);\r\nspin_unlock(&fctx->lock);\r\n}\r\nreturn ret;\r\n}\r\nbool\r\nnouveau_fence_done(struct nouveau_fence *fence)\r\n{\r\nif (fence->channel)\r\nnouveau_fence_update(fence->channel);\r\nreturn !fence->channel;\r\n}\r\nstatic int\r\nnouveau_fence_wait_uevent_handler(struct nouveau_eventh *event, int index)\r\n{\r\nstruct nouveau_fence_uevent *uevent =\r\ncontainer_of(event, struct nouveau_fence_uevent, handler);\r\nwake_up_all(&uevent->priv->waiting);\r\nreturn NVKM_EVENT_KEEP;\r\n}\r\nstatic int\r\nnouveau_fence_wait_uevent(struct nouveau_fence *fence, bool intr)\r\n{\r\nstruct nouveau_channel *chan = fence->channel;\r\nstruct nouveau_fifo *pfifo = nouveau_fifo(chan->drm->device);\r\nstruct nouveau_fence_priv *priv = chan->drm->fence;\r\nstruct nouveau_fence_uevent uevent = {\r\n.handler.func = nouveau_fence_wait_uevent_handler,\r\n.priv = priv,\r\n};\r\nint ret = 0;\r\nnouveau_event_get(pfifo->uevent, 0, &uevent.handler);\r\nif (fence->timeout) {\r\nunsigned long timeout = fence->timeout - jiffies;\r\nif (time_before(jiffies, fence->timeout)) {\r\nif (intr) {\r\nret = wait_event_interruptible_timeout(\r\npriv->waiting,\r\nnouveau_fence_done(fence),\r\ntimeout);\r\n} else {\r\nret = wait_event_timeout(priv->waiting,\r\nnouveau_fence_done(fence),\r\ntimeout);\r\n}\r\n}\r\nif (ret >= 0) {\r\nfence->timeout = jiffies + ret;\r\nif (time_after_eq(jiffies, fence->timeout))\r\nret = -EBUSY;\r\n}\r\n} else {\r\nif (intr) {\r\nret = wait_event_interruptible(priv->waiting,\r\nnouveau_fence_done(fence));\r\n} else {\r\nwait_event(priv->waiting, nouveau_fence_done(fence));\r\n}\r\n}\r\nnouveau_event_put(pfifo->uevent, 0, &uevent.handler);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint\r\nnouveau_fence_wait(struct nouveau_fence *fence, bool lazy, bool intr)\r\n{\r\nstruct nouveau_channel *chan = fence->channel;\r\nstruct nouveau_fence_priv *priv = chan ? chan->drm->fence : NULL;\r\nunsigned long sleep_time = NSEC_PER_MSEC / 1000;\r\nktime_t t;\r\nint ret = 0;\r\nwhile (priv && priv->uevent && lazy && !nouveau_fence_done(fence)) {\r\nret = nouveau_fence_wait_uevent(fence, intr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nwhile (!nouveau_fence_done(fence)) {\r\nif (fence->timeout && time_after_eq(jiffies, fence->timeout)) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n__set_current_state(intr ? TASK_INTERRUPTIBLE :\r\nTASK_UNINTERRUPTIBLE);\r\nif (lazy) {\r\nt = ktime_set(0, sleep_time);\r\nschedule_hrtimeout(&t, HRTIMER_MODE_REL);\r\nsleep_time *= 2;\r\nif (sleep_time > NSEC_PER_MSEC)\r\nsleep_time = NSEC_PER_MSEC;\r\n}\r\nif (intr && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_fence_sync(struct nouveau_fence *fence, struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct nouveau_channel *prev;\r\nint ret = 0;\r\nprev = fence ? fence->channel : NULL;\r\nif (prev) {\r\nif (unlikely(prev != chan && !nouveau_fence_done(fence))) {\r\nret = fctx->sync(fence, prev, chan);\r\nif (unlikely(ret))\r\nret = nouveau_fence_wait(fence, true, false);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnouveau_fence_del(struct kref *kref)\r\n{\r\nstruct nouveau_fence *fence = container_of(kref, typeof(*fence), kref);\r\nkfree(fence);\r\n}\r\nvoid\r\nnouveau_fence_unref(struct nouveau_fence **pfence)\r\n{\r\nif (*pfence)\r\nkref_put(&(*pfence)->kref, nouveau_fence_del);\r\n*pfence = NULL;\r\n}\r\nstruct nouveau_fence *\r\nnouveau_fence_ref(struct nouveau_fence *fence)\r\n{\r\nkref_get(&fence->kref);\r\nreturn fence;\r\n}\r\nint\r\nnouveau_fence_new(struct nouveau_channel *chan, bool sysmem,\r\nstruct nouveau_fence **pfence)\r\n{\r\nstruct nouveau_fence *fence;\r\nint ret = 0;\r\nif (unlikely(!chan->fence))\r\nreturn -ENODEV;\r\nfence = kzalloc(sizeof(*fence), GFP_KERNEL);\r\nif (!fence)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&fence->work);\r\nfence->sysmem = sysmem;\r\nkref_init(&fence->kref);\r\nret = nouveau_fence_emit(fence, chan);\r\nif (ret)\r\nnouveau_fence_unref(&fence);\r\n*pfence = fence;\r\nreturn ret;\r\n}
