static void jz4740_pcm_start_transfer(struct jz4740_runtime_data *prtd,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nunsigned long count;\r\nif (prtd->dma_pos == prtd->dma_end)\r\nprtd->dma_pos = prtd->dma_start;\r\nif (prtd->dma_pos + prtd->dma_period > prtd->dma_end)\r\ncount = prtd->dma_end - prtd->dma_pos;\r\nelse\r\ncount = prtd->dma_period;\r\njz4740_dma_disable(prtd->dma);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\njz4740_dma_set_src_addr(prtd->dma, prtd->dma_pos);\r\njz4740_dma_set_dst_addr(prtd->dma, prtd->fifo_addr);\r\n} else {\r\njz4740_dma_set_src_addr(prtd->dma, prtd->fifo_addr);\r\njz4740_dma_set_dst_addr(prtd->dma, prtd->dma_pos);\r\n}\r\njz4740_dma_set_transfer_count(prtd->dma, count);\r\nprtd->dma_pos += count;\r\njz4740_dma_enable(prtd->dma);\r\n}\r\nstatic void jz4740_pcm_dma_transfer_done(struct jz4740_dma_chan *dma, int err,\r\nvoid *dev_id)\r\n{\r\nstruct snd_pcm_substream *substream = dev_id;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct jz4740_runtime_data *prtd = runtime->private_data;\r\nsnd_pcm_period_elapsed(substream);\r\njz4740_pcm_start_transfer(prtd, substream);\r\n}\r\nstatic int jz4740_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct jz4740_runtime_data *prtd = runtime->private_data;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct jz4740_pcm_config *config;\r\nconfig = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (!config)\r\nreturn 0;\r\nif (!prtd->dma) {\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nprtd->dma = jz4740_dma_request(substream, "PCM Capture");\r\nelse\r\nprtd->dma = jz4740_dma_request(substream, "PCM Playback");\r\n}\r\nif (!prtd->dma)\r\nreturn -EBUSY;\r\njz4740_dma_configure(prtd->dma, &config->dma_config);\r\nprtd->fifo_addr = config->fifo_addr;\r\njz4740_dma_set_complete_cb(prtd->dma, jz4740_pcm_dma_transfer_done);\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nprtd->dma_period = params_period_bytes(params);\r\nprtd->dma_start = runtime->dma_addr;\r\nprtd->dma_pos = prtd->dma_start;\r\nprtd->dma_end = prtd->dma_start + runtime->dma_bytes;\r\nreturn 0;\r\n}\r\nstatic int jz4740_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct jz4740_runtime_data *prtd = substream->runtime->private_data;\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nif (prtd->dma) {\r\njz4740_dma_free(prtd->dma);\r\nprtd->dma = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jz4740_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct jz4740_runtime_data *prtd = substream->runtime->private_data;\r\nif (!prtd->dma)\r\nreturn -EBUSY;\r\nprtd->dma_pos = prtd->dma_start;\r\nreturn 0;\r\n}\r\nstatic int jz4740_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct jz4740_runtime_data *prtd = runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\njz4740_pcm_start_transfer(prtd, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\njz4740_dma_disable(prtd->dma);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t jz4740_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct jz4740_runtime_data *prtd = runtime->private_data;\r\nunsigned long byte_offset;\r\nsnd_pcm_uframes_t offset;\r\nstruct jz4740_dma_chan *dma = prtd->dma;\r\nbyte_offset = prtd->dma_pos - prtd->dma_start;\r\nbyte_offset -= jz4740_dma_get_residue(dma);\r\noffset = bytes_to_frames(runtime, byte_offset);\r\nif (offset >= runtime->buffer_size)\r\noffset = 0;\r\nreturn offset;\r\n}\r\nstatic int jz4740_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct jz4740_runtime_data *prtd;\r\nprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\r\nif (prtd == NULL)\r\nreturn -ENOMEM;\r\nsnd_soc_set_runtime_hwparams(substream, &jz4740_pcm_hardware);\r\nruntime->private_data = prtd;\r\nreturn 0;\r\n}\r\nstatic int jz4740_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct jz4740_runtime_data *prtd = runtime->private_data;\r\nkfree(prtd);\r\nreturn 0;\r\n}\r\nstatic int jz4740_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nreturn remap_pfn_range(vma, vma->vm_start,\r\nsubstream->dma_buffer.addr >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot);\r\n}\r\nstatic int jz4740_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = jz4740_pcm_hardware.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_noncoherent(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic void jz4740_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < SNDRV_PCM_STREAM_LAST; ++stream) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_noncoherent(pcm->card->dev, buf->bytes, buf->area,\r\nbuf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\nstatic int jz4740_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret = 0;\r\nif (!card->dev->dma_mask)\r\ncard->dev->dma_mask = &jz4740_pcm_dmamask;\r\nif (!card->dev->coherent_dma_mask)\r\ncard->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = jz4740_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = jz4740_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int jz4740_pcm_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev, &jz4740_soc_platform);\r\n}\r\nstatic int jz4740_pcm_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
