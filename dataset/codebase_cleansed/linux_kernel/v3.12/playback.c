static void change_volume(struct urb *urb_out, int volume[],\r\nint bytes_per_frame)\r\n{\r\nint chn = 0;\r\nif (volume[0] == 256 && volume[1] == 256)\r\nreturn;\r\nif (bytes_per_frame == 4) {\r\nshort *p, *buf_end;\r\np = (short *)urb_out->transfer_buffer;\r\nbuf_end = p + urb_out->transfer_buffer_length / sizeof(*p);\r\nfor (; p < buf_end; ++p) {\r\n*p = (*p * volume[chn & 1]) >> 8;\r\n++chn;\r\n}\r\n} else if (bytes_per_frame == 6) {\r\nunsigned char *p, *buf_end;\r\np = (unsigned char *)urb_out->transfer_buffer;\r\nbuf_end = p + urb_out->transfer_buffer_length;\r\nfor (; p < buf_end; p += 3) {\r\nint val;\r\nval = p[0] + (p[1] << 8) + ((signed char)p[2] << 16);\r\nval = (val * volume[chn & 1]) >> 8;\r\np[0] = val;\r\np[1] = val >> 8;\r\np[2] = val >> 16;\r\n++chn;\r\n}\r\n}\r\n}\r\nstatic void create_impulse_test_signal(struct snd_line6_pcm *line6pcm,\r\nstruct urb *urb_out, int bytes_per_frame)\r\n{\r\nint frames = urb_out->transfer_buffer_length / bytes_per_frame;\r\nif (bytes_per_frame == 4) {\r\nint i;\r\nshort *pi = (short *)line6pcm->prev_fbuf;\r\nshort *po = (short *)urb_out->transfer_buffer;\r\nfor (i = 0; i < frames; ++i) {\r\npo[0] = pi[0];\r\npo[1] = 0;\r\npi += 2;\r\npo += 2;\r\n}\r\n} else if (bytes_per_frame == 6) {\r\nint i, j;\r\nunsigned char *pi = line6pcm->prev_fbuf;\r\nunsigned char *po = urb_out->transfer_buffer;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (j = 0; j < bytes_per_frame / 2; ++j)\r\npo[j] = pi[j];\r\nfor (; j < bytes_per_frame; ++j)\r\npo[j] = 0;\r\npi += bytes_per_frame;\r\npo += bytes_per_frame;\r\n}\r\n}\r\nif (--line6pcm->impulse_count <= 0) {\r\n((unsigned char *)(urb_out->transfer_buffer))[bytes_per_frame -\r\n1] =\r\nline6pcm->impulse_volume;\r\nline6pcm->impulse_count = line6pcm->impulse_period;\r\n}\r\n}\r\nstatic void add_monitor_signal(struct urb *urb_out, unsigned char *signal,\r\nint volume, int bytes_per_frame)\r\n{\r\nif (volume == 0)\r\nreturn;\r\nif (bytes_per_frame == 4) {\r\nshort *pi, *po, *buf_end;\r\npi = (short *)signal;\r\npo = (short *)urb_out->transfer_buffer;\r\nbuf_end = po + urb_out->transfer_buffer_length / sizeof(*po);\r\nfor (; po < buf_end; ++pi, ++po)\r\n*po += (*pi * volume) >> 8;\r\n}\r\n}\r\nstatic int submit_audio_out_urb(struct snd_line6_pcm *line6pcm)\r\n{\r\nint index;\r\nunsigned long flags;\r\nint i, urb_size, urb_frames;\r\nint ret;\r\nconst int bytes_per_frame = line6pcm->properties->bytes_per_frame;\r\nconst int frame_increment =\r\nline6pcm->properties->snd_line6_rates.rats[0].num_min;\r\nconst int frame_factor =\r\nline6pcm->properties->snd_line6_rates.rats[0].den *\r\n(USB_INTERVALS_PER_SECOND / LINE6_ISO_INTERVAL);\r\nstruct urb *urb_out;\r\nspin_lock_irqsave(&line6pcm->lock_audio_out, flags);\r\nindex =\r\nfind_first_zero_bit(&line6pcm->active_urb_out, LINE6_ISO_BUFFERS);\r\nif (index < 0 || index >= LINE6_ISO_BUFFERS) {\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);\r\ndev_err(line6pcm->line6->ifcdev, "no free URB found\n");\r\nreturn -EINVAL;\r\n}\r\nurb_out = line6pcm->urb_audio_out[index];\r\nurb_size = 0;\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nint fsize = 0;\r\nstruct usb_iso_packet_descriptor *fout =\r\n&urb_out->iso_frame_desc[i];\r\nif (line6pcm->flags & LINE6_BITS_CAPTURE_STREAM)\r\nfsize = line6pcm->prev_fsize;\r\nif (fsize == 0) {\r\nint n;\r\nline6pcm->count_out += frame_increment;\r\nn = line6pcm->count_out / frame_factor;\r\nline6pcm->count_out -= n * frame_factor;\r\nfsize = n * bytes_per_frame;\r\n}\r\nfout->offset = urb_size;\r\nfout->length = fsize;\r\nurb_size += fsize;\r\n}\r\nif (urb_size == 0) {\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);\r\ndev_err(line6pcm->line6->ifcdev, "driver bug: urb_size = 0\n");\r\nreturn -EINVAL;\r\n}\r\nurb_frames = urb_size / bytes_per_frame;\r\nurb_out->transfer_buffer =\r\nline6pcm->buffer_out +\r\nindex * LINE6_ISO_PACKETS * line6pcm->max_packet_size;\r\nurb_out->transfer_buffer_length = urb_size;\r\nurb_out->context = line6pcm;\r\nif (test_bit(LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM, &line6pcm->flags) &&\r\n!test_bit(LINE6_INDEX_PAUSE_PLAYBACK, &line6pcm->flags)) {\r\nstruct snd_pcm_runtime *runtime =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_PLAYBACK)->runtime;\r\nif (line6pcm->pos_out + urb_frames > runtime->buffer_size) {\r\nint len;\r\nlen = runtime->buffer_size - line6pcm->pos_out;\r\nif (len > 0) {\r\nmemcpy(urb_out->transfer_buffer,\r\nruntime->dma_area +\r\nline6pcm->pos_out * bytes_per_frame,\r\nlen * bytes_per_frame);\r\nmemcpy(urb_out->transfer_buffer +\r\nlen * bytes_per_frame, runtime->dma_area,\r\n(urb_frames - len) * bytes_per_frame);\r\n} else\r\ndev_err(line6pcm->line6->ifcdev, "driver bug: len = %d\n",\r\nlen);\r\n} else {\r\nmemcpy(urb_out->transfer_buffer,\r\nruntime->dma_area +\r\nline6pcm->pos_out * bytes_per_frame,\r\nurb_out->transfer_buffer_length);\r\n}\r\nline6pcm->pos_out += urb_frames;\r\nif (line6pcm->pos_out >= runtime->buffer_size)\r\nline6pcm->pos_out -= runtime->buffer_size;\r\n} else {\r\nmemset(urb_out->transfer_buffer, 0,\r\nurb_out->transfer_buffer_length);\r\n}\r\nchange_volume(urb_out, line6pcm->volume_playback, bytes_per_frame);\r\nif (line6pcm->prev_fbuf != NULL) {\r\n#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE\r\nif (line6pcm->flags & LINE6_BITS_PCM_IMPULSE) {\r\ncreate_impulse_test_signal(line6pcm, urb_out,\r\nbytes_per_frame);\r\nif (line6pcm->flags & LINE6_BIT_PCM_ALSA_CAPTURE_STREAM) {\r\nline6_capture_copy(line6pcm,\r\nurb_out->transfer_buffer,\r\nurb_out->\r\ntransfer_buffer_length);\r\nline6_capture_check_period(line6pcm,\r\nurb_out->transfer_buffer_length);\r\n}\r\n} else {\r\n#endif\r\nif (!\r\n(line6pcm->line6->\r\nproperties->capabilities & LINE6_BIT_HWMON)\r\n&& (line6pcm->flags & LINE6_BITS_PLAYBACK_STREAM)\r\n&& (line6pcm->flags & LINE6_BITS_CAPTURE_STREAM))\r\nadd_monitor_signal(urb_out, line6pcm->prev_fbuf,\r\nline6pcm->volume_monitor,\r\nbytes_per_frame);\r\n#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE\r\n}\r\n#endif\r\n}\r\nret = usb_submit_urb(urb_out, GFP_ATOMIC);\r\nif (ret == 0)\r\nset_bit(index, &line6pcm->active_urb_out);\r\nelse\r\ndev_err(line6pcm->line6->ifcdev,\r\n"URB out #%d submission failed (%d)\n", index, ret);\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);\r\nreturn 0;\r\n}\r\nint line6_submit_audio_out_all_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < LINE6_ISO_BUFFERS; ++i) {\r\nret = submit_audio_out_urb(line6pcm);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid line6_unlink_audio_out_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nunsigned int i;\r\nfor (i = LINE6_ISO_BUFFERS; i--;) {\r\nif (test_bit(i, &line6pcm->active_urb_out)) {\r\nif (!test_and_set_bit(i, &line6pcm->unlink_urb_out)) {\r\nstruct urb *u = line6pcm->urb_audio_out[i];\r\nusb_unlink_urb(u);\r\n}\r\n}\r\n}\r\n}\r\nvoid line6_wait_clear_audio_out_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint timeout = HZ;\r\nunsigned int i;\r\nint alive;\r\ndo {\r\nalive = 0;\r\nfor (i = LINE6_ISO_BUFFERS; i--;) {\r\nif (test_bit(i, &line6pcm->active_urb_out))\r\nalive++;\r\n}\r\nif (!alive)\r\nbreak;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(1);\r\n} while (--timeout > 0);\r\nif (alive)\r\nsnd_printk(KERN_ERR "timeout: still %d active urbs..\n", alive);\r\n}\r\nvoid line6_unlink_wait_clear_audio_out_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nline6_unlink_audio_out_urbs(line6pcm);\r\nline6_wait_clear_audio_out_urbs(line6pcm);\r\n}\r\nvoid line6_free_playback_buffer(struct snd_line6_pcm *line6pcm)\r\n{\r\nkfree(line6pcm->buffer_out);\r\nline6pcm->buffer_out = NULL;\r\n}\r\nstatic void audio_out_callback(struct urb *urb)\r\n{\r\nint i, index, length = 0, shutdown = 0;\r\nunsigned long flags;\r\nstruct snd_line6_pcm *line6pcm = (struct snd_line6_pcm *)urb->context;\r\nstruct snd_pcm_substream *substream =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_PLAYBACK);\r\n#if USE_CLEAR_BUFFER_WORKAROUND\r\nmemset(urb->transfer_buffer, 0, urb->transfer_buffer_length);\r\n#endif\r\nline6pcm->last_frame_out = urb->start_frame;\r\nfor (index = LINE6_ISO_BUFFERS; index--;)\r\nif (urb == line6pcm->urb_audio_out[index])\r\nbreak;\r\nif (index < 0)\r\nreturn;\r\nfor (i = LINE6_ISO_PACKETS; i--;)\r\nlength += urb->iso_frame_desc[i].length;\r\nspin_lock_irqsave(&line6pcm->lock_audio_out, flags);\r\nif (test_bit(LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM, &line6pcm->flags)) {\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nline6pcm->pos_out_done +=\r\nlength / line6pcm->properties->bytes_per_frame;\r\nif (line6pcm->pos_out_done >= runtime->buffer_size)\r\nline6pcm->pos_out_done -= runtime->buffer_size;\r\n}\r\nclear_bit(index, &line6pcm->active_urb_out);\r\nfor (i = LINE6_ISO_PACKETS; i--;)\r\nif (urb->iso_frame_desc[i].status == -EXDEV) {\r\nshutdown = 1;\r\nbreak;\r\n}\r\nif (test_and_clear_bit(index, &line6pcm->unlink_urb_out))\r\nshutdown = 1;\r\nspin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);\r\nif (!shutdown) {\r\nsubmit_audio_out_urb(line6pcm);\r\nif (test_bit(LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM,\r\n&line6pcm->flags)) {\r\nline6pcm->bytes_out += length;\r\nif (line6pcm->bytes_out >= line6pcm->period_out) {\r\nline6pcm->bytes_out %= line6pcm->period_out;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\n}\r\n}\r\n}\r\nstatic int snd_line6_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nerr = snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n(&line6pcm->\r\nproperties->snd_line6_rates));\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw = line6pcm->properties->snd_line6_playback_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_line6_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint ret;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nif (line6pcm == NULL) {\r\nif (substream->pcm == NULL)\r\nreturn -ENOMEM;\r\nif (substream->pcm->private_data == NULL)\r\nreturn -ENOMEM;\r\nsubstream->private_data = substream->pcm->private_data;\r\nline6pcm = snd_pcm_substream_chip(substream);\r\n}\r\nret = line6_pcm_acquire(line6pcm, LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0) {\r\nline6_pcm_release(line6pcm, LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER);\r\nreturn ret;\r\n}\r\nline6pcm->period_out = params_period_bytes(hw_params);\r\nreturn 0;\r\n}\r\nstatic int snd_line6_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nline6_pcm_release(line6pcm, LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nint snd_line6_playback_trigger(struct snd_line6_pcm *line6pcm, int cmd)\r\n{\r\nint err;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\n#ifdef CONFIG_PM\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\n#endif\r\nerr = line6_pcm_acquire(line6pcm,\r\nLINE6_BIT_PCM_ALSA_PLAYBACK_STREAM);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\n#ifdef CONFIG_PM\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\n#endif\r\nerr = line6_pcm_release(line6pcm,\r\nLINE6_BIT_PCM_ALSA_PLAYBACK_STREAM);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nset_bit(LINE6_INDEX_PAUSE_PLAYBACK, &line6pcm->flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nclear_bit(LINE6_INDEX_PAUSE_PLAYBACK, &line6pcm->flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_line6_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nreturn line6pcm->pos_out_done;\r\n}\r\nint line6_create_audio_out_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint i;\r\nfor (i = 0; i < LINE6_ISO_BUFFERS; ++i) {\r\nstruct urb *urb;\r\nurb = line6pcm->urb_audio_out[i] =\r\nusb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndev_err(line6pcm->line6->ifcdev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nurb->dev = line6pcm->line6->usbdev;\r\nurb->pipe =\r\nusb_sndisocpipe(line6pcm->line6->usbdev,\r\nline6pcm->ep_audio_write &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->start_frame = -1;\r\nurb->number_of_packets = LINE6_ISO_PACKETS;\r\nurb->interval = LINE6_ISO_INTERVAL;\r\nurb->error_count = 0;\r\nurb->complete = audio_out_callback;\r\n}\r\nreturn 0;\r\n}
