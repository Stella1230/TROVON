static int cmux_set_parent(struct clk_hw *hw, u8 idx)\r\n{\r\nstruct cmux_clk *clk = to_cmux_clk(hw);\r\nu32 clksel;\r\nclksel = ((idx / clocks_per_pll) << 2) + idx % clocks_per_pll;\r\nif (clk->flags & CLKSEL_ADJUST)\r\nclksel += 8;\r\nclksel = (clksel & 0xf) << CLKSEL_SHIFT;\r\niowrite32be(clksel, clk->reg);\r\nreturn 0;\r\n}\r\nstatic u8 cmux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct cmux_clk *clk = to_cmux_clk(hw);\r\nu32 clksel;\r\nclksel = ioread32be(clk->reg);\r\nclksel = (clksel >> CLKSEL_SHIFT) & 0xf;\r\nif (clk->flags & CLKSEL_ADJUST)\r\nclksel -= 8;\r\nclksel = (clksel >> 2) * clocks_per_pll + clksel % 4;\r\nreturn clksel;\r\n}\r\nstatic void __init core_mux_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nstruct cmux_clk *cmux_clk;\r\nstruct device_node *node;\r\nint rc, count, i;\r\nu32 offset;\r\nconst char *clk_name;\r\nconst char **parent_names;\r\nrc = of_property_read_u32(np, "reg", &offset);\r\nif (rc) {\r\npr_err("%s: could not get reg property\n", np->name);\r\nreturn;\r\n}\r\ncount = of_property_count_strings(np, "clock-names");\r\nif (count < 0) {\r\npr_err("%s: get clock count error\n", np->name);\r\nreturn;\r\n}\r\nparent_names = kzalloc((sizeof(char *) * count), GFP_KERNEL);\r\nif (!parent_names) {\r\npr_err("%s: could not allocate parent_names\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0; i < count; i++)\r\nparent_names[i] = of_clk_get_parent_name(np, i);\r\ncmux_clk = kzalloc(sizeof(struct cmux_clk), GFP_KERNEL);\r\nif (!cmux_clk) {\r\npr_err("%s: could not allocate cmux_clk\n", __func__);\r\ngoto err_name;\r\n}\r\ncmux_clk->reg = base + offset;\r\nnode = of_find_compatible_node(NULL, NULL, "fsl,p4080-clockgen");\r\nif (node && (offset >= 0x80))\r\ncmux_clk->flags = CLKSEL_ADJUST;\r\nrc = of_property_read_string_index(np, "clock-output-names",\r\n0, &clk_name);\r\nif (rc) {\r\npr_err("%s: read clock names error\n", np->name);\r\ngoto err_clk;\r\n}\r\ninit.name = clk_name;\r\ninit.ops = &cmux_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = count;\r\ninit.flags = 0;\r\ncmux_clk->hw.init = &init;\r\nclk = clk_register(NULL, &cmux_clk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: could not register clock\n", clk_name);\r\ngoto err_clk;\r\n}\r\nrc = of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nif (rc) {\r\npr_err("Could not register clock provider for node:%s\n",\r\nnp->name);\r\ngoto err_clk;\r\n}\r\ngoto err_name;\r\nerr_clk:\r\nkfree(cmux_clk);\r\nerr_name:\r\nkfree(parent_names);\r\n}\r\nstatic void __init core_pll_init(struct device_node *np)\r\n{\r\nu32 offset, mult;\r\nint i, rc, count;\r\nconst char *clk_name, *parent_name;\r\nstruct clk_onecell_data *onecell_data;\r\nstruct clk **subclks;\r\nrc = of_property_read_u32(np, "reg", &offset);\r\nif (rc) {\r\npr_err("%s: could not get reg property\n", np->name);\r\nreturn;\r\n}\r\nmult = ioread32be(base + offset);\r\nif (mult & PLL_KILL) {\r\npr_debug("PLL:%s is disabled\n", np->name);\r\nreturn;\r\n}\r\nmult = (mult >> 1) & 0x3f;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name) {\r\npr_err("PLL: %s must have a parent\n", np->name);\r\nreturn;\r\n}\r\ncount = of_property_count_strings(np, "clock-output-names");\r\nif (count < 0 || count > 4) {\r\npr_err("%s: clock is not supported\n", np->name);\r\nreturn;\r\n}\r\nclocks_per_pll = count;\r\nsubclks = kzalloc(sizeof(struct clk *) * count, GFP_KERNEL);\r\nif (!subclks) {\r\npr_err("%s: could not allocate subclks\n", __func__);\r\nreturn;\r\n}\r\nonecell_data = kzalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\r\nif (!onecell_data) {\r\npr_err("%s: could not allocate onecell_data\n", __func__);\r\ngoto err_clks;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nrc = of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name);\r\nif (rc) {\r\npr_err("%s: could not get clock names\n", np->name);\r\ngoto err_cell;\r\n}\r\nif (count == 4)\r\nsubclks[i] = clk_register_fixed_factor(NULL, clk_name,\r\nparent_name, 0, mult, 1 + i);\r\nelse\r\nsubclks[i] = clk_register_fixed_factor(NULL, clk_name,\r\nparent_name, 0, mult, 1 << i);\r\nif (IS_ERR(subclks[i])) {\r\npr_err("%s: could not register clock\n", clk_name);\r\ngoto err_cell;\r\n}\r\n}\r\nonecell_data->clks = subclks;\r\nonecell_data->clk_num = count;\r\nrc = of_clk_add_provider(np, of_clk_src_onecell_get, onecell_data);\r\nif (rc) {\r\npr_err("Could not register clk provider for node:%s\n",\r\nnp->name);\r\ngoto err_cell;\r\n}\r\nreturn;\r\nerr_cell:\r\nkfree(onecell_data);\r\nerr_clks:\r\nkfree(subclks);\r\n}\r\nstatic int __init ppc_corenet_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np;\r\nnp = pdev->dev.of_node;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\ndev_err(&pdev->dev, "iomap error\n");\r\nreturn -ENOMEM;\r\n}\r\nof_clk_init(clk_match);\r\nreturn 0;\r\n}\r\nstatic int __init ppc_corenet_clk_init(void)\r\n{\r\nreturn platform_driver_register(&ppc_corenet_clk_driver);\r\n}
