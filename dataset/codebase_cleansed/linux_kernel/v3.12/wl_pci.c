int wl_adapter_init_module( void )\r\n{\r\nint result;\r\nDBG_FUNC( "wl_adapter_init_module()" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, "wl_adapter_init_module() -- PCI\n" );\r\nresult = pci_register_driver( &wl_driver );\r\nDBG_LEAVE( DbgInfo );\r\nreturn 0;\r\n}\r\nvoid wl_adapter_cleanup_module( void )\r\n{\r\nDBG_FUNC( "wl_adapter_cleanup_module" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, "wl_adapter_cleanup_module() -- PCI\n" );\r\npci_unregister_driver( &wl_driver );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nint wl_adapter_insert( struct net_device *dev )\r\n{\r\nint result = FALSE;\r\nDBG_FUNC( "wl_adapter_insert" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, "wl_adapter_insert() -- PCI\n" );\r\nif( dev == NULL ) {\r\nDBG_ERROR( DbgInfo, "net_device pointer is NULL!!!\n" );\r\n} else if( dev->priv == NULL ) {\r\nDBG_ERROR( DbgInfo, "wl_private pointer is NULL!!!\n" );\r\n} else if( wl_insert( dev ) ) {\r\nresult = TRUE;\r\n} else {\r\nDBG_TRACE( DbgInfo, "wl_insert() FAILED\n" );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n}\r\nint wl_adapter_open( struct net_device *dev )\r\n{\r\nint result = 0;\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( "wl_adapter_open" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, "wl_adapter_open() -- PCI\n" );\r\nhcf_status = wl_open( dev );\r\nif( hcf_status != HCF_SUCCESS ) {\r\nresult = -ENODEV;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n}\r\nint wl_adapter_close( struct net_device *dev )\r\n{\r\nDBG_FUNC( "wl_adapter_close" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, "wl_adapter_close() -- PCI\n" );\r\nDBG_TRACE( DbgInfo, "%s: Shutting down adapter.\n", dev->name );\r\nwl_close( dev );\r\nDBG_LEAVE( DbgInfo );\r\nreturn 0;\r\n}\r\nint wl_adapter_is_open( struct net_device *dev )\r\n{\r\nreturn TRUE;\r\n}\r\nint wl_pci_probe( struct pci_dev *pdev,\r\nconst struct pci_device_id *ent )\r\n{\r\nint result;\r\nDBG_FUNC( "wl_pci_probe" );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PRINT( "%s\n", VERSION_INFO );\r\nresult = wl_pci_setup( pdev );\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n}\r\nvoid wl_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = NULL;\r\nDBG_FUNC( "wl_pci_remove" );\r\nDBG_ENTER( DbgInfo );\r\nif( pdev == NULL ) {\r\nDBG_ERROR( DbgInfo, "PCI subsys passed in an invalid pci_dev pointer\n" );\r\nreturn;\r\n}\r\ndev = pci_get_drvdata( pdev );\r\nif( dev == NULL ) {\r\nDBG_ERROR( DbgInfo, "Could not retrieve net_device structure\n" );\r\nreturn;\r\n}\r\nwl_remove( dev );\r\nfree_irq( dev->irq, dev );\r\n#ifdef ENABLE_DMA\r\nwl_pci_dma_free( pdev, dev->priv );\r\n#endif\r\nwl_device_dealloc( dev );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nint wl_pci_setup( struct pci_dev *pdev )\r\n{\r\nint result = 0;\r\nstruct net_device *dev = NULL;\r\nstruct wl_private *lp = NULL;\r\nDBG_FUNC( "wl_pci_setup" );\r\nDBG_ENTER( DbgInfo );\r\nif( pdev == NULL ) {\r\nDBG_ERROR( DbgInfo, "PCI subsys passed in an invalid pci_dev pointer\n" );\r\nreturn -ENODEV;\r\n}\r\nresult = pci_enable_device( pdev );\r\nif( result != 0 ) {\r\nDBG_ERROR( DbgInfo, "pci_enable_device() failed\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n}\r\nDBG_TRACE( DbgInfo, "Found our device, now registering\n" );\r\ndev = wl_device_alloc( );\r\nif( dev == NULL ) {\r\nDBG_ERROR( DbgInfo, "Could not register device!!!\n" );\r\nDBG_LEAVE( DbgInfo );\r\nreturn -ENOMEM;\r\n}\r\nif( dev->priv == NULL ) {\r\nDBG_ERROR( DbgInfo, "Private adapter struct was not allocated!!!\n" );\r\nwl_device_dealloc(dev);\r\nDBG_LEAVE( DbgInfo );\r\nreturn -ENOMEM;\r\n}\r\n#ifdef ENABLE_DMA\r\nif( wl_pci_dma_alloc( pdev, dev->priv ) < 0 ) {\r\nDBG_ERROR( DbgInfo, "Could not allocate DMA descriptor memory!!!\n" );\r\nwl_device_dealloc(dev);\r\nDBG_LEAVE( DbgInfo );\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\npci_set_drvdata( pdev, dev );\r\ndev->irq = pdev->irq;\r\nSET_MODULE_OWNER( dev );\r\nDBG_TRACE( DbgInfo, "Device Base Address: %#03lx\n", pdev->resource[0].start );\r\ndev->base_addr = pdev->resource[0].start;\r\nif( !wl_adapter_insert( dev )) {\r\nDBG_ERROR( DbgInfo, "wl_adapter_insert() FAILED!!!\n" );\r\nwl_device_dealloc( dev );\r\nDBG_LEAVE( DbgInfo );\r\nreturn -EINVAL;\r\n}\r\nDBG_TRACE( DbgInfo, "Registering ISR...\n" );\r\nresult = request_irq(dev->irq, wl_isr, SA_SHIRQ, dev->name, dev);\r\nif( result ) {\r\nDBG_WARNING( DbgInfo, "Could not register ISR!!!\n" );\r\nwl_remove(dev);\r\nwl_device_dealloc(dev);\r\nDBG_LEAVE( DbgInfo );\r\nreturn result;\r\n}\r\nlp = dev->priv;\r\nif( lp->hcfCtx.IFB_BusType == CFG_NIC_BUS_TYPE_CARDBUS ||\r\nlp->hcfCtx.IFB_BusType == CFG_NIC_BUS_TYPE_PCI ) {\r\nDBG_TRACE( DbgInfo, "This is a PCI/CardBus card, enable interrupts\n" );\r\nwl_pci_enable_cardbus_interrupts( pdev );\r\n}\r\npci_set_master( pdev );\r\nDBG_LEAVE( DbgInfo );\r\nreturn 0;\r\n}\r\nvoid wl_pci_enable_cardbus_interrupts( struct pci_dev *pdev )\r\n{\r\nu32 bar2_reg;\r\nu32 mem_addr_bus;\r\nu32 func_evt_mask_reg;\r\nvoid *mem_addr_kern = NULL;\r\nDBG_FUNC( "wl_pci_enable_cardbus_interrupts" );\r\nDBG_ENTER( DbgInfo );\r\nbar2_reg = 0xdeadbeef;\r\nmem_addr_bus = 0xdeadbeef;\r\npci_read_config_dword( pdev, PCI_BASE_ADDRESS_2, &bar2_reg );\r\nmem_addr_bus = bar2_reg & PCI_BASE_ADDRESS_MEM_MASK;\r\nmem_addr_kern = ioremap( mem_addr_bus, 0x200 );\r\n#ifdef HERMES25\r\n#define REG_OFFSET 0x07F4\r\n#else\r\n#define REG_OFFSET 0x01F4\r\n#endif\r\n#define BIT15 0x8000\r\nfunc_evt_mask_reg = *(u32 *)( mem_addr_kern + REG_OFFSET );\r\nfunc_evt_mask_reg |= BIT15;\r\n*(u32 *)( mem_addr_kern + REG_OFFSET ) = func_evt_mask_reg;\r\niounmap( mem_addr_kern );\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nint wl_pci_dma_alloc( struct pci_dev *pdev, struct wl_private *lp )\r\n{\r\nint i;\r\nint status = 0;\r\nDBG_FUNC( "wl_pci_dma_alloc" );\r\nDBG_ENTER( DbgInfo );\r\nreturn status;\r\n}\r\nint wl_pci_dma_free( struct pci_dev *pdev, struct wl_private *lp )\r\n{\r\nint i;\r\nint status = 0;\r\nDBG_FUNC( "wl_pci_dma_free" );\r\nDBG_ENTER( DbgInfo );\r\nfor( i = 0; i < NUM_RX_DESC; i++ ) {\r\nif( lp->dma.rx_packet[i] ) {\r\nstatus = wl_pci_dma_free_rx_packet( pdev, lp, &lp->dma.rx_packet[i] );\r\nif( status != 0 ) {\r\nDBG_WARNING( DbgInfo, "Problem freeing Rx packet\n" );\r\n}\r\n}\r\n}\r\nlp->dma.rx_rsc_ind = 0;\r\nif( lp->dma.rx_reclaim_desc ) {\r\nstatus = wl_pci_dma_free_desc( pdev, lp, &lp->dma.rx_reclaim_desc );\r\nif( status != 0 ) {\r\nDBG_WARNING( DbgInfo, "Problem freeing Rx reclaim descriptor\n" );\r\n}\r\n}\r\nfor( i = 0; i < NUM_TX_DESC; i++ ) {\r\nif( lp->dma.tx_packet[i] ) {\r\nstatus = wl_pci_dma_free_tx_packet( pdev, lp, &lp->dma.tx_packet[i] );\r\nif( status != 0 ) {\r\nDBG_WARNING( DbgInfo, "Problem freeing Tx packet\n" );\r\n}\r\n}\r\n}\r\nlp->dma.tx_rsc_ind = 0;\r\nif( lp->dma.tx_reclaim_desc ) {\r\nstatus = wl_pci_dma_free_desc( pdev, lp, &lp->dma.tx_reclaim_desc );\r\nif( status != 0 ) {\r\nDBG_WARNING( DbgInfo, "Problem freeing Tx reclaim descriptor\n" );\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn status;\r\n}\r\nint wl_pci_dma_alloc_tx_packet( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\n}\r\nint wl_pci_dma_free_tx_packet( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\nint status = 0;\r\nif( *desc == NULL ) {\r\nDBG_PRINT( "Null descriptor\n" );\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 && (*desc)->next_desc_addr ) {\r\nstatus = wl_pci_dma_free_desc_and_buf( pdev, lp, &(*desc)->next_desc_addr );\r\n}\r\nif( status == 0 ) {\r\nstatus = wl_pci_dma_free_desc_and_buf( pdev, lp, desc );\r\n}\r\nreturn status;\r\n}\r\nint wl_pci_dma_alloc_rx_packet( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\nint status = 0;\r\nDESC_STRCT *p;\r\nreturn status;\r\n}\r\nint wl_pci_dma_free_rx_packet( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\nint status = 0;\r\nDESC_STRCT *p;\r\nif( *desc == NULL ) {\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 ) {\r\np = (*desc)->next_desc_addr;\r\nif( p != NULL ) {\r\np->buf_addr = NULL;\r\np->buf_phys_addr = 0;\r\nstatus = wl_pci_dma_free_desc( pdev, lp, &p );\r\n}\r\n}\r\nif( status == 0 ) {\r\nSET_BUF_SIZE( *desc, HCF_MAX_PACKET_SIZE );\r\nstatus = wl_pci_dma_free_desc_and_buf( pdev, lp, desc );\r\n}\r\nreturn status;\r\n}\r\nint wl_pci_dma_alloc_desc_and_buf( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc, int size )\r\n{\r\nint status = 0;\r\nreturn status;\r\n}\r\nint wl_pci_dma_free_desc_and_buf( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\nint status = 0;\r\nif( desc == NULL ) {\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 && *desc == NULL ) {\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 ) {\r\nstatus = wl_pci_dma_free_buf( pdev, lp, *desc );\r\nif( status == 0 ) {\r\nstatus = wl_pci_dma_free_desc( pdev, lp, desc );\r\n}\r\n}\r\nreturn status;\r\n}\r\nint wl_pci_dma_alloc_desc( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\n}\r\nint wl_pci_dma_free_desc( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT **desc )\r\n{\r\nint status = 0;\r\nif( *desc == NULL ) {\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 ) {\r\npci_free_consistent( pdev, sizeof( DESC_STRCT ), *desc,\r\n(*desc)->desc_phys_addr );\r\n}\r\n*desc = NULL;\r\nreturn status;\r\n}\r\nint wl_pci_dma_alloc_buf( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT *desc, int size )\r\n{\r\nint status = 0;\r\ndma_addr_t pa;\r\nreturn status;\r\n}\r\nint wl_pci_dma_free_buf( struct pci_dev *pdev, struct wl_private *lp,\r\nDESC_STRCT *desc )\r\n{\r\nint status = 0;\r\nif( desc == NULL ) {\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 && desc->buf_addr == NULL ) {\r\nstatus = -EFAULT;\r\n}\r\nif( status == 0 ) {\r\npci_free_consistent( pdev, GET_BUF_SIZE( desc ), desc->buf_addr,\r\ndesc->buf_phys_addr );\r\ndesc->buf_addr = 0;\r\ndesc->buf_phys_addr = 0;\r\nSET_BUF_SIZE( desc, 0 );\r\n}\r\nreturn status;\r\n}\r\nvoid wl_pci_dma_hcf_supply( struct wl_private *lp )\r\n{\r\nint i;\r\nDBG_FUNC( "wl_pci_dma_hcf_supply" );\r\nDBG_ENTER( DbgInfo );\r\nif( lp->dma.tx_reclaim_desc ) {\r\nDBG_PRINT( "lp->dma.tx_reclaim_desc: 0x%p\n", lp->dma.tx_reclaim_desc );\r\nhcf_dma_tx_put( &lp->hcfCtx, lp->dma.tx_reclaim_desc, 0 );\r\nlp->dma.tx_reclaim_desc = NULL;\r\nDBG_PRINT( "lp->dma.tx_reclaim_desc: 0x%p\n", lp->dma.tx_reclaim_desc );\r\n}\r\nif( lp->dma.rx_reclaim_desc ) {\r\nDBG_PRINT( "lp->dma.rx_reclaim_desc: 0x%p\n", lp->dma.rx_reclaim_desc );\r\nhcf_dma_rx_put( &lp->hcfCtx, lp->dma.rx_reclaim_desc );\r\nlp->dma.rx_reclaim_desc = NULL;\r\nDBG_PRINT( "lp->dma.rx_reclaim_desc: 0x%p\n", lp->dma.rx_reclaim_desc );\r\n}\r\nfor( i = 0; i < NUM_RX_DESC; i++ ) {\r\nDBG_PRINT( "lp->dma.rx_packet[%d]: 0x%p\n", i, lp->dma.rx_packet[i] );\r\nhcf_dma_rx_put( &lp->hcfCtx, lp->dma.rx_packet[i] );\r\nlp->dma.rx_packet[i] = NULL;\r\nDBG_PRINT( "lp->dma.rx_packet[%d]: 0x%p\n", i, lp->dma.rx_packet[i] );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nvoid wl_pci_dma_hcf_reclaim( struct wl_private *lp )\r\n{\r\nint i;\r\nDBG_FUNC( "wl_pci_dma_hcf_reclaim" );\r\nDBG_ENTER( DbgInfo );\r\nwl_pci_dma_hcf_reclaim_rx( lp );\r\nfor( i = 0; i < NUM_RX_DESC; i++ ) {\r\nDBG_PRINT( "rx_packet[%d] 0x%p\n", i, lp->dma.rx_packet[i] );\r\n}\r\nwl_pci_dma_hcf_reclaim_tx( lp );\r\nfor( i = 0; i < NUM_TX_DESC; i++ ) {\r\nDBG_PRINT( "tx_packet[%d] 0x%p\n", i, lp->dma.tx_packet[i] );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nvoid wl_pci_dma_hcf_reclaim_rx( struct wl_private *lp )\r\n{\r\nint i;\r\nDESC_STRCT *p;\r\nDBG_FUNC( "wl_pci_dma_hcf_reclaim_rx" );\r\nDBG_ENTER( DbgInfo );\r\nwhile ( ( p = hcf_dma_rx_get( &lp->hcfCtx ) ) != NULL ) {\r\nif( p && p->buf_addr == NULL ) {\r\nlp->dma.rx_reclaim_desc = p;\r\nDBG_PRINT( "reclaim_descriptor: 0x%p\n", p );\r\ncontinue;\r\n}\r\nfor( i = 0; i < NUM_RX_DESC; i++ ) {\r\nif( lp->dma.rx_packet[i] == NULL ) {\r\nbreak;\r\n}\r\n}\r\nlp->dma.rx_packet[i] = p;\r\nlp->dma.rx_rsc_ind++;\r\nDBG_PRINT( "rx_packet[%d] 0x%p\n", i, lp->dma.rx_packet[i] );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\n}\r\nDESC_STRCT * wl_pci_dma_get_tx_packet( struct wl_private *lp )\r\n{\r\nint i;\r\nDESC_STRCT *desc = NULL;\r\nfor( i = 0; i < NUM_TX_DESC; i++ ) {\r\nif( lp->dma.tx_packet[i] ) {\r\nbreak;\r\n}\r\n}\r\nif( i != NUM_TX_DESC ) {\r\ndesc = lp->dma.tx_packet[i];\r\nlp->dma.tx_packet[i] = NULL;\r\nlp->dma.tx_rsc_ind--;\r\nmemset( desc->buf_addr, 0, HCF_DMA_TX_BUF1_SIZE );\r\n}\r\nreturn desc;\r\n}\r\nvoid wl_pci_dma_put_tx_packet( struct wl_private *lp, DESC_STRCT *desc )\r\n{\r\nint i;\r\nfor( i = 0; i < NUM_TX_DESC; i++ ) {\r\nif( lp->dma.tx_packet[i] == NULL ) {\r\nbreak;\r\n}\r\n}\r\nif( i != NUM_TX_DESC ) {\r\nlp->dma.tx_packet[i] = desc;\r\nlp->dma.tx_rsc_ind++;\r\n}\r\n}\r\nvoid wl_pci_dma_hcf_reclaim_tx( struct wl_private *lp )\r\n{\r\nint i;\r\nDESC_STRCT *p;\r\nDBG_FUNC( "wl_pci_dma_hcf_reclaim_tx" );\r\nDBG_ENTER( DbgInfo );\r\nwhile ( ( p = hcf_dma_tx_get( &lp->hcfCtx ) ) != NULL ) {\r\nif( p != NULL && p->buf_addr == NULL ) {\r\nlp->dma.tx_reclaim_desc = p;\r\nDBG_PRINT( "reclaim_descriptor: 0x%p\n", p );\r\ncontinue;\r\n}\r\nfor( i = 0; i < NUM_TX_DESC; i++ ) {\r\nif( lp->dma.tx_packet[i] == NULL ) {\r\nbreak;\r\n}\r\n}\r\nlp->dma.tx_packet[i] = p;\r\nlp->dma.tx_rsc_ind++;\r\nDBG_PRINT( "tx_packet[%d] 0x%p\n", i, lp->dma.tx_packet[i] );\r\n}\r\nif( lp->netif_queue_on == FALSE ) {\r\nnetif_wake_queue( lp->dev );\r\nWL_WDS_NETIF_WAKE_QUEUE( lp );\r\nlp->netif_queue_on = TRUE;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}
