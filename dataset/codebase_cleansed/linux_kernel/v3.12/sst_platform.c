int sst_register_dsp(struct sst_device *dev)\r\n{\r\nBUG_ON(!dev);\r\nif (!try_module_get(dev->dev->driver->owner))\r\nreturn -ENODEV;\r\nmutex_lock(&sst_lock);\r\nif (sst) {\r\npr_err("we already have a device %s\n", sst->name);\r\nmodule_put(dev->dev->driver->owner);\r\nmutex_unlock(&sst_lock);\r\nreturn -EEXIST;\r\n}\r\npr_debug("registering device %s\n", dev->name);\r\nsst = dev;\r\nmutex_unlock(&sst_lock);\r\nreturn 0;\r\n}\r\nint sst_unregister_dsp(struct sst_device *dev)\r\n{\r\nBUG_ON(!dev);\r\nif (dev != sst)\r\nreturn -EINVAL;\r\nmutex_lock(&sst_lock);\r\nif (!sst) {\r\nmutex_unlock(&sst_lock);\r\nreturn -EIO;\r\n}\r\nmodule_put(sst->dev->driver->owner);\r\npr_debug("unreg %s\n", sst->name);\r\nsst = NULL;\r\nmutex_unlock(&sst_lock);\r\nreturn 0;\r\n}\r\nstatic inline void sst_set_stream_status(struct sst_runtime_stream *stream,\r\nint state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&stream->status_lock, flags);\r\nstream->stream_status = state;\r\nspin_unlock_irqrestore(&stream->status_lock, flags);\r\n}\r\nstatic inline int sst_get_stream_status(struct sst_runtime_stream *stream)\r\n{\r\nint state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&stream->status_lock, flags);\r\nstate = stream->stream_status;\r\nspin_unlock_irqrestore(&stream->status_lock, flags);\r\nreturn state;\r\n}\r\nstatic void sst_fill_pcm_params(struct snd_pcm_substream *substream,\r\nstruct sst_pcm_params *param)\r\n{\r\nparam->codec = SST_CODEC_TYPE_PCM;\r\nparam->num_chan = (u8) substream->runtime->channels;\r\nparam->pcm_wd_sz = substream->runtime->sample_bits;\r\nparam->reserved = 0;\r\nparam->sfreq = substream->runtime->rate;\r\nparam->ring_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\nparam->period_count = substream->runtime->period_size;\r\nparam->ring_buffer_addr = virt_to_phys(substream->dma_buffer.area);\r\npr_debug("period_cnt = %d\n", param->period_count);\r\npr_debug("sfreq= %d, wd_sz = %d\n", param->sfreq, param->pcm_wd_sz);\r\n}\r\nstatic int sst_platform_alloc_stream(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream =\r\nsubstream->runtime->private_data;\r\nstruct sst_pcm_params param = {0};\r\nstruct sst_stream_params str_params = {0};\r\nint ret_val;\r\nsst_fill_pcm_params(substream, &param);\r\nsubstream->runtime->dma_area = substream->dma_buffer.area;\r\nstr_params.sparams = param;\r\nstr_params.codec = param.codec;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nstr_params.ops = STREAM_OPS_PLAYBACK;\r\nstr_params.device_type = substream->pcm->device + 1;\r\npr_debug("Playbck stream,Device %d\n",\r\nsubstream->pcm->device);\r\n} else {\r\nstr_params.ops = STREAM_OPS_CAPTURE;\r\nstr_params.device_type = SND_SST_DEVICE_CAPTURE;\r\npr_debug("Capture stream,Device %d\n",\r\nsubstream->pcm->device);\r\n}\r\nret_val = stream->ops->open(&str_params);\r\npr_debug("SST_SND_PLAY/CAPTURE ret_val = %x\n", ret_val);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nstream->stream_info.str_id = ret_val;\r\npr_debug("str id : %d\n", stream->stream_info.str_id);\r\nreturn ret_val;\r\n}\r\nstatic void sst_period_elapsed(void *mad_substream)\r\n{\r\nstruct snd_pcm_substream *substream = mad_substream;\r\nstruct sst_runtime_stream *stream;\r\nint status;\r\nif (!substream || !substream->runtime)\r\nreturn;\r\nstream = substream->runtime->private_data;\r\nif (!stream)\r\nreturn;\r\nstatus = sst_get_stream_status(stream);\r\nif (status != SST_PLATFORM_RUNNING)\r\nreturn;\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int sst_platform_init_stream(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream =\r\nsubstream->runtime->private_data;\r\nint ret_val;\r\npr_debug("setting buffer ptr param\n");\r\nsst_set_stream_status(stream, SST_PLATFORM_INIT);\r\nstream->stream_info.period_elapsed = sst_period_elapsed;\r\nstream->stream_info.mad_substream = substream;\r\nstream->stream_info.buffer_ptr = 0;\r\nstream->stream_info.sfreq = substream->runtime->rate;\r\nret_val = stream->ops->device_control(\r\nSST_SND_STREAM_INIT, &stream->stream_info);\r\nif (ret_val)\r\npr_err("control_set ret error %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nstatic int sst_platform_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sst_runtime_stream *stream;\r\nint ret_val;\r\npr_debug("sst_platform_open called\n");\r\nsnd_soc_set_runtime_hwparams(substream, &sst_platform_pcm_hw);\r\nret_val = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (!stream)\r\nreturn -ENOMEM;\r\nspin_lock_init(&stream->status_lock);\r\nmutex_lock(&sst_lock);\r\nif (!sst) {\r\npr_err("no device available to run\n");\r\nmutex_unlock(&sst_lock);\r\nkfree(stream);\r\nreturn -ENODEV;\r\n}\r\nif (!try_module_get(sst->dev->driver->owner)) {\r\nmutex_unlock(&sst_lock);\r\nkfree(stream);\r\nreturn -ENODEV;\r\n}\r\nstream->ops = sst->ops;\r\nmutex_unlock(&sst_lock);\r\nstream->stream_info.str_id = 0;\r\nsst_set_stream_status(stream, SST_PLATFORM_INIT);\r\nstream->stream_info.mad_substream = substream;\r\nruntime->private_data = stream;\r\nreturn 0;\r\n}\r\nstatic int sst_platform_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val = 0, str_id;\r\npr_debug("sst_platform_close called\n");\r\nstream = substream->runtime->private_data;\r\nstr_id = stream->stream_info.str_id;\r\nif (str_id)\r\nret_val = stream->ops->close(str_id);\r\nmodule_put(sst->dev->driver->owner);\r\nkfree(stream);\r\nreturn ret_val;\r\n}\r\nstatic int sst_platform_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val = 0, str_id;\r\npr_debug("sst_platform_pcm_prepare called\n");\r\nstream = substream->runtime->private_data;\r\nstr_id = stream->stream_info.str_id;\r\nif (stream->stream_info.str_id) {\r\nret_val = stream->ops->device_control(\r\nSST_SND_DROP, &str_id);\r\nreturn ret_val;\r\n}\r\nret_val = sst_platform_alloc_stream(substream);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nsnprintf(substream->pcm->id, sizeof(substream->pcm->id),\r\n"%d", stream->stream_info.str_id);\r\nret_val = sst_platform_init_stream(substream);\r\nif (ret_val)\r\nreturn ret_val;\r\nsubstream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;\r\nreturn ret_val;\r\n}\r\nstatic int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nint ret_val = 0, str_id;\r\nstruct sst_runtime_stream *stream;\r\nint str_cmd, status;\r\npr_debug("sst_platform_pcm_trigger called\n");\r\nstream = substream->runtime->private_data;\r\nstr_id = stream->stream_info.str_id;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npr_debug("sst: Trigger Start\n");\r\nstr_cmd = SST_SND_START;\r\nstatus = SST_PLATFORM_RUNNING;\r\nstream->stream_info.mad_substream = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npr_debug("sst: in stop\n");\r\nstr_cmd = SST_SND_DROP;\r\nstatus = SST_PLATFORM_DROPPED;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\npr_debug("sst: in pause\n");\r\nstr_cmd = SST_SND_PAUSE;\r\nstatus = SST_PLATFORM_PAUSED;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\npr_debug("sst: in pause release\n");\r\nstr_cmd = SST_SND_RESUME;\r\nstatus = SST_PLATFORM_RUNNING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret_val = stream->ops->device_control(str_cmd, &str_id);\r\nif (!ret_val)\r\nsst_set_stream_status(stream, status);\r\nreturn ret_val;\r\n}\r\nstatic snd_pcm_uframes_t sst_platform_pcm_pointer\r\n(struct snd_pcm_substream *substream)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val, status;\r\nstruct pcm_stream_info *str_info;\r\nstream = substream->runtime->private_data;\r\nstatus = sst_get_stream_status(stream);\r\nif (status == SST_PLATFORM_INIT)\r\nreturn 0;\r\nstr_info = &stream->stream_info;\r\nret_val = stream->ops->device_control(\r\nSST_SND_BUFFER_POINTER, str_info);\r\nif (ret_val) {\r\npr_err("sst: error code = %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nreturn stream->stream_info.buffer_ptr;\r\n}\r\nstatic int sst_platform_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nsnd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nmemset(substream->runtime->dma_area, 0, params_buffer_bytes(params));\r\nreturn 0;\r\n}\r\nstatic int sst_platform_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void sst_pcm_free(struct snd_pcm *pcm)\r\n{\r\npr_debug("sst_pcm_free called\n");\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint retval = 0;\r\npr_debug("sst_pcm_new called\n");\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nretval = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\nSST_MIN_BUFFER, SST_MAX_BUFFER);\r\nif (retval) {\r\npr_err("dma buffer allocationf fail\n");\r\nreturn retval;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void sst_compr_fragment_elapsed(void *arg)\r\n{\r\nstruct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;\r\npr_debug("fragment elapsed by driver\n");\r\nif (cstream)\r\nsnd_compr_fragment_elapsed(cstream);\r\n}\r\nstatic int sst_platform_compr_open(struct snd_compr_stream *cstream)\r\n{\r\nint ret_val = 0;\r\nstruct snd_compr_runtime *runtime = cstream->runtime;\r\nstruct sst_runtime_stream *stream;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (!stream)\r\nreturn -ENOMEM;\r\nspin_lock_init(&stream->status_lock);\r\nif (!sst || !try_module_get(sst->dev->driver->owner)) {\r\npr_err("no device available to run\n");\r\nret_val = -ENODEV;\r\ngoto out_ops;\r\n}\r\nstream->compr_ops = sst->compr_ops;\r\nstream->id = 0;\r\nsst_set_stream_status(stream, SST_PLATFORM_INIT);\r\nruntime->private_data = stream;\r\nreturn 0;\r\nout_ops:\r\nkfree(stream);\r\nreturn ret_val;\r\n}\r\nstatic int sst_platform_compr_free(struct snd_compr_stream *cstream)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint ret_val = 0, str_id;\r\nstream = cstream->runtime->private_data;\r\nstr_id = stream->id;\r\nif (str_id)\r\nret_val = stream->compr_ops->close(str_id);\r\nmodule_put(sst->dev->driver->owner);\r\nkfree(stream);\r\npr_debug("%s: %d\n", __func__, ret_val);\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_set_params(struct snd_compr_stream *cstream,\r\nstruct snd_compr_params *params)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nint retval;\r\nstruct snd_sst_params str_params;\r\nstruct sst_compress_cb cb;\r\nstream = cstream->runtime->private_data;\r\nmemset(&str_params, 0, sizeof(str_params));\r\nstr_params.ops = STREAM_OPS_PLAYBACK;\r\nstr_params.stream_type = SST_STREAM_TYPE_MUSIC;\r\nstr_params.device_type = SND_SST_DEVICE_COMPRESS;\r\nswitch (params->codec.id) {\r\ncase SND_AUDIOCODEC_MP3: {\r\nstr_params.codec = SST_CODEC_TYPE_MP3;\r\nstr_params.sparams.uc.mp3_params.codec = SST_CODEC_TYPE_MP3;\r\nstr_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;\r\nstr_params.sparams.uc.mp3_params.pcm_wd_sz = 16;\r\nbreak;\r\n}\r\ncase SND_AUDIOCODEC_AAC: {\r\nstr_params.codec = SST_CODEC_TYPE_AAC;\r\nstr_params.sparams.uc.aac_params.codec = SST_CODEC_TYPE_AAC;\r\nstr_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;\r\nstr_params.sparams.uc.aac_params.pcm_wd_sz = 16;\r\nif (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)\r\nstr_params.sparams.uc.aac_params.bs_format =\r\nAAC_BIT_STREAM_ADTS;\r\nelse if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)\r\nstr_params.sparams.uc.aac_params.bs_format =\r\nAAC_BIT_STREAM_RAW;\r\nelse {\r\npr_err("Undefined format%d\n", params->codec.format);\r\nreturn -EINVAL;\r\n}\r\nstr_params.sparams.uc.aac_params.externalsr =\r\nparams->codec.sample_rate;\r\nbreak;\r\n}\r\ndefault:\r\npr_err("codec not supported, id =%d\n", params->codec.id);\r\nreturn -EINVAL;\r\n}\r\nstr_params.aparams.ring_buf_info[0].addr =\r\nvirt_to_phys(cstream->runtime->buffer);\r\nstr_params.aparams.ring_buf_info[0].size =\r\ncstream->runtime->buffer_size;\r\nstr_params.aparams.sg_count = 1;\r\nstr_params.aparams.frag_size = cstream->runtime->fragment_size;\r\ncb.param = cstream;\r\ncb.compr_cb = sst_compr_fragment_elapsed;\r\nretval = stream->compr_ops->open(&str_params, &cb);\r\nif (retval < 0) {\r\npr_err("stream allocation failed %d\n", retval);\r\nreturn retval;\r\n}\r\nstream->id = retval;\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->control(cmd, stream->id);\r\n}\r\nstatic int sst_platform_compr_pointer(struct snd_compr_stream *cstream,\r\nstruct snd_compr_tstamp *tstamp)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nstream = cstream->runtime->private_data;\r\nstream->compr_ops->tstamp(stream->id, tstamp);\r\ntstamp->byte_offset = tstamp->copied_total %\r\n(u32)cstream->runtime->buffer_size;\r\npr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_ack(struct snd_compr_stream *cstream,\r\nsize_t bytes)\r\n{\r\nstruct sst_runtime_stream *stream;\r\nstream = cstream->runtime->private_data;\r\nstream->compr_ops->ack(stream->id, (unsigned long)bytes);\r\nstream->bytes_written += bytes;\r\nreturn 0;\r\n}\r\nstatic int sst_platform_compr_get_caps(struct snd_compr_stream *cstream,\r\nstruct snd_compr_caps *caps)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->get_caps(caps);\r\n}\r\nstatic int sst_platform_compr_get_codec_caps(struct snd_compr_stream *cstream,\r\nstruct snd_compr_codec_caps *codec)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->get_codec_caps(codec);\r\n}\r\nstatic int sst_platform_compr_set_metadata(struct snd_compr_stream *cstream,\r\nstruct snd_compr_metadata *metadata)\r\n{\r\nstruct sst_runtime_stream *stream =\r\ncstream->runtime->private_data;\r\nreturn stream->compr_ops->set_metadata(stream->id, metadata);\r\n}\r\nstatic int sst_platform_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\npr_debug("sst_platform_probe called\n");\r\nsst = NULL;\r\nret = snd_soc_register_platform(&pdev->dev, &sst_soc_platform_drv);\r\nif (ret) {\r\npr_err("registering soc platform failed\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_register_component(&pdev->dev, &sst_component,\r\nsst_platform_dai, ARRAY_SIZE(sst_platform_dai));\r\nif (ret) {\r\npr_err("registering cpu dais failed\n");\r\nsnd_soc_unregister_platform(&pdev->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\npr_debug("sst_platform_remove success\n");\r\nreturn 0;\r\n}
