static void store_cursor_position(void)\r\n{\r\nstruct biosregs ireg, oreg;\r\ninitregs(&ireg);\r\nireg.ah = 0x03;\r\nintcall(0x10, &ireg, &oreg);\r\nboot_params.screen_info.orig_x = oreg.dl;\r\nboot_params.screen_info.orig_y = oreg.dh;\r\nif (oreg.ch & 0x20)\r\nboot_params.screen_info.flags |= VIDEO_FLAGS_NOCURSOR;\r\nif ((oreg.ch & 0x1f) > (oreg.cl & 0x1f))\r\nboot_params.screen_info.flags |= VIDEO_FLAGS_NOCURSOR;\r\n}\r\nstatic void store_video_mode(void)\r\n{\r\nstruct biosregs ireg, oreg;\r\ninitregs(&ireg);\r\nireg.ah = 0x0f;\r\nintcall(0x10, &ireg, &oreg);\r\nboot_params.screen_info.orig_video_mode = oreg.al & 0x7f;\r\nboot_params.screen_info.orig_video_page = oreg.bh;\r\n}\r\nstatic void store_mode_params(void)\r\n{\r\nu16 font_size;\r\nint x, y;\r\nif (graphic_mode)\r\nreturn;\r\nstore_cursor_position();\r\nstore_video_mode();\r\nif (boot_params.screen_info.orig_video_mode == 0x07) {\r\nvideo_segment = 0xb000;\r\n} else {\r\nvideo_segment = 0xb800;\r\n}\r\nset_fs(0);\r\nfont_size = rdfs16(0x485);\r\nboot_params.screen_info.orig_video_points = font_size;\r\nx = rdfs16(0x44a);\r\ny = (adapter == ADAPTER_CGA) ? 25 : rdfs8(0x484)+1;\r\nif (force_x)\r\nx = force_x;\r\nif (force_y)\r\ny = force_y;\r\nboot_params.screen_info.orig_video_cols = x;\r\nboot_params.screen_info.orig_video_lines = y;\r\n}\r\nstatic unsigned int get_entry(void)\r\n{\r\nchar entry_buf[4];\r\nint i, len = 0;\r\nint key;\r\nunsigned int v;\r\ndo {\r\nkey = getchar();\r\nif (key == '\b') {\r\nif (len > 0) {\r\nputs("\b \b");\r\nlen--;\r\n}\r\n} else if ((key >= '0' && key <= '9') ||\r\n(key >= 'A' && key <= 'Z') ||\r\n(key >= 'a' && key <= 'z')) {\r\nif (len < sizeof entry_buf) {\r\nentry_buf[len++] = key;\r\nputchar(key);\r\n}\r\n}\r\n} while (key != '\r');\r\nputchar('\n');\r\nif (len == 0)\r\nreturn VIDEO_CURRENT_MODE;\r\nv = 0;\r\nfor (i = 0; i < len; i++) {\r\nv <<= 4;\r\nkey = entry_buf[i] | 0x20;\r\nv += (key > '9') ? key-'a'+10 : key-'0';\r\n}\r\nreturn v;\r\n}\r\nstatic void display_menu(void)\r\n{\r\nstruct card_info *card;\r\nstruct mode_info *mi;\r\nchar ch;\r\nint i;\r\nint nmodes;\r\nint modes_per_line;\r\nint col;\r\nnmodes = 0;\r\nfor (card = video_cards; card < video_cards_end; card++)\r\nnmodes += card->nmodes;\r\nmodes_per_line = 1;\r\nif (nmodes >= 20)\r\nmodes_per_line = 3;\r\nfor (col = 0; col < modes_per_line; col++)\r\nputs("Mode: Resolution: Type: ");\r\nputchar('\n');\r\ncol = 0;\r\nch = '0';\r\nfor (card = video_cards; card < video_cards_end; card++) {\r\nmi = card->modes;\r\nfor (i = 0; i < card->nmodes; i++, mi++) {\r\nchar resbuf[32];\r\nint visible = mi->x && mi->y;\r\nu16 mode_id = mi->mode ? mi->mode :\r\n(mi->y << 8)+mi->x;\r\nif (!visible)\r\ncontinue;\r\nif (mi->depth)\r\nsprintf(resbuf, "%dx%d", mi->y, mi->depth);\r\nelse\r\nsprintf(resbuf, "%d", mi->y);\r\nprintf("%c %03X %4dx%-7s %-6s",\r\nch, mode_id, mi->x, resbuf, card->card_name);\r\ncol++;\r\nif (col >= modes_per_line) {\r\nputchar('\n');\r\ncol = 0;\r\n}\r\nif (ch == '9')\r\nch = 'a';\r\nelse if (ch == 'z' || ch == ' ')\r\nch = ' ';\r\nelse\r\nch++;\r\n}\r\n}\r\nif (col)\r\nputchar('\n');\r\n}\r\nstatic unsigned int mode_menu(void)\r\n{\r\nint key;\r\nunsigned int sel;\r\nputs("Press <ENTER> to see video modes available, "\r\n"<SPACE> to continue, or wait 30 sec\n");\r\nkbd_flush();\r\nwhile (1) {\r\nkey = getchar_timeout();\r\nif (key == ' ' || key == 0)\r\nreturn VIDEO_CURRENT_MODE;\r\nif (key == '\r')\r\nbreak;\r\nputchar('\a');\r\n}\r\nfor (;;) {\r\ndisplay_menu();\r\nputs("Enter a video mode or \"scan\" to scan for "\r\n"additional modes: ");\r\nsel = get_entry();\r\nif (sel != SCAN)\r\nreturn sel;\r\nprobe_cards(1);\r\n}\r\n}\r\nstatic void save_screen(void)\r\n{\r\nsaved.x = boot_params.screen_info.orig_video_cols;\r\nsaved.y = boot_params.screen_info.orig_video_lines;\r\nsaved.curx = boot_params.screen_info.orig_x;\r\nsaved.cury = boot_params.screen_info.orig_y;\r\nif (!heap_free(saved.x*saved.y*sizeof(u16)+512))\r\nreturn;\r\nsaved.data = GET_HEAP(u16, saved.x*saved.y);\r\nset_fs(video_segment);\r\ncopy_from_fs(saved.data, 0, saved.x*saved.y*sizeof(u16));\r\n}\r\nstatic void restore_screen(void)\r\n{\r\nint xs = boot_params.screen_info.orig_video_cols;\r\nint ys = boot_params.screen_info.orig_video_lines;\r\nint y;\r\naddr_t dst = 0;\r\nu16 *src = saved.data;\r\nstruct biosregs ireg;\r\nif (graphic_mode)\r\nreturn;\r\nif (!src)\r\nreturn;\r\nset_fs(video_segment);\r\nfor (y = 0; y < ys; y++) {\r\nint npad;\r\nif (y < saved.y) {\r\nint copy = (xs < saved.x) ? xs : saved.x;\r\ncopy_to_fs(dst, src, copy*sizeof(u16));\r\ndst += copy*sizeof(u16);\r\nsrc += saved.x;\r\nnpad = (xs < saved.x) ? 0 : xs-saved.x;\r\n} else {\r\nnpad = xs;\r\n}\r\nasm volatile("pushw %%es ; "\r\n"movw %2,%%es ; "\r\n"shrw %%cx ; "\r\n"jnc 1f ; "\r\n"stosw \n\t"\r\n"1: rep;stosl ; "\r\n"popw %%es"\r\n: "+D" (dst), "+c" (npad)\r\n: "bdS" (video_segment),\r\n"a" (0x07200720));\r\n}\r\nif (saved.curx >= xs)\r\nsaved.curx = xs-1;\r\nif (saved.cury >= ys)\r\nsaved.cury = ys-1;\r\ninitregs(&ireg);\r\nireg.ah = 0x02;\r\nireg.dh = saved.cury;\r\nireg.dl = saved.curx;\r\nintcall(0x10, &ireg, NULL);\r\nstore_cursor_position();\r\n}\r\nvoid set_video(void)\r\n{\r\nu16 mode = boot_params.hdr.vid_mode;\r\nRESET_HEAP();\r\nstore_mode_params();\r\nsave_screen();\r\nprobe_cards(0);\r\nfor (;;) {\r\nif (mode == ASK_VGA)\r\nmode = mode_menu();\r\nif (!set_mode(mode))\r\nbreak;\r\nprintf("Undefined video mode number: %x\n", mode);\r\nmode = ASK_VGA;\r\n}\r\nboot_params.hdr.vid_mode = mode;\r\nvesa_store_edid();\r\nstore_mode_params();\r\nif (do_restore)\r\nrestore_screen();\r\n}
