static void lirc_rx51_on(struct lirc_rx51 *lirc_rx51)\r\n{\r\nomap_dm_timer_set_pwm(lirc_rx51->pwm_timer, 0, 1,\r\nOMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE);\r\n}\r\nstatic void lirc_rx51_off(struct lirc_rx51 *lirc_rx51)\r\n{\r\nomap_dm_timer_set_pwm(lirc_rx51->pwm_timer, 0, 1,\r\nOMAP_TIMER_TRIGGER_NONE);\r\n}\r\nstatic int init_timing_params(struct lirc_rx51 *lirc_rx51)\r\n{\r\nu32 load, match;\r\nload = -(lirc_rx51->fclk_khz * 1000 / lirc_rx51->freq);\r\nmatch = -(lirc_rx51->duty_cycle * -load / 100);\r\nomap_dm_timer_set_load(lirc_rx51->pwm_timer, 1, load);\r\nomap_dm_timer_set_match(lirc_rx51->pwm_timer, 1, match);\r\nomap_dm_timer_write_counter(lirc_rx51->pwm_timer, TIMER_MAX_VALUE - 2);\r\nomap_dm_timer_start(lirc_rx51->pwm_timer);\r\nomap_dm_timer_set_int_enable(lirc_rx51->pulse_timer, 0);\r\nomap_dm_timer_start(lirc_rx51->pulse_timer);\r\nlirc_rx51->match = 0;\r\nreturn 0;\r\n}\r\nstatic int pulse_timer_set_timeout(struct lirc_rx51 *lirc_rx51, int usec)\r\n{\r\nint counter;\r\nBUG_ON(usec < 0);\r\nif (lirc_rx51->match == 0)\r\ncounter = omap_dm_timer_read_counter(lirc_rx51->pulse_timer);\r\nelse\r\ncounter = lirc_rx51->match;\r\ncounter += (u32)(lirc_rx51->fclk_khz * usec / (1000));\r\nomap_dm_timer_set_match(lirc_rx51->pulse_timer, 1, counter);\r\nomap_dm_timer_set_int_enable(lirc_rx51->pulse_timer,\r\nOMAP_TIMER_INT_MATCH);\r\nif (tics_after(omap_dm_timer_read_counter(lirc_rx51->pulse_timer),\r\ncounter)) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lirc_rx51_interrupt_handler(int irq, void *ptr)\r\n{\r\nunsigned int retval;\r\nstruct lirc_rx51 *lirc_rx51 = ptr;\r\nretval = omap_dm_timer_read_status(lirc_rx51->pulse_timer);\r\nif (!retval)\r\nreturn IRQ_NONE;\r\nif (retval & ~OMAP_TIMER_INT_MATCH)\r\ndev_err_ratelimited(lirc_rx51->dev,\r\n": Unexpected interrupt source: %x\n", retval);\r\nomap_dm_timer_write_status(lirc_rx51->pulse_timer,\r\nOMAP_TIMER_INT_MATCH |\r\nOMAP_TIMER_INT_OVERFLOW |\r\nOMAP_TIMER_INT_CAPTURE);\r\nif (lirc_rx51->wbuf_index < 0) {\r\ndev_err_ratelimited(lirc_rx51->dev,\r\n": BUG wbuf_index has value of %i\n",\r\nlirc_rx51->wbuf_index);\r\ngoto end;\r\n}\r\ndo {\r\nif (lirc_rx51->wbuf_index >= WBUF_LEN)\r\ngoto end;\r\nif (lirc_rx51->wbuf[lirc_rx51->wbuf_index] == -1)\r\ngoto end;\r\nif (lirc_rx51->wbuf_index % 2)\r\nlirc_rx51_off(lirc_rx51);\r\nelse\r\nlirc_rx51_on(lirc_rx51);\r\nretval = pulse_timer_set_timeout(lirc_rx51,\r\nlirc_rx51->wbuf[lirc_rx51->wbuf_index]);\r\nlirc_rx51->wbuf_index++;\r\n} while (retval);\r\nreturn IRQ_HANDLED;\r\nend:\r\nlirc_rx51_off(lirc_rx51);\r\nlirc_rx51->wbuf_index = -1;\r\nomap_dm_timer_stop(lirc_rx51->pwm_timer);\r\nomap_dm_timer_stop(lirc_rx51->pulse_timer);\r\nomap_dm_timer_set_int_enable(lirc_rx51->pulse_timer, 0);\r\nwake_up_interruptible(&lirc_rx51->wqueue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lirc_rx51_init_port(struct lirc_rx51 *lirc_rx51)\r\n{\r\nstruct clk *clk_fclk;\r\nint retval, pwm_timer = lirc_rx51->pwm_timer_num;\r\nlirc_rx51->pwm_timer = omap_dm_timer_request_specific(pwm_timer);\r\nif (lirc_rx51->pwm_timer == NULL) {\r\ndev_err(lirc_rx51->dev, ": Error requesting GPT%d timer\n",\r\npwm_timer);\r\nreturn -EBUSY;\r\n}\r\nlirc_rx51->pulse_timer = omap_dm_timer_request();\r\nif (lirc_rx51->pulse_timer == NULL) {\r\ndev_err(lirc_rx51->dev, ": Error requesting pulse timer\n");\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\nomap_dm_timer_set_source(lirc_rx51->pwm_timer, OMAP_TIMER_SRC_SYS_CLK);\r\nomap_dm_timer_set_source(lirc_rx51->pulse_timer,\r\nOMAP_TIMER_SRC_SYS_CLK);\r\nomap_dm_timer_enable(lirc_rx51->pwm_timer);\r\nomap_dm_timer_enable(lirc_rx51->pulse_timer);\r\nlirc_rx51->irq_num = omap_dm_timer_get_irq(lirc_rx51->pulse_timer);\r\nretval = request_irq(lirc_rx51->irq_num, lirc_rx51_interrupt_handler,\r\nIRQF_DISABLED | IRQF_SHARED,\r\n"lirc_pulse_timer", lirc_rx51);\r\nif (retval) {\r\ndev_err(lirc_rx51->dev, ": Failed to request interrupt line\n");\r\ngoto err2;\r\n}\r\nclk_fclk = omap_dm_timer_get_fclk(lirc_rx51->pwm_timer);\r\nlirc_rx51->fclk_khz = clk_fclk->rate / 1000;\r\nreturn 0;\r\nerr2:\r\nomap_dm_timer_free(lirc_rx51->pulse_timer);\r\nerr1:\r\nomap_dm_timer_free(lirc_rx51->pwm_timer);\r\nreturn retval;\r\n}\r\nstatic int lirc_rx51_free_port(struct lirc_rx51 *lirc_rx51)\r\n{\r\nomap_dm_timer_set_int_enable(lirc_rx51->pulse_timer, 0);\r\nfree_irq(lirc_rx51->irq_num, lirc_rx51);\r\nlirc_rx51_off(lirc_rx51);\r\nomap_dm_timer_disable(lirc_rx51->pwm_timer);\r\nomap_dm_timer_disable(lirc_rx51->pulse_timer);\r\nomap_dm_timer_free(lirc_rx51->pwm_timer);\r\nomap_dm_timer_free(lirc_rx51->pulse_timer);\r\nlirc_rx51->wbuf_index = -1;\r\nreturn 0;\r\n}\r\nstatic ssize_t lirc_rx51_write(struct file *file, const char *buf,\r\nsize_t n, loff_t *ppos)\r\n{\r\nint count, i;\r\nstruct lirc_rx51 *lirc_rx51 = file->private_data;\r\nif (n % sizeof(int))\r\nreturn -EINVAL;\r\ncount = n / sizeof(int);\r\nif ((count > WBUF_LEN) || (count % 2 == 0))\r\nreturn -EINVAL;\r\nwait_event_interruptible(lirc_rx51->wqueue, lirc_rx51->wbuf_index < 0);\r\nif (copy_from_user(lirc_rx51->wbuf, buf, n))\r\nreturn -EFAULT;\r\nfor (i = 0; i < count; i++)\r\nif (lirc_rx51->wbuf[i] < 0)\r\nreturn -EINVAL;\r\ninit_timing_params(lirc_rx51);\r\nif (count < WBUF_LEN)\r\nlirc_rx51->wbuf[count] = -1;\r\nlirc_rx51->pdata->set_max_mpu_wakeup_lat(lirc_rx51->dev, 50);\r\nlirc_rx51_on(lirc_rx51);\r\nlirc_rx51->wbuf_index = 1;\r\npulse_timer_set_timeout(lirc_rx51, lirc_rx51->wbuf[0]);\r\nwait_event_interruptible(lirc_rx51->wqueue, lirc_rx51->wbuf_index < 0);\r\nlirc_rx51->pdata->set_max_mpu_wakeup_lat(lirc_rx51->dev, -1);\r\nreturn n;\r\n}\r\nstatic long lirc_rx51_ioctl(struct file *filep,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint result;\r\nunsigned long value;\r\nunsigned int ivalue;\r\nstruct lirc_rx51 *lirc_rx51 = filep->private_data;\r\nswitch (cmd) {\r\ncase LIRC_GET_SEND_MODE:\r\nresult = put_user(LIRC_MODE_PULSE, (unsigned long *)arg);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\nresult = get_user(value, (unsigned long *)arg);\r\nif (result)\r\nreturn result;\r\nif (value != LIRC_MODE_PULSE)\r\nreturn -ENOSYS;\r\nbreak;\r\ncase LIRC_GET_REC_MODE:\r\nresult = put_user(0, (unsigned long *) arg);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ncase LIRC_GET_LENGTH:\r\nreturn -ENOSYS;\r\nbreak;\r\ncase LIRC_SET_SEND_DUTY_CYCLE:\r\nresult = get_user(ivalue, (unsigned int *) arg);\r\nif (result)\r\nreturn result;\r\nif (ivalue <= 0 || ivalue > 100) {\r\ndev_err(lirc_rx51->dev, ": invalid duty cycle %d\n",\r\nivalue);\r\nreturn -EINVAL;\r\n}\r\nlirc_rx51->duty_cycle = ivalue;\r\nbreak;\r\ncase LIRC_SET_SEND_CARRIER:\r\nresult = get_user(ivalue, (unsigned int *) arg);\r\nif (result)\r\nreturn result;\r\nif (ivalue > 500000 || ivalue < 20000) {\r\ndev_err(lirc_rx51->dev, ": invalid carrier freq %d\n",\r\nivalue);\r\nreturn -EINVAL;\r\n}\r\nlirc_rx51->freq = ivalue;\r\nbreak;\r\ncase LIRC_GET_FEATURES:\r\nresult = put_user(LIRC_RX51_DRIVER_FEATURES,\r\n(unsigned long *) arg);\r\nif (result)\r\nreturn result;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lirc_rx51_open(struct inode *inode, struct file *file)\r\n{\r\nstruct lirc_rx51 *lirc_rx51 = lirc_get_pdata(file);\r\nBUG_ON(!lirc_rx51);\r\nfile->private_data = lirc_rx51;\r\nif (test_and_set_bit(1, &lirc_rx51->device_is_open))\r\nreturn -EBUSY;\r\nreturn lirc_rx51_init_port(lirc_rx51);\r\n}\r\nstatic int lirc_rx51_release(struct inode *inode, struct file *file)\r\n{\r\nstruct lirc_rx51 *lirc_rx51 = file->private_data;\r\nlirc_rx51_free_port(lirc_rx51);\r\nclear_bit(1, &lirc_rx51->device_is_open);\r\nreturn 0;\r\n}\r\nstatic int lirc_rx51_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nif (test_and_set_bit(1, &lirc_rx51.device_is_open))\r\nreturn -EAGAIN;\r\nclear_bit(1, &lirc_rx51.device_is_open);\r\nreturn 0;\r\n}\r\nstatic int lirc_rx51_resume(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lirc_rx51_probe(struct platform_device *dev)\r\n{\r\nlirc_rx51_driver.features = LIRC_RX51_DRIVER_FEATURES;\r\nlirc_rx51.pdata = dev->dev.platform_data;\r\nlirc_rx51.pwm_timer_num = lirc_rx51.pdata->pwm_timer;\r\nlirc_rx51.dev = &dev->dev;\r\nlirc_rx51_driver.dev = &dev->dev;\r\nlirc_rx51_driver.minor = lirc_register_driver(&lirc_rx51_driver);\r\ninit_waitqueue_head(&lirc_rx51.wqueue);\r\nif (lirc_rx51_driver.minor < 0) {\r\ndev_err(lirc_rx51.dev, ": lirc_register_driver failed: %d\n",\r\nlirc_rx51_driver.minor);\r\nreturn lirc_rx51_driver.minor;\r\n}\r\ndev_info(lirc_rx51.dev, "registration ok, minor: %d, pwm: %d\n",\r\nlirc_rx51_driver.minor, lirc_rx51.pwm_timer_num);\r\nreturn 0;\r\n}\r\nstatic int lirc_rx51_remove(struct platform_device *dev)\r\n{\r\nreturn lirc_unregister_driver(lirc_rx51_driver.minor);\r\n}
