static int __init gfs_init(void)\r\n{\r\nint i;\r\nENTER();\r\nif (!func_num) {\r\ngfs_single_func = true;\r\nfunc_num = 1;\r\n}\r\nffs_tab = kcalloc(func_num, sizeof *ffs_tab, GFP_KERNEL);\r\nif (!ffs_tab)\r\nreturn -ENOMEM;\r\nif (!gfs_single_func)\r\nfor (i = 0; i < func_num; i++)\r\nffs_tab[i].name = func_names[i];\r\nmissing_funcs = func_num;\r\nreturn functionfs_init();\r\n}\r\nstatic void __exit gfs_exit(void)\r\n{\r\nENTER();\r\nmutex_lock(&gfs_lock);\r\nif (gfs_registered)\r\nusb_composite_unregister(&gfs_driver);\r\ngfs_registered = false;\r\nfunctionfs_cleanup();\r\nmutex_unlock(&gfs_lock);\r\nkfree(ffs_tab);\r\n}\r\nstatic struct gfs_ffs_obj *gfs_find_dev(const char *dev_name)\r\n{\r\nint i;\r\nENTER();\r\nif (gfs_single_func)\r\nreturn &ffs_tab[0];\r\nfor (i = 0; i < func_num; i++)\r\nif (strcmp(ffs_tab[i].name, dev_name) == 0)\r\nreturn &ffs_tab[i];\r\nreturn NULL;\r\n}\r\nstatic int functionfs_ready_callback(struct ffs_data *ffs)\r\n{\r\nstruct gfs_ffs_obj *ffs_obj;\r\nint ret;\r\nENTER();\r\nmutex_lock(&gfs_lock);\r\nffs_obj = ffs->private_data;\r\nif (!ffs_obj) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (WARN_ON(ffs_obj->desc_ready)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nffs_obj->desc_ready = true;\r\nffs_obj->ffs_data = ffs;\r\nif (--missing_funcs) {\r\nret = 0;\r\ngoto done;\r\n}\r\nif (gfs_registered) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\ngfs_registered = true;\r\nret = usb_composite_probe(&gfs_driver);\r\nif (unlikely(ret < 0))\r\ngfs_registered = false;\r\ndone:\r\nmutex_unlock(&gfs_lock);\r\nreturn ret;\r\n}\r\nstatic void functionfs_closed_callback(struct ffs_data *ffs)\r\n{\r\nstruct gfs_ffs_obj *ffs_obj;\r\nENTER();\r\nmutex_lock(&gfs_lock);\r\nffs_obj = ffs->private_data;\r\nif (!ffs_obj)\r\ngoto done;\r\nffs_obj->desc_ready = false;\r\nmissing_funcs++;\r\nif (gfs_registered)\r\nusb_composite_unregister(&gfs_driver);\r\ngfs_registered = false;\r\ndone:\r\nmutex_unlock(&gfs_lock);\r\n}\r\nstatic void *functionfs_acquire_dev_callback(const char *dev_name)\r\n{\r\nstruct gfs_ffs_obj *ffs_dev;\r\nENTER();\r\nmutex_lock(&gfs_lock);\r\nffs_dev = gfs_find_dev(dev_name);\r\nif (!ffs_dev) {\r\nffs_dev = ERR_PTR(-ENODEV);\r\ngoto done;\r\n}\r\nif (ffs_dev->mounted) {\r\nffs_dev = ERR_PTR(-EBUSY);\r\ngoto done;\r\n}\r\nffs_dev->mounted = true;\r\ndone:\r\nmutex_unlock(&gfs_lock);\r\nreturn ffs_dev;\r\n}\r\nstatic void functionfs_release_dev_callback(struct ffs_data *ffs_data)\r\n{\r\nstruct gfs_ffs_obj *ffs_dev;\r\nENTER();\r\nmutex_lock(&gfs_lock);\r\nffs_dev = ffs_data->private_data;\r\nif (ffs_dev)\r\nffs_dev->mounted = false;\r\nmutex_unlock(&gfs_lock);\r\n}\r\nstatic int gfs_bind(struct usb_composite_dev *cdev)\r\n{\r\nint ret, i;\r\nENTER();\r\nif (missing_funcs)\r\nreturn -ENODEV;\r\n#if defined CONFIG_USB_FUNCTIONFS_ETH || defined CONFIG_USB_FUNCTIONFS_RNDIS\r\nthe_dev = gether_setup(cdev->gadget, dev_addr, host_addr, gfs_host_mac,\r\nqmult);\r\n#endif\r\nif (IS_ERR(the_dev)) {\r\nret = PTR_ERR(the_dev);\r\ngoto error_quick;\r\n}\r\ngfs_ether_setup = true;\r\nret = usb_string_ids_tab(cdev, gfs_strings);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\ngfs_dev_desc.iProduct = gfs_strings[USB_GADGET_PRODUCT_IDX].id;\r\nfor (i = func_num; i--; ) {\r\nret = functionfs_bind(ffs_tab[i].ffs_data, cdev);\r\nif (unlikely(ret < 0)) {\r\nwhile (++i < func_num)\r\nfunctionfs_unbind(ffs_tab[i].ffs_data);\r\ngoto error;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(gfs_configurations); ++i) {\r\nstruct gfs_configuration *c = gfs_configurations + i;\r\nint sid = USB_GADGET_FIRST_AVAIL_IDX + i;\r\nc->c.label = gfs_strings[sid].s;\r\nc->c.iConfiguration = gfs_strings[sid].id;\r\nc->c.bConfigurationValue = 1 + i;\r\nc->c.bmAttributes = USB_CONFIG_ATT_SELFPOWER;\r\nret = usb_add_config(cdev, &c->c, gfs_do_config);\r\nif (unlikely(ret < 0))\r\ngoto error_unbind;\r\n}\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nreturn 0;\r\nerror_unbind:\r\nfor (i = 0; i < func_num; i++)\r\nfunctionfs_unbind(ffs_tab[i].ffs_data);\r\nerror:\r\ngether_cleanup(the_dev);\r\nerror_quick:\r\ngfs_ether_setup = false;\r\nreturn ret;\r\n}\r\nstatic int gfs_unbind(struct usb_composite_dev *cdev)\r\n{\r\nint i;\r\nENTER();\r\nif (gfs_ether_setup)\r\ngether_cleanup(the_dev);\r\ngfs_ether_setup = false;\r\nfor (i = func_num; i--; )\r\nif (ffs_tab[i].ffs_data)\r\nfunctionfs_unbind(ffs_tab[i].ffs_data);\r\nreturn 0;\r\n}\r\nstatic int gfs_do_config(struct usb_configuration *c)\r\n{\r\nstruct gfs_configuration *gc =\r\ncontainer_of(c, struct gfs_configuration, c);\r\nint i;\r\nint ret;\r\nif (missing_funcs)\r\nreturn -ENODEV;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = gfs_otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nif (gc->eth) {\r\nret = gc->eth(c, gfs_host_mac, the_dev);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n}\r\nfor (i = 0; i < func_num; i++) {\r\nret = functionfs_bind_config(c->cdev, c, ffs_tab[i].ffs_data);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n}\r\nif (c->next_interface_id < ARRAY_SIZE(c->interface))\r\nc->interface[c->next_interface_id] = NULL;\r\nreturn 0;\r\n}\r\nstatic int eth_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],\r\nstruct eth_dev *dev)\r\n{\r\nreturn can_support_ecm(c->cdev->gadget)\r\n? ecm_bind_config(c, ethaddr, dev)\r\n: geth_bind_config(c, ethaddr, dev);\r\n}
