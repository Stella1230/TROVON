static void sep_do_callback(struct work_struct *work)\r\n{\r\nstruct sep_work_struct *sep_work = container_of(work,\r\nstruct sep_work_struct, work);\r\nif (sep_work != NULL) {\r\n(sep_work->callback)(sep_work->data);\r\nkfree(sep_work);\r\n} else {\r\npr_debug("sep crypto: do callback - NULL container\n");\r\n}\r\n}\r\nstatic int sep_submit_work(struct workqueue_struct *work_queue,\r\nvoid(*funct)(void *),\r\nvoid *data)\r\n{\r\nstruct sep_work_struct *sep_work;\r\nint result;\r\nsep_work = kmalloc(sizeof(struct sep_work_struct), GFP_ATOMIC);\r\nif (sep_work == NULL) {\r\npr_debug("sep crypto: cant allocate work structure\n");\r\nreturn -ENOMEM;\r\n}\r\nsep_work->callback = funct;\r\nsep_work->data = data;\r\nINIT_WORK(&sep_work->work, sep_do_callback);\r\nresult = queue_work(work_queue, &sep_work->work);\r\nif (!result) {\r\npr_debug("sep_crypto: queue_work failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct scatterlist *sep_alloc_sg_buf(\r\nstruct sep_device *sep,\r\nsize_t size,\r\nsize_t block_size)\r\n{\r\nu32 nbr_pages;\r\nu32 ct1;\r\nvoid *buf;\r\nsize_t current_size;\r\nsize_t real_page_size;\r\nstruct scatterlist *sg, *sg_temp;\r\nif (size == 0)\r\nreturn NULL;\r\ndev_dbg(&sep->pdev->dev, "sep alloc sg buf\n");\r\ncurrent_size = 0;\r\nnbr_pages = 0;\r\nreal_page_size = PAGE_SIZE - (PAGE_SIZE % block_size);\r\nwhile (current_size < size) {\r\ncurrent_size += real_page_size;\r\nnbr_pages += 1;\r\n}\r\nsg = kmalloc_array(nbr_pages, sizeof(struct scatterlist), GFP_ATOMIC);\r\nif (!sg)\r\nreturn NULL;\r\nsg_init_table(sg, nbr_pages);\r\ncurrent_size = 0;\r\nsg_temp = sg;\r\nfor (ct1 = 0; ct1 < nbr_pages; ct1 += 1) {\r\nbuf = (void *)get_zeroed_page(GFP_ATOMIC);\r\nif (!buf) {\r\ndev_warn(&sep->pdev->dev,\r\n"Cannot allocate page for new buffer\n");\r\nkfree(sg);\r\nreturn NULL;\r\n}\r\nsg_set_buf(sg_temp, buf, real_page_size);\r\nif ((size - current_size) > real_page_size) {\r\nsg_temp->length = real_page_size;\r\ncurrent_size += real_page_size;\r\n} else {\r\nsg_temp->length = (size - current_size);\r\ncurrent_size = size;\r\n}\r\nsg_temp = sg_next(sg);\r\n}\r\nreturn sg;\r\n}\r\nstatic void sep_free_sg_buf(struct scatterlist *sg)\r\n{\r\nstruct scatterlist *sg_temp = sg;\r\nwhile (sg_temp) {\r\nfree_page((unsigned long)sg_virt(sg_temp));\r\nsg_temp = sg_next(sg_temp);\r\n}\r\nkfree(sg);\r\n}\r\nstatic void sep_copy_sg(\r\nstruct sep_device *sep,\r\nstruct scatterlist *sg_src,\r\nstruct scatterlist *sg_dst,\r\nsize_t size)\r\n{\r\nu32 seg_size;\r\nu32 in_offset, out_offset;\r\nu32 count = 0;\r\nstruct scatterlist *sg_src_tmp = sg_src;\r\nstruct scatterlist *sg_dst_tmp = sg_dst;\r\nin_offset = 0;\r\nout_offset = 0;\r\ndev_dbg(&sep->pdev->dev, "sep copy sg\n");\r\nif ((sg_src == NULL) || (sg_dst == NULL) || (size == 0))\r\nreturn;\r\ndev_dbg(&sep->pdev->dev, "sep copy sg not null\n");\r\nwhile (count < size) {\r\nif ((sg_src_tmp->length - in_offset) >\r\n(sg_dst_tmp->length - out_offset))\r\nseg_size = sg_dst_tmp->length - out_offset;\r\nelse\r\nseg_size = sg_src_tmp->length - in_offset;\r\nif (seg_size > (size - count))\r\nseg_size = (size = count);\r\nmemcpy(sg_virt(sg_dst_tmp) + out_offset,\r\nsg_virt(sg_src_tmp) + in_offset,\r\nseg_size);\r\nin_offset += seg_size;\r\nout_offset += seg_size;\r\ncount += seg_size;\r\nif (in_offset >= sg_src_tmp->length) {\r\nsg_src_tmp = sg_next(sg_src_tmp);\r\nin_offset = 0;\r\n}\r\nif (out_offset >= sg_dst_tmp->length) {\r\nsg_dst_tmp = sg_next(sg_dst_tmp);\r\nout_offset = 0;\r\n}\r\n}\r\n}\r\nstatic int sep_oddball_pages(\r\nstruct sep_device *sep,\r\nstruct scatterlist *sg,\r\nsize_t data_size,\r\nu32 block_size,\r\nstruct scatterlist **new_sg,\r\nu32 do_copy)\r\n{\r\nstruct scatterlist *sg_temp;\r\nu32 flag;\r\nu32 nbr_pages, page_count;\r\ndev_dbg(&sep->pdev->dev, "sep oddball\n");\r\nif ((sg == NULL) || (data_size == 0) || (data_size < block_size))\r\nreturn 0;\r\ndev_dbg(&sep->pdev->dev, "sep oddball not null\n");\r\nflag = 0;\r\nnbr_pages = 0;\r\npage_count = 0;\r\nsg_temp = sg;\r\nwhile (sg_temp) {\r\nnbr_pages += 1;\r\nsg_temp = sg_next(sg_temp);\r\n}\r\nsg_temp = sg;\r\nwhile ((sg_temp) && (flag == 0)) {\r\npage_count += 1;\r\nif (sg_temp->length % block_size)\r\nflag = 1;\r\nelse\r\nsg_temp = sg_next(sg_temp);\r\n}\r\nif (nbr_pages == page_count)\r\nflag = 0;\r\nif (flag) {\r\ndev_dbg(&sep->pdev->dev, "sep oddball processing\n");\r\n*new_sg = sep_alloc_sg_buf(sep, data_size, block_size);\r\nif (*new_sg == NULL) {\r\ndev_warn(&sep->pdev->dev, "cannot allocate new sg\n");\r\nreturn -ENOMEM;\r\n}\r\nif (do_copy)\r\nsep_copy_sg(sep, sg, *new_sg, data_size);\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic size_t sep_copy_offset_sg(\r\nstruct sep_device *sep,\r\nstruct scatterlist *sg,\r\nu32 offset,\r\nvoid *dst,\r\nu32 len)\r\n{\r\nsize_t page_start;\r\nsize_t page_end;\r\nsize_t offset_within_page;\r\nsize_t length_within_page;\r\nsize_t length_remaining;\r\nsize_t current_offset;\r\npage_start = 0;\r\npage_end = sg->length;\r\nwhile ((sg) && (offset > page_end)) {\r\npage_start += sg->length;\r\nsg = sg_next(sg);\r\nif (sg)\r\npage_end += sg->length;\r\n}\r\nif (sg == NULL)\r\nreturn -ENOMEM;\r\noffset_within_page = offset - page_start;\r\nif ((sg->length - offset_within_page) >= len) {\r\nmemcpy(dst, sg_virt(sg) + offset_within_page, len);\r\nreturn len;\r\n} else {\r\ncurrent_offset = 0;\r\nlength_remaining = len;\r\nwhile ((sg) && (current_offset < len)) {\r\nlength_within_page = sg->length - offset_within_page;\r\nif (length_within_page >= length_remaining) {\r\nmemcpy(dst+current_offset,\r\nsg_virt(sg) + offset_within_page,\r\nlength_remaining);\r\nlength_remaining = 0;\r\ncurrent_offset = len;\r\n} else {\r\nmemcpy(dst+current_offset,\r\nsg_virt(sg) + offset_within_page,\r\nlength_within_page);\r\nlength_remaining -= length_within_page;\r\ncurrent_offset += length_within_page;\r\noffset_within_page = 0;\r\nsg = sg_next(sg);\r\n}\r\n}\r\nif (sg == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn len;\r\n}\r\nstatic int partial_overlap(void *src_ptr, void *dst_ptr, u32 nbytes)\r\n{\r\nif (src_ptr != dst_ptr) {\r\nif (src_ptr < dst_ptr) {\r\nif ((src_ptr + nbytes) > dst_ptr)\r\nreturn -EINVAL;\r\n} else {\r\nif ((dst_ptr + nbytes) > src_ptr)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sep_dump_ivs(struct ablkcipher_request *req, char *reason)\r\n{\r\nunsigned char *cptr;\r\nstruct sep_aes_internal_context *aes_internal;\r\nstruct sep_des_internal_context *des_internal;\r\nint ct1;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct crypto_ablkcipher *tfm;\r\nstruct sep_system_ctx *sctx;\r\nta_ctx = ablkcipher_request_ctx(req);\r\ntfm = crypto_ablkcipher_reqtfm(req);\r\nsctx = crypto_ablkcipher_ctx(tfm);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "IV DUMP - %s\n", reason);\r\nif ((ta_ctx->current_request == DES_CBC) &&\r\n(ta_ctx->des_opmode == SEP_DES_CBC)) {\r\ndes_internal = (struct sep_des_internal_context *)\r\nsctx->des_private_ctx.ctx_buf;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep - vendor iv for DES\n");\r\ncptr = (unsigned char *)des_internal->iv_context;\r\nfor (ct1 = 0; ct1 < crypto_ablkcipher_ivsize(tfm); ct1 += 1)\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"%02x\n", *(cptr + ct1));\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep - walk from kernel crypto iv for DES\n");\r\ncptr = (unsigned char *)ta_ctx->walk.iv;\r\nfor (ct1 = 0; ct1 < crypto_ablkcipher_ivsize(tfm); ct1 += 1)\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"%02x\n", *(cptr + ct1));\r\n} else if ((ta_ctx->current_request == AES_CBC) &&\r\n(ta_ctx->aes_opmode == SEP_AES_CBC)) {\r\naes_internal = (struct sep_aes_internal_context *)\r\nsctx->aes_private_ctx.cbuff;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep - vendor iv for AES\n");\r\ncptr = (unsigned char *)aes_internal->aes_ctx_iv;\r\nfor (ct1 = 0; ct1 < crypto_ablkcipher_ivsize(tfm); ct1 += 1)\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"%02x\n", *(cptr + ct1));\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep - walk from kernel crypto iv for AES\n");\r\ncptr = (unsigned char *)ta_ctx->walk.iv;\r\nfor (ct1 = 0; ct1 < crypto_ablkcipher_ivsize(tfm); ct1 += 1)\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"%02x\n", *(cptr + ct1));\r\n}\r\n}\r\nstatic int sep_weak_key(const u8 *key, unsigned int keylen)\r\n{\r\nstatic const u8 parity[] = {\r\n8, 1, 0, 8, 0, 8, 8, 0, 0, 8, 8, 0, 8, 0, 2, 8,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8,\r\n0, 0, 8, 0, 8, 8, 3,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8, 8, 0,\r\n8, 0, 0, 8, 0, 8, 8, 0, 0,\r\n8, 8, 0, 8, 0, 0, 8,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8, 8, 0,\r\n8, 0, 0, 8, 0, 8, 8, 0, 0,\r\n8, 8, 0, 8, 0, 0, 8,\r\n8, 0, 0, 8, 0, 8, 8, 0, 0, 8, 8, 0, 8, 0, 0, 8,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8,\r\n0, 0, 8, 0, 8, 8, 0,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8, 8, 0,\r\n8, 0, 0, 8, 0, 8, 8, 0, 0,\r\n8, 8, 0, 8, 0, 0, 8,\r\n8, 0, 0, 8, 0, 8, 8, 0, 0, 8, 8, 0, 8, 0, 0, 8,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8,\r\n0, 0, 8, 0, 8, 8, 0,\r\n8, 0, 0, 8, 0, 8, 8, 0, 0, 8, 8, 0, 8, 0, 0, 8,\r\n0, 8, 8, 0, 8, 0, 0, 8, 8,\r\n0, 0, 8, 0, 8, 8, 0,\r\n4, 8, 8, 0, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8, 8, 0,\r\n8, 5, 0, 8, 0, 8, 8, 0, 0,\r\n8, 8, 0, 8, 0, 6, 8,\r\n};\r\nu32 n, w;\r\nn = parity[key[0]]; n <<= 4;\r\nn |= parity[key[1]]; n <<= 4;\r\nn |= parity[key[2]]; n <<= 4;\r\nn |= parity[key[3]]; n <<= 4;\r\nn |= parity[key[4]]; n <<= 4;\r\nn |= parity[key[5]]; n <<= 4;\r\nn |= parity[key[6]]; n <<= 4;\r\nn |= parity[key[7]];\r\nw = 0x88888888L;\r\nif (!((n - (w >> 3)) & w)) {\r\nif (n < 0x41415151) {\r\nif (n < 0x31312121) {\r\nif (n < 0x14141515) {\r\nif (n == 0x11111111)\r\ngoto weak;\r\nif (n == 0x13131212)\r\ngoto weak;\r\n} else {\r\nif (n == 0x14141515)\r\ngoto weak;\r\nif (n == 0x16161616)\r\ngoto weak;\r\n}\r\n} else {\r\nif (n < 0x34342525) {\r\nif (n == 0x31312121)\r\ngoto weak;\r\nif (n == 0x33332222)\r\ngoto weak;\r\n} else {\r\nif (n == 0x34342525)\r\ngoto weak;\r\nif (n == 0x36362626)\r\ngoto weak;\r\n}\r\n}\r\n} else {\r\nif (n < 0x61616161) {\r\nif (n < 0x44445555) {\r\nif (n == 0x41415151)\r\ngoto weak;\r\nif (n == 0x43435252)\r\ngoto weak;\r\n} else {\r\nif (n == 0x44445555)\r\ngoto weak;\r\nif (n == 0x46465656)\r\ngoto weak;\r\n}\r\n} else {\r\nif (n < 0x64646565) {\r\nif (n == 0x61616161)\r\ngoto weak;\r\nif (n == 0x63636262)\r\ngoto weak;\r\n} else {\r\nif (n == 0x64646565)\r\ngoto weak;\r\nif (n == 0x66666666)\r\ngoto weak;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\nweak:\r\nreturn 1;\r\n}\r\nstatic u32 sep_sg_nents(struct scatterlist *sg)\r\n{\r\nu32 ct1 = 0;\r\nwhile (sg) {\r\nct1 += 1;\r\nsg = sg_next(sg);\r\n}\r\nreturn ct1;\r\n}\r\nstatic u32 sep_start_msg(struct this_task_ctx *ta_ctx)\r\n{\r\nu32 *word_ptr;\r\nta_ctx->msg_len_words = 2;\r\nta_ctx->msgptr = ta_ctx->msg;\r\nmemset(ta_ctx->msg, 0, SEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nta_ctx->msgptr += sizeof(u32) * 2;\r\nword_ptr = (u32 *)ta_ctx->msgptr;\r\n*word_ptr = SEP_START_MSG_TOKEN;\r\nreturn sizeof(u32) * 2;\r\n}\r\nstatic void sep_end_msg(struct this_task_ctx *ta_ctx, u32 msg_offset)\r\n{\r\nu32 *word_ptr;\r\nta_ctx->msg_len_words = msg_offset / sizeof(u32) + 1;\r\nword_ptr = (u32 *)ta_ctx->msgptr;\r\nword_ptr += 1;\r\n*word_ptr = ta_ctx->msg_len_words;\r\nword_ptr = (u32 *)(ta_ctx->msgptr + msg_offset);\r\n*word_ptr = 0;\r\n}\r\nstatic u32 sep_start_inbound_msg(struct this_task_ctx *ta_ctx, u32 *msg_offset)\r\n{\r\nu32 *word_ptr;\r\nu32 token;\r\nu32 error = SEP_OK;\r\n*msg_offset = sizeof(u32) * 2;\r\nword_ptr = (u32 *)ta_ctx->msgptr;\r\ntoken = *word_ptr;\r\nta_ctx->msg_len_words = *(word_ptr + 1);\r\nif (token != SEP_START_MSG_TOKEN) {\r\nerror = SEP_INVALID_START;\r\ngoto end_function;\r\n}\r\nend_function:\r\nreturn error;\r\n}\r\nstatic void sep_write_msg(struct this_task_ctx *ta_ctx, void *in_addr,\r\nu32 size, u32 max_size, u32 *msg_offset, u32 byte_array)\r\n{\r\nu32 *word_ptr;\r\nvoid *void_ptr;\r\nvoid_ptr = ta_ctx->msgptr + *msg_offset;\r\nword_ptr = (u32 *)void_ptr;\r\nmemcpy(void_ptr, in_addr, size);\r\n*msg_offset += max_size;\r\nif (byte_array) {\r\nu32 i;\r\nfor (i = 0; i < ((size + 3) / 4); i += 1)\r\n*(word_ptr + i) = CHG_ENDIAN(*(word_ptr + i));\r\n}\r\n}\r\nstatic void sep_make_header(struct this_task_ctx *ta_ctx, u32 *msg_offset,\r\nu32 op_code)\r\n{\r\nu32 *word_ptr;\r\n*msg_offset = sep_start_msg(ta_ctx);\r\nword_ptr = (u32 *)(ta_ctx->msgptr + *msg_offset);\r\n*word_ptr = op_code;\r\n*msg_offset += sizeof(u32);\r\n}\r\nstatic void sep_read_msg(struct this_task_ctx *ta_ctx, void *in_addr,\r\nu32 size, u32 max_size, u32 *msg_offset, u32 byte_array)\r\n{\r\nu32 *word_ptr;\r\nvoid *void_ptr;\r\nvoid_ptr = ta_ctx->msgptr + *msg_offset;\r\nword_ptr = (u32 *)void_ptr;\r\nif (byte_array) {\r\nu32 i;\r\nfor (i = 0; i < ((size + 3) / 4); i += 1)\r\n*(word_ptr + i) = CHG_ENDIAN(*(word_ptr + i));\r\n}\r\nmemcpy(in_addr, void_ptr, size);\r\n*msg_offset += max_size;\r\n}\r\nstatic u32 sep_verify_op(struct this_task_ctx *ta_ctx, u32 op_code,\r\nu32 *msg_offset)\r\n{\r\nu32 error;\r\nu32 in_ary[2];\r\nstruct sep_device *sep = ta_ctx->sep_used;\r\ndev_dbg(&sep->pdev->dev, "dumping return message\n");\r\nerror = sep_start_inbound_msg(ta_ctx, msg_offset);\r\nif (error) {\r\ndev_warn(&sep->pdev->dev,\r\n"sep_start_inbound_msg error\n");\r\nreturn error;\r\n}\r\nsep_read_msg(ta_ctx, in_ary, sizeof(u32) * 2, sizeof(u32) * 2,\r\nmsg_offset, 0);\r\nif (in_ary[0] != op_code) {\r\ndev_warn(&sep->pdev->dev,\r\n"sep got back wrong opcode\n");\r\ndev_warn(&sep->pdev->dev,\r\n"got back %x; expected %x\n",\r\nin_ary[0], op_code);\r\nreturn SEP_WRONG_OPCODE;\r\n}\r\nif (in_ary[1] != SEP_OK) {\r\ndev_warn(&sep->pdev->dev,\r\n"sep execution error\n");\r\ndev_warn(&sep->pdev->dev,\r\n"got back %x; expected %x\n",\r\nin_ary[1], SEP_OK);\r\nreturn in_ary[0];\r\n}\r\nreturn 0;\r\n}\r\nstatic void sep_read_context(struct this_task_ctx *ta_ctx, u32 *msg_offset,\r\nvoid *dst, u32 len)\r\n{\r\nu32 max_length = ((len + 3) / sizeof(u32)) * sizeof(u32);\r\nsep_read_msg(ta_ctx, dst, len, max_length, msg_offset, 0);\r\n}\r\nstatic void sep_write_context(struct this_task_ctx *ta_ctx, u32 *msg_offset,\r\nvoid *src, u32 len)\r\n{\r\nu32 max_length = ((len + 3) / sizeof(u32)) * sizeof(u32);\r\nsep_write_msg(ta_ctx, src, len, max_length, msg_offset, 0);\r\n}\r\nstatic void sep_clear_out(struct this_task_ctx *ta_ctx)\r\n{\r\nif (ta_ctx->src_sg_hold) {\r\nsep_free_sg_buf(ta_ctx->src_sg_hold);\r\nta_ctx->src_sg_hold = NULL;\r\n}\r\nif (ta_ctx->dst_sg_hold) {\r\nsep_free_sg_buf(ta_ctx->dst_sg_hold);\r\nta_ctx->dst_sg_hold = NULL;\r\n}\r\nta_ctx->src_sg = NULL;\r\nta_ctx->dst_sg = NULL;\r\nsep_free_dma_table_data_handler(ta_ctx->sep_used, &ta_ctx->dma_ctx);\r\nif (ta_ctx->i_own_sep) {\r\nta_ctx->sep_used->current_hash_req = NULL;\r\nta_ctx->sep_used->current_cypher_req = NULL;\r\nta_ctx->sep_used->current_request = 0;\r\nta_ctx->sep_used->current_hash_stage = 0;\r\nta_ctx->sep_used->ta_ctx = NULL;\r\nta_ctx->sep_used->in_kernel = 0;\r\nta_ctx->call_status.status = 0;\r\nmemset(ta_ctx->sep_used->shared_addr, 0,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nsep_queue_status_remove(ta_ctx->sep_used, &ta_ctx->queue_elem);\r\n#ifdef SEP_ENABLE_RUNTIME_PM\r\nta_ctx->sep_used->in_use = 0;\r\npm_runtime_mark_last_busy(&ta_ctx->sep_used->pdev->dev);\r\npm_runtime_put_autosuspend(&ta_ctx->sep_used->pdev->dev);\r\n#endif\r\nclear_bit(SEP_WORKING_LOCK_BIT,\r\n&ta_ctx->sep_used->in_use_flags);\r\nta_ctx->sep_used->pid_doing_transaction = 0;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"[PID%d] waking up next transaction\n",\r\ncurrent->pid);\r\nclear_bit(SEP_TRANSACTION_STARTED_LOCK_BIT,\r\n&ta_ctx->sep_used->in_use_flags);\r\nwake_up(&ta_ctx->sep_used->event_transactions);\r\nta_ctx->i_own_sep = 0;\r\n}\r\n}\r\nstatic void sep_crypto_release(struct sep_system_ctx *sctx,\r\nstruct this_task_ctx *ta_ctx, u32 error)\r\n{\r\nstruct ahash_request *hash_req = ta_ctx->current_hash_req;\r\nstruct ablkcipher_request *cypher_req =\r\nta_ctx->current_cypher_req;\r\nstruct sep_device *sep = ta_ctx->sep_used;\r\nsep_clear_out(ta_ctx);\r\nif (ta_ctx->are_we_done_yet != NULL)\r\n*ta_ctx->are_we_done_yet = 1;\r\nif (cypher_req != NULL) {\r\nif ((sctx->key_sent == 1) ||\r\n((error != 0) && (error != -EINPROGRESS))) {\r\nif (cypher_req->base.complete == NULL) {\r\ndev_dbg(&sep->pdev->dev,\r\n"release is null for cypher!");\r\n} else {\r\ncypher_req->base.complete(\r\n&cypher_req->base, error);\r\n}\r\n}\r\n}\r\nif (hash_req != NULL) {\r\nif (hash_req->base.complete == NULL) {\r\ndev_dbg(&sep->pdev->dev,\r\n"release is null for hash!");\r\n} else {\r\nhash_req->base.complete(\r\n&hash_req->base, error);\r\n}\r\n}\r\n}\r\nstatic int sep_crypto_take_sep(struct this_task_ctx *ta_ctx)\r\n{\r\nstruct sep_device *sep = ta_ctx->sep_used;\r\nint result;\r\nstruct sep_msgarea_hdr *my_msg_header;\r\nmy_msg_header = (struct sep_msgarea_hdr *)ta_ctx->msg;\r\nta_ctx->queue_elem = sep_queue_status_add(sep, my_msg_header->opcode,\r\nta_ctx->nbytes, current->pid,\r\ncurrent->comm, sizeof(current->comm));\r\nif (!ta_ctx->queue_elem) {\r\ndev_dbg(&sep->pdev->dev,\r\n"[PID%d] updating queue status error\n", current->pid);\r\nreturn -EINVAL;\r\n}\r\nresult = sep_wait_transaction(sep);\r\nif (result)\r\nreturn result;\r\nif (sep_dev->power_save_setup == 1)\r\npm_runtime_get_sync(&sep_dev->pdev->dev);\r\nmemcpy(sep->shared_addr, ta_ctx->msg,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nif (ta_ctx->dcb_region) {\r\nresult = sep_activate_dcb_dmatables_context(sep,\r\n&ta_ctx->dcb_region, &ta_ctx->dmatables_region,\r\nta_ctx->dma_ctx);\r\nif (result)\r\nreturn result;\r\n}\r\nif (ta_ctx->current_hash_req)\r\nsep->current_hash_req = ta_ctx->current_hash_req;\r\nelse\r\nsep->current_cypher_req = ta_ctx->current_cypher_req;\r\nsep->current_request = ta_ctx->current_request;\r\nsep->current_hash_stage = ta_ctx->current_hash_stage;\r\nsep->ta_ctx = ta_ctx;\r\nsep->in_kernel = 1;\r\nta_ctx->i_own_sep = 1;\r\nset_bit(SEP_LEGACY_SENDMSG_DONE_OFFSET, &ta_ctx->call_status.status);\r\nresult = sep_send_command_handler(sep);\r\ndev_dbg(&sep->pdev->dev, "[PID%d]: sending command to the sep\n",\r\ncurrent->pid);\r\nif (!result)\r\ndev_dbg(&sep->pdev->dev, "[PID%d]: command sent okay\n",\r\ncurrent->pid);\r\nelse {\r\ndev_dbg(&sep->pdev->dev, "[PID%d]: cant send command\n",\r\ncurrent->pid);\r\nclear_bit(SEP_LEGACY_SENDMSG_DONE_OFFSET,\r\n&ta_ctx->call_status.status);\r\n}\r\nreturn result;\r\n}\r\nstatic int sep_crypto_block_data(struct ablkcipher_request *req)\r\n{\r\nint int_error;\r\nu32 msg_offset;\r\nstatic u32 msg[10];\r\nvoid *src_ptr;\r\nvoid *dst_ptr;\r\nstatic char small_buf[100];\r\nssize_t copy_result;\r\nint result;\r\nstruct scatterlist *new_sg;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct crypto_ablkcipher *tfm;\r\nstruct sep_system_ctx *sctx;\r\nstruct sep_des_internal_context *des_internal;\r\nstruct sep_aes_internal_context *aes_internal;\r\nta_ctx = ablkcipher_request_ctx(req);\r\ntfm = crypto_ablkcipher_reqtfm(req);\r\nsctx = crypto_ablkcipher_ctx(tfm);\r\nablkcipher_walk_init(&ta_ctx->walk, req->src, req->dst, req->nbytes);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "sep crypto block data size of %x\n",\r\nreq->nbytes);\r\nint_error = ablkcipher_walk_phys(req, &ta_ctx->walk);\r\nif (int_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "walk phys error %x\n",\r\nint_error);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"crypto block: src is %lx dst is %lx\n",\r\n(unsigned long)req->src, (unsigned long)req->dst);\r\nint_error = sep_oddball_pages(ta_ctx->sep_used, req->src,\r\nreq->nbytes, ta_ctx->walk.blocksize, &new_sg, 1);\r\nif (int_error < 0) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "oddball page error\n");\r\nreturn -ENOMEM;\r\n} else if (int_error == 1) {\r\nta_ctx->src_sg = new_sg;\r\nta_ctx->src_sg_hold = new_sg;\r\n} else {\r\nta_ctx->src_sg = req->src;\r\nta_ctx->src_sg_hold = NULL;\r\n}\r\nint_error = sep_oddball_pages(ta_ctx->sep_used, req->dst,\r\nreq->nbytes, ta_ctx->walk.blocksize, &new_sg, 0);\r\nif (int_error < 0) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "walk phys error %x\n",\r\nint_error);\r\nreturn -ENOMEM;\r\n} else if (int_error == 1) {\r\nta_ctx->dst_sg = new_sg;\r\nta_ctx->dst_sg_hold = new_sg;\r\n} else {\r\nta_ctx->dst_sg = req->dst;\r\nta_ctx->dst_sg_hold = NULL;\r\n}\r\nta_ctx->nbytes = req->nbytes;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "sending data\n");\r\nsrc_ptr = sg_virt(ta_ctx->src_sg);\r\ndst_ptr = sg_virt(ta_ctx->dst_sg);\r\nif (!src_ptr || !dst_ptr ||\r\n(ta_ctx->current_cypher_req->nbytes %\r\ncrypto_ablkcipher_blocksize(tfm))) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"cipher block size odd\n");\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"cipher block size is %x\n",\r\ncrypto_ablkcipher_blocksize(tfm));\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"cipher data size is %x\n",\r\nta_ctx->current_cypher_req->nbytes);\r\nreturn -EINVAL;\r\n}\r\nif (partial_overlap(src_ptr, dst_ptr,\r\nta_ctx->current_cypher_req->nbytes)) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"block partial overlap\n");\r\nreturn -EINVAL;\r\n}\r\nsep_make_header(ta_ctx, &msg_offset, ta_ctx->block_opcode);\r\nif ((ta_ctx->block_opcode == SEP_DES_BLOCK_OPCODE) &&\r\n(req->nbytes == crypto_ablkcipher_blocksize(tfm))) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"writing out one block des\n");\r\ncopy_result = sg_copy_to_buffer(\r\nta_ctx->src_sg, sep_sg_nents(ta_ctx->src_sg),\r\nsmall_buf, crypto_ablkcipher_blocksize(tfm));\r\nif (copy_result != crypto_ablkcipher_blocksize(tfm)) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"des block copy failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsep_write_msg(ta_ctx, small_buf,\r\ncrypto_ablkcipher_blocksize(tfm),\r\ncrypto_ablkcipher_blocksize(tfm) * 2,\r\n&msg_offset, 1);\r\nsep_write_msg(ta_ctx, &req->nbytes,\r\nsizeof(u32), sizeof(u32), &msg_offset, 0);\r\n} else {\r\nta_ctx->dcb_input_data.app_in_address = src_ptr;\r\nta_ctx->dcb_input_data.data_in_size = req->nbytes;\r\nta_ctx->dcb_input_data.app_out_address = dst_ptr;\r\nta_ctx->dcb_input_data.block_size =\r\ncrypto_ablkcipher_blocksize(tfm);\r\nta_ctx->dcb_input_data.tail_block_size = 0;\r\nta_ctx->dcb_input_data.is_applet = 0;\r\nta_ctx->dcb_input_data.src_sg = ta_ctx->src_sg;\r\nta_ctx->dcb_input_data.dst_sg = ta_ctx->dst_sg;\r\nresult = sep_create_dcb_dmatables_context_kernel(\r\nta_ctx->sep_used,\r\n&ta_ctx->dcb_region,\r\n&ta_ctx->dmatables_region,\r\n&ta_ctx->dma_ctx,\r\n&ta_ctx->dcb_input_data,\r\n1);\r\nif (result) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"crypto dma table create failed\n");\r\nreturn -EINVAL;\r\n}\r\nmsg[0] = (u32)0;\r\nmsg[1] = (u32)0;\r\nmsg[2] = (u32)0;\r\nmsg[3] = (u32)0;\r\nmsg[4] = (u32)0;\r\nsep_write_msg(ta_ctx, (void *)msg, sizeof(u32) * 5,\r\nsizeof(u32) * 5, &msg_offset, 0);\r\n}\r\nsep_dump_ivs(req, "sending data block to sep\n");\r\nif ((ta_ctx->current_request == DES_CBC) &&\r\n(ta_ctx->des_opmode == SEP_DES_CBC)) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"overwrite vendor iv on DES\n");\r\ndes_internal = (struct sep_des_internal_context *)\r\nsctx->des_private_ctx.ctx_buf;\r\nmemcpy((void *)des_internal->iv_context,\r\nta_ctx->walk.iv, crypto_ablkcipher_ivsize(tfm));\r\n} else if ((ta_ctx->current_request == AES_CBC) &&\r\n(ta_ctx->aes_opmode == SEP_AES_CBC)) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"overwrite vendor iv on AES\n");\r\naes_internal = (struct sep_aes_internal_context *)\r\nsctx->aes_private_ctx.cbuff;\r\nmemcpy((void *)aes_internal->aes_ctx_iv,\r\nta_ctx->walk.iv, crypto_ablkcipher_ivsize(tfm));\r\n}\r\nif (ta_ctx->block_opcode == SEP_DES_BLOCK_OPCODE) {\r\nsep_write_context(ta_ctx, &msg_offset,\r\n&sctx->des_private_ctx,\r\nsizeof(struct sep_des_private_context));\r\n} else {\r\nsep_write_context(ta_ctx, &msg_offset,\r\n&sctx->aes_private_ctx,\r\nsizeof(struct sep_aes_private_context));\r\n}\r\nsep_end_msg(ta_ctx, msg_offset);\r\nreturn 0;\r\n}\r\nstatic int sep_crypto_send_key(struct ablkcipher_request *req)\r\n{\r\nint int_error;\r\nu32 msg_offset;\r\nstatic u32 msg[10];\r\nu32 max_length;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct crypto_ablkcipher *tfm;\r\nstruct sep_system_ctx *sctx;\r\nta_ctx = ablkcipher_request_ctx(req);\r\ntfm = crypto_ablkcipher_reqtfm(req);\r\nsctx = crypto_ablkcipher_ctx(tfm);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "sending key\n");\r\nablkcipher_walk_init(&ta_ctx->walk, req->src, req->dst, req->nbytes);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep crypto block data size of %x\n", req->nbytes);\r\nint_error = ablkcipher_walk_phys(req, &ta_ctx->walk);\r\nif (int_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "walk phys error %x\n",\r\nint_error);\r\nreturn -ENOMEM;\r\n}\r\nif ((ta_ctx->current_request == DES_CBC) &&\r\n(ta_ctx->des_opmode == SEP_DES_CBC)) {\r\nif (!ta_ctx->walk.iv) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "no iv found\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ta_ctx->iv, ta_ctx->walk.iv, SEP_DES_IV_SIZE_BYTES);\r\n}\r\nif ((ta_ctx->current_request == AES_CBC) &&\r\n(ta_ctx->aes_opmode == SEP_AES_CBC)) {\r\nif (!ta_ctx->walk.iv) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "no iv found\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ta_ctx->iv, ta_ctx->walk.iv, SEP_AES_IV_SIZE_BYTES);\r\n}\r\nsep_make_header(ta_ctx, &msg_offset, ta_ctx->init_opcode);\r\nif (ta_ctx->init_opcode == SEP_DES_INIT_OPCODE) {\r\nif (ta_ctx->des_opmode == SEP_DES_CBC) {\r\nsep_write_msg(ta_ctx, ta_ctx->iv,\r\nSEP_DES_IV_SIZE_BYTES, sizeof(u32) * 4,\r\n&msg_offset, 1);\r\n} else {\r\nmsg_offset += 4 * sizeof(u32);\r\n}\r\n} else {\r\nmax_length = ((SEP_AES_IV_SIZE_BYTES + 3) /\r\nsizeof(u32)) * sizeof(u32);\r\nif (ta_ctx->aes_opmode == SEP_AES_CBC) {\r\nsep_write_msg(ta_ctx, ta_ctx->iv,\r\nSEP_AES_IV_SIZE_BYTES, max_length,\r\n&msg_offset, 1);\r\n} else {\r\nmsg_offset += max_length;\r\n}\r\n}\r\nif (ta_ctx->init_opcode == SEP_DES_INIT_OPCODE) {\r\nsep_write_msg(ta_ctx, (void *)&sctx->key.des.key1,\r\nsizeof(u32) * 8, sizeof(u32) * 8,\r\n&msg_offset, 1);\r\nmsg[0] = (u32)sctx->des_nbr_keys;\r\nmsg[1] = (u32)ta_ctx->des_encmode;\r\nmsg[2] = (u32)ta_ctx->des_opmode;\r\nsep_write_msg(ta_ctx, (void *)msg,\r\nsizeof(u32) * 3, sizeof(u32) * 3,\r\n&msg_offset, 0);\r\n} else {\r\nsep_write_msg(ta_ctx, (void *)&sctx->key.aes,\r\nsctx->keylen,\r\nSEP_AES_MAX_KEY_SIZE_BYTES,\r\n&msg_offset, 1);\r\nmsg[0] = (u32)sctx->aes_key_size;\r\nmsg[1] = (u32)ta_ctx->aes_encmode;\r\nmsg[2] = (u32)ta_ctx->aes_opmode;\r\nmsg[3] = (u32)0;\r\nsep_write_msg(ta_ctx, (void *)msg,\r\nsizeof(u32) * 4, sizeof(u32) * 4,\r\n&msg_offset, 0);\r\n}\r\nsep_end_msg(ta_ctx, msg_offset);\r\nreturn 0;\r\n}\r\nstatic void sep_crypto_block(void *data)\r\n{\r\nunsigned long end_time;\r\nint result;\r\nstruct ablkcipher_request *req;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct crypto_ablkcipher *tfm;\r\nstruct sep_system_ctx *sctx;\r\nint are_we_done_yet;\r\nreq = (struct ablkcipher_request *)data;\r\nta_ctx = ablkcipher_request_ctx(req);\r\ntfm = crypto_ablkcipher_reqtfm(req);\r\nsctx = crypto_ablkcipher_ctx(tfm);\r\nta_ctx->are_we_done_yet = &are_we_done_yet;\r\npr_debug("sep_crypto_block\n");\r\npr_debug("tfm is %p sctx is %p ta_ctx is %p\n",\r\ntfm, sctx, ta_ctx);\r\npr_debug("key_sent is %d\n", sctx->key_sent);\r\nif (sctx->key_sent == 0) {\r\nare_we_done_yet = 0;\r\nresult = sep_crypto_send_key(req);\r\nif (result != 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"could not prep key %x\n", result);\r\nsep_crypto_release(sctx, ta_ctx, result);\r\nreturn;\r\n}\r\nresult = sep_crypto_take_sep(ta_ctx);\r\nif (result) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep_crypto_take_sep for key send failed\n");\r\nsep_crypto_release(sctx, ta_ctx, result);\r\nreturn;\r\n}\r\nend_time = jiffies + (WAIT_TIME * HZ);\r\nwhile ((time_before(jiffies, end_time)) &&\r\n(are_we_done_yet == 0))\r\nschedule();\r\nif (are_we_done_yet == 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"Send key job never got done\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\nsctx->key_sent = 1;\r\n}\r\nare_we_done_yet = 0;\r\nresult = sep_crypto_block_data(req);\r\nif (result != 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"could prep not send block %x\n", result);\r\nsep_crypto_release(sctx, ta_ctx, result);\r\nreturn;\r\n}\r\nresult = sep_crypto_take_sep(ta_ctx);\r\nif (result) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep_crypto_take_sep for block send failed\n");\r\nsep_crypto_release(sctx, ta_ctx, result);\r\nreturn;\r\n}\r\nend_time = jiffies + (WAIT_TIME * HZ);\r\nwhile ((time_before(jiffies, end_time)) && (are_we_done_yet == 0))\r\nschedule();\r\nif (are_we_done_yet == 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"Send block job never got done\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\npr_debug("crypto_block leaving\n");\r\npr_debug("tfm is %p sctx is %p ta_ctx is %p\n", tfm, sctx, ta_ctx);\r\n}\r\nstatic u32 crypto_post_op(struct sep_device *sep)\r\n{\r\nu32 u32_error;\r\nu32 msg_offset;\r\nssize_t copy_result;\r\nstatic char small_buf[100];\r\nstruct ablkcipher_request *req;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct sep_system_ctx *sctx;\r\nstruct crypto_ablkcipher *tfm;\r\nstruct sep_des_internal_context *des_internal;\r\nstruct sep_aes_internal_context *aes_internal;\r\nif (!sep->current_cypher_req)\r\nreturn -EINVAL;\r\nreq = sep->current_cypher_req;\r\nta_ctx = ablkcipher_request_ctx(sep->current_cypher_req);\r\ntfm = crypto_ablkcipher_reqtfm(sep->current_cypher_req);\r\nsctx = crypto_ablkcipher_ctx(tfm);\r\npr_debug("crypto_post op\n");\r\npr_debug("key_sent is %d tfm is %p sctx is %p ta_ctx is %p\n",\r\nsctx->key_sent, tfm, sctx, ta_ctx);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "crypto post_op\n");\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "crypto post_op message dump\n");\r\nmemcpy(ta_ctx->msg, sep->shared_addr,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nif (sctx->key_sent == 0) {\r\nu32_error = sep_verify_op(ta_ctx, ta_ctx->init_opcode,\r\n&msg_offset);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"aes init error %x\n", u32_error);\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn u32_error;\r\n}\r\nif (ta_ctx->init_opcode == SEP_DES_INIT_OPCODE) {\r\nsep_read_context(ta_ctx, &msg_offset,\r\n&sctx->des_private_ctx,\r\nsizeof(struct sep_des_private_context));\r\n} else {\r\nsep_read_context(ta_ctx, &msg_offset,\r\n&sctx->aes_private_ctx,\r\nsizeof(struct sep_aes_private_context));\r\n}\r\nsep_dump_ivs(req, "after sending key to sep\n");\r\nsctx->key_sent = 1;\r\nsep_crypto_release(sctx, ta_ctx, -EINPROGRESS);\r\n} else {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"crypto_post_op block response\n");\r\nu32_error = sep_verify_op(ta_ctx, ta_ctx->block_opcode,\r\n&msg_offset);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep block error %x\n", u32_error);\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn -EINVAL;\r\n}\r\nif (ta_ctx->block_opcode == SEP_DES_BLOCK_OPCODE) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"post op for DES\n");\r\nif (sep->current_cypher_req->nbytes ==\r\ncrypto_ablkcipher_blocksize(tfm)) {\r\nsep_read_msg(ta_ctx, small_buf,\r\ncrypto_ablkcipher_blocksize(tfm),\r\ncrypto_ablkcipher_blocksize(tfm) * 2,\r\n&msg_offset, 1);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"reading in block des\n");\r\ncopy_result = sg_copy_from_buffer(\r\nta_ctx->dst_sg,\r\nsep_sg_nents(ta_ctx->dst_sg),\r\nsmall_buf,\r\ncrypto_ablkcipher_blocksize(tfm));\r\nif (copy_result !=\r\ncrypto_ablkcipher_blocksize(tfm)) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"des block copy failed\n");\r\nsep_crypto_release(sctx, ta_ctx,\r\n-ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nsep_read_context(ta_ctx, &msg_offset,\r\n&sctx->des_private_ctx,\r\nsizeof(struct sep_des_private_context));\r\n} else {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"post op for AES\n");\r\nmsg_offset += (sizeof(u32) * 4);\r\nsep_read_context(ta_ctx, &msg_offset,\r\n&sctx->aes_private_ctx,\r\nsizeof(struct sep_aes_private_context));\r\n}\r\nif (ta_ctx->dst_sg_hold)\r\nsep_copy_sg(ta_ctx->sep_used,\r\nta_ctx->dst_sg,\r\nta_ctx->current_cypher_req->dst,\r\nta_ctx->current_cypher_req->nbytes);\r\nsep_dump_ivs(req, "got data block from sep\n");\r\nif ((ta_ctx->current_request == DES_CBC) &&\r\n(ta_ctx->des_opmode == SEP_DES_CBC)) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"returning result iv to walk on DES\n");\r\ndes_internal = (struct sep_des_internal_context *)\r\nsctx->des_private_ctx.ctx_buf;\r\nmemcpy(ta_ctx->walk.iv,\r\n(void *)des_internal->iv_context,\r\ncrypto_ablkcipher_ivsize(tfm));\r\n} else if ((ta_ctx->current_request == AES_CBC) &&\r\n(ta_ctx->aes_opmode == SEP_AES_CBC)) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"returning result iv to walk on AES\n");\r\naes_internal = (struct sep_aes_internal_context *)\r\nsctx->aes_private_ctx.cbuff;\r\nmemcpy(ta_ctx->walk.iv,\r\n(void *)aes_internal->aes_ctx_iv,\r\ncrypto_ablkcipher_ivsize(tfm));\r\n}\r\nsep_crypto_release(sctx, ta_ctx, 0);\r\n}\r\npr_debug("crypto_post_op done\n");\r\npr_debug("key_sent is %d tfm is %p sctx is %p ta_ctx is %p\n",\r\nsctx->key_sent, tfm, sctx, ta_ctx);\r\nreturn 0;\r\n}\r\nstatic u32 hash_init_post_op(struct sep_device *sep)\r\n{\r\nu32 u32_error;\r\nu32 msg_offset;\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(sep->current_hash_req);\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(sep->current_hash_req);\r\nstruct sep_system_ctx *sctx = crypto_ahash_ctx(tfm);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash init post op\n");\r\nmemcpy(ta_ctx->msg, sep->shared_addr,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nu32_error = sep_verify_op(ta_ctx, SEP_HASH_INIT_OPCODE,\r\n&msg_offset);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "hash init error %x\n",\r\nu32_error);\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn u32_error;\r\n}\r\nsep_read_context(ta_ctx, &msg_offset,\r\n&sctx->hash_private_ctx,\r\nsizeof(struct sep_hash_private_context));\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "hash init post op done\n");\r\nsep_crypto_release(sctx, ta_ctx, 0);\r\nreturn 0;\r\n}\r\nstatic u32 hash_update_post_op(struct sep_device *sep)\r\n{\r\nu32 u32_error;\r\nu32 msg_offset;\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(sep->current_hash_req);\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(sep->current_hash_req);\r\nstruct sep_system_ctx *sctx = crypto_ahash_ctx(tfm);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash update post op\n");\r\nmemcpy(ta_ctx->msg, sep->shared_addr,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nu32_error = sep_verify_op(ta_ctx, SEP_HASH_UPDATE_OPCODE,\r\n&msg_offset);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "hash init error %x\n",\r\nu32_error);\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn u32_error;\r\n}\r\nsep_read_context(ta_ctx, &msg_offset,\r\n&sctx->hash_private_ctx,\r\nsizeof(struct sep_hash_private_context));\r\nif (ta_ctx->sep_used->current_hash_stage == HASH_FINUP_DATA) {\r\nta_ctx->sep_used->current_hash_stage = HASH_FINUP_FINISH;\r\nspin_lock_irq(&queue_lock);\r\nu32_error = crypto_enqueue_request(&sep_queue,\r\n&ta_ctx->sep_used->current_hash_req->base);\r\nspin_unlock_irq(&queue_lock);\r\nif ((u32_error != 0) && (u32_error != -EINPROGRESS)) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"spe cypher post op cant queue\n");\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn u32_error;\r\n}\r\nu32_error = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"cant submit work sep_crypto_block\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "hash update post op done\n");\r\nsep_crypto_release(sctx, ta_ctx, 0);\r\nreturn 0;\r\n}\r\nstatic u32 hash_final_post_op(struct sep_device *sep)\r\n{\r\nint max_length;\r\nu32 u32_error;\r\nu32 msg_offset;\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(sep->current_hash_req);\r\nstruct sep_system_ctx *sctx = crypto_ahash_ctx(tfm);\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(sep->current_hash_req);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash final post op\n");\r\nmemcpy(ta_ctx->msg, sep->shared_addr,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nu32_error = sep_verify_op(ta_ctx, SEP_HASH_FINISH_OPCODE,\r\n&msg_offset);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev, "hash finish error %x\n",\r\nu32_error);\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn u32_error;\r\n}\r\nif (ta_ctx->current_hash_req->result == NULL) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"hash finish null buffer\n");\r\nsep_crypto_release(sctx, ta_ctx, (u32)-ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nmax_length = (((SEP_HASH_RESULT_SIZE_WORDS * sizeof(u32)) + 3) /\r\nsizeof(u32)) * sizeof(u32);\r\nsep_read_msg(ta_ctx,\r\nta_ctx->current_hash_req->result,\r\ncrypto_ahash_digestsize(tfm), max_length,\r\n&msg_offset, 0);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "hash finish post op done\n");\r\nsep_crypto_release(sctx, ta_ctx, 0);\r\nreturn 0;\r\n}\r\nstatic u32 hash_digest_post_op(struct sep_device *sep)\r\n{\r\nint max_length;\r\nu32 u32_error;\r\nu32 msg_offset;\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(sep->current_hash_req);\r\nstruct sep_system_ctx *sctx = crypto_ahash_ctx(tfm);\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(sep->current_hash_req);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash digest post op\n");\r\nmemcpy(ta_ctx->msg, sep->shared_addr,\r\nSEP_DRIVER_MESSAGE_SHARED_AREA_SIZE_IN_BYTES);\r\nu32_error = sep_verify_op(ta_ctx, SEP_HASH_SINGLE_OPCODE,\r\n&msg_offset);\r\nif (u32_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"hash digest finish error %x\n", u32_error);\r\nsep_crypto_release(sctx, ta_ctx, u32_error);\r\nreturn u32_error;\r\n}\r\nif (ta_ctx->current_hash_req->result == NULL) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"hash digest finish null buffer\n");\r\nsep_crypto_release(sctx, ta_ctx, (u32)-ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nmax_length = (((SEP_HASH_RESULT_SIZE_WORDS * sizeof(u32)) + 3) /\r\nsizeof(u32)) * sizeof(u32);\r\nsep_read_msg(ta_ctx,\r\nta_ctx->current_hash_req->result,\r\ncrypto_ahash_digestsize(tfm), max_length,\r\n&msg_offset, 0);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash digest finish post op done\n");\r\nsep_crypto_release(sctx, ta_ctx, 0);\r\nreturn 0;\r\n}\r\nstatic void sep_finish(unsigned long data)\r\n{\r\nstruct sep_device *sep_dev;\r\nint res;\r\nres = 0;\r\nif (data == 0) {\r\npr_debug("sep_finish called with null data\n");\r\nreturn;\r\n}\r\nsep_dev = (struct sep_device *)data;\r\nif (sep_dev == NULL) {\r\npr_debug("sep_finish; sep_dev is NULL\n");\r\nreturn;\r\n}\r\nif (sep_dev->in_kernel == (u32)0) {\r\ndev_warn(&sep_dev->pdev->dev,\r\n"sep_finish; not in kernel operation\n");\r\nreturn;\r\n}\r\nif (0 == test_bit(SEP_LEGACY_SENDMSG_DONE_OFFSET,\r\n&sep_dev->ta_ctx->call_status.status)) {\r\ndev_warn(&sep_dev->pdev->dev, "[PID%d] sendmsg not called\n",\r\ncurrent->pid);\r\nreturn;\r\n}\r\nif (sep_dev->send_ct != sep_dev->reply_ct) {\r\ndev_warn(&sep_dev->pdev->dev,\r\n"[PID%d] poll; no message came back\n",\r\ncurrent->pid);\r\nreturn;\r\n}\r\nif ((res != 0x0) && (res != 0x8)) {\r\ndev_warn(&sep_dev->pdev->dev,\r\n"[PID%d] poll; poll error GPR3 is %x\n",\r\ncurrent->pid, res);\r\nreturn;\r\n}\r\nres = sep_read_reg(sep_dev, HW_HOST_SEP_HOST_GPR2_REG_ADDR);\r\ndev_dbg(&sep_dev->pdev->dev, "[PID%d] GPR2 at crypto finish is %x\n",\r\ncurrent->pid, res);\r\nif ((res >> 30) & 0x1) {\r\ndev_dbg(&sep_dev->pdev->dev, "[PID%d] sep print req\n",\r\ncurrent->pid);\r\ndev_dbg(&sep_dev->pdev->dev, "[PID%d] contents: %s\n",\r\ncurrent->pid,\r\n(char *)(sep_dev->shared_addr +\r\nSEP_DRIVER_PRINTF_OFFSET_IN_BYTES));\r\nreturn;\r\n}\r\nif (res >> 31) {\r\ndev_dbg(&sep_dev->pdev->dev,\r\n"[PID%d] sep request; ignoring\n",\r\ncurrent->pid);\r\nreturn;\r\n}\r\ndev_dbg(&sep_dev->pdev->dev,\r\n"[PID%d] sep reply to command; processing request: %x\n",\r\ncurrent->pid, sep_dev->current_request);\r\nswitch (sep_dev->current_request) {\r\ncase AES_CBC:\r\ncase AES_ECB:\r\ncase DES_CBC:\r\ncase DES_ECB:\r\nres = crypto_post_op(sep_dev);\r\nbreak;\r\ncase SHA1:\r\ncase MD5:\r\ncase SHA224:\r\ncase SHA256:\r\nswitch (sep_dev->current_hash_stage) {\r\ncase HASH_INIT:\r\nres = hash_init_post_op(sep_dev);\r\nbreak;\r\ncase HASH_UPDATE:\r\ncase HASH_FINUP_DATA:\r\nres = hash_update_post_op(sep_dev);\r\nbreak;\r\ncase HASH_FINUP_FINISH:\r\ncase HASH_FINISH:\r\nres = hash_final_post_op(sep_dev);\r\nbreak;\r\ncase HASH_DIGEST:\r\nres = hash_digest_post_op(sep_dev);\r\nbreak;\r\ndefault:\r\npr_debug("sep - invalid stage for hash finish\n");\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("sep - invalid request for finish\n");\r\n}\r\nif (res)\r\npr_debug("sep - finish returned error %x\n", res);\r\n}\r\nstatic int sep_hash_cra_init(struct crypto_tfm *tfm)\r\n{\r\nconst char *alg_name = crypto_tfm_alg_name(tfm);\r\npr_debug("sep_hash_cra_init name is %s\n", alg_name);\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct this_task_ctx));\r\nreturn 0;\r\n}\r\nstatic void sep_hash_cra_exit(struct crypto_tfm *tfm)\r\n{\r\npr_debug("sep_hash_cra_exit\n");\r\n}\r\nstatic void sep_hash_init(void *data)\r\n{\r\nu32 msg_offset;\r\nint result;\r\nstruct ahash_request *req;\r\nstruct crypto_ahash *tfm;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct sep_system_ctx *sctx;\r\nunsigned long end_time;\r\nint are_we_done_yet;\r\nreq = (struct ahash_request *)data;\r\ntfm = crypto_ahash_reqtfm(req);\r\nsctx = crypto_ahash_ctx(tfm);\r\nta_ctx = ahash_request_ctx(req);\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->are_we_done_yet = &are_we_done_yet;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_init\n");\r\nta_ctx->current_hash_stage = HASH_INIT;\r\nsep_make_header(ta_ctx, &msg_offset, SEP_HASH_INIT_OPCODE);\r\nsep_write_msg(ta_ctx, &ta_ctx->hash_opmode,\r\nsizeof(u32), sizeof(u32), &msg_offset, 0);\r\nsep_end_msg(ta_ctx, msg_offset);\r\nare_we_done_yet = 0;\r\nresult = sep_crypto_take_sep(ta_ctx);\r\nif (result) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_init take sep failed\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\n}\r\nend_time = jiffies + (WAIT_TIME * HZ);\r\nwhile ((time_before(jiffies, end_time)) && (are_we_done_yet == 0))\r\nschedule();\r\nif (are_we_done_yet == 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash init never got done\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\n}\r\nstatic void sep_hash_update(void *data)\r\n{\r\nint int_error;\r\nu32 msg_offset;\r\nu32 len;\r\nstruct sep_hash_internal_context *int_ctx;\r\nu32 block_size;\r\nu32 head_len;\r\nu32 tail_len;\r\nint are_we_done_yet;\r\nstatic u32 msg[10];\r\nstatic char small_buf[100];\r\nvoid *src_ptr;\r\nstruct scatterlist *new_sg;\r\nssize_t copy_result;\r\nstruct ahash_request *req;\r\nstruct crypto_ahash *tfm;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct sep_system_ctx *sctx;\r\nunsigned long end_time;\r\nreq = (struct ahash_request *)data;\r\ntfm = crypto_ahash_reqtfm(req);\r\nsctx = crypto_ahash_ctx(tfm);\r\nta_ctx = ahash_request_ctx(req);\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->are_we_done_yet = &are_we_done_yet;\r\nta_ctx->nbytes = req->nbytes;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_update\n");\r\nta_ctx->current_hash_stage = HASH_UPDATE;\r\nlen = req->nbytes;\r\nblock_size = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\r\ntail_len = req->nbytes % block_size;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "length is %x\n", len);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "block_size is %x\n", block_size);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "tail len is %x\n", tail_len);\r\nint_ctx = (struct sep_hash_internal_context *)&sctx->\r\nhash_private_ctx.internal_context;\r\nhead_len = (block_size - int_ctx->prev_update_bytes) % block_size;\r\ntail_len = (req->nbytes - head_len) % block_size;\r\nint_error = sep_oddball_pages(ta_ctx->sep_used, req->src,\r\nreq->nbytes,\r\nblock_size, &new_sg, 1);\r\nif (int_error < 0) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"oddball pages error in crash update\n");\r\nsep_crypto_release(sctx, ta_ctx, -ENOMEM);\r\nreturn;\r\n} else if (int_error == 1) {\r\nta_ctx->src_sg = new_sg;\r\nta_ctx->src_sg_hold = new_sg;\r\n} else {\r\nta_ctx->src_sg = req->src;\r\nta_ctx->src_sg_hold = NULL;\r\n}\r\nsrc_ptr = sg_virt(ta_ctx->src_sg);\r\nif ((!req->nbytes) || (!ta_ctx->src_sg)) {\r\nsrc_ptr = NULL;\r\n}\r\nta_ctx->dcb_input_data.app_in_address = src_ptr;\r\nta_ctx->dcb_input_data.data_in_size =\r\nreq->nbytes - (head_len + tail_len);\r\nta_ctx->dcb_input_data.app_out_address = NULL;\r\nta_ctx->dcb_input_data.block_size = block_size;\r\nta_ctx->dcb_input_data.tail_block_size = 0;\r\nta_ctx->dcb_input_data.is_applet = 0;\r\nta_ctx->dcb_input_data.src_sg = ta_ctx->src_sg;\r\nta_ctx->dcb_input_data.dst_sg = NULL;\r\nint_error = sep_create_dcb_dmatables_context_kernel(\r\nta_ctx->sep_used,\r\n&ta_ctx->dcb_region,\r\n&ta_ctx->dmatables_region,\r\n&ta_ctx->dma_ctx,\r\n&ta_ctx->dcb_input_data,\r\n1);\r\nif (int_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"hash update dma table create failed\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\nsep_make_header(ta_ctx, &msg_offset, SEP_HASH_UPDATE_OPCODE);\r\nmsg[0] = (u32)0;\r\nmsg[1] = (u32)0;\r\nmsg[2] = (u32)0;\r\nsep_write_msg(ta_ctx, msg, sizeof(u32) * 3, sizeof(u32) * 3,\r\n&msg_offset, 0);\r\nsep_write_msg(ta_ctx, &head_len, sizeof(u32),\r\nsizeof(u32), &msg_offset, 0);\r\nif (head_len) {\r\ncopy_result = sg_copy_to_buffer(\r\nreq->src,\r\nsep_sg_nents(ta_ctx->src_sg),\r\nsmall_buf, head_len);\r\nif (copy_result != head_len) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sg head copy failure in hash block\n");\r\nsep_crypto_release(sctx, ta_ctx, -ENOMEM);\r\nreturn;\r\n}\r\nsep_write_msg(ta_ctx, small_buf, head_len,\r\nsizeof(u32) * 32, &msg_offset, 1);\r\n} else {\r\nmsg_offset += sizeof(u32) * 32;\r\n}\r\nsep_write_msg(ta_ctx, &tail_len, sizeof(u32),\r\nsizeof(u32), &msg_offset, 0);\r\nif (tail_len) {\r\ncopy_result = sep_copy_offset_sg(\r\nta_ctx->sep_used,\r\nta_ctx->src_sg,\r\nreq->nbytes - tail_len,\r\nsmall_buf, tail_len);\r\nif (copy_result != tail_len) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sg tail copy failure in hash block\n");\r\nsep_crypto_release(sctx, ta_ctx, -ENOMEM);\r\nreturn;\r\n}\r\nsep_write_msg(ta_ctx, small_buf, tail_len,\r\nsizeof(u32) * 32, &msg_offset, 1);\r\n} else {\r\nmsg_offset += sizeof(u32) * 32;\r\n}\r\nsep_write_context(ta_ctx, &msg_offset, &sctx->hash_private_ctx,\r\nsizeof(struct sep_hash_private_context));\r\nsep_end_msg(ta_ctx, msg_offset);\r\nare_we_done_yet = 0;\r\nint_error = sep_crypto_take_sep(ta_ctx);\r\nif (int_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_update take sep failed\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\n}\r\nend_time = jiffies + (WAIT_TIME * HZ);\r\nwhile ((time_before(jiffies, end_time)) && (are_we_done_yet == 0))\r\nschedule();\r\nif (are_we_done_yet == 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash update never got done\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\n}\r\nstatic void sep_hash_final(void *data)\r\n{\r\nu32 msg_offset;\r\nstruct ahash_request *req;\r\nstruct crypto_ahash *tfm;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct sep_system_ctx *sctx;\r\nint result;\r\nunsigned long end_time;\r\nint are_we_done_yet;\r\nreq = (struct ahash_request *)data;\r\ntfm = crypto_ahash_reqtfm(req);\r\nsctx = crypto_ahash_ctx(tfm);\r\nta_ctx = ahash_request_ctx(req);\r\nta_ctx->sep_used = sep_dev;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_final\n");\r\nta_ctx->current_hash_stage = HASH_FINISH;\r\nta_ctx->are_we_done_yet = &are_we_done_yet;\r\nsep_make_header(ta_ctx, &msg_offset, SEP_HASH_FINISH_OPCODE);\r\nsep_write_context(ta_ctx, &msg_offset, &sctx->hash_private_ctx,\r\nsizeof(struct sep_hash_private_context));\r\nsep_end_msg(ta_ctx, msg_offset);\r\nare_we_done_yet = 0;\r\nresult = sep_crypto_take_sep(ta_ctx);\r\nif (result) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_final take sep failed\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\n}\r\nend_time = jiffies + (WAIT_TIME * HZ);\r\nwhile ((time_before(jiffies, end_time)) && (are_we_done_yet == 0))\r\nschedule();\r\nif (are_we_done_yet == 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash final job never got done\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\n}\r\nstatic void sep_hash_digest(void *data)\r\n{\r\nint int_error;\r\nu32 msg_offset;\r\nu32 block_size;\r\nu32 msg[10];\r\nsize_t copy_result;\r\nint result;\r\nint are_we_done_yet;\r\nu32 tail_len;\r\nstatic char small_buf[100];\r\nstruct scatterlist *new_sg;\r\nvoid *src_ptr;\r\nstruct ahash_request *req;\r\nstruct crypto_ahash *tfm;\r\nstruct this_task_ctx *ta_ctx;\r\nstruct sep_system_ctx *sctx;\r\nunsigned long end_time;\r\nreq = (struct ahash_request *)data;\r\ntfm = crypto_ahash_reqtfm(req);\r\nsctx = crypto_ahash_ctx(tfm);\r\nta_ctx = ahash_request_ctx(req);\r\nta_ctx->sep_used = sep_dev;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_digest\n");\r\nta_ctx->current_hash_stage = HASH_DIGEST;\r\nta_ctx->are_we_done_yet = &are_we_done_yet;\r\nta_ctx->nbytes = req->nbytes;\r\nblock_size = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\r\ntail_len = req->nbytes % block_size;\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "length is %x\n", req->nbytes);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "block_size is %x\n", block_size);\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev, "tail len is %x\n", tail_len);\r\nint_error = sep_oddball_pages(ta_ctx->sep_used, req->src,\r\nreq->nbytes,\r\nblock_size, &new_sg, 1);\r\nif (int_error < 0) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"oddball pages error in crash update\n");\r\nsep_crypto_release(sctx, ta_ctx, -ENOMEM);\r\nreturn;\r\n} else if (int_error == 1) {\r\nta_ctx->src_sg = new_sg;\r\nta_ctx->src_sg_hold = new_sg;\r\n} else {\r\nta_ctx->src_sg = req->src;\r\nta_ctx->src_sg_hold = NULL;\r\n}\r\nsrc_ptr = sg_virt(ta_ctx->src_sg);\r\nif ((!req->nbytes) || (!ta_ctx->src_sg)) {\r\nsrc_ptr = NULL;\r\n}\r\nta_ctx->dcb_input_data.app_in_address = src_ptr;\r\nta_ctx->dcb_input_data.data_in_size = req->nbytes - tail_len;\r\nta_ctx->dcb_input_data.app_out_address = NULL;\r\nta_ctx->dcb_input_data.block_size = block_size;\r\nta_ctx->dcb_input_data.tail_block_size = 0;\r\nta_ctx->dcb_input_data.is_applet = 0;\r\nta_ctx->dcb_input_data.src_sg = ta_ctx->src_sg;\r\nta_ctx->dcb_input_data.dst_sg = NULL;\r\nint_error = sep_create_dcb_dmatables_context_kernel(\r\nta_ctx->sep_used,\r\n&ta_ctx->dcb_region,\r\n&ta_ctx->dmatables_region,\r\n&ta_ctx->dma_ctx,\r\n&ta_ctx->dcb_input_data,\r\n1);\r\nif (int_error) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"hash update dma table create failed\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\nsep_make_header(ta_ctx, &msg_offset, SEP_HASH_SINGLE_OPCODE);\r\nsep_write_msg(ta_ctx, &ta_ctx->hash_opmode,\r\nsizeof(u32), sizeof(u32), &msg_offset, 0);\r\nmsg[0] = (u32)0;\r\nmsg[1] = (u32)0;\r\nmsg[2] = (u32)0;\r\nsep_write_msg(ta_ctx, msg, sizeof(u32) * 3, sizeof(u32) * 3,\r\n&msg_offset, 0);\r\nsep_write_msg(ta_ctx, &tail_len, sizeof(u32),\r\nsizeof(u32), &msg_offset, 0);\r\nif (tail_len) {\r\ncopy_result = sep_copy_offset_sg(\r\nta_ctx->sep_used,\r\nta_ctx->src_sg,\r\nreq->nbytes - tail_len,\r\nsmall_buf, tail_len);\r\nif (copy_result != tail_len) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sg tail copy failure in hash block\n");\r\nsep_crypto_release(sctx, ta_ctx, -ENOMEM);\r\nreturn;\r\n}\r\nsep_write_msg(ta_ctx, small_buf, tail_len,\r\nsizeof(u32) * 32, &msg_offset, 1);\r\n} else {\r\nmsg_offset += sizeof(u32) * 32;\r\n}\r\nsep_end_msg(ta_ctx, msg_offset);\r\nare_we_done_yet = 0;\r\nresult = sep_crypto_take_sep(ta_ctx);\r\nif (result) {\r\ndev_warn(&ta_ctx->sep_used->pdev->dev,\r\n"sep_hash_digest take sep failed\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\n}\r\nend_time = jiffies + (WAIT_TIME * HZ);\r\nwhile ((time_before(jiffies, end_time)) && (are_we_done_yet == 0))\r\nschedule();\r\nif (are_we_done_yet == 0) {\r\ndev_dbg(&ta_ctx->sep_used->pdev->dev,\r\n"hash digest job never got done\n");\r\nsep_crypto_release(sctx, ta_ctx, -EINVAL);\r\nreturn;\r\n}\r\n}\r\nstatic void sep_dequeuer(void *data)\r\n{\r\nstruct crypto_queue *this_queue;\r\nstruct crypto_async_request *async_req;\r\nstruct crypto_async_request *backlog;\r\nstruct ablkcipher_request *cypher_req;\r\nstruct ahash_request *hash_req;\r\nstruct sep_system_ctx *sctx;\r\nstruct crypto_ahash *hash_tfm;\r\nstruct this_task_ctx *ta_ctx;\r\nthis_queue = (struct crypto_queue *)data;\r\nspin_lock_irq(&queue_lock);\r\nbacklog = crypto_get_backlog(this_queue);\r\nasync_req = crypto_dequeue_request(this_queue);\r\nspin_unlock_irq(&queue_lock);\r\nif (!async_req) {\r\npr_debug("sep crypto queue is empty\n");\r\nreturn;\r\n}\r\nif (backlog) {\r\npr_debug("sep crypto backlog set\n");\r\nif (backlog->complete)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nbacklog = NULL;\r\n}\r\nif (!async_req->tfm) {\r\npr_debug("sep crypto queue null tfm\n");\r\nreturn;\r\n}\r\nif (!async_req->tfm->__crt_alg) {\r\npr_debug("sep crypto queue null __crt_alg\n");\r\nreturn;\r\n}\r\nif (!async_req->tfm->__crt_alg->cra_type) {\r\npr_debug("sep crypto queue null cra_type\n");\r\nreturn;\r\n}\r\nif (async_req->tfm->__crt_alg->cra_type !=\r\n&crypto_ahash_type) {\r\npr_debug("sep crypto queue doing cipher\n");\r\ncypher_req = container_of(async_req,\r\nstruct ablkcipher_request,\r\nbase);\r\nif (!cypher_req) {\r\npr_debug("sep crypto queue null cypher_req\n");\r\nreturn;\r\n}\r\nsep_crypto_block((void *)cypher_req);\r\nreturn;\r\n} else {\r\npr_debug("sep crypto queue doing hash\n");\r\nhash_req = ahash_request_cast(async_req);\r\nif (!hash_req) {\r\npr_debug("sep crypto queue null hash_req\n");\r\nreturn;\r\n}\r\nhash_tfm = crypto_ahash_reqtfm(hash_req);\r\nif (!hash_tfm) {\r\npr_debug("sep crypto queue null hash_tfm\n");\r\nreturn;\r\n}\r\nsctx = crypto_ahash_ctx(hash_tfm);\r\nif (!sctx) {\r\npr_debug("sep crypto queue null sctx\n");\r\nreturn;\r\n}\r\nta_ctx = ahash_request_ctx(hash_req);\r\nif (ta_ctx->current_hash_stage == HASH_INIT) {\r\npr_debug("sep crypto queue hash init\n");\r\nsep_hash_init((void *)hash_req);\r\nreturn;\r\n} else if (ta_ctx->current_hash_stage == HASH_UPDATE) {\r\npr_debug("sep crypto queue hash update\n");\r\nsep_hash_update((void *)hash_req);\r\nreturn;\r\n} else if (ta_ctx->current_hash_stage == HASH_FINISH) {\r\npr_debug("sep crypto queue hash final\n");\r\nsep_hash_final((void *)hash_req);\r\nreturn;\r\n} else if (ta_ctx->current_hash_stage == HASH_DIGEST) {\r\npr_debug("sep crypto queue hash digest\n");\r\nsep_hash_digest((void *)hash_req);\r\nreturn;\r\n} else if (ta_ctx->current_hash_stage == HASH_FINUP_DATA) {\r\npr_debug("sep crypto queue hash digest\n");\r\nsep_hash_update((void *)hash_req);\r\nreturn;\r\n} else if (ta_ctx->current_hash_stage == HASH_FINUP_FINISH) {\r\npr_debug("sep crypto queue hash digest\n");\r\nsep_hash_final((void *)hash_req);\r\nreturn;\r\n} else {\r\npr_debug("sep crypto queue hash oops nothing\n");\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int sep_sha1_init(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha1 init\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA1;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA1;\r\nta_ctx->current_hash_stage = HASH_INIT;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha1_update(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha1 update\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA1;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA1;\r\nta_ctx->current_hash_stage = HASH_UPDATE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha1_final(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha1 final\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA1;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA1;\r\nta_ctx->current_hash_stage = HASH_FINISH;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha1_digest(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha1 digest\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA1;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA1;\r\nta_ctx->current_hash_stage = HASH_DIGEST;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha1_finup(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha1 finup\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA1;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA1;\r\nta_ctx->current_hash_stage = HASH_FINUP_DATA;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_md5_init(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing md5 init\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = MD5;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_MD5;\r\nta_ctx->current_hash_stage = HASH_INIT;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_md5_update(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing md5 update\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = MD5;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_MD5;\r\nta_ctx->current_hash_stage = HASH_UPDATE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_md5_final(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing md5 final\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = MD5;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_MD5;\r\nta_ctx->current_hash_stage = HASH_FINISH;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_md5_digest(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing md5 digest\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = MD5;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_MD5;\r\nta_ctx->current_hash_stage = HASH_DIGEST;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_md5_finup(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing md5 finup\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = MD5;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_MD5;\r\nta_ctx->current_hash_stage = HASH_FINUP_DATA;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha224_init(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha224 init\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA224;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA224;\r\nta_ctx->current_hash_stage = HASH_INIT;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha224_update(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha224 update\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA224;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA224;\r\nta_ctx->current_hash_stage = HASH_UPDATE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha224_final(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha224 final\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA224;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA224;\r\nta_ctx->current_hash_stage = HASH_FINISH;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha224_digest(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha224 digest\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA224;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA224;\r\nta_ctx->current_hash_stage = HASH_DIGEST;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha224_finup(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha224 finup\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA224;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA224;\r\nta_ctx->current_hash_stage = HASH_FINUP_DATA;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha256_init(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha256 init\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA256;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA256;\r\nta_ctx->current_hash_stage = HASH_INIT;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha256_update(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha256 update\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA256;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA256;\r\nta_ctx->current_hash_stage = HASH_UPDATE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha256_final(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha256 final\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA256;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA256;\r\nta_ctx->current_hash_stage = HASH_FINISH;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha256_digest(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha256 digest\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA256;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA256;\r\nta_ctx->current_hash_stage = HASH_DIGEST;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_sha256_finup(struct ahash_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ahash_request_ctx(req);\r\npr_debug("sep - doing sha256 finup\n");\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = SHA256;\r\nta_ctx->current_hash_req = req;\r\nta_ctx->current_cypher_req = NULL;\r\nta_ctx->hash_opmode = SEP_HASH_SHA256;\r\nta_ctx->current_hash_stage = HASH_FINUP_DATA;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_crypto_init(struct crypto_tfm *tfm)\r\n{\r\nconst char *alg_name = crypto_tfm_alg_name(tfm);\r\nif (alg_name == NULL)\r\npr_debug("sep_crypto_init alg is NULL\n");\r\nelse\r\npr_debug("sep_crypto_init alg is %s\n", alg_name);\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct this_task_ctx);\r\nreturn 0;\r\n}\r\nstatic void sep_crypto_exit(struct crypto_tfm *tfm)\r\n{\r\npr_debug("sep_crypto_exit\n");\r\n}\r\nstatic int sep_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct sep_system_ctx *sctx = crypto_ablkcipher_ctx(tfm);\r\npr_debug("sep aes setkey\n");\r\npr_debug("tfm is %p sctx is %p\n", tfm, sctx);\r\nswitch (keylen) {\r\ncase SEP_AES_KEY_128_SIZE:\r\nsctx->aes_key_size = AES_128;\r\nbreak;\r\ncase SEP_AES_KEY_192_SIZE:\r\nsctx->aes_key_size = AES_192;\r\nbreak;\r\ncase SEP_AES_KEY_256_SIZE:\r\nsctx->aes_key_size = AES_256;\r\nbreak;\r\ncase SEP_AES_KEY_512_SIZE:\r\nsctx->aes_key_size = AES_512;\r\nbreak;\r\ndefault:\r\npr_debug("invalid sep aes key size %x\n",\r\nkeylen);\r\nreturn -EINVAL;\r\n}\r\nmemset(&sctx->key.aes, 0, sizeof(u32) *\r\nSEP_AES_MAX_KEY_SIZE_WORDS);\r\nmemcpy(&sctx->key.aes, key, keylen);\r\nsctx->keylen = keylen;\r\nsctx->key_sent = 0;\r\nreturn 0;\r\n}\r\nstatic int sep_aes_ecb_encrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\npr_debug("sep - doing aes ecb encrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = AES_ECB;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->aes_encmode = SEP_AES_ENCRYPT;\r\nta_ctx->aes_opmode = SEP_AES_ECB;\r\nta_ctx->init_opcode = SEP_AES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_AES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_aes_ecb_decrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\npr_debug("sep - doing aes ecb decrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = AES_ECB;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->aes_encmode = SEP_AES_DECRYPT;\r\nta_ctx->aes_opmode = SEP_AES_ECB;\r\nta_ctx->init_opcode = SEP_AES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_AES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_aes_cbc_encrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\nstruct sep_system_ctx *sctx = crypto_ablkcipher_ctx(\r\ncrypto_ablkcipher_reqtfm(req));\r\npr_debug("sep - doing aes cbc encrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\npr_debug("tfm is %p sctx is %p and ta_ctx is %p\n",\r\ncrypto_ablkcipher_reqtfm(req), sctx, ta_ctx);\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = AES_CBC;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->aes_encmode = SEP_AES_ENCRYPT;\r\nta_ctx->aes_opmode = SEP_AES_CBC;\r\nta_ctx->init_opcode = SEP_AES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_AES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_aes_cbc_decrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\nstruct sep_system_ctx *sctx = crypto_ablkcipher_ctx(\r\ncrypto_ablkcipher_reqtfm(req));\r\npr_debug("sep - doing aes cbc decrypt\n");\r\npr_debug("tfm is %p sctx is %p and ta_ctx is %p\n",\r\ncrypto_ablkcipher_reqtfm(req), sctx, ta_ctx);\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = AES_CBC;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->aes_encmode = SEP_AES_DECRYPT;\r\nta_ctx->aes_opmode = SEP_AES_CBC;\r\nta_ctx->init_opcode = SEP_AES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_AES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct sep_system_ctx *sctx = crypto_ablkcipher_ctx(tfm);\r\nstruct crypto_tfm *ctfm = crypto_ablkcipher_tfm(tfm);\r\nu32 *flags = &ctfm->crt_flags;\r\npr_debug("sep des setkey\n");\r\nswitch (keylen) {\r\ncase DES_KEY_SIZE:\r\nsctx->des_nbr_keys = DES_KEY_1;\r\nbreak;\r\ncase DES_KEY_SIZE * 2:\r\nsctx->des_nbr_keys = DES_KEY_2;\r\nbreak;\r\ncase DES_KEY_SIZE * 3:\r\nsctx->des_nbr_keys = DES_KEY_3;\r\nbreak;\r\ndefault:\r\npr_debug("invalid key size %x\n",\r\nkeylen);\r\nreturn -EINVAL;\r\n}\r\nif ((*flags & CRYPTO_TFM_REQ_WEAK_KEY) &&\r\n(sep_weak_key(key, keylen))) {\r\n*flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\npr_debug("weak key\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&sctx->key.des, 0, sizeof(struct sep_des_key));\r\nmemcpy(&sctx->key.des.key1, key, keylen);\r\nsctx->keylen = keylen;\r\nsctx->key_sent = 0;\r\nreturn 0;\r\n}\r\nstatic int sep_des_ebc_encrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\npr_debug("sep - doing des ecb encrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = DES_ECB;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->des_encmode = SEP_DES_ENCRYPT;\r\nta_ctx->des_opmode = SEP_DES_ECB;\r\nta_ctx->init_opcode = SEP_DES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_DES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_des_ebc_decrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\npr_debug("sep - doing des ecb decrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = DES_ECB;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->des_encmode = SEP_DES_DECRYPT;\r\nta_ctx->des_opmode = SEP_DES_ECB;\r\nta_ctx->init_opcode = SEP_DES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_DES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_des_cbc_encrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\npr_debug("sep - doing des cbc encrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = DES_CBC;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->des_encmode = SEP_DES_ENCRYPT;\r\nta_ctx->des_opmode = SEP_DES_CBC;\r\nta_ctx->init_opcode = SEP_DES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_DES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nstatic int sep_des_cbc_decrypt(struct ablkcipher_request *req)\r\n{\r\nint error;\r\nint error1;\r\nstruct this_task_ctx *ta_ctx = ablkcipher_request_ctx(req);\r\npr_debug("sep - doing des ecb decrypt\n");\r\nmemset(ta_ctx, 0, sizeof(struct this_task_ctx));\r\nta_ctx->sep_used = sep_dev;\r\nta_ctx->current_request = DES_CBC;\r\nta_ctx->current_hash_req = NULL;\r\nta_ctx->current_cypher_req = req;\r\nta_ctx->des_encmode = SEP_DES_DECRYPT;\r\nta_ctx->des_opmode = SEP_DES_CBC;\r\nta_ctx->init_opcode = SEP_DES_INIT_OPCODE;\r\nta_ctx->block_opcode = SEP_DES_BLOCK_OPCODE;\r\nspin_lock_irq(&queue_lock);\r\nerror = crypto_enqueue_request(&sep_queue, &req->base);\r\nif ((error != 0) && (error != -EINPROGRESS))\r\npr_debug(" sep - crypto enqueue failed: %x\n",\r\nerror);\r\nerror1 = sep_submit_work(ta_ctx->sep_used->workqueue,\r\nsep_dequeuer, (void *)&sep_queue);\r\nif (error1)\r\npr_debug(" sep - workqueue submit failed: %x\n",\r\nerror1);\r\nspin_unlock_irq(&queue_lock);\r\nreturn error;\r\n}\r\nint sep_crypto_setup(void)\r\n{\r\nint err, i, j, k;\r\ntasklet_init(&sep_dev->finish_tasklet, sep_finish,\r\n(unsigned long)sep_dev);\r\ncrypto_init_queue(&sep_queue, SEP_QUEUE_LENGTH);\r\nsep_dev->workqueue = create_singlethread_workqueue(\r\n"sep_crypto_workqueue");\r\nif (!sep_dev->workqueue) {\r\ndev_warn(&sep_dev->pdev->dev, "cant create workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&queue_lock);\r\nerr = 0;\r\nfor (i = 0; i < ARRAY_SIZE(hash_algs); i++) {\r\nerr = crypto_register_ahash(&hash_algs[i]);\r\nif (err)\r\ngoto err_algs;\r\n}\r\nerr = 0;\r\nfor (j = 0; j < ARRAY_SIZE(crypto_algs); j++) {\r\nerr = crypto_register_alg(&crypto_algs[j]);\r\nif (err)\r\ngoto err_crypto_algs;\r\n}\r\nreturn err;\r\nerr_algs:\r\nfor (k = 0; k < i; k++)\r\ncrypto_unregister_ahash(&hash_algs[k]);\r\nreturn err;\r\nerr_crypto_algs:\r\nfor (k = 0; k < j; k++)\r\ncrypto_unregister_alg(&crypto_algs[k]);\r\ngoto err_algs;\r\n}\r\nvoid sep_crypto_takedown(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hash_algs); i++)\r\ncrypto_unregister_ahash(&hash_algs[i]);\r\nfor (i = 0; i < ARRAY_SIZE(crypto_algs); i++)\r\ncrypto_unregister_alg(&crypto_algs[i]);\r\ntasklet_kill(&sep_dev->finish_tasklet);\r\n}
