static int simdisk_param_set_filename(const char *val,\r\nconst struct kernel_param *kp)\r\n{\r\nif (n_files < ARRAY_SIZE(filename))\r\nfilename[n_files++] = val;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void simdisk_transfer(struct simdisk *dev, unsigned long sector,\r\nunsigned long nsect, char *buffer, int write)\r\n{\r\nunsigned long offset = sector << SECTOR_SHIFT;\r\nunsigned long nbytes = nsect << SECTOR_SHIFT;\r\nif (offset > dev->size || dev->size - offset < nbytes) {\r\npr_notice("Beyond-end %s (%ld %ld)\n",\r\nwrite ? "write" : "read", offset, nbytes);\r\nreturn;\r\n}\r\nspin_lock(&dev->lock);\r\nwhile (nbytes > 0) {\r\nunsigned long io;\r\nsimc_lseek(dev->fd, offset, SEEK_SET);\r\nif (write)\r\nio = simc_write(dev->fd, buffer, nbytes);\r\nelse\r\nio = simc_read(dev->fd, buffer, nbytes);\r\nif (io == -1) {\r\npr_err("SIMDISK: IO error %d\n", errno);\r\nbreak;\r\n}\r\nbuffer += io;\r\noffset += io;\r\nnbytes -= io;\r\n}\r\nspin_unlock(&dev->lock);\r\n}\r\nstatic int simdisk_xfer_bio(struct simdisk *dev, struct bio *bio)\r\n{\r\nint i;\r\nstruct bio_vec *bvec;\r\nsector_t sector = bio->bi_sector;\r\nbio_for_each_segment(bvec, bio, i) {\r\nchar *buffer = __bio_kmap_atomic(bio, i);\r\nunsigned len = bvec->bv_len >> SECTOR_SHIFT;\r\nsimdisk_transfer(dev, sector, len, buffer,\r\nbio_data_dir(bio) == WRITE);\r\nsector += len;\r\n__bio_kunmap_atomic(bio);\r\n}\r\nreturn 0;\r\n}\r\nstatic void simdisk_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct simdisk *dev = q->queuedata;\r\nint status = simdisk_xfer_bio(dev, bio);\r\nbio_endio(bio, status);\r\n}\r\nstatic int simdisk_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct simdisk *dev = bdev->bd_disk->private_data;\r\nspin_lock(&dev->lock);\r\nif (!dev->users)\r\ncheck_disk_change(bdev);\r\n++dev->users;\r\nspin_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic void simdisk_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct simdisk *dev = disk->private_data;\r\nspin_lock(&dev->lock);\r\n--dev->users;\r\nspin_unlock(&dev->lock);\r\n}\r\nstatic int simdisk_attach(struct simdisk *dev, const char *filename)\r\n{\r\nint err = 0;\r\nfilename = kstrdup(filename, GFP_KERNEL);\r\nif (filename == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&dev->lock);\r\nif (dev->fd != -1) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\ndev->fd = simc_open(filename, O_RDWR, 0);\r\nif (dev->fd == -1) {\r\npr_err("SIMDISK: Can't open %s: %d\n", filename, errno);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ndev->size = simc_lseek(dev->fd, 0, SEEK_END);\r\nset_capacity(dev->gd, dev->size >> SECTOR_SHIFT);\r\ndev->filename = filename;\r\npr_info("SIMDISK: %s=%s\n", dev->gd->disk_name, dev->filename);\r\nout:\r\nif (err)\r\nkfree(filename);\r\nspin_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic int simdisk_detach(struct simdisk *dev)\r\n{\r\nint err = 0;\r\nspin_lock(&dev->lock);\r\nif (dev->users != 0) {\r\nerr = -EBUSY;\r\n} else if (dev->fd != -1) {\r\nif (simc_close(dev->fd)) {\r\npr_err("SIMDISK: error closing %s: %d\n",\r\ndev->filename, errno);\r\nerr = -EIO;\r\n} else {\r\npr_info("SIMDISK: %s detached from %s\n",\r\ndev->gd->disk_name, dev->filename);\r\ndev->fd = -1;\r\nkfree(dev->filename);\r\ndev->filename = NULL;\r\n}\r\n}\r\nspin_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic ssize_t proc_read_simdisk(struct file *file, char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct simdisk *dev = PDE_DATA(file_inode(file));\r\nconst char *s = dev->filename;\r\nif (s) {\r\nssize_t n = simple_read_from_buffer(buf, size, ppos,\r\ns, strlen(s));\r\nif (n < 0)\r\nreturn n;\r\nbuf += n;\r\nsize -= n;\r\n}\r\nreturn simple_read_from_buffer(buf, size, ppos, "\n", 1);\r\n}\r\nstatic ssize_t proc_write_simdisk(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *tmp = kmalloc(count + 1, GFP_KERNEL);\r\nstruct simdisk *dev = PDE_DATA(file_inode(file));\r\nint err;\r\nif (tmp == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(tmp, buf, count)) {\r\nerr = -EFAULT;\r\ngoto out_free;\r\n}\r\nerr = simdisk_detach(dev);\r\nif (err != 0)\r\ngoto out_free;\r\nif (count > 0 && tmp[count - 1] == '\n')\r\ntmp[count - 1] = 0;\r\nelse\r\ntmp[count] = 0;\r\nif (tmp[0])\r\nerr = simdisk_attach(dev, tmp);\r\nif (err == 0)\r\nerr = count;\r\nout_free:\r\nkfree(tmp);\r\nreturn err;\r\n}\r\nstatic int __init simdisk_setup(struct simdisk *dev, int which,\r\nstruct proc_dir_entry *procdir)\r\n{\r\nchar tmp[2] = { '0' + which, 0 };\r\ndev->fd = -1;\r\ndev->filename = NULL;\r\nspin_lock_init(&dev->lock);\r\ndev->users = 0;\r\ndev->queue = blk_alloc_queue(GFP_KERNEL);\r\nif (dev->queue == NULL) {\r\npr_err("blk_alloc_queue failed\n");\r\ngoto out_alloc_queue;\r\n}\r\nblk_queue_make_request(dev->queue, simdisk_make_request);\r\ndev->queue->queuedata = dev;\r\ndev->gd = alloc_disk(SIMDISK_MINORS);\r\nif (dev->gd == NULL) {\r\npr_err("alloc_disk failed\n");\r\ngoto out_alloc_disk;\r\n}\r\ndev->gd->major = simdisk_major;\r\ndev->gd->first_minor = which;\r\ndev->gd->fops = &simdisk_ops;\r\ndev->gd->queue = dev->queue;\r\ndev->gd->private_data = dev;\r\nsnprintf(dev->gd->disk_name, 32, "simdisk%d", which);\r\nset_capacity(dev->gd, 0);\r\nadd_disk(dev->gd);\r\ndev->procfile = proc_create_data(tmp, 0644, procdir, &fops, dev);\r\nreturn 0;\r\nout_alloc_disk:\r\nblk_cleanup_queue(dev->queue);\r\ndev->queue = NULL;\r\nout_alloc_queue:\r\nsimc_close(dev->fd);\r\nreturn -EIO;\r\n}\r\nstatic int __init simdisk_init(void)\r\n{\r\nint i;\r\nif (register_blkdev(simdisk_major, "simdisk") < 0) {\r\npr_err("SIMDISK: register_blkdev: %d\n", simdisk_major);\r\nreturn -EIO;\r\n}\r\npr_info("SIMDISK: major: %d\n", simdisk_major);\r\nif (n_files > simdisk_count)\r\nsimdisk_count = n_files;\r\nif (simdisk_count > MAX_SIMDISK_COUNT)\r\nsimdisk_count = MAX_SIMDISK_COUNT;\r\nsddev = kmalloc(simdisk_count * sizeof(struct simdisk),\r\nGFP_KERNEL);\r\nif (sddev == NULL)\r\ngoto out_unregister;\r\nsimdisk_procdir = proc_mkdir("simdisk", 0);\r\nif (simdisk_procdir == NULL)\r\ngoto out_free_unregister;\r\nfor (i = 0; i < simdisk_count; ++i) {\r\nif (simdisk_setup(sddev + i, i, simdisk_procdir) == 0) {\r\nif (filename[i] != NULL && filename[i][0] != 0 &&\r\n(n_files == 0 || i < n_files))\r\nsimdisk_attach(sddev + i, filename[i]);\r\n}\r\n}\r\nreturn 0;\r\nout_free_unregister:\r\nkfree(sddev);\r\nout_unregister:\r\nunregister_blkdev(simdisk_major, "simdisk");\r\nreturn -ENOMEM;\r\n}\r\nstatic void simdisk_teardown(struct simdisk *dev, int which,\r\nstruct proc_dir_entry *procdir)\r\n{\r\nchar tmp[2] = { '0' + which, 0 };\r\nsimdisk_detach(dev);\r\nif (dev->gd)\r\ndel_gendisk(dev->gd);\r\nif (dev->queue)\r\nblk_cleanup_queue(dev->queue);\r\nremove_proc_entry(tmp, procdir);\r\n}\r\nstatic void __exit simdisk_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < simdisk_count; ++i)\r\nsimdisk_teardown(sddev + i, i, simdisk_procdir);\r\nremove_proc_entry("simdisk", 0);\r\nkfree(sddev);\r\nunregister_blkdev(simdisk_major, "simdisk");\r\n}
