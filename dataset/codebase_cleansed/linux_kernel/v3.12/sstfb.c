static void sst_dbg_print_read_reg(u32 reg, u32 val) {\r\nconst char *regname;\r\nswitch (reg) {\r\ncase FBIINIT0: regname = "FbiInit0"; break;\r\ncase FBIINIT1: regname = "FbiInit1"; break;\r\ncase FBIINIT2: regname = "FbiInit2"; break;\r\ncase FBIINIT3: regname = "FbiInit3"; break;\r\ncase FBIINIT4: regname = "FbiInit4"; break;\r\ncase FBIINIT5: regname = "FbiInit5"; break;\r\ncase FBIINIT6: regname = "FbiInit6"; break;\r\ndefault: regname = NULL; break;\r\n}\r\nif (regname == NULL)\r\nr_ddprintk("sst_read(%#x): %#x\n", reg, val);\r\nelse\r\nr_dprintk(" sst_read(%s): %#x\n", regname, val);\r\n}\r\nstatic void sst_dbg_print_write_reg(u32 reg, u32 val) {\r\nconst char *regname;\r\nswitch (reg) {\r\ncase FBIINIT0: regname = "FbiInit0"; break;\r\ncase FBIINIT1: regname = "FbiInit1"; break;\r\ncase FBIINIT2: regname = "FbiInit2"; break;\r\ncase FBIINIT3: regname = "FbiInit3"; break;\r\ncase FBIINIT4: regname = "FbiInit4"; break;\r\ncase FBIINIT5: regname = "FbiInit5"; break;\r\ncase FBIINIT6: regname = "FbiInit6"; break;\r\ndefault: regname = NULL; break;\r\n}\r\nif (regname == NULL)\r\nr_ddprintk("sst_write(%#x, %#x)\n", reg, val);\r\nelse\r\nr_dprintk(" sst_write(%s, %#x)\n", regname, val);\r\n}\r\nstatic inline u32 __sst_read(u8 __iomem *vbase, u32 reg)\r\n{\r\nu32 ret = readl(vbase + reg);\r\nsst_dbg_print_read_reg(reg, ret);\r\nreturn ret;\r\n}\r\nstatic inline void __sst_write(u8 __iomem *vbase, u32 reg, u32 val)\r\n{\r\nsst_dbg_print_write_reg(reg, val);\r\nwritel(val, vbase + reg);\r\n}\r\nstatic inline void __sst_set_bits(u8 __iomem *vbase, u32 reg, u32 val)\r\n{\r\nr_dprintk("sst_set_bits(%#x, %#x)\n", reg, val);\r\n__sst_write(vbase, reg, __sst_read(vbase, reg) | val);\r\n}\r\nstatic inline void __sst_unset_bits(u8 __iomem *vbase, u32 reg, u32 val)\r\n{\r\nr_dprintk("sst_unset_bits(%#x, %#x)\n", reg, val);\r\n__sst_write(vbase, reg, __sst_read(vbase, reg) & ~val);\r\n}\r\nstatic int __sst_wait_idle(u8 __iomem *vbase)\r\n{\r\nint count = 0;\r\nwhile(1) {\r\nif (__sst_read(vbase, STATUS) & STATUS_FBI_BUSY) {\r\nf_dddprintk("status: busy\n");\r\ncount = 0;\r\n} else {\r\ncount++;\r\nf_dddprintk("status: idle(%d)\n", count);\r\n}\r\nif (count >= 5) return 1;\r\n}\r\n}\r\nstatic u8 __sst_dac_read(u8 __iomem *vbase, u8 reg)\r\n{\r\nu8 ret;\r\nreg &= 0x07;\r\n__sst_write(vbase, DAC_DATA, ((u32)reg << 8) | DAC_READ_CMD );\r\n__sst_wait_idle(vbase);\r\nret = __sst_read(vbase, DAC_READ) & 0xff;\r\nr_dprintk("sst_dac_read(%#x): %#x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic void __sst_dac_write(u8 __iomem *vbase, u8 reg, u8 val)\r\n{\r\nr_dprintk("sst_dac_write(%#x, %#x)\n", reg, val);\r\nreg &= 0x07;\r\n__sst_write(vbase, DAC_DATA,(((u32)reg << 8)) | (u32)val);\r\n__sst_wait_idle(vbase);\r\n}\r\nstatic u32 __dac_i_read(u8 __iomem *vbase, u8 reg)\r\n{\r\nu32 ret;\r\n__sst_dac_write(vbase, DACREG_ADDR_I, reg);\r\nret = __sst_dac_read(vbase, DACREG_DATA_I);\r\nr_dprintk("sst_dac_read_i(%#x): %#x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic void __dac_i_write(u8 __iomem *vbase, u8 reg,u8 val)\r\n{\r\nr_dprintk("sst_dac_write_i(%#x, %#x)\n", reg, val);\r\n__sst_dac_write(vbase, DACREG_ADDR_I, reg);\r\n__sst_dac_write(vbase, DACREG_DATA_I, val);\r\n}\r\nstatic int sst_calc_pll(const int freq, int *freq_out, struct pll_timing *t)\r\n{\r\nint m, m2, n, p, best_err, fout;\r\nint best_n = -1;\r\nint best_m = -1;\r\nbest_err = freq;\r\np = 3;\r\nwhile (((1 << p) * freq > VCO_MAX) && (p >= 0))\r\np--;\r\nif (p == -1)\r\nreturn -EINVAL;\r\nfor (n = 1; n < 32; n++) {\r\nm2 = (2 * freq * (1 << p) * (n + 2) ) / DAC_FREF - 4 ;\r\nm = (m2 % 2 ) ? m2/2+1 : m2/2 ;\r\nif (m >= 128)\r\nbreak;\r\nfout = (DAC_FREF * (m + 2)) / ((1 << p) * (n + 2));\r\nif ((abs(fout - freq) < best_err) && (m > 0)) {\r\nbest_n = n;\r\nbest_m = m;\r\nbest_err = abs(fout - freq);\r\nif (200*best_err < freq) break;\r\n}\r\n}\r\nif (best_n == -1)\r\nreturn -EINVAL;\r\nt->p = p;\r\nt->n = best_n;\r\nt->m = best_m;\r\n*freq_out = (DAC_FREF * (t->m + 2)) / ((1 << t->p) * (t->n + 2));\r\nf_ddprintk ("m: %d, n: %d, p: %d, F: %dKhz\n",\r\nt->m, t->n, t->p, *freq_out);\r\nreturn 0;\r\n}\r\nstatic void sstfb_clear_screen(struct fb_info *info)\r\n{\r\nfb_memset(info->screen_base, 0, info->fix.smem_len);\r\n}\r\nstatic int sstfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nint hSyncOff = var->xres + var->right_margin + var->left_margin;\r\nint vSyncOff = var->yres + var->lower_margin + var->upper_margin;\r\nint vBackPorch = var->left_margin, yDim = var->yres;\r\nint vSyncOn = var->vsync_len;\r\nint tiles_in_X, real_length;\r\nunsigned int freq;\r\nif (sst_calc_pll(PICOS2KHZ(var->pixclock), &freq, &par->pll)) {\r\nprintk(KERN_ERR "sstfb: Pixclock at %ld KHZ out of range\n",\r\nPICOS2KHZ(var->pixclock));\r\nreturn -EINVAL;\r\n}\r\nvar->pixclock = KHZ2PICOS(freq);\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\nvBackPorch += (vBackPorch % 2);\r\nif (var->vmode & FB_VMODE_DOUBLE) {\r\nvBackPorch <<= 1;\r\nyDim <<=1;\r\nvSyncOn <<=1;\r\nvSyncOff <<=1;\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 0 ... 16 :\r\nvar->bits_per_pixel = 16;\r\nbreak;\r\ndefault :\r\nprintk(KERN_ERR "sstfb: Unsupported bpp %d\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres <= 1 || yDim <= 0 || var->hsync_len <= 1 ||\r\nhSyncOff <= 1 || var->left_margin <= 2 || vSyncOn <= 0 ||\r\nvSyncOff <= 0 || vBackPorch <= 0) {\r\nreturn -EINVAL;\r\n}\r\nif (IS_VOODOO2(par)) {\r\ntiles_in_X = (var->xres + 63 ) / 64 * 2;\r\nif (var->xres > POW2(11) || yDim >= POW2(11)) {\r\nprintk(KERN_ERR "sstfb: Unsupported resolution %dx%d\n",\r\nvar->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif (var->hsync_len > POW2(9) || hSyncOff > POW2(11) ||\r\nvar->left_margin - 2 >= POW2(9) || vSyncOn >= POW2(13) ||\r\nvSyncOff >= POW2(13) || vBackPorch >= POW2(9) ||\r\ntiles_in_X >= POW2(6) || tiles_in_X <= 0) {\r\nprintk(KERN_ERR "sstfb: Unsupported timings\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ntiles_in_X = (var->xres + 63 ) / 64;\r\nif (var->vmode) {\r\nprintk(KERN_ERR "sstfb: Interlace/doublescan not supported %#x\n",\r\nvar->vmode);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres > POW2(10) || var->yres >= POW2(10)) {\r\nprintk(KERN_ERR "sstfb: Unsupported resolution %dx%d\n",\r\nvar->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif (var->hsync_len > POW2(8) || hSyncOff - 1 > POW2(10) ||\r\nvar->left_margin - 2 >= POW2(8) || vSyncOn >= POW2(12) ||\r\nvSyncOff >= POW2(12) || vBackPorch >= POW2(8) ||\r\ntiles_in_X >= POW2(4) || tiles_in_X <= 0) {\r\nprintk(KERN_ERR "sstfb: Unsupported timings\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreal_length = tiles_in_X * (IS_VOODOO2(par) ? 32 : 64 )\r\n* ((var->bits_per_pixel == 16) ? 2 : 4);\r\nif (real_length * yDim > info->fix.smem_len) {\r\nprintk(KERN_ERR "sstfb: Not enough video memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvar->sync &= (FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT);\r\nvar->vmode &= (FB_VMODE_INTERLACED | FB_VMODE_DOUBLE);\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->height = -1;\r\nvar->width = -1;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nvar->transp.length = 0;\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sstfb_set_par(struct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nu32 lfbmode, fbiinit1, fbiinit2, fbiinit3, fbiinit5, fbiinit6=0;\r\nstruct pci_dev *sst_dev = par->dev;\r\nunsigned int freq;\r\nint ntiles;\r\npar->hSyncOff = info->var.xres + info->var.right_margin + info->var.left_margin;\r\npar->yDim = info->var.yres;\r\npar->vSyncOn = info->var.vsync_len;\r\npar->vSyncOff = info->var.yres + info->var.lower_margin + info->var.upper_margin;\r\npar->vBackPorch = info->var.upper_margin;\r\nsst_calc_pll(PICOS2KHZ(info->var.pixclock), &freq, &par->pll);\r\nif (info->var.vmode & FB_VMODE_INTERLACED)\r\npar->vBackPorch += (par->vBackPorch % 2);\r\nif (info->var.vmode & FB_VMODE_DOUBLE) {\r\npar->vBackPorch <<= 1;\r\npar->yDim <<=1;\r\npar->vSyncOn <<=1;\r\npar->vSyncOff <<=1;\r\n}\r\nif (IS_VOODOO2(par)) {\r\npar->tiles_in_X = (info->var.xres + 63 ) / 64 * 2;\r\n} else {\r\npar->tiles_in_X = (info->var.xres + 63 ) / 64;\r\n}\r\nf_ddprintk("hsync_len hSyncOff vsync_len vSyncOff\n");\r\nf_ddprintk("%-7d %-8d %-7d %-8d\n",\r\ninfo->var.hsync_len, par->hSyncOff,\r\npar->vSyncOn, par->vSyncOff);\r\nf_ddprintk("left_margin upper_margin xres yres Freq\n");\r\nf_ddprintk("%-10d %-10d %-4d %-4d %-8ld\n",\r\ninfo->var.left_margin, info->var.upper_margin,\r\ninfo->var.xres, info->var.yres, PICOS2KHZ(info->var.pixclock));\r\nsst_write(NOPCMD, 0);\r\nsst_wait_idle();\r\npci_write_config_dword(sst_dev, PCI_INIT_ENABLE, PCI_EN_INIT_WR);\r\nsst_set_bits(FBIINIT1, VIDEO_RESET);\r\nsst_set_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\r\nsst_unset_bits(FBIINIT2, EN_DRAM_REFRESH);\r\nsst_wait_idle();\r\nsst_write(BACKPORCH, par->vBackPorch << 16 | (info->var.left_margin - 2));\r\nsst_write(VIDEODIMENSIONS, par->yDim << 16 | (info->var.xres - 1));\r\nsst_write(HSYNC, (par->hSyncOff - 1) << 16 | (info->var.hsync_len - 1));\r\nsst_write(VSYNC, par->vSyncOff << 16 | par->vSyncOn);\r\nfbiinit2 = sst_read(FBIINIT2);\r\nfbiinit3 = sst_read(FBIINIT3);\r\npci_write_config_dword(sst_dev, PCI_INIT_ENABLE,\r\nPCI_EN_INIT_WR | PCI_REMAP_DAC );\r\npar->dac_sw.set_vidmod(info, info->var.bits_per_pixel);\r\npar->dac_sw.set_pll(info, &par->pll, VID_CLOCK);\r\npci_write_config_dword(sst_dev, PCI_INIT_ENABLE,\r\nPCI_EN_INIT_WR);\r\nsst_write(FBIINIT2,fbiinit2);\r\nsst_write(FBIINIT3,fbiinit3);\r\nfbiinit1 = (sst_read(FBIINIT1) & VIDEO_MASK)\r\n| EN_DATA_OE\r\n| EN_BLANK_OE\r\n| EN_HVSYNC_OE\r\n| EN_DCLK_OE\r\n| SEL_INPUT_VCLK_2X\r\n;\r\nntiles = par->tiles_in_X;\r\nif (IS_VOODOO2(par)) {\r\nfbiinit1 |= ((ntiles & 0x20) >> 5) << TILES_IN_X_MSB_SHIFT\r\n| ((ntiles & 0x1e) >> 1) << TILES_IN_X_SHIFT;\r\nfbiinit6 = (ntiles & 0x1) << TILES_IN_X_LSB_SHIFT;\r\n}\r\nelse\r\nfbiinit1 |= ntiles << TILES_IN_X_SHIFT;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nfbiinit1 |= SEL_SOURCE_VCLK_2X_SEL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsst_write(FBIINIT1, fbiinit1);\r\nif (IS_VOODOO2(par)) {\r\nsst_write(FBIINIT6, fbiinit6);\r\nfbiinit5=sst_read(FBIINIT5) & FBIINIT5_MASK ;\r\nif (info->var.vmode & FB_VMODE_INTERLACED)\r\nfbiinit5 |= INTERLACE;\r\nif (info->var.vmode & FB_VMODE_DOUBLE)\r\nfbiinit5 |= VDOUBLESCAN;\r\nif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nfbiinit5 |= HSYNC_HIGH;\r\nif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nfbiinit5 |= VSYNC_HIGH;\r\nsst_write(FBIINIT5, fbiinit5);\r\n}\r\nsst_wait_idle();\r\nsst_unset_bits(FBIINIT1, VIDEO_RESET);\r\nsst_unset_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\r\nsst_set_bits(FBIINIT2, EN_DRAM_REFRESH);\r\npci_write_config_dword(sst_dev, PCI_INIT_ENABLE, PCI_EN_FIFO_WR);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nlfbmode = LFB_565;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n#if defined(__BIG_ENDIAN)\r\nlfbmode |= ( LFB_WORD_SWIZZLE_WR | LFB_BYTE_SWIZZLE_WR |\r\nLFB_WORD_SWIZZLE_RD | LFB_BYTE_SWIZZLE_RD );\r\n#endif\r\nif (clipping) {\r\nsst_write(LFBMODE, lfbmode | EN_PXL_PIPELINE);\r\nf_ddprintk("setting clipping dimensions 0..%d, 0..%d\n",\r\ninfo->var.xres - 1, par->yDim - 1);\r\nsst_write(CLIP_LEFT_RIGHT, info->var.xres);\r\nsst_write(CLIP_LOWY_HIGHY, par->yDim);\r\nsst_set_bits(FBZMODE, EN_CLIPPING | EN_RGB_WRITE);\r\n} else {\r\nsst_write(LFBMODE, lfbmode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sstfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nu32 col;\r\nf_dddprintk("sstfb_setcolreg\n");\r\nf_dddprintk("%-2d rgbt: %#x, %#x, %#x, %#x\n",\r\nregno, red, green, blue, transp);\r\nif (regno > 15)\r\nreturn 0;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\ntransp >>= (16 - info->var.transp.length);\r\ncol = (red << info->var.red.offset)\r\n| (green << info->var.green.offset)\r\n| (blue << info->var.blue.offset)\r\n| (transp << info->var.transp.offset);\r\npar->palette[regno] = col;\r\nreturn 0;\r\n}\r\nstatic void sstfb_setvgapass( struct fb_info *info, int enable )\r\n{\r\nstruct sstfb_par *par = info->par;\r\nstruct pci_dev *sst_dev = par->dev;\r\nu32 fbiinit0, tmp;\r\nenable = enable ? 1:0;\r\nif (par->vgapass == enable)\r\nreturn;\r\npar->vgapass = enable;\r\npci_read_config_dword(sst_dev, PCI_INIT_ENABLE, &tmp);\r\npci_write_config_dword(sst_dev, PCI_INIT_ENABLE,\r\ntmp | PCI_EN_INIT_WR );\r\nfbiinit0 = sst_read (FBIINIT0);\r\nif (par->vgapass) {\r\nsst_write(FBIINIT0, fbiinit0 & ~DIS_VGA_PASSTHROUGH);\r\nprintk(KERN_INFO "fb%d: Enabling VGA pass-through\n", info->node );\r\n} else {\r\nsst_write(FBIINIT0, fbiinit0 | DIS_VGA_PASSTHROUGH);\r\nprintk(KERN_INFO "fb%d: Disabling VGA pass-through\n", info->node );\r\n}\r\npci_write_config_dword(sst_dev, PCI_INIT_ENABLE, tmp);\r\n}\r\nstatic ssize_t store_vgapass(struct device *device, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(device);\r\nchar ** last = NULL;\r\nint val;\r\nval = simple_strtoul(buf, last, 0);\r\nsstfb_setvgapass(info, val);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vgapass(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(device);\r\nstruct sstfb_par *par = info->par;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", par->vgapass);\r\n}\r\nstatic int sstfb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sstfb_par *par;\r\nu32 val;\r\nswitch (cmd) {\r\ncase SSTFB_SET_VGAPASS:\r\nif (copy_from_user(&val, (void __user *)arg, sizeof(val)))\r\nreturn -EFAULT;\r\nsstfb_setvgapass(info, val);\r\nreturn 0;\r\ncase SSTFB_GET_VGAPASS:\r\npar = info->par;\r\nval = par->vgapass;\r\nif (copy_to_user((void __user *)arg, &val, sizeof(val)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sst_get_memsize(struct fb_info *info, __u32 *memsize)\r\n{\r\nu8 __iomem *fbbase_virt = info->screen_base;\r\nif (mem >= 1 && mem <= 4) {\r\n*memsize = (mem * 0x100000);\r\nprintk(KERN_INFO "supplied memsize: %#x\n", *memsize);\r\nreturn 1;\r\n}\r\nwritel(0xdeadbeef, fbbase_virt);\r\nwritel(0xdeadbeef, fbbase_virt+0x100000);\r\nwritel(0xdeadbeef, fbbase_virt+0x200000);\r\nf_ddprintk("0MB: %#x, 1MB: %#x, 2MB: %#x\n",\r\nreadl(fbbase_virt), readl(fbbase_virt + 0x100000),\r\nreadl(fbbase_virt + 0x200000));\r\nwritel(0xabcdef01, fbbase_virt);\r\nf_ddprintk("0MB: %#x, 1MB: %#x, 2MB: %#x\n",\r\nreadl(fbbase_virt), readl(fbbase_virt + 0x100000),\r\nreadl(fbbase_virt + 0x200000));\r\nif (readl(fbbase_virt + 0x200000) == 0xdeadbeef)\r\n*memsize = 0x400000;\r\nelse if (readl(fbbase_virt + 0x100000) == 0xdeadbeef)\r\n*memsize = 0x200000;\r\nelse\r\n*memsize = 0x100000;\r\nf_ddprintk("detected memsize: %dMB\n", *memsize >> 20);\r\nreturn 1;\r\n}\r\nstatic int sst_detect_att(struct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nint i, mir, dir;\r\nfor (i = 0; i < 3; i++) {\r\nsst_dac_write(DACREG_WMA, 0);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nmir = sst_dac_read(DACREG_RMR);\r\ndir = sst_dac_read(DACREG_RMR);\r\nf_ddprintk("mir: %#x, dir: %#x\n", mir, dir);\r\nif (mir == DACREG_MIR_ATT && dir == DACREG_DIR_ATT) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_detect_ti(struct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nint i, mir, dir;\r\nfor (i = 0; i<3; i++) {\r\nsst_dac_write(DACREG_WMA, 0);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nmir = sst_dac_read(DACREG_RMR);\r\ndir = sst_dac_read(DACREG_RMR);\r\nf_ddprintk("mir: %#x, dir: %#x\n", mir, dir);\r\nif ((mir == DACREG_MIR_TI ) && (dir == DACREG_DIR_TI)) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_detect_ics(struct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nint m_clk0_1, m_clk0_7, m_clk1_b;\r\nint n_clk0_1, n_clk0_7, n_clk1_b;\r\nint i;\r\nfor (i = 0; i<5; i++ ) {\r\nsst_dac_write(DACREG_ICS_PLLRMA, 0x1);\r\nm_clk0_1 = sst_dac_read(DACREG_ICS_PLLDATA);\r\nn_clk0_1 = sst_dac_read(DACREG_ICS_PLLDATA);\r\nsst_dac_write(DACREG_ICS_PLLRMA, 0x7);\r\nm_clk0_7 = sst_dac_read(DACREG_ICS_PLLDATA);\r\nn_clk0_7 = sst_dac_read(DACREG_ICS_PLLDATA);\r\nsst_dac_write(DACREG_ICS_PLLRMA, 0xb);\r\nm_clk1_b= sst_dac_read(DACREG_ICS_PLLDATA);\r\nn_clk1_b= sst_dac_read(DACREG_ICS_PLLDATA);\r\nf_ddprintk("m_clk0_1: %#x, m_clk0_7: %#x, m_clk1_b: %#x\n",\r\nm_clk0_1, m_clk0_7, m_clk1_b);\r\nf_ddprintk("n_clk0_1: %#x, n_clk0_7: %#x, n_clk1_b: %#x\n",\r\nn_clk0_1, n_clk0_7, n_clk1_b);\r\nif (( m_clk0_1 == DACREG_ICS_PLL_CLK0_1_INI)\r\n&& (m_clk0_7 == DACREG_ICS_PLL_CLK0_7_INI)\r\n&& (m_clk1_b == DACREG_ICS_PLL_CLK1_B_INI)) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_set_pll_att_ti(struct fb_info *info,\r\nconst struct pll_timing *t, const int clock)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nu8 cr0, cc;\r\nsst_dac_write(DACREG_WMA, 0);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\ncr0 = sst_dac_read(DACREG_RMR);\r\nsst_dac_write(DACREG_WMA, 0);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_write(DACREG_RMR, (cr0 & 0xf0)\r\n| DACREG_CR0_EN_INDEXED\r\n| DACREG_CR0_8BIT\r\n| DACREG_CR0_PWDOWN );\r\nudelay(300);\r\ncc = dac_i_read(DACREG_CC_I);\r\nswitch (clock) {\r\ncase VID_CLOCK:\r\ndac_i_write(DACREG_AC0_I, t->m);\r\ndac_i_write(DACREG_AC1_I, t->p << 6 | t->n);\r\ndac_i_write(DACREG_CC_I,\r\n(cc & 0x0f) | DACREG_CC_CLKA | DACREG_CC_CLKA_C);\r\nbreak;\r\ncase GFX_CLOCK:\r\ndac_i_write(DACREG_BD0_I, t->m);\r\ndac_i_write(DACREG_BD1_I, t->p << 6 | t->n);\r\ndac_i_write(DACREG_CC_I,\r\n(cc & 0xf0) | DACREG_CC_CLKB | DACREG_CC_CLKB_D);\r\nbreak;\r\ndefault:\r\ndprintk("%s: wrong clock code '%d'\n",\r\n__func__, clock);\r\nreturn 0;\r\n}\r\nudelay(300);\r\ndac_i_write(DACREG_CR0_I,\r\ncr0 & ~DACREG_CR0_PWDOWN & ~DACREG_CR0_EN_INDEXED);\r\nreturn 1;\r\n}\r\nstatic int sst_set_pll_ics(struct fb_info *info,\r\nconst struct pll_timing *t, const int clock)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nu8 pll_ctrl;\r\nsst_dac_write(DACREG_ICS_PLLRMA, DACREG_ICS_PLL_CTRL);\r\npll_ctrl = sst_dac_read(DACREG_ICS_PLLDATA);\r\nswitch(clock) {\r\ncase VID_CLOCK:\r\nsst_dac_write(DACREG_ICS_PLLWMA, 0x0);\r\nsst_dac_write(DACREG_ICS_PLLDATA, t->m);\r\nsst_dac_write(DACREG_ICS_PLLDATA, t->p << 5 | t->n);\r\nsst_dac_write(DACREG_ICS_PLLWMA, DACREG_ICS_PLL_CTRL);\r\nsst_dac_write(DACREG_ICS_PLLDATA,\r\n(pll_ctrl & 0xd8)\r\n| DACREG_ICS_CLK0\r\n| DACREG_ICS_CLK0_0);\r\nbreak;\r\ncase GFX_CLOCK :\r\nsst_dac_write(DACREG_ICS_PLLWMA, 0xa);\r\nsst_dac_write(DACREG_ICS_PLLDATA, t->m);\r\nsst_dac_write(DACREG_ICS_PLLDATA, t->p << 5 | t->n);\r\nsst_dac_write(DACREG_ICS_PLLWMA, DACREG_ICS_PLL_CTRL);\r\nsst_dac_write(DACREG_ICS_PLLDATA,\r\n(pll_ctrl & 0xef) | DACREG_ICS_CLK1_A);\r\nbreak;\r\ndefault:\r\ndprintk("%s: wrong clock code '%d'\n",\r\n__func__, clock);\r\nreturn 0;\r\n}\r\nudelay(300);\r\nreturn 1;\r\n}\r\nstatic void sst_set_vidmod_att_ti(struct fb_info *info, const int bpp)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nu8 cr0;\r\nsst_dac_write(DACREG_WMA, 0);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\ncr0 = sst_dac_read(DACREG_RMR);\r\nsst_dac_write(DACREG_WMA, 0);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nsst_dac_read(DACREG_RMR);\r\nswitch(bpp) {\r\ncase 16:\r\nsst_dac_write(DACREG_RMR, (cr0 & 0x0f) | DACREG_CR0_16BPP);\r\nbreak;\r\ndefault:\r\ndprintk("%s: bad depth '%u'\n", __func__, bpp);\r\nbreak;\r\n}\r\n}\r\nstatic void sst_set_vidmod_ics(struct fb_info *info, const int bpp)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nswitch(bpp) {\r\ncase 16:\r\nsst_dac_write(DACREG_ICS_CMD, DACREG_ICS_CMD_16BPP);\r\nbreak;\r\ndefault:\r\ndprintk("%s: bad depth '%u'\n", __func__, bpp);\r\nbreak;\r\n}\r\n}\r\nstatic int sst_detect_dactype(struct fb_info *info, struct sstfb_par *par)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < ARRAY_SIZE(dacs); i++) {\r\nret = dacs[i].detect(info);\r\nif (ret)\r\nbreak;\r\n}\r\nif (!ret)\r\nreturn 0;\r\nf_dprintk("%s found %s\n", __func__, dacs[i].name);\r\npar->dac_sw = dacs[i];\r\nreturn 1;\r\n}\r\nstatic int sst_init(struct fb_info *info, struct sstfb_par *par)\r\n{\r\nu32 fbiinit0, fbiinit1, fbiinit4;\r\nstruct pci_dev *dev = par->dev;\r\nstruct pll_timing gfx_timings;\r\nstruct sst_spec *spec;\r\nint Fout;\r\nint gfx_clock;\r\nspec = &voodoo_spec[par->type];\r\nf_ddprintk(" fbiinit0 fbiinit1 fbiinit2 fbiinit3 fbiinit4 "\r\n" fbiinit6\n");\r\nf_ddprintk("%0#10x %0#10x %0#10x %0#10x %0#10x %0#10x\n",\r\nsst_read(FBIINIT0), sst_read(FBIINIT1), sst_read(FBIINIT2),\r\nsst_read(FBIINIT3), sst_read(FBIINIT4), sst_read(FBIINIT6));\r\npci_write_config_dword(dev, PCI_VCLK_DISABLE, 0);\r\npci_write_config_dword(dev, PCI_INIT_ENABLE, PCI_EN_INIT_WR);\r\nsst_set_bits(FBIINIT1, VIDEO_RESET);\r\nsst_wait_idle();\r\nsst_set_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\r\nsst_wait_idle();\r\nsst_unset_bits(FBIINIT2, EN_DRAM_REFRESH);\r\nsst_wait_idle();\r\npci_write_config_dword(dev, PCI_INIT_ENABLE,\r\nPCI_EN_INIT_WR | PCI_REMAP_DAC );\r\nif (!sst_detect_dactype(info, par)) {\r\nprintk(KERN_ERR "sstfb: unknown dac type.\n");\r\nreturn 0;\r\n}\r\ngfx_clock = spec->default_gfx_clock;\r\nif ((gfxclk >10 ) && (gfxclk < spec->max_gfxclk)) {\r\nprintk(KERN_INFO "sstfb: Using supplied graphic freq : %dMHz\n", gfxclk);\r\ngfx_clock = gfxclk *1000;\r\n} else if (gfxclk) {\r\nprintk(KERN_WARNING "sstfb: %dMhz is way out of spec! Using default\n", gfxclk);\r\n}\r\nsst_calc_pll(gfx_clock, &Fout, &gfx_timings);\r\npar->dac_sw.set_pll(info, &gfx_timings, GFX_CLOCK);\r\npci_write_config_dword(dev, PCI_INIT_ENABLE,\r\nPCI_EN_INIT_WR| PCI_EN_FIFO_WR );\r\nfbiinit0 = FBIINIT0_DEFAULT;\r\nfbiinit1 = FBIINIT1_DEFAULT;\r\nfbiinit4 = FBIINIT4_DEFAULT;\r\npar->vgapass = vgapass;\r\nif (par->vgapass)\r\nfbiinit0 &= ~DIS_VGA_PASSTHROUGH;\r\nelse\r\nfbiinit0 |= DIS_VGA_PASSTHROUGH;\r\nif (slowpci) {\r\nfbiinit1 |= SLOW_PCI_WRITES;\r\nfbiinit4 |= SLOW_PCI_READS;\r\n} else {\r\nfbiinit1 &= ~SLOW_PCI_WRITES;\r\nfbiinit4 &= ~SLOW_PCI_READS;\r\n}\r\nsst_write(FBIINIT0, fbiinit0);\r\nsst_wait_idle();\r\nsst_write(FBIINIT1, fbiinit1);\r\nsst_wait_idle();\r\nsst_write(FBIINIT2, FBIINIT2_DEFAULT);\r\nsst_wait_idle();\r\nsst_write(FBIINIT3, FBIINIT3_DEFAULT);\r\nsst_wait_idle();\r\nsst_write(FBIINIT4, fbiinit4);\r\nsst_wait_idle();\r\nif (IS_VOODOO2(par)) {\r\nsst_write(FBIINIT6, FBIINIT6_DEFAULT);\r\nsst_wait_idle();\r\n}\r\npci_write_config_dword(dev, PCI_INIT_ENABLE, PCI_EN_FIFO_WR);\r\npci_write_config_dword(dev, PCI_VCLK_ENABLE, 0);\r\nreturn 1;\r\n}\r\nstatic void sst_shutdown(struct fb_info *info)\r\n{\r\nstruct sstfb_par *par = info->par;\r\nstruct pci_dev *dev = par->dev;\r\nstruct pll_timing gfx_timings;\r\nint Fout;\r\npci_write_config_dword(dev, PCI_INIT_ENABLE, PCI_EN_INIT_WR);\r\nsst_set_bits(FBIINIT1, VIDEO_RESET | EN_BLANKING);\r\nsst_unset_bits(FBIINIT2, EN_DRAM_REFRESH);\r\nsst_set_bits(FBIINIT0, FBI_RESET | FIFO_RESET);\r\nsst_wait_idle();\r\npci_write_config_dword(dev, PCI_INIT_ENABLE,\r\nPCI_EN_INIT_WR | PCI_REMAP_DAC);\r\nsst_calc_pll(20000, &Fout, &gfx_timings);\r\npar->dac_sw.set_pll(info, &gfx_timings, GFX_CLOCK);\r\npci_write_config_dword(dev, PCI_INIT_ENABLE,\r\nPCI_EN_INIT_WR);\r\nsst_unset_bits(FBIINIT0, FBI_RESET | FIFO_RESET | DIS_VGA_PASSTHROUGH);\r\npci_write_config_dword(dev, PCI_VCLK_DISABLE,0);\r\npci_write_config_dword(dev, PCI_INIT_ENABLE, 0);\r\n}\r\nstatic int sstfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt) continue;\r\nf_ddprintk("option %s\n", this_opt);\r\nif (!strcmp(this_opt, "vganopass"))\r\nvgapass = 0;\r\nelse if (!strcmp(this_opt, "vgapass"))\r\nvgapass = 1;\r\nelse if (!strcmp(this_opt, "clipping"))\r\nclipping = 1;\r\nelse if (!strcmp(this_opt, "noclipping"))\r\nclipping = 0;\r\nelse if (!strcmp(this_opt, "fastpci"))\r\nslowpci = 0;\r\nelse if (!strcmp(this_opt, "slowpci"))\r\nslowpci = 1;\r\nelse if (!strncmp(this_opt, "mem:",4))\r\nmem = simple_strtoul (this_opt+4, NULL, 0);\r\nelse if (!strncmp(this_opt, "gfxclk:",7))\r\ngfxclk = simple_strtoul (this_opt+7, NULL, 0);\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sstfb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct fb_info *info;\r\nstruct fb_fix_screeninfo *fix;\r\nstruct sstfb_par *par;\r\nstruct sst_spec *spec;\r\nint err;\r\nif ((err=pci_enable_device(pdev))) {\r\nprintk(KERN_ERR "cannot enable device\n");\r\nreturn err;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct sstfb_par), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pdev, info);\r\npar = info->par;\r\nfix = &info->fix;\r\npar->type = id->driver_data;\r\nspec = &voodoo_spec[par->type];\r\nf_ddprintk("found device : %s\n", spec->name);\r\npar->dev = pdev;\r\npar->revision = pdev->revision;\r\nfix->mmio_start = pci_resource_start(pdev,0);\r\nfix->mmio_len = 0x400000;\r\nfix->smem_start = fix->mmio_start + 0x400000;\r\nif (!request_mem_region(fix->mmio_start, fix->mmio_len, "sstfb MMIO")) {\r\nprintk(KERN_ERR "sstfb: cannot reserve mmio memory\n");\r\ngoto fail_mmio_mem;\r\n}\r\nif (!request_mem_region(fix->smem_start, 0x400000,"sstfb FB")) {\r\nprintk(KERN_ERR "sstfb: cannot reserve fb memory\n");\r\ngoto fail_fb_mem;\r\n}\r\npar->mmio_vbase = ioremap_nocache(fix->mmio_start,\r\nfix->mmio_len);\r\nif (!par->mmio_vbase) {\r\nprintk(KERN_ERR "sstfb: cannot remap register area %#lx\n",\r\nfix->mmio_start);\r\ngoto fail_mmio_remap;\r\n}\r\ninfo->screen_base = ioremap_nocache(fix->smem_start, 0x400000);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "sstfb: cannot remap framebuffer %#lx\n",\r\nfix->smem_start);\r\ngoto fail_fb_remap;\r\n}\r\nif (!sst_init(info, par)) {\r\nprintk(KERN_ERR "sstfb: Init failed\n");\r\ngoto fail;\r\n}\r\nsst_get_memsize(info, &fix->smem_len);\r\nstrlcpy(fix->id, spec->name, sizeof(fix->id));\r\nprintk(KERN_INFO "%s (revision %d) with %s dac\n",\r\nfix->id, par->revision, par->dac_sw.name);\r\nprintk(KERN_INFO "framebuffer at %#lx, mapped to 0x%p, size %dMB\n",\r\nfix->smem_start, info->screen_base,\r\nfix->smem_len >> 20);\r\nf_ddprintk("regbase_virt: %#lx\n", par->mmio_vbase);\r\nf_ddprintk("membase_phys: %#lx\n", fix->smem_start);\r\nf_ddprintk("fbbase_virt: %p\n", info->screen_base);\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->fbops = &sstfb_ops;\r\ninfo->pseudo_palette = par->palette;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->accel = FB_ACCEL_NONE;\r\nfix->line_length = 2048;\r\nfb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 16);\r\nif (sstfb_check_var(&info->var, info)) {\r\nprintk(KERN_ERR "sstfb: invalid video mode.\n");\r\ngoto fail;\r\n}\r\nif (sstfb_set_par(info)) {\r\nprintk(KERN_ERR "sstfb: can't set default video mode.\n");\r\ngoto fail;\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 0)) {\r\nprintk(KERN_ERR "sstfb: can't alloc cmap memory.\n");\r\ngoto fail;\r\n}\r\ninfo->device = &pdev->dev;\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "sstfb: can't register framebuffer.\n");\r\ngoto fail_register;\r\n}\r\nsstfb_clear_screen(info);\r\nif (device_create_file(info->dev, &device_attrs[0]))\r\nprintk(KERN_WARNING "sstfb: can't create sysfs entry.\n");\r\nprintk(KERN_INFO "fb%d: %s frame buffer device at 0x%p\n",\r\ninfo->node, fix->id, info->screen_base);\r\nreturn 0;\r\nfail_register:\r\nfb_dealloc_cmap(&info->cmap);\r\nfail:\r\niounmap(info->screen_base);\r\nfail_fb_remap:\r\niounmap(par->mmio_vbase);\r\nfail_mmio_remap:\r\nrelease_mem_region(fix->smem_start, 0x400000);\r\nfail_fb_mem:\r\nrelease_mem_region(fix->mmio_start, info->fix.mmio_len);\r\nfail_mmio_mem:\r\nframebuffer_release(info);\r\nreturn -ENXIO;\r\n}\r\nstatic void sstfb_remove(struct pci_dev *pdev)\r\n{\r\nstruct sstfb_par *par;\r\nstruct fb_info *info;\r\ninfo = pci_get_drvdata(pdev);\r\npar = info->par;\r\ndevice_remove_file(info->dev, &device_attrs[0]);\r\nsst_shutdown(info);\r\niounmap(info->screen_base);\r\niounmap(par->mmio_vbase);\r\nrelease_mem_region(info->fix.smem_start, 0x400000);\r\nrelease_mem_region(info->fix.mmio_start, info->fix.mmio_len);\r\nfb_dealloc_cmap(&info->cmap);\r\nunregister_framebuffer(info);\r\nframebuffer_release(info);\r\n}\r\nstatic int sstfb_init(void)\r\n{\r\nchar *option = NULL;\r\nif (fb_get_options("sstfb", &option))\r\nreturn -ENODEV;\r\nsstfb_setup(option);\r\nreturn pci_register_driver(&sstfb_driver);\r\n}\r\nstatic void sstfb_exit(void)\r\n{\r\npci_unregister_driver(&sstfb_driver);\r\n}
