static int __init vsyscall_setup(char *str)\r\n{\r\nif (str) {\r\nif (!strcmp("emulate", str))\r\nvsyscall_mode = EMULATE;\r\nelse if (!strcmp("native", str))\r\nvsyscall_mode = NATIVE;\r\nelse if (!strcmp("none", str))\r\nvsyscall_mode = NONE;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid update_vsyscall_tz(void)\r\n{\r\nvsyscall_gtod_data.sys_tz = sys_tz;\r\n}\r\nvoid update_vsyscall(struct timekeeper *tk)\r\n{\r\nstruct vsyscall_gtod_data *vdata = &vsyscall_gtod_data;\r\nwrite_seqcount_begin(&vdata->seq);\r\nvdata->clock.vclock_mode = tk->clock->archdata.vclock_mode;\r\nvdata->clock.cycle_last = tk->clock->cycle_last;\r\nvdata->clock.mask = tk->clock->mask;\r\nvdata->clock.mult = tk->mult;\r\nvdata->clock.shift = tk->shift;\r\nvdata->wall_time_sec = tk->xtime_sec;\r\nvdata->wall_time_snsec = tk->xtime_nsec;\r\nvdata->monotonic_time_sec = tk->xtime_sec\r\n+ tk->wall_to_monotonic.tv_sec;\r\nvdata->monotonic_time_snsec = tk->xtime_nsec\r\n+ (tk->wall_to_monotonic.tv_nsec\r\n<< tk->shift);\r\nwhile (vdata->monotonic_time_snsec >=\r\n(((u64)NSEC_PER_SEC) << tk->shift)) {\r\nvdata->monotonic_time_snsec -=\r\n((u64)NSEC_PER_SEC) << tk->shift;\r\nvdata->monotonic_time_sec++;\r\n}\r\nvdata->wall_time_coarse.tv_sec = tk->xtime_sec;\r\nvdata->wall_time_coarse.tv_nsec = (long)(tk->xtime_nsec >> tk->shift);\r\nvdata->monotonic_time_coarse = timespec_add(vdata->wall_time_coarse,\r\ntk->wall_to_monotonic);\r\nwrite_seqcount_end(&vdata->seq);\r\n}\r\nstatic void warn_bad_vsyscall(const char *level, struct pt_regs *regs,\r\nconst char *message)\r\n{\r\nif (!show_unhandled_signals)\r\nreturn;\r\npr_notice_ratelimited("%s%s[%d] %s ip:%lx cs:%lx sp:%lx ax:%lx si:%lx di:%lx\n",\r\nlevel, current->comm, task_pid_nr(current),\r\nmessage, regs->ip, regs->cs,\r\nregs->sp, regs->ax, regs->si, regs->di);\r\n}\r\nstatic int addr_to_vsyscall_nr(unsigned long addr)\r\n{\r\nint nr;\r\nif ((addr & ~0xC00UL) != VSYSCALL_START)\r\nreturn -EINVAL;\r\nnr = (addr & 0xC00UL) >> 10;\r\nif (nr >= 3)\r\nreturn -EINVAL;\r\nreturn nr;\r\n}\r\nstatic bool write_ok_or_segv(unsigned long ptr, size_t size)\r\n{\r\nif (!access_ok(VERIFY_WRITE, (void __user *)ptr, size)) {\r\nsiginfo_t info;\r\nstruct thread_struct *thread = &current->thread;\r\nthread->error_code = 6;\r\nthread->cr2 = ptr;\r\nthread->trap_nr = X86_TRAP_PF;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_errno = 0;\r\ninfo.si_code = SEGV_MAPERR;\r\ninfo.si_addr = (void __user *)ptr;\r\nforce_sig_info(SIGSEGV, &info, current);\r\nreturn false;\r\n} else {\r\nreturn true;\r\n}\r\n}\r\nbool emulate_vsyscall(struct pt_regs *regs, unsigned long address)\r\n{\r\nstruct task_struct *tsk;\r\nunsigned long caller;\r\nint vsyscall_nr, syscall_nr, tmp;\r\nint prev_sig_on_uaccess_error;\r\nlong ret;\r\nWARN_ON_ONCE(address != regs->ip);\r\nif (vsyscall_mode == NONE) {\r\nwarn_bad_vsyscall(KERN_INFO, regs,\r\n"vsyscall attempted with vsyscall=none");\r\nreturn false;\r\n}\r\nvsyscall_nr = addr_to_vsyscall_nr(address);\r\ntrace_emulate_vsyscall(vsyscall_nr);\r\nif (vsyscall_nr < 0) {\r\nwarn_bad_vsyscall(KERN_WARNING, regs,\r\n"misaligned vsyscall (exploit attempt or buggy program) -- look up the vsyscall kernel parameter if you need a workaround");\r\ngoto sigsegv;\r\n}\r\nif (get_user(caller, (unsigned long __user *)regs->sp) != 0) {\r\nwarn_bad_vsyscall(KERN_WARNING, regs,\r\n"vsyscall with bad stack (exploit attempt?)");\r\ngoto sigsegv;\r\n}\r\ntsk = current;\r\nswitch (vsyscall_nr) {\r\ncase 0:\r\nif (!write_ok_or_segv(regs->di, sizeof(struct timeval)) ||\r\n!write_ok_or_segv(regs->si, sizeof(struct timezone))) {\r\nret = -EFAULT;\r\ngoto check_fault;\r\n}\r\nsyscall_nr = __NR_gettimeofday;\r\nbreak;\r\ncase 1:\r\nif (!write_ok_or_segv(regs->di, sizeof(time_t))) {\r\nret = -EFAULT;\r\ngoto check_fault;\r\n}\r\nsyscall_nr = __NR_time;\r\nbreak;\r\ncase 2:\r\nif (!write_ok_or_segv(regs->di, sizeof(unsigned)) ||\r\n!write_ok_or_segv(regs->si, sizeof(unsigned))) {\r\nret = -EFAULT;\r\ngoto check_fault;\r\n}\r\nsyscall_nr = __NR_getcpu;\r\nbreak;\r\n}\r\nregs->orig_ax = syscall_nr;\r\nregs->ax = -ENOSYS;\r\ntmp = secure_computing(syscall_nr);\r\nif ((!tmp && regs->orig_ax != syscall_nr) || regs->ip != address) {\r\nwarn_bad_vsyscall(KERN_DEBUG, regs,\r\n"seccomp tried to change syscall nr or ip");\r\ndo_exit(SIGSYS);\r\n}\r\nif (tmp)\r\ngoto do_ret;\r\nprev_sig_on_uaccess_error = current_thread_info()->sig_on_uaccess_error;\r\ncurrent_thread_info()->sig_on_uaccess_error = 1;\r\nret = -EFAULT;\r\nswitch (vsyscall_nr) {\r\ncase 0:\r\nret = sys_gettimeofday(\r\n(struct timeval __user *)regs->di,\r\n(struct timezone __user *)regs->si);\r\nbreak;\r\ncase 1:\r\nret = sys_time((time_t __user *)regs->di);\r\nbreak;\r\ncase 2:\r\nret = sys_getcpu((unsigned __user *)regs->di,\r\n(unsigned __user *)regs->si,\r\nNULL);\r\nbreak;\r\n}\r\ncurrent_thread_info()->sig_on_uaccess_error = prev_sig_on_uaccess_error;\r\ncheck_fault:\r\nif (ret == -EFAULT) {\r\nwarn_bad_vsyscall(KERN_INFO, regs,\r\n"vsyscall fault (exploit attempt?)");\r\nif (WARN_ON_ONCE(!sigismember(&tsk->pending.signal, SIGBUS) &&\r\n!sigismember(&tsk->pending.signal, SIGSEGV)))\r\ngoto sigsegv;\r\nreturn true;\r\n}\r\nregs->ax = ret;\r\ndo_ret:\r\nregs->ip = caller;\r\nregs->sp += 8;\r\nreturn true;\r\nsigsegv:\r\nforce_sig(SIGSEGV, current);\r\nreturn true;\r\n}\r\nstatic void vsyscall_set_cpu(int cpu)\r\n{\r\nunsigned long d;\r\nunsigned long node = 0;\r\n#ifdef CONFIG_NUMA\r\nnode = cpu_to_node(cpu);\r\n#endif\r\nif (cpu_has(&cpu_data(cpu), X86_FEATURE_RDTSCP))\r\nwrite_rdtscp_aux((node << 12) | cpu);\r\nd = 0x0f40000000000ULL;\r\nd |= cpu;\r\nd |= (node & 0xf) << 12;\r\nd |= (node >> 4) << 48;\r\nwrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_PER_CPU, &d, DESCTYPE_S);\r\n}\r\nstatic void cpu_vsyscall_init(void *arg)\r\n{\r\nvsyscall_set_cpu(raw_smp_processor_id());\r\n}\r\nstatic int\r\ncpu_vsyscall_notifier(struct notifier_block *n, unsigned long action, void *arg)\r\n{\r\nlong cpu = (long)arg;\r\nif (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)\r\nsmp_call_function_single(cpu, cpu_vsyscall_init, NULL, 1);\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid __init map_vsyscall(void)\r\n{\r\nextern char __vsyscall_page;\r\nunsigned long physaddr_vsyscall = __pa_symbol(&__vsyscall_page);\r\nextern char __vvar_page;\r\nunsigned long physaddr_vvar_page = __pa_symbol(&__vvar_page);\r\n__set_fixmap(VSYSCALL_FIRST_PAGE, physaddr_vsyscall,\r\nvsyscall_mode == NATIVE\r\n? PAGE_KERNEL_VSYSCALL\r\n: PAGE_KERNEL_VVAR);\r\nBUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_FIRST_PAGE) !=\r\n(unsigned long)VSYSCALL_START);\r\n__set_fixmap(VVAR_PAGE, physaddr_vvar_page, PAGE_KERNEL_VVAR);\r\nBUILD_BUG_ON((unsigned long)__fix_to_virt(VVAR_PAGE) !=\r\n(unsigned long)VVAR_ADDRESS);\r\n}\r\nstatic int __init vsyscall_init(void)\r\n{\r\nBUG_ON(VSYSCALL_ADDR(0) != __fix_to_virt(VSYSCALL_FIRST_PAGE));\r\non_each_cpu(cpu_vsyscall_init, NULL, 1);\r\nhotcpu_notifier(cpu_vsyscall_notifier, 30);\r\nreturn 0;\r\n}
