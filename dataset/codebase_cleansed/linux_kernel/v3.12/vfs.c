int\r\nnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp,\r\nstruct svc_export **expp)\r\n{\r\nstruct svc_export *exp = *expp, *exp2 = NULL;\r\nstruct dentry *dentry = *dpp;\r\nstruct path path = {.mnt = mntget(exp->ex_path.mnt),\r\n.dentry = dget(dentry)};\r\nint err = 0;\r\nerr = follow_down(&path);\r\nif (err < 0)\r\ngoto out;\r\nexp2 = rqst_exp_get_by_name(rqstp, &path);\r\nif (IS_ERR(exp2)) {\r\nerr = PTR_ERR(exp2);\r\nif (err == -ENOENT && !(exp->ex_flags & NFSEXP_V4ROOT))\r\nerr = 0;\r\npath_put(&path);\r\ngoto out;\r\n}\r\nif (nfsd_v4client(rqstp) ||\r\n(exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {\r\n*dpp = path.dentry;\r\npath.dentry = dentry;\r\n*expp = exp2;\r\nexp2 = exp;\r\n}\r\npath_put(&path);\r\nexp_put(exp2);\r\nout:\r\nreturn err;\r\n}\r\nstatic void follow_to_parent(struct path *path)\r\n{\r\nstruct dentry *dp;\r\nwhile (path->dentry == path->mnt->mnt_root && follow_up(path))\r\n;\r\ndp = dget_parent(path->dentry);\r\ndput(path->dentry);\r\npath->dentry = dp;\r\n}\r\nstatic int nfsd_lookup_parent(struct svc_rqst *rqstp, struct dentry *dparent, struct svc_export **exp, struct dentry **dentryp)\r\n{\r\nstruct svc_export *exp2;\r\nstruct path path = {.mnt = mntget((*exp)->ex_path.mnt),\r\n.dentry = dget(dparent)};\r\nfollow_to_parent(&path);\r\nexp2 = rqst_exp_parent(rqstp, &path);\r\nif (PTR_ERR(exp2) == -ENOENT) {\r\n*dentryp = dget(dparent);\r\n} else if (IS_ERR(exp2)) {\r\npath_put(&path);\r\nreturn PTR_ERR(exp2);\r\n} else {\r\n*dentryp = dget(path.dentry);\r\nexp_put(*exp);\r\n*exp = exp2;\r\n}\r\npath_put(&path);\r\nreturn 0;\r\n}\r\nint nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\r\n{\r\nif (d_mountpoint(dentry))\r\nreturn 1;\r\nif (nfsd4_is_junction(dentry))\r\nreturn 1;\r\nif (!(exp->ex_flags & NFSEXP_V4ROOT))\r\nreturn 0;\r\nreturn dentry->d_inode != NULL;\r\n}\r\n__be32\r\nnfsd_lookup_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nconst char *name, unsigned int len,\r\nstruct svc_export **exp_ret, struct dentry **dentry_ret)\r\n{\r\nstruct svc_export *exp;\r\nstruct dentry *dparent;\r\nstruct dentry *dentry;\r\nint host_err;\r\ndprintk("nfsd: nfsd_lookup(fh %s, %.*s)\n", SVCFH_fmt(fhp), len,name);\r\ndparent = fhp->fh_dentry;\r\nexp = fhp->fh_export;\r\nexp_get(exp);\r\nif (isdotent(name, len)) {\r\nif (len==1)\r\ndentry = dget(dparent);\r\nelse if (dparent != exp->ex_path.dentry)\r\ndentry = dget_parent(dparent);\r\nelse if (!EX_NOHIDE(exp) && !nfsd_v4client(rqstp))\r\ndentry = dget(dparent);\r\nelse {\r\nhost_err = nfsd_lookup_parent(rqstp, dparent, &exp, &dentry);\r\nif (host_err)\r\ngoto out_nfserr;\r\n}\r\n} else {\r\nfh_lock(fhp);\r\ndentry = lookup_one_len(name, dparent, len);\r\nhost_err = PTR_ERR(dentry);\r\nif (IS_ERR(dentry))\r\ngoto out_nfserr;\r\nif (nfsd_mountpoint(dentry, exp)) {\r\nif ((host_err = nfsd_cross_mnt(rqstp, &dentry, &exp))) {\r\ndput(dentry);\r\ngoto out_nfserr;\r\n}\r\n}\r\n}\r\n*dentry_ret = dentry;\r\n*exp_ret = exp;\r\nreturn 0;\r\nout_nfserr:\r\nexp_put(exp);\r\nreturn nfserrno(host_err);\r\n}\r\n__be32\r\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\r\nunsigned int len, struct svc_fh *resfh)\r\n{\r\nstruct svc_export *exp;\r\nstruct dentry *dentry;\r\n__be32 err;\r\nerr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\r\nif (err)\r\nreturn err;\r\nerr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\r\nif (err)\r\nreturn err;\r\nerr = check_nfsd_access(exp, rqstp);\r\nif (err)\r\ngoto out;\r\nerr = fh_compose(resfh, exp, dentry, fhp);\r\nif (!err && !dentry->d_inode)\r\nerr = nfserr_noent;\r\nout:\r\ndput(dentry);\r\nexp_put(exp);\r\nreturn err;\r\n}\r\nstatic int nfsd_break_lease(struct inode *inode)\r\n{\r\nif (!S_ISREG(inode->i_mode))\r\nreturn 0;\r\nreturn break_lease(inode, O_WRONLY | O_NONBLOCK);\r\n}\r\nstatic int\r\ncommit_metadata(struct svc_fh *fhp)\r\n{\r\nstruct inode *inode = fhp->fh_dentry->d_inode;\r\nconst struct export_operations *export_ops = inode->i_sb->s_export_op;\r\nif (!EX_ISSYNC(fhp->fh_export))\r\nreturn 0;\r\nif (export_ops->commit_metadata)\r\nreturn export_ops->commit_metadata(inode);\r\nreturn sync_inode_metadata(inode, 1);\r\n}\r\n__be32\r\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\r\nint check_guard, time_t guardtime)\r\n{\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nint accmode = NFSD_MAY_SATTR;\r\numode_t ftype = 0;\r\n__be32 err;\r\nint host_err;\r\nint size_change = 0;\r\nif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\r\naccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\r\nif (iap->ia_valid & ATTR_SIZE)\r\nftype = S_IFREG;\r\nerr = fh_verify(rqstp, fhp, ftype, accmode);\r\nif (err)\r\ngoto out;\r\ndentry = fhp->fh_dentry;\r\ninode = dentry->d_inode;\r\nif (S_ISLNK(inode->i_mode))\r\niap->ia_valid &= ~ATTR_MODE;\r\nif (!iap->ia_valid)\r\ngoto out;\r\n#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)\r\n#define MAX_TOUCH_TIME_ERROR (30*60)\r\nif ((iap->ia_valid & BOTH_TIME_SET) == BOTH_TIME_SET &&\r\niap->ia_mtime.tv_sec == iap->ia_atime.tv_sec) {\r\ntime_t delta = iap->ia_atime.tv_sec - get_seconds();\r\nif (delta < 0)\r\ndelta = -delta;\r\nif (delta < MAX_TOUCH_TIME_ERROR &&\r\ninode_change_ok(inode, iap) != 0) {\r\niap->ia_valid &= ~BOTH_TIME_SET;\r\n}\r\n}\r\nif (iap->ia_valid & ATTR_SIZE) {\r\nif (iap->ia_size < inode->i_size) {\r\nerr = nfsd_permission(rqstp, fhp->fh_export, dentry,\r\nNFSD_MAY_TRUNC|NFSD_MAY_OWNER_OVERRIDE);\r\nif (err)\r\ngoto out;\r\n}\r\nhost_err = get_write_access(inode);\r\nif (host_err)\r\ngoto out_nfserr;\r\nsize_change = 1;\r\nhost_err = locks_verify_truncate(inode, NULL, iap->ia_size);\r\nif (host_err) {\r\nput_write_access(inode);\r\ngoto out_nfserr;\r\n}\r\n}\r\nif (iap->ia_valid & ATTR_MODE) {\r\niap->ia_mode &= S_IALLUGO;\r\niap->ia_mode |= (inode->i_mode & ~S_IALLUGO);\r\n}\r\nif (!S_ISDIR(inode->i_mode) &&\r\n(((iap->ia_valid & ATTR_UID) && !uid_eq(iap->ia_uid, inode->i_uid)) ||\r\n((iap->ia_valid & ATTR_GID) && !gid_eq(iap->ia_gid, inode->i_gid)))) {\r\niap->ia_valid |= ATTR_KILL_PRIV;\r\nif (iap->ia_valid & ATTR_MODE) {\r\niap->ia_mode &= ~S_ISUID;\r\nif (iap->ia_mode & S_IXGRP)\r\niap->ia_mode &= ~S_ISGID;\r\n} else {\r\niap->ia_valid |= (ATTR_KILL_SUID | ATTR_KILL_SGID);\r\n}\r\n}\r\niap->ia_valid |= ATTR_CTIME;\r\nerr = nfserr_notsync;\r\nif (!check_guard || guardtime == inode->i_ctime.tv_sec) {\r\nhost_err = nfsd_break_lease(inode);\r\nif (host_err)\r\ngoto out_nfserr;\r\nfh_lock(fhp);\r\nhost_err = notify_change(dentry, iap);\r\nerr = nfserrno(host_err);\r\nfh_unlock(fhp);\r\n}\r\nif (size_change)\r\nput_write_access(inode);\r\nif (!err)\r\ncommit_metadata(fhp);\r\nout:\r\nreturn err;\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\nstatic ssize_t nfsd_getxattr(struct dentry *dentry, char *key, void **buf)\r\n{\r\nssize_t buflen;\r\nssize_t ret;\r\nbuflen = vfs_getxattr(dentry, key, NULL, 0);\r\nif (buflen <= 0)\r\nreturn buflen;\r\n*buf = kmalloc(buflen, GFP_KERNEL);\r\nif (!*buf)\r\nreturn -ENOMEM;\r\nret = vfs_getxattr(dentry, key, *buf, buflen);\r\nif (ret < 0)\r\nkfree(*buf);\r\nreturn ret;\r\n}\r\nstatic int\r\nset_nfsv4_acl_one(struct dentry *dentry, struct posix_acl *pacl, char *key)\r\n{\r\nint len;\r\nsize_t buflen;\r\nchar *buf = NULL;\r\nint error = 0;\r\nbuflen = posix_acl_xattr_size(pacl->a_count);\r\nbuf = kmalloc(buflen, GFP_KERNEL);\r\nerror = -ENOMEM;\r\nif (buf == NULL)\r\ngoto out;\r\nlen = posix_acl_to_xattr(&init_user_ns, pacl, buf, buflen);\r\nif (len < 0) {\r\nerror = len;\r\ngoto out;\r\n}\r\nerror = vfs_setxattr(dentry, key, buf, len, 0);\r\nout:\r\nkfree(buf);\r\nreturn error;\r\n}\r\n__be32\r\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nstruct nfs4_acl *acl)\r\n{\r\n__be32 error;\r\nint host_error;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nstruct posix_acl *pacl = NULL, *dpacl = NULL;\r\nunsigned int flags = 0;\r\nerror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\r\nif (error)\r\nreturn error;\r\ndentry = fhp->fh_dentry;\r\ninode = dentry->d_inode;\r\nif (S_ISDIR(inode->i_mode))\r\nflags = NFS4_ACL_DIR;\r\nhost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\r\nif (host_error == -EINVAL) {\r\nreturn nfserr_attrnotsupp;\r\n} else if (host_error < 0)\r\ngoto out_nfserr;\r\nhost_error = set_nfsv4_acl_one(dentry, pacl, POSIX_ACL_XATTR_ACCESS);\r\nif (host_error < 0)\r\ngoto out_release;\r\nif (S_ISDIR(inode->i_mode))\r\nhost_error = set_nfsv4_acl_one(dentry, dpacl, POSIX_ACL_XATTR_DEFAULT);\r\nout_release:\r\nposix_acl_release(pacl);\r\nposix_acl_release(dpacl);\r\nout_nfserr:\r\nif (host_error == -EOPNOTSUPP)\r\nreturn nfserr_attrnotsupp;\r\nelse\r\nreturn nfserrno(host_error);\r\n}\r\nstatic struct posix_acl *\r\n_get_posix_acl(struct dentry *dentry, char *key)\r\n{\r\nvoid *buf = NULL;\r\nstruct posix_acl *pacl = NULL;\r\nint buflen;\r\nbuflen = nfsd_getxattr(dentry, key, &buf);\r\nif (!buflen)\r\nbuflen = -ENODATA;\r\nif (buflen <= 0)\r\nreturn ERR_PTR(buflen);\r\npacl = posix_acl_from_xattr(&init_user_ns, buf, buflen);\r\nkfree(buf);\r\nreturn pacl;\r\n}\r\nint\r\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry, struct nfs4_acl **acl)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nint error = 0;\r\nstruct posix_acl *pacl = NULL, *dpacl = NULL;\r\nunsigned int flags = 0;\r\npacl = _get_posix_acl(dentry, POSIX_ACL_XATTR_ACCESS);\r\nif (IS_ERR(pacl) && PTR_ERR(pacl) == -ENODATA)\r\npacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\r\nif (IS_ERR(pacl)) {\r\nerror = PTR_ERR(pacl);\r\npacl = NULL;\r\ngoto out;\r\n}\r\nif (S_ISDIR(inode->i_mode)) {\r\ndpacl = _get_posix_acl(dentry, POSIX_ACL_XATTR_DEFAULT);\r\nif (IS_ERR(dpacl) && PTR_ERR(dpacl) == -ENODATA)\r\ndpacl = NULL;\r\nelse if (IS_ERR(dpacl)) {\r\nerror = PTR_ERR(dpacl);\r\ndpacl = NULL;\r\ngoto out;\r\n}\r\nflags = NFS4_ACL_DIR;\r\n}\r\n*acl = nfs4_acl_posix_to_nfsv4(pacl, dpacl, flags);\r\nif (IS_ERR(*acl)) {\r\nerror = PTR_ERR(*acl);\r\n*acl = NULL;\r\n}\r\nout:\r\nposix_acl_release(pacl);\r\nposix_acl_release(dpacl);\r\nreturn error;\r\n}\r\nint nfsd4_is_junction(struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nif (inode == NULL)\r\nreturn 0;\r\nif (inode->i_mode & S_IXUGO)\r\nreturn 0;\r\nif (!(inode->i_mode & S_ISVTX))\r\nreturn 0;\r\nif (vfs_getxattr(dentry, NFSD_JUNCTION_XATTR_NAME, NULL, 0) <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\n__be32 nfsd4_set_nfs4_label(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nstruct xdr_netobj *label)\r\n{\r\n__be32 error;\r\nint host_error;\r\nstruct dentry *dentry;\r\nerror = fh_verify(rqstp, fhp, 0 , NFSD_MAY_SATTR);\r\nif (error)\r\nreturn error;\r\ndentry = fhp->fh_dentry;\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nhost_error = security_inode_setsecctx(dentry, label->data, label->len);\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\nreturn nfserrno(host_error);\r\n}\r\n__be32 nfsd4_set_nfs4_label(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nstruct xdr_netobj *label)\r\n{\r\nreturn nfserr_notsupp;\r\n}\r\n__be32\r\nnfsd_access(struct svc_rqst *rqstp, struct svc_fh *fhp, u32 *access, u32 *supported)\r\n{\r\nstruct accessmap *map;\r\nstruct svc_export *export;\r\nstruct dentry *dentry;\r\nu32 query, result = 0, sresult = 0;\r\n__be32 error;\r\nerror = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\r\nif (error)\r\ngoto out;\r\nexport = fhp->fh_export;\r\ndentry = fhp->fh_dentry;\r\nif (S_ISREG(dentry->d_inode->i_mode))\r\nmap = nfs3_regaccess;\r\nelse if (S_ISDIR(dentry->d_inode->i_mode))\r\nmap = nfs3_diraccess;\r\nelse\r\nmap = nfs3_anyaccess;\r\nquery = *access;\r\nfor (; map->access; map++) {\r\nif (map->access & query) {\r\n__be32 err2;\r\nsresult |= map->access;\r\nerr2 = nfsd_permission(rqstp, export, dentry, map->how);\r\nswitch (err2) {\r\ncase nfs_ok:\r\nresult |= map->access;\r\nbreak;\r\ncase nfserr_rofs:\r\ncase nfserr_acces:\r\ncase nfserr_perm:\r\nbreak;\r\ndefault:\r\nerror = err2;\r\ngoto out;\r\n}\r\n}\r\n}\r\n*access = result;\r\nif (supported)\r\n*supported = sresult;\r\nout:\r\nreturn error;\r\n}\r\nstatic int nfsd_open_break_lease(struct inode *inode, int access)\r\n{\r\nunsigned int mode;\r\nif (access & NFSD_MAY_NOT_BREAK_LEASE)\r\nreturn 0;\r\nmode = (access & NFSD_MAY_WRITE) ? O_WRONLY : O_RDONLY;\r\nreturn break_lease(inode, mode | O_NONBLOCK);\r\n}\r\n__be32\r\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\r\nint may_flags, struct file **filp)\r\n{\r\nstruct path path;\r\nstruct inode *inode;\r\nint flags = O_RDONLY|O_LARGEFILE;\r\n__be32 err;\r\nint host_err = 0;\r\nvalidate_process_creds();\r\nif (type == S_IFREG)\r\nmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\r\nerr = fh_verify(rqstp, fhp, type, may_flags);\r\nif (err)\r\ngoto out;\r\npath.mnt = fhp->fh_export->ex_path.mnt;\r\npath.dentry = fhp->fh_dentry;\r\ninode = path.dentry->d_inode;\r\nerr = nfserr_perm;\r\nif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\r\ngoto out;\r\nif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\r\ngoto out;\r\nif (!inode->i_fop)\r\ngoto out;\r\nhost_err = nfsd_open_break_lease(inode, may_flags);\r\nif (host_err)\r\ngoto out_nfserr;\r\nif (may_flags & NFSD_MAY_WRITE) {\r\nif (may_flags & NFSD_MAY_READ)\r\nflags = O_RDWR|O_LARGEFILE;\r\nelse\r\nflags = O_WRONLY|O_LARGEFILE;\r\n}\r\n*filp = dentry_open(&path, flags, current_cred());\r\nif (IS_ERR(*filp)) {\r\nhost_err = PTR_ERR(*filp);\r\n*filp = NULL;\r\n} else {\r\nhost_err = ima_file_check(*filp, may_flags);\r\nif (may_flags & NFSD_MAY_64BIT_COOKIE)\r\n(*filp)->f_mode |= FMODE_64BITHASH;\r\nelse\r\n(*filp)->f_mode |= FMODE_32BITHASH;\r\n}\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\nout:\r\nvalidate_process_creds();\r\nreturn err;\r\n}\r\nvoid\r\nnfsd_close(struct file *filp)\r\n{\r\nfput(filp);\r\n}\r\nstatic inline struct raparms *\r\nnfsd_get_raparms(dev_t dev, ino_t ino)\r\n{\r\nstruct raparms *ra, **rap, **frap = NULL;\r\nint depth = 0;\r\nunsigned int hash;\r\nstruct raparm_hbucket *rab;\r\nhash = jhash_2words(dev, ino, 0xfeedbeef) & RAPARM_HASH_MASK;\r\nrab = &raparm_hash[hash];\r\nspin_lock(&rab->pb_lock);\r\nfor (rap = &rab->pb_head; (ra = *rap); rap = &ra->p_next) {\r\nif (ra->p_ino == ino && ra->p_dev == dev)\r\ngoto found;\r\ndepth++;\r\nif (ra->p_count == 0)\r\nfrap = rap;\r\n}\r\ndepth = nfsdstats.ra_size;\r\nif (!frap) {\r\nspin_unlock(&rab->pb_lock);\r\nreturn NULL;\r\n}\r\nrap = frap;\r\nra = *frap;\r\nra->p_dev = dev;\r\nra->p_ino = ino;\r\nra->p_set = 0;\r\nra->p_hindex = hash;\r\nfound:\r\nif (rap != &rab->pb_head) {\r\n*rap = ra->p_next;\r\nra->p_next = rab->pb_head;\r\nrab->pb_head = ra;\r\n}\r\nra->p_count++;\r\nnfsdstats.ra_depth[depth*10/nfsdstats.ra_size]++;\r\nspin_unlock(&rab->pb_lock);\r\nreturn ra;\r\n}\r\nstatic int\r\nnfsd_splice_actor(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\r\nstruct splice_desc *sd)\r\n{\r\nstruct svc_rqst *rqstp = sd->u.data;\r\nstruct page **pp = rqstp->rq_next_page;\r\nstruct page *page = buf->page;\r\nsize_t size;\r\nsize = sd->len;\r\nif (rqstp->rq_res.page_len == 0) {\r\nget_page(page);\r\nput_page(*rqstp->rq_next_page);\r\n*(rqstp->rq_next_page++) = page;\r\nrqstp->rq_res.page_base = buf->offset;\r\nrqstp->rq_res.page_len = size;\r\n} else if (page != pp[-1]) {\r\nget_page(page);\r\nif (*rqstp->rq_next_page)\r\nput_page(*rqstp->rq_next_page);\r\n*(rqstp->rq_next_page++) = page;\r\nrqstp->rq_res.page_len += size;\r\n} else\r\nrqstp->rq_res.page_len += size;\r\nreturn size;\r\n}\r\nstatic int nfsd_direct_splice_actor(struct pipe_inode_info *pipe,\r\nstruct splice_desc *sd)\r\n{\r\nreturn __splice_from_pipe(pipe, sd, nfsd_splice_actor);\r\n}\r\nstatic __be32\r\nnfsd_vfs_read(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\r\nloff_t offset, struct kvec *vec, int vlen, unsigned long *count)\r\n{\r\nmm_segment_t oldfs;\r\n__be32 err;\r\nint host_err;\r\nerr = nfserr_perm;\r\nif (file->f_op->splice_read && rqstp->rq_splice_ok) {\r\nstruct splice_desc sd = {\r\n.len = 0,\r\n.total_len = *count,\r\n.pos = offset,\r\n.u.data = rqstp,\r\n};\r\nrqstp->rq_next_page = rqstp->rq_respages + 1;\r\nhost_err = splice_direct_to_actor(file, &sd, nfsd_direct_splice_actor);\r\n} else {\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nhost_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset);\r\nset_fs(oldfs);\r\n}\r\nif (host_err >= 0) {\r\nnfsdstats.io_read += host_err;\r\n*count = host_err;\r\nerr = 0;\r\nfsnotify_access(file);\r\n} else\r\nerr = nfserrno(host_err);\r\nreturn err;\r\n}\r\nstatic void kill_suid(struct dentry *dentry)\r\n{\r\nstruct iattr ia;\r\nia.ia_valid = ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nnotify_change(dentry, &ia);\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\n}\r\nstatic int wait_for_concurrent_writes(struct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstatic ino_t last_ino;\r\nstatic dev_t last_dev;\r\nint err = 0;\r\nif (atomic_read(&inode->i_writecount) > 1\r\n|| (last_ino == inode->i_ino && last_dev == inode->i_sb->s_dev)) {\r\ndprintk("nfsd: write defer %d\n", task_pid_nr(current));\r\nmsleep(10);\r\ndprintk("nfsd: write resume %d\n", task_pid_nr(current));\r\n}\r\nif (inode->i_state & I_DIRTY) {\r\ndprintk("nfsd: write sync %d\n", task_pid_nr(current));\r\nerr = vfs_fsync(file, 0);\r\n}\r\nlast_ino = inode->i_ino;\r\nlast_dev = inode->i_sb->s_dev;\r\nreturn err;\r\n}\r\nstatic __be32\r\nnfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\r\nloff_t offset, struct kvec *vec, int vlen,\r\nunsigned long *cnt, int *stablep)\r\n{\r\nstruct svc_export *exp;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nmm_segment_t oldfs;\r\n__be32 err = 0;\r\nint host_err;\r\nint stable = *stablep;\r\nint use_wgather;\r\nloff_t pos = offset;\r\ndentry = file->f_path.dentry;\r\ninode = dentry->d_inode;\r\nexp = fhp->fh_export;\r\nuse_wgather = (rqstp->rq_vers == 2) && EX_WGATHER(exp);\r\nif (!EX_ISSYNC(exp))\r\nstable = 0;\r\noldfs = get_fs(); set_fs(KERNEL_DS);\r\nhost_err = vfs_writev(file, (struct iovec __user *)vec, vlen, &pos);\r\nset_fs(oldfs);\r\nif (host_err < 0)\r\ngoto out_nfserr;\r\n*cnt = host_err;\r\nnfsdstats.io_write += host_err;\r\nfsnotify_modify(file);\r\nif (inode->i_mode & (S_ISUID | S_ISGID))\r\nkill_suid(dentry);\r\nif (stable) {\r\nif (use_wgather)\r\nhost_err = wait_for_concurrent_writes(file);\r\nelse\r\nhost_err = vfs_fsync_range(file, offset, offset+*cnt, 0);\r\n}\r\nout_nfserr:\r\ndprintk("nfsd: write complete host_err=%d\n", host_err);\r\nif (host_err >= 0)\r\nerr = 0;\r\nelse\r\nerr = nfserrno(host_err);\r\nreturn err;\r\n}\r\n__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nloff_t offset, struct kvec *vec, int vlen, unsigned long *count)\r\n{\r\nstruct file *file;\r\nstruct inode *inode;\r\nstruct raparms *ra;\r\n__be32 err;\r\nerr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\r\nif (err)\r\nreturn err;\r\ninode = file_inode(file);\r\nra = nfsd_get_raparms(inode->i_sb->s_dev, inode->i_ino);\r\nif (ra && ra->p_set)\r\nfile->f_ra = ra->p_ra;\r\nerr = nfsd_vfs_read(rqstp, fhp, file, offset, vec, vlen, count);\r\nif (ra) {\r\nstruct raparm_hbucket *rab = &raparm_hash[ra->p_hindex];\r\nspin_lock(&rab->pb_lock);\r\nra->p_ra = file->f_ra;\r\nra->p_set = 1;\r\nra->p_count--;\r\nspin_unlock(&rab->pb_lock);\r\n}\r\nnfsd_close(file);\r\nreturn err;\r\n}\r\n__be32\r\nnfsd_read_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\r\nloff_t offset, struct kvec *vec, int vlen,\r\nunsigned long *count)\r\n{\r\n__be32 err;\r\nif (file) {\r\nerr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\r\nNFSD_MAY_READ|NFSD_MAY_OWNER_OVERRIDE);\r\nif (err)\r\ngoto out;\r\nerr = nfsd_vfs_read(rqstp, fhp, file, offset, vec, vlen, count);\r\n} else\r\nerr = nfsd_read(rqstp, fhp, offset, vec, vlen, count);\r\nout:\r\nreturn err;\r\n}\r\n__be32\r\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\r\nloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\r\nint *stablep)\r\n{\r\n__be32 err = 0;\r\nif (file) {\r\nerr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\r\nNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\r\nif (err)\r\ngoto out;\r\nerr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\r\nstablep);\r\n} else {\r\nerr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\r\nif (err)\r\ngoto out;\r\nif (cnt)\r\nerr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\r\ncnt, stablep);\r\nnfsd_close(file);\r\n}\r\nout:\r\nreturn err;\r\n}\r\n__be32\r\nnfsd_commit(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nloff_t offset, unsigned long count)\r\n{\r\nstruct file *file;\r\nloff_t end = LLONG_MAX;\r\n__be32 err = nfserr_inval;\r\nif (offset < 0)\r\ngoto out;\r\nif (count != 0) {\r\nend = offset + (loff_t)count - 1;\r\nif (end < offset)\r\ngoto out;\r\n}\r\nerr = nfsd_open(rqstp, fhp, S_IFREG,\r\nNFSD_MAY_WRITE|NFSD_MAY_NOT_BREAK_LEASE, &file);\r\nif (err)\r\ngoto out;\r\nif (EX_ISSYNC(fhp->fh_export)) {\r\nint err2 = vfs_fsync_range(file, offset, end, 0);\r\nif (err2 != -EINVAL)\r\nerr = nfserrno(err2);\r\nelse\r\nerr = nfserr_notsupp;\r\n}\r\nnfsd_close(file);\r\nout:\r\nreturn err;\r\n}\r\nstatic __be32\r\nnfsd_create_setattr(struct svc_rqst *rqstp, struct svc_fh *resfhp,\r\nstruct iattr *iap)\r\n{\r\niap->ia_valid &= ~ATTR_MODE;\r\nif (!uid_eq(current_fsuid(), GLOBAL_ROOT_UID))\r\niap->ia_valid &= ~(ATTR_UID|ATTR_GID);\r\nif (iap->ia_valid)\r\nreturn nfsd_setattr(rqstp, resfhp, iap, 0, (time_t)0);\r\nreturn 0;\r\n}\r\nstatic void\r\nnfsd_check_ignore_resizing(struct iattr *iap)\r\n{\r\nif ((iap->ia_valid & ATTR_SIZE) && (iap->ia_size == 0))\r\niap->ia_valid &= ~ATTR_SIZE;\r\n}\r\n__be32\r\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nchar *fname, int flen, struct iattr *iap,\r\nint type, dev_t rdev, struct svc_fh *resfhp)\r\n{\r\nstruct dentry *dentry, *dchild = NULL;\r\nstruct inode *dirp;\r\n__be32 err;\r\n__be32 err2;\r\nint host_err;\r\nerr = nfserr_perm;\r\nif (!flen)\r\ngoto out;\r\nerr = nfserr_exist;\r\nif (isdotent(fname, flen))\r\ngoto out;\r\nerr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\r\nif (err)\r\ngoto out;\r\ndentry = fhp->fh_dentry;\r\ndirp = dentry->d_inode;\r\nerr = nfserr_notdir;\r\nif (!dirp->i_op->lookup)\r\ngoto out;\r\nif (!resfhp->fh_dentry) {\r\nhost_err = fh_want_write(fhp);\r\nif (host_err)\r\ngoto out_nfserr;\r\nfh_lock_nested(fhp, I_MUTEX_PARENT);\r\ndchild = lookup_one_len(fname, dentry, flen);\r\nhost_err = PTR_ERR(dchild);\r\nif (IS_ERR(dchild))\r\ngoto out_nfserr;\r\nerr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\r\nif (err)\r\ngoto out;\r\n} else {\r\ndchild = dget(resfhp->fh_dentry);\r\nif (!fhp->fh_locked) {\r\nprintk(KERN_ERR\r\n"nfsd_create: parent %s/%s not locked!\n",\r\ndentry->d_parent->d_name.name,\r\ndentry->d_name.name);\r\nerr = nfserr_io;\r\ngoto out;\r\n}\r\n}\r\nerr = nfserr_exist;\r\nif (dchild->d_inode) {\r\ndprintk("nfsd_create: dentry %s/%s not negative!\n",\r\ndentry->d_name.name, dchild->d_name.name);\r\ngoto out;\r\n}\r\nif (!(iap->ia_valid & ATTR_MODE))\r\niap->ia_mode = 0;\r\niap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\r\nerr = nfserr_inval;\r\nif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\r\nprintk(KERN_WARNING "nfsd: bad file type %o in nfsd_create\n",\r\ntype);\r\ngoto out;\r\n}\r\nerr = 0;\r\nhost_err = 0;\r\nswitch (type) {\r\ncase S_IFREG:\r\nhost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\r\nif (!host_err)\r\nnfsd_check_ignore_resizing(iap);\r\nbreak;\r\ncase S_IFDIR:\r\nhost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\r\nbreak;\r\ncase S_IFCHR:\r\ncase S_IFBLK:\r\ncase S_IFIFO:\r\ncase S_IFSOCK:\r\nhost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\r\nbreak;\r\n}\r\nif (host_err < 0)\r\ngoto out_nfserr;\r\nerr = nfsd_create_setattr(rqstp, resfhp, iap);\r\nerr2 = nfserrno(commit_metadata(fhp));\r\nif (err2)\r\nerr = err2;\r\nif (!err)\r\nerr = fh_update(resfhp);\r\nout:\r\nif (dchild && !IS_ERR(dchild))\r\ndput(dchild);\r\nreturn err;\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\nstatic inline int nfsd_create_is_exclusive(int createmode)\r\n{\r\nreturn createmode == NFS3_CREATE_EXCLUSIVE\r\n|| createmode == NFS4_CREATE_EXCLUSIVE4_1;\r\n}\r\n__be32\r\ndo_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nchar *fname, int flen, struct iattr *iap,\r\nstruct svc_fh *resfhp, int createmode, u32 *verifier,\r\nbool *truncp, bool *created)\r\n{\r\nstruct dentry *dentry, *dchild = NULL;\r\nstruct inode *dirp;\r\n__be32 err;\r\nint host_err;\r\n__u32 v_mtime=0, v_atime=0;\r\nerr = nfserr_perm;\r\nif (!flen)\r\ngoto out;\r\nerr = nfserr_exist;\r\nif (isdotent(fname, flen))\r\ngoto out;\r\nif (!(iap->ia_valid & ATTR_MODE))\r\niap->ia_mode = 0;\r\nerr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\r\nif (err)\r\ngoto out;\r\ndentry = fhp->fh_dentry;\r\ndirp = dentry->d_inode;\r\nerr = nfserr_notdir;\r\nif (!dirp->i_op->lookup)\r\ngoto out;\r\nhost_err = fh_want_write(fhp);\r\nif (host_err)\r\ngoto out_nfserr;\r\nfh_lock_nested(fhp, I_MUTEX_PARENT);\r\ndchild = lookup_one_len(fname, dentry, flen);\r\nhost_err = PTR_ERR(dchild);\r\nif (IS_ERR(dchild))\r\ngoto out_nfserr;\r\nif (!dchild->d_inode) {\r\nerr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\r\nif (err)\r\ngoto out;\r\nif (nfsd_create_is_exclusive(createmode)) {\r\nv_mtime = verifier[0]&0x7fffffff;\r\nv_atime = verifier[1]&0x7fffffff;\r\n}\r\nif (dchild->d_inode) {\r\nerr = 0;\r\nswitch (createmode) {\r\ncase NFS3_CREATE_UNCHECKED:\r\nif (! S_ISREG(dchild->d_inode->i_mode))\r\ngoto out;\r\nelse if (truncp) {\r\n*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;\r\n}\r\nelse {\r\niap->ia_valid &= ATTR_SIZE;\r\ngoto set_attr;\r\n}\r\nbreak;\r\ncase NFS3_CREATE_EXCLUSIVE:\r\nif ( dchild->d_inode->i_mtime.tv_sec == v_mtime\r\n&& dchild->d_inode->i_atime.tv_sec == v_atime\r\n&& dchild->d_inode->i_size == 0 ) {\r\nif (created)\r\n*created = 1;\r\nbreak;\r\n}\r\ncase NFS4_CREATE_EXCLUSIVE4_1:\r\nif ( dchild->d_inode->i_mtime.tv_sec == v_mtime\r\n&& dchild->d_inode->i_atime.tv_sec == v_atime\r\n&& dchild->d_inode->i_size == 0 ) {\r\nif (created)\r\n*created = 1;\r\ngoto set_attr;\r\n}\r\ncase NFS3_CREATE_GUARDED:\r\nerr = nfserr_exist;\r\n}\r\nfh_drop_write(fhp);\r\ngoto out;\r\n}\r\nhost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\r\nif (host_err < 0) {\r\nfh_drop_write(fhp);\r\ngoto out_nfserr;\r\n}\r\nif (created)\r\n*created = 1;\r\nnfsd_check_ignore_resizing(iap);\r\nif (nfsd_create_is_exclusive(createmode)) {\r\niap->ia_valid = ATTR_MTIME|ATTR_ATIME\r\n| ATTR_MTIME_SET|ATTR_ATIME_SET;\r\niap->ia_mtime.tv_sec = v_mtime;\r\niap->ia_atime.tv_sec = v_atime;\r\niap->ia_mtime.tv_nsec = 0;\r\niap->ia_atime.tv_nsec = 0;\r\n}\r\nset_attr:\r\nerr = nfsd_create_setattr(rqstp, resfhp, iap);\r\nif (!err)\r\nerr = nfserrno(commit_metadata(fhp));\r\nif (!err)\r\nerr = fh_update(resfhp);\r\nout:\r\nfh_unlock(fhp);\r\nif (dchild && !IS_ERR(dchild))\r\ndput(dchild);\r\nfh_drop_write(fhp);\r\nreturn err;\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\n__be32\r\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\r\n{\r\nstruct inode *inode;\r\nmm_segment_t oldfs;\r\n__be32 err;\r\nint host_err;\r\nstruct path path;\r\nerr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\r\nif (err)\r\ngoto out;\r\npath.mnt = fhp->fh_export->ex_path.mnt;\r\npath.dentry = fhp->fh_dentry;\r\ninode = path.dentry->d_inode;\r\nerr = nfserr_inval;\r\nif (!inode->i_op->readlink)\r\ngoto out;\r\ntouch_atime(&path);\r\noldfs = get_fs(); set_fs(KERNEL_DS);\r\nhost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\r\nset_fs(oldfs);\r\nif (host_err < 0)\r\ngoto out_nfserr;\r\n*lenp = host_err;\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\n__be32\r\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\r\nchar *fname, int flen,\r\nchar *path, int plen,\r\nstruct svc_fh *resfhp,\r\nstruct iattr *iap)\r\n{\r\nstruct dentry *dentry, *dnew;\r\n__be32 err, cerr;\r\nint host_err;\r\nerr = nfserr_noent;\r\nif (!flen || !plen)\r\ngoto out;\r\nerr = nfserr_exist;\r\nif (isdotent(fname, flen))\r\ngoto out;\r\nerr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\r\nif (err)\r\ngoto out;\r\nhost_err = fh_want_write(fhp);\r\nif (host_err)\r\ngoto out_nfserr;\r\nfh_lock(fhp);\r\ndentry = fhp->fh_dentry;\r\ndnew = lookup_one_len(fname, dentry, flen);\r\nhost_err = PTR_ERR(dnew);\r\nif (IS_ERR(dnew))\r\ngoto out_nfserr;\r\nif (unlikely(path[plen] != 0)) {\r\nchar *path_alloced = kmalloc(plen+1, GFP_KERNEL);\r\nif (path_alloced == NULL)\r\nhost_err = -ENOMEM;\r\nelse {\r\nstrncpy(path_alloced, path, plen);\r\npath_alloced[plen] = 0;\r\nhost_err = vfs_symlink(dentry->d_inode, dnew, path_alloced);\r\nkfree(path_alloced);\r\n}\r\n} else\r\nhost_err = vfs_symlink(dentry->d_inode, dnew, path);\r\nerr = nfserrno(host_err);\r\nif (!err)\r\nerr = nfserrno(commit_metadata(fhp));\r\nfh_unlock(fhp);\r\nfh_drop_write(fhp);\r\ncerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\r\ndput(dnew);\r\nif (err==0) err = cerr;\r\nout:\r\nreturn err;\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\n__be32\r\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\r\nchar *name, int len, struct svc_fh *tfhp)\r\n{\r\nstruct dentry *ddir, *dnew, *dold;\r\nstruct inode *dirp;\r\n__be32 err;\r\nint host_err;\r\nerr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\r\nif (err)\r\ngoto out;\r\nerr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\r\nif (err)\r\ngoto out;\r\nerr = nfserr_isdir;\r\nif (S_ISDIR(tfhp->fh_dentry->d_inode->i_mode))\r\ngoto out;\r\nerr = nfserr_perm;\r\nif (!len)\r\ngoto out;\r\nerr = nfserr_exist;\r\nif (isdotent(name, len))\r\ngoto out;\r\nhost_err = fh_want_write(tfhp);\r\nif (host_err) {\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\nfh_lock_nested(ffhp, I_MUTEX_PARENT);\r\nddir = ffhp->fh_dentry;\r\ndirp = ddir->d_inode;\r\ndnew = lookup_one_len(name, ddir, len);\r\nhost_err = PTR_ERR(dnew);\r\nif (IS_ERR(dnew))\r\ngoto out_nfserr;\r\ndold = tfhp->fh_dentry;\r\nerr = nfserr_noent;\r\nif (!dold->d_inode)\r\ngoto out_dput;\r\nhost_err = nfsd_break_lease(dold->d_inode);\r\nif (host_err) {\r\nerr = nfserrno(host_err);\r\ngoto out_dput;\r\n}\r\nhost_err = vfs_link(dold, dirp, dnew);\r\nif (!host_err) {\r\nerr = nfserrno(commit_metadata(ffhp));\r\nif (!err)\r\nerr = nfserrno(commit_metadata(tfhp));\r\n} else {\r\nif (host_err == -EXDEV && rqstp->rq_vers == 2)\r\nerr = nfserr_acces;\r\nelse\r\nerr = nfserrno(host_err);\r\n}\r\nout_dput:\r\ndput(dnew);\r\nout_unlock:\r\nfh_unlock(ffhp);\r\nfh_drop_write(tfhp);\r\nout:\r\nreturn err;\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\ngoto out_unlock;\r\n}\r\n__be32\r\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\r\nstruct svc_fh *tfhp, char *tname, int tlen)\r\n{\r\nstruct dentry *fdentry, *tdentry, *odentry, *ndentry, *trap;\r\nstruct inode *fdir, *tdir;\r\n__be32 err;\r\nint host_err;\r\nerr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\r\nif (err)\r\ngoto out;\r\nerr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\r\nif (err)\r\ngoto out;\r\nfdentry = ffhp->fh_dentry;\r\nfdir = fdentry->d_inode;\r\ntdentry = tfhp->fh_dentry;\r\ntdir = tdentry->d_inode;\r\nerr = nfserr_perm;\r\nif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\r\ngoto out;\r\nhost_err = fh_want_write(ffhp);\r\nif (host_err) {\r\nerr = nfserrno(host_err);\r\ngoto out;\r\n}\r\ntrap = lock_rename(tdentry, fdentry);\r\nffhp->fh_locked = tfhp->fh_locked = 1;\r\nfill_pre_wcc(ffhp);\r\nfill_pre_wcc(tfhp);\r\nodentry = lookup_one_len(fname, fdentry, flen);\r\nhost_err = PTR_ERR(odentry);\r\nif (IS_ERR(odentry))\r\ngoto out_nfserr;\r\nhost_err = -ENOENT;\r\nif (!odentry->d_inode)\r\ngoto out_dput_old;\r\nhost_err = -EINVAL;\r\nif (odentry == trap)\r\ngoto out_dput_old;\r\nndentry = lookup_one_len(tname, tdentry, tlen);\r\nhost_err = PTR_ERR(ndentry);\r\nif (IS_ERR(ndentry))\r\ngoto out_dput_old;\r\nhost_err = -ENOTEMPTY;\r\nif (ndentry == trap)\r\ngoto out_dput_new;\r\nhost_err = -EXDEV;\r\nif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\r\ngoto out_dput_new;\r\nif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\r\ngoto out_dput_new;\r\nhost_err = nfsd_break_lease(odentry->d_inode);\r\nif (host_err)\r\ngoto out_dput_new;\r\nif (ndentry->d_inode) {\r\nhost_err = nfsd_break_lease(ndentry->d_inode);\r\nif (host_err)\r\ngoto out_dput_new;\r\n}\r\nhost_err = vfs_rename(fdir, odentry, tdir, ndentry);\r\nif (!host_err) {\r\nhost_err = commit_metadata(tfhp);\r\nif (!host_err)\r\nhost_err = commit_metadata(ffhp);\r\n}\r\nout_dput_new:\r\ndput(ndentry);\r\nout_dput_old:\r\ndput(odentry);\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\nfill_post_wcc(ffhp);\r\nfill_post_wcc(tfhp);\r\nunlock_rename(tdentry, fdentry);\r\nffhp->fh_locked = tfhp->fh_locked = 0;\r\nfh_drop_write(ffhp);\r\nout:\r\nreturn err;\r\n}\r\n__be32\r\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\r\nchar *fname, int flen)\r\n{\r\nstruct dentry *dentry, *rdentry;\r\nstruct inode *dirp;\r\n__be32 err;\r\nint host_err;\r\nerr = nfserr_acces;\r\nif (!flen || isdotent(fname, flen))\r\ngoto out;\r\nerr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\r\nif (err)\r\ngoto out;\r\nhost_err = fh_want_write(fhp);\r\nif (host_err)\r\ngoto out_nfserr;\r\nfh_lock_nested(fhp, I_MUTEX_PARENT);\r\ndentry = fhp->fh_dentry;\r\ndirp = dentry->d_inode;\r\nrdentry = lookup_one_len(fname, dentry, flen);\r\nhost_err = PTR_ERR(rdentry);\r\nif (IS_ERR(rdentry))\r\ngoto out_nfserr;\r\nif (!rdentry->d_inode) {\r\ndput(rdentry);\r\nerr = nfserr_noent;\r\ngoto out;\r\n}\r\nif (!type)\r\ntype = rdentry->d_inode->i_mode & S_IFMT;\r\nhost_err = nfsd_break_lease(rdentry->d_inode);\r\nif (host_err)\r\ngoto out_put;\r\nif (type != S_IFDIR)\r\nhost_err = vfs_unlink(dirp, rdentry);\r\nelse\r\nhost_err = vfs_rmdir(dirp, rdentry);\r\nif (!host_err)\r\nhost_err = commit_metadata(fhp);\r\nout_put:\r\ndput(rdentry);\r\nout_nfserr:\r\nerr = nfserrno(host_err);\r\nout:\r\nreturn err;\r\n}\r\nstatic int nfsd_buffered_filldir(void *__buf, const char *name, int namlen,\r\nloff_t offset, u64 ino, unsigned int d_type)\r\n{\r\nstruct readdir_data *buf = __buf;\r\nstruct buffered_dirent *de = (void *)(buf->dirent + buf->used);\r\nunsigned int reclen;\r\nreclen = ALIGN(sizeof(struct buffered_dirent) + namlen, sizeof(u64));\r\nif (buf->used + reclen > PAGE_SIZE) {\r\nbuf->full = 1;\r\nreturn -EINVAL;\r\n}\r\nde->namlen = namlen;\r\nde->offset = offset;\r\nde->ino = ino;\r\nde->d_type = d_type;\r\nmemcpy(de->name, name, namlen);\r\nbuf->used += reclen;\r\nreturn 0;\r\n}\r\nstatic __be32 nfsd_buffered_readdir(struct file *file, filldir_t func,\r\nstruct readdir_cd *cdp, loff_t *offsetp)\r\n{\r\nstruct buffered_dirent *de;\r\nint host_err;\r\nint size;\r\nloff_t offset;\r\nstruct readdir_data buf = {\r\n.ctx.actor = nfsd_buffered_filldir,\r\n.dirent = (void *)__get_free_page(GFP_KERNEL)\r\n};\r\nif (!buf.dirent)\r\nreturn nfserrno(-ENOMEM);\r\noffset = *offsetp;\r\nwhile (1) {\r\nstruct inode *dir_inode = file_inode(file);\r\nunsigned int reclen;\r\ncdp->err = nfserr_eof;\r\nbuf.used = 0;\r\nbuf.full = 0;\r\nhost_err = iterate_dir(file, &buf.ctx);\r\nif (buf.full)\r\nhost_err = 0;\r\nif (host_err < 0)\r\nbreak;\r\nsize = buf.used;\r\nif (!size)\r\nbreak;\r\nhost_err = mutex_lock_killable(&dir_inode->i_mutex);\r\nif (host_err)\r\nbreak;\r\nde = (struct buffered_dirent *)buf.dirent;\r\nwhile (size > 0) {\r\noffset = de->offset;\r\nif (func(cdp, de->name, de->namlen, de->offset,\r\nde->ino, de->d_type))\r\nbreak;\r\nif (cdp->err != nfs_ok)\r\nbreak;\r\nreclen = ALIGN(sizeof(*de) + de->namlen,\r\nsizeof(u64));\r\nsize -= reclen;\r\nde = (struct buffered_dirent *)((char *)de + reclen);\r\n}\r\nmutex_unlock(&dir_inode->i_mutex);\r\nif (size > 0)\r\nbreak;\r\noffset = vfs_llseek(file, 0, SEEK_CUR);\r\n}\r\nfree_page((unsigned long)(buf.dirent));\r\nif (host_err)\r\nreturn nfserrno(host_err);\r\n*offsetp = offset;\r\nreturn cdp->err;\r\n}\r\n__be32\r\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp,\r\nstruct readdir_cd *cdp, filldir_t func)\r\n{\r\n__be32 err;\r\nstruct file *file;\r\nloff_t offset = *offsetp;\r\nint may_flags = NFSD_MAY_READ;\r\nif (rqstp->rq_vers > 2)\r\nmay_flags |= NFSD_MAY_64BIT_COOKIE;\r\nerr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\r\nif (err)\r\ngoto out;\r\noffset = vfs_llseek(file, offset, SEEK_SET);\r\nif (offset < 0) {\r\nerr = nfserrno((int)offset);\r\ngoto out_close;\r\n}\r\nerr = nfsd_buffered_readdir(file, func, cdp, offsetp);\r\nif (err == nfserr_eof || err == nfserr_toosmall)\r\nerr = nfs_ok;\r\nout_close:\r\nnfsd_close(file);\r\nout:\r\nreturn err;\r\n}\r\n__be32\r\nnfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat, int access)\r\n{\r\n__be32 err;\r\nerr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP | access);\r\nif (!err) {\r\nstruct path path = {\r\n.mnt = fhp->fh_export->ex_path.mnt,\r\n.dentry = fhp->fh_dentry,\r\n};\r\nif (vfs_statfs(&path, stat))\r\nerr = nfserr_io;\r\n}\r\nreturn err;\r\n}\r\nstatic int exp_rdonly(struct svc_rqst *rqstp, struct svc_export *exp)\r\n{\r\nreturn nfsexp_flags(rqstp, exp) & NFSEXP_READONLY;\r\n}\r\n__be32\r\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\r\nstruct dentry *dentry, int acc)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nint err;\r\nif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\r\nreturn 0;\r\n#if 0\r\ndprintk("nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\n",\r\nacc,\r\n(acc & NFSD_MAY_READ)? " read" : "",\r\n(acc & NFSD_MAY_WRITE)? " write" : "",\r\n(acc & NFSD_MAY_EXEC)? " exec" : "",\r\n(acc & NFSD_MAY_SATTR)? " sattr" : "",\r\n(acc & NFSD_MAY_TRUNC)? " trunc" : "",\r\n(acc & NFSD_MAY_LOCK)? " lock" : "",\r\n(acc & NFSD_MAY_OWNER_OVERRIDE)? " owneroverride" : "",\r\ninode->i_mode,\r\nIS_IMMUTABLE(inode)? " immut" : "",\r\nIS_APPEND(inode)? " append" : "",\r\n__mnt_is_readonly(exp->ex_path.mnt)? " ro" : "");\r\ndprintk(" owner %d/%d user %d/%d\n",\r\ninode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\r\n#endif\r\nif (!(acc & NFSD_MAY_LOCAL_ACCESS))\r\nif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\r\nif (exp_rdonly(rqstp, exp) ||\r\n__mnt_is_readonly(exp->ex_path.mnt))\r\nreturn nfserr_rofs;\r\nif ( IS_IMMUTABLE(inode))\r\nreturn nfserr_perm;\r\n}\r\nif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\r\nreturn nfserr_perm;\r\nif (acc & NFSD_MAY_LOCK) {\r\nif (exp->ex_flags & NFSEXP_NOAUTHNLM)\r\nreturn 0;\r\nelse\r\nacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\r\n}\r\nif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\r\nuid_eq(inode->i_uid, current_fsuid()))\r\nreturn 0;\r\nerr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\r\nif (err == -EACCES && S_ISREG(inode->i_mode) &&\r\n(acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\r\nacc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\r\nerr = inode_permission(inode, MAY_EXEC);\r\nreturn err? nfserrno(err) : 0;\r\n}\r\nvoid\r\nnfsd_racache_shutdown(void)\r\n{\r\nstruct raparms *raparm, *last_raparm;\r\nunsigned int i;\r\ndprintk("nfsd: freeing readahead buffers.\n");\r\nfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\r\nraparm = raparm_hash[i].pb_head;\r\nwhile(raparm) {\r\nlast_raparm = raparm;\r\nraparm = raparm->p_next;\r\nkfree(last_raparm);\r\n}\r\nraparm_hash[i].pb_head = NULL;\r\n}\r\n}\r\nint\r\nnfsd_racache_init(int cache_size)\r\n{\r\nint i;\r\nint j = 0;\r\nint nperbucket;\r\nstruct raparms **raparm = NULL;\r\nif (raparm_hash[0].pb_head)\r\nreturn 0;\r\nnperbucket = DIV_ROUND_UP(cache_size, RAPARM_HASH_SIZE);\r\nif (nperbucket < 2)\r\nnperbucket = 2;\r\ncache_size = nperbucket * RAPARM_HASH_SIZE;\r\ndprintk("nfsd: allocating %d readahead buffers.\n", cache_size);\r\nfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\r\nspin_lock_init(&raparm_hash[i].pb_lock);\r\nraparm = &raparm_hash[i].pb_head;\r\nfor (j = 0; j < nperbucket; j++) {\r\n*raparm = kzalloc(sizeof(struct raparms), GFP_KERNEL);\r\nif (!*raparm)\r\ngoto out_nomem;\r\nraparm = &(*raparm)->p_next;\r\n}\r\n*raparm = NULL;\r\n}\r\nnfsdstats.ra_size = cache_size;\r\nreturn 0;\r\nout_nomem:\r\ndprintk("nfsd: kmalloc failed, freeing readahead buffers\n");\r\nnfsd_racache_shutdown();\r\nreturn -ENOMEM;\r\n}\r\nstruct posix_acl *\r\nnfsd_get_posix_acl(struct svc_fh *fhp, int type)\r\n{\r\nstruct inode *inode = fhp->fh_dentry->d_inode;\r\nchar *name;\r\nvoid *value = NULL;\r\nssize_t size;\r\nstruct posix_acl *acl;\r\nif (!IS_POSIXACL(inode))\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nname = POSIX_ACL_XATTR_ACCESS;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nname = POSIX_ACL_XATTR_DEFAULT;\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nsize = nfsd_getxattr(fhp->fh_dentry, name, &value);\r\nif (size < 0)\r\nreturn ERR_PTR(size);\r\nacl = posix_acl_from_xattr(&init_user_ns, value, size);\r\nkfree(value);\r\nreturn acl;\r\n}\r\nint\r\nnfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)\r\n{\r\nstruct inode *inode = fhp->fh_dentry->d_inode;\r\nchar *name;\r\nvoid *value = NULL;\r\nsize_t size;\r\nint error;\r\nif (!IS_POSIXACL(inode) ||\r\n!inode->i_op->setxattr || !inode->i_op->removexattr)\r\nreturn -EOPNOTSUPP;\r\nswitch(type) {\r\ncase ACL_TYPE_ACCESS:\r\nname = POSIX_ACL_XATTR_ACCESS;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nname = POSIX_ACL_XATTR_DEFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (acl && acl->a_count) {\r\nsize = posix_acl_xattr_size(acl->a_count);\r\nvalue = kmalloc(size, GFP_KERNEL);\r\nif (!value)\r\nreturn -ENOMEM;\r\nerror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\r\nif (error < 0)\r\ngoto getout;\r\nsize = error;\r\n} else\r\nsize = 0;\r\nerror = fh_want_write(fhp);\r\nif (error)\r\ngoto getout;\r\nif (size)\r\nerror = vfs_setxattr(fhp->fh_dentry, name, value, size, 0);\r\nelse {\r\nif (!S_ISDIR(inode->i_mode) && type == ACL_TYPE_DEFAULT)\r\nerror = 0;\r\nelse {\r\nerror = vfs_removexattr(fhp->fh_dentry, name);\r\nif (error == -ENODATA)\r\nerror = 0;\r\n}\r\n}\r\nfh_drop_write(fhp);\r\ngetout:\r\nkfree(value);\r\nreturn error;\r\n}
