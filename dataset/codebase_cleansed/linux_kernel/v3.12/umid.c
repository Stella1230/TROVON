static int __init make_uml_dir(void)\r\n{\r\nchar dir[512] = { '\0' };\r\nint len, err;\r\nif (*uml_dir == '~') {\r\nchar *home = getenv("HOME");\r\nerr = -ENOENT;\r\nif (home == NULL) {\r\nprintk(UM_KERN_ERR "make_uml_dir : no value in "\r\n"environment for $HOME\n");\r\ngoto err;\r\n}\r\nstrlcpy(dir, home, sizeof(dir));\r\numl_dir++;\r\n}\r\nstrlcat(dir, uml_dir, sizeof(dir));\r\nlen = strlen(dir);\r\nif (len > 0 && dir[len - 1] != '/')\r\nstrlcat(dir, "/", sizeof(dir));\r\nerr = -ENOMEM;\r\numl_dir = malloc(strlen(dir) + 1);\r\nif (uml_dir == NULL) {\r\nprintf("make_uml_dir : malloc failed, errno = %d\n", errno);\r\ngoto err;\r\n}\r\nstrcpy(uml_dir, dir);\r\nif ((mkdir(uml_dir, 0777) < 0) && (errno != EEXIST)) {\r\nprintf("Failed to mkdir '%s': %s\n", uml_dir, strerror(errno));\r\nerr = -errno;\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nfree(uml_dir);\r\nerr:\r\numl_dir = NULL;\r\nreturn err;\r\n}\r\nstatic int remove_files_and_dir(char *dir)\r\n{\r\nDIR *directory;\r\nstruct dirent *ent;\r\nint len;\r\nchar file[256];\r\nint ret;\r\ndirectory = opendir(dir);\r\nif (directory == NULL) {\r\nif (errno != ENOENT)\r\nreturn -errno;\r\nelse\r\nreturn 0;\r\n}\r\nwhile ((ent = readdir(directory)) != NULL) {\r\nif (!strcmp(ent->d_name, ".") || !strcmp(ent->d_name, ".."))\r\ncontinue;\r\nlen = strlen(dir) + sizeof("/") + strlen(ent->d_name) + 1;\r\nif (len > sizeof(file)) {\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nsprintf(file, "%s/%s", dir, ent->d_name);\r\nif (unlink(file) < 0 && errno != ENOENT) {\r\nret = -errno;\r\ngoto out;\r\n}\r\n}\r\nif (rmdir(dir) < 0 && errno != ENOENT) {\r\nret = -errno;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nclosedir(directory);\r\nreturn ret;\r\n}\r\nstatic inline int is_umdir_used(char *dir)\r\n{\r\nchar file[strlen(uml_dir) + UMID_LEN + sizeof("/pid\0")];\r\nchar pid[sizeof("nnnnn\0")], *end;\r\nint dead, fd, p, n, err;\r\nn = snprintf(file, sizeof(file), "%s/pid", dir);\r\nif (n >= sizeof(file)) {\r\nprintk(UM_KERN_ERR "is_umdir_used - pid filename too long\n");\r\nerr = -E2BIG;\r\ngoto out;\r\n}\r\ndead = 0;\r\nfd = open(file, O_RDONLY);\r\nif (fd < 0) {\r\nfd = -errno;\r\nif (fd != -ENOENT) {\r\nprintk(UM_KERN_ERR "is_umdir_used : couldn't open pid "\r\n"file '%s', err = %d\n", file, -fd);\r\n}\r\ngoto out;\r\n}\r\nerr = 0;\r\nn = read(fd, pid, sizeof(pid));\r\nif (n < 0) {\r\nprintk(UM_KERN_ERR "is_umdir_used : couldn't read pid file "\r\n"'%s', err = %d\n", file, errno);\r\ngoto out_close;\r\n} else if (n == 0) {\r\nprintk(UM_KERN_ERR "is_umdir_used : couldn't read pid file "\r\n"'%s', 0-byte read\n", file);\r\ngoto out_close;\r\n}\r\np = strtoul(pid, &end, 0);\r\nif (end == pid) {\r\nprintk(UM_KERN_ERR "is_umdir_used : couldn't parse pid file "\r\n"'%s', errno = %d\n", file, errno);\r\ngoto out_close;\r\n}\r\nif ((kill(p, 0) == 0) || (errno != ESRCH)) {\r\nprintk(UM_KERN_ERR "umid \"%s\" is already in use by pid %d\n",\r\numid, p);\r\nreturn 1;\r\n}\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int umdir_take_if_dead(char *dir)\r\n{\r\nint ret;\r\nif (is_umdir_used(dir))\r\nreturn -EEXIST;\r\nret = remove_files_and_dir(dir);\r\nif (ret) {\r\nprintk(UM_KERN_ERR "is_umdir_used - remove_files_and_dir "\r\n"failed with err = %d\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init create_pid_file(void)\r\n{\r\nchar file[strlen(uml_dir) + UMID_LEN + sizeof("/pid\0")];\r\nchar pid[sizeof("nnnnn\0")];\r\nint fd, n;\r\nif (umid_file_name("pid", file, sizeof(file)))\r\nreturn;\r\nfd = open(file, O_RDWR | O_CREAT | O_EXCL, 0644);\r\nif (fd < 0) {\r\nprintk(UM_KERN_ERR "Open of machine pid file \"%s\" failed: "\r\n"%s\n", file, strerror(errno));\r\nreturn;\r\n}\r\nsnprintf(pid, sizeof(pid), "%d\n", getpid());\r\nn = write(fd, pid, strlen(pid));\r\nif (n != strlen(pid))\r\nprintk(UM_KERN_ERR "Write of pid file failed - err = %d\n",\r\nerrno);\r\nclose(fd);\r\n}\r\nint __init set_umid(char *name)\r\n{\r\nif (strlen(name) > UMID_LEN - 1)\r\nreturn -E2BIG;\r\nstrlcpy(umid, name, sizeof(umid));\r\nreturn 0;\r\n}\r\nstatic int __init make_umid(void)\r\n{\r\nint fd, err;\r\nchar tmp[256];\r\nif (umid_setup)\r\nreturn 0;\r\nmake_uml_dir();\r\nif (*umid == '\0') {\r\nstrlcpy(tmp, uml_dir, sizeof(tmp));\r\nstrlcat(tmp, "XXXXXX", sizeof(tmp));\r\nfd = mkstemp(tmp);\r\nif (fd < 0) {\r\nprintk(UM_KERN_ERR "make_umid - mkstemp(%s) failed: "\r\n"%s\n", tmp, strerror(errno));\r\nerr = -errno;\r\ngoto err;\r\n}\r\nclose(fd);\r\nset_umid(&tmp[strlen(uml_dir)]);\r\nif (unlink(tmp)) {\r\nerr = -errno;\r\ngoto err;\r\n}\r\n}\r\nsnprintf(tmp, sizeof(tmp), "%s%s", uml_dir, umid);\r\nerr = mkdir(tmp, 0777);\r\nif (err < 0) {\r\nerr = -errno;\r\nif (err != -EEXIST)\r\ngoto err;\r\nif (umdir_take_if_dead(tmp) < 0)\r\ngoto err;\r\nerr = mkdir(tmp, 0777);\r\n}\r\nif (err) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "Failed to create '%s' - err = %d\n", umid,\r\nerrno);\r\ngoto err;\r\n}\r\numid_setup = 1;\r\ncreate_pid_file();\r\nerr = 0;\r\nerr:\r\nreturn err;\r\n}\r\nstatic int __init make_umid_init(void)\r\n{\r\nif (!make_umid())\r\nreturn 0;\r\nprintk(UM_KERN_ERR "Failed to initialize umid \"%s\", trying with a "\r\n"random umid\n", umid);\r\n*umid = '\0';\r\nmake_umid();\r\nreturn 0;\r\n}\r\nint __init umid_file_name(char *name, char *buf, int len)\r\n{\r\nint n, err;\r\nerr = make_umid();\r\nif (err)\r\nreturn err;\r\nn = snprintf(buf, len, "%s%s/%s", uml_dir, umid, name);\r\nif (n >= len) {\r\nprintk(UM_KERN_ERR "umid_file_name : buffer too short\n");\r\nreturn -E2BIG;\r\n}\r\nreturn 0;\r\n}\r\nchar *get_umid(void)\r\n{\r\nreturn umid;\r\n}\r\nstatic int __init set_uml_dir(char *name, int *add)\r\n{\r\nif (*name == '\0') {\r\nprintf("uml_dir can't be an empty string\n");\r\nreturn 0;\r\n}\r\nif (name[strlen(name) - 1] == '/') {\r\numl_dir = name;\r\nreturn 0;\r\n}\r\numl_dir = malloc(strlen(name) + 2);\r\nif (uml_dir == NULL) {\r\nprintf("Failed to malloc uml_dir - error = %d\n", errno);\r\nreturn 0;\r\n}\r\nsprintf(uml_dir, "%s/", name);\r\nreturn 0;\r\n}\r\nstatic void remove_umid_dir(void)\r\n{\r\nchar dir[strlen(uml_dir) + UMID_LEN + 1], err;\r\nsprintf(dir, "%s%s", uml_dir, umid);\r\nerr = remove_files_and_dir(dir);\r\nif (err)\r\nprintf("remove_umid_dir - remove_files_and_dir failed with "\r\n"err = %d\n", err);\r\n}
