static inline int canif_is_active(struct net_device *netdev)\r\n{\r\nstruct can_priv *can = netdev_priv(netdev);\r\nif (!netif_running(netdev))\r\nreturn 0;\r\nreturn (can->state <= CAN_STATE_ERROR_PASSIVE);\r\n}\r\nstatic inline void softing_set_reset_dpram(struct softing *card)\r\n{\r\nif (card->pdat->generation >= 2) {\r\nspin_lock_bh(&card->spin);\r\niowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) & ~1,\r\n&card->dpram[DPRAM_V2_RESET]);\r\nspin_unlock_bh(&card->spin);\r\n}\r\n}\r\nstatic inline void softing_clr_reset_dpram(struct softing *card)\r\n{\r\nif (card->pdat->generation >= 2) {\r\nspin_lock_bh(&card->spin);\r\niowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) | 1,\r\n&card->dpram[DPRAM_V2_RESET]);\r\nspin_unlock_bh(&card->spin);\r\n}\r\n}\r\nstatic netdev_tx_t softing_netdev_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct softing_priv *priv = netdev_priv(dev);\r\nstruct softing *card = priv->card;\r\nint ret;\r\nuint8_t *ptr;\r\nuint8_t fifo_wr, fifo_rd;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nuint8_t buf[DPRAM_TX_SIZE];\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nspin_lock(&card->spin);\r\nret = NETDEV_TX_BUSY;\r\nif (!card->fw.up ||\r\n(card->tx.pending >= TXMAX) ||\r\n(priv->tx.pending >= TX_ECHO_SKB_MAX))\r\ngoto xmit_done;\r\nfifo_wr = ioread8(&card->dpram[DPRAM_TX_WR]);\r\nfifo_rd = ioread8(&card->dpram[DPRAM_TX_RD]);\r\nif (fifo_wr == fifo_rd)\r\ngoto xmit_done;\r\nmemset(buf, 0, sizeof(buf));\r\nptr = buf;\r\n*ptr = CMD_TX;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\n*ptr |= CMD_RTR;\r\nif (cf->can_id & CAN_EFF_FLAG)\r\n*ptr |= CMD_XTD;\r\nif (priv->index)\r\n*ptr |= CMD_BUS2;\r\n++ptr;\r\n*ptr++ = cf->can_dlc;\r\n*ptr++ = (cf->can_id >> 0);\r\n*ptr++ = (cf->can_id >> 8);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\n*ptr++ = (cf->can_id >> 16);\r\n*ptr++ = (cf->can_id >> 24);\r\n} else {\r\nptr += 1;\r\n}\r\nif (!(cf->can_id & CAN_RTR_FLAG))\r\nmemcpy(ptr, &cf->data[0], cf->can_dlc);\r\nmemcpy_toio(&card->dpram[DPRAM_TX + DPRAM_TX_SIZE * fifo_wr],\r\nbuf, DPRAM_TX_SIZE);\r\nif (++fifo_wr >= DPRAM_TX_CNT)\r\nfifo_wr = 0;\r\niowrite8(fifo_wr, &card->dpram[DPRAM_TX_WR]);\r\ncard->tx.last_bus = priv->index;\r\n++card->tx.pending;\r\n++priv->tx.pending;\r\ncan_put_echo_skb(skb, dev, priv->tx.echo_put);\r\n++priv->tx.echo_put;\r\nif (priv->tx.echo_put >= TX_ECHO_SKB_MAX)\r\npriv->tx.echo_put = 0;\r\nret = NETDEV_TX_OK;\r\nxmit_done:\r\nspin_unlock(&card->spin);\r\nif (card->tx.pending >= TXMAX) {\r\nint j;\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nif (card->net[j])\r\nnetif_stop_queue(card->net[j]);\r\n}\r\n}\r\nif (ret != NETDEV_TX_OK)\r\nnetif_stop_queue(dev);\r\nreturn ret;\r\n}\r\nint softing_netdev_rx(struct net_device *netdev, const struct can_frame *msg,\r\nktime_t ktime)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nskb = alloc_can_skb(netdev, &cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nmemcpy(cf, msg, sizeof(*msg));\r\nskb->tstamp = ktime;\r\nreturn netif_rx(skb);\r\n}\r\nstatic int softing_handle_1(struct softing *card)\r\n{\r\nstruct net_device *netdev;\r\nstruct softing_priv *priv;\r\nktime_t ktime;\r\nstruct can_frame msg;\r\nint cnt = 0, lost_msg;\r\nuint8_t fifo_rd, fifo_wr, cmd;\r\nuint8_t *ptr;\r\nuint32_t tmp_u32;\r\nuint8_t buf[DPRAM_RX_SIZE];\r\nmemset(&msg, 0, sizeof(msg));\r\nlost_msg = ioread8(&card->dpram[DPRAM_RX_LOST]);\r\nif (lost_msg) {\r\nint j;\r\niowrite8(0, &card->dpram[DPRAM_RX_LOST]);\r\nmsg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;\r\nmsg.can_dlc = CAN_ERR_DLC;\r\nmsg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nnetdev = card->net[j];\r\nif (!netdev)\r\ncontinue;\r\nif (!canif_is_active(netdev))\r\ncontinue;\r\n++netdev->stats.rx_over_errors;\r\nsofting_netdev_rx(netdev, &msg, ktime_set(0, 0));\r\n}\r\nmemset(&msg, 0, sizeof(msg));\r\n++cnt;\r\n}\r\nfifo_rd = ioread8(&card->dpram[DPRAM_RX_RD]);\r\nfifo_wr = ioread8(&card->dpram[DPRAM_RX_WR]);\r\nif (++fifo_rd >= DPRAM_RX_CNT)\r\nfifo_rd = 0;\r\nif (fifo_wr == fifo_rd)\r\nreturn cnt;\r\nmemcpy_fromio(buf, &card->dpram[DPRAM_RX + DPRAM_RX_SIZE*fifo_rd],\r\nDPRAM_RX_SIZE);\r\nmb();\r\niowrite8(fifo_rd, &card->dpram[DPRAM_RX_RD]);\r\nptr = buf;\r\ncmd = *ptr++;\r\nif (cmd == 0xff)\r\nreturn 0;\r\nnetdev = card->net[0];\r\nif (cmd & CMD_BUS2)\r\nnetdev = card->net[1];\r\npriv = netdev_priv(netdev);\r\nif (cmd & CMD_ERR) {\r\nuint8_t can_state, state;\r\nstate = *ptr++;\r\nmsg.can_id = CAN_ERR_FLAG;\r\nmsg.can_dlc = CAN_ERR_DLC;\r\nif (state & SF_MASK_BUSOFF) {\r\ncan_state = CAN_STATE_BUS_OFF;\r\nmsg.can_id |= CAN_ERR_BUSOFF;\r\nstate = STATE_BUSOFF;\r\n} else if (state & SF_MASK_EPASSIVE) {\r\ncan_state = CAN_STATE_ERROR_PASSIVE;\r\nmsg.can_id |= CAN_ERR_CRTL;\r\nmsg.data[1] = CAN_ERR_CRTL_TX_PASSIVE;\r\nstate = STATE_EPASSIVE;\r\n} else {\r\ncan_state = CAN_STATE_ERROR_ACTIVE;\r\nmsg.can_id |= CAN_ERR_CRTL;\r\nstate = STATE_EACTIVE;\r\n}\r\niowrite8(state, &card->dpram[priv->index ?\r\nDPRAM_INFO_BUSSTATE2 : DPRAM_INFO_BUSSTATE]);\r\ntmp_u32 = le32_to_cpup((void *)ptr);\r\nptr += 4;\r\nktime = softing_raw2ktime(card, tmp_u32);\r\n++netdev->stats.rx_errors;\r\nif (can_state != priv->can.state) {\r\npriv->can.state = can_state;\r\nif (can_state == CAN_STATE_ERROR_PASSIVE)\r\n++priv->can.can_stats.error_passive;\r\nelse if (can_state == CAN_STATE_BUS_OFF) {\r\ncan_bus_off(netdev);\r\nnetif_stop_queue(netdev);\r\n}\r\nsofting_netdev_rx(netdev, &msg, ktime);\r\n}\r\n} else {\r\nif (cmd & CMD_RTR)\r\nmsg.can_id |= CAN_RTR_FLAG;\r\nmsg.can_dlc = get_can_dlc(*ptr++);\r\nif (cmd & CMD_XTD) {\r\nmsg.can_id |= CAN_EFF_FLAG;\r\nmsg.can_id |= le32_to_cpup((void *)ptr);\r\nptr += 4;\r\n} else {\r\nmsg.can_id |= le16_to_cpup((void *)ptr);\r\nptr += 2;\r\n}\r\ntmp_u32 = le32_to_cpup((void *)ptr);\r\nptr += 4;\r\nktime = softing_raw2ktime(card, tmp_u32);\r\nif (!(msg.can_id & CAN_RTR_FLAG))\r\nmemcpy(&msg.data[0], ptr, 8);\r\nptr += 8;\r\nif (cmd & CMD_ACK) {\r\nstruct sk_buff *skb;\r\nskb = priv->can.echo_skb[priv->tx.echo_get];\r\nif (skb)\r\nskb->tstamp = ktime;\r\ncan_get_echo_skb(netdev, priv->tx.echo_get);\r\n++priv->tx.echo_get;\r\nif (priv->tx.echo_get >= TX_ECHO_SKB_MAX)\r\npriv->tx.echo_get = 0;\r\nif (priv->tx.pending)\r\n--priv->tx.pending;\r\nif (card->tx.pending)\r\n--card->tx.pending;\r\n++netdev->stats.tx_packets;\r\nif (!(msg.can_id & CAN_RTR_FLAG))\r\nnetdev->stats.tx_bytes += msg.can_dlc;\r\n} else {\r\nint ret;\r\nret = softing_netdev_rx(netdev, &msg, ktime);\r\nif (ret == NET_RX_SUCCESS) {\r\n++netdev->stats.rx_packets;\r\nif (!(msg.can_id & CAN_RTR_FLAG))\r\nnetdev->stats.rx_bytes += msg.can_dlc;\r\n} else {\r\n++netdev->stats.rx_dropped;\r\n}\r\n}\r\n}\r\n++cnt;\r\nreturn cnt;\r\n}\r\nstatic irqreturn_t softing_irq_thread(int irq, void *dev_id)\r\n{\r\nstruct softing *card = (struct softing *)dev_id;\r\nstruct net_device *netdev;\r\nstruct softing_priv *priv;\r\nint j, offset, work_done;\r\nwork_done = 0;\r\nspin_lock_bh(&card->spin);\r\nwhile (softing_handle_1(card) > 0) {\r\n++card->irq.svc_count;\r\n++work_done;\r\n}\r\nspin_unlock_bh(&card->spin);\r\noffset = card->tx.last_bus;\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nif (card->tx.pending >= TXMAX)\r\nbreak;\r\nnetdev = card->net[(j + offset + 1) % card->pdat->nbus];\r\nif (!netdev)\r\ncontinue;\r\npriv = netdev_priv(netdev);\r\nif (!canif_is_active(netdev))\r\ncontinue;\r\nif (priv->tx.pending >= TX_ECHO_SKB_MAX)\r\ncontinue;\r\n++work_done;\r\nnetif_wake_queue(netdev);\r\n}\r\nreturn work_done ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t softing_irq_v2(int irq, void *dev_id)\r\n{\r\nstruct softing *card = (struct softing *)dev_id;\r\nuint8_t ir;\r\nir = ioread8(&card->dpram[DPRAM_V2_IRQ_TOHOST]);\r\niowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);\r\nreturn (1 == ir) ? IRQ_WAKE_THREAD : IRQ_NONE;\r\n}\r\nstatic irqreturn_t softing_irq_v1(int irq, void *dev_id)\r\n{\r\nstruct softing *card = (struct softing *)dev_id;\r\nuint8_t ir;\r\nir = ioread8(&card->dpram[DPRAM_IRQ_TOHOST]);\r\niowrite8(0, &card->dpram[DPRAM_IRQ_TOHOST]);\r\nreturn ir ? IRQ_WAKE_THREAD : IRQ_NONE;\r\n}\r\nstatic int softing_netdev_open(struct net_device *ndev)\r\n{\r\nint ret;\r\nret = open_candev(ndev);\r\nif (!ret)\r\nret = softing_startstop(ndev, 1);\r\nreturn ret;\r\n}\r\nstatic int softing_netdev_stop(struct net_device *ndev)\r\n{\r\nint ret;\r\nnetif_stop_queue(ndev);\r\nret = softing_startstop(ndev, 0);\r\nreturn ret;\r\n}\r\nstatic int softing_candev_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nint ret;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nret = softing_startstop(ndev, 1);\r\nreturn ret;\r\ncase CAN_MODE_STOP:\r\ncase CAN_MODE_SLEEP:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint softing_enable_irq(struct softing *card, int enable)\r\n{\r\nint ret;\r\nif (!card->irq.nr) {\r\nreturn 0;\r\n} else if (card->irq.requested && !enable) {\r\nfree_irq(card->irq.nr, card);\r\ncard->irq.requested = 0;\r\n} else if (!card->irq.requested && enable) {\r\nret = request_threaded_irq(card->irq.nr,\r\n(card->pdat->generation >= 2) ?\r\nsofting_irq_v2 : softing_irq_v1,\r\nsofting_irq_thread, IRQF_SHARED,\r\ndev_name(&card->pdev->dev), card);\r\nif (ret) {\r\ndev_alert(&card->pdev->dev,\r\n"request_threaded_irq(%u) failed\n",\r\ncard->irq.nr);\r\nreturn ret;\r\n}\r\ncard->irq.requested = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void softing_card_shutdown(struct softing *card)\r\n{\r\nint fw_up = 0;\r\nif (mutex_lock_interruptible(&card->fw.lock))\r\n;\r\nfw_up = card->fw.up;\r\ncard->fw.up = 0;\r\nif (card->irq.requested && card->irq.nr) {\r\nfree_irq(card->irq.nr, card);\r\ncard->irq.requested = 0;\r\n}\r\nif (fw_up) {\r\nif (card->pdat->enable_irq)\r\ncard->pdat->enable_irq(card->pdev, 0);\r\nsofting_set_reset_dpram(card);\r\nif (card->pdat->reset)\r\ncard->pdat->reset(card->pdev, 1);\r\n}\r\nmutex_unlock(&card->fw.lock);\r\n}\r\nstatic int softing_card_boot(struct softing *card)\r\n{\r\nint ret, j;\r\nstatic const uint8_t stream[] = {\r\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };\r\nunsigned char back[sizeof(stream)];\r\nif (mutex_lock_interruptible(&card->fw.lock))\r\nreturn -ERESTARTSYS;\r\nif (card->fw.up) {\r\nmutex_unlock(&card->fw.lock);\r\nreturn 0;\r\n}\r\nif (card->pdat->enable_irq)\r\ncard->pdat->enable_irq(card->pdev, 1);\r\nsofting_set_reset_dpram(card);\r\nif (card->pdat->reset)\r\ncard->pdat->reset(card->pdev, 1);\r\nfor (j = 0; (j + sizeof(stream)) < card->dpram_size;\r\nj += sizeof(stream)) {\r\nmemcpy_toio(&card->dpram[j], stream, sizeof(stream));\r\nmb();\r\nmemcpy_fromio(back, &card->dpram[j], sizeof(stream));\r\nif (!memcmp(back, stream, sizeof(stream)))\r\ncontinue;\r\ndev_alert(&card->pdev->dev, "dpram failed at 0x%04x\n", j);\r\nret = -EIO;\r\ngoto failed;\r\n}\r\nwmb();\r\nret = softing_load_fw(card->pdat->boot.fw, card, card->dpram,\r\ncard->dpram_size,\r\ncard->pdat->boot.offs - card->pdat->boot.addr);\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_load_fw(card->pdat->load.fw, card, card->dpram,\r\ncard->dpram_size,\r\ncard->pdat->load.offs - card->pdat->load.addr);\r\nif (ret < 0)\r\ngoto failed;\r\nif (card->pdat->reset)\r\ncard->pdat->reset(card->pdev, 0);\r\nsofting_clr_reset_dpram(card);\r\nret = softing_bootloader_command(card, 0, "card boot");\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_load_app_fw(card->pdat->app.fw, card);\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_chip_poweron(card);\r\nif (ret < 0)\r\ngoto failed;\r\ncard->fw.up = 1;\r\nmutex_unlock(&card->fw.lock);\r\nreturn 0;\r\nfailed:\r\ncard->fw.up = 0;\r\nif (card->pdat->enable_irq)\r\ncard->pdat->enable_irq(card->pdev, 0);\r\nsofting_set_reset_dpram(card);\r\nif (card->pdat->reset)\r\ncard->pdat->reset(card->pdev, 1);\r\nmutex_unlock(&card->fw.lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_channel(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net_device *ndev = to_net_dev(dev);\r\nstruct softing_priv *priv = netdev2softing(ndev);\r\nreturn sprintf(buf, "%i\n", priv->index);\r\n}\r\nstatic ssize_t show_chip(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net_device *ndev = to_net_dev(dev);\r\nstruct softing_priv *priv = netdev2softing(ndev);\r\nreturn sprintf(buf, "%i\n", priv->chip);\r\n}\r\nstatic ssize_t show_output(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net_device *ndev = to_net_dev(dev);\r\nstruct softing_priv *priv = netdev2softing(ndev);\r\nreturn sprintf(buf, "0x%02x\n", priv->output);\r\n}\r\nstatic ssize_t store_output(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct net_device *ndev = to_net_dev(dev);\r\nstruct softing_priv *priv = netdev2softing(ndev);\r\nstruct softing *card = priv->card;\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nval &= 0xFF;\r\nret = mutex_lock_interruptible(&card->fw.lock);\r\nif (ret)\r\nreturn -ERESTARTSYS;\r\nif (netif_running(ndev)) {\r\nmutex_unlock(&card->fw.lock);\r\nreturn -EBUSY;\r\n}\r\npriv->output = val;\r\nmutex_unlock(&card->fw.lock);\r\nreturn count;\r\n}\r\nstatic struct net_device *softing_netdev_create(struct softing *card,\r\nuint16_t chip_id)\r\n{\r\nstruct net_device *netdev;\r\nstruct softing_priv *priv;\r\nnetdev = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);\r\nif (!netdev) {\r\ndev_alert(&card->pdev->dev, "alloc_candev failed\n");\r\nreturn NULL;\r\n}\r\npriv = netdev_priv(netdev);\r\npriv->netdev = netdev;\r\npriv->card = card;\r\nmemcpy(&priv->btr_const, &softing_btr_const, sizeof(priv->btr_const));\r\npriv->btr_const.brp_max = card->pdat->max_brp;\r\npriv->btr_const.sjw_max = card->pdat->max_sjw;\r\npriv->can.bittiming_const = &priv->btr_const;\r\npriv->can.clock.freq = 8000000;\r\npriv->chip = chip_id;\r\npriv->output = softing_default_output(netdev);\r\nSET_NETDEV_DEV(netdev, &card->pdev->dev);\r\nnetdev->flags |= IFF_ECHO;\r\nnetdev->netdev_ops = &softing_netdev_ops;\r\npriv->can.do_set_mode = softing_candev_set_mode;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nreturn netdev;\r\n}\r\nstatic int softing_netdev_register(struct net_device *netdev)\r\n{\r\nint ret;\r\nnetdev->sysfs_groups[0] = &netdev_sysfs_group;\r\nret = register_candev(netdev);\r\nif (ret) {\r\ndev_alert(&netdev->dev, "register failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void softing_netdev_cleanup(struct net_device *netdev)\r\n{\r\nunregister_candev(netdev);\r\nfree_candev(netdev);\r\n}\r\nstatic int softing_pdev_remove(struct platform_device *pdev)\r\n{\r\nstruct softing *card = platform_get_drvdata(pdev);\r\nint j;\r\nsofting_card_shutdown(card);\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nif (!card->net[j])\r\ncontinue;\r\nsofting_netdev_cleanup(card->net[j]);\r\ncard->net[j] = NULL;\r\n}\r\nsysfs_remove_group(&pdev->dev.kobj, &softing_pdev_group);\r\niounmap(card->dpram);\r\nkfree(card);\r\nreturn 0;\r\n}\r\nstatic int softing_pdev_probe(struct platform_device *pdev)\r\n{\r\nconst struct softing_platform_data *pdat = pdev->dev.platform_data;\r\nstruct softing *card;\r\nstruct net_device *netdev;\r\nstruct softing_priv *priv;\r\nstruct resource *pres;\r\nint ret;\r\nint j;\r\nif (!pdat) {\r\ndev_warn(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdat->nbus > ARRAY_SIZE(card->net)) {\r\ndev_warn(&pdev->dev, "%u nets??\n", pdat->nbus);\r\nreturn -EINVAL;\r\n}\r\ncard = kzalloc(sizeof(*card), GFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\ncard->pdat = pdat;\r\ncard->pdev = pdev;\r\nplatform_set_drvdata(pdev, card);\r\nmutex_init(&card->fw.lock);\r\nspin_lock_init(&card->spin);\r\nret = -EINVAL;\r\npres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!pres)\r\ngoto platform_resource_failed;\r\ncard->dpram_phys = pres->start;\r\ncard->dpram_size = resource_size(pres);\r\ncard->dpram = ioremap_nocache(card->dpram_phys, card->dpram_size);\r\nif (!card->dpram) {\r\ndev_alert(&card->pdev->dev, "dpram ioremap failed\n");\r\ngoto ioremap_failed;\r\n}\r\npres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (pres)\r\ncard->irq.nr = pres->start;\r\nret = softing_card_boot(card);\r\nif (ret < 0) {\r\ndev_alert(&pdev->dev, "failed to boot\n");\r\ngoto boot_failed;\r\n}\r\ncard->id.freq = card->pdat->freq;\r\nret = sysfs_create_group(&pdev->dev.kobj, &softing_pdev_group);\r\nif (ret < 0) {\r\ndev_alert(&card->pdev->dev, "sysfs failed\n");\r\ngoto sysfs_failed;\r\n}\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\ncard->net[j] = netdev =\r\nsofting_netdev_create(card, card->id.chip[j]);\r\nif (!netdev) {\r\ndev_alert(&pdev->dev, "failed to make can[%i]", j);\r\nret = -ENOMEM;\r\ngoto netdev_failed;\r\n}\r\npriv = netdev_priv(card->net[j]);\r\npriv->index = j;\r\nret = softing_netdev_register(netdev);\r\nif (ret) {\r\nfree_candev(netdev);\r\ncard->net[j] = NULL;\r\ndev_alert(&card->pdev->dev,\r\n"failed to register can[%i]\n", j);\r\ngoto netdev_failed;\r\n}\r\n}\r\ndev_info(&card->pdev->dev, "%s ready.\n", card->pdat->name);\r\nreturn 0;\r\nnetdev_failed:\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nif (!card->net[j])\r\ncontinue;\r\nsofting_netdev_cleanup(card->net[j]);\r\n}\r\nsysfs_remove_group(&pdev->dev.kobj, &softing_pdev_group);\r\nsysfs_failed:\r\nsofting_card_shutdown(card);\r\nboot_failed:\r\niounmap(card->dpram);\r\nioremap_failed:\r\nplatform_resource_failed:\r\nkfree(card);\r\nreturn ret;\r\n}
