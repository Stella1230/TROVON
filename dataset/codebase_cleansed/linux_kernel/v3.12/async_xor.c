void\r\ndo_sync_xor(struct page *dest, struct page **src_list, unsigned int offset,\r\nint src_cnt, size_t len, struct async_submit_ctl *submit)\r\n{\r\nint i;\r\nint xor_src_cnt = 0;\r\nint src_off = 0;\r\nvoid *dest_buf;\r\nvoid **srcs;\r\nif (submit->scribble)\r\nsrcs = submit->scribble;\r\nelse\r\nsrcs = (void **) src_list;\r\nfor (i = 0; i < src_cnt; i++)\r\nif (src_list[i])\r\nsrcs[xor_src_cnt++] = page_address(src_list[i]) + offset;\r\nsrc_cnt = xor_src_cnt;\r\ndest_buf = page_address(dest) + offset;\r\nif (submit->flags & ASYNC_TX_XOR_ZERO_DST)\r\nmemset(dest_buf, 0, len);\r\nwhile (src_cnt > 0) {\r\nxor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\r\nxor_blocks(xor_src_cnt, len, dest_buf, &srcs[src_off]);\r\nsrc_cnt -= xor_src_cnt;\r\nsrc_off += xor_src_cnt;\r\n}\r\nasync_tx_sync_epilog(submit);\r\n}\r\nstruct dma_async_tx_descriptor *\r\nasync_xor(struct page *dest, struct page **src_list, unsigned int offset,\r\nint src_cnt, size_t len, struct async_submit_ctl *submit)\r\n{\r\nstruct dma_chan *chan = async_tx_find_channel(submit, DMA_XOR,\r\n&dest, 1, src_list,\r\nsrc_cnt, len);\r\ndma_addr_t *dma_src = NULL;\r\nBUG_ON(src_cnt <= 1);\r\nif (submit->scribble)\r\ndma_src = submit->scribble;\r\nelse if (sizeof(dma_addr_t) <= sizeof(struct page *))\r\ndma_src = (dma_addr_t *) src_list;\r\nif (dma_src && chan && is_dma_xor_aligned(chan->device, offset, 0, len)) {\r\npr_debug("%s (async): len: %zu\n", __func__, len);\r\nreturn do_async_xor(chan, dest, src_list, offset, src_cnt, len,\r\ndma_src, submit);\r\n} else {\r\npr_debug("%s (sync): len: %zu\n", __func__, len);\r\nWARN_ONCE(chan, "%s: no space for dma address conversion\n",\r\n__func__);\r\nif (submit->flags & ASYNC_TX_XOR_DROP_DST) {\r\nsrc_cnt--;\r\nsrc_list++;\r\n}\r\nasync_tx_quiesce(&submit->depend_tx);\r\ndo_sync_xor(dest, src_list, offset, src_cnt, len, submit);\r\nreturn NULL;\r\n}\r\n}\r\nstatic int page_is_zero(struct page *p, unsigned int offset, size_t len)\r\n{\r\nreturn !memchr_inv(page_address(p) + offset, 0, len);\r\n}\r\nstatic inline struct dma_chan *\r\nxor_val_chan(struct async_submit_ctl *submit, struct page *dest,\r\nstruct page **src_list, int src_cnt, size_t len)\r\n{\r\n#ifdef CONFIG_ASYNC_TX_DISABLE_XOR_VAL_DMA\r\nreturn NULL;\r\n#endif\r\nreturn async_tx_find_channel(submit, DMA_XOR_VAL, &dest, 1, src_list,\r\nsrc_cnt, len);\r\n}\r\nstruct dma_async_tx_descriptor *\r\nasync_xor_val(struct page *dest, struct page **src_list, unsigned int offset,\r\nint src_cnt, size_t len, enum sum_check_flags *result,\r\nstruct async_submit_ctl *submit)\r\n{\r\nstruct dma_chan *chan = xor_val_chan(submit, dest, src_list, src_cnt, len);\r\nstruct dma_device *device = chan ? chan->device : NULL;\r\nstruct dma_async_tx_descriptor *tx = NULL;\r\ndma_addr_t *dma_src = NULL;\r\nBUG_ON(src_cnt <= 1);\r\nif (submit->scribble)\r\ndma_src = submit->scribble;\r\nelse if (sizeof(dma_addr_t) <= sizeof(struct page *))\r\ndma_src = (dma_addr_t *) src_list;\r\nif (dma_src && device && src_cnt <= device->max_xor &&\r\nis_dma_xor_aligned(device, offset, 0, len)) {\r\nunsigned long dma_prep_flags = 0;\r\nint i;\r\npr_debug("%s: (async) len: %zu\n", __func__, len);\r\nif (submit->cb_fn)\r\ndma_prep_flags |= DMA_PREP_INTERRUPT;\r\nif (submit->flags & ASYNC_TX_FENCE)\r\ndma_prep_flags |= DMA_PREP_FENCE;\r\nfor (i = 0; i < src_cnt; i++)\r\ndma_src[i] = dma_map_page(device->dev, src_list[i],\r\noffset, len, DMA_TO_DEVICE);\r\ntx = device->device_prep_dma_xor_val(chan, dma_src, src_cnt,\r\nlen, result,\r\ndma_prep_flags);\r\nif (unlikely(!tx)) {\r\nasync_tx_quiesce(&submit->depend_tx);\r\nwhile (!tx) {\r\ndma_async_issue_pending(chan);\r\ntx = device->device_prep_dma_xor_val(chan,\r\ndma_src, src_cnt, len, result,\r\ndma_prep_flags);\r\n}\r\n}\r\nasync_tx_submit(chan, tx, submit);\r\n} else {\r\nenum async_tx_flags flags_orig = submit->flags;\r\npr_debug("%s: (sync) len: %zu\n", __func__, len);\r\nWARN_ONCE(device && src_cnt <= device->max_xor,\r\n"%s: no space for dma address conversion\n",\r\n__func__);\r\nsubmit->flags |= ASYNC_TX_XOR_DROP_DST;\r\nsubmit->flags &= ~ASYNC_TX_ACK;\r\ntx = async_xor(dest, src_list, offset, src_cnt, len, submit);\r\nasync_tx_quiesce(&tx);\r\n*result = !page_is_zero(dest, offset, len) << SUM_CHECK_P;\r\nasync_tx_sync_epilog(submit);\r\nsubmit->flags = flags_orig;\r\n}\r\nreturn tx;\r\n}
