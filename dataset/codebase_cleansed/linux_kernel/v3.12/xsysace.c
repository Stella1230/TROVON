static u16 ace_in_8(struct ace_device *ace, int reg)\r\n{\r\nvoid __iomem *r = ace->baseaddr + reg;\r\nreturn in_8(r) | (in_8(r + 1) << 8);\r\n}\r\nstatic void ace_out_8(struct ace_device *ace, int reg, u16 val)\r\n{\r\nvoid __iomem *r = ace->baseaddr + reg;\r\nout_8(r, val);\r\nout_8(r + 1, val >> 8);\r\n}\r\nstatic void ace_datain_8(struct ace_device *ace)\r\n{\r\nvoid __iomem *r = ace->baseaddr + 0x40;\r\nu8 *dst = ace->data_ptr;\r\nint i = ACE_FIFO_SIZE;\r\nwhile (i--)\r\n*dst++ = in_8(r++);\r\nace->data_ptr = dst;\r\n}\r\nstatic void ace_dataout_8(struct ace_device *ace)\r\n{\r\nvoid __iomem *r = ace->baseaddr + 0x40;\r\nu8 *src = ace->data_ptr;\r\nint i = ACE_FIFO_SIZE;\r\nwhile (i--)\r\nout_8(r++, *src++);\r\nace->data_ptr = src;\r\n}\r\nstatic u16 ace_in_be16(struct ace_device *ace, int reg)\r\n{\r\nreturn in_be16(ace->baseaddr + reg);\r\n}\r\nstatic void ace_out_be16(struct ace_device *ace, int reg, u16 val)\r\n{\r\nout_be16(ace->baseaddr + reg, val);\r\n}\r\nstatic void ace_datain_be16(struct ace_device *ace)\r\n{\r\nint i = ACE_FIFO_SIZE / 2;\r\nu16 *dst = ace->data_ptr;\r\nwhile (i--)\r\n*dst++ = in_le16(ace->baseaddr + 0x40);\r\nace->data_ptr = dst;\r\n}\r\nstatic void ace_dataout_be16(struct ace_device *ace)\r\n{\r\nint i = ACE_FIFO_SIZE / 2;\r\nu16 *src = ace->data_ptr;\r\nwhile (i--)\r\nout_le16(ace->baseaddr + 0x40, *src++);\r\nace->data_ptr = src;\r\n}\r\nstatic u16 ace_in_le16(struct ace_device *ace, int reg)\r\n{\r\nreturn in_le16(ace->baseaddr + reg);\r\n}\r\nstatic void ace_out_le16(struct ace_device *ace, int reg, u16 val)\r\n{\r\nout_le16(ace->baseaddr + reg, val);\r\n}\r\nstatic void ace_datain_le16(struct ace_device *ace)\r\n{\r\nint i = ACE_FIFO_SIZE / 2;\r\nu16 *dst = ace->data_ptr;\r\nwhile (i--)\r\n*dst++ = in_be16(ace->baseaddr + 0x40);\r\nace->data_ptr = dst;\r\n}\r\nstatic void ace_dataout_le16(struct ace_device *ace)\r\n{\r\nint i = ACE_FIFO_SIZE / 2;\r\nu16 *src = ace->data_ptr;\r\nwhile (i--)\r\nout_be16(ace->baseaddr + 0x40, *src++);\r\nace->data_ptr = src;\r\n}\r\nstatic inline u16 ace_in(struct ace_device *ace, int reg)\r\n{\r\nreturn ace->reg_ops->in(ace, reg);\r\n}\r\nstatic inline u32 ace_in32(struct ace_device *ace, int reg)\r\n{\r\nreturn ace_in(ace, reg) | (ace_in(ace, reg + 2) << 16);\r\n}\r\nstatic inline void ace_out(struct ace_device *ace, int reg, u16 val)\r\n{\r\nace->reg_ops->out(ace, reg, val);\r\n}\r\nstatic inline void ace_out32(struct ace_device *ace, int reg, u32 val)\r\n{\r\nace_out(ace, reg, val);\r\nace_out(ace, reg + 2, val >> 16);\r\n}\r\nstatic void ace_dump_mem(void *base, int len)\r\n{\r\nconst char *ptr = base;\r\nint i, j;\r\nfor (i = 0; i < len; i += 16) {\r\nprintk(KERN_INFO "%.8x:", i);\r\nfor (j = 0; j < 16; j++) {\r\nif (!(j % 4))\r\nprintk(" ");\r\nprintk("%.2x", ptr[i + j]);\r\n}\r\nprintk(" ");\r\nfor (j = 0; j < 16; j++)\r\nprintk("%c", isprint(ptr[i + j]) ? ptr[i + j] : '.');\r\nprintk("\n");\r\n}\r\n}\r\nstatic inline void ace_dump_mem(void *base, int len)\r\n{\r\n}\r\nstatic void ace_dump_regs(struct ace_device *ace)\r\n{\r\ndev_info(ace->dev,\r\n" ctrl: %.8x seccnt/cmd: %.4x ver:%.4x\n"\r\n" status:%.8x mpu_lba:%.8x busmode:%4x\n"\r\n" error: %.8x cfg_lba:%.8x fatstat:%.4x\n",\r\nace_in32(ace, ACE_CTRL),\r\nace_in(ace, ACE_SECCNTCMD),\r\nace_in(ace, ACE_VERSION),\r\nace_in32(ace, ACE_STATUS),\r\nace_in32(ace, ACE_MPULBA),\r\nace_in(ace, ACE_BUSMODE),\r\nace_in32(ace, ACE_ERROR),\r\nace_in32(ace, ACE_CFGLBA), ace_in(ace, ACE_FATSTAT));\r\n}\r\nstatic void ace_fix_driveid(u16 *id)\r\n{\r\n#if defined(__BIG_ENDIAN)\r\nint i;\r\nfor (i = 0; i < ATA_ID_WORDS; i++, id++)\r\n*id = le16_to_cpu(*id);\r\n#endif\r\n}\r\nstatic inline void ace_fsm_yield(struct ace_device *ace)\r\n{\r\ndev_dbg(ace->dev, "ace_fsm_yield()\n");\r\ntasklet_schedule(&ace->fsm_tasklet);\r\nace->fsm_continue_flag = 0;\r\n}\r\nstatic inline void ace_fsm_yieldirq(struct ace_device *ace)\r\n{\r\ndev_dbg(ace->dev, "ace_fsm_yieldirq()\n");\r\nif (!ace->irq)\r\ntasklet_schedule(&ace->fsm_tasklet);\r\nace->fsm_continue_flag = 0;\r\n}\r\nstatic struct request *ace_get_next_request(struct request_queue *q)\r\n{\r\nstruct request *req;\r\nwhile ((req = blk_peek_request(q)) != NULL) {\r\nif (req->cmd_type == REQ_TYPE_FS)\r\nbreak;\r\nblk_start_request(req);\r\n__blk_end_request_all(req, -EIO);\r\n}\r\nreturn req;\r\n}\r\nstatic void ace_fsm_dostate(struct ace_device *ace)\r\n{\r\nstruct request *req;\r\nu32 status;\r\nu16 val;\r\nint count;\r\n#if defined(DEBUG)\r\ndev_dbg(ace->dev, "fsm_state=%i, id_req_count=%i\n",\r\nace->fsm_state, ace->id_req_count);\r\n#endif\r\nstatus = ace_in32(ace, ACE_STATUS);\r\nif ((status & ACE_STATUS_CFDETECT) == 0) {\r\nace->fsm_state = ACE_FSM_STATE_IDLE;\r\nace->media_change = 1;\r\nset_capacity(ace->gd, 0);\r\ndev_info(ace->dev, "No CF in slot\n");\r\nif (ace->req) {\r\n__blk_end_request_all(ace->req, -EIO);\r\nace->req = NULL;\r\n}\r\nwhile ((req = blk_fetch_request(ace->queue)) != NULL)\r\n__blk_end_request_all(req, -EIO);\r\nace->fsm_state = ACE_FSM_STATE_IDLE;\r\nace->id_result = -EIO;\r\nwhile (ace->id_req_count) {\r\ncomplete(&ace->id_completion);\r\nace->id_req_count--;\r\n}\r\n}\r\nswitch (ace->fsm_state) {\r\ncase ACE_FSM_STATE_IDLE:\r\nif (ace->id_req_count || ace_get_next_request(ace->queue)) {\r\nace->fsm_iter_num++;\r\nace->fsm_state = ACE_FSM_STATE_REQ_LOCK;\r\nmod_timer(&ace->stall_timer, jiffies + HZ);\r\nif (!timer_pending(&ace->stall_timer))\r\nadd_timer(&ace->stall_timer);\r\nbreak;\r\n}\r\ndel_timer(&ace->stall_timer);\r\nace->fsm_continue_flag = 0;\r\nbreak;\r\ncase ACE_FSM_STATE_REQ_LOCK:\r\nif (ace_in(ace, ACE_STATUS) & ACE_STATUS_MPULOCK) {\r\nace->fsm_state = ACE_FSM_STATE_WAIT_CFREADY;\r\nbreak;\r\n}\r\nval = ace_in(ace, ACE_CTRL);\r\nace_out(ace, ACE_CTRL, val | ACE_CTRL_LOCKREQ);\r\nace->fsm_state = ACE_FSM_STATE_WAIT_LOCK;\r\nbreak;\r\ncase ACE_FSM_STATE_WAIT_LOCK:\r\nif (ace_in(ace, ACE_STATUS) & ACE_STATUS_MPULOCK) {\r\nace->fsm_state = ACE_FSM_STATE_WAIT_CFREADY;\r\nbreak;\r\n}\r\nace_fsm_yield(ace);\r\nbreak;\r\ncase ACE_FSM_STATE_WAIT_CFREADY:\r\nstatus = ace_in32(ace, ACE_STATUS);\r\nif (!(status & ACE_STATUS_RDYFORCFCMD) ||\r\n(status & ACE_STATUS_CFBSY)) {\r\nace_fsm_yield(ace);\r\nbreak;\r\n}\r\nif (ace->id_req_count)\r\nace->fsm_state = ACE_FSM_STATE_IDENTIFY_PREPARE;\r\nelse\r\nace->fsm_state = ACE_FSM_STATE_REQ_PREPARE;\r\nbreak;\r\ncase ACE_FSM_STATE_IDENTIFY_PREPARE:\r\nace->fsm_task = ACE_TASK_IDENTIFY;\r\nace->data_ptr = ace->cf_id;\r\nace->data_count = ACE_BUF_PER_SECTOR;\r\nace_out(ace, ACE_SECCNTCMD, ACE_SECCNTCMD_IDENTIFY);\r\nval = ace_in(ace, ACE_CTRL);\r\nace_out(ace, ACE_CTRL, val | ACE_CTRL_CFGRESET);\r\nace->fsm_state = ACE_FSM_STATE_IDENTIFY_TRANSFER;\r\nace_fsm_yieldirq(ace);\r\nbreak;\r\ncase ACE_FSM_STATE_IDENTIFY_TRANSFER:\r\nstatus = ace_in32(ace, ACE_STATUS);\r\nif (status & ACE_STATUS_CFBSY) {\r\ndev_dbg(ace->dev, "CFBSY set; t=%i iter=%i dc=%i\n",\r\nace->fsm_task, ace->fsm_iter_num,\r\nace->data_count);\r\nace_fsm_yield(ace);\r\nbreak;\r\n}\r\nif (!(status & ACE_STATUS_DATABUFRDY)) {\r\nace_fsm_yield(ace);\r\nbreak;\r\n}\r\nace->reg_ops->datain(ace);\r\nace->data_count--;\r\nif (ace->data_count != 0) {\r\nace_fsm_yieldirq(ace);\r\nbreak;\r\n}\r\ndev_dbg(ace->dev, "identify finished\n");\r\nace->fsm_state = ACE_FSM_STATE_IDENTIFY_COMPLETE;\r\nbreak;\r\ncase ACE_FSM_STATE_IDENTIFY_COMPLETE:\r\nace_fix_driveid(ace->cf_id);\r\nace_dump_mem(ace->cf_id, 512);\r\nif (ace->data_result) {\r\nace->media_change = 1;\r\nset_capacity(ace->gd, 0);\r\ndev_err(ace->dev, "error fetching CF id (%i)\n",\r\nace->data_result);\r\n} else {\r\nace->media_change = 0;\r\nset_capacity(ace->gd,\r\nata_id_u32(ace->cf_id, ATA_ID_LBA_CAPACITY));\r\ndev_info(ace->dev, "capacity: %i sectors\n",\r\nata_id_u32(ace->cf_id, ATA_ID_LBA_CAPACITY));\r\n}\r\nace->fsm_state = ACE_FSM_STATE_IDLE;\r\nace->id_result = ace->data_result;\r\nwhile (ace->id_req_count) {\r\ncomplete(&ace->id_completion);\r\nace->id_req_count--;\r\n}\r\nbreak;\r\ncase ACE_FSM_STATE_REQ_PREPARE:\r\nreq = ace_get_next_request(ace->queue);\r\nif (!req) {\r\nace->fsm_state = ACE_FSM_STATE_IDLE;\r\nbreak;\r\n}\r\nblk_start_request(req);\r\ndev_dbg(ace->dev,\r\n"request: sec=%llx hcnt=%x, ccnt=%x, dir=%i\n",\r\n(unsigned long long)blk_rq_pos(req),\r\nblk_rq_sectors(req), blk_rq_cur_sectors(req),\r\nrq_data_dir(req));\r\nace->req = req;\r\nace->data_ptr = req->buffer;\r\nace->data_count = blk_rq_cur_sectors(req) * ACE_BUF_PER_SECTOR;\r\nace_out32(ace, ACE_MPULBA, blk_rq_pos(req) & 0x0FFFFFFF);\r\ncount = blk_rq_sectors(req);\r\nif (rq_data_dir(req)) {\r\ndev_dbg(ace->dev, "write data\n");\r\nace->fsm_task = ACE_TASK_WRITE;\r\nace_out(ace, ACE_SECCNTCMD,\r\ncount | ACE_SECCNTCMD_WRITE_DATA);\r\n} else {\r\ndev_dbg(ace->dev, "read data\n");\r\nace->fsm_task = ACE_TASK_READ;\r\nace_out(ace, ACE_SECCNTCMD,\r\ncount | ACE_SECCNTCMD_READ_DATA);\r\n}\r\nval = ace_in(ace, ACE_CTRL);\r\nace_out(ace, ACE_CTRL, val | ACE_CTRL_CFGRESET);\r\nace->fsm_state = ACE_FSM_STATE_REQ_TRANSFER;\r\nif (ace->fsm_task == ACE_TASK_READ)\r\nace_fsm_yieldirq(ace);\r\nbreak;\r\ncase ACE_FSM_STATE_REQ_TRANSFER:\r\nstatus = ace_in32(ace, ACE_STATUS);\r\nif (status & ACE_STATUS_CFBSY) {\r\ndev_dbg(ace->dev,\r\n"CFBSY set; t=%i iter=%i c=%i dc=%i irq=%i\n",\r\nace->fsm_task, ace->fsm_iter_num,\r\nblk_rq_cur_sectors(ace->req) * 16,\r\nace->data_count, ace->in_irq);\r\nace_fsm_yield(ace);\r\nbreak;\r\n}\r\nif (!(status & ACE_STATUS_DATABUFRDY)) {\r\ndev_dbg(ace->dev,\r\n"DATABUF not set; t=%i iter=%i c=%i dc=%i irq=%i\n",\r\nace->fsm_task, ace->fsm_iter_num,\r\nblk_rq_cur_sectors(ace->req) * 16,\r\nace->data_count, ace->in_irq);\r\nace_fsm_yieldirq(ace);\r\nbreak;\r\n}\r\nif (ace->fsm_task == ACE_TASK_WRITE)\r\nace->reg_ops->dataout(ace);\r\nelse\r\nace->reg_ops->datain(ace);\r\nace->data_count--;\r\nif (ace->data_count != 0) {\r\nace_fsm_yieldirq(ace);\r\nbreak;\r\n}\r\nif (__blk_end_request_cur(ace->req, 0)) {\r\nace->data_ptr = ace->req->buffer;\r\nace->data_count = blk_rq_cur_sectors(ace->req) * 16;\r\nace_fsm_yieldirq(ace);\r\nbreak;\r\n}\r\nace->fsm_state = ACE_FSM_STATE_REQ_COMPLETE;\r\nbreak;\r\ncase ACE_FSM_STATE_REQ_COMPLETE:\r\nace->req = NULL;\r\nace->fsm_state = ACE_FSM_STATE_IDLE;\r\nbreak;\r\ndefault:\r\nace->fsm_state = ACE_FSM_STATE_IDLE;\r\nbreak;\r\n}\r\n}\r\nstatic void ace_fsm_tasklet(unsigned long data)\r\n{\r\nstruct ace_device *ace = (void *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ace->lock, flags);\r\nace->fsm_continue_flag = 1;\r\nwhile (ace->fsm_continue_flag)\r\nace_fsm_dostate(ace);\r\nspin_unlock_irqrestore(&ace->lock, flags);\r\n}\r\nstatic void ace_stall_timer(unsigned long data)\r\n{\r\nstruct ace_device *ace = (void *)data;\r\nunsigned long flags;\r\ndev_warn(ace->dev,\r\n"kicking stalled fsm; state=%i task=%i iter=%i dc=%i\n",\r\nace->fsm_state, ace->fsm_task, ace->fsm_iter_num,\r\nace->data_count);\r\nspin_lock_irqsave(&ace->lock, flags);\r\nmod_timer(&ace->stall_timer, jiffies + HZ);\r\nace->fsm_continue_flag = 1;\r\nwhile (ace->fsm_continue_flag)\r\nace_fsm_dostate(ace);\r\nspin_unlock_irqrestore(&ace->lock, flags);\r\n}\r\nstatic int ace_interrupt_checkstate(struct ace_device *ace)\r\n{\r\nu32 sreg = ace_in32(ace, ACE_STATUS);\r\nu16 creg = ace_in(ace, ACE_CTRL);\r\nif ((sreg & (ACE_STATUS_CFGERROR | ACE_STATUS_CFCERROR)) &&\r\n(creg & ACE_CTRL_ERRORIRQ)) {\r\ndev_err(ace->dev, "transfer failure\n");\r\nace_dump_regs(ace);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ace_interrupt(int irq, void *dev_id)\r\n{\r\nu16 creg;\r\nstruct ace_device *ace = dev_id;\r\nspin_lock(&ace->lock);\r\nace->in_irq = 1;\r\ncreg = ace_in(ace, ACE_CTRL);\r\nace_out(ace, ACE_CTRL, creg | ACE_CTRL_RESETIRQ);\r\nace_out(ace, ACE_CTRL, creg);\r\nif (ace_interrupt_checkstate(ace))\r\nace->data_result = -EIO;\r\nif (ace->fsm_task == 0) {\r\ndev_err(ace->dev,\r\n"spurious irq; stat=%.8x ctrl=%.8x cmd=%.4x\n",\r\nace_in32(ace, ACE_STATUS), ace_in32(ace, ACE_CTRL),\r\nace_in(ace, ACE_SECCNTCMD));\r\ndev_err(ace->dev, "fsm_task=%i fsm_state=%i data_count=%i\n",\r\nace->fsm_task, ace->fsm_state, ace->data_count);\r\n}\r\nace->fsm_continue_flag = 1;\r\nwhile (ace->fsm_continue_flag)\r\nace_fsm_dostate(ace);\r\nace->in_irq = 0;\r\nspin_unlock(&ace->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ace_request(struct request_queue * q)\r\n{\r\nstruct request *req;\r\nstruct ace_device *ace;\r\nreq = ace_get_next_request(q);\r\nif (req) {\r\nace = req->rq_disk->private_data;\r\ntasklet_schedule(&ace->fsm_tasklet);\r\n}\r\n}\r\nstatic unsigned int ace_check_events(struct gendisk *gd, unsigned int clearing)\r\n{\r\nstruct ace_device *ace = gd->private_data;\r\ndev_dbg(ace->dev, "ace_check_events(): %i\n", ace->media_change);\r\nreturn ace->media_change ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic int ace_revalidate_disk(struct gendisk *gd)\r\n{\r\nstruct ace_device *ace = gd->private_data;\r\nunsigned long flags;\r\ndev_dbg(ace->dev, "ace_revalidate_disk()\n");\r\nif (ace->media_change) {\r\ndev_dbg(ace->dev, "requesting cf id and scheduling tasklet\n");\r\nspin_lock_irqsave(&ace->lock, flags);\r\nace->id_req_count++;\r\nspin_unlock_irqrestore(&ace->lock, flags);\r\ntasklet_schedule(&ace->fsm_tasklet);\r\nwait_for_completion(&ace->id_completion);\r\n}\r\ndev_dbg(ace->dev, "revalidate complete\n");\r\nreturn ace->id_result;\r\n}\r\nstatic int ace_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct ace_device *ace = bdev->bd_disk->private_data;\r\nunsigned long flags;\r\ndev_dbg(ace->dev, "ace_open() users=%i\n", ace->users + 1);\r\nmutex_lock(&xsysace_mutex);\r\nspin_lock_irqsave(&ace->lock, flags);\r\nace->users++;\r\nspin_unlock_irqrestore(&ace->lock, flags);\r\ncheck_disk_change(bdev);\r\nmutex_unlock(&xsysace_mutex);\r\nreturn 0;\r\n}\r\nstatic void ace_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct ace_device *ace = disk->private_data;\r\nunsigned long flags;\r\nu16 val;\r\ndev_dbg(ace->dev, "ace_release() users=%i\n", ace->users - 1);\r\nmutex_lock(&xsysace_mutex);\r\nspin_lock_irqsave(&ace->lock, flags);\r\nace->users--;\r\nif (ace->users == 0) {\r\nval = ace_in(ace, ACE_CTRL);\r\nace_out(ace, ACE_CTRL, val & ~ACE_CTRL_LOCKREQ);\r\n}\r\nspin_unlock_irqrestore(&ace->lock, flags);\r\nmutex_unlock(&xsysace_mutex);\r\n}\r\nstatic int ace_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct ace_device *ace = bdev->bd_disk->private_data;\r\nu16 *cf_id = ace->cf_id;\r\ndev_dbg(ace->dev, "ace_getgeo()\n");\r\ngeo->heads = cf_id[ATA_ID_HEADS];\r\ngeo->sectors = cf_id[ATA_ID_SECTORS];\r\ngeo->cylinders = cf_id[ATA_ID_CYLS];\r\nreturn 0;\r\n}\r\nstatic int ace_setup(struct ace_device *ace)\r\n{\r\nu16 version;\r\nu16 val;\r\nint rc;\r\ndev_dbg(ace->dev, "ace_setup(ace=0x%p)\n", ace);\r\ndev_dbg(ace->dev, "physaddr=0x%llx irq=%i\n",\r\n(unsigned long long)ace->physaddr, ace->irq);\r\nspin_lock_init(&ace->lock);\r\ninit_completion(&ace->id_completion);\r\nace->baseaddr = ioremap(ace->physaddr, 0x80);\r\nif (!ace->baseaddr)\r\ngoto err_ioremap;\r\ntasklet_init(&ace->fsm_tasklet, ace_fsm_tasklet, (unsigned long)ace);\r\nsetup_timer(&ace->stall_timer, ace_stall_timer, (unsigned long)ace);\r\nace->queue = blk_init_queue(ace_request, &ace->lock);\r\nif (ace->queue == NULL)\r\ngoto err_blk_initq;\r\nblk_queue_logical_block_size(ace->queue, 512);\r\nace->gd = alloc_disk(ACE_NUM_MINORS);\r\nif (!ace->gd)\r\ngoto err_alloc_disk;\r\nace->gd->major = ace_major;\r\nace->gd->first_minor = ace->id * ACE_NUM_MINORS;\r\nace->gd->fops = &ace_fops;\r\nace->gd->queue = ace->queue;\r\nace->gd->private_data = ace;\r\nsnprintf(ace->gd->disk_name, 32, "xs%c", ace->id + 'a');\r\nif (ace->bus_width == ACE_BUS_WIDTH_16) {\r\nace_out_le16(ace, ACE_BUSMODE, 0x0101);\r\nif (ace_in_le16(ace, ACE_BUSMODE) == 0x0001)\r\nace->reg_ops = &ace_reg_le16_ops;\r\nelse\r\nace->reg_ops = &ace_reg_be16_ops;\r\n} else {\r\nace_out_8(ace, ACE_BUSMODE, 0x00);\r\nace->reg_ops = &ace_reg_8_ops;\r\n}\r\nversion = ace_in(ace, ACE_VERSION);\r\nif ((version == 0) || (version == 0xFFFF))\r\ngoto err_read;\r\nace_out(ace, ACE_CTRL, ACE_CTRL_FORCECFGMODE |\r\nACE_CTRL_DATABUFRDYIRQ | ACE_CTRL_ERRORIRQ);\r\nif (ace->irq) {\r\nrc = request_irq(ace->irq, ace_interrupt, 0, "systemace", ace);\r\nif (rc) {\r\ndev_err(ace->dev, "request_irq failed\n");\r\nace->irq = 0;\r\n}\r\n}\r\nval = ace_in(ace, ACE_CTRL);\r\nval |= ACE_CTRL_DATABUFRDYIRQ | ACE_CTRL_ERRORIRQ;\r\nace_out(ace, ACE_CTRL, val);\r\ndev_info(ace->dev, "Xilinx SystemACE revision %i.%i.%i\n",\r\n(version >> 12) & 0xf, (version >> 8) & 0x0f, version & 0xff);\r\ndev_dbg(ace->dev, "physaddr 0x%llx, mapped to 0x%p, irq=%i\n",\r\n(unsigned long long) ace->physaddr, ace->baseaddr, ace->irq);\r\nace->media_change = 1;\r\nace_revalidate_disk(ace->gd);\r\nadd_disk(ace->gd);\r\nreturn 0;\r\nerr_read:\r\nput_disk(ace->gd);\r\nerr_alloc_disk:\r\nblk_cleanup_queue(ace->queue);\r\nerr_blk_initq:\r\niounmap(ace->baseaddr);\r\nerr_ioremap:\r\ndev_info(ace->dev, "xsysace: error initializing device at 0x%llx\n",\r\n(unsigned long long) ace->physaddr);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ace_teardown(struct ace_device *ace)\r\n{\r\nif (ace->gd) {\r\ndel_gendisk(ace->gd);\r\nput_disk(ace->gd);\r\n}\r\nif (ace->queue)\r\nblk_cleanup_queue(ace->queue);\r\ntasklet_kill(&ace->fsm_tasklet);\r\nif (ace->irq)\r\nfree_irq(ace->irq, ace);\r\niounmap(ace->baseaddr);\r\n}\r\nstatic int ace_alloc(struct device *dev, int id, resource_size_t physaddr,\r\nint irq, int bus_width)\r\n{\r\nstruct ace_device *ace;\r\nint rc;\r\ndev_dbg(dev, "ace_alloc(%p)\n", dev);\r\nif (!physaddr) {\r\nrc = -ENODEV;\r\ngoto err_noreg;\r\n}\r\nace = kzalloc(sizeof(struct ace_device), GFP_KERNEL);\r\nif (!ace) {\r\nrc = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nace->dev = dev;\r\nace->id = id;\r\nace->physaddr = physaddr;\r\nace->irq = irq;\r\nace->bus_width = bus_width;\r\nrc = ace_setup(ace);\r\nif (rc)\r\ngoto err_setup;\r\ndev_set_drvdata(dev, ace);\r\nreturn 0;\r\nerr_setup:\r\ndev_set_drvdata(dev, NULL);\r\nkfree(ace);\r\nerr_alloc:\r\nerr_noreg:\r\ndev_err(dev, "could not initialize device, err=%i\n", rc);\r\nreturn rc;\r\n}\r\nstatic void ace_free(struct device *dev)\r\n{\r\nstruct ace_device *ace = dev_get_drvdata(dev);\r\ndev_dbg(dev, "ace_free(%p)\n", dev);\r\nif (ace) {\r\nace_teardown(ace);\r\ndev_set_drvdata(dev, NULL);\r\nkfree(ace);\r\n}\r\n}\r\nstatic int ace_probe(struct platform_device *dev)\r\n{\r\nresource_size_t physaddr = 0;\r\nint bus_width = ACE_BUS_WIDTH_16;\r\nu32 id = dev->id;\r\nint irq = 0;\r\nint i;\r\ndev_dbg(&dev->dev, "ace_probe(%p)\n", dev);\r\nif (of_property_read_u32(dev->dev.of_node, "port-number", &id))\r\nid = 0;\r\nif (of_find_property(dev->dev.of_node, "8-bit", NULL))\r\nbus_width = ACE_BUS_WIDTH_8;\r\nfor (i = 0; i < dev->num_resources; i++) {\r\nif (dev->resource[i].flags & IORESOURCE_MEM)\r\nphysaddr = dev->resource[i].start;\r\nif (dev->resource[i].flags & IORESOURCE_IRQ)\r\nirq = dev->resource[i].start;\r\n}\r\nreturn ace_alloc(&dev->dev, id, physaddr, irq, bus_width);\r\n}\r\nstatic int ace_remove(struct platform_device *dev)\r\n{\r\nace_free(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init ace_init(void)\r\n{\r\nint rc;\r\nace_major = register_blkdev(ace_major, "xsysace");\r\nif (ace_major <= 0) {\r\nrc = -ENOMEM;\r\ngoto err_blk;\r\n}\r\nrc = platform_driver_register(&ace_platform_driver);\r\nif (rc)\r\ngoto err_plat;\r\npr_info("Xilinx SystemACE device driver, major=%i\n", ace_major);\r\nreturn 0;\r\nerr_plat:\r\nunregister_blkdev(ace_major, "xsysace");\r\nerr_blk:\r\nprintk(KERN_ERR "xsysace: registration failed; err=%i\n", rc);\r\nreturn rc;\r\n}\r\nstatic void __exit ace_exit(void)\r\n{\r\npr_debug("Unregistering Xilinx SystemACE driver\n");\r\nplatform_driver_unregister(&ace_platform_driver);\r\nunregister_blkdev(ace_major, "xsysace");\r\n}
