static inline void uwb_dev_addr_init(struct uwb_dev_addr *addr)\r\n{\r\nmemset(&addr->data, 0xff, sizeof(addr->data));\r\n}\r\nstatic inline void uwb_mac_addr_init(struct uwb_mac_addr *addr)\r\n{\r\nmemset(&addr->data, 0xff, sizeof(addr->data));\r\n}\r\nstatic inline int uwb_dev_addr_bcast(const struct uwb_dev_addr *addr)\r\n{\r\nstatic const struct uwb_dev_addr bcast = { .data = { 0xff, 0xff } };\r\nreturn !uwb_dev_addr_cmp(addr, &bcast);\r\n}\r\nint uwb_notifs_register(struct uwb_rc *rc, struct uwb_notifs_handler *new)\r\n{\r\nif (mutex_lock_interruptible(&rc->notifs_chain.mutex))\r\nreturn -ERESTARTSYS;\r\nlist_add(&new->list_node, &rc->notifs_chain.list);\r\nmutex_unlock(&rc->notifs_chain.mutex);\r\nreturn 0;\r\n}\r\nint uwb_notifs_deregister(struct uwb_rc *rc, struct uwb_notifs_handler *entry)\r\n{\r\nif (mutex_lock_interruptible(&rc->notifs_chain.mutex))\r\nreturn -ERESTARTSYS;\r\nlist_del(&entry->list_node);\r\nmutex_unlock(&rc->notifs_chain.mutex);\r\nreturn 0;\r\n}\r\nvoid uwb_notify(struct uwb_rc *rc, struct uwb_dev *uwb_dev, enum uwb_notifs event)\r\n{\r\nstruct uwb_notifs_handler *handler;\r\nif (mutex_lock_interruptible(&rc->notifs_chain.mutex))\r\nreturn;\r\nif (!list_empty(&rc->notifs_chain.list)) {\r\nlist_for_each_entry(handler, &rc->notifs_chain.list, list_node) {\r\nhandler->cb(handler->data, uwb_dev, event);\r\n}\r\n}\r\nmutex_unlock(&rc->notifs_chain.mutex);\r\n}\r\nstatic void uwb_dev_sys_release(struct device *dev)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nuwb_bce_put(uwb_dev->bce);\r\nmemset(uwb_dev, 0x69, sizeof(*uwb_dev));\r\nkfree(uwb_dev);\r\n}\r\nvoid uwb_dev_init(struct uwb_dev *uwb_dev)\r\n{\r\nmutex_init(&uwb_dev->mutex);\r\ndevice_initialize(&uwb_dev->dev);\r\nuwb_dev->dev.release = uwb_dev_sys_release;\r\nuwb_dev_addr_init(&uwb_dev->dev_addr);\r\nuwb_mac_addr_init(&uwb_dev->mac_addr);\r\nbitmap_fill(uwb_dev->streams, UWB_NUM_GLOBAL_STREAMS);\r\n}\r\nstatic ssize_t uwb_dev_EUI_48_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nchar addr[UWB_ADDR_STRSIZE];\r\nuwb_mac_addr_print(addr, sizeof(addr), &uwb_dev->mac_addr);\r\nreturn sprintf(buf, "%s\n", addr);\r\n}\r\nstatic ssize_t uwb_dev_DevAddr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nchar addr[UWB_ADDR_STRSIZE];\r\nuwb_dev_addr_print(addr, sizeof(addr), &uwb_dev->dev_addr);\r\nreturn sprintf(buf, "%s\n", addr);\r\n}\r\nstatic ssize_t uwb_dev_BPST_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nstruct uwb_beca_e *bce;\r\nstruct uwb_beacon_frame *bf;\r\nu16 bpst;\r\nbce = uwb_dev->bce;\r\nmutex_lock(&bce->mutex);\r\nbf = (struct uwb_beacon_frame *)bce->be->BeaconInfo;\r\nbpst = bce->be->wBPSTOffset\r\n- (u16)(bf->Beacon_Slot_Number * UWB_BEACON_SLOT_LENGTH_US);\r\nmutex_unlock(&bce->mutex);\r\nreturn sprintf(buf, "%d\n", bpst);\r\n}\r\nstatic ssize_t uwb_dev_IEs_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nreturn uwb_bce_print_IEs(uwb_dev, uwb_dev->bce, buf, PAGE_SIZE);\r\n}\r\nstatic ssize_t uwb_dev_LQE_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nstruct uwb_beca_e *bce = uwb_dev->bce;\r\nsize_t result;\r\nmutex_lock(&bce->mutex);\r\nresult = stats_show(&uwb_dev->bce->lqe_stats, buf);\r\nmutex_unlock(&bce->mutex);\r\nreturn result;\r\n}\r\nstatic ssize_t uwb_dev_LQE_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nstruct uwb_beca_e *bce = uwb_dev->bce;\r\nssize_t result;\r\nmutex_lock(&bce->mutex);\r\nresult = stats_store(&uwb_dev->bce->lqe_stats, buf, size);\r\nmutex_unlock(&bce->mutex);\r\nreturn result;\r\n}\r\nstatic ssize_t uwb_dev_RSSI_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nstruct uwb_beca_e *bce = uwb_dev->bce;\r\nsize_t result;\r\nmutex_lock(&bce->mutex);\r\nresult = stats_show(&uwb_dev->bce->rssi_stats, buf);\r\nmutex_unlock(&bce->mutex);\r\nreturn result;\r\n}\r\nstatic ssize_t uwb_dev_RSSI_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nstruct uwb_beca_e *bce = uwb_dev->bce;\r\nssize_t result;\r\nmutex_lock(&bce->mutex);\r\nresult = stats_store(&uwb_dev->bce->rssi_stats, buf, size);\r\nmutex_unlock(&bce->mutex);\r\nreturn result;\r\n}\r\nstatic int __uwb_dev_sys_add(struct uwb_dev *uwb_dev, struct device *parent_dev)\r\n{\r\nstruct device *dev;\r\ndev = &uwb_dev->dev;\r\nif (&uwb_dev->rc->uwb_dev != uwb_dev)\r\ndev->groups = groups;\r\ndev->parent = parent_dev;\r\ndev_set_drvdata(dev, uwb_dev);\r\nreturn device_add(dev);\r\n}\r\nstatic void __uwb_dev_sys_rm(struct uwb_dev *uwb_dev)\r\n{\r\ndev_set_drvdata(&uwb_dev->dev, NULL);\r\ndevice_del(&uwb_dev->dev);\r\n}\r\nint uwb_dev_add(struct uwb_dev *uwb_dev, struct device *parent_dev,\r\nstruct uwb_rc *parent_rc)\r\n{\r\nint result;\r\nstruct device *dev;\r\nBUG_ON(uwb_dev == NULL);\r\nBUG_ON(parent_dev == NULL);\r\nBUG_ON(parent_rc == NULL);\r\nmutex_lock(&uwb_dev->mutex);\r\ndev = &uwb_dev->dev;\r\nuwb_dev->rc = parent_rc;\r\nresult = __uwb_dev_sys_add(uwb_dev, parent_dev);\r\nif (result < 0)\r\nprintk(KERN_ERR "UWB: unable to register dev %s with sysfs: %d\n",\r\ndev_name(dev), result);\r\nmutex_unlock(&uwb_dev->mutex);\r\nreturn result;\r\n}\r\nvoid uwb_dev_rm(struct uwb_dev *uwb_dev)\r\n{\r\nmutex_lock(&uwb_dev->mutex);\r\n__uwb_dev_sys_rm(uwb_dev);\r\nmutex_unlock(&uwb_dev->mutex);\r\n}\r\nstatic\r\nint __uwb_dev_try_get(struct device *dev, void *__target_uwb_dev)\r\n{\r\nstruct uwb_dev *target_uwb_dev = __target_uwb_dev;\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nif (uwb_dev == target_uwb_dev) {\r\nuwb_dev_get(uwb_dev);\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstruct uwb_dev *uwb_dev_try_get(struct uwb_rc *rc, struct uwb_dev *uwb_dev)\r\n{\r\nif (uwb_dev_for_each(rc, __uwb_dev_try_get, uwb_dev))\r\nreturn uwb_dev;\r\nelse\r\nreturn NULL;\r\n}\r\nint __uwb_dev_offair(struct uwb_dev *uwb_dev, struct uwb_rc *rc)\r\n{\r\nstruct device *dev = &uwb_dev->dev;\r\nchar macbuf[UWB_ADDR_STRSIZE], devbuf[UWB_ADDR_STRSIZE];\r\nuwb_mac_addr_print(macbuf, sizeof(macbuf), &uwb_dev->mac_addr);\r\nuwb_dev_addr_print(devbuf, sizeof(devbuf), &uwb_dev->dev_addr);\r\ndev_info(dev, "uwb device (mac %s dev %s) disconnected from %s %s\n",\r\nmacbuf, devbuf,\r\nrc ? rc->uwb_dev.dev.parent->bus->name : "n/a",\r\nrc ? dev_name(rc->uwb_dev.dev.parent) : "");\r\nuwb_dev_rm(uwb_dev);\r\nlist_del(&uwb_dev->bce->node);\r\nuwb_bce_put(uwb_dev->bce);\r\nuwb_dev_put(uwb_dev);\r\nreturn 0;\r\n}\r\nvoid uwbd_dev_offair(struct uwb_beca_e *bce)\r\n{\r\nstruct uwb_dev *uwb_dev;\r\nuwb_dev = bce->uwb_dev;\r\nif (uwb_dev) {\r\nuwb_notify(uwb_dev->rc, uwb_dev, UWB_NOTIF_OFFAIR);\r\n__uwb_dev_offair(uwb_dev, uwb_dev->rc);\r\n}\r\n}\r\nvoid uwbd_dev_onair(struct uwb_rc *rc, struct uwb_beca_e *bce)\r\n{\r\nint result;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_dev *uwb_dev;\r\nchar macbuf[UWB_ADDR_STRSIZE], devbuf[UWB_ADDR_STRSIZE];\r\nuwb_mac_addr_print(macbuf, sizeof(macbuf), bce->mac_addr);\r\nuwb_dev_addr_print(devbuf, sizeof(devbuf), &bce->dev_addr);\r\nuwb_dev = kzalloc(sizeof(struct uwb_dev), GFP_KERNEL);\r\nif (uwb_dev == NULL) {\r\ndev_err(dev, "new device %s: Cannot allocate memory\n",\r\nmacbuf);\r\nreturn;\r\n}\r\nuwb_dev_init(uwb_dev);\r\nuwb_dev->mac_addr = *bce->mac_addr;\r\nuwb_dev->dev_addr = bce->dev_addr;\r\ndev_set_name(&uwb_dev->dev, "%s", macbuf);\r\nresult = uwb_dev_add(uwb_dev, &rc->uwb_dev.dev, rc);\r\nif (result < 0) {\r\ndev_err(dev, "new device %s: cannot instantiate device\n",\r\nmacbuf);\r\ngoto error_dev_add;\r\n}\r\nbce->uwb_dev = uwb_dev;\r\nuwb_dev->bce = bce;\r\nuwb_bce_get(bce);\r\ndev_info(dev, "uwb device (mac %s dev %s) connected to %s %s\n",\r\nmacbuf, devbuf, rc->uwb_dev.dev.parent->bus->name,\r\ndev_name(rc->uwb_dev.dev.parent));\r\nuwb_notify(rc, uwb_dev, UWB_NOTIF_ONAIR);\r\nreturn;\r\nerror_dev_add:\r\nkfree(uwb_dev);\r\nreturn;\r\n}\r\nint uwb_dev_for_each(struct uwb_rc *rc, uwb_dev_for_each_f function, void *priv)\r\n{\r\nreturn device_for_each_child(&rc->uwb_dev.dev, priv, function);\r\n}
