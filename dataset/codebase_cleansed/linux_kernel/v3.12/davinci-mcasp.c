static inline void mcasp_set_bits(void __iomem *reg, u32 val)\r\n{\r\n__raw_writel(__raw_readl(reg) | val, reg);\r\n}\r\nstatic inline void mcasp_clr_bits(void __iomem *reg, u32 val)\r\n{\r\n__raw_writel((__raw_readl(reg) & ~(val)), reg);\r\n}\r\nstatic inline void mcasp_mod_bits(void __iomem *reg, u32 val, u32 mask)\r\n{\r\n__raw_writel((__raw_readl(reg) & ~mask) | val, reg);\r\n}\r\nstatic inline void mcasp_set_reg(void __iomem *reg, u32 val)\r\n{\r\n__raw_writel(val, reg);\r\n}\r\nstatic inline u32 mcasp_get_reg(void __iomem *reg)\r\n{\r\nreturn (unsigned int)__raw_readl(reg);\r\n}\r\nstatic inline void mcasp_set_ctl_reg(void __iomem *regs, u32 val)\r\n{\r\nint i = 0;\r\nmcasp_set_bits(regs, val);\r\nfor (i = 0; i < 1000; i++) {\r\nif ((mcasp_get_reg(regs) & val) == val)\r\nbreak;\r\n}\r\nif (i == 1000 && ((mcasp_get_reg(regs) & val) != val))\r\nprintk(KERN_ERR "GBLCTL write error\n");\r\n}\r\nstatic void mcasp_start_rx(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);\r\n}\r\nstatic void mcasp_start_tx(struct davinci_audio_dev *dev)\r\n{\r\nu8 offset = 0, i;\r\nu32 cnt;\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSERCLR);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSMRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);\r\nfor (i = 0; i < dev->num_serializer; i++) {\r\nif (dev->serial_dir[i] == TX_MODE) {\r\noffset = i;\r\nbreak;\r\n}\r\n}\r\ncnt = 0;\r\nwhile (!(mcasp_get_reg(dev->base + DAVINCI_MCASP_XRSRCTL_REG(offset)) &\r\nTXSTATE) && (cnt < 100000))\r\ncnt++;\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);\r\n}\r\nstatic void davinci_mcasp_start(struct davinci_audio_dev *dev, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (dev->txnumevt) {\r\nswitch (dev->version) {\r\ncase MCASP_VERSION_3:\r\nmcasp_clr_bits(dev->base + MCASP_VER3_WFIFOCTL,\r\nFIFO_ENABLE);\r\nmcasp_set_bits(dev->base + MCASP_VER3_WFIFOCTL,\r\nFIFO_ENABLE);\r\nbreak;\r\ndefault:\r\nmcasp_clr_bits(dev->base +\r\nDAVINCI_MCASP_WFIFOCTL, FIFO_ENABLE);\r\nmcasp_set_bits(dev->base +\r\nDAVINCI_MCASP_WFIFOCTL, FIFO_ENABLE);\r\n}\r\n}\r\nmcasp_start_tx(dev);\r\n} else {\r\nif (dev->rxnumevt) {\r\nswitch (dev->version) {\r\ncase MCASP_VERSION_3:\r\nmcasp_clr_bits(dev->base + MCASP_VER3_RFIFOCTL,\r\nFIFO_ENABLE);\r\nmcasp_set_bits(dev->base + MCASP_VER3_RFIFOCTL,\r\nFIFO_ENABLE);\r\nbreak;\r\ndefault:\r\nmcasp_clr_bits(dev->base +\r\nDAVINCI_MCASP_RFIFOCTL, FIFO_ENABLE);\r\nmcasp_set_bits(dev->base +\r\nDAVINCI_MCASP_RFIFOCTL, FIFO_ENABLE);\r\n}\r\n}\r\nmcasp_start_rx(dev);\r\n}\r\n}\r\nstatic void mcasp_stop_rx(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, 0);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\r\n}\r\nstatic void mcasp_stop_tx(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, 0);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\r\n}\r\nstatic void davinci_mcasp_stop(struct davinci_audio_dev *dev, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (dev->txnumevt) {\r\nswitch (dev->version) {\r\ncase MCASP_VERSION_3:\r\nmcasp_clr_bits(dev->base + MCASP_VER3_WFIFOCTL,\r\nFIFO_ENABLE);\r\nbreak;\r\ndefault:\r\nmcasp_clr_bits(dev->base +\r\nDAVINCI_MCASP_WFIFOCTL, FIFO_ENABLE);\r\n}\r\n}\r\nmcasp_stop_tx(dev);\r\n} else {\r\nif (dev->rxnumevt) {\r\nswitch (dev->version) {\r\ncase MCASP_VERSION_3:\r\nmcasp_clr_bits(dev->base + MCASP_VER3_RFIFOCTL,\r\nFIFO_ENABLE);\r\nbreak;\r\ndefault:\r\nmcasp_clr_bits(dev->base +\r\nDAVINCI_MCASP_RFIFOCTL, FIFO_ENABLE);\r\n}\r\n}\r\nmcasp_stop_rx(dev);\r\n}\r\n}\r\nstatic int davinci_mcasp_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nvoid __iomem *base = dev->base;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ncase SND_SOC_DAIFMT_AC97:\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\nbreak;\r\ndefault:\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, FSXDLY(1));\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, FSRDLY(1));\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nACLKX | ACLKR);\r\nmcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nAFSX | AFSR);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nACLKX | ACLKR);\r\nmcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nAFSX | AFSR);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nACLKX | AHCLKX | AFSX | ACLKR | AHCLKR | AFSR);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nswitch (div_id) {\r\ncase 0:\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,\r\nAHCLKXDIV(div - 1), AHCLKXDIV_MASK);\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,\r\nAHCLKRDIV(div - 1), AHCLKRDIV_MASK);\r\nbreak;\r\ncase 1:\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,\r\nACLKXDIV(div - 1), ACLKXDIV_MASK);\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_ACLKRCTL_REG,\r\nACLKRDIV(div - 1), ACLKRDIV_MASK);\r\nbreak;\r\ncase 2:\r\ndev->bclk_lrclk_ratio = div;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nif (dir == SND_SOC_CLOCK_OUT) {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXE);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRE);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AHCLKX);\r\n} else {\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXE);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRE);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AHCLKX);\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_config_channel_size(struct davinci_audio_dev *dev,\r\nint word_length)\r\n{\r\nu32 fmt;\r\nu32 tx_rotate = (word_length / 4) & 0x7;\r\nu32 rx_rotate = (32 - word_length) / 4;\r\nu32 mask = (1ULL << word_length) - 1;\r\nif (dev->bclk_lrclk_ratio)\r\nword_length = dev->bclk_lrclk_ratio / dev->tdm_slots;\r\nfmt = (word_length >> 1) - 1;\r\nif (dev->op_mode != DAVINCI_MCASP_DIT_MODE) {\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG,\r\nRXSSZ(fmt), RXSSZ(0x0F));\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,\r\nTXSSZ(fmt), TXSSZ(0x0F));\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,\r\nTXROT(tx_rotate), TXROT(7));\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG,\r\nRXROT(rx_rotate), RXROT(7));\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXMASK_REG,\r\nmask);\r\n}\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, mask);\r\nreturn 0;\r\n}\r\nstatic int davinci_hw_common_param(struct davinci_audio_dev *dev, int stream,\r\nint channels)\r\n{\r\nint i;\r\nu8 tx_ser = 0;\r\nu8 rx_ser = 0;\r\nu8 ser;\r\nu8 slots = dev->tdm_slots;\r\nu8 max_active_serializers = (channels + slots - 1) / slots;\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_PWREMUMGT_REG, MCASP_SOFT);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_PFUNC_REG, 0x00000000);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_XEVTCTL_REG,\r\nTXDATADMADIS);\r\n} else {\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_REVTCTL_REG,\r\nRXDATADMADIS);\r\n}\r\nfor (i = 0; i < dev->num_serializer; i++) {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_XRSRCTL_REG(i),\r\ndev->serial_dir[i]);\r\nif (dev->serial_dir[i] == TX_MODE &&\r\ntx_ser < max_active_serializers) {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG,\r\nAXR(i));\r\ntx_ser++;\r\n} else if (dev->serial_dir[i] == RX_MODE &&\r\nrx_ser < max_active_serializers) {\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_PDIR_REG,\r\nAXR(i));\r\nrx_ser++;\r\n} else {\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_XRSRCTL_REG(i),\r\nSRMOD_INACTIVE, SRMOD_MASK);\r\n}\r\n}\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nser = tx_ser;\r\nelse\r\nser = rx_ser;\r\nif (ser < max_active_serializers) {\r\ndev_warn(dev->dev, "stream has more channels (%d) than are "\r\n"enabled in mcasp (%d)\n", channels, ser * slots);\r\nreturn -EINVAL;\r\n}\r\nif (dev->txnumevt && stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (dev->txnumevt * tx_ser > 64)\r\ndev->txnumevt = 1;\r\nswitch (dev->version) {\r\ncase MCASP_VERSION_3:\r\nmcasp_mod_bits(dev->base + MCASP_VER3_WFIFOCTL, tx_ser,\r\nNUMDMA_MASK);\r\nmcasp_mod_bits(dev->base + MCASP_VER3_WFIFOCTL,\r\n((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);\r\nbreak;\r\ndefault:\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,\r\ntx_ser, NUMDMA_MASK);\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,\r\n((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);\r\n}\r\n}\r\nif (dev->rxnumevt && stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nif (dev->rxnumevt * rx_ser > 64)\r\ndev->rxnumevt = 1;\r\nswitch (dev->version) {\r\ncase MCASP_VERSION_3:\r\nmcasp_mod_bits(dev->base + MCASP_VER3_RFIFOCTL, rx_ser,\r\nNUMDMA_MASK);\r\nmcasp_mod_bits(dev->base + MCASP_VER3_RFIFOCTL,\r\n((dev->rxnumevt * rx_ser) << 8), NUMEVT_MASK);\r\nbreak;\r\ndefault:\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,\r\nrx_ser, NUMDMA_MASK);\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,\r\n((dev->rxnumevt * rx_ser) << 8), NUMEVT_MASK);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void davinci_hw_param(struct davinci_audio_dev *dev, int stream)\r\n{\r\nint i, active_slots;\r\nu32 mask = 0;\r\nactive_slots = (dev->tdm_slots > 31) ? 32 : dev->tdm_slots;\r\nfor (i = 0; i < active_slots; i++)\r\nmask |= (1 << i);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, mask);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD);\r\nif ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,\r\nFSXMOD(dev->tdm_slots), FSXMOD(0x1FF));\r\nelse\r\nprintk(KERN_ERR "playback tdm slot %d not supported\n",\r\ndev->tdm_slots);\r\n} else {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXORD);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXTDM_REG, mask);\r\nif ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,\r\nFSRMOD(dev->tdm_slots), FSRMOD(0x1FF));\r\nelse\r\nprintk(KERN_ERR "capture tdm slot %d not supported\n",\r\ndev->tdm_slots);\r\n}\r\n}\r\nstatic void davinci_hw_dit_param(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,\r\nTXROT(6) | TXSSZ(15));\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXFMCTL_REG,\r\nAFSXE | FSXMOD(0x180));\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, 0xFFFFFFFF);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,\r\nACLKXE | TX_ASYNC);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(3));\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXDITCTL_REG, DITEN);\r\n}\r\nstatic int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct davinci_pcm_dma_params *dma_params =\r\n&dev->dma_params[substream->stream];\r\nint word_length;\r\nu8 fifo_level;\r\nu8 slots = dev->tdm_slots;\r\nu8 active_serializers;\r\nint channels;\r\nstruct snd_interval *pcm_channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nchannels = pcm_channels->min;\r\nactive_serializers = (channels + slots - 1) / slots;\r\nif (davinci_hw_common_param(dev, substream->stream, channels) == -EINVAL)\r\nreturn -EINVAL;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfifo_level = dev->txnumevt * active_serializers;\r\nelse\r\nfifo_level = dev->rxnumevt * active_serializers;\r\nif (dev->op_mode == DAVINCI_MCASP_DIT_MODE)\r\ndavinci_hw_dit_param(dev);\r\nelse\r\ndavinci_hw_param(dev, substream->stream);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\ncase SNDRV_PCM_FORMAT_S8:\r\ndma_params->data_type = 1;\r\nword_length = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U16_LE:\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndma_params->data_type = 2;\r\nword_length = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U24_3LE:\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\ndma_params->data_type = 3;\r\nword_length = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U24_LE:\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_U32_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndma_params->data_type = 4;\r\nword_length = 32;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "davinci-mcasp: unsupported PCM format");\r\nreturn -EINVAL;\r\n}\r\nif (dev->version == MCASP_VERSION_2 && !fifo_level)\r\ndma_params->acnt = 4;\r\nelse\r\ndma_params->acnt = dma_params->data_type;\r\ndma_params->fifo_level = fifo_level;\r\ndavinci_config_channel_size(dev, word_length);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = pm_runtime_get_sync(dev->dev);\r\nif (IS_ERR_VALUE(ret))\r\ndev_err(dev->dev, "pm_runtime_get_sync() failed\n");\r\ndavinci_mcasp_start(dev, substream->stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndavinci_mcasp_stop(dev, substream->stream);\r\nret = pm_runtime_put_sync(dev->dev);\r\nif (IS_ERR_VALUE(ret))\r\ndev_err(dev->dev, "pm_runtime_put_sync() failed\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndavinci_mcasp_stop(dev, substream->stream);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_set_dma_data(dai, substream, dev->dma_params);\r\nreturn 0;\r\n}\r\nstatic struct snd_platform_data *davinci_mcasp_set_pdata_from_of(\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct snd_platform_data *pdata = NULL;\r\nconst struct of_device_id *match =\r\nof_match_device(mcasp_dt_ids, &pdev->dev);\r\nconst u32 *of_serial_dir32;\r\nu8 *of_serial_dir;\r\nu32 val;\r\nint i, ret = 0;\r\nif (pdev->dev.platform_data) {\r\npdata = pdev->dev.platform_data;\r\nreturn pdata;\r\n} else if (match) {\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\nret = -ENOMEM;\r\ngoto nodata;\r\n}\r\n} else {\r\nret = -EINVAL;\r\ngoto nodata;\r\n}\r\nif (match->data)\r\npdata->version = (u8)((int)match->data);\r\nret = of_property_read_u32(np, "op-mode", &val);\r\nif (ret >= 0)\r\npdata->op_mode = val;\r\nret = of_property_read_u32(np, "tdm-slots", &val);\r\nif (ret >= 0) {\r\nif (val < 2 || val > 32) {\r\ndev_err(&pdev->dev,\r\n"tdm-slots must be in rage [2-32]\n");\r\nret = -EINVAL;\r\ngoto nodata;\r\n}\r\npdata->tdm_slots = val;\r\n}\r\nret = of_property_read_u32(np, "num-serializer", &val);\r\nif (ret >= 0)\r\npdata->num_serializer = val;\r\nof_serial_dir32 = of_get_property(np, "serial-dir", &val);\r\nval /= sizeof(u32);\r\nif (val != pdata->num_serializer) {\r\ndev_err(&pdev->dev,\r\n"num-serializer(%d) != serial-dir size(%d)\n",\r\npdata->num_serializer, val);\r\nret = -EINVAL;\r\ngoto nodata;\r\n}\r\nif (of_serial_dir32) {\r\nof_serial_dir = devm_kzalloc(&pdev->dev,\r\n(sizeof(*of_serial_dir) * val),\r\nGFP_KERNEL);\r\nif (!of_serial_dir) {\r\nret = -ENOMEM;\r\ngoto nodata;\r\n}\r\nfor (i = 0; i < pdata->num_serializer; i++)\r\nof_serial_dir[i] = be32_to_cpup(&of_serial_dir32[i]);\r\npdata->serial_dir = of_serial_dir;\r\n}\r\nret = of_property_read_u32(np, "tx-num-evt", &val);\r\nif (ret >= 0)\r\npdata->txnumevt = val;\r\nret = of_property_read_u32(np, "rx-num-evt", &val);\r\nif (ret >= 0)\r\npdata->rxnumevt = val;\r\nret = of_property_read_u32(np, "sram-size-playback", &val);\r\nif (ret >= 0)\r\npdata->sram_size_playback = val;\r\nret = of_property_read_u32(np, "sram-size-capture", &val);\r\nif (ret >= 0)\r\npdata->sram_size_capture = val;\r\nreturn pdata;\r\nnodata:\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error populating platform data, err %d\n",\r\nret);\r\npdata = NULL;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int davinci_mcasp_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_pcm_dma_params *dma_data;\r\nstruct resource *mem, *ioarea, *res;\r\nstruct snd_platform_data *pdata;\r\nstruct davinci_audio_dev *dev;\r\nint ret;\r\nif (!pdev->dev.platform_data && !pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "No platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\ndev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_audio_dev),\r\nGFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\npdata = davinci_mcasp_set_pdata_from_of(pdev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\nioarea = devm_request_mem_region(&pdev->dev, mem->start,\r\nresource_size(mem), pdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "Audio region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (IS_ERR_VALUE(ret)) {\r\ndev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");\r\nreturn ret;\r\n}\r\ndev->base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!dev->base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_release_clk;\r\n}\r\ndev->op_mode = pdata->op_mode;\r\ndev->tdm_slots = pdata->tdm_slots;\r\ndev->num_serializer = pdata->num_serializer;\r\ndev->serial_dir = pdata->serial_dir;\r\ndev->version = pdata->version;\r\ndev->txnumevt = pdata->txnumevt;\r\ndev->rxnumevt = pdata->rxnumevt;\r\ndev->dev = &pdev->dev;\r\ndma_data = &dev->dma_params[SNDRV_PCM_STREAM_PLAYBACK];\r\ndma_data->asp_chan_q = pdata->asp_chan_q;\r\ndma_data->ram_chan_q = pdata->ram_chan_q;\r\ndma_data->sram_pool = pdata->sram_pool;\r\ndma_data->sram_size = pdata->sram_size_playback;\r\ndma_data->dma_addr = (dma_addr_t) (pdata->tx_dma_offset +\r\nmem->start);\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no DMA resource\n");\r\nret = -ENODEV;\r\ngoto err_release_clk;\r\n}\r\ndma_data->channel = res->start;\r\ndma_data = &dev->dma_params[SNDRV_PCM_STREAM_CAPTURE];\r\ndma_data->asp_chan_q = pdata->asp_chan_q;\r\ndma_data->ram_chan_q = pdata->ram_chan_q;\r\ndma_data->sram_pool = pdata->sram_pool;\r\ndma_data->sram_size = pdata->sram_size_capture;\r\ndma_data->dma_addr = (dma_addr_t)(pdata->rx_dma_offset +\r\nmem->start);\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no DMA resource\n");\r\nret = -ENODEV;\r\ngoto err_release_clk;\r\n}\r\ndma_data->channel = res->start;\r\ndev_set_drvdata(&pdev->dev, dev);\r\nret = snd_soc_register_component(&pdev->dev, &davinci_mcasp_component,\r\n&davinci_mcasp_dai[pdata->op_mode], 1);\r\nif (ret != 0)\r\ngoto err_release_clk;\r\nret = davinci_soc_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "register PCM failed: %d\n", ret);\r\ngoto err_unregister_component;\r\n}\r\nreturn 0;\r\nerr_unregister_component:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr_release_clk:\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_component(&pdev->dev);\r\ndavinci_soc_platform_unregister(&pdev->dev);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
