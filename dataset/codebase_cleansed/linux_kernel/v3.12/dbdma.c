static dbdev_tab_t *find_dbdev_id(u32 id)\r\n{\r\nint i;\r\ndbdev_tab_t *p;\r\nfor (i = 0; i < DBDEV_TAB_SIZE; ++i) {\r\np = &dbdev_tab[i];\r\nif (p->dev_id == id)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp)\r\n{\r\nreturn phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\n}\r\nu32 au1xxx_ddma_add_device(dbdev_tab_t *dev)\r\n{\r\nu32 ret = 0;\r\ndbdev_tab_t *p;\r\nstatic u16 new_id = 0x1000;\r\np = find_dbdev_id(~0);\r\nif (NULL != p) {\r\nmemcpy(p, dev, sizeof(dbdev_tab_t));\r\np->dev_id = DSCR_DEV2CUSTOM_ID(new_id, dev->dev_id);\r\nret = p->dev_id;\r\nnew_id++;\r\n#if 0\r\nprintk(KERN_DEBUG "add_device: id:%x flags:%x padd:%x\n",\r\np->dev_id, p->dev_flags, p->dev_physaddr);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nvoid au1xxx_ddma_del_device(u32 devid)\r\n{\r\ndbdev_tab_t *p = find_dbdev_id(devid);\r\nif (p != NULL) {\r\nmemset(p, 0, sizeof(dbdev_tab_t));\r\np->dev_id = ~0;\r\n}\r\n}\r\nu32 au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,\r\nvoid (*callback)(int, void *), void *callparam)\r\n{\r\nunsigned long flags;\r\nu32 used, chan;\r\nu32 dcp;\r\nint i;\r\ndbdev_tab_t *stp, *dtp;\r\nchan_tab_t *ctp;\r\nau1x_dma_chan_t *cp;\r\nif (!dbdma_initialized)\r\nreturn 0;\r\nstp = find_dbdev_id(srcid);\r\nif (stp == NULL)\r\nreturn 0;\r\ndtp = find_dbdev_id(destid);\r\nif (dtp == NULL)\r\nreturn 0;\r\nused = 0;\r\nspin_lock_irqsave(&au1xxx_dbdma_spin_lock, flags);\r\nif (!(stp->dev_flags & DEV_FLAGS_INUSE) ||\r\n(stp->dev_flags & DEV_FLAGS_ANYUSE)) {\r\nstp->dev_flags |= DEV_FLAGS_INUSE;\r\nif (!(dtp->dev_flags & DEV_FLAGS_INUSE) ||\r\n(dtp->dev_flags & DEV_FLAGS_ANYUSE)) {\r\ndtp->dev_flags |= DEV_FLAGS_INUSE;\r\n} else {\r\nstp->dev_flags &= ~DEV_FLAGS_INUSE;\r\nused++;\r\n}\r\n} else\r\nused++;\r\nspin_unlock_irqrestore(&au1xxx_dbdma_spin_lock, flags);\r\nif (used)\r\nreturn 0;\r\nctp = NULL;\r\nchan = 0;\r\nspin_lock_irqsave(&au1xxx_dbdma_spin_lock, flags);\r\nfor (i = 0; i < NUM_DBDMA_CHANS; i++)\r\nif (chan_tab_ptr[i] == NULL) {\r\nctp = kmalloc(sizeof(chan_tab_t), GFP_ATOMIC);\r\nchan_tab_ptr[i] = ctp;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&au1xxx_dbdma_spin_lock, flags);\r\nif (ctp != NULL) {\r\nmemset(ctp, 0, sizeof(chan_tab_t));\r\nctp->chan_index = chan = i;\r\ndcp = KSEG1ADDR(AU1550_DBDMA_PHYS_ADDR);\r\ndcp += (0x0100 * chan);\r\nctp->chan_ptr = (au1x_dma_chan_t *)dcp;\r\ncp = (au1x_dma_chan_t *)dcp;\r\nctp->chan_src = stp;\r\nctp->chan_dest = dtp;\r\nctp->chan_callback = callback;\r\nctp->chan_callparam = callparam;\r\ni = 0;\r\nif (stp->dev_intlevel)\r\ni |= DDMA_CFG_SED;\r\nif (stp->dev_intpolarity)\r\ni |= DDMA_CFG_SP;\r\nif (dtp->dev_intlevel)\r\ni |= DDMA_CFG_DED;\r\nif (dtp->dev_intpolarity)\r\ni |= DDMA_CFG_DP;\r\nif ((stp->dev_flags & DEV_FLAGS_SYNC) ||\r\n(dtp->dev_flags & DEV_FLAGS_SYNC))\r\ni |= DDMA_CFG_SYNC;\r\ncp->ddma_cfg = i;\r\nau_sync();\r\nreturn (u32)(&chan_tab_ptr[chan]);\r\n}\r\nstp->dev_flags &= ~DEV_FLAGS_INUSE;\r\ndtp->dev_flags &= ~DEV_FLAGS_INUSE;\r\nreturn 0;\r\n}\r\nu32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits)\r\n{\r\nu32 rv;\r\nchan_tab_t *ctp;\r\ndbdev_tab_t *stp, *dtp;\r\nctp = *((chan_tab_t **)chanid);\r\nstp = ctp->chan_src;\r\ndtp = ctp->chan_dest;\r\nrv = 0;\r\nif (stp->dev_flags & DEV_FLAGS_IN) {\r\nrv = stp->dev_devwidth;\r\nstp->dev_devwidth = bits;\r\n}\r\nif (dtp->dev_flags & DEV_FLAGS_OUT) {\r\nrv = dtp->dev_devwidth;\r\ndtp->dev_devwidth = bits;\r\n}\r\nreturn rv;\r\n}\r\nu32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries)\r\n{\r\nint i;\r\nu32 desc_base, srcid, destid;\r\nu32 cmd0, cmd1, src1, dest1;\r\nu32 src0, dest0;\r\nchan_tab_t *ctp;\r\ndbdev_tab_t *stp, *dtp;\r\nau1x_ddma_desc_t *dp;\r\nctp = *((chan_tab_t **)chanid);\r\nstp = ctp->chan_src;\r\ndtp = ctp->chan_dest;\r\ndesc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t),\r\nGFP_KERNEL|GFP_DMA);\r\nif (desc_base == 0)\r\nreturn 0;\r\nif (desc_base & 0x1f) {\r\nkfree((const void *)desc_base);\r\ni = entries * sizeof(au1x_ddma_desc_t);\r\ni += (sizeof(au1x_ddma_desc_t) - 1);\r\ndesc_base = (u32)kmalloc(i, GFP_KERNEL|GFP_DMA);\r\nif (desc_base == 0)\r\nreturn 0;\r\nctp->cdb_membase = desc_base;\r\ndesc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));\r\n} else\r\nctp->cdb_membase = desc_base;\r\ndp = (au1x_ddma_desc_t *)desc_base;\r\nctp->chan_desc_base = dp;\r\nsrcid = stp->dev_id;\r\ndestid = dtp->dev_id;\r\ncmd0 = cmd1 = src1 = dest1 = 0;\r\nsrc0 = dest0 = 0;\r\ncmd0 |= DSCR_CMD0_SID(srcid);\r\ncmd0 |= DSCR_CMD0_DID(destid);\r\ncmd0 |= DSCR_CMD0_IE | DSCR_CMD0_CV;\r\ncmd0 |= DSCR_CMD0_ST(DSCR_CMD0_ST_NOCHANGE);\r\nif (((DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_THROTTLE) ||\r\n(DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_ALWAYS)) &&\r\n((DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_THROTTLE) ||\r\n(DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_ALWAYS)))\r\ncmd0 |= DSCR_CMD0_MEM;\r\nswitch (stp->dev_devwidth) {\r\ncase 8:\r\ncmd0 |= DSCR_CMD0_SW(DSCR_CMD0_BYTE);\r\nbreak;\r\ncase 16:\r\ncmd0 |= DSCR_CMD0_SW(DSCR_CMD0_HALFWORD);\r\nbreak;\r\ncase 32:\r\ndefault:\r\ncmd0 |= DSCR_CMD0_SW(DSCR_CMD0_WORD);\r\nbreak;\r\n}\r\nswitch (dtp->dev_devwidth) {\r\ncase 8:\r\ncmd0 |= DSCR_CMD0_DW(DSCR_CMD0_BYTE);\r\nbreak;\r\ncase 16:\r\ncmd0 |= DSCR_CMD0_DW(DSCR_CMD0_HALFWORD);\r\nbreak;\r\ncase 32:\r\ndefault:\r\ncmd0 |= DSCR_CMD0_DW(DSCR_CMD0_WORD);\r\nbreak;\r\n}\r\nif (stp->dev_flags & DEV_FLAGS_IN)\r\ncmd0 |= DSCR_CMD0_SN;\r\nif (dtp->dev_flags & DEV_FLAGS_OUT)\r\ncmd0 |= DSCR_CMD0_DN;\r\nswitch (stp->dev_tsize) {\r\ncase 1:\r\nsrc1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE1);\r\nbreak;\r\ncase 2:\r\nsrc1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE2);\r\nbreak;\r\ncase 4:\r\nsrc1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE4);\r\nbreak;\r\ncase 8:\r\ndefault:\r\nsrc1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE8);\r\nbreak;\r\n}\r\nif (stp->dev_flags & DEV_FLAGS_IN) {\r\nif (stp->dev_flags & DEV_FLAGS_BURSTABLE)\r\nsrc1 |= DSCR_SRC1_SAM(DSCR_xAM_BURST);\r\nelse\r\nsrc1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);\r\n}\r\nif (stp->dev_physaddr)\r\nsrc0 = stp->dev_physaddr;\r\nswitch (dtp->dev_tsize) {\r\ncase 1:\r\ndest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE1);\r\nbreak;\r\ncase 2:\r\ndest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE2);\r\nbreak;\r\ncase 4:\r\ndest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE4);\r\nbreak;\r\ncase 8:\r\ndefault:\r\ndest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE8);\r\nbreak;\r\n}\r\nif (dtp->dev_flags & DEV_FLAGS_OUT) {\r\nif (dtp->dev_flags & DEV_FLAGS_BURSTABLE)\r\ndest1 |= DSCR_DEST1_DAM(DSCR_xAM_BURST);\r\nelse\r\ndest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);\r\n}\r\nif (dtp->dev_physaddr)\r\ndest0 = dtp->dev_physaddr;\r\n#if 0\r\nprintk(KERN_DEBUG "did:%x sid:%x cmd0:%x cmd1:%x source0:%x "\r\n"source1:%x dest0:%x dest1:%x\n",\r\ndtp->dev_id, stp->dev_id, cmd0, cmd1, src0,\r\nsrc1, dest0, dest1);\r\n#endif\r\nfor (i = 0; i < entries; i++) {\r\ndp->dscr_cmd0 = cmd0;\r\ndp->dscr_cmd1 = cmd1;\r\ndp->dscr_source0 = src0;\r\ndp->dscr_source1 = src1;\r\ndp->dscr_dest0 = dest0;\r\ndp->dscr_dest1 = dest1;\r\ndp->dscr_stat = 0;\r\ndp->sw_context = 0;\r\ndp->sw_status = 0;\r\ndp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(dp + 1));\r\ndp++;\r\n}\r\ndp--;\r\ndp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(ctp->chan_desc_base));\r\nctp->get_ptr = ctp->put_ptr = ctp->cur_ptr = ctp->chan_desc_base;\r\nreturn (u32)ctp->chan_desc_base;\r\n}\r\nu32 au1xxx_dbdma_put_source(u32 chanid, dma_addr_t buf, int nbytes, u32 flags)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nctp = *(chan_tab_t **)chanid;\r\ndp = ctp->put_ptr;\r\nif (dp->dscr_cmd0 & DSCR_CMD0_V)\r\nreturn 0;\r\ndp->dscr_source0 = buf & ~0UL;\r\ndp->dscr_cmd1 = nbytes;\r\nif (flags & DDMA_FLAGS_IE)\r\ndp->dscr_cmd0 |= DSCR_CMD0_IE;\r\nif (flags & DDMA_FLAGS_NOIE)\r\ndp->dscr_cmd0 &= ~DSCR_CMD0_IE;\r\ndma_cache_wback_inv((unsigned long)buf, nbytes);\r\ndp->dscr_cmd0 |= DSCR_CMD0_V;\r\nau_sync();\r\ndma_cache_wback_inv((unsigned long)dp, sizeof(*dp));\r\nctp->chan_ptr->ddma_dbell = 0;\r\nctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\nreturn nbytes;\r\n}\r\nu32 au1xxx_dbdma_put_dest(u32 chanid, dma_addr_t buf, int nbytes, u32 flags)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nctp = *((chan_tab_t **)chanid);\r\ndp = ctp->put_ptr;\r\nif (dp->dscr_cmd0 & DSCR_CMD0_V)\r\nreturn 0;\r\nif (flags & DDMA_FLAGS_IE)\r\ndp->dscr_cmd0 |= DSCR_CMD0_IE;\r\nif (flags & DDMA_FLAGS_NOIE)\r\ndp->dscr_cmd0 &= ~DSCR_CMD0_IE;\r\ndp->dscr_dest0 = buf & ~0UL;\r\ndp->dscr_cmd1 = nbytes;\r\n#if 0\r\nprintk(KERN_DEBUG "cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",\r\ndp->dscr_cmd0, dp->dscr_cmd1, dp->dscr_source0,\r\ndp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1);\r\n#endif\r\ndma_cache_inv((unsigned long)buf, nbytes);\r\ndp->dscr_cmd0 |= DSCR_CMD0_V;\r\nau_sync();\r\ndma_cache_wback_inv((unsigned long)dp, sizeof(*dp));\r\nctp->chan_ptr->ddma_dbell = 0;\r\nctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\nreturn nbytes;\r\n}\r\nu32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nu32 rv;\r\nctp = *((chan_tab_t **)chanid);\r\ndp = ctp->get_ptr;\r\nif (dp->dscr_cmd0 & DSCR_CMD0_V)\r\nreturn 0;\r\n*buf = (void *)(phys_to_virt(dp->dscr_dest0));\r\n*nbytes = dp->dscr_cmd1;\r\nrv = dp->dscr_stat;\r\nctp->get_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\nreturn rv;\r\n}\r\nvoid au1xxx_dbdma_stop(u32 chanid)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_dma_chan_t *cp;\r\nint halt_timeout = 0;\r\nctp = *((chan_tab_t **)chanid);\r\ncp = ctp->chan_ptr;\r\ncp->ddma_cfg &= ~DDMA_CFG_EN;\r\nau_sync();\r\nwhile (!(cp->ddma_stat & DDMA_STAT_H)) {\r\nudelay(1);\r\nhalt_timeout++;\r\nif (halt_timeout > 100) {\r\nprintk(KERN_WARNING "warning: DMA channel won't halt\n");\r\nbreak;\r\n}\r\n}\r\ncp->ddma_stat |= (DDMA_STAT_DB | DDMA_STAT_V);\r\nau_sync();\r\n}\r\nvoid au1xxx_dbdma_start(u32 chanid)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_dma_chan_t *cp;\r\nctp = *((chan_tab_t **)chanid);\r\ncp = ctp->chan_ptr;\r\ncp->ddma_desptr = virt_to_phys(ctp->cur_ptr);\r\ncp->ddma_cfg |= DDMA_CFG_EN;\r\nau_sync();\r\ncp->ddma_dbell = 0;\r\nau_sync();\r\n}\r\nvoid au1xxx_dbdma_reset(u32 chanid)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nau1xxx_dbdma_stop(chanid);\r\nctp = *((chan_tab_t **)chanid);\r\nctp->get_ptr = ctp->put_ptr = ctp->cur_ptr = ctp->chan_desc_base;\r\ndp = ctp->chan_desc_base;\r\ndo {\r\ndp->dscr_cmd0 &= ~DSCR_CMD0_V;\r\ndp->sw_status = 0;\r\ndp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\n} while (dp != ctp->chan_desc_base);\r\n}\r\nu32 au1xxx_get_dma_residue(u32 chanid)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_dma_chan_t *cp;\r\nu32 rv;\r\nctp = *((chan_tab_t **)chanid);\r\ncp = ctp->chan_ptr;\r\nrv = cp->ddma_bytecnt;\r\nau_sync();\r\nreturn rv;\r\n}\r\nvoid au1xxx_dbdma_chan_free(u32 chanid)\r\n{\r\nchan_tab_t *ctp;\r\ndbdev_tab_t *stp, *dtp;\r\nctp = *((chan_tab_t **)chanid);\r\nstp = ctp->chan_src;\r\ndtp = ctp->chan_dest;\r\nau1xxx_dbdma_stop(chanid);\r\nkfree((void *)ctp->cdb_membase);\r\nstp->dev_flags &= ~DEV_FLAGS_INUSE;\r\ndtp->dev_flags &= ~DEV_FLAGS_INUSE;\r\nchan_tab_ptr[ctp->chan_index] = NULL;\r\nkfree(ctp);\r\n}\r\nstatic irqreturn_t dbdma_interrupt(int irq, void *dev_id)\r\n{\r\nu32 intstat;\r\nu32 chan_index;\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nau1x_dma_chan_t *cp;\r\nintstat = dbdma_gptr->ddma_intstat;\r\nau_sync();\r\nchan_index = __ffs(intstat);\r\nctp = chan_tab_ptr[chan_index];\r\ncp = ctp->chan_ptr;\r\ndp = ctp->cur_ptr;\r\ncp->ddma_irq = 0;\r\nau_sync();\r\nif (ctp->chan_callback)\r\nctp->chan_callback(irq, ctp->chan_callparam);\r\nctp->cur_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\nreturn IRQ_RETVAL(1);\r\n}\r\nvoid au1xxx_dbdma_dump(u32 chanid)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\ndbdev_tab_t *stp, *dtp;\r\nau1x_dma_chan_t *cp;\r\nu32 i = 0;\r\nctp = *((chan_tab_t **)chanid);\r\nstp = ctp->chan_src;\r\ndtp = ctp->chan_dest;\r\ncp = ctp->chan_ptr;\r\nprintk(KERN_DEBUG "Chan %x, stp %x (dev %d) dtp %x (dev %d)\n",\r\n(u32)ctp, (u32)stp, stp - dbdev_tab, (u32)dtp,\r\ndtp - dbdev_tab);\r\nprintk(KERN_DEBUG "desc base %x, get %x, put %x, cur %x\n",\r\n(u32)(ctp->chan_desc_base), (u32)(ctp->get_ptr),\r\n(u32)(ctp->put_ptr), (u32)(ctp->cur_ptr));\r\nprintk(KERN_DEBUG "dbdma chan %x\n", (u32)cp);\r\nprintk(KERN_DEBUG "cfg %08x, desptr %08x, statptr %08x\n",\r\ncp->ddma_cfg, cp->ddma_desptr, cp->ddma_statptr);\r\nprintk(KERN_DEBUG "dbell %08x, irq %08x, stat %08x, bytecnt %08x\n",\r\ncp->ddma_dbell, cp->ddma_irq, cp->ddma_stat,\r\ncp->ddma_bytecnt);\r\ndp = ctp->chan_desc_base;\r\ndo {\r\nprintk(KERN_DEBUG "Dp[%d]= %08x, cmd0 %08x, cmd1 %08x\n",\r\ni++, (u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);\r\nprintk(KERN_DEBUG "src0 %08x, src1 %08x, dest0 %08x, dest1 %08x\n",\r\ndp->dscr_source0, dp->dscr_source1,\r\ndp->dscr_dest0, dp->dscr_dest1);\r\nprintk(KERN_DEBUG "stat %08x, nxtptr %08x\n",\r\ndp->dscr_stat, dp->dscr_nxtptr);\r\ndp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\n} while (dp != ctp->chan_desc_base);\r\n}\r\nu32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr)\r\n{\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nu32 nbytes = 0;\r\nctp = *((chan_tab_t **)chanid);\r\ndp = ctp->put_ptr;\r\nif (dp->dscr_cmd0 & DSCR_CMD0_V)\r\nreturn 0;\r\ndp->dscr_dest0 = dscr->dscr_dest0;\r\ndp->dscr_source0 = dscr->dscr_source0;\r\ndp->dscr_dest1 = dscr->dscr_dest1;\r\ndp->dscr_source1 = dscr->dscr_source1;\r\ndp->dscr_cmd1 = dscr->dscr_cmd1;\r\nnbytes = dscr->dscr_cmd1;\r\ndp->dscr_cmd0 &= ~DSCR_CMD0_IE;\r\ndp->dscr_cmd0 |= dscr->dscr_cmd0 | DSCR_CMD0_V;\r\nctp->chan_ptr->ddma_dbell = 0;\r\nctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));\r\nreturn nbytes;\r\n}\r\nstatic int alchemy_dbdma_suspend(void)\r\n{\r\nint i;\r\nvoid __iomem *addr;\r\naddr = (void __iomem *)KSEG1ADDR(AU1550_DBDMA_CONF_PHYS_ADDR);\r\nalchemy_dbdma_pm_data[0][0] = __raw_readl(addr + 0x00);\r\nalchemy_dbdma_pm_data[0][1] = __raw_readl(addr + 0x04);\r\nalchemy_dbdma_pm_data[0][2] = __raw_readl(addr + 0x08);\r\nalchemy_dbdma_pm_data[0][3] = __raw_readl(addr + 0x0c);\r\naddr = (void __iomem *)KSEG1ADDR(AU1550_DBDMA_PHYS_ADDR);\r\nfor (i = 1; i <= NUM_DBDMA_CHANS; i++) {\r\nalchemy_dbdma_pm_data[i][0] = __raw_readl(addr + 0x00);\r\nalchemy_dbdma_pm_data[i][1] = __raw_readl(addr + 0x04);\r\nalchemy_dbdma_pm_data[i][2] = __raw_readl(addr + 0x08);\r\nalchemy_dbdma_pm_data[i][3] = __raw_readl(addr + 0x0c);\r\nalchemy_dbdma_pm_data[i][4] = __raw_readl(addr + 0x10);\r\nalchemy_dbdma_pm_data[i][5] = __raw_readl(addr + 0x14);\r\n__raw_writel(alchemy_dbdma_pm_data[i][0] & ~1, addr + 0x00);\r\nwmb();\r\nwhile (!(__raw_readl(addr + 0x14) & 1))\r\nwmb();\r\naddr += 0x100;\r\n}\r\naddr = (void __iomem *)KSEG1ADDR(AU1550_DBDMA_CONF_PHYS_ADDR);\r\n__raw_writel(0, addr + 0x0c);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic void alchemy_dbdma_resume(void)\r\n{\r\nint i;\r\nvoid __iomem *addr;\r\naddr = (void __iomem *)KSEG1ADDR(AU1550_DBDMA_CONF_PHYS_ADDR);\r\n__raw_writel(alchemy_dbdma_pm_data[0][0], addr + 0x00);\r\n__raw_writel(alchemy_dbdma_pm_data[0][1], addr + 0x04);\r\n__raw_writel(alchemy_dbdma_pm_data[0][2], addr + 0x08);\r\n__raw_writel(alchemy_dbdma_pm_data[0][3], addr + 0x0c);\r\naddr = (void __iomem *)KSEG1ADDR(AU1550_DBDMA_PHYS_ADDR);\r\nfor (i = 1; i <= NUM_DBDMA_CHANS; i++) {\r\n__raw_writel(alchemy_dbdma_pm_data[i][0], addr + 0x00);\r\n__raw_writel(alchemy_dbdma_pm_data[i][1], addr + 0x04);\r\n__raw_writel(alchemy_dbdma_pm_data[i][2], addr + 0x08);\r\n__raw_writel(alchemy_dbdma_pm_data[i][3], addr + 0x0c);\r\n__raw_writel(alchemy_dbdma_pm_data[i][4], addr + 0x10);\r\n__raw_writel(alchemy_dbdma_pm_data[i][5], addr + 0x14);\r\nwmb();\r\naddr += 0x100;\r\n}\r\n}\r\nstatic int __init dbdma_setup(unsigned int irq, dbdev_tab_t *idtable)\r\n{\r\nint ret;\r\ndbdev_tab = kzalloc(sizeof(dbdev_tab_t) * DBDEV_TAB_SIZE, GFP_KERNEL);\r\nif (!dbdev_tab)\r\nreturn -ENOMEM;\r\nmemcpy(dbdev_tab, idtable, 32 * sizeof(dbdev_tab_t));\r\nfor (ret = 32; ret < DBDEV_TAB_SIZE; ret++)\r\ndbdev_tab[ret].dev_id = ~0;\r\ndbdma_gptr->ddma_config = 0;\r\ndbdma_gptr->ddma_throttle = 0;\r\ndbdma_gptr->ddma_inten = 0xffff;\r\nau_sync();\r\nret = request_irq(irq, dbdma_interrupt, 0, "dbdma", (void *)dbdma_gptr);\r\nif (ret)\r\nprintk(KERN_ERR "Cannot grab DBDMA interrupt!\n");\r\nelse {\r\ndbdma_initialized = 1;\r\nregister_syscore_ops(&alchemy_dbdma_syscore_ops);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init alchemy_dbdma_init(void)\r\n{\r\nswitch (alchemy_get_cputype()) {\r\ncase ALCHEMY_CPU_AU1550:\r\nreturn dbdma_setup(AU1550_DDMA_INT, au1550_dbdev_tab);\r\ncase ALCHEMY_CPU_AU1200:\r\nreturn dbdma_setup(AU1200_DDMA_INT, au1200_dbdev_tab);\r\ncase ALCHEMY_CPU_AU1300:\r\nreturn dbdma_setup(AU1300_DDMA_INT, au1300_dbdev_tab);\r\n}\r\nreturn 0;\r\n}
