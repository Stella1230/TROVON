static int sdv_gpio_pub_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct sdv_gpio_chip_data *sd = gc->private;\r\nvoid __iomem *type_reg;\r\nu32 reg;\r\nif (d->hwirq < 8)\r\ntype_reg = sd->gpio_pub_base + GPIT1R0;\r\nelse\r\ntype_reg = sd->gpio_pub_base + GPIT1R1;\r\nreg = readl(type_reg);\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nreg &= ~BIT(4 * (d->hwirq % 8));\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nreg |= BIT(4 * (d->hwirq % 8));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(reg, type_reg);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sdv_gpio_pub_irq_handler(int irq, void *data)\r\n{\r\nstruct sdv_gpio_chip_data *sd = data;\r\nu32 irq_stat = readl(sd->gpio_pub_base + GPSTR);\r\nirq_stat &= readl(sd->gpio_pub_base + GPIO_INT);\r\nif (!irq_stat)\r\nreturn IRQ_NONE;\r\nwhile (irq_stat) {\r\nu32 irq_bit = __fls(irq_stat);\r\nirq_stat &= ~BIT(irq_bit);\r\ngeneric_handle_irq(irq_find_mapping(sd->id, irq_bit));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sdv_xlate(struct irq_domain *h, struct device_node *node,\r\nconst u32 *intspec, u32 intsize, irq_hw_number_t *out_hwirq,\r\nu32 *out_type)\r\n{\r\nu32 line, type;\r\nif (node != h->of_node)\r\nreturn -EINVAL;\r\nif (intsize < 2)\r\nreturn -EINVAL;\r\nline = *intspec;\r\n*out_hwirq = line;\r\nintspec++;\r\ntype = *intspec;\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\n*out_type = type;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdv_register_irqsupport(struct sdv_gpio_chip_data *sd,\r\nstruct pci_dev *pdev)\r\n{\r\nstruct irq_chip_type *ct;\r\nint ret;\r\nsd->irq_base = irq_alloc_descs(-1, 0, SDV_NUM_PUB_GPIOS, -1);\r\nif (sd->irq_base < 0)\r\nreturn sd->irq_base;\r\nwritel(0, sd->gpio_pub_base + GPIO_INT);\r\nwritel((1 << 11) - 1, sd->gpio_pub_base + GPSTR);\r\nret = request_irq(pdev->irq, sdv_gpio_pub_irq_handler, IRQF_SHARED,\r\n"sdv_gpio", sd);\r\nif (ret)\r\ngoto out_free_desc;\r\nsd->gc = irq_alloc_generic_chip("sdv-gpio", 1, sd->irq_base,\r\nsd->gpio_pub_base, handle_fasteoi_irq);\r\nif (!sd->gc) {\r\nret = -ENOMEM;\r\ngoto out_free_irq;\r\n}\r\nsd->gc->private = sd;\r\nct = sd->gc->chip_types;\r\nct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;\r\nct->regs.eoi = GPSTR;\r\nct->regs.mask = GPIO_INT;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_eoi = irq_gc_eoi;\r\nct->chip.irq_set_type = sdv_gpio_pub_set_type;\r\nirq_setup_generic_chip(sd->gc, IRQ_MSK(SDV_NUM_PUB_GPIOS),\r\nIRQ_GC_INIT_MASK_CACHE, IRQ_NOREQUEST,\r\nIRQ_LEVEL | IRQ_NOPROBE);\r\nsd->id = irq_domain_add_legacy(pdev->dev.of_node, SDV_NUM_PUB_GPIOS,\r\nsd->irq_base, 0, &irq_domain_sdv_ops, sd);\r\nif (!sd->id)\r\ngoto out_free_irq;\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(pdev->irq, sd);\r\nout_free_desc:\r\nirq_free_descs(sd->irq_base, SDV_NUM_PUB_GPIOS);\r\nreturn ret;\r\n}\r\nstatic int sdv_gpio_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct sdv_gpio_chip_data *sd;\r\nunsigned long addr;\r\nconst void *prop;\r\nint len;\r\nint ret;\r\nu32 mux_val;\r\nsd = kzalloc(sizeof(struct sdv_gpio_chip_data), GFP_KERNEL);\r\nif (!sd)\r\nreturn -ENOMEM;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't enable device.\n");\r\ngoto done;\r\n}\r\nret = pci_request_region(pdev, GPIO_BAR, DRV_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't alloc PCI BAR #%d\n", GPIO_BAR);\r\ngoto disable_pci;\r\n}\r\naddr = pci_resource_start(pdev, GPIO_BAR);\r\nif (!addr)\r\ngoto release_reg;\r\nsd->gpio_pub_base = ioremap(addr, pci_resource_len(pdev, GPIO_BAR));\r\nprop = of_get_property(pdev->dev.of_node, "intel,muxctl", &len);\r\nif (prop && len == 4) {\r\nmux_val = of_read_number(prop, 1);\r\nwritel(mux_val, sd->gpio_pub_base + GPMUXCTL);\r\n}\r\nret = bgpio_init(&sd->bgpio, &pdev->dev, 4,\r\nsd->gpio_pub_base + GPINR, sd->gpio_pub_base + GPOUTR,\r\nNULL, sd->gpio_pub_base + GPOER, NULL, 0);\r\nif (ret)\r\ngoto unmap;\r\nsd->bgpio.gc.ngpio = SDV_NUM_PUB_GPIOS;\r\nret = gpiochip_add(&sd->bgpio.gc);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "gpiochip_add() failed.\n");\r\ngoto unmap;\r\n}\r\nret = sdv_register_irqsupport(sd, pdev);\r\nif (ret)\r\ngoto unmap;\r\npci_set_drvdata(pdev, sd);\r\ndev_info(&pdev->dev, "Sodaville GPIO driver registered.\n");\r\nreturn 0;\r\nunmap:\r\niounmap(sd->gpio_pub_base);\r\nrelease_reg:\r\npci_release_region(pdev, GPIO_BAR);\r\ndisable_pci:\r\npci_disable_device(pdev);\r\ndone:\r\nkfree(sd);\r\nreturn ret;\r\n}\r\nstatic void sdv_gpio_remove(struct pci_dev *pdev)\r\n{\r\nstruct sdv_gpio_chip_data *sd = pci_get_drvdata(pdev);\r\nfree_irq(pdev->irq, sd);\r\nirq_free_descs(sd->irq_base, SDV_NUM_PUB_GPIOS);\r\nif (gpiochip_remove(&sd->bgpio.gc))\r\ndev_err(&pdev->dev, "gpiochip_remove() failed.\n");\r\npci_release_region(pdev, GPIO_BAR);\r\niounmap(sd->gpio_pub_base);\r\npci_disable_device(pdev);\r\nkfree(sd);\r\n}
