static irqreturn_t inport_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char buttons;\r\noutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\r\noutb(INPORT_MODE_HOLD | INPORT_MODE_IRQ | INPORT_MODE_BASE, INPORT_DATA_PORT);\r\noutb(INPORT_REG_X, INPORT_CONTROL_PORT);\r\ninput_report_rel(inport_dev, REL_X, inb(INPORT_DATA_PORT));\r\noutb(INPORT_REG_Y, INPORT_CONTROL_PORT);\r\ninput_report_rel(inport_dev, REL_Y, inb(INPORT_DATA_PORT));\r\noutb(INPORT_REG_BTNS, INPORT_CONTROL_PORT);\r\nbuttons = inb(INPORT_DATA_PORT);\r\ninput_report_key(inport_dev, BTN_MIDDLE, buttons & 1);\r\ninput_report_key(inport_dev, BTN_LEFT, buttons & 2);\r\ninput_report_key(inport_dev, BTN_RIGHT, buttons & 4);\r\noutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\r\noutb(INPORT_MODE_IRQ | INPORT_MODE_BASE, INPORT_DATA_PORT);\r\ninput_sync(inport_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int inport_open(struct input_dev *dev)\r\n{\r\nif (request_irq(inport_irq, inport_interrupt, 0, "inport", NULL))\r\nreturn -EBUSY;\r\noutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\r\noutb(INPORT_MODE_IRQ | INPORT_MODE_BASE, INPORT_DATA_PORT);\r\nreturn 0;\r\n}\r\nstatic void inport_close(struct input_dev *dev)\r\n{\r\noutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\r\noutb(INPORT_MODE_BASE, INPORT_DATA_PORT);\r\nfree_irq(inport_irq, NULL);\r\n}\r\nstatic int __init inport_init(void)\r\n{\r\nunsigned char a, b, c;\r\nint err;\r\nif (!request_region(INPORT_BASE, INPORT_EXTENT, "inport")) {\r\nprintk(KERN_ERR "inport.c: Can't allocate ports at %#x\n", INPORT_BASE);\r\nreturn -EBUSY;\r\n}\r\na = inb(INPORT_SIGNATURE_PORT);\r\nb = inb(INPORT_SIGNATURE_PORT);\r\nc = inb(INPORT_SIGNATURE_PORT);\r\nif (a == b || a != c) {\r\nprintk(KERN_INFO "inport.c: Didn't find InPort mouse at %#x\n", INPORT_BASE);\r\nerr = -ENODEV;\r\ngoto err_release_region;\r\n}\r\ninport_dev = input_allocate_device();\r\nif (!inport_dev) {\r\nprintk(KERN_ERR "inport.c: Not enough memory for input device\n");\r\nerr = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\ninport_dev->name = INPORT_NAME;\r\ninport_dev->phys = "isa023c/input0";\r\ninport_dev->id.bustype = BUS_ISA;\r\ninport_dev->id.vendor = INPORT_VENDOR;\r\ninport_dev->id.product = 0x0001;\r\ninport_dev->id.version = 0x0100;\r\ninport_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ninport_dev->keybit[BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) |\r\nBIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\r\ninport_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ninport_dev->open = inport_open;\r\ninport_dev->close = inport_close;\r\noutb(INPORT_RESET, INPORT_CONTROL_PORT);\r\noutb(INPORT_REG_MODE, INPORT_CONTROL_PORT);\r\noutb(INPORT_MODE_BASE, INPORT_DATA_PORT);\r\nerr = input_register_device(inport_dev);\r\nif (err)\r\ngoto err_free_dev;\r\nreturn 0;\r\nerr_free_dev:\r\ninput_free_device(inport_dev);\r\nerr_release_region:\r\nrelease_region(INPORT_BASE, INPORT_EXTENT);\r\nreturn err;\r\n}\r\nstatic void __exit inport_exit(void)\r\n{\r\ninput_unregister_device(inport_dev);\r\nrelease_region(INPORT_BASE, INPORT_EXTENT);\r\n}
