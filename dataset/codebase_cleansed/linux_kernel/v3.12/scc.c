static inline unsigned char InReg(io_port port, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nunsigned char r;\r\nspin_lock_irqsave(&iolock, flags);\r\n#ifdef SCC_LDELAY\r\nOutb(port, reg);\r\nudelay(SCC_LDELAY);\r\nr=Inb(port);\r\nudelay(SCC_LDELAY);\r\n#else\r\nOutb(port, reg);\r\nr=Inb(port);\r\n#endif\r\nspin_unlock_irqrestore(&iolock, flags);\r\nreturn r;\r\n}\r\nstatic inline void OutReg(io_port port, unsigned char reg, unsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&iolock, flags);\r\n#ifdef SCC_LDELAY\r\nOutb(port, reg); udelay(SCC_LDELAY);\r\nOutb(port, val); udelay(SCC_LDELAY);\r\n#else\r\nOutb(port, reg);\r\nOutb(port, val);\r\n#endif\r\nspin_unlock_irqrestore(&iolock, flags);\r\n}\r\nstatic inline void wr(struct scc_channel *scc, unsigned char reg,\r\nunsigned char val)\r\n{\r\nOutReg(scc->ctrl, reg, (scc->wreg[reg] = val));\r\n}\r\nstatic inline void or(struct scc_channel *scc, unsigned char reg, unsigned char val)\r\n{\r\nOutReg(scc->ctrl, reg, (scc->wreg[reg] |= val));\r\n}\r\nstatic inline void cl(struct scc_channel *scc, unsigned char reg, unsigned char val)\r\n{\r\nOutReg(scc->ctrl, reg, (scc->wreg[reg] &= ~val));\r\n}\r\nstatic inline void scc_discard_buffers(struct scc_channel *scc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\nif (scc->tx_buff != NULL)\r\n{\r\ndev_kfree_skb(scc->tx_buff);\r\nscc->tx_buff = NULL;\r\n}\r\nwhile (!skb_queue_empty(&scc->tx_queue))\r\ndev_kfree_skb(skb_dequeue(&scc->tx_queue));\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic inline void scc_notify(struct scc_channel *scc, int event)\r\n{\r\nstruct sk_buff *skb;\r\nchar *bp;\r\nif (scc->kiss.fulldup != KISS_DUPLEX_OPTIMA)\r\nreturn;\r\nskb = dev_alloc_skb(2);\r\nif (skb != NULL)\r\n{\r\nbp = skb_put(skb, 2);\r\n*bp++ = PARAM_HWEVENT;\r\n*bp++ = event;\r\nscc_net_rx(scc, skb);\r\n} else\r\nscc->stat.nospace++;\r\n}\r\nstatic inline void flush_rx_FIFO(struct scc_channel *scc)\r\n{\r\nint k;\r\nfor (k=0; k<3; k++)\r\nInb(scc->data);\r\nif(scc->rx_buff != NULL)\r\n{\r\nscc->stat.rxerrs++;\r\ndev_kfree_skb_irq(scc->rx_buff);\r\nscc->rx_buff = NULL;\r\n}\r\n}\r\nstatic void start_hunt(struct scc_channel *scc)\r\n{\r\nif ((scc->modem.clocksrc != CLK_EXTERNAL))\r\nOutReg(scc->ctrl,R14,SEARCH|scc->wreg[R14]);\r\nor(scc,R3,ENT_HM|RxENABLE);\r\n}\r\nstatic inline void scc_txint(struct scc_channel *scc)\r\n{\r\nstruct sk_buff *skb;\r\nscc->stat.txints++;\r\nskb = scc->tx_buff;\r\nif (skb == NULL)\r\n{\r\nskb = skb_dequeue(&scc->tx_queue);\r\nscc->tx_buff = skb;\r\nnetif_wake_queue(scc->dev);\r\nif (skb == NULL)\r\n{\r\nscc_tx_done(scc);\r\nOutb(scc->ctrl, RES_Tx_P);\r\nreturn;\r\n}\r\nif (skb->len == 0)\r\n{\r\ndev_kfree_skb_irq(skb);\r\nscc->tx_buff = NULL;\r\nscc_tx_done(scc);\r\nOutb(scc->ctrl, RES_Tx_P);\r\nreturn;\r\n}\r\nscc->stat.tx_state = TXS_ACTIVE;\r\nOutReg(scc->ctrl, R0, RES_Tx_CRC);\r\nor(scc,R10,ABUNDER);\r\nOutb(scc->data,*skb->data);\r\nskb_pull(skb, 1);\r\nif (!scc->enhanced)\r\nOutb(scc->ctrl,RES_EOM_L);\r\nreturn;\r\n}\r\nif (skb->len == 0)\r\n{\r\nOutb(scc->ctrl, RES_Tx_P);\r\ncl(scc, R10, ABUNDER);\r\ndev_kfree_skb_irq(skb);\r\nscc->tx_buff = NULL;\r\nscc->stat.tx_state = TXS_NEWFRAME;\r\nreturn;\r\n}\r\nOutb(scc->data,*skb->data);\r\nskb_pull(skb, 1);\r\n}\r\nstatic inline void scc_exint(struct scc_channel *scc)\r\n{\r\nunsigned char status,changes,chg_and_stat;\r\nscc->stat.exints++;\r\nstatus = InReg(scc->ctrl,R0);\r\nchanges = status ^ scc->status;\r\nchg_and_stat = changes & status;\r\nif (chg_and_stat & BRK_ABRT)\r\nflush_rx_FIFO(scc);\r\nif ((changes & SYNC_HUNT) && scc->kiss.softdcd)\r\n{\r\nif (status & SYNC_HUNT)\r\n{\r\nscc->dcd = 0;\r\nflush_rx_FIFO(scc);\r\nif ((scc->modem.clocksrc != CLK_EXTERNAL))\r\nOutReg(scc->ctrl,R14,SEARCH|scc->wreg[R14]);\r\n} else {\r\nscc->dcd = 1;\r\n}\r\nscc_notify(scc, scc->dcd? HWEV_DCD_OFF:HWEV_DCD_ON);\r\n}\r\nif((changes & DCD) && !scc->kiss.softdcd)\r\n{\r\nif(status & DCD)\r\n{\r\nstart_hunt(scc);\r\nscc->dcd = 1;\r\n} else {\r\ncl(scc,R3,ENT_HM|RxENABLE);\r\nflush_rx_FIFO(scc);\r\nscc->dcd = 0;\r\n}\r\nscc_notify(scc, scc->dcd? HWEV_DCD_ON:HWEV_DCD_OFF);\r\n}\r\n#ifdef notdef\r\nif (chg_and_stat & CTS)\r\n{\r\nif (scc->kiss.txdelay == 0)\r\nscc_start_tx_timer(scc, t_txdelay, 0);\r\n}\r\n#endif\r\nif (scc->stat.tx_state == TXS_ACTIVE && (status & TxEOM))\r\n{\r\nscc->stat.tx_under++;\r\nOutb(scc->ctrl, RES_EXT_INT);\r\nif (scc->tx_buff != NULL)\r\n{\r\ndev_kfree_skb_irq(scc->tx_buff);\r\nscc->tx_buff = NULL;\r\n}\r\nor(scc,R10,ABUNDER);\r\nscc_start_tx_timer(scc, t_txdelay, 0);\r\n}\r\nscc->status = status;\r\nOutb(scc->ctrl,RES_EXT_INT);\r\n}\r\nstatic inline void scc_rxint(struct scc_channel *scc)\r\n{\r\nstruct sk_buff *skb;\r\nscc->stat.rxints++;\r\nif((scc->wreg[5] & RTS) && scc->kiss.fulldup == KISS_DUPLEX_HALF)\r\n{\r\nInb(scc->data);\r\nor(scc,R3,ENT_HM);\r\nreturn;\r\n}\r\nskb = scc->rx_buff;\r\nif (skb == NULL)\r\n{\r\nskb = dev_alloc_skb(scc->stat.bufsize);\r\nif (skb == NULL)\r\n{\r\nscc->dev_stat.rx_dropped++;\r\nscc->stat.nospace++;\r\nInb(scc->data);\r\nor(scc, R3, ENT_HM);\r\nreturn;\r\n}\r\nscc->rx_buff = skb;\r\n*(skb_put(skb, 1)) = 0;\r\n}\r\nif (skb->len >= scc->stat.bufsize)\r\n{\r\n#ifdef notdef\r\nprintk(KERN_DEBUG "z8530drv: oops, scc_rxint() received huge frame...\n");\r\n#endif\r\ndev_kfree_skb_irq(skb);\r\nscc->rx_buff = NULL;\r\nInb(scc->data);\r\nor(scc, R3, ENT_HM);\r\nreturn;\r\n}\r\n*(skb_put(skb, 1)) = Inb(scc->data);\r\n}\r\nstatic inline void scc_spint(struct scc_channel *scc)\r\n{\r\nunsigned char status;\r\nstruct sk_buff *skb;\r\nscc->stat.spints++;\r\nstatus = InReg(scc->ctrl,R1);\r\nInb(scc->data);\r\nskb = scc->rx_buff;\r\nif(status & Rx_OVR)\r\n{\r\nscc->stat.rx_over++;\r\nor(scc,R3,ENT_HM);\r\nif (skb != NULL)\r\ndev_kfree_skb_irq(skb);\r\nscc->rx_buff = skb = NULL;\r\n}\r\nif(status & END_FR && skb != NULL)\r\n{\r\nif (!(status & CRC_ERR) && (status & 0xe) == RES8 && skb->len > 0)\r\n{\r\nskb_trim(skb, skb->len-1);\r\nscc_net_rx(scc, skb);\r\nscc->rx_buff = NULL;\r\nscc->stat.rxframes++;\r\n} else {\r\ndev_kfree_skb_irq(skb);\r\nscc->rx_buff = NULL;\r\nscc->stat.rxerrs++;\r\n}\r\n}\r\nOutb(scc->ctrl,ERR_RES);\r\n}\r\nstatic void scc_isr_dispatch(struct scc_channel *scc, int vector)\r\n{\r\nspin_lock(&scc->lock);\r\nswitch (vector & VECTOR_MASK)\r\n{\r\ncase TXINT: scc_txint(scc); break;\r\ncase EXINT: scc_exint(scc); break;\r\ncase RXINT: scc_rxint(scc); break;\r\ncase SPINT: scc_spint(scc); break;\r\n}\r\nspin_unlock(&scc->lock);\r\n}\r\nstatic irqreturn_t scc_isr(int irq, void *dev_id)\r\n{\r\nint chip_irq = (long) dev_id;\r\nunsigned char vector;\r\nstruct scc_channel *scc;\r\nstruct scc_ctrl *ctrl;\r\nint k;\r\nif (Vector_Latch)\r\n{\r\nfor(k=0; k < SCC_IRQTIMEOUT; k++)\r\n{\r\nOutb(Vector_Latch, 0);\r\nif((vector=Inb(Vector_Latch)) >= 16 * Nchips) break;\r\nif (vector & 0x01) break;\r\nscc=&SCC_Info[vector >> 3 ^ 0x01];\r\nif (!scc->dev) break;\r\nscc_isr_dispatch(scc, vector);\r\nOutReg(scc->ctrl,R0,RES_H_IUS);\r\n}\r\nif (k == SCC_IRQTIMEOUT)\r\nprintk(KERN_WARNING "z8530drv: endless loop in scc_isr()?\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nctrl = SCC_ctrl;\r\nwhile (ctrl->chan_A)\r\n{\r\nif (ctrl->irq != chip_irq)\r\n{\r\nctrl++;\r\ncontinue;\r\n}\r\nscc = NULL;\r\nfor (k = 0; InReg(ctrl->chan_A,R3) && k < SCC_IRQTIMEOUT; k++)\r\n{\r\nvector=InReg(ctrl->chan_B,R2);\r\nif (vector & 0x01) break;\r\nscc = &SCC_Info[vector >> 3 ^ 0x01];\r\nif (!scc->dev) break;\r\nscc_isr_dispatch(scc, vector);\r\n}\r\nif (k == SCC_IRQTIMEOUT)\r\n{\r\nprintk(KERN_WARNING "z8530drv: endless loop in scc_isr()?!\n");\r\nbreak;\r\n}\r\nif (scc != NULL)\r\n{\r\nOutReg(scc->ctrl,R0,RES_H_IUS);\r\nctrl = SCC_ctrl;\r\n} else\r\nctrl++;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void set_brg(struct scc_channel *scc, unsigned int tc)\r\n{\r\ncl(scc,R14,BRENABL);\r\nwr(scc,R12,tc & 255);\r\nwr(scc,R13,tc >> 8);\r\nor(scc,R14,BRENABL);\r\n}\r\nstatic inline void set_speed(struct scc_channel *scc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\nif (scc->modem.speed > 0)\r\nset_brg(scc, (unsigned) (scc->clock / (scc->modem.speed * 64)) - 2);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic inline void init_brg(struct scc_channel *scc)\r\n{\r\nwr(scc, R14, BRSRC);\r\nOutReg(scc->ctrl, R14, SSBR|scc->wreg[R14]);\r\nOutReg(scc->ctrl, R14, SNRZI|scc->wreg[R14]);\r\n}\r\nstatic void init_channel(struct scc_channel *scc)\r\n{\r\ndel_timer(&scc->tx_t);\r\ndel_timer(&scc->tx_wdog);\r\ndisable_irq(scc->irq);\r\nwr(scc,R4,X1CLK|SDLC);\r\nwr(scc,R1,0);\r\nwr(scc,R3,Rx8|RxCRC_ENAB);\r\nwr(scc,R5,Tx8|DTR|TxCRC_ENAB);\r\nwr(scc,R6,0);\r\nwr(scc,R7,FLAG);\r\nwr(scc,R9,VIS);\r\nwr(scc,R10,(scc->modem.nrz? NRZ : NRZI)|CRCPS|ABUNDER);\r\nwr(scc,R14, 0);\r\nswitch(scc->modem.clocksrc)\r\n{\r\ncase CLK_DPLL:\r\nwr(scc, R11, RCDPLL|TCDPLL|TRxCOI|TRxCDP);\r\ninit_brg(scc);\r\nbreak;\r\ncase CLK_DIVIDER:\r\nwr(scc, R11, ((scc->brand & BAYCOM)? TRxCDP : TRxCBR) | RCDPLL|TCRTxCP|TRxCOI);\r\ninit_brg(scc);\r\nbreak;\r\ncase CLK_EXTERNAL:\r\nwr(scc, R11, (scc->brand & BAYCOM)? RCTRxCP|TCRTxCP : RCRTxCP|TCTRxCP);\r\nOutReg(scc->ctrl, R14, DISDPLL);\r\nbreak;\r\n}\r\nset_speed(scc);\r\nif(scc->enhanced)\r\n{\r\nor(scc,R15,SHDLCE|FIFOE);\r\nwr(scc,R7,AUTOEOM);\r\n}\r\nif(scc->kiss.softdcd || (InReg(scc->ctrl,R0) & DCD))\r\n{\r\nstart_hunt(scc);\r\n}\r\nwr(scc,R15, BRKIE|TxUIE|(scc->kiss.softdcd? SYNCIE:DCDIE));\r\nOutb(scc->ctrl,RES_EXT_INT);\r\nOutb(scc->ctrl,RES_EXT_INT);\r\nor(scc,R1,INT_ALL_Rx|TxINT_ENAB|EXT_INT_ENAB);\r\nscc->status = InReg(scc->ctrl,R0);\r\nor(scc,R9,MIE);\r\nscc_init_timer(scc);\r\nenable_irq(scc->irq);\r\n}\r\nstatic void scc_key_trx(struct scc_channel *scc, char tx)\r\n{\r\nunsigned int time_const;\r\nif (scc->brand & PRIMUS)\r\nOutb(scc->ctrl + 4, scc->option | (tx? 0x80 : 0));\r\nif (scc->modem.speed < 300)\r\nscc->modem.speed = 1200;\r\ntime_const = (unsigned) (scc->clock / (scc->modem.speed * (tx? 2:64))) - 2;\r\ndisable_irq(scc->irq);\r\nif (tx)\r\n{\r\nor(scc, R1, TxINT_ENAB);\r\nor(scc, R15, TxUIE);\r\n}\r\nif (scc->modem.clocksrc == CLK_DPLL)\r\n{\r\nif (tx)\r\n{\r\n#ifdef CONFIG_SCC_TRXECHO\r\ncl(scc, R3, RxENABLE|ENT_HM);\r\ncl(scc, R15, DCDIE|SYNCIE);\r\n#endif\r\nset_brg(scc, time_const);\r\nwr(scc, R11, RCDPLL|TCBR|TRxCOI|TRxCBR);\r\nif (scc->kiss.tx_inhibit)\r\n{\r\nor(scc,R5, TxENAB);\r\nscc->wreg[R5] |= RTS;\r\n} else {\r\nor(scc,R5,RTS|TxENAB);\r\n}\r\n} else {\r\ncl(scc,R5,RTS|TxENAB);\r\nset_brg(scc, time_const);\r\nwr(scc, R11, RCDPLL|TCDPLL|TRxCOI|TRxCDP);\r\n#ifndef CONFIG_SCC_TRXECHO\r\nif (scc->kiss.softdcd)\r\n#endif\r\n{\r\nor(scc,R15, scc->kiss.softdcd? SYNCIE:DCDIE);\r\nstart_hunt(scc);\r\n}\r\n}\r\n} else {\r\nif (tx)\r\n{\r\n#ifdef CONFIG_SCC_TRXECHO\r\nif (scc->kiss.fulldup == KISS_DUPLEX_HALF)\r\n{\r\ncl(scc, R3, RxENABLE);\r\ncl(scc, R15, DCDIE|SYNCIE);\r\n}\r\n#endif\r\nif (scc->kiss.tx_inhibit)\r\n{\r\nor(scc,R5, TxENAB);\r\nscc->wreg[R5] |= RTS;\r\n} else {\r\nor(scc,R5,RTS|TxENAB);\r\n}\r\n} else {\r\ncl(scc,R5,RTS|TxENAB);\r\nif ((scc->kiss.fulldup == KISS_DUPLEX_HALF) &&\r\n#ifndef CONFIG_SCC_TRXECHO\r\nscc->kiss.softdcd)\r\n#else\r\n1)\r\n#endif\r\n{\r\nor(scc, R15, scc->kiss.softdcd? SYNCIE:DCDIE);\r\nstart_hunt(scc);\r\n}\r\n}\r\n}\r\nvoid __scc_start_tx_timer(struct scc_channel *scc, void (*handler)(unsigned long), unsigned long when)\r\n{\r\ndel_timer(&scc->tx_t);\r\nif (when == 0)\r\n{\r\nhandler((unsigned long) scc);\r\n} else\r\nif (when != TIMER_OFF)\r\n{\r\nscc->tx_t.data = (unsigned long) scc;\r\nscc->tx_t.function = handler;\r\nscc->tx_t.expires = jiffies + (when*HZ)/100;\r\nadd_timer(&scc->tx_t);\r\n}\r\n}\r\nstatic void scc_start_tx_timer(struct scc_channel *scc, void (*handler)(unsigned long), unsigned long when)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\n__scc_start_tx_timer(scc, handler, when);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic void scc_start_defer(struct scc_channel *scc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\ndel_timer(&scc->tx_wdog);\r\nif (scc->kiss.maxdefer != 0 && scc->kiss.maxdefer != TIMER_OFF)\r\n{\r\nscc->tx_wdog.data = (unsigned long) scc;\r\nscc->tx_wdog.function = t_busy;\r\nscc->tx_wdog.expires = jiffies + HZ*scc->kiss.maxdefer;\r\nadd_timer(&scc->tx_wdog);\r\n}\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic void scc_start_maxkeyup(struct scc_channel *scc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\ndel_timer(&scc->tx_wdog);\r\nif (scc->kiss.maxkeyup != 0 && scc->kiss.maxkeyup != TIMER_OFF)\r\n{\r\nscc->tx_wdog.data = (unsigned long) scc;\r\nscc->tx_wdog.function = t_maxkeyup;\r\nscc->tx_wdog.expires = jiffies + HZ*scc->kiss.maxkeyup;\r\nadd_timer(&scc->tx_wdog);\r\n}\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic void scc_tx_done(struct scc_channel *scc)\r\n{\r\nswitch (scc->kiss.fulldup)\r\n{\r\ncase KISS_DUPLEX_LINK:\r\nscc->stat.tx_state = TXS_IDLE2;\r\nif (scc->kiss.idletime != TIMER_OFF)\r\nscc_start_tx_timer(scc, t_idle,\r\nscc->kiss.idletime*100);\r\nbreak;\r\ncase KISS_DUPLEX_OPTIMA:\r\nscc_notify(scc, HWEV_ALL_SENT);\r\nbreak;\r\ndefault:\r\nscc->stat.tx_state = TXS_BUSY;\r\nscc_start_tx_timer(scc, t_tail, scc->kiss.tailtime);\r\n}\r\nnetif_wake_queue(scc->dev);\r\n}\r\nstatic inline int is_grouped(struct scc_channel *scc)\r\n{\r\nint k;\r\nstruct scc_channel *scc2;\r\nunsigned char grp1, grp2;\r\ngrp1 = scc->kiss.group;\r\nfor (k = 0; k < (Nchips * 2); k++)\r\n{\r\nscc2 = &SCC_Info[k];\r\ngrp2 = scc2->kiss.group;\r\nif (scc2 == scc || !(scc2->dev && grp2))\r\ncontinue;\r\nif ((grp1 & 0x3f) == (grp2 & 0x3f))\r\n{\r\nif ( (grp1 & TXGROUP) && (scc2->wreg[R5] & RTS) )\r\nreturn 1;\r\nif ( (grp1 & RXGROUP) && scc2->dcd )\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void t_dwait(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\nif (scc->stat.tx_state == TXS_WAIT)\r\n{\r\nif (skb_queue_empty(&scc->tx_queue)) {\r\nscc->stat.tx_state = TXS_IDLE;\r\nnetif_wake_queue(scc->dev);\r\nreturn;\r\n}\r\nscc->stat.tx_state = TXS_BUSY;\r\n}\r\nif (scc->kiss.fulldup == KISS_DUPLEX_HALF)\r\n{\r\nRand = Rand * 17 + 31;\r\nif (scc->dcd || (scc->kiss.persist) < Rand || (scc->kiss.group && is_grouped(scc)) )\r\n{\r\nscc_start_defer(scc);\r\nscc_start_tx_timer(scc, t_dwait, scc->kiss.slottime);\r\nreturn ;\r\n}\r\n}\r\nif ( !(scc->wreg[R5] & RTS) )\r\n{\r\nscc_key_trx(scc, TX_ON);\r\nscc_start_tx_timer(scc, t_txdelay, scc->kiss.txdelay);\r\n} else {\r\nscc_start_tx_timer(scc, t_txdelay, 0);\r\n}\r\n}\r\nstatic void t_txdelay(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\nscc_start_maxkeyup(scc);\r\nif (scc->tx_buff == NULL)\r\n{\r\ndisable_irq(scc->irq);\r\nscc_txint(scc);\r\nenable_irq(scc->irq);\r\n}\r\n}\r\nstatic void t_tail(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\ndel_timer(&scc->tx_wdog);\r\nscc_key_trx(scc, TX_OFF);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\nif (scc->stat.tx_state == TXS_TIMEOUT)\r\n{\r\nscc->stat.tx_state = TXS_WAIT;\r\nscc_start_tx_timer(scc, t_dwait, scc->kiss.mintime*100);\r\nreturn;\r\n}\r\nscc->stat.tx_state = TXS_IDLE;\r\nnetif_wake_queue(scc->dev);\r\n}\r\nstatic void t_busy(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\ndel_timer(&scc->tx_t);\r\nnetif_stop_queue(scc->dev);\r\nscc_discard_buffers(scc);\r\nscc->stat.txerrs++;\r\nscc->stat.tx_state = TXS_IDLE;\r\nnetif_wake_queue(scc->dev);\r\n}\r\nstatic void t_maxkeyup(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\nnetif_stop_queue(scc->dev);\r\nscc_discard_buffers(scc);\r\ndel_timer(&scc->tx_t);\r\ncl(scc, R1, TxINT_ENAB);\r\ncl(scc, R15, TxUIE);\r\nOutReg(scc->ctrl, R0, RES_Tx_P);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\nscc->stat.txerrs++;\r\nscc->stat.tx_state = TXS_TIMEOUT;\r\nscc_start_tx_timer(scc, t_tail, scc->kiss.tailtime);\r\n}\r\nstatic void t_idle(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\ndel_timer(&scc->tx_wdog);\r\nscc_key_trx(scc, TX_OFF);\r\nif(scc->kiss.mintime)\r\nscc_start_tx_timer(scc, t_dwait, scc->kiss.mintime*100);\r\nscc->stat.tx_state = TXS_WAIT;\r\n}\r\nstatic void scc_init_timer(struct scc_channel *scc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\nscc->stat.tx_state = TXS_IDLE;\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic unsigned int scc_set_param(struct scc_channel *scc, unsigned int cmd, unsigned int arg)\r\n{\r\nswitch (cmd)\r\n{\r\ncase PARAM_TXDELAY: scc->kiss.txdelay=arg; break;\r\ncase PARAM_PERSIST: scc->kiss.persist=arg; break;\r\ncase PARAM_SLOTTIME: scc->kiss.slottime=arg; break;\r\ncase PARAM_TXTAIL: scc->kiss.tailtime=arg; break;\r\ncase PARAM_FULLDUP: scc->kiss.fulldup=arg; break;\r\ncase PARAM_DTR: break;\r\ncase PARAM_GROUP: scc->kiss.group=arg; break;\r\ncase PARAM_IDLE: scc->kiss.idletime=arg; break;\r\ncase PARAM_MIN: scc->kiss.mintime=arg; break;\r\ncase PARAM_MAXKEY: scc->kiss.maxkeyup=arg; break;\r\ncase PARAM_WAIT: scc->kiss.waittime=arg; break;\r\ncase PARAM_MAXDEFER: scc->kiss.maxdefer=arg; break;\r\ncase PARAM_TX: scc->kiss.tx_inhibit=arg; break;\r\ncase PARAM_SOFTDCD:\r\nscc->kiss.softdcd=arg;\r\nif (arg)\r\n{\r\nor(scc, R15, SYNCIE);\r\ncl(scc, R15, DCDIE);\r\nstart_hunt(scc);\r\n} else {\r\nor(scc, R15, DCDIE);\r\ncl(scc, R15, SYNCIE);\r\n}\r\nbreak;\r\ncase PARAM_SPEED:\r\nif (arg < 256)\r\nscc->modem.speed=arg*100;\r\nelse\r\nscc->modem.speed=arg;\r\nif (scc->stat.tx_state == 0)\r\nset_speed(scc);\r\nbreak;\r\ncase PARAM_RTS:\r\nif ( !(scc->wreg[R5] & RTS) )\r\n{\r\nif (arg != TX_OFF) {\r\nscc_key_trx(scc, TX_ON);\r\nscc_start_tx_timer(scc, t_txdelay, scc->kiss.txdelay);\r\n}\r\n} else {\r\nif (arg == TX_OFF)\r\n{\r\nscc->stat.tx_state = TXS_BUSY;\r\nscc_start_tx_timer(scc, t_tail, scc->kiss.tailtime);\r\n}\r\n}\r\nbreak;\r\ncase PARAM_HWEVENT:\r\nscc_notify(scc, scc->dcd? HWEV_DCD_ON:HWEV_DCD_OFF);\r\nbreak;\r\ndefault: return -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long scc_get_param(struct scc_channel *scc, unsigned int cmd)\r\n{\r\nswitch (cmd)\r\n{\r\ncase PARAM_TXDELAY: return CAST(scc->kiss.txdelay);\r\ncase PARAM_PERSIST: return CAST(scc->kiss.persist);\r\ncase PARAM_SLOTTIME: return CAST(scc->kiss.slottime);\r\ncase PARAM_TXTAIL: return CAST(scc->kiss.tailtime);\r\ncase PARAM_FULLDUP: return CAST(scc->kiss.fulldup);\r\ncase PARAM_SOFTDCD: return CAST(scc->kiss.softdcd);\r\ncase PARAM_DTR: return CAST((scc->wreg[R5] & DTR)? 1:0);\r\ncase PARAM_RTS: return CAST((scc->wreg[R5] & RTS)? 1:0);\r\ncase PARAM_SPEED: return CAST(scc->modem.speed);\r\ncase PARAM_GROUP: return CAST(scc->kiss.group);\r\ncase PARAM_IDLE: return CAST(scc->kiss.idletime);\r\ncase PARAM_MIN: return CAST(scc->kiss.mintime);\r\ncase PARAM_MAXKEY: return CAST(scc->kiss.maxkeyup);\r\ncase PARAM_WAIT: return CAST(scc->kiss.waittime);\r\ncase PARAM_MAXDEFER: return CAST(scc->kiss.maxdefer);\r\ncase PARAM_TX: return CAST(scc->kiss.tx_inhibit);\r\ndefault: return NO_SUCH_PARAM;\r\n}\r\n}\r\nstatic void scc_stop_calibrate(unsigned long channel)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) channel;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\ndel_timer(&scc->tx_wdog);\r\nscc_key_trx(scc, TX_OFF);\r\nwr(scc, R6, 0);\r\nwr(scc, R7, FLAG);\r\nOutb(scc->ctrl,RES_EXT_INT);\r\nOutb(scc->ctrl,RES_EXT_INT);\r\nnetif_wake_queue(scc->dev);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic void\r\nscc_start_calibrate(struct scc_channel *scc, int duration, unsigned char pattern)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->lock, flags);\r\nnetif_stop_queue(scc->dev);\r\nscc_discard_buffers(scc);\r\ndel_timer(&scc->tx_wdog);\r\nscc->tx_wdog.data = (unsigned long) scc;\r\nscc->tx_wdog.function = scc_stop_calibrate;\r\nscc->tx_wdog.expires = jiffies + HZ*duration;\r\nadd_timer(&scc->tx_wdog);\r\nwr(scc, R6, 0);\r\nwr(scc, R7, pattern);\r\nOutb(scc->ctrl,RES_EXT_INT);\r\nOutb(scc->ctrl,RES_EXT_INT);\r\nscc_key_trx(scc, TX_ON);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nstatic void z8530_init(void)\r\n{\r\nstruct scc_channel *scc;\r\nint chip, k;\r\nunsigned long flags;\r\nchar *flag;\r\nprintk(KERN_INFO "Init Z8530 driver: %u channels, IRQ", Nchips*2);\r\nflag=" ";\r\nfor (k = 0; k < nr_irqs; k++)\r\nif (Ivec[k].used)\r\n{\r\nprintk("%s%d", flag, k);\r\nflag=",";\r\n}\r\nprintk("\n");\r\nfor (chip = 0; chip < Nchips; chip++)\r\n{\r\nscc=&SCC_Info[2*chip];\r\nif (!scc->ctrl) continue;\r\nif(scc->brand & EAGLE)\r\nOutb(scc->special,0x08);\r\nif(scc->brand & (PC100 | PRIMUS))\r\nOutb(scc->special,scc->option);\r\nspin_lock_irqsave(&scc->lock, flags);\r\nOutb(scc->ctrl, 0);\r\nOutReg(scc->ctrl,R9,FHWRES);\r\nudelay(100);\r\nwr(scc, R2, chip*16);\r\nwr(scc, R9, VIS);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\n}\r\nDriver_Initialized = 1;\r\n}\r\nstatic int scc_net_alloc(const char *name, struct scc_channel *scc)\r\n{\r\nint err;\r\nstruct net_device *dev;\r\ndev = alloc_netdev(0, name, scc_net_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->ml_priv = scc;\r\nscc->dev = dev;\r\nspin_lock_init(&scc->lock);\r\ninit_timer(&scc->tx_t);\r\ninit_timer(&scc->tx_wdog);\r\nerr = register_netdevice(dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: can't register network device (%d)\n",\r\nname, err);\r\nfree_netdev(dev);\r\nscc->dev = NULL;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void scc_net_setup(struct net_device *dev)\r\n{\r\ndev->tx_queue_len = 16;\r\ndev->netdev_ops = &scc_netdev_ops;\r\ndev->header_ops = &ax25_header_ops;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\ndev->flags = 0;\r\ndev->type = ARPHRD_AX25;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\r\ndev->mtu = AX25_DEF_PACLEN;\r\ndev->addr_len = AX25_ADDR_LEN;\r\n}\r\nstatic int scc_net_open(struct net_device *dev)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\r\nif (!scc->init)\r\nreturn -EINVAL;\r\nscc->tx_buff = NULL;\r\nskb_queue_head_init(&scc->tx_queue);\r\ninit_channel(scc);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int scc_net_close(struct net_device *dev)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&scc->lock, flags);\r\nOutb(scc->ctrl,0);\r\nwr(scc,R1,0);\r\nwr(scc,R3,0);\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\ndel_timer_sync(&scc->tx_t);\r\ndel_timer_sync(&scc->tx_wdog);\r\nscc_discard_buffers(scc);\r\nreturn 0;\r\n}\r\nstatic void scc_net_rx(struct scc_channel *scc, struct sk_buff *skb)\r\n{\r\nif (skb->len == 0) {\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\n}\r\nscc->dev_stat.rx_packets++;\r\nscc->dev_stat.rx_bytes += skb->len;\r\nskb->protocol = ax25_type_trans(skb, scc->dev);\r\nnetif_rx(skb);\r\n}\r\nstatic netdev_tx_t scc_net_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\r\nunsigned long flags;\r\nchar kisscmd;\r\nif (skb->len > scc->stat.bufsize || skb->len < 2) {\r\nscc->dev_stat.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nscc->dev_stat.tx_packets++;\r\nscc->dev_stat.tx_bytes += skb->len;\r\nscc->stat.txframes++;\r\nkisscmd = *skb->data & 0x1f;\r\nskb_pull(skb, 1);\r\nif (kisscmd) {\r\nscc_set_param(scc, kisscmd, *skb->data);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_irqsave(&scc->lock, flags);\r\nif (skb_queue_len(&scc->tx_queue) > scc->dev->tx_queue_len) {\r\nstruct sk_buff *skb_del;\r\nskb_del = skb_dequeue(&scc->tx_queue);\r\ndev_kfree_skb(skb_del);\r\n}\r\nskb_queue_tail(&scc->tx_queue, skb);\r\ndev->trans_start = jiffies;\r\nif(scc->stat.tx_state == TXS_IDLE || scc->stat.tx_state == TXS_IDLE2) {\r\nscc->stat.tx_state = TXS_BUSY;\r\nif (scc->kiss.fulldup == KISS_DUPLEX_HALF)\r\n__scc_start_tx_timer(scc, t_dwait, scc->kiss.waittime);\r\nelse\r\n__scc_start_tx_timer(scc, t_dwait, 0);\r\n}\r\nspin_unlock_irqrestore(&scc->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int scc_net_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct scc_kiss_cmd kiss_cmd;\r\nstruct scc_mem_config memcfg;\r\nstruct scc_hw_config hwcfg;\r\nstruct scc_calibrate cal;\r\nstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\r\nint chan;\r\nunsigned char device_name[IFNAMSIZ];\r\nvoid __user *arg = ifr->ifr_data;\r\nif (!Driver_Initialized)\r\n{\r\nif (cmd == SIOCSCCCFG)\r\n{\r\nint found = 1;\r\nif (!capable(CAP_SYS_RAWIO)) return -EPERM;\r\nif (!arg) return -EFAULT;\r\nif (Nchips >= SCC_MAXCHIPS)\r\nreturn -EINVAL;\r\nif (copy_from_user(&hwcfg, arg, sizeof(hwcfg)))\r\nreturn -EFAULT;\r\nif (hwcfg.irq == 2) hwcfg.irq = 9;\r\nif (hwcfg.irq < 0 || hwcfg.irq >= nr_irqs)\r\nreturn -EINVAL;\r\nif (!Ivec[hwcfg.irq].used && hwcfg.irq)\r\n{\r\nif (request_irq(hwcfg.irq, scc_isr,\r\nIRQF_DISABLED, "AX.25 SCC",\r\n(void *)(long) hwcfg.irq))\r\nprintk(KERN_WARNING "z8530drv: warning, cannot get IRQ %d\n", hwcfg.irq);\r\nelse\r\nIvec[hwcfg.irq].used = 1;\r\n}\r\nif (hwcfg.vector_latch && !Vector_Latch) {\r\nif (!request_region(hwcfg.vector_latch, 1, "scc vector latch"))\r\nprintk(KERN_WARNING "z8530drv: warning, cannot reserve vector latch port 0x%lx\n, disabled.", hwcfg.vector_latch);\r\nelse\r\nVector_Latch = hwcfg.vector_latch;\r\n}\r\nif (hwcfg.clock == 0)\r\nhwcfg.clock = SCC_DEFAULT_CLOCK;\r\n#ifndef SCC_DONT_CHECK\r\nif(request_region(hwcfg.ctrl_a, 1, "scc-probe"))\r\n{\r\ndisable_irq(hwcfg.irq);\r\nOutb(hwcfg.ctrl_a, 0);\r\nOutReg(hwcfg.ctrl_a, R9, FHWRES);\r\nudelay(100);\r\nOutReg(hwcfg.ctrl_a,R13,0x55);\r\nudelay(5);\r\nif (InReg(hwcfg.ctrl_a,R13) != 0x55)\r\nfound = 0;\r\nenable_irq(hwcfg.irq);\r\nrelease_region(hwcfg.ctrl_a, 1);\r\n}\r\nelse\r\nfound = 0;\r\n#endif\r\nif (found)\r\n{\r\nSCC_Info[2*Nchips ].ctrl = hwcfg.ctrl_a;\r\nSCC_Info[2*Nchips ].data = hwcfg.data_a;\r\nSCC_Info[2*Nchips ].irq = hwcfg.irq;\r\nSCC_Info[2*Nchips+1].ctrl = hwcfg.ctrl_b;\r\nSCC_Info[2*Nchips+1].data = hwcfg.data_b;\r\nSCC_Info[2*Nchips+1].irq = hwcfg.irq;\r\nSCC_ctrl[Nchips].chan_A = hwcfg.ctrl_a;\r\nSCC_ctrl[Nchips].chan_B = hwcfg.ctrl_b;\r\nSCC_ctrl[Nchips].irq = hwcfg.irq;\r\n}\r\nfor (chan = 0; chan < 2; chan++)\r\n{\r\nsprintf(device_name, "%s%i", SCC_DriverName, 2*Nchips+chan);\r\nSCC_Info[2*Nchips+chan].special = hwcfg.special;\r\nSCC_Info[2*Nchips+chan].clock = hwcfg.clock;\r\nSCC_Info[2*Nchips+chan].brand = hwcfg.brand;\r\nSCC_Info[2*Nchips+chan].option = hwcfg.option;\r\nSCC_Info[2*Nchips+chan].enhanced = hwcfg.escc;\r\n#ifdef SCC_DONT_CHECK\r\nprintk(KERN_INFO "%s: data port = 0x%3.3x control port = 0x%3.3x\n",\r\ndevice_name,\r\nSCC_Info[2*Nchips+chan].data,\r\nSCC_Info[2*Nchips+chan].ctrl);\r\n#else\r\nprintk(KERN_INFO "%s: data port = 0x%3.3lx control port = 0x%3.3lx -- %s\n",\r\ndevice_name,\r\nchan? hwcfg.data_b : hwcfg.data_a,\r\nchan? hwcfg.ctrl_b : hwcfg.ctrl_a,\r\nfound? "found" : "missing");\r\n#endif\r\nif (found)\r\n{\r\nrequest_region(SCC_Info[2*Nchips+chan].ctrl, 1, "scc ctrl");\r\nrequest_region(SCC_Info[2*Nchips+chan].data, 1, "scc data");\r\nif (Nchips+chan != 0 &&\r\nscc_net_alloc(device_name,\r\n&SCC_Info[2*Nchips+chan]))\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (found) Nchips++;\r\nreturn 0;\r\n}\r\nif (cmd == SIOCSCCINI)\r\n{\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (Nchips == 0)\r\nreturn -EINVAL;\r\nz8530_init();\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nif (!scc->init)\r\n{\r\nif (cmd == SIOCSCCCHANINI)\r\n{\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (!arg) return -EINVAL;\r\nscc->stat.bufsize = SCC_BUFSIZE;\r\nif (copy_from_user(&scc->modem, arg, sizeof(struct scc_modem)))\r\nreturn -EINVAL;\r\nif (scc->modem.speed < 4800)\r\n{\r\nscc->kiss.txdelay = 36;\r\nscc->kiss.persist = 42;\r\nscc->kiss.slottime = 16;\r\nscc->kiss.tailtime = 4;\r\nscc->kiss.fulldup = 0;\r\nscc->kiss.waittime = 50;\r\nscc->kiss.maxkeyup = 10;\r\nscc->kiss.mintime = 3;\r\nscc->kiss.idletime = 30;\r\nscc->kiss.maxdefer = 120;\r\nscc->kiss.softdcd = 0;\r\n} else {\r\nscc->kiss.txdelay = 10;\r\nscc->kiss.persist = 64;\r\nscc->kiss.slottime = 8;\r\nscc->kiss.tailtime = 1;\r\nscc->kiss.fulldup = 0;\r\nscc->kiss.waittime = 50;\r\nscc->kiss.maxkeyup = 7;\r\nscc->kiss.mintime = 3;\r\nscc->kiss.idletime = 30;\r\nscc->kiss.maxdefer = 120;\r\nscc->kiss.softdcd = 0;\r\n}\r\nscc->tx_buff = NULL;\r\nskb_queue_head_init(&scc->tx_queue);\r\nscc->init = 1;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nswitch(cmd)\r\n{\r\ncase SIOCSCCRESERVED:\r\nreturn -ENOIOCTLCMD;\r\ncase SIOCSCCSMEM:\r\nif (!capable(CAP_SYS_RAWIO)) return -EPERM;\r\nif (!arg || copy_from_user(&memcfg, arg, sizeof(memcfg)))\r\nreturn -EINVAL;\r\nscc->stat.bufsize = memcfg.bufsize;\r\nreturn 0;\r\ncase SIOCSCCGSTAT:\r\nif (!arg || copy_to_user(arg, &scc->stat, sizeof(scc->stat)))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase SIOCSCCGKISS:\r\nif (!arg || copy_from_user(&kiss_cmd, arg, sizeof(kiss_cmd)))\r\nreturn -EINVAL;\r\nkiss_cmd.param = scc_get_param(scc, kiss_cmd.command);\r\nif (copy_to_user(arg, &kiss_cmd, sizeof(kiss_cmd)))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase SIOCSCCSKISS:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (!arg || copy_from_user(&kiss_cmd, arg, sizeof(kiss_cmd)))\r\nreturn -EINVAL;\r\nreturn scc_set_param(scc, kiss_cmd.command, kiss_cmd.param);\r\ncase SIOCSCCCAL:\r\nif (!capable(CAP_SYS_RAWIO)) return -EPERM;\r\nif (!arg || copy_from_user(&cal, arg, sizeof(cal)) || cal.time == 0)\r\nreturn -EINVAL;\r\nscc_start_calibrate(scc, cal.time, cal.pattern);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int scc_net_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = (struct sockaddr *) addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *scc_net_get_stats(struct net_device *dev)\r\n{\r\nstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\r\nscc->dev_stat.rx_errors = scc->stat.rxerrs + scc->stat.rx_over;\r\nscc->dev_stat.tx_errors = scc->stat.txerrs + scc->stat.tx_under;\r\nscc->dev_stat.rx_fifo_errors = scc->stat.rx_over;\r\nscc->dev_stat.tx_fifo_errors = scc->stat.tx_under;\r\nreturn &scc->dev_stat;\r\n}\r\nstatic inline struct scc_channel *scc_net_seq_idx(loff_t pos)\r\n{\r\nint k;\r\nfor (k = 0; k < Nchips*2; ++k) {\r\nif (!SCC_Info[k].init)\r\ncontinue;\r\nif (pos-- == 0)\r\nreturn &SCC_Info[k];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *scc_net_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn *pos ? scc_net_seq_idx(*pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *scc_net_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nunsigned k;\r\nstruct scc_channel *scc = v;\r\n++*pos;\r\nfor (k = (v == SEQ_START_TOKEN) ? 0 : (scc - SCC_Info)+1;\r\nk < Nchips*2; ++k) {\r\nif (SCC_Info[k].init)\r\nreturn &SCC_Info[k];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void scc_net_seq_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int scc_net_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "z8530drv-"VERSION"\n");\r\n} else if (!Driver_Initialized) {\r\nseq_puts(seq, "not initialized\n");\r\n} else if (!Nchips) {\r\nseq_puts(seq, "chips missing\n");\r\n} else {\r\nconst struct scc_channel *scc = v;\r\nconst struct scc_stat *stat = &scc->stat;\r\nconst struct scc_kiss *kiss = &scc->kiss;\r\nseq_printf(seq, "%s\t%3.3lx %3.3lx %d %lu %2.2x %d %3.3lx %3.3lx %d\n",\r\nscc->dev->name,\r\nscc->data, scc->ctrl, scc->irq, scc->clock, scc->brand,\r\nscc->enhanced, Vector_Latch, scc->special,\r\nscc->option);\r\nseq_printf(seq, "\t%lu %d %d %d %d\n",\r\nscc->modem.speed, scc->modem.nrz,\r\nscc->modem.clocksrc, kiss->softdcd,\r\nstat->bufsize);\r\nseq_printf(seq, "\t%lu %lu %lu %lu\n",\r\nstat->rxints, stat->txints, stat->exints, stat->spints);\r\nseq_printf(seq, "\t%lu %lu %d / %lu %lu %d / %d %d\n",\r\nstat->rxframes, stat->rxerrs, stat->rx_over,\r\nstat->txframes, stat->txerrs, stat->tx_under,\r\nstat->nospace, stat->tx_state);\r\n#define K(x) kiss->x\r\nseq_printf(seq, "\t%d %d %d %d %d %d %d %d %d %d %d %d\n",\r\nK(txdelay), K(persist), K(slottime), K(tailtime),\r\nK(fulldup), K(waittime), K(mintime), K(maxkeyup),\r\nK(idletime), K(maxdefer), K(tx_inhibit), K(group));\r\n#undef K\r\n#ifdef SCC_DEBUG\r\n{\r\nint reg;\r\nseq_printf(seq, "\tW ");\r\nfor (reg = 0; reg < 16; reg++)\r\nseq_printf(seq, "%2.2x ", scc->wreg[reg]);\r\nseq_printf(seq, "\n");\r\nseq_printf(seq, "\tR %2.2x %2.2x XX ", InReg(scc->ctrl,R0), InReg(scc->ctrl,R1));\r\nfor (reg = 3; reg < 8; reg++)\r\nseq_printf(seq, "%2.2x ", InReg(scc->ctrl, reg));\r\nseq_printf(seq, "XX ");\r\nfor (reg = 9; reg < 16; reg++)\r\nseq_printf(seq, "%2.2x ", InReg(scc->ctrl, reg));\r\nseq_printf(seq, "\n");\r\n}\r\n#endif\r\nseq_putc(seq, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int scc_net_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &scc_net_seq_ops);\r\n}\r\nstatic int __init scc_init_driver (void)\r\n{\r\nchar devname[IFNAMSIZ];\r\nprintk(banner);\r\nsprintf(devname,"%s0", SCC_DriverName);\r\nrtnl_lock();\r\nif (scc_net_alloc(devname, SCC_Info)) {\r\nrtnl_unlock();\r\nprintk(KERN_ERR "z8530drv: cannot initialize module\n");\r\nreturn -EIO;\r\n}\r\nrtnl_unlock();\r\nproc_create("z8530drv", 0, init_net.proc_net, &scc_net_seq_fops);\r\nreturn 0;\r\n}\r\nstatic void __exit scc_cleanup_driver(void)\r\n{\r\nio_port ctrl;\r\nint k;\r\nstruct scc_channel *scc;\r\nstruct net_device *dev;\r\nif (Nchips == 0 && (dev = SCC_Info[0].dev))\r\n{\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\nlocal_irq_disable();\r\nfor (k = 0; k < Nchips; k++)\r\nif ( (ctrl = SCC_ctrl[k].chan_A) )\r\n{\r\nOutb(ctrl, 0);\r\nOutReg(ctrl,R9,FHWRES);\r\nudelay(50);\r\n}\r\nfor (k = 0; k < nr_irqs ; k++)\r\nif (Ivec[k].used) free_irq(k, NULL);\r\nlocal_irq_enable();\r\nfor (k = 0; k < Nchips*2; k++)\r\n{\r\nscc = &SCC_Info[k];\r\nif (scc->ctrl)\r\n{\r\nrelease_region(scc->ctrl, 1);\r\nrelease_region(scc->data, 1);\r\n}\r\nif (scc->dev)\r\n{\r\nunregister_netdev(scc->dev);\r\nfree_netdev(scc->dev);\r\n}\r\n}\r\nif (Vector_Latch)\r\nrelease_region(Vector_Latch, 1);\r\nremove_proc_entry("z8530drv", init_net.proc_net);\r\n}
