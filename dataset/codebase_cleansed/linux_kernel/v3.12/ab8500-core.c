static int ab8500_prcmu_write(struct ab8500 *ab8500, u16 addr, u8 data)\r\n{\r\nint ret;\r\nret = prcmu_abb_write((u8)(addr >> 8), (u8)(addr & 0xFF), &data, 1);\r\nif (ret < 0)\r\ndev_err(ab8500->dev, "prcmu i2c error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ab8500_prcmu_write_masked(struct ab8500 *ab8500, u16 addr, u8 mask,\r\nu8 data)\r\n{\r\nint ret;\r\nret = prcmu_abb_write_masked((u8)(addr >> 8), (u8)(addr & 0xFF), &data,\r\n&mask, 1);\r\nif (ret < 0)\r\ndev_err(ab8500->dev, "prcmu i2c error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ab8500_prcmu_read(struct ab8500 *ab8500, u16 addr)\r\n{\r\nint ret;\r\nu8 data;\r\nret = prcmu_abb_read((u8)(addr >> 8), (u8)(addr & 0xFF), &data, 1);\r\nif (ret < 0) {\r\ndev_err(ab8500->dev, "prcmu i2c error %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn (int)data;\r\n}\r\nstatic int ab8500_get_chip_id(struct device *dev)\r\n{\r\nstruct ab8500 *ab8500;\r\nif (!dev)\r\nreturn -EINVAL;\r\nab8500 = dev_get_drvdata(dev->parent);\r\nreturn ab8500 ? (int)ab8500->chip_id : -EINVAL;\r\n}\r\nstatic int set_register_interruptible(struct ab8500 *ab8500, u8 bank,\r\nu8 reg, u8 data)\r\n{\r\nint ret;\r\nu16 addr = ((u16)bank) << 8 | reg;\r\ndev_vdbg(ab8500->dev, "wr: addr %#x <= %#x\n", addr, data);\r\nmutex_lock(&ab8500->lock);\r\nret = ab8500->write(ab8500, addr, data);\r\nif (ret < 0)\r\ndev_err(ab8500->dev, "failed to write reg %#x: %d\n",\r\naddr, ret);\r\nmutex_unlock(&ab8500->lock);\r\nreturn ret;\r\n}\r\nstatic int ab8500_set_register(struct device *dev, u8 bank,\r\nu8 reg, u8 value)\r\n{\r\nint ret;\r\nstruct ab8500 *ab8500 = dev_get_drvdata(dev->parent);\r\natomic_inc(&ab8500->transfer_ongoing);\r\nret = set_register_interruptible(ab8500, bank, reg, value);\r\natomic_dec(&ab8500->transfer_ongoing);\r\nreturn ret;\r\n}\r\nstatic int get_register_interruptible(struct ab8500 *ab8500, u8 bank,\r\nu8 reg, u8 *value)\r\n{\r\nint ret;\r\nu16 addr = ((u16)bank) << 8 | reg;\r\nmutex_lock(&ab8500->lock);\r\nret = ab8500->read(ab8500, addr);\r\nif (ret < 0)\r\ndev_err(ab8500->dev, "failed to read reg %#x: %d\n",\r\naddr, ret);\r\nelse\r\n*value = ret;\r\nmutex_unlock(&ab8500->lock);\r\ndev_vdbg(ab8500->dev, "rd: addr %#x => data %#x\n", addr, ret);\r\nreturn ret;\r\n}\r\nstatic int ab8500_get_register(struct device *dev, u8 bank,\r\nu8 reg, u8 *value)\r\n{\r\nint ret;\r\nstruct ab8500 *ab8500 = dev_get_drvdata(dev->parent);\r\natomic_inc(&ab8500->transfer_ongoing);\r\nret = get_register_interruptible(ab8500, bank, reg, value);\r\natomic_dec(&ab8500->transfer_ongoing);\r\nreturn ret;\r\n}\r\nstatic int mask_and_set_register_interruptible(struct ab8500 *ab8500, u8 bank,\r\nu8 reg, u8 bitmask, u8 bitvalues)\r\n{\r\nint ret;\r\nu16 addr = ((u16)bank) << 8 | reg;\r\nmutex_lock(&ab8500->lock);\r\nif (ab8500->write_masked == NULL) {\r\nu8 data;\r\nret = ab8500->read(ab8500, addr);\r\nif (ret < 0) {\r\ndev_err(ab8500->dev, "failed to read reg %#x: %d\n",\r\naddr, ret);\r\ngoto out;\r\n}\r\ndata = (u8)ret;\r\ndata = (~bitmask & data) | (bitmask & bitvalues);\r\nret = ab8500->write(ab8500, addr, data);\r\nif (ret < 0)\r\ndev_err(ab8500->dev, "failed to write reg %#x: %d\n",\r\naddr, ret);\r\ndev_vdbg(ab8500->dev, "mask: addr %#x => data %#x\n", addr,\r\ndata);\r\ngoto out;\r\n}\r\nret = ab8500->write_masked(ab8500, addr, bitmask, bitvalues);\r\nif (ret < 0)\r\ndev_err(ab8500->dev, "failed to modify reg %#x: %d\n", addr,\r\nret);\r\nout:\r\nmutex_unlock(&ab8500->lock);\r\nreturn ret;\r\n}\r\nstatic int ab8500_mask_and_set_register(struct device *dev,\r\nu8 bank, u8 reg, u8 bitmask, u8 bitvalues)\r\n{\r\nint ret;\r\nstruct ab8500 *ab8500 = dev_get_drvdata(dev->parent);\r\natomic_inc(&ab8500->transfer_ongoing);\r\nret= mask_and_set_register_interruptible(ab8500, bank, reg,\r\nbitmask, bitvalues);\r\natomic_dec(&ab8500->transfer_ongoing);\r\nreturn ret;\r\n}\r\nstatic void ab8500_irq_lock(struct irq_data *data)\r\n{\r\nstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&ab8500->irq_lock);\r\natomic_inc(&ab8500->transfer_ongoing);\r\n}\r\nstatic void ab8500_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\r\nint i;\r\nfor (i = 0; i < ab8500->mask_size; i++) {\r\nu8 old = ab8500->oldmask[i];\r\nu8 new = ab8500->mask[i];\r\nint reg;\r\nif (new == old)\r\ncontinue;\r\nif (ab8500->irq_reg_offset[i] == 11 &&\r\nis_ab8500_1p1_or_earlier(ab8500))\r\ncontinue;\r\nif (ab8500->irq_reg_offset[i] < 0)\r\ncontinue;\r\nab8500->oldmask[i] = new;\r\nreg = AB8500_IT_MASK1_REG + ab8500->irq_reg_offset[i];\r\nset_register_interruptible(ab8500, AB8500_INTERRUPT, reg, new);\r\n}\r\natomic_dec(&ab8500->transfer_ongoing);\r\nmutex_unlock(&ab8500->irq_lock);\r\n}\r\nstatic void ab8500_irq_mask(struct irq_data *data)\r\n{\r\nstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\r\nint offset = data->hwirq;\r\nint index = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nab8500->mask[index] |= mask;\r\nif (offset >= AB8500_INT_GPIO6R && offset <= AB8500_INT_GPIO41R)\r\nab8500->mask[index + 2] |= mask;\r\nif (offset >= AB9540_INT_GPIO50R && offset <= AB9540_INT_GPIO54R)\r\nab8500->mask[index + 1] |= mask;\r\nif (offset == AB8540_INT_GPIO43R || offset == AB8540_INT_GPIO44R)\r\nab8500->mask[index] |= (mask << 1);\r\n}\r\nstatic void ab8500_irq_unmask(struct irq_data *data)\r\n{\r\nstruct ab8500 *ab8500 = irq_data_get_irq_chip_data(data);\r\nunsigned int type = irqd_get_trigger_type(data);\r\nint offset = data->hwirq;\r\nint index = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nab8500->mask[index] &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_FALLING) {\r\nif (offset >= AB8500_INT_GPIO6R && offset <= AB8500_INT_GPIO41R)\r\nab8500->mask[index + 2] &= ~mask;\r\nelse if (offset >= AB9540_INT_GPIO50R && offset <= AB9540_INT_GPIO54R)\r\nab8500->mask[index + 1] &= ~mask;\r\nelse if (offset == AB8540_INT_GPIO43R || offset == AB8540_INT_GPIO44R)\r\nab8500->mask[index] &= ~(mask << 1);\r\nelse\r\nab8500->mask[index] &= ~mask;\r\n} else {\r\nab8500->mask[index] &= ~mask;\r\n}\r\n}\r\nstatic int ab8500_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nreturn 0;\r\n}\r\nstatic void update_latch_offset(u8 *offset, int i)\r\n{\r\nif (unlikely(*offset == 17))\r\n*offset = 24;\r\nif (unlikely(*offset == 16))\r\n*offset = 25;\r\nif ((i==3) && (*offset >= 24))\r\n*offset += 2;\r\n}\r\nstatic int ab8500_handle_hierarchical_line(struct ab8500 *ab8500,\r\nint latch_offset, u8 latch_val)\r\n{\r\nint int_bit, line, i;\r\nfor (i = 0; i < ab8500->mask_size; i++)\r\nif (ab8500->irq_reg_offset[i] == latch_offset)\r\nbreak;\r\nif (i >= ab8500->mask_size) {\r\ndev_err(ab8500->dev, "Register offset 0x%2x not declared\n",\r\nlatch_offset);\r\nreturn -ENXIO;\r\n}\r\nlatch_val &= ~ab8500->mask[i];\r\nwhile (latch_val) {\r\nint_bit = __ffs(latch_val);\r\nline = (i << 3) + int_bit;\r\nlatch_val &= ~(1 << int_bit);\r\nif (line >= AB8500_INT_GPIO6F && line <= AB8500_INT_GPIO41F)\r\nline -= 16;\r\nif (line >= AB9540_INT_GPIO50F && line <= AB9540_INT_GPIO54F)\r\nline -= 8;\r\nif (line == AB8540_INT_GPIO43F || line == AB8540_INT_GPIO44F)\r\nline += 1;\r\nhandle_nested_irq(ab8500->irq_base + line);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_handle_hierarchical_latch(struct ab8500 *ab8500,\r\nint hier_offset, u8 hier_val)\r\n{\r\nint latch_bit, status;\r\nu8 latch_offset, latch_val;\r\ndo {\r\nlatch_bit = __ffs(hier_val);\r\nlatch_offset = (hier_offset << 3) + latch_bit;\r\nupdate_latch_offset(&latch_offset, hier_offset);\r\nstatus = get_register_interruptible(ab8500,\r\nAB8500_INTERRUPT,\r\nAB8500_IT_LATCH1_REG + latch_offset,\r\n&latch_val);\r\nif (status < 0 || latch_val == 0)\r\ngoto discard;\r\nstatus = ab8500_handle_hierarchical_line(ab8500,\r\nlatch_offset, latch_val);\r\nif (status < 0)\r\nreturn status;\r\ndiscard:\r\nhier_val &= ~(1 << latch_bit);\r\n} while (hier_val);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ab8500_hierarchical_irq(int irq, void *dev)\r\n{\r\nstruct ab8500 *ab8500 = dev;\r\nu8 i;\r\ndev_vdbg(ab8500->dev, "interrupt\n");\r\nfor (i = 0; i < (ab8500->it_latchhier_num); i++) {\r\nint status;\r\nu8 hier_val;\r\nstatus = get_register_interruptible(ab8500, AB8500_INTERRUPT,\r\nAB8500_IT_LATCHHIER1_REG + i, &hier_val);\r\nif (status < 0 || hier_val == 0)\r\ncontinue;\r\nstatus = ab8500_handle_hierarchical_latch(ab8500, i, hier_val);\r\nif (status < 0)\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ab8500_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct ab8500 *ab8500 = d->host_data;\r\nif (!ab8500)\r\nreturn -EINVAL;\r\nirq_set_chip_data(virq, ab8500);\r\nirq_set_chip_and_handler(virq, &ab8500_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_nested_thread(virq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(virq);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ab8500_irq_init(struct ab8500 *ab8500, struct device_node *np)\r\n{\r\nint num_irqs;\r\nif (is_ab8540(ab8500))\r\nnum_irqs = AB8540_NR_IRQS;\r\nelse if (is_ab9540(ab8500))\r\nnum_irqs = AB9540_NR_IRQS;\r\nelse if (is_ab8505(ab8500))\r\nnum_irqs = AB8505_NR_IRQS;\r\nelse\r\nnum_irqs = AB8500_NR_IRQS;\r\nab8500->domain = irq_domain_add_simple(NULL,\r\nnum_irqs, ab8500->irq_base,\r\n&ab8500_irq_ops, ab8500);\r\nif (!ab8500->domain) {\r\ndev_err(ab8500->dev, "Failed to create irqdomain\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nint ab8500_suspend(struct ab8500 *ab8500)\r\n{\r\nif (atomic_read(&ab8500->transfer_ongoing))\r\nreturn -EINVAL;\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t show_chip_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ab8500 *ab8500;\r\nab8500 = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%#x\n", ab8500 ? ab8500->chip_id : -EINVAL);\r\n}\r\nstatic ssize_t show_switch_off_status(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nu8 value;\r\nstruct ab8500 *ab8500;\r\nab8500 = dev_get_drvdata(dev);\r\nret = get_register_interruptible(ab8500, AB8500_RTC,\r\nAB8500_SWITCH_OFF_STATUS, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%#x\n", value);\r\n}\r\nvoid ab8500_override_turn_on_stat(u8 mask, u8 set)\r\n{\r\nspin_lock(&on_stat_lock);\r\nturn_on_stat_mask = mask;\r\nturn_on_stat_set = set;\r\nspin_unlock(&on_stat_lock);\r\n}\r\nstatic ssize_t show_turn_on_status(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nu8 value;\r\nstruct ab8500 *ab8500;\r\nab8500 = dev_get_drvdata(dev);\r\nret = get_register_interruptible(ab8500, AB8500_SYS_CTRL1_BLOCK,\r\nAB8500_TURN_ON_STATUS, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nif (is_ab9540(ab8500)) {\r\nspin_lock(&on_stat_lock);\r\nvalue = (value & turn_on_stat_mask) | turn_on_stat_set;\r\nspin_unlock(&on_stat_lock);\r\n}\r\nreturn sprintf(buf, "%#x\n", value);\r\n}\r\nstatic ssize_t show_turn_on_status_2(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nu8 value;\r\nstruct ab8500 *ab8500;\r\nab8500 = dev_get_drvdata(dev);\r\nret = get_register_interruptible(ab8500, AB8500_SYS_CTRL1_BLOCK,\r\nAB8505_TURN_ON_STATUS_2, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%#x\n", (value & 0x1));\r\n}\r\nstatic ssize_t show_ab9540_dbbrstn(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ab8500 *ab8500;\r\nint ret;\r\nu8 value;\r\nab8500 = dev_get_drvdata(dev);\r\nret = get_register_interruptible(ab8500, AB8500_REGU_CTRL2,\r\nAB9540_MODEM_CTRL2_REG, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n",\r\n(value & AB9540_MODEM_CTRL2_SWDBBRSTN_BIT) ? 1 : 0);\r\n}\r\nstatic ssize_t store_ab9540_dbbrstn(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct ab8500 *ab8500;\r\nint ret = count;\r\nint err;\r\nu8 bitvalues;\r\nab8500 = dev_get_drvdata(dev);\r\nif (count > 0) {\r\nswitch (buf[0]) {\r\ncase '0':\r\nbitvalues = 0;\r\nbreak;\r\ncase '1':\r\nbitvalues = AB9540_MODEM_CTRL2_SWDBBRSTN_BIT;\r\nbreak;\r\ndefault:\r\ngoto exit;\r\n}\r\nerr = mask_and_set_register_interruptible(ab8500,\r\nAB8500_REGU_CTRL2, AB9540_MODEM_CTRL2_REG,\r\nAB9540_MODEM_CTRL2_SWDBBRSTN_BIT, bitvalues);\r\nif (err)\r\ndev_info(ab8500->dev,\r\n"Failed to set DBBRSTN %c, err %#x\n",\r\nbuf[0], err);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int ab8500_probe(struct platform_device *pdev)\r\n{\r\nstatic char *switch_off_status[] = {\r\n"Swoff bit programming",\r\n"Thermal protection activation",\r\n"Vbat lower then BattOk falling threshold",\r\n"Watchdog expired",\r\n"Non presence of 32kHz clock",\r\n"Battery level lower than power on reset threshold",\r\n"Power on key 1 pressed longer than 10 seconds",\r\n"DB8500 thermal shutdown"};\r\nstatic char *turn_on_status[] = {\r\n"Battery rising (Vbat)",\r\n"Power On Key 1 dbF",\r\n"Power On Key 2 dbF",\r\n"RTC Alarm",\r\n"Main Charger Detect",\r\n"Vbus Detect (USB)",\r\n"USB ID Detect",\r\n"UART Factory Mode Detect"};\r\nstruct ab8500_platform_data *plat = dev_get_platdata(&pdev->dev);\r\nconst struct platform_device_id *platid = platform_get_device_id(pdev);\r\nenum ab8500_version version = AB8500_VERSION_UNDEFINED;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct ab8500 *ab8500;\r\nstruct resource *resource;\r\nint ret;\r\nint i;\r\nu8 value;\r\nab8500 = devm_kzalloc(&pdev->dev, sizeof *ab8500, GFP_KERNEL);\r\nif (!ab8500)\r\nreturn -ENOMEM;\r\nif (plat)\r\nab8500->irq_base = plat->irq_base;\r\nab8500->dev = &pdev->dev;\r\nresource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!resource)\r\nreturn -ENODEV;\r\nab8500->irq = resource->start;\r\nab8500->read = ab8500_prcmu_read;\r\nab8500->write = ab8500_prcmu_write;\r\nab8500->write_masked = ab8500_prcmu_write_masked;\r\nmutex_init(&ab8500->lock);\r\nmutex_init(&ab8500->irq_lock);\r\natomic_set(&ab8500->transfer_ongoing, 0);\r\nplatform_set_drvdata(pdev, ab8500);\r\nif (platid)\r\nversion = platid->driver_data;\r\nif (version != AB8500_VERSION_UNDEFINED)\r\nab8500->version = version;\r\nelse {\r\nret = get_register_interruptible(ab8500, AB8500_MISC,\r\nAB8500_IC_NAME_REG, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nab8500->version = value;\r\n}\r\nret = get_register_interruptible(ab8500, AB8500_MISC,\r\nAB8500_REV_REG, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nab8500->chip_id = value;\r\ndev_info(ab8500->dev, "detected chip, %s rev. %1x.%1x\n",\r\nab8500_version_str[ab8500->version],\r\nab8500->chip_id >> 4,\r\nab8500->chip_id & 0x0F);\r\nif (is_ab8540(ab8500)) {\r\nab8500->mask_size = AB8540_NUM_IRQ_REGS;\r\nab8500->irq_reg_offset = ab8540_irq_regoffset;\r\nab8500->it_latchhier_num = AB8540_IT_LATCHHIER_NUM;\r\n}\r\nelse if (is_ab9540(ab8500) || is_ab8505(ab8500)) {\r\nab8500->mask_size = AB9540_NUM_IRQ_REGS;\r\nab8500->irq_reg_offset = ab9540_irq_regoffset;\r\nab8500->it_latchhier_num = AB8500_IT_LATCHHIER_NUM;\r\n} else {\r\nab8500->mask_size = AB8500_NUM_IRQ_REGS;\r\nab8500->irq_reg_offset = ab8500_irq_regoffset;\r\nab8500->it_latchhier_num = AB8500_IT_LATCHHIER_NUM;\r\n}\r\nab8500->mask = devm_kzalloc(&pdev->dev, ab8500->mask_size, GFP_KERNEL);\r\nif (!ab8500->mask)\r\nreturn -ENOMEM;\r\nab8500->oldmask = devm_kzalloc(&pdev->dev, ab8500->mask_size, GFP_KERNEL);\r\nif (!ab8500->oldmask)\r\nreturn -ENOMEM;\r\nret = get_register_interruptible(ab8500, AB8500_RTC,\r\nAB8500_SWITCH_OFF_STATUS, &value);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(ab8500->dev, "switch off cause(s) (%#x): ", value);\r\nif (value) {\r\nfor (i = 0; i < ARRAY_SIZE(switch_off_status); i++) {\r\nif (value & 1)\r\nprintk(KERN_CONT " \"%s\"",\r\nswitch_off_status[i]);\r\nvalue = value >> 1;\r\n}\r\nprintk(KERN_CONT "\n");\r\n} else {\r\nprintk(KERN_CONT " None\n");\r\n}\r\nret = get_register_interruptible(ab8500, AB8500_SYS_CTRL1_BLOCK,\r\nAB8500_TURN_ON_STATUS, &value);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(ab8500->dev, "turn on reason(s) (%#x): ", value);\r\nif (value) {\r\nfor (i = 0; i < ARRAY_SIZE(turn_on_status); i++) {\r\nif (value & 1)\r\nprintk("\"%s\" ", turn_on_status[i]);\r\nvalue = value >> 1;\r\n}\r\nprintk("\n");\r\n} else {\r\nprintk("None\n");\r\n}\r\nif (plat && plat->init)\r\nplat->init(ab8500);\r\nif (is_ab9540(ab8500)) {\r\nret = get_register_interruptible(ab8500, AB8500_CHARGER,\r\nAB8500_CH_USBCH_STAT1_REG, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((value & VBUS_DET_DBNC1) && (value & VBUS_DET_DBNC100))\r\nab8500_override_turn_on_stat(~AB8500_POW_KEY_1_ON,\r\nAB8500_VBUS_DET);\r\n}\r\nfor (i = 0; i < ab8500->mask_size; i++) {\r\nif (ab8500->irq_reg_offset[i] == 11 &&\r\nis_ab8500_1p1_or_earlier(ab8500))\r\ncontinue;\r\nif (ab8500->irq_reg_offset[i] < 0)\r\ncontinue;\r\nget_register_interruptible(ab8500, AB8500_INTERRUPT,\r\nAB8500_IT_LATCH1_REG + ab8500->irq_reg_offset[i],\r\n&value);\r\nset_register_interruptible(ab8500, AB8500_INTERRUPT,\r\nAB8500_IT_MASK1_REG + ab8500->irq_reg_offset[i], 0xff);\r\n}\r\nret = abx500_register_ops(ab8500->dev, &ab8500_ops);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ab8500->mask_size; i++)\r\nab8500->mask[i] = ab8500->oldmask[i] = 0xff;\r\nret = ab8500_irq_init(ab8500, np);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_threaded_irq(&pdev->dev, ab8500->irq, NULL,\r\nab8500_hierarchical_irq,\r\nIRQF_ONESHOT | IRQF_NO_SUSPEND,\r\n"ab8500", ab8500);\r\nif (ret)\r\nreturn ret;\r\n#if CONFIG_DEBUG_FS\r\nab8500_debug_resources[0].start = ab8500->irq;\r\nab8500_debug_resources[0].end = ab8500->irq;\r\n#endif\r\nif (is_ab9540(ab8500))\r\nret = mfd_add_devices(ab8500->dev, 0, ab9540_devs,\r\nARRAY_SIZE(ab9540_devs), NULL,\r\nab8500->irq_base, ab8500->domain);\r\nelse if (is_ab8540(ab8500)) {\r\nret = mfd_add_devices(ab8500->dev, 0, ab8540_devs,\r\nARRAY_SIZE(ab8540_devs), NULL,\r\nab8500->irq_base, NULL);\r\nif (ret)\r\nreturn ret;\r\nif (is_ab8540_1p2_or_earlier(ab8500))\r\nret = mfd_add_devices(ab8500->dev, 0, ab8540_cut1_devs,\r\nARRAY_SIZE(ab8540_cut1_devs), NULL,\r\nab8500->irq_base, NULL);\r\nelse\r\nret = mfd_add_devices(ab8500->dev, 0, ab8540_cut2_devs,\r\nARRAY_SIZE(ab8540_cut2_devs), NULL,\r\nab8500->irq_base, NULL);\r\n} else if (is_ab8505(ab8500))\r\nret = mfd_add_devices(ab8500->dev, 0, ab8505_devs,\r\nARRAY_SIZE(ab8505_devs), NULL,\r\nab8500->irq_base, ab8500->domain);\r\nelse\r\nret = mfd_add_devices(ab8500->dev, 0, ab8500_devs,\r\nARRAY_SIZE(ab8500_devs), NULL,\r\nab8500->irq_base, ab8500->domain);\r\nif (ret)\r\nreturn ret;\r\nif (!no_bm) {\r\nret = mfd_add_devices(ab8500->dev, 0, ab8500_bm_devs,\r\nARRAY_SIZE(ab8500_bm_devs), NULL,\r\nab8500->irq_base, ab8500->domain);\r\nif (ret)\r\ndev_err(ab8500->dev, "error adding bm devices\n");\r\n}\r\nif (((is_ab8505(ab8500) || is_ab9540(ab8500)) &&\r\nab8500->chip_id >= AB8500_CUT2P0) || is_ab8540(ab8500))\r\nret = sysfs_create_group(&ab8500->dev->kobj,\r\n&ab9540_attr_group);\r\nelse\r\nret = sysfs_create_group(&ab8500->dev->kobj,\r\n&ab8500_attr_group);\r\nif ((is_ab8505(ab8500) || is_ab9540(ab8500)) &&\r\nab8500->chip_id >= AB8500_CUT2P0)\r\nret = sysfs_create_group(&ab8500->dev->kobj,\r\n&ab8505_attr_group);\r\nif (ret)\r\ndev_err(ab8500->dev, "error creating sysfs entries\n");\r\nreturn ret;\r\n}\r\nstatic int ab8500_remove(struct platform_device *pdev)\r\n{\r\nstruct ab8500 *ab8500 = platform_get_drvdata(pdev);\r\nif (((is_ab8505(ab8500) || is_ab9540(ab8500)) &&\r\nab8500->chip_id >= AB8500_CUT2P0) || is_ab8540(ab8500))\r\nsysfs_remove_group(&ab8500->dev->kobj, &ab9540_attr_group);\r\nelse\r\nsysfs_remove_group(&ab8500->dev->kobj, &ab8500_attr_group);\r\nif ((is_ab8505(ab8500) || is_ab9540(ab8500)) &&\r\nab8500->chip_id >= AB8500_CUT2P0)\r\nsysfs_remove_group(&ab8500->dev->kobj, &ab8505_attr_group);\r\nmfd_remove_devices(ab8500->dev);\r\nreturn 0;\r\n}\r\nstatic int __init ab8500_core_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_core_driver);\r\n}\r\nstatic void __exit ab8500_core_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_core_driver);\r\n}
