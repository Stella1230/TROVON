static uint32_t __sdb_rd(struct fmc_device *fmc, unsigned long address,\r\nint convert)\r\n{\r\nuint32_t res = fmc_readl(fmc, address);\r\nif (convert)\r\nreturn __be32_to_cpu(res);\r\nreturn res;\r\n}\r\nstatic struct sdb_array *__fmc_scan_sdb_tree(struct fmc_device *fmc,\r\nunsigned long sdb_addr,\r\nunsigned long reg_base, int level)\r\n{\r\nuint32_t onew;\r\nint i, j, n, convert = 0;\r\nstruct sdb_array *arr, *sub;\r\nonew = fmc_readl(fmc, sdb_addr);\r\nif (onew == SDB_MAGIC) {\r\nif (SDB_MAGIC != __be32_to_cpu(SDB_MAGIC))\r\nconvert = 1;\r\n} else if (onew == __be32_to_cpu(SDB_MAGIC)) {\r\n} else {\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nonew = __sdb_rd(fmc, sdb_addr + 4, convert);\r\nn = __be16_to_cpu(*(uint16_t *)&onew);\r\narr = kzalloc(sizeof(*arr), GFP_KERNEL);\r\nif (!arr)\r\nreturn ERR_PTR(-ENOMEM);\r\narr->record = kzalloc(sizeof(arr->record[0]) * n, GFP_KERNEL);\r\narr->subtree = kzalloc(sizeof(arr->subtree[0]) * n, GFP_KERNEL);\r\nif (!arr->record || !arr->subtree) {\r\nkfree(arr->record);\r\nkfree(arr->subtree);\r\nkfree(arr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\narr->len = n;\r\narr->level = level;\r\narr->fmc = fmc;\r\nfor (i = 0; i < n; i++) {\r\nunion sdb_record *r;\r\nfor (j = 0; j < sizeof(arr->record[0]); j += 4) {\r\n*(uint32_t *)((void *)(arr->record + i) + j) =\r\n__sdb_rd(fmc, sdb_addr + (i * 64) + j, convert);\r\n}\r\nr = &arr->record[i];\r\narr->subtree[i] = ERR_PTR(-ENODEV);\r\nif (r->empty.record_type == sdb_type_bridge) {\r\nstruct sdb_component *c = &r->bridge.sdb_component;\r\nuint64_t subaddr = __be64_to_cpu(r->bridge.sdb_child);\r\nuint64_t newbase = __be64_to_cpu(c->addr_first);\r\nsubaddr += reg_base;\r\nnewbase += reg_base;\r\nsub = __fmc_scan_sdb_tree(fmc, subaddr, newbase,\r\nlevel + 1);\r\narr->subtree[i] = sub;\r\nif (IS_ERR(sub))\r\ncontinue;\r\nsub->parent = arr;\r\nsub->baseaddr = newbase;\r\n}\r\n}\r\nreturn arr;\r\n}\r\nint fmc_scan_sdb_tree(struct fmc_device *fmc, unsigned long address)\r\n{\r\nstruct sdb_array *ret;\r\nif (fmc->sdb)\r\nreturn -EBUSY;\r\nret = __fmc_scan_sdb_tree(fmc, address, 0 , 0);\r\nif (IS_ERR(ret))\r\nreturn PTR_ERR(ret);\r\nfmc->sdb = ret;\r\nreturn 0;\r\n}\r\nstatic void __fmc_sdb_free(struct sdb_array *arr)\r\n{\r\nint i, n;\r\nif (!arr)\r\nreturn;\r\nn = arr->len;\r\nfor (i = 0; i < n; i++) {\r\nif (IS_ERR(arr->subtree[i]))\r\ncontinue;\r\n__fmc_sdb_free(arr->subtree[i]);\r\n}\r\nkfree(arr->record);\r\nkfree(arr->subtree);\r\nkfree(arr);\r\n}\r\nint fmc_free_sdb_tree(struct fmc_device *fmc)\r\n{\r\n__fmc_sdb_free(fmc->sdb);\r\nfmc->sdb = NULL;\r\nreturn 0;\r\n}\r\nint fmc_reprogram(struct fmc_device *fmc, struct fmc_driver *d, char *gw,\r\nint sdb_entry)\r\n{\r\nint ret;\r\nret = fmc->op->reprogram(fmc, d, gw);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sdb_entry < 0)\r\nreturn ret;\r\nret = fmc_scan_sdb_tree(fmc, sdb_entry);\r\nif (ret < 0) {\r\ndev_err(&fmc->dev, "Can't find SDB at address 0x%x\n",\r\nsdb_entry);\r\nreturn -ENODEV;\r\n}\r\nfmc_dump_sdb(fmc);\r\nreturn 0;\r\n}\r\nstatic void __fmc_show_sdb_tree(const struct fmc_device *fmc,\r\nconst struct sdb_array *arr)\r\n{\r\nint i, j, n = arr->len, level = arr->level;\r\nconst struct sdb_array *ap;\r\nfor (i = 0; i < n; i++) {\r\nunsigned long base;\r\nunion sdb_record *r;\r\nstruct sdb_product *p;\r\nstruct sdb_component *c;\r\nr = &arr->record[i];\r\nc = &r->dev.sdb_component;\r\np = &c->product;\r\nbase = 0;\r\nfor (ap = arr; ap; ap = ap->parent)\r\nbase += ap->baseaddr;\r\ndev_info(&fmc->dev, "SDB: ");\r\nfor (j = 0; j < level; j++)\r\nprintk(KERN_CONT " ");\r\nswitch (r->empty.record_type) {\r\ncase sdb_type_interconnect:\r\nprintk(KERN_CONT "%08llx:%08x %.19s\n",\r\n__be64_to_cpu(p->vendor_id),\r\n__be32_to_cpu(p->device_id),\r\np->name);\r\nbreak;\r\ncase sdb_type_device:\r\nprintk(KERN_CONT "%08llx:%08x %.19s (%08llx-%08llx)\n",\r\n__be64_to_cpu(p->vendor_id),\r\n__be32_to_cpu(p->device_id),\r\np->name,\r\n__be64_to_cpu(c->addr_first) + base,\r\n__be64_to_cpu(c->addr_last) + base);\r\nbreak;\r\ncase sdb_type_bridge:\r\nprintk(KERN_CONT "%08llx:%08x %.19s (bridge: %08llx)\n",\r\n__be64_to_cpu(p->vendor_id),\r\n__be32_to_cpu(p->device_id),\r\np->name,\r\n__be64_to_cpu(c->addr_first) + base);\r\nif (IS_ERR(arr->subtree[i])) {\r\nprintk(KERN_CONT "(bridge error %li)\n",\r\nPTR_ERR(arr->subtree[i]));\r\nbreak;\r\n}\r\n__fmc_show_sdb_tree(fmc, arr->subtree[i]);\r\nbreak;\r\ncase sdb_type_integration:\r\nprintk(KERN_CONT "integration\n");\r\nbreak;\r\ncase sdb_type_repo_url:\r\nprintk(KERN_CONT "repo-url\n");\r\nbreak;\r\ncase sdb_type_synthesis:\r\nprintk(KERN_CONT "synthesis-info\n");\r\nbreak;\r\ncase sdb_type_empty:\r\nprintk(KERN_CONT "empty\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_CONT "UNKNOWN TYPE 0x%02x\n",\r\nr->empty.record_type);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid fmc_show_sdb_tree(const struct fmc_device *fmc)\r\n{\r\nif (!fmc->sdb)\r\nreturn;\r\n__fmc_show_sdb_tree(fmc, fmc->sdb);\r\n}\r\nsigned long fmc_find_sdb_device(struct sdb_array *tree,\r\nuint64_t vid, uint32_t did, unsigned long *sz)\r\n{\r\nsigned long res = -ENODEV;\r\nunion sdb_record *r;\r\nstruct sdb_product *p;\r\nstruct sdb_component *c;\r\nint i, n = tree->len;\r\nuint64_t last, first;\r\nfor (i = 0; i < n; i++) {\r\nr = &tree->record[i];\r\nc = &r->dev.sdb_component;\r\np = &c->product;\r\nif (!IS_ERR(tree->subtree[i]))\r\nres = fmc_find_sdb_device(tree->subtree[i],\r\nvid, did, sz);\r\nif (res >= 0)\r\nreturn res + tree->baseaddr;\r\nif (r->empty.record_type != sdb_type_device)\r\ncontinue;\r\nif (__be64_to_cpu(p->vendor_id) != vid)\r\ncontinue;\r\nif (__be32_to_cpu(p->device_id) != did)\r\ncontinue;\r\nlast = __be64_to_cpu(c->addr_last);\r\nfirst = __be64_to_cpu(c->addr_first);\r\nif (sz)\r\n*sz = (typeof(*sz))(last + 1 - first);\r\nreturn first + tree->baseaddr;\r\n}\r\nreturn res;\r\n}
