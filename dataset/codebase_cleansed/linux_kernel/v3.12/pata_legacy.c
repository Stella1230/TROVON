static int legacy_probe_add(unsigned long port, unsigned int irq,\r\nenum controller type, unsigned long private)\r\n{\r\nstruct legacy_probe *lp = &probe_list[0];\r\nint i;\r\nstruct legacy_probe *free = NULL;\r\nfor (i = 0; i < NR_HOST; i++) {\r\nif (lp->port == 0 && free == NULL)\r\nfree = lp;\r\nif (lp->port == port || legacy_port[i] == port) {\r\nfree = lp;\r\nbreak;\r\n}\r\nlp++;\r\n}\r\nif (free == NULL) {\r\nprintk(KERN_ERR "pata_legacy: Too many interfaces.\n");\r\nreturn -1;\r\n}\r\nfree->port = port;\r\nfree->irq = irq;\r\nfree->type = type;\r\nfree->private = private;\r\nreturn 0;\r\n}\r\nstatic int legacy_set_mode(struct ata_link *link, struct ata_device **unused)\r\n{\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, link, ENABLED) {\r\nata_dev_info(dev, "configured for PIO\n");\r\ndev->pio_mode = XFER_PIO_0;\r\ndev->xfer_mode = XFER_PIO_0;\r\ndev->xfer_shift = ATA_SHIFT_PIO;\r\ndev->flags |= ATA_DFLAG_PIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pdc20230_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nint tries = 5;\r\nint pio = adev->pio_mode - XFER_PIO_0;\r\nu8 rt;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ndo {\r\ninb(0x1F5);\r\noutb(inb(0x1F2) | 0x80, 0x1F2);\r\ninb(0x1F2);\r\ninb(0x3F6);\r\ninb(0x3F6);\r\ninb(0x1F2);\r\ninb(0x1F2);\r\n}\r\nwhile ((inb(0x1F2) & 0x80) && --tries);\r\nlocal_irq_restore(flags);\r\noutb(inb(0x1F4) & 0x07, 0x1F4);\r\nrt = inb(0x1F3);\r\nrt &= 0x07 << (3 * adev->devno);\r\nif (pio)\r\nrt |= (1 + 3 * pio) << (3 * adev->devno);\r\nudelay(100);\r\noutb(inb(0x1F2) | 0x01, 0x1F2);\r\nudelay(100);\r\ninb(0x1F5);\r\n}\r\nstatic unsigned int pdc_data_xfer_vlb(struct ata_device *dev,\r\nunsigned char *buf, unsigned int buflen, int rw)\r\n{\r\nint slop = buflen & 3;\r\nstruct ata_port *ap = dev->link->ap;\r\nif (ata_id_has_dword_io(dev->id) && (slop == 0 || slop == 3)\r\n&& (ap->pflags & ATA_PFLAG_PIO32)) {\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nioread8(ap->ioaddr.nsect_addr);\r\nioread8(ap->ioaddr.nsect_addr);\r\nioread8(ap->ioaddr.nsect_addr);\r\nif (rw == READ)\r\nioread32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\r\nelse\r\niowrite32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\r\nif (unlikely(slop)) {\r\n__le32 pad;\r\nif (rw == READ) {\r\npad = cpu_to_le32(ioread32(ap->ioaddr.data_addr));\r\nmemcpy(buf + buflen - slop, &pad, slop);\r\n} else {\r\nmemcpy(&pad, buf + buflen - slop, slop);\r\niowrite32(le32_to_cpu(pad), ap->ioaddr.data_addr);\r\n}\r\nbuflen += 4 - slop;\r\n}\r\nlocal_irq_restore(flags);\r\n} else\r\nbuflen = ata_sff_data_xfer_noirq(dev, buf, buflen, rw);\r\nreturn buflen;\r\n}\r\nstatic void ht6560a_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nu8 active, recover;\r\nstruct ata_timing t;\r\nata_timing_compute(adev, adev->pio_mode, &t, 20000, 1000);\r\nactive = clamp_val(t.active, 2, 15);\r\nrecover = clamp_val(t.recover, 4, 15);\r\ninb(0x3E6);\r\ninb(0x3E6);\r\ninb(0x3E6);\r\ninb(0x3E6);\r\niowrite8(recover << 4 | active, ap->ioaddr.device_addr);\r\nioread8(ap->ioaddr.status_addr);\r\n}\r\nstatic void ht6560b_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nu8 active, recover;\r\nstruct ata_timing t;\r\nata_timing_compute(adev, adev->pio_mode, &t, 20000, 1000);\r\nactive = clamp_val(t.active, 2, 15);\r\nrecover = clamp_val(t.recover, 2, 16) & 0x0F;\r\ninb(0x3E6);\r\ninb(0x3E6);\r\ninb(0x3E6);\r\ninb(0x3E6);\r\niowrite8(recover << 4 | active, ap->ioaddr.device_addr);\r\nif (adev->class != ATA_DEV_ATA) {\r\nu8 rconf = inb(0x3E6);\r\nif (rconf & 0x24) {\r\nrconf &= ~0x24;\r\noutb(rconf, 0x3E6);\r\n}\r\n}\r\nioread8(ap->ioaddr.status_addr);\r\n}\r\nstatic u8 opti_syscfg(u8 reg)\r\n{\r\nunsigned long flags;\r\nu8 r;\r\nlocal_irq_save(flags);\r\noutb(reg, 0x22);\r\nr = inb(0x24);\r\nlocal_irq_restore(flags);\r\nreturn r;\r\n}\r\nstatic void opti82c611a_set_piomode(struct ata_port *ap,\r\nstruct ata_device *adev)\r\n{\r\nu8 active, recover, setup;\r\nstruct ata_timing t;\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nint clock;\r\nint khz[4] = { 50000, 40000, 33000, 25000 };\r\nu8 rc;\r\nioread16(ap->ioaddr.error_addr);\r\nioread16(ap->ioaddr.error_addr);\r\niowrite8(3, ap->ioaddr.nsect_addr);\r\nclock = 1000000000 / khz[ioread8(ap->ioaddr.lbah_addr) & 0x03];\r\nata_timing_compute(adev, adev->pio_mode, &t, clock, 1000);\r\nif (pair) {\r\nstruct ata_timing tp;\r\nata_timing_compute(pair, pair->pio_mode, &tp, clock, 1000);\r\nata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\r\n}\r\nactive = clamp_val(t.active, 2, 17) - 2;\r\nrecover = clamp_val(t.recover, 1, 16) - 1;\r\nsetup = clamp_val(t.setup, 1, 4) - 1;\r\nrc = ioread8(ap->ioaddr.lbal_addr);\r\nrc &= 0x7F;\r\nrc |= (adev->devno << 7);\r\niowrite8(rc, ap->ioaddr.lbal_addr);\r\niowrite8(active << 4 | recover, ap->ioaddr.error_addr);\r\nrc = ioread8(ap->ioaddr.device_addr);\r\nrc &= 0xC0;\r\nrc |= adev->devno;\r\nrc |= (setup << 4) | 0x04;\r\niowrite8(rc, ap->ioaddr.device_addr);\r\niowrite8(active << 4 | recover, ap->ioaddr.data_addr);\r\nrc = ioread8(ap->ioaddr.lbal_addr);\r\nrc &= 0x73;\r\nrc |= 0x84;\r\niowrite8(rc, ap->ioaddr.lbal_addr);\r\niowrite8(0x83, ap->ioaddr.nsect_addr);\r\n}\r\nstatic void opti82c46x_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nu8 active, recover, setup;\r\nstruct ata_timing t;\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nint clock;\r\nint khz[4] = { 50000, 40000, 33000, 25000 };\r\nu8 rc;\r\nu8 sysclk;\r\nsysclk = (opti_syscfg(0xAC) & 0xC0) >> 6;\r\nioread16(ap->ioaddr.error_addr);\r\nioread16(ap->ioaddr.error_addr);\r\niowrite8(3, ap->ioaddr.nsect_addr);\r\nclock = 1000000000 / khz[sysclk];\r\nata_timing_compute(adev, adev->pio_mode, &t, clock, 1000);\r\nif (pair) {\r\nstruct ata_timing tp;\r\nata_timing_compute(pair, pair->pio_mode, &tp, clock, 1000);\r\nata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\r\n}\r\nactive = clamp_val(t.active, 2, 17) - 2;\r\nrecover = clamp_val(t.recover, 1, 16) - 1;\r\nsetup = clamp_val(t.setup, 1, 4) - 1;\r\nrc = ioread8(ap->ioaddr.lbal_addr);\r\nrc &= 0x7F;\r\nrc |= (adev->devno << 7);\r\niowrite8(rc, ap->ioaddr.lbal_addr);\r\niowrite8(active << 4 | recover, ap->ioaddr.error_addr);\r\nrc = ioread8(ap->ioaddr.device_addr);\r\nrc &= 0xC0;\r\nrc |= adev->devno;\r\nrc |= (setup << 4) | 0x04;\r\niowrite8(rc, ap->ioaddr.device_addr);\r\niowrite8(active << 4 | recover, ap->ioaddr.data_addr);\r\nrc = ioread8(ap->ioaddr.lbal_addr);\r\nrc &= 0x73;\r\nrc |= 0x84;\r\niowrite8(rc, ap->ioaddr.lbal_addr);\r\niowrite8(0x83, ap->ioaddr.nsect_addr);\r\nap->host->private_data = ap;\r\n}\r\nstatic unsigned int opti82c46x_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nif (ap->host->private_data != ap->host\r\n&& ap->host->private_data != NULL)\r\nopti82c46x_set_piomode(ap, adev);\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nstatic void qdi65x0_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_timing t;\r\nstruct legacy_data *ld_qdi = ap->host->private_data;\r\nint active, recovery;\r\nu8 timing;\r\nata_timing_compute(adev, adev->pio_mode, &t, 30303, 1000);\r\nif (ld_qdi->fast) {\r\nactive = 8 - clamp_val(t.active, 1, 8);\r\nrecovery = 18 - clamp_val(t.recover, 3, 18);\r\n} else {\r\nactive = 9 - clamp_val(t.active, 2, 9);\r\nrecovery = 15 - clamp_val(t.recover, 0, 15);\r\n}\r\ntiming = (recovery << 4) | active | 0x08;\r\nld_qdi->clock[adev->devno] = timing;\r\nif (ld_qdi->type == QDI6580)\r\noutb(timing, ld_qdi->timing + 2 * adev->devno);\r\nelse\r\noutb(timing, ld_qdi->timing + 2 * ap->port_no);\r\nif (ld_qdi->type != QDI6500 && adev->class != ATA_DEV_ATA)\r\noutb(0x5F, (ld_qdi->timing & 0xFFF0) + 3);\r\n}\r\nstatic unsigned int qdi_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct legacy_data *ld_qdi = ap->host->private_data;\r\nif (ld_qdi->clock[adev->devno] != ld_qdi->last) {\r\nif (adev->pio_mode) {\r\nld_qdi->last = ld_qdi->clock[adev->devno];\r\noutb(ld_qdi->clock[adev->devno], ld_qdi->timing +\r\n2 * ap->port_no);\r\n}\r\n}\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nstatic unsigned int vlb32_data_xfer(struct ata_device *adev, unsigned char *buf,\r\nunsigned int buflen, int rw)\r\n{\r\nstruct ata_port *ap = adev->link->ap;\r\nint slop = buflen & 3;\r\nif (ata_id_has_dword_io(adev->id) && (slop == 0 || slop == 3)\r\n&& (ap->pflags & ATA_PFLAG_PIO32)) {\r\nif (rw == WRITE)\r\niowrite32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\r\nelse\r\nioread32_rep(ap->ioaddr.data_addr, buf, buflen >> 2);\r\nif (unlikely(slop)) {\r\n__le32 pad;\r\nif (rw == WRITE) {\r\nmemcpy(&pad, buf + buflen - slop, slop);\r\niowrite32(le32_to_cpu(pad), ap->ioaddr.data_addr);\r\n} else {\r\npad = cpu_to_le32(ioread32(ap->ioaddr.data_addr));\r\nmemcpy(buf + buflen - slop, &pad, slop);\r\n}\r\n}\r\nreturn (buflen + 3) & ~3;\r\n} else\r\nreturn ata_sff_data_xfer(adev, buf, buflen, rw);\r\n}\r\nstatic int qdi_port(struct platform_device *dev,\r\nstruct legacy_probe *lp, struct legacy_data *ld)\r\n{\r\nif (devm_request_region(&dev->dev, lp->private, 4, "qdi") == NULL)\r\nreturn -EBUSY;\r\nld->timing = lp->private;\r\nreturn 0;\r\n}\r\nstatic void winbond_writecfg(unsigned long port, u8 reg, u8 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&winbond_lock, flags);\r\noutb(reg, port + 0x01);\r\noutb(val, port + 0x02);\r\nspin_unlock_irqrestore(&winbond_lock, flags);\r\n}\r\nstatic u8 winbond_readcfg(unsigned long port, u8 reg)\r\n{\r\nu8 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&winbond_lock, flags);\r\noutb(reg, port + 0x01);\r\nval = inb(port + 0x02);\r\nspin_unlock_irqrestore(&winbond_lock, flags);\r\nreturn val;\r\n}\r\nstatic void winbond_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_timing t;\r\nstruct legacy_data *ld_winbond = ap->host->private_data;\r\nint active, recovery;\r\nu8 reg;\r\nint timing = 0x88 + (ap->port_no * 4) + (adev->devno * 2);\r\nreg = winbond_readcfg(ld_winbond->timing, 0x81);\r\nif (reg & 0x40)\r\nata_timing_compute(adev, adev->pio_mode, &t, 20000, 1000);\r\nelse\r\nata_timing_compute(adev, adev->pio_mode, &t, 30303, 1000);\r\nactive = (clamp_val(t.active, 3, 17) - 1) & 0x0F;\r\nrecovery = (clamp_val(t.recover, 1, 15) + 1) & 0x0F;\r\ntiming = (active << 4) | recovery;\r\nwinbond_writecfg(ld_winbond->timing, timing, reg);\r\nreg = 0x35;\r\nif (adev->class != ATA_DEV_ATA)\r\nreg |= 0x08;\r\nif (!ata_pio_need_iordy(adev))\r\nreg |= 0x02;\r\nreg |= (clamp_val(t.setup, 0, 3) << 6);\r\nwinbond_writecfg(ld_winbond->timing, timing + 1, reg);\r\n}\r\nstatic int winbond_port(struct platform_device *dev,\r\nstruct legacy_probe *lp, struct legacy_data *ld)\r\n{\r\nif (devm_request_region(&dev->dev, lp->private, 4, "winbond") == NULL)\r\nreturn -EBUSY;\r\nld->timing = lp->private;\r\nreturn 0;\r\n}\r\nstatic __init int probe_chip_type(struct legacy_probe *probe)\r\n{\r\nint mask = 1 << probe->slot;\r\nif (winbond && (probe->port == 0x1F0 || probe->port == 0x170)) {\r\nu8 reg = winbond_readcfg(winbond, 0x81);\r\nreg |= 0x80;\r\nwinbond_writecfg(winbond, 0x81, reg);\r\nreg = winbond_readcfg(winbond, 0x83);\r\nreg |= 0xF0;\r\nwinbond_writecfg(winbond, 0x83, reg);\r\nreg = winbond_readcfg(winbond, 0x85);\r\nreg |= 0xF0;\r\nwinbond_writecfg(winbond, 0x85, reg);\r\nreg = winbond_readcfg(winbond, 0x81);\r\nif (reg & mask)\r\nreturn W83759A;\r\n}\r\nif (probe->port == 0x1F0) {\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\noutb(inb(0x1F2) | 0x80, 0x1F2);\r\ninb(0x1F5);\r\ninb(0x1F2);\r\ninb(0x3F6);\r\ninb(0x3F6);\r\ninb(0x1F2);\r\ninb(0x1F2);\r\nif ((inb(0x1F2) & 0x80) == 0) {\r\nprintk(KERN_INFO "PDC20230-C/20630 VLB ATA controller"\r\n" detected.\n");\r\nudelay(100);\r\ninb(0x1F5);\r\nlocal_irq_restore(flags);\r\nreturn PDC20230;\r\n} else {\r\noutb(0x55, 0x1F2);\r\ninb(0x1F2);\r\ninb(0x1F2);\r\nif (inb(0x1F2) == 0x00)\r\nprintk(KERN_INFO "PDC20230-B VLB ATA "\r\n"controller detected.\n");\r\nlocal_irq_restore(flags);\r\nreturn BIOS;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nif (ht6560a & mask)\r\nreturn HT6560A;\r\nif (ht6560b & mask)\r\nreturn HT6560B;\r\nif (opti82c611a & mask)\r\nreturn OPTI611A;\r\nif (opti82c46x & mask)\r\nreturn OPTI46X;\r\nif (autospeed & mask)\r\nreturn SNOOP;\r\nreturn BIOS;\r\n}\r\nstatic __init int legacy_init_one(struct legacy_probe *probe)\r\n{\r\nstruct legacy_controller *controller = &controllers[probe->type];\r\nint pio_modes = controller->pio_mask;\r\nunsigned long io = probe->port;\r\nu32 mask = (1 << probe->slot);\r\nstruct ata_port_operations *ops = controller->ops;\r\nstruct legacy_data *ld = &legacy_data[probe->slot];\r\nstruct ata_host *host = NULL;\r\nstruct ata_port *ap;\r\nstruct platform_device *pdev;\r\nstruct ata_device *dev;\r\nvoid __iomem *io_addr, *ctrl_addr;\r\nu32 iordy = (iordy_mask & mask) ? 0: ATA_FLAG_NO_IORDY;\r\nint ret;\r\niordy |= controller->flags;\r\npdev = platform_device_register_simple(DRV_NAME, probe->slot, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nret = -EBUSY;\r\nif (devm_request_region(&pdev->dev, io, 8, "pata_legacy") == NULL ||\r\ndevm_request_region(&pdev->dev, io + 0x0206, 1,\r\n"pata_legacy") == NULL)\r\ngoto fail;\r\nret = -ENOMEM;\r\nio_addr = devm_ioport_map(&pdev->dev, io, 8);\r\nctrl_addr = devm_ioport_map(&pdev->dev, io + 0x0206, 1);\r\nif (!io_addr || !ctrl_addr)\r\ngoto fail;\r\nld->type = probe->type;\r\nif (controller->setup)\r\nif (controller->setup(pdev, probe, ld) < 0)\r\ngoto fail;\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host)\r\ngoto fail;\r\nap = host->ports[0];\r\nap->ops = ops;\r\nap->pio_mask = pio_modes;\r\nap->flags |= ATA_FLAG_SLAVE_POSS | iordy;\r\nap->pflags |= controller->pflags;\r\nap->ioaddr.cmd_addr = io_addr;\r\nap->ioaddr.altstatus_addr = ctrl_addr;\r\nap->ioaddr.ctl_addr = ctrl_addr;\r\nata_sff_std_ports(&ap->ioaddr);\r\nap->host->private_data = ld;\r\nata_port_desc(ap, "cmd 0x%lx ctl 0x%lx", io, io + 0x0206);\r\nret = ata_host_activate(host, probe->irq, ata_sff_interrupt, 0,\r\n&legacy_sht);\r\nif (ret)\r\ngoto fail;\r\nasync_synchronize_full();\r\nld->platform_dev = pdev;\r\nret = -ENODEV;\r\nata_for_each_dev(dev, &ap->link, ALL) {\r\nif (!ata_dev_absent(dev)) {\r\nlegacy_host[probe->slot] = host;\r\nld->platform_dev = pdev;\r\nreturn 0;\r\n}\r\n}\r\nata_host_detach(host);\r\nfail:\r\nplatform_device_unregister(pdev);\r\nreturn ret;\r\n}\r\nstatic void __init legacy_check_special_cases(struct pci_dev *p, int *primary,\r\nint *secondary)\r\n{\r\nif (p->vendor == 0x1078 && p->device == 0x0000) {\r\n*primary = *secondary = 1;\r\nreturn;\r\n}\r\nif (p->vendor == 0x1078 && p->device == 0x0002) {\r\n*primary = *secondary = 1;\r\nreturn;\r\n}\r\nif (p->vendor == 0x8086 && p->device == 0x1234) {\r\nu16 r;\r\npci_read_config_word(p, 0x6C, &r);\r\nif (r & 0x8000) {\r\nif (r & 0x4000)\r\n*secondary = 1;\r\nelse\r\n*primary = 1;\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic __init void probe_opti_vlb(void)\r\n{\r\nstatic const char *optis[4] = {\r\n"3/463MV", "5MV",\r\n"5MVA", "5MVB"\r\n};\r\nu8 chans = 1;\r\nu8 ctrl = (opti_syscfg(0x30) & 0xC0) >> 6;\r\nopti82c46x = 3;\r\nprintk(KERN_INFO DRV_NAME ": Opti 82C46%s chipset support.\n",\r\noptis[ctrl]);\r\nif (ctrl == 3)\r\nchans = (opti_syscfg(0x3F) & 0x20) ? 2 : 1;\r\nctrl = opti_syscfg(0xAC);\r\nif (ctrl & 8) {\r\nif (chans == 2) {\r\nlegacy_probe_add(0x1F0, 14, OPTI46X, 0);\r\nlegacy_probe_add(0x170, 15, OPTI46X, 0);\r\n}\r\nif (ctrl & 4)\r\nlegacy_probe_add(0x170, 15, OPTI46X, 0);\r\nelse\r\nlegacy_probe_add(0x1F0, 14, OPTI46X, 0);\r\n} else\r\nlegacy_probe_add(0x1F0, 14, OPTI46X, 0);\r\n}\r\nstatic __init void qdi65_identify_port(u8 r, u8 res, unsigned long port)\r\n{\r\nstatic const unsigned long ide_port[2] = { 0x170, 0x1F0 };\r\nif ((r & 0xF0) == 0xC0) {\r\nif (r & 8)\r\nreturn;\r\nlegacy_probe_add(ide_port[r & 0x01], 14 + (r & 0x01),\r\nQDI6500, port);\r\n}\r\nif (((r & 0xF0) == 0xA0) || (r & 0xF0) == 0x50) {\r\nif (!request_region(port + 2 , 2, "pata_qdi")) {\r\nrelease_region(port, 2);\r\nreturn;\r\n}\r\nres = inb(port + 3);\r\nif (res & 1)\r\nlegacy_probe_add(ide_port[r & 0x01], 14 + (r & 0x01),\r\nQDI6580, port);\r\nelse {\r\nlegacy_probe_add(0x1F0, 14, QDI6580DP, port);\r\nlegacy_probe_add(0x170, 15, QDI6580DP, port + 2);\r\n}\r\nrelease_region(port + 2, 2);\r\n}\r\n}\r\nstatic __init void probe_qdi_vlb(void)\r\n{\r\nunsigned long flags;\r\nstatic const unsigned long qd_port[2] = { 0x30, 0xB0 };\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nunsigned long port = qd_port[i];\r\nu8 r, res;\r\nif (request_region(port, 2, "pata_qdi")) {\r\nlocal_irq_save(flags);\r\nr = inb(port);\r\nudelay(1);\r\noutb(0x19, port);\r\nudelay(1);\r\nres = inb(port);\r\nudelay(1);\r\noutb(r, port);\r\nudelay(1);\r\nlocal_irq_restore(flags);\r\nif (res == 0x19) {\r\nrelease_region(port, 2);\r\ncontinue;\r\n}\r\nr = inb(port + 1);\r\nudelay(1);\r\nif ((r & 2) >> 1 == i)\r\nqdi65_identify_port(r, res, port);\r\nrelease_region(port, 2);\r\n}\r\n}\r\n}\r\nstatic __init int legacy_init(void)\r\n{\r\nint i;\r\nint ct = 0;\r\nint primary = 0;\r\nint secondary = 0;\r\nint pci_present = 0;\r\nstruct legacy_probe *pl = &probe_list[0];\r\nint slot = 0;\r\nstruct pci_dev *p = NULL;\r\nfor_each_pci_dev(p) {\r\nint r;\r\nfor (r = 0; r < 6; r++) {\r\nif (pci_resource_start(p, r) == 0x1f0)\r\nprimary = 1;\r\nif (pci_resource_start(p, r) == 0x170)\r\nsecondary = 1;\r\n}\r\nlegacy_check_special_cases(p, &primary, &secondary);\r\npci_present = 1;\r\n}\r\nif (winbond == 1)\r\nwinbond = 0x130;\r\nif (primary == 0 || all)\r\nlegacy_probe_add(0x1F0, 14, UNKNOWN, 0);\r\nif (secondary == 0 || all)\r\nlegacy_probe_add(0x170, 15, UNKNOWN, 0);\r\nif (probe_all || !pci_present) {\r\nlegacy_probe_add(0x1E8, 11, UNKNOWN, 0);\r\nlegacy_probe_add(0x168, 10, UNKNOWN, 0);\r\nlegacy_probe_add(0x1E0, 8, UNKNOWN, 0);\r\nlegacy_probe_add(0x160, 12, UNKNOWN, 0);\r\n}\r\nif (opti82c46x)\r\nprobe_opti_vlb();\r\nif (qdi)\r\nprobe_qdi_vlb();\r\nfor (i = 0; i < NR_HOST; i++, pl++) {\r\nif (pl->port == 0)\r\ncontinue;\r\nif (pl->type == UNKNOWN)\r\npl->type = probe_chip_type(pl);\r\npl->slot = slot++;\r\nif (legacy_init_one(pl) == 0)\r\nct++;\r\n}\r\nif (ct != 0)\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic __exit void legacy_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_legacy_host; i++) {\r\nstruct legacy_data *ld = &legacy_data[i];\r\nata_host_detach(legacy_host[i]);\r\nplatform_device_unregister(ld->platform_dev);\r\n}\r\n}
