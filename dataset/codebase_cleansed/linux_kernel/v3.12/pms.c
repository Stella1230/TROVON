static inline void mvv_write(struct pms *dev, u8 index, u8 value)\r\n{\r\noutw(index | (value << 8), dev->io);\r\n}\r\nstatic inline u8 mvv_read(struct pms *dev, u8 index)\r\n{\r\noutb(index, dev->io);\r\nreturn inb(dev->data);\r\n}\r\nstatic int pms_i2c_stat(struct pms *dev, u8 slave)\r\n{\r\nint counter = 0;\r\nint i;\r\noutb(0x28, dev->io);\r\nwhile ((inb(dev->data) & 0x01) == 0)\r\nif (counter++ == 256)\r\nbreak;\r\nwhile ((inb(dev->data) & 0x01) != 0)\r\nif (counter++ == 256)\r\nbreak;\r\noutb(slave, dev->io);\r\ncounter = 0;\r\nwhile ((inb(dev->data) & 0x01) == 0)\r\nif (counter++ == 256)\r\nbreak;\r\nwhile ((inb(dev->data) & 0x01) != 0)\r\nif (counter++ == 256)\r\nbreak;\r\nfor (i = 0; i < 12; i++) {\r\nchar st = inb(dev->data);\r\nif ((st & 2) != 0)\r\nreturn -1;\r\nif ((st & 1) == 0)\r\nbreak;\r\n}\r\noutb(0x29, dev->io);\r\nreturn inb(dev->data);\r\n}\r\nstatic int pms_i2c_write(struct pms *dev, u16 slave, u16 sub, u16 data)\r\n{\r\nint skip = 0;\r\nint count;\r\nint i;\r\nfor (i = 0; i < dev->i2c_count; i++) {\r\nif ((dev->i2cinfo[i].slave == slave) &&\r\n(dev->i2cinfo[i].sub == sub)) {\r\nif (dev->i2cinfo[i].data == data)\r\nskip = 1;\r\ndev->i2cinfo[i].data = data;\r\ni = dev->i2c_count + 1;\r\n}\r\n}\r\nif (i == dev->i2c_count && dev->i2c_count < 64) {\r\ndev->i2cinfo[dev->i2c_count].slave = slave;\r\ndev->i2cinfo[dev->i2c_count].sub = sub;\r\ndev->i2cinfo[dev->i2c_count].data = data;\r\ndev->i2c_count++;\r\n}\r\nif (skip)\r\nreturn 0;\r\nmvv_write(dev, 0x29, sub);\r\nmvv_write(dev, 0x2A, data);\r\nmvv_write(dev, 0x28, slave);\r\noutb(0x28, dev->io);\r\ncount = 0;\r\nwhile ((inb(dev->data) & 1) == 0)\r\nif (count > 255)\r\nbreak;\r\nwhile ((inb(dev->data) & 1) != 0)\r\nif (count > 255)\r\nbreak;\r\ncount = inb(dev->data);\r\nif (count & 2)\r\nreturn -1;\r\nreturn count;\r\n}\r\nstatic int pms_i2c_read(struct pms *dev, int slave, int sub)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->i2c_count; i++) {\r\nif (dev->i2cinfo[i].slave == slave && dev->i2cinfo[i].sub == sub)\r\nreturn dev->i2cinfo[i].data;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pms_i2c_andor(struct pms *dev, int slave, int sub, int and, int or)\r\n{\r\nu8 tmp;\r\ntmp = pms_i2c_read(dev, slave, sub);\r\ntmp = (tmp & and) | or;\r\npms_i2c_write(dev, slave, sub, tmp);\r\n}\r\nstatic void pms_videosource(struct pms *dev, short source)\r\n{\r\nswitch (dev->decoder) {\r\ncase MOTOROLA:\r\nbreak;\r\ncase PHILIPS2:\r\npms_i2c_andor(dev, 0x8a, 0x06, 0x7f, source ? 0x80 : 0);\r\nbreak;\r\ncase PHILIPS1:\r\nbreak;\r\n}\r\nmvv_write(dev, 0x2E, 0x31);\r\n}\r\nstatic void pms_hue(struct pms *dev, short hue)\r\n{\r\nswitch (dev->decoder) {\r\ncase MOTOROLA:\r\npms_i2c_write(dev, 0x8a, 0x00, hue);\r\nbreak;\r\ncase PHILIPS2:\r\npms_i2c_write(dev, 0x8a, 0x07, hue);\r\nbreak;\r\ncase PHILIPS1:\r\npms_i2c_write(dev, 0x42, 0x07, hue);\r\nbreak;\r\n}\r\n}\r\nstatic void pms_saturation(struct pms *dev, short sat)\r\n{\r\nswitch (dev->decoder) {\r\ncase MOTOROLA:\r\npms_i2c_write(dev, 0x8a, 0x00, sat);\r\nbreak;\r\ncase PHILIPS1:\r\npms_i2c_write(dev, 0x42, 0x12, sat);\r\nbreak;\r\n}\r\n}\r\nstatic void pms_contrast(struct pms *dev, short contrast)\r\n{\r\nswitch (dev->decoder) {\r\ncase MOTOROLA:\r\npms_i2c_write(dev, 0x8a, 0x00, contrast);\r\nbreak;\r\ncase PHILIPS1:\r\npms_i2c_write(dev, 0x42, 0x13, contrast);\r\nbreak;\r\n}\r\n}\r\nstatic void pms_brightness(struct pms *dev, short brightness)\r\n{\r\nswitch (dev->decoder) {\r\ncase MOTOROLA:\r\npms_i2c_write(dev, 0x8a, 0x00, brightness);\r\npms_i2c_write(dev, 0x8a, 0x00, brightness);\r\npms_i2c_write(dev, 0x8a, 0x00, brightness);\r\nbreak;\r\ncase PHILIPS1:\r\npms_i2c_write(dev, 0x42, 0x19, brightness);\r\nbreak;\r\n}\r\n}\r\nstatic void pms_format(struct pms *dev, short format)\r\n{\r\nint target;\r\ndev->standard = format;\r\nif (dev->decoder == PHILIPS1)\r\ntarget = 0x42;\r\nelse if (dev->decoder == PHILIPS2)\r\ntarget = 0x8a;\r\nelse\r\nreturn;\r\nswitch (format) {\r\ncase 0:\r\npms_i2c_andor(dev, target, 0x0d, 0xfe, 0x00);\r\npms_i2c_andor(dev, target, 0x0f, 0x3f, 0x80);\r\nbreak;\r\ncase 1:\r\npms_i2c_andor(dev, target, 0x0d, 0xfe, 0x00);\r\npms_i2c_andor(dev, target, 0x0f, 0x3f, 0x40);\r\nbreak;\r\ncase 2:\r\npms_i2c_andor(dev, target, 0x0d, 0xfe, 0x00);\r\npms_i2c_andor(dev, target, 0x0f, 0x3f, 0x00);\r\nbreak;\r\ncase 3:\r\npms_i2c_andor(dev, target, 0x0d, 0xfe, 0x01);\r\npms_i2c_andor(dev, target, 0x0f, 0x3f, 0x00);\r\nbreak;\r\n}\r\n}\r\nstatic void pms_hstart(struct pms *dev, short start)\r\n{\r\nswitch (dev->decoder) {\r\ncase PHILIPS1:\r\npms_i2c_write(dev, 0x8a, 0x05, start);\r\npms_i2c_write(dev, 0x8a, 0x18, start);\r\nbreak;\r\ncase PHILIPS2:\r\npms_i2c_write(dev, 0x42, 0x05, start);\r\npms_i2c_write(dev, 0x42, 0x18, start);\r\nbreak;\r\n}\r\n}\r\nstatic void pms_bandpass(struct pms *dev, short pass)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x06, 0xcf, (pass & 0x03) << 4);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x06, 0xcf, (pass & 0x03) << 4);\r\n}\r\nstatic void pms_antisnow(struct pms *dev, short snow)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x06, 0xf3, (snow & 0x03) << 2);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x06, 0xf3, (snow & 0x03) << 2);\r\n}\r\nstatic void pms_sharpness(struct pms *dev, short sharp)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x06, 0xfc, sharp & 0x03);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x06, 0xfc, sharp & 0x03);\r\n}\r\nstatic void pms_chromaagc(struct pms *dev, short agc)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x0c, 0x9f, (agc & 0x03) << 5);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x0c, 0x9f, (agc & 0x03) << 5);\r\n}\r\nstatic void pms_vertnoise(struct pms *dev, short noise)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x10, 0xfc, noise & 3);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x10, 0xfc, noise & 3);\r\n}\r\nstatic void pms_forcecolour(struct pms *dev, short colour)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x0c, 0x7f, (colour & 1) << 7);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x0c, 0x7, (colour & 1) << 7);\r\n}\r\nstatic void pms_antigamma(struct pms *dev, short gamma)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0xb8, 0x00, 0x7f, (gamma & 1) << 7);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x20, 0x7, (gamma & 1) << 7);\r\n}\r\nstatic void pms_prefilter(struct pms *dev, short filter)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x06, 0xbf, (filter & 1) << 6);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x06, 0xbf, (filter & 1) << 6);\r\n}\r\nstatic void pms_hfilter(struct pms *dev, short filter)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0xb8, 0x04, 0x1f, (filter & 7) << 5);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x24, 0x1f, (filter & 7) << 5);\r\n}\r\nstatic void pms_vfilter(struct pms *dev, short filter)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0xb8, 0x08, 0x9f, (filter & 3) << 5);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x28, 0x9f, (filter & 3) << 5);\r\n}\r\nstatic void pms_killcolour(struct pms *dev, short colour)\r\n{\r\nif (dev->decoder == PHILIPS2) {\r\npms_i2c_andor(dev, 0x8a, 0x08, 0x07, (colour & 0x1f) << 3);\r\npms_i2c_andor(dev, 0x8a, 0x09, 0x07, (colour & 0x1f) << 3);\r\n} else if (dev->decoder == PHILIPS1) {\r\npms_i2c_andor(dev, 0x42, 0x08, 0x07, (colour & 0x1f) << 3);\r\npms_i2c_andor(dev, 0x42, 0x09, 0x07, (colour & 0x1f) << 3);\r\n}\r\n}\r\nstatic void pms_chromagain(struct pms *dev, short chroma)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_write(dev, 0x8a, 0x11, chroma);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_write(dev, 0x42, 0x11, chroma);\r\n}\r\nstatic void pms_spacialcompl(struct pms *dev, short data)\r\n{\r\nmvv_write(dev, 0x3b, data);\r\n}\r\nstatic void pms_spacialcomph(struct pms *dev, short data)\r\n{\r\nmvv_write(dev, 0x3a, data);\r\n}\r\nstatic void pms_vstart(struct pms *dev, short start)\r\n{\r\nmvv_write(dev, 0x16, start);\r\nmvv_write(dev, 0x17, (start >> 8) & 0x01);\r\n}\r\nstatic void pms_secamcross(struct pms *dev, short cross)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x0f, 0xdf, (cross & 1) << 5);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x0f, 0xdf, (cross & 1) << 5);\r\n}\r\nstatic void pms_swsense(struct pms *dev, short sense)\r\n{\r\nif (dev->decoder == PHILIPS2) {\r\npms_i2c_write(dev, 0x8a, 0x0a, sense);\r\npms_i2c_write(dev, 0x8a, 0x0b, sense);\r\n} else if (dev->decoder == PHILIPS1) {\r\npms_i2c_write(dev, 0x42, 0x0a, sense);\r\npms_i2c_write(dev, 0x42, 0x0b, sense);\r\n}\r\n}\r\nstatic void pms_framerate(struct pms *dev, short frr)\r\n{\r\nint fps = (dev->std & V4L2_STD_525_60) ? 30 : 25;\r\nif (frr == 0)\r\nreturn;\r\nfps = fps/frr;\r\nmvv_write(dev, 0x14, 0x80 | fps);\r\nmvv_write(dev, 0x15, 1);\r\n}\r\nstatic void pms_vert(struct pms *dev, u8 deciden, u8 decinum)\r\n{\r\nmvv_write(dev, 0x1c, deciden);\r\nmvv_write(dev, 0x1d, decinum);\r\n}\r\nstatic void pms_vertdeci(struct pms *dev, unsigned short decinum, unsigned short deciden)\r\n{\r\nif (decinum % 5 == 0) {\r\ndeciden /= 5;\r\ndecinum /= 5;\r\n}\r\nwhile (decinum % 3 == 0 && deciden % 3 == 0) {\r\ndeciden /= 3;\r\ndecinum /= 3;\r\n}\r\nwhile (decinum % 2 == 0 && deciden % 2 == 0) {\r\ndecinum /= 2;\r\ndeciden /= 2;\r\n}\r\nwhile (deciden > 32) {\r\ndeciden /= 2;\r\ndecinum = (decinum + 1) / 2;\r\n}\r\nif (deciden == 32)\r\ndeciden--;\r\npms_vert(dev, deciden, decinum);\r\n}\r\nstatic void pms_horzdeci(struct pms *dev, short decinum, short deciden)\r\n{\r\nif (decinum <= 512) {\r\nif (decinum % 5 == 0) {\r\ndecinum /= 5;\r\ndeciden /= 5;\r\n}\r\n} else {\r\ndecinum = 512;\r\ndeciden = 640;\r\n}\r\nwhile (((decinum | deciden) & 1) == 0) {\r\ndecinum >>= 1;\r\ndeciden >>= 1;\r\n}\r\nwhile (deciden > 32) {\r\ndeciden >>= 1;\r\ndecinum = (decinum + 1) >> 1;\r\n}\r\nif (deciden == 32)\r\ndeciden--;\r\nmvv_write(dev, 0x24, 0x80 | deciden);\r\nmvv_write(dev, 0x25, decinum);\r\n}\r\nstatic void pms_resolution(struct pms *dev, short width, short height)\r\n{\r\nint fg_height;\r\nfg_height = height;\r\nif (fg_height > 280)\r\nfg_height = 280;\r\nmvv_write(dev, 0x18, fg_height);\r\nmvv_write(dev, 0x19, fg_height >> 8);\r\nif (dev->std & V4L2_STD_525_60) {\r\nmvv_write(dev, 0x1a, 0xfc);\r\nmvv_write(dev, 0x1b, 0x00);\r\nif (height > fg_height)\r\npms_vertdeci(dev, 240, 240);\r\nelse\r\npms_vertdeci(dev, fg_height, 240);\r\n} else {\r\nmvv_write(dev, 0x1a, 0x1a);\r\nmvv_write(dev, 0x1b, 0x01);\r\nif (fg_height > 256)\r\npms_vertdeci(dev, 270, 270);\r\nelse\r\npms_vertdeci(dev, fg_height, 270);\r\n}\r\nmvv_write(dev, 0x12, 0);\r\nmvv_write(dev, 0x13, MVVMEMORYWIDTH);\r\nmvv_write(dev, 0x42, 0x00);\r\nmvv_write(dev, 0x43, 0x00);\r\nmvv_write(dev, 0x44, MVVMEMORYWIDTH);\r\nmvv_write(dev, 0x22, width + 8);\r\nmvv_write(dev, 0x23, (width + 8) >> 8);\r\nif (dev->std & V4L2_STD_525_60)\r\npms_horzdeci(dev, width, 640);\r\nelse\r\npms_horzdeci(dev, width + 8, 768);\r\nmvv_write(dev, 0x30, mvv_read(dev, 0x30) & 0xfe);\r\nmvv_write(dev, 0x08, mvv_read(dev, 0x08) | 0x01);\r\nmvv_write(dev, 0x01, mvv_read(dev, 0x01) & 0xfd);\r\nmvv_write(dev, 0x32, 0x00);\r\nmvv_write(dev, 0x33, MVVMEMORYWIDTH);\r\n}\r\nstatic void pms_vcrinput(struct pms *dev, short input)\r\n{\r\nif (dev->decoder == PHILIPS2)\r\npms_i2c_andor(dev, 0x8a, 0x0d, 0x7f, (input & 1) << 7);\r\nelse if (dev->decoder == PHILIPS1)\r\npms_i2c_andor(dev, 0x42, 0x0d, 0x7f, (input & 1) << 7);\r\n}\r\nstatic int pms_capture(struct pms *dev, char __user *buf, int rgb555, int count)\r\n{\r\nint y;\r\nint dw = 2 * dev->width;\r\nchar tmp[dw + 32];\r\nint cnt = 0;\r\nint len = 0;\r\nunsigned char r8 = 0x5;\r\nif (rgb555)\r\nr8 |= 0x20;\r\nmvv_write(dev, 0x08, r8);\r\nfor (y = 0; y < dev->height; y++) {\r\nwriteb(0, dev->mem);\r\nmemcpy_fromio(tmp, dev->mem, dw + 32);\r\ncnt -= dev->height;\r\nwhile (cnt <= 0) {\r\nint dt = dw;\r\nif (dt + len > count)\r\ndt = count - len;\r\ncnt += dev->height;\r\nif (copy_to_user(buf, tmp + 32, dt))\r\nreturn len ? len : -EFAULT;\r\nbuf += dt;\r\nlen += dt;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int pms_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\nstrlcpy(vcap->driver, dev->v4l2_dev.name, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, "Mediavision PMS", sizeof(vcap->card));\r\nsnprintf(vcap->bus_info, sizeof(vcap->bus_info),\r\n"ISA:%s", dev->v4l2_dev.name);\r\nvcap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE;\r\nvcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int pms_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nstatic const char *inputs[4] = {\r\n"Composite",\r\n"S-Video",\r\n"Composite (VCR)",\r\n"S-Video (VCR)"\r\n};\r\nif (vin->index > 3)\r\nreturn -EINVAL;\r\nstrlcpy(vin->name, inputs[vin->index], sizeof(vin->name));\r\nvin->type = V4L2_INPUT_TYPE_CAMERA;\r\nvin->audioset = 0;\r\nvin->tuner = 0;\r\nvin->std = V4L2_STD_ALL;\r\nvin->status = 0;\r\nreturn 0;\r\n}\r\nstatic int pms_g_input(struct file *file, void *fh, unsigned int *inp)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\n*inp = dev->input;\r\nreturn 0;\r\n}\r\nstatic int pms_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\nif (inp > 3)\r\nreturn -EINVAL;\r\ndev->input = inp;\r\npms_videosource(dev, inp & 1);\r\npms_vcrinput(dev, inp >> 1);\r\nreturn 0;\r\n}\r\nstatic int pms_g_std(struct file *file, void *fh, v4l2_std_id *std)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\n*std = dev->std;\r\nreturn 0;\r\n}\r\nstatic int pms_s_std(struct file *file, void *fh, v4l2_std_id std)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\nint ret = 0;\r\ndev->std = std;\r\nif (dev->std & V4L2_STD_NTSC) {\r\npms_framerate(dev, 30);\r\npms_secamcross(dev, 0);\r\npms_format(dev, 1);\r\n} else if (dev->std & V4L2_STD_PAL) {\r\npms_framerate(dev, 25);\r\npms_secamcross(dev, 0);\r\npms_format(dev, 2);\r\n} else if (dev->std & V4L2_STD_SECAM) {\r\npms_framerate(dev, 25);\r\npms_secamcross(dev, 1);\r\npms_format(dev, 2);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pms_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct pms *dev = container_of(ctrl->handler, struct pms, hdl);\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\npms_brightness(dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\npms_contrast(dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\npms_saturation(dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\npms_hue(dev, ctrl->val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pms_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\npix->width = dev->width;\r\npix->height = dev->height;\r\npix->pixelformat = dev->width == 15 ?\r\nV4L2_PIX_FMT_RGB555 : V4L2_PIX_FMT_RGB565;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = 2 * dev->width;\r\npix->sizeimage = 2 * dev->width * dev->height;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int pms_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nif (pix->height < 16 || pix->height > 480)\r\nreturn -EINVAL;\r\nif (pix->width < 16 || pix->width > 640)\r\nreturn -EINVAL;\r\nif (pix->pixelformat != V4L2_PIX_FMT_RGB555 &&\r\npix->pixelformat != V4L2_PIX_FMT_RGB565)\r\nreturn -EINVAL;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = 2 * pix->width;\r\npix->sizeimage = 2 * pix->width * pix->height;\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int pms_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nint ret = pms_try_fmt_vid_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\ndev->width = pix->width;\r\ndev->height = pix->height;\r\ndev->depth = (pix->pixelformat == V4L2_PIX_FMT_RGB555) ? 15 : 16;\r\npms_resolution(dev, dev->width, dev->height);\r\nreturn 0;\r\n}\r\nstatic int pms_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic struct v4l2_fmtdesc formats[] = {\r\n{ 0, 0, 0,\r\n"RGB 5:5:5", V4L2_PIX_FMT_RGB555,\r\n{ 0, 0, 0, 0 }\r\n},\r\n{ 1, 0, 0,\r\n"RGB 5:6:5", V4L2_PIX_FMT_RGB565,\r\n{ 0, 0, 0, 0 }\r\n},\r\n};\r\nenum v4l2_buf_type type = fmt->type;\r\nif (fmt->index > 1)\r\nreturn -EINVAL;\r\n*fmt = formats[fmt->index];\r\nfmt->type = type;\r\nreturn 0;\r\n}\r\nstatic ssize_t pms_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct pms *dev = video_drvdata(file);\r\nint len;\r\nlen = pms_capture(dev, buf, (dev->depth == 15), count);\r\nreturn len;\r\n}\r\nstatic unsigned int pms_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct v4l2_fh *fh = file->private_data;\r\nunsigned int res = POLLIN | POLLRDNORM;\r\nif (v4l2_event_pending(fh))\r\nres |= POLLPRI;\r\npoll_wait(file, &fh->wait, wait);\r\nreturn res;\r\n}\r\nstatic int init_mediavision(struct pms *dev)\r\n{\r\nint idec, decst;\r\nint i;\r\nstatic const unsigned char i2c_defs[] = {\r\n0x4c, 0x30, 0x00, 0xe8,\r\n0xb6, 0xe2, 0x00, 0x00,\r\n0xff, 0xff, 0x00, 0x00,\r\n0x00, 0x00, 0x78, 0x98,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x34, 0x0a, 0xf4, 0xce,\r\n0xe4\r\n};\r\ndev->mem = ioremap(mem_base, 0x800);\r\nif (!dev->mem)\r\nreturn -ENOMEM;\r\nif (!request_region(0x9a01, 1, "Mediavision PMS config")) {\r\nprintk(KERN_WARNING "mediavision: unable to detect: 0x9a01 in use.\n");\r\niounmap(dev->mem);\r\nreturn -EBUSY;\r\n}\r\nif (!request_region(dev->io, 3, "Mediavision PMS")) {\r\nprintk(KERN_WARNING "mediavision: I/O port %d in use.\n", dev->io);\r\nrelease_region(0x9a01, 1);\r\niounmap(dev->mem);\r\nreturn -EBUSY;\r\n}\r\noutb(0xb8, 0x9a01);\r\noutb(dev->io >> 4, 0x9a01);\r\ndecst = pms_i2c_stat(dev, 0x43);\r\nif (decst != -1)\r\nidec = 2;\r\nelse if (pms_i2c_stat(dev, 0xb9) != -1)\r\nidec = 3;\r\nelse if (pms_i2c_stat(dev, 0x8b) != -1)\r\nidec = 1;\r\nelse\r\nidec = 0;\r\nprintk(KERN_INFO "PMS type is %d\n", idec);\r\nif (idec == 0) {\r\nrelease_region(dev->io, 3);\r\nrelease_region(0x9a01, 1);\r\niounmap(dev->mem);\r\nreturn -ENODEV;\r\n}\r\nmvv_write(dev, 0x04, mem_base >> 12);\r\nfor (i = 0; i < 0x19; i++) {\r\nif (i2c_defs[i] == 0xff)\r\npms_i2c_andor(dev, 0x8a, i, 0x07, 0x00);\r\nelse\r\npms_i2c_write(dev, 0x8a, i, i2c_defs[i]);\r\n}\r\npms_i2c_write(dev, 0xb8, 0x00, 0x12);\r\npms_i2c_write(dev, 0xb8, 0x04, 0x00);\r\npms_i2c_write(dev, 0xb8, 0x07, 0x00);\r\npms_i2c_write(dev, 0xb8, 0x08, 0x00);\r\npms_i2c_write(dev, 0xb8, 0x09, 0xff);\r\npms_i2c_write(dev, 0xb8, 0x0a, 0x00);\r\npms_i2c_write(dev, 0xb8, 0x0b, 0x10);\r\npms_i2c_write(dev, 0xb8, 0x10, 0x03);\r\nmvv_write(dev, 0x01, 0x00);\r\nmvv_write(dev, 0x05, 0xa0);\r\nmvv_write(dev, 0x08, 0x25);\r\nmvv_write(dev, 0x09, 0x00);\r\nmvv_write(dev, 0x0a, 0x20 | MVVMEMORYWIDTH);\r\nmvv_write(dev, 0x10, 0x02);\r\nmvv_write(dev, 0x1e, 0x0c);\r\nmvv_write(dev, 0x1f, 0x03);\r\nmvv_write(dev, 0x26, 0x06);\r\nmvv_write(dev, 0x2b, 0x00);\r\nmvv_write(dev, 0x2c, 0x20);\r\nmvv_write(dev, 0x2d, 0x00);\r\nmvv_write(dev, 0x2f, 0x70);\r\nmvv_write(dev, 0x32, 0x00);\r\nmvv_write(dev, 0x33, MVVMEMORYWIDTH);\r\nmvv_write(dev, 0x34, 0x00);\r\nmvv_write(dev, 0x35, 0x00);\r\nmvv_write(dev, 0x3a, 0x80);\r\nmvv_write(dev, 0x3b, 0x10);\r\nmvv_write(dev, 0x20, 0x00);\r\nmvv_write(dev, 0x21, 0x00);\r\nmvv_write(dev, 0x30, 0x22);\r\nreturn 0;\r\n}\r\nstatic int pms_probe(struct device *pdev, unsigned int card)\r\n{\r\nstruct pms *dev;\r\nstruct v4l2_device *v4l2_dev;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint res;\r\n#ifndef MODULE\r\nif (!enable) {\r\npr_err("PMS: not enabled, use pms.enable=1 to probe\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ndev->decoder = PHILIPS2;\r\ndev->io = io_port;\r\ndev->data = io_port + 1;\r\nv4l2_dev = &dev->v4l2_dev;\r\nhdl = &dev->hdl;\r\nres = v4l2_device_register(pdev, v4l2_dev);\r\nif (res < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\ngoto free_dev;\r\n}\r\nv4l2_info(v4l2_dev, "Mediavision Pro Movie Studio driver 0.05\n");\r\nres = init_mediavision(dev);\r\nif (res) {\r\nv4l2_err(v4l2_dev, "Board not found.\n");\r\ngoto free_io;\r\n}\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &pms_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 139);\r\nv4l2_ctrl_new_std(hdl, &pms_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 70);\r\nv4l2_ctrl_new_std(hdl, &pms_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 64);\r\nv4l2_ctrl_new_std(hdl, &pms_ctrl_ops,\r\nV4L2_CID_HUE, 0, 255, 1, 0);\r\nif (hdl->error) {\r\nres = hdl->error;\r\ngoto free_hdl;\r\n}\r\nmutex_init(&dev->lock);\r\nstrlcpy(dev->vdev.name, v4l2_dev->name, sizeof(dev->vdev.name));\r\ndev->vdev.v4l2_dev = v4l2_dev;\r\ndev->vdev.ctrl_handler = hdl;\r\ndev->vdev.fops = &pms_fops;\r\ndev->vdev.ioctl_ops = &pms_ioctl_ops;\r\ndev->vdev.release = video_device_release_empty;\r\ndev->vdev.lock = &dev->lock;\r\ndev->vdev.tvnorms = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &dev->vdev.flags);\r\nvideo_set_drvdata(&dev->vdev, dev);\r\ndev->std = V4L2_STD_NTSC_M;\r\ndev->height = 240;\r\ndev->width = 320;\r\ndev->depth = 16;\r\npms_swsense(dev, 75);\r\npms_resolution(dev, 320, 240);\r\npms_videosource(dev, 0);\r\npms_vcrinput(dev, 0);\r\nv4l2_ctrl_handler_setup(hdl);\r\nres = video_register_device(&dev->vdev, VFL_TYPE_GRABBER, video_nr);\r\nif (res >= 0)\r\nreturn 0;\r\nfree_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nfree_io:\r\nrelease_region(dev->io, 3);\r\nrelease_region(0x9a01, 1);\r\niounmap(dev->mem);\r\nfree_dev:\r\nkfree(dev);\r\nreturn res;\r\n}\r\nstatic int pms_remove(struct device *pdev, unsigned int card)\r\n{\r\nstruct pms *dev = dev_get_drvdata(pdev);\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nrelease_region(dev->io, 3);\r\nrelease_region(0x9a01, 1);\r\niounmap(dev->mem);\r\nreturn 0;\r\n}\r\nstatic int __init pms_init(void)\r\n{\r\nreturn isa_register_driver(&pms_driver, 1);\r\n}\r\nstatic void __exit pms_exit(void)\r\n{\r\nisa_unregister_driver(&pms_driver);\r\n}
