static void c67x00_hub_reset_host_port(struct c67x00_sie *sie, int port)\r\n{\r\nstruct c67x00_hcd *c67x00 = sie->private_data;\r\nunsigned long flags;\r\nc67x00_ll_husb_reset(sie, port);\r\nspin_lock_irqsave(&c67x00->lock, flags);\r\nc67x00_ll_husb_reset_port(sie, port);\r\nspin_unlock_irqrestore(&c67x00->lock, flags);\r\nc67x00_ll_set_husb_eot(sie->dev, DEFAULT_EOT);\r\n}\r\nstatic int c67x00_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\r\nstruct c67x00_sie *sie = c67x00->sie;\r\nu16 status;\r\nint i;\r\n*buf = 0;\r\nstatus = c67x00_ll_usb_get_status(sie);\r\nfor (i = 0; i < C67X00_PORTS; i++)\r\nif (status & PORT_CONNECT_CHANGE(i))\r\n*buf |= (1 << i);\r\n*buf <<= 1;\r\nreturn !!*buf;\r\n}\r\nstatic int c67x00_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\r\nstruct c67x00_sie *sie = c67x00->sie;\r\nu16 status, usb_status;\r\nint len = 0;\r\nunsigned int port = wIndex-1;\r\nu16 wPortChange, wPortStatus;\r\nswitch (typeReq) {\r\ncase GetHubStatus:\r\n*(__le32 *) buf = cpu_to_le32(0);\r\nlen = 4;\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex > C67X00_PORTS)\r\nreturn -EPIPE;\r\nstatus = c67x00_ll_usb_get_status(sie);\r\nusb_status = c67x00_ll_get_usb_ctl(sie);\r\nwPortChange = 0;\r\nif (status & PORT_CONNECT_CHANGE(port))\r\nwPortChange |= USB_PORT_STAT_C_CONNECTION;\r\nwPortStatus = USB_PORT_STAT_POWER;\r\nif (!(status & PORT_SE0_STATUS(port)))\r\nwPortStatus |= USB_PORT_STAT_CONNECTION;\r\nif (usb_status & LOW_SPEED_PORT(port)) {\r\nwPortStatus |= USB_PORT_STAT_LOW_SPEED;\r\nc67x00->low_speed_ports |= (1 << port);\r\n} else\r\nc67x00->low_speed_ports &= ~(1 << port);\r\nif (usb_status & SOF_EOP_EN(port))\r\nwPortStatus |= USB_PORT_STAT_ENABLE;\r\n*(__le16 *) buf = cpu_to_le16(wPortStatus);\r\n*(__le16 *) (buf + 2) = cpu_to_le16(wPortChange);\r\nlen = 4;\r\nbreak;\r\ncase SetHubFeature:\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nlen = 0;\r\nbreak;\r\ndefault:\r\nreturn -EPIPE;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nif (wIndex > C67X00_PORTS)\r\nreturn -EPIPE;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"SetPortFeature %d (SUSPEND)\n", port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nc67x00_hub_reset_host_port(sie, port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nlen = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"%s: SetPortFeature %d (0x%04x) Error!\n",\r\n__func__, port, wValue);\r\nreturn -EPIPE;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (wIndex > C67X00_PORTS)\r\nreturn -EPIPE;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nc67x00_hub_reset_host_port(sie, port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"ClearPortFeature (%d): C_ENABLE\n", port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"ClearPortFeature (%d): SUSPEND\n", port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"ClearPortFeature (%d): C_SUSPEND\n", port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"ClearPortFeature (%d): POWER\n", port);\r\nreturn -EPIPE;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nc67x00_ll_usb_clear_status(sie,\r\nPORT_CONNECT_CHANGE(port));\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"ClearPortFeature (%d): OVER_CURRENT\n", port);\r\nlen = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"ClearPortFeature (%d): C_RESET\n", port);\r\nlen = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(c67x00_hcd_dev(c67x00),\r\n"%s: ClearPortFeature %d (0x%04x) Error!\n",\r\n__func__, port, wValue);\r\nreturn -EPIPE;\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nlen = min_t(unsigned int, sizeof(c67x00_hub_des), wLength);\r\nmemcpy(buf, c67x00_hub_des, len);\r\nbreak;\r\ndefault:\r\ndev_dbg(c67x00_hcd_dev(c67x00), "%s: unknown\n", __func__);\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void c67x00_hcd_irq(struct c67x00_sie *sie, u16 int_status, u16 msg)\r\n{\r\nstruct c67x00_hcd *c67x00 = sie->private_data;\r\nstruct usb_hcd *hcd = c67x00_hcd_to_hcd(c67x00);\r\nif (msg) {\r\nif (msg & HUSB_TDListDone)\r\nc67x00_sched_kick(c67x00);\r\nelse\r\ndev_warn(c67x00_hcd_dev(c67x00),\r\n"Unknown SIE msg flag(s): 0x%04x\n", msg);\r\n}\r\nif (unlikely(hcd->state == HC_STATE_HALT))\r\nreturn;\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\nreturn;\r\nif (int_status & SOFEOP_FLG(sie->sie_num)) {\r\nc67x00_ll_usb_clear_status(sie, SOF_EOP_IRQ_FLG);\r\nc67x00_sched_kick(c67x00);\r\n}\r\n}\r\nstatic int c67x00_hcd_start(struct usb_hcd *hcd)\r\n{\r\nhcd->uses_new_polling = 1;\r\nhcd->state = HC_STATE_RUNNING;\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nreturn 0;\r\n}\r\nstatic void c67x00_hcd_stop(struct usb_hcd *hcd)\r\n{\r\n}\r\nstatic int c67x00_hcd_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\r\nu16 temp_val;\r\ndev_dbg(c67x00_hcd_dev(c67x00), "%s\n", __func__);\r\ntemp_val = c67x00_ll_husb_get_frame(c67x00->sie);\r\ntemp_val &= HOST_FRAME_MASK;\r\nreturn temp_val ? (temp_val - 1) : HOST_FRAME_MASK;\r\n}\r\nint c67x00_hcd_probe(struct c67x00_sie *sie)\r\n{\r\nstruct c67x00_hcd *c67x00;\r\nstruct usb_hcd *hcd;\r\nunsigned long flags;\r\nint retval;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nhcd = usb_create_hcd(&c67x00_hc_driver, sie_dev(sie), "c67x00_sie");\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err0;\r\n}\r\nc67x00 = hcd_to_c67x00_hcd(hcd);\r\nspin_lock_init(&c67x00->lock);\r\nc67x00->sie = sie;\r\nINIT_LIST_HEAD(&c67x00->list[PIPE_ISOCHRONOUS]);\r\nINIT_LIST_HEAD(&c67x00->list[PIPE_INTERRUPT]);\r\nINIT_LIST_HEAD(&c67x00->list[PIPE_CONTROL]);\r\nINIT_LIST_HEAD(&c67x00->list[PIPE_BULK]);\r\nc67x00->urb_count = 0;\r\nINIT_LIST_HEAD(&c67x00->td_list);\r\nc67x00->td_base_addr = CY_HCD_BUF_ADDR + SIE_TD_OFFSET(sie->sie_num);\r\nc67x00->buf_base_addr = CY_HCD_BUF_ADDR + SIE_BUF_OFFSET(sie->sie_num);\r\nc67x00->max_frame_bw = MAX_FRAME_BW_STD;\r\nc67x00_ll_husb_init_host_port(sie);\r\ninit_completion(&c67x00->endpoint_disable);\r\nretval = c67x00_sched_start_scheduler(c67x00);\r\nif (retval)\r\ngoto err1;\r\nretval = usb_add_hcd(hcd, 0, 0);\r\nif (retval) {\r\ndev_dbg(sie_dev(sie), "%s: usb_add_hcd returned %d\n",\r\n__func__, retval);\r\ngoto err2;\r\n}\r\nspin_lock_irqsave(&sie->lock, flags);\r\nsie->private_data = c67x00;\r\nsie->irq = c67x00_hcd_irq;\r\nspin_unlock_irqrestore(&sie->lock, flags);\r\nreturn retval;\r\nerr2:\r\nc67x00_sched_stop_scheduler(c67x00);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nerr0:\r\nreturn retval;\r\n}\r\nvoid c67x00_hcd_remove(struct c67x00_sie *sie)\r\n{\r\nstruct c67x00_hcd *c67x00 = sie->private_data;\r\nstruct usb_hcd *hcd = c67x00_hcd_to_hcd(c67x00);\r\nc67x00_sched_stop_scheduler(c67x00);\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\n}
