static u64 adjust_bix(u64 bix, level_t level)\r\n{\r\nswitch (level) {\r\ncase 0:\r\nreturn bix;\r\ncase LEVEL(1):\r\nreturn max_t(u64, bix, I0_BLOCKS);\r\ncase LEVEL(2):\r\nreturn max_t(u64, bix, I1_BLOCKS);\r\ncase LEVEL(3):\r\nreturn max_t(u64, bix, I2_BLOCKS);\r\ncase LEVEL(4):\r\nreturn max_t(u64, bix, I3_BLOCKS);\r\ncase LEVEL(5):\r\nreturn max_t(u64, bix, I4_BLOCKS);\r\ndefault:\r\nWARN_ON(1);\r\nreturn bix;\r\n}\r\n}\r\nstatic inline u64 maxbix(u8 height)\r\n{\r\nreturn 1ULL << (LOGFS_BLOCK_BITS * height);\r\n}\r\nstatic inline pgoff_t first_indirect_block(void)\r\n{\r\nreturn INDIRECT_BIT | (1ULL << LEVEL_SHIFT);\r\n}\r\npgoff_t logfs_pack_index(u64 bix, level_t level)\r\n{\r\npgoff_t index;\r\nBUG_ON(bix >= INDIRECT_BIT);\r\nif (level == 0)\r\nreturn bix;\r\nindex = INDIRECT_BIT;\r\nindex |= (__force long)level << LEVEL_SHIFT;\r\nindex |= bix >> ((__force u8)level * LOGFS_BLOCK_BITS);\r\nreturn index;\r\n}\r\nvoid logfs_unpack_index(pgoff_t index, u64 *bix, level_t *level)\r\n{\r\nu8 __level;\r\nif (!(index & INDIRECT_BIT)) {\r\n*bix = index;\r\n*level = 0;\r\nreturn;\r\n}\r\n__level = (index & ~INDIRECT_BIT) >> LEVEL_SHIFT;\r\n*level = LEVEL(__level);\r\n*bix = (index << (__level * LOGFS_BLOCK_BITS)) & ~INDIRECT_BIT;\r\n*bix = adjust_bix(*bix, *level);\r\nreturn;\r\n}\r\nstatic struct timespec be64_to_timespec(__be64 betime)\r\n{\r\nreturn ns_to_timespec(be64_to_cpu(betime));\r\n}\r\nstatic __be64 timespec_to_be64(struct timespec tsp)\r\n{\r\nreturn cpu_to_be64((u64)tsp.tv_sec * NSEC_PER_SEC + tsp.tv_nsec);\r\n}\r\nstatic void logfs_disk_to_inode(struct logfs_disk_inode *di, struct inode*inode)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nint i;\r\ninode->i_mode = be16_to_cpu(di->di_mode);\r\nli->li_height = di->di_height;\r\nli->li_flags = be32_to_cpu(di->di_flags);\r\ni_uid_write(inode, be32_to_cpu(di->di_uid));\r\ni_gid_write(inode, be32_to_cpu(di->di_gid));\r\ninode->i_size = be64_to_cpu(di->di_size);\r\nlogfs_set_blocks(inode, be64_to_cpu(di->di_used_bytes));\r\ninode->i_atime = be64_to_timespec(di->di_atime);\r\ninode->i_ctime = be64_to_timespec(di->di_ctime);\r\ninode->i_mtime = be64_to_timespec(di->di_mtime);\r\nset_nlink(inode, be32_to_cpu(di->di_refcount));\r\ninode->i_generation = be32_to_cpu(di->di_generation);\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFSOCK:\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\ncase S_IFIFO:\r\ninode->i_rdev = be64_to_cpu(di->di_data[0]);\r\nbreak;\r\ncase S_IFDIR:\r\ncase S_IFREG:\r\ncase S_IFLNK:\r\nfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\r\nli->li_data[i] = be64_to_cpu(di->di_data[i]);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void logfs_inode_to_disk(struct inode *inode, struct logfs_disk_inode*di)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nint i;\r\ndi->di_mode = cpu_to_be16(inode->i_mode);\r\ndi->di_height = li->li_height;\r\ndi->di_pad = 0;\r\ndi->di_flags = cpu_to_be32(li->li_flags);\r\ndi->di_uid = cpu_to_be32(i_uid_read(inode));\r\ndi->di_gid = cpu_to_be32(i_gid_read(inode));\r\ndi->di_size = cpu_to_be64(i_size_read(inode));\r\ndi->di_used_bytes = cpu_to_be64(li->li_used_bytes);\r\ndi->di_atime = timespec_to_be64(inode->i_atime);\r\ndi->di_ctime = timespec_to_be64(inode->i_ctime);\r\ndi->di_mtime = timespec_to_be64(inode->i_mtime);\r\ndi->di_refcount = cpu_to_be32(inode->i_nlink);\r\ndi->di_generation = cpu_to_be32(inode->i_generation);\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFSOCK:\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\ncase S_IFIFO:\r\ndi->di_data[0] = cpu_to_be64(inode->i_rdev);\r\nbreak;\r\ncase S_IFDIR:\r\ncase S_IFREG:\r\ncase S_IFLNK:\r\nfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\r\ndi->di_data[i] = cpu_to_be64(li->li_data[i]);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void __logfs_set_blocks(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct logfs_inode *li = logfs_inode(inode);\r\ninode->i_blocks = ULONG_MAX;\r\nif (li->li_used_bytes >> sb->s_blocksize_bits < ULONG_MAX)\r\ninode->i_blocks = ALIGN(li->li_used_bytes, 512) >> 9;\r\n}\r\nvoid logfs_set_blocks(struct inode *inode, u64 bytes)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nli->li_used_bytes = bytes;\r\n__logfs_set_blocks(inode);\r\n}\r\nstatic void prelock_page(struct super_block *sb, struct page *page, int lock)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nBUG_ON(!PageLocked(page));\r\nif (lock) {\r\nBUG_ON(PagePreLocked(page));\r\nSetPagePreLocked(page);\r\n} else {\r\nif (PagePreLocked(page))\r\nsuper->s_lock_count++;\r\nelse\r\nSetPagePreLocked(page);\r\n}\r\n}\r\nstatic void preunlock_page(struct super_block *sb, struct page *page, int lock)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nBUG_ON(!PageLocked(page));\r\nif (lock)\r\nClearPagePreLocked(page);\r\nelse {\r\nBUG_ON(!PagePreLocked(page));\r\nif (super->s_lock_count)\r\nsuper->s_lock_count--;\r\nelse\r\nClearPagePreLocked(page);\r\n}\r\n}\r\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nif (page)\r\nprelock_page(sb, page, lock);\r\nif (lock) {\r\nmutex_lock(&super->s_write_mutex);\r\nlogfs_gc_pass(sb);\r\n}\r\n}\r\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nif (page)\r\npreunlock_page(sb, page, lock);\r\nif (lock)\r\nmutex_unlock(&super->s_write_mutex);\r\n}\r\nstatic struct page *logfs_get_read_page(struct inode *inode, u64 bix,\r\nlevel_t level)\r\n{\r\nreturn find_or_create_page(inode->i_mapping,\r\nlogfs_pack_index(bix, level), GFP_NOFS);\r\n}\r\nstatic void logfs_put_read_page(struct page *page)\r\n{\r\nunlock_page(page);\r\npage_cache_release(page);\r\n}\r\nstatic void logfs_lock_write_page(struct page *page)\r\n{\r\nint loop = 0;\r\nwhile (unlikely(!trylock_page(page))) {\r\nif (loop++ > 0x1000) {\r\nprintk(KERN_ERR "stack at %p\n", &loop);\r\nBUG();\r\n}\r\nif (PagePreLocked(page)) {\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nBUG_ON(!PageLocked(page));\r\n}\r\nstatic struct page *logfs_get_write_page(struct inode *inode, u64 bix,\r\nlevel_t level)\r\n{\r\nstruct address_space *mapping = inode->i_mapping;\r\npgoff_t index = logfs_pack_index(bix, level);\r\nstruct page *page;\r\nint err;\r\nrepeat:\r\npage = find_get_page(mapping, index);\r\nif (!page) {\r\npage = __page_cache_alloc(GFP_NOFS);\r\nif (!page)\r\nreturn NULL;\r\nerr = add_to_page_cache_lru(page, mapping, index, GFP_NOFS);\r\nif (unlikely(err)) {\r\npage_cache_release(page);\r\nif (err == -EEXIST)\r\ngoto repeat;\r\nreturn NULL;\r\n}\r\n} else logfs_lock_write_page(page);\r\nBUG_ON(!PageLocked(page));\r\nreturn page;\r\n}\r\nstatic void logfs_unlock_write_page(struct page *page)\r\n{\r\nif (!PagePreLocked(page))\r\nunlock_page(page);\r\n}\r\nstatic void logfs_put_write_page(struct page *page)\r\n{\r\nlogfs_unlock_write_page(page);\r\npage_cache_release(page);\r\n}\r\nstatic struct page *logfs_get_page(struct inode *inode, u64 bix, level_t level,\r\nint rw)\r\n{\r\nif (rw == READ)\r\nreturn logfs_get_read_page(inode, bix, level);\r\nelse\r\nreturn logfs_get_write_page(inode, bix, level);\r\n}\r\nstatic void logfs_put_page(struct page *page, int rw)\r\n{\r\nif (rw == READ)\r\nlogfs_put_read_page(page);\r\nelse\r\nlogfs_put_write_page(page);\r\n}\r\nstatic unsigned long __get_bits(u64 val, int skip, int no)\r\n{\r\nu64 ret = val;\r\nret >>= skip * no;\r\nret <<= 64 - no;\r\nret >>= 64 - no;\r\nreturn ret;\r\n}\r\nstatic unsigned long get_bits(u64 val, level_t skip)\r\n{\r\nreturn __get_bits(val, (__force int)skip, LOGFS_BLOCK_BITS);\r\n}\r\nstatic inline void init_shadow_tree(struct super_block *sb,\r\nstruct shadow_tree *tree)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nbtree_init_mempool64(&tree->new, super->s_btree_pool);\r\nbtree_init_mempool64(&tree->old, super->s_btree_pool);\r\n}\r\nstatic void indirect_write_block(struct logfs_block *block)\r\n{\r\nstruct page *page;\r\nstruct inode *inode;\r\nint ret;\r\npage = block->page;\r\ninode = page->mapping->host;\r\nlogfs_lock_write_page(page);\r\nret = logfs_write_buf(inode, page, 0);\r\nlogfs_unlock_write_page(page);\r\nBUG_ON(ret);\r\n}\r\nstatic void inode_write_block(struct logfs_block *block)\r\n{\r\nstruct inode *inode;\r\nint ret;\r\ninode = block->inode;\r\nif (inode->i_ino == LOGFS_INO_MASTER)\r\nlogfs_write_anchor(inode->i_sb);\r\nelse {\r\nret = __logfs_write_inode(inode, NULL, 0);\r\nBUG_ON(ret);\r\n}\r\n}\r\nstatic unsigned long fnb(const unsigned long *addr,\r\nunsigned long size, unsigned long offset)\r\n{\r\nreturn find_next_bit(addr, size, offset);\r\n}\r\nstatic __be64 inode_val0(struct inode *inode)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nu64 val;\r\nBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_mode) != 0);\r\nBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_height) != 2);\r\nBUILD_BUG_ON(offsetof(struct logfs_disk_inode, di_flags) != 4);\r\nval = (u64)inode->i_mode << 48 |\r\n(u64)li->li_height << 40 |\r\n(u64)li->li_flags;\r\nreturn cpu_to_be64(val);\r\n}\r\nstatic int inode_write_alias(struct super_block *sb,\r\nstruct logfs_block *block, write_alias_t *write_one_alias)\r\n{\r\nstruct inode *inode = block->inode;\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nunsigned long pos;\r\nu64 ino , bix;\r\n__be64 val;\r\nlevel_t level;\r\nint err;\r\nfor (pos = 0; ; pos++) {\r\npos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\r\nif (pos >= LOGFS_EMBEDDED_FIELDS + INODE_POINTER_OFS)\r\nreturn 0;\r\nswitch (pos) {\r\ncase INODE_HEIGHT_OFS:\r\nval = inode_val0(inode);\r\nbreak;\r\ncase INODE_USED_OFS:\r\nval = cpu_to_be64(li->li_used_bytes);\r\nbreak;\r\ncase INODE_SIZE_OFS:\r\nval = cpu_to_be64(i_size_read(inode));\r\nbreak;\r\ncase INODE_POINTER_OFS ... INODE_POINTER_OFS + LOGFS_EMBEDDED_FIELDS - 1:\r\nval = cpu_to_be64(li->li_data[pos - INODE_POINTER_OFS]);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nino = LOGFS_INO_MASTER;\r\nbix = inode->i_ino;\r\nlevel = LEVEL(0);\r\nerr = write_one_alias(sb, ino, bix, level, pos, val);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nstatic int indirect_write_alias(struct super_block *sb,\r\nstruct logfs_block *block, write_alias_t *write_one_alias)\r\n{\r\nunsigned long pos;\r\nstruct page *page = block->page;\r\nu64 ino , bix;\r\n__be64 *child, val;\r\nlevel_t level;\r\nint err;\r\nfor (pos = 0; ; pos++) {\r\npos = fnb(block->alias_map, LOGFS_BLOCK_FACTOR, pos);\r\nif (pos >= LOGFS_BLOCK_FACTOR)\r\nreturn 0;\r\nino = page->mapping->host->i_ino;\r\nlogfs_unpack_index(page->index, &bix, &level);\r\nchild = kmap_atomic(page);\r\nval = child[pos];\r\nkunmap_atomic(child);\r\nerr = write_one_alias(sb, ino, bix, level, pos, val);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nint logfs_write_obj_aliases_pagecache(struct super_block *sb)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct logfs_block *block;\r\nint err;\r\nlist_for_each_entry(block, &super->s_object_alias, alias_list) {\r\nerr = block->ops->write_alias(sb, block, write_alias_journal);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid __free_block(struct super_block *sb, struct logfs_block *block)\r\n{\r\nBUG_ON(!list_empty(&block->item_list));\r\nlist_del(&block->alias_list);\r\nmempool_free(block, logfs_super(sb)->s_block_pool);\r\n}\r\nstatic void inode_free_block(struct super_block *sb, struct logfs_block *block)\r\n{\r\nstruct inode *inode = block->inode;\r\nlogfs_inode(inode)->li_block = NULL;\r\n__free_block(sb, block);\r\n}\r\nstatic void indirect_free_block(struct super_block *sb,\r\nstruct logfs_block *block)\r\n{\r\nstruct page *page = block->page;\r\nif (PagePrivate(page)) {\r\nClearPagePrivate(page);\r\npage_cache_release(page);\r\nset_page_private(page, 0);\r\n}\r\n__free_block(sb, block);\r\n}\r\nstruct logfs_block *__alloc_block(struct super_block *sb,\r\nu64 ino, u64 bix, level_t level)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct logfs_block *block;\r\nblock = mempool_alloc(super->s_block_pool, GFP_NOFS);\r\nmemset(block, 0, sizeof(*block));\r\nINIT_LIST_HEAD(&block->alias_list);\r\nINIT_LIST_HEAD(&block->item_list);\r\nblock->sb = sb;\r\nblock->ino = ino;\r\nblock->bix = bix;\r\nblock->level = level;\r\nreturn block;\r\n}\r\nstatic void alloc_inode_block(struct inode *inode)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct logfs_block *block;\r\nif (li->li_block)\r\nreturn;\r\nblock = __alloc_block(inode->i_sb, LOGFS_INO_MASTER, inode->i_ino, 0);\r\nblock->inode = inode;\r\nli->li_block = block;\r\nblock->ops = &inode_block_ops;\r\n}\r\nvoid initialize_block_counters(struct page *page, struct logfs_block *block,\r\n__be64 *array, int page_is_empty)\r\n{\r\nu64 ptr;\r\nint i, start;\r\nblock->partial = 0;\r\nblock->full = 0;\r\nstart = 0;\r\nif (page->index < first_indirect_block()) {\r\nreturn;\r\n}\r\nif (page->index == first_indirect_block()) {\r\nstart = I0_BLOCKS;\r\nblock->full = I0_BLOCKS;\r\n}\r\nif (!page_is_empty) {\r\nfor (i = start; i < LOGFS_BLOCK_FACTOR; i++) {\r\nptr = be64_to_cpu(array[i]);\r\nif (ptr)\r\nblock->partial++;\r\nif (ptr & LOGFS_FULLY_POPULATED)\r\nblock->full++;\r\n}\r\n}\r\n}\r\nstatic void alloc_data_block(struct inode *inode, struct page *page)\r\n{\r\nstruct logfs_block *block;\r\nu64 bix;\r\nlevel_t level;\r\nif (PagePrivate(page))\r\nreturn;\r\nlogfs_unpack_index(page->index, &bix, &level);\r\nblock = __alloc_block(inode->i_sb, inode->i_ino, bix, level);\r\nblock->page = page;\r\nSetPagePrivate(page);\r\npage_cache_get(page);\r\nset_page_private(page, (unsigned long) block);\r\nblock->ops = &indirect_block_ops;\r\n}\r\nstatic void alloc_indirect_block(struct inode *inode, struct page *page,\r\nint page_is_empty)\r\n{\r\nstruct logfs_block *block;\r\n__be64 *array;\r\nif (PagePrivate(page))\r\nreturn;\r\nalloc_data_block(inode, page);\r\nblock = logfs_block(page);\r\narray = kmap_atomic(page);\r\ninitialize_block_counters(page, block, array, page_is_empty);\r\nkunmap_atomic(array);\r\n}\r\nstatic void block_set_pointer(struct page *page, int index, u64 ptr)\r\n{\r\nstruct logfs_block *block = logfs_block(page);\r\n__be64 *array;\r\nu64 oldptr;\r\nBUG_ON(!block);\r\narray = kmap_atomic(page);\r\noldptr = be64_to_cpu(array[index]);\r\narray[index] = cpu_to_be64(ptr);\r\nkunmap_atomic(array);\r\nSetPageUptodate(page);\r\nblock->full += !!(ptr & LOGFS_FULLY_POPULATED)\r\n- !!(oldptr & LOGFS_FULLY_POPULATED);\r\nblock->partial += !!ptr - !!oldptr;\r\n}\r\nstatic u64 block_get_pointer(struct page *page, int index)\r\n{\r\n__be64 *block;\r\nu64 ptr;\r\nblock = kmap_atomic(page);\r\nptr = be64_to_cpu(block[index]);\r\nkunmap_atomic(block);\r\nreturn ptr;\r\n}\r\nstatic int logfs_read_empty(struct page *page)\r\n{\r\nzero_user_segment(page, 0, PAGE_CACHE_SIZE);\r\nreturn 0;\r\n}\r\nstatic int logfs_read_direct(struct inode *inode, struct page *page)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\npgoff_t index = page->index;\r\nu64 block;\r\nblock = li->li_data[index];\r\nif (!block)\r\nreturn logfs_read_empty(page);\r\nreturn logfs_segment_read(inode, page, block, index, 0);\r\n}\r\nstatic int logfs_read_loop(struct inode *inode, struct page *page,\r\nint rw_context)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nu64 bix, bofs = li->li_data[INDIRECT_INDEX];\r\nlevel_t level, target_level;\r\nint ret;\r\nstruct page *ipage;\r\nlogfs_unpack_index(page->index, &bix, &target_level);\r\nif (!bofs)\r\nreturn logfs_read_empty(page);\r\nif (bix >= maxbix(li->li_height))\r\nreturn logfs_read_empty(page);\r\nfor (level = LEVEL(li->li_height);\r\n(__force u8)level > (__force u8)target_level;\r\nlevel = SUBLEVEL(level)){\r\nipage = logfs_get_page(inode, bix, level, rw_context);\r\nif (!ipage)\r\nreturn -ENOMEM;\r\nret = logfs_segment_read(inode, ipage, bofs, bix, level);\r\nif (ret) {\r\nlogfs_put_read_page(ipage);\r\nreturn ret;\r\n}\r\nbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\r\nlogfs_put_page(ipage, rw_context);\r\nif (!bofs)\r\nreturn logfs_read_empty(page);\r\n}\r\nreturn logfs_segment_read(inode, page, bofs, bix, 0);\r\n}\r\nstatic int logfs_read_block(struct inode *inode, struct page *page,\r\nint rw_context)\r\n{\r\npgoff_t index = page->index;\r\nif (index < I0_BLOCKS)\r\nreturn logfs_read_direct(inode, page);\r\nreturn logfs_read_loop(inode, page, rw_context);\r\n}\r\nstatic int logfs_exist_loop(struct inode *inode, u64 bix)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nu64 bofs = li->li_data[INDIRECT_INDEX];\r\nlevel_t level;\r\nint ret;\r\nstruct page *ipage;\r\nif (!bofs)\r\nreturn 0;\r\nif (bix >= maxbix(li->li_height))\r\nreturn 0;\r\nfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\r\nipage = logfs_get_read_page(inode, bix, level);\r\nif (!ipage)\r\nreturn -ENOMEM;\r\nret = logfs_segment_read(inode, ipage, bofs, bix, level);\r\nif (ret) {\r\nlogfs_put_read_page(ipage);\r\nreturn ret;\r\n}\r\nbofs = block_get_pointer(ipage, get_bits(bix, SUBLEVEL(level)));\r\nlogfs_put_read_page(ipage);\r\nif (!bofs)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint logfs_exist_block(struct inode *inode, u64 bix)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nif (bix < I0_BLOCKS)\r\nreturn !!li->li_data[bix];\r\nreturn logfs_exist_loop(inode, bix);\r\n}\r\nstatic u64 seek_holedata_direct(struct inode *inode, u64 bix, int data)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nfor (; bix < I0_BLOCKS; bix++)\r\nif (data ^ (li->li_data[bix] == 0))\r\nreturn bix;\r\nreturn I0_BLOCKS;\r\n}\r\nstatic u64 seek_holedata_loop(struct inode *inode, u64 bix, int data)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\n__be64 *rblock;\r\nu64 increment, bofs = li->li_data[INDIRECT_INDEX];\r\nlevel_t level;\r\nint ret, slot;\r\nstruct page *page;\r\nBUG_ON(!bofs);\r\nfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)) {\r\nincrement = 1 << (LOGFS_BLOCK_BITS * ((__force u8)level-1));\r\npage = logfs_get_read_page(inode, bix, level);\r\nif (!page)\r\nreturn bix;\r\nret = logfs_segment_read(inode, page, bofs, bix, level);\r\nif (ret) {\r\nlogfs_put_read_page(page);\r\nreturn bix;\r\n}\r\nslot = get_bits(bix, SUBLEVEL(level));\r\nrblock = kmap_atomic(page);\r\nwhile (slot < LOGFS_BLOCK_FACTOR) {\r\nif (data && (rblock[slot] != 0))\r\nbreak;\r\nif (!data && !(be64_to_cpu(rblock[slot]) & LOGFS_FULLY_POPULATED))\r\nbreak;\r\nslot++;\r\nbix += increment;\r\nbix &= ~(increment - 1);\r\n}\r\nif (slot >= LOGFS_BLOCK_FACTOR) {\r\nkunmap_atomic(rblock);\r\nlogfs_put_read_page(page);\r\nreturn bix;\r\n}\r\nbofs = be64_to_cpu(rblock[slot]);\r\nkunmap_atomic(rblock);\r\nlogfs_put_read_page(page);\r\nif (!bofs) {\r\nBUG_ON(data);\r\nreturn bix;\r\n}\r\n}\r\nreturn bix;\r\n}\r\nu64 logfs_seek_hole(struct inode *inode, u64 bix)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nif (bix < I0_BLOCKS) {\r\nbix = seek_holedata_direct(inode, bix, 0);\r\nif (bix < I0_BLOCKS)\r\nreturn bix;\r\n}\r\nif (!li->li_data[INDIRECT_INDEX])\r\nreturn bix;\r\nelse if (li->li_data[INDIRECT_INDEX] & LOGFS_FULLY_POPULATED)\r\nbix = maxbix(li->li_height);\r\nelse if (bix >= maxbix(li->li_height))\r\nreturn bix;\r\nelse {\r\nbix = seek_holedata_loop(inode, bix, 0);\r\nif (bix < maxbix(li->li_height))\r\nreturn bix;\r\nWARN_ON_ONCE(bix == maxbix(li->li_height));\r\n}\r\nreturn bix;\r\n}\r\nstatic u64 __logfs_seek_data(struct inode *inode, u64 bix)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nif (bix < I0_BLOCKS) {\r\nbix = seek_holedata_direct(inode, bix, 1);\r\nif (bix < I0_BLOCKS)\r\nreturn bix;\r\n}\r\nif (bix < maxbix(li->li_height)) {\r\nif (!li->li_data[INDIRECT_INDEX])\r\nbix = maxbix(li->li_height);\r\nelse\r\nreturn seek_holedata_loop(inode, bix, 1);\r\n}\r\nreturn bix;\r\n}\r\nu64 logfs_seek_data(struct inode *inode, u64 bix)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nu64 ret, end;\r\nret = __logfs_seek_data(inode, bix);\r\nend = i_size_read(inode) >> sb->s_blocksize_bits;\r\nif (ret >= end)\r\nret = max(bix, end);\r\nreturn ret;\r\n}\r\nstatic int logfs_is_valid_direct(struct logfs_inode *li, u64 bix, u64 ofs)\r\n{\r\nreturn pure_ofs(li->li_data[bix]) == ofs;\r\n}\r\nstatic int __logfs_is_valid_loop(struct inode *inode, u64 bix,\r\nu64 ofs, u64 bofs)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nlevel_t level;\r\nint ret;\r\nstruct page *page;\r\nfor (level = LEVEL(li->li_height); level != 0; level = SUBLEVEL(level)){\r\npage = logfs_get_write_page(inode, bix, level);\r\nBUG_ON(!page);\r\nret = logfs_segment_read(inode, page, bofs, bix, level);\r\nif (ret) {\r\nlogfs_put_write_page(page);\r\nreturn 0;\r\n}\r\nbofs = block_get_pointer(page, get_bits(bix, SUBLEVEL(level)));\r\nlogfs_put_write_page(page);\r\nif (!bofs)\r\nreturn 0;\r\nif (pure_ofs(bofs) == ofs)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int logfs_is_valid_loop(struct inode *inode, u64 bix, u64 ofs)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nu64 bofs = li->li_data[INDIRECT_INDEX];\r\nif (!bofs)\r\nreturn 0;\r\nif (bix >= maxbix(li->li_height))\r\nreturn 0;\r\nif (pure_ofs(bofs) == ofs)\r\nreturn 1;\r\nreturn __logfs_is_valid_loop(inode, bix, ofs, bofs);\r\n}\r\nstatic int __logfs_is_valid_block(struct inode *inode, u64 bix, u64 ofs)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nif ((inode->i_nlink == 0) && atomic_read(&inode->i_count) == 1)\r\nreturn 0;\r\nif (bix < I0_BLOCKS)\r\nreturn logfs_is_valid_direct(li, bix, ofs);\r\nreturn logfs_is_valid_loop(inode, bix, ofs);\r\n}\r\nint logfs_is_valid_block(struct super_block *sb, u64 ofs, u64 ino, u64 bix,\r\ngc_level_t gc_level)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct inode *inode;\r\nint ret, cookie;\r\nif (ino == -1)\r\nreturn 0;\r\nLOGFS_BUG_ON((u64)(u_long)ino != ino, sb);\r\ninode = logfs_safe_iget(sb, ino, &cookie);\r\nif (IS_ERR(inode))\r\ngoto invalid;\r\nret = __logfs_is_valid_block(inode, bix, ofs);\r\nlogfs_safe_iput(inode, cookie);\r\nif (ret)\r\nreturn ret;\r\ninvalid:\r\nif (btree_lookup64(&super->s_shadow_tree.old, ofs))\r\nreturn 2;\r\nreturn 0;\r\n}\r\nint logfs_readpage_nolock(struct page *page)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nint ret = -EIO;\r\nret = logfs_read_block(inode, page, READ);\r\nif (ret) {\r\nClearPageUptodate(page);\r\nSetPageError(page);\r\n} else {\r\nSetPageUptodate(page);\r\nClearPageError(page);\r\n}\r\nflush_dcache_page(page);\r\nreturn ret;\r\n}\r\nstatic int logfs_reserve_bytes(struct inode *inode, int bytes)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\nu64 available = super->s_free_bytes + super->s_dirty_free_bytes\r\n- super->s_dirty_used_bytes - super->s_dirty_pages;\r\nif (!bytes)\r\nreturn 0;\r\nif (available < bytes)\r\nreturn -ENOSPC;\r\nif (available < bytes + super->s_root_reserve &&\r\n!capable(CAP_SYS_RESOURCE))\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nint get_page_reserve(struct inode *inode, struct page *page)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\nstruct logfs_block *block = logfs_block(page);\r\nint ret;\r\nif (block && block->reserved_bytes)\r\nreturn 0;\r\nlogfs_get_wblocks(inode->i_sb, page, WF_LOCK);\r\nwhile ((ret = logfs_reserve_bytes(inode, 6 * LOGFS_MAX_OBJECTSIZE)) &&\r\n!list_empty(&super->s_writeback_list)) {\r\nblock = list_entry(super->s_writeback_list.next,\r\nstruct logfs_block, alias_list);\r\nblock->ops->write_block(block);\r\n}\r\nif (!ret) {\r\nalloc_data_block(inode, page);\r\nblock = logfs_block(page);\r\nblock->reserved_bytes += 6 * LOGFS_MAX_OBJECTSIZE;\r\nsuper->s_dirty_pages += 6 * LOGFS_MAX_OBJECTSIZE;\r\nlist_move_tail(&block->alias_list, &super->s_writeback_list);\r\n}\r\nlogfs_put_wblocks(inode->i_sb, page, WF_LOCK);\r\nreturn ret;\r\n}\r\nstatic void logfs_handle_transaction(struct inode *inode,\r\nstruct logfs_transaction *ta)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\nif (!ta)\r\nreturn;\r\nlogfs_inode(inode)->li_block->ta = NULL;\r\nif (inode->i_ino != LOGFS_INO_MASTER) {\r\nBUG();\r\nreturn;\r\n}\r\nswitch (ta->state) {\r\ncase CREATE_1:\r\ncase UNLINK_1:\r\nBUG_ON(super->s_victim_ino);\r\nsuper->s_victim_ino = ta->ino;\r\nbreak;\r\ncase CREATE_2:\r\ncase UNLINK_2:\r\nBUG_ON(super->s_victim_ino != ta->ino);\r\nsuper->s_victim_ino = 0;\r\nkfree(ta);\r\nbreak;\r\ncase CROSS_RENAME_1:\r\nBUG_ON(super->s_rename_dir);\r\nBUG_ON(super->s_rename_pos);\r\nsuper->s_rename_dir = ta->dir;\r\nsuper->s_rename_pos = ta->pos;\r\nbreak;\r\ncase CROSS_RENAME_2:\r\nBUG_ON(super->s_rename_dir != ta->dir);\r\nBUG_ON(super->s_rename_pos != ta->pos);\r\nsuper->s_rename_dir = 0;\r\nsuper->s_rename_pos = 0;\r\nkfree(ta);\r\nbreak;\r\ncase TARGET_RENAME_1:\r\nBUG_ON(super->s_rename_dir);\r\nBUG_ON(super->s_rename_pos);\r\nBUG_ON(super->s_victim_ino);\r\nsuper->s_rename_dir = ta->dir;\r\nsuper->s_rename_pos = ta->pos;\r\nsuper->s_victim_ino = ta->ino;\r\nbreak;\r\ncase TARGET_RENAME_2:\r\nBUG_ON(super->s_rename_dir != ta->dir);\r\nBUG_ON(super->s_rename_pos != ta->pos);\r\nBUG_ON(super->s_victim_ino != ta->ino);\r\nsuper->s_rename_dir = 0;\r\nsuper->s_rename_pos = 0;\r\nbreak;\r\ncase TARGET_RENAME_3:\r\nBUG_ON(super->s_rename_dir);\r\nBUG_ON(super->s_rename_pos);\r\nBUG_ON(super->s_victim_ino != ta->ino);\r\nsuper->s_victim_ino = 0;\r\nkfree(ta);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int logfs_reserve_blocks(struct inode *inode, int blocks)\r\n{\r\nreturn logfs_reserve_bytes(inode, blocks * LOGFS_MAX_OBJECTSIZE);\r\n}\r\nstatic struct logfs_shadow *alloc_shadow(struct inode *inode, u64 bix,\r\nlevel_t level, u64 old_ofs)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\nstruct logfs_shadow *shadow;\r\nshadow = mempool_alloc(super->s_shadow_pool, GFP_NOFS);\r\nmemset(shadow, 0, sizeof(*shadow));\r\nshadow->ino = inode->i_ino;\r\nshadow->bix = bix;\r\nshadow->gc_level = expand_level(inode->i_ino, level);\r\nshadow->old_ofs = old_ofs & ~LOGFS_FULLY_POPULATED;\r\nreturn shadow;\r\n}\r\nstatic void free_shadow(struct inode *inode, struct logfs_shadow *shadow)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\nmempool_free(shadow, super->s_shadow_pool);\r\n}\r\nstatic void mark_segment(struct shadow_tree *tree, u32 segno)\r\n{\r\nint err;\r\nif (!btree_lookup32(&tree->segment_map, segno)) {\r\nerr = btree_insert32(&tree->segment_map, segno, (void *)1,\r\nGFP_NOFS);\r\nBUG_ON(err);\r\ntree->no_shadowed_segments++;\r\n}\r\n}\r\nstatic void fill_shadow_tree(struct inode *inode, struct page *page,\r\nstruct logfs_shadow *shadow)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\nstruct logfs_block *block = logfs_block(page);\r\nstruct shadow_tree *tree = &super->s_shadow_tree;\r\nif (PagePrivate(page)) {\r\nif (block->alias_map)\r\nsuper->s_no_object_aliases -= bitmap_weight(\r\nblock->alias_map, LOGFS_BLOCK_FACTOR);\r\nlogfs_handle_transaction(inode, block->ta);\r\nblock->ops->free_block(inode->i_sb, block);\r\n}\r\nif (shadow) {\r\nif (shadow->old_ofs)\r\nbtree_insert64(&tree->old, shadow->old_ofs, shadow,\r\nGFP_NOFS);\r\nelse\r\nbtree_insert64(&tree->new, shadow->new_ofs, shadow,\r\nGFP_NOFS);\r\nsuper->s_dirty_used_bytes += shadow->new_len;\r\nsuper->s_dirty_free_bytes += shadow->old_len;\r\nmark_segment(tree, shadow->old_ofs >> super->s_segshift);\r\nmark_segment(tree, shadow->new_ofs >> super->s_segshift);\r\n}\r\n}\r\nstatic void logfs_set_alias(struct super_block *sb, struct logfs_block *block,\r\nlong child_no)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nif (block->inode && block->inode->i_ino == LOGFS_INO_MASTER) {\r\nreturn;\r\n}\r\nif (!test_bit(child_no, block->alias_map)) {\r\nset_bit(child_no, block->alias_map);\r\nsuper->s_no_object_aliases++;\r\n}\r\nlist_move_tail(&block->alias_list, &super->s_object_alias);\r\n}\r\nstatic void set_iused(struct inode *inode, struct logfs_shadow *shadow)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nif (shadow->new_len == shadow->old_len)\r\nreturn;\r\nalloc_inode_block(inode);\r\nli->li_used_bytes += shadow->new_len - shadow->old_len;\r\n__logfs_set_blocks(inode);\r\nlogfs_set_alias(inode->i_sb, li->li_block, INODE_USED_OFS);\r\nlogfs_set_alias(inode->i_sb, li->li_block, INODE_SIZE_OFS);\r\n}\r\nstatic int logfs_write_i0(struct inode *inode, struct page *page,\r\nstruct write_control *wc)\r\n{\r\nstruct logfs_shadow *shadow;\r\nu64 bix;\r\nlevel_t level;\r\nint full, err = 0;\r\nlogfs_unpack_index(page->index, &bix, &level);\r\nif (wc->ofs == 0)\r\nif (logfs_reserve_blocks(inode, 1))\r\nreturn -ENOSPC;\r\nshadow = alloc_shadow(inode, bix, level, wc->ofs);\r\nif (wc->flags & WF_WRITE)\r\nerr = logfs_segment_write(inode, page, shadow);\r\nif (wc->flags & WF_DELETE)\r\nlogfs_segment_delete(inode, shadow);\r\nif (err) {\r\nfree_shadow(inode, shadow);\r\nreturn err;\r\n}\r\nset_iused(inode, shadow);\r\nfull = 1;\r\nif (level != 0) {\r\nalloc_indirect_block(inode, page, 0);\r\nfull = logfs_block(page)->full == LOGFS_BLOCK_FACTOR;\r\n}\r\nfill_shadow_tree(inode, page, shadow);\r\nwc->ofs = shadow->new_ofs;\r\nif (wc->ofs && full)\r\nwc->ofs |= LOGFS_FULLY_POPULATED;\r\nreturn 0;\r\n}\r\nstatic int logfs_write_direct(struct inode *inode, struct page *page,\r\nlong flags)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct write_control wc = {\r\n.ofs = li->li_data[page->index],\r\n.flags = flags,\r\n};\r\nint err;\r\nalloc_inode_block(inode);\r\nerr = logfs_write_i0(inode, page, &wc);\r\nif (err)\r\nreturn err;\r\nli->li_data[page->index] = wc.ofs;\r\nlogfs_set_alias(inode->i_sb, li->li_block,\r\npage->index + INODE_POINTER_OFS);\r\nreturn 0;\r\n}\r\nstatic int ptr_change(u64 ofs, struct page *page)\r\n{\r\nstruct logfs_block *block = logfs_block(page);\r\nint empty0, empty1, full0, full1;\r\nempty0 = ofs == 0;\r\nempty1 = block->partial == 0;\r\nif (empty0 != empty1)\r\nreturn 1;\r\nfull0 = !!(ofs & LOGFS_FULLY_POPULATED);\r\nfull1 = block->full == LOGFS_BLOCK_FACTOR;\r\nif (full0 != full1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __logfs_write_rec(struct inode *inode, struct page *page,\r\nstruct write_control *this_wc,\r\npgoff_t bix, level_t target_level, level_t level)\r\n{\r\nint ret, page_empty = 0;\r\nint child_no = get_bits(bix, SUBLEVEL(level));\r\nstruct page *ipage;\r\nstruct write_control child_wc = {\r\n.flags = this_wc->flags,\r\n};\r\nipage = logfs_get_write_page(inode, bix, level);\r\nif (!ipage)\r\nreturn -ENOMEM;\r\nif (this_wc->ofs) {\r\nret = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\r\nif (ret)\r\ngoto out;\r\n} else if (!PageUptodate(ipage)) {\r\npage_empty = 1;\r\nlogfs_read_empty(ipage);\r\n}\r\nchild_wc.ofs = block_get_pointer(ipage, child_no);\r\nif ((__force u8)level-1 > (__force u8)target_level)\r\nret = __logfs_write_rec(inode, page, &child_wc, bix,\r\ntarget_level, SUBLEVEL(level));\r\nelse\r\nret = logfs_write_i0(inode, page, &child_wc);\r\nif (ret)\r\ngoto out;\r\nalloc_indirect_block(inode, ipage, page_empty);\r\nblock_set_pointer(ipage, child_no, child_wc.ofs);\r\nif (child_wc.ofs || logfs_block(ipage)->partial)\r\nthis_wc->flags |= WF_WRITE;\r\nif (!this_wc->ofs || ptr_change(this_wc->ofs, ipage))\r\nret = logfs_write_i0(inode, ipage, this_wc);\r\nelse\r\nlogfs_set_alias(inode->i_sb, logfs_block(ipage), child_no);\r\nout:\r\nlogfs_put_write_page(ipage);\r\nreturn ret;\r\n}\r\nstatic int logfs_write_rec(struct inode *inode, struct page *page,\r\npgoff_t bix, level_t target_level, long flags)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct write_control wc = {\r\n.ofs = li->li_data[INDIRECT_INDEX],\r\n.flags = flags,\r\n};\r\nint ret;\r\nalloc_inode_block(inode);\r\nif (li->li_height > (__force u8)target_level)\r\nret = __logfs_write_rec(inode, page, &wc, bix, target_level,\r\nLEVEL(li->li_height));\r\nelse\r\nret = logfs_write_i0(inode, page, &wc);\r\nif (ret)\r\nreturn ret;\r\nif (li->li_data[INDIRECT_INDEX] != wc.ofs) {\r\nli->li_data[INDIRECT_INDEX] = wc.ofs;\r\nlogfs_set_alias(inode->i_sb, li->li_block,\r\nINDIRECT_INDEX + INODE_POINTER_OFS);\r\n}\r\nreturn ret;\r\n}\r\nvoid logfs_add_transaction(struct inode *inode, struct logfs_transaction *ta)\r\n{\r\nalloc_inode_block(inode);\r\nlogfs_inode(inode)->li_block->ta = ta;\r\n}\r\nvoid logfs_del_transaction(struct inode *inode, struct logfs_transaction *ta)\r\n{\r\nstruct logfs_block *block = logfs_inode(inode)->li_block;\r\nif (block && block->ta)\r\nblock->ta = NULL;\r\n}\r\nstatic int grow_inode(struct inode *inode, u64 bix, level_t level)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nu8 height = (__force u8)level;\r\nstruct page *page;\r\nstruct write_control wc = {\r\n.flags = WF_WRITE,\r\n};\r\nint err;\r\nBUG_ON(height > 5 || li->li_height > 5);\r\nwhile (height > li->li_height || bix >= maxbix(li->li_height)) {\r\npage = logfs_get_write_page(inode, I0_BLOCKS + 1,\r\nLEVEL(li->li_height + 1));\r\nif (!page)\r\nreturn -ENOMEM;\r\nlogfs_read_empty(page);\r\nalloc_indirect_block(inode, page, 1);\r\nblock_set_pointer(page, 0, li->li_data[INDIRECT_INDEX]);\r\nerr = logfs_write_i0(inode, page, &wc);\r\nlogfs_put_write_page(page);\r\nif (err)\r\nreturn err;\r\nli->li_data[INDIRECT_INDEX] = wc.ofs;\r\nwc.ofs = 0;\r\nli->li_height++;\r\nlogfs_set_alias(inode->i_sb, li->li_block, INODE_HEIGHT_OFS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __logfs_write_buf(struct inode *inode, struct page *page, long flags)\r\n{\r\nstruct logfs_super *super = logfs_super(inode->i_sb);\r\npgoff_t index = page->index;\r\nu64 bix;\r\nlevel_t level;\r\nint err;\r\nflags |= WF_WRITE | WF_DELETE;\r\ninode->i_ctime = inode->i_mtime = CURRENT_TIME;\r\nlogfs_unpack_index(index, &bix, &level);\r\nif (logfs_block(page) && logfs_block(page)->reserved_bytes)\r\nsuper->s_dirty_pages -= logfs_block(page)->reserved_bytes;\r\nif (index < I0_BLOCKS)\r\nreturn logfs_write_direct(inode, page, flags);\r\nbix = adjust_bix(bix, level);\r\nerr = grow_inode(inode, bix, level);\r\nif (err)\r\nreturn err;\r\nreturn logfs_write_rec(inode, page, bix, level, flags);\r\n}\r\nint logfs_write_buf(struct inode *inode, struct page *page, long flags)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nint ret;\r\nlogfs_get_wblocks(sb, page, flags & WF_LOCK);\r\nret = __logfs_write_buf(inode, page, flags);\r\nlogfs_put_wblocks(sb, page, flags & WF_LOCK);\r\nreturn ret;\r\n}\r\nstatic int __logfs_delete(struct inode *inode, struct page *page)\r\n{\r\nlong flags = WF_DELETE;\r\nint err;\r\ninode->i_ctime = inode->i_mtime = CURRENT_TIME;\r\nif (page->index < I0_BLOCKS)\r\nreturn logfs_write_direct(inode, page, flags);\r\nerr = grow_inode(inode, page->index, 0);\r\nif (err)\r\nreturn err;\r\nreturn logfs_write_rec(inode, page, page->index, 0, flags);\r\n}\r\nint logfs_delete(struct inode *inode, pgoff_t index,\r\nstruct shadow_tree *shadow_tree)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct page *page;\r\nint ret;\r\npage = logfs_get_read_page(inode, index, 0);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlogfs_get_wblocks(sb, page, 1);\r\nret = __logfs_delete(inode, page);\r\nlogfs_put_wblocks(sb, page, 1);\r\nlogfs_put_read_page(page);\r\nreturn ret;\r\n}\r\nint logfs_rewrite_block(struct inode *inode, u64 bix, u64 ofs,\r\ngc_level_t gc_level, long flags)\r\n{\r\nlevel_t level = shrink_level(gc_level);\r\nstruct page *page;\r\nint err;\r\npage = logfs_get_write_page(inode, bix, level);\r\nif (!page)\r\nreturn -ENOMEM;\r\nerr = logfs_segment_read(inode, page, ofs, bix, level);\r\nif (!err) {\r\nif (level != 0)\r\nalloc_indirect_block(inode, page, 0);\r\nerr = logfs_write_buf(inode, page, flags);\r\nif (!err && shrink_level(gc_level) == 0) {\r\nif (inode->i_ino == LOGFS_INO_MASTER)\r\nlogfs_write_anchor(inode->i_sb);\r\nelse {\r\nerr = __logfs_write_inode(inode, page, flags);\r\n}\r\n}\r\n}\r\nlogfs_put_write_page(page);\r\nreturn err;\r\n}\r\nstatic int truncate_data_block(struct inode *inode, struct page *page,\r\nu64 ofs, struct logfs_shadow *shadow, u64 size)\r\n{\r\nloff_t pageofs = page->index << inode->i_sb->s_blocksize_bits;\r\nu64 bix;\r\nlevel_t level;\r\nint err;\r\nif (size <= pageofs || size - pageofs >= PAGE_SIZE)\r\nreturn 0;\r\nlogfs_unpack_index(page->index, &bix, &level);\r\nBUG_ON(level != 0);\r\nerr = logfs_segment_read(inode, page, ofs, bix, level);\r\nif (err)\r\nreturn err;\r\nzero_user_segment(page, size - pageofs, PAGE_CACHE_SIZE);\r\nreturn logfs_segment_write(inode, page, shadow);\r\n}\r\nstatic int logfs_truncate_i0(struct inode *inode, struct page *page,\r\nstruct write_control *wc, u64 size)\r\n{\r\nstruct logfs_shadow *shadow;\r\nu64 bix;\r\nlevel_t level;\r\nint err = 0;\r\nlogfs_unpack_index(page->index, &bix, &level);\r\nBUG_ON(level != 0);\r\nshadow = alloc_shadow(inode, bix, level, wc->ofs);\r\nerr = truncate_data_block(inode, page, wc->ofs, shadow, size);\r\nif (err) {\r\nfree_shadow(inode, shadow);\r\nreturn err;\r\n}\r\nlogfs_segment_delete(inode, shadow);\r\nset_iused(inode, shadow);\r\nfill_shadow_tree(inode, page, shadow);\r\nwc->ofs = shadow->new_ofs;\r\nreturn 0;\r\n}\r\nstatic int logfs_truncate_direct(struct inode *inode, u64 size)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct write_control wc;\r\nstruct page *page;\r\nint e;\r\nint err;\r\nalloc_inode_block(inode);\r\nfor (e = I0_BLOCKS - 1; e >= 0; e--) {\r\nif (size > (e+1) * LOGFS_BLOCKSIZE)\r\nbreak;\r\nwc.ofs = li->li_data[e];\r\nif (!wc.ofs)\r\ncontinue;\r\npage = logfs_get_write_page(inode, e, 0);\r\nif (!page)\r\nreturn -ENOMEM;\r\nerr = logfs_segment_read(inode, page, wc.ofs, e, 0);\r\nif (err) {\r\nlogfs_put_write_page(page);\r\nreturn err;\r\n}\r\nerr = logfs_truncate_i0(inode, page, &wc, size);\r\nlogfs_put_write_page(page);\r\nif (err)\r\nreturn err;\r\nli->li_data[e] = wc.ofs;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u64 logfs_step(level_t level)\r\n{\r\nreturn __logfs_step[(__force u8)level];\r\n}\r\nstatic inline u64 logfs_factor(u8 level)\r\n{\r\nreturn __logfs_step[level] * LOGFS_BLOCKSIZE;\r\n}\r\nstatic inline u64 logfs_start_index(level_t level)\r\n{\r\nreturn __logfs_start_index[(__force u8)level];\r\n}\r\nstatic void logfs_unpack_raw_index(pgoff_t index, u64 *bix, level_t *level)\r\n{\r\nlogfs_unpack_index(index, bix, level);\r\nif (*bix <= logfs_start_index(SUBLEVEL(*level)))\r\n*bix = 0;\r\n}\r\nstatic int __logfs_truncate_rec(struct inode *inode, struct page *ipage,\r\nstruct write_control *this_wc, u64 size)\r\n{\r\nint truncate_happened = 0;\r\nint e, err = 0;\r\nu64 bix, child_bix, next_bix;\r\nlevel_t level;\r\nstruct page *page;\r\nstruct write_control child_wc = { };\r\nlogfs_unpack_raw_index(ipage->index, &bix, &level);\r\nerr = logfs_segment_read(inode, ipage, this_wc->ofs, bix, level);\r\nif (err)\r\nreturn err;\r\nfor (e = LOGFS_BLOCK_FACTOR - 1; e >= 0; e--) {\r\nchild_bix = bix + e * logfs_step(SUBLEVEL(level));\r\nnext_bix = child_bix + logfs_step(SUBLEVEL(level));\r\nif (size > next_bix * LOGFS_BLOCKSIZE)\r\nbreak;\r\nchild_wc.ofs = pure_ofs(block_get_pointer(ipage, e));\r\nif (!child_wc.ofs)\r\ncontinue;\r\npage = logfs_get_write_page(inode, child_bix, SUBLEVEL(level));\r\nif (!page)\r\nreturn -ENOMEM;\r\nif ((__force u8)level > 1)\r\nerr = __logfs_truncate_rec(inode, page, &child_wc, size);\r\nelse\r\nerr = logfs_truncate_i0(inode, page, &child_wc, size);\r\nlogfs_put_write_page(page);\r\nif (err)\r\nreturn err;\r\ntruncate_happened = 1;\r\nalloc_indirect_block(inode, ipage, 0);\r\nblock_set_pointer(ipage, e, child_wc.ofs);\r\n}\r\nif (!truncate_happened) {\r\nprintk("ineffectual truncate (%lx, %lx, %llx)\n", inode->i_ino, ipage->index, size);\r\nreturn 0;\r\n}\r\nthis_wc->flags = WF_DELETE;\r\nif (logfs_block(ipage)->partial)\r\nthis_wc->flags |= WF_WRITE;\r\nreturn logfs_write_i0(inode, ipage, this_wc);\r\n}\r\nstatic int logfs_truncate_rec(struct inode *inode, u64 size)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct write_control wc = {\r\n.ofs = li->li_data[INDIRECT_INDEX],\r\n};\r\nstruct page *page;\r\nint err;\r\nalloc_inode_block(inode);\r\nif (!wc.ofs)\r\nreturn 0;\r\npage = logfs_get_write_page(inode, 0, LEVEL(li->li_height));\r\nif (!page)\r\nreturn -ENOMEM;\r\nerr = __logfs_truncate_rec(inode, page, &wc, size);\r\nlogfs_put_write_page(page);\r\nif (err)\r\nreturn err;\r\nif (li->li_data[INDIRECT_INDEX] != wc.ofs)\r\nli->li_data[INDIRECT_INDEX] = wc.ofs;\r\nreturn 0;\r\n}\r\nstatic int __logfs_truncate(struct inode *inode, u64 size)\r\n{\r\nint ret;\r\nif (size >= logfs_factor(logfs_inode(inode)->li_height))\r\nreturn 0;\r\nret = logfs_truncate_rec(inode, size);\r\nif (ret)\r\nreturn ret;\r\nreturn logfs_truncate_direct(inode, size);\r\n}\r\nint logfs_truncate(struct inode *inode, u64 target)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nu64 size = i_size_read(inode);\r\nint err = 0;\r\nsize = ALIGN(size, TRUNCATE_STEP);\r\nwhile (size > target) {\r\nif (size > TRUNCATE_STEP)\r\nsize -= TRUNCATE_STEP;\r\nelse\r\nsize = 0;\r\nif (size < target)\r\nsize = target;\r\nlogfs_get_wblocks(sb, NULL, 1);\r\nerr = __logfs_truncate(inode, size);\r\nif (!err)\r\nerr = __logfs_write_inode(inode, NULL, 0);\r\nlogfs_put_wblocks(sb, NULL, 1);\r\n}\r\nif (!err) {\r\nerr = inode_newsize_ok(inode, target);\r\nif (err)\r\ngoto out;\r\ntruncate_setsize(inode, target);\r\n}\r\nout:\r\nWARN_ON(err);\r\nreturn err;\r\n}\r\nstatic void move_page_to_inode(struct inode *inode, struct page *page)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct logfs_block *block = logfs_block(page);\r\nif (!block)\r\nreturn;\r\nlog_blockmove("move_page_to_inode(%llx, %llx, %x)\n",\r\nblock->ino, block->bix, block->level);\r\nBUG_ON(li->li_block);\r\nblock->ops = &inode_block_ops;\r\nblock->inode = inode;\r\nli->li_block = block;\r\nblock->page = NULL;\r\nif (PagePrivate(page)) {\r\nClearPagePrivate(page);\r\npage_cache_release(page);\r\nset_page_private(page, 0);\r\n}\r\n}\r\nstatic void move_inode_to_page(struct page *page, struct inode *inode)\r\n{\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct logfs_block *block = li->li_block;\r\nif (!block)\r\nreturn;\r\nlog_blockmove("move_inode_to_page(%llx, %llx, %x)\n",\r\nblock->ino, block->bix, block->level);\r\nBUG_ON(PagePrivate(page));\r\nblock->ops = &indirect_block_ops;\r\nblock->page = page;\r\nif (!PagePrivate(page)) {\r\nSetPagePrivate(page);\r\npage_cache_get(page);\r\nset_page_private(page, (unsigned long) block);\r\n}\r\nblock->inode = NULL;\r\nli->li_block = NULL;\r\n}\r\nint logfs_read_inode(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct inode *master_inode = super->s_master_inode;\r\nstruct page *page;\r\nstruct logfs_disk_inode *di;\r\nu64 ino = inode->i_ino;\r\nif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\r\nreturn -ENODATA;\r\nif (!logfs_exist_block(master_inode, ino))\r\nreturn -ENODATA;\r\npage = read_cache_page(master_inode->i_mapping, ino,\r\n(filler_t *)logfs_readpage, NULL);\r\nif (IS_ERR(page))\r\nreturn PTR_ERR(page);\r\ndi = kmap_atomic(page);\r\nlogfs_disk_to_inode(di, inode);\r\nkunmap_atomic(di);\r\nmove_page_to_inode(inode, page);\r\npage_cache_release(page);\r\nreturn 0;\r\n}\r\nstatic struct page *inode_to_page(struct inode *inode)\r\n{\r\nstruct inode *master_inode = logfs_super(inode->i_sb)->s_master_inode;\r\nstruct logfs_disk_inode *di;\r\nstruct page *page;\r\nBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\r\npage = logfs_get_write_page(master_inode, inode->i_ino, 0);\r\nif (!page)\r\nreturn NULL;\r\ndi = kmap_atomic(page);\r\nlogfs_inode_to_disk(inode, di);\r\nkunmap_atomic(di);\r\nmove_inode_to_page(page, inode);\r\nreturn page;\r\n}\r\nstatic int do_write_inode(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct inode *master_inode = logfs_super(sb)->s_master_inode;\r\nloff_t size = (inode->i_ino + 1) << inode->i_sb->s_blocksize_bits;\r\nstruct page *page;\r\nint err;\r\nBUG_ON(inode->i_ino == LOGFS_INO_MASTER);\r\nif (i_size_read(master_inode) < size)\r\ni_size_write(master_inode, size);\r\npage = inode_to_page(inode);\r\nif (!page)\r\nreturn -ENOMEM;\r\nerr = logfs_write_buf(master_inode, page, 0);\r\nif (err)\r\nmove_page_to_inode(inode, page);\r\nlogfs_put_write_page(page);\r\nreturn err;\r\n}\r\nstatic void logfs_mod_segment_entry(struct super_block *sb, u32 segno,\r\nint write,\r\nvoid (*change_se)(struct logfs_segment_entry *, long),\r\nlong arg)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct inode *inode;\r\nstruct page *page;\r\nstruct logfs_segment_entry *se;\r\npgoff_t page_no;\r\nint child_no;\r\npage_no = segno >> (sb->s_blocksize_bits - 3);\r\nchild_no = segno & ((sb->s_blocksize >> 3) - 1);\r\ninode = super->s_segfile_inode;\r\npage = logfs_get_write_page(inode, page_no, 0);\r\nBUG_ON(!page);\r\nif (!PageUptodate(page))\r\nlogfs_read_block(inode, page, WRITE);\r\nif (write)\r\nalloc_indirect_block(inode, page, 0);\r\nse = kmap_atomic(page);\r\nchange_se(se + child_no, arg);\r\nif (write) {\r\nlogfs_set_alias(sb, logfs_block(page), child_no);\r\nBUG_ON((int)be32_to_cpu(se[child_no].valid) > super->s_segsize);\r\n}\r\nkunmap_atomic(se);\r\nlogfs_put_write_page(page);\r\n}\r\nstatic void __get_segment_entry(struct logfs_segment_entry *se, long _target)\r\n{\r\nstruct logfs_segment_entry *target = (void *)_target;\r\n*target = *se;\r\n}\r\nvoid logfs_get_segment_entry(struct super_block *sb, u32 segno,\r\nstruct logfs_segment_entry *se)\r\n{\r\nlogfs_mod_segment_entry(sb, segno, 0, __get_segment_entry, (long)se);\r\n}\r\nstatic void __set_segment_used(struct logfs_segment_entry *se, long increment)\r\n{\r\nu32 valid;\r\nvalid = be32_to_cpu(se->valid);\r\nvalid += increment;\r\nse->valid = cpu_to_be32(valid);\r\n}\r\nvoid logfs_set_segment_used(struct super_block *sb, u64 ofs, int increment)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nu32 segno = ofs >> super->s_segshift;\r\nif (!increment)\r\nreturn;\r\nlogfs_mod_segment_entry(sb, segno, 1, __set_segment_used, increment);\r\n}\r\nstatic void __set_segment_erased(struct logfs_segment_entry *se, long ec_level)\r\n{\r\nse->ec_level = cpu_to_be32(ec_level);\r\n}\r\nvoid logfs_set_segment_erased(struct super_block *sb, u32 segno, u32 ec,\r\ngc_level_t gc_level)\r\n{\r\nu32 ec_level = ec << 4 | (__force u8)gc_level;\r\nlogfs_mod_segment_entry(sb, segno, 1, __set_segment_erased, ec_level);\r\n}\r\nstatic void __set_segment_reserved(struct logfs_segment_entry *se, long ignore)\r\n{\r\nse->valid = cpu_to_be32(RESERVED);\r\n}\r\nvoid logfs_set_segment_reserved(struct super_block *sb, u32 segno)\r\n{\r\nlogfs_mod_segment_entry(sb, segno, 1, __set_segment_reserved, 0);\r\n}\r\nstatic void __set_segment_unreserved(struct logfs_segment_entry *se,\r\nlong ec_level)\r\n{\r\nse->valid = 0;\r\nse->ec_level = cpu_to_be32(ec_level);\r\n}\r\nvoid logfs_set_segment_unreserved(struct super_block *sb, u32 segno, u32 ec)\r\n{\r\nu32 ec_level = ec << 4;\r\nlogfs_mod_segment_entry(sb, segno, 1, __set_segment_unreserved,\r\nec_level);\r\n}\r\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nint ret;\r\nlogfs_get_wblocks(sb, page, flags & WF_LOCK);\r\nret = do_write_inode(inode);\r\nlogfs_put_wblocks(sb, page, flags & WF_LOCK);\r\nreturn ret;\r\n}\r\nstatic int do_delete_inode(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct inode *master_inode = logfs_super(sb)->s_master_inode;\r\nstruct page *page;\r\nint ret;\r\npage = logfs_get_write_page(master_inode, inode->i_ino, 0);\r\nif (!page)\r\nreturn -ENOMEM;\r\nmove_inode_to_page(page, inode);\r\nlogfs_get_wblocks(sb, page, 1);\r\nret = __logfs_delete(master_inode, page);\r\nlogfs_put_wblocks(sb, page, 1);\r\nlogfs_put_write_page(page);\r\nreturn ret;\r\n}\r\nvoid logfs_evict_inode(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct logfs_inode *li = logfs_inode(inode);\r\nstruct logfs_block *block = li->li_block;\r\nstruct page *page;\r\nif (!inode->i_nlink) {\r\nif (!(li->li_flags & LOGFS_IF_ZOMBIE)) {\r\nli->li_flags |= LOGFS_IF_ZOMBIE;\r\nif (i_size_read(inode) > 0)\r\nlogfs_truncate(inode, 0);\r\ndo_delete_inode(inode);\r\n}\r\n}\r\ntruncate_inode_pages(&inode->i_data, 0);\r\nclear_inode(inode);\r\nBUG_ON(inode->i_state & I_DIRTY && inode->i_nlink);\r\nif (!block)\r\nreturn;\r\nif ((logfs_super(sb)->s_flags & LOGFS_SB_FLAG_SHUTDOWN)) {\r\nblock->ops->free_block(inode->i_sb, block);\r\nreturn;\r\n}\r\npage = inode_to_page(inode);\r\nBUG_ON(!page);\r\nlogfs_put_write_page(page);\r\n}\r\nvoid btree_write_block(struct logfs_block *block)\r\n{\r\nstruct inode *inode;\r\nstruct page *page;\r\nint err, cookie;\r\ninode = logfs_safe_iget(block->sb, block->ino, &cookie);\r\npage = logfs_get_write_page(inode, block->bix, block->level);\r\nerr = logfs_readpage_nolock(page);\r\nBUG_ON(err);\r\nBUG_ON(!PagePrivate(page));\r\nBUG_ON(logfs_block(page) != block);\r\nerr = __logfs_write_buf(inode, page, 0);\r\nBUG_ON(err);\r\nBUG_ON(PagePrivate(page) || page->private);\r\nlogfs_put_write_page(page);\r\nlogfs_safe_iput(inode, cookie);\r\n}\r\nint logfs_inode_write(struct inode *inode, const void *buf, size_t count,\r\nloff_t bix, long flags, struct shadow_tree *shadow_tree)\r\n{\r\nloff_t pos = bix << inode->i_sb->s_blocksize_bits;\r\nint err;\r\nstruct page *page;\r\nvoid *pagebuf;\r\nBUG_ON(pos & (LOGFS_BLOCKSIZE-1));\r\nBUG_ON(count > LOGFS_BLOCKSIZE);\r\npage = logfs_get_write_page(inode, bix, 0);\r\nif (!page)\r\nreturn -ENOMEM;\r\npagebuf = kmap_atomic(page);\r\nmemcpy(pagebuf, buf, count);\r\nflush_dcache_page(page);\r\nkunmap_atomic(pagebuf);\r\nif (i_size_read(inode) < pos + LOGFS_BLOCKSIZE)\r\ni_size_write(inode, pos + LOGFS_BLOCKSIZE);\r\nerr = logfs_write_buf(inode, page, flags);\r\nlogfs_put_write_page(page);\r\nreturn err;\r\n}\r\nint logfs_open_segfile(struct super_block *sb)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nstruct inode *inode;\r\ninode = logfs_read_meta_inode(sb, LOGFS_INO_SEGFILE);\r\nif (IS_ERR(inode))\r\nreturn PTR_ERR(inode);\r\nsuper->s_segfile_inode = inode;\r\nreturn 0;\r\n}\r\nint logfs_init_rw(struct super_block *sb)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nint min_fill = 3 * super->s_no_blocks;\r\nINIT_LIST_HEAD(&super->s_object_alias);\r\nINIT_LIST_HEAD(&super->s_writeback_list);\r\nmutex_init(&super->s_write_mutex);\r\nsuper->s_block_pool = mempool_create_kmalloc_pool(min_fill,\r\nsizeof(struct logfs_block));\r\nsuper->s_shadow_pool = mempool_create_kmalloc_pool(min_fill,\r\nsizeof(struct logfs_shadow));\r\nreturn 0;\r\n}\r\nvoid logfs_cleanup_rw(struct super_block *sb)\r\n{\r\nstruct logfs_super *super = logfs_super(sb);\r\nlogfs_mempool_destroy(super->s_block_pool);\r\nlogfs_mempool_destroy(super->s_shadow_pool);\r\n}
