static unsigned char read_zsreg(struct zilog_channel __iomem *channel,\r\nunsigned char reg)\r\n{\r\nunsigned char retval;\r\nwriteb(reg, &channel->control);\r\nZSDELAY();\r\nretval = readb(&channel->control);\r\nZSDELAY();\r\nreturn retval;\r\n}\r\nstatic void write_zsreg(struct zilog_channel __iomem *channel,\r\nunsigned char reg, unsigned char value)\r\n{\r\nwriteb(reg, &channel->control);\r\nZSDELAY();\r\nwriteb(value, &channel->control);\r\nZSDELAY();\r\n}\r\nstatic void sunzilog_clear_fifo(struct zilog_channel __iomem *channel)\r\n{\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nunsigned char regval;\r\nregval = readb(&channel->control);\r\nZSDELAY();\r\nif (regval & Rx_CH_AV)\r\nbreak;\r\nregval = read_zsreg(channel, R1);\r\nreadb(&channel->data);\r\nZSDELAY();\r\nif (regval & (PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\n}\r\n}\r\nstatic int __load_zsregs(struct zilog_channel __iomem *channel, unsigned char *regs)\r\n{\r\nint i;\r\nint escc;\r\nunsigned char r15;\r\nfor (i = 0; i < 1000; i++) {\r\nunsigned char stat = read_zsreg(channel, R1);\r\nif (stat & ALL_SNT)\r\nbreak;\r\nudelay(100);\r\n}\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nsunzilog_clear_fifo(channel);\r\nwrite_zsreg(channel, R1,\r\nregs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));\r\nwrite_zsreg(channel, R4, regs[R4]);\r\nwrite_zsreg(channel, R10, regs[R10]);\r\nwrite_zsreg(channel, R3, regs[R3] & ~RxENAB);\r\nwrite_zsreg(channel, R5, regs[R5] & ~TxENAB);\r\nwrite_zsreg(channel, R6, regs[R6]);\r\nwrite_zsreg(channel, R7, regs[R7]);\r\nwrite_zsreg(channel, R14, regs[R14] & ~BRENAB);\r\nwrite_zsreg(channel, R11, regs[R11]);\r\nwrite_zsreg(channel, R12, regs[R12]);\r\nwrite_zsreg(channel, R13, regs[R13]);\r\nwrite_zsreg(channel, R14, regs[R14]);\r\nwrite_zsreg(channel, R15, (regs[R15] | WR7pEN) & ~FIFOEN);\r\nr15 = read_zsreg(channel, R15);\r\nif (r15 & 0x01) {\r\nwrite_zsreg(channel, R7, regs[R7p]);\r\nwrite_zsreg(channel, R15, regs[R15] & ~WR7pEN);\r\nescc = 1;\r\n} else {\r\nregs[R15] &= ~FIFOEN;\r\nescc = 0;\r\n}\r\nwrite_zsreg(channel, R0, RES_EXT_INT);\r\nwrite_zsreg(channel, R0, RES_EXT_INT);\r\nwrite_zsreg(channel, R3, regs[R3]);\r\nwrite_zsreg(channel, R5, regs[R5]);\r\nwrite_zsreg(channel, R1, regs[R1]);\r\nreturn escc;\r\n}\r\nstatic void sunzilog_maybe_update_regs(struct uart_sunzilog_port *up,\r\nstruct zilog_channel __iomem *channel)\r\n{\r\nif (!ZS_REGS_HELD(up)) {\r\nif (ZS_TX_ACTIVE(up)) {\r\nup->flags |= SUNZILOG_FLAG_REGS_HELD;\r\n} else {\r\n__load_zsregs(channel, up->curregs);\r\n}\r\n}\r\n}\r\nstatic void sunzilog_change_mouse_baud(struct uart_sunzilog_port *up)\r\n{\r\nunsigned int cur_cflag = up->cflag;\r\nint brg, new_baud;\r\nup->cflag &= ~CBAUD;\r\nup->cflag |= suncore_mouse_baud_cflag_next(cur_cflag, &new_baud);\r\nbrg = BPS_TO_BRG(new_baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nup->curregs[R12] = (brg & 0xff);\r\nup->curregs[R13] = (brg >> 8) & 0xff;\r\nsunzilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(&up->port));\r\n}\r\nstatic void sunzilog_kbdms_receive_chars(struct uart_sunzilog_port *up,\r\nunsigned char ch, int is_break)\r\n{\r\nif (ZS_IS_KEYB(up)) {\r\n#ifdef CONFIG_SERIO\r\nif (up->serio_open)\r\nserio_interrupt(&up->serio, ch, 0);\r\n#endif\r\n} else if (ZS_IS_MOUSE(up)) {\r\nint ret = suncore_mouse_baud_detection(ch, is_break);\r\nswitch (ret) {\r\ncase 2:\r\nsunzilog_change_mouse_baud(up);\r\ncase 1:\r\nbreak;\r\ncase 0:\r\n#ifdef CONFIG_SERIO\r\nif (up->serio_open)\r\nserio_interrupt(&up->serio, ch, 0);\r\n#endif\r\nbreak;\r\n};\r\n}\r\n}\r\nstatic struct tty_port *\r\nsunzilog_receive_chars(struct uart_sunzilog_port *up,\r\nstruct zilog_channel __iomem *channel)\r\n{\r\nstruct tty_port *port = NULL;\r\nunsigned char ch, r1, flag;\r\nif (up->port.state != NULL)\r\nport = &up->port.state->port;\r\nfor (;;) {\r\nr1 = read_zsreg(channel, R1);\r\nif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nch = readb(&channel->control);\r\nZSDELAY();\r\nif (ch & BRK_ABRT)\r\nr1 |= BRK_ABRT;\r\nif (!(ch & Rx_CH_AV))\r\nbreak;\r\nch = readb(&channel->data);\r\nZSDELAY();\r\nch &= up->parity_mask;\r\nif (unlikely(ZS_IS_KEYB(up)) || unlikely(ZS_IS_MOUSE(up))) {\r\nsunzilog_kbdms_receive_chars(up, ch, 0);\r\ncontinue;\r\n}\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (r1 & (BRK_ABRT | PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nif (r1 & BRK_ABRT) {\r\nr1 &= ~(PAR_ERR | CRC_ERR);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\ncontinue;\r\n}\r\nelse if (r1 & PAR_ERR)\r\nup->port.icount.parity++;\r\nelse if (r1 & CRC_ERR)\r\nup->port.icount.frame++;\r\nif (r1 & Rx_OVR)\r\nup->port.icount.overrun++;\r\nr1 &= up->port.read_status_mask;\r\nif (r1 & BRK_ABRT)\r\nflag = TTY_BREAK;\r\nelse if (r1 & PAR_ERR)\r\nflag = TTY_PARITY;\r\nelse if (r1 & CRC_ERR)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch) || !port)\r\ncontinue;\r\nif (up->port.ignore_status_mask == 0xff ||\r\n(r1 & up->port.ignore_status_mask) == 0) {\r\ntty_insert_flip_char(port, ch, flag);\r\n}\r\nif (r1 & Rx_OVR)\r\ntty_insert_flip_char(port, 0, TTY_OVERRUN);\r\n}\r\nreturn port;\r\n}\r\nstatic void sunzilog_status_handle(struct uart_sunzilog_port *up,\r\nstruct zilog_channel __iomem *channel)\r\n{\r\nunsigned char status;\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nwriteb(RES_EXT_INT, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nif (status & BRK_ABRT) {\r\nif (ZS_IS_MOUSE(up))\r\nsunzilog_kbdms_receive_chars(up, 0, 1);\r\nif (ZS_IS_CONS(up)) {\r\nwhile (1) {\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nif (!(status & BRK_ABRT))\r\nbreak;\r\n}\r\nsun_do_break();\r\nreturn;\r\n}\r\n}\r\nif (ZS_WANTS_MODEM_STATUS(up)) {\r\nif (status & SYNC)\r\nup->port.icount.dsr++;\r\nif ((status ^ up->prev_status) ^ DCD)\r\nuart_handle_dcd_change(&up->port,\r\n(status & DCD));\r\nif ((status ^ up->prev_status) ^ CTS)\r\nuart_handle_cts_change(&up->port,\r\n(status & CTS));\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nup->prev_status = status;\r\n}\r\nstatic void sunzilog_transmit_chars(struct uart_sunzilog_port *up,\r\nstruct zilog_channel __iomem *channel)\r\n{\r\nstruct circ_buf *xmit;\r\nif (ZS_IS_CONS(up)) {\r\nunsigned char status = readb(&channel->control);\r\nZSDELAY();\r\nif (!(status & Tx_BUF_EMP))\r\nreturn;\r\n}\r\nup->flags &= ~SUNZILOG_FLAG_TX_ACTIVE;\r\nif (ZS_REGS_HELD(up)) {\r\n__load_zsregs(channel, up->curregs);\r\nup->flags &= ~SUNZILOG_FLAG_REGS_HELD;\r\n}\r\nif (ZS_TX_STOPPED(up)) {\r\nup->flags &= ~SUNZILOG_FLAG_TX_STOPPED;\r\ngoto ack_tx_int;\r\n}\r\nif (up->port.x_char) {\r\nup->flags |= SUNZILOG_FLAG_TX_ACTIVE;\r\nwriteb(up->port.x_char, &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (up->port.state == NULL)\r\ngoto ack_tx_int;\r\nxmit = &up->port.state->xmit;\r\nif (uart_circ_empty(xmit))\r\ngoto ack_tx_int;\r\nif (uart_tx_stopped(&up->port))\r\ngoto ack_tx_int;\r\nup->flags |= SUNZILOG_FLAG_TX_ACTIVE;\r\nwriteb(xmit->buf[xmit->tail], &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nreturn;\r\nack_tx_int:\r\nwriteb(RES_Tx_P, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nstatic irqreturn_t sunzilog_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_sunzilog_port *up = dev_id;\r\nwhile (up) {\r\nstruct zilog_channel __iomem *channel\r\n= ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nstruct tty_port *port;\r\nunsigned char r3;\r\nspin_lock(&up->port.lock);\r\nr3 = read_zsreg(channel, R3);\r\nport = NULL;\r\nif (r3 & (CHAEXT | CHATxIP | CHARxIP)) {\r\nwriteb(RES_H_IUS, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nif (r3 & CHARxIP)\r\nport = sunzilog_receive_chars(up, channel);\r\nif (r3 & CHAEXT)\r\nsunzilog_status_handle(up, channel);\r\nif (r3 & CHATxIP)\r\nsunzilog_transmit_chars(up, channel);\r\n}\r\nspin_unlock(&up->port.lock);\r\nif (port)\r\ntty_flip_buffer_push(port);\r\nup = up->next;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nspin_lock(&up->port.lock);\r\nport = NULL;\r\nif (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {\r\nwriteb(RES_H_IUS, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nif (r3 & CHBRxIP)\r\nport = sunzilog_receive_chars(up, channel);\r\nif (r3 & CHBEXT)\r\nsunzilog_status_handle(up, channel);\r\nif (r3 & CHBTxIP)\r\nsunzilog_transmit_chars(up, channel);\r\n}\r\nspin_unlock(&up->port.lock);\r\nif (port)\r\ntty_flip_buffer_push(port);\r\nup = up->next;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __inline__ unsigned char sunzilog_read_channel_status(struct uart_port *port)\r\n{\r\nstruct zilog_channel __iomem *channel;\r\nunsigned char status;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(port);\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nreturn status;\r\n}\r\nstatic unsigned int sunzilog_tx_empty(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nunsigned char status;\r\nunsigned int ret;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = sunzilog_read_channel_status(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (status & Tx_BUF_EMP)\r\nret = TIOCSER_TEMT;\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic unsigned int sunzilog_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = sunzilog_read_channel_status(port);\r\nret = 0;\r\nif (status & DCD)\r\nret |= TIOCM_CAR;\r\nif (status & SYNC)\r\nret |= TIOCM_DSR;\r\nif (status & CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void sunzilog_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char set_bits, clear_bits;\r\nset_bits = clear_bits = 0;\r\nif (mctrl & TIOCM_RTS)\r\nset_bits |= RTS;\r\nelse\r\nclear_bits |= RTS;\r\nif (mctrl & TIOCM_DTR)\r\nset_bits |= DTR;\r\nelse\r\nclear_bits |= DTR;\r\nup->curregs[R5] |= set_bits;\r\nup->curregs[R5] &= ~clear_bits;\r\nwrite_zsreg(channel, R5, up->curregs[R5]);\r\n}\r\nstatic void sunzilog_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nup->flags |= SUNZILOG_FLAG_TX_STOPPED;\r\n}\r\nstatic void sunzilog_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char status;\r\nup->flags |= SUNZILOG_FLAG_TX_ACTIVE;\r\nup->flags &= ~SUNZILOG_FLAG_TX_STOPPED;\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nif (!(status & Tx_BUF_EMP))\r\nreturn;\r\nif (port->x_char) {\r\nwriteb(port->x_char, &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n} else {\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nwriteb(xmit->buf[xmit->tail], &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\n}\r\n}\r\nstatic void sunzilog_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = UART_ZILOG(port);\r\nstruct zilog_channel __iomem *channel;\r\nif (ZS_IS_CONS(up))\r\nreturn;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(port);\r\nup->curregs[R1] &= ~RxINT_MASK;\r\nsunzilog_maybe_update_regs(up, channel);\r\n}\r\nstatic void sunzilog_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char new_reg;\r\nnew_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);\r\nif (new_reg != up->curregs[R15]) {\r\nup->curregs[R15] = new_reg;\r\nwrite_zsreg(channel, R15, up->curregs[R15] & ~WR7pEN);\r\n}\r\n}\r\nstatic void sunzilog_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char set_bits, clear_bits, new_reg;\r\nunsigned long flags;\r\nset_bits = clear_bits = 0;\r\nif (break_state)\r\nset_bits |= SND_BRK;\r\nelse\r\nclear_bits |= SND_BRK;\r\nspin_lock_irqsave(&port->lock, flags);\r\nnew_reg = (up->curregs[R5] | set_bits) & ~clear_bits;\r\nif (new_reg != up->curregs[R5]) {\r\nup->curregs[R5] = new_reg;\r\nwrite_zsreg(channel, R5, up->curregs[R5]);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void __sunzilog_startup(struct uart_sunzilog_port *up)\r\n{\r\nstruct zilog_channel __iomem *channel;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nup->prev_status = readb(&channel->control);\r\nup->curregs[R3] |= RxENAB;\r\nup->curregs[R5] |= TxENAB;\r\nup->curregs[R1] |= EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\r\nsunzilog_maybe_update_regs(up, channel);\r\n}\r\nstatic int sunzilog_startup(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = UART_ZILOG(port);\r\nunsigned long flags;\r\nif (ZS_IS_CONS(up))\r\nreturn 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\n__sunzilog_startup(up);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sunzilog_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = UART_ZILOG(port);\r\nstruct zilog_channel __iomem *channel;\r\nunsigned long flags;\r\nif (ZS_IS_CONS(up))\r\nreturn;\r\nspin_lock_irqsave(&port->lock, flags);\r\nchannel = ZILOG_CHANNEL_FROM_PORT(port);\r\nup->curregs[R3] &= ~RxENAB;\r\nup->curregs[R5] &= ~TxENAB;\r\nup->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);\r\nup->curregs[R5] &= ~SND_BRK;\r\nsunzilog_maybe_update_regs(up, channel);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void\r\nsunzilog_convert_to_zs(struct uart_sunzilog_port *up, unsigned int cflag,\r\nunsigned int iflag, int brg)\r\n{\r\nup->curregs[R10] = NRZ;\r\nup->curregs[R11] = TCBR | RCBR;\r\nup->curregs[R4] &= ~XCLK_MASK;\r\nup->curregs[R4] |= X16CLK;\r\nup->curregs[R12] = brg & 0xff;\r\nup->curregs[R13] = (brg >> 8) & 0xff;\r\nup->curregs[R14] = BRSRC | BRENAB;\r\nup->curregs[R3] &= ~RxN_MASK;\r\nup->curregs[R5] &= ~TxN_MASK;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nup->curregs[R3] |= Rx5;\r\nup->curregs[R5] |= Tx5;\r\nup->parity_mask = 0x1f;\r\nbreak;\r\ncase CS6:\r\nup->curregs[R3] |= Rx6;\r\nup->curregs[R5] |= Tx6;\r\nup->parity_mask = 0x3f;\r\nbreak;\r\ncase CS7:\r\nup->curregs[R3] |= Rx7;\r\nup->curregs[R5] |= Tx7;\r\nup->parity_mask = 0x7f;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nup->curregs[R3] |= Rx8;\r\nup->curregs[R5] |= Tx8;\r\nup->parity_mask = 0xff;\r\nbreak;\r\n};\r\nup->curregs[R4] &= ~0x0c;\r\nif (cflag & CSTOPB)\r\nup->curregs[R4] |= SB2;\r\nelse\r\nup->curregs[R4] |= SB1;\r\nif (cflag & PARENB)\r\nup->curregs[R4] |= PAR_ENAB;\r\nelse\r\nup->curregs[R4] &= ~PAR_ENAB;\r\nif (!(cflag & PARODD))\r\nup->curregs[R4] |= PAR_EVEN;\r\nelse\r\nup->curregs[R4] &= ~PAR_EVEN;\r\nup->port.read_status_mask = Rx_OVR;\r\nif (iflag & INPCK)\r\nup->port.read_status_mask |= CRC_ERR | PAR_ERR;\r\nif (iflag & (BRKINT | PARMRK))\r\nup->port.read_status_mask |= BRK_ABRT;\r\nup->port.ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= CRC_ERR | PAR_ERR;\r\nif (iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= BRK_ABRT;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= Rx_OVR;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nup->port.ignore_status_mask = 0xff;\r\n}\r\nstatic void\r\nsunzilog_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nunsigned long flags;\r\nint baud, brg;\r\nbaud = uart_get_baud_rate(port, termios, old, 1200, 76800);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nsunzilog_convert_to_zs(up, termios->c_cflag, termios->c_iflag, brg);\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->flags |= SUNZILOG_FLAG_MODEM_STATUS;\r\nelse\r\nup->flags &= ~SUNZILOG_FLAG_MODEM_STATUS;\r\nup->cflag = termios->c_cflag;\r\nsunzilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic const char *sunzilog_type(struct uart_port *port)\r\n{\r\nstruct uart_sunzilog_port *up = UART_ZILOG(port);\r\nreturn (up->flags & SUNZILOG_FLAG_ESCC) ? "zs (ESCC)" : "zs";\r\n}\r\nstatic void sunzilog_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sunzilog_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sunzilog_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int sunzilog_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int sunzilog_get_poll_char(struct uart_port *port)\r\n{\r\nunsigned char ch, r1;\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *) port;\r\nstruct zilog_channel __iomem *channel\r\n= ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nr1 = read_zsreg(channel, R1);\r\nif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nch = readb(&channel->control);\r\nZSDELAY();\r\nif (ch & BRK_ABRT)\r\nr1 |= BRK_ABRT;\r\nif (!(ch & Rx_CH_AV))\r\nreturn NO_POLL_CHAR;\r\nch = readb(&channel->data);\r\nZSDELAY();\r\nch &= up->parity_mask;\r\nreturn ch;\r\n}\r\nstatic void sunzilog_put_poll_char(struct uart_port *port,\r\nunsigned char ch)\r\n{\r\nstruct uart_sunzilog_port *up = (struct uart_sunzilog_port *)port;\r\nsunzilog_putchar(&up->port, ch);\r\n}\r\nstatic int __init sunzilog_alloc_tables(int num_sunzilog)\r\n{\r\nstruct uart_sunzilog_port *up;\r\nunsigned long size;\r\nint num_channels = num_sunzilog * 2;\r\nint i;\r\nsize = num_channels * sizeof(struct uart_sunzilog_port);\r\nsunzilog_port_table = kzalloc(size, GFP_KERNEL);\r\nif (!sunzilog_port_table)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_channels; i++) {\r\nup = &sunzilog_port_table[i];\r\nspin_lock_init(&up->port.lock);\r\nif (i == 0)\r\nsunzilog_irq_chain = up;\r\nif (i < num_channels - 1)\r\nup->next = up + 1;\r\nelse\r\nup->next = NULL;\r\n}\r\nsize = num_sunzilog * sizeof(struct zilog_layout __iomem *);\r\nsunzilog_chip_regs = kzalloc(size, GFP_KERNEL);\r\nif (!sunzilog_chip_regs) {\r\nkfree(sunzilog_port_table);\r\nsunzilog_irq_chain = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sunzilog_free_tables(void)\r\n{\r\nkfree(sunzilog_port_table);\r\nsunzilog_irq_chain = NULL;\r\nkfree(sunzilog_chip_regs);\r\n}\r\nstatic void sunzilog_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct zilog_channel __iomem *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nint loops = ZS_PUT_CHAR_MAX_DELAY;\r\ndo {\r\nunsigned char val = readb(&channel->control);\r\nif (val & Tx_BUF_EMP) {\r\nZSDELAY();\r\nbreak;\r\n}\r\nudelay(5);\r\n} while (--loops);\r\nwriteb(ch, &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nstatic int sunzilog_serio_write(struct serio *serio, unsigned char ch)\r\n{\r\nstruct uart_sunzilog_port *up = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sunzilog_serio_lock, flags);\r\nsunzilog_putchar(&up->port, ch);\r\nspin_unlock_irqrestore(&sunzilog_serio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunzilog_serio_open(struct serio *serio)\r\n{\r\nstruct uart_sunzilog_port *up = serio->port_data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&sunzilog_serio_lock, flags);\r\nif (!up->serio_open) {\r\nup->serio_open = 1;\r\nret = 0;\r\n} else\r\nret = -EBUSY;\r\nspin_unlock_irqrestore(&sunzilog_serio_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sunzilog_serio_close(struct serio *serio)\r\n{\r\nstruct uart_sunzilog_port *up = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sunzilog_serio_lock, flags);\r\nup->serio_open = 0;\r\nspin_unlock_irqrestore(&sunzilog_serio_lock, flags);\r\n}\r\nstatic void\r\nsunzilog_console_write(struct console *con, const char *s, unsigned int count)\r\n{\r\nstruct uart_sunzilog_port *up = &sunzilog_port_table[con->index];\r\nunsigned long flags;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&up->port.lock);\r\n} else\r\nspin_lock(&up->port.lock);\r\nuart_console_write(&up->port, s, count, sunzilog_putchar);\r\nudelay(2);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init sunzilog_console_setup(struct console *con, char *options)\r\n{\r\nstruct uart_sunzilog_port *up = &sunzilog_port_table[con->index];\r\nunsigned long flags;\r\nint baud, brg;\r\nif (up->port.type != PORT_SUNZILOG)\r\nreturn -1;\r\nprintk(KERN_INFO "Console: ttyS%d (SunZilog zs%d)\n",\r\n(sunzilog_reg.minor - 64) + con->index, con->index);\r\nsunserial_console_termios(con, up->port.dev->of_node);\r\nswitch (con->cflag & CBAUD) {\r\ncase B150: baud = 150; break;\r\ncase B300: baud = 300; break;\r\ncase B600: baud = 600; break;\r\ncase B1200: baud = 1200; break;\r\ncase B2400: baud = 2400; break;\r\ncase B4800: baud = 4800; break;\r\ndefault: case B9600: baud = 9600; break;\r\ncase B19200: baud = 19200; break;\r\ncase B38400: baud = 38400; break;\r\n};\r\nbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->curregs[R15] |= BRKIE;\r\nsunzilog_convert_to_zs(up, con->cflag, 0, brg);\r\nsunzilog_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);\r\n__sunzilog_startup(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline struct console *SUNZILOG_CONSOLE(void)\r\n{\r\nreturn &sunzilog_console_ops;\r\n}\r\nstatic void sunzilog_init_kbdms(struct uart_sunzilog_port *up)\r\n{\r\nint baud, brg;\r\nif (up->flags & SUNZILOG_FLAG_CONS_KEYB) {\r\nup->cflag = B1200 | CS8 | CLOCAL | CREAD;\r\nbaud = 1200;\r\n} else {\r\nup->cflag = B4800 | CS8 | CLOCAL | CREAD;\r\nbaud = 4800;\r\n}\r\nup->curregs[R15] |= BRKIE;\r\nbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nsunzilog_convert_to_zs(up, up->cflag, 0, brg);\r\nsunzilog_set_mctrl(&up->port, TIOCM_DTR | TIOCM_RTS);\r\n__sunzilog_startup(up);\r\n}\r\nstatic void sunzilog_register_serio(struct uart_sunzilog_port *up)\r\n{\r\nstruct serio *serio = &up->serio;\r\nserio->port_data = up;\r\nserio->id.type = SERIO_RS232;\r\nif (up->flags & SUNZILOG_FLAG_CONS_KEYB) {\r\nserio->id.proto = SERIO_SUNKBD;\r\nstrlcpy(serio->name, "zskbd", sizeof(serio->name));\r\n} else {\r\nserio->id.proto = SERIO_SUN;\r\nserio->id.extra = 1;\r\nstrlcpy(serio->name, "zsms", sizeof(serio->name));\r\n}\r\nstrlcpy(serio->phys,\r\n((up->flags & SUNZILOG_FLAG_CONS_KEYB) ?\r\n"zs/serio0" : "zs/serio1"),\r\nsizeof(serio->phys));\r\nserio->write = sunzilog_serio_write;\r\nserio->open = sunzilog_serio_open;\r\nserio->close = sunzilog_serio_close;\r\nserio->dev.parent = up->port.dev;\r\nserio_register_port(serio);\r\n}\r\nstatic void sunzilog_init_hw(struct uart_sunzilog_port *up)\r\n{\r\nstruct zilog_channel __iomem *channel;\r\nunsigned long flags;\r\nint baud, brg;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (ZS_IS_CHANNEL_A(up)) {\r\nwrite_zsreg(channel, R9, FHWRES);\r\nZSDELAY_LONG();\r\n(void) read_zsreg(channel, R0);\r\n}\r\nif (up->flags & (SUNZILOG_FLAG_CONS_KEYB |\r\nSUNZILOG_FLAG_CONS_MOUSE)) {\r\nup->curregs[R1] = EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\r\nup->curregs[R4] = PAR_EVEN | X16CLK | SB1;\r\nup->curregs[R3] = RxENAB | Rx8;\r\nup->curregs[R5] = TxENAB | Tx8;\r\nup->curregs[R6] = 0x00;\r\nup->curregs[R7] = 0x7E;\r\nup->curregs[R9] = NV;\r\nup->curregs[R7p] = 0x00;\r\nsunzilog_init_kbdms(up);\r\nif (up->flags & SUNZILOG_FLAG_ISR_HANDLER)\r\nup->curregs[R9] |= MIE;\r\nwrite_zsreg(channel, R9, up->curregs[R9]);\r\n} else {\r\nup->parity_mask = 0xff;\r\nup->curregs[R1] = EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\r\nup->curregs[R4] = PAR_EVEN | X16CLK | SB1;\r\nup->curregs[R3] = RxENAB | Rx8;\r\nup->curregs[R5] = TxENAB | Tx8;\r\nup->curregs[R6] = 0x00;\r\nup->curregs[R7] = 0x7E;\r\nup->curregs[R9] = NV;\r\nup->curregs[R10] = NRZ;\r\nup->curregs[R11] = TCBR | RCBR;\r\nbaud = 9600;\r\nbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nup->curregs[R12] = (brg & 0xff);\r\nup->curregs[R13] = (brg >> 8) & 0xff;\r\nup->curregs[R14] = BRSRC | BRENAB;\r\nup->curregs[R15] = FIFOEN;\r\nup->curregs[R7p] = TxFIFO_LVL | RxFIFO_LVL;\r\nif (__load_zsregs(channel, up->curregs)) {\r\nup->flags |= SUNZILOG_FLAG_ESCC;\r\n}\r\nif (up->flags & SUNZILOG_FLAG_ISR_HANDLER)\r\nup->curregs[R9] |= MIE;\r\nwrite_zsreg(channel, R9, up->curregs[R9]);\r\n}\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n#ifdef CONFIG_SERIO\r\nif (up->flags & (SUNZILOG_FLAG_CONS_KEYB |\r\nSUNZILOG_FLAG_CONS_MOUSE))\r\nsunzilog_register_serio(up);\r\n#endif\r\n}\r\nstatic int zs_probe(struct platform_device *op)\r\n{\r\nstatic int kbm_inst, uart_inst;\r\nint inst;\r\nstruct uart_sunzilog_port *up;\r\nstruct zilog_layout __iomem *rp;\r\nint keyboard_mouse = 0;\r\nint err;\r\nif (of_find_property(op->dev.of_node, "keyboard", NULL))\r\nkeyboard_mouse = 1;\r\nif (keyboard_mouse)\r\ninst = uart_chip_count + kbm_inst;\r\nelse\r\ninst = uart_inst;\r\nsunzilog_chip_regs[inst] = of_ioremap(&op->resource[0], 0,\r\nsizeof(struct zilog_layout),\r\n"zs");\r\nif (!sunzilog_chip_regs[inst])\r\nreturn -ENOMEM;\r\nrp = sunzilog_chip_regs[inst];\r\nif (!zilog_irq)\r\nzilog_irq = op->archdata.irqs[0];\r\nup = &sunzilog_port_table[inst * 2];\r\nup[0].port.mapbase = op->resource[0].start + 0x00;\r\nup[0].port.membase = (void __iomem *) &rp->channelA;\r\nup[0].port.iotype = UPIO_MEM;\r\nup[0].port.irq = op->archdata.irqs[0];\r\nup[0].port.uartclk = ZS_CLOCK;\r\nup[0].port.fifosize = 1;\r\nup[0].port.ops = &sunzilog_pops;\r\nup[0].port.type = PORT_SUNZILOG;\r\nup[0].port.flags = 0;\r\nup[0].port.line = (inst * 2) + 0;\r\nup[0].port.dev = &op->dev;\r\nup[0].flags |= SUNZILOG_FLAG_IS_CHANNEL_A;\r\nif (keyboard_mouse)\r\nup[0].flags |= SUNZILOG_FLAG_CONS_KEYB;\r\nsunzilog_init_hw(&up[0]);\r\nup[1].port.mapbase = op->resource[0].start + 0x04;\r\nup[1].port.membase = (void __iomem *) &rp->channelB;\r\nup[1].port.iotype = UPIO_MEM;\r\nup[1].port.irq = op->archdata.irqs[0];\r\nup[1].port.uartclk = ZS_CLOCK;\r\nup[1].port.fifosize = 1;\r\nup[1].port.ops = &sunzilog_pops;\r\nup[1].port.type = PORT_SUNZILOG;\r\nup[1].port.flags = 0;\r\nup[1].port.line = (inst * 2) + 1;\r\nup[1].port.dev = &op->dev;\r\nup[1].flags |= 0;\r\nif (keyboard_mouse)\r\nup[1].flags |= SUNZILOG_FLAG_CONS_MOUSE;\r\nsunzilog_init_hw(&up[1]);\r\nif (!keyboard_mouse) {\r\nif (sunserial_console_match(SUNZILOG_CONSOLE(), op->dev.of_node,\r\n&sunzilog_reg, up[0].port.line,\r\nfalse))\r\nup->flags |= SUNZILOG_FLAG_IS_CONS;\r\nerr = uart_add_one_port(&sunzilog_reg, &up[0].port);\r\nif (err) {\r\nof_iounmap(&op->resource[0],\r\nrp, sizeof(struct zilog_layout));\r\nreturn err;\r\n}\r\nif (sunserial_console_match(SUNZILOG_CONSOLE(), op->dev.of_node,\r\n&sunzilog_reg, up[1].port.line,\r\nfalse))\r\nup->flags |= SUNZILOG_FLAG_IS_CONS;\r\nerr = uart_add_one_port(&sunzilog_reg, &up[1].port);\r\nif (err) {\r\nuart_remove_one_port(&sunzilog_reg, &up[0].port);\r\nof_iounmap(&op->resource[0],\r\nrp, sizeof(struct zilog_layout));\r\nreturn err;\r\n}\r\nuart_inst++;\r\n} else {\r\nprintk(KERN_INFO "%s: Keyboard at MMIO 0x%llx (irq = %d) "\r\n"is a %s\n",\r\ndev_name(&op->dev),\r\n(unsigned long long) up[0].port.mapbase,\r\nop->archdata.irqs[0], sunzilog_type(&up[0].port));\r\nprintk(KERN_INFO "%s: Mouse at MMIO 0x%llx (irq = %d) "\r\n"is a %s\n",\r\ndev_name(&op->dev),\r\n(unsigned long long) up[1].port.mapbase,\r\nop->archdata.irqs[0], sunzilog_type(&up[1].port));\r\nkbm_inst++;\r\n}\r\nplatform_set_drvdata(op, &up[0]);\r\nreturn 0;\r\n}\r\nstatic void zs_remove_one(struct uart_sunzilog_port *up)\r\n{\r\nif (ZS_IS_KEYB(up) || ZS_IS_MOUSE(up)) {\r\n#ifdef CONFIG_SERIO\r\nserio_unregister_port(&up->serio);\r\n#endif\r\n} else\r\nuart_remove_one_port(&sunzilog_reg, &up->port);\r\n}\r\nstatic int zs_remove(struct platform_device *op)\r\n{\r\nstruct uart_sunzilog_port *up = platform_get_drvdata(op);\r\nstruct zilog_layout __iomem *regs;\r\nzs_remove_one(&up[0]);\r\nzs_remove_one(&up[1]);\r\nregs = sunzilog_chip_regs[up[0].port.line / 2];\r\nof_iounmap(&op->resource[0], regs, sizeof(struct zilog_layout));\r\nreturn 0;\r\n}\r\nstatic int __init sunzilog_init(void)\r\n{\r\nstruct device_node *dp;\r\nint err;\r\nint num_keybms = 0;\r\nint num_sunzilog = 0;\r\nfor_each_node_by_name(dp, "zs") {\r\nnum_sunzilog++;\r\nif (of_find_property(dp, "keyboard", NULL))\r\nnum_keybms++;\r\n}\r\nif (num_sunzilog) {\r\nerr = sunzilog_alloc_tables(num_sunzilog);\r\nif (err)\r\ngoto out;\r\nuart_chip_count = num_sunzilog - num_keybms;\r\nerr = sunserial_register_minors(&sunzilog_reg,\r\nuart_chip_count * 2);\r\nif (err)\r\ngoto out_free_tables;\r\n}\r\nerr = platform_driver_register(&zs_driver);\r\nif (err)\r\ngoto out_unregister_uart;\r\nif (zilog_irq) {\r\nstruct uart_sunzilog_port *up = sunzilog_irq_chain;\r\nerr = request_irq(zilog_irq, sunzilog_interrupt, IRQF_SHARED,\r\n"zs", sunzilog_irq_chain);\r\nif (err)\r\ngoto out_unregister_driver;\r\nwhile (up) {\r\nstruct zilog_channel __iomem *channel;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nup->flags |= SUNZILOG_FLAG_ISR_HANDLER;\r\nup->curregs[R9] |= MIE;\r\nwrite_zsreg(channel, R9, up->curregs[R9]);\r\nup = up->next;\r\n}\r\n}\r\nout:\r\nreturn err;\r\nout_unregister_driver:\r\nplatform_driver_unregister(&zs_driver);\r\nout_unregister_uart:\r\nif (num_sunzilog) {\r\nsunserial_unregister_minors(&sunzilog_reg, num_sunzilog);\r\nsunzilog_reg.cons = NULL;\r\n}\r\nout_free_tables:\r\nsunzilog_free_tables();\r\ngoto out;\r\n}\r\nstatic void __exit sunzilog_exit(void)\r\n{\r\nplatform_driver_unregister(&zs_driver);\r\nif (zilog_irq) {\r\nstruct uart_sunzilog_port *up = sunzilog_irq_chain;\r\nwhile (up) {\r\nstruct zilog_channel __iomem *channel;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nup->flags &= ~SUNZILOG_FLAG_ISR_HANDLER;\r\nup->curregs[R9] &= ~MIE;\r\nwrite_zsreg(channel, R9, up->curregs[R9]);\r\nup = up->next;\r\n}\r\nfree_irq(zilog_irq, sunzilog_irq_chain);\r\nzilog_irq = 0;\r\n}\r\nif (sunzilog_reg.nr) {\r\nsunserial_unregister_minors(&sunzilog_reg, sunzilog_reg.nr);\r\nsunzilog_free_tables();\r\n}\r\n}
