static inline struct scsi_cd *scsi_cd(struct gendisk *disk)\r\n{\r\nreturn container_of(disk->private_data, struct scsi_cd, driver);\r\n}\r\nstatic int sr_runtime_suspend(struct device *dev)\r\n{\r\nstruct scsi_cd *cd = dev_get_drvdata(dev);\r\nif (cd->media_present)\r\nreturn -EBUSY;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)\r\n{\r\nstruct scsi_cd *cd = NULL;\r\nmutex_lock(&sr_ref_mutex);\r\nif (disk->private_data == NULL)\r\ngoto out;\r\ncd = scsi_cd(disk);\r\nkref_get(&cd->kref);\r\nif (scsi_device_get(cd->device))\r\ngoto out_put;\r\nif (!scsi_autopm_get_device(cd->device))\r\ngoto out;\r\nout_put:\r\nkref_put(&cd->kref, sr_kref_release);\r\ncd = NULL;\r\nout:\r\nmutex_unlock(&sr_ref_mutex);\r\nreturn cd;\r\n}\r\nstatic void scsi_cd_put(struct scsi_cd *cd)\r\n{\r\nstruct scsi_device *sdev = cd->device;\r\nmutex_lock(&sr_ref_mutex);\r\nkref_put(&cd->kref, sr_kref_release);\r\nscsi_autopm_put_device(sdev);\r\nscsi_device_put(sdev);\r\nmutex_unlock(&sr_ref_mutex);\r\n}\r\nstatic unsigned int sr_get_events(struct scsi_device *sdev)\r\n{\r\nu8 buf[8];\r\nu8 cmd[] = { GET_EVENT_STATUS_NOTIFICATION,\r\n1,\r\n0, 0,\r\n1 << 4,\r\n0, 0,\r\n0, sizeof(buf),\r\n0,\r\n};\r\nstruct event_header *eh = (void *)buf;\r\nstruct media_event_desc *med = (void *)(buf + 4);\r\nstruct scsi_sense_hdr sshdr;\r\nint result;\r\nresult = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, sizeof(buf),\r\n&sshdr, SR_TIMEOUT, MAX_RETRIES, NULL);\r\nif (scsi_sense_valid(&sshdr) && sshdr.sense_key == UNIT_ATTENTION)\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\nif (result || be16_to_cpu(eh->data_len) < sizeof(*med))\r\nreturn 0;\r\nif (eh->nea || eh->notification_class != 0x4)\r\nreturn 0;\r\nif (med->media_event_code == 1)\r\nreturn DISK_EVENT_EJECT_REQUEST;\r\nelse if (med->media_event_code == 2)\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\nreturn 0;\r\n}\r\nstatic unsigned int sr_check_events(struct cdrom_device_info *cdi,\r\nunsigned int clearing, int slot)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nbool last_present;\r\nstruct scsi_sense_hdr sshdr;\r\nunsigned int events;\r\nint ret;\r\nif (CDSL_CURRENT != slot)\r\nreturn 0;\r\nevents = sr_get_events(cd->device);\r\ncd->get_event_changed |= events & DISK_EVENT_MEDIA_CHANGE;\r\nif (cd->ignore_get_event) {\r\nevents &= ~DISK_EVENT_MEDIA_CHANGE;\r\ngoto do_tur;\r\n}\r\nif (cd->device->changed) {\r\nevents |= DISK_EVENT_MEDIA_CHANGE;\r\ncd->device->changed = 0;\r\ncd->tur_changed = true;\r\n}\r\nif (!(clearing & DISK_EVENT_MEDIA_CHANGE))\r\nreturn events;\r\ndo_tur:\r\nlast_present = cd->media_present;\r\nret = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);\r\ncd->media_present = scsi_status_is_good(ret) ||\r\n(scsi_sense_valid(&sshdr) && sshdr.asc != 0x3a);\r\nif (last_present != cd->media_present)\r\ncd->device->changed = 1;\r\nif (cd->device->changed) {\r\nevents |= DISK_EVENT_MEDIA_CHANGE;\r\ncd->device->changed = 0;\r\ncd->tur_changed = true;\r\n}\r\nif (cd->ignore_get_event)\r\nreturn events;\r\nif (!cd->tur_changed) {\r\nif (cd->get_event_changed) {\r\nif (cd->tur_mismatch++ > 8) {\r\nsdev_printk(KERN_WARNING, cd->device,\r\n"GET_EVENT and TUR disagree continuously, suppress GET_EVENT events\n");\r\ncd->ignore_get_event = true;\r\n}\r\n} else {\r\ncd->tur_mismatch = 0;\r\n}\r\n}\r\ncd->tur_changed = false;\r\ncd->get_event_changed = false;\r\nreturn events;\r\n}\r\nstatic int sr_done(struct scsi_cmnd *SCpnt)\r\n{\r\nint result = SCpnt->result;\r\nint this_count = scsi_bufflen(SCpnt);\r\nint good_bytes = (result == 0 ? this_count : 0);\r\nint block_sectors = 0;\r\nlong error_sector;\r\nstruct scsi_cd *cd = scsi_cd(SCpnt->request->rq_disk);\r\n#ifdef DEBUG\r\nprintk("sr.c done: %x\n", result);\r\n#endif\r\nif (driver_byte(result) != 0 &&\r\n(SCpnt->sense_buffer[0] & 0x7f) == 0x70) {\r\nswitch (SCpnt->sense_buffer[2]) {\r\ncase MEDIUM_ERROR:\r\ncase VOLUME_OVERFLOW:\r\ncase ILLEGAL_REQUEST:\r\nif (!(SCpnt->sense_buffer[0] & 0x90))\r\nbreak;\r\nerror_sector = (SCpnt->sense_buffer[3] << 24) |\r\n(SCpnt->sense_buffer[4] << 16) |\r\n(SCpnt->sense_buffer[5] << 8) |\r\nSCpnt->sense_buffer[6];\r\nif (SCpnt->request->bio != NULL)\r\nblock_sectors =\r\nbio_sectors(SCpnt->request->bio);\r\nif (block_sectors < 4)\r\nblock_sectors = 4;\r\nif (cd->device->sector_size == 2048)\r\nerror_sector <<= 2;\r\nerror_sector &= ~(block_sectors - 1);\r\ngood_bytes = (error_sector -\r\nblk_rq_pos(SCpnt->request)) << 9;\r\nif (good_bytes < 0 || good_bytes >= this_count)\r\ngood_bytes = 0;\r\nif (error_sector < get_capacity(cd->disk) &&\r\ncd->capacity - error_sector < 4 * 75)\r\nset_capacity(cd->disk, error_sector);\r\nbreak;\r\ncase RECOVERED_ERROR:\r\ngood_bytes = this_count;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn good_bytes;\r\n}\r\nstatic int sr_prep_fn(struct request_queue *q, struct request *rq)\r\n{\r\nint block = 0, this_count, s_size;\r\nstruct scsi_cd *cd;\r\nstruct scsi_cmnd *SCpnt;\r\nstruct scsi_device *sdp = q->queuedata;\r\nint ret;\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC) {\r\nret = scsi_setup_blk_pc_cmnd(sdp, rq);\r\ngoto out;\r\n} else if (rq->cmd_type != REQ_TYPE_FS) {\r\nret = BLKPREP_KILL;\r\ngoto out;\r\n}\r\nret = scsi_setup_fs_cmnd(sdp, rq);\r\nif (ret != BLKPREP_OK)\r\ngoto out;\r\nSCpnt = rq->special;\r\ncd = scsi_cd(rq->rq_disk);\r\nret = BLKPREP_KILL;\r\nSCSI_LOG_HLQUEUE(1, printk("Doing sr request, dev = %s, block = %d\n",\r\ncd->disk->disk_name, block));\r\nif (!cd->device || !scsi_device_online(cd->device)) {\r\nSCSI_LOG_HLQUEUE(2, printk("Finishing %u sectors\n",\r\nblk_rq_sectors(rq)));\r\nSCSI_LOG_HLQUEUE(2, printk("Retry with 0x%p\n", SCpnt));\r\ngoto out;\r\n}\r\nif (cd->device->changed) {\r\ngoto out;\r\n}\r\ns_size = cd->device->sector_size;\r\nif (s_size > 2048) {\r\nif (!in_interrupt())\r\nsr_set_blocklength(cd, 2048);\r\nelse\r\nprintk("sr: can't switch blocksize: in interrupt\n");\r\n}\r\nif (s_size != 512 && s_size != 1024 && s_size != 2048) {\r\nscmd_printk(KERN_ERR, SCpnt, "bad sector size %d\n", s_size);\r\ngoto out;\r\n}\r\nif (rq_data_dir(rq) == WRITE) {\r\nif (!cd->device->writeable)\r\ngoto out;\r\nSCpnt->cmnd[0] = WRITE_10;\r\nSCpnt->sc_data_direction = DMA_TO_DEVICE;\r\ncd->cdi.media_written = 1;\r\n} else if (rq_data_dir(rq) == READ) {\r\nSCpnt->cmnd[0] = READ_10;\r\nSCpnt->sc_data_direction = DMA_FROM_DEVICE;\r\n} else {\r\nblk_dump_rq_flags(rq, "Unknown sr command");\r\ngoto out;\r\n}\r\n{\r\nstruct scatterlist *sg;\r\nint i, size = 0, sg_count = scsi_sg_count(SCpnt);\r\nscsi_for_each_sg(SCpnt, sg, sg_count, i)\r\nsize += sg->length;\r\nif (size != scsi_bufflen(SCpnt)) {\r\nscmd_printk(KERN_ERR, SCpnt,\r\n"mismatch count %d, bytes %d\n",\r\nsize, scsi_bufflen(SCpnt));\r\nif (scsi_bufflen(SCpnt) > size)\r\nSCpnt->sdb.length = size;\r\n}\r\n}\r\nif (((unsigned int)blk_rq_pos(rq) % (s_size >> 9)) ||\r\n(scsi_bufflen(SCpnt) % s_size)) {\r\nscmd_printk(KERN_NOTICE, SCpnt, "unaligned transfer\n");\r\ngoto out;\r\n}\r\nthis_count = (scsi_bufflen(SCpnt) >> 9) / (s_size >> 9);\r\nSCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%u 512 byte blocks.\n",\r\ncd->cdi.name,\r\n(rq_data_dir(rq) == WRITE) ?\r\n"writing" : "reading",\r\nthis_count, blk_rq_sectors(rq)));\r\nSCpnt->cmnd[1] = 0;\r\nblock = (unsigned int)blk_rq_pos(rq) / (s_size >> 9);\r\nif (this_count > 0xffff) {\r\nthis_count = 0xffff;\r\nSCpnt->sdb.length = this_count * s_size;\r\n}\r\nSCpnt->cmnd[2] = (unsigned char) (block >> 24) & 0xff;\r\nSCpnt->cmnd[3] = (unsigned char) (block >> 16) & 0xff;\r\nSCpnt->cmnd[4] = (unsigned char) (block >> 8) & 0xff;\r\nSCpnt->cmnd[5] = (unsigned char) block & 0xff;\r\nSCpnt->cmnd[6] = SCpnt->cmnd[9] = 0;\r\nSCpnt->cmnd[7] = (unsigned char) (this_count >> 8) & 0xff;\r\nSCpnt->cmnd[8] = (unsigned char) this_count & 0xff;\r\nSCpnt->transfersize = cd->device->sector_size;\r\nSCpnt->underflow = this_count << 9;\r\nSCpnt->allowed = MAX_RETRIES;\r\nret = BLKPREP_OK;\r\nout:\r\nreturn scsi_prep_return(q, rq, ret);\r\n}\r\nstatic int sr_block_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct scsi_cd *cd;\r\nint ret = -ENXIO;\r\nmutex_lock(&sr_mutex);\r\ncd = scsi_cd_get(bdev->bd_disk);\r\nif (cd) {\r\nret = cdrom_open(&cd->cdi, bdev, mode);\r\nif (ret)\r\nscsi_cd_put(cd);\r\n}\r\nmutex_unlock(&sr_mutex);\r\nreturn ret;\r\n}\r\nstatic void sr_block_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct scsi_cd *cd = scsi_cd(disk);\r\nmutex_lock(&sr_mutex);\r\ncdrom_release(&cd->cdi, mode);\r\nscsi_cd_put(cd);\r\nmutex_unlock(&sr_mutex);\r\n}\r\nstatic int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,\r\nunsigned long arg)\r\n{\r\nstruct scsi_cd *cd = scsi_cd(bdev->bd_disk);\r\nstruct scsi_device *sdev = cd->device;\r\nvoid __user *argp = (void __user *)arg;\r\nint ret;\r\nscsi_autopm_get_device(cd->device);\r\nmutex_lock(&sr_mutex);\r\nswitch (cmd) {\r\ncase SCSI_IOCTL_GET_IDLUN:\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\nret = scsi_ioctl(sdev, cmd, argp);\r\ngoto out;\r\n}\r\nret = cdrom_ioctl(&cd->cdi, bdev, mode, cmd, arg);\r\nif (ret != -ENOSYS)\r\ngoto out;\r\nret = scsi_nonblockable_ioctl(sdev, cmd, argp,\r\n(mode & FMODE_NDELAY) != 0);\r\nif (ret != -ENODEV)\r\ngoto out;\r\nret = scsi_ioctl(sdev, cmd, argp);\r\nout:\r\nmutex_unlock(&sr_mutex);\r\nscsi_autopm_put_device(cd->device);\r\nreturn ret;\r\n}\r\nstatic unsigned int sr_block_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct scsi_cd *cd = scsi_cd(disk);\r\nunsigned int ret;\r\nif (atomic_read(&cd->device->disk_events_disable_depth) == 0) {\r\nscsi_autopm_get_device(cd->device);\r\nret = cdrom_check_events(&cd->cdi, clearing);\r\nscsi_autopm_put_device(cd->device);\r\n} else {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sr_block_revalidate_disk(struct gendisk *disk)\r\n{\r\nstruct scsi_cd *cd = scsi_cd(disk);\r\nstruct scsi_sense_hdr sshdr;\r\nscsi_autopm_get_device(cd->device);\r\nif (scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))\r\ngoto out;\r\nsr_cd_check(&cd->cdi);\r\nget_sectorsize(cd);\r\nout:\r\nscsi_autopm_put_device(cd->device);\r\nreturn 0;\r\n}\r\nstatic int sr_open(struct cdrom_device_info *cdi, int purpose)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nstruct scsi_device *sdev = cd->device;\r\nint retval;\r\nretval = -ENXIO;\r\nif (!scsi_block_when_processing_errors(sdev))\r\ngoto error_out;\r\nreturn 0;\r\nerror_out:\r\nreturn retval;\r\n}\r\nstatic void sr_release(struct cdrom_device_info *cdi)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nif (cd->device->sector_size > 2048)\r\nsr_set_blocklength(cd, 2048);\r\n}\r\nstatic int sr_probe(struct device *dev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct gendisk *disk;\r\nstruct scsi_cd *cd;\r\nint minor, error;\r\nerror = -ENODEV;\r\nif (sdev->type != TYPE_ROM && sdev->type != TYPE_WORM)\r\ngoto fail;\r\nerror = -ENOMEM;\r\ncd = kzalloc(sizeof(*cd), GFP_KERNEL);\r\nif (!cd)\r\ngoto fail;\r\nkref_init(&cd->kref);\r\ndisk = alloc_disk(1);\r\nif (!disk)\r\ngoto fail_free;\r\nspin_lock(&sr_index_lock);\r\nminor = find_first_zero_bit(sr_index_bits, SR_DISKS);\r\nif (minor == SR_DISKS) {\r\nspin_unlock(&sr_index_lock);\r\nerror = -EBUSY;\r\ngoto fail_put;\r\n}\r\n__set_bit(minor, sr_index_bits);\r\nspin_unlock(&sr_index_lock);\r\ndisk->major = SCSI_CDROM_MAJOR;\r\ndisk->first_minor = minor;\r\nsprintf(disk->disk_name, "sr%d", minor);\r\ndisk->fops = &sr_bdops;\r\ndisk->flags = GENHD_FL_CD | GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\r\ndisk->events = DISK_EVENT_MEDIA_CHANGE | DISK_EVENT_EJECT_REQUEST;\r\nblk_queue_rq_timeout(sdev->request_queue, SR_TIMEOUT);\r\ncd->device = sdev;\r\ncd->disk = disk;\r\ncd->driver = &sr_template;\r\ncd->disk = disk;\r\ncd->capacity = 0x1fffff;\r\ncd->device->changed = 1;\r\ncd->media_present = 1;\r\ncd->use = 1;\r\ncd->readcd_known = 0;\r\ncd->readcd_cdda = 0;\r\ncd->cdi.ops = &sr_dops;\r\ncd->cdi.handle = cd;\r\ncd->cdi.mask = 0;\r\ncd->cdi.capacity = 1;\r\nsprintf(cd->cdi.name, "sr%d", minor);\r\nsdev->sector_size = 2048;\r\nget_capabilities(cd);\r\nblk_queue_prep_rq(sdev->request_queue, sr_prep_fn);\r\nsr_vendor_init(cd);\r\ndisk->driverfs_dev = &sdev->sdev_gendev;\r\nset_capacity(disk, cd->capacity);\r\ndisk->private_data = &cd->driver;\r\ndisk->queue = sdev->request_queue;\r\ncd->cdi.disk = disk;\r\nif (register_cdrom(&cd->cdi))\r\ngoto fail_put;\r\ndev_set_drvdata(dev, cd);\r\ndisk->flags |= GENHD_FL_REMOVABLE;\r\nadd_disk(disk);\r\nsdev_printk(KERN_DEBUG, sdev,\r\n"Attached scsi CD-ROM %s\n", cd->cdi.name);\r\nscsi_autopm_put_device(cd->device);\r\nreturn 0;\r\nfail_put:\r\nput_disk(disk);\r\nfail_free:\r\nkfree(cd);\r\nfail:\r\nreturn error;\r\n}\r\nstatic void get_sectorsize(struct scsi_cd *cd)\r\n{\r\nunsigned char cmd[10];\r\nunsigned char buffer[8];\r\nint the_result, retries = 3;\r\nint sector_size;\r\nstruct request_queue *queue;\r\ndo {\r\ncmd[0] = READ_CAPACITY;\r\nmemset((void *) &cmd[1], 0, 9);\r\nmemset(buffer, 0, sizeof(buffer));\r\nthe_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,\r\nbuffer, sizeof(buffer), NULL,\r\nSR_TIMEOUT, MAX_RETRIES, NULL);\r\nretries--;\r\n} while (the_result && retries);\r\nif (the_result) {\r\ncd->capacity = 0x1fffff;\r\nsector_size = 2048;\r\n} else {\r\nlong last_written;\r\ncd->capacity = 1 + ((buffer[0] << 24) | (buffer[1] << 16) |\r\n(buffer[2] << 8) | buffer[3]);\r\nif (!cdrom_get_last_written(&cd->cdi, &last_written))\r\ncd->capacity = max_t(long, cd->capacity, last_written);\r\nsector_size = (buffer[4] << 24) |\r\n(buffer[5] << 16) | (buffer[6] << 8) | buffer[7];\r\nswitch (sector_size) {\r\ncase 0:\r\ncase 2340:\r\ncase 2352:\r\nsector_size = 2048;\r\ncase 2048:\r\ncd->capacity *= 4;\r\ncase 512:\r\nbreak;\r\ndefault:\r\nprintk("%s: unsupported sector size %d.\n",\r\ncd->cdi.name, sector_size);\r\ncd->capacity = 0;\r\n}\r\ncd->device->sector_size = sector_size;\r\nset_capacity(cd->disk, cd->capacity);\r\n}\r\nqueue = cd->device->request_queue;\r\nblk_queue_logical_block_size(queue, sector_size);\r\nreturn;\r\n}\r\nstatic void get_capabilities(struct scsi_cd *cd)\r\n{\r\nunsigned char *buffer;\r\nstruct scsi_mode_data data;\r\nstruct scsi_sense_hdr sshdr;\r\nint rc, n;\r\nstatic const char *loadmech[] =\r\n{\r\n"caddy",\r\n"tray",\r\n"pop-up",\r\n"",\r\n"changer",\r\n"cartridge changer",\r\n"",\r\n""\r\n};\r\nbuffer = kmalloc(512, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\nprintk(KERN_ERR "sr: out of memory.\n");\r\nreturn;\r\n}\r\nscsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);\r\nrc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,\r\nSR_TIMEOUT, 3, &data, NULL);\r\nif (!scsi_status_is_good(rc)) {\r\ncd->cdi.speed = 1;\r\ncd->cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |\r\nCDC_DVD | CDC_DVD_RAM |\r\nCDC_SELECT_DISC | CDC_SELECT_SPEED |\r\nCDC_MRW | CDC_MRW_W | CDC_RAM);\r\nkfree(buffer);\r\nprintk("%s: scsi-1 drive\n", cd->cdi.name);\r\nreturn;\r\n}\r\nn = data.header_length + data.block_descriptor_length;\r\ncd->cdi.speed = ((buffer[n + 8] << 8) + buffer[n + 9]) / 176;\r\ncd->readcd_known = 1;\r\ncd->readcd_cdda = buffer[n + 5] & 0x01;\r\nprintk("%s: scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s\n", cd->cdi.name,\r\n((buffer[n + 14] << 8) + buffer[n + 15]) / 176,\r\ncd->cdi.speed,\r\nbuffer[n + 3] & 0x01 ? "writer " : "",\r\nbuffer[n + 3] & 0x20 ? "dvd-ram " : "",\r\nbuffer[n + 2] & 0x02 ? "cd/rw " : "",\r\nbuffer[n + 4] & 0x20 ? "xa/form2 " : "",\r\nbuffer[n + 5] & 0x01 ? "cdda " : "",\r\nloadmech[buffer[n + 6] >> 5]);\r\nif ((buffer[n + 6] >> 5) == 0)\r\ncd->cdi.mask |= CDC_CLOSE_TRAY;\r\nif ((buffer[n + 2] & 0x8) == 0)\r\ncd->cdi.mask |= CDC_DVD;\r\nif ((buffer[n + 3] & 0x20) == 0)\r\ncd->cdi.mask |= CDC_DVD_RAM;\r\nif ((buffer[n + 3] & 0x10) == 0)\r\ncd->cdi.mask |= CDC_DVD_R;\r\nif ((buffer[n + 3] & 0x2) == 0)\r\ncd->cdi.mask |= CDC_CD_RW;\r\nif ((buffer[n + 3] & 0x1) == 0)\r\ncd->cdi.mask |= CDC_CD_R;\r\nif ((buffer[n + 6] & 0x8) == 0)\r\ncd->cdi.mask |= CDC_OPEN_TRAY;\r\nif ((buffer[n + 6] >> 5) == mechtype_individual_changer ||\r\n(buffer[n + 6] >> 5) == mechtype_cartridge_changer)\r\ncd->cdi.capacity =\r\ncdrom_number_of_slots(&cd->cdi);\r\nif (cd->cdi.capacity <= 1)\r\ncd->cdi.mask |= CDC_SELECT_DISC;\r\nif ((cd->cdi.mask & (CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) !=\r\n(CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) {\r\ncd->device->writeable = 1;\r\n}\r\nkfree(buffer);\r\n}\r\nstatic int sr_packet(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc)\r\n{\r\nstruct scsi_cd *cd = cdi->handle;\r\nstruct scsi_device *sdev = cd->device;\r\nif (cgc->cmd[0] == GPCMD_READ_DISC_INFO && sdev->no_read_disc_info)\r\nreturn -EDRIVE_CANT_DO_THIS;\r\nif (cgc->timeout <= 0)\r\ncgc->timeout = IOCTL_TIMEOUT;\r\nsr_do_ioctl(cd, cgc);\r\nreturn cgc->stat;\r\n}\r\nstatic void sr_kref_release(struct kref *kref)\r\n{\r\nstruct scsi_cd *cd = container_of(kref, struct scsi_cd, kref);\r\nstruct gendisk *disk = cd->disk;\r\nspin_lock(&sr_index_lock);\r\nclear_bit(MINOR(disk_devt(disk)), sr_index_bits);\r\nspin_unlock(&sr_index_lock);\r\nunregister_cdrom(&cd->cdi);\r\ndisk->private_data = NULL;\r\nput_disk(disk);\r\nkfree(cd);\r\n}\r\nstatic int sr_remove(struct device *dev)\r\n{\r\nstruct scsi_cd *cd = dev_get_drvdata(dev);\r\nscsi_autopm_get_device(cd->device);\r\nblk_queue_prep_rq(cd->device->request_queue, scsi_prep_fn);\r\ndel_gendisk(cd->disk);\r\nmutex_lock(&sr_ref_mutex);\r\nkref_put(&cd->kref, sr_kref_release);\r\nmutex_unlock(&sr_ref_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init init_sr(void)\r\n{\r\nint rc;\r\nrc = register_blkdev(SCSI_CDROM_MAJOR, "sr");\r\nif (rc)\r\nreturn rc;\r\nrc = scsi_register_driver(&sr_template.gendrv);\r\nif (rc)\r\nunregister_blkdev(SCSI_CDROM_MAJOR, "sr");\r\nreturn rc;\r\n}\r\nstatic void __exit exit_sr(void)\r\n{\r\nscsi_unregister_driver(&sr_template.gendrv);\r\nunregister_blkdev(SCSI_CDROM_MAJOR, "sr");\r\n}
