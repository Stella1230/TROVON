static unsigned long\r\nxp_pa_uv(void *addr)\r\n{\r\nreturn uv_gpa(addr);\r\n}\r\nstatic unsigned long\r\nxp_socket_pa_uv(unsigned long gpa)\r\n{\r\nreturn uv_gpa_to_soc_phys_ram(gpa);\r\n}\r\nstatic enum xp_retval\r\nxp_remote_mmr_read(unsigned long dst_gpa, const unsigned long src_gpa,\r\nsize_t len)\r\n{\r\nint ret;\r\nunsigned long *dst_va = __va(uv_gpa_to_soc_phys_ram(dst_gpa));\r\nBUG_ON(!uv_gpa_in_mmr_space(src_gpa));\r\nBUG_ON(len != 8);\r\nret = gru_read_gpa(dst_va, src_gpa);\r\nif (ret == 0)\r\nreturn xpSuccess;\r\ndev_err(xp, "gru_read_gpa() failed, dst_gpa=0x%016lx src_gpa=0x%016lx "\r\n"len=%ld\n", dst_gpa, src_gpa, len);\r\nreturn xpGruCopyError;\r\n}\r\nstatic enum xp_retval\r\nxp_remote_memcpy_uv(unsigned long dst_gpa, const unsigned long src_gpa,\r\nsize_t len)\r\n{\r\nint ret;\r\nif (uv_gpa_in_mmr_space(src_gpa))\r\nreturn xp_remote_mmr_read(dst_gpa, src_gpa, len);\r\nret = gru_copy_gpa(dst_gpa, src_gpa, len);\r\nif (ret == 0)\r\nreturn xpSuccess;\r\ndev_err(xp, "gru_copy_gpa() failed, dst_gpa=0x%016lx src_gpa=0x%016lx "\r\n"len=%ld\n", dst_gpa, src_gpa, len);\r\nreturn xpGruCopyError;\r\n}\r\nstatic int\r\nxp_cpu_to_nasid_uv(int cpuid)\r\n{\r\nreturn UV_PNODE_TO_NASID(uv_cpu_to_pnode(cpuid));\r\n}\r\nstatic enum xp_retval\r\nxp_expand_memprotect_uv(unsigned long phys_addr, unsigned long size)\r\n{\r\nint ret;\r\n#if defined CONFIG_X86_64\r\nret = uv_bios_change_memprotect(phys_addr, size, UV_MEMPROT_ALLOW_RW);\r\nif (ret != BIOS_STATUS_SUCCESS) {\r\ndev_err(xp, "uv_bios_change_memprotect(,, "\r\n"UV_MEMPROT_ALLOW_RW) failed, ret=%d\n", ret);\r\nreturn xpBiosError;\r\n}\r\n#elif defined CONFIG_IA64_GENERIC || defined CONFIG_IA64_SGI_UV\r\nu64 nasid_array;\r\nret = sn_change_memprotect(phys_addr, size, SN_MEMPROT_ACCESS_CLASS_1,\r\n&nasid_array);\r\nif (ret != 0) {\r\ndev_err(xp, "sn_change_memprotect(,, "\r\n"SN_MEMPROT_ACCESS_CLASS_1,) failed ret=%d\n", ret);\r\nreturn xpSalError;\r\n}\r\n#else\r\n#error not a supported configuration\r\n#endif\r\nreturn xpSuccess;\r\n}\r\nstatic enum xp_retval\r\nxp_restrict_memprotect_uv(unsigned long phys_addr, unsigned long size)\r\n{\r\nint ret;\r\n#if defined CONFIG_X86_64\r\nret = uv_bios_change_memprotect(phys_addr, size,\r\nUV_MEMPROT_RESTRICT_ACCESS);\r\nif (ret != BIOS_STATUS_SUCCESS) {\r\ndev_err(xp, "uv_bios_change_memprotect(,, "\r\n"UV_MEMPROT_RESTRICT_ACCESS) failed, ret=%d\n", ret);\r\nreturn xpBiosError;\r\n}\r\n#elif defined CONFIG_IA64_GENERIC || defined CONFIG_IA64_SGI_UV\r\nu64 nasid_array;\r\nret = sn_change_memprotect(phys_addr, size, SN_MEMPROT_ACCESS_CLASS_0,\r\n&nasid_array);\r\nif (ret != 0) {\r\ndev_err(xp, "sn_change_memprotect(,, "\r\n"SN_MEMPROT_ACCESS_CLASS_0,) failed ret=%d\n", ret);\r\nreturn xpSalError;\r\n}\r\n#else\r\n#error not a supported configuration\r\n#endif\r\nreturn xpSuccess;\r\n}\r\nenum xp_retval\r\nxp_init_uv(void)\r\n{\r\nBUG_ON(!is_uv());\r\nxp_max_npartitions = XP_MAX_NPARTITIONS_UV;\r\nxp_partition_id = sn_partition_id;\r\nxp_region_size = sn_region_size;\r\nxp_pa = xp_pa_uv;\r\nxp_socket_pa = xp_socket_pa_uv;\r\nxp_remote_memcpy = xp_remote_memcpy_uv;\r\nxp_cpu_to_nasid = xp_cpu_to_nasid_uv;\r\nxp_expand_memprotect = xp_expand_memprotect_uv;\r\nxp_restrict_memprotect = xp_restrict_memprotect_uv;\r\nreturn xpSuccess;\r\n}\r\nvoid\r\nxp_exit_uv(void)\r\n{\r\nBUG_ON(!is_uv());\r\n}
