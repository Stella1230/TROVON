int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper *fb_helper)\r\n{\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_connector *connector;\r\nint i;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct drm_fb_helper_connector *fb_helper_connector;\r\nfb_helper_connector = kzalloc(sizeof(struct drm_fb_helper_connector), GFP_KERNEL);\r\nif (!fb_helper_connector)\r\ngoto fail;\r\nfb_helper_connector->connector = connector;\r\nfb_helper->connector_info[fb_helper->connector_count++] = fb_helper_connector;\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nkfree(fb_helper->connector_info[i]);\r\nfb_helper->connector_info[i] = NULL;\r\n}\r\nfb_helper->connector_count = 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic int drm_fb_helper_parse_command_line(struct drm_fb_helper *fb_helper)\r\n{\r\nstruct drm_fb_helper_connector *fb_helper_conn;\r\nint i;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nstruct drm_cmdline_mode *mode;\r\nstruct drm_connector *connector;\r\nchar *option = NULL;\r\nfb_helper_conn = fb_helper->connector_info[i];\r\nconnector = fb_helper_conn->connector;\r\nmode = &fb_helper_conn->cmdline_mode;\r\nif (fb_get_options(drm_get_connector_name(connector), &option))\r\ncontinue;\r\nif (drm_mode_parse_command_line_for_connector(option,\r\nconnector,\r\nmode)) {\r\nif (mode->force) {\r\nconst char *s;\r\nswitch (mode->force) {\r\ncase DRM_FORCE_OFF:\r\ns = "OFF";\r\nbreak;\r\ncase DRM_FORCE_ON_DIGITAL:\r\ns = "ON - dig";\r\nbreak;\r\ndefault:\r\ncase DRM_FORCE_ON:\r\ns = "ON";\r\nbreak;\r\n}\r\nDRM_INFO("forcing %s connector %s\n",\r\ndrm_get_connector_name(connector), s);\r\nconnector->force = mode->force;\r\n}\r\nDRM_DEBUG_KMS("cmdline mode for connector %s %dx%d@%dHz%s%s%s\n",\r\ndrm_get_connector_name(connector),\r\nmode->xres, mode->yres,\r\nmode->refresh_specified ? mode->refresh : 60,\r\nmode->rb ? " reduced blanking" : "",\r\nmode->margins ? " with margins" : "",\r\nmode->interlace ? " interlaced" : "");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void drm_fb_helper_save_lut_atomic(struct drm_crtc *crtc, struct drm_fb_helper *helper)\r\n{\r\nuint16_t *r_base, *g_base, *b_base;\r\nint i;\r\nif (helper->funcs->gamma_get == NULL)\r\nreturn;\r\nr_base = crtc->gamma_store;\r\ng_base = r_base + crtc->gamma_size;\r\nb_base = g_base + crtc->gamma_size;\r\nfor (i = 0; i < crtc->gamma_size; i++)\r\nhelper->funcs->gamma_get(crtc, &r_base[i], &g_base[i], &b_base[i], i);\r\n}\r\nstatic void drm_fb_helper_restore_lut_atomic(struct drm_crtc *crtc)\r\n{\r\nuint16_t *r_base, *g_base, *b_base;\r\nif (crtc->funcs->gamma_set == NULL)\r\nreturn;\r\nr_base = crtc->gamma_store;\r\ng_base = r_base + crtc->gamma_size;\r\nb_base = g_base + crtc->gamma_size;\r\ncrtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size);\r\n}\r\nint drm_fb_helper_debug_enter(struct fb_info *info)\r\n{\r\nstruct drm_fb_helper *helper = info->par;\r\nstruct drm_crtc_helper_funcs *funcs;\r\nint i;\r\nif (list_empty(&kernel_fb_helper_list))\r\nreturn false;\r\nlist_for_each_entry(helper, &kernel_fb_helper_list, kernel_fb_list) {\r\nfor (i = 0; i < helper->crtc_count; i++) {\r\nstruct drm_mode_set *mode_set =\r\n&helper->crtc_info[i].mode_set;\r\nif (!mode_set->crtc->enabled)\r\ncontinue;\r\nfuncs = mode_set->crtc->helper_private;\r\ndrm_fb_helper_save_lut_atomic(mode_set->crtc, helper);\r\nfuncs->mode_set_base_atomic(mode_set->crtc,\r\nmode_set->fb,\r\nmode_set->x,\r\nmode_set->y,\r\nENTER_ATOMIC_MODE_SET);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *drm_mode_config_fb(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_crtc *c;\r\nlist_for_each_entry(c, &dev->mode_config.crtc_list, head) {\r\nif (crtc->base.id == c->base.id)\r\nreturn c->fb;\r\n}\r\nreturn NULL;\r\n}\r\nint drm_fb_helper_debug_leave(struct fb_info *info)\r\n{\r\nstruct drm_fb_helper *helper = info->par;\r\nstruct drm_crtc *crtc;\r\nstruct drm_crtc_helper_funcs *funcs;\r\nstruct drm_framebuffer *fb;\r\nint i;\r\nfor (i = 0; i < helper->crtc_count; i++) {\r\nstruct drm_mode_set *mode_set = &helper->crtc_info[i].mode_set;\r\ncrtc = mode_set->crtc;\r\nfuncs = crtc->helper_private;\r\nfb = drm_mode_config_fb(crtc);\r\nif (!crtc->enabled)\r\ncontinue;\r\nif (!fb) {\r\nDRM_ERROR("no fb to restore??\n");\r\ncontinue;\r\n}\r\ndrm_fb_helper_restore_lut_atomic(mode_set->crtc);\r\nfuncs->mode_set_base_atomic(mode_set->crtc, fb, crtc->x,\r\ncrtc->y, LEAVE_ATOMIC_MODE_SET);\r\n}\r\nreturn 0;\r\n}\r\nbool drm_fb_helper_restore_fbdev_mode(struct drm_fb_helper *fb_helper)\r\n{\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_plane *plane;\r\nbool error = false;\r\nint i;\r\ndrm_warn_on_modeset_not_all_locked(dev);\r\nlist_for_each_entry(plane, &dev->mode_config.plane_list, head)\r\ndrm_plane_force_disable(plane);\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\nstruct drm_mode_set *mode_set = &fb_helper->crtc_info[i].mode_set;\r\nstruct drm_crtc *crtc = mode_set->crtc;\r\nint ret;\r\nif (crtc->funcs->cursor_set) {\r\nret = crtc->funcs->cursor_set(crtc, NULL, 0, 0, 0);\r\nif (ret)\r\nerror = true;\r\n}\r\nret = drm_mode_set_config_internal(mode_set);\r\nif (ret)\r\nerror = true;\r\n}\r\nreturn error;\r\n}\r\nstatic bool drm_fb_helper_force_kernel_mode(void)\r\n{\r\nbool ret, error = false;\r\nstruct drm_fb_helper *helper;\r\nif (list_empty(&kernel_fb_helper_list))\r\nreturn false;\r\nlist_for_each_entry(helper, &kernel_fb_helper_list, kernel_fb_list) {\r\nif (helper->dev->switch_power_state == DRM_SWITCH_POWER_OFF)\r\ncontinue;\r\nret = drm_fb_helper_restore_fbdev_mode(helper);\r\nif (ret)\r\nerror = true;\r\n}\r\nreturn error;\r\n}\r\nstatic int drm_fb_helper_panic(struct notifier_block *n, unsigned long ununsed,\r\nvoid *panic_str)\r\n{\r\nif (panic_timeout < 0)\r\nreturn 0;\r\npr_err("panic occurred, switching back to text console\n");\r\nreturn drm_fb_helper_force_kernel_mode();\r\n}\r\nstatic bool drm_fb_helper_is_bound(struct drm_fb_helper *fb_helper)\r\n{\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_crtc *crtc;\r\nint bound = 0, crtcs_bound = 0;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (crtc->fb)\r\ncrtcs_bound++;\r\nif (crtc->fb == fb_helper->fb)\r\nbound++;\r\n}\r\nif (bound < crtcs_bound)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void drm_fb_helper_restore_work_fn(struct work_struct *ignored)\r\n{\r\nbool ret;\r\nret = drm_fb_helper_force_kernel_mode();\r\nif (ret == true)\r\nDRM_ERROR("Failed to restore crtc configuration\n");\r\n}\r\nstatic void drm_fb_helper_sysrq(int dummy1)\r\n{\r\nschedule_work(&drm_fb_helper_restore_work);\r\n}\r\nstatic void drm_fb_helper_dpms(struct fb_info *info, int dpms_mode)\r\n{\r\nstruct drm_fb_helper *fb_helper = info->par;\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_crtc *crtc;\r\nstruct drm_connector *connector;\r\nint i, j;\r\nif (oops_in_progress)\r\nreturn;\r\ndrm_modeset_lock_all(dev);\r\nif (!drm_fb_helper_is_bound(fb_helper)) {\r\ndrm_modeset_unlock_all(dev);\r\nreturn;\r\n}\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\ncrtc = fb_helper->crtc_info[i].mode_set.crtc;\r\nif (!crtc->enabled)\r\ncontinue;\r\nfor (j = 0; j < fb_helper->connector_count; j++) {\r\nconnector = fb_helper->connector_info[j]->connector;\r\nconnector->funcs->dpms(connector, dpms_mode);\r\ndrm_object_property_set_value(&connector->base,\r\ndev->mode_config.dpms_property, dpms_mode);\r\n}\r\n}\r\ndrm_modeset_unlock_all(dev);\r\n}\r\nint drm_fb_helper_blank(int blank, struct fb_info *info)\r\n{\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ndrm_fb_helper_dpms(info, DRM_MODE_DPMS_ON);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ndrm_fb_helper_dpms(info, DRM_MODE_DPMS_STANDBY);\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndrm_fb_helper_dpms(info, DRM_MODE_DPMS_STANDBY);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ndrm_fb_helper_dpms(info, DRM_MODE_DPMS_SUSPEND);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ndrm_fb_helper_dpms(info, DRM_MODE_DPMS_OFF);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void drm_fb_helper_crtc_free(struct drm_fb_helper *helper)\r\n{\r\nint i;\r\nfor (i = 0; i < helper->connector_count; i++)\r\nkfree(helper->connector_info[i]);\r\nkfree(helper->connector_info);\r\nfor (i = 0; i < helper->crtc_count; i++) {\r\nkfree(helper->crtc_info[i].mode_set.connectors);\r\nif (helper->crtc_info[i].mode_set.mode)\r\ndrm_mode_destroy(helper->dev, helper->crtc_info[i].mode_set.mode);\r\n}\r\nkfree(helper->crtc_info);\r\n}\r\nint drm_fb_helper_init(struct drm_device *dev,\r\nstruct drm_fb_helper *fb_helper,\r\nint crtc_count, int max_conn_count)\r\n{\r\nstruct drm_crtc *crtc;\r\nint i;\r\nfb_helper->dev = dev;\r\nINIT_LIST_HEAD(&fb_helper->kernel_fb_list);\r\nfb_helper->crtc_info = kcalloc(crtc_count, sizeof(struct drm_fb_helper_crtc), GFP_KERNEL);\r\nif (!fb_helper->crtc_info)\r\nreturn -ENOMEM;\r\nfb_helper->crtc_count = crtc_count;\r\nfb_helper->connector_info = kcalloc(dev->mode_config.num_connector, sizeof(struct drm_fb_helper_connector *), GFP_KERNEL);\r\nif (!fb_helper->connector_info) {\r\nkfree(fb_helper->crtc_info);\r\nreturn -ENOMEM;\r\n}\r\nfb_helper->connector_count = 0;\r\nfor (i = 0; i < crtc_count; i++) {\r\nfb_helper->crtc_info[i].mode_set.connectors =\r\nkcalloc(max_conn_count,\r\nsizeof(struct drm_connector *),\r\nGFP_KERNEL);\r\nif (!fb_helper->crtc_info[i].mode_set.connectors)\r\ngoto out_free;\r\nfb_helper->crtc_info[i].mode_set.num_connectors = 0;\r\n}\r\ni = 0;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nfb_helper->crtc_info[i].mode_set.crtc = crtc;\r\ni++;\r\n}\r\nreturn 0;\r\nout_free:\r\ndrm_fb_helper_crtc_free(fb_helper);\r\nreturn -ENOMEM;\r\n}\r\nvoid drm_fb_helper_fini(struct drm_fb_helper *fb_helper)\r\n{\r\nif (!list_empty(&fb_helper->kernel_fb_list)) {\r\nlist_del(&fb_helper->kernel_fb_list);\r\nif (list_empty(&kernel_fb_helper_list)) {\r\npr_info("drm: unregistered panic notifier\n");\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&paniced);\r\nunregister_sysrq_key('v', &sysrq_drm_fb_helper_restore_op);\r\n}\r\n}\r\ndrm_fb_helper_crtc_free(fb_helper);\r\n}\r\nstatic int setcolreg(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, u16 regno, struct fb_info *info)\r\n{\r\nstruct drm_fb_helper *fb_helper = info->par;\r\nstruct drm_framebuffer *fb = fb_helper->fb;\r\nint pindex;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 *palette;\r\nu32 value;\r\nif (regno > 16)\r\nreturn -EINVAL;\r\npalette = (u32 *)info->pseudo_palette;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\nvalue = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nif (info->var.transp.length > 0) {\r\nu32 mask = (1 << info->var.transp.length) - 1;\r\nmask <<= info->var.transp.offset;\r\nvalue |= mask;\r\n}\r\npalette[regno] = value;\r\nreturn 0;\r\n}\r\nif (WARN_ON(!fb_helper->funcs->gamma_set ||\r\n!fb_helper->funcs->gamma_get))\r\nreturn -EINVAL;\r\npindex = regno;\r\nif (fb->bits_per_pixel == 16) {\r\npindex = regno << 3;\r\nif (fb->depth == 16 && regno > 63)\r\nreturn -EINVAL;\r\nif (fb->depth == 15 && regno > 31)\r\nreturn -EINVAL;\r\nif (fb->depth == 16) {\r\nu16 r, g, b;\r\nint i;\r\nif (regno < 32) {\r\nfor (i = 0; i < 8; i++)\r\nfb_helper->funcs->gamma_set(crtc, red,\r\ngreen, blue, pindex + i);\r\n}\r\nfb_helper->funcs->gamma_get(crtc, &r,\r\n&g, &b,\r\npindex >> 1);\r\nfor (i = 0; i < 4; i++)\r\nfb_helper->funcs->gamma_set(crtc, r,\r\ngreen, b,\r\n(pindex >> 1) + i);\r\n}\r\n}\r\nif (fb->depth != 16)\r\nfb_helper->funcs->gamma_set(crtc, red, green, blue, pindex);\r\nreturn 0;\r\n}\r\nint drm_fb_helper_setcmap(struct fb_cmap *cmap, struct fb_info *info)\r\n{\r\nstruct drm_fb_helper *fb_helper = info->par;\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_crtc_helper_funcs *crtc_funcs;\r\nu16 *red, *green, *blue, *transp;\r\nstruct drm_crtc *crtc;\r\nint i, j, rc = 0;\r\nint start;\r\ndrm_modeset_lock_all(dev);\r\nif (!drm_fb_helper_is_bound(fb_helper)) {\r\ndrm_modeset_unlock_all(dev);\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\ncrtc = fb_helper->crtc_info[i].mode_set.crtc;\r\ncrtc_funcs = crtc->helper_private;\r\nred = cmap->red;\r\ngreen = cmap->green;\r\nblue = cmap->blue;\r\ntransp = cmap->transp;\r\nstart = cmap->start;\r\nfor (j = 0; j < cmap->len; j++) {\r\nu16 hred, hgreen, hblue, htransp = 0xffff;\r\nhred = *red++;\r\nhgreen = *green++;\r\nhblue = *blue++;\r\nif (transp)\r\nhtransp = *transp++;\r\nrc = setcolreg(crtc, hred, hgreen, hblue, start++, info);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (crtc_funcs->load_lut)\r\ncrtc_funcs->load_lut(crtc);\r\n}\r\nout:\r\ndrm_modeset_unlock_all(dev);\r\nreturn rc;\r\n}\r\nint drm_fb_helper_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct drm_fb_helper *fb_helper = info->par;\r\nstruct drm_framebuffer *fb = fb_helper->fb;\r\nint depth;\r\nif (var->pixclock != 0 || in_dbg_master())\r\nreturn -EINVAL;\r\nif (var->bits_per_pixel > fb->bits_per_pixel ||\r\nvar->xres > fb->width || var->yres > fb->height ||\r\nvar->xres_virtual > fb->width || var->yres_virtual > fb->height) {\r\nDRM_DEBUG("fb userspace requested width/height/bpp is greater than current fb "\r\n"request %dx%d-%d (virtual %dx%d) > %dx%d-%d\n",\r\nvar->xres, var->yres, var->bits_per_pixel,\r\nvar->xres_virtual, var->yres_virtual,\r\nfb->width, fb->height, fb->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\ndepth = (var->green.length == 6) ? 16 : 15;\r\nbreak;\r\ncase 32:\r\ndepth = (var->transp.length > 0) ? 32 : 24;\r\nbreak;\r\ndefault:\r\ndepth = var->bits_per_pixel;\r\nbreak;\r\n}\r\nswitch (depth) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->green.offset = 0;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 15:\r\nvar->red.offset = 10;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nvar->transp.length = 1;\r\nvar->transp.offset = 15;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint drm_fb_helper_set_par(struct fb_info *info)\r\n{\r\nstruct drm_fb_helper *fb_helper = info->par;\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint ret;\r\nint i;\r\nif (var->pixclock != 0) {\r\nDRM_ERROR("PIXEL CLOCK SET\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_modeset_lock_all(dev);\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\nret = drm_mode_set_config_internal(&fb_helper->crtc_info[i].mode_set);\r\nif (ret) {\r\ndrm_modeset_unlock_all(dev);\r\nreturn ret;\r\n}\r\n}\r\ndrm_modeset_unlock_all(dev);\r\nif (fb_helper->delayed_hotplug) {\r\nfb_helper->delayed_hotplug = false;\r\ndrm_fb_helper_hotplug_event(fb_helper);\r\n}\r\nreturn 0;\r\n}\r\nint drm_fb_helper_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct drm_fb_helper *fb_helper = info->par;\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_mode_set *modeset;\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\nint i;\r\ndrm_modeset_lock_all(dev);\r\nif (!drm_fb_helper_is_bound(fb_helper)) {\r\ndrm_modeset_unlock_all(dev);\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\ncrtc = fb_helper->crtc_info[i].mode_set.crtc;\r\nmodeset = &fb_helper->crtc_info[i].mode_set;\r\nmodeset->x = var->xoffset;\r\nmodeset->y = var->yoffset;\r\nif (modeset->num_connectors) {\r\nret = drm_mode_set_config_internal(modeset);\r\nif (!ret) {\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\n}\r\n}\r\n}\r\ndrm_modeset_unlock_all(dev);\r\nreturn ret;\r\n}\r\nstatic int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,\r\nint preferred_bpp)\r\n{\r\nint ret = 0;\r\nint crtc_count = 0;\r\nint i;\r\nstruct fb_info *info;\r\nstruct drm_fb_helper_surface_size sizes;\r\nint gamma_size = 0;\r\nmemset(&sizes, 0, sizeof(struct drm_fb_helper_surface_size));\r\nsizes.surface_depth = 24;\r\nsizes.surface_bpp = 32;\r\nsizes.fb_width = (unsigned)-1;\r\nsizes.fb_height = (unsigned)-1;\r\nif (preferred_bpp != sizes.surface_bpp)\r\nsizes.surface_depth = sizes.surface_bpp = preferred_bpp;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nstruct drm_fb_helper_connector *fb_helper_conn = fb_helper->connector_info[i];\r\nstruct drm_cmdline_mode *cmdline_mode;\r\ncmdline_mode = &fb_helper_conn->cmdline_mode;\r\nif (cmdline_mode->bpp_specified) {\r\nswitch (cmdline_mode->bpp) {\r\ncase 8:\r\nsizes.surface_depth = sizes.surface_bpp = 8;\r\nbreak;\r\ncase 15:\r\nsizes.surface_depth = 15;\r\nsizes.surface_bpp = 16;\r\nbreak;\r\ncase 16:\r\nsizes.surface_depth = sizes.surface_bpp = 16;\r\nbreak;\r\ncase 24:\r\nsizes.surface_depth = sizes.surface_bpp = 24;\r\nbreak;\r\ncase 32:\r\nsizes.surface_depth = 24;\r\nsizes.surface_bpp = 32;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\ncrtc_count = 0;\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\nstruct drm_display_mode *desired_mode;\r\ndesired_mode = fb_helper->crtc_info[i].desired_mode;\r\nif (desired_mode) {\r\nif (gamma_size == 0)\r\ngamma_size = fb_helper->crtc_info[i].mode_set.crtc->gamma_size;\r\nif (desired_mode->hdisplay < sizes.fb_width)\r\nsizes.fb_width = desired_mode->hdisplay;\r\nif (desired_mode->vdisplay < sizes.fb_height)\r\nsizes.fb_height = desired_mode->vdisplay;\r\nif (desired_mode->hdisplay > sizes.surface_width)\r\nsizes.surface_width = desired_mode->hdisplay;\r\nif (desired_mode->vdisplay > sizes.surface_height)\r\nsizes.surface_height = desired_mode->vdisplay;\r\ncrtc_count++;\r\n}\r\n}\r\nif (crtc_count == 0 || sizes.fb_width == -1 || sizes.fb_height == -1) {\r\nDRM_INFO("Cannot find any crtc or sizes - going 1024x768\n");\r\nsizes.fb_width = sizes.surface_width = 1024;\r\nsizes.fb_height = sizes.surface_height = 768;\r\n}\r\nret = (*fb_helper->funcs->fb_probe)(fb_helper, &sizes);\r\nif (ret < 0)\r\nreturn ret;\r\ninfo = fb_helper->fbdev;\r\nfor (i = 0; i < fb_helper->crtc_count; i++)\r\nif (fb_helper->crtc_info[i].mode_set.num_connectors)\r\nfb_helper->crtc_info[i].mode_set.fb = fb_helper->fb;\r\ninfo->var.pixclock = 0;\r\nif (register_framebuffer(info) < 0)\r\nreturn -EINVAL;\r\ndev_info(fb_helper->dev->dev, "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nif (list_empty(&kernel_fb_helper_list)) {\r\ndev_info(fb_helper->dev->dev, "registered panic notifier\n");\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&paniced);\r\nregister_sysrq_key('v', &sysrq_drm_fb_helper_restore_op);\r\n}\r\nlist_add(&fb_helper->kernel_fb_list, &kernel_fb_helper_list);\r\nreturn 0;\r\n}\r\nvoid drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch,\r\nuint32_t depth)\r\n{\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = depth == 8 ? FB_VISUAL_PSEUDOCOLOR :\r\nFB_VISUAL_TRUECOLOR;\r\ninfo->fix.mmio_start = 0;\r\ninfo->fix.mmio_len = 0;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 1;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.line_length = pitch;\r\nreturn;\r\n}\r\nvoid drm_fb_helper_fill_var(struct fb_info *info, struct drm_fb_helper *fb_helper,\r\nuint32_t fb_width, uint32_t fb_height)\r\n{\r\nstruct drm_framebuffer *fb = fb_helper->fb;\r\ninfo->pseudo_palette = fb_helper->pseudo_palette;\r\ninfo->var.xres_virtual = fb->width;\r\ninfo->var.yres_virtual = fb->height;\r\ninfo->var.bits_per_pixel = fb->bits_per_pixel;\r\ninfo->var.accel_flags = FB_ACCELF_TEXT;\r\ninfo->var.xoffset = 0;\r\ninfo->var.yoffset = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\nswitch (fb->depth) {\r\ncase 8:\r\ninfo->var.red.offset = 0;\r\ninfo->var.green.offset = 0;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\nbreak;\r\ncase 15:\r\ninfo->var.red.offset = 10;\r\ninfo->var.green.offset = 5;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 5;\r\ninfo->var.green.length = 5;\r\ninfo->var.blue.length = 5;\r\ninfo->var.transp.offset = 15;\r\ninfo->var.transp.length = 1;\r\nbreak;\r\ncase 16:\r\ninfo->var.red.offset = 11;\r\ninfo->var.green.offset = 5;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 5;\r\ninfo->var.green.length = 6;\r\ninfo->var.blue.length = 5;\r\ninfo->var.transp.offset = 0;\r\nbreak;\r\ncase 24:\r\ninfo->var.red.offset = 16;\r\ninfo->var.green.offset = 8;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\nbreak;\r\ncase 32:\r\ninfo->var.red.offset = 16;\r\ninfo->var.green.offset = 8;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\ninfo->var.transp.offset = 24;\r\ninfo->var.transp.length = 8;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninfo->var.xres = fb_width;\r\ninfo->var.yres = fb_height;\r\n}\r\nstatic int drm_fb_helper_probe_connector_modes(struct drm_fb_helper *fb_helper,\r\nuint32_t maxX,\r\nuint32_t maxY)\r\n{\r\nstruct drm_connector *connector;\r\nint count = 0;\r\nint i;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nconnector = fb_helper->connector_info[i]->connector;\r\ncount += connector->funcs->fill_modes(connector, maxX, maxY);\r\n}\r\nreturn count;\r\n}\r\nstatic struct drm_display_mode *drm_has_preferred_mode(struct drm_fb_helper_connector *fb_connector, int width, int height)\r\n{\r\nstruct drm_display_mode *mode;\r\nlist_for_each_entry(mode, &fb_connector->connector->modes, head) {\r\nif (drm_mode_width(mode) > width ||\r\ndrm_mode_height(mode) > height)\r\ncontinue;\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED)\r\nreturn mode;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool drm_has_cmdline_mode(struct drm_fb_helper_connector *fb_connector)\r\n{\r\nstruct drm_cmdline_mode *cmdline_mode;\r\ncmdline_mode = &fb_connector->cmdline_mode;\r\nreturn cmdline_mode->specified;\r\n}\r\nstatic struct drm_display_mode *drm_pick_cmdline_mode(struct drm_fb_helper_connector *fb_helper_conn,\r\nint width, int height)\r\n{\r\nstruct drm_cmdline_mode *cmdline_mode;\r\nstruct drm_display_mode *mode = NULL;\r\ncmdline_mode = &fb_helper_conn->cmdline_mode;\r\nif (cmdline_mode->specified == false)\r\nreturn mode;\r\nif (cmdline_mode->rb || cmdline_mode->margins)\r\ngoto create_mode;\r\nlist_for_each_entry(mode, &fb_helper_conn->connector->modes, head) {\r\nif (mode->hdisplay != cmdline_mode->xres ||\r\nmode->vdisplay != cmdline_mode->yres)\r\ncontinue;\r\nif (cmdline_mode->refresh_specified) {\r\nif (mode->vrefresh != cmdline_mode->refresh)\r\ncontinue;\r\n}\r\nif (cmdline_mode->interlace) {\r\nif (!(mode->flags & DRM_MODE_FLAG_INTERLACE))\r\ncontinue;\r\n}\r\nreturn mode;\r\n}\r\ncreate_mode:\r\nmode = drm_mode_create_from_cmdline_mode(fb_helper_conn->connector->dev,\r\ncmdline_mode);\r\nlist_add(&mode->head, &fb_helper_conn->connector->modes);\r\nreturn mode;\r\n}\r\nstatic bool drm_connector_enabled(struct drm_connector *connector, bool strict)\r\n{\r\nbool enable;\r\nif (strict)\r\nenable = connector->status == connector_status_connected;\r\nelse\r\nenable = connector->status != connector_status_disconnected;\r\nreturn enable;\r\n}\r\nstatic void drm_enable_connectors(struct drm_fb_helper *fb_helper,\r\nbool *enabled)\r\n{\r\nbool any_enabled = false;\r\nstruct drm_connector *connector;\r\nint i = 0;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nconnector = fb_helper->connector_info[i]->connector;\r\nenabled[i] = drm_connector_enabled(connector, true);\r\nDRM_DEBUG_KMS("connector %d enabled? %s\n", connector->base.id,\r\nenabled[i] ? "yes" : "no");\r\nany_enabled |= enabled[i];\r\n}\r\nif (any_enabled)\r\nreturn;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nconnector = fb_helper->connector_info[i]->connector;\r\nenabled[i] = drm_connector_enabled(connector, false);\r\n}\r\n}\r\nstatic bool drm_target_cloned(struct drm_fb_helper *fb_helper,\r\nstruct drm_display_mode **modes,\r\nbool *enabled, int width, int height)\r\n{\r\nint count, i, j;\r\nbool can_clone = false;\r\nstruct drm_fb_helper_connector *fb_helper_conn;\r\nstruct drm_display_mode *dmt_mode, *mode;\r\nif (fb_helper->crtc_count > 1)\r\nreturn false;\r\ncount = 0;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nif (enabled[i])\r\ncount++;\r\n}\r\nif (count <= 1)\r\nreturn false;\r\ncan_clone = true;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nif (!enabled[i])\r\ncontinue;\r\nfb_helper_conn = fb_helper->connector_info[i];\r\nmodes[i] = drm_pick_cmdline_mode(fb_helper_conn, width, height);\r\nif (!modes[i]) {\r\ncan_clone = false;\r\nbreak;\r\n}\r\nfor (j = 0; j < i; j++) {\r\nif (!enabled[j])\r\ncontinue;\r\nif (!drm_mode_equal(modes[j], modes[i]))\r\ncan_clone = false;\r\n}\r\n}\r\nif (can_clone) {\r\nDRM_DEBUG_KMS("can clone using command line\n");\r\nreturn true;\r\n}\r\ncan_clone = true;\r\ndmt_mode = drm_mode_find_dmt(fb_helper->dev, 1024, 768, 60, false);\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nif (!enabled[i])\r\ncontinue;\r\nfb_helper_conn = fb_helper->connector_info[i];\r\nlist_for_each_entry(mode, &fb_helper_conn->connector->modes, head) {\r\nif (drm_mode_equal(mode, dmt_mode))\r\nmodes[i] = mode;\r\n}\r\nif (!modes[i])\r\ncan_clone = false;\r\n}\r\nif (can_clone) {\r\nDRM_DEBUG_KMS("can clone using 1024x768\n");\r\nreturn true;\r\n}\r\nDRM_INFO("kms: can't enable cloning when we probably wanted to.\n");\r\nreturn false;\r\n}\r\nstatic bool drm_target_preferred(struct drm_fb_helper *fb_helper,\r\nstruct drm_display_mode **modes,\r\nbool *enabled, int width, int height)\r\n{\r\nstruct drm_fb_helper_connector *fb_helper_conn;\r\nint i;\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nfb_helper_conn = fb_helper->connector_info[i];\r\nif (enabled[i] == false)\r\ncontinue;\r\nDRM_DEBUG_KMS("looking for cmdline mode on connector %d\n",\r\nfb_helper_conn->connector->base.id);\r\nmodes[i] = drm_pick_cmdline_mode(fb_helper_conn, width, height);\r\nif (!modes[i]) {\r\nDRM_DEBUG_KMS("looking for preferred mode on connector %d\n",\r\nfb_helper_conn->connector->base.id);\r\nmodes[i] = drm_has_preferred_mode(fb_helper_conn, width, height);\r\n}\r\nif (!modes[i] && !list_empty(&fb_helper_conn->connector->modes)) {\r\nlist_for_each_entry(modes[i], &fb_helper_conn->connector->modes, head)\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("found mode %s\n", modes[i] ? modes[i]->name :\r\n"none");\r\n}\r\nreturn true;\r\n}\r\nstatic int drm_pick_crtcs(struct drm_fb_helper *fb_helper,\r\nstruct drm_fb_helper_crtc **best_crtcs,\r\nstruct drm_display_mode **modes,\r\nint n, int width, int height)\r\n{\r\nint c, o;\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_connector_helper_funcs *connector_funcs;\r\nstruct drm_encoder *encoder;\r\nstruct drm_fb_helper_crtc *best_crtc;\r\nint my_score, best_score, score;\r\nstruct drm_fb_helper_crtc **crtcs, *crtc;\r\nstruct drm_fb_helper_connector *fb_helper_conn;\r\nif (n == fb_helper->connector_count)\r\nreturn 0;\r\nfb_helper_conn = fb_helper->connector_info[n];\r\nconnector = fb_helper_conn->connector;\r\nbest_crtcs[n] = NULL;\r\nbest_crtc = NULL;\r\nbest_score = drm_pick_crtcs(fb_helper, best_crtcs, modes, n+1, width, height);\r\nif (modes[n] == NULL)\r\nreturn best_score;\r\ncrtcs = kzalloc(dev->mode_config.num_connector *\r\nsizeof(struct drm_fb_helper_crtc *), GFP_KERNEL);\r\nif (!crtcs)\r\nreturn best_score;\r\nmy_score = 1;\r\nif (connector->status == connector_status_connected)\r\nmy_score++;\r\nif (drm_has_cmdline_mode(fb_helper_conn))\r\nmy_score++;\r\nif (drm_has_preferred_mode(fb_helper_conn, width, height))\r\nmy_score++;\r\nconnector_funcs = connector->helper_private;\r\nencoder = connector_funcs->best_encoder(connector);\r\nif (!encoder)\r\ngoto out;\r\nfor (c = 0; c < fb_helper->crtc_count; c++) {\r\ncrtc = &fb_helper->crtc_info[c];\r\nif ((encoder->possible_crtcs & (1 << c)) == 0)\r\ncontinue;\r\nfor (o = 0; o < n; o++)\r\nif (best_crtcs[o] == crtc)\r\nbreak;\r\nif (o < n) {\r\nif (fb_helper->crtc_count > 1)\r\ncontinue;\r\nif (!drm_mode_equal(modes[o], modes[n]))\r\ncontinue;\r\n}\r\ncrtcs[n] = crtc;\r\nmemcpy(crtcs, best_crtcs, n * sizeof(struct drm_fb_helper_crtc *));\r\nscore = my_score + drm_pick_crtcs(fb_helper, crtcs, modes, n + 1,\r\nwidth, height);\r\nif (score > best_score) {\r\nbest_crtc = crtc;\r\nbest_score = score;\r\nmemcpy(best_crtcs, crtcs,\r\ndev->mode_config.num_connector *\r\nsizeof(struct drm_fb_helper_crtc *));\r\n}\r\n}\r\nout:\r\nkfree(crtcs);\r\nreturn best_score;\r\n}\r\nstatic void drm_setup_crtcs(struct drm_fb_helper *fb_helper)\r\n{\r\nstruct drm_device *dev = fb_helper->dev;\r\nstruct drm_fb_helper_crtc **crtcs;\r\nstruct drm_display_mode **modes;\r\nstruct drm_mode_set *modeset;\r\nbool *enabled;\r\nint width, height;\r\nint i;\r\nDRM_DEBUG_KMS("\n");\r\nwidth = dev->mode_config.max_width;\r\nheight = dev->mode_config.max_height;\r\ncrtcs = kcalloc(dev->mode_config.num_connector,\r\nsizeof(struct drm_fb_helper_crtc *), GFP_KERNEL);\r\nmodes = kcalloc(dev->mode_config.num_connector,\r\nsizeof(struct drm_display_mode *), GFP_KERNEL);\r\nenabled = kcalloc(dev->mode_config.num_connector,\r\nsizeof(bool), GFP_KERNEL);\r\nif (!crtcs || !modes || !enabled) {\r\nDRM_ERROR("Memory allocation failed\n");\r\ngoto out;\r\n}\r\ndrm_enable_connectors(fb_helper, enabled);\r\nif (!(fb_helper->funcs->initial_config &&\r\nfb_helper->funcs->initial_config(fb_helper, crtcs, modes,\r\nenabled, width, height))) {\r\nmemset(modes, 0, dev->mode_config.num_connector*sizeof(modes[0]));\r\nmemset(crtcs, 0, dev->mode_config.num_connector*sizeof(crtcs[0]));\r\nif (!drm_target_cloned(fb_helper,\r\nmodes, enabled, width, height) &&\r\n!drm_target_preferred(fb_helper,\r\nmodes, enabled, width, height))\r\nDRM_ERROR("Unable to find initial modes\n");\r\nDRM_DEBUG_KMS("picking CRTCs for %dx%d config\n",\r\nwidth, height);\r\ndrm_pick_crtcs(fb_helper, crtcs, modes, 0, width, height);\r\n}\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\nmodeset = &fb_helper->crtc_info[i].mode_set;\r\nmodeset->num_connectors = 0;\r\nmodeset->fb = NULL;\r\n}\r\nfor (i = 0; i < fb_helper->connector_count; i++) {\r\nstruct drm_display_mode *mode = modes[i];\r\nstruct drm_fb_helper_crtc *fb_crtc = crtcs[i];\r\nmodeset = &fb_crtc->mode_set;\r\nif (mode && fb_crtc) {\r\nDRM_DEBUG_KMS("desired mode %s set on crtc %d\n",\r\nmode->name, fb_crtc->mode_set.crtc->base.id);\r\nfb_crtc->desired_mode = mode;\r\nif (modeset->mode)\r\ndrm_mode_destroy(dev, modeset->mode);\r\nmodeset->mode = drm_mode_duplicate(dev,\r\nfb_crtc->desired_mode);\r\nmodeset->connectors[modeset->num_connectors++] = fb_helper->connector_info[i]->connector;\r\nmodeset->fb = fb_helper->fb;\r\n}\r\n}\r\nfor (i = 0; i < fb_helper->crtc_count; i++) {\r\nmodeset = &fb_helper->crtc_info[i].mode_set;\r\nif (modeset->num_connectors == 0) {\r\nBUG_ON(modeset->fb);\r\nBUG_ON(modeset->num_connectors);\r\nif (modeset->mode)\r\ndrm_mode_destroy(dev, modeset->mode);\r\nmodeset->mode = NULL;\r\n}\r\n}\r\nout:\r\nkfree(crtcs);\r\nkfree(modes);\r\nkfree(enabled);\r\n}\r\nbool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper, int bpp_sel)\r\n{\r\nstruct drm_device *dev = fb_helper->dev;\r\nint count = 0;\r\ndrm_fb_helper_parse_command_line(fb_helper);\r\ncount = drm_fb_helper_probe_connector_modes(fb_helper,\r\ndev->mode_config.max_width,\r\ndev->mode_config.max_height);\r\nif (count == 0)\r\ndev_info(fb_helper->dev->dev, "No connectors reported connected with modes\n");\r\ndrm_setup_crtcs(fb_helper);\r\nreturn drm_fb_helper_single_fb_probe(fb_helper, bpp_sel);\r\n}\r\nint drm_fb_helper_hotplug_event(struct drm_fb_helper *fb_helper)\r\n{\r\nstruct drm_device *dev = fb_helper->dev;\r\nint count = 0;\r\nu32 max_width, max_height, bpp_sel;\r\nif (!fb_helper->fb)\r\nreturn 0;\r\nmutex_lock(&fb_helper->dev->mode_config.mutex);\r\nif (!drm_fb_helper_is_bound(fb_helper)) {\r\nfb_helper->delayed_hotplug = true;\r\nmutex_unlock(&fb_helper->dev->mode_config.mutex);\r\nreturn 0;\r\n}\r\nDRM_DEBUG_KMS("\n");\r\nmax_width = fb_helper->fb->width;\r\nmax_height = fb_helper->fb->height;\r\nbpp_sel = fb_helper->fb->bits_per_pixel;\r\ncount = drm_fb_helper_probe_connector_modes(fb_helper, max_width,\r\nmax_height);\r\nmutex_unlock(&fb_helper->dev->mode_config.mutex);\r\ndrm_modeset_lock_all(dev);\r\ndrm_setup_crtcs(fb_helper);\r\ndrm_modeset_unlock_all(dev);\r\ndrm_fb_helper_set_par(fb_helper->fbdev);\r\nreturn 0;\r\n}\r\nstatic int __init drm_fb_helper_modinit(void)\r\n{\r\nconst char *name = "fbcon";\r\nstruct module *fbcon;\r\nmutex_lock(&module_mutex);\r\nfbcon = find_module(name);\r\nmutex_unlock(&module_mutex);\r\nif (!fbcon)\r\nrequest_module_nowait(name);\r\nreturn 0;\r\n}
