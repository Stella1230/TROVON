static void __init ap_map_io(void)\r\n{\r\niotable_init(ap_io_desc, ARRAY_SIZE(ap_io_desc));\r\npci_v3_early_init();\r\n}\r\nstatic int irq_suspend(void)\r\n{\r\nic_irq_enable = readl(VA_IC_BASE + IRQ_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void irq_resume(void)\r\n{\r\nwritel(-1, VA_CMIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(-1, VA_IC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(-1, VA_IC_BASE + FIQ_ENABLE_CLEAR);\r\nwritel(ic_irq_enable, VA_IC_BASE + IRQ_ENABLE_SET);\r\n}\r\nstatic int __init irq_syscore_init(void)\r\n{\r\nregister_syscore_ops(&irq_syscore_ops);\r\nreturn 0;\r\n}\r\nstatic int ap_flash_init(struct platform_device *dev)\r\n{\r\nu32 tmp;\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP,\r\nap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\ntmp = readl(EBI_CSR1) | INTEGRATOR_EBI_WRITE_ENABLE;\r\nwritel(tmp, EBI_CSR1);\r\nif (!(readl(EBI_CSR1) & INTEGRATOR_EBI_WRITE_ENABLE)) {\r\nwritel(0xa05f, EBI_LOCK);\r\nwritel(tmp, EBI_CSR1);\r\nwritel(0, EBI_LOCK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ap_flash_exit(struct platform_device *dev)\r\n{\r\nu32 tmp;\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN | INTEGRATOR_SC_CTRL_nFLWP,\r\nap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\ntmp = readl(EBI_CSR1) & ~INTEGRATOR_EBI_WRITE_ENABLE;\r\nwritel(tmp, EBI_CSR1);\r\nif (readl(EBI_CSR1) & INTEGRATOR_EBI_WRITE_ENABLE) {\r\nwritel(0xa05f, EBI_LOCK);\r\nwritel(tmp, EBI_CSR1);\r\nwritel(0, EBI_LOCK);\r\n}\r\n}\r\nstatic void ap_flash_set_vpp(struct platform_device *pdev, int on)\r\n{\r\nif (on)\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN,\r\nap_syscon_base + INTEGRATOR_SC_CTRLS_OFFSET);\r\nelse\r\nwritel(INTEGRATOR_SC_CTRL_nFLVPPEN,\r\nap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\n}\r\nstatic void integrator_uart_set_mctrl(struct amba_device *dev,\r\nvoid __iomem *base, unsigned int mctrl)\r\n{\r\nunsigned int ctrls = 0, ctrlc = 0, rts_mask, dtr_mask;\r\nu32 phybase = dev->res.start;\r\nif (phybase == INTEGRATOR_UART0_BASE) {\r\nrts_mask = 1 << 4;\r\ndtr_mask = 1 << 5;\r\n} else {\r\nrts_mask = 1 << 6;\r\ndtr_mask = 1 << 7;\r\n}\r\nif (mctrl & TIOCM_RTS)\r\nctrlc |= rts_mask;\r\nelse\r\nctrls |= rts_mask;\r\nif (mctrl & TIOCM_DTR)\r\nctrlc |= dtr_mask;\r\nelse\r\nctrls |= dtr_mask;\r\n__raw_writel(ctrls, ap_syscon_base + INTEGRATOR_SC_CTRLS_OFFSET);\r\n__raw_writel(ctrlc, ap_syscon_base + INTEGRATOR_SC_CTRLC_OFFSET);\r\n}\r\nstatic u32 notrace integrator_read_sched_clock(void)\r\n{\r\nreturn -readl((void __iomem *) TIMER2_VA_BASE + TIMER_VALUE);\r\n}\r\nstatic void integrator_clocksource_init(unsigned long inrate,\r\nvoid __iomem *base)\r\n{\r\nu32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;\r\nunsigned long rate = inrate;\r\nif (rate >= 1500000) {\r\nrate /= 16;\r\nctrl |= TIMER_CTRL_DIV16;\r\n}\r\nwritel(0xffff, base + TIMER_LOAD);\r\nwritel(ctrl, base + TIMER_CTRL);\r\nclocksource_mmio_init(base + TIMER_VALUE, "timer2",\r\nrate, 200, 16, clocksource_mmio_readl_down);\r\nsetup_sched_clock(integrator_read_sched_clock, 16, rate);\r\n}\r\nstatic irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(1, clkevt_base + TIMER_INTCLR);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void clkevt_set_mode(enum clock_event_mode mode, struct clock_event_device *evt)\r\n{\r\nu32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nwritel(timer_reload, clkevt_base + TIMER_LOAD);\r\nctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nctrl &= ~TIMER_CTRL_PERIODIC;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_RESUME:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)\r\n{\r\nunsigned long ctrl = readl(clkevt_base + TIMER_CTRL);\r\nwritel(ctrl & ~TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\r\nwritel(next, clkevt_base + TIMER_LOAD);\r\nwritel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic void integrator_clockevent_init(unsigned long inrate,\r\nvoid __iomem *base, int irq)\r\n{\r\nunsigned long rate = inrate;\r\nunsigned int ctrl = 0;\r\nclkevt_base = base;\r\nif (rate > 0x100000 * HZ) {\r\nrate /= 256;\r\nctrl |= TIMER_CTRL_DIV256;\r\n} else if (rate > 0x10000 * HZ) {\r\nrate /= 16;\r\nctrl |= TIMER_CTRL_DIV16;\r\n}\r\ntimer_reload = rate / HZ;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nsetup_irq(irq, &integrator_timer_irq);\r\nclockevents_config_and_register(&integrator_clockevent,\r\nrate,\r\n1,\r\n0xffffU);\r\n}\r\nvoid __init ap_init_early(void)\r\n{\r\n}\r\nstatic void __init ap_of_timer_init(void)\r\n{\r\nstruct device_node *node;\r\nconst char *path;\r\nvoid __iomem *base;\r\nint err;\r\nint irq;\r\nstruct clk *clk;\r\nunsigned long rate;\r\nclk = clk_get_sys("ap_timer", NULL);\r\nBUG_ON(IS_ERR(clk));\r\nclk_prepare_enable(clk);\r\nrate = clk_get_rate(clk);\r\nerr = of_property_read_string(of_aliases,\r\n"arm,timer-primary", &path);\r\nif (WARN_ON(err))\r\nreturn;\r\nnode = of_find_node_by_path(path);\r\nbase = of_iomap(node, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nwritel(0, base + TIMER_CTRL);\r\nintegrator_clocksource_init(rate, base);\r\nerr = of_property_read_string(of_aliases,\r\n"arm,timer-secondary", &path);\r\nif (WARN_ON(err))\r\nreturn;\r\nnode = of_find_node_by_path(path);\r\nbase = of_iomap(node, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nirq = irq_of_parse_and_map(node, 0);\r\nwritel(0, base + TIMER_CTRL);\r\nintegrator_clockevent_init(rate, base, irq);\r\n}\r\nstatic void __init ap_init_irq_of(void)\r\n{\r\nwritel(0xffffffffU, VA_CMIC_BASE + IRQ_ENABLE_CLEAR);\r\nof_irq_init(fpga_irq_of_match);\r\nintegrator_clk_init(false);\r\n}\r\nstatic void __init ap_init_of(void)\r\n{\r\nunsigned long sc_dec;\r\nstruct device_node *root;\r\nstruct device_node *syscon;\r\nstruct device *parent;\r\nstruct soc_device *soc_dev;\r\nstruct soc_device_attribute *soc_dev_attr;\r\nu32 ap_sc_id;\r\nint err;\r\nint i;\r\nroot = of_find_node_by_path("/");\r\nif (!root)\r\nreturn;\r\nsyscon = of_find_node_by_path("/syscon");\r\nif (!syscon)\r\nreturn;\r\nap_syscon_base = of_iomap(syscon, 0);\r\nif (!ap_syscon_base)\r\nreturn;\r\nap_sc_id = readl(ap_syscon_base);\r\nsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\r\nif (!soc_dev_attr)\r\nreturn;\r\nerr = of_property_read_string(root, "compatible",\r\n&soc_dev_attr->soc_id);\r\nif (err)\r\nreturn;\r\nerr = of_property_read_string(root, "model", &soc_dev_attr->machine);\r\nif (err)\r\nreturn;\r\nsoc_dev_attr->family = "Integrator";\r\nsoc_dev_attr->revision = kasprintf(GFP_KERNEL, "%c",\r\n'A' + (ap_sc_id & 0x0f));\r\nsoc_dev = soc_device_register(soc_dev_attr);\r\nif (IS_ERR(soc_dev)) {\r\nkfree(soc_dev_attr->revision);\r\nkfree(soc_dev_attr);\r\nreturn;\r\n}\r\nparent = soc_device_to_device(soc_dev);\r\nintegrator_init_sysfs(parent, ap_sc_id);\r\nof_platform_populate(root, of_default_bus_match_table,\r\nap_auxdata_lookup, parent);\r\nsc_dec = readl(ap_syscon_base + INTEGRATOR_SC_DEC_OFFSET);\r\nfor (i = 0; i < 4; i++) {\r\nstruct lm_device *lmdev;\r\nif ((sc_dec & (16 << i)) == 0)\r\ncontinue;\r\nlmdev = kzalloc(sizeof(struct lm_device), GFP_KERNEL);\r\nif (!lmdev)\r\ncontinue;\r\nlmdev->resource.start = 0xc0000000 + 0x10000000 * i;\r\nlmdev->resource.end = lmdev->resource.start + 0x0fffffff;\r\nlmdev->resource.flags = IORESOURCE_MEM;\r\nlmdev->irq = IRQ_AP_EXPINT0 + i;\r\nlmdev->id = i;\r\nlm_device_register(lmdev);\r\n}\r\n}\r\nstatic void __init ap_map_io_atag(void)\r\n{\r\niotable_init(ap_io_desc_atag, ARRAY_SIZE(ap_io_desc_atag));\r\nap_map_io();\r\n}\r\nstatic void __init ap_timer_init(void)\r\n{\r\nstruct clk *clk;\r\nunsigned long rate;\r\nclk = clk_get_sys("ap_timer", NULL);\r\nBUG_ON(IS_ERR(clk));\r\nclk_prepare_enable(clk);\r\nrate = clk_get_rate(clk);\r\nwritel(0, TIMER0_VA_BASE + TIMER_CTRL);\r\nwritel(0, TIMER1_VA_BASE + TIMER_CTRL);\r\nwritel(0, TIMER2_VA_BASE + TIMER_CTRL);\r\nintegrator_clocksource_init(rate, (void __iomem *)TIMER2_VA_BASE);\r\nintegrator_clockevent_init(rate, (void __iomem *)TIMER1_VA_BASE,\r\nIRQ_TIMERINT1);\r\n}\r\nstatic void __init ap_init_irq(void)\r\n{\r\nwritel(-1, VA_CMIC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(-1, VA_IC_BASE + IRQ_ENABLE_CLEAR);\r\nwritel(-1, VA_IC_BASE + FIQ_ENABLE_CLEAR);\r\nfpga_irq_init(VA_IC_BASE, "SC", IRQ_PIC_START,\r\n-1, INTEGRATOR_SC_VALID_INT, NULL);\r\nintegrator_clk_init(false);\r\n}\r\nstatic void __init ap_init(void)\r\n{\r\nunsigned long sc_dec;\r\nint i;\r\nplatform_device_register(&pci_v3_device);\r\nplatform_device_register(&cfi_flash_device);\r\nap_syscon_base = __io_address(INTEGRATOR_SC_BASE);\r\nsc_dec = readl(ap_syscon_base + INTEGRATOR_SC_DEC_OFFSET);\r\nfor (i = 0; i < 4; i++) {\r\nstruct lm_device *lmdev;\r\nif ((sc_dec & (16 << i)) == 0)\r\ncontinue;\r\nlmdev = kzalloc(sizeof(struct lm_device), GFP_KERNEL);\r\nif (!lmdev)\r\ncontinue;\r\nlmdev->resource.start = 0xc0000000 + 0x10000000 * i;\r\nlmdev->resource.end = lmdev->resource.start + 0x0fffffff;\r\nlmdev->resource.flags = IORESOURCE_MEM;\r\nlmdev->irq = IRQ_AP_EXPINT0 + i;\r\nlmdev->id = i;\r\nlm_device_register(lmdev);\r\n}\r\nintegrator_init(false);\r\n}
