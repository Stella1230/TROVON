struct tipc_media *tipc_media_find(const char *name)\r\n{\r\nu32 i;\r\nfor (i = 0; i < media_count; i++) {\r\nif (!strcmp(media_list[i]->name, name))\r\nreturn media_list[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct tipc_media *media_find_id(u8 type)\r\n{\r\nu32 i;\r\nfor (i = 0; i < media_count; i++) {\r\nif (media_list[i]->type_id == type)\r\nreturn media_list[i];\r\n}\r\nreturn NULL;\r\n}\r\nint tipc_register_media(struct tipc_media *m_ptr)\r\n{\r\nint res = -EINVAL;\r\nwrite_lock_bh(&tipc_net_lock);\r\nif ((strlen(m_ptr->name) + 1) > TIPC_MAX_MEDIA_NAME)\r\ngoto exit;\r\nif (m_ptr->priority > TIPC_MAX_LINK_PRI)\r\ngoto exit;\r\nif ((m_ptr->tolerance < TIPC_MIN_LINK_TOL) ||\r\n(m_ptr->tolerance > TIPC_MAX_LINK_TOL))\r\ngoto exit;\r\nif (media_count >= MAX_MEDIA)\r\ngoto exit;\r\nif (tipc_media_find(m_ptr->name) || media_find_id(m_ptr->type_id))\r\ngoto exit;\r\nmedia_list[media_count] = m_ptr;\r\nmedia_count++;\r\nres = 0;\r\nexit:\r\nwrite_unlock_bh(&tipc_net_lock);\r\nif (res)\r\npr_warn("Media <%s> registration error\n", m_ptr->name);\r\nreturn res;\r\n}\r\nvoid tipc_media_addr_printf(char *buf, int len, struct tipc_media_addr *a)\r\n{\r\nchar addr_str[MAX_ADDR_STR];\r\nstruct tipc_media *m_ptr;\r\nint ret;\r\nm_ptr = media_find_id(a->media_id);\r\nif (m_ptr && !m_ptr->addr2str(a, addr_str, sizeof(addr_str)))\r\nret = tipc_snprintf(buf, len, "%s(%s)", m_ptr->name, addr_str);\r\nelse {\r\nu32 i;\r\nret = tipc_snprintf(buf, len, "UNKNOWN(%u)", a->media_id);\r\nfor (i = 0; i < sizeof(a->value); i++)\r\nret += tipc_snprintf(buf - ret, len + ret,\r\n"-%02x", a->value[i]);\r\n}\r\n}\r\nstruct sk_buff *tipc_media_get_names(void)\r\n{\r\nstruct sk_buff *buf;\r\nint i;\r\nbuf = tipc_cfg_reply_alloc(MAX_MEDIA * TLV_SPACE(TIPC_MAX_MEDIA_NAME));\r\nif (!buf)\r\nreturn NULL;\r\nread_lock_bh(&tipc_net_lock);\r\nfor (i = 0; i < media_count; i++) {\r\ntipc_cfg_append_tlv(buf, TIPC_TLV_MEDIA_NAME,\r\nmedia_list[i]->name,\r\nstrlen(media_list[i]->name) + 1);\r\n}\r\nread_unlock_bh(&tipc_net_lock);\r\nreturn buf;\r\n}\r\nstatic int bearer_name_validate(const char *name,\r\nstruct tipc_bearer_names *name_parts)\r\n{\r\nchar name_copy[TIPC_MAX_BEARER_NAME];\r\nchar *media_name;\r\nchar *if_name;\r\nu32 media_len;\r\nu32 if_len;\r\nname_copy[TIPC_MAX_BEARER_NAME - 1] = 0;\r\nstrncpy(name_copy, name, TIPC_MAX_BEARER_NAME);\r\nif (name_copy[TIPC_MAX_BEARER_NAME - 1] != 0)\r\nreturn 0;\r\nmedia_name = name_copy;\r\nif_name = strchr(media_name, ':');\r\nif (if_name == NULL)\r\nreturn 0;\r\n*(if_name++) = 0;\r\nmedia_len = if_name - media_name;\r\nif_len = strlen(if_name) + 1;\r\nif ((media_len <= 1) || (media_len > TIPC_MAX_MEDIA_NAME) ||\r\n(if_len <= 1) || (if_len > TIPC_MAX_IF_NAME))\r\nreturn 0;\r\nif (name_parts) {\r\nstrcpy(name_parts->media_name, media_name);\r\nstrcpy(name_parts->if_name, if_name);\r\n}\r\nreturn 1;\r\n}\r\nstruct tipc_bearer *tipc_bearer_find(const char *name)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nu32 i;\r\nfor (i = 0, b_ptr = tipc_bearers; i < MAX_BEARERS; i++, b_ptr++) {\r\nif (b_ptr->active && (!strcmp(b_ptr->name, name)))\r\nreturn b_ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstruct tipc_bearer *tipc_bearer_find_interface(const char *if_name)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nchar *b_if_name;\r\nu32 i;\r\nfor (i = 0, b_ptr = tipc_bearers; i < MAX_BEARERS; i++, b_ptr++) {\r\nif (!b_ptr->active)\r\ncontinue;\r\nb_if_name = strchr(b_ptr->name, ':') + 1;\r\nif (!strcmp(b_if_name, if_name))\r\nreturn b_ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstruct sk_buff *tipc_bearer_get_names(void)\r\n{\r\nstruct sk_buff *buf;\r\nstruct tipc_bearer *b_ptr;\r\nint i, j;\r\nbuf = tipc_cfg_reply_alloc(MAX_BEARERS * TLV_SPACE(TIPC_MAX_BEARER_NAME));\r\nif (!buf)\r\nreturn NULL;\r\nread_lock_bh(&tipc_net_lock);\r\nfor (i = 0; i < media_count; i++) {\r\nfor (j = 0; j < MAX_BEARERS; j++) {\r\nb_ptr = &tipc_bearers[j];\r\nif (b_ptr->active && (b_ptr->media == media_list[i])) {\r\ntipc_cfg_append_tlv(buf, TIPC_TLV_BEARER_NAME,\r\nb_ptr->name,\r\nstrlen(b_ptr->name) + 1);\r\n}\r\n}\r\n}\r\nread_unlock_bh(&tipc_net_lock);\r\nreturn buf;\r\n}\r\nvoid tipc_bearer_add_dest(struct tipc_bearer *b_ptr, u32 dest)\r\n{\r\ntipc_nmap_add(&b_ptr->nodes, dest);\r\ntipc_bcbearer_sort();\r\ntipc_disc_add_dest(b_ptr->link_req);\r\n}\r\nvoid tipc_bearer_remove_dest(struct tipc_bearer *b_ptr, u32 dest)\r\n{\r\ntipc_nmap_remove(&b_ptr->nodes, dest);\r\ntipc_bcbearer_sort();\r\ntipc_disc_remove_dest(b_ptr->link_req);\r\n}\r\nvoid tipc_continue(struct tipc_bearer *b)\r\n{\r\nspin_lock_bh(&b->lock);\r\nb->blocked = 0;\r\nspin_unlock_bh(&b->lock);\r\n}\r\nint tipc_bearer_blocked(struct tipc_bearer *b)\r\n{\r\nint res;\r\nspin_lock_bh(&b->lock);\r\nres = b->blocked;\r\nspin_unlock_bh(&b->lock);\r\nreturn res;\r\n}\r\nint tipc_enable_bearer(const char *name, u32 disc_domain, u32 priority)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nstruct tipc_media *m_ptr;\r\nstruct tipc_bearer_names b_names;\r\nchar addr_string[16];\r\nu32 bearer_id;\r\nu32 with_this_prio;\r\nu32 i;\r\nint res = -EINVAL;\r\nif (!tipc_own_addr) {\r\npr_warn("Bearer <%s> rejected, not supported in standalone mode\n",\r\nname);\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (!bearer_name_validate(name, &b_names)) {\r\npr_warn("Bearer <%s> rejected, illegal name\n", name);\r\nreturn -EINVAL;\r\n}\r\nif (tipc_addr_domain_valid(disc_domain) &&\r\n(disc_domain != tipc_own_addr)) {\r\nif (tipc_in_scope(disc_domain, tipc_own_addr)) {\r\ndisc_domain = tipc_own_addr & TIPC_CLUSTER_MASK;\r\nres = 0;\r\n} else if (in_own_cluster_exact(disc_domain))\r\nres = 0;\r\n}\r\nif (res) {\r\npr_warn("Bearer <%s> rejected, illegal discovery domain\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\nif ((priority > TIPC_MAX_LINK_PRI) &&\r\n(priority != TIPC_MEDIA_LINK_PRI)) {\r\npr_warn("Bearer <%s> rejected, illegal priority\n", name);\r\nreturn -EINVAL;\r\n}\r\nwrite_lock_bh(&tipc_net_lock);\r\nm_ptr = tipc_media_find(b_names.media_name);\r\nif (!m_ptr) {\r\npr_warn("Bearer <%s> rejected, media <%s> not registered\n",\r\nname, b_names.media_name);\r\ngoto exit;\r\n}\r\nif (priority == TIPC_MEDIA_LINK_PRI)\r\npriority = m_ptr->priority;\r\nrestart:\r\nbearer_id = MAX_BEARERS;\r\nwith_this_prio = 1;\r\nfor (i = MAX_BEARERS; i-- != 0; ) {\r\nif (!tipc_bearers[i].active) {\r\nbearer_id = i;\r\ncontinue;\r\n}\r\nif (!strcmp(name, tipc_bearers[i].name)) {\r\npr_warn("Bearer <%s> rejected, already enabled\n",\r\nname);\r\ngoto exit;\r\n}\r\nif ((tipc_bearers[i].priority == priority) &&\r\n(++with_this_prio > 2)) {\r\nif (priority-- == 0) {\r\npr_warn("Bearer <%s> rejected, duplicate priority\n",\r\nname);\r\ngoto exit;\r\n}\r\npr_warn("Bearer <%s> priority adjustment required %u->%u\n",\r\nname, priority + 1, priority);\r\ngoto restart;\r\n}\r\n}\r\nif (bearer_id >= MAX_BEARERS) {\r\npr_warn("Bearer <%s> rejected, bearer limit reached (%u)\n",\r\nname, MAX_BEARERS);\r\ngoto exit;\r\n}\r\nb_ptr = &tipc_bearers[bearer_id];\r\nstrcpy(b_ptr->name, name);\r\nres = m_ptr->enable_bearer(b_ptr);\r\nif (res) {\r\npr_warn("Bearer <%s> rejected, enable failure (%d)\n",\r\nname, -res);\r\ngoto exit;\r\n}\r\nb_ptr->identity = bearer_id;\r\nb_ptr->media = m_ptr;\r\nb_ptr->tolerance = m_ptr->tolerance;\r\nb_ptr->window = m_ptr->window;\r\nb_ptr->net_plane = bearer_id + 'A';\r\nb_ptr->active = 1;\r\nb_ptr->priority = priority;\r\nINIT_LIST_HEAD(&b_ptr->links);\r\nspin_lock_init(&b_ptr->lock);\r\nres = tipc_disc_create(b_ptr, &b_ptr->bcast_addr, disc_domain);\r\nif (res) {\r\nbearer_disable(b_ptr);\r\npr_warn("Bearer <%s> rejected, discovery object creation failed\n",\r\nname);\r\ngoto exit;\r\n}\r\npr_info("Enabled bearer <%s>, discovery domain %s, priority %u\n",\r\nname,\r\ntipc_addr_string_fill(addr_string, disc_domain), priority);\r\nexit:\r\nwrite_unlock_bh(&tipc_net_lock);\r\nreturn res;\r\n}\r\nint tipc_block_bearer(const char *name)\r\n{\r\nstruct tipc_bearer *b_ptr = NULL;\r\nstruct tipc_link *l_ptr;\r\nstruct tipc_link *temp_l_ptr;\r\nread_lock_bh(&tipc_net_lock);\r\nb_ptr = tipc_bearer_find(name);\r\nif (!b_ptr) {\r\npr_warn("Attempt to block unknown bearer <%s>\n", name);\r\nread_unlock_bh(&tipc_net_lock);\r\nreturn -EINVAL;\r\n}\r\npr_info("Blocking bearer <%s>\n", name);\r\nspin_lock_bh(&b_ptr->lock);\r\nb_ptr->blocked = 1;\r\nlist_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {\r\nstruct tipc_node *n_ptr = l_ptr->owner;\r\nspin_lock_bh(&n_ptr->lock);\r\ntipc_link_reset(l_ptr);\r\nspin_unlock_bh(&n_ptr->lock);\r\n}\r\nspin_unlock_bh(&b_ptr->lock);\r\nread_unlock_bh(&tipc_net_lock);\r\nreturn 0;\r\n}\r\nstatic void bearer_disable(struct tipc_bearer *b_ptr)\r\n{\r\nstruct tipc_link *l_ptr;\r\nstruct tipc_link *temp_l_ptr;\r\nstruct tipc_link_req *temp_req;\r\npr_info("Disabling bearer <%s>\n", b_ptr->name);\r\nspin_lock_bh(&b_ptr->lock);\r\nb_ptr->blocked = 1;\r\nb_ptr->media->disable_bearer(b_ptr);\r\nlist_for_each_entry_safe(l_ptr, temp_l_ptr, &b_ptr->links, link_list) {\r\ntipc_link_delete(l_ptr);\r\n}\r\ntemp_req = b_ptr->link_req;\r\nb_ptr->link_req = NULL;\r\nspin_unlock_bh(&b_ptr->lock);\r\nif (temp_req)\r\ntipc_disc_delete(temp_req);\r\nmemset(b_ptr, 0, sizeof(struct tipc_bearer));\r\n}\r\nint tipc_disable_bearer(const char *name)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nint res;\r\nwrite_lock_bh(&tipc_net_lock);\r\nb_ptr = tipc_bearer_find(name);\r\nif (b_ptr == NULL) {\r\npr_warn("Attempt to disable unknown bearer <%s>\n", name);\r\nres = -EINVAL;\r\n} else {\r\nbearer_disable(b_ptr);\r\nres = 0;\r\n}\r\nwrite_unlock_bh(&tipc_net_lock);\r\nreturn res;\r\n}\r\nvoid tipc_bearer_stop(void)\r\n{\r\nu32 i;\r\nfor (i = 0; i < MAX_BEARERS; i++) {\r\nif (tipc_bearers[i].active)\r\nbearer_disable(&tipc_bearers[i]);\r\n}\r\nmedia_count = 0;\r\n}
