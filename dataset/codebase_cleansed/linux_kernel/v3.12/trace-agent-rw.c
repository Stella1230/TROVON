void *rw_thread_info_new(void)\r\n{\r\nstruct rw_thread_info *rw_ti;\r\nrw_ti = zalloc(sizeof(struct rw_thread_info));\r\nif (rw_ti == NULL) {\r\npr_err("rw_thread_info zalloc error\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nrw_ti->cpu_num = -1;\r\nrw_ti->in_fd = -1;\r\nrw_ti->out_fd = -1;\r\nrw_ti->read_pipe = -1;\r\nrw_ti->write_pipe = -1;\r\nrw_ti->pipe_size = PIPE_INIT;\r\nreturn rw_ti;\r\n}\r\nvoid *rw_thread_init(int cpu, const char *in_path, const char *out_path,\r\nbool stdout_flag, unsigned long pipe_size,\r\nstruct rw_thread_info *rw_ti)\r\n{\r\nint data_pipe[2];\r\nrw_ti->cpu_num = cpu;\r\nrw_ti->in_fd = open(in_path, O_RDONLY);\r\nif (rw_ti->in_fd == -1) {\r\npr_err("Could not open in_fd (CPU:%d)\n", cpu);\r\ngoto error;\r\n}\r\nif (!stdout_flag) {\r\nrw_ti->out_fd = open(out_path, O_WRONLY);\r\nif (rw_ti->out_fd == -1) {\r\npr_err("Could not open out_fd (CPU:%d)\n", cpu);\r\ngoto error;\r\n}\r\n} else\r\nrw_ti->out_fd = STDOUT_FILENO;\r\nif (pipe2(data_pipe, O_NONBLOCK) < 0) {\r\npr_err("Could not create pipe in rw-thread(%d)\n", cpu);\r\ngoto error;\r\n}\r\nif (fcntl(*data_pipe, F_SETPIPE_SZ, pipe_size) < 0) {\r\npr_err("Could not change pipe size in rw-thread(%d)\n", cpu);\r\ngoto error;\r\n}\r\nrw_ti->read_pipe = data_pipe[1];\r\nrw_ti->write_pipe = data_pipe[0];\r\nrw_ti->pipe_size = pipe_size;\r\nreturn NULL;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void bind_cpu(int cpu_num)\r\n{\r\ncpu_set_t mask;\r\nCPU_ZERO(&mask);\r\nCPU_SET(cpu_num, &mask);\r\nif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\r\npr_err("Could not set CPU#%d affinity\n", (int)cpu_num);\r\n}\r\nstatic void *rw_thread_main(void *thread_info)\r\n{\r\nssize_t rlen, wlen;\r\nssize_t ret;\r\nstruct rw_thread_info *ts = (struct rw_thread_info *)thread_info;\r\nbind_cpu(ts->cpu_num);\r\nwhile (1) {\r\nif (!global_run_operation) {\r\npthread_mutex_lock(&mutex_notify);\r\npthread_cond_wait(&cond_wakeup, &mutex_notify);\r\npthread_mutex_unlock(&mutex_notify);\r\n}\r\nif (global_sig_receive)\r\nbreak;\r\nrlen = splice(ts->in_fd, NULL, ts->read_pipe, NULL,\r\nts->pipe_size, SPLICE_F_MOVE | SPLICE_F_MORE);\r\nif (rlen < 0) {\r\npr_err("Splice_read in rw-thread(%d)\n", ts->cpu_num);\r\ngoto error;\r\n} else if (rlen == 0) {\r\nusleep(READ_WAIT_USEC);\r\npr_debug("Read retry(cpu:%d)\n", ts->cpu_num);\r\ncontinue;\r\n}\r\nwlen = 0;\r\ndo {\r\nret = splice(ts->write_pipe, NULL, ts->out_fd, NULL,\r\nrlen - wlen,\r\nSPLICE_F_MOVE | SPLICE_F_MORE);\r\nif (ret < 0) {\r\npr_err("Splice_write in rw-thread(%d)\n",\r\nts->cpu_num);\r\ngoto error;\r\n} else if (ret == 0)\r\nsleep(1);\r\nwlen += ret;\r\n} while (wlen < rlen);\r\n}\r\nreturn NULL;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\npthread_t rw_thread_run(struct rw_thread_info *rw_ti)\r\n{\r\nint ret;\r\npthread_t rw_thread_per_cpu;\r\nret = pthread_create(&rw_thread_per_cpu, NULL, rw_thread_main, rw_ti);\r\nif (ret != 0) {\r\npr_err("Could not create a rw thread(%d)\n", rw_ti->cpu_num);\r\nexit(EXIT_FAILURE);\r\n}\r\nreturn rw_thread_per_cpu;\r\n}
