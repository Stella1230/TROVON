static void mv_completion_timer_callback(unsigned long unused)\r\n{\r\nint active = readl(cpg->reg + SEC_ACCEL_CMD) & SEC_CMD_EN_SEC_ACCL0;\r\nprintk(KERN_ERR MV_CESA\r\n"completion timer expired (CESA %sactive), cleaning up.\n",\r\nactive ? "" : "in");\r\ndel_timer(&cpg->completion_timer);\r\nwritel(SEC_CMD_DISABLE_SEC, cpg->reg + SEC_ACCEL_CMD);\r\nwhile(readl(cpg->reg + SEC_ACCEL_CMD) & SEC_CMD_DISABLE_SEC)\r\nprintk(KERN_INFO MV_CESA "%s: waiting for engine finishing\n", __func__);\r\ncpg->eng_st = ENGINE_W_DEQUEUE;\r\nwake_up_process(cpg->queue_th);\r\n}\r\nstatic void mv_setup_timer(void)\r\n{\r\nsetup_timer(&cpg->completion_timer, &mv_completion_timer_callback, 0);\r\nmod_timer(&cpg->completion_timer,\r\njiffies + msecs_to_jiffies(MV_CESA_EXPIRE));\r\n}\r\nstatic void compute_aes_dec_key(struct mv_ctx *ctx)\r\n{\r\nstruct crypto_aes_ctx gen_aes_key;\r\nint key_pos;\r\nif (!ctx->need_calc_aes_dkey)\r\nreturn;\r\ncrypto_aes_expand_key(&gen_aes_key, ctx->aes_enc_key, ctx->key_len);\r\nkey_pos = ctx->key_len + 24;\r\nmemcpy(ctx->aes_dec_key, &gen_aes_key.key_enc[key_pos], 4 * 4);\r\nswitch (ctx->key_len) {\r\ncase AES_KEYSIZE_256:\r\nkey_pos -= 2;\r\ncase AES_KEYSIZE_192:\r\nkey_pos -= 2;\r\nmemcpy(&ctx->aes_dec_key[4], &gen_aes_key.key_enc[key_pos],\r\n4 * 4);\r\nbreak;\r\n}\r\nctx->need_calc_aes_dkey = 0;\r\n}\r\nstatic int mv_setkey_aes(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct mv_ctx *ctx = crypto_tfm_ctx(tfm);\r\nswitch (len) {\r\ncase AES_KEYSIZE_128:\r\ncase AES_KEYSIZE_192:\r\ncase AES_KEYSIZE_256:\r\nbreak;\r\ndefault:\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nctx->key_len = len;\r\nctx->need_calc_aes_dkey = 1;\r\nmemcpy(ctx->aes_enc_key, key, AES_KEY_LEN);\r\nreturn 0;\r\n}\r\nstatic void copy_src_to_buf(struct req_progress *p, char *dbuf, int len)\r\n{\r\nint ret;\r\nvoid *sbuf;\r\nint copy_len;\r\nwhile (len) {\r\nif (!p->sg_src_left) {\r\nret = sg_miter_next(&p->src_sg_it);\r\nBUG_ON(!ret);\r\np->sg_src_left = p->src_sg_it.length;\r\np->src_start = 0;\r\n}\r\nsbuf = p->src_sg_it.addr + p->src_start;\r\ncopy_len = min(p->sg_src_left, len);\r\nmemcpy(dbuf, sbuf, copy_len);\r\np->src_start += copy_len;\r\np->sg_src_left -= copy_len;\r\nlen -= copy_len;\r\ndbuf += copy_len;\r\n}\r\n}\r\nstatic void setup_data_in(void)\r\n{\r\nstruct req_progress *p = &cpg->p;\r\nint data_in_sram =\r\nmin(p->hw_nbytes - p->hw_processed_bytes, cpg->max_req_size);\r\ncopy_src_to_buf(p, cpg->sram + SRAM_DATA_IN_START + p->crypt_len,\r\ndata_in_sram - p->crypt_len);\r\np->crypt_len = data_in_sram;\r\n}\r\nstatic void mv_process_current_q(int first_block)\r\n{\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(cpg->cur_req);\r\nstruct mv_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_req_ctx *req_ctx = ablkcipher_request_ctx(req);\r\nstruct sec_accel_config op;\r\nswitch (req_ctx->op) {\r\ncase COP_AES_ECB:\r\nop.config = CFG_OP_CRYPT_ONLY | CFG_ENCM_AES | CFG_ENC_MODE_ECB;\r\nbreak;\r\ncase COP_AES_CBC:\r\ndefault:\r\nop.config = CFG_OP_CRYPT_ONLY | CFG_ENCM_AES | CFG_ENC_MODE_CBC;\r\nop.enc_iv = ENC_IV_POINT(SRAM_DATA_IV) |\r\nENC_IV_BUF_POINT(SRAM_DATA_IV_BUF);\r\nif (first_block)\r\nmemcpy(cpg->sram + SRAM_DATA_IV, req->info, 16);\r\nbreak;\r\n}\r\nif (req_ctx->decrypt) {\r\nop.config |= CFG_DIR_DEC;\r\nmemcpy(cpg->sram + SRAM_DATA_KEY_P, ctx->aes_dec_key,\r\nAES_KEY_LEN);\r\n} else {\r\nop.config |= CFG_DIR_ENC;\r\nmemcpy(cpg->sram + SRAM_DATA_KEY_P, ctx->aes_enc_key,\r\nAES_KEY_LEN);\r\n}\r\nswitch (ctx->key_len) {\r\ncase AES_KEYSIZE_128:\r\nop.config |= CFG_AES_LEN_128;\r\nbreak;\r\ncase AES_KEYSIZE_192:\r\nop.config |= CFG_AES_LEN_192;\r\nbreak;\r\ncase AES_KEYSIZE_256:\r\nop.config |= CFG_AES_LEN_256;\r\nbreak;\r\n}\r\nop.enc_p = ENC_P_SRC(SRAM_DATA_IN_START) |\r\nENC_P_DST(SRAM_DATA_OUT_START);\r\nop.enc_key_p = SRAM_DATA_KEY_P;\r\nsetup_data_in();\r\nop.enc_len = cpg->p.crypt_len;\r\nmemcpy(cpg->sram + SRAM_CONFIG, &op,\r\nsizeof(struct sec_accel_config));\r\nmv_setup_timer();\r\nwritel(SEC_CMD_EN_SEC_ACCL0, cpg->reg + SEC_ACCEL_CMD);\r\n}\r\nstatic void mv_crypto_algo_completion(void)\r\n{\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(cpg->cur_req);\r\nstruct mv_req_ctx *req_ctx = ablkcipher_request_ctx(req);\r\nsg_miter_stop(&cpg->p.src_sg_it);\r\nsg_miter_stop(&cpg->p.dst_sg_it);\r\nif (req_ctx->op != COP_AES_CBC)\r\nreturn ;\r\nmemcpy(req->info, cpg->sram + SRAM_DATA_IV_BUF, 16);\r\n}\r\nstatic void mv_process_hash_current(int first_block)\r\n{\r\nstruct ahash_request *req = ahash_request_cast(cpg->cur_req);\r\nconst struct mv_tfm_hash_ctx *tfm_ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_req_hash_ctx *req_ctx = ahash_request_ctx(req);\r\nstruct req_progress *p = &cpg->p;\r\nstruct sec_accel_config op = { 0 };\r\nint is_last;\r\nswitch (req_ctx->op) {\r\ncase COP_SHA1:\r\ndefault:\r\nop.config = CFG_OP_MAC_ONLY | CFG_MACM_SHA1;\r\nbreak;\r\ncase COP_HMAC_SHA1:\r\nop.config = CFG_OP_MAC_ONLY | CFG_MACM_HMAC_SHA1;\r\nmemcpy(cpg->sram + SRAM_HMAC_IV_IN,\r\ntfm_ctx->ivs, sizeof(tfm_ctx->ivs));\r\nbreak;\r\n}\r\nop.mac_src_p =\r\nMAC_SRC_DATA_P(SRAM_DATA_IN_START) | MAC_SRC_TOTAL_LEN((u32)\r\nreq_ctx->\r\ncount);\r\nsetup_data_in();\r\nop.mac_digest =\r\nMAC_DIGEST_P(SRAM_DIGEST_BUF) | MAC_FRAG_LEN(p->crypt_len);\r\nop.mac_iv =\r\nMAC_INNER_IV_P(SRAM_HMAC_IV_IN) |\r\nMAC_OUTER_IV_P(SRAM_HMAC_IV_OUT);\r\nis_last = req_ctx->last_chunk\r\n&& (p->hw_processed_bytes + p->crypt_len >= p->hw_nbytes)\r\n&& (req_ctx->count <= MAX_HW_HASH_SIZE);\r\nif (req_ctx->first_hash) {\r\nif (is_last)\r\nop.config |= CFG_NOT_FRAG;\r\nelse\r\nop.config |= CFG_FIRST_FRAG;\r\nreq_ctx->first_hash = 0;\r\n} else {\r\nif (is_last)\r\nop.config |= CFG_LAST_FRAG;\r\nelse\r\nop.config |= CFG_MID_FRAG;\r\nif (first_block) {\r\nwritel(req_ctx->state[0], cpg->reg + DIGEST_INITIAL_VAL_A);\r\nwritel(req_ctx->state[1], cpg->reg + DIGEST_INITIAL_VAL_B);\r\nwritel(req_ctx->state[2], cpg->reg + DIGEST_INITIAL_VAL_C);\r\nwritel(req_ctx->state[3], cpg->reg + DIGEST_INITIAL_VAL_D);\r\nwritel(req_ctx->state[4], cpg->reg + DIGEST_INITIAL_VAL_E);\r\n}\r\n}\r\nmemcpy(cpg->sram + SRAM_CONFIG, &op, sizeof(struct sec_accel_config));\r\nmv_setup_timer();\r\nwritel(SEC_CMD_EN_SEC_ACCL0, cpg->reg + SEC_ACCEL_CMD);\r\n}\r\nstatic inline int mv_hash_import_sha1_ctx(const struct mv_req_hash_ctx *ctx,\r\nstruct shash_desc *desc)\r\n{\r\nint i;\r\nstruct sha1_state shash_state;\r\nshash_state.count = ctx->count + ctx->count_add;\r\nfor (i = 0; i < 5; i++)\r\nshash_state.state[i] = ctx->state[i];\r\nmemcpy(shash_state.buffer, ctx->buffer, sizeof(shash_state.buffer));\r\nreturn crypto_shash_import(desc, &shash_state);\r\n}\r\nstatic int mv_hash_final_fallback(struct ahash_request *req)\r\n{\r\nconst struct mv_tfm_hash_ctx *tfm_ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_req_hash_ctx *req_ctx = ahash_request_ctx(req);\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(tfm_ctx->fallback)];\r\n} desc;\r\nint rc;\r\ndesc.shash.tfm = tfm_ctx->fallback;\r\ndesc.shash.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nif (unlikely(req_ctx->first_hash)) {\r\ncrypto_shash_init(&desc.shash);\r\ncrypto_shash_update(&desc.shash, req_ctx->buffer,\r\nreq_ctx->extra_bytes);\r\n} else {\r\nrc = mv_hash_import_sha1_ctx(req_ctx, &desc.shash);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = crypto_shash_final(&desc.shash, req->result);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void mv_save_digest_state(struct mv_req_hash_ctx *ctx)\r\n{\r\nctx->state[0] = readl(cpg->reg + DIGEST_INITIAL_VAL_A);\r\nctx->state[1] = readl(cpg->reg + DIGEST_INITIAL_VAL_B);\r\nctx->state[2] = readl(cpg->reg + DIGEST_INITIAL_VAL_C);\r\nctx->state[3] = readl(cpg->reg + DIGEST_INITIAL_VAL_D);\r\nctx->state[4] = readl(cpg->reg + DIGEST_INITIAL_VAL_E);\r\n}\r\nstatic void mv_hash_algo_completion(void)\r\n{\r\nstruct ahash_request *req = ahash_request_cast(cpg->cur_req);\r\nstruct mv_req_hash_ctx *ctx = ahash_request_ctx(req);\r\nif (ctx->extra_bytes)\r\ncopy_src_to_buf(&cpg->p, ctx->buffer, ctx->extra_bytes);\r\nsg_miter_stop(&cpg->p.src_sg_it);\r\nif (likely(ctx->last_chunk)) {\r\nif (likely(ctx->count <= MAX_HW_HASH_SIZE)) {\r\nmemcpy(req->result, cpg->sram + SRAM_DIGEST_BUF,\r\ncrypto_ahash_digestsize(crypto_ahash_reqtfm\r\n(req)));\r\n} else {\r\nmv_save_digest_state(ctx);\r\nmv_hash_final_fallback(req);\r\n}\r\n} else {\r\nmv_save_digest_state(ctx);\r\n}\r\n}\r\nstatic void dequeue_complete_req(void)\r\n{\r\nstruct crypto_async_request *req = cpg->cur_req;\r\nvoid *buf;\r\nint ret;\r\ncpg->p.hw_processed_bytes += cpg->p.crypt_len;\r\nif (cpg->p.copy_back) {\r\nint need_copy_len = cpg->p.crypt_len;\r\nint sram_offset = 0;\r\ndo {\r\nint dst_copy;\r\nif (!cpg->p.sg_dst_left) {\r\nret = sg_miter_next(&cpg->p.dst_sg_it);\r\nBUG_ON(!ret);\r\ncpg->p.sg_dst_left = cpg->p.dst_sg_it.length;\r\ncpg->p.dst_start = 0;\r\n}\r\nbuf = cpg->p.dst_sg_it.addr;\r\nbuf += cpg->p.dst_start;\r\ndst_copy = min(need_copy_len, cpg->p.sg_dst_left);\r\nmemcpy(buf,\r\ncpg->sram + SRAM_DATA_OUT_START + sram_offset,\r\ndst_copy);\r\nsram_offset += dst_copy;\r\ncpg->p.sg_dst_left -= dst_copy;\r\nneed_copy_len -= dst_copy;\r\ncpg->p.dst_start += dst_copy;\r\n} while (need_copy_len > 0);\r\n}\r\ncpg->p.crypt_len = 0;\r\nBUG_ON(cpg->eng_st != ENGINE_W_DEQUEUE);\r\nif (cpg->p.hw_processed_bytes < cpg->p.hw_nbytes) {\r\ncpg->eng_st = ENGINE_BUSY;\r\ncpg->p.process(0);\r\n} else {\r\ncpg->p.complete();\r\ncpg->eng_st = ENGINE_IDLE;\r\nlocal_bh_disable();\r\nreq->complete(req, 0);\r\nlocal_bh_enable();\r\n}\r\n}\r\nstatic int count_sgs(struct scatterlist *sl, unsigned int total_bytes)\r\n{\r\nint i = 0;\r\nsize_t cur_len;\r\nwhile (sl) {\r\ncur_len = sl[i].length;\r\n++i;\r\nif (total_bytes > cur_len)\r\ntotal_bytes -= cur_len;\r\nelse\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic void mv_start_new_crypt_req(struct ablkcipher_request *req)\r\n{\r\nstruct req_progress *p = &cpg->p;\r\nint num_sgs;\r\ncpg->cur_req = &req->base;\r\nmemset(p, 0, sizeof(struct req_progress));\r\np->hw_nbytes = req->nbytes;\r\np->complete = mv_crypto_algo_completion;\r\np->process = mv_process_current_q;\r\np->copy_back = 1;\r\nnum_sgs = count_sgs(req->src, req->nbytes);\r\nsg_miter_start(&p->src_sg_it, req->src, num_sgs, SG_MITER_FROM_SG);\r\nnum_sgs = count_sgs(req->dst, req->nbytes);\r\nsg_miter_start(&p->dst_sg_it, req->dst, num_sgs, SG_MITER_TO_SG);\r\nmv_process_current_q(1);\r\n}\r\nstatic void mv_start_new_hash_req(struct ahash_request *req)\r\n{\r\nstruct req_progress *p = &cpg->p;\r\nstruct mv_req_hash_ctx *ctx = ahash_request_ctx(req);\r\nint num_sgs, hw_bytes, old_extra_bytes, rc;\r\ncpg->cur_req = &req->base;\r\nmemset(p, 0, sizeof(struct req_progress));\r\nhw_bytes = req->nbytes + ctx->extra_bytes;\r\nold_extra_bytes = ctx->extra_bytes;\r\nctx->extra_bytes = hw_bytes % SHA1_BLOCK_SIZE;\r\nif (ctx->extra_bytes != 0\r\n&& (!ctx->last_chunk || ctx->count > MAX_HW_HASH_SIZE))\r\nhw_bytes -= ctx->extra_bytes;\r\nelse\r\nctx->extra_bytes = 0;\r\nnum_sgs = count_sgs(req->src, req->nbytes);\r\nsg_miter_start(&p->src_sg_it, req->src, num_sgs, SG_MITER_FROM_SG);\r\nif (hw_bytes) {\r\np->hw_nbytes = hw_bytes;\r\np->complete = mv_hash_algo_completion;\r\np->process = mv_process_hash_current;\r\nif (unlikely(old_extra_bytes)) {\r\nmemcpy(cpg->sram + SRAM_DATA_IN_START, ctx->buffer,\r\nold_extra_bytes);\r\np->crypt_len = old_extra_bytes;\r\n}\r\nmv_process_hash_current(1);\r\n} else {\r\ncopy_src_to_buf(p, ctx->buffer + old_extra_bytes,\r\nctx->extra_bytes - old_extra_bytes);\r\nsg_miter_stop(&p->src_sg_it);\r\nif (ctx->last_chunk)\r\nrc = mv_hash_final_fallback(req);\r\nelse\r\nrc = 0;\r\ncpg->eng_st = ENGINE_IDLE;\r\nlocal_bh_disable();\r\nreq->base.complete(&req->base, rc);\r\nlocal_bh_enable();\r\n}\r\n}\r\nstatic int queue_manag(void *data)\r\n{\r\ncpg->eng_st = ENGINE_IDLE;\r\ndo {\r\nstruct crypto_async_request *async_req = NULL;\r\nstruct crypto_async_request *backlog;\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nif (cpg->eng_st == ENGINE_W_DEQUEUE)\r\ndequeue_complete_req();\r\nspin_lock_irq(&cpg->lock);\r\nif (cpg->eng_st == ENGINE_IDLE) {\r\nbacklog = crypto_get_backlog(&cpg->queue);\r\nasync_req = crypto_dequeue_request(&cpg->queue);\r\nif (async_req) {\r\nBUG_ON(cpg->eng_st != ENGINE_IDLE);\r\ncpg->eng_st = ENGINE_BUSY;\r\n}\r\n}\r\nspin_unlock_irq(&cpg->lock);\r\nif (backlog) {\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nbacklog = NULL;\r\n}\r\nif (async_req) {\r\nif (async_req->tfm->__crt_alg->cra_type !=\r\n&crypto_ahash_type) {\r\nstruct ablkcipher_request *req =\r\nablkcipher_request_cast(async_req);\r\nmv_start_new_crypt_req(req);\r\n} else {\r\nstruct ahash_request *req =\r\nahash_request_cast(async_req);\r\nmv_start_new_hash_req(req);\r\n}\r\nasync_req = NULL;\r\n}\r\nschedule();\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nstatic int mv_handle_req(struct crypto_async_request *req)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cpg->lock, flags);\r\nret = crypto_enqueue_request(&cpg->queue, req);\r\nspin_unlock_irqrestore(&cpg->lock, flags);\r\nwake_up_process(cpg->queue_th);\r\nreturn ret;\r\n}\r\nstatic int mv_enc_aes_ecb(struct ablkcipher_request *req)\r\n{\r\nstruct mv_req_ctx *req_ctx = ablkcipher_request_ctx(req);\r\nreq_ctx->op = COP_AES_ECB;\r\nreq_ctx->decrypt = 0;\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_dec_aes_ecb(struct ablkcipher_request *req)\r\n{\r\nstruct mv_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_req_ctx *req_ctx = ablkcipher_request_ctx(req);\r\nreq_ctx->op = COP_AES_ECB;\r\nreq_ctx->decrypt = 1;\r\ncompute_aes_dec_key(ctx);\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_enc_aes_cbc(struct ablkcipher_request *req)\r\n{\r\nstruct mv_req_ctx *req_ctx = ablkcipher_request_ctx(req);\r\nreq_ctx->op = COP_AES_CBC;\r\nreq_ctx->decrypt = 0;\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_dec_aes_cbc(struct ablkcipher_request *req)\r\n{\r\nstruct mv_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct mv_req_ctx *req_ctx = ablkcipher_request_ctx(req);\r\nreq_ctx->op = COP_AES_CBC;\r\nreq_ctx->decrypt = 1;\r\ncompute_aes_dec_key(ctx);\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_cra_init(struct crypto_tfm *tfm)\r\n{\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct mv_req_ctx);\r\nreturn 0;\r\n}\r\nstatic void mv_init_hash_req_ctx(struct mv_req_hash_ctx *ctx, int op,\r\nint is_last, unsigned int req_len,\r\nint count_add)\r\n{\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->op = op;\r\nctx->count = req_len;\r\nctx->first_hash = 1;\r\nctx->last_chunk = is_last;\r\nctx->count_add = count_add;\r\n}\r\nstatic void mv_update_hash_req_ctx(struct mv_req_hash_ctx *ctx, int is_last,\r\nunsigned req_len)\r\n{\r\nctx->last_chunk = is_last;\r\nctx->count += req_len;\r\n}\r\nstatic int mv_hash_init(struct ahash_request *req)\r\n{\r\nconst struct mv_tfm_hash_ctx *tfm_ctx = crypto_tfm_ctx(req->base.tfm);\r\nmv_init_hash_req_ctx(ahash_request_ctx(req), tfm_ctx->op, 0, 0,\r\ntfm_ctx->count_add);\r\nreturn 0;\r\n}\r\nstatic int mv_hash_update(struct ahash_request *req)\r\n{\r\nif (!req->nbytes)\r\nreturn 0;\r\nmv_update_hash_req_ctx(ahash_request_ctx(req), 0, req->nbytes);\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_hash_final(struct ahash_request *req)\r\n{\r\nstruct mv_req_hash_ctx *ctx = ahash_request_ctx(req);\r\nahash_request_set_crypt(req, NULL, req->result, 0);\r\nmv_update_hash_req_ctx(ctx, 1, 0);\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_hash_finup(struct ahash_request *req)\r\n{\r\nmv_update_hash_req_ctx(ahash_request_ctx(req), 1, req->nbytes);\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic int mv_hash_digest(struct ahash_request *req)\r\n{\r\nconst struct mv_tfm_hash_ctx *tfm_ctx = crypto_tfm_ctx(req->base.tfm);\r\nmv_init_hash_req_ctx(ahash_request_ctx(req), tfm_ctx->op, 1,\r\nreq->nbytes, tfm_ctx->count_add);\r\nreturn mv_handle_req(&req->base);\r\n}\r\nstatic void mv_hash_init_ivs(struct mv_tfm_hash_ctx *ctx, const void *istate,\r\nconst void *ostate)\r\n{\r\nconst struct sha1_state *isha1_state = istate, *osha1_state = ostate;\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nctx->ivs[i] = cpu_to_be32(isha1_state->state[i]);\r\nctx->ivs[i + 5] = cpu_to_be32(osha1_state->state[i]);\r\n}\r\n}\r\nstatic int mv_hash_setkey(struct crypto_ahash *tfm, const u8 * key,\r\nunsigned int keylen)\r\n{\r\nint rc;\r\nstruct mv_tfm_hash_ctx *ctx = crypto_tfm_ctx(&tfm->base);\r\nint bs, ds, ss;\r\nif (!ctx->base_hash)\r\nreturn 0;\r\nrc = crypto_shash_setkey(ctx->fallback, key, keylen);\r\nif (rc)\r\nreturn rc;\r\nbs = crypto_shash_blocksize(ctx->base_hash);\r\nds = crypto_shash_digestsize(ctx->base_hash);\r\nss = crypto_shash_statesize(ctx->base_hash);\r\n{\r\nstruct {\r\nstruct shash_desc shash;\r\nchar ctx[crypto_shash_descsize(ctx->base_hash)];\r\n} desc;\r\nunsigned int i;\r\nchar ipad[ss];\r\nchar opad[ss];\r\ndesc.shash.tfm = ctx->base_hash;\r\ndesc.shash.flags = crypto_shash_get_flags(ctx->base_hash) &\r\nCRYPTO_TFM_REQ_MAY_SLEEP;\r\nif (keylen > bs) {\r\nint err;\r\nerr =\r\ncrypto_shash_digest(&desc.shash, key, keylen, ipad);\r\nif (err)\r\nreturn err;\r\nkeylen = ds;\r\n} else\r\nmemcpy(ipad, key, keylen);\r\nmemset(ipad + keylen, 0, bs - keylen);\r\nmemcpy(opad, ipad, bs);\r\nfor (i = 0; i < bs; i++) {\r\nipad[i] ^= 0x36;\r\nopad[i] ^= 0x5c;\r\n}\r\nrc = crypto_shash_init(&desc.shash) ? :\r\ncrypto_shash_update(&desc.shash, ipad, bs) ? :\r\ncrypto_shash_export(&desc.shash, ipad) ? :\r\ncrypto_shash_init(&desc.shash) ? :\r\ncrypto_shash_update(&desc.shash, opad, bs) ? :\r\ncrypto_shash_export(&desc.shash, opad);\r\nif (rc == 0)\r\nmv_hash_init_ivs(ctx, ipad, opad);\r\nreturn rc;\r\n}\r\n}\r\nstatic int mv_cra_hash_init(struct crypto_tfm *tfm, const char *base_hash_name,\r\nenum hash_op op, int count_add)\r\n{\r\nconst char *fallback_driver_name = tfm->__crt_alg->cra_name;\r\nstruct mv_tfm_hash_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_shash *fallback_tfm = NULL;\r\nstruct crypto_shash *base_hash = NULL;\r\nint err = -ENOMEM;\r\nctx->op = op;\r\nctx->count_add = count_add;\r\nfallback_tfm = crypto_alloc_shash(fallback_driver_name, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(fallback_tfm)) {\r\nprintk(KERN_WARNING MV_CESA\r\n"Fallback driver '%s' could not be loaded!\n",\r\nfallback_driver_name);\r\nerr = PTR_ERR(fallback_tfm);\r\ngoto out;\r\n}\r\nctx->fallback = fallback_tfm;\r\nif (base_hash_name) {\r\nbase_hash = crypto_alloc_shash(base_hash_name, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(base_hash)) {\r\nprintk(KERN_WARNING MV_CESA\r\n"Base driver '%s' could not be loaded!\n",\r\nbase_hash_name);\r\nerr = PTR_ERR(base_hash);\r\ngoto err_bad_base;\r\n}\r\n}\r\nctx->base_hash = base_hash;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct mv_req_hash_ctx) +\r\ncrypto_shash_descsize(ctx->fallback));\r\nreturn 0;\r\nerr_bad_base:\r\ncrypto_free_shash(fallback_tfm);\r\nout:\r\nreturn err;\r\n}\r\nstatic void mv_cra_hash_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct mv_tfm_hash_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_shash(ctx->fallback);\r\nif (ctx->base_hash)\r\ncrypto_free_shash(ctx->base_hash);\r\n}\r\nstatic int mv_cra_hash_sha1_init(struct crypto_tfm *tfm)\r\n{\r\nreturn mv_cra_hash_init(tfm, NULL, COP_SHA1, 0);\r\n}\r\nstatic int mv_cra_hash_hmac_sha1_init(struct crypto_tfm *tfm)\r\n{\r\nreturn mv_cra_hash_init(tfm, "sha1", COP_HMAC_SHA1, SHA1_BLOCK_SIZE);\r\n}\r\nirqreturn_t crypto_int(int irq, void *priv)\r\n{\r\nu32 val;\r\nval = readl(cpg->reg + SEC_ACCEL_INT_STATUS);\r\nif (!(val & SEC_INT_ACCEL0_DONE))\r\nreturn IRQ_NONE;\r\nif (!del_timer(&cpg->completion_timer)) {\r\nprintk(KERN_WARNING MV_CESA\r\n"got an interrupt but no pending timer?\n");\r\n}\r\nval &= ~SEC_INT_ACCEL0_DONE;\r\nwritel(val, cpg->reg + FPGA_INT_STATUS);\r\nwritel(val, cpg->reg + SEC_ACCEL_INT_STATUS);\r\nBUG_ON(cpg->eng_st != ENGINE_BUSY);\r\ncpg->eng_st = ENGINE_W_DEQUEUE;\r\nwake_up_process(cpg->queue_th);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mv_probe(struct platform_device *pdev)\r\n{\r\nstruct crypto_priv *cp;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nif (cpg) {\r\nprintk(KERN_ERR MV_CESA "Second crypto dev?\n");\r\nreturn -EEXIST;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");\r\nif (!res)\r\nreturn -ENXIO;\r\ncp = kzalloc(sizeof(*cp), GFP_KERNEL);\r\nif (!cp)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cp->lock);\r\ncrypto_init_queue(&cp->queue, 50);\r\ncp->reg = ioremap(res->start, resource_size(res));\r\nif (!cp->reg) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sram");\r\nif (!res) {\r\nret = -ENXIO;\r\ngoto err_unmap_reg;\r\n}\r\ncp->sram_size = resource_size(res);\r\ncp->max_req_size = cp->sram_size - SRAM_CFG_SPACE;\r\ncp->sram = ioremap(res->start, cp->sram_size);\r\nif (!cp->sram) {\r\nret = -ENOMEM;\r\ngoto err_unmap_reg;\r\n}\r\nif (pdev->dev.of_node)\r\nirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nelse\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0 || irq == NO_IRQ) {\r\nret = irq;\r\ngoto err_unmap_sram;\r\n}\r\ncp->irq = irq;\r\nplatform_set_drvdata(pdev, cp);\r\ncpg = cp;\r\ncp->queue_th = kthread_run(queue_manag, cp, "mv_crypto");\r\nif (IS_ERR(cp->queue_th)) {\r\nret = PTR_ERR(cp->queue_th);\r\ngoto err_unmap_sram;\r\n}\r\nret = request_irq(irq, crypto_int, IRQF_DISABLED, dev_name(&pdev->dev),\r\ncp);\r\nif (ret)\r\ngoto err_thread;\r\ncp->clk = clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(cp->clk))\r\nclk_prepare_enable(cp->clk);\r\nwritel(0, cpg->reg + SEC_ACCEL_INT_STATUS);\r\nwritel(SEC_INT_ACCEL0_DONE, cpg->reg + SEC_ACCEL_INT_MASK);\r\nwritel(SEC_CFG_STOP_DIG_ERR, cpg->reg + SEC_ACCEL_CFG);\r\nwritel(SRAM_CONFIG, cpg->reg + SEC_ACCEL_DESC_P0);\r\nret = crypto_register_alg(&mv_aes_alg_ecb);\r\nif (ret) {\r\nprintk(KERN_WARNING MV_CESA\r\n"Could not register aes-ecb driver\n");\r\ngoto err_irq;\r\n}\r\nret = crypto_register_alg(&mv_aes_alg_cbc);\r\nif (ret) {\r\nprintk(KERN_WARNING MV_CESA\r\n"Could not register aes-cbc driver\n");\r\ngoto err_unreg_ecb;\r\n}\r\nret = crypto_register_ahash(&mv_sha1_alg);\r\nif (ret == 0)\r\ncpg->has_sha1 = 1;\r\nelse\r\nprintk(KERN_WARNING MV_CESA "Could not register sha1 driver\n");\r\nret = crypto_register_ahash(&mv_hmac_sha1_alg);\r\nif (ret == 0) {\r\ncpg->has_hmac_sha1 = 1;\r\n} else {\r\nprintk(KERN_WARNING MV_CESA\r\n"Could not register hmac-sha1 driver\n");\r\n}\r\nreturn 0;\r\nerr_unreg_ecb:\r\ncrypto_unregister_alg(&mv_aes_alg_ecb);\r\nerr_irq:\r\nfree_irq(irq, cp);\r\nif (!IS_ERR(cp->clk)) {\r\nclk_disable_unprepare(cp->clk);\r\nclk_put(cp->clk);\r\n}\r\nerr_thread:\r\nkthread_stop(cp->queue_th);\r\nerr_unmap_sram:\r\niounmap(cp->sram);\r\nerr_unmap_reg:\r\niounmap(cp->reg);\r\nerr:\r\nkfree(cp);\r\ncpg = NULL;\r\nreturn ret;\r\n}\r\nstatic int mv_remove(struct platform_device *pdev)\r\n{\r\nstruct crypto_priv *cp = platform_get_drvdata(pdev);\r\ncrypto_unregister_alg(&mv_aes_alg_ecb);\r\ncrypto_unregister_alg(&mv_aes_alg_cbc);\r\nif (cp->has_sha1)\r\ncrypto_unregister_ahash(&mv_sha1_alg);\r\nif (cp->has_hmac_sha1)\r\ncrypto_unregister_ahash(&mv_hmac_sha1_alg);\r\nkthread_stop(cp->queue_th);\r\nfree_irq(cp->irq, cp);\r\nmemset(cp->sram, 0, cp->sram_size);\r\niounmap(cp->sram);\r\niounmap(cp->reg);\r\nif (!IS_ERR(cp->clk)) {\r\nclk_disable_unprepare(cp->clk);\r\nclk_put(cp->clk);\r\n}\r\nkfree(cp);\r\ncpg = NULL;\r\nreturn 0;\r\n}
