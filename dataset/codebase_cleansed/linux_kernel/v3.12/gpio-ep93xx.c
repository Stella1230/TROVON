static void ep93xx_gpio_update_int_params(unsigned port)\r\n{\r\nBUG_ON(port > 2);\r\n__raw_writeb(0, EP93XX_GPIO_REG(int_en_register_offset[port]));\r\n__raw_writeb(gpio_int_type2[port],\r\nEP93XX_GPIO_REG(int_type2_register_offset[port]));\r\n__raw_writeb(gpio_int_type1[port],\r\nEP93XX_GPIO_REG(int_type1_register_offset[port]));\r\n__raw_writeb(gpio_int_unmasked[port] & gpio_int_enabled[port],\r\nEP93XX_GPIO_REG(int_en_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_int_debounce(unsigned int irq, bool enable)\r\n{\r\nint line = irq_to_gpio(irq);\r\nint port = line >> 3;\r\nint port_mask = 1 << (line & 7);\r\nif (enable)\r\ngpio_int_debounce[port] |= port_mask;\r\nelse\r\ngpio_int_debounce[port] &= ~port_mask;\r\n__raw_writeb(gpio_int_debounce[port],\r\nEP93XX_GPIO_REG(int_debounce_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_ab_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned char status;\r\nint i;\r\nstatus = __raw_readb(EP93XX_GPIO_A_INT_STATUS);\r\nfor (i = 0; i < 8; i++) {\r\nif (status & (1 << i)) {\r\nint gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_A(0)) + i;\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\n}\r\nstatus = __raw_readb(EP93XX_GPIO_B_INT_STATUS);\r\nfor (i = 0; i < 8; i++) {\r\nif (status & (1 << i)) {\r\nint gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_B(0)) + i;\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\n}\r\n}\r\nstatic void ep93xx_gpio_f_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nint port_f_idx = ((irq + 1) & 7) ^ 4;\r\nint gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_F(0)) + port_f_idx;\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\nstatic void ep93xx_gpio_irq_ack(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\nint port_mask = 1 << (line & 7);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\r\ngpio_int_type2[port] ^= port_mask;\r\nep93xx_gpio_update_int_params(port);\r\n}\r\n__raw_writeb(port_mask, EP93XX_GPIO_REG(eoi_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_irq_mask_ack(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\nint port_mask = 1 << (line & 7);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH)\r\ngpio_int_type2[port] ^= port_mask;\r\ngpio_int_unmasked[port] &= ~port_mask;\r\nep93xx_gpio_update_int_params(port);\r\n__raw_writeb(port_mask, EP93XX_GPIO_REG(eoi_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_irq_mask(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\ngpio_int_unmasked[port] &= ~(1 << (line & 7));\r\nep93xx_gpio_update_int_params(port);\r\n}\r\nstatic void ep93xx_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\ngpio_int_unmasked[port] |= 1 << (line & 7);\r\nep93xx_gpio_update_int_params(port);\r\n}\r\nstatic int ep93xx_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nconst int gpio = irq_to_gpio(d->irq);\r\nconst int port = gpio >> 3;\r\nconst int port_mask = 1 << (gpio & 7);\r\nirq_flow_handler_t handler;\r\ngpio_direction_input(gpio);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ngpio_int_type1[port] |= port_mask;\r\ngpio_int_type2[port] |= port_mask;\r\nhandler = handle_edge_irq;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ngpio_int_type1[port] |= port_mask;\r\ngpio_int_type2[port] &= ~port_mask;\r\nhandler = handle_edge_irq;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ngpio_int_type1[port] &= ~port_mask;\r\ngpio_int_type2[port] |= port_mask;\r\nhandler = handle_level_irq;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ngpio_int_type1[port] &= ~port_mask;\r\ngpio_int_type2[port] &= ~port_mask;\r\nhandler = handle_level_irq;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ngpio_int_type1[port] |= port_mask;\r\nif (gpio_get_value(gpio))\r\ngpio_int_type2[port] &= ~port_mask;\r\nelse\r\ngpio_int_type2[port] |= port_mask;\r\nhandler = handle_edge_irq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n__irq_set_handler_locked(d->irq, handler);\r\ngpio_int_enabled[port] |= port_mask;\r\nep93xx_gpio_update_int_params(port);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_gpio_init_irq(void)\r\n{\r\nint gpio_irq;\r\nfor (gpio_irq = gpio_to_irq(0);\r\ngpio_irq <= gpio_to_irq(EP93XX_GPIO_LINE_MAX_IRQ); ++gpio_irq) {\r\nirq_set_chip_and_handler(gpio_irq, &ep93xx_gpio_irq_chip,\r\nhandle_level_irq);\r\nset_irq_flags(gpio_irq, IRQF_VALID);\r\n}\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO_AB,\r\nep93xx_gpio_ab_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO0MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO1MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO2MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO3MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO4MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO5MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO6MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO7MUX,\r\nep93xx_gpio_f_irq_handler);\r\n}\r\nstatic int ep93xx_gpio_set_debounce(struct gpio_chip *chip,\r\nunsigned offset, unsigned debounce)\r\n{\r\nint gpio = chip->base + offset;\r\nint irq = gpio_to_irq(gpio);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\nep93xx_gpio_int_debounce(irq, debounce ? true : false);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\nif (gpio > EP93XX_GPIO_LINE_MAX_IRQ)\r\nreturn -EINVAL;\r\nreturn 64 + gpio;\r\n}\r\nstatic int ep93xx_gpio_add_bank(struct bgpio_chip *bgc, struct device *dev,\r\nvoid __iomem *mmio_base, struct ep93xx_gpio_bank *bank)\r\n{\r\nvoid __iomem *data = mmio_base + bank->data;\r\nvoid __iomem *dir = mmio_base + bank->dir;\r\nint err;\r\nerr = bgpio_init(bgc, dev, 1, data, NULL, NULL, dir, NULL, 0);\r\nif (err)\r\nreturn err;\r\nbgc->gc.label = bank->label;\r\nbgc->gc.base = bank->base;\r\nif (bank->has_debounce) {\r\nbgc->gc.set_debounce = ep93xx_gpio_set_debounce;\r\nbgc->gc.to_irq = ep93xx_gpio_to_irq;\r\n}\r\nreturn gpiochip_add(&bgc->gc);\r\n}\r\nstatic int ep93xx_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_gpio *ep93xx_gpio;\r\nstruct resource *res;\r\nvoid __iomem *mmio;\r\nint i;\r\nint ret;\r\nep93xx_gpio = kzalloc(sizeof(*ep93xx_gpio), GFP_KERNEL);\r\nif (!ep93xx_gpio)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENXIO;\r\ngoto exit_free;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\nret = -EBUSY;\r\ngoto exit_free;\r\n}\r\nmmio = ioremap(res->start, resource_size(res));\r\nif (!mmio) {\r\nret = -ENXIO;\r\ngoto exit_release;\r\n}\r\nep93xx_gpio->mmio_base = mmio;\r\nfor (i = 0; i < ARRAY_SIZE(ep93xx_gpio_banks); i++) {\r\nstruct bgpio_chip *bgc = &ep93xx_gpio->bgc[i];\r\nstruct ep93xx_gpio_bank *bank = &ep93xx_gpio_banks[i];\r\nif (ep93xx_gpio_add_bank(bgc, &pdev->dev, mmio, bank))\r\ndev_warn(&pdev->dev, "Unable to add gpio bank %s\n",\r\nbank->label);\r\n}\r\nep93xx_gpio_init_irq();\r\nreturn 0;\r\nexit_release:\r\nrelease_mem_region(res->start, resource_size(res));\r\nexit_free:\r\nkfree(ep93xx_gpio);\r\ndev_info(&pdev->dev, "%s failed with errno %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int __init ep93xx_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&ep93xx_gpio_driver);\r\n}
