int sb_dsp_command(sb_devc * devc, unsigned char val)\r\n{\r\nint i;\r\nunsigned long limit;\r\nlimit = jiffies + HZ / 10;\r\nfor (i = 0; i < 500000 && (limit-jiffies)>0; i++)\r\n{\r\nif ((inb(DSP_STATUS) & 0x80) == 0)\r\n{\r\noutb((val), DSP_COMMAND);\r\nreturn 1;\r\n}\r\n}\r\nprintk(KERN_WARNING "Sound Blaster: DSP command(%x) timeout.\n", val);\r\nreturn 0;\r\n}\r\nint sb_dsp_get_byte(sb_devc * devc)\r\n{\r\nint i;\r\nfor (i = 1000; i; i--)\r\n{\r\nif (inb(DSP_DATA_AVAIL) & 0x80)\r\nreturn inb(DSP_READ);\r\n}\r\nreturn 0xffff;\r\n}\r\nstatic void sb_intr (sb_devc *devc)\r\n{\r\nint status;\r\nunsigned char src = 0xff;\r\nif (devc->model == MDL_SB16)\r\n{\r\nsrc = sb_getmixer(devc, IRQ_STAT);\r\nif (src & 4)\r\nif(devc->midi_irq_cookie)\r\nuart401intr(devc->irq, devc->midi_irq_cookie);\r\nif (!(src & 3))\r\nreturn;\r\n}\r\nif (devc->intr_active && (!devc->fullduplex || (src & 0x01)))\r\n{\r\nswitch (devc->irq_mode)\r\n{\r\ncase IMODE_OUTPUT:\r\nDMAbuf_outputintr(devc->dev, 1);\r\nbreak;\r\ncase IMODE_INPUT:\r\nDMAbuf_inputintr(devc->dev);\r\nbreak;\r\ncase IMODE_INIT:\r\nbreak;\r\ncase IMODE_MIDI:\r\nsb_midi_interrupt(devc);\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n}\r\nelse if (devc->intr_active_16 && (src & 0x02))\r\n{\r\nswitch (devc->irq_mode_16)\r\n{\r\ncase IMODE_OUTPUT:\r\nDMAbuf_outputintr(devc->dev, 1);\r\nbreak;\r\ncase IMODE_INPUT:\r\nDMAbuf_inputintr(devc->dev);\r\nbreak;\r\ncase IMODE_INIT:\r\nbreak;\r\ndefault:\r\n;\r\n}\r\n}\r\nif (src & 0x01)\r\nstatus = inb(DSP_DATA_AVAIL);\r\nif (devc->model == MDL_SB16 && src & 0x02)\r\nstatus = inb(DSP_DATA_AVL16);\r\n}\r\nstatic void pci_intr(sb_devc *devc)\r\n{\r\nint src = inb(devc->pcibase+0x1A);\r\nsrc&=3;\r\nif(src)\r\nsb_intr(devc);\r\n}\r\nstatic irqreturn_t sbintr(int irq, void *dev_id)\r\n{\r\nsb_devc *devc = dev_id;\r\ndevc->irq_ok = 1;\r\nswitch (devc->model) {\r\ncase MDL_ESSPCI:\r\npci_intr (devc);\r\nbreak;\r\ncase MDL_ESS:\r\ness_intr (devc);\r\nbreak;\r\ndefault:\r\nsb_intr (devc);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint sb_dsp_reset(sb_devc * devc)\r\n{\r\nint loopc;\r\nDEB(printk("Entered sb_dsp_reset()\n"));\r\nif (devc->model == MDL_ESS) return ess_dsp_reset (devc);\r\noutb(1, DSP_RESET);\r\nudelay(10);\r\noutb(0, DSP_RESET);\r\nudelay(30);\r\nfor (loopc = 0; loopc < 1000 && !(inb(DSP_DATA_AVAIL) & 0x80); loopc++);\r\nif (inb(DSP_READ) != 0xAA)\r\n{\r\nDDB(printk("sb: No response to RESET\n"));\r\nreturn 0;\r\n}\r\nDEB(printk("sb_dsp_reset() OK\n"));\r\nreturn 1;\r\n}\r\nstatic void dsp_get_vers(sb_devc * devc)\r\n{\r\nint i;\r\nunsigned long flags;\r\nDDB(printk("Entered dsp_get_vers()\n"));\r\nspin_lock_irqsave(&devc->lock, flags);\r\ndevc->major = devc->minor = 0;\r\nsb_dsp_command(devc, 0xe1);\r\nfor (i = 100000; i; i--)\r\n{\r\nif (inb(DSP_DATA_AVAIL) & 0x80)\r\n{\r\nif (devc->major == 0)\r\ndevc->major = inb(DSP_READ);\r\nelse\r\n{\r\ndevc->minor = inb(DSP_READ);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nDDB(printk("DSP version %d.%02d\n", devc->major, devc->minor));\r\n}\r\nstatic int sb16_set_dma_hw(sb_devc * devc)\r\n{\r\nint bits;\r\nif (devc->dma8 != 0 && devc->dma8 != 1 && devc->dma8 != 3)\r\n{\r\nprintk(KERN_ERR "SB16: Invalid 8 bit DMA (%d)\n", devc->dma8);\r\nreturn 0;\r\n}\r\nbits = (1 << devc->dma8);\r\nif (devc->dma16 >= 5 && devc->dma16 <= 7)\r\nbits |= (1 << devc->dma16);\r\nsb_setmixer(devc, DMA_NR, bits);\r\nreturn 1;\r\n}\r\nstatic void sb16_set_mpu_port(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nunsigned char bits = sb_getmixer(devc, 0x84) & ~0x06;\r\nswitch (hw_config->io_base)\r\n{\r\ncase 0x300:\r\nsb_setmixer(devc, 0x84, bits | 0x04);\r\nbreak;\r\ncase 0x330:\r\nsb_setmixer(devc, 0x84, bits | 0x00);\r\nbreak;\r\ndefault:\r\nsb_setmixer(devc, 0x84, bits | 0x02);\r\nprintk(KERN_ERR "SB16: Invalid MIDI I/O port %x\n", hw_config->io_base);\r\n}\r\n}\r\nstatic int sb16_set_irq_hw(sb_devc * devc, int level)\r\n{\r\nint ival;\r\nswitch (level)\r\n{\r\ncase 5:\r\nival = 2;\r\nbreak;\r\ncase 7:\r\nival = 4;\r\nbreak;\r\ncase 9:\r\nival = 1;\r\nbreak;\r\ncase 10:\r\nival = 8;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "SB16: Invalid IRQ%d\n", level);\r\nreturn 0;\r\n}\r\nsb_setmixer(devc, IRQ_NR, ival);\r\nreturn 1;\r\n}\r\nstatic void relocate_Jazz16(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nunsigned char bits = 0;\r\nunsigned long flags;\r\nif (jazz16_base != 0 && jazz16_base != hw_config->io_base)\r\nreturn;\r\nswitch (hw_config->io_base)\r\n{\r\ncase 0x220:\r\nbits = 1;\r\nbreak;\r\ncase 0x240:\r\nbits = 2;\r\nbreak;\r\ncase 0x260:\r\nbits = 3;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nbits = jazz16_bits = bits << 5;\r\njazz16_base = hw_config->io_base;\r\nspin_lock_irqsave(&jazz16_lock, flags);\r\noutb((0xAF), 0x201);\r\noutb((0x50), 0x201);\r\noutb((bits), 0x201);\r\nspin_unlock_irqrestore(&jazz16_lock, flags);\r\n}\r\nstatic int init_Jazz16(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nchar name[100];\r\nif (!sb_dsp_command(devc, 0xfa))\r\nreturn 0;\r\nif (sb_dsp_get_byte(devc) != 0x12)\r\nreturn 0;\r\nif (hw_config->irq < 1 || hw_config->irq > 15 || jazz_irq_bits[hw_config->irq] == 0)\r\n{\r\nprintk(KERN_ERR "Jazz16: Invalid interrupt (IRQ%d)\n", hw_config->irq);\r\nreturn 0;\r\n}\r\nif (hw_config->dma < 0 || hw_config->dma > 3 || jazz_dma_bits[hw_config->dma] == 0)\r\n{\r\nprintk(KERN_ERR "Jazz16: Invalid 8 bit DMA (DMA%d)\n", hw_config->dma);\r\nreturn 0;\r\n}\r\nif (hw_config->dma2 < 0)\r\n{\r\nprintk(KERN_ERR "Jazz16: No 16 bit DMA channel defined\n");\r\nreturn 0;\r\n}\r\nif (hw_config->dma2 < 5 || hw_config->dma2 > 7 || jazz_dma_bits[hw_config->dma2] == 0)\r\n{\r\nprintk(KERN_ERR "Jazz16: Invalid 16 bit DMA (DMA%d)\n", hw_config->dma2);\r\nreturn 0;\r\n}\r\ndevc->dma16 = hw_config->dma2;\r\nif (!sb_dsp_command(devc, 0xfb))\r\nreturn 0;\r\nif (!sb_dsp_command(devc, jazz_dma_bits[hw_config->dma] |\r\n(jazz_dma_bits[hw_config->dma2] << 4)))\r\nreturn 0;\r\nif (!sb_dsp_command(devc, jazz_irq_bits[hw_config->irq]))\r\nreturn 0;\r\ndevc->model = MDL_JAZZ;\r\nstrcpy(name, "Jazz16");\r\nhw_config->name = "Jazz16";\r\ndevc->caps |= SB_NO_MIDI;\r\nreturn 1;\r\n}\r\nstatic void relocate_ess1688(sb_devc * devc)\r\n{\r\nunsigned char bits;\r\nswitch (devc->base)\r\n{\r\ncase 0x220:\r\nbits = 0x04;\r\nbreak;\r\ncase 0x230:\r\nbits = 0x05;\r\nbreak;\r\ncase 0x240:\r\nbits = 0x06;\r\nbreak;\r\ncase 0x250:\r\nbits = 0x07;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nDDB(printk("Doing ESS1688 address selection\n"));\r\ninb(0x229);\r\ninb(0x229);\r\ninb(0x229);\r\ninb(0x22b);\r\ninb(0x229);\r\ninb(0x22b);\r\ninb(0x229);\r\ninb(0x229);\r\ninb(0x22b);\r\ninb(0x229);\r\ninb(devc->base);\r\nif (sb_dsp_reset(devc))\r\nreturn;\r\n#if 0\r\noutb((0x00), 0xfb);\r\noutb((0x00), 0xe0);\r\noutb((bits), 0xe1);\r\noutb((0x00), 0xf9);\r\n#endif\r\n}\r\nint sb_dsp_detect(struct address_info *hw_config, int pci, int pciio, struct sb_module_options *sbmo)\r\n{\r\nsb_devc sb_info;\r\nsb_devc *devc = &sb_info;\r\nmemset((char *) &sb_info, 0, sizeof(sb_info));\r\nif(sbmo) memcpy(&devc->sbmo, sbmo, sizeof(struct sb_module_options));\r\nsb_info.my_mididev = -1;\r\nsb_info.my_mixerdev = -1;\r\nsb_info.dev = -1;\r\nDDB(printk("sb_dsp_detect(%x) entered\n", hw_config->io_base));\r\nspin_lock_init(&devc->lock);\r\ndevc->type = hw_config->card_subtype;\r\ndevc->base = hw_config->io_base;\r\ndevc->irq = hw_config->irq;\r\ndevc->dma8 = hw_config->dma;\r\ndevc->dma16 = -1;\r\ndevc->pcibase = pciio;\r\nif(pci == SB_PCI_ESSMAESTRO)\r\n{\r\ndevc->model = MDL_ESSPCI;\r\ndevc->caps |= SB_PCI_IRQ;\r\nhw_config->driver_use_1 |= SB_PCI_IRQ;\r\nhw_config->card_subtype = MDL_ESSPCI;\r\n}\r\nif(pci == SB_PCI_YAMAHA)\r\n{\r\ndevc->model = MDL_YMPCI;\r\ndevc->caps |= SB_PCI_IRQ;\r\nhw_config->driver_use_1 |= SB_PCI_IRQ;\r\nhw_config->card_subtype = MDL_YMPCI;\r\nprintk("Yamaha PCI mode.\n");\r\n}\r\nif (devc->sbmo.acer)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devc->lock, flags);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x0b);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x0b);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x0b);\r\ninb(devc->base + 0x09);\r\ninb(devc->base + 0x00);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nif (sb_dsp_reset(devc))\r\ndsp_get_vers(devc);\r\nelse\r\ndevc->major = 0;\r\nif (devc->type == 0 || devc->type == MDL_JAZZ || devc->type == MDL_SMW)\r\nif (devc->major == 0 || (devc->major == 3 && devc->minor == 1))\r\nrelocate_Jazz16(devc, hw_config);\r\nif (devc->major == 0 && (devc->type == MDL_ESS || devc->type == 0))\r\nrelocate_ess1688(devc);\r\nif (!sb_dsp_reset(devc))\r\n{\r\nDDB(printk("SB reset failed\n"));\r\n#ifdef MODULE\r\nprintk(KERN_INFO "sb: dsp reset failed.\n");\r\n#endif\r\nreturn 0;\r\n}\r\nif (devc->major == 0)\r\ndsp_get_vers(devc);\r\nif (devc->major == 3 && devc->minor == 1)\r\n{\r\nif (devc->type == MDL_AZTECH)\r\n{\r\nif (sb_dsp_command(devc, 0x09))\r\nif (sb_dsp_command(devc, 0x00))\r\n{\r\nint i;\r\nfor (i = 0; i < 10000; i++)\r\ninb(DSP_DATA_AVAIL);\r\ndevc->caps = SB_NO_AUDIO | SB_NO_MIDI;\r\ndevc->model = MDL_AZTECH;\r\n}\r\n}\r\n}\r\nif(devc->type == MDL_ESSPCI)\r\ndevc->model = MDL_ESSPCI;\r\nif(devc->type == MDL_YMPCI)\r\n{\r\nprintk("YMPCI selected\n");\r\ndevc->model = MDL_YMPCI;\r\n}\r\ndetected_devc = kmemdup(devc, sizeof(sb_devc), GFP_KERNEL);\r\nif (detected_devc == NULL)\r\n{\r\nprintk(KERN_ERR "sb: Can't allocate memory for device information\n");\r\nreturn 0;\r\n}\r\nMDB(printk(KERN_INFO "SB %d.%02d detected OK (%x)\n", devc->major, devc->minor, hw_config->io_base));\r\nreturn 1;\r\n}\r\nint sb_dsp_init(struct address_info *hw_config, struct module *owner)\r\n{\r\nsb_devc *devc;\r\nchar name[100];\r\nextern int sb_be_quiet;\r\nint mixer22, mixer30;\r\nDDB(printk("sb_dsp_init(%x) entered\n", hw_config->io_base));\r\nname[0] = 0;\r\nif (detected_devc == NULL)\r\n{\r\nMDB(printk("No detected device\n"));\r\nreturn 0;\r\n}\r\ndevc = detected_devc;\r\ndetected_devc = NULL;\r\nif (devc->base != hw_config->io_base)\r\n{\r\nDDB(printk("I/O port mismatch\n"));\r\nrelease_region(devc->base, 16);\r\nreturn 0;\r\n}\r\ndevc->caps = hw_config->driver_use_1;\r\nif (!((devc->caps & SB_NO_AUDIO) && (devc->caps & SB_NO_MIDI)) && hw_config->irq > 0)\r\n{\r\nint i=(devc->caps&SB_PCI_IRQ)?IRQF_SHARED:0;\r\nif (request_irq(hw_config->irq, sbintr, i, "soundblaster", devc) < 0)\r\n{\r\nprintk(KERN_ERR "SB: Can't allocate IRQ%d\n", hw_config->irq);\r\nrelease_region(devc->base, 16);\r\nreturn 0;\r\n}\r\ndevc->irq_ok = 0;\r\nif (devc->major == 4)\r\nif (!sb16_set_irq_hw(devc, devc->irq))\r\n{\r\nfree_irq(devc->irq, devc);\r\nrelease_region(devc->base, 16);\r\nreturn 0;\r\n}\r\nif ((devc->type == 0 || devc->type == MDL_ESS) &&\r\ndevc->major == 3 && devc->minor == 1)\r\n{\r\nif ((devc->type != 0 && devc->type != MDL_ESS) ||\r\n!ess_init(devc, hw_config))\r\n{\r\nif ((devc->type != 0 && devc->type != MDL_JAZZ &&\r\ndevc->type != MDL_SMW) || !init_Jazz16(devc, hw_config))\r\n{\r\nDDB(printk("This is a genuine SB Pro\n"));\r\n}\r\n}\r\n}\r\nif (devc->major == 4 && devc->minor <= 11 )\r\ndevc->irq_ok = 1;\r\nelse\r\n{\r\nint n;\r\nfor (n = 0; n < 3 && devc->irq_ok == 0; n++)\r\n{\r\nif (sb_dsp_command(devc, 0xf2))\r\n{\r\nint i;\r\nfor (i = 0; !devc->irq_ok && i < 10000; i++);\r\n}\r\n}\r\nif (!devc->irq_ok)\r\nprintk(KERN_WARNING "sb: Interrupt test on IRQ%d failed - Probable IRQ conflict\n", devc->irq);\r\nelse\r\n{\r\nDDB(printk("IRQ test OK (IRQ%d)\n", devc->irq));\r\n}\r\n}\r\n}\r\nlast_sb = devc;\r\nswitch (devc->major)\r\n{\r\ncase 1:\r\ndevc->model = hw_config->card_subtype = MDL_SB1;\r\nbreak;\r\ncase 2:\r\nif (devc->minor == 0)\r\ndevc->model = hw_config->card_subtype = MDL_SB2;\r\nelse\r\ndevc->model = hw_config->card_subtype = MDL_SB201;\r\nbreak;\r\ncase 3:\r\nswitch (devc->model) {\r\ncase 0:\r\ndevc->model = hw_config->card_subtype = MDL_SBPRO;\r\nif (hw_config->name == NULL)\r\nhw_config->name = "Sound Blaster Pro (8 BIT ONLY)";\r\nbreak;\r\ncase MDL_ESS:\r\ness_dsp_init(devc, hw_config);\r\nbreak;\r\n}\r\nbreak;\r\ncase 4:\r\ndevc->model = hw_config->card_subtype = MDL_SB16;\r\nif ((devc->minor == 2) && sb_getmixer(devc,0x3c) && sb_getmixer(devc,0x4c))\r\n{\r\nmixer30 = sb_getmixer(devc,0x30);\r\nsb_setmixer(devc,0x22,(mixer22=sb_getmixer(devc,0x22)) & 0x0f);\r\nsb_setmixer(devc,0x30,0xff);\r\nif ((sb_getmixer(devc,0x30) != 0xff) || ((sb_getmixer(devc,0x22) & 0xf0) != 0x10))\r\n{\r\ndevc->submodel = SUBMDL_ALS100;\r\nif (hw_config->name == NULL)\r\nhw_config->name = "Sound Blaster 16 (ALS-100)";\r\n}\r\nelse\r\n{\r\nsb_setmixer(devc,0x3c,0x1f);\r\nsb_setmixer(devc,0x4c,0x1f);\r\nsb_setmixer(devc,0x22,mixer22);\r\ndevc->submodel = SUBMDL_ALS007;\r\nif (hw_config->name == NULL)\r\nhw_config->name = "Sound Blaster 16 (ALS-007)";\r\n}\r\nsb_setmixer(devc,0x30,mixer30);\r\n}\r\nelse if (hw_config->name == NULL)\r\nhw_config->name = "Sound Blaster 16";\r\nif (hw_config->dma2 == -1)\r\ndevc->dma16 = devc->dma8;\r\nelse if (hw_config->dma2 < 5 || hw_config->dma2 > 7)\r\n{\r\nprintk(KERN_WARNING "SB16: Bad or missing 16 bit DMA channel\n");\r\ndevc->dma16 = devc->dma8;\r\n}\r\nelse\r\ndevc->dma16 = hw_config->dma2;\r\nif(!sb16_set_dma_hw(devc)) {\r\nfree_irq(devc->irq, devc);\r\nrelease_region(hw_config->io_base, 16);\r\nreturn 0;\r\n}\r\ndevc->caps |= SB_NO_MIDI;\r\n}\r\nif (!(devc->caps & SB_NO_MIXER))\r\nif (devc->major == 3 || devc->major == 4)\r\nsb_mixer_init(devc, owner);\r\nif (!(devc->caps & SB_NO_MIDI))\r\nsb_dsp_midi_init(devc, owner);\r\nif (hw_config->name == NULL)\r\nhw_config->name = "Sound Blaster (8 BIT/MONO ONLY)";\r\nsprintf(name, "%s (%d.%02d)", hw_config->name, devc->major, devc->minor);\r\nconf_printf(name, hw_config);\r\nif (devc->model <= MDL_SBPRO)\r\n{\r\nif (devc->major == 3 && devc->minor != 1)\r\n{\r\nprintk(KERN_INFO "This sound card may not be fully Sound Blaster Pro compatible.\n");\r\nprintk(KERN_INFO "In many cases there is another way to configure OSS so that\n");\r\nprintk(KERN_INFO "it works properly with OSS (for example in 16 bit mode).\n");\r\nprintk(KERN_INFO "Please ignore this message if you _really_ have a SB Pro.\n");\r\n}\r\nelse if (!sb_be_quiet && devc->model == MDL_SBPRO)\r\n{\r\nprintk(KERN_INFO "SB DSP version is just %d.%02d which means that your card is\n", devc->major, devc->minor);\r\nprintk(KERN_INFO "several years old (8 bit only device) or alternatively the sound driver\n");\r\nprintk(KERN_INFO "is incorrectly configured.\n");\r\n}\r\n}\r\nhw_config->card_subtype = devc->model;\r\nhw_config->slots[0]=devc->dev;\r\nlast_devc = devc;\r\nif (!(devc->caps & SB_NO_AUDIO) && devc->dma8 >= 0)\r\n{\r\nif (sound_alloc_dma(devc->dma8, "SoundBlaster8"))\r\n{\r\nprintk(KERN_WARNING "Sound Blaster: Can't allocate 8 bit DMA channel %d\n", devc->dma8);\r\n}\r\nif (devc->dma16 >= 0 && devc->dma16 != devc->dma8)\r\n{\r\nif (sound_alloc_dma(devc->dma16, "SoundBlaster16"))\r\nprintk(KERN_WARNING "Sound Blaster: can't allocate 16 bit DMA channel %d.\n", devc->dma16);\r\n}\r\nsb_audio_init(devc, name, owner);\r\nhw_config->slots[0]=devc->dev;\r\n}\r\nelse\r\n{\r\nMDB(printk("Sound Blaster: no audio devices found.\n"));\r\n}\r\nreturn 1;\r\n}\r\nvoid sb_dsp_unload(struct address_info *hw_config, int sbmpu)\r\n{\r\nsb_devc *devc;\r\ndevc = audio_devs[hw_config->slots[0]]->devc;\r\nif (devc && devc->base == hw_config->io_base)\r\n{\r\nif ((devc->model & MDL_ESS) && devc->pcibase)\r\nrelease_region(devc->pcibase, 8);\r\nrelease_region(devc->base, 16);\r\nif (!(devc->caps & SB_NO_AUDIO))\r\n{\r\nsound_free_dma(devc->dma8);\r\nif (devc->dma16 >= 0)\r\nsound_free_dma(devc->dma16);\r\n}\r\nif (!(devc->caps & SB_NO_AUDIO && devc->caps & SB_NO_MIDI))\r\n{\r\nif (devc->irq > 0)\r\nfree_irq(devc->irq, devc);\r\nsb_mixer_unload(devc);\r\nif (!sbmpu)\r\nsound_unload_mididev(devc->my_mididev);\r\nsound_unload_audiodev(devc->dev);\r\n}\r\nkfree(devc);\r\n}\r\nelse\r\nrelease_region(hw_config->io_base, 16);\r\nkfree(detected_devc);\r\n}\r\nvoid sb_setmixer(sb_devc * devc, unsigned int port, unsigned int value)\r\n{\r\nunsigned long flags;\r\nif (devc->model == MDL_ESS) {\r\ness_setmixer (devc, port, value);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&devc->lock, flags);\r\noutb(((unsigned char) (port & 0xff)), MIXER_ADDR);\r\nudelay(20);\r\noutb(((unsigned char) (value & 0xff)), MIXER_DATA);\r\nudelay(20);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nunsigned int sb_getmixer(sb_devc * devc, unsigned int port)\r\n{\r\nunsigned int val;\r\nunsigned long flags;\r\nif (devc->model == MDL_ESS) return ess_getmixer (devc, port);\r\nspin_lock_irqsave(&devc->lock, flags);\r\noutb(((unsigned char) (port & 0xff)), MIXER_ADDR);\r\nudelay(20);\r\nval = inb(MIXER_DATA);\r\nudelay(20);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nreturn val;\r\n}\r\nvoid sb_chgmixer\r\n(sb_devc * devc, unsigned int reg, unsigned int mask, unsigned int val)\r\n{\r\nint value;\r\nvalue = sb_getmixer(devc, reg);\r\nvalue = (value & ~mask) | (val & mask);\r\nsb_setmixer(devc, reg, value);\r\n}\r\nstatic void smw_putmem(sb_devc * devc, int base, int addr, unsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&jazz16_lock, flags);\r\noutb((addr & 0xff), base + 1);\r\noutb((addr >> 8), base + 2);\r\noutb((val), base);\r\nspin_unlock_irqrestore(&jazz16_lock, flags);\r\n}\r\nstatic unsigned char smw_getmem(sb_devc * devc, int base, int addr)\r\n{\r\nunsigned long flags;\r\nunsigned char val;\r\nspin_lock_irqsave(&jazz16_lock, flags);\r\noutb((addr & 0xff), base + 1);\r\noutb((addr >> 8), base + 2);\r\nval = inb(base);\r\nspin_unlock_irqrestore(&jazz16_lock, flags);\r\nreturn val;\r\n}\r\nstatic int smw_midi_init(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nint mpu_base = hw_config->io_base;\r\nint mp_base = mpu_base + 4;\r\nint i;\r\nunsigned char control;\r\ncontrol = inb(mpu_base + 7);\r\noutb((control | 3), mpu_base + 7);\r\noutb(((control & 0xfe) | 2), mpu_base + 7);\r\nmdelay(3);\r\noutb((control & 0xfc), mpu_base + 7);\r\nsmw_putmem(devc, mp_base, 0, 0x00);\r\nsmw_putmem(devc, mp_base, 1, 0xff);\r\nudelay(10);\r\nif (smw_getmem(devc, mp_base, 0) != 0x00 || smw_getmem(devc, mp_base, 1) != 0xff)\r\n{\r\nDDB(printk("SM Wave: No microcontroller RAM detected (%02x, %02x)\n", smw_getmem(devc, mp_base, 0), smw_getmem(devc, mp_base, 1)));\r\nreturn 0;\r\n}\r\ndevc->model = MDL_SMW;\r\nsmw_mixer_init(devc);\r\n#ifdef MODULE\r\nif (!smw_ucode)\r\n{\r\nsmw_ucodeLen = mod_firmware_load("/etc/sound/midi0001.bin", (void *) &smw_ucode);\r\nsmw_free = smw_ucode;\r\n}\r\n#endif\r\nif (smw_ucodeLen > 0)\r\n{\r\nif (smw_ucodeLen != 8192)\r\n{\r\nprintk(KERN_ERR "SM Wave: Invalid microcode (MIDI0001.BIN) length\n");\r\nreturn 1;\r\n}\r\nfor (i = 0; i < 8192; i++)\r\nsmw_putmem(devc, mp_base, i, smw_ucode[i]);\r\nfor (i = 0; i < 8192; i++)\r\nif (smw_getmem(devc, mp_base, i) != smw_ucode[i])\r\n{\r\nprintk(KERN_ERR "SM Wave: Microcode verification failed\n");\r\nreturn 0;\r\n}\r\n}\r\ncontrol = 0;\r\n#ifdef SMW_SCSI_IRQ\r\n{\r\nstatic unsigned char scsi_irq_bits[] = {\r\n0, 0, 3, 1, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 0\r\n};\r\ncontrol |= scsi_irq_bits[SMW_SCSI_IRQ] << 6;\r\n}\r\n#endif\r\n#ifdef SMW_OPL4_ENABLE\r\ncontrol |= 0x10;\r\n#endif\r\noutb((control | 0x03), mpu_base + 7);\r\nhw_config->name = "SoundMan Wave";\r\nreturn 1;\r\n}\r\nstatic int init_Jazz16_midi(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nint mpu_base = hw_config->io_base;\r\nint sb_base = devc->base;\r\nint irq = hw_config->irq;\r\nunsigned char bits = 0;\r\nunsigned long flags;\r\nif (irq < 0)\r\nirq *= -1;\r\nif (irq < 1 || irq > 15 ||\r\njazz_irq_bits[irq] == 0)\r\n{\r\nprintk(KERN_ERR "Jazz16: Invalid MIDI interrupt (IRQ%d)\n", irq);\r\nreturn 0;\r\n}\r\nswitch (sb_base)\r\n{\r\ncase 0x220:\r\nbits = 1;\r\nbreak;\r\ncase 0x240:\r\nbits = 2;\r\nbreak;\r\ncase 0x260:\r\nbits = 3;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbits = jazz16_bits = bits << 5;\r\nswitch (mpu_base)\r\n{\r\ncase 0x310:\r\nbits |= 1;\r\nbreak;\r\ncase 0x320:\r\nbits |= 2;\r\nbreak;\r\ncase 0x330:\r\nbits |= 3;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Jazz16: Invalid MIDI I/O port %x\n", mpu_base);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&jazz16_lock, flags);\r\noutb(0xAF, 0x201);\r\noutb(0x50, 0x201);\r\noutb(bits, 0x201);\r\nspin_unlock_irqrestore(&jazz16_lock, flags);\r\nhw_config->name = "Jazz16";\r\nsmw_midi_init(devc, hw_config);\r\nif (!sb_dsp_command(devc, 0xfb))\r\nreturn 0;\r\nif (!sb_dsp_command(devc, jazz_dma_bits[devc->dma8] |\r\n(jazz_dma_bits[devc->dma16] << 4)))\r\nreturn 0;\r\nif (!sb_dsp_command(devc, jazz_irq_bits[devc->irq] |\r\n(jazz_irq_bits[irq] << 4)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint probe_sbmpu(struct address_info *hw_config, struct module *owner)\r\n{\r\nsb_devc *devc = last_devc;\r\nint ret;\r\nif (last_devc == NULL)\r\nreturn 0;\r\nlast_devc = NULL;\r\nif (hw_config->io_base <= 0)\r\n{\r\nif(devc->model == MDL_SB16 && devc->minor >= 12)\r\n{\r\nunsigned char bits = sb_getmixer(devc, 0x84) & ~0x06;\r\nsb_setmixer(devc, 0x84, bits | 0x02);\r\n}\r\nreturn 0;\r\n}\r\n#if defined(CONFIG_SOUND_MPU401)\r\nif (devc->model == MDL_ESS)\r\n{\r\nstruct resource *ports;\r\nports = request_region(hw_config->io_base, 2, "mpu401");\r\nif (!ports) {\r\nprintk(KERN_ERR "sbmpu: I/O port conflict (%x)\n", hw_config->io_base);\r\nreturn 0;\r\n}\r\nif (!ess_midi_init(devc, hw_config)) {\r\nrelease_region(hw_config->io_base, 2);\r\nreturn 0;\r\n}\r\nhw_config->name = "ESS1xxx MPU";\r\ndevc->midi_irq_cookie = NULL;\r\nif (!probe_mpu401(hw_config, ports)) {\r\nrelease_region(hw_config->io_base, 2);\r\nreturn 0;\r\n}\r\nattach_mpu401(hw_config, owner);\r\nif (last_sb->irq == -hw_config->irq)\r\nlast_sb->midi_irq_cookie =\r\n(void *)(long) hw_config->slots[1];\r\nreturn 1;\r\n}\r\n#endif\r\nswitch (devc->model)\r\n{\r\ncase MDL_SB16:\r\nif (hw_config->io_base != 0x300 && hw_config->io_base != 0x330)\r\n{\r\nprintk(KERN_ERR "SB16: Invalid MIDI port %x\n", hw_config->io_base);\r\nreturn 0;\r\n}\r\nhw_config->name = "Sound Blaster 16";\r\nif (hw_config->irq < 3 || hw_config->irq == devc->irq)\r\nhw_config->irq = -devc->irq;\r\nif (devc->minor > 12)\r\nsb16_set_mpu_port(devc, hw_config);\r\nbreak;\r\ncase MDL_JAZZ:\r\nif (hw_config->irq < 3 || hw_config->irq == devc->irq)\r\nhw_config->irq = -devc->irq;\r\nif (!init_Jazz16_midi(devc, hw_config))\r\nreturn 0;\r\nbreak;\r\ncase MDL_YMPCI:\r\nhw_config->name = "Yamaha PCI Legacy";\r\nprintk("Yamaha PCI legacy UART401 check.\n");\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nret = probe_uart401(hw_config, owner);\r\nif (ret)\r\nlast_sb->midi_irq_cookie=midi_devs[hw_config->slots[4]]->devc;\r\nreturn ret;\r\n}\r\nvoid unload_sbmpu(struct address_info *hw_config)\r\n{\r\n#if defined(CONFIG_SOUND_MPU401)\r\nif (!strcmp (hw_config->name, "ESS1xxx MPU")) {\r\nunload_mpu401(hw_config);\r\nreturn;\r\n}\r\n#endif\r\nunload_uart401(hw_config);\r\n}
