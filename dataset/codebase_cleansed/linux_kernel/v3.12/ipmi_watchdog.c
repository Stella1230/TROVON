static int set_param_timeout(const char *val, const struct kernel_param *kp)\r\n{\r\nchar *endp;\r\nint l;\r\nint rv = 0;\r\nif (!val)\r\nreturn -EINVAL;\r\nl = simple_strtoul(val, &endp, 0);\r\nif (endp == val)\r\nreturn -EINVAL;\r\n*((int *)kp->arg) = l;\r\nif (watchdog_user)\r\nrv = ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\r\nreturn rv;\r\n}\r\nstatic int set_param_str(const char *val, const struct kernel_param *kp)\r\n{\r\naction_fn fn = (action_fn) kp->arg;\r\nint rv = 0;\r\nchar valcp[16];\r\nchar *s;\r\nstrncpy(valcp, val, 16);\r\nvalcp[15] = '\0';\r\ns = strstrip(valcp);\r\nrv = fn(s, NULL);\r\nif (rv)\r\ngoto out;\r\ncheck_parms();\r\nif (watchdog_user)\r\nrv = ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\r\nout:\r\nreturn rv;\r\n}\r\nstatic int get_param_str(char *buffer, const struct kernel_param *kp)\r\n{\r\naction_fn fn = (action_fn) kp->arg;\r\nint rv;\r\nrv = fn(NULL, buffer);\r\nif (rv)\r\nreturn rv;\r\nreturn strlen(buffer);\r\n}\r\nstatic int set_param_wdog_ifnum(const char *val, const struct kernel_param *kp)\r\n{\r\nint rv = param_set_int(val, kp);\r\nif (rv)\r\nreturn rv;\r\nif ((ifnum_to_use < 0) || (ifnum_to_use == watchdog_ifnum))\r\nreturn 0;\r\nipmi_unregister_watchdog(watchdog_ifnum);\r\nipmi_register_watchdog(ifnum_to_use);\r\nreturn 0;\r\n}\r\nstatic void set_timeout_free_smi(struct ipmi_smi_msg *msg)\r\n{\r\nif (atomic_dec_and_test(&set_timeout_tofree))\r\ncomplete(&set_timeout_wait);\r\n}\r\nstatic void set_timeout_free_recv(struct ipmi_recv_msg *msg)\r\n{\r\nif (atomic_dec_and_test(&set_timeout_tofree))\r\ncomplete(&set_timeout_wait);\r\n}\r\nstatic int i_ipmi_set_timeout(struct ipmi_smi_msg *smi_msg,\r\nstruct ipmi_recv_msg *recv_msg,\r\nint *send_heartbeat_now)\r\n{\r\nstruct kernel_ipmi_msg msg;\r\nunsigned char data[6];\r\nint rv;\r\nstruct ipmi_system_interface_addr addr;\r\nint hbnow = 0;\r\npretimeout_since_last_heartbeat = 0;\r\ndata[0] = 0;\r\nWDOG_SET_TIMER_USE(data[0], WDOG_TIMER_USE_SMS_OS);\r\nif ((ipmi_version_major > 1)\r\n|| ((ipmi_version_major == 1) && (ipmi_version_minor >= 5))) {\r\ndata[0] |= WDOG_DONT_STOP_ON_SET;\r\n} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {\r\nhbnow = 1;\r\n}\r\ndata[1] = 0;\r\nWDOG_SET_TIMEOUT_ACT(data[1], ipmi_watchdog_state);\r\nif ((pretimeout > 0) && (ipmi_watchdog_state != WDOG_TIMEOUT_NONE)) {\r\nWDOG_SET_PRETIMEOUT_ACT(data[1], preaction_val);\r\ndata[2] = pretimeout;\r\n} else {\r\nWDOG_SET_PRETIMEOUT_ACT(data[1], WDOG_PRETIMEOUT_NONE);\r\ndata[2] = 0;\r\n}\r\ndata[3] = 0;\r\nWDOG_SET_TIMEOUT(data[4], data[5], timeout);\r\naddr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\naddr.channel = IPMI_BMC_CHANNEL;\r\naddr.lun = 0;\r\nmsg.netfn = 0x06;\r\nmsg.cmd = IPMI_WDOG_SET_TIMER;\r\nmsg.data = data;\r\nmsg.data_len = sizeof(data);\r\nrv = ipmi_request_supply_msgs(watchdog_user,\r\n(struct ipmi_addr *) &addr,\r\n0,\r\n&msg,\r\nNULL,\r\nsmi_msg,\r\nrecv_msg,\r\n1);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX "set timeout error: %d\n",\r\nrv);\r\n}\r\nif (send_heartbeat_now)\r\n*send_heartbeat_now = hbnow;\r\nreturn rv;\r\n}\r\nstatic int ipmi_set_timeout(int do_heartbeat)\r\n{\r\nint send_heartbeat_now;\r\nint rv;\r\nmutex_lock(&set_timeout_lock);\r\natomic_set(&set_timeout_tofree, 2);\r\nrv = i_ipmi_set_timeout(&set_timeout_smi_msg,\r\n&set_timeout_recv_msg,\r\n&send_heartbeat_now);\r\nif (rv) {\r\nmutex_unlock(&set_timeout_lock);\r\ngoto out;\r\n}\r\nwait_for_completion(&set_timeout_wait);\r\nmutex_unlock(&set_timeout_lock);\r\nif ((do_heartbeat == IPMI_SET_TIMEOUT_FORCE_HB)\r\n|| ((send_heartbeat_now)\r\n&& (do_heartbeat == IPMI_SET_TIMEOUT_HB_IF_NECESSARY)))\r\nrv = ipmi_heartbeat();\r\nout:\r\nreturn rv;\r\n}\r\nstatic void panic_smi_free(struct ipmi_smi_msg *msg)\r\n{\r\natomic_dec(&panic_done_count);\r\n}\r\nstatic void panic_recv_free(struct ipmi_recv_msg *msg)\r\n{\r\natomic_dec(&panic_done_count);\r\n}\r\nstatic void panic_halt_ipmi_heartbeat(void)\r\n{\r\nstruct kernel_ipmi_msg msg;\r\nstruct ipmi_system_interface_addr addr;\r\nint rv;\r\nif (ipmi_watchdog_state == WDOG_TIMEOUT_NONE)\r\nreturn;\r\naddr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\naddr.channel = IPMI_BMC_CHANNEL;\r\naddr.lun = 0;\r\nmsg.netfn = 0x06;\r\nmsg.cmd = IPMI_WDOG_RESET_TIMER;\r\nmsg.data = NULL;\r\nmsg.data_len = 0;\r\natomic_add(2, &panic_done_count);\r\nrv = ipmi_request_supply_msgs(watchdog_user,\r\n(struct ipmi_addr *) &addr,\r\n0,\r\n&msg,\r\nNULL,\r\n&panic_halt_heartbeat_smi_msg,\r\n&panic_halt_heartbeat_recv_msg,\r\n1);\r\nif (rv)\r\natomic_sub(2, &panic_done_count);\r\n}\r\nstatic void panic_halt_ipmi_set_timeout(void)\r\n{\r\nint send_heartbeat_now;\r\nint rv;\r\nwhile (atomic_read(&panic_done_count) != 0)\r\nipmi_poll_interface(watchdog_user);\r\natomic_add(2, &panic_done_count);\r\nrv = i_ipmi_set_timeout(&panic_halt_smi_msg,\r\n&panic_halt_recv_msg,\r\n&send_heartbeat_now);\r\nif (rv) {\r\natomic_sub(2, &panic_done_count);\r\nprintk(KERN_WARNING PFX\r\n"Unable to extend the watchdog timeout.");\r\n} else {\r\nif (send_heartbeat_now)\r\npanic_halt_ipmi_heartbeat();\r\n}\r\nwhile (atomic_read(&panic_done_count) != 0)\r\nipmi_poll_interface(watchdog_user);\r\n}\r\nstatic void heartbeat_free_smi(struct ipmi_smi_msg *msg)\r\n{\r\nif (atomic_dec_and_test(&heartbeat_tofree))\r\ncomplete(&heartbeat_wait);\r\n}\r\nstatic void heartbeat_free_recv(struct ipmi_recv_msg *msg)\r\n{\r\nif (atomic_dec_and_test(&heartbeat_tofree))\r\ncomplete(&heartbeat_wait);\r\n}\r\nstatic int ipmi_heartbeat(void)\r\n{\r\nstruct kernel_ipmi_msg msg;\r\nint rv;\r\nstruct ipmi_system_interface_addr addr;\r\nint timeout_retries = 0;\r\nif (ipmi_ignore_heartbeat)\r\nreturn 0;\r\nif (ipmi_start_timer_on_heartbeat) {\r\nipmi_start_timer_on_heartbeat = 0;\r\nipmi_watchdog_state = action_val;\r\nreturn ipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\r\n} else if (pretimeout_since_last_heartbeat) {\r\nreturn ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\r\n}\r\nmutex_lock(&heartbeat_lock);\r\nrestart:\r\natomic_set(&heartbeat_tofree, 2);\r\nif (ipmi_watchdog_state == WDOG_TIMEOUT_NONE) {\r\nmutex_unlock(&heartbeat_lock);\r\nreturn 0;\r\n}\r\naddr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\naddr.channel = IPMI_BMC_CHANNEL;\r\naddr.lun = 0;\r\nmsg.netfn = 0x06;\r\nmsg.cmd = IPMI_WDOG_RESET_TIMER;\r\nmsg.data = NULL;\r\nmsg.data_len = 0;\r\nrv = ipmi_request_supply_msgs(watchdog_user,\r\n(struct ipmi_addr *) &addr,\r\n0,\r\n&msg,\r\nNULL,\r\n&heartbeat_smi_msg,\r\n&heartbeat_recv_msg,\r\n1);\r\nif (rv) {\r\nmutex_unlock(&heartbeat_lock);\r\nprintk(KERN_WARNING PFX "heartbeat failure: %d\n",\r\nrv);\r\nreturn rv;\r\n}\r\nwait_for_completion(&heartbeat_wait);\r\nif (heartbeat_recv_msg.msg.data[0] == IPMI_WDOG_TIMER_NOT_INIT_RESP) {\r\ntimeout_retries++;\r\nif (timeout_retries > 3) {\r\nprintk(KERN_ERR PFX ": Unable to restore the IPMI"\r\n" watchdog's settings, giving up.\n");\r\nrv = -EIO;\r\ngoto out_unlock;\r\n}\r\nrv = ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\r\nif (rv) {\r\nprintk(KERN_ERR PFX ": Unable to send the command to"\r\n" set the watchdog's settings, giving up.\n");\r\ngoto out_unlock;\r\n}\r\ngoto restart;\r\n} else if (heartbeat_recv_msg.msg.data[0] != 0) {\r\nrv = -EINVAL;\r\n}\r\nout_unlock:\r\nmutex_unlock(&heartbeat_lock);\r\nreturn rv;\r\n}\r\nstatic int ipmi_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint i;\r\nint val;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\ni = copy_to_user(argp, &ident, sizeof(ident));\r\nreturn i ? -EFAULT : 0;\r\ncase WDIOC_SETTIMEOUT:\r\ni = copy_from_user(&val, argp, sizeof(int));\r\nif (i)\r\nreturn -EFAULT;\r\ntimeout = val;\r\nreturn ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\r\ncase WDIOC_GETTIMEOUT:\r\ni = copy_to_user(argp, &timeout, sizeof(timeout));\r\nif (i)\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_SETPRETIMEOUT:\r\ni = copy_from_user(&val, argp, sizeof(int));\r\nif (i)\r\nreturn -EFAULT;\r\npretimeout = val;\r\nreturn ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\r\ncase WDIOC_GETPRETIMEOUT:\r\ni = copy_to_user(argp, &pretimeout, sizeof(pretimeout));\r\nif (i)\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nreturn ipmi_heartbeat();\r\ncase WDIOC_SETOPTIONS:\r\ni = copy_from_user(&val, argp, sizeof(int));\r\nif (i)\r\nreturn -EFAULT;\r\nif (val & WDIOS_DISABLECARD) {\r\nipmi_watchdog_state = WDOG_TIMEOUT_NONE;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\r\nipmi_start_timer_on_heartbeat = 0;\r\n}\r\nif (val & WDIOS_ENABLECARD) {\r\nipmi_watchdog_state = action_val;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\r\n}\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\nval = 0;\r\ni = copy_to_user(argp, &val, sizeof(val));\r\nif (i)\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic long ipmi_unlocked_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&ipmi_watchdog_mutex);\r\nret = ipmi_ioctl(file, cmd, arg);\r\nmutex_unlock(&ipmi_watchdog_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ipmi_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len,\r\nloff_t *ppos)\r\n{\r\nint rv;\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nrv = ipmi_heartbeat();\r\nif (rv)\r\nreturn rv;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t ipmi_read(struct file *file,\r\nchar __user *buf,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nint rv = 0;\r\nwait_queue_t wait;\r\nif (count <= 0)\r\nreturn 0;\r\nspin_lock(&ipmi_read_lock);\r\nif (!data_to_read) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nrv = -EAGAIN;\r\ngoto out;\r\n}\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&read_q, &wait);\r\nwhile (!data_to_read) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock(&ipmi_read_lock);\r\nschedule();\r\nspin_lock(&ipmi_read_lock);\r\n}\r\nremove_wait_queue(&read_q, &wait);\r\nif (signal_pending(current)) {\r\nrv = -ERESTARTSYS;\r\ngoto out;\r\n}\r\n}\r\ndata_to_read = 0;\r\nout:\r\nspin_unlock(&ipmi_read_lock);\r\nif (rv == 0) {\r\nif (copy_to_user(buf, &data_to_read, 1))\r\nrv = -EFAULT;\r\nelse\r\nrv = 1;\r\n}\r\nreturn rv;\r\n}\r\nstatic int ipmi_open(struct inode *ino, struct file *filep)\r\n{\r\nswitch (iminor(ino)) {\r\ncase WATCHDOG_MINOR:\r\nif (test_and_set_bit(0, &ipmi_wdog_open))\r\nreturn -EBUSY;\r\nipmi_start_timer_on_heartbeat = 1;\r\nreturn nonseekable_open(ino, filep);\r\ndefault:\r\nreturn (-ENODEV);\r\n}\r\n}\r\nstatic unsigned int ipmi_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &read_q, wait);\r\nspin_lock(&ipmi_read_lock);\r\nif (data_to_read)\r\nmask |= (POLLIN | POLLRDNORM);\r\nspin_unlock(&ipmi_read_lock);\r\nreturn mask;\r\n}\r\nstatic int ipmi_fasync(int fd, struct file *file, int on)\r\n{\r\nint result;\r\nresult = fasync_helper(fd, file, on, &fasync_q);\r\nreturn (result);\r\n}\r\nstatic int ipmi_close(struct inode *ino, struct file *filep)\r\n{\r\nif (iminor(ino) == WATCHDOG_MINOR) {\r\nif (expect_close == 42) {\r\nipmi_watchdog_state = WDOG_TIMEOUT_NONE;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\r\n} else {\r\nprintk(KERN_CRIT PFX\r\n"Unexpected close, not stopping watchdog!\n");\r\nipmi_heartbeat();\r\n}\r\nclear_bit(0, &ipmi_wdog_open);\r\n}\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic void ipmi_wdog_msg_handler(struct ipmi_recv_msg *msg,\r\nvoid *handler_data)\r\n{\r\nif (msg->msg.cmd == IPMI_WDOG_RESET_TIMER &&\r\nmsg->msg.data[0] == IPMI_WDOG_TIMER_NOT_INIT_RESP)\r\nprintk(KERN_INFO PFX "response: The IPMI controller appears"\r\n" to have been reset, will attempt to reinitialize"\r\n" the watchdog timer\n");\r\nelse if (msg->msg.data[0] != 0)\r\nprintk(KERN_ERR PFX "response: Error %x on cmd %x\n",\r\nmsg->msg.data[0],\r\nmsg->msg.cmd);\r\nipmi_free_recv_msg(msg);\r\n}\r\nstatic void ipmi_wdog_pretimeout_handler(void *handler_data)\r\n{\r\nif (preaction_val != WDOG_PRETIMEOUT_NONE) {\r\nif (preop_val == WDOG_PREOP_PANIC) {\r\nif (atomic_inc_and_test(&preop_panic_excl))\r\npanic("Watchdog pre-timeout");\r\n} else if (preop_val == WDOG_PREOP_GIVE_DATA) {\r\nspin_lock(&ipmi_read_lock);\r\ndata_to_read = 1;\r\nwake_up_interruptible(&read_q);\r\nkill_fasync(&fasync_q, SIGIO, POLL_IN);\r\nspin_unlock(&ipmi_read_lock);\r\n}\r\n}\r\npretimeout_since_last_heartbeat = 1;\r\n}\r\nstatic void ipmi_register_watchdog(int ipmi_intf)\r\n{\r\nint rv = -EBUSY;\r\nif (watchdog_user)\r\ngoto out;\r\nif ((ifnum_to_use >= 0) && (ifnum_to_use != ipmi_intf))\r\ngoto out;\r\nwatchdog_ifnum = ipmi_intf;\r\nrv = ipmi_create_user(ipmi_intf, &ipmi_hndlrs, NULL, &watchdog_user);\r\nif (rv < 0) {\r\nprintk(KERN_CRIT PFX "Unable to register with ipmi\n");\r\ngoto out;\r\n}\r\nipmi_get_version(watchdog_user,\r\n&ipmi_version_major,\r\n&ipmi_version_minor);\r\nrv = misc_register(&ipmi_wdog_miscdev);\r\nif (rv < 0) {\r\nipmi_destroy_user(watchdog_user);\r\nwatchdog_user = NULL;\r\nprintk(KERN_CRIT PFX "Unable to register misc device\n");\r\n}\r\n#ifdef HAVE_DIE_NMI\r\nif (nmi_handler_registered) {\r\nint old_pretimeout = pretimeout;\r\nint old_timeout = timeout;\r\nint old_preop_val = preop_val;\r\nipmi_watchdog_state = WDOG_TIMEOUT_RESET;\r\npreop_val = WDOG_PREOP_NONE;\r\npretimeout = 99;\r\ntimeout = 100;\r\ntesting_nmi = 1;\r\nrv = ipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX "Error starting timer to"\r\n" test NMI: 0x%x. The NMI pretimeout will"\r\n" likely not work\n", rv);\r\nrv = 0;\r\ngoto out_restore;\r\n}\r\nmsleep(1500);\r\nif (testing_nmi != 2) {\r\nprintk(KERN_WARNING PFX "IPMI NMI didn't seem to"\r\n" occur. The NMI pretimeout will"\r\n" likely not work\n");\r\n}\r\nout_restore:\r\ntesting_nmi = 0;\r\npreop_val = old_preop_val;\r\npretimeout = old_pretimeout;\r\ntimeout = old_timeout;\r\n}\r\n#endif\r\nout:\r\nif ((start_now) && (rv == 0)) {\r\nstart_now = 0;\r\nipmi_watchdog_state = action_val;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\r\nprintk(KERN_INFO PFX "Starting now!\n");\r\n} else {\r\nipmi_watchdog_state = WDOG_TIMEOUT_NONE;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\r\n}\r\n}\r\nstatic void ipmi_unregister_watchdog(int ipmi_intf)\r\n{\r\nint rv;\r\nif (!watchdog_user)\r\ngoto out;\r\nif (watchdog_ifnum != ipmi_intf)\r\ngoto out;\r\nmisc_deregister(&ipmi_wdog_miscdev);\r\nwhile (atomic_read(&set_timeout_tofree))\r\nschedule_timeout_uninterruptible(1);\r\nrv = ipmi_destroy_user(watchdog_user);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX "error unlinking from IPMI: %d\n",\r\nrv);\r\n}\r\nwatchdog_user = NULL;\r\nout:\r\nreturn;\r\n}\r\nstatic int\r\nipmi_nmi(unsigned int val, struct pt_regs *regs)\r\n{\r\nif (testing_nmi) {\r\ntesting_nmi = 2;\r\nreturn NMI_HANDLED;\r\n}\r\nif (ipmi_watchdog_state == WDOG_TIMEOUT_NONE)\r\nreturn NMI_DONE;\r\nif (preaction_val != WDOG_PRETIMEOUT_NMI)\r\nreturn NMI_DONE;\r\nif (preop_val == WDOG_PREOP_PANIC) {\r\npretimeout_since_last_heartbeat = 1;\r\nif (atomic_inc_and_test(&preop_panic_excl))\r\npanic(PFX "pre-timeout");\r\n}\r\nreturn NMI_HANDLED;\r\n}\r\nstatic int wdog_reboot_handler(struct notifier_block *this,\r\nunsigned long code,\r\nvoid *unused)\r\n{\r\nstatic int reboot_event_handled;\r\nif ((watchdog_user) && (!reboot_event_handled)) {\r\nreboot_event_handled = 1;\r\nif (code == SYS_POWER_OFF || code == SYS_HALT) {\r\nipmi_watchdog_state = WDOG_TIMEOUT_NONE;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\r\n} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {\r\ntimeout = 120;\r\npretimeout = 0;\r\nipmi_watchdog_state = WDOG_TIMEOUT_RESET;\r\nipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int wdog_panic_handler(struct notifier_block *this,\r\nunsigned long event,\r\nvoid *unused)\r\n{\r\nstatic int panic_event_handled;\r\nif (watchdog_user && !panic_event_handled &&\r\nipmi_watchdog_state != WDOG_TIMEOUT_NONE) {\r\npanic_event_handled = 1;\r\ntimeout = 255;\r\npretimeout = 0;\r\npanic_halt_ipmi_set_timeout();\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void ipmi_new_smi(int if_num, struct device *device)\r\n{\r\nipmi_register_watchdog(if_num);\r\n}\r\nstatic void ipmi_smi_gone(int if_num)\r\n{\r\nipmi_unregister_watchdog(if_num);\r\n}\r\nstatic int action_op(const char *inval, char *outval)\r\n{\r\nif (outval)\r\nstrcpy(outval, action);\r\nif (!inval)\r\nreturn 0;\r\nif (strcmp(inval, "reset") == 0)\r\naction_val = WDOG_TIMEOUT_RESET;\r\nelse if (strcmp(inval, "none") == 0)\r\naction_val = WDOG_TIMEOUT_NONE;\r\nelse if (strcmp(inval, "power_cycle") == 0)\r\naction_val = WDOG_TIMEOUT_POWER_CYCLE;\r\nelse if (strcmp(inval, "power_off") == 0)\r\naction_val = WDOG_TIMEOUT_POWER_DOWN;\r\nelse\r\nreturn -EINVAL;\r\nstrcpy(action, inval);\r\nreturn 0;\r\n}\r\nstatic int preaction_op(const char *inval, char *outval)\r\n{\r\nif (outval)\r\nstrcpy(outval, preaction);\r\nif (!inval)\r\nreturn 0;\r\nif (strcmp(inval, "pre_none") == 0)\r\npreaction_val = WDOG_PRETIMEOUT_NONE;\r\nelse if (strcmp(inval, "pre_smi") == 0)\r\npreaction_val = WDOG_PRETIMEOUT_SMI;\r\n#ifdef HAVE_DIE_NMI\r\nelse if (strcmp(inval, "pre_nmi") == 0)\r\npreaction_val = WDOG_PRETIMEOUT_NMI;\r\n#endif\r\nelse if (strcmp(inval, "pre_int") == 0)\r\npreaction_val = WDOG_PRETIMEOUT_MSG_INT;\r\nelse\r\nreturn -EINVAL;\r\nstrcpy(preaction, inval);\r\nreturn 0;\r\n}\r\nstatic int preop_op(const char *inval, char *outval)\r\n{\r\nif (outval)\r\nstrcpy(outval, preop);\r\nif (!inval)\r\nreturn 0;\r\nif (strcmp(inval, "preop_none") == 0)\r\npreop_val = WDOG_PREOP_NONE;\r\nelse if (strcmp(inval, "preop_panic") == 0)\r\npreop_val = WDOG_PREOP_PANIC;\r\nelse if (strcmp(inval, "preop_give_data") == 0)\r\npreop_val = WDOG_PREOP_GIVE_DATA;\r\nelse\r\nreturn -EINVAL;\r\nstrcpy(preop, inval);\r\nreturn 0;\r\n}\r\nstatic void check_parms(void)\r\n{\r\n#ifdef HAVE_DIE_NMI\r\nint do_nmi = 0;\r\nint rv;\r\nif (preaction_val == WDOG_PRETIMEOUT_NMI) {\r\ndo_nmi = 1;\r\nif (preop_val == WDOG_PREOP_GIVE_DATA) {\r\nprintk(KERN_WARNING PFX "Pretimeout op is to give data"\r\n" but NMI pretimeout is enabled, setting"\r\n" pretimeout op to none\n");\r\npreop_op("preop_none", NULL);\r\ndo_nmi = 0;\r\n}\r\n}\r\nif (do_nmi && !nmi_handler_registered) {\r\nrv = register_nmi_handler(NMI_UNKNOWN, ipmi_nmi, 0,\r\n"ipmi");\r\nif (rv) {\r\nprintk(KERN_WARNING PFX\r\n"Can't register nmi handler\n");\r\nreturn;\r\n} else\r\nnmi_handler_registered = 1;\r\n} else if (!do_nmi && nmi_handler_registered) {\r\nunregister_nmi_handler(NMI_UNKNOWN, "ipmi");\r\nnmi_handler_registered = 0;\r\n}\r\n#endif\r\n}\r\nstatic int __init ipmi_wdog_init(void)\r\n{\r\nint rv;\r\nif (action_op(action, NULL)) {\r\naction_op("reset", NULL);\r\nprintk(KERN_INFO PFX "Unknown action '%s', defaulting to"\r\n" reset\n", action);\r\n}\r\nif (preaction_op(preaction, NULL)) {\r\npreaction_op("pre_none", NULL);\r\nprintk(KERN_INFO PFX "Unknown preaction '%s', defaulting to"\r\n" none\n", preaction);\r\n}\r\nif (preop_op(preop, NULL)) {\r\npreop_op("preop_none", NULL);\r\nprintk(KERN_INFO PFX "Unknown preop '%s', defaulting to"\r\n" none\n", preop);\r\n}\r\ncheck_parms();\r\nregister_reboot_notifier(&wdog_reboot_notifier);\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&wdog_panic_notifier);\r\nrv = ipmi_smi_watcher_register(&smi_watcher);\r\nif (rv) {\r\n#ifdef HAVE_DIE_NMI\r\nif (nmi_handler_registered)\r\nunregister_nmi_handler(NMI_UNKNOWN, "ipmi");\r\n#endif\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&wdog_panic_notifier);\r\nunregister_reboot_notifier(&wdog_reboot_notifier);\r\nprintk(KERN_WARNING PFX "can't register smi watcher\n");\r\nreturn rv;\r\n}\r\nprintk(KERN_INFO PFX "driver initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ipmi_wdog_exit(void)\r\n{\r\nipmi_smi_watcher_unregister(&smi_watcher);\r\nipmi_unregister_watchdog(watchdog_ifnum);\r\n#ifdef HAVE_DIE_NMI\r\nif (nmi_handler_registered)\r\nunregister_nmi_handler(NMI_UNKNOWN, "ipmi");\r\n#endif\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&wdog_panic_notifier);\r\nunregister_reboot_notifier(&wdog_reboot_notifier);\r\n}
