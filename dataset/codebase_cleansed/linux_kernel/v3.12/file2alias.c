static inline void add_wildcard(char *str)\r\n{\r\nint len = strlen(str);\r\nif (str[len - 1] != '*')\r\nstrcat(str + len, "*");\r\n}\r\nstatic void device_id_check(const char *modname, const char *device_id,\r\nunsigned long size, unsigned long id_size,\r\nvoid *symval)\r\n{\r\nint i;\r\nif (size % id_size || size < id_size) {\r\nfatal("%s: sizeof(struct %s_device_id)=%lu is not a modulo "\r\n"of the size of section __mod_%s_device_table=%lu.\n"\r\n"Fix definition of struct %s_device_id "\r\n"in mod_devicetable.h\n",\r\nmodname, device_id, id_size, device_id, size, device_id);\r\n}\r\nfor (i = 0; i < id_size; i++ ) {\r\nif (*(uint8_t*)(symval+size-id_size+i)) {\r\nfprintf(stderr,"%s: struct %s_device_id is %lu bytes. "\r\n"The last of %lu is:\n",\r\nmodname, device_id, id_size, size / id_size);\r\nfor (i = 0; i < id_size; i++ )\r\nfprintf(stderr,"0x%02x ",\r\n*(uint8_t*)(symval+size-id_size+i) );\r\nfprintf(stderr,"\n");\r\nfatal("%s: struct %s_device_id is not terminated "\r\n"with a NULL entry!\n", modname, device_id);\r\n}\r\n}\r\n}\r\nstatic void do_usb_entry(void *symval,\r\nunsigned int bcdDevice_initial, int bcdDevice_initial_digits,\r\nunsigned char range_lo, unsigned char range_hi,\r\nunsigned char max, struct module *mod)\r\n{\r\nchar alias[500];\r\nDEF_FIELD(symval, usb_device_id, match_flags);\r\nDEF_FIELD(symval, usb_device_id, idVendor);\r\nDEF_FIELD(symval, usb_device_id, idProduct);\r\nDEF_FIELD(symval, usb_device_id, bcdDevice_lo);\r\nDEF_FIELD(symval, usb_device_id, bDeviceClass);\r\nDEF_FIELD(symval, usb_device_id, bDeviceSubClass);\r\nDEF_FIELD(symval, usb_device_id, bDeviceProtocol);\r\nDEF_FIELD(symval, usb_device_id, bInterfaceClass);\r\nDEF_FIELD(symval, usb_device_id, bInterfaceSubClass);\r\nDEF_FIELD(symval, usb_device_id, bInterfaceProtocol);\r\nDEF_FIELD(symval, usb_device_id, bInterfaceNumber);\r\nstrcpy(alias, "usb:");\r\nADD(alias, "v", match_flags&USB_DEVICE_ID_MATCH_VENDOR,\r\nidVendor);\r\nADD(alias, "p", match_flags&USB_DEVICE_ID_MATCH_PRODUCT,\r\nidProduct);\r\nstrcat(alias, "d");\r\nif (bcdDevice_initial_digits)\r\nsprintf(alias + strlen(alias), "%0*X",\r\nbcdDevice_initial_digits, bcdDevice_initial);\r\nif (range_lo == range_hi)\r\nsprintf(alias + strlen(alias), "%X", range_lo);\r\nelse if (range_lo > 0 || range_hi < max) {\r\nif (range_lo > 0x9 || range_hi < 0xA)\r\nsprintf(alias + strlen(alias),\r\n"[%X-%X]",\r\nrange_lo,\r\nrange_hi);\r\nelse {\r\nsprintf(alias + strlen(alias),\r\nrange_lo < 0x9 ? "[%X-9" : "[%X",\r\nrange_lo);\r\nsprintf(alias + strlen(alias),\r\nrange_hi > 0xA ? "a-%X]" : "%X]",\r\nrange_lo);\r\n}\r\n}\r\nif (bcdDevice_initial_digits < (sizeof(bcdDevice_lo) * 2 - 1))\r\nstrcat(alias, "*");\r\nADD(alias, "dc", match_flags&USB_DEVICE_ID_MATCH_DEV_CLASS,\r\nbDeviceClass);\r\nADD(alias, "dsc", match_flags&USB_DEVICE_ID_MATCH_DEV_SUBCLASS,\r\nbDeviceSubClass);\r\nADD(alias, "dp", match_flags&USB_DEVICE_ID_MATCH_DEV_PROTOCOL,\r\nbDeviceProtocol);\r\nADD(alias, "ic", match_flags&USB_DEVICE_ID_MATCH_INT_CLASS,\r\nbInterfaceClass);\r\nADD(alias, "isc", match_flags&USB_DEVICE_ID_MATCH_INT_SUBCLASS,\r\nbInterfaceSubClass);\r\nADD(alias, "ip", match_flags&USB_DEVICE_ID_MATCH_INT_PROTOCOL,\r\nbInterfaceProtocol);\r\nADD(alias, "in", match_flags&USB_DEVICE_ID_MATCH_INT_NUMBER,\r\nbInterfaceNumber);\r\nadd_wildcard(alias);\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"%s\");\n", alias);\r\n}\r\nstatic unsigned int incbcd(unsigned int *bcd,\r\nint inc,\r\nunsigned char max,\r\nsize_t chars)\r\n{\r\nunsigned int init = *bcd, i, j;\r\nunsigned long long c, dec = 0;\r\nif (max > 0x9) {\r\n*bcd += inc;\r\nreturn init;\r\n}\r\nfor (i=0 ; i < chars ; i++) {\r\nc = (*bcd >> (i << 2)) & 0xf;\r\nc = c > 9 ? 9 : c;\r\nfor (j=0 ; j < i ; j++)\r\nc = c * 10;\r\ndec += c;\r\n}\r\ndec += inc;\r\n*bcd = 0;\r\nfor (i=0 ; i < chars ; i++) {\r\nfor (c=1,j=0 ; j < i ; j++)\r\nc = c * 10;\r\nc = (dec / c) % 10;\r\n*bcd += c << (i << 2);\r\n}\r\nreturn init;\r\n}\r\nstatic void do_usb_entry_multi(void *symval, struct module *mod)\r\n{\r\nunsigned int devlo, devhi;\r\nunsigned char chi, clo, max;\r\nint ndigits;\r\nDEF_FIELD(symval, usb_device_id, match_flags);\r\nDEF_FIELD(symval, usb_device_id, idVendor);\r\nDEF_FIELD(symval, usb_device_id, idProduct);\r\nDEF_FIELD(symval, usb_device_id, bcdDevice_lo);\r\nDEF_FIELD(symval, usb_device_id, bcdDevice_hi);\r\nDEF_FIELD(symval, usb_device_id, bDeviceClass);\r\nDEF_FIELD(symval, usb_device_id, bInterfaceClass);\r\ndevlo = match_flags & USB_DEVICE_ID_MATCH_DEV_LO ?\r\nbcdDevice_lo : 0x0U;\r\ndevhi = match_flags & USB_DEVICE_ID_MATCH_DEV_HI ?\r\nbcdDevice_hi : ~0x0U;\r\nmax = 0x9;\r\nfor (ndigits = 0 ; ndigits < sizeof(bcdDevice_lo) * 2 ; ndigits++) {\r\nclo = (devlo >> (ndigits << 2)) & 0xf;\r\nchi = ((devhi > 0x9999 ? 0x9999 : devhi) >> (ndigits << 2)) & 0xf;\r\nif (clo > max || chi > max) {\r\nmax = 0xf;\r\nbreak;\r\n}\r\n}\r\nif (!(idVendor | idProduct | bDeviceClass | bInterfaceClass))\r\nreturn;\r\nfor (ndigits = sizeof(bcdDevice_lo) * 2 - 1; devlo <= devhi; ndigits--) {\r\nclo = devlo & 0xf;\r\nchi = devhi & 0xf;\r\nif (chi > max)\r\nchi = max;\r\ndevlo >>= 4;\r\ndevhi >>= 4;\r\nif (devlo == devhi || !ndigits) {\r\ndo_usb_entry(symval, devlo, ndigits, clo, chi, max, mod);\r\nbreak;\r\n}\r\nif (clo > 0x0)\r\ndo_usb_entry(symval,\r\nincbcd(&devlo, 1, max,\r\nsizeof(bcdDevice_lo) * 2),\r\nndigits, clo, max, max, mod);\r\nif (chi < max)\r\ndo_usb_entry(symval,\r\nincbcd(&devhi, -1, max,\r\nsizeof(bcdDevice_lo) * 2),\r\nndigits, 0x0, chi, max, mod);\r\n}\r\n}\r\nstatic void do_usb_table(void *symval, unsigned long size,\r\nstruct module *mod)\r\n{\r\nunsigned int i;\r\nconst unsigned long id_size = SIZE_usb_device_id;\r\ndevice_id_check(mod->name, "usb", size, id_size, symval);\r\nsize -= id_size;\r\nfor (i = 0; i < size; i += id_size)\r\ndo_usb_entry_multi(symval + i, mod);\r\n}\r\nstatic int do_hid_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, hid_device_id, bus);\r\nDEF_FIELD(symval, hid_device_id, group);\r\nDEF_FIELD(symval, hid_device_id, vendor);\r\nDEF_FIELD(symval, hid_device_id, product);\r\nsprintf(alias, "hid:");\r\nADD(alias, "b", bus != HID_BUS_ANY, bus);\r\nADD(alias, "g", group != HID_GROUP_ANY, group);\r\nADD(alias, "v", vendor != HID_ANY_ID, vendor);\r\nADD(alias, "p", product != HID_ANY_ID, product);\r\nreturn 1;\r\n}\r\nstatic int do_ieee1394_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, ieee1394_device_id, match_flags);\r\nDEF_FIELD(symval, ieee1394_device_id, vendor_id);\r\nDEF_FIELD(symval, ieee1394_device_id, model_id);\r\nDEF_FIELD(symval, ieee1394_device_id, specifier_id);\r\nDEF_FIELD(symval, ieee1394_device_id, version);\r\nstrcpy(alias, "ieee1394:");\r\nADD(alias, "ven", match_flags & IEEE1394_MATCH_VENDOR_ID,\r\nvendor_id);\r\nADD(alias, "mo", match_flags & IEEE1394_MATCH_MODEL_ID,\r\nmodel_id);\r\nADD(alias, "sp", match_flags & IEEE1394_MATCH_SPECIFIER_ID,\r\nspecifier_id);\r\nADD(alias, "ver", match_flags & IEEE1394_MATCH_VERSION,\r\nversion);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_pci_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nunsigned char baseclass, subclass, interface,\r\nbaseclass_mask, subclass_mask, interface_mask;\r\nDEF_FIELD(symval, pci_device_id, vendor);\r\nDEF_FIELD(symval, pci_device_id, device);\r\nDEF_FIELD(symval, pci_device_id, subvendor);\r\nDEF_FIELD(symval, pci_device_id, subdevice);\r\nDEF_FIELD(symval, pci_device_id, class);\r\nDEF_FIELD(symval, pci_device_id, class_mask);\r\nstrcpy(alias, "pci:");\r\nADD(alias, "v", vendor != PCI_ANY_ID, vendor);\r\nADD(alias, "d", device != PCI_ANY_ID, device);\r\nADD(alias, "sv", subvendor != PCI_ANY_ID, subvendor);\r\nADD(alias, "sd", subdevice != PCI_ANY_ID, subdevice);\r\nbaseclass = (class) >> 16;\r\nbaseclass_mask = (class_mask) >> 16;\r\nsubclass = (class) >> 8;\r\nsubclass_mask = (class_mask) >> 8;\r\ninterface = class;\r\ninterface_mask = class_mask;\r\nif ((baseclass_mask != 0 && baseclass_mask != 0xFF)\r\n|| (subclass_mask != 0 && subclass_mask != 0xFF)\r\n|| (interface_mask != 0 && interface_mask != 0xFF)) {\r\nwarn("Can't handle masks in %s:%04X\n",\r\nfilename, class_mask);\r\nreturn 0;\r\n}\r\nADD(alias, "bc", baseclass_mask == 0xFF, baseclass);\r\nADD(alias, "sc", subclass_mask == 0xFF, subclass);\r\nADD(alias, "i", interface_mask == 0xFF, interface);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_ccw_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, ccw_device_id, match_flags);\r\nDEF_FIELD(symval, ccw_device_id, cu_type);\r\nDEF_FIELD(symval, ccw_device_id, cu_model);\r\nDEF_FIELD(symval, ccw_device_id, dev_type);\r\nDEF_FIELD(symval, ccw_device_id, dev_model);\r\nstrcpy(alias, "ccw:");\r\nADD(alias, "t", match_flags&CCW_DEVICE_ID_MATCH_CU_TYPE,\r\ncu_type);\r\nADD(alias, "m", match_flags&CCW_DEVICE_ID_MATCH_CU_MODEL,\r\ncu_model);\r\nADD(alias, "dt", match_flags&CCW_DEVICE_ID_MATCH_DEVICE_TYPE,\r\ndev_type);\r\nADD(alias, "dm", match_flags&CCW_DEVICE_ID_MATCH_DEVICE_MODEL,\r\ndev_model);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_ap_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, ap_device_id, dev_type);\r\nsprintf(alias, "ap:t%02X*", dev_type);\r\nreturn 1;\r\n}\r\nstatic int do_css_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, css_device_id, type);\r\nsprintf(alias, "css:t%01X", type);\r\nreturn 1;\r\n}\r\nstatic int do_serio_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, serio_device_id, type);\r\nDEF_FIELD(symval, serio_device_id, proto);\r\nDEF_FIELD(symval, serio_device_id, id);\r\nDEF_FIELD(symval, serio_device_id, extra);\r\nstrcpy(alias, "serio:");\r\nADD(alias, "ty", type != SERIO_ANY, type);\r\nADD(alias, "pr", proto != SERIO_ANY, proto);\r\nADD(alias, "id", id != SERIO_ANY, id);\r\nADD(alias, "ex", extra != SERIO_ANY, extra);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_acpi_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD_ADDR(symval, acpi_device_id, id);\r\nsprintf(alias, "acpi*:%s:*", *id);\r\nreturn 1;\r\n}\r\nstatic void do_pnp_device_entry(void *symval, unsigned long size,\r\nstruct module *mod)\r\n{\r\nconst unsigned long id_size = SIZE_pnp_device_id;\r\nconst unsigned int count = (size / id_size)-1;\r\nunsigned int i;\r\ndevice_id_check(mod->name, "pnp", size, id_size, symval);\r\nfor (i = 0; i < count; i++) {\r\nDEF_FIELD_ADDR(symval + i*id_size, pnp_device_id, id);\r\nchar acpi_id[sizeof(*id)];\r\nint j;\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"pnp:d%s*\");\n", *id);\r\nfor (j = 0; j < sizeof(acpi_id); j++)\r\nacpi_id[j] = toupper((*id)[j]);\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"acpi*:%s:*\");\n", acpi_id);\r\n}\r\n}\r\nstatic void do_pnp_card_entries(void *symval, unsigned long size,\r\nstruct module *mod)\r\n{\r\nconst unsigned long id_size = SIZE_pnp_card_device_id;\r\nconst unsigned int count = (size / id_size)-1;\r\nunsigned int i;\r\ndevice_id_check(mod->name, "pnp", size, id_size, symval);\r\nfor (i = 0; i < count; i++) {\r\nunsigned int j;\r\nDEF_FIELD_ADDR(symval + i*id_size, pnp_card_device_id, devs);\r\nfor (j = 0; j < PNP_MAX_DEVICES; j++) {\r\nconst char *id = (char *)(*devs)[j].id;\r\nint i2, j2;\r\nint dup = 0;\r\nif (!id[0])\r\nbreak;\r\nfor (i2 = 0; i2 < i && !dup; i2++) {\r\nDEF_FIELD_ADDR(symval + i2*id_size, pnp_card_device_id, devs);\r\nfor (j2 = 0; j2 < PNP_MAX_DEVICES; j2++) {\r\nconst char *id2 = (char *)(*devs)[j2].id;\r\nif (!id2[0])\r\nbreak;\r\nif (!strcmp(id, id2)) {\r\ndup = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!dup) {\r\nchar acpi_id[PNP_ID_LEN];\r\nint k;\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"pnp:d%s*\");\n", id);\r\nfor (k = 0; k < sizeof(acpi_id); k++)\r\nacpi_id[k] = toupper(id[k]);\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"acpi*:%s:*\");\n", acpi_id);\r\n}\r\n}\r\n}\r\n}\r\nstatic int do_pcmcia_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nunsigned int i;\r\nDEF_FIELD(symval, pcmcia_device_id, match_flags);\r\nDEF_FIELD(symval, pcmcia_device_id, manf_id);\r\nDEF_FIELD(symval, pcmcia_device_id, card_id);\r\nDEF_FIELD(symval, pcmcia_device_id, func_id);\r\nDEF_FIELD(symval, pcmcia_device_id, function);\r\nDEF_FIELD(symval, pcmcia_device_id, device_no);\r\nDEF_FIELD_ADDR(symval, pcmcia_device_id, prod_id_hash);\r\nfor (i=0; i<4; i++) {\r\n(*prod_id_hash)[i] = TO_NATIVE((*prod_id_hash)[i]);\r\n}\r\nstrcpy(alias, "pcmcia:");\r\nADD(alias, "m", match_flags & PCMCIA_DEV_ID_MATCH_MANF_ID,\r\nmanf_id);\r\nADD(alias, "c", match_flags & PCMCIA_DEV_ID_MATCH_CARD_ID,\r\ncard_id);\r\nADD(alias, "f", match_flags & PCMCIA_DEV_ID_MATCH_FUNC_ID,\r\nfunc_id);\r\nADD(alias, "fn", match_flags & PCMCIA_DEV_ID_MATCH_FUNCTION,\r\nfunction);\r\nADD(alias, "pfn", match_flags & PCMCIA_DEV_ID_MATCH_DEVICE_NO,\r\ndevice_no);\r\nADD(alias, "pa", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID1, (*prod_id_hash)[0]);\r\nADD(alias, "pb", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID2, (*prod_id_hash)[1]);\r\nADD(alias, "pc", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID3, (*prod_id_hash)[2]);\r\nADD(alias, "pd", match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID4, (*prod_id_hash)[3]);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_of_entry (const char *filename, void *symval, char *alias)\r\n{\r\nint len;\r\nchar *tmp;\r\nDEF_FIELD_ADDR(symval, of_device_id, name);\r\nDEF_FIELD_ADDR(symval, of_device_id, type);\r\nDEF_FIELD_ADDR(symval, of_device_id, compatible);\r\nlen = sprintf (alias, "of:N%sT%s",\r\n(*name)[0] ? *name : "*",\r\n(*type)[0] ? *type : "*");\r\nif (compatible[0])\r\nsprintf (&alias[len], "%sC%s",\r\n(*type)[0] ? "*" : "",\r\n*compatible);\r\nfor (tmp = alias; tmp && *tmp; tmp++)\r\nif (isspace (*tmp))\r\n*tmp = '_';\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_vio_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nchar *tmp;\r\nDEF_FIELD_ADDR(symval, vio_device_id, type);\r\nDEF_FIELD_ADDR(symval, vio_device_id, compat);\r\nsprintf(alias, "vio:T%sS%s", (*type)[0] ? *type : "*",\r\n(*compat)[0] ? *compat : "*");\r\nfor (tmp = alias; tmp && *tmp; tmp++)\r\nif (isspace (*tmp))\r\n*tmp = '_';\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic void do_input(char *alias,\r\nkernel_ulong_t *arr, unsigned int min, unsigned int max)\r\n{\r\nunsigned int i;\r\nfor (i = min / BITS_PER_LONG; i < max / BITS_PER_LONG + 1; i++)\r\narr[i] = TO_NATIVE(arr[i]);\r\nfor (i = min; i < max; i++)\r\nif (arr[i / BITS_PER_LONG] & (1L << (i%BITS_PER_LONG)))\r\nsprintf(alias + strlen(alias), "%X,*", i);\r\n}\r\nstatic int do_input_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD(symval, input_device_id, flags);\r\nDEF_FIELD(symval, input_device_id, bustype);\r\nDEF_FIELD(symval, input_device_id, vendor);\r\nDEF_FIELD(symval, input_device_id, product);\r\nDEF_FIELD(symval, input_device_id, version);\r\nDEF_FIELD_ADDR(symval, input_device_id, evbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, keybit);\r\nDEF_FIELD_ADDR(symval, input_device_id, relbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, absbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, mscbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, ledbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, sndbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, ffbit);\r\nDEF_FIELD_ADDR(symval, input_device_id, swbit);\r\nsprintf(alias, "input:");\r\nADD(alias, "b", flags & INPUT_DEVICE_ID_MATCH_BUS, bustype);\r\nADD(alias, "v", flags & INPUT_DEVICE_ID_MATCH_VENDOR, vendor);\r\nADD(alias, "p", flags & INPUT_DEVICE_ID_MATCH_PRODUCT, product);\r\nADD(alias, "e", flags & INPUT_DEVICE_ID_MATCH_VERSION, version);\r\nsprintf(alias + strlen(alias), "-e*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_EVBIT)\r\ndo_input(alias, *evbit, 0, INPUT_DEVICE_ID_EV_MAX);\r\nsprintf(alias + strlen(alias), "k*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_KEYBIT)\r\ndo_input(alias, *keybit,\r\nINPUT_DEVICE_ID_KEY_MIN_INTERESTING,\r\nINPUT_DEVICE_ID_KEY_MAX);\r\nsprintf(alias + strlen(alias), "r*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_RELBIT)\r\ndo_input(alias, *relbit, 0, INPUT_DEVICE_ID_REL_MAX);\r\nsprintf(alias + strlen(alias), "a*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_ABSBIT)\r\ndo_input(alias, *absbit, 0, INPUT_DEVICE_ID_ABS_MAX);\r\nsprintf(alias + strlen(alias), "m*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_MSCIT)\r\ndo_input(alias, *mscbit, 0, INPUT_DEVICE_ID_MSC_MAX);\r\nsprintf(alias + strlen(alias), "l*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_LEDBIT)\r\ndo_input(alias, *ledbit, 0, INPUT_DEVICE_ID_LED_MAX);\r\nsprintf(alias + strlen(alias), "s*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_SNDBIT)\r\ndo_input(alias, *sndbit, 0, INPUT_DEVICE_ID_SND_MAX);\r\nsprintf(alias + strlen(alias), "f*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_FFBIT)\r\ndo_input(alias, *ffbit, 0, INPUT_DEVICE_ID_FF_MAX);\r\nsprintf(alias + strlen(alias), "w*");\r\nif (flags & INPUT_DEVICE_ID_MATCH_SWBIT)\r\ndo_input(alias, *swbit, 0, INPUT_DEVICE_ID_SW_MAX);\r\nreturn 1;\r\n}\r\nstatic int do_eisa_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD_ADDR(symval, eisa_device_id, sig);\r\nif (sig[0])\r\nsprintf(alias, EISA_DEVICE_MODALIAS_FMT "*", *sig);\r\nelse\r\nstrcat(alias, "*");\r\nreturn 1;\r\n}\r\nstatic int do_parisc_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD(symval, parisc_device_id, hw_type);\r\nDEF_FIELD(symval, parisc_device_id, hversion);\r\nDEF_FIELD(symval, parisc_device_id, hversion_rev);\r\nDEF_FIELD(symval, parisc_device_id, sversion);\r\nstrcpy(alias, "parisc:");\r\nADD(alias, "t", hw_type != PA_HWTYPE_ANY_ID, hw_type);\r\nADD(alias, "hv", hversion != PA_HVERSION_ANY_ID, hversion);\r\nADD(alias, "rev", hversion_rev != PA_HVERSION_REV_ANY_ID, hversion_rev);\r\nADD(alias, "sv", sversion != PA_SVERSION_ANY_ID, sversion);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_sdio_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, sdio_device_id, class);\r\nDEF_FIELD(symval, sdio_device_id, vendor);\r\nDEF_FIELD(symval, sdio_device_id, device);\r\nstrcpy(alias, "sdio:");\r\nADD(alias, "c", class != (__u8)SDIO_ANY_ID, class);\r\nADD(alias, "v", vendor != (__u16)SDIO_ANY_ID, vendor);\r\nADD(alias, "d", device != (__u16)SDIO_ANY_ID, device);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_ssb_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, ssb_device_id, vendor);\r\nDEF_FIELD(symval, ssb_device_id, coreid);\r\nDEF_FIELD(symval, ssb_device_id, revision);\r\nstrcpy(alias, "ssb:");\r\nADD(alias, "v", vendor != SSB_ANY_VENDOR, vendor);\r\nADD(alias, "id", coreid != SSB_ANY_ID, coreid);\r\nADD(alias, "rev", revision != SSB_ANY_REV, revision);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_bcma_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, bcma_device_id, manuf);\r\nDEF_FIELD(symval, bcma_device_id, id);\r\nDEF_FIELD(symval, bcma_device_id, rev);\r\nDEF_FIELD(symval, bcma_device_id, class);\r\nstrcpy(alias, "bcma:");\r\nADD(alias, "m", manuf != BCMA_ANY_MANUF, manuf);\r\nADD(alias, "id", id != BCMA_ANY_ID, id);\r\nADD(alias, "rev", rev != BCMA_ANY_REV, rev);\r\nADD(alias, "cl", class != BCMA_ANY_CLASS, class);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_virtio_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD(symval, virtio_device_id, device);\r\nDEF_FIELD(symval, virtio_device_id, vendor);\r\nstrcpy(alias, "virtio:");\r\nADD(alias, "d", device != VIRTIO_DEV_ANY_ID, device);\r\nADD(alias, "v", vendor != VIRTIO_DEV_ANY_ID, vendor);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic int do_vmbus_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nint i;\r\nDEF_FIELD_ADDR(symval, hv_vmbus_device_id, guid);\r\nchar guid_name[(sizeof(*guid) + 1) * 2];\r\nfor (i = 0; i < (sizeof(*guid) * 2); i += 2)\r\nsprintf(&guid_name[i], "%02x", TO_NATIVE((*guid)[i/2]));\r\nstrcpy(alias, "vmbus:");\r\nstrcat(alias, guid_name);\r\nreturn 1;\r\n}\r\nstatic int do_i2c_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD_ADDR(symval, i2c_device_id, name);\r\nsprintf(alias, I2C_MODULE_PREFIX "%s", *name);\r\nreturn 1;\r\n}\r\nstatic int do_spi_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD_ADDR(symval, spi_device_id, name);\r\nsprintf(alias, SPI_MODULE_PREFIX "%s", *name);\r\nreturn 1;\r\n}\r\nstatic void dmi_ascii_filter(char *d, const char *s)\r\n{\r\nfor (; *s; s++)\r\nif (*s > ' ' && *s < 127 && *s != ':')\r\n*(d++) = *s;\r\n*d = 0;\r\n}\r\nstatic int do_dmi_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nint i, j;\r\nDEF_FIELD_ADDR(symval, dmi_system_id, matches);\r\nsprintf(alias, "dmi*");\r\nfor (i = 0; i < ARRAY_SIZE(dmi_fields); i++) {\r\nfor (j = 0; j < 4; j++) {\r\nif ((*matches)[j].slot &&\r\n(*matches)[j].slot == dmi_fields[i].field) {\r\nsprintf(alias + strlen(alias), ":%s*",\r\ndmi_fields[i].prefix);\r\ndmi_ascii_filter(alias + strlen(alias),\r\n(*matches)[j].substr);\r\nstrcat(alias, "*");\r\n}\r\n}\r\n}\r\nstrcat(alias, ":");\r\nreturn 1;\r\n}\r\nstatic int do_platform_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD_ADDR(symval, platform_device_id, name);\r\nsprintf(alias, PLATFORM_MODULE_PREFIX "%s", *name);\r\nreturn 1;\r\n}\r\nstatic int do_mdio_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nint i;\r\nDEF_FIELD(symval, mdio_device_id, phy_id);\r\nDEF_FIELD(symval, mdio_device_id, phy_id_mask);\r\nalias += sprintf(alias, MDIO_MODULE_PREFIX);\r\nfor (i = 0; i < 32; i++) {\r\nif (!((phy_id_mask >> (31-i)) & 1))\r\n*(alias++) = '?';\r\nelse if ((phy_id >> (31-i)) & 1)\r\n*(alias++) = '1';\r\nelse\r\n*(alias++) = '0';\r\n}\r\n*alias = 0;\r\nreturn 1;\r\n}\r\nstatic int do_zorro_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD(symval, zorro_device_id, id);\r\nstrcpy(alias, "zorro:");\r\nADD(alias, "i", id != ZORRO_WILDCARD, id);\r\nreturn 1;\r\n}\r\nstatic int do_isapnp_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, isapnp_device_id, vendor);\r\nDEF_FIELD(symval, isapnp_device_id, function);\r\nsprintf(alias, "pnp:d%c%c%c%x%x%x%x*",\r\n'A' + ((vendor >> 2) & 0x3f) - 1,\r\n'A' + (((vendor & 3) << 3) | ((vendor >> 13) & 7)) - 1,\r\n'A' + ((vendor >> 8) & 0x1f) - 1,\r\n(function >> 4) & 0x0f, function & 0x0f,\r\n(function >> 12) & 0x0f, (function >> 8) & 0x0f);\r\nreturn 1;\r\n}\r\nstatic int do_ipack_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, ipack_device_id, format);\r\nDEF_FIELD(symval, ipack_device_id, vendor);\r\nDEF_FIELD(symval, ipack_device_id, device);\r\nstrcpy(alias, "ipack:");\r\nADD(alias, "f", format != IPACK_ANY_FORMAT, format);\r\nADD(alias, "v", vendor != IPACK_ANY_ID, vendor);\r\nADD(alias, "d", device != IPACK_ANY_ID, device);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic void append_nibble_mask(char **outp,\r\nunsigned int nibble, unsigned int mask)\r\n{\r\nchar *p = *outp;\r\nunsigned int i;\r\nswitch (mask) {\r\ncase 0:\r\n*p++ = '?';\r\nbreak;\r\ncase 0xf:\r\np += sprintf(p, "%X", nibble);\r\nbreak;\r\ndefault:\r\n*p++ = '[';\r\nfor (i = 0; i < 0x10; i++)\r\nif ((i & mask) == nibble)\r\np += sprintf(p, "%X", i);\r\n*p++ = ']';\r\n}\r\n*p = '\0';\r\n*outp = p;\r\n}\r\nstatic int do_amba_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nunsigned int digit;\r\nchar *p = alias;\r\nDEF_FIELD(symval, amba_id, id);\r\nDEF_FIELD(symval, amba_id, mask);\r\nif ((id & mask) != id)\r\nfatal("%s: Masked-off bit(s) of AMBA device ID are non-zero: "\r\n"id=0x%08X, mask=0x%08X. Please fix this driver.\n",\r\nfilename, id, mask);\r\np += sprintf(alias, "amba:d");\r\nfor (digit = 0; digit < 8; digit++)\r\nappend_nibble_mask(&p,\r\n(id >> (4 * (7 - digit))) & 0xf,\r\n(mask >> (4 * (7 - digit))) & 0xf);\r\nreturn 1;\r\n}\r\nstatic int do_x86cpu_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD(symval, x86_cpu_id, feature);\r\nDEF_FIELD(symval, x86_cpu_id, family);\r\nDEF_FIELD(symval, x86_cpu_id, model);\r\nDEF_FIELD(symval, x86_cpu_id, vendor);\r\nstrcpy(alias, "x86cpu:");\r\nADD(alias, "vendor:", vendor != X86_VENDOR_ANY, vendor);\r\nADD(alias, ":family:", family != X86_FAMILY_ANY, family);\r\nADD(alias, ":model:", model != X86_MODEL_ANY, model);\r\nstrcat(alias, ":feature:*");\r\nif (feature != X86_FEATURE_ANY)\r\nsprintf(alias + strlen(alias), "%04X*", feature);\r\nreturn 1;\r\n}\r\nstatic int do_mei_entry(const char *filename, void *symval,\r\nchar *alias)\r\n{\r\nDEF_FIELD_ADDR(symval, mei_cl_device_id, name);\r\nsprintf(alias, MEI_CL_MODULE_PREFIX "%s", *name);\r\nreturn 1;\r\n}\r\nstatic int do_rio_entry(const char *filename,\r\nvoid *symval, char *alias)\r\n{\r\nDEF_FIELD(symval, rio_device_id, did);\r\nDEF_FIELD(symval, rio_device_id, vid);\r\nDEF_FIELD(symval, rio_device_id, asm_did);\r\nDEF_FIELD(symval, rio_device_id, asm_vid);\r\nstrcpy(alias, "rapidio:");\r\nADD(alias, "v", vid != RIO_ANY_ID, vid);\r\nADD(alias, "d", did != RIO_ANY_ID, did);\r\nADD(alias, "av", asm_vid != RIO_ANY_ID, asm_vid);\r\nADD(alias, "ad", asm_did != RIO_ANY_ID, asm_did);\r\nadd_wildcard(alias);\r\nreturn 1;\r\n}\r\nstatic bool sym_is(const char *name, unsigned namelen, const char *symbol)\r\n{\r\nif (namelen != strlen(symbol))\r\nreturn false;\r\nreturn memcmp(name, symbol, namelen) == 0;\r\n}\r\nstatic void do_table(void *symval, unsigned long size,\r\nunsigned long id_size,\r\nconst char *device_id,\r\nvoid *function,\r\nstruct module *mod)\r\n{\r\nunsigned int i;\r\nchar alias[500];\r\nint (*do_entry)(const char *, void *entry, char *alias) = function;\r\ndevice_id_check(mod->name, device_id, size, id_size, symval);\r\nsize -= id_size;\r\nfor (i = 0; i < size; i += id_size) {\r\nif (do_entry(mod->name, symval+i, alias)) {\r\nbuf_printf(&mod->dev_table_buf,\r\n"MODULE_ALIAS(\"%s\");\n", alias);\r\n}\r\n}\r\n}\r\nvoid handle_moddevtable(struct module *mod, struct elf_info *info,\r\nElf_Sym *sym, const char *symname)\r\n{\r\nvoid *symval;\r\nchar *zeros = NULL;\r\nconst char *name;\r\nunsigned int namelen;\r\nif (!sym->st_shndx || get_secindex(info, sym) >= info->num_sections)\r\nreturn;\r\nif (ELF_ST_TYPE(sym->st_info) != STT_OBJECT)\r\nreturn;\r\nname = strstr(symname, "__mod_");\r\nif (!name)\r\nreturn;\r\nname += strlen("__mod_");\r\nnamelen = strlen(name);\r\nif (namelen < strlen("_device_table"))\r\nreturn;\r\nif (strcmp(name + namelen - strlen("_device_table"), "_device_table"))\r\nreturn;\r\nnamelen -= strlen("_device_table");\r\nif (info->sechdrs[get_secindex(info, sym)].sh_type & SHT_NOBITS) {\r\nzeros = calloc(1, sym->st_size);\r\nsymval = zeros;\r\n} else {\r\nsymval = (void *)info->hdr\r\n+ info->sechdrs[get_secindex(info, sym)].sh_offset\r\n+ sym->st_value;\r\n}\r\nif (sym_is(name, namelen, "usb"))\r\ndo_usb_table(symval, sym->st_size, mod);\r\nelse if (sym_is(name, namelen, "pnp"))\r\ndo_pnp_device_entry(symval, sym->st_size, mod);\r\nelse if (sym_is(name, namelen, "pnp_card"))\r\ndo_pnp_card_entries(symval, sym->st_size, mod);\r\nelse {\r\nstruct devtable **p;\r\nINIT_SECTION(__devtable);\r\nfor (p = __start___devtable; p < __stop___devtable; p++) {\r\nif (sym_is(name, namelen, (*p)->device_id)) {\r\ndo_table(symval, sym->st_size, (*p)->id_size,\r\n(*p)->device_id, (*p)->function, mod);\r\nbreak;\r\n}\r\n}\r\n}\r\nfree(zeros);\r\n}\r\nvoid add_moddevtable(struct buffer *buf, struct module *mod)\r\n{\r\nbuf_printf(buf, "\n");\r\nbuf_write(buf, mod->dev_table_buf.p, mod->dev_table_buf.pos);\r\nfree(mod->dev_table_buf.p);\r\n}
