static int davinci_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nstruct davinci_cpufreq_config *pdata = cpufreq.dev->platform_data;\r\nstruct cpufreq_frequency_table *freq_table = pdata->freq_table;\r\nstruct clk *armclk = cpufreq.armclk;\r\nif (freq_table)\r\nreturn cpufreq_frequency_table_verify(policy, freq_table);\r\nif (policy->cpu)\r\nreturn -EINVAL;\r\ncpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\npolicy->min = clk_round_rate(armclk, policy->min * 1000) / 1000;\r\npolicy->max = clk_round_rate(armclk, policy->max * 1000) / 1000;\r\ncpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\r\npolicy->cpuinfo.max_freq);\r\nreturn 0;\r\n}\r\nstatic unsigned int davinci_getspeed(unsigned int cpu)\r\n{\r\nif (cpu)\r\nreturn 0;\r\nreturn clk_get_rate(cpufreq.armclk) / 1000;\r\n}\r\nstatic int davinci_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq, unsigned int relation)\r\n{\r\nint ret = 0;\r\nunsigned int idx;\r\nstruct cpufreq_freqs freqs;\r\nstruct davinci_cpufreq_config *pdata = cpufreq.dev->platform_data;\r\nstruct clk *armclk = cpufreq.armclk;\r\nfreqs.old = davinci_getspeed(0);\r\nfreqs.new = clk_round_rate(armclk, target_freq * 1000) / 1000;\r\nif (freqs.old == freqs.new)\r\nreturn ret;\r\ndev_dbg(cpufreq.dev, "transition: %u --> %u\n", freqs.old, freqs.new);\r\nret = cpufreq_frequency_table_target(policy, pdata->freq_table,\r\nfreqs.new, relation, &idx);\r\nif (ret)\r\nreturn -EINVAL;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nif (pdata->set_voltage && freqs.new > freqs.old) {\r\nret = pdata->set_voltage(idx);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = clk_set_rate(armclk, idx);\r\nif (ret)\r\ngoto out;\r\nif (cpufreq.asyncclk) {\r\nret = clk_set_rate(cpufreq.asyncclk, cpufreq.asyncrate);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (pdata->set_voltage && freqs.new < freqs.old)\r\npdata->set_voltage(idx);\r\nout:\r\nif (ret)\r\nfreqs.new = freqs.old;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\nreturn ret;\r\n}\r\nstatic int davinci_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint result = 0;\r\nstruct davinci_cpufreq_config *pdata = cpufreq.dev->platform_data;\r\nstruct cpufreq_frequency_table *freq_table = pdata->freq_table;\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\nif (pdata->init) {\r\nresult = pdata->init();\r\nif (result)\r\nreturn result;\r\n}\r\npolicy->cur = davinci_getspeed(0);\r\nresult = cpufreq_frequency_table_cpuinfo(policy, freq_table);\r\nif (result) {\r\npr_err("%s: cpufreq_frequency_table_cpuinfo() failed",\r\n__func__);\r\nreturn result;\r\n}\r\ncpufreq_frequency_table_get_attr(freq_table, policy->cpu);\r\npolicy->cpuinfo.transition_latency = 2000 * 1000;\r\nreturn 0;\r\n}\r\nstatic int davinci_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_cpufreq_config *pdata = pdev->dev.platform_data;\r\nstruct clk *asyncclk;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (!pdata->freq_table)\r\nreturn -EINVAL;\r\ncpufreq.dev = &pdev->dev;\r\ncpufreq.armclk = clk_get(NULL, "arm");\r\nif (IS_ERR(cpufreq.armclk)) {\r\ndev_err(cpufreq.dev, "Unable to get ARM clock\n");\r\nreturn PTR_ERR(cpufreq.armclk);\r\n}\r\nasyncclk = clk_get(cpufreq.dev, "async");\r\nif (!IS_ERR(asyncclk)) {\r\ncpufreq.asyncclk = asyncclk;\r\ncpufreq.asyncrate = clk_get_rate(asyncclk);\r\n}\r\nreturn cpufreq_register_driver(&davinci_driver);\r\n}\r\nstatic int __exit davinci_cpufreq_remove(struct platform_device *pdev)\r\n{\r\nclk_put(cpufreq.armclk);\r\nif (cpufreq.asyncclk)\r\nclk_put(cpufreq.asyncclk);\r\nreturn cpufreq_unregister_driver(&davinci_driver);\r\n}\r\nint __init davinci_cpufreq_init(void)\r\n{\r\nreturn platform_driver_probe(&davinci_cpufreq_driver,\r\ndavinci_cpufreq_probe);\r\n}
