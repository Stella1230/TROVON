static int\r\nnv31_mpeg_object_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_gpuobj *obj;\r\nint ret;\r\nret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,\r\n20, 16, 0, &obj);\r\n*pobject = nv_object(obj);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(obj, 0x00, nv_mclass(obj));\r\nnv_wo32(obj, 0x04, 0x00000000);\r\nnv_wo32(obj, 0x08, 0x00000000);\r\nnv_wo32(obj, 0x0c, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv31_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)\r\n{\r\nstruct nouveau_instmem *imem = nouveau_instmem(object);\r\nstruct nv31_mpeg_priv *priv = (void *)object->engine;\r\nu32 inst = *(u32 *)arg << 4;\r\nu32 dma0 = nv_ro32(imem, inst + 0);\r\nu32 dma1 = nv_ro32(imem, inst + 4);\r\nu32 dma2 = nv_ro32(imem, inst + 8);\r\nu32 base = (dma2 & 0xfffff000) | (dma0 >> 20);\r\nu32 size = dma1 + 1;\r\nif (!(dma0 & 0x00002000))\r\nreturn -EINVAL;\r\nif (mthd == 0x0190) {\r\nnv_mask(priv, 0x00b300, 0x00030000, (dma0 & 0x00030000));\r\nnv_wr32(priv, 0x00b334, base);\r\nnv_wr32(priv, 0x00b324, size);\r\n} else\r\nif (mthd == 0x01a0) {\r\nnv_mask(priv, 0x00b300, 0x000c0000, (dma0 & 0x00030000) << 2);\r\nnv_wr32(priv, 0x00b360, base);\r\nnv_wr32(priv, 0x00b364, size);\r\n} else {\r\nif (dma0 & 0x000c0000)\r\nreturn -EINVAL;\r\nnv_wr32(priv, 0x00b370, base);\r\nnv_wr32(priv, 0x00b374, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv31_mpeg_context_ctor(struct nouveau_object *parent,\r\nstruct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nv31_mpeg_priv *priv = (void *)engine;\r\nstruct nv31_mpeg_chan *chan;\r\nint ret;\r\nif (!atomic_add_unless(&priv->refcount, 1, 1))\r\nreturn -EBUSY;\r\nret = nouveau_object_create(parent, engine, oclass, 0, &chan);\r\n*pobject = nv_object(chan);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv31_mpeg_context_dtor(struct nouveau_object *object)\r\n{\r\nstruct nv31_mpeg_priv *priv = (void *)object->engine;\r\nstruct nv31_mpeg_chan *chan = (void *)object;\r\natomic_dec(&priv->refcount);\r\nnouveau_object_destroy(&chan->base);\r\n}\r\nvoid\r\nnv31_mpeg_tile_prog(struct nouveau_engine *engine, int i)\r\n{\r\nstruct nouveau_fb_tile *tile = &nouveau_fb(engine)->tile.region[i];\r\nstruct nv31_mpeg_priv *priv = (void *)engine;\r\nnv_wr32(priv, 0x00b008 + (i * 0x10), tile->pitch);\r\nnv_wr32(priv, 0x00b004 + (i * 0x10), tile->limit);\r\nnv_wr32(priv, 0x00b000 + (i * 0x10), tile->addr);\r\n}\r\nvoid\r\nnv31_mpeg_intr(struct nouveau_subdev *subdev)\r\n{\r\nstruct nouveau_fifo *pfifo = nouveau_fifo(subdev);\r\nstruct nouveau_engine *engine = nv_engine(subdev);\r\nstruct nouveau_object *engctx;\r\nstruct nouveau_handle *handle;\r\nstruct nv31_mpeg_priv *priv = (void *)subdev;\r\nu32 inst = nv_rd32(priv, 0x00b318) & 0x000fffff;\r\nu32 stat = nv_rd32(priv, 0x00b100);\r\nu32 type = nv_rd32(priv, 0x00b230);\r\nu32 mthd = nv_rd32(priv, 0x00b234);\r\nu32 data = nv_rd32(priv, 0x00b238);\r\nu32 show = stat;\r\nint chid;\r\nengctx = nouveau_engctx_get(engine, inst);\r\nchid = pfifo->chid(pfifo, engctx);\r\nif (stat & 0x01000000) {\r\nif (type == 0x00000020 && mthd == 0x0000) {\r\nnv_mask(priv, 0x00b308, 0x00000000, 0x00000000);\r\nshow &= ~0x01000000;\r\n}\r\nif (type == 0x00000010) {\r\nhandle = nouveau_handle_get_class(engctx, 0x3174);\r\nif (handle && !nv_call(handle->object, mthd, data))\r\nshow &= ~0x01000000;\r\nnouveau_handle_put(handle);\r\n}\r\n}\r\nnv_wr32(priv, 0x00b100, stat);\r\nnv_wr32(priv, 0x00b230, 0x00000001);\r\nif (show) {\r\nnv_error(priv,\r\n"ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nchid, inst << 4, nouveau_client_name(engctx), stat,\r\ntype, mthd, data);\r\n}\r\nnouveau_engctx_put(engctx);\r\n}\r\nstatic int\r\nnv31_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nv31_mpeg_priv *priv;\r\nint ret;\r\nret = nouveau_mpeg_create(parent, engine, oclass, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\nnv_subdev(priv)->unit = 0x00000002;\r\nnv_subdev(priv)->intr = nv31_mpeg_intr;\r\nnv_engine(priv)->cclass = &nv31_mpeg_cclass;\r\nnv_engine(priv)->sclass = nv31_mpeg_sclass;\r\nnv_engine(priv)->tile_prog = nv31_mpeg_tile_prog;\r\nreturn 0;\r\n}\r\nint\r\nnv31_mpeg_init(struct nouveau_object *object)\r\n{\r\nstruct nouveau_engine *engine = nv_engine(object);\r\nstruct nv31_mpeg_priv *priv = (void *)object;\r\nstruct nouveau_fb *pfb = nouveau_fb(object);\r\nint ret, i;\r\nret = nouveau_mpeg_init(&priv->base);\r\nif (ret)\r\nreturn ret;\r\nnv_wr32(priv, 0x00b0e0, 0x00000020);\r\nnv_wr32(priv, 0x00b0e8, 0x00000020);\r\nfor (i = 0; i < pfb->tile.regions; i++)\r\nengine->tile_prog(engine, i);\r\nnv_wr32(priv, 0x00b32c, 0x00000000);\r\nnv_wr32(priv, 0x00b314, 0x00000100);\r\nif (nv_device(priv)->chipset >= 0x40 && nv44_graph_class(priv))\r\nnv_wr32(priv, 0x00b220, 0x00000044);\r\nelse\r\nnv_wr32(priv, 0x00b220, 0x00000031);\r\nnv_wr32(priv, 0x00b300, 0x02001ec1);\r\nnv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);\r\nnv_wr32(priv, 0x00b100, 0xffffffff);\r\nnv_wr32(priv, 0x00b140, 0xffffffff);\r\nif (!nv_wait(priv, 0x00b200, 0x00000001, 0x00000000)) {\r\nnv_error(priv, "timeout 0x%08x\n", nv_rd32(priv, 0x00b200));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}
