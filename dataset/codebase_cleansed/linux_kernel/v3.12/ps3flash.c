static int ps3flash_read_write_sectors(struct ps3_storage_device *dev,\r\nu64 start_sector, int write)\r\n{\r\nstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nu64 res = ps3stor_read_write_sectors(dev, dev->bounce_lpar,\r\nstart_sector, priv->chunk_sectors,\r\nwrite);\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: %s failed 0x%llx\n", __func__,\r\n__LINE__, write ? "write" : "read", res);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ps3flash_writeback(struct ps3_storage_device *dev)\r\n{\r\nstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nint res;\r\nif (!priv->dirty || priv->tag < 0)\r\nreturn 0;\r\nres = ps3flash_read_write_sectors(dev, priv->tag, 1);\r\nif (res)\r\nreturn res;\r\npriv->dirty = false;\r\nreturn 0;\r\n}\r\nstatic int ps3flash_fetch(struct ps3_storage_device *dev, u64 start_sector)\r\n{\r\nstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nint res;\r\nif (start_sector == priv->tag)\r\nreturn 0;\r\nres = ps3flash_writeback(dev);\r\nif (res)\r\nreturn res;\r\npriv->tag = -1;\r\nres = ps3flash_read_write_sectors(dev, start_sector, 0);\r\nif (res)\r\nreturn res;\r\npriv->tag = start_sector;\r\nreturn 0;\r\n}\r\nstatic loff_t ps3flash_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nstruct ps3_storage_device *dev = ps3flash_dev;\r\nreturn generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,\r\ndev->regions[dev->region_idx].size*dev->blk_size);\r\n}\r\nstatic ssize_t ps3flash_read(char __user *userbuf, void *kernelbuf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct ps3_storage_device *dev = ps3flash_dev;\r\nstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nu64 size, sector, offset;\r\nint res;\r\nsize_t remaining, n;\r\nconst void *src;\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u: Reading %zu bytes at position %lld to U0x%p/K0x%p\n",\r\n__func__, __LINE__, count, *pos, userbuf, kernelbuf);\r\nsize = dev->regions[dev->region_idx].size*dev->blk_size;\r\nif (*pos >= size || !count)\r\nreturn 0;\r\nif (*pos + count > size) {\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u Truncating count from %zu to %llu\n", __func__,\r\n__LINE__, count, size - *pos);\r\ncount = size - *pos;\r\n}\r\nsector = *pos / dev->bounce_size * priv->chunk_sectors;\r\noffset = *pos % dev->bounce_size;\r\nremaining = count;\r\ndo {\r\nn = min_t(u64, remaining, dev->bounce_size - offset);\r\nsrc = dev->bounce_buf + offset;\r\nmutex_lock(&priv->mutex);\r\nres = ps3flash_fetch(dev, sector);\r\nif (res)\r\ngoto fail;\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u: copy %lu bytes from 0x%p to U0x%p/K0x%p\n",\r\n__func__, __LINE__, n, src, userbuf, kernelbuf);\r\nif (userbuf) {\r\nif (copy_to_user(userbuf, src, n)) {\r\nres = -EFAULT;\r\ngoto fail;\r\n}\r\nuserbuf += n;\r\n}\r\nif (kernelbuf) {\r\nmemcpy(kernelbuf, src, n);\r\nkernelbuf += n;\r\n}\r\nmutex_unlock(&priv->mutex);\r\n*pos += n;\r\nremaining -= n;\r\nsector += priv->chunk_sectors;\r\noffset = 0;\r\n} while (remaining > 0);\r\nreturn count;\r\nfail:\r\nmutex_unlock(&priv->mutex);\r\nreturn res;\r\n}\r\nstatic ssize_t ps3flash_write(const char __user *userbuf,\r\nconst void *kernelbuf, size_t count, loff_t *pos)\r\n{\r\nstruct ps3_storage_device *dev = ps3flash_dev;\r\nstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nu64 size, sector, offset;\r\nint res = 0;\r\nsize_t remaining, n;\r\nvoid *dst;\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u: Writing %zu bytes at position %lld from U0x%p/K0x%p\n",\r\n__func__, __LINE__, count, *pos, userbuf, kernelbuf);\r\nsize = dev->regions[dev->region_idx].size*dev->blk_size;\r\nif (*pos >= size || !count)\r\nreturn 0;\r\nif (*pos + count > size) {\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u Truncating count from %zu to %llu\n", __func__,\r\n__LINE__, count, size - *pos);\r\ncount = size - *pos;\r\n}\r\nsector = *pos / dev->bounce_size * priv->chunk_sectors;\r\noffset = *pos % dev->bounce_size;\r\nremaining = count;\r\ndo {\r\nn = min_t(u64, remaining, dev->bounce_size - offset);\r\ndst = dev->bounce_buf + offset;\r\nmutex_lock(&priv->mutex);\r\nif (n != dev->bounce_size)\r\nres = ps3flash_fetch(dev, sector);\r\nelse if (sector != priv->tag)\r\nres = ps3flash_writeback(dev);\r\nif (res)\r\ngoto fail;\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u: copy %lu bytes from U0x%p/K0x%p to 0x%p\n",\r\n__func__, __LINE__, n, userbuf, kernelbuf, dst);\r\nif (userbuf) {\r\nif (copy_from_user(dst, userbuf, n)) {\r\nres = -EFAULT;\r\ngoto fail;\r\n}\r\nuserbuf += n;\r\n}\r\nif (kernelbuf) {\r\nmemcpy(dst, kernelbuf, n);\r\nkernelbuf += n;\r\n}\r\npriv->tag = sector;\r\npriv->dirty = true;\r\nmutex_unlock(&priv->mutex);\r\n*pos += n;\r\nremaining -= n;\r\nsector += priv->chunk_sectors;\r\noffset = 0;\r\n} while (remaining > 0);\r\nreturn count;\r\nfail:\r\nmutex_unlock(&priv->mutex);\r\nreturn res;\r\n}\r\nstatic ssize_t ps3flash_user_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nreturn ps3flash_read(buf, NULL, count, pos);\r\n}\r\nstatic ssize_t ps3flash_user_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nreturn ps3flash_write(buf, NULL, count, pos);\r\n}\r\nstatic ssize_t ps3flash_kernel_read(void *buf, size_t count, loff_t pos)\r\n{\r\nreturn ps3flash_read(NULL, buf, count, &pos);\r\n}\r\nstatic ssize_t ps3flash_kernel_write(const void *buf, size_t count,\r\nloff_t pos)\r\n{\r\nssize_t res;\r\nint wb;\r\nres = ps3flash_write(NULL, buf, count, &pos);\r\nif (res < 0)\r\nreturn res;\r\nwb = ps3flash_writeback(ps3flash_dev);\r\nif (wb)\r\nreturn wb;\r\nreturn res;\r\n}\r\nstatic int ps3flash_flush(struct file *file, fl_owner_t id)\r\n{\r\nreturn ps3flash_writeback(ps3flash_dev);\r\n}\r\nstatic int ps3flash_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nint err;\r\nmutex_lock(&inode->i_mutex);\r\nerr = ps3flash_writeback(ps3flash_dev);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn err;\r\n}\r\nstatic irqreturn_t ps3flash_interrupt(int irq, void *data)\r\n{\r\nstruct ps3_storage_device *dev = data;\r\nint res;\r\nu64 tag, status;\r\nres = lv1_storage_get_async_status(dev->sbd.dev_id, &tag, &status);\r\nif (tag != dev->tag)\r\ndev_err(&dev->sbd.core,\r\n"%s:%u: tag mismatch, got %llx, expected %llx\n",\r\n__func__, __LINE__, tag, dev->tag);\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: res=%d status=0x%llx\n",\r\n__func__, __LINE__, res, status);\r\n} else {\r\ndev->lv1_status = status;\r\ncomplete(&dev->done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ps3flash_probe(struct ps3_system_bus_device *_dev)\r\n{\r\nstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\r\nstruct ps3flash_private *priv;\r\nint error;\r\nunsigned long tmp;\r\ntmp = dev->regions[dev->region_idx].start*dev->blk_size;\r\nif (tmp % FLASH_BLOCK_SIZE) {\r\ndev_err(&dev->sbd.core,\r\n"%s:%u region start %lu is not aligned\n", __func__,\r\n__LINE__, tmp);\r\nreturn -EINVAL;\r\n}\r\ntmp = dev->regions[dev->region_idx].size*dev->blk_size;\r\nif (tmp % FLASH_BLOCK_SIZE) {\r\ndev_err(&dev->sbd.core,\r\n"%s:%u region size %lu is not aligned\n", __func__,\r\n__LINE__, tmp);\r\nreturn -EINVAL;\r\n}\r\nif (!ps3flash_bounce_buffer.address)\r\nreturn -ENODEV;\r\nif (ps3flash_dev) {\r\ndev_err(&dev->sbd.core,\r\n"Only one FLASH device is supported\n");\r\nreturn -EBUSY;\r\n}\r\nps3flash_dev = dev;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nps3_system_bus_set_drvdata(&dev->sbd, priv);\r\nmutex_init(&priv->mutex);\r\npriv->tag = -1;\r\ndev->bounce_size = ps3flash_bounce_buffer.size;\r\ndev->bounce_buf = ps3flash_bounce_buffer.address;\r\npriv->chunk_sectors = dev->bounce_size / dev->blk_size;\r\nerror = ps3stor_setup(dev, ps3flash_interrupt);\r\nif (error)\r\ngoto fail_free_priv;\r\nps3flash_misc.parent = &dev->sbd.core;\r\nerror = misc_register(&ps3flash_misc);\r\nif (error) {\r\ndev_err(&dev->sbd.core, "%s:%u: misc_register failed %d\n",\r\n__func__, __LINE__, error);\r\ngoto fail_teardown;\r\n}\r\ndev_info(&dev->sbd.core, "%s:%u: registered misc device %d\n",\r\n__func__, __LINE__, ps3flash_misc.minor);\r\nps3_os_area_flash_register(&ps3flash_kernel_ops);\r\nreturn 0;\r\nfail_teardown:\r\nps3stor_teardown(dev);\r\nfail_free_priv:\r\nkfree(priv);\r\nps3_system_bus_set_drvdata(&dev->sbd, NULL);\r\nfail:\r\nps3flash_dev = NULL;\r\nreturn error;\r\n}\r\nstatic int ps3flash_remove(struct ps3_system_bus_device *_dev)\r\n{\r\nstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\r\nps3_os_area_flash_register(NULL);\r\nmisc_deregister(&ps3flash_misc);\r\nps3stor_teardown(dev);\r\nkfree(ps3_system_bus_get_drvdata(&dev->sbd));\r\nps3_system_bus_set_drvdata(&dev->sbd, NULL);\r\nps3flash_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init ps3flash_init(void)\r\n{\r\nreturn ps3_system_bus_driver_register(&ps3flash);\r\n}\r\nstatic void __exit ps3flash_exit(void)\r\n{\r\nps3_system_bus_driver_unregister(&ps3flash);\r\n}
