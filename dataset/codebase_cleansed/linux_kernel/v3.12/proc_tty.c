static void show_tty_range(struct seq_file *m, struct tty_driver *p,\r\ndev_t from, int num)\r\n{\r\nseq_printf(m, "%-20s ", p->driver_name ? p->driver_name : "unknown");\r\nseq_printf(m, "/dev/%-8s ", p->name);\r\nif (p->num > 1) {\r\nseq_printf(m, "%3d %d-%d ", MAJOR(from), MINOR(from),\r\nMINOR(from) + num - 1);\r\n} else {\r\nseq_printf(m, "%3d %7d ", MAJOR(from), MINOR(from));\r\n}\r\nswitch (p->type) {\r\ncase TTY_DRIVER_TYPE_SYSTEM:\r\nseq_puts(m, "system");\r\nif (p->subtype == SYSTEM_TYPE_TTY)\r\nseq_puts(m, ":/dev/tty");\r\nelse if (p->subtype == SYSTEM_TYPE_SYSCONS)\r\nseq_puts(m, ":console");\r\nelse if (p->subtype == SYSTEM_TYPE_CONSOLE)\r\nseq_puts(m, ":vtmaster");\r\nbreak;\r\ncase TTY_DRIVER_TYPE_CONSOLE:\r\nseq_puts(m, "console");\r\nbreak;\r\ncase TTY_DRIVER_TYPE_SERIAL:\r\nseq_puts(m, "serial");\r\nbreak;\r\ncase TTY_DRIVER_TYPE_PTY:\r\nif (p->subtype == PTY_TYPE_MASTER)\r\nseq_puts(m, "pty:master");\r\nelse if (p->subtype == PTY_TYPE_SLAVE)\r\nseq_puts(m, "pty:slave");\r\nelse\r\nseq_puts(m, "pty");\r\nbreak;\r\ndefault:\r\nseq_printf(m, "type:%d.%d", p->type, p->subtype);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic int show_tty_driver(struct seq_file *m, void *v)\r\n{\r\nstruct tty_driver *p = list_entry(v, struct tty_driver, tty_drivers);\r\ndev_t from = MKDEV(p->major, p->minor_start);\r\ndev_t to = from + p->num;\r\nif (&p->tty_drivers == tty_drivers.next) {\r\nseq_printf(m, "%-20s /dev/%-8s ", "/dev/tty", "tty");\r\nseq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 0);\r\nseq_puts(m, "system:/dev/tty\n");\r\nseq_printf(m, "%-20s /dev/%-8s ", "/dev/console", "console");\r\nseq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 1);\r\nseq_puts(m, "system:console\n");\r\n#ifdef CONFIG_UNIX98_PTYS\r\nseq_printf(m, "%-20s /dev/%-8s ", "/dev/ptmx", "ptmx");\r\nseq_printf(m, "%3d %7d ", TTYAUX_MAJOR, 2);\r\nseq_puts(m, "system\n");\r\n#endif\r\n#ifdef CONFIG_VT\r\nseq_printf(m, "%-20s /dev/%-8s ", "/dev/vc/0", "vc/0");\r\nseq_printf(m, "%3d %7d ", TTY_MAJOR, 0);\r\nseq_puts(m, "system:vtmaster\n");\r\n#endif\r\n}\r\nwhile (MAJOR(from) < MAJOR(to)) {\r\ndev_t next = MKDEV(MAJOR(from)+1, 0);\r\nshow_tty_range(m, p, from, next - from);\r\nfrom = next;\r\n}\r\nif (from != to)\r\nshow_tty_range(m, p, from, to - from);\r\nreturn 0;\r\n}\r\nstatic void *t_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&tty_mutex);\r\nreturn seq_list_start(&tty_drivers, *pos);\r\n}\r\nstatic void *t_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &tty_drivers, pos);\r\n}\r\nstatic void t_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&tty_mutex);\r\n}\r\nstatic int tty_drivers_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &tty_drivers_op);\r\n}\r\nvoid proc_tty_register_driver(struct tty_driver *driver)\r\n{\r\nstruct proc_dir_entry *ent;\r\nif (!driver->driver_name || driver->proc_entry ||\r\n!driver->ops->proc_fops)\r\nreturn;\r\nent = proc_create_data(driver->driver_name, 0, proc_tty_driver,\r\ndriver->ops->proc_fops, driver);\r\ndriver->proc_entry = ent;\r\n}\r\nvoid proc_tty_unregister_driver(struct tty_driver *driver)\r\n{\r\nstruct proc_dir_entry *ent;\r\nent = driver->proc_entry;\r\nif (!ent)\r\nreturn;\r\nremove_proc_entry(driver->driver_name, proc_tty_driver);\r\ndriver->proc_entry = NULL;\r\n}\r\nvoid __init proc_tty_init(void)\r\n{\r\nif (!proc_mkdir("tty", NULL))\r\nreturn;\r\nproc_tty_ldisc = proc_mkdir("tty/ldisc", NULL);\r\nproc_tty_driver = proc_mkdir_mode("tty/driver", S_IRUSR|S_IXUSR, NULL);\r\nproc_create("tty/ldiscs", 0, NULL, &tty_ldiscs_proc_fops);\r\nproc_create("tty/drivers", 0, NULL, &proc_tty_drivers_operations);\r\n}
