static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,\r\nstruct audioformat *fp,\r\nunsigned int format, void *_fmt)\r\n{\r\nint sample_width, sample_bytes;\r\nu64 pcm_formats = 0;\r\nswitch (fp->protocol) {\r\ncase UAC_VERSION_1:\r\ndefault: {\r\nstruct uac_format_type_i_discrete_descriptor *fmt = _fmt;\r\nsample_width = fmt->bBitResolution;\r\nsample_bytes = fmt->bSubframeSize;\r\nformat = 1 << format;\r\nbreak;\r\n}\r\ncase UAC_VERSION_2: {\r\nstruct uac_format_type_i_ext_descriptor *fmt = _fmt;\r\nsample_width = fmt->bBitResolution;\r\nsample_bytes = fmt->bSubslotSize;\r\nif (format & UAC2_FORMAT_TYPE_I_RAW_DATA)\r\npcm_formats |= SNDRV_PCM_FMTBIT_SPECIAL;\r\nformat <<= 1;\r\nbreak;\r\n}\r\n}\r\nif ((pcm_formats == 0) &&\r\n(format == 0 || format == (1 << UAC_FORMAT_TYPE_I_UNDEFINED))) {\r\nsnd_printdd(KERN_INFO "%d:%u:%d : format type 0 is detected, processed as PCM\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting);\r\nformat = 1 << UAC_FORMAT_TYPE_I_PCM;\r\n}\r\nif (format & (1 << UAC_FORMAT_TYPE_I_PCM)) {\r\nif (chip->usb_id == USB_ID(0x0582, 0x0016) &&\r\nsample_width == 24 && sample_bytes == 2)\r\nsample_bytes = 3;\r\nelse if (sample_width > sample_bytes * 8) {\r\nsnd_printk(KERN_INFO "%d:%u:%d : sample bitwidth %d in over sample bytes %d\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting,\r\nsample_width, sample_bytes);\r\n}\r\nswitch (sample_bytes) {\r\ncase 1:\r\npcm_formats |= SNDRV_PCM_FMTBIT_S8;\r\nbreak;\r\ncase 2:\r\nif (snd_usb_is_big_endian_format(chip, fp))\r\npcm_formats |= SNDRV_PCM_FMTBIT_S16_BE;\r\nelse\r\npcm_formats |= SNDRV_PCM_FMTBIT_S16_LE;\r\nbreak;\r\ncase 3:\r\nif (snd_usb_is_big_endian_format(chip, fp))\r\npcm_formats |= SNDRV_PCM_FMTBIT_S24_3BE;\r\nelse\r\npcm_formats |= SNDRV_PCM_FMTBIT_S24_3LE;\r\nbreak;\r\ncase 4:\r\npcm_formats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_INFO "%d:%u:%d : unsupported sample bitwidth %d in %d bytes\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting,\r\nsample_width, sample_bytes);\r\nbreak;\r\n}\r\n}\r\nif (format & (1 << UAC_FORMAT_TYPE_I_PCM8)) {\r\nif (chip->usb_id == USB_ID(0x04fa, 0x4201))\r\npcm_formats |= SNDRV_PCM_FMTBIT_S8;\r\nelse\r\npcm_formats |= SNDRV_PCM_FMTBIT_U8;\r\n}\r\nif (format & (1 << UAC_FORMAT_TYPE_I_IEEE_FLOAT)) {\r\npcm_formats |= SNDRV_PCM_FMTBIT_FLOAT_LE;\r\n}\r\nif (format & (1 << UAC_FORMAT_TYPE_I_ALAW)) {\r\npcm_formats |= SNDRV_PCM_FMTBIT_A_LAW;\r\n}\r\nif (format & (1 << UAC_FORMAT_TYPE_I_MULAW)) {\r\npcm_formats |= SNDRV_PCM_FMTBIT_MU_LAW;\r\n}\r\nif (format & ~0x3f) {\r\nsnd_printk(KERN_INFO "%d:%u:%d : unsupported format bits %#x\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting, format);\r\n}\r\npcm_formats |= snd_usb_interface_dsd_format_quirks(chip, fp, sample_bytes);\r\nreturn pcm_formats;\r\n}\r\nstatic int parse_audio_format_rates_v1(struct snd_usb_audio *chip, struct audioformat *fp,\r\nunsigned char *fmt, int offset)\r\n{\r\nint nr_rates = fmt[offset];\r\nif (fmt[0] < offset + 1 + 3 * (nr_rates ? nr_rates : 2)) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid UAC_FORMAT_TYPE desc\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting);\r\nreturn -EINVAL;\r\n}\r\nif (nr_rates) {\r\nint r, idx;\r\nfp->rate_table = kmalloc(sizeof(int) * nr_rates, GFP_KERNEL);\r\nif (fp->rate_table == NULL) {\r\nsnd_printk(KERN_ERR "cannot malloc\n");\r\nreturn -ENOMEM;\r\n}\r\nfp->nr_rates = 0;\r\nfp->rate_min = fp->rate_max = 0;\r\nfor (r = 0, idx = offset + 1; r < nr_rates; r++, idx += 3) {\r\nunsigned int rate = combine_triple(&fmt[idx]);\r\nif (!rate)\r\ncontinue;\r\nif (rate == 48000 && nr_rates == 1 &&\r\n(chip->usb_id == USB_ID(0x0d8c, 0x0201) ||\r\nchip->usb_id == USB_ID(0x0d8c, 0x0102) ||\r\nchip->usb_id == USB_ID(0x0ccd, 0x00b1)) &&\r\nfp->altsetting == 5 && fp->maxpacksize == 392)\r\nrate = 96000;\r\nif (rate == 16000 && chip->usb_id == USB_ID(0x041e, 0x4068))\r\nrate = 8000;\r\nfp->rate_table[fp->nr_rates] = rate;\r\nif (!fp->rate_min || rate < fp->rate_min)\r\nfp->rate_min = rate;\r\nif (!fp->rate_max || rate > fp->rate_max)\r\nfp->rate_max = rate;\r\nfp->rates |= snd_pcm_rate_to_rate_bit(rate);\r\nfp->nr_rates++;\r\n}\r\nif (!fp->nr_rates) {\r\nhwc_debug("All rates were zero. Skipping format!\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nfp->rates = SNDRV_PCM_RATE_CONTINUOUS;\r\nfp->rate_min = combine_triple(&fmt[offset + 1]);\r\nfp->rate_max = combine_triple(&fmt[offset + 4]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_uac2_sample_rate_range(struct audioformat *fp, int nr_triplets,\r\nconst unsigned char *data)\r\n{\r\nint i, nr_rates = 0;\r\nfp->rates = fp->rate_min = fp->rate_max = 0;\r\nfor (i = 0; i < nr_triplets; i++) {\r\nint min = combine_quad(&data[2 + 12 * i]);\r\nint max = combine_quad(&data[6 + 12 * i]);\r\nint res = combine_quad(&data[10 + 12 * i]);\r\nunsigned int rate;\r\nif ((max < 0) || (min < 0) || (res < 0) || (max < min))\r\ncontinue;\r\nif (res == 1) {\r\nfp->rate_min = min;\r\nfp->rate_max = max;\r\nfp->rates = SNDRV_PCM_RATE_CONTINUOUS;\r\nreturn 0;\r\n}\r\nfor (rate = min; rate <= max; rate += res) {\r\nif (fp->rate_table)\r\nfp->rate_table[nr_rates] = rate;\r\nif (!fp->rate_min || rate < fp->rate_min)\r\nfp->rate_min = rate;\r\nif (!fp->rate_max || rate > fp->rate_max)\r\nfp->rate_max = rate;\r\nfp->rates |= snd_pcm_rate_to_rate_bit(rate);\r\nnr_rates++;\r\nif (nr_rates >= MAX_NR_RATES) {\r\nsnd_printk(KERN_ERR "invalid uac2 rates\n");\r\nbreak;\r\n}\r\nif (res == 0)\r\nbreak;\r\n}\r\n}\r\nreturn nr_rates;\r\n}\r\nstatic int parse_audio_format_rates_v2(struct snd_usb_audio *chip,\r\nstruct audioformat *fp)\r\n{\r\nstruct usb_device *dev = chip->dev;\r\nunsigned char tmp[2], *data;\r\nint nr_triplets, data_size, ret = 0;\r\nint clock = snd_usb_clock_find_source(chip, fp->clock, false);\r\nif (clock < 0) {\r\nsnd_printk(KERN_ERR "%s(): unable to find clock source (clock %d)\n",\r\n__func__, clock);\r\ngoto err;\r\n}\r\nret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_RANGE,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\r\nUAC2_CS_CONTROL_SAM_FREQ << 8,\r\nsnd_usb_ctrl_intf(chip) | (clock << 8),\r\ntmp, sizeof(tmp));\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR "%s(): unable to retrieve number of sample rates (clock %d)\n",\r\n__func__, clock);\r\ngoto err;\r\n}\r\nnr_triplets = (tmp[1] << 8) | tmp[0];\r\ndata_size = 2 + 12 * nr_triplets;\r\ndata = kzalloc(data_size, GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), UAC2_CS_RANGE,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\r\nUAC2_CS_CONTROL_SAM_FREQ << 8,\r\nsnd_usb_ctrl_intf(chip) | (clock << 8),\r\ndata, data_size);\r\nif (ret < 0) {\r\nsnd_printk(KERN_ERR "%s(): unable to retrieve sample rate range (clock %d)\n",\r\n__func__, clock);\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nkfree(fp->rate_table);\r\nfp->rate_table = NULL;\r\nfp->nr_rates = parse_uac2_sample_rate_range(fp, nr_triplets, data);\r\nif (fp->nr_rates == 0) {\r\nret = 0;\r\ngoto err_free;\r\n}\r\nfp->rate_table = kmalloc(sizeof(int) * fp->nr_rates, GFP_KERNEL);\r\nif (!fp->rate_table) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nparse_uac2_sample_rate_range(fp, nr_triplets, data);\r\nerr_free:\r\nkfree(data);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int parse_audio_format_i(struct snd_usb_audio *chip,\r\nstruct audioformat *fp, unsigned int format,\r\nstruct uac_format_type_i_continuous_descriptor *fmt)\r\n{\r\nsnd_pcm_format_t pcm_format;\r\nint ret;\r\nif (fmt->bFormatType == UAC_FORMAT_TYPE_III) {\r\nswitch (chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2003):\r\nif (chip->setup == 0x00 &&\r\nfp->altsetting == 6)\r\npcm_format = SNDRV_PCM_FORMAT_S16_BE;\r\nelse\r\npcm_format = SNDRV_PCM_FORMAT_S16_LE;\r\nbreak;\r\ndefault:\r\npcm_format = SNDRV_PCM_FORMAT_S16_LE;\r\n}\r\nfp->formats = pcm_format_to_bits(pcm_format);\r\n} else {\r\nfp->formats = parse_audio_format_i_type(chip, fp, format, fmt);\r\nif (!fp->formats)\r\nreturn -EINVAL;\r\n}\r\nswitch (fp->protocol) {\r\ndefault:\r\ncase UAC_VERSION_1:\r\nfp->channels = fmt->bNrChannels;\r\nret = parse_audio_format_rates_v1(chip, fp, (unsigned char *) fmt, 7);\r\nbreak;\r\ncase UAC_VERSION_2:\r\nret = parse_audio_format_rates_v2(chip, fp);\r\nbreak;\r\n}\r\nif (fp->channels < 1) {\r\nsnd_printk(KERN_ERR "%d:%u:%d : invalid channels %d\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting, fp->channels);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int parse_audio_format_ii(struct snd_usb_audio *chip,\r\nstruct audioformat *fp,\r\nint format, void *_fmt)\r\n{\r\nint brate, framesize, ret;\r\nswitch (format) {\r\ncase UAC_FORMAT_TYPE_II_AC3:\r\nfp->formats = SNDRV_PCM_FMTBIT_U8;\r\nbreak;\r\ncase UAC_FORMAT_TYPE_II_MPEG:\r\nfp->formats = SNDRV_PCM_FMTBIT_MPEG;\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_INFO "%d:%u:%d : unknown format tag %#x is detected. processed as MPEG.\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting, format);\r\nfp->formats = SNDRV_PCM_FMTBIT_MPEG;\r\nbreak;\r\n}\r\nfp->channels = 1;\r\nswitch (fp->protocol) {\r\ndefault:\r\ncase UAC_VERSION_1: {\r\nstruct uac_format_type_ii_discrete_descriptor *fmt = _fmt;\r\nbrate = le16_to_cpu(fmt->wMaxBitRate);\r\nframesize = le16_to_cpu(fmt->wSamplesPerFrame);\r\nsnd_printd(KERN_INFO "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);\r\nfp->frame_size = framesize;\r\nret = parse_audio_format_rates_v1(chip, fp, _fmt, 8);\r\nbreak;\r\n}\r\ncase UAC_VERSION_2: {\r\nstruct uac_format_type_ii_ext_descriptor *fmt = _fmt;\r\nbrate = le16_to_cpu(fmt->wMaxBitRate);\r\nframesize = le16_to_cpu(fmt->wSamplesPerFrame);\r\nsnd_printd(KERN_INFO "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);\r\nfp->frame_size = framesize;\r\nret = parse_audio_format_rates_v2(chip, fp);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint snd_usb_parse_audio_format(struct snd_usb_audio *chip,\r\nstruct audioformat *fp, unsigned int format,\r\nstruct uac_format_type_i_continuous_descriptor *fmt,\r\nint stream)\r\n{\r\nint err;\r\nswitch (fmt->bFormatType) {\r\ncase UAC_FORMAT_TYPE_I:\r\ncase UAC_FORMAT_TYPE_III:\r\nerr = parse_audio_format_i(chip, fp, format, fmt);\r\nbreak;\r\ncase UAC_FORMAT_TYPE_II:\r\nerr = parse_audio_format_ii(chip, fp, format, fmt);\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_INFO "%d:%u:%d : format type %d is not supported yet\n",\r\nchip->dev->devnum, fp->iface, fp->altsetting,\r\nfmt->bFormatType);\r\nreturn -ENOTSUPP;\r\n}\r\nfp->fmt_type = fmt->bFormatType;\r\nif (err < 0)\r\nreturn err;\r\n#if 1\r\nif (chip->usb_id == USB_ID(0x041e, 0x3000) ||\r\nchip->usb_id == USB_ID(0x041e, 0x3020) ||\r\nchip->usb_id == USB_ID(0x041e, 0x3061)) {\r\nif (fmt->bFormatType == UAC_FORMAT_TYPE_I &&\r\nfp->rates != SNDRV_PCM_RATE_48000 &&\r\nfp->rates != SNDRV_PCM_RATE_96000)\r\nreturn -ENOTSUPP;\r\n}\r\n#endif\r\nreturn 0;\r\n}
