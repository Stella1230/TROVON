static int atmtcp_send_control(struct atm_vcc *vcc,int type,\r\nconst struct atmtcp_control *msg,int flag)\r\n{\r\nDECLARE_WAITQUEUE(wait,current);\r\nstruct atm_vcc *out_vcc;\r\nstruct sk_buff *skb;\r\nstruct atmtcp_control *new_msg;\r\nint old_test;\r\nint error = 0;\r\nout_vcc = PRIV(vcc->dev) ? PRIV(vcc->dev)->vcc : NULL;\r\nif (!out_vcc) return -EUNATCH;\r\nskb = alloc_skb(sizeof(*msg),GFP_KERNEL);\r\nif (!skb) return -ENOMEM;\r\nmb();\r\nout_vcc = PRIV(vcc->dev) ? PRIV(vcc->dev)->vcc : NULL;\r\nif (!out_vcc) {\r\ndev_kfree_skb(skb);\r\nreturn -EUNATCH;\r\n}\r\natm_force_charge(out_vcc,skb->truesize);\r\nnew_msg = (struct atmtcp_control *) skb_put(skb,sizeof(*new_msg));\r\n*new_msg = *msg;\r\nnew_msg->hdr.length = ATMTCP_HDR_MAGIC;\r\nnew_msg->type = type;\r\nmemset(&new_msg->vcc,0,sizeof(atm_kptr_t));\r\n*(struct atm_vcc **) &new_msg->vcc = vcc;\r\nold_test = test_bit(flag,&vcc->flags);\r\nout_vcc->push(out_vcc,skb);\r\nadd_wait_queue(sk_sleep(sk_atm(vcc)), &wait);\r\nwhile (test_bit(flag,&vcc->flags) == old_test) {\r\nmb();\r\nout_vcc = PRIV(vcc->dev) ? PRIV(vcc->dev)->vcc : NULL;\r\nif (!out_vcc) {\r\nerror = -EUNATCH;\r\nbreak;\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk_atm(vcc)), &wait);\r\nreturn error;\r\n}\r\nstatic int atmtcp_recv_control(const struct atmtcp_control *msg)\r\n{\r\nstruct atm_vcc *vcc = *(struct atm_vcc **) &msg->vcc;\r\nvcc->vpi = msg->addr.sap_addr.vpi;\r\nvcc->vci = msg->addr.sap_addr.vci;\r\nvcc->qos = msg->qos;\r\nsk_atm(vcc)->sk_err = -msg->result;\r\nswitch (msg->type) {\r\ncase ATMTCP_CTRL_OPEN:\r\nchange_bit(ATM_VF_READY,&vcc->flags);\r\nbreak;\r\ncase ATMTCP_CTRL_CLOSE:\r\nchange_bit(ATM_VF_ADDR,&vcc->flags);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "atmtcp_recv_control: unknown type %d\n",\r\nmsg->type);\r\nreturn -EINVAL;\r\n}\r\nwake_up(sk_sleep(sk_atm(vcc)));\r\nreturn 0;\r\n}\r\nstatic void atmtcp_v_dev_close(struct atm_dev *dev)\r\n{\r\n}\r\nstatic int atmtcp_v_open(struct atm_vcc *vcc)\r\n{\r\nstruct atmtcp_control msg;\r\nint error;\r\nshort vpi = vcc->vpi;\r\nint vci = vcc->vci;\r\nmemset(&msg,0,sizeof(msg));\r\nmsg.addr.sap_family = AF_ATMPVC;\r\nmsg.hdr.vpi = htons(vpi);\r\nmsg.addr.sap_addr.vpi = vpi;\r\nmsg.hdr.vci = htons(vci);\r\nmsg.addr.sap_addr.vci = vci;\r\nif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC) return 0;\r\nmsg.type = ATMTCP_CTRL_OPEN;\r\nmsg.qos = vcc->qos;\r\nset_bit(ATM_VF_ADDR,&vcc->flags);\r\nclear_bit(ATM_VF_READY,&vcc->flags);\r\nerror = atmtcp_send_control(vcc,ATMTCP_CTRL_OPEN,&msg,ATM_VF_READY);\r\nif (error) return error;\r\nreturn -sk_atm(vcc)->sk_err;\r\n}\r\nstatic void atmtcp_v_close(struct atm_vcc *vcc)\r\n{\r\nstruct atmtcp_control msg;\r\nmemset(&msg,0,sizeof(msg));\r\nmsg.addr.sap_family = AF_ATMPVC;\r\nmsg.addr.sap_addr.vpi = vcc->vpi;\r\nmsg.addr.sap_addr.vci = vcc->vci;\r\nclear_bit(ATM_VF_READY,&vcc->flags);\r\n(void) atmtcp_send_control(vcc,ATMTCP_CTRL_CLOSE,&msg,ATM_VF_ADDR);\r\n}\r\nstatic int atmtcp_v_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)\r\n{\r\nstruct atm_cirange ci;\r\nstruct atm_vcc *vcc;\r\nstruct sock *s;\r\nint i;\r\nif (cmd != ATM_SETCIRANGE) return -ENOIOCTLCMD;\r\nif (copy_from_user(&ci, arg,sizeof(ci))) return -EFAULT;\r\nif (ci.vpi_bits == ATM_CI_MAX) ci.vpi_bits = MAX_VPI_BITS;\r\nif (ci.vci_bits == ATM_CI_MAX) ci.vci_bits = MAX_VCI_BITS;\r\nif (ci.vpi_bits > MAX_VPI_BITS || ci.vpi_bits < 0 ||\r\nci.vci_bits > MAX_VCI_BITS || ci.vci_bits < 0) return -EINVAL;\r\nread_lock(&vcc_sklist_lock);\r\nfor(i = 0; i < VCC_HTABLE_SIZE; ++i) {\r\nstruct hlist_head *head = &vcc_hash[i];\r\nsk_for_each(s, head) {\r\nvcc = atm_sk(s);\r\nif (vcc->dev != dev)\r\ncontinue;\r\nif ((vcc->vpi >> ci.vpi_bits) ||\r\n(vcc->vci >> ci.vci_bits)) {\r\nread_unlock(&vcc_sklist_lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nread_unlock(&vcc_sklist_lock);\r\ndev->ci_range = ci;\r\nreturn 0;\r\n}\r\nstatic int atmtcp_v_send(struct atm_vcc *vcc,struct sk_buff *skb)\r\n{\r\nstruct atmtcp_dev_data *dev_data;\r\nstruct atm_vcc *out_vcc=NULL;\r\nstruct sk_buff *new_skb;\r\nstruct atmtcp_hdr *hdr;\r\nint size;\r\nif (vcc->qos.txtp.traffic_class == ATM_NONE) {\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\ndev_data = PRIV(vcc->dev);\r\nif (dev_data) out_vcc = dev_data->vcc;\r\nif (!dev_data || !out_vcc) {\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nif (dev_data) return 0;\r\natomic_inc(&vcc->stats->tx_err);\r\nreturn -ENOLINK;\r\n}\r\nsize = skb->len+sizeof(struct atmtcp_hdr);\r\nnew_skb = atm_alloc_charge(out_vcc,size,GFP_ATOMIC);\r\nif (!new_skb) {\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\natomic_inc(&vcc->stats->tx_err);\r\nreturn -ENOBUFS;\r\n}\r\nhdr = (void *) skb_put(new_skb,sizeof(struct atmtcp_hdr));\r\nhdr->vpi = htons(vcc->vpi);\r\nhdr->vci = htons(vcc->vci);\r\nhdr->length = htonl(skb->len);\r\nskb_copy_from_linear_data(skb, skb_put(new_skb, skb->len), skb->len);\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nout_vcc->push(out_vcc,new_skb);\r\natomic_inc(&vcc->stats->tx);\r\natomic_inc(&out_vcc->stats->rx);\r\nreturn 0;\r\n}\r\nstatic int atmtcp_v_proc(struct atm_dev *dev,loff_t *pos,char *page)\r\n{\r\nstruct atmtcp_dev_data *dev_data = PRIV(dev);\r\nif (*pos) return 0;\r\nif (!dev_data->persist) return sprintf(page,"ephemeral\n");\r\nreturn sprintf(page,"persistent, %sconnected\n",\r\ndev_data->vcc ? "" : "dis");\r\n}\r\nstatic void atmtcp_c_close(struct atm_vcc *vcc)\r\n{\r\nstruct atm_dev *atmtcp_dev;\r\nstruct atmtcp_dev_data *dev_data;\r\natmtcp_dev = (struct atm_dev *) vcc->dev_data;\r\ndev_data = PRIV(atmtcp_dev);\r\ndev_data->vcc = NULL;\r\nif (dev_data->persist) return;\r\natmtcp_dev->dev_data = NULL;\r\nkfree(dev_data);\r\natm_dev_deregister(atmtcp_dev);\r\nvcc->dev_data = NULL;\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic struct atm_vcc *find_vcc(struct atm_dev *dev, short vpi, int vci)\r\n{\r\nstruct hlist_head *head;\r\nstruct atm_vcc *vcc;\r\nstruct sock *s;\r\nhead = &vcc_hash[vci & (VCC_HTABLE_SIZE -1)];\r\nsk_for_each(s, head) {\r\nvcc = atm_sk(s);\r\nif (vcc->dev == dev &&\r\nvcc->vci == vci && vcc->vpi == vpi &&\r\nvcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nreturn vcc;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int atmtcp_c_send(struct atm_vcc *vcc,struct sk_buff *skb)\r\n{\r\nstruct atm_dev *dev;\r\nstruct atmtcp_hdr *hdr;\r\nstruct atm_vcc *out_vcc;\r\nstruct sk_buff *new_skb;\r\nint result = 0;\r\nif (!skb->len) return 0;\r\ndev = vcc->dev_data;\r\nhdr = (struct atmtcp_hdr *) skb->data;\r\nif (hdr->length == ATMTCP_HDR_MAGIC) {\r\nresult = atmtcp_recv_control(\r\n(struct atmtcp_control *) skb->data);\r\ngoto done;\r\n}\r\nread_lock(&vcc_sklist_lock);\r\nout_vcc = find_vcc(dev, ntohs(hdr->vpi), ntohs(hdr->vci));\r\nread_unlock(&vcc_sklist_lock);\r\nif (!out_vcc) {\r\natomic_inc(&vcc->stats->tx_err);\r\ngoto done;\r\n}\r\nskb_pull(skb,sizeof(struct atmtcp_hdr));\r\nnew_skb = atm_alloc_charge(out_vcc,skb->len,GFP_KERNEL);\r\nif (!new_skb) {\r\nresult = -ENOBUFS;\r\ngoto done;\r\n}\r\n__net_timestamp(new_skb);\r\nskb_copy_from_linear_data(skb, skb_put(new_skb, skb->len), skb->len);\r\nout_vcc->push(out_vcc,new_skb);\r\natomic_inc(&vcc->stats->tx);\r\natomic_inc(&out_vcc->stats->rx);\r\ndone:\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nreturn result;\r\n}\r\nstatic int atmtcp_create(int itf,int persist,struct atm_dev **result)\r\n{\r\nstruct atmtcp_dev_data *dev_data;\r\nstruct atm_dev *dev;\r\ndev_data = kmalloc(sizeof(*dev_data),GFP_KERNEL);\r\nif (!dev_data)\r\nreturn -ENOMEM;\r\ndev = atm_dev_register(DEV_LABEL,NULL,&atmtcp_v_dev_ops,itf,NULL);\r\nif (!dev) {\r\nkfree(dev_data);\r\nreturn itf == -1 ? -ENOMEM : -EBUSY;\r\n}\r\ndev->ci_range.vpi_bits = MAX_VPI_BITS;\r\ndev->ci_range.vci_bits = MAX_VCI_BITS;\r\ndev->dev_data = dev_data;\r\nPRIV(dev)->vcc = NULL;\r\nPRIV(dev)->persist = persist;\r\nif (result) *result = dev;\r\nreturn 0;\r\n}\r\nstatic int atmtcp_attach(struct atm_vcc *vcc,int itf)\r\n{\r\nstruct atm_dev *dev;\r\ndev = NULL;\r\nif (itf != -1) dev = atm_dev_lookup(itf);\r\nif (dev) {\r\nif (dev->ops != &atmtcp_v_dev_ops) {\r\natm_dev_put(dev);\r\nreturn -EMEDIUMTYPE;\r\n}\r\nif (PRIV(dev)->vcc) {\r\natm_dev_put(dev);\r\nreturn -EBUSY;\r\n}\r\n}\r\nelse {\r\nint error;\r\nerror = atmtcp_create(itf,0,&dev);\r\nif (error) return error;\r\n}\r\nPRIV(dev)->vcc = vcc;\r\nvcc->dev = &atmtcp_control_dev;\r\nvcc_insert_socket(sk_atm(vcc));\r\nset_bit(ATM_VF_META,&vcc->flags);\r\nset_bit(ATM_VF_READY,&vcc->flags);\r\nvcc->dev_data = dev;\r\n(void) atm_init_aal5(vcc);\r\nvcc->stats = &atmtcp_control_dev.stats.aal5;\r\nreturn dev->number;\r\n}\r\nstatic int atmtcp_create_persistent(int itf)\r\n{\r\nreturn atmtcp_create(itf,1,NULL);\r\n}\r\nstatic int atmtcp_remove_persistent(int itf)\r\n{\r\nstruct atm_dev *dev;\r\nstruct atmtcp_dev_data *dev_data;\r\ndev = atm_dev_lookup(itf);\r\nif (!dev) return -ENODEV;\r\nif (dev->ops != &atmtcp_v_dev_ops) {\r\natm_dev_put(dev);\r\nreturn -EMEDIUMTYPE;\r\n}\r\ndev_data = PRIV(dev);\r\nif (!dev_data->persist) return 0;\r\ndev_data->persist = 0;\r\nif (PRIV(dev)->vcc) return 0;\r\nkfree(dev_data);\r\natm_dev_put(dev);\r\natm_dev_deregister(dev);\r\nreturn 0;\r\n}\r\nstatic int atmtcp_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nint err = 0;\r\nstruct atm_vcc *vcc = ATM_SD(sock);\r\nif (cmd != SIOCSIFATMTCP && cmd != ATMTCP_CREATE && cmd != ATMTCP_REMOVE)\r\nreturn -ENOIOCTLCMD;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase SIOCSIFATMTCP:\r\nerr = atmtcp_attach(vcc, (int) arg);\r\nif (err >= 0) {\r\nsock->state = SS_CONNECTED;\r\n__module_get(THIS_MODULE);\r\n}\r\nbreak;\r\ncase ATMTCP_CREATE:\r\nerr = atmtcp_create_persistent((int) arg);\r\nbreak;\r\ncase ATMTCP_REMOVE:\r\nerr = atmtcp_remove_persistent((int) arg);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic __init int atmtcp_init(void)\r\n{\r\nregister_atm_ioctl(&atmtcp_ioctl_ops);\r\nreturn 0;\r\n}\r\nstatic void __exit atmtcp_exit(void)\r\n{\r\nderegister_atm_ioctl(&atmtcp_ioctl_ops);\r\n}
