static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)\r\n{\r\nstruct dg *data = chip->model_data;\r\noxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\r\nOXYGEN_SPI_DATA_LENGTH_3 |\r\nOXYGEN_SPI_CLOCK_1280 |\r\n(0 << OXYGEN_SPI_CODEC_SHIFT) |\r\nOXYGEN_SPI_CEN_LATCH_CLOCK_HI,\r\nCS4245_SPI_ADDRESS |\r\nCS4245_SPI_WRITE |\r\n(reg << 8) | value);\r\ndata->cs4245_regs[reg] = value;\r\n}\r\nstatic void cs4245_write_cached(struct oxygen *chip, unsigned int reg, u8 value)\r\n{\r\nstruct dg *data = chip->model_data;\r\nif (value != data->cs4245_regs[reg])\r\ncs4245_write(chip, reg, value);\r\n}\r\nstatic void cs4245_registers_init(struct oxygen *chip)\r\n{\r\nstruct dg *data = chip->model_data;\r\ncs4245_write(chip, CS4245_POWER_CTRL, CS4245_PDN);\r\ncs4245_write(chip, CS4245_DAC_CTRL_1,\r\ndata->cs4245_regs[CS4245_DAC_CTRL_1]);\r\ncs4245_write(chip, CS4245_ADC_CTRL,\r\ndata->cs4245_regs[CS4245_ADC_CTRL]);\r\ncs4245_write(chip, CS4245_SIGNAL_SEL,\r\ndata->cs4245_regs[CS4245_SIGNAL_SEL]);\r\ncs4245_write(chip, CS4245_PGA_B_CTRL,\r\ndata->cs4245_regs[CS4245_PGA_B_CTRL]);\r\ncs4245_write(chip, CS4245_PGA_A_CTRL,\r\ndata->cs4245_regs[CS4245_PGA_A_CTRL]);\r\ncs4245_write(chip, CS4245_ANALOG_IN,\r\ndata->cs4245_regs[CS4245_ANALOG_IN]);\r\ncs4245_write(chip, CS4245_DAC_A_CTRL,\r\ndata->cs4245_regs[CS4245_DAC_A_CTRL]);\r\ncs4245_write(chip, CS4245_DAC_B_CTRL,\r\ndata->cs4245_regs[CS4245_DAC_B_CTRL]);\r\ncs4245_write(chip, CS4245_DAC_CTRL_2,\r\nCS4245_DAC_SOFT | CS4245_DAC_ZERO | CS4245_INVERT_DAC);\r\ncs4245_write(chip, CS4245_INT_MASK, 0);\r\ncs4245_write(chip, CS4245_POWER_CTRL, 0);\r\n}\r\nstatic void cs4245_init(struct oxygen *chip)\r\n{\r\nstruct dg *data = chip->model_data;\r\ndata->cs4245_regs[CS4245_DAC_CTRL_1] =\r\nCS4245_DAC_FM_SINGLE | CS4245_DAC_DIF_LJUST;\r\ndata->cs4245_regs[CS4245_ADC_CTRL] =\r\nCS4245_ADC_FM_SINGLE | CS4245_ADC_DIF_LJUST;\r\ndata->cs4245_regs[CS4245_SIGNAL_SEL] =\r\nCS4245_A_OUT_SEL_HIZ | CS4245_ASYNCH;\r\ndata->cs4245_regs[CS4245_PGA_B_CTRL] = 0;\r\ndata->cs4245_regs[CS4245_PGA_A_CTRL] = 0;\r\ndata->cs4245_regs[CS4245_ANALOG_IN] =\r\nCS4245_PGA_SOFT | CS4245_PGA_ZERO | CS4245_SEL_INPUT_4;\r\ndata->cs4245_regs[CS4245_DAC_A_CTRL] = 0;\r\ndata->cs4245_regs[CS4245_DAC_B_CTRL] = 0;\r\ncs4245_registers_init(chip);\r\nsnd_component_add(chip->card, "CS4245");\r\n}\r\nstatic void dg_output_enable(struct oxygen *chip)\r\n{\r\nmsleep(2500);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);\r\n}\r\nstatic void dg_init(struct oxygen *chip)\r\n{\r\nstruct dg *data = chip->model_data;\r\ndata->output_sel = 0;\r\ndata->input_sel = 3;\r\ndata->hp_vol_att = 2 * 16;\r\ncs4245_init(chip);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_MAGIC | GPIO_HP_DETECT);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_INPUT_ROUTE | GPIO_HP_REAR | GPIO_OUTPUT_ENABLE);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,\r\nGPIO_INPUT_ROUTE | GPIO_HP_REAR);\r\ndg_output_enable(chip);\r\n}\r\nstatic void dg_cleanup(struct oxygen *chip)\r\n{\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);\r\n}\r\nstatic void dg_suspend(struct oxygen *chip)\r\n{\r\ndg_cleanup(chip);\r\n}\r\nstatic void dg_resume(struct oxygen *chip)\r\n{\r\ncs4245_registers_init(chip);\r\ndg_output_enable(chip);\r\n}\r\nstatic void set_cs4245_dac_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct dg *data = chip->model_data;\r\nu8 value;\r\nvalue = data->cs4245_regs[CS4245_DAC_CTRL_1] & ~CS4245_DAC_FM_MASK;\r\nif (params_rate(params) <= 50000)\r\nvalue |= CS4245_DAC_FM_SINGLE;\r\nelse if (params_rate(params) <= 100000)\r\nvalue |= CS4245_DAC_FM_DOUBLE;\r\nelse\r\nvalue |= CS4245_DAC_FM_QUAD;\r\ncs4245_write_cached(chip, CS4245_DAC_CTRL_1, value);\r\n}\r\nstatic void set_cs4245_adc_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct dg *data = chip->model_data;\r\nu8 value;\r\nvalue = data->cs4245_regs[CS4245_ADC_CTRL] & ~CS4245_ADC_FM_MASK;\r\nif (params_rate(params) <= 50000)\r\nvalue |= CS4245_ADC_FM_SINGLE;\r\nelse if (params_rate(params) <= 100000)\r\nvalue |= CS4245_ADC_FM_DOUBLE;\r\nelse\r\nvalue |= CS4245_ADC_FM_QUAD;\r\ncs4245_write_cached(chip, CS4245_ADC_CTRL, value);\r\n}\r\nstatic inline unsigned int shift_bits(unsigned int value,\r\nunsigned int shift_from,\r\nunsigned int shift_to,\r\nunsigned int mask)\r\n{\r\nif (shift_from < shift_to)\r\nreturn (value << (shift_to - shift_from)) & mask;\r\nelse\r\nreturn (value >> (shift_from - shift_to)) & mask;\r\n}\r\nstatic unsigned int adjust_dg_dac_routing(struct oxygen *chip,\r\nunsigned int play_routing)\r\n{\r\nreturn (play_routing & OXYGEN_PLAY_DAC0_SOURCE_MASK) |\r\nshift_bits(play_routing,\r\nOXYGEN_PLAY_DAC2_SOURCE_SHIFT,\r\nOXYGEN_PLAY_DAC1_SOURCE_SHIFT,\r\nOXYGEN_PLAY_DAC1_SOURCE_MASK) |\r\nshift_bits(play_routing,\r\nOXYGEN_PLAY_DAC1_SOURCE_SHIFT,\r\nOXYGEN_PLAY_DAC2_SOURCE_SHIFT,\r\nOXYGEN_PLAY_DAC2_SOURCE_MASK) |\r\nshift_bits(play_routing,\r\nOXYGEN_PLAY_DAC0_SOURCE_SHIFT,\r\nOXYGEN_PLAY_DAC3_SOURCE_SHIFT,\r\nOXYGEN_PLAY_DAC3_SOURCE_MASK);\r\n}\r\nstatic int output_switch_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"Speakers", "Headphones", "FP Headphones"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int output_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.enumerated.item[0] = data->output_sel;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int output_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nu8 reg;\r\nint changed;\r\nif (value->value.enumerated.item[0] > 2)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = value->value.enumerated.item[0] != data->output_sel;\r\nif (changed) {\r\ndata->output_sel = value->value.enumerated.item[0];\r\nreg = data->cs4245_regs[CS4245_SIGNAL_SEL] &\r\n~CS4245_A_OUT_SEL_MASK;\r\nreg |= data->output_sel == 2 ?\r\nCS4245_A_OUT_SEL_DAC : CS4245_A_OUT_SEL_HIZ;\r\ncs4245_write_cached(chip, CS4245_SIGNAL_SEL, reg);\r\ncs4245_write_cached(chip, CS4245_DAC_A_CTRL,\r\ndata->output_sel ? data->hp_vol_att : 0);\r\ncs4245_write_cached(chip, CS4245_DAC_B_CTRL,\r\ndata->output_sel ? data->hp_vol_att : 0);\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\ndata->output_sel == 1 ? GPIO_HP_REAR : 0,\r\nGPIO_HP_REAR);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hp_volume_offset_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"< 64 ohms", "64-150 ohms", "150-300 ohms"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int hp_volume_offset_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nif (data->hp_vol_att > 2 * 7)\r\nvalue->value.enumerated.item[0] = 0;\r\nelse if (data->hp_vol_att > 0)\r\nvalue->value.enumerated.item[0] = 1;\r\nelse\r\nvalue->value.enumerated.item[0] = 2;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int hp_volume_offset_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstatic const s8 atts[3] = { 2 * 16, 2 * 7, 0 };\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\ns8 att;\r\nint changed;\r\nif (value->value.enumerated.item[0] > 2)\r\nreturn -EINVAL;\r\natt = atts[value->value.enumerated.item[0]];\r\nmutex_lock(&chip->mutex);\r\nchanged = att != data->hp_vol_att;\r\nif (changed) {\r\ndata->hp_vol_att = att;\r\nif (data->output_sel) {\r\ncs4245_write_cached(chip, CS4245_DAC_A_CTRL, att);\r\ncs4245_write_cached(chip, CS4245_DAC_B_CTRL, att);\r\n}\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int input_vol_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 2 * -12;\r\ninfo->value.integer.max = 2 * 12;\r\nreturn 0;\r\n}\r\nstatic int input_vol_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nunsigned int idx = ctl->private_value;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.integer.value[0] = data->input_vol[idx][0];\r\nvalue->value.integer.value[1] = data->input_vol[idx][1];\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int input_vol_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nunsigned int idx = ctl->private_value;\r\nint changed = 0;\r\nif (value->value.integer.value[0] < 2 * -12 ||\r\nvalue->value.integer.value[0] > 2 * 12 ||\r\nvalue->value.integer.value[1] < 2 * -12 ||\r\nvalue->value.integer.value[1] > 2 * 12)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = data->input_vol[idx][0] != value->value.integer.value[0] ||\r\ndata->input_vol[idx][1] != value->value.integer.value[1];\r\nif (changed) {\r\ndata->input_vol[idx][0] = value->value.integer.value[0];\r\ndata->input_vol[idx][1] = value->value.integer.value[1];\r\nif (idx == data->input_sel) {\r\ncs4245_write_cached(chip, CS4245_PGA_A_CTRL,\r\ndata->input_vol[idx][0]);\r\ncs4245_write_cached(chip, CS4245_PGA_B_CTRL,\r\ndata->input_vol[idx][1]);\r\n}\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int input_sel_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[4] = {\r\n"Mic", "Aux", "Front Mic", "Line"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 4, names);\r\n}\r\nstatic int input_sel_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.enumerated.item[0] = data->input_sel;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int input_sel_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstatic const u8 sel_values[4] = {\r\nCS4245_SEL_MIC,\r\nCS4245_SEL_INPUT_1,\r\nCS4245_SEL_INPUT_2,\r\nCS4245_SEL_INPUT_4\r\n};\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nint changed;\r\nif (value->value.enumerated.item[0] > 3)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = value->value.enumerated.item[0] != data->input_sel;\r\nif (changed) {\r\ndata->input_sel = value->value.enumerated.item[0];\r\ncs4245_write(chip, CS4245_ANALOG_IN,\r\n(data->cs4245_regs[CS4245_ANALOG_IN] &\r\n~CS4245_SEL_MASK) |\r\nsel_values[data->input_sel]);\r\ncs4245_write_cached(chip, CS4245_PGA_A_CTRL,\r\ndata->input_vol[data->input_sel][0]);\r\ncs4245_write_cached(chip, CS4245_PGA_B_CTRL,\r\ndata->input_vol[data->input_sel][1]);\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\ndata->input_sel ? 0 : GPIO_INPUT_ROUTE,\r\nGPIO_INPUT_ROUTE);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = { "Active", "Frozen" };\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nvalue->value.enumerated.item[0] =\r\n!!(data->cs4245_regs[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);\r\nreturn 0;\r\n}\r\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct dg *data = chip->model_data;\r\nu8 reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nreg = data->cs4245_regs[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;\r\nif (value->value.enumerated.item[0])\r\nreg |= CS4245_HPF_FREEZE;\r\nchanged = reg != data->cs4245_regs[CS4245_ADC_CTRL];\r\nif (changed)\r\ncs4245_write(chip, CS4245_ADC_CTRL, reg);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int dg_control_filter(struct snd_kcontrol_new *template)\r\n{\r\nif (!strncmp(template->name, "Master Playback ", 16))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int dg_mixer_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&dg_controls[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dump_cs4245_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct dg *data = chip->model_data;\r\nunsigned int i;\r\nsnd_iprintf(buffer, "\nCS4245:");\r\nfor (i = 1; i <= 0x10; ++i)\r\nsnd_iprintf(buffer, " %02x", data->cs4245_regs[i]);\r\nsnd_iprintf(buffer, "\n");\r\n}
