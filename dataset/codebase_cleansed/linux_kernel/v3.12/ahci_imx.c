static int imx6q_sata_init(struct device *dev, void __iomem *mmio)\r\n{\r\nint ret = 0;\r\nunsigned int reg_val;\r\nstruct imx_ahci_priv *imxpriv = dev_get_drvdata(dev->parent);\r\nimxpriv->gpr =\r\nsyscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");\r\nif (IS_ERR(imxpriv->gpr)) {\r\ndev_err(dev, "failed to find fsl,imx6q-iomux-gpr regmap\n");\r\nreturn PTR_ERR(imxpriv->gpr);\r\n}\r\nret = clk_prepare_enable(imxpriv->sata_ref_clk);\r\nif (ret < 0) {\r\ndev_err(dev, "prepare-enable sata_ref clock err:%d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(imxpriv->gpr, 0x34, IMX6Q_GPR13_SATA_RX_EQ_VAL_MASK\r\n| IMX6Q_GPR13_SATA_RX_LOS_LVL_MASK\r\n| IMX6Q_GPR13_SATA_RX_DPLL_MODE_MASK\r\n| IMX6Q_GPR13_SATA_SPD_MODE_MASK\r\n| IMX6Q_GPR13_SATA_MPLL_SS_EN\r\n| IMX6Q_GPR13_SATA_TX_ATTEN_MASK\r\n| IMX6Q_GPR13_SATA_TX_BOOST_MASK\r\n| IMX6Q_GPR13_SATA_TX_LVL_MASK\r\n| IMX6Q_GPR13_SATA_TX_EDGE_RATE\r\n, IMX6Q_GPR13_SATA_RX_EQ_VAL_3_0_DB\r\n| IMX6Q_GPR13_SATA_RX_LOS_LVL_SATA2M\r\n| IMX6Q_GPR13_SATA_RX_DPLL_MODE_2P_4F\r\n| IMX6Q_GPR13_SATA_SPD_MODE_3P0G\r\n| IMX6Q_GPR13_SATA_MPLL_SS_EN\r\n| IMX6Q_GPR13_SATA_TX_ATTEN_9_16\r\n| IMX6Q_GPR13_SATA_TX_BOOST_3_33_DB\r\n| IMX6Q_GPR13_SATA_TX_LVL_1_025_V);\r\nregmap_update_bits(imxpriv->gpr, 0x34, IMX6Q_GPR13_SATA_MPLL_CLK_EN,\r\nIMX6Q_GPR13_SATA_MPLL_CLK_EN);\r\nusleep_range(100, 200);\r\nreg_val = readl(mmio + HOST_CAP);\r\nif (!(reg_val & HOST_CAP_SSS)) {\r\nreg_val |= HOST_CAP_SSS;\r\nwritel(reg_val, mmio + HOST_CAP);\r\n}\r\nreg_val = readl(mmio + HOST_PORTS_IMPL);\r\nif (!(reg_val & 0x1)) {\r\nreg_val |= 0x1;\r\nwritel(reg_val, mmio + HOST_PORTS_IMPL);\r\n}\r\nreg_val = clk_get_rate(imxpriv->ahb_clk) / 1000;\r\nwritel(reg_val, mmio + HOST_TIMER1MS);\r\nreturn 0;\r\n}\r\nstatic void imx6q_sata_exit(struct device *dev)\r\n{\r\nstruct imx_ahci_priv *imxpriv = dev_get_drvdata(dev->parent);\r\nregmap_update_bits(imxpriv->gpr, 0x34, IMX6Q_GPR13_SATA_MPLL_CLK_EN,\r\n!IMX6Q_GPR13_SATA_MPLL_CLK_EN);\r\nclk_disable_unprepare(imxpriv->sata_ref_clk);\r\n}\r\nstatic int imx_ahci_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *mem, *irq, res[2];\r\nconst struct of_device_id *of_id;\r\nconst struct ahci_platform_data *pdata = NULL;\r\nstruct imx_ahci_priv *imxpriv;\r\nstruct device *ahci_dev;\r\nstruct platform_device *ahci_pdev;\r\nint ret;\r\nimxpriv = devm_kzalloc(dev, sizeof(*imxpriv), GFP_KERNEL);\r\nif (!imxpriv) {\r\ndev_err(dev, "can't alloc ahci_host_priv\n");\r\nreturn -ENOMEM;\r\n}\r\nahci_pdev = platform_device_alloc("ahci", -1);\r\nif (!ahci_pdev)\r\nreturn -ENODEV;\r\nahci_dev = &ahci_pdev->dev;\r\nahci_dev->parent = dev;\r\nimxpriv->ahb_clk = devm_clk_get(dev, "ahb");\r\nif (IS_ERR(imxpriv->ahb_clk)) {\r\ndev_err(dev, "can't get ahb clock.\n");\r\nret = PTR_ERR(imxpriv->ahb_clk);\r\ngoto err_out;\r\n}\r\nimxpriv->sata_ref_clk = devm_clk_get(dev, "sata_ref");\r\nif (IS_ERR(imxpriv->sata_ref_clk)) {\r\ndev_err(dev, "can't get sata_ref clock.\n");\r\nret = PTR_ERR(imxpriv->sata_ref_clk);\r\ngoto err_out;\r\n}\r\nimxpriv->ahci_pdev = ahci_pdev;\r\nplatform_set_drvdata(pdev, imxpriv);\r\nof_id = of_match_device(imx_ahci_of_match, dev);\r\nif (of_id) {\r\npdata = of_id->data;\r\n} else {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!mem || !irq) {\r\ndev_err(dev, "no mmio/irq resource\n");\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\nres[0] = *mem;\r\nres[1] = *irq;\r\nahci_dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nahci_dev->dma_mask = &ahci_dev->coherent_dma_mask;\r\nahci_dev->of_node = dev->of_node;\r\nret = platform_device_add_resources(ahci_pdev, res, 2);\r\nif (ret)\r\ngoto err_out;\r\nret = platform_device_add_data(ahci_pdev, pdata, sizeof(*pdata));\r\nif (ret)\r\ngoto err_out;\r\nret = platform_device_add(ahci_pdev);\r\nif (ret) {\r\nerr_out:\r\nplatform_device_put(ahci_pdev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_ahci_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_ahci_priv *imxpriv = platform_get_drvdata(pdev);\r\nstruct platform_device *ahci_pdev = imxpriv->ahci_pdev;\r\nplatform_device_unregister(ahci_pdev);\r\nreturn 0;\r\n}
