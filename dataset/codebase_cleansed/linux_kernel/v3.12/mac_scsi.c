static __inline__ char macscsi_read(struct Scsi_Host *instance, int reg)\r\n{\r\nreturn in_8(instance->io_port + (reg<<4));\r\n}\r\nstatic __inline__ void macscsi_write(struct Scsi_Host *instance, int reg, int value)\r\n{\r\nout_8(instance->io_port + (reg<<4), value);\r\n}\r\nstatic int __init mac_scsi_setup(char *str) {\r\n#ifdef DRIVER_SETUP\r\nint ints[7];\r\n(void)get_options( str, ARRAY_SIZE(ints), ints);\r\nif (setup_called++ || ints[0] < 1 || ints[0] > 6) {\r\nprintk(KERN_WARNING "scsi: <mac5380>"\r\n" Usage: mac5380=<can_queue>[,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>,<use_pdma>]\n");\r\nprintk(KERN_ALERT "scsi: <mac5380> Bad Penguin parameters?\n");\r\nreturn 0;\r\n}\r\nif (ints[0] >= 1) {\r\nif (ints[1] > 0)\r\nsetup_can_queue = ints[1];\r\n}\r\nif (ints[0] >= 2) {\r\nif (ints[2] > 0)\r\nsetup_cmd_per_lun = ints[2];\r\n}\r\nif (ints[0] >= 3) {\r\nif (ints[3] >= 0) {\r\nsetup_sg_tablesize = ints[3];\r\nif (setup_sg_tablesize > SG_ALL)\r\nsetup_sg_tablesize = SG_ALL;\r\n}\r\n}\r\nif (ints[0] >= 4) {\r\nif (ints[4] >= 0 && ints[4] <= 7)\r\nsetup_hostid = ints[4];\r\nelse if (ints[4] > 7)\r\nprintk(KERN_WARNING "mac_scsi_setup: invalid host ID %d !\n", ints[4] );\r\n}\r\n#ifdef SUPPORT_TAGS\r\nif (ints[0] >= 5) {\r\nif (ints[5] >= 0)\r\nsetup_use_tagged_queuing = !!ints[5];\r\n}\r\nif (ints[0] == 6) {\r\nif (ints[6] >= 0)\r\nsetup_use_pdma = ints[6];\r\n}\r\n#else\r\nif (ints[0] == 5) {\r\nif (ints[5] >= 0)\r\nsetup_use_pdma = ints[5];\r\n}\r\n#endif\r\n#endif\r\nreturn 1;\r\n}\r\nint __init macscsi_detect(struct scsi_host_template * tpnt)\r\n{\r\nstatic int called = 0;\r\nint flags = 0;\r\nstruct Scsi_Host *instance;\r\nif (!MACH_IS_MAC || called)\r\nreturn( 0 );\r\nif (macintosh_config->scsi_type != MAC_SCSI_OLD)\r\nreturn( 0 );\r\ntpnt->can_queue =\r\n(setup_can_queue > 0) ? setup_can_queue : CAN_QUEUE;\r\ntpnt->cmd_per_lun =\r\n(setup_cmd_per_lun > 0) ? setup_cmd_per_lun : CMD_PER_LUN;\r\ntpnt->sg_tablesize =\r\n(setup_sg_tablesize >= 0) ? setup_sg_tablesize : SG_TABLESIZE;\r\nif (setup_hostid >= 0)\r\ntpnt->this_id = setup_hostid;\r\nelse {\r\ntpnt->this_id = 7;\r\n}\r\n#ifdef SUPPORT_TAGS\r\nif (setup_use_tagged_queuing < 0)\r\nsetup_use_tagged_queuing = USE_TAGGED_QUEUING;\r\n#endif\r\ninstance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));\r\nif (macintosh_config->ident == MAC_MODEL_IIFX) {\r\nmac_scsi_regp = via1+0x8000;\r\nmac_scsi_drq = via1+0xE000;\r\nmac_scsi_nodrq = via1+0xC000;\r\nflags = FLAG_NO_PSEUDO_DMA;\r\n} else {\r\nmac_scsi_regp = via1+0x10000;\r\nmac_scsi_drq = via1+0x6000;\r\nmac_scsi_nodrq = via1+0x12000;\r\n}\r\nif (! setup_use_pdma)\r\nflags = FLAG_NO_PSEUDO_DMA;\r\ninstance->io_port = (unsigned long) mac_scsi_regp;\r\ninstance->irq = IRQ_MAC_SCSI;\r\n#ifdef RESET_BOOT\r\nmac_scsi_reset_boot(instance);\r\n#endif\r\nNCR5380_init(instance, flags);\r\ninstance->n_io_port = 255;\r\n((struct NCR5380_hostdata *)instance->hostdata)->ctrl = 0;\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nif (request_irq(instance->irq, NCR5380_intr, 0, "ncr5380", instance)) {\r\nprintk(KERN_WARNING "scsi%d: IRQ%d not free, interrupts disabled\n",\r\ninstance->host_no, instance->irq);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n}\r\nprintk(KERN_INFO "scsi%d: generic 5380 at port %lX irq", instance->host_no, instance->io_port);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nprintk (KERN_INFO "s disabled");\r\nelse\r\nprintk (KERN_INFO " %d", instance->irq);\r\nprintk(KERN_INFO " options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",\r\ninstance->can_queue, instance->cmd_per_lun, MACSCSI_PUBLIC_RELEASE);\r\nprintk(KERN_INFO "\nscsi%d:", instance->host_no);\r\nNCR5380_print_options(instance);\r\nprintk("\n");\r\ncalled = 1;\r\nreturn 1;\r\n}\r\nint macscsi_release (struct Scsi_Host *shpnt)\r\n{\r\nif (shpnt->irq != SCSI_IRQ_NONE)\r\nfree_irq(shpnt->irq, shpnt);\r\nNCR5380_exit(shpnt);\r\nreturn 0;\r\n}\r\nstatic void mac_scsi_reset_boot(struct Scsi_Host *instance)\r\n{\r\nunsigned long end;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nprintk(KERN_INFO "Macintosh SCSI: resetting the SCSI bus..." );\r\nNCR5380_write( TARGET_COMMAND_REG,\r\nPHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));\r\nNCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );\r\nudelay( 50 );\r\nNCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );\r\nNCR5380_read( RESET_PARITY_INTERRUPT_REG );\r\nfor( end = jiffies + AFTER_RESET_DELAY; time_before(jiffies, end); )\r\nbarrier();\r\nprintk(KERN_INFO " done\n" );\r\n}\r\nconst char * macscsi_info (struct Scsi_Host *spnt) {\r\nreturn "";\r\n}\r\nstatic int macscsi_pread (struct Scsi_Host *instance,\r\nunsigned char *dst, int len)\r\n{\r\nunsigned char *d;\r\nvolatile unsigned char *s;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\ns = mac_scsi_drq+0x60;\r\nd = dst;\r\nwhile (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_DRQ)\r\n&& !(NCR5380_read(STATUS_REG) & SR_REQ))\r\n;\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_DRQ)\r\n&& (NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH)) {\r\nprintk(KERN_ERR "Error in macscsi_pread\n");\r\nreturn -1;\r\n}\r\nCP_IO_TO_MEM(s, d, len);\r\nif (len != 0) {\r\nprintk(KERN_NOTICE "Bus error in macscsi_pread\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int macscsi_pwrite (struct Scsi_Host *instance,\r\nunsigned char *src, int len)\r\n{\r\nunsigned char *s;\r\nvolatile unsigned char *d;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\ns = src;\r\nd = mac_scsi_drq;\r\nwhile (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_DRQ)\r\n&& (!(NCR5380_read(STATUS_REG) & SR_REQ)\r\n|| (NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH)))\r\n;\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_DRQ)) {\r\nprintk(KERN_ERR "Error in macscsi_pwrite\n");\r\nreturn -1;\r\n}\r\nCP_MEM_TO_IO(s, d, len);\r\nif (len != 0) {\r\nprintk(KERN_NOTICE "Bus error in macscsi_pwrite\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}
