void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,\r\nstruct ieee80211_channel *chan,\r\nenum nl80211_channel_type chan_type)\r\n{\r\nif (WARN_ON(!chan))\r\nreturn;\r\nchandef->chan = chan;\r\nchandef->center_freq2 = 0;\r\nswitch (chan_type) {\r\ncase NL80211_CHAN_NO_HT:\r\nchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\r\nchandef->center_freq1 = chan->center_freq;\r\nbreak;\r\ncase NL80211_CHAN_HT20:\r\nchandef->width = NL80211_CHAN_WIDTH_20;\r\nchandef->center_freq1 = chan->center_freq;\r\nbreak;\r\ncase NL80211_CHAN_HT40PLUS:\r\nchandef->width = NL80211_CHAN_WIDTH_40;\r\nchandef->center_freq1 = chan->center_freq + 10;\r\nbreak;\r\ncase NL80211_CHAN_HT40MINUS:\r\nchandef->width = NL80211_CHAN_WIDTH_40;\r\nchandef->center_freq1 = chan->center_freq - 10;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nbool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef)\r\n{\r\nu32 control_freq;\r\nif (!chandef->chan)\r\nreturn false;\r\ncontrol_freq = chandef->chan->center_freq;\r\nswitch (chandef->width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\ncase NL80211_CHAN_WIDTH_10:\r\ncase NL80211_CHAN_WIDTH_20:\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nif (chandef->center_freq1 != control_freq)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nif (chandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\nif (chandef->center_freq1 != control_freq + 30 &&\r\nchandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10 &&\r\nchandef->center_freq1 != control_freq - 30)\r\nreturn false;\r\nif (!chandef->center_freq2)\r\nreturn false;\r\nif (chandef->center_freq1 - chandef->center_freq2 == 80 ||\r\nchandef->center_freq2 - chandef->center_freq1 == 80)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80:\r\nif (chandef->center_freq1 != control_freq + 30 &&\r\nchandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10 &&\r\nchandef->center_freq1 != control_freq - 30)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\nif (chandef->center_freq1 != control_freq + 70 &&\r\nchandef->center_freq1 != control_freq + 50 &&\r\nchandef->center_freq1 != control_freq + 30 &&\r\nchandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10 &&\r\nchandef->center_freq1 != control_freq - 30 &&\r\nchandef->center_freq1 != control_freq - 50 &&\r\nchandef->center_freq1 != control_freq - 70)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void chandef_primary_freqs(const struct cfg80211_chan_def *c,\r\nint *pri40, int *pri80)\r\n{\r\nint tmp;\r\nswitch (c->width) {\r\ncase NL80211_CHAN_WIDTH_40:\r\n*pri40 = c->center_freq1;\r\n*pri80 = 0;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80:\r\ncase NL80211_CHAN_WIDTH_80P80:\r\n*pri80 = c->center_freq1;\r\ntmp = (30 + c->chan->center_freq - c->center_freq1)/20;\r\ntmp /= 2;\r\n*pri40 = c->center_freq1 - 20 + 40 * tmp;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\ntmp = (70 + c->chan->center_freq - c->center_freq1)/20;\r\ntmp /= 2;\r\n*pri40 = c->center_freq1 - 60 + 40 * tmp;\r\ntmp /= 2;\r\n*pri80 = c->center_freq1 - 40 + 80 * tmp;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\n}\r\n}\r\nstatic int cfg80211_chandef_get_width(const struct cfg80211_chan_def *c)\r\n{\r\nint width;\r\nswitch (c->width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\nwidth = 5;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_10:\r\nwidth = 10;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_20:\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nwidth = 20;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nwidth = 40;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\ncase NL80211_CHAN_WIDTH_80:\r\nwidth = 80;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\nwidth = 160;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn -1;\r\n}\r\nreturn width;\r\n}\r\nconst struct cfg80211_chan_def *\r\ncfg80211_chandef_compatible(const struct cfg80211_chan_def *c1,\r\nconst struct cfg80211_chan_def *c2)\r\n{\r\nu32 c1_pri40, c1_pri80, c2_pri40, c2_pri80;\r\nif (cfg80211_chandef_identical(c1, c2))\r\nreturn c1;\r\nif (c1->chan != c2->chan)\r\nreturn NULL;\r\nif (c1->width == c2->width)\r\nreturn NULL;\r\nif (c1->width == NL80211_CHAN_WIDTH_5 ||\r\nc1->width == NL80211_CHAN_WIDTH_10 ||\r\nc2->width == NL80211_CHAN_WIDTH_5 ||\r\nc2->width == NL80211_CHAN_WIDTH_10)\r\nreturn NULL;\r\nif (c1->width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nc1->width == NL80211_CHAN_WIDTH_20)\r\nreturn c2;\r\nif (c2->width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nc2->width == NL80211_CHAN_WIDTH_20)\r\nreturn c1;\r\nchandef_primary_freqs(c1, &c1_pri40, &c1_pri80);\r\nchandef_primary_freqs(c2, &c2_pri40, &c2_pri80);\r\nif (c1_pri40 != c2_pri40)\r\nreturn NULL;\r\nWARN_ON(!c1_pri80 && !c2_pri80);\r\nif (c1_pri80 && c2_pri80 && c1_pri80 != c2_pri80)\r\nreturn NULL;\r\nif (c1->width > c2->width)\r\nreturn c1;\r\nreturn c2;\r\n}\r\nstatic void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,\r\nu32 bandwidth,\r\nenum nl80211_dfs_state dfs_state)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq;\r\nfor (freq = center_freq - bandwidth/2 + 10;\r\nfreq <= center_freq + bandwidth/2 - 10;\r\nfreq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c || !(c->flags & IEEE80211_CHAN_RADAR))\r\ncontinue;\r\nc->dfs_state = dfs_state;\r\nc->dfs_state_entered = jiffies;\r\n}\r\n}\r\nvoid cfg80211_set_dfs_state(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef,\r\nenum nl80211_dfs_state dfs_state)\r\n{\r\nint width;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn;\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn;\r\ncfg80211_set_chans_dfs_state(wiphy, chandef->center_freq1,\r\nwidth, dfs_state);\r\nif (!chandef->center_freq2)\r\nreturn;\r\ncfg80211_set_chans_dfs_state(wiphy, chandef->center_freq2,\r\nwidth, dfs_state);\r\n}\r\nstatic int cfg80211_get_chans_dfs_required(struct wiphy *wiphy,\r\nu32 center_freq,\r\nu32 bandwidth)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq, start_freq, end_freq;\r\nif (bandwidth <= 20) {\r\nstart_freq = center_freq;\r\nend_freq = center_freq;\r\n} else {\r\nstart_freq = center_freq - bandwidth/2 + 10;\r\nend_freq = center_freq + bandwidth/2 - 10;\r\n}\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c)\r\nreturn -EINVAL;\r\nif (c->flags & IEEE80211_CHAN_RADAR)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint cfg80211_chandef_dfs_required(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef)\r\n{\r\nint width;\r\nint r;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn -EINVAL;\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn -EINVAL;\r\nr = cfg80211_get_chans_dfs_required(wiphy, chandef->center_freq1,\r\nwidth);\r\nif (r)\r\nreturn r;\r\nif (!chandef->center_freq2)\r\nreturn 0;\r\nreturn cfg80211_get_chans_dfs_required(wiphy, chandef->center_freq2,\r\nwidth);\r\n}\r\nstatic bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,\r\nu32 center_freq, u32 bandwidth,\r\nu32 prohibited_flags)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq, start_freq, end_freq;\r\nif (bandwidth <= 20) {\r\nstart_freq = center_freq;\r\nend_freq = center_freq;\r\n} else {\r\nstart_freq = center_freq - bandwidth/2 + 10;\r\nend_freq = center_freq + bandwidth/2 - 10;\r\n}\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c)\r\nreturn false;\r\nif ((prohibited_flags & c->flags & IEEE80211_CHAN_RADAR) &&\r\n(c->dfs_state != NL80211_DFS_AVAILABLE))\r\nreturn false;\r\nif (c->flags & prohibited_flags & ~IEEE80211_CHAN_RADAR)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool cfg80211_chandef_usable(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef,\r\nu32 prohibited_flags)\r\n{\r\nstruct ieee80211_sta_ht_cap *ht_cap;\r\nstruct ieee80211_sta_vht_cap *vht_cap;\r\nu32 width, control_freq;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn false;\r\nht_cap = &wiphy->bands[chandef->chan->band]->ht_cap;\r\nvht_cap = &wiphy->bands[chandef->chan->band]->vht_cap;\r\ncontrol_freq = chandef->chan->center_freq;\r\nswitch (chandef->width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\nwidth = 5;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_10:\r\nwidth = 10;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_20:\r\nif (!ht_cap->ht_supported)\r\nreturn false;\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nwidth = 20;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nwidth = 40;\r\nif (!ht_cap->ht_supported)\r\nreturn false;\r\nif (!(ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) ||\r\nht_cap->cap & IEEE80211_HT_CAP_40MHZ_INTOLERANT)\r\nreturn false;\r\nif (chandef->center_freq1 < control_freq &&\r\nchandef->chan->flags & IEEE80211_CHAN_NO_HT40MINUS)\r\nreturn false;\r\nif (chandef->center_freq1 > control_freq &&\r\nchandef->chan->flags & IEEE80211_CHAN_NO_HT40PLUS)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\nif (!(vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ))\r\nreturn false;\r\ncase NL80211_CHAN_WIDTH_80:\r\nif (!vht_cap->vht_supported)\r\nreturn false;\r\nprohibited_flags |= IEEE80211_CHAN_NO_80MHZ;\r\nwidth = 80;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\nif (!vht_cap->vht_supported)\r\nreturn false;\r\nif (!(vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ))\r\nreturn false;\r\nprohibited_flags |= IEEE80211_CHAN_NO_160MHZ;\r\nwidth = 160;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn false;\r\n}\r\nif (width > 20)\r\nprohibited_flags |= IEEE80211_CHAN_NO_OFDM;\r\nif (width < 20)\r\nprohibited_flags |= IEEE80211_CHAN_NO_OFDM;\r\nif (!cfg80211_secondary_chans_ok(wiphy, chandef->center_freq1,\r\nwidth, prohibited_flags))\r\nreturn false;\r\nif (!chandef->center_freq2)\r\nreturn true;\r\nreturn cfg80211_secondary_chans_ok(wiphy, chandef->center_freq2,\r\nwidth, prohibited_flags);\r\n}\r\nbool cfg80211_reg_can_beacon(struct wiphy *wiphy,\r\nstruct cfg80211_chan_def *chandef)\r\n{\r\nbool res;\r\ntrace_cfg80211_reg_can_beacon(wiphy, chandef);\r\nres = cfg80211_chandef_usable(wiphy, chandef,\r\nIEEE80211_CHAN_DISABLED |\r\nIEEE80211_CHAN_PASSIVE_SCAN |\r\nIEEE80211_CHAN_NO_IBSS |\r\nIEEE80211_CHAN_RADAR);\r\ntrace_cfg80211_return_bool(res);\r\nreturn res;\r\n}\r\nint cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,\r\nstruct cfg80211_chan_def *chandef)\r\n{\r\nif (!rdev->ops->set_monitor_channel)\r\nreturn -EOPNOTSUPP;\r\nif (!cfg80211_has_monitors_only(rdev))\r\nreturn -EBUSY;\r\nreturn rdev_set_monitor_channel(rdev, chandef);\r\n}\r\nvoid\r\ncfg80211_get_chan_state(struct wireless_dev *wdev,\r\nstruct ieee80211_channel **chan,\r\nenum cfg80211_chan_mode *chanmode)\r\n{\r\n*chan = NULL;\r\n*chanmode = CHAN_MODE_UNDEFINED;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (wdev->netdev && !netif_running(wdev->netdev))\r\nreturn;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (wdev->current_bss) {\r\n*chan = wdev->current_bss->pub.channel;\r\n*chanmode = wdev->ibss_fixed\r\n? CHAN_MODE_SHARED\r\n: CHAN_MODE_EXCLUSIVE;\r\nreturn;\r\n}\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nif (wdev->current_bss) {\r\n*chan = wdev->current_bss->pub.channel;\r\n*chanmode = CHAN_MODE_SHARED;\r\nreturn;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\nif (wdev->cac_started) {\r\n*chan = wdev->channel;\r\n*chanmode = CHAN_MODE_SHARED;\r\n} else if (wdev->beacon_interval) {\r\n*chan = wdev->channel;\r\n*chanmode = CHAN_MODE_SHARED;\r\n}\r\nreturn;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nif (wdev->mesh_id_len) {\r\n*chan = wdev->channel;\r\n*chanmode = CHAN_MODE_SHARED;\r\n}\r\nreturn;\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\nreturn;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nif (wdev->wiphy->features &\r\nNL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL)\r\n*chanmode = CHAN_MODE_EXCLUSIVE;\r\nreturn;\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\ncase NUM_NL80211_IFTYPES:\r\nWARN_ON(1);\r\n}\r\nreturn;\r\n}
