static ssize_t pm8001_ctl_mpi_interface_rev_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.interface_rev);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.interface_rev);\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_fw_version_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x.%02x\n",\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 24),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 16),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev >> 8),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm8001_tbl.firmware_rev));\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x.%02x\n",\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 24),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 16),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev >> 8),\r\n(u8)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.firmware_rev));\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_max_out_io_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.max_out_io);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.max_out_io);\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_max_devices_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\n(u16)(pm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl >> 16)\r\n);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\n(u16)(pm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl >> 16)\r\n);\r\n}\r\n}\r\nstatic ssize_t pm8001_ctl_max_sg_list_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\npm8001_ha->main_cfg_tbl.pm8001_tbl.max_sgl & 0x0000FFFF\r\n);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%04d\n",\r\npm8001_ha->main_cfg_tbl.pm80xx_tbl.max_sgl & 0x0000FFFF\r\n);\r\n}\r\n}\r\nstatic ssize_t\r\nshow_sas_spec_support_status(unsigned int mode, char *buf)\r\n{\r\nssize_t len = 0;\r\nif (mode & SAS_1_1)\r\nlen = sprintf(buf, "%s", "SAS1.1");\r\nif (mode & SAS_2_0)\r\nlen += sprintf(buf + len, "%s%s", len ? ", " : "", "SAS2.0");\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t pm8001_ctl_sas_spec_support_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned int mode;\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nif (pm8001_ha->chip_id == chip_8001)\r\nmode = (pm8001_ha->main_cfg_tbl.pm8001_tbl.ctrl_cap_flag &\r\n0xfe000000)>>25;\r\nelse\r\nmode = (pm8001_ha->main_cfg_tbl.pm80xx_tbl.ctrl_cap_flag &\r\n0xfe000000)>>25;\r\nreturn show_sas_spec_support_status(mode, buf);\r\n}\r\nstatic ssize_t pm8001_ctl_host_sas_address_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%016llx\n",\r\nbe64_to_cpu(*(__be64 *)pm8001_ha->sas_addr));\r\n}\r\nstatic ssize_t pm8001_ctl_logging_level_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nreturn snprintf(buf, PAGE_SIZE, "%08xh\n", pm8001_ha->logging_level);\r\n}\r\nstatic ssize_t pm8001_ctl_logging_level_store(struct device *cdev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nint val = 0;\r\nif (sscanf(buf, "%x", &val) != 1)\r\nreturn -EINVAL;\r\npm8001_ha->logging_level = val;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t pm8001_ctl_aap_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nint i;\r\n#define AAP1_MEMMAP(r, c) \\r\n(*(u32 *)((u8*)pm8001_ha->memoryMap.region[AAP1].virt_ptr + (r) * 32 \\r\n+ (c)))\r\nchar *str = buf;\r\nint max = 2;\r\nfor (i = 0; i < max; i++) {\r\nstr += sprintf(str, "0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x"\r\n"0x%08x 0x%08x\n",\r\nAAP1_MEMMAP(i, 0),\r\nAAP1_MEMMAP(i, 4),\r\nAAP1_MEMMAP(i, 8),\r\nAAP1_MEMMAP(i, 12),\r\nAAP1_MEMMAP(i, 16),\r\nAAP1_MEMMAP(i, 20),\r\nAAP1_MEMMAP(i, 24),\r\nAAP1_MEMMAP(i, 28));\r\n}\r\nreturn str - buf;\r\n}\r\nstatic ssize_t pm8001_ctl_iop_log_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\n#define IOP_MEMMAP(r, c) \\r\n(*(u32 *)((u8*)pm8001_ha->memoryMap.region[IOP].virt_ptr + (r) * 32 \\r\n+ (c)))\r\nint i;\r\nchar *str = buf;\r\nint max = 2;\r\nfor (i = 0; i < max; i++) {\r\nstr += sprintf(str, "0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x"\r\n"0x%08x 0x%08x\n",\r\nIOP_MEMMAP(i, 0),\r\nIOP_MEMMAP(i, 4),\r\nIOP_MEMMAP(i, 8),\r\nIOP_MEMMAP(i, 12),\r\nIOP_MEMMAP(i, 16),\r\nIOP_MEMMAP(i, 20),\r\nIOP_MEMMAP(i, 24),\r\nIOP_MEMMAP(i, 28));\r\n}\r\nreturn str - buf;\r\n}\r\nstatic int pm8001_set_nvmd(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pm8001_ioctl_payload *payload;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nu8 *ioctlbuffer = NULL;\r\nu32 length = 0;\r\nu32 ret = 0;\r\nlength = 1024 * 5 + sizeof(*payload) - 1;\r\nioctlbuffer = kzalloc(length, GFP_KERNEL);\r\nif (!ioctlbuffer)\r\nreturn -ENOMEM;\r\nif ((pm8001_ha->fw_image->size <= 0) ||\r\n(pm8001_ha->fw_image->size > 4096)) {\r\nret = FAIL_FILE_SIZE;\r\ngoto out;\r\n}\r\npayload = (struct pm8001_ioctl_payload *)ioctlbuffer;\r\nmemcpy((u8 *)&payload->func_specific, (u8 *)pm8001_ha->fw_image->data,\r\npm8001_ha->fw_image->size);\r\npayload->length = pm8001_ha->fw_image->size;\r\npayload->id = 0;\r\npayload->minor_function = 0x1;\r\npm8001_ha->nvmd_completion = &completion;\r\nret = PM8001_CHIP_DISP->set_nvmd_req(pm8001_ha, payload);\r\nwait_for_completion(&completion);\r\nout:\r\nkfree(ioctlbuffer);\r\nreturn ret;\r\n}\r\nstatic int pm8001_update_flash(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pm8001_ioctl_payload *payload;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nu8 *ioctlbuffer = NULL;\r\nu32 length = 0;\r\nstruct fw_control_info *fwControl;\r\nu32 loopNumber, loopcount = 0;\r\nu32 sizeRead = 0;\r\nu32 partitionSize, partitionSizeTmp;\r\nu32 ret = 0;\r\nu32 partitionNumber = 0;\r\nstruct pm8001_fw_image_header *image_hdr;\r\nlength = 1024 * 16 + sizeof(*payload) - 1;\r\nioctlbuffer = kzalloc(length, GFP_KERNEL);\r\nimage_hdr = (struct pm8001_fw_image_header *)pm8001_ha->fw_image->data;\r\nif (!ioctlbuffer)\r\nreturn -ENOMEM;\r\nif (pm8001_ha->fw_image->size < 28) {\r\nret = FAIL_FILE_SIZE;\r\ngoto out;\r\n}\r\nwhile (sizeRead < pm8001_ha->fw_image->size) {\r\npartitionSizeTmp =\r\n*(u32 *)((u8 *)&image_hdr->image_length + sizeRead);\r\npartitionSize = be32_to_cpu(partitionSizeTmp);\r\nloopcount = (partitionSize + HEADER_LEN)/IOCTL_BUF_SIZE;\r\nif (loopcount % IOCTL_BUF_SIZE)\r\nloopcount++;\r\nif (loopcount == 0)\r\nloopcount++;\r\nfor (loopNumber = 0; loopNumber < loopcount; loopNumber++) {\r\npayload = (struct pm8001_ioctl_payload *)ioctlbuffer;\r\npayload->length = 1024*16;\r\npayload->id = 0;\r\nfwControl =\r\n(struct fw_control_info *)&payload->func_specific;\r\nfwControl->len = IOCTL_BUF_SIZE;\r\nfwControl->size = partitionSize + HEADER_LEN;\r\nfwControl->retcode = 0;\r\nfwControl->offset = loopNumber * IOCTL_BUF_SIZE;\r\nif (((loopcount-loopNumber) == 1) &&\r\n((partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE)) {\r\nfwControl->len =\r\n(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;\r\nmemcpy((u8 *)fwControl->buffer,\r\n(u8 *)pm8001_ha->fw_image->data + sizeRead,\r\n(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE);\r\nsizeRead +=\r\n(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;\r\n} else {\r\nmemcpy((u8 *)fwControl->buffer,\r\n(u8 *)pm8001_ha->fw_image->data + sizeRead,\r\nIOCTL_BUF_SIZE);\r\nsizeRead += IOCTL_BUF_SIZE;\r\n}\r\npm8001_ha->nvmd_completion = &completion;\r\nret = PM8001_CHIP_DISP->fw_flash_update_req(pm8001_ha, payload);\r\nwait_for_completion(&completion);\r\nif (ret || (fwControl->retcode > FLASH_UPDATE_IN_PROGRESS)) {\r\nret = fwControl->retcode;\r\nkfree(ioctlbuffer);\r\nioctlbuffer = NULL;\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nbreak;\r\npartitionNumber++;\r\n}\r\nout:\r\nkfree(ioctlbuffer);\r\nreturn ret;\r\n}\r\nstatic ssize_t pm8001_store_update_fw(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nchar *cmd_ptr, *filename_ptr;\r\nint res, i;\r\nint flash_command = FLASH_CMD_NONE;\r\nint err = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\ncmd_ptr = kzalloc(count*2, GFP_KERNEL);\r\nif (!cmd_ptr) {\r\nerr = FAIL_OUT_MEMORY;\r\ngoto out;\r\n}\r\nfilename_ptr = cmd_ptr + count;\r\nres = sscanf(buf, "%s %s", cmd_ptr, filename_ptr);\r\nif (res != 2) {\r\nerr = FAIL_PARAMETERS;\r\ngoto out1;\r\n}\r\nfor (i = 0; flash_command_table[i].code != FLASH_CMD_NONE; i++) {\r\nif (!memcmp(flash_command_table[i].command,\r\ncmd_ptr, strlen(cmd_ptr))) {\r\nflash_command = flash_command_table[i].code;\r\nbreak;\r\n}\r\n}\r\nif (flash_command == FLASH_CMD_NONE) {\r\nerr = FAIL_PARAMETERS;\r\ngoto out1;\r\n}\r\nif (pm8001_ha->fw_status == FLASH_IN_PROGRESS) {\r\nerr = FLASH_IN_PROGRESS;\r\ngoto out1;\r\n}\r\nerr = request_firmware(&pm8001_ha->fw_image,\r\nfilename_ptr,\r\npm8001_ha->dev);\r\nif (err) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Failed to load firmware image file %s,"\r\n" error %d\n", filename_ptr, err));\r\nerr = FAIL_OPEN_BIOS_FILE;\r\ngoto out1;\r\n}\r\nswitch (flash_command) {\r\ncase FLASH_CMD_UPDATE:\r\npm8001_ha->fw_status = FLASH_IN_PROGRESS;\r\nerr = pm8001_update_flash(pm8001_ha);\r\nbreak;\r\ncase FLASH_CMD_SET_NVMD:\r\npm8001_ha->fw_status = FLASH_IN_PROGRESS;\r\nerr = pm8001_set_nvmd(pm8001_ha);\r\nbreak;\r\ndefault:\r\npm8001_ha->fw_status = FAIL_PARAMETERS;\r\nerr = FAIL_PARAMETERS;\r\nbreak;\r\n}\r\nrelease_firmware(pm8001_ha->fw_image);\r\nout1:\r\nkfree(cmd_ptr);\r\nout:\r\npm8001_ha->fw_status = err;\r\nif (!err)\r\nreturn count;\r\nelse\r\nreturn -err;\r\n}\r\nstatic ssize_t pm8001_show_update_fw(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;\r\nfor (i = 0; flash_error_table[i].err_code != 0; i++) {\r\nif (flash_error_table[i].err_code == pm8001_ha->fw_status)\r\nbreak;\r\n}\r\nif (pm8001_ha->fw_status != FLASH_IN_PROGRESS)\r\npm8001_ha->fw_status = FLASH_OK;\r\nreturn snprintf(buf, PAGE_SIZE, "status=%x %s\n",\r\nflash_error_table[i].err_code,\r\nflash_error_table[i].reason);\r\n}
