struct nouveau_abi16 *\r\nnouveau_abi16_get(struct drm_file *file_priv, struct drm_device *dev)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nmutex_lock(&cli->mutex);\r\nif (!cli->abi16) {\r\nstruct nouveau_abi16 *abi16;\r\ncli->abi16 = abi16 = kzalloc(sizeof(*abi16), GFP_KERNEL);\r\nif (cli->abi16) {\r\nINIT_LIST_HEAD(&abi16->channels);\r\nabi16->client = nv_object(cli);\r\nif (nouveau_object_new(abi16->client, NVDRM_CLIENT,\r\nNVDRM_DEVICE, 0x0080,\r\n&(struct nv_device_class) {\r\n.device = ~0ULL,\r\n},\r\nsizeof(struct nv_device_class),\r\n&abi16->device) == 0)\r\nreturn cli->abi16;\r\nkfree(cli->abi16);\r\ncli->abi16 = NULL;\r\n}\r\nmutex_unlock(&cli->mutex);\r\n}\r\nreturn cli->abi16;\r\n}\r\nint\r\nnouveau_abi16_put(struct nouveau_abi16 *abi16, int ret)\r\n{\r\nstruct nouveau_cli *cli = (void *)abi16->client;\r\nmutex_unlock(&cli->mutex);\r\nreturn ret;\r\n}\r\nu16\r\nnouveau_abi16_swclass(struct nouveau_drm *drm)\r\n{\r\nswitch (nv_device(drm->device)->card_type) {\r\ncase NV_04:\r\nreturn 0x006e;\r\ncase NV_10:\r\ncase NV_20:\r\ncase NV_30:\r\ncase NV_40:\r\nreturn 0x016e;\r\ncase NV_50:\r\nreturn 0x506e;\r\ncase NV_C0:\r\ncase NV_D0:\r\ncase NV_E0:\r\nreturn 0x906e;\r\n}\r\nreturn 0x0000;\r\n}\r\nstatic void\r\nnouveau_abi16_ntfy_fini(struct nouveau_abi16_chan *chan,\r\nstruct nouveau_abi16_ntfy *ntfy)\r\n{\r\nnouveau_mm_free(&chan->heap, &ntfy->node);\r\nlist_del(&ntfy->head);\r\nkfree(ntfy);\r\n}\r\nstatic void\r\nnouveau_abi16_chan_fini(struct nouveau_abi16 *abi16,\r\nstruct nouveau_abi16_chan *chan)\r\n{\r\nstruct nouveau_abi16_ntfy *ntfy, *temp;\r\nif (chan->chan && chan->ntfy)\r\nnouveau_channel_idle(chan->chan);\r\nlist_for_each_entry_safe(ntfy, temp, &chan->notifiers, head) {\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\n}\r\nif (chan->ntfy) {\r\nnouveau_bo_vma_del(chan->ntfy, &chan->ntfy_vma);\r\nnouveau_bo_unpin(chan->ntfy);\r\ndrm_gem_object_unreference_unlocked(chan->ntfy->gem);\r\n}\r\nif (chan->heap.block_size)\r\nnouveau_mm_fini(&chan->heap);\r\nif (chan->chan) {\r\nabi16->handles &= ~(1 << (chan->chan->handle & 0xffff));\r\nnouveau_channel_del(&chan->chan);\r\n}\r\nlist_del(&chan->head);\r\nkfree(chan);\r\n}\r\nvoid\r\nnouveau_abi16_fini(struct nouveau_abi16 *abi16)\r\n{\r\nstruct nouveau_cli *cli = (void *)abi16->client;\r\nstruct nouveau_abi16_chan *chan, *temp;\r\nlist_for_each_entry_safe(chan, temp, &abi16->channels, head) {\r\nnouveau_abi16_chan_fini(abi16, chan);\r\n}\r\nnouveau_object_del(abi16->client, NVDRM_CLIENT, NVDRM_DEVICE);\r\nkfree(cli->abi16);\r\ncli->abi16 = NULL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_getparam(ABI16_IOCTL_ARGS)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_timer *ptimer = nouveau_timer(device);\r\nstruct nouveau_graph *graph = (void *)nouveau_engine(device, NVDEV_ENGINE_GR);\r\nstruct drm_nouveau_getparam *getparam = data;\r\nswitch (getparam->param) {\r\ncase NOUVEAU_GETPARAM_CHIPSET_ID:\r\ngetparam->value = device->chipset;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PCI_VENDOR:\r\ngetparam->value = dev->pci_vendor;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PCI_DEVICE:\r\ngetparam->value = dev->pci_device;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_BUS_TYPE:\r\nif (drm_pci_device_is_agp(dev))\r\ngetparam->value = 0;\r\nelse\r\nif (!pci_is_pcie(dev->pdev))\r\ngetparam->value = 1;\r\nelse\r\ngetparam->value = 2;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_FB_SIZE:\r\ngetparam->value = drm->gem.vram_available;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_AGP_SIZE:\r\ngetparam->value = drm->gem.gart_available;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_VM_VRAM_BASE:\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PTIMER_TIME:\r\ngetparam->value = ptimer->read(ptimer);\r\nbreak;\r\ncase NOUVEAU_GETPARAM_HAS_BO_USAGE:\r\ngetparam->value = 1;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_HAS_PAGEFLIP:\r\ngetparam->value = 1;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_GRAPH_UNITS:\r\ngetparam->value = graph->units ? graph->units(graph) : 0;\r\nbreak;\r\ndefault:\r\nnv_debug(device, "unknown parameter %lld\n", getparam->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_abi16_ioctl_setparam(ABI16_IOCTL_ARGS)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_channel_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_channel_alloc *init = data;\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_client *client;\r\nstruct nouveau_device *device;\r\nstruct nouveau_instmem *imem;\r\nstruct nouveau_fb *pfb;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (!drm->channel)\r\nreturn nouveau_abi16_put(abi16, -ENODEV);\r\nclient = nv_client(abi16->client);\r\ndevice = nv_device(abi16->device);\r\nimem = nouveau_instmem(device);\r\npfb = nouveau_fb(device);\r\nif (device->card_type >= NV_E0) {\r\nif (init->fb_ctxdma_handle != ~0)\r\ninit->fb_ctxdma_handle = NVE0_CHANNEL_IND_ENGINE_GR;\r\nelse\r\ninit->fb_ctxdma_handle = init->tt_ctxdma_handle;\r\ninit->tt_ctxdma_handle = 0;\r\nif (init->fb_ctxdma_handle == NVE0_CHANNEL_IND_ENGINE_GR)\r\ninit->tt_ctxdma_handle = 1;\r\n}\r\nif (init->fb_ctxdma_handle == ~0 || init->tt_ctxdma_handle == ~0)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\ninit->channel = ffsll(~abi16->handles);\r\nif (!init->channel--)\r\nreturn nouveau_abi16_put(abi16, -ENOSPC);\r\nchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nINIT_LIST_HEAD(&chan->notifiers);\r\nlist_add(&chan->head, &abi16->channels);\r\nabi16->handles |= (1 << init->channel);\r\nret = nouveau_channel_new(drm, cli, NVDRM_DEVICE, NVDRM_CHAN |\r\ninit->channel, init->fb_ctxdma_handle,\r\ninit->tt_ctxdma_handle, &chan->chan);\r\nif (ret)\r\ngoto done;\r\nif (device->card_type >= NV_50)\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM |\r\nNOUVEAU_GEM_DOMAIN_GART;\r\nelse\r\nif (chan->chan->push.buffer->bo.mem.mem_type == TTM_PL_VRAM)\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM;\r\nelse\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_GART;\r\nif (device->card_type < NV_C0) {\r\ninit->subchan[0].handle = 0x00000000;\r\ninit->subchan[0].grclass = 0x0000;\r\ninit->subchan[1].handle = NvSw;\r\ninit->subchan[1].grclass = 0x506e;\r\ninit->nr_subchan = 2;\r\n}\r\nret = nouveau_gem_new(dev, PAGE_SIZE, 0, NOUVEAU_GEM_DOMAIN_GART,\r\n0, 0, &chan->ntfy);\r\nif (ret == 0)\r\nret = nouveau_bo_pin(chan->ntfy, TTM_PL_FLAG_TT);\r\nif (ret)\r\ngoto done;\r\nif (device->card_type >= NV_50) {\r\nret = nouveau_bo_vma_add(chan->ntfy, client->vm,\r\n&chan->ntfy_vma);\r\nif (ret)\r\ngoto done;\r\n}\r\nret = drm_gem_handle_create(file_priv, chan->ntfy->gem,\r\n&init->notifier_handle);\r\nif (ret)\r\ngoto done;\r\nret = nouveau_mm_init(&chan->heap, 0, PAGE_SIZE, 1);\r\ndone:\r\nif (ret)\r\nnouveau_abi16_chan_fini(abi16, chan);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_channel_free(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_channel_free *req = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan;\r\nint ret = -ENOENT;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nlist_for_each_entry(chan, &abi16->channels, head) {\r\nif (chan->chan->handle == (NVDRM_CHAN | req->channel)) {\r\nnouveau_abi16_chan_fini(abi16, chan);\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}\r\n}\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_grobj_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_grobj_alloc *init = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_object *object;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (init->handle == ~0)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nif (init->class == 0x506e) {\r\ninit->class = nouveau_abi16_swclass(drm);\r\nif (init->class == 0x906e)\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}\r\nret = nouveau_object_new(abi16->client, NVDRM_CHAN | init->channel,\r\ninit->handle, init->class, NULL, 0, &object);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_notifierobj_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_notifierobj_alloc *info = data;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan = NULL, *temp;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nstruct nouveau_object *object;\r\nstruct nv_dma_class args = {};\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (unlikely(nv_device(abi16->device)->card_type >= NV_C0))\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nlist_for_each_entry(temp, &abi16->channels, head) {\r\nif (temp->chan->handle == (NVDRM_CHAN | info->channel)) {\r\nchan = temp;\r\nbreak;\r\n}\r\n}\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nntfy = kzalloc(sizeof(*ntfy), GFP_KERNEL);\r\nif (!ntfy)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nlist_add(&ntfy->head, &chan->notifiers);\r\nntfy->handle = info->handle;\r\nret = nouveau_mm_head(&chan->heap, 1, info->size, info->size, 1,\r\n&ntfy->node);\r\nif (ret)\r\ngoto done;\r\nargs.start = ntfy->node->offset;\r\nargs.limit = ntfy->node->offset + ntfy->node->length - 1;\r\nif (device->card_type >= NV_50) {\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_VM;\r\nargs.start += chan->ntfy_vma.offset;\r\nargs.limit += chan->ntfy_vma.offset;\r\n} else\r\nif (drm->agp.stat == ENABLED) {\r\nargs.flags = NV_DMA_TARGET_AGP | NV_DMA_ACCESS_RDWR;\r\nargs.start += drm->agp.base + chan->ntfy->bo.offset;\r\nargs.limit += drm->agp.base + chan->ntfy->bo.offset;\r\n} else {\r\nargs.flags = NV_DMA_TARGET_VM | NV_DMA_ACCESS_RDWR;\r\nargs.start += chan->ntfy->bo.offset;\r\nargs.limit += chan->ntfy->bo.offset;\r\n}\r\nret = nouveau_object_new(abi16->client, chan->chan->handle,\r\nntfy->handle, 0x003d, &args,\r\nsizeof(args), &object);\r\nif (ret)\r\ngoto done;\r\ndone:\r\nif (ret)\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_gpuobj_free(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_gpuobj_free *fini = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan = NULL, *temp;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nlist_for_each_entry(temp, &abi16->channels, head) {\r\nif (temp->chan->handle == (NVDRM_CHAN | fini->channel)) {\r\nchan = temp;\r\nbreak;\r\n}\r\n}\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nnouveau_channel_idle(chan->chan);\r\nret = nouveau_object_del(abi16->client, chan->chan->handle, fini->handle);\r\nif (ret)\r\nreturn nouveau_abi16_put(abi16, ret);\r\nlist_for_each_entry(ntfy, &chan->notifiers, head) {\r\nif (ntfy->handle == fini->handle) {\r\nnouveau_mm_free(&chan->heap, &ntfy->node);\r\nlist_del(&ntfy->head);\r\nbreak;\r\n}\r\n}\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}
