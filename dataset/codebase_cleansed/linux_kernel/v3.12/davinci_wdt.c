static void wdt_service(void)\r\n{\r\nspin_lock(&io_lock);\r\niowrite32(WDKEY_SEQ0, wdt_base + WDTCR);\r\niowrite32(WDKEY_SEQ1, wdt_base + WDTCR);\r\nspin_unlock(&io_lock);\r\n}\r\nstatic void wdt_enable(void)\r\n{\r\nu32 tgcr;\r\nu32 timer_margin;\r\nunsigned long wdt_freq;\r\nwdt_freq = clk_get_rate(wdt_clk);\r\nspin_lock(&io_lock);\r\niowrite32(0, wdt_base + TCR);\r\niowrite32(0, wdt_base + TGCR);\r\ntgcr = TIMMODE_64BIT_WDOG | TIM12RS_UNRESET | TIM34RS_UNRESET;\r\niowrite32(tgcr, wdt_base + TGCR);\r\niowrite32(0, wdt_base + TIM12);\r\niowrite32(0, wdt_base + TIM34);\r\ntimer_margin = (((u64)heartbeat * wdt_freq) & 0xffffffff);\r\niowrite32(timer_margin, wdt_base + PRD12);\r\ntimer_margin = (((u64)heartbeat * wdt_freq) >> 32);\r\niowrite32(timer_margin, wdt_base + PRD34);\r\niowrite32(ENAMODE12_PERIODIC, wdt_base + TCR);\r\niowrite32(WDKEY_SEQ0 | WDEN, wdt_base + WDTCR);\r\niowrite32(WDKEY_SEQ1 | WDEN, wdt_base + WDTCR);\r\nspin_unlock(&io_lock);\r\n}\r\nstatic int davinci_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(WDT_IN_USE, &wdt_status))\r\nreturn -EBUSY;\r\nwdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t\r\ndavinci_wdt_write(struct file *file, const char *data, size_t len,\r\nloff_t *ppos)\r\n{\r\nif (len)\r\nwdt_service();\r\nreturn len;\r\n}\r\nstatic long davinci_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret = -ENOTTY;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user((struct watchdog_info *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(0, (int *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nwdt_service();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(heartbeat, (int *)arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nwdt_service();\r\nclear_bit(WDT_IN_USE, &wdt_status);\r\nreturn 0;\r\n}\r\nstatic int davinci_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *wdt_mem;\r\nwdt_clk = devm_clk_get(dev, NULL);\r\nif (WARN_ON(IS_ERR(wdt_clk)))\r\nreturn PTR_ERR(wdt_clk);\r\nclk_prepare_enable(wdt_clk);\r\nif (heartbeat < 1 || heartbeat > MAX_HEARTBEAT)\r\nheartbeat = DEFAULT_HEARTBEAT;\r\ndev_info(dev, "heartbeat %d sec\n", heartbeat);\r\nwdt_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt_base = devm_ioremap_resource(dev, wdt_mem);\r\nif (IS_ERR(wdt_base))\r\nreturn PTR_ERR(wdt_base);\r\nret = misc_register(&davinci_wdt_miscdev);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot register misc device\n");\r\n} else {\r\nset_bit(WDT_DEVICE_INITED, &wdt_status);\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_wdt_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&davinci_wdt_miscdev);\r\nclk_disable_unprepare(wdt_clk);\r\nreturn 0;\r\n}
