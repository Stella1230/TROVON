static void hex_dump(char *str, u8 *src_buf, u32 src_buf_len)\r\n{\r\nunsigned char *pt;\r\nint x;\r\npt = src_buf;\r\nBT_DBG("%s: %p, len = %d\n", str, src_buf, src_buf_len);\r\nfor (x = 0; x < src_buf_len; x++) {\r\nif (x % 16 == 0)\r\nBT_DBG("0x%04x : ", x);\r\nBT_DBG("%02x ", ((unsigned char)pt[x]));\r\nif (x % 16 == 15)\r\nBT_DBG("\n");\r\n}\r\nBT_DBG("\n");\r\n}\r\nstatic int btmtk_usb_reset(struct usb_device *udev)\r\n{\r\nint ret;\r\nBT_DBG("%s\n", __func__);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x01, DEVICE_VENDOR_REQUEST_OUT,\r\n0x01, 0x00, NULL, 0x00, CONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\nBT_ERR("%s error(%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int btmtk_usb_io_read32(struct btmtk_usb_data *data, u32 reg, u32 *val)\r\n{\r\nu8 request = data->r_request;\r\nstruct usb_device *udev = data->udev;\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), request, DEVICE_VENDOR_REQUEST_IN,\r\n0x0, reg, data->io_buf, 4,\r\nCONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\n*val = 0xffffffff;\r\nBT_ERR("%s error(%d), reg=%x, value=%x\n", __func__, ret, reg, *val);\r\nreturn ret;\r\n}\r\nmemmove(val, data->io_buf, 4);\r\n*val = le32_to_cpu(*val);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int btmtk_usb_io_write32(struct btmtk_usb_data *data, u32 reg, u32 val)\r\n{\r\nu16 value, index;\r\nu8 request = data->w_request;\r\nstruct usb_device *udev = data->udev;\r\nint ret;\r\nindex = (u16)reg;\r\nvalue = val & 0x0000ffff;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), request, DEVICE_VENDOR_REQUEST_OUT,\r\nvalue, index, NULL, 0,\r\nCONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\nBT_ERR("%s error(%d), reg=%x, value=%x\n", __func__, ret, reg, val);\r\nreturn ret;\r\n}\r\nindex = (u16)(reg + 2);\r\nvalue = (val & 0xffff0000) >> 16;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nrequest, DEVICE_VENDOR_REQUEST_OUT,\r\nvalue, index, NULL, 0, CONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\nBT_ERR("%s error(%d), reg=%x, value=%x\n", __func__, ret, reg, val);\r\nreturn ret;\r\n}\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int btmtk_usb_switch_iobase(struct btmtk_usb_data *data, int base)\r\n{\r\nint ret = 0;\r\nswitch (base) {\r\ncase SYSCTL:\r\ndata->w_request = 0x42;\r\ndata->r_request = 0x47;\r\nbreak;\r\ncase WLAN:\r\ndata->w_request = 0x02;\r\ndata->r_request = 0x07;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void btmtk_usb_cap_init(struct btmtk_usb_data *data)\r\n{\r\nconst struct firmware *firmware;\r\nstruct usb_device *udev = data->udev;\r\nint ret;\r\nbtmtk_usb_io_read32(data, 0x00, &data->chip_id);\r\nBT_DBG("chip id = %x\n", data->chip_id);\r\nif (is_mt7630(data) || is_mt7650(data)) {\r\ndata->need_load_fw = 1;\r\ndata->need_load_rom_patch = 0;\r\nret = request_firmware(&firmware, MT7650_FIRMWARE, &udev->dev);\r\nif (ret < 0) {\r\nif (ret == -ENOENT) {\r\nBT_ERR("Firmware file \"%s\" not found \n", MT7650_FIRMWARE);\r\n} else {\r\nBT_ERR("Firmware file \"%s\" request failed (err=%d) \n",\r\nMT7650_FIRMWARE, ret);\r\n}\r\n} else {\r\nBT_DBG("Firmware file \"%s\" Found \n", MT7650_FIRMWARE);\r\ndata->firmware = firmware;\r\nbtmtk_usb_load_fw(data);\r\n}\r\nrelease_firmware(firmware);\r\n} else if (is_mt7632(data) || is_mt7662(data)) {\r\ndata->need_load_fw = 0;\r\ndata->need_load_rom_patch = 1;\r\ndata->rom_patch_offset = 0x90000;\r\nret = request_firmware(&firmware, MT7662_FIRMWARE, &udev->dev);\r\nif (ret < 0) {\r\nif (ret == -ENOENT) {\r\nBT_ERR("Firmware file \"%s\" not found\n", MT7662_FIRMWARE);\r\n} else {\r\nBT_ERR("Firmware file \"%s\" request failed (err=%d)\n",\r\nMT7662_FIRMWARE, ret);\r\n}\r\n} else {\r\nBT_DBG("Firmware file \"%s\" Found\n", MT7662_FIRMWARE);\r\ndata->firmware = firmware;\r\ndata->rom_patch_len = firmware->size;\r\nbtmtk_usb_load_rom_patch(data);\r\n}\r\nrelease_firmware(firmware);\r\n} else {\r\nBT_ERR("unknow chip(%x)\n", data->chip_id);\r\n}\r\n}\r\nstatic u16 checksume16(u8 *pData, int len)\r\n{\r\nint sum = 0;\r\nwhile (len > 1) {\r\nsum += *((u16 *)pData);\r\npData = pData + 2;\r\nif (sum & 0x80000000)\r\nsum = (sum & 0xFFFF) + (sum >> 16);\r\nlen -= 2;\r\n}\r\nif (len)\r\nsum += *((u8 *)pData);\r\nwhile (sum >> 16) {\r\nsum = (sum & 0xFFFF) + (sum >> 16);\r\n}\r\nreturn ~sum;\r\n}\r\nstatic int btmtk_usb_chk_crc(struct btmtk_usb_data *data, u32 checksum_len)\r\n{\r\nint ret = 0;\r\nstruct usb_device *udev = data->udev;\r\nBT_DBG("%s\n", __func__);\r\nmemmove(data->io_buf, &data->rom_patch_offset, 4);\r\nmemmove(&data->io_buf[4], &checksum_len, 4);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x1, DEVICE_VENDOR_REQUEST_IN,\r\n0x20, 0x00, data->io_buf, 8,\r\nCONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\nBT_ERR("%s error(%d)\n", __func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 btmtk_usb_get_crc(struct btmtk_usb_data *data)\r\n{\r\nint ret = 0;\r\nstruct usb_device *udev = data->udev;\r\nu16 crc, count = 0;\r\nBT_DBG("%s\n", __func__);\r\nwhile (1) {\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x01, DEVICE_VENDOR_REQUEST_IN,\r\n0x21, 0x00, data->io_buf, 2,\r\nCONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\ncrc = 0xFFFF;\r\nBT_ERR("%s error(%d)\n", __func__, ret);\r\n}\r\nmemmove(&crc, data->io_buf, 2);\r\ncrc = le16_to_cpu(crc);\r\nif (crc != 0xFFFF)\r\nbreak;\r\nmdelay(100);\r\nif (count++ > 100) {\r\nBT_ERR("Query CRC over %d times\n", count);\r\nbreak;\r\n}\r\n}\r\nreturn crc;\r\n}\r\nstatic int btmtk_usb_reset_wmt(struct btmtk_usb_data *data)\r\n{\r\nint ret = 0;\r\nu8 cmd[8] = {0x6F, 0xFC, 0x05, 0x01, 0x07, 0x01, 0x00, 0x04};\r\nmemmove(data->io_buf, cmd, 8);\r\nBT_DBG("%s\n", __func__);\r\nret = usb_control_msg(data->udev, usb_sndctrlpipe(data->udev, 0), 0x01,\r\nDEVICE_CLASS_REQUEST_OUT, 0x12, 0x00, data->io_buf,\r\n8, CONTROL_TIMEOUT_JIFFIES);\r\nif (ret)\r\nBT_ERR("%s:(%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void load_rom_patch_complete(struct urb *urb)\r\n{\r\nstruct completion *sent_to_mcu_done = (struct completion *)urb->context;\r\ncomplete(sent_to_mcu_done);\r\n}\r\nstatic int btmtk_usb_load_rom_patch(struct btmtk_usb_data *data)\r\n{\r\nu32 loop = 0;\r\nu32 value;\r\ns32 sent_len;\r\nint ret = 0, total_checksum = 0;\r\nstruct urb *urb;\r\nu32 patch_len = 0;\r\nu32 cur_len = 0;\r\ndma_addr_t data_dma;\r\nstruct completion sent_to_mcu_done;\r\nint first_block = 1;\r\nunsigned char phase;\r\nvoid *buf;\r\nchar *pos;\r\nunsigned int pipe = usb_sndbulkpipe(data->udev, data->bulk_tx_ep->bEndpointAddress);\r\nif (!data->firmware) {\r\nBT_ERR("%s:please assign a rom patch\n", __func__);\r\nreturn -1;\r\n}\r\nload_patch_protect:\r\nbtmtk_usb_switch_iobase(data, WLAN);\r\nbtmtk_usb_io_read32(data, SEMAPHORE_03, &value);\r\nloop++;\r\nif (((value & 0x01) == 0x00) && (loop < 600)) {\r\nmdelay(1);\r\ngoto load_patch_protect;\r\n}\r\nbtmtk_usb_io_write32(data, 0x1004, 0x2c);\r\nbtmtk_usb_switch_iobase(data, SYSCTL);\r\nbtmtk_usb_io_write32(data, 0x1c, 0x30);\r\nbtmtk_usb_io_write32(data, 0x9018, 0x00c00020);\r\nbtmtk_usb_switch_iobase(data, WLAN);\r\nbtmtk_usb_io_read32(data, COM_REG0, &value);\r\nif ((value & 0x02) == 0x02)\r\ngoto error0;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nret = -ENOMEM;\r\ngoto error0;\r\n}\r\nbuf = usb_alloc_coherent(data->udev, UPLOAD_PATCH_UNIT, GFP_ATOMIC, &data_dma);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\npos = buf;\r\nBT_DBG("loading rom patch");\r\ninit_completion(&sent_to_mcu_done);\r\ncur_len = 0x00;\r\npatch_len = data->rom_patch_len - PATCH_INFO_SIZE;\r\nwhile (1) {\r\ns32 sent_len_max = UPLOAD_PATCH_UNIT - PATCH_HEADER_SIZE;\r\nsent_len = (patch_len - cur_len) >= sent_len_max ? sent_len_max : (patch_len - cur_len);\r\nBT_DBG("patch_len = %d\n", patch_len);\r\nBT_DBG("cur_len = %d\n", cur_len);\r\nBT_DBG("sent_len = %d\n", sent_len);\r\nif (sent_len > 0) {\r\nif (first_block == 1) {\r\nif (sent_len < sent_len_max)\r\nphase = PATCH_PHASE3;\r\nelse\r\nphase = PATCH_PHASE1;\r\nfirst_block = 0;\r\n} else if (sent_len == sent_len_max) {\r\nphase = PATCH_PHASE2;\r\n} else {\r\nphase = PATCH_PHASE3;\r\n}\r\npos[0] = 0x6F;\r\npos[1] = 0xFC;\r\npos[2] = (sent_len + 5) & 0xFF;\r\npos[3] = ((sent_len + 5) >> 8) & 0xFF;\r\npos[4] = 0x01;\r\npos[5] = 0x01;\r\npos[6] = (sent_len + 1) & 0xFF;\r\npos[7] = ((sent_len + 1) >> 8) & 0xFF;\r\npos[8] = phase;\r\nmemcpy(&pos[9], data->firmware->data + PATCH_INFO_SIZE + cur_len, sent_len);\r\nBT_DBG("sent_len + PATCH_HEADER_SIZE = %d, phase = %d\n",\r\nsent_len + PATCH_HEADER_SIZE, phase);\r\nusb_fill_bulk_urb(urb,\r\ndata->udev,\r\npipe,\r\nbuf,\r\nsent_len + PATCH_HEADER_SIZE,\r\nload_rom_patch_complete,\r\n&sent_to_mcu_done);\r\nurb->transfer_dma = data_dma;\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\ngoto error2;\r\nif (!wait_for_completion_timeout(&sent_to_mcu_done, msecs_to_jiffies(1000))) {\r\nusb_kill_urb(urb);\r\nBT_ERR("upload rom_patch timeout\n");\r\ngoto error2;\r\n}\r\nBT_DBG(".");\r\nmdelay(200);\r\ncur_len += sent_len;\r\n} else {\r\nbreak;\r\n}\r\n}\r\ntotal_checksum = checksume16((u8 *)data->firmware->data + PATCH_INFO_SIZE, patch_len);\r\nBT_DBG("Send checksum req..\n");\r\nbtmtk_usb_chk_crc(data, patch_len);\r\nmdelay(20);\r\nif (total_checksum != btmtk_usb_get_crc(data)) {\r\nBT_ERR("checksum fail!, local(0x%x) <> fw(0x%x)\n",\r\ntotal_checksum, btmtk_usb_get_crc(data));\r\nret = -1;\r\ngoto error2;\r\n}\r\nmdelay(20);\r\nret = btmtk_usb_reset_wmt(data);\r\nmdelay(20);\r\nerror2:\r\nusb_free_coherent(data->udev, UPLOAD_PATCH_UNIT, buf, data_dma);\r\nerror1:\r\nusb_free_urb(urb);\r\nerror0:\r\nbtmtk_usb_io_write32(data, SEMAPHORE_03, 0x1);\r\nreturn ret;\r\n}\r\nstatic int load_fw_iv(struct btmtk_usb_data *data)\r\n{\r\nint ret;\r\nstruct usb_device *udev = data->udev;\r\nchar *buf = kmalloc(64, GFP_ATOMIC);\r\nmemmove(buf, data->firmware->data + 32, 64);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x01,\r\nDEVICE_VENDOR_REQUEST_OUT, 0x12, 0x0, buf, 64,\r\nCONTROL_TIMEOUT_JIFFIES);\r\nif (ret < 0) {\r\nBT_ERR("%s error(%d) step4\n", __func__, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nif (ret > 0)\r\nret = 0;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void load_fw_complete(struct urb *urb)\r\n{\r\nstruct completion *sent_to_mcu_done = (struct completion *)urb->context;\r\ncomplete(sent_to_mcu_done);\r\n}\r\nstatic int btmtk_usb_load_fw(struct btmtk_usb_data *data)\r\n{\r\nstruct usb_device *udev = data->udev;\r\nstruct urb *urb;\r\nvoid *buf;\r\nu32 cur_len = 0;\r\nu32 packet_header = 0;\r\nu32 value;\r\nu32 ilm_len = 0, dlm_len = 0;\r\nu16 fw_ver, build_ver;\r\nu32 loop = 0;\r\ndma_addr_t data_dma;\r\nint ret = 0, sent_len;\r\nstruct completion sent_to_mcu_done;\r\nunsigned int pipe = usb_sndbulkpipe(data->udev, data->bulk_tx_ep->bEndpointAddress);\r\nif (!data->firmware) {\r\nBT_ERR("%s:please assign a fw\n", __func__);\r\nreturn -1;\r\n}\r\nBT_DBG("bulk_tx_ep = %x\n", data->bulk_tx_ep->bEndpointAddress);\r\nloadfw_protect:\r\nbtmtk_usb_switch_iobase(data, WLAN);\r\nbtmtk_usb_io_read32(data, SEMAPHORE_00, &value);\r\nloop++;\r\nif (((value & 0x1) == 0) && (loop < 10000))\r\ngoto loadfw_protect;\r\nbtmtk_usb_io_read32(data, COM_REG0, &value);\r\nif ((value & 0x01) == 0x01)\r\ngoto error0;\r\nbtmtk_usb_io_write32(data, 0x238, 0x1c000000);\r\nbtmtk_usb_reset(udev);\r\nmdelay(100);\r\nilm_len = (*(data->firmware->data + 3) << 24)\r\n| (*(data->firmware->data + 2) << 16)\r\n| (*(data->firmware->data + 1) << 8)\r\n| (*data->firmware->data);\r\ndlm_len = (*(data->firmware->data + 7) << 24)\r\n| (*(data->firmware->data + 6) << 16)\r\n| (*(data->firmware->data + 5) << 8)\r\n| (*(data->firmware->data + 4));\r\nfw_ver = (*(data->firmware->data + 11) << 8) | (*(data->firmware->data + 10));\r\nbuild_ver = (*(data->firmware->data + 9) << 8) | (*(data->firmware->data + 8));\r\nBT_DBG("fw version:%d.%d.%02d ",\r\n(fw_ver & 0xf000) >> 8,\r\n(fw_ver & 0x0f00) >> 8,\r\n(fw_ver & 0x00ff));\r\nBT_DBG("build:%x\n", build_ver);\r\nBT_DBG("build Time =");\r\nfor (loop = 0; loop < 16; loop++)\r\nBT_DBG("%c", *(data->firmware->data + 16 + loop));\r\nBT_DBG("\n");\r\nBT_DBG("ILM length = %d(bytes)\n", ilm_len);\r\nBT_DBG("DLM length = %d(bytes)\n", dlm_len);\r\nbtmtk_usb_switch_iobase(data, SYSCTL);\r\nbtmtk_usb_io_write32(data, 0x790, 0x400230);\r\nbtmtk_usb_io_write32(data, 0x794, 0x1);\r\nbtmtk_usb_io_write32(data, 0x798, 0x1);\r\nbtmtk_usb_io_write32(data, 0x704, 0x44);\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\nbuf = usb_alloc_coherent(udev, 14592, GFP_ATOMIC, &data_dma);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto error2;\r\n}\r\nBT_DBG("loading fw");\r\ninit_completion(&sent_to_mcu_done);\r\nbtmtk_usb_switch_iobase(data, SYSCTL);\r\ncur_len = 0x40;\r\nwhile (1) {\r\nsent_len = (ilm_len - cur_len) >= 14336 ? 14336 : (ilm_len - cur_len);\r\nif (sent_len > 0) {\r\npacket_header &= ~(0xffffffff);\r\npacket_header |= (sent_len << 16);\r\npacket_header = cpu_to_le32(packet_header);\r\nmemmove(buf, &packet_header, 4);\r\nmemmove(buf + 4, data->firmware->data + 32 + cur_len, sent_len);\r\nbtmtk_usb_io_write32(data, 0x230, cur_len);\r\nwhile ((sent_len % 4) != 0) {\r\nsent_len++;\r\n}\r\nbtmtk_usb_io_write32(data, 0x234, sent_len << 16);\r\nusb_fill_bulk_urb(urb,\r\nudev,\r\npipe,\r\nbuf,\r\nsent_len + 4,\r\nload_fw_complete,\r\n&sent_to_mcu_done);\r\nurb->transfer_dma = data_dma;\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\ngoto error3;\r\nif (!wait_for_completion_timeout(&sent_to_mcu_done, msecs_to_jiffies(1000))) {\r\nusb_kill_urb(urb);\r\nBT_ERR("upload ilm fw timeout\n");\r\ngoto error3;\r\n}\r\nBT_DBG(".");\r\nmdelay(200);\r\ncur_len += sent_len;\r\n} else {\r\nbreak;\r\n}\r\n}\r\ninit_completion(&sent_to_mcu_done);\r\ncur_len = 0x00;\r\nwhile (1) {\r\nsent_len = (dlm_len - cur_len) >= 14336 ? 14336 : (dlm_len - cur_len);\r\nif (sent_len > 0) {\r\npacket_header &= ~(0xffffffff);\r\npacket_header |= (sent_len << 16);\r\npacket_header = cpu_to_le32(packet_header);\r\nmemmove(buf, &packet_header, 4);\r\nmemmove(buf + 4, data->firmware->data + 32 + ilm_len + cur_len, sent_len);\r\nbtmtk_usb_io_write32(data, 0x230, 0x80000 + cur_len);\r\nwhile ((sent_len % 4) != 0) {\r\nBT_DBG("sent_len is not divided by 4\n");\r\nsent_len++;\r\n}\r\nbtmtk_usb_io_write32(data, 0x234, sent_len << 16);\r\nusb_fill_bulk_urb(urb,\r\nudev,\r\npipe,\r\nbuf,\r\nsent_len + 4,\r\nload_fw_complete,\r\n&sent_to_mcu_done);\r\nurb->transfer_dma = data_dma;\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\ngoto error3;\r\nif (!wait_for_completion_timeout(&sent_to_mcu_done, msecs_to_jiffies(1000))) {\r\nusb_kill_urb(urb);\r\nBT_ERR("upload dlm fw timeout\n");\r\ngoto error3;\r\n}\r\nBT_DBG(".");\r\nmdelay(500);\r\ncur_len += sent_len;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nret = load_fw_iv(data);\r\nmdelay(100);\r\nbtmtk_usb_switch_iobase(data, WLAN);\r\nloop = 0;\r\ndo {\r\nbtmtk_usb_io_read32(data, COM_REG0, &value);\r\nif (value == 0x01)\r\nbreak;\r\nmdelay(10);\r\nloop++;\r\n} while (loop <= 100);\r\nif (loop > 1000) {\r\nBT_ERR("wait for 100 times\n");\r\nret = -ENODEV;\r\n}\r\nerror3:\r\nusb_free_coherent(udev, 14592, buf, data_dma);\r\nerror2:\r\nusb_free_urb(urb);\r\nerror1:\r\nbtmtk_usb_io_read32(data, 0x238, &value);\r\nvalue = value & ~(0x10000000);\r\nbtmtk_usb_io_write32(data, 0x238, value);\r\nerror0:\r\nbtmtk_usb_io_write32(data, SEMAPHORE_00, 0x1);\r\nreturn ret;\r\n}\r\nstatic int inc_tx(struct btmtk_usb_data *data)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nspin_lock_irqsave(&data->txlock, flags);\r\nrv = test_bit(BTUSB_SUSPENDING, &data->flags);\r\nif (!rv)\r\ndata->tx_in_flight++;\r\nspin_unlock_irqrestore(&data->txlock, flags);\r\nreturn rv;\r\n}\r\nstatic void btmtk_usb_intr_complete(struct urb *urb)\r\n{\r\nstruct hci_dev *hdev = urb->context;\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s: %s urb %p status %d count %d\n", __func__, hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn;\r\nif (urb->status == 0) {\r\nhdev->stat.byte_rx += urb->actual_length;\r\nhex_dump("hci event", urb->transfer_buffer, urb->actual_length);\r\nif (hci_recv_fragment(hdev, HCI_EVENT_PKT,\r\nurb->transfer_buffer,\r\nurb->actual_length) < 0) {\r\nBT_ERR("%s corrupted event packet", hdev->name);\r\nhdev->stat.err_rx++;\r\n}\r\n}\r\nif (!test_bit(BTUSB_INTR_RUNNING, &data->flags))\r\nreturn;\r\nusb_mark_last_busy(data->udev);\r\nusb_anchor_urb(urb, &data->intr_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p failed to resubmit (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\n}\r\nstatic int btmtk_usb_submit_intr_urb(struct hci_dev *hdev, gfp_t mem_flags)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size;\r\nBT_DBG("%s\n", __func__);\r\nif (!data->intr_ep)\r\nreturn -ENODEV;\r\nurb = usb_alloc_urb(0, mem_flags);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nsize = le16_to_cpu(data->intr_ep->wMaxPacketSize);\r\nbuf = kmalloc(size, mem_flags);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvintpipe(data->udev, data->intr_ep->bEndpointAddress);\r\nusb_fill_int_urb(urb, data->udev, pipe, buf, size,\r\nbtmtk_usb_intr_complete, hdev,\r\ndata->intr_ep->bInterval);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_anchor_urb(urb, &data->intr_anchor);\r\nerr = usb_submit_urb(urb, mem_flags);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic void btmtk_usb_bulk_in_complete(struct urb *urb)\r\n{\r\nstruct hci_dev *hdev = urb->context;\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s:%s urb %p status %d count %d", __func__, hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags)) {\r\nreturn;\r\n}\r\nif (urb->status == 0) {\r\nhdev->stat.byte_rx += urb->actual_length;\r\nif (hci_recv_fragment(hdev, HCI_ACLDATA_PKT,\r\nurb->transfer_buffer,\r\nurb->actual_length) < 0) {\r\nBT_ERR("%s corrupted ACL packet", hdev->name);\r\nhdev->stat.err_rx++;\r\n}\r\n}\r\nif (!test_bit(BTUSB_BULK_RUNNING, &data->flags))\r\nreturn;\r\nusb_anchor_urb(urb, &data->bulk_anchor);\r\nusb_mark_last_busy(data->udev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p failed to resubmit (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\n}\r\nstatic int btmtk_usb_submit_bulk_in_urb(struct hci_dev *hdev, gfp_t mem_flags)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size = HCI_MAX_FRAME_SIZE;\r\nBT_DBG("%s:%s\n", __func__, hdev->name);\r\nif (!data->bulk_rx_ep)\r\nreturn -ENODEV;\r\nurb = usb_alloc_urb(0, mem_flags);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(size, mem_flags);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvbulkpipe(data->udev, data->bulk_rx_ep->bEndpointAddress);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nbuf, size, btmtk_usb_bulk_in_complete, hdev);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_mark_last_busy(data->udev);\r\nusb_anchor_urb(urb, &data->bulk_anchor);\r\nerr = usb_submit_urb(urb, mem_flags);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic void btmtk_usb_isoc_in_complete(struct urb *urb)\r\n{\r\nstruct hci_dev *hdev = urb->context;\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nint i, err;\r\nBT_DBG("%s: %s urb %p status %d count %d", __func__, hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn;\r\nif (urb->status == 0) {\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nunsigned int offset = urb->iso_frame_desc[i].offset;\r\nunsigned int length = urb->iso_frame_desc[i].actual_length;\r\nif (urb->iso_frame_desc[i].status)\r\ncontinue;\r\nhdev->stat.byte_rx += length;\r\nif (hci_recv_fragment(hdev, HCI_SCODATA_PKT,\r\nurb->transfer_buffer + offset,\r\nlength) < 0) {\r\nBT_ERR("%s corrupted SCO packet", hdev->name);\r\nhdev->stat.err_rx++;\r\n}\r\n}\r\n}\r\nif (!test_bit(BTUSB_ISOC_RUNNING, &data->flags))\r\nreturn;\r\nusb_anchor_urb(urb, &data->isoc_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p failed to resubmit (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\n}\r\nstatic inline void __fill_isoc_descriptor(struct urb *urb, int len, int mtu)\r\n{\r\nint i, offset = 0;\r\nBT_DBG("len %d mtu %d", len, mtu);\r\nfor (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;\r\ni++, offset += mtu, len -= mtu) {\r\nurb->iso_frame_desc[i].offset = offset;\r\nurb->iso_frame_desc[i].length = mtu;\r\n}\r\nif (len && i < BTUSB_MAX_ISOC_FRAMES) {\r\nurb->iso_frame_desc[i].offset = offset;\r\nurb->iso_frame_desc[i].length = len;\r\ni++;\r\n}\r\nurb->number_of_packets = i;\r\n}\r\nstatic int btmtk_usb_submit_isoc_in_urb(struct hci_dev *hdev, gfp_t mem_flags)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size;\r\nBT_DBG("%s\n", __func__);\r\nif (!data->isoc_rx_ep)\r\nreturn -ENODEV;\r\nurb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, mem_flags);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nsize = le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize) *\r\nBTUSB_MAX_ISOC_FRAMES;\r\nbuf = kmalloc(size, mem_flags);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvisocpipe(data->udev, data->isoc_rx_ep->bEndpointAddress);\r\nusb_fill_int_urb(urb, data->udev, pipe, buf, size, btmtk_usb_isoc_in_complete,\r\nhdev, data->isoc_rx_ep->bInterval);\r\nurb->transfer_flags = URB_FREE_BUFFER | URB_ISO_ASAP;\r\n__fill_isoc_descriptor(urb, size,\r\nle16_to_cpu(data->isoc_rx_ep->wMaxPacketSize));\r\nusb_anchor_urb(urb, &data->isoc_anchor);\r\nerr = usb_submit_urb(urb, mem_flags);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic int btmtk_usb_open(struct hci_dev *hdev)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s\n", __func__);\r\nerr = usb_autopm_get_interface(data->intf);\r\nif (err < 0)\r\nreturn err;\r\ndata->intf->needs_remote_wakeup = 1;\r\nif (test_and_set_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nif (test_and_set_bit(BTUSB_INTR_RUNNING, &data->flags))\r\ngoto done;\r\nerr = btmtk_usb_submit_intr_urb(hdev, GFP_KERNEL);\r\nif (err < 0)\r\ngoto failed;\r\nerr = btmtk_usb_submit_bulk_in_urb(hdev, GFP_KERNEL);\r\nif (err < 0) {\r\nusb_kill_anchored_urbs(&data->intr_anchor);\r\ngoto failed;\r\n}\r\nset_bit(BTUSB_BULK_RUNNING, &data->flags);\r\nbtmtk_usb_submit_bulk_in_urb(hdev, GFP_KERNEL);\r\ndone:\r\nusb_autopm_put_interface(data->intf);\r\nreturn 0;\r\nfailed:\r\nclear_bit(BTUSB_INTR_RUNNING, &data->flags);\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nusb_autopm_put_interface(data->intf);\r\nreturn err;\r\n}\r\nstatic void btmtk_usb_stop_traffic(struct btmtk_usb_data *data)\r\n{\r\nBT_DBG("%s\n", __func__);\r\nusb_kill_anchored_urbs(&data->intr_anchor);\r\nusb_kill_anchored_urbs(&data->bulk_anchor);\r\nusb_kill_anchored_urbs(&data->isoc_anchor);\r\n}\r\nstatic int btmtk_usb_close(struct hci_dev *hdev)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s\n", __func__);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\ncancel_work_sync(&data->work);\r\ncancel_work_sync(&data->waker);\r\nclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\r\nclear_bit(BTUSB_BULK_RUNNING, &data->flags);\r\nclear_bit(BTUSB_INTR_RUNNING, &data->flags);\r\nbtmtk_usb_stop_traffic(data);\r\nerr = usb_autopm_get_interface(data->intf);\r\nif (err < 0)\r\ngoto failed;\r\ndata->intf->needs_remote_wakeup = 0;\r\nusb_autopm_put_interface(data->intf);\r\nfailed:\r\nusb_scuttle_anchored_urbs(&data->deferred);\r\nreturn 0;\r\n}\r\nstatic int btmtk_usb_flush(struct hci_dev *hdev)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s\n", __func__);\r\nusb_kill_anchored_urbs(&data->tx_anchor);\r\nreturn 0;\r\n}\r\nstatic void btmtk_usb_tx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = urb->context;\r\nstruct hci_dev *hdev = (struct hci_dev *)skb->dev;\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s: %s urb %p status %d count %d\n", __func__, hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nif (!urb->status)\r\nhdev->stat.byte_tx += urb->transfer_buffer_length;\r\nelse\r\nhdev->stat.err_tx++;\r\ndone:\r\nspin_lock(&data->txlock);\r\ndata->tx_in_flight--;\r\nspin_unlock(&data->txlock);\r\nkfree(urb->setup_packet);\r\nkfree_skb(skb);\r\n}\r\nstatic void btmtk_usb_isoc_tx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = urb->context;\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nBT_DBG("%s: %s urb %p status %d count %d", __func__, hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nif (!urb->status)\r\nhdev->stat.byte_tx += urb->transfer_buffer_length;\r\nelse\r\nhdev->stat.err_tx++;\r\ndone:\r\nkfree(urb->setup_packet);\r\nkfree_skb(skb);\r\n}\r\nstatic int btmtk_usb_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = (struct hci_dev *)skb->dev;\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb;\r\nunsigned int pipe;\r\nint err;\r\nBT_DBG("%s\n", __func__);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndr = kmalloc(sizeof(*dr), GFP_ATOMIC);\r\nif (!dr) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ndr->bRequestType = data->cmdreq_type;\r\ndr->bRequest = 0;\r\ndr->wIndex = 0;\r\ndr->wValue = 0;\r\ndr->wLength = __cpu_to_le16(skb->len);\r\npipe = usb_sndctrlpipe(data->udev, 0x00);\r\nif (test_bit(HCI_RUNNING, &hdev->flags)) {\r\nu16 op_code;\r\nmemcpy(&op_code, skb->data, 2);\r\nBT_DBG("ogf = %x\n", (op_code & 0xfc00) >> 10);\r\nBT_DBG("ocf = %x\n", op_code & 0x03ff);\r\nhex_dump("hci command", skb->data, skb->len);\r\n}\r\nusb_fill_control_urb(urb, data->udev, pipe, (void *) dr,\r\nskb->data, skb->len, btmtk_usb_tx_complete, skb);\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nif (!data->bulk_tx_ep)\r\nreturn -ENODEV;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\npipe = usb_sndbulkpipe(data->udev,\r\ndata->bulk_tx_ep->bEndpointAddress);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nskb->data, skb->len, btmtk_usb_tx_complete, skb);\r\nhdev->stat.acl_tx++;\r\nBT_DBG("HCI_ACLDATA_PKT:\n");\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nif (!data->isoc_tx_ep || hdev->conn_hash.sco_num < 1)\r\nreturn -ENODEV;\r\nurb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\npipe = usb_sndisocpipe(data->udev,\r\ndata->isoc_tx_ep->bEndpointAddress);\r\nusb_fill_int_urb(urb, data->udev, pipe,\r\nskb->data, skb->len, btmtk_usb_isoc_tx_complete,\r\nskb, data->isoc_tx_ep->bInterval);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\n__fill_isoc_descriptor(urb, skb->len,\r\nle16_to_cpu(data->isoc_tx_ep->wMaxPacketSize));\r\nhdev->stat.sco_tx++;\r\nBT_DBG("HCI_SCODATA_PKT:\n");\r\ngoto skip_waking;\r\ndefault:\r\nreturn -EILSEQ;\r\n}\r\nerr = inc_tx(data);\r\nif (err) {\r\nusb_anchor_urb(urb, &data->deferred);\r\nschedule_work(&data->waker);\r\nerr = 0;\r\ngoto done;\r\n}\r\nskip_waking:\r\nusb_anchor_urb(urb, &data->tx_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nif (err != -EPERM && err != -ENODEV)\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nkfree(urb->setup_packet);\r\nusb_unanchor_urb(urb);\r\n} else {\r\nusb_mark_last_busy(data->udev);\r\n}\r\ndone:\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic void btmtk_usb_notify(struct hci_dev *hdev, unsigned int evt)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s evt %d", hdev->name, evt);\r\nif (hdev->conn_hash.sco_num != data->sco_num) {\r\ndata->sco_num = hdev->conn_hash.sco_num;\r\nschedule_work(&data->work);\r\n}\r\n}\r\nstatic inline int __set_isoc_interface(struct hci_dev *hdev, int altsetting)\r\n{\r\nstruct btmtk_usb_data *data = hci_get_drvdata(hdev);\r\nstruct usb_interface *intf = data->isoc;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nint i, err;\r\nif (!data->isoc)\r\nreturn -ENODEV;\r\nerr = usb_set_interface(data->udev, 1, altsetting);\r\nif (err < 0) {\r\nBT_ERR("%s setting interface failed (%d)", hdev->name, -err);\r\nreturn err;\r\n}\r\ndata->isoc_altsetting = altsetting;\r\ndata->isoc_tx_ep = NULL;\r\ndata->isoc_rx_ep = NULL;\r\nfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\r\nep_desc = &intf->cur_altsetting->endpoint[i].desc;\r\nif (!data->isoc_tx_ep && usb_endpoint_is_isoc_out(ep_desc)) {\r\ndata->isoc_tx_ep = ep_desc;\r\ncontinue;\r\n}\r\nif (!data->isoc_rx_ep && usb_endpoint_is_isoc_in(ep_desc)) {\r\ndata->isoc_rx_ep = ep_desc;\r\ncontinue;\r\n}\r\n}\r\nif (!data->isoc_tx_ep || !data->isoc_rx_ep) {\r\nBT_ERR("%s invalid SCO descriptors", hdev->name);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void btmtk_usb_work(struct work_struct *work)\r\n{\r\nstruct btmtk_usb_data *data = container_of(work, struct btmtk_usb_data, work);\r\nstruct hci_dev *hdev = data->hdev;\r\nint new_alts;\r\nint err;\r\nBT_DBG("%s\n", __func__);\r\nif (hdev->conn_hash.sco_num > 0) {\r\nif (!test_bit(BTUSB_DID_ISO_RESUME, &data->flags)) {\r\nerr = usb_autopm_get_interface(data->isoc ? data->isoc : data->intf);\r\nif (err < 0) {\r\nclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\r\nusb_kill_anchored_urbs(&data->isoc_anchor);\r\nreturn;\r\n}\r\nset_bit(BTUSB_DID_ISO_RESUME, &data->flags);\r\n}\r\nif (hdev->voice_setting & 0x0020) {\r\nstatic const int alts[3] = { 2, 4, 5 };\r\nnew_alts = alts[hdev->conn_hash.sco_num - 1];\r\n} else {\r\nnew_alts = hdev->conn_hash.sco_num;\r\n}\r\nif (data->isoc_altsetting != new_alts) {\r\nclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\r\nusb_kill_anchored_urbs(&data->isoc_anchor);\r\nif (__set_isoc_interface(hdev, new_alts) < 0)\r\nreturn;\r\n}\r\nif (!test_and_set_bit(BTUSB_ISOC_RUNNING, &data->flags)) {\r\nif (btmtk_usb_submit_isoc_in_urb(hdev, GFP_KERNEL) < 0)\r\nclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\r\nelse\r\nbtmtk_usb_submit_isoc_in_urb(hdev, GFP_KERNEL);\r\n}\r\n} else {\r\nclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\r\nusb_kill_anchored_urbs(&data->isoc_anchor);\r\n__set_isoc_interface(hdev, 0);\r\nif (test_and_clear_bit(BTUSB_DID_ISO_RESUME, &data->flags))\r\nusb_autopm_put_interface(data->isoc ? data->isoc : data->intf);\r\n}\r\n}\r\nstatic void btmtk_usb_waker(struct work_struct *work)\r\n{\r\nstruct btmtk_usb_data *data = container_of(work, struct btmtk_usb_data, waker);\r\nint err;\r\nerr = usb_autopm_get_interface(data->intf);\r\nif (err < 0)\r\nreturn;\r\nusb_autopm_put_interface(data->intf);\r\n}\r\nstatic int btmtk_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct btmtk_usb_data *data;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nint i, err;\r\nstruct hci_dev *hdev;\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\r\nep_desc = &intf->cur_altsetting->endpoint[i].desc;\r\nif (!data->intr_ep && usb_endpoint_is_int_in(ep_desc)) {\r\ndata->intr_ep = ep_desc;\r\ncontinue;\r\n}\r\nif (!data->bulk_tx_ep && usb_endpoint_is_bulk_out(ep_desc)) {\r\ndata->bulk_tx_ep = ep_desc;\r\ncontinue;\r\n}\r\nif (!data->bulk_rx_ep && usb_endpoint_is_bulk_in(ep_desc)) {\r\ndata->bulk_rx_ep = ep_desc;\r\ncontinue;\r\n}\r\n}\r\nif (!data->intr_ep || !data->bulk_tx_ep || !data->bulk_rx_ep) {\r\nkfree(data);\r\nreturn -ENODEV;\r\n}\r\ndata->cmdreq_type = USB_TYPE_CLASS;\r\ndata->udev = interface_to_usbdev(intf);\r\ndata->intf = intf;\r\nspin_lock_init(&data->lock);\r\nINIT_WORK(&data->work, btmtk_usb_work);\r\nINIT_WORK(&data->waker, btmtk_usb_waker);\r\nspin_lock_init(&data->txlock);\r\ninit_usb_anchor(&data->tx_anchor);\r\ninit_usb_anchor(&data->intr_anchor);\r\ninit_usb_anchor(&data->bulk_anchor);\r\ninit_usb_anchor(&data->isoc_anchor);\r\ninit_usb_anchor(&data->deferred);\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\nhdev->bus = HCI_USB;\r\nhci_set_drvdata(hdev, data);\r\ndata->hdev = hdev;\r\nSET_HCIDEV_DEV(hdev, &intf->dev);\r\nhdev->open = btmtk_usb_open;\r\nhdev->close = btmtk_usb_close;\r\nhdev->flush = btmtk_usb_flush;\r\nhdev->send = btmtk_usb_send_frame;\r\nhdev->notify = btmtk_usb_notify;\r\ndata->isoc = usb_ifnum_to_if(data->udev, 1);\r\nif (data->isoc) {\r\nerr = usb_driver_claim_interface(&btmtk_usb_driver,\r\ndata->isoc, data);\r\nif (err < 0) {\r\nhci_free_dev(hdev);\r\nkfree(data);\r\nreturn err;\r\n}\r\n}\r\ndata->io_buf = kmalloc(256, GFP_KERNEL);\r\nif (!data->io_buf) {\r\nhci_free_dev(hdev);\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\nbtmtk_usb_switch_iobase(data, WLAN);\r\nbtmtk_usb_cap_init(data);\r\nerr = hci_register_dev(hdev);\r\nif (err < 0) {\r\nhci_free_dev(hdev);\r\nkfree(data);\r\nreturn err;\r\n}\r\nusb_set_intfdata(intf, data);\r\nreturn 0;\r\n}\r\nstatic void btmtk_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct btmtk_usb_data *data = usb_get_intfdata(intf);\r\nstruct hci_dev *hdev;\r\nBT_DBG("%s\n", __func__);\r\nif (!data)\r\nreturn;\r\nhdev = data->hdev;\r\nusb_set_intfdata(data->intf, NULL);\r\nif (data->isoc)\r\nusb_set_intfdata(data->isoc, NULL);\r\nhci_unregister_dev(hdev);\r\nif (intf == data->isoc)\r\nusb_driver_release_interface(&btmtk_usb_driver, data->intf);\r\nelse if (data->isoc)\r\nusb_driver_release_interface(&btmtk_usb_driver, data->isoc);\r\nhci_free_dev(hdev);\r\nkfree(data->io_buf);\r\nkfree(data);\r\n}\r\nstatic int btmtk_usb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct btmtk_usb_data *data = usb_get_intfdata(intf);\r\nBT_DBG("%s\n", __func__);\r\nif (data->suspend_count++)\r\nreturn 0;\r\nspin_lock_irq(&data->txlock);\r\nif (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {\r\nset_bit(BTUSB_SUSPENDING, &data->flags);\r\nspin_unlock_irq(&data->txlock);\r\n} else {\r\nspin_unlock_irq(&data->txlock);\r\ndata->suspend_count--;\r\nreturn -EBUSY;\r\n}\r\ncancel_work_sync(&data->work);\r\nbtmtk_usb_stop_traffic(data);\r\nusb_kill_anchored_urbs(&data->tx_anchor);\r\nreturn 0;\r\n}\r\nstatic void play_deferred(struct btmtk_usb_data *data)\r\n{\r\nstruct urb *urb;\r\nint err;\r\nwhile ((urb = usb_get_from_anchor(&data->deferred))) {\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0)\r\nbreak;\r\ndata->tx_in_flight++;\r\n}\r\nusb_scuttle_anchored_urbs(&data->deferred);\r\n}\r\nstatic int btmtk_usb_resume(struct usb_interface *intf)\r\n{\r\nstruct btmtk_usb_data *data = usb_get_intfdata(intf);\r\nstruct hci_dev *hdev = data->hdev;\r\nint err = 0;\r\nBT_DBG("%s\n", __func__);\r\nif (--data->suspend_count)\r\nreturn 0;\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nif (test_bit(BTUSB_INTR_RUNNING, &data->flags)) {\r\nerr = btmtk_usb_submit_intr_urb(hdev, GFP_NOIO);\r\nif (err < 0) {\r\nclear_bit(BTUSB_INTR_RUNNING, &data->flags);\r\ngoto failed;\r\n}\r\n}\r\nif (test_bit(BTUSB_BULK_RUNNING, &data->flags)) {\r\nerr = btmtk_usb_submit_bulk_in_urb(hdev, GFP_NOIO);\r\nif (err < 0) {\r\nclear_bit(BTUSB_BULK_RUNNING, &data->flags);\r\ngoto failed;\r\n}\r\nbtmtk_usb_submit_bulk_in_urb(hdev, GFP_NOIO);\r\n}\r\nif (test_bit(BTUSB_ISOC_RUNNING, &data->flags)) {\r\nif (btmtk_usb_submit_isoc_in_urb(hdev, GFP_NOIO) < 0)\r\nclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\r\nelse\r\nbtmtk_usb_submit_isoc_in_urb(hdev, GFP_NOIO);\r\n}\r\nspin_lock_irq(&data->txlock);\r\nplay_deferred(data);\r\nclear_bit(BTUSB_SUSPENDING, &data->flags);\r\nspin_unlock_irq(&data->txlock);\r\nschedule_work(&data->work);\r\nreturn 0;\r\nfailed:\r\nusb_scuttle_anchored_urbs(&data->deferred);\r\ndone:\r\nspin_lock_irq(&data->txlock);\r\nclear_bit(BTUSB_SUSPENDING, &data->flags);\r\nspin_unlock_irq(&data->txlock);\r\nreturn err;\r\n}
