static inline u32 pci_cfg_read_32bit(struct pci_bus *bus, unsigned int devfn,\r\nint where)\r\n{\r\nu32 data;\r\nu32 *cfgaddr;\r\ncfgaddr = (u32 *)(pci_config_base +\r\npci_cfg_addr(bus->number, devfn, where & ~3));\r\ndata = *cfgaddr;\r\nreturn cpu_to_le32(data);\r\n}\r\nstatic inline void pci_cfg_write_32bit(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 data)\r\n{\r\nu32 *cfgaddr;\r\ncfgaddr = (u32 *)(pci_config_base +\r\npci_cfg_addr(bus->number, devfn, where & ~3));\r\n*cfgaddr = cpu_to_le32(data);\r\n}\r\nstatic int nlm_pcibios_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nu32 data;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = pci_cfg_read_32bit(bus, devfn, where);\r\nif (size == 1)\r\n*val = (data >> ((where & 3) << 3)) & 0xff;\r\nelse if (size == 2)\r\n*val = (data >> ((where & 3) << 3)) & 0xffff;\r\nelse\r\n*val = data;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int nlm_pcibios_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nu32 data;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = pci_cfg_read_32bit(bus, devfn, where);\r\nif (size == 1)\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse if (size == 2)\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse\r\ndata = val;\r\npci_cfg_write_32bit(bus, devfn, where, data);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic struct pci_dev *xls_get_pcie_link(const struct pci_dev *dev)\r\n{\r\nstruct pci_bus *bus, *p;\r\nbus = dev->bus;\r\nfor (p = bus->parent; p && p->number != 0; p = p->parent)\r\nbus = p;\r\nreturn p ? bus->self : NULL;\r\n}\r\nstatic int nlm_pci_link_to_irq(int link)\r\n{\r\nswitch (link) {\r\ncase 0:\r\nreturn PIC_PCIE_LINK0_IRQ;\r\ncase 1:\r\nreturn PIC_PCIE_LINK1_IRQ;\r\ncase 2:\r\nif (nlm_chip_is_xls_b())\r\nreturn PIC_PCIE_XLSB0_LINK2_IRQ;\r\nelse\r\nreturn PIC_PCIE_LINK2_IRQ;\r\ncase 3:\r\nif (nlm_chip_is_xls_b())\r\nreturn PIC_PCIE_XLSB0_LINK3_IRQ;\r\nelse\r\nreturn PIC_PCIE_LINK3_IRQ;\r\n}\r\nWARN(1, "Unexpected link %d\n", link);\r\nreturn 0;\r\n}\r\nstatic int get_irq_vector(const struct pci_dev *dev)\r\n{\r\nstruct pci_dev *lnk;\r\nint link;\r\nif (!nlm_chip_is_xls())\r\nreturn PIC_PCIX_IRQ;\r\nlnk = xls_get_pcie_link(dev);\r\nif (lnk == NULL)\r\nreturn 0;\r\nlink = PCI_SLOT(lnk->devfn);\r\nreturn nlm_pci_link_to_irq(link);\r\n}\r\nvoid destroy_irq(unsigned int irq)\r\n{\r\n}\r\nvoid arch_teardown_msi_irq(unsigned int irq)\r\n{\r\ndestroy_irq(irq);\r\n}\r\nint arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)\r\n{\r\nstruct msi_msg msg;\r\nstruct pci_dev *lnk;\r\nint irq, ret;\r\nu16 val;\r\nif (!nlm_chip_is_xls())\r\nreturn 1;\r\nlnk = xls_get_pcie_link(dev);\r\nif (lnk == NULL)\r\nreturn 1;\r\npci_read_config_word(lnk, 0x50 + PCI_MSI_FLAGS, &val);\r\nif ((val & PCI_MSI_FLAGS_ENABLE) == 0) {\r\nval |= PCI_MSI_FLAGS_ENABLE;\r\npci_write_config_word(lnk, 0x50 + PCI_MSI_FLAGS, val);\r\n}\r\nirq = get_irq_vector(dev);\r\nif (irq <= 0)\r\nreturn 1;\r\nmsg.address_hi = MSI_ADDR_BASE_HI;\r\nmsg.address_lo = MSI_ADDR_BASE_LO |\r\nMSI_ADDR_DEST_MODE_PHYSICAL |\r\nMSI_ADDR_REDIRECTION_CPU;\r\nmsg.data = MSI_DATA_TRIGGER_EDGE |\r\nMSI_DATA_LEVEL_ASSERT |\r\nMSI_DATA_DELIVERY_FIXED;\r\nret = irq_set_msi_desc(irq, desc);\r\nif (ret < 0) {\r\ndestroy_irq(irq);\r\nreturn ret;\r\n}\r\nwrite_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nstatic void xlr_pci_ack(struct irq_data *d)\r\n{\r\nuint64_t pcibase = nlm_mmio_base(NETLOGIC_IO_PCIX_OFFSET);\r\nnlm_read_reg(pcibase, (0x140 >> 2));\r\n}\r\nstatic void xls_pcie_ack(struct irq_data *d)\r\n{\r\nuint64_t pciebase_le = nlm_mmio_base(NETLOGIC_IO_PCIE_1_OFFSET);\r\nswitch (d->irq) {\r\ncase PIC_PCIE_LINK0_IRQ:\r\nnlm_write_reg(pciebase_le, (0x90 >> 2), 0xffffffff);\r\nbreak;\r\ncase PIC_PCIE_LINK1_IRQ:\r\nnlm_write_reg(pciebase_le, (0x94 >> 2), 0xffffffff);\r\nbreak;\r\ncase PIC_PCIE_LINK2_IRQ:\r\nnlm_write_reg(pciebase_le, (0x190 >> 2), 0xffffffff);\r\nbreak;\r\ncase PIC_PCIE_LINK3_IRQ:\r\nnlm_write_reg(pciebase_le, (0x194 >> 2), 0xffffffff);\r\nbreak;\r\n}\r\n}\r\nstatic void xls_pcie_ack_b(struct irq_data *d)\r\n{\r\nuint64_t pciebase_le = nlm_mmio_base(NETLOGIC_IO_PCIE_1_OFFSET);\r\nswitch (d->irq) {\r\ncase PIC_PCIE_LINK0_IRQ:\r\nnlm_write_reg(pciebase_le, (0x90 >> 2), 0xffffffff);\r\nbreak;\r\ncase PIC_PCIE_LINK1_IRQ:\r\nnlm_write_reg(pciebase_le, (0x94 >> 2), 0xffffffff);\r\nbreak;\r\ncase PIC_PCIE_XLSB0_LINK2_IRQ:\r\nnlm_write_reg(pciebase_le, (0x190 >> 2), 0xffffffff);\r\nbreak;\r\ncase PIC_PCIE_XLSB0_LINK3_IRQ:\r\nnlm_write_reg(pciebase_le, (0x194 >> 2), 0xffffffff);\r\nbreak;\r\n}\r\n}\r\nint __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nreturn get_irq_vector(dev);\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init pcibios_init(void)\r\n{\r\nvoid (*extra_ack)(struct irq_data *);\r\nint link, irq;\r\npci_set_flags(PCI_PROBE_ONLY);\r\npci_config_base = ioremap(DEFAULT_PCI_CONFIG_BASE, 16 << 20);\r\nioport_resource.start = 0;\r\nioport_resource.end = ~0;\r\nset_io_port_base(CKSEG1);\r\nnlm_pci_controller.io_map_base = CKSEG1;\r\npr_info("Registering XLR/XLS PCIX/PCIE Controller.\n");\r\nregister_pci_controller(&nlm_pci_controller);\r\nif (!nlm_chip_is_xls()) {\r\nnlm_set_pic_extra_ack(0, PIC_PCIX_IRQ, xlr_pci_ack);\r\n} else {\r\nif (nlm_chip_is_xls_b())\r\nextra_ack = xls_pcie_ack_b;\r\nelse\r\nextra_ack = xls_pcie_ack;\r\nfor (link = 0; link < 4; link++) {\r\nirq = nlm_pci_link_to_irq(link);\r\nnlm_set_pic_extra_ack(0, irq, extra_ack);\r\n}\r\n}\r\nreturn 0;\r\n}
