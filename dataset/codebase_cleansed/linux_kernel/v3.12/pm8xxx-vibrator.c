static int pm8xxx_vib_read_u8(struct pm8xxx_vib *vib,\r\nu8 *data, u16 reg)\r\n{\r\nint rc;\r\nrc = pm8xxx_readb(vib->dev->parent, reg, data);\r\nif (rc < 0)\r\ndev_warn(vib->dev, "Error reading pm8xxx reg 0x%x(0x%x)\n",\r\nreg, rc);\r\nreturn rc;\r\n}\r\nstatic int pm8xxx_vib_write_u8(struct pm8xxx_vib *vib,\r\nu8 data, u16 reg)\r\n{\r\nint rc;\r\nrc = pm8xxx_writeb(vib->dev->parent, reg, data);\r\nif (rc < 0)\r\ndev_warn(vib->dev, "Error writing pm8xxx reg 0x%x(0x%x)\n",\r\nreg, rc);\r\nreturn rc;\r\n}\r\nstatic int pm8xxx_vib_set(struct pm8xxx_vib *vib, bool on)\r\n{\r\nint rc;\r\nu8 val = vib->reg_vib_drv;\r\nif (on)\r\nval |= ((vib->level << VIB_DRV_SEL_SHIFT) & VIB_DRV_SEL_MASK);\r\nelse\r\nval &= ~VIB_DRV_SEL_MASK;\r\nrc = pm8xxx_vib_write_u8(vib, val, VIB_DRV);\r\nif (rc < 0)\r\nreturn rc;\r\nvib->reg_vib_drv = val;\r\nreturn 0;\r\n}\r\nstatic void pm8xxx_work_handler(struct work_struct *work)\r\n{\r\nstruct pm8xxx_vib *vib = container_of(work, struct pm8xxx_vib, work);\r\nint rc;\r\nu8 val;\r\nrc = pm8xxx_vib_read_u8(vib, &val, VIB_DRV);\r\nif (rc < 0)\r\nreturn;\r\nif (vib->speed) {\r\nvib->active = true;\r\nvib->level = ((VIB_MAX_LEVELS * vib->speed) / MAX_FF_SPEED) +\r\nVIB_MIN_LEVEL_mV;\r\nvib->level /= 100;\r\n} else {\r\nvib->active = false;\r\nvib->level = VIB_MIN_LEVEL_mV / 100;\r\n}\r\npm8xxx_vib_set(vib, vib->active);\r\n}\r\nstatic void pm8xxx_vib_close(struct input_dev *dev)\r\n{\r\nstruct pm8xxx_vib *vib = input_get_drvdata(dev);\r\ncancel_work_sync(&vib->work);\r\nif (vib->active)\r\npm8xxx_vib_set(vib, false);\r\n}\r\nstatic int pm8xxx_vib_play_effect(struct input_dev *dev, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct pm8xxx_vib *vib = input_get_drvdata(dev);\r\nvib->speed = effect->u.rumble.strong_magnitude >> 8;\r\nif (!vib->speed)\r\nvib->speed = effect->u.rumble.weak_magnitude >> 9;\r\nschedule_work(&vib->work);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_vib_probe(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_vib *vib;\r\nstruct input_dev *input_dev;\r\nint error;\r\nu8 val;\r\nvib = kzalloc(sizeof(*vib), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!vib || !input_dev) {\r\ndev_err(&pdev->dev, "couldn't allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nINIT_WORK(&vib->work, pm8xxx_work_handler);\r\nvib->dev = &pdev->dev;\r\nvib->vib_input_dev = input_dev;\r\nerror = pm8xxx_vib_read_u8(vib, &val, VIB_DRV);\r\nif (error < 0)\r\ngoto err_free_mem;\r\nval &= ~VIB_DRV_EN_MANUAL_MASK;\r\nerror = pm8xxx_vib_write_u8(vib, val, VIB_DRV);\r\nif (error < 0)\r\ngoto err_free_mem;\r\nvib->reg_vib_drv = val;\r\ninput_dev->name = "pm8xxx_vib_ffmemless";\r\ninput_dev->id.version = 1;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->close = pm8xxx_vib_close;\r\ninput_set_drvdata(input_dev, vib);\r\ninput_set_capability(vib->vib_input_dev, EV_FF, FF_RUMBLE);\r\nerror = input_ff_create_memless(input_dev, NULL,\r\npm8xxx_vib_play_effect);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"couldn't register vibrator as FF device\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "couldn't register input device\n");\r\ngoto err_destroy_memless;\r\n}\r\nplatform_set_drvdata(pdev, vib);\r\nreturn 0;\r\nerr_destroy_memless:\r\ninput_ff_destroy(input_dev);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(vib);\r\nreturn error;\r\n}\r\nstatic int pm8xxx_vib_remove(struct platform_device *pdev)\r\n{\r\nstruct pm8xxx_vib *vib = platform_get_drvdata(pdev);\r\ninput_unregister_device(vib->vib_input_dev);\r\nkfree(vib);\r\nreturn 0;\r\n}\r\nstatic int pm8xxx_vib_suspend(struct device *dev)\r\n{\r\nstruct pm8xxx_vib *vib = dev_get_drvdata(dev);\r\npm8xxx_vib_set(vib, false);\r\nreturn 0;\r\n}
