static int orion_mdio_smi_is_done(struct orion_mdio_dev *dev)\r\n{\r\nreturn !(readl(dev->regs) & MVMDIO_SMI_BUSY);\r\n}\r\nstatic int orion_mdio_wait_ready(struct mii_bus *bus)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nint count;\r\nif (dev->err_interrupt <= 0) {\r\ncount = 0;\r\nwhile (1) {\r\nif (orion_mdio_smi_is_done(dev))\r\nbreak;\r\nif (count > 100) {\r\ndev_err(bus->parent,\r\n"Timeout: SMI busy for too long\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(10);\r\ncount++;\r\n}\r\n} else {\r\nif (!orion_mdio_smi_is_done(dev)) {\r\nwait_event_timeout(dev->smi_busy_wait,\r\norion_mdio_smi_is_done(dev),\r\nmsecs_to_jiffies(100));\r\nif (!orion_mdio_smi_is_done(dev))\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int orion_mdio_read(struct mii_bus *bus, int mii_id,\r\nint regnum)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nint count;\r\nu32 val;\r\nint ret;\r\nmutex_lock(&dev->lock);\r\nret = orion_mdio_wait_ready(bus);\r\nif (ret < 0) {\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nwritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\r\n(regnum << MVMDIO_SMI_PHY_REG_SHIFT) |\r\nMVMDIO_SMI_READ_OPERATION),\r\ndev->regs);\r\ncount = 0;\r\nwhile (1) {\r\nval = readl(dev->regs);\r\nif (val & MVMDIO_SMI_READ_VALID)\r\nbreak;\r\nif (count > 100) {\r\ndev_err(bus->parent, "Timeout when reading PHY\n");\r\nmutex_unlock(&dev->lock);\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(10);\r\ncount++;\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn val & 0xFFFF;\r\n}\r\nstatic int orion_mdio_write(struct mii_bus *bus, int mii_id,\r\nint regnum, u16 value)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nint ret;\r\nmutex_lock(&dev->lock);\r\nret = orion_mdio_wait_ready(bus);\r\nif (ret < 0) {\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nwritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\r\n(regnum << MVMDIO_SMI_PHY_REG_SHIFT) |\r\nMVMDIO_SMI_WRITE_OPERATION |\r\n(value << MVMDIO_SMI_DATA_SHIFT)),\r\ndev->regs);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int orion_mdio_reset(struct mii_bus *bus)\r\n{\r\nreturn 0;\r\n}\r\nstatic irqreturn_t orion_mdio_err_irq(int irq, void *dev_id)\r\n{\r\nstruct orion_mdio_dev *dev = dev_id;\r\nif (readl(dev->regs + MVMDIO_ERR_INT_CAUSE) &\r\nMVMDIO_ERR_INT_SMI_DONE) {\r\nwritel(~MVMDIO_ERR_INT_SMI_DONE,\r\ndev->regs + MVMDIO_ERR_INT_CAUSE);\r\nwake_up(&dev->smi_busy_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int orion_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nstruct mii_bus *bus;\r\nstruct orion_mdio_dev *dev;\r\nint i, ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "No SMI register address given\n");\r\nreturn -ENODEV;\r\n}\r\nbus = mdiobus_alloc_size(sizeof(struct orion_mdio_dev));\r\nif (!bus) {\r\ndev_err(&pdev->dev, "Cannot allocate MDIO bus\n");\r\nreturn -ENOMEM;\r\n}\r\nbus->name = "orion_mdio_bus";\r\nbus->read = orion_mdio_read;\r\nbus->write = orion_mdio_write;\r\nbus->reset = orion_mdio_reset;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",\r\ndev_name(&pdev->dev));\r\nbus->parent = &pdev->dev;\r\nbus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!bus->irq) {\r\nmdiobus_free(bus);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nbus->irq[i] = PHY_POLL;\r\ndev = bus->priv;\r\ndev->regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!dev->regs) {\r\ndev_err(&pdev->dev, "Unable to remap SMI register\n");\r\nret = -ENODEV;\r\ngoto out_mdio;\r\n}\r\ninit_waitqueue_head(&dev->smi_busy_wait);\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(dev->clk))\r\nclk_prepare_enable(dev->clk);\r\ndev->err_interrupt = platform_get_irq(pdev, 0);\r\nif (dev->err_interrupt != -ENXIO) {\r\nret = devm_request_irq(&pdev->dev, dev->err_interrupt,\r\norion_mdio_err_irq,\r\nIRQF_SHARED, pdev->name, dev);\r\nif (ret)\r\ngoto out_mdio;\r\nwritel(MVMDIO_ERR_INT_SMI_DONE,\r\ndev->regs + MVMDIO_ERR_INT_MASK);\r\n}\r\nmutex_init(&dev->lock);\r\nif (pdev->dev.of_node)\r\nret = of_mdiobus_register(bus, pdev->dev.of_node);\r\nelse\r\nret = mdiobus_register(bus);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Cannot register MDIO bus (%d)\n", ret);\r\ngoto out_mdio;\r\n}\r\nplatform_set_drvdata(pdev, bus);\r\nreturn 0;\r\nout_mdio:\r\nif (!IS_ERR(dev->clk))\r\nclk_disable_unprepare(dev->clk);\r\nkfree(bus->irq);\r\nmdiobus_free(bus);\r\nreturn ret;\r\n}\r\nstatic int orion_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus = platform_get_drvdata(pdev);\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nwritel(0, dev->regs + MVMDIO_ERR_INT_MASK);\r\nmdiobus_unregister(bus);\r\nkfree(bus->irq);\r\nmdiobus_free(bus);\r\nif (!IS_ERR(dev->clk))\r\nclk_disable_unprepare(dev->clk);\r\nreturn 0;\r\n}
