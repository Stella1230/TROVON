static void cam_write(struct omap1_cam_dev *pcdev, u16 reg, u32 val)\r\n{\r\npcdev->reg_cache[reg / sizeof(u32)] = val;\r\n__raw_writel(val, pcdev->base + reg);\r\n}\r\nstatic u32 cam_read(struct omap1_cam_dev *pcdev, u16 reg, bool from_cache)\r\n{\r\nreturn !from_cache ? __raw_readl(pcdev->base + reg) :\r\npcdev->reg_cache[reg / sizeof(u32)];\r\n}\r\nstatic int omap1_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\n*size = icd->sizeimage;\r\nif (!*count || *count < OMAP1_CAMERA_MIN_BUF_COUNT(pcdev->vb_mode))\r\n*count = OMAP1_CAMERA_MIN_BUF_COUNT(pcdev->vb_mode);\r\nif (*size * *count > MAX_VIDEO_MEM * 1024 * 1024)\r\n*count = (MAX_VIDEO_MEM * 1024 * 1024) / *size;\r\ndev_dbg(icd->parent,\r\n"%s: count=%d, size=%d\n", __func__, *count, *size);\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct omap1_cam_buf *buf,\r\nenum omap1_cam_vb_mode vb_mode)\r\n{\r\nstruct videobuf_buffer *vb = &buf->vb;\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(vq, vb, 0, 0);\r\nif (vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\nvideobuf_dma_contig_free(vq, vb);\r\n} else {\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct device *dev = icd->parent;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nvideobuf_dma_unmap(dev, dma);\r\nvideobuf_dma_free(dma);\r\n}\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int omap1_videobuf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct omap1_cam_buf *buf = container_of(vb, struct omap1_cam_buf, vb);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nint ret;\r\nWARN_ON(!list_empty(&vb->queue));\r\nBUG_ON(NULL == icd->current_fmt);\r\nbuf->inwork = 1;\r\nif (buf->code != icd->current_fmt->code || vb->field != field ||\r\nvb->width != icd->user_width ||\r\nvb->height != icd->user_height) {\r\nbuf->code = icd->current_fmt->code;\r\nvb->width = icd->user_width;\r\nvb->height = icd->user_height;\r\nvb->field = field;\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nvb->size = icd->sizeimage;\r\nif (vb->baddr && vb->bsize < vb->size) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret)\r\ngoto fail;\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\nbuf->inwork = 0;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf, pcdev->vb_mode);\r\nout:\r\nbuf->inwork = 0;\r\nreturn ret;\r\n}\r\nstatic void set_dma_dest_params(int dma_ch, struct omap1_cam_buf *buf,\r\nenum omap1_cam_vb_mode vb_mode)\r\n{\r\ndma_addr_t dma_addr;\r\nunsigned int block_size;\r\nif (vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\ndma_addr = videobuf_to_dma_contig(&buf->vb);\r\nblock_size = buf->vb.size;\r\n} else {\r\nif (WARN_ON(!buf->sgbuf)) {\r\nbuf->result = VIDEOBUF_ERROR;\r\nreturn;\r\n}\r\ndma_addr = sg_dma_address(buf->sgbuf);\r\nif (WARN_ON(!dma_addr)) {\r\nbuf->sgbuf = NULL;\r\nbuf->result = VIDEOBUF_ERROR;\r\nreturn;\r\n}\r\nblock_size = sg_dma_len(buf->sgbuf);\r\nif (WARN_ON(!block_size)) {\r\nbuf->sgbuf = NULL;\r\nbuf->result = VIDEOBUF_ERROR;\r\nreturn;\r\n}\r\nif (unlikely(buf->bytes_left < block_size))\r\nblock_size = buf->bytes_left;\r\nif (WARN_ON(dma_addr & (DMA_FRAME_SIZE(vb_mode) *\r\nDMA_ELEMENT_SIZE - 1))) {\r\ndma_addr = ALIGN(dma_addr, DMA_FRAME_SIZE(vb_mode) *\r\nDMA_ELEMENT_SIZE);\r\nblock_size &= ~(DMA_FRAME_SIZE(vb_mode) *\r\nDMA_ELEMENT_SIZE - 1);\r\n}\r\nbuf->bytes_left -= block_size;\r\nbuf->sgcount++;\r\n}\r\nomap_set_dma_dest_params(dma_ch,\r\nOMAP_DMA_PORT_EMIFF, OMAP_DMA_AMODE_POST_INC, dma_addr, 0, 0);\r\nomap_set_dma_transfer_params(dma_ch,\r\nOMAP_DMA_DATA_TYPE_S32, DMA_FRAME_SIZE(vb_mode),\r\nblock_size >> (DMA_FRAME_SHIFT(vb_mode) + DMA_ELEMENT_SHIFT),\r\nDMA_SYNC, 0, 0);\r\n}\r\nstatic struct omap1_cam_buf *prepare_next_vb(struct omap1_cam_dev *pcdev)\r\n{\r\nstruct omap1_cam_buf *buf;\r\nbuf = pcdev->ready;\r\nif (!buf) {\r\nif (list_empty(&pcdev->capture))\r\nreturn buf;\r\nbuf = list_entry(pcdev->capture.next,\r\nstruct omap1_cam_buf, vb.queue);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\npcdev->ready = buf;\r\nlist_del_init(&buf->vb.queue);\r\n}\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\nset_dma_dest_params(pcdev->dma_ch, buf, pcdev->vb_mode);\r\n} else {\r\nbuf->sgbuf = NULL;\r\n}\r\nreturn buf;\r\n}\r\nstatic struct scatterlist *try_next_sgbuf(int dma_ch, struct omap1_cam_buf *buf)\r\n{\r\nstruct scatterlist *sgbuf;\r\nif (likely(buf->sgbuf)) {\r\nif (unlikely(!buf->bytes_left)) {\r\nsgbuf = NULL;\r\n} else {\r\nsgbuf = sg_next(buf->sgbuf);\r\nif (WARN_ON(!sgbuf)) {\r\nbuf->result = VIDEOBUF_ERROR;\r\n} else if (WARN_ON(!sg_dma_len(sgbuf))) {\r\nsgbuf = NULL;\r\nbuf->result = VIDEOBUF_ERROR;\r\n}\r\n}\r\nbuf->sgbuf = sgbuf;\r\n} else {\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nsgbuf = dma->sglist;\r\nif (!(WARN_ON(!sgbuf))) {\r\nbuf->sgbuf = sgbuf;\r\nbuf->sgcount = 0;\r\nbuf->bytes_left = buf->vb.size;\r\nbuf->result = VIDEOBUF_DONE;\r\n}\r\n}\r\nif (sgbuf)\r\nset_dma_dest_params(dma_ch, buf, OMAP1_CAM_DMA_SG);\r\nreturn sgbuf;\r\n}\r\nstatic void start_capture(struct omap1_cam_dev *pcdev)\r\n{\r\nstruct omap1_cam_buf *buf = pcdev->active;\r\nu32 ctrlclock = CAM_READ_CACHE(pcdev, CTRLCLOCK);\r\nu32 mode = CAM_READ_CACHE(pcdev, MODE) & ~EN_V_DOWN;\r\nif (WARN_ON(!buf))\r\nreturn;\r\nmode |= EN_V_UP;\r\nif (unlikely(ctrlclock & LCLK_EN))\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock & ~LCLK_EN);\r\nCAM_WRITE(pcdev, MODE, mode | RAZ_FIFO);\r\nomap_start_dma(pcdev->dma_ch);\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_SG) {\r\ntry_next_sgbuf(pcdev->dma_ch, buf);\r\n}\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock | LCLK_EN);\r\nCAM_WRITE(pcdev, MODE, mode);\r\n}\r\nstatic void suspend_capture(struct omap1_cam_dev *pcdev)\r\n{\r\nu32 ctrlclock = CAM_READ_CACHE(pcdev, CTRLCLOCK);\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock & ~LCLK_EN);\r\nomap_stop_dma(pcdev->dma_ch);\r\n}\r\nstatic void disable_capture(struct omap1_cam_dev *pcdev)\r\n{\r\nu32 mode = CAM_READ_CACHE(pcdev, MODE);\r\nCAM_WRITE(pcdev, MODE, mode & ~(IRQ_MASK | DMA));\r\n}\r\nstatic void omap1_videobuf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nstruct omap1_cam_buf *buf;\r\nu32 mode;\r\nlist_add_tail(&vb->queue, &pcdev->capture);\r\nvb->state = VIDEOBUF_QUEUED;\r\nif (pcdev->active) {\r\nreturn;\r\n}\r\nWARN_ON(pcdev->ready);\r\nbuf = prepare_next_vb(pcdev);\r\nif (WARN_ON(!buf))\r\nreturn;\r\npcdev->active = buf;\r\npcdev->ready = NULL;\r\ndev_dbg(icd->parent,\r\n"%s: capture not active, setup FIFO, start DMA\n", __func__);\r\nmode = CAM_READ_CACHE(pcdev, MODE) & ~THRESHOLD_MASK;\r\nmode |= THRESHOLD_LEVEL(pcdev->vb_mode) << THRESHOLD_SHIFT;\r\nCAM_WRITE(pcdev, MODE, mode | EN_FIFO_FULL | DMA);\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_SG) {\r\ntry_next_sgbuf(pcdev->dma_ch, buf);\r\n}\r\nstart_capture(pcdev);\r\n}\r\nstatic void omap1_videobuf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct omap1_cam_buf *buf =\r\ncontainer_of(vb, struct omap1_cam_buf, vb);\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nswitch (vb->state) {\r\ncase VIDEOBUF_DONE:\r\ndev_dbg(dev, "%s (done)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_ACTIVE:\r\ndev_dbg(dev, "%s (active)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_QUEUED:\r\ndev_dbg(dev, "%s (queued)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_PREPARED:\r\ndev_dbg(dev, "%s (prepared)\n", __func__);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s (unknown %d)\n", __func__, vb->state);\r\nbreak;\r\n}\r\nfree_buffer(vq, buf, pcdev->vb_mode);\r\n}\r\nstatic void videobuf_done(struct omap1_cam_dev *pcdev,\r\nenum videobuf_state result)\r\n{\r\nstruct omap1_cam_buf *buf = pcdev->active;\r\nstruct videobuf_buffer *vb;\r\nstruct device *dev = pcdev->soc_host.icd->parent;\r\nif (WARN_ON(!buf)) {\r\nsuspend_capture(pcdev);\r\ndisable_capture(pcdev);\r\nreturn;\r\n}\r\nif (result == VIDEOBUF_ERROR)\r\nsuspend_capture(pcdev);\r\nvb = &buf->vb;\r\nif (waitqueue_active(&vb->done)) {\r\nif (!pcdev->ready && result != VIDEOBUF_ERROR) {\r\nsuspend_capture(pcdev);\r\n}\r\nvb->state = result;\r\nv4l2_get_timestamp(&vb->ts);\r\nif (result != VIDEOBUF_ERROR)\r\nvb->field_count++;\r\nwake_up(&vb->done);\r\nbuf = pcdev->ready;\r\npcdev->active = buf;\r\npcdev->ready = NULL;\r\nif (!buf) {\r\nresult = VIDEOBUF_ERROR;\r\nprepare_next_vb(pcdev);\r\nbuf = pcdev->ready;\r\npcdev->active = buf;\r\npcdev->ready = NULL;\r\n}\r\n} else if (pcdev->ready) {\r\ndev_dbg(dev, "%s: nobody waiting on videobuf, swap with next\n",\r\n__func__);\r\npcdev->active = pcdev->ready;\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_SG) {\r\nbuf->sgbuf = NULL;\r\n}\r\npcdev->ready = buf;\r\nbuf = pcdev->active;\r\n} else {\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\ndev_dbg(dev,\r\n"%s: nobody waiting on videobuf, reuse it\n",\r\n__func__);\r\n} else {\r\nif (result != VIDEOBUF_ERROR) {\r\nsuspend_capture(pcdev);\r\nresult = VIDEOBUF_ERROR;\r\n}\r\n}\r\n}\r\nif (!buf) {\r\ndev_dbg(dev, "%s: no more videobufs, stop capture\n", __func__);\r\ndisable_capture(pcdev);\r\nreturn;\r\n}\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\n} else {\r\nif (result == VIDEOBUF_ERROR)\r\nbuf->sgbuf = NULL;\r\ntry_next_sgbuf(pcdev->dma_ch, buf);\r\n}\r\nif (result == VIDEOBUF_ERROR) {\r\ndev_dbg(dev, "%s: videobuf error; reset FIFO, restart DMA\n",\r\n__func__);\r\nstart_capture(pcdev);\r\n}\r\nprepare_next_vb(pcdev);\r\n}\r\nstatic void dma_isr(int channel, unsigned short status, void *data)\r\n{\r\nstruct omap1_cam_dev *pcdev = data;\r\nstruct omap1_cam_buf *buf = pcdev->active;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nif (WARN_ON(!buf)) {\r\nsuspend_capture(pcdev);\r\ndisable_capture(pcdev);\r\ngoto out;\r\n}\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\nCAM_WRITE(pcdev, MODE,\r\nCAM_READ_CACHE(pcdev, MODE) & ~EN_V_DOWN);\r\nvideobuf_done(pcdev, VIDEOBUF_DONE);\r\n} else {\r\nif (buf->sgbuf) {\r\ntry_next_sgbuf(pcdev->dma_ch, buf);\r\nif (buf->sgbuf)\r\ngoto out;\r\nif (buf->result != VIDEOBUF_ERROR) {\r\nbuf = prepare_next_vb(pcdev);\r\nif (!buf)\r\ngoto out;\r\ntry_next_sgbuf(pcdev->dma_ch, buf);\r\ngoto out;\r\n}\r\n}\r\nvideobuf_done(pcdev, buf->result);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\n}\r\nstatic irqreturn_t cam_isr(int irq, void *data)\r\n{\r\nstruct omap1_cam_dev *pcdev = data;\r\nstruct device *dev = pcdev->soc_host.icd->parent;\r\nstruct omap1_cam_buf *buf = pcdev->active;\r\nu32 it_status;\r\nunsigned long flags;\r\nit_status = CAM_READ(pcdev, IT_STATUS);\r\nif (!it_status)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nif (WARN_ON(!buf)) {\r\ndev_warn(dev, "%s: unhandled camera interrupt, status == %#x\n",\r\n__func__, it_status);\r\nsuspend_capture(pcdev);\r\ndisable_capture(pcdev);\r\ngoto out;\r\n}\r\nif (unlikely(it_status & FIFO_FULL)) {\r\ndev_warn(dev, "%s: FIFO overflow\n", __func__);\r\n} else if (it_status & V_DOWN) {\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\n} else {\r\nif (buf->sgcount == 2) {\r\ngoto out;\r\n}\r\n}\r\ndev_notice(dev, "%s: unexpected end of video frame\n",\r\n__func__);\r\n} else if (it_status & V_UP) {\r\nu32 mode;\r\nif (pcdev->vb_mode == OMAP1_CAM_DMA_CONTIG) {\r\nmode = CAM_READ_CACHE(pcdev, MODE);\r\n} else {\r\nmode = CAM_READ_CACHE(pcdev, MODE) & ~EN_V_UP;\r\n}\r\nif (!(mode & EN_V_DOWN)) {\r\nmode |= EN_V_DOWN;\r\n}\r\nCAM_WRITE(pcdev, MODE, mode);\r\ngoto out;\r\n} else {\r\ndev_warn(dev, "%s: unhandled camera interrupt, status == %#x\n",\r\n__func__, it_status);\r\ngoto out;\r\n}\r\nvideobuf_done(pcdev, VIDEOBUF_ERROR);\r\nout:\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sensor_reset(struct omap1_cam_dev *pcdev, bool reset)\r\n{\r\nif (pcdev->pflags & OMAP1_CAMERA_RST_HIGH)\r\nCAM_WRITE(pcdev, GPIO, reset);\r\nelse if (pcdev->pflags & OMAP1_CAMERA_RST_LOW)\r\nCAM_WRITE(pcdev, GPIO, !reset);\r\n}\r\nstatic int omap1_cam_add_device(struct soc_camera_device *icd)\r\n{\r\ndev_dbg(icd->parent, "OMAP1 Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void omap1_cam_remove_device(struct soc_camera_device *icd)\r\n{\r\ndev_dbg(icd->parent,\r\n"OMAP1 Camera driver detached from camera %d\n", icd->devnum);\r\n}\r\nstatic int omap1_cam_clock_start(struct soc_camera_host *ici)\r\n{\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nu32 ctrlclock;\r\nclk_enable(pcdev->clk);\r\nctrlclock = CAM_READ(pcdev, CTRLCLOCK);\r\nctrlclock &= ~(CAMEXCLK_EN | MCLK_EN | DPLL_EN);\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock);\r\nctrlclock &= ~FOSCMOD_MASK;\r\nswitch (pcdev->camexclk) {\r\ncase 6000000:\r\nctrlclock |= CAMEXCLK_EN | FOSCMOD_6MHz;\r\nbreak;\r\ncase 8000000:\r\nctrlclock |= CAMEXCLK_EN | FOSCMOD_8MHz | DPLL_EN;\r\nbreak;\r\ncase 9600000:\r\nctrlclock |= CAMEXCLK_EN | FOSCMOD_9_6MHz | DPLL_EN;\r\nbreak;\r\ncase 12000000:\r\nctrlclock |= CAMEXCLK_EN | FOSCMOD_12MHz;\r\nbreak;\r\ncase 24000000:\r\nctrlclock |= CAMEXCLK_EN | FOSCMOD_24MHz | DPLL_EN;\r\ndefault:\r\nbreak;\r\n}\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock & ~DPLL_EN);\r\nctrlclock |= MCLK_EN;\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock);\r\nsensor_reset(pcdev, false);\r\nreturn 0;\r\n}\r\nstatic void omap1_cam_clock_stop(struct soc_camera_host *ici)\r\n{\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nu32 ctrlclock;\r\nsuspend_capture(pcdev);\r\ndisable_capture(pcdev);\r\nsensor_reset(pcdev, true);\r\nctrlclock = CAM_READ_CACHE(pcdev, CTRLCLOCK);\r\nctrlclock &= ~(MCLK_EN | DPLL_EN | CAMEXCLK_EN);\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock);\r\nctrlclock = (ctrlclock & ~FOSCMOD_MASK) | FOSCMOD_12MHz;\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock);\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock | MCLK_EN);\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock & ~MCLK_EN);\r\nclk_disable(pcdev->clk);\r\n}\r\nstatic int omap1_cam_get_formats(struct soc_camera_device *icd,\r\nunsigned int idx, struct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nint formats = 0, ret;\r\nenum v4l2_mbus_pixelcode code;\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code);\r\nif (!fmt) {\r\ndev_warn(dev, "%s: unsupported format code #%d: %d\n", __func__,\r\nidx, code);\r\nreturn 0;\r\n}\r\nif (fmt->bits_per_sample != 8)\r\nreturn 0;\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ncase V4L2_MBUS_FMT_RGB555_2X8_PADHI_BE:\r\ncase V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE:\r\ncase V4L2_MBUS_FMT_RGB565_2X8_BE:\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = soc_mbus_find_fmtdesc(code,\r\nomap1_cam_formats,\r\nARRAY_SIZE(omap1_cam_formats));\r\nxlate->code = code;\r\nxlate++;\r\ndev_dbg(dev,\r\n"%s: providing format %s as byte swapped code #%d\n",\r\n__func__, xlate->host_fmt->name, code);\r\n}\r\ndefault:\r\nif (xlate)\r\ndev_dbg(dev,\r\n"%s: providing format %s in pass-through mode\n",\r\n__func__, fmt->name);\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic bool is_dma_aligned(s32 bytes_per_line, unsigned int height,\r\nenum omap1_cam_vb_mode vb_mode)\r\n{\r\nint size = bytes_per_line * height;\r\nreturn IS_ALIGNED(bytes_per_line, DMA_ELEMENT_SIZE) &&\r\nIS_ALIGNED(size, DMA_FRAME_SIZE(vb_mode) * DMA_ELEMENT_SIZE);\r\n}\r\nstatic int dma_align(int *width, int *height,\r\nconst struct soc_mbus_pixelfmt *fmt,\r\nenum omap1_cam_vb_mode vb_mode, bool enlarge)\r\n{\r\ns32 bytes_per_line = soc_mbus_bytes_per_line(*width, fmt);\r\nif (bytes_per_line < 0)\r\nreturn bytes_per_line;\r\nif (!is_dma_aligned(bytes_per_line, *height, vb_mode)) {\r\nunsigned int pxalign = __fls(bytes_per_line / *width);\r\nunsigned int salign = DMA_FRAME_SHIFT(vb_mode) +\r\nDMA_ELEMENT_SHIFT - pxalign;\r\nunsigned int incr = enlarge << salign;\r\nv4l_bound_align_image(width, 1, *width + incr, 0,\r\nheight, 1, *height + incr, 0, salign);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int set_mbus_format(struct omap1_cam_dev *pcdev, struct device *dev,\r\nstruct soc_camera_device *icd, struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf,\r\nconst struct soc_camera_format_xlate *xlate)\r\n{\r\ns32 bytes_per_line;\r\nint ret = subdev_call_with_sense(pcdev, dev, icd, sd, s_mbus_fmt, mf);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: s_mbus_fmt failed\n", __func__);\r\nreturn ret;\r\n}\r\nif (mf->code != xlate->code) {\r\ndev_err(dev, "%s: unexpected pixel code change\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nbytes_per_line = soc_mbus_bytes_per_line(mf->width, xlate->host_fmt);\r\nif (bytes_per_line < 0) {\r\ndev_err(dev, "%s: soc_mbus_bytes_per_line() failed\n",\r\n__func__);\r\nreturn bytes_per_line;\r\n}\r\nif (!is_dma_aligned(bytes_per_line, mf->height, pcdev->vb_mode)) {\r\ndev_err(dev, "%s: resulting geometry %ux%u not DMA aligned\n",\r\n__func__, mf->width, mf->height);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_set_crop(struct soc_camera_device *icd,\r\nconst struct v4l2_crop *crop)\r\n{\r\nconst struct v4l2_rect *rect = &crop->c;\r\nconst struct soc_camera_format_xlate *xlate = icd->current_fmt;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nret = subdev_call_with_sense(pcdev, dev, icd, sd, s_crop, crop);\r\nif (ret < 0) {\r\ndev_warn(dev, "%s: failed to crop to %ux%u@%u:%u\n", __func__,\r\nrect->width, rect->height, rect->left, rect->top);\r\nreturn ret;\r\n}\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);\r\nif (ret < 0) {\r\ndev_warn(dev, "%s: failed to fetch current format\n", __func__);\r\nreturn ret;\r\n}\r\nret = dma_align(&mf.width, &mf.height, xlate->host_fmt, pcdev->vb_mode,\r\nfalse);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: failed to align %ux%u %s with DMA\n",\r\n__func__, mf.width, mf.height,\r\nxlate->host_fmt->name);\r\nreturn ret;\r\n}\r\nif (!ret) {\r\nret = set_mbus_format(pcdev, dev, icd, sd, &mf, xlate);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: failed to set format\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nicd->user_width = mf.width;\r\nicd->user_height = mf.height;\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(dev, "%s: format %#x not found\n", __func__,\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = dma_align(&mf.width, &mf.height, xlate->host_fmt, pcdev->vb_mode,\r\ntrue);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: failed to align %ux%u %s with DMA\n",\r\n__func__, pix->width, pix->height,\r\nxlate->host_fmt->name);\r\nreturn ret;\r\n}\r\nret = set_mbus_format(pcdev, dev, icd, sd, &mf, xlate);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: failed to set format\n", __func__);\r\nreturn ret;\r\n}\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nicd->current_fmt = xlate;\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %#x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_mmap_mapper(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct soc_camera_device *icd = q->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nint ret;\r\nret = pcdev->mmap_mapper(q, buf, vma);\r\nif (ret == -ENOMEM)\r\nsg_mode = true;\r\nreturn ret;\r\n}\r\nstatic void omap1_cam_init_videobuf(struct videobuf_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nif (!sg_mode)\r\nvideobuf_queue_dma_contig_init(q, &omap1_videobuf_ops,\r\nicd->parent, &pcdev->lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_NONE,\r\nsizeof(struct omap1_cam_buf), icd, &ici->host_lock);\r\nelse\r\nvideobuf_queue_sg_init(q, &omap1_videobuf_ops,\r\nicd->parent, &pcdev->lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_NONE,\r\nsizeof(struct omap1_cam_buf), icd, &ici->host_lock);\r\npcdev->vb_mode = sg_mode ? OMAP1_CAM_DMA_SG : OMAP1_CAM_DMA_CONTIG;\r\nif (!sg_mode && q->int_ops->mmap_mapper != omap1_cam_mmap_mapper) {\r\npcdev->mmap_mapper = q->int_ops->mmap_mapper;\r\nq->int_ops->mmap_mapper = omap1_cam_mmap_mapper;\r\n}\r\n}\r\nstatic int omap1_cam_reqbufs(struct soc_camera_device *icd,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint i;\r\nfor (i = 0; i < p->count; i++) {\r\nstruct omap1_cam_buf *buf = container_of(icd->vb_vidq.bufs[i],\r\nstruct omap1_cam_buf, vb);\r\nbuf->inwork = 0;\r\nINIT_LIST_HEAD(&buf->vb.queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, "OMAP1 Camera", sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct omap1_cam_dev *pcdev = ici->priv;\r\nu32 pixfmt = icd->current_fmt->host_fmt->fourcc;\r\nconst struct soc_camera_format_xlate *xlate;\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nu32 ctrlclock, mode;\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg, SOCAM_BUS_FLAGS);\r\nif (!common_flags) {\r\ndev_warn(dev,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, SOCAM_BUS_FLAGS);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = SOCAM_BUS_FLAGS;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (!pcdev->pdata ||\r\npcdev->pdata->flags & OMAP1_CAMERA_LCLK_RISING)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(dev, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\nctrlclock = CAM_READ_CACHE(pcdev, CTRLCLOCK);\r\nif (ctrlclock & LCLK_EN)\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock & ~LCLK_EN);\r\nif (common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) {\r\ndev_dbg(dev, "CTRLCLOCK_REG |= POLCLK\n");\r\nctrlclock |= POLCLK;\r\n} else {\r\ndev_dbg(dev, "CTRLCLOCK_REG &= ~POLCLK\n");\r\nctrlclock &= ~POLCLK;\r\n}\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock & ~LCLK_EN);\r\nif (ctrlclock & LCLK_EN)\r\nCAM_WRITE(pcdev, CTRLCLOCK, ctrlclock);\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nfmt = xlate->host_fmt;\r\nmode = CAM_READ(pcdev, MODE) & ~(RAZ_FIFO | IRQ_MASK | DMA);\r\nif (fmt->order == SOC_MBUS_ORDER_LE) {\r\ndev_dbg(dev, "MODE_REG &= ~ORDERCAMD\n");\r\nCAM_WRITE(pcdev, MODE, mode & ~ORDERCAMD);\r\n} else {\r\ndev_dbg(dev, "MODE_REG |= ORDERCAMD\n");\r\nCAM_WRITE(pcdev, MODE, mode | ORDERCAMD);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int omap1_cam_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct omap1_cam_buf *buf;\r\nbuf = list_entry(icd->vb_vidq.stream.next, struct omap1_cam_buf,\r\nvb.stream);\r\npoll_wait(file, &buf->vb.done, pt);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int omap1_cam_probe(struct platform_device *pdev)\r\n{\r\nstruct omap1_cam_dev *pcdev;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nunsigned int irq;\r\nint err = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || (int)irq <= 0) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nclk = clk_get(&pdev->dev, "armper_ck");\r\nif (IS_ERR(clk)) {\r\nerr = PTR_ERR(clk);\r\ngoto exit;\r\n}\r\npcdev = kzalloc(sizeof(*pcdev) + resource_size(res), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nerr = -ENOMEM;\r\ngoto exit_put_clk;\r\n}\r\npcdev->res = res;\r\npcdev->clk = clk;\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (pcdev->pdata) {\r\npcdev->pflags = pcdev->pdata->flags;\r\npcdev->camexclk = pcdev->pdata->camexclk_khz * 1000;\r\n}\r\nswitch (pcdev->camexclk) {\r\ncase 6000000:\r\ncase 8000000:\r\ncase 9600000:\r\ncase 12000000:\r\ncase 24000000:\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev,\r\n"Incorrect sensor clock frequency %ld kHz, "\r\n"should be one of 0, 6, 8, 9.6, 12 or 24 MHz, "\r\n"please correct your platform data\n",\r\npcdev->pdata->camexclk_khz);\r\npcdev->camexclk = 0;\r\ncase 0:\r\ndev_info(&pdev->dev, "Not providing sensor clock\n");\r\n}\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nspin_lock_init(&pcdev->lock);\r\nif (!request_mem_region(res->start, resource_size(res), DRIVER_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit_kfree;\r\n}\r\nbase = ioremap(res->start, resource_size(res));\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\npcdev->irq = irq;\r\npcdev->base = base;\r\nsensor_reset(pcdev, true);\r\nerr = omap_request_dma(OMAP_DMA_CAMERA_IF_RX, DRIVER_NAME,\r\ndma_isr, (void *)pcdev, &pcdev->dma_ch);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Can't request DMA for OMAP1 Camera\n");\r\nerr = -EBUSY;\r\ngoto exit_iounmap;\r\n}\r\ndev_dbg(&pdev->dev, "got DMA channel %d\n", pcdev->dma_ch);\r\nomap_set_dma_src_params(pcdev->dma_ch, OMAP_DMA_PORT_TIPB,\r\nOMAP_DMA_AMODE_CONSTANT, res->start + REG_CAMDATA,\r\n0, 0);\r\nomap_set_dma_dest_burst_mode(pcdev->dma_ch, OMAP_DMA_DATA_BURST_4);\r\nomap_dma_link_lch(pcdev->dma_ch, pcdev->dma_ch);\r\nerr = request_irq(pcdev->irq, cam_isr, 0, DRIVER_NAME, pcdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Camera interrupt register failed\n");\r\ngoto exit_free_dma;\r\n}\r\npcdev->soc_host.drv_name = DRIVER_NAME;\r\npcdev->soc_host.ops = &omap1_host_ops;\r\npcdev->soc_host.priv = pcdev;\r\npcdev->soc_host.v4l2_dev.dev = &pdev->dev;\r\npcdev->soc_host.nr = pdev->id;\r\nerr = soc_camera_host_register(&pcdev->soc_host);\r\nif (err)\r\ngoto exit_free_irq;\r\ndev_info(&pdev->dev, "OMAP1 Camera Interface driver loaded\n");\r\nreturn 0;\r\nexit_free_irq:\r\nfree_irq(pcdev->irq, pcdev);\r\nexit_free_dma:\r\nomap_free_dma(pcdev->dma_ch);\r\nexit_iounmap:\r\niounmap(base);\r\nexit_release:\r\nrelease_mem_region(res->start, resource_size(res));\r\nexit_kfree:\r\nkfree(pcdev);\r\nexit_put_clk:\r\nclk_put(clk);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int omap1_cam_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct omap1_cam_dev *pcdev = container_of(soc_host,\r\nstruct omap1_cam_dev, soc_host);\r\nstruct resource *res;\r\nfree_irq(pcdev->irq, pcdev);\r\nomap_free_dma(pcdev->dma_ch);\r\nsoc_camera_host_unregister(soc_host);\r\niounmap(pcdev->base);\r\nres = pcdev->res;\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_put(pcdev->clk);\r\nkfree(pcdev);\r\ndev_info(&pdev->dev, "OMAP1 Camera Interface driver unloaded\n");\r\nreturn 0;\r\n}
