static int __init hash_setup(char *str)\r\n{\r\nif (strncmp(str, "md5", 3) == 0)\r\nima_hash = "md5";\r\nreturn 1;\r\n}\r\nstatic void ima_rdwr_violation_check(struct file *file)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct inode *inode = file_inode(file);\r\nfmode_t mode = file->f_mode;\r\nint must_measure;\r\nbool send_tomtou = false, send_writers = false;\r\nchar *pathbuf = NULL;\r\nconst char *pathname;\r\nif (!S_ISREG(inode->i_mode) || !ima_initialized)\r\nreturn;\r\nmutex_lock(&inode->i_mutex);\r\nif (mode & FMODE_WRITE) {\r\nif (atomic_read(&inode->i_readcount) && IS_IMA(inode))\r\nsend_tomtou = true;\r\ngoto out;\r\n}\r\nmust_measure = ima_must_measure(inode, MAY_READ, FILE_CHECK);\r\nif (!must_measure)\r\ngoto out;\r\nif (atomic_read(&inode->i_writecount) > 0)\r\nsend_writers = true;\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nif (!send_tomtou && !send_writers)\r\nreturn;\r\npathname = ima_d_path(&file->f_path, &pathbuf);\r\nif (!pathname || strlen(pathname) > IMA_EVENT_NAME_LEN_MAX)\r\npathname = dentry->d_name.name;\r\nif (send_tomtou)\r\nima_add_violation(inode, pathname,\r\n"invalid_pcr", "ToMToU");\r\nif (send_writers)\r\nima_add_violation(inode, pathname,\r\n"invalid_pcr", "open_writers");\r\nkfree(pathbuf);\r\n}\r\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\r\nstruct inode *inode, struct file *file)\r\n{\r\nfmode_t mode = file->f_mode;\r\nif (!(mode & FMODE_WRITE))\r\nreturn;\r\nmutex_lock(&inode->i_mutex);\r\nif (atomic_read(&inode->i_writecount) == 1 &&\r\niint->version != inode->i_version) {\r\niint->flags &= ~IMA_DONE_MASK;\r\nif (iint->flags & IMA_APPRAISE)\r\nima_update_xattr(iint, file);\r\n}\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nvoid ima_file_free(struct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct integrity_iint_cache *iint;\r\nif (!iint_initialized || !S_ISREG(inode->i_mode))\r\nreturn;\r\niint = integrity_iint_find(inode);\r\nif (!iint)\r\nreturn;\r\nima_check_last_writer(iint, inode, file);\r\n}\r\nstatic int process_measurement(struct file *file, const char *filename,\r\nint mask, int function)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct integrity_iint_cache *iint;\r\nchar *pathbuf = NULL;\r\nconst char *pathname = NULL;\r\nint rc = -ENOMEM, action, must_appraise, _func;\r\nif (!ima_initialized || !S_ISREG(inode->i_mode))\r\nreturn 0;\r\naction = ima_get_action(inode, mask, function);\r\nif (!action)\r\nreturn 0;\r\nmust_appraise = action & IMA_APPRAISE;\r\n_func = (action & IMA_FILE_APPRAISE) ? FILE_CHECK : function;\r\nmutex_lock(&inode->i_mutex);\r\niint = integrity_inode_get(inode);\r\nif (!iint)\r\ngoto out;\r\niint->flags |= action;\r\naction &= IMA_DO_MASK;\r\naction &= ~((iint->flags & IMA_DONE_MASK) >> 1);\r\nif (!action) {\r\nif (must_appraise)\r\nrc = ima_get_cache_status(iint, _func);\r\ngoto out_digsig;\r\n}\r\nrc = ima_collect_measurement(iint, file);\r\nif (rc != 0)\r\ngoto out_digsig;\r\npathname = !filename ? ima_d_path(&file->f_path, &pathbuf) : filename;\r\nif (!pathname)\r\npathname = (const char *)file->f_dentry->d_name.name;\r\nif (action & IMA_MEASURE)\r\nima_store_measurement(iint, file, pathname);\r\nif (action & IMA_APPRAISE_SUBMASK)\r\nrc = ima_appraise_measurement(_func, iint, file, pathname);\r\nif (action & IMA_AUDIT)\r\nima_audit_measurement(iint, pathname);\r\nkfree(pathbuf);\r\nout_digsig:\r\nif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG))\r\nrc = -EACCES;\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nint ima_file_mmap(struct file *file, unsigned long prot)\r\n{\r\nif (file && (prot & PROT_EXEC))\r\nreturn process_measurement(file, NULL, MAY_EXEC, MMAP_CHECK);\r\nreturn 0;\r\n}\r\nint ima_bprm_check(struct linux_binprm *bprm)\r\n{\r\nreturn process_measurement(bprm->file,\r\n(strcmp(bprm->filename, bprm->interp) == 0) ?\r\nbprm->filename : bprm->interp,\r\nMAY_EXEC, BPRM_CHECK);\r\n}\r\nint ima_file_check(struct file *file, int mask)\r\n{\r\nima_rdwr_violation_check(file);\r\nreturn process_measurement(file, NULL,\r\nmask & (MAY_READ | MAY_WRITE | MAY_EXEC),\r\nFILE_CHECK);\r\n}\r\nint ima_module_check(struct file *file)\r\n{\r\nif (!file) {\r\n#ifndef CONFIG_MODULE_SIG_FORCE\r\nif ((ima_appraise & IMA_APPRAISE_MODULES) &&\r\n(ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\n#endif\r\nreturn 0;\r\n}\r\nreturn process_measurement(file, NULL, MAY_EXEC, MODULE_CHECK);\r\n}\r\nstatic int __init init_ima(void)\r\n{\r\nint error;\r\nerror = ima_init();\r\nif (!error)\r\nima_initialized = 1;\r\nreturn error;\r\n}
