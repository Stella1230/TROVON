static void __iomem *gpio_reg(struct gpio_chip *chip, unsigned offset,\r\nenum GPIO_REG reg_type)\r\n{\r\nstruct lnw_gpio *lnw = to_lnw_priv(chip);\r\nunsigned nreg = chip->ngpio / 32;\r\nu8 reg = offset / 32;\r\nreturn lnw->reg_base + reg_type * nreg * 4 + reg * 4;\r\n}\r\nstatic void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,\r\nenum GPIO_REG reg_type)\r\n{\r\nstruct lnw_gpio *lnw = to_lnw_priv(chip);\r\nunsigned nreg = chip->ngpio / 32;\r\nu8 reg = offset / 16;\r\nreturn lnw->reg_base + reg_type * nreg * 4 + reg * 4;\r\n}\r\nstatic int lnw_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *gafr = gpio_reg_2bit(chip, offset, GAFR);\r\nu32 value = readl(gafr);\r\nint shift = (offset % 16) << 1, af = (value >> shift) & 3;\r\nif (af) {\r\nvalue &= ~(3 << shift);\r\nwritel(value, gafr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *gplr = gpio_reg(chip, offset, GPLR);\r\nreturn readl(gplr) & BIT(offset % 32);\r\n}\r\nstatic void lnw_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nvoid __iomem *gpsr, *gpcr;\r\nif (value) {\r\ngpsr = gpio_reg(chip, offset, GPSR);\r\nwritel(BIT(offset % 32), gpsr);\r\n} else {\r\ngpcr = gpio_reg(chip, offset, GPCR);\r\nwritel(BIT(offset % 32), gpcr);\r\n}\r\n}\r\nstatic int lnw_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct lnw_gpio *lnw = to_lnw_priv(chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nu32 value;\r\nunsigned long flags;\r\nif (lnw->pdev)\r\npm_runtime_get(&lnw->pdev->dev);\r\nspin_lock_irqsave(&lnw->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue &= ~BIT(offset % 32);\r\nwritel(value, gpdr);\r\nspin_unlock_irqrestore(&lnw->lock, flags);\r\nif (lnw->pdev)\r\npm_runtime_put(&lnw->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct lnw_gpio *lnw = to_lnw_priv(chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nunsigned long flags;\r\nlnw_gpio_set(chip, offset, value);\r\nif (lnw->pdev)\r\npm_runtime_get(&lnw->pdev->dev);\r\nspin_lock_irqsave(&lnw->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue |= BIT(offset % 32);\r\nwritel(value, gpdr);\r\nspin_unlock_irqrestore(&lnw->lock, flags);\r\nif (lnw->pdev)\r\npm_runtime_put(&lnw->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct lnw_gpio *lnw = to_lnw_priv(chip);\r\nreturn irq_create_mapping(lnw->domain, offset);\r\n}\r\nstatic int lnw_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct lnw_gpio *lnw = irq_data_get_irq_chip_data(d);\r\nu32 gpio = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu32 value;\r\nvoid __iomem *grer = gpio_reg(&lnw->chip, gpio, GRER);\r\nvoid __iomem *gfer = gpio_reg(&lnw->chip, gpio, GFER);\r\nif (gpio >= lnw->chip.ngpio)\r\nreturn -EINVAL;\r\nif (lnw->pdev)\r\npm_runtime_get(&lnw->pdev->dev);\r\nspin_lock_irqsave(&lnw->lock, flags);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nvalue = readl(grer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(grer) & (~BIT(gpio % 32));\r\nwritel(value, grer);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nvalue = readl(gfer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(gfer) & (~BIT(gpio % 32));\r\nwritel(value, gfer);\r\nspin_unlock_irqrestore(&lnw->lock, flags);\r\nif (lnw->pdev)\r\npm_runtime_put(&lnw->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void lnw_irq_unmask(struct irq_data *d)\r\n{\r\n}\r\nstatic void lnw_irq_mask(struct irq_data *d)\r\n{\r\n}\r\nstatic void lnw_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct lnw_gpio *lnw = irq_data_get_irq_handler_data(data);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nu32 base, gpio, mask;\r\nunsigned long pending;\r\nvoid __iomem *gedr;\r\nfor (base = 0; base < lnw->chip.ngpio; base += 32) {\r\ngedr = gpio_reg(&lnw->chip, base, GEDR);\r\nwhile ((pending = readl(gedr))) {\r\ngpio = __ffs(pending);\r\nmask = BIT(gpio);\r\nwritel(mask, gedr);\r\ngeneric_handle_irq(irq_find_mapping(lnw->domain,\r\nbase + gpio));\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic void lnw_irq_init_hw(struct lnw_gpio *lnw)\r\n{\r\nvoid __iomem *reg;\r\nunsigned base;\r\nfor (base = 0; base < lnw->chip.ngpio; base += 32) {\r\nreg = gpio_reg(&lnw->chip, base, GRER);\r\nwritel(0, reg);\r\nreg = gpio_reg(&lnw->chip, base, GFER);\r\nwritel(0, reg);\r\nreg = gpio_reg(&lnw->chip, base, GEDR);\r\nwritel(~0, reg);\r\n}\r\n}\r\nstatic int lnw_gpio_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct lnw_gpio *lnw = d->host_data;\r\nirq_set_chip_and_handler_name(virq, &lnw_irqchip, handle_simple_irq,\r\n"demux");\r\nirq_set_chip_data(virq, lnw);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_runtime_idle(struct device *dev)\r\n{\r\npm_schedule_suspend(dev, 500);\r\nreturn -EBUSY;\r\n}\r\nstatic int lnw_gpio_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nvoid __iomem *base;\r\nstruct lnw_gpio *lnw;\r\nu32 gpio_base;\r\nu32 irq_base;\r\nint retval;\r\nint ngpio = id->driver_data;\r\nretval = pcim_enable_device(pdev);\r\nif (retval)\r\nreturn retval;\r\nretval = pcim_iomap_regions(pdev, 1 << 0 | 1 << 1, pci_name(pdev));\r\nif (retval) {\r\ndev_err(&pdev->dev, "I/O memory mapping error\n");\r\nreturn retval;\r\n}\r\nbase = pcim_iomap_table(pdev)[1];\r\nirq_base = readl(base);\r\ngpio_base = readl(sizeof(u32) + base);\r\npcim_iounmap_regions(pdev, 1 << 1);\r\nlnw = devm_kzalloc(&pdev->dev, sizeof(*lnw), GFP_KERNEL);\r\nif (!lnw) {\r\ndev_err(&pdev->dev, "can't allocate chip data\n");\r\nreturn -ENOMEM;\r\n}\r\nlnw->reg_base = pcim_iomap_table(pdev)[0];\r\nlnw->chip.label = dev_name(&pdev->dev);\r\nlnw->chip.request = lnw_gpio_request;\r\nlnw->chip.direction_input = lnw_gpio_direction_input;\r\nlnw->chip.direction_output = lnw_gpio_direction_output;\r\nlnw->chip.get = lnw_gpio_get;\r\nlnw->chip.set = lnw_gpio_set;\r\nlnw->chip.to_irq = lnw_gpio_to_irq;\r\nlnw->chip.base = gpio_base;\r\nlnw->chip.ngpio = ngpio;\r\nlnw->chip.can_sleep = 0;\r\nlnw->pdev = pdev;\r\nspin_lock_init(&lnw->lock);\r\nlnw->domain = irq_domain_add_simple(pdev->dev.of_node, ngpio, irq_base,\r\n&lnw_gpio_irq_ops, lnw);\r\nif (!lnw->domain)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pdev, lnw);\r\nretval = gpiochip_add(&lnw->chip);\r\nif (retval) {\r\ndev_err(&pdev->dev, "gpiochip_add error %d\n", retval);\r\nreturn retval;\r\n}\r\nlnw_irq_init_hw(lnw);\r\nirq_set_handler_data(pdev->irq, lnw);\r\nirq_set_chained_handler(pdev->irq, lnw_irq_handler);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_allow(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init lnw_gpio_init(void)\r\n{\r\nreturn pci_register_driver(&lnw_gpio_driver);\r\n}
