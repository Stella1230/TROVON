static void done(struct qe_ep *ep, struct qe_req *req, int status)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nunsigned char stopped = ep->stopped;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (req->mapped) {\r\ndma_unmap_single(udc->gadget.dev.parent,\r\nreq->req.dma, req->req.length,\r\nep_is_in(ep)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nreq->req.dma = DMA_ADDR_INVALID;\r\nreq->mapped = 0;\r\n} else\r\ndma_sync_single_for_cpu(udc->gadget.dev.parent,\r\nreq->req.dma, req->req.length,\r\nep_is_in(ep)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nif (status && (status != -ESHUTDOWN))\r\ndev_vdbg(udc->dev, "complete %s req %p stat %d len %u/%u\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nspin_unlock(&udc->lock);\r\nif (req->req.complete)\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic void nuke(struct qe_ep *ep, int status)\r\n{\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct qe_req *req = NULL;\r\nreq = list_entry(ep->queue.next, struct qe_req, queue);\r\ndone(ep, req, status);\r\n}\r\n}\r\nstatic int qe_eprx_stall_change(struct qe_ep *ep, int value)\r\n{\r\nu16 tem_usep;\r\nu8 epnum = ep->epnum;\r\nstruct qe_udc *udc = ep->udc;\r\ntem_usep = in_be16(&udc->usb_regs->usb_usep[epnum]);\r\ntem_usep = tem_usep & ~USB_RHS_MASK;\r\nif (value == 1)\r\ntem_usep |= USB_RHS_STALL;\r\nelse if (ep->dir == USB_DIR_IN)\r\ntem_usep |= USB_RHS_IGNORE_OUT;\r\nout_be16(&udc->usb_regs->usb_usep[epnum], tem_usep);\r\nreturn 0;\r\n}\r\nstatic int qe_eptx_stall_change(struct qe_ep *ep, int value)\r\n{\r\nu16 tem_usep;\r\nu8 epnum = ep->epnum;\r\nstruct qe_udc *udc = ep->udc;\r\ntem_usep = in_be16(&udc->usb_regs->usb_usep[epnum]);\r\ntem_usep = tem_usep & ~USB_THS_MASK;\r\nif (value == 1)\r\ntem_usep |= USB_THS_STALL;\r\nelse if (ep->dir == USB_DIR_OUT)\r\ntem_usep |= USB_THS_IGNORE_IN;\r\nout_be16(&udc->usb_regs->usb_usep[epnum], tem_usep);\r\nreturn 0;\r\n}\r\nstatic int qe_ep0_stall(struct qe_udc *udc)\r\n{\r\nqe_eptx_stall_change(&udc->eps[0], 1);\r\nqe_eprx_stall_change(&udc->eps[0], 1);\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = 0;\r\nreturn 0;\r\n}\r\nstatic int qe_eprx_nack(struct qe_ep *ep)\r\n{\r\nu8 epnum = ep->epnum;\r\nstruct qe_udc *udc = ep->udc;\r\nif (ep->state == EP_STATE_IDLE) {\r\nclrsetbits_be16(&udc->usb_regs->usb_usep[epnum],\r\nUSB_RHS_MASK, USB_RHS_NACK);\r\nclrbits16(&udc->usb_regs->usb_usbmr,\r\n(USB_E_RXB_MASK | USB_E_BSY_MASK));\r\nep->state = EP_STATE_NACK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qe_eprx_normal(struct qe_ep *ep)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nif (ep->state == EP_STATE_NACK) {\r\nclrsetbits_be16(&udc->usb_regs->usb_usep[ep->epnum],\r\nUSB_RTHS_MASK, USB_THS_IGNORE_IN);\r\nout_be16(&udc->usb_regs->usb_usber,\r\nUSB_E_BSY_MASK | USB_E_RXB_MASK);\r\nsetbits16(&udc->usb_regs->usb_usbmr,\r\n(USB_E_RXB_MASK | USB_E_BSY_MASK));\r\nep->state = EP_STATE_IDLE;\r\nep->has_data = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qe_ep_cmd_stoptx(struct qe_ep *ep)\r\n{\r\nif (ep->udc->soc_type == PORT_CPM)\r\ncpm_command(CPM_USB_STOP_TX | (ep->epnum << CPM_USB_EP_SHIFT),\r\nCPM_USB_STOP_TX_OPCODE);\r\nelse\r\nqe_issue_cmd(QE_USB_STOP_TX, QE_CR_SUBBLOCK_USB,\r\nep->epnum, 0);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_cmd_restarttx(struct qe_ep *ep)\r\n{\r\nif (ep->udc->soc_type == PORT_CPM)\r\ncpm_command(CPM_USB_RESTART_TX | (ep->epnum <<\r\nCPM_USB_EP_SHIFT), CPM_USB_RESTART_TX_OPCODE);\r\nelse\r\nqe_issue_cmd(QE_USB_RESTART_TX, QE_CR_SUBBLOCK_USB,\r\nep->epnum, 0);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_flushtxfifo(struct qe_ep *ep)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nint i;\r\ni = (int)ep->epnum;\r\nqe_ep_cmd_stoptx(ep);\r\nout_8(&udc->usb_regs->usb_uscom,\r\nUSB_CMD_FLUSH_FIFO | (USB_CMD_EP_MASK & (ep->epnum)));\r\nout_be16(&udc->ep_param[i]->tbptr, in_be16(&udc->ep_param[i]->tbase));\r\nout_be32(&udc->ep_param[i]->tstate, 0);\r\nout_be16(&udc->ep_param[i]->tbcnt, 0);\r\nep->c_txbd = ep->txbase;\r\nep->n_txbd = ep->txbase;\r\nqe_ep_cmd_restarttx(ep);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_filltxfifo(struct qe_ep *ep)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nout_8(&udc->usb_regs->usb_uscom,\r\nUSB_CMD_STR_FIFO | (USB_CMD_EP_MASK & (ep->epnum)));\r\nreturn 0;\r\n}\r\nstatic int qe_epbds_reset(struct qe_udc *udc, int pipe_num)\r\n{\r\nstruct qe_ep *ep;\r\nu32 bdring_len;\r\nstruct qe_bd __iomem *bd;\r\nint i;\r\nep = &udc->eps[pipe_num];\r\nif (ep->dir == USB_DIR_OUT)\r\nbdring_len = USB_BDRING_LEN_RX;\r\nelse\r\nbdring_len = USB_BDRING_LEN;\r\nbd = ep->rxbase;\r\nfor (i = 0; i < (bdring_len - 1); i++) {\r\nout_be32((u32 __iomem *)bd, R_E | R_I);\r\nbd++;\r\n}\r\nout_be32((u32 __iomem *)bd, R_E | R_I | R_W);\r\nbd = ep->txbase;\r\nfor (i = 0; i < USB_BDRING_LEN_TX - 1; i++) {\r\nout_be32(&bd->buf, 0);\r\nout_be32((u32 __iomem *)bd, 0);\r\nbd++;\r\n}\r\nout_be32((u32 __iomem *)bd, T_W);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_reset(struct qe_udc *udc, int pipe_num)\r\n{\r\nstruct qe_ep *ep;\r\nu16 tmpusep;\r\nep = &udc->eps[pipe_num];\r\ntmpusep = in_be16(&udc->usb_regs->usb_usep[pipe_num]);\r\ntmpusep &= ~USB_RTHS_MASK;\r\nswitch (ep->dir) {\r\ncase USB_DIR_BOTH:\r\nqe_ep_flushtxfifo(ep);\r\nbreak;\r\ncase USB_DIR_OUT:\r\ntmpusep |= USB_THS_IGNORE_IN;\r\nbreak;\r\ncase USB_DIR_IN:\r\nqe_ep_flushtxfifo(ep);\r\ntmpusep |= USB_RHS_IGNORE_OUT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout_be16(&udc->usb_regs->usb_usep[pipe_num], tmpusep);\r\nqe_epbds_reset(udc, pipe_num);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_toggledata01(struct qe_ep *ep)\r\n{\r\nep->data01 ^= 0x1;\r\nreturn 0;\r\n}\r\nstatic int qe_ep_bd_init(struct qe_udc *udc, unsigned char pipe_num)\r\n{\r\nstruct qe_ep *ep = &udc->eps[pipe_num];\r\nunsigned long tmp_addr = 0;\r\nstruct usb_ep_para __iomem *epparam;\r\nint i;\r\nstruct qe_bd __iomem *bd;\r\nint bdring_len;\r\nif (ep->dir == USB_DIR_OUT)\r\nbdring_len = USB_BDRING_LEN_RX;\r\nelse\r\nbdring_len = USB_BDRING_LEN;\r\nepparam = udc->ep_param[pipe_num];\r\ntmp_addr = cpm_muram_alloc(sizeof(struct qe_bd) * (bdring_len +\r\nUSB_BDRING_LEN_TX), QE_ALIGNMENT_OF_BD);\r\nif (IS_ERR_VALUE(tmp_addr))\r\nreturn -ENOMEM;\r\nout_be16(&epparam->rbase, (u16)tmp_addr);\r\nout_be16(&epparam->tbase, (u16)(tmp_addr +\r\n(sizeof(struct qe_bd) * bdring_len)));\r\nout_be16(&epparam->rbptr, in_be16(&epparam->rbase));\r\nout_be16(&epparam->tbptr, in_be16(&epparam->tbase));\r\nep->rxbase = cpm_muram_addr(tmp_addr);\r\nep->txbase = cpm_muram_addr(tmp_addr + (sizeof(struct qe_bd)\r\n* bdring_len));\r\nep->n_rxbd = ep->rxbase;\r\nep->e_rxbd = ep->rxbase;\r\nep->n_txbd = ep->txbase;\r\nep->c_txbd = ep->txbase;\r\nep->data01 = 0;\r\nbd = ep->rxbase;\r\nfor (i = 0; i < bdring_len - 1; i++) {\r\nout_be32(&bd->buf, 0);\r\nout_be32((u32 __iomem *)bd, 0);\r\nbd++;\r\n}\r\nout_be32(&bd->buf, 0);\r\nout_be32((u32 __iomem *)bd, R_W);\r\nbd = ep->txbase;\r\nfor (i = 0; i < USB_BDRING_LEN_TX - 1; i++) {\r\nout_be32(&bd->buf, 0);\r\nout_be32((u32 __iomem *)bd, 0);\r\nbd++;\r\n}\r\nout_be32(&bd->buf, 0);\r\nout_be32((u32 __iomem *)bd, T_W);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_rxbd_update(struct qe_ep *ep)\r\n{\r\nunsigned int size;\r\nint i;\r\nunsigned int tmp;\r\nstruct qe_bd __iomem *bd;\r\nunsigned int bdring_len;\r\nif (ep->rxbase == NULL)\r\nreturn -EINVAL;\r\nbd = ep->rxbase;\r\nep->rxframe = kmalloc(sizeof(*ep->rxframe), GFP_ATOMIC);\r\nif (ep->rxframe == NULL) {\r\ndev_err(ep->udc->dev, "malloc rxframe failed\n");\r\nreturn -ENOMEM;\r\n}\r\nqe_frame_init(ep->rxframe);\r\nif (ep->dir == USB_DIR_OUT)\r\nbdring_len = USB_BDRING_LEN_RX;\r\nelse\r\nbdring_len = USB_BDRING_LEN;\r\nsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) * (bdring_len + 1);\r\nep->rxbuffer = kzalloc(size, GFP_ATOMIC);\r\nif (ep->rxbuffer == NULL) {\r\ndev_err(ep->udc->dev, "malloc rxbuffer failed,size=%d\n",\r\nsize);\r\nkfree(ep->rxframe);\r\nreturn -ENOMEM;\r\n}\r\nep->rxbuf_d = virt_to_phys((void *)ep->rxbuffer);\r\nif (ep->rxbuf_d == DMA_ADDR_INVALID) {\r\nep->rxbuf_d = dma_map_single(ep->udc->gadget.dev.parent,\r\nep->rxbuffer,\r\nsize,\r\nDMA_FROM_DEVICE);\r\nep->rxbufmap = 1;\r\n} else {\r\ndma_sync_single_for_device(ep->udc->gadget.dev.parent,\r\nep->rxbuf_d, size,\r\nDMA_FROM_DEVICE);\r\nep->rxbufmap = 0;\r\n}\r\nsize = ep->ep.maxpacket + USB_CRC_SIZE + 2;\r\ntmp = ep->rxbuf_d;\r\ntmp = (u32)(((tmp >> 2) << 2) + 4);\r\nfor (i = 0; i < bdring_len - 1; i++) {\r\nout_be32(&bd->buf, tmp);\r\nout_be32((u32 __iomem *)bd, (R_E | R_I));\r\ntmp = tmp + size;\r\nbd++;\r\n}\r\nout_be32(&bd->buf, tmp);\r\nout_be32((u32 __iomem *)bd, (R_E | R_I | R_W));\r\nreturn 0;\r\n}\r\nstatic int qe_ep_register_init(struct qe_udc *udc, unsigned char pipe_num)\r\n{\r\nstruct qe_ep *ep = &udc->eps[pipe_num];\r\nstruct usb_ep_para __iomem *epparam;\r\nu16 usep, logepnum;\r\nu16 tmp;\r\nu8 rtfcr = 0;\r\nepparam = udc->ep_param[pipe_num];\r\nusep = 0;\r\nlogepnum = (ep->ep.desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\nusep |= (logepnum << USB_EPNUM_SHIFT);\r\nswitch (ep->ep.desc->bmAttributes & 0x03) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nusep |= USB_TRANS_BULK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nusep |= USB_TRANS_ISO;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nusep |= USB_TRANS_INT;\r\nbreak;\r\ndefault:\r\nusep |= USB_TRANS_CTR;\r\nbreak;\r\n}\r\nswitch (ep->dir) {\r\ncase USB_DIR_OUT:\r\nusep |= USB_THS_IGNORE_IN;\r\nbreak;\r\ncase USB_DIR_IN:\r\nusep |= USB_RHS_IGNORE_OUT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout_be16(&udc->usb_regs->usb_usep[pipe_num], usep);\r\nrtfcr = 0x30;\r\nout_8(&epparam->rbmr, rtfcr);\r\nout_8(&epparam->tbmr, rtfcr);\r\ntmp = (u16)(ep->ep.maxpacket + USB_CRC_SIZE);\r\ntmp = (u16)(((tmp >> 2) << 2) + 4);\r\nout_be16(&epparam->mrblr, tmp);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_init(struct qe_udc *udc,\r\nunsigned char pipe_num,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct qe_ep *ep = &udc->eps[pipe_num];\r\nunsigned long flags;\r\nint reval = 0;\r\nu16 max = 0;\r\nmax = usb_endpoint_maxp(desc);\r\nif (pipe_num != 0) {\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (strstr(ep->ep.name, "-iso")\r\n|| strstr(ep->ep.name, "-int"))\r\ngoto en_done;\r\nswitch (udc->gadget.speed) {\r\ncase USB_SPEED_HIGH:\r\nif ((max == 128) || (max == 256) || (max == 512))\r\nbreak;\r\ndefault:\r\nswitch (max) {\r\ncase 4:\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\nbreak;\r\ndefault:\r\ncase USB_SPEED_LOW:\r\ngoto en_done;\r\n}\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (strstr(ep->ep.name, "-iso"))\r\ngoto en_done;\r\nswitch (udc->gadget.speed) {\r\ncase USB_SPEED_HIGH:\r\nif (max <= 1024)\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nif (max <= 64)\r\nbreak;\r\ndefault:\r\nif (max <= 8)\r\nbreak;\r\ngoto en_done;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (strstr(ep->ep.name, "-bulk")\r\n|| strstr(ep->ep.name, "-int"))\r\ngoto en_done;\r\nswitch (udc->gadget.speed) {\r\ncase USB_SPEED_HIGH:\r\nif (max <= 1024)\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nif (max <= 1023)\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nif (strstr(ep->ep.name, "-iso")\r\n|| strstr(ep->ep.name, "-int"))\r\ngoto en_done;\r\nswitch (udc->gadget.speed) {\r\ncase USB_SPEED_HIGH:\r\ncase USB_SPEED_FULL:\r\nswitch (max) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\ncase USB_SPEED_LOW:\r\nswitch (max) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\ndefault:\r\ngoto en_done;\r\n}\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->ep.maxpacket = max;\r\nep->tm = (u8)(desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\r\nep->ep.desc = desc;\r\nep->stopped = 0;\r\nep->init = 1;\r\nif (pipe_num == 0) {\r\nep->dir = USB_DIR_BOTH;\r\nudc->ep0_dir = USB_DIR_OUT;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\n} else {\r\nswitch (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) {\r\ncase USB_DIR_OUT:\r\nep->dir = USB_DIR_OUT;\r\nbreak;\r\ncase USB_DIR_IN:\r\nep->dir = USB_DIR_IN;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nqe_ep_bd_init(udc, pipe_num);\r\nif ((ep->tm == USBP_TM_CTL) || (ep->dir == USB_DIR_OUT)) {\r\nreval = qe_ep_rxbd_update(ep);\r\nif (reval)\r\ngoto en_done1;\r\n}\r\nif ((ep->tm == USBP_TM_CTL) || (ep->dir == USB_DIR_IN)) {\r\nep->txframe = kmalloc(sizeof(*ep->txframe), GFP_ATOMIC);\r\nif (ep->txframe == NULL) {\r\ndev_err(udc->dev, "malloc txframe failed\n");\r\ngoto en_done2;\r\n}\r\nqe_frame_init(ep->txframe);\r\n}\r\nqe_ep_register_init(udc, pipe_num);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\nen_done2:\r\nkfree(ep->rxbuffer);\r\nkfree(ep->rxframe);\r\nen_done1:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nen_done:\r\ndev_err(udc->dev, "failed to initialize %s\n", ep->ep.name);\r\nreturn -ENODEV;\r\n}\r\nstatic inline void qe_usb_enable(struct qe_udc *udc)\r\n{\r\nsetbits8(&udc->usb_regs->usb_usmod, USB_MODE_EN);\r\n}\r\nstatic inline void qe_usb_disable(struct qe_udc *udc)\r\n{\r\nclrbits8(&udc->usb_regs->usb_usmod, USB_MODE_EN);\r\n}\r\nstatic void recycle_one_rxbd(struct qe_ep *ep)\r\n{\r\nu32 bdstatus;\r\nbdstatus = in_be32((u32 __iomem *)ep->e_rxbd);\r\nbdstatus = R_I | R_E | (bdstatus & R_W);\r\nout_be32((u32 __iomem *)ep->e_rxbd, bdstatus);\r\nif (bdstatus & R_W)\r\nep->e_rxbd = ep->rxbase;\r\nelse\r\nep->e_rxbd++;\r\n}\r\nstatic void recycle_rxbds(struct qe_ep *ep, unsigned char stopatnext)\r\n{\r\nu32 bdstatus;\r\nstruct qe_bd __iomem *bd, *nextbd;\r\nunsigned char stop = 0;\r\nnextbd = ep->n_rxbd;\r\nbd = ep->e_rxbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nwhile (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK) && !stop) {\r\nbdstatus = R_E | R_I | (bdstatus & R_W);\r\nout_be32((u32 __iomem *)bd, bdstatus);\r\nif (bdstatus & R_W)\r\nbd = ep->rxbase;\r\nelse\r\nbd++;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nif (stopatnext && (bd == nextbd))\r\nstop = 1;\r\n}\r\nep->e_rxbd = bd;\r\n}\r\nstatic void ep_recycle_rxbds(struct qe_ep *ep)\r\n{\r\nstruct qe_bd __iomem *bd = ep->n_rxbd;\r\nu32 bdstatus;\r\nu8 epnum = ep->epnum;\r\nstruct qe_udc *udc = ep->udc;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nif (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK)) {\r\nbd = ep->rxbase +\r\n((in_be16(&udc->ep_param[epnum]->rbptr) -\r\nin_be16(&udc->ep_param[epnum]->rbase))\r\n>> 3);\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nif (bdstatus & R_W)\r\nbd = ep->rxbase;\r\nelse\r\nbd++;\r\nep->e_rxbd = bd;\r\nrecycle_rxbds(ep, 0);\r\nep->e_rxbd = ep->n_rxbd;\r\n} else\r\nrecycle_rxbds(ep, 1);\r\nif (in_be16(&udc->usb_regs->usb_usber) & USB_E_BSY_MASK)\r\nout_be16(&udc->usb_regs->usb_usber, USB_E_BSY_MASK);\r\nif (ep->has_data <= 0 && (!list_empty(&ep->queue)))\r\nqe_eprx_normal(ep);\r\nep->localnack = 0;\r\n}\r\nstatic int ep0_setup_handle(struct qe_udc *udc)\r\n{\r\nstruct qe_ep *ep = &udc->eps[0];\r\nstruct qe_frame *pframe;\r\nunsigned int fsize;\r\nu8 *cp;\r\npframe = ep->rxframe;\r\nif ((frame_get_info(pframe) & PID_SETUP)\r\n&& (udc->ep0_state == WAIT_FOR_SETUP)) {\r\nfsize = frame_get_length(pframe);\r\nif (unlikely(fsize != 8))\r\nreturn -EINVAL;\r\ncp = (u8 *)&udc->local_setup_buff;\r\nmemcpy(cp, pframe->data, fsize);\r\nep->data01 = 1;\r\nsetup_received_handle(udc, &udc->local_setup_buff);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int qe_ep0_rx(struct qe_udc *udc)\r\n{\r\nstruct qe_ep *ep = &udc->eps[0];\r\nstruct qe_frame *pframe;\r\nstruct qe_bd __iomem *bd;\r\nu32 bdstatus, length;\r\nu32 vaddr;\r\npframe = ep->rxframe;\r\nif (ep->dir == USB_DIR_IN) {\r\ndev_err(udc->dev, "ep0 not a control endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nbd = ep->n_rxbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nlength = bdstatus & BD_LENGTH_MASK;\r\nwhile (!(bdstatus & R_E) && length) {\r\nif ((bdstatus & R_F) && (bdstatus & R_L)\r\n&& !(bdstatus & R_ERROR)) {\r\nif (length == USB_CRC_SIZE) {\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\ndev_vdbg(udc->dev,\r\n"receive a ZLP in status phase\n");\r\n} else {\r\nqe_frame_clean(pframe);\r\nvaddr = (u32)phys_to_virt(in_be32(&bd->buf));\r\nframe_set_data(pframe, (u8 *)vaddr);\r\nframe_set_length(pframe,\r\n(length - USB_CRC_SIZE));\r\nframe_set_status(pframe, FRAME_OK);\r\nswitch (bdstatus & R_PID) {\r\ncase R_PID_SETUP:\r\nframe_set_info(pframe, PID_SETUP);\r\nbreak;\r\ncase R_PID_DATA1:\r\nframe_set_info(pframe, PID_DATA1);\r\nbreak;\r\ndefault:\r\nframe_set_info(pframe, PID_DATA0);\r\nbreak;\r\n}\r\nif ((bdstatus & R_PID) == R_PID_SETUP)\r\nep0_setup_handle(udc);\r\nelse\r\nqe_ep_rxframe_handle(ep);\r\n}\r\n} else {\r\ndev_err(udc->dev, "The receive frame with error!\n");\r\n}\r\nrecycle_one_rxbd(ep);\r\nif (bdstatus & R_W)\r\nbd = ep->rxbase;\r\nelse\r\nbd++;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nlength = bdstatus & BD_LENGTH_MASK;\r\n}\r\nep->n_rxbd = bd;\r\nreturn 0;\r\n}\r\nstatic int qe_ep_rxframe_handle(struct qe_ep *ep)\r\n{\r\nstruct qe_frame *pframe;\r\nu8 framepid = 0;\r\nunsigned int fsize;\r\nu8 *cp;\r\nstruct qe_req *req;\r\npframe = ep->rxframe;\r\nif (frame_get_info(pframe) & PID_DATA1)\r\nframepid = 0x1;\r\nif (framepid != ep->data01) {\r\ndev_err(ep->udc->dev, "the data01 error!\n");\r\nreturn -EIO;\r\n}\r\nfsize = frame_get_length(pframe);\r\nif (list_empty(&ep->queue)) {\r\ndev_err(ep->udc->dev, "the %s have no requeue!\n", ep->name);\r\n} else {\r\nreq = list_entry(ep->queue.next, struct qe_req, queue);\r\ncp = (u8 *)(req->req.buf) + req->req.actual;\r\nif (cp) {\r\nmemcpy(cp, pframe->data, fsize);\r\nreq->req.actual += fsize;\r\nif ((fsize < ep->ep.maxpacket) ||\r\n(req->req.actual >= req->req.length)) {\r\nif (ep->epnum == 0)\r\nep0_req_complete(ep->udc, req);\r\nelse\r\ndone(ep, req, 0);\r\nif (list_empty(&ep->queue) && ep->epnum != 0)\r\nqe_eprx_nack(ep);\r\n}\r\n}\r\n}\r\nqe_ep_toggledata01(ep);\r\nreturn 0;\r\n}\r\nstatic void ep_rx_tasklet(unsigned long data)\r\n{\r\nstruct qe_udc *udc = (struct qe_udc *)data;\r\nstruct qe_ep *ep;\r\nstruct qe_frame *pframe;\r\nstruct qe_bd __iomem *bd;\r\nunsigned long flags;\r\nu32 bdstatus, length;\r\nu32 vaddr, i;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nfor (i = 1; i < USB_MAX_ENDPOINTS; i++) {\r\nep = &udc->eps[i];\r\nif (ep->dir == USB_DIR_IN || ep->enable_tasklet == 0) {\r\ndev_dbg(udc->dev,\r\n"This is a transmit ep or disable tasklet!\n");\r\ncontinue;\r\n}\r\npframe = ep->rxframe;\r\nbd = ep->n_rxbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nlength = bdstatus & BD_LENGTH_MASK;\r\nwhile (!(bdstatus & R_E) && length) {\r\nif (list_empty(&ep->queue)) {\r\nqe_eprx_nack(ep);\r\ndev_dbg(udc->dev,\r\n"The rxep have noreq %d\n",\r\nep->has_data);\r\nbreak;\r\n}\r\nif ((bdstatus & R_F) && (bdstatus & R_L)\r\n&& !(bdstatus & R_ERROR)) {\r\nqe_frame_clean(pframe);\r\nvaddr = (u32)phys_to_virt(in_be32(&bd->buf));\r\nframe_set_data(pframe, (u8 *)vaddr);\r\nframe_set_length(pframe,\r\n(length - USB_CRC_SIZE));\r\nframe_set_status(pframe, FRAME_OK);\r\nswitch (bdstatus & R_PID) {\r\ncase R_PID_DATA1:\r\nframe_set_info(pframe, PID_DATA1);\r\nbreak;\r\ncase R_PID_SETUP:\r\nframe_set_info(pframe, PID_SETUP);\r\nbreak;\r\ndefault:\r\nframe_set_info(pframe, PID_DATA0);\r\nbreak;\r\n}\r\nqe_ep_rxframe_handle(ep);\r\n} else {\r\ndev_err(udc->dev,\r\n"error in received frame\n");\r\n}\r\nout_be32((u32 __iomem *)bd, bdstatus & BD_STATUS_MASK);\r\nep->has_data--;\r\nif (!(ep->localnack))\r\nrecycle_one_rxbd(ep);\r\nif (bdstatus & R_W)\r\nbd = ep->rxbase;\r\nelse\r\nbd++;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nlength = bdstatus & BD_LENGTH_MASK;\r\n}\r\nep->n_rxbd = bd;\r\nif (ep->localnack)\r\nep_recycle_rxbds(ep);\r\nep->enable_tasklet = 0;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic int qe_ep_rx(struct qe_ep *ep)\r\n{\r\nstruct qe_udc *udc;\r\nstruct qe_frame *pframe;\r\nstruct qe_bd __iomem *bd;\r\nu16 swoffs, ucoffs, emptybds;\r\nudc = ep->udc;\r\npframe = ep->rxframe;\r\nif (ep->dir == USB_DIR_IN) {\r\ndev_err(udc->dev, "transmit ep in rx function\n");\r\nreturn -EINVAL;\r\n}\r\nbd = ep->n_rxbd;\r\nswoffs = (u16)(bd - ep->rxbase);\r\nucoffs = (u16)((in_be16(&udc->ep_param[ep->epnum]->rbptr) -\r\nin_be16(&udc->ep_param[ep->epnum]->rbase)) >> 3);\r\nif (swoffs < ucoffs)\r\nemptybds = USB_BDRING_LEN_RX - ucoffs + swoffs;\r\nelse\r\nemptybds = swoffs - ucoffs;\r\nif (emptybds < MIN_EMPTY_BDS) {\r\nqe_eprx_nack(ep);\r\nep->localnack = 1;\r\ndev_vdbg(udc->dev, "%d empty bds, send NACK\n", emptybds);\r\n}\r\nep->has_data = USB_BDRING_LEN_RX - emptybds;\r\nif (list_empty(&ep->queue)) {\r\nqe_eprx_nack(ep);\r\ndev_vdbg(udc->dev, "The rxep have no req queued with %d BDs\n",\r\nep->has_data);\r\nreturn 0;\r\n}\r\ntasklet_schedule(&udc->rx_tasklet);\r\nep->enable_tasklet = 1;\r\nreturn 0;\r\n}\r\nstatic int qe_ep_tx(struct qe_ep *ep, struct qe_frame *frame)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nstruct qe_bd __iomem *bd;\r\nu16 saveusbmr;\r\nu32 bdstatus, pidmask;\r\nu32 paddr;\r\nif (ep->dir == USB_DIR_OUT) {\r\ndev_err(udc->dev, "receive ep passed to tx function\n");\r\nreturn -EINVAL;\r\n}\r\nsaveusbmr = in_be16(&udc->usb_regs->usb_usbmr);\r\nout_be16(&udc->usb_regs->usb_usbmr,\r\nsaveusbmr & ~(USB_E_TXB_MASK | USB_E_TXE_MASK));\r\nbd = ep->n_txbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nif (!(bdstatus & (T_R | BD_LENGTH_MASK))) {\r\nif (frame_get_length(frame) == 0) {\r\nframe_set_data(frame, udc->nullbuf);\r\nframe_set_length(frame, 2);\r\nframe->info |= (ZLP | NO_CRC);\r\ndev_vdbg(udc->dev, "the frame size = 0\n");\r\n}\r\npaddr = virt_to_phys((void *)frame->data);\r\nout_be32(&bd->buf, paddr);\r\nbdstatus = (bdstatus&T_W);\r\nif (!(frame_get_info(frame) & NO_CRC))\r\nbdstatus |= T_R | T_I | T_L | T_TC\r\n| frame_get_length(frame);\r\nelse\r\nbdstatus |= T_R | T_I | T_L | frame_get_length(frame);\r\nif ((ep->epnum == 0) && (udc->ep0_state == DATA_STATE_NEED_ZLP))\r\nep->data01 = 0x1;\r\nif (ep->data01) {\r\npidmask = T_PID_DATA1;\r\nframe->info |= PID_DATA1;\r\n} else {\r\npidmask = T_PID_DATA0;\r\nframe->info |= PID_DATA0;\r\n}\r\nbdstatus |= T_CNF;\r\nbdstatus |= pidmask;\r\nout_be32((u32 __iomem *)bd, bdstatus);\r\nqe_ep_filltxfifo(ep);\r\nout_be16(&udc->usb_regs->usb_usbmr, saveusbmr);\r\nqe_ep_toggledata01(ep);\r\nif (bdstatus & T_W)\r\nep->n_txbd = ep->txbase;\r\nelse\r\nep->n_txbd++;\r\nreturn 0;\r\n} else {\r\nout_be16(&udc->usb_regs->usb_usbmr, saveusbmr);\r\ndev_vdbg(udc->dev, "The tx bd is not ready!\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nstatic int txcomplete(struct qe_ep *ep, unsigned char restart)\r\n{\r\nif (ep->tx_req != NULL) {\r\nstruct qe_req *req = ep->tx_req;\r\nunsigned zlp = 0, last_len = 0;\r\nlast_len = min_t(unsigned, req->req.length - ep->sent,\r\nep->ep.maxpacket);\r\nif (!restart) {\r\nint asent = ep->last;\r\nep->sent += asent;\r\nep->last -= asent;\r\n} else {\r\nep->last = 0;\r\n}\r\nif (req->req.zero) {\r\nif (last_len == 0 ||\r\n(req->req.length % ep->ep.maxpacket) != 0)\r\nzlp = 0;\r\nelse\r\nzlp = 1;\r\n} else\r\nzlp = 0;\r\nif (((ep->tx_req->req.length - ep->sent) <= 0) && !zlp) {\r\ndone(ep, ep->tx_req, 0);\r\nep->tx_req = NULL;\r\nep->last = 0;\r\nep->sent = 0;\r\n}\r\n}\r\nif (ep->tx_req == NULL) {\r\nif (!list_empty(&ep->queue)) {\r\nep->tx_req = list_entry(ep->queue.next, struct qe_req,\r\nqueue);\r\nep->last = 0;\r\nep->sent = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qe_usb_senddata(struct qe_ep *ep, struct qe_frame *frame)\r\n{\r\nunsigned int size;\r\nu8 *buf;\r\nqe_frame_clean(frame);\r\nsize = min_t(u32, (ep->tx_req->req.length - ep->sent),\r\nep->ep.maxpacket);\r\nbuf = (u8 *)ep->tx_req->req.buf + ep->sent;\r\nif (buf && size) {\r\nep->last = size;\r\nep->tx_req->req.actual += size;\r\nframe_set_data(frame, buf);\r\nframe_set_length(frame, size);\r\nframe_set_status(frame, FRAME_OK);\r\nframe_set_info(frame, 0);\r\nreturn qe_ep_tx(ep, frame);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int sendnulldata(struct qe_ep *ep, struct qe_frame *frame, uint infor)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nif (frame == NULL)\r\nreturn -ENODEV;\r\nqe_frame_clean(frame);\r\nframe_set_data(frame, (u8 *)udc->nullbuf);\r\nframe_set_length(frame, 2);\r\nframe_set_status(frame, FRAME_OK);\r\nframe_set_info(frame, (ZLP | NO_CRC | infor));\r\nreturn qe_ep_tx(ep, frame);\r\n}\r\nstatic int frame_create_tx(struct qe_ep *ep, struct qe_frame *frame)\r\n{\r\nstruct qe_req *req = ep->tx_req;\r\nint reval;\r\nif (req == NULL)\r\nreturn -ENODEV;\r\nif ((req->req.length - ep->sent) > 0)\r\nreval = qe_usb_senddata(ep, frame);\r\nelse\r\nreval = sendnulldata(ep, frame, 0);\r\nreturn reval;\r\n}\r\nstatic int ep0_prime_status(struct qe_udc *udc, int direction)\r\n{\r\nstruct qe_ep *ep = &udc->eps[0];\r\nif (direction == USB_DIR_IN) {\r\nudc->ep0_state = DATA_STATE_NEED_ZLP;\r\nudc->ep0_dir = USB_DIR_IN;\r\nsendnulldata(ep, ep->txframe, SETUP_STATUS | NO_REQ);\r\n} else {\r\nudc->ep0_dir = USB_DIR_OUT;\r\nudc->ep0_state = WAIT_FOR_OUT_STATUS;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ep0_req_complete(struct qe_udc *udc, struct qe_req *req)\r\n{\r\nstruct qe_ep *ep = &udc->eps[0];\r\nswitch (udc->ep0_state) {\r\ncase DATA_STATE_XMIT:\r\ndone(ep, req, 0);\r\nif (ep0_prime_status(udc, USB_DIR_OUT))\r\nqe_ep0_stall(udc);\r\nbreak;\r\ncase DATA_STATE_NEED_ZLP:\r\ndone(ep, req, 0);\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase DATA_STATE_RECV:\r\ndone(ep, req, 0);\r\nif (ep0_prime_status(udc, USB_DIR_IN))\r\nqe_ep0_stall(udc);\r\nbreak;\r\ncase WAIT_FOR_OUT_STATUS:\r\ndone(ep, req, 0);\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase WAIT_FOR_SETUP:\r\ndev_vdbg(udc->dev, "Unexpected interrupt\n");\r\nbreak;\r\ndefault:\r\nqe_ep0_stall(udc);\r\nbreak;\r\n}\r\n}\r\nstatic int ep0_txcomplete(struct qe_ep *ep, unsigned char restart)\r\n{\r\nstruct qe_req *tx_req = NULL;\r\nstruct qe_frame *frame = ep->txframe;\r\nif ((frame_get_info(frame) & (ZLP | NO_REQ)) == (ZLP | NO_REQ)) {\r\nif (!restart)\r\nep->udc->ep0_state = WAIT_FOR_SETUP;\r\nelse\r\nsendnulldata(ep, ep->txframe, SETUP_STATUS | NO_REQ);\r\nreturn 0;\r\n}\r\ntx_req = ep->tx_req;\r\nif (tx_req != NULL) {\r\nif (!restart) {\r\nint asent = ep->last;\r\nep->sent += asent;\r\nep->last -= asent;\r\n} else {\r\nep->last = 0;\r\n}\r\nif ((ep->tx_req->req.length - ep->sent) <= 0) {\r\nep->tx_req->req.actual = (unsigned int)ep->sent;\r\nep0_req_complete(ep->udc, ep->tx_req);\r\nep->tx_req = NULL;\r\nep->last = 0;\r\nep->sent = 0;\r\n}\r\n} else {\r\ndev_vdbg(ep->udc->dev, "the ep0_controller have no req\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep0_txframe_handle(struct qe_ep *ep)\r\n{\r\nif (frame_get_status(ep->txframe) & FRAME_ERROR) {\r\nqe_ep_flushtxfifo(ep);\r\ndev_vdbg(ep->udc->dev, "The EP0 transmit data have error!\n");\r\nif (frame_get_info(ep->txframe) & PID_DATA0)\r\nep->data01 = 0;\r\nelse\r\nep->data01 = 1;\r\nep0_txcomplete(ep, 1);\r\n} else\r\nep0_txcomplete(ep, 0);\r\nframe_create_tx(ep, ep->txframe);\r\nreturn 0;\r\n}\r\nstatic int qe_ep0_txconf(struct qe_ep *ep)\r\n{\r\nstruct qe_bd __iomem *bd;\r\nstruct qe_frame *pframe;\r\nu32 bdstatus;\r\nbd = ep->c_txbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nwhile (!(bdstatus & T_R) && (bdstatus & ~T_W)) {\r\npframe = ep->txframe;\r\nout_be32((u32 __iomem *)bd, bdstatus & T_W);\r\nout_be32(&bd->buf, 0);\r\nif (bdstatus & T_W)\r\nep->c_txbd = ep->txbase;\r\nelse\r\nep->c_txbd++;\r\nif (ep->c_txbd == ep->n_txbd) {\r\nif (bdstatus & DEVICE_T_ERROR) {\r\nframe_set_status(pframe, FRAME_ERROR);\r\nif (bdstatus & T_TO)\r\npframe->status |= TX_ER_TIMEOUT;\r\nif (bdstatus & T_UN)\r\npframe->status |= TX_ER_UNDERUN;\r\n}\r\nep0_txframe_handle(ep);\r\n}\r\nbd = ep->c_txbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep_txframe_handle(struct qe_ep *ep)\r\n{\r\nif (frame_get_status(ep->txframe) & FRAME_ERROR) {\r\nqe_ep_flushtxfifo(ep);\r\ndev_vdbg(ep->udc->dev, "The EP0 transmit data have error!\n");\r\nif (frame_get_info(ep->txframe) & PID_DATA0)\r\nep->data01 = 0;\r\nelse\r\nep->data01 = 1;\r\ntxcomplete(ep, 1);\r\n} else\r\ntxcomplete(ep, 0);\r\nframe_create_tx(ep, ep->txframe);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_txconf(struct qe_ep *ep)\r\n{\r\nstruct qe_bd __iomem *bd;\r\nstruct qe_frame *pframe = NULL;\r\nu32 bdstatus;\r\nunsigned char breakonrxinterrupt = 0;\r\nbd = ep->c_txbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nwhile (!(bdstatus & T_R) && (bdstatus & ~T_W)) {\r\npframe = ep->txframe;\r\nif (bdstatus & DEVICE_T_ERROR) {\r\nframe_set_status(pframe, FRAME_ERROR);\r\nif (bdstatus & T_TO)\r\npframe->status |= TX_ER_TIMEOUT;\r\nif (bdstatus & T_UN)\r\npframe->status |= TX_ER_UNDERUN;\r\n}\r\nout_be32((u32 __iomem *)bd, bdstatus & T_W);\r\nout_be32(&bd->buf, 0);\r\nif (bdstatus & T_W)\r\nep->c_txbd = ep->txbase;\r\nelse\r\nep->c_txbd++;\r\nep_txframe_handle(ep);\r\nbd = ep->c_txbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\n}\r\nif (breakonrxinterrupt)\r\nreturn -EIO;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int ep_req_send(struct qe_ep *ep, struct qe_req *req)\r\n{\r\nint reval = 0;\r\nif (ep->tx_req == NULL) {\r\nep->sent = 0;\r\nep->last = 0;\r\ntxcomplete(ep, 0);\r\nreval = frame_create_tx(ep, ep->txframe);\r\n}\r\nreturn reval;\r\n}\r\nstatic int ep_req_rx(struct qe_ep *ep, struct qe_req *req)\r\n{\r\nstruct qe_udc *udc = ep->udc;\r\nstruct qe_frame *pframe = NULL;\r\nstruct qe_bd __iomem *bd;\r\nu32 bdstatus, length;\r\nu32 vaddr, fsize;\r\nu8 *cp;\r\nu8 finish_req = 0;\r\nu8 framepid;\r\nif (list_empty(&ep->queue)) {\r\ndev_vdbg(udc->dev, "the req already finish!\n");\r\nreturn 0;\r\n}\r\npframe = ep->rxframe;\r\nbd = ep->n_rxbd;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nlength = bdstatus & BD_LENGTH_MASK;\r\nwhile (!(bdstatus & R_E) && length) {\r\nif (finish_req)\r\nbreak;\r\nif ((bdstatus & R_F) && (bdstatus & R_L)\r\n&& !(bdstatus & R_ERROR)) {\r\nqe_frame_clean(pframe);\r\nvaddr = (u32)phys_to_virt(in_be32(&bd->buf));\r\nframe_set_data(pframe, (u8 *)vaddr);\r\nframe_set_length(pframe, (length - USB_CRC_SIZE));\r\nframe_set_status(pframe, FRAME_OK);\r\nswitch (bdstatus & R_PID) {\r\ncase R_PID_DATA1:\r\nframe_set_info(pframe, PID_DATA1); break;\r\ndefault:\r\nframe_set_info(pframe, PID_DATA0); break;\r\n}\r\nif (frame_get_info(pframe) & PID_DATA1)\r\nframepid = 0x1;\r\nelse\r\nframepid = 0;\r\nif (framepid != ep->data01) {\r\ndev_vdbg(udc->dev, "the data01 error!\n");\r\n} else {\r\nfsize = frame_get_length(pframe);\r\ncp = (u8 *)(req->req.buf) + req->req.actual;\r\nif (cp) {\r\nmemcpy(cp, pframe->data, fsize);\r\nreq->req.actual += fsize;\r\nif ((fsize < ep->ep.maxpacket)\r\n|| (req->req.actual >=\r\nreq->req.length)) {\r\nfinish_req = 1;\r\ndone(ep, req, 0);\r\nif (list_empty(&ep->queue))\r\nqe_eprx_nack(ep);\r\n}\r\n}\r\nqe_ep_toggledata01(ep);\r\n}\r\n} else {\r\ndev_err(udc->dev, "The receive frame with error!\n");\r\n}\r\nout_be32((u32 __iomem *)bd, (bdstatus & BD_STATUS_MASK));\r\nep->has_data--;\r\nif (bdstatus & R_W)\r\nbd = ep->rxbase;\r\nelse\r\nbd++;\r\nbdstatus = in_be32((u32 __iomem *)bd);\r\nlength = bdstatus & BD_LENGTH_MASK;\r\n}\r\nep->n_rxbd = bd;\r\nep_recycle_rxbds(ep);\r\nreturn 0;\r\n}\r\nstatic int ep_req_receive(struct qe_ep *ep, struct qe_req *req)\r\n{\r\nif (ep->state == EP_STATE_NACK) {\r\nif (ep->has_data <= 0) {\r\nqe_eprx_normal(ep);\r\n} else {\r\nep_req_rx(ep, req);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qe_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct qe_udc *udc;\r\nstruct qe_ep *ep;\r\nint retval = 0;\r\nunsigned char epnum;\r\nep = container_of(_ep, struct qe_ep, ep);\r\nif (!_ep || !desc || _ep->name == ep_name[0] ||\r\n(desc->bDescriptorType != USB_DT_ENDPOINT))\r\nreturn -EINVAL;\r\nudc = ep->udc;\r\nif (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))\r\nreturn -ESHUTDOWN;\r\nepnum = (u8)desc->bEndpointAddress & 0xF;\r\nretval = qe_ep_init(udc, epnum, desc);\r\nif (retval != 0) {\r\ncpm_muram_free(cpm_muram_offset(ep->rxbase));\r\ndev_dbg(udc->dev, "enable ep%d failed\n", ep->epnum);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(udc->dev, "enable ep%d successful\n", ep->epnum);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct qe_udc *udc;\r\nstruct qe_ep *ep;\r\nunsigned long flags;\r\nunsigned int size;\r\nep = container_of(_ep, struct qe_ep, ep);\r\nudc = ep->udc;\r\nif (!_ep || !ep->ep.desc) {\r\ndev_dbg(udc->dev, "%s not enabled\n", _ep ? ep->ep.name : NULL);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nnuke(ep, -ESHUTDOWN);\r\nep->ep.desc = NULL;\r\nep->stopped = 1;\r\nep->tx_req = NULL;\r\nqe_ep_reset(udc, ep->epnum);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ncpm_muram_free(cpm_muram_offset(ep->rxbase));\r\nif (ep->dir == USB_DIR_OUT)\r\nsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) *\r\n(USB_BDRING_LEN_RX + 1);\r\nelse\r\nsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) *\r\n(USB_BDRING_LEN + 1);\r\nif (ep->dir != USB_DIR_IN) {\r\nkfree(ep->rxframe);\r\nif (ep->rxbufmap) {\r\ndma_unmap_single(udc->gadget.dev.parent,\r\nep->rxbuf_d, size,\r\nDMA_FROM_DEVICE);\r\nep->rxbuf_d = DMA_ADDR_INVALID;\r\n} else {\r\ndma_sync_single_for_cpu(\r\nudc->gadget.dev.parent,\r\nep->rxbuf_d, size,\r\nDMA_FROM_DEVICE);\r\n}\r\nkfree(ep->rxbuffer);\r\n}\r\nif (ep->dir != USB_DIR_OUT)\r\nkfree(ep->txframe);\r\ndev_dbg(udc->dev, "disabled %s OK\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *qe_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct qe_req *req;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nreq->req.dma = DMA_ADDR_INVALID;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void qe_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct qe_req *req;\r\nreq = container_of(_req, struct qe_req, req);\r\nif (_req)\r\nkfree(req);\r\n}\r\nstatic int __qe_ep_queue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct qe_ep *ep = container_of(_ep, struct qe_ep, ep);\r\nstruct qe_req *req = container_of(_req, struct qe_req, req);\r\nstruct qe_udc *udc;\r\nint reval;\r\nudc = ep->udc;\r\nif (!_req || !req->req.complete || !req->req.buf\r\n|| !list_empty(&req->queue)) {\r\ndev_dbg(udc->dev, "bad params\n");\r\nreturn -EINVAL;\r\n}\r\nif (!_ep || (!ep->ep.desc && ep_index(ep))) {\r\ndev_dbg(udc->dev, "bad ep\n");\r\nreturn -EINVAL;\r\n}\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nreq->ep = ep;\r\nif (req->req.dma == DMA_ADDR_INVALID) {\r\nreq->req.dma = dma_map_single(ep->udc->gadget.dev.parent,\r\nreq->req.buf,\r\nreq->req.length,\r\nep_is_in(ep)\r\n? DMA_TO_DEVICE :\r\nDMA_FROM_DEVICE);\r\nreq->mapped = 1;\r\n} else {\r\ndma_sync_single_for_device(ep->udc->gadget.dev.parent,\r\nreq->req.dma, req->req.length,\r\nep_is_in(ep)\r\n? DMA_TO_DEVICE :\r\nDMA_FROM_DEVICE);\r\nreq->mapped = 0;\r\n}\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nlist_add_tail(&req->queue, &ep->queue);\r\ndev_vdbg(udc->dev, "gadget have request in %s! %d\n",\r\nep->name, req->req.length);\r\nif (ep_is_in(ep))\r\nreval = ep_req_send(ep, req);\r\nif (ep_index(ep) == 0 && req->req.length > 0) {\r\nif (ep_is_in(ep))\r\nudc->ep0_state = DATA_STATE_XMIT;\r\nelse\r\nudc->ep0_state = DATA_STATE_RECV;\r\n}\r\nif (ep->dir == USB_DIR_OUT)\r\nreval = ep_req_receive(ep, req);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct qe_ep *ep = container_of(_ep, struct qe_ep, ep);\r\nstruct qe_udc *udc = ep->udc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nret = __qe_ep_queue(_ep, _req);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int qe_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct qe_ep *ep = container_of(_ep, struct qe_ep, ep);\r\nstruct qe_req *req;\r\nunsigned long flags;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ndone(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct qe_ep *ep;\r\nunsigned long flags;\r\nint status = -EOPNOTSUPP;\r\nstruct qe_udc *udc;\r\nep = container_of(_ep, struct qe_ep, ep);\r\nif (!_ep || !ep->ep.desc) {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nudc = ep->udc;\r\nif (value && ep_is_in(ep) && !list_empty(&ep->queue)) {\r\nstatus = -EAGAIN;\r\ngoto out;\r\n}\r\nstatus = 0;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nqe_eptx_stall_change(ep, value);\r\nqe_eprx_stall_change(ep, value);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nif (ep->epnum == 0) {\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = 0;\r\n}\r\nif (value == 0)\r\nep->data01 = 0;\r\nout:\r\ndev_vdbg(udc->dev, "%s %s halt stat %d\n", ep->ep.name,\r\nvalue ? "set" : "clear", status);\r\nreturn status;\r\n}\r\nstatic int qe_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct qe_udc *udc = container_of(gadget, struct qe_udc, gadget);\r\nu16 tmp;\r\ntmp = in_be16(&udc->usb_param->frame_n);\r\nif (tmp & 0x8000)\r\ntmp = tmp & 0x07ff;\r\nelse\r\ntmp = -EINVAL;\r\nreturn (int)tmp;\r\n}\r\nstatic int udc_reset_ep_queue(struct qe_udc *udc, u8 pipe)\r\n{\r\nstruct qe_ep *ep = &udc->eps[pipe];\r\nnuke(ep, -ECONNRESET);\r\nep->tx_req = NULL;\r\nreturn 0;\r\n}\r\nstatic int reset_queues(struct qe_udc *udc)\r\n{\r\nu8 pipe;\r\nfor (pipe = 0; pipe < USB_MAX_ENDPOINTS; pipe++)\r\nudc_reset_ep_queue(udc, pipe);\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\nreturn 0;\r\n}\r\nstatic void ch9setaddress(struct qe_udc *udc, u16 value, u16 index,\r\nu16 length)\r\n{\r\nudc->device_address = (u8) value;\r\nudc->usb_state = USB_STATE_ADDRESS;\r\nif (ep0_prime_status(udc, USB_DIR_IN))\r\nqe_ep0_stall(udc);\r\n}\r\nstatic void ownercomplete(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct qe_req *req = container_of(_req, struct qe_req, req);\r\nreq->req.buf = NULL;\r\nkfree(req);\r\n}\r\nstatic void ch9getstatus(struct qe_udc *udc, u8 request_type, u16 value,\r\nu16 index, u16 length)\r\n{\r\nu16 usb_status = 0;\r\nstruct qe_req *req;\r\nstruct qe_ep *ep;\r\nint status = 0;\r\nep = &udc->eps[0];\r\nif ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\r\nusb_status = 1 << USB_DEVICE_SELF_POWERED;\r\n} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {\r\nusb_status = 0;\r\n} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {\r\nint pipe = index & USB_ENDPOINT_NUMBER_MASK;\r\nstruct qe_ep *target_ep = &udc->eps[pipe];\r\nu16 usep;\r\nif (!target_ep->ep.desc)\r\ngoto stall;\r\nusep = in_be16(&udc->usb_regs->usb_usep[pipe]);\r\nif (index & USB_DIR_IN) {\r\nif (target_ep->dir != USB_DIR_IN)\r\ngoto stall;\r\nif ((usep & USB_THS_MASK) == USB_THS_STALL)\r\nusb_status = 1 << USB_ENDPOINT_HALT;\r\n} else {\r\nif (target_ep->dir != USB_DIR_OUT)\r\ngoto stall;\r\nif ((usep & USB_RHS_MASK) == USB_RHS_STALL)\r\nusb_status = 1 << USB_ENDPOINT_HALT;\r\n}\r\n}\r\nreq = container_of(qe_alloc_request(&ep->ep, GFP_KERNEL),\r\nstruct qe_req, req);\r\nreq->req.length = 2;\r\nreq->req.buf = udc->statusbuf;\r\n*(u16 *)req->req.buf = cpu_to_le16(usb_status);\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nreq->req.complete = ownercomplete;\r\nudc->ep0_dir = USB_DIR_IN;\r\nstatus = __qe_ep_queue(&ep->ep, &req->req);\r\nif (status == 0)\r\nreturn;\r\nstall:\r\ndev_err(udc->dev, "Can't respond to getstatus request \n");\r\nqe_ep0_stall(udc);\r\n}\r\nstatic void setup_received_handle(struct qe_udc *udc,\r\nstruct usb_ctrlrequest *setup)\r\n{\r\nu16 wValue = le16_to_cpu(setup->wValue);\r\nu16 wIndex = le16_to_cpu(setup->wIndex);\r\nu16 wLength = le16_to_cpu(setup->wLength);\r\nudc_reset_ep_queue(udc, 0);\r\nif (setup->bRequestType & USB_DIR_IN)\r\nudc->ep0_dir = USB_DIR_IN;\r\nelse\r\nudc->ep0_dir = USB_DIR_OUT;\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nif ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))\r\n!= (USB_DIR_IN | USB_TYPE_STANDARD))\r\nbreak;\r\nch9getstatus(udc, setup->bRequestType, wValue, wIndex,\r\nwLength);\r\nreturn;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD |\r\nUSB_RECIP_DEVICE))\r\nbreak;\r\nch9setaddress(udc, wValue, wIndex, wLength);\r\nreturn;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nif ((setup->bRequestType & USB_TYPE_MASK)\r\n!= USB_TYPE_STANDARD)\r\nbreak;\r\nif ((setup->bRequestType & USB_RECIP_MASK)\r\n== USB_RECIP_ENDPOINT) {\r\nint pipe = wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nstruct qe_ep *ep;\r\nif (wValue != 0 || wLength != 0\r\n|| pipe > USB_MAX_ENDPOINTS)\r\nbreak;\r\nep = &udc->eps[pipe];\r\nspin_unlock(&udc->lock);\r\nqe_ep_set_halt(&ep->ep,\r\n(setup->bRequest == USB_REQ_SET_FEATURE)\r\n? 1 : 0);\r\nspin_lock(&udc->lock);\r\n}\r\nep0_prime_status(udc, USB_DIR_IN);\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nif (wLength) {\r\nif (setup->bRequestType & USB_DIR_IN) {\r\nudc->ep0_state = DATA_STATE_XMIT;\r\nudc->ep0_dir = USB_DIR_IN;\r\n} else {\r\nudc->ep0_state = DATA_STATE_RECV;\r\nudc->ep0_dir = USB_DIR_OUT;\r\n}\r\nspin_unlock(&udc->lock);\r\nif (udc->driver->setup(&udc->gadget,\r\n&udc->local_setup_buff) < 0)\r\nqe_ep0_stall(udc);\r\nspin_lock(&udc->lock);\r\n} else {\r\nudc->ep0_dir = USB_DIR_IN;\r\nspin_unlock(&udc->lock);\r\nif (udc->driver->setup(&udc->gadget,\r\n&udc->local_setup_buff) < 0)\r\nqe_ep0_stall(udc);\r\nspin_lock(&udc->lock);\r\nudc->ep0_state = DATA_STATE_NEED_ZLP;\r\n}\r\n}\r\nstatic void suspend_irq(struct qe_udc *udc)\r\n{\r\nudc->resume_state = udc->usb_state;\r\nudc->usb_state = USB_STATE_SUSPENDED;\r\nif (udc->driver->suspend)\r\nudc->driver->suspend(&udc->gadget);\r\n}\r\nstatic void resume_irq(struct qe_udc *udc)\r\n{\r\nudc->usb_state = udc->resume_state;\r\nudc->resume_state = 0;\r\nif (udc->driver->resume)\r\nudc->driver->resume(&udc->gadget);\r\n}\r\nstatic void idle_irq(struct qe_udc *udc)\r\n{\r\nu8 usbs;\r\nusbs = in_8(&udc->usb_regs->usb_usbs);\r\nif (usbs & USB_IDLE_STATUS_MASK) {\r\nif ((udc->usb_state) != USB_STATE_SUSPENDED)\r\nsuspend_irq(udc);\r\n} else {\r\nif (udc->usb_state == USB_STATE_SUSPENDED)\r\nresume_irq(udc);\r\n}\r\n}\r\nstatic int reset_irq(struct qe_udc *udc)\r\n{\r\nunsigned char i;\r\nif (udc->usb_state == USB_STATE_DEFAULT)\r\nreturn 0;\r\nqe_usb_disable(udc);\r\nout_8(&udc->usb_regs->usb_usadr, 0);\r\nfor (i = 0; i < USB_MAX_ENDPOINTS; i++) {\r\nif (udc->eps[i].init)\r\nqe_ep_reset(udc, i);\r\n}\r\nreset_queues(udc);\r\nudc->usb_state = USB_STATE_DEFAULT;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = USB_DIR_OUT;\r\nqe_usb_enable(udc);\r\nreturn 0;\r\n}\r\nstatic int bsy_irq(struct qe_udc *udc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int txe_irq(struct qe_udc *udc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tx_irq(struct qe_udc *udc)\r\n{\r\nstruct qe_ep *ep;\r\nstruct qe_bd __iomem *bd;\r\nint i, res = 0;\r\nif ((udc->usb_state == USB_STATE_ADDRESS)\r\n&& (in_8(&udc->usb_regs->usb_usadr) == 0))\r\nout_8(&udc->usb_regs->usb_usadr, udc->device_address);\r\nfor (i = (USB_MAX_ENDPOINTS-1); ((i >= 0) && (res == 0)); i--) {\r\nep = &udc->eps[i];\r\nif (ep && ep->init && (ep->dir != USB_DIR_OUT)) {\r\nbd = ep->c_txbd;\r\nif (!(in_be32((u32 __iomem *)bd) & T_R)\r\n&& (in_be32(&bd->buf))) {\r\nif (ep->epnum == 0)\r\nres = qe_ep0_txconf(ep);\r\nelse\r\nres = qe_ep_txconf(ep);\r\n}\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic void rx_irq(struct qe_udc *udc)\r\n{\r\nstruct qe_ep *ep;\r\nstruct qe_bd __iomem *bd;\r\nint i;\r\nfor (i = 0; i < USB_MAX_ENDPOINTS; i++) {\r\nep = &udc->eps[i];\r\nif (ep && ep->init && (ep->dir != USB_DIR_IN)) {\r\nbd = ep->n_rxbd;\r\nif (!(in_be32((u32 __iomem *)bd) & R_E)\r\n&& (in_be32(&bd->buf))) {\r\nif (ep->epnum == 0) {\r\nqe_ep0_rx(udc);\r\n} else {\r\nqe_ep_rx(ep);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t qe_udc_irq(int irq, void *_udc)\r\n{\r\nstruct qe_udc *udc = (struct qe_udc *)_udc;\r\nu16 irq_src;\r\nirqreturn_t status = IRQ_NONE;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nirq_src = in_be16(&udc->usb_regs->usb_usber) &\r\nin_be16(&udc->usb_regs->usb_usbmr);\r\nout_be16(&udc->usb_regs->usb_usber, irq_src);\r\nif (irq_src & USB_E_IDLE_MASK) {\r\nidle_irq(udc);\r\nirq_src &= ~USB_E_IDLE_MASK;\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_E_TXB_MASK) {\r\ntx_irq(udc);\r\nirq_src &= ~USB_E_TXB_MASK;\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_E_RXB_MASK) {\r\nrx_irq(udc);\r\nirq_src &= ~USB_E_RXB_MASK;\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_E_RESET_MASK) {\r\nreset_irq(udc);\r\nirq_src &= ~USB_E_RESET_MASK;\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_E_BSY_MASK) {\r\nbsy_irq(udc);\r\nirq_src &= ~USB_E_BSY_MASK;\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (irq_src & USB_E_TXE_MASK) {\r\ntxe_irq(udc);\r\nirq_src &= ~USB_E_TXE_MASK;\r\nstatus = IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic int fsl_qe_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct qe_udc *udc;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct qe_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\ndriver->driver.bus = NULL;\r\nudc->driver = driver;\r\nudc->gadget.speed = driver->max_speed;\r\nqe_usb_enable(udc);\r\nout_be16(&udc->usb_regs->usb_usber, 0xffff);\r\nout_be16(&udc->usb_regs->usb_usbmr, USB_E_DEFAULT_DEVICE);\r\nudc->usb_state = USB_STATE_ATTACHED;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = USB_DIR_OUT;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ndev_info(udc->dev, "%s bind to driver %s\n", udc->gadget.name,\r\ndriver->driver.name);\r\nreturn 0;\r\n}\r\nstatic int fsl_qe_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct qe_udc *udc;\r\nstruct qe_ep *loop_ep;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct qe_udc, gadget);\r\nqe_usb_disable(udc);\r\nudc->usb_state = USB_STATE_ATTACHED;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = 0;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nnuke(&udc->eps[0], -ESHUTDOWN);\r\nlist_for_each_entry(loop_ep, &udc->gadget.ep_list, ep.ep_list)\r\nnuke(loop_ep, -ESHUTDOWN);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nudc->driver = NULL;\r\ndev_info(udc->dev, "unregistered gadget driver '%s'\r\n",\r\ndriver->driver.name);\r\nreturn 0;\r\n}\r\nstatic struct qe_udc *qe_udc_config(struct platform_device *ofdev)\r\n{\r\nstruct qe_udc *udc;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nunsigned int tmp_addr = 0;\r\nstruct usb_device_para __iomem *usbpram;\r\nunsigned int i;\r\nu64 size;\r\nu32 offset;\r\nudc = kzalloc(sizeof(*udc), GFP_KERNEL);\r\nif (udc == NULL) {\r\ndev_err(&ofdev->dev, "malloc udc failed\n");\r\ngoto cleanup;\r\n}\r\nudc->dev = &ofdev->dev;\r\noffset = *of_get_address(np, 1, &size, NULL);\r\nudc->usb_param = cpm_muram_addr(offset);\r\nmemset_io(udc->usb_param, 0, size);\r\nusbpram = udc->usb_param;\r\nout_be16(&usbpram->frame_n, 0);\r\nout_be32(&usbpram->rstate, 0);\r\ntmp_addr = cpm_muram_alloc((USB_MAX_ENDPOINTS *\r\nsizeof(struct usb_ep_para)),\r\nUSB_EP_PARA_ALIGNMENT);\r\nif (IS_ERR_VALUE(tmp_addr))\r\ngoto cleanup;\r\nfor (i = 0; i < USB_MAX_ENDPOINTS; i++) {\r\nout_be16(&usbpram->epptr[i], (u16)tmp_addr);\r\nudc->ep_param[i] = cpm_muram_addr(tmp_addr);\r\ntmp_addr += 32;\r\n}\r\nmemset_io(udc->ep_param[0], 0,\r\nUSB_MAX_ENDPOINTS * sizeof(struct usb_ep_para));\r\nudc->resume_state = USB_STATE_NOTATTACHED;\r\nudc->usb_state = USB_STATE_POWERED;\r\nudc->ep0_dir = 0;\r\nspin_lock_init(&udc->lock);\r\nreturn udc;\r\ncleanup:\r\nkfree(udc);\r\nreturn NULL;\r\n}\r\nstatic int qe_udc_reg_init(struct qe_udc *udc)\r\n{\r\nstruct usb_ctlr __iomem *qe_usbregs;\r\nqe_usbregs = udc->usb_regs;\r\nout_8(&qe_usbregs->usb_usmod, 0x01);\r\nout_8(&qe_usbregs->usb_usmod, 0x00);\r\nout_be16(&qe_usbregs->usb_usbmr, 0);\r\nout_8(&qe_usbregs->usb_uscom, 0);\r\nout_be16(&qe_usbregs->usb_usber, USBER_ALL_CLEAR);\r\nreturn 0;\r\n}\r\nstatic int qe_ep_config(struct qe_udc *udc, unsigned char pipe_num)\r\n{\r\nstruct qe_ep *ep = &udc->eps[pipe_num];\r\nep->udc = udc;\r\nstrcpy(ep->name, ep_name[pipe_num]);\r\nep->ep.name = ep_name[pipe_num];\r\nep->ep.ops = &qe_ep_ops;\r\nep->stopped = 1;\r\nep->ep.maxpacket = (unsigned short) ~0;\r\nep->ep.desc = NULL;\r\nep->dir = 0xff;\r\nep->epnum = (u8)pipe_num;\r\nep->sent = 0;\r\nep->last = 0;\r\nep->init = 0;\r\nep->rxframe = NULL;\r\nep->txframe = NULL;\r\nep->tx_req = NULL;\r\nep->state = EP_STATE_IDLE;\r\nep->has_data = 0;\r\nINIT_LIST_HEAD(&ep->queue);\r\nif (pipe_num != 0)\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nep->gadget = &udc->gadget;\r\nreturn 0;\r\n}\r\nstatic void qe_udc_release(struct device *dev)\r\n{\r\nstruct qe_udc *udc = container_of(dev, struct qe_udc, gadget.dev);\r\nint i;\r\ncomplete(udc->done);\r\ncpm_muram_free(cpm_muram_offset(udc->ep_param[0]));\r\nfor (i = 0; i < USB_MAX_ENDPOINTS; i++)\r\nudc->ep_param[i] = NULL;\r\nkfree(udc);\r\n}\r\nstatic int qe_udc_probe(struct platform_device *ofdev)\r\n{\r\nstruct qe_udc *udc;\r\nconst struct of_device_id *match;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct qe_ep *ep;\r\nunsigned int ret = 0;\r\nunsigned int i;\r\nconst void *prop;\r\nmatch = of_match_device(qe_udc_match, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nprop = of_get_property(np, "mode", NULL);\r\nif (!prop || strcmp(prop, "peripheral"))\r\nreturn -ENODEV;\r\nudc = qe_udc_config(ofdev);\r\nif (!udc) {\r\ndev_err(&ofdev->dev, "failed to initialize\n");\r\nreturn -ENOMEM;\r\n}\r\nudc->soc_type = (unsigned long)match->data;\r\nudc->usb_regs = of_iomap(np, 0);\r\nif (!udc->usb_regs) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nqe_udc_reg_init(udc);\r\nudc->gadget.ops = &qe_gadget_ops;\r\nudc->gadget.ep0 = &udc->eps[0].ep;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->gadget.name = driver_name;\r\nudc->gadget.dev.parent = &ofdev->dev;\r\nfor (i = 0; i < USB_MAX_ENDPOINTS ; i++) {\r\nqe_ep_config(udc, (unsigned char)i);\r\n}\r\nret = qe_ep_init(udc, 0, &qe_ep0_desc);\r\nif (ret)\r\ngoto err2;\r\nudc->nullbuf = kzalloc(256, GFP_KERNEL);\r\nif (udc->nullbuf == NULL) {\r\ndev_err(udc->dev, "cannot alloc nullbuf\n");\r\nret = -ENOMEM;\r\ngoto err3;\r\n}\r\nudc->statusbuf = kzalloc(2, GFP_KERNEL);\r\nif (udc->statusbuf == NULL) {\r\nret = -ENOMEM;\r\ngoto err4;\r\n}\r\nudc->nullp = virt_to_phys((void *)udc->nullbuf);\r\nif (udc->nullp == DMA_ADDR_INVALID) {\r\nudc->nullp = dma_map_single(\r\nudc->gadget.dev.parent,\r\nudc->nullbuf,\r\n256,\r\nDMA_TO_DEVICE);\r\nudc->nullmap = 1;\r\n} else {\r\ndma_sync_single_for_device(udc->gadget.dev.parent,\r\nudc->nullp, 256,\r\nDMA_TO_DEVICE);\r\n}\r\ntasklet_init(&udc->rx_tasklet, ep_rx_tasklet,\r\n(unsigned long)udc);\r\nudc->usb_irq = irq_of_parse_and_map(np, 0);\r\nif (!udc->usb_irq) {\r\nret = -EINVAL;\r\ngoto err_noirq;\r\n}\r\nret = request_irq(udc->usb_irq, qe_udc_irq, 0,\r\ndriver_name, udc);\r\nif (ret) {\r\ndev_err(udc->dev, "cannot request irq %d err %d\n",\r\nudc->usb_irq, ret);\r\ngoto err5;\r\n}\r\nret = usb_add_gadget_udc_release(&ofdev->dev, &udc->gadget,\r\nqe_udc_release);\r\nif (ret)\r\ngoto err6;\r\nplatform_set_drvdata(ofdev, udc);\r\ndev_info(udc->dev,\r\n"%s USB controller initialized as device\n",\r\n(udc->soc_type == PORT_QE) ? "QE" : "CPM");\r\nreturn 0;\r\nerr6:\r\nfree_irq(udc->usb_irq, udc);\r\nerr5:\r\nirq_dispose_mapping(udc->usb_irq);\r\nerr_noirq:\r\nif (udc->nullmap) {\r\ndma_unmap_single(udc->gadget.dev.parent,\r\nudc->nullp, 256,\r\nDMA_TO_DEVICE);\r\nudc->nullp = DMA_ADDR_INVALID;\r\n} else {\r\ndma_sync_single_for_cpu(udc->gadget.dev.parent,\r\nudc->nullp, 256,\r\nDMA_TO_DEVICE);\r\n}\r\nkfree(udc->statusbuf);\r\nerr4:\r\nkfree(udc->nullbuf);\r\nerr3:\r\nep = &udc->eps[0];\r\ncpm_muram_free(cpm_muram_offset(ep->rxbase));\r\nkfree(ep->rxframe);\r\nkfree(ep->rxbuffer);\r\nkfree(ep->txframe);\r\nerr2:\r\niounmap(udc->usb_regs);\r\nerr1:\r\nkfree(udc);\r\nreturn ret;\r\n}\r\nstatic int qe_udc_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int qe_udc_resume(struct platform_device *dev)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int qe_udc_remove(struct platform_device *ofdev)\r\n{\r\nstruct qe_udc *udc = platform_get_drvdata(ofdev);\r\nstruct qe_ep *ep;\r\nunsigned int size;\r\nDECLARE_COMPLETION(done);\r\nusb_del_gadget_udc(&udc->gadget);\r\nudc->done = &done;\r\ntasklet_disable(&udc->rx_tasklet);\r\nif (udc->nullmap) {\r\ndma_unmap_single(udc->gadget.dev.parent,\r\nudc->nullp, 256,\r\nDMA_TO_DEVICE);\r\nudc->nullp = DMA_ADDR_INVALID;\r\n} else {\r\ndma_sync_single_for_cpu(udc->gadget.dev.parent,\r\nudc->nullp, 256,\r\nDMA_TO_DEVICE);\r\n}\r\nkfree(udc->statusbuf);\r\nkfree(udc->nullbuf);\r\nep = &udc->eps[0];\r\ncpm_muram_free(cpm_muram_offset(ep->rxbase));\r\nsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) * (USB_BDRING_LEN + 1);\r\nkfree(ep->rxframe);\r\nif (ep->rxbufmap) {\r\ndma_unmap_single(udc->gadget.dev.parent,\r\nep->rxbuf_d, size,\r\nDMA_FROM_DEVICE);\r\nep->rxbuf_d = DMA_ADDR_INVALID;\r\n} else {\r\ndma_sync_single_for_cpu(udc->gadget.dev.parent,\r\nep->rxbuf_d, size,\r\nDMA_FROM_DEVICE);\r\n}\r\nkfree(ep->rxbuffer);\r\nkfree(ep->txframe);\r\nfree_irq(udc->usb_irq, udc);\r\nirq_dispose_mapping(udc->usb_irq);\r\ntasklet_kill(&udc->rx_tasklet);\r\niounmap(udc->usb_regs);\r\nwait_for_completion(&done);\r\nreturn 0;\r\n}
