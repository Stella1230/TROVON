static u16 dib0090_read_reg(struct dib0090_state *state, u8 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nstate->i2c_write_buffer[0] = reg;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->config->i2c_address;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 1;\r\nstate->msg[1].addr = state->config->i2c_address;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c, state->msg, 2) != 2) {\r\nprintk(KERN_WARNING "DiB0090 I2C read failed\n");\r\nret = 0;\r\n} else\r\nret = (state->i2c_read_buffer[0] << 8)\r\n| state->i2c_read_buffer[1];\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib0090_write_reg(struct dib0090_state *state, u32 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = reg & 0xff;\r\nstate->i2c_write_buffer[1] = val >> 8;\r\nstate->i2c_write_buffer[2] = val & 0xff;\r\nmemset(state->msg, 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->config->i2c_address;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 3;\r\nif (i2c_transfer(state->i2c, state->msg, 1) != 1) {\r\nprintk(KERN_WARNING "DiB0090 I2C write failed\n");\r\nret = -EREMOTEIO;\r\n} else\r\nret = 0;\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u16 dib0090_fw_read_reg(struct dib0090_fw_state *state, u8 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nstate->i2c_write_buffer[0] = reg;\r\nmemset(&state->msg, 0, sizeof(struct i2c_msg));\r\nstate->msg.addr = reg;\r\nstate->msg.flags = I2C_M_RD;\r\nstate->msg.buf = state->i2c_read_buffer;\r\nstate->msg.len = 2;\r\nif (i2c_transfer(state->i2c, &state->msg, 1) != 1) {\r\nprintk(KERN_WARNING "DiB0090 I2C read failed\n");\r\nret = 0;\r\n} else\r\nret = (state->i2c_read_buffer[0] << 8)\r\n| state->i2c_read_buffer[1];\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib0090_fw_write_reg(struct dib0090_fw_state *state, u8 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = val >> 8;\r\nstate->i2c_write_buffer[1] = val & 0xff;\r\nmemset(&state->msg, 0, sizeof(struct i2c_msg));\r\nstate->msg.addr = reg;\r\nstate->msg.flags = 0;\r\nstate->msg.buf = state->i2c_write_buffer;\r\nstate->msg.len = 2;\r\nif (i2c_transfer(state->i2c, &state->msg, 1) != 1) {\r\nprintk(KERN_WARNING "DiB0090 I2C write failed\n");\r\nret = -EREMOTEIO;\r\n} else\r\nret = 0;\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic void dib0090_write_regs(struct dib0090_state *state, u8 r, const u16 * b, u8 c)\r\n{\r\ndo {\r\ndib0090_write_reg(state, r++, *b++);\r\n} while (--c);\r\n}\r\nstatic int dib0090_identify(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nu16 v;\r\nstruct dib0090_identity *identity = &state->identity;\r\nv = dib0090_read_reg(state, 0x1a);\r\nidentity->p1g = 0;\r\nidentity->in_soc = 0;\r\ndprintk("Tuner identification (Version = 0x%04x)", v);\r\nv &= ~KROSUS_PLL_LOCKED;\r\nidentity->version = v & 0xff;\r\nidentity->product = (v >> 8) & 0xf;\r\nif (identity->product != KROSUS)\r\ngoto identification_error;\r\nif ((identity->version & 0x3) == SOC) {\r\nidentity->in_soc = 1;\r\nswitch (identity->version) {\r\ncase SOC_8090_P1G_11R1:\r\ndprintk("SOC 8090 P1-G11R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase SOC_8090_P1G_21R1:\r\ndprintk("SOC 8090 P1-G21R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase SOC_7090_P1G_11R1:\r\ndprintk("SOC 7090 P1-G11R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase SOC_7090_P1G_21R1:\r\ndprintk("SOC 7090 P1-G21R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ndefault:\r\ngoto identification_error;\r\n}\r\n} else {\r\nswitch ((identity->version >> 5) & 0x7) {\r\ncase MP001:\r\ndprintk("MP001 : 9090/8096");\r\nbreak;\r\ncase MP005:\r\ndprintk("MP005 : Single Sband");\r\nbreak;\r\ncase MP008:\r\ndprintk("MP008 : diversity VHF-UHF-LBAND");\r\nbreak;\r\ncase MP009:\r\ndprintk("MP009 : diversity 29098 CBAND-UHF-LBAND-SBAND");\r\nbreak;\r\ndefault:\r\ngoto identification_error;\r\n}\r\nswitch (identity->version & 0x1f) {\r\ncase P1G_21R2:\r\ndprintk("P1G_21R2 detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase P1G:\r\ndprintk("P1G detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase P1D_E_F:\r\ndprintk("P1D/E/F detected");\r\nbreak;\r\ncase P1C:\r\ndprintk("P1C detected");\r\nbreak;\r\ncase P1A_B:\r\ndprintk("P1-A/B detected: driver is deactivated - not available");\r\ngoto identification_error;\r\nbreak;\r\ndefault:\r\ngoto identification_error;\r\n}\r\n}\r\nreturn 0;\r\nidentification_error:\r\nreturn -EIO;\r\n}\r\nstatic int dib0090_fw_identify(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_fw_state *state = fe->tuner_priv;\r\nstruct dib0090_identity *identity = &state->identity;\r\nu16 v = dib0090_fw_read_reg(state, 0x1a);\r\nidentity->p1g = 0;\r\nidentity->in_soc = 0;\r\ndprintk("FE: Tuner identification (Version = 0x%04x)", v);\r\nv &= ~KROSUS_PLL_LOCKED;\r\nidentity->version = v & 0xff;\r\nidentity->product = (v >> 8) & 0xf;\r\nif (identity->product != KROSUS)\r\ngoto identification_error;\r\nif ((identity->version & 0x3) == SOC) {\r\nidentity->in_soc = 1;\r\nswitch (identity->version) {\r\ncase SOC_8090_P1G_11R1:\r\ndprintk("SOC 8090 P1-G11R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase SOC_8090_P1G_21R1:\r\ndprintk("SOC 8090 P1-G21R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase SOC_7090_P1G_11R1:\r\ndprintk("SOC 7090 P1-G11R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase SOC_7090_P1G_21R1:\r\ndprintk("SOC 7090 P1-G21R1 Has been detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ndefault:\r\ngoto identification_error;\r\n}\r\n} else {\r\nswitch ((identity->version >> 5) & 0x7) {\r\ncase MP001:\r\ndprintk("MP001 : 9090/8096");\r\nbreak;\r\ncase MP005:\r\ndprintk("MP005 : Single Sband");\r\nbreak;\r\ncase MP008:\r\ndprintk("MP008 : diversity VHF-UHF-LBAND");\r\nbreak;\r\ncase MP009:\r\ndprintk("MP009 : diversity 29098 CBAND-UHF-LBAND-SBAND");\r\nbreak;\r\ndefault:\r\ngoto identification_error;\r\n}\r\nswitch (identity->version & 0x1f) {\r\ncase P1G_21R2:\r\ndprintk("P1G_21R2 detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase P1G:\r\ndprintk("P1G detected");\r\nidentity->p1g = 1;\r\nbreak;\r\ncase P1D_E_F:\r\ndprintk("P1D/E/F detected");\r\nbreak;\r\ncase P1C:\r\ndprintk("P1C detected");\r\nbreak;\r\ncase P1A_B:\r\ndprintk("P1-A/B detected: driver is deactivated - not available");\r\ngoto identification_error;\r\nbreak;\r\ndefault:\r\ngoto identification_error;\r\n}\r\n}\r\nreturn 0;\r\nidentification_error:\r\nreturn -EIO;\r\n}\r\nstatic void dib0090_reset_digital(struct dvb_frontend *fe, const struct dib0090_config *cfg)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nu16 PllCfg, i, v;\r\nHARD_RESET(state);\r\ndib0090_write_reg(state, 0x24, EN_PLL | EN_CRYSTAL);\r\nif (cfg->in_soc)\r\nreturn;\r\ndib0090_write_reg(state, 0x1b, EN_DIGCLK | EN_PLL | EN_CRYSTAL);\r\ndib0090_write_reg(state, 0x20, ((cfg->io.adc_clock_ratio - 1) << 11) | (0 << 10) | (1 << 9) | (1 << 8) | (0 << 4) | 0);\r\nif (cfg->clkoutdrive != 0)\r\ndib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)\r\n| (cfg->clkoutdrive << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));\r\nelse\r\ndib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)\r\n| (7 << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));\r\nPllCfg = dib0090_read_reg(state, 0x21);\r\nif ((PllCfg & 0x1FFF) != ((cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv)) && (!cfg->in_soc)\r\n&& !cfg->io.pll_bypass) {\r\nPllCfg |= (1 << 15);\r\ndib0090_write_reg(state, 0x21, PllCfg);\r\nPllCfg &= ~(1 << 13);\r\ndib0090_write_reg(state, 0x21, PllCfg);\r\nPllCfg = (1 << 15) | (0 << 13) | (cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv);\r\ndib0090_write_reg(state, 0x21, PllCfg);\r\nPllCfg |= (1 << 13);\r\ndib0090_write_reg(state, 0x21, PllCfg);\r\ni = 100;\r\ndo {\r\nv = !!(dib0090_read_reg(state, 0x1a) & 0x800);\r\nif (v)\r\nbreak;\r\n} while (--i);\r\nif (i == 0) {\r\ndprintk("Pll: Unable to lock Pll");\r\nreturn;\r\n}\r\nPllCfg &= ~(1 << 15);\r\ndib0090_write_reg(state, 0x21, PllCfg);\r\n}\r\nif (cfg->io.pll_bypass) {\r\nPllCfg |= (cfg->io.pll_bypass << 15);\r\ndib0090_write_reg(state, 0x21, PllCfg);\r\n}\r\n}\r\nstatic int dib0090_fw_reset_digital(struct dvb_frontend *fe, const struct dib0090_config *cfg)\r\n{\r\nstruct dib0090_fw_state *state = fe->tuner_priv;\r\nu16 PllCfg;\r\nu16 v;\r\nint i;\r\ndprintk("fw reset digital");\r\nHARD_RESET(state);\r\ndib0090_fw_write_reg(state, 0x24, EN_PLL | EN_CRYSTAL);\r\ndib0090_fw_write_reg(state, 0x1b, EN_DIGCLK | EN_PLL | EN_CRYSTAL);\r\ndib0090_fw_write_reg(state, 0x20,\r\n((cfg->io.adc_clock_ratio - 1) << 11) | (0 << 10) | (1 << 9) | (1 << 8) | (cfg->data_tx_drv << 4) | cfg->ls_cfg_pad_drv);\r\nv = (0 << 15) | ((!cfg->analog_output) << 14) | (1 << 9) | (0 << 8) | (cfg->clkouttobamse << 4) | (0 << 2) | (0);\r\nif (cfg->clkoutdrive != 0)\r\nv |= cfg->clkoutdrive << 5;\r\nelse\r\nv |= 7 << 5;\r\nv |= 2 << 10;\r\ndib0090_fw_write_reg(state, 0x23, v);\r\nPllCfg = dib0090_fw_read_reg(state, 0x21);\r\nif ((PllCfg & 0x1FFF) != ((cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv)) && !cfg->io.pll_bypass) {\r\nPllCfg |= (1 << 15);\r\ndib0090_fw_write_reg(state, 0x21, PllCfg);\r\nPllCfg &= ~(1 << 13);\r\ndib0090_fw_write_reg(state, 0x21, PllCfg);\r\nPllCfg = (1 << 15) | (0 << 13) | (cfg->io.pll_range << 12) | (cfg->io.pll_loopdiv << 6) | (cfg->io.pll_prediv);\r\ndib0090_fw_write_reg(state, 0x21, PllCfg);\r\nPllCfg |= (1 << 13);\r\ndib0090_fw_write_reg(state, 0x21, PllCfg);\r\ni = 100;\r\ndo {\r\nv = !!(dib0090_fw_read_reg(state, 0x1a) & 0x800);\r\nif (v)\r\nbreak;\r\n} while (--i);\r\nif (i == 0) {\r\ndprintk("Pll: Unable to lock Pll");\r\nreturn -EIO;\r\n}\r\nPllCfg &= ~(1 << 15);\r\ndib0090_fw_write_reg(state, 0x21, PllCfg);\r\n}\r\nif (cfg->io.pll_bypass) {\r\nPllCfg |= (cfg->io.pll_bypass << 15);\r\ndib0090_fw_write_reg(state, 0x21, PllCfg);\r\n}\r\nreturn dib0090_fw_identify(fe);\r\n}\r\nstatic int dib0090_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nif (state->config->sleep)\r\nstate->config->sleep(fe, 0);\r\ndib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) | (1 << 14));\r\nreturn 0;\r\n}\r\nstatic int dib0090_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nif (state->config->sleep)\r\nstate->config->sleep(fe, 1);\r\nreturn 0;\r\n}\r\nvoid dib0090_dcc_freq(struct dvb_frontend *fe, u8 fast)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nif (fast)\r\ndib0090_write_reg(state, 0x04, 0);\r\nelse\r\ndib0090_write_reg(state, 0x04, 1);\r\n}\r\nstatic u16 slopes_to_scale(const struct slope *slopes, u8 num, s16 val)\r\n{\r\nu8 i;\r\nu16 rest;\r\nu16 ret = 0;\r\nfor (i = 0; i < num; i++) {\r\nif (val > slopes[i].range)\r\nrest = slopes[i].range;\r\nelse\r\nrest = val;\r\nret += (rest * slopes[i].slope) / slopes[i].range;\r\nval -= rest;\r\n}\r\nreturn ret;\r\n}\r\nstatic s16 dib0090_wbd_to_db(struct dib0090_state *state, u16 wbd)\r\n{\r\nwbd &= 0x3ff;\r\nif (wbd < state->wbd_offset)\r\nwbd = 0;\r\nelse\r\nwbd -= state->wbd_offset;\r\nreturn -640 + (s16) slopes_to_scale(dib0090_wbd_slopes, ARRAY_SIZE(dib0090_wbd_slopes), wbd);\r\n}\r\nstatic void dib0090_wbd_target(struct dib0090_state *state, u32 rf)\r\n{\r\nu16 offset = 250;\r\nif (state->current_band == BAND_VHF)\r\noffset = 650;\r\n#ifndef FIRMWARE_FIREFLY\r\nif (state->current_band == BAND_VHF)\r\noffset = state->config->wbd_vhf_offset;\r\nif (state->current_band == BAND_CBAND)\r\noffset = state->config->wbd_cband_offset;\r\n#endif\r\nstate->wbd_target = dib0090_wbd_to_db(state, state->wbd_offset + offset);\r\ndprintk("wbd-target: %d dB", (u32) state->wbd_target);\r\n}\r\nstatic void dib0090_gain_apply(struct dib0090_state *state, s16 gain_delta, s16 top_delta, u8 force)\r\n{\r\nu16 rf, bb, ref;\r\nu16 i, v, gain_reg[4] = { 0 }, gain;\r\nconst u16 *g;\r\nif (top_delta < -511)\r\ntop_delta = -511;\r\nif (top_delta > 511)\r\ntop_delta = 511;\r\nif (force) {\r\ntop_delta *= (1 << WBD_ALPHA);\r\ngain_delta *= (1 << GAIN_ALPHA);\r\n}\r\nif (top_delta >= ((s16) (state->rf_ramp[0] << WBD_ALPHA) - state->rf_gain_limit))\r\nstate->rf_gain_limit = state->rf_ramp[0] << WBD_ALPHA;\r\nelse\r\nstate->rf_gain_limit += top_delta;\r\nif (state->rf_gain_limit < 0)\r\nstate->rf_gain_limit = 0;\r\ngain = ((state->rf_gain_limit >> WBD_ALPHA) + state->bb_ramp[0]) << GAIN_ALPHA;\r\nif (gain_delta >= ((s16) gain - state->current_gain))\r\nstate->current_gain = gain;\r\nelse\r\nstate->current_gain += gain_delta;\r\nif (state->current_gain < 0)\r\nstate->current_gain = 0;\r\ngain = state->current_gain >> GAIN_ALPHA;\r\nif (gain > (state->rf_gain_limit >> WBD_ALPHA)) {\r\nrf = state->rf_gain_limit >> WBD_ALPHA;\r\nbb = gain - rf;\r\nif (bb > state->bb_ramp[0])\r\nbb = state->bb_ramp[0];\r\n} else {\r\nrf = gain;\r\nbb = 0;\r\n}\r\nstate->gain[0] = rf;\r\nstate->gain[1] = bb;\r\ng = state->rf_ramp + 1;\r\nref = rf;\r\nfor (i = 0; i < 7; i++) {\r\nif (g[0] == 0 || ref < (g[1] - g[0]))\r\nv = 0;\r\nelse if (ref >= g[1])\r\nv = g[2];\r\nelse\r\nv = ((ref - (g[1] - g[0])) * g[2]) / g[0];\r\nif (i == 0)\r\ngain_reg[0] = v;\r\nelse if (i == 1)\r\ngain_reg[0] |= v << 7;\r\nelse if (i == 2)\r\ngain_reg[1] = v;\r\nelse if (i == 3)\r\ngain_reg[1] |= v << 7;\r\nelse if (i == 4)\r\ngain_reg[2] = v | state->rf_lt_def;\r\nelse if (i == 5)\r\ngain_reg[3] = v << 3;\r\nelse if (i == 6)\r\ngain_reg[3] |= v << 8;\r\ng += 3;\r\nif (i == 4) {\r\ng = state->bb_ramp + 1;\r\nref = bb;\r\n}\r\n}\r\ngain_reg[3] |= state->bb_1_def;\r\ngain_reg[3] |= ((bb % 10) * 100) / 125;\r\n#ifdef DEBUG_AGC\r\ndprintk("GA CALC: DB: %3d(rf) + %3d(bb) = %3d gain_reg[0]=%04x gain_reg[1]=%04x gain_reg[2]=%04x gain_reg[0]=%04x", rf, bb, rf + bb,\r\ngain_reg[0], gain_reg[1], gain_reg[2], gain_reg[3]);\r\n#endif\r\nfor (i = 0; i < 4; i++) {\r\nv = gain_reg[i];\r\nif (force || state->gain_reg[i] != v) {\r\nstate->gain_reg[i] = v;\r\ndib0090_write_reg(state, gain_reg_addr[i], v);\r\n}\r\n}\r\n}\r\nstatic void dib0090_set_boost(struct dib0090_state *state, int onoff)\r\n{\r\nstate->bb_1_def &= 0xdfff;\r\nstate->bb_1_def |= onoff << 13;\r\n}\r\nstatic void dib0090_set_rframp(struct dib0090_state *state, const u16 * cfg)\r\n{\r\nstate->rf_ramp = cfg;\r\n}\r\nstatic void dib0090_set_rframp_pwm(struct dib0090_state *state, const u16 * cfg)\r\n{\r\nstate->rf_ramp = cfg;\r\ndib0090_write_reg(state, 0x2a, 0xffff);\r\ndprintk("total RF gain: %ddB, step: %d", (u32) cfg[0], dib0090_read_reg(state, 0x2a));\r\ndib0090_write_regs(state, 0x2c, cfg + 3, 6);\r\ndib0090_write_regs(state, 0x3e, cfg + 9, 2);\r\n}\r\nstatic void dib0090_set_bbramp(struct dib0090_state *state, const u16 * cfg)\r\n{\r\nstate->bb_ramp = cfg;\r\ndib0090_set_boost(state, cfg[0] > 500);\r\n}\r\nstatic void dib0090_set_bbramp_pwm(struct dib0090_state *state, const u16 * cfg)\r\n{\r\nstate->bb_ramp = cfg;\r\ndib0090_set_boost(state, cfg[0] > 500);\r\ndib0090_write_reg(state, 0x33, 0xffff);\r\ndprintk("total BB gain: %ddB, step: %d", (u32) cfg[0], dib0090_read_reg(state, 0x33));\r\ndib0090_write_regs(state, 0x35, cfg + 3, 4);\r\n}\r\nvoid dib0090_pwm_gain_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nu16 *bb_ramp = (u16 *)&bb_ramp_pwm_normal;\r\nu16 *rf_ramp = NULL;\r\nu8 en_pwm_rf_mux = 1;\r\nif (state->config->use_pwm_agc) {\r\nif (state->current_band == BAND_CBAND) {\r\nif (state->identity.in_soc) {\r\nbb_ramp = (u16 *)&bb_ramp_pwm_normal_socs;\r\nif (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)\r\nrf_ramp = (u16 *)&rf_ramp_pwm_cband_8090;\r\nelse if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1) {\r\nif (state->config->is_dib7090e) {\r\nif (state->rf_ramp == NULL)\r\nrf_ramp = (u16 *)&rf_ramp_pwm_cband_7090e_sensitivity;\r\nelse\r\nrf_ramp = (u16 *)state->rf_ramp;\r\n} else\r\nrf_ramp = (u16 *)&rf_ramp_pwm_cband_7090p;\r\n}\r\n} else\r\nrf_ramp = (u16 *)&rf_ramp_pwm_cband;\r\n} else\r\nif (state->current_band == BAND_VHF) {\r\nif (state->identity.in_soc) {\r\nbb_ramp = (u16 *)&bb_ramp_pwm_normal_socs;\r\n} else\r\nrf_ramp = (u16 *)&rf_ramp_pwm_vhf;\r\n} else if (state->current_band == BAND_UHF) {\r\nif (state->identity.in_soc) {\r\nbb_ramp = (u16 *)&bb_ramp_pwm_normal_socs;\r\nif (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)\r\nrf_ramp = (u16 *)&rf_ramp_pwm_uhf_8090;\r\nelse if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)\r\nrf_ramp = (u16 *)&rf_ramp_pwm_uhf_7090;\r\n} else\r\nrf_ramp = (u16 *)&rf_ramp_pwm_uhf;\r\n}\r\nif (rf_ramp)\r\ndib0090_set_rframp_pwm(state, rf_ramp);\r\ndib0090_set_bbramp_pwm(state, bb_ramp);\r\ndprintk("ramp RF gain = %d BAND = %s version = %d", state->rf_ramp[0], (state->current_band == BAND_CBAND) ? "CBAND" : "NOT CBAND", state->identity.version & 0x1f);\r\nif ((state->rf_ramp[0] == 0) || (state->current_band == BAND_CBAND && (state->identity.version & 0x1f) <= P1D_E_F)) {\r\ndprintk("DE-Engage mux for direct gain reg control");\r\nen_pwm_rf_mux = 0;\r\n} else\r\ndprintk("Engage mux for PWM control");\r\ndib0090_write_reg(state, 0x32, (en_pwm_rf_mux << 12) | (en_pwm_rf_mux << 11));\r\nif (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)\r\ndib0090_write_reg(state, 0x04, 3);\r\nelse\r\ndib0090_write_reg(state, 0x04, 1);\r\ndib0090_write_reg(state, 0x39, (1 << 10));\r\n}\r\n}\r\nvoid dib0090_set_dc_servo(struct dvb_frontend *fe, u8 DC_servo_cutoff)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nif (DC_servo_cutoff < 4)\r\ndib0090_write_reg(state, 0x04, DC_servo_cutoff);\r\n}\r\nstatic u32 dib0090_get_slow_adc_val(struct dib0090_state *state)\r\n{\r\nu16 adc_val = dib0090_read_reg(state, 0x1d);\r\nif (state->identity.in_soc)\r\nadc_val >>= 2;\r\nreturn adc_val;\r\n}\r\nint dib0090_gain_control(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nint ret = 10;\r\nu16 wbd_val = 0;\r\nu8 apply_gain_immediatly = 1;\r\ns16 wbd_error = 0, adc_error = 0;\r\nif (*tune_state == CT_AGC_START) {\r\nstate->agc_freeze = 0;\r\ndib0090_write_reg(state, 0x04, 0x0);\r\n#ifdef CONFIG_BAND_SBAND\r\nif (state->current_band == BAND_SBAND) {\r\ndib0090_set_rframp(state, rf_ramp_sband);\r\ndib0090_set_bbramp(state, bb_ramp_boost);\r\n} else\r\n#endif\r\n#ifdef CONFIG_BAND_VHF\r\nif (state->current_band == BAND_VHF && !state->identity.p1g) {\r\ndib0090_set_rframp(state, rf_ramp_pwm_vhf);\r\ndib0090_set_bbramp(state, bb_ramp_pwm_normal);\r\n} else\r\n#endif\r\n#ifdef CONFIG_BAND_CBAND\r\nif (state->current_band == BAND_CBAND && !state->identity.p1g) {\r\ndib0090_set_rframp(state, rf_ramp_pwm_cband);\r\ndib0090_set_bbramp(state, bb_ramp_pwm_normal);\r\n} else\r\n#endif\r\nif ((state->current_band == BAND_CBAND || state->current_band == BAND_VHF) && state->identity.p1g) {\r\ndib0090_set_rframp(state, rf_ramp_pwm_cband_7090p);\r\ndib0090_set_bbramp(state, bb_ramp_pwm_normal_socs);\r\n} else {\r\ndib0090_set_rframp(state, rf_ramp_pwm_uhf);\r\ndib0090_set_bbramp(state, bb_ramp_pwm_normal);\r\n}\r\ndib0090_write_reg(state, 0x32, 0);\r\ndib0090_write_reg(state, 0x39, 0);\r\ndib0090_wbd_target(state, state->current_rf);\r\nstate->rf_gain_limit = state->rf_ramp[0] << WBD_ALPHA;\r\nstate->current_gain = ((state->rf_ramp[0] + state->bb_ramp[0]) / 2) << GAIN_ALPHA;\r\n*tune_state = CT_AGC_STEP_0;\r\n} else if (!state->agc_freeze) {\r\ns16 wbd = 0, i, cnt;\r\nint adc;\r\nwbd_val = dib0090_get_slow_adc_val(state);\r\nif (*tune_state == CT_AGC_STEP_0)\r\ncnt = 5;\r\nelse\r\ncnt = 1;\r\nfor (i = 0; i < cnt; i++) {\r\nwbd_val = dib0090_get_slow_adc_val(state);\r\nwbd += dib0090_wbd_to_db(state, wbd_val);\r\n}\r\nwbd /= cnt;\r\nwbd_error = state->wbd_target - wbd;\r\nif (*tune_state == CT_AGC_STEP_0) {\r\nif (wbd_error < 0 && state->rf_gain_limit > 0 && !state->identity.p1g) {\r\n#ifdef CONFIG_BAND_CBAND\r\nu8 ltg2 = (state->rf_lt_def >> 10) & 0x7;\r\nif (state->current_band == BAND_CBAND && ltg2) {\r\nltg2 >>= 1;\r\nstate->rf_lt_def &= ltg2 << 10;\r\n}\r\n#endif\r\n} else {\r\nstate->agc_step = 0;\r\n*tune_state = CT_AGC_STEP_1;\r\n}\r\n} else {\r\nadc = state->config->get_adc_power(fe);\r\nadc = (adc * ((s32) 355774) + (((s32) 1) << 20)) >> 21;\r\nadc_error = (s16) (((s32) ADC_TARGET) - adc);\r\n#ifdef CONFIG_STANDARD_DAB\r\nif (state->fe->dtv_property_cache.delivery_system == STANDARD_DAB)\r\nadc_error -= 10;\r\n#endif\r\n#ifdef CONFIG_STANDARD_DVBT\r\nif (state->fe->dtv_property_cache.delivery_system == STANDARD_DVBT &&\r\n(state->fe->dtv_property_cache.modulation == QAM_64 || state->fe->dtv_property_cache.modulation == QAM_16))\r\nadc_error += 60;\r\n#endif\r\n#ifdef CONFIG_SYS_ISDBT\r\nif ((state->fe->dtv_property_cache.delivery_system == SYS_ISDBT) && (((state->fe->dtv_property_cache.layer[0].segment_count >\r\n0)\r\n&&\r\n((state->fe->dtv_property_cache.layer[0].modulation ==\r\nQAM_64)\r\n|| (state->fe->dtv_property_cache.\r\nlayer[0].modulation == QAM_16)))\r\n||\r\n((state->fe->dtv_property_cache.layer[1].segment_count >\r\n0)\r\n&&\r\n((state->fe->dtv_property_cache.layer[1].modulation ==\r\nQAM_64)\r\n|| (state->fe->dtv_property_cache.\r\nlayer[1].modulation == QAM_16)))\r\n||\r\n((state->fe->dtv_property_cache.layer[2].segment_count >\r\n0)\r\n&&\r\n((state->fe->dtv_property_cache.layer[2].modulation ==\r\nQAM_64)\r\n|| (state->fe->dtv_property_cache.\r\nlayer[2].modulation == QAM_16)))\r\n)\r\n)\r\nadc_error += 60;\r\n#endif\r\nif (*tune_state == CT_AGC_STEP_1) {\r\nif (ABS(adc_error) < 50 || state->agc_step++ > 5) {\r\n#ifdef CONFIG_STANDARD_DAB\r\nif (state->fe->dtv_property_cache.delivery_system == STANDARD_DAB) {\r\ndib0090_write_reg(state, 0x02, (1 << 15) | (15 << 11) | (31 << 6) | (63));\r\ndib0090_write_reg(state, 0x04, 0x0);\r\n} else\r\n#endif\r\n{\r\ndib0090_write_reg(state, 0x02, (1 << 15) | (3 << 11) | (6 << 6) | (32));\r\ndib0090_write_reg(state, 0x04, 0x01);\r\n}\r\n*tune_state = CT_AGC_STOP;\r\n}\r\n} else {\r\nret = 100;\r\napply_gain_immediatly = 0;\r\n}\r\n}\r\n#ifdef DEBUG_AGC\r\ndprintk\r\n("tune state %d, ADC = %3ddB (ADC err %3d) WBD %3ddB (WBD err %3d, WBD val SADC: %4d), RFGainLimit (TOP): %3d, signal: %3ddBm",\r\n(u32) *tune_state, (u32) adc, (u32) adc_error, (u32) wbd, (u32) wbd_error, (u32) wbd_val,\r\n(u32) state->rf_gain_limit >> WBD_ALPHA, (s32) 200 + adc - (state->current_gain >> GAIN_ALPHA));\r\n#endif\r\n}\r\nif (!state->agc_freeze)\r\ndib0090_gain_apply(state, adc_error, wbd_error, apply_gain_immediatly);\r\nreturn ret;\r\n}\r\nvoid dib0090_get_current_gain(struct dvb_frontend *fe, u16 * rf, u16 * bb, u16 * rf_gain_limit, u16 * rflt)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nif (rf)\r\n*rf = state->gain[0];\r\nif (bb)\r\n*bb = state->gain[1];\r\nif (rf_gain_limit)\r\n*rf_gain_limit = state->rf_gain_limit;\r\nif (rflt)\r\n*rflt = (state->rf_lt_def >> 10) & 0x7;\r\n}\r\nu16 dib0090_get_wbd_target(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nu32 f_MHz = state->fe->dtv_property_cache.frequency / 1000000;\r\ns32 current_temp = state->temperature;\r\ns32 wbd_thot, wbd_tcold;\r\nconst struct dib0090_wbd_slope *wbd = state->current_wbd_table;\r\nwhile (f_MHz > wbd->max_freq)\r\nwbd++;\r\ndprintk("using wbd-table-entry with max freq %d", wbd->max_freq);\r\nif (current_temp < 0)\r\ncurrent_temp = 0;\r\nif (current_temp > 128)\r\ncurrent_temp = 128;\r\nstate->wbdmux &= ~(7 << 13);\r\nif (wbd->wbd_gain != 0)\r\nstate->wbdmux |= (wbd->wbd_gain << 13);\r\nelse\r\nstate->wbdmux |= (4 << 13);\r\ndib0090_write_reg(state, 0x10, state->wbdmux);\r\nwbd_thot = wbd->offset_hot - (((u32) wbd->slope_hot * f_MHz) >> 6);\r\nwbd_tcold = wbd->offset_cold - (((u32) wbd->slope_cold * f_MHz) >> 6);\r\nwbd_tcold += ((wbd_thot - wbd_tcold) * current_temp) >> 7;\r\nstate->wbd_target = dib0090_wbd_to_db(state, state->wbd_offset + wbd_tcold);\r\ndprintk("wbd-target: %d dB", (u32) state->wbd_target);\r\ndprintk("wbd offset applied is %d", wbd_tcold);\r\nreturn state->wbd_offset + wbd_tcold;\r\n}\r\nu16 dib0090_get_wbd_offset(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nreturn state->wbd_offset;\r\n}\r\nint dib0090_set_switch(struct dvb_frontend *fe, u8 sw1, u8 sw2, u8 sw3)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\ndib0090_write_reg(state, 0x0b, (dib0090_read_reg(state, 0x0b) & 0xfff8)\r\n| ((sw3 & 1) << 2) | ((sw2 & 1) << 1) | (sw1 & 1));\r\nreturn 0;\r\n}\r\nint dib0090_set_vga(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\ndib0090_write_reg(state, 0x09, (dib0090_read_reg(state, 0x09) & 0x7fff)\r\n| ((onoff & 1) << 15));\r\nreturn 0;\r\n}\r\nint dib0090_update_rframp_7090(struct dvb_frontend *fe, u8 cfg_sensitivity)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nif ((!state->identity.p1g) || (!state->identity.in_soc)\r\n|| ((state->identity.version != SOC_7090_P1G_21R1)\r\n&& (state->identity.version != SOC_7090_P1G_11R1))) {\r\ndprintk("%s() function can only be used for dib7090P", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (cfg_sensitivity)\r\nstate->rf_ramp = (const u16 *)&rf_ramp_pwm_cband_7090e_sensitivity;\r\nelse\r\nstate->rf_ramp = (const u16 *)&rf_ramp_pwm_cband_7090e_aci;\r\ndib0090_pwm_gain_reset(fe);\r\nreturn 0;\r\n}\r\nstatic void dib0090_set_default_config(struct dib0090_state *state, const u16 * n)\r\n{\r\nu16 l, r;\r\nl = pgm_read_word(n++);\r\nwhile (l) {\r\nr = pgm_read_word(n++);\r\ndo {\r\ndib0090_write_reg(state, r, pgm_read_word(n++));\r\nr++;\r\n} while (--l);\r\nl = pgm_read_word(n++);\r\n}\r\n}\r\nstatic void dib0090_set_EFUSE(struct dib0090_state *state)\r\n{\r\nu8 c, h, n;\r\nu16 e2, e4;\r\nu16 cal;\r\ne2 = dib0090_read_reg(state, 0x26);\r\ne4 = dib0090_read_reg(state, 0x28);\r\nif ((state->identity.version == P1D_E_F) ||\r\n(state->identity.version == P1G) || (e2 == 0xffff)) {\r\ndib0090_write_reg(state, 0x22, 0x10);\r\ncal = (dib0090_read_reg(state, 0x22) >> 6) & 0x3ff;\r\nif ((cal < 670) || (cal == 1023))\r\ncal = 850;\r\nn = 165 - ((cal * 10)>>6) ;\r\ne2 = e4 = (3<<12) | (34<<6) | (n);\r\n}\r\nif (e2 != e4)\r\ne2 &= e4;\r\nif (e2 != 0xffff) {\r\nc = e2 & 0x3f;\r\nn = (e2 >> 12) & 0xf;\r\nh = (e2 >> 6) & 0x3f;\r\nif ((c >= CAP_VALUE_MAX) || (c <= CAP_VALUE_MIN))\r\nc = 32;\r\nelse\r\nc += 14;\r\nif ((h >= HR_MAX) || (h <= HR_MIN))\r\nh = 34;\r\nif ((n >= POLY_MAX) || (n <= POLY_MIN))\r\nn = 3;\r\ndib0090_write_reg(state, 0x13, (h << 10));\r\ne2 = (n << 11) | ((h >> 2)<<6) | c;\r\ndib0090_write_reg(state, 0x2, e2);\r\n}\r\n}\r\nstatic int dib0090_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\ndib0090_reset_digital(fe, state->config);\r\nif (dib0090_identify(fe) < 0)\r\nreturn -EIO;\r\n#ifdef CONFIG_TUNER_DIB0090_P1B_SUPPORT\r\nif (!(state->identity.version & 0x1))\r\nreturn 0;\r\n#endif\r\nif (!state->identity.in_soc) {\r\nif ((dib0090_read_reg(state, 0x1a) >> 5) & 0x2)\r\ndib0090_write_reg(state, 0x1b, (EN_IQADC | EN_BB | EN_BIAS | EN_DIGCLK | EN_PLL | EN_CRYSTAL));\r\nelse\r\ndib0090_write_reg(state, 0x1b, (EN_DIGCLK | EN_PLL | EN_CRYSTAL));\r\n}\r\ndib0090_set_default_config(state, dib0090_defaults);\r\nif (state->identity.in_soc)\r\ndib0090_write_reg(state, 0x18, 0x2910);\r\nif (state->identity.p1g)\r\ndib0090_set_default_config(state, dib0090_p1g_additionnal_defaults);\r\nif (((state->identity.version & 0x1f) >= P1D_E_F) || (state->identity.in_soc))\r\ndib0090_set_EFUSE(state);\r\nif (state->config->force_crystal_mode != 0)\r\ndib0090_write_reg(state, 0x14,\r\nstate->config->force_crystal_mode & 3);\r\nelse if (state->config->io.clock_khz >= 24000)\r\ndib0090_write_reg(state, 0x14, 1);\r\nelse\r\ndib0090_write_reg(state, 0x14, 2);\r\ndprintk("Pll lock : %d", (dib0090_read_reg(state, 0x1a) >> 11) & 0x1);\r\nstate->calibrate = DC_CAL | WBD_CAL | TEMP_CAL;\r\nreturn 0;\r\n}\r\nstatic int dib0090_get_offset(struct dib0090_state *state, enum frontend_tune_state *tune_state)\r\n{\r\nint ret = INTERN_WAIT * 10;\r\nswitch (*tune_state) {\r\ncase CT_TUNER_STEP_2:\r\ndib0090_write_reg(state, 0x1f, 0x7);\r\n*tune_state = CT_TUNER_STEP_3;\r\nbreak;\r\ncase CT_TUNER_STEP_3:\r\nstate->adc_diff = dib0090_read_reg(state, 0x1d);\r\ndib0090_write_reg(state, 0x1f, 0x4);\r\n*tune_state = CT_TUNER_STEP_4;\r\nbreak;\r\ncase CT_TUNER_STEP_4:\r\nstate->adc_diff -= dib0090_read_reg(state, 0x1d);\r\n*tune_state = CT_TUNER_STEP_5;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dib0090_set_trim(struct dib0090_state *state)\r\n{\r\nu16 *val;\r\nif (state->dc->addr == 0x07)\r\nval = &state->bb7;\r\nelse\r\nval = &state->bb6;\r\n*val &= ~(0x1f << state->dc->offset);\r\n*val |= state->step << state->dc->offset;\r\ndib0090_write_reg(state, state->dc->addr, *val);\r\n}\r\nstatic int dib0090_dc_offset_calibration(struct dib0090_state *state, enum frontend_tune_state *tune_state)\r\n{\r\nint ret = 0;\r\nu16 reg;\r\nswitch (*tune_state) {\r\ncase CT_TUNER_START:\r\ndprintk("Start DC offset calibration");\r\nstate->bb6 = 0;\r\nstate->bb7 = 0x040d;\r\nreg = dib0090_read_reg(state, 0x24) & 0x0ffb;\r\ndib0090_write_reg(state, 0x24, reg);\r\nstate->wbdmux = dib0090_read_reg(state, 0x10);\r\ndib0090_write_reg(state, 0x10, (state->wbdmux & ~(0xff << 3)) | (0x7 << 3) | 0x3);\r\ndib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) & ~(1 << 14));\r\nstate->dc = dc_table;\r\nif (state->identity.p1g)\r\nstate->dc = dc_p1g_table;\r\n*tune_state = CT_TUNER_STEP_0;\r\ncase CT_TUNER_STEP_0:\r\ndprintk("Sart/continue DC calibration for %s path", (state->dc->i == 1) ? "I" : "Q");\r\ndib0090_write_reg(state, 0x01, state->dc->bb1);\r\ndib0090_write_reg(state, 0x07, state->bb7 | (state->dc->i << 7));\r\nstate->step = 0;\r\nstate->min_adc_diff = 1023;\r\n*tune_state = CT_TUNER_STEP_1;\r\nret = 50;\r\nbreak;\r\ncase CT_TUNER_STEP_1:\r\ndib0090_set_trim(state);\r\n*tune_state = CT_TUNER_STEP_2;\r\nbreak;\r\ncase CT_TUNER_STEP_2:\r\ncase CT_TUNER_STEP_3:\r\ncase CT_TUNER_STEP_4:\r\nret = dib0090_get_offset(state, tune_state);\r\nbreak;\r\ncase CT_TUNER_STEP_5:\r\ndprintk("adc_diff = %d, current step= %d", (u32) state->adc_diff, state->step);\r\nif (state->step == 0 && state->adc_diff < 0) {\r\nstate->min_adc_diff = -1023;\r\ndprintk("Change of sign of the minimum adc diff");\r\n}\r\ndprintk("adc_diff = %d, min_adc_diff = %d current_step = %d", state->adc_diff, state->min_adc_diff, state->step);\r\nif (state->step == 0) {\r\nif (state->dc->pga && state->adc_diff < 0)\r\nstate->step = 0x10;\r\nif (state->dc->pga == 0 && state->adc_diff > 0)\r\nstate->step = 0x10;\r\n}\r\nif ((state->adc_diff & 0x8000) == (state->min_adc_diff & 0x8000) && steps(state->step) < 15) {\r\nstate->step++;\r\nstate->min_adc_diff = state->adc_diff;\r\n*tune_state = CT_TUNER_STEP_1;\r\n} else {\r\nif (ABS(state->adc_diff) > ABS(state->min_adc_diff)) {\r\ndprintk("Since adc_diff N = %d > adc_diff step N-1 = %d, Come back one step", state->adc_diff, state->min_adc_diff);\r\nstate->step--;\r\n}\r\ndib0090_set_trim(state);\r\ndprintk("BB Offset Cal, BBreg=%hd,Offset=%hd,Value Set=%hd", state->dc->addr, state->adc_diff, state->step);\r\nstate->dc++;\r\nif (state->dc->addr == 0)\r\n*tune_state = CT_TUNER_STEP_6;\r\nelse\r\n*tune_state = CT_TUNER_STEP_0;\r\n}\r\nbreak;\r\ncase CT_TUNER_STEP_6:\r\ndib0090_write_reg(state, 0x07, state->bb7 & ~0x0008);\r\ndib0090_write_reg(state, 0x1f, 0x7);\r\n*tune_state = CT_TUNER_START;\r\nstate->calibrate &= ~DC_CAL;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0090_wbd_calibration(struct dib0090_state *state, enum frontend_tune_state *tune_state)\r\n{\r\nu8 wbd_gain;\r\nconst struct dib0090_wbd_slope *wbd = state->current_wbd_table;\r\nswitch (*tune_state) {\r\ncase CT_TUNER_START:\r\nwhile (state->current_rf / 1000 > wbd->max_freq)\r\nwbd++;\r\nif (wbd->wbd_gain != 0)\r\nwbd_gain = wbd->wbd_gain;\r\nelse {\r\nwbd_gain = 4;\r\n#if defined(CONFIG_BAND_LBAND) || defined(CONFIG_BAND_SBAND)\r\nif ((state->current_band == BAND_LBAND) || (state->current_band == BAND_SBAND))\r\nwbd_gain = 2;\r\n#endif\r\n}\r\nif (wbd_gain == state->wbd_calibration_gain) {\r\n*tune_state = CT_TUNER_START;\r\nstate->calibrate &= ~WBD_CAL;\r\nreturn 0;\r\n}\r\ndib0090_write_reg(state, 0x10, 0x1b81 | (1 << 10) | (wbd_gain << 13) | (1 << 3));\r\ndib0090_write_reg(state, 0x24, ((EN_UHF & 0x0fff) | (1 << 1)));\r\n*tune_state = CT_TUNER_STEP_0;\r\nstate->wbd_calibration_gain = wbd_gain;\r\nreturn 90;\r\ncase CT_TUNER_STEP_0:\r\nstate->wbd_offset = dib0090_get_slow_adc_val(state);\r\ndprintk("WBD calibration offset = %d", state->wbd_offset);\r\n*tune_state = CT_TUNER_START;\r\nstate->calibrate &= ~WBD_CAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib0090_set_bandwidth(struct dib0090_state *state)\r\n{\r\nu16 tmp;\r\nif (state->fe->dtv_property_cache.bandwidth_hz / 1000 <= 5000)\r\ntmp = (3 << 14);\r\nelse if (state->fe->dtv_property_cache.bandwidth_hz / 1000 <= 6000)\r\ntmp = (2 << 14);\r\nelse if (state->fe->dtv_property_cache.bandwidth_hz / 1000 <= 7000)\r\ntmp = (1 << 14);\r\nelse\r\ntmp = (0 << 14);\r\nstate->bb_1_def &= 0x3fff;\r\nstate->bb_1_def |= tmp;\r\ndib0090_write_reg(state, 0x01, state->bb_1_def);\r\ndib0090_write_reg(state, 0x03, 0x6008);\r\ndib0090_write_reg(state, 0x04, 0x1);\r\nif (state->identity.in_soc) {\r\ndib0090_write_reg(state, 0x05, 0x9bcf);\r\n} else {\r\ndib0090_write_reg(state, 0x02, (5 << 11) | (8 << 6) | (22 & 0x3f));\r\ndib0090_write_reg(state, 0x05, 0xabcd);\r\n}\r\n}\r\nint dib0090_update_tuning_table_7090(struct dvb_frontend *fe,\r\nu8 cfg_sensitivity)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nconst struct dib0090_tuning *tune =\r\ndib0090_tuning_table_cband_7090e_sensitivity;\r\nconst struct dib0090_tuning dib0090_tuning_table_cband_7090e_aci[] = {\r\n{ 300000, 0 , 3, 0x8165, 0x2c0, 0x2d12, 0xb84e, EN_CAB },\r\n{ 650000, 0 , 4, 0x815B, 0x280, 0x2d12, 0xb84e, EN_CAB },\r\n{ 860000, 0 , 5, 0x84EF, 0x280, 0x2d12, 0xb84e, EN_CAB },\r\n};\r\nif ((!state->identity.p1g) || (!state->identity.in_soc)\r\n|| ((state->identity.version != SOC_7090_P1G_21R1)\r\n&& (state->identity.version != SOC_7090_P1G_11R1))) {\r\ndprintk("%s() function can only be used for dib7090", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (cfg_sensitivity)\r\ntune = dib0090_tuning_table_cband_7090e_sensitivity;\r\nelse\r\ntune = dib0090_tuning_table_cband_7090e_aci;\r\nwhile (state->rf_request > tune->max_freq)\r\ntune++;\r\ndib0090_write_reg(state, 0x09, (dib0090_read_reg(state, 0x09) & 0x8000)\r\n| (tune->lna_bias & 0x7fff));\r\ndib0090_write_reg(state, 0x0b, (dib0090_read_reg(state, 0x0b) & 0xf83f)\r\n| ((tune->lna_tune << 6) & 0x07c0));\r\nreturn 0;\r\n}\r\nstatic int dib0090_captrim_search(struct dib0090_state *state, enum frontend_tune_state *tune_state)\r\n{\r\nint ret = 0;\r\nu16 lo4 = 0xe900;\r\ns16 adc_target;\r\nu16 adc;\r\ns8 step_sign;\r\nu8 force_soft_search = 0;\r\nif (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)\r\nforce_soft_search = 1;\r\nif (*tune_state == CT_TUNER_START) {\r\ndprintk("Start Captrim search : %s", (force_soft_search == 1) ? "FORCE SOFT SEARCH" : "AUTO");\r\ndib0090_write_reg(state, 0x10, 0x2B1);\r\ndib0090_write_reg(state, 0x1e, 0x0032);\r\nif (!state->tuner_is_tuned) {\r\nif (!state->identity.p1g || force_soft_search)\r\nstate->step = state->captrim = state->fcaptrim = 64;\r\nstate->current_rf = state->rf_request;\r\n} else {\r\nif (!state->identity.p1g || force_soft_search) {\r\nstate->step = 4;\r\nstate->captrim = state->fcaptrim = dib0090_read_reg(state, 0x18) & 0x7f;\r\n}\r\n}\r\nstate->adc_diff = 3000;\r\n*tune_state = CT_TUNER_STEP_0;\r\n} else if (*tune_state == CT_TUNER_STEP_0) {\r\nif (state->identity.p1g && !force_soft_search) {\r\nu8 ratio = 31;\r\ndib0090_write_reg(state, 0x40, (3 << 7) | (ratio << 2) | (1 << 1) | 1);\r\ndib0090_read_reg(state, 0x40);\r\nret = 50;\r\n} else {\r\nstate->step /= 2;\r\ndib0090_write_reg(state, 0x18, lo4 | state->captrim);\r\nif (state->identity.in_soc)\r\nret = 25;\r\n}\r\n*tune_state = CT_TUNER_STEP_1;\r\n} else if (*tune_state == CT_TUNER_STEP_1) {\r\nif (state->identity.p1g && !force_soft_search) {\r\ndib0090_write_reg(state, 0x40, 0x18c | (0 << 1) | 0);\r\ndib0090_read_reg(state, 0x40);\r\nstate->fcaptrim = dib0090_read_reg(state, 0x18) & 0x7F;\r\ndprintk("***Final Captrim= 0x%x", state->fcaptrim);\r\n*tune_state = CT_TUNER_STEP_3;\r\n} else {\r\nadc = dib0090_get_slow_adc_val(state);\r\ndprintk("CAPTRIM=%d; ADC = %d (ADC) & %dmV", (u32) state->captrim, (u32) adc, (u32) (adc) * (u32) 1800 / (u32) 1024);\r\nif (state->rest == 0 || state->identity.in_soc) {\r\nadc_target = 200;\r\n} else\r\nadc_target = 400;\r\nif (adc >= adc_target) {\r\nadc -= adc_target;\r\nstep_sign = -1;\r\n} else {\r\nadc = adc_target - adc;\r\nstep_sign = 1;\r\n}\r\nif (adc < state->adc_diff) {\r\ndprintk("CAPTRIM=%d is closer to target (%d/%d)", (u32) state->captrim, (u32) adc, (u32) state->adc_diff);\r\nstate->adc_diff = adc;\r\nstate->fcaptrim = state->captrim;\r\n}\r\nstate->captrim += step_sign * state->step;\r\nif (state->step >= 1)\r\n*tune_state = CT_TUNER_STEP_0;\r\nelse\r\n*tune_state = CT_TUNER_STEP_2;\r\nret = 25;\r\n}\r\n} else if (*tune_state == CT_TUNER_STEP_2) {\r\ndib0090_write_reg(state, 0x18, lo4 | state->fcaptrim);\r\n*tune_state = CT_TUNER_STEP_3;\r\n} else if (*tune_state == CT_TUNER_STEP_3) {\r\nstate->calibrate &= ~CAPTRIM_CAL;\r\n*tune_state = CT_TUNER_STEP_0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0090_get_temperature(struct dib0090_state *state, enum frontend_tune_state *tune_state)\r\n{\r\nint ret = 15;\r\ns16 val;\r\nswitch (*tune_state) {\r\ncase CT_TUNER_START:\r\nstate->wbdmux = dib0090_read_reg(state, 0x10);\r\ndib0090_write_reg(state, 0x10, (state->wbdmux & ~(0xff << 3)) | (0x8 << 3));\r\nstate->bias = dib0090_read_reg(state, 0x13);\r\ndib0090_write_reg(state, 0x13, state->bias | (0x3 << 8));\r\n*tune_state = CT_TUNER_STEP_0;\r\nbreak;\r\ncase CT_TUNER_STEP_0:\r\nstate->adc_diff = dib0090_get_slow_adc_val(state);\r\ndib0090_write_reg(state, 0x13, (state->bias & ~(0x3 << 8)) | (0x2 << 8));\r\n*tune_state = CT_TUNER_STEP_1;\r\nbreak;\r\ncase CT_TUNER_STEP_1:\r\nval = dib0090_get_slow_adc_val(state);\r\nstate->temperature = ((s16) ((val - state->adc_diff) * 180) >> 8) + 55;\r\ndprintk("temperature: %d C", state->temperature - 30);\r\n*tune_state = CT_TUNER_STEP_2;\r\nbreak;\r\ncase CT_TUNER_STEP_2:\r\ndib0090_write_reg(state, 0x13, state->bias);\r\ndib0090_write_reg(state, 0x10, state->wbdmux);\r\n*tune_state = CT_TUNER_START;\r\nstate->calibrate &= ~TEMP_CAL;\r\nif (state->config->analog_output == 0)\r\ndib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) | (1 << 14));\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0090_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nconst struct dib0090_tuning *tune = state->current_tune_table_index;\r\nconst struct dib0090_pll *pll = state->current_pll_table_index;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nu16 lo5, lo6, Den, tmp;\r\nu32 FBDiv, Rest, FREF, VCOF_kHz = 0;\r\nint ret = 10;\r\nu8 c, i;\r\nif (*tune_state == CT_TUNER_START) {\r\nif (state->calibrate & (DC_CAL | TEMP_CAL | WBD_CAL))\r\ndib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) & ~(1 << 14));\r\nelse\r\nif (state->config->analog_output == 0)\r\ndib0090_write_reg(state, 0x23, dib0090_read_reg(state, 0x23) | (1 << 14));\r\n}\r\nif (state->calibrate & DC_CAL)\r\nreturn dib0090_dc_offset_calibration(state, tune_state);\r\nelse if (state->calibrate & WBD_CAL) {\r\nif (state->current_rf == 0)\r\nstate->current_rf = state->fe->dtv_property_cache.frequency / 1000;\r\nreturn dib0090_wbd_calibration(state, tune_state);\r\n} else if (state->calibrate & TEMP_CAL)\r\nreturn dib0090_get_temperature(state, tune_state);\r\nelse if (state->calibrate & CAPTRIM_CAL)\r\nreturn dib0090_captrim_search(state, tune_state);\r\nif (*tune_state == CT_TUNER_START) {\r\nif (state->config->use_pwm_agc && state->identity.in_soc) {\r\ntmp = dib0090_read_reg(state, 0x39);\r\nif ((tmp >> 10) & 0x1)\r\ndib0090_write_reg(state, 0x39, tmp & ~(1 << 10));\r\n}\r\nstate->current_band = (u8) BAND_OF_FREQUENCY(state->fe->dtv_property_cache.frequency / 1000);\r\nstate->rf_request =\r\nstate->fe->dtv_property_cache.frequency / 1000 + (state->current_band ==\r\nBAND_UHF ? state->config->freq_offset_khz_uhf : state->config->\r\nfreq_offset_khz_vhf);\r\nif ((state->fe->dtv_property_cache.delivery_system == SYS_ISDBT && state->fe->dtv_property_cache.isdbt_sb_mode == 1\r\n&& state->fe->dtv_property_cache.isdbt_partial_reception == 0)) {\r\nconst struct dib0090_low_if_offset_table *LUT_offset = state->config->low_if;\r\nu8 found_offset = 0;\r\nu32 margin_khz = 100;\r\nif (LUT_offset != NULL) {\r\nwhile (LUT_offset->RF_freq != 0xffff) {\r\nif (((state->rf_request > (LUT_offset->RF_freq - margin_khz))\r\n&& (state->rf_request < (LUT_offset->RF_freq + margin_khz)))\r\n&& LUT_offset->std == state->fe->dtv_property_cache.delivery_system) {\r\nstate->rf_request += LUT_offset->offset_khz;\r\nfound_offset = 1;\r\nbreak;\r\n}\r\nLUT_offset++;\r\n}\r\n}\r\nif (found_offset == 0)\r\nstate->rf_request += 400;\r\n}\r\nif (state->current_rf != state->rf_request || (state->current_standard != state->fe->dtv_property_cache.delivery_system)) {\r\nstate->tuner_is_tuned = 0;\r\nstate->current_rf = 0;\r\nstate->current_standard = 0;\r\ntune = dib0090_tuning_table;\r\nif (state->identity.p1g)\r\ntune = dib0090_p1g_tuning_table;\r\ntmp = (state->identity.version >> 5) & 0x7;\r\nif (state->identity.in_soc) {\r\nif (state->config->force_cband_input) {\r\nif (state->current_band & BAND_CBAND || state->current_band & BAND_FM || state->current_band & BAND_VHF\r\n|| state->current_band & BAND_UHF) {\r\nstate->current_band = BAND_CBAND;\r\nif (state->config->is_dib7090e)\r\ntune = dib0090_tuning_table_cband_7090e_sensitivity;\r\nelse\r\ntune = dib0090_tuning_table_cband_7090;\r\n}\r\n} else {\r\nif (state->current_band & BAND_CBAND || state->current_band & BAND_FM || state->current_band & BAND_VHF) {\r\nstate->current_band = BAND_CBAND;\r\nif (state->config->is_dib7090e)\r\ntune = dib0090_tuning_table_cband_7090e_sensitivity;\r\nelse\r\ntune = dib0090_tuning_table_cband_7090;\r\n}\r\n}\r\n} else\r\nif (tmp == 0x4 || tmp == 0x7) {\r\nif (state->current_band == BAND_FM || state->current_band == BAND_CBAND || state->current_band == BAND_VHF) {\r\nstate->current_band = BAND_CBAND;\r\ntune = dib0090_tuning_table_fm_vhf_on_cband;\r\nif (state->identity.p1g)\r\ntune = dib0090_p1g_tuning_table_fm_vhf_on_cband;\r\n}\r\n}\r\npll = dib0090_pll_table;\r\nif (state->identity.p1g)\r\npll = dib0090_p1g_pll_table;\r\nwhile (state->rf_request > tune->max_freq)\r\ntune++;\r\nwhile (state->rf_request > pll->max_freq)\r\npll++;\r\nstate->current_tune_table_index = tune;\r\nstate->current_pll_table_index = pll;\r\ndib0090_write_reg(state, 0x0b, 0xb800 | (tune->switch_trim));\r\nVCOF_kHz = (pll->hfdiv * state->rf_request) * 2;\r\nFREF = state->config->io.clock_khz;\r\nif (state->config->fref_clock_ratio != 0)\r\nFREF /= state->config->fref_clock_ratio;\r\nFBDiv = (VCOF_kHz / pll->topresc / FREF);\r\nRest = (VCOF_kHz / pll->topresc) - FBDiv * FREF;\r\nif (Rest < LPF)\r\nRest = 0;\r\nelse if (Rest < 2 * LPF)\r\nRest = 2 * LPF;\r\nelse if (Rest > (FREF - LPF)) {\r\nRest = 0;\r\nFBDiv += 1;\r\n} else if (Rest > (FREF - 2 * LPF))\r\nRest = FREF - 2 * LPF;\r\nRest = (Rest * 6528) / (FREF / 10);\r\nstate->rest = Rest;\r\nif (Rest == 0) {\r\nif (pll->vco_band)\r\nlo5 = 0x049f;\r\nelse\r\nlo5 = 0x041f;\r\n} else {\r\nif (pll->vco_band)\r\nlo5 = 0x049e;\r\nelse if (state->config->analog_output)\r\nlo5 = 0x041d;\r\nelse\r\nlo5 = 0x041c;\r\n}\r\nif (state->identity.p1g) {\r\nif (state->identity.in_soc) {\r\nif (state->identity.version == SOC_8090_P1G_11R1)\r\nlo5 = 0x46f;\r\nelse\r\nlo5 = 0x42f;\r\n} else\r\nlo5 = 0x42c;\r\n}\r\nlo5 |= (pll->hfdiv_code << 11) | (pll->vco_band << 7);\r\nif (!state->config->io.pll_int_loop_filt) {\r\nif (state->identity.in_soc)\r\nlo6 = 0xff98;\r\nelse if (state->identity.p1g || (Rest == 0))\r\nlo6 = 0xfff8;\r\nelse\r\nlo6 = 0xff28;\r\n} else\r\nlo6 = (state->config->io.pll_int_loop_filt << 3);\r\nDen = 1;\r\nif (Rest > 0) {\r\nif (state->config->analog_output)\r\nlo6 |= (1 << 2) | 2;\r\nelse {\r\nif (state->identity.in_soc)\r\nlo6 |= (1 << 2) | 2;\r\nelse\r\nlo6 |= (1 << 2) | 2;\r\n}\r\nDen = 255;\r\n}\r\ndib0090_write_reg(state, 0x15, (u16) FBDiv);\r\nif (state->config->fref_clock_ratio != 0)\r\ndib0090_write_reg(state, 0x16, (Den << 8) | state->config->fref_clock_ratio);\r\nelse\r\ndib0090_write_reg(state, 0x16, (Den << 8) | 1);\r\ndib0090_write_reg(state, 0x17, (u16) Rest);\r\ndib0090_write_reg(state, 0x19, lo5);\r\ndib0090_write_reg(state, 0x1c, lo6);\r\nlo6 = tune->tuner_enable;\r\nif (state->config->analog_output)\r\nlo6 = (lo6 & 0xff9f) | 0x2;\r\ndib0090_write_reg(state, 0x24, lo6 | EN_LO | state->config->use_pwm_agc * EN_CRYSTAL);\r\n}\r\nstate->current_rf = state->rf_request;\r\nstate->current_standard = state->fe->dtv_property_cache.delivery_system;\r\nret = 20;\r\nstate->calibrate = CAPTRIM_CAL;\r\n}\r\nelse if (*tune_state == CT_TUNER_STEP_0) {\r\nconst struct dib0090_wbd_slope *wbd = state->current_wbd_table;\r\nwhile (state->current_rf / 1000 > wbd->max_freq)\r\nwbd++;\r\ndib0090_write_reg(state, 0x1e, 0x07ff);\r\ndprintk("Final Captrim: %d", (u32) state->fcaptrim);\r\ndprintk("HFDIV code: %d", (u32) pll->hfdiv_code);\r\ndprintk("VCO = %d", (u32) pll->vco_band);\r\ndprintk("VCOF in kHz: %d ((%d*%d) << 1))", (u32) ((pll->hfdiv * state->rf_request) * 2), (u32) pll->hfdiv, (u32) state->rf_request);\r\ndprintk("REFDIV: %d, FREF: %d", (u32) 1, (u32) state->config->io.clock_khz);\r\ndprintk("FBDIV: %d, Rest: %d", (u32) dib0090_read_reg(state, 0x15), (u32) dib0090_read_reg(state, 0x17));\r\ndprintk("Num: %d, Den: %d, SD: %d", (u32) dib0090_read_reg(state, 0x17), (u32) (dib0090_read_reg(state, 0x16) >> 8),\r\n(u32) dib0090_read_reg(state, 0x1c) & 0x3);\r\n#define WBD 0x781\r\nc = 4;\r\ni = 3;\r\nif (wbd->wbd_gain != 0)\r\nc = wbd->wbd_gain;\r\nstate->wbdmux = (c << 13) | (i << 11) | (WBD | (state->config->use_pwm_agc << 1));\r\ndib0090_write_reg(state, 0x10, state->wbdmux);\r\nif ((tune->tuner_enable == EN_CAB) && state->identity.p1g) {\r\ndprintk("P1G : The cable band is selected and lna_tune = %d", tune->lna_tune);\r\ndib0090_write_reg(state, 0x09, tune->lna_bias);\r\ndib0090_write_reg(state, 0x0b, 0xb800 | (tune->lna_tune << 6) | (tune->switch_trim));\r\n} else\r\ndib0090_write_reg(state, 0x09, (tune->lna_tune << 5) | tune->lna_bias);\r\ndib0090_write_reg(state, 0x0c, tune->v2i);\r\ndib0090_write_reg(state, 0x0d, tune->mix);\r\ndib0090_write_reg(state, 0x0e, tune->load);\r\n*tune_state = CT_TUNER_STEP_1;\r\n} else if (*tune_state == CT_TUNER_STEP_1) {\r\nstate->rf_lt_def = 0x7c00;\r\ndib0090_set_bandwidth(state);\r\nstate->tuner_is_tuned = 1;\r\nstate->calibrate |= WBD_CAL;\r\nstate->calibrate |= TEMP_CAL;\r\n*tune_state = CT_TUNER_STOP;\r\n} else\r\nret = FE_CALLBACK_TIME_NEVER;\r\nreturn ret;\r\n}\r\nstatic int dib0090_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nenum frontend_tune_state dib0090_get_tune_state(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nreturn state->tune_state;\r\n}\r\nint dib0090_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nstate->tune_state = tune_state;\r\nreturn 0;\r\n}\r\nstatic int dib0090_get_frequency(struct dvb_frontend *fe, u32 * frequency)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\n*frequency = 1000 * state->current_rf;\r\nreturn 0;\r\n}\r\nstatic int dib0090_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dib0090_state *state = fe->tuner_priv;\r\nu32 ret;\r\nstate->tune_state = CT_TUNER_START;\r\ndo {\r\nret = dib0090_tune(fe);\r\nif (ret != FE_CALLBACK_TIME_NEVER)\r\nmsleep(ret / 10);\r\nelse\r\nbreak;\r\n} while (state->tune_state != CT_TUNER_STOP);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *dib0090_register(struct dvb_frontend *fe, struct i2c_adapter *i2c, const struct dib0090_config *config)\r\n{\r\nstruct dib0090_state *st = kzalloc(sizeof(struct dib0090_state), GFP_KERNEL);\r\nif (st == NULL)\r\nreturn NULL;\r\nst->config = config;\r\nst->i2c = i2c;\r\nst->fe = fe;\r\nmutex_init(&st->i2c_buffer_lock);\r\nfe->tuner_priv = st;\r\nif (config->wbd == NULL)\r\nst->current_wbd_table = dib0090_wbd_table_default;\r\nelse\r\nst->current_wbd_table = config->wbd;\r\nif (dib0090_reset(fe) != 0)\r\ngoto free_mem;\r\nprintk(KERN_INFO "DiB0090: successfully identified\n");\r\nmemcpy(&fe->ops.tuner_ops, &dib0090_ops, sizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\nfree_mem:\r\nkfree(st);\r\nfe->tuner_priv = NULL;\r\nreturn NULL;\r\n}\r\nstruct dvb_frontend *dib0090_fw_register(struct dvb_frontend *fe, struct i2c_adapter *i2c, const struct dib0090_config *config)\r\n{\r\nstruct dib0090_fw_state *st = kzalloc(sizeof(struct dib0090_fw_state), GFP_KERNEL);\r\nif (st == NULL)\r\nreturn NULL;\r\nst->config = config;\r\nst->i2c = i2c;\r\nst->fe = fe;\r\nmutex_init(&st->i2c_buffer_lock);\r\nfe->tuner_priv = st;\r\nif (dib0090_fw_reset_digital(fe, st->config) != 0)\r\ngoto free_mem;\r\ndprintk("DiB0090 FW: successfully identified");\r\nmemcpy(&fe->ops.tuner_ops, &dib0090_fw_ops, sizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\nfree_mem:\r\nkfree(st);\r\nfe->tuner_priv = NULL;\r\nreturn NULL;\r\n}
