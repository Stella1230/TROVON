static inline int lm3533_bl_get_ctrlbank_id(struct lm3533_bl *bl)\r\n{\r\nreturn bl->id;\r\n}\r\nstatic int lm3533_bl_update_status(struct backlight_device *bd)\r\n{\r\nstruct lm3533_bl *bl = bl_get_data(bd);\r\nint brightness = bd->props.brightness;\r\nif (bd->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bd->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nreturn lm3533_ctrlbank_set_brightness(&bl->cb, (u8)brightness);\r\n}\r\nstatic int lm3533_bl_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct lm3533_bl *bl = bl_get_data(bd);\r\nu8 val;\r\nint ret;\r\nret = lm3533_ctrlbank_get_brightness(&bl->cb, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic ssize_t show_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", bl->id);\r\n}\r\nstatic ssize_t show_als_channel(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nunsigned channel = lm3533_bl_get_ctrlbank_id(bl);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", channel);\r\n}\r\nstatic ssize_t show_als_en(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nint ctrlbank = lm3533_bl_get_ctrlbank_id(bl);\r\nu8 val;\r\nu8 mask;\r\nbool enable;\r\nint ret;\r\nret = lm3533_read(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, &val);\r\nif (ret)\r\nreturn ret;\r\nmask = 1 << (2 * ctrlbank);\r\nenable = val & mask;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", enable);\r\n}\r\nstatic ssize_t store_als_en(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nint ctrlbank = lm3533_bl_get_ctrlbank_id(bl);\r\nint enable;\r\nu8 val;\r\nu8 mask;\r\nint ret;\r\nif (kstrtoint(buf, 0, &enable))\r\nreturn -EINVAL;\r\nmask = 1 << (2 * ctrlbank);\r\nif (enable)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, val,\r\nmask);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t show_linear(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nu8 val;\r\nu8 mask;\r\nint linear;\r\nint ret;\r\nret = lm3533_read(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, &val);\r\nif (ret)\r\nreturn ret;\r\nmask = 1 << (2 * lm3533_bl_get_ctrlbank_id(bl) + 1);\r\nif (val & mask)\r\nlinear = 1;\r\nelse\r\nlinear = 0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", linear);\r\n}\r\nstatic ssize_t store_linear(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nunsigned long linear;\r\nu8 mask;\r\nu8 val;\r\nint ret;\r\nif (kstrtoul(buf, 0, &linear))\r\nreturn -EINVAL;\r\nmask = 1 << (2 * lm3533_bl_get_ctrlbank_id(bl) + 1);\r\nif (linear)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(bl->lm3533, LM3533_REG_CTRLBANK_AB_BCONF, val,\r\nmask);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nu8 val;\r\nint ret;\r\nret = lm3533_ctrlbank_get_pwm(&bl->cb, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", val);\r\n}\r\nstatic ssize_t store_pwm(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\nu8 val;\r\nint ret;\r\nif (kstrtou8(buf, 0, &val))\r\nreturn -EINVAL;\r\nret = lm3533_ctrlbank_set_pwm(&bl->cb, val);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic umode_t lm3533_bl_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_als_channel.attr ||\r\nattr == &dev_attr_als_en.attr) {\r\nif (!bl->lm3533->have_als)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic int lm3533_bl_setup(struct lm3533_bl *bl,\r\nstruct lm3533_bl_platform_data *pdata)\r\n{\r\nint ret;\r\nret = lm3533_ctrlbank_set_max_current(&bl->cb, pdata->max_current);\r\nif (ret)\r\nreturn ret;\r\nreturn lm3533_ctrlbank_set_pwm(&bl->cb, pdata->pwm);\r\n}\r\nstatic int lm3533_bl_probe(struct platform_device *pdev)\r\n{\r\nstruct lm3533 *lm3533;\r\nstruct lm3533_bl_platform_data *pdata;\r\nstruct lm3533_bl *bl;\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nint ret;\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nlm3533 = dev_get_drvdata(pdev->dev.parent);\r\nif (!lm3533)\r\nreturn -EINVAL;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdev->id < 0 || pdev->id >= LM3533_HVCTRLBANK_COUNT) {\r\ndev_err(&pdev->dev, "illegal backlight id %d\n", pdev->id);\r\nreturn -EINVAL;\r\n}\r\nbl = devm_kzalloc(&pdev->dev, sizeof(*bl), GFP_KERNEL);\r\nif (!bl) {\r\ndev_err(&pdev->dev,\r\n"failed to allocate memory for backlight\n");\r\nreturn -ENOMEM;\r\n}\r\nbl->lm3533 = lm3533;\r\nbl->id = pdev->id;\r\nbl->cb.lm3533 = lm3533;\r\nbl->cb.id = lm3533_bl_get_ctrlbank_id(bl);\r\nbl->cb.dev = NULL;\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = LM3533_BL_MAX_BRIGHTNESS;\r\nprops.brightness = pdata->default_brightness;\r\nbd = backlight_device_register(pdata->name, pdev->dev.parent, bl,\r\n&lm3533_bl_ops, &props);\r\nif (IS_ERR(bd)) {\r\ndev_err(&pdev->dev, "failed to register backlight device\n");\r\nreturn PTR_ERR(bd);\r\n}\r\nbl->bd = bd;\r\nbl->cb.dev = &bl->bd->dev;\r\nplatform_set_drvdata(pdev, bl);\r\nret = sysfs_create_group(&bd->dev.kobj, &lm3533_bl_attribute_group);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to create sysfs attributes\n");\r\ngoto err_unregister;\r\n}\r\nbacklight_update_status(bd);\r\nret = lm3533_bl_setup(bl, pdata);\r\nif (ret)\r\ngoto err_sysfs_remove;\r\nret = lm3533_ctrlbank_enable(&bl->cb);\r\nif (ret)\r\ngoto err_sysfs_remove;\r\nreturn 0;\r\nerr_sysfs_remove:\r\nsysfs_remove_group(&bd->dev.kobj, &lm3533_bl_attribute_group);\r\nerr_unregister:\r\nbacklight_device_unregister(bd);\r\nreturn ret;\r\n}\r\nstatic int lm3533_bl_remove(struct platform_device *pdev)\r\n{\r\nstruct lm3533_bl *bl = platform_get_drvdata(pdev);\r\nstruct backlight_device *bd = bl->bd;\r\ndev_dbg(&bd->dev, "%s\n", __func__);\r\nbd->props.power = FB_BLANK_POWERDOWN;\r\nbd->props.brightness = 0;\r\nlm3533_ctrlbank_disable(&bl->cb);\r\nsysfs_remove_group(&bd->dev.kobj, &lm3533_bl_attribute_group);\r\nbacklight_device_unregister(bd);\r\nreturn 0;\r\n}\r\nstatic int lm3533_bl_suspend(struct device *dev)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nreturn lm3533_ctrlbank_disable(&bl->cb);\r\n}\r\nstatic int lm3533_bl_resume(struct device *dev)\r\n{\r\nstruct lm3533_bl *bl = dev_get_drvdata(dev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nreturn lm3533_ctrlbank_enable(&bl->cb);\r\n}\r\nstatic void lm3533_bl_shutdown(struct platform_device *pdev)\r\n{\r\nstruct lm3533_bl *bl = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nlm3533_ctrlbank_disable(&bl->cb);\r\n}
