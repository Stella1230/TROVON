static int s3c2443_gate(void __iomem *reg, struct clk *clk, int enable)\r\n{\r\nu32 ctrlbit = clk->ctrlbit;\r\nu32 con = __raw_readl(reg);\r\nif (enable)\r\ncon |= ctrlbit;\r\nelse\r\ncon &= ~ctrlbit;\r\n__raw_writel(con, reg);\r\nreturn 0;\r\n}\r\nint s3c2443_clkcon_enable_h(struct clk *clk, int enable)\r\n{\r\nreturn s3c2443_gate(S3C2443_HCLKCON, clk, enable);\r\n}\r\nint s3c2443_clkcon_enable_p(struct clk *clk, int enable)\r\n{\r\nreturn s3c2443_gate(S3C2443_PCLKCON, clk, enable);\r\n}\r\nint s3c2443_clkcon_enable_s(struct clk *clk, int enable)\r\n{\r\nreturn s3c2443_gate(S3C2443_SCLKCON, clk, enable);\r\n}\r\nstatic unsigned long s3c2443_getrate_mdivclk(struct clk *clk)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long div = __raw_readl(S3C2443_CLKDIV0);\r\ndiv &= S3C2443_CLKDIV0_EXTDIV_MASK;\r\ndiv >>= (S3C2443_CLKDIV0_EXTDIV_SHIFT-1);\r\nreturn parent_rate / (div + 1);\r\n}\r\nstatic unsigned long s3c2443_prediv_getrate(struct clk *clk)\r\n{\r\nunsigned long rate = clk_get_rate(clk->parent);\r\nunsigned long clkdiv0 = __raw_readl(S3C2443_CLKDIV0);\r\nclkdiv0 &= S3C2443_CLKDIV0_PREDIV_MASK;\r\nclkdiv0 >>= S3C2443_CLKDIV0_PREDIV_SHIFT;\r\nreturn rate / (clkdiv0 + 1);\r\n}\r\nstatic unsigned long s3c2443_hclkdiv_getrate(struct clk *clk)\r\n{\r\nunsigned long rate = clk_get_rate(clk->parent);\r\nunsigned long clkdiv0 = __raw_readl(S3C2443_CLKDIV0);\r\nclkdiv0 &= S3C2443_CLKDIV0_HCLKDIV_MASK;\r\nreturn rate / (clkdiv0 + 1);\r\n}\r\nstatic unsigned long s3c2443_pclkdiv_getrate(struct clk *clk)\r\n{\r\nunsigned long rate = clk_get_rate(clk->parent);\r\nunsigned long clkdiv0 = __raw_readl(S3C2443_CLKDIV0);\r\nclkdiv0 = ((clkdiv0 & S3C2443_CLKDIV0_HALF_PCLK) ? 1 : 0);\r\nreturn rate / (clkdiv0 + 1);\r\n}\r\nstatic unsigned long s3c2443_armclk_roundrate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nunsigned long parent = clk_get_rate(clk->parent);\r\nunsigned long calc;\r\nunsigned best = 256;\r\nunsigned div;\r\nint ptr;\r\nif (!nr_armdiv)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < nr_armdiv; ptr++) {\r\ndiv = armdiv[ptr];\r\nif (div) {\r\ncalc = (parent / div / 1000) * 1000;\r\nif (calc <= rate && div < best)\r\nbest = div;\r\n}\r\n}\r\nreturn parent / best;\r\n}\r\nstatic unsigned long s3c2443_armclk_getrate(struct clk *clk)\r\n{\r\nunsigned long rate = clk_get_rate(clk->parent);\r\nunsigned long clkcon0;\r\nint val;\r\nif (!nr_armdiv || !armdivmask)\r\nreturn -EINVAL;\r\nclkcon0 = __raw_readl(S3C2443_CLKDIV0);\r\nclkcon0 &= armdivmask;\r\nval = clkcon0 >> S3C2443_CLKDIV0_ARMDIV_SHIFT;\r\nreturn rate / armdiv[val];\r\n}\r\nstatic int s3c2443_armclk_setrate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long parent = clk_get_rate(clk->parent);\r\nunsigned long calc;\r\nunsigned div;\r\nunsigned best = 256;\r\nint ptr;\r\nint val = -1;\r\nif (!nr_armdiv || !armdivmask)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < nr_armdiv; ptr++) {\r\ndiv = armdiv[ptr];\r\nif (div) {\r\ncalc = (parent / div / 1000) * 1000;\r\nif (calc <= rate && div < best) {\r\nbest = div;\r\nval = ptr;\r\n}\r\n}\r\n}\r\nif (val >= 0) {\r\nunsigned long clkcon0;\r\nclkcon0 = __raw_readl(S3C2443_CLKDIV0);\r\nclkcon0 &= ~armdivmask;\r\nclkcon0 |= val << S3C2443_CLKDIV0_ARMDIV_SHIFT;\r\n__raw_writel(clkcon0, S3C2443_CLKDIV0);\r\n}\r\nreturn (val == -1) ? -EINVAL : 0;\r\n}\r\nvoid __init_or_cpufreq s3c2443_common_setup_clocks(pll_fn get_mpll)\r\n{\r\nunsigned long epllcon = __raw_readl(S3C2443_EPLLCON);\r\nunsigned long mpllcon = __raw_readl(S3C2443_MPLLCON);\r\nstruct clk *xtal_clk;\r\nunsigned long xtal;\r\nunsigned long pll;\r\nint ptr;\r\nxtal_clk = clk_get(NULL, "xtal");\r\nxtal = clk_get_rate(xtal_clk);\r\nclk_put(xtal_clk);\r\npll = get_mpll(mpllcon, xtal);\r\nclk_msysclk.clk.rate = pll;\r\nclk_mpll.rate = pll;\r\nprintk("CPU: MPLL %s %ld.%03ld MHz, cpu %ld.%03ld MHz, mem %ld.%03ld MHz, pclk %ld.%03ld MHz\n",\r\n(mpllcon & S3C2443_PLLCON_OFF) ? "off" : "on",\r\nprint_mhz(pll), print_mhz(clk_get_rate(&clk_armdiv)),\r\nprint_mhz(clk_get_rate(&clk_h)),\r\nprint_mhz(clk_get_rate(&clk_p)));\r\nfor (ptr = 0; ptr < ARRAY_SIZE(clksrc_clks); ptr++)\r\ns3c_set_clksrc(&clksrc_clks[ptr], true);\r\nif (clk_get_rate(&clk_usb_bus_host.clk) != (48 * 1000 * 1000)) {\r\nprintk(KERN_INFO "Warning: USB host bus not at 48MHz\n");\r\nclk_set_rate(&clk_usb_bus_host.clk, 48*1000*1000);\r\n}\r\nprintk("CPU: EPLL %s %ld.%03ld MHz, usb-bus %ld.%03ld MHz\n",\r\n(epllcon & S3C2443_PLLCON_OFF) ? "off" : "on",\r\nprint_mhz(clk_get_rate(&clk_epll)),\r\nprint_mhz(clk_get_rate(&clk_usb_bus)));\r\n}\r\nvoid __init s3c2443_common_init_clocks(int xtal, pll_fn get_mpll,\r\nunsigned int *divs, int nr_divs,\r\nint divmask)\r\n{\r\nint ptr;\r\narmdiv = divs;\r\nnr_armdiv = nr_divs;\r\narmdivmask = divmask;\r\nclk_h.parent = &clk_prediv;\r\nclk_h.ops = &clk_h_ops;\r\nclk_p.parent = &clk_h;\r\nclk_p.ops = &clk_p_ops;\r\nclk_usb_bus.parent = &clk_usb_bus_host.clk;\r\nclk_epll.parent = &clk_epllref.clk;\r\ns3c24xx_register_baseclocks(xtal);\r\ns3c24xx_register_clocks(clks, ARRAY_SIZE(clks));\r\nfor (ptr = 0; ptr < ARRAY_SIZE(clksrcs); ptr++)\r\ns3c_register_clksrc(clksrcs[ptr], 1);\r\ns3c_register_clksrc(clksrc_clks, ARRAY_SIZE(clksrc_clks));\r\ns3c_register_clocks(init_clocks, ARRAY_SIZE(init_clocks));\r\ns3c_register_clocks(init_clocks_off, ARRAY_SIZE(init_clocks_off));\r\ns3c_disable_clocks(init_clocks_off, ARRAY_SIZE(init_clocks_off));\r\nclkdev_add_table(s3c2443_clk_lookup, ARRAY_SIZE(s3c2443_clk_lookup));\r\ns3c2443_common_setup_clocks(get_mpll);\r\n}
