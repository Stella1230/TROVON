static bool atkbd_need_xlate(unsigned long xl_bit, unsigned char code)\r\n{\r\nint i;\r\nif (code == ATKBD_RET_EMUL0 || code == ATKBD_RET_EMUL1)\r\nreturn false;\r\nfor (i = 0; i < ARRAY_SIZE(xl_table); i++)\r\nif (code == xl_table[i])\r\nreturn test_bit(i, &xl_bit);\r\nreturn true;\r\n}\r\nstatic void atkbd_calculate_xl_bit(struct atkbd *atkbd, unsigned char code)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(xl_table); i++) {\r\nif (!((code ^ xl_table[i]) & 0x7f)) {\r\nif (code & 0x80)\r\n__clear_bit(i, &atkbd->xl_bit);\r\nelse\r\n__set_bit(i, &atkbd->xl_bit);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic unsigned int atkbd_compat_scancode(struct atkbd *atkbd, unsigned int code)\r\n{\r\nif (atkbd->set == 3) {\r\nif (atkbd->emul == 1)\r\ncode |= 0x100;\r\n} else {\r\ncode = (code & 0x7f) | ((code & 0x80) << 1);\r\nif (atkbd->emul == 1)\r\ncode |= 0x80;\r\n}\r\nreturn code;\r\n}\r\nstatic irqreturn_t atkbd_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int flags)\r\n{\r\nstruct atkbd *atkbd = serio_get_drvdata(serio);\r\nstruct input_dev *dev = atkbd->dev;\r\nunsigned int code = data;\r\nint scroll = 0, hscroll = 0, click = -1;\r\nint value;\r\nunsigned short keycode;\r\ndev_dbg(&serio->dev, "Received %02x flags %02x\n", data, flags);\r\n#if !defined(__i386__) && !defined (__x86_64__)\r\nif ((flags & (SERIO_FRAME | SERIO_PARITY)) && (~flags & SERIO_TIMEOUT) && !atkbd->resend && atkbd->write) {\r\ndev_warn(&serio->dev, "Frame/parity error: %02x\n", flags);\r\nserio_write(serio, ATKBD_CMD_RESEND);\r\natkbd->resend = true;\r\ngoto out;\r\n}\r\nif (!flags && data == ATKBD_RET_ACK)\r\natkbd->resend = false;\r\n#endif\r\nif (unlikely(atkbd->ps2dev.flags & PS2_FLAG_ACK))\r\nif (ps2_handle_ack(&atkbd->ps2dev, data))\r\ngoto out;\r\nif (unlikely(atkbd->ps2dev.flags & PS2_FLAG_CMD))\r\nif (ps2_handle_response(&atkbd->ps2dev, data))\r\ngoto out;\r\nif (!atkbd->enabled)\r\ngoto out;\r\ninput_event(dev, EV_MSC, MSC_RAW, code);\r\nif (atkbd_platform_scancode_fixup)\r\ncode = atkbd_platform_scancode_fixup(atkbd, code);\r\nif (atkbd->translated) {\r\nif (atkbd->emul || atkbd_need_xlate(atkbd->xl_bit, code)) {\r\natkbd->release = code >> 7;\r\ncode &= 0x7f;\r\n}\r\nif (!atkbd->emul)\r\natkbd_calculate_xl_bit(atkbd, data);\r\n}\r\nswitch (code) {\r\ncase ATKBD_RET_BAT:\r\natkbd->enabled = false;\r\nserio_reconnect(atkbd->ps2dev.serio);\r\ngoto out;\r\ncase ATKBD_RET_EMUL0:\r\natkbd->emul = 1;\r\ngoto out;\r\ncase ATKBD_RET_EMUL1:\r\natkbd->emul = 2;\r\ngoto out;\r\ncase ATKBD_RET_RELEASE:\r\natkbd->release = true;\r\ngoto out;\r\ncase ATKBD_RET_ACK:\r\ncase ATKBD_RET_NAK:\r\nif (printk_ratelimit())\r\ndev_warn(&serio->dev,\r\n"Spurious %s on %s. "\r\n"Some program might be trying to access hardware directly.\n",\r\ndata == ATKBD_RET_ACK ? "ACK" : "NAK", serio->phys);\r\ngoto out;\r\ncase ATKBD_RET_ERR:\r\natkbd->err_count++;\r\ndev_dbg(&serio->dev, "Keyboard on %s reports too many keys pressed.\n",\r\nserio->phys);\r\ngoto out;\r\n}\r\ncode = atkbd_compat_scancode(atkbd, code);\r\nif (atkbd->emul && --atkbd->emul)\r\ngoto out;\r\nkeycode = atkbd->keycode[code];\r\nif (keycode != ATKBD_KEY_NULL)\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\nswitch (keycode) {\r\ncase ATKBD_KEY_NULL:\r\nbreak;\r\ncase ATKBD_KEY_UNKNOWN:\r\ndev_warn(&serio->dev,\r\n"Unknown key %s (%s set %d, code %#x on %s).\n",\r\natkbd->release ? "released" : "pressed",\r\natkbd->translated ? "translated" : "raw",\r\natkbd->set, code, serio->phys);\r\ndev_warn(&serio->dev,\r\n"Use 'setkeycodes %s%02x <keycode>' to make it known.\n",\r\ncode & 0x80 ? "e0" : "", code & 0x7f);\r\ninput_sync(dev);\r\nbreak;\r\ncase ATKBD_SCR_1:\r\nscroll = 1;\r\nbreak;\r\ncase ATKBD_SCR_2:\r\nscroll = 2;\r\nbreak;\r\ncase ATKBD_SCR_4:\r\nscroll = 4;\r\nbreak;\r\ncase ATKBD_SCR_8:\r\nscroll = 8;\r\nbreak;\r\ncase ATKBD_SCR_CLICK:\r\nclick = !atkbd->release;\r\nbreak;\r\ncase ATKBD_SCR_LEFT:\r\nhscroll = -1;\r\nbreak;\r\ncase ATKBD_SCR_RIGHT:\r\nhscroll = 1;\r\nbreak;\r\ndefault:\r\nif (atkbd->release) {\r\nvalue = 0;\r\natkbd->last = 0;\r\n} else if (!atkbd->softrepeat && test_bit(keycode, dev->key)) {\r\nvalue = time_before(jiffies, atkbd->time) && atkbd->last == code ? 1 : 2;\r\n} else {\r\nvalue = 1;\r\natkbd->last = code;\r\natkbd->time = jiffies + msecs_to_jiffies(dev->rep[REP_DELAY]) / 2;\r\n}\r\ninput_event(dev, EV_KEY, keycode, value);\r\ninput_sync(dev);\r\nif (value && test_bit(code, atkbd->force_release_mask)) {\r\ninput_report_key(dev, keycode, 0);\r\ninput_sync(dev);\r\n}\r\n}\r\nif (atkbd->scroll) {\r\nif (click != -1)\r\ninput_report_key(dev, BTN_MIDDLE, click);\r\ninput_report_rel(dev, REL_WHEEL,\r\natkbd->release ? -scroll : scroll);\r\ninput_report_rel(dev, REL_HWHEEL, hscroll);\r\ninput_sync(dev);\r\n}\r\natkbd->release = false;\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atkbd_set_repeat_rate(struct atkbd *atkbd)\r\n{\r\nconst short period[32] =\r\n{ 33, 37, 42, 46, 50, 54, 58, 63, 67, 75, 83, 92, 100, 109, 116, 125,\r\n133, 149, 167, 182, 200, 217, 232, 250, 270, 303, 333, 370, 400, 435, 470, 500 };\r\nconst short delay[4] =\r\n{ 250, 500, 750, 1000 };\r\nstruct input_dev *dev = atkbd->dev;\r\nunsigned char param;\r\nint i = 0, j = 0;\r\nwhile (i < ARRAY_SIZE(period) - 1 && period[i] < dev->rep[REP_PERIOD])\r\ni++;\r\ndev->rep[REP_PERIOD] = period[i];\r\nwhile (j < ARRAY_SIZE(delay) - 1 && delay[j] < dev->rep[REP_DELAY])\r\nj++;\r\ndev->rep[REP_DELAY] = delay[j];\r\nparam = i | (j << 5);\r\nreturn ps2_command(&atkbd->ps2dev, &param, ATKBD_CMD_SETREP);\r\n}\r\nstatic int atkbd_set_leds(struct atkbd *atkbd)\r\n{\r\nstruct input_dev *dev = atkbd->dev;\r\nunsigned char param[2];\r\nparam[0] = (test_bit(LED_SCROLLL, dev->led) ? 1 : 0)\r\n| (test_bit(LED_NUML, dev->led) ? 2 : 0)\r\n| (test_bit(LED_CAPSL, dev->led) ? 4 : 0);\r\nif (ps2_command(&atkbd->ps2dev, param, ATKBD_CMD_SETLEDS))\r\nreturn -1;\r\nif (atkbd->extra) {\r\nparam[0] = 0;\r\nparam[1] = (test_bit(LED_COMPOSE, dev->led) ? 0x01 : 0)\r\n| (test_bit(LED_SLEEP, dev->led) ? 0x02 : 0)\r\n| (test_bit(LED_SUSPEND, dev->led) ? 0x04 : 0)\r\n| (test_bit(LED_MISC, dev->led) ? 0x10 : 0)\r\n| (test_bit(LED_MUTE, dev->led) ? 0x20 : 0);\r\nif (ps2_command(&atkbd->ps2dev, param, ATKBD_CMD_EX_SETLEDS))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atkbd_event_work(struct work_struct *work)\r\n{\r\nstruct atkbd *atkbd = container_of(work, struct atkbd, event_work.work);\r\nmutex_lock(&atkbd->mutex);\r\nif (!atkbd->enabled) {\r\nschedule_delayed_work(&atkbd->event_work,\r\nmsecs_to_jiffies(100));\r\n} else {\r\nif (test_and_clear_bit(ATKBD_LED_EVENT_BIT, &atkbd->event_mask))\r\natkbd_set_leds(atkbd);\r\nif (test_and_clear_bit(ATKBD_REP_EVENT_BIT, &atkbd->event_mask))\r\natkbd_set_repeat_rate(atkbd);\r\n}\r\nmutex_unlock(&atkbd->mutex);\r\n}\r\nstatic void atkbd_schedule_event_work(struct atkbd *atkbd, int event_bit)\r\n{\r\nunsigned long delay = msecs_to_jiffies(50);\r\nif (time_after(jiffies, atkbd->event_jiffies + delay))\r\ndelay = 0;\r\natkbd->event_jiffies = jiffies;\r\nset_bit(event_bit, &atkbd->event_mask);\r\nmb();\r\nschedule_delayed_work(&atkbd->event_work, delay);\r\n}\r\nstatic int atkbd_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct atkbd *atkbd = input_get_drvdata(dev);\r\nif (!atkbd->write)\r\nreturn -1;\r\nswitch (type) {\r\ncase EV_LED:\r\natkbd_schedule_event_work(atkbd, ATKBD_LED_EVENT_BIT);\r\nreturn 0;\r\ncase EV_REP:\r\nif (!atkbd->softrepeat)\r\natkbd_schedule_event_work(atkbd, ATKBD_REP_EVENT_BIT);\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic inline void atkbd_enable(struct atkbd *atkbd)\r\n{\r\nserio_pause_rx(atkbd->ps2dev.serio);\r\natkbd->enabled = true;\r\nserio_continue_rx(atkbd->ps2dev.serio);\r\n}\r\nstatic inline void atkbd_disable(struct atkbd *atkbd)\r\n{\r\nserio_pause_rx(atkbd->ps2dev.serio);\r\natkbd->enabled = false;\r\nserio_continue_rx(atkbd->ps2dev.serio);\r\n}\r\nstatic int atkbd_activate(struct atkbd *atkbd)\r\n{\r\nstruct ps2dev *ps2dev = &atkbd->ps2dev;\r\nif (ps2_command(ps2dev, NULL, ATKBD_CMD_ENABLE)) {\r\ndev_err(&ps2dev->serio->dev,\r\n"Failed to enable keyboard on %s\n",\r\nps2dev->serio->phys);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atkbd_deactivate(struct atkbd *atkbd)\r\n{\r\nstruct ps2dev *ps2dev = &atkbd->ps2dev;\r\nif (ps2_command(ps2dev, NULL, ATKBD_CMD_RESET_DIS))\r\ndev_err(&ps2dev->serio->dev,\r\n"Failed to deactivate keyboard on %s\n",\r\nps2dev->serio->phys);\r\n}\r\nstatic int atkbd_probe(struct atkbd *atkbd)\r\n{\r\nstruct ps2dev *ps2dev = &atkbd->ps2dev;\r\nunsigned char param[2];\r\nif (atkbd_reset)\r\nif (ps2_command(ps2dev, NULL, ATKBD_CMD_RESET_BAT))\r\ndev_warn(&ps2dev->serio->dev,\r\n"keyboard reset failed on %s\n",\r\nps2dev->serio->phys);\r\nparam[0] = param[1] = 0xa5;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_GETID)) {\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_SETLEDS))\r\nreturn -1;\r\natkbd->id = 0xabba;\r\nreturn 0;\r\n}\r\nif (!ps2_is_keyboard_id(param[0]))\r\nreturn -1;\r\natkbd->id = (param[0] << 8) | param[1];\r\nif (atkbd->id == 0xaca1 && atkbd->translated) {\r\ndev_err(&ps2dev->serio->dev,\r\n"NCD terminal keyboards are only supported on non-translating controllers. "\r\n"Use i8042.direct=1 to disable translation.\n");\r\nreturn -1;\r\n}\r\natkbd_deactivate(atkbd);\r\nreturn 0;\r\n}\r\nstatic int atkbd_select_set(struct atkbd *atkbd, int target_set, int allow_extra)\r\n{\r\nstruct ps2dev *ps2dev = &atkbd->ps2dev;\r\nunsigned char param[2];\r\natkbd->extra = false;\r\nif (atkbd->translated)\r\nreturn 2;\r\nif (atkbd->id == 0xaca1) {\r\nparam[0] = 3;\r\nps2_command(ps2dev, param, ATKBD_CMD_SSCANSET);\r\nreturn 3;\r\n}\r\nif (allow_extra) {\r\nparam[0] = 0x71;\r\nif (!ps2_command(ps2dev, param, ATKBD_CMD_EX_ENABLE)) {\r\natkbd->extra = true;\r\nreturn 2;\r\n}\r\n}\r\nif (atkbd_terminal) {\r\nps2_command(ps2dev, param, ATKBD_CMD_SETALL_MB);\r\nreturn 3;\r\n}\r\nif (target_set != 3)\r\nreturn 2;\r\nif (!ps2_command(ps2dev, param, ATKBD_CMD_OK_GETID)) {\r\natkbd->id = param[0] << 8 | param[1];\r\nreturn 2;\r\n}\r\nparam[0] = 3;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_SSCANSET))\r\nreturn 2;\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_GSCANSET))\r\nreturn 2;\r\nif (param[0] != 3) {\r\nparam[0] = 2;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_SSCANSET))\r\nreturn 2;\r\n}\r\nps2_command(ps2dev, param, ATKBD_CMD_SETALL_MBR);\r\nreturn 3;\r\n}\r\nstatic int atkbd_reset_state(struct atkbd *atkbd)\r\n{\r\nstruct ps2dev *ps2dev = &atkbd->ps2dev;\r\nunsigned char param[1];\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_SETLEDS))\r\nreturn -1;\r\nparam[0] = 0;\r\nif (ps2_command(ps2dev, param, ATKBD_CMD_SETREP))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void atkbd_cleanup(struct serio *serio)\r\n{\r\nstruct atkbd *atkbd = serio_get_drvdata(serio);\r\natkbd_disable(atkbd);\r\nps2_command(&atkbd->ps2dev, NULL, ATKBD_CMD_RESET_DEF);\r\n}\r\nstatic void atkbd_disconnect(struct serio *serio)\r\n{\r\nstruct atkbd *atkbd = serio_get_drvdata(serio);\r\nsysfs_remove_group(&serio->dev.kobj, &atkbd_attribute_group);\r\natkbd_disable(atkbd);\r\ninput_unregister_device(atkbd->dev);\r\ncancel_delayed_work_sync(&atkbd->event_work);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\nkfree(atkbd);\r\n}\r\nstatic void atkbd_apply_forced_release_keylist(struct atkbd* atkbd,\r\nconst void *data)\r\n{\r\nconst unsigned int *keys = data;\r\nunsigned int i;\r\nif (atkbd->set == 2)\r\nfor (i = 0; keys[i] != -1U; i++)\r\n__set_bit(keys[i], atkbd->force_release_mask);\r\n}\r\nstatic unsigned int atkbd_oqo_01plus_scancode_fixup(struct atkbd *atkbd,\r\nunsigned int code)\r\n{\r\nif (atkbd->translated && atkbd->emul == 1 &&\r\n(code == 0x64 || code == 0x65 || code == 0x66)) {\r\natkbd->emul = 0;\r\ncode |= 0x80;\r\n}\r\nreturn code;\r\n}\r\nstatic void atkbd_set_keycode_table(struct atkbd *atkbd)\r\n{\r\nunsigned int scancode;\r\nint i, j;\r\nmemset(atkbd->keycode, 0, sizeof(atkbd->keycode));\r\nbitmap_zero(atkbd->force_release_mask, ATKBD_KEYMAP_SIZE);\r\nif (atkbd->translated) {\r\nfor (i = 0; i < 128; i++) {\r\nscancode = atkbd_unxlate_table[i];\r\natkbd->keycode[i] = atkbd_set2_keycode[scancode];\r\natkbd->keycode[i | 0x80] = atkbd_set2_keycode[scancode | 0x80];\r\nif (atkbd->scroll)\r\nfor (j = 0; j < ARRAY_SIZE(atkbd_scroll_keys); j++)\r\nif ((scancode | 0x80) == atkbd_scroll_keys[j].set2)\r\natkbd->keycode[i | 0x80] = atkbd_scroll_keys[j].keycode;\r\n}\r\n} else if (atkbd->set == 3) {\r\nmemcpy(atkbd->keycode, atkbd_set3_keycode, sizeof(atkbd->keycode));\r\n} else {\r\nmemcpy(atkbd->keycode, atkbd_set2_keycode, sizeof(atkbd->keycode));\r\nif (atkbd->scroll)\r\nfor (i = 0; i < ARRAY_SIZE(atkbd_scroll_keys); i++) {\r\nscancode = atkbd_scroll_keys[i].set2;\r\natkbd->keycode[scancode] = atkbd_scroll_keys[i].keycode;\r\n}\r\n}\r\nscancode = atkbd_compat_scancode(atkbd, ATKBD_RET_HANGEUL);\r\natkbd->keycode[scancode] = KEY_HANGEUL;\r\n__set_bit(scancode, atkbd->force_release_mask);\r\nscancode = atkbd_compat_scancode(atkbd, ATKBD_RET_HANJA);\r\natkbd->keycode[scancode] = KEY_HANJA;\r\n__set_bit(scancode, atkbd->force_release_mask);\r\nif (atkbd_platform_fixup)\r\natkbd_platform_fixup(atkbd, atkbd_platform_fixup_data);\r\n}\r\nstatic void atkbd_set_device_attrs(struct atkbd *atkbd)\r\n{\r\nstruct input_dev *input_dev = atkbd->dev;\r\nint i;\r\nif (atkbd->extra)\r\nsnprintf(atkbd->name, sizeof(atkbd->name),\r\n"AT Set 2 Extra keyboard");\r\nelse\r\nsnprintf(atkbd->name, sizeof(atkbd->name),\r\n"AT %s Set %d keyboard",\r\natkbd->translated ? "Translated" : "Raw", atkbd->set);\r\nsnprintf(atkbd->phys, sizeof(atkbd->phys),\r\n"%s/input0", atkbd->ps2dev.serio->phys);\r\ninput_dev->name = atkbd->name;\r\ninput_dev->phys = atkbd->phys;\r\ninput_dev->id.bustype = BUS_I8042;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = atkbd->translated ? 1 : atkbd->set;\r\ninput_dev->id.version = atkbd->id;\r\ninput_dev->event = atkbd_event;\r\ninput_dev->dev.parent = &atkbd->ps2dev.serio->dev;\r\ninput_set_drvdata(input_dev, atkbd);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP) |\r\nBIT_MASK(EV_MSC);\r\nif (atkbd->write) {\r\ninput_dev->evbit[0] |= BIT_MASK(EV_LED);\r\ninput_dev->ledbit[0] = BIT_MASK(LED_NUML) |\r\nBIT_MASK(LED_CAPSL) | BIT_MASK(LED_SCROLLL);\r\n}\r\nif (atkbd->extra)\r\ninput_dev->ledbit[0] |= BIT_MASK(LED_COMPOSE) |\r\nBIT_MASK(LED_SUSPEND) | BIT_MASK(LED_SLEEP) |\r\nBIT_MASK(LED_MUTE) | BIT_MASK(LED_MISC);\r\nif (!atkbd->softrepeat) {\r\ninput_dev->rep[REP_DELAY] = 250;\r\ninput_dev->rep[REP_PERIOD] = 33;\r\n}\r\ninput_dev->mscbit[0] = atkbd->softraw ? BIT_MASK(MSC_SCAN) :\r\nBIT_MASK(MSC_RAW) | BIT_MASK(MSC_SCAN);\r\nif (atkbd->scroll) {\r\ninput_dev->evbit[0] |= BIT_MASK(EV_REL);\r\ninput_dev->relbit[0] = BIT_MASK(REL_WHEEL) |\r\nBIT_MASK(REL_HWHEEL);\r\n__set_bit(BTN_MIDDLE, input_dev->keybit);\r\n}\r\ninput_dev->keycode = atkbd->keycode;\r\ninput_dev->keycodesize = sizeof(unsigned short);\r\ninput_dev->keycodemax = ARRAY_SIZE(atkbd_set2_keycode);\r\nfor (i = 0; i < ATKBD_KEYMAP_SIZE; i++) {\r\nif (atkbd->keycode[i] != KEY_RESERVED &&\r\natkbd->keycode[i] != ATKBD_KEY_NULL &&\r\natkbd->keycode[i] < ATKBD_SPECIAL) {\r\n__set_bit(atkbd->keycode[i], input_dev->keybit);\r\n}\r\n}\r\n}\r\nstatic int atkbd_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct atkbd *atkbd;\r\nstruct input_dev *dev;\r\nint err = -ENOMEM;\r\natkbd = kzalloc(sizeof(struct atkbd), GFP_KERNEL);\r\ndev = input_allocate_device();\r\nif (!atkbd || !dev)\r\ngoto fail1;\r\natkbd->dev = dev;\r\nps2_init(&atkbd->ps2dev, serio);\r\nINIT_DELAYED_WORK(&atkbd->event_work, atkbd_event_work);\r\nmutex_init(&atkbd->mutex);\r\nswitch (serio->id.type) {\r\ncase SERIO_8042_XL:\r\natkbd->translated = true;\r\ncase SERIO_8042:\r\nif (serio->write)\r\natkbd->write = true;\r\nbreak;\r\n}\r\natkbd->softraw = atkbd_softraw;\r\natkbd->softrepeat = atkbd_softrepeat;\r\natkbd->scroll = atkbd_scroll;\r\nif (atkbd->softrepeat)\r\natkbd->softraw = true;\r\nserio_set_drvdata(serio, atkbd);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nif (atkbd->write) {\r\nif (atkbd_probe(atkbd)) {\r\nerr = -ENODEV;\r\ngoto fail3;\r\n}\r\natkbd->set = atkbd_select_set(atkbd, atkbd_set, atkbd_extra);\r\natkbd_reset_state(atkbd);\r\n} else {\r\natkbd->set = 2;\r\natkbd->id = 0xab00;\r\n}\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nerr = sysfs_create_group(&serio->dev.kobj, &atkbd_attribute_group);\r\nif (err)\r\ngoto fail3;\r\natkbd_enable(atkbd);\r\nif (serio->write)\r\natkbd_activate(atkbd);\r\nerr = input_register_device(atkbd->dev);\r\nif (err)\r\ngoto fail4;\r\nreturn 0;\r\nfail4: sysfs_remove_group(&serio->dev.kobj, &atkbd_attribute_group);\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(dev);\r\nkfree(atkbd);\r\nreturn err;\r\n}\r\nstatic int atkbd_reconnect(struct serio *serio)\r\n{\r\nstruct atkbd *atkbd = serio_get_drvdata(serio);\r\nstruct serio_driver *drv = serio->drv;\r\nint retval = -1;\r\nif (!atkbd || !drv) {\r\ndev_dbg(&serio->dev,\r\n"reconnect request, but serio is disconnected, ignoring...\n");\r\nreturn -1;\r\n}\r\nmutex_lock(&atkbd->mutex);\r\natkbd_disable(atkbd);\r\nif (atkbd->write) {\r\nif (atkbd_probe(atkbd))\r\ngoto out;\r\nif (atkbd->set != atkbd_select_set(atkbd, atkbd->set, atkbd->extra))\r\ngoto out;\r\natkbd_set_leds(atkbd);\r\nif (!atkbd->softrepeat)\r\natkbd_set_repeat_rate(atkbd);\r\n}\r\natkbd->xl_bit = 0;\r\natkbd->emul = 0;\r\natkbd_enable(atkbd);\r\nif (atkbd->write)\r\natkbd_activate(atkbd);\r\nretval = 0;\r\nout:\r\nmutex_unlock(&atkbd->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t atkbd_attr_show_helper(struct device *dev, char *buf,\r\nssize_t (*handler)(struct atkbd *, char *))\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct atkbd *atkbd = serio_get_drvdata(serio);\r\nreturn handler(atkbd, buf);\r\n}\r\nstatic ssize_t atkbd_attr_set_helper(struct device *dev, const char *buf, size_t count,\r\nssize_t (*handler)(struct atkbd *, const char *, size_t))\r\n{\r\nstruct serio *serio = to_serio_port(dev);\r\nstruct atkbd *atkbd = serio_get_drvdata(serio);\r\nint retval;\r\nretval = mutex_lock_interruptible(&atkbd->mutex);\r\nif (retval)\r\nreturn retval;\r\natkbd_disable(atkbd);\r\nretval = handler(atkbd, buf, count);\r\natkbd_enable(atkbd);\r\nmutex_unlock(&atkbd->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t atkbd_show_extra(struct atkbd *atkbd, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", atkbd->extra ? 1 : 0);\r\n}\r\nstatic ssize_t atkbd_set_extra(struct atkbd *atkbd, const char *buf, size_t count)\r\n{\r\nstruct input_dev *old_dev, *new_dev;\r\nunsigned int value;\r\nint err;\r\nbool old_extra;\r\nunsigned char old_set;\r\nif (!atkbd->write)\r\nreturn -EIO;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (atkbd->extra != value) {\r\nold_dev = atkbd->dev;\r\nold_extra = atkbd->extra;\r\nold_set = atkbd->set;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\natkbd->dev = new_dev;\r\natkbd->set = atkbd_select_set(atkbd, atkbd->set, value);\r\natkbd_reset_state(atkbd);\r\natkbd_activate(atkbd);\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nerr = input_register_device(atkbd->dev);\r\nif (err) {\r\ninput_free_device(new_dev);\r\natkbd->dev = old_dev;\r\natkbd->set = atkbd_select_set(atkbd, old_set, old_extra);\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nreturn err;\r\n}\r\ninput_unregister_device(old_dev);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atkbd_show_force_release(struct atkbd *atkbd, char *buf)\r\n{\r\nsize_t len = bitmap_scnlistprintf(buf, PAGE_SIZE - 2,\r\natkbd->force_release_mask, ATKBD_KEYMAP_SIZE);\r\nbuf[len++] = '\n';\r\nbuf[len] = '\0';\r\nreturn len;\r\n}\r\nstatic ssize_t atkbd_set_force_release(struct atkbd *atkbd,\r\nconst char *buf, size_t count)\r\n{\r\nDECLARE_BITMAP(new_mask, ATKBD_KEYMAP_SIZE);\r\nint err;\r\nerr = bitmap_parselist(buf, new_mask, ATKBD_KEYMAP_SIZE);\r\nif (err)\r\nreturn err;\r\nmemcpy(atkbd->force_release_mask, new_mask, sizeof(atkbd->force_release_mask));\r\nreturn count;\r\n}\r\nstatic ssize_t atkbd_show_scroll(struct atkbd *atkbd, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", atkbd->scroll ? 1 : 0);\r\n}\r\nstatic ssize_t atkbd_set_scroll(struct atkbd *atkbd, const char *buf, size_t count)\r\n{\r\nstruct input_dev *old_dev, *new_dev;\r\nunsigned int value;\r\nint err;\r\nbool old_scroll;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (atkbd->scroll != value) {\r\nold_dev = atkbd->dev;\r\nold_scroll = atkbd->scroll;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\natkbd->dev = new_dev;\r\natkbd->scroll = value;\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nerr = input_register_device(atkbd->dev);\r\nif (err) {\r\ninput_free_device(new_dev);\r\natkbd->scroll = old_scroll;\r\natkbd->dev = old_dev;\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nreturn err;\r\n}\r\ninput_unregister_device(old_dev);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atkbd_show_set(struct atkbd *atkbd, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", atkbd->set);\r\n}\r\nstatic ssize_t atkbd_set_set(struct atkbd *atkbd, const char *buf, size_t count)\r\n{\r\nstruct input_dev *old_dev, *new_dev;\r\nunsigned int value;\r\nint err;\r\nunsigned char old_set;\r\nbool old_extra;\r\nif (!atkbd->write)\r\nreturn -EIO;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value != 2 && value != 3)\r\nreturn -EINVAL;\r\nif (atkbd->set != value) {\r\nold_dev = atkbd->dev;\r\nold_extra = atkbd->extra;\r\nold_set = atkbd->set;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\natkbd->dev = new_dev;\r\natkbd->set = atkbd_select_set(atkbd, value, atkbd->extra);\r\natkbd_reset_state(atkbd);\r\natkbd_activate(atkbd);\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nerr = input_register_device(atkbd->dev);\r\nif (err) {\r\ninput_free_device(new_dev);\r\natkbd->dev = old_dev;\r\natkbd->set = atkbd_select_set(atkbd, old_set, old_extra);\r\natkbd_set_keycode_table(atkbd);\r\natkbd_set_device_attrs(atkbd);\r\nreturn err;\r\n}\r\ninput_unregister_device(old_dev);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atkbd_show_softrepeat(struct atkbd *atkbd, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", atkbd->softrepeat ? 1 : 0);\r\n}\r\nstatic ssize_t atkbd_set_softrepeat(struct atkbd *atkbd, const char *buf, size_t count)\r\n{\r\nstruct input_dev *old_dev, *new_dev;\r\nunsigned int value;\r\nint err;\r\nbool old_softrepeat, old_softraw;\r\nif (!atkbd->write)\r\nreturn -EIO;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (atkbd->softrepeat != value) {\r\nold_dev = atkbd->dev;\r\nold_softrepeat = atkbd->softrepeat;\r\nold_softraw = atkbd->softraw;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\natkbd->dev = new_dev;\r\natkbd->softrepeat = value;\r\nif (atkbd->softrepeat)\r\natkbd->softraw = true;\r\natkbd_set_device_attrs(atkbd);\r\nerr = input_register_device(atkbd->dev);\r\nif (err) {\r\ninput_free_device(new_dev);\r\natkbd->dev = old_dev;\r\natkbd->softrepeat = old_softrepeat;\r\natkbd->softraw = old_softraw;\r\natkbd_set_device_attrs(atkbd);\r\nreturn err;\r\n}\r\ninput_unregister_device(old_dev);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atkbd_show_softraw(struct atkbd *atkbd, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", atkbd->softraw ? 1 : 0);\r\n}\r\nstatic ssize_t atkbd_set_softraw(struct atkbd *atkbd, const char *buf, size_t count)\r\n{\r\nstruct input_dev *old_dev, *new_dev;\r\nunsigned int value;\r\nint err;\r\nbool old_softraw;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nif (atkbd->softraw != value) {\r\nold_dev = atkbd->dev;\r\nold_softraw = atkbd->softraw;\r\nnew_dev = input_allocate_device();\r\nif (!new_dev)\r\nreturn -ENOMEM;\r\natkbd->dev = new_dev;\r\natkbd->softraw = value;\r\natkbd_set_device_attrs(atkbd);\r\nerr = input_register_device(atkbd->dev);\r\nif (err) {\r\ninput_free_device(new_dev);\r\natkbd->dev = old_dev;\r\natkbd->softraw = old_softraw;\r\natkbd_set_device_attrs(atkbd);\r\nreturn err;\r\n}\r\ninput_unregister_device(old_dev);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atkbd_show_err_count(struct atkbd *atkbd, char *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", atkbd->err_count);\r\n}\r\nstatic int __init atkbd_setup_forced_release(const struct dmi_system_id *id)\r\n{\r\natkbd_platform_fixup = atkbd_apply_forced_release_keylist;\r\natkbd_platform_fixup_data = id->driver_data;\r\nreturn 1;\r\n}\r\nstatic int __init atkbd_setup_scancode_fixup(const struct dmi_system_id *id)\r\n{\r\natkbd_platform_scancode_fixup = id->driver_data;\r\nreturn 1;\r\n}\r\nstatic int __init atkbd_init(void)\r\n{\r\ndmi_check_system(atkbd_dmi_quirk_table);\r\nreturn serio_register_driver(&atkbd_drv);\r\n}\r\nstatic void __exit atkbd_exit(void)\r\n{\r\nserio_unregister_driver(&atkbd_drv);\r\n}
