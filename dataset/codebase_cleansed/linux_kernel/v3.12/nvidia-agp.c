static int nvidia_fetch_size(void)\r\n{\r\nint i;\r\nu8 size_value;\r\nstruct aper_size_info_8 *values;\r\npci_read_config_byte(agp_bridge->dev, NVIDIA_0_APSIZE, &size_value);\r\nsize_value &= 0x0f;\r\nvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (size_value == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nvidia_init_iorr(u32 base, u32 size)\r\n{\r\nu32 base_hi, base_lo;\r\nu32 mask_hi, mask_lo;\r\nu32 sys_hi, sys_lo;\r\nu32 iorr_addr, free_iorr_addr;\r\nfree_iorr_addr = AMD_K7_NUM_IORR;\r\nfor (iorr_addr = 0; iorr_addr < AMD_K7_NUM_IORR; iorr_addr++) {\r\nrdmsr(IORR_BASE0 + 2 * iorr_addr, base_lo, base_hi);\r\nrdmsr(IORR_MASK0 + 2 * iorr_addr, mask_lo, mask_hi);\r\nif ((base_lo & 0xfffff000) == (base & 0xfffff000))\r\nbreak;\r\nif ((mask_lo & 0x00000800) == 0)\r\nfree_iorr_addr = iorr_addr;\r\n}\r\nif (iorr_addr >= AMD_K7_NUM_IORR) {\r\niorr_addr = free_iorr_addr;\r\nif (iorr_addr >= AMD_K7_NUM_IORR)\r\nreturn -EINVAL;\r\n}\r\nbase_hi = 0x0;\r\nbase_lo = (base & ~0xfff) | 0x18;\r\nmask_hi = 0xf;\r\nmask_lo = ((~(size - 1)) & 0xfffff000) | 0x800;\r\nwrmsr(IORR_BASE0 + 2 * iorr_addr, base_lo, base_hi);\r\nwrmsr(IORR_MASK0 + 2 * iorr_addr, mask_lo, mask_hi);\r\nrdmsr(SYSCFG, sys_lo, sys_hi);\r\nsys_lo |= 0x00100000;\r\nwrmsr(SYSCFG, sys_lo, sys_hi);\r\nreturn 0;\r\n}\r\nstatic int nvidia_configure(void)\r\n{\r\nint i, rc, num_dirs;\r\nu32 apbase, aplimit;\r\nstruct aper_size_info_8 *current_size;\r\nu32 temp;\r\ncurrent_size = A_SIZE_8(agp_bridge->current_size);\r\npci_write_config_byte(agp_bridge->dev, NVIDIA_0_APSIZE,\r\ncurrent_size->size_value);\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &apbase);\r\napbase &= PCI_BASE_ADDRESS_MEM_MASK;\r\nagp_bridge->gart_bus_addr = apbase;\r\naplimit = apbase + (current_size->size * 1024 * 1024) - 1;\r\npci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_APBASE, apbase);\r\npci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_APLIMIT, aplimit);\r\npci_write_config_dword(nvidia_private.dev_3, NVIDIA_3_APBASE, apbase);\r\npci_write_config_dword(nvidia_private.dev_3, NVIDIA_3_APLIMIT, aplimit);\r\nif (0 != (rc = nvidia_init_iorr(apbase, current_size->size * 1024 * 1024)))\r\nreturn rc;\r\nnum_dirs = current_size->size / 64;\r\nnvidia_private.num_active_entries = current_size->num_entries;\r\nnvidia_private.pg_offset = 0;\r\nif (num_dirs == 0) {\r\nnum_dirs = 1;\r\nnvidia_private.num_active_entries /= (64 / current_size->size);\r\nnvidia_private.pg_offset = (apbase & (64 * 1024 * 1024 - 1) &\r\n~(current_size->size * 1024 * 1024 - 1)) / PAGE_SIZE;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\npci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_ATTBASE(i),\r\n(agp_bridge->gatt_bus_addr + (i % num_dirs) * 64 * 1024) | 1);\r\n}\r\npci_read_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, &temp);\r\npci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, temp | 0x11);\r\npci_read_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, &temp);\r\npci_write_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, temp | 0x100);\r\nnvidia_private.aperture =\r\n(volatile u32 __iomem *) ioremap(apbase, 33 * PAGE_SIZE);\r\nif (!nvidia_private.aperture)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void nvidia_cleanup(void)\r\n{\r\nstruct aper_size_info_8 *previous_size;\r\nu32 temp;\r\npci_read_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, &temp);\r\npci_write_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, temp & ~(0x100));\r\npci_read_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, &temp);\r\npci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, temp & ~(0x11));\r\niounmap((void __iomem *) nvidia_private.aperture);\r\nprevious_size = A_SIZE_8(agp_bridge->previous_size);\r\npci_write_config_byte(agp_bridge->dev, NVIDIA_0_APSIZE,\r\nprevious_size->size_value);\r\nnvidia_init_iorr(agp_bridge->gart_bus_addr,\r\nprevious_size->size * 1024 * 1024);\r\n}\r\nstatic int nvidia_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nint i, j;\r\nint mask_type;\r\nmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\r\nif (mask_type != 0 || type != mem->type)\r\nreturn -EINVAL;\r\nif (mem->page_count == 0)\r\nreturn 0;\r\nif ((pg_start + mem->page_count) >\r\n(nvidia_private.num_active_entries - agp_memory_reserved/PAGE_SIZE))\r\nreturn -EINVAL;\r\nfor (j = pg_start; j < (pg_start + mem->page_count); j++) {\r\nif (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+nvidia_private.pg_offset+j)))\r\nreturn -EBUSY;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\r\nwritel(agp_bridge->driver->mask_memory(agp_bridge,\r\npage_to_phys(mem->pages[i]), mask_type),\r\nagp_bridge->gatt_table+nvidia_private.pg_offset+j);\r\n}\r\nreadl(agp_bridge->gatt_table+nvidia_private.pg_offset+j - 1);\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int nvidia_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nint i;\r\nint mask_type;\r\nmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\r\nif (mask_type != 0 || type != mem->type)\r\nreturn -EINVAL;\r\nif (mem->page_count == 0)\r\nreturn 0;\r\nfor (i = pg_start; i < (mem->page_count + pg_start); i++)\r\nwritel(agp_bridge->scratch_page, agp_bridge->gatt_table+nvidia_private.pg_offset+i);\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic void nvidia_tlbflush(struct agp_memory *mem)\r\n{\r\nunsigned long end;\r\nu32 wbc_reg, temp;\r\nint i;\r\nif (nvidia_private.wbc_mask) {\r\npci_read_config_dword(nvidia_private.dev_1, NVIDIA_1_WBC, &wbc_reg);\r\nwbc_reg |= nvidia_private.wbc_mask;\r\npci_write_config_dword(nvidia_private.dev_1, NVIDIA_1_WBC, wbc_reg);\r\nend = jiffies + 3*HZ;\r\ndo {\r\npci_read_config_dword(nvidia_private.dev_1,\r\nNVIDIA_1_WBC, &wbc_reg);\r\nif (time_before_eq(end, jiffies)) {\r\nprintk(KERN_ERR PFX\r\n"TLB flush took more than 3 seconds.\n");\r\n}\r\n} while (wbc_reg & nvidia_private.wbc_mask);\r\n}\r\nfor (i = 0; i < 32 + 1; i++)\r\ntemp = readl(nvidia_private.aperture+(i * PAGE_SIZE / sizeof(u32)));\r\nfor (i = 0; i < 32 + 1; i++)\r\ntemp = readl(nvidia_private.aperture+(i * PAGE_SIZE / sizeof(u32)));\r\n}\r\nstatic int agp_nvidia_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\nnvidia_private.dev_1 =\r\npci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(0, 1));\r\nnvidia_private.dev_2 =\r\npci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(0, 2));\r\nnvidia_private.dev_3 =\r\npci_get_bus_and_slot((unsigned int)pdev->bus->number, PCI_DEVFN(30, 0));\r\nif (!nvidia_private.dev_1 || !nvidia_private.dev_2 || !nvidia_private.dev_3) {\r\nprintk(KERN_INFO PFX "Detected an NVIDIA nForce/nForce2 "\r\n"chipset, but could not find the secondary devices.\n");\r\nreturn -ENODEV;\r\n}\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_NVIDIA_NFORCE:\r\nprintk(KERN_INFO PFX "Detected NVIDIA nForce chipset\n");\r\nnvidia_private.wbc_mask = 0x00010000;\r\nbreak;\r\ncase PCI_DEVICE_ID_NVIDIA_NFORCE2:\r\nprintk(KERN_INFO PFX "Detected NVIDIA nForce2 chipset\n");\r\nnvidia_private.wbc_mask = 0x80000000;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "Unsupported NVIDIA chipset (device id: %04x)\n",\r\npdev->device);\r\nreturn -ENODEV;\r\n}\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver = &nvidia_driver;\r\nbridge->dev_private_data = &nvidia_private,\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\npci_read_config_dword(pdev,\r\nbridge->capndx+PCI_AGP_STATUS,\r\n&bridge->mode);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void agp_nvidia_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int agp_nvidia_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int agp_nvidia_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nnvidia_configure();\r\nreturn 0;\r\n}\r\nstatic int __init agp_nvidia_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_nvidia_pci_driver);\r\n}\r\nstatic void __exit agp_nvidia_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_nvidia_pci_driver);\r\npci_dev_put(nvidia_private.dev_1);\r\npci_dev_put(nvidia_private.dev_2);\r\npci_dev_put(nvidia_private.dev_3);\r\n}
