static int omap34_xxbridge_suspend_lockout(struct omap34_xx_bridge_suspend_data\r\n*s, struct file *f)\r\n{\r\nif ((s)->suspended) {\r\nif ((f)->f_flags & O_NONBLOCK)\r\nreturn -EPERM;\r\nwait_event_interruptible((s)->suspend_wq, (s)->suspended == 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bridge_open(struct inode *ip, struct file *filp)\r\n{\r\nint status = 0;\r\nstruct process_context *pr_ctxt = NULL;\r\n#ifdef CONFIG_TIDSPBRIDGE_RECOVERY\r\nif (recover) {\r\nif (filp->f_flags & O_NONBLOCK ||\r\nwait_for_completion_interruptible(&bridge_open_comp))\r\nreturn -EBUSY;\r\n}\r\n#endif\r\npr_ctxt = kzalloc(sizeof(struct process_context), GFP_KERNEL);\r\nif (!pr_ctxt)\r\nreturn -ENOMEM;\r\npr_ctxt->res_state = PROC_RES_ALLOCATED;\r\nspin_lock_init(&pr_ctxt->dmm_map_lock);\r\nINIT_LIST_HEAD(&pr_ctxt->dmm_map_list);\r\nspin_lock_init(&pr_ctxt->dmm_rsv_lock);\r\nINIT_LIST_HEAD(&pr_ctxt->dmm_rsv_list);\r\npr_ctxt->node_id = kzalloc(sizeof(struct idr), GFP_KERNEL);\r\nif (!pr_ctxt->node_id) {\r\nstatus = -ENOMEM;\r\ngoto err1;\r\n}\r\nidr_init(pr_ctxt->node_id);\r\npr_ctxt->stream_id = kzalloc(sizeof(struct idr), GFP_KERNEL);\r\nif (!pr_ctxt->stream_id) {\r\nstatus = -ENOMEM;\r\ngoto err2;\r\n}\r\nidr_init(pr_ctxt->stream_id);\r\nfilp->private_data = pr_ctxt;\r\n#ifdef CONFIG_TIDSPBRIDGE_RECOVERY\r\natomic_inc(&bridge_cref);\r\n#endif\r\nreturn 0;\r\nerr2:\r\nkfree(pr_ctxt->node_id);\r\nerr1:\r\nkfree(pr_ctxt);\r\nreturn status;\r\n}\r\nstatic int bridge_release(struct inode *ip, struct file *filp)\r\n{\r\nint status = 0;\r\nstruct process_context *pr_ctxt;\r\nif (!filp->private_data) {\r\nstatus = -EIO;\r\ngoto err;\r\n}\r\npr_ctxt = filp->private_data;\r\nflush_signals(current);\r\ndrv_remove_all_resources(pr_ctxt);\r\nproc_detach(pr_ctxt);\r\nkfree(pr_ctxt->node_id);\r\nkfree(pr_ctxt->stream_id);\r\nkfree(pr_ctxt);\r\nfilp->private_data = NULL;\r\nerr:\r\n#ifdef CONFIG_TIDSPBRIDGE_RECOVERY\r\nif (!atomic_dec_return(&bridge_cref))\r\ncomplete(&bridge_comp);\r\n#endif\r\nreturn status;\r\n}\r\nstatic long bridge_ioctl(struct file *filp, unsigned int code,\r\nunsigned long args)\r\n{\r\nint status;\r\nu32 retval = 0;\r\nunion trapped_args buf_in;\r\n#ifdef CONFIG_TIDSPBRIDGE_RECOVERY\r\nif (recover) {\r\nstatus = -EIO;\r\ngoto err;\r\n}\r\n#endif\r\n#ifdef CONFIG_PM\r\nstatus = omap34_xxbridge_suspend_lockout(&bridge_suspend_data, filp);\r\nif (status != 0)\r\nreturn status;\r\n#endif\r\nif (!filp->private_data) {\r\nstatus = -EIO;\r\ngoto err;\r\n}\r\nstatus = copy_from_user(&buf_in, (union trapped_args *)args,\r\nsizeof(union trapped_args));\r\nif (!status) {\r\nstatus = api_call_dev_ioctl(code, &buf_in, &retval,\r\nfilp->private_data);\r\nif (!status) {\r\nstatus = retval;\r\n} else {\r\ndev_dbg(bridge, "%s: IOCTL Failed, code: 0x%x "\r\n"status 0x%x\n", __func__, code, status);\r\nstatus = -1;\r\n}\r\n}\r\nerr:\r\nreturn status;\r\n}\r\nstatic int bridge_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nu32 status;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\ndev_dbg(bridge, "%s: vm filp %p start %lx end %lx page_prot %ulx "\r\n"flags %lx\n", __func__, filp,\r\nvma->vm_start, vma->vm_end, vma->vm_page_prot,\r\nvma->vm_flags);\r\nstatus = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\nif (status != 0)\r\nstatus = -EAGAIN;\r\nreturn status;\r\n}\r\nstatic void bridge_recover(struct work_struct *work)\r\n{\r\nstruct dev_object *dev;\r\nstruct cfg_devnode *dev_node;\r\nif (atomic_read(&bridge_cref)) {\r\nINIT_COMPLETION(bridge_comp);\r\nwhile (!wait_for_completion_timeout(&bridge_comp,\r\nmsecs_to_jiffies(REC_TIMEOUT)))\r\npr_info("%s:%d handle(s) still opened\n",\r\n__func__, atomic_read(&bridge_cref));\r\n}\r\ndev = dev_get_first();\r\ndev_get_dev_node(dev, &dev_node);\r\nif (!dev_node || proc_auto_start(dev_node, dev))\r\npr_err("DSP could not be restarted\n");\r\nrecover = false;\r\ncomplete_all(&bridge_open_comp);\r\n}\r\nvoid bridge_recover_schedule(void)\r\n{\r\nINIT_COMPLETION(bridge_open_comp);\r\nrecover = true;\r\nqueue_work(bridge_rec_queue, &bridge_recovery_work);\r\n}\r\nstatic int dspbridge_scale_notification(struct notifier_block *op,\r\nunsigned long val, void *ptr)\r\n{\r\nstruct omap_dsp_platform_data *pdata =\r\nomap_dspbridge_dev->dev.platform_data;\r\nif (CPUFREQ_POSTCHANGE == val && pdata->dsp_get_opp)\r\npwr_pm_post_scale(PRCM_VDD1, pdata->dsp_get_opp());\r\nreturn 0;\r\n}\r\nstatic int omap3_bridge_startup(struct platform_device *pdev)\r\n{\r\nstruct omap_dsp_platform_data *pdata = pdev->dev.platform_data;\r\nstruct drv_data *drv_datap = NULL;\r\nu32 phys_membase, phys_memsize;\r\nint err;\r\n#ifdef CONFIG_TIDSPBRIDGE_RECOVERY\r\nbridge_rec_queue = create_workqueue("bridge_rec_queue");\r\nINIT_WORK(&bridge_recovery_work, bridge_recover);\r\nINIT_COMPLETION(bridge_comp);\r\n#endif\r\n#ifdef CONFIG_PM\r\nbridge_suspend_data.suspended = 0;\r\ninit_waitqueue_head(&bridge_suspend_data.suspend_wq);\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nfor (i = 0; i < 6; i++)\r\npdata->mpu_speed[i] = vdd1_rate_table_bridge[i].rate;\r\nerr = cpufreq_register_notifier(&iva_clk_notifier,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nif (err)\r\npr_err("%s: clk_notifier_register failed for iva2_ck\n",\r\n__func__);\r\n#endif\r\n#endif\r\ndsp_clk_init();\r\ndrv_datap = kzalloc(sizeof(struct drv_data), GFP_KERNEL);\r\nif (!drv_datap) {\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\ndrv_datap->shm_size = shm_size;\r\ndrv_datap->tc_wordswapon = tc_wordswapon;\r\nif (base_img) {\r\ndrv_datap->base_img = kstrdup(base_img, GFP_KERNEL);\r\nif (!drv_datap->base_img) {\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\n}\r\ndev_set_drvdata(bridge, drv_datap);\r\nif (shm_size < 0x10000) {\r\nerr = -EINVAL;\r\npr_err("%s: shm size must be at least 64 KB\n", __func__);\r\ngoto err3;\r\n}\r\ndev_dbg(bridge, "%s: requested shm_size = 0x%x\n", __func__, shm_size);\r\nphys_membase = pdata->phys_mempool_base;\r\nphys_memsize = pdata->phys_mempool_size;\r\nif (phys_membase > 0 && phys_memsize > 0)\r\nmem_ext_phys_pool_init(phys_membase, phys_memsize);\r\nif (tc_wordswapon)\r\ndev_dbg(bridge, "%s: TC Word Swap is enabled\n", __func__);\r\ndriver_context = dsp_init(&err);\r\nif (err) {\r\npr_err("DSP Bridge driver initialization failed\n");\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\nmem_ext_phys_pool_release();\r\nerr3:\r\nkfree(drv_datap->base_img);\r\nerr2:\r\nkfree(drv_datap);\r\nerr1:\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\ncpufreq_unregister_notifier(&iva_clk_notifier,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n#endif\r\ndsp_clk_exit();\r\nreturn err;\r\n}\r\nstatic int omap34_xx_bridge_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\ndev_t dev = 0;\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nint i = 0;\r\n#endif\r\nomap_dspbridge_dev = pdev;\r\nbridge = &omap_dspbridge_dev->dev;\r\nerr = omap3_bridge_startup(pdev);\r\nif (err)\r\ngoto err1;\r\nerr = alloc_chrdev_region(&dev, 0, 1, "DspBridge");\r\nif (err) {\r\npr_err("%s: Can't get major %d\n", __func__, driver_major);\r\ngoto err1;\r\n}\r\ncdev_init(&bridge_cdev, &bridge_fops);\r\nbridge_cdev.owner = THIS_MODULE;\r\nerr = cdev_add(&bridge_cdev, dev, 1);\r\nif (err) {\r\npr_err("%s: Failed to add bridge device\n", __func__);\r\ngoto err2;\r\n}\r\nbridge_class = class_create(THIS_MODULE, "ti_bridge");\r\nif (IS_ERR(bridge_class)) {\r\npr_err("%s: Error creating bridge class\n", __func__);\r\nerr = PTR_ERR(bridge_class);\r\ngoto err3;\r\n}\r\ndriver_major = MAJOR(dev);\r\ndevice_create(bridge_class, NULL, MKDEV(driver_major, 0),\r\nNULL, "DspBridge");\r\npr_info("DSP Bridge driver loaded\n");\r\nreturn 0;\r\nerr3:\r\ncdev_del(&bridge_cdev);\r\nerr2:\r\nunregister_chrdev_region(dev, 1);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic int omap34_xx_bridge_remove(struct platform_device *pdev)\r\n{\r\ndev_t devno;\r\nint status = 0;\r\nstruct drv_data *drv_datap = dev_get_drvdata(bridge);\r\nif (!drv_datap || !drv_datap->drv_object) {\r\nstatus = -ENODATA;\r\npr_err("%s: Failed to retrieve the object handle\n", __func__);\r\ngoto func_cont;\r\n}\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nif (cpufreq_unregister_notifier(&iva_clk_notifier,\r\nCPUFREQ_TRANSITION_NOTIFIER))\r\npr_err("%s: cpufreq_unregister_notifier failed for iva2_ck\n",\r\n__func__);\r\n#endif\r\nif (driver_context) {\r\ndsp_deinit(driver_context);\r\ndriver_context = 0;\r\n}\r\nkfree(drv_datap);\r\ndev_set_drvdata(bridge, NULL);\r\nfunc_cont:\r\nmem_ext_phys_pool_release();\r\ndsp_clk_exit();\r\ndevno = MKDEV(driver_major, 0);\r\ncdev_del(&bridge_cdev);\r\nunregister_chrdev_region(devno, 1);\r\nif (bridge_class) {\r\ndevice_destroy(bridge_class, MKDEV(driver_major, 0));\r\nclass_destroy(bridge_class);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bridge_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nu32 status;\r\nu32 command = PWR_EMERGENCYDEEPSLEEP;\r\nstatus = pwr_sleep_dsp(command, time_out);\r\nif (status)\r\nreturn -1;\r\nbridge_suspend_data.suspended = 1;\r\nreturn 0;\r\n}\r\nstatic int bridge_resume(struct platform_device *pdev)\r\n{\r\nu32 status;\r\nstatus = pwr_wake_dsp(time_out);\r\nif (status)\r\nreturn -1;\r\nbridge_suspend_data.suspended = 0;\r\nwake_up(&bridge_suspend_data.suspend_wq);\r\nreturn 0;\r\n}\r\nint drv_remove_all_resources(void *process_ctxt)\r\n{\r\nint status = 0;\r\nstruct process_context *ctxt = (struct process_context *)process_ctxt;\r\ndrv_remove_all_strm_res_elements(ctxt);\r\ndrv_remove_all_node_res_elements(ctxt);\r\ndrv_remove_all_dmm_res_elements(ctxt);\r\nctxt->res_state = PROC_RES_FREED;\r\nreturn status;\r\n}
