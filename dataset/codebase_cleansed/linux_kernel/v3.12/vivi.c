static const struct vivi_fmt *__get_format(u32 pixelformat)\r\n{\r\nconst struct vivi_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < ARRAY_SIZE(formats); k++) {\r\nfmt = &formats[k];\r\nif (fmt->fourcc == pixelformat)\r\nbreak;\r\n}\r\nif (k == ARRAY_SIZE(formats))\r\nreturn NULL;\r\nreturn &formats[k];\r\n}\r\nstatic const struct vivi_fmt *get_format(struct v4l2_format *f)\r\n{\r\nreturn __get_format(f->fmt.pix.pixelformat);\r\n}\r\nstatic void precalculate_bars(struct vivi_dev *dev)\r\n{\r\nu8 r, g, b;\r\nint k, is_yuv;\r\nfor (k = 0; k < 9; k++) {\r\nr = bars[dev->input].bar[k][0];\r\ng = bars[dev->input].bar[k][1];\r\nb = bars[dev->input].bar[k][2];\r\nis_yuv = dev->fmt->is_yuv;\r\nswitch (dev->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\nr >>= 3;\r\ng >>= 2;\r\nb >>= 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncase V4L2_PIX_FMT_RGB555X:\r\nr >>= 3;\r\ng >>= 3;\r\nb >>= 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncase V4L2_PIX_FMT_VYUY:\r\ncase V4L2_PIX_FMT_RGB24:\r\ncase V4L2_PIX_FMT_BGR24:\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\nbreak;\r\n}\r\nif (is_yuv) {\r\ndev->bars[k][0] = TO_Y(r, g, b);\r\ndev->bars[k][1] = TO_U(r, g, b);\r\ndev->bars[k][2] = TO_V(r, g, b);\r\n} else {\r\ndev->bars[k][0] = r;\r\ndev->bars[k][1] = g;\r\ndev->bars[k][2] = b;\r\n}\r\n}\r\n}\r\nstatic void gen_twopix(struct vivi_dev *dev, u8 *buf, int colorpos, bool odd)\r\n{\r\nu8 r_y, g_u, b_v;\r\nu8 alpha = dev->alpha_component;\r\nint color;\r\nu8 *p;\r\nr_y = dev->bars[colorpos][0];\r\ng_u = dev->bars[colorpos][1];\r\nb_v = dev->bars[colorpos][2];\r\nfor (color = 0; color < dev->pixelsize; color++) {\r\np = buf + color;\r\nswitch (dev->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nswitch (color) {\r\ncase 0:\r\n*p = r_y;\r\nbreak;\r\ncase 1:\r\n*p = odd ? b_v : g_u;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\nswitch (color) {\r\ncase 0:\r\n*p = odd ? b_v : g_u;\r\nbreak;\r\ncase 1:\r\n*p = r_y;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_YVYU:\r\nswitch (color) {\r\ncase 0:\r\n*p = r_y;\r\nbreak;\r\ncase 1:\r\n*p = odd ? g_u : b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_VYUY:\r\nswitch (color) {\r\ncase 0:\r\n*p = odd ? g_u : b_v;\r\nbreak;\r\ncase 1:\r\n*p = r_y;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nswitch (color) {\r\ncase 0:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\ncase 1:\r\n*p = (r_y << 3) | (g_u >> 3);\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565X:\r\nswitch (color) {\r\ncase 0:\r\n*p = (r_y << 3) | (g_u >> 3);\r\nbreak;\r\ncase 1:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\nswitch (color) {\r\ncase 0:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\ncase 1:\r\n*p = (alpha & 0x80) | (r_y << 2) | (g_u >> 3);\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555X:\r\nswitch (color) {\r\ncase 0:\r\n*p = (alpha & 0x80) | (r_y << 2) | (g_u >> 3);\r\nbreak;\r\ncase 1:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\nswitch (color) {\r\ncase 0:\r\n*p = r_y;\r\nbreak;\r\ncase 1:\r\n*p = g_u;\r\nbreak;\r\ncase 2:\r\n*p = b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR24:\r\nswitch (color) {\r\ncase 0:\r\n*p = b_v;\r\nbreak;\r\ncase 1:\r\n*p = g_u;\r\nbreak;\r\ncase 2:\r\n*p = r_y;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\nswitch (color) {\r\ncase 0:\r\n*p = alpha;\r\nbreak;\r\ncase 1:\r\n*p = r_y;\r\nbreak;\r\ncase 2:\r\n*p = g_u;\r\nbreak;\r\ncase 3:\r\n*p = b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\nswitch (color) {\r\ncase 0:\r\n*p = b_v;\r\nbreak;\r\ncase 1:\r\n*p = g_u;\r\nbreak;\r\ncase 2:\r\n*p = r_y;\r\nbreak;\r\ncase 3:\r\n*p = alpha;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void precalculate_line(struct vivi_dev *dev)\r\n{\r\nunsigned pixsize = dev->pixelsize;\r\nunsigned pixsize2 = 2*pixsize;\r\nint colorpos;\r\nu8 *pos;\r\nfor (colorpos = 0; colorpos < 16; ++colorpos) {\r\nu8 pix[8];\r\nint wstart = colorpos * dev->width / 8;\r\nint wend = (colorpos+1) * dev->width / 8;\r\nint w;\r\ngen_twopix(dev, &pix[0], colorpos % 8, 0);\r\ngen_twopix(dev, &pix[pixsize], colorpos % 8, 1);\r\nfor (w = wstart/2*2, pos = dev->line + w*pixsize; w < wend; w += 2, pos += pixsize2)\r\nmemcpy(pos, pix, pixsize2);\r\n}\r\n}\r\nstatic void gen_text(struct vivi_dev *dev, char *basep,\r\nint y, int x, char *text)\r\n{\r\nint line;\r\nunsigned int width = dev->width;\r\nif (y + 16 >= dev->height || x + strlen(text) * 8 >= width)\r\nreturn;\r\n#define PRINTSTR(PIXTYPE) do { \\r\nPIXTYPE fg; \\r\nPIXTYPE bg; \\r\nmemcpy(&fg, &dev->textfg, sizeof(PIXTYPE)); \\r\nmemcpy(&bg, &dev->textbg, sizeof(PIXTYPE)); \\r\n\\r\nfor (line = 0; line < 16; line++) { \\r\nPIXTYPE *pos = (PIXTYPE *)( basep + ((y + line) * width + x) * sizeof(PIXTYPE) ); \\r\nu8 *s; \\r\n\\r\nfor (s = text; *s; s++) { \\r\nu8 chr = font8x16[*s * 16 + line]; \\r\n\\r\npos[0] = (chr & (0x01 << 7) ? fg : bg); \\r\npos[1] = (chr & (0x01 << 6) ? fg : bg); \\r\npos[2] = (chr & (0x01 << 5) ? fg : bg); \\r\npos[3] = (chr & (0x01 << 4) ? fg : bg); \\r\npos[4] = (chr & (0x01 << 3) ? fg : bg); \\r\npos[5] = (chr & (0x01 << 2) ? fg : bg); \\r\npos[6] = (chr & (0x01 << 1) ? fg : bg); \\r\npos[7] = (chr & (0x01 << 0) ? fg : bg); \\r\n\\r\npos += 8; \\r\n} \\r\n} \\r\n} while (0)\r\nswitch (dev->pixelsize) {\r\ncase 2:\r\nPRINTSTR(u16); break;\r\ncase 4:\r\nPRINTSTR(u32); break;\r\ncase 3:\r\nPRINTSTR(x24); break;\r\n}\r\n}\r\nstatic void vivi_fillbuff(struct vivi_dev *dev, struct vivi_buffer *buf)\r\n{\r\nint stride = dev->width * dev->pixelsize;\r\nint hmax = dev->height;\r\nvoid *vbuf = vb2_plane_vaddr(&buf->vb, 0);\r\nunsigned ms;\r\nchar str[100];\r\nint h, line = 1;\r\nu8 *linestart;\r\ns32 gain;\r\nif (!vbuf)\r\nreturn;\r\nlinestart = dev->line + (dev->mv_count % dev->width) * dev->pixelsize;\r\nfor (h = 0; h < hmax; h++)\r\nmemcpy(vbuf + h * stride, linestart, stride);\r\ngen_twopix(dev, (u8 *)&dev->textbg, TEXT_BLACK, 0);\r\ngen_twopix(dev, (u8 *)&dev->textfg, WHITE, 0);\r\ndev->ms += jiffies_to_msecs(jiffies - dev->jiffies);\r\ndev->jiffies = jiffies;\r\nms = dev->ms;\r\nsnprintf(str, sizeof(str), " %02d:%02d:%02d:%03d ",\r\n(ms / (60 * 60 * 1000)) % 24,\r\n(ms / (60 * 1000)) % 60,\r\n(ms / 1000) % 60,\r\nms % 1000);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " %dx%d, input %d ",\r\ndev->width, dev->height, dev->input);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\ngain = v4l2_ctrl_g_ctrl(dev->gain);\r\nmutex_lock(dev->ctrl_handler.lock);\r\nsnprintf(str, sizeof(str), " brightness %3d, contrast %3d, saturation %3d, hue %d ",\r\ndev->brightness->cur.val,\r\ndev->contrast->cur.val,\r\ndev->saturation->cur.val,\r\ndev->hue->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " autogain %d, gain %3d, volume %3d, alpha 0x%02x ",\r\ndev->autogain->cur.val, gain, dev->volume->cur.val,\r\ndev->alpha->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " int32 %d, int64 %lld, bitmask %08x ",\r\ndev->int32->cur.val,\r\ndev->int64->cur.val64,\r\ndev->bitmask->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " boolean %d, menu %s, string \"%s\" ",\r\ndev->boolean->cur.val,\r\ndev->menu->qmenu[dev->menu->cur.val],\r\ndev->string->cur.string);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " integer_menu %lld, value %d ",\r\ndev->int_menu->qmenu_int[dev->int_menu->cur.val],\r\ndev->int_menu->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nmutex_unlock(dev->ctrl_handler.lock);\r\nif (dev->button_pressed) {\r\ndev->button_pressed--;\r\nsnprintf(str, sizeof(str), " button pressed!");\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\n}\r\ndev->mv_count += 2;\r\nbuf->vb.v4l2_buf.field = V4L2_FIELD_INTERLACED;\r\ndev->field_count++;\r\nbuf->vb.v4l2_buf.sequence = dev->field_count >> 1;\r\nv4l2_get_timestamp(&buf->vb.v4l2_buf.timestamp);\r\n}\r\nstatic void vivi_thread_tick(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\nstruct vivi_buffer *buf;\r\nunsigned long flags = 0;\r\ndprintk(dev, 1, "Thread tick\n");\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (list_empty(&dma_q->active)) {\r\ndprintk(dev, 1, "No active queue to serve\n");\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn;\r\n}\r\nbuf = list_entry(dma_q->active.next, struct vivi_buffer, list);\r\nlist_del(&buf->list);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nv4l2_get_timestamp(&buf->vb.v4l2_buf.timestamp);\r\nvivi_fillbuff(dev, buf);\r\ndprintk(dev, 1, "filled buffer %p\n", buf);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);\r\ndprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);\r\n}\r\nstatic void vivi_sleep(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\nint timeout;\r\nDECLARE_WAITQUEUE(wait, current);\r\ndprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,\r\n(unsigned long)dma_q);\r\nadd_wait_queue(&dma_q->wq, &wait);\r\nif (kthread_should_stop())\r\ngoto stop_task;\r\ntimeout = msecs_to_jiffies(frames_to_ms(dev, 1));\r\nvivi_thread_tick(dev);\r\nschedule_timeout_interruptible(timeout);\r\nstop_task:\r\nremove_wait_queue(&dma_q->wq, &wait);\r\ntry_to_freeze();\r\n}\r\nstatic int vivi_thread(void *data)\r\n{\r\nstruct vivi_dev *dev = data;\r\ndprintk(dev, 1, "thread started\n");\r\nset_freezable();\r\nfor (;;) {\r\nvivi_sleep(dev);\r\nif (kthread_should_stop())\r\nbreak;\r\n}\r\ndprintk(dev, 1, "thread: exit\n");\r\nreturn 0;\r\n}\r\nstatic int vivi_start_generating(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\ndprintk(dev, 1, "%s\n", __func__);\r\ndev->ms = 0;\r\ndev->mv_count = 0;\r\ndev->jiffies = jiffies;\r\ndma_q->frame = 0;\r\ndma_q->ini_jiffies = jiffies;\r\ndma_q->kthread = kthread_run(vivi_thread, dev, "%s",\r\ndev->v4l2_dev.name);\r\nif (IS_ERR(dma_q->kthread)) {\r\nv4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");\r\nreturn PTR_ERR(dma_q->kthread);\r\n}\r\nwake_up_interruptible(&dma_q->wq);\r\ndprintk(dev, 1, "returning from %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void vivi_stop_generating(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dma_q->kthread) {\r\nkthread_stop(dma_q->kthread);\r\ndma_q->kthread = NULL;\r\n}\r\nwhile (!list_empty(&dma_q->active)) {\r\nstruct vivi_buffer *buf;\r\nbuf = list_entry(dma_q->active.next, struct vivi_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\ndprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);\r\n}\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\nunsigned long size;\r\nif (fmt)\r\nsize = fmt->fmt.pix.sizeimage;\r\nelse\r\nsize = dev->width * dev->height * dev->pixelsize;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nif (0 == *nbuffers)\r\n*nbuffers = 32;\r\nwhile (size * *nbuffers > vid_limit * 1024 * 1024)\r\n(*nbuffers)--;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\ndprintk(dev, 1, "%s, count=%d, size=%ld\n", __func__,\r\n*nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivi_buffer *buf = container_of(vb, struct vivi_buffer, vb);\r\nunsigned long size;\r\ndprintk(dev, 1, "%s, field=%d\n", __func__, vb->v4l2_buf.field);\r\nBUG_ON(NULL == dev->fmt);\r\nif (dev->width < 48 || dev->width > MAX_WIDTH ||\r\ndev->height < 32 || dev->height > MAX_HEIGHT)\r\nreturn -EINVAL;\r\nsize = dev->width * dev->height * dev->pixelsize;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndprintk(dev, 1, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buf->vb, 0, size);\r\nbuf->fmt = dev->fmt;\r\nprecalculate_bars(dev);\r\nprecalculate_line(dev);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivi_buffer *buf = container_of(vb, struct vivi_buffer, vb);\r\nstruct vivi_dmaqueue *vidq = &dev->vidq;\r\nunsigned long flags = 0;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nlist_add_tail(&buf->list, &vidq->active);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nreturn vivi_start_generating(dev);\r\n}\r\nstatic int stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nvivi_stop_generating(dev);\r\nreturn 0;\r\n}\r\nstatic void vivi_lock(struct vb2_queue *vq)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\nmutex_lock(&dev->mutex);\r\n}\r\nstatic void vivi_unlock(struct vb2_queue *vq)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\nmutex_unlock(&dev->mutex);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "vivi");\r\nstrcpy(cap->card, "vivi");\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", dev->v4l2_dev.name);\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nconst struct vivi_fmt *fmt;\r\nif (f->index >= ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nfmt = &formats[f->index];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * dev->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nif (dev->fmt->is_yuv)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nconst struct vivi_fmt *fmt;\r\nfmt = get_format(f);\r\nif (!fmt) {\r\ndprintk(dev, 1, "Fourcc format (0x%08x) unknown.\n",\r\nf->fmt.pix.pixelformat);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;\r\nfmt = get_format(f);\r\n}\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, MAX_WIDTH, 2,\r\n&f->fmt.pix.height, 32, MAX_HEIGHT, 0, 0);\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nif (fmt->is_yuv)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstruct vb2_queue *q = &dev->vb_vidq;\r\nint ret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vb2_is_busy(q)) {\r\ndprintk(dev, 1, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ndev->fmt = get_format(f);\r\ndev->pixelsize = dev->fmt->depth / 8;\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstatic const struct v4l2_frmsize_stepwise sizes = {\r\n48, MAX_WIDTH, 4,\r\n32, MAX_HEIGHT, 1\r\n};\r\nint i;\r\nif (fsize->index)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fsize->pixel_format)\r\nbreak;\r\nif (i == ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfsize->stepwise = sizes;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index >= NUM_INPUTS)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\nsprintf(inp->name, "Camera %u", inp->index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\n*i = dev->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nif (i >= NUM_INPUTS)\r\nreturn -EINVAL;\r\nif (i == dev->input)\r\nreturn 0;\r\ndev->input = i;\r\nv4l2_ctrl_modify_range(dev->brightness,\r\n128 * i, 255 + 128 * i, 1, 127 + 128 * i);\r\nprecalculate_bars(dev);\r\nprecalculate_line(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nconst struct vivi_fmt *fmt;\r\nif (fival->index)\r\nreturn -EINVAL;\r\nfmt = __get_format(fival->pixel_format);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nfival->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;\r\nfival->stepwise.min = tpf_min;\r\nfival->stepwise.max = tpf_max;\r\nfival->stepwise.step = (struct v4l2_fract) {1, 1};\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.capture.timeperframe = dev->timeperframe;\r\nparm->parm.capture.readbuffers = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstruct v4l2_fract tpf;\r\nif (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ntpf = parm->parm.capture.timeperframe;\r\ntpf = tpf.denominator ? tpf : tpf_default;\r\ntpf = FRACT_CMP(tpf, <, tpf_min) ? tpf_min : tpf;\r\ntpf = FRACT_CMP(tpf, >, tpf_max) ? tpf_max : tpf;\r\ndev->timeperframe = tpf;\r\nparm->parm.capture.timeperframe = tpf;\r\nparm->parm.capture.readbuffers = 1;\r\nreturn 0;\r\n}\r\nstatic int vivi_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vivi_dev *dev = container_of(ctrl->handler, struct vivi_dev, ctrl_handler);\r\nif (ctrl == dev->autogain)\r\ndev->gain->val = jiffies & 0xff;\r\nreturn 0;\r\n}\r\nstatic int vivi_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vivi_dev *dev = container_of(ctrl->handler, struct vivi_dev, ctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_ALPHA_COMPONENT:\r\ndev->alpha_component = ctrl->val;\r\nbreak;\r\ndefault:\r\nif (ctrl == dev->button)\r\ndev->button_pressed = 30;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vivi_release(void)\r\n{\r\nstruct vivi_dev *dev;\r\nstruct list_head *list;\r\nwhile (!list_empty(&vivi_devlist)) {\r\nlist = vivi_devlist.next;\r\nlist_del(list);\r\ndev = list_entry(list, struct vivi_dev, vivi_devlist);\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->vdev));\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nkfree(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vivi_create_instance(int inst)\r\n{\r\nstruct vivi_dev *dev;\r\nstruct video_device *vfd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct vb2_queue *q;\r\nint ret;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\r\n"%s-%03d", VIVI_MODULE_NAME, inst);\r\nret = v4l2_device_register(NULL, &dev->v4l2_dev);\r\nif (ret)\r\ngoto free_dev;\r\ndev->fmt = &formats[0];\r\ndev->timeperframe = tpf_default;\r\ndev->width = 640;\r\ndev->height = 480;\r\ndev->pixelsize = dev->fmt->depth / 8;\r\nhdl = &dev->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 11);\r\ndev->volume = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 255, 1, 200);\r\ndev->brightness = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\ndev->contrast = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 16);\r\ndev->saturation = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 127);\r\ndev->hue = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\ndev->autogain = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ndev->gain = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 100);\r\ndev->alpha = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);\r\ndev->button = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_button, NULL);\r\ndev->int32 = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_int32, NULL);\r\ndev->int64 = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_int64, NULL);\r\ndev->boolean = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_boolean, NULL);\r\ndev->menu = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_menu, NULL);\r\ndev->string = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_string, NULL);\r\ndev->bitmask = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_bitmask, NULL);\r\ndev->int_menu = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_int_menu, NULL);\r\nif (hdl->error) {\r\nret = hdl->error;\r\ngoto unreg_dev;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &dev->autogain, 0, true);\r\ndev->v4l2_dev.ctrl_handler = hdl;\r\nspin_lock_init(&dev->slock);\r\nq = &dev->vb_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivi_buffer);\r\nq->ops = &vivi_video_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto unreg_dev;\r\nmutex_init(&dev->mutex);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\ninit_waitqueue_head(&dev->vidq.wq);\r\nvfd = &dev->vdev;\r\n*vfd = vivi_template;\r\nvfd->debug = debug;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->queue = q;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\nvfd->lock = &dev->mutex;\r\nvideo_set_drvdata(vfd, dev);\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nlist_add_tail(&dev->vivi_devlist, &vivi_devlist);\r\nv4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\nreturn 0;\r\nunreg_dev:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nfree_dev:\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic int __init vivi_init(void)\r\n{\r\nconst struct font_desc *font = find_font("VGA8x16");\r\nint ret = 0, i;\r\nif (font == NULL) {\r\nprintk(KERN_ERR "vivi: could not find font\n");\r\nreturn -ENODEV;\r\n}\r\nfont8x16 = font->data;\r\nif (n_devs <= 0)\r\nn_devs = 1;\r\nfor (i = 0; i < n_devs; i++) {\r\nret = vivi_create_instance(i);\r\nif (ret) {\r\nif (i)\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\nprintk(KERN_ERR "vivi: error %d while loading driver\n", ret);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "Video Technology Magazine Virtual Video "\r\n"Capture Board ver %s successfully loaded.\n",\r\nVIVI_VERSION);\r\nn_devs = i;\r\nreturn ret;\r\n}\r\nstatic void __exit vivi_exit(void)\r\n{\r\nvivi_release();\r\n}
