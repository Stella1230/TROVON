bool l2cap_is_socket(struct socket *sock)\r\n{\r\nreturn sock && sock->ops == &l2cap_sock_ops;\r\n}\r\nstatic int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nstruct sockaddr_l2 la;\r\nint len, err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (!addr || addr->sa_family != AF_BLUETOOTH)\r\nreturn -EINVAL;\r\nmemset(&la, 0, sizeof(la));\r\nlen = min_t(unsigned int, sizeof(la), alen);\r\nmemcpy(&la, addr, len);\r\nif (la.l2_cid && la.l2_psm)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != BT_OPEN) {\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nif (la.l2_psm) {\r\n__u16 psm = __le16_to_cpu(la.l2_psm);\r\nif ((psm & 0x0101) != 0x0001) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (psm < 0x1001 && !capable(CAP_NET_BIND_SERVICE)) {\r\nerr = -EACCES;\r\ngoto done;\r\n}\r\n}\r\nif (la.l2_cid)\r\nerr = l2cap_add_scid(chan, __le16_to_cpu(la.l2_cid));\r\nelse\r\nerr = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);\r\nif (err < 0)\r\ngoto done;\r\nif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_SDP ||\r\n__le16_to_cpu(la.l2_psm) == L2CAP_PSM_RFCOMM)\r\nchan->sec_level = BT_SECURITY_SDP;\r\nbacpy(&bt_sk(sk)->src, &la.l2_bdaddr);\r\nchan->state = BT_BOUND;\r\nsk->sk_state = BT_BOUND;\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr,\r\nint alen, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nstruct sockaddr_l2 la;\r\nint len, err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (!addr || alen < sizeof(addr->sa_family) ||\r\naddr->sa_family != AF_BLUETOOTH)\r\nreturn -EINVAL;\r\nmemset(&la, 0, sizeof(la));\r\nlen = min_t(unsigned int, sizeof(la), alen);\r\nmemcpy(&la, addr, len);\r\nif (la.l2_cid && la.l2_psm)\r\nreturn -EINVAL;\r\nerr = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),\r\n&la.l2_bdaddr, la.l2_bdaddr_type);\r\nif (err)\r\nreturn err;\r\nlock_sock(sk);\r\nerr = bt_sock_wait_state(sk, BT_CONNECTED,\r\nsock_sndtimeo(sk, flags & O_NONBLOCK));\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nint err = 0;\r\nBT_DBG("sk %p backlog %d", sk, backlog);\r\nlock_sock(sk);\r\nif (sk->sk_state != BT_BOUND) {\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_BASIC:\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\ncase L2CAP_MODE_STREAMING:\r\nif (!disable_ertm)\r\nbreak;\r\ndefault:\r\nerr = -ENOTSUPP;\r\ngoto done;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_ack_backlog = 0;\r\nchan->state = BT_LISTEN;\r\nsk->sk_state = BT_LISTEN;\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_accept(struct socket *sock, struct socket *newsock,\r\nint flags)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct sock *sk = sock->sk, *nsk;\r\nlong timeo;\r\nint err = 0;\r\nlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\r\ntimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\r\nBT_DBG("sk %p timeo %ld", sk, timeo);\r\nadd_wait_queue_exclusive(sk_sleep(sk), &wait);\r\nwhile (1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (sk->sk_state != BT_LISTEN) {\r\nerr = -EBADFD;\r\nbreak;\r\n}\r\nnsk = bt_accept_dequeue(sk, newsock);\r\nif (nsk)\r\nbreak;\r\nif (!timeo) {\r\nerr = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto done;\r\nnewsock->state = SS_CONNECTED;\r\nBT_DBG("new socket %p", nsk);\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr,\r\nint *len, int peer)\r\n{\r\nstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nmemset(la, 0, sizeof(struct sockaddr_l2));\r\naddr->sa_family = AF_BLUETOOTH;\r\n*len = sizeof(struct sockaddr_l2);\r\nif (peer) {\r\nla->l2_psm = chan->psm;\r\nbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\r\nla->l2_cid = cpu_to_le16(chan->dcid);\r\n} else {\r\nla->l2_psm = chan->sport;\r\nbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\r\nla->l2_cid = cpu_to_le16(chan->scid);\r\n}\r\nreturn 0;\r\n}\r\nstatic int l2cap_sock_getsockopt_old(struct socket *sock, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nstruct l2cap_options opts;\r\nstruct l2cap_conninfo cinfo;\r\nint len, err = 0;\r\nu32 opt;\r\nBT_DBG("sk %p", sk);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase L2CAP_OPTIONS:\r\nmemset(&opts, 0, sizeof(opts));\r\nopts.imtu = chan->imtu;\r\nopts.omtu = chan->omtu;\r\nopts.flush_to = chan->flush_to;\r\nopts.mode = chan->mode;\r\nopts.fcs = chan->fcs;\r\nopts.max_tx = chan->max_tx;\r\nopts.txwin_size = chan->tx_win;\r\nlen = min_t(unsigned int, len, sizeof(opts));\r\nif (copy_to_user(optval, (char *) &opts, len))\r\nerr = -EFAULT;\r\nbreak;\r\ncase L2CAP_LM:\r\nswitch (chan->sec_level) {\r\ncase BT_SECURITY_LOW:\r\nopt = L2CAP_LM_AUTH;\r\nbreak;\r\ncase BT_SECURITY_MEDIUM:\r\nopt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;\r\nbreak;\r\ncase BT_SECURITY_HIGH:\r\nopt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\r\nL2CAP_LM_SECURE;\r\nbreak;\r\ndefault:\r\nopt = 0;\r\nbreak;\r\n}\r\nif (test_bit(FLAG_ROLE_SWITCH, &chan->flags))\r\nopt |= L2CAP_LM_MASTER;\r\nif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\r\nopt |= L2CAP_LM_RELIABLE;\r\nif (put_user(opt, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase L2CAP_CONNINFO:\r\nif (sk->sk_state != BT_CONNECTED &&\r\n!(sk->sk_state == BT_CONNECT2 &&\r\ntest_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nmemset(&cinfo, 0, sizeof(cinfo));\r\ncinfo.hci_handle = chan->conn->hcon->handle;\r\nmemcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);\r\nlen = min_t(unsigned int, len, sizeof(cinfo));\r\nif (copy_to_user(optval, (char *) &cinfo, len))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nstruct bt_security sec;\r\nstruct bt_power pwr;\r\nint len, err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (level == SOL_L2CAP)\r\nreturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\r\nif (level != SOL_BLUETOOTH)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase BT_SECURITY:\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\r\nchan->chan_type != L2CAP_CHAN_RAW) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nmemset(&sec, 0, sizeof(sec));\r\nif (chan->conn) {\r\nsec.level = chan->conn->hcon->sec_level;\r\nif (sk->sk_state == BT_CONNECTED)\r\nsec.key_size = chan->conn->hcon->enc_key_size;\r\n} else {\r\nsec.level = chan->sec_level;\r\n}\r\nlen = min_t(unsigned int, len, sizeof(sec));\r\nif (copy_to_user(optval, (char *) &sec, len))\r\nerr = -EFAULT;\r\nbreak;\r\ncase BT_DEFER_SETUP:\r\nif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\r\n(u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase BT_FLUSHABLE:\r\nif (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),\r\n(u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase BT_POWER:\r\nif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM\r\n&& sk->sk_type != SOCK_RAW) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\npwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\r\nlen = min_t(unsigned int, len, sizeof(pwr));\r\nif (copy_to_user(optval, (char *) &pwr, len))\r\nerr = -EFAULT;\r\nbreak;\r\ncase BT_CHANNEL_POLICY:\r\nif (!enable_hs) {\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nif (put_user(chan->chan_policy, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic bool l2cap_valid_mtu(struct l2cap_chan *chan, u16 mtu)\r\n{\r\nswitch (chan->scid) {\r\ncase L2CAP_CID_ATT:\r\nif (mtu < L2CAP_LE_MIN_MTU)\r\nreturn false;\r\nbreak;\r\ndefault:\r\nif (mtu < L2CAP_DEFAULT_MIN_MTU)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int l2cap_sock_setsockopt_old(struct socket *sock, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nstruct l2cap_options opts;\r\nint len, err = 0;\r\nu32 opt;\r\nBT_DBG("sk %p", sk);\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase L2CAP_OPTIONS:\r\nif (sk->sk_state == BT_CONNECTED) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nopts.imtu = chan->imtu;\r\nopts.omtu = chan->omtu;\r\nopts.flush_to = chan->flush_to;\r\nopts.mode = chan->mode;\r\nopts.fcs = chan->fcs;\r\nopts.max_tx = chan->max_tx;\r\nopts.txwin_size = chan->tx_win;\r\nlen = min_t(unsigned int, sizeof(opts), optlen);\r\nif (copy_from_user((char *) &opts, optval, len)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (!l2cap_valid_mtu(chan, opts.imtu)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nchan->mode = opts.mode;\r\nswitch (chan->mode) {\r\ncase L2CAP_MODE_BASIC:\r\nclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\r\nbreak;\r\ncase L2CAP_MODE_ERTM:\r\ncase L2CAP_MODE_STREAMING:\r\nif (!disable_ertm)\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nchan->imtu = opts.imtu;\r\nchan->omtu = opts.omtu;\r\nchan->fcs = opts.fcs;\r\nchan->max_tx = opts.max_tx;\r\nchan->tx_win = opts.txwin_size;\r\nchan->flush_to = opts.flush_to;\r\nbreak;\r\ncase L2CAP_LM:\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt & L2CAP_LM_AUTH)\r\nchan->sec_level = BT_SECURITY_LOW;\r\nif (opt & L2CAP_LM_ENCRYPT)\r\nchan->sec_level = BT_SECURITY_MEDIUM;\r\nif (opt & L2CAP_LM_SECURE)\r\nchan->sec_level = BT_SECURITY_HIGH;\r\nif (opt & L2CAP_LM_MASTER)\r\nset_bit(FLAG_ROLE_SWITCH, &chan->flags);\r\nelse\r\nclear_bit(FLAG_ROLE_SWITCH, &chan->flags);\r\nif (opt & L2CAP_LM_RELIABLE)\r\nset_bit(FLAG_FORCE_RELIABLE, &chan->flags);\r\nelse\r\nclear_bit(FLAG_FORCE_RELIABLE, &chan->flags);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nstruct bt_security sec;\r\nstruct bt_power pwr;\r\nstruct l2cap_conn *conn;\r\nint len, err = 0;\r\nu32 opt;\r\nBT_DBG("sk %p", sk);\r\nif (level == SOL_L2CAP)\r\nreturn l2cap_sock_setsockopt_old(sock, optname, optval, optlen);\r\nif (level != SOL_BLUETOOTH)\r\nreturn -ENOPROTOOPT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase BT_SECURITY:\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\r\nchan->chan_type != L2CAP_CHAN_RAW) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nsec.level = BT_SECURITY_LOW;\r\nlen = min_t(unsigned int, sizeof(sec), optlen);\r\nif (copy_from_user((char *) &sec, optval, len)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (sec.level < BT_SECURITY_LOW ||\r\nsec.level > BT_SECURITY_HIGH) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nchan->sec_level = sec.level;\r\nif (!chan->conn)\r\nbreak;\r\nconn = chan->conn;\r\nif (chan->scid == L2CAP_CID_ATT) {\r\nif (!conn->hcon->out) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (smp_conn_security(conn->hcon, sec.level))\r\nbreak;\r\nsk->sk_state = BT_CONFIG;\r\nchan->state = BT_CONFIG;\r\n} else if ((sk->sk_state == BT_CONNECT2 &&\r\ntest_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) ||\r\nsk->sk_state == BT_CONNECTED) {\r\nif (!l2cap_chan_check_security(chan))\r\nset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\r\nelse\r\nsk->sk_state_change(sk);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase BT_DEFER_SETUP:\r\nif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt)\r\nset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\r\nelse\r\nclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\r\nbreak;\r\ncase BT_FLUSHABLE:\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt > BT_FLUSHABLE_ON) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (opt == BT_FLUSHABLE_OFF) {\r\nstruct l2cap_conn *conn = chan->conn;\r\nif (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (opt)\r\nset_bit(FLAG_FLUSHABLE, &chan->flags);\r\nelse\r\nclear_bit(FLAG_FLUSHABLE, &chan->flags);\r\nbreak;\r\ncase BT_POWER:\r\nif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\r\nchan->chan_type != L2CAP_CHAN_RAW) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\npwr.force_active = BT_POWER_FORCE_ACTIVE_ON;\r\nlen = min_t(unsigned int, sizeof(pwr), optlen);\r\nif (copy_from_user((char *) &pwr, optval, len)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (pwr.force_active)\r\nset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\r\nelse\r\nclear_bit(FLAG_FORCE_ACTIVE, &chan->flags);\r\nbreak;\r\ncase BT_CHANNEL_POLICY:\r\nif (!enable_hs) {\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (chan->mode != L2CAP_MODE_ERTM &&\r\nchan->mode != L2CAP_MODE_STREAMING) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nchan->chan_policy = (u8) opt;\r\nif (sk->sk_state == BT_CONNECTED &&\r\nchan->move_role == L2CAP_MOVE_ROLE_NONE)\r\nl2cap_move_start(chan);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nint err;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nerr = sock_error(sk);\r\nif (err)\r\nreturn err;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nif (sk->sk_state != BT_CONNECTED)\r\nreturn -ENOTCONN;\r\nl2cap_chan_lock(chan);\r\nerr = l2cap_chan_send(chan, msg, len, sk->sk_priority);\r\nl2cap_chan_unlock(chan);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_pinfo *pi = l2cap_pi(sk);\r\nint err;\r\nlock_sock(sk);\r\nif (sk->sk_state == BT_CONNECT2 && test_bit(BT_SK_DEFER_SETUP,\r\n&bt_sk(sk)->flags)) {\r\nsk->sk_state = BT_CONFIG;\r\npi->chan->state = BT_CONFIG;\r\n__l2cap_connect_rsp_defer(pi->chan);\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nrelease_sock(sk);\r\nif (sock->type == SOCK_STREAM)\r\nerr = bt_sock_stream_recvmsg(iocb, sock, msg, len, flags);\r\nelse\r\nerr = bt_sock_recvmsg(iocb, sock, msg, len, flags);\r\nif (pi->chan->mode != L2CAP_MODE_ERTM)\r\nreturn err;\r\nlock_sock(sk);\r\nif (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))\r\ngoto done;\r\nif (pi->rx_busy_skb) {\r\nif (!sock_queue_rcv_skb(sk, pi->rx_busy_skb))\r\npi->rx_busy_skb = NULL;\r\nelse\r\ngoto done;\r\n}\r\nif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)\r\nl2cap_chan_busy(pi->chan, 0);\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic void l2cap_sock_kill(struct sock *sk)\r\n{\r\nif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\r\nreturn;\r\nBT_DBG("sk %p state %s", sk, state_to_string(sk->sk_state));\r\nl2cap_chan_put(l2cap_pi(sk)->chan);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock_put(sk);\r\n}\r\nstatic int l2cap_sock_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2cap_chan *chan;\r\nstruct l2cap_conn *conn;\r\nint err = 0;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nchan = l2cap_pi(sk)->chan;\r\nconn = chan->conn;\r\nif (conn)\r\nmutex_lock(&conn->chan_lock);\r\nl2cap_chan_lock(chan);\r\nlock_sock(sk);\r\nif (!sk->sk_shutdown) {\r\nif (chan->mode == L2CAP_MODE_ERTM)\r\nerr = __l2cap_wait_ack(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nrelease_sock(sk);\r\nl2cap_chan_close(chan, 0);\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)\r\nerr = bt_sock_wait_state(sk, BT_CLOSED,\r\nsk->sk_lingertime);\r\n}\r\nif (!err && sk->sk_err)\r\nerr = -sk->sk_err;\r\nrelease_sock(sk);\r\nl2cap_chan_unlock(chan);\r\nif (conn)\r\nmutex_unlock(&conn->chan_lock);\r\nreturn err;\r\n}\r\nstatic int l2cap_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nbt_sock_unlink(&l2cap_sk_list, sk);\r\nerr = l2cap_sock_shutdown(sock, 2);\r\nsock_orphan(sk);\r\nl2cap_sock_kill(sk);\r\nreturn err;\r\n}\r\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("parent %p", parent);\r\nwhile ((sk = bt_accept_dequeue(parent, NULL))) {\r\nstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\r\nl2cap_chan_lock(chan);\r\n__clear_chan_timer(chan);\r\nl2cap_chan_close(chan, ECONNRESET);\r\nl2cap_chan_unlock(chan);\r\nl2cap_sock_kill(sk);\r\n}\r\n}\r\nstatic struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)\r\n{\r\nstruct sock *sk, *parent = chan->data;\r\nif (sk_acceptq_is_full(parent)) {\r\nBT_DBG("backlog full %d", parent->sk_ack_backlog);\r\nreturn NULL;\r\n}\r\nsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\r\nGFP_ATOMIC);\r\nif (!sk)\r\nreturn NULL;\r\nbt_sock_reclassify_lock(sk, BTPROTO_L2CAP);\r\nl2cap_sock_init(sk, parent);\r\nbt_accept_enqueue(parent, sk);\r\nreturn l2cap_pi(sk)->chan;\r\n}\r\nstatic int l2cap_sock_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\r\n{\r\nint err;\r\nstruct sock *sk = chan->data;\r\nstruct l2cap_pinfo *pi = l2cap_pi(sk);\r\nlock_sock(sk);\r\nif (pi->rx_busy_skb) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err < 0 && pi->chan->mode == L2CAP_MODE_ERTM) {\r\npi->rx_busy_skb = skb;\r\nl2cap_chan_busy(pi->chan, 1);\r\nerr = 0;\r\n}\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic void l2cap_sock_close_cb(struct l2cap_chan *chan)\r\n{\r\nstruct sock *sk = chan->data;\r\nl2cap_sock_kill(sk);\r\n}\r\nstatic void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\r\n{\r\nstruct sock *sk = chan->data;\r\nstruct sock *parent;\r\nlock_sock(sk);\r\nparent = bt_sk(sk)->parent;\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\nswitch (chan->state) {\r\ncase BT_OPEN:\r\ncase BT_BOUND:\r\ncase BT_CLOSED:\r\nbreak;\r\ncase BT_LISTEN:\r\nl2cap_sock_cleanup_listen(sk);\r\nsk->sk_state = BT_CLOSED;\r\nchan->state = BT_CLOSED;\r\nbreak;\r\ndefault:\r\nsk->sk_state = BT_CLOSED;\r\nchan->state = BT_CLOSED;\r\nsk->sk_err = err;\r\nif (parent) {\r\nbt_accept_unlink(sk);\r\nparent->sk_data_ready(parent, 0);\r\n} else {\r\nsk->sk_state_change(sk);\r\n}\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\n}\r\nstatic void l2cap_sock_state_change_cb(struct l2cap_chan *chan, int state)\r\n{\r\nstruct sock *sk = chan->data;\r\nsk->sk_state = state;\r\n}\r\nstatic struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,\r\nunsigned long len, int nb)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nl2cap_chan_unlock(chan);\r\nskb = bt_skb_send_alloc(chan->sk, len, nb, &err);\r\nl2cap_chan_lock(chan);\r\nif (!skb)\r\nreturn ERR_PTR(err);\r\nreturn skb;\r\n}\r\nstatic void l2cap_sock_ready_cb(struct l2cap_chan *chan)\r\n{\r\nstruct sock *sk = chan->data;\r\nstruct sock *parent;\r\nlock_sock(sk);\r\nparent = bt_sk(sk)->parent;\r\nBT_DBG("sk %p, parent %p", sk, parent);\r\nsk->sk_state = BT_CONNECTED;\r\nsk->sk_state_change(sk);\r\nif (parent)\r\nparent->sk_data_ready(parent, 0);\r\nrelease_sock(sk);\r\n}\r\nstatic void l2cap_sock_defer_cb(struct l2cap_chan *chan)\r\n{\r\nstruct sock *sk = chan->data;\r\nstruct sock *parent = bt_sk(sk)->parent;\r\nif (parent)\r\nparent->sk_data_ready(parent, 0);\r\n}\r\nstatic void l2cap_sock_destruct(struct sock *sk)\r\n{\r\nBT_DBG("sk %p", sk);\r\nif (l2cap_pi(sk)->chan)\r\nl2cap_chan_put(l2cap_pi(sk)->chan);\r\nif (l2cap_pi(sk)->rx_busy_skb) {\r\nkfree_skb(l2cap_pi(sk)->rx_busy_skb);\r\nl2cap_pi(sk)->rx_busy_skb = NULL;\r\n}\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nskb_queue_purge(&sk->sk_write_queue);\r\n}\r\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\r\n{\r\nstruct l2cap_pinfo *pi = l2cap_pi(sk);\r\nstruct l2cap_chan *chan = pi->chan;\r\nBT_DBG("sk %p", sk);\r\nif (parent) {\r\nstruct l2cap_chan *pchan = l2cap_pi(parent)->chan;\r\nsk->sk_type = parent->sk_type;\r\nbt_sk(sk)->flags = bt_sk(parent)->flags;\r\nchan->chan_type = pchan->chan_type;\r\nchan->imtu = pchan->imtu;\r\nchan->omtu = pchan->omtu;\r\nchan->conf_state = pchan->conf_state;\r\nchan->mode = pchan->mode;\r\nchan->fcs = pchan->fcs;\r\nchan->max_tx = pchan->max_tx;\r\nchan->tx_win = pchan->tx_win;\r\nchan->tx_win_max = pchan->tx_win_max;\r\nchan->sec_level = pchan->sec_level;\r\nchan->flags = pchan->flags;\r\nsecurity_sk_clone(parent, sk);\r\n} else {\r\nswitch (sk->sk_type) {\r\ncase SOCK_RAW:\r\nchan->chan_type = L2CAP_CHAN_RAW;\r\nbreak;\r\ncase SOCK_DGRAM:\r\nchan->chan_type = L2CAP_CHAN_CONN_LESS;\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\ncase SOCK_STREAM:\r\nchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\r\nbreak;\r\n}\r\nchan->imtu = L2CAP_DEFAULT_MTU;\r\nchan->omtu = 0;\r\nif (!disable_ertm && sk->sk_type == SOCK_STREAM) {\r\nchan->mode = L2CAP_MODE_ERTM;\r\nset_bit(CONF_STATE2_DEVICE, &chan->conf_state);\r\n} else {\r\nchan->mode = L2CAP_MODE_BASIC;\r\n}\r\nl2cap_chan_set_defaults(chan);\r\n}\r\nchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\r\nchan->data = sk;\r\nchan->ops = &l2cap_chan_ops;\r\n}\r\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\r\nint proto, gfp_t prio)\r\n{\r\nstruct sock *sk;\r\nstruct l2cap_chan *chan;\r\nsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);\r\nif (!sk)\r\nreturn NULL;\r\nsock_init_data(sock, sk);\r\nINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\r\nsk->sk_destruct = l2cap_sock_destruct;\r\nsk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nsk->sk_protocol = proto;\r\nsk->sk_state = BT_OPEN;\r\nchan = l2cap_chan_create();\r\nif (!chan) {\r\nsk_free(sk);\r\nreturn NULL;\r\n}\r\nl2cap_chan_hold(chan);\r\nchan->sk = sk;\r\nl2cap_pi(sk)->chan = chan;\r\nreturn sk;\r\n}\r\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("sock %p", sock);\r\nsock->state = SS_UNCONNECTED;\r\nif (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&\r\nsock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\r\nreturn -ESOCKTNOSUPPORT;\r\nif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\r\nreturn -EPERM;\r\nsock->ops = &l2cap_sock_ops;\r\nsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nl2cap_sock_init(sk, NULL);\r\nbt_sock_link(&l2cap_sk_list, sk);\r\nreturn 0;\r\n}\r\nint __init l2cap_init_sockets(void)\r\n{\r\nint err;\r\nerr = proto_register(&l2cap_proto, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\r\nif (err < 0) {\r\nBT_ERR("L2CAP socket registration failed");\r\ngoto error;\r\n}\r\nerr = bt_procfs_init(&init_net, "l2cap", &l2cap_sk_list,\r\nNULL);\r\nif (err < 0) {\r\nBT_ERR("Failed to create L2CAP proc file");\r\nbt_sock_unregister(BTPROTO_L2CAP);\r\ngoto error;\r\n}\r\nBT_INFO("L2CAP socket layer initialized");\r\nreturn 0;\r\nerror:\r\nproto_unregister(&l2cap_proto);\r\nreturn err;\r\n}\r\nvoid l2cap_cleanup_sockets(void)\r\n{\r\nbt_procfs_cleanup(&init_net, "l2cap");\r\nbt_sock_unregister(BTPROTO_L2CAP);\r\nproto_unregister(&l2cap_proto);\r\n}
