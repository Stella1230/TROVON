static inline u32\r\nip_to_id(const struct bitmap_ip *m, u32 ip)\r\n{\r\nreturn ((ip & ip_set_hostmask(m->netmask)) - m->first_ip)/m->hosts;\r\n}\r\nstatic inline int\r\nbitmap_ip_do_test(const struct bitmap_ip_adt_elem *e, struct bitmap_ip *map)\r\n{\r\nreturn !!test_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_ip_gc_test(u16 id, const struct bitmap_ip *map)\r\n{\r\nreturn !!test_bit(id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_ip_do_add(const struct bitmap_ip_adt_elem *e, struct bitmap_ip *map,\r\nu32 flags)\r\n{\r\nreturn !!test_and_set_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_ip_do_del(const struct bitmap_ip_adt_elem *e, struct bitmap_ip *map)\r\n{\r\nreturn !test_and_clear_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_ip_do_list(struct sk_buff *skb, const struct bitmap_ip *map, u32 id)\r\n{\r\nreturn nla_put_ipaddr4(skb, IPSET_ATTR_IP,\r\nhtonl(map->first_ip + id * map->hosts));\r\n}\r\nstatic inline int\r\nbitmap_ip_do_head(struct sk_buff *skb, const struct bitmap_ip *map)\r\n{\r\nreturn nla_put_ipaddr4(skb, IPSET_ATTR_IP, htonl(map->first_ip)) ||\r\nnla_put_ipaddr4(skb, IPSET_ATTR_IP_TO, htonl(map->last_ip)) ||\r\n(map->netmask != 32 &&\r\nnla_put_u8(skb, IPSET_ATTR_NETMASK, map->netmask));\r\n}\r\nstatic int\r\nbitmap_ip_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct bitmap_ip_adt_elem e = { };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, map);\r\nu32 ip;\r\nip = ntohl(ip4addr(skb, opt->flags & IPSET_DIM_ONE_SRC));\r\nif (ip < map->first_ip || ip > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\ne.id = ip_to_id(map, ip);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nbitmap_ip_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct bitmap_ip *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nu32 ip, ip_to;\r\nstruct bitmap_ip_adt_elem e = { };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(map);\r\nint ret = 0;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip) ||\r\nip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nif (ip < map->first_ip || ip > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nif (adt == IPSET_TEST) {\r\ne.id = ip_to_id(map, ip);\r\nreturn adtfn(set, &e, &ext, &ext, flags);\r\n}\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip > ip_to) {\r\nswap(ip, ip_to);\r\nif (ip < map->first_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\n}\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (!cidr || cidr > 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(ip, ip_to, cidr);\r\n} else\r\nip_to = ip;\r\nif (ip_to > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nfor (; !before(ip_to, ip); ip += map->hosts) {\r\ne.id = ip_to_id(map, ip);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\nbitmap_ip_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct bitmap_ip *x = a->data;\r\nconst struct bitmap_ip *y = b->data;\r\nreturn x->first_ip == y->first_ip &&\r\nx->last_ip == y->last_ip &&\r\nx->netmask == y->netmask &&\r\nx->timeout == y->timeout &&\r\na->extensions == b->extensions;\r\n}\r\nstatic bool\r\ninit_map_ip(struct ip_set *set, struct bitmap_ip *map,\r\nu32 first_ip, u32 last_ip,\r\nu32 elements, u32 hosts, u8 netmask)\r\n{\r\nmap->members = ip_set_alloc(map->memsize);\r\nif (!map->members)\r\nreturn false;\r\nif (map->dsize) {\r\nmap->extensions = ip_set_alloc(map->dsize * elements);\r\nif (!map->extensions) {\r\nkfree(map->members);\r\nreturn false;\r\n}\r\n}\r\nmap->first_ip = first_ip;\r\nmap->last_ip = last_ip;\r\nmap->elements = elements;\r\nmap->hosts = hosts;\r\nmap->netmask = netmask;\r\nmap->timeout = IPSET_NO_TIMEOUT;\r\nset->data = map;\r\nset->family = NFPROTO_IPV4;\r\nreturn true;\r\n}\r\nstatic int\r\nbitmap_ip_create(struct ip_set *set, struct nlattr *tb[], u32 flags)\r\n{\r\nstruct bitmap_ip *map;\r\nu32 first_ip, last_ip, hosts, cadt_flags = 0;\r\nu64 elements;\r\nu8 netmask = 32;\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);\r\nif (ret)\r\nreturn ret;\r\nif (first_ip > last_ip) {\r\nu32 tmp = first_ip;\r\nfirst_ip = last_ip;\r\nlast_ip = tmp;\r\n}\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr >= 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(first_ip, last_ip, cidr);\r\n} else\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_NETMASK]) {\r\nnetmask = nla_get_u8(tb[IPSET_ATTR_NETMASK]);\r\nif (netmask > 32)\r\nreturn -IPSET_ERR_INVALID_NETMASK;\r\nfirst_ip &= ip_set_hostmask(netmask);\r\nlast_ip |= ~ip_set_hostmask(netmask);\r\n}\r\nif (netmask == 32) {\r\nhosts = 1;\r\nelements = (u64)last_ip - first_ip + 1;\r\n} else {\r\nu8 mask_bits;\r\nu32 mask;\r\nmask = range_to_mask(first_ip, last_ip, &mask_bits);\r\nif ((!mask && (first_ip || last_ip != 0xFFFFFFFF)) ||\r\nnetmask <= mask_bits)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\npr_debug("mask_bits %u, netmask %u\n", mask_bits, netmask);\r\nhosts = 2 << (32 - netmask - 1);\r\nelements = 2 << (netmask - mask_bits - 1);\r\n}\r\nif (elements > IPSET_BITMAP_MAX_RANGE + 1)\r\nreturn -IPSET_ERR_BITMAP_RANGE_SIZE;\r\npr_debug("hosts %u, elements %llu\n",\r\nhosts, (unsigned long long)elements);\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nmap->memsize = bitmap_bytes(0, elements - 1);\r\nset->variant = &bitmap_ip;\r\nif (tb[IPSET_ATTR_CADT_FLAGS])\r\ncadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\nif (cadt_flags & IPSET_FLAG_WITH_COUNTERS) {\r\nset->extensions |= IPSET_EXT_COUNTER;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nmap->dsize = sizeof(struct bitmap_ipct_elem);\r\nmap->offset[IPSET_OFFSET_TIMEOUT] =\r\noffsetof(struct bitmap_ipct_elem, timeout);\r\nmap->offset[IPSET_OFFSET_COUNTER] =\r\noffsetof(struct bitmap_ipct_elem, counter);\r\nif (!init_map_ip(set, map, first_ip, last_ip,\r\nelements, hosts, netmask)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nmap->timeout = ip_set_timeout_uget(\r\ntb[IPSET_ATTR_TIMEOUT]);\r\nset->extensions |= IPSET_EXT_TIMEOUT;\r\nbitmap_ip_gc_init(set, bitmap_ip_gc);\r\n} else {\r\nmap->dsize = sizeof(struct bitmap_ipc_elem);\r\nmap->offset[IPSET_OFFSET_COUNTER] =\r\noffsetof(struct bitmap_ipc_elem, counter);\r\nif (!init_map_ip(set, map, first_ip, last_ip,\r\nelements, hosts, netmask)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\n}\r\n} else if (tb[IPSET_ATTR_TIMEOUT]) {\r\nmap->dsize = sizeof(struct bitmap_ipt_elem);\r\nmap->offset[IPSET_OFFSET_TIMEOUT] =\r\noffsetof(struct bitmap_ipt_elem, timeout);\r\nif (!init_map_ip(set, map, first_ip, last_ip,\r\nelements, hosts, netmask)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nmap->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nset->extensions |= IPSET_EXT_TIMEOUT;\r\nbitmap_ip_gc_init(set, bitmap_ip_gc);\r\n} else {\r\nmap->dsize = 0;\r\nif (!init_map_ip(set, map, first_ip, last_ip,\r\nelements, hosts, netmask)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nbitmap_ip_init(void)\r\n{\r\nreturn ip_set_type_register(&bitmap_ip_type);\r\n}\r\nstatic void __exit\r\nbitmap_ip_fini(void)\r\n{\r\nip_set_type_unregister(&bitmap_ip_type);\r\n}
