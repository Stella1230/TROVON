static int m41t80_get_datetime(struct i2c_client *client,\r\nstruct rtc_time *tm)\r\n{\r\nu8 buf[M41T80_DATETIME_REG_SIZE], dt_addr[1] = { M41T80_REG_SEC };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = dt_addr,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = M41T80_DATETIME_REG_SIZE - M41T80_REG_SEC,\r\n.buf = buf + M41T80_REG_SEC,\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, msgs, 2) < 0) {\r\ndev_err(&client->dev, "read error\n");\r\nreturn -EIO;\r\n}\r\ntm->tm_sec = bcd2bin(buf[M41T80_REG_SEC] & 0x7f);\r\ntm->tm_min = bcd2bin(buf[M41T80_REG_MIN] & 0x7f);\r\ntm->tm_hour = bcd2bin(buf[M41T80_REG_HOUR] & 0x3f);\r\ntm->tm_mday = bcd2bin(buf[M41T80_REG_DAY] & 0x3f);\r\ntm->tm_wday = buf[M41T80_REG_WDAY] & 0x07;\r\ntm->tm_mon = bcd2bin(buf[M41T80_REG_MON] & 0x1f) - 1;\r\ntm->tm_year = bcd2bin(buf[M41T80_REG_YEAR]) + 100;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int m41t80_set_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nu8 wbuf[1 + M41T80_DATETIME_REG_SIZE];\r\nu8 *buf = &wbuf[1];\r\nu8 dt_addr[1] = { M41T80_REG_SEC };\r\nstruct i2c_msg msgs_in[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = dt_addr,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = M41T80_DATETIME_REG_SIZE - M41T80_REG_SEC,\r\n.buf = buf + M41T80_REG_SEC,\r\n},\r\n};\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1 + M41T80_DATETIME_REG_SIZE,\r\n.buf = wbuf,\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, msgs_in, 2) < 0) {\r\ndev_err(&client->dev, "read error\n");\r\nreturn -EIO;\r\n}\r\nwbuf[0] = 0;\r\nbuf[M41T80_REG_SSEC] = 0;\r\nbuf[M41T80_REG_SEC] =\r\nbin2bcd(tm->tm_sec) | (buf[M41T80_REG_SEC] & ~0x7f);\r\nbuf[M41T80_REG_MIN] =\r\nbin2bcd(tm->tm_min) | (buf[M41T80_REG_MIN] & ~0x7f);\r\nbuf[M41T80_REG_HOUR] =\r\nbin2bcd(tm->tm_hour) | (buf[M41T80_REG_HOUR] & ~0x3f);\r\nbuf[M41T80_REG_WDAY] =\r\n(tm->tm_wday & 0x07) | (buf[M41T80_REG_WDAY] & ~0x07);\r\nbuf[M41T80_REG_DAY] =\r\nbin2bcd(tm->tm_mday) | (buf[M41T80_REG_DAY] & ~0x3f);\r\nbuf[M41T80_REG_MON] =\r\nbin2bcd(tm->tm_mon + 1) | (buf[M41T80_REG_MON] & ~0x1f);\r\nbuf[M41T80_REG_YEAR] = bin2bcd(tm->tm_year % 100);\r\nif (i2c_transfer(client->adapter, msgs, 1) != 1) {\r\ndev_err(&client->dev, "write error\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int m41t80_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nu8 reg;\r\nif (clientdata->features & M41T80_FEATURE_BL) {\r\nreg = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nseq_printf(seq, "battery\t\t: %s\n",\r\n(reg & M41T80_FLAGS_BATT_LOW) ? "exhausted" : "ok");\r\n}\r\nreturn 0;\r\n}\r\nstatic int m41t80_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn m41t80_get_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int m41t80_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn m41t80_set_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic ssize_t m41t80_sysfs_show_flags(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint val;\r\nval = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (val < 0)\r\nreturn -EIO;\r\nreturn sprintf(buf, "%#x\n", val);\r\n}\r\nstatic ssize_t m41t80_sysfs_show_sqwfreq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nint val, reg_sqw;\r\nif (!(clientdata->features & M41T80_FEATURE_SQ))\r\nreturn -EINVAL;\r\nreg_sqw = M41T80_REG_SQW;\r\nif (clientdata->features & M41T80_FEATURE_SQ_ALT)\r\nreg_sqw = M41T80_REG_WDAY;\r\nval = i2c_smbus_read_byte_data(client, reg_sqw);\r\nif (val < 0)\r\nreturn -EIO;\r\nval = (val >> 4) & 0xf;\r\nswitch (val) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nval = 32768;\r\nbreak;\r\ndefault:\r\nval = 32768 >> val;\r\n}\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t m41t80_sysfs_set_sqwfreq(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nint almon, sqw, reg_sqw;\r\nint val = simple_strtoul(buf, NULL, 0);\r\nif (!(clientdata->features & M41T80_FEATURE_SQ))\r\nreturn -EINVAL;\r\nif (val) {\r\nif (!is_power_of_2(val))\r\nreturn -EINVAL;\r\nval = ilog2(val);\r\nif (val == 15)\r\nval = 1;\r\nelse if (val < 14)\r\nval = 15 - val;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nalmon = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\r\nif (almon < 0)\r\nreturn -EIO;\r\nreg_sqw = M41T80_REG_SQW;\r\nif (clientdata->features & M41T80_FEATURE_SQ_ALT)\r\nreg_sqw = M41T80_REG_WDAY;\r\nsqw = i2c_smbus_read_byte_data(client, reg_sqw);\r\nif (sqw < 0)\r\nreturn -EIO;\r\nsqw = (sqw & 0x0f) | (val << 4);\r\nif (i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nalmon & ~M41T80_ALMON_SQWE) < 0 ||\r\ni2c_smbus_write_byte_data(client, reg_sqw, sqw) < 0)\r\nreturn -EIO;\r\nif (val && i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nalmon | M41T80_ALMON_SQWE) < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic int m41t80_sysfs_register(struct device *dev)\r\n{\r\nreturn sysfs_create_group(&dev->kobj, &attr_group);\r\n}\r\nstatic int m41t80_sysfs_register(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void wdt_ping(void)\r\n{\r\nunsigned char i2c_data[2];\r\nstruct i2c_msg msgs1[1] = {\r\n{\r\n.addr = save_client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = i2c_data,\r\n},\r\n};\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(save_client);\r\ni2c_data[0] = 0x09;\r\nif (wdt_margin > 31)\r\ni2c_data[1] = (wdt_margin & 0xFC) | 0x83;\r\nelse\r\ni2c_data[1] = wdt_margin<<2 | 0x82;\r\nif (clientdata->features & M41T80_FEATURE_WD)\r\ni2c_data[1] &= ~M41T80_WATCHDOG_RB2;\r\ni2c_transfer(save_client->adapter, msgs1, 1);\r\n}\r\nstatic void wdt_disable(void)\r\n{\r\nunsigned char i2c_data[2], i2c_buf[0x10];\r\nstruct i2c_msg msgs0[2] = {\r\n{\r\n.addr = save_client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = i2c_data,\r\n},\r\n{\r\n.addr = save_client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = i2c_buf,\r\n},\r\n};\r\nstruct i2c_msg msgs1[1] = {\r\n{\r\n.addr = save_client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = i2c_data,\r\n},\r\n};\r\ni2c_data[0] = 0x09;\r\ni2c_transfer(save_client->adapter, msgs0, 2);\r\ni2c_data[0] = 0x09;\r\ni2c_data[1] = 0x00;\r\ni2c_transfer(save_client->adapter, msgs1, 1);\r\n}\r\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nwdt_ping();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t wdt_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint new_margin, rv;\r\nstatic struct watchdog_info ident = {\r\n.options = WDIOF_POWERUNDER | WDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT,\r\n.firmware_version = 1,\r\n.identity = "M41T80 WTD"\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user((struct watchdog_info __user *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(boot_flag, (int __user *)arg);\r\ncase WDIOC_KEEPALIVE:\r\nwdt_ping();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, (int __user *)arg))\r\nreturn -EFAULT;\r\nif (new_margin < 1 || new_margin > 124)\r\nreturn -EINVAL;\r\nwdt_margin = new_margin;\r\nwdt_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(wdt_margin, (int __user *)arg);\r\ncase WDIOC_SETOPTIONS:\r\nif (copy_from_user(&rv, (int __user *)arg, sizeof(int)))\r\nreturn -EFAULT;\r\nif (rv & WDIOS_DISABLECARD) {\r\npr_info("rtc-m41t80: disable watchdog\n");\r\nwdt_disable();\r\n}\r\nif (rv & WDIOS_ENABLECARD) {\r\npr_info("rtc-m41t80: enable watchdog\n");\r\nwdt_ping();\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic long wdt_unlocked_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&m41t80_rtc_mutex);\r\nret = wdt_ioctl(file, cmd, arg);\r\nmutex_unlock(&m41t80_rtc_mutex);\r\nreturn ret;\r\n}\r\nstatic int wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (MINOR(inode->i_rdev) == WATCHDOG_MINOR) {\r\nmutex_lock(&m41t80_rtc_mutex);\r\nif (test_and_set_bit(0, &wdt_is_open)) {\r\nmutex_unlock(&m41t80_rtc_mutex);\r\nreturn -EBUSY;\r\n}\r\nwdt_is_open = 1;\r\nmutex_unlock(&m41t80_rtc_mutex);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (MINOR(inode->i_rdev) == WATCHDOG_MINOR)\r\nclear_bit(0, &wdt_is_open);\r\nreturn 0;\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_disable();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int m41t80_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint rc = 0;\r\nstruct rtc_device *rtc = NULL;\r\nstruct rtc_time tm;\r\nstruct m41t80_data *clientdata = NULL;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C\r\n| I2C_FUNC_SMBUS_BYTE_DATA)) {\r\nrc = -ENODEV;\r\ngoto exit;\r\n}\r\ndev_info(&client->dev,\r\n"chip found, driver version " DRV_VERSION "\n");\r\nclientdata = devm_kzalloc(&client->dev, sizeof(*clientdata),\r\nGFP_KERNEL);\r\nif (!clientdata) {\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\nclientdata->features = id->driver_data;\r\ni2c_set_clientdata(client, clientdata);\r\nrtc = devm_rtc_device_register(&client->dev, client->name,\r\n&m41t80_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\nrc = PTR_ERR(rtc);\r\nrtc = NULL;\r\ngoto exit;\r\n}\r\nclientdata->rtc = rtc;\r\nrc = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_HOUR);\r\nif (rc < 0)\r\ngoto ht_err;\r\nif (rc & M41T80_ALHOUR_HT) {\r\nif (clientdata->features & M41T80_FEATURE_HT) {\r\nm41t80_get_datetime(client, &tm);\r\ndev_info(&client->dev, "HT bit was set!\n");\r\ndev_info(&client->dev,\r\n"Power Down at "\r\n"%04i-%02i-%02i %02i:%02i:%02i\n",\r\ntm.tm_year + 1900,\r\ntm.tm_mon + 1, tm.tm_mday, tm.tm_hour,\r\ntm.tm_min, tm.tm_sec);\r\n}\r\nif (i2c_smbus_write_byte_data(client,\r\nM41T80_REG_ALARM_HOUR,\r\nrc & ~M41T80_ALHOUR_HT) < 0)\r\ngoto ht_err;\r\n}\r\nrc = i2c_smbus_read_byte_data(client, M41T80_REG_SEC);\r\nif (rc < 0)\r\ngoto st_err;\r\nif (rc & M41T80_SEC_ST) {\r\nif (i2c_smbus_write_byte_data(client, M41T80_REG_SEC,\r\nrc & ~M41T80_SEC_ST) < 0)\r\ngoto st_err;\r\n}\r\nrc = m41t80_sysfs_register(&client->dev);\r\nif (rc)\r\ngoto exit;\r\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\r\nif (clientdata->features & M41T80_FEATURE_HT) {\r\nsave_client = client;\r\nrc = misc_register(&wdt_dev);\r\nif (rc)\r\ngoto exit;\r\nrc = register_reboot_notifier(&wdt_notifier);\r\nif (rc) {\r\nmisc_deregister(&wdt_dev);\r\ngoto exit;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\nst_err:\r\nrc = -EIO;\r\ndev_err(&client->dev, "Can't clear ST bit\n");\r\ngoto exit;\r\nht_err:\r\nrc = -EIO;\r\ndev_err(&client->dev, "Can't clear HT bit\n");\r\ngoto exit;\r\nexit:\r\nreturn rc;\r\n}\r\nstatic int m41t80_remove(struct i2c_client *client)\r\n{\r\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nif (clientdata->features & M41T80_FEATURE_HT) {\r\nmisc_deregister(&wdt_dev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\n}\r\n#endif\r\nreturn 0;\r\n}
