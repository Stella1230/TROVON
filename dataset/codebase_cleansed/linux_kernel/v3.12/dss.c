static inline void dss_write_reg(const struct dss_reg idx, u32 val)\r\n{\r\n__raw_writel(val, dss.base + idx.idx);\r\n}\r\nstatic inline u32 dss_read_reg(const struct dss_reg idx)\r\n{\r\nreturn __raw_readl(dss.base + idx.idx);\r\n}\r\nstatic void dss_save_context(void)\r\n{\r\nDSSDBG("dss_save_context\n");\r\nSR(CONTROL);\r\nif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\r\nOMAP_DISPLAY_TYPE_SDI) {\r\nSR(SDI_CONTROL);\r\nSR(PLL_CONTROL);\r\n}\r\ndss.ctx_valid = true;\r\nDSSDBG("context saved\n");\r\n}\r\nstatic void dss_restore_context(void)\r\n{\r\nDSSDBG("dss_restore_context\n");\r\nif (!dss.ctx_valid)\r\nreturn;\r\nRR(CONTROL);\r\nif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\r\nOMAP_DISPLAY_TYPE_SDI) {\r\nRR(SDI_CONTROL);\r\nRR(PLL_CONTROL);\r\n}\r\nDSSDBG("context restored\n");\r\n}\r\nint dss_get_ctx_loss_count(void)\r\n{\r\nstruct platform_device *core_pdev = dss_get_core_pdev();\r\nstruct omap_dss_board_info *board_data = core_pdev->dev.platform_data;\r\nint cnt;\r\nif (!board_data->get_context_loss_count)\r\nreturn -ENOENT;\r\ncnt = board_data->get_context_loss_count(&dss.pdev->dev);\r\nWARN_ONCE(cnt < 0, "get_context_loss_count failed: %d\n", cnt);\r\nreturn cnt;\r\n}\r\nvoid dss_sdi_init(int datapairs)\r\n{\r\nu32 l;\r\nBUG_ON(datapairs > 3 || datapairs < 1);\r\nl = dss_read_reg(DSS_SDI_CONTROL);\r\nl = FLD_MOD(l, 0xf, 19, 15);\r\nl = FLD_MOD(l, datapairs-1, 3, 2);\r\nl = FLD_MOD(l, 2, 1, 0);\r\ndss_write_reg(DSS_SDI_CONTROL, l);\r\nl = dss_read_reg(DSS_PLL_CONTROL);\r\nl = FLD_MOD(l, 0x7, 25, 22);\r\nl = FLD_MOD(l, 0xb, 16, 11);\r\nl = FLD_MOD(l, 0xb4, 10, 1);\r\ndss_write_reg(DSS_PLL_CONTROL, l);\r\n}\r\nint dss_sdi_enable(void)\r\n{\r\nunsigned long timeout;\r\ndispc_pck_free_enable(1);\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 1, 18, 18);\r\nudelay(1);\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 1, 28, 28);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (dss_read_reg(DSS_SDI_STATUS) & (1 << 6)) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nDSSERR("PLL lock request timed out\n");\r\ngoto err1;\r\n}\r\n}\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 0, 28, 28);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 5))) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nDSSERR("PLL lock timed out\n");\r\ngoto err1;\r\n}\r\n}\r\ndispc_lcd_enable_signal(1);\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (!(dss_read_reg(DSS_SDI_STATUS) & (1 << 2))) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nDSSERR("SDI reset timed out\n");\r\ngoto err2;\r\n}\r\n}\r\nreturn 0;\r\nerr2:\r\ndispc_lcd_enable_signal(0);\r\nerr1:\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18);\r\ndispc_pck_free_enable(0);\r\nreturn -ETIMEDOUT;\r\n}\r\nvoid dss_sdi_disable(void)\r\n{\r\ndispc_lcd_enable_signal(0);\r\ndispc_pck_free_enable(0);\r\nREG_FLD_MOD(DSS_PLL_CONTROL, 0, 18, 18);\r\n}\r\nconst char *dss_get_generic_clk_source_name(enum omap_dss_clk_source clk_src)\r\n{\r\nreturn dss_generic_clk_source_names[clk_src];\r\n}\r\nvoid dss_dump_clocks(struct seq_file *s)\r\n{\r\nunsigned long dpll4_ck_rate;\r\nunsigned long dpll4_m4_ck_rate;\r\nconst char *fclk_name, *fclk_real_name;\r\nunsigned long fclk_rate;\r\nif (dss_runtime_get())\r\nreturn;\r\nseq_printf(s, "- DSS -\n");\r\nfclk_name = dss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_FCK);\r\nfclk_real_name = dss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_FCK);\r\nfclk_rate = clk_get_rate(dss.dss_clk);\r\nif (dss.dpll4_m4_ck) {\r\ndpll4_ck_rate = clk_get_rate(clk_get_parent(dss.dpll4_m4_ck));\r\ndpll4_m4_ck_rate = clk_get_rate(dss.dpll4_m4_ck);\r\nseq_printf(s, "dpll4_ck %lu\n", dpll4_ck_rate);\r\nseq_printf(s, "%s (%s) = %lu / %lu * %d = %lu\n",\r\nfclk_name, fclk_real_name, dpll4_ck_rate,\r\ndpll4_ck_rate / dpll4_m4_ck_rate,\r\ndss.feat->dss_fck_multiplier, fclk_rate);\r\n} else {\r\nseq_printf(s, "%s (%s) = %lu\n",\r\nfclk_name, fclk_real_name,\r\nfclk_rate);\r\n}\r\ndss_runtime_put();\r\n}\r\nstatic void dss_dump_regs(struct seq_file *s)\r\n{\r\n#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dss_read_reg(r))\r\nif (dss_runtime_get())\r\nreturn;\r\nDUMPREG(DSS_REVISION);\r\nDUMPREG(DSS_SYSCONFIG);\r\nDUMPREG(DSS_SYSSTATUS);\r\nDUMPREG(DSS_CONTROL);\r\nif (dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_LCD) &\r\nOMAP_DISPLAY_TYPE_SDI) {\r\nDUMPREG(DSS_SDI_CONTROL);\r\nDUMPREG(DSS_PLL_CONTROL);\r\nDUMPREG(DSS_SDI_STATUS);\r\n}\r\ndss_runtime_put();\r\n#undef DUMPREG\r\n}\r\nstatic void dss_select_dispc_clk_source(enum omap_dss_clk_source clk_src)\r\n{\r\nstruct platform_device *dsidev;\r\nint b;\r\nu8 start, end;\r\nswitch (clk_src) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nb = 0;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\r\nb = 1;\r\ndsidev = dsi_get_dsidev_from_id(0);\r\ndsi_wait_pll_hsdiv_dispc_active(dsidev);\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\r\nb = 2;\r\ndsidev = dsi_get_dsidev_from_id(1);\r\ndsi_wait_pll_hsdiv_dispc_active(dsidev);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\ndss_feat_get_reg_field(FEAT_REG_DISPC_CLK_SWITCH, &start, &end);\r\nREG_FLD_MOD(DSS_CONTROL, b, start, end);\r\ndss.dispc_clk_source = clk_src;\r\n}\r\nvoid dss_select_dsi_clk_source(int dsi_module,\r\nenum omap_dss_clk_source clk_src)\r\n{\r\nstruct platform_device *dsidev;\r\nint b, pos;\r\nswitch (clk_src) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nb = 0;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI:\r\nBUG_ON(dsi_module != 0);\r\nb = 1;\r\ndsidev = dsi_get_dsidev_from_id(0);\r\ndsi_wait_pll_hsdiv_dsi_active(dsidev);\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI:\r\nBUG_ON(dsi_module != 1);\r\nb = 1;\r\ndsidev = dsi_get_dsidev_from_id(1);\r\ndsi_wait_pll_hsdiv_dsi_active(dsidev);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\npos = dsi_module == 0 ? 1 : 10;\r\nREG_FLD_MOD(DSS_CONTROL, b, pos, pos);\r\ndss.dsi_clk_source[dsi_module] = clk_src;\r\n}\r\nvoid dss_select_lcd_clk_source(enum omap_channel channel,\r\nenum omap_dss_clk_source clk_src)\r\n{\r\nstruct platform_device *dsidev;\r\nint b, ix, pos;\r\nif (!dss_has_feature(FEAT_LCD_CLK_SRC)) {\r\ndss_select_dispc_clk_source(clk_src);\r\nreturn;\r\n}\r\nswitch (clk_src) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nb = 0;\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\r\nBUG_ON(channel != OMAP_DSS_CHANNEL_LCD);\r\nb = 1;\r\ndsidev = dsi_get_dsidev_from_id(0);\r\ndsi_wait_pll_hsdiv_dispc_active(dsidev);\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\r\nBUG_ON(channel != OMAP_DSS_CHANNEL_LCD2 &&\r\nchannel != OMAP_DSS_CHANNEL_LCD3);\r\nb = 1;\r\ndsidev = dsi_get_dsidev_from_id(1);\r\ndsi_wait_pll_hsdiv_dispc_active(dsidev);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\npos = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\r\n(channel == OMAP_DSS_CHANNEL_LCD2 ? 12 : 19);\r\nREG_FLD_MOD(DSS_CONTROL, b, pos, pos);\r\nix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\r\n(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);\r\ndss.lcd_clk_source[ix] = clk_src;\r\n}\r\nenum omap_dss_clk_source dss_get_dispc_clk_source(void)\r\n{\r\nreturn dss.dispc_clk_source;\r\n}\r\nenum omap_dss_clk_source dss_get_dsi_clk_source(int dsi_module)\r\n{\r\nreturn dss.dsi_clk_source[dsi_module];\r\n}\r\nenum omap_dss_clk_source dss_get_lcd_clk_source(enum omap_channel channel)\r\n{\r\nif (dss_has_feature(FEAT_LCD_CLK_SRC)) {\r\nint ix = channel == OMAP_DSS_CHANNEL_LCD ? 0 :\r\n(channel == OMAP_DSS_CHANNEL_LCD2 ? 1 : 2);\r\nreturn dss.lcd_clk_source[ix];\r\n} else {\r\nreturn dss.dispc_clk_source;\r\n}\r\n}\r\nint dss_calc_clock_rates(struct dss_clock_info *cinfo)\r\n{\r\nif (dss.dpll4_m4_ck) {\r\nunsigned long prate;\r\nif (cinfo->fck_div > dss.feat->fck_div_max ||\r\ncinfo->fck_div == 0)\r\nreturn -EINVAL;\r\nprate = clk_get_rate(clk_get_parent(dss.dpll4_m4_ck));\r\ncinfo->fck = prate / cinfo->fck_div *\r\ndss.feat->dss_fck_multiplier;\r\n} else {\r\nif (cinfo->fck_div != 0)\r\nreturn -EINVAL;\r\ncinfo->fck = clk_get_rate(dss.dss_clk);\r\n}\r\nreturn 0;\r\n}\r\nbool dss_div_calc(unsigned long fck_min, dss_div_calc_func func, void *data)\r\n{\r\nint fckd, fckd_start, fckd_stop;\r\nunsigned long fck;\r\nunsigned long fck_hw_max;\r\nunsigned long fckd_hw_max;\r\nunsigned long prate;\r\nunsigned m;\r\nif (dss.dpll4_m4_ck == NULL) {\r\nfck = clk_get_rate(dss.dss_clk);\r\nfckd = 1;\r\nreturn func(fckd, fck, data);\r\n}\r\nfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\r\nfckd_hw_max = dss.feat->fck_div_max;\r\nm = dss.feat->dss_fck_multiplier;\r\nprate = dss_get_dpll4_rate();\r\nfck_min = fck_min ? fck_min : 1;\r\nfckd_start = min(prate * m / fck_min, fckd_hw_max);\r\nfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\r\nfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\r\nfck = prate / fckd * m;\r\nif (func(fckd, fck, data))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint dss_set_clock_div(struct dss_clock_info *cinfo)\r\n{\r\nif (dss.dpll4_m4_ck) {\r\nunsigned long prate;\r\nint r;\r\nprate = clk_get_rate(clk_get_parent(dss.dpll4_m4_ck));\r\nDSSDBG("dpll4_m4 = %ld\n", prate);\r\nr = clk_set_rate(dss.dpll4_m4_ck,\r\nDIV_ROUND_UP(prate, cinfo->fck_div));\r\nif (r)\r\nreturn r;\r\n} else {\r\nif (cinfo->fck_div != 0)\r\nreturn -EINVAL;\r\n}\r\ndss.dss_clk_rate = clk_get_rate(dss.dss_clk);\r\nWARN_ONCE(dss.dss_clk_rate != cinfo->fck,\r\n"clk rate mismatch: %lu != %lu", dss.dss_clk_rate,\r\ncinfo->fck);\r\nDSSDBG("fck = %ld (%d)\n", cinfo->fck, cinfo->fck_div);\r\nreturn 0;\r\n}\r\nunsigned long dss_get_dpll4_rate(void)\r\n{\r\nif (dss.dpll4_m4_ck)\r\nreturn clk_get_rate(clk_get_parent(dss.dpll4_m4_ck));\r\nelse\r\nreturn 0;\r\n}\r\nunsigned long dss_get_dispc_clk_rate(void)\r\n{\r\nreturn dss.dss_clk_rate;\r\n}\r\nstatic int dss_setup_default_clock(void)\r\n{\r\nunsigned long max_dss_fck, prate;\r\nunsigned fck_div;\r\nstruct dss_clock_info dss_cinfo = { 0 };\r\nint r;\r\nif (dss.dpll4_m4_ck == NULL)\r\nreturn 0;\r\nmax_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\r\nprate = dss_get_dpll4_rate();\r\nfck_div = DIV_ROUND_UP(prate * dss.feat->dss_fck_multiplier,\r\nmax_dss_fck);\r\ndss_cinfo.fck_div = fck_div;\r\nr = dss_calc_clock_rates(&dss_cinfo);\r\nif (r)\r\nreturn r;\r\nr = dss_set_clock_div(&dss_cinfo);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nvoid dss_set_venc_output(enum omap_dss_venc_type type)\r\n{\r\nint l = 0;\r\nif (type == OMAP_DSS_VENC_TYPE_COMPOSITE)\r\nl = 0;\r\nelse if (type == OMAP_DSS_VENC_TYPE_SVIDEO)\r\nl = 1;\r\nelse\r\nBUG();\r\nREG_FLD_MOD(DSS_CONTROL, l, 6, 6);\r\n}\r\nvoid dss_set_dac_pwrdn_bgz(bool enable)\r\n{\r\nREG_FLD_MOD(DSS_CONTROL, enable, 5, 5);\r\n}\r\nvoid dss_select_hdmi_venc_clk_source(enum dss_hdmi_venc_clk_source_select src)\r\n{\r\nenum omap_display_type dp;\r\ndp = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);\r\nWARN_ON((src == DSS_VENC_TV_CLK) && !(dp & OMAP_DISPLAY_TYPE_VENC));\r\nWARN_ON((src == DSS_HDMI_M_PCLK) && !(dp & OMAP_DISPLAY_TYPE_HDMI));\r\nif ((dp & OMAP_DISPLAY_TYPE_VENC) && (dp & OMAP_DISPLAY_TYPE_HDMI))\r\nREG_FLD_MOD(DSS_CONTROL, src, 15, 15);\r\n}\r\nenum dss_hdmi_venc_clk_source_select dss_get_hdmi_venc_clk_source(void)\r\n{\r\nenum omap_display_type displays;\r\ndisplays = dss_feat_get_supported_displays(OMAP_DSS_CHANNEL_DIGIT);\r\nif ((displays & OMAP_DISPLAY_TYPE_HDMI) == 0)\r\nreturn DSS_VENC_TV_CLK;\r\nif ((displays & OMAP_DISPLAY_TYPE_VENC) == 0)\r\nreturn DSS_HDMI_M_PCLK;\r\nreturn REG_GET(DSS_CONTROL, 15, 15);\r\n}\r\nstatic int dss_dpi_select_source_omap2_omap3(enum omap_channel channel)\r\n{\r\nif (channel != OMAP_DSS_CHANNEL_LCD)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dss_dpi_select_source_omap4(enum omap_channel channel)\r\n{\r\nint val;\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nval = 0;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_DIGIT:\r\nval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nREG_FLD_MOD(DSS_CONTROL, val, 17, 17);\r\nreturn 0;\r\n}\r\nstatic int dss_dpi_select_source_omap5(enum omap_channel channel)\r\n{\r\nint val;\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nval = 1;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nval = 2;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nval = 3;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_DIGIT:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nREG_FLD_MOD(DSS_CONTROL, val, 17, 16);\r\nreturn 0;\r\n}\r\nint dss_dpi_select_source(enum omap_channel channel)\r\n{\r\nreturn dss.feat->dpi_select_source(channel);\r\n}\r\nstatic int dss_get_clocks(void)\r\n{\r\nstruct clk *clk;\r\nclk = devm_clk_get(&dss.pdev->dev, "fck");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get clock fck\n");\r\nreturn PTR_ERR(clk);\r\n}\r\ndss.dss_clk = clk;\r\nif (dss.feat->clk_name) {\r\nclk = clk_get(NULL, dss.feat->clk_name);\r\nif (IS_ERR(clk)) {\r\nDSSERR("Failed to get %s\n", dss.feat->clk_name);\r\nreturn PTR_ERR(clk);\r\n}\r\n} else {\r\nclk = NULL;\r\n}\r\ndss.dpll4_m4_ck = clk;\r\nreturn 0;\r\n}\r\nstatic void dss_put_clocks(void)\r\n{\r\nif (dss.dpll4_m4_ck)\r\nclk_put(dss.dpll4_m4_ck);\r\n}\r\nstatic int dss_runtime_get(void)\r\n{\r\nint r;\r\nDSSDBG("dss_runtime_get\n");\r\nr = pm_runtime_get_sync(&dss.pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nstatic void dss_runtime_put(void)\r\n{\r\nint r;\r\nDSSDBG("dss_runtime_put\n");\r\nr = pm_runtime_put_sync(&dss.pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);\r\n}\r\nvoid dss_debug_dump_clocks(struct seq_file *s)\r\n{\r\ndss_dump_clocks(s);\r\ndispc_dump_clocks(s);\r\n#ifdef CONFIG_OMAP2_DSS_DSI\r\ndsi_dump_clocks(s);\r\n#endif\r\n}\r\nstatic int __init dss_init_features(struct platform_device *pdev)\r\n{\r\nconst struct dss_features *src;\r\nstruct dss_features *dst;\r\ndst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);\r\nif (!dst) {\r\ndev_err(&pdev->dev, "Failed to allocate local DSS Features\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\nsrc = &omap24xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_AM35xx:\r\nsrc = &omap34xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP3630:\r\nsrc = &omap3630_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nsrc = &omap44xx_dss_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\nsrc = &omap54xx_dss_feats;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmemcpy(dst, src, sizeof(*dst));\r\ndss.feat = dst;\r\nreturn 0;\r\n}\r\nstatic int __init omap_dsshw_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *dss_mem;\r\nu32 rev;\r\nint r;\r\ndss.pdev = pdev;\r\nr = dss_init_features(dss.pdev);\r\nif (r)\r\nreturn r;\r\ndss_mem = platform_get_resource(dss.pdev, IORESOURCE_MEM, 0);\r\nif (!dss_mem) {\r\nDSSERR("can't get IORESOURCE_MEM DSS\n");\r\nreturn -EINVAL;\r\n}\r\ndss.base = devm_ioremap(&pdev->dev, dss_mem->start,\r\nresource_size(dss_mem));\r\nif (!dss.base) {\r\nDSSERR("can't ioremap DSS\n");\r\nreturn -ENOMEM;\r\n}\r\nr = dss_get_clocks();\r\nif (r)\r\nreturn r;\r\nr = dss_setup_default_clock();\r\nif (r)\r\ngoto err_setup_clocks;\r\npm_runtime_enable(&pdev->dev);\r\nr = dss_runtime_get();\r\nif (r)\r\ngoto err_runtime_get;\r\ndss.dss_clk_rate = clk_get_rate(dss.dss_clk);\r\nREG_FLD_MOD(DSS_CONTROL, 0, 0, 0);\r\ndss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);\r\n#ifdef CONFIG_OMAP2_DSS_VENC\r\nREG_FLD_MOD(DSS_CONTROL, 1, 4, 4);\r\nREG_FLD_MOD(DSS_CONTROL, 1, 3, 3);\r\nREG_FLD_MOD(DSS_CONTROL, 0, 2, 2);\r\n#endif\r\ndss.dsi_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;\r\ndss.dsi_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;\r\ndss.dispc_clk_source = OMAP_DSS_CLK_SRC_FCK;\r\ndss.lcd_clk_source[0] = OMAP_DSS_CLK_SRC_FCK;\r\ndss.lcd_clk_source[1] = OMAP_DSS_CLK_SRC_FCK;\r\nrev = dss_read_reg(DSS_REVISION);\r\nprintk(KERN_INFO "OMAP DSS rev %d.%d\n",\r\nFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\r\ndss_runtime_put();\r\ndss_debugfs_create_file("dss", dss_dump_regs);\r\nreturn 0;\r\nerr_runtime_get:\r\npm_runtime_disable(&pdev->dev);\r\nerr_setup_clocks:\r\ndss_put_clocks();\r\nreturn r;\r\n}\r\nstatic int __exit omap_dsshw_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\ndss_put_clocks();\r\nreturn 0;\r\n}\r\nstatic int dss_runtime_suspend(struct device *dev)\r\n{\r\ndss_save_context();\r\ndss_set_min_bus_tput(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int dss_runtime_resume(struct device *dev)\r\n{\r\nint r;\r\nr = dss_set_min_bus_tput(dev, 1000000000);\r\nif (r)\r\nreturn r;\r\ndss_restore_context();\r\nreturn 0;\r\n}\r\nint __init dss_init_platform_driver(void)\r\n{\r\nreturn platform_driver_probe(&omap_dsshw_driver, omap_dsshw_probe);\r\n}\r\nvoid dss_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dsshw_driver);\r\n}
