static ssize_t path_show(struct pci_slot *pci_slot, char *buf)\r\n{\r\nint retval = -ENOENT;\r\nstruct slot *slot = pci_slot->hotplug->private;\r\nif (!slot)\r\nreturn retval;\r\nretval = sprintf (buf, "%s\n", slot->physical_path);\r\nreturn retval;\r\n}\r\nstatic int sn_pci_slot_valid(struct pci_bus *pci_bus, int device)\r\n{\r\nstruct pcibus_info *pcibus_info;\r\nu16 busnum, segment, ioboard_type;\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(pci_bus);\r\nif (!(pcibus_info->pbi_valid_devices & (1 << device)))\r\nreturn -EPERM;\r\nioboard_type = sn_ioboard_to_pci_bus(pci_bus);\r\nbusnum = pcibus_info->pbi_buscommon.bs_persist_busnum;\r\nsegment = pci_domain_nr(pci_bus) & 0xf;\r\nif ((ioboard_type == L1_BRICKTYPE_IX ||\r\nioboard_type == L1_BRICKTYPE_IA) &&\r\n(segment == 1 && busnum == 0 && device != 1))\r\nreturn -EPERM;\r\nreturn 1;\r\n}\r\nstatic int sn_pci_bus_valid(struct pci_bus *pci_bus)\r\n{\r\nstruct pcibus_info *pcibus_info;\r\nu32 asic_type;\r\nu16 ioboard_type;\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(pci_bus);\r\nasic_type = pcibus_info->pbi_buscommon.bs_asic_type;\r\nif (asic_type == PCIIO_ASIC_TYPE_TIOCA)\r\nreturn -EPERM;\r\nioboard_type = sn_ioboard_to_pci_bus(pci_bus);\r\nswitch (ioboard_type) {\r\ncase L1_BRICKTYPE_IX:\r\ncase L1_BRICKTYPE_PX:\r\ncase L1_BRICKTYPE_IA:\r\ncase L1_BRICKTYPE_PA:\r\ncase L1_BOARDTYPE_PCIX3SLOT:\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nreturn -EPERM;\r\nbreak;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int sn_hp_slot_private_alloc(struct hotplug_slot *bss_hotplug_slot,\r\nstruct pci_bus *pci_bus, int device,\r\nchar *name)\r\n{\r\nstruct pcibus_info *pcibus_info;\r\nstruct slot *slot;\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(pci_bus);\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot)\r\nreturn -ENOMEM;\r\nbss_hotplug_slot->private = slot;\r\nslot->device_num = device;\r\nslot->pci_bus = pci_bus;\r\nsprintf(name, "%04x:%02x:%02x",\r\npci_domain_nr(pci_bus),\r\n((u16)pcibus_info->pbi_buscommon.bs_persist_busnum),\r\ndevice + 1);\r\nsn_generate_path(pci_bus, slot->physical_path);\r\nslot->hotplug_slot = bss_hotplug_slot;\r\nlist_add(&slot->hp_list, &sn_hp_list);\r\nreturn 0;\r\n}\r\nstatic struct hotplug_slot * sn_hp_destroy(void)\r\n{\r\nstruct slot *slot;\r\nstruct pci_slot *pci_slot;\r\nstruct hotplug_slot *bss_hotplug_slot = NULL;\r\nlist_for_each_entry(slot, &sn_hp_list, hp_list) {\r\nbss_hotplug_slot = slot->hotplug_slot;\r\npci_slot = bss_hotplug_slot->pci_slot;\r\nlist_del(&((struct slot *)bss_hotplug_slot->private)->\r\nhp_list);\r\nsysfs_remove_file(&pci_slot->kobj,\r\n&sn_slot_path_attr.attr);\r\nbreak;\r\n}\r\nreturn bss_hotplug_slot;\r\n}\r\nstatic void sn_bus_free_data(struct pci_dev *dev)\r\n{\r\nstruct pci_bus *subordinate_bus;\r\nstruct pci_dev *child;\r\nif (dev->subordinate) {\r\nsubordinate_bus = dev->subordinate;\r\nlist_for_each_entry(child, &subordinate_bus->devices, bus_list)\r\nsn_bus_free_data(child);\r\n}\r\nsn_bus_store_sysdata(dev);\r\nsn_pci_unfixup_slot(dev);\r\n}\r\nstatic int sn_slot_enable(struct hotplug_slot *bss_hotplug_slot,\r\nint device_num, char **ssdt)\r\n{\r\nstruct slot *slot = bss_hotplug_slot->private;\r\nstruct pcibus_info *pcibus_info;\r\nstruct pcibr_slot_enable_resp resp;\r\nint rc;\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(slot->pci_bus);\r\nrc = sal_pcibr_slot_enable(pcibus_info, device_num, &resp, ssdt);\r\nif (rc == PCI_SLOT_ALREADY_UP) {\r\ndev_dbg(&slot->pci_bus->self->dev, "is already active\n");\r\nreturn 1;\r\n}\r\nif (rc == PCI_L1_ERR) {\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"L1 failure %d with message: %s",\r\nresp.resp_sub_errno, resp.resp_l1_msg);\r\nreturn -EPERM;\r\n}\r\nif (rc) {\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"insert failed with error %d sub-error %d\n",\r\nrc, resp.resp_sub_errno);\r\nreturn -EIO;\r\n}\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(slot->pci_bus);\r\npcibus_info->pbi_enabled_devices |= (1 << device_num);\r\nreturn 0;\r\n}\r\nstatic int sn_slot_disable(struct hotplug_slot *bss_hotplug_slot,\r\nint device_num, int action)\r\n{\r\nstruct slot *slot = bss_hotplug_slot->private;\r\nstruct pcibus_info *pcibus_info;\r\nstruct pcibr_slot_disable_resp resp;\r\nint rc;\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(slot->pci_bus);\r\nrc = sal_pcibr_slot_disable(pcibus_info, device_num, action, &resp);\r\nif ((action == PCI_REQ_SLOT_ELIGIBLE) &&\r\n(rc == PCI_SLOT_ALREADY_DOWN)) {\r\ndev_dbg(&slot->pci_bus->self->dev, "Slot %s already inactive\n", slot->physical_path);\r\nreturn 1;\r\n}\r\nif ((action == PCI_REQ_SLOT_ELIGIBLE) && (rc == PCI_EMPTY_33MHZ)) {\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"Cannot remove last 33MHz card\n");\r\nreturn -EPERM;\r\n}\r\nif ((action == PCI_REQ_SLOT_ELIGIBLE) && (rc == PCI_L1_ERR)) {\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"L1 failure %d with message \n%s\n",\r\nresp.resp_sub_errno, resp.resp_l1_msg);\r\nreturn -EPERM;\r\n}\r\nif ((action == PCI_REQ_SLOT_ELIGIBLE) && rc) {\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"remove failed with error %d sub-error %d\n",\r\nrc, resp.resp_sub_errno);\r\nreturn -EIO;\r\n}\r\nif ((action == PCI_REQ_SLOT_ELIGIBLE) && !rc)\r\nreturn 0;\r\nif ((action == PCI_REQ_SLOT_DISABLE) && !rc) {\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(slot->pci_bus);\r\npcibus_info->pbi_enabled_devices &= ~(1 << device_num);\r\ndev_dbg(&slot->pci_bus->self->dev, "remove successful\n");\r\nreturn 0;\r\n}\r\nif ((action == PCI_REQ_SLOT_DISABLE) && rc) {\r\ndev_dbg(&slot->pci_bus->self->dev,"remove failed rc = %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int enable_slot(struct hotplug_slot *bss_hotplug_slot)\r\n{\r\nstruct slot *slot = bss_hotplug_slot->private;\r\nstruct pci_bus *new_bus = NULL;\r\nstruct pci_dev *dev;\r\nint num_funcs;\r\nint new_ppb = 0;\r\nint rc;\r\nchar *ssdt = NULL;\r\nvoid pcibios_fixup_device_resources(struct pci_dev *);\r\nmutex_lock(&sn_hotplug_mutex);\r\nrc = sn_slot_enable(bss_hotplug_slot, slot->device_num, &ssdt);\r\nif (rc) {\r\nmutex_unlock(&sn_hotplug_mutex);\r\nreturn rc;\r\n}\r\nif (ssdt)\r\nssdt = __va(ssdt);\r\nif (SN_ACPI_BASE_SUPPORT() && ssdt) {\r\nacpi_status ret;\r\nret = acpi_load_table((struct acpi_table_header *)ssdt);\r\nif (ACPI_FAILURE(ret)) {\r\nprintk(KERN_ERR "%s: acpi_load_table failed (0x%x)\n",\r\n__func__, ret);\r\n}\r\n}\r\nnum_funcs = pci_scan_slot(slot->pci_bus,\r\nPCI_DEVFN(slot->device_num + 1, 0));\r\nif (!num_funcs) {\r\ndev_dbg(&slot->pci_bus->self->dev, "no device in slot\n");\r\nmutex_unlock(&sn_hotplug_mutex);\r\nreturn -ENODEV;\r\n}\r\nlist_for_each_entry(dev, &slot->pci_bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != slot->device_num + 1)\r\ncontinue;\r\npcibios_fixup_device_resources(dev);\r\nif (SN_ACPI_BASE_SUPPORT())\r\nsn_acpi_slot_fixup(dev);\r\nelse\r\nsn_io_slot_fixup(dev);\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\npci_hp_add_bridge(dev);\r\nif (dev->subordinate) {\r\nnew_bus = dev->subordinate;\r\nnew_ppb = 1;\r\n}\r\n}\r\n}\r\nif (SN_ACPI_BASE_SUPPORT() && ssdt) {\r\nunsigned long long adr;\r\nstruct acpi_device *pdevice;\r\nacpi_handle phandle;\r\nacpi_handle chandle = NULL;\r\nacpi_handle rethandle;\r\nacpi_status ret;\r\nphandle = PCI_CONTROLLER(slot->pci_bus)->acpi_handle;\r\nif (acpi_bus_get_device(phandle, &pdevice)) {\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"no parent device, assuming NULL\n");\r\npdevice = NULL;\r\n}\r\nacpi_scan_lock_acquire();\r\nfor (;;) {\r\nrethandle = NULL;\r\nret = acpi_get_next_object(ACPI_TYPE_DEVICE,\r\nphandle, chandle,\r\n&rethandle);\r\nif (ret == AE_NOT_FOUND || rethandle == NULL)\r\nbreak;\r\nchandle = rethandle;\r\nret = acpi_evaluate_integer(chandle, METHOD_NAME__ADR,\r\nNULL, &adr);\r\nif (ACPI_SUCCESS(ret) &&\r\n(adr>>16) == (slot->device_num + 1)) {\r\nret = acpi_bus_scan(chandle);\r\nif (ACPI_FAILURE(ret)) {\r\nprintk(KERN_ERR "%s: acpi_bus_scan "\r\n"failed (0x%x) for slot %d "\r\n"func %d\n", __func__,\r\nret, (int)(adr>>16),\r\n(int)(adr&0xffff));\r\n}\r\n}\r\n}\r\nacpi_scan_lock_release();\r\n}\r\npci_bus_add_devices(slot->pci_bus);\r\nif (new_ppb)\r\npci_bus_add_devices(new_bus);\r\nmutex_unlock(&sn_hotplug_mutex);\r\nif (rc == 0)\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"insert operation successful\n");\r\nelse\r\ndev_dbg(&slot->pci_bus->self->dev,\r\n"insert operation failed rc = %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int disable_slot(struct hotplug_slot *bss_hotplug_slot)\r\n{\r\nstruct slot *slot = bss_hotplug_slot->private;\r\nstruct pci_dev *dev, *temp;\r\nint rc;\r\nacpi_owner_id ssdt_id = 0;\r\nmutex_lock(&sn_hotplug_mutex);\r\nrc = sn_slot_disable(bss_hotplug_slot, slot->device_num,\r\nPCI_REQ_SLOT_ELIGIBLE);\r\nif (rc)\r\ngoto leaving;\r\nif (SN_ACPI_BASE_SUPPORT() &&\r\nPCI_CONTROLLER(slot->pci_bus)->acpi_handle) {\r\nunsigned long long adr;\r\nstruct acpi_device *device;\r\nacpi_handle phandle;\r\nacpi_handle chandle = NULL;\r\nacpi_handle rethandle;\r\nacpi_status ret;\r\nphandle = PCI_CONTROLLER(slot->pci_bus)->acpi_handle;\r\nacpi_scan_lock_acquire();\r\nfor (;;) {\r\nrethandle = NULL;\r\nret = acpi_get_next_object(ACPI_TYPE_DEVICE,\r\nphandle, chandle,\r\n&rethandle);\r\nif (ret == AE_NOT_FOUND || rethandle == NULL)\r\nbreak;\r\nchandle = rethandle;\r\nret = acpi_evaluate_integer(chandle,\r\nMETHOD_NAME__ADR,\r\nNULL, &adr);\r\nif (ACPI_SUCCESS(ret) &&\r\n(adr>>16) == (slot->device_num + 1)) {\r\nacpi_get_id(chandle, &ssdt_id);\r\nret = acpi_bus_get_device(chandle,\r\n&device);\r\nif (ACPI_SUCCESS(ret))\r\nacpi_bus_trim(device);\r\n}\r\n}\r\nacpi_scan_lock_release();\r\n}\r\nlist_for_each_entry_safe(dev, temp, &slot->pci_bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != slot->device_num + 1)\r\ncontinue;\r\npci_dev_get(dev);\r\nsn_bus_free_data(dev);\r\npci_stop_and_remove_bus_device(dev);\r\npci_dev_put(dev);\r\n}\r\nif (SN_ACPI_BASE_SUPPORT() && ssdt_id) {\r\nacpi_status ret;\r\nret = acpi_unload_table_id(ssdt_id);\r\nif (ACPI_FAILURE(ret)) {\r\nprintk(KERN_ERR "%s: acpi_unload_table_id "\r\n"failed (0x%x) for id %d\n",\r\n__func__, ret, ssdt_id);\r\n}\r\n}\r\nsn_bus_free_sysdata();\r\nrc = sn_slot_disable(bss_hotplug_slot, slot->device_num,\r\nPCI_REQ_SLOT_DISABLE);\r\nleaving:\r\nmutex_unlock(&sn_hotplug_mutex);\r\nreturn rc;\r\n}\r\nstatic inline int get_power_status(struct hotplug_slot *bss_hotplug_slot,\r\nu8 *value)\r\n{\r\nstruct slot *slot = bss_hotplug_slot->private;\r\nstruct pcibus_info *pcibus_info;\r\nu32 power;\r\npcibus_info = SN_PCIBUS_BUSSOFT_INFO(slot->pci_bus);\r\nmutex_lock(&sn_hotplug_mutex);\r\npower = pcibus_info->pbi_enabled_devices & (1 << slot->device_num);\r\n*value = power ? 1 : 0;\r\nmutex_unlock(&sn_hotplug_mutex);\r\nreturn 0;\r\n}\r\nstatic void sn_release_slot(struct hotplug_slot *bss_hotplug_slot)\r\n{\r\nkfree(bss_hotplug_slot->info);\r\nkfree(bss_hotplug_slot->private);\r\nkfree(bss_hotplug_slot);\r\n}\r\nstatic int sn_hotplug_slot_register(struct pci_bus *pci_bus)\r\n{\r\nint device;\r\nstruct pci_slot *pci_slot;\r\nstruct hotplug_slot *bss_hotplug_slot;\r\nchar name[SN_SLOT_NAME_SIZE];\r\nint rc = 0;\r\nfor (device = 0; device < SN_MAX_HP_SLOTS ; device++) {\r\nif (sn_pci_slot_valid(pci_bus, device) != 1)\r\ncontinue;\r\nbss_hotplug_slot = kzalloc(sizeof(*bss_hotplug_slot),\r\nGFP_KERNEL);\r\nif (!bss_hotplug_slot) {\r\nrc = -ENOMEM;\r\ngoto alloc_err;\r\n}\r\nbss_hotplug_slot->info =\r\nkzalloc(sizeof(struct hotplug_slot_info),\r\nGFP_KERNEL);\r\nif (!bss_hotplug_slot->info) {\r\nrc = -ENOMEM;\r\ngoto alloc_err;\r\n}\r\nif (sn_hp_slot_private_alloc(bss_hotplug_slot,\r\npci_bus, device, name)) {\r\nrc = -ENOMEM;\r\ngoto alloc_err;\r\n}\r\nbss_hotplug_slot->ops = &sn_hotplug_slot_ops;\r\nbss_hotplug_slot->release = &sn_release_slot;\r\nrc = pci_hp_register(bss_hotplug_slot, pci_bus, device, name);\r\nif (rc)\r\ngoto register_err;\r\npci_slot = bss_hotplug_slot->pci_slot;\r\nrc = sysfs_create_file(&pci_slot->kobj,\r\n&sn_slot_path_attr.attr);\r\nif (rc)\r\ngoto register_err;\r\n}\r\ndev_dbg(&pci_bus->self->dev, "Registered bus with hotplug\n");\r\nreturn rc;\r\nregister_err:\r\ndev_dbg(&pci_bus->self->dev, "bus failed to register with err = %d\n",\r\nrc);\r\nalloc_err:\r\nif (rc == -ENOMEM)\r\ndev_dbg(&pci_bus->self->dev, "Memory allocation error\n");\r\nif (bss_hotplug_slot)\r\nsn_release_slot(bss_hotplug_slot);\r\nwhile ((bss_hotplug_slot = sn_hp_destroy()))\r\npci_hp_deregister(bss_hotplug_slot);\r\nreturn rc;\r\n}\r\nstatic int __init sn_pci_hotplug_init(void)\r\n{\r\nstruct pci_bus *pci_bus = NULL;\r\nint rc;\r\nint registered = 0;\r\nif (!sn_prom_feature_available(PRF_HOTPLUG_SUPPORT)) {\r\nprintk(KERN_ERR "%s: PROM version does not support hotplug.\n",\r\n__func__);\r\nreturn -EPERM;\r\n}\r\nINIT_LIST_HEAD(&sn_hp_list);\r\nwhile ((pci_bus = pci_find_next_bus(pci_bus))) {\r\nif (!pci_bus->sysdata)\r\ncontinue;\r\nrc = sn_pci_bus_valid(pci_bus);\r\nif (rc != 1) {\r\ndev_dbg(&pci_bus->self->dev, "not a valid hotplug bus\n");\r\ncontinue;\r\n}\r\ndev_dbg(&pci_bus->self->dev, "valid hotplug bus\n");\r\nrc = sn_hotplug_slot_register(pci_bus);\r\nif (!rc) {\r\nregistered = 1;\r\n} else {\r\nregistered = 0;\r\nbreak;\r\n}\r\n}\r\nreturn registered == 1 ? 0 : -ENODEV;\r\n}\r\nstatic void __exit sn_pci_hotplug_exit(void)\r\n{\r\nstruct hotplug_slot *bss_hotplug_slot;\r\nwhile ((bss_hotplug_slot = sn_hp_destroy()))\r\npci_hp_deregister(bss_hotplug_slot);\r\nif (!list_empty(&sn_hp_list))\r\nprintk(KERN_ERR "%s: internal list is not empty\n", __FILE__);\r\n}
