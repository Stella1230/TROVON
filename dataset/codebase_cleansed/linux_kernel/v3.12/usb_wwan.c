void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nintfdata = port->serial->private;\r\nif (!intfdata->send_setup)\r\nreturn;\r\nportdata = usb_get_serial_port_data(port);\r\nportdata->rts_state = on;\r\nportdata->dtr_state = on;\r\nintfdata->send_setup(port);\r\n}\r\nvoid usb_wwan_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_wwan_intf_private *intfdata = port->serial->private;\r\ntty_termios_copy_hw(&tty->termios, old_termios);\r\nif (intfdata->send_setup)\r\nintfdata->send_setup(port);\r\n}\r\nint usb_wwan_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned int value;\r\nstruct usb_wwan_port_private *portdata;\r\nportdata = usb_get_serial_port_data(port);\r\nvalue = ((portdata->rts_state) ? TIOCM_RTS : 0) |\r\n((portdata->dtr_state) ? TIOCM_DTR : 0) |\r\n((portdata->cts_state) ? TIOCM_CTS : 0) |\r\n((portdata->dsr_state) ? TIOCM_DSR : 0) |\r\n((portdata->dcd_state) ? TIOCM_CAR : 0) |\r\n((portdata->ri_state) ? TIOCM_RNG : 0);\r\nreturn value;\r\n}\r\nint usb_wwan_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = port->serial->private;\r\nif (!intfdata->send_setup)\r\nreturn -EINVAL;\r\nif (set & TIOCM_RTS)\r\nportdata->rts_state = 1;\r\nif (set & TIOCM_DTR)\r\nportdata->dtr_state = 1;\r\nif (clear & TIOCM_RTS)\r\nportdata->rts_state = 0;\r\nif (clear & TIOCM_DTR)\r\nportdata->dtr_state = 0;\r\nreturn intfdata->send_setup(port);\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.line = port->minor;\r\ntmp.port = port->port_number;\r\ntmp.baud_base = tty_get_baud_rate(port->port.tty);\r\ntmp.close_delay = port->port.close_delay / 10;\r\ntmp.closing_wait = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE :\r\nport->port.closing_wait / 10;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *newinfo)\r\n{\r\nstruct serial_struct new_serial;\r\nunsigned int closing_wait, close_delay;\r\nint retval = 0;\r\nif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nclose_delay = new_serial.close_delay * 10;\r\nclosing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;\r\nmutex_lock(&port->port.mutex);\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((close_delay != port->port.close_delay) ||\r\n(closing_wait != port->port.closing_wait))\r\nretval = -EPERM;\r\nelse\r\nretval = -EOPNOTSUPP;\r\n} else {\r\nport->port.close_delay = close_delay;\r\nport->port.closing_wait = closing_wait;\r\n}\r\nmutex_unlock(&port->port.mutex);\r\nreturn retval;\r\n}\r\nint usb_wwan_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(&port->dev, "%s arg not supported\n", __func__);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint usb_wwan_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nint i;\r\nint left, todo;\r\nstruct urb *this_urb = NULL;\r\nint err;\r\nunsigned long flags;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = port->serial->private;\r\ndev_dbg(&port->dev, "%s: write (%d chars)\n", __func__, count);\r\ni = 0;\r\nleft = count;\r\nfor (i = 0; left > 0 && i < N_OUT_URB; i++) {\r\ntodo = left;\r\nif (todo > OUT_BUFLEN)\r\ntodo = OUT_BUFLEN;\r\nthis_urb = portdata->out_urbs[i];\r\nif (test_and_set_bit(i, &portdata->out_busy)) {\r\nif (time_before(jiffies,\r\nportdata->tx_start_time[i] + 10 * HZ))\r\ncontinue;\r\nusb_unlink_urb(this_urb);\r\ncontinue;\r\n}\r\ndev_dbg(&port->dev, "%s: endpoint %d buf %d\n", __func__,\r\nusb_pipeendpoint(this_urb->pipe), i);\r\nerr = usb_autopm_get_interface_async(port->serial->interface);\r\nif (err < 0)\r\nbreak;\r\nmemcpy(this_urb->transfer_buffer, buf, todo);\r\nthis_urb->transfer_buffer_length = todo;\r\nspin_lock_irqsave(&intfdata->susp_lock, flags);\r\nif (intfdata->suspended) {\r\nusb_anchor_urb(this_urb, &portdata->delayed);\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\n} else {\r\nintfdata->in_flight++;\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err) {\r\ndev_dbg(&port->dev,\r\n"usb_submit_urb %p (write bulk) failed (%d)\n",\r\nthis_urb, err);\r\nclear_bit(i, &portdata->out_busy);\r\nspin_lock_irqsave(&intfdata->susp_lock, flags);\r\nintfdata->in_flight--;\r\nspin_unlock_irqrestore(&intfdata->susp_lock,\r\nflags);\r\nusb_autopm_put_interface_async(port->serial->interface);\r\nbreak;\r\n}\r\n}\r\nportdata->tx_start_time[i] = jiffies;\r\nbuf += todo;\r\nleft -= todo;\r\n}\r\ncount -= left;\r\ndev_dbg(&port->dev, "%s: wrote (did %d)\n", __func__, count);\r\nreturn count;\r\n}\r\nstatic void usb_wwan_indat_callback(struct urb *urb)\r\n{\r\nint err;\r\nint endpoint;\r\nstruct usb_serial_port *port;\r\nstruct device *dev;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\nendpoint = usb_pipeendpoint(urb->pipe);\r\nport = urb->context;\r\ndev = &port->dev;\r\nif (status) {\r\ndev_dbg(dev, "%s: nonzero status: %d on endpoint %02x.\n",\r\n__func__, status, endpoint);\r\n} else {\r\nif (urb->actual_length) {\r\ntty_insert_flip_string(&port->port, data,\r\nurb->actual_length);\r\ntty_flip_buffer_push(&port->port);\r\n} else\r\ndev_dbg(dev, "%s: empty read urb received\n", __func__);\r\n}\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nif (err != -EPERM) {\r\ndev_err(dev, "%s: resubmit read urb failed. (%d)\n",\r\n__func__, err);\r\nusb_mark_last_busy(port->serial->dev);\r\n}\r\n} else {\r\nusb_mark_last_busy(port->serial->dev);\r\n}\r\n}\r\nstatic void usb_wwan_outdat_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nint i;\r\nport = urb->context;\r\nintfdata = port->serial->private;\r\nusb_serial_port_softint(port);\r\nusb_autopm_put_interface_async(port->serial->interface);\r\nportdata = usb_get_serial_port_data(port);\r\nspin_lock(&intfdata->susp_lock);\r\nintfdata->in_flight--;\r\nspin_unlock(&intfdata->susp_lock);\r\nfor (i = 0; i < N_OUT_URB; ++i) {\r\nif (portdata->out_urbs[i] == urb) {\r\nsmp_mb__before_clear_bit();\r\nclear_bit(i, &portdata->out_busy);\r\nbreak;\r\n}\r\n}\r\n}\r\nint usb_wwan_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_wwan_port_private *portdata;\r\nint i;\r\nint data_len = 0;\r\nstruct urb *this_urb;\r\nportdata = usb_get_serial_port_data(port);\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nthis_urb = portdata->out_urbs[i];\r\nif (this_urb && !test_bit(i, &portdata->out_busy))\r\ndata_len += OUT_BUFLEN;\r\n}\r\ndev_dbg(&port->dev, "%s: %d\n", __func__, data_len);\r\nreturn data_len;\r\n}\r\nint usb_wwan_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_wwan_port_private *portdata;\r\nint i;\r\nint data_len = 0;\r\nstruct urb *this_urb;\r\nportdata = usb_get_serial_port_data(port);\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nthis_urb = portdata->out_urbs[i];\r\nif (this_urb && test_bit(i, &portdata->out_busy))\r\ndata_len += this_urb->transfer_buffer_length;\r\n}\r\ndev_dbg(&port->dev, "%s: %d\n", __func__, data_len);\r\nreturn data_len;\r\n}\r\nint usb_wwan_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nstruct usb_serial *serial = port->serial;\r\nint i, err;\r\nstruct urb *urb;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = serial->private;\r\nfor (i = 0; i < N_IN_URB; i++) {\r\nurb = portdata->in_urbs[i];\r\nif (!urb)\r\ncontinue;\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\ndev_dbg(&port->dev, "%s: submit urb %d failed (%d) %d\n",\r\n__func__, i, err, urb->transfer_buffer_length);\r\n}\r\n}\r\nif (intfdata->send_setup)\r\nintfdata->send_setup(port);\r\nserial->interface->needs_remote_wakeup = 1;\r\nspin_lock_irq(&intfdata->susp_lock);\r\nportdata->opened = 1;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nusb_autopm_put_interface(serial->interface);\r\nreturn 0;\r\n}\r\nvoid usb_wwan_close(struct usb_serial_port *port)\r\n{\r\nint i;\r\nstruct usb_serial *serial = port->serial;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata = port->serial->private;\r\nportdata = usb_get_serial_port_data(port);\r\nspin_lock_irq(&intfdata->susp_lock);\r\nportdata->opened = 0;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nfor (i = 0; i < N_IN_URB; i++)\r\nusb_kill_urb(portdata->in_urbs[i]);\r\nfor (i = 0; i < N_OUT_URB; i++)\r\nusb_kill_urb(portdata->out_urbs[i]);\r\nusb_autopm_get_interface_no_resume(serial->interface);\r\nserial->interface->needs_remote_wakeup = 0;\r\n}\r\nstatic struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,\r\nint endpoint,\r\nint dir, void *ctx, char *buf, int len,\r\nvoid (*callback) (struct urb *))\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct urb *urb;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndev_dbg(&serial->interface->dev,\r\n"%s: alloc for endpoint %d failed.\n", __func__,\r\nendpoint);\r\nreturn NULL;\r\n}\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev, endpoint) | dir,\r\nbuf, len, callback, ctx);\r\nreturn urb;\r\n}\r\nint usb_wwan_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_wwan_port_private *portdata;\r\nstruct urb *urb;\r\nu8 *buffer;\r\nint err;\r\nint i;\r\nportdata = kzalloc(sizeof(*portdata), GFP_KERNEL);\r\nif (!portdata)\r\nreturn -ENOMEM;\r\ninit_usb_anchor(&portdata->delayed);\r\nfor (i = 0; i < N_IN_URB; i++) {\r\nif (!port->bulk_in_size)\r\nbreak;\r\nbuffer = (u8 *)__get_free_page(GFP_KERNEL);\r\nif (!buffer)\r\ngoto bail_out_error;\r\nportdata->in_buffer[i] = buffer;\r\nurb = usb_wwan_setup_urb(port, port->bulk_in_endpointAddress,\r\nUSB_DIR_IN, port,\r\nbuffer, IN_BUFLEN,\r\nusb_wwan_indat_callback);\r\nportdata->in_urbs[i] = urb;\r\n}\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nif (!port->bulk_out_size)\r\nbreak;\r\nbuffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);\r\nif (!buffer)\r\ngoto bail_out_error2;\r\nportdata->out_buffer[i] = buffer;\r\nurb = usb_wwan_setup_urb(port, port->bulk_out_endpointAddress,\r\nUSB_DIR_OUT, port,\r\nbuffer, OUT_BUFLEN,\r\nusb_wwan_outdat_callback);\r\nportdata->out_urbs[i] = urb;\r\n}\r\nusb_set_serial_port_data(port, portdata);\r\nif (port->interrupt_in_urb) {\r\nerr = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (err)\r\ndev_dbg(&port->dev, "%s: submit irq_in urb failed %d\n",\r\n__func__, err);\r\n}\r\nreturn 0;\r\nbail_out_error2:\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nusb_free_urb(portdata->out_urbs[i]);\r\nkfree(portdata->out_buffer[i]);\r\n}\r\nbail_out_error:\r\nfor (i = 0; i < N_IN_URB; i++) {\r\nusb_free_urb(portdata->in_urbs[i]);\r\nfree_page((unsigned long)portdata->in_buffer[i]);\r\n}\r\nkfree(portdata);\r\nreturn -ENOMEM;\r\n}\r\nint usb_wwan_port_remove(struct usb_serial_port *port)\r\n{\r\nint i;\r\nstruct usb_wwan_port_private *portdata;\r\nportdata = usb_get_serial_port_data(port);\r\nusb_set_serial_port_data(port, NULL);\r\nfor (i = 0; i < N_IN_URB; i++) {\r\nusb_kill_urb(portdata->in_urbs[i]);\r\nusb_free_urb(portdata->in_urbs[i]);\r\nfree_page((unsigned long)portdata->in_buffer[i]);\r\n}\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nusb_kill_urb(portdata->out_urbs[i]);\r\nusb_free_urb(portdata->out_urbs[i]);\r\nkfree(portdata->out_buffer[i]);\r\n}\r\nkfree(portdata);\r\nreturn 0;\r\n}\r\nstatic void stop_read_write_urbs(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nif (!portdata)\r\ncontinue;\r\nfor (j = 0; j < N_IN_URB; j++)\r\nusb_kill_urb(portdata->in_urbs[j]);\r\nfor (j = 0; j < N_OUT_URB; j++)\r\nusb_kill_urb(portdata->out_urbs[j]);\r\n}\r\n}\r\nint usb_wwan_suspend(struct usb_serial *serial, pm_message_t message)\r\n{\r\nstruct usb_wwan_intf_private *intfdata = serial->private;\r\nint b;\r\nif (PMSG_IS_AUTO(message)) {\r\nspin_lock_irq(&intfdata->susp_lock);\r\nb = intfdata->in_flight;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nif (b)\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irq(&intfdata->susp_lock);\r\nintfdata->suspended = 1;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nstop_read_write_urbs(serial);\r\nreturn 0;\r\n}\r\nstatic void unbusy_queued_urb(struct urb *urb, struct usb_wwan_port_private *portdata)\r\n{\r\nint i;\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nif (urb == portdata->out_urbs[i]) {\r\nclear_bit(i, &portdata->out_busy);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void play_delayed(struct usb_serial_port *port)\r\n{\r\nstruct usb_wwan_intf_private *data;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct urb *urb;\r\nint err;\r\nportdata = usb_get_serial_port_data(port);\r\ndata = port->serial->private;\r\nwhile ((urb = usb_get_from_anchor(&portdata->delayed))) {\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (!err) {\r\ndata->in_flight++;\r\n} else {\r\ndo {\r\nunbusy_queued_urb(urb, portdata);\r\nusb_autopm_put_interface_no_suspend(port->serial->interface);\r\n} while ((urb = usb_get_from_anchor(&portdata->delayed)));\r\nbreak;\r\n}\r\n}\r\n}\r\nint usb_wwan_resume(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_intf_private *intfdata = serial->private;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct urb *urb;\r\nint err = 0;\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!port->interrupt_in_urb) {\r\ndev_dbg(&port->dev, "%s: No interrupt URB for port\n", __func__);\r\ncontinue;\r\n}\r\nerr = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);\r\ndev_dbg(&port->dev, "Submitted interrupt URB for port (result %d)\n", err);\r\nif (err < 0) {\r\ndev_err(&port->dev, "%s: Error %d for interrupt URB\n",\r\n__func__, err);\r\ngoto err_out;\r\n}\r\n}\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nspin_lock_irq(&intfdata->susp_lock);\r\nif (!portdata || !portdata->opened) {\r\nspin_unlock_irq(&intfdata->susp_lock);\r\ncontinue;\r\n}\r\nfor (j = 0; j < N_IN_URB; j++) {\r\nurb = portdata->in_urbs[j];\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\ndev_err(&port->dev, "%s: Error %d for bulk URB %d\n",\r\n__func__, err, i);\r\nspin_unlock_irq(&intfdata->susp_lock);\r\ngoto err_out;\r\n}\r\n}\r\nplay_delayed(port);\r\nspin_unlock_irq(&intfdata->susp_lock);\r\n}\r\nspin_lock_irq(&intfdata->susp_lock);\r\nintfdata->suspended = 0;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nerr_out:\r\nreturn err;\r\n}
