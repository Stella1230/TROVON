static inline void usbtll_write(void __iomem *base, u32 reg, u32 val)\r\n{\r\n__raw_writel(val, base + reg);\r\n}\r\nstatic inline u32 usbtll_read(void __iomem *base, u32 reg)\r\n{\r\nreturn __raw_readl(base + reg);\r\n}\r\nstatic inline void usbtll_writeb(void __iomem *base, u8 reg, u8 val)\r\n{\r\n__raw_writeb(val, base + reg);\r\n}\r\nstatic inline u8 usbtll_readb(void __iomem *base, u8 reg)\r\n{\r\nreturn __raw_readb(base + reg);\r\n}\r\nstatic bool is_ohci_port(enum usbhs_omap_port_mode pmode)\r\n{\r\nswitch (pmode) {\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic unsigned ohci_omap3_fslsmode(enum usbhs_omap_port_mode mode)\r\n{\r\nswitch (mode) {\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0;\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_PHY_DP_DM;\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_3PIN_PHY;\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_4PIN_PHY;\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_TLL_DAT_SE0;\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_TLL_DP_DM;\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_3PIN_TLL;\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_4PIN_TLL;\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_2PIN_TLL_DAT_SE0;\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_2PIN_DAT_DP_DM;\r\ndefault:\r\npr_warn("Invalid port mode, using default\n");\r\nreturn OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0;\r\n}\r\n}\r\nstatic int usbtll_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct usbtll_omap *tll;\r\nint ret = 0;\r\nint i, ver;\r\ndev_dbg(dev, "starting TI HSUSB TLL Controller\n");\r\ntll = devm_kzalloc(dev, sizeof(struct usbtll_omap), GFP_KERNEL);\r\nif (!tll) {\r\ndev_err(dev, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntll->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(tll->base))\r\nreturn PTR_ERR(tll->base);\r\nplatform_set_drvdata(pdev, tll);\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nver = usbtll_read(tll->base, OMAP_USBTLL_REVISION);\r\nswitch (ver) {\r\ncase OMAP_USBTLL_REV1:\r\ncase OMAP_USBTLL_REV4:\r\ntll->nch = OMAP_TLL_CHANNEL_COUNT;\r\nbreak;\r\ncase OMAP_USBTLL_REV2:\r\ncase OMAP_USBTLL_REV3:\r\ntll->nch = OMAP_REV2_TLL_CHANNEL_COUNT;\r\nbreak;\r\ndefault:\r\ntll->nch = OMAP_TLL_CHANNEL_COUNT;\r\ndev_dbg(dev,\r\n"USB TLL Rev : 0x%x not recognized, assuming %d channels\n",\r\nver, tll->nch);\r\nbreak;\r\n}\r\ntll->ch_clk = devm_kzalloc(dev, sizeof(struct clk * [tll->nch]),\r\nGFP_KERNEL);\r\nif (!tll->ch_clk) {\r\nret = -ENOMEM;\r\ndev_err(dev, "Couldn't allocate memory for channel clocks\n");\r\ngoto err_clk_alloc;\r\n}\r\nfor (i = 0; i < tll->nch; i++) {\r\nchar clkname[] = "usb_tll_hs_usb_chx_clk";\r\nsnprintf(clkname, sizeof(clkname),\r\n"usb_tll_hs_usb_ch%d_clk", i);\r\ntll->ch_clk[i] = clk_get(dev, clkname);\r\nif (IS_ERR(tll->ch_clk[i]))\r\ndev_dbg(dev, "can't get clock : %s\n", clkname);\r\n}\r\npm_runtime_put_sync(dev);\r\nspin_lock(&tll_lock);\r\ntll_dev = dev;\r\nspin_unlock(&tll_lock);\r\nreturn 0;\r\nerr_clk_alloc:\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int usbtll_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct usbtll_omap *tll = platform_get_drvdata(pdev);\r\nint i;\r\nspin_lock(&tll_lock);\r\ntll_dev = NULL;\r\nspin_unlock(&tll_lock);\r\nfor (i = 0; i < tll->nch; i++)\r\nif (!IS_ERR(tll->ch_clk[i]))\r\nclk_put(tll->ch_clk[i]);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nint omap_tll_init(struct usbhs_omap_platform_data *pdata)\r\n{\r\nint i;\r\nbool needs_tll;\r\nunsigned reg;\r\nstruct usbtll_omap *tll;\r\nspin_lock(&tll_lock);\r\nif (!tll_dev) {\r\nspin_unlock(&tll_lock);\r\nreturn -ENODEV;\r\n}\r\ntll = dev_get_drvdata(tll_dev);\r\nneeds_tll = false;\r\nfor (i = 0; i < tll->nch; i++)\r\nneeds_tll |= omap_usb_mode_needs_tll(pdata->port_mode[i]);\r\npm_runtime_get_sync(tll_dev);\r\nif (needs_tll) {\r\nvoid __iomem *base = tll->base;\r\nreg = usbtll_read(base, OMAP_TLL_SHARED_CONF);\r\nreg |= (OMAP_TLL_SHARED_CONF_FCLK_IS_ON\r\n| OMAP_TLL_SHARED_CONF_USB_DIVRATION);\r\nreg &= ~OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN;\r\nreg &= ~OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN;\r\nusbtll_write(base, OMAP_TLL_SHARED_CONF, reg);\r\nfor (i = 0; i < tll->nch; i++) {\r\nreg = usbtll_read(base, OMAP_TLL_CHANNEL_CONF(i));\r\nif (is_ohci_port(pdata->port_mode[i])) {\r\nreg |= ohci_omap3_fslsmode(pdata->port_mode[i])\r\n<< OMAP_TLL_CHANNEL_CONF_FSLSMODE_SHIFT;\r\nreg |= OMAP_TLL_CHANNEL_CONF_CHANMODE_FSLS;\r\n} else if (pdata->port_mode[i] ==\r\nOMAP_EHCI_PORT_MODE_TLL) {\r\nreg &= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE\r\n| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF\r\n| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);\r\n} else if (pdata->port_mode[i] ==\r\nOMAP_EHCI_PORT_MODE_HSIC) {\r\nreg |= OMAP_TLL_CHANNEL_CONF_DRVVBUS\r\n| OMAP_TLL_CHANNEL_CONF_CHRGVBUS\r\n| OMAP_TLL_CHANNEL_CONF_MODE_TRANSPARENT_UTMI\r\n| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;\r\n} else {\r\ncontinue;\r\n}\r\nreg |= OMAP_TLL_CHANNEL_CONF_CHANEN;\r\nusbtll_write(base, OMAP_TLL_CHANNEL_CONF(i), reg);\r\nusbtll_writeb(base,\r\nOMAP_TLL_ULPI_SCRATCH_REGISTER(i),\r\n0xbe);\r\n}\r\n}\r\npm_runtime_put_sync(tll_dev);\r\nspin_unlock(&tll_lock);\r\nreturn 0;\r\n}\r\nint omap_tll_enable(struct usbhs_omap_platform_data *pdata)\r\n{\r\nint i;\r\nstruct usbtll_omap *tll;\r\nspin_lock(&tll_lock);\r\nif (!tll_dev) {\r\nspin_unlock(&tll_lock);\r\nreturn -ENODEV;\r\n}\r\ntll = dev_get_drvdata(tll_dev);\r\npm_runtime_get_sync(tll_dev);\r\nfor (i = 0; i < tll->nch; i++) {\r\nif (omap_usb_mode_needs_tll(pdata->port_mode[i])) {\r\nint r;\r\nif (IS_ERR(tll->ch_clk[i]))\r\ncontinue;\r\nr = clk_enable(tll->ch_clk[i]);\r\nif (r) {\r\ndev_err(tll_dev,\r\n"Error enabling ch %d clock: %d\n", i, r);\r\n}\r\n}\r\n}\r\nspin_unlock(&tll_lock);\r\nreturn 0;\r\n}\r\nint omap_tll_disable(struct usbhs_omap_platform_data *pdata)\r\n{\r\nint i;\r\nstruct usbtll_omap *tll;\r\nspin_lock(&tll_lock);\r\nif (!tll_dev) {\r\nspin_unlock(&tll_lock);\r\nreturn -ENODEV;\r\n}\r\ntll = dev_get_drvdata(tll_dev);\r\nfor (i = 0; i < tll->nch; i++) {\r\nif (omap_usb_mode_needs_tll(pdata->port_mode[i])) {\r\nif (!IS_ERR(tll->ch_clk[i]))\r\nclk_disable(tll->ch_clk[i]);\r\n}\r\n}\r\npm_runtime_put_sync(tll_dev);\r\nspin_unlock(&tll_lock);\r\nreturn 0;\r\n}\r\nstatic int __init omap_usbtll_drvinit(void)\r\n{\r\nreturn platform_driver_register(&usbtll_omap_driver);\r\n}\r\nstatic void __exit omap_usbtll_drvexit(void)\r\n{\r\nplatform_driver_unregister(&usbtll_omap_driver);\r\n}
