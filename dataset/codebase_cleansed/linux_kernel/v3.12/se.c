static void se200pci_WM8740_init(struct snd_ice1712 *ice)\r\n{\r\n}\r\nstatic void se200pci_WM8740_set_pro_rate(struct snd_ice1712 *ice,\r\nunsigned int rate)\r\n{\r\n}\r\nstatic void se200pci_WM8766_write(struct snd_ice1712 *ice,\r\nunsigned int addr, unsigned int data)\r\n{\r\nunsigned int st;\r\nunsigned int bits;\r\nint i;\r\nconst unsigned int DATA = 0x010000;\r\nconst unsigned int CLOCK = 0x020000;\r\nconst unsigned int LOAD = 0x040000;\r\nconst unsigned int ALL_MASK = (DATA | CLOCK | LOAD);\r\nsnd_ice1712_save_gpio_status(ice);\r\nst = ((addr & 0x7f) << 9) | (data & 0x1ff);\r\nsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction | ALL_MASK);\r\nsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask & ~ALL_MASK);\r\nbits = snd_ice1712_gpio_read(ice) & ~ALL_MASK;\r\nsnd_ice1712_gpio_write(ice, bits);\r\nfor (i = 0; i < 16; i++) {\r\nudelay(1);\r\nbits &= ~CLOCK;\r\nst = (st << 1);\r\nif (st & 0x10000)\r\nbits |= DATA;\r\nelse\r\nbits &= ~DATA;\r\nsnd_ice1712_gpio_write(ice, bits);\r\nudelay(1);\r\nbits |= CLOCK;\r\nsnd_ice1712_gpio_write(ice, bits);\r\n}\r\nudelay(1);\r\nbits |= LOAD;\r\nsnd_ice1712_gpio_write(ice, bits);\r\nudelay(1);\r\nbits |= (DATA | CLOCK);\r\nsnd_ice1712_gpio_write(ice, bits);\r\nsnd_ice1712_restore_gpio_status(ice);\r\n}\r\nstatic void se200pci_WM8766_set_volume(struct snd_ice1712 *ice, int ch,\r\nunsigned int vol1, unsigned int vol2)\r\n{\r\nswitch (ch) {\r\ncase 0:\r\nse200pci_WM8766_write(ice, 0x000, vol1);\r\nse200pci_WM8766_write(ice, 0x001, vol2 | 0x100);\r\nbreak;\r\ncase 1:\r\nse200pci_WM8766_write(ice, 0x004, vol1);\r\nse200pci_WM8766_write(ice, 0x005, vol2 | 0x100);\r\nbreak;\r\ncase 2:\r\nse200pci_WM8766_write(ice, 0x006, vol1);\r\nse200pci_WM8766_write(ice, 0x007, vol2 | 0x100);\r\nbreak;\r\n}\r\n}\r\nstatic void se200pci_WM8766_init(struct snd_ice1712 *ice)\r\n{\r\nse200pci_WM8766_write(ice, 0x1f, 0x000);\r\nudelay(10);\r\nse200pci_WM8766_set_volume(ice, 0, 0, 0);\r\nse200pci_WM8766_set_volume(ice, 1, 0, 0);\r\nse200pci_WM8766_set_volume(ice, 2, 0, 0);\r\nse200pci_WM8766_write(ice, 0x03, 0x022);\r\nse200pci_WM8766_write(ice, 0x0a, 0x080);\r\nse200pci_WM8766_write(ice, 0x12, 0x000);\r\nse200pci_WM8766_write(ice, 0x15, 0x000);\r\nse200pci_WM8766_write(ice, 0x09, 0x000);\r\nse200pci_WM8766_write(ice, 0x02, 0x124);\r\nse200pci_WM8766_write(ice, 0x02, 0x120);\r\n}\r\nstatic void se200pci_WM8766_set_pro_rate(struct snd_ice1712 *ice,\r\nunsigned int rate)\r\n{\r\nif (rate > 96000)\r\nse200pci_WM8766_write(ice, 0x0a, 0x000);\r\nelse\r\nse200pci_WM8766_write(ice, 0x0a, 0x080);\r\n}\r\nstatic void se200pci_WM8776_write(struct snd_ice1712 *ice,\r\nunsigned int addr, unsigned int data)\r\n{\r\nunsigned int val;\r\nval = (addr << 9) | data;\r\nsnd_vt1724_write_i2c(ice, 0x34, val >> 8, val & 0xff);\r\n}\r\nstatic void se200pci_WM8776_set_output_volume(struct snd_ice1712 *ice,\r\nunsigned int vol1, unsigned int vol2)\r\n{\r\nse200pci_WM8776_write(ice, 0x03, vol1);\r\nse200pci_WM8776_write(ice, 0x04, vol2 | 0x100);\r\n}\r\nstatic void se200pci_WM8776_set_input_volume(struct snd_ice1712 *ice,\r\nunsigned int vol1, unsigned int vol2)\r\n{\r\nse200pci_WM8776_write(ice, 0x0e, vol1);\r\nse200pci_WM8776_write(ice, 0x0f, vol2 | 0x100);\r\n}\r\nstatic void se200pci_WM8776_set_input_selector(struct snd_ice1712 *ice,\r\nunsigned int sel)\r\n{\r\nstatic unsigned char vals[] = {\r\n0x10, 0x04, 0x08, 0x1c, 0x03\r\n};\r\nif (sel > 4)\r\nsel = 4;\r\nse200pci_WM8776_write(ice, 0x15, vals[sel]);\r\n}\r\nstatic void se200pci_WM8776_set_afl(struct snd_ice1712 *ice, unsigned int afl)\r\n{\r\nif (afl)\r\nse200pci_WM8776_write(ice, 0x16, 0x005);\r\nelse\r\nse200pci_WM8776_write(ice, 0x16, 0x001);\r\n}\r\nstatic void se200pci_WM8776_set_agc(struct snd_ice1712 *ice, unsigned int agc)\r\n{\r\nswitch (agc) {\r\ncase 0:\r\nse200pci_WM8776_write(ice, 0x11, 0x000);\r\nbreak;\r\ncase 1:\r\nse200pci_WM8776_write(ice, 0x10, 0x07b);\r\nse200pci_WM8776_write(ice, 0x11, 0x100);\r\nbreak;\r\ncase 2:\r\nse200pci_WM8776_write(ice, 0x10, 0x1fb);\r\nse200pci_WM8776_write(ice, 0x11, 0x100);\r\nbreak;\r\n}\r\n}\r\nstatic void se200pci_WM8776_init(struct snd_ice1712 *ice)\r\n{\r\nint i;\r\nstatic unsigned short default_values[] = {\r\n0x100, 0x100, 0x100,\r\n0x100, 0x100, 0x100,\r\n0x000, 0x090, 0x000, 0x000,\r\n0x022, 0x022, 0x022,\r\n0x008, 0x0cf, 0x0cf, 0x07b, 0x000,\r\n0x032, 0x000, 0x0a6, 0x001, 0x001\r\n};\r\nse200pci_WM8776_write(ice, 0x17, 0x000);\r\nudelay(10);\r\nfor (i = 0; i < ARRAY_SIZE(default_values); i++)\r\nse200pci_WM8776_write(ice, i, default_values[i]);\r\nse200pci_WM8776_set_input_selector(ice, 0);\r\nse200pci_WM8776_set_afl(ice, 0);\r\nse200pci_WM8776_set_agc(ice, 0);\r\nse200pci_WM8776_set_input_volume(ice, 0, 0);\r\nse200pci_WM8776_set_output_volume(ice, 0, 0);\r\nse200pci_WM8776_write(ice, 0x00, 0);\r\nse200pci_WM8776_write(ice, 0x01, 0);\r\nse200pci_WM8776_write(ice, 0x02, 0x100);\r\nse200pci_WM8776_write(ice, 0x0d, 0x080);\r\n}\r\nstatic void se200pci_WM8776_set_pro_rate(struct snd_ice1712 *ice,\r\nunsigned int rate)\r\n{\r\n}\r\nstatic void se200pci_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate)\r\n{\r\nse200pci_WM8740_set_pro_rate(ice, rate);\r\nse200pci_WM8766_set_pro_rate(ice, rate);\r\nse200pci_WM8776_set_pro_rate(ice, rate);\r\n}\r\nstatic int se200pci_get_enum_count(int n)\r\n{\r\nconst char * const *member;\r\nint c;\r\nmember = se200pci_cont[n].member;\r\nif (!member)\r\nreturn 0;\r\nfor (c = 0; member[c]; c++)\r\n;\r\nreturn c;\r\n}\r\nstatic int se200pci_cont_volume_info(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xff;\r\nreturn 0;\r\n}\r\nstatic int se200pci_cont_enum_info(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint n, c;\r\nn = kc->private_value;\r\nc = se200pci_get_enum_count(n);\r\nif (!c)\r\nreturn -EINVAL;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = c;\r\nif (uinfo->value.enumerated.item >= c)\r\nuinfo->value.enumerated.item = c - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nse200pci_cont[n].member[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int se200pci_cont_volume_get(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *uc)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\r\nstruct se_spec *spec = ice->spec;\r\nint n = kc->private_value;\r\nuc->value.integer.value[0] = spec->vol[n].ch1;\r\nuc->value.integer.value[1] = spec->vol[n].ch2;\r\nreturn 0;\r\n}\r\nstatic int se200pci_cont_boolean_get(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *uc)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\r\nstruct se_spec *spec = ice->spec;\r\nint n = kc->private_value;\r\nuc->value.integer.value[0] = spec->vol[n].ch1;\r\nreturn 0;\r\n}\r\nstatic int se200pci_cont_enum_get(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *uc)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\r\nstruct se_spec *spec = ice->spec;\r\nint n = kc->private_value;\r\nuc->value.enumerated.item[0] = spec->vol[n].ch1;\r\nreturn 0;\r\n}\r\nstatic void se200pci_cont_update(struct snd_ice1712 *ice, int n)\r\n{\r\nstruct se_spec *spec = ice->spec;\r\nswitch (se200pci_cont[n].target) {\r\ncase WM8766:\r\nse200pci_WM8766_set_volume(ice,\r\nse200pci_cont[n].ch,\r\nspec->vol[n].ch1,\r\nspec->vol[n].ch2);\r\nbreak;\r\ncase WM8776in:\r\nse200pci_WM8776_set_input_volume(ice,\r\nspec->vol[n].ch1,\r\nspec->vol[n].ch2);\r\nbreak;\r\ncase WM8776out:\r\nse200pci_WM8776_set_output_volume(ice,\r\nspec->vol[n].ch1,\r\nspec->vol[n].ch2);\r\nbreak;\r\ncase WM8776sel:\r\nse200pci_WM8776_set_input_selector(ice,\r\nspec->vol[n].ch1);\r\nbreak;\r\ncase WM8776agc:\r\nse200pci_WM8776_set_agc(ice, spec->vol[n].ch1);\r\nbreak;\r\ncase WM8776afl:\r\nse200pci_WM8776_set_afl(ice, spec->vol[n].ch1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int se200pci_cont_volume_put(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *uc)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\r\nstruct se_spec *spec = ice->spec;\r\nint n = kc->private_value;\r\nunsigned int vol1, vol2;\r\nint changed;\r\nchanged = 0;\r\nvol1 = uc->value.integer.value[0] & 0xff;\r\nvol2 = uc->value.integer.value[1] & 0xff;\r\nif (spec->vol[n].ch1 != vol1) {\r\nspec->vol[n].ch1 = vol1;\r\nchanged = 1;\r\n}\r\nif (spec->vol[n].ch2 != vol2) {\r\nspec->vol[n].ch2 = vol2;\r\nchanged = 1;\r\n}\r\nif (changed)\r\nse200pci_cont_update(ice, n);\r\nreturn changed;\r\n}\r\nstatic int se200pci_cont_boolean_put(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *uc)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\r\nstruct se_spec *spec = ice->spec;\r\nint n = kc->private_value;\r\nunsigned int vol1;\r\nvol1 = !!uc->value.integer.value[0];\r\nif (spec->vol[n].ch1 != vol1) {\r\nspec->vol[n].ch1 = vol1;\r\nse200pci_cont_update(ice, n);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int se200pci_cont_enum_put(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *uc)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kc);\r\nstruct se_spec *spec = ice->spec;\r\nint n = kc->private_value;\r\nunsigned int vol1;\r\nvol1 = uc->value.enumerated.item[0];\r\nif (vol1 >= se200pci_get_enum_count(n))\r\nreturn -EINVAL;\r\nif (spec->vol[n].ch1 != vol1) {\r\nspec->vol[n].ch1 = vol1;\r\nse200pci_cont_update(ice, n);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int se200pci_add_controls(struct snd_ice1712 *ice)\r\n{\r\nint i;\r\nstruct snd_kcontrol_new cont;\r\nint err;\r\nmemset(&cont, 0, sizeof(cont));\r\ncont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nfor (i = 0; i < ARRAY_SIZE(se200pci_cont); i++) {\r\ncont.private_value = i;\r\ncont.name = se200pci_cont[i].name;\r\ncont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\ncont.tlv.p = NULL;\r\nswitch (se200pci_cont[i].type) {\r\ncase VOLUME1:\r\ncase VOLUME2:\r\ncont.info = se200pci_cont_volume_info;\r\ncont.get = se200pci_cont_volume_get;\r\ncont.put = se200pci_cont_volume_put;\r\ncont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nif (se200pci_cont[i].type == VOLUME1)\r\ncont.tlv.p = db_scale_gain1;\r\nelse\r\ncont.tlv.p = db_scale_gain2;\r\nbreak;\r\ncase BOOLEAN:\r\ncont.info = se200pci_cont_boolean_info;\r\ncont.get = se200pci_cont_boolean_get;\r\ncont.put = se200pci_cont_boolean_put;\r\nbreak;\r\ncase ENUM:\r\ncont.info = se200pci_cont_enum_info;\r\ncont.get = se200pci_cont_enum_get;\r\ncont.put = se200pci_cont_enum_put;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&cont, ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int se_init(struct snd_ice1712 *ice)\r\n{\r\nstruct se_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE90PCI) {\r\nice->num_total_dacs = 2;\r\nice->num_total_adcs = 0;\r\nice->vt1720 = 1;\r\nreturn 0;\r\n} else if (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE200PCI) {\r\nice->num_total_dacs = 8;\r\nice->num_total_adcs = 2;\r\nse200pci_WM8740_init(ice);\r\nse200pci_WM8766_init(ice);\r\nse200pci_WM8776_init(ice);\r\nice->gpio.set_pro_rate = se200pci_set_pro_rate;\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int se_add_controls(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nerr = 0;\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE200PCI)\r\nerr = se200pci_add_controls(ice);\r\nreturn err;\r\n}
