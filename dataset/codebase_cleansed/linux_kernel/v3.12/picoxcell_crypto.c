static inline struct spacc_alg *to_spacc_alg(struct crypto_alg *alg)\r\n{\r\nreturn alg ? container_of(alg, struct spacc_alg, alg) : NULL;\r\n}\r\nstatic inline int spacc_fifo_cmd_full(struct spacc_engine *engine)\r\n{\r\nu32 fifo_stat = readl(engine->regs + SPA_FIFO_STAT_REG_OFFSET);\r\nreturn fifo_stat & SPA_FIFO_CMD_FULL;\r\n}\r\nstatic inline void __iomem *spacc_ctx_page_addr(struct spacc_generic_ctx *ctx,\r\nunsigned indx,\r\nbool is_cipher_ctx)\r\n{\r\nreturn is_cipher_ctx ? ctx->engine->cipher_ctx_base +\r\n(indx * ctx->engine->cipher_pg_sz) :\r\nctx->engine->hash_key_base + (indx * ctx->engine->hash_pg_sz);\r\n}\r\nstatic inline void memcpy_toio32(u32 __iomem *dst, const void *src,\r\nunsigned count)\r\n{\r\nconst u32 *src32 = (const u32 *) src;\r\nwhile (count--)\r\nwritel(*src32++, dst++);\r\n}\r\nstatic void spacc_cipher_write_ctx(struct spacc_generic_ctx *ctx,\r\nvoid __iomem *page_addr, const u8 *key,\r\nsize_t key_len, const u8 *iv, size_t iv_len)\r\n{\r\nvoid __iomem *key_ptr = page_addr + ctx->key_offs;\r\nvoid __iomem *iv_ptr = page_addr + ctx->iv_offs;\r\nmemcpy_toio32(key_ptr, key, key_len / 4);\r\nmemcpy_toio32(iv_ptr, iv, iv_len / 4);\r\n}\r\nstatic unsigned spacc_load_ctx(struct spacc_generic_ctx *ctx,\r\nconst u8 *ciph_key, size_t ciph_len,\r\nconst u8 *iv, size_t ivlen, const u8 *hash_key,\r\nsize_t hash_len)\r\n{\r\nunsigned indx = ctx->engine->next_ctx++;\r\nvoid __iomem *ciph_page_addr, *hash_page_addr;\r\nciph_page_addr = spacc_ctx_page_addr(ctx, indx, 1);\r\nhash_page_addr = spacc_ctx_page_addr(ctx, indx, 0);\r\nctx->engine->next_ctx &= ctx->engine->fifo_sz - 1;\r\nspacc_cipher_write_ctx(ctx, ciph_page_addr, ciph_key, ciph_len, iv,\r\nivlen);\r\nwritel(ciph_len | (indx << SPA_KEY_SZ_CTX_INDEX_OFFSET) |\r\n(1 << SPA_KEY_SZ_CIPHER_OFFSET),\r\nctx->engine->regs + SPA_KEY_SZ_REG_OFFSET);\r\nif (hash_key) {\r\nmemcpy_toio32(hash_page_addr, hash_key, hash_len / 4);\r\nwritel(hash_len | (indx << SPA_KEY_SZ_CTX_INDEX_OFFSET),\r\nctx->engine->regs + SPA_KEY_SZ_REG_OFFSET);\r\n}\r\nreturn indx;\r\n}\r\nstatic int sg_count(struct scatterlist *sg_list, int nbytes)\r\n{\r\nstruct scatterlist *sg = sg_list;\r\nint sg_nents = 0;\r\nwhile (nbytes > 0) {\r\n++sg_nents;\r\nnbytes -= sg->length;\r\nsg = sg_next(sg);\r\n}\r\nreturn sg_nents;\r\n}\r\nstatic inline void ddt_set(struct spacc_ddt *ddt, dma_addr_t phys, size_t len)\r\n{\r\nddt->p = phys;\r\nddt->len = len;\r\n}\r\nstatic struct spacc_ddt *spacc_sg_to_ddt(struct spacc_engine *engine,\r\nstruct scatterlist *payload,\r\nunsigned nbytes,\r\nenum dma_data_direction dir,\r\ndma_addr_t *ddt_phys)\r\n{\r\nunsigned nents, mapped_ents;\r\nstruct scatterlist *cur;\r\nstruct spacc_ddt *ddt;\r\nint i;\r\nnents = sg_count(payload, nbytes);\r\nmapped_ents = dma_map_sg(engine->dev, payload, nents, dir);\r\nif (mapped_ents + 1 > MAX_DDT_LEN)\r\ngoto out;\r\nddt = dma_pool_alloc(engine->req_pool, GFP_ATOMIC, ddt_phys);\r\nif (!ddt)\r\ngoto out;\r\nfor_each_sg(payload, cur, mapped_ents, i)\r\nddt_set(&ddt[i], sg_dma_address(cur), sg_dma_len(cur));\r\nddt_set(&ddt[mapped_ents], 0, 0);\r\nreturn ddt;\r\nout:\r\ndma_unmap_sg(engine->dev, payload, nents, dir);\r\nreturn NULL;\r\n}\r\nstatic int spacc_aead_make_ddts(struct spacc_req *req, u8 *giv)\r\n{\r\nstruct aead_request *areq = container_of(req->req, struct aead_request,\r\nbase);\r\nstruct spacc_engine *engine = req->engine;\r\nstruct spacc_ddt *src_ddt, *dst_ddt;\r\nunsigned ivsize = crypto_aead_ivsize(crypto_aead_reqtfm(areq));\r\nunsigned nents = sg_count(areq->src, areq->cryptlen);\r\ndma_addr_t iv_addr;\r\nstruct scatterlist *cur;\r\nint i, dst_ents, src_ents, assoc_ents;\r\nu8 *iv = giv ? giv : areq->iv;\r\nsrc_ddt = dma_pool_alloc(engine->req_pool, GFP_ATOMIC, &req->src_addr);\r\nif (!src_ddt)\r\nreturn -ENOMEM;\r\ndst_ddt = dma_pool_alloc(engine->req_pool, GFP_ATOMIC, &req->dst_addr);\r\nif (!dst_ddt) {\r\ndma_pool_free(engine->req_pool, src_ddt, req->src_addr);\r\nreturn -ENOMEM;\r\n}\r\nreq->src_ddt = src_ddt;\r\nreq->dst_ddt = dst_ddt;\r\nassoc_ents = dma_map_sg(engine->dev, areq->assoc,\r\nsg_count(areq->assoc, areq->assoclen), DMA_TO_DEVICE);\r\nif (areq->src != areq->dst) {\r\nsrc_ents = dma_map_sg(engine->dev, areq->src, nents,\r\nDMA_TO_DEVICE);\r\ndst_ents = dma_map_sg(engine->dev, areq->dst, nents,\r\nDMA_FROM_DEVICE);\r\n} else {\r\nsrc_ents = dma_map_sg(engine->dev, areq->src, nents,\r\nDMA_BIDIRECTIONAL);\r\ndst_ents = 0;\r\n}\r\niv_addr = dma_map_single(engine->dev, iv, ivsize,\r\ngiv ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\r\nreq->giv_pa = iv_addr;\r\nfor_each_sg(areq->assoc, cur, assoc_ents, i) {\r\nddt_set(src_ddt++, sg_dma_address(cur), sg_dma_len(cur));\r\nif (req->is_encrypt)\r\nddt_set(dst_ddt++, sg_dma_address(cur),\r\nsg_dma_len(cur));\r\n}\r\nddt_set(src_ddt++, iv_addr, ivsize);\r\nif (giv || req->is_encrypt)\r\nddt_set(dst_ddt++, iv_addr, ivsize);\r\nfor_each_sg(areq->src, cur, src_ents, i) {\r\nddt_set(src_ddt++, sg_dma_address(cur), sg_dma_len(cur));\r\nif (areq->src == areq->dst)\r\nddt_set(dst_ddt++, sg_dma_address(cur),\r\nsg_dma_len(cur));\r\n}\r\nfor_each_sg(areq->dst, cur, dst_ents, i)\r\nddt_set(dst_ddt++, sg_dma_address(cur),\r\nsg_dma_len(cur));\r\nddt_set(src_ddt, 0, 0);\r\nddt_set(dst_ddt, 0, 0);\r\nreturn 0;\r\n}\r\nstatic void spacc_aead_free_ddts(struct spacc_req *req)\r\n{\r\nstruct aead_request *areq = container_of(req->req, struct aead_request,\r\nbase);\r\nstruct spacc_alg *alg = to_spacc_alg(req->req->tfm->__crt_alg);\r\nstruct spacc_ablk_ctx *aead_ctx = crypto_tfm_ctx(req->req->tfm);\r\nstruct spacc_engine *engine = aead_ctx->generic.engine;\r\nunsigned ivsize = alg->alg.cra_aead.ivsize;\r\nunsigned nents = sg_count(areq->src, areq->cryptlen);\r\nif (areq->src != areq->dst) {\r\ndma_unmap_sg(engine->dev, areq->src, nents, DMA_TO_DEVICE);\r\ndma_unmap_sg(engine->dev, areq->dst,\r\nsg_count(areq->dst, areq->cryptlen),\r\nDMA_FROM_DEVICE);\r\n} else\r\ndma_unmap_sg(engine->dev, areq->src, nents, DMA_BIDIRECTIONAL);\r\ndma_unmap_sg(engine->dev, areq->assoc,\r\nsg_count(areq->assoc, areq->assoclen), DMA_TO_DEVICE);\r\ndma_unmap_single(engine->dev, req->giv_pa, ivsize, DMA_BIDIRECTIONAL);\r\ndma_pool_free(engine->req_pool, req->src_ddt, req->src_addr);\r\ndma_pool_free(engine->req_pool, req->dst_ddt, req->dst_addr);\r\n}\r\nstatic void spacc_free_ddt(struct spacc_req *req, struct spacc_ddt *ddt,\r\ndma_addr_t ddt_addr, struct scatterlist *payload,\r\nunsigned nbytes, enum dma_data_direction dir)\r\n{\r\nunsigned nents = sg_count(payload, nbytes);\r\ndma_unmap_sg(req->engine->dev, payload, nents, dir);\r\ndma_pool_free(req->engine->req_pool, ddt, ddt_addr);\r\n}\r\nstatic int spacc_aead_des_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nif (unlikely(!des_ekey(tmp, key)) &&\r\n(crypto_aead_get_flags(aead)) & CRYPTO_TFM_REQ_WEAK_KEY) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->cipher_key, key, len);\r\nctx->cipher_key_len = len;\r\nreturn 0;\r\n}\r\nstatic int spacc_aead_aes_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (len != AES_KEYSIZE_128 && len != AES_KEYSIZE_256) {\r\nctx->sw_cipher->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;\r\nctx->sw_cipher->base.crt_flags |=\r\ntfm->crt_flags & CRYPTO_TFM_REQ_MASK;\r\nreturn crypto_aead_setkey(ctx->sw_cipher, key, len);\r\n}\r\nmemcpy(ctx->cipher_key, key, len);\r\nctx->cipher_key_len = len;\r\nreturn 0;\r\n}\r\nstatic int spacc_aead_setkey(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->base.__crt_alg);\r\nstruct rtattr *rta = (void *)key;\r\nstruct crypto_authenc_key_param *param;\r\nunsigned int authkeylen, enckeylen;\r\nint err = -EINVAL;\r\nif (!RTA_OK(rta, keylen))\r\ngoto badkey;\r\nif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\r\ngoto badkey;\r\nif (RTA_PAYLOAD(rta) < sizeof(*param))\r\ngoto badkey;\r\nparam = RTA_DATA(rta);\r\nenckeylen = be32_to_cpu(param->enckeylen);\r\nkey += RTA_ALIGN(rta->rta_len);\r\nkeylen -= RTA_ALIGN(rta->rta_len);\r\nif (keylen < enckeylen)\r\ngoto badkey;\r\nauthkeylen = keylen - enckeylen;\r\nif (enckeylen > AES_MAX_KEY_SIZE)\r\ngoto badkey;\r\nif ((alg->ctrl_default & SPACC_CRYPTO_ALG_MASK) ==\r\nSPA_CTRL_CIPH_ALG_AES)\r\nerr = spacc_aead_aes_setkey(tfm, key + authkeylen, enckeylen);\r\nelse\r\nerr = spacc_aead_des_setkey(tfm, key + authkeylen, enckeylen);\r\nif (err)\r\ngoto badkey;\r\nmemcpy(ctx->hash_ctx, key, authkeylen);\r\nctx->hash_key_len = authkeylen;\r\nreturn 0;\r\nbadkey:\r\ncrypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nstatic int spacc_aead_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(crypto_aead_tfm(tfm));\r\nctx->auth_size = authsize;\r\nreturn 0;\r\n}\r\nstatic int spacc_aead_need_fallback(struct spacc_req *req)\r\n{\r\nstruct aead_request *aead_req;\r\nstruct crypto_tfm *tfm = req->req->tfm;\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\naead_req = container_of(req->req, struct aead_request, base);\r\nif ((spacc_alg->ctrl_default & SPACC_CRYPTO_ALG_MASK) ==\r\nSPA_CTRL_CIPH_ALG_AES &&\r\nctx->cipher_key_len != AES_KEYSIZE_128 &&\r\nctx->cipher_key_len != AES_KEYSIZE_256)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int spacc_aead_do_fallback(struct aead_request *req, unsigned alg_type,\r\nbool is_encrypt)\r\n{\r\nstruct crypto_tfm *old_tfm = crypto_aead_tfm(crypto_aead_reqtfm(req));\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(old_tfm);\r\nint err;\r\nif (ctx->sw_cipher) {\r\naead_request_set_tfm(req, ctx->sw_cipher);\r\nerr = is_encrypt ? crypto_aead_encrypt(req) :\r\ncrypto_aead_decrypt(req);\r\naead_request_set_tfm(req, __crypto_aead_cast(old_tfm));\r\n} else\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nstatic void spacc_aead_complete(struct spacc_req *req)\r\n{\r\nspacc_aead_free_ddts(req);\r\nreq->req->complete(req->req, req->result);\r\n}\r\nstatic int spacc_aead_submit(struct spacc_req *req)\r\n{\r\nstruct crypto_tfm *tfm = req->req->tfm;\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_engine *engine = ctx->generic.engine;\r\nu32 ctrl, proc_len, assoc_len;\r\nstruct aead_request *aead_req =\r\ncontainer_of(req->req, struct aead_request, base);\r\nreq->result = -EINPROGRESS;\r\nreq->ctx_id = spacc_load_ctx(&ctx->generic, ctx->cipher_key,\r\nctx->cipher_key_len, aead_req->iv, alg->cra_aead.ivsize,\r\nctx->hash_ctx, ctx->hash_key_len);\r\nwritel(req->src_addr, engine->regs + SPA_SRC_PTR_REG_OFFSET);\r\nwritel(req->dst_addr, engine->regs + SPA_DST_PTR_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_OFFSET_REG_OFFSET);\r\nassoc_len = aead_req->assoclen;\r\nproc_len = aead_req->cryptlen + assoc_len;\r\nif (!req->giv) {\r\nassoc_len += crypto_aead_ivsize(crypto_aead_reqtfm(aead_req));\r\nproc_len += crypto_aead_ivsize(crypto_aead_reqtfm(aead_req));\r\n} else\r\nproc_len += req->giv_len;\r\nif (!req->is_encrypt)\r\nproc_len -= ctx->auth_size;\r\nwritel(proc_len, engine->regs + SPA_PROC_LEN_REG_OFFSET);\r\nwritel(assoc_len, engine->regs + SPA_AAD_LEN_REG_OFFSET);\r\nwritel(ctx->auth_size, engine->regs + SPA_ICV_LEN_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_ICV_OFFSET_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_AUX_INFO_REG_OFFSET);\r\nctrl = spacc_alg->ctrl_default | (req->ctx_id << SPA_CTRL_CTX_IDX) |\r\n(1 << SPA_CTRL_ICV_APPEND);\r\nif (req->is_encrypt)\r\nctrl |= (1 << SPA_CTRL_ENCRYPT_IDX) | (1 << SPA_CTRL_AAD_COPY);\r\nelse\r\nctrl |= (1 << SPA_CTRL_KEY_EXP);\r\nmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\r\nwritel(ctrl, engine->regs + SPA_CTRL_REG_OFFSET);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic void spacc_push(struct spacc_engine *engine)\r\n{\r\nstruct spacc_req *req;\r\nwhile (!list_empty(&engine->pending) &&\r\nengine->in_flight + 1 <= engine->fifo_sz) {\r\n++engine->in_flight;\r\nreq = list_first_entry(&engine->pending, struct spacc_req,\r\nlist);\r\nlist_move_tail(&req->list, &engine->in_progress);\r\nreq->result = spacc_req_submit(req);\r\n}\r\n}\r\nstatic int spacc_aead_setup(struct aead_request *req, u8 *giv,\r\nunsigned alg_type, bool is_encrypt)\r\n{\r\nstruct crypto_alg *alg = req->base.tfm->__crt_alg;\r\nstruct spacc_engine *engine = to_spacc_alg(alg)->engine;\r\nstruct spacc_req *dev_req = aead_request_ctx(req);\r\nint err = -EINPROGRESS;\r\nunsigned long flags;\r\nunsigned ivsize = crypto_aead_ivsize(crypto_aead_reqtfm(req));\r\ndev_req->giv = giv;\r\ndev_req->giv_len = ivsize;\r\ndev_req->req = &req->base;\r\ndev_req->is_encrypt = is_encrypt;\r\ndev_req->result = -EBUSY;\r\ndev_req->engine = engine;\r\ndev_req->complete = spacc_aead_complete;\r\nif (unlikely(spacc_aead_need_fallback(dev_req)))\r\nreturn spacc_aead_do_fallback(req, alg_type, is_encrypt);\r\nspacc_aead_make_ddts(dev_req, dev_req->giv);\r\nerr = -EINPROGRESS;\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nif (unlikely(spacc_fifo_cmd_full(engine)) ||\r\nengine->in_flight + 1 > engine->fifo_sz) {\r\nif (!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\r\nerr = -EBUSY;\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out_free_ddts;\r\n}\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\n} else {\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\nspacc_push(engine);\r\n}\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out;\r\nout_free_ddts:\r\nspacc_aead_free_ddts(dev_req);\r\nout:\r\nreturn err;\r\n}\r\nstatic int spacc_aead_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->__crt_alg);\r\nreturn spacc_aead_setup(req, NULL, alg->type, 1);\r\n}\r\nstatic int spacc_aead_givencrypt(struct aead_givcrypt_request *req)\r\n{\r\nstruct crypto_aead *tfm = aead_givcrypt_reqtfm(req);\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\nsize_t ivsize = crypto_aead_ivsize(tfm);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->base.__crt_alg);\r\nunsigned len;\r\n__be64 seq;\r\nmemcpy(req->areq.iv, ctx->salt, ivsize);\r\nlen = ivsize;\r\nif (ivsize > sizeof(u64)) {\r\nmemset(req->giv, 0, ivsize - sizeof(u64));\r\nlen = sizeof(u64);\r\n}\r\nseq = cpu_to_be64(req->seq);\r\nmemcpy(req->giv + ivsize - len, &seq, len);\r\nreturn spacc_aead_setup(&req->areq, req->giv, alg->type, 1);\r\n}\r\nstatic int spacc_aead_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->__crt_alg);\r\nreturn spacc_aead_setup(req, NULL, alg->type, 0);\r\n}\r\nstatic int spacc_aead_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_engine *engine = spacc_alg->engine;\r\nctx->generic.flags = spacc_alg->type;\r\nctx->generic.engine = engine;\r\nctx->sw_cipher = crypto_alloc_aead(alg->cra_name, 0,\r\nCRYPTO_ALG_ASYNC |\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(ctx->sw_cipher)) {\r\ndev_warn(engine->dev, "failed to allocate fallback for %s\n",\r\nalg->cra_name);\r\nctx->sw_cipher = NULL;\r\n}\r\nctx->generic.key_offs = spacc_alg->key_offs;\r\nctx->generic.iv_offs = spacc_alg->iv_offs;\r\nget_random_bytes(ctx->salt, sizeof(ctx->salt));\r\ntfm->crt_aead.reqsize = sizeof(struct spacc_req);\r\nreturn 0;\r\n}\r\nstatic void spacc_aead_cra_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (ctx->sw_cipher)\r\ncrypto_free_aead(ctx->sw_cipher);\r\nctx->sw_cipher = NULL;\r\n}\r\nstatic int spacc_des_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nif (len > DES3_EDE_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!des_ekey(tmp, key)) &&\r\n(crypto_ablkcipher_get_flags(cipher) & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, len);\r\nctx->key_len = len;\r\nreturn 0;\r\n}\r\nstatic int spacc_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint err = 0;\r\nif (len > AES_MAX_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif (len != AES_KEYSIZE_128 && len != AES_KEYSIZE_256 &&\r\nctx->sw_cipher) {\r\nctx->sw_cipher->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;\r\nctx->sw_cipher->base.crt_flags |=\r\ncipher->base.crt_flags & CRYPTO_TFM_REQ_MASK;\r\nerr = crypto_ablkcipher_setkey(ctx->sw_cipher, key, len);\r\nif (err)\r\ngoto sw_setkey_failed;\r\n} else if (len != AES_KEYSIZE_128 && len != AES_KEYSIZE_256 &&\r\n!ctx->sw_cipher)\r\nerr = -EINVAL;\r\nmemcpy(ctx->key, key, len);\r\nctx->key_len = len;\r\nsw_setkey_failed:\r\nif (err && ctx->sw_cipher) {\r\ntfm->crt_flags &= ~CRYPTO_TFM_RES_MASK;\r\ntfm->crt_flags |=\r\nctx->sw_cipher->base.crt_flags & CRYPTO_TFM_RES_MASK;\r\n}\r\nreturn err;\r\n}\r\nstatic int spacc_kasumi_f8_setkey(struct crypto_ablkcipher *cipher,\r\nconst u8 *key, unsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint err = 0;\r\nif (len > AES_MAX_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(ctx->key, key, len);\r\nctx->key_len = len;\r\nout:\r\nreturn err;\r\n}\r\nstatic int spacc_ablk_need_fallback(struct spacc_req *req)\r\n{\r\nstruct spacc_ablk_ctx *ctx;\r\nstruct crypto_tfm *tfm = req->req->tfm;\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nctx = crypto_tfm_ctx(tfm);\r\nreturn (spacc_alg->ctrl_default & SPACC_CRYPTO_ALG_MASK) ==\r\nSPA_CTRL_CIPH_ALG_AES &&\r\nctx->key_len != AES_KEYSIZE_128 &&\r\nctx->key_len != AES_KEYSIZE_256;\r\n}\r\nstatic void spacc_ablk_complete(struct spacc_req *req)\r\n{\r\nstruct ablkcipher_request *ablk_req =\r\ncontainer_of(req->req, struct ablkcipher_request, base);\r\nif (ablk_req->src != ablk_req->dst) {\r\nspacc_free_ddt(req, req->src_ddt, req->src_addr, ablk_req->src,\r\nablk_req->nbytes, DMA_TO_DEVICE);\r\nspacc_free_ddt(req, req->dst_ddt, req->dst_addr, ablk_req->dst,\r\nablk_req->nbytes, DMA_FROM_DEVICE);\r\n} else\r\nspacc_free_ddt(req, req->dst_ddt, req->dst_addr, ablk_req->dst,\r\nablk_req->nbytes, DMA_BIDIRECTIONAL);\r\nreq->req->complete(req->req, req->result);\r\n}\r\nstatic int spacc_ablk_submit(struct spacc_req *req)\r\n{\r\nstruct crypto_tfm *tfm = req->req->tfm;\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct ablkcipher_request *ablk_req = ablkcipher_request_cast(req->req);\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_engine *engine = ctx->generic.engine;\r\nu32 ctrl;\r\nreq->ctx_id = spacc_load_ctx(&ctx->generic, ctx->key,\r\nctx->key_len, ablk_req->info, alg->cra_ablkcipher.ivsize,\r\nNULL, 0);\r\nwritel(req->src_addr, engine->regs + SPA_SRC_PTR_REG_OFFSET);\r\nwritel(req->dst_addr, engine->regs + SPA_DST_PTR_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_OFFSET_REG_OFFSET);\r\nwritel(ablk_req->nbytes, engine->regs + SPA_PROC_LEN_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_ICV_OFFSET_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_AUX_INFO_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_AAD_LEN_REG_OFFSET);\r\nctrl = spacc_alg->ctrl_default | (req->ctx_id << SPA_CTRL_CTX_IDX) |\r\n(req->is_encrypt ? (1 << SPA_CTRL_ENCRYPT_IDX) :\r\n(1 << SPA_CTRL_KEY_EXP));\r\nmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\r\nwritel(ctrl, engine->regs + SPA_CTRL_REG_OFFSET);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int spacc_ablk_do_fallback(struct ablkcipher_request *req,\r\nunsigned alg_type, bool is_encrypt)\r\n{\r\nstruct crypto_tfm *old_tfm =\r\ncrypto_ablkcipher_tfm(crypto_ablkcipher_reqtfm(req));\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(old_tfm);\r\nint err;\r\nif (!ctx->sw_cipher)\r\nreturn -EINVAL;\r\nablkcipher_request_set_tfm(req, ctx->sw_cipher);\r\nerr = is_encrypt ? crypto_ablkcipher_encrypt(req) :\r\ncrypto_ablkcipher_decrypt(req);\r\nablkcipher_request_set_tfm(req, __crypto_ablkcipher_cast(old_tfm));\r\nreturn err;\r\n}\r\nstatic int spacc_ablk_setup(struct ablkcipher_request *req, unsigned alg_type,\r\nbool is_encrypt)\r\n{\r\nstruct crypto_alg *alg = req->base.tfm->__crt_alg;\r\nstruct spacc_engine *engine = to_spacc_alg(alg)->engine;\r\nstruct spacc_req *dev_req = ablkcipher_request_ctx(req);\r\nunsigned long flags;\r\nint err = -ENOMEM;\r\ndev_req->req = &req->base;\r\ndev_req->is_encrypt = is_encrypt;\r\ndev_req->engine = engine;\r\ndev_req->complete = spacc_ablk_complete;\r\ndev_req->result = -EINPROGRESS;\r\nif (unlikely(spacc_ablk_need_fallback(dev_req)))\r\nreturn spacc_ablk_do_fallback(req, alg_type, is_encrypt);\r\nif (req->src != req->dst) {\r\ndev_req->src_ddt = spacc_sg_to_ddt(engine, req->src,\r\nreq->nbytes, DMA_TO_DEVICE, &dev_req->src_addr);\r\nif (!dev_req->src_ddt)\r\ngoto out;\r\ndev_req->dst_ddt = spacc_sg_to_ddt(engine, req->dst,\r\nreq->nbytes, DMA_FROM_DEVICE, &dev_req->dst_addr);\r\nif (!dev_req->dst_ddt)\r\ngoto out_free_src;\r\n} else {\r\ndev_req->dst_ddt = spacc_sg_to_ddt(engine, req->dst,\r\nreq->nbytes, DMA_BIDIRECTIONAL, &dev_req->dst_addr);\r\nif (!dev_req->dst_ddt)\r\ngoto out;\r\ndev_req->src_ddt = NULL;\r\ndev_req->src_addr = dev_req->dst_addr;\r\n}\r\nerr = -EINPROGRESS;\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nif (unlikely(spacc_fifo_cmd_full(engine)) ||\r\nengine->in_flight + 1 > engine->fifo_sz) {\r\nif (!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\r\nerr = -EBUSY;\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out_free_ddts;\r\n}\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\n} else {\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\nspacc_push(engine);\r\n}\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out;\r\nout_free_ddts:\r\nspacc_free_ddt(dev_req, dev_req->dst_ddt, dev_req->dst_addr, req->dst,\r\nreq->nbytes, req->src == req->dst ?\r\nDMA_BIDIRECTIONAL : DMA_FROM_DEVICE);\r\nout_free_src:\r\nif (req->src != req->dst)\r\nspacc_free_ddt(dev_req, dev_req->src_ddt, dev_req->src_addr,\r\nreq->src, req->nbytes, DMA_TO_DEVICE);\r\nout:\r\nreturn err;\r\n}\r\nstatic int spacc_ablk_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_engine *engine = spacc_alg->engine;\r\nctx->generic.flags = spacc_alg->type;\r\nctx->generic.engine = engine;\r\nif (alg->cra_flags & CRYPTO_ALG_NEED_FALLBACK) {\r\nctx->sw_cipher = crypto_alloc_ablkcipher(alg->cra_name, 0,\r\nCRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(ctx->sw_cipher)) {\r\ndev_warn(engine->dev, "failed to allocate fallback for %s\n",\r\nalg->cra_name);\r\nctx->sw_cipher = NULL;\r\n}\r\n}\r\nctx->generic.key_offs = spacc_alg->key_offs;\r\nctx->generic.iv_offs = spacc_alg->iv_offs;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct spacc_req);\r\nreturn 0;\r\n}\r\nstatic void spacc_ablk_cra_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (ctx->sw_cipher)\r\ncrypto_free_ablkcipher(ctx->sw_cipher);\r\nctx->sw_cipher = NULL;\r\n}\r\nstatic int spacc_ablk_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->__crt_alg);\r\nreturn spacc_ablk_setup(req, alg->type, 1);\r\n}\r\nstatic int spacc_ablk_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->__crt_alg);\r\nreturn spacc_ablk_setup(req, alg->type, 0);\r\n}\r\nstatic inline int spacc_fifo_stat_empty(struct spacc_engine *engine)\r\n{\r\nreturn readl(engine->regs + SPA_FIFO_STAT_REG_OFFSET) &\r\nSPA_FIFO_STAT_EMPTY;\r\n}\r\nstatic void spacc_process_done(struct spacc_engine *engine)\r\n{\r\nstruct spacc_req *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nwhile (!spacc_fifo_stat_empty(engine)) {\r\nreq = list_first_entry(&engine->in_progress, struct spacc_req,\r\nlist);\r\nlist_move_tail(&req->list, &engine->completed);\r\n--engine->in_flight;\r\nwritel(~0, engine->regs + SPA_STAT_POP_REG_OFFSET);\r\nreq->result = (readl(engine->regs + SPA_STATUS_REG_OFFSET) &\r\nSPA_STATUS_RES_CODE_MASK) >> SPA_STATUS_RES_CODE_OFFSET;\r\nif (unlikely(req->result)) {\r\nswitch (req->result) {\r\ncase SPA_STATUS_ICV_FAIL:\r\nreq->result = -EBADMSG;\r\nbreak;\r\ncase SPA_STATUS_MEMORY_ERROR:\r\ndev_warn(engine->dev,\r\n"memory error triggered\n");\r\nreq->result = -EFAULT;\r\nbreak;\r\ncase SPA_STATUS_BLOCK_ERROR:\r\ndev_warn(engine->dev,\r\n"block error triggered\n");\r\nreq->result = -EIO;\r\nbreak;\r\n}\r\n}\r\n}\r\ntasklet_schedule(&engine->complete);\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\n}\r\nstatic irqreturn_t spacc_spacc_irq(int irq, void *dev)\r\n{\r\nstruct spacc_engine *engine = (struct spacc_engine *)dev;\r\nu32 spacc_irq_stat = readl(engine->regs + SPA_IRQ_STAT_REG_OFFSET);\r\nwritel(spacc_irq_stat, engine->regs + SPA_IRQ_STAT_REG_OFFSET);\r\nspacc_process_done(engine);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spacc_packet_timeout(unsigned long data)\r\n{\r\nstruct spacc_engine *engine = (struct spacc_engine *)data;\r\nspacc_process_done(engine);\r\n}\r\nstatic int spacc_req_submit(struct spacc_req *req)\r\n{\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nif (CRYPTO_ALG_TYPE_AEAD == (CRYPTO_ALG_TYPE_MASK & alg->cra_flags))\r\nreturn spacc_aead_submit(req);\r\nelse\r\nreturn spacc_ablk_submit(req);\r\n}\r\nstatic void spacc_spacc_complete(unsigned long data)\r\n{\r\nstruct spacc_engine *engine = (struct spacc_engine *)data;\r\nstruct spacc_req *req, *tmp;\r\nunsigned long flags;\r\nLIST_HEAD(completed);\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nlist_splice_init(&engine->completed, &completed);\r\nspacc_push(engine);\r\nif (engine->in_flight)\r\nmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\nlist_for_each_entry_safe(req, tmp, &completed, list) {\r\nlist_del(&req->list);\r\nreq->complete(req);\r\n}\r\n}\r\nstatic int spacc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spacc_engine *engine = platform_get_drvdata(pdev);\r\nclk_disable(engine->clk);\r\nreturn 0;\r\n}\r\nstatic int spacc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spacc_engine *engine = platform_get_drvdata(pdev);\r\nreturn clk_enable(engine->clk);\r\n}\r\nstatic inline struct spacc_engine *spacc_dev_to_engine(struct device *dev)\r\n{\r\nreturn dev ? platform_get_drvdata(to_platform_device(dev)) : NULL;\r\n}\r\nstatic ssize_t spacc_stat_irq_thresh_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct spacc_engine *engine = spacc_dev_to_engine(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", engine->stat_irq_thresh);\r\n}\r\nstatic ssize_t spacc_stat_irq_thresh_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct spacc_engine *engine = spacc_dev_to_engine(dev);\r\nunsigned long thresh;\r\nif (kstrtoul(buf, 0, &thresh))\r\nreturn -EINVAL;\r\nthresh = clamp(thresh, 1UL, engine->fifo_sz - 1);\r\nengine->stat_irq_thresh = thresh;\r\nwritel(engine->stat_irq_thresh << SPA_IRQ_CTRL_STAT_CNT_OFFSET,\r\nengine->regs + SPA_IRQ_CTRL_REG_OFFSET);\r\nreturn len;\r\n}\r\nstatic bool spacc_is_compatible(struct platform_device *pdev,\r\nconst char *spacc_type)\r\n{\r\nconst struct platform_device_id *platid = platform_get_device_id(pdev);\r\nif (platid && !strcmp(platid->name, spacc_type))\r\nreturn true;\r\n#ifdef CONFIG_OF\r\nif (of_device_is_compatible(pdev->dev.of_node, spacc_type))\r\nreturn true;\r\n#endif\r\nreturn false;\r\n}\r\nstatic int spacc_probe(struct platform_device *pdev)\r\n{\r\nint i, err, ret = -EINVAL;\r\nstruct resource *mem, *irq;\r\nstruct spacc_engine *engine = devm_kzalloc(&pdev->dev, sizeof(*engine),\r\nGFP_KERNEL);\r\nif (!engine)\r\nreturn -ENOMEM;\r\nif (spacc_is_compatible(pdev, "picochip,spacc-ipsec")) {\r\nengine->max_ctxs = SPACC_CRYPTO_IPSEC_MAX_CTXS;\r\nengine->cipher_pg_sz = SPACC_CRYPTO_IPSEC_CIPHER_PG_SZ;\r\nengine->hash_pg_sz = SPACC_CRYPTO_IPSEC_HASH_PG_SZ;\r\nengine->fifo_sz = SPACC_CRYPTO_IPSEC_FIFO_SZ;\r\nengine->algs = ipsec_engine_algs;\r\nengine->num_algs = ARRAY_SIZE(ipsec_engine_algs);\r\n} else if (spacc_is_compatible(pdev, "picochip,spacc-l2")) {\r\nengine->max_ctxs = SPACC_CRYPTO_L2_MAX_CTXS;\r\nengine->cipher_pg_sz = SPACC_CRYPTO_L2_CIPHER_PG_SZ;\r\nengine->hash_pg_sz = SPACC_CRYPTO_L2_HASH_PG_SZ;\r\nengine->fifo_sz = SPACC_CRYPTO_L2_FIFO_SZ;\r\nengine->algs = l2_engine_algs;\r\nengine->num_algs = ARRAY_SIZE(l2_engine_algs);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nengine->name = dev_name(&pdev->dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!mem || !irq) {\r\ndev_err(&pdev->dev, "no memory/irq resource for engine\n");\r\nreturn -ENXIO;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),\r\nengine->name))\r\nreturn -ENOMEM;\r\nengine->regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!engine->regs) {\r\ndev_err(&pdev->dev, "memory map failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (devm_request_irq(&pdev->dev, irq->start, spacc_spacc_irq, 0,\r\nengine->name, engine)) {\r\ndev_err(engine->dev, "failed to request IRQ\n");\r\nreturn -EBUSY;\r\n}\r\nengine->dev = &pdev->dev;\r\nengine->cipher_ctx_base = engine->regs + SPA_CIPH_KEY_BASE_REG_OFFSET;\r\nengine->hash_key_base = engine->regs + SPA_HASH_KEY_BASE_REG_OFFSET;\r\nengine->req_pool = dmam_pool_create(engine->name, engine->dev,\r\nMAX_DDT_LEN * sizeof(struct spacc_ddt), 8, SZ_64K);\r\nif (!engine->req_pool)\r\nreturn -ENOMEM;\r\nspin_lock_init(&engine->hw_lock);\r\nengine->clk = clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(engine->clk)) {\r\ndev_info(&pdev->dev, "clk unavailable\n");\r\ndevice_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);\r\nreturn PTR_ERR(engine->clk);\r\n}\r\nif (clk_enable(engine->clk)) {\r\ndev_info(&pdev->dev, "unable to enable clk\n");\r\nclk_put(engine->clk);\r\nreturn -EIO;\r\n}\r\nerr = device_create_file(&pdev->dev, &dev_attr_stat_irq_thresh);\r\nif (err) {\r\nclk_disable(engine->clk);\r\nclk_put(engine->clk);\r\nreturn err;\r\n}\r\nengine->stat_irq_thresh = (engine->fifo_sz / 2);\r\nwritel(engine->stat_irq_thresh << SPA_IRQ_CTRL_STAT_CNT_OFFSET,\r\nengine->regs + SPA_IRQ_CTRL_REG_OFFSET);\r\nwritel(SPA_IRQ_EN_STAT_EN | SPA_IRQ_EN_GLBL_EN,\r\nengine->regs + SPA_IRQ_EN_REG_OFFSET);\r\nsetup_timer(&engine->packet_timeout, spacc_packet_timeout,\r\n(unsigned long)engine);\r\nINIT_LIST_HEAD(&engine->pending);\r\nINIT_LIST_HEAD(&engine->completed);\r\nINIT_LIST_HEAD(&engine->in_progress);\r\nengine->in_flight = 0;\r\ntasklet_init(&engine->complete, spacc_spacc_complete,\r\n(unsigned long)engine);\r\nplatform_set_drvdata(pdev, engine);\r\nINIT_LIST_HEAD(&engine->registered_algs);\r\nfor (i = 0; i < engine->num_algs; ++i) {\r\nengine->algs[i].engine = engine;\r\nerr = crypto_register_alg(&engine->algs[i].alg);\r\nif (!err) {\r\nlist_add_tail(&engine->algs[i].entry,\r\n&engine->registered_algs);\r\nret = 0;\r\n}\r\nif (err)\r\ndev_err(engine->dev, "failed to register alg \"%s\"\n",\r\nengine->algs[i].alg.cra_name);\r\nelse\r\ndev_dbg(engine->dev, "registered alg \"%s\"\n",\r\nengine->algs[i].alg.cra_name);\r\n}\r\nreturn ret;\r\n}\r\nstatic int spacc_remove(struct platform_device *pdev)\r\n{\r\nstruct spacc_alg *alg, *next;\r\nstruct spacc_engine *engine = platform_get_drvdata(pdev);\r\ndel_timer_sync(&engine->packet_timeout);\r\ndevice_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);\r\nlist_for_each_entry_safe(alg, next, &engine->registered_algs, entry) {\r\nlist_del(&alg->entry);\r\ncrypto_unregister_alg(&alg->alg);\r\n}\r\nclk_disable(engine->clk);\r\nclk_put(engine->clk);\r\nreturn 0;\r\n}
