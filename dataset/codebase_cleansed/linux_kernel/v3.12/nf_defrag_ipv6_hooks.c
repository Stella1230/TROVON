static enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,\r\nstruct sk_buff *skb)\r\n{\r\nu16 zone = NF_CT_DEFAULT_ZONE;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (skb->nfct)\r\nzone = nf_ct_zone((struct nf_conn *)skb->nfct);\r\n#endif\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (skb->nf_bridge &&\r\nskb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)\r\nreturn IP6_DEFRAG_CONNTRACK_BRIDGE_IN + zone;\r\n#endif\r\nif (hooknum == NF_INET_PRE_ROUTING)\r\nreturn IP6_DEFRAG_CONNTRACK_IN + zone;\r\nelse\r\nreturn IP6_DEFRAG_CONNTRACK_OUT + zone;\r\n}\r\nstatic unsigned int ipv6_defrag(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct sk_buff *reasm;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\r\nreturn NF_ACCEPT;\r\n#endif\r\nreasm = nf_ct_frag6_gather(skb, nf_ct6_defrag_user(hooknum, skb));\r\nif (reasm == NULL)\r\nreturn NF_STOLEN;\r\nif (reasm == skb)\r\nreturn NF_ACCEPT;\r\nnf_ct_frag6_output(hooknum, reasm, (struct net_device *)in,\r\n(struct net_device *)out, okfn);\r\nreturn NF_STOLEN;\r\n}\r\nstatic int __init nf_defrag_init(void)\r\n{\r\nint ret = 0;\r\nret = nf_ct_frag6_init();\r\nif (ret < 0) {\r\npr_err("nf_defrag_ipv6: can't initialize frag6.\n");\r\nreturn ret;\r\n}\r\nret = nf_register_hooks(ipv6_defrag_ops, ARRAY_SIZE(ipv6_defrag_ops));\r\nif (ret < 0) {\r\npr_err("nf_defrag_ipv6: can't register hooks\n");\r\ngoto cleanup_frag6;\r\n}\r\nreturn ret;\r\ncleanup_frag6:\r\nnf_ct_frag6_cleanup();\r\nreturn ret;\r\n}\r\nstatic void __exit nf_defrag_fini(void)\r\n{\r\nnf_unregister_hooks(ipv6_defrag_ops, ARRAY_SIZE(ipv6_defrag_ops));\r\nnf_ct_frag6_cleanup();\r\n}\r\nvoid nf_defrag_ipv6_enable(void)\r\n{\r\n}
