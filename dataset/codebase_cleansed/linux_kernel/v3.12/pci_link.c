static acpi_status acpi_pci_link_check_possible(struct acpi_resource *resource,\r\nvoid *context)\r\n{\r\nstruct acpi_pci_link *link = context;\r\nu32 i;\r\nswitch (resource->type) {\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\n{\r\nstruct acpi_resource_irq *p = &resource->data.irq;\r\nif (!p || !p->interrupt_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Blank _PRS IRQ resource\n"));\r\nreturn AE_OK;\r\n}\r\nfor (i = 0;\r\n(i < p->interrupt_count\r\n&& i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {\r\nif (!p->interrupts[i]) {\r\nprintk(KERN_WARNING PREFIX\r\n"Invalid _PRS IRQ %d\n",\r\np->interrupts[i]);\r\ncontinue;\r\n}\r\nlink->irq.possible[i] = p->interrupts[i];\r\nlink->irq.possible_count++;\r\n}\r\nlink->irq.triggering = p->triggering;\r\nlink->irq.polarity = p->polarity;\r\nlink->irq.resource_type = ACPI_RESOURCE_TYPE_IRQ;\r\nbreak;\r\n}\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\n{\r\nstruct acpi_resource_extended_irq *p =\r\n&resource->data.extended_irq;\r\nif (!p || !p->interrupt_count) {\r\nprintk(KERN_WARNING PREFIX\r\n"Blank _PRS EXT IRQ resource\n");\r\nreturn AE_OK;\r\n}\r\nfor (i = 0;\r\n(i < p->interrupt_count\r\n&& i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {\r\nif (!p->interrupts[i]) {\r\nprintk(KERN_WARNING PREFIX\r\n"Invalid _PRS IRQ %d\n",\r\np->interrupts[i]);\r\ncontinue;\r\n}\r\nlink->irq.possible[i] = p->interrupts[i];\r\nlink->irq.possible_count++;\r\n}\r\nlink->irq.triggering = p->triggering;\r\nlink->irq.polarity = p->polarity;\r\nlink->irq.resource_type = ACPI_RESOURCE_TYPE_EXTENDED_IRQ;\r\nbreak;\r\n}\r\ndefault:\r\nprintk(KERN_ERR PREFIX "_PRS resource type 0x%x isn't an IRQ\n",\r\nresource->type);\r\nreturn AE_OK;\r\n}\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int acpi_pci_link_get_possible(struct acpi_pci_link *link)\r\n{\r\nacpi_status status;\r\nstatus = acpi_walk_resources(link->device->handle, METHOD_NAME__PRS,\r\nacpi_pci_link_check_possible, link);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PRS"));\r\nreturn -ENODEV;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Found %d possible IRQs\n",\r\nlink->irq.possible_count));\r\nreturn 0;\r\n}\r\nstatic acpi_status acpi_pci_link_check_current(struct acpi_resource *resource,\r\nvoid *context)\r\n{\r\nint *irq = context;\r\nswitch (resource->type) {\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\n{\r\nstruct acpi_resource_irq *p = &resource->data.irq;\r\nif (!p || !p->interrupt_count) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Blank _CRS IRQ resource\n"));\r\nreturn AE_OK;\r\n}\r\n*irq = p->interrupts[0];\r\nbreak;\r\n}\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\n{\r\nstruct acpi_resource_extended_irq *p =\r\n&resource->data.extended_irq;\r\nif (!p || !p->interrupt_count) {\r\nprintk(KERN_WARNING PREFIX\r\n"Blank _CRS EXT IRQ resource\n");\r\nreturn AE_OK;\r\n}\r\n*irq = p->interrupts[0];\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PREFIX "_CRS resource type 0x%x isn't an IRQ\n",\r\nresource->type);\r\nreturn AE_OK;\r\n}\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int acpi_pci_link_get_current(struct acpi_pci_link *link)\r\n{\r\nint result = 0;\r\nacpi_status status;\r\nint irq = 0;\r\nlink->irq.active = 0;\r\nif (acpi_strict) {\r\nresult = acpi_bus_get_status(link->device);\r\nif (result) {\r\nprintk(KERN_ERR PREFIX "Unable to read status\n");\r\ngoto end;\r\n}\r\nif (!link->device->status.enabled) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link disabled\n"));\r\nreturn 0;\r\n}\r\n}\r\nstatus = acpi_walk_resources(link->device->handle, METHOD_NAME__CRS,\r\nacpi_pci_link_check_current, &irq);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _CRS"));\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nif (acpi_strict && !irq) {\r\nprintk(KERN_ERR PREFIX "_CRS returned 0\n");\r\nresult = -ENODEV;\r\n}\r\nlink->irq.active = irq;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Link at IRQ %d \n", link->irq.active));\r\nend:\r\nreturn result;\r\n}\r\nstatic int acpi_pci_link_set(struct acpi_pci_link *link, int irq)\r\n{\r\nint result;\r\nacpi_status status;\r\nstruct {\r\nstruct acpi_resource res;\r\nstruct acpi_resource end;\r\n} *resource;\r\nstruct acpi_buffer buffer = { 0, NULL };\r\nif (!irq)\r\nreturn -EINVAL;\r\nresource = kzalloc(sizeof(*resource) + 1, irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);\r\nif (!resource)\r\nreturn -ENOMEM;\r\nbuffer.length = sizeof(*resource) + 1;\r\nbuffer.pointer = resource;\r\nswitch (link->irq.resource_type) {\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\nresource->res.type = ACPI_RESOURCE_TYPE_IRQ;\r\nresource->res.length = sizeof(struct acpi_resource);\r\nresource->res.data.irq.triggering = link->irq.triggering;\r\nresource->res.data.irq.polarity =\r\nlink->irq.polarity;\r\nif (link->irq.triggering == ACPI_EDGE_SENSITIVE)\r\nresource->res.data.irq.sharable =\r\nACPI_EXCLUSIVE;\r\nelse\r\nresource->res.data.irq.sharable = ACPI_SHARED;\r\nresource->res.data.irq.interrupt_count = 1;\r\nresource->res.data.irq.interrupts[0] = irq;\r\nbreak;\r\ncase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\r\nresource->res.type = ACPI_RESOURCE_TYPE_EXTENDED_IRQ;\r\nresource->res.length = sizeof(struct acpi_resource);\r\nresource->res.data.extended_irq.producer_consumer =\r\nACPI_CONSUMER;\r\nresource->res.data.extended_irq.triggering =\r\nlink->irq.triggering;\r\nresource->res.data.extended_irq.polarity =\r\nlink->irq.polarity;\r\nif (link->irq.triggering == ACPI_EDGE_SENSITIVE)\r\nresource->res.data.irq.sharable =\r\nACPI_EXCLUSIVE;\r\nelse\r\nresource->res.data.irq.sharable = ACPI_SHARED;\r\nresource->res.data.extended_irq.interrupt_count = 1;\r\nresource->res.data.extended_irq.interrupts[0] = irq;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PREFIX "Invalid Resource_type %d\n", link->irq.resource_type);\r\nresult = -EINVAL;\r\ngoto end;\r\n}\r\nresource->end.type = ACPI_RESOURCE_TYPE_END_TAG;\r\nresource->end.length = sizeof(struct acpi_resource);\r\nstatus = acpi_set_current_resources(link->device->handle, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _SRS"));\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nresult = acpi_bus_get_status(link->device);\r\nif (result) {\r\nprintk(KERN_ERR PREFIX "Unable to read status\n");\r\ngoto end;\r\n}\r\nif (!link->device->status.enabled) {\r\nprintk(KERN_WARNING PREFIX\r\n"%s [%s] disabled and referenced, BIOS bug\n",\r\nacpi_device_name(link->device),\r\nacpi_device_bid(link->device));\r\n}\r\nresult = acpi_pci_link_get_current(link);\r\nif (result) {\r\ngoto end;\r\n}\r\nif (link->irq.active != irq) {\r\nprintk(KERN_WARNING PREFIX\r\n"%s [%s] BIOS reported IRQ %d, using IRQ %d\n",\r\nacpi_device_name(link->device),\r\nacpi_device_bid(link->device), link->irq.active, irq);\r\nlink->irq.active = irq;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Set IRQ %d\n", link->irq.active));\r\nend:\r\nkfree(resource);\r\nreturn result;\r\n}\r\nint __init acpi_irq_penalty_init(void)\r\n{\r\nstruct acpi_pci_link *link;\r\nint i;\r\nlist_for_each_entry(link, &acpi_link_list, list) {\r\nif (link->irq.possible_count) {\r\nint penalty =\r\nPIRQ_PENALTY_PCI_POSSIBLE /\r\nlink->irq.possible_count;\r\nfor (i = 0; i < link->irq.possible_count; i++) {\r\nif (link->irq.possible[i] < ACPI_MAX_ISA_IRQ)\r\nacpi_irq_penalty[link->irq.\r\npossible[i]] +=\r\npenalty;\r\n}\r\n} else if (link->irq.active) {\r\nacpi_irq_penalty[link->irq.active] +=\r\nPIRQ_PENALTY_PCI_POSSIBLE;\r\n}\r\n}\r\nacpi_irq_penalty[acpi_gbl_FADT.sci_interrupt] += PIRQ_PENALTY_PCI_USING;\r\nreturn 0;\r\n}\r\nstatic int acpi_pci_link_allocate(struct acpi_pci_link *link)\r\n{\r\nint irq;\r\nint i;\r\nif (link->irq.initialized) {\r\nif (link->refcnt == 0)\r\nacpi_pci_link_set(link, link->irq.active);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < link->irq.possible_count; ++i) {\r\nif (link->irq.active == link->irq.possible[i])\r\nbreak;\r\n}\r\nif (i == link->irq.possible_count) {\r\nif (acpi_strict)\r\nprintk(KERN_WARNING PREFIX "_CRS %d not found"\r\n" in _PRS\n", link->irq.active);\r\nlink->irq.active = 0;\r\n}\r\nif (link->irq.active)\r\nirq = link->irq.active;\r\nelse\r\nirq = link->irq.possible[link->irq.possible_count - 1];\r\nif (acpi_irq_balance || !link->irq.active) {\r\nfor (i = (link->irq.possible_count - 1); i >= 0; i--) {\r\nif (acpi_irq_penalty[irq] >\r\nacpi_irq_penalty[link->irq.possible[i]])\r\nirq = link->irq.possible[i];\r\n}\r\n}\r\nif (acpi_pci_link_set(link, irq)) {\r\nprintk(KERN_ERR PREFIX "Unable to set IRQ for %s [%s]. "\r\n"Try pci=noacpi or acpi=off\n",\r\nacpi_device_name(link->device),\r\nacpi_device_bid(link->device));\r\nreturn -ENODEV;\r\n} else {\r\nacpi_irq_penalty[link->irq.active] += PIRQ_PENALTY_PCI_USING;\r\nprintk(KERN_WARNING PREFIX "%s [%s] enabled at IRQ %d\n",\r\nacpi_device_name(link->device),\r\nacpi_device_bid(link->device), link->irq.active);\r\n}\r\nlink->irq.initialized = 1;\r\nreturn 0;\r\n}\r\nint acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering,\r\nint *polarity, char **name)\r\n{\r\nint result;\r\nstruct acpi_device *device;\r\nstruct acpi_pci_link *link;\r\nresult = acpi_bus_get_device(handle, &device);\r\nif (result) {\r\nprintk(KERN_ERR PREFIX "Invalid link device\n");\r\nreturn -1;\r\n}\r\nlink = acpi_driver_data(device);\r\nif (!link) {\r\nprintk(KERN_ERR PREFIX "Invalid link context\n");\r\nreturn -1;\r\n}\r\nif (index) {\r\nprintk(KERN_ERR PREFIX "Invalid index %d\n", index);\r\nreturn -1;\r\n}\r\nmutex_lock(&acpi_link_lock);\r\nif (acpi_pci_link_allocate(link)) {\r\nmutex_unlock(&acpi_link_lock);\r\nreturn -1;\r\n}\r\nif (!link->irq.active) {\r\nmutex_unlock(&acpi_link_lock);\r\nprintk(KERN_ERR PREFIX "Link active IRQ is 0!\n");\r\nreturn -1;\r\n}\r\nlink->refcnt++;\r\nmutex_unlock(&acpi_link_lock);\r\nif (triggering)\r\n*triggering = link->irq.triggering;\r\nif (polarity)\r\n*polarity = link->irq.polarity;\r\nif (name)\r\n*name = acpi_device_bid(link->device);\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Link %s is referenced\n",\r\nacpi_device_bid(link->device)));\r\nreturn (link->irq.active);\r\n}\r\nint acpi_pci_link_free_irq(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nstruct acpi_pci_link *link;\r\nacpi_status result;\r\nresult = acpi_bus_get_device(handle, &device);\r\nif (result) {\r\nprintk(KERN_ERR PREFIX "Invalid link device\n");\r\nreturn -1;\r\n}\r\nlink = acpi_driver_data(device);\r\nif (!link) {\r\nprintk(KERN_ERR PREFIX "Invalid link context\n");\r\nreturn -1;\r\n}\r\nmutex_lock(&acpi_link_lock);\r\nif (!link->irq.initialized) {\r\nmutex_unlock(&acpi_link_lock);\r\nprintk(KERN_ERR PREFIX "Link isn't initialized\n");\r\nreturn -1;\r\n}\r\n#ifdef FUTURE_USE\r\nlink->refcnt--;\r\n#endif\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Link %s is dereferenced\n",\r\nacpi_device_bid(link->device)));\r\nif (link->refcnt == 0)\r\nacpi_evaluate_object(link->device->handle, "_DIS", NULL, NULL);\r\nmutex_unlock(&acpi_link_lock);\r\nreturn (link->irq.active);\r\n}\r\nstatic int acpi_pci_link_add(struct acpi_device *device,\r\nconst struct acpi_device_id *not_used)\r\n{\r\nint result;\r\nstruct acpi_pci_link *link;\r\nint i;\r\nint found = 0;\r\nlink = kzalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);\r\nif (!link)\r\nreturn -ENOMEM;\r\nlink->device = device;\r\nstrcpy(acpi_device_name(device), ACPI_PCI_LINK_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);\r\ndevice->driver_data = link;\r\nmutex_lock(&acpi_link_lock);\r\nresult = acpi_pci_link_get_possible(link);\r\nif (result)\r\ngoto end;\r\nacpi_pci_link_get_current(link);\r\nprintk(KERN_INFO PREFIX "%s [%s] (IRQs", acpi_device_name(device),\r\nacpi_device_bid(device));\r\nfor (i = 0; i < link->irq.possible_count; i++) {\r\nif (link->irq.active == link->irq.possible[i]) {\r\nprintk(KERN_CONT " *%d", link->irq.possible[i]);\r\nfound = 1;\r\n} else\r\nprintk(KERN_CONT " %d", link->irq.possible[i]);\r\n}\r\nprintk(KERN_CONT ")");\r\nif (!found)\r\nprintk(KERN_CONT " *%d", link->irq.active);\r\nif (!link->device->status.enabled)\r\nprintk(KERN_CONT ", disabled.");\r\nprintk(KERN_CONT "\n");\r\nlist_add_tail(&link->list, &acpi_link_list);\r\nend:\r\nacpi_evaluate_object(device->handle, "_DIS", NULL, NULL);\r\nmutex_unlock(&acpi_link_lock);\r\nif (result)\r\nkfree(link);\r\nreturn result < 0 ? result : 1;\r\n}\r\nstatic int acpi_pci_link_resume(struct acpi_pci_link *link)\r\n{\r\nif (link->refcnt && link->irq.active && link->irq.initialized)\r\nreturn (acpi_pci_link_set(link, link->irq.active));\r\nreturn 0;\r\n}\r\nstatic void irqrouter_resume(void)\r\n{\r\nstruct acpi_pci_link *link;\r\nlist_for_each_entry(link, &acpi_link_list, list) {\r\nacpi_pci_link_resume(link);\r\n}\r\n}\r\nstatic void acpi_pci_link_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_pci_link *link;\r\nlink = acpi_driver_data(device);\r\nmutex_lock(&acpi_link_lock);\r\nlist_del(&link->list);\r\nmutex_unlock(&acpi_link_lock);\r\nkfree(link);\r\n}\r\nstatic int __init acpi_irq_penalty_update(char *str, int used)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nint retval;\r\nint irq;\r\nretval = get_option(&str, &irq);\r\nif (!retval)\r\nbreak;\r\nif (irq < 0)\r\ncontinue;\r\nif (irq >= ARRAY_SIZE(acpi_irq_penalty))\r\ncontinue;\r\nif (used)\r\nacpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;\r\nelse\r\nacpi_irq_penalty[irq] = PIRQ_PENALTY_PCI_AVAILABLE;\r\nif (retval != 2)\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nvoid acpi_penalize_isa_irq(int irq, int active)\r\n{\r\nif (irq >= 0 && irq < ARRAY_SIZE(acpi_irq_penalty)) {\r\nif (active)\r\nacpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_USED;\r\nelse\r\nacpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;\r\n}\r\n}\r\nstatic int __init acpi_irq_isa(char *str)\r\n{\r\nreturn acpi_irq_penalty_update(str, 1);\r\n}\r\nstatic int __init acpi_irq_pci(char *str)\r\n{\r\nreturn acpi_irq_penalty_update(str, 0);\r\n}\r\nstatic int __init acpi_irq_nobalance_set(char *str)\r\n{\r\nacpi_irq_balance = 0;\r\nreturn 1;\r\n}\r\nstatic int __init acpi_irq_balance_set(char *str)\r\n{\r\nacpi_irq_balance = 1;\r\nreturn 1;\r\n}\r\nvoid __init acpi_pci_link_init(void)\r\n{\r\nif (acpi_noirq)\r\nreturn;\r\nif (acpi_irq_balance == -1) {\r\nif (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)\r\nacpi_irq_balance = 1;\r\nelse\r\nacpi_irq_balance = 0;\r\n}\r\nregister_syscore_ops(&irqrouter_syscore_ops);\r\nacpi_scan_add_handler(&pci_link_handler);\r\n}
