static inline __be16 vlan_proto(const struct sk_buff *skb)\r\n{\r\nif (vlan_tx_tag_present(skb))\r\nreturn skb->protocol;\r\nelse if (skb->protocol == htons(ETH_P_8021Q))\r\nreturn vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline __be16 pppoe_proto(const struct sk_buff *skb)\r\n{\r\nreturn *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +\r\nsizeof(struct pppoe_hdr)));\r\n}\r\nstatic void fake_update_pmtu(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb, u32 mtu)\r\n{\r\n}\r\nstatic void fake_redirect(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\n}\r\nstatic u32 *fake_cow_metrics(struct dst_entry *dst, unsigned long old)\r\n{\r\nreturn NULL;\r\n}\r\nstatic struct neighbour *fake_neigh_lookup(const struct dst_entry *dst,\r\nstruct sk_buff *skb,\r\nconst void *daddr)\r\n{\r\nreturn NULL;\r\n}\r\nstatic unsigned int fake_mtu(const struct dst_entry *dst)\r\n{\r\nreturn dst->dev->mtu;\r\n}\r\nvoid br_netfilter_rtable_init(struct net_bridge *br)\r\n{\r\nstruct rtable *rt = &br->fake_rtable;\r\natomic_set(&rt->dst.__refcnt, 1);\r\nrt->dst.dev = br->dev;\r\nrt->dst.path = &rt->dst;\r\ndst_init_metrics(&rt->dst, br_dst_default_metrics, true);\r\nrt->dst.flags = DST_NOXFRM | DST_NOPEER | DST_FAKE_RTABLE;\r\nrt->dst.ops = &fake_dst_ops;\r\n}\r\nstatic inline struct rtable *bridge_parent_rtable(const struct net_device *dev)\r\n{\r\nstruct net_bridge_port *port;\r\nport = br_port_get_rcu(dev);\r\nreturn port ? &port->br->fake_rtable : NULL;\r\n}\r\nstatic inline struct net_device *bridge_parent(const struct net_device *dev)\r\n{\r\nstruct net_bridge_port *port;\r\nport = br_port_get_rcu(dev);\r\nreturn port ? port->br->dev : NULL;\r\n}\r\nstatic inline struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)\r\n{\r\nskb->nf_bridge = kzalloc(sizeof(struct nf_bridge_info), GFP_ATOMIC);\r\nif (likely(skb->nf_bridge))\r\natomic_set(&(skb->nf_bridge->use), 1);\r\nreturn skb->nf_bridge;\r\n}\r\nstatic inline struct nf_bridge_info *nf_bridge_unshare(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nif (atomic_read(&nf_bridge->use) > 1) {\r\nstruct nf_bridge_info *tmp = nf_bridge_alloc(skb);\r\nif (tmp) {\r\nmemcpy(tmp, nf_bridge, sizeof(struct nf_bridge_info));\r\natomic_set(&tmp->use, 1);\r\n}\r\nnf_bridge_put(nf_bridge);\r\nnf_bridge = tmp;\r\n}\r\nreturn nf_bridge;\r\n}\r\nstatic inline void nf_bridge_push_encap_header(struct sk_buff *skb)\r\n{\r\nunsigned int len = nf_bridge_encap_header_len(skb);\r\nskb_push(skb, len);\r\nskb->network_header -= len;\r\n}\r\nstatic inline void nf_bridge_pull_encap_header(struct sk_buff *skb)\r\n{\r\nunsigned int len = nf_bridge_encap_header_len(skb);\r\nskb_pull(skb, len);\r\nskb->network_header += len;\r\n}\r\nstatic inline void nf_bridge_pull_encap_header_rcsum(struct sk_buff *skb)\r\n{\r\nunsigned int len = nf_bridge_encap_header_len(skb);\r\nskb_pull_rcsum(skb, len);\r\nskb->network_header += len;\r\n}\r\nstatic inline void nf_bridge_save_header(struct sk_buff *skb)\r\n{\r\nint header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);\r\nskb_copy_from_linear_data_offset(skb, -header_size,\r\nskb->nf_bridge->data, header_size);\r\n}\r\nstatic inline void nf_bridge_update_protocol(struct sk_buff *skb)\r\n{\r\nif (skb->nf_bridge->mask & BRNF_8021Q)\r\nskb->protocol = htons(ETH_P_8021Q);\r\nelse if (skb->nf_bridge->mask & BRNF_PPPoE)\r\nskb->protocol = htons(ETH_P_PPP_SES);\r\n}\r\nstatic int br_parse_ip_options(struct sk_buff *skb)\r\n{\r\nstruct ip_options *opt;\r\nconst struct iphdr *iph;\r\nstruct net_device *dev = skb->dev;\r\nu32 len;\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\ngoto inhdr_error;\r\niph = ip_hdr(skb);\r\nopt = &(IPCB(skb)->opt);\r\nif (iph->ihl < 5 || iph->version != 4)\r\ngoto inhdr_error;\r\nif (!pskb_may_pull(skb, iph->ihl*4))\r\ngoto inhdr_error;\r\niph = ip_hdr(skb);\r\nif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\r\ngoto inhdr_error;\r\nlen = ntohs(iph->tot_len);\r\nif (skb->len < len) {\r\nIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\r\ngoto drop;\r\n} else if (len < (iph->ihl*4))\r\ngoto inhdr_error;\r\nif (pskb_trim_rcsum(skb, len)) {\r\nIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\r\ngoto drop;\r\n}\r\nmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\r\nif (iph->ihl == 5)\r\nreturn 0;\r\nopt->optlen = iph->ihl*4 - sizeof(struct iphdr);\r\nif (ip_options_compile(dev_net(dev), opt, skb))\r\ngoto inhdr_error;\r\nif (unlikely(opt->srr)) {\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\r\ngoto drop;\r\nif (ip_options_rcv_srr(skb))\r\ngoto drop;\r\n}\r\nreturn 0;\r\ninhdr_error:\r\nIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\r\ndrop:\r\nreturn -1;\r\n}\r\nint nf_bridge_copy_header(struct sk_buff *skb)\r\n{\r\nint err;\r\nunsigned int header_size;\r\nnf_bridge_update_protocol(skb);\r\nheader_size = ETH_HLEN + nf_bridge_encap_header_len(skb);\r\nerr = skb_cow_head(skb, header_size);\r\nif (err)\r\nreturn err;\r\nskb_copy_to_linear_data_offset(skb, -header_size,\r\nskb->nf_bridge->data, header_size);\r\n__skb_push(skb, nf_bridge_encap_header_len(skb));\r\nreturn 0;\r\n}\r\nstatic int br_nf_pre_routing_finish_ipv6(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nstruct rtable *rt;\r\nif (nf_bridge->mask & BRNF_PKT_TYPE) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nnf_bridge->mask ^= BRNF_PKT_TYPE;\r\n}\r\nnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\r\nrt = bridge_parent_rtable(nf_bridge->physindev);\r\nif (!rt) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb_dst_set_noref(skb, &rt->dst);\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\r\nbr_handle_frame_finish, 1);\r\nreturn 0;\r\n}\r\nstatic int br_nf_pre_routing_finish_bridge(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nstruct neighbour *neigh;\r\nstruct dst_entry *dst;\r\nskb->dev = bridge_parent(skb->dev);\r\nif (!skb->dev)\r\ngoto free_skb;\r\ndst = skb_dst(skb);\r\nneigh = dst_neigh_lookup_skb(dst, skb);\r\nif (neigh) {\r\nint ret;\r\nif (neigh->hh.hh_len) {\r\nneigh_hh_bridge(&neigh->hh, skb);\r\nskb->dev = nf_bridge->physindev;\r\nret = br_handle_frame_finish(skb);\r\n} else {\r\nskb_copy_from_linear_data_offset(skb,\r\n-(ETH_HLEN-ETH_ALEN),\r\nskb->nf_bridge->data,\r\nETH_HLEN-ETH_ALEN);\r\nnf_bridge->mask |= BRNF_BRIDGED_DNAT;\r\nret = neigh->output(neigh, skb);\r\n}\r\nneigh_release(neigh);\r\nreturn ret;\r\n}\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int br_nf_pre_routing_finish(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nstruct rtable *rt;\r\nint err;\r\nif (nf_bridge->mask & BRNF_PKT_TYPE) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nnf_bridge->mask ^= BRNF_PKT_TYPE;\r\n}\r\nnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\r\nif (dnat_took_place(skb)) {\r\nif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\r\ngoto free_skb;\r\nrt = ip_route_output(dev_net(dev), iph->daddr, 0,\r\nRT_TOS(iph->tos), 0);\r\nif (!IS_ERR(rt)) {\r\nif (rt->dst.dev == dev) {\r\nskb_dst_set(skb, &rt->dst);\r\ngoto bridged_dnat;\r\n}\r\nip_rt_put(rt);\r\n}\r\nfree_skb:\r\nkfree_skb(skb);\r\nreturn 0;\r\n} else {\r\nif (skb_dst(skb)->dev == dev) {\r\nbridged_dnat:\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE,\r\nNF_BR_PRE_ROUTING,\r\nskb, skb->dev, NULL,\r\nbr_nf_pre_routing_finish_bridge,\r\n1);\r\nreturn 0;\r\n}\r\nmemcpy(eth_hdr(skb)->h_dest, dev->dev_addr, ETH_ALEN);\r\nskb->pkt_type = PACKET_HOST;\r\n}\r\n} else {\r\nrt = bridge_parent_rtable(nf_bridge->physindev);\r\nif (!rt) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb_dst_set_noref(skb, &rt->dst);\r\n}\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\r\nbr_handle_frame_finish, 1);\r\nreturn 0;\r\n}\r\nstatic struct net_device *brnf_get_logical_dev(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct net_device *vlan, *br;\r\nbr = bridge_parent(dev);\r\nif (brnf_pass_vlan_indev == 0 || !vlan_tx_tag_present(skb))\r\nreturn br;\r\nvlan = __vlan_find_dev_deep(br, skb->vlan_proto,\r\nvlan_tx_tag_get(skb) & VLAN_VID_MASK);\r\nreturn vlan ? vlan : br;\r\n}\r\nstatic struct net_device *setup_pre_routing(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nskb->pkt_type = PACKET_HOST;\r\nnf_bridge->mask |= BRNF_PKT_TYPE;\r\n}\r\nnf_bridge->mask |= BRNF_NF_BRIDGE_PREROUTING;\r\nnf_bridge->physindev = skb->dev;\r\nskb->dev = brnf_get_logical_dev(skb, skb->dev);\r\nif (skb->protocol == htons(ETH_P_8021Q))\r\nnf_bridge->mask |= BRNF_8021Q;\r\nelse if (skb->protocol == htons(ETH_P_PPP_SES))\r\nnf_bridge->mask |= BRNF_PPPoE;\r\nreturn skb->dev;\r\n}\r\nstatic int check_hbh_len(struct sk_buff *skb)\r\n{\r\nunsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);\r\nu32 pkt_len;\r\nconst unsigned char *nh = skb_network_header(skb);\r\nint off = raw - nh;\r\nint len = (raw[1] + 1) << 3;\r\nif ((raw + len) - skb->data > skb_headlen(skb))\r\ngoto bad;\r\noff += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nint optlen = nh[off + 1] + 2;\r\nswitch (nh[off]) {\r\ncase IPV6_TLV_PAD1:\r\noptlen = 1;\r\nbreak;\r\ncase IPV6_TLV_PADN:\r\nbreak;\r\ncase IPV6_TLV_JUMBO:\r\nif (nh[off + 1] != 4 || (off & 3) != 2)\r\ngoto bad;\r\npkt_len = ntohl(*(__be32 *) (nh + off + 2));\r\nif (pkt_len <= IPV6_MAXPLEN ||\r\nipv6_hdr(skb)->payload_len)\r\ngoto bad;\r\nif (pkt_len > skb->len - sizeof(struct ipv6hdr))\r\ngoto bad;\r\nif (pskb_trim_rcsum(skb,\r\npkt_len + sizeof(struct ipv6hdr)))\r\ngoto bad;\r\nnh = skb_network_header(skb);\r\nbreak;\r\ndefault:\r\nif (optlen > len)\r\ngoto bad;\r\nbreak;\r\n}\r\noff += optlen;\r\nlen -= optlen;\r\n}\r\nif (len == 0)\r\nreturn 0;\r\nbad:\r\nreturn -1;\r\n}\r\nstatic unsigned int br_nf_pre_routing_ipv6(unsigned int hook,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nconst struct ipv6hdr *hdr;\r\nu32 pkt_len;\r\nif (skb->len < sizeof(struct ipv6hdr))\r\nreturn NF_DROP;\r\nif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\r\nreturn NF_DROP;\r\nhdr = ipv6_hdr(skb);\r\nif (hdr->version != 6)\r\nreturn NF_DROP;\r\npkt_len = ntohs(hdr->payload_len);\r\nif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\r\nif (pkt_len + sizeof(struct ipv6hdr) > skb->len)\r\nreturn NF_DROP;\r\nif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\r\nreturn NF_DROP;\r\n}\r\nif (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))\r\nreturn NF_DROP;\r\nnf_bridge_put(skb->nf_bridge);\r\nif (!nf_bridge_alloc(skb))\r\nreturn NF_DROP;\r\nif (!setup_pre_routing(skb))\r\nreturn NF_DROP;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\r\nbr_nf_pre_routing_finish_ipv6);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int br_nf_pre_routing(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct net_bridge_port *p;\r\nstruct net_bridge *br;\r\n__u32 len = nf_bridge_encap_header_len(skb);\r\nif (unlikely(!pskb_may_pull(skb, len)))\r\nreturn NF_DROP;\r\np = br_port_get_rcu(in);\r\nif (p == NULL)\r\nreturn NF_DROP;\r\nbr = p->br;\r\nif (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb)) {\r\nif (!brnf_call_ip6tables && !br->nf_call_ip6tables)\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header_rcsum(skb);\r\nreturn br_nf_pre_routing_ipv6(hook, skb, in, out, okfn);\r\n}\r\nif (!brnf_call_iptables && !br->nf_call_iptables)\r\nreturn NF_ACCEPT;\r\nif (!IS_IP(skb) && !IS_VLAN_IP(skb) && !IS_PPPOE_IP(skb))\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header_rcsum(skb);\r\nif (br_parse_ip_options(skb))\r\nreturn NF_DROP;\r\nnf_bridge_put(skb->nf_bridge);\r\nif (!nf_bridge_alloc(skb))\r\nreturn NF_DROP;\r\nif (!setup_pre_routing(skb))\r\nreturn NF_DROP;\r\nstore_orig_dstaddr(skb);\r\nskb->protocol = htons(ETH_P_IP);\r\nNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, skb->dev, NULL,\r\nbr_nf_pre_routing_finish);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int br_nf_local_in(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nbr_drop_fake_rtable(skb);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int br_nf_forward_finish(struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nstruct net_device *in;\r\nif (!IS_ARP(skb) && !IS_VLAN_ARP(skb)) {\r\nin = nf_bridge->physindev;\r\nif (nf_bridge->mask & BRNF_PKT_TYPE) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nnf_bridge->mask ^= BRNF_PKT_TYPE;\r\n}\r\nnf_bridge_update_protocol(skb);\r\n} else {\r\nin = *((struct net_device **)(skb->cb));\r\n}\r\nnf_bridge_push_encap_header(skb);\r\nNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, in,\r\nskb->dev, br_forward_finish, 1);\r\nreturn 0;\r\n}\r\nstatic unsigned int br_nf_forward_ip(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_bridge_info *nf_bridge;\r\nstruct net_device *parent;\r\nu_int8_t pf;\r\nif (!skb->nf_bridge)\r\nreturn NF_ACCEPT;\r\nif (!nf_bridge_unshare(skb))\r\nreturn NF_DROP;\r\nparent = bridge_parent(out);\r\nif (!parent)\r\nreturn NF_DROP;\r\nif (IS_IP(skb) || IS_VLAN_IP(skb) || IS_PPPOE_IP(skb))\r\npf = NFPROTO_IPV4;\r\nelse if (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb))\r\npf = NFPROTO_IPV6;\r\nelse\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header(skb);\r\nnf_bridge = skb->nf_bridge;\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nskb->pkt_type = PACKET_HOST;\r\nnf_bridge->mask |= BRNF_PKT_TYPE;\r\n}\r\nif (pf == NFPROTO_IPV4 && br_parse_ip_options(skb))\r\nreturn NF_DROP;\r\nnf_bridge->mask |= BRNF_BRIDGED;\r\nnf_bridge->physoutdev = skb->dev;\r\nif (pf == NFPROTO_IPV4)\r\nskb->protocol = htons(ETH_P_IP);\r\nelse\r\nskb->protocol = htons(ETH_P_IPV6);\r\nNF_HOOK(pf, NF_INET_FORWARD, skb, brnf_get_logical_dev(skb, in), parent,\r\nbr_nf_forward_finish);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int br_nf_forward_arp(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct net_bridge_port *p;\r\nstruct net_bridge *br;\r\nstruct net_device **d = (struct net_device **)(skb->cb);\r\np = br_port_get_rcu(out);\r\nif (p == NULL)\r\nreturn NF_ACCEPT;\r\nbr = p->br;\r\nif (!brnf_call_arptables && !br->nf_call_arptables)\r\nreturn NF_ACCEPT;\r\nif (!IS_ARP(skb)) {\r\nif (!IS_VLAN_ARP(skb))\r\nreturn NF_ACCEPT;\r\nnf_bridge_pull_encap_header(skb);\r\n}\r\nif (arp_hdr(skb)->ar_pln != 4) {\r\nif (IS_VLAN_ARP(skb))\r\nnf_bridge_push_encap_header(skb);\r\nreturn NF_ACCEPT;\r\n}\r\n*d = (struct net_device *)in;\r\nNF_HOOK(NFPROTO_ARP, NF_ARP_FORWARD, skb, (struct net_device *)in,\r\n(struct net_device *)out, br_nf_forward_finish);\r\nreturn NF_STOLEN;\r\n}\r\nstatic int br_nf_dev_queue_xmit(struct sk_buff *skb)\r\n{\r\nint ret;\r\nif (skb->nfct != NULL && skb->protocol == htons(ETH_P_IP) &&\r\nskb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&\r\n!skb_is_gso(skb)) {\r\nif (br_parse_ip_options(skb))\r\nreturn NF_DROP;\r\nret = ip_fragment(skb, br_dev_queue_push_xmit);\r\n} else\r\nret = br_dev_queue_push_xmit(skb);\r\nreturn ret;\r\n}\r\nstatic int br_nf_dev_queue_xmit(struct sk_buff *skb)\r\n{\r\nreturn br_dev_queue_push_xmit(skb);\r\n}\r\nstatic unsigned int br_nf_post_routing(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\r\nstruct net_device *realoutdev = bridge_parent(skb->dev);\r\nu_int8_t pf;\r\nif (!nf_bridge || !(nf_bridge->mask & BRNF_BRIDGED))\r\nreturn NF_ACCEPT;\r\nif (!realoutdev)\r\nreturn NF_DROP;\r\nif (IS_IP(skb) || IS_VLAN_IP(skb) || IS_PPPOE_IP(skb))\r\npf = NFPROTO_IPV4;\r\nelse if (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb))\r\npf = NFPROTO_IPV6;\r\nelse\r\nreturn NF_ACCEPT;\r\nif (skb->pkt_type == PACKET_OTHERHOST) {\r\nskb->pkt_type = PACKET_HOST;\r\nnf_bridge->mask |= BRNF_PKT_TYPE;\r\n}\r\nnf_bridge_pull_encap_header(skb);\r\nnf_bridge_save_header(skb);\r\nif (pf == NFPROTO_IPV4)\r\nskb->protocol = htons(ETH_P_IP);\r\nelse\r\nskb->protocol = htons(ETH_P_IPV6);\r\nNF_HOOK(pf, NF_INET_POST_ROUTING, skb, NULL, realoutdev,\r\nbr_nf_dev_queue_xmit);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int ip_sabotage_in(unsigned int hook, struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nif (skb->nf_bridge &&\r\n!(skb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)) {\r\nreturn NF_STOP;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic\r\nint brnf_sysctl_call_tables(struct ctl_table *ctl, int write,\r\nvoid __user * buffer, size_t * lenp, loff_t * ppos)\r\n{\r\nint ret;\r\nret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nif (write && *(int *)(ctl->data))\r\n*(int *)(ctl->data) = 1;\r\nreturn ret;\r\n}\r\nint __init br_netfilter_init(void)\r\n{\r\nint ret;\r\nret = dst_entries_init(&fake_dst_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nret = nf_register_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\r\nif (ret < 0) {\r\ndst_entries_destroy(&fake_dst_ops);\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_SYSCTL\r\nbrnf_sysctl_header = register_net_sysctl(&init_net, "net/bridge", brnf_table);\r\nif (brnf_sysctl_header == NULL) {\r\nprintk(KERN_WARNING\r\n"br_netfilter: can't register to sysctl.\n");\r\nnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\r\ndst_entries_destroy(&fake_dst_ops);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nprintk(KERN_NOTICE "Bridge firewalling registered\n");\r\nreturn 0;\r\n}\r\nvoid br_netfilter_fini(void)\r\n{\r\nnf_unregister_hooks(br_nf_ops, ARRAY_SIZE(br_nf_ops));\r\n#ifdef CONFIG_SYSCTL\r\nunregister_net_sysctl_table(brnf_sysctl_header);\r\n#endif\r\ndst_entries_destroy(&fake_dst_ops);\r\n}
