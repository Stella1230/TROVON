static int regcache_lzo_block_count(struct regmap *map)\r\n{\r\nreturn LZO_BLOCK_NUM;\r\n}\r\nstatic int regcache_lzo_prepare(struct regcache_lzo_ctx *lzo_ctx)\r\n{\r\nlzo_ctx->wmem = kmalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);\r\nif (!lzo_ctx->wmem)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int regcache_lzo_compress(struct regcache_lzo_ctx *lzo_ctx)\r\n{\r\nsize_t compress_size;\r\nint ret;\r\nret = lzo1x_1_compress(lzo_ctx->src, lzo_ctx->src_len,\r\nlzo_ctx->dst, &compress_size, lzo_ctx->wmem);\r\nif (ret != LZO_E_OK || compress_size > lzo_ctx->dst_len)\r\nreturn -EINVAL;\r\nlzo_ctx->dst_len = compress_size;\r\nreturn 0;\r\n}\r\nstatic int regcache_lzo_decompress(struct regcache_lzo_ctx *lzo_ctx)\r\n{\r\nsize_t dst_len;\r\nint ret;\r\ndst_len = lzo_ctx->dst_len;\r\nret = lzo1x_decompress_safe(lzo_ctx->src, lzo_ctx->src_len,\r\nlzo_ctx->dst, &dst_len);\r\nif (ret != LZO_E_OK || dst_len != lzo_ctx->dst_len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int regcache_lzo_compress_cache_block(struct regmap *map,\r\nstruct regcache_lzo_ctx *lzo_ctx)\r\n{\r\nint ret;\r\nlzo_ctx->dst_len = lzo1x_worst_compress(PAGE_SIZE);\r\nlzo_ctx->dst = kmalloc(lzo_ctx->dst_len, GFP_KERNEL);\r\nif (!lzo_ctx->dst) {\r\nlzo_ctx->dst_len = 0;\r\nreturn -ENOMEM;\r\n}\r\nret = regcache_lzo_compress(lzo_ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int regcache_lzo_decompress_cache_block(struct regmap *map,\r\nstruct regcache_lzo_ctx *lzo_ctx)\r\n{\r\nint ret;\r\nlzo_ctx->dst_len = lzo_ctx->decompressed_size;\r\nlzo_ctx->dst = kmalloc(lzo_ctx->dst_len, GFP_KERNEL);\r\nif (!lzo_ctx->dst) {\r\nlzo_ctx->dst_len = 0;\r\nreturn -ENOMEM;\r\n}\r\nret = regcache_lzo_decompress(lzo_ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic inline int regcache_lzo_get_blkindex(struct regmap *map,\r\nunsigned int reg)\r\n{\r\nreturn ((reg / map->reg_stride) * map->cache_word_size) /\r\nDIV_ROUND_UP(map->cache_size_raw,\r\nregcache_lzo_block_count(map));\r\n}\r\nstatic inline int regcache_lzo_get_blkpos(struct regmap *map,\r\nunsigned int reg)\r\n{\r\nreturn (reg / map->reg_stride) %\r\n(DIV_ROUND_UP(map->cache_size_raw,\r\nregcache_lzo_block_count(map)) /\r\nmap->cache_word_size);\r\n}\r\nstatic inline int regcache_lzo_get_blksize(struct regmap *map)\r\n{\r\nreturn DIV_ROUND_UP(map->cache_size_raw,\r\nregcache_lzo_block_count(map));\r\n}\r\nstatic int regcache_lzo_init(struct regmap *map)\r\n{\r\nstruct regcache_lzo_ctx **lzo_blocks;\r\nsize_t bmp_size;\r\nint ret, i, blksize, blkcount;\r\nconst char *p, *end;\r\nunsigned long *sync_bmp;\r\nret = 0;\r\nblkcount = regcache_lzo_block_count(map);\r\nmap->cache = kzalloc(blkcount * sizeof *lzo_blocks,\r\nGFP_KERNEL);\r\nif (!map->cache)\r\nreturn -ENOMEM;\r\nlzo_blocks = map->cache;\r\nbmp_size = map->num_reg_defaults_raw;\r\nsync_bmp = kmalloc(BITS_TO_LONGS(bmp_size) * sizeof(long),\r\nGFP_KERNEL);\r\nif (!sync_bmp) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nbitmap_zero(sync_bmp, bmp_size);\r\nfor (i = 0; i < blkcount; i++) {\r\nlzo_blocks[i] = kzalloc(sizeof **lzo_blocks,\r\nGFP_KERNEL);\r\nif (!lzo_blocks[i]) {\r\nkfree(sync_bmp);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nlzo_blocks[i]->sync_bmp = sync_bmp;\r\nlzo_blocks[i]->sync_bmp_nbits = bmp_size;\r\nret = regcache_lzo_prepare(lzo_blocks[i]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nblksize = regcache_lzo_get_blksize(map);\r\np = map->reg_defaults_raw;\r\nend = map->reg_defaults_raw + map->cache_size_raw;\r\nfor (i = 0; i < blkcount; i++, p += blksize) {\r\nlzo_blocks[i]->src = p;\r\nif (p + blksize > end)\r\nlzo_blocks[i]->src_len = end - p;\r\nelse\r\nlzo_blocks[i]->src_len = blksize;\r\nret = regcache_lzo_compress_cache_block(map,\r\nlzo_blocks[i]);\r\nif (ret < 0)\r\ngoto err;\r\nlzo_blocks[i]->decompressed_size =\r\nlzo_blocks[i]->src_len;\r\n}\r\nreturn 0;\r\nerr:\r\nregcache_lzo_exit(map);\r\nreturn ret;\r\n}\r\nstatic int regcache_lzo_exit(struct regmap *map)\r\n{\r\nstruct regcache_lzo_ctx **lzo_blocks;\r\nint i, blkcount;\r\nlzo_blocks = map->cache;\r\nif (!lzo_blocks)\r\nreturn 0;\r\nblkcount = regcache_lzo_block_count(map);\r\nif (lzo_blocks[0])\r\nkfree(lzo_blocks[0]->sync_bmp);\r\nfor (i = 0; i < blkcount; i++) {\r\nif (lzo_blocks[i]) {\r\nkfree(lzo_blocks[i]->wmem);\r\nkfree(lzo_blocks[i]->dst);\r\n}\r\nkfree(lzo_blocks[i]);\r\n}\r\nkfree(lzo_blocks);\r\nmap->cache = NULL;\r\nreturn 0;\r\n}\r\nstatic int regcache_lzo_read(struct regmap *map,\r\nunsigned int reg, unsigned int *value)\r\n{\r\nstruct regcache_lzo_ctx *lzo_block, **lzo_blocks;\r\nint ret, blkindex, blkpos;\r\nsize_t blksize, tmp_dst_len;\r\nvoid *tmp_dst;\r\nblkindex = regcache_lzo_get_blkindex(map, reg);\r\nblkpos = regcache_lzo_get_blkpos(map, reg);\r\nblksize = regcache_lzo_get_blksize(map);\r\nlzo_blocks = map->cache;\r\nlzo_block = lzo_blocks[blkindex];\r\ntmp_dst = lzo_block->dst;\r\ntmp_dst_len = lzo_block->dst_len;\r\nlzo_block->src = lzo_block->dst;\r\nlzo_block->src_len = lzo_block->dst_len;\r\nret = regcache_lzo_decompress_cache_block(map, lzo_block);\r\nif (ret >= 0)\r\n*value = regcache_get_val(map, lzo_block->dst, blkpos);\r\nkfree(lzo_block->dst);\r\nlzo_block->dst = tmp_dst;\r\nlzo_block->dst_len = tmp_dst_len;\r\nreturn ret;\r\n}\r\nstatic int regcache_lzo_write(struct regmap *map,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct regcache_lzo_ctx *lzo_block, **lzo_blocks;\r\nint ret, blkindex, blkpos;\r\nsize_t blksize, tmp_dst_len;\r\nvoid *tmp_dst;\r\nblkindex = regcache_lzo_get_blkindex(map, reg);\r\nblkpos = regcache_lzo_get_blkpos(map, reg);\r\nblksize = regcache_lzo_get_blksize(map);\r\nlzo_blocks = map->cache;\r\nlzo_block = lzo_blocks[blkindex];\r\ntmp_dst = lzo_block->dst;\r\ntmp_dst_len = lzo_block->dst_len;\r\nlzo_block->src = lzo_block->dst;\r\nlzo_block->src_len = lzo_block->dst_len;\r\nret = regcache_lzo_decompress_cache_block(map, lzo_block);\r\nif (ret < 0) {\r\nkfree(lzo_block->dst);\r\ngoto out;\r\n}\r\nif (regcache_set_val(map, lzo_block->dst, blkpos, value)) {\r\nkfree(lzo_block->dst);\r\ngoto out;\r\n}\r\nlzo_block->src = lzo_block->dst;\r\nlzo_block->src_len = lzo_block->dst_len;\r\nret = regcache_lzo_compress_cache_block(map, lzo_block);\r\nif (ret < 0) {\r\nkfree(lzo_block->dst);\r\nkfree(lzo_block->src);\r\ngoto out;\r\n}\r\nset_bit(reg / map->reg_stride, lzo_block->sync_bmp);\r\nkfree(tmp_dst);\r\nkfree(lzo_block->src);\r\nreturn 0;\r\nout:\r\nlzo_block->dst = tmp_dst;\r\nlzo_block->dst_len = tmp_dst_len;\r\nreturn ret;\r\n}\r\nstatic int regcache_lzo_sync(struct regmap *map, unsigned int min,\r\nunsigned int max)\r\n{\r\nstruct regcache_lzo_ctx **lzo_blocks;\r\nunsigned int val;\r\nint i;\r\nint ret;\r\nlzo_blocks = map->cache;\r\ni = min;\r\nfor_each_set_bit_from(i, lzo_blocks[0]->sync_bmp,\r\nlzo_blocks[0]->sync_bmp_nbits) {\r\nif (i > max)\r\ncontinue;\r\nret = regcache_read(map, i, &val);\r\nif (ret)\r\nreturn ret;\r\nret = regcache_lookup_reg(map, i);\r\nif (ret > 0 && val == map->reg_defaults[ret].def)\r\ncontinue;\r\nmap->cache_bypass = 1;\r\nret = _regmap_write(map, i, val);\r\nmap->cache_bypass = 0;\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(map->dev, "Synced register %#x, value %#x\n",\r\ni, val);\r\n}\r\nreturn 0;\r\n}
