uint32_t udf_get_pblock(struct super_block *sb, uint32_t block,\r\nuint16_t partition, uint32_t offset)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct udf_part_map *map;\r\nif (partition >= sbi->s_partitions) {\r\nudf_debug("block=%d, partition=%d, offset=%d: invalid partition\n",\r\nblock, partition, offset);\r\nreturn 0xFFFFFFFF;\r\n}\r\nmap = &sbi->s_partmaps[partition];\r\nif (map->s_partition_func)\r\nreturn map->s_partition_func(sb, block, partition, offset);\r\nelse\r\nreturn map->s_partition_root + block + offset;\r\n}\r\nuint32_t udf_get_pblock_virt15(struct super_block *sb, uint32_t block,\r\nuint16_t partition, uint32_t offset)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nuint32_t newblock;\r\nuint32_t index;\r\nuint32_t loc;\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct udf_part_map *map;\r\nstruct udf_virtual_data *vdata;\r\nstruct udf_inode_info *iinfo = UDF_I(sbi->s_vat_inode);\r\nmap = &sbi->s_partmaps[partition];\r\nvdata = &map->s_type_specific.s_virtual;\r\nif (block > vdata->s_num_entries) {\r\nudf_debug("Trying to access block beyond end of VAT (%d max %d)\n",\r\nblock, vdata->s_num_entries);\r\nreturn 0xFFFFFFFF;\r\n}\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\r\nloc = le32_to_cpu(((__le32 *)(iinfo->i_ext.i_data +\r\nvdata->s_start_offset))[block]);\r\ngoto translate;\r\n}\r\nindex = (sb->s_blocksize - vdata->s_start_offset) / sizeof(uint32_t);\r\nif (block >= index) {\r\nblock -= index;\r\nnewblock = 1 + (block / (sb->s_blocksize / sizeof(uint32_t)));\r\nindex = block % (sb->s_blocksize / sizeof(uint32_t));\r\n} else {\r\nnewblock = 0;\r\nindex = vdata->s_start_offset / sizeof(uint32_t) + block;\r\n}\r\nloc = udf_block_map(sbi->s_vat_inode, newblock);\r\nbh = sb_bread(sb, loc);\r\nif (!bh) {\r\nudf_debug("get_pblock(UDF_VIRTUAL_MAP:%p,%d,%d) VAT: %d[%d]\n",\r\nsb, block, partition, loc, index);\r\nreturn 0xFFFFFFFF;\r\n}\r\nloc = le32_to_cpu(((__le32 *)bh->b_data)[index]);\r\nbrelse(bh);\r\ntranslate:\r\nif (iinfo->i_location.partitionReferenceNum == partition) {\r\nudf_debug("recursive call to udf_get_pblock!\n");\r\nreturn 0xFFFFFFFF;\r\n}\r\nreturn udf_get_pblock(sb, loc,\r\niinfo->i_location.partitionReferenceNum,\r\noffset);\r\n}\r\ninline uint32_t udf_get_pblock_virt20(struct super_block *sb, uint32_t block,\r\nuint16_t partition, uint32_t offset)\r\n{\r\nreturn udf_get_pblock_virt15(sb, block, partition, offset);\r\n}\r\nuint32_t udf_get_pblock_spar15(struct super_block *sb, uint32_t block,\r\nuint16_t partition, uint32_t offset)\r\n{\r\nint i;\r\nstruct sparingTable *st = NULL;\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct udf_part_map *map;\r\nuint32_t packet;\r\nstruct udf_sparing_data *sdata;\r\nmap = &sbi->s_partmaps[partition];\r\nsdata = &map->s_type_specific.s_sparing;\r\npacket = (block + offset) & ~(sdata->s_packet_len - 1);\r\nfor (i = 0; i < 4; i++) {\r\nif (sdata->s_spar_map[i] != NULL) {\r\nst = (struct sparingTable *)\r\nsdata->s_spar_map[i]->b_data;\r\nbreak;\r\n}\r\n}\r\nif (st) {\r\nfor (i = 0; i < le16_to_cpu(st->reallocationTableLen); i++) {\r\nstruct sparingEntry *entry = &st->mapEntry[i];\r\nu32 origLoc = le32_to_cpu(entry->origLocation);\r\nif (origLoc >= 0xFFFFFFF0)\r\nbreak;\r\nelse if (origLoc == packet)\r\nreturn le32_to_cpu(entry->mappedLocation) +\r\n((block + offset) &\r\n(sdata->s_packet_len - 1));\r\nelse if (origLoc > packet)\r\nbreak;\r\n}\r\n}\r\nreturn map->s_partition_root + block + offset;\r\n}\r\nint udf_relocate_blocks(struct super_block *sb, long old_block, long *new_block)\r\n{\r\nstruct udf_sparing_data *sdata;\r\nstruct sparingTable *st = NULL;\r\nstruct sparingEntry mapEntry;\r\nuint32_t packet;\r\nint i, j, k, l;\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nu16 reallocationTableLen;\r\nstruct buffer_head *bh;\r\nint ret = 0;\r\nmutex_lock(&sbi->s_alloc_mutex);\r\nfor (i = 0; i < sbi->s_partitions; i++) {\r\nstruct udf_part_map *map = &sbi->s_partmaps[i];\r\nif (old_block > map->s_partition_root &&\r\nold_block < map->s_partition_root + map->s_partition_len) {\r\nsdata = &map->s_type_specific.s_sparing;\r\npacket = (old_block - map->s_partition_root) &\r\n~(sdata->s_packet_len - 1);\r\nfor (j = 0; j < 4; j++)\r\nif (sdata->s_spar_map[j] != NULL) {\r\nst = (struct sparingTable *)\r\nsdata->s_spar_map[j]->b_data;\r\nbreak;\r\n}\r\nif (!st) {\r\nret = 1;\r\ngoto out;\r\n}\r\nreallocationTableLen =\r\nle16_to_cpu(st->reallocationTableLen);\r\nfor (k = 0; k < reallocationTableLen; k++) {\r\nstruct sparingEntry *entry = &st->mapEntry[k];\r\nu32 origLoc = le32_to_cpu(entry->origLocation);\r\nif (origLoc == 0xFFFFFFFF) {\r\nfor (; j < 4; j++) {\r\nint len;\r\nbh = sdata->s_spar_map[j];\r\nif (!bh)\r\ncontinue;\r\nst = (struct sparingTable *)\r\nbh->b_data;\r\nentry->origLocation =\r\ncpu_to_le32(packet);\r\nlen =\r\nsizeof(struct sparingTable) +\r\nreallocationTableLen *\r\nsizeof(struct sparingEntry);\r\nudf_update_tag((char *)st, len);\r\nmark_buffer_dirty(bh);\r\n}\r\n*new_block = le32_to_cpu(\r\nentry->mappedLocation) +\r\n((old_block -\r\nmap->s_partition_root) &\r\n(sdata->s_packet_len - 1));\r\nret = 0;\r\ngoto out;\r\n} else if (origLoc == packet) {\r\n*new_block = le32_to_cpu(\r\nentry->mappedLocation) +\r\n((old_block -\r\nmap->s_partition_root) &\r\n(sdata->s_packet_len - 1));\r\nret = 0;\r\ngoto out;\r\n} else if (origLoc > packet)\r\nbreak;\r\n}\r\nfor (l = k; l < reallocationTableLen; l++) {\r\nstruct sparingEntry *entry = &st->mapEntry[l];\r\nu32 origLoc = le32_to_cpu(entry->origLocation);\r\nif (origLoc != 0xFFFFFFFF)\r\ncontinue;\r\nfor (; j < 4; j++) {\r\nbh = sdata->s_spar_map[j];\r\nif (!bh)\r\ncontinue;\r\nst = (struct sparingTable *)bh->b_data;\r\nmapEntry = st->mapEntry[l];\r\nmapEntry.origLocation =\r\ncpu_to_le32(packet);\r\nmemmove(&st->mapEntry[k + 1],\r\n&st->mapEntry[k],\r\n(l - k) *\r\nsizeof(struct sparingEntry));\r\nst->mapEntry[k] = mapEntry;\r\nudf_update_tag((char *)st,\r\nsizeof(struct sparingTable) +\r\nreallocationTableLen *\r\nsizeof(struct sparingEntry));\r\nmark_buffer_dirty(bh);\r\n}\r\n*new_block =\r\nle32_to_cpu(\r\nst->mapEntry[k].mappedLocation) +\r\n((old_block - map->s_partition_root) &\r\n(sdata->s_packet_len - 1));\r\nret = 0;\r\ngoto out;\r\n}\r\nret = 1;\r\ngoto out;\r\n}\r\n}\r\nif (i == sbi->s_partitions) {\r\nret = 1;\r\n}\r\nout:\r\nmutex_unlock(&sbi->s_alloc_mutex);\r\nreturn ret;\r\n}\r\nstatic uint32_t udf_try_read_meta(struct inode *inode, uint32_t block,\r\nuint16_t partition, uint32_t offset)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct udf_part_map *map;\r\nstruct kernel_lb_addr eloc;\r\nuint32_t elen;\r\nsector_t ext_offset;\r\nstruct extent_position epos = {};\r\nuint32_t phyblock;\r\nif (inode_bmap(inode, block, &epos, &eloc, &elen, &ext_offset) !=\r\n(EXT_RECORDED_ALLOCATED >> 30))\r\nphyblock = 0xFFFFFFFF;\r\nelse {\r\nmap = &UDF_SB(sb)->s_partmaps[partition];\r\nphyblock = udf_get_pblock(sb, eloc.logicalBlockNum,\r\nmap->s_partition_num, ext_offset + offset);\r\n}\r\nbrelse(epos.bh);\r\nreturn phyblock;\r\n}\r\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\r\nuint16_t partition, uint32_t offset)\r\n{\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct udf_part_map *map;\r\nstruct udf_meta_data *mdata;\r\nuint32_t retblk;\r\nstruct inode *inode;\r\nudf_debug("READING from METADATA\n");\r\nmap = &sbi->s_partmaps[partition];\r\nmdata = &map->s_type_specific.s_metadata;\r\ninode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\r\nBUG_ON(!inode);\r\nretblk = udf_try_read_meta(inode, block, partition, offset);\r\nif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\r\nudf_warn(sb, "error reading from METADATA, trying to read from MIRROR\n");\r\nif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\r\nmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\r\nmdata->s_mirror_file_loc, map->s_partition_num);\r\nmdata->s_flags |= MF_MIRROR_FE_LOADED;\r\n}\r\ninode = mdata->s_mirror_fe;\r\nif (!inode)\r\nreturn 0xFFFFFFFF;\r\nretblk = udf_try_read_meta(inode, block, partition, offset);\r\n}\r\nreturn retblk;\r\n}
