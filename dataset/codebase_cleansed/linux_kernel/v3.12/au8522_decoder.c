static inline struct au8522_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct au8522_state, sd);\r\n}\r\nstatic void setup_vbi(struct au8522_state *state, int aud_input)\r\n{\r\nint i;\r\nau8522_writereg(state, AU8522_TVDEC_VBI_CTRL_H_REG017H, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_CTRL_L_REG018H, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_TOTAL_BITS_REG019H, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_TUNIT_H_REG01AH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_TUNIT_L_REG01BH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_THRESH1_REG01CH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_FRAME_PAT2_REG01EH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_FRAME_PAT1_REG01FH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_FRAME_PAT0_REG020H, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_FRAME_MASK2_REG021H,\r\n0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_FRAME_MASK1_REG022H,\r\n0x00);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_USER_FRAME_MASK0_REG023H,\r\n0x00);\r\nfor (i = 0x30; i < 0x60; i++)\r\nau8522_writereg(state, i, 0x40);\r\nau8522_writereg(state, 0x44, 0x60);\r\nau8522_writereg(state, AU8522_TVDEC_VBI_CTRL_H_REG017H,\r\nAU8522_TVDEC_VBI_CTRL_H_REG017H_CCON);\r\n}\r\nstatic void setup_decoder_defaults(struct au8522_state *state, u8 input_mode)\r\n{\r\nint i;\r\nint filter_coef_type;\r\nau8522_writereg(state, AU8522_TVDEC_SHARPNESSREG009H, 0x07);\r\nau8522_writereg(state, AU8522_TVDEC_BRIGHTNESS_REG00AH, 0xed);\r\nau8522_writereg(state, AU8522_TVDEC_CONTRAST_REG00BH, 0x79);\r\nau8522_writereg(state, AU8522_TVDEC_SATURATION_CB_REG00CH, 0x80);\r\nau8522_writereg(state, AU8522_TVDEC_SATURATION_CR_REG00DH, 0x80);\r\nau8522_writereg(state, AU8522_TVDEC_HUE_H_REG00EH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_HUE_L_REG00FH, 0x00);\r\nau8522_writereg(state, AU8522_TVDEC_INT_MASK_REG010H, 0x00);\r\nif (input_mode == 0x23) {\r\nau8522_writereg(state, AU8522_VIDEO_MODE_REG011H, 0x04);\r\n} else {\r\nau8522_writereg(state, AU8522_VIDEO_MODE_REG011H, 0x00);\r\n}\r\nau8522_writereg(state, AU8522_TVDEC_PGA_REG012H,\r\nAU8522_TVDEC_PGA_REG012H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_MODE_REG015H,\r\nAU8522_TVDEC_COMB_MODE_REG015H_CVBS);\r\nau8522_writereg(state, AU8522_TVDED_DBG_MODE_REG060H,\r\nAU8522_TVDED_DBG_MODE_REG060H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_FORMAT_CTRL1_REG061H,\r\nAU8522_TVDEC_FORMAT_CTRL1_REG061H_FIELD_LEN_525 |\r\nAU8522_TVDEC_FORMAT_CTRL1_REG061H_LINE_LEN_63_492 |\r\nAU8522_TVDEC_FORMAT_CTRL1_REG061H_SUBCARRIER_NTSC_MN);\r\nau8522_writereg(state, AU8522_TVDEC_FORMAT_CTRL2_REG062H,\r\nAU8522_TVDEC_FORMAT_CTRL2_REG062H_STD_NTSC);\r\nau8522_writereg(state, AU8522_TVDEC_VCR_DET_LLIM_REG063H,\r\nAU8522_TVDEC_VCR_DET_LLIM_REG063H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_VCR_DET_HLIM_REG064H,\r\nAU8522_TVDEC_VCR_DET_HLIM_REG064H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_VDIF_THR1_REG065H,\r\nAU8522_TVDEC_COMB_VDIF_THR1_REG065H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_VDIF_THR2_REG066H,\r\nAU8522_TVDEC_COMB_VDIF_THR2_REG066H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_VDIF_THR3_REG067H,\r\nAU8522_TVDEC_COMB_VDIF_THR3_REG067H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_NOTCH_THR_REG068H,\r\nAU8522_TVDEC_COMB_NOTCH_THR_REG068H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_HDIF_THR1_REG069H,\r\nAU8522_TVDEC_COMB_HDIF_THR1_REG069H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_HDIF_THR2_REG06AH,\r\nAU8522_TVDEC_COMB_HDIF_THR2_REG06AH_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_HDIF_THR3_REG06BH,\r\nAU8522_TVDEC_COMB_HDIF_THR3_REG06BH_CVBS);\r\nif (input_mode == AU8522_INPUT_CONTROL_REG081H_SVIDEO_CH13 ||\r\ninput_mode == AU8522_INPUT_CONTROL_REG081H_SVIDEO_CH24) {\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR1_REG06CH,\r\nAU8522_TVDEC_COMB_DCDIF_THR1_REG06CH_SVIDEO);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR2_REG06DH,\r\nAU8522_TVDEC_COMB_DCDIF_THR2_REG06DH_SVIDEO);\r\n} else {\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR1_REG06CH,\r\nAU8522_TVDEC_COMB_DCDIF_THR1_REG06CH_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR2_REG06DH,\r\nAU8522_TVDEC_COMB_DCDIF_THR2_REG06DH_CVBS);\r\n}\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DCDIF_THR3_REG06EH,\r\nAU8522_TVDEC_COMB_DCDIF_THR3_REG06EH_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_UV_SEP_THR_REG06FH,\r\nAU8522_TVDEC_UV_SEP_THR_REG06FH_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DC_THR1_NTSC_REG070H,\r\nAU8522_TVDEC_COMB_DC_THR1_NTSC_REG070H_CVBS);\r\nau8522_writereg(state, AU8522_REG071H, AU8522_REG071H_CVBS);\r\nau8522_writereg(state, AU8522_REG072H, AU8522_REG072H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_COMB_DC_THR2_NTSC_REG073H,\r\nAU8522_TVDEC_COMB_DC_THR2_NTSC_REG073H_CVBS);\r\nau8522_writereg(state, AU8522_REG074H, AU8522_REG074H_CVBS);\r\nau8522_writereg(state, AU8522_REG075H, AU8522_REG075H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_DCAGC_CTRL_REG077H,\r\nAU8522_TVDEC_DCAGC_CTRL_REG077H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_PIC_START_ADJ_REG078H,\r\nAU8522_TVDEC_PIC_START_ADJ_REG078H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_AGC_HIGH_LIMIT_REG079H,\r\nAU8522_TVDEC_AGC_HIGH_LIMIT_REG079H_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_MACROVISION_SYNC_THR_REG07AH,\r\nAU8522_TVDEC_MACROVISION_SYNC_THR_REG07AH_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_INTRP_CTRL_REG07BH,\r\nAU8522_TVDEC_INTRP_CTRL_REG07BH_CVBS);\r\nau8522_writereg(state, AU8522_TVDEC_AGC_LOW_LIMIT_REG0E4H,\r\nAU8522_TVDEC_AGC_LOW_LIMIT_REG0E4H_CVBS);\r\nau8522_writereg(state, AU8522_TOREGAAGC_REG0E5H,\r\nAU8522_TOREGAAGC_REG0E5H_CVBS);\r\nau8522_writereg(state, AU8522_REG016H, AU8522_REG016H_CVBS);\r\nsetup_vbi(state, 0);\r\nif (input_mode == AU8522_INPUT_CONTROL_REG081H_SVIDEO_CH13 ||\r\ninput_mode == AU8522_INPUT_CONTROL_REG081H_SVIDEO_CH24) {\r\nfilter_coef_type = 5;\r\n} else {\r\nfilter_coef_type = 5;\r\n}\r\nfor (i = 0; i < NUM_FILTER_COEF; i++) {\r\nau8522_writereg(state, filter_coef[i].reg_name,\r\nfilter_coef[i].reg_val[filter_coef_type]);\r\n}\r\nau8522_writereg(state, AU8522_REG42EH, 0x87);\r\nau8522_writereg(state, AU8522_REG42FH, 0xa2);\r\nau8522_writereg(state, AU8522_REG430H, 0xbf);\r\nau8522_writereg(state, AU8522_REG431H, 0xcb);\r\nau8522_writereg(state, AU8522_REG432H, 0xa1);\r\nau8522_writereg(state, AU8522_REG433H, 0x41);\r\nau8522_writereg(state, AU8522_REG434H, 0x88);\r\nau8522_writereg(state, AU8522_REG435H, 0xc2);\r\nau8522_writereg(state, AU8522_REG436H, 0x3c);\r\n}\r\nstatic void au8522_setup_cvbs_mode(struct au8522_state *state)\r\n{\r\nau8522_writereg(state, AU8522_MODULE_CLOCK_CONTROL_REG0A3H,\r\nAU8522_MODULE_CLOCK_CONTROL_REG0A3H_CVBS);\r\nau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x00);\r\nau8522_writereg(state, AU8522_CLAMPING_CONTROL_REG083H, 0x00);\r\nau8522_writereg(state, AU8522_INPUT_CONTROL_REG081H,\r\nAU8522_INPUT_CONTROL_REG081H_CVBS_CH1);\r\nsetup_decoder_defaults(state, AU8522_INPUT_CONTROL_REG081H_CVBS_CH1);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\nAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\r\n}\r\nstatic void au8522_setup_cvbs_tuner_mode(struct au8522_state *state)\r\n{\r\nau8522_writereg(state, AU8522_MODULE_CLOCK_CONTROL_REG0A3H,\r\nAU8522_MODULE_CLOCK_CONTROL_REG0A3H_CVBS);\r\nau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x00);\r\nau8522_writereg(state, AU8522_CLAMPING_CONTROL_REG083H, 0x0e);\r\nau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x10);\r\nau8522_writereg(state, AU8522_INPUT_CONTROL_REG081H,\r\nAU8522_INPUT_CONTROL_REG081H_CVBS_CH4_SIF);\r\nsetup_decoder_defaults(state,\r\nAU8522_INPUT_CONTROL_REG081H_CVBS_CH4_SIF);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\nAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\r\n}\r\nstatic void au8522_setup_svideo_mode(struct au8522_state *state)\r\n{\r\nau8522_writereg(state, AU8522_MODULE_CLOCK_CONTROL_REG0A3H,\r\nAU8522_MODULE_CLOCK_CONTROL_REG0A3H_SVIDEO);\r\nau8522_writereg(state, AU8522_INPUT_CONTROL_REG081H,\r\nAU8522_INPUT_CONTROL_REG081H_SVIDEO_CH13);\r\nau8522_writereg(state, AU8522_PGA_CONTROL_REG082H, 0x00);\r\nau8522_writereg(state, AU8522_CLAMPING_CONTROL_REG083H, 0x00);\r\nsetup_decoder_defaults(state,\r\nAU8522_INPUT_CONTROL_REG081H_SVIDEO_CH13);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\nAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\r\n}\r\nstatic void disable_audio_input(struct au8522_state *state)\r\n{\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_L_REG0F2H, 0x00);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_R_REG0F3H, 0x00);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_REG0F4H, 0x00);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_1_REG0A5H, 0x04);\r\nau8522_writereg(state, AU8522_I2S_CTRL_2_REG112H, 0x02);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\nAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_SVIDEO);\r\n}\r\nstatic void set_audio_input(struct au8522_state *state, int aud_input)\r\n{\r\nint i;\r\nif (aud_input == AU8522_AUDIO_NONE) {\r\ndisable_audio_input(state);\r\nreturn;\r\n}\r\nif (aud_input != AU8522_AUDIO_SIF) {\r\nprintk(KERN_ERR "Unsupported audio mode requested! mode=%d\n",\r\naud_input);\r\nreturn;\r\n}\r\nfor (i = 0; i < NUM_LPFILTER_COEF; i++) {\r\nau8522_writereg(state, lpfilter_coef[i].reg_name,\r\nlpfilter_coef[i].reg_val[0]);\r\n}\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_L_REG0F2H, 0x00);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_R_REG0F3H, 0x00);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_REG0F4H, 0x00);\r\nau8522_writereg(state, AU8522_I2C_CONTROL_REG1_REG091H, 0x80);\r\nau8522_writereg(state, AU8522_I2C_CONTROL_REG0_REG090H, 0x84);\r\nmsleep(150);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H, 0x00);\r\nmsleep(1);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H, 0x9d);\r\nmsleep(50);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_L_REG0F2H, 0x7F);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_R_REG0F3H, 0x7F);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_REG0F4H, 0xff);\r\nmsleep(80);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_L_REG0F2H, 0x7F);\r\nau8522_writereg(state, AU8522_AUDIO_VOLUME_R_REG0F3H, 0x7F);\r\nau8522_writereg(state, AU8522_REG0F9H, AU8522_REG0F9H_AUDIO);\r\nau8522_writereg(state, AU8522_AUDIO_MODE_REG0F1H, 0x82);\r\nmsleep(70);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_1_REG0A5H, 0x09);\r\nau8522_writereg(state, AU8522_AUDIOFREQ_REG606H, 0x03);\r\nau8522_writereg(state, AU8522_I2S_CTRL_2_REG112H, 0xc2);\r\n}\r\nstatic int au8522_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct au8522_state *state =\r\ncontainer_of(ctrl->handler, struct au8522_state, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nau8522_writereg(state, AU8522_TVDEC_BRIGHTNESS_REG00AH,\r\nctrl->val - 128);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nau8522_writereg(state, AU8522_TVDEC_CONTRAST_REG00BH,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nau8522_writereg(state, AU8522_TVDEC_SATURATION_CB_REG00CH,\r\nctrl->val);\r\nau8522_writereg(state, AU8522_TVDEC_SATURATION_CR_REG00DH,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nau8522_writereg(state, AU8522_TVDEC_HUE_H_REG00EH,\r\nctrl->val >> 8);\r\nau8522_writereg(state, AU8522_TVDEC_HUE_L_REG00FH,\r\nctrl->val & 0xFF);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int au8522_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct au8522_state *state = to_state(sd);\r\nreg->val = au8522_readreg(state, reg->reg & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int au8522_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct au8522_state *state = to_state(sd);\r\nau8522_writereg(state, reg->reg, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int au8522_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct au8522_state *state = to_state(sd);\r\nif (enable) {\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\n0x01);\r\nmsleep(1);\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\nAU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H_CVBS);\r\n} else {\r\nau8522_writereg(state, AU8522_SYSTEM_MODULE_CONTROL_0_REG0A4H,\r\n1 << 5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int au8522_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct au8522_state *state = to_state(sd);\r\nstate->operational_mode = AU8522_ANALOG_MODE;\r\nstate->current_frequency = 0;\r\nau8522_writereg(state, 0xa4, 1 << 5);\r\nreturn 0;\r\n}\r\nstatic int au8522_s_video_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct au8522_state *state = to_state(sd);\r\nau8522_reset(sd, 0);\r\nif (input == AU8522_COMPOSITE_CH1) {\r\nau8522_setup_cvbs_mode(state);\r\n} else if (input == AU8522_SVIDEO_CH13) {\r\nau8522_setup_svideo_mode(state);\r\n} else if (input == AU8522_COMPOSITE_CH4_SIF) {\r\nau8522_setup_cvbs_tuner_mode(state);\r\n} else {\r\nprintk(KERN_ERR "au8522 mode not currently supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int au8522_s_audio_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct au8522_state *state = to_state(sd);\r\nset_audio_input(state, input);\r\nreturn 0;\r\n}\r\nstatic int au8522_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nint val = 0;\r\nstruct au8522_state *state = to_state(sd);\r\nu8 lock_status;\r\nlock_status = au8522_readreg(state, 0x00);\r\nif (lock_status == 0xa2)\r\nvt->signal = 0xffff;\r\nelse\r\nvt->signal = 0x00;\r\nvt->capability |=\r\nV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2 | V4L2_TUNER_CAP_SAP;\r\nval = V4L2_TUNER_SUB_MONO;\r\nvt->rxsubchans = val;\r\nvt->audmode = V4L2_TUNER_MODE_STEREO;\r\nreturn 0;\r\n}\r\nstatic int au8522_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct au8522_state *state;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nint instance;\r\nstruct au8522_config *demod_config;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\nreturn -EIO;\r\n}\r\ninstance = au8522_get_state(&state, client->adapter, client->addr);\r\nswitch (instance) {\r\ncase 0:\r\nprintk(KERN_ERR "au8522_decoder allocation failed\n");\r\nreturn -EIO;\r\ncase 1:\r\nprintk(KERN_INFO "au8522_decoder creating new instance...\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "au8522_decoder attach existing instance.\n");\r\nbreak;\r\n}\r\ndemod_config = kzalloc(sizeof(struct au8522_config), GFP_KERNEL);\r\nif (demod_config == NULL) {\r\nif (instance == 1)\r\nkfree(state);\r\nreturn -ENOMEM;\r\n}\r\ndemod_config->demod_address = 0x8e >> 1;\r\nstate->config = demod_config;\r\nstate->i2c = client->adapter;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &au8522_ops);\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 109);\r\nv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1,\r\nAU8522_TVDEC_CONTRAST_REG00BH_CVBS);\r\nv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &au8522_ctrl_ops,\r\nV4L2_CID_HUE, -32768, 32767, 1, 0);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nkfree(demod_config);\r\nkfree(state);\r\nreturn err;\r\n}\r\nstate->c = client;\r\nstate->vid_input = AU8522_COMPOSITE_CH1;\r\nstate->aud_input = AU8522_AUDIO_NONE;\r\nstate->id = 8522;\r\nstate->rev = 0;\r\nau8522_writereg(state, 0x106, 1);\r\nreturn 0;\r\n}\r\nstatic int au8522_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nau8522_release_state(to_state(sd));\r\nreturn 0;\r\n}
