static struct c2_cq *c2_cq_get(struct c2_dev *c2dev, int cqn)\r\n{\r\nstruct c2_cq *cq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&c2dev->lock, flags);\r\ncq = c2dev->qptr_array[cqn];\r\nif (!cq) {\r\nspin_unlock_irqrestore(&c2dev->lock, flags);\r\nreturn NULL;\r\n}\r\natomic_inc(&cq->refcount);\r\nspin_unlock_irqrestore(&c2dev->lock, flags);\r\nreturn cq;\r\n}\r\nstatic void c2_cq_put(struct c2_cq *cq)\r\n{\r\nif (atomic_dec_and_test(&cq->refcount))\r\nwake_up(&cq->wait);\r\n}\r\nvoid c2_cq_event(struct c2_dev *c2dev, u32 mq_index)\r\n{\r\nstruct c2_cq *cq;\r\ncq = c2_cq_get(c2dev, mq_index);\r\nif (!cq) {\r\nprintk("discarding events on destroyed CQN=%d\n", mq_index);\r\nreturn;\r\n}\r\n(*cq->ibcq.comp_handler) (&cq->ibcq, cq->ibcq.cq_context);\r\nc2_cq_put(cq);\r\n}\r\nvoid c2_cq_clean(struct c2_dev *c2dev, struct c2_qp *qp, u32 mq_index)\r\n{\r\nstruct c2_cq *cq;\r\nstruct c2_mq *q;\r\ncq = c2_cq_get(c2dev, mq_index);\r\nif (!cq)\r\nreturn;\r\nspin_lock_irq(&cq->lock);\r\nq = &cq->mq;\r\nif (q && !c2_mq_empty(q)) {\r\nu16 priv = q->priv;\r\nstruct c2wr_ce *msg;\r\nwhile (priv != be16_to_cpu(*q->shared)) {\r\nmsg = (struct c2wr_ce *)\r\n(q->msg_pool.host + priv * q->msg_size);\r\nif (msg->qp_user_context == (u64) (unsigned long) qp) {\r\nmsg->qp_user_context = (u64) 0;\r\n}\r\npriv = (priv + 1) % q->q_size;\r\n}\r\n}\r\nspin_unlock_irq(&cq->lock);\r\nc2_cq_put(cq);\r\n}\r\nstatic inline enum ib_wc_status c2_cqe_status_to_openib(u8 status)\r\n{\r\nswitch (status) {\r\ncase C2_OK:\r\nreturn IB_WC_SUCCESS;\r\ncase CCERR_FLUSHED:\r\nreturn IB_WC_WR_FLUSH_ERR;\r\ncase CCERR_BASE_AND_BOUNDS_VIOLATION:\r\nreturn IB_WC_LOC_PROT_ERR;\r\ncase CCERR_ACCESS_VIOLATION:\r\nreturn IB_WC_LOC_ACCESS_ERR;\r\ncase CCERR_TOTAL_LENGTH_TOO_BIG:\r\nreturn IB_WC_LOC_LEN_ERR;\r\ncase CCERR_INVALID_WINDOW:\r\nreturn IB_WC_MW_BIND_ERR;\r\ndefault:\r\nreturn IB_WC_GENERAL_ERR;\r\n}\r\n}\r\nstatic inline int c2_poll_one(struct c2_dev *c2dev,\r\nstruct c2_cq *cq, struct ib_wc *entry)\r\n{\r\nstruct c2wr_ce *ce;\r\nstruct c2_qp *qp;\r\nint is_recv = 0;\r\nce = c2_mq_consume(&cq->mq);\r\nif (!ce) {\r\nreturn -EAGAIN;\r\n}\r\nwhile ((qp =\r\n(struct c2_qp *) (unsigned long) ce->qp_user_context) == NULL) {\r\nc2_mq_free(&cq->mq);\r\nce = c2_mq_consume(&cq->mq);\r\nif (!ce)\r\nreturn -EAGAIN;\r\n}\r\nentry->status = c2_cqe_status_to_openib(c2_wr_get_result(ce));\r\nentry->wr_id = ce->hdr.context;\r\nentry->qp = &qp->ibqp;\r\nentry->wc_flags = 0;\r\nentry->slid = 0;\r\nentry->sl = 0;\r\nentry->src_qp = 0;\r\nentry->dlid_path_bits = 0;\r\nentry->pkey_index = 0;\r\nswitch (c2_wr_get_id(ce)) {\r\ncase C2_WR_TYPE_SEND:\r\nentry->opcode = IB_WC_SEND;\r\nbreak;\r\ncase C2_WR_TYPE_RDMA_WRITE:\r\nentry->opcode = IB_WC_RDMA_WRITE;\r\nbreak;\r\ncase C2_WR_TYPE_RDMA_READ:\r\nentry->opcode = IB_WC_RDMA_READ;\r\nbreak;\r\ncase C2_WR_TYPE_BIND_MW:\r\nentry->opcode = IB_WC_BIND_MW;\r\nbreak;\r\ncase C2_WR_TYPE_RECV:\r\nentry->byte_len = be32_to_cpu(ce->bytes_rcvd);\r\nentry->opcode = IB_WC_RECV;\r\nis_recv = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (is_recv)\r\nc2_mq_lconsume(&qp->rq_mq, 1);\r\nelse\r\nc2_mq_lconsume(&qp->sq_mq,\r\nbe32_to_cpu(c2_wr_get_wqe_count(ce)) + 1);\r\nc2_mq_free(&cq->mq);\r\nreturn 0;\r\n}\r\nint c2_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *entry)\r\n{\r\nstruct c2_dev *c2dev = to_c2dev(ibcq->device);\r\nstruct c2_cq *cq = to_c2cq(ibcq);\r\nunsigned long flags;\r\nint npolled, err;\r\nspin_lock_irqsave(&cq->lock, flags);\r\nfor (npolled = 0; npolled < num_entries; ++npolled) {\r\nerr = c2_poll_one(c2dev, cq, entry + npolled);\r\nif (err)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cq->lock, flags);\r\nreturn npolled;\r\n}\r\nint c2_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags notify_flags)\r\n{\r\nstruct c2_mq_shared __iomem *shared;\r\nstruct c2_cq *cq;\r\nunsigned long flags;\r\nint ret = 0;\r\ncq = to_c2cq(ibcq);\r\nshared = cq->mq.peer;\r\nif ((notify_flags & IB_CQ_SOLICITED_MASK) == IB_CQ_NEXT_COMP)\r\nwriteb(C2_CQ_NOTIFICATION_TYPE_NEXT, &shared->notification_type);\r\nelse if ((notify_flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED)\r\nwriteb(C2_CQ_NOTIFICATION_TYPE_NEXT_SE, &shared->notification_type);\r\nelse\r\nreturn -EINVAL;\r\nwriteb(CQ_WAIT_FOR_DMA | CQ_ARMED, &shared->armed);\r\nreadb(&shared->armed);\r\nif (notify_flags & IB_CQ_REPORT_MISSED_EVENTS) {\r\nspin_lock_irqsave(&cq->lock, flags);\r\nret = !c2_mq_empty(&cq->mq);\r\nspin_unlock_irqrestore(&cq->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic void c2_free_cq_buf(struct c2_dev *c2dev, struct c2_mq *mq)\r\n{\r\ndma_free_coherent(&c2dev->pcidev->dev, mq->q_size * mq->msg_size,\r\nmq->msg_pool.host, dma_unmap_addr(mq, mapping));\r\n}\r\nstatic int c2_alloc_cq_buf(struct c2_dev *c2dev, struct c2_mq *mq, int q_size,\r\nint msg_size)\r\n{\r\nu8 *pool_start;\r\npool_start = dma_alloc_coherent(&c2dev->pcidev->dev, q_size * msg_size,\r\n&mq->host_dma, GFP_KERNEL);\r\nif (!pool_start)\r\nreturn -ENOMEM;\r\nc2_mq_rep_init(mq,\r\n0,\r\nq_size,\r\nmsg_size,\r\npool_start,\r\nNULL,\r\nC2_MQ_HOST_TARGET);\r\ndma_unmap_addr_set(mq, mapping, mq->host_dma);\r\nreturn 0;\r\n}\r\nint c2_init_cq(struct c2_dev *c2dev, int entries,\r\nstruct c2_ucontext *ctx, struct c2_cq *cq)\r\n{\r\nstruct c2wr_cq_create_req wr;\r\nstruct c2wr_cq_create_rep *reply;\r\nunsigned long peer_pa;\r\nstruct c2_vq_req *vq_req;\r\nint err;\r\nmight_sleep();\r\ncq->ibcq.cqe = entries - 1;\r\ncq->is_kernel = !ctx;\r\ncq->mq.shared = c2_alloc_mqsp(c2dev, c2dev->kern_mqsp_pool,\r\n&cq->mq.shared_dma, GFP_KERNEL);\r\nif (!cq->mq.shared)\r\nreturn -ENOMEM;\r\nerr = c2_alloc_cq_buf(c2dev, &cq->mq, entries + 1, C2_CQ_MSG_SIZE);\r\nif (err)\r\ngoto bail0;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nmemset(&wr, 0, sizeof(wr));\r\nc2_wr_set_id(&wr, CCWR_CQ_CREATE);\r\nwr.hdr.context = (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nwr.msg_size = cpu_to_be32(cq->mq.msg_size);\r\nwr.depth = cpu_to_be32(cq->mq.q_size);\r\nwr.shared_ht = cpu_to_be64(cq->mq.shared_dma);\r\nwr.msg_pool = cpu_to_be64(cq->mq.host_dma);\r\nwr.user_context = (u64) (unsigned long) (cq);\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail2;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail2;\r\nreply = (struct c2wr_cq_create_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail2;\r\n}\r\nif ((err = c2_errno(reply)) != 0)\r\ngoto bail3;\r\ncq->adapter_handle = reply->cq_handle;\r\ncq->mq.index = be32_to_cpu(reply->mq_index);\r\npeer_pa = c2dev->pa + be32_to_cpu(reply->adapter_shared);\r\ncq->mq.peer = ioremap_nocache(peer_pa, PAGE_SIZE);\r\nif (!cq->mq.peer) {\r\nerr = -ENOMEM;\r\ngoto bail3;\r\n}\r\nvq_repbuf_free(c2dev, reply);\r\nvq_req_free(c2dev, vq_req);\r\nspin_lock_init(&cq->lock);\r\natomic_set(&cq->refcount, 1);\r\ninit_waitqueue_head(&cq->wait);\r\ncq->cqn = cq->mq.index;\r\nc2dev->qptr_array[cq->cqn] = cq;\r\nreturn 0;\r\nbail3:\r\nvq_repbuf_free(c2dev, reply);\r\nbail2:\r\nvq_req_free(c2dev, vq_req);\r\nbail1:\r\nc2_free_cq_buf(c2dev, &cq->mq);\r\nbail0:\r\nc2_free_mqsp(cq->mq.shared);\r\nreturn err;\r\n}\r\nvoid c2_free_cq(struct c2_dev *c2dev, struct c2_cq *cq)\r\n{\r\nint err;\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_cq_destroy_req wr;\r\nstruct c2wr_cq_destroy_rep *reply;\r\nmight_sleep();\r\nspin_lock_irq(&c2dev->lock);\r\nc2dev->qptr_array[cq->mq.index] = NULL;\r\natomic_dec(&cq->refcount);\r\nspin_unlock_irq(&c2dev->lock);\r\nwait_event(cq->wait, !atomic_read(&cq->refcount));\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req) {\r\ngoto bail0;\r\n}\r\nmemset(&wr, 0, sizeof(wr));\r\nc2_wr_set_id(&wr, CCWR_CQ_DESTROY);\r\nwr.hdr.context = (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nwr.cq_handle = cq->adapter_handle;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail1;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail1;\r\nreply = (struct c2wr_cq_destroy_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (reply)\r\nvq_repbuf_free(c2dev, reply);\r\nbail1:\r\nvq_req_free(c2dev, vq_req);\r\nbail0:\r\nif (cq->is_kernel) {\r\nc2_free_cq_buf(c2dev, &cq->mq);\r\n}\r\nreturn;\r\n}
