static struct cdrom_info *ide_cd_get(struct gendisk *disk)\r\n{\r\nstruct cdrom_info *cd = NULL;\r\nmutex_lock(&idecd_ref_mutex);\r\ncd = ide_drv_g(disk, cdrom_info);\r\nif (cd) {\r\nif (ide_device_get(cd->drive))\r\ncd = NULL;\r\nelse\r\nget_device(&cd->dev);\r\n}\r\nmutex_unlock(&idecd_ref_mutex);\r\nreturn cd;\r\n}\r\nstatic void ide_cd_put(struct cdrom_info *cd)\r\n{\r\nide_drive_t *drive = cd->drive;\r\nmutex_lock(&idecd_ref_mutex);\r\nput_device(&cd->dev);\r\nide_device_put(drive);\r\nmutex_unlock(&idecd_ref_mutex);\r\n}\r\nstatic void cdrom_saw_media_change(ide_drive_t *drive)\r\n{\r\ndrive->dev_flags |= IDE_DFLAG_MEDIA_CHANGED;\r\ndrive->atapi_flags &= ~IDE_AFLAG_TOC_VALID;\r\n}\r\nstatic int cdrom_log_sense(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct request_sense *sense = &drive->sense_data;\r\nint log = 0;\r\nif (!sense || !rq || (rq->cmd_flags & REQ_QUIET))\r\nreturn 0;\r\nide_debug_log(IDE_DBG_SENSE, "sense_key: 0x%x", sense->sense_key);\r\nswitch (sense->sense_key) {\r\ncase NO_SENSE:\r\ncase RECOVERED_ERROR:\r\nbreak;\r\ncase NOT_READY:\r\nif (sense->asc == 0x3a || sense->asc == 0x04)\r\nbreak;\r\nlog = 1;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nif (rq->cmd[0] == GPCMD_START_STOP_UNIT && sense->asc == 0x24)\r\nbreak;\r\nlog = 1;\r\nbreak;\r\ncase UNIT_ATTENTION:\r\ncdrom_saw_media_change(drive);\r\nbreak;\r\ndefault:\r\nlog = 1;\r\nbreak;\r\n}\r\nreturn log;\r\n}\r\nstatic void cdrom_analyze_sense_data(ide_drive_t *drive,\r\nstruct request *failed_command)\r\n{\r\nstruct request_sense *sense = &drive->sense_data;\r\nstruct cdrom_info *info = drive->driver_data;\r\nunsigned long sector;\r\nunsigned long bio_sectors;\r\nide_debug_log(IDE_DBG_SENSE, "error_code: 0x%x, sense_key: 0x%x",\r\nsense->error_code, sense->sense_key);\r\nif (failed_command)\r\nide_debug_log(IDE_DBG_SENSE, "failed cmd: 0x%x",\r\nfailed_command->cmd[0]);\r\nif (!cdrom_log_sense(drive, failed_command))\r\nreturn;\r\nif (failed_command && failed_command->cmd[0] == GPCMD_READ_TOC_PMA_ATIP)\r\nif (sense->sense_key == 0x05 && sense->asc == 0x24)\r\nreturn;\r\nif (sense->error_code == 0x70) {\r\nswitch (sense->sense_key) {\r\ncase MEDIUM_ERROR:\r\ncase VOLUME_OVERFLOW:\r\ncase ILLEGAL_REQUEST:\r\nif (!sense->valid)\r\nbreak;\r\nif (failed_command == NULL ||\r\nfailed_command->cmd_type != REQ_TYPE_FS)\r\nbreak;\r\nsector = (sense->information[0] << 24) |\r\n(sense->information[1] << 16) |\r\n(sense->information[2] << 8) |\r\n(sense->information[3]);\r\nif (queue_logical_block_size(drive->queue) == 2048)\r\nsector <<= 2;\r\nbio_sectors = max(bio_sectors(failed_command->bio), 4U);\r\nsector &= ~(bio_sectors - 1);\r\nif (sector < get_capacity(info->disk) &&\r\ndrive->probed_capacity - sector < 4 * 75)\r\nset_capacity(info->disk, sector);\r\n}\r\n}\r\nide_cd_log_error(drive->name, failed_command, sense);\r\n}\r\nstatic void ide_cd_complete_failed_rq(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct request *failed = (struct request *)rq->special;\r\nvoid *sense = bio_data(rq->bio);\r\nif (failed) {\r\nif (failed->sense) {\r\nmemcpy(failed->sense, sense, 18);\r\nfailed->sense_len = rq->sense_len;\r\n}\r\ncdrom_analyze_sense_data(drive, failed);\r\nif (ide_end_rq(drive, failed, -EIO, blk_rq_bytes(failed)))\r\nBUG();\r\n} else\r\ncdrom_analyze_sense_data(drive, NULL);\r\n}\r\nstatic int ide_cd_breathe(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nif (!rq->errors)\r\ninfo->write_timeout = jiffies + ATAPI_WAIT_WRITE_BUSY;\r\nrq->errors = 1;\r\nif (time_after(jiffies, info->write_timeout))\r\nreturn 0;\r\nelse {\r\nblk_delay_queue(drive->queue, 1);\r\nreturn 1;\r\n}\r\n}\r\nstatic int cdrom_decode_status(ide_drive_t *drive, u8 stat)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct request *rq = hwif->rq;\r\nint err, sense_key, do_end_request = 0;\r\nerr = ide_read_error(drive);\r\nsense_key = err >> 4;\r\nide_debug_log(IDE_DBG_RQ, "cmd: 0x%x, rq->cmd_type: 0x%x, err: 0x%x, "\r\n"stat 0x%x",\r\nrq->cmd[0], rq->cmd_type, err, stat);\r\nif (rq->cmd_type == REQ_TYPE_SENSE) {\r\nrq->cmd_flags |= REQ_FAILED;\r\nreturn 2;\r\n}\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC && !rq->errors)\r\nrq->errors = SAM_STAT_CHECK_CONDITION;\r\nif (blk_noretry_request(rq))\r\ndo_end_request = 1;\r\nswitch (sense_key) {\r\ncase NOT_READY:\r\nif (rq->cmd_type == REQ_TYPE_FS && rq_data_dir(rq) == WRITE) {\r\nif (ide_cd_breathe(drive, rq))\r\nreturn 1;\r\n} else {\r\ncdrom_saw_media_change(drive);\r\nif (rq->cmd_type == REQ_TYPE_FS &&\r\n!(rq->cmd_flags & REQ_QUIET))\r\nprintk(KERN_ERR PFX "%s: tray open\n",\r\ndrive->name);\r\n}\r\ndo_end_request = 1;\r\nbreak;\r\ncase UNIT_ATTENTION:\r\ncdrom_saw_media_change(drive);\r\nif (rq->cmd_type != REQ_TYPE_FS)\r\nreturn 0;\r\nif (++rq->errors > ERROR_MAX)\r\ndo_end_request = 1;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nif (rq->cmd[0] == GPCMD_START_STOP_UNIT)\r\nbreak;\r\ncase DATA_PROTECT:\r\nif (!(rq->cmd_flags & REQ_QUIET))\r\nide_dump_status(drive, "command error", stat);\r\ndo_end_request = 1;\r\nbreak;\r\ncase MEDIUM_ERROR:\r\nif (!(rq->cmd_flags & REQ_QUIET))\r\nide_dump_status(drive, "media error "\r\n"(bad sector)", stat);\r\ndo_end_request = 1;\r\nbreak;\r\ncase BLANK_CHECK:\r\nif (!(rq->cmd_flags & REQ_QUIET))\r\nide_dump_status(drive, "media error (blank)",\r\nstat);\r\ndo_end_request = 1;\r\nbreak;\r\ndefault:\r\nif (rq->cmd_type != REQ_TYPE_FS)\r\nbreak;\r\nif (err & ~ATA_ABORTED) {\r\nide_error(drive, "cdrom_decode_status", stat);\r\nreturn 1;\r\n} else if (++rq->errors > ERROR_MAX)\r\ndo_end_request = 1;\r\n}\r\nif (rq->cmd_type != REQ_TYPE_FS) {\r\nrq->cmd_flags |= REQ_FAILED;\r\ndo_end_request = 1;\r\n}\r\nif (do_end_request)\r\ngoto end_request;\r\nif (stat & ATA_ERR)\r\nreturn ide_queue_sense_rq(drive, NULL) ? 2 : 1;\r\nreturn 1;\r\nend_request:\r\nif (stat & ATA_ERR) {\r\nhwif->rq = NULL;\r\nreturn ide_queue_sense_rq(drive, rq) ? 2 : 1;\r\n} else\r\nreturn 2;\r\n}\r\nstatic void ide_cd_request_sense_fixup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nstruct request *rq = cmd->rq;\r\nide_debug_log(IDE_DBG_FUNC, "rq->cmd[0]: 0x%x", rq->cmd[0]);\r\nif (rq->cmd[0] == GPCMD_REQUEST_SENSE &&\r\ncmd->nleft > 0 && cmd->nleft <= 5)\r\ncmd->nleft = 0;\r\n}\r\nint ide_cd_queue_pc(ide_drive_t *drive, const unsigned char *cmd,\r\nint write, void *buffer, unsigned *bufflen,\r\nstruct request_sense *sense, int timeout,\r\nunsigned int cmd_flags)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct request_sense local_sense;\r\nint retries = 10;\r\nunsigned int flags = 0;\r\nif (!sense)\r\nsense = &local_sense;\r\nide_debug_log(IDE_DBG_PC, "cmd[0]: 0x%x, write: 0x%x, timeout: %d, "\r\n"cmd_flags: 0x%x",\r\ncmd[0], write, timeout, cmd_flags);\r\ndo {\r\nstruct request *rq;\r\nint error;\r\nrq = blk_get_request(drive->queue, write, __GFP_WAIT);\r\nmemcpy(rq->cmd, cmd, BLK_MAX_CDB);\r\nrq->cmd_type = REQ_TYPE_ATA_PC;\r\nrq->sense = sense;\r\nrq->cmd_flags |= cmd_flags;\r\nrq->timeout = timeout;\r\nif (buffer) {\r\nerror = blk_rq_map_kern(drive->queue, rq, buffer,\r\n*bufflen, GFP_NOIO);\r\nif (error) {\r\nblk_put_request(rq);\r\nreturn error;\r\n}\r\n}\r\nerror = blk_execute_rq(drive->queue, info->disk, rq, 0);\r\nif (buffer)\r\n*bufflen = rq->resid_len;\r\nflags = rq->cmd_flags;\r\nblk_put_request(rq);\r\nif (flags & REQ_FAILED) {\r\nstruct request_sense *reqbuf = sense;\r\nif (reqbuf->sense_key == UNIT_ATTENTION)\r\ncdrom_saw_media_change(drive);\r\nelse if (reqbuf->sense_key == NOT_READY &&\r\nreqbuf->asc == 4 && reqbuf->ascq != 4) {\r\nssleep(2);\r\n} else {\r\nretries = 0;\r\n}\r\n--retries;\r\n}\r\n} while ((flags & REQ_FAILED) && retries >= 0);\r\nreturn (flags & REQ_FAILED) ? -EIO : 0;\r\n}\r\nstatic bool ide_cd_error_cmd(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nunsigned int nr_bytes = cmd->nbytes - cmd->nleft;\r\nif (cmd->tf_flags & IDE_TFLAG_WRITE)\r\nnr_bytes -= cmd->last_xfer_len;\r\nif (nr_bytes > 0) {\r\nide_complete_rq(drive, 0, nr_bytes);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic ide_startstop_t cdrom_newpc_intr(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_cmd *cmd = &hwif->cmd;\r\nstruct request *rq = hwif->rq;\r\nide_expiry_t *expiry = NULL;\r\nint dma_error = 0, dma, thislen, uptodate = 0;\r\nint write = (rq_data_dir(rq) == WRITE) ? 1 : 0, rc = 0;\r\nint sense = (rq->cmd_type == REQ_TYPE_SENSE);\r\nunsigned int timeout;\r\nu16 len;\r\nu8 ireason, stat;\r\nide_debug_log(IDE_DBG_PC, "cmd: 0x%x, write: 0x%x", rq->cmd[0], write);\r\ndma = drive->dma;\r\nif (dma) {\r\ndrive->dma = 0;\r\ndrive->waiting_for_dma = 0;\r\ndma_error = hwif->dma_ops->dma_end(drive);\r\nide_dma_unmap_sg(drive, cmd);\r\nif (dma_error) {\r\nprintk(KERN_ERR PFX "%s: DMA %s error\n", drive->name,\r\nwrite ? "write" : "read");\r\nide_dma_off(drive);\r\n}\r\n}\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif (!OK_STAT(stat, 0, BAD_R_STAT)) {\r\nrc = cdrom_decode_status(drive, stat);\r\nif (rc) {\r\nif (rc == 2)\r\ngoto out_end;\r\nreturn ide_stopped;\r\n}\r\n}\r\nif (dma) {\r\nif (dma_error)\r\nreturn ide_error(drive, "dma error", stat);\r\nuptodate = 1;\r\ngoto out_end;\r\n}\r\nide_read_bcount_and_ireason(drive, &len, &ireason);\r\nthislen = (rq->cmd_type == REQ_TYPE_FS) ? len : cmd->nleft;\r\nif (thislen > len)\r\nthislen = len;\r\nide_debug_log(IDE_DBG_PC, "DRQ: stat: 0x%x, thislen: %d",\r\nstat, thislen);\r\nif ((stat & ATA_DRQ) == 0) {\r\nif (rq->cmd_type == REQ_TYPE_FS) {\r\nuptodate = 1;\r\nif (cmd->nleft > 0) {\r\nprintk(KERN_ERR PFX "%s: %s: data underrun "\r\n"(%u bytes)\n", drive->name, __func__,\r\ncmd->nleft);\r\nif (!write)\r\nrq->cmd_flags |= REQ_FAILED;\r\nuptodate = 0;\r\n}\r\n} else if (rq->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nide_cd_request_sense_fixup(drive, cmd);\r\nuptodate = cmd->nleft ? 0 : 1;\r\nif (!(stat & ATA_ERR) && !uptodate && thislen) {\r\nide_pio_bytes(drive, cmd, write, thislen);\r\nuptodate = cmd->nleft ? 0 : 1;\r\n}\r\nif (!uptodate)\r\nrq->cmd_flags |= REQ_FAILED;\r\n}\r\ngoto out_end;\r\n}\r\nrc = ide_check_ireason(drive, rq, len, ireason, write);\r\nif (rc)\r\ngoto out_end;\r\ncmd->last_xfer_len = 0;\r\nide_debug_log(IDE_DBG_PC, "data transfer, rq->cmd_type: 0x%x, "\r\n"ireason: 0x%x",\r\nrq->cmd_type, ireason);\r\nwhile (thislen > 0) {\r\nint blen = min_t(int, thislen, cmd->nleft);\r\nif (cmd->nleft == 0)\r\nbreak;\r\nide_pio_bytes(drive, cmd, write, blen);\r\ncmd->last_xfer_len += blen;\r\nthislen -= blen;\r\nlen -= blen;\r\nif (sense && write == 0)\r\nrq->sense_len += blen;\r\n}\r\nif (len > 0) {\r\nif (rq->cmd_type != REQ_TYPE_FS || write == 0)\r\nide_pad_transfer(drive, write, len);\r\nelse {\r\nprintk(KERN_ERR PFX "%s: confused, missing data\n",\r\ndrive->name);\r\nblk_dump_rq_flags(rq, "cdrom_newpc_intr");\r\n}\r\n}\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC) {\r\ntimeout = rq->timeout;\r\n} else {\r\ntimeout = ATAPI_WAIT_PC;\r\nif (rq->cmd_type != REQ_TYPE_FS)\r\nexpiry = ide_cd_expiry;\r\n}\r\nhwif->expiry = expiry;\r\nide_set_handler(drive, cdrom_newpc_intr, timeout);\r\nreturn ide_started;\r\nout_end:\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC && rc == 0) {\r\nrq->resid_len = 0;\r\nblk_end_request_all(rq, 0);\r\nhwif->rq = NULL;\r\n} else {\r\nif (sense && uptodate)\r\nide_cd_complete_failed_rq(drive, rq);\r\nif (rq->cmd_type == REQ_TYPE_FS) {\r\nif (cmd->nleft == 0)\r\nuptodate = 1;\r\n} else {\r\nif (uptodate <= 0 && rq->errors == 0)\r\nrq->errors = -EIO;\r\n}\r\nif (uptodate == 0 && rq->bio)\r\nif (ide_cd_error_cmd(drive, cmd))\r\nreturn ide_stopped;\r\nif (rq->cmd_type != REQ_TYPE_FS) {\r\nrq->resid_len -= cmd->nbytes - cmd->nleft;\r\nif (uptodate == 0 && (cmd->tf_flags & IDE_TFLAG_WRITE))\r\nrq->resid_len += cmd->last_xfer_len;\r\n}\r\nide_complete_rq(drive, uptodate ? 0 : -EIO, blk_rq_bytes(rq));\r\nif (sense && rc == 2)\r\nide_error(drive, "request sense failure", stat);\r\n}\r\nreturn ide_stopped;\r\n}\r\nstatic ide_startstop_t cdrom_start_rw(ide_drive_t *drive, struct request *rq)\r\n{\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct request_queue *q = drive->queue;\r\nint write = rq_data_dir(rq) == WRITE;\r\nunsigned short sectors_per_frame =\r\nqueue_logical_block_size(q) >> SECTOR_BITS;\r\nide_debug_log(IDE_DBG_RQ, "rq->cmd[0]: 0x%x, rq->cmd_flags: 0x%x, "\r\n"secs_per_frame: %u",\r\nrq->cmd[0], rq->cmd_flags, sectors_per_frame);\r\nif (write) {\r\nif (get_disk_ro(cd->disk))\r\nreturn ide_stopped;\r\n} else {\r\nq->prep_rq_fn(q, rq);\r\n}\r\nif ((blk_rq_sectors(rq) & (sectors_per_frame - 1)) ||\r\n(blk_rq_pos(rq) & (sectors_per_frame - 1)))\r\nreturn ide_stopped;\r\ndrive->dma = !!(drive->dev_flags & IDE_DFLAG_USING_DMA);\r\nif (write)\r\ncd->devinfo.media_written = 1;\r\nrq->timeout = ATAPI_WAIT_PC;\r\nreturn ide_started;\r\n}\r\nstatic void cdrom_do_block_pc(ide_drive_t *drive, struct request *rq)\r\n{\r\nide_debug_log(IDE_DBG_PC, "rq->cmd[0]: 0x%x, rq->cmd_type: 0x%x",\r\nrq->cmd[0], rq->cmd_type);\r\nif (rq->cmd_type == REQ_TYPE_BLOCK_PC)\r\nrq->cmd_flags |= REQ_QUIET;\r\nelse\r\nrq->cmd_flags &= ~REQ_FAILED;\r\ndrive->dma = 0;\r\nif (rq->bio) {\r\nstruct request_queue *q = drive->queue;\r\nchar *buf = bio_data(rq->bio);\r\nunsigned int alignment;\r\ndrive->dma = !!(drive->dev_flags & IDE_DFLAG_USING_DMA);\r\nalignment = queue_dma_alignment(q) | q->dma_pad_mask;\r\nif ((unsigned long)buf & alignment\r\n|| blk_rq_bytes(rq) & q->dma_pad_mask\r\n|| object_is_on_stack(buf))\r\ndrive->dma = 0;\r\n}\r\n}\r\nstatic ide_startstop_t ide_cd_do_request(ide_drive_t *drive, struct request *rq,\r\nsector_t block)\r\n{\r\nstruct ide_cmd cmd;\r\nint uptodate = 0;\r\nunsigned int nsectors;\r\nide_debug_log(IDE_DBG_RQ, "cmd: 0x%x, block: %llu",\r\nrq->cmd[0], (unsigned long long)block);\r\nif (drive->debug_mask & IDE_DBG_RQ)\r\nblk_dump_rq_flags(rq, "ide_cd_do_request");\r\nswitch (rq->cmd_type) {\r\ncase REQ_TYPE_FS:\r\nif (cdrom_start_rw(drive, rq) == ide_stopped)\r\ngoto out_end;\r\nbreak;\r\ncase REQ_TYPE_SENSE:\r\ncase REQ_TYPE_BLOCK_PC:\r\ncase REQ_TYPE_ATA_PC:\r\nif (!rq->timeout)\r\nrq->timeout = ATAPI_WAIT_PC;\r\ncdrom_do_block_pc(drive, rq);\r\nbreak;\r\ncase REQ_TYPE_SPECIAL:\r\nuptodate = 1;\r\ngoto out_end;\r\ndefault:\r\nBUG();\r\n}\r\nide_prep_sense(drive, rq);\r\nmemset(&cmd, 0, sizeof(cmd));\r\nif (rq_data_dir(rq))\r\ncmd.tf_flags |= IDE_TFLAG_WRITE;\r\ncmd.rq = rq;\r\nif (rq->cmd_type == REQ_TYPE_FS || blk_rq_bytes(rq)) {\r\nide_init_sg_cmd(&cmd, blk_rq_bytes(rq));\r\nide_map_sg(drive, &cmd);\r\n}\r\nreturn ide_issue_pc(drive, &cmd);\r\nout_end:\r\nnsectors = blk_rq_sectors(rq);\r\nif (nsectors == 0)\r\nnsectors = 1;\r\nide_complete_rq(drive, uptodate ? 0 : -EIO, nsectors << 9);\r\nreturn ide_stopped;\r\n}\r\nstatic void msf_from_bcd(struct atapi_msf *msf)\r\n{\r\nmsf->minute = bcd2bin(msf->minute);\r\nmsf->second = bcd2bin(msf->second);\r\nmsf->frame = bcd2bin(msf->frame);\r\n}\r\nint cdrom_check_status(ide_drive_t *drive, struct request_sense *sense)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct cdrom_device_info *cdi = &info->devinfo;\r\nunsigned char cmd[BLK_MAX_CDB];\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_TEST_UNIT_READY;\r\ncmd[7] = cdi->sanyo_slot % 3;\r\nreturn ide_cd_queue_pc(drive, cmd, 0, NULL, NULL, sense, 0, REQ_QUIET);\r\n}\r\nstatic int cdrom_read_capacity(ide_drive_t *drive, unsigned long *capacity,\r\nunsigned long *sectors_per_frame,\r\nstruct request_sense *sense)\r\n{\r\nstruct {\r\n__be32 lba;\r\n__be32 blocklen;\r\n} capbuf;\r\nint stat;\r\nunsigned char cmd[BLK_MAX_CDB];\r\nunsigned len = sizeof(capbuf);\r\nu32 blocklen;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_READ_CDVD_CAPACITY;\r\nstat = ide_cd_queue_pc(drive, cmd, 0, &capbuf, &len, sense, 0,\r\nREQ_QUIET);\r\nif (stat)\r\nreturn stat;\r\nblocklen = be32_to_cpu(capbuf.blocklen);\r\nblocklen = (blocklen >> SECTOR_BITS) << SECTOR_BITS;\r\nswitch (blocklen) {\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\ncase 4096:\r\nbreak;\r\ndefault:\r\nprintk_once(KERN_ERR PFX "%s: weird block size %u; "\r\n"setting default block size to 2048\n",\r\ndrive->name, blocklen);\r\nblocklen = 2048;\r\nbreak;\r\n}\r\n*capacity = 1 + be32_to_cpu(capbuf.lba);\r\n*sectors_per_frame = blocklen >> SECTOR_BITS;\r\nide_debug_log(IDE_DBG_PROBE, "cap: %lu, sectors_per_frame: %lu",\r\n*capacity, *sectors_per_frame);\r\nreturn 0;\r\n}\r\nstatic int cdrom_read_tocentry(ide_drive_t *drive, int trackno, int msf_flag,\r\nint format, char *buf, int buflen,\r\nstruct request_sense *sense)\r\n{\r\nunsigned char cmd[BLK_MAX_CDB];\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_READ_TOC_PMA_ATIP;\r\ncmd[6] = trackno;\r\ncmd[7] = (buflen >> 8);\r\ncmd[8] = (buflen & 0xff);\r\ncmd[9] = (format << 6);\r\nif (msf_flag)\r\ncmd[1] = 2;\r\nreturn ide_cd_queue_pc(drive, cmd, 0, buf, &buflen, sense, 0, REQ_QUIET);\r\n}\r\nint ide_cd_read_toc(ide_drive_t *drive, struct request_sense *sense)\r\n{\r\nint stat, ntracks, i;\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct cdrom_device_info *cdi = &info->devinfo;\r\nstruct atapi_toc *toc = info->toc;\r\nstruct {\r\nstruct atapi_toc_header hdr;\r\nstruct atapi_toc_entry ent;\r\n} ms_tmp;\r\nlong last_written;\r\nunsigned long sectors_per_frame = SECTORS_PER_FRAME;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nif (toc == NULL) {\r\ntoc = kmalloc(sizeof(struct atapi_toc), GFP_KERNEL);\r\nif (toc == NULL) {\r\nprintk(KERN_ERR PFX "%s: No cdrom TOC buffer!\n",\r\ndrive->name);\r\nreturn -ENOMEM;\r\n}\r\ninfo->toc = toc;\r\n}\r\n(void) cdrom_check_status(drive, sense);\r\nif (drive->atapi_flags & IDE_AFLAG_TOC_VALID)\r\nreturn 0;\r\nstat = cdrom_read_capacity(drive, &toc->capacity, &sectors_per_frame,\r\nsense);\r\nif (stat)\r\ntoc->capacity = 0x1fffff;\r\nset_capacity(info->disk, toc->capacity * sectors_per_frame);\r\ndrive->probed_capacity = toc->capacity * sectors_per_frame;\r\nblk_queue_logical_block_size(drive->queue,\r\nsectors_per_frame << SECTOR_BITS);\r\nstat = cdrom_read_tocentry(drive, 0, 1, 0, (char *) &toc->hdr,\r\nsizeof(struct atapi_toc_header), sense);\r\nif (stat)\r\nreturn stat;\r\nif (drive->atapi_flags & IDE_AFLAG_TOCTRACKS_AS_BCD) {\r\ntoc->hdr.first_track = bcd2bin(toc->hdr.first_track);\r\ntoc->hdr.last_track = bcd2bin(toc->hdr.last_track);\r\n}\r\nntracks = toc->hdr.last_track - toc->hdr.first_track + 1;\r\nif (ntracks <= 0)\r\nreturn -EIO;\r\nif (ntracks > MAX_TRACKS)\r\nntracks = MAX_TRACKS;\r\nstat = cdrom_read_tocentry(drive, toc->hdr.first_track, 1, 0,\r\n(char *)&toc->hdr,\r\nsizeof(struct atapi_toc_header) +\r\n(ntracks + 1) *\r\nsizeof(struct atapi_toc_entry), sense);\r\nif (stat && toc->hdr.first_track > 1) {\r\nntracks = 0;\r\nstat = cdrom_read_tocentry(drive, CDROM_LEADOUT, 1, 0,\r\n(char *)&toc->hdr,\r\nsizeof(struct atapi_toc_header) +\r\n(ntracks + 1) *\r\nsizeof(struct atapi_toc_entry),\r\nsense);\r\nif (stat)\r\nreturn stat;\r\nif (drive->atapi_flags & IDE_AFLAG_TOCTRACKS_AS_BCD) {\r\ntoc->hdr.first_track = (u8)bin2bcd(CDROM_LEADOUT);\r\ntoc->hdr.last_track = (u8)bin2bcd(CDROM_LEADOUT);\r\n} else {\r\ntoc->hdr.first_track = CDROM_LEADOUT;\r\ntoc->hdr.last_track = CDROM_LEADOUT;\r\n}\r\n}\r\nif (stat)\r\nreturn stat;\r\ntoc->hdr.toc_length = be16_to_cpu(toc->hdr.toc_length);\r\nif (drive->atapi_flags & IDE_AFLAG_TOCTRACKS_AS_BCD) {\r\ntoc->hdr.first_track = bcd2bin(toc->hdr.first_track);\r\ntoc->hdr.last_track = bcd2bin(toc->hdr.last_track);\r\n}\r\nfor (i = 0; i <= ntracks; i++) {\r\nif (drive->atapi_flags & IDE_AFLAG_TOCADDR_AS_BCD) {\r\nif (drive->atapi_flags & IDE_AFLAG_TOCTRACKS_AS_BCD)\r\ntoc->ent[i].track = bcd2bin(toc->ent[i].track);\r\nmsf_from_bcd(&toc->ent[i].addr.msf);\r\n}\r\ntoc->ent[i].addr.lba = msf_to_lba(toc->ent[i].addr.msf.minute,\r\ntoc->ent[i].addr.msf.second,\r\ntoc->ent[i].addr.msf.frame);\r\n}\r\nif (toc->hdr.first_track != CDROM_LEADOUT) {\r\nstat = cdrom_read_tocentry(drive, 0, 0, 1, (char *)&ms_tmp,\r\nsizeof(ms_tmp), sense);\r\nif (stat)\r\nreturn stat;\r\ntoc->last_session_lba = be32_to_cpu(ms_tmp.ent.addr.lba);\r\n} else {\r\nms_tmp.hdr.last_track = CDROM_LEADOUT;\r\nms_tmp.hdr.first_track = ms_tmp.hdr.last_track;\r\ntoc->last_session_lba = msf_to_lba(0, 2, 0);\r\n}\r\nif (drive->atapi_flags & IDE_AFLAG_TOCADDR_AS_BCD) {\r\nstat = cdrom_read_tocentry(drive, 0, 1, 1, (char *)&ms_tmp,\r\nsizeof(ms_tmp), sense);\r\nif (stat)\r\nreturn stat;\r\nmsf_from_bcd(&ms_tmp.ent.addr.msf);\r\ntoc->last_session_lba = msf_to_lba(ms_tmp.ent.addr.msf.minute,\r\nms_tmp.ent.addr.msf.second,\r\nms_tmp.ent.addr.msf.frame);\r\n}\r\ntoc->xa_flag = (ms_tmp.hdr.first_track != ms_tmp.hdr.last_track);\r\nstat = cdrom_get_last_written(cdi, &last_written);\r\nif (!stat && (last_written > toc->capacity)) {\r\ntoc->capacity = last_written;\r\nset_capacity(info->disk, toc->capacity * sectors_per_frame);\r\ndrive->probed_capacity = toc->capacity * sectors_per_frame;\r\n}\r\ndrive->atapi_flags |= IDE_AFLAG_TOC_VALID;\r\nreturn 0;\r\n}\r\nint ide_cdrom_get_capabilities(ide_drive_t *drive, u8 *buf)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct cdrom_device_info *cdi = &info->devinfo;\r\nstruct packet_command cgc;\r\nint stat, attempts = 3, size = ATAPI_CAPABILITIES_PAGE_SIZE;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nif ((drive->atapi_flags & IDE_AFLAG_FULL_CAPS_PAGE) == 0)\r\nsize -= ATAPI_CAPABILITIES_PAGE_PAD_SIZE;\r\ninit_cdrom_command(&cgc, buf, size, CGC_DATA_UNKNOWN);\r\ndo {\r\nstat = cdrom_mode_sense(cdi, &cgc, GPMODE_CAPABILITIES_PAGE, 0);\r\nif (!stat)\r\nbreak;\r\n} while (--attempts);\r\nreturn stat;\r\n}\r\nvoid ide_cdrom_update_speed(ide_drive_t *drive, u8 *buf)\r\n{\r\nstruct cdrom_info *cd = drive->driver_data;\r\nu16 curspeed, maxspeed;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nif (drive->atapi_flags & IDE_AFLAG_LE_SPEED_FIELDS) {\r\ncurspeed = le16_to_cpup((__le16 *)&buf[8 + 14]);\r\nmaxspeed = le16_to_cpup((__le16 *)&buf[8 + 8]);\r\n} else {\r\ncurspeed = be16_to_cpup((__be16 *)&buf[8 + 14]);\r\nmaxspeed = be16_to_cpup((__be16 *)&buf[8 + 8]);\r\n}\r\nide_debug_log(IDE_DBG_PROBE, "curspeed: %u, maxspeed: %u",\r\ncurspeed, maxspeed);\r\ncd->current_speed = DIV_ROUND_CLOSEST(curspeed, 176);\r\ncd->max_speed = DIV_ROUND_CLOSEST(maxspeed, 176);\r\n}\r\nstatic int ide_cdrom_register(ide_drive_t *drive, int nslots)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct cdrom_device_info *devinfo = &info->devinfo;\r\nide_debug_log(IDE_DBG_PROBE, "nslots: %d", nslots);\r\ndevinfo->ops = &ide_cdrom_dops;\r\ndevinfo->speed = info->current_speed;\r\ndevinfo->capacity = nslots;\r\ndevinfo->handle = drive;\r\nstrcpy(devinfo->name, drive->name);\r\nif (drive->atapi_flags & IDE_AFLAG_NO_SPEED_SELECT)\r\ndevinfo->mask |= CDC_SELECT_SPEED;\r\ndevinfo->disk = info->disk;\r\nreturn register_cdrom(devinfo);\r\n}\r\nstatic int ide_cdrom_probe_capabilities(ide_drive_t *drive)\r\n{\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct cdrom_device_info *cdi = &cd->devinfo;\r\nu8 buf[ATAPI_CAPABILITIES_PAGE_SIZE];\r\nmechtype_t mechtype;\r\nint nslots = 1;\r\nide_debug_log(IDE_DBG_PROBE, "media: 0x%x, atapi_flags: 0x%lx",\r\ndrive->media, drive->atapi_flags);\r\ncdi->mask = (CDC_CD_R | CDC_CD_RW | CDC_DVD | CDC_DVD_R |\r\nCDC_DVD_RAM | CDC_SELECT_DISC | CDC_PLAY_AUDIO |\r\nCDC_MO_DRIVE | CDC_RAM);\r\nif (drive->media == ide_optical) {\r\ncdi->mask &= ~(CDC_MO_DRIVE | CDC_RAM);\r\nprintk(KERN_ERR PFX "%s: ATAPI magneto-optical drive\n",\r\ndrive->name);\r\nreturn nslots;\r\n}\r\nif (drive->atapi_flags & IDE_AFLAG_PRE_ATAPI12) {\r\ndrive->atapi_flags &= ~IDE_AFLAG_NO_EJECT;\r\ncdi->mask &= ~CDC_PLAY_AUDIO;\r\nreturn nslots;\r\n}\r\ncdi->handle = drive;\r\ncdi->ops = &ide_cdrom_dops;\r\nif (ide_cdrom_get_capabilities(drive, buf))\r\nreturn 0;\r\nif ((buf[8 + 6] & 0x01) == 0)\r\ndrive->dev_flags &= ~IDE_DFLAG_DOORLOCKING;\r\nif (buf[8 + 6] & 0x08)\r\ndrive->atapi_flags &= ~IDE_AFLAG_NO_EJECT;\r\nif (buf[8 + 3] & 0x01)\r\ncdi->mask &= ~CDC_CD_R;\r\nif (buf[8 + 3] & 0x02)\r\ncdi->mask &= ~(CDC_CD_RW | CDC_RAM);\r\nif (buf[8 + 2] & 0x38)\r\ncdi->mask &= ~CDC_DVD;\r\nif (buf[8 + 3] & 0x20)\r\ncdi->mask &= ~(CDC_DVD_RAM | CDC_RAM);\r\nif (buf[8 + 3] & 0x10)\r\ncdi->mask &= ~CDC_DVD_R;\r\nif ((buf[8 + 4] & 0x01) || (drive->atapi_flags & IDE_AFLAG_PLAY_AUDIO_OK))\r\ncdi->mask &= ~CDC_PLAY_AUDIO;\r\nmechtype = buf[8 + 6] >> 5;\r\nif (mechtype == mechtype_caddy ||\r\nmechtype == mechtype_popup ||\r\n(drive->atapi_flags & IDE_AFLAG_NO_AUTOCLOSE))\r\ncdi->mask |= CDC_CLOSE_TRAY;\r\nif (cdi->sanyo_slot > 0) {\r\ncdi->mask &= ~CDC_SELECT_DISC;\r\nnslots = 3;\r\n} else if (mechtype == mechtype_individual_changer ||\r\nmechtype == mechtype_cartridge_changer) {\r\nnslots = cdrom_number_of_slots(cdi);\r\nif (nslots > 1)\r\ncdi->mask &= ~CDC_SELECT_DISC;\r\n}\r\nide_cdrom_update_speed(drive, buf);\r\nprintk(KERN_INFO PFX "%s: ATAPI", drive->name);\r\nif (cd->max_speed)\r\nprintk(KERN_CONT " %dX", cd->max_speed);\r\nprintk(KERN_CONT " %s", (cdi->mask & CDC_DVD) ? "CD-ROM" : "DVD-ROM");\r\nif ((cdi->mask & CDC_DVD_R) == 0 || (cdi->mask & CDC_DVD_RAM) == 0)\r\nprintk(KERN_CONT " DVD%s%s",\r\n(cdi->mask & CDC_DVD_R) ? "" : "-R",\r\n(cdi->mask & CDC_DVD_RAM) ? "" : "/RAM");\r\nif ((cdi->mask & CDC_CD_R) == 0 || (cdi->mask & CDC_CD_RW) == 0)\r\nprintk(KERN_CONT " CD%s%s",\r\n(cdi->mask & CDC_CD_R) ? "" : "-R",\r\n(cdi->mask & CDC_CD_RW) ? "" : "/RW");\r\nif ((cdi->mask & CDC_SELECT_DISC) == 0)\r\nprintk(KERN_CONT " changer w/%d slots", nslots);\r\nelse\r\nprintk(KERN_CONT " drive");\r\nprintk(KERN_CONT ", %dkB Cache\n",\r\nbe16_to_cpup((__be16 *)&buf[8 + 12]));\r\nreturn nslots;\r\n}\r\nstatic int ide_cdrom_prep_fs(struct request_queue *q, struct request *rq)\r\n{\r\nint hard_sect = queue_logical_block_size(q);\r\nlong block = (long)blk_rq_pos(rq) / (hard_sect >> 9);\r\nunsigned long blocks = blk_rq_sectors(rq) / (hard_sect >> 9);\r\nmemset(rq->cmd, 0, BLK_MAX_CDB);\r\nif (rq_data_dir(rq) == READ)\r\nrq->cmd[0] = GPCMD_READ_10;\r\nelse\r\nrq->cmd[0] = GPCMD_WRITE_10;\r\nrq->cmd[2] = (block >> 24) & 0xff;\r\nrq->cmd[3] = (block >> 16) & 0xff;\r\nrq->cmd[4] = (block >> 8) & 0xff;\r\nrq->cmd[5] = block & 0xff;\r\nrq->cmd[7] = (blocks >> 8) & 0xff;\r\nrq->cmd[8] = blocks & 0xff;\r\nrq->cmd_len = 10;\r\nreturn BLKPREP_OK;\r\n}\r\nstatic int ide_cdrom_prep_pc(struct request *rq)\r\n{\r\nu8 *c = rq->cmd;\r\nif (c[0] == READ_6 || c[0] == WRITE_6) {\r\nc[8] = c[4];\r\nc[5] = c[3];\r\nc[4] = c[2];\r\nc[3] = c[1] & 0x1f;\r\nc[2] = 0;\r\nc[1] &= 0xe0;\r\nc[0] += (READ_10 - READ_6);\r\nrq->cmd_len = 10;\r\nreturn BLKPREP_OK;\r\n}\r\nif (c[0] == MODE_SENSE || c[0] == MODE_SELECT) {\r\nrq->errors = ILLEGAL_REQUEST;\r\nreturn BLKPREP_KILL;\r\n}\r\nreturn BLKPREP_OK;\r\n}\r\nstatic int ide_cdrom_prep_fn(struct request_queue *q, struct request *rq)\r\n{\r\nif (rq->cmd_type == REQ_TYPE_FS)\r\nreturn ide_cdrom_prep_fs(q, rq);\r\nelse if (rq->cmd_type == REQ_TYPE_BLOCK_PC)\r\nreturn ide_cdrom_prep_pc(rq);\r\nreturn 0;\r\n}\r\nstatic sector_t ide_cdrom_capacity(ide_drive_t *drive)\r\n{\r\nunsigned long capacity, sectors_per_frame;\r\nif (cdrom_read_capacity(drive, &capacity, &sectors_per_frame, NULL))\r\nreturn 0;\r\nreturn capacity * sectors_per_frame;\r\n}\r\nstatic int idecd_capacity_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_drive_t *drive = m->private;\r\nseq_printf(m, "%llu\n", (long long)ide_cdrom_capacity(drive));\r\nreturn 0;\r\n}\r\nstatic int idecd_capacity_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, idecd_capacity_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ide_proc_entry_t *ide_cd_proc_entries(ide_drive_t *drive)\r\n{\r\nreturn idecd_proc;\r\n}\r\nstatic const struct ide_proc_devset *ide_cd_proc_devsets(ide_drive_t *drive)\r\n{\r\nreturn NULL;\r\n}\r\nstatic unsigned int ide_cd_flags(u16 *id)\r\n{\r\nconst struct cd_list_entry *cle = ide_cd_quirks_list;\r\nwhile (cle->id_model) {\r\nif (strcmp(cle->id_model, (char *)&id[ATA_ID_PROD]) == 0 &&\r\n(cle->id_firmware == NULL ||\r\nstrstr((char *)&id[ATA_ID_FW_REV], cle->id_firmware)))\r\nreturn cle->cd_flags;\r\ncle++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ide_cdrom_setup(ide_drive_t *drive)\r\n{\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct cdrom_device_info *cdi = &cd->devinfo;\r\nstruct request_queue *q = drive->queue;\r\nu16 *id = drive->id;\r\nchar *fw_rev = (char *)&id[ATA_ID_FW_REV];\r\nint nslots;\r\nide_debug_log(IDE_DBG_PROBE, "enter");\r\nblk_queue_prep_rq(q, ide_cdrom_prep_fn);\r\nblk_queue_dma_alignment(q, 31);\r\nblk_queue_update_dma_pad(q, 15);\r\ndrive->dev_flags |= IDE_DFLAG_MEDIA_CHANGED;\r\ndrive->atapi_flags = IDE_AFLAG_NO_EJECT | ide_cd_flags(id);\r\nif ((drive->atapi_flags & IDE_AFLAG_VERTOS_300_SSD) &&\r\nfw_rev[4] == '1' && fw_rev[6] <= '2')\r\ndrive->atapi_flags |= (IDE_AFLAG_TOCTRACKS_AS_BCD |\r\nIDE_AFLAG_TOCADDR_AS_BCD);\r\nelse if ((drive->atapi_flags & IDE_AFLAG_VERTOS_600_ESD) &&\r\nfw_rev[4] == '1' && fw_rev[6] <= '2')\r\ndrive->atapi_flags |= IDE_AFLAG_TOCTRACKS_AS_BCD;\r\nelse if (drive->atapi_flags & IDE_AFLAG_SANYO_3CD)\r\ncdi->sanyo_slot = 3;\r\nnslots = ide_cdrom_probe_capabilities(drive);\r\nblk_queue_logical_block_size(q, CD_FRAMESIZE);\r\nif (ide_cdrom_register(drive, nslots)) {\r\nprintk(KERN_ERR PFX "%s: %s failed to register device with the"\r\n" cdrom driver.\n", drive->name, __func__);\r\ncd->devinfo.handle = NULL;\r\nreturn 1;\r\n}\r\nide_proc_register_driver(drive, cd->driver);\r\nreturn 0;\r\n}\r\nstatic void ide_cd_remove(ide_drive_t *drive)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nide_proc_unregister_driver(drive, info->driver);\r\ndevice_del(&info->dev);\r\ndel_gendisk(info->disk);\r\nmutex_lock(&idecd_ref_mutex);\r\nput_device(&info->dev);\r\nmutex_unlock(&idecd_ref_mutex);\r\n}\r\nstatic void ide_cd_release(struct device *dev)\r\n{\r\nstruct cdrom_info *info = to_ide_drv(dev, cdrom_info);\r\nstruct cdrom_device_info *devinfo = &info->devinfo;\r\nide_drive_t *drive = info->drive;\r\nstruct gendisk *g = info->disk;\r\nide_debug_log(IDE_DBG_FUNC, "enter");\r\nkfree(info->toc);\r\nif (devinfo->handle == drive)\r\nunregister_cdrom(devinfo);\r\ndrive->driver_data = NULL;\r\nblk_queue_prep_rq(drive->queue, NULL);\r\ng->private_data = NULL;\r\nput_disk(g);\r\nkfree(info);\r\n}\r\nstatic int idecd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct cdrom_info *info;\r\nint rc = -ENXIO;\r\nmutex_lock(&ide_cd_mutex);\r\ninfo = ide_cd_get(bdev->bd_disk);\r\nif (!info)\r\ngoto out;\r\nrc = cdrom_open(&info->devinfo, bdev, mode);\r\nif (rc < 0)\r\nide_cd_put(info);\r\nout:\r\nmutex_unlock(&ide_cd_mutex);\r\nreturn rc;\r\n}\r\nstatic void idecd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct cdrom_info *info = ide_drv_g(disk, cdrom_info);\r\nmutex_lock(&ide_cd_mutex);\r\ncdrom_release(&info->devinfo, mode);\r\nide_cd_put(info);\r\nmutex_unlock(&ide_cd_mutex);\r\n}\r\nstatic int idecd_set_spindown(struct cdrom_device_info *cdi, unsigned long arg)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[16];\r\nint stat;\r\nchar spindown;\r\nif (copy_from_user(&spindown, (void __user *)arg, sizeof(char)))\r\nreturn -EFAULT;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_UNKNOWN);\r\nstat = cdrom_mode_sense(cdi, &cgc, GPMODE_CDROM_PAGE, 0);\r\nif (stat)\r\nreturn stat;\r\nbuffer[11] = (buffer[11] & 0xf0) | (spindown & 0x0f);\r\nreturn cdrom_mode_select(cdi, &cgc);\r\n}\r\nstatic int idecd_get_spindown(struct cdrom_device_info *cdi, unsigned long arg)\r\n{\r\nstruct packet_command cgc;\r\nchar buffer[16];\r\nint stat;\r\nchar spindown;\r\ninit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_UNKNOWN);\r\nstat = cdrom_mode_sense(cdi, &cgc, GPMODE_CDROM_PAGE, 0);\r\nif (stat)\r\nreturn stat;\r\nspindown = buffer[11] & 0x0f;\r\nif (copy_to_user((void __user *)arg, &spindown, sizeof(char)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int idecd_locked_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cdrom_info *info = ide_drv_g(bdev->bd_disk, cdrom_info);\r\nint err;\r\nswitch (cmd) {\r\ncase CDROMSETSPINDOWN:\r\nreturn idecd_set_spindown(&info->devinfo, arg);\r\ncase CDROMGETSPINDOWN:\r\nreturn idecd_get_spindown(&info->devinfo, arg);\r\ndefault:\r\nbreak;\r\n}\r\nerr = generic_ide_ioctl(info->drive, bdev, cmd, arg);\r\nif (err == -EINVAL)\r\nerr = cdrom_ioctl(&info->devinfo, bdev, mode, cmd, arg);\r\nreturn err;\r\n}\r\nstatic int idecd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&ide_cd_mutex);\r\nret = idecd_locked_ioctl(bdev, mode, cmd, arg);\r\nmutex_unlock(&ide_cd_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int idecd_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct cdrom_info *info = ide_drv_g(disk, cdrom_info);\r\nreturn cdrom_check_events(&info->devinfo, clearing);\r\n}\r\nstatic int idecd_revalidate_disk(struct gendisk *disk)\r\n{\r\nstruct cdrom_info *info = ide_drv_g(disk, cdrom_info);\r\nstruct request_sense sense;\r\nide_cd_read_toc(info->drive, &sense);\r\nreturn 0;\r\n}\r\nstatic int ide_cd_probe(ide_drive_t *drive)\r\n{\r\nstruct cdrom_info *info;\r\nstruct gendisk *g;\r\nstruct request_sense sense;\r\nide_debug_log(IDE_DBG_PROBE, "driver_req: %s, media: 0x%x",\r\ndrive->driver_req, drive->media);\r\nif (!strstr("ide-cdrom", drive->driver_req))\r\ngoto failed;\r\nif (drive->media != ide_cdrom && drive->media != ide_optical)\r\ngoto failed;\r\ndrive->debug_mask = debug_mask;\r\ndrive->irq_handler = cdrom_newpc_intr;\r\ninfo = kzalloc(sizeof(struct cdrom_info), GFP_KERNEL);\r\nif (info == NULL) {\r\nprintk(KERN_ERR PFX "%s: Can't allocate a cdrom structure\n",\r\ndrive->name);\r\ngoto failed;\r\n}\r\ng = alloc_disk(1 << PARTN_BITS);\r\nif (!g)\r\ngoto out_free_cd;\r\nide_init_disk(g, drive);\r\ninfo->dev.parent = &drive->gendev;\r\ninfo->dev.release = ide_cd_release;\r\ndev_set_name(&info->dev, "%s", dev_name(&drive->gendev));\r\nif (device_register(&info->dev))\r\ngoto out_free_disk;\r\ninfo->drive = drive;\r\ninfo->driver = &ide_cdrom_driver;\r\ninfo->disk = g;\r\ng->private_data = &info->driver;\r\ndrive->driver_data = info;\r\ng->minors = 1;\r\ng->driverfs_dev = &drive->gendev;\r\ng->flags = GENHD_FL_CD | GENHD_FL_REMOVABLE;\r\nif (ide_cdrom_setup(drive)) {\r\nput_device(&info->dev);\r\ngoto failed;\r\n}\r\nide_cd_read_toc(drive, &sense);\r\ng->fops = &idecd_ops;\r\ng->flags |= GENHD_FL_REMOVABLE | GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\r\nadd_disk(g);\r\nreturn 0;\r\nout_free_disk:\r\nput_disk(g);\r\nout_free_cd:\r\nkfree(info);\r\nfailed:\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit ide_cdrom_exit(void)\r\n{\r\ndriver_unregister(&ide_cdrom_driver.gen_driver);\r\n}\r\nstatic int __init ide_cdrom_init(void)\r\n{\r\nprintk(KERN_INFO DRV_NAME " driver " IDECD_VERSION "\n");\r\nreturn driver_register(&ide_cdrom_driver.gen_driver);\r\n}
