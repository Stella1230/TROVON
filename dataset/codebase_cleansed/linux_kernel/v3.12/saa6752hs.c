static inline struct saa6752hs_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa6752hs_state, sd);\r\n}\r\nstatic int saa6752hs_chip_command(struct i2c_client *client,\r\nenum saa6752hs_command command)\r\n{\r\nunsigned char buf[3];\r\nunsigned long timeout;\r\nint status = 0;\r\nswitch(command) {\r\ncase SAA6752HS_COMMAND_RESET:\r\nbuf[0] = 0x00;\r\nbreak;\r\ncase SAA6752HS_COMMAND_STOP:\r\nbuf[0] = 0x03;\r\nbreak;\r\ncase SAA6752HS_COMMAND_START:\r\nbuf[0] = 0x02;\r\nbreak;\r\ncase SAA6752HS_COMMAND_PAUSE:\r\nbuf[0] = 0x04;\r\nbreak;\r\ncase SAA6752HS_COMMAND_RECONFIGURE:\r\nbuf[0] = 0x05;\r\nbreak;\r\ncase SAA6752HS_COMMAND_SLEEP:\r\nbuf[0] = 0x06;\r\nbreak;\r\ncase SAA6752HS_COMMAND_RECONFIGURE_FORCE:\r\nbuf[0] = 0x07;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni2c_master_send(client, buf, 1);\r\ntimeout = jiffies + HZ * 3;\r\nfor (;;) {\r\nbuf[0] = 0x10;\r\ni2c_master_send(client, buf, 1);\r\ni2c_master_recv(client, buf, 1);\r\nif (!(buf[0] & 0x20))\r\nbreak;\r\nif (time_after(jiffies,timeout)) {\r\nstatus = -ETIMEDOUT;\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nmsleep(50);\r\nreturn status;\r\n}\r\nstatic inline void set_reg8(struct i2c_client *client, uint8_t reg, uint8_t val)\r\n{\r\nu8 buf[2];\r\nbuf[0] = reg;\r\nbuf[1] = val;\r\ni2c_master_send(client, buf, 2);\r\n}\r\nstatic inline void set_reg16(struct i2c_client *client, uint8_t reg, uint16_t val)\r\n{\r\nu8 buf[3];\r\nbuf[0] = reg;\r\nbuf[1] = val >> 8;\r\nbuf[2] = val & 0xff;\r\ni2c_master_send(client, buf, 3);\r\n}\r\nstatic int saa6752hs_set_bitrate(struct i2c_client *client,\r\nstruct saa6752hs_state *h)\r\n{\r\nstruct saa6752hs_mpeg_params *params = &h->params;\r\nint tot_bitrate;\r\nint is_384k;\r\nset_reg8(client, 0x71,\r\nparams->vi_bitrate_mode != V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\r\nif (params->vi_bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) {\r\nset_reg16(client, 0x80, params->vi_bitrate);\r\nset_reg16(client, 0x81, params->vi_bitrate_peak);\r\ntot_bitrate = params->vi_bitrate_peak;\r\n} else {\r\nset_reg16(client, 0x81, params->vi_bitrate);\r\ntot_bitrate = params->vi_bitrate;\r\n}\r\nset_reg8(client, 0x93,\r\nparams->au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3);\r\nif (params->au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3)\r\nis_384k = V4L2_MPEG_AUDIO_AC3_BITRATE_384K == params->au_ac3_bitrate;\r\nelse\r\nis_384k = V4L2_MPEG_AUDIO_L2_BITRATE_384K == params->au_l2_bitrate;\r\nset_reg8(client, 0x94, is_384k);\r\ntot_bitrate += is_384k ? 384 : 256;\r\ntot_bitrate += 768;\r\nif (tot_bitrate > MPEG_TOTAL_TARGET_BITRATE_MAX)\r\ntot_bitrate = MPEG_TOTAL_TARGET_BITRATE_MAX;\r\nset_reg16(client, 0xb1, tot_bitrate);\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_try_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct saa6752hs_state *h =\r\ncontainer_of(ctrl->handler, struct saa6752hs_state, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nif (ctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&\r\nh->video_bitrate_peak->val < h->video_bitrate->val)\r\nh->video_bitrate_peak->val = h->video_bitrate->val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct saa6752hs_state *h =\r\ncontainer_of(ctrl->handler, struct saa6752hs_state, hdl);\r\nstruct saa6752hs_mpeg_params *params = &h->params;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_PMT:\r\nparams->ts_pid_pmt = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_AUDIO:\r\nparams->ts_pid_audio = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_VIDEO:\r\nparams->ts_pid_video = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_PCR:\r\nparams->ts_pid_pcr = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nparams->au_encoding = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nparams->au_l2_bitrate = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nparams->au_ac3_bitrate = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nparams->vi_aspect = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nparams->vi_bitrate_mode = ctrl->val;\r\nparams->vi_bitrate = h->video_bitrate->val / 1000;\r\nparams->vi_bitrate_peak = h->video_bitrate_peak->val / 1000;\r\nv4l2_ctrl_activate(h->video_bitrate_peak,\r\nctrl->val == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_init(struct v4l2_subdev *sd, u32 leading_null_bytes)\r\n{\r\nunsigned char buf[9], buf2[4];\r\nstruct saa6752hs_state *h = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nunsigned size;\r\nu32 crc;\r\nunsigned char localPAT[256];\r\nunsigned char localPMT[256];\r\nset_reg8(client, 0x41, h->video_format);\r\nset_reg8(client, 0x40, (h->standard & V4L2_STD_525_60) ? 1 : 0);\r\nsaa6752hs_set_bitrate(client, h);\r\nset_reg16(client, 0x72, 0x030d);\r\nset_reg8(client, 0x82, 0x04);\r\nset_reg8(client, 0x83, 0x0c);\r\nset_reg8(client, 0xd0, 0x81);\r\nset_reg8(client, 0xb0, 0x05);\r\nset_reg16(client, 0xf6, leading_null_bytes);\r\nmemcpy(localPAT, PAT, sizeof(PAT));\r\nlocalPAT[17] = 0xe0 | ((h->params.ts_pid_pmt >> 8) & 0x0f);\r\nlocalPAT[18] = h->params.ts_pid_pmt & 0xff;\r\ncrc = crc32_be(~0, &localPAT[7], sizeof(PAT) - 7 - 4);\r\nlocalPAT[sizeof(PAT) - 4] = (crc >> 24) & 0xFF;\r\nlocalPAT[sizeof(PAT) - 3] = (crc >> 16) & 0xFF;\r\nlocalPAT[sizeof(PAT) - 2] = (crc >> 8) & 0xFF;\r\nlocalPAT[sizeof(PAT) - 1] = crc & 0xFF;\r\nif (h->params.au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3) {\r\nsize = sizeof(PMT_AC3);\r\nmemcpy(localPMT, PMT_AC3, size);\r\n} else {\r\nsize = sizeof(PMT);\r\nmemcpy(localPMT, PMT, size);\r\n}\r\nlocalPMT[3] = 0x40 | ((h->params.ts_pid_pmt >> 8) & 0x0f);\r\nlocalPMT[4] = h->params.ts_pid_pmt & 0xff;\r\nlocalPMT[15] = 0xE0 | ((h->params.ts_pid_pcr >> 8) & 0x0F);\r\nlocalPMT[16] = h->params.ts_pid_pcr & 0xFF;\r\nlocalPMT[20] = 0xE0 | ((h->params.ts_pid_video >> 8) & 0x0F);\r\nlocalPMT[21] = h->params.ts_pid_video & 0xFF;\r\nlocalPMT[25] = 0xE0 | ((h->params.ts_pid_audio >> 8) & 0x0F);\r\nlocalPMT[26] = h->params.ts_pid_audio & 0xFF;\r\ncrc = crc32_be(~0, &localPMT[7], size - 7 - 4);\r\nlocalPMT[size - 4] = (crc >> 24) & 0xFF;\r\nlocalPMT[size - 3] = (crc >> 16) & 0xFF;\r\nlocalPMT[size - 2] = (crc >> 8) & 0xFF;\r\nlocalPMT[size - 1] = crc & 0xFF;\r\nset_reg16(client, 0xc1, h->params.ts_pid_audio);\r\nset_reg16(client, 0xc0, h->params.ts_pid_video);\r\nset_reg16(client, 0xc4, h->params.ts_pid_pcr);\r\ni2c_master_send(client, localPAT, sizeof(PAT));\r\ni2c_master_send(client, localPMT, size);\r\nset_reg8(client, 0xa4, 1);\r\nset_reg8(client, 0xa4, 0);\r\nsaa6752hs_chip_command(client, SAA6752HS_COMMAND_START);\r\nbuf[0] = 0xE1;\r\nbuf[1] = 0xA7;\r\nbuf[2] = 0xFE;\r\nbuf[3] = 0x82;\r\nbuf[4] = 0xB0;\r\ni2c_master_send(client, buf, 5);\r\ni2c_master_recv(client, buf2, 4);\r\nbuf[0] = 0xE0;\r\nbuf[1] = 0xA7;\r\nbuf[2] = 0xFE;\r\nbuf[3] = 0x82;\r\nbuf[4] = 0xB0;\r\nbuf[5] = buf2[0];\r\nswitch (h->params.vi_aspect) {\r\ncase V4L2_MPEG_VIDEO_ASPECT_16x9:\r\nbuf[6] = buf2[1] | 0x40;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_4x3:\r\ndefault:\r\nbuf[6] = buf2[1] & 0xBF;\r\nbreak;\r\n}\r\nbuf[7] = buf2[2];\r\nbuf[8] = buf2[3];\r\ni2c_master_send(client, buf, 9);\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_g_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nif (h->video_format == SAA6752HS_VF_UNKNOWN)\r\nh->video_format = SAA6752HS_VF_D1;\r\nf->width = v4l2_format_table[h->video_format].fmt.pix.width;\r\nf->height = v4l2_format_table[h->video_format].fmt.pix.height;\r\nf->code = V4L2_MBUS_FMT_FIXED;\r\nf->field = V4L2_FIELD_INTERLACED;\r\nf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_try_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nint dist_352, dist_480, dist_720;\r\nf->code = V4L2_MBUS_FMT_FIXED;\r\ndist_352 = abs(f->width - 352);\r\ndist_480 = abs(f->width - 480);\r\ndist_720 = abs(f->width - 720);\r\nif (dist_720 < dist_480) {\r\nf->width = 720;\r\nf->height = 576;\r\n} else if (dist_480 < dist_352) {\r\nf->width = 480;\r\nf->height = 576;\r\n} else {\r\nf->width = 352;\r\nif (abs(f->height - 576) < abs(f->height - 288))\r\nf->height = 576;\r\nelse\r\nf->height = 288;\r\n}\r\nf->field = V4L2_FIELD_INTERLACED;\r\nf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_s_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nif (f->code != V4L2_MBUS_FMT_FIXED)\r\nreturn -EINVAL;\r\nsaa6752hs_try_mbus_fmt(sd, f);\r\nif (f->width == 720)\r\nh->video_format = SAA6752HS_VF_D1;\r\nelse if (f->width == 480)\r\nh->video_format = SAA6752HS_VF_2_3_D1;\r\nelse if (f->height == 576)\r\nh->video_format = SAA6752HS_VF_1_2_D1;\r\nelse\r\nh->video_format = SAA6752HS_VF_SIF;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nh->standard = std;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa6752hs_state *h = kzalloc(sizeof(*h), GFP_KERNEL);\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nu8 addr = 0x13;\r\nu8 data[12];\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nif (h == NULL)\r\nreturn -ENOMEM;\r\nsd = &h->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa6752hs_ops);\r\ni2c_master_send(client, &addr, 1);\r\ni2c_master_recv(client, data, sizeof(data));\r\nh->revision = (data[8] << 8) | data[9];\r\nh->has_ac3 = 0;\r\nif (h->revision == 0x0206) {\r\nh->has_ac3 = 1;\r\nv4l_info(client, "supports AC-3\n");\r\n}\r\nh->params = param_defaults;\r\nhdl = &h->hdl;\r\nv4l2_ctrl_handler_init(hdl, 14);\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_AUDIO_ENCODING,\r\nh->has_ac3 ? V4L2_MPEG_AUDIO_ENCODING_AC3 :\r\nV4L2_MPEG_AUDIO_ENCODING_LAYER_2,\r\n0x0d, V4L2_MPEG_AUDIO_ENCODING_LAYER_2);\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_AUDIO_L2_BITRATE,\r\nV4L2_MPEG_AUDIO_L2_BITRATE_384K,\r\n~((1 << V4L2_MPEG_AUDIO_L2_BITRATE_256K) |\r\n(1 << V4L2_MPEG_AUDIO_L2_BITRATE_384K)),\r\nV4L2_MPEG_AUDIO_L2_BITRATE_256K);\r\nif (h->has_ac3)\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_AUDIO_AC3_BITRATE,\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_384K,\r\n~((1 << V4L2_MPEG_AUDIO_AC3_BITRATE_256K) |\r\n(1 << V4L2_MPEG_AUDIO_AC3_BITRATE_384K)),\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_256K);\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_AUDIO_SAMPLING_FREQ,\r\nV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000,\r\n~(1 << V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000),\r\nV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000);\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_ENCODING,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_2,\r\n~(1 << V4L2_MPEG_VIDEO_ENCODING_MPEG_2),\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_2);\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_ASPECT,\r\nV4L2_MPEG_VIDEO_ASPECT_16x9, 0x01,\r\nV4L2_MPEG_VIDEO_ASPECT_4x3);\r\nh->video_bitrate_peak = v4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\r\n1000000, 27000000, 1000, 8000000);\r\nv4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_STREAM_TYPE,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS,\r\n~(1 << V4L2_MPEG_STREAM_TYPE_MPEG2_TS),\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS);\r\nh->video_bitrate_mode = v4l2_ctrl_new_std_menu(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\r\nh->video_bitrate = v4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_BITRATE, 1000000, 27000000, 1000, 6000000);\r\nv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_STREAM_PID_PMT, 0, (1 << 14) - 1, 1, 16);\r\nv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_STREAM_PID_AUDIO, 0, (1 << 14) - 1, 1, 260);\r\nv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_STREAM_PID_VIDEO, 0, (1 << 14) - 1, 1, 256);\r\nv4l2_ctrl_new_std(hdl, &saa6752hs_ctrl_ops,\r\nV4L2_CID_MPEG_STREAM_PID_PCR, 0, (1 << 14) - 1, 1, 259);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nkfree(h);\r\nreturn err;\r\n}\r\nv4l2_ctrl_cluster(3, &h->video_bitrate_mode);\r\nv4l2_ctrl_handler_setup(hdl);\r\nh->standard = 0;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&to_state(sd)->hdl);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
