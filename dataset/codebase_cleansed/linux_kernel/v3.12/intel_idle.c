static int intel_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int index)\r\n{\r\nunsigned long ecx = 1;\r\nstruct cpuidle_state *state = &drv->states[index];\r\nunsigned long eax = flg2MWAIT(state->flags);\r\nunsigned int cstate;\r\nint cpu = smp_processor_id();\r\ncstate = (((eax) >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) + 1;\r\nif (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)\r\nleave_mm(cpu);\r\nif (!(lapic_timer_reliable_states & (1 << (cstate))))\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);\r\nif (!need_resched()) {\r\n__monitor((void *)&current_thread_info()->flags, 0, 0);\r\nsmp_mb();\r\nif (!need_resched())\r\n__mwait(eax, ecx);\r\n}\r\nif (!(lapic_timer_reliable_states & (1 << (cstate))))\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);\r\nreturn index;\r\n}\r\nstatic void __setup_broadcast_timer(void *arg)\r\n{\r\nunsigned long reason = (unsigned long)arg;\r\nint cpu = smp_processor_id();\r\nreason = reason ?\r\nCLOCK_EVT_NOTIFY_BROADCAST_ON : CLOCK_EVT_NOTIFY_BROADCAST_OFF;\r\nclockevents_notify(reason, &cpu);\r\n}\r\nstatic int cpu_hotplug_notify(struct notifier_block *n,\r\nunsigned long action, void *hcpu)\r\n{\r\nint hotcpu = (unsigned long)hcpu;\r\nstruct cpuidle_device *dev;\r\nswitch (action & 0xf) {\r\ncase CPU_ONLINE:\r\nif (lapic_timer_reliable_states != LAPIC_TIMER_ALWAYS_RELIABLE)\r\nsmp_call_function_single(hotcpu, __setup_broadcast_timer,\r\n(void *)true, 1);\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, hotcpu);\r\nif (!dev->registered)\r\nintel_idle_cpu_init(hotcpu);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void auto_demotion_disable(void *dummy)\r\n{\r\nunsigned long long msr_bits;\r\nrdmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr_bits);\r\nmsr_bits &= ~(icpu->auto_demotion_disable_flags);\r\nwrmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr_bits);\r\n}\r\nstatic void c1e_promotion_disable(void *dummy)\r\n{\r\nunsigned long long msr_bits;\r\nrdmsrl(MSR_IA32_POWER_CTL, msr_bits);\r\nmsr_bits &= ~0x2;\r\nwrmsrl(MSR_IA32_POWER_CTL, msr_bits);\r\n}\r\nstatic int intel_idle_probe(void)\r\n{\r\nunsigned int eax, ebx, ecx;\r\nconst struct x86_cpu_id *id;\r\nif (max_cstate == 0) {\r\npr_debug(PREFIX "disabled\n");\r\nreturn -EPERM;\r\n}\r\nid = x86_match_cpu(intel_idle_ids);\r\nif (!id) {\r\nif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\r\nboot_cpu_data.x86 == 6)\r\npr_debug(PREFIX "does not run on family %d model %d\n",\r\nboot_cpu_data.x86, boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\r\nreturn -ENODEV;\r\ncpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &mwait_substates);\r\nif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\r\n!(ecx & CPUID5_ECX_INTERRUPT_BREAK) ||\r\n!mwait_substates)\r\nreturn -ENODEV;\r\npr_debug(PREFIX "MWAIT substates: 0x%x\n", mwait_substates);\r\nicpu = (const struct idle_cpu *)id->driver_data;\r\ncpuidle_state_table = icpu->state_table;\r\nif (boot_cpu_has(X86_FEATURE_ARAT))\r\nlapic_timer_reliable_states = LAPIC_TIMER_ALWAYS_RELIABLE;\r\nelse\r\non_each_cpu(__setup_broadcast_timer, (void *)true, 1);\r\npr_debug(PREFIX "v" INTEL_IDLE_VERSION\r\n" model 0x%X\n", boot_cpu_data.x86_model);\r\npr_debug(PREFIX "lapic_timer_reliable_states 0x%x\n",\r\nlapic_timer_reliable_states);\r\nreturn 0;\r\n}\r\nstatic void intel_idle_cpuidle_devices_uninit(void)\r\n{\r\nint i;\r\nstruct cpuidle_device *dev;\r\nfor_each_online_cpu(i) {\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, i);\r\ncpuidle_unregister_device(dev);\r\n}\r\nfree_percpu(intel_idle_cpuidle_devices);\r\nreturn;\r\n}\r\nstatic int intel_idle_cpuidle_driver_init(void)\r\n{\r\nint cstate;\r\nstruct cpuidle_driver *drv = &intel_idle_driver;\r\ndrv->state_count = 1;\r\nfor (cstate = 0; cstate < CPUIDLE_STATE_MAX; ++cstate) {\r\nint num_substates, mwait_hint, mwait_cstate, mwait_substate;\r\nif (cpuidle_state_table[cstate].enter == NULL)\r\nbreak;\r\nif (cstate + 1 > max_cstate) {\r\nprintk(PREFIX "max_cstate %d reached\n",\r\nmax_cstate);\r\nbreak;\r\n}\r\nmwait_hint = flg2MWAIT(cpuidle_state_table[cstate].flags);\r\nmwait_cstate = MWAIT_HINT2CSTATE(mwait_hint);\r\nmwait_substate = MWAIT_HINT2SUBSTATE(mwait_hint);\r\nnum_substates = (mwait_substates >> ((mwait_cstate + 1) * 4))\r\n& MWAIT_SUBSTATE_MASK;\r\nif ((mwait_substate + 1) > num_substates)\r\ncontinue;\r\nif (((mwait_cstate + 1) > 2) &&\r\n!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))\r\nmark_tsc_unstable("TSC halts in idle"\r\n" states deeper than C2");\r\ndrv->states[drv->state_count] =\r\ncpuidle_state_table[cstate];\r\ndrv->state_count += 1;\r\n}\r\nif (icpu->auto_demotion_disable_flags)\r\non_each_cpu(auto_demotion_disable, NULL, 1);\r\nif (icpu->disable_promotion_to_c1e)\r\non_each_cpu(c1e_promotion_disable, NULL, 1);\r\nreturn 0;\r\n}\r\nstatic int intel_idle_cpu_init(int cpu)\r\n{\r\nint cstate;\r\nstruct cpuidle_device *dev;\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, cpu);\r\ndev->state_count = 1;\r\nfor (cstate = 0; cstate < CPUIDLE_STATE_MAX; ++cstate) {\r\nint num_substates, mwait_hint, mwait_cstate, mwait_substate;\r\nif (cpuidle_state_table[cstate].enter == NULL)\r\ncontinue;\r\nif (cstate + 1 > max_cstate) {\r\nprintk(PREFIX "max_cstate %d reached\n", max_cstate);\r\nbreak;\r\n}\r\nmwait_hint = flg2MWAIT(cpuidle_state_table[cstate].flags);\r\nmwait_cstate = MWAIT_HINT2CSTATE(mwait_hint);\r\nmwait_substate = MWAIT_HINT2SUBSTATE(mwait_hint);\r\nnum_substates = (mwait_substates >> ((mwait_cstate + 1) * 4))\r\n& MWAIT_SUBSTATE_MASK;\r\nif ((mwait_substate + 1) > num_substates)\r\ncontinue;\r\ndev->state_count += 1;\r\n}\r\ndev->cpu = cpu;\r\nif (cpuidle_register_device(dev)) {\r\npr_debug(PREFIX "cpuidle_register_device %d failed!\n", cpu);\r\nintel_idle_cpuidle_devices_uninit();\r\nreturn -EIO;\r\n}\r\nif (icpu->auto_demotion_disable_flags)\r\nsmp_call_function_single(cpu, auto_demotion_disable, NULL, 1);\r\nreturn 0;\r\n}\r\nstatic int __init intel_idle_init(void)\r\n{\r\nint retval, i;\r\nif (boot_option_idle_override != IDLE_NO_OVERRIDE)\r\nreturn -ENODEV;\r\nretval = intel_idle_probe();\r\nif (retval)\r\nreturn retval;\r\nintel_idle_cpuidle_driver_init();\r\nretval = cpuidle_register_driver(&intel_idle_driver);\r\nif (retval) {\r\nstruct cpuidle_driver *drv = cpuidle_get_driver();\r\nprintk(KERN_DEBUG PREFIX "intel_idle yielding to %s",\r\ndrv ? drv->name : "none");\r\nreturn retval;\r\n}\r\nintel_idle_cpuidle_devices = alloc_percpu(struct cpuidle_device);\r\nif (intel_idle_cpuidle_devices == NULL)\r\nreturn -ENOMEM;\r\nfor_each_online_cpu(i) {\r\nretval = intel_idle_cpu_init(i);\r\nif (retval) {\r\ncpuidle_unregister_driver(&intel_idle_driver);\r\nreturn retval;\r\n}\r\n}\r\nregister_cpu_notifier(&cpu_hotplug_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit intel_idle_exit(void)\r\n{\r\nintel_idle_cpuidle_devices_uninit();\r\ncpuidle_unregister_driver(&intel_idle_driver);\r\nif (lapic_timer_reliable_states != LAPIC_TIMER_ALWAYS_RELIABLE)\r\non_each_cpu(__setup_broadcast_timer, (void *)false, 1);\r\nunregister_cpu_notifier(&cpu_hotplug_notifier);\r\nreturn;\r\n}
