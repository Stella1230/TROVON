static void event_dump(void)\r\n{\r\n}\r\nstatic void EVENT(const char *s,unsigned long a,unsigned long b)\r\n{\r\nev[ec] = s;\r\nev_a[ec] = a;\r\nev_b[ec] = b;\r\nec = (ec+1) % EV;\r\n}\r\nstatic void event_dump(void)\r\n{\r\nint n,i;\r\nfor (n = 0; n < EV; n++) {\r\ni = (ec+n) % EV;\r\nprintk(KERN_NOTICE);\r\nprintk(ev[i] ? ev[i] : "(null)",ev_a[i],ev_b[i]);\r\n}\r\n}\r\nstatic void dump_mem(struct eni_dev *eni_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < eni_dev->free_len; i++)\r\nprintk(KERN_DEBUG " %d: %p %d\n",i,\r\neni_dev->free_list[i].start,\r\n1 << eni_dev->free_list[i].order);\r\n}\r\nstatic void dump(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nint i;\r\neni_dev = ENI_DEV(dev);\r\nprintk(KERN_NOTICE "Free memory\n");\r\ndump_mem(eni_dev);\r\nprintk(KERN_NOTICE "TX buffers\n");\r\nfor (i = 0; i < NR_CHAN; i++)\r\nif (eni_dev->tx[i].send)\r\nprintk(KERN_NOTICE " TX %d @ %p: %ld\n",i,\r\neni_dev->tx[i].send,eni_dev->tx[i].words*4);\r\nprintk(KERN_NOTICE "RX buffers\n");\r\nfor (i = 0; i < 1024; i++)\r\nif (eni_dev->rx_map[i] && ENI_VCC(eni_dev->rx_map[i])->rx)\r\nprintk(KERN_NOTICE " RX %d @ %p: %ld\n",i,\r\nENI_VCC(eni_dev->rx_map[i])->recv,\r\nENI_VCC(eni_dev->rx_map[i])->words*4);\r\nprintk(KERN_NOTICE "----\n");\r\n}\r\nstatic void eni_put_free(struct eni_dev *eni_dev, void __iomem *start,\r\nunsigned long size)\r\n{\r\nstruct eni_free *list;\r\nint len,order;\r\nDPRINTK("init 0x%lx+%ld(0x%lx)\n",start,size,size);\r\nstart += eni_dev->base_diff;\r\nlist = eni_dev->free_list;\r\nlen = eni_dev->free_len;\r\nwhile (size) {\r\nif (len >= eni_dev->free_list_size) {\r\nprintk(KERN_CRIT "eni_put_free overflow (%p,%ld)\n",\r\nstart,size);\r\nbreak;\r\n}\r\nfor (order = 0; !(((unsigned long)start | size) & (1 << order)); order++);\r\nif (MID_MIN_BUF_SIZE > (1 << order)) {\r\nprintk(KERN_CRIT "eni_put_free: order %d too small\n",\r\norder);\r\nbreak;\r\n}\r\nlist[len].start = (void __iomem *) start;\r\nlist[len].order = order;\r\nlen++;\r\nstart += 1 << order;\r\nsize -= 1 << order;\r\n}\r\neni_dev->free_len = len;\r\n}\r\nstatic void __iomem *eni_alloc_mem(struct eni_dev *eni_dev, unsigned long *size)\r\n{\r\nstruct eni_free *list;\r\nvoid __iomem *start;\r\nint len,i,order,best_order,index;\r\nlist = eni_dev->free_list;\r\nlen = eni_dev->free_len;\r\nif (*size < MID_MIN_BUF_SIZE) *size = MID_MIN_BUF_SIZE;\r\nif (*size > MID_MAX_BUF_SIZE) return NULL;\r\nfor (order = 0; (1 << order) < *size; order++);\r\nDPRINTK("trying: %ld->%d\n",*size,order);\r\nbest_order = 65;\r\nindex = 0;\r\nfor (i = 0; i < len; i++)\r\nif (list[i].order == order) {\r\nbest_order = order;\r\nindex = i;\r\nbreak;\r\n}\r\nelse if (best_order > list[i].order && list[i].order > order) {\r\nbest_order = list[i].order;\r\nindex = i;\r\n}\r\nif (best_order == 65) return NULL;\r\nstart = list[index].start-eni_dev->base_diff;\r\nlist[index] = list[--len];\r\neni_dev->free_len = len;\r\n*size = 1 << order;\r\neni_put_free(eni_dev,start+*size,(1 << best_order)-*size);\r\nDPRINTK("%ld bytes (order %d) at 0x%lx\n",*size,order,start);\r\nmemset_io(start,0,*size);\r\nreturn start;\r\n}\r\nstatic void eni_free_mem(struct eni_dev *eni_dev, void __iomem *start,\r\nunsigned long size)\r\n{\r\nstruct eni_free *list;\r\nint len,i,order;\r\nstart += eni_dev->base_diff;\r\nlist = eni_dev->free_list;\r\nlen = eni_dev->free_len;\r\nfor (order = -1; size; order++) size >>= 1;\r\nDPRINTK("eni_free_mem: %p+0x%lx (order %d)\n",start,size,order);\r\nfor (i = 0; i < len; i++)\r\nif (((unsigned long) list[i].start) == ((unsigned long)start^(1 << order)) &&\r\nlist[i].order == order) {\r\nDPRINTK("match[%d]: 0x%lx/0x%lx(0x%x), %d/%d\n",i,\r\nlist[i].start,start,1 << order,list[i].order,order);\r\nlist[i] = list[--len];\r\nstart = (void __iomem *) ((unsigned long) start & ~(unsigned long) (1 << order));\r\norder++;\r\ni = -1;\r\ncontinue;\r\n}\r\nif (len >= eni_dev->free_list_size) {\r\nprintk(KERN_ALERT "eni_free_mem overflow (%p,%d)\n",start,\r\norder);\r\nreturn;\r\n}\r\nlist[len].start = start;\r\nlist[len].order = order;\r\neni_dev->free_len = len+1;\r\n}\r\nstatic void rx_ident_err(struct atm_vcc *vcc)\r\n{\r\nstruct atm_dev *dev;\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\ndev = vcc->dev;\r\neni_dev = ENI_DEV(dev);\r\neni_out(eni_in(MID_MC_S) &\r\n~(MID_DMA_ENABLE | MID_TX_ENABLE | MID_RX_ENABLE),MID_MC_S);\r\neni_vcc = ENI_VCC(vcc);\r\nprintk(KERN_ALERT DEV_LABEL "(itf %d): driver error - RX ident "\r\n"mismatch\n",dev->number);\r\nprintk(KERN_ALERT " VCI %d, rxing %d, words %ld\n",vcc->vci,\r\neni_vcc->rxing,eni_vcc->words);\r\nprintk(KERN_ALERT " host descr 0x%lx, rx pos 0x%lx, descr value "\r\n"0x%x\n",eni_vcc->descr,eni_vcc->rx_pos,\r\n(unsigned) readl(eni_vcc->recv+eni_vcc->descr*4));\r\nprintk(KERN_ALERT " last %p, servicing %d\n",eni_vcc->last,\r\neni_vcc->servicing);\r\nEVENT("---dump ends here---\n",0,0);\r\nprintk(KERN_NOTICE "---recent events---\n");\r\nevent_dump();\r\nENI_DEV(dev)->fast = NULL;\r\nENI_DEV(dev)->slow = NULL;\r\nskb_queue_head_init(&ENI_DEV(dev)->rx_queue);\r\n}\r\nstatic int do_rx_dma(struct atm_vcc *vcc,struct sk_buff *skb,\r\nunsigned long skip,unsigned long size,unsigned long eff)\r\n{\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\nu32 dma_rd,dma_wr;\r\nu32 dma[RX_DMA_BUF*2];\r\ndma_addr_t paddr;\r\nunsigned long here;\r\nint i,j;\r\neni_dev = ENI_DEV(vcc->dev);\r\neni_vcc = ENI_VCC(vcc);\r\npaddr = 0;\r\nif (skb) {\r\npaddr = pci_map_single(eni_dev->pci_dev,skb->data,skb->len,\r\nPCI_DMA_FROMDEVICE);\r\nENI_PRV_PADDR(skb) = paddr;\r\nif (paddr & 3)\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): VCI %d has "\r\n"mis-aligned RX data (0x%lx)\n",vcc->dev->number,\r\nvcc->vci,(unsigned long) paddr);\r\nENI_PRV_SIZE(skb) = size+skip;\r\nATM_SKB(skb)->vcc = vcc;\r\n}\r\nj = 0;\r\nif ((eff && skip) || 1) {\r\nhere = (eni_vcc->descr+skip) & (eni_vcc->words-1);\r\ndma[j++] = (here << MID_DMA_COUNT_SHIFT) | (vcc->vci\r\n<< MID_DMA_VCI_SHIFT) | MID_DT_JK;\r\nj++;\r\n}\r\nhere = (eni_vcc->descr+size+skip) & (eni_vcc->words-1);\r\nif (!eff) size += skip;\r\nelse {\r\nunsigned long words;\r\nif (!size) {\r\nDPRINTK("strange things happen ...\n");\r\nEVENT("strange things happen ... (skip=%ld,eff=%ld)\n",\r\nsize,eff);\r\n}\r\nwords = eff;\r\nif (paddr & 15) {\r\nunsigned long init;\r\ninit = 4-((paddr & 15) >> 2);\r\nif (init > words) init = words;\r\ndma[j++] = MID_DT_WORD | (init << MID_DMA_COUNT_SHIFT) |\r\n(vcc->vci << MID_DMA_VCI_SHIFT);\r\ndma[j++] = paddr;\r\npaddr += init << 2;\r\nwords -= init;\r\n}\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_16W\r\nif (words & ~15) {\r\ndma[j++] = MID_DT_16W | ((words >> 4) <<\r\nMID_DMA_COUNT_SHIFT) | (vcc->vci <<\r\nMID_DMA_VCI_SHIFT);\r\ndma[j++] = paddr;\r\npaddr += (words & ~15) << 2;\r\nwords &= 15;\r\n}\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_8W\r\nif (words & ~7) {\r\ndma[j++] = MID_DT_8W | ((words >> 3) <<\r\nMID_DMA_COUNT_SHIFT) | (vcc->vci <<\r\nMID_DMA_VCI_SHIFT);\r\ndma[j++] = paddr;\r\npaddr += (words & ~7) << 2;\r\nwords &= 7;\r\n}\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_4W\r\nif (words & ~3) {\r\ndma[j++] = MID_DT_4W | ((words >> 2) <<\r\nMID_DMA_COUNT_SHIFT) | (vcc->vci <<\r\nMID_DMA_VCI_SHIFT);\r\ndma[j++] = paddr;\r\npaddr += (words & ~3) << 2;\r\nwords &= 3;\r\n}\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_2W\r\nif (words & ~1) {\r\ndma[j++] = MID_DT_2W | ((words >> 1) <<\r\nMID_DMA_COUNT_SHIFT) | (vcc->vci <<\r\nMID_DMA_VCI_SHIFT);\r\ndma[j++] = paddr;\r\npaddr += (words & ~1) << 2;\r\nwords &= 1;\r\n}\r\n#endif\r\nif (words) {\r\ndma[j++] = MID_DT_WORD | (words << MID_DMA_COUNT_SHIFT)\r\n| (vcc->vci << MID_DMA_VCI_SHIFT);\r\ndma[j++] = paddr;\r\n}\r\n}\r\nif (size != eff) {\r\ndma[j++] = (here << MID_DMA_COUNT_SHIFT) |\r\n(vcc->vci << MID_DMA_VCI_SHIFT) | MID_DT_JK;\r\nj++;\r\n}\r\nif (!j || j > 2*RX_DMA_BUF) {\r\nprintk(KERN_CRIT DEV_LABEL "!j or j too big!!!\n");\r\ngoto trouble;\r\n}\r\ndma[j-2] |= MID_DMA_END;\r\nj = j >> 1;\r\ndma_wr = eni_in(MID_DMA_WR_RX);\r\ndma_rd = eni_in(MID_DMA_RD_RX);\r\nif (!NEPMOK(dma_wr,j+j+1,dma_rd,NR_DMA_RX)) {\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): RX DMA full\n",\r\nvcc->dev->number);\r\ngoto trouble;\r\n}\r\nfor (i = 0; i < j; i++) {\r\nwritel(dma[i*2],eni_dev->rx_dma+dma_wr*8);\r\nwritel(dma[i*2+1],eni_dev->rx_dma+dma_wr*8+4);\r\ndma_wr = (dma_wr+1) & (NR_DMA_RX-1);\r\n}\r\nif (skb) {\r\nENI_PRV_POS(skb) = eni_vcc->descr+size+1;\r\nskb_queue_tail(&eni_dev->rx_queue,skb);\r\neni_vcc->last = skb;\r\nrx_enqueued++;\r\n}\r\neni_vcc->descr = here;\r\neni_out(dma_wr,MID_DMA_WR_RX);\r\nreturn 0;\r\ntrouble:\r\nif (paddr)\r\npci_unmap_single(eni_dev->pci_dev,paddr,skb->len,\r\nPCI_DMA_FROMDEVICE);\r\nif (skb) dev_kfree_skb_irq(skb);\r\nreturn -1;\r\n}\r\nstatic void discard(struct atm_vcc *vcc,unsigned long size)\r\n{\r\nstruct eni_vcc *eni_vcc;\r\neni_vcc = ENI_VCC(vcc);\r\nEVENT("discard (size=%ld)\n",size,0);\r\nwhile (do_rx_dma(vcc,NULL,1,size,0)) EVENT("BUSY LOOP",0,0);\r\nif (eni_vcc->rxing) ENI_PRV_POS(eni_vcc->last) += size+1;\r\nelse eni_vcc->rx_pos = (eni_vcc->rx_pos+size+1) & (eni_vcc->words-1);\r\n}\r\nstatic int rx_aal0(struct atm_vcc *vcc)\r\n{\r\nstruct eni_vcc *eni_vcc;\r\nunsigned long descr;\r\nunsigned long length;\r\nstruct sk_buff *skb;\r\nDPRINTK(">rx_aal0\n");\r\neni_vcc = ENI_VCC(vcc);\r\ndescr = readl(eni_vcc->recv+eni_vcc->descr*4);\r\nif ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {\r\nrx_ident_err(vcc);\r\nreturn 1;\r\n}\r\nif (descr & MID_RED_T) {\r\nDPRINTK(DEV_LABEL "(itf %d): trashing empty cell\n",\r\nvcc->dev->number);\r\nlength = 0;\r\natomic_inc(&vcc->stats->rx_err);\r\n}\r\nelse {\r\nlength = ATM_CELL_SIZE-1;\r\n}\r\nskb = length ? atm_alloc_charge(vcc,length,GFP_ATOMIC) : NULL;\r\nif (!skb) {\r\ndiscard(vcc,length >> 2);\r\nreturn 0;\r\n}\r\nskb_put(skb,length);\r\nskb->tstamp = eni_vcc->timestamp;\r\nDPRINTK("got len %ld\n",length);\r\nif (do_rx_dma(vcc,skb,1,length >> 2,length >> 2)) return 1;\r\neni_vcc->rxing++;\r\nreturn 0;\r\n}\r\nstatic int rx_aal5(struct atm_vcc *vcc)\r\n{\r\nstruct eni_vcc *eni_vcc;\r\nunsigned long descr;\r\nunsigned long size,eff,length;\r\nstruct sk_buff *skb;\r\nEVENT("rx_aal5\n",0,0);\r\nDPRINTK(">rx_aal5\n");\r\neni_vcc = ENI_VCC(vcc);\r\ndescr = readl(eni_vcc->recv+eni_vcc->descr*4);\r\nif ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {\r\nrx_ident_err(vcc);\r\nreturn 1;\r\n}\r\nif (descr & (MID_RED_T | MID_RED_CRC_ERR)) {\r\nif (descr & MID_RED_T) {\r\nEVENT("empty cell (descr=0x%lx)\n",descr,0);\r\nDPRINTK(DEV_LABEL "(itf %d): trashing empty cell\n",\r\nvcc->dev->number);\r\nsize = 0;\r\n}\r\nelse {\r\nstatic unsigned long silence = 0;\r\nif (time_after(jiffies, silence) || silence == 0) {\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): "\r\n"discarding PDU(s) with CRC error\n",\r\nvcc->dev->number);\r\nsilence = (jiffies+2*HZ)|1;\r\n}\r\nsize = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);\r\nEVENT("CRC error (descr=0x%lx,size=%ld)\n",descr,\r\nsize);\r\n}\r\neff = length = 0;\r\natomic_inc(&vcc->stats->rx_err);\r\n}\r\nelse {\r\nsize = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);\r\nDPRINTK("size=%ld\n",size);\r\nlength = readl(eni_vcc->recv+(((eni_vcc->descr+size-1) &\r\n(eni_vcc->words-1)))*4) & 0xffff;\r\nif (length && length <= (size << 2)-8 && length <=\r\nATM_MAX_AAL5_PDU) eff = (length+3) >> 2;\r\nelse {\r\nEVENT("bad PDU (descr=0x08%lx,length=%ld)\n",descr,\r\nlength);\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): bad AAL5 PDU "\r\n"(VCI=%d,length=%ld,size=%ld (descr 0x%lx))\n",\r\nvcc->dev->number,vcc->vci,length,size << 2,descr);\r\nlength = eff = 0;\r\natomic_inc(&vcc->stats->rx_err);\r\n}\r\n}\r\nskb = eff ? atm_alloc_charge(vcc,eff << 2,GFP_ATOMIC) : NULL;\r\nif (!skb) {\r\ndiscard(vcc,size);\r\nreturn 0;\r\n}\r\nskb_put(skb,length);\r\nDPRINTK("got len %ld\n",length);\r\nif (do_rx_dma(vcc,skb,1,size,eff)) return 1;\r\neni_vcc->rxing++;\r\nreturn 0;\r\n}\r\nstatic inline int rx_vcc(struct atm_vcc *vcc)\r\n{\r\nvoid __iomem *vci_dsc;\r\nunsigned long tmp;\r\nstruct eni_vcc *eni_vcc;\r\neni_vcc = ENI_VCC(vcc);\r\nvci_dsc = ENI_DEV(vcc->dev)->vci+vcc->vci*16;\r\nEVENT("rx_vcc(1)\n",0,0);\r\nwhile (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>\r\nMID_VCI_DESCR_SHIFT)) {\r\nEVENT("rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\n",\r\neni_vcc->descr,tmp);\r\nDPRINTK("CB_DESCR %ld REG_DESCR %d\n",ENI_VCC(vcc)->descr,\r\n(((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>\r\nMID_VCI_DESCR_SHIFT));\r\nif (ENI_VCC(vcc)->rx(vcc)) return 1;\r\n}\r\nwritel(readl(vci_dsc) & ~MID_VCI_IN_SERVICE,vci_dsc);\r\nEVENT("rx_vcc(3)\n",0,0);\r\nwhile (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)\r\n>> MID_VCI_DESCR_SHIFT)) {\r\nEVENT("rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\n",\r\neni_vcc->descr,tmp);\r\nDPRINTK("CB_DESCR %ld REG_DESCR %d\n",ENI_VCC(vcc)->descr,\r\n(((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>\r\nMID_VCI_DESCR_SHIFT));\r\nif (ENI_VCC(vcc)->rx(vcc)) return 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void poll_rx(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nstruct atm_vcc *curr;\r\neni_dev = ENI_DEV(dev);\r\nwhile ((curr = eni_dev->fast)) {\r\nEVENT("poll_rx.fast\n",0,0);\r\nif (rx_vcc(curr)) return;\r\neni_dev->fast = ENI_VCC(curr)->next;\r\nENI_VCC(curr)->next = ENI_VCC_NOS;\r\nbarrier();\r\nENI_VCC(curr)->servicing--;\r\n}\r\nwhile ((curr = eni_dev->slow)) {\r\nEVENT("poll_rx.slow\n",0,0);\r\nif (rx_vcc(curr)) return;\r\neni_dev->slow = ENI_VCC(curr)->next;\r\nENI_VCC(curr)->next = ENI_VCC_NOS;\r\nbarrier();\r\nENI_VCC(curr)->servicing--;\r\n}\r\n}\r\nstatic void get_service(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nstruct atm_vcc *vcc;\r\nunsigned long vci;\r\nDPRINTK(">get_service\n");\r\neni_dev = ENI_DEV(dev);\r\nwhile (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {\r\nvci = readl(eni_dev->service+eni_dev->serv_read*4);\r\neni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);\r\nvcc = eni_dev->rx_map[vci & 1023];\r\nif (!vcc) {\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): VCI %ld not "\r\n"found\n",dev->number,vci);\r\ncontinue;\r\n}\r\nEVENT("getting from service\n",0,0);\r\nif (ENI_VCC(vcc)->next != ENI_VCC_NOS) {\r\nEVENT("double service\n",0,0);\r\nDPRINTK("Grr, servicing VCC %ld twice\n",vci);\r\ncontinue;\r\n}\r\nENI_VCC(vcc)->timestamp = ktime_get_real();\r\nENI_VCC(vcc)->next = NULL;\r\nif (vcc->qos.rxtp.traffic_class == ATM_CBR) {\r\nif (eni_dev->fast)\r\nENI_VCC(eni_dev->last_fast)->next = vcc;\r\nelse eni_dev->fast = vcc;\r\neni_dev->last_fast = vcc;\r\n}\r\nelse {\r\nif (eni_dev->slow)\r\nENI_VCC(eni_dev->last_slow)->next = vcc;\r\nelse eni_dev->slow = vcc;\r\neni_dev->last_slow = vcc;\r\n}\r\nputting++;\r\nENI_VCC(vcc)->servicing++;\r\n}\r\n}\r\nstatic void dequeue_rx(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *skb;\r\nvoid __iomem *vci_dsc;\r\nint first;\r\neni_dev = ENI_DEV(dev);\r\nfirst = 1;\r\nwhile (1) {\r\nskb = skb_dequeue(&eni_dev->rx_queue);\r\nif (!skb) {\r\nif (first) {\r\nDPRINTK(DEV_LABEL "(itf %d): RX but not "\r\n"rxing\n",dev->number);\r\nEVENT("nothing to dequeue\n",0,0);\r\n}\r\nbreak;\r\n}\r\nEVENT("dequeued (size=%ld,pos=0x%lx)\n",ENI_PRV_SIZE(skb),\r\nENI_PRV_POS(skb));\r\nrx_dequeued++;\r\nvcc = ATM_SKB(skb)->vcc;\r\neni_vcc = ENI_VCC(vcc);\r\nfirst = 0;\r\nvci_dsc = eni_dev->vci+vcc->vci*16;\r\nif (!EEPMOK(eni_vcc->rx_pos,ENI_PRV_SIZE(skb),\r\n(readl(vci_dsc+4) & MID_VCI_READ) >> MID_VCI_READ_SHIFT,\r\neni_vcc->words)) {\r\nEVENT("requeuing\n",0,0);\r\nskb_queue_head(&eni_dev->rx_queue,skb);\r\nbreak;\r\n}\r\neni_vcc->rxing--;\r\neni_vcc->rx_pos = ENI_PRV_POS(skb) & (eni_vcc->words-1);\r\npci_unmap_single(eni_dev->pci_dev,ENI_PRV_PADDR(skb),skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (!skb->len) dev_kfree_skb_irq(skb);\r\nelse {\r\nEVENT("pushing (len=%ld)\n",skb->len,0);\r\nif (vcc->qos.aal == ATM_AAL0)\r\n*(unsigned long *) skb->data =\r\nntohl(*(unsigned long *) skb->data);\r\nmemset(skb->cb,0,sizeof(struct eni_skb_prv));\r\nvcc->push(vcc,skb);\r\npushed++;\r\n}\r\natomic_inc(&vcc->stats->rx);\r\n}\r\nwake_up(&eni_dev->rx_wait);\r\n}\r\nstatic int open_rx_first(struct atm_vcc *vcc)\r\n{\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\nunsigned long size;\r\nDPRINTK("open_rx_first\n");\r\neni_dev = ENI_DEV(vcc->dev);\r\neni_vcc = ENI_VCC(vcc);\r\neni_vcc->rx = NULL;\r\nif (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;\r\nsize = vcc->qos.rxtp.max_sdu*eni_dev->rx_mult/100;\r\nif (size > MID_MAX_BUF_SIZE && vcc->qos.rxtp.max_sdu <=\r\nMID_MAX_BUF_SIZE)\r\nsize = MID_MAX_BUF_SIZE;\r\neni_vcc->recv = eni_alloc_mem(eni_dev,&size);\r\nDPRINTK("rx at 0x%lx\n",eni_vcc->recv);\r\neni_vcc->words = size >> 2;\r\nif (!eni_vcc->recv) return -ENOBUFS;\r\neni_vcc->rx = vcc->qos.aal == ATM_AAL5 ? rx_aal5 : rx_aal0;\r\neni_vcc->descr = 0;\r\neni_vcc->rx_pos = 0;\r\neni_vcc->rxing = 0;\r\neni_vcc->servicing = 0;\r\neni_vcc->next = ENI_VCC_NOS;\r\nreturn 0;\r\n}\r\nstatic int open_rx_second(struct atm_vcc *vcc)\r\n{\r\nvoid __iomem *here;\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\nunsigned long size;\r\nint order;\r\nDPRINTK("open_rx_second\n");\r\neni_dev = ENI_DEV(vcc->dev);\r\neni_vcc = ENI_VCC(vcc);\r\nif (!eni_vcc->rx) return 0;\r\nhere = eni_dev->vci+vcc->vci*16;\r\nDPRINTK("loc 0x%x\n",(unsigned) (eni_vcc->recv-eni_dev->ram)/4);\r\nsize = eni_vcc->words >> 8;\r\nfor (order = -1; size; order++) size >>= 1;\r\nwritel(0,here+4);\r\nwritel(0,here+8);\r\nif (eni_dev->rx_map[vcc->vci])\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): BUG - VCI %d already "\r\n"in use\n",vcc->dev->number,vcc->vci);\r\neni_dev->rx_map[vcc->vci] = vcc;\r\nwritel(((vcc->qos.aal != ATM_AAL5 ? MID_MODE_RAW : MID_MODE_AAL5) <<\r\nMID_VCI_MODE_SHIFT) | MID_VCI_PTI_MODE |\r\n(((eni_vcc->recv-eni_dev->ram) >> (MID_LOC_SKIP+2)) <<\r\nMID_VCI_LOCATION_SHIFT) | (order << MID_VCI_SIZE_SHIFT),here);\r\nreturn 0;\r\n}\r\nstatic void close_rx(struct atm_vcc *vcc)\r\n{\r\nDECLARE_WAITQUEUE(wait,current);\r\nvoid __iomem *here;\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\neni_vcc = ENI_VCC(vcc);\r\nif (!eni_vcc->rx) return;\r\neni_dev = ENI_DEV(vcc->dev);\r\nif (vcc->vpi != ATM_VPI_UNSPEC && vcc->vci != ATM_VCI_UNSPEC) {\r\nhere = eni_dev->vci+vcc->vci*16;\r\nwritel((readl(here) & ~MID_VCI_MODE) | (MID_MODE_TRASH <<\r\nMID_VCI_MODE_SHIFT),here);\r\nudelay(27);\r\nwritel(readl(here) & ~MID_VCI_IN_SERVICE,here);\r\neni_dev->rx_map[vcc->vci] = NULL;\r\nDPRINTK("eni_close: waiting for RX ...\n");\r\nEVENT("RX closing\n",0,0);\r\nadd_wait_queue(&eni_dev->rx_wait,&wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nbarrier();\r\nfor (;;) {\r\nif (!eni_vcc->servicing) {\r\nbarrier();\r\nif (!eni_vcc->rxing) break;\r\n}\r\nEVENT("drain PDUs (rx %ld, serv %ld)\n",eni_vcc->rxing,\r\neni_vcc->servicing);\r\nprintk(KERN_INFO "%d+%d RX left\n",eni_vcc->servicing,\r\neni_vcc->rxing);\r\nschedule();\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\n}\r\nfor (;;) {\r\nint at_end;\r\nu32 tmp;\r\ntasklet_disable(&eni_dev->task);\r\ntmp = readl(eni_dev->vci+vcc->vci*16+4) & MID_VCI_READ;\r\nat_end = eni_vcc->rx_pos == tmp >> MID_VCI_READ_SHIFT;\r\ntasklet_enable(&eni_dev->task);\r\nif (at_end) break;\r\nEVENT("drain discard (host 0x%lx, nic 0x%lx)\n",\r\neni_vcc->rx_pos,tmp);\r\nprintk(KERN_INFO "draining RX: host 0x%lx, nic 0x%x\n",\r\neni_vcc->rx_pos,tmp);\r\nschedule();\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&eni_dev->rx_wait,&wait);\r\n}\r\neni_free_mem(eni_dev,eni_vcc->recv,eni_vcc->words << 2);\r\neni_vcc->rx = NULL;\r\n}\r\nstatic int start_rx(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\neni_dev = ENI_DEV(dev);\r\neni_dev->rx_map = (struct atm_vcc **) get_zeroed_page(GFP_KERNEL);\r\nif (!eni_dev->rx_map) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): couldn't get free page\n",\r\ndev->number);\r\nfree_page((unsigned long) eni_dev->free_list);\r\nreturn -ENOMEM;\r\n}\r\neni_dev->rx_mult = DEFAULT_RX_MULT;\r\neni_dev->fast = eni_dev->last_fast = NULL;\r\neni_dev->slow = eni_dev->last_slow = NULL;\r\ninit_waitqueue_head(&eni_dev->rx_wait);\r\nskb_queue_head_init(&eni_dev->rx_queue);\r\neni_dev->serv_read = eni_in(MID_SERV_WRITE);\r\neni_out(0,MID_DMA_WR_RX);\r\nreturn 0;\r\n}\r\nstatic inline void put_dma(int chan,u32 *dma,int *j,dma_addr_t paddr,\r\nu32 size)\r\n{\r\nu32 init,words;\r\nDPRINTK("put_dma: 0x%lx+0x%x\n",(unsigned long) paddr,size);\r\nEVENT("put_dma: 0x%lx+0x%lx\n",(unsigned long) paddr,size);\r\n#if 0\r\nif (paddr & 3)\r\nprintk(KERN_ERR "put_dma: unaligned addr (0x%lx)\n",paddr);\r\nif (size & 3)\r\nprintk(KERN_ERR "put_dma: unaligned size (0x%lx)\n",size);\r\n#endif\r\nif (paddr & 3) {\r\ninit = 4-(paddr & 3);\r\nif (init > size || size < 7) init = size;\r\nDPRINTK("put_dma: %lx DMA: %d/%d bytes\n",\r\n(unsigned long) paddr,init,size);\r\ndma[(*j)++] = MID_DT_BYTE | (init << MID_DMA_COUNT_SHIFT) |\r\n(chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += init;\r\nsize -= init;\r\n}\r\nwords = size >> 2;\r\nsize &= 3;\r\nif (words && (paddr & 31)) {\r\ninit = 8-((paddr & 31) >> 2);\r\nif (init > words) init = words;\r\nDPRINTK("put_dma: %lx DMA: %d/%d words\n",\r\n(unsigned long) paddr,init,words);\r\ndma[(*j)++] = MID_DT_WORD | (init << MID_DMA_COUNT_SHIFT) |\r\n(chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += init << 2;\r\nwords -= init;\r\n}\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_16W\r\nif (words & ~15) {\r\nDPRINTK("put_dma: %lx DMA: %d*16/%d words\n",\r\n(unsigned long) paddr,words >> 4,words);\r\ndma[(*j)++] = MID_DT_16W | ((words >> 4) << MID_DMA_COUNT_SHIFT)\r\n| (chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += (words & ~15) << 2;\r\nwords &= 15;\r\n}\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_8W\r\nif (words & ~7) {\r\nDPRINTK("put_dma: %lx DMA: %d*8/%d words\n",\r\n(unsigned long) paddr,words >> 3,words);\r\ndma[(*j)++] = MID_DT_8W | ((words >> 3) << MID_DMA_COUNT_SHIFT)\r\n| (chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += (words & ~7) << 2;\r\nwords &= 7;\r\n}\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_4W\r\nif (words & ~3) {\r\nDPRINTK("put_dma: %lx DMA: %d*4/%d words\n",\r\n(unsigned long) paddr,words >> 2,words);\r\ndma[(*j)++] = MID_DT_4W | ((words >> 2) << MID_DMA_COUNT_SHIFT)\r\n| (chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += (words & ~3) << 2;\r\nwords &= 3;\r\n}\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_2W\r\nif (words & ~1) {\r\nDPRINTK("put_dma: %lx DMA: %d*2/%d words\n",\r\n(unsigned long) paddr,words >> 1,words);\r\ndma[(*j)++] = MID_DT_2W | ((words >> 1) << MID_DMA_COUNT_SHIFT)\r\n| (chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += (words & ~1) << 2;\r\nwords &= 1;\r\n}\r\n#endif\r\nif (words) {\r\nDPRINTK("put_dma: %lx DMA: %d words\n",(unsigned long) paddr,\r\nwords);\r\ndma[(*j)++] = MID_DT_WORD | (words << MID_DMA_COUNT_SHIFT) |\r\n(chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\npaddr += words << 2;\r\n}\r\nif (size) {\r\nDPRINTK("put_dma: %lx DMA: %d bytes\n",(unsigned long) paddr,\r\nsize);\r\ndma[(*j)++] = MID_DT_BYTE | (size << MID_DMA_COUNT_SHIFT) |\r\n(chan << MID_DMA_CHAN_SHIFT);\r\ndma[(*j)++] = paddr;\r\n}\r\n}\r\nstatic enum enq_res do_tx(struct sk_buff *skb)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\nstruct eni_tx *tx;\r\ndma_addr_t paddr;\r\nu32 dma_rd,dma_wr;\r\nu32 size;\r\nint aal5,dma_size,i,j;\r\nDPRINTK(">do_tx\n");\r\nNULLCHECK(skb);\r\nEVENT("do_tx: skb=0x%lx, %ld bytes\n",(unsigned long) skb,skb->len);\r\nvcc = ATM_SKB(skb)->vcc;\r\nNULLCHECK(vcc);\r\neni_dev = ENI_DEV(vcc->dev);\r\nNULLCHECK(eni_dev);\r\neni_vcc = ENI_VCC(vcc);\r\ntx = eni_vcc->tx;\r\nNULLCHECK(tx);\r\n#if 0\r\n{\r\nunsigned int hack = *((char *) skb->data)-'0';\r\nif (hack < 8) {\r\nskb->data += hack;\r\nskb->len -= hack;\r\n}\r\n}\r\n#endif\r\n#if 0\r\nif ((unsigned long) skb->data & 3)\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): VCI %d has mis-aligned "\r\n"TX data\n",vcc->dev->number,vcc->vci);\r\n#endif\r\naal5 = vcc->qos.aal == ATM_AAL5;\r\nif (!aal5)\r\nsize = (ATM_CELL_PAYLOAD >> 2)+TX_DESCR_SIZE;\r\nelse {\r\nsize = skb->len+4*AAL5_TRAILER+ATM_CELL_PAYLOAD-1;\r\nsize = ((size-(size % ATM_CELL_PAYLOAD)) >> 2)+TX_DESCR_SIZE;\r\n}\r\nif (!NEPMOK(tx->tx_pos,size+TX_GAP,\r\neni_in(MID_TX_RDPTR(tx->index)),tx->words)) {\r\nDPRINTK(DEV_LABEL "(itf %d): TX full (size %d)\n",\r\nvcc->dev->number,size);\r\nreturn enq_next;\r\n}\r\ndma_wr = eni_in(MID_DMA_WR_TX);\r\ndma_rd = eni_in(MID_DMA_RD_TX);\r\ndma_size = 3;\r\nDPRINTK("iovcnt = %d\n",skb_shinfo(skb)->nr_frags);\r\nif (!skb_shinfo(skb)->nr_frags) dma_size += 5;\r\nelse dma_size += 5*(skb_shinfo(skb)->nr_frags+1);\r\nif (dma_size > TX_DMA_BUF) {\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): needs %d DMA entries "\r\n"(got only %d)\n",vcc->dev->number,dma_size,TX_DMA_BUF);\r\n}\r\nDPRINTK("dma_wr is %d, tx_pos is %ld\n",dma_wr,tx->tx_pos);\r\nif (dma_wr != dma_rd && ((dma_rd+NR_DMA_TX-dma_wr) & (NR_DMA_TX-1)) <\r\ndma_size) {\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): TX DMA full\n",\r\nvcc->dev->number);\r\nreturn enq_jam;\r\n}\r\npaddr = pci_map_single(eni_dev->pci_dev,skb->data,skb->len,\r\nPCI_DMA_TODEVICE);\r\nENI_PRV_PADDR(skb) = paddr;\r\nj = 0;\r\neni_dev->dma[j++] = (((tx->tx_pos+TX_DESCR_SIZE) & (tx->words-1)) <<\r\nMID_DMA_COUNT_SHIFT) | (tx->index << MID_DMA_CHAN_SHIFT) |\r\nMID_DT_JK;\r\nj++;\r\nif (!skb_shinfo(skb)->nr_frags)\r\nif (aal5) put_dma(tx->index,eni_dev->dma,&j,paddr,skb->len);\r\nelse put_dma(tx->index,eni_dev->dma,&j,paddr+4,skb->len-4);\r\nelse {\r\nDPRINTK("doing direct send\n");\r\nfor (i = -1; i < skb_shinfo(skb)->nr_frags; i++)\r\nif (i == -1)\r\nput_dma(tx->index,eni_dev->dma,&j,(unsigned long)\r\nskb->data,\r\nskb_headlen(skb));\r\nelse\r\nput_dma(tx->index,eni_dev->dma,&j,(unsigned long)\r\nskb_frag_page(&skb_shinfo(skb)->frags[i]) +\r\nskb_shinfo(skb)->frags[i].page_offset,\r\nskb_frag_size(&skb_shinfo(skb)->frags[i]));\r\n}\r\nif (skb->len & 3) {\r\nput_dma(tx->index, eni_dev->dma, &j, eni_dev->zero.dma,\r\n4 - (skb->len & 3));\r\n}\r\neni_dev->dma[j++] = (((tx->tx_pos+size) & (tx->words-1)) <<\r\nMID_DMA_COUNT_SHIFT) | (tx->index << MID_DMA_CHAN_SHIFT) |\r\nMID_DMA_END | MID_DT_JK;\r\nj++;\r\nDPRINTK("DMA at end: %d\n",j);\r\nwritel((MID_SEG_TX_ID << MID_SEG_ID_SHIFT) |\r\n(aal5 ? MID_SEG_AAL5 : 0) | (tx->prescaler << MID_SEG_PR_SHIFT) |\r\n(tx->resolution << MID_SEG_RATE_SHIFT) |\r\n(size/(ATM_CELL_PAYLOAD/4)),tx->send+tx->tx_pos*4);\r\nwritel((vcc->vci << MID_SEG_VCI_SHIFT) |\r\n(aal5 ? 0 : (skb->data[3] & 0xf)) |\r\n(ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ? MID_SEG_CLP : 0),\r\ntx->send+((tx->tx_pos+1) & (tx->words-1))*4);\r\nDPRINTK("size: %d, len:%d\n",size,skb->len);\r\nif (aal5)\r\nwritel(skb->len,tx->send+\r\n((tx->tx_pos+size-AAL5_TRAILER) & (tx->words-1))*4);\r\nj = j >> 1;\r\nfor (i = 0; i < j; i++) {\r\nwritel(eni_dev->dma[i*2],eni_dev->tx_dma+dma_wr*8);\r\nwritel(eni_dev->dma[i*2+1],eni_dev->tx_dma+dma_wr*8+4);\r\ndma_wr = (dma_wr+1) & (NR_DMA_TX-1);\r\n}\r\nENI_PRV_POS(skb) = tx->tx_pos;\r\nENI_PRV_SIZE(skb) = size;\r\nENI_VCC(vcc)->txing += size;\r\ntx->tx_pos = (tx->tx_pos+size) & (tx->words-1);\r\nDPRINTK("dma_wr set to %d, tx_pos is now %ld\n",dma_wr,tx->tx_pos);\r\neni_out(dma_wr,MID_DMA_WR_TX);\r\nskb_queue_tail(&eni_dev->tx_queue,skb);\r\nqueued++;\r\nreturn enq_ok;\r\n}\r\nstatic void poll_tx(struct atm_dev *dev)\r\n{\r\nstruct eni_tx *tx;\r\nstruct sk_buff *skb;\r\nenum enq_res res;\r\nint i;\r\nDPRINTK(">poll_tx\n");\r\nfor (i = NR_CHAN-1; i >= 0; i--) {\r\ntx = &ENI_DEV(dev)->tx[i];\r\nif (tx->send)\r\nwhile ((skb = skb_dequeue(&tx->backlog))) {\r\nres = do_tx(skb);\r\nif (res == enq_ok) continue;\r\nDPRINTK("re-queuing TX PDU\n");\r\nskb_queue_head(&tx->backlog,skb);\r\nrequeued++;\r\nif (res == enq_jam) return;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void dequeue_tx(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *skb;\r\nstruct eni_tx *tx;\r\nNULLCHECK(dev);\r\neni_dev = ENI_DEV(dev);\r\nNULLCHECK(eni_dev);\r\nwhile ((skb = skb_dequeue(&eni_dev->tx_queue))) {\r\nvcc = ATM_SKB(skb)->vcc;\r\nNULLCHECK(vcc);\r\ntx = ENI_VCC(vcc)->tx;\r\nNULLCHECK(ENI_VCC(vcc)->tx);\r\nDPRINTK("dequeue_tx: next 0x%lx curr 0x%x\n",ENI_PRV_POS(skb),\r\n(unsigned) eni_in(MID_TX_DESCRSTART(tx->index)));\r\nif (ENI_VCC(vcc)->txing < tx->words && ENI_PRV_POS(skb) ==\r\neni_in(MID_TX_DESCRSTART(tx->index))) {\r\nskb_queue_head(&eni_dev->tx_queue,skb);\r\nbreak;\r\n}\r\nENI_VCC(vcc)->txing -= ENI_PRV_SIZE(skb);\r\npci_unmap_single(eni_dev->pci_dev,ENI_PRV_PADDR(skb),skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb_irq(skb);\r\natomic_inc(&vcc->stats->tx);\r\nwake_up(&eni_dev->tx_wait);\r\ndma_complete++;\r\n}\r\n}\r\nstatic struct eni_tx *alloc_tx(struct eni_dev *eni_dev,int ubr)\r\n{\r\nint i;\r\nfor (i = !ubr; i < NR_CHAN; i++)\r\nif (!eni_dev->tx[i].send) return eni_dev->tx+i;\r\nreturn NULL;\r\n}\r\nstatic int comp_tx(struct eni_dev *eni_dev,int *pcr,int reserved,int *pre,\r\nint *res,int unlimited)\r\n{\r\nstatic const int pre_div[] = { 4,16,128,2048 };\r\nif (unlimited) *pre = *res = 0;\r\nelse {\r\nif (*pcr > 0) {\r\nint div;\r\nfor (*pre = 0; *pre < 3; (*pre)++)\r\nif (TS_CLOCK/pre_div[*pre]/64 <= *pcr) break;\r\ndiv = pre_div[*pre]**pcr;\r\nDPRINTK("min div %d\n",div);\r\n*res = TS_CLOCK/div-1;\r\n}\r\nelse {\r\nint div;\r\nif (!*pcr) *pcr = eni_dev->tx_bw+reserved;\r\nfor (*pre = 3; *pre >= 0; (*pre)--)\r\nif (TS_CLOCK/pre_div[*pre]/64 > -*pcr) break;\r\nif (*pre < 3) (*pre)++;\r\ndiv = pre_div[*pre]*-*pcr;\r\nDPRINTK("max div %d\n",div);\r\n*res = DIV_ROUND_UP(TS_CLOCK, div)-1;\r\n}\r\nif (*res < 0) *res = 0;\r\nif (*res > MID_SEG_MAX_RATE) *res = MID_SEG_MAX_RATE;\r\n}\r\n*pcr = TS_CLOCK/pre_div[*pre]/(*res+1);\r\nDPRINTK("out pcr: %d (%d:%d)\n",*pcr,*pre,*res);\r\nreturn 0;\r\n}\r\nstatic int reserve_or_set_tx(struct atm_vcc *vcc,struct atm_trafprm *txtp,\r\nint set_rsv,int set_shp)\r\n{\r\nstruct eni_dev *eni_dev = ENI_DEV(vcc->dev);\r\nstruct eni_vcc *eni_vcc = ENI_VCC(vcc);\r\nstruct eni_tx *tx;\r\nunsigned long size;\r\nvoid __iomem *mem;\r\nint rate,ubr,unlimited,new_tx;\r\nint pre,res,order;\r\nint error;\r\nrate = atm_pcr_goal(txtp);\r\nubr = txtp->traffic_class == ATM_UBR;\r\nunlimited = ubr && (!rate || rate <= -ATM_OC3_PCR ||\r\nrate >= ATM_OC3_PCR);\r\nif (!unlimited) {\r\nsize = txtp->max_sdu*eni_dev->tx_mult/100;\r\nif (size > MID_MAX_BUF_SIZE && txtp->max_sdu <=\r\nMID_MAX_BUF_SIZE)\r\nsize = MID_MAX_BUF_SIZE;\r\n}\r\nelse {\r\nif (eni_dev->ubr) {\r\neni_vcc->tx = eni_dev->ubr;\r\ntxtp->pcr = ATM_OC3_PCR;\r\nreturn 0;\r\n}\r\nsize = UBR_BUFFER;\r\n}\r\nnew_tx = !eni_vcc->tx;\r\nmem = NULL;\r\nif (!new_tx) tx = eni_vcc->tx;\r\nelse {\r\nmem = eni_alloc_mem(eni_dev,&size);\r\nif (!mem) return -ENOBUFS;\r\ntx = alloc_tx(eni_dev,unlimited);\r\nif (!tx) {\r\neni_free_mem(eni_dev,mem,size);\r\nreturn -EBUSY;\r\n}\r\nDPRINTK("got chan %d\n",tx->index);\r\ntx->reserved = tx->shaping = 0;\r\ntx->send = mem;\r\ntx->words = size >> 2;\r\nskb_queue_head_init(&tx->backlog);\r\nfor (order = 0; size > (1 << (order+10)); order++);\r\neni_out((order << MID_SIZE_SHIFT) |\r\n((tx->send-eni_dev->ram) >> (MID_LOC_SKIP+2)),\r\nMID_TX_PLACE(tx->index));\r\ntx->tx_pos = eni_in(MID_TX_DESCRSTART(tx->index)) &\r\nMID_DESCR_START;\r\n}\r\nerror = comp_tx(eni_dev,&rate,tx->reserved,&pre,&res,unlimited);\r\nif (!error && txtp->min_pcr > rate) error = -EINVAL;\r\nif (!error && txtp->max_pcr && txtp->max_pcr != ATM_MAX_PCR &&\r\ntxtp->max_pcr < rate) error = -EINVAL;\r\nif (!error && !ubr && rate > eni_dev->tx_bw+tx->reserved)\r\nerror = -EINVAL;\r\nif (!error && set_rsv && !set_shp && rate < tx->shaping)\r\nerror = -EINVAL;\r\nif (!error && !set_rsv && rate > tx->reserved && !ubr)\r\nerror = -EINVAL;\r\nif (error) {\r\nif (new_tx) {\r\ntx->send = NULL;\r\neni_free_mem(eni_dev,mem,size);\r\n}\r\nreturn error;\r\n}\r\ntxtp->pcr = rate;\r\nif (set_rsv && !ubr) {\r\neni_dev->tx_bw += tx->reserved;\r\ntx->reserved = rate;\r\neni_dev->tx_bw -= rate;\r\n}\r\nif (set_shp || (unlimited && new_tx)) {\r\nif (unlimited && new_tx) eni_dev->ubr = tx;\r\ntx->prescaler = pre;\r\ntx->resolution = res;\r\ntx->shaping = rate;\r\n}\r\nif (set_shp) eni_vcc->tx = tx;\r\nDPRINTK("rsv %d shp %d\n",tx->reserved,tx->shaping);\r\nreturn 0;\r\n}\r\nstatic int open_tx_first(struct atm_vcc *vcc)\r\n{\r\nENI_VCC(vcc)->tx = NULL;\r\nif (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;\r\nENI_VCC(vcc)->txing = 0;\r\nreturn reserve_or_set_tx(vcc,&vcc->qos.txtp,1,1);\r\n}\r\nstatic int open_tx_second(struct atm_vcc *vcc)\r\n{\r\nreturn 0;\r\n}\r\nstatic void close_tx(struct atm_vcc *vcc)\r\n{\r\nDECLARE_WAITQUEUE(wait,current);\r\nstruct eni_dev *eni_dev;\r\nstruct eni_vcc *eni_vcc;\r\neni_vcc = ENI_VCC(vcc);\r\nif (!eni_vcc->tx) return;\r\neni_dev = ENI_DEV(vcc->dev);\r\nDPRINTK("eni_close: waiting for TX ...\n");\r\nadd_wait_queue(&eni_dev->tx_wait,&wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nfor (;;) {\r\nint txing;\r\ntasklet_disable(&eni_dev->task);\r\ntxing = skb_peek(&eni_vcc->tx->backlog) || eni_vcc->txing;\r\ntasklet_enable(&eni_dev->task);\r\nif (!txing) break;\r\nDPRINTK("%d TX left\n",eni_vcc->txing);\r\nschedule();\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&eni_dev->tx_wait,&wait);\r\nif (eni_vcc->tx != eni_dev->ubr) {\r\nwhile (eni_in(MID_TX_RDPTR(eni_vcc->tx->index)) !=\r\neni_in(MID_TX_DESCRSTART(eni_vcc->tx->index)))\r\nschedule();\r\neni_free_mem(eni_dev,eni_vcc->tx->send,eni_vcc->tx->words << 2);\r\neni_vcc->tx->send = NULL;\r\neni_dev->tx_bw += eni_vcc->tx->reserved;\r\n}\r\neni_vcc->tx = NULL;\r\n}\r\nstatic int start_tx(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nint i;\r\neni_dev = ENI_DEV(dev);\r\neni_dev->lost = 0;\r\neni_dev->tx_bw = ATM_OC3_PCR;\r\neni_dev->tx_mult = DEFAULT_TX_MULT;\r\ninit_waitqueue_head(&eni_dev->tx_wait);\r\neni_dev->ubr = NULL;\r\nskb_queue_head_init(&eni_dev->tx_queue);\r\neni_out(0,MID_DMA_WR_TX);\r\nfor (i = 0; i < NR_CHAN; i++) {\r\neni_dev->tx[i].send = NULL;\r\neni_dev->tx[i].index = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bug_int(struct atm_dev *dev,unsigned long reason)\r\n{\r\nDPRINTK(">bug_int\n");\r\nif (reason & MID_DMA_ERR_ACK)\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): driver error - DMA "\r\n"error\n",dev->number);\r\nif (reason & MID_TX_IDENT_MISM)\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): driver error - ident "\r\n"mismatch\n",dev->number);\r\nif (reason & MID_TX_DMA_OVFL)\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): driver error - DMA "\r\n"overflow\n",dev->number);\r\nEVENT("---dump ends here---\n",0,0);\r\nprintk(KERN_NOTICE "---recent events---\n");\r\nevent_dump();\r\n}\r\nstatic irqreturn_t eni_int(int irq,void *dev_id)\r\n{\r\nstruct atm_dev *dev;\r\nstruct eni_dev *eni_dev;\r\nu32 reason;\r\nDPRINTK(">eni_int\n");\r\ndev = dev_id;\r\neni_dev = ENI_DEV(dev);\r\nreason = eni_in(MID_ISA);\r\nDPRINTK(DEV_LABEL ": int 0x%lx\n",(unsigned long) reason);\r\nif (reason & MID_STAT_OVFL) {\r\nEVENT("stat overflow\n",0,0);\r\neni_dev->lost += eni_in(MID_STAT) & MID_OVFL_TRASH;\r\n}\r\nif (reason & MID_SUNI_INT) {\r\nEVENT("SUNI int\n",0,0);\r\ndev->phy->interrupt(dev);\r\n#if 0\r\nfoo();\r\n#endif\r\n}\r\nspin_lock(&eni_dev->lock);\r\neni_dev->events |= reason;\r\nspin_unlock(&eni_dev->lock);\r\ntasklet_schedule(&eni_dev->task);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void eni_tasklet(unsigned long data)\r\n{\r\nstruct atm_dev *dev = (struct atm_dev *) data;\r\nstruct eni_dev *eni_dev = ENI_DEV(dev);\r\nunsigned long flags;\r\nu32 events;\r\nDPRINTK("eni_tasklet (dev %p)\n",dev);\r\nspin_lock_irqsave(&eni_dev->lock,flags);\r\nevents = xchg(&eni_dev->events,0);\r\nspin_unlock_irqrestore(&eni_dev->lock,flags);\r\nif (events & MID_RX_DMA_COMPLETE) {\r\nEVENT("INT: RX DMA complete, starting dequeue_rx\n",0,0);\r\ndequeue_rx(dev);\r\nEVENT("dequeue_rx done, starting poll_rx\n",0,0);\r\npoll_rx(dev);\r\nEVENT("poll_rx done\n",0,0);\r\n}\r\nif (events & MID_SERVICE) {\r\nEVENT("INT: service, starting get_service\n",0,0);\r\nget_service(dev);\r\nEVENT("get_service done, starting poll_rx\n",0,0);\r\npoll_rx(dev);\r\nEVENT("poll_rx done\n",0,0);\r\n}\r\nif (events & MID_TX_DMA_COMPLETE) {\r\nEVENT("INT: TX DMA COMPLETE\n",0,0);\r\ndequeue_tx(dev);\r\n}\r\nif (events & MID_TX_COMPLETE) {\r\nEVENT("INT: TX COMPLETE\n",0,0);\r\ntx_complete++;\r\nwake_up(&eni_dev->tx_wait);\r\n}\r\nif (events & (MID_DMA_ERR_ACK | MID_TX_IDENT_MISM | MID_TX_DMA_OVFL)) {\r\nEVENT("bug interrupt\n",0,0);\r\nbug_int(dev,events);\r\n}\r\npoll_tx(dev);\r\n}\r\nstatic int get_esi_asic(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nunsigned char tonga;\r\nint error,failed,pci_error;\r\nint address,i,j;\r\neni_dev = ENI_DEV(dev);\r\nerror = pci_error = 0;\r\ntonga = SEPROM_MAGIC | SEPROM_DATA | SEPROM_CLK;\r\nSET_SEPROM;\r\nfor (i = 0; i < ESI_LEN && !error && !pci_error; i++) {\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga |= SEPROM_CLK;\r\nSET_SEPROM;\r\ntonga &= ~SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga &= ~SEPROM_CLK;\r\nSET_SEPROM;\r\naddress = ((i+SEPROM_ESI_BASE) << 1)+1;\r\nfor (j = 7; j >= 0; j--) {\r\ntonga = (address >> j) & 1 ? tonga | SEPROM_DATA :\r\ntonga & ~SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga |= SEPROM_CLK;\r\nSET_SEPROM;\r\ntonga &= ~SEPROM_CLK;\r\nSET_SEPROM;\r\n}\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga |= SEPROM_CLK;\r\nSET_SEPROM;\r\nGET_SEPROM;\r\nfailed = tonga & SEPROM_DATA;\r\ntonga &= ~SEPROM_CLK;\r\nSET_SEPROM;\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\nif (failed) error = -EIO;\r\nelse {\r\ndev->esi[i] = 0;\r\nfor (j = 7; j >= 0; j--) {\r\ndev->esi[i] <<= 1;\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga |= SEPROM_CLK;\r\nSET_SEPROM;\r\nGET_SEPROM;\r\nif (tonga & SEPROM_DATA) dev->esi[i] |= 1;\r\ntonga &= ~SEPROM_CLK;\r\nSET_SEPROM;\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\n}\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga |= SEPROM_CLK;\r\nSET_SEPROM;\r\nGET_SEPROM;\r\nif (!(tonga & SEPROM_DATA)) error = -EIO;\r\ntonga &= ~SEPROM_CLK;\r\nSET_SEPROM;\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\n}\r\ntonga &= ~SEPROM_DATA;\r\nSET_SEPROM;\r\ntonga |= SEPROM_CLK;\r\nSET_SEPROM;\r\ntonga |= SEPROM_DATA;\r\nSET_SEPROM;\r\n}\r\nif (pci_error) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): error reading ESI "\r\n"(0x%02x)\n",dev->number,pci_error);\r\nerror = -EIO;\r\n}\r\nreturn error;\r\n}\r\nstatic int get_esi_fpga(struct atm_dev *dev, void __iomem *base)\r\n{\r\nvoid __iomem *mac_base;\r\nint i;\r\nmac_base = base+EPROM_SIZE-sizeof(struct midway_eprom);\r\nfor (i = 0; i < ESI_LEN; i++) dev->esi[i] = readb(mac_base+(i^3));\r\nreturn 0;\r\n}\r\nstatic int eni_do_init(struct atm_dev *dev)\r\n{\r\nstruct midway_eprom __iomem *eprom;\r\nstruct eni_dev *eni_dev;\r\nstruct pci_dev *pci_dev;\r\nunsigned long real_base;\r\nvoid __iomem *base;\r\nint error,i,last;\r\nDPRINTK(">eni_init\n");\r\ndev->ci_range.vpi_bits = 0;\r\ndev->ci_range.vci_bits = NR_VCI_LD;\r\ndev->link_rate = ATM_OC3_PCR;\r\neni_dev = ENI_DEV(dev);\r\npci_dev = eni_dev->pci_dev;\r\nreal_base = pci_resource_start(pci_dev, 0);\r\neni_dev->irq = pci_dev->irq;\r\nif ((error = pci_write_config_word(pci_dev,PCI_COMMAND,\r\nPCI_COMMAND_MEMORY |\r\n(eni_dev->asic ? PCI_COMMAND_PARITY | PCI_COMMAND_SERR : 0)))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't enable memory "\r\n"(0x%02x)\n",dev->number,error);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_NOTICE DEV_LABEL "(itf %d): rev.%d,base=0x%lx,irq=%d,",\r\ndev->number,pci_dev->revision,real_base,eni_dev->irq);\r\nif (!(base = ioremap_nocache(real_base,MAP_MAX_SIZE))) {\r\nprintk("\n");\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't set up page "\r\n"mapping\n",dev->number);\r\nreturn error;\r\n}\r\neni_dev->ioaddr = base;\r\neni_dev->base_diff = real_base - (unsigned long) base;\r\nif (!eni_dev->asic) {\r\neprom = (base+EPROM_SIZE-sizeof(struct midway_eprom));\r\nif (readl(&eprom->magic) != ENI155_MAGIC) {\r\nprintk("\n");\r\nprintk(KERN_ERR DEV_LABEL\r\n"(itf %d): bad magic - expected 0x%x, got 0x%x\n",\r\ndev->number, ENI155_MAGIC,\r\n(unsigned)readl(&eprom->magic));\r\nerror = -EINVAL;\r\ngoto unmap;\r\n}\r\n}\r\neni_dev->phy = base+PHY_BASE;\r\neni_dev->reg = base+REG_BASE;\r\neni_dev->ram = base+RAM_BASE;\r\nlast = MAP_MAX_SIZE-RAM_BASE;\r\nfor (i = last-RAM_INCREMENT; i >= 0; i -= RAM_INCREMENT) {\r\nwritel(0x55555555,eni_dev->ram+i);\r\nif (readl(eni_dev->ram+i) != 0x55555555) last = i;\r\nelse {\r\nwritel(0xAAAAAAAA,eni_dev->ram+i);\r\nif (readl(eni_dev->ram+i) != 0xAAAAAAAA) last = i;\r\nelse writel(i,eni_dev->ram+i);\r\n}\r\n}\r\nfor (i = 0; i < last; i += RAM_INCREMENT)\r\nif (readl(eni_dev->ram+i) != i) break;\r\neni_dev->mem = i;\r\nmemset_io(eni_dev->ram,0,eni_dev->mem);\r\nprintk("mem=%dkB (",eni_dev->mem >> 10);\r\nif (!(eni_in(MID_RES_ID_MCON) & 0x200) != !eni_dev->asic) {\r\nprintk(")\n");\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): ERROR - wrong id 0x%x\n",\r\ndev->number,(unsigned) eni_in(MID_RES_ID_MCON));\r\nerror = -EINVAL;\r\ngoto unmap;\r\n}\r\nerror = eni_dev->asic ? get_esi_asic(dev) : get_esi_fpga(dev,base);\r\nif (error)\r\ngoto unmap;\r\nfor (i = 0; i < ESI_LEN; i++)\r\nprintk("%s%02X",i ? "-" : "",dev->esi[i]);\r\nprintk(")\n");\r\nprintk(KERN_NOTICE DEV_LABEL "(itf %d): %s,%s\n",dev->number,\r\neni_in(MID_RES_ID_MCON) & 0x200 ? "ASIC" : "FPGA",\r\nmedia_name[eni_in(MID_RES_ID_MCON) & DAUGTHER_ID]);\r\nerror = suni_init(dev);\r\nif (error)\r\ngoto unmap;\r\nout:\r\nreturn error;\r\nunmap:\r\niounmap(base);\r\ngoto out;\r\n}\r\nstatic void eni_do_release(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *ed = ENI_DEV(dev);\r\ndev->phy->stop(dev);\r\ndev->phy = NULL;\r\niounmap(ed->ioaddr);\r\n}\r\nstatic int eni_start(struct atm_dev *dev)\r\n{\r\nstruct eni_dev *eni_dev;\r\nvoid __iomem *buf;\r\nunsigned long buffer_mem;\r\nint error;\r\nDPRINTK(">eni_start\n");\r\neni_dev = ENI_DEV(dev);\r\nif (request_irq(eni_dev->irq,&eni_int,IRQF_SHARED,DEV_LABEL,dev)) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",\r\ndev->number,eni_dev->irq);\r\nerror = -EAGAIN;\r\ngoto out;\r\n}\r\npci_set_master(eni_dev->pci_dev);\r\nif ((error = pci_write_config_word(eni_dev->pci_dev,PCI_COMMAND,\r\nPCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\r\n(eni_dev->asic ? PCI_COMMAND_PARITY | PCI_COMMAND_SERR : 0)))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't enable memory+"\r\n"master (0x%02x)\n",dev->number,error);\r\ngoto free_irq;\r\n}\r\nif ((error = pci_write_config_byte(eni_dev->pci_dev,PCI_TONGA_CTRL,\r\nEND_SWAP_DMA))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't set endian swap "\r\n"(0x%02x)\n",dev->number,error);\r\ngoto free_irq;\r\n}\r\neni_dev->vci = eni_dev->ram;\r\neni_dev->rx_dma = eni_dev->ram+NR_VCI*16;\r\neni_dev->tx_dma = eni_dev->rx_dma+NR_DMA_RX*8;\r\neni_dev->service = eni_dev->tx_dma+NR_DMA_TX*8;\r\nbuf = eni_dev->service+NR_SERVICE*4;\r\nDPRINTK("vci 0x%lx,rx 0x%lx, tx 0x%lx,srv 0x%lx,buf 0x%lx\n",\r\neni_dev->vci,eni_dev->rx_dma,eni_dev->tx_dma,\r\neni_dev->service,buf);\r\nspin_lock_init(&eni_dev->lock);\r\ntasklet_init(&eni_dev->task,eni_tasklet,(unsigned long) dev);\r\neni_dev->events = 0;\r\nbuffer_mem = eni_dev->mem - (buf - eni_dev->ram);\r\neni_dev->free_list_size = buffer_mem/MID_MIN_BUF_SIZE/2;\r\neni_dev->free_list = kmalloc(\r\nsizeof(struct eni_free)*(eni_dev->free_list_size+1),GFP_KERNEL);\r\nif (!eni_dev->free_list) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): couldn't get free page\n",\r\ndev->number);\r\nerror = -ENOMEM;\r\ngoto free_irq;\r\n}\r\neni_dev->free_len = 0;\r\neni_put_free(eni_dev,buf,buffer_mem);\r\nmemset_io(eni_dev->vci,0,16*NR_VCI);\r\neni_out(0xffffffff,MID_IE);\r\nerror = start_tx(dev);\r\nif (error) goto free_list;\r\nerror = start_rx(dev);\r\nif (error) goto free_list;\r\nerror = dev->phy->start(dev);\r\nif (error) goto free_list;\r\neni_out(eni_in(MID_MC_S) | (1 << MID_INT_SEL_SHIFT) |\r\nMID_TX_LOCK_MODE | MID_DMA_ENABLE | MID_TX_ENABLE | MID_RX_ENABLE,\r\nMID_MC_S);\r\n(void) eni_in(MID_ISA);\r\nreturn 0;\r\nfree_list:\r\nkfree(eni_dev->free_list);\r\nfree_irq:\r\nfree_irq(eni_dev->irq, dev);\r\nout:\r\nreturn error;\r\n}\r\nstatic void eni_close(struct atm_vcc *vcc)\r\n{\r\nDPRINTK(">eni_close\n");\r\nif (!ENI_VCC(vcc)) return;\r\nclear_bit(ATM_VF_READY,&vcc->flags);\r\nclose_rx(vcc);\r\nclose_tx(vcc);\r\nDPRINTK("eni_close: done waiting\n");\r\nkfree(ENI_VCC(vcc));\r\nvcc->dev_data = NULL;\r\nclear_bit(ATM_VF_ADDR,&vcc->flags);\r\n}\r\nstatic int eni_open(struct atm_vcc *vcc)\r\n{\r\nstruct eni_vcc *eni_vcc;\r\nint error;\r\nshort vpi = vcc->vpi;\r\nint vci = vcc->vci;\r\nDPRINTK(">eni_open\n");\r\nEVENT("eni_open\n",0,0);\r\nif (!test_bit(ATM_VF_PARTIAL,&vcc->flags))\r\nvcc->dev_data = NULL;\r\nif (vci != ATM_VPI_UNSPEC && vpi != ATM_VCI_UNSPEC)\r\nset_bit(ATM_VF_ADDR,&vcc->flags);\r\nif (vcc->qos.aal != ATM_AAL0 && vcc->qos.aal != ATM_AAL5)\r\nreturn -EINVAL;\r\nDPRINTK(DEV_LABEL "(itf %d): open %d.%d\n",vcc->dev->number,vcc->vpi,\r\nvcc->vci);\r\nif (!test_bit(ATM_VF_PARTIAL,&vcc->flags)) {\r\neni_vcc = kmalloc(sizeof(struct eni_vcc),GFP_KERNEL);\r\nif (!eni_vcc) return -ENOMEM;\r\nvcc->dev_data = eni_vcc;\r\neni_vcc->tx = NULL;\r\nif ((error = open_rx_first(vcc))) {\r\neni_close(vcc);\r\nreturn error;\r\n}\r\nif ((error = open_tx_first(vcc))) {\r\neni_close(vcc);\r\nreturn error;\r\n}\r\n}\r\nif (vci == ATM_VPI_UNSPEC || vpi == ATM_VCI_UNSPEC) return 0;\r\nif ((error = open_rx_second(vcc))) {\r\neni_close(vcc);\r\nreturn error;\r\n}\r\nif ((error = open_tx_second(vcc))) {\r\neni_close(vcc);\r\nreturn error;\r\n}\r\nset_bit(ATM_VF_READY,&vcc->flags);\r\nreturn 0;\r\n}\r\nstatic int eni_change_qos(struct atm_vcc *vcc,struct atm_qos *qos,int flgs)\r\n{\r\nstruct eni_dev *eni_dev = ENI_DEV(vcc->dev);\r\nstruct eni_tx *tx = ENI_VCC(vcc)->tx;\r\nstruct sk_buff *skb;\r\nint error,rate,rsv,shp;\r\nif (qos->txtp.traffic_class == ATM_NONE) return 0;\r\nif (tx == eni_dev->ubr) return -EBADFD;\r\nrate = atm_pcr_goal(&qos->txtp);\r\nif (rate < 0) rate = -rate;\r\nrsv = shp = 0;\r\nif ((flgs & ATM_MF_DEC_RSV) && rate && rate < tx->reserved) rsv = 1;\r\nif ((flgs & ATM_MF_INC_RSV) && (!rate || rate > tx->reserved)) rsv = 1;\r\nif ((flgs & ATM_MF_DEC_SHP) && rate && rate < tx->shaping) shp = 1;\r\nif ((flgs & ATM_MF_INC_SHP) && (!rate || rate > tx->shaping)) shp = 1;\r\nif (!rsv && !shp) return 0;\r\nerror = reserve_or_set_tx(vcc,&qos->txtp,rsv,shp);\r\nif (error) return error;\r\nif (shp && !(flgs & ATM_MF_IMMED)) return 0;\r\ntasklet_disable(&eni_dev->task);\r\nskb_queue_walk(&eni_dev->tx_queue, skb) {\r\nvoid __iomem *dsc;\r\nif (ATM_SKB(skb)->vcc != vcc) continue;\r\ndsc = tx->send+ENI_PRV_POS(skb)*4;\r\nwritel((readl(dsc) & ~(MID_SEG_RATE | MID_SEG_PR)) |\r\n(tx->prescaler << MID_SEG_PR_SHIFT) |\r\n(tx->resolution << MID_SEG_RATE_SHIFT), dsc);\r\n}\r\ntasklet_enable(&eni_dev->task);\r\nreturn 0;\r\n}\r\nstatic int eni_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)\r\n{\r\nstruct eni_dev *eni_dev = ENI_DEV(dev);\r\nif (cmd == ENI_MEMDUMP) {\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nprintk(KERN_WARNING "Please use /proc/atm/" DEV_LABEL ":%d "\r\n"instead of obsolete ioctl ENI_MEMDUMP\n",dev->number);\r\ndump(dev);\r\nreturn 0;\r\n}\r\nif (cmd == ENI_SETMULT) {\r\nstruct eni_multipliers mult;\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (copy_from_user(&mult, arg,\r\nsizeof(struct eni_multipliers)))\r\nreturn -EFAULT;\r\nif ((mult.tx && mult.tx <= 100) || (mult.rx &&mult.rx <= 100) ||\r\nmult.tx > 65536 || mult.rx > 65536)\r\nreturn -EINVAL;\r\nif (mult.tx) eni_dev->tx_mult = mult.tx;\r\nif (mult.rx) eni_dev->rx_mult = mult.rx;\r\nreturn 0;\r\n}\r\nif (cmd == ATM_SETCIRANGE) {\r\nstruct atm_cirange ci;\r\nif (copy_from_user(&ci, arg,sizeof(struct atm_cirange)))\r\nreturn -EFAULT;\r\nif ((ci.vpi_bits == 0 || ci.vpi_bits == ATM_CI_MAX) &&\r\n(ci.vci_bits == NR_VCI_LD || ci.vpi_bits == ATM_CI_MAX))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nif (!dev->phy->ioctl) return -ENOIOCTLCMD;\r\nreturn dev->phy->ioctl(dev,cmd,arg);\r\n}\r\nstatic int eni_getsockopt(struct atm_vcc *vcc,int level,int optname,\r\nvoid __user *optval,int optlen)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int eni_setsockopt(struct atm_vcc *vcc,int level,int optname,\r\nvoid __user *optval,unsigned int optlen)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int eni_send(struct atm_vcc *vcc,struct sk_buff *skb)\r\n{\r\nenum enq_res res;\r\nDPRINTK(">eni_send\n");\r\nif (!ENI_VCC(vcc)->tx) {\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!skb) {\r\nprintk(KERN_CRIT "!skb in eni_send ?\n");\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nreturn -EINVAL;\r\n}\r\nif (vcc->qos.aal == ATM_AAL0) {\r\nif (skb->len != ATM_CELL_SIZE-1) {\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\n*(u32 *) skb->data = htonl(*(u32 *) skb->data);\r\n}\r\nsubmitted++;\r\nATM_SKB(skb)->vcc = vcc;\r\ntasklet_disable(&ENI_DEV(vcc->dev)->task);\r\nres = do_tx(skb);\r\ntasklet_enable(&ENI_DEV(vcc->dev)->task);\r\nif (res == enq_ok) return 0;\r\nskb_queue_tail(&ENI_VCC(vcc)->tx->backlog,skb);\r\nbacklogged++;\r\ntasklet_schedule(&ENI_DEV(vcc->dev)->task);\r\nreturn 0;\r\n}\r\nstatic void eni_phy_put(struct atm_dev *dev,unsigned char value,\r\nunsigned long addr)\r\n{\r\nwritel(value,ENI_DEV(dev)->phy+addr*4);\r\n}\r\nstatic unsigned char eni_phy_get(struct atm_dev *dev,unsigned long addr)\r\n{\r\nreturn readl(ENI_DEV(dev)->phy+addr*4);\r\n}\r\nstatic int eni_proc_read(struct atm_dev *dev,loff_t *pos,char *page)\r\n{\r\nstruct sock *s;\r\nstatic const char *signal[] = { "LOST","unknown","okay" };\r\nstruct eni_dev *eni_dev = ENI_DEV(dev);\r\nstruct atm_vcc *vcc;\r\nint left,i;\r\nleft = *pos;\r\nif (!left)\r\nreturn sprintf(page,DEV_LABEL "(itf %d) signal %s, %dkB, "\r\n"%d cps remaining\n",dev->number,signal[(int) dev->signal],\r\neni_dev->mem >> 10,eni_dev->tx_bw);\r\nif (!--left)\r\nreturn sprintf(page,"%4sBursts: TX"\r\n#if !defined(CONFIG_ATM_ENI_BURST_TX_16W) && \\r\n!defined(CONFIG_ATM_ENI_BURST_TX_8W) && \\r\n!defined(CONFIG_ATM_ENI_BURST_TX_4W) && \\r\n!defined(CONFIG_ATM_ENI_BURST_TX_2W)\r\n" none"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_16W\r\n" 16W"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_8W\r\n" 8W"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_4W\r\n" 4W"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_TX_2W\r\n" 2W"\r\n#endif\r\n", RX"\r\n#if !defined(CONFIG_ATM_ENI_BURST_RX_16W) && \\r\n!defined(CONFIG_ATM_ENI_BURST_RX_8W) && \\r\n!defined(CONFIG_ATM_ENI_BURST_RX_4W) && \\r\n!defined(CONFIG_ATM_ENI_BURST_RX_2W)\r\n" none"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_16W\r\n" 16W"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_8W\r\n" 8W"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_4W\r\n" 4W"\r\n#endif\r\n#ifdef CONFIG_ATM_ENI_BURST_RX_2W\r\n" 2W"\r\n#endif\r\n#ifndef CONFIG_ATM_ENI_TUNE_BURST\r\n" (default)"\r\n#endif\r\n"\n","");\r\nif (!--left)\r\nreturn sprintf(page,"%4sBuffer multipliers: tx %d%%, rx %d%%\n",\r\n"",eni_dev->tx_mult,eni_dev->rx_mult);\r\nfor (i = 0; i < NR_CHAN; i++) {\r\nstruct eni_tx *tx = eni_dev->tx+i;\r\nif (!tx->send) continue;\r\nif (!--left) {\r\nreturn sprintf(page,"tx[%d]: 0x%ld-0x%ld "\r\n"(%6ld bytes), rsv %d cps, shp %d cps%s\n",i,\r\n(unsigned long) (tx->send - eni_dev->ram),\r\ntx->send-eni_dev->ram+tx->words*4-1,tx->words*4,\r\ntx->reserved,tx->shaping,\r\ntx == eni_dev->ubr ? " (UBR)" : "");\r\n}\r\nif (--left) continue;\r\nreturn sprintf(page,"%10sbacklog %u packets\n","",\r\nskb_queue_len(&tx->backlog));\r\n}\r\nread_lock(&vcc_sklist_lock);\r\nfor(i = 0; i < VCC_HTABLE_SIZE; ++i) {\r\nstruct hlist_head *head = &vcc_hash[i];\r\nsk_for_each(s, head) {\r\nstruct eni_vcc *eni_vcc;\r\nint length;\r\nvcc = atm_sk(s);\r\nif (vcc->dev != dev)\r\ncontinue;\r\neni_vcc = ENI_VCC(vcc);\r\nif (--left) continue;\r\nlength = sprintf(page,"vcc %4d: ",vcc->vci);\r\nif (eni_vcc->rx) {\r\nlength += sprintf(page+length,"0x%ld-0x%ld "\r\n"(%6ld bytes)",\r\n(unsigned long) (eni_vcc->recv - eni_dev->ram),\r\neni_vcc->recv-eni_dev->ram+eni_vcc->words*4-1,\r\neni_vcc->words*4);\r\nif (eni_vcc->tx) length += sprintf(page+length,", ");\r\n}\r\nif (eni_vcc->tx)\r\nlength += sprintf(page+length,"tx[%d], txing %d bytes",\r\neni_vcc->tx->index,eni_vcc->txing);\r\npage[length] = '\n';\r\nread_unlock(&vcc_sklist_lock);\r\nreturn length+1;\r\n}\r\n}\r\nread_unlock(&vcc_sklist_lock);\r\nfor (i = 0; i < eni_dev->free_len; i++) {\r\nstruct eni_free *fe = eni_dev->free_list+i;\r\nunsigned long offset;\r\nif (--left) continue;\r\noffset = (unsigned long) eni_dev->ram+eni_dev->base_diff;\r\nreturn sprintf(page,"free %p-%p (%6d bytes)\n",\r\nfe->start-offset,fe->start-offset+(1 << fe->order)-1,\r\n1 << fe->order);\r\n}\r\nreturn 0;\r\n}\r\nstatic int eni_init_one(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct atm_dev *dev;\r\nstruct eni_dev *eni_dev;\r\nstruct eni_zero *zero;\r\nint rc;\r\nrc = pci_enable_device(pci_dev);\r\nif (rc < 0)\r\ngoto out;\r\nrc = -ENOMEM;\r\neni_dev = kmalloc(sizeof(struct eni_dev), GFP_KERNEL);\r\nif (!eni_dev)\r\ngoto err_disable;\r\nzero = &eni_dev->zero;\r\nzero->addr = pci_alloc_consistent(pci_dev, ENI_ZEROES_SIZE, &zero->dma);\r\nif (!zero->addr)\r\ngoto err_kfree;\r\ndev = atm_dev_register(DEV_LABEL, &pci_dev->dev, &ops, -1, NULL);\r\nif (!dev)\r\ngoto err_free_consistent;\r\ndev->dev_data = eni_dev;\r\npci_set_drvdata(pci_dev, dev);\r\neni_dev->pci_dev = pci_dev;\r\neni_dev->asic = ent->driver_data;\r\nrc = eni_do_init(dev);\r\nif (rc < 0)\r\ngoto err_unregister;\r\nrc = eni_start(dev);\r\nif (rc < 0)\r\ngoto err_eni_release;\r\neni_dev->more = eni_boards;\r\neni_boards = dev;\r\nout:\r\nreturn rc;\r\nerr_eni_release:\r\neni_do_release(dev);\r\nerr_unregister:\r\natm_dev_deregister(dev);\r\nerr_free_consistent:\r\npci_free_consistent(pci_dev, ENI_ZEROES_SIZE, zero->addr, zero->dma);\r\nerr_kfree:\r\nkfree(eni_dev);\r\nerr_disable:\r\npci_disable_device(pci_dev);\r\ngoto out;\r\n}\r\nstatic void eni_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct atm_dev *dev = pci_get_drvdata(pdev);\r\nstruct eni_dev *ed = ENI_DEV(dev);\r\nstruct eni_zero *zero = &ed->zero;\r\neni_do_release(dev);\r\natm_dev_deregister(dev);\r\npci_free_consistent(pdev, ENI_ZEROES_SIZE, zero->addr, zero->dma);\r\nkfree(ed);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init eni_init(void)\r\n{\r\nstruct sk_buff *skb;\r\nif (sizeof(skb->cb) < sizeof(struct eni_skb_prv)) {\r\nprintk(KERN_ERR "eni_detect: skb->cb is too small (%Zd < %Zd)\n",\r\nsizeof(skb->cb),sizeof(struct eni_skb_prv));\r\nreturn -EIO;\r\n}\r\nreturn pci_register_driver(&eni_driver);\r\n}
