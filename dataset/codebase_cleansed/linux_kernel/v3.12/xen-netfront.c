static void skb_entry_set_link(union skb_entry *list, unsigned short id)\r\n{\r\nlist->link = id;\r\n}\r\nstatic int skb_entry_is_link(const union skb_entry *list)\r\n{\r\nBUILD_BUG_ON(sizeof(list->skb) != sizeof(list->link));\r\nreturn (unsigned long)list->skb < PAGE_OFFSET;\r\n}\r\nstatic void add_id_to_freelist(unsigned *head, union skb_entry *list,\r\nunsigned short id)\r\n{\r\nskb_entry_set_link(&list[id], *head);\r\n*head = id;\r\n}\r\nstatic unsigned short get_id_from_freelist(unsigned *head,\r\nunion skb_entry *list)\r\n{\r\nunsigned int id = *head;\r\n*head = list[id].link;\r\nreturn id;\r\n}\r\nstatic int xennet_rxidx(RING_IDX idx)\r\n{\r\nreturn idx & (NET_RX_RING_SIZE - 1);\r\n}\r\nstatic struct sk_buff *xennet_get_rx_skb(struct netfront_info *np,\r\nRING_IDX ri)\r\n{\r\nint i = xennet_rxidx(ri);\r\nstruct sk_buff *skb = np->rx_skbs[i];\r\nnp->rx_skbs[i] = NULL;\r\nreturn skb;\r\n}\r\nstatic grant_ref_t xennet_get_rx_ref(struct netfront_info *np,\r\nRING_IDX ri)\r\n{\r\nint i = xennet_rxidx(ri);\r\ngrant_ref_t ref = np->grant_rx_ref[i];\r\nnp->grant_rx_ref[i] = GRANT_INVALID_REF;\r\nreturn ref;\r\n}\r\nstatic bool xennet_can_sg(struct net_device *dev)\r\n{\r\nreturn dev->features & NETIF_F_SG;\r\n}\r\nstatic void rx_refill_timeout(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct netfront_info *np = netdev_priv(dev);\r\nnapi_schedule(&np->napi);\r\n}\r\nstatic int netfront_tx_slot_available(struct netfront_info *np)\r\n{\r\nreturn (np->tx.req_prod_pvt - np->tx.rsp_cons) <\r\n(TX_MAX_TARGET - MAX_SKB_FRAGS - 2);\r\n}\r\nstatic void xennet_maybe_wake_tx(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nif (unlikely(netif_queue_stopped(dev)) &&\r\nnetfront_tx_slot_available(np) &&\r\nlikely(netif_running(dev)))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void xennet_alloc_rx_buffers(struct net_device *dev)\r\n{\r\nunsigned short id;\r\nstruct netfront_info *np = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct page *page;\r\nint i, batch_target, notify;\r\nRING_IDX req_prod = np->rx.req_prod_pvt;\r\ngrant_ref_t ref;\r\nunsigned long pfn;\r\nvoid *vaddr;\r\nstruct xen_netif_rx_request *req;\r\nif (unlikely(!netif_carrier_ok(dev)))\r\nreturn;\r\nbatch_target = np->rx_target - (req_prod - np->rx.rsp_cons);\r\nfor (i = skb_queue_len(&np->rx_batch); i < batch_target; i++) {\r\nskb = __netdev_alloc_skb(dev, RX_COPY_THRESHOLD + NET_IP_ALIGN,\r\nGFP_ATOMIC | __GFP_NOWARN);\r\nif (unlikely(!skb))\r\ngoto no_skb;\r\nskb_reserve(skb, NET_IP_ALIGN);\r\npage = alloc_page(GFP_ATOMIC | __GFP_NOWARN);\r\nif (!page) {\r\nkfree_skb(skb);\r\nno_skb:\r\nif (i != 0)\r\ngoto refill;\r\nmod_timer(&np->rx_refill_timer,\r\njiffies + (HZ/10));\r\nbreak;\r\n}\r\nskb_add_rx_frag(skb, 0, page, 0, 0, PAGE_SIZE);\r\n__skb_queue_tail(&np->rx_batch, skb);\r\n}\r\nif (i < (np->rx_target/2)) {\r\nif (req_prod > np->rx.sring->req_prod)\r\ngoto push;\r\nreturn;\r\n}\r\nif (((req_prod - np->rx.sring->rsp_prod) < (np->rx_target / 4)) &&\r\n((np->rx_target *= 2) > np->rx_max_target))\r\nnp->rx_target = np->rx_max_target;\r\nrefill:\r\nfor (i = 0; ; i++) {\r\nskb = __skb_dequeue(&np->rx_batch);\r\nif (skb == NULL)\r\nbreak;\r\nskb->dev = dev;\r\nid = xennet_rxidx(req_prod + i);\r\nBUG_ON(np->rx_skbs[id]);\r\nnp->rx_skbs[id] = skb;\r\nref = gnttab_claim_grant_reference(&np->gref_rx_head);\r\nBUG_ON((signed short)ref < 0);\r\nnp->grant_rx_ref[id] = ref;\r\npfn = page_to_pfn(skb_frag_page(&skb_shinfo(skb)->frags[0]));\r\nvaddr = page_address(skb_frag_page(&skb_shinfo(skb)->frags[0]));\r\nreq = RING_GET_REQUEST(&np->rx, req_prod + i);\r\ngnttab_grant_foreign_access_ref(ref,\r\nnp->xbdev->otherend_id,\r\npfn_to_mfn(pfn),\r\n0);\r\nreq->id = id;\r\nreq->gref = ref;\r\n}\r\nwmb();\r\nnp->rx.req_prod_pvt = req_prod + i;\r\npush:\r\nRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&np->rx, notify);\r\nif (notify)\r\nnotify_remote_via_irq(np->rx_irq);\r\n}\r\nstatic int xennet_open(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nnapi_enable(&np->napi);\r\nspin_lock_bh(&np->rx_lock);\r\nif (netif_carrier_ok(dev)) {\r\nxennet_alloc_rx_buffers(dev);\r\nnp->rx.sring->rsp_event = np->rx.rsp_cons + 1;\r\nif (RING_HAS_UNCONSUMED_RESPONSES(&np->rx))\r\nnapi_schedule(&np->napi);\r\n}\r\nspin_unlock_bh(&np->rx_lock);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void xennet_tx_buf_gc(struct net_device *dev)\r\n{\r\nRING_IDX cons, prod;\r\nunsigned short id;\r\nstruct netfront_info *np = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nBUG_ON(!netif_carrier_ok(dev));\r\ndo {\r\nprod = np->tx.sring->rsp_prod;\r\nrmb();\r\nfor (cons = np->tx.rsp_cons; cons != prod; cons++) {\r\nstruct xen_netif_tx_response *txrsp;\r\ntxrsp = RING_GET_RESPONSE(&np->tx, cons);\r\nif (txrsp->status == XEN_NETIF_RSP_NULL)\r\ncontinue;\r\nid = txrsp->id;\r\nskb = np->tx_skbs[id].skb;\r\nif (unlikely(gnttab_query_foreign_access(\r\nnp->grant_tx_ref[id]) != 0)) {\r\npr_alert("%s: warning -- grant still in use by backend domain\n",\r\n__func__);\r\nBUG();\r\n}\r\ngnttab_end_foreign_access_ref(\r\nnp->grant_tx_ref[id], GNTMAP_readonly);\r\ngnttab_release_grant_reference(\r\n&np->gref_tx_head, np->grant_tx_ref[id]);\r\nnp->grant_tx_ref[id] = GRANT_INVALID_REF;\r\nadd_id_to_freelist(&np->tx_skb_freelist, np->tx_skbs, id);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nnp->tx.rsp_cons = prod;\r\nnp->tx.sring->rsp_event =\r\nprod + ((np->tx.sring->req_prod - prod) >> 1) + 1;\r\nmb();\r\n} while ((cons == prod) && (prod != np->tx.sring->rsp_prod));\r\nxennet_maybe_wake_tx(dev);\r\n}\r\nstatic void xennet_make_frags(struct sk_buff *skb, struct net_device *dev,\r\nstruct xen_netif_tx_request *tx)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nchar *data = skb->data;\r\nunsigned long mfn;\r\nRING_IDX prod = np->tx.req_prod_pvt;\r\nint frags = skb_shinfo(skb)->nr_frags;\r\nunsigned int offset = offset_in_page(data);\r\nunsigned int len = skb_headlen(skb);\r\nunsigned int id;\r\ngrant_ref_t ref;\r\nint i;\r\nwhile (len > PAGE_SIZE - offset) {\r\ntx->size = PAGE_SIZE - offset;\r\ntx->flags |= XEN_NETTXF_more_data;\r\nlen -= tx->size;\r\ndata += tx->size;\r\noffset = 0;\r\nid = get_id_from_freelist(&np->tx_skb_freelist, np->tx_skbs);\r\nnp->tx_skbs[id].skb = skb_get(skb);\r\ntx = RING_GET_REQUEST(&np->tx, prod++);\r\ntx->id = id;\r\nref = gnttab_claim_grant_reference(&np->gref_tx_head);\r\nBUG_ON((signed short)ref < 0);\r\nmfn = virt_to_mfn(data);\r\ngnttab_grant_foreign_access_ref(ref, np->xbdev->otherend_id,\r\nmfn, GNTMAP_readonly);\r\ntx->gref = np->grant_tx_ref[id] = ref;\r\ntx->offset = offset;\r\ntx->size = len;\r\ntx->flags = 0;\r\n}\r\nfor (i = 0; i < frags; i++) {\r\nskb_frag_t *frag = skb_shinfo(skb)->frags + i;\r\nstruct page *page = skb_frag_page(frag);\r\nlen = skb_frag_size(frag);\r\noffset = frag->page_offset;\r\nBUG_ON(len + offset > PAGE_SIZE<<compound_order(page));\r\npage += offset >> PAGE_SHIFT;\r\noffset &= ~PAGE_MASK;\r\nwhile (len > 0) {\r\nunsigned long bytes;\r\nBUG_ON(offset >= PAGE_SIZE);\r\nbytes = PAGE_SIZE - offset;\r\nif (bytes > len)\r\nbytes = len;\r\ntx->flags |= XEN_NETTXF_more_data;\r\nid = get_id_from_freelist(&np->tx_skb_freelist,\r\nnp->tx_skbs);\r\nnp->tx_skbs[id].skb = skb_get(skb);\r\ntx = RING_GET_REQUEST(&np->tx, prod++);\r\ntx->id = id;\r\nref = gnttab_claim_grant_reference(&np->gref_tx_head);\r\nBUG_ON((signed short)ref < 0);\r\nmfn = pfn_to_mfn(page_to_pfn(page));\r\ngnttab_grant_foreign_access_ref(ref,\r\nnp->xbdev->otherend_id,\r\nmfn, GNTMAP_readonly);\r\ntx->gref = np->grant_tx_ref[id] = ref;\r\ntx->offset = offset;\r\ntx->size = bytes;\r\ntx->flags = 0;\r\noffset += bytes;\r\nlen -= bytes;\r\nif (offset == PAGE_SIZE && len) {\r\nBUG_ON(!PageCompound(page));\r\npage++;\r\noffset = 0;\r\n}\r\n}\r\n}\r\nnp->tx.req_prod_pvt = prod;\r\n}\r\nstatic int xennet_count_skb_frag_slots(struct sk_buff *skb)\r\n{\r\nint i, frags = skb_shinfo(skb)->nr_frags;\r\nint pages = 0;\r\nfor (i = 0; i < frags; i++) {\r\nskb_frag_t *frag = skb_shinfo(skb)->frags + i;\r\nunsigned long size = skb_frag_size(frag);\r\nunsigned long offset = frag->page_offset;\r\noffset &= ~PAGE_MASK;\r\npages += PFN_UP(offset + size);\r\n}\r\nreturn pages;\r\n}\r\nstatic int xennet_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned short id;\r\nstruct netfront_info *np = netdev_priv(dev);\r\nstruct netfront_stats *stats = this_cpu_ptr(np->stats);\r\nstruct xen_netif_tx_request *tx;\r\nchar *data = skb->data;\r\nRING_IDX i;\r\ngrant_ref_t ref;\r\nunsigned long mfn;\r\nint notify;\r\nint slots;\r\nunsigned int offset = offset_in_page(data);\r\nunsigned int len = skb_headlen(skb);\r\nunsigned long flags;\r\nif (unlikely(skb->len > XEN_NETIF_MAX_TX_SIZE)) {\r\nnet_alert_ratelimited(\r\n"xennet: skb->len = %u, too big for wire format\n",\r\nskb->len);\r\ngoto drop;\r\n}\r\nslots = DIV_ROUND_UP(offset + len, PAGE_SIZE) +\r\nxennet_count_skb_frag_slots(skb);\r\nif (unlikely(slots > MAX_SKB_FRAGS + 1)) {\r\nnet_alert_ratelimited(\r\n"xennet: skb rides the rocket: %d slots\n", slots);\r\ngoto drop;\r\n}\r\nspin_lock_irqsave(&np->tx_lock, flags);\r\nif (unlikely(!netif_carrier_ok(dev) ||\r\n(slots > 1 && !xennet_can_sg(dev)) ||\r\nnetif_needs_gso(skb, netif_skb_features(skb)))) {\r\nspin_unlock_irqrestore(&np->tx_lock, flags);\r\ngoto drop;\r\n}\r\ni = np->tx.req_prod_pvt;\r\nid = get_id_from_freelist(&np->tx_skb_freelist, np->tx_skbs);\r\nnp->tx_skbs[id].skb = skb;\r\ntx = RING_GET_REQUEST(&np->tx, i);\r\ntx->id = id;\r\nref = gnttab_claim_grant_reference(&np->gref_tx_head);\r\nBUG_ON((signed short)ref < 0);\r\nmfn = virt_to_mfn(data);\r\ngnttab_grant_foreign_access_ref(\r\nref, np->xbdev->otherend_id, mfn, GNTMAP_readonly);\r\ntx->gref = np->grant_tx_ref[id] = ref;\r\ntx->offset = offset;\r\ntx->size = len;\r\ntx->flags = 0;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\ntx->flags |= XEN_NETTXF_csum_blank | XEN_NETTXF_data_validated;\r\nelse if (skb->ip_summed == CHECKSUM_UNNECESSARY)\r\ntx->flags |= XEN_NETTXF_data_validated;\r\nif (skb_shinfo(skb)->gso_size) {\r\nstruct xen_netif_extra_info *gso;\r\ngso = (struct xen_netif_extra_info *)\r\nRING_GET_REQUEST(&np->tx, ++i);\r\ntx->flags |= XEN_NETTXF_extra_info;\r\ngso->u.gso.size = skb_shinfo(skb)->gso_size;\r\ngso->u.gso.type = XEN_NETIF_GSO_TYPE_TCPV4;\r\ngso->u.gso.pad = 0;\r\ngso->u.gso.features = 0;\r\ngso->type = XEN_NETIF_EXTRA_TYPE_GSO;\r\ngso->flags = 0;\r\n}\r\nnp->tx.req_prod_pvt = i + 1;\r\nxennet_make_frags(skb, dev, tx);\r\ntx->size = skb->len;\r\nRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&np->tx, notify);\r\nif (notify)\r\nnotify_remote_via_irq(np->tx_irq);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->tx_bytes += skb->len;\r\nstats->tx_packets++;\r\nu64_stats_update_end(&stats->syncp);\r\nxennet_tx_buf_gc(dev);\r\nif (!netfront_tx_slot_available(np))\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&np->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int xennet_close(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nnetif_stop_queue(np->netdev);\r\nnapi_disable(&np->napi);\r\nreturn 0;\r\n}\r\nstatic void xennet_move_rx_slot(struct netfront_info *np, struct sk_buff *skb,\r\ngrant_ref_t ref)\r\n{\r\nint new = xennet_rxidx(np->rx.req_prod_pvt);\r\nBUG_ON(np->rx_skbs[new]);\r\nnp->rx_skbs[new] = skb;\r\nnp->grant_rx_ref[new] = ref;\r\nRING_GET_REQUEST(&np->rx, np->rx.req_prod_pvt)->id = new;\r\nRING_GET_REQUEST(&np->rx, np->rx.req_prod_pvt)->gref = ref;\r\nnp->rx.req_prod_pvt++;\r\n}\r\nstatic int xennet_get_extras(struct netfront_info *np,\r\nstruct xen_netif_extra_info *extras,\r\nRING_IDX rp)\r\n{\r\nstruct xen_netif_extra_info *extra;\r\nstruct device *dev = &np->netdev->dev;\r\nRING_IDX cons = np->rx.rsp_cons;\r\nint err = 0;\r\ndo {\r\nstruct sk_buff *skb;\r\ngrant_ref_t ref;\r\nif (unlikely(cons + 1 == rp)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Missing extra info\n");\r\nerr = -EBADR;\r\nbreak;\r\n}\r\nextra = (struct xen_netif_extra_info *)\r\nRING_GET_RESPONSE(&np->rx, ++cons);\r\nif (unlikely(!extra->type ||\r\nextra->type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Invalid extra type: %d\n",\r\nextra->type);\r\nerr = -EINVAL;\r\n} else {\r\nmemcpy(&extras[extra->type - 1], extra,\r\nsizeof(*extra));\r\n}\r\nskb = xennet_get_rx_skb(np, cons);\r\nref = xennet_get_rx_ref(np, cons);\r\nxennet_move_rx_slot(np, skb, ref);\r\n} while (extra->flags & XEN_NETIF_EXTRA_FLAG_MORE);\r\nnp->rx.rsp_cons = cons;\r\nreturn err;\r\n}\r\nstatic int xennet_get_responses(struct netfront_info *np,\r\nstruct netfront_rx_info *rinfo, RING_IDX rp,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct xen_netif_rx_response *rx = &rinfo->rx;\r\nstruct xen_netif_extra_info *extras = rinfo->extras;\r\nstruct device *dev = &np->netdev->dev;\r\nRING_IDX cons = np->rx.rsp_cons;\r\nstruct sk_buff *skb = xennet_get_rx_skb(np, cons);\r\ngrant_ref_t ref = xennet_get_rx_ref(np, cons);\r\nint max = MAX_SKB_FRAGS + (rx->status <= RX_COPY_THRESHOLD);\r\nint slots = 1;\r\nint err = 0;\r\nunsigned long ret;\r\nif (rx->flags & XEN_NETRXF_extra_info) {\r\nerr = xennet_get_extras(np, extras, rp);\r\ncons = np->rx.rsp_cons;\r\n}\r\nfor (;;) {\r\nif (unlikely(rx->status < 0 ||\r\nrx->offset + rx->status > PAGE_SIZE)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "rx->offset: %x, size: %u\n",\r\nrx->offset, rx->status);\r\nxennet_move_rx_slot(np, skb, ref);\r\nerr = -EINVAL;\r\ngoto next;\r\n}\r\nif (ref == GRANT_INVALID_REF) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Bad rx response id %d.\n",\r\nrx->id);\r\nerr = -EINVAL;\r\ngoto next;\r\n}\r\nret = gnttab_end_foreign_access_ref(ref, 0);\r\nBUG_ON(!ret);\r\ngnttab_release_grant_reference(&np->gref_rx_head, ref);\r\n__skb_queue_tail(list, skb);\r\nnext:\r\nif (!(rx->flags & XEN_NETRXF_more_data))\r\nbreak;\r\nif (cons + slots == rp) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Need more slots\n");\r\nerr = -ENOENT;\r\nbreak;\r\n}\r\nrx = RING_GET_RESPONSE(&np->rx, cons + slots);\r\nskb = xennet_get_rx_skb(np, cons + slots);\r\nref = xennet_get_rx_ref(np, cons + slots);\r\nslots++;\r\n}\r\nif (unlikely(slots > max)) {\r\nif (net_ratelimit())\r\ndev_warn(dev, "Too many slots\n");\r\nerr = -E2BIG;\r\n}\r\nif (unlikely(err))\r\nnp->rx.rsp_cons = cons + slots;\r\nreturn err;\r\n}\r\nstatic int xennet_set_skb_gso(struct sk_buff *skb,\r\nstruct xen_netif_extra_info *gso)\r\n{\r\nif (!gso->u.gso.size) {\r\nif (net_ratelimit())\r\npr_warn("GSO size must not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\r\nif (net_ratelimit())\r\npr_warn("Bad GSO type %d\n", gso->u.gso.type);\r\nreturn -EINVAL;\r\n}\r\nskb_shinfo(skb)->gso_size = gso->u.gso.size;\r\nskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\r\nskb_shinfo(skb)->gso_segs = 0;\r\nreturn 0;\r\n}\r\nstatic RING_IDX xennet_fill_frags(struct netfront_info *np,\r\nstruct sk_buff *skb,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct skb_shared_info *shinfo = skb_shinfo(skb);\r\nRING_IDX cons = np->rx.rsp_cons;\r\nstruct sk_buff *nskb;\r\nwhile ((nskb = __skb_dequeue(list))) {\r\nstruct xen_netif_rx_response *rx =\r\nRING_GET_RESPONSE(&np->rx, ++cons);\r\nskb_frag_t *nfrag = &skb_shinfo(nskb)->frags[0];\r\nif (shinfo->nr_frags == MAX_SKB_FRAGS) {\r\nunsigned int pull_to = NETFRONT_SKB_CB(skb)->pull_to;\r\nBUG_ON(pull_to <= skb_headlen(skb));\r\n__pskb_pull_tail(skb, pull_to - skb_headlen(skb));\r\n}\r\nBUG_ON(shinfo->nr_frags >= MAX_SKB_FRAGS);\r\nskb_add_rx_frag(skb, shinfo->nr_frags, skb_frag_page(nfrag),\r\nrx->offset, rx->status, PAGE_SIZE);\r\nskb_shinfo(nskb)->nr_frags = 0;\r\nkfree_skb(nskb);\r\n}\r\nreturn cons;\r\n}\r\nstatic int checksum_setup(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct iphdr *iph;\r\nint err = -EPROTO;\r\nint recalculate_partial_csum = 0;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\r\nstruct netfront_info *np = netdev_priv(dev);\r\nnp->rx_gso_checksum_fixup++;\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nrecalculate_partial_csum = 1;\r\n}\r\nif (skb->ip_summed != CHECKSUM_PARTIAL)\r\nreturn 0;\r\nif (skb->protocol != htons(ETH_P_IP))\r\ngoto out;\r\niph = (void *)skb->data;\r\nswitch (iph->protocol) {\r\ncase IPPROTO_TCP:\r\nif (!skb_partial_csum_set(skb, 4 * iph->ihl,\r\noffsetof(struct tcphdr, check)))\r\ngoto out;\r\nif (recalculate_partial_csum) {\r\nstruct tcphdr *tcph = tcp_hdr(skb);\r\ntcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - iph->ihl*4,\r\nIPPROTO_TCP, 0);\r\n}\r\nbreak;\r\ncase IPPROTO_UDP:\r\nif (!skb_partial_csum_set(skb, 4 * iph->ihl,\r\noffsetof(struct udphdr, check)))\r\ngoto out;\r\nif (recalculate_partial_csum) {\r\nstruct udphdr *udph = udp_hdr(skb);\r\nudph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - iph->ihl*4,\r\nIPPROTO_UDP, 0);\r\n}\r\nbreak;\r\ndefault:\r\nif (net_ratelimit())\r\npr_err("Attempting to checksum a non-TCP/UDP packet, dropping a protocol %d packet\n",\r\niph->protocol);\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int handle_incoming_queue(struct net_device *dev,\r\nstruct sk_buff_head *rxq)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nstruct netfront_stats *stats = this_cpu_ptr(np->stats);\r\nint packets_dropped = 0;\r\nstruct sk_buff *skb;\r\nwhile ((skb = __skb_dequeue(rxq)) != NULL) {\r\nint pull_to = NETFRONT_SKB_CB(skb)->pull_to;\r\nif (pull_to > skb_headlen(skb))\r\n__pskb_pull_tail(skb, pull_to - skb_headlen(skb));\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (checksum_setup(dev, skb)) {\r\nkfree_skb(skb);\r\npackets_dropped++;\r\ndev->stats.rx_errors++;\r\ncontinue;\r\n}\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->rx_packets++;\r\nstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&stats->syncp);\r\nnetif_receive_skb(skb);\r\n}\r\nreturn packets_dropped;\r\n}\r\nstatic int xennet_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct netfront_info *np = container_of(napi, struct netfront_info, napi);\r\nstruct net_device *dev = np->netdev;\r\nstruct sk_buff *skb;\r\nstruct netfront_rx_info rinfo;\r\nstruct xen_netif_rx_response *rx = &rinfo.rx;\r\nstruct xen_netif_extra_info *extras = rinfo.extras;\r\nRING_IDX i, rp;\r\nint work_done;\r\nstruct sk_buff_head rxq;\r\nstruct sk_buff_head errq;\r\nstruct sk_buff_head tmpq;\r\nunsigned long flags;\r\nint err;\r\nspin_lock(&np->rx_lock);\r\nskb_queue_head_init(&rxq);\r\nskb_queue_head_init(&errq);\r\nskb_queue_head_init(&tmpq);\r\nrp = np->rx.sring->rsp_prod;\r\nrmb();\r\ni = np->rx.rsp_cons;\r\nwork_done = 0;\r\nwhile ((i != rp) && (work_done < budget)) {\r\nmemcpy(rx, RING_GET_RESPONSE(&np->rx, i), sizeof(*rx));\r\nmemset(extras, 0, sizeof(rinfo.extras));\r\nerr = xennet_get_responses(np, &rinfo, rp, &tmpq);\r\nif (unlikely(err)) {\r\nerr:\r\nwhile ((skb = __skb_dequeue(&tmpq)))\r\n__skb_queue_tail(&errq, skb);\r\ndev->stats.rx_errors++;\r\ni = np->rx.rsp_cons;\r\ncontinue;\r\n}\r\nskb = __skb_dequeue(&tmpq);\r\nif (extras[XEN_NETIF_EXTRA_TYPE_GSO - 1].type) {\r\nstruct xen_netif_extra_info *gso;\r\ngso = &extras[XEN_NETIF_EXTRA_TYPE_GSO - 1];\r\nif (unlikely(xennet_set_skb_gso(skb, gso))) {\r\n__skb_queue_head(&tmpq, skb);\r\nnp->rx.rsp_cons += skb_queue_len(&tmpq);\r\ngoto err;\r\n}\r\n}\r\nNETFRONT_SKB_CB(skb)->pull_to = rx->status;\r\nif (NETFRONT_SKB_CB(skb)->pull_to > RX_COPY_THRESHOLD)\r\nNETFRONT_SKB_CB(skb)->pull_to = RX_COPY_THRESHOLD;\r\nskb_shinfo(skb)->frags[0].page_offset = rx->offset;\r\nskb_frag_size_set(&skb_shinfo(skb)->frags[0], rx->status);\r\nskb->data_len = rx->status;\r\nskb->len += rx->status;\r\ni = xennet_fill_frags(np, skb, &tmpq);\r\nif (rx->flags & XEN_NETRXF_csum_blank)\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nelse if (rx->flags & XEN_NETRXF_data_validated)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n__skb_queue_tail(&rxq, skb);\r\nnp->rx.rsp_cons = ++i;\r\nwork_done++;\r\n}\r\n__skb_queue_purge(&errq);\r\nwork_done -= handle_incoming_queue(dev, &rxq);\r\nif (((np->rx.req_prod_pvt - np->rx.sring->rsp_prod) >\r\n((3*np->rx_target) / 4)) &&\r\n(--np->rx_target < np->rx_min_target))\r\nnp->rx_target = np->rx_min_target;\r\nxennet_alloc_rx_buffers(dev);\r\nif (work_done < budget) {\r\nint more_to_do = 0;\r\nlocal_irq_save(flags);\r\nRING_FINAL_CHECK_FOR_RESPONSES(&np->rx, more_to_do);\r\nif (!more_to_do)\r\n__napi_complete(napi);\r\nlocal_irq_restore(flags);\r\n}\r\nspin_unlock(&np->rx_lock);\r\nreturn work_done;\r\n}\r\nstatic int xennet_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nint max = xennet_can_sg(dev) ?\r\nXEN_NETIF_MAX_TX_SIZE - MAX_TCP_HEADER : ETH_DATA_LEN;\r\nif (mtu > max)\r\nreturn -EINVAL;\r\ndev->mtu = mtu;\r\nreturn 0;\r\n}\r\nstatic struct rtnl_link_stats64 *xennet_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *tot)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct netfront_stats *stats = per_cpu_ptr(np->stats, cpu);\r\nu64 rx_packets, rx_bytes, tx_packets, tx_bytes;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&stats->syncp);\r\nrx_packets = stats->rx_packets;\r\ntx_packets = stats->tx_packets;\r\nrx_bytes = stats->rx_bytes;\r\ntx_bytes = stats->tx_bytes;\r\n} while (u64_stats_fetch_retry_bh(&stats->syncp, start));\r\ntot->rx_packets += rx_packets;\r\ntot->tx_packets += tx_packets;\r\ntot->rx_bytes += rx_bytes;\r\ntot->tx_bytes += tx_bytes;\r\n}\r\ntot->rx_errors = dev->stats.rx_errors;\r\ntot->tx_dropped = dev->stats.tx_dropped;\r\nreturn tot;\r\n}\r\nstatic void xennet_release_tx_bufs(struct netfront_info *np)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < NET_TX_RING_SIZE; i++) {\r\nif (skb_entry_is_link(&np->tx_skbs[i]))\r\ncontinue;\r\nskb = np->tx_skbs[i].skb;\r\ngnttab_end_foreign_access_ref(np->grant_tx_ref[i],\r\nGNTMAP_readonly);\r\ngnttab_release_grant_reference(&np->gref_tx_head,\r\nnp->grant_tx_ref[i]);\r\nnp->grant_tx_ref[i] = GRANT_INVALID_REF;\r\nadd_id_to_freelist(&np->tx_skb_freelist, np->tx_skbs, i);\r\ndev_kfree_skb_irq(skb);\r\n}\r\n}\r\nstatic void xennet_release_rx_bufs(struct netfront_info *np)\r\n{\r\nstruct mmu_update *mmu = np->rx_mmu;\r\nstruct multicall_entry *mcl = np->rx_mcl;\r\nstruct sk_buff_head free_list;\r\nstruct sk_buff *skb;\r\nunsigned long mfn;\r\nint xfer = 0, noxfer = 0, unused = 0;\r\nint id, ref;\r\ndev_warn(&np->netdev->dev, "%s: fix me for copying receiver.\n",\r\n__func__);\r\nreturn;\r\nskb_queue_head_init(&free_list);\r\nspin_lock_bh(&np->rx_lock);\r\nfor (id = 0; id < NET_RX_RING_SIZE; id++) {\r\nref = np->grant_rx_ref[id];\r\nif (ref == GRANT_INVALID_REF) {\r\nunused++;\r\ncontinue;\r\n}\r\nskb = np->rx_skbs[id];\r\nmfn = gnttab_end_foreign_transfer_ref(ref);\r\ngnttab_release_grant_reference(&np->gref_rx_head, ref);\r\nnp->grant_rx_ref[id] = GRANT_INVALID_REF;\r\nif (0 == mfn) {\r\nskb_shinfo(skb)->nr_frags = 0;\r\ndev_kfree_skb(skb);\r\nnoxfer++;\r\ncontinue;\r\n}\r\nif (!xen_feature(XENFEAT_auto_translated_physmap)) {\r\nconst struct page *page =\r\nskb_frag_page(&skb_shinfo(skb)->frags[0]);\r\nunsigned long pfn = page_to_pfn(page);\r\nvoid *vaddr = page_address(page);\r\nMULTI_update_va_mapping(mcl, (unsigned long)vaddr,\r\nmfn_pte(mfn, PAGE_KERNEL),\r\n0);\r\nmcl++;\r\nmmu->ptr = ((u64)mfn << PAGE_SHIFT)\r\n| MMU_MACHPHYS_UPDATE;\r\nmmu->val = pfn;\r\nmmu++;\r\nset_phys_to_machine(pfn, mfn);\r\n}\r\n__skb_queue_tail(&free_list, skb);\r\nxfer++;\r\n}\r\ndev_info(&np->netdev->dev, "%s: %d xfer, %d noxfer, %d unused\n",\r\n__func__, xfer, noxfer, unused);\r\nif (xfer) {\r\nif (!xen_feature(XENFEAT_auto_translated_physmap)) {\r\nMULTI_mmu_update(mcl, np->rx_mmu, mmu - np->rx_mmu,\r\nNULL, DOMID_SELF);\r\nmcl++;\r\nHYPERVISOR_multicall(np->rx_mcl, mcl - np->rx_mcl);\r\n}\r\n}\r\n__skb_queue_purge(&free_list);\r\nspin_unlock_bh(&np->rx_lock);\r\n}\r\nstatic void xennet_uninit(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nxennet_release_tx_bufs(np);\r\nxennet_release_rx_bufs(np);\r\ngnttab_free_grant_references(np->gref_tx_head);\r\ngnttab_free_grant_references(np->gref_rx_head);\r\n}\r\nstatic netdev_features_t xennet_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nint val;\r\nif (features & NETIF_F_SG) {\r\nif (xenbus_scanf(XBT_NIL, np->xbdev->otherend, "feature-sg",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (!val)\r\nfeatures &= ~NETIF_F_SG;\r\n}\r\nif (features & NETIF_F_TSO) {\r\nif (xenbus_scanf(XBT_NIL, np->xbdev->otherend,\r\n"feature-gso-tcpv4", "%d", &val) < 0)\r\nval = 0;\r\nif (!val)\r\nfeatures &= ~NETIF_F_TSO;\r\n}\r\nreturn features;\r\n}\r\nstatic int xennet_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nif (!(features & NETIF_F_SG) && dev->mtu > ETH_DATA_LEN) {\r\nnetdev_info(dev, "Reducing MTU because no SG offload");\r\ndev->mtu = ETH_DATA_LEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xennet_tx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct netfront_info *np = dev_id;\r\nstruct net_device *dev = np->netdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&np->tx_lock, flags);\r\nxennet_tx_buf_gc(dev);\r\nspin_unlock_irqrestore(&np->tx_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xennet_rx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct netfront_info *np = dev_id;\r\nstruct net_device *dev = np->netdev;\r\nif (likely(netif_carrier_ok(dev) &&\r\nRING_HAS_UNCONSUMED_RESPONSES(&np->rx)))\r\nnapi_schedule(&np->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xennet_interrupt(int irq, void *dev_id)\r\n{\r\nxennet_tx_interrupt(irq, dev_id);\r\nxennet_rx_interrupt(irq, dev_id);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xennet_poll_controller(struct net_device *dev)\r\n{\r\nxennet_interrupt(0, dev);\r\n}\r\nstatic struct net_device *xennet_create_dev(struct xenbus_device *dev)\r\n{\r\nint i, err;\r\nstruct net_device *netdev;\r\nstruct netfront_info *np;\r\nnetdev = alloc_etherdev(sizeof(struct netfront_info));\r\nif (!netdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nnp = netdev_priv(netdev);\r\nnp->xbdev = dev;\r\nspin_lock_init(&np->tx_lock);\r\nspin_lock_init(&np->rx_lock);\r\nskb_queue_head_init(&np->rx_batch);\r\nnp->rx_target = RX_DFL_MIN_TARGET;\r\nnp->rx_min_target = RX_DFL_MIN_TARGET;\r\nnp->rx_max_target = RX_MAX_TARGET;\r\ninit_timer(&np->rx_refill_timer);\r\nnp->rx_refill_timer.data = (unsigned long)netdev;\r\nnp->rx_refill_timer.function = rx_refill_timeout;\r\nerr = -ENOMEM;\r\nnp->stats = alloc_percpu(struct netfront_stats);\r\nif (np->stats == NULL)\r\ngoto exit;\r\nnp->tx_skb_freelist = 0;\r\nfor (i = 0; i < NET_TX_RING_SIZE; i++) {\r\nskb_entry_set_link(&np->tx_skbs[i], i+1);\r\nnp->grant_tx_ref[i] = GRANT_INVALID_REF;\r\n}\r\nfor (i = 0; i < NET_RX_RING_SIZE; i++) {\r\nnp->rx_skbs[i] = NULL;\r\nnp->grant_rx_ref[i] = GRANT_INVALID_REF;\r\n}\r\nif (gnttab_alloc_grant_references(TX_MAX_TARGET,\r\n&np->gref_tx_head) < 0) {\r\npr_alert("can't alloc tx grant refs\n");\r\nerr = -ENOMEM;\r\ngoto exit_free_stats;\r\n}\r\nif (gnttab_alloc_grant_references(RX_MAX_TARGET,\r\n&np->gref_rx_head) < 0) {\r\npr_alert("can't alloc rx grant refs\n");\r\nerr = -ENOMEM;\r\ngoto exit_free_tx;\r\n}\r\nnetdev->netdev_ops = &xennet_netdev_ops;\r\nnetif_napi_add(netdev, &np->napi, xennet_poll, 64);\r\nnetdev->features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |\r\nNETIF_F_GSO_ROBUST;\r\nnetdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO;\r\nnetdev->features |= netdev->hw_features;\r\nSET_ETHTOOL_OPS(netdev, &xennet_ethtool_ops);\r\nSET_NETDEV_DEV(netdev, &dev->dev);\r\nnetif_set_gso_max_size(netdev, XEN_NETIF_MAX_TX_SIZE - MAX_TCP_HEADER);\r\nnp->netdev = netdev;\r\nnetif_carrier_off(netdev);\r\nreturn netdev;\r\nexit_free_tx:\r\ngnttab_free_grant_references(np->gref_tx_head);\r\nexit_free_stats:\r\nfree_percpu(np->stats);\r\nexit:\r\nfree_netdev(netdev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int netfront_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nint err;\r\nstruct net_device *netdev;\r\nstruct netfront_info *info;\r\nnetdev = xennet_create_dev(dev);\r\nif (IS_ERR(netdev)) {\r\nerr = PTR_ERR(netdev);\r\nxenbus_dev_fatal(dev, err, "creating netdev");\r\nreturn err;\r\n}\r\ninfo = netdev_priv(netdev);\r\ndev_set_drvdata(&dev->dev, info);\r\nerr = register_netdev(info->netdev);\r\nif (err) {\r\npr_warn("%s: register_netdev err=%d\n", __func__, err);\r\ngoto fail;\r\n}\r\nerr = xennet_sysfs_addif(info->netdev);\r\nif (err) {\r\nunregister_netdev(info->netdev);\r\npr_warn("%s: add sysfs failed err=%d\n", __func__, err);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nfree_netdev(netdev);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nreturn err;\r\n}\r\nstatic void xennet_end_access(int ref, void *page)\r\n{\r\nif (ref != GRANT_INVALID_REF)\r\ngnttab_end_foreign_access(ref, 0, (unsigned long)page);\r\n}\r\nstatic void xennet_disconnect_backend(struct netfront_info *info)\r\n{\r\nspin_lock_bh(&info->rx_lock);\r\nspin_lock_irq(&info->tx_lock);\r\nnetif_carrier_off(info->netdev);\r\nspin_unlock_irq(&info->tx_lock);\r\nspin_unlock_bh(&info->rx_lock);\r\nif (info->tx_irq && (info->tx_irq == info->rx_irq))\r\nunbind_from_irqhandler(info->tx_irq, info);\r\nif (info->tx_irq && (info->tx_irq != info->rx_irq)) {\r\nunbind_from_irqhandler(info->tx_irq, info);\r\nunbind_from_irqhandler(info->rx_irq, info);\r\n}\r\ninfo->tx_evtchn = info->rx_evtchn = 0;\r\ninfo->tx_irq = info->rx_irq = 0;\r\nxennet_end_access(info->tx_ring_ref, info->tx.sring);\r\nxennet_end_access(info->rx_ring_ref, info->rx.sring);\r\ninfo->tx_ring_ref = GRANT_INVALID_REF;\r\ninfo->rx_ring_ref = GRANT_INVALID_REF;\r\ninfo->tx.sring = NULL;\r\ninfo->rx.sring = NULL;\r\n}\r\nstatic int netfront_resume(struct xenbus_device *dev)\r\n{\r\nstruct netfront_info *info = dev_get_drvdata(&dev->dev);\r\ndev_dbg(&dev->dev, "%s\n", dev->nodename);\r\nxennet_disconnect_backend(info);\r\nreturn 0;\r\n}\r\nstatic int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\r\n{\r\nchar *s, *e, *macstr;\r\nint i;\r\nmacstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);\r\nif (IS_ERR(macstr))\r\nreturn PTR_ERR(macstr);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nmac[i] = simple_strtoul(s, &e, 16);\r\nif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {\r\nkfree(macstr);\r\nreturn -ENOENT;\r\n}\r\ns = e+1;\r\n}\r\nkfree(macstr);\r\nreturn 0;\r\n}\r\nstatic int setup_netfront_single(struct netfront_info *info)\r\n{\r\nint err;\r\nerr = xenbus_alloc_evtchn(info->xbdev, &info->tx_evtchn);\r\nif (err < 0)\r\ngoto fail;\r\nerr = bind_evtchn_to_irqhandler(info->tx_evtchn,\r\nxennet_interrupt,\r\n0, info->netdev->name, info);\r\nif (err < 0)\r\ngoto bind_fail;\r\ninfo->rx_evtchn = info->tx_evtchn;\r\ninfo->rx_irq = info->tx_irq = err;\r\nreturn 0;\r\nbind_fail:\r\nxenbus_free_evtchn(info->xbdev, info->tx_evtchn);\r\ninfo->tx_evtchn = 0;\r\nfail:\r\nreturn err;\r\n}\r\nstatic int setup_netfront_split(struct netfront_info *info)\r\n{\r\nint err;\r\nerr = xenbus_alloc_evtchn(info->xbdev, &info->tx_evtchn);\r\nif (err < 0)\r\ngoto fail;\r\nerr = xenbus_alloc_evtchn(info->xbdev, &info->rx_evtchn);\r\nif (err < 0)\r\ngoto alloc_rx_evtchn_fail;\r\nsnprintf(info->tx_irq_name, sizeof(info->tx_irq_name),\r\n"%s-tx", info->netdev->name);\r\nerr = bind_evtchn_to_irqhandler(info->tx_evtchn,\r\nxennet_tx_interrupt,\r\n0, info->tx_irq_name, info);\r\nif (err < 0)\r\ngoto bind_tx_fail;\r\ninfo->tx_irq = err;\r\nsnprintf(info->rx_irq_name, sizeof(info->rx_irq_name),\r\n"%s-rx", info->netdev->name);\r\nerr = bind_evtchn_to_irqhandler(info->rx_evtchn,\r\nxennet_rx_interrupt,\r\n0, info->rx_irq_name, info);\r\nif (err < 0)\r\ngoto bind_rx_fail;\r\ninfo->rx_irq = err;\r\nreturn 0;\r\nbind_rx_fail:\r\nunbind_from_irqhandler(info->tx_irq, info);\r\ninfo->tx_irq = 0;\r\nbind_tx_fail:\r\nxenbus_free_evtchn(info->xbdev, info->rx_evtchn);\r\ninfo->rx_evtchn = 0;\r\nalloc_rx_evtchn_fail:\r\nxenbus_free_evtchn(info->xbdev, info->tx_evtchn);\r\ninfo->tx_evtchn = 0;\r\nfail:\r\nreturn err;\r\n}\r\nstatic int setup_netfront(struct xenbus_device *dev, struct netfront_info *info)\r\n{\r\nstruct xen_netif_tx_sring *txs;\r\nstruct xen_netif_rx_sring *rxs;\r\nint err;\r\nstruct net_device *netdev = info->netdev;\r\nunsigned int feature_split_evtchn;\r\ninfo->tx_ring_ref = GRANT_INVALID_REF;\r\ninfo->rx_ring_ref = GRANT_INVALID_REF;\r\ninfo->rx.sring = NULL;\r\ninfo->tx.sring = NULL;\r\nnetdev->irq = 0;\r\nerr = xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"feature-split-event-channels", "%u",\r\n&feature_split_evtchn);\r\nif (err < 0)\r\nfeature_split_evtchn = 0;\r\nerr = xen_net_read_mac(dev, netdev->dev_addr);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);\r\ngoto fail;\r\n}\r\ntxs = (struct xen_netif_tx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\r\nif (!txs) {\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(dev, err, "allocating tx ring page");\r\ngoto fail;\r\n}\r\nSHARED_RING_INIT(txs);\r\nFRONT_RING_INIT(&info->tx, txs, PAGE_SIZE);\r\nerr = xenbus_grant_ring(dev, virt_to_mfn(txs));\r\nif (err < 0)\r\ngoto grant_tx_ring_fail;\r\ninfo->tx_ring_ref = err;\r\nrxs = (struct xen_netif_rx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);\r\nif (!rxs) {\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(dev, err, "allocating rx ring page");\r\ngoto alloc_rx_ring_fail;\r\n}\r\nSHARED_RING_INIT(rxs);\r\nFRONT_RING_INIT(&info->rx, rxs, PAGE_SIZE);\r\nerr = xenbus_grant_ring(dev, virt_to_mfn(rxs));\r\nif (err < 0)\r\ngoto grant_rx_ring_fail;\r\ninfo->rx_ring_ref = err;\r\nif (feature_split_evtchn)\r\nerr = setup_netfront_split(info);\r\nif (!feature_split_evtchn || (feature_split_evtchn && err))\r\nerr = setup_netfront_single(info);\r\nif (err)\r\ngoto alloc_evtchn_fail;\r\nreturn 0;\r\nalloc_evtchn_fail:\r\ngnttab_end_foreign_access_ref(info->rx_ring_ref, 0);\r\ngrant_rx_ring_fail:\r\nfree_page((unsigned long)rxs);\r\nalloc_rx_ring_fail:\r\ngnttab_end_foreign_access_ref(info->tx_ring_ref, 0);\r\ngrant_tx_ring_fail:\r\nfree_page((unsigned long)txs);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int talk_to_netback(struct xenbus_device *dev,\r\nstruct netfront_info *info)\r\n{\r\nconst char *message;\r\nstruct xenbus_transaction xbt;\r\nint err;\r\nerr = setup_netfront(dev, info);\r\nif (err)\r\ngoto out;\r\nagain:\r\nerr = xenbus_transaction_start(&xbt);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "starting transaction");\r\ngoto destroy_ring;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "tx-ring-ref", "%u",\r\ninfo->tx_ring_ref);\r\nif (err) {\r\nmessage = "writing tx ring-ref";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "rx-ring-ref", "%u",\r\ninfo->rx_ring_ref);\r\nif (err) {\r\nmessage = "writing rx ring-ref";\r\ngoto abort_transaction;\r\n}\r\nif (info->tx_evtchn == info->rx_evtchn) {\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"event-channel", "%u", info->tx_evtchn);\r\nif (err) {\r\nmessage = "writing event-channel";\r\ngoto abort_transaction;\r\n}\r\n} else {\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"event-channel-tx", "%u", info->tx_evtchn);\r\nif (err) {\r\nmessage = "writing event-channel-tx";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"event-channel-rx", "%u", info->rx_evtchn);\r\nif (err) {\r\nmessage = "writing event-channel-rx";\r\ngoto abort_transaction;\r\n}\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "request-rx-copy", "%u",\r\n1);\r\nif (err) {\r\nmessage = "writing request-rx-copy";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-rx-notify", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-rx-notify";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-sg", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-sg";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv4", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv4";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_transaction_end(xbt, 0);\r\nif (err) {\r\nif (err == -EAGAIN)\r\ngoto again;\r\nxenbus_dev_fatal(dev, err, "completing transaction");\r\ngoto destroy_ring;\r\n}\r\nreturn 0;\r\nabort_transaction:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, err, "%s", message);\r\ndestroy_ring:\r\nxennet_disconnect_backend(info);\r\nout:\r\nreturn err;\r\n}\r\nstatic int xennet_connect(struct net_device *dev)\r\n{\r\nstruct netfront_info *np = netdev_priv(dev);\r\nint i, requeue_idx, err;\r\nstruct sk_buff *skb;\r\ngrant_ref_t ref;\r\nstruct xen_netif_rx_request *req;\r\nunsigned int feature_rx_copy;\r\nerr = xenbus_scanf(XBT_NIL, np->xbdev->otherend,\r\n"feature-rx-copy", "%u", &feature_rx_copy);\r\nif (err != 1)\r\nfeature_rx_copy = 0;\r\nif (!feature_rx_copy) {\r\ndev_info(&dev->dev,\r\n"backend does not support copying receive path\n");\r\nreturn -ENODEV;\r\n}\r\nerr = talk_to_netback(np->xbdev, np);\r\nif (err)\r\nreturn err;\r\nrtnl_lock();\r\nnetdev_update_features(dev);\r\nrtnl_unlock();\r\nspin_lock_bh(&np->rx_lock);\r\nspin_lock_irq(&np->tx_lock);\r\nxennet_release_tx_bufs(np);\r\nfor (requeue_idx = 0, i = 0; i < NET_RX_RING_SIZE; i++) {\r\nskb_frag_t *frag;\r\nconst struct page *page;\r\nif (!np->rx_skbs[i])\r\ncontinue;\r\nskb = np->rx_skbs[requeue_idx] = xennet_get_rx_skb(np, i);\r\nref = np->grant_rx_ref[requeue_idx] = xennet_get_rx_ref(np, i);\r\nreq = RING_GET_REQUEST(&np->rx, requeue_idx);\r\nfrag = &skb_shinfo(skb)->frags[0];\r\npage = skb_frag_page(frag);\r\ngnttab_grant_foreign_access_ref(\r\nref, np->xbdev->otherend_id,\r\npfn_to_mfn(page_to_pfn(page)),\r\n0);\r\nreq->gref = ref;\r\nreq->id = requeue_idx;\r\nrequeue_idx++;\r\n}\r\nnp->rx.req_prod_pvt = requeue_idx;\r\nnetif_carrier_on(np->netdev);\r\nnotify_remote_via_irq(np->tx_irq);\r\nif (np->tx_irq != np->rx_irq)\r\nnotify_remote_via_irq(np->rx_irq);\r\nxennet_tx_buf_gc(dev);\r\nxennet_alloc_rx_buffers(dev);\r\nspin_unlock_irq(&np->tx_lock);\r\nspin_unlock_bh(&np->rx_lock);\r\nreturn 0;\r\n}\r\nstatic void netback_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nstruct netfront_info *np = dev_get_drvdata(&dev->dev);\r\nstruct net_device *netdev = np->netdev;\r\ndev_dbg(&dev->dev, "%s\n", xenbus_strstate(backend_state));\r\nswitch (backend_state) {\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitialised:\r\ncase XenbusStateReconfiguring:\r\ncase XenbusStateReconfigured:\r\ncase XenbusStateUnknown:\r\ncase XenbusStateClosed:\r\nbreak;\r\ncase XenbusStateInitWait:\r\nif (dev->state != XenbusStateInitialising)\r\nbreak;\r\nif (xennet_connect(netdev) != 0)\r\nbreak;\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateConnected:\r\nnetdev_notify_peers(netdev);\r\nbreak;\r\ncase XenbusStateClosing:\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int xennet_get_sset_count(struct net_device *dev, int string_set)\r\n{\r\nswitch (string_set) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(xennet_stats);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void xennet_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 * data)\r\n{\r\nvoid *np = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(xennet_stats); i++)\r\ndata[i] = *(unsigned long *)(np + xennet_stats[i].offset);\r\n}\r\nstatic void xennet_get_strings(struct net_device *dev, u32 stringset, u8 * data)\r\n{\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < ARRAY_SIZE(xennet_stats); i++)\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nxennet_stats[i].name, ETH_GSTRING_LEN);\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t show_rxbuf_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net_device *netdev = to_net_dev(dev);\r\nstruct netfront_info *info = netdev_priv(netdev);\r\nreturn sprintf(buf, "%u\n", info->rx_min_target);\r\n}\r\nstatic ssize_t store_rxbuf_min(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct net_device *netdev = to_net_dev(dev);\r\nstruct netfront_info *np = netdev_priv(netdev);\r\nchar *endp;\r\nunsigned long target;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ntarget = simple_strtoul(buf, &endp, 0);\r\nif (endp == buf)\r\nreturn -EBADMSG;\r\nif (target < RX_MIN_TARGET)\r\ntarget = RX_MIN_TARGET;\r\nif (target > RX_MAX_TARGET)\r\ntarget = RX_MAX_TARGET;\r\nspin_lock_bh(&np->rx_lock);\r\nif (target > np->rx_max_target)\r\nnp->rx_max_target = target;\r\nnp->rx_min_target = target;\r\nif (target > np->rx_target)\r\nnp->rx_target = target;\r\nxennet_alloc_rx_buffers(netdev);\r\nspin_unlock_bh(&np->rx_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t show_rxbuf_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net_device *netdev = to_net_dev(dev);\r\nstruct netfront_info *info = netdev_priv(netdev);\r\nreturn sprintf(buf, "%u\n", info->rx_max_target);\r\n}\r\nstatic ssize_t store_rxbuf_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct net_device *netdev = to_net_dev(dev);\r\nstruct netfront_info *np = netdev_priv(netdev);\r\nchar *endp;\r\nunsigned long target;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ntarget = simple_strtoul(buf, &endp, 0);\r\nif (endp == buf)\r\nreturn -EBADMSG;\r\nif (target < RX_MIN_TARGET)\r\ntarget = RX_MIN_TARGET;\r\nif (target > RX_MAX_TARGET)\r\ntarget = RX_MAX_TARGET;\r\nspin_lock_bh(&np->rx_lock);\r\nif (target < np->rx_min_target)\r\nnp->rx_min_target = target;\r\nnp->rx_max_target = target;\r\nif (target < np->rx_target)\r\nnp->rx_target = target;\r\nxennet_alloc_rx_buffers(netdev);\r\nspin_unlock_bh(&np->rx_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t show_rxbuf_cur(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net_device *netdev = to_net_dev(dev);\r\nstruct netfront_info *info = netdev_priv(netdev);\r\nreturn sprintf(buf, "%u\n", info->rx_target);\r\n}\r\nstatic int xennet_sysfs_addif(struct net_device *netdev)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(xennet_attrs); i++) {\r\nerr = device_create_file(&netdev->dev,\r\n&xennet_attrs[i]);\r\nif (err)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nwhile (--i >= 0)\r\ndevice_remove_file(&netdev->dev, &xennet_attrs[i]);\r\nreturn err;\r\n}\r\nstatic void xennet_sysfs_delif(struct net_device *netdev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(xennet_attrs); i++)\r\ndevice_remove_file(&netdev->dev, &xennet_attrs[i]);\r\n}\r\nstatic int xennet_remove(struct xenbus_device *dev)\r\n{\r\nstruct netfront_info *info = dev_get_drvdata(&dev->dev);\r\ndev_dbg(&dev->dev, "%s\n", dev->nodename);\r\nxennet_disconnect_backend(info);\r\nxennet_sysfs_delif(info->netdev);\r\nunregister_netdev(info->netdev);\r\ndel_timer_sync(&info->rx_refill_timer);\r\nfree_percpu(info->stats);\r\nfree_netdev(info->netdev);\r\nreturn 0;\r\n}\r\nstatic int __init netif_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (xen_hvm_domain() && !xen_platform_pci_unplug)\r\nreturn -ENODEV;\r\npr_info("Initialising Xen virtual ethernet driver\n");\r\nreturn xenbus_register_frontend(&netfront_driver);\r\n}\r\nstatic void __exit netif_exit(void)\r\n{\r\nxenbus_unregister_driver(&netfront_driver);\r\n}
