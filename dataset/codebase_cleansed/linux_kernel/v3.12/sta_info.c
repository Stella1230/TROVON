static int sta_info_hash_del(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nstruct sta_info *s;\r\ns = rcu_dereference_protected(local->sta_hash[STA_HASH(sta->sta.addr)],\r\nlockdep_is_held(&local->sta_mtx));\r\nif (!s)\r\nreturn -ENOENT;\r\nif (s == sta) {\r\nrcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)],\r\ns->hnext);\r\nreturn 0;\r\n}\r\nwhile (rcu_access_pointer(s->hnext) &&\r\nrcu_access_pointer(s->hnext) != sta)\r\ns = rcu_dereference_protected(s->hnext,\r\nlockdep_is_held(&local->sta_mtx));\r\nif (rcu_access_pointer(s->hnext)) {\r\nrcu_assign_pointer(s->hnext, sta->hnext);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void cleanup_single_sta(struct sta_info *sta)\r\n{\r\nint ac, i;\r\nstruct tid_ampdu_tx *tid_tx;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ps_data *ps;\r\nif (test_sta_flag(sta, WLAN_STA_PS_STA)) {\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\r\nps = &sdata->bss->ps;\r\nelse if (ieee80211_vif_is_mesh(&sdata->vif))\r\nps = &sdata->u.mesh.ps;\r\nelse\r\nreturn;\r\nclear_sta_flag(sta, WLAN_STA_PS_STA);\r\natomic_dec(&ps->num_sta_ps);\r\nsta_info_recalc_tim(sta);\r\n}\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nlocal->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);\r\nieee80211_purge_tx_queue(&local->hw, &sta->ps_tx_buf[ac]);\r\nieee80211_purge_tx_queue(&local->hw, &sta->tx_filtered[ac]);\r\n}\r\nif (ieee80211_vif_is_mesh(&sdata->vif))\r\nmesh_sta_cleanup(sta);\r\ncancel_work_sync(&sta->drv_unblock_wk);\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\nkfree(sta->ampdu_mlme.tid_start_tx[i]);\r\ntid_tx = rcu_dereference_raw(sta->ampdu_mlme.tid_tx[i]);\r\nif (!tid_tx)\r\ncontinue;\r\nieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);\r\nkfree(tid_tx);\r\n}\r\nsta_info_free(local, sta);\r\n}\r\nvoid ieee80211_cleanup_sdata_stas(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct sta_info *sta;\r\nspin_lock_bh(&sdata->cleanup_stations_lock);\r\nwhile (!list_empty(&sdata->cleanup_stations)) {\r\nsta = list_first_entry(&sdata->cleanup_stations,\r\nstruct sta_info, list);\r\nlist_del(&sta->list);\r\nspin_unlock_bh(&sdata->cleanup_stations_lock);\r\ncleanup_single_sta(sta);\r\nspin_lock_bh(&sdata->cleanup_stations_lock);\r\n}\r\nspin_unlock_bh(&sdata->cleanup_stations_lock);\r\n}\r\nstatic void free_sta_rcu(struct rcu_head *h)\r\n{\r\nstruct sta_info *sta = container_of(h, struct sta_info, rcu_head);\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nspin_lock(&sdata->cleanup_stations_lock);\r\nlist_add_tail(&sta->list, &sdata->cleanup_stations);\r\nspin_unlock(&sdata->cleanup_stations_lock);\r\nieee80211_queue_work(&sdata->local->hw, &sdata->cleanup_stations_wk);\r\n}\r\nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nsta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],\r\nlockdep_is_held(&local->sta_mtx));\r\nwhile (sta) {\r\nif (sta->sdata == sdata &&\r\nether_addr_equal(sta->sta.addr, addr))\r\nbreak;\r\nsta = rcu_dereference_check(sta->hnext,\r\nlockdep_is_held(&local->sta_mtx));\r\n}\r\nreturn sta;\r\n}\r\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nsta = rcu_dereference_check(local->sta_hash[STA_HASH(addr)],\r\nlockdep_is_held(&local->sta_mtx));\r\nwhile (sta) {\r\nif ((sta->sdata == sdata ||\r\n(sta->sdata->bss && sta->sdata->bss == sdata->bss)) &&\r\nether_addr_equal(sta->sta.addr, addr))\r\nbreak;\r\nsta = rcu_dereference_check(sta->hnext,\r\nlockdep_is_held(&local->sta_mtx));\r\n}\r\nreturn sta;\r\n}\r\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\r\nint idx)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nint i = 0;\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list) {\r\nif (sdata != sta->sdata)\r\ncontinue;\r\nif (i < idx) {\r\n++i;\r\ncontinue;\r\n}\r\nreturn sta;\r\n}\r\nreturn NULL;\r\n}\r\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta)\r\n{\r\nif (sta->rate_ctrl)\r\nrate_control_free_sta(sta);\r\nsta_dbg(sta->sdata, "Destroyed STA %pM\n", sta->sta.addr);\r\nkfree(sta);\r\n}\r\nstatic void sta_info_hash_add(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nlockdep_assert_held(&local->sta_mtx);\r\nsta->hnext = local->sta_hash[STA_HASH(sta->sta.addr)];\r\nrcu_assign_pointer(local->sta_hash[STA_HASH(sta->sta.addr)], sta);\r\n}\r\nstatic void sta_unblock(struct work_struct *wk)\r\n{\r\nstruct sta_info *sta;\r\nsta = container_of(wk, struct sta_info, drv_unblock_wk);\r\nif (sta->dead)\r\nreturn;\r\nif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\r\nlocal_bh_disable();\r\nieee80211_sta_ps_deliver_wakeup(sta);\r\nlocal_bh_enable();\r\n} else if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL)) {\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nlocal_bh_disable();\r\nieee80211_sta_ps_deliver_poll_response(sta);\r\nlocal_bh_enable();\r\n} else if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD)) {\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nlocal_bh_disable();\r\nieee80211_sta_ps_deliver_uapsd(sta);\r\nlocal_bh_enable();\r\n} else\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\n}\r\nstatic int sta_prepare_rate_control(struct ieee80211_local *local,\r\nstruct sta_info *sta, gfp_t gfp)\r\n{\r\nif (local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL)\r\nreturn 0;\r\nsta->rate_ctrl = local->rate_ctrl;\r\nsta->rate_ctrl_priv = rate_control_alloc_sta(sta->rate_ctrl,\r\n&sta->sta, gfp);\r\nif (!sta->rate_ctrl_priv)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr, gfp_t gfp)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nstruct timespec uptime;\r\nint i;\r\nsta = kzalloc(sizeof(*sta) + local->hw.sta_data_size, gfp);\r\nif (!sta)\r\nreturn NULL;\r\nspin_lock_init(&sta->lock);\r\nINIT_WORK(&sta->drv_unblock_wk, sta_unblock);\r\nINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\r\nmutex_init(&sta->ampdu_mlme.mtx);\r\n#ifdef CONFIG_MAC80211_MESH\r\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\r\n!sdata->u.mesh.user_mpm)\r\ninit_timer(&sta->plink_timer);\r\nsta->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\r\n#endif\r\nmemcpy(sta->sta.addr, addr, ETH_ALEN);\r\nsta->local = local;\r\nsta->sdata = sdata;\r\nsta->last_rx = jiffies;\r\nsta->sta_state = IEEE80211_STA_NONE;\r\ndo_posix_clock_monotonic_gettime(&uptime);\r\nsta->last_connected = uptime.tv_sec;\r\newma_init(&sta->avg_signal, 1024, 8);\r\nfor (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)\r\newma_init(&sta->chain_signal_avg[i], 1024, 8);\r\nif (sta_prepare_rate_control(local, sta, gfp)) {\r\nkfree(sta);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\nsta->timer_to_tid[i] = i;\r\n}\r\nfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\r\nskb_queue_head_init(&sta->ps_tx_buf[i]);\r\nskb_queue_head_init(&sta->tx_filtered[i]);\r\n}\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\r\nsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\r\nsta->sta.smps_mode = IEEE80211_SMPS_OFF;\r\nsta_dbg(sdata, "Allocated STA %pM\n", sta->sta.addr);\r\nreturn sta;\r\n}\r\nstatic int sta_info_insert_check(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nif (unlikely(!ieee80211_sdata_running(sdata)))\r\nreturn -ENETDOWN;\r\nif (WARN_ON(ether_addr_equal(sta->sta.addr, sdata->vif.addr) ||\r\nis_multicast_ether_addr(sta->sta.addr)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sta_info_insert_drv_state(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta)\r\n{\r\nenum ieee80211_sta_state state;\r\nint err = 0;\r\nfor (state = IEEE80211_STA_NOTEXIST; state < sta->sta_state; state++) {\r\nerr = drv_sta_state(local, sdata, sta, state, state + 1);\r\nif (err)\r\nbreak;\r\n}\r\nif (!err) {\r\nif (!local->ops->sta_add)\r\nsta->uploaded = true;\r\nreturn 0;\r\n}\r\nif (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\r\nsdata_info(sdata,\r\n"failed to move IBSS STA %pM to state %d (%d) - keeping it anyway\n",\r\nsta->sta.addr, state + 1, err);\r\nerr = 0;\r\n}\r\nfor (; state > IEEE80211_STA_NOTEXIST; state--)\r\nWARN_ON(drv_sta_state(local, sdata, sta, state, state - 1));\r\nreturn err;\r\n}\r\nstatic int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct station_info sinfo;\r\nint err = 0;\r\nlockdep_assert_held(&local->sta_mtx);\r\nif (sta_info_get_bss(sdata, sta->sta.addr)) {\r\nerr = -EEXIST;\r\ngoto out_err;\r\n}\r\nerr = sta_info_insert_drv_state(local, sdata, sta);\r\nif (err)\r\ngoto out_err;\r\nlocal->num_sta++;\r\nlocal->sta_generation++;\r\nsmp_mb();\r\nsta_info_hash_add(local, sta);\r\nlist_add_rcu(&sta->list, &local->sta_list);\r\nset_sta_flag(sta, WLAN_STA_INSERTED);\r\nieee80211_sta_debugfs_add(sta);\r\nrate_control_add_sta_debugfs(sta);\r\nmemset(&sinfo, 0, sizeof(sinfo));\r\nsinfo.filled = 0;\r\nsinfo.generation = local->sta_generation;\r\ncfg80211_new_sta(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);\r\nsta_dbg(sdata, "Inserted STA %pM\n", sta->sta.addr);\r\nrcu_read_lock();\r\nmutex_unlock(&local->sta_mtx);\r\nif (ieee80211_vif_is_mesh(&sdata->vif))\r\nmesh_accept_plinks_update(sdata);\r\nreturn 0;\r\nout_err:\r\nmutex_unlock(&local->sta_mtx);\r\nrcu_read_lock();\r\nreturn err;\r\n}\r\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nint err = 0;\r\nmight_sleep();\r\nerr = sta_info_insert_check(sta);\r\nif (err) {\r\nrcu_read_lock();\r\ngoto out_free;\r\n}\r\nmutex_lock(&local->sta_mtx);\r\nerr = sta_info_insert_finish(sta);\r\nif (err)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nBUG_ON(!err);\r\nsta_info_free(local, sta);\r\nreturn err;\r\n}\r\nint sta_info_insert(struct sta_info *sta)\r\n{\r\nint err = sta_info_insert_rcu(sta);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic inline void __bss_tim_set(u8 *tim, u16 id)\r\n{\r\ntim[id / 8] |= (1 << (id % 8));\r\n}\r\nstatic inline void __bss_tim_clear(u8 *tim, u16 id)\r\n{\r\ntim[id / 8] &= ~(1 << (id % 8));\r\n}\r\nstatic inline bool __bss_tim_get(u8 *tim, u16 id)\r\n{\r\nreturn tim[id / 8] & (1 << (id % 8));\r\n}\r\nstatic unsigned long ieee80211_tids_for_ac(int ac)\r\n{\r\nswitch (ac) {\r\ncase IEEE80211_AC_VO:\r\nreturn BIT(6) | BIT(7);\r\ncase IEEE80211_AC_VI:\r\nreturn BIT(4) | BIT(5);\r\ncase IEEE80211_AC_BE:\r\nreturn BIT(0) | BIT(3);\r\ncase IEEE80211_AC_BK:\r\nreturn BIT(1) | BIT(2);\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\n}\r\nvoid sta_info_recalc_tim(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ps_data *ps;\r\nbool indicate_tim = false;\r\nu8 ignore_for_tim = sta->sta.uapsd_queues;\r\nint ac;\r\nu16 id;\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\r\nif (WARN_ON_ONCE(!sta->sdata->bss))\r\nreturn;\r\nps = &sta->sdata->bss->ps;\r\nid = sta->sta.aid;\r\n#ifdef CONFIG_MAC80211_MESH\r\n} else if (ieee80211_vif_is_mesh(&sta->sdata->vif)) {\r\nps = &sta->sdata->u.mesh.ps;\r\nid = le16_to_cpu(sta->plid) % IEEE80211_MAX_AID;\r\n#endif\r\n} else {\r\nreturn;\r\n}\r\nif (local->hw.flags & IEEE80211_HW_AP_LINK_PS)\r\nreturn;\r\nif (sta->dead)\r\ngoto done;\r\nif (ignore_for_tim == BIT(IEEE80211_NUM_ACS) - 1)\r\nignore_for_tim = 0;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nunsigned long tids;\r\nif (ignore_for_tim & BIT(ac))\r\ncontinue;\r\nindicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||\r\n!skb_queue_empty(&sta->ps_tx_buf[ac]);\r\nif (indicate_tim)\r\nbreak;\r\ntids = ieee80211_tids_for_ac(ac);\r\nindicate_tim |=\r\nsta->driver_buffered_tids & tids;\r\n}\r\ndone:\r\nspin_lock_bh(&local->tim_lock);\r\nif (indicate_tim == __bss_tim_get(ps->tim, id))\r\ngoto out_unlock;\r\nif (indicate_tim)\r\n__bss_tim_set(ps->tim, id);\r\nelse\r\n__bss_tim_clear(ps->tim, id);\r\nif (local->ops->set_tim) {\r\nlocal->tim_in_locked_section = true;\r\ndrv_set_tim(local, &sta->sta, indicate_tim);\r\nlocal->tim_in_locked_section = false;\r\n}\r\nout_unlock:\r\nspin_unlock_bh(&local->tim_lock);\r\n}\r\nstatic bool sta_info_buffer_expired(struct sta_info *sta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_tx_info *info;\r\nint timeout;\r\nif (!skb)\r\nreturn false;\r\ninfo = IEEE80211_SKB_CB(skb);\r\ntimeout = (sta->listen_interval *\r\nsta->sdata->vif.bss_conf.beacon_int *\r\n32 / 15625) * HZ;\r\nif (timeout < STA_TX_BUFFER_EXPIRE)\r\ntimeout = STA_TX_BUFFER_EXPIRE;\r\nreturn time_after(jiffies, info->control.jiffies + timeout);\r\n}\r\nstatic bool sta_info_cleanup_expire_buffered_ac(struct ieee80211_local *local,\r\nstruct sta_info *sta, int ac)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nfor (;;) {\r\nspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\r\nskb = skb_peek(&sta->tx_filtered[ac]);\r\nif (sta_info_buffer_expired(sta, skb))\r\nskb = __skb_dequeue(&sta->tx_filtered[ac]);\r\nelse\r\nskb = NULL;\r\nspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\r\nif (!skb)\r\nbreak;\r\nieee80211_free_txskb(&local->hw, skb);\r\n}\r\nfor (;;) {\r\nspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\r\nskb = skb_peek(&sta->ps_tx_buf[ac]);\r\nif (sta_info_buffer_expired(sta, skb))\r\nskb = __skb_dequeue(&sta->ps_tx_buf[ac]);\r\nelse\r\nskb = NULL;\r\nspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\r\nif (!skb)\r\nbreak;\r\nlocal->total_ps_buffered--;\r\nps_dbg(sta->sdata, "Buffered frame expired (STA %pM)\n",\r\nsta->sta.addr);\r\nieee80211_free_txskb(&local->hw, skb);\r\n}\r\nsta_info_recalc_tim(sta);\r\nreturn !(skb_queue_empty(&sta->ps_tx_buf[ac]) &&\r\nskb_queue_empty(&sta->tx_filtered[ac]));\r\n}\r\nstatic bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,\r\nstruct sta_info *sta)\r\n{\r\nbool have_buffered = false;\r\nint ac;\r\nif (!sta->sdata->bss &&\r\n!ieee80211_vif_is_mesh(&sta->sdata->vif))\r\nreturn false;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\nhave_buffered |=\r\nsta_info_cleanup_expire_buffered_ac(local, sta, ac);\r\nreturn have_buffered;\r\n}\r\nint __must_check __sta_info_destroy(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local;\r\nstruct ieee80211_sub_if_data *sdata;\r\nint ret;\r\nmight_sleep();\r\nif (!sta)\r\nreturn -ENOENT;\r\nlocal = sta->local;\r\nsdata = sta->sdata;\r\nlockdep_assert_held(&local->sta_mtx);\r\nset_sta_flag(sta, WLAN_STA_BLOCK_BA);\r\nieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\r\nret = sta_info_hash_del(local, sta);\r\nif (ret)\r\nreturn ret;\r\nlist_del_rcu(&sta->list);\r\nieee80211_free_sta_keys(local, sta);\r\nsta->dead = true;\r\nlocal->num_sta--;\r\nlocal->sta_generation++;\r\nif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\r\nRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\r\nwhile (sta->sta_state > IEEE80211_STA_NONE) {\r\nret = sta_info_move_state(sta, sta->sta_state - 1);\r\nif (ret) {\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\n}\r\nif (sta->uploaded) {\r\nret = drv_sta_state(local, sdata, sta, IEEE80211_STA_NONE,\r\nIEEE80211_STA_NOTEXIST);\r\nWARN_ON_ONCE(ret != 0);\r\n}\r\nsta_dbg(sdata, "Removed STA %pM\n", sta->sta.addr);\r\ncfg80211_del_sta(sdata->dev, sta->sta.addr, GFP_KERNEL);\r\nrate_control_remove_sta_debugfs(sta);\r\nieee80211_sta_debugfs_remove(sta);\r\ncall_rcu(&sta->rcu_head, free_sta_rcu);\r\nreturn 0;\r\n}\r\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata, const u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret;\r\nmutex_lock(&sdata->local->sta_mtx);\r\nsta = sta_info_get(sdata, addr);\r\nret = __sta_info_destroy(sta);\r\nmutex_unlock(&sdata->local->sta_mtx);\r\nreturn ret;\r\n}\r\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nint ret;\r\nmutex_lock(&sdata->local->sta_mtx);\r\nsta = sta_info_get_bss(sdata, addr);\r\nret = __sta_info_destroy(sta);\r\nmutex_unlock(&sdata->local->sta_mtx);\r\nreturn ret;\r\n}\r\nstatic void sta_info_cleanup(unsigned long data)\r\n{\r\nstruct ieee80211_local *local = (struct ieee80211_local *) data;\r\nstruct sta_info *sta;\r\nbool timer_needed = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sta, &local->sta_list, list)\r\nif (sta_info_cleanup_expire_buffered(local, sta))\r\ntimer_needed = true;\r\nrcu_read_unlock();\r\nif (local->quiescing)\r\nreturn;\r\nif (!timer_needed)\r\nreturn;\r\nmod_timer(&local->sta_cleanup,\r\nround_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));\r\n}\r\nvoid sta_info_init(struct ieee80211_local *local)\r\n{\r\nspin_lock_init(&local->tim_lock);\r\nmutex_init(&local->sta_mtx);\r\nINIT_LIST_HEAD(&local->sta_list);\r\nsetup_timer(&local->sta_cleanup, sta_info_cleanup,\r\n(unsigned long)local);\r\n}\r\nvoid sta_info_stop(struct ieee80211_local *local)\r\n{\r\ndel_timer_sync(&local->sta_cleanup);\r\n}\r\nint sta_info_flush_defer(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta, *tmp;\r\nint ret = 0;\r\nmight_sleep();\r\nmutex_lock(&local->sta_mtx);\r\nlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\r\nif (sdata == sta->sdata) {\r\nWARN_ON(__sta_info_destroy(sta));\r\nret++;\r\n}\r\n}\r\nmutex_unlock(&local->sta_mtx);\r\nreturn ret;\r\n}\r\nvoid sta_info_flush_cleanup(struct ieee80211_sub_if_data *sdata)\r\n{\r\nieee80211_cleanup_sdata_stas(sdata);\r\ncancel_work_sync(&sdata->cleanup_stations_wk);\r\n}\r\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\r\nunsigned long exp_time)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta, *tmp;\r\nmutex_lock(&local->sta_mtx);\r\nlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\r\nif (sdata != sta->sdata)\r\ncontinue;\r\nif (time_after(jiffies, sta->last_rx + exp_time)) {\r\nsta_dbg(sta->sdata, "expiring inactive STA %pM\n",\r\nsta->sta.addr);\r\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\r\ntest_sta_flag(sta, WLAN_STA_PS_STA))\r\natomic_dec(&sdata->u.mesh.ps.num_sta_ps);\r\nWARN_ON(__sta_info_destroy(sta));\r\n}\r\n}\r\nmutex_unlock(&local->sta_mtx);\r\n}\r\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\r\nconst u8 *addr,\r\nconst u8 *localaddr)\r\n{\r\nstruct sta_info *sta, *nxt;\r\nfor_each_sta_info(hw_to_local(hw), addr, sta, nxt) {\r\nif (localaddr &&\r\n!ether_addr_equal(sta->sdata->vif.addr, localaddr))\r\ncontinue;\r\nif (!sta->uploaded)\r\nreturn NULL;\r\nreturn &sta->sta;\r\n}\r\nreturn NULL;\r\n}\r\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\r\nconst u8 *addr)\r\n{\r\nstruct sta_info *sta;\r\nif (!vif)\r\nreturn NULL;\r\nsta = sta_info_get_bss(vif_to_sdata(vif), addr);\r\nif (!sta)\r\nreturn NULL;\r\nif (!sta->uploaded)\r\nreturn NULL;\r\nreturn &sta->sta;\r\n}\r\nstatic void clear_sta_ps_flags(void *_sta)\r\n{\r\nstruct sta_info *sta = _sta;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ps_data *ps;\r\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN)\r\nps = &sdata->bss->ps;\r\nelse if (ieee80211_vif_is_mesh(&sdata->vif))\r\nps = &sdata->u.mesh.ps;\r\nelse\r\nreturn;\r\nclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nif (test_and_clear_sta_flag(sta, WLAN_STA_PS_STA))\r\natomic_dec(&ps->num_sta_ps);\r\n}\r\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff_head pending;\r\nint filtered = 0, buffered = 0, ac;\r\nunsigned long flags;\r\nclear_sta_flag(sta, WLAN_STA_SP);\r\nBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\r\nsta->driver_buffered_tids = 0;\r\nif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\r\ndrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\r\nskb_queue_head_init(&pending);\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nint count = skb_queue_len(&pending), tmp;\r\nspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\r\nskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\r\nspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\r\ntmp = skb_queue_len(&pending);\r\nfiltered += tmp - count;\r\ncount = tmp;\r\nspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\r\nskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\r\nspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\r\ntmp = skb_queue_len(&pending);\r\nbuffered += tmp - count;\r\n}\r\nieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\r\nlocal->total_ps_buffered -= buffered;\r\nsta_info_recalc_tim(sta);\r\nps_dbg(sdata,\r\n"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\n",\r\nsta->sta.addr, sta->sta.aid, filtered, buffered);\r\n}\r\nstatic void ieee80211_send_null_response(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta, int tid,\r\nenum ieee80211_frame_release_type reason)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_qos_hdr *nullfunc;\r\nstruct sk_buff *skb;\r\nint size = sizeof(*nullfunc);\r\n__le16 fc;\r\nbool qos = test_sta_flag(sta, WLAN_STA_WME);\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nif (qos) {\r\nfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_QOS_NULLFUNC |\r\nIEEE80211_FCTL_FROMDS);\r\n} else {\r\nsize -= 2;\r\nfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_NULLFUNC |\r\nIEEE80211_FCTL_FROMDS);\r\n}\r\nskb = dev_alloc_skb(local->hw.extra_tx_headroom + size);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nnullfunc = (void *) skb_put(skb, size);\r\nnullfunc->frame_control = fc;\r\nnullfunc->duration_id = 0;\r\nmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\r\nmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);\r\nskb->priority = tid;\r\nskb_set_queue_mapping(skb, ieee802_1d_to_ac[tid]);\r\nif (qos) {\r\nnullfunc->qos_ctrl = cpu_to_le16(tid);\r\nif (reason == IEEE80211_FRAME_RELEASE_UAPSD)\r\nnullfunc->qos_ctrl |=\r\ncpu_to_le16(IEEE80211_QOS_CTL_EOSP);\r\n}\r\ninfo = IEEE80211_SKB_CB(skb);\r\ninfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\r\nIEEE80211_TX_CTL_PS_RESPONSE |\r\nIEEE80211_TX_STATUS_EOSP |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\ndrv_allow_buffered_frames(local, sta, BIT(tid), 1, reason, false);\r\nskb->dev = sdata->dev;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nieee80211_xmit(sdata, skb, chanctx_conf->def.chan->band);\r\nrcu_read_unlock();\r\n}\r\nstatic void\r\nieee80211_sta_ps_deliver_response(struct sta_info *sta,\r\nint n_frames, u8 ignored_acs,\r\nenum ieee80211_frame_release_type reason)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nbool found = false;\r\nbool more_data = false;\r\nint ac;\r\nunsigned long driver_release_tids = 0;\r\nstruct sk_buff_head frames;\r\nset_sta_flag(sta, WLAN_STA_SP);\r\n__skb_queue_head_init(&frames);\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\r\nunsigned long tids;\r\nif (ignored_acs & BIT(ac))\r\ncontinue;\r\ntids = ieee80211_tids_for_ac(ac);\r\nif (!found) {\r\ndriver_release_tids = sta->driver_buffered_tids & tids;\r\nif (driver_release_tids) {\r\nfound = true;\r\n} else {\r\nstruct sk_buff *skb;\r\nwhile (n_frames > 0) {\r\nskb = skb_dequeue(&sta->tx_filtered[ac]);\r\nif (!skb) {\r\nskb = skb_dequeue(\r\n&sta->ps_tx_buf[ac]);\r\nif (skb)\r\nlocal->total_ps_buffered--;\r\n}\r\nif (!skb)\r\nbreak;\r\nn_frames--;\r\nfound = true;\r\n__skb_queue_tail(&frames, skb);\r\n}\r\n}\r\nif (reason == IEEE80211_FRAME_RELEASE_PSPOLL &&\r\nhweight16(driver_release_tids) > 1) {\r\nmore_data = true;\r\ndriver_release_tids =\r\nBIT(ffs(driver_release_tids) - 1);\r\nbreak;\r\n}\r\n}\r\nif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\r\n!skb_queue_empty(&sta->ps_tx_buf[ac])) {\r\nmore_data = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nint tid;\r\ntid = 7 - ((ffs(~ignored_acs) - 1) << 1);\r\nieee80211_send_null_response(sdata, sta, tid, reason);\r\nreturn;\r\n}\r\nif (!driver_release_tids) {\r\nstruct sk_buff_head pending;\r\nstruct sk_buff *skb;\r\nint num = 0;\r\nu16 tids = 0;\r\nskb_queue_head_init(&pending);\r\nwhile ((skb = __skb_dequeue(&frames))) {\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (void *) skb->data;\r\nu8 *qoshdr = NULL;\r\nnum++;\r\ninfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\r\nIEEE80211_TX_CTL_PS_RESPONSE;\r\nif (more_data || !skb_queue_empty(&frames))\r\nhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FCTL_MOREDATA);\r\nelse\r\nhdr->frame_control &=\r\ncpu_to_le16(~IEEE80211_FCTL_MOREDATA);\r\nif (ieee80211_is_data_qos(hdr->frame_control) ||\r\nieee80211_is_qos_nullfunc(hdr->frame_control))\r\nqoshdr = ieee80211_get_qos_ctl(hdr);\r\nif (skb_queue_empty(&frames)) {\r\nif (reason == IEEE80211_FRAME_RELEASE_UAPSD &&\r\nqoshdr)\r\n*qoshdr |= IEEE80211_QOS_CTL_EOSP;\r\ninfo->flags |= IEEE80211_TX_STATUS_EOSP |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\n}\r\nif (qoshdr)\r\ntids |= BIT(*qoshdr & IEEE80211_QOS_CTL_TID_MASK);\r\nelse\r\ntids |= BIT(0);\r\n__skb_queue_tail(&pending, skb);\r\n}\r\ndrv_allow_buffered_frames(local, sta, tids, num,\r\nreason, more_data);\r\nieee80211_add_pending_skbs(local, &pending);\r\nsta_info_recalc_tim(sta);\r\n} else {\r\ndrv_release_buffered_frames(local, sta, driver_release_tids,\r\nn_frames, reason, more_data);\r\n}\r\n}\r\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta)\r\n{\r\nu8 ignore_for_response = sta->sta.uapsd_queues;\r\nif (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)\r\nignore_for_response = 0;\r\nieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,\r\nIEEE80211_FRAME_RELEASE_PSPOLL);\r\n}\r\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta)\r\n{\r\nint n_frames = sta->sta.max_sp;\r\nu8 delivery_enabled = sta->sta.uapsd_queues;\r\nif (!delivery_enabled)\r\nreturn;\r\nswitch (sta->sta.max_sp) {\r\ncase 1:\r\nn_frames = 2;\r\nbreak;\r\ncase 2:\r\nn_frames = 4;\r\nbreak;\r\ncase 3:\r\nn_frames = 6;\r\nbreak;\r\ncase 0:\r\nn_frames = 8;\r\nbreak;\r\n}\r\nieee80211_sta_ps_deliver_response(sta, n_frames, ~delivery_enabled,\r\nIEEE80211_FRAME_RELEASE_UAPSD);\r\n}\r\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *pubsta, bool block)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\ntrace_api_sta_block_awake(sta->local, pubsta, block);\r\nif (block)\r\nset_sta_flag(sta, WLAN_STA_PS_DRIVER);\r\nelse if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))\r\nieee80211_queue_work(hw, &sta->drv_unblock_wk);\r\n}\r\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nstruct ieee80211_local *local = sta->local;\r\ntrace_api_eosp(local, pubsta);\r\nclear_sta_flag(sta, WLAN_STA_SP);\r\n}\r\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,\r\nu8 tid, bool buffered)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\r\nreturn;\r\nif (buffered)\r\nset_bit(tid, &sta->driver_buffered_tids);\r\nelse\r\nclear_bit(tid, &sta->driver_buffered_tids);\r\nsta_info_recalc_tim(sta);\r\n}\r\nint sta_info_move_state(struct sta_info *sta,\r\nenum ieee80211_sta_state new_state)\r\n{\r\nmight_sleep();\r\nif (sta->sta_state == new_state)\r\nreturn 0;\r\nswitch (new_state) {\r\ncase IEEE80211_STA_NONE:\r\nif (sta->sta_state != IEEE80211_STA_AUTH)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IEEE80211_STA_AUTH:\r\nif (sta->sta_state != IEEE80211_STA_NONE &&\r\nsta->sta_state != IEEE80211_STA_ASSOC)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IEEE80211_STA_ASSOC:\r\nif (sta->sta_state != IEEE80211_STA_AUTH &&\r\nsta->sta_state != IEEE80211_STA_AUTHORIZED)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IEEE80211_STA_AUTHORIZED:\r\nif (sta->sta_state != IEEE80211_STA_ASSOC)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nWARN(1, "invalid state %d", new_state);\r\nreturn -EINVAL;\r\n}\r\nsta_dbg(sta->sdata, "moving STA %pM to state %d\n",\r\nsta->sta.addr, new_state);\r\nif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\r\nint err = drv_sta_state(sta->local, sta->sdata, sta,\r\nsta->sta_state, new_state);\r\nif (err)\r\nreturn err;\r\n}\r\nswitch (new_state) {\r\ncase IEEE80211_STA_NONE:\r\nif (sta->sta_state == IEEE80211_STA_AUTH)\r\nclear_bit(WLAN_STA_AUTH, &sta->_flags);\r\nbreak;\r\ncase IEEE80211_STA_AUTH:\r\nif (sta->sta_state == IEEE80211_STA_NONE)\r\nset_bit(WLAN_STA_AUTH, &sta->_flags);\r\nelse if (sta->sta_state == IEEE80211_STA_ASSOC)\r\nclear_bit(WLAN_STA_ASSOC, &sta->_flags);\r\nbreak;\r\ncase IEEE80211_STA_ASSOC:\r\nif (sta->sta_state == IEEE80211_STA_AUTH) {\r\nset_bit(WLAN_STA_ASSOC, &sta->_flags);\r\n} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\r\n(sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\r\n!sta->sdata->u.vlan.sta))\r\natomic_dec(&sta->sdata->bss->num_mcast_sta);\r\nclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\r\n}\r\nbreak;\r\ncase IEEE80211_STA_AUTHORIZED:\r\nif (sta->sta_state == IEEE80211_STA_ASSOC) {\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\r\n(sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\r\n!sta->sdata->u.vlan.sta))\r\natomic_inc(&sta->sdata->bss->num_mcast_sta);\r\nset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsta->sta_state = new_state;\r\nreturn 0;\r\n}
