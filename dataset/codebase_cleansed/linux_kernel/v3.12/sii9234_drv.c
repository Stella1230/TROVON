static inline struct sii9234_context *sd_to_context(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct sii9234_context, sd);\r\n}\r\nstatic inline int sii9234_readb(struct i2c_client *client, int addr)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, addr);\r\n}\r\nstatic inline int sii9234_writeb(struct i2c_client *client, int addr, int value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, addr, value);\r\n}\r\nstatic inline int sii9234_writeb_mask(struct i2c_client *client, int addr,\r\nint value, int mask)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = (ret & ~mask) | (value & mask);\r\nreturn i2c_smbus_write_byte_data(client, addr, ret);\r\n}\r\nstatic inline int sii9234_readb_idx(struct i2c_client *client, int addr)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, 0xbc, addr >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, 0xbd, addr & 0xff);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i2c_smbus_read_byte_data(client, 0xbe);\r\n}\r\nstatic inline int sii9234_writeb_idx(struct i2c_client *client, int addr,\r\nint value)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, 0xbc, addr >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, 0xbd, addr & 0xff);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, 0xbe, value);\r\nreturn ret;\r\n}\r\nstatic inline int sii9234_writeb_idx_mask(struct i2c_client *client, int addr,\r\nint value, int mask)\r\n{\r\nint ret;\r\nret = sii9234_readb_idx(client, addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = (ret & ~mask) | (value & mask);\r\nreturn sii9234_writeb_idx(client, addr, ret);\r\n}\r\nstatic int sii9234_reset(struct sii9234_context *ctx)\r\n{\r\nstruct i2c_client *client = ctx->client;\r\nstruct device *dev = &client->dev;\r\nint ret, tries;\r\ngpio_direction_output(ctx->gpio_n_reset, 1);\r\nmdelay(1);\r\ngpio_direction_output(ctx->gpio_n_reset, 0);\r\nmdelay(1);\r\ngpio_direction_output(ctx->gpio_n_reset, 1);\r\nmdelay(1);\r\nret = sii9234_writeb(client, 0xc7, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to set TTPI mode\n");\r\nreturn ret;\r\n}\r\nfor (tries = 0; tries < 100 ; ++tries) {\r\nret = sii9234_readb(client, 0x1b);\r\nif (ret > 0)\r\nbreak;\r\nif (ret < 0) {\r\ndev_err(dev, "failed to reset device\n");\r\nreturn -EIO;\r\n}\r\nmdelay(1);\r\n}\r\nif (tries == 100) {\r\ndev_err(dev, "maximal number of tries reached\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sii9234_verify_version(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nint family, rev, tpi_rev, dev_id, sub_id, hdcp, id;\r\nfamily = sii9234_readb(client, 0x1b);\r\nrev = sii9234_readb(client, 0x1c) & 0x0f;\r\ntpi_rev = sii9234_readb(client, 0x1d) & 0x7f;\r\ndev_id = sii9234_readb_idx(client, 0x0103);\r\nsub_id = sii9234_readb_idx(client, 0x0102);\r\nhdcp = sii9234_readb(client, 0x30);\r\nif (family < 0 || rev < 0 || tpi_rev < 0 || dev_id < 0 ||\r\nsub_id < 0 || hdcp < 0) {\r\ndev_err(dev, "failed to read chip's version\n");\r\nreturn -EIO;\r\n}\r\nid = (dev_id << 8) | sub_id;\r\ndev_info(dev, "chip: SiL%02x family: %02x, rev: %02x\n",\r\nid, family, rev);\r\ndev_info(dev, "tpi_rev:%02x, hdcp: %02x\n", tpi_rev, hdcp);\r\nif (id != 0x9234) {\r\ndev_err(dev, "not supported chip\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sii9234_set_internal(struct sii9234_context *ctx)\r\n{\r\nstruct i2c_client *client = ctx->client;\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(data); ++i) {\r\nint addr = (data[i][0] << 8) | data[i][1];\r\nret = sii9234_writeb_idx(client, addr, data[i][2]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sii9234_runtime_suspend(struct device *dev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct sii9234_context *ctx = sd_to_context(sd);\r\nstruct i2c_client *client = ctx->client;\r\ndev_info(dev, "suspend start\n");\r\nsii9234_writeb_mask(client, 0x1e, 3, 3);\r\nregulator_disable(ctx->power);\r\nreturn 0;\r\n}\r\nstatic int sii9234_runtime_resume(struct device *dev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct sii9234_context *ctx = sd_to_context(sd);\r\nstruct i2c_client *client = ctx->client;\r\nint ret;\r\ndev_info(dev, "resume start\n");\r\nret = regulator_enable(ctx->power);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sii9234_reset(ctx);\r\nif (ret)\r\ngoto fail;\r\nret = sii9234_writeb_mask(client, 0x1e, 1, 0);\r\nif (ret < 0)\r\ngoto fail;\r\nret = sii9234_set_internal(ctx);\r\nif (ret < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ndev_err(dev, "failed to resume\n");\r\nregulator_disable(ctx->power);\r\nreturn ret;\r\n}\r\nstatic int sii9234_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct sii9234_context *ctx = sd_to_context(sd);\r\nint ret;\r\nif (on)\r\nret = pm_runtime_get_sync(&ctx->client->dev);\r\nelse\r\nret = pm_runtime_put(&ctx->client->dev);\r\nreturn IS_ERR_VALUE(ret) ? ret : 0;\r\n}\r\nstatic int sii9234_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct sii9234_context *ctx = sd_to_context(sd);\r\nsii9234_writeb_mask(ctx->client, 0x1a, enable ? 0 : ~0 , 1 << 4);\r\nreturn 0;\r\n}\r\nstatic int sii9234_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct sii9234_platform_data *pdata = dev->platform_data;\r\nstruct sii9234_context *ctx;\r\nint ret;\r\nctx = devm_kzalloc(&client->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\ndev_err(dev, "out of memory\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nctx->client = client;\r\nctx->power = devm_regulator_get(dev, "hdmi-en");\r\nif (IS_ERR(ctx->power)) {\r\ndev_err(dev, "failed to acquire regulator hdmi-en\n");\r\nreturn PTR_ERR(ctx->power);\r\n}\r\nctx->gpio_n_reset = pdata->gpio_n_reset;\r\nret = devm_gpio_request(dev, ctx->gpio_n_reset, "MHL_RST");\r\nif (ret) {\r\ndev_err(dev, "failed to acquire MHL_RST gpio\n");\r\nreturn ret;\r\n}\r\nv4l2_i2c_subdev_init(&ctx->sd, client, &sii9234_ops);\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(dev);\r\nif (ret)\r\ngoto fail_pm;\r\nret = sii9234_verify_version(client);\r\nif (ret)\r\ngoto fail_pm_get;\r\npm_runtime_put(dev);\r\ndev_info(dev, "probe successful\n");\r\nreturn 0;\r\nfail_pm_get:\r\npm_runtime_put_sync(dev);\r\nfail_pm:\r\npm_runtime_disable(dev);\r\nfail:\r\ndev_err(dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int sii9234_remove(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\npm_runtime_disable(dev);\r\ndev_info(dev, "remove successful\n");\r\nreturn 0;\r\n}
