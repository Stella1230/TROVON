struct tick_device *tick_get_device(int cpu)\r\n{\r\nreturn &per_cpu(tick_cpu_device, cpu);\r\n}\r\nint tick_is_oneshot_available(void)\r\n{\r\nstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\r\nif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\r\nreturn 0;\r\nif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\r\nreturn 1;\r\nreturn tick_broadcast_oneshot_available();\r\n}\r\nstatic void tick_periodic(int cpu)\r\n{\r\nif (tick_do_timer_cpu == cpu) {\r\nwrite_seqlock(&jiffies_lock);\r\ntick_next_period = ktime_add(tick_next_period, tick_period);\r\ndo_timer(1);\r\nwrite_sequnlock(&jiffies_lock);\r\n}\r\nupdate_process_times(user_mode(get_irq_regs()));\r\nprofile_tick(CPU_PROFILING);\r\n}\r\nvoid tick_handle_periodic(struct clock_event_device *dev)\r\n{\r\nint cpu = smp_processor_id();\r\nktime_t next;\r\ntick_periodic(cpu);\r\nif (dev->mode != CLOCK_EVT_MODE_ONESHOT)\r\nreturn;\r\nnext = ktime_add(dev->next_event, tick_period);\r\nfor (;;) {\r\nif (!clockevents_program_event(dev, next, false))\r\nreturn;\r\nif (timekeeping_valid_for_hres())\r\ntick_periodic(cpu);\r\nnext = ktime_add(next, tick_period);\r\n}\r\n}\r\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\r\n{\r\ntick_set_periodic_handler(dev, broadcast);\r\nif (!tick_device_is_functional(dev))\r\nreturn;\r\nif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\r\n!tick_broadcast_oneshot_active()) {\r\nclockevents_set_mode(dev, CLOCK_EVT_MODE_PERIODIC);\r\n} else {\r\nunsigned long seq;\r\nktime_t next;\r\ndo {\r\nseq = read_seqbegin(&jiffies_lock);\r\nnext = tick_next_period;\r\n} while (read_seqretry(&jiffies_lock, seq));\r\nclockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);\r\nfor (;;) {\r\nif (!clockevents_program_event(dev, next, false))\r\nreturn;\r\nnext = ktime_add(next, tick_period);\r\n}\r\n}\r\n}\r\nstatic void tick_setup_device(struct tick_device *td,\r\nstruct clock_event_device *newdev, int cpu,\r\nconst struct cpumask *cpumask)\r\n{\r\nktime_t next_event;\r\nvoid (*handler)(struct clock_event_device *) = NULL;\r\nif (!td->evtdev) {\r\nif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\r\nif (!tick_nohz_full_cpu(cpu))\r\ntick_do_timer_cpu = cpu;\r\nelse\r\ntick_do_timer_cpu = TICK_DO_TIMER_NONE;\r\ntick_next_period = ktime_get();\r\ntick_period = ktime_set(0, NSEC_PER_SEC / HZ);\r\n}\r\ntd->mode = TICKDEV_MODE_PERIODIC;\r\n} else {\r\nhandler = td->evtdev->event_handler;\r\nnext_event = td->evtdev->next_event;\r\ntd->evtdev->event_handler = clockevents_handle_noop;\r\n}\r\ntd->evtdev = newdev;\r\nif (!cpumask_equal(newdev->cpumask, cpumask))\r\nirq_set_affinity(newdev->irq, cpumask);\r\nif (tick_device_uses_broadcast(newdev, cpu))\r\nreturn;\r\nif (td->mode == TICKDEV_MODE_PERIODIC)\r\ntick_setup_periodic(newdev, 0);\r\nelse\r\ntick_setup_oneshot(newdev, handler, next_event);\r\n}\r\nvoid tick_install_replacement(struct clock_event_device *newdev)\r\n{\r\nstruct tick_device *td = &__get_cpu_var(tick_cpu_device);\r\nint cpu = smp_processor_id();\r\nclockevents_exchange_device(td->evtdev, newdev);\r\ntick_setup_device(td, newdev, cpu, cpumask_of(cpu));\r\nif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\r\ntick_oneshot_notify();\r\n}\r\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\r\nstruct clock_event_device *newdev, int cpu)\r\n{\r\nif (!cpumask_test_cpu(cpu, newdev->cpumask))\r\nreturn false;\r\nif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\r\nreturn true;\r\nif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\r\nreturn false;\r\nif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\r\nstruct clock_event_device *newdev)\r\n{\r\nif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\r\nif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\r\nreturn false;\r\nif (tick_oneshot_mode_active())\r\nreturn false;\r\n}\r\nreturn !curdev ||\r\nnewdev->rating > curdev->rating ||\r\n!cpumask_equal(curdev->cpumask, newdev->cpumask);\r\n}\r\nbool tick_check_replacement(struct clock_event_device *curdev,\r\nstruct clock_event_device *newdev)\r\n{\r\nif (tick_check_percpu(curdev, newdev, smp_processor_id()))\r\nreturn false;\r\nreturn tick_check_preferred(curdev, newdev);\r\n}\r\nvoid tick_check_new_device(struct clock_event_device *newdev)\r\n{\r\nstruct clock_event_device *curdev;\r\nstruct tick_device *td;\r\nint cpu;\r\ncpu = smp_processor_id();\r\nif (!cpumask_test_cpu(cpu, newdev->cpumask))\r\ngoto out_bc;\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\ncurdev = td->evtdev;\r\nif (!tick_check_percpu(curdev, newdev, cpu))\r\ngoto out_bc;\r\nif (!tick_check_preferred(curdev, newdev))\r\ngoto out_bc;\r\nif (!try_module_get(newdev->owner))\r\nreturn;\r\nif (tick_is_broadcast_device(curdev)) {\r\nclockevents_shutdown(curdev);\r\ncurdev = NULL;\r\n}\r\nclockevents_exchange_device(curdev, newdev);\r\ntick_setup_device(td, newdev, cpu, cpumask_of(cpu));\r\nif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\r\ntick_oneshot_notify();\r\nreturn;\r\nout_bc:\r\ntick_install_broadcast_device(newdev);\r\n}\r\nvoid tick_handover_do_timer(int *cpup)\r\n{\r\nif (*cpup == tick_do_timer_cpu) {\r\nint cpu = cpumask_first(cpu_online_mask);\r\ntick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\r\nTICK_DO_TIMER_NONE;\r\n}\r\n}\r\nvoid tick_shutdown(unsigned int *cpup)\r\n{\r\nstruct tick_device *td = &per_cpu(tick_cpu_device, *cpup);\r\nstruct clock_event_device *dev = td->evtdev;\r\ntd->mode = TICKDEV_MODE_PERIODIC;\r\nif (dev) {\r\ndev->mode = CLOCK_EVT_MODE_UNUSED;\r\nclockevents_exchange_device(dev, NULL);\r\ndev->event_handler = clockevents_handle_noop;\r\ntd->evtdev = NULL;\r\n}\r\n}\r\nvoid tick_suspend(void)\r\n{\r\nstruct tick_device *td = &__get_cpu_var(tick_cpu_device);\r\nclockevents_shutdown(td->evtdev);\r\n}\r\nvoid tick_resume(void)\r\n{\r\nstruct tick_device *td = &__get_cpu_var(tick_cpu_device);\r\nint broadcast = tick_resume_broadcast();\r\nclockevents_set_mode(td->evtdev, CLOCK_EVT_MODE_RESUME);\r\nif (!broadcast) {\r\nif (td->mode == TICKDEV_MODE_PERIODIC)\r\ntick_setup_periodic(td->evtdev, 0);\r\nelse\r\ntick_resume_oneshot();\r\n}\r\n}\r\nvoid __init tick_init(void)\r\n{\r\ntick_broadcast_init();\r\n}
