static int ds3000_writereg(struct ds3000_state *state, int reg, int data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nint err;\r\ndprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);\r\nerr = i2c_transfer(state->i2c, &msg, 1);\r\nif (err != 1) {\r\nprintk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"\r\n" value == 0x%02x)\n", __func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3000_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nif (enable)\r\nds3000_writereg(state, 0x03, 0x12);\r\nelse\r\nds3000_writereg(state, 0x03, 0x02);\r\nreturn 0;\r\n}\r\nstatic int ds3000_writeFW(struct ds3000_state *state, int reg,\r\nconst u8 *data, u16 len)\r\n{\r\nint i, ret = 0;\r\nstruct i2c_msg msg;\r\nu8 *buf;\r\nbuf = kmalloc(33, GFP_KERNEL);\r\nif (buf == NULL) {\r\nprintk(KERN_ERR "Unable to kmalloc\n");\r\nreturn -ENOMEM;\r\n}\r\n*(buf) = reg;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.buf = buf;\r\nmsg.len = 33;\r\nfor (i = 0; i < len; i += 32) {\r\nmemcpy(buf + 1, data + i, 32);\r\ndprintk("%s: write reg 0x%02x, len = %d\n", __func__, reg, len);\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\nprintk(KERN_ERR "%s: write error(err == %i, "\r\n"reg == 0x%02x\n", __func__, ret, reg);\r\nret = -EREMOTEIO;\r\ngoto error;\r\n}\r\n}\r\nret = 0;\r\nerror:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int ds3000_readreg(struct ds3000_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n}, {\r\n.addr = state->config->demod_address,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);\r\nreturn ret;\r\n}\r\ndprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);\r\nreturn b1[0];\r\n}\r\nstatic int ds3000_firmware_ondemand(struct dvb_frontend *fe)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nconst struct firmware *fw;\r\nint ret = 0;\r\ndprintk("%s()\n", __func__);\r\nret = ds3000_readreg(state, 0xb2);\r\nif (ret < 0)\r\nreturn ret;\r\nprintk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,\r\nDS3000_DEFAULT_FIRMWARE);\r\nret = request_firmware(&fw, DS3000_DEFAULT_FIRMWARE,\r\nstate->i2c->dev.parent);\r\nprintk(KERN_INFO "%s: Waiting for firmware upload(2)...\n", __func__);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: No firmware uploaded (timeout or file not "\r\n"found?)\n", __func__);\r\nreturn ret;\r\n}\r\nret = ds3000_load_firmware(fe, fw);\r\nif (ret)\r\nprintk("%s: Writing firmware to device failed\n", __func__);\r\nrelease_firmware(fw);\r\ndprintk("%s: Firmware upload %s\n", __func__,\r\nret == 0 ? "complete" : "failed");\r\nreturn ret;\r\n}\r\nstatic int ds3000_load_firmware(struct dvb_frontend *fe,\r\nconst struct firmware *fw)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\ndprintk("%s\n", __func__);\r\ndprintk("Firmware is %zu bytes (%02x %02x .. %02x %02x)\n",\r\nfw->size,\r\nfw->data[0],\r\nfw->data[1],\r\nfw->data[fw->size - 2],\r\nfw->data[fw->size - 1]);\r\nds3000_writereg(state, 0xb2, 0x01);\r\nret = ds3000_writeFW(state, 0xb0, fw->data, fw->size);\r\nds3000_writereg(state, 0xb2, 0x00);\r\nreturn ret;\r\n}\r\nstatic int ds3000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nu8 data;\r\ndprintk("%s(%d)\n", __func__, voltage);\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata |= 0x03;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_18:\r\ndata &= ~0x03;\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\ndata &= ~0x03;\r\ndata |= 0x01;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nbreak;\r\n}\r\nds3000_writereg(state, 0xa2, data);\r\nreturn 0;\r\n}\r\nstatic int ds3000_read_status(struct dvb_frontend *fe, fe_status_t* status)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint lock;\r\n*status = 0;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nlock = ds3000_readreg(state, 0xd1);\r\nif ((lock & 0x07) == 0x07)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nbreak;\r\ncase SYS_DVBS2:\r\nlock = ds3000_readreg(state, 0x0d);\r\nif ((lock & 0x8f) == 0x8f)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, *status == 0 ? 0 : 1);\r\ndprintk("%s: status = 0x%02x\n", __func__, lock);\r\nreturn 0;\r\n}\r\nstatic int ds3000_read_ber(struct dvb_frontend *fe, u32* ber)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 data;\r\nu32 ber_reading, lpdc_frames;\r\ndprintk("%s()\n", __func__);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nds3000_writereg(state, 0xf9, 0x04);\r\ndata = ds3000_readreg(state, 0xf8);\r\nif ((data & 0x10) == 0) {\r\n*ber = (ds3000_readreg(state, 0xf7) << 8) |\r\nds3000_readreg(state, 0xf6);\r\ndata |= 0x10;\r\nds3000_writereg(state, 0xf8, data);\r\nds3000_writereg(state, 0xf8, data);\r\n} else\r\n*ber = 0xffffffff;\r\nbreak;\r\ncase SYS_DVBS2:\r\nlpdc_frames = (ds3000_readreg(state, 0xd7) << 16) |\r\n(ds3000_readreg(state, 0xd6) << 8) |\r\nds3000_readreg(state, 0xd5);\r\nber_reading = (ds3000_readreg(state, 0xf8) << 8) |\r\nds3000_readreg(state, 0xf7);\r\nif (lpdc_frames > 750) {\r\nds3000_writereg(state, 0xd1, 0x01);\r\nds3000_writereg(state, 0xf9, 0x01);\r\nds3000_writereg(state, 0xf9, 0x00);\r\nds3000_writereg(state, 0xd1, 0x00);\r\n*ber = ber_reading;\r\n} else\r\n*ber = 0xffffffff;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3000_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nif (fe->ops.tuner_ops.get_rf_strength)\r\nfe->ops.tuner_ops.get_rf_strength(fe, signal_strength);\r\nreturn 0;\r\n}\r\nstatic int ds3000_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 snr_reading, snr_value;\r\nu32 dvbs2_signal_reading, dvbs2_noise_reading, tmp;\r\nstatic const u16 dvbs_snr_tab[] = {\r\n0x0000, 0x1b13, 0x2aea, 0x3627, 0x3ede, 0x45fe, 0x4c03,\r\n0x513a, 0x55d4, 0x59f2, 0x5dab, 0x6111, 0x6431, 0x6717,\r\n0x69c9, 0x6c4e, 0x6eac, 0x70e8, 0x7304, 0x7505\r\n};\r\nstatic const u16 dvbs2_snr_tab[] = {\r\n0x0000, 0x0bc2, 0x12a3, 0x1785, 0x1b4e, 0x1e65, 0x2103,\r\n0x2347, 0x2546, 0x2710, 0x28ae, 0x2a28, 0x2b83, 0x2cc5,\r\n0x2df1, 0x2f09, 0x3010, 0x3109, 0x31f4, 0x32d2, 0x33a6,\r\n0x3470, 0x3531, 0x35ea, 0x369b, 0x3746, 0x37ea, 0x3888,\r\n0x3920, 0x39b3, 0x3a42, 0x3acc, 0x3b51, 0x3bd3, 0x3c51,\r\n0x3ccb, 0x3d42, 0x3db6, 0x3e27, 0x3e95, 0x3f00, 0x3f68,\r\n0x3fcf, 0x4033, 0x4094, 0x40f4, 0x4151, 0x41ac, 0x4206,\r\n0x425e, 0x42b4, 0x4308, 0x435b, 0x43ac, 0x43fc, 0x444a,\r\n0x4497, 0x44e2, 0x452d, 0x4576, 0x45bd, 0x4604, 0x4649,\r\n0x468e, 0x46d1, 0x4713, 0x4755, 0x4795, 0x47d4, 0x4813,\r\n0x4851, 0x488d, 0x48c9, 0x4904, 0x493f, 0x4978, 0x49b1,\r\n0x49e9, 0x4a20, 0x4a57\r\n};\r\ndprintk("%s()\n", __func__);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nsnr_reading = ds3000_readreg(state, 0xff);\r\nsnr_reading /= 8;\r\nif (snr_reading == 0)\r\n*snr = 0x0000;\r\nelse {\r\nif (snr_reading > 20)\r\nsnr_reading = 20;\r\nsnr_value = dvbs_snr_tab[snr_reading - 1] * 10 / 23026;\r\n*snr = snr_value * 8 * 655;\r\n}\r\ndprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,\r\nsnr_reading, *snr);\r\nbreak;\r\ncase SYS_DVBS2:\r\ndvbs2_noise_reading = (ds3000_readreg(state, 0x8c) & 0x3f) +\r\n(ds3000_readreg(state, 0x8d) << 4);\r\ndvbs2_signal_reading = ds3000_readreg(state, 0x8e);\r\ntmp = dvbs2_signal_reading * dvbs2_signal_reading >> 1;\r\nif (tmp == 0) {\r\n*snr = 0x0000;\r\nreturn 0;\r\n}\r\nif (dvbs2_noise_reading == 0) {\r\nsnr_value = 0x0013;\r\n*snr = 0xffff;\r\nreturn 0;\r\n}\r\nif (tmp > dvbs2_noise_reading) {\r\nsnr_reading = tmp / dvbs2_noise_reading;\r\nif (snr_reading > 80)\r\nsnr_reading = 80;\r\nsnr_value = dvbs2_snr_tab[snr_reading - 1] / 1000;\r\n*snr = snr_value * 5 * 655;\r\n} else {\r\nsnr_reading = dvbs2_noise_reading / tmp;\r\nif (snr_reading > 80)\r\nsnr_reading = 80;\r\n*snr = -(dvbs2_snr_tab[snr_reading] / 1000);\r\n}\r\ndprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,\r\nsnr_reading, *snr);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3000_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 data;\r\nu16 _ucblocks;\r\ndprintk("%s()\n", __func__);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\n*ucblocks = (ds3000_readreg(state, 0xf5) << 8) |\r\nds3000_readreg(state, 0xf4);\r\ndata = ds3000_readreg(state, 0xf8);\r\ndata &= ~0x20;\r\nds3000_writereg(state, 0xf8, data);\r\ndata |= 0x20;\r\nds3000_writereg(state, 0xf8, data);\r\nbreak;\r\ncase SYS_DVBS2:\r\n_ucblocks = (ds3000_readreg(state, 0xe2) << 8) |\r\nds3000_readreg(state, 0xe1);\r\nif (_ucblocks > state->prevUCBS2)\r\n*ucblocks = _ucblocks - state->prevUCBS2;\r\nelse\r\n*ucblocks = state->prevUCBS2 - _ucblocks;\r\nstate->prevUCBS2 = _ucblocks;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3000_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nu8 data;\r\ndprintk("%s(%d)\n", __func__, tone);\r\nif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\r\nprintk(KERN_ERR "%s: Invalid, tone=%d\n", __func__, tone);\r\nreturn -EINVAL;\r\n}\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\nds3000_writereg(state, 0xa2, data);\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\ndprintk("%s: setting tone on\n", __func__);\r\ndata = ds3000_readreg(state, 0xa1);\r\ndata &= ~0x43;\r\ndata |= 0x04;\r\nds3000_writereg(state, 0xa1, data);\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ndprintk("%s: setting tone off\n", __func__);\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata |= 0x80;\r\nds3000_writereg(state, 0xa2, data);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3000_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *d)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 data;\r\ndprintk("%s(", __func__);\r\nfor (i = 0 ; i < d->msg_len;) {\r\ndprintk("0x%02x", d->msg[i]);\r\nif (++i < d->msg_len)\r\ndprintk(", ");\r\n}\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\nds3000_writereg(state, 0xa2, data);\r\nfor (i = 0; i < d->msg_len; i++)\r\nds3000_writereg(state, 0xa3 + i, d->msg[i]);\r\ndata = ds3000_readreg(state, 0xa1);\r\ndata &= ~0xf8;\r\ndata |= ((d->msg_len - 1) << 3) | 0x07;\r\nds3000_writereg(state, 0xa1, data);\r\nfor (i = 0; i < 15; i++) {\r\ndata = ds3000_readreg(state, 0xa1);\r\nif ((data & 0x40) == 0)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (i == 15) {\r\ndata = ds3000_readreg(state, 0xa1);\r\ndata &= ~0x80;\r\ndata |= 0x40;\r\nds3000_writereg(state, 0xa1, data);\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\ndata |= 0x80;\r\nds3000_writereg(state, 0xa2, data);\r\nreturn 1;\r\n}\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\ndata |= 0x80;\r\nds3000_writereg(state, 0xa2, data);\r\nreturn 0;\r\n}\r\nstatic int ds3000_diseqc_send_burst(struct dvb_frontend *fe,\r\nfe_sec_mini_cmd_t burst)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 data;\r\ndprintk("%s()\n", __func__);\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\nds3000_writereg(state, 0xa2, data);\r\nif (burst == SEC_MINI_A)\r\nds3000_writereg(state, 0xa1, 0x02);\r\nelse if (burst == SEC_MINI_B)\r\nds3000_writereg(state, 0xa1, 0x01);\r\nelse\r\nreturn -EINVAL;\r\nmsleep(13);\r\nfor (i = 0; i < 5; i++) {\r\ndata = ds3000_readreg(state, 0xa1);\r\nif ((data & 0x40) == 0)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (i == 5) {\r\ndata = ds3000_readreg(state, 0xa1);\r\ndata &= ~0x80;\r\ndata |= 0x40;\r\nds3000_writereg(state, 0xa1, data);\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\ndata |= 0x80;\r\nds3000_writereg(state, 0xa2, data);\r\nreturn 1;\r\n}\r\ndata = ds3000_readreg(state, 0xa2);\r\ndata &= ~0xc0;\r\ndata |= 0x80;\r\nds3000_writereg(state, 0xa2, data);\r\nreturn 0;\r\n}\r\nstatic void ds3000_release(struct dvb_frontend *fe)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, 0);\r\ndprintk("%s\n", __func__);\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *ds3000_attach(const struct ds3000_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct ds3000_state *state = NULL;\r\nint ret;\r\ndprintk("%s\n", __func__);\r\nstate = kzalloc(sizeof(struct ds3000_state), GFP_KERNEL);\r\nif (state == NULL) {\r\nprintk(KERN_ERR "Unable to kmalloc\n");\r\ngoto error2;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->prevUCBS2 = 0;\r\nret = ds3000_readreg(state, 0x00) & 0xfe;\r\nif (ret != 0xe0) {\r\nprintk(KERN_ERR "Invalid probe, probably not a DS3000\n");\r\ngoto error3;\r\n}\r\nprintk(KERN_INFO "DS3000 chip version: %d.%d attached.\n",\r\nds3000_readreg(state, 0x02),\r\nds3000_readreg(state, 0x01));\r\nmemcpy(&state->frontend.ops, &ds3000_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror3:\r\nkfree(state);\r\nerror2:\r\nreturn NULL;\r\n}\r\nstatic int ds3000_set_carrier_offset(struct dvb_frontend *fe,\r\ns32 carrier_offset_khz)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\ns32 tmp;\r\ntmp = carrier_offset_khz;\r\ntmp *= 65536;\r\ntmp = (2 * tmp + DS3000_SAMPLE_RATE) / (2 * DS3000_SAMPLE_RATE);\r\nif (tmp < 0)\r\ntmp += 65536;\r\nds3000_writereg(state, 0x5f, tmp >> 8);\r\nds3000_writereg(state, 0x5e, tmp & 0xff);\r\nreturn 0;\r\n}\r\nstatic int ds3000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint i;\r\nfe_status_t status;\r\ns32 offset_khz;\r\nu32 frequency;\r\nu16 value;\r\ndprintk("%s() ", __func__);\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nds3000_writereg(state, 0x07, 0x80);\r\nds3000_writereg(state, 0x07, 0x00);\r\nds3000_writereg(state, 0xb2, 0x01);\r\nds3000_writereg(state, 0x00, 0x01);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nfor (i = 0; i < sizeof(ds3000_dvbs_init_tab); i += 2)\r\nds3000_writereg(state,\r\nds3000_dvbs_init_tab[i],\r\nds3000_dvbs_init_tab[i + 1]);\r\nvalue = ds3000_readreg(state, 0xfe);\r\nvalue &= 0xc0;\r\nvalue |= 0x1b;\r\nds3000_writereg(state, 0xfe, value);\r\nbreak;\r\ncase SYS_DVBS2:\r\nfor (i = 0; i < sizeof(ds3000_dvbs2_init_tab); i += 2)\r\nds3000_writereg(state,\r\nds3000_dvbs2_init_tab[i],\r\nds3000_dvbs2_init_tab[i + 1]);\r\nif (c->symbol_rate >= 30000000)\r\nds3000_writereg(state, 0xfe, 0x54);\r\nelse\r\nds3000_writereg(state, 0xfe, 0x98);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nds3000_writereg(state, 0x29, 0x80);\r\nds3000_writereg(state, 0x25, 0x8a);\r\nif ((c->symbol_rate / 1000) <= 5000) {\r\nvalue = 29777 / (c->symbol_rate / 1000) + 1;\r\nif (value % 2 != 0)\r\nvalue++;\r\nds3000_writereg(state, 0xc3, 0x0d);\r\nds3000_writereg(state, 0xc8, value);\r\nds3000_writereg(state, 0xc4, 0x10);\r\nds3000_writereg(state, 0xc7, 0x0e);\r\n} else if ((c->symbol_rate / 1000) <= 10000) {\r\nvalue = 92166 / (c->symbol_rate / 1000) + 1;\r\nif (value % 2 != 0)\r\nvalue++;\r\nds3000_writereg(state, 0xc3, 0x07);\r\nds3000_writereg(state, 0xc8, value);\r\nds3000_writereg(state, 0xc4, 0x09);\r\nds3000_writereg(state, 0xc7, 0x12);\r\n} else if ((c->symbol_rate / 1000) <= 20000) {\r\nvalue = 64516 / (c->symbol_rate / 1000) + 1;\r\nds3000_writereg(state, 0xc3, value);\r\nds3000_writereg(state, 0xc8, 0x0e);\r\nds3000_writereg(state, 0xc4, 0x07);\r\nds3000_writereg(state, 0xc7, 0x18);\r\n} else {\r\nvalue = 129032 / (c->symbol_rate / 1000) + 1;\r\nds3000_writereg(state, 0xc3, value);\r\nds3000_writereg(state, 0xc8, 0x0a);\r\nds3000_writereg(state, 0xc4, 0x05);\r\nds3000_writereg(state, 0xc7, 0x24);\r\n}\r\nvalue = (((c->symbol_rate / 1000) << 16) +\r\n(DS3000_SAMPLE_RATE / 2)) / DS3000_SAMPLE_RATE;\r\nds3000_writereg(state, 0x61, value & 0x00ff);\r\nds3000_writereg(state, 0x62, (value & 0xff00) >> 8);\r\nds3000_writereg(state, 0x56, 0x00);\r\nds3000_writereg(state, 0x76, 0x00);\r\nif (state->config->ci_mode) {\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ndefault:\r\nds3000_writereg(state, 0xfd, 0x80);\r\nbreak;\r\ncase SYS_DVBS2:\r\nds3000_writereg(state, 0xfd, 0x01);\r\nbreak;\r\n}\r\n}\r\nds3000_writereg(state, 0x00, 0x00);\r\nds3000_writereg(state, 0xb2, 0x00);\r\nif (fe->ops.tuner_ops.get_frequency) {\r\nfe->ops.tuner_ops.get_frequency(fe, &frequency);\r\noffset_khz = frequency - c->frequency;\r\nds3000_set_carrier_offset(fe, offset_khz);\r\n}\r\nfor (i = 0; i < 30 ; i++) {\r\nds3000_read_status(fe, &status);\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\nmsleep(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3000_tune(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nif (re_tune) {\r\nint ret = ds3000_set_frontend(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\n*delay = HZ / 5;\r\nreturn ds3000_read_status(fe, status);\r\n}\r\nstatic enum dvbfe_algo ds3000_get_algo(struct dvb_frontend *fe)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, 0);\r\ndprintk("%s()\n", __func__);\r\nreturn DVBFE_ALGO_HW;\r\n}\r\nstatic int ds3000_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct ds3000_state *state = fe->demodulator_priv;\r\nint ret;\r\ndprintk("%s()\n", __func__);\r\nds3000_writereg(state, 0x08, 0x01 | ds3000_readreg(state, 0x08));\r\nmsleep(1);\r\nret = ds3000_firmware_ondemand(fe);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "%s: Unable initialize firmware\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
