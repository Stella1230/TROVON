static loff_t dev_nvram_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nint size;\r\nif (ppc_md.nvram_size == NULL)\r\nreturn -ENODEV;\r\nsize = ppc_md.nvram_size();\r\nswitch (origin) {\r\ncase 1:\r\noffset += file->f_pos;\r\nbreak;\r\ncase 2:\r\noffset += size;\r\nbreak;\r\n}\r\nif (offset < 0)\r\nreturn -EINVAL;\r\nfile->f_pos = offset;\r\nreturn file->f_pos;\r\n}\r\nstatic ssize_t dev_nvram_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nchar *tmp = NULL;\r\nssize_t size;\r\nif (!ppc_md.nvram_size) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsize = ppc_md.nvram_size();\r\nif (size < 0) {\r\nret = size;\r\ngoto out;\r\n}\r\nif (*ppos >= size) {\r\nret = 0;\r\ngoto out;\r\n}\r\ncount = min_t(size_t, count, size - *ppos);\r\ncount = min(count, PAGE_SIZE);\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = ppc_md.nvram_read(tmp, count, ppos);\r\nif (ret <= 0)\r\ngoto out;\r\nif (copy_to_user(buf, tmp, ret))\r\nret = -EFAULT;\r\nout:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic ssize_t dev_nvram_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nchar *tmp = NULL;\r\nssize_t size;\r\nret = -ENODEV;\r\nif (!ppc_md.nvram_size)\r\ngoto out;\r\nret = 0;\r\nsize = ppc_md.nvram_size();\r\nif (*ppos >= size || size < 0)\r\ngoto out;\r\ncount = min_t(size_t, count, size - *ppos);\r\ncount = min(count, PAGE_SIZE);\r\nret = -ENOMEM;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp)\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(tmp, buf, count))\r\ngoto out;\r\nret = ppc_md.nvram_write(tmp, count, ppos);\r\nout:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic long dev_nvram_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch(cmd) {\r\n#ifdef CONFIG_PPC_PMAC\r\ncase OBSOLETE_PMAC_NVRAM_GET_OFFSET:\r\nprintk(KERN_WARNING "nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\n");\r\ncase IOC_NVRAM_GET_OFFSET: {\r\nint part, offset;\r\nif (!machine_is(powermac))\r\nreturn -EINVAL;\r\nif (copy_from_user(&part, (void __user*)arg, sizeof(part)) != 0)\r\nreturn -EFAULT;\r\nif (part < pmac_nvram_OF || part > pmac_nvram_NR)\r\nreturn -EINVAL;\r\noffset = pmac_get_partition(part);\r\nif (offset < 0)\r\nreturn offset;\r\nif (copy_to_user((void __user*)arg, &offset, sizeof(offset)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void __init nvram_print_partitions(char * label)\r\n{\r\nstruct nvram_partition * tmp_part;\r\nprintk(KERN_WARNING "--------%s---------\n", label);\r\nprintk(KERN_WARNING "indx\t\tsig\tchks\tlen\tname\n");\r\nlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\r\nprintk(KERN_WARNING "%4d \t%02x\t%02x\t%d\t%12s\n",\r\ntmp_part->index, tmp_part->header.signature,\r\ntmp_part->header.checksum, tmp_part->header.length,\r\ntmp_part->header.name);\r\n}\r\n}\r\nstatic int __init nvram_write_header(struct nvram_partition * part)\r\n{\r\nloff_t tmp_index;\r\nint rc;\r\ntmp_index = part->index;\r\nrc = ppc_md.nvram_write((char *)&part->header, NVRAM_HEADER_LEN, &tmp_index);\r\nreturn rc;\r\n}\r\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\r\n{\r\nunsigned int c_sum, c_sum2;\r\nunsigned short *sp = (unsigned short *)p->name;\r\nc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\r\nc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\r\nc_sum2 = (c_sum >> 8) + (c_sum << 8);\r\nc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\r\nreturn c_sum;\r\n}\r\nstatic int nvram_can_remove_partition(struct nvram_partition *part,\r\nconst char *name, int sig, const char *exceptions[])\r\n{\r\nif (part->header.signature != sig)\r\nreturn 0;\r\nif (name) {\r\nif (strncmp(name, part->header.name, 12))\r\nreturn 0;\r\n} else if (exceptions) {\r\nconst char **except;\r\nfor (except = exceptions; *except; except++) {\r\nif (!strncmp(*except, part->header.name, 12))\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint __init nvram_remove_partition(const char *name, int sig,\r\nconst char *exceptions[])\r\n{\r\nstruct nvram_partition *part, *prev, *tmp;\r\nint rc;\r\nlist_for_each_entry(part, &nvram_partitions, partition) {\r\nif (!nvram_can_remove_partition(part, name, sig, exceptions))\r\ncontinue;\r\npart->header.signature = NVRAM_SIG_FREE;\r\nstrncpy(part->header.name, "wwwwwwwwwwww", 12);\r\npart->header.checksum = nvram_checksum(&part->header);\r\nrc = nvram_write_header(part);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_remove_partition: nvram_write failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nprev = NULL;\r\nlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\r\nif (part->header.signature != NVRAM_SIG_FREE) {\r\nprev = NULL;\r\ncontinue;\r\n}\r\nif (prev) {\r\nprev->header.length += part->header.length;\r\nprev->header.checksum = nvram_checksum(&part->header);\r\nrc = nvram_write_header(part);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_remove_partition: nvram_write failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nlist_del(&part->partition);\r\nkfree(part);\r\n} else\r\nprev = part;\r\n}\r\nreturn 0;\r\n}\r\nloff_t __init nvram_create_partition(const char *name, int sig,\r\nint req_size, int min_size)\r\n{\r\nstruct nvram_partition *part;\r\nstruct nvram_partition *new_part;\r\nstruct nvram_partition *free_part = NULL;\r\nstatic char nv_init_vals[16];\r\nloff_t tmp_index;\r\nlong size = 0;\r\nint rc;\r\nreq_size = _ALIGN_UP(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\r\nmin_size = _ALIGN_UP(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\r\nif (min_size == 0)\r\nmin_size = req_size;\r\nif (min_size > req_size)\r\nreturn -EINVAL;\r\nreq_size += 1;\r\nmin_size += 1;\r\nlist_for_each_entry(part, &nvram_partitions, partition) {\r\nif (part->header.signature != NVRAM_SIG_FREE)\r\ncontinue;\r\nif (part->header.length >= req_size) {\r\nsize = req_size;\r\nfree_part = part;\r\nbreak;\r\n}\r\nif (part->header.length > size &&\r\npart->header.length >= min_size) {\r\nsize = part->header.length;\r\nfree_part = part;\r\n}\r\n}\r\nif (!size)\r\nreturn -ENOSPC;\r\nnew_part = kmalloc(sizeof(*new_part), GFP_KERNEL);\r\nif (!new_part) {\r\npr_err("nvram_create_os_partition: kmalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nnew_part->index = free_part->index;\r\nnew_part->header.signature = sig;\r\nnew_part->header.length = size;\r\nstrncpy(new_part->header.name, name, 12);\r\nnew_part->header.checksum = nvram_checksum(&new_part->header);\r\nrc = nvram_write_header(new_part);\r\nif (rc <= 0) {\r\npr_err("nvram_create_os_partition: nvram_write_header "\r\n"failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nlist_add_tail(&new_part->partition, &free_part->partition);\r\nif (free_part->header.length > size) {\r\nfree_part->index += size * NVRAM_BLOCK_LEN;\r\nfree_part->header.length -= size;\r\nfree_part->header.checksum = nvram_checksum(&free_part->header);\r\nrc = nvram_write_header(free_part);\r\nif (rc <= 0) {\r\npr_err("nvram_create_os_partition: nvram_write_header "\r\n"failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\n} else {\r\nlist_del(&free_part->partition);\r\nkfree(free_part);\r\n}\r\nfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\r\ntmp_index < ((size - 1) * NVRAM_BLOCK_LEN);\r\ntmp_index += NVRAM_BLOCK_LEN) {\r\nrc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("nvram_create_partition: nvram_write failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nreturn new_part->index + NVRAM_HEADER_LEN;\r\n}\r\nint nvram_get_partition_size(loff_t data_index)\r\n{\r\nstruct nvram_partition *part;\r\nlist_for_each_entry(part, &nvram_partitions, partition) {\r\nif (part->index + NVRAM_HEADER_LEN == data_index)\r\nreturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\r\n}\r\nreturn -1;\r\n}\r\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\r\n{\r\nstruct nvram_partition *p;\r\nlist_for_each_entry(p, &nvram_partitions, partition) {\r\nif (p->header.signature == sig &&\r\n(!name || !strncmp(p->header.name, name, 12))) {\r\nif (out_size)\r\n*out_size = (p->header.length - 1) *\r\nNVRAM_BLOCK_LEN;\r\nreturn p->index + NVRAM_HEADER_LEN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __init nvram_scan_partitions(void)\r\n{\r\nloff_t cur_index = 0;\r\nstruct nvram_header phead;\r\nstruct nvram_partition * tmp_part;\r\nunsigned char c_sum;\r\nchar * header;\r\nint total_size;\r\nint err;\r\nif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\r\nreturn -ENODEV;\r\ntotal_size = ppc_md.nvram_size();\r\nheader = kmalloc(NVRAM_HEADER_LEN, GFP_KERNEL);\r\nif (!header) {\r\nprintk(KERN_ERR "nvram_scan_partitions: Failed kmalloc\n");\r\nreturn -ENOMEM;\r\n}\r\nwhile (cur_index < total_size) {\r\nerr = ppc_md.nvram_read(header, NVRAM_HEADER_LEN, &cur_index);\r\nif (err != NVRAM_HEADER_LEN) {\r\nprintk(KERN_ERR "nvram_scan_partitions: Error parsing "\r\n"nvram partitions\n");\r\ngoto out;\r\n}\r\ncur_index -= NVRAM_HEADER_LEN;\r\nmemcpy(&phead, header, NVRAM_HEADER_LEN);\r\nerr = 0;\r\nc_sum = nvram_checksum(&phead);\r\nif (c_sum != phead.checksum) {\r\nprintk(KERN_WARNING "WARNING: nvram partition checksum"\r\n" was %02x, should be %02x!\n",\r\nphead.checksum, c_sum);\r\nprintk(KERN_WARNING "Terminating nvram partition scan\n");\r\ngoto out;\r\n}\r\nif (!phead.length) {\r\nprintk(KERN_WARNING "WARNING: nvram corruption "\r\n"detected: 0-length partition\n");\r\ngoto out;\r\n}\r\ntmp_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!tmp_part) {\r\nprintk(KERN_ERR "nvram_scan_partitions: kmalloc failed\n");\r\ngoto out;\r\n}\r\nmemcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);\r\ntmp_part->index = cur_index;\r\nlist_add_tail(&tmp_part->partition, &nvram_partitions);\r\ncur_index += phead.length * NVRAM_BLOCK_LEN;\r\n}\r\nerr = 0;\r\n#ifdef DEBUG_NVRAM\r\nnvram_print_partitions("NVRAM Partitions");\r\n#endif\r\nout:\r\nkfree(header);\r\nreturn err;\r\n}\r\nstatic int __init nvram_init(void)\r\n{\r\nint rc;\r\nBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\r\nif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\r\nreturn -ENODEV;\r\nrc = misc_register(&nvram_dev);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "nvram_init: failed to register device\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nvoid __exit nvram_cleanup(void)\r\n{\r\nmisc_deregister( &nvram_dev );\r\n}
