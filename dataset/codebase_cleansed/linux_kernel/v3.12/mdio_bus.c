struct mii_bus *mdiobus_alloc_size(size_t size)\r\n{\r\nstruct mii_bus *bus;\r\nsize_t aligned_size = ALIGN(sizeof(*bus), NETDEV_ALIGN);\r\nsize_t alloc_size;\r\nif (size)\r\nalloc_size = aligned_size + size;\r\nelse\r\nalloc_size = sizeof(*bus);\r\nbus = kzalloc(alloc_size, GFP_KERNEL);\r\nif (bus) {\r\nbus->state = MDIOBUS_ALLOCATED;\r\nif (size)\r\nbus->priv = (void *)bus + aligned_size;\r\n}\r\nreturn bus;\r\n}\r\nstatic void mdiobus_release(struct device *d)\r\n{\r\nstruct mii_bus *bus = to_mii_bus(d);\r\nBUG_ON(bus->state != MDIOBUS_RELEASED &&\r\nbus->state != MDIOBUS_ALLOCATED);\r\nkfree(bus);\r\n}\r\nstatic int of_mdio_bus_match(struct device *dev, const void *mdio_bus_np)\r\n{\r\nreturn dev->of_node == mdio_bus_np;\r\n}\r\nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)\r\n{\r\nstruct device *d;\r\nif (!mdio_bus_np)\r\nreturn NULL;\r\nd = class_find_device(&mdio_bus_class, NULL, mdio_bus_np,\r\nof_mdio_bus_match);\r\nreturn d ? to_mii_bus(d) : NULL;\r\n}\r\nint mdiobus_register(struct mii_bus *bus)\r\n{\r\nint i, err;\r\nif (NULL == bus || NULL == bus->name ||\r\nNULL == bus->read ||\r\nNULL == bus->write)\r\nreturn -EINVAL;\r\nBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\r\nbus->state != MDIOBUS_UNREGISTERED);\r\nbus->dev.parent = bus->parent;\r\nbus->dev.class = &mdio_bus_class;\r\nbus->dev.groups = NULL;\r\ndev_set_name(&bus->dev, "%s", bus->id);\r\nerr = device_register(&bus->dev);\r\nif (err) {\r\npr_err("mii_bus %s failed to register\n", bus->id);\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&bus->mdio_lock);\r\nif (bus->reset)\r\nbus->reset(bus);\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\nif ((bus->phy_mask & (1 << i)) == 0) {\r\nstruct phy_device *phydev;\r\nphydev = mdiobus_scan(bus, i);\r\nif (IS_ERR(phydev)) {\r\nerr = PTR_ERR(phydev);\r\ngoto error;\r\n}\r\n}\r\n}\r\nbus->state = MDIOBUS_REGISTERED;\r\npr_info("%s: probed\n", bus->name);\r\nreturn 0;\r\nerror:\r\nwhile (--i >= 0) {\r\nif (bus->phy_map[i])\r\ndevice_unregister(&bus->phy_map[i]->dev);\r\n}\r\ndevice_del(&bus->dev);\r\nreturn err;\r\n}\r\nvoid mdiobus_unregister(struct mii_bus *bus)\r\n{\r\nint i;\r\nBUG_ON(bus->state != MDIOBUS_REGISTERED);\r\nbus->state = MDIOBUS_UNREGISTERED;\r\ndevice_del(&bus->dev);\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\nif (bus->phy_map[i])\r\ndevice_unregister(&bus->phy_map[i]->dev);\r\nbus->phy_map[i] = NULL;\r\n}\r\n}\r\nvoid mdiobus_free(struct mii_bus *bus)\r\n{\r\nif (bus->state == MDIOBUS_ALLOCATED) {\r\nkfree(bus);\r\nreturn;\r\n}\r\nBUG_ON(bus->state != MDIOBUS_UNREGISTERED);\r\nbus->state = MDIOBUS_RELEASED;\r\nput_device(&bus->dev);\r\n}\r\nstruct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)\r\n{\r\nstruct phy_device *phydev;\r\nint err;\r\nphydev = get_phy_device(bus, addr, false);\r\nif (IS_ERR(phydev) || phydev == NULL)\r\nreturn phydev;\r\nerr = phy_device_register(phydev);\r\nif (err) {\r\nphy_device_free(phydev);\r\nreturn NULL;\r\n}\r\nreturn phydev;\r\n}\r\nint mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\r\n{\r\nint retval;\r\nBUG_ON(in_interrupt());\r\nmutex_lock(&bus->mdio_lock);\r\nretval = bus->read(bus, addr, regnum);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn retval;\r\n}\r\nint mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\r\n{\r\nint err;\r\nBUG_ON(in_interrupt());\r\nmutex_lock(&bus->mdio_lock);\r\nerr = bus->write(bus, addr, regnum, val);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn err;\r\n}\r\nstatic int mdio_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nstruct phy_driver *phydrv = to_phy_driver(drv);\r\nif (of_driver_match_device(dev, drv))\r\nreturn 1;\r\nif (phydrv->match_phy_device)\r\nreturn phydrv->match_phy_device(phydev);\r\nreturn ((phydrv->phy_id & phydrv->phy_id_mask) ==\r\n(phydev->phy_id & phydrv->phy_id_mask));\r\n}\r\nstatic bool mdio_bus_phy_may_suspend(struct phy_device *phydev)\r\n{\r\nstruct device_driver *drv = phydev->dev.driver;\r\nstruct phy_driver *phydrv = to_phy_driver(drv);\r\nstruct net_device *netdev = phydev->attached_dev;\r\nif (!drv || !phydrv->suspend)\r\nreturn false;\r\nif (!netdev)\r\nreturn true;\r\nif (netdev->dev.parent && device_may_wakeup(netdev->dev.parent))\r\nreturn false;\r\nif (device_may_wakeup(&netdev->dev))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int mdio_bus_suspend(struct device *dev)\r\n{\r\nstruct phy_driver *phydrv = to_phy_driver(dev->driver);\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nif (phydev->attached_dev && phydev->adjust_link)\r\nphy_stop_machine(phydev);\r\nif (!mdio_bus_phy_may_suspend(phydev))\r\nreturn 0;\r\nreturn phydrv->suspend(phydev);\r\n}\r\nstatic int mdio_bus_resume(struct device *dev)\r\n{\r\nstruct phy_driver *phydrv = to_phy_driver(dev->driver);\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nint ret;\r\nif (!mdio_bus_phy_may_suspend(phydev))\r\ngoto no_resume;\r\nret = phydrv->resume(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nno_resume:\r\nif (phydev->attached_dev && phydev->adjust_link)\r\nphy_start_machine(phydev, NULL);\r\nreturn 0;\r\n}\r\nstatic int mdio_bus_restore(struct device *dev)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nstruct net_device *netdev = phydev->attached_dev;\r\nint ret;\r\nif (!netdev)\r\nreturn 0;\r\nret = phy_init_hw(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nphydev->link = 0;\r\nphydev->state = PHY_UP;\r\nphy_start_machine(phydev, NULL);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nphy_id_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct phy_device *phydev = to_phy_device(dev);\r\nreturn sprintf(buf, "0x%.8lx\n", (unsigned long)phydev->phy_id);\r\n}\r\nint __init mdio_bus_init(void)\r\n{\r\nint ret;\r\nret = class_register(&mdio_bus_class);\r\nif (!ret) {\r\nret = bus_register(&mdio_bus_type);\r\nif (ret)\r\nclass_unregister(&mdio_bus_class);\r\n}\r\nreturn ret;\r\n}\r\nvoid mdio_bus_exit(void)\r\n{\r\nclass_unregister(&mdio_bus_class);\r\nbus_unregister(&mdio_bus_type);\r\n}
