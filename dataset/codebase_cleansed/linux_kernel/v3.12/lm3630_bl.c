static int lm3630_chip_init(struct lm3630_chip_data *pchip)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3630_platform_data *pdata = pchip->pdata;\r\nreg_val = ((pdata->pwm_active & 0x01) << 2) | (pdata->pwm_ctrl & 0x03);\r\nret = regmap_update_bits(pchip->regmap, REG_CONFIG, 0x07, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nreg_val = ((pdata->bank_b_ctrl & 0x01) << 1) |\r\n(pdata->bank_a_ctrl & 0x07);\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x07, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nif (pdata->bank_a_ctrl != BANK_A_CTRL_DISABLE) {\r\nret = regmap_write(pchip->regmap,\r\nREG_BRT_A, pdata->init_brt_led1);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (pdata->bank_b_ctrl != BANK_B_CTRL_DISABLE) {\r\nret = regmap_write(pchip->regmap,\r\nREG_BRT_B, pdata->init_brt_led2);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nreturn ret;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn ret;\r\n}\r\nstatic void lm3630_delayed_func(struct work_struct *work)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3630_chip_data *pchip;\r\npchip = container_of(work, struct lm3630_chip_data, work.work);\r\nret = regmap_read(pchip->regmap, REG_INT_STATUS, &reg_val);\r\nif (ret < 0) {\r\ndev_err(pchip->dev,\r\n"i2c failed to access REG_INT_STATUS Register\n");\r\nreturn;\r\n}\r\ndev_info(pchip->dev, "REG_INT_STATUS Register is 0x%x\n", reg_val);\r\n}\r\nstatic irqreturn_t lm3630_isr_func(int irq, void *chip)\r\n{\r\nint ret;\r\nstruct lm3630_chip_data *pchip = chip;\r\nunsigned long delay = msecs_to_jiffies(INT_DEBOUNCE_MSEC);\r\nqueue_delayed_work(pchip->irqthread, &pchip->work, delay);\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nreturn IRQ_HANDLED;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lm3630_intr_config(struct lm3630_chip_data *pchip)\r\n{\r\nINIT_DELAYED_WORK(&pchip->work, lm3630_delayed_func);\r\npchip->irqthread = create_singlethread_workqueue("lm3630-irqthd");\r\nif (!pchip->irqthread) {\r\ndev_err(pchip->dev, "create irq thread fail...\n");\r\nreturn -1;\r\n}\r\nif (request_threaded_irq\r\n(pchip->irq, NULL, lm3630_isr_func,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT, "lm3630_irq", pchip)) {\r\ndev_err(pchip->dev, "request threaded irq fail..\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\nset_intensity(struct backlight_device *bl, struct lm3630_chip_data *pchip)\r\n{\r\nif (!pchip->pdata->pwm_set_intensity)\r\nreturn false;\r\npchip->pdata->pwm_set_intensity(bl->props.brightness - 1,\r\npchip->pdata->pwm_period);\r\nreturn true;\r\n}\r\nstatic int lm3630_bank_a_update_status(struct backlight_device *bl)\r\n{\r\nint ret;\r\nstruct lm3630_chip_data *pchip = bl_get_data(bl);\r\nenum lm3630_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif (!bl->props.brightness) {\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x04, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nreturn bl->props.brightness;\r\n}\r\nif (pwm_ctrl == PWM_CTRL_BANK_A || pwm_ctrl == PWM_CTRL_BANK_ALL) {\r\nif (!set_intensity(bl, pchip))\r\ndev_err(pchip->dev, "No pwm control func. in plat-data\n");\r\n} else {\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nmdelay(1);\r\nret = regmap_write(pchip->regmap,\r\nREG_BRT_A, bl->props.brightness - 1);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nreturn bl->props.brightness;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access REG_CTRL\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lm3630_bank_a_get_brightness(struct backlight_device *bl)\r\n{\r\nunsigned int reg_val;\r\nint brightness, ret;\r\nstruct lm3630_chip_data *pchip = bl_get_data(bl);\r\nenum lm3630_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif (pwm_ctrl == PWM_CTRL_BANK_A || pwm_ctrl == PWM_CTRL_BANK_ALL) {\r\nret = regmap_read(pchip->regmap, REG_PWM_OUTHIGH, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbrightness = reg_val & 0x01;\r\nret = regmap_read(pchip->regmap, REG_PWM_OUTLOW, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbrightness = ((brightness << 8) | reg_val) + 1;\r\n} else {\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nmdelay(1);\r\nret = regmap_read(pchip->regmap, REG_BRT_A, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbrightness = reg_val + 1;\r\n}\r\nbl->props.brightness = brightness;\r\nreturn bl->props.brightness;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn 0;\r\n}\r\nstatic int lm3630_bank_b_update_status(struct backlight_device *bl)\r\n{\r\nint ret;\r\nstruct lm3630_chip_data *pchip = bl_get_data(bl);\r\nenum lm3630_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif (pwm_ctrl == PWM_CTRL_BANK_B || pwm_ctrl == PWM_CTRL_BANK_ALL) {\r\nif (!set_intensity(bl, pchip))\r\ndev_err(pchip->dev,\r\n"no pwm control func. in plat-data\n");\r\n} else {\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nmdelay(1);\r\nret = regmap_write(pchip->regmap,\r\nREG_BRT_B, bl->props.brightness - 1);\r\n}\r\nreturn bl->props.brightness;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lm3630_bank_b_get_brightness(struct backlight_device *bl)\r\n{\r\nunsigned int reg_val;\r\nint brightness, ret;\r\nstruct lm3630_chip_data *pchip = bl_get_data(bl);\r\nenum lm3630_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;\r\nif (pwm_ctrl == PWM_CTRL_BANK_B || pwm_ctrl == PWM_CTRL_BANK_ALL) {\r\nret = regmap_read(pchip->regmap, REG_PWM_OUTHIGH, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbrightness = reg_val & 0x01;\r\nret = regmap_read(pchip->regmap, REG_PWM_OUTLOW, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbrightness = ((brightness << 8) | reg_val) + 1;\r\n} else {\r\nret = regmap_update_bits(pchip->regmap, REG_CTRL, 0x80, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nmdelay(1);\r\nret = regmap_read(pchip->regmap, REG_BRT_B, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbrightness = reg_val + 1;\r\n}\r\nbl->props.brightness = brightness;\r\nreturn bl->props.brightness;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lm3630_backlight_register(struct lm3630_chip_data *pchip,\r\nenum lm3630_leds ledno)\r\n{\r\nconst char *name = bled_name[ledno];\r\nstruct backlight_properties props;\r\nstruct lm3630_platform_data *pdata = pchip->pdata;\r\nprops.type = BACKLIGHT_RAW;\r\nswitch (ledno) {\r\ncase BLED_1:\r\ncase BLED_ALL:\r\nprops.brightness = pdata->init_brt_led1;\r\nprops.max_brightness = pdata->max_brt_led1;\r\npchip->bled1 =\r\nbacklight_device_register(name, pchip->dev, pchip,\r\n&lm3630_bank_a_ops, &props);\r\nif (IS_ERR(pchip->bled1))\r\nreturn PTR_ERR(pchip->bled1);\r\nbreak;\r\ncase BLED_2:\r\nprops.brightness = pdata->init_brt_led2;\r\nprops.max_brightness = pdata->max_brt_led2;\r\npchip->bled2 =\r\nbacklight_device_register(name, pchip->dev, pchip,\r\n&lm3630_bank_b_ops, &props);\r\nif (IS_ERR(pchip->bled2))\r\nreturn PTR_ERR(pchip->bled2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lm3630_backlight_unregister(struct lm3630_chip_data *pchip)\r\n{\r\nif (pchip->bled1)\r\nbacklight_device_unregister(pchip->bled1);\r\nif (pchip->bled2)\r\nbacklight_device_unregister(pchip->bled2);\r\n}\r\nstatic int lm3630_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm3630_platform_data *pdata = client->dev.platform_data;\r\nstruct lm3630_chip_data *pchip;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "fail : i2c functionality check...\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "fail : no platform data.\n");\r\nreturn -ENODATA;\r\n}\r\npchip = devm_kzalloc(&client->dev, sizeof(struct lm3630_chip_data),\r\nGFP_KERNEL);\r\nif (!pchip)\r\nreturn -ENOMEM;\r\npchip->pdata = pdata;\r\npchip->dev = &client->dev;\r\npchip->regmap = devm_regmap_init_i2c(client, &lm3630_regmap);\r\nif (IS_ERR(pchip->regmap)) {\r\nret = PTR_ERR(pchip->regmap);\r\ndev_err(&client->dev, "fail : allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, pchip);\r\nret = lm3630_chip_init(pchip);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail : init chip\n");\r\ngoto err_chip_init;\r\n}\r\nswitch (pdata->bank_a_ctrl) {\r\ncase BANK_A_CTRL_ALL:\r\nret = lm3630_backlight_register(pchip, BLED_ALL);\r\npdata->bank_b_ctrl = BANK_B_CTRL_DISABLE;\r\nbreak;\r\ncase BANK_A_CTRL_LED1:\r\nret = lm3630_backlight_register(pchip, BLED_1);\r\nbreak;\r\ncase BANK_A_CTRL_LED2:\r\nret = lm3630_backlight_register(pchip, BLED_2);\r\npdata->bank_b_ctrl = BANK_B_CTRL_DISABLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto err_bl_reg;\r\nif (pdata->bank_b_ctrl && pchip->bled2 == NULL) {\r\nret = lm3630_backlight_register(pchip, BLED_2);\r\nif (ret < 0)\r\ngoto err_bl_reg;\r\n}\r\npchip->irq = client->irq;\r\nif (pchip->irq)\r\nlm3630_intr_config(pchip);\r\ndev_info(&client->dev, "LM3630 backlight register OK.\n");\r\nreturn 0;\r\nerr_bl_reg:\r\ndev_err(&client->dev, "fail : backlight register.\n");\r\nlm3630_backlight_unregister(pchip);\r\nerr_chip_init:\r\nreturn ret;\r\n}\r\nstatic int lm3630_remove(struct i2c_client *client)\r\n{\r\nint ret;\r\nstruct lm3630_chip_data *pchip = i2c_get_clientdata(client);\r\nret = regmap_write(pchip->regmap, REG_BRT_A, 0);\r\nif (ret < 0)\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nret = regmap_write(pchip->regmap, REG_BRT_B, 0);\r\nif (ret < 0)\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nlm3630_backlight_unregister(pchip);\r\nif (pchip->irq) {\r\nfree_irq(pchip->irq, pchip);\r\nflush_workqueue(pchip->irqthread);\r\ndestroy_workqueue(pchip->irqthread);\r\n}\r\nreturn 0;\r\n}
