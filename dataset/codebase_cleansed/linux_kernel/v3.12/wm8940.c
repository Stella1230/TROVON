static int wm8940_volatile_register(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8940_SOFTRESET:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int wm8940_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret;\r\nret = snd_soc_dapm_new_controls(dapm, wm8940_dapm_widgets,\r\nARRAY_SIZE(wm8940_dapm_widgets));\r\nif (ret)\r\ngoto error_ret;\r\nret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int wm8940_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = snd_soc_read(codec, WM8940_IFACE) & 0xFE67;\r\nu16 clk = snd_soc_read(codec, WM8940_CLOCK) & 0x1fe;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nclk |= 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8940_CLOCK, clk);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= (2 << 3);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= (1 << 3);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= (3 << 3);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= (3 << 3) | (1 << 7);\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= (1 << 7);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= (1 << 8);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= (1 << 8) | (1 << 7);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, WM8940_IFACE, iface);\r\nreturn 0;\r\n}\r\nstatic int wm8940_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 iface = snd_soc_read(codec, WM8940_IFACE) & 0xFD9F;\r\nu16 addcntrl = snd_soc_read(codec, WM8940_ADDCNTRL) & 0xFFF1;\r\nu16 companding = snd_soc_read(codec,\r\nWM8940_COMPANDINGCTL) & 0xFFDF;\r\nint ret;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE\r\n&& params_channels(params) == 2)\r\niface |= (1 << 9);\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\naddcntrl |= (0x5 << 1);\r\nbreak;\r\ncase 11025:\r\naddcntrl |= (0x4 << 1);\r\nbreak;\r\ncase 16000:\r\naddcntrl |= (0x3 << 1);\r\nbreak;\r\ncase 22050:\r\naddcntrl |= (0x2 << 1);\r\nbreak;\r\ncase 32000:\r\naddcntrl |= (0x1 << 1);\r\nbreak;\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\n}\r\nret = snd_soc_write(codec, WM8940_ADDCNTRL, addcntrl);\r\nif (ret)\r\ngoto error_ret;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\ncompanding = companding | (1 << 5);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface |= (1 << 5);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface |= (2 << 5);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\niface |= (3 << 5);\r\nbreak;\r\n}\r\nret = snd_soc_write(codec, WM8940_COMPANDINGCTL, companding);\r\nif (ret)\r\ngoto error_ret;\r\nret = snd_soc_write(codec, WM8940_IFACE, iface);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int wm8940_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 mute_reg = snd_soc_read(codec, WM8940_DAC) & 0xffbf;\r\nif (mute)\r\nmute_reg |= 0x40;\r\nreturn snd_soc_write(codec, WM8940_DAC, mute_reg);\r\n}\r\nstatic int wm8940_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 val;\r\nu16 pwr_reg = snd_soc_read(codec, WM8940_POWER1) & 0x1F0;\r\nint ret = 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\npwr_reg |= (1 << 2) | (1 << 3);\r\nval = snd_soc_read(codec, WM8940_OUTPUTCTL);\r\nret = snd_soc_write(codec, WM8940_OUTPUTCTL, val | 0x2);\r\nif (ret)\r\nbreak;\r\nret = snd_soc_write(codec, WM8940_POWER1, pwr_reg | 0x1);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\npwr_reg |= (1 << 2) | (1 << 3);\r\nret = snd_soc_write(codec, WM8940_POWER1, pwr_reg | 0x1);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = snd_soc_cache_sync(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\npwr_reg |= (1 << 2) | (1 << 3);\r\nret = snd_soc_write(codec, WM8940_POWER1, pwr_reg | 0x2);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = snd_soc_write(codec, WM8940_POWER1, pwr_reg);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn ret;\r\n}\r\nstatic void pll_factors(unsigned int target, unsigned int source)\r\n{\r\nunsigned long long Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\nNdiv = target / source;\r\nif (Ndiv > 12) {\r\nsource <<= 1;\r\npll_div.pre_scale = 0;\r\nNdiv = target / source;\r\n} else if (Ndiv < 3) {\r\nsource >>= 2;\r\npll_div.pre_scale = 3;\r\nNdiv = target / source;\r\n} else if (Ndiv < 6) {\r\nsource >>= 1;\r\npll_div.pre_scale = 2;\r\nNdiv = target / source;\r\n} else\r\npll_div.pre_scale = 1;\r\nif ((Ndiv < 6) || (Ndiv > 12))\r\nprintk(KERN_WARNING\r\n"WM8940 N value %d outwith recommended range!d\n",\r\nNdiv);\r\npll_div.n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div.k = K;\r\n}\r\nstatic int wm8940_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nreg = snd_soc_read(codec, WM8940_POWER1);\r\nsnd_soc_write(codec, WM8940_POWER1, reg & 0x1df);\r\nif (freq_in == 0 || freq_out == 0) {\r\nreg = snd_soc_read(codec, WM8940_CLOCK);\r\nsnd_soc_write(codec, WM8940_CLOCK, reg & 0x0ff);\r\nsnd_soc_write(codec, WM8940_PLLN, (1 << 7));\r\nreturn 0;\r\n}\r\npll_factors(freq_out*4, freq_in);\r\nif (pll_div.k)\r\nsnd_soc_write(codec, WM8940_PLLN,\r\n(pll_div.pre_scale << 4) | pll_div.n | (1 << 6));\r\nelse\r\nsnd_soc_write(codec, WM8940_PLLN,\r\n(pll_div.pre_scale << 4) | pll_div.n);\r\nsnd_soc_write(codec, WM8940_PLLK1, pll_div.k >> 18);\r\nsnd_soc_write(codec, WM8940_PLLK2, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8940_PLLK3, pll_div.k & 0x1ff);\r\nreg = snd_soc_read(codec, WM8940_POWER1);\r\nsnd_soc_write(codec, WM8940_POWER1, reg | 0x020);\r\nreg = snd_soc_read(codec, WM8940_CLOCK);\r\nsnd_soc_write(codec, WM8940_CLOCK, reg | 0x100);\r\nreturn 0;\r\n}\r\nstatic int wm8940_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8940_priv *wm8940 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase 11289600:\r\ncase 12000000:\r\ncase 12288000:\r\ncase 16934400:\r\ncase 18432000:\r\nwm8940->sysclk = freq;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8940_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nint ret = 0;\r\nswitch (div_id) {\r\ncase WM8940_BCLKDIV:\r\nreg = snd_soc_read(codec, WM8940_CLOCK) & 0xFFE3;\r\nret = snd_soc_write(codec, WM8940_CLOCK, reg | (div << 2));\r\nbreak;\r\ncase WM8940_MCLKDIV:\r\nreg = snd_soc_read(codec, WM8940_CLOCK) & 0xFF1F;\r\nret = snd_soc_write(codec, WM8940_CLOCK, reg | (div << 5));\r\nbreak;\r\ncase WM8940_OPCLKDIV:\r\nreg = snd_soc_read(codec, WM8940_GPIO) & 0xFFCF;\r\nret = snd_soc_write(codec, WM8940_GPIO, reg | (div << 4));\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wm8940_suspend(struct snd_soc_codec *codec)\r\n{\r\nreturn wm8940_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\n}\r\nstatic int wm8940_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8940_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8940_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8940_priv *wm8940 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8940_setup_data *pdata = codec->dev->platform_data;\r\nint ret;\r\nu16 reg;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8940->control_type);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wm8940_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nwm8940_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nret = snd_soc_write(codec, WM8940_POWER1, 0x180);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!pdata)\r\ndev_warn(codec->dev, "No platform data supplied\n");\r\nelse {\r\nreg = snd_soc_read(codec, WM8940_OUTPUTCTL);\r\nret = snd_soc_write(codec, WM8940_OUTPUTCTL, reg | pdata->vroi);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = snd_soc_add_codec_controls(codec, wm8940_snd_controls,\r\nARRAY_SIZE(wm8940_snd_controls));\r\nif (ret)\r\nreturn ret;\r\nret = wm8940_add_widgets(codec);\r\nreturn ret;\r\n}\r\nstatic int wm8940_remove(struct snd_soc_codec *codec)\r\n{\r\nwm8940_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8940_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8940_priv *wm8940;\r\nint ret;\r\nwm8940 = devm_kzalloc(&i2c->dev, sizeof(struct wm8940_priv),\r\nGFP_KERNEL);\r\nif (wm8940 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8940);\r\nwm8940->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8940, &wm8940_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8940_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
